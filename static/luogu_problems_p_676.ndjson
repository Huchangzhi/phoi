{"pid": "P14706", "type": "P", "difficulty": 6, "samples": [["6 3\n1 2 4\n1 3 3\n1 4 2\n4 5 1\n4 6 2\n1 1 0 0 1 0", "-1 3 2 3 6"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2023", "ICPC"], "title": "[ICPC 2023 Tehran R] Cup of Tea", "background": "", "description": "Abolf lives in Aboland, a country consisting of $n$ cities and $n-1$ two-way roads. In Aboland, one can travel from any city to any other city using these roads. Aboland's cities are numbered from 1 to $n$.\n\nAbolbucks is a multinational chain of teahouses which serves the best tea in the world. When Abolf enters a city with an Abolbucks branch, he drinks a cup of tea and instantly reaches $k$ units of happiness. However, each time Abolf travels through the $i^{th}$ road, he must pay $c_i$ coins as toll which causes him to lose $c_i$ units of happiness.\n\nAbolf currently resides in city 1 and wants to plan his summer trip. If at any point during his trip Abolf's happiness drops below zero, he would stops his trip immediately. For each city $t$ (for $2 \\leq t \\leq n$), Abolf wants to know what is the minimum amount of coins he should pay to reach city $t$ while making sure that his happiness remains non-negative at all time, including at the destination. He has asked you to find this amount for each city except for his home city. Note that each destination should be considered separately. Also, he may visit a city multiple times during his trip.\n", "inputFormat": "The first line of input contains two integers $n$ and $k$ ($2 \\leq n \\leq 3 \\cdot 10^5$, $1 \\leq k \\leq 10^9$), the number of cities in Aboland and Abolf's happiness after he drinks a cup of tea, respectively. Each of the next $n-1$ lines contains three space-separated integers $v_i$, $u_i$, and $c_i$ ($1 \\leq v_i, u_i \\leq n$, $1 \\leq c_i \\leq 10^9$, $u_i \\neq v_i$) indicating that the $i^{th}$ road connects city $u_i$ and city $v_i$, and Abolf should pay $c_i$ coins each time he travels through this road. The last line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\leq a_i \\leq 1$). If $a_i = 1$, there is an Abolbucks branch in city $i$. It is guaranteed that $a_1 = 1$.\n", "outputFormat": "In the only line of the output, you should print $n-1$ integers. The $i^{th}$ number should be the minimum amount of coins it takes for Abolf to reach city $i+1$ from city 1. If there is no way to reach city $i+1$ such that Abolf's happiness remains non-negative at all time, print $-1$ for that city.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2023 Tehran R] Cup of Tea", "background": "", "description": "Abolf lives in Aboland, a country consisting of $n$ cities and $n-1$ two-way roads. In Aboland, one can travel from any city to any other city using these roads. Aboland's cities are numbered from 1 to $n$.\n\nAbolbucks is a multinational chain of teahouses which serves the best tea in the world. When Abolf enters a city with an Abolbucks branch, he drinks a cup of tea and instantly reaches $k$ units of happiness. However, each time Abolf travels through the $i^{th}$ road, he must pay $c_i$ coins as toll which causes him to lose $c_i$ units of happiness.\n\nAbolf currently resides in city 1 and wants to plan his summer trip. If at any point during his trip Abolf's happiness drops below zero, he would stops his trip immediately. For each city $t$ (for $2 \\leq t \\leq n$), Abolf wants to know what is the minimum amount of coins he should pay to reach city $t$ while making sure that his happiness remains non-negative at all time, including at the destination. He has asked you to find this amount for each city except for his home city. Note that each destination should be considered separately. Also, he may visit a city multiple times during his trip.\n", "inputFormat": "The first line of input contains two integers $n$ and $k$ ($2 \\leq n \\leq 3 \\cdot 10^5$, $1 \\leq k \\leq 10^9$), the number of cities in Aboland and Abolf's happiness after he drinks a cup of tea, respectively. Each of the next $n-1$ lines contains three space-separated integers $v_i$, $u_i$, and $c_i$ ($1 \\leq v_i, u_i \\leq n$, $1 \\leq c_i \\leq 10^9$, $u_i \\neq v_i$) indicating that the $i^{th}$ road connects city $u_i$ and city $v_i$, and Abolf should pay $c_i$ coins each time he travels through this road. The last line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\leq a_i \\leq 1$). If $a_i = 1$, there is an Abolbucks branch in city $i$. It is guaranteed that $a_1 = 1$.\n", "outputFormat": "In the only line of the output, you should print $n-1$ integers. The $i^{th}$ number should be the minimum amount of coins it takes for Abolf to reach city $i+1$ from city 1. If there is no way to reach city $i+1$ such that Abolf's happiness remains non-negative at all time, print $-1$ for that city.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2023 Tehran R] Cup of Tea", "background": "", "description": "Abolf 生活在阿博兰德，这是一个由 $n$ 个城市和 $n-1$ 条双向道路组成的国家。在阿博兰德，人们可以通过这些道路从任何一个城市前往任何其他城市。阿博兰德的城市编号从 $1$ 到 $n$。\n\nAbolbucks 是一家跨国茶馆连锁店，提供世界上最好的茶。当 Abolf 进入一个有 Abolbucks 分店的城市时，他会喝一杯茶并瞬间达到 $k$ 单位的幸福感。然而，每次 Abolf 经过第 $i$ 条道路时，他必须支付 $c_i$ 硬币作为通行费，这会导致他失去 $c_i$ 单位的幸福感。\n\nAbolf 目前居住在城市 $1$，并计划他的夏季旅行。如果在旅途中的任何时刻，Abolf 的幸福感降至零以下，他将立即停止旅行。对于每个城市 $t$（$2 \\leq t \\leq n$），Abolf 想知道，为了确保他在整个旅途（包括目的地）中的幸福感始终保持非负，他需要支付的最小硬币数量是多少才能到达城市 $t$。他请你找出除他家乡城市外每个城市的这个数量。注意，每个目的地应单独考虑。此外，他在旅途中可以多次访问一个城市。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $k$ ($2 \\leq n \\leq 3 \\cdot 10^5$, $1 \\leq k \\leq 10^9$)，分别表示阿博兰德的城市数量以及 Abolf 喝了一杯茶后获得的幸福感。接下来的 $n-1$ 行每行包含三个用空格分隔的整数 $v_i$、$u_i$ 和 $c_i$ ($1 \\leq v_i, u_i \\leq n$, $1 \\leq c_i \\leq 10^9$, $u_i \\neq v_i$)，表示第 $i$ 条道路连接城市 $u_i$ 和 $v_i$，且 Abolf 每次经过这条道路需支付 $c_i$ 硬币。最后一行包含 $n$ 个整数 $a_1, a_2, \\ldots, a_n$ ($0 \\leq a_i \\leq 1$)。如果 $a_i = 1$，则表示城市 $i$ 有一家 Abolbucks 分店。保证 $a_1 = 1$。\n", "outputFormat": "在输出的唯一一行中，你应该打印 $n-1$ 个整数。第 $i$ 个数应该是 Abolf 从城市 $1$ 到达城市 $i+1$ 所需的最小硬币数量。如果无法在 Abolf 的幸福感始终保持非负的条件下到达城市 $i+1$，则对于该城市输出 $-1$。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14707", "type": "P", "difficulty": 5, "samples": [["11\n0 0\n2 10\n4 5\n6 7\n8 8\n10 4\n12 6\n14 4\n15 4\n16 7\n17 0", "53.666667"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["计算几何", "2023", "Special Judge", "凸包", "ICPC"], "title": "[ICPC 2023 Tehran R] Largest Triangle", "background": "", "description": "A \"terrain\" is an $x$-monotone polygon defined by the points $p_1, \\ldots, p_n$ where each point $p_i$ has coordinates $(x_i, y_i)$, and the following three conditions hold:\n\n- $y_1 = y_n = 0$\n- $y_i > 0$ for $1 < i < n$\n- $x_i < x_{i+1}$ for $1 \\leq i < n$\n\nGiven a terrain defined by the points $p_1, \\ldots, p_n$, find the largest triangle that fits entirely within the terrain, and one of its three vertices is positioned at one of the terrain points $p_2$ through $p_{n-1}$.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/o5mnrvkd.png)\n:::", "inputFormat": "The first line of input contains an integer $n$, representing the number of points in the terrain ($3 \\leq n \\leq 10^5$). The $i^{th}$ line in the following $n$ lines consists of two space-separated integers $x_i$ and $y_i$, representing the point $p_i$ of the terrain ($0 \\leq x_i, y_i \\leq 10^9$).\n", "outputFormat": "Print the area of the largest triangle contained within the terrain. Your output will be considered correct if its absolute or relative error is at most $10^{-6}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2023 Tehran R] Largest Triangle", "background": "", "description": "A \"terrain\" is an $x$-monotone polygon defined by the points $p_1, \\ldots, p_n$ where each point $p_i$ has coordinates $(x_i, y_i)$, and the following three conditions hold:\n\n- $y_1 = y_n = 0$\n- $y_i > 0$ for $1 < i < n$\n- $x_i < x_{i+1}$ for $1 \\leq i < n$\n\nGiven a terrain defined by the points $p_1, \\ldots, p_n$, find the largest triangle that fits entirely within the terrain, and one of its three vertices is positioned at one of the terrain points $p_2$ through $p_{n-1}$.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/o5mnrvkd.png)\n:::", "inputFormat": "The first line of input contains an integer $n$, representing the number of points in the terrain ($3 \\leq n \\leq 10^5$). The $i^{th}$ line in the following $n$ lines consists of two space-separated integers $x_i$ and $y_i$, representing the point $p_i$ of the terrain ($0 \\leq x_i, y_i \\leq 10^9$).\n", "outputFormat": "Print the area of the largest triangle contained within the terrain. Your output will be considered correct if its absolute or relative error is at most $10^{-6}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2023 Tehran R] Largest Triangle", "background": "", "description": "一个“地形”是一个 $x$-单调多边形，由点 $p_1, \\ldots, p_n$ 定义，其中每个点 $p_i$ 的坐标为 $(x_i, y_i)$，并且满足以下三个条件：\n\n- $y_1 = y_n = 0$\n- 对于 $1 < i < n$，有 $y_i > 0$\n- 对于 $1 \\leq i < n$，有 $x_i < x_{i+1}$\n\n给定由点 $p_1, \\ldots, p_n$ 定义的地形，找出能够完全放置在地形内的最大三角形，且其三个顶点之一位于地形点 $p_2$ 到 $p_{n-1}$ 中的某一个上。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/o5mnrvkd.png)\n:::", "inputFormat": "输入的第一行包含一个整数 $n$，表示地形中的点数 ($3 \\leq n \\leq 10^5$)。接下来的 $n$ 行中，第 $i$ 行包含两个用空格分隔的整数 $x_i$ 和 $y_i$，表示地形中的点 $p_i$ ($0 \\leq x_i, y_i \\leq 10^9$)。\n", "outputFormat": "输出地形内所能容纳的最大三角形的面积。只要你的输出的绝对或相对误差不超过 $10^{-6}$，即被视为正确。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14708", "type": "P", "difficulty": 4, "samples": [["+-------------------------------------------------+\n|  +-------------------+                          |\n|  |Algorithm Design   |   +-------------------+  |\n|  |  Programming      |   |PROGRAMMING        |  |\n|  |Discrete Structures|   |   Web Prgramming  |  |\n|  |   Data Structures |   |                   |  |\n|  +-------------------+   | DatabaseDesign    |  |\n|                          |Software Test      |  |\n|     +--------------+     |     Patterns      |  |\n|     |    Python    |     +-------------------+  |\n|     +--------------+                            |\n|          +------------------------+             |\n|          |Programming             |             |\n|          |          AI            |             |\n|          |    Algorithm     design|             |\n|          |Database Design         |             |\n|          +------------------------+             |\n+-------------------------------------------------+", "7"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["模拟", "2023", "枚举", "ICPC"], "title": "[ICPC 2023 Tehran R] Micromasters Certificates", "background": "", "description": "The Department of Computer Engineering has provided several micromasters, each containing a curriculum. If a student successfully completes all the courses of a micromaster, he will receive the certificate of that micromaster. A course may be included in the curriculum of several micromasters. Soroush, who only thinks about getting a certificate and doesn't care about the type of certificate, wants to get 3 micromasters certificates by taking the minimum possible number of courses. The micromasters curriculums are posted on the bulletin board. Help Soroush reach his goal according to the micromasters curriculums.\n", "inputFormat": "The input represents a bulletin board. The board consists of at most 400 rows and 400 columns. Each micromasters curriculum is encapsulated in a rectangular box. The boundaries of the bulletin board and the curriculum boxes are represented by characters \"+\", \"-\", and \"|\" for corners, horizontal sides, and vertical sides, respectively. The curriculum boxes are disjoint (with no characters in common) and each has its own boundary. Each line inside a curriculum box contains at most one course name. Course names consist of alphanumeric and space characters. Course names are not case-sensitive, and spaces do not matter in them. For example, \"General math1\" and \"generalMath 1\" are the same. There are at most 50 curriculum boxes and each box contains at most 30 courses. It is guaranteed that there are at least 3 boxes on the board and there is at least 1 course in each box.\n", "outputFormat": "Print a single line containing the minimum number of courses that should be taken by Soroush to get at least 3 certificates.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2023 Tehran R] Micromasters Certificates", "background": "", "description": "The Department of Computer Engineering has provided several micromasters, each containing a curriculum. If a student successfully completes all the courses of a micromaster, he will receive the certificate of that micromaster. A course may be included in the curriculum of several micromasters. Soroush, who only thinks about getting a certificate and doesn't care about the type of certificate, wants to get 3 micromasters certificates by taking the minimum possible number of courses. The micromasters curriculums are posted on the bulletin board. Help Soroush reach his goal according to the micromasters curriculums.\n", "inputFormat": "The input represents a bulletin board. The board consists of at most 400 rows and 400 columns. Each micromasters curriculum is encapsulated in a rectangular box. The boundaries of the bulletin board and the curriculum boxes are represented by characters \"+\", \"-\", and \"|\" for corners, horizontal sides, and vertical sides, respectively. The curriculum boxes are disjoint (with no characters in common) and each has its own boundary. Each line inside a curriculum box contains at most one course name. Course names consist of alphanumeric and space characters. Course names are not case-sensitive, and spaces do not matter in them. For example, \"General math1\" and \"generalMath 1\" are the same. There are at most 50 curriculum boxes and each box contains at most 30 courses. It is guaranteed that there are at least 3 boxes on the board and there is at least 1 course in each box.\n", "outputFormat": "Print a single line containing the minimum number of courses that should be taken by Soroush to get at least 3 certificates.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2023 Tehran R] Micromasters Certificates", "background": "", "description": "计算机工程系提供了若干微硕士项目，每个项目包含一套课程体系。如果一名学生成功完成了某个微硕士项目的所有课程，他将获得该微硕士项目的证书。一门课程可能包含在多个微硕士项目的课程体系中。Soroush 只关心获得证书，而不在乎证书的类型，他希望以尽可能少的课程数量获得 $3$ 个微硕士项目的证书。微硕士项目的课程体系被张贴在公告板上。请根据公告板上的微硕士课程体系帮助 Soroush 实现他的目标。", "inputFormat": "输入表示一个公告板。公告板最多包含 $400$ 行和 $400$ 列。每个微硕士项目的课程体系被封装在一个矩形框中。公告板和课程体系框的边界分别用字符 \"+\"、\"-\" 和 \"|\" 表示角、水平边和垂直边。课程体系框之间互不相交（没有共享字符），每个框都有自己的边界。课程体系框内的每一行最多包含一个课程名称。课程名称由字母数字和空格字符组成。课程名称不区分大小写，其中的空格无关紧要。例如，\"General math1\" 和 \"generalMath 1\" 被视为相同。公告板上最多有 $50$ 个课程体系框，每个框最多包含 $30$ 门课程。保证公告板上至少有 $3$ 个框，且每个框内至少有 $1$ 门课程。", "outputFormat": "输出一行，表示 Soroush 为获得至少 $3$ 个证书所需修读的最少课程数量。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14709", "type": "P", "difficulty": 6, "samples": [["4\n3\n5\n10\n20", "4\n16\n1728\n23887872"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "ICPC"], "title": "[ICPC 2023 Tehran R] Jackson House", "background": "", "description": "Jackson, after witnessing the advancements in the world of technology, decided to sell his small cozy house and enroll in the programming-and-algorithm micromaster. He came across an interesting algorithm that he needed to analyze and solve the problem related to it, in order to pass the exam at this stage of the course. The pseudocode of this algorithm is as follows:\n\n$$\n\\begin{array}{l}\n\\textbf{input:} \\text{ a permutation } \\pi = \\langle \\pi_1, \\pi_2, \\ldots, \\pi_n \\rangle \\text{ of numbers } \\{1, 2, \\ldots, n\\} \\\\\n\\textbf{while } \\pi \\text{ is changing during this iteration:} \\\\\n\\quad \\textbf{for } i := n \\textbf{ downto } 2: \\\\\n\\quad\\quad \\textbf{if } \\pi_i < \\pi_{\\lfloor i/2 \\rfloor}: \\\\\n\\quad\\quad\\quad \\text{swap}(\\pi_i, \\pi_{\\lfloor i/2 \\rfloor})\n\\end{array}\n$$\n\nHe wants to know for how many permutations $\\pi$ of length $n$ from the possible $n!$ ones, the final permutation will be sorted after running this algorithm.", "inputFormat": "The first line contains an integer $t$ ($1 \\leq t \\leq 100$), the number of test cases.\n\nEach of the next $t$ lines contains an integer $n_i$ ($2 \\leq n_i \\leq 10^9$), representing the length of the permutation for the $i^{th}$ test case.\n", "outputFormat": "Output $t$ lines. On the $i^{th}$ line, print the number of permutations of length $n_i$ which will be sorted after running the provided algorithm on it. Since the output could be very large, output the result modulo $10^9 + 7$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2023 Tehran R] Jackson House", "background": "", "description": "Jackson, after witnessing the advancements in the world of technology, decided to sell his small cozy house and enroll in the programming-and-algorithm micromaster. He came across an interesting algorithm that he needed to analyze and solve the problem related to it, in order to pass the exam at this stage of the course. The pseudocode of this algorithm is as follows:\n\n$$\n\\begin{array}{l}\n\\textbf{input:} \\text{ a permutation } \\pi = \\langle \\pi_1, \\pi_2, \\ldots, \\pi_n \\rangle \\text{ of numbers } \\{1, 2, \\ldots, n\\} \\\\\n\\textbf{while } \\pi \\text{ is changing during this iteration:} \\\\\n\\quad \\textbf{for } i := n \\textbf{ downto } 2: \\\\\n\\quad\\quad \\textbf{if } \\pi_i < \\pi_{\\lfloor i/2 \\rfloor}: \\\\\n\\quad\\quad\\quad \\text{swap}(\\pi_i, \\pi_{\\lfloor i/2 \\rfloor})\n\\end{array}\n$$\n\nHe wants to know for how many permutations $\\pi$ of length $n$ from the possible $n!$ ones, the final permutation will be sorted after running this algorithm.", "inputFormat": "The first line contains an integer $t$ ($1 \\leq t \\leq 100$), the number of test cases.\n\nEach of the next $t$ lines contains an integer $n_i$ ($2 \\leq n_i \\leq 10^9$), representing the length of the permutation for the $i^{th}$ test case.\n", "outputFormat": "Output $t$ lines. On the $i^{th}$ line, print the number of permutations of length $n_i$ which will be sorted after running the provided algorithm on it. Since the output could be very large, output the result modulo $10^9 + 7$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2023 Tehran R] Jackson House", "background": "", "description": "Jackson 在见证了科技世界的发展后，决定卖掉他舒适的小房子，并报名参加编程与算法微硕士项目。他遇到了一个有趣的算法，为了通过该课程此阶段的考试，他需要分析并解决与之相关的问题。该算法的伪代码如下：\n\n$$\n\\begin{array}{l}\n\\textbf{输入：} \\text{ 一个数字 } \\{1, 2, \\ldots, n\\} \\text{ 的排列 } \\pi = \\langle \\pi_1, \\pi_2, \\ldots, \\pi_n \\rangle \\\\\n\\textbf{while } \\pi \\text{ 在本轮迭代中发生变化：} \\\\\n\\quad \\textbf{for } i := n \\textbf{ downto } 2: \\\\\n\\quad\\quad \\textbf{if } \\pi_i < \\pi_{\\lfloor i/2 \\rfloor}: \\\\\n\\quad\\quad\\quad \\text{交换}(\\pi_i, \\pi_{\\lfloor i/2 \\rfloor})\n\\end{array}\n$$\n\n他想知道，在长度为 $n$ 的所有 $n!$ 种可能排列 $\\pi$ 中，有多少种排列在运行此算法后最终会变为有序排列。", "inputFormat": "第一行包含一个整数 $t$ ($1 \\leq t \\leq 100$)，表示测试用例的数量。\n\n接下来的 $t$ 行每行包含一个整数 $n_i$ ($2 \\leq n_i \\leq 10^9$)，表示第 $i$ 个测试用例中排列的长度。\n", "outputFormat": "输出 $t$ 行。在第 $i$ 行中，输出长度为 $n_i$ 的排列中，在运行所提供的算法后会变为有序排列的数量。由于输出可能非常大，请将结果对 $10^9 + 7$ 取模后输出。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14710", "type": "P", "difficulty": 3, "samples": [["8 10\n.W...BB...\nW..B.WB...\n.B.WB...W.\n.B..B.....\n..W...BB..\nB.B..B.W.W\n.WB.W...B.\n..W..BW.B.", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "ICPC"], "title": "[ICPC 2023 Tehran R] Star Wars", "background": "", "description": "Amirreza is playing the Star Wars game. This game is played on an $n \\times m$ board where each cell is either empty ('$.$'), contains a white piece ('$W$') or a black piece ('$B$'). At start of the game, Amirreza should choose exactly one white piece to play with. Afterwards he can move this piece multiple times to knock out as many black pieces as possible. Suppose the white piece is currently in cell $(i, j)$ of the board; In one move, this piece can go up-left $(i - 1, j - 1)$, up $(i - 1, j)$ or up-right $(i - 1, j + 1)$, provided that cell exists on the board and it does not contain another white piece. If the cell contains a black piece, it will be knocked out. Help Amirreza figure out the maximum number of black pieces he can knock out.\n", "inputFormat": "The first line contains two integers $n$ and $m$ ($1 \\leq n, m \\leq 50$), the number of rows and columns in the board, respectively. This is followed by $n$ lines, each containing $m$ characters. The $j^{th}$ character of the $(i + 1)^{th}$ line represents cell $(i, j)$. Each character is '$W$', '$B$', or '$.$', denoting a white piece, a black piece, or an empty cell, respectively.\n", "outputFormat": "Print a single integer, the maximum number of black pieces Amirreza can knock out.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2023 Tehran R] Star Wars", "background": "", "description": "Amirreza is playing the Star Wars game. This game is played on an $n \\times m$ board where each cell is either empty ('$.$'), contains a white piece ('$W$') or a black piece ('$B$'). At start of the game, Amirreza should choose exactly one white piece to play with. Afterwards he can move this piece multiple times to knock out as many black pieces as possible. Suppose the white piece is currently in cell $(i, j)$ of the board; In one move, this piece can go up-left $(i - 1, j - 1)$, up $(i - 1, j)$ or up-right $(i - 1, j + 1)$, provided that cell exists on the board and it does not contain another white piece. If the cell contains a black piece, it will be knocked out. Help Amirreza figure out the maximum number of black pieces he can knock out.\n", "inputFormat": "The first line contains two integers $n$ and $m$ ($1 \\leq n, m \\leq 50$), the number of rows and columns in the board, respectively. This is followed by $n$ lines, each containing $m$ characters. The $j^{th}$ character of the $(i + 1)^{th}$ line represents cell $(i, j)$. Each character is '$W$', '$B$', or '$.$', denoting a white piece, a black piece, or an empty cell, respectively.\n", "outputFormat": "Print a single integer, the maximum number of black pieces Amirreza can knock out.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2023 Tehran R] Star Wars", "background": "", "description": "Amirreza 正在玩一款《星球大战》游戏。游戏在一个 $n \\times m$ 的棋盘上进行，棋盘上的每个格子要么是空的（'$.$'），要么包含一个白棋（'$W$'）或一个黑棋（'$B$'）。在游戏开始时，Amirreza 必须恰好选择一个白棋来操作。之后，他可以多次移动这个白棋，以击落尽可能多的黑棋。假设当前白棋位于棋盘的 $(i, j)$ 格子；在一次移动中，该棋子可以走向左上 $(i - 1, j - 1)$、正上 $(i - 1, j)$ 或右上 $(i - 1, j + 1)$ 方向，前提是该格子在棋盘上存在且不包含另一个白棋。如果该格子包含一个黑棋，则该黑棋将被击落。请帮助 Amirreza 计算他最多能击落多少个黑棋。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$ ($1 \\leq n, m \\leq 50$)，分别表示棋盘的行数和列数。接下来是 $n$ 行，每行包含 $m$ 个字符。第 $i+1$ 行的第 $j$ 个字符表示格子 $(i, j)$。每个字符是 '$W$'、'$B$' 或 '$.$'，分别表示白棋、黑棋或空格子。", "outputFormat": "输出一个整数，表示 Amirreza 最多能击落黑棋的数量。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14711", "type": "P", "difficulty": 3, "samples": [["2 5\n2 U\n5 D", "7"], ["4 6\n0 U\n0 D\n6 U\n3 U", "15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "ICPC"], "title": "[ICPC 2023 Tehran R] Pistons", "background": "", "description": "Maryam, a famous mathematician, recently has bought an old vintage car. This car uses a combustion engine to generate the power needed to move the car. Inside the engine, there are $n$ cylinders of length $m$ and inside each cylinder, there is a piston constantly moving up and down. All pistons move independently and at the same speed. At any given time, the position of a piston inside a cylinder can be shown with an integer from 0 to $m$, which also describes the area of the cylinder occupied by the piston. A piston instantly changes its direction when it reaches the top (position $m$) or bottom (position 0) of its cylinder.\n\nMaryam managed to determine the position and direction of all the pistons at a specific time. Now she is curious about the maximum total area occupied by all the pistons. Help Maryam find out this value.\n", "inputFormat": "The first line of input contains two integers $n$ and $m$ ($1 \\leq n \\leq 10^5, 1 \\leq m \\leq 10^6$), describing the number of pistons and the length of cylinders, respectively. Each of the next $n$ lines describe $p_i$ ($0 \\leq p_i \\leq m$), and a character $d_i$ ($d_i \\in \\{U, D\\}$), the initial position of the $i^{th}$ piston and its direction (Up or Down), respectively.\n", "outputFormat": "Print a single integer, the maximum total area occupied by all the pistons.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2023 Tehran R] Pistons", "background": "", "description": "Maryam, a famous mathematician, recently has bought an old vintage car. This car uses a combustion engine to generate the power needed to move the car. Inside the engine, there are $n$ cylinders of length $m$ and inside each cylinder, there is a piston constantly moving up and down. All pistons move independently and at the same speed. At any given time, the position of a piston inside a cylinder can be shown with an integer from 0 to $m$, which also describes the area of the cylinder occupied by the piston. A piston instantly changes its direction when it reaches the top (position $m$) or bottom (position 0) of its cylinder.\n\nMaryam managed to determine the position and direction of all the pistons at a specific time. Now she is curious about the maximum total area occupied by all the pistons. Help Maryam find out this value.\n", "inputFormat": "The first line of input contains two integers $n$ and $m$ ($1 \\leq n \\leq 10^5, 1 \\leq m \\leq 10^6$), describing the number of pistons and the length of cylinders, respectively. Each of the next $n$ lines describe $p_i$ ($0 \\leq p_i \\leq m$), and a character $d_i$ ($d_i \\in \\{U, D\\}$), the initial position of the $i^{th}$ piston and its direction (Up or Down), respectively.\n", "outputFormat": "Print a single integer, the maximum total area occupied by all the pistons.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2023 Tehran R] Pistons", "background": "", "description": "著名数学家 Maryam 最近购买了一辆老式经典汽车。这辆车使用内燃机产生动力以驱动汽车。发动机内部有 $n$ 个长度为 $m$ 的气缸，每个气缸内有一个活塞在不断地上下运动。所有活塞独立且以相同的速度运动。在任何给定时刻，活塞在气缸内的位置可以用 $0$ 到 $m$ 之间的一个整数表示，该整数也描述了活塞所占据的气缸面积。当活塞到达其气缸的顶部（位置 $m$）或底部（位置 $0$）时，它会瞬间改变运动方向。\n\nMaryam 设法确定了所有活塞在某一特定时刻的位置和方向。现在她想知道所有活塞占据的总面积的最大值。请帮助 Maryam 找出这个值。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $m$ ($1 \\leq n \\leq 10^5$, $1 \\leq m \\leq 10^6$)，分别表示活塞的数量和气缸的长度。接下来的 $n$ 行每行描述一个活塞：$p_i$ ($0 \\leq p_i \\leq m$) 和一个字符 $d_i$ ($d_i \\in \\{U, D\\}$)，分别表示第 $i$ 个活塞的初始位置和其方向（向上或向下）。", "outputFormat": "输出一个整数，表示所有活塞占据的总面积的最大值。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14712", "type": "P", "difficulty": 4, "samples": [["7 3\n15000000\n10000000\n30000000\n20000000\n200000\n70000000\n100000000", "2 3 1 2 3 1 1"], ["3 2\n10\n10\n10", "1 1 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "2023", "ICPC"], "title": "[ICPC 2023 Tehran R] Cafebazaar' s Applications", "background": "", "description": "It's the end of the year, and Cafebazaar has released a list, containing the number of users of each of its $n$ applications. Now, each application is eager to showcase its success through an advertisement image, which highlights a continuous subset of the application list containing the application itself. Also, for the image to be credible, it should contain at least $k$ applications, including itself.\n\nFor each application in this list, we need to determine the minimum possible rank this application can achieve within any valid subset, according to the number of users. The rank of an application within a subset is defined by the number of applications in that subset that have more users than it, plus one.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/a8dbzpk9.png)\n:::", "inputFormat": "The first line of input consists of two integers $n$ and $k$ ($1 \\leq k \\leq n \\leq 10^5$), where $n$ represents the total number of applications and $k$ represents the minimum number of applications in an advertisement image. The following $n$ lines contain information about each application: the $i^{th}$ line contains $c_i$, representing the number of users for the $i^{th}$ application ($1 \\leq c_i \\leq 10^8$).", "outputFormat": "In the only line of output print $n$ space-separated integers. The $i^{th}$ integer should be the minimum rank that $i^{th}$ application can achieve within an advertisement image.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2023 Tehran R] Cafebazaar' s Applications", "background": "", "description": "It's the end of the year, and Cafebazaar has released a list, containing the number of users of each of its $n$ applications. Now, each application is eager to showcase its success through an advertisement image, which highlights a continuous subset of the application list containing the application itself. Also, for the image to be credible, it should contain at least $k$ applications, including itself.\n\nFor each application in this list, we need to determine the minimum possible rank this application can achieve within any valid subset, according to the number of users. The rank of an application within a subset is defined by the number of applications in that subset that have more users than it, plus one.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/a8dbzpk9.png)\n:::", "inputFormat": "The first line of input consists of two integers $n$ and $k$ ($1 \\leq k \\leq n \\leq 10^5$), where $n$ represents the total number of applications and $k$ represents the minimum number of applications in an advertisement image. The following $n$ lines contain information about each application: the $i^{th}$ line contains $c_i$, representing the number of users for the $i^{th}$ application ($1 \\leq c_i \\leq 10^8$).", "outputFormat": "In the only line of output print $n$ space-separated integers. The $i^{th}$ integer should be the minimum rank that $i^{th}$ application can achieve within an advertisement image.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2023 Tehran R] Cafebazaar' s Applications", "background": "", "description": "年末，Cafebazaar 发布了一份列表，包含了其 $n$ 个应用程序各自的用户数量。现在，每个应用程序都渴望通过一张广告图片来展示其成功，这张图片突出显示了包含该应用程序自身在内的一个连续应用子集。此外，为了使图片可信，该子集必须包含至少 $k$ 个应用程序（包括自身）。\n\n对于列表中的每个应用程序，我们需要根据用户数量，确定该应用程序在任意有效子集中可能达到的最小排名。应用程序在子集中的排名定义为：在该子集中，用户数量多于它的应用程序数量加 $1$。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/a8dbzpk9.png)\n:::", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $k$ ($1 \\leq k \\leq n \\leq 10^5$)，其中 $n$ 表示应用程序的总数，$k$ 表示广告图片中应用程序的最小数量。接下来的 $n$ 行包含每个应用程序的信息：第 $i$ 行包含 $c_i$，表示第 $i$ 个应用程序的用户数量 ($1 \\leq c_i \\leq 10^8$)。", "outputFormat": "在输出的一行中，打印 $n$ 个用空格分隔的整数。第 $i$ 个整数应为第 $i$ 个应用程序在广告图片中可能达到的最小排名。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14713", "type": "P", "difficulty": 5, "samples": [["BUY (10 apple, 10 carrot, 10 banana, ())\nUNPACK 1\nUNPACK 2\nPACK (3 apple, (5 cArrot, 2 banana))\nPACK (3 apple, (5 carrOt, 1 banana))\nPACK (5 apple, (3 banana))\n? MIN apple\n? MIN CaRRoT\n? CONTAINS apple", "OK\nOK, 1 container added.\nOK, No containers added.\nOK\nOK\nDISCARD\n0\n2\n2"], ["BUY (apple, (banana, 3 carrot))\nBUY ((banana, apple), (banana, carrot))\n? MIN apple\nUNPACK 1\n? COUNT apple\n? COUNT carrot\n? CONTAINS banana", "OK\nOK\n1\nOK, 1 container added.\n1\n0\n2"], ["BUY ((duck 2, carrot), 1 celery)\n? MIN duck\n? MIN carrot\n? MIN celery\n? MIN test\nSELL 10\nPACK (celery)\nUNPACK 1\nUNPACK 1\nPACK (celery)\n? COUNT celery\n? COUNT carrot\n? CONTAINS celery\n? CONTAINS carrot\nBUY ((duck 8, carrot), ((7 duck), celery))\nUNPACK 4\nUNPACK 5\nUNPACK 6\n? COUNT DUCK\n? MIN duck", "OK\n2\n2\n1\n-1\nDISCARD\nDISCARD\nOK, 1 container added.\nDISCARD\nOK\n0\n0\n1\n1\nOK\nOK, 2 containers added.\nOK, No containers added.\nOK, 1 container added.\n8\n0"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "ICPC"], "title": "[ICPC 2023 Tehran R] Monster Warehouse", "background": "", "description": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/s2r0l3if.png)\n:::\n\nMike and Sally work in the warehouse of Monster Inc. as storekeepers. Their daily tasks are to process incoming requests and update the inventory of the Warehouse. Requests only include buying, selling, unpacking, and packing containers. The warehouse includes goods and containers and has unlimited space. A container may contain goods or other containers as sub-containers.\n\nThe exact format of the requests is given below.\n\n- BUY `<CONTAINER_DESCRIPTION>`\n- SELL `<CONTAINER_ID>`\n- UNPACK `<CONTAINER_ID>`\n- PACK `<CONTAINER_DESCRIPTION>`\n\nEach container which is not inside any other container is uniquely identified by a positive integer ID. Assigning IDs to containers is done sequentially and started from 1. An ID is valid if and only if its container exists in the warehouse, otherwise it is invalid.\n\nA container description is enclosed in parentheses and lists the contents, which can be either goods or sub-containers. A good is identified exclusively by its name, which consists of non-case-sensitive English letters. Multiple units of a good may be available. To denote quantities, place a positive integer 'N' before or after the good name (separated by one whitespace), where $N < 100$ is the number of the good. For example, $((tomato, potato), 4 celery, (wood, (silk 3, banana 2)))$ describes a container with four units of celery and two sub-containers.\n\nThe description of each request is as follows:\n\n- BUY: A new container is transferred into the warehouse and an ID is assigned to it.\n- SELL: An existing container with the given ID is ship out and its ID becomes invalid.\n- UNPACK: All goods and sub-containers are extracted from the container and added to the warehouse. Moreover, the sub-containers become new containers and get their own ID. The assignment of IDs to the new containers is based on the order of their appearance in the container description (from left to right). For instance, considering the following two lines as the first requests, results in adding one unit of celery and adding three containers with IDs 2, 3, and 4 to the warehouse and ID 1 becomes invalid.\n\n$$\n\\text{BUY (celery, (Banana), (Celery), (celery))} \\\\\n\\text{UNPACK 1}\n$$\n\n- PACK: Goods specified in a PACK request are grouped into a new container, which is then assigned the next available ID.\n\nMike and Sulley process the requests in the order they are received. Any request with an invalid container ID must be discarded. Moreover, for a PACK request they need to check if there exists enough units of each good in the warehouse.\n\nRoz, the agent of Monster Inc., has told Mike once \"I'm watching you, Wazowski. Always watching, Always.\" She rolled her desk into their office and asked for requests and reports. She is looking for every detail. She is reviewing each request and might ask a few questions. Her questions might be each of the following types:\n\n- `? COUNT <good>`: How many units of the given good exist outside of containers?\n- `? CONTAINS <good>`: How many containers with ID have the given good, i.e. the good is in the container or there is a recursive sub-container which contains that good.\n- `? MIN <good>`: At least how many containers should be unpacked to reach one unit of the good. If it is impossible, the answer should be $-1$.\n\nMike and Sulley are expected to answer these queries using just one integer.\n\nBefore helping Mike and Sulley, read samples carefully.\n", "inputFormat": "The input consists of $n$ requests or queries from Roz while she is reviewing ($1 \\leq n \\leq 5000$); each appears in a separated line. The name of each good is limited to 100 characters. Each container description might have at most 5000 characters and the input size is less than $10^6$ characters.\n", "outputFormat": "Each line of the report is associated with a request or Roz's questions. After each BUY, SELL, PACK, UNPACK request, you should print OK, if the request is not discarded. Otherwise, print DISCARD. If the request is UNPACK, after printing OK, you should print the number of containers added to the warehouse (read samples for more details). For each Roz's query, print just one integer in a line.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2023 Tehran R] Monster Warehouse", "background": "", "description": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/s2r0l3if.png)\n:::\n\nMike and Sally work in the warehouse of Monster Inc. as storekeepers. Their daily tasks are to process incoming requests and update the inventory of the Warehouse. Requests only include buying, selling, unpacking, and packing containers. The warehouse includes goods and containers and has unlimited space. A container may contain goods or other containers as sub-containers.\n\nThe exact format of the requests is given below.\n\n- BUY `<CONTAINER_DESCRIPTION>`\n- SELL `<CONTAINER_ID>`\n- UNPACK `<CONTAINER_ID>`\n- PACK `<CONTAINER_DESCRIPTION>`\n\nEach container which is not inside any other container is uniquely identified by a positive integer ID. Assigning IDs to containers is done sequentially and started from 1. An ID is valid if and only if its container exists in the warehouse, otherwise it is invalid.\n\nA container description is enclosed in parentheses and lists the contents, which can be either goods or sub-containers. A good is identified exclusively by its name, which consists of non-case-sensitive English letters. Multiple units of a good may be available. To denote quantities, place a positive integer 'N' before or after the good name (separated by one whitespace), where $N < 100$ is the number of the good. For example, $((tomato, potato), 4 celery, (wood, (silk 3, banana 2)))$ describes a container with four units of celery and two sub-containers.\n\nThe description of each request is as follows:\n\n- BUY: A new container is transferred into the warehouse and an ID is assigned to it.\n- SELL: An existing container with the given ID is ship out and its ID becomes invalid.\n- UNPACK: All goods and sub-containers are extracted from the container and added to the warehouse. Moreover, the sub-containers become new containers and get their own ID. The assignment of IDs to the new containers is based on the order of their appearance in the container description (from left to right). For instance, considering the following two lines as the first requests, results in adding one unit of celery and adding three containers with IDs 2, 3, and 4 to the warehouse and ID 1 becomes invalid.\n\n$$\n\\text{BUY (celery, (Banana), (Celery), (celery))} \\\\\n\\text{UNPACK 1}\n$$\n\n- PACK: Goods specified in a PACK request are grouped into a new container, which is then assigned the next available ID.\n\nMike and Sulley process the requests in the order they are received. Any request with an invalid container ID must be discarded. Moreover, for a PACK request they need to check if there exists enough units of each good in the warehouse.\n\nRoz, the agent of Monster Inc., has told Mike once \"I'm watching you, Wazowski. Always watching, Always.\" She rolled her desk into their office and asked for requests and reports. She is looking for every detail. She is reviewing each request and might ask a few questions. Her questions might be each of the following types:\n\n- `? COUNT <good>`: How many units of the given good exist outside of containers?\n- `? CONTAINS <good>`: How many containers with ID have the given good, i.e. the good is in the container or there is a recursive sub-container which contains that good.\n- `? MIN <good>`: At least how many containers should be unpacked to reach one unit of the good. If it is impossible, the answer should be $-1$.\n\nMike and Sulley are expected to answer these queries using just one integer.\n\nBefore helping Mike and Sulley, read samples carefully.\n", "inputFormat": "The input consists of $n$ requests or queries from Roz while she is reviewing ($1 \\leq n \\leq 5000$); each appears in a separated line. The name of each good is limited to 100 characters. Each container description might have at most 5000 characters and the input size is less than $10^6$ characters.\n", "outputFormat": "Each line of the report is associated with a request or Roz's questions. After each BUY, SELL, PACK, UNPACK request, you should print OK, if the request is not discarded. Otherwise, print DISCARD. If the request is UNPACK, after printing OK, you should print the number of containers added to the warehouse (read samples for more details). For each Roz's query, print just one integer in a line.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2023 Tehran R] Monster Warehouse", "background": "", "description": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/s2r0l3if.png)\n:::\n\nMike 和 Sally 在怪兽电力公司的仓库担任管理员。他们的日常任务是处理入库请求并更新仓库库存。请求仅包括购买、出售、拆箱和装箱容器。仓库包括货物和容器，且空间无限。一个容器可以包含货物或其他容器作为子容器。\n\n请求的具体格式如下。\n\n- BUY `<CONTAINER_DESCRIPTION>`\n- SELL `<CONTAINER_ID>`\n- UNPACK `<CONTAINER_ID>`\n- PACK `<CONTAINER_DESCRIPTION>`\n\n每个不位于任何其他容器内的容器都由一个唯一的正整数 ID 标识。为容器分配 ID 是顺序进行的，从 $1$ 开始。一个 ID 有效当且仅当其容器存在于仓库中，否则无效。\n\n容器描述用括号括起来，并列出了内容，内容可以是货物或子容器。货物仅通过其名称标识，名称由不区分大小写的英文字母组成。同一种货物可能有多单位。为了表示数量，可在货物名称前或后放置一个正整数 'N'（用一个空格分隔），其中 $N < 100$ 是货物的数量。例如，$((tomato, potato), 4 celery, (wood, (silk 3, banana 2)))$ 描述了一个包含四单位芹菜和两个子容器的容器。\n\n每个请求的描述如下：\n\n- BUY：一个新的容器被转移到仓库中，并分配一个 ID。\n- SELL：将具有给定 ID 的现有容器运出，其 ID 变为无效。\n- UNPACK：从容器中提取所有货物和子容器，并将其添加到仓库中。此外，子容器成为新容器并获得自己的 ID。为新容器分配 ID 基于它们在容器描述中出现的顺序（从左到右）。例如，将以下两行作为前两个请求处理，会导致添加一单位芹菜，并向仓库添加三个 ID 为 $2$、$3$ 和 $4$ 的容器，且 ID $1$ 变为无效。\n\n$$\n\\text{BUY (celery, (Banana), (Celery), (celery))} \\\\\n\\text{UNPACK 1}\n$$\n\n- PACK：将 PACK 请求中指定的货物分组到一个新容器中，然后分配下一个可用的 ID。\n\nMike 和 Sulley 按照接收顺序处理请求。任何具有无效容器 ID 的请求都必须被丢弃。此外，对于 PACK 请求，他们需要检查仓库中每种货物是否有足够的数量。\n\n怪兽电力公司的特工 Roz 曾对 Mike 说过：“我在看着你，瓦索斯基。一直看着，始终看着。”她把她的办公桌推进了他们的办公室，并要求查看请求和报告。她关注每一个细节。她正在审查每个请求，并可能提出一些问题。她的问题可能是以下几种类型之一：\n\n- `? COUNT <good>`：给定货物有多少单位存在于容器之外？\n- `? CONTAINS <good>`：有多少个容器（具有 ID）包含给定货物，即货物在容器内，或存在一个递归的子容器包含该货物。\n- `? MIN <good>`：至少需要拆开多少个容器才能得到一单位该货物。如果不可能，则答案为 $-1$。\n\nMike 和 Sulley 需要使用一个整数来回答这些查询。\n\n在帮助 Mike 和 Sulley 之前，请仔细阅读样例。", "inputFormat": "输入包含 $n$ 个来自 Roz 审查期间的请求或查询 ($1 \\leq n \\leq 5000$)；每个占一行。每种货物的名称长度限制为 $100$ 个字符。每个容器描述最多有 $5000$ 个字符，且输入总大小小于 $10^6$ 个字符。\n", "outputFormat": "报告中的每一行与一个请求或 Roz 的问题相关联。对于每个 BUY、SELL、PACK、UNPACK 请求，如果请求未被丢弃，则打印 OK。否则打印 DISCARD。如果请求是 UNPACK，则在打印 OK 之后，打印添加到仓库的容器数量（更多细节请阅读样例）。对于 Roz 的每个查询，只需在一行中打印一个整数。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14714", "type": "P", "difficulty": 4, "samples": [["3 4\n.23s\n4.2x\nxx.1", "5"], ["2 2\n4s\n22", "1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "ICPC"], "title": "[ICPC 2023 Tehran R] Rolling-Dice Puzzle", "background": "", "description": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/4dwpi5ky.png)\n:::\n\nSarina and her brother, Soroush, are playing the rolling-dice game. The game is played on an $n \\times m$ board. Initially, Soroush places a standard dice in one of the cells. It is place in a way that the number 6 is on the upper face, the number 4 is on the north face, and the number 2 is on the west face. In a standard dice, 6 is on the opposite side of 1, 2 is on the opposite side of 5, and 3 is on the opposite side of 4. Additionally, he selects some of the cells and writes arbitrary integers numbers from 1 to 6 in them.\n\nAfter that, Sarina have to move the dice on the board by rolling it multiple times. The act of rolling is defined as follows: Suppose two adjacent cells $A$ and $B$ share an edge $e$ and the dice is on the cell $A$; The dice can be rolled around its edge incident to $e$ and moved from $A$ to $B$. For example, consider the starting position of the dice. If the dice is rolled around the east, west, north, and south edges, the number appearing on the top face after rolling will be 2, 5, 3, and 4, respectively.\n\nWhenever Sarina moves the dice to a cell with a number in it in such a way that the number on the upper face of the dice matches the number in that cell, she gets a point. Note that Sarina can get a point from each cell at most one. The game is not that simple! There are obstacles in some of the cells and it is not possible to move the dice to the cells with an obstacle in it. Your task is to find out the maximum points that Sarina can get.\n", "inputFormat": "The first line of input contains two integers $n$ and $m$ ($1 \\leq n, m \\leq 100$), indicating the number of rows and columns of the board, respectively. Each of the next $n$ lines contain $m$ characters, describing the board. Empty cells are represented by \".\" and obstacles are represented by \"x\". The starting position of the dice is represented by \"s\" and the selected cells are represented by the integers written in them (from 1 to 6). It is guaranteed that there is only one \"s\" in the input.\n", "outputFormat": "Output a line containing the maximum points Sarina can get.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2023 Tehran R] Rolling-Dice Puzzle", "background": "", "description": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/4dwpi5ky.png)\n:::\n\nSarina and her brother, Soroush, are playing the rolling-dice game. The game is played on an $n \\times m$ board. Initially, Soroush places a standard dice in one of the cells. It is place in a way that the number 6 is on the upper face, the number 4 is on the north face, and the number 2 is on the west face. In a standard dice, 6 is on the opposite side of 1, 2 is on the opposite side of 5, and 3 is on the opposite side of 4. Additionally, he selects some of the cells and writes arbitrary integers numbers from 1 to 6 in them.\n\nAfter that, Sarina have to move the dice on the board by rolling it multiple times. The act of rolling is defined as follows: Suppose two adjacent cells $A$ and $B$ share an edge $e$ and the dice is on the cell $A$; The dice can be rolled around its edge incident to $e$ and moved from $A$ to $B$. For example, consider the starting position of the dice. If the dice is rolled around the east, west, north, and south edges, the number appearing on the top face after rolling will be 2, 5, 3, and 4, respectively.\n\nWhenever Sarina moves the dice to a cell with a number in it in such a way that the number on the upper face of the dice matches the number in that cell, she gets a point. Note that Sarina can get a point from each cell at most one. The game is not that simple! There are obstacles in some of the cells and it is not possible to move the dice to the cells with an obstacle in it. Your task is to find out the maximum points that Sarina can get.\n", "inputFormat": "The first line of input contains two integers $n$ and $m$ ($1 \\leq n, m \\leq 100$), indicating the number of rows and columns of the board, respectively. Each of the next $n$ lines contain $m$ characters, describing the board. Empty cells are represented by \".\" and obstacles are represented by \"x\". The starting position of the dice is represented by \"s\" and the selected cells are represented by the integers written in them (from 1 to 6). It is guaranteed that there is only one \"s\" in the input.\n", "outputFormat": "Output a line containing the maximum points Sarina can get.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2023 Tehran R] Rolling-Dice Puzzle", "background": "", "description": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/4dwpi5ky.png)\n:::\n\nSarina 和她的兄弟 Soroush 正在玩掷骰子游戏。游戏在一个 $n \\times m$ 的棋盘上进行。初始时，Soroush 将一个标准骰子放在棋盘的一个格子中。放置方式是：数字 $6$ 朝上，数字 $4$ 朝北（上），数字 $2$ 朝西（左）。在标准骰子中，$6$ 与 $1$ 相对，$2$ 与 $5$ 相对，$3$ 与 $4$ 相对。此外，他选择了一些格子并在其中任意写入了 $1$ 到 $6$ 之间的整数。\n\n之后，Sarina 需要通过多次滚动骰子在棋盘上移动它。滚动的定义如下：假设两个相邻的格子 $A$ 和 $B$ 共享一条边 $e$，且骰子位于格子 $A$ 上；骰子可以围绕其与 $e$ 相接的边滚动，从而从 $A$ 移动到 $B$。例如，考虑骰子的起始位置。如果骰子围绕东、西、北、南边滚动，滚动后朝上一面的数字将分别为 $2$、$5$、$3$ 和 $4$。\n\n每当 Sarina 将骰子移动到一个写有数字的格子，且骰子朝上一面的数字与该格子中的数字匹配时，她将获得一分。注意，Sarina 每个格子最多只能获得一分。游戏并不那么简单！一些格子中有障碍物，无法将骰子移动到有障碍物的格子中。你的任务是找出 Sarina 可以获得的最大分数。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $m$ ($1 \\leq n, m \\leq 100$)，分别表示棋盘的行数和列数。接下来的 $n$ 行每行包含 $m$ 个字符，描述棋盘。空单元格用 \".\" 表示，障碍物用 \"x\" 表示。骰子的起始位置用 \"s\" 表示，被选中的单元格用其中写入的整数（$1$ 到 $6$）表示。保证输入中只有一个 \"s\"。", "outputFormat": "输出一行，包含 Sarina 可以获得的最大分数。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14715", "type": "P", "difficulty": 4, "samples": [["5\nblue\nred\nblue\nblack\nred", "3"], ["8\npeachfuzz\nlivingcoral\nlivingcoral\nteal\nteal\nlivingcoral\nlivingcoral\ncoral", "5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2023", "ICPC"], "title": "[ICPC 2023 Tehran R] Colorful Intervals", "background": "", "description": "The **Museum of Contemporary Art** is holding a painting gallery focused on modern art, especially Monochromatic style paintings, which use only a single color. The gallery displays $n$ paintings arranged in a line.\n\nThe ICPC wants to bring students on an excursion to the gallery to spark their interest in art. However, the students are programmers, and everyone knows programmers only care about the colors of these modern paintings. They are also somewhat impatient. To keep their attention and to ensure they see every color without overwhelming them, the organizer decided to show them exactly two intervals of painting. This approach balances their short attention span and ensures all colors are represented. The task is to find two intervals of paintings such that each color appears at least once in at least one of the intervals, and the total number of paintings the students need to see is minimized.", "inputFormat": "The input consists of a single line containing a non-negative integer $n$ ($2 \\leq n \\leq 2000$), indicating the number of paintings. This is followed by $n$ lines, each containing a string representing the color of a painting. Each color is represented by a non-empty lowercase string with a length of less than 20. It is guaranteed that there are at least 2 and at most 50 different colors in the input.\n", "outputFormat": "In the output, print the minimum number of paintings the ICPC students need to see, which is the sum of the lengths of the two intervals.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2023 Tehran R] Colorful Intervals", "background": "", "description": "The **Museum of Contemporary Art** is holding a painting gallery focused on modern art, especially Monochromatic style paintings, which use only a single color. The gallery displays $n$ paintings arranged in a line.\n\nThe ICPC wants to bring students on an excursion to the gallery to spark their interest in art. However, the students are programmers, and everyone knows programmers only care about the colors of these modern paintings. They are also somewhat impatient. To keep their attention and to ensure they see every color without overwhelming them, the organizer decided to show them exactly two intervals of painting. This approach balances their short attention span and ensures all colors are represented. The task is to find two intervals of paintings such that each color appears at least once in at least one of the intervals, and the total number of paintings the students need to see is minimized.", "inputFormat": "The input consists of a single line containing a non-negative integer $n$ ($2 \\leq n \\leq 2000$), indicating the number of paintings. This is followed by $n$ lines, each containing a string representing the color of a painting. Each color is represented by a non-empty lowercase string with a length of less than 20. It is guaranteed that there are at least 2 and at most 50 different colors in the input.\n", "outputFormat": "In the output, print the minimum number of paintings the ICPC students need to see, which is the sum of the lengths of the two intervals.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2023 Tehran R] Colorful Intervals", "background": "", "description": "**当代艺术博物馆** 正在举办一场专注于现代艺术，尤其是单色风格绘画的绘画展。该展览呈线性排列展示了 $n$ 幅画作。\n\nICPC 计划组织学生参观画廊，以激发他们对艺术的兴趣。然而，学生们都是程序员，众所周知，程序员只关心这些现代画作的颜色。他们也有些缺乏耐心。为了保持他们的注意力，并确保他们在不过度疲劳的情况下看到每种颜色，组织者决定只向他们展示恰好两个画作区间。这种方法平衡了他们短暂的注意力跨度，并保证了所有颜色都被呈现。任务是找到两个画作区间，使得每种颜色至少在其中一个区间中出现至少一次，并且学生们需要看到的画作总数最小。", "inputFormat": "输入的第一行包含一个非负整数 $n$ ($2 \\leq n \\leq 2000$)，表示画作的数量。随后是 $n$ 行，每行包含一个字符串，表示一幅画作的颜色。每种颜色由一个长度小于 $20$ 的非空小写字符串表示。保证输入中至少出现 $2$ 种且最多 $50$ 种不同的颜色。", "outputFormat": "在输出中，打印 ICPC 学生需要看到的最少画作数量，即两个区间长度之和。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14716", "type": "P", "difficulty": 6, "samples": [["5 3\n1 10 3 8 6\n0 1\n1 2\n2 3\n2 4", "1"], ["20 30 \n13 36 11 35 4 9 42 9 1 4 11 3 15 31 46 41 31 17 11 12\n19 5\n19 0\n19 13\n19 9\n19 4\n19 10\n5 1\n19 18\n0 7\n5 8\n19 12\n5 17\n13 16\n5 14\n13 3\n19 6\n5 15\n5 2\n4 11", "3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2025", "交互题", "最近公共祖先 LCA", "树链剖分", "Ad-hoc", "RMI（罗马尼亚）"], "title": "[RMI 2025] 电缆维护 / Engineers", "background": "由于官方未提供时限和空限，将 TL 设置为 std 的两倍，ML 设置为 2G。\n", "description": "\n给定一棵 $N$ 个点的树，点编号 $0\\sim N-1$。点 $i$ 有正整数点权 $C_i$。\n\n给定正整数 $D$。构造若干条**简单**路径（点集可以有交），使得未被路径覆盖的点的点权差值不大于 $D$。\n\n形式化地说，设未被覆盖的点集为 $R$，你需要保证 $\\forall i,j\\in R$，都有 $|C_i-C_j|\\le D$。\n\n在满足上述条件的前提下最小化路径数量。只需要求出路径数量。\n\n### 实现细节\n\n这是一道（函数式）交互题。你不需要，也不应该定义 `main` 函数。\n\n你需要实现函数\n\n```cpp\nint solve(int N, int D, std::vector<int> C, std::vector<int> P, std::vector<int> Q)\n```\n\n该函数接收以下参数：\n- 点数 $N$；\n- 最大可接受差值 $D$；\n- 点权 $C$；\n- 两个长度为 $N-1$ 的 `vector<int>` $P$ 和 $Q$，表示对所有 $0 \\le i \\le N-1$，存在树边 $(P_i,Q_i)$。\n\n返回符合条件的路径的最少数量。\n\n", "inputFormat": "见「实现细节」。", "outputFormat": "见「实现细节」。", "hint": "\n\n### 样例解释\n\n在样例一中，有 $N=5$ 且 $D=3$。树的结构如图所示：\n\n::::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/0v5nanlt.png)\n::::\n\n一种合法的方案为构造路径 $[0,1,2,3]$。\n\n\n### 限制条件\n* $1 \\le N \\le 200\\,000$。\n* 对所有 $0 \\le i \\le N-1$ ，有 $1 \\le C_i \\le 1\\,000\\,000\\,000$。\n* $1 \\le D \\le 1\\,000\\,000\\,000$。\n* $0 \\le p_i, q_i < N$ ，$p_i \\ne q_i$，且 $(p_i, q_i)$ 互不相同。\n\n### 子任务\n\n| # | 分值 | 约束 |\n|:---:|:---:|:---|\n| $1$ | $7 $ | $N \\le 20$ 且对所有 $0 \\le i \\le N-1$ ，有 $1 \\le C_i \\le 50$。 |\n| $2$ | $6 $ | $N \\le 1000$ 且对所有 $0 \\le i \\le N-1$ ，有 $1 \\le C_i \\le 1000$。 |\n| $3$ | $11$ | $N \\le 1000$。 |\n| $4$ | $16$ | 对所有 $0 \\le i < N-1$ ，有 $p_i = 0, q_i = i+1$。 |\n| $5$ | $26$ | $N \\le 50000$。 |\n| $6$ | $34$ | 无额外约束。 |\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RMI 2025] 电缆维护 / Engineers", "background": "由于官方未提供时限和空限，将 TL 设置为 std 的两倍，ML 设置为 2G。\n", "description": "\n给定一棵 $N$ 个点的树，点编号 $0\\sim N-1$。点 $i$ 有正整数点权 $C_i$。\n\n给定正整数 $D$。构造若干条**简单**路径（点集可以有交），使得未被路径覆盖的点的点权差值不大于 $D$。\n\n形式化地说，设未被覆盖的点集为 $R$，你需要保证 $\\forall i,j\\in R$，都有 $|C_i-C_j|\\le D$。\n\n在满足上述条件的前提下最小化路径数量。只需要求出路径数量。\n\n### 实现细节\n\n这是一道（函数式）交互题。你不需要，也不应该定义 `main` 函数。\n\n你需要实现函数\n\n```cpp\nint solve(int N, int D, std::vector<int> C, std::vector<int> P, std::vector<int> Q)\n```\n\n该函数接收以下参数：\n- 点数 $N$；\n- 最大可接受差值 $D$；\n- 点权 $C$；\n- 两个长度为 $N-1$ 的 `vector<int>` $P$ 和 $Q$，表示对所有 $0 \\le i \\le N-1$，存在树边 $(P_i,Q_i)$。\n\n返回符合条件的路径的最少数量。\n\n", "inputFormat": "见「实现细节」。", "outputFormat": "见「实现细节」。", "hint": "\n\n### 样例解释\n\n在样例一中，有 $N=5$ 且 $D=3$。树的结构如图所示：\n\n::::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/0v5nanlt.png)\n::::\n\n一种合法的方案为构造路径 $[0,1,2,3]$。\n\n\n### 限制条件\n* $1 \\le N \\le 200\\,000$。\n* 对所有 $0 \\le i \\le N-1$ ，有 $1 \\le C_i \\le 1\\,000\\,000\\,000$。\n* $1 \\le D \\le 1\\,000\\,000\\,000$。\n* $0 \\le p_i, q_i < N$ ，$p_i \\ne q_i$，且 $(p_i, q_i)$ 互不相同。\n\n### 子任务\n\n| # | 分值 | 约束 |\n|:---:|:---:|:---|\n| $1$ | $7 $ | $N \\le 20$ 且对所有 $0 \\le i \\le N-1$ ，有 $1 \\le C_i \\le 50$。 |\n| $2$ | $6 $ | $N \\le 1000$ 且对所有 $0 \\le i \\le N-1$ ，有 $1 \\le C_i \\le 1000$。 |\n| $3$ | $11$ | $N \\le 1000$。 |\n| $4$ | $16$ | 对所有 $0 \\le i < N-1$ ，有 $p_i = 0, q_i = i+1$。 |\n| $5$ | $26$ | $N \\le 50000$。 |\n| $6$ | $34$ | 无额外约束。 |\n\n", "locale": "zh-CN"}}}
{"pid": "P14717", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["二分", "2025", "交互题", "Special Judge", "期望", "RMI（罗马尼亚）"], "title": "[RMI 2025] 猜排列 / Guess Permutation", "background": "**不要引入头文件**。在文件头粘贴\n\n```cpp\n#include <vector>\nint press_button(int);\n```\n\n以评测。", "description": "\n**这是一道交互题。本题中，交互库是非自适应的。**\n\n有一台破旧的机器，有 $N$ 个**隐藏的**开关，编号 $0\\sim N-1$。开关的状态用 $s_0,\\ldots,s_{N-1}$ 来表示。我们说开关 $i$ **断开**，当且仅当 $s_i=0$；否则 $s_i=1$，开关 $i$ **接通**。\n\n起初，所有开关都是断开的。\n\n有 $N$ 个按钮，编号 $0\\sim N-1$。有一个**隐藏的** $0\\sim N-1$ 的排列，记为 $P=[p_0,\\ldots,p_{N-1}]$。\n\n现在想要确定 $P$。为此，你可以进行如下的操作：\n\n> **操作**\n> \n> - 选定 $i$ 满足 $0\\le i\\lt n$，按下按钮 $i$。\n> - 令本次操作**前**（不含本次）一共进行了 $k$ 次操作。\n> - 翻转开关 $p_{k\\bmod N}$ 的状态。形式化地，令 $s_{p_{k\\bmod N}}\\gets 1-s_{p_{k\\bmod N}}$。\n> - 你将得知 $s_i$ 的值。\n\n给定 $N$，你需要用至多 $50N$ 次操作找出排列 $P$。\n\n为了获得满分，需要更少的操作次数，详见「计分方式」。\n\n### 实现细节\n\n\n**这是一道（函数式）交互题。你不需要，也不应该定义 `main` 函数。**\n\n你需要实现函数\n\n```cpp\nstd::vector<int> solve(int N);\n```\n\n该函数接收参数 $N$；返回长度为 $N$ 的 `vector` $q$ 满足 $q[i]=p[i]$。该函数每个测试点仅调用一次。\n\n你可以调用以下的函数：\n\n```cpp\nint press_button(int i);\n```\n\n描述一次按下按钮 $i$ 的操作，返回操作后 $s_i$ 的值。\n\n### Sample Grader\n\n在附件中附有 sample grader（$\\texttt{sample-grader.cpp}$）。其输入格式如下：\n\n- 第一行：正整数 $N$\n- 第二行：$N$ 个整数 $p_0,p_1,\\ldots,p_{N-1}$。\n\n它会调用 `solve(N)` 函数，报告你程序的运行结果：若通过，输出查询次数；否则，输出错误信息。\n", "inputFormat": "\n见「实现细节」。\n", "outputFormat": "\n见「实现细节」。", "hint": "\n### 样例解释\n\n考虑 $N=4,P=[1,3,0,2]$ 和以下的调用。\n\n| 操作           | $S=$     | 返回值 |\n|------------------|-------|--------------|\n| $\\texttt{press\\_button(0)}$  | $\\texttt{0100}$  | $\\texttt{ }$            |\n| $\\texttt{press\\_button(1)}$  | $\\texttt{0101}$  | $\\texttt{0}$            |\n| $\\texttt{press\\_button(2)}$  | $\\texttt{1101}$  | $\\texttt{1}$            |\n| $\\texttt{press\\_button(3)}$  | $\\texttt{1111}$  | $\\texttt{0}$            |\n| $\\texttt{press\\_button(1)}$  | $\\texttt{1011}$  | $\\texttt{1}$            |\n| $\\texttt{press\\_button(3)}$  | $\\texttt{1010}$  | $\\texttt{0}$            |\n| $\\texttt{press\\_button(2)}$  | $\\texttt{0010}$  | $\\texttt{0}$            |\n| 返回 $\\texttt{\\{1,3,0,2\\}}$ |       | $\\texttt{1}$            |\n\n\n### 限制条件\n\n- $N\\le 10^4$。\n- $P$ 是 $0\\sim N-1$ 的排列。\n\n### 子任务\n\n| # | 得分 | $N=$ |\n| :-: | :-: | :-: |\n| $1$ | $20$ | $32$ |\n| $2$ | $40$ | $1\\, 000$ |\n| $3$ | $40$ | $10\\, 000$ |\n\n### 计分方式\n\n如果你的程序未能成功结束，或者答案错误，得 $0$ 分。\n\n否则，令 $K$ 为你的程序调用 `press_button()` 的次数。令 $Q=K/N$，若 $Q>50$，得 $0$ 分。否则，每个子任务得分为系数 $S$ 乘以子任务满分。$S$ 的计算方式如下：\n\n- 子任务 $1$：$\\displaystyle S=\\begin{cases} \\displaystyle  1, & Q\\le 7 \\\\ \\displaystyle  1-\\frac{1}{10}(Q-7), & 7\\lt Q\\le 12 \\\\ \\displaystyle \\frac{1}{2}-\\frac{1}{100}(Q-12), & 12\\lt Q\\le 32 \\\\ \\displaystyle \\frac{3}{10}-\\frac{1}{10}\\sqrt[4]{\\frac{Q-32}{18}}, & 32\\lt Q\\le 50\\end{cases}$\n- 子任务 $2$：$\\displaystyle S=\\begin{cases} \\displaystyle  1, & Q\\le 13 \\\\ \\displaystyle  \\frac{1}{2}+\\frac{1}{2}\\left(\\frac{23-Q}{10}\\right)^2, & 13\\lt Q\\le 23 \\\\ \\displaystyle \\frac{1}{5}+\\frac{3}{10}\\sqrt{\\frac{50-Q}{27}}, & 23\\lt Q\\le 50\\end{cases}$\n- 子任务 $3$：$\\displaystyle S=\\begin{cases} \\displaystyle  1, & Q\\le 17 \\\\ \\displaystyle  \\frac{3}{5}+\\frac{25-Q}{20}, & 17\\lt Q\\le 25 \\\\ \\displaystyle \\frac{1}{5}+\\frac{2}{5}\\left(\\frac{50-Q}{25}\\right)^2, & 25\\lt Q\\le 50\\end{cases}$\n\n你可以利用下图获得直观感受。\n\n::::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/y3dxxitv.png)\n::::\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RMI 2025] 猜排列 / Guess Permutation", "background": "**不要引入头文件**。在文件头粘贴\n\n```cpp\n#include <vector>\nint press_button(int);\n```\n\n以评测。", "description": "\n**这是一道交互题。本题中，交互库是非自适应的。**\n\n有一台破旧的机器，有 $N$ 个**隐藏的**开关，编号 $0\\sim N-1$。开关的状态用 $s_0,\\ldots,s_{N-1}$ 来表示。我们说开关 $i$ **断开**，当且仅当 $s_i=0$；否则 $s_i=1$，开关 $i$ **接通**。\n\n起初，所有开关都是断开的。\n\n有 $N$ 个按钮，编号 $0\\sim N-1$。有一个**隐藏的** $0\\sim N-1$ 的排列，记为 $P=[p_0,\\ldots,p_{N-1}]$。\n\n现在想要确定 $P$。为此，你可以进行如下的操作：\n\n> **操作**\n> \n> - 选定 $i$ 满足 $0\\le i\\lt n$，按下按钮 $i$。\n> - 令本次操作**前**（不含本次）一共进行了 $k$ 次操作。\n> - 翻转开关 $p_{k\\bmod N}$ 的状态。形式化地，令 $s_{p_{k\\bmod N}}\\gets 1-s_{p_{k\\bmod N}}$。\n> - 你将得知 $s_i$ 的值。\n\n给定 $N$，你需要用至多 $50N$ 次操作找出排列 $P$。\n\n为了获得满分，需要更少的操作次数，详见「计分方式」。\n\n### 实现细节\n\n\n**这是一道（函数式）交互题。你不需要，也不应该定义 `main` 函数。**\n\n你需要实现函数\n\n```cpp\nstd::vector<int> solve(int N);\n```\n\n该函数接收参数 $N$；返回长度为 $N$ 的 `vector` $q$ 满足 $q[i]=p[i]$。该函数每个测试点仅调用一次。\n\n你可以调用以下的函数：\n\n```cpp\nint press_button(int i);\n```\n\n描述一次按下按钮 $i$ 的操作，返回操作后 $s_i$ 的值。\n\n### Sample Grader\n\n在附件中附有 sample grader（$\\texttt{sample-grader.cpp}$）。其输入格式如下：\n\n- 第一行：正整数 $N$\n- 第二行：$N$ 个整数 $p_0,p_1,\\ldots,p_{N-1}$。\n\n它会调用 `solve(N)` 函数，报告你程序的运行结果：若通过，输出查询次数；否则，输出错误信息。\n", "inputFormat": "\n见「实现细节」。\n", "outputFormat": "\n见「实现细节」。", "hint": "\n### 样例解释\n\n考虑 $N=4,P=[1,3,0,2]$ 和以下的调用。\n\n| 操作           | $S=$     | 返回值 |\n|------------------|-------|--------------|\n| $\\texttt{press\\_button(0)}$  | $\\texttt{0100}$  | $\\texttt{ }$            |\n| $\\texttt{press\\_button(1)}$  | $\\texttt{0101}$  | $\\texttt{0}$            |\n| $\\texttt{press\\_button(2)}$  | $\\texttt{1101}$  | $\\texttt{1}$            |\n| $\\texttt{press\\_button(3)}$  | $\\texttt{1111}$  | $\\texttt{0}$            |\n| $\\texttt{press\\_button(1)}$  | $\\texttt{1011}$  | $\\texttt{1}$            |\n| $\\texttt{press\\_button(3)}$  | $\\texttt{1010}$  | $\\texttt{0}$            |\n| $\\texttt{press\\_button(2)}$  | $\\texttt{0010}$  | $\\texttt{0}$            |\n| 返回 $\\texttt{\\{1,3,0,2\\}}$ |       | $\\texttt{1}$            |\n\n\n### 限制条件\n\n- $N\\le 10^4$。\n- $P$ 是 $0\\sim N-1$ 的排列。\n\n### 子任务\n\n| # | 得分 | $N=$ |\n| :-: | :-: | :-: |\n| $1$ | $20$ | $32$ |\n| $2$ | $40$ | $1\\, 000$ |\n| $3$ | $40$ | $10\\, 000$ |\n\n### 计分方式\n\n如果你的程序未能成功结束，或者答案错误，得 $0$ 分。\n\n否则，令 $K$ 为你的程序调用 `press_button()` 的次数。令 $Q=K/N$，若 $Q>50$，得 $0$ 分。否则，每个子任务得分为系数 $S$ 乘以子任务满分。$S$ 的计算方式如下：\n\n- 子任务 $1$：$\\displaystyle S=\\begin{cases} \\displaystyle  1, & Q\\le 7 \\\\ \\displaystyle  1-\\frac{1}{10}(Q-7), & 7\\lt Q\\le 12 \\\\ \\displaystyle \\frac{1}{2}-\\frac{1}{100}(Q-12), & 12\\lt Q\\le 32 \\\\ \\displaystyle \\frac{3}{10}-\\frac{1}{10}\\sqrt[4]{\\frac{Q-32}{18}}, & 32\\lt Q\\le 50\\end{cases}$\n- 子任务 $2$：$\\displaystyle S=\\begin{cases} \\displaystyle  1, & Q\\le 13 \\\\ \\displaystyle  \\frac{1}{2}+\\frac{1}{2}\\left(\\frac{23-Q}{10}\\right)^2, & 13\\lt Q\\le 23 \\\\ \\displaystyle \\frac{1}{5}+\\frac{3}{10}\\sqrt{\\frac{50-Q}{27}}, & 23\\lt Q\\le 50\\end{cases}$\n- 子任务 $3$：$\\displaystyle S=\\begin{cases} \\displaystyle  1, & Q\\le 17 \\\\ \\displaystyle  \\frac{3}{5}+\\frac{25-Q}{20}, & 17\\lt Q\\le 25 \\\\ \\displaystyle \\frac{1}{5}+\\frac{2}{5}\\left(\\frac{50-Q}{25}\\right)^2, & 25\\lt Q\\le 50\\end{cases}$\n\n你可以利用下图获得直观感受。\n\n::::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/y3dxxitv.png)\n::::\n", "locale": "zh-CN"}}}
{"pid": "P14718", "type": "P", "difficulty": 6, "samples": [["5\n1\n14 6\n8 2 15\n3 10 4 12\n9 5 13 11 7", "64\n14 10 15 12 13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["贪心", "2025", "网络流", "交互题", "Special Judge", "RMI（罗马尼亚）"], "title": "[RMI 2025] 松鼠 / Squirrel", "background": "", "description": "\n一只松鼠发现了一个存放坚果的储藏室。  \n储藏室包含 $N$ 行房间，编号从 $0$ 到 $N-1$。  \n索引为 $i$ 的一行包含 $i+1$ 个房间，编号从 $0$ 到 $i$。  \n位于第 $i$ 行第 $j$ 列的房间包含 $A_{ij}$ 个坚果。\n\n在 $\\frac{N \\times (N+1)}{2}$ 个房间中，数 $A_{ij}$ 两两不同，且取值在 $1$ 到 $\\frac{N \\times (N+1)}{2}$ 之间。\n\n形式化地说，储藏室的形状是一个三角形半矩阵，即主对角线下方（包含主对角线）的那一部分，其中每个元素表示坚果数量。  \n这个半矩阵中的数是从 $1$ 到 $\\frac{N \\times (N+1)}{2}$ 的所有整数，每个数恰好出现一次。\n\n例如，当 $N = 5$ 时，储藏室会有 15 个房间，包含从 1 到 15 的数字。  \n这种储藏室的一个例子可以是下面所示的半矩阵：\n\n::::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/7tusl2qo.png)\n::::\n\n松鼠沿着主对角线行走，并且在位于 $(i, i)$ 的每个房间，它会选择一个位于以 $(i, i)$ 为右上角、以 $(N-1, 0)$ 为左下角的矩形中的房间，并吃掉该房间里的橡实。  \n在上面的例子中，当松鼠位于 $(1, 1)$ 时，它可以选择吃掉红色标出的 8 个房间中的任意一个房间里的坚果。  \n当它走过主对角线上的所有房间并且恰好吃了 $N$ 个不同房间里的坚果后，松鼠心满意足地离开。\n\n\n要求：给定 $N$ 以及对任意 $0 \\le i < N$ 和 $0 \\le j \\le i$ 的 $A_{ij}$，求松鼠最多能吃到多少坚果。  \n同时，对于它访问的 $N$ 个房间中的每一个，求松鼠所吃的坚果数量。\n\n### 实现细节\n\n这是一道（函数式）交互题。你不需要，也不应该定义 `main` 函数。\n\n你需要实现函数\n```cpp\nvoid solve(int N, vector<vector<int>> A, long long& answer, vector<int>& solution)\n```\n\n函数参数：\n\n输入数据：\n\n*   `int N`：储藏室大小 / 行数  \n*   `vector<vector<int>> A`：每个房间中的坚果数量（更准确地说，在 $A_{ij}$ 中，$0 \\le i < N$ 且 $0 \\le j \\le i$，你会找到第 $i$ 行第 $j$ 个位置的房间中的坚果数量）\n\n输出数据：\n\n*   `long long &answer`：将包含松鼠走过对角线上的全部 $N$ 个房间后能够吃到的最大坚果数量。  \n*   `vector<int> &solution`：一个 `vector<int>`，包含松鼠在每个房间中吃到的坚果数量。（更准确地说，$solution_i$ 且 $0 \\le i < N$ 表示松鼠位于房间 $(i,i)$ 时吃到的坚果数量）\n\n\n**注意**：对于 $A$ 和 $solution$，下标从 $0$ 开始，并且 $solution$ 的大小应当恰好为 $N$。", "inputFormat": "见「实现细节」。", "outputFormat": "见「实现细节」。", "hint": "\n### 约束\n\n*   $1 \\le N \\le 2000$  \n*   $1 \\le A_{ij} \\le \\frac{N \\times (N+1)}{2}$\n\n| # | 分数 | 约束                                       |\n|:-:|:-:|:-:|\n| $1$ | $11$   | $N \\le 5$                                  |\n| $2$ | $12$   | $N \\le 100$                                |\n| $3$ | $23$   | $N \\le 500$                                |\n| $4$ | $15$   | $N \\le 1000$                               |\n| $5$ | $13$   | $N \\le 1200$                               |\n| $6$ | $8 $   | 矩阵的内容是随机分配的。                   |\n| $7$ | $18$   | 无额外约束                                 |\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RMI 2025] 松鼠 / Squirrel", "background": "", "description": "\n一只松鼠发现了一个存放坚果的储藏室。  \n储藏室包含 $N$ 行房间，编号从 $0$ 到 $N-1$。  \n索引为 $i$ 的一行包含 $i+1$ 个房间，编号从 $0$ 到 $i$。  \n位于第 $i$ 行第 $j$ 列的房间包含 $A_{ij}$ 个坚果。\n\n在 $\\frac{N \\times (N+1)}{2}$ 个房间中，数 $A_{ij}$ 两两不同，且取值在 $1$ 到 $\\frac{N \\times (N+1)}{2}$ 之间。\n\n形式化地说，储藏室的形状是一个三角形半矩阵，即主对角线下方（包含主对角线）的那一部分，其中每个元素表示坚果数量。  \n这个半矩阵中的数是从 $1$ 到 $\\frac{N \\times (N+1)}{2}$ 的所有整数，每个数恰好出现一次。\n\n例如，当 $N = 5$ 时，储藏室会有 15 个房间，包含从 1 到 15 的数字。  \n这种储藏室的一个例子可以是下面所示的半矩阵：\n\n::::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/7tusl2qo.png)\n::::\n\n松鼠沿着主对角线行走，并且在位于 $(i, i)$ 的每个房间，它会选择一个位于以 $(i, i)$ 为右上角、以 $(N-1, 0)$ 为左下角的矩形中的房间，并吃掉该房间里的橡实。  \n在上面的例子中，当松鼠位于 $(1, 1)$ 时，它可以选择吃掉红色标出的 8 个房间中的任意一个房间里的坚果。  \n当它走过主对角线上的所有房间并且恰好吃了 $N$ 个不同房间里的坚果后，松鼠心满意足地离开。\n\n\n要求：给定 $N$ 以及对任意 $0 \\le i < N$ 和 $0 \\le j \\le i$ 的 $A_{ij}$，求松鼠最多能吃到多少坚果。  \n同时，对于它访问的 $N$ 个房间中的每一个，求松鼠所吃的坚果数量。\n\n### 实现细节\n\n这是一道（函数式）交互题。你不需要，也不应该定义 `main` 函数。\n\n你需要实现函数\n```cpp\nvoid solve(int N, vector<vector<int>> A, long long& answer, vector<int>& solution)\n```\n\n函数参数：\n\n输入数据：\n\n*   `int N`：储藏室大小 / 行数  \n*   `vector<vector<int>> A`：每个房间中的坚果数量（更准确地说，在 $A_{ij}$ 中，$0 \\le i < N$ 且 $0 \\le j \\le i$，你会找到第 $i$ 行第 $j$ 个位置的房间中的坚果数量）\n\n输出数据：\n\n*   `long long &answer`：将包含松鼠走过对角线上的全部 $N$ 个房间后能够吃到的最大坚果数量。  \n*   `vector<int> &solution`：一个 `vector<int>`，包含松鼠在每个房间中吃到的坚果数量。（更准确地说，$solution_i$ 且 $0 \\le i < N$ 表示松鼠位于房间 $(i,i)$ 时吃到的坚果数量）\n\n\n**注意**：对于 $A$ 和 $solution$，下标从 $0$ 开始，并且 $solution$ 的大小应当恰好为 $N$。", "inputFormat": "见「实现细节」。", "outputFormat": "见「实现细节」。", "hint": "\n### 约束\n\n*   $1 \\le N \\le 2000$  \n*   $1 \\le A_{ij} \\le \\frac{N \\times (N+1)}{2}$\n\n| # | 分数 | 约束                                       |\n|:-:|:-:|:-:|\n| $1$ | $11$   | $N \\le 5$                                  |\n| $2$ | $12$   | $N \\le 100$                                |\n| $3$ | $23$   | $N \\le 500$                                |\n| $4$ | $15$   | $N \\le 1000$                               |\n| $5$ | $13$   | $N \\le 1200$                               |\n| $6$ | $8 $   | 矩阵的内容是随机分配的。                   |\n| $7$ | $18$   | 无额外约束                                 |\n\n", "locale": "zh-CN"}}}
{"pid": "P14719", "type": "P", "difficulty": 6, "samples": [["5 \naabaabacbbaabaa", "7"], ["8 \naaaaaaaaaaaaaaaaaaa", "4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2025", "交互题", "分治", "哈希 hashing", "后缀数组 SA", "RMI（罗马尼亚）"], "title": "[RMI 2025] Cheap AI", "background": "", "description": "\n给定一个数 $K$ 和一个由英文小写字母组成的字符串 $S$，选择一个非空串 $t$，满足 $1 \\le |t| \\le K$，将 $t$ 在 $S$ 中出现的位置（选择若干个且互不重叠）替换为特殊字符 `#`，使得得到的最终字符串的长度最小。  \n\n求出这个最小长度。\n\n\n### 实现细节\n\n你需要实现下列函数：\n\n```cpp\nint solve(int K, std::string S);\n```\n\n这个函数接收 $K$ 和 $S$ 作为参数，需要求出在把一个长度不超过 $K$ 的所选 token 的若干次出现（互不重叠）替换为特殊字符 `#` 之后得到的字符串的最小长度。\n", "inputFormat": "见「实现细节」。", "outputFormat": "见「实现细节」。", "hint": "\n#### 样例解释\n\n- 样例一解释：我们选择 $t = \\texttt{aabaa}$，于是 $S$ 变为 $\\texttt{\\#bacbb\\#}$（长度为 7）。\n- 样例二解释：我们选择 $t = \\texttt{aaaaaa}$，于是 $S$ 变为 $\\texttt{\\#\\#\\#a}$（长度为 4）。\n\n#### 约束\n\n*   $1 \\le K \\le |S| \\le 200\\,000$\n*   $S$ 由英文小写字母组成。\n\n| # | 分值 | 限制 |\n|:-:|:-:|---|\n| $1$ | $5 $| $S_i = \\texttt{a}$ |\n| $2$ | $7 $| $\\vert S\\vert \\le 100$ |\n| $3$ | $12$ | $\\vert S\\vert \\le 5000$ |\n| $4$ | $40$ | $\\vert S\\vert \\le 75\\,000$ |\n| $5$ | $36$ | $\\vert S\\vert \\le 200\\,000$ |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RMI 2025] Cheap AI", "background": "", "description": "\n给定一个数 $K$ 和一个由英文小写字母组成的字符串 $S$，选择一个非空串 $t$，满足 $1 \\le |t| \\le K$，将 $t$ 在 $S$ 中出现的位置（选择若干个且互不重叠）替换为特殊字符 `#`，使得得到的最终字符串的长度最小。  \n\n求出这个最小长度。\n\n\n### 实现细节\n\n你需要实现下列函数：\n\n```cpp\nint solve(int K, std::string S);\n```\n\n这个函数接收 $K$ 和 $S$ 作为参数，需要求出在把一个长度不超过 $K$ 的所选 token 的若干次出现（互不重叠）替换为特殊字符 `#` 之后得到的字符串的最小长度。\n", "inputFormat": "见「实现细节」。", "outputFormat": "见「实现细节」。", "hint": "\n#### 样例解释\n\n- 样例一解释：我们选择 $t = \\texttt{aabaa}$，于是 $S$ 变为 $\\texttt{\\#bacbb\\#}$（长度为 7）。\n- 样例二解释：我们选择 $t = \\texttt{aaaaaa}$，于是 $S$ 变为 $\\texttt{\\#\\#\\#a}$（长度为 4）。\n\n#### 约束\n\n*   $1 \\le K \\le |S| \\le 200\\,000$\n*   $S$ 由英文小写字母组成。\n\n| # | 分值 | 限制 |\n|:-:|:-:|---|\n| $1$ | $5 $| $S_i = \\texttt{a}$ |\n| $2$ | $7 $| $\\vert S\\vert \\le 100$ |\n| $3$ | $12$ | $\\vert S\\vert \\le 5000$ |\n| $4$ | $40$ | $\\vert S\\vert \\le 75\\,000$ |\n| $5$ | $36$ | $\\vert S\\vert \\le 200\\,000$ |\n", "locale": "zh-CN"}}}
{"pid": "P14720", "type": "P", "difficulty": 5, "samples": [["2 \n6 \n2 2\n5 10 \n2000 3 \n2000 5 \n100 32\n150 278", "332748119\n1\n518205646\n742082393\n368118258\n937239298"], ["7 \n8 \n100000000 0 \n100000000 1 \n100000000 2 \n100000000 3 \n5219873 192 \n853875838 238 \n43782384 1500\n58123292 180000", "0\n1\n268791198\n806373591\n782159797\n435727907\n712321002\n257644694"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2025", "交互题", "平面图欧拉公式", "组合数学", "RMI（罗马尼亚）"], "title": "[RMI 2025] 鼠皇 / King of rats", "background": "", "description": "\n给定正整数 $n,k$。\n\n考虑一个 $2$ 行 $n$ 列的网格图，其中每个格子上填写着 $0$ 或 $1$。图上共有 $k$ 个 $1$。\n\n定义两个格子相连，当且仅当它们共享一条公共边。\n\n在所有符合条件的图等概率出现的前提下，求出这张图上所有填写着 $1$ 的格子的期望连通分量个数，答案对 $998\\, 244\\, 353$ 取模。\n\n\n### 实现\n\n你需要实现以下函数：\n\n```cpp\nvoid prec(int subtask_id)\n```\n\n```cpp\nint solve(int n, int k)\n```\n\n第一个函数会在评测程序开始时被调用一次，你可以用它来做预处理。\n\n第二个函数应当在给定参数 $n$ 和 $k$ 的情况下，返回危险度的期望值，对模数 $998\\,244\\,353$ 取模。  \n形式化地，设 $M = 998\\,244\\,353$ 。可以证明答案可以表示为既约分数 $\\frac{p}{q}$，其中 $p$ 和 $q$ 是整数且 $q \\neq 0 \\pmod M$。  \n返回等于 $p \\cdot q^{-1} \\pmod M$ 的整数。  \n换句话说，返回一个整数 $x$，满足 $0 \\le x < M$ 且 $x \\cdot q \\equiv p \\pmod M$。\n\n第二个函数将会被调用 $t$ 次。也就是说，输入中包含多组测试数据！\n\n", "inputFormat": "见「实现细节」。", "outputFormat": "见「实现细节」。", "hint": "\n\n注意，评测程序会被提供子任务编号、测试数据组数 $t$，以及每组测试数据对应的 $n, k$ 的值。\n\n### 样例解释\n\n\n\n对于第一个样例的第一组测试数据，所有可能的配置如下所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mylprcq6.png)\n\n一共有 6 种配置，其中有 4 种只有一个连通分量。  \n因此答案为 $\\frac{4 \\cdot 1 + 2 \\cdot 2}{6} = \\frac{4}{3}$。\n\n\n\n### 约束\n\n* $1 \\le t \\le 10$\n* $1 \\le n \\le 10^9$\n* $0 \\le k \\le 10^6$\n* $k \\le 2 \\cdot n$\n\n| # | 分值 | 约束条件 |\n|:---:|:------:|----------|\n| $1$ | $10$   | $1 \\le n \\le 100$ |\n| $2$ | $5 $   | $1 \\le n \\le 2000$ |\n| $3$ | $5 $   | $k \\le 3$ |\n| $4$ | $15$   | $k \\le 40$ |\n| $5$ | $10$   | $k \\le 400$ |\n| $6$ | $15$   | $k \\le 2000$ |\n| $7$ | $40$   | 无额外限制 |\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RMI 2025] 鼠皇 / King of rats", "background": "", "description": "\n给定正整数 $n,k$。\n\n考虑一个 $2$ 行 $n$ 列的网格图，其中每个格子上填写着 $0$ 或 $1$。图上共有 $k$ 个 $1$。\n\n定义两个格子相连，当且仅当它们共享一条公共边。\n\n在所有符合条件的图等概率出现的前提下，求出这张图上所有填写着 $1$ 的格子的期望连通分量个数，答案对 $998\\, 244\\, 353$ 取模。\n\n\n### 实现\n\n你需要实现以下函数：\n\n```cpp\nvoid prec(int subtask_id)\n```\n\n```cpp\nint solve(int n, int k)\n```\n\n第一个函数会在评测程序开始时被调用一次，你可以用它来做预处理。\n\n第二个函数应当在给定参数 $n$ 和 $k$ 的情况下，返回危险度的期望值，对模数 $998\\,244\\,353$ 取模。  \n形式化地，设 $M = 998\\,244\\,353$ 。可以证明答案可以表示为既约分数 $\\frac{p}{q}$，其中 $p$ 和 $q$ 是整数且 $q \\neq 0 \\pmod M$。  \n返回等于 $p \\cdot q^{-1} \\pmod M$ 的整数。  \n换句话说，返回一个整数 $x$，满足 $0 \\le x < M$ 且 $x \\cdot q \\equiv p \\pmod M$。\n\n第二个函数将会被调用 $t$ 次。也就是说，输入中包含多组测试数据！\n\n", "inputFormat": "见「实现细节」。", "outputFormat": "见「实现细节」。", "hint": "\n\n注意，评测程序会被提供子任务编号、测试数据组数 $t$，以及每组测试数据对应的 $n, k$ 的值。\n\n### 样例解释\n\n\n\n对于第一个样例的第一组测试数据，所有可能的配置如下所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mylprcq6.png)\n\n一共有 6 种配置，其中有 4 种只有一个连通分量。  \n因此答案为 $\\frac{4 \\cdot 1 + 2 \\cdot 2}{6} = \\frac{4}{3}$。\n\n\n\n### 约束\n\n* $1 \\le t \\le 10$\n* $1 \\le n \\le 10^9$\n* $0 \\le k \\le 10^6$\n* $k \\le 2 \\cdot n$\n\n| # | 分值 | 约束条件 |\n|:---:|:------:|----------|\n| $1$ | $10$   | $1 \\le n \\le 100$ |\n| $2$ | $5 $   | $1 \\le n \\le 2000$ |\n| $3$ | $5 $   | $k \\le 3$ |\n| $4$ | $15$   | $k \\le 40$ |\n| $5$ | $10$   | $k \\le 400$ |\n| $6$ | $15$   | $k \\le 2000$ |\n| $7$ | $40$   | 无额外限制 |\n\n", "locale": "zh-CN"}}}
{"pid": "P14721", "type": "P", "difficulty": 6, "samples": [["1", "0 1"], ["4 \n0 1\n1 2\n2 3", "0 0 4 4 1"], ["6\n0 1\n1 2\n1 3\n0 4\n4 5", "0 0 0 0 11 6 1"], ["15 \n0 1\n0 2\n2 3\n3 4\n4 5\n5 6\n0 7\n7 8\n8 9\n9 10\n8 11\n11 12\n7 13\n7 14", "0 0 0 0 0 0 0 0 0 560 992 793 361 98 15 1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2025", "交互题", "背包 DP", "树形 DP", "Ad-hoc", "RMI（罗马尼亚）"], "title": "[RMI 2025] 橙子 / Oranges", "background": "", "description": "在日本某处的一个动物园里，饲养员们决定和水豚们玩以下游戏。\n\n水豚的围栏由 $N$ 个温泉组成，编号从 $0$ 到 $N-1$。这些温泉由 $N-1$ 条走道连接。每条走道连接两个温泉，并且可以从任何一个温泉通过这些走道到达任何其他温泉。换句话说，水豚围栏的结构是一棵树（即一个无向连通无环图）。\n\n最初，每个温泉中最多只有一只水豚，但这在游戏过程中可能会改变。\n\n游戏包含数轮（可能是无限轮）。每轮有两个阶段：\n\n1.  饲养员会将一个橘子扔进 $N$ 个温泉中的一个。水豚们会知道橘子被扔进了哪个温泉。\n2.  最多一只水豚可以移动到相邻的温泉。之后，如果装有橘子的温泉里没有水豚，则饲养员获胜，水豚失败。否则，橘子被吃掉，游戏继续。\n\n一个初始配置（即最初包含水豚的温泉集合）是**安全**的，如果当饲养员和水豚都采取最优策略时，饲养员无法在有限轮内获胜。\n\n对于从 $0$ 到 $N$ 的每个 $K$，找出恰好有 $K$ 只水豚的**安全**初始配置的数量。由于这些数字可能非常大，请找出它们对 $998244353$ 取模的余数。\n\n### 实现细节\n\n你将需要实现以下函数：\n\n```cpp\nstd::vector<int> solve(int N, std::vector<int> U, std::vector<int> V)\n```\n\n该函数由评分器调用一次，并应返回一个长度为 $N+1$ 的 `std::vector<int>`，其中包含对于每个 $0 \\le K \\le N$，恰好有 $K$ 只水豚的安全初始配置的数量（对 $998244353$ 取模）。\n\n此函数的参数具有以下含义：\n\n*   $N$ - 温泉的数量。\n*   $U$ - 一个长度为 $N-1$ 的 `std::vector<int>`，包含 $N-1$ 条走道中每条的第一个端点。\n*   $V$ - 一个长度为 $N-1$ 的 `std::vector<int>`，包含 $N-1$ 条走道中每条的第二个端点。\n\n对于每个 $0 \\le i < N-1$，第 $i$ 条走道连接温泉 $U_i$ 和 $V_i$。\n", "inputFormat": "见「实现细节」。", "outputFormat": "见「实现细节」。", "hint": "\n### 样例解释\n\n#### 样例一解释\n\n唯一的安全初始配置是 $\\{0\\}$。\n\n#### 样例二解释\n第二个示例中水豚围栏的结构：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tf9i4mpb.png)\n\n有 $4$ 个包含两只水豚的安全初始配置：$\\{0, 2\\}, \\{0, 3\\}, \\{1, 2\\}, \\{1, 3\\}$。\n\n所有至少有 $3$ 只水豚的初始配置都是安全的。\n\n#### 样例三解释\n\n第三个样例中水豚围栏的结构：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/d1uvv2pk.png)\n\n例如，初始配置 $\\{1, 3, 4\\}$ 是不安全的：\n\n在第一轮中，饲养员会向温泉 5 中扔一个橙子。来自温泉 4 的水豚被迫移动到温泉 5。\n\n在第二轮中，饲养员会向温泉 2 中扔一个橙子。来自温泉 1 的水豚被迫移动到温泉 2。\n\n在第三轮中，饲养员会向温泉 0 中扔一个橙子。由于没有水豚可以移动到温泉 0，饲养员获胜。\n\n\n\n#### 样例四解释\n\n\n第四个示例中水豚围栏的结构：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qs7e25r3.png)\n\n### 约束\n\n*   $1 \\le N \\le 6000$\n*   对于每条走道 $(U_i, V_i)$，有 $0 \\le U_i, V_i < N, U_i \\ne V_i$\n*   保证给定的走道构成一棵树（即一个无向连通无环图）。\n\n| # | 得分 | 约束 |\n| :-: | :--: | :---------- |\n| $1$ | $4 $| 存在一个温泉与其他所有温泉都直接相连。 |\n| $2$ | $11$ | 每个温泉最多与其他两个温泉直接相连。 |\n| $3$ | $14$ | $N \\le 10$ |\n| $4$ | $9 $| $N \\le 20$ |\n| $5$ | $33$ | $N \\le 200$ |\n| $6$ | $29$ | 无额外限制 |\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RMI 2025] 橙子 / Oranges", "background": "", "description": "在日本某处的一个动物园里，饲养员们决定和水豚们玩以下游戏。\n\n水豚的围栏由 $N$ 个温泉组成，编号从 $0$ 到 $N-1$。这些温泉由 $N-1$ 条走道连接。每条走道连接两个温泉，并且可以从任何一个温泉通过这些走道到达任何其他温泉。换句话说，水豚围栏的结构是一棵树（即一个无向连通无环图）。\n\n最初，每个温泉中最多只有一只水豚，但这在游戏过程中可能会改变。\n\n游戏包含数轮（可能是无限轮）。每轮有两个阶段：\n\n1.  饲养员会将一个橘子扔进 $N$ 个温泉中的一个。水豚们会知道橘子被扔进了哪个温泉。\n2.  最多一只水豚可以移动到相邻的温泉。之后，如果装有橘子的温泉里没有水豚，则饲养员获胜，水豚失败。否则，橘子被吃掉，游戏继续。\n\n一个初始配置（即最初包含水豚的温泉集合）是**安全**的，如果当饲养员和水豚都采取最优策略时，饲养员无法在有限轮内获胜。\n\n对于从 $0$ 到 $N$ 的每个 $K$，找出恰好有 $K$ 只水豚的**安全**初始配置的数量。由于这些数字可能非常大，请找出它们对 $998244353$ 取模的余数。\n\n### 实现细节\n\n你将需要实现以下函数：\n\n```cpp\nstd::vector<int> solve(int N, std::vector<int> U, std::vector<int> V)\n```\n\n该函数由评分器调用一次，并应返回一个长度为 $N+1$ 的 `std::vector<int>`，其中包含对于每个 $0 \\le K \\le N$，恰好有 $K$ 只水豚的安全初始配置的数量（对 $998244353$ 取模）。\n\n此函数的参数具有以下含义：\n\n*   $N$ - 温泉的数量。\n*   $U$ - 一个长度为 $N-1$ 的 `std::vector<int>`，包含 $N-1$ 条走道中每条的第一个端点。\n*   $V$ - 一个长度为 $N-1$ 的 `std::vector<int>`，包含 $N-1$ 条走道中每条的第二个端点。\n\n对于每个 $0 \\le i < N-1$，第 $i$ 条走道连接温泉 $U_i$ 和 $V_i$。\n", "inputFormat": "见「实现细节」。", "outputFormat": "见「实现细节」。", "hint": "\n### 样例解释\n\n#### 样例一解释\n\n唯一的安全初始配置是 $\\{0\\}$。\n\n#### 样例二解释\n第二个示例中水豚围栏的结构：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tf9i4mpb.png)\n\n有 $4$ 个包含两只水豚的安全初始配置：$\\{0, 2\\}, \\{0, 3\\}, \\{1, 2\\}, \\{1, 3\\}$。\n\n所有至少有 $3$ 只水豚的初始配置都是安全的。\n\n#### 样例三解释\n\n第三个样例中水豚围栏的结构：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/d1uvv2pk.png)\n\n例如，初始配置 $\\{1, 3, 4\\}$ 是不安全的：\n\n在第一轮中，饲养员会向温泉 5 中扔一个橙子。来自温泉 4 的水豚被迫移动到温泉 5。\n\n在第二轮中，饲养员会向温泉 2 中扔一个橙子。来自温泉 1 的水豚被迫移动到温泉 2。\n\n在第三轮中，饲养员会向温泉 0 中扔一个橙子。由于没有水豚可以移动到温泉 0，饲养员获胜。\n\n\n\n#### 样例四解释\n\n\n第四个示例中水豚围栏的结构：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qs7e25r3.png)\n\n### 约束\n\n*   $1 \\le N \\le 6000$\n*   对于每条走道 $(U_i, V_i)$，有 $0 \\le U_i, V_i < N, U_i \\ne V_i$\n*   保证给定的走道构成一棵树（即一个无向连通无环图）。\n\n| # | 得分 | 约束 |\n| :-: | :--: | :---------- |\n| $1$ | $4 $| 存在一个温泉与其他所有温泉都直接相连。 |\n| $2$ | $11$ | 每个温泉最多与其他两个温泉直接相连。 |\n| $3$ | $14$ | $N \\le 10$ |\n| $4$ | $9 $| $N \\le 20$ |\n| $5$ | $33$ | $N \\le 200$ |\n| $6$ | $29$ | 无额外限制 |\n\n", "locale": "zh-CN"}}}
{"pid": "P14722", "type": "P", "difficulty": 5, "samples": [["1 3\nBBB", "W"], ["2 3\nBBG\nRGR", "W"], ["2 2\nGG\nGG", "L"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["博弈论", "2022", "ICPC", "首尔"], "title": "[ICPC 2022 Seoul R] Card Game", "background": "", "description": "Alice and Bob play a game of taking turns removing cards from the grid board. At the beginning of the game, there is one card in each cell of the $N \\times M$ sized grid board, and each card is painted in one of three colors: red, black, or green. In the grid, the position of the upper-left cell is indicated by $(1,1)$, and the position of the lower-right cell is indicated by $(N,M)$.\n\nAlice and Bob choose one of the cards placed on the grid, and then remove the cards according to the rules below.\n\n- If the color of the chosen card is red, all 'connected cards' placed on a diagonal with a slope of 1 based on it are removed.\n- If the color of the chosen card is blue, all 'connected cards' placed on a diagonal with a slope of -1 based on it are removed.\n- If the color of the chosen card is green, all 'connected cards' placed on the diagonal in both directions based on it are removed.\n\n'Connected cards' to the chosen card are consecutively adjacent cards along a diagonal with a slope of 1 or -1 including the chosen card.\n\nFor example, when the current board situation during the game is as in Figure A.1, let the chosen card be a red card placed at $(4,3)$. As shown in Figure A.1, 'connected cards' placed on the diagonal line with a slope of 1 refer to the cards placed in the oval circle, which should be removed. That is, cards placed in the cells on the movement path while moving diagonally in both directions from the position $(4,3)$ are 'connected cards'. However, while moving in both directions along the diagonal at the chosen cell $(4,3)$, if it encounters a grid boundary or a blank cell, the movement stops.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/0fpto8ut.png)\n\nFigure A.1. An example to illustrate connected cards to the red card at $(4, 3)$\n:::\n\nSimilarly, when the current board situation during the game is as shown in Figure A.2, let the chosen card be the blue card placed at $(3,5)$. As shown in Figure A.2, 'connected cards' placed on the diagonal line with a slope of $-1$ refer to the cards placed in the oval circle, which should be removed.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/j0zkyww7.png)\n\nFigure A.2. An example to illustrate connected cards to the blue card at $(3, 5)$\n:::\n\nFigure A.3 shows the cards to be removed when the chosen card is green card placed at $(4,5)$.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/8lwlfhb9.png)\n\nFigure A.3. An example to illustrate connected cards to the green card at $(4, 5)$\n:::\n\nAlice and Bob alternately choose a card from the grid, and according to the color of the chosen card, remove the 'connected cards' according to the rules described above. Whoever removes the last card wins the game. That is, the player who cannot remove any card because there are no cards to choose from on the grid loses the game. Both Alice and Bob have a good understanding of the strategy of how to win the game and do their best to win.\n\nGiven the size of the grid board and the information on color of the cards placed on the board, write a program to determine whether Alice can win when she starts the game.", "inputFormat": "Your program is to read from standard input. The input starts with a line containing two integers, $N$ and $M$ ($1 \\leq N, M \\leq 25$), where $N$ is the number of rows and $M$ is the number of columns of the grid. In the following $N$ lines, the $i$-th line contains a string of length $M$, which represents the colors of the $M$ cards in the $i$-th row in the grid. Every character in the string is either ‘R’, ‘B’, or ‘G’, which stands for red, blue, or green, respectively.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain an upper-case letter: either ‘W’ if Alice wins or ‘L’ if Alice loses.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Seoul R] Card Game", "background": "", "description": "Alice and Bob play a game of taking turns removing cards from the grid board. At the beginning of the game, there is one card in each cell of the $N \\times M$ sized grid board, and each card is painted in one of three colors: red, black, or green. In the grid, the position of the upper-left cell is indicated by $(1,1)$, and the position of the lower-right cell is indicated by $(N,M)$.\n\nAlice and Bob choose one of the cards placed on the grid, and then remove the cards according to the rules below.\n\n- If the color of the chosen card is red, all 'connected cards' placed on a diagonal with a slope of 1 based on it are removed.\n- If the color of the chosen card is blue, all 'connected cards' placed on a diagonal with a slope of -1 based on it are removed.\n- If the color of the chosen card is green, all 'connected cards' placed on the diagonal in both directions based on it are removed.\n\n'Connected cards' to the chosen card are consecutively adjacent cards along a diagonal with a slope of 1 or -1 including the chosen card.\n\nFor example, when the current board situation during the game is as in Figure A.1, let the chosen card be a red card placed at $(4,3)$. As shown in Figure A.1, 'connected cards' placed on the diagonal line with a slope of 1 refer to the cards placed in the oval circle, which should be removed. That is, cards placed in the cells on the movement path while moving diagonally in both directions from the position $(4,3)$ are 'connected cards'. However, while moving in both directions along the diagonal at the chosen cell $(4,3)$, if it encounters a grid boundary or a blank cell, the movement stops.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/0fpto8ut.png)\n\nFigure A.1. An example to illustrate connected cards to the red card at $(4, 3)$\n:::\n\nSimilarly, when the current board situation during the game is as shown in Figure A.2, let the chosen card be the blue card placed at $(3,5)$. As shown in Figure A.2, 'connected cards' placed on the diagonal line with a slope of $-1$ refer to the cards placed in the oval circle, which should be removed.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/j0zkyww7.png)\n\nFigure A.2. An example to illustrate connected cards to the blue card at $(3, 5)$\n:::\n\nFigure A.3 shows the cards to be removed when the chosen card is green card placed at $(4,5)$.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/8lwlfhb9.png)\n\nFigure A.3. An example to illustrate connected cards to the green card at $(4, 5)$\n:::\n\nAlice and Bob alternately choose a card from the grid, and according to the color of the chosen card, remove the 'connected cards' according to the rules described above. Whoever removes the last card wins the game. That is, the player who cannot remove any card because there are no cards to choose from on the grid loses the game. Both Alice and Bob have a good understanding of the strategy of how to win the game and do their best to win.\n\nGiven the size of the grid board and the information on color of the cards placed on the board, write a program to determine whether Alice can win when she starts the game.", "inputFormat": "Your program is to read from standard input. The input starts with a line containing two integers, $N$ and $M$ ($1 \\leq N, M \\leq 25$), where $N$ is the number of rows and $M$ is the number of columns of the grid. In the following $N$ lines, the $i$-th line contains a string of length $M$, which represents the colors of the $M$ cards in the $i$-th row in the grid. Every character in the string is either ‘R’, ‘B’, or ‘G’, which stands for red, blue, or green, respectively.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain an upper-case letter: either ‘W’ if Alice wins or ‘L’ if Alice loses.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Seoul R] Card Game", "background": "", "description": "Alice 和 Bob 玩一个轮流从网格棋盘上取走卡片的游戏。游戏开始时，一个 $N \\times M$ 大小的网格棋盘的每个单元格中有一张卡片，每张卡片被涂成三种颜色之一：红色、蓝色或绿色。在网格中，左上角单元格的位置用 $(1,1)$ 表示，右下角单元格的位置用 $(N,M)$ 表示。\n\nAlice 和 Bob 从放置在网格上的卡片中选择一张，然后根据以下规则移除卡片。\n\n- 如果所选卡片的颜色是**红色**，则移除所有以其为基础、位于斜率为 $1$ 的对角线上的“连通卡片”。\n- 如果所选卡片的颜色是**蓝色**，则移除所有以其为基础、位于斜率为 $-1$ 的对角线上的“连通卡片”。\n- 如果所选卡片的颜色是**绿色**，则移除所有以其为基础、位于两个方向对角线上的“连通卡片”。\n\n所选卡片的“连通卡片”是指沿着斜率为 $1$ 或 $-1$ 的对角线、包括所选卡片在内的连续相邻卡片。\n\n例如，当游戏进行时的当前棋盘状态如图 A.1 所示时，设所选卡片是放置在 $(4,3)$ 的红色卡片。如图 A.1 所示，位于斜率为 $1$ 的对角线上的“连通卡片”指的是放置在椭圆形圆圈中的卡片，它们应该被移除。也就是说，从位置 $(4,3)$ 沿对角线向两个方向移动时，移动路径上的单元格中放置的卡片是“连通卡片”。然而，沿着所选单元格 $(4,3)$ 的对角线向两个方向移动时，如果遇到网格边界或空白单元格，移动就会停止。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/0fpto8ut.png)\n\n图 A.1. 说明 $(4, 3)$ 处红色卡片连通卡片的示例\n:::\n\n类似地，当游戏进行时的当前棋盘状态如图 A.2 所示时，设所选卡片是放置在 $(3,5)$ 的蓝色卡片。如图 A.2 所示，位于斜率为 $-1$ 的对角线上的“连通卡片”指的是放置在椭圆形圆圈中的卡片，它们应该被移除。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/j0zkyww7.png)\n\n图 A.2. 说明 $(3, 5)$ 处蓝色卡片连通卡片的示例\n:::\n\n图 A.3 显示了当所选卡片是放置在 $(4,5)$ 的绿色卡片时，要被移除的卡片。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/8lwlfhb9.png)\n\n图 A.3. 说明 $(4, 5)$ 处绿色卡片连通卡片的示例\n:::\n\nAlice 和 Bob 轮流从网格中选择一张卡片，并根据所选卡片的颜色，按照上述规则移除“连通卡片”。谁移走最后一张卡片，谁就赢得游戏。也就是说，当网格上没有卡片可供选择而无法移除任何卡片的玩家输掉游戏。Alice 和 Bob 都深知如何赢得游戏的策略，并尽最大努力争取胜利。\n\n给定网格棋盘的大小以及放置在棋盘上的卡片颜色信息，请编写一个程序来判断当 Alice 先手时，她是否能赢。", "inputFormat": "你的程序需要从标准输入读取数据。输入的第一行包含两个整数 $N$ 和 $M$ ($1 \\leq N, M \\leq 25$)，其中 $N$ 是网格的行数，$M$ 是列数。接下来的 $N$ 行中，第 $i$ 行包含一个长度为 $M$ 的字符串，表示网格中第 $i$ 行 $M$ 张卡片的颜色。字符串中的每个字符是 ‘R’、‘B’ 或 ‘G’，分别代表红色、蓝色或绿色。", "outputFormat": "你的程序需要向标准输出写入数据。输出恰好一行。该行应包含一个大写字母：如果 Alice 获胜则输出 ‘W’，如果 Alice 失败则输出 ‘L’。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14723", "type": "P", "difficulty": 6, "samples": [["LLRLLRLLRLRLLR", "16"], ["RLLRLLLRRLLRLRLL", "20"], ["LLRRLLLLRRLL", "16"], ["RLLRLLRLLRLL", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2022", "ICPC", "首尔"], "title": "[ICPC 2022 Seoul R] Castle Design", "background": "", "description": "The ICPC kingdom has decided to build a new castle. The boundary of the castle is designed as a **rectilinear polygon** with edges parallel to the $x$-axis or to the $y$-axis. To minimize the damage exposed by the enemy attack, the kingdom wants to minimize the perimeter of the rectilinear polygon. Let us go into more detail.\n\nA rectilinear polygon $P$ of $n$ vertices with integer coordinates realizes a **turn sequence** $S$ of length $n$ of two letters L and R if there is a counterclockwise traverse along the boundary of $P$ such that the turns at vertices of $P$, encountered during the traverse, form the turn sequence $S$; the left turn at a convex vertex corresponds to L and the right turn at a reflex vertex corresponds to R. For example, the rectilinear polygon in Figure B.1(a) realizes the turn sequence $S = \\text{RLLRLLLLRRLRIRLLL}$ of length 16. Another turn sequence $S = \\text{LLRLLRLLRLLRLLR}$ of length 14 can be realized by rectilinear polygons in Figure B.1(b) and B.1(c). Note that a turn sequence can have infinitely many realizations of rectilinear polygons in the integral plane.\n\nA polygon is **simple** if there are no two edges that intersect except at the end vertices of adjacent edges. A polygon is **monotone** to an axis if its intersection with a line orthogonal to the axis is at most one segment. The monotone polygon is called **2-monotone** if it is monotone to both $x$-axis and the $y$-axis, and **1-monotone** if it is monotone to the one axis but not to the other axis. For example, the polygon in Figure B.1(a) is 1-monotone because it is monotone to only one axis, the $x$-axis, while the polygons in Figure B.1(b) and B.1(c) are 2-monotone. A turn sequence is also said to be **$t$-monotone** if any simple rectilinear polygon realizing the turn sequence is $t$-monotone where $t = 1, 2$.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/grpmlqo9.png)\n\nFigure B.1 (a) A simple 1-monotone rectilinear polygon realizing a 1-monotone turn sequence RLLRLLLRRLLRIRLLL (starting from the marked vertex). (b) A simple 2-monotone rectilinear polygon realizing a 2-monotone turn sequence LLRLLRLLRLLRLLR (starting from the marked vertex). (c) The 2-monotone rectilinear polygon with the minimum perimeter for the turn sequence in (b).\n:::\n\nThe perimeter of a rectilinear polygon is the sum of the length of its edges. The perimeter of the polygon in Figure B.1(b) is 18, but this is not minimum for `LLRLLRLLRLLRLLR`. Its minimum perimeter should be 16 as in Figure B.1(c).\n\nGiven a $t$-monotone turn sequence of $n$ turns for $t = 1, 2$, write a program to compute the minimum perimeter of simple $t$-monotone rectilinear polygons that realize the input $t$-monotone turn sequence.", "inputFormat": "Your program is to read from standard input. The input is one line containing a string of $n$ turns of two uppercase letters L and R that is a $t$-monotone turn sequence, where $t = 1, 2$ and $4 \\leq n \\leq 10^{t+3}$.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain the positive integer that is the minimum perimeter of simple $t$-monotone rectilinear polygons that realize the input $t$-monotone turn sequence for $t = 1, 2$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Seoul R] Castle Design", "background": "", "description": "The ICPC kingdom has decided to build a new castle. The boundary of the castle is designed as a **rectilinear polygon** with edges parallel to the $x$-axis or to the $y$-axis. To minimize the damage exposed by the enemy attack, the kingdom wants to minimize the perimeter of the rectilinear polygon. Let us go into more detail.\n\nA rectilinear polygon $P$ of $n$ vertices with integer coordinates realizes a **turn sequence** $S$ of length $n$ of two letters L and R if there is a counterclockwise traverse along the boundary of $P$ such that the turns at vertices of $P$, encountered during the traverse, form the turn sequence $S$; the left turn at a convex vertex corresponds to L and the right turn at a reflex vertex corresponds to R. For example, the rectilinear polygon in Figure B.1(a) realizes the turn sequence $S = \\text{RLLRLLLLRRLRIRLLL}$ of length 16. Another turn sequence $S = \\text{LLRLLRLLRLLRLLR}$ of length 14 can be realized by rectilinear polygons in Figure B.1(b) and B.1(c). Note that a turn sequence can have infinitely many realizations of rectilinear polygons in the integral plane.\n\nA polygon is **simple** if there are no two edges that intersect except at the end vertices of adjacent edges. A polygon is **monotone** to an axis if its intersection with a line orthogonal to the axis is at most one segment. The monotone polygon is called **2-monotone** if it is monotone to both $x$-axis and the $y$-axis, and **1-monotone** if it is monotone to the one axis but not to the other axis. For example, the polygon in Figure B.1(a) is 1-monotone because it is monotone to only one axis, the $x$-axis, while the polygons in Figure B.1(b) and B.1(c) are 2-monotone. A turn sequence is also said to be **$t$-monotone** if any simple rectilinear polygon realizing the turn sequence is $t$-monotone where $t = 1, 2$.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/grpmlqo9.png)\n\nFigure B.1 (a) A simple 1-monotone rectilinear polygon realizing a 1-monotone turn sequence RLLRLLLRRLLRIRLLL (starting from the marked vertex). (b) A simple 2-monotone rectilinear polygon realizing a 2-monotone turn sequence LLRLLRLLRLLRLLR (starting from the marked vertex). (c) The 2-monotone rectilinear polygon with the minimum perimeter for the turn sequence in (b).\n:::\n\nThe perimeter of a rectilinear polygon is the sum of the length of its edges. The perimeter of the polygon in Figure B.1(b) is 18, but this is not minimum for `LLRLLRLLRLLRLLR`. Its minimum perimeter should be 16 as in Figure B.1(c).\n\nGiven a $t$-monotone turn sequence of $n$ turns for $t = 1, 2$, write a program to compute the minimum perimeter of simple $t$-monotone rectilinear polygons that realize the input $t$-monotone turn sequence.", "inputFormat": "Your program is to read from standard input. The input is one line containing a string of $n$ turns of two uppercase letters L and R that is a $t$-monotone turn sequence, where $t = 1, 2$ and $4 \\leq n \\leq 10^{t+3}$.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain the positive integer that is the minimum perimeter of simple $t$-monotone rectilinear polygons that realize the input $t$-monotone turn sequence for $t = 1, 2$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Seoul R] Castle Design", "background": "", "description": "ICPC 王国决定建造一座新的城堡。城堡的边界被设计为一个**直角多边形**，其边平行于 $x$ 轴或 $y$ 轴。为了最小化暴露在敌人攻击下的损害，王国希望最小化该直角多边形的周长。让我们进一步详细说明。\n\n一个具有 $n$ 个整数坐标顶点的直角多边形 $P$ **实现** 了一个长度为 $n$、由字母 L 和 R 组成的**转向序列** $S$，如果存在一种沿 $P$ 边界逆时针的遍历，使得在遍历过程中遇到的 $P$ 的顶点处的转向构成了转向序列 $S$；在凸顶点处的左转对应 L，在凹顶点处的右转对应 R。例如，图 B.1(a) 中的直角多边形实现了长度为 $16$ 的转向序列 $S = \\text{RLLRLLLLRRLRIRLLL}$。另一个长度为 $14$ 的转向序列 $S = \\text{LLRLLRLLRLLRLLR}$ 可以由图 B.1(b) 和 B.1(c) 中的直角多边形实现。请注意，一个转向序列在整数平面上可以有无限多个直角多边形实现。\n\n一个多边形如果是**简单的**，则除了相邻边的端点外，没有两条边相交。一个多边形如果相对于某个坐标轴是**单调的**，则其与垂直于该轴的直线的交点最多为一个线段。单调多边形如果同时相对于 $x$ 轴和 $y$ 轴都是单调的，则称为 **2-单调**；如果仅相对于一个轴是单调的，而相对于另一个轴不是，则称为 **1-单调**。例如，图 B.1(a) 中的多边形是 1-单调的，因为它仅对 $x$ 轴单调；而图 B.1(b) 和 B.1(c) 中的多边形是 2-单调的。一个转向序列也被称为 **$t$-单调**，如果任何实现该转向序列的简单直角多边形都是 $t$-单调的，其中 $t = 1, 2$。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/grpmlqo9.png)\n\n图 B.1 (a) 一个实现 1-单调转向序列 RLLRLLLRRLLRIRLLL 的简单 1-单调直角多边形（从标记顶点开始）。(b) 一个实现 2-单调转向序列 LLRLLRLLRLLRLLR 的简单 2-单调直角多边形（从标记顶点开始）。(c) 对于 (b) 中的转向序列，具有最小周长的 2-单调直角多边形。\n:::\n\n直角多边形的周长是其各边长度的总和。图 B.1(b) 中多边形的周长是 $18$，但这不是 $\\text{LLRLLRLLRLLRLLR}$ 的最小周长。其最小周长应为 $16$，如图 B.1(c) 所示。\n\n给定一个长度为 $n$ 的 $t$-单调转向序列（$t = 1, 2$），请编写一个程序，计算能够实现该输入 $t$-单调转向序列的简单 $t$-单调直角多边形的最小周长。", "inputFormat": "你的程序需要从标准输入读取数据。输入是一行，包含一个由大写字母 L 和 R 组成的长度为 $n$ 的转向序列字符串，它是一个 $t$-单调转向序列，其中 $t = 1, 2$，且 $4 \\leq n \\leq 10^{t+3}$。", "outputFormat": "你的程序需要向标准输出写入数据。输出恰好一行。该行应包含一个正整数，表示能够实现输入 $t$-单调转向序列（$t = 1, 2$）的简单 $t$-单调直角多边形的最小周长。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14724", "type": "P", "difficulty": 5, "samples": [["5\n0 0\n2 4\n6 2\n6 -2\n7 3", "8"], ["4\n0 0\n10 0\n5 10\n3 2", "3"], ["10\n10 10\n1 0\n4 8\n-1 -4\n-7 -4\n-3 2\n5 -10\n-10 -5\n1 1\n5 -3", "170"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2022", "ICPC", "首尔"], "title": "[ICPC 2022 Seoul R] Empty Quadrilaterals", "background": "", "description": "A **quadrilateral** is a polygon with exactly four distinct corners and four distinct sides, without any crossing between its sides. In this problem, you are given a set $P$ of $n$ points in the plane, no three of which are collinear, and asked to count the number of all quadrilaterals whose corners are members of the set $P$ and whose interior contains no other points in $P$.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/potkihwj.png)\n:::\n\nFor example, assume that $P$ consists of five points as shown in the left of the figure above. There are nine distinct quadrilaterals in total whose corners are members of $P$, while only one of them contains a point of $P$ in its interior, as in the right of the figure above. Therefore, there are exactly eight quadrilaterals satisfying the condition and your program must print out 8 as the correct answer.\n", "inputFormat": "Your program is to read from standard input. The input starts with a line containing an integer $n$ ($1 \\leq n \\leq 300$), where $n$ denotes the number of points in the set $P$. In the following $n$ lines, each line consists of two integers, ranging from $-10^9$ to $10^9$, representing the coordinates of a point in $P$. There are no three points in $P$ that are collinear.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line consisting of a single integer that represents the number of quadrilaterals whose corners are members of the set $P$ and whose interior contains no other points in $P$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Seoul R] Empty Quadrilaterals", "background": "", "description": "A **quadrilateral** is a polygon with exactly four distinct corners and four distinct sides, without any crossing between its sides. In this problem, you are given a set $P$ of $n$ points in the plane, no three of which are collinear, and asked to count the number of all quadrilaterals whose corners are members of the set $P$ and whose interior contains no other points in $P$.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/potkihwj.png)\n:::\n\nFor example, assume that $P$ consists of five points as shown in the left of the figure above. There are nine distinct quadrilaterals in total whose corners are members of $P$, while only one of them contains a point of $P$ in its interior, as in the right of the figure above. Therefore, there are exactly eight quadrilaterals satisfying the condition and your program must print out 8 as the correct answer.\n", "inputFormat": "Your program is to read from standard input. The input starts with a line containing an integer $n$ ($1 \\leq n \\leq 300$), where $n$ denotes the number of points in the set $P$. In the following $n$ lines, each line consists of two integers, ranging from $-10^9$ to $10^9$, representing the coordinates of a point in $P$. There are no three points in $P$ that are collinear.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line consisting of a single integer that represents the number of quadrilaterals whose corners are members of the set $P$ and whose interior contains no other points in $P$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Seoul R] Empty Quadrilaterals", "background": "", "description": "一个**四边形**是一个恰好有四个不同顶点和四条不同边的多边形，且其边之间没有任何交叉。在本问题中，给定平面上 $n$ 个点的集合 $P$，其中任意三点不共线，要求计算所有满足以下条件的四边形的数量：其顶点是集合 $P$ 中的点，并且其内部不包含 $P$ 中的任何其他点。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/potkihwj.png)\n:::\n\n例如，假设 $P$ 由如上图左侧所示的五个点组成。总共有九个不同的四边形，其顶点都是 $P$ 中的点，但其中只有一个四边形的内部包含 $P$ 中的一个点，如上图右侧所示。因此，恰好有八个四边形满足条件，你的程序必须输出 $8$ 作为正确答案。", "inputFormat": "你的程序需要从标准输入读取数据。输入的第一行包含一个整数 $n$ ($1 \\leq n \\leq 300$)，其中 $n$ 表示集合 $P$ 中的点数。接下来的 $n$ 行，每行包含两个整数，范围从 $-10^9$ 到 $10^9$，表示 $P$ 中一个点的坐标。保证 $P$ 中不存在三点共线。", "outputFormat": "你的程序需要向标准输出写入数据。输出恰好一行，包含一个整数，表示满足条件的四边形的数量：其顶点是集合 $P$ 中的点，且其内部不包含 $P$ 中的任何其他点。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14725", "type": "P", "difficulty": 4, "samples": [["4\n3 2 2 3", "4"], ["5\n1 1 1 1 1", "1"], ["7\n1 3 2 3 4 2 2", "6"]], "limits": {"time": [400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["动态规划 DP", "2022", "ICPC", "单调栈", "首尔"], "title": "[ICPC 2022 Seoul R] Folding Stick", "background": "", "description": "There is a folding stick made up of $n$ segments of positive length. The segments are connected by hinges (stretchable strings), allowing the segments to be folded 180 degrees at each hinge. The **wrapping length** is said to be the length of the folded stick after the stick is folded at hinges one or more. Depending on the folding strategy, the wrapping length may be different.\n\nYou are to find the minimum wrapping length under the condition that the stick is folded in the following way: First, place the segments of the stick along a horizontal line. Then, fold the stick clockwise from left to right. During folding, the segment attached to the left side of each hinge rotates 180 degrees clockwise or not at all.\n\nFor example, the figure below shows a four-segment stick with a sum of segment lengths of 10. In the figure, the lengths of the segments are 3, 2, 2, and 3 from left to right, and the hinges are marked with ①, ②, ③.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/vsm99tzh.png)\n:::\n\nIn this example, the stick cannot be folded at both hinges ① and ②. This is because if the stick is folded at hinge ① and then at hinge ②, the segment with length 3 passing over the hinge ② will be broken. If it is folded only at hinge ②, the wrapping length is 5. If it is folded at hinges ① and ③ in order, the wrapping length is 4 as shown in the figure below.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/96ppywpi.png)\n:::\n\nGiven a sequence of segments lengths of a folding stick, write a program to output the minimum wrapping length of the stick.", "inputFormat": "Your program is to read from standard input. The input starts with a line containing an integer, $n$ ($2 \\leq n \\leq 100,000$), where $n$ is the number of segments of a folding stick. The next line contains $n$ positive integers which represent a sequence of lengths of segments from the leftmost one to rightmost one of the stick. Each segment length is no more than 20,000.", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain the positive integer representing the minimum wrapping length.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Seoul R] Folding Stick", "background": "", "description": "There is a folding stick made up of $n$ segments of positive length. The segments are connected by hinges (stretchable strings), allowing the segments to be folded 180 degrees at each hinge. The **wrapping length** is said to be the length of the folded stick after the stick is folded at hinges one or more. Depending on the folding strategy, the wrapping length may be different.\n\nYou are to find the minimum wrapping length under the condition that the stick is folded in the following way: First, place the segments of the stick along a horizontal line. Then, fold the stick clockwise from left to right. During folding, the segment attached to the left side of each hinge rotates 180 degrees clockwise or not at all.\n\nFor example, the figure below shows a four-segment stick with a sum of segment lengths of 10. In the figure, the lengths of the segments are 3, 2, 2, and 3 from left to right, and the hinges are marked with ①, ②, ③.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/vsm99tzh.png)\n:::\n\nIn this example, the stick cannot be folded at both hinges ① and ②. This is because if the stick is folded at hinge ① and then at hinge ②, the segment with length 3 passing over the hinge ② will be broken. If it is folded only at hinge ②, the wrapping length is 5. If it is folded at hinges ① and ③ in order, the wrapping length is 4 as shown in the figure below.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/96ppywpi.png)\n:::\n\nGiven a sequence of segments lengths of a folding stick, write a program to output the minimum wrapping length of the stick.", "inputFormat": "Your program is to read from standard input. The input starts with a line containing an integer, $n$ ($2 \\leq n \\leq 100,000$), where $n$ is the number of segments of a folding stick. The next line contains $n$ positive integers which represent a sequence of lengths of segments from the leftmost one to rightmost one of the stick. Each segment length is no more than 20,000.", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain the positive integer representing the minimum wrapping length.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Seoul R] Folding Stick", "background": "", "description": "有一根可折叠的棍子，由 $n$ 段长度为正的节段组成。节段之间通过铰链（可伸缩的细绳）连接，允许每段在铰链处折叠 $180$ 度。**缠绕长度** 是指棍子在一个或多个铰链处折叠后折叠部分的长度。根据折叠策略的不同，缠绕长度可能不同。\n\n你需要在以下折叠方式的条件下找到最小的缠绕长度：首先，将棍子的各节段沿水平线放置。然后，从左到右顺时针折叠棍子。在折叠过程中，每个铰链左侧所连接的节段要么顺时针旋转 $180$ 度，要么完全不旋转。\n\n例如，下图展示了一根四节段的棍子，节段长度总和为 $10$。图中，从左到右各节段的长度分别为 $3$、$2$、$2$ 和 $3$，铰链标记为 ①、②、③。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/vsm99tzh.png)\n:::\n\n在此例中，棍子不能在铰链 ① 和 ② 处同时折叠。这是因为如果先在铰链 ① 处折叠，再在铰链 ② 处折叠，经过铰链 ② 的长度为 $3$ 的节段将被折断。如果仅在铰链 ② 处折叠，缠绕长度为 $5$。如果依次在铰链 ① 和 ③ 处折叠，缠绕长度为 $4$，如下图所示。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/96ppywpi.png)\n:::\n\n给定一根可折叠棍子的节段长度序列，请编写程序输出该棍子的最小缠绕长度。", "inputFormat": "你的程序需要从标准输入读取数据。输入的第一行包含一个整数 $n$ ($2 \\leq n \\leq 100,000$)，其中 $n$ 是可折叠棍子的节段数。第二行包含 $n$ 个正整数，表示从棍子最左端到最右端的节段长度序列。每段长度不超过 $20,000$。", "outputFormat": "你的程序需要向标准输出写入数据。输出恰好一行。该行应包含一个正整数，表示最小缠绕长度。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
