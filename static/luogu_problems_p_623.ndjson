{"pid": "P13636", "type": "P", "difficulty": 0, "samples": [["4\n\n-1\n\n-1\n\n1\n\n1", "\nC 1 2\n\nC 2 3\n\nC 3 4\n\nS 3 4"], ["1\n\n1", "\nS 1 1"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "交互题", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2021] Imprecise Permutation Sort", "background": "", "description": "This is an interactive problem.  \n\nA permutation $a[1], a[2], \\ldots, a[n]$ of integers from $1$ to $n$ is hidden from you.  \n\nYour task is to sort it in ascending order by comparing and swapping pairs of elements. This problem could be pretty easy, but the jury member responsible for the problem was too concentrated on floating-point arithmetic in problems G and J and implemented an \"imprecise\" comparator:  \n\n- If $\\frac{|a[i] - a[j]|}{max(a[i], a[j])} \\leq 0.01$, then return $0$;  \n- Otherwise, if $a[i] < a[j]$, then return $-1$;  \n- Otherwise, return $1$.  \n\nYour program can make queries to compare any two elements with this comparator, or to swap any two elements. After each swap, it will be told whether the permutation became sorted.  \n\nSort a permutation of size up to $16\\,384$ using no more than $300\\,000$ queries.  \n\n### Interaction \n\nReceive an integer $n$ from the jury's program — the size of the permutation ($1 \\leq n \\leq 16\\,384$). Then print queries and receive responses from the jury's program. After each query the output should be flushed and then a single integer should be read — the response to that query.  \n\nComparison queries have a format $\\tt{C\\ i\\ j}$, and swap queries have a format $\\tt{S\\ i\\ j}$, where $i$ and $j$ are indices of two elements ($1 \\leq i, j \\leq n$). Making queries with $i=j$ is allowed.  \n\nThe response to a comparison query is:  \n- $0$ if $a[i]$ \"approximately equals\" $a[j]$,  \n- $-1$ if $a[i] < a[j]$,  \n- $1$ if $a[i] > a[j]$.  \n\nA swap query swaps values in $a[i]$ and $a[j]$, and the response to a swap query is:  \n- $1$ if after this swap the array became sorted in ascending order,  \n- $0$ otherwise.  \n\nYour program should exit as soon as it receives $1$ as a response to a swap query.  \n\nThe program should make at least one swap query. For example, if the hidden permutation is already sorted, it can make a query $\\tt{S\\ 1\\ 1}$, receive a $1$, and exit.  \n\nThe interactor is not adaptive. The initial permutation is chosen by the jury's program in advance, before you make your first query. ", "inputFormat": "", "outputFormat": "", "hint": "", "locale": "en", "translations": {"en": {"title": "[NWRRC 2021] Imprecise Permutation Sort", "background": "", "description": "This is an interactive problem.  \n\nA permutation $a[1], a[2], \\ldots, a[n]$ of integers from $1$ to $n$ is hidden from you.  \n\nYour task is to sort it in ascending order by comparing and swapping pairs of elements. This problem could be pretty easy, but the jury member responsible for the problem was too concentrated on floating-point arithmetic in problems G and J and implemented an \"imprecise\" comparator:  \n\n- If $\\frac{|a[i] - a[j]|}{max(a[i], a[j])} \\leq 0.01$, then return $0$;  \n- Otherwise, if $a[i] < a[j]$, then return $-1$;  \n- Otherwise, return $1$.  \n\nYour program can make queries to compare any two elements with this comparator, or to swap any two elements. After each swap, it will be told whether the permutation became sorted.  \n\nSort a permutation of size up to $16\\,384$ using no more than $300\\,000$ queries.  \n\n### Interaction \n\nReceive an integer $n$ from the jury's program — the size of the permutation ($1 \\leq n \\leq 16\\,384$). Then print queries and receive responses from the jury's program. After each query the output should be flushed and then a single integer should be read — the response to that query.  \n\nComparison queries have a format $\\tt{C\\ i\\ j}$, and swap queries have a format $\\tt{S\\ i\\ j}$, where $i$ and $j$ are indices of two elements ($1 \\leq i, j \\leq n$). Making queries with $i=j$ is allowed.  \n\nThe response to a comparison query is:  \n- $0$ if $a[i]$ \"approximately equals\" $a[j]$,  \n- $-1$ if $a[i] < a[j]$,  \n- $1$ if $a[i] > a[j]$.  \n\nA swap query swaps values in $a[i]$ and $a[j]$, and the response to a swap query is:  \n- $1$ if after this swap the array became sorted in ascending order,  \n- $0$ otherwise.  \n\nYour program should exit as soon as it receives $1$ as a response to a swap query.  \n\nThe program should make at least one swap query. For example, if the hidden permutation is already sorted, it can make a query $\\tt{S\\ 1\\ 1}$, receive a $1$, and exit.  \n\nThe interactor is not adaptive. The initial permutation is chosen by the jury's program in advance, before you make your first query. ", "inputFormat": "", "outputFormat": "", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2021] Imprecise Permutation Sort", "background": null, "description": "这是一个交互题。\n\n有一个由 $1$ 到 $n$ 的整数构成的排列 $a[1], a[2], \\ldots, a[n]$ 被隐藏了起来。\n\n你的任务是通过比较和交换元素对，将其按升序排序。本题本应很简单，但出题人因为在 G 和 J 题中过于专注于浮点数运算，实现了一个“不精确”的比较器：\n\n- 如果 $\\frac{|a[i] - a[j]|}{\\max(a[i], a[j])} \\leq 0.01$，则返回 $0$；\n- 否则，如果 $a[i] < a[j]$，则返回 $-1$；\n- 否则，返回 $1$。\n\n你的程序可以使用该比较器对任意两个元素进行比较，也可以交换任意两个元素。每次交换后，系统会告知当前排列是否已经有序。\n\n请在不超过 $300\\,000$ 次查询内，将长度不超过 $16\\,384$ 的排列排序。\n\n### 交互说明\n\n首先，你会收到一个整数 $n$，表示排列的长度（$1 \\leq n \\leq 16\\,384$）。然后，你可以输出查询，并读取系统的响应。每次查询后需要刷新输出，并读取一个整数作为响应。\n\n比较查询格式为 $\\tt{C\\ i\\ j}$，交换查询格式为 $\\tt{S\\ i\\ j}$，其中 $i$ 和 $j$ 是元素的下标（$1 \\leq i, j \\leq n$）。允许 $i = j$。\n\n比较查询的响应为：\n- $0$，如果 $a[i]$ “近似等于” $a[j]$；\n- $-1$，如果 $a[i] < a[j]$；\n- $1$，如果 $a[i] > a[j]$。\n\n交换查询会交换 $a[i]$ 和 $a[j]$ 的值，响应为：\n- $1$，如果交换后数组已按升序排列；\n- $0$，否则。\n\n一旦收到交换查询的响应为 $1$，你的程序应立即退出。\n\n你的程序至少要进行一次交换查询。例如，如果初始排列已经有序，可以查询 $\\tt{S\\ 1\\ 1}$，收到 $1$ 后退出。\n\n交互器是非自适应的。排列在你第一次查询前就已确定。", "inputFormat": "无。", "outputFormat": "无。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13637", "type": "P", "difficulty": 6, "samples": [["1 1000 30\n10", "50.0000000000000"], ["1 1000 10\n30", "33.3333333333333"], ["4 1000 20\n10 20 30 40", "46.2500000000000\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2021] Journey in Fog", "background": "", "description": "Julia and Jane are two friends living at the opposite ends of a long narrow street of length $L$.\n\nToday, Julia needs to meet Jane and return home as soon as possible.\n\nJane has a list of speeds $v_1, v_2, \\ldots, v_n$. At time $0$, Jane picks an integer $i$ from $1$ to $n$ uniformly at random, and starts moving towards Julia at a constant speed of $v_i$.\n\nJulia is not as restricted in her movements, though. Starting from time $0$, Julia can freely move along the street in any direction at any speed not exceeding $V$. In particular, Julia can stay at the same place as long as she wants, move at speeds lower than $V$, and change her speed at any moment.\n\nIt's foggy outside. Hence, Julia and Jane can not see each other unless they are at the same point of the street. Also note that Julia does not know Jane's speed, but she knows the list $v_1, v_2, \\ldots, v_n$.\n\nSuppose Julia meets Jane and arrives back home at time $t$. Julia will follow a strategy that minimizes the expected value of $t$. Find that expected value.", "inputFormat": "The first line contains three integers $n$, $L$, and $V$ --- the number of speeds on Jane's list, the length of the street, and Julia's maximum speed ($1 \\le n \\le 10^5$; $1 \\le L \\le 10^9$; $1 \\le V \\le 10^6$).\n\nThe second line contains $n$ integers $v_1, v_2, \\ldots, v_n$ --- the list of possible speeds of Jane in ascending order ($1 \\le v_1 < v_2 < \\dotsb < v_n \\le 10^6$).", "outputFormat": "Print a single real number --- the expected amount of time it will take Julia to meet Jane and return back home, if she follows an optimal strategy. Your answer will be considered correct if its absolute or relative error doesn't exceed $10^{-9}$.", "hint": "In the first example test, Julia is much faster than Jane. It's best for Julia to move towards Jane as fast as she can, meet her at time $25$ at distance $750$ away from home, and return back home at time $50$.\n\nIn the second example test, Jane is much faster than Julia. It's best for Julia to just wait for Jane at home, where Jane will arrive at time $\\frac{1000}{30}$.", "locale": "en", "translations": {"en": {"title": "[NWRRC 2021] Journey in Fog", "background": "", "description": "Julia and Jane are two friends living at the opposite ends of a long narrow street of length $L$.\n\nToday, Julia needs to meet Jane and return home as soon as possible.\n\nJane has a list of speeds $v_1, v_2, \\ldots, v_n$. At time $0$, Jane picks an integer $i$ from $1$ to $n$ uniformly at random, and starts moving towards Julia at a constant speed of $v_i$.\n\nJulia is not as restricted in her movements, though. Starting from time $0$, Julia can freely move along the street in any direction at any speed not exceeding $V$. In particular, Julia can stay at the same place as long as she wants, move at speeds lower than $V$, and change her speed at any moment.\n\nIt's foggy outside. Hence, Julia and Jane can not see each other unless they are at the same point of the street. Also note that Julia does not know Jane's speed, but she knows the list $v_1, v_2, \\ldots, v_n$.\n\nSuppose Julia meets Jane and arrives back home at time $t$. Julia will follow a strategy that minimizes the expected value of $t$. Find that expected value.", "inputFormat": "The first line contains three integers $n$, $L$, and $V$ --- the number of speeds on Jane's list, the length of the street, and Julia's maximum speed ($1 \\le n \\le 10^5$; $1 \\le L \\le 10^9$; $1 \\le V \\le 10^6$).\n\nThe second line contains $n$ integers $v_1, v_2, \\ldots, v_n$ --- the list of possible speeds of Jane in ascending order ($1 \\le v_1 < v_2 < \\dotsb < v_n \\le 10^6$).", "outputFormat": "Print a single real number --- the expected amount of time it will take Julia to meet Jane and return back home, if she follows an optimal strategy. Your answer will be considered correct if its absolute or relative error doesn't exceed $10^{-9}$.", "hint": "In the first example test, Julia is much faster than Jane. It's best for Julia to move towards Jane as fast as she can, meet her at time $25$ at distance $750$ away from home, and return back home at time $50$.\n\nIn the second example test, Jane is much faster than Julia. It's best for Julia to just wait for Jane at home, where Jane will arrive at time $\\frac{1000}{30}$.", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2021] Journey in Fog", "background": null, "description": "Julia 和 Jane 是住在一条长度为 $L$ 的狭长街道两端的朋友。\n\n今天，Julia 需要去见 Jane，并尽快返回家中。\n\nJane 有一个速度列表 $v_1, v_2, \\ldots, v_n$。在时间 $0$ 时，Jane 会从 $1$ 到 $n$ 中均匀随机选择一个整数 $i$，并以恒定速度 $v_i$ 朝 Julia 走去。\n\n而 Julia 的行动则没有这么多限制。从时间 $0$ 开始，Julia 可以在街道上任意方向自由移动，速度不超过 $V$。特别地，Julia 可以在原地停留任意长时间，也可以以低于 $V$ 的速度移动，并且可以随时改变速度。\n\n由于外面有雾，Julia 和 Jane 只有在街道上的同一个点时才能看到对方。此外，Julia 并不知道 Jane 的具体速度，但她知道速度列表 $v_1, v_2, \\ldots, v_n$。\n\n假设 Julia 在时间 $t$ 与 Jane 相遇并返回家中。Julia 会采取一种策略，使得 $t$ 的期望值最小。请你求出这个期望值。", "inputFormat": "第一行包含三个整数 $n$、$L$ 和 $V$，分别表示 Jane 的速度列表长度、街道长度和 Julia 的最大速度（$1 \\le n \\le 10^5$；$1 \\le L \\le 10^9$；$1 \\le V \\le 10^6$）。\n\n第二行包含 $n$ 个整数 $v_1, v_2, \\ldots, v_n$，表示 Jane 可能的速度，按升序排列（$1 \\le v_1 < v_2 < \\dotsb < v_n \\le 10^6$）。", "outputFormat": "输出一个实数，表示 Julia 采取最优策略时，从出发到与 Jane 相遇并返回家中的期望时间。若你的答案的绝对误差或相对误差不超过 $10^{-9}$，则视为正确。", "hint": "在第一个样例测试中，Julia 比 Jane 快得多。Julia 最优的做法是以最快速度朝 Jane 走去，在 $25$ 时刻于距离家 $750$ 的地方相遇，然后在 $50$ 时刻返回家中。\n\n在第二个样例测试中，Jane 比 Julia 快得多。Julia 最优的做法是一直在家等 Jane，Jane 会在 $\\frac{1000}{30}$ 时刻到达。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13638", "type": "P", "difficulty": 4, "samples": [["6 8\n1 5 2\n5 2 5\n3 5 4\n1 3 10\n3 4 6\n4 5 7\n4 6 8\n2 6 1", "3\n1 5 4 6"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "2021", "Special Judge", "广度优先搜索 BFS", "ICPC", "NWRRC"], "title": "[NWRRC 2021] Kaleidoscopic Route", "background": "", "description": "There are $n$ cities in Kaleidostan connected with $m$ bidirectional roads. The cities are numbered from $1$ to $n$. Each road has an integer called $\\textit{colorfulness}$. \n\nKeanu wants to travel from city $1$ to city $n$. He wants to take the $\\textit{shortest}$ route --- that is, the route with the smallest number of roads. Among all the shortest routes, he wants to take the $\\textit{kaleidoscopic}$ one --- that is, the route with the largest possible difference between the maximum and the minimum colorfulnesses of its roads. Help Keanu find such a route.", "inputFormat": "The first line contains two integers $n$ and $m$ --- the number of cities and the number of roads ($2 \\le n \\le 10^5$; $1 \\le m \\le 2 \\cdot 10^5$).\n\nThe $i$-th of the following $m$ lines contains three integers $v_i$, $u_i$, and $c_i$ --- the indices of the cities connected by the $i$-th road, and the colorfulness of the $i$-th road ($1 \\le v_i, u_i \\le n$; $v_i \\neq u_i$; $0\\le c_i \\le 10^9$).\n\nEach pair of cities is connected by at most one road. It is guaranteed that you can travel from any city to any other city using the roads.", "outputFormat": "In the first line, print a single integer $k$ --- the number of roads in the required route. \n\nIn the second line, print $k+1$ integers $c_0, c_1, \\ldots, c_k$ --- the sequence of cities on the route ($1 \\le c_i \\le n$; $c_0 = 1$; $c_k = n$).", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/bun5oktu.png)\n\nIn the example test, the required route consists of $3$ roads, and the difference between the maximum and the minimum colorfulnesses of its roads is $8-2=6$.", "locale": "en", "translations": {"en": {"title": "[NWRRC 2021] Kaleidoscopic Route", "background": "", "description": "There are $n$ cities in Kaleidostan connected with $m$ bidirectional roads. The cities are numbered from $1$ to $n$. Each road has an integer called $\\textit{colorfulness}$. \n\nKeanu wants to travel from city $1$ to city $n$. He wants to take the $\\textit{shortest}$ route --- that is, the route with the smallest number of roads. Among all the shortest routes, he wants to take the $\\textit{kaleidoscopic}$ one --- that is, the route with the largest possible difference between the maximum and the minimum colorfulnesses of its roads. Help Keanu find such a route.", "inputFormat": "The first line contains two integers $n$ and $m$ --- the number of cities and the number of roads ($2 \\le n \\le 10^5$; $1 \\le m \\le 2 \\cdot 10^5$).\n\nThe $i$-th of the following $m$ lines contains three integers $v_i$, $u_i$, and $c_i$ --- the indices of the cities connected by the $i$-th road, and the colorfulness of the $i$-th road ($1 \\le v_i, u_i \\le n$; $v_i \\neq u_i$; $0\\le c_i \\le 10^9$).\n\nEach pair of cities is connected by at most one road. It is guaranteed that you can travel from any city to any other city using the roads.", "outputFormat": "In the first line, print a single integer $k$ --- the number of roads in the required route. \n\nIn the second line, print $k+1$ integers $c_0, c_1, \\ldots, c_k$ --- the sequence of cities on the route ($1 \\le c_i \\le n$; $c_0 = 1$; $c_k = n$).", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/bun5oktu.png)\n\nIn the example test, the required route consists of $3$ roads, and the difference between the maximum and the minimum colorfulnesses of its roads is $8-2=6$.", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2021] Kaleidoscopic Route", "background": null, "description": "Kaleidostan 有 $n$ 个城市，通过 $m$ 条双向道路相连。城市编号从 $1$ 到 $n$。每条道路都有一个整数，称为“色彩度”。\n\nKeanu 想从城市 $1$ 前往城市 $n$。他希望选择一条“最短”路线——即经过道路数最少的路线。在所有最短路线中，他又希望选择一条“万花筒”路线——即这条路线中道路的最大色彩度与最小色彩度之差尽可能大。请你帮助 Keanu 找到这样一条路线。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$，分别表示城市数和道路数（$2 \\le n \\le 10^5$，$1 \\le m \\le 2 \\cdot 10^5$）。\n\n接下来的 $m$ 行中，第 $i$ 行包含三个整数 $v_i$、$u_i$ 和 $c_i$，表示第 $i$ 条道路连接城市 $v_i$ 和 $u_i$，且色彩度为 $c_i$（$1 \\le v_i, u_i \\le n$，$v_i \\neq u_i$，$0 \\le c_i \\le 10^9$）。\n\n任意一对城市之间至多有一条道路。保证任意两个城市之间都可以通过道路互达。", "outputFormat": "第一行输出一个整数 $k$，表示所需路线经过的道路数。\n\n第二行输出 $k+1$ 个整数 $c_0, c_1, \\ldots, c_k$，表示路线经过的城市序列（$1 \\le c_i \\le n$，$c_0 = 1$，$c_k = n$）。", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/bun5oktu.png)\n\n在示例测试中，所需路线经过 $3$ 条道路，且其最大色彩度与最小色彩度之差为 $8-2=6$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13639", "type": "P", "difficulty": 4, "samples": [["5 3\n###\n#.#\n###\n..#\n..#", "1 0"], ["5 3\n###\n#..\n##.\n#..\n#..", "0 1"], ["5 8\n###..###\n#.#..#..\n###..##.\n..#..#..\n..#..#..", "1 1"], ["8 8\n.....###\n###..#.#\n#.######\n###.####\n#.###.##\n#.#.###.\n..#...#.\n......#.", "2 2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "ICPC", "NWRRC"], "title": "[NWRRC 2021] Letters Q and F", "background": "", "description": "Little Lev is learning how to draw letters $\\tt{Q}$ and $\\tt{F}$. Initially, he has a white grid of size $n \\times m$. Then he will draw several letters of one of the following two shapes:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nmufwv6b.png)\n\nLev will not rotate or mirror these two shapes. Every time he draws a new letter, he will choose a position for the letter inside the grid and paint all cells of the shape black. Lev will only draw letters in such a way that before drawing all black cells of the letter are white --- that is, he will never paint a cell twice.\n\nYou are given the final coloring of the grid. Count the number of letters $\\tt{Q}$ and letters $\\tt{F}$ drawn by Lev.", "inputFormat": "The first line contains two integers $n$ and $m$ --- the height and the width of the grid ($5 \\le n \\le 300$; $3 \\le m \\le 300$).\n\nThe next $n$ lines contain $m$ characters each, denoting the final state of the grid. A white cell is denoted by $\\tt{.}$, a black cell is denoted by $\\tt{\\#}$.\n\nIt is guaranteed that the grid is a valid result of Lev's drawing.", "outputFormat": "Print two integers --- the number of letters $\\tt{Q}$ and the number of letters $\\tt{F}$ drawn by Lev, respectively.", "hint": "Illustration for the fourth example test:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xurousuy.png)", "locale": "en", "translations": {"en": {"title": "[NWRRC 2021] Letters Q and F", "background": "", "description": "Little Lev is learning how to draw letters $\\tt{Q}$ and $\\tt{F}$. Initially, he has a white grid of size $n \\times m$. Then he will draw several letters of one of the following two shapes:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nmufwv6b.png)\n\nLev will not rotate or mirror these two shapes. Every time he draws a new letter, he will choose a position for the letter inside the grid and paint all cells of the shape black. Lev will only draw letters in such a way that before drawing all black cells of the letter are white --- that is, he will never paint a cell twice.\n\nYou are given the final coloring of the grid. Count the number of letters $\\tt{Q}$ and letters $\\tt{F}$ drawn by Lev.", "inputFormat": "The first line contains two integers $n$ and $m$ --- the height and the width of the grid ($5 \\le n \\le 300$; $3 \\le m \\le 300$).\n\nThe next $n$ lines contain $m$ characters each, denoting the final state of the grid. A white cell is denoted by $\\tt{.}$, a black cell is denoted by $\\tt{\\#}$.\n\nIt is guaranteed that the grid is a valid result of Lev's drawing.", "outputFormat": "Print two integers --- the number of letters $\\tt{Q}$ and the number of letters $\\tt{F}$ drawn by Lev, respectively.", "hint": "Illustration for the fourth example test:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xurousuy.png)", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2021] Letters Q and F", "background": null, "description": "小 Lev 正在学习如何绘制字母 $\\tt{Q}$ 和 $\\tt{F}$。最初，他有一个 $n \\times m$ 的白色网格。然后他会在网格上绘制若干个如下两种形状之一的字母：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nmufwv6b.png)\n\nLev 不会旋转或翻转这两种形状。每次绘制新字母时，他会选择网格中的一个位置，并将该形状的所有格子涂黑。Lev 只会在所有要涂黑的格子都是白色的情况下绘制字母——也就是说，他不会重复涂黑同一个格子。\n\n现在给出网格的最终涂色状态。请你统计 Lev 绘制了多少个字母 $\\tt{Q}$ 和多少个字母 $\\tt{F}$。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$，表示网格的高度和宽度（$5 \\le n \\le 300$，$3 \\le m \\le 300$）。\n\n接下来的 $n$ 行，每行包含 $m$ 个字符，表示网格的最终状态。白色格子用 $\\tt{.}$ 表示，黑色格子用 $\\tt{\\#}$ 表示。\n\n保证该网格是 Lev 按照上述规则绘制的合法结果。", "outputFormat": "输出两个整数，分别表示绘制的字母 $\\tt{Q}$ 和字母 $\\tt{F}$ 的数量。", "hint": "第四个样例的示意图如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xurousuy.png)\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13640", "type": "P", "difficulty": 0, "samples": [["2\n2\na=1\nb=2\n2\nb=1\na=2\n2\na 1\nb 1", "No"], ["3\n5\nstart=1\ncounter=1111\ncounter=10\ncounter=3333\nfinish=1\n4\nstart=2\ncounter=20\ncounter=10\nfinish=2\n3\nstart=3\nqwerty=787788\nfinish=3\n4\ncounter 10\nstart 1\nfinish 1\nqwerty 787788", "Yes\n2 3 3 2 1 1 3 1 1 2 2 1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2021] Multithreaded Program", "background": "", "description": "Maurice is debugging a multithreaded program on his old machine. The program has several threads operating on a set of shared variables. Each thread executes its own sequence of assignments in a predefined \\textit{program order}. Each assignment sets one of the variables to an integer value.\n\nWhen the program is run, assignments from different threads can be executed in any order. The only guarantee is that each thread executes all of its assignments in the program order.\n\nFor example, let's say the program has three threads that have $2$, $2$, and $1$ assignments in their sequences, respectively. Then one valid program execution looks as follows:\n- thread $1$ executes the first assignment in its sequence;\n- thread $2$ executes the first assignment in its sequence;\n- thread $2$ executes the second assignment in its sequence;\n- thread $1$ executes the second assignment in its sequence;\n- thread $3$ executes the only assignment in its sequence.\n\nThis execution can be described as $1, 2, 2, 1, 3$, where numbers specify the threads performing each assignment, in order. Note that many other valid executions are possible.\n\nMaurice suspects that his machine is broken and can work incorrectly. He has run his program and recorded the values of all variables at the end.\n\nFind an execution of the program that performs all assignments and leads to the recorded values of all variables, or report that the machine is indeed broken and such an execution does not exist.", "inputFormat": "The first line contains a single integer $t$ --- the number of threads ($1 \\leq t \\leq 100$). The threads are numbered from $1$ to $t$. The following lines describe $t$ sequences of assignments, one per thread.\n\nThe first line of the $i$-th description contains an integer $l_i$ --- the length of the sequence of assignments of the $i$-th thread ($1 \\leq l_i \\leq 100$). Each of the following $l_i$ lines contains an assignment in the form $\\texttt{<variable>=<value>}$. The assignments are listed in the program order. Variable names consist of up to $10$ lowercase English letters, and values are positive integers not exceeding $10^9$.\n\nThe first of the remaining lines contains an integer $k$ --- the number of variables ($1 \\le k \\le 10\\,000$). Each of the following $k$ lines contains a variable name and its recorded value, which is a positive integer not exceeding $10^9$. Each variable used in the program is listed exactly once, and each listed variable is used in at least one assignment.", "outputFormat": "Print $\\texttt{Yes}$ if an execution producing the recorded values exists, and $\\texttt{No}$ otherwise.\n\nIf an execution exists, print a line containing $s = l_1 + l_2 + \\dotsb + l_t$ integers $c_1, c_2, \\ldots, c_s$, describing such an execution ($1 \\le c_i \\le t$). This specifies that the first assignment is performed by thread $c_1$, the second one is performed by thread $c_2$, and so on. Each thread performs its assignments in the program order. After the $s$-th assignment, each variable must have the recorded value. The $i$-th thread must appear in the description exactly $l_i$ times.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NWRRC 2021] Multithreaded Program", "background": "", "description": "Maurice is debugging a multithreaded program on his old machine. The program has several threads operating on a set of shared variables. Each thread executes its own sequence of assignments in a predefined \\textit{program order}. Each assignment sets one of the variables to an integer value.\n\nWhen the program is run, assignments from different threads can be executed in any order. The only guarantee is that each thread executes all of its assignments in the program order.\n\nFor example, let's say the program has three threads that have $2$, $2$, and $1$ assignments in their sequences, respectively. Then one valid program execution looks as follows:\n- thread $1$ executes the first assignment in its sequence;\n- thread $2$ executes the first assignment in its sequence;\n- thread $2$ executes the second assignment in its sequence;\n- thread $1$ executes the second assignment in its sequence;\n- thread $3$ executes the only assignment in its sequence.\n\nThis execution can be described as $1, 2, 2, 1, 3$, where numbers specify the threads performing each assignment, in order. Note that many other valid executions are possible.\n\nMaurice suspects that his machine is broken and can work incorrectly. He has run his program and recorded the values of all variables at the end.\n\nFind an execution of the program that performs all assignments and leads to the recorded values of all variables, or report that the machine is indeed broken and such an execution does not exist.", "inputFormat": "The first line contains a single integer $t$ --- the number of threads ($1 \\leq t \\leq 100$). The threads are numbered from $1$ to $t$. The following lines describe $t$ sequences of assignments, one per thread.\n\nThe first line of the $i$-th description contains an integer $l_i$ --- the length of the sequence of assignments of the $i$-th thread ($1 \\leq l_i \\leq 100$). Each of the following $l_i$ lines contains an assignment in the form $\\texttt{<variable>=<value>}$. The assignments are listed in the program order. Variable names consist of up to $10$ lowercase English letters, and values are positive integers not exceeding $10^9$.\n\nThe first of the remaining lines contains an integer $k$ --- the number of variables ($1 \\le k \\le 10\\,000$). Each of the following $k$ lines contains a variable name and its recorded value, which is a positive integer not exceeding $10^9$. Each variable used in the program is listed exactly once, and each listed variable is used in at least one assignment.", "outputFormat": "Print $\\texttt{Yes}$ if an execution producing the recorded values exists, and $\\texttt{No}$ otherwise.\n\nIf an execution exists, print a line containing $s = l_1 + l_2 + \\dotsb + l_t$ integers $c_1, c_2, \\ldots, c_s$, describing such an execution ($1 \\le c_i \\le t$). This specifies that the first assignment is performed by thread $c_1$, the second one is performed by thread $c_2$, and so on. Each thread performs its assignments in the program order. After the $s$-th assignment, each variable must have the recorded value. The $i$-th thread must appear in the description exactly $l_i$ times.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2021] Multithreaded Program", "background": null, "description": "Maurice 正在他的老旧机器上调试一个多线程程序。该程序有若干线程操作一组共享变量。每个线程按照预定的“程序顺序”执行自己的赋值序列。每次赋值会将某个变量设置为一个整数值。\n\n当程序运行时，不同线程的赋值可以以任意顺序执行。唯一的保证是，每个线程内部的赋值必须按照程序顺序依次执行。\n\n例如，假设程序有三个线程，它们的赋值序列长度分别为 $2$、$2$ 和 $1$。那么一种合法的程序执行顺序如下：\n- 线程 $1$ 执行其序列中的第一个赋值；\n- 线程 $2$ 执行其序列中的第一个赋值；\n- 线程 $2$ 执行其序列中的第二个赋值；\n- 线程 $1$ 执行其序列中的第二个赋值；\n- 线程 $3$ 执行其唯一的赋值。\n\n这种执行顺序可以描述为 $1, 2, 2, 1, 3$，其中数字表示每一步执行赋值的线程编号。注意，还存在许多其他合法的执行顺序。\n\nMaurice 怀疑他的机器有故障，可能会出现错误的行为。他已经运行了程序，并记录了所有变量在结束时的值。\n\n请你找出一种执行顺序，使得所有赋值都被执行，并且最终所有变量的值与记录一致；或者报告机器确实有故障，不存在这样的执行顺序。", "inputFormat": "第一行包含一个整数 $t$，表示线程数（$1 \\leq t \\leq 100$）。线程编号为 $1$ 到 $t$。接下来的 $t$ 段描述每个线程的赋值序列，每段一行。\n\n第 $i$ 段的第一行包含一个整数 $l_i$，表示第 $i$ 个线程的赋值序列长度（$1 \\leq l_i \\leq 100$）。接下来的 $l_i$ 行，每行包含一个赋值，格式为 $\\texttt{<variable>=<value>}$. 这些赋值按照程序顺序给出。变量名由不超过 $10$ 个小写英文字母组成，赋值为不超过 $10^9$ 的正整数。\n\n剩下的第一行包含一个整数 $k$，表示变量的数量（$1 \\le k \\le 10\\,000$）。接下来的 $k$ 行，每行包含一个变量名和其记录的值，均为不超过 $10^9$ 的正整数。每个在程序中出现过的变量恰好出现一次，且每个列出的变量至少在某个赋值中被使用过。", "outputFormat": "如果存在一种执行顺序能得到记录的变量值，输出 $\\texttt{Yes}$；否则输出 $\\texttt{No}$。\n\n如果存在可行的执行顺序，输出一行 $s = l_1 + l_2 + \\dotsb + l_t$ 个整数 $c_1, c_2, \\ldots, c_s$，描述一种合法的执行顺序（$1 \\le c_i \\le t$）。这表示第 $i$ 步执行赋值的线程编号为 $c_i$。每个线程的赋值必须按照程序顺序依次执行。第 $i$ 个线程在序列中恰好出现 $l_i$ 次。执行完第 $s$ 步后，每个变量的值必须与记录值一致。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13641", "type": "P", "difficulty": 0, "samples": [["6\n4\n1 1\n1 1\n1 0\n1 0\n4\n1 0\n2 1\n1 1\n1 0\n1\n0 0\n2\n0 1\n0 1\n2\n1 0\n0 1\n3\n2 0\n0 1\n0 1", "Yes\n1 4 W\n2 3 W\n2 1 B\nNo\nYes\nYes\n2 1 B\nNo\nNo"]], "limits": {"time": [7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2021] New White-Black Tree", "background": "", "description": "Naomi has learnt about Red-Black trees, now it's time to learn about White-Black trees.\nShe is reading an algorithms book. Some pages contain pictures of trees, but the edges of the trees faded out through all these years. According to the text, each of these edges should be either white or black.\n\nNaomi noticed that each vertex has two integers written beside it. She guessed that the first integer is the number of white edges incident to the vertex, and the second is the number of black edges incident to the vertex.\n\nNaomi recreated all the pictures. Can you do that?", "inputFormat": "The first line contains an integer $t$ --- the number of pictures to recreate ($1 \\le t \\le 3 \\cdot 10^5$).\n\nThe following lines describe $t$ pictures. Each description starts with a line containing an integer $n$ --- the number of vertices in the tree ($1 \\le n \\le 3 \\cdot 10^5$).\n\nThe $i$-th of the following $n$ lines of the picture description contains two integers $w_i$ and $b_i$ --- two integers written beside the $i$-th vertex of the tree: the number of white and black edges incident to the $i$-th vertex ($0 \\le w_i, b_i \\le n - 1$).\n\nIt is guaranteed that the sum of $n$ over all the pictures does not exceed $3 \\cdot 10^5$.", "outputFormat": "Print $t$ blocks of output, the $i$-th of which should contain the information about recreating picture $i$.\n\nIn the first line of each block print $\\tt{No}$ if there is no way, and $\\tt{Yes}$ if there is at least one way to recreate the picture. If there is a way to recreate the picture of the tree, print additional $n - 1$ lines, each of them containing two integers and a letter $\\tt{W}$ for white or $\\tt{B}$ for black: $v_i$, $u_i$ and $c_i$, defining an edge between vertices $v_i$ and $u_i$ of color $c_i$ ($1 \\le v_i, u_i \\le n$; $c_i$ is either $\\tt{W}$ or $\\tt{B}$).\n\nIf there are multiple ways to recreate a picture, you can print any of them. The edges of the tree can be printed in any order.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NWRRC 2021] New White-Black Tree", "background": "", "description": "Naomi has learnt about Red-Black trees, now it's time to learn about White-Black trees.\nShe is reading an algorithms book. Some pages contain pictures of trees, but the edges of the trees faded out through all these years. According to the text, each of these edges should be either white or black.\n\nNaomi noticed that each vertex has two integers written beside it. She guessed that the first integer is the number of white edges incident to the vertex, and the second is the number of black edges incident to the vertex.\n\nNaomi recreated all the pictures. Can you do that?", "inputFormat": "The first line contains an integer $t$ --- the number of pictures to recreate ($1 \\le t \\le 3 \\cdot 10^5$).\n\nThe following lines describe $t$ pictures. Each description starts with a line containing an integer $n$ --- the number of vertices in the tree ($1 \\le n \\le 3 \\cdot 10^5$).\n\nThe $i$-th of the following $n$ lines of the picture description contains two integers $w_i$ and $b_i$ --- two integers written beside the $i$-th vertex of the tree: the number of white and black edges incident to the $i$-th vertex ($0 \\le w_i, b_i \\le n - 1$).\n\nIt is guaranteed that the sum of $n$ over all the pictures does not exceed $3 \\cdot 10^5$.", "outputFormat": "Print $t$ blocks of output, the $i$-th of which should contain the information about recreating picture $i$.\n\nIn the first line of each block print $\\tt{No}$ if there is no way, and $\\tt{Yes}$ if there is at least one way to recreate the picture. If there is a way to recreate the picture of the tree, print additional $n - 1$ lines, each of them containing two integers and a letter $\\tt{W}$ for white or $\\tt{B}$ for black: $v_i$, $u_i$ and $c_i$, defining an edge between vertices $v_i$ and $u_i$ of color $c_i$ ($1 \\le v_i, u_i \\le n$; $c_i$ is either $\\tt{W}$ or $\\tt{B}$).\n\nIf there are multiple ways to recreate a picture, you can print any of them. The edges of the tree can be printed in any order.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2021] New White-Black Tree", "background": null, "description": "Naomi 学习了红黑树，现在是学习白黑树的时候了。  \n她正在阅读一本算法书。有些页面上画有树的图，但这些树的边经过多年已经褪色了。根据正文，每条边应该是白色或黑色之一。\n\nNaomi 注意到每个顶点旁边都写着两个整数。她猜测第一个整数表示与该顶点相连的白色边的数量，第二个整数表示与该顶点相连的黑色边的数量。\n\nNaomi 重新绘制了所有的图。你能做到吗？", "inputFormat": "第一行包含一个整数 $t$，表示需要重建的图片数量（$1 \\le t \\le 3 \\cdot 10^5$）。\n\n接下来的若干行描述 $t$ 张图片。每张图片的描述以一行整数 $n$ 开始，表示树的顶点数（$1 \\le n \\le 3 \\cdot 10^5$）。\n\n接下来的 $n$ 行中，第 $i$ 行包含两个整数 $w_i$ 和 $b_i$，分别表示写在第 $i$ 个顶点旁的白色边和黑色边的数量（$0 \\le w_i, b_i \\le n - 1$）。\n\n保证所有图片的 $n$ 之和不超过 $3 \\cdot 10^5$。", "outputFormat": "输出 $t$ 个区块，第 $i$ 个区块描述第 $i$ 张图片的重建情况。\n\n每个区块的第一行输出 $\\tt{No}$，如果无法重建；如果至少有一种重建方式，则输出 $\\tt{Yes}$。如果可以重建该树，则再输出 $n-1$ 行，每行包含两个整数和一个字母 $\\tt{W}$ 或 $\\tt{B}$，分别表示一条连接顶点 $v_i$ 和 $u_i$ 的边及其颜色（$1 \\le v_i, u_i \\le n$；$c_i$ 为 $\\tt{W}$ 或 $\\tt{B}$）。\n\n如果有多种重建方式，可以输出任意一种。树的边可以按任意顺序输出。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13642", "type": "P", "difficulty": 4, "samples": [["5\n1 1 1 1", "No"], ["7\n1 1 2 2 3 3", "Yes\n1 4 5 6 7 2 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "交互题", "O2优化", "构造"], "title": "EERT", "background": "顺着走是不可能的！这辈子都不可能！", "description": "### 本题仅允许使用 C++ 语言提交。\n\n小 S 有一颗有 $N$ 个节点的树，现在他邀请小 T 参观这棵树的每一个节点。\n\n因为顺着走太无聊，所以小 S 想找到一个参观顺序，使得没有相邻两个参观的点在树上是相连的，并且每个节点恰好参观一次。\n\n你是小 S 雇佣的导游，所以这个问题就抛给了你。\n\n当然，如果没有解决办法，那就说明小 S 不想带小 T 参观，你也就不用管了。\n\n**形式化的讲**，给定一颗 $N$ 个节点的树，你需要找到一条这棵树的补图的哈密顿路径。\n\n### 实现细节\n\n在本题中，你不需要，也不能实现 main 函数和从标准输入输出流中输入输出。\n\n本题中所有数组下标均从 $0$ 开始。\n\n你需要实现下面一个函数：\n```cpp\nstd::vector<int> eert(int N,std::vector<int> f)\n```\n\n- 本题保证每个测试点仅会调用 $1$ 次该函数。\n- $N$ 是这个树的节点个数，保证 $1\\leq N\\leq 10^7$。\n- 树上点的编号从 $1$ 到 $N$。\n- $f$ 是一个长度为 $N-1$ 的数组，其中 $f_i$ 表示点 $i+2$ 和点 $f_i$ 之间有条边，保证 $1\\leq f_i \\leq i+1$。\n- 你需要返回一个大小为 $N$ 或者为 $0$ 的数组（`vector`）。具体的：如果有解，返回一个长度为 $N$ 的数组，表示你的答案；如果无解，返回一个空的数组。\n- 你返回的数组设为 $ans$，你需要保证 $ans$ 是一个 $1-N$ 的排列，下标从 $0$ 开始，且对于 $1\\leq i<N$，$ans_{i-1}$ 与 $ans_i$ 之间没有连边。 ", "inputFormat": "第一行一个整数 $N$，表示树的大小。\n\n第二行 $N-1$ 个整数，表示数组 $f$。", "outputFormat": "输出一行，表示交互结果，有以下几种情况：\n1. `No` 表示你的函数返回无解；\n2. `Wrong answer` 表示你的函数返回了错误的哈密顿路径（包括不合法的返回）；\n3. `Yes` 表示你的函数找到了正确的哈密顿路径。\n\n其中，$2,3$ 会同时输出你的函数返回的排列。", "hint": "**本地测试**\n\n你可以在代码末尾加入如下代码测试（提交时请删去或注释掉）。\n\n```cpp\n#include<bits/stdc++.h> \nusing namespace std;\nnamespace CHECKER{\n\tint N;\n\tvector<int> f;\n\tvector<int> ans;\n\tvector<int> vis;\n\tbool checker(){\n\t\tif(ans.size()!=N) return 0;\n\t\tfor(int i=0;i<N;i++) if(ans[i]<=0||N<ans[i]) return 0;\n\t\tvis.resize(N,0);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(vis[ans[i]-1]) return 0;\n\t\t\tvis[ans[i]-1]=1;\n\t\t}\n\t\tint u,v;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tu=ans[i-1];\n\t\t\tv=ans[i];\n\t\t\tif(u!=1&&f[u-2]==v||v!=1&&f[v-2]==u) return 0;\n\t\t}\n\t\treturn 1;\n\t}\n\tint main(){\n\t\tscanf(\"%d\",&N);\n\t\tf.resize(N-1);\n\t\tfor(int i=0;i<N-1;i++){\n\t\t\tscanf(\"%d\",&f[i]);\n\t\t}\n\t\tans=eert(N,f);\n\t\tif(ans.empty()){\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif(checker()) printf(\"YES\\n\");\n\t\telse printf(\"Wrong answer\\n\");\n\t\tfor(int i=0;i<ans.size();i++){\n\t\t\tprintf(\"%d \",ans[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\treturn 0;\n\t}\n}\nint main(){\n\treturn CHECKER::main();\n}\n```\n\n其中，输入输出格式为题面中的【输入格式】和【输出格式】。\n\n**本题有捆绑测试**。\n\n- 对于 Subtask #$0$（$10$pts）：$N\\leq10$\n- 对于 Subtask #$1$（$15$pts）：$N\\leq20$\n- 对于 Subtask #$2$（$5$pts）：保证 $f_i=1$。\n- 对于 Subtask #$3$（$10$pts）：保证 $f_i=i+1$。\n- 对于 Subtask #$4$（$20$pts）：保证 $N\\leq10^5$。\n- 对于 Subtask #$5$（$40$pts）：无特殊限制。\n\n对于 $100\\%$ 的数据：$1\\leq N\\leq10^7,1\\leq f_i\\leq i+1$。\n\n本题 SPJ 需要使用不超过 $200$MB 的内存和 $300$ms 的时间，这是无法避免的，请注意你的空间和时间，与交互库相加不能超过对应的限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "EERT", "background": "顺着走是不可能的！这辈子都不可能！", "description": "### 本题仅允许使用 C++ 语言提交。\n\n小 S 有一颗有 $N$ 个节点的树，现在他邀请小 T 参观这棵树的每一个节点。\n\n因为顺着走太无聊，所以小 S 想找到一个参观顺序，使得没有相邻两个参观的点在树上是相连的，并且每个节点恰好参观一次。\n\n你是小 S 雇佣的导游，所以这个问题就抛给了你。\n\n当然，如果没有解决办法，那就说明小 S 不想带小 T 参观，你也就不用管了。\n\n**形式化的讲**，给定一颗 $N$ 个节点的树，你需要找到一条这棵树的补图的哈密顿路径。\n\n### 实现细节\n\n在本题中，你不需要，也不能实现 main 函数和从标准输入输出流中输入输出。\n\n本题中所有数组下标均从 $0$ 开始。\n\n你需要实现下面一个函数：\n```cpp\nstd::vector<int> eert(int N,std::vector<int> f)\n```\n\n- 本题保证每个测试点仅会调用 $1$ 次该函数。\n- $N$ 是这个树的节点个数，保证 $1\\leq N\\leq 10^7$。\n- 树上点的编号从 $1$ 到 $N$。\n- $f$ 是一个长度为 $N-1$ 的数组，其中 $f_i$ 表示点 $i+2$ 和点 $f_i$ 之间有条边，保证 $1\\leq f_i \\leq i+1$。\n- 你需要返回一个大小为 $N$ 或者为 $0$ 的数组（`vector`）。具体的：如果有解，返回一个长度为 $N$ 的数组，表示你的答案；如果无解，返回一个空的数组。\n- 你返回的数组设为 $ans$，你需要保证 $ans$ 是一个 $1-N$ 的排列，下标从 $0$ 开始，且对于 $1\\leq i<N$，$ans_{i-1}$ 与 $ans_i$ 之间没有连边。 ", "inputFormat": "第一行一个整数 $N$，表示树的大小。\n\n第二行 $N-1$ 个整数，表示数组 $f$。", "outputFormat": "输出一行，表示交互结果，有以下几种情况：\n1. `No` 表示你的函数返回无解；\n2. `Wrong answer` 表示你的函数返回了错误的哈密顿路径（包括不合法的返回）；\n3. `Yes` 表示你的函数找到了正确的哈密顿路径。\n\n其中，$2,3$ 会同时输出你的函数返回的排列。", "hint": "**本地测试**\n\n你可以在代码末尾加入如下代码测试（提交时请删去或注释掉）。\n\n```cpp\n#include<bits/stdc++.h> \nusing namespace std;\nnamespace CHECKER{\n\tint N;\n\tvector<int> f;\n\tvector<int> ans;\n\tvector<int> vis;\n\tbool checker(){\n\t\tif(ans.size()!=N) return 0;\n\t\tfor(int i=0;i<N;i++) if(ans[i]<=0||N<ans[i]) return 0;\n\t\tvis.resize(N,0);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(vis[ans[i]-1]) return 0;\n\t\t\tvis[ans[i]-1]=1;\n\t\t}\n\t\tint u,v;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tu=ans[i-1];\n\t\t\tv=ans[i];\n\t\t\tif(u!=1&&f[u-2]==v||v!=1&&f[v-2]==u) return 0;\n\t\t}\n\t\treturn 1;\n\t}\n\tint main(){\n\t\tscanf(\"%d\",&N);\n\t\tf.resize(N-1);\n\t\tfor(int i=0;i<N-1;i++){\n\t\t\tscanf(\"%d\",&f[i]);\n\t\t}\n\t\tans=eert(N,f);\n\t\tif(ans.empty()){\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif(checker()) printf(\"YES\\n\");\n\t\telse printf(\"Wrong answer\\n\");\n\t\tfor(int i=0;i<ans.size();i++){\n\t\t\tprintf(\"%d \",ans[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\treturn 0;\n\t}\n}\nint main(){\n\treturn CHECKER::main();\n}\n```\n\n其中，输入输出格式为题面中的【输入格式】和【输出格式】。\n\n**本题有捆绑测试**。\n\n- 对于 Subtask #$0$（$10$pts）：$N\\leq10$\n- 对于 Subtask #$1$（$15$pts）：$N\\leq20$\n- 对于 Subtask #$2$（$5$pts）：保证 $f_i=1$。\n- 对于 Subtask #$3$（$10$pts）：保证 $f_i=i+1$。\n- 对于 Subtask #$4$（$20$pts）：保证 $N\\leq10^5$。\n- 对于 Subtask #$5$（$40$pts）：无特殊限制。\n\n对于 $100\\%$ 的数据：$1\\leq N\\leq10^7,1\\leq f_i\\leq i+1$。\n\n本题 SPJ 需要使用不超过 $200$MB 的内存和 $300$ms 的时间，这是无法避免的，请注意你的空间和时间，与交互库相加不能超过对应的限制。", "locale": "zh-CN"}}}
{"pid": "P13643", "type": "P", "difficulty": 5, "samples": [["3 1\n1 3 2", "Y 1 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["交互题", "Special Judge", "O2优化"], "title": "Guess", "background": "猜猜我是谁？", "description": "### 本题仅允许使用 C++ 语言提交。\n\n小 Q 有一个长度为 $n$ 的隐藏排列 $p$，你要把它猜出来。\n\n你可以问他两个位置上较大的那个值是多少，你也可以问他一个答案是否正确，他会诚实的回答你。\n\n### 实现细节\n\n你需要在代码开头加入如下代码：\n```cpp\n#include<vector>\nint _max(int x,int y);\nbool _ask(std::vector<int> a);\n```\n你要实现以下函数：\n```cpp\nstd::vector<int> Guess(int n)\n```\n\n- 保证在每个测试点交互库恰好调用 **$50$** 次该函数，且在一个测试点内 $n$ 的值相同。\n- $n$ 表示排列 $p$ 的长度。\n- 该函数应该返回一个数组 `Ans`，下标从 $0$ 开始，表示你猜测的排列 $p$。\n\n上述函数可以调用如下两个函数：\n```cpp\nint _max(int x,int y)\n```\n- $x,y$ 表示你询问的位置，你需要保证 $1\\leq x,y\\leq n,x\\not=y$。\n- 该函数会返回 $\\max(p_x,p_y)$。\n- 对每一次 `Guess` 函数的调用，该函数最多被调用 $10^5$ 次。\n\n```cpp\nbool _ask(std::vector<int> a)\n```\n- 数组 $a$ 表示你询问的排列，下标从 $0$ 开始，你需要保证 $a$ 是一个 $1-n$ 的排列。\n- 若你的排列 $a$ 与答案排列 $p$ 相同，该函数会返回 True，否则返回 False。\n- 对每一次 `Guess` 函数的调用，该函数最多被调用 $10$ 次。\n\n**本题的目的是使得 `_ask` 函数和 `_max` 函数的总调用次数尽量少。每一个测试点都有一个满分线 $MAX$，评测程序根据 $MAX$ 和你的总调用次数来评分。**\n\n**评测程序的行为是非自适应的。这意味着在每次调用 `Guess` 前，排列 $p$ 是固定的。**", "inputFormat": "第一行两个整数 $n,T$，表示排列长度和 `Guess` 函数被调用的次数，保证 $1\\leq n\\leq10^4$，在数据中，保证 $T=50$（在样例中不保证）。\n\n接下来 $T$ 行，每行有 $n$ 个整数，表示每次调用中隐藏的排列 $p$，保证每行的 $n$ 个整数组成一个 $1-n$ 排列。", "outputFormat": "共 $T$ 行，每行输出该次测试的结果。\n\n若你的所有调用合法，并且返回的排列正确，则输出 `Y` 与你的函数调用两个函数的次数。\n\n否则输出一个字符 `N`。", "hint": "**【样例解释】**\n\n对于样例 $1$，可能的调用顺序：\n| 选手程序 | 交互库 | 说明 |\n| :-----------: | :-----------: |:-----------: |\n|  | 获得排列，如 $[1,3,2]$ | |\n|  | 调用 `Guess(3)` | 开始测试 |\n| 调用`_max(1,2)` | 返回 $3$ | $\\max(p_1,p_2)=\\max(1,3)=3$ |\n| 调用`_ask([1,3,2])` | 返回 True | 猜测排列与真实排列相同 |\n| 运行结束并返回 $[1,3,2]$ | 向屏幕打印交互结果、`_max`和`_ask`的调用次数：`Y 1 1` | 交互结束，结果正确，次数小于满分标准 |\n\n**【数据范围】**\n\n对于所有数据保证：$p$ 为 $1-n$ 的排列，$1\\leq n\\leq 10^4$。\n\n本题共有 $50$ 组测试点，每个测试点的分值均为 $100$ 分，得分为所有测试点得分的平均数，数据范围如下：\n\n设 $c$ 为测试点编号，\n\n- 对于测试点 $1-5$：$n=c$\n- 对于测试点 $6-10$：$n=2c$\n- 对于测试点 $11-20$：$n=5c$\n- 对于测试点 $21-30$：$n=50c$\n- 对于测试点 $31-50$：$n=200c$\n\n**【评分方式】**\n\n注意：\n\n- 选手不应通过非法方式获取交互库里的信息，如试图读取排列 $p$ 的值，或直接与标准输入、输出流进行交互。此类行为将被视为作弊。\n\n在每次 `Guess` 函数的调用中，程序调用 `_max` 次数不得超过 $10^5$ 次，`_ask` 次数不得超过 $10$ 次，否则将会获得 $0$ 分。\n\n若你调用 `_max` 或 `_ask` 的参数不符合题目要求，或者 `Guess` 的返回值不符合题目要求，将会获得 $0$ 分并获得 `Wrong function using` 的返回。\n\n若你的返回值与正确排列 $p$ 不同，将会获得 $0$ 分并获得 `Wrong answer permutation` 的返回。\n\n我们设你调用 `_max` 和 `_ask` 的总次数在 $T$ 次 `Guess` 函数调用中的最大值为 $w$，满分标准（满分标准见附件）为 $MAX$，若你返回正确排列，评分方式如下：\n| $w$ | 分数系数 |\n| :----------: | :----------: |\n| $[0,MAX]$ | $1$ |\n| $(MAX,2n)$ | $1-0.8(\\log_{2n-MAX}w-MAX)$ |\n| $[2n,10^5+10]$ | $0.2$ |\n\n\n**【本地测试】**\n\n可以在代码最后加入以下示例交互库，按照输入格式测试。\n\n示例交互库并**不判断**你的函数调用合法性，所以请注意你是否合法调用。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nvector<int> Guess(int n);\nint __p[10005],__n,__T,__cnt1,__cnt2;\nint _max(int x,int y){\n\t++__cnt1;\n\treturn max(__p[x],__p[y]);\n}\nbool _ask(vector<int> a){\n\t++__cnt2;\n\tfor(int i=0;i<__n;i++) if(a[i]!=__p[i+1]) return 0;\n\treturn 1;\n}\nint main(){\n\tcin>>__n>>__T;\n\tfor(int i=1;i<=__T;i++){\n\t\tfor(int j=1;j<=__n;j++) scanf(\"%d\",&__p[j]);\n\t\t__cnt1=__cnt2=0;\n\t\tvector<int> ans=Guess(__n);\n\t\tprintf(\"%c %d %d\\n\",\"NY\"[_ask(ans)],__cnt1,__cnt2);\n\t}\n\treturn 0;\n}\n```\n\n**【附件】**\n\n在本题附件中，`.in` 文件中为对应测试点 $n$ 的值， **`.out` 文件为对应的满分标准**。\n\n例如：`data1.in` 中是 `1`，`data1.out` 中是 `0`。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Guess", "background": "猜猜我是谁？", "description": "### 本题仅允许使用 C++ 语言提交。\n\n小 Q 有一个长度为 $n$ 的隐藏排列 $p$，你要把它猜出来。\n\n你可以问他两个位置上较大的那个值是多少，你也可以问他一个答案是否正确，他会诚实的回答你。\n\n### 实现细节\n\n你需要在代码开头加入如下代码：\n```cpp\n#include<vector>\nint _max(int x,int y);\nbool _ask(std::vector<int> a);\n```\n你要实现以下函数：\n```cpp\nstd::vector<int> Guess(int n)\n```\n\n- 保证在每个测试点交互库恰好调用 **$50$** 次该函数，且在一个测试点内 $n$ 的值相同。\n- $n$ 表示排列 $p$ 的长度。\n- 该函数应该返回一个数组 `Ans`，下标从 $0$ 开始，表示你猜测的排列 $p$。\n\n上述函数可以调用如下两个函数：\n```cpp\nint _max(int x,int y)\n```\n- $x,y$ 表示你询问的位置，你需要保证 $1\\leq x,y\\leq n,x\\not=y$。\n- 该函数会返回 $\\max(p_x,p_y)$。\n- 对每一次 `Guess` 函数的调用，该函数最多被调用 $10^5$ 次。\n\n```cpp\nbool _ask(std::vector<int> a)\n```\n- 数组 $a$ 表示你询问的排列，下标从 $0$ 开始，你需要保证 $a$ 是一个 $1-n$ 的排列。\n- 若你的排列 $a$ 与答案排列 $p$ 相同，该函数会返回 True，否则返回 False。\n- 对每一次 `Guess` 函数的调用，该函数最多被调用 $10$ 次。\n\n**本题的目的是使得 `_ask` 函数和 `_max` 函数的总调用次数尽量少。每一个测试点都有一个满分线 $MAX$，评测程序根据 $MAX$ 和你的总调用次数来评分。**\n\n**评测程序的行为是非自适应的。这意味着在每次调用 `Guess` 前，排列 $p$ 是固定的。**", "inputFormat": "第一行两个整数 $n,T$，表示排列长度和 `Guess` 函数被调用的次数，保证 $1\\leq n\\leq10^4$，在数据中，保证 $T=50$（在样例中不保证）。\n\n接下来 $T$ 行，每行有 $n$ 个整数，表示每次调用中隐藏的排列 $p$，保证每行的 $n$ 个整数组成一个 $1-n$ 排列。", "outputFormat": "共 $T$ 行，每行输出该次测试的结果。\n\n若你的所有调用合法，并且返回的排列正确，则输出 `Y` 与你的函数调用两个函数的次数。\n\n否则输出一个字符 `N`。", "hint": "**【样例解释】**\n\n对于样例 $1$，可能的调用顺序：\n| 选手程序 | 交互库 | 说明 |\n| :-----------: | :-----------: |:-----------: |\n|  | 获得排列，如 $[1,3,2]$ | |\n|  | 调用 `Guess(3)` | 开始测试 |\n| 调用`_max(1,2)` | 返回 $3$ | $\\max(p_1,p_2)=\\max(1,3)=3$ |\n| 调用`_ask([1,3,2])` | 返回 True | 猜测排列与真实排列相同 |\n| 运行结束并返回 $[1,3,2]$ | 向屏幕打印交互结果、`_max`和`_ask`的调用次数：`Y 1 1` | 交互结束，结果正确，次数小于满分标准 |\n\n**【数据范围】**\n\n对于所有数据保证：$p$ 为 $1-n$ 的排列，$1\\leq n\\leq 10^4$。\n\n本题共有 $50$ 组测试点，每个测试点的分值均为 $100$ 分，得分为所有测试点得分的平均数，数据范围如下：\n\n设 $c$ 为测试点编号，\n\n- 对于测试点 $1-5$：$n=c$\n- 对于测试点 $6-10$：$n=2c$\n- 对于测试点 $11-20$：$n=5c$\n- 对于测试点 $21-30$：$n=50c$\n- 对于测试点 $31-50$：$n=200c$\n\n**【评分方式】**\n\n注意：\n\n- 选手不应通过非法方式获取交互库里的信息，如试图读取排列 $p$ 的值，或直接与标准输入、输出流进行交互。此类行为将被视为作弊。\n\n在每次 `Guess` 函数的调用中，程序调用 `_max` 次数不得超过 $10^5$ 次，`_ask` 次数不得超过 $10$ 次，否则将会获得 $0$ 分。\n\n若你调用 `_max` 或 `_ask` 的参数不符合题目要求，或者 `Guess` 的返回值不符合题目要求，将会获得 $0$ 分并获得 `Wrong function using` 的返回。\n\n若你的返回值与正确排列 $p$ 不同，将会获得 $0$ 分并获得 `Wrong answer permutation` 的返回。\n\n我们设你调用 `_max` 和 `_ask` 的总次数在 $T$ 次 `Guess` 函数调用中的最大值为 $w$，满分标准（满分标准见附件）为 $MAX$，若你返回正确排列，评分方式如下：\n| $w$ | 分数系数 |\n| :----------: | :----------: |\n| $[0,MAX]$ | $1$ |\n| $(MAX,2n)$ | $1-0.8(\\log_{2n-MAX}w-MAX)$ |\n| $[2n,10^5+10]$ | $0.2$ |\n\n\n**【本地测试】**\n\n可以在代码最后加入以下示例交互库，按照输入格式测试。\n\n示例交互库并**不判断**你的函数调用合法性，所以请注意你是否合法调用。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nvector<int> Guess(int n);\nint __p[10005],__n,__T,__cnt1,__cnt2;\nint _max(int x,int y){\n\t++__cnt1;\n\treturn max(__p[x],__p[y]);\n}\nbool _ask(vector<int> a){\n\t++__cnt2;\n\tfor(int i=0;i<__n;i++) if(a[i]!=__p[i+1]) return 0;\n\treturn 1;\n}\nint main(){\n\tcin>>__n>>__T;\n\tfor(int i=1;i<=__T;i++){\n\t\tfor(int j=1;j<=__n;j++) scanf(\"%d\",&__p[j]);\n\t\t__cnt1=__cnt2=0;\n\t\tvector<int> ans=Guess(__n);\n\t\tprintf(\"%c %d %d\\n\",\"NY\"[_ask(ans)],__cnt1,__cnt2);\n\t}\n\treturn 0;\n}\n```\n\n**【附件】**\n\n在本题附件中，`.in` 文件中为对应测试点 $n$ 的值， **`.out` 文件为对应的满分标准**。\n\n例如：`data1.in` 中是 `1`，`data1.out` 中是 `0`。", "locale": "zh-CN"}}}
{"pid": "P13644", "type": "P", "difficulty": 6, "samples": [["5 7 2\n1 2\n1 3\n2 4\n2 5\n1 3\n1 4\n1 5\n2 4\n2 5\n3 5\n4 5\n", "1\n2\n2\n2\n2\n2\n2\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 5000, 5000, 5000, 5000, 5000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["莫队", "O2优化", "树链剖分"], "title": "K-LCA", "background": "成本越低，赚的越多！", "description": "T 国由 $n$ 座城市组成，首都在 $1$ 号城市，有 $(n-1)$ 条道路连接着这些城，且所有城市都可以通过这些道路到达首都。\n\n有 $q$ 轮旅行活动，第 $i$ 次旅游会有一个参数 $(l_i,r_i)$，每次都有 $k$ 个人，他们每个人都会在编号在 $[l_i,r_i]$ 的城市中选择一个城市作为出发点。为了让每个人都有独处空间，任意两人不会选择同一个城市。\n\n然后他们开始进行旅行。由于靠近首都的城市更高级，所以旅行者会向首都方向移动。\n\n最终他们会在一个城市会聚，然后旅行结束。旅游公司没有足够经费让旅行者去更高级的城市，所以旅游公司会让他们会聚的城市离首都尽可能远。\n\n现在旅游公司问你，他们会聚的地方，离首都距离最远是多少？两个城市之间的距离定义为最短路径上城市的个数（包括路径端点的两个城市）。", "inputFormat": "第一行三个数 $n,q,k$。\n\n接下来 $(n-1)$ 行，每行两个正整数 $u,v$ 表示一条边。\n\n接下来 $q$ 行，每行两个正整数 $l,r$ 表示一次询问。", "outputFormat": "共 $q$ 行，第 $i$ 行表示第 $i$ 次询问的答案。", "hint": "**本题有捆绑测试**，每个子任务均为 $20$ 分。\n\n| 子任务编号 | $n$ | $q$ | 特殊性质 | 时间限制 | 子任务依赖 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| $0$ | $10^4$ | $10^4$ | 无 | 3s | 无 |\n| $1$ | $2\\times10^4$ | $5\\times10^4$ | 无 | 3s | $0$ |\n| $2$ | $5\\times10^4$ | $5\\times10^4$ | 无 | 5s | $1$ |\n| $3$ | $10^5$ | $10^5$ | **有** | 7s | 无 |\n| $4$ | $10^5$ | $10^5$ | 无 | 7s | $2,3$ |\n\n特殊性质：树的形态是以 $1$ 结点为链顶的一条链\n\n对于 $100\\%$ 的数据，$n\\le 10^5,q\\le10^5,1< k\\le n,r-l+1\\ge k$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "K-LCA", "background": "成本越低，赚的越多！", "description": "T 国由 $n$ 座城市组成，首都在 $1$ 号城市，有 $(n-1)$ 条道路连接着这些城，且所有城市都可以通过这些道路到达首都。\n\n有 $q$ 轮旅行活动，第 $i$ 次旅游会有一个参数 $(l_i,r_i)$，每次都有 $k$ 个人，他们每个人都会在编号在 $[l_i,r_i]$ 的城市中选择一个城市作为出发点。为了让每个人都有独处空间，任意两人不会选择同一个城市。\n\n然后他们开始进行旅行。由于靠近首都的城市更高级，所以旅行者会向首都方向移动。\n\n最终他们会在一个城市会聚，然后旅行结束。旅游公司没有足够经费让旅行者去更高级的城市，所以旅游公司会让他们会聚的城市离首都尽可能远。\n\n现在旅游公司问你，他们会聚的地方，离首都距离最远是多少？两个城市之间的距离定义为最短路径上城市的个数（包括路径端点的两个城市）。", "inputFormat": "第一行三个数 $n,q,k$。\n\n接下来 $(n-1)$ 行，每行两个正整数 $u,v$ 表示一条边。\n\n接下来 $q$ 行，每行两个正整数 $l,r$ 表示一次询问。", "outputFormat": "共 $q$ 行，第 $i$ 行表示第 $i$ 次询问的答案。", "hint": "**本题有捆绑测试**，每个子任务均为 $20$ 分。\n\n| 子任务编号 | $n$ | $q$ | 特殊性质 | 时间限制 | 子任务依赖 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| $0$ | $10^4$ | $10^4$ | 无 | 3s | 无 |\n| $1$ | $2\\times10^4$ | $5\\times10^4$ | 无 | 3s | $0$ |\n| $2$ | $5\\times10^4$ | $5\\times10^4$ | 无 | 5s | $1$ |\n| $3$ | $10^5$ | $10^5$ | **有** | 7s | 无 |\n| $4$ | $10^5$ | $10^5$ | 无 | 7s | $2,3$ |\n\n特殊性质：树的形态是以 $1$ 结点为链顶的一条链\n\n对于 $100\\%$ 的数据，$n\\le 10^5,q\\le10^5,1< k\\le n,r-l+1\\ge k$。", "locale": "zh-CN"}}}
{"pid": "P13645", "type": "P", "difficulty": 7, "samples": [["8\n2 2\n3 3\n4 4\n5 5\n6 6\n7 7\n114 514\n2333 23333\n", "14\n130\n566\n2310\n4778\n13934\n603971168\n547492264"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数论", "O2优化", "莫比乌斯反演", "整除分块", "筛法"], "title": "Totient with Divisors", "background": "到底是互质还是整除？", "description": "有 $T$ 组询问，每次给定 $n,m$，求：\n\n$$\n\\sum_{i=1}^n\\sum_{j=1}^m\\varphi(i)\\varphi(j)\\sigma(ij)\n$$\n\n由于答案会很大，你只需要输出答案对 $998244353$ 取模的结果。\n\n上式中：\n\n- $\\varphi$ 是欧拉函数，$\\varphi(n)$ 表示 $1\\sim n$ 中与 $n$ 互质的数的个数。\n- $\\sigma$ 是约数和函数，$\\sigma(n)$ 表示 $n$ 的所有约数之和。", "inputFormat": "第一行一个正整数 $T$，表示有 $T$ 组询问。\n\n接下来 $T$ 行，每行两个正整数 $n,m$，表示一次询问。", "outputFormat": "$T$ 行，每行一个非负整数表示答案。", "hint": "**本题有捆绑测试**\n\n- 对于 Subtask #$0$（$7$pts）：保证 $T\\leq500,n,m\\leq400$。\n- 对于 Subtask #$1$（$8$pts）：保证 $n,m\\leq450$。\n- 对于 Subtask #$2$（$12$pts）：保证 $T,n,m\\leq5000$。\n- 对于 Subtask #$3$（$15$pts）：保证 $n,m\\leq5000$。\n- 对于 Subtask #$4$（$20$pts）：保证 $T\\leq10$。\n- 对于 Subtask #$5$（$38$pts）：无特殊限制。\n\n对于 $100\\%$ 的数据：保证 $1\\leq T,n,m\\leq 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Totient with Divisors", "background": "到底是互质还是整除？", "description": "有 $T$ 组询问，每次给定 $n,m$，求：\n\n$$\n\\sum_{i=1}^n\\sum_{j=1}^m\\varphi(i)\\varphi(j)\\sigma(ij)\n$$\n\n由于答案会很大，你只需要输出答案对 $998244353$ 取模的结果。\n\n上式中：\n\n- $\\varphi$ 是欧拉函数，$\\varphi(n)$ 表示 $1\\sim n$ 中与 $n$ 互质的数的个数。\n- $\\sigma$ 是约数和函数，$\\sigma(n)$ 表示 $n$ 的所有约数之和。", "inputFormat": "第一行一个正整数 $T$，表示有 $T$ 组询问。\n\n接下来 $T$ 行，每行两个正整数 $n,m$，表示一次询问。", "outputFormat": "$T$ 行，每行一个非负整数表示答案。", "hint": "**本题有捆绑测试**\n\n- 对于 Subtask #$0$（$7$pts）：保证 $T\\leq500,n,m\\leq400$。\n- 对于 Subtask #$1$（$8$pts）：保证 $n,m\\leq450$。\n- 对于 Subtask #$2$（$12$pts）：保证 $T,n,m\\leq5000$。\n- 对于 Subtask #$3$（$15$pts）：保证 $n,m\\leq5000$。\n- 对于 Subtask #$4$（$20$pts）：保证 $T\\leq10$。\n- 对于 Subtask #$5$（$38$pts）：无特殊限制。\n\n对于 $100\\%$ 的数据：保证 $1\\leq T,n,m\\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P13646", "type": "P", "difficulty": 2, "samples": [["10 4\n3\n9\n4\n2", "3"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "2016", "排序", "NOISG（新加坡）"], "title": "[NOISG 2016] LunchBox", "background": "", "description": "You are the manager of a restaurant. You prepare $N$ lunch boxes and hope to distribute them to some schools. Suppose there are $m$ schools and assume the $i$th school asks for $k_i$ lunch boxes.\n\nYou aim to distribute the lunch boxes to as many schools as possible. Moreover, you have a rule. For the $i$th school, you give either zero or $k_i$ lunch boxes. Can you make a program that help you to find the maximum number of schools that can receive lunch boxes?\n", "inputFormat": "Your program must read from standard input. The first line contains 2 integers, $N$ and $m$. Then, it follows by $m$ lines. The $i$th line contains an integer $k_i$.\n", "outputFormat": "Your program must output one line with a single integer to the standard output, which is the maximum number of schools.", "hint": "### Sample Explanation\n\nIn this example, the answer is $3$ since $3 + 4 + 2 \\leq 10$ and $3 + 9 + 4 + 2 > 10$.\n\n### Subtasks\n\nThe maximum execution time on each instance is $0.5s$. Your program will be tested on sets of input instances that satisfies the following restrictions:\n\n| Subtask | Marks | Restrictions |\n|:-------:|:-----:|:------------:|\n| 1       | 20    | Each instance satisfies $m = 1$, $0 < N \\leq 60000$ and $0 < k_i \\leq 30000$ |\n| 2       | 30    | Each instance satisfies $0 < m \\leq 1000$, $0 < N \\leq 60000$ and $0 < k_i \\leq 1000$ |\n| 3       | 50    | Each instance satisfies $0 < N$, $m \\leq 60000$ and $0 < k_i \\leq 30000$ |\n", "locale": "en", "translations": {"en": {"title": "[NOISG 2016] LunchBox", "background": "", "description": "You are the manager of a restaurant. You prepare $N$ lunch boxes and hope to distribute them to some schools. Suppose there are $m$ schools and assume the $i$th school asks for $k_i$ lunch boxes.\n\nYou aim to distribute the lunch boxes to as many schools as possible. Moreover, you have a rule. For the $i$th school, you give either zero or $k_i$ lunch boxes. Can you make a program that help you to find the maximum number of schools that can receive lunch boxes?\n", "inputFormat": "Your program must read from standard input. The first line contains 2 integers, $N$ and $m$. Then, it follows by $m$ lines. The $i$th line contains an integer $k_i$.\n", "outputFormat": "Your program must output one line with a single integer to the standard output, which is the maximum number of schools.", "hint": "### Sample Explanation\n\nIn this example, the answer is $3$ since $3 + 4 + 2 \\leq 10$ and $3 + 9 + 4 + 2 > 10$.\n\n### Subtasks\n\nThe maximum execution time on each instance is $0.5s$. Your program will be tested on sets of input instances that satisfies the following restrictions:\n\n| Subtask | Marks | Restrictions |\n|:-------:|:-----:|:------------:|\n| 1       | 20    | Each instance satisfies $m = 1$, $0 < N \\leq 60000$ and $0 < k_i \\leq 30000$ |\n| 2       | 30    | Each instance satisfies $0 < m \\leq 1000$, $0 < N \\leq 60000$ and $0 < k_i \\leq 1000$ |\n| 3       | 50    | Each instance satisfies $0 < N$, $m \\leq 60000$ and $0 < k_i \\leq 30000$ |\n", "locale": "en"}, "zh-CN": {"title": "[NOISG 2016] LunchBox", "background": null, "description": "你是一家餐馆的经理。你准备了 $N$ 个饭盒，希望分发给一些学校。假设有 $m$ 所学校且第 $i$ 所学校需要 $k_i$ 个午餐盒。你的目标是将午餐盒分发到尽可能多的学校。同时，你有一个规则。对于第 $i$ 所学校，你要么不提供餐盒，要么必须提供 $k_i$ 个午餐盒。你能写一个程序来找到可以接收午餐盒的学校的最大数量吗？", "inputFormat": "程序必须从标准输入中读入。第一行两个正整数 $N$ 和 $m$，然后有 $m$ 行，除去第一行的第 $i$ 行有一个整数表示 $k_i$。", "outputFormat": "您的程序必须向标准输出输出一行包含仅一个整数，表示能满足要求的学校的最大数量。", "hint": "### 样例解释\n\n在这个样例中，答案是 $3$，因为 $3 + 4 + 2 \\leq 10$ 且 $3 + 9 + 4 + 2 > 10$。\n\n### 子任务\n\n每个测试数据的时限为 $0.5$ 秒。您的程序将在满足以下限制的输入数据上进行测试：\n\n| 子任务 | 分值 | 限制 |\n|:-------:|:-----:|:------------:|\n| 1       | 20    | 每组输入数据满足 $m = 1$, $0 < N \\leq 60000$ 且 $0 < k_i \\leq 30000$。 |\n| 2       | 30    | 每组输入数据满足 $0 < m \\leq 1000$, $0 < N \\leq 60000$ 且 $0 < k_i \\leq 1000$。 |\n| 3       | 50    | 每组输入数据满足 $0 < N,m \\leq 60000$ 且 $0 < k_i \\leq 30000$。 |", "locale": "zh-CN"}}}
{"pid": "P13647", "type": "P", "difficulty": 4, "samples": [["2 4 3\n1 0 0 0\n0 0 0 1", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2016", "笛卡尔树", "单调栈", "NOISG（新加坡）", "bitset"], "title": "[NOISG 2016] Fabric", "background": "", "description": "Kraw the Krow has a beautiful piece of fabric. The patterns are so intricate that every part of the fabric is different. However, after the Great Fire of 2017, the fabric now has a lot of unsightly holes. (The Great Fire was started, of course, by none other than Squeaky the Rat.)\n\nKraw wants to forget about the Great Fire, because he doesn’t like heat very much. He would like to cut out a rectangle of fabric and throw the rest away. The new piece of fabric must have an area of at least $K$ and cannot contain any holes.\n\nDue to the gauge-antisymmetric properties of Kraw’s fabric (or something – Kraw can’t remember what the salesman said), Kraw can only cut the fabric along regular gridlines. Kraw wonders how many ways there are to cut a rectangle with an area of at least $K$ out of the fabric such that it contains no holes.", "inputFormat": "Your program should read the input from standard input. The input consists of:\n\n- one line with three integers $N$ and $M$ ($1 \\leq N, M \\leq 2000$), the height and width of the fabric, and $K$ ($1 \\leq K \\leq MN$), the minimum area of the rectangle in terms of the number of grid segments it must contain;\n- $N$ lines each with $M$ integers $s_{0y}, s_{1y}, \\ldots, s_{(M-1)y}$. $s_{xy}$ is $1$ if there is a hole on the segment with coordinates $(x, y)$, and $0$ if there is no hole.", "outputFormat": "Output one line with a single integer: the number of ways to cut a rectangle with an area of at least $K$ out of the fabric such that it contains no holes.\n", "hint": "### Sample Explanation\n\n3 rectangles with an area of at least 3 can possibly be cut from the fabric. Taking the top left segment as $(0, 0)$, there are:\n- 2 rectangles of area 3 — $\\{(1, 0), (2, 0), (3, 0)\\}$, $\\{(0, 1), (1, 1), (2, 1)\\}$\n- 1 rectangle of area 4 — $\\{(1, 0), (2, 0), (1, 1), (2, 1)\\}$\n\n### Subtasks\n\nThe maximum execution time on each instance is 1.0s. Your program will be tested on sets of input instances as follows:\n\n| Subtask | Marks | Restrictions |\n| :-: | :-: | :-: |\n| 1 | 7 | Each instance satisfies $0 < N, M \\leq 2000$, $K = 1$ and $s_{xy} = 0$ for all $(x, y)$; |\n| 2 | 9 | Each instance satisfies $0 < N, M \\leq 2000$, $K = 1$ and $s_{xy} = 1$ for only one $(x, y)$; |\n| 3 | 12 | Each instance satisfies $0 < N, M \\leq 50$; |\n| 4 | 14 | Each instance satisfies $0 < N, M \\leq 500$; |\n| 5 | 23 | Each instance satisfies $0 < N, M \\leq 2000$ and $K = 1$; |\n| 6 | 35 | Each instance satisfies $0 < N, M \\leq 2000$. |\n", "locale": "en", "translations": {"en": {"title": "[NOISG 2016] Fabric", "background": "", "description": "Kraw the Krow has a beautiful piece of fabric. The patterns are so intricate that every part of the fabric is different. However, after the Great Fire of 2017, the fabric now has a lot of unsightly holes. (The Great Fire was started, of course, by none other than Squeaky the Rat.)\n\nKraw wants to forget about the Great Fire, because he doesn’t like heat very much. He would like to cut out a rectangle of fabric and throw the rest away. The new piece of fabric must have an area of at least $K$ and cannot contain any holes.\n\nDue to the gauge-antisymmetric properties of Kraw’s fabric (or something – Kraw can’t remember what the salesman said), Kraw can only cut the fabric along regular gridlines. Kraw wonders how many ways there are to cut a rectangle with an area of at least $K$ out of the fabric such that it contains no holes.", "inputFormat": "Your program should read the input from standard input. The input consists of:\n\n- one line with three integers $N$ and $M$ ($1 \\leq N, M \\leq 2000$), the height and width of the fabric, and $K$ ($1 \\leq K \\leq MN$), the minimum area of the rectangle in terms of the number of grid segments it must contain;\n- $N$ lines each with $M$ integers $s_{0y}, s_{1y}, \\ldots, s_{(M-1)y}$. $s_{xy}$ is $1$ if there is a hole on the segment with coordinates $(x, y)$, and $0$ if there is no hole.", "outputFormat": "Output one line with a single integer: the number of ways to cut a rectangle with an area of at least $K$ out of the fabric such that it contains no holes.\n", "hint": "### Sample Explanation\n\n3 rectangles with an area of at least 3 can possibly be cut from the fabric. Taking the top left segment as $(0, 0)$, there are:\n- 2 rectangles of area 3 — $\\{(1, 0), (2, 0), (3, 0)\\}$, $\\{(0, 1), (1, 1), (2, 1)\\}$\n- 1 rectangle of area 4 — $\\{(1, 0), (2, 0), (1, 1), (2, 1)\\}$\n\n### Subtasks\n\nThe maximum execution time on each instance is 1.0s. Your program will be tested on sets of input instances as follows:\n\n| Subtask | Marks | Restrictions |\n| :-: | :-: | :-: |\n| 1 | 7 | Each instance satisfies $0 < N, M \\leq 2000$, $K = 1$ and $s_{xy} = 0$ for all $(x, y)$; |\n| 2 | 9 | Each instance satisfies $0 < N, M \\leq 2000$, $K = 1$ and $s_{xy} = 1$ for only one $(x, y)$; |\n| 3 | 12 | Each instance satisfies $0 < N, M \\leq 50$; |\n| 4 | 14 | Each instance satisfies $0 < N, M \\leq 500$; |\n| 5 | 23 | Each instance satisfies $0 < N, M \\leq 2000$ and $K = 1$; |\n| 6 | 35 | Each instance satisfies $0 < N, M \\leq 2000$. |\n", "locale": "en"}, "zh-CN": {"title": "[NOISG 2016] Fabric", "background": null, "description": "Kraw the Krow 有一块漂亮的布料。布料上的花纹非常精致，以至于每一部分都不相同。然而，在 2017 年的大火之后，这块布料上出现了许多难看的洞。（当然，这场大火是由 Squeaky the Rat 引发的。）\n\nKraw 想要忘记那场大火，因为他并不喜欢高温。他希望能从布料上裁剪出一个矩形，把剩下的部分都扔掉。新的布料必须满足面积至少为 $K$，并且不能包含任何洞。\n\n由于 Kraw 的布料具有“规-反对称”特性（或者别的什么——Kraw 已经不记得推销员说了什么），Kraw 只能沿着规则的网格线裁剪布料。Kraw 想知道，有多少种方法可以裁剪出一个面积至少为 $K$、且不包含任何洞的矩形。", "inputFormat": "你的程序应从标准输入读取数据。输入包括：\n\n- 一行，包含三个整数 $N$ 和 $M$（$1 \\leq N, M \\leq 2000$），分别表示布料的高度和宽度，以及 $K$（$1 \\leq K \\leq MN$），即矩形的最小面积（以网格单元数计）；\n- 接下来 $N$ 行，每行包含 $M$ 个整数 $s_{0y}, s_{1y}, \\ldots, s_{(M-1)y}$。若坐标为 $(x, y)$ 的网格单元有洞，则 $s_{xy} = 1$，否则 $s_{xy} = 0$。", "outputFormat": "输出一行，包含一个整数：表示可以裁剪出多少种面积至少为 $K$、且不包含任何洞的矩形。", "hint": "### 样例解释\n\n可以从布料上裁剪出 3 个面积至少为 3 的矩形。以左上角为 $(0, 0)$，它们分别是：\n- 2 个面积为 3 的矩形——$\\{(1, 0), (2, 0), (3, 0)\\}$，$\\{(0, 1), (1, 1), (2, 1)\\}$\n- 1 个面积为 4 的矩形——$\\{(1, 0), (2, 0), (1, 1), (2, 1)\\}$\n\n### 子任务\n\n每组数据的最大运行时间为 1.0 秒。你的程序将在以下输入范围内进行测试：\n\n| 子任务 | 分值 | 限制条件 |\n| :-: | :-: | :-: |\n| 1 | 7 | 满足 $0 < N, M \\leq 2000$，$K = 1$ 且所有 $(x, y)$ 都有 $s_{xy} = 0$； |\n| 2 | 9 | 满足 $0 < N, M \\leq 2000$，$K = 1$ 且仅有一个 $(x, y)$ 满足 $s_{xy} = 1$； |\n| 3 | 12 | 满足 $0 < N, M \\leq 50$； |\n| 4 | 14 | 满足 $0 < N, M \\leq 500$； |\n| 5 | 23 | 满足 $0 < N, M \\leq 2000$ 且 $K = 1$； |\n| 6 | 35 | 满足 $0 < N, M \\leq 2000$。 |\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13648", "type": "P", "difficulty": 6, "samples": [["5\n0 3 2\n-1 5 1\n4 4 3\n-1 1 2\n2 2 1", "3"], ["3\n0 1 2000000\n-1 2 2000000\n1 2 2000000", "3"], ["2\n0 1 1\n0 5 1", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "2016", "二分图", "Dilworth 定理", "NOISG（新加坡）", "Floyd 算法"], "title": "[NOISG 2016] Rock Climbing", "background": "", "description": "On one fine day, Mr. Panda and Rar the Cat decide to go rock climbing. The rock climbing wall has $N$ rocks. The $i$-th rock is located at height $Y_i$ from the bottom of the wall and $X_i$ units right from the centre of the wall. If $X_i$ is negative then it is to the left of the centre. The positions of all rocks are different.\n\nTo test Mr. Panda's rock climbing skills, Rar the Cat decided to issue a challenge to him. The challenge is as follows:\n\n1. Out of the $N$ rocks, Rar the Cat will pick a set of $K$ rocks, this set is called $R$.\n2. In order to win the challenge, Mr. Panda first has to pick one pair of rocks $(A, B)$ from set $R$. Mr. Panda is free to choose any pair of rocks as long as $A \\neq B$ and both rocks are in set $R$.\n3. Mr. Panda will start from the first rock $(A)$ and try to make his way to the second rock $(B)$. He can pass through other rocks on the way from $A$ to $B$, regardless of whether the rock is in set $R$.\n4. However, each rock is associated with a slippery rate $S_i$. When a rock has a high slippery rate, it is more difficult to stretch to a far away rock without slipping off. Furthermore, Rar the Cat only allows him to climb upwards. More precisely, to move from the $i$th rock to the $j$th rock, we require $\\max(|X_i - X_j|, |Y_i - Y_j|) \\leq \\max(S_i, S_j)$ and $Y_i < Y_j$\n5. Mr. Panda will win the challenge if he manages to pick one pair of rocks $(A, B)$ such that he can get from rock $A$ to rock $B$. If he fails to do that, Mr. Panda would have lost the challenge.\n\nRefer to the sample input and output for more details.\n\nOf course, Mr. Panda knows that there are many pairs of rocks such that the challenge cannot be completed. He wants to find the minimum $K$ such that no matter what set of rocks Rar the Cat chooses, he can always complete the challenge. He needs your help to find this value.", "inputFormat": "Your program must read from standard input. The first line of input contains one integer $N$. The next $N$ lines contain 3 integers each. The $(i + 1)$-th line represents $X_i, Y_i, S_i$ for the $i$-th rock.", "outputFormat": "Your program must output one line with a single integer to the standard output, which is the minimum number of rocks so that Mr. Panda can always complete the challenge. If Mr. Panda can never complete the challenge, output $-1$.", "hint": "### Sample Explanation 1\n\nWhen $K = 2$, there exists some subset of rocks so that Mr. Panda cannot complete the challenge. For example, if Rar the Cat chooses the rocks on $(-1, 1)$ and $(2, 2)$ to form the set $R$, Mr. Panda cannot complete the challenge. Mr. Panda cannot move from the rock on $(2, 2)$ to the rock on $(-1, 1)$ since he can only climb upward. Mr. Panda cannot move directly from the rock on $(-1, 1)$ to the rock on $(2, 2)$ since $\\max(|-1 - 2|, |1 - 2|) = 3 > \\max(2, 1) = 2$.\n\nAnother choice is to move indirectly from $(-1, 1)$ to $(2, 2)$. Mr. Panda can climb from the rock on $(-1, 1)$ to the rock on $(0, 3)$ since $\\max(|-1 - 0|, |1 - 3|) = 2 \\leq \\max(2, 1) = 2$. However, he cannot move from the rock on $(0, 3)$ to the rock on $(2, 2)$ since he must climb upwards.\n\nMoreover, it can be verified that for every set of 3 rocks, there is always a way to pick a pair of rocks so that Mr. Panda can complete the challenge. For example, if Rar the Cat picks the rocks on $(-1, 5)$, $(4, 4)$, $(-1, 1)$ to form set $R$, Mr. Panda can complete the challenge by picking the rocks on $(-1, 5)$ and $(-1, 1)$. To complete the challenge, he climbs from the rock $(-1, 1)$ to the rock on $(0, 3)$ then to the rock on $(-1, 5)$. The intermediate rocks do not need to be from $R$.\n\n### Sample Explanation 2\n\nThis testcase is only valid for subtasks 1,2 and 5.\n\nIf Rar the Cat selects the 2 rocks on height 2 (i.e. the 2nd and the 3rd rocks), Mr. Panda cannot complete the challenge since he must always climb upwards. So Mr. Panda can only guarantee that he can complete the challenge if Rar the Cat chooses all the rocks.\n\n### Sample Explanation 3\n\nThis testcase is only valid for subtasks 2,3,4 and 5.\n\nEven if Rar the cat selects all the rocks Mr. Panda since there is no way to get from one rock to another. Thus, Mr. Panda can never complete the challenge.\n\n### Subtasks\n\nThe maximum execution time on each instance is 1.0s. Your program will be tested on sets of input instances as follows:\n\n| Subtask | Marks | $N$ | Others |\n| :-: | :-: | :-: | :-: |\n| 1 | 15 | $1 \\leq N \\leq 20$ | $S_i = 2 \\times 10^6$ for all $i$ |\n| 2 | 29 | $1 \\leq N \\leq 20$ | No other restriction |\n| 3 | 17 | $1 \\leq N \\leq 500$ | $X_i = 0$, $S_i = S_j$ for all $i, j$ |\n| 4 | 19 | $1 \\leq N \\leq 500$ | $S_i = 1$, $Y_i$ is not a multiple of 3 for all $i$ |\n| 5 | 20 | $1 \\leq N \\leq 500$ | No other restriction |\n\nFor all test cases, $-10^6 \\leq X_i \\leq 10^6$, $1 \\leq Y \\leq 10^6$, $1 \\leq S_i \\leq 2 \\times 10^6$", "locale": "en", "translations": {"en": {"title": "[NOISG 2016] Rock Climbing", "background": "", "description": "On one fine day, Mr. Panda and Rar the Cat decide to go rock climbing. The rock climbing wall has $N$ rocks. The $i$-th rock is located at height $Y_i$ from the bottom of the wall and $X_i$ units right from the centre of the wall. If $X_i$ is negative then it is to the left of the centre. The positions of all rocks are different.\n\nTo test Mr. Panda's rock climbing skills, Rar the Cat decided to issue a challenge to him. The challenge is as follows:\n\n1. Out of the $N$ rocks, Rar the Cat will pick a set of $K$ rocks, this set is called $R$.\n2. In order to win the challenge, Mr. Panda first has to pick one pair of rocks $(A, B)$ from set $R$. Mr. Panda is free to choose any pair of rocks as long as $A \\neq B$ and both rocks are in set $R$.\n3. Mr. Panda will start from the first rock $(A)$ and try to make his way to the second rock $(B)$. He can pass through other rocks on the way from $A$ to $B$, regardless of whether the rock is in set $R$.\n4. However, each rock is associated with a slippery rate $S_i$. When a rock has a high slippery rate, it is more difficult to stretch to a far away rock without slipping off. Furthermore, Rar the Cat only allows him to climb upwards. More precisely, to move from the $i$th rock to the $j$th rock, we require $\\max(|X_i - X_j|, |Y_i - Y_j|) \\leq \\max(S_i, S_j)$ and $Y_i < Y_j$\n5. Mr. Panda will win the challenge if he manages to pick one pair of rocks $(A, B)$ such that he can get from rock $A$ to rock $B$. If he fails to do that, Mr. Panda would have lost the challenge.\n\nRefer to the sample input and output for more details.\n\nOf course, Mr. Panda knows that there are many pairs of rocks such that the challenge cannot be completed. He wants to find the minimum $K$ such that no matter what set of rocks Rar the Cat chooses, he can always complete the challenge. He needs your help to find this value.", "inputFormat": "Your program must read from standard input. The first line of input contains one integer $N$. The next $N$ lines contain 3 integers each. The $(i + 1)$-th line represents $X_i, Y_i, S_i$ for the $i$-th rock.", "outputFormat": "Your program must output one line with a single integer to the standard output, which is the minimum number of rocks so that Mr. Panda can always complete the challenge. If Mr. Panda can never complete the challenge, output $-1$.", "hint": "### Sample Explanation 1\n\nWhen $K = 2$, there exists some subset of rocks so that Mr. Panda cannot complete the challenge. For example, if Rar the Cat chooses the rocks on $(-1, 1)$ and $(2, 2)$ to form the set $R$, Mr. Panda cannot complete the challenge. Mr. Panda cannot move from the rock on $(2, 2)$ to the rock on $(-1, 1)$ since he can only climb upward. Mr. Panda cannot move directly from the rock on $(-1, 1)$ to the rock on $(2, 2)$ since $\\max(|-1 - 2|, |1 - 2|) = 3 > \\max(2, 1) = 2$.\n\nAnother choice is to move indirectly from $(-1, 1)$ to $(2, 2)$. Mr. Panda can climb from the rock on $(-1, 1)$ to the rock on $(0, 3)$ since $\\max(|-1 - 0|, |1 - 3|) = 2 \\leq \\max(2, 1) = 2$. However, he cannot move from the rock on $(0, 3)$ to the rock on $(2, 2)$ since he must climb upwards.\n\nMoreover, it can be verified that for every set of 3 rocks, there is always a way to pick a pair of rocks so that Mr. Panda can complete the challenge. For example, if Rar the Cat picks the rocks on $(-1, 5)$, $(4, 4)$, $(-1, 1)$ to form set $R$, Mr. Panda can complete the challenge by picking the rocks on $(-1, 5)$ and $(-1, 1)$. To complete the challenge, he climbs from the rock $(-1, 1)$ to the rock on $(0, 3)$ then to the rock on $(-1, 5)$. The intermediate rocks do not need to be from $R$.\n\n### Sample Explanation 2\n\nThis testcase is only valid for subtasks 1,2 and 5.\n\nIf Rar the Cat selects the 2 rocks on height 2 (i.e. the 2nd and the 3rd rocks), Mr. Panda cannot complete the challenge since he must always climb upwards. So Mr. Panda can only guarantee that he can complete the challenge if Rar the Cat chooses all the rocks.\n\n### Sample Explanation 3\n\nThis testcase is only valid for subtasks 2,3,4 and 5.\n\nEven if Rar the cat selects all the rocks Mr. Panda since there is no way to get from one rock to another. Thus, Mr. Panda can never complete the challenge.\n\n### Subtasks\n\nThe maximum execution time on each instance is 1.0s. Your program will be tested on sets of input instances as follows:\n\n| Subtask | Marks | $N$ | Others |\n| :-: | :-: | :-: | :-: |\n| 1 | 15 | $1 \\leq N \\leq 20$ | $S_i = 2 \\times 10^6$ for all $i$ |\n| 2 | 29 | $1 \\leq N \\leq 20$ | No other restriction |\n| 3 | 17 | $1 \\leq N \\leq 500$ | $X_i = 0$, $S_i = S_j$ for all $i, j$ |\n| 4 | 19 | $1 \\leq N \\leq 500$ | $S_i = 1$, $Y_i$ is not a multiple of 3 for all $i$ |\n| 5 | 20 | $1 \\leq N \\leq 500$ | No other restriction |\n\nFor all test cases, $-10^6 \\leq X_i \\leq 10^6$, $1 \\leq Y \\leq 10^6$, $1 \\leq S_i \\leq 2 \\times 10^6$", "locale": "en"}, "zh-CN": {"title": "[NOISG 2016] Rock Climbing", "background": null, "description": "在某一天，Panda 先生和猫咪 Rar 决定去攀岩。攀岩墙上有 $N$ 块岩石。第 $i$ 块岩石位于距离墙底 $Y_i$ 的高度，距离墙中心右侧 $X_i$ 个单位的位置。如果 $X_i$ 为负，则表示在中心左侧。所有岩石的位置都不相同。\n\n为了考验 Panda 先生的攀岩技巧，猫咪 Rar 给他出了一个挑战。挑战内容如下：\n\n1. 在 $N$ 块岩石中，猫咪 Rar 会选出 $K$ 块岩石组成一个集合 $R$。\n2. 为了赢得挑战，Panda 先生需要从集合 $R$ 中任选一对岩石 $(A, B)$。Panda 先生可以自由选择任意一对岩石，只要 $A \\neq B$ 且两块岩石都在集合 $R$ 中。\n3. Panda 先生将从第一块岩石 $(A)$ 出发，尝试到达第二块岩石 $(B)$。在从 $A$ 到 $B$ 的过程中，他可以经过其他岩石，无论这些岩石是否在集合 $R$ 中。\n4. 但是，每块岩石都有一个滑溜系数 $S_i$。滑溜系数越高，越难从这块岩石伸展到远处的岩石而不滑落。此外，猫咪 Rar 只允许他向上攀爬。更准确地说，从第 $i$ 块岩石移动到第 $j$ 块岩石，需要满足 $\\max(|X_i - X_j|, |Y_i - Y_j|) \\leq \\max(S_i, S_j)$ 且 $Y_i < Y_j$。\n5. 如果 Panda 先生能够选出一对岩石 $(A, B)$，使得他能从岩石 $A$ 到达岩石 $B$，则他赢得挑战。如果无法做到，则挑战失败。\n\n请参考样例输入输出以获取更多细节。\n\n当然，Panda 先生知道有很多岩石对无法完成挑战。他想要找到最小的 $K$，使得无论猫咪 Rar 如何选择岩石集合，他都能完成挑战。请你帮他找出这个值。", "inputFormat": "你的程序需要从标准输入读取数据。第一行包含一个整数 $N$。接下来的 $N$ 行，每行包含三个整数，分别为 $X_i, Y_i, S_i$，表示第 $i$ 块岩石的信息。", "outputFormat": "你的程序需要输出一行，一个整数，表示使 Panda 先生总能完成挑战所需的最小岩石数。如果 Panda 先生永远无法完成挑战，输出 $-1$。", "hint": "### 样例解释 1\n\n当 $K = 2$ 时，存在某些岩石子集使 Panda 先生无法完成挑战。例如，如果猫咪 Rar 选择 $(-1, 1)$ 和 $(2, 2)$ 这两块岩石组成集合 $R$，Panda 先生无法完成挑战。Panda 先生无法从 $(2, 2)$ 移动到 $(-1, 1)$，因为只能向上攀爬。Panda 先生也无法直接从 $(-1, 1)$ 移动到 $(2, 2)$，因为 $\\max(|-1 - 2|, |1 - 2|) = 3 > \\max(2, 1) = 2$。\n\n另一种选择是尝试间接从 $(-1, 1)$ 到 $(2, 2)$。Panda 先生可以从 $(-1, 1)$ 攀爬到 $(0, 3)$，因为 $\\max(|-1 - 0|, |1 - 3|) = 2 \\leq \\max(2, 1) = 2$。但他无法从 $(0, 3)$ 移动到 $(2, 2)$，因为必须向上攀爬。\n\n此外，可以验证，对于任意 3 块岩石的集合，总能找到一对岩石使 Panda 先生完成挑战。例如，如果猫咪 Rar 选择 $(-1, 5)$、$(4, 4)$、$(-1, 1)$ 这三块岩石组成集合 $R$，Panda 先生可以选择 $(-1, 5)$ 和 $(-1, 1)$ 这对岩石。完成挑战的方法是从 $(-1, 1)$ 攀爬到 $(0, 3)$，再到 $(-1, 5)$。中间经过的岩石不需要在 $R$ 中。\n\n### 样例解释 2\n\n本测试点仅适用于子任务 1、2 和 5。\n\n如果猫咪 Rar 选择高度为 2 的两块岩石（即第 2 和第 3 块岩石），Panda 先生无法完成挑战，因为他只能向上攀爬。因此，只有当猫咪 Rar 选择所有岩石时，Panda 先生才能保证完成挑战。\n\n### 样例解释 3\n\n本测试点仅适用于子任务 2、3、4 和 5。\n\n即使猫咪 Rar 选择了所有岩石，Panda 先生也无法从一块岩石到达另一块岩石。因此，Panda 先生永远无法完成挑战。\n\n### 子任务\n\n每个测试点的最大运行时间为 1.0 秒。你的程序将在以下输入范围内进行测试：\n\n| 子任务 | 分值 | $N$ | 其他限制 |\n| :-: | :-: | :-: | :-: |\n| 1 | 15 | $1 \\leq N \\leq 20$ | 所有 $S_i = 2 \\times 10^6$ |\n| 2 | 29 | $1 \\leq N \\leq 20$ | 无其他限制 |\n| 3 | 17 | $1 \\leq N \\leq 500$ | 所有 $X_i = 0$，且所有 $S_i$ 相等 |\n| 4 | 19 | $1 \\leq N \\leq 500$ | 所有 $S_i = 1$，且所有 $Y_i$ 不是 3 的倍数 |\n| 5 | 20 | $1 \\leq N \\leq 500$ | 无其他限制 |\n\n对于所有测试点，$-10^6 \\leq X_i \\leq 10^6$，$1 \\leq Y \\leq 10^6$，$1 \\leq S_i \\leq 2 \\times 10^6$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13649", "type": "P", "difficulty": 5, "samples": [["5 5\n0 5 5 1\n3 4 4 3\n-2 3 3 2\n1 1 4 4\n-1 2 3 1", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2016", "线段树", "扫描线", "双指针 two-pointer", "单调栈", "NOISG（新加坡）"], "title": "[NOISG 2016] Panda Ski", "background": "", "description": "The Winter Olympics is coming and Mr. Panda has been training very hard to take part in the skiing event. This event takes place on the mountain Mt. Rar which is of height $H$. Everyone can ski down from the peak to the base using the centroid path. To increase the difficulties, $N$ gates, each associated with a score, are placed at various heights and either to the left or to the right of the centroid path. The objective is to ski down from the peak to the base and achieve score by passing through some subset of gates.\n\nThe $i$-th gate is located at height $Y_i$ and $X_i$ units to the right of the centroid path. If $X_i$ is negative then it is to the left of the centroid path. Passing through the $i$-th gate gives $S_i$ points and you can pass through the same gate multiple times but you only get points for the first time you pass through a gate. No gate is at the same point.\n\nMr. Panda wants to maximize his score. Moreover, Mr. Panda understands he is not a good skier and he will fail to visit some gates. To avoid embarrassing himself, Mr. Panda analyses the gates and gives each gate an easiness score $E_i$ (high score is easier) based on the angle of the slope, the amount of snow, etc.\n\nPrecisely, Mr. Panda calculated that he can move from the $i$-th gate to the $j$-th gate if $\\max(|X_j - X_i|, Y_i - Y_j) \\leq E_i$ and $Y_i \\geq Y_j$. Also, it is possible to get from the peak to any gate and from any gate to the base of the mountain.\n\nMr. Panda is overwhelmed by the number of possible paths moving down the mountain and he needs your help to find the path that will give him the maximum score.\n", "inputFormat": "Your program must read from standard input. The first line of input contains two positive integers $N$ and $H$. The next $N$ lines contain 4 integers each. The $(i+1)$-th line represents $X_i, Y_i, S_i, E_i$.", "outputFormat": "You program must output one line with a single integer to the standard output, which is the maximum score Mr. Panda can attain. ", "hint": "### Explanation\n\nThere are only 3 possible paths Mr. Panda can take.\n\n1. Top $\\rightarrow (0, 5) \\rightarrow$ Bottom, Score: 5\n2. Top $\\rightarrow (3, 4) \\rightarrow (1, 1) \\rightarrow$ Bottom, Score: $4 + 4 = 8$\n3. Top $\\rightarrow (-2, 3) \\rightarrow (-1, 2) \\rightarrow$ Bottom, Score: $3 + 3 = 6$\n\nSo the best score is 8.\n\n### Subtasks\n\nThe maximum execution time on each instance is 1.0s. Your program will be tested on sets of input instances as follows:\n\n| Subtask | Marks | $N$ | Others |\n| :-: | :-: | :-: | :-: |\n| 1 | 7 | $1 \\leq N \\leq 300$ | $E_i = 200000$ for all $i$ |\n| 2 | 8 | $1 \\leq N \\leq 300$ | $X_i = 0$ for all $i$, $E_i = E_j$ for all $i, j$ |\n| 3 | 11 | $1 \\leq N \\leq 300$ | $Y_i \\neq Y_j$ for all $i \\neq j$ |\n| 4 | 13 | $1 \\leq N \\leq 2000$ | $Y_i \\neq Y_j$ for all $i \\neq j$ |\n| 5 | 15 | $1 \\leq N \\leq 50000$ | $Y_i \\neq Y_j$ for all $i \\neq j$, $E_i = E_j$ for all $i, j$ |\n| 6 | 13 | $1 \\leq N \\leq 50000$ | $E_i = E_j$ for all $i, j$ |\n| 7 | 16 | $1 \\leq N \\leq 50000$ | $Y_i \\neq Y_j$ for all $i \\neq j$ |\n| 8 | 17 | $1 \\leq N \\leq 200000$ | $Y_i \\neq Y_j$ for all $i \\neq j$ |\n\nFor all test cases, $-50000 \\leq X_i \\leq 50000$, $1 \\leq Y_i \\leq H \\leq 200000$, $1 \\leq S_i \\leq 10^6$, $1 \\leq E_i \\leq 200000$", "locale": "en", "translations": {"en": {"title": "[NOISG 2016] Panda Ski", "background": "", "description": "The Winter Olympics is coming and Mr. Panda has been training very hard to take part in the skiing event. This event takes place on the mountain Mt. Rar which is of height $H$. Everyone can ski down from the peak to the base using the centroid path. To increase the difficulties, $N$ gates, each associated with a score, are placed at various heights and either to the left or to the right of the centroid path. The objective is to ski down from the peak to the base and achieve score by passing through some subset of gates.\n\nThe $i$-th gate is located at height $Y_i$ and $X_i$ units to the right of the centroid path. If $X_i$ is negative then it is to the left of the centroid path. Passing through the $i$-th gate gives $S_i$ points and you can pass through the same gate multiple times but you only get points for the first time you pass through a gate. No gate is at the same point.\n\nMr. Panda wants to maximize his score. Moreover, Mr. Panda understands he is not a good skier and he will fail to visit some gates. To avoid embarrassing himself, Mr. Panda analyses the gates and gives each gate an easiness score $E_i$ (high score is easier) based on the angle of the slope, the amount of snow, etc.\n\nPrecisely, Mr. Panda calculated that he can move from the $i$-th gate to the $j$-th gate if $\\max(|X_j - X_i|, Y_i - Y_j) \\leq E_i$ and $Y_i \\geq Y_j$. Also, it is possible to get from the peak to any gate and from any gate to the base of the mountain.\n\nMr. Panda is overwhelmed by the number of possible paths moving down the mountain and he needs your help to find the path that will give him the maximum score.\n", "inputFormat": "Your program must read from standard input. The first line of input contains two positive integers $N$ and $H$. The next $N$ lines contain 4 integers each. The $(i+1)$-th line represents $X_i, Y_i, S_i, E_i$.", "outputFormat": "You program must output one line with a single integer to the standard output, which is the maximum score Mr. Panda can attain. ", "hint": "### Explanation\n\nThere are only 3 possible paths Mr. Panda can take.\n\n1. Top $\\rightarrow (0, 5) \\rightarrow$ Bottom, Score: 5\n2. Top $\\rightarrow (3, 4) \\rightarrow (1, 1) \\rightarrow$ Bottom, Score: $4 + 4 = 8$\n3. Top $\\rightarrow (-2, 3) \\rightarrow (-1, 2) \\rightarrow$ Bottom, Score: $3 + 3 = 6$\n\nSo the best score is 8.\n\n### Subtasks\n\nThe maximum execution time on each instance is 1.0s. Your program will be tested on sets of input instances as follows:\n\n| Subtask | Marks | $N$ | Others |\n| :-: | :-: | :-: | :-: |\n| 1 | 7 | $1 \\leq N \\leq 300$ | $E_i = 200000$ for all $i$ |\n| 2 | 8 | $1 \\leq N \\leq 300$ | $X_i = 0$ for all $i$, $E_i = E_j$ for all $i, j$ |\n| 3 | 11 | $1 \\leq N \\leq 300$ | $Y_i \\neq Y_j$ for all $i \\neq j$ |\n| 4 | 13 | $1 \\leq N \\leq 2000$ | $Y_i \\neq Y_j$ for all $i \\neq j$ |\n| 5 | 15 | $1 \\leq N \\leq 50000$ | $Y_i \\neq Y_j$ for all $i \\neq j$, $E_i = E_j$ for all $i, j$ |\n| 6 | 13 | $1 \\leq N \\leq 50000$ | $E_i = E_j$ for all $i, j$ |\n| 7 | 16 | $1 \\leq N \\leq 50000$ | $Y_i \\neq Y_j$ for all $i \\neq j$ |\n| 8 | 17 | $1 \\leq N \\leq 200000$ | $Y_i \\neq Y_j$ for all $i \\neq j$ |\n\nFor all test cases, $-50000 \\leq X_i \\leq 50000$, $1 \\leq Y_i \\leq H \\leq 200000$, $1 \\leq S_i \\leq 10^6$, $1 \\leq E_i \\leq 200000$", "locale": "en"}, "zh-CN": {"title": "[NOISG 2016] Panda Ski", "background": null, "description": "冬奥会即将来临，Panda 先生一直在努力训练，准备参加滑雪项目。该项目在 Mt. Rar 山上举行，山高为 $H$。每个人都可以沿着中线滑道从山顶滑到山脚。为了增加难度，山上设置了 $N$ 个闸门，每个闸门都有一个得分，且位于不同高度，并分布在中线滑道的左侧或右侧。目标是从山顶滑到山脚，并通过经过某些闸门来获得分数。\n\n第 $i$ 个闸门位于高度 $Y_i$，距离中线滑道右侧 $X_i$ 个单位。如果 $X_i$ 为负，则表示在中线滑道左侧。通过第 $i$ 个闸门可以获得 $S_i$ 分数，每个闸门只能首次通过时获得分数，重复通过不再计分。没有两个闸门在同一个点上。\n\nPanda 先生希望最大化自己的得分。此外，Panda 先生知道自己滑雪技术一般，可能无法经过所有闸门。为了避免尴尬，他对每个闸门根据坡度、积雪量等因素给出了一个“易通过分数” $E_i$（分数越高越容易）。\n\n具体来说，Panda 先生计算出：如果 $\\max(|X_j - X_i|, Y_i - Y_j) \\leq E_i$ 且 $Y_i \\geq Y_j$，则可以从第 $i$ 个闸门滑到第 $j$ 个闸门。此外，可以从山顶到达任意一个闸门，也可以从任意一个闸门到达山脚。\n\nPanda 先生被可能的滑行路径数量吓到了，他需要你的帮助，找出能获得最高分的滑行路径。", "inputFormat": "你的程序需要从标准输入读取数据。第一行包含两个正整数 $N$ 和 $H$。接下来的 $N$ 行，每行包含 4 个整数，分别为 $X_i, Y_i, S_i, E_i$，表示第 $i$ 个闸门的信息。", "outputFormat": "你的程序需要输出一行，一个整数，表示 Panda 先生能够获得的最大分数。", "hint": "### 说明\n\n只有 3 条可能的滑行路径：\n\n1. 顶部 $\\rightarrow (0, 5) \\rightarrow$ 底部，得分：5\n2. 顶部 $\\rightarrow (3, 4) \\rightarrow (1, 1) \\rightarrow$ 底部，得分：$4 + 4 = 8$\n3. 顶部 $\\rightarrow (-2, 3) \\rightarrow (-1, 2) \\rightarrow$ 底部，得分：$3 + 3 = 6$\n\n所以最高得分为 8。\n\n### 子任务\n\n每个测试点的最大运行时间为 1.0 秒。你的程序将在以下输入范围下进行测试：\n\n| 子任务 | 分值 | $N$ | 其他限制 |\n| :-: | :-: | :-: | :-: |\n| 1 | 7 | $1 \\leq N \\leq 300$ | 所有 $E_i = 200000$ |\n| 2 | 8 | $1 \\leq N \\leq 300$ | 所有 $X_i = 0$，且 $E_i$ 相同 |\n| 3 | 11 | $1 \\leq N \\leq 300$ | $Y_i$ 互不相同 |\n| 4 | 13 | $1 \\leq N \\leq 2000$ | $Y_i$ 互不相同 |\n| 5 | 15 | $1 \\leq N \\leq 50000$ | $Y_i$ 互不相同，且 $E_i$ 相同 |\n| 6 | 13 | $1 \\leq N \\leq 50000$ | $E_i$ 相同 |\n| 7 | 16 | $1 \\leq N \\leq 50000$ | $Y_i$ 互不相同 |\n| 8 | 17 | $1 \\leq N \\leq 200000$ | $Y_i$ 互不相同 |\n\n对于所有测试点，$-50000 \\leq X_i \\leq 50000$，$1 \\leq Y_i \\leq H \\leq 200000$，$1 \\leq S_i \\leq 10^6$，$1 \\leq E_i \\leq 200000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13650", "type": "P", "difficulty": 5, "samples": [["8\n1 1\n1 4\n1 15\n1 25\n2 1\n2 4\n2 15\n2 25", "1\n-1\n12\n21\n1\n5\n18\n29"], ["10\n1 1\n2 4\n1 15\n2 15\n1 26\n1 131\n2 131\n2 1337\n1 100000\n2 100000", "1\n5\n12\n18\n22\n-1\n178\n1995\n56160\n190508"], ["2\n1 9\n1 999999999999", "8\n245967827040"], ["5\n1 987328938823\n1 75732858587173\n1 4444444444444444\n1 1313131313131313\n1 10000000000000000", "241928778399\n13999321852875\n-1\n-1\n1534593233484559"], ["5\n2 987328938823\n2 75732858587173\n2 4444444444444444\n2 1313131313131313\n2 10000000000000000", "5110985302888\n500859079673722\n30071998020860537\n8755153350232701\n76732116285952928"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2016", "二分", "数位 DP", "前缀和", "NOISG（新加坡）"], "title": "[NOISG 2016] UnluckyFloors", "background": "", "description": "When Rar the Cat went to Taiwan for IOI 2014, he was accomodated in a hotel. During his\nstay, he realised that certain floors are 'missing' from the hotel building. Namely, he observed that numbers containing $4$ and $13$ as substrings are omitted from the floor numberings. This is because $4$ and $13$ are considered unlucky numbers and are purposely left out in the numbering.\n\nFor simplicity, we will refer to this numbering scheme as the lucky numbering scheme, as it omits the unlucky numbers. The table below shows the first $20$ floors in a lucky numbering scheme as well as the conventional numbering scheme.\n\n:::align{center}\n\n| Conventional | Lucky |\n| :-: | :-: |\n| $1$ | $1$ |\n| $2$ | $2$ |\n| $3$ | $3$ |\n| $4$ | $5$ |\n| $5$ | $6$ |\n| $6$ | $7$ |\n| $7$ | $8$ |\n| $8$ | $9$ |\n| $9$ | $10$ |\n| $10$ | $11$ |\n| $11$ | $12$ |\n| $12$ | $15$ |\n| $13$ | $16$ |\n| $14$ | $17$ |\n| $15$ | $18$ |\n| $16$ | $19$ |\n| $17$ | $20$ |\n| $18$ | $21$ |\n| $19$ | $22$ |\n| $20$ | $23$ |\n\n:::\n\nHowever, Rar the Cat feels that such a numbering scheme is not legitimate and wants to be able to convert floors between the lucky and conventional numbering scheme. For example, floor $6$ in the lucky numbering scheme will be floor $5$ in the conventional numbering scheme and floor $15$ will actually be floor $12$. Hence, given a floor number in the lucky numbering scheme, Rar the Cat wants you to compute which floor it will be in the conventional numbering scheme and vice-versa.", "inputFormat": "Your program must read from standard input.\n\nThe input will start with a single integer, $N$, in a single line. $N$ denotes how many floor numbers Rar the Cat wants you to convert for him.\n\n$N$ lines will then follow with 2 integers each, the $i^{th}$ line will contain $T_i$ and $X_i$.\n\nIf $T_i$ is $1$, you are to convert $X_i$ from the lucky numbering scheme to the conventional numbering scheme and print the result in a single line. However, if $X_i$ is not a valid number in the lucky numbering scheme, print $-1$ as the answer instead.\n\nIf $T_i$ is $2$, you are to convert $X_i$ from the conventional numbering scheme to the lucky numbering scheme and print the result on a single line.\n", "outputFormat": "Your program must output to standard output only.\n\nOutput a total of $N$ lines with 1 integer each. For each $i$, output the answer to $T_i$ and $X_i$.\n\nIt is guaranteed that the answer will fit in a 64-bit signed integer. Refer to Sample Testcase 4 and 5 for more information.\n", "hint": "### Sample Explanation\n\nSample Testcase 1 is only valid for subtasks 1, 2, 3, 5 and 6.\n\nSample Testcase 2 is only valid for subtasks 2, 3 and 6 only.\n\nSample Testcase 3 is only valid for subtasks 4, 5 and 6 only.\n\nSample Testcase 4 is only valid for subtasks 5 and 6 only.\n\nSample Testcase 5 is only valid for subtask 6 only.\n\n\n### Subtasks\n\nThe maximum execution time on each instance is $2.5s$. Your program will be tested on sets of input instances that satisfies the following restrictions:\n\n| Subtask | Marks | $N$ | $T_i$ | $X_i$ |\n| :-: | :-: | :-: | :-: | :-: |\n| 1 | 5 | $0 < N \\leq 50$ | $T_i = 1$ or $2$ | $0 < X_i \\leq 25$ |\n| 2 | 12 | $0 < N \\leq 50$ | $T_i = 1$ or $2$ | $0 < X_i \\leq 100000$ |\n| 3 | 18 | $0 < N \\leq 100000$ | $T_i = 1$ or $2$ | $0 < X_i \\leq 100000$ |\n| 4 | 11 | $0 < N \\leq 100000$ | $T_i = 1$ | $X_i = 10^K - 1$ where $1 \\leq K \\leq 16$ |\n| 5 | 37 | $0 < N \\leq 100000$ | $T_i = 1$ | $0 < X_i \\leq 10^{16}$ |\n| 6 | 17 | $0 < N \\leq 100000$ | $T_i = 1$ or $2$ | $0 < X_i \\leq 10^{16}$ |", "locale": "en", "translations": {"en": {"title": "[NOISG 2016] UnluckyFloors", "background": "", "description": "When Rar the Cat went to Taiwan for IOI 2014, he was accomodated in a hotel. During his\nstay, he realised that certain floors are 'missing' from the hotel building. Namely, he observed that numbers containing $4$ and $13$ as substrings are omitted from the floor numberings. This is because $4$ and $13$ are considered unlucky numbers and are purposely left out in the numbering.\n\nFor simplicity, we will refer to this numbering scheme as the lucky numbering scheme, as it omits the unlucky numbers. The table below shows the first $20$ floors in a lucky numbering scheme as well as the conventional numbering scheme.\n\n:::align{center}\n\n| Conventional | Lucky |\n| :-: | :-: |\n| $1$ | $1$ |\n| $2$ | $2$ |\n| $3$ | $3$ |\n| $4$ | $5$ |\n| $5$ | $6$ |\n| $6$ | $7$ |\n| $7$ | $8$ |\n| $8$ | $9$ |\n| $9$ | $10$ |\n| $10$ | $11$ |\n| $11$ | $12$ |\n| $12$ | $15$ |\n| $13$ | $16$ |\n| $14$ | $17$ |\n| $15$ | $18$ |\n| $16$ | $19$ |\n| $17$ | $20$ |\n| $18$ | $21$ |\n| $19$ | $22$ |\n| $20$ | $23$ |\n\n:::\n\nHowever, Rar the Cat feels that such a numbering scheme is not legitimate and wants to be able to convert floors between the lucky and conventional numbering scheme. For example, floor $6$ in the lucky numbering scheme will be floor $5$ in the conventional numbering scheme and floor $15$ will actually be floor $12$. Hence, given a floor number in the lucky numbering scheme, Rar the Cat wants you to compute which floor it will be in the conventional numbering scheme and vice-versa.", "inputFormat": "Your program must read from standard input.\n\nThe input will start with a single integer, $N$, in a single line. $N$ denotes how many floor numbers Rar the Cat wants you to convert for him.\n\n$N$ lines will then follow with 2 integers each, the $i^{th}$ line will contain $T_i$ and $X_i$.\n\nIf $T_i$ is $1$, you are to convert $X_i$ from the lucky numbering scheme to the conventional numbering scheme and print the result in a single line. However, if $X_i$ is not a valid number in the lucky numbering scheme, print $-1$ as the answer instead.\n\nIf $T_i$ is $2$, you are to convert $X_i$ from the conventional numbering scheme to the lucky numbering scheme and print the result on a single line.\n", "outputFormat": "Your program must output to standard output only.\n\nOutput a total of $N$ lines with 1 integer each. For each $i$, output the answer to $T_i$ and $X_i$.\n\nIt is guaranteed that the answer will fit in a 64-bit signed integer. Refer to Sample Testcase 4 and 5 for more information.\n", "hint": "### Sample Explanation\n\nSample Testcase 1 is only valid for subtasks 1, 2, 3, 5 and 6.\n\nSample Testcase 2 is only valid for subtasks 2, 3 and 6 only.\n\nSample Testcase 3 is only valid for subtasks 4, 5 and 6 only.\n\nSample Testcase 4 is only valid for subtasks 5 and 6 only.\n\nSample Testcase 5 is only valid for subtask 6 only.\n\n\n### Subtasks\n\nThe maximum execution time on each instance is $2.5s$. Your program will be tested on sets of input instances that satisfies the following restrictions:\n\n| Subtask | Marks | $N$ | $T_i$ | $X_i$ |\n| :-: | :-: | :-: | :-: | :-: |\n| 1 | 5 | $0 < N \\leq 50$ | $T_i = 1$ or $2$ | $0 < X_i \\leq 25$ |\n| 2 | 12 | $0 < N \\leq 50$ | $T_i = 1$ or $2$ | $0 < X_i \\leq 100000$ |\n| 3 | 18 | $0 < N \\leq 100000$ | $T_i = 1$ or $2$ | $0 < X_i \\leq 100000$ |\n| 4 | 11 | $0 < N \\leq 100000$ | $T_i = 1$ | $X_i = 10^K - 1$ where $1 \\leq K \\leq 16$ |\n| 5 | 37 | $0 < N \\leq 100000$ | $T_i = 1$ | $0 < X_i \\leq 10^{16}$ |\n| 6 | 17 | $0 < N \\leq 100000$ | $T_i = 1$ or $2$ | $0 < X_i \\leq 10^{16}$ |", "locale": "en"}, "zh-CN": {"title": "[NOISG 2016] UnluckyFloors", "background": null, "description": "当 Rar the Cat 前往台湾参加 IOI 2014 时，他住在一家酒店。在入住期间，他发现酒店大楼中有些楼层“消失”了。具体来说，他注意到包含 $4$ 和 $13$ 作为子串的数字在楼层编号中被省略了。这是因为 $4$ 和 $13$ 被认为是不吉利的数字，因此在编号时被有意跳过。\n\n为简便起见，我们将这种编号方式称为“幸运编号方案”，因为它省略了不吉利的数字。下表展示了前 $20$ 层在幸运编号方案和常规编号方案下的对应关系。\n\n:::align{center}\n\n| 常规编号 | 幸运编号 |\n| :-: | :-: |\n| $1$ | $1$ |\n| $2$ | $2$ |\n| $3$ | $3$ |\n| $4$ | $5$ |\n| $5$ | $6$ |\n| $6$ | $7$ |\n| $7$ | $8$ |\n| $8$ | $9$ |\n| $9$ | $10$ |\n| $10$ | $11$ |\n| $11$ | $12$ |\n| $12$ | $15$ |\n| $13$ | $16$ |\n| $14$ | $17$ |\n| $15$ | $18$ |\n| $16$ | $19$ |\n| $17$ | $20$ |\n| $18$ | $21$ |\n| $19$ | $22$ |\n| $20$ | $23$ |\n\n:::\n\n然而，Rar the Cat 认为这种编号方式不够正规，他希望能够在幸运编号方案和常规编号方案之间进行楼层转换。例如，幸运编号方案下的第 $6$ 层对应常规编号方案下的第 $5$ 层，而幸运编号方案下的第 $15$ 层实际上是常规编号方案下的第 $12$ 层。因此，给定幸运编号方案下的某一楼层编号，Rar the Cat 希望你计算出它在常规编号方案下对应的楼层编号，反之亦然。", "inputFormat": "你的程序需要从标准输入读取数据。\n\n输入的第一行为一个整数 $N$，表示 Rar the Cat 需要你帮他转换的楼层编号的数量。\n\n接下来的 $N$ 行，每行包含两个整数，分别为 $T_i$ 和 $X_i$。\n\n如果 $T_i$ 为 $1$，你需要将 $X_i$ 从幸运编号方案转换为常规编号方案，并将结果输出在一行中。如果 $X_i$ 不是幸运编号方案下的有效楼层编号，则输出 $-1$。\n\n如果 $T_i$ 为 $2$，你需要将 $X_i$ 从常规编号方案转换为幸运编号方案，并将结果输出在一行中。\n\n保证答案不会超过 $64$ 位有符号整数。更多信息请参考样例测试 4 和 5。", "outputFormat": "你的程序只需输出到标准输出。\n\n共输出 $N$ 行，每行一个整数。对于每个 $i$，输出 $T_i$ 和 $X_i$ 的答案。\n\n保证答案不会超过 $64$ 位有符号整数。", "hint": "### 样例解释\n\n样例测试 1 仅适用于子任务 1、2、3、5 和 6。\n\n样例测试 2 仅适用于子任务 2、3 和 6。\n\n样例测试 3 仅适用于子任务 4、5 和 6。\n\n样例测试 4 仅适用于子任务 5 和 6。\n\n样例测试 5 仅适用于子任务 6。\n\n### 子任务\n\n每个测试点的最大运行时间为 $2.5$ 秒。你的程序将在满足以下限制的输入实例集上进行测试：\n\n| 子任务 | 分值 | $N$ | $T_i$ | $X_i$ |\n| :-: | :-: | :-: | :-: | :-: |\n| 1 | 5 | $0 < N \\leq 50$ | $T_i = 1$ 或 $2$ | $0 < X_i \\leq 25$ |\n| 2 | 12 | $0 < N \\leq 50$ | $T_i = 1$ 或 $2$ | $0 < X_i \\leq 100000$ |\n| 3 | 18 | $0 < N \\leq 100000$ | $T_i = 1$ 或 $2$ | $0 < X_i \\leq 100000$ |\n| 4 | 11 | $0 < N \\leq 100000$ | $T_i = 1$ | $X_i = 10^K - 1$，其中 $1 \\leq K \\leq 16$ |\n| 5 | 37 | $0 < N \\leq 100000$ | $T_i = 1$ | $0 < X_i \\leq 10^{16}$ |\n| 6 | 17 | $0 < N \\leq 100000$ | $T_i = 1$ 或 $2$ | $0 < X_i \\leq 10^{16}$ |\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13651", "type": "P", "difficulty": 5, "samples": [["9\n *^!/\\vDG\n *^!/\\vDG\n *^!/\\vDG\n *^!/\\vDG\n *^!/\\vDG\n *^!/\\vDG\n *^!/\\vDG\n *^!/\\vDG\n *^!/\\vDG", "12672"], ["3\n!  \n  v\n D ", "2059"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["模拟", "2020", "ICPC", "CERC"], "title": "[CERC 2020] Art Transaction", "background": null, "description": "The largest picture stolen by the gangsters from the State Gallery is to be evaluated by an expert before it is sold on the black market. The composition of the picture clearly follows mainstream tendencies in contemporary AI art. The picture can be viewed as a grid of square cells where each cell is either empty or non-empty. A non-empty cell contains exactly one of these objects: a sun, a house, a chupacabra, a left slope, a right slope, a bird, a drake, or a grill. Two cells are adjacent if they share an edge in the grid. A connection between two cells is a sequence of cells which contains both given cells and in which each two consecutive cells are adjacent in the picture. An area is a set of cells. It is connected if there is a connection between any two cells in the area.\n\nThe value of the picture is the total of all values generated by all rules listed below.\n\n- Suns:\\\nA non-empty cell, not containing a sun, is illuminated by a sun if there is no other object on a straight line between the cell and another cell with a sun. The straight line may be horizontal, vertical or diagonal (both diagonal directions apply). When a cell is illuminated by multiple suns it is still counted only once. A sun cannot illuminate itself. Each illuminated cell generates $100$ .\n\n- Biggest bird:\\\nA drake is a bird. A flock of birds is maximal connected area of cells each of which contains a bird. The width of a flock is the length of a maximum contiguous sequence of cells on one line in a flock. A flock of birds generates $500 \\cdot (\\text{width of the flock})$.\n\n- Flock perimeter:\\\nEach flock of birds (see previous rule) generates value $60 \\cdot (\\text{flock perimeter})$. Flock perimeter is the total number of edges each of which separates a flock cell from a cell which does not contain a bird or from the outside of the picture.\n\n- House view up:\\\nWhen an empty cell is located above a cell containing a house, it is in the same column, and there is no non-empty field between the empty cell and the house, the empty cell generates $10$.\n\n- $3 \\times 3$ blocks:\\\nEach unique $3 \\times 3$ block (possibly overlapping) generates $1$.\n\n- Animals I:\\\nEach edge between a cell with an animal and an empty cell generates $15$.\n\n- Freedom:\\\nCell X is a freedom cell if it is either adjacent to the picture border or there is a connection between a cell adjacent to the picture border and a cell adjacent to X and the connection contains only empty cells. Each non-empty freedom cell generates $7$.\n\n- Chupacabra:\\\nA drake is a bird. Each bird which can be reached by a chupacabra performing one chess knight move in the grid generates $200$\n\n- Peaks:\\\nA pair of adjacent cells with characters `/` (left slope) and `\\` (right slope, in this order) on one line is a peak. Peak summit is an imaginary point in the middle of the segment connecting the uppermost points of both symbols in the peak. Peak value is equal to the maximum Manhattan distance from the peak summit to the summit of another peak in the grid. Note that peak value is an integer. Each peak P generates $50 \\cdot (P \\text{ value})$ when there are at least two peaks in the picture. Otherwise, a single peak in the picture generates $0$.\n\n- Drake/grill:\\\nEach cell with a drake and with at least one adjacent cell with a grill generates $500$ .\n\n- Minimum frequency:\\\nFrequency of an object X is the number of the objects (including X) of the same type as X in the entire picture. Each single object which frequency is minimum among all objects in the picture generates $10$.\n\n- Empty fields:\\\nEach empty field generates $1$.\n\n- Animals II:\\\nAll animals in the picture together generate single value $1 \\cdot (\\text{number of chupacabras}) \\cdot (\\text{number of birds which are not drakes}) \\cdot (\\text{number of drakes})$.\n\n- House view down:\\\nWhen an empty field is located above a house, is in the same column, and there is no non-empty field between the empty field and the house, the empty field generates $5$.\n\n- Grill/drake:\\\nEach cell with a grill and with at least one adjacent cell with a drake generates $50$.\n\n- Houses and grills:\\\nHouses and grills in the picture generate $3 \\cdot \\min \\{ \\text{number of all houses}, \\text{number of all grills} \\}$.", "inputFormat": "The first input line contains one integer $N$ ($1 \\leq N \\leq 50$), the number of the rows and the columns in the picture. Next, there are $N$ lines, each specifies one line in the picture. One character on the line represents one cell and its contents.\n\nThe interpretation of particular characters in the picture representation follows:\nempty cell ` ` (space), sun `*`, house `^`, chupacabra `!`, left slope `/`, right slope `\\`, bird `v`, drake `D`, grill `G`.", "outputFormat": "Print one integer, the value of the input picture.", "hint": null, "locale": "en", "translations": {"en": {"title": "[CERC 2020] Art Transaction", "background": null, "description": "The largest picture stolen by the gangsters from the State Gallery is to be evaluated by an expert before it is sold on the black market. The composition of the picture clearly follows mainstream tendencies in contemporary AI art. The picture can be viewed as a grid of square cells where each cell is either empty or non-empty. A non-empty cell contains exactly one of these objects: a sun, a house, a chupacabra, a left slope, a right slope, a bird, a drake, or a grill. Two cells are adjacent if they share an edge in the grid. A connection between two cells is a sequence of cells which contains both given cells and in which each two consecutive cells are adjacent in the picture. An area is a set of cells. It is connected if there is a connection between any two cells in the area.\n\nThe value of the picture is the total of all values generated by all rules listed below.\n\n- Suns:\\\nA non-empty cell, not containing a sun, is illuminated by a sun if there is no other object on a straight line between the cell and another cell with a sun. The straight line may be horizontal, vertical or diagonal (both diagonal directions apply). When a cell is illuminated by multiple suns it is still counted only once. A sun cannot illuminate itself. Each illuminated cell generates $100$ .\n\n- Biggest bird:\\\nA drake is a bird. A flock of birds is maximal connected area of cells each of which contains a bird. The width of a flock is the length of a maximum contiguous sequence of cells on one line in a flock. A flock of birds generates $500 \\cdot (\\text{width of the flock})$.\n\n- Flock perimeter:\\\nEach flock of birds (see previous rule) generates value $60 \\cdot (\\text{flock perimeter})$. Flock perimeter is the total number of edges each of which separates a flock cell from a cell which does not contain a bird or from the outside of the picture.\n\n- House view up:\\\nWhen an empty cell is located above a cell containing a house, it is in the same column, and there is no non-empty field between the empty cell and the house, the empty cell generates $10$.\n\n- $3 \\times 3$ blocks:\\\nEach unique $3 \\times 3$ block (possibly overlapping) generates $1$.\n\n- Animals I:\\\nEach edge between a cell with an animal and an empty cell generates $15$.\n\n- Freedom:\\\nCell X is a freedom cell if it is either adjacent to the picture border or there is a connection between a cell adjacent to the picture border and a cell adjacent to X and the connection contains only empty cells. Each non-empty freedom cell generates $7$.\n\n- Chupacabra:\\\nA drake is a bird. Each bird which can be reached by a chupacabra performing one chess knight move in the grid generates $200$\n\n- Peaks:\\\nA pair of adjacent cells with characters `/` (left slope) and `\\` (right slope, in this order) on one line is a peak. Peak summit is an imaginary point in the middle of the segment connecting the uppermost points of both symbols in the peak. Peak value is equal to the maximum Manhattan distance from the peak summit to the summit of another peak in the grid. Note that peak value is an integer. Each peak P generates $50 \\cdot (P \\text{ value})$ when there are at least two peaks in the picture. Otherwise, a single peak in the picture generates $0$.\n\n- Drake/grill:\\\nEach cell with a drake and with at least one adjacent cell with a grill generates $500$ .\n\n- Minimum frequency:\\\nFrequency of an object X is the number of the objects (including X) of the same type as X in the entire picture. Each single object which frequency is minimum among all objects in the picture generates $10$.\n\n- Empty fields:\\\nEach empty field generates $1$.\n\n- Animals II:\\\nAll animals in the picture together generate single value $1 \\cdot (\\text{number of chupacabras}) \\cdot (\\text{number of birds which are not drakes}) \\cdot (\\text{number of drakes})$.\n\n- House view down:\\\nWhen an empty field is located above a house, is in the same column, and there is no non-empty field between the empty field and the house, the empty field generates $5$.\n\n- Grill/drake:\\\nEach cell with a grill and with at least one adjacent cell with a drake generates $50$.\n\n- Houses and grills:\\\nHouses and grills in the picture generate $3 \\cdot \\min \\{ \\text{number of all houses}, \\text{number of all grills} \\}$.", "inputFormat": "The first input line contains one integer $N$ ($1 \\leq N \\leq 50$), the number of the rows and the columns in the picture. Next, there are $N$ lines, each specifies one line in the picture. One character on the line represents one cell and its contents.\n\nThe interpretation of particular characters in the picture representation follows:\nempty cell ` ` (space), sun `*`, house `^`, chupacabra `!`, left slope `/`, right slope `\\`, bird `v`, drake `D`, grill `G`.", "outputFormat": "Print one integer, the value of the input picture.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[CERC 2020] Art Transaction", "background": null, "description": "黑帮从国家美术馆盗走的最大画作将在被卖到黑市之前由专家进行鉴定。这幅画的构图明显遵循了当代 AI 艺术的主流趋势。可以将这幅画看作一个由方格单元组成的网格，每个单元要么为空，要么非空。非空单元格中恰好包含以下某一种物体：太阳、房子、卓柏卡布拉、左斜坡、右斜坡、鸟、龙、烤架。若两个单元格在网格中共享一条边，则称它们是相邻的。两个单元格之间的连接是一系列包含这两个单元格的单元格序列，且序列中每一对相邻单元格在画中也是相邻的。一个区域是一组单元格。如果区域内任意两单元格之间都存在连接，则称该区域是连通的。\n\n这幅画的价值等于所有下述规则产生的价值之和。\n\n太阳：\n一个非空单元格（不含太阳）如果与某个含有太阳的单元格在同一直线上，且两者之间没有其他物体，则被该太阳照亮。直线可以是水平、垂直或对角线（两种对角线方向均适用）。如果一个单元格被多个太阳照亮，仍只计一次。太阳不能照亮自身。每个被照亮的单元格产生 $100$ 分。\n\n最大鸟群：\n龙也是鸟。鸟群是由所有包含鸟的单元格组成的极大连通区域。鸟群的宽度定义为该鸟群中同一行上连续单元格的最大长度。每个鸟群产生 $500 \\cdot (\\text{鸟群宽度})$ 分。\n\n鸟群周长：\n每个鸟群（见上条）产生 $60 \\cdot (\\text{鸟群周长})$ 分。鸟群周长是指所有将鸟群单元格与不含鸟的单元格或画外部分隔开的边的总数。\n\n房屋上方视野：\n当一个空单元格位于某个房子上方、在同一列且两者之间没有非空单元格时，该空单元格产生 $10$ 分。\n\n$3 \\times 3$ 区块：\n每个唯一的 $3 \\times 3$ 区块（可以重叠）产生 $1$ 分。\n\n动物 I：\n每条连接动物单元格和空单元格的边产生 $15$ 分。\n\n自由：\n如果单元格 X 要么与画的边界相邻，要么存在一条仅经过空单元格的连接，将画边界相邻的单元格与 X 相邻的单元格连接起来，则称 X 是自由单元格。每个非空自由单元格产生 $7$ 分。\n\n卓柏卡布拉：\n龙也是鸟。每个能被卓柏卡布拉通过一次国际象棋马步到达的鸟都会被计入。\n\n山峰：\n在同一行上，若有一对相邻单元格分别为“/”（左斜坡）和“\\”（右斜坡，顺序不可颠倒），则称为一个山峰。山峰顶点是连接这两个符号最上端点的线段中点。山峰值为该山峰顶点到网格中其他山峰顶点的最大曼哈顿距离（取整数）。当画中有至少两个山峰时，每个山峰 $P$ 产生 $50 \\cdot (P \\text{ 值})$ 分；若只有一个山峰，则产生 $0$ 分。\n\n龙/烤架：\n每个含有龙且至少有一个相邻单元格为烤架的单元格产生 $500$ 分。\n\n最小频率：\n某种物体 X 的频率为画中该类物体（包括 X 本身）的总数。若某个物体的频率在所有物体中最小，则每个这样的单独物体产生 $10$ 分。\n\n空单元格：\n每个空单元格产生 $1$ 分。\n\n动物 II：\n画中所有动物共同产生 $1 \\cdot (\\text{卓柏卡布拉数量}) \\cdot (\\text{非龙的鸟数量}) \\cdot (\\text{龙的数量})$ 分。\n\n房屋下方视野：\n当一个空单元格位于某个房子下方、在同一列且两者之间没有非空单元格时，该空单元格产生 $5$ 分。\n\n烤架/龙：\n每个含有烤架且至少有一个相邻单元格为龙的单元格产生 $50$ 分。\n\n房屋与烤架：\n画中的房屋和烤架共同产生 $3 \\cdot \\min \\{ \\text{房屋总数}, \\text{烤架总数} \\}$ 分。", "inputFormat": "第一行输入一个整数 $N$（$1 \\leq N \\leq 50$），表示画的行数和列数。接下来 $N$ 行，每行描述画的一行。每行的每个字符表示一个单元格及其内容。\n\n各字符含义如下：\n空单元格“ ”（空格），太阳“*”，房子“~”，卓柏卡布拉“!”，左斜坡“/”，右斜坡“\\”，鸟“v”，龙“D”，烤架“G”。", "outputFormat": "输出一个整数，表示输入画作的总价值。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13652", "type": "P", "difficulty": 6, "samples": [["4 3\n0 1\n0 2\n0 3\n\n\n2\n\n3\n\n-1", "\n\n\n\nDEFEND\n0 1 2\n\n0\n\n2 1 0 0 3"], ["4 1\n0 1\n0 2\n0 3\n\n0\n\n1 0 1", "\n\n\n\nATTACK\n\n1\n\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "交互题", "Special Judge", "ICPC", "CERC"], "title": "[CERC 2020] Bank Robbery", "background": "", "description": "Each day, robbers plan to rob exactly one bank in a region. Due to undercover informers' work, the detectives get to know which particular bank is being targeted by the robbers on each day just before $6$ AM. The presence of a single detective in a bank is enough to deter the robbers, so the detectives want to plan their positions intelligently. Robbing is planned to happen during the daylight after $8$ AM, when the banks open, and is always successful when there is no detective in the bank. Unfortunately, though, the number of detectives is not very big so there may not be enough of them to keep the banks safe. To ensure they are effective, there can be at most one detective in any bank at any time. A detective can leave a bank and travel to another bank only between $6$ AM and $8$ AM.\n\nGiven enough days, any detective would be able to move from any of the banks to any other via the $2$-hour transits. Due to the travel restrictions (mainly time), they are not able to move freely but are restricted to move only between banks that are close to each other. The region is quite specific because there is a minimum number of bank pairs that are close that conform to the above restrictions. Additionally, no bank is close to exactly two other banks.\n\nNow, there is a quest for a computer simulation: determining if the robbers can succeed in at least one robbery during one year. The simulation is run against the preprogrammed judge as a kind of computer game, with strong consequences in real life. In the game, the attacker represents the robbers, the defender manages the detectives.\n\nIn the beginning, the simulation is given the system of connections between close banks and the number of detectives available. Then, the simulation chooses whether it plays as an attacker or as a defender. The judge automatically adopts the opposite role. Next, the defender places the given number of detectives in banks according to its own choice.\n\nNext, the game proceeds in turns. In one turn, the attacker announces a bank and then the defender moves each detective over at most one connection. The defender's aim is to choose the movements in such a way the announced bank is occupied by a detective at the end of the turn. If there is no detective in the announced bank after all movements in the turn, the attacker immediately wins the game. Otherwise, the defender defends the turn and the next turn ensues. If the defender can successfully defend for one year ($365$ turns), they win the game. During the game, the location of each detective is known to both the attacker and the defender.\n\nThe goal of the simulation you have to write is to choose a role smartly so that you are able to win the game.\n\n### Interactive Mode\n\nThe simulation is evaluated in so-called _interactive_ mode, which means that the input received depends on the output produced so far. The output of the judge is the input of the simulation and vice versa. If you have no previous experience with such problems, just do not be afraid — you are still reading from the standard input and printing to the standard output. There are just a few things to pay attention to.\n\nAfter printing each response to the input from the judge, the simulation has to flush the output buffer. For example, it may use fflush(stdout) or cout.flush() in C++, System.out.flush() in Java, or stdout.flush() in Python. Also, it should never try to read more data than what is guaranteed to be ready in the input, because that may cause it to hang indefinitely. In particular, be careful to _not_ invoke anything like scanf(\"%d \") or scanf(\"%d\\n\"), as such formats try to scan forward for any further whitespace. Instead, use just scanf(\"%d\") without trailing whitespace.\n\nAfter you choose a role and print a corresponding output, the following exchange is repeated for up to 365 times: The attacker outputs the bank index $0 \\leq v \\leq B-1$ which they choose to attack. Then, the defender outputs an integer $k$ and then $k$ pairs $b_i, c_i$ ($0 \\leq b_i, c_i \\leq B-1$), each of which represents a detective move from bank $b_i$ to bank $c_i$. The detectives may only move along connections between close banks. The attacker ends the sequence of attacks by outputting $-1$. The defender may give up by ending the program.\n\nIn this exchange, the output of one player is always the input of the other player.", "inputFormat": "The first input line contains values $B$ and $D$ ($4 \\leq B \\leq 100, 0 \\leq D \\leq B$), the number of banks and the number of detectives. The banks are labeled by integers $0, 1, \\ldots, B-1$. Each of the next $B-1$ lines contains a pair of integers $b_i$ and $c_i$ ($0 \\leq b_i, c_i \\leq B-1$) representing a connection between two close banks $b_i$ and $c_i$.\n", "outputFormat": "After reading the input, if you choose to attack, then prints a line with string ATTACK. Otherwise, print a line with string DEFEND and on the next line it print $D$ different indices, in arbitrary order, of all the banks where a detective is initially located. The remainder of the exchange happens interactively.\n", "hint": "For clarity, the above data are interleaved to illustrate the order of interaction between the simulation and the judge. Note that there will be no empty lines in real data and there must not be any empty lines in the simulation output.", "locale": "en", "translations": {"en": {"title": "[CERC 2020] Bank Robbery", "background": "", "description": "Each day, robbers plan to rob exactly one bank in a region. Due to undercover informers' work, the detectives get to know which particular bank is being targeted by the robbers on each day just before $6$ AM. The presence of a single detective in a bank is enough to deter the robbers, so the detectives want to plan their positions intelligently. Robbing is planned to happen during the daylight after $8$ AM, when the banks open, and is always successful when there is no detective in the bank. Unfortunately, though, the number of detectives is not very big so there may not be enough of them to keep the banks safe. To ensure they are effective, there can be at most one detective in any bank at any time. A detective can leave a bank and travel to another bank only between $6$ AM and $8$ AM.\n\nGiven enough days, any detective would be able to move from any of the banks to any other via the $2$-hour transits. Due to the travel restrictions (mainly time), they are not able to move freely but are restricted to move only between banks that are close to each other. The region is quite specific because there is a minimum number of bank pairs that are close that conform to the above restrictions. Additionally, no bank is close to exactly two other banks.\n\nNow, there is a quest for a computer simulation: determining if the robbers can succeed in at least one robbery during one year. The simulation is run against the preprogrammed judge as a kind of computer game, with strong consequences in real life. In the game, the attacker represents the robbers, the defender manages the detectives.\n\nIn the beginning, the simulation is given the system of connections between close banks and the number of detectives available. Then, the simulation chooses whether it plays as an attacker or as a defender. The judge automatically adopts the opposite role. Next, the defender places the given number of detectives in banks according to its own choice.\n\nNext, the game proceeds in turns. In one turn, the attacker announces a bank and then the defender moves each detective over at most one connection. The defender's aim is to choose the movements in such a way the announced bank is occupied by a detective at the end of the turn. If there is no detective in the announced bank after all movements in the turn, the attacker immediately wins the game. Otherwise, the defender defends the turn and the next turn ensues. If the defender can successfully defend for one year ($365$ turns), they win the game. During the game, the location of each detective is known to both the attacker and the defender.\n\nThe goal of the simulation you have to write is to choose a role smartly so that you are able to win the game.\n\n### Interactive Mode\n\nThe simulation is evaluated in so-called _interactive_ mode, which means that the input received depends on the output produced so far. The output of the judge is the input of the simulation and vice versa. If you have no previous experience with such problems, just do not be afraid — you are still reading from the standard input and printing to the standard output. There are just a few things to pay attention to.\n\nAfter printing each response to the input from the judge, the simulation has to flush the output buffer. For example, it may use fflush(stdout) or cout.flush() in C++, System.out.flush() in Java, or stdout.flush() in Python. Also, it should never try to read more data than what is guaranteed to be ready in the input, because that may cause it to hang indefinitely. In particular, be careful to _not_ invoke anything like scanf(\"%d \") or scanf(\"%d\\n\"), as such formats try to scan forward for any further whitespace. Instead, use just scanf(\"%d\") without trailing whitespace.\n\nAfter you choose a role and print a corresponding output, the following exchange is repeated for up to 365 times: The attacker outputs the bank index $0 \\leq v \\leq B-1$ which they choose to attack. Then, the defender outputs an integer $k$ and then $k$ pairs $b_i, c_i$ ($0 \\leq b_i, c_i \\leq B-1$), each of which represents a detective move from bank $b_i$ to bank $c_i$. The detectives may only move along connections between close banks. The attacker ends the sequence of attacks by outputting $-1$. The defender may give up by ending the program.\n\nIn this exchange, the output of one player is always the input of the other player.", "inputFormat": "The first input line contains values $B$ and $D$ ($4 \\leq B \\leq 100, 0 \\leq D \\leq B$), the number of banks and the number of detectives. The banks are labeled by integers $0, 1, \\ldots, B-1$. Each of the next $B-1$ lines contains a pair of integers $b_i$ and $c_i$ ($0 \\leq b_i, c_i \\leq B-1$) representing a connection between two close banks $b_i$ and $c_i$.\n", "outputFormat": "After reading the input, if you choose to attack, then prints a line with string ATTACK. Otherwise, print a line with string DEFEND and on the next line it print $D$ different indices, in arbitrary order, of all the banks where a detective is initially located. The remainder of the exchange happens interactively.\n", "hint": "For clarity, the above data are interleaved to illustrate the order of interaction between the simulation and the judge. Note that there will be no empty lines in real data and there must not be any empty lines in the simulation output.", "locale": "en"}, "zh-CN": {"title": "[CERC 2020] Bank Robbery", "background": null, "description": "每天，劫匪计划在某个地区抢劫恰好一家银行。由于卧底线人的工作，侦探们会在每天早上 $6$ 点之前得知劫匪当天要抢劫哪家银行。只要有一名侦探在银行，劫匪就会被吓退，因此侦探们需要合理安排自己的位置。抢劫会在银行开门后的白天（早上 $8$ 点后）进行，如果银行内没有侦探，抢劫就一定会成功。不幸的是，侦探的数量并不多，可能无法保护所有银行。为了保证效果，任何时刻每家银行最多只能有一名侦探。侦探只能在早上 $6$ 点到 $8$ 点之间离开当前银行并前往另一家银行。\n\n只要有足够的天数，任何侦探都可以通过多次 $2$ 小时的转移，从任意一家银行到达另一家银行。但由于出行限制（主要是时间），侦探们只能在彼此相邻的银行之间移动。该地区的银行网络有如下特点：存在最少数量的相邻银行对，并且没有任何一家银行恰好与两家其他银行相邻。\n\n现在，需要进行一次计算机模拟：判断劫匪在一年内（365 天）是否至少能成功抢劫一次。模拟程序将与预设的裁判程序进行对抗，类似于一场计算机游戏，且结果具有现实意义。在游戏中，攻击方代表劫匪，防守方负责调度侦探。\n\n一开始，模拟程序会获得所有银行之间的相邻关系以及侦探的数量。然后，程序选择扮演攻击方或防守方，裁判自动扮演对方角色。接下来，防守方根据自己的选择将所有侦探安置在若干银行。\n\n之后，游戏按回合进行。每回合，攻击方宣布要抢劫的一家银行，然后防守方可以让每名侦探沿着一条相邻银行的连线移动一次。防守方的目标是在回合结束时让被宣布的银行有侦探驻守。如果回合结束后该银行没有侦探，攻击方立即获胜。否则，防守方成功防守本回合，进入下一回合。如果防守方能连续防守一年（365 回合），则防守方获胜。游戏过程中，每名侦探的位置对双方都是公开的。\n\n你需要编写一个模拟程序，智能地选择扮演的角色，以确保自己能够获胜。\n\n### 交互模式\n\n本题采用“交互模式”评测，即输入数据会根据你当前的输出动态生成。如果你没有相关经验也不用担心——你依然是从标准输入读取数据，向标准输出打印数据。只需注意以下几点：\n\n每次输出响应后，必须刷新输出缓冲区。例如，在 C++ 中可以使用 fflush(stdout) 或 cout.flush()，在 Java 中用 System.out.flush()，在 Python 中用 stdout.flush()。同时，切勿尝试读取未准备好的输入数据，否则程序可能会无限等待。特别注意不要使用 scanf(\"%d \") 或 scanf(\"%d\\n\") 之类的格式，因为这些格式会试图读取后续的空白字符。应只使用 scanf(\"%d\")，不要带尾随空白。\n\n选择角色并输出后，以下交互最多重复 365 次：攻击方输出要攻击的银行编号 $0 \\leq v \\leq B-1$，防守方输出一个整数 $k$，随后输出 $k$ 对 $b_i, c_i$（$0 \\leq b_i, c_i \\leq B-1$），表示侦探从银行 $b_i$ 移动到银行 $c_i$。侦探只能沿着相邻银行之间的连线移动。攻击方在结束攻击时输出 $-1$。防守方可以通过结束程序放弃比赛。\n\n在整个交互过程中，一方的输出始终作为另一方的输入。", "inputFormat": "第一行输入两个整数 $B$ 和 $D$（$4 \\leq B \\leq 100, 0 \\leq D \\leq B$），分别表示银行数量和侦探数量。银行编号为 $0, 1, \\ldots, B-1$。接下来的 $B-1$ 行，每行包含一对整数 $b_i, c_i$（$0 \\leq b_i, c_i \\leq B-1$），表示银行 $b_i$ 和 $c_i$ 之间有一条相邻连线。", "outputFormat": "读入输入后，如果你选择攻击方，则输出一行 ATTACK。否则，输出一行 DEFEND，下一行输出 $D$ 个不同的银行编号（顺序任意），表示每名侦探的初始位置。后续交互过程按题目描述进行。", "hint": "为便于理解，样例数据中输入输出交错排列，展示了模拟程序与裁判的交互顺序。注意，实际数据中不会有空行，程序输出也不得有空行。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13653", "type": "P", "difficulty": 5, "samples": [["4\nA?A?\n2\nA 10\nB 25", "140"], ["4\nA??A\n2\nA 10\nB 25", "120"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "ICPC", "CERC"], "title": "[CERC 2020] Pizzo Collectors", "background": "", "description": "Lavish Circle (LC) is the fashionable circular avenue in the residential area of the town. Houses on LC are exceptionally expensive and some of them are currently empty. LC is under heavy control of the town mafia who wants to populate the empty houses with new owners loyal to the mafia. When LC is completely populated, each house owner will live in one house on LC. LC is a circular avenue of houses numbered from $1$ to $N$, that is for $i < N$, $i$-th and $i+1$-th houses are neighboring and also houses $N$ and $1$ are neighboring.\n\nThe house owners, both the existing ones and the new ones, fall into few categories according to the sum they can pay the mafia monthly for protecting them. The money is called pizzo and it is typically collected by a person called a pizzo collector (PC). The mafia employs a group of them.\n\nThe job of a PC is to go around entire LC exactly once in a month and collect pizzo from the selected houses on the journey. All selected houses on a journey of a PC must have owners of the same pizzo category. The journey must also start and end at the same house, it is a check PC completed the journey correctly. The pizzo is collected from this house only once, at the beginning or at the end of the journey. During his journey, a PC always moves forward by a fixed number of houses, until the PC arrives again to the starting house. That is, the number of houses a PC skips on each move is a non-negative integer $d$, which remains constant during the entire journey of this PC. It must hold that $(d+1)$ divides $N$ evenly.\n\nThe mafia wants to employ as many PCs as possible. Of course, employing a number of PCs means that some owners quite probably have to pay pizzo more than once in a month, but the mafia does not care... Unfortunately, there is a complication. PCs are peaceful citizens and they do not tend to shoot at each other under normal conditions. However, when two PCs find out that at their respective collection journeys they visit the same set of houses, and it does not matter in which order they visit the houses, the collectors tend to shoot each other and thus attract the police, which is a behavior the mafia wants to avoid at any cost. So, no two collectors who may shoot each other can be employed simultaneously.\n\nThe total value of all collected pizzo depends also on the categories of the owners of the newly populated houses. The mafia decides on the category of each new house owner. Obviously the mafia wants to maximize their income. You have been hired as an analyst to find the maximum possible total value of all collected pizzo in one month, when LC gets completely and suitably populated. The mafia is going to decide on the pizzo category of each new house owner based on your recommendations. The number of houses on LC is a non-negative integer power of a prime number.\n", "inputFormat": "The first line contains integer $N$ ($1 \\leq N \\leq 10^5$), a non-negative integer power of some prime number $p$. The second row contains string $S$ of length $N$, which consists of only capital letters of English alphabet and the character \"?\". The characters of the string represent the houses on LC in the order they appear on LC. The \"?\" character represents a currently empty house, each of the other characters represent the pizzo category of the house owner.\n\nThe next line contains integer $k$ ($1 \\leq k \\leq 26$), the number of different pizzo categories. Each of the next $k$ lines contains an integer pair $c_i$ $v_i$, where $c_i$ is a capital English character and $1 \\leq v_i \\leq 10^6$ is the money value which is paid by a house owner of pizzo category $c_i$ in one visit of a PC to the house.\n\nIt is guaranteed that for every category that appears in $S$, there is a pair $c_i$ and $v_i$ which defines its money value which is paid on the PC's visit.\n", "outputFormat": "Print the maximum possible total value of all collected pizzo in one month, when LC is completely populated.", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC 2020] Pizzo Collectors", "background": "", "description": "Lavish Circle (LC) is the fashionable circular avenue in the residential area of the town. Houses on LC are exceptionally expensive and some of them are currently empty. LC is under heavy control of the town mafia who wants to populate the empty houses with new owners loyal to the mafia. When LC is completely populated, each house owner will live in one house on LC. LC is a circular avenue of houses numbered from $1$ to $N$, that is for $i < N$, $i$-th and $i+1$-th houses are neighboring and also houses $N$ and $1$ are neighboring.\n\nThe house owners, both the existing ones and the new ones, fall into few categories according to the sum they can pay the mafia monthly for protecting them. The money is called pizzo and it is typically collected by a person called a pizzo collector (PC). The mafia employs a group of them.\n\nThe job of a PC is to go around entire LC exactly once in a month and collect pizzo from the selected houses on the journey. All selected houses on a journey of a PC must have owners of the same pizzo category. The journey must also start and end at the same house, it is a check PC completed the journey correctly. The pizzo is collected from this house only once, at the beginning or at the end of the journey. During his journey, a PC always moves forward by a fixed number of houses, until the PC arrives again to the starting house. That is, the number of houses a PC skips on each move is a non-negative integer $d$, which remains constant during the entire journey of this PC. It must hold that $(d+1)$ divides $N$ evenly.\n\nThe mafia wants to employ as many PCs as possible. Of course, employing a number of PCs means that some owners quite probably have to pay pizzo more than once in a month, but the mafia does not care... Unfortunately, there is a complication. PCs are peaceful citizens and they do not tend to shoot at each other under normal conditions. However, when two PCs find out that at their respective collection journeys they visit the same set of houses, and it does not matter in which order they visit the houses, the collectors tend to shoot each other and thus attract the police, which is a behavior the mafia wants to avoid at any cost. So, no two collectors who may shoot each other can be employed simultaneously.\n\nThe total value of all collected pizzo depends also on the categories of the owners of the newly populated houses. The mafia decides on the category of each new house owner. Obviously the mafia wants to maximize their income. You have been hired as an analyst to find the maximum possible total value of all collected pizzo in one month, when LC gets completely and suitably populated. The mafia is going to decide on the pizzo category of each new house owner based on your recommendations. The number of houses on LC is a non-negative integer power of a prime number.\n", "inputFormat": "The first line contains integer $N$ ($1 \\leq N \\leq 10^5$), a non-negative integer power of some prime number $p$. The second row contains string $S$ of length $N$, which consists of only capital letters of English alphabet and the character \"?\". The characters of the string represent the houses on LC in the order they appear on LC. The \"?\" character represents a currently empty house, each of the other characters represent the pizzo category of the house owner.\n\nThe next line contains integer $k$ ($1 \\leq k \\leq 26$), the number of different pizzo categories. Each of the next $k$ lines contains an integer pair $c_i$ $v_i$, where $c_i$ is a capital English character and $1 \\leq v_i \\leq 10^6$ is the money value which is paid by a house owner of pizzo category $c_i$ in one visit of a PC to the house.\n\nIt is guaranteed that for every category that appears in $S$, there is a pair $c_i$ and $v_i$ which defines its money value which is paid on the PC's visit.\n", "outputFormat": "Print the maximum possible total value of all collected pizzo in one month, when LC is completely populated.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC 2020] Pizzo Collectors", "background": null, "description": "Lavish Circle（LC）是小镇住宅区内一条时尚的环形大道。LC 上的房屋价格极其昂贵，其中有些房屋目前还空着。LC 受到镇上黑手党的严密控制，他们希望用忠于黑手党的新房主填满这些空房。当 LC 完全住满后，每位房主将居住在 LC 上的一间房屋中。LC 是一条环形大道，房屋编号从 $1$ 到 $N$，即对于 $i < N$，第 $i$ 号房屋和第 $i+1$ 号房屋相邻，同时第 $N$ 号房屋和第 $1$ 号房屋也相邻。\n\n房主（包括现有的和新入住的）根据他们每月能为黑手党支付保护费的金额被分为若干类别。这笔钱被称为 pizzo，通常由一名称为 pizzo 收集员（PC）的人收取。黑手党雇佣了一批这样的收集员。\n\nPC 的工作是每月沿 LC 环形大道完整走一圈，并在途中从选定的房屋收取 pizzo。一次 PC 的收集路线上的所有被选中的房屋，其房主必须属于同一 pizzo 类别。收集路线必须从某一房屋出发并最终回到该房屋，以此检查 PC 是否正确完成了路线。在收集过程中，PC 每次都向前移动固定数量的房屋，直到再次回到起点。也就是说，PC 每次跳过的房屋数是一个非负整数 $d$，在整个收集过程中保持不变。必须满足 $(d+1)$ 能整除 $N$。\n\n黑手党希望雇佣尽可能多的 PC。当然，雇佣多个 PC 意味着某些房主可能每月要多次支付 pizzo，但黑手党对此并不在意……然而，事情有个复杂之处。PC 们本是和平公民，通常不会互相开枪。但如果两名 PC 发现他们各自的收集路线访问了同一组房屋（无论访问顺序如何），他们就会互相开枪，从而引来警察，这种情况黑手党无论如何都要避免。因此，任何可能互相开枪的收集员不能同时被雇佣。\n\n所有收集到的 pizzo 总价值还取决于新入住房主的类别。黑手党可以决定每个新房主的 pizzo 类别。显然，黑手党希望最大化他们的收入。你被雇佣为分析师，需要找出在 LC 完全且合理住满时，一个月内所有收集到的 pizzo 的最大可能总价值。黑手党将根据你的建议决定每个新房主的 pizzo 类别。LC 上的房屋数量 $N$ 是某个质数 $p$ 的非负整数次幂。", "inputFormat": "第一行包含整数 $N$（$1 \\leq N \\leq 10^5$），$N$ 是某个质数 $p$ 的非负整数次幂。第二行包含长度为 $N$ 的字符串 $S$，仅由大写英文字母和字符 \"?\" 组成。字符串的每个字符代表 LC 上对应顺序的房屋。\"?\" 表示该房屋目前为空，其它字符表示该房屋主人的 pizzo 类别。\n\n接下来一行包含整数 $k$（$1 \\leq k \\leq 26$），表示不同的 pizzo 类别数。接下来的 $k$ 行，每行包含一对整数 $c_i$ $v_i$，其中 $c_i$ 是一个大写英文字母，$1 \\leq v_i \\leq 10^6$，表示 pizzo 类别 $c_i$ 的房主在 PC 每次访问该房屋时需支付的金额。\n\n保证 $S$ 中出现的每个类别都在输入的类别列表中有定义。", "outputFormat": "输出在 LC 完全住满时，一个月内所有收集到的 pizzo 的最大可能总价值。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13654", "type": "P", "difficulty": 4, "samples": [["2 K\nK.\nKK", "YES\n2 2 2 1\n2 1 1 1"], ["3 B\nB..\nB..\n..B", "NO"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "并查集", "Special Judge", "ICPC", "CERC"], "title": "[CERC 2020] Excavation", "background": "", "description": "The police investigation revealed the gangsters deployed several radioactive stones under the city to poison underground waters. The exact positions of radioactive stones were found, but due to nature of radioactivity, it is a difficult task to remove the stones safely. The government of the city thus decided to use shielded excavators to retrieve stones from the ground.\n\nThe city shape is a square grid. City services have several excavator types available – Reepadlo, Qrtech, Bugger, Namakatschenko, and Kopatsch. Each of them has different specifications and movement pattern. Excavators may move either as a Rook, a Queen, a Bishop, a kNight, or as a King in the game of chess, respectively (see images for movement illustration). Due to compatibility issues only a single type of excavators can be deployed.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s7uvuutt.png)\n\nThere is at most one radioactive stone on each tile of the grid. At the beginning of the excavation, there is one excavator at the position of each radioactive stone and it immediately retrieves the stone from the ground. The next steps of the operation are executed to follow strict radiation handling safety protocol. At each step only one excavator can execute a single move and it can execute it only if the move brings the excavator to a position of another excavator. Excavators of types Reepadlo, Qrtech, Bugger may skip over other excavators during a move over multiple grid tiles, i.e. they do not have to end the move on the position of the first encountered excavator. After excavator $A$ arrives to the position of excavator $B$, $B$ takes its load and $A$ is removed from the operation to be cleaned of radiation.\n\nThe operation finishes successfully if in the end there is a single excavator remaining. It is possible the operation can not be successfully finished.\n\nYour task is to determine whether the operation can be finished successfully. If it can, print also the excavators' moves leading to the solution.\n", "inputFormat": "The first line of input contains an integer $N$ ($1 \\leq N \\leq 100$), determining the size of the city, and a single character determining the excavator type to be deployed (“R” – Reepadlo, “Q” – Qrtech, “B” – Bugger, “N” – Namakatschenko, “K” – Kopatsch).\n\nAfter that follow $N$ lines describing the initial positions of the excavators in the city. Each line contains $N$ characters, where each character is either the excavator type or “.” for empty field. There is always at least one excavator deployed in the city.\n", "outputFormat": "On the first line print either “YES”, if the operation for the given configuration can be finished successfully, and “NO” otherwise. If the operation can be finished successfully, print also lines describing moves of excavators in the same order they were executed during the excavation, if there were any. $i$-th such line describes a single step and contains four space separated integers $X, Y, W, Z$ ($1 \\leq X, Y, W, Z \\leq N$), indicating an excavator moves from position $(X, Y)$ to position $(W, Z)$ in step $i$. A position $(X, Y)$ describes the position on row $X$ (numbered from top to bottom) and in column $Y$ (numbered from left to right).", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC 2020] Excavation", "background": "", "description": "The police investigation revealed the gangsters deployed several radioactive stones under the city to poison underground waters. The exact positions of radioactive stones were found, but due to nature of radioactivity, it is a difficult task to remove the stones safely. The government of the city thus decided to use shielded excavators to retrieve stones from the ground.\n\nThe city shape is a square grid. City services have several excavator types available – Reepadlo, Qrtech, Bugger, Namakatschenko, and Kopatsch. Each of them has different specifications and movement pattern. Excavators may move either as a Rook, a Queen, a Bishop, a kNight, or as a King in the game of chess, respectively (see images for movement illustration). Due to compatibility issues only a single type of excavators can be deployed.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s7uvuutt.png)\n\nThere is at most one radioactive stone on each tile of the grid. At the beginning of the excavation, there is one excavator at the position of each radioactive stone and it immediately retrieves the stone from the ground. The next steps of the operation are executed to follow strict radiation handling safety protocol. At each step only one excavator can execute a single move and it can execute it only if the move brings the excavator to a position of another excavator. Excavators of types Reepadlo, Qrtech, Bugger may skip over other excavators during a move over multiple grid tiles, i.e. they do not have to end the move on the position of the first encountered excavator. After excavator $A$ arrives to the position of excavator $B$, $B$ takes its load and $A$ is removed from the operation to be cleaned of radiation.\n\nThe operation finishes successfully if in the end there is a single excavator remaining. It is possible the operation can not be successfully finished.\n\nYour task is to determine whether the operation can be finished successfully. If it can, print also the excavators' moves leading to the solution.\n", "inputFormat": "The first line of input contains an integer $N$ ($1 \\leq N \\leq 100$), determining the size of the city, and a single character determining the excavator type to be deployed (“R” – Reepadlo, “Q” – Qrtech, “B” – Bugger, “N” – Namakatschenko, “K” – Kopatsch).\n\nAfter that follow $N$ lines describing the initial positions of the excavators in the city. Each line contains $N$ characters, where each character is either the excavator type or “.” for empty field. There is always at least one excavator deployed in the city.\n", "outputFormat": "On the first line print either “YES”, if the operation for the given configuration can be finished successfully, and “NO” otherwise. If the operation can be finished successfully, print also lines describing moves of excavators in the same order they were executed during the excavation, if there were any. $i$-th such line describes a single step and contains four space separated integers $X, Y, W, Z$ ($1 \\leq X, Y, W, Z \\leq N$), indicating an excavator moves from position $(X, Y)$ to position $(W, Z)$ in step $i$. A position $(X, Y)$ describes the position on row $X$ (numbered from top to bottom) and in column $Y$ (numbered from left to right).", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC 2020] Excavation", "background": null, "description": "警方调查发现，黑帮分子在城市地下布置了若干放射性石块，用以污染地下水。虽然已查明所有放射性石块的具体位置，但由于放射性的特殊性质，安全移除这些石块是一项极其困难的任务。因此，市政府决定使用带有防护装置的挖掘机将石块从地下取出。\n\n城市的形状为一个正方形网格。市政部门拥有多种类型的挖掘机可供选择——Reepadlo、Qrtech、Bugger、Namakatschenko 和 Kopatsch。每种挖掘机具有不同的规格和移动方式。挖掘机的移动方式分别对应国际象棋中的车、后、象、马和王（见上图）。由于兼容性问题，每次只能部署一种类型的挖掘机。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s7uvuutt.png)\n\n每个网格最多只会有一块放射性石块。挖掘行动开始时，每块放射性石块的位置上各有一台挖掘机，并立即将该石块取出。接下来的操作必须严格遵守放射性安全处理协议。每一步操作中，只允许一台挖掘机执行一次移动，且该移动必须使挖掘机到达另一台挖掘机所在的位置。Reepadlo、Qrtech、Bugger 类型的挖掘机在一次跨越多个格子的移动过程中可以跳过其他挖掘机，即它们不必在遇到的第一台挖掘机处停下。挖掘机 $A$ 到达挖掘机 $B$ 的位置后，$B$ 会接管 $A$ 的负载，$A$ 随即退出行动并进行辐射清理。\n\n如果最终只剩下一台挖掘机，则行动成功完成。也有可能无法成功完成该行动。\n\n你的任务是判断该行动能否成功完成。如果可以，请输出实现该目标的挖掘机移动方案。", "inputFormat": "输入的第一行包含一个整数 $N$（$1 \\leq N \\leq 100$），表示城市的规模，以及一个字符，表示要部署的挖掘机类型（“R”——Reepadlo，“Q”——Qrtech，“B”——Bugger，“N”——Namakatschenko，“K”——Kopatsch）。\n\n接下来有 $N$ 行描述城市中挖掘机的初始位置。每行包含 $N$ 个字符，每个字符要么是挖掘机类型的字母，要么是“.”表示该格为空。城市中至少有一台挖掘机。", "outputFormat": "输出的第一行若该配置可以成功完成行动，则输出“YES”，否则输出“NO”。如果可以成功完成行动，则接下来每行描述一次挖掘机的移动，按执行顺序输出。如果有多步操作，第 $i$ 行包含四个用空格分隔的整数 $X, Y, W, Z$（$1 \\leq X, Y, W, Z \\leq N$），表示有一台挖掘机从位置 $(X, Y)$ 移动到位置 $(W, Z)$。位置 $(X, Y)$ 表示第 $X$ 行（自上而下编号）第 $Y$ 列（自左至右编号）。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13655", "type": "P", "difficulty": 4, "samples": [["1", "1\n0 0 1\n1 0\n0 0"], ["13", "8\n1 0 1\n0 1 0\n1 1 0\n3 1 0\n1 2 1\n2 2 1\n1 3 1\n3 3 1\n3 2\n3 3\n1 2\n1 0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "Special Judge", "ICPC", "CERC"], "title": "[CERC 2020] Tobacco Growing", "background": "", "description": "In the city, there is a beautiful park full of blossoming flowers. This park is very popular among citizens and especially families with children are common visitors. The gangsters want to extend their criminal activities to this area, mainly in the tobacco production. They decided to secretly plant tobacco seeds in the park and let it grow right under policemen noses. When the time is right, they plan to harvest as much tobacco as possible in a single operation and smuggle it over borders.\n\nThe park consists of flower tiles with coordinates ranging from $-10^6$ to $10^6$ in either direction. A tile on coordinates $(X, Y)$ neighbors with tiles on coordinates $(X + 1, Y)$, $(X - 1, Y)$, $(X, Y + 1)$ and $(X, Y - 1)$ (within coordinates range). On the first day, the gangsters may cut the flowers on any of the tiles. Also only on the first day, if a tile is cut, the gangsters may either plant a tobacco on it, or let the tile contain only grass. In the beginning, the tobacco quantity on a tile with tobacco is $1$ and the tobacco quantity on a tile with grass or on a tile with flowers is $0$. Local tobacco spreads rather aggressively, and so on each consecutive day, the tobacco quantity on park tiles grows as follows:\n\n- Tobacco quantity on tiles with tobacco and grass is increased by the sum of tobacco quantity on the neighboring tiles on the previous day.\n- Tobacco quantity on tiles with flowers always remains $0$.\n\nAfter some days of growing, the harvest operation will take place on a particular day. The gangsters will choose some of the tiles (of any type) to be harvested and obtain the total tobacco quantity on such tiles on that day. Each tile may be harvested at most once and all tobacco quantity on a chosen tile must be harvested. The gangsters can’t harvest everything, because there is a limit on the tobacco quantity that can be somewhat safely smuggled. At the same time, the gangsters do not want to take any unnecessary losses and so they want to harvest exactly the limit amount.\n\nThe task is to help the gangsters to plan the operation to the very detail. That is in particular:\n\n1. For the first day, choose flower tiles to be cut, and from these choose tiles to plant tobacco on. At most $2 \\cdot 10^5$ flower tiles may be cut, to not raise suspicion among policemen.\n2. Choose the number of days to keep tobacco growing. The number of days must be at most 100 to not make this tobacco business blatantly obvious.\n3. Choose tiles to be harvested after the given number of days pass. At most $10^4$ tiles may be harvested, as any more would take the gangsters too much time.\n\nWill you manage to help the gangsters? Good luck!\n", "inputFormat": "The input contains a single line with an integer $N$ ($0 \\leq N \\leq 10^{18}$), the exact tobacco quantity to be harvested.\n", "outputFormat": "On the first line, print the number $C$ ($0 \\leq C \\leq 2 \\cdot 10^5$) of cut flower tiles. For each such tile, output a line in the form of either $X$ $Y$ $1$ for a cut tile with integer coordinates $(X, Y)$ and with a planted tobacco, or $X$ $Y$ $0$ for a cut tile left as a grass area ($-10^6 \\leq X, Y \\leq 10^6$).\n\nAfterwards print a line with two space-separated numbers $H$ and $D$ ($0 \\leq H \\leq 10^4$, $0 \\leq D \\leq 100$), the number of harvested fields and the number of days for tobacco to grow, respectively. Then print $H$ lines with two space-separated integers $X$ and $Y$ ($-10^6 \\leq X, Y \\leq 10^6$), the coordinates of tiles to be harvested after $D$ days.", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/np0x8jis.png)", "locale": "en", "translations": {"en": {"title": "[CERC 2020] Tobacco Growing", "background": "", "description": "In the city, there is a beautiful park full of blossoming flowers. This park is very popular among citizens and especially families with children are common visitors. The gangsters want to extend their criminal activities to this area, mainly in the tobacco production. They decided to secretly plant tobacco seeds in the park and let it grow right under policemen noses. When the time is right, they plan to harvest as much tobacco as possible in a single operation and smuggle it over borders.\n\nThe park consists of flower tiles with coordinates ranging from $-10^6$ to $10^6$ in either direction. A tile on coordinates $(X, Y)$ neighbors with tiles on coordinates $(X + 1, Y)$, $(X - 1, Y)$, $(X, Y + 1)$ and $(X, Y - 1)$ (within coordinates range). On the first day, the gangsters may cut the flowers on any of the tiles. Also only on the first day, if a tile is cut, the gangsters may either plant a tobacco on it, or let the tile contain only grass. In the beginning, the tobacco quantity on a tile with tobacco is $1$ and the tobacco quantity on a tile with grass or on a tile with flowers is $0$. Local tobacco spreads rather aggressively, and so on each consecutive day, the tobacco quantity on park tiles grows as follows:\n\n- Tobacco quantity on tiles with tobacco and grass is increased by the sum of tobacco quantity on the neighboring tiles on the previous day.\n- Tobacco quantity on tiles with flowers always remains $0$.\n\nAfter some days of growing, the harvest operation will take place on a particular day. The gangsters will choose some of the tiles (of any type) to be harvested and obtain the total tobacco quantity on such tiles on that day. Each tile may be harvested at most once and all tobacco quantity on a chosen tile must be harvested. The gangsters can’t harvest everything, because there is a limit on the tobacco quantity that can be somewhat safely smuggled. At the same time, the gangsters do not want to take any unnecessary losses and so they want to harvest exactly the limit amount.\n\nThe task is to help the gangsters to plan the operation to the very detail. That is in particular:\n\n1. For the first day, choose flower tiles to be cut, and from these choose tiles to plant tobacco on. At most $2 \\cdot 10^5$ flower tiles may be cut, to not raise suspicion among policemen.\n2. Choose the number of days to keep tobacco growing. The number of days must be at most 100 to not make this tobacco business blatantly obvious.\n3. Choose tiles to be harvested after the given number of days pass. At most $10^4$ tiles may be harvested, as any more would take the gangsters too much time.\n\nWill you manage to help the gangsters? Good luck!\n", "inputFormat": "The input contains a single line with an integer $N$ ($0 \\leq N \\leq 10^{18}$), the exact tobacco quantity to be harvested.\n", "outputFormat": "On the first line, print the number $C$ ($0 \\leq C \\leq 2 \\cdot 10^5$) of cut flower tiles. For each such tile, output a line in the form of either $X$ $Y$ $1$ for a cut tile with integer coordinates $(X, Y)$ and with a planted tobacco, or $X$ $Y$ $0$ for a cut tile left as a grass area ($-10^6 \\leq X, Y \\leq 10^6$).\n\nAfterwards print a line with two space-separated numbers $H$ and $D$ ($0 \\leq H \\leq 10^4$, $0 \\leq D \\leq 100$), the number of harvested fields and the number of days for tobacco to grow, respectively. Then print $H$ lines with two space-separated integers $X$ and $Y$ ($-10^6 \\leq X, Y \\leq 10^6$), the coordinates of tiles to be harvested after $D$ days.", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/np0x8jis.png)", "locale": "en"}, "zh-CN": {"title": "[CERC 2020] Tobacco Growing", "background": null, "description": "在城市中，有一个美丽的公园，公园里鲜花盛开。这个公园深受市民喜爱，尤其是有孩子的家庭常常来这里游玩。黑帮分子想要将他们的犯罪活动扩展到这个区域，主要是进行烟草种植。他们决定在公园里偷偷种下烟草种子，让烟草在警察的眼皮底下悄悄生长。当时机成熟时，他们计划在一次行动中尽可能多地收获烟草，并将其走私出境。\n\n公园由若干花坛组成，每个花坛的坐标范围在 $-10^6$ 到 $10^6$ 之间。位于 $(X, Y)$ 的花坛与 $(X + 1, Y)$、$(X - 1, Y)$、$(X, Y + 1)$ 和 $(X, Y - 1)$ 这四个相邻坐标的花坛相邻（前提是这些坐标在范围内）。在第一天，黑帮可以选择任意若干花坛进行割花。并且也只有在第一天，如果一个花坛被割花，黑帮可以选择在该花坛上种植烟草，或者让该花坛只长草。最初，种有烟草的花坛烟草数量为 $1$，而只长草或仍有鲜花的花坛烟草数量为 $0$。当地烟草生长非常迅速，因此在接下来的每一天，公园中各花坛的烟草数量按如下方式增长：\n\n- 对于种有烟草和草地的花坛，其烟草数量会增加为前一天相邻花坛的烟草数量之和。\n- 对于仍有鲜花的花坛，其烟草数量始终为 $0$。\n\n经过若干天的生长后，黑帮将在某一天进行收割。他们可以选择若干花坛（类型不限）进行收割，并获得这些花坛当天的烟草总量。每个花坛最多只能被收割一次，且被选中的花坛上的所有烟草都必须被收割。黑帮不能把所有烟草都收割走，因为能安全走私的烟草数量有限。同时，黑帮也不想有任何不必要的损失，因此他们希望收割的烟草数量恰好等于这个上限。\n\n你的任务是帮助黑帮精确地制定行动计划。具体来说：\n\n1. 在第一天，选择要割花的花坛，并从中选择要种植烟草的花坛。最多只能割 $2 \\times 10^5$ 个花坛，以免引起警察怀疑。\n2. 选择烟草生长的天数。天数最多不能超过 $100$，以免烟草生意过于明显。\n3. 选择在指定天数后要收割的花坛。最多只能收割 $10^4$ 个花坛，否则收割时间太长。\n\n你能帮助黑帮完成计划吗？祝你好运！", "inputFormat": "输入包含一行一个整数 $N$（$0 \\leq N \\leq 10^{18}$），表示需要恰好收割的烟草总量。", "outputFormat": "第一行输出被割花的花坛数量 $C$（$0 \\leq C \\leq 2 \\times 10^5$）。对于每个被割花的花坛，输出一行，格式为 $X\\ Y\\ 1$，表示在整数坐标 $(X, Y)$ 的花坛被割花并种植了烟草，或 $X\\ Y\\ 0$，表示该花坛被割花后只长草（$-10^6 \\leq X, Y \\leq 10^6$）。\n\n接下来输出一行，包含两个用空格分隔的整数 $H$ 和 $D$（$0 \\leq H \\leq 10^4$，$0 \\leq D \\leq 100$），分别表示收割的花坛数量和烟草生长的天数。之后输出 $H$ 行，每行两个用空格分隔的整数 $X$ 和 $Y$（$-10^6 \\leq X, Y \\leq 10^6$），表示在第 $D$ 天后要收割的花坛坐标。", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/np0x8jis.png)\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
