{"pid": "P12427", "type": "P", "difficulty": 5, "samples": [["5\n3 3\n1 2 1\n2 3 2\n3 1 1\n3 3\n2 1 1\n1 3 3\n3 1 2\n2 2\n1 2 2\n1 2 1\n5 6\n1 2 1\n2 3 2\n3 1 1\n1 4 3\n4 5 4\n5 1 3\n4 4\n1 3 4\n3 2 1\n2 3 2\n2 3 2", "NO\nYES\n2 2 3\nNO\nYES\n6 3 4 5 6 1 2\nYES\n4 2 4 2 3"]], "limits": {"time": [4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "Special Judge", "图遍历", "BalticOI（波罗的海）"], "title": "[BalticOI 2025] Tour", "background": "", "description": "There are many tourist attractions in Toruń. Our tour guides prepared a list of $m$ one-way walks connecting $n$ meeting points in the city center. The walks are numbered from 1 to $m$ and similarly the meeting points are numbered from 1 to $n$. Each walk leads from one meeting point to another and allows the participants to see a single attraction on the way. It might be possible to see the same attraction on different walks and there might be multiple walks between the same pair of meeting points. We would like to organise an *interesting tour* on our day off.\n\nA *tour* is a sequence of walks, such that every walk starts at the meeting point where the previous one ends. Furthermore, the last walk ends at the meeting point where the very first walk begins.\n\nWe call such a tour *interesting* if it doesn't contain the same attraction twice in a row. In other words, every two consecutive walks from the tour allow us to see different attractions, and additionally the very first and very last walks from the tour allow us to see different attractions as well. Note that we do not mind if some non-consecutive walks allow us to see the same attraction. In particular, the same walk might be used multiple times on the tour (but not twice in a row).\n\nYour task is to check if it is possible to form an interesting tour, and if so to find one. You can output any interesting tour that consists of at most $m$ walks. It can be proven that if there exists an interesting tour, then there exists one consisting of at most $m$ walks.", "inputFormat": "The first line contains a positive integer $t$ ($1 \\leq t \\leq 5 \\cdot 10^5$) denoting the number of test cases.\n\nThe first line of each test case contains positive integers $n$ and $m$ ($2 \\leq n$, $1 \\leq m$) denoting the number of meeting points and walks, respectively.\n\nEach of the subsequent $m$ lines describes one of the $m$ walks. The $i$-th line contains three positive integers $x_i, y_i$ and $c_i$ ($1 \\leq x_i, y_i \\leq n$, $x_i \\neq y_i$, $1 \\leq c_i \\leq m$), which indicate that the $i$-th walk starts at the meeting point $x_i$, ends at the meeting point $y_i$, and allows us to see the attraction $c_i$.\n\nLet $N$ and $M$ denote the sum of $n$ and $m$, respectively, over all test cases. You can assume that $N, M \\leq 10^6$.", "outputFormat": "For each test case, in the first line you should output YES if it is possible to organise an interesting tour and NO otherwise. In the former case, the second line should first contain a positive integer $k$ ($2 \\leq k \\leq m$) denoting the number of walks forming the interesting tour. This should be followed by $k$ integers $p_1, p_2, \\ldots, p_k$ separated by single spaces. These numbers should describe an interesting tour, where we first follow walk $p_1$, then $p_2$, and so on, and finally we follow walk $p_k$ returning to the original meeting point.", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/9ydu28tk.png)\n\nIllustration of the 4th test case from the example. The arrows represent the walks between meeting points.\n\n### Scoring\n\n| Subtask | Constraints | Points |\n| :---: | :---: | :---: |\n| 1 | $m \\leq 10$ and $t \\leq 100$ | 9 |\n| 2 | $M \\leq 5000$ | 23 |\n| 3 | $M \\leq 5 \\cdot 10^4$ | 19 |\n| 4 | $M \\leq 2 \\cdot 10^5$ | 25 |\n| 5 | No additional constraints. | 24 |", "locale": "en", "translations": {"en": {"title": "[BalticOI 2025] Tour", "background": "", "description": "There are many tourist attractions in Toruń. Our tour guides prepared a list of $m$ one-way walks connecting $n$ meeting points in the city center. The walks are numbered from 1 to $m$ and similarly the meeting points are numbered from 1 to $n$. Each walk leads from one meeting point to another and allows the participants to see a single attraction on the way. It might be possible to see the same attraction on different walks and there might be multiple walks between the same pair of meeting points. We would like to organise an *interesting tour* on our day off.\n\nA *tour* is a sequence of walks, such that every walk starts at the meeting point where the previous one ends. Furthermore, the last walk ends at the meeting point where the very first walk begins.\n\nWe call such a tour *interesting* if it doesn't contain the same attraction twice in a row. In other words, every two consecutive walks from the tour allow us to see different attractions, and additionally the very first and very last walks from the tour allow us to see different attractions as well. Note that we do not mind if some non-consecutive walks allow us to see the same attraction. In particular, the same walk might be used multiple times on the tour (but not twice in a row).\n\nYour task is to check if it is possible to form an interesting tour, and if so to find one. You can output any interesting tour that consists of at most $m$ walks. It can be proven that if there exists an interesting tour, then there exists one consisting of at most $m$ walks.", "inputFormat": "The first line contains a positive integer $t$ ($1 \\leq t \\leq 5 \\cdot 10^5$) denoting the number of test cases.\n\nThe first line of each test case contains positive integers $n$ and $m$ ($2 \\leq n$, $1 \\leq m$) denoting the number of meeting points and walks, respectively.\n\nEach of the subsequent $m$ lines describes one of the $m$ walks. The $i$-th line contains three positive integers $x_i, y_i$ and $c_i$ ($1 \\leq x_i, y_i \\leq n$, $x_i \\neq y_i$, $1 \\leq c_i \\leq m$), which indicate that the $i$-th walk starts at the meeting point $x_i$, ends at the meeting point $y_i$, and allows us to see the attraction $c_i$.\n\nLet $N$ and $M$ denote the sum of $n$ and $m$, respectively, over all test cases. You can assume that $N, M \\leq 10^6$.", "outputFormat": "For each test case, in the first line you should output YES if it is possible to organise an interesting tour and NO otherwise. In the former case, the second line should first contain a positive integer $k$ ($2 \\leq k \\leq m$) denoting the number of walks forming the interesting tour. This should be followed by $k$ integers $p_1, p_2, \\ldots, p_k$ separated by single spaces. These numbers should describe an interesting tour, where we first follow walk $p_1$, then $p_2$, and so on, and finally we follow walk $p_k$ returning to the original meeting point.", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/9ydu28tk.png)\n\nIllustration of the 4th test case from the example. The arrows represent the walks between meeting points.\n\n### Scoring\n\n| Subtask | Constraints | Points |\n| :---: | :---: | :---: |\n| 1 | $m \\leq 10$ and $t \\leq 100$ | 9 |\n| 2 | $M \\leq 5000$ | 23 |\n| 3 | $M \\leq 5 \\cdot 10^4$ | 19 |\n| 4 | $M \\leq 2 \\cdot 10^5$ | 25 |\n| 5 | No additional constraints. | 24 |", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2025] Tour", "background": "", "description": "托伦有许多旅游景点。我们的导游准备了一份包含 $m$ 条单向步行路线的清单，这些路线连接了市中心的 $n$ 个集合点。步行路线编号为 1 到 $m$，集合点编号为 1 到 $n$。每条步行路线从一个集合点出发，到达另一个集合点，途中可以参观一个景点。不同的步行路线可能参观相同的景点，并且同一对集合点之间可能存在多条步行路线。我们希望在休息日组织一次**有趣的游览**。\n\n一次**游览**是指一系列步行路线，其中每条步行路线的起点是前一条步行路线的终点。此外，最后一条步行路线的终点必须是最初第一条步行路线的起点。\n\n如果一次游览中不会连续两次参观相同的景点，则称其为**有趣的游览**。换句话说，游览中任意两条连续的步行路线参观的景点必须不同，并且第一条和最后一条步行路线参观的景点也必须不同。注意，我们不关心非连续的步行路线是否参观相同的景点。特别地，同一条步行路线可以在游览中多次使用（但不能连续使用两次）。\n\n你的任务是判断是否可以组织一次**有趣的游览**，如果可以，则找到一条这样的游览。你可以输出任意一条包含不超过 $m$ 条步行路线的有趣游览。可以证明，如果存在有趣的游览，那么一定存在一条不超过 $m$ 条步行路线的有趣游览。", "inputFormat": "第一行包含一个正整数 $t$（$1 \\leq t \\leq 5 \\cdot 10^5$），表示测试用例的数量。\n\n每个测试用例的第一行包含两个正整数 $n$ 和 $m$（$2 \\leq n$，$1 \\leq m$），分别表示集合点的数量和步行路线的数量。\n\n接下来的 $m$ 行描述了 $m$ 条步行路线。第 $i$ 行包含三个正整数 $x_i$、$y_i$ 和 $c_i$（$1 \\leq x_i, y_i \\leq n$，$x_i \\neq y_i$，$1 \\leq c_i \\leq m$），表示第 $i$ 条步行路线从集合点 $x_i$ 出发，到达集合点 $y_i$，并且参观的景点编号为 $c_i$。\n\n设 $N$ 和 $M$ 分别表示所有测试用例中 $n$ 和 $m$ 的总和。你可以假设 $N, M \\leq 10^6$。", "outputFormat": "对于每个测试用例，第一行输出 YES 表示可以组织有趣的游览，否则输出 NO。如果可以组织，则在第二行首先输出一个正整数 $k$（$2 \\leq k \\leq m$），表示构成有趣游览的步行路线数量。随后输出 $k$ 个用单个空格分隔的整数 $p_1, p_2, \\ldots, p_k$，这些数字描述了一条有趣的游览，其中我们首先走步行路线 $p_1$，然后是 $p_2$，依此类推，最后走步行路线 $p_k$ 回到最初的集合点。", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/9ydu28tk.png)\n\n示例中第 4 个测试用例的图示。箭头表示集合点之间的步行路线。\n\n### 评分\n\n| 子任务 | 限制条件 | 分值 |\n| :---: | :---: | :---: |\n| 1 | $m \\leq 10$ 且 $t \\leq 100$ | 9 |\n| 2 | $M \\leq 5000$ | 23 |\n| 3 | $M \\leq 5 \\cdot 10^4$ | 19 |\n| 4 | $M \\leq 2 \\cdot 10^5$ | 25 |\n| 5 | 无额外限制。 | 24 |\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12428", "type": "P", "difficulty": 7, "samples": [], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000], "memory": [262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2025", "交互题", "Special Judge", "BalticOI（波罗的海）", "Ad-hoc"], "title": "[BalticOI 2025] Tower", "background": "", "description": "There are many legends concerning the Leaning Tower of Toruń. The wall of the tower is a circle with $N \\geq 3$ evenly spaced doors (in other words, the doors are the vertices of a regular $N$-gon). The doors are numbered from 0 to $N - 1$, but in a random order. Please refer to the scoring section for more details about this.\n\nOne of the less known legends describes how every new inhabitant of the tower had to complete a certain challenge. The goal of the challenge was to list the doors, starting with some door and then walking around the circle (clockwise or counterclockwise), visiting each door exactly once.\n\nThis needs to be done without actually seeing the tower. Instead, the new inhabitant can ask questions of the following form: \"Given three distinct doors $x, y, z$, which pairs of doors are the closest to each other: $\\{x, y\\}$, $\\{y, z\\}$, or $\\{z, x\\}$?\". The answer to such a question are all pairs (among $\\{x, y\\}$, $\\{y, z\\}$ and $\\{z, x\\}$) of doors with the smallest Euclidean distance. The distance is simply the length of the shortest segment connecting the doors. Your task is to write a program that will ask a small number of such questions to determine the order of the doors.\n\n### Interaction\n\nThis is an interactive task. You should write a program which finds a correct solution to the task and communicates with the interactor by reading from the standard input and writing to the standard output.\n\nAt the beginning of the interaction, your program should read two integers $t$ and $k$ ($1 \\leq t \\leq 100$, $1 \\leq k \\leq 12\\ 000$) from the standard input, denoting the number of test cases and the maximum allowed average number of queries, respectively. See the scoring section for more information about the latter.\n\nFor each test case, your program should first read a single integer $n$ ($3 \\leq n \\leq 500$) from the standard input, denoting the number of doors in the tower.\n\nThen your program should ask the questions in the following way:\n\n- Your program should write a single line in the form of    \n  $?\\ x\\ y\\ z$    \n  to the standard output, where $x$, $y$, and $z$ are distinct integers ($0 \\leq x, y, z \\leq n - 1$). This line represents a single question concerning doors $x$, $y$, and $z$.\n- The response will be given as:    \n  $r$   \n  $a_1\\ b_1$   \n  $\\vdots$   \n  $a_r\\ b_r$    \n  where $r$ is an integer ($1 \\leq r \\leq 3$) representing the number of pairs of doors with the smallest distance. Each such pair is described by two integers $a_i$ and $b_i$ ($a_i, b_i \\in \\{x, y, z\\}$ and $a_i < b_i$).\n\nOnce you have determined the order of the doors, you should write a single line in the form of\n\n$!\\ x_0\\ x_1\\ \\dots\\ x_{n-1}$\n\nto the standard output, where $x_0, x_1, \\ldots, x_{n-1}$ is the order of the doors as described in the task statement. Please note that there are exactly $2n$ possible correct answers since you can output the order starting from any door and then going in either direction. Any of them will be accepted.\n\n**Keep in mind that after each query or answer you have to flush the output buffer using `cout.flush()` (or `fflush(stdout)` if using `printf`) in C++ or `sys.stdout.flush()` in Python.** Otherwise your program may receive a Time Limit Exceeded verdict.\n\nAfter writing the answer to the interactor, your program should immediately proceed to the next test case or end the interaction if all test cases have been processed.\n\nYour program cannot open any files or use any other resources. It can use the standard error stream for debugging purposes, but please mind that writing to this stream takes time.\n\nPlease also note that the interactor is not adaptive, meaning that the initial order of the doors is fixed beforehand in each test case and does not change during the interaction.", "inputFormat": "See Interation.", "outputFormat": "See Interation.", "hint": "Suppose we have only one test case with $n = 6$, and the order of the doors is $5, 3, 0, 2, 1, 4$. The interaction could look as follows:\n\n| Interactor | Your program | Comment |\n| :---: | :---: | :---: |\n| 1 100 |  | $t=1$ and $k=100$. |\n| 6 |  | Interactor gives the number of doors in the first test case. |\n|  | ? 0 1 2 | Your program asks which pairs of doors are the closest. |\n| 2 |  | Pairs of doors $\\{0,2\\}$ and $\\{1,2\\}$ are the closest. |\n| 0 2 |  |  |\n| 1 2 |  |  |\n|  | ? 4 1 3 | Your program asks which pairs of doors are the closest. |\n| 1 |  | Pair $\\{1,4\\}$ is the closest. |\n| 1 4 |  |  |\n|  | ? 0 5 1 | Your program asks which pairs of doors are the closest. |\n| 3 |  | Pairs $\\{0,5\\},\\{0,1\\}$, and $\\{1,5\\}$ are the closest. |\n| 0 5 |  |  |\n| 0 1 |  |  |\n| 1 5 |  |  |\n|  | ! 4 5 3 0 2 1 | Your program correctly outputs the order of the doors. |\n\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cqzay89h.png)\n\nExplanation of the example: The pictures above show the doors with their numbers along the walls of the tower. In the first picture from the left a triangle formed by the doors with numbers $0, 1, 2$ is shown, corresponding to the first query of your program. We can see that the pairs $\\{0, 2\\}$ and $\\{1, 2\\}$ are the closest. In the middle picture a triangle formed by the doors with numbers $1, 4, 3$ is shown, corresponding to the second query of your program. We can clearly see that the pair $\\{1, 4\\}$ is the closest. In the third picture from the left a triangle formed by the doors with numbers $0, 1, 5$ is shown, corresponding to the third query of your program. We can clearly see that all the pairs of doors are equally close to each other.\n\nPlease note that the sequences $0, 2, 1, 4, 5, 3$ or $5, 4, 1, 2, 0, 3$ (and a couple others) would also be correct answers in this case.\n\n### Scoring\n\nScoring for this problem is divided into subtasks. For each subtask there is exactly one test and this single test contains exactly $t = 100$ test cases. For each test, the average number of queries asked by your program is calculated by taking the total number of queries among all test cases and dividing it by the number of test cases. If this average is greater than $k$ for a given subtask, you will receive a score of $0$ for that subtask. Otherwise, for subtasks $1$ to $4$, you will receive full score for that subtask.\n\nFor the last subtask, your score will be calculated as follows. Let $k^*$ be the actual average number of queries asked by your program. Then, the number of points is given by the following formula:\n\n$$\\left\\lceil 56 \\cdot \\min \\left(1, \\frac{12000 - k^*}{7800}\\right) \\right\\rceil$$\n\nmeaning that your score increases linearly from $0$ to $56$ as $k^*$ goes from $12000$ to $4200$.\n\nPlease note that if your program gives an incorrect answer to any test case, you will receive a score of $0$ for that subtask regardless of the number of queries asked.\n\nThe additional constraints for each subtask are in the table below.\n\n| Subtask | Constraints | Points |\n| :---: | :---: | :---: |\n| 1 | $k = 8000, 3 \\leq n \\leq 9$ | 6 |\n| 2 | $k = 4500, 40 \\leq n \\leq 50$ | 7 |\n| 3 | $k = 3000, 90 \\leq n \\leq 100$ | 9 |\n| 4 | $k = 4500, n = 400$, there is a correct answer $x_0, \\ldots, x_{n-1}$ where $x_i = i$ for $200 \\leq i \\leq 399$ | 22 |\n| 5 | $k = 12000, n = 500$ | up to 56 |\n\nMoreover, you can assume that each test case has been generated by first choosing $n$ **uniformly at random** from all values of $n$ satisfying the constraints of a given subtask, and then choosing the order of the doors **uniformly at random** from all orders of $n$ doors satisfying the constraints of a given subtask.", "locale": "en", "translations": {"en": {"title": "[BalticOI 2025] Tower", "background": "", "description": "There are many legends concerning the Leaning Tower of Toruń. The wall of the tower is a circle with $N \\geq 3$ evenly spaced doors (in other words, the doors are the vertices of a regular $N$-gon). The doors are numbered from 0 to $N - 1$, but in a random order. Please refer to the scoring section for more details about this.\n\nOne of the less known legends describes how every new inhabitant of the tower had to complete a certain challenge. The goal of the challenge was to list the doors, starting with some door and then walking around the circle (clockwise or counterclockwise), visiting each door exactly once.\n\nThis needs to be done without actually seeing the tower. Instead, the new inhabitant can ask questions of the following form: \"Given three distinct doors $x, y, z$, which pairs of doors are the closest to each other: $\\{x, y\\}$, $\\{y, z\\}$, or $\\{z, x\\}$?\". The answer to such a question are all pairs (among $\\{x, y\\}$, $\\{y, z\\}$ and $\\{z, x\\}$) of doors with the smallest Euclidean distance. The distance is simply the length of the shortest segment connecting the doors. Your task is to write a program that will ask a small number of such questions to determine the order of the doors.\n\n### Interaction\n\nThis is an interactive task. You should write a program which finds a correct solution to the task and communicates with the interactor by reading from the standard input and writing to the standard output.\n\nAt the beginning of the interaction, your program should read two integers $t$ and $k$ ($1 \\leq t \\leq 100$, $1 \\leq k \\leq 12\\ 000$) from the standard input, denoting the number of test cases and the maximum allowed average number of queries, respectively. See the scoring section for more information about the latter.\n\nFor each test case, your program should first read a single integer $n$ ($3 \\leq n \\leq 500$) from the standard input, denoting the number of doors in the tower.\n\nThen your program should ask the questions in the following way:\n\n- Your program should write a single line in the form of    \n  $?\\ x\\ y\\ z$    \n  to the standard output, where $x$, $y$, and $z$ are distinct integers ($0 \\leq x, y, z \\leq n - 1$). This line represents a single question concerning doors $x$, $y$, and $z$.\n- The response will be given as:    \n  $r$   \n  $a_1\\ b_1$   \n  $\\vdots$   \n  $a_r\\ b_r$    \n  where $r$ is an integer ($1 \\leq r \\leq 3$) representing the number of pairs of doors with the smallest distance. Each such pair is described by two integers $a_i$ and $b_i$ ($a_i, b_i \\in \\{x, y, z\\}$ and $a_i < b_i$).\n\nOnce you have determined the order of the doors, you should write a single line in the form of\n\n$!\\ x_0\\ x_1\\ \\dots\\ x_{n-1}$\n\nto the standard output, where $x_0, x_1, \\ldots, x_{n-1}$ is the order of the doors as described in the task statement. Please note that there are exactly $2n$ possible correct answers since you can output the order starting from any door and then going in either direction. Any of them will be accepted.\n\n**Keep in mind that after each query or answer you have to flush the output buffer using `cout.flush()` (or `fflush(stdout)` if using `printf`) in C++ or `sys.stdout.flush()` in Python.** Otherwise your program may receive a Time Limit Exceeded verdict.\n\nAfter writing the answer to the interactor, your program should immediately proceed to the next test case or end the interaction if all test cases have been processed.\n\nYour program cannot open any files or use any other resources. It can use the standard error stream for debugging purposes, but please mind that writing to this stream takes time.\n\nPlease also note that the interactor is not adaptive, meaning that the initial order of the doors is fixed beforehand in each test case and does not change during the interaction.", "inputFormat": "See Interation.", "outputFormat": "See Interation.", "hint": "Suppose we have only one test case with $n = 6$, and the order of the doors is $5, 3, 0, 2, 1, 4$. The interaction could look as follows:\n\n| Interactor | Your program | Comment |\n| :---: | :---: | :---: |\n| 1 100 |  | $t=1$ and $k=100$. |\n| 6 |  | Interactor gives the number of doors in the first test case. |\n|  | ? 0 1 2 | Your program asks which pairs of doors are the closest. |\n| 2 |  | Pairs of doors $\\{0,2\\}$ and $\\{1,2\\}$ are the closest. |\n| 0 2 |  |  |\n| 1 2 |  |  |\n|  | ? 4 1 3 | Your program asks which pairs of doors are the closest. |\n| 1 |  | Pair $\\{1,4\\}$ is the closest. |\n| 1 4 |  |  |\n|  | ? 0 5 1 | Your program asks which pairs of doors are the closest. |\n| 3 |  | Pairs $\\{0,5\\},\\{0,1\\}$, and $\\{1,5\\}$ are the closest. |\n| 0 5 |  |  |\n| 0 1 |  |  |\n| 1 5 |  |  |\n|  | ! 4 5 3 0 2 1 | Your program correctly outputs the order of the doors. |\n\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cqzay89h.png)\n\nExplanation of the example: The pictures above show the doors with their numbers along the walls of the tower. In the first picture from the left a triangle formed by the doors with numbers $0, 1, 2$ is shown, corresponding to the first query of your program. We can see that the pairs $\\{0, 2\\}$ and $\\{1, 2\\}$ are the closest. In the middle picture a triangle formed by the doors with numbers $1, 4, 3$ is shown, corresponding to the second query of your program. We can clearly see that the pair $\\{1, 4\\}$ is the closest. In the third picture from the left a triangle formed by the doors with numbers $0, 1, 5$ is shown, corresponding to the third query of your program. We can clearly see that all the pairs of doors are equally close to each other.\n\nPlease note that the sequences $0, 2, 1, 4, 5, 3$ or $5, 4, 1, 2, 0, 3$ (and a couple others) would also be correct answers in this case.\n\n### Scoring\n\nScoring for this problem is divided into subtasks. For each subtask there is exactly one test and this single test contains exactly $t = 100$ test cases. For each test, the average number of queries asked by your program is calculated by taking the total number of queries among all test cases and dividing it by the number of test cases. If this average is greater than $k$ for a given subtask, you will receive a score of $0$ for that subtask. Otherwise, for subtasks $1$ to $4$, you will receive full score for that subtask.\n\nFor the last subtask, your score will be calculated as follows. Let $k^*$ be the actual average number of queries asked by your program. Then, the number of points is given by the following formula:\n\n$$\\left\\lceil 56 \\cdot \\min \\left(1, \\frac{12000 - k^*}{7800}\\right) \\right\\rceil$$\n\nmeaning that your score increases linearly from $0$ to $56$ as $k^*$ goes from $12000$ to $4200$.\n\nPlease note that if your program gives an incorrect answer to any test case, you will receive a score of $0$ for that subtask regardless of the number of queries asked.\n\nThe additional constraints for each subtask are in the table below.\n\n| Subtask | Constraints | Points |\n| :---: | :---: | :---: |\n| 1 | $k = 8000, 3 \\leq n \\leq 9$ | 6 |\n| 2 | $k = 4500, 40 \\leq n \\leq 50$ | 7 |\n| 3 | $k = 3000, 90 \\leq n \\leq 100$ | 9 |\n| 4 | $k = 4500, n = 400$, there is a correct answer $x_0, \\ldots, x_{n-1}$ where $x_i = i$ for $200 \\leq i \\leq 399$ | 22 |\n| 5 | $k = 12000, n = 500$ | up to 56 |\n\nMoreover, you can assume that each test case has been generated by first choosing $n$ **uniformly at random** from all values of $n$ satisfying the constraints of a given subtask, and then choosing the order of the doors **uniformly at random** from all orders of $n$ doors satisfying the constraints of a given subtask.", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2025] Tower", "background": "", "description": "关于托伦斜塔有许多传说。塔的墙壁是一个带有 $N \\geq 3$ 个均匀分布的门（换句话说，这些门构成一个正 $N$ 边形的顶点）的圆形结构。门的编号从 0 到 $N - 1$，但顺序是随机的。更多细节请参考评分部分。\n\n其中一个不太为人所知的传说描述了每位新居民必须完成的挑战。挑战的目标是列出所有门，从某一扇门开始，然后沿着圆形（顺时针或逆时针）行走，恰好访问每扇门一次。\n\n这一过程无法直接观察塔楼，而是需要通过提问来获取信息。每次提问的形式如下：\"给定三扇不同的门 $x$、$y$、$z$，哪对门之间的距离最近：$\\{x, y\\}$、$\\{y, z\\}$ 还是 $\\{z, x\\}$？\"。这类问题的回答将给出所有距离最近的门对（在 $\\{x, y\\}$、$\\{y, z\\}$ 和 $\\{z, x\\}$ 中）。距离是指连接两扇门的最短线段的长度。你的任务是编写一个程序，通过少量此类提问来确定门的排列顺序。\n\n### 交互说明\n\n这是一个交互式任务。你需要编写一个程序，通过与交互器进行标准输入输出的交互来解决问题。\n\n在交互开始时，你的程序应从标准输入读取两个整数 $t$ 和 $k$（$1 \\leq t \\leq 100$，$1 \\leq k \\leq 12000$），分别表示测试用例的数量和允许的平均提问次数上限。更多信息请参考评分部分。\n\n对于每个测试用例，你的程序应首先从标准输入读取一个整数 $n$（$3 \\leq n \\leq 500$），表示塔楼中门的数量。\n\n然后，你的程序可以通过以下方式提问：\n\n- 向标准输出写入一行格式为  \n  $?\\ x\\ y\\ z$  \n  的内容，其中 $x$、$y$ 和 $z$ 是不同的整数（$0 \\leq x, y, z \\leq n - 1$）。这一行表示一个关于门 $x$、$y$ 和 $z$ 的提问。\n- 交互器的响应格式为：  \n  $r$  \n  $a_1\\ b_1$  \n  $\\vdots$  \n  $a_r\\ b_r$  \n  其中 $r$ 是一个整数（$1 \\leq r \\leq 3$），表示距离最近的门对数量。每个门对由两个整数 $a_i$ 和 $b_i$（$a_i, b_i \\in \\{x, y, z\\}$ 且 $a_i < b_i$）描述。\n\n一旦确定了门的顺序，你的程序应向标准输出写入一行格式为\n\n$!\\ x_0\\ x_1\\ \\dots\\ x_{n-1}$\n\n的内容，其中 $x_0, x_1, \\ldots, x_{n-1}$ 是题目描述中要求的门的顺序。注意共有 $2n$ 种可能的正确答案，因为你可以从任意一扇门开始，并按任意方向排列。其中任何一种都会被接受。\n\n**请记住，每次提问或回答后，必须使用 `cout.flush()`（或 `fflush(stdout)`，如果使用 `printf`）或 Python 中的 `sys.stdout.flush()` 刷新输出缓冲区。** 否则你的程序可能会因超时而失败。\n\n在向交互器输出答案后，你的程序应立即处理下一个测试用例，或在所有测试用例处理完毕后结束交互。\n\n你的程序不能打开任何文件或使用其他资源。可以使用标准错误流进行调试，但请注意写入该流会消耗时间。\n\n另外请注意，交互器不是自适应的，即每个测试用例中门的初始顺序在交互开始前已固定，不会在交互过程中改变。", "inputFormat": "参见交互说明。", "outputFormat": "参见交互说明。", "hint": "假设我们只有一个测试用例，$n = 6$，且门的顺序为 $5, 3, 0, 2, 1, 4$。交互过程可能如下：\n\n| 交互器 | 你的程序 | 说明 |\n| :---: | :---: | :---: |\n| 1 100 |  | $t=1$ 且 $k=100$。 |\n| 6 |  | 交互器给出第一个测试用例的门数。 |\n|  | ? 0 1 2 | 你的程序询问哪对门距离最近。 |\n| 2 |  | 门对 $\\{0,2\\}$ 和 $\\{1,2\\}$ 距离最近。 |\n| 0 2 |  |  |\n| 1 2 |  |  |\n|  | ? 4 1 3 | 你的程序询问哪对门距离最近。 |\n| 1 |  | 门对 $\\{1,4\\}$ 距离最近。 |\n| 1 4 |  |  |\n|  | ? 0 5 1 | 你的程序询问哪对门距离最近。 |\n| 3 |  | 门对 $\\{0,5\\}$、$\\{0,1\\}$ 和 $\\{1,5\\}$ 距离最近。 |\n| 0 5 |  |  |\n| 0 1 |  |  |\n| 1 5 |  |  |\n|  | ! 4 5 3 0 2 1 | 你的程序正确输出门的顺序。 |\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cqzay89h.png)\n\n样例解释：上图展示了塔楼墙壁上门的编号。最左边的图片显示了编号为 $0, 1, 2$ 的门形成的三角形，对应你的程序的第一个提问。可以看到，门对 $\\{0, 2\\}$ 和 $\\{1, 2\\}$ 距离最近。中间的图片显示了编号为 $1, 4, 3$ 的门形成的三角形，对应第二个提问。显然，门对 $\\{1, 4\\}$ 距离最近。最右边的图片显示了编号为 $0, 1, 5$ 的门形成的三角形，对应第三个提问。可以看到，所有门对的距离都相等。\n\n注意，序列 $0, 2, 1, 4, 5, 3$ 或 $5, 4, 1, 2, 0, 3$（以及其他几种）在此情况下也是正确答案。\n\n### 评分\n\n本题的评分分为多个子任务。每个子任务仅包含一个测试，该测试包含 $t = 100$ 个测试用例。对于每个测试，你的程序的平均提问次数为所有测试用例的总提问次数除以测试用例数。如果该平均值超过给定子任务的 $k$ 值，则该子任务得分为 $0$。否则，对于子任务 1 至 4，你将获得该子任务的满分。\n\n对于最后一个子任务，你的得分将按以下方式计算。设 $k^*$ 为你的程序实际的平均提问次数，则得分由以下公式给出：\n\n$$\\left\\lceil 56 \\cdot \\min \\left(1, \\frac{12000 - k^*}{7800}\\right) \\right\\rceil$$\n\n这意味着当 $k^*$ 从 12000 降到 4200 时，你的得分将从 0 线性增加到 56。\n\n请注意，如果你的程序在任何测试用例中给出错误答案，无论提问次数多少，该子任务的得分都将为 0。\n\n各子任务的额外约束如下表所示：\n\n| 子任务 | 约束条件 | 分值 |\n| :---: | :---: | :---: |\n| 1 | $k = 8000, 3 \\leq n \\leq 9$ | 6 |\n| 2 | $k = 4500, 40 \\leq n \\leq 50$ | 7 |\n| 3 | $k = 3000, 90 \\leq n \\leq 100$ | 9 |\n| 4 | $k = 4500, n = 400$，存在正确答案 $x_0, \\ldots, x_{n-1}$ 满足 $x_i = i$（$200 \\leq i \\leq 399$） | 22 |\n| 5 | $k = 12000, n = 500$ | 最高 56 |\n\n此外，可以假设每个测试用例的生成方式为：首先从满足子任务约束的所有 $n$ 值中均匀随机选择一个 $n$，然后从满足子任务约束的所有 $n$ 扇门的排列中均匀随机选择一个顺序。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12429", "type": "P", "difficulty": 6, "samples": [["11\n7 2 1 2 5 7 8 8 10 8 8", "5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "BalticOI（波罗的海）"], "title": "[BalticOI 2025] Developer", "background": "", "description": "You are in charge of developing new properties in the suburbs of Toruń. You have already decided that there will be one main street and $n$ properties numbered from 1 to $n$ along the street. The area is somewhat hilly, and the elevation of the $i$-th property is $a_i$ centimetres.\n\nIt turns out that no one wants to buy a property that is on a slope. Formally, for elevations $a_1, a_2, \\ldots, a_n$, a slope is a contiguous subsequence $a_{i-1}, a_i, \\ldots, a_j, a_{j+1}$ with $2 \\leq i \\leq j \\leq n-1$ such that either (i) $a_{i-1} < a_i = a_{i+1} = \\ldots = a_j < a_{j+1}$, or (ii) $a_{i-1} > a_i = a_{i+1} = \\ldots = a_j > a_{j+1}$. Intuitively, a slope is a contiguous range of properties at positions $i-1, i, i+1, \\ldots, j, j+1$, where the elevations of all properties at positions $i, i+1, \\ldots, j$ are equal to some $h$, and $h$ is strictly between $a_{i-1}$ and $a_{j+1}$.\n\nYou are able to increase or decrease the elevation of any property by any integer, but of course you want to minimise the overall effort. Your task is to determine the minimal total change in elevation such that there are no slopes at all. That is, you want to find elevations $b_1, b_2, \\ldots, b_n$ without slopes such that $|a_1 - b_1| + |a_2 - b_2| + \\ldots + |a_n - b_n|$ is as small as possible. The elevations $b_i$ must be integers (in particular, they don't have to be positive), and there are no other constraints on $b_i$.", "inputFormat": "The first line contains an integer $n$ ($1 \\leq n \\leq 2 \\cdot 10^5$) denoting the number of properties along the street.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\leq a_i \\leq 10^9$), where the $i$-th integer $a_i$ is the initial elevation of the $i$-th property.", "outputFormat": "You should output the minimal total change in elevation to ensure that there are no slopes.", "hint": "This is illustrated below. The dashed lines represent the changed elevations without slopes bi of their corresponding properties.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nbh6cd1e.png)\n\n### Scoring\n\n| Subtask | Constraints | Points |\n| :---: | :---: | :---: |\n| 1 | $n \\leq 5$ and $a_i \\leq 10$ | 4 |\n| 2 | $n \\leq 2000$ | 13 |\n| 3 | $a_i \\leq 10$ | 8 |\n| 4 | $a_i < a_{i+1}$ | 19 |\n| 5 | $n \\leq 2 \\cdot 10^4$ | 29 |\n| 6 | No additional constraints. | 27 |\n", "locale": "en", "translations": {"en": {"title": "[BalticOI 2025] Developer", "background": "", "description": "You are in charge of developing new properties in the suburbs of Toruń. You have already decided that there will be one main street and $n$ properties numbered from 1 to $n$ along the street. The area is somewhat hilly, and the elevation of the $i$-th property is $a_i$ centimetres.\n\nIt turns out that no one wants to buy a property that is on a slope. Formally, for elevations $a_1, a_2, \\ldots, a_n$, a slope is a contiguous subsequence $a_{i-1}, a_i, \\ldots, a_j, a_{j+1}$ with $2 \\leq i \\leq j \\leq n-1$ such that either (i) $a_{i-1} < a_i = a_{i+1} = \\ldots = a_j < a_{j+1}$, or (ii) $a_{i-1} > a_i = a_{i+1} = \\ldots = a_j > a_{j+1}$. Intuitively, a slope is a contiguous range of properties at positions $i-1, i, i+1, \\ldots, j, j+1$, where the elevations of all properties at positions $i, i+1, \\ldots, j$ are equal to some $h$, and $h$ is strictly between $a_{i-1}$ and $a_{j+1}$.\n\nYou are able to increase or decrease the elevation of any property by any integer, but of course you want to minimise the overall effort. Your task is to determine the minimal total change in elevation such that there are no slopes at all. That is, you want to find elevations $b_1, b_2, \\ldots, b_n$ without slopes such that $|a_1 - b_1| + |a_2 - b_2| + \\ldots + |a_n - b_n|$ is as small as possible. The elevations $b_i$ must be integers (in particular, they don't have to be positive), and there are no other constraints on $b_i$.", "inputFormat": "The first line contains an integer $n$ ($1 \\leq n \\leq 2 \\cdot 10^5$) denoting the number of properties along the street.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\leq a_i \\leq 10^9$), where the $i$-th integer $a_i$ is the initial elevation of the $i$-th property.", "outputFormat": "You should output the minimal total change in elevation to ensure that there are no slopes.", "hint": "This is illustrated below. The dashed lines represent the changed elevations without slopes bi of their corresponding properties.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nbh6cd1e.png)\n\n### Scoring\n\n| Subtask | Constraints | Points |\n| :---: | :---: | :---: |\n| 1 | $n \\leq 5$ and $a_i \\leq 10$ | 4 |\n| 2 | $n \\leq 2000$ | 13 |\n| 3 | $a_i \\leq 10$ | 8 |\n| 4 | $a_i < a_{i+1}$ | 19 |\n| 5 | $n \\leq 2 \\cdot 10^4$ | 29 |\n| 6 | No additional constraints. | 27 |\n", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2025] Developer", "background": "", "description": "你负责在托伦郊区开发新的房产。你已经决定将建造一条主干道和沿街的 $n$ 处房产，编号从 1 到 $n$。该地区地势略有起伏，第 $i$ 处房产的海拔高度为 $a_i$ 厘米。\n\n事实证明，没有人愿意购买位于斜坡上的房产。形式化地说，对于海拔高度序列 $a_1, a_2, \\ldots, a_n$，一个斜坡是指满足以下条件的连续子序列 $a_{i-1}, a_i, \\ldots, a_j, a_{j+1}$（其中 $2 \\leq i \\leq j \\leq n-1$）：\n1. $a_{i-1} < a_i = a_{i+1} = \\ldots = a_j < a_{j+1}$，或者\n2. $a_{i-1} > a_i = a_{i+1} = \\ldots = a_j > a_{j+1}$。\n\n直观地说，一个斜坡是指位置 $i-1, i, i+1, \\ldots, j, j+1$ 上的连续房产区域，其中位置 $i, i+1, \\ldots, j$ 的所有房产海拔高度都等于某个值 $h$，且 $h$ 严格位于 $a_{i-1}$ 和 $a_{j+1}$ 之间。\n\n你可以任意增加或减少任何房产的海拔高度（以整数为单位调整），但当然你希望尽量减少总工作量。你的任务是确定消除所有斜坡所需的最小总海拔变化量。也就是说，你需要找到一组不存在斜坡的海拔高度 $b_1, b_2, \\ldots, b_n$，使得 $|a_1 - b_1| + |a_2 - b_2| + \\ldots + |a_n - b_n|$ 尽可能小。调整后的海拔高度 $b_i$ 必须是整数（特别地，它们不一定要是正数），且对 $b_i$ 没有其他约束。", "inputFormat": "第一行包含一个整数 $n$（$1 \\leq n \\leq 2 \\cdot 10^5$），表示沿街房产的数量。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\ldots, a_n$（$0 \\leq a_i \\leq 10^9$），其中第 $i$ 个整数 $a_i$ 表示第 $i$ 处房产的初始海拔高度。", "outputFormat": "输出消除所有斜坡所需的最小总海拔变化量。", "hint": "如下图所示。虚线表示调整后的无斜坡海拔高度 $b_i$ 与其对应房产的关系。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nbh6cd1e.png)\n\n### 评分\n\n| 子任务 | 限制条件 | 分值 |\n| :---: | :---: | :---: |\n| 1 | $n \\leq 5$ 且 $a_i \\leq 10$ | 4 |\n| 2 | $n \\leq 2000$ | 13 |\n| 3 | $a_i \\leq 10$ | 8 |\n| 4 | $a_i < a_{i+1}$ | 19 |\n| 5 | $n \\leq 2 \\cdot 10^4$ | 29 |\n| 6 | 无额外限制。 | 27 |\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12430", "type": "P", "difficulty": 6, "samples": [["8 4\n2 4 2 5 4 4 4 5\n4 8\n1 4\n2 5\n1 7", "7\n7\n7\n8"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "BalticOI（波罗的海）"], "title": "[BalticOI 2025] Exponents", "background": "", "description": "The famous polymath Nicolaus Copernicus was born and grew up in Toruń in the 15th century. Archaeologists have recently discovered his notebook, and learned that he was fond of using powers of two to store large numbers. In particular, even when he added two powers of two:\n\n$$2^a + 2^b$$\n\nCopernicus evaluated the result and then rounded up the result to the nearest power of two. That is, he would evaluate $2^a + 2^b$ to $2^{\\max(a,b)+1}$. To evaluate a longer expression of the form:\n\n$$2^{b_1}+2^{b_2}+\\cdots + 2^{b_r}$$\n\nhe first inserted the brackets to make it well - parenthesised*. For example, an expression $2^5 + 2^4+2^4 + 2^4+2^5$ can be made well - parenthesised to obtain $((2^5 + 2^4)+(2^4+(2^4 + 2^5)))$. Finally, he evaluated the result of the obtained well - parenthesised expression, operating on powers of two as described above. Notice that the result might vary depending on how he inserts the brackets. For example, here are two possible ways to evaluate $2^5 + 2^4+2^4 + 2^4+2^5$:\n\n$((2^5 + 2^4)+(2^4 + 2^5))=((2^6+2^4)+2^5)=(2^7 + 2^6)=2^8$\n\n$((2^5+(2^4 + 2^4))+(2^4 + 2^5))=((2^5 + 2^5)+2^6)=(2^6+2^6)=2^7$\n\nThe first page of the Copernicus' notebook contains only a single expression $2^{a_1}+2^{a_2}+\\cdots + 2^{a_n}$ called the main expression. Later pages of the notebook then reference fragments of the main expression, which are of the form $2^{a_\\ell}+2^{a_{\\ell + 1}}+\\cdots + 2^{a_r}$, for some $1\\leq \\ell\\leq r\\leq n$.\n\nYou are not sure what their meaning, but suspect that you should calculate, for each such fragment, the smallest possible result that can be obtained when evaluating the result as described above for the fragment. Note that each fragment is evaluated independently of the other fragments.", "inputFormat": "The first line contains two integers $n$ and $q$ ($1\\leq n,q\\leq300000$) denoting the length of the main expression from the first page of the notebook and the number of queries, respectively.\n\nThe second line contains $n$ integers $a_1,a_2,\\cdots,a_n$ ($0\\leq a_i\\leq 10^9$), where the $i$ - th integer $a_i$ denotes the exponent of the $i$ - th power of two in the main expression.\n\nThe next $q$ lines describe the queries. Each query consists of two integers $\\ell$ and $r$ ($1\\leq \\ell\\leq r\\leq n$) representing a fragment of the main expression starting at the $\\ell$ - th power of two and ending at the $r$ - th power of two.", "outputFormat": "You should output $q$ lines. The $i$ - th line should contain the smallest possible result that can be obtained when evaluating the fragment described in the $i$ - th query. You should output only the exponent of the corresponding power of two.", "hint": "| Subtasks | Constrains | Score |\n| :---: | :---: | :---: |\n| 1 | $n \\leq 8, q \\leq 10$ | 6 |\n| 2 | $n \\leq 200$ | 8 |\n| 3 | $n, q \\leq 2000$ | 23 |\n| 4 | $a_{i} \\leq 20$ | 22 |\n| 5 | No addition constrains | 41 |", "locale": "en", "translations": {"en": {"title": "[BalticOI 2025] Exponents", "background": "", "description": "The famous polymath Nicolaus Copernicus was born and grew up in Toruń in the 15th century. Archaeologists have recently discovered his notebook, and learned that he was fond of using powers of two to store large numbers. In particular, even when he added two powers of two:\n\n$$2^a + 2^b$$\n\nCopernicus evaluated the result and then rounded up the result to the nearest power of two. That is, he would evaluate $2^a + 2^b$ to $2^{\\max(a,b)+1}$. To evaluate a longer expression of the form:\n\n$$2^{b_1}+2^{b_2}+\\cdots + 2^{b_r}$$\n\nhe first inserted the brackets to make it well - parenthesised*. For example, an expression $2^5 + 2^4+2^4 + 2^4+2^5$ can be made well - parenthesised to obtain $((2^5 + 2^4)+(2^4+(2^4 + 2^5)))$. Finally, he evaluated the result of the obtained well - parenthesised expression, operating on powers of two as described above. Notice that the result might vary depending on how he inserts the brackets. For example, here are two possible ways to evaluate $2^5 + 2^4+2^4 + 2^4+2^5$:\n\n$((2^5 + 2^4)+(2^4 + 2^5))=((2^6+2^4)+2^5)=(2^7 + 2^6)=2^8$\n\n$((2^5+(2^4 + 2^4))+(2^4 + 2^5))=((2^5 + 2^5)+2^6)=(2^6+2^6)=2^7$\n\nThe first page of the Copernicus' notebook contains only a single expression $2^{a_1}+2^{a_2}+\\cdots + 2^{a_n}$ called the main expression. Later pages of the notebook then reference fragments of the main expression, which are of the form $2^{a_\\ell}+2^{a_{\\ell + 1}}+\\cdots + 2^{a_r}$, for some $1\\leq \\ell\\leq r\\leq n$.\n\nYou are not sure what their meaning, but suspect that you should calculate, for each such fragment, the smallest possible result that can be obtained when evaluating the result as described above for the fragment. Note that each fragment is evaluated independently of the other fragments.", "inputFormat": "The first line contains two integers $n$ and $q$ ($1\\leq n,q\\leq300000$) denoting the length of the main expression from the first page of the notebook and the number of queries, respectively.\n\nThe second line contains $n$ integers $a_1,a_2,\\cdots,a_n$ ($0\\leq a_i\\leq 10^9$), where the $i$ - th integer $a_i$ denotes the exponent of the $i$ - th power of two in the main expression.\n\nThe next $q$ lines describe the queries. Each query consists of two integers $\\ell$ and $r$ ($1\\leq \\ell\\leq r\\leq n$) representing a fragment of the main expression starting at the $\\ell$ - th power of two and ending at the $r$ - th power of two.", "outputFormat": "You should output $q$ lines. The $i$ - th line should contain the smallest possible result that can be obtained when evaluating the fragment described in the $i$ - th query. You should output only the exponent of the corresponding power of two.", "hint": "| Subtasks | Constrains | Score |\n| :---: | :---: | :---: |\n| 1 | $n \\leq 8, q \\leq 10$ | 6 |\n| 2 | $n \\leq 200$ | 8 |\n| 3 | $n, q \\leq 2000$ | 23 |\n| 4 | $a_{i} \\leq 20$ | 22 |\n| 5 | No addition constrains | 41 |", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2025] Exponents", "background": null, "description": "著名博学家尼古拉·哥白尼于 15 世纪在托伦出生并长大。考古学家最近发现了他的笔记本，了解到他喜欢用 2 的幂次来存储大数。特别是，当他将两个 2 的幂次相加时：\n\n$$2^{a}+2^{b}$$\n\n哥白尼会先计算结果，然后将结果向上舍入到最近的 2 的幂次。也就是说，他会将 $2^{a}+2^{b}$ 计算为 $2^{\\max(a, b)+1}$。对于更长的表达式：\n\n$$2^{b_{1}}+2^{b_{2}}+\\ldots+2^{b_{k}}$$\n\n他会先插入括号使其成为良好括号化表达式$\\text{*}$。例如，表达式 $2^{5}+2^{4}+2^{4}+2^{4}+2^{5}$ 可以通过插入括号变为 $((2^{5}+2^{4})+(2^{4}+(2^{4}+2^{5})))$。最后，他按照上述方式计算这个良好括号化表达式的结果。注意，计算结果可能因括号插入方式的不同而有所变化。例如，以下是两种可能的计算方式：\n\n$$((2^{5}+2^{4})+2^{4})+(2^{4}+2^{5}))=((2^{6}+2^{4})+2^{6})=(2^{7}+2^{6})=2^{8} \\\\((2^{5}+(2^{4}+2^{4}))+(2^{4}+2^{5}))=((2^{5}+2^{5})+2^{6})=(2^{6}+2^{6})=2^{7}$$\n\n哥白尼笔记本的第一页仅包含一个称为**主表达式**的表达式 $2^{a_{1}}+2^{a_{2}}+\\ldots+2^{a_{n}}$。笔记本后面的页面引用了主表达式的片段，这些片段的格式为 $2^{a_{\\ell}}+2^{a_{\\ell+1}}+\\ldots+2^{a_{r}}$，其中 $1 \\leq \\ell \\leq r \\leq n$。\n\n你不确定这些片段的含义，但怀疑应该为每个片段计算其可能的最小结果（按照上述方式计算）。注意，每个片段是独立于其他片段计算的。\n\n$\\text{*}$关于“良好括号化表达式”的形式化定义如下：对于任意非负整数 $a$，$2^{a}$ 是一个良好括号化表达式；如果 $E_{1}$ 和 $E_{2}$ 都是良好括号化表达式，那么 $(E_{1} + E_{2})$ 也是良好括号化表达式。除此之外没有其他形式的良好括号化表达式。", "inputFormat": "第一行包含两个整数 $n$ 和 $q$（$1 \\leq n, q \\leq 300000$），分别表示笔记本第一页主表达式的长度和查询的数量。\n\n第二行包含 $n$ 个整数 $a_{1}, a_{2}, \\ldots, a_{n}$（$0 \\leq a_{i} \\leq 10^{6}$），其中第 $i$ 个整数 $a_{i}$ 表示主表达式中第 $i$ 个 2 的幂次的指数。\n\n接下来的 $q$ 行描述查询。每个查询包含两个整数 $\\ell$ 和 $r$（$1 \\leq \\ell \\leq r \\leq n$），表示主表达式中从第 $\\ell$ 个 2 的幂次到第 $r$ 个 2 的幂次的片段。", "outputFormat": "输出 $q$ 行。第 $i$ 行应包含第 $i$ 个查询描述的片段可能计算得到的最小结果。只需输出对应的 2 的幂次的指数。", "hint": "### 评分\n\n| 子任务 | 限制条件 | 分值 |\n| :---: | :---: | :---: |\n| 1 | $n \\leq 8, q \\leq 10$ | 6 |\n| 2 | $n \\leq 200$ | 8 |\n| 3 | $n, q \\leq 2000$ | 23 |\n| 4 | $a_{i} \\leq 20$ | 22 |\n| 5 | 无额外限制。 | 41 |\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12431", "type": "P", "difficulty": 5, "samples": [["3\n90 84 140", "2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2025", "BalticOI（波罗的海）"], "title": "[BalticOI 2025] Gingerbread", "background": "", "description": "Toruń has been known for its traditional gingerbread since the Middle Ages. Young Nicolaus would like to buy a set of $n$ boxes with gingerbread cookies in his favourite shop. The shop has very strict rules, though: Nicolaus initially obtains $n$ boxes that are already filled with cookies: the $i$-th box initially contains $a_{i}$ of them. Then, Nicolaus can order some extra cookies. He adds extra cookies to some boxes so that the greatest common divisor$\\text{*}$ of the numbers of cookies in all of the boxes becomes equal to 1. It can be proven that this is always possible.\n\nHelp Nicolaus by calculating the smallest number of cookies that need to be added in order to make the greatest common divisor of all the numbers equal to 1.\n\n$\\text{*}$ The greatest common divisor (GCD) of multiple numbers is the largest positive integer that divides all of them without\nremainder.", "inputFormat": "The first line contains an integer $n\\ (2 \\leq n \\leq 10^6)$, denoting the number of boxes.\n\nThe second line contains $n$ integers $a_{1}, a_{2}, \\ldots, a_{n}\\ (1 \\leq a_{i} \\leq 10^7)$, where the $i$-th integer $a_{i}$ denotes the initial number of cookies in the $i$-th box.", "outputFormat": "Output one line with a single integer denoting the smallest number of cookies that Nicolaus should add to the boxes. If Nicolaus doesn't have to add any cookies to make the greatest common divisor of the numbers equal to 1, output 0.", "hint": "Explanation of the example: Indeed, the greatest common divisor (GCD) of 90, 84, and 140 is 2, so some cookies must be added. If we add only one cookie, we may obtain the quantities 91, 84, 140 with GCD of 7, or 90, 85, 140 with GCD of 5, or 90, 84, 141 with GCD of 3, so this is not enough. After adding two cookies, one to the first box, and one to the second box, we obtain the quantities 91, 85, 140 with GCD of 1; hence the answer is 2. Note that adding both cookies to the first box does not help: we obtain quantities 92, 84, 140 with GCD of 4.\n\n### Scoring\n\n| Subtask | Constraints | Points |\n| :---: | :---: | :---: |\n| 1 | $n=2$ | 17 |\n| 2 | $n \\leq 10$ | 34 |\n| 3 | $n \\leq 1000$ | 11 |\n| 4 | No additional constraints. | 38 |\n", "locale": "en", "translations": {"en": {"title": "[BalticOI 2025] Gingerbread", "background": "", "description": "Toruń has been known for its traditional gingerbread since the Middle Ages. Young Nicolaus would like to buy a set of $n$ boxes with gingerbread cookies in his favourite shop. The shop has very strict rules, though: Nicolaus initially obtains $n$ boxes that are already filled with cookies: the $i$-th box initially contains $a_{i}$ of them. Then, Nicolaus can order some extra cookies. He adds extra cookies to some boxes so that the greatest common divisor$\\text{*}$ of the numbers of cookies in all of the boxes becomes equal to 1. It can be proven that this is always possible.\n\nHelp Nicolaus by calculating the smallest number of cookies that need to be added in order to make the greatest common divisor of all the numbers equal to 1.\n\n$\\text{*}$ The greatest common divisor (GCD) of multiple numbers is the largest positive integer that divides all of them without\nremainder.", "inputFormat": "The first line contains an integer $n\\ (2 \\leq n \\leq 10^6)$, denoting the number of boxes.\n\nThe second line contains $n$ integers $a_{1}, a_{2}, \\ldots, a_{n}\\ (1 \\leq a_{i} \\leq 10^7)$, where the $i$-th integer $a_{i}$ denotes the initial number of cookies in the $i$-th box.", "outputFormat": "Output one line with a single integer denoting the smallest number of cookies that Nicolaus should add to the boxes. If Nicolaus doesn't have to add any cookies to make the greatest common divisor of the numbers equal to 1, output 0.", "hint": "Explanation of the example: Indeed, the greatest common divisor (GCD) of 90, 84, and 140 is 2, so some cookies must be added. If we add only one cookie, we may obtain the quantities 91, 84, 140 with GCD of 7, or 90, 85, 140 with GCD of 5, or 90, 84, 141 with GCD of 3, so this is not enough. After adding two cookies, one to the first box, and one to the second box, we obtain the quantities 91, 85, 140 with GCD of 1; hence the answer is 2. Note that adding both cookies to the first box does not help: we obtain quantities 92, 84, 140 with GCD of 4.\n\n### Scoring\n\n| Subtask | Constraints | Points |\n| :---: | :---: | :---: |\n| 1 | $n=2$ | 17 |\n| 2 | $n \\leq 10$ | 34 |\n| 3 | $n \\leq 1000$ | 11 |\n| 4 | No additional constraints. | 38 |\n", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2025] Gingerbread", "background": "", "description": "托伦自中世纪以来就以传统姜饼闻名。年轻的尼古拉斯想在他最喜欢的商店购买一套装有姜饼饼干的 $n$ 个盒子。不过这家店有非常严格的规定：尼古拉斯最初会得到 $n$ 个已经装有饼干的盒子，其中第 $i$ 个盒子初始装有 $a_{i}$ 块饼干。然后，尼古拉斯可以订购一些额外的饼干。他需要向某些盒子中添加额外的饼干，使得所有盒子中饼干数量的最大公约数$\\text{*}$等于 1。可以证明这总是可行的。\n\n请帮助尼古拉斯计算出，为了使所有饼干数量的最大公约数等于 1，需要添加的最少饼干数量。\n\n$\\text{*}$ 多个数的最大公约数（GCD）是指能整除所有这些数的最大正整数。", "inputFormat": "第一行包含一个整数 $n$（$2 \\leq n \\leq 10^6$），表示盒子的数量。\n\n第二行包含 $n$ 个整数 $a_{1}, a_{2}, \\ldots, a_{n}$（$1 \\leq a_{i} \\leq 10^7$），其中第 $i$ 个整数 $a_{i}$ 表示第 $i$ 个盒子初始的饼干数量。", "outputFormat": "输出一行，包含一个整数，表示尼古拉斯需要添加的最少饼干数量。如果不需要添加任何饼干就能使所有饼干数量的最大公约数等于 1，则输出 0。\n", "hint": "样例解释：初始时 90、84 和 140 的最大公约数是 2，因此必须添加饼干。如果只添加 1 块饼干，可能得到 91、84、140（GCD 为 7），或 90、85、140（GCD 为 5），或 90、84、141（GCD 为 3），这些都不满足要求。添加 2 块饼干（分别加到第一个和第二个盒子）后，得到 91、85、140，其 GCD 为 1，因此答案是 2。注意，如果将两块饼干都加到第一个盒子，会得到 92、84、140（GCD 为 4），这仍然不符合要求。\n\n### 评分\n\n| 子任务 | 限制条件 | 分值 |\n| :---: | :---: | :---: |\n| 1 | $n=2$ | 17 |\n| 2 | $n \\leq 10$ | 34 |\n| 3 | $n \\leq 1000$ | 11 |\n| 4 | 无额外限制。 | 38 |\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12432", "type": "P", "difficulty": 4, "samples": [["1 3\n2 -1 2\n2 -2 3\n2 -3 4", "4"], ["1 2\n3 -1 -1 4\n4 1 -3 -4 8", "4"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "ICPC", "NERC/NEERC"], "title": "[NERC2023] Accumulator Apex", "background": "", "description": "Allyn is playing a new strategy game called `Accumulator Apex`. In this game, Allyn is given the initial value of an integer $x$, referred to as the accumulator, and $k$ lists of integers. Allyn can make multiple turns. On each turn, Allyn can withdraw the leftmost element from any non-empty list and add it to the accumulator $x$ if the resulting $x$ is non-negative. Allyn can end the game at any moment. The goal of the game is to get the largest possible value of the accumulator $x$. Please help Allyn find the largest possible value of the accumulator $x$ they can get in this game.", "inputFormat": "The first line of the input contains two integers $x$ and $k$ ($0 \\leq x \\leq 10^9, 1 \\leq k \\leq 10^5$) --- the initial value of the accumulator $x$ and the number of lists. The next $k$ lines contain the description of lists: an integer $l_i$ ($l_i \\ge 1$) followed on the same line by $l_i$ elements of the list in the order from left to right. Each element of lists does not exceed $10^9$ by the absolute value, and the total size of all lists does not exceed $10^5$.", "outputFormat": "The sole line of the output should contain the largest value of the accumulator $x$ Allyn can get.", "hint": "In the first input, we start with $x = 1$. Then, we can take the first integer from the first list and get $x = 0$ --- adding the next integer $2$ from the first list we get $x = 2$. After that, we can add the integers from the second list and obtain $x = 3$. Finally, we can add the integers from the third list and obtain $x = 4$.\n\nIn the second input, we can add the first integer from the second list and get $x = 2$. Then, by adding the elements from the first list, we get $x = 4$. We cannot add more integers to increase $x$.", "locale": "en", "translations": {"en": {"title": "[NERC2023] Accumulator Apex", "background": "", "description": "Allyn is playing a new strategy game called `Accumulator Apex`. In this game, Allyn is given the initial value of an integer $x$, referred to as the accumulator, and $k$ lists of integers. Allyn can make multiple turns. On each turn, Allyn can withdraw the leftmost element from any non-empty list and add it to the accumulator $x$ if the resulting $x$ is non-negative. Allyn can end the game at any moment. The goal of the game is to get the largest possible value of the accumulator $x$. Please help Allyn find the largest possible value of the accumulator $x$ they can get in this game.", "inputFormat": "The first line of the input contains two integers $x$ and $k$ ($0 \\leq x \\leq 10^9, 1 \\leq k \\leq 10^5$) --- the initial value of the accumulator $x$ and the number of lists. The next $k$ lines contain the description of lists: an integer $l_i$ ($l_i \\ge 1$) followed on the same line by $l_i$ elements of the list in the order from left to right. Each element of lists does not exceed $10^9$ by the absolute value, and the total size of all lists does not exceed $10^5$.", "outputFormat": "The sole line of the output should contain the largest value of the accumulator $x$ Allyn can get.", "hint": "In the first input, we start with $x = 1$. Then, we can take the first integer from the first list and get $x = 0$ --- adding the next integer $2$ from the first list we get $x = 2$. After that, we can add the integers from the second list and obtain $x = 3$. Finally, we can add the integers from the third list and obtain $x = 4$.\n\nIn the second input, we can add the first integer from the second list and get $x = 2$. Then, by adding the elements from the first list, we get $x = 4$. We cannot add more integers to increase $x$.", "locale": "en"}, "zh-CN": {"title": "[NERC2023] Accumulator Apex", "background": "", "description": "Allyn 正在玩一款名为 `Accumulator Apex` 的新策略游戏。在游戏中，Allyn 会获得一个整数 $x$ 的初始值（称为累加器）和 $k$ 个整数列表。Allyn 可以进行多轮操作。在每一轮中，Allyn 可以从任意一个非空列表中取出最左侧的元素，并将其加到累加器 $x$ 中，前提是操作后的 $x$ 为非负数。Allyn 可以随时结束游戏。游戏的目标是让累加器 $x$ 的值尽可能大。请帮助 Allyn 找出他们在这场游戏中能获得的最大累加器值 $x$。", "inputFormat": "输入的第一行包含两个整数 $x$ 和 $k$（$0 \\leq x \\leq 10^9, 1 \\leq k \\leq 10^5$）——分别是累加器 $x$ 的初始值和列表的数量。接下来的 $k$ 行描述了这些列表：每行首先是一个整数 $l_i$（$l_i \\ge 1$），随后是 $l_i$ 个按从左到右顺序排列的列表元素。列表中的每个元素的绝对值不超过 $10^9$，且所有列表的总大小不超过 $10^5$。", "outputFormat": "输出的唯一一行应包含 Allyn 能获得的最大累加器值 $x$。\n", "hint": "在第一个输入样例中，初始时 $x = 1$。我们可以从第一个列表中取出第一个整数，得到 $x = 0$——接着从第一个列表中取出下一个整数 $2$，得到 $x = 2$。之后，我们可以从第二个列表中取出整数，得到 $x = 3$。最后，从第三个列表中取出整数，得到 $x = 4$。\n\n在第二个输入样例中，我们可以从第二个列表中取出第一个整数，得到 $x = 2$。然后，从第一个列表中取出元素，得到 $x = 4$。此时无法再通过添加更多整数来增加 $x$ 的值。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12433", "type": "P", "difficulty": 4, "samples": [["8\n4 1\n3 2\n4 2\n5 2\n6 1\n6 2\n1000000000 1\n9 2", "2 1\n0 1\n0 1\n1 3\n6 1\n2 4\n249999999500000000 1\n6 3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "ICPC", "NERC/NEERC"], "title": "[NERC2023] Blueprint for Seating", "background": "", "description": "An aircraft manufacturing company wants to optimize their products for passenger airlines. The company's latest research shows that most of the delays happen because of slow boarding.\n\nMost of the medium-sized aircraft are designed with 3-3 seat layout, meaning each row has 6 seats: 3 seats on the left side, a single aisle, and 3 seats on the right side. At each of the left and right sides there is a window seat, a middle seat, and an aisle seat. A passenger that boards an aircraft assigned to an aisle seat takes significantly less time than a passenger assigned to a window seat even when there is no one else in the aircraft.\n\nThe company decided to compute an  _inconvenience_  of a layout as the total sum of distances from each of the seats of a single row to the closest aisle. The distance from a seat to an aisle is the number of seats between them. For a 3-3 layout, a window seat has a distance of 2, a middle seat --- 1, and an aisle seat --- 0. The inconvenience of a 3-3 layout is $(2+1+0)+(0+1+2)=6$. The inconvenience of a 3-5-3 layout is $(2+1+0)+(0+1+2+1+0)+(0+1+2)=10$.\n\nFormally, a layout is a sequence of positive integers $a_1, a_2, \\ldots, a_{k+1}$ --- group $i$ having $a_i$ seats, with $k$ aisles between groups, the $i$-th aisle being between groups $i$ and $i+1$. This means that in a layout each aisle must always be between two seats, so no aisle can be next to a window, and no two aisles can be next to each other.\n\nThe company decided to design a layout with a row of $n$ seats, $k$ aisles and having the minimum inconvenience possible. Help them find the minimum inconvenience among all layouts of $n$ seats and $k$ aisles, and count the number of such layouts modulo $998\\,244\\,353$. Two layouts are different if their corresponding sequences are different.", "inputFormat": "The first line contains an integer $t$ --- the number of test cases you need to solve ($1 \\le t \\le 10^5$).\n\nFor each of the test cases, there is a single line containing $n$ and $k$ --- the number of seats, and the number of aisles in a row ($2 \\le n \\le 10^9$; $1 \\le k \\le 10^5$; $k < n$).\n\nThe total sum of $k$ in all $t$ given test cases does not exceed $10^6$.", "outputFormat": "For each test case print two integers --- the minimum inconvenience among all possible layouts, and the number of layouts with the minimum inconvenience modulo $998\\,244\\,353$.", "hint": "In the last test case of $\\texttt{9 2}$ the possible layouts with the minimum inconvenience of 6 are 3-4-2, 2-4-3, and 2-5-2.", "locale": "en", "translations": {"en": {"title": "[NERC2023] Blueprint for Seating", "background": "", "description": "An aircraft manufacturing company wants to optimize their products for passenger airlines. The company's latest research shows that most of the delays happen because of slow boarding.\n\nMost of the medium-sized aircraft are designed with 3-3 seat layout, meaning each row has 6 seats: 3 seats on the left side, a single aisle, and 3 seats on the right side. At each of the left and right sides there is a window seat, a middle seat, and an aisle seat. A passenger that boards an aircraft assigned to an aisle seat takes significantly less time than a passenger assigned to a window seat even when there is no one else in the aircraft.\n\nThe company decided to compute an  _inconvenience_  of a layout as the total sum of distances from each of the seats of a single row to the closest aisle. The distance from a seat to an aisle is the number of seats between them. For a 3-3 layout, a window seat has a distance of 2, a middle seat --- 1, and an aisle seat --- 0. The inconvenience of a 3-3 layout is $(2+1+0)+(0+1+2)=6$. The inconvenience of a 3-5-3 layout is $(2+1+0)+(0+1+2+1+0)+(0+1+2)=10$.\n\nFormally, a layout is a sequence of positive integers $a_1, a_2, \\ldots, a_{k+1}$ --- group $i$ having $a_i$ seats, with $k$ aisles between groups, the $i$-th aisle being between groups $i$ and $i+1$. This means that in a layout each aisle must always be between two seats, so no aisle can be next to a window, and no two aisles can be next to each other.\n\nThe company decided to design a layout with a row of $n$ seats, $k$ aisles and having the minimum inconvenience possible. Help them find the minimum inconvenience among all layouts of $n$ seats and $k$ aisles, and count the number of such layouts modulo $998\\,244\\,353$. Two layouts are different if their corresponding sequences are different.", "inputFormat": "The first line contains an integer $t$ --- the number of test cases you need to solve ($1 \\le t \\le 10^5$).\n\nFor each of the test cases, there is a single line containing $n$ and $k$ --- the number of seats, and the number of aisles in a row ($2 \\le n \\le 10^9$; $1 \\le k \\le 10^5$; $k < n$).\n\nThe total sum of $k$ in all $t$ given test cases does not exceed $10^6$.", "outputFormat": "For each test case print two integers --- the minimum inconvenience among all possible layouts, and the number of layouts with the minimum inconvenience modulo $998\\,244\\,353$.", "hint": "In the last test case of $\\texttt{9 2}$ the possible layouts with the minimum inconvenience of 6 are 3-4-2, 2-4-3, and 2-5-2.", "locale": "en"}, "zh-CN": {"title": "[NERC2023] Blueprint for Seating", "background": "", "description": "一家飞机制造公司希望优化其客机产品。公司最新研究表明，大多数延误是由于登机速度过慢造成的。\n\n大多数中型客机采用 3-3 座位布局设计，即每排有 6 个座位：左侧 3 个座位、一条过道和右侧 3 个座位。在左右两侧各有一个靠窗座位、一个中间座位和一个靠过道座位。当飞机上没有其他乘客时，被分配到靠过道座位的乘客登机所用时间明显少于靠窗座位的乘客。\n\n公司决定将布局的**不便值**定义为单排每个座位到最近过道的距离之和。座位到过道的距离指两者之间的座位数量。对于 3-3 布局，靠窗座位的距离为 2，中间座位为 1，靠过道座位为 0。因此 3-3 布局的不便值为 $(2+1+0)+(0+1+2)=6$。而 3-5-3 布局的不便值为 $(2+1+0)+(0+1+2+1+0)+(0+1+2)=10$。\n\n严格来说，一个布局是一个正整数序列 $a_1, a_2, \\ldots, a_{k+1}$ —— 第 $i$ 组有 $a_i$ 个座位，组间有 $k$ 条过道，第 $i$ 条过道位于第 $i$ 组和第 $i+1$ 组之间。这意味着在布局中，每条过道必须始终位于两个座位之间，因此过道不能紧邻窗户，也不能有两条过道相邻。\n\n公司计划设计一种包含 $n$ 个座位、$k$ 条过道且不便值最小的布局。请帮助他们找出所有满足条件的布局中的最小不便值，并统计此类布局的数量（模 $998\\,244\\,353$）。若两个布局的序列不同，则视为不同布局。", "inputFormat": "第一行包含一个整数 $t$ —— 需要解决的测试用例数量（$1 \\le t \\le 10^5$）。\n\n每个测试用例占一行，包含 $n$ 和 $k$ —— 每排的座位数和过道数（$2 \\le n \\le 10^9$；$1 \\le k \\le 10^5$；$k < n$）。\n\n所有测试用例的 $k$ 之和不超过 $10^6$。", "outputFormat": "对于每个测试用例，输出两个整数 —— 所有可能布局中的最小不便值，以及达到最小不便值的布局数量（模 $998\\,244\\,353$）。", "hint": "在最后一个测试用例 $\\texttt{9 2}$ 中，不便值最小为 6 的可能布局有 3-4-2、2-4-3 和 2-5-2。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12434", "type": "P", "difficulty": 7, "samples": [["5 5\n1 2\n3 1\n2 4\n3 4\n4 5\n1 2\n3 2\n3 1\n4 1\n3 5", "YES\n3\n3 4 2 3\n5 4 3 5\n2 4 1 4"], ["5 6\n1 2\n2 3\n1 3\n4 3\n3 5\n5 4\n1 2\n2 4\n4 1\n4 3\n3 5\n4 5", "NO"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC2023] Cactus Transformation", "background": "", "description": "In the university, Caroline started to learn about cactus graphs. Her teacher wanted to check whether the students really understood the definition of a cactus or not and gave them the following problem as a home assignment:\n\nYou are given two cactuses with the same number of vertices and edges. Your task is to answer whether it is possible to transform the first cactus into the second one using only the following two-step operation at most $15\\,000$ times:\n\n- Pick an **arbitrary** edge from the **first** cactus and remove it (note that after this action, it's not necessary that graph is a cactus);\n- Add an **arbitrary non-existing** edge into the **first** graph, so that the graph becomes a cactus.\n\nNote that the operation consists of both actions, so you **must** apply both actions.\n\nIt's guaranteed that if it's possible to transform the first cactus into the second one, then it can be done by using at most $15\\,000$ operations.\n\nThe teacher promised to give a perfect grade without an exam to anyone who solved the problem. Since the given cactuses are big and Caroline can't solve the problem independently in this short period of time, she asked you to help her write a program that solves the problem.\n\nA  _cactus_  is a connected undirected graph in which every edge lies on at most one simple cycle. Intuitively,\na cactus is a generalization of a tree where some cycles are allowed. Multiedges (multiple edges between\na pair of vertices) and loops (edges that connect a vertex to itself) are not allowed in a cactus.\n\nTwo cactuses are called  _same_  if for any pair of vertices $v$ and $u$ ($1 \\leq v < u \\leq n$), either there exists an edge $(v, u)$ in both cactuses or does not.", "inputFormat": "The first line contains two integers $n$ and $m$ ($3 \\le n \\le 1000$, $n - 1 \\le m \\le \\lfloor \\frac{3(n - 1)}{2} \\rfloor$) --- the number of vertices and edges in the cactuses. Each of the next $2 \\cdot m$ lines contains two integers $u$ and $v$ ($1 \\le u \\ne v \\le n$) --- the edges of the cactuses. The first $m$ lines represent the first cactus, while the second $m$ lines represent the second cactus.", "outputFormat": "If transforming the first cactus into the second one is impossible, output the single line with the word ``NO``.\n\nOtherwise, in the first line output the single word ``YES``. In the second line output an integer $c$ ($0 \\leq c \\leq 15\\,000$) --- the number of operations. Each of the following $c$ lines should contain four integers $w_i$ ($1 \\le i \\le 4$, $1 \\le w_i \\le n$). The first two integers ($w_1$, $w_2$) represent the vertices of the removed edge, while the last two integers ($w_3$, $w_4$) represent the vertices of the added edge.", "hint": "### Sample 1 Explanation\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l0rikzrs.png)\n\n### Sample 2 Explanation\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/d9jkxikd.png)", "locale": "en", "translations": {"en": {"title": "[NERC2023] Cactus Transformation", "background": "", "description": "In the university, Caroline started to learn about cactus graphs. Her teacher wanted to check whether the students really understood the definition of a cactus or not and gave them the following problem as a home assignment:\n\nYou are given two cactuses with the same number of vertices and edges. Your task is to answer whether it is possible to transform the first cactus into the second one using only the following two-step operation at most $15\\,000$ times:\n\n- Pick an **arbitrary** edge from the **first** cactus and remove it (note that after this action, it's not necessary that graph is a cactus);\n- Add an **arbitrary non-existing** edge into the **first** graph, so that the graph becomes a cactus.\n\nNote that the operation consists of both actions, so you **must** apply both actions.\n\nIt's guaranteed that if it's possible to transform the first cactus into the second one, then it can be done by using at most $15\\,000$ operations.\n\nThe teacher promised to give a perfect grade without an exam to anyone who solved the problem. Since the given cactuses are big and Caroline can't solve the problem independently in this short period of time, she asked you to help her write a program that solves the problem.\n\nA  _cactus_  is a connected undirected graph in which every edge lies on at most one simple cycle. Intuitively,\na cactus is a generalization of a tree where some cycles are allowed. Multiedges (multiple edges between\na pair of vertices) and loops (edges that connect a vertex to itself) are not allowed in a cactus.\n\nTwo cactuses are called  _same_  if for any pair of vertices $v$ and $u$ ($1 \\leq v < u \\leq n$), either there exists an edge $(v, u)$ in both cactuses or does not.", "inputFormat": "The first line contains two integers $n$ and $m$ ($3 \\le n \\le 1000$, $n - 1 \\le m \\le \\lfloor \\frac{3(n - 1)}{2} \\rfloor$) --- the number of vertices and edges in the cactuses. Each of the next $2 \\cdot m$ lines contains two integers $u$ and $v$ ($1 \\le u \\ne v \\le n$) --- the edges of the cactuses. The first $m$ lines represent the first cactus, while the second $m$ lines represent the second cactus.", "outputFormat": "If transforming the first cactus into the second one is impossible, output the single line with the word ``NO``.\n\nOtherwise, in the first line output the single word ``YES``. In the second line output an integer $c$ ($0 \\leq c \\leq 15\\,000$) --- the number of operations. Each of the following $c$ lines should contain four integers $w_i$ ($1 \\le i \\le 4$, $1 \\le w_i \\le n$). The first two integers ($w_1$, $w_2$) represent the vertices of the removed edge, while the last two integers ($w_3$, $w_4$) represent the vertices of the added edge.", "hint": "### Sample 1 Explanation\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l0rikzrs.png)\n\n### Sample 2 Explanation\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/d9jkxikd.png)", "locale": "en"}, "zh-CN": {"title": "[NERC2023] Cactus Transformation", "background": "", "description": "在大学里，Caroline 开始学习仙人掌图。她的老师为了检验学生是否真正理解仙人掌的定义，布置了以下家庭作业问题：\n\n给定两个具有相同顶点数和边数的仙人掌图。你的任务是判断是否可以通过最多 $15\\,000$ 次以下两步操作，将第一个仙人掌图转换为第二个仙人掌图：\n\n1. 从**第一个**仙人掌图中选择**任意一条**边并删除（注意：此操作后，图不一定是仙人掌图）；\n2. 向**第一个**图中添加一条**原本不存在**的边，使得图重新成为仙人掌图。\n\n注意：该操作包含两个步骤，因此**必须**执行这两个动作。\n\n题目保证，如果可以将第一个仙人掌图转换为第二个仙人掌图，则最多使用 $15\\,000$ 次操作即可完成。\n\n老师承诺，任何解决此问题的学生将无需考试直接获得满分。由于给定的仙人掌图规模较大，Caroline 无法在短时间内独立解决该问题，因此她请你帮忙编写一个程序来解决该问题。\n\n**仙人掌图**是一种连通无向图，其中每条边最多属于一个简单环。直观地说，仙人掌图是允许存在某些环的树的推广。仙人掌图中不允许存在重边（一对顶点之间的多条边）或自环（连接顶点自身的边）。\n\n如果对于任意顶点对 $v$ 和 $u$（$1 \\leq v < u \\leq n$），两个仙人掌图中要么同时存在边 $(v, u)$，要么同时不存在，则称这两个仙人掌图**相同**。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$（$3 \\le n \\le 1000$，$n - 1 \\le m \\le \\lfloor \\frac{3(n - 1)}{2} \\rfloor$）——仙人掌图的顶点数和边数。接下来的 $2 \\cdot m$ 行，每行包含两个整数 $u$ 和 $v$（$1 \\le u \\ne v \\le n$）——表示仙人掌图的边。前 $m$ 行描述第一个仙人掌图，后 $m$ 行描述第二个仙人掌图。\n", "outputFormat": "如果无法将第一个仙人掌图转换为第二个仙人掌图，则输出一行 ``NO``。\n\n否则，第一行输出 ``YES``。第二行输出一个整数 $c$（$0 \\leq c \\leq 15\\,000$）——操作次数。接下来的 $c$ 行，每行包含四个整数 $w_i$（$1 \\le i \\le 4$，$1 \\le w_i \\le n$）。前两个整数 $w_1$ 和 $w_2$ 表示被删除边的顶点，后两个整数 $w_3$ 和 $w_4$ 表示被添加边的顶点。\n", "hint": "### 样例 1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l0rikzrs.png)\n\n### 样例 2 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/d9jkxikd.png)\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12435", "type": "P", "difficulty": 4, "samples": [["6\n10 3\n10 11\n10 4\n10 7\n8 5\n10 6", "2 1\n3 1\n1 2\n3 3\n3 2\n0"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "ICPC", "NERC/NEERC"], "title": "[NERC2023] Divisibility Test", "background": "", "description": "Daisy has recently learned divisibility rules for integers and she is fascinated by them. One of the tests she learned is a divisibility test by 3. You can find a sum of all digits of a decimal number and check if the resulting sum is divisible by 3. Moreover, the resulting sum of digits is congruent modulo 3 to the original number --- the remainder modulo 3 is preserved. For example, $75 \\equiv 7 + 5 \\pmod 3$.\nDaisy is specifically interested in such  _remainder preservin_  divisibility tests.\n\nThere are more examples like that that she learned for decimal integers (integers base 10):\n\n- To test divisibility modulo 11, find an alternating sum of digits. Counting digits from the last (least significant) digit, add digits on odd positions (the last, 3rd to the last, etc) and subtract digits on even positions (2nd to the last, 4th to the last, etc) to get the sum that is congruent modulo 11 to the original number. For example, $123 \\equiv 1 - 2 + 3  \\pmod {11}$.\n- To test divisibility modulo 4, keep the last **two digits**. Their value is congruent modulo 4 to the original number. For example, $876543 \\equiv 43 \\pmod 4$.\n- To test divisibility modulo 7, find an alternating sum of groups of **three digits**. For example, $4389328 \\equiv 4 - 389 + 328 \\pmod 7$.\n\nSimilar tests can be found in other bases. For example, to test divisibility modulo 5 for octal numbers (base 8), find an alternating sum of groups of **two digits**. For example, $1234_8 \\equiv -12_8 + 34_8 \\pmod 5$.\n\nDaisy wants to find such rules for a given base $b$. She is interested in three kinds of divisibility rules:\n\n- **Kind 1** --- take the last $k$ digits of an integer in base $b$.\n- **Kind 2** --- take a sum of groups of $k$ digits of an integer in base $b$.\n- **Kind 3** --- take an alternating sum of groups of $k$ digits of an integer in base $b$.\n\nIt is not always possible to find such a divisibility rule. For example, in base 10 there is no such test for divisibility modulo 6, even though different approaches to testing divisibility by 6 exist.\n\nGiven base $b$ and modulo $n$, Daisy wants to know the smallest group size $k$ for which such a divisibility test exits.", "inputFormat": "There are several tests in the input. The first line of the input contains an integer $t$ --- the number of tests. The next $t$ lines describe the tests.\n\nEach test consists of a line with two integers $b$ and $n$ --- the base and the modulo ($b, n \\ge 2$). The sum of all $b$ values in the input does not exceed $10^6$, and the sum of all $n$ values in the input does not exceed $10^6$.", "outputFormat": "Write $t$ lines --- a line for each test in the input. On a line for a test write a single integer $0$ if the divisibility test for a given $b$ and $n$ does not exist. Otherwise, write two integers $a$ and $k$, where $a$ is the kind of the divisibility test (1, 2, or 3) and $k$ is the number of digits in a group for the test, such that $k$ is the lowest among all possible divisiblity tests for the given $b$ and $n$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC2023] Divisibility Test", "background": "", "description": "Daisy has recently learned divisibility rules for integers and she is fascinated by them. One of the tests she learned is a divisibility test by 3. You can find a sum of all digits of a decimal number and check if the resulting sum is divisible by 3. Moreover, the resulting sum of digits is congruent modulo 3 to the original number --- the remainder modulo 3 is preserved. For example, $75 \\equiv 7 + 5 \\pmod 3$.\nDaisy is specifically interested in such  _remainder preservin_  divisibility tests.\n\nThere are more examples like that that she learned for decimal integers (integers base 10):\n\n- To test divisibility modulo 11, find an alternating sum of digits. Counting digits from the last (least significant) digit, add digits on odd positions (the last, 3rd to the last, etc) and subtract digits on even positions (2nd to the last, 4th to the last, etc) to get the sum that is congruent modulo 11 to the original number. For example, $123 \\equiv 1 - 2 + 3  \\pmod {11}$.\n- To test divisibility modulo 4, keep the last **two digits**. Their value is congruent modulo 4 to the original number. For example, $876543 \\equiv 43 \\pmod 4$.\n- To test divisibility modulo 7, find an alternating sum of groups of **three digits**. For example, $4389328 \\equiv 4 - 389 + 328 \\pmod 7$.\n\nSimilar tests can be found in other bases. For example, to test divisibility modulo 5 for octal numbers (base 8), find an alternating sum of groups of **two digits**. For example, $1234_8 \\equiv -12_8 + 34_8 \\pmod 5$.\n\nDaisy wants to find such rules for a given base $b$. She is interested in three kinds of divisibility rules:\n\n- **Kind 1** --- take the last $k$ digits of an integer in base $b$.\n- **Kind 2** --- take a sum of groups of $k$ digits of an integer in base $b$.\n- **Kind 3** --- take an alternating sum of groups of $k$ digits of an integer in base $b$.\n\nIt is not always possible to find such a divisibility rule. For example, in base 10 there is no such test for divisibility modulo 6, even though different approaches to testing divisibility by 6 exist.\n\nGiven base $b$ and modulo $n$, Daisy wants to know the smallest group size $k$ for which such a divisibility test exits.", "inputFormat": "There are several tests in the input. The first line of the input contains an integer $t$ --- the number of tests. The next $t$ lines describe the tests.\n\nEach test consists of a line with two integers $b$ and $n$ --- the base and the modulo ($b, n \\ge 2$). The sum of all $b$ values in the input does not exceed $10^6$, and the sum of all $n$ values in the input does not exceed $10^6$.", "outputFormat": "Write $t$ lines --- a line for each test in the input. On a line for a test write a single integer $0$ if the divisibility test for a given $b$ and $n$ does not exist. Otherwise, write two integers $a$ and $k$, where $a$ is the kind of the divisibility test (1, 2, or 3) and $k$ is the number of digits in a group for the test, such that $k$ is the lowest among all possible divisiblity tests for the given $b$ and $n$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC2023] Divisibility Test", "background": "", "description": "Daisy 最近学习了整数的可除性规则，并对此非常着迷。她学到的其中一个测试是关于 3 的整除性测试：可以计算一个十进制数所有数字的和，然后检查这个和是否能被 3 整除。此外，这个数字和与原数在模 3 意义下同余——即模 3 的余数保持不变。例如，$75 \\equiv 7 + 5 \\pmod 3$。Daisy 对这类**余数保持**的可除性测试特别感兴趣。\n\n她还学习了其他一些针对十进制整数（基数为 10 的整数）的例子：\n\n- 测试模 11 的整除性时，可以计算数字的交错和。从最后一位（最低有效位）开始计数，奇数位（最后一位、倒数第三位等）的数字相加，偶数位（倒数第二位、倒数第四位等）的数字相减，得到的和在模 11 意义下与原数同余。例如，$123 \\equiv 1 - 2 + 3 \\pmod {11}$。\n- 测试模 4 的整除性时，保留最后**两位数字**。它们的值在模 4 意义下与原数同余。例如，$876543 \\equiv 43 \\pmod 4$。\n- 测试模 7 的整除性时，计算**三位数字**组的交错和。例如，$4389328 \\equiv 4 - 389 + 328 \\pmod 7$。\n\n类似的测试也可以在其他进制中找到。例如，测试八进制数（基数为 8）模 5 的整除性时，可以计算**两位数字**组的交错和。例如，$1234_8 \\equiv -12_8 + 34_8 \\pmod 5$。\n\nDaisy 希望为给定的基数 $b$ 找到这样的规则。她对以下三种可除性测试感兴趣：\n\n1. **类型 1** —— 取基数为 $b$ 的整数的最后 $k$ 位数字。\n2. **类型 2** —— 取基数为 $b$ 的整数的 $k$ 位数字组的和。\n3. **类型 3** —— 取基数为 $b$ 的整数的 $k$ 位数字组的交错和。\n\n并非总能找到这样的可除性测试。例如，在基数为 10 时，没有针对模 6 的测试（尽管存在其他测试 6 的整除性的方法）。\n\n给定基数 $b$ 和模数 $n$，Daisy 想知道是否存在这样的可除性测试，以及最小的组大小 $k$ 是多少。", "inputFormat": "输入包含多个测试用例。第一行是一个整数 $t$ —— 测试用例的数量。接下来的 $t$ 行描述每个测试用例。\n\n每个测试用例包含一行两个整数 $b$ 和 $n$ —— 基数和模数（$b, n \\ge 2$）。输入中所有 $b$ 的总和不超过 $10^6$，所有 $n$ 的总和不超过 $10^6$。", "outputFormat": "输出 $t$ 行 —— 每个测试用例一行。如果对于给定的 $b$ 和 $n$ 不存在可除性测试，则输出 `0`。否则，输出两个整数 $a$ 和 $k$，其中 $a$ 是可除性测试的类型（1、2 或 3），$k$ 是测试中数字组的位数，且 $k$ 是所有可能的测试中最小的。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12436", "type": "P", "difficulty": 5, "samples": [["1998 -3192", "2023-12-13"], ["413 908", "12*34+5\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC2023] Evaluate It and Back Again", "background": "", "description": "Aidan and Nadia are long-time friends with a shared passion for mathematics. Each of them has a favorite number: Aidan's favorite number is $p$, and Nadia's is $q$. \n\nTo commemorate their friendship, their friends want to make a present: a plaque with an arithmetic expression whose value is equal to their favorite numbers. At first glance, it sounds impossible, but the answer is simple: Aidan reads  _left-to-right_ , while Nadia reads  _right-to-left_ , so the same expression can have different values for them.\n\nFor example, if $\\texttt{2023-12-13}$ is written on the plaque, then Aidan would calculate the result as $2023-12-13 = 1998$, and Nadia would calculate it as $31-21-3202=-3192$.\n\nFind an arithmetic expression that, when read left-to-right, evaluates to $p$, and, when read right-to-left, evaluates to $q$. Its length must be at most $1000$ characters. It's guaranteed that such an expression exists for all valid inputs.", "inputFormat": "The first line of the input contains two integers $p$ and $q$ ($-10^{18} \\le p, q \\le 10^{18}$).", "outputFormat": "Print the expression without spaces or line breaks. It can only contain digits 0 through 9, $\\tt{+}$, $\\tt{-}$, and $\\tt{*}$ characters.\n\nThe expression must contain at most $1000$ characters. Leading zeros in numbers are not allowed (the only exception is the notation $\\tt{0}$ representing the number $0$) in both the expression and its reverse. Use of unary $\\tt{+}$ or $\\tt{-}$ is not allowed. \nThe expression must be well-formed in both directions. The calculation uses the standard operator precedence. ", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC2023] Evaluate It and Back Again", "background": "", "description": "Aidan and Nadia are long-time friends with a shared passion for mathematics. Each of them has a favorite number: Aidan's favorite number is $p$, and Nadia's is $q$. \n\nTo commemorate their friendship, their friends want to make a present: a plaque with an arithmetic expression whose value is equal to their favorite numbers. At first glance, it sounds impossible, but the answer is simple: Aidan reads  _left-to-right_ , while Nadia reads  _right-to-left_ , so the same expression can have different values for them.\n\nFor example, if $\\texttt{2023-12-13}$ is written on the plaque, then Aidan would calculate the result as $2023-12-13 = 1998$, and Nadia would calculate it as $31-21-3202=-3192$.\n\nFind an arithmetic expression that, when read left-to-right, evaluates to $p$, and, when read right-to-left, evaluates to $q$. Its length must be at most $1000$ characters. It's guaranteed that such an expression exists for all valid inputs.", "inputFormat": "The first line of the input contains two integers $p$ and $q$ ($-10^{18} \\le p, q \\le 10^{18}$).", "outputFormat": "Print the expression without spaces or line breaks. It can only contain digits 0 through 9, $\\tt{+}$, $\\tt{-}$, and $\\tt{*}$ characters.\n\nThe expression must contain at most $1000$ characters. Leading zeros in numbers are not allowed (the only exception is the notation $\\tt{0}$ representing the number $0$) in both the expression and its reverse. Use of unary $\\tt{+}$ or $\\tt{-}$ is not allowed. \nThe expression must be well-formed in both directions. The calculation uses the standard operator precedence. ", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC2023] Evaluate It and Back Again", "background": "", "description": "Aidan 和 Nadia 是两位热爱数学的多年好友。他们各自有一个最喜爱的数字：Aidan 的最爱是 $p$，而 Nadia 的最爱是 $q$。\n\n为了纪念他们的友谊，朋友们决定制作一份礼物：一块刻有算术表达式的牌匾，该表达式的值分别等于他们最喜爱的数字。乍看之下这似乎不可能，但答案很简单：Aidan 会以**从左到右**的顺序阅读，而 Nadia 会以**从右到左**的顺序阅读，因此同一个表达式可以为他们计算出不同的值。\n\n例如，如果牌匾上刻着 $\\texttt{2023-12-13}$，那么 Aidan 会计算 $2023 - 12 - 13 = 1998$，而 Nadia 会计算 $31 - 21 - 3202 = -3192$。\n\n你需要找到一个算术表达式，满足从左到右计算时结果为 $p$，从右到左计算时结果为 $q$。表达式的长度不得超过 $1000$ 个字符。题目保证对于所有有效输入，这样的表达式一定存在。", "inputFormat": "输入的第一行包含两个整数 $p$ 和 $q$（$-10^{18} \\le p, q \\le 10^{18}$）。\n", "outputFormat": "输出一个不含空格或换行的表达式。表达式中仅允许包含数字 0 到 9，以及字符 $\\tt{+}$、$\\tt{-}$ 和 $\\tt{*}$。\n\n表达式的长度不得超过 $1000$ 个字符。数字不允许有前导零（唯一的例外是表示数字 $0$ 的 $\\tt{0}$），无论是原表达式还是其反向形式。不允许使用一元运算符 $\\tt{+}$ 或 $\\tt{-}$。表达式在两个方向上都必须语法正确，计算时遵循标准运算符优先级。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12437", "type": "P", "difficulty": 7, "samples": [["2\n1 2\n2", "1"], ["3\n1 2\n1 3\n1", "2"], ["4\n4 3\n4 1\n4 2\n4", "3.66667"], ["7\n1 4\n4 5\n5 2\n4 6\n6 7\n7 3\n3", "8.3525"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["博弈论", "2023", "Special Judge", "期望", "ICPC", "NERC/NEERC"], "title": "[NERC2023] Fugitive Frenzy", "background": "", "description": "The city of F. can be represented as a tree. A famous fugitive is hiding in it, and today a faithful police officer decided to catch him at all costs. The police officer is stronger than the fugitive, but the fugitive is much faster than the former. That is why the pursuit proceeds as follows. At the moment $t = 0$ the police officer appears at the vertex with number $s$, and the fugitive spawns at any other vertex of his choice. After that, they take turns, starting with the police officer.\n\n- During the police officer's move, she selects any vertex adjacent to the one where she is currently located and moves there. The police officer spends one minute moving. Also, the police officer may decide to stand still instead, in which case she waits one minute at the vertex at which she started her move. If at the end of the turn the police officer ends up at the same vertex as the fugitive, she instantly catches him and the chase ends.\n- The fugitive's move is as follows. Let him be at vertex $b$, and the police officer at vertex $p$. Then the fugitive chooses any vertex $b' \\ne p$ such that the path between the vertices $b$ and $b'$ does not contain vertex $p$ and instantly moves there. In particular, he can always choose $b' = b$ to stay where he is. The fugitive's move takes no time.\n\nNote that the fugitive managed to attach a radio bug to the police officer's badge a week ago, so the fugitive knows the location of the police officer at every moment (in particular, he knows the number $s$). On the contrary, the police officer knows nothing about the fugitive's movements and will only be able to detect him at the very moment she catches him.\n\nThe police officer aims to catch the fugitive as fast as possible, and the fugitive aims to be caught as late as possible. Since the chase can be thought of as a game with incomplete information, participants can use mixed (probabilistic) strategies --- thus, the police officer acts to minimize the expected duration of the chase, and the fugitive --- to maximize it.\n\nFind the mathematical expectation of the duration of the chase with optimal actions of the police officer and the fugitive. It can be proven that it is always finite. In particular, with optimal strategies, the probability that the chase continues indefinitely is equal to zero.", "inputFormat": "The first line contains an integer $n$ --- the number of vertices in the tree ($2 \\le n \\le 100$). The next $n - 1$ lines describe the city of F.: each of them contains a pair of integers $u_i$, $v_i$ --- the numbers of the ends of an edge ($1 \\le u_i, v_i \\le n$). These edges are guaranteed to form a tree.\n\nThe last line contains an integer $s$ --- the number of the vertex where the police officer initially appears ($1 \\le s \\le n$).", "outputFormat": "Print one real number --- the mathematical expectation of the duration of the chase with the optimal strategies of the police officer and the fugitive. Your answer will be accepted if its absolute or relative error does not exceed $10^{-6}$; formally, if $p$ is your answer, and $j$ is the jury's answer, this should hold: $\\frac{|p - j|}{\\max\\{1, |j|\\}} \\le 10^{-6}$.", "hint": "The trees from the examples are depicted below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/371pj0ej.png)", "locale": "en", "translations": {"en": {"title": "[NERC2023] Fugitive Frenzy", "background": "", "description": "The city of F. can be represented as a tree. A famous fugitive is hiding in it, and today a faithful police officer decided to catch him at all costs. The police officer is stronger than the fugitive, but the fugitive is much faster than the former. That is why the pursuit proceeds as follows. At the moment $t = 0$ the police officer appears at the vertex with number $s$, and the fugitive spawns at any other vertex of his choice. After that, they take turns, starting with the police officer.\n\n- During the police officer's move, she selects any vertex adjacent to the one where she is currently located and moves there. The police officer spends one minute moving. Also, the police officer may decide to stand still instead, in which case she waits one minute at the vertex at which she started her move. If at the end of the turn the police officer ends up at the same vertex as the fugitive, she instantly catches him and the chase ends.\n- The fugitive's move is as follows. Let him be at vertex $b$, and the police officer at vertex $p$. Then the fugitive chooses any vertex $b' \\ne p$ such that the path between the vertices $b$ and $b'$ does not contain vertex $p$ and instantly moves there. In particular, he can always choose $b' = b$ to stay where he is. The fugitive's move takes no time.\n\nNote that the fugitive managed to attach a radio bug to the police officer's badge a week ago, so the fugitive knows the location of the police officer at every moment (in particular, he knows the number $s$). On the contrary, the police officer knows nothing about the fugitive's movements and will only be able to detect him at the very moment she catches him.\n\nThe police officer aims to catch the fugitive as fast as possible, and the fugitive aims to be caught as late as possible. Since the chase can be thought of as a game with incomplete information, participants can use mixed (probabilistic) strategies --- thus, the police officer acts to minimize the expected duration of the chase, and the fugitive --- to maximize it.\n\nFind the mathematical expectation of the duration of the chase with optimal actions of the police officer and the fugitive. It can be proven that it is always finite. In particular, with optimal strategies, the probability that the chase continues indefinitely is equal to zero.", "inputFormat": "The first line contains an integer $n$ --- the number of vertices in the tree ($2 \\le n \\le 100$). The next $n - 1$ lines describe the city of F.: each of them contains a pair of integers $u_i$, $v_i$ --- the numbers of the ends of an edge ($1 \\le u_i, v_i \\le n$). These edges are guaranteed to form a tree.\n\nThe last line contains an integer $s$ --- the number of the vertex where the police officer initially appears ($1 \\le s \\le n$).", "outputFormat": "Print one real number --- the mathematical expectation of the duration of the chase with the optimal strategies of the police officer and the fugitive. Your answer will be accepted if its absolute or relative error does not exceed $10^{-6}$; formally, if $p$ is your answer, and $j$ is the jury's answer, this should hold: $\\frac{|p - j|}{\\max\\{1, |j|\\}} \\le 10^{-6}$.", "hint": "The trees from the examples are depicted below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/371pj0ej.png)", "locale": "en"}, "zh-CN": {"title": "[NERC2023] Fugitive Frenzy", "background": "", "description": "F 城可以被表示为一棵树。一名著名逃犯正藏匿其中，今天一名忠实的警官决定不惜一切代价抓住他。警官比逃犯更强壮，但逃犯的速度远快于前者。因此追捕过程如下：在时刻 $t = 0$，警官出现在编号为 $s$ 的顶点，而逃犯可以选择任意其他顶点作为出生点。之后，他们轮流行动，警官先手。\n\n- **警官的回合**：她可以选择当前所在顶点的任意相邻顶点并移动过去。移动耗时 1 分钟。警官也可以选择停留在原地，此时她在当前顶点等待 1 分钟。如果在回合结束时警官与逃犯位于同一顶点，她会立即抓住逃犯，追捕结束。\n- **逃犯的回合**：设逃犯位于顶点 $b$，警官位于顶点 $p$。逃犯可以选择任意满足 $b' \\ne p$ 且 $b$ 到 $b'$ 的路径不经过 $p$ 的顶点 $b'$，并瞬间移动过去。特别地，他可以选择 $b' = b$ 保持不动。逃犯的移动不消耗时间。\n\n注意，逃犯一周前成功在警官的徽章上安装了无线电窃听器，因此逃犯始终知道警官的实时位置（包括初始顶点 $s$）。相反，警官对逃犯的移动一无所知，只有在抓住逃犯的瞬间才能发现他。\n\n警官的目标是尽快抓住逃犯，而逃犯的目标是尽可能延迟被抓。由于追捕可视为不完全信息博弈，参与者可以采用混合（概率）策略——警官会最小化追捕的期望时长，逃犯会最大化该期望。\n\n求在双方最优策略下追捕时长的数学期望。可以证明该期望总是有限的。特别地，在最优策略下，追捕无限持续的概率为零。", "inputFormat": "第一行输入整数 $n$ 表示树的顶点数（$2 \\le n \\le 100$）。接下来 $n - 1$ 行描述 F 城的边：每行包含两个整数 $u_i$, $v_i$ 表示边的端点（$1 \\le u_i, v_i \\le n$），保证这些边构成一棵树。\n\n最后一行输入整数 $s$ 表示警官的初始顶点编号（$1 \\le s \\le n$）。", "outputFormat": "输出一个实数，表示最优策略下追捕时长的数学期望。若答案的绝对或相对误差不超过 $10^{-6}$ 则视为正确。形式化地，设你的答案为 $p$，标准答案为 $j$，需满足：$\\frac{|p - j|}{\\max\\{1, |j|\\}} \\le 10^{-6}$。", "hint": "样例中的树如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/371pj0ej.png)\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12438", "type": "P", "difficulty": 6, "samples": [["5 4\n3 2 1 2 3\n1 5\n2 4\n1 2\n5 5", "4\n4\n1\n1\n3"], ["7 3\n1 1000000000 1 1 1 1000000000 1\n1 3\n4 5\n5 7", "2999999997\n2999999996\n2999999994\n2999999996"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "ICPC", "NERC/NEERC"], "title": "[NERC2023] Great City Saint Petersburg", "background": "", "description": "Saint Petersburg is the most beautiful city in the world unless it is raining. For the sake of this problem, we will assume it is raining every single day.\n\nOne of the streets in Saint Petersburg has an unusual shape --- it is a narrow stripe of $n$ sections $1$ meter long each, where section $i$ is at the height $a_i$ meters from the ground. The stripe is $1$ meter deep and bounded on the front and on the back by incredibly high buildings. Because of this, when it is raining, a certain amount of rain will accumulate, unable to flow out of the street from either its leftmost or rightmost end.\nGiven the heights $a_1, a_2, \\ldots, a_n$, you need to determine the amount of rain (in cubic meters) which will accumulate on the street.\n\nMoreover, your colleagues from the metropolitan construction company will be visiting for $q$ days and on day $i$ they will be laying asphalt on all sections from $l_i$ to $r_i$ inclusive, thus increasing the height of each section $l_i, l_i+1, \\ldots, r_i$ by $1$ meter. You need to determine the total amount of water which accumulates on the street before the construction works, and also after every single day of the construction works.", "inputFormat": "The first line contains the number of blocks $n$ and the number of construction events $q$ ($1 \\le n, q \\le 2 \\cdot 10^5$).\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$) --- the height of each section before all the events.\nEach of the following $q$ lines contains a pair of integers $l_i$, $r_i$ ($1 \\le l_i \\le r_i \\le n$), denoting the construction work from $l_i$ to $r_i$ inclusive.", "outputFormat": "Print $q+1$ integers --- the amount of water on the street before all updates, and also after every update.", "hint": "The picture illustrates the amount of water accumulating on the street in the first example.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jmpwgw7q.png)", "locale": "en", "translations": {"en": {"title": "[NERC2023] Great City Saint Petersburg", "background": "", "description": "Saint Petersburg is the most beautiful city in the world unless it is raining. For the sake of this problem, we will assume it is raining every single day.\n\nOne of the streets in Saint Petersburg has an unusual shape --- it is a narrow stripe of $n$ sections $1$ meter long each, where section $i$ is at the height $a_i$ meters from the ground. The stripe is $1$ meter deep and bounded on the front and on the back by incredibly high buildings. Because of this, when it is raining, a certain amount of rain will accumulate, unable to flow out of the street from either its leftmost or rightmost end.\nGiven the heights $a_1, a_2, \\ldots, a_n$, you need to determine the amount of rain (in cubic meters) which will accumulate on the street.\n\nMoreover, your colleagues from the metropolitan construction company will be visiting for $q$ days and on day $i$ they will be laying asphalt on all sections from $l_i$ to $r_i$ inclusive, thus increasing the height of each section $l_i, l_i+1, \\ldots, r_i$ by $1$ meter. You need to determine the total amount of water which accumulates on the street before the construction works, and also after every single day of the construction works.", "inputFormat": "The first line contains the number of blocks $n$ and the number of construction events $q$ ($1 \\le n, q \\le 2 \\cdot 10^5$).\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$) --- the height of each section before all the events.\nEach of the following $q$ lines contains a pair of integers $l_i$, $r_i$ ($1 \\le l_i \\le r_i \\le n$), denoting the construction work from $l_i$ to $r_i$ inclusive.", "outputFormat": "Print $q+1$ integers --- the amount of water on the street before all updates, and also after every update.", "hint": "The picture illustrates the amount of water accumulating on the street in the first example.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jmpwgw7q.png)", "locale": "en"}, "zh-CN": {"title": "[NERC2023] Great City Saint Petersburg", "background": "", "description": "圣彼得堡是世界上最美丽的城市——除非下雨天。为了本题的设定，我们假设这里每天都在下雨。\n\n圣彼得堡的一条街道形状特殊——它由 $n$ 个长度为 1 米的区块组成，其中第 $i$ 个区块距离地面的高度为 $a_i$ 米。街道深度为 1 米，前后两侧被极高的建筑物包围。因此下雨时，会有一定量的雨水因无法从街道最左端或最右端流出而积聚在街道上。\n给定高度序列 $a_1, a_2, \\ldots, a_n$，你需要计算街道上积聚的雨水量（单位：立方米）。\n\n此外，市政建设公司的同事们将进行为期 $q$ 天的考察。在第 $i$ 天，他们会对从 $l_i$ 到 $r_i$ 的所有区块铺设沥青，使这些区块 $l_i, l_i+1, \\ldots, r_i$ 的高度各增加 1 米。你需要分别计算在施工前，以及每天施工后的街道积水总量。", "inputFormat": "第一行包含两个整数 $n$（区块数）和 $q$（施工天数）（$1 \\le n, q \\le 2 \\cdot 10^5$）。\n第二行包含 $n$ 个整数 $a_1, a_2, \\ldots, a_n$（$1 \\le a_i \\le 10^9$），表示所有施工事件前的初始高度。\n接下来 $q$ 行，每行包含两个整数 $l_i$, $r_i$（$1 \\le l_i \\le r_i \\le n$），表示当天施工的区块范围。", "outputFormat": "输出 $q+1$ 个整数，分别表示：所有施工前的积水量，以及每次施工后的积水量。", "hint": "图示为第一个样例中街道的积水情况。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jmpwgw7q.png)\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12439", "type": "P", "difficulty": 5, "samples": [["5 6\n1 3\n1 2\n2 3\n4 2\n1 5\n5 1", "5\n5 1\n1 2\n4 2\n2 3\n3 5"], ["3 6\n1 2\n1 3\n2 1\n2 3\n3 1\n3 2", "-1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC2023] Hypercatapult Commute", "background": "", "description": "A revolutionary new transport system is currently operating in Byteland. This system requires neither roads nor sophisticated mechanisms, only giant catapults. \n\nThe system works as follows. There are $n$ cities in Byteland. In every city there is a catapult, right in the city center. People who want to travel are put in a special capsule, and a catapult throws this capsule to the center of some other city. Every catapult is powerful enough to throw the capsule to any other city, with any number of passengers inside the capsule. The only problem is that it takes a long time to charge the catapult, so it is only possible to use it once a day.\n\nThe passenger may need to use the catapults multiple times. For example, if the passenger wants to travel from city A to city B, they can first use one catapult to move from A to C, and then transfer to another catapult to move from C to B.\n\nToday there are $m$ passengers. Passenger $i$ wants to travel from city $a_i$ to city $b_i$. Your task is to find the way to deliver all the passengers to their destinations in a single day, using the minimal possible number of catapults, or say that it is impossible.", "inputFormat": "The first line of the input contains two integers $n$ and $m$ ($1 \\leq n \\leq 1000$, $0 \\leq m \\leq 10^5$) --- the number of cities and the number of passengers. The next $m$ lines contain pairs of numbers $a_i$ and $b_i$ ($1 \\leq a_i, b_i \\leq n$, $a_i \\neq b_i$).", "outputFormat": "In the first line print the number $k$ --- the minimal number of catapults you need to use.\n\nIn the next $k$ lines, print descriptions of each catapult launch, in the order they need to be performed. Each description should consist of two integers $c_i$, $d_i$, the index of the city to launch from, and the index of destination city.\n\nNote that you don't need to print what passengers should be put into the capsule on each launch, but it should be possible for each passenger to reach their destination city using the plan you provide.\n\nIf it is impossible to deliver all passengers, print the single number $-1$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC2023] Hypercatapult Commute", "background": "", "description": "A revolutionary new transport system is currently operating in Byteland. This system requires neither roads nor sophisticated mechanisms, only giant catapults. \n\nThe system works as follows. There are $n$ cities in Byteland. In every city there is a catapult, right in the city center. People who want to travel are put in a special capsule, and a catapult throws this capsule to the center of some other city. Every catapult is powerful enough to throw the capsule to any other city, with any number of passengers inside the capsule. The only problem is that it takes a long time to charge the catapult, so it is only possible to use it once a day.\n\nThe passenger may need to use the catapults multiple times. For example, if the passenger wants to travel from city A to city B, they can first use one catapult to move from A to C, and then transfer to another catapult to move from C to B.\n\nToday there are $m$ passengers. Passenger $i$ wants to travel from city $a_i$ to city $b_i$. Your task is to find the way to deliver all the passengers to their destinations in a single day, using the minimal possible number of catapults, or say that it is impossible.", "inputFormat": "The first line of the input contains two integers $n$ and $m$ ($1 \\leq n \\leq 1000$, $0 \\leq m \\leq 10^5$) --- the number of cities and the number of passengers. The next $m$ lines contain pairs of numbers $a_i$ and $b_i$ ($1 \\leq a_i, b_i \\leq n$, $a_i \\neq b_i$).", "outputFormat": "In the first line print the number $k$ --- the minimal number of catapults you need to use.\n\nIn the next $k$ lines, print descriptions of each catapult launch, in the order they need to be performed. Each description should consist of two integers $c_i$, $d_i$, the index of the city to launch from, and the index of destination city.\n\nNote that you don't need to print what passengers should be put into the capsule on each launch, but it should be possible for each passenger to reach their destination city using the plan you provide.\n\nIf it is impossible to deliver all passengers, print the single number $-1$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC2023] Hypercatapult Commute", "background": "", "description": "比特兰王国正在运营一套革命性的新型交通系统。这套系统既不需要道路，也不需要复杂机械，仅需巨型弹射器即可运作。\n\n该系统工作原理如下：比特兰有 $n$ 座城市，每座城市的市中心都设有一座弹射器。想要出行的乘客会被装入特制胶囊，弹射器将胶囊发射至其他城市的中心。每座弹射器的动力都足以将胶囊（无论载客量多少）发射到任意其他城市。唯一的问题是弹射器充能耗时较长，因此每天只能使用一次。\n\n乘客可能需要多次换乘弹射器。例如，若乘客想从城市 A 前往城市 B，可以先通过弹射器从 A 移动到 C，再换乘另一座弹射器从 C 移动到 B。\n\n今天共有 $m$ 名乘客需要出行，其中第 $i$ 名乘客希望从城市 $a_i$ 前往城市 $b_i$。你的任务是找到一种方案，使得所有乘客都能在一天内抵达目的地，且使用的弹射器数量最少；若不可能实现，则需给出相应判断。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$（$1 \\leq n \\leq 1000$，$0 \\leq m \\leq 10^5$），分别表示城市数量和乘客数量。接下来 $m$ 行每行包含两个整数 $a_i$ 和 $b_i$（$1 \\leq a_i, b_i \\leq n$，$a_i \\neq b_i$），描述乘客的出发地和目的地。", "outputFormat": "第一行输出整数 $k$，表示所需使用的最少弹射器数量。\n\n随后 $k$ 行按执行顺序输出每次弹射的详情，每行包含两个整数 $c_i$ 和 $d_i$，分别表示发射城市和目的城市的编号。\n\n注意：你不需要具体说明每次弹射搭载哪些乘客，但需确保根据你提供的方案，所有乘客都能抵达目的地。\n\n若无法完成所有运输任务，则输出单个数字 $-1$。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12440", "type": "P", "difficulty": 7, "samples": [["4\n4 2\n0 0\n2 0\n2 2\n0 2\n3 1\n1 -1\n0 1\n-1 -1\n8 18\n-2 1\n-2 -3\n-1 -4\n0 -4\n3 -3\n4 -1\n4 0\n-1 2\n4 1\n99999998 99999999\n99999999 99999998\n100000000 99999999\n99999999 100000000", "0.3729232286\n0.1379212354\n1.3663189952\n0.2636965438"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC2023] Innovative Washing Machine", "background": "", "description": "You are asked to help a team that participates in ``Innovation Workshop`` --- an event where teams of students invent and prototype their innovative ideas. One of the teams developed a new innovative washing machine that significantly reduces the usage of energy needed for laundry.\n\nThe innovative idea was to use a convex polygon instead of a circle for the shape of a washing machine drum. You are given this polygon. A drum is rotating around some fixed point inside the polygon with a constant speed of $1$ turn in $1$ second.\n\nCurrently, the prototype is built and testing is started. There are $s$ litres of water in the drum. At each moment of time, water under the influence of gravity occupies a region with area $s$ at the bottom of the drum.\n\nVertices of the polygon that are underwater are under pressure. By Pascal's law, we know that pressure is proportional to depth. Let's define by $d_1, d_2, \\ldots, d_k$ depths of the vertices that are underwater at some moment of time, $k$ is the number of underwater vertices. Let's define the *pressure imbalance* as the average difference between underwater vertex depth and the maximum underwater vertex depth, i.e. $\\frac{1}{k} \\sum\\limits_{i=1}^{k} \\left(\\max\\limits_{j=1}^{k} d_j - d_i \\right)$. Note that the order of $d_i$ is not important.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ty81xbs5.png)\n\nThe polygon from the third test case is rotated. Vertices $1$, $2$, $3$, $4$, $8$ are underwater.\n\nTo select the optimal shape of the drum, the team wants to know the expected value of pressure imbalance for the moment of time selected uniformly from segment $[0, 1]$ (in seconds). Please help the team to calculate this value.", "inputFormat": "The first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) --- the number of test cases. The next lines contain descriptions of test cases.\n\nThe first line contains two integers $n$, $s$ ($3 \\leq n \\leq 2 \\cdot 10^5$, $s \\geq 1$) --- the number of vertices in the polygon and the number of litres of water inside the drum. It is guaranteed that $s$ is less than the area of the polygon.\n\nEach of the next $n$ lines contains two integers $x_i$, $y_i$ ($|x_i|, |y_i| \\leq 10^8$) --- coordinates of polygon vertices. \n\nIt is guaranteed that the given points form a convex polygon. The area of the polygon is positive and no two consecutive segments are collinear. The vertices of the polygon are given in counterclockwise order.\n\nThe sum of $n$ for all test cases does not exceed $2 \\cdot 10^5$.", "outputFormat": "For each test case, print a single real number --- the expected value of pressure imbalance for a random uniform moment of time.\n\nYour answer will be accepted if its absolute or relative error does not exceed $10^{-5}$; formally, if $p$ is your answer, and $j$ is the jury's answer, this should hold: $\\frac{|p - j|}{\\max\\{1, |j|\\}} \\le 10^{-5}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC2023] Innovative Washing Machine", "background": "", "description": "You are asked to help a team that participates in ``Innovation Workshop`` --- an event where teams of students invent and prototype their innovative ideas. One of the teams developed a new innovative washing machine that significantly reduces the usage of energy needed for laundry.\n\nThe innovative idea was to use a convex polygon instead of a circle for the shape of a washing machine drum. You are given this polygon. A drum is rotating around some fixed point inside the polygon with a constant speed of $1$ turn in $1$ second.\n\nCurrently, the prototype is built and testing is started. There are $s$ litres of water in the drum. At each moment of time, water under the influence of gravity occupies a region with area $s$ at the bottom of the drum.\n\nVertices of the polygon that are underwater are under pressure. By Pascal's law, we know that pressure is proportional to depth. Let's define by $d_1, d_2, \\ldots, d_k$ depths of the vertices that are underwater at some moment of time, $k$ is the number of underwater vertices. Let's define the *pressure imbalance* as the average difference between underwater vertex depth and the maximum underwater vertex depth, i.e. $\\frac{1}{k} \\sum\\limits_{i=1}^{k} \\left(\\max\\limits_{j=1}^{k} d_j - d_i \\right)$. Note that the order of $d_i$ is not important.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ty81xbs5.png)\n\nThe polygon from the third test case is rotated. Vertices $1$, $2$, $3$, $4$, $8$ are underwater.\n\nTo select the optimal shape of the drum, the team wants to know the expected value of pressure imbalance for the moment of time selected uniformly from segment $[0, 1]$ (in seconds). Please help the team to calculate this value.", "inputFormat": "The first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$) --- the number of test cases. The next lines contain descriptions of test cases.\n\nThe first line contains two integers $n$, $s$ ($3 \\leq n \\leq 2 \\cdot 10^5$, $s \\geq 1$) --- the number of vertices in the polygon and the number of litres of water inside the drum. It is guaranteed that $s$ is less than the area of the polygon.\n\nEach of the next $n$ lines contains two integers $x_i$, $y_i$ ($|x_i|, |y_i| \\leq 10^8$) --- coordinates of polygon vertices. \n\nIt is guaranteed that the given points form a convex polygon. The area of the polygon is positive and no two consecutive segments are collinear. The vertices of the polygon are given in counterclockwise order.\n\nThe sum of $n$ for all test cases does not exceed $2 \\cdot 10^5$.", "outputFormat": "For each test case, print a single real number --- the expected value of pressure imbalance for a random uniform moment of time.\n\nYour answer will be accepted if its absolute or relative error does not exceed $10^{-5}$; formally, if $p$ is your answer, and $j$ is the jury's answer, this should hold: $\\frac{|p - j|}{\\max\\{1, |j|\\}} \\le 10^{-5}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC2023] Innovative Washing Machine", "background": "", "description": "你被邀请协助一个参加\"创新工坊\"的学生团队——这是一个让学生团队发明并制作创新产品原型的活动。该团队开发了一款新型创新洗衣机，能显著降低洗衣所需的能耗。\n\n这个创新点在于使用凸多边形而非圆形作为洗衣机滚筒的形状。现在给你这个多边形。滚筒以恒定速度绕多边形内部某个固定点旋转，每秒转 $1$ 圈。\n\n目前原型机已经建成并开始测试。滚筒内有 $s$ 升水。在任何时刻，受重力影响的水都会占据滚筒底部面积为 $s$ 的区域。\n\n位于水下的多边形顶点会受到压力。根据帕斯卡定律，压力与深度成正比。设在某一时刻有 $k$ 个顶点位于水下，其深度分别为 $d_1, d_2, \\ldots, d_k$。我们定义**压力失衡值**为水下顶点深度与最大水下顶点深度的平均差值，即 $\\frac{1}{k} \\sum\\limits_{i=1}^{k} \\left(\\max\\limits_{j=1}^{k} d_j - d_i \\right)$。注意 $d_i$ 的顺序不影响计算结果。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ty81xbs5.png)\n\n第三个测试用例中的多边形正在旋转。顶点 $1$、$2$、$3$、$4$、$8$ 位于水下。\n\n为了选择最优的滚筒形状，团队需要知道在时间区间 $[0, 1]$（秒）内均匀随机选取时刻时压力失衡值的期望。请帮助团队计算这个值。", "inputFormat": "第一行包含一个整数 $t$（$1 \\leq t \\leq 10^4$）——测试用例数量。接下来是各测试用例的描述。\n\n每个测试用例的第一行包含两个整数 $n$, $s$（$3 \\leq n \\leq 2 \\cdot 10^5$, $s \\geq 1$）——多边形的顶点数和滚筒内的水量（升）。保证 $s$ 小于多边形面积。\n\n接下来的 $n$ 行每行包含两个整数 $x_i$, $y_i$（$|x_i|, |y_i| \\leq 10^8$）——多边形顶点的坐标。\n\n保证给定点构成一个凸多边形。多边形面积为正且没有两条连续边共线。多边形顶点按逆时针顺序给出。\n\n所有测试用例的 $n$ 之和不超过 $2 \\cdot 10^5$。", "outputFormat": "对于每个测试用例，输出一个实数——在随机均匀时刻的压力失衡值的期望。\n\n当你的答案与标准答案的绝对误差或相对误差不超过 $10^{-5}$ 时视为正确。形式化地说，设你的答案为 $p$，标准答案为 $j$，则应满足：$\\frac{|p - j|}{\\max\\{1, |j|\\}} \\le 10^{-5}$。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12441", "type": "P", "difficulty": 5, "samples": [["3\n6 1 3\n6 2 2 3\n6 3 1 2 3", "1\n2\n7"], ["4\n1000000000 3 1 1 1\n0 3 2 4 5\n17 2 2 4\n34 3 5 3 2", "500000001500000001\n1\n0\n25\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "ICPC", "NERC/NEERC"], "title": "[NERC2023] Joy of Pokémon Observation", "background": "", "description": "The Pokémon Conservation Society protects Pokémon and their habitats all around the globe. In recent research, data about $h$ habitats was collected.\n\nEach habitat may be inhabited by several Pokémon species. Researchers know how many limbs each species has. Pokémon are swift and extremely good at hiding, so researchers were only able to detect the total number of limbs in each of the habitats.\n\nResearchers understand that it might not be possible to find the population of each species, but would like to understand how much uncertainty is left. How many different combinations of Pokémon would have the observed number of limbs?", "inputFormat": "The first line contains a single integer $h$ ($1 \\le h \\le 1\\,024$) --- the number of habitats.\nThe next $h$ lines contain the description of each habitat.\n\nEach line starts with two integers $t$ and $s$ ($0 \\le t \\le 10^9$, $1 \\le s \\le 3$), where $t$ is the total number of limbs, and $s$ is the number of species in the habitat. They are followed by $s$ integers $l_i$ ($1 \\le l_i \\le 16$) --- the number of limbs for each species.", "outputFormat": "Output the number of possible combinations of Pokémon in each habitat.\nOutput should contain $h$ lines with a single integer.", "hint": "For the sake of example we will use $\\LaTeX{}$ Pokémon: $\\c{O}$ has one limb, $\\angle$ has two limbs, $\\exists$ has three limbs. In the first example all three habitats have $6$ limbs.\n\n**In the first example** the first habitat has only one Pokémon species --- $\\exists$. So it is likely the young family containing $\\exists\\exists$.\n\nIn the second habitat there are two Pokémon species: $\\angle$ and $\\exists$. So it is either $\\angle\\angle\\angle$ or $\\exists\\exists$.\n\nThe third habitat may contain any of the three Pokémon species: $\\c{O}$, $\\angle$ and $\\exists$. There are seven possible combinations: $\\exists\\exists$, $\\angle\\angle\\angle$, $\\c{O}\\angle\\exists$, $\\c{O}\\c{O}\\angle\\angle$, $\\c{O}\\c{O}\\c{O}\\exists$, $\\c{O}\\c{O}\\c{O}\\c{O}\\angle$, $\\c{O}\\c{O}\\c{O}\\c{O}\\c{O}\\c{O}$.\n\n**In the second example** the first habitat has three Pokémon species, but all of them have only one limb: $\\partial$, $\\c{O}$ and $\\rho$. There are $10^9$ limbs and $\\sum_{i=0}^{i\\le 10^9}(i + 1)$ combinations.\n\nIn the second habitat no limbs were detected. So there are unfortunately no Pokémon left in the area. \n\nIn the third habitat all Pokémon have an even number of limbs, so it is not possible to have 17 limbs.", "locale": "en", "translations": {"en": {"title": "[NERC2023] Joy of Pokémon Observation", "background": "", "description": "The Pokémon Conservation Society protects Pokémon and their habitats all around the globe. In recent research, data about $h$ habitats was collected.\n\nEach habitat may be inhabited by several Pokémon species. Researchers know how many limbs each species has. Pokémon are swift and extremely good at hiding, so researchers were only able to detect the total number of limbs in each of the habitats.\n\nResearchers understand that it might not be possible to find the population of each species, but would like to understand how much uncertainty is left. How many different combinations of Pokémon would have the observed number of limbs?", "inputFormat": "The first line contains a single integer $h$ ($1 \\le h \\le 1\\,024$) --- the number of habitats.\nThe next $h$ lines contain the description of each habitat.\n\nEach line starts with two integers $t$ and $s$ ($0 \\le t \\le 10^9$, $1 \\le s \\le 3$), where $t$ is the total number of limbs, and $s$ is the number of species in the habitat. They are followed by $s$ integers $l_i$ ($1 \\le l_i \\le 16$) --- the number of limbs for each species.", "outputFormat": "Output the number of possible combinations of Pokémon in each habitat.\nOutput should contain $h$ lines with a single integer.", "hint": "For the sake of example we will use $\\LaTeX{}$ Pokémon: $\\c{O}$ has one limb, $\\angle$ has two limbs, $\\exists$ has three limbs. In the first example all three habitats have $6$ limbs.\n\n**In the first example** the first habitat has only one Pokémon species --- $\\exists$. So it is likely the young family containing $\\exists\\exists$.\n\nIn the second habitat there are two Pokémon species: $\\angle$ and $\\exists$. So it is either $\\angle\\angle\\angle$ or $\\exists\\exists$.\n\nThe third habitat may contain any of the three Pokémon species: $\\c{O}$, $\\angle$ and $\\exists$. There are seven possible combinations: $\\exists\\exists$, $\\angle\\angle\\angle$, $\\c{O}\\angle\\exists$, $\\c{O}\\c{O}\\angle\\angle$, $\\c{O}\\c{O}\\c{O}\\exists$, $\\c{O}\\c{O}\\c{O}\\c{O}\\angle$, $\\c{O}\\c{O}\\c{O}\\c{O}\\c{O}\\c{O}$.\n\n**In the second example** the first habitat has three Pokémon species, but all of them have only one limb: $\\partial$, $\\c{O}$ and $\\rho$. There are $10^9$ limbs and $\\sum_{i=0}^{i\\le 10^9}(i + 1)$ combinations.\n\nIn the second habitat no limbs were detected. So there are unfortunately no Pokémon left in the area. \n\nIn the third habitat all Pokémon have an even number of limbs, so it is not possible to have 17 limbs.", "locale": "en"}, "zh-CN": {"title": "[NERC2023] Joy of Pokémon Observation", "background": "", "description": "宝可梦保护协会致力于保护全球各地的宝可梦及其栖息地。在最近的研究中，研究人员收集了 $h$ 个栖息地的数据。\n\n每个栖息地可能栖息着若干种宝可梦。研究人员知道每种宝可梦的肢体数量。由于宝可梦行动敏捷且极善隐藏，研究人员只能检测到每个栖息地的肢体总数。\n\n研究人员明白可能无法确定每种宝可梦的具体数量，但希望了解剩余的不确定性有多少。有多少种不同的宝可梦组合会产生观察到的肢体数量？", "inputFormat": "第一行包含一个整数 $h$（$1 \\le h \\le 1\\,024$）——栖息地的数量。\n接下来的 $h$ 行描述每个栖息地。\n\n每行以两个整数 $t$ 和 $s$（$0 \\le t \\le 10^9$，$1 \\le s \\le 3$）开头，其中 $t$ 是肢体总数，$s$ 是该栖息地的宝可梦种类数。随后是 $s$ 个整数 $l_i$（$1 \\le l_i \\le 16$）——每种宝可梦的肢体数量。", "outputFormat": "输出每个栖息地可能的宝可梦组合数量。\n输出应包含 $h$ 行，每行一个整数。", "hint": "为了举例说明，我们将使用 $\\LaTeX{}$ 宝可梦：$\\c{O}$ 有 1 个肢体，$\\angle$ 有 2 个肢体，$\\exists$ 有 3 个肢体。在第一个样例中，所有三个栖息地都有 $6$ 个肢体。\n\n**在第一个样例中**，第一个栖息地只有一种宝可梦——$\\exists$。因此可能是由 $\\exists\\exists$ 组成的年轻家庭。\n\n第二个栖息地有两种宝可梦：$\\angle$ 和 $\\exists$。因此可能是 $\\angle\\angle\\angle$ 或 $\\exists\\exists$。\n\n第三个栖息地可能包含三种宝可梦中的任意一种：$\\c{O}$、$\\angle$ 和 $\\exists$。共有七种可能的组合：$\\exists\\exists$、$\\angle\\angle\\angle$、$\\c{O}\\angle\\exists$、$\\c{O}\\c{O}\\angle\\angle$、$\\c{O}\\c{O}\\c{O}\\exists$、$\\c{O}\\c{O}\\c{O}\\c{O}\\angle$、$\\c{O}\\c{O}\\c{O}\\c{O}\\c{O}\\c{O}$。\n\n**在第二个样例中**，第一个栖息地有三种宝可梦，但它们的肢体数都是 1：$\\partial$、$\\c{O}$ 和 $\\rho$。共有 $10^9$ 个肢体和 $\\sum_{i=0}^{i\\le 10^9}(i + 1)$ 种组合。\n\n第二个栖息地没有检测到肢体。因此该区域不幸地没有宝可梦存在。\n\n第三个栖息地的所有宝可梦都有偶数个肢体，因此不可能有 17 个肢体。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12442", "type": "P", "difficulty": 4, "samples": [["3\n1 2 3", "1"], ["5\n2 8 2 6 4", "16"], ["5\n5 7 1 3 5", "0"], ["11\n3 1 4 1 5 9 2 6 5 3 6", "386"], ["54\n2 1 1 1 1 2 1 2 2 2 2 1 1 1 2 1 1 2\n2 1 2 2 2 2 2 2 2 1 1 1 2 2 1 1 1 1\n2 2 1 1 2 2 2 2 2 1 1 1 2 2 1 2 1 1", "0"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "ICPC", "NERC/NEERC"], "title": "[NERC2023] Kim's Quest", "background": "", "description": "In the long-forgotten halls of Kombinatoria's ancient academy, a gifted mathematician named Kim is faced with an unusual challenge. They found an old sequence of integers, which is believed to be a cryptic message from the legendary Kombinatoria's Oracle, and Kim wants to decipher its hidden meaning.\n\nKim's mission is to find specific patterns within the sequence, known as *Harmonious Subsequences*. These are extraordinary subsequences where the sum of every three consecutive numbers is even, and each subsequence must be at least three numbers in length. \n\nGiven a sequence $a_i$ ($1 \\le i \\le n$) of length $n$, its *subsequence* of length $m$ is equal to $a_{b_1}, a_{b_2}, \\ldots, a_{b_m}$ and is uniquely defined by a set of $m$ indices $b_j$, such that $1 \\le b_1 < b_2 < \\ldots < b_m \\le n$. Subsequences given by different sets of indices $b_j$ are considered different.\n\nThere's a twist in Kim's quest: the number of these Harmonious Subsequences could be overwhelming. To report the findings effectively, Kim must calculate the total number of these subsequences, presenting the answer as a remainder after dividing by the number $998\\,244\\,353$.", "inputFormat": "The first line contains a single integer $n$ --- the length of the sequence ($3 \\le n \\le 2 \\cdot 10^5$).\n\nThe second line contains $n$ space-separated integers $a_i$ --- the elements of the sequence ($1 \\le a_i \\le 2 \\cdot 10^5$).", "outputFormat": "Output one number --- the number of Harmonious Subsequences, modulo $998\\,244\\,353$.", "hint": "In the provided input data for the fifth sample, the sequence of numbers is split into three separate lines for clarity, but it should be understood that in the actual test data, the sequence is given in one line. The actual number of Harmonious Subsequences in this example is $4\\,991\\,221\\,765 = 5 \\times 998\\,244\\,353$, hence the output is zero as a result of finding its remainder after dividing by the number $998\\,244\\,353$.", "locale": "en", "translations": {"en": {"title": "[NERC2023] Kim's Quest", "background": "", "description": "In the long-forgotten halls of Kombinatoria's ancient academy, a gifted mathematician named Kim is faced with an unusual challenge. They found an old sequence of integers, which is believed to be a cryptic message from the legendary Kombinatoria's Oracle, and Kim wants to decipher its hidden meaning.\n\nKim's mission is to find specific patterns within the sequence, known as *Harmonious Subsequences*. These are extraordinary subsequences where the sum of every three consecutive numbers is even, and each subsequence must be at least three numbers in length. \n\nGiven a sequence $a_i$ ($1 \\le i \\le n$) of length $n$, its *subsequence* of length $m$ is equal to $a_{b_1}, a_{b_2}, \\ldots, a_{b_m}$ and is uniquely defined by a set of $m$ indices $b_j$, such that $1 \\le b_1 < b_2 < \\ldots < b_m \\le n$. Subsequences given by different sets of indices $b_j$ are considered different.\n\nThere's a twist in Kim's quest: the number of these Harmonious Subsequences could be overwhelming. To report the findings effectively, Kim must calculate the total number of these subsequences, presenting the answer as a remainder after dividing by the number $998\\,244\\,353$.", "inputFormat": "The first line contains a single integer $n$ --- the length of the sequence ($3 \\le n \\le 2 \\cdot 10^5$).\n\nThe second line contains $n$ space-separated integers $a_i$ --- the elements of the sequence ($1 \\le a_i \\le 2 \\cdot 10^5$).", "outputFormat": "Output one number --- the number of Harmonious Subsequences, modulo $998\\,244\\,353$.", "hint": "In the provided input data for the fifth sample, the sequence of numbers is split into three separate lines for clarity, but it should be understood that in the actual test data, the sequence is given in one line. The actual number of Harmonious Subsequences in this example is $4\\,991\\,221\\,765 = 5 \\times 998\\,244\\,353$, hence the output is zero as a result of finding its remainder after dividing by the number $998\\,244\\,353$.", "locale": "en"}, "zh-CN": {"title": "[NERC2023] Kim's Quest", "background": "", "description": "在康比纳托里亚古老学院被遗忘的大厅里，一位名叫金姆的天才数学家面临着一个不寻常的挑战。他们发现了一个古老的整数序列，据信这是来自传奇的康比纳托里亚神谕的加密信息，金姆想要破译其中隐藏的含义。\n\n金姆的任务是在序列中寻找特定的模式，这些模式被称为**和谐子序列**。这些特殊的子序列需要满足每三个连续数字之和为偶数，且每个子序列的长度必须至少为三个数字。\n\n给定一个长度为 $n$ 的序列 $a_i$（$1 \\le i \\le n$），其长度为 $m$ 的**子序列**定义为 $a_{b_1}, a_{b_2}, \\ldots, a_{b_m}$，由一组 $m$ 个索引 $b_j$ 唯一确定，其中 $1 \\le b_1 < b_2 < \\ldots < b_m \\le n$。由不同索引集 $b_j$ 给出的子序列被视为不同的子序列。\n\n金姆的探索有一个转折：这些和谐子序列的数量可能非常庞大。为了有效地报告发现结果，金姆必须计算这些子序列的总数，并将答案对 $998\\,244\\,353$ 取模后输出。", "inputFormat": "第一行包含一个整数 $n$ —— 序列的长度（$3 \\le n \\le 2 \\cdot 10^5$）。\n\n第二行包含 $n$ 个用空格分隔的整数 $a_i$ —— 序列的元素（$1 \\le a_i \\le 2 \\cdot 10^5$）。\n", "outputFormat": "输出一个数字 —— 和谐子序列的数量，对 $998\\,244\\,353$ 取模后的结果。\n", "hint": "在第五个样例的输入数据中，数字序列被分成三行以提高可读性，但在实际的测试数据中，序列是以一行给出的。在这个例子中，实际的和谐子序列数量为 $4\\,991\\,221\\,765 = 5 \\times 998\\,244\\,353$，因此输出为零，因为这是其对 $998\\,244\\,353$ 取模后的结果。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12443", "type": "P", "difficulty": 2, "samples": [["3\nLOL", "-1"], ["2\nLO", "1"], ["4\nLLLO", "1"], ["4\nOLOL", "-1"], ["10\nLLOOOOLLLO", "5"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC2023] LOL Lovers", "background": "", "description": "There are $n$ food items lying in a row on a long table. Each of these items is either a loaf of bread (denoted as a capital Latin letter $\\texttt{L}$ with ASCII code 76) or an onion (denoted as a capital Latin letter $\\texttt{O}$ with ASCII code 79). There is at least one loaf of bread and at least one onion on the table.\n\nYou and your friend want to divide the food on the table: you will take a prefix of this row (several leftmost items), and the friend will take the rest. However, there are several restrictions:\n\n- Each person should have at least one item.\n- The number of your loaves should differ from the number of your friend's loaves.\n- The number of your onions should differ from the number of your friend's onions.\n\nFind any correct division and print the number of items you take or report that there is no answer.", "inputFormat": "The first line contains one integer $n$ ($2 \\le n \\le 200$) --- the number of food items on the table. The second line contains a string of length $n$ consisting of letters $\\texttt{L}$ and $\\texttt{O}$. $i$-th symbol represents the type of the $i$-th food item on the table: $\\texttt{L}$ stands for a loaf of bread, and $\\texttt{O}$ stands for an onion. It is guaranteed that this string contains at least one letter $\\texttt{L}$ and at least one letter $\\texttt{O}$.", "outputFormat": "Print one integer --- a number $k$ such that, if you take $k$ leftmost items and your friend takes the remaining $n - k$ items, each of you and your friend get at least one item, your number of loaves is different from your friend's, and your number of onions is different from your friend's. If there are several possible answers, print any of them. If there are no possible answers, print the number $-1$.", "hint": "In the first example, in any division the left and the right part contain one loaf of bread.\n\nIn the second example, the division is $\\texttt{L}$ and $\\texttt{O}$, and in these two strings the number of loaves is different (1 and 0) and the number of onions is different (0 and 1).\n\nIn the third example, any number 1, 2 or 3 is a correct answer.\n", "locale": "en", "translations": {"en": {"title": "[NERC2023] LOL Lovers", "background": "", "description": "There are $n$ food items lying in a row on a long table. Each of these items is either a loaf of bread (denoted as a capital Latin letter $\\texttt{L}$ with ASCII code 76) or an onion (denoted as a capital Latin letter $\\texttt{O}$ with ASCII code 79). There is at least one loaf of bread and at least one onion on the table.\n\nYou and your friend want to divide the food on the table: you will take a prefix of this row (several leftmost items), and the friend will take the rest. However, there are several restrictions:\n\n- Each person should have at least one item.\n- The number of your loaves should differ from the number of your friend's loaves.\n- The number of your onions should differ from the number of your friend's onions.\n\nFind any correct division and print the number of items you take or report that there is no answer.", "inputFormat": "The first line contains one integer $n$ ($2 \\le n \\le 200$) --- the number of food items on the table. The second line contains a string of length $n$ consisting of letters $\\texttt{L}$ and $\\texttt{O}$. $i$-th symbol represents the type of the $i$-th food item on the table: $\\texttt{L}$ stands for a loaf of bread, and $\\texttt{O}$ stands for an onion. It is guaranteed that this string contains at least one letter $\\texttt{L}$ and at least one letter $\\texttt{O}$.", "outputFormat": "Print one integer --- a number $k$ such that, if you take $k$ leftmost items and your friend takes the remaining $n - k$ items, each of you and your friend get at least one item, your number of loaves is different from your friend's, and your number of onions is different from your friend's. If there are several possible answers, print any of them. If there are no possible answers, print the number $-1$.", "hint": "In the first example, in any division the left and the right part contain one loaf of bread.\n\nIn the second example, the division is $\\texttt{L}$ and $\\texttt{O}$, and in these two strings the number of loaves is different (1 and 0) and the number of onions is different (0 and 1).\n\nIn the third example, any number 1, 2 or 3 is a correct answer.\n", "locale": "en"}, "zh-CN": {"title": "[NERC2023] LOL Lovers", "background": "", "description": "在一张长桌上摆放着排成一行的 $n$ 个食物。每个食物要么是一个面包（用大写拉丁字母 $\\texttt{L}$ 表示，ASCII 码为 76），要么是一个洋葱（用大写拉丁字母 $\\texttt{O}$ 表示，ASCII 码为 79）。桌上至少有一个面包和一个洋葱。\n\n你和你的朋友想要分配桌上的食物：你将拿走这排食物的一个前缀（最左边的若干个物品），而你的朋友将拿走剩下的部分。然而，分配需要满足以下几个限制条件：\n\n- 每个人都必须至少拿到一个物品。\n- 你拿到的面包数量必须与朋友拿到的面包数量不同。\n- 你拿到的洋葱数量必须与朋友拿到的洋葱数量不同。\n\n请找出任意一个满足条件的分割方案，并输出你拿走的物品数量；如果不存在这样的方案，则报告无解。", "inputFormat": "第一行包含一个整数 $n$（$2 \\le n \\le 200$）——桌上食物的数量。  \n第二行包含一个长度为 $n$ 的字符串，由字母 $\\texttt{L}$ 和 $\\texttt{O}$ 组成。第 $i$ 个字符表示桌上第 $i$ 个食物的类型：$\\texttt{L}$ 代表面包，$\\texttt{O}$ 代表洋葱。保证该字符串中至少有一个 $\\texttt{L}$ 和一个 $\\texttt{O}$。", "outputFormat": "输出一个整数 $k$，表示如果你拿走最左边的 $k$ 个物品，而你的朋友拿走剩下的 $n - k$ 个物品，那么：  \n- 你和朋友各自至少拿到一个物品；\n- 你的面包数量与朋友的面包数量不同；\n- 你的洋葱数量与朋友的洋葱数量不同。  \n\n如果存在多个可能的答案，输出其中任意一个即可。如果不存在满足条件的分割方案，则输出 $-1$。", "hint": "在第一个样例中，任何分割方式下，左边和右边的部分都各有一个面包，因此无法满足条件。  \n\n在第二个样例中，分割为 $\\texttt{L}$ 和 $\\texttt{O}$，此时两边的面包数量不同（1 和 0），洋葱数量也不同（0 和 1）。  \n\n在第三个样例中，任意选择 1、2 或 3 作为 $k$ 都是正确答案。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12444", "type": "P", "difficulty": 5, "samples": [["2 100\n1\n10 10\n101 100", "0"], ["5 7\n1 1 2 2\n2 1 2 3 3\n4 2 4 2 3", "6"], ["4 9\n1 2 2\n3 4 4 2\n2 5 5 4", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2025", "Ad-hoc", "COTS（克罗地亚）"], "title": "[COTS 2025] 发好奖 / Hijerarhija", "background": "", "description": "\n$N$ 个人的上下级关系构成一棵树。第 $1$ 个人为总监，第 $i$（$i\\ge 2$）个人的直接上级为 $s_i$。\n\n现在要给员工分配奖金。每个人的奖金可以是正整数，或者 $0$（没有奖金）。如果第 $i$ 个人获得了至少 $c_i$ 的奖金，下一年他的**积极性**会提高 $p_i$，否则积极性不会提高。\n\n并非所有人都必须获得奖金，但是每个获得奖金的人的直接上级必须获得至少 $1$ 的奖金。\n\n在发出的奖金总额不超过 $K$ 的前提下，求出积极性提高的总和最大值。", "inputFormat": "\n> $N$ $K$\\\n> $s_2$ $s_3$ $\\ldots$ $s_N$\\\n> $p_1$ $p_2$ $\\ldots$ $p_N$\\\n> $c_1$ $c_2$ $\\ldots$ $c_N$", "outputFormat": "一行一个非负整数，表示答案。\n", "hint": "\n### 样例解释\n\n样例 $2$ 解释：\n\n一个合法的奖金分配方案：员工依次获得的奖金为 $1,1,0,2,3$。\n\n分配方案 $1,1,1,2,3$ 不合法，因为奖金超支了。  \n\n分配方案 $0,1,1,2,3$ 同样不合法，因为第 $2$ 个人获得了奖金，但其直接上级未获得。\n\n\n### 数据范围\n\n- $2\\le N\\le 5\\, 000$；\n- $1\\le K\\le 5\\, 000$；\n- $1\\le p_i\\le 10^5$；\n- $1\\le c_i\\le 5\\, 000$；\n- $1\\le s_i\\lt i$；\n- 输入的所有值均为整数。\n\n### 子任务\n\n子任务 $0$ 为样例。\n\n其中，「$-$」表示「不保证」。\n\n| 子任务编号 | $N\\le$ | $K\\le$ | 特殊性质 | 得分 |\n| :-: | :-: | :-: | :-: | :-: |\n| $1$ | $20$ | $-$ | $-$  |  $7$ |\n| $2$ | $-$ | $-$ | $\\text{A}$ |  $9$ |\n| $3$ | $-$ | $-$ | $\\text{B}$ |  $14$ |\n| $4$ | $500$ | $500$ | $-$  |  $19$ |\n| $5$ | $100$ | $-$ | $-$ |  $21$ |\n| $6$ | $-$ | $-$ | $-$ |  $30$ |\n\n- 特殊性质 $\\text{A}$：$c_i=1$，且 $j$ 是 $i$ 的上级 $\\implies$ $p_j\\ge p_i$。\n- 特殊性质 $\\text{B}$：$\\forall 2\\le i\\le N$，$s_i=i-1$。\n\n2025-06-03: 增加了一组 hack 数据", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COTS 2025] 发好奖 / Hijerarhija", "background": "", "description": "\n$N$ 个人的上下级关系构成一棵树。第 $1$ 个人为总监，第 $i$（$i\\ge 2$）个人的直接上级为 $s_i$。\n\n现在要给员工分配奖金。每个人的奖金可以是正整数，或者 $0$（没有奖金）。如果第 $i$ 个人获得了至少 $c_i$ 的奖金，下一年他的**积极性**会提高 $p_i$，否则积极性不会提高。\n\n并非所有人都必须获得奖金，但是每个获得奖金的人的直接上级必须获得至少 $1$ 的奖金。\n\n在发出的奖金总额不超过 $K$ 的前提下，求出积极性提高的总和最大值。", "inputFormat": "\n> $N$ $K$\\\n> $s_2$ $s_3$ $\\ldots$ $s_N$\\\n> $p_1$ $p_2$ $\\ldots$ $p_N$\\\n> $c_1$ $c_2$ $\\ldots$ $c_N$", "outputFormat": "一行一个非负整数，表示答案。\n", "hint": "\n### 样例解释\n\n样例 $2$ 解释：\n\n一个合法的奖金分配方案：员工依次获得的奖金为 $1,1,0,2,3$。\n\n分配方案 $1,1,1,2,3$ 不合法，因为奖金超支了。  \n\n分配方案 $0,1,1,2,3$ 同样不合法，因为第 $2$ 个人获得了奖金，但其直接上级未获得。\n\n\n### 数据范围\n\n- $2\\le N\\le 5\\, 000$；\n- $1\\le K\\le 5\\, 000$；\n- $1\\le p_i\\le 10^5$；\n- $1\\le c_i\\le 5\\, 000$；\n- $1\\le s_i\\lt i$；\n- 输入的所有值均为整数。\n\n### 子任务\n\n子任务 $0$ 为样例。\n\n其中，「$-$」表示「不保证」。\n\n| 子任务编号 | $N\\le$ | $K\\le$ | 特殊性质 | 得分 |\n| :-: | :-: | :-: | :-: | :-: |\n| $1$ | $20$ | $-$ | $-$  |  $7$ |\n| $2$ | $-$ | $-$ | $\\text{A}$ |  $9$ |\n| $3$ | $-$ | $-$ | $\\text{B}$ |  $14$ |\n| $4$ | $500$ | $500$ | $-$  |  $19$ |\n| $5$ | $100$ | $-$ | $-$ |  $21$ |\n| $6$ | $-$ | $-$ | $-$ |  $30$ |\n\n- 特殊性质 $\\text{A}$：$c_i=1$，且 $j$ 是 $i$ 的上级 $\\implies$ $p_j\\ge p_i$。\n- 特殊性质 $\\text{B}$：$\\forall 2\\le i\\le N$，$s_i=i-1$。\n\n2025-06-03: 增加了一组 hack 数据", "locale": "zh-CN"}}}
{"pid": "P12445", "type": "P", "difficulty": 7, "samples": [["2 1000000007", "1 0 1"], ["3 1000000007", "3 0 3 2"], ["5 1000000007", "183 0 183 286 250 122"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "容斥原理", "COTS（克罗地亚）"], "title": "[COTS 2025] 数好图 / Promet", "background": "", "description": "\n给定正整数 $N$ 和素数 $P$。\n\n$\\forall K=0,1,\\ldots,N$，求出满足以下条件的**简单**有向图的数量：\n\n- 图中仅包含 $i\\to j$（$1\\le i\\lt j\\le N$）的边；\n- 满足以下条件的点 $u$ 恰好有 $K$ 个：\n\t- 存在 $1\\to u$ 和 $u\\to N$ 的路径。\n\n只需要输出答案对 $P$ 取模后的结果。", "inputFormat": "> $N$ $P$\n", "outputFormat": "输出一行 $(N+1)$ 个非负整数，第 $i$ 个数表示 $K=i-1$ 时的答案。\n", "hint": "\n### 样例解释\n\n样例 $2$ 解释：\n\n$K=0$ 的时候，根据定义，下面三个边集合法：\n\n- $\\varnothing$；\n- $\\{(1, 2)\\}$；\n- $\\{(2, 3)\\}$。\n\n\n$K=2$ 时，合法的边集：\n\n- $\\{(1, 3)\\}$；\n- $\\{(1, 3), (1, 2)\\}$；\n- $\\{(1, 3), (2, 3)\\}$。\n\n$K=3$ 时，合法的边集：\n\n- $\\{(1, 2), (2, 3)\\}$；\n- $\\{(1, 2), (1, 3), (2, 3)\\}$。\n\n### 数据范围\n\n- $2\\le N\\le 2\\,000$；\n- $10^8\\le P\\le 10^9+100$；\n- $P$ 是素数。\n### 子任务\n\n子任务 $0$ 为样例。\n\n| 子任务编号 | $N\\le$ | 得分 |\n| :-: | :-: | :-: |\n| $1$ | $7$ | $4$ |\n| $2$ | $18$ | $7$ |\n| $3$ | $50$ | $23$ |\n| $4$ | $100$ | $13$ |\n| $5$ | $300$ | $18$ |\n| $6$ | $2\\,000$ | $35$ |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COTS 2025] 数好图 / Promet", "background": "", "description": "\n给定正整数 $N$ 和素数 $P$。\n\n$\\forall K=0,1,\\ldots,N$，求出满足以下条件的**简单**有向图的数量：\n\n- 图中仅包含 $i\\to j$（$1\\le i\\lt j\\le N$）的边；\n- 满足以下条件的点 $u$ 恰好有 $K$ 个：\n\t- 存在 $1\\to u$ 和 $u\\to N$ 的路径。\n\n只需要输出答案对 $P$ 取模后的结果。", "inputFormat": "> $N$ $P$\n", "outputFormat": "输出一行 $(N+1)$ 个非负整数，第 $i$ 个数表示 $K=i-1$ 时的答案。\n", "hint": "\n### 样例解释\n\n样例 $2$ 解释：\n\n$K=0$ 的时候，根据定义，下面三个边集合法：\n\n- $\\varnothing$；\n- $\\{(1, 2)\\}$；\n- $\\{(2, 3)\\}$。\n\n\n$K=2$ 时，合法的边集：\n\n- $\\{(1, 3)\\}$；\n- $\\{(1, 3), (1, 2)\\}$；\n- $\\{(1, 3), (2, 3)\\}$。\n\n$K=3$ 时，合法的边集：\n\n- $\\{(1, 2), (2, 3)\\}$；\n- $\\{(1, 2), (1, 3), (2, 3)\\}$。\n\n### 数据范围\n\n- $2\\le N\\le 2\\,000$；\n- $10^8\\le P\\le 10^9+100$；\n- $P$ 是素数。\n### 子任务\n\n子任务 $0$ 为样例。\n\n| 子任务编号 | $N\\le$ | 得分 |\n| :-: | :-: | :-: |\n| $1$ | $7$ | $4$ |\n| $2$ | $18$ | $7$ |\n| $3$ | $50$ | $23$ |\n| $4$ | $100$ | $13$ |\n| $5$ | $300$ | $18$ |\n| $6$ | $2\\,000$ | $35$ |\n", "locale": "zh-CN"}}}
{"pid": "P12446", "type": "P", "difficulty": 6, "samples": [["4\n\n2\n\n1\n\n2\n1 4\n2 3\n\n", "\n? 1 2\n\n? 1 3\n\n!\n\n\n\n4\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "交互题", "Special Judge", "COTS（克罗地亚）"], "title": "[COTS 2025] 答好位 / Vrsta", "background": "", "description": "\n**这是一道交互题。交互库是非自适应的。**\n\n有一个隐藏的 $1\\sim N$ 的排列 $p_1,\\ldots,p_N$。\n\n你可以提问交互库至多 $K$ 次，每次给定 $i,j$（$1\\le i\\lt j\\le N$），交互库会回答 $p_{i},p_{i+1},\\ldots,p_{j}$ 中次大元素的下标。\n\n在你提问完后，交互库会向你提问 $Q$ 次，每次给定 $a,b$（$1\\le a\\lt b\\le N$），你需要回答 $p_{a},p_{a+1},\\ldots,p_{b}$ 中次大元素的下标。\n\n请注意：在你提问完之后，才能得知交互库的提问。这 $Q$ 次交互库对你的提问一次性给出。\n\n### 实现细节\n\n首先读入正整数 $N$。\n\n接下来，发起至多 $K$ 次提问：\n\n- $\\texttt{?}$ $i$ $j$：提问 $p_{i},p_{i+1},\\ldots,p_{j}$ 中次大元素的下标。\n    - 你需要保证 $1\\le i\\lt j\\le N$。\n- $\\texttt{!}$：结束提问。\n\n每次提问后，都需要换行并刷新缓冲区。\n\n在结束提问后，读入正整数 $Q$，以及 $Q$ 对正整数 $a,b$，表示对交互库你的提问。交互库保证 $1\\le a\\lt b\\le N$。\n\n对于每个交互库的提问，输出一行一个正整数，表示次大元素的下标。\n\n在你回答完所有询问后，你需要刷新缓冲区，然后终止程序运行。\n\n**交互库是非自适应的**。也就是说，询问和排列在交互开始前就已经固定。\n", "inputFormat": "见「实现细节」。\n", "outputFormat": "见「实现细节」。\n", "hint": "\n### 样例解释\n\n样例的排列为 $p=[2,1,4,3]$。\n\n### 数据范围\n\n- $N\\le 512$；\n- $K=Q=2\\, 048$。\n\n### 子任务\n子任务 $0$ 为样例。\n\n其中，「$-$」表示「不保证」。\n\n| 子任务编号 | $N\\le$ |特殊性质 | 得分 |\n| :-: | :-: |  :-: | :-: |\n| $1$ | $64$ | $-$  |  $6$ |\n| $2$ | $-$ | $\\text{A}$ |  $10$ |\n| $3$ | $-$ | $\\text{B}$ |  $11$ |\n| $4$ | $-$ | $\\text{C}$  |  $13$ |\n| $5$ | $256$ | $-$ |  $26$ |\n| $6$ | $-$ |$-$ |  $34$ |\n\n\n- 特殊性质 $\\text{A}$：不存在 $i$ 使得 $p_i\\gt \\max\\{p_{i-1},p_{i+1}\\}$。\n- 特殊性质 $\\text{B}$：$p_1=N$。\n- 特殊性质 $\\text{C}$：不存在 $i$ 使得 $p_i\\lt \\min\\{p_{i-1},p_{i+1}\\}$。\n\n\n**交互库是非自适应的**。也就是说，询问和排列在交互开始前就已经固定。\n\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COTS 2025] 答好位 / Vrsta", "background": "", "description": "\n**这是一道交互题。交互库是非自适应的。**\n\n有一个隐藏的 $1\\sim N$ 的排列 $p_1,\\ldots,p_N$。\n\n你可以提问交互库至多 $K$ 次，每次给定 $i,j$（$1\\le i\\lt j\\le N$），交互库会回答 $p_{i},p_{i+1},\\ldots,p_{j}$ 中次大元素的下标。\n\n在你提问完后，交互库会向你提问 $Q$ 次，每次给定 $a,b$（$1\\le a\\lt b\\le N$），你需要回答 $p_{a},p_{a+1},\\ldots,p_{b}$ 中次大元素的下标。\n\n请注意：在你提问完之后，才能得知交互库的提问。这 $Q$ 次交互库对你的提问一次性给出。\n\n### 实现细节\n\n首先读入正整数 $N$。\n\n接下来，发起至多 $K$ 次提问：\n\n- $\\texttt{?}$ $i$ $j$：提问 $p_{i},p_{i+1},\\ldots,p_{j}$ 中次大元素的下标。\n    - 你需要保证 $1\\le i\\lt j\\le N$。\n- $\\texttt{!}$：结束提问。\n\n每次提问后，都需要换行并刷新缓冲区。\n\n在结束提问后，读入正整数 $Q$，以及 $Q$ 对正整数 $a,b$，表示对交互库你的提问。交互库保证 $1\\le a\\lt b\\le N$。\n\n对于每个交互库的提问，输出一行一个正整数，表示次大元素的下标。\n\n在你回答完所有询问后，你需要刷新缓冲区，然后终止程序运行。\n\n**交互库是非自适应的**。也就是说，询问和排列在交互开始前就已经固定。\n", "inputFormat": "见「实现细节」。\n", "outputFormat": "见「实现细节」。\n", "hint": "\n### 样例解释\n\n样例的排列为 $p=[2,1,4,3]$。\n\n### 数据范围\n\n- $N\\le 512$；\n- $K=Q=2\\, 048$。\n\n### 子任务\n子任务 $0$ 为样例。\n\n其中，「$-$」表示「不保证」。\n\n| 子任务编号 | $N\\le$ |特殊性质 | 得分 |\n| :-: | :-: |  :-: | :-: |\n| $1$ | $64$ | $-$  |  $6$ |\n| $2$ | $-$ | $\\text{A}$ |  $10$ |\n| $3$ | $-$ | $\\text{B}$ |  $11$ |\n| $4$ | $-$ | $\\text{C}$  |  $13$ |\n| $5$ | $256$ | $-$ |  $26$ |\n| $6$ | $-$ |$-$ |  $34$ |\n\n\n- 特殊性质 $\\text{A}$：不存在 $i$ 使得 $p_i\\gt \\max\\{p_{i-1},p_{i+1}\\}$。\n- 特殊性质 $\\text{B}$：$p_1=N$。\n- 特殊性质 $\\text{C}$：不存在 $i$ 使得 $p_i\\lt \\min\\{p_{i-1},p_{i+1}\\}$。\n\n\n**交互库是非自适应的**。也就是说，询问和排列在交互开始前就已经固定。\n\n\n", "locale": "zh-CN"}}}
