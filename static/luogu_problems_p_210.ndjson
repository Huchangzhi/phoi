{"pid": "P5246", "type": "P", "difficulty": 7, "samples": [["0\n2\n2 3\n4 7", "5\n11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "集训队互测", "提交答案"], "title": "[集训队互测 2016] 消失的源代码", "background": "翻开古老的试题，发现题面已模糊不清。   \n选手们的源代码也已经消失。   \n只剩下编译后的可执行程序。  \n你找到了输入文件，希望重新生成输出文件。", "description": "给出可执行程序 $\\texttt{lost}$，和输入文件 $\\texttt{input*.txt}$，对于每一个输入文件，求出它对应的输出文件。    \n$\\texttt{lost}$ 的输入和输出是标准输入输出。可以在命令行中对输入输出进行重定向。  \n还下发了一个可执行程序 $\\texttt{lost2}$，它从 $\\texttt{input.txt}$ 中读入，输出到 $\\texttt{output.txt}$。除此以外 $\\texttt{lost2}$ 和 $\\texttt{lost}$ 完全相同。可以根据习惯选用 $\\texttt{lost}$ 或 $\\texttt{lost2}$。   \n$\\text{lost}$ 并不完美，当数据规模较大时，它或许不能成功运行，此时会直接输出 `invalid input.`", "inputFormat": "第一行一个整数，表示数据类型。$\\texttt{lost}$ 会根据数据类型，完成相应的计算。例如数据类型为 $0$ 时，$\\texttt{lost}$会计算 $\\texttt{A+B Problem}$ ( $\\texttt{input0.txt}$、$\\texttt{output0.txt}$ )。  \n第二行一个整数，表示数据组数。    \n接下来是每一组数据。输入格式由数据类型确定。   \n当数据规模不超过第一组数据时，保证 $\\texttt{lost}$ 能够正常运行。   \n只有数据组数不超过一组时，保证 $\\texttt{lost}$ 的输出正确。", "outputFormat": "对于每组数据，输出一行。", "hint": "[输入数据下载](http://uoj.ac/download.php?type=problem&id=190)", "locale": "zh-CN", "translations": {"en": {"title": "[Training Team Mutual Test 2016] The Disappeared Source Code", "background": "Opening an old set of problems, you find the statement has become blurry and unclear.  \nThe contestants’ source code has also disappeared.  \nOnly the compiled executable program remains.  \nYou found the input files and hope to regenerate the output files.", "description": "Given the executable program $\\texttt{lost}$ and the input files $\\texttt{input*.txt}$, for each input file, compute its corresponding output file.  \n$\\texttt{lost}$ uses standard input and output. You can redirect input and output in the command line.  \nAn executable program $\\texttt{lost2}$ is also provided. It reads from $\\texttt{input.txt}$ and writes to $\\texttt{output.txt}$. Other than that, $\\texttt{lost2}$ is exactly the same as $\\texttt{lost}$. You may choose $\\texttt{lost}$ or $\\texttt{lost2}$ according to your habit.  \n$\\text{lost}$ is not perfect. When the data size is large, it may fail to run successfully, and in this case it will directly output `invalid input!`.", "inputFormat": "The first line contains an integer representing the data type. $\\texttt{lost}$ will perform the corresponding computation based on the data type. For example, when the data type is $0$, $\\texttt{lost}$ will compute the $\\texttt{A+B Problem}$ ( $\\texttt{input0.txt}$, $\\texttt{output0.txt}$ ).  \nThe second line contains an integer representing the number of test cases.  \nThen follows each test case. The input format is determined by the data type.  \nWhen the data size does not exceed the first test case, it is guaranteed that $\\texttt{lost}$ can run normally.  \nOnly when the number of test cases does not exceed one, it is guaranteed that the output of $\\texttt{lost}$ is correct.", "outputFormat": "For each test case, output one line.", "hint": "[Download input data](http://uoj.ac/download.php?type=problem&id=190)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[集训队互测 2016] 消失的源代码", "background": "翻开古老的试题，发现题面已模糊不清。   \n选手们的源代码也已经消失。   \n只剩下编译后的可执行程序。  \n你找到了输入文件，希望重新生成输出文件。", "description": "给出可执行程序 $\\texttt{lost}$，和输入文件 $\\texttt{input*.txt}$，对于每一个输入文件，求出它对应的输出文件。    \n$\\texttt{lost}$ 的输入和输出是标准输入输出。可以在命令行中对输入输出进行重定向。  \n还下发了一个可执行程序 $\\texttt{lost2}$，它从 $\\texttt{input.txt}$ 中读入，输出到 $\\texttt{output.txt}$。除此以外 $\\texttt{lost2}$ 和 $\\texttt{lost}$ 完全相同。可以根据习惯选用 $\\texttt{lost}$ 或 $\\texttt{lost2}$。   \n$\\text{lost}$ 并不完美，当数据规模较大时，它或许不能成功运行，此时会直接输出 `invalid input.`", "inputFormat": "第一行一个整数，表示数据类型。$\\texttt{lost}$ 会根据数据类型，完成相应的计算。例如数据类型为 $0$ 时，$\\texttt{lost}$会计算 $\\texttt{A+B Problem}$ ( $\\texttt{input0.txt}$、$\\texttt{output0.txt}$ )。  \n第二行一个整数，表示数据组数。    \n接下来是每一组数据。输入格式由数据类型确定。   \n当数据规模不超过第一组数据时，保证 $\\texttt{lost}$ 能够正常运行。   \n只有数据组数不超过一组时，保证 $\\texttt{lost}$ 的输出正确。", "outputFormat": "对于每组数据，输出一行。", "hint": "[输入数据下载](http://uoj.ac/download.php?type=problem&id=190)", "locale": "zh-CN"}}}
{"pid": "P5247", "type": "P", "difficulty": 7, "samples": [["200 5\n2 123 127\n0 4 0\n2 4 0\n1 4 0\n2 0 4", "N\nY\nN"], ["4 10\n0 1 2\n0 2 3\n0 3 1\n2 1 4\n0 0 7\n2 5 0\n1 3 2\n2 0 5\n1 0 2\n2 0 5", "N\nY\nY\nN"]], "limits": {"time": [1000, 1000, 2000, 2000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["图论", "动态树 LCT", "模板题"], "title": "【模板】动态图连通性", "background": "这是 [LOJ #122](https://loj.ac/problem/122) 的一个非官方、**不维护**的镜像，原始出题人是 EtaoinWu ，在本站的原始上传者未知。这个镜像题的数据不保证是最新的，因此推荐到 LOJ 进行练习。", "description": "这是一道模板题。\n\n你要维护一张无向简单图（即没有自环，没有重边的无向图）。你被要求加入删除一条边及查询两个点是否连通。\n\n$0.$：加入一条边。保证它不存在。   \n$1.$：删除一条边。保证它存在。   \n$2.$：查询两个点是否联通。   \n\n为了保证做法的在线性，本题采用了特殊方式的读入。\n\n假设你维护了一个变量 $\\text{last}$，初始值为 $0$ 。\n\n对于每个读入的节点 $x$，实际上询问、修改的节点编号是 $x \\text{ xor } \\text{last}$，其中 $\\text{xor}$ 是二进制异或操作。\n\n对于每次解码之后查询 $u,v$，如果它们联通，那么 $\\text{last}$ 会被更新为 $u$；否则会被更新为 $v$。", "inputFormat": "输入的第一行是两个数 $n,m$。\n\n接下来 $m$ 行，每一行三个数 $\\text{op},x,y$。$\\text{op}$ 表示操作编号。", "outputFormat": "对于每一个$op=2$ 的询问，输出一行 `Y` 或 `N` ，表示两个节点是否连通。", "hint": "由于hack数据的加入，数据分布并非如下文所述。下面的仅供参考。\n\n对于数据点 $1$，$n \\leq 200,m \\leq 200$\n\n对于数据点 $2$，$n=5,m \\leq 30$\n\n对于数据点 $3$，$n=10,m \\leq 1000$，其中查询的次数 $\\geq 900$ 次。\n\n对于数据点 $4$，$n=300,m \\leq 50000$\n\n对于数据点 $5$，$n=5000,m \\leq 200000$，没有操作 $1$，其中约 $70 \\%$ 是操作 $2$。\n\n对于数据点 $6$，$n=5000,m \\leq 200000$，没有操作 $1$，其中约 $70 \\%$ 是操作 $0$。\n\n对于数据点 $7$、$8$，$n=100,m \\leq 500000$\n\n对于数据点 $9$，$n=5000,m \\leq 500000$，图是一棵树，其直径 $\\leq 30$ 。\n\n对于数据点 $10$， $n=5000,m \\leq 500000$，图是一棵树，其每个点度数 $\\leq 10$。\n\n还有一些保证 $n \\leq 5000,m \\leq 500000$ 的附加数据。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Dynamic Graph Connectivity", "background": "This is an unofficial, **unmaintained** mirror of [LOJ #122](https://loj.ac/problem/122). The original problem setter is EtaoinWu, and the original uploader on this site is unknown. The testdata of this mirror is not guaranteed to be the latest, so it is recommended to practice on LOJ.", "description": "This is a template problem.\n\nYou need to maintain an undirected simple graph (that is, an undirected graph with no self-loops and no multiple edges). You are required to add an edge, delete an edge, and query whether two vertices are connected.\n\n$0.$: Add an edge. It is guaranteed that it does not exist.  \n$1.$: Delete an edge. It is guaranteed that it exists.  \n$2.$: Query whether two vertices are connected.  \n\nTo keep the solution online, this problem uses a special input method.\n\nAssume you maintain a variable $\\text{last}$, with initial value $0$.\n\nFor each input vertex $x$, the actual vertex index used in the query or modification is $x \\text{ xor } \\text{last}$, where $\\text{xor}$ is the bitwise XOR operation.\n\nAfter decoding each query $u,v$, if they are connected, then $\\text{last}$ will be updated to $u$; otherwise it will be updated to $v$.", "inputFormat": "The first line contains two integers $n,m$.\n\nThe next $m$ lines each contain three integers $\\text{op},x,y$. $\\text{op}$ denotes the operation number.", "outputFormat": "For each query with $op=2$, output one line `Y` or `N`, indicating whether the two vertices are connected.", "hint": "Due to the addition of hack testdata, the data distribution is not as described below. The following is for reference only.\n\nFor test point $1$, $n \\leq 200,m \\leq 200$.\n\nFor test point $2$, $n=5,m \\leq 30$.\n\nFor test point $3$, $n=10,m \\leq 1000$, and the number of queries is $\\geq 900$.\n\nFor test point $4$, $n=300,m \\leq 50000$.\n\nFor test point $5$, $n=5000,m \\leq 200000$, there is no operation $1$, and about $70 \\%$ are operation $2$.\n\nFor test point $6$, $n=5000,m \\leq 200000$, there is no operation $1$, and about $70 \\%$ are operation $0$.\n\nFor test point $7$ and $8$, $n=100,m \\leq 500000$.\n\nFor test point $9$, $n=5000,m \\leq 500000$, the graph is a tree, and its diameter is $\\leq 30$.\n\nFor test point $10$, $n=5000,m \\leq 500000$, the graph is a tree, and the degree of each vertex is $\\leq 10$.\n\nThere is also some additional testdata with guarantees $n \\leq 5000,m \\leq 500000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】动态图连通性", "background": "这是 [LOJ #122](https://loj.ac/problem/122) 的一个非官方、**不维护**的镜像，原始出题人是 EtaoinWu ，在本站的原始上传者未知。这个镜像题的数据不保证是最新的，因此推荐到 LOJ 进行练习。", "description": "这是一道模板题。\n\n你要维护一张无向简单图（即没有自环，没有重边的无向图）。你被要求加入删除一条边及查询两个点是否连通。\n\n$0.$：加入一条边。保证它不存在。   \n$1.$：删除一条边。保证它存在。   \n$2.$：查询两个点是否联通。   \n\n为了保证做法的在线性，本题采用了特殊方式的读入。\n\n假设你维护了一个变量 $\\text{last}$，初始值为 $0$ 。\n\n对于每个读入的节点 $x$，实际上询问、修改的节点编号是 $x \\text{ xor } \\text{last}$，其中 $\\text{xor}$ 是二进制异或操作。\n\n对于每次解码之后查询 $u,v$，如果它们联通，那么 $\\text{last}$ 会被更新为 $u$；否则会被更新为 $v$。", "inputFormat": "输入的第一行是两个数 $n,m$。\n\n接下来 $m$ 行，每一行三个数 $\\text{op},x,y$。$\\text{op}$ 表示操作编号。", "outputFormat": "对于每一个$op=2$ 的询问，输出一行 `Y` 或 `N` ，表示两个节点是否连通。", "hint": "由于hack数据的加入，数据分布并非如下文所述。下面的仅供参考。\n\n对于数据点 $1$，$n \\leq 200,m \\leq 200$\n\n对于数据点 $2$，$n=5,m \\leq 30$\n\n对于数据点 $3$，$n=10,m \\leq 1000$，其中查询的次数 $\\geq 900$ 次。\n\n对于数据点 $4$，$n=300,m \\leq 50000$\n\n对于数据点 $5$，$n=5000,m \\leq 200000$，没有操作 $1$，其中约 $70 \\%$ 是操作 $2$。\n\n对于数据点 $6$，$n=5000,m \\leq 200000$，没有操作 $1$，其中约 $70 \\%$ 是操作 $0$。\n\n对于数据点 $7$、$8$，$n=100,m \\leq 500000$\n\n对于数据点 $9$，$n=5000,m \\leq 500000$，图是一棵树，其直径 $\\leq 30$ 。\n\n对于数据点 $10$， $n=5000,m \\leq 500000$，图是一棵树，其每个点度数 $\\leq 10$。\n\n还有一些保证 $n \\leq 5000,m \\leq 500000$ 的附加数据。", "locale": "zh-CN"}}}
{"pid": "P5248", "type": "P", "difficulty": 2, "samples": [["10 10", "2\n0 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["Special Judge", "O2优化", "进制"], "title": "[LnOI2019SP] 快速多项式变换(FPT)", "background": "![avartar](https://cdn.luogu.com.cn/upload/pic/52800.png)", "description": "这是一道构造题。\n\n诗乃在心中想了一个$n+1$项的多项式$f(x)$。第$i$项次数为$i$，系数为$a_i$：\n\n$$f(x)=a_0+a_1x+a_2x^2+a_3x^3+ \\cdots +a_nx^n$$\n\n给定$m$以及$f(m)$的值（即当$x=m$时此多项式的值），请构造多项式，满足任意$0 \\leq a_i < m$且$a_i$为非负整数。\n\n设你构造的多项式项数为$n$，则必须满足$1 ≤ n ≤ 100$且最高项系数不为零。", "inputFormat": "两个整数，$m$、$f(m)$。", "outputFormat": "第一行输出正整数$n$，表示多项式的项数。\n\n第二行依次输出$n$个非负整数（$a_0$至$a_{n-1}$），每个非负整数之间用**一个**空格隔开。", "hint": "对于20%的数据， $ 2 ≤ m ≤ 5. $\n\n对于100%的数据，\n $ 2 ≤ m,f(m) ≤ 10^{18}.$\n\n所有数据的时间限制为 $1000ms$，空间限制为 $256MB$，可开启O2优化。", "locale": "zh-CN", "translations": {"en": {"title": "[LnOI2019SP] Fast Polynomial Transform (FPT).", "background": "![avartar](https://cdn.luogu.com.cn/upload/pic/52800.png)", "description": "This is a constructive problem.\n\nShino thinks of a polynomial $f(x)$ with $n+1$ terms. The degree of the $i$-th term is $i$, and its coefficient is $a_i$:\n\n$$f(x)=a_0+a_1x+a_2x^2+a_3x^3+ \\cdots +a_nx^n$$\n\nGiven $m$ and the value of $f(m)$ (that is, the value of this polynomial when $x=m$), please construct a polynomial such that for any $0 \\leq a_i < m$, $a_i$ is a non-negative integer.\n\nLet the number of terms of the polynomial you construct be $n$. Then it must satisfy $1 \\le n \\le 100$, and the leading coefficient must be non-zero.", "inputFormat": "Two integers, $m$ and $f(m)$.", "outputFormat": "The first line outputs a positive integer $n$, which represents the number of terms of the polynomial.\n\nThe second line outputs $n$ non-negative integers ($a_0$ to $a_{n-1}$) in order, with **exactly one** space between each pair of adjacent integers.", "hint": "For $20\\%$ of the testdata, $2 \\le m \\le 5$.\n\nFor $100\\%$ of the testdata, $2 \\le m,f(m) \\le 10^{18}$.\n\nFor all testdata, the time limit is $1000\\text{ms}$ and the memory limit is $256\\text{MB}$. You may enable O2 optimization.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[LnOI2019SP] 快速多项式变换(FPT)", "background": "![avartar](https://cdn.luogu.com.cn/upload/pic/52800.png)", "description": "这是一道构造题。\n\n诗乃在心中想了一个$n+1$项的多项式$f(x)$。第$i$项次数为$i$，系数为$a_i$：\n\n$$f(x)=a_0+a_1x+a_2x^2+a_3x^3+ \\cdots +a_nx^n$$\n\n给定$m$以及$f(m)$的值（即当$x=m$时此多项式的值），请构造多项式，满足任意$0 \\leq a_i < m$且$a_i$为非负整数。\n\n设你构造的多项式项数为$n$，则必须满足$1 ≤ n ≤ 100$且最高项系数不为零。", "inputFormat": "两个整数，$m$、$f(m)$。", "outputFormat": "第一行输出正整数$n$，表示多项式的项数。\n\n第二行依次输出$n$个非负整数（$a_0$至$a_{n-1}$），每个非负整数之间用**一个**空格隔开。", "hint": "对于20%的数据， $ 2 ≤ m ≤ 5. $\n\n对于100%的数据，\n $ 2 ≤ m,f(m) ≤ 10^{18}.$\n\n所有数据的时间限制为 $1000ms$，空间限制为 $256MB$，可开启O2优化。", "locale": "zh-CN"}}}
{"pid": "P5249", "type": "P", "difficulty": 5, "samples": [["0.5 2 1", "0.33333333"], ["0.5 2 2", "0.66666667"], ["0.5 3 1", "0.23809524"], ["0.5 3 2", "0.28571429"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["递推", "Special Judge", "O2优化", "概率论"], "title": "[LnOI2019] 加特林轮盘赌", "background": "加特林轮盘赌是一个养生游戏。", "description": "与俄罗斯轮盘赌等手枪的赌博不同的是，加特林轮盘赌的赌具是加特林。\n\n加特林轮盘赌的规则很简单：在加特林的部分弹夹中填充子弹。游戏的参加者**坐在一个圆桌上**，轮流把加特林对着自己的头，扣动扳机一秒钟。中枪的自动退出，坚持到最后的就是胜利者。\n\n我们使用的是 2019 年最新技术的加特林，他的特点是**无需预热、子弹无限**，每一个人，在每一回合，中枪的概率是完全相同的 $P_0$。\n\n每局游戏共有 $n$ 只长脖子鹿，从 1 长脖子鹿开始，按照编号顺序从小到大进行游戏，绕着圆桌不断循环。\n\n游戏可能会循环进行多轮，直到场上仅剩下最后一只长脖子鹿时，游戏结束。\n\n给出 $P_0$ 和 $n$，询问 $k$ 号长脖子鹿最终成为**唯一幸存者**的概率 $P_k$。\n\n**如果 $P_0=0$，我们认为胜者为 $1$ 号。**", "inputFormat": "仅一行三个数，$P_0,n,k$。", "outputFormat": "一个浮点数 $P_{k}$，误差应该小于 $10^{-8}$。（请保留更多位数的小数）", "hint": "- 对于 $10\\%$ 的数据，$n \\le 100$。\n- 对于 $30\\%$ 的数据，$n \\le 500$。\n- 对于另外 $20\\%$ 的数据，$k = n$。\n- 对于 $100\\%$ 的数据，$1 \\le k \\le n \\le 10^{4}, 0 \\le P_0 \\le 1$。\n\n所有数据的时间限制为 1000ms，空间限制为256MB，可开启 O2 优化。", "locale": "zh-CN", "translations": {"en": {"title": "[LnOI2019] Gatling Roulette", "background": "Gatling roulette is a wellness game.", "description": "Unlike gambling games with pistols such as Russian roulette, the game tool in Gatling roulette is a Gatling gun.\n\nThe rules of Gatling roulette are simple: bullets are loaded into some parts of the Gatling’s magazine. The players **sit at a round table**, and take turns aiming the Gatling at their own head and pulling the trigger for one second. Anyone who gets shot is eliminated immediately. The one who lasts to the end is the winner.\n\nWe use a Gatling gun with the latest 2019 technology. Its features are **no warm-up needed and unlimited bullets**. For each person, in each round, the probability of getting shot is exactly the same, $P_0$.\n\nThere are $n$ long-necked deer in each game. Starting from long-necked deer $1$, they play in increasing order by number, going around the round table in a loop.\n\nThe game may go through multiple cycles, and ends when only the last long-necked deer remains.\n\nGiven $P_0$ and $n$, find the probability $P_k$ that long-necked deer $k$ will eventually become the **only survivor**.\n\n**If $P_0=0$, we consider deer $1$ to be the winner.**", "inputFormat": "Only one line with three numbers, $P_0,n,k$.", "outputFormat": "Output a floating-point number $P_{k}$. The error should be less than $10^{-8}$. (Please keep more digits after the decimal point.)", "hint": "- For $10\\%$ of the testdata, $n \\le 100$.\n- For $30\\%$ of the testdata, $n \\le 500$.\n- For another $20\\%$ of the testdata, $k = n$.\n- For $100\\%$ of the testdata, $1 \\le k \\le n \\le 10^{4}, 0 \\le P_0 \\le 1$.\n\nFor all testdata, the time limit is 1000 ms and the memory limit is 256 MB. $O2$ optimization is allowed.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[LnOI2019] 加特林轮盘赌", "background": "加特林轮盘赌是一个养生游戏。", "description": "与俄罗斯轮盘赌等手枪的赌博不同的是，加特林轮盘赌的赌具是加特林。\n\n加特林轮盘赌的规则很简单：在加特林的部分弹夹中填充子弹。游戏的参加者**坐在一个圆桌上**，轮流把加特林对着自己的头，扣动扳机一秒钟。中枪的自动退出，坚持到最后的就是胜利者。\n\n我们使用的是 2019 年最新技术的加特林，他的特点是**无需预热、子弹无限**，每一个人，在每一回合，中枪的概率是完全相同的 $P_0$。\n\n每局游戏共有 $n$ 只长脖子鹿，从 1 长脖子鹿开始，按照编号顺序从小到大进行游戏，绕着圆桌不断循环。\n\n游戏可能会循环进行多轮，直到场上仅剩下最后一只长脖子鹿时，游戏结束。\n\n给出 $P_0$ 和 $n$，询问 $k$ 号长脖子鹿最终成为**唯一幸存者**的概率 $P_k$。\n\n**如果 $P_0=0$，我们认为胜者为 $1$ 号。**", "inputFormat": "仅一行三个数，$P_0,n,k$。", "outputFormat": "一个浮点数 $P_{k}$，误差应该小于 $10^{-8}$。（请保留更多位数的小数）", "hint": "- 对于 $10\\%$ 的数据，$n \\le 100$。\n- 对于 $30\\%$ 的数据，$n \\le 500$。\n- 对于另外 $20\\%$ 的数据，$k = n$。\n- 对于 $100\\%$ 的数据，$1 \\le k \\le n \\le 10^{4}, 0 \\le P_0 \\le 1$。\n\n所有数据的时间限制为 1000ms，空间限制为256MB，可开启 O2 优化。", "locale": "zh-CN"}}}
{"pid": "P5250", "type": "P", "difficulty": 3, "samples": [["7\n1 1\n1 5\n1 3\n2 3\n2 3\n2 3\n2 3", "3\n1\n5\nEmpty\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["二分", "STL"], "title": "【深基17.例5】木材仓库", "background": null, "description": "博艾市有一个木材仓库，里面可以存储各种长度的木材，但是保证没有两个木材的长度是相同的。作为仓库负责人，你有时候会进货，有时候会出货，因此需要维护这个库存。有不超过 $10^5$ 条的操作：\n\n- 进货，格式 `1 Length`：在仓库中放入一根长度为 $Length$（不超过 $10^9$）的木材。如果已经有相同长度的木材那么输出 `Already Exist`。\n- 出货，格式 `2 Length`：从仓库中取出长度为 $Length$ 的木材。如果没有刚好长度的木材，取出仓库中存在的和要求长度最接近的木材。如果有多根木材符合要求，取出比较短的一根。输出取出的木材长度。如果仓库是空的，输出 `Empty`。", "inputFormat": "第一行一个数 $m$ 代表操作次数。\n\n接下来 $m$ 行，每行一次操作，格式如题目描述所示。", "outputFormat": "对于每次操作，按照题目描述要求输出答案。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[Deep Basic 17. Example 5] Timber Warehouse", "background": "", "description": "In Boai City, there is a timber warehouse that can store timber of various lengths, and it is guaranteed that no two pieces of timber have the same length. As the warehouse manager, you sometimes purchase stock and sometimes ship stock, so you need to maintain the inventory. There are no more than $10^5$ operations:\n\n- Stock in, format `1 Length`: Put a piece of timber of length $Length$ (no more than $10^9$) into the warehouse. If a piece of timber with the same length already exists, output `Already Exist`.\n- Stock out, format `2 Length`: Take out the piece of timber with length $Length$ from the warehouse. If there is no piece with exactly that length, take out the piece in the warehouse whose length is closest to the requested length. If multiple pieces satisfy this, take out the shorter one. Output the length of the timber taken out. If the warehouse is empty, output `Empty`.", "inputFormat": "The first line contains an integer $m$, representing the number of operations.\n\nThe next $m$ lines each contain one operation, in the format described in the statement.", "outputFormat": "For each operation, output the answer as required in the statement.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【深基17.例5】木材仓库", "background": null, "description": "博艾市有一个木材仓库，里面可以存储各种长度的木材，但是保证没有两个木材的长度是相同的。作为仓库负责人，你有时候会进货，有时候会出货，因此需要维护这个库存。有不超过 $10^5$ 条的操作：\n\n- 进货，格式 `1 Length`：在仓库中放入一根长度为 $Length$（不超过 $10^9$）的木材。如果已经有相同长度的木材那么输出 `Already Exist`。\n- 出货，格式 `2 Length`：从仓库中取出长度为 $Length$ 的木材。如果没有刚好长度的木材，取出仓库中存在的和要求长度最接近的木材。如果有多根木材符合要求，取出比较短的一根。输出取出的木材长度。如果仓库是空的，输出 `Empty`。", "inputFormat": "第一行一个数 $m$ 代表操作次数。\n\n接下来 $m$ 行，每行一次操作，格式如题目描述所示。", "outputFormat": "对于每次操作，按照题目描述要求输出答案。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P5251", "type": "P", "difficulty": 6, "samples": [["9 8 4\n17 5 8 1 6 4 12 3 4\n1 1 1 1 1 1 1 3 4\n2 3 6 2\n3 1 9\n4 1 9\n4 6 9\n4 1 3\n2 4 5 4\n3 1 1\n3 1 9", "23\n23\n23\n17\n-1\n23"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["线段树", "颜色段均摊（珂朵莉树 ODT）", "双指针 two-pointer"], "title": "[LnOI2019] 第二代图灵机", "background": "1989年，Abbi提出了一种抽象的计算模型 —— 第二代图灵机 (The 2nd Generation Turing Machine）。\n\n所谓的第二代图灵机就是指一个抽象的机器，它有一条长度为$n$的纸带，纸带分成了$n$个小方格，每个方格有不同的**颜色**和不同的**数字**。\n\n![avatar](https://cdn.luogu.com.cn/upload/pic/52955.png)", "description": "第二代图灵的基本思想是用机器来模拟鹿们用纸笔进行数学运算的过程，他把这样的过程看作下列两种简单的动作：\n\n1. 在纸带上的一格写数字。\n2. 在纸带上的一段区间着色。\n\n为了测试第二代图灵机的性能，Abbi提出了一种用于判定机器是否具有智能的试验方法，即图灵试验。\n\n1. 求 $[l,r]$ 中包含所有(一共 $c$ 种)颜色，数字和最小的子区间的数字和。\n2. 求 $[l,r]$ 中没有重复颜色，数字和最大的子区间的数字和。\n\n你需要为第二代图灵机编写算法，使他能通过所有的图灵试验。为保证试验的正确性，所有数据都是随机生成的。", "inputFormat": "第一行输入两个正整数 $n,m,c$，分别表示纸带长度，操作次数和颜色总数。\n\n第二行 $n$ 个非负整数，表示每个格子上的初始数字 $a_i$。\n\n第三行 $n$ 个非负整数，表示每个格子上的颜色编号 $b_i$。\n\n接下来 $m$ 行，对应每一次操作。\n\n操作一格式：$1\\quad x\\quad y$，表示将第 $x$ 位的数字改为 $y$，保证 $1≤y≤10000$。\n\n操作二格式：$2\\quad l\\quad r\\quad y$，表示将区间 $[l,r]$ 的颜色全部改为 $y$ ，保证 $1≤y≤c$。\n\n操作三格式：$3\\quad l\\quad r$，表示询问区间$[l,r]$中包含所有(一共$c$种)颜色，数字和最小的子区间的数字和。\n\n操作四格式：$4\\quad l\\quad r$，表示询问区间$[l,r]$中没有重复颜色，数字和最大的子区间的数字和。", "outputFormat": "对于操作三和操作四，输出一个整数，表示最小或最大的数字和。\n\n对于操作三，若不存在满足条件的子区间，请输出 $-1$。", "hint": "![avatar](https://cdn.luogu.com.cn/upload/pic/53113.png)\n\n**由于数据规模较大，建议用以下方法读入一个正整数。**\n\n```cpp\nvoid read(int &x){\n\tchar ch;\n\twhile(ch = getchar(), ch < '!'); x = ch - 48;\n\twhile(ch = getchar(), ch > '!') x = (x << 3) + (x << 1) + ch - 48;\n}\n```", "locale": "zh-CN", "translations": {"en": {"title": "[LnOI2019] The 2nd Generation Turing Machine", "background": "In 1989, Abbi proposed an abstract computation model — the 2nd Generation Turing Machine (The 2nd Generation Turing Machine).\n\nThe so-called 2nd Generation Turing Machine refers to an abstract machine that has a tape of length $n$. The tape is divided into $n$ small cells. Each cell has a different **color** and a different **number**.\n\n![avatar](https://cdn.luogu.com.cn/upload/pic/52955.png)", "description": "The basic idea of the 2nd Generation Turing Machine is to use a machine to simulate the process of deer doing mathematical calculations with pen and paper. He regarded such a process as the following two simple actions:\n\n1. Write a number in one cell on the tape.\n2. Color a segment of the tape.\n\nTo test the performance of the 2nd Generation Turing Machine, Abbi proposed a method to determine whether the machine is intelligent, namely the Turing test.\n\n1. For $[l,r]$, query the sum of numbers of the subsegment with the minimum sum that contains all (a total of $c$ types of) colors.\n2. For $[l,r]$, query the sum of numbers of the subsegment with the maximum sum that has no repeated colors.\n\nYou need to write an algorithm for the 2nd Generation Turing Machine so that it can pass all Turing tests. To ensure the correctness of the tests, all testdata are randomly generated.", "inputFormat": "The first line contains three positive integers $n,m,c$, representing the tape length, the number of operations, and the total number of colors.\n\nThe second line contains $n$ non-negative integers, representing the initial number $a_i$ in each cell.\n\nThe third line contains $n$ non-negative integers, representing the color ID $b_i$ of each cell.\n\nThe next $m$ lines describe the operations.\n\nOperation 1: $1\\quad x\\quad y$, meaning to change the number at position $x$ to $y$, with $1≤y≤10000$ guaranteed.\n\nOperation 2: $2\\quad l\\quad r\\quad y$, meaning to change the colors of all cells in the interval $[l,r]$ to $y$, with $1≤y≤c$ guaranteed.\n\nOperation 3: $3\\quad l\\quad r$, meaning to query, within $[l,r]$, the sum of numbers of the subsegment with the minimum sum that contains all (a total of $c$ types of) colors.\n\nOperation 4: $4\\quad l\\quad r$, meaning to query, within $[l,r]$, the sum of numbers of the subsegment with the maximum sum that has no repeated colors.", "outputFormat": "For Operation 3 and Operation 4, output one integer, representing the minimum or maximum sum of numbers.\n\nFor Operation 3, if there is no subsegment that satisfies the condition, output $-1$.", "hint": "![avatar](https://cdn.luogu.com.cn/upload/pic/53113.png)\n\n**Since the data size is large, it is recommended to read a positive integer using the following method.**\n\n```cpp\nvoid read(int &x){\n\tchar ch;\n\twhile(ch = getchar(), ch < '!'); x = ch - 48;\n\twhile(ch = getchar(), ch > '!') x = (x << 3) + (x << 1) + ch - 48;\n}\n```\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[LnOI2019] 第二代图灵机", "background": "1989年，Abbi提出了一种抽象的计算模型 —— 第二代图灵机 (The 2nd Generation Turing Machine）。\n\n所谓的第二代图灵机就是指一个抽象的机器，它有一条长度为$n$的纸带，纸带分成了$n$个小方格，每个方格有不同的**颜色**和不同的**数字**。\n\n![avatar](https://cdn.luogu.com.cn/upload/pic/52955.png)", "description": "第二代图灵的基本思想是用机器来模拟鹿们用纸笔进行数学运算的过程，他把这样的过程看作下列两种简单的动作：\n\n1. 在纸带上的一格写数字。\n2. 在纸带上的一段区间着色。\n\n为了测试第二代图灵机的性能，Abbi提出了一种用于判定机器是否具有智能的试验方法，即图灵试验。\n\n1. 求 $[l,r]$ 中包含所有(一共 $c$ 种)颜色，数字和最小的子区间的数字和。\n2. 求 $[l,r]$ 中没有重复颜色，数字和最大的子区间的数字和。\n\n你需要为第二代图灵机编写算法，使他能通过所有的图灵试验。为保证试验的正确性，所有数据都是随机生成的。", "inputFormat": "第一行输入两个正整数 $n,m,c$，分别表示纸带长度，操作次数和颜色总数。\n\n第二行 $n$ 个非负整数，表示每个格子上的初始数字 $a_i$。\n\n第三行 $n$ 个非负整数，表示每个格子上的颜色编号 $b_i$。\n\n接下来 $m$ 行，对应每一次操作。\n\n操作一格式：$1\\quad x\\quad y$，表示将第 $x$ 位的数字改为 $y$，保证 $1≤y≤10000$。\n\n操作二格式：$2\\quad l\\quad r\\quad y$，表示将区间 $[l,r]$ 的颜色全部改为 $y$ ，保证 $1≤y≤c$。\n\n操作三格式：$3\\quad l\\quad r$，表示询问区间$[l,r]$中包含所有(一共$c$种)颜色，数字和最小的子区间的数字和。\n\n操作四格式：$4\\quad l\\quad r$，表示询问区间$[l,r]$中没有重复颜色，数字和最大的子区间的数字和。", "outputFormat": "对于操作三和操作四，输出一个整数，表示最小或最大的数字和。\n\n对于操作三，若不存在满足条件的子区间，请输出 $-1$。", "hint": "![avatar](https://cdn.luogu.com.cn/upload/pic/53113.png)\n\n**由于数据规模较大，建议用以下方法读入一个正整数。**\n\n```cpp\nvoid read(int &x){\n\tchar ch;\n\twhile(ch = getchar(), ch < '!'); x = ch - 48;\n\twhile(ch = getchar(), ch > '!') x = (x << 3) + (x << 1) + ch - 48;\n}\n```", "locale": "zh-CN"}}}
{"pid": "P5252", "type": "P", "difficulty": 7, "samples": [["3\n1.0 1.0 1.0\n1.0 4.0 1.0\n5.0 1.0 1.0", "3.00 2.50 3.50"], ["3\n4.0 1.0 1.0\n4.0 7.0 1.0\n5.0 5.0 3.0", "4.63 4.00 4.07"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["Special Judge"], "title": "[LnOI2019] 东京夏日相会", "background": "![avartar](https://cdn.luogu.com.cn/upload/pic/52827.png)\n\n「听说有烟火大会在下周举办呢」\n\n「诶？ 那种人多的地方我不太喜欢呢」\n\n「啊， 那我还是问问别人好了╭(╯^╰)╮」\n\n「唔， 好像还是很有趣呢。我说不定会去吧(⊙﹏⊙)b」\n", "description": "当然上面发生的事情和Abbi没有任何一点关系。作为一只长(zhang)了脖子的单身鹿，Abbi只能在家拿着“望远镜”孤独地在远处欣赏烟火大会。\n\n![avartar](https://cdn.luogu.com.cn/upload/pic/52828.png)\n\n~~啥？什么狙击枪？这是望远镜啊！（认真）~~\n\n为了看到夜空中所有的烟花，Abbi需要调整“望远镜”的放大倍数与位置。夜空可近似地看成一个平面，其中第$i$朵烟花可以近似地看作一个圆心为$(x_i,y_i)$，半径为$r_i$的圆。\n\nAbbi的望远镜视野可以近似地看作一个圆。因为调整放大倍数很累，因此Abbi希望在满足所有烟花都**完整**地出现在视野中的同时，视野的半径尽可能小。请你求出视野的圆心坐标与半径。", "inputFormat": "第一行一个整数$n$，表示有$n$朵烟花。\n\n第二行~第$n+1$行，每行三个实数$x_i$、$y_i$和$r_i$，表示每朵烟花的圆心坐标与半径。\n", "outputFormat": "第一行三个实数，$X$、$Y$、$R$，分别表示望远镜视野的圆心坐标与半径。你的答案中半径与标准答案的误差不得超过$0.01$，圆心坐标与标准答案的误差不得超过$0.04$。", "hint": "![avartar](https://cdn.luogu.com.cn/upload/pic/52900.png)\n\n**请开启O2优化。建议使用读入优化或scanf读入数据。**", "locale": "zh-CN", "translations": {"en": {"title": "[LnOI2019] Tokyo Summer Meetup", "background": "![avartar](https://cdn.luogu.com.cn/upload/pic/52827.png)\n\n“I heard there will be a fireworks festival next week.”\n\n“Huh? I don’t really like places with lots of people.”\n\n“Ah, then I’ll just ask someone else. ╭(╯^╰)╮”\n\n“Hmm, it still sounds fun. I might go. (⊙﹏⊙)b”", "description": "Of course, what happened above has absolutely nothing to do with Abbi. As a single deer with a long (zhang) neck, Abbi can only stay at home, holding a “telescope” and lonely watching the fireworks festival from afar.\n\n![avartar](https://cdn.luogu.com.cn/upload/pic/52828.png)\n\n~~What? A sniper rifle? This is a telescope! (seriously)~~\n\nTo see all the fireworks in the night sky, Abbi needs to adjust the magnification and position of the “telescope”. The night sky can be approximately considered as a plane. The $i$-th firework can be approximately considered as a circle with center $(x_i, y_i)$ and radius $r_i$.\n\nThe telescope’s field of view can be approximately considered as a circle. Because adjusting the magnification is tiring, Abbi wants the radius of the field of view to be as small as possible while ensuring that all fireworks appear **completely** inside the field of view. Please find the center coordinates and the radius of the field-of-view circle.", "inputFormat": "The first line contains an integer $n$, meaning there are $n$ fireworks.\n\nLines $2$ to $n + 1$ each contain three real numbers $x_i$, $y_i$, and $r_i$, representing the center coordinates and radius of each firework.", "outputFormat": "Output three real numbers $X$, $Y$, and $R$ on the first line, representing the center coordinates and radius of the telescope’s field of view. The error of the radius compared with the standard answer must not exceed $0.01$, and the error of the center coordinates compared with the standard answer must not exceed $0.04$.", "hint": "![avartar](https://cdn.luogu.com.cn/upload/pic/52900.png)\n\n**Please enable O2 optimization. It is recommended to use fast input or scanf to read the testdata.**\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[LnOI2019] 东京夏日相会", "background": "![avartar](https://cdn.luogu.com.cn/upload/pic/52827.png)\n\n「听说有烟火大会在下周举办呢」\n\n「诶？ 那种人多的地方我不太喜欢呢」\n\n「啊， 那我还是问问别人好了╭(╯^╰)╮」\n\n「唔， 好像还是很有趣呢。我说不定会去吧(⊙﹏⊙)b」\n", "description": "当然上面发生的事情和Abbi没有任何一点关系。作为一只长(zhang)了脖子的单身鹿，Abbi只能在家拿着“望远镜”孤独地在远处欣赏烟火大会。\n\n![avartar](https://cdn.luogu.com.cn/upload/pic/52828.png)\n\n~~啥？什么狙击枪？这是望远镜啊！（认真）~~\n\n为了看到夜空中所有的烟花，Abbi需要调整“望远镜”的放大倍数与位置。夜空可近似地看成一个平面，其中第$i$朵烟花可以近似地看作一个圆心为$(x_i,y_i)$，半径为$r_i$的圆。\n\nAbbi的望远镜视野可以近似地看作一个圆。因为调整放大倍数很累，因此Abbi希望在满足所有烟花都**完整**地出现在视野中的同时，视野的半径尽可能小。请你求出视野的圆心坐标与半径。", "inputFormat": "第一行一个整数$n$，表示有$n$朵烟花。\n\n第二行~第$n+1$行，每行三个实数$x_i$、$y_i$和$r_i$，表示每朵烟花的圆心坐标与半径。\n", "outputFormat": "第一行三个实数，$X$、$Y$、$R$，分别表示望远镜视野的圆心坐标与半径。你的答案中半径与标准答案的误差不得超过$0.01$，圆心坐标与标准答案的误差不得超过$0.04$。", "hint": "![avartar](https://cdn.luogu.com.cn/upload/pic/52900.png)\n\n**请开启O2优化。建议使用读入优化或scanf读入数据。**", "locale": "zh-CN"}}}
{"pid": "P5253", "type": "P", "difficulty": 4, "samples": [["4", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2013", "各省省选", "江苏", "O2优化"], "title": "[JSOI2013] 丢番图", "background": "丢番图是亚历山大时期埃及著名的数学家。他是最早研究整数系数不定方程的数学家之一。\n\n为了纪念他，这些方程一般被称作丢番图方程。最著名的丢番图方程之一是\n\n$$x^n+y^n=z^n$$\n\n费马提出，对于 $n>2$, $x,y,z$ 没有正整数解。这被称为“费马大定理”，它的证明直到最近才被安德鲁·怀尔斯（AndrewWiles）证明。", "description": "考虑如下的丢番图方程：\n\n$$\\frac{1}{x}~+~\\frac{1}{y}~=~\\frac{1}{n}~,(x,y,n~\\in~\\mathbb{N}^+)$$\n\n小 G 对下面这个问题十分感兴趣：对于一个给定的正整数 $n$，有多少种本质不同的解满足上面的方程？例如 $n=4$，有三种本质不同 $(x~\\leq~y)$ 的解：\n\n> $\\frac{1}{5}+\\frac{1}{20}~=~\\frac{1}{4}$\n>\n> $\\frac{1}{6}+\\frac{1}{12}~=~\\frac{1}{4}$\n>\n> $\\frac{1}{8}+\\frac{1}{8}~=~\\frac{1}{4}$\n\n显然，对于更大的 $n$，没有意义去列举所有本质不同的解。你能否帮助小 G 快速地求出对于给定 $n$，满足上面方程的本质不同的解的个数？", "inputFormat": "一行，仅一个整数 $n$。", "outputFormat": "一行一个整数代表答案。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1\\leq n \\leq 10^{14}$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2013] Diophantus", "background": "Diophantus was a famous mathematician in Egypt during the Alexandrian period. He was one of the earliest mathematicians to study indeterminate equations with integer coefficients.\n\nTo honor him, such equations are generally called Diophantine equations. One of the most famous Diophantine equations is\n\n$$x^n+y^n=z^n$$\n\nFermat proposed that for $n>2$, $x,y,z$ have no positive integer solutions. This is called “Fermat's Last Theorem”, and its proof was not completed until recently by Andrew Wiles (AndrewWiles).", "description": "Consider the following Diophantine equation:\n\n$$\\frac{1}{x}~+~\\frac{1}{y}~=~\\frac{1}{n}~,(x,y,n~\\in~\\mathbb{N}^+)$$\n\nXiao G is very interested in the following question: for a given positive integer $n$, how many essentially different solutions satisfy the equation above? For example, when $n=4$, there are three essentially different solutions $(x~\\leq~y)$:\n\n> $\\frac{1}{5}+\\frac{1}{20}~=~\\frac{1}{4}$\n>\n> $\\frac{1}{6}+\\frac{1}{12}~=~\\frac{1}{4}$\n>\n> $\\frac{1}{8}+\\frac{1}{8}~=~\\frac{1}{4}$\n\nObviously, for larger $n$, it is meaningless to list all essentially different solutions. Can you help Xiao G quickly find, for a given $n$, the number of essentially different solutions to the equation above?", "inputFormat": "One line with only one integer $n$.", "outputFormat": "Output one line with one integer, representing the answer.", "hint": "#### Constraints\n\nFor all testdata, it is guaranteed that $1 \\leq n \\leq 10^{14}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2013] 丢番图", "background": "丢番图是亚历山大时期埃及著名的数学家。他是最早研究整数系数不定方程的数学家之一。\n\n为了纪念他，这些方程一般被称作丢番图方程。最著名的丢番图方程之一是\n\n$$x^n+y^n=z^n$$\n\n费马提出，对于 $n>2$, $x,y,z$ 没有正整数解。这被称为“费马大定理”，它的证明直到最近才被安德鲁·怀尔斯（AndrewWiles）证明。", "description": "考虑如下的丢番图方程：\n\n$$\\frac{1}{x}~+~\\frac{1}{y}~=~\\frac{1}{n}~,(x,y,n~\\in~\\mathbb{N}^+)$$\n\n小 G 对下面这个问题十分感兴趣：对于一个给定的正整数 $n$，有多少种本质不同的解满足上面的方程？例如 $n=4$，有三种本质不同 $(x~\\leq~y)$ 的解：\n\n> $\\frac{1}{5}+\\frac{1}{20}~=~\\frac{1}{4}$\n>\n> $\\frac{1}{6}+\\frac{1}{12}~=~\\frac{1}{4}$\n>\n> $\\frac{1}{8}+\\frac{1}{8}~=~\\frac{1}{4}$\n\n显然，对于更大的 $n$，没有意义去列举所有本质不同的解。你能否帮助小 G 快速地求出对于给定 $n$，满足上面方程的本质不同的解的个数？", "inputFormat": "一行，仅一个整数 $n$。", "outputFormat": "一行一个整数代表答案。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1\\leq n \\leq 10^{14}$。", "locale": "zh-CN"}}}
{"pid": "P5254", "type": "P", "difficulty": 5, "samples": [["3 4\ntiet\noink\nezin\nzenit", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["字符串", "2013", "各省省选", "江苏", "O2优化", "哈希 hashing", "bitset"], "title": "[JSOI2013] 广告计划", "background": "如今，在建筑的墙面上或者篱笆桩的表面上涂上一些广告，是一种新的吸引眼球的方法。", "description": "现在，小G 运营的一家小公司，决定也试着这样做做广告。小G在他的篱笆桩上腾出了一些地方供广告使用。每一个篱笆桩都是一个水平的1\\*1\\*L的 4 棱柱，其中有一个 1\\*L的面是可以做广告的。1\\*L的面上划出了 L 个1\\*1 的小正方形（更具体地说是连续L个水平排列的正方形），每个正方形内写上一个字母。 时间久了，广告做多了难免会出现一些比较麻烦的情况，比如计划改变或者制作出错，因此小 G 的仓库里面积累了好多没有用的，上面已经写上 L 个字母的篱笆桩。（所有的篱笆桩的大小都是一样的，他们唯一的区别仅仅在于上面写了什么字母）。 小G 决定对于这些篱笆桩进行重新利用，并且有了一些新的想法。\n\n如果将这些篱笆桩竖直的叠放起来，并且依次从左往右，对于每一个篱笆桩顺次从上到下读出上面的字母，那么我们可以得到一些新的比较长的单词，如下图：\n\n![qwq](https://cdn.luogu.com.cn/upload/pic/54049.png)\n\n\n这些新的单词能满足小G的一些新的需要。当然，基于美学考虑，小G 是不允许你删改篱笆桩上已经写上的字母的。 我们更具体地描述这个过程。我们将 K个长度为 L的篱笆桩叠在一起，可以得到一个写有 K行L列共K*L个字母的面，每一个字母都在对应的唯一的格子里。\n\n我们从左上角开始依次向下读出每一个字母可以得到一个字母的序列，比如上图中的这个例子，那么我们读出的结果就是“TOEIIZENITKN”。如果，这个串中有我们所需要的单词，那么显然我们只需要将一些格子刷白，就可以得到我们所需要的了。举个例子，比如小G想要给圣彼得堡的足球队泽尼特队做个广告，那么很显然只要按照上图中的做法就可以达到小G想要的效果了。\n\n现在小G已经想好了要做怎样的广告，同时也提供给你了小G仓库中的篱笆桩的类型的描述，你可以认为每一种类型的篱笆桩都是有无数个的。现在小G 想知道至少需要多少个篱笆桩叠起来才可以做出小G想要的广告。", "inputFormat": "第一行两个自然数，N和L。\n \n接下来N 行，每行包含 L个小写字母，描述一种篱笆桩上写着的字母。保证不同类型的篱笆桩上的字母序列都是不一样的，每一种类型的篱笆桩都是有无数个。\n\n最后一行是一个字符串s，表示小G 想好的广告词。", "outputFormat": "第一行一个整数K，表示所需要的最少数量的篱笆桩（注意是数量，并不是种类数）。", "hint": "$1~\\leq~N,~L~\\leq~100$\n\n$1~\\leq~|s|~\\leq~200$", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2013] Advertising Plan", "background": "Nowadays, painting some advertisements on the walls of buildings or on the surface of fence posts is a new way to attract attention.", "description": "Now, a small company run by Little G decided to try this kind of advertising as well. Little G freed up some space on his fence posts for advertisements. Each fence post is a horizontal $1*1*L$ quadrangular prism, and one $1*L$ face can be used for advertising. The $1*L$ face is divided into $L$ $1*1$ small squares (more specifically, $L$ consecutive squares arranged horizontally), and each square contains one letter.\n\nOver time, with more and more ads, troublesome situations may occur, such as plan changes or production mistakes. As a result, Little G’s warehouse has accumulated many useless fence posts that already have $L$ letters written on them. (All fence posts have the same size; the only difference is what letters are written on them.) Little G decided to reuse these fence posts and came up with some new ideas.\n\nIf we stack these fence posts vertically, and then from left to right, for each fence post read the letters on it from top to bottom, we can obtain some new longer words, as shown in the picture:\n\n![qwq](https://cdn.luogu.com.cn/upload/pic/54049.png)\n\nThese new words can meet some new needs of Little G. Of course, for aesthetic reasons, Little G does not allow you to delete or modify the letters that are already written on the fence posts. We describe this process more precisely.\n\nWe stack $K$ fence posts of length $L$ together, obtaining a face with $K$ rows and $L$ columns, containing a total of $K*L$ letters, where each letter lies in its own unique cell.\n\nStarting from the top-left corner and reading each letter downward in order, we get a sequence of letters. For example, in the figure above, the result is “TOEIIZENITKN”. If this string contains the word we need, then obviously we only need to paint some cells white to obtain the desired word. For instance, if Little G wants to make an ad for Zenit, the football team of Saint Petersburg, then clearly the method in the picture can achieve what Little G wants.\n\nNow Little G has decided what advertisement to make, and he also provides you with the descriptions of the types of fence posts in his warehouse. You may assume that there are infinitely many fence posts of each type. Little G now wants to know the minimum number of fence posts that must be stacked to produce the advertisement Little G wants.", "inputFormat": "The first line contains two natural numbers, $N$ and $L$.\n\nThe next $N$ lines each contain $L$ lowercase letters, describing the letters written on one type of fence post. It is guaranteed that the letter sequences on different types of fence posts are all different, and there are infinitely many fence posts of each type.\n\nThe last line is a string $s$, representing the advertising slogan Little G has decided on.", "outputFormat": "The first line contains an integer $K$, indicating the minimum number of fence posts needed (note that this is the quantity, not the number of types).", "hint": "$1~\\leq~N,~L~\\leq~100$\n\n$1~\\leq~|s|~\\leq~200$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2013] 广告计划", "background": "如今，在建筑的墙面上或者篱笆桩的表面上涂上一些广告，是一种新的吸引眼球的方法。", "description": "现在，小G 运营的一家小公司，决定也试着这样做做广告。小G在他的篱笆桩上腾出了一些地方供广告使用。每一个篱笆桩都是一个水平的1\\*1\\*L的 4 棱柱，其中有一个 1\\*L的面是可以做广告的。1\\*L的面上划出了 L 个1\\*1 的小正方形（更具体地说是连续L个水平排列的正方形），每个正方形内写上一个字母。 时间久了，广告做多了难免会出现一些比较麻烦的情况，比如计划改变或者制作出错，因此小 G 的仓库里面积累了好多没有用的，上面已经写上 L 个字母的篱笆桩。（所有的篱笆桩的大小都是一样的，他们唯一的区别仅仅在于上面写了什么字母）。 小G 决定对于这些篱笆桩进行重新利用，并且有了一些新的想法。\n\n如果将这些篱笆桩竖直的叠放起来，并且依次从左往右，对于每一个篱笆桩顺次从上到下读出上面的字母，那么我们可以得到一些新的比较长的单词，如下图：\n\n![qwq](https://cdn.luogu.com.cn/upload/pic/54049.png)\n\n\n这些新的单词能满足小G的一些新的需要。当然，基于美学考虑，小G 是不允许你删改篱笆桩上已经写上的字母的。 我们更具体地描述这个过程。我们将 K个长度为 L的篱笆桩叠在一起，可以得到一个写有 K行L列共K*L个字母的面，每一个字母都在对应的唯一的格子里。\n\n我们从左上角开始依次向下读出每一个字母可以得到一个字母的序列，比如上图中的这个例子，那么我们读出的结果就是“TOEIIZENITKN”。如果，这个串中有我们所需要的单词，那么显然我们只需要将一些格子刷白，就可以得到我们所需要的了。举个例子，比如小G想要给圣彼得堡的足球队泽尼特队做个广告，那么很显然只要按照上图中的做法就可以达到小G想要的效果了。\n\n现在小G已经想好了要做怎样的广告，同时也提供给你了小G仓库中的篱笆桩的类型的描述，你可以认为每一种类型的篱笆桩都是有无数个的。现在小G 想知道至少需要多少个篱笆桩叠起来才可以做出小G想要的广告。", "inputFormat": "第一行两个自然数，N和L。\n \n接下来N 行，每行包含 L个小写字母，描述一种篱笆桩上写着的字母。保证不同类型的篱笆桩上的字母序列都是不一样的，每一种类型的篱笆桩都是有无数个。\n\n最后一行是一个字符串s，表示小G 想好的广告词。", "outputFormat": "第一行一个整数K，表示所需要的最少数量的篱笆桩（注意是数量，并不是种类数）。", "hint": "$1~\\leq~N,~L~\\leq~100$\n\n$1~\\leq~|s|~\\leq~200$", "locale": "zh-CN"}}}
{"pid": "P5255", "type": "P", "difficulty": 5, "samples": [["2 2 5", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2013", "各省省选", "江苏", "O2优化"], "title": "[JSOI2013] 美丽家园", "background": "", "description": "现在富裕的家庭都有了自己的别墅，别墅的院子往往大家选择铺上黑白两色的地砖。如何铺地砖是很有学问的，因为这涉及到美学方面的问题。怎样铺是美的呢？先看下面两组：\n\n![qwq](https://cdn.luogu.com.cn/upload/pic/54050.png)\n \nFigure 1 中的就被人们认定为比较美丽的，而 Figure 2 中的铺法则是不美丽的了。因为人们认为，如果出现一块 2*2 的区域里，只有一种颜色，那这就是不美丽的，反之则是美丽的。\n\n现在，小 G 的公司拿到了一个任务，一块 N*M 的院子必须铺上地砖。爱美之心人皆有之，主人家自然希望这块院子地砖的铺法是美丽的，所以他首先想让小 G 的公司拿出设计方案的总数来。\n\n而且这户主人家似乎对 P这个数特别迷信，所以他希望得到的总方案数对P取模后的结果。", "inputFormat": "仅有一行包含三个用空格隔开的正整数 $N,~M,~P$, 分别与题目描述中的数据对应。", "outputFormat": "输出总方案数对 $P$ 取模后的结果。", "hint": "$1~\\leq~N~\\leq~10^{100}$\n\n$1~\\leq~M~\\leq~5$\n\n$1~\\leq~P~\\leq~10000$", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2013] Beautiful Home", "background": "", "description": "Nowadays, wealthy families often have their own villas, and the courtyard of a villa is usually paved with black and white tiles. How to pave the tiles is quite a sophisticated matter, because it involves aesthetics. What kind of paving is considered beautiful? Look at the following two examples:\n\n![qwq](https://cdn.luogu.com.cn/upload/pic/54050.png)\n\nThe one in Figure 1 is considered relatively beautiful, while the paving in Figure 2 is not beautiful. This is because people believe that if there exists a $2*2$ area where there is only one color, then it is not beautiful; otherwise, it is beautiful.\n\nNow, Xiao G's company has received a task: a courtyard of size $N*M$ must be paved with tiles. Everyone loves beauty, so the owner naturally hopes the tiling of this courtyard is beautiful. Therefore, he first wants Xiao G's company to provide the total number of design plans.\n\nMoreover, the owner seems to be especially superstitious about the number $P$, so he wants the result to be the total number of plans modulo $P$.", "inputFormat": "There is only one line containing three positive integers $N,~M,~P$ separated by spaces, corresponding to the values described in the statement.", "outputFormat": "Output the total number of plans modulo $P$.", "hint": "$1~\\leq~N~\\leq~10^{100}$\n\n$1~\\leq~M~\\leq~5$\n\n$1~\\leq~P~\\leq~10000$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2013] 美丽家园", "background": "", "description": "现在富裕的家庭都有了自己的别墅，别墅的院子往往大家选择铺上黑白两色的地砖。如何铺地砖是很有学问的，因为这涉及到美学方面的问题。怎样铺是美的呢？先看下面两组：\n\n![qwq](https://cdn.luogu.com.cn/upload/pic/54050.png)\n \nFigure 1 中的就被人们认定为比较美丽的，而 Figure 2 中的铺法则是不美丽的了。因为人们认为，如果出现一块 2*2 的区域里，只有一种颜色，那这就是不美丽的，反之则是美丽的。\n\n现在，小 G 的公司拿到了一个任务，一块 N*M 的院子必须铺上地砖。爱美之心人皆有之，主人家自然希望这块院子地砖的铺法是美丽的，所以他首先想让小 G 的公司拿出设计方案的总数来。\n\n而且这户主人家似乎对 P这个数特别迷信，所以他希望得到的总方案数对P取模后的结果。", "inputFormat": "仅有一行包含三个用空格隔开的正整数 $N,~M,~P$, 分别与题目描述中的数据对应。", "outputFormat": "输出总方案数对 $P$ 取模后的结果。", "hint": "$1~\\leq~N~\\leq~10^{100}$\n\n$1~\\leq~M~\\leq~5$\n\n$1~\\leq~P~\\leq~10000$", "locale": "zh-CN"}}}
{"pid": "P5256", "type": "P", "difficulty": 5, "samples": [["3\nAiBjCiDECjDiFGC\nAaBiCaDECiDaFGC\ncDEcDEbDE\naDEbDE\nccddef\naab", "1\n1\n2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2013", "各省省选", "江苏", "O2优化", "哈希 hashing", "KMP 算法"], "title": "[JSOI2013] 编程作业", "background": null, "description": "考虑到如下的两段代码，很容易发现他们其实是一样的。\n\n#### 代码1\n\n```cpp\nint i, j;\ni = 3;\nj = i + 1;\n```\n\n#### 代码2\n\n```cpp\nint a, i;\na = 3;\ni = a + 1;\n```\n\n这是因为这两段代码之间唯一的差异，只是他们更换了一下变量名，比如第一段代码中的 `i` 变成了第二段的 `a`，第一段的 `j` 变成了第二段的 `i` 。而其他的常量，例如 `3`，`1` 或者其他的关键字和运算符，比如 `int`，`+` 和 `;`。都是没有发生变化的。 \n\n不过注意到如下的代码片段，我们并不能简单认为这是一样的，因为这不是一个简单的替换，而是可以导致不同运算结果的。\n#### 代码3\n\n```cpp\na = 3;\nb = 3;\n```\n\n#### 代码4\n```cpp\nc = 3;\nc = 3; \n```\n\n为了简化问题，我们用大写字母来表示所有的关键字、常量等非变量符号。\n\n假如我们采用如下的替换表：\n\n![qwq](https://cdn.luogu.com.cn/upload/pic/54051.png)\n\n那么最开始给出的两段雷同代码就可以分别写成 `AiBjCiDECjDiFGC` 以及 `AaBiCaDECiDaFGC`。\n\n或者简单的说，我们认为这两段代码是一样的。\n\n现在请写一个程序，处理若干这样的代码雷同检测问题：给一个完整代码以及一个较短的代码片段，请求出，这个代码片段在完整代码中一共出现了多少次（代码片段出现的位置可以重叠）。\n\n为了简单起见，我们认为程序中只会至多出现 $\\text a\\sim \\text z$ 这 $26$ 个变量，同时也至\n多只有 $\\text A\\sim \\text Z$ 这 $26$ 个非变量符号。", "inputFormat": "第一行包含一个整数 $Q$ 表示此数据中一共包含 $Q$ 个询问。\n\n接下来 $2Q$ 行，每两行为一个询问。\n\n每个询问中的第一行包含一个字符串 $S$，表示完整代码，第二行包含一个字符串 $T$，表示需要检测出现次数的代码片段。", "outputFormat": "一共输出 $Q$ 行，每行一个整数，表示对应代码片段的出现次数。", "hint": "#### 样例说明\n前两个样例均为题目中所举例的代码段。第三个样例中，在完整代码 $S$ 中与代码片段 $T$ 一样的片段为：`ccd` 和 `dde`\n\n#### 数据范围\n$Q<=3,|T|<=10^5,|S|<=10^6$", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2013] Programming Assignment", "background": "", "description": "Consider the following two pieces of code. It is easy to see that they are actually the same.\n\n#### Code 1\n\n```cpp\nint i, j;\ni = 3;\nj = i + 1;\n```\n\n#### Code 2\n\n```cpp\nint a, i;\na = 3;\ni = a + 1;\n```\n\nThis is because the only difference between these two pieces of code is that they rename the variables. For example, `i` in the first code becomes `a` in the second code, and `j` in the first code becomes `i` in the second code. All other constants, such as `3` and `1`, and other keywords and operators, such as `int`, `+`, and `;`, do not change.\n\nHowever, for the following code fragments, we cannot simply treat them as the same, because this is not a simple replacement and it can lead to different computation results.\n\n#### Code 3\n\n```cpp\na = 3;\nb = 3;\n```\n\n#### Code 4\n\n```cpp\nc = 3;\nc = 3; \n```\n\nTo simplify the problem, we use uppercase letters to represent all non-variable symbols, such as keywords and constants.\n\nSuppose we use the following substitution table:\n\n![qwq](https://cdn.luogu.com.cn/upload/pic/54051.png)\n\nThen the two similar code pieces given at the beginning can be written as `AiBjCiDECjDiFGC` and `AaBiCaDECiDaFGC`, respectively.\n\nIn other words, we consider these two pieces of code to be the same.\n\nNow please write a program to handle several such code similarity detection queries: given a full code string and a shorter code fragment, find how many times this fragment appears in the full code (the occurrence positions may overlap).\n\nFor simplicity, we assume that at most the $26$ variables $\\text a\\sim \\text z$ may appear in the program, and at most the $26$ non-variable symbols $\\text A\\sim \\text Z$ may appear.", "inputFormat": "The first line contains an integer $Q$, indicating that this testdata contains $Q$ queries in total.\n\nThe next $2Q$ lines describe the queries, with every two lines forming one query.\n\nIn each query, the first line contains a string $S$, representing the full code, and the second line contains a string $T$, representing the code fragment whose number of occurrences needs to be checked.", "outputFormat": "Output $Q$ lines in total. Each line contains an integer, representing the number of occurrences of the corresponding code fragment.", "hint": "#### Sample Explanation\n\nIn the first two samples, the code fragments are the examples given in the statement. In the third sample, the fragments in the full code $S$ that are the same as the code fragment $T$ are: `ccd` and `dde`.\n\n#### Constraints\n\n$Q<=3,|T|<=10^5,|S|<=10^6$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2013] 编程作业", "background": null, "description": "考虑到如下的两段代码，很容易发现他们其实是一样的。\n\n#### 代码1\n\n```cpp\nint i, j;\ni = 3;\nj = i + 1;\n```\n\n#### 代码2\n\n```cpp\nint a, i;\na = 3;\ni = a + 1;\n```\n\n这是因为这两段代码之间唯一的差异，只是他们更换了一下变量名，比如第一段代码中的 `i` 变成了第二段的 `a`，第一段的 `j` 变成了第二段的 `i` 。而其他的常量，例如 `3`，`1` 或者其他的关键字和运算符，比如 `int`，`+` 和 `;`。都是没有发生变化的。 \n\n不过注意到如下的代码片段，我们并不能简单认为这是一样的，因为这不是一个简单的替换，而是可以导致不同运算结果的。\n#### 代码3\n\n```cpp\na = 3;\nb = 3;\n```\n\n#### 代码4\n```cpp\nc = 3;\nc = 3; \n```\n\n为了简化问题，我们用大写字母来表示所有的关键字、常量等非变量符号。\n\n假如我们采用如下的替换表：\n\n![qwq](https://cdn.luogu.com.cn/upload/pic/54051.png)\n\n那么最开始给出的两段雷同代码就可以分别写成 `AiBjCiDECjDiFGC` 以及 `AaBiCaDECiDaFGC`。\n\n或者简单的说，我们认为这两段代码是一样的。\n\n现在请写一个程序，处理若干这样的代码雷同检测问题：给一个完整代码以及一个较短的代码片段，请求出，这个代码片段在完整代码中一共出现了多少次（代码片段出现的位置可以重叠）。\n\n为了简单起见，我们认为程序中只会至多出现 $\\text a\\sim \\text z$ 这 $26$ 个变量，同时也至\n多只有 $\\text A\\sim \\text Z$ 这 $26$ 个非变量符号。", "inputFormat": "第一行包含一个整数 $Q$ 表示此数据中一共包含 $Q$ 个询问。\n\n接下来 $2Q$ 行，每两行为一个询问。\n\n每个询问中的第一行包含一个字符串 $S$，表示完整代码，第二行包含一个字符串 $T$，表示需要检测出现次数的代码片段。", "outputFormat": "一共输出 $Q$ 行，每行一个整数，表示对应代码片段的出现次数。", "hint": "#### 样例说明\n前两个样例均为题目中所举例的代码段。第三个样例中，在完整代码 $S$ 中与代码片段 $T$ 一样的片段为：`ccd` 和 `dde`\n\n#### 数据范围\n$Q<=3,|T|<=10^5,|S|<=10^6$", "locale": "zh-CN"}}}
{"pid": "P5257", "type": "P", "difficulty": 6, "samples": [["2", "35"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["数学", "2013", "各省省选", "矩阵运算", "江苏", "O2优化"], "title": "[JSOI2013] 密码", "background": "Will 有一个神秘盒，传说只要有人能解开神秘盒上的密码，就可以预知未来（比如知道这道题的标程是怎样的），你愿意来尝试一下么？", "description": "对于一个 $m$ 位的十进制整数 $N~=~(\\overline{n_1 n_2 n_3 \\dots n_m})_{10}$，定义 $g(N)~=~\\sum_{i = 1}^{m} n_i$。\n\n定义集合 $S_N~=~\\{x~|~x~>~0,~g(x)~\\leq~N,x~\\text{的十进制表示中任意位不为} 0\\}$。\n\n给定 $n$，求\n\n$$f(n)~=~\\sum_{x \\in S_n} \\sum_{y \\in S_n \\land x < y} x~\\times~y$$\n\n答案对 $10^6+3$ 取模。", "inputFormat": "一行一个正整数 $n$。", "outputFormat": "一行一个整数代表答案对 $10^6 + 3$ 取模的结果。", "hint": "#### 样例输入输出 1 解释\n\n$S_n={1, 2, 11}$，故 $f(N)~=~1 \\times 2+1 \\times 11+2 \\times 11~=~35$。\n\n---\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $3~\\leq~n~\\leq~10^{18}$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2013] Password", "background": "Will has a mysterious box. It is said that if someone can crack the password on the box, they can foresee the future (for example, know what the official solution of this problem looks like). Would you like to give it a try?", "description": "For an $m$-digit decimal integer $N~=~(\\overline{n_1 n_2 n_3 \\dots n_m})_{10}$, define $g(N)~=~\\sum_{i = 1}^{m} n_i$.\n\nDefine the set $S_N~=~\\{x~|~x~>~0,~g(x)~\\leq~N,x~\\text{ has no digit equal to } 0 \\text{ in its decimal representation}\\}$.\n\nGiven $n$, compute\n\n$$f(n)~=~\\sum_{x \\in S_n} \\sum_{y \\in S_n \\land x < y} x~\\times~y$$\n\nOutput the answer modulo $10^6+3$.", "inputFormat": "One line with a positive integer $n$.", "outputFormat": "One line with one integer, representing the result of the answer modulo $10^6 + 3$.", "hint": "#### Explanation for Sample Input/Output 1\n\n$S_n={1, 2, 11}$, so $f(N)~=~1 \\times 2+1 \\times 11+2 \\times 11~=~35$.\n\n---\n\n#### Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that $3~\\leq~n~\\leq~10^{18}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2013] 密码", "background": "Will 有一个神秘盒，传说只要有人能解开神秘盒上的密码，就可以预知未来（比如知道这道题的标程是怎样的），你愿意来尝试一下么？", "description": "对于一个 $m$ 位的十进制整数 $N~=~(\\overline{n_1 n_2 n_3 \\dots n_m})_{10}$，定义 $g(N)~=~\\sum_{i = 1}^{m} n_i$。\n\n定义集合 $S_N~=~\\{x~|~x~>~0,~g(x)~\\leq~N,x~\\text{的十进制表示中任意位不为} 0\\}$。\n\n给定 $n$，求\n\n$$f(n)~=~\\sum_{x \\in S_n} \\sum_{y \\in S_n \\land x < y} x~\\times~y$$\n\n答案对 $10^6+3$ 取模。", "inputFormat": "一行一个正整数 $n$。", "outputFormat": "一行一个整数代表答案对 $10^6 + 3$ 取模的结果。", "hint": "#### 样例输入输出 1 解释\n\n$S_n={1, 2, 11}$，故 $f(N)~=~1 \\times 2+1 \\times 11+2 \\times 11~=~35$。\n\n---\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $3~\\leq~n~\\leq~10^{18}$。", "locale": "zh-CN"}}}
{"pid": "P5258", "type": "P", "difficulty": 5, "samples": [["4\n0 1\n1 2\n1 3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["贪心", "2013", "各省省选", "江苏", "O2优化", "上下界网络流"], "title": "[JSOI2013] 旅行时的困惑", "background": "", "description": "Waldives 有 $N$ 个小岛。目前的交通系统中包含 $N-1$ 条快艇专线，每条快艇专线连接两个岛。这 $N-1$ 条快艇专线恰好形成了一棵树。\n\n由于特殊的原因，所有 $N-1$ 条快艇专线都是单向的。这导致了很多岛屿之间\n不能相互到达。因此，Waldives 政府希望新建一些公交线路，使得建设完毕后，任意两个小岛都可以互相到达。为了节约开支，政府希望建设最少的公交线路。 \n\n同时，出于规划考虑，每一条公交线路都有如下的要求：\n> 1、每一条交通线路包含若干条连续的快艇专线，你可以认为一条公交线路\n对应树上的一条路径，而其所包含的若干快艇专线则对应树上被这条路\n径所覆盖的树边（也就是之前已经存在的某个快艇专线）；\n>\n> 2、显然一条交通线路只能覆盖树上任意一条边至多一次；\n>\n> 3、公交线路中所包含的每一个快艇专线都是有方向的，并且与其所覆盖的\n树边的方向相反；\n>\n>4、不同的公交线路可以覆盖树上相同的点或者相同的边。\n\nWaldives 的 $N$ 个岛屿分别从 $0$ 到 $N-1$ 编号。现在给出 Waldives 已有的快艇专线信息，请计算最少所需要新建的交通线路的数量。", "inputFormat": "第一行包含一个整数 $N$。\n\n接下来 $N-1$行，每行包含两个整数 $x,~y$。表示存在一条从岛屿 $x$ 开往岛屿 $y$ 的快艇专线。", "outputFormat": "输出一行一个整数，表示需要建设的最少的交通线路数量。", "hint": "$1~\\leq~N~\\leq~10^5$", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2013] Confusion During Travel", "background": "", "description": "Waldives has $N$ small islands. The current transportation system contains $N-1$ express boat routes, and each express boat route connects two islands. These $N-1$ express boat routes form a tree.\n\nFor special reasons, all $N-1$ express boat routes are one-way. This makes many pairs of islands unable to reach each other. Therefore, the Waldives government wants to build some new bus routes so that after construction, any two islands can reach each other. To save money, the government wants to build as few bus routes as possible.\n\nAt the same time, for planning reasons, each bus route must satisfy the following requirements:\n> 1. Each transportation route contains several consecutive express boat routes. You may treat one bus route as a path on the tree, and the express boat routes it contains correspond to the tree edges covered by this path (that is, some express boat routes that already exist).\n>\n> 2. Obviously, a transportation route can cover any edge on the tree at most once.\n>\n> 3. Each express boat route included in a bus route has a direction, and this direction is opposite to the direction of the tree edge it covers.\n>\n> 4. Different bus routes may cover the same vertices or the same edges on the tree.\n\nThe $N$ islands of Waldives are numbered from $0$ to $N-1$. Now the existing express boat route information of Waldives is given. Please compute the minimum number of new transportation routes that need to be built.", "inputFormat": "The first line contains an integer $N$.\n\nThe next $N-1$ lines each contain two integers $x,~y$, meaning that there is an express boat route from island $x$ to island $y$.", "outputFormat": "Output one line with one integer, representing the minimum number of transportation routes that need to be built.", "hint": "$1~\\leq~N~\\leq~10^5$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2013] 旅行时的困惑", "background": "", "description": "Waldives 有 $N$ 个小岛。目前的交通系统中包含 $N-1$ 条快艇专线，每条快艇专线连接两个岛。这 $N-1$ 条快艇专线恰好形成了一棵树。\n\n由于特殊的原因，所有 $N-1$ 条快艇专线都是单向的。这导致了很多岛屿之间\n不能相互到达。因此，Waldives 政府希望新建一些公交线路，使得建设完毕后，任意两个小岛都可以互相到达。为了节约开支，政府希望建设最少的公交线路。 \n\n同时，出于规划考虑，每一条公交线路都有如下的要求：\n> 1、每一条交通线路包含若干条连续的快艇专线，你可以认为一条公交线路\n对应树上的一条路径，而其所包含的若干快艇专线则对应树上被这条路\n径所覆盖的树边（也就是之前已经存在的某个快艇专线）；\n>\n> 2、显然一条交通线路只能覆盖树上任意一条边至多一次；\n>\n> 3、公交线路中所包含的每一个快艇专线都是有方向的，并且与其所覆盖的\n树边的方向相反；\n>\n>4、不同的公交线路可以覆盖树上相同的点或者相同的边。\n\nWaldives 的 $N$ 个岛屿分别从 $0$ 到 $N-1$ 编号。现在给出 Waldives 已有的快艇专线信息，请计算最少所需要新建的交通线路的数量。", "inputFormat": "第一行包含一个整数 $N$。\n\n接下来 $N-1$行，每行包含两个整数 $x,~y$。表示存在一条从岛屿 $x$ 开往岛屿 $y$ 的快艇专线。", "outputFormat": "输出一行一个整数，表示需要建设的最少的交通线路数量。", "hint": "$1~\\leq~N~\\leq~10^5$", "locale": "zh-CN"}}}
{"pid": "P5259", "type": "P", "difficulty": 4, "samples": [["3 1 1000000009 ", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2013", "各省省选", "江苏", "O2优化"], "title": "[JSOI2013] 游戏中的学问", "background": "", "description": "大家应该都见过很多人手拉手围着篝火跳舞的场景吧？一般情况下，大家手拉手跳舞总是会围成一个大圈，每个人的左手拉着旁边朋友的右手，右手拉着另\n一侧朋友的左手。\n\n不过，如果每一个人都随机的拉住两个不同人的手，然后再慢慢散开，事情\n就变得有趣多了——此时大家依旧会形成圈，不过却可能会形成多个独立的圈。\n当然这里我们依然要求一个人的右手只能拉另一个人的左手，反之亦然。\n\n班里一共有 $N$ 个同学，由 $1$ 到 $N$ 编号。Will想知道，究竟有多少种本质不\n同的拉手方案，使得最终大家散开后恰好形成 $k$ 个圈呢？\n\n给定两种方案，若存在一个人和他的一只手，满足在这两种方案中，拉着这\n只手的人的编号不同，则这两种方案本质不同。", "inputFormat": "输入一行包含三个正整数$N,~k,~P$", "outputFormat": "输出文件的包含一行一个整数，表示本质不同的方案数对p的余数。保证p\n一定是一个质数。", "hint": "$3~\\leq~3k~\\leq~N~\\leq~3000$\n\n$10^4~\\leq~p~\\leq~2~\\times~10^9$", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2013] Knowledge in Games", "background": "", "description": "You have probably seen the scene where many people hold hands and dance around a bonfire. In general, when everyone dances hand in hand, they form one big circle: each person's left hand holds the right hand of the friend next to them, and their right hand holds the left hand of the friend on the other side.\n\nHowever, if everyone randomly holds the hands of two different people and then slowly spreads out, things become much more interesting. At this time, everyone will still form circles, but they may form several independent circles. Of course, we still require that a person's right hand can only hold another person's left hand, and vice versa.\n\nThere are $N$ students in the class, numbered from $1$ to $N$. Will wants to know how many essentially different hand-holding arrangements will make them form exactly $k$ circles after they spread out.\n\nGiven two arrangements, if there exists a person and one of their hands such that, in these two arrangements, the number of the person holding that hand is different, then these two arrangements are essentially different.", "inputFormat": "One line containing three positive integers $N,~k,~P$.", "outputFormat": "Output one integer in one line, representing the remainder of the number of essentially different arrangements modulo $p$. It is guaranteed that $p$ is a prime number.", "hint": "Constraints:\n\n$3~\\leq~3k~\\leq~N~\\leq~3000$.\n\n$10^4~\\leq~p~\\leq~2~\\times~10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2013] 游戏中的学问", "background": "", "description": "大家应该都见过很多人手拉手围着篝火跳舞的场景吧？一般情况下，大家手拉手跳舞总是会围成一个大圈，每个人的左手拉着旁边朋友的右手，右手拉着另\n一侧朋友的左手。\n\n不过，如果每一个人都随机的拉住两个不同人的手，然后再慢慢散开，事情\n就变得有趣多了——此时大家依旧会形成圈，不过却可能会形成多个独立的圈。\n当然这里我们依然要求一个人的右手只能拉另一个人的左手，反之亦然。\n\n班里一共有 $N$ 个同学，由 $1$ 到 $N$ 编号。Will想知道，究竟有多少种本质不\n同的拉手方案，使得最终大家散开后恰好形成 $k$ 个圈呢？\n\n给定两种方案，若存在一个人和他的一只手，满足在这两种方案中，拉着这\n只手的人的编号不同，则这两种方案本质不同。", "inputFormat": "输入一行包含三个正整数$N,~k,~P$", "outputFormat": "输出文件的包含一行一个整数，表示本质不同的方案数对p的余数。保证p\n一定是一个质数。", "hint": "$3~\\leq~3k~\\leq~N~\\leq~3000$\n\n$10^4~\\leq~p~\\leq~2~\\times~10^9$", "locale": "zh-CN"}}}
{"pid": "P5260", "type": "P", "difficulty": 5, "samples": [["3\n2 2\n0 1\n1 0\n4 4\n0 1\n1 2\n2 0\n0 3\n8 12\n2 3\n2 6\n7 6\n1 7\n4 1\n3 4\n0 2\n7 3\n5 6\n5 1\n5 0\n4 0", "-1\n-1\n0 6 1 5 4 2 3 7"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "各省省选", "江苏", "Special Judge", "广度优先搜索 BFS", "位运算", "状压 DP"], "title": "[JSOI2013] 超立方体", "background": "超立方体是立方体在高维空间内的拓展（其在 2 维情况下退化为正方形，1 维情况下退化成线段）。在理论计算机科学领域里，超立方体往往可以和 2 进制编码联系到一起。对理论计算机科学颇有研究的 Will 自然也会对超立方体有着\n自己的思考。\n\n![qwq](https://cdn.luogu.com.cn/upload/pic/54052.png)\n\n上图就是在 0～4 维空间内超立方体所对应的图形。显然我们可以把超立方体的每个顶点看成一个点，每一条棱看成一条边，这样就会得到一个无向图，我们称之为超立方图。", "description": "D 维空间内的超立方图有 $2^D$ 个点，我们把这些点从 $0$ 到 $2^D-1$ 依次编号。\n\n有一个有趣而重要的充要结论是：一定存在一种编号的方式，使得图中任意两个有边相连的顶点的编号的 2 进制码中，恰好有一位不同。\n\n在2维和3维空间内这个结论可以这样形象的理解：对于 2 维空间，我们只要把这个正方形放到第一象限内，使得 4 个顶点的坐标按逆时针顺序依次为 $(0,0),(1,0),(1,1),(0,1)$，然后再把坐标看成 2 位 2 进制数，依次将这 4 个点编号为  0,1,3,2即可。\n\n对于 3 维空间，同样我们可以将立方体的一个顶点与原点重合，并使得所有棱均平行于坐标轴，然后分别确定这 8 个点的坐标，最后把 3 维空间内的坐标看成一个 3 位 2 进制数即可。对于 D 维空间，以此类推。\n\n现在对于一个 $N$ 个点 $M$ 条边的无向图（每个点从 $0$ 到 $N-1$ 编号），Will 希望知道这个图是否同构于一个超立方图。", "inputFormat": "第一行包含一个整数 $Q$ 表示此数据中一共包含 $Q$ 个询问。\n\n接下来 $Q$ 组询问，每一组询问的输入格式如下：\n\n第一行包含两个整数 $N$ 和 $M$，接下来 $M$ 行，每行 2 个不同的整数 $x,y$，表示图中存在一条无向边连接编\n号为 $x$ 和 $y$ 的点（$0 \\le x,y < N$）\n\n\n", "outputFormat": "1、如果询问中给定的图不同构于任何一个超立方图，输出 $-1$；\n\n2、如果同构于某一个超立方图，那么请给图中这 $N$ 个点重新编号，并在这一行输出 $N$ 个用空格隔开的整数，表示原图中每个点新的编号，使得重新编号后，满足题目中所述的结论。\n\n注意：输出文件的每一行，要么仅包含一个整数 $-1$，要么则应包含一个由 $0$ 到 $N-1$ 这 $N$ 个数组成的排列。如果有多组解输出任意一个均可。", "hint": "$Q~\\leq~3,~N~\\leq~32768,~M~\\leq~1000000$", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2013] Hypercube.", "background": "A hypercube is an extension of a cube into higher-dimensional space (it becomes a square in 2D and a line segment in 1D). In theoretical computer science, a hypercube is often related to binary encoding. Will, who has done quite a bit of research in theoretical computer science, naturally has his own thoughts about hypercubes.\n\n![qwq](https://cdn.luogu.com.cn/upload/pic/54052.png)\n\nThe figure above shows the shapes corresponding to hypercubes in $0$ to $4$ dimensions. Clearly, we can view each vertex of a hypercube as a point, and each edge as a graph edge. In this way, we get an undirected graph, which we call a hypercube graph.", "description": "A $D$-dimensional hypercube graph has $2^D$ vertices. We label these vertices from $0$ to $2^D - 1$.\n\nThere is an interesting and important necessary and sufficient conclusion: there must exist a way of labeling such that, for any two adjacent vertices in the graph, their labels’ binary codes differ in exactly one bit.\n\nIn 2D and 3D, this can be understood intuitively as follows.\n\nFor 2D, we can place the square in the first quadrant so that its four vertices, in counterclockwise order, are $(0,0)$, $(1,0)$, $(1,1)$, $(0,1)$. Then treat each coordinate as a 2-bit binary number, and label these four points as $0, 1, 3, 2$.\n\nFor 3D, similarly, we can make one vertex of the cube coincide with the origin, and make all edges parallel to the coordinate axes. Then determine the coordinates of the 8 points, and finally treat each 3D coordinate as a 3-bit binary number. For $D$ dimensions, do the same, and so on.\n\nNow, given an undirected graph with $N$ vertices and $M$ edges (vertices are labeled from $0$ to $N - 1$), Will wants to know whether this graph is isomorphic to a hypercube graph.", "inputFormat": "The first line contains an integer $Q$, meaning there are $Q$ queries in this input.\n\nThen follow $Q$ queries. For each query, the input format is:\n\nThe first line contains two integers $N$ and $M$. The next $M$ lines each contain two different integers $x, y$, indicating that there is an undirected edge between vertex $x$ and vertex $y$ in the graph ($0 \\le x, y < N$).", "outputFormat": "1. If the graph given in a query is not isomorphic to any hypercube graph, output $-1$.\n\n2. If it is isomorphic to some hypercube graph, please relabel these $N$ vertices, and output on this line $N$ integers separated by spaces. The $i$-th integer denotes the new label of vertex $i$ in the original graph, such that after relabeling, the conclusion described in the statement is satisfied.\n\nNote: Each line of the output file must either contain only one integer $-1$, or contain a permutation of $N$ numbers from $0$ to $N - 1$. If there are multiple solutions, output any one.", "hint": "$Q \\leq 3, N \\leq 32768, M \\leq 1000000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2013] 超立方体", "background": "超立方体是立方体在高维空间内的拓展（其在 2 维情况下退化为正方形，1 维情况下退化成线段）。在理论计算机科学领域里，超立方体往往可以和 2 进制编码联系到一起。对理论计算机科学颇有研究的 Will 自然也会对超立方体有着\n自己的思考。\n\n![qwq](https://cdn.luogu.com.cn/upload/pic/54052.png)\n\n上图就是在 0～4 维空间内超立方体所对应的图形。显然我们可以把超立方体的每个顶点看成一个点，每一条棱看成一条边，这样就会得到一个无向图，我们称之为超立方图。", "description": "D 维空间内的超立方图有 $2^D$ 个点，我们把这些点从 $0$ 到 $2^D-1$ 依次编号。\n\n有一个有趣而重要的充要结论是：一定存在一种编号的方式，使得图中任意两个有边相连的顶点的编号的 2 进制码中，恰好有一位不同。\n\n在2维和3维空间内这个结论可以这样形象的理解：对于 2 维空间，我们只要把这个正方形放到第一象限内，使得 4 个顶点的坐标按逆时针顺序依次为 $(0,0),(1,0),(1,1),(0,1)$，然后再把坐标看成 2 位 2 进制数，依次将这 4 个点编号为  0,1,3,2即可。\n\n对于 3 维空间，同样我们可以将立方体的一个顶点与原点重合，并使得所有棱均平行于坐标轴，然后分别确定这 8 个点的坐标，最后把 3 维空间内的坐标看成一个 3 位 2 进制数即可。对于 D 维空间，以此类推。\n\n现在对于一个 $N$ 个点 $M$ 条边的无向图（每个点从 $0$ 到 $N-1$ 编号），Will 希望知道这个图是否同构于一个超立方图。", "inputFormat": "第一行包含一个整数 $Q$ 表示此数据中一共包含 $Q$ 个询问。\n\n接下来 $Q$ 组询问，每一组询问的输入格式如下：\n\n第一行包含两个整数 $N$ 和 $M$，接下来 $M$ 行，每行 2 个不同的整数 $x,y$，表示图中存在一条无向边连接编\n号为 $x$ 和 $y$ 的点（$0 \\le x,y < N$）\n\n\n", "outputFormat": "1、如果询问中给定的图不同构于任何一个超立方图，输出 $-1$；\n\n2、如果同构于某一个超立方图，那么请给图中这 $N$ 个点重新编号，并在这一行输出 $N$ 个用空格隔开的整数，表示原图中每个点新的编号，使得重新编号后，满足题目中所述的结论。\n\n注意：输出文件的每一行，要么仅包含一个整数 $-1$，要么则应包含一个由 $0$ 到 $N-1$ 这 $N$ 个数组成的排列。如果有多组解输出任意一个均可。", "hint": "$Q~\\leq~3,~N~\\leq~32768,~M~\\leq~1000000$", "locale": "zh-CN"}}}
{"pid": "P5261", "type": "P", "difficulty": 6, "samples": [["2 9 9 5", "18"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2013", "各省省选", "江苏", "O2优化"], "title": "[JSOI2013] 数字理论", "background": "", "description": "给定 $4$ 个正整数 $K,~S,~P,~D$，要求在十进制数中，寻找一个最小的 $K$ 位自然数 $x$，满足 $x$ 的各个数位之和为 $S$，并且 $x$ 乘以 $D$ 之后各个数位之和为 $P$。", "inputFormat": "输入数据中包含一行四个整数，分别为 $K,~S,~P,~D$。\n", "outputFormat": "输出一行一个整数，表示满足条件的最小自然数 $x$。如果不存在则输出$-1$。", "hint": "$1~\\leq~K~\\leq~100,~1~\\leq~S,~P~\\leq~1000,~1~\\leq~D~\\leq~9$", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2013] Number Theory", "background": "", "description": "Given four positive integers $K,~S,~P,~D$, in decimal, find the smallest $K$-digit natural number $x$ such that the sum of digits of $x$ is $S$, and the sum of digits of $x \\times D$ is $P$.", "inputFormat": "The input contains one line with four integers: $K,~S,~P,~D$.", "outputFormat": "Output one integer in one line, representing the smallest natural number $x$ that satisfies the conditions. If it does not exist, output $-1$.", "hint": "Constraints: $1~\\leq~K~\\leq~100,~1~\\leq~S,~P~\\leq~1000,~1~\\leq~D~\\leq~9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2013] 数字理论", "background": "", "description": "给定 $4$ 个正整数 $K,~S,~P,~D$，要求在十进制数中，寻找一个最小的 $K$ 位自然数 $x$，满足 $x$ 的各个数位之和为 $S$，并且 $x$ 乘以 $D$ 之后各个数位之和为 $P$。", "inputFormat": "输入数据中包含一行四个整数，分别为 $K,~S,~P,~D$。\n", "outputFormat": "输出一行一个整数，表示满足条件的最小自然数 $x$。如果不存在则输出$-1$。", "hint": "$1~\\leq~K~\\leq~100,~1~\\leq~S,~P~\\leq~1000,~1~\\leq~D~\\leq~9$", "locale": "zh-CN"}}}
{"pid": "P5262", "type": "P", "difficulty": 0, "samples": [["10 7 7\n8 3 5 4 5 7 4 2 1 3", "3\n----+++++"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2007", "2013", "各省省选", "江苏", "O2优化", "ROI（俄罗斯）"], "title": "[ROI2007 / JSOI2013] 体育课", "background": null, "description": "体育课里一共有 $N$ 个同学，学号从 $1$ 到 $N$。JYY 的体育老师 KFC 有一个特殊排队方法：\n- KFC 先让班里的 $N$ 个同学按照学号从小到大的顺序，从左到右站成一排，然后从到队列的最左边（也就是第一个学生面前）开始，一直向右走动到第 $N-1$ 个学生面前；\n- 接着 KFC 再回到第一个学生面前，继续开始向右走，就这样一共走动 $N-1$ 次。\n- 每次当 KFC 走到第 $i$ 个学生面前时，KFC 会比较一下队列里第 $i$ 个学生和第 $i+1$ 个学生的身高，如果左边（第 $i$ 个）的学生比右边（第 $i+1$ 个）的学生高，那么 KFC 就会交换这两个学生在队列里的位置。\n\n最终，在 $N-1$ 次走动全部结束之后，KFC 会选出队列最右边的一些学生去搬桌子。自然地，JYY 希望能够站在尽量靠左的位置来增加自己踢足球的机会。\n\n此外，JYY 还有一个绝招，那就是在 KFC 老师快走到自己面前的时候，开始蹲下来系鞋带！如果 JYY 蹲下来系鞋带了，那么在这一次走动中，好说话的 KFC 老师就不会让 JYY 和相邻的同学比较身高了，自然也就不会让 JYY 和相邻的同学交换位置（只有 JYY 最聪明会蹲下来系鞋带，其他同学都只会老老实实的让 KFC 老师比较身高）。\n\n蹲下来系鞋带是很耗费体力的。为了留着体力踢足球，JYY 最多只能蹲下 $K$ 次。\n\nJYY 想知道，按照怎样的下蹲策略可以使自己在队列里站的尽量靠左。用一个长度为 $N-1$ 的字符串来表示一个策略：如果字符串的第 $i$ 个字符是 `+`，则表示在第 $i$ 次走动时 JYY 蹲下来系鞋带；如果第 $i$ 个字符是 `-`，则表示 JYY 会老老实实地比较身高。", "inputFormat": "第一行包含三个整数 $N,P,K$，分别表示同学的数量、JYY 的学号、JYY 最多能蹲下的次数。\n\n第二行包含 $N$ 个整数，其中第 $i$ 个整数表示 $h_i$，表示学号为 $i$ 的同学的身高。", "outputFormat": "第一行包含一个正整数，表示按照最佳策略时 JYY 可以排在的最靠左的位置。\n\n第二行包含一个长度为 $N-1$ 的字符串，表示最佳策略。如果有多个最佳策略，JYY 希望知道字典序最大的策略。", "hint": "数据范围：$1\\le P\\le N\\le 10^5$，$0\\le K\\le N-1$，$1\\le h_i\\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[ROI2007 / JSOI2013] PE Class", "background": "", "description": "There are $N$ students in the PE class, with student IDs from $1$ to $N$. JYY’s PE teacher KFC has a special way to arrange the line:\n- KFC first makes the $N$ students stand in a row from left to right in increasing order of student ID. Then, starting from the far left of the line (in front of the first student), KFC walks to the right until reaching the $(N-1)$-th student.\n- Next, KFC returns to the first student and starts walking to the right again. In total, KFC walks $N-1$ times.\n- Each time when KFC reaches the $i$-th student, KFC compares the heights of the $i$-th and $(i+1)$-th students. If the student on the left (the $i$-th) is taller than the student on the right (the $(i+1)$-th), KFC swaps their positions in the line.\n\nAfter all $N-1$ walks are finished, KFC will choose some students on the far right of the line to move desks. Naturally, JYY wants to stand as far to the left as possible to increase his chances to play soccer.\n\nIn addition, JYY has a special trick: when KFC is about to walk up to him, JYY can squat down to tie his shoelaces. If JYY squats down to tie his shoelaces, then during that walk, the easygoing teacher KFC will not make JYY compare heights with adjacent students, and of course will not make JYY swap positions with adjacent students (only JYY is smart enough to squat down; all other students will honestly let KFC compare heights).\n\nSquatting down to tie shoelaces costs a lot of energy. To save energy for playing soccer, JYY can squat at most $K$ times.\n\nJYY wants to know what squatting strategy can make him stand as far to the left as possible in the line. Use a string of length $N-1$ to represent a strategy: if the $i$-th character of the string is `+`, it means JYY squats down to tie his shoelaces during the $i$-th walk; if it is `-`, it means JYY will honestly compare heights.", "inputFormat": "The first line contains three integers $N, P, K$, representing the number of students, JYY’s student ID, and the maximum number of times JYY can squat.\n\nThe second line contains $N$ integers, where the $i$-th integer is $h_i$, the height of the student with ID $i$.", "outputFormat": "The first line contains one positive integer, the leftmost position JYY can reach under the best strategy.\n\nThe second line contains a string of length $N-1$, representing the best strategy. If there are multiple best strategies, JYY wants the lexicographically largest one.", "hint": "Constraints: $1\\le P\\le N\\le 10^5$, $0\\le K\\le N-1$, $1\\le h_i\\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ROI2007 / JSOI2013] 体育课", "background": null, "description": "体育课里一共有 $N$ 个同学，学号从 $1$ 到 $N$。JYY 的体育老师 KFC 有一个特殊排队方法：\n- KFC 先让班里的 $N$ 个同学按照学号从小到大的顺序，从左到右站成一排，然后从到队列的最左边（也就是第一个学生面前）开始，一直向右走动到第 $N-1$ 个学生面前；\n- 接着 KFC 再回到第一个学生面前，继续开始向右走，就这样一共走动 $N-1$ 次。\n- 每次当 KFC 走到第 $i$ 个学生面前时，KFC 会比较一下队列里第 $i$ 个学生和第 $i+1$ 个学生的身高，如果左边（第 $i$ 个）的学生比右边（第 $i+1$ 个）的学生高，那么 KFC 就会交换这两个学生在队列里的位置。\n\n最终，在 $N-1$ 次走动全部结束之后，KFC 会选出队列最右边的一些学生去搬桌子。自然地，JYY 希望能够站在尽量靠左的位置来增加自己踢足球的机会。\n\n此外，JYY 还有一个绝招，那就是在 KFC 老师快走到自己面前的时候，开始蹲下来系鞋带！如果 JYY 蹲下来系鞋带了，那么在这一次走动中，好说话的 KFC 老师就不会让 JYY 和相邻的同学比较身高了，自然也就不会让 JYY 和相邻的同学交换位置（只有 JYY 最聪明会蹲下来系鞋带，其他同学都只会老老实实的让 KFC 老师比较身高）。\n\n蹲下来系鞋带是很耗费体力的。为了留着体力踢足球，JYY 最多只能蹲下 $K$ 次。\n\nJYY 想知道，按照怎样的下蹲策略可以使自己在队列里站的尽量靠左。用一个长度为 $N-1$ 的字符串来表示一个策略：如果字符串的第 $i$ 个字符是 `+`，则表示在第 $i$ 次走动时 JYY 蹲下来系鞋带；如果第 $i$ 个字符是 `-`，则表示 JYY 会老老实实地比较身高。", "inputFormat": "第一行包含三个整数 $N,P,K$，分别表示同学的数量、JYY 的学号、JYY 最多能蹲下的次数。\n\n第二行包含 $N$ 个整数，其中第 $i$ 个整数表示 $h_i$，表示学号为 $i$ 的同学的身高。", "outputFormat": "第一行包含一个正整数，表示按照最佳策略时 JYY 可以排在的最靠左的位置。\n\n第二行包含一个长度为 $N-1$ 的字符串，表示最佳策略。如果有多个最佳策略，JYY 希望知道字典序最大的策略。", "hint": "数据范围：$1\\le P\\le N\\le 10^5$，$0\\le K\\le N-1$，$1\\le h_i\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P5263", "type": "P", "difficulty": 6, "samples": [["3 10 150 250\n100 20 123\n201 10 67\n202 10 45", "190"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2013", "各省省选", "网络流", "江苏", "O2优化"], "title": "[JSOI2013] 打地鼠", "background": "JYY 特别喜欢到游戏厅玩打地鼠游戏——拿起两个锤子用力敲打不断冒出\n来的地鼠。\n\n打到不同的地鼠有不同的得分，JYY想知道怎样才能得到最高的分\n数。", "description": "游戏里一共会冒出来 $N$ 个地鼠，这些地鼠冒出来的位置都分布在一条直线\n上。第 $i$ 个地鼠会在 $T_i$ 时刻在 $X_i$ 位置冒出来，打到第 $i$ 个地鼠的得分是 $P_i$。\n\n当游戏开始时（也就是 0 时刻），JYY 左手的位置为 XLEFT，右手的位置为\nXRIGHT。JYY的手的最大移动速度是 $V$（每单位时刻最多移动的距离为 V） 。\n\n地鼠会在瞬间冒出来然后消失。如果在对应的时刻 JYY 的一只手恰好也在地鼠冒出来的位置，那么 JYY 就可以在瞬间完成击打动作并得到对应的分数,否则，JYY就只能错过这只地鼠了。\n\nJYY两只手都拿着锤子，所以两只手是可以同时打地鼠的。\n\n然而， 如果在游戏过程中 JYY的两只手交叉的话， JYY会感到很不舒服 （这\n个动作确实很别扭，而且两只手可能会互相阻碍而影响移动速度） ，所以 JYY希\n望在整个游戏过程中左手的位置 XLEFT永远严格小于右手的位置XRIGHT。JYY想知道，他最多能得多少分呢？", "inputFormat": "第一行包含四个整数$N,~V,~XLEFT,~XRIGHT$；\n接下来 $N$ 行，分别描述 $N$ 个可能出现的地鼠；\n其中第 $i$ 行包含三个整数 $X_i$，$T_i$，$P_i$。\n数据保证在同一个时刻不会有两个地鼠出现在同样的位置。", "outputFormat": "输出一行一个整数，表示JYY最多能够得到的分数。", "hint": "$1~\\leq~N~\\leq~3000,~1~\\leq~XLEFT~<~XRIGHT~\\leq~10^5,~1~\\leq~T_i~\\leq~10^5$\n\n$1~\\leq~P_i~\\leq~10^5,~1~\\leq~X_i~\\leq~10^5,~1~\\leq~V~\\leq~10^4$", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2013] Whac-a-Mole.", "background": "JYY really likes going to the arcade to play Whac-a-Mole—picking up two hammers and hitting the moles that keep popping out.\n\nHitting different moles gives different scores, and JYY wants to know how to get the highest score.", "description": "In the game, a total of $N$ moles will appear, and their positions are all on a straight line. The $i$-th mole appears at position $X_i$ at time $T_i$, and the score for hitting the $i$-th mole is $P_i$.\n\nWhen the game starts (that is, at time $0$), JYY’s left hand is at position XLEFT, and the right hand is at position XRIGHT. The maximum moving speed of JYY’s hands is $V$ (the maximum distance moved per unit time is $V$).\n\nEach mole appears and disappears instantly. If at the corresponding time, one of JYY’s hands is exactly at the position where the mole appears, then JYY can complete the hit instantly and get the corresponding score. Otherwise, JYY can only miss this mole.\n\nSince JYY holds hammers in both hands, the two hands can hit moles at the same time.\n\nHowever, if JYY’s two hands cross during the game, JYY will feel very uncomfortable (the movement is indeed awkward, and the two hands may block each other and affect the moving speed). Therefore, JYY hopes that throughout the whole game, the left hand position XLEFT is always strictly less than the right hand position XRIGHT. JYY wants to know the maximum total score he can get.", "inputFormat": "The first line contains four integers $N,~V,~XLEFT,~XRIGHT$.\nThe next $N$ lines describe the $N$ possible moles.\nThe $i$-th line contains three integers $X_i$, $T_i$, $P_i$.\nThe testdata guarantees that at the same time, there will not be two moles appearing at the same position.", "outputFormat": "Output one line with one integer, meaning the maximum score JYY can get.", "hint": "Constraints.\n\n$1~\\leq~N~\\leq~3000,~1~\\leq~XLEFT~<~XRIGHT~\\leq~10^5,~1~\\leq~T_i~\\leq~10^5$\n\n$1~\\leq~P_i~\\leq~10^5,~1~\\leq~X_i~\\leq~10^5,~1~\\leq~V~\\leq~10^4$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2013] 打地鼠", "background": "JYY 特别喜欢到游戏厅玩打地鼠游戏——拿起两个锤子用力敲打不断冒出\n来的地鼠。\n\n打到不同的地鼠有不同的得分，JYY想知道怎样才能得到最高的分\n数。", "description": "游戏里一共会冒出来 $N$ 个地鼠，这些地鼠冒出来的位置都分布在一条直线\n上。第 $i$ 个地鼠会在 $T_i$ 时刻在 $X_i$ 位置冒出来，打到第 $i$ 个地鼠的得分是 $P_i$。\n\n当游戏开始时（也就是 0 时刻），JYY 左手的位置为 XLEFT，右手的位置为\nXRIGHT。JYY的手的最大移动速度是 $V$（每单位时刻最多移动的距离为 V） 。\n\n地鼠会在瞬间冒出来然后消失。如果在对应的时刻 JYY 的一只手恰好也在地鼠冒出来的位置，那么 JYY 就可以在瞬间完成击打动作并得到对应的分数,否则，JYY就只能错过这只地鼠了。\n\nJYY两只手都拿着锤子，所以两只手是可以同时打地鼠的。\n\n然而， 如果在游戏过程中 JYY的两只手交叉的话， JYY会感到很不舒服 （这\n个动作确实很别扭，而且两只手可能会互相阻碍而影响移动速度） ，所以 JYY希\n望在整个游戏过程中左手的位置 XLEFT永远严格小于右手的位置XRIGHT。JYY想知道，他最多能得多少分呢？", "inputFormat": "第一行包含四个整数$N,~V,~XLEFT,~XRIGHT$；\n接下来 $N$ 行，分别描述 $N$ 个可能出现的地鼠；\n其中第 $i$ 行包含三个整数 $X_i$，$T_i$，$P_i$。\n数据保证在同一个时刻不会有两个地鼠出现在同样的位置。", "outputFormat": "输出一行一个整数，表示JYY最多能够得到的分数。", "hint": "$1~\\leq~N~\\leq~3000,~1~\\leq~XLEFT~<~XRIGHT~\\leq~10^5,~1~\\leq~T_i~\\leq~10^5$\n\n$1~\\leq~P_i~\\leq~10^5,~1~\\leq~X_i~\\leq~10^5,~1~\\leq~V~\\leq~10^4$", "locale": "zh-CN"}}}
{"pid": "P5264", "type": "P", "difficulty": 6, "samples": [["8 0\n0 4 2 6 1 5 3 7", "0 4 2 332748113 998244338 931694687 998244320 72887640"], ["8 1\n0 4 2 6 1 5 3 7", "1 0 998244345 998244345 665496220 332748123 44366450 133099314"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["倍增", "O2优化", "构造", "快速数论变换 NTT"], "title": "多项式三角函数", "background": "", "description": "给定一个 $n-1$ 次多项式 $A(x)$，求一个 $\\bmod{\\:x^n}$ 下的多项式 $F(x)$，满足 $F(x)\\equiv\\sin{A(x)}$ 或 $F(x)\\equiv\\cos{A(x)}$。\n\n所有运算在 $\\bmod\\ 998244353$ 意义下进行。", "inputFormat": "第一行 **两个** 整数 $n,type$，若 $type=0$ 代表求 $\\sin$，若 $type=1$ 代表求 $\\cos$；\n\n第二行 $n$ 个整数，依次表示多项式的系数 $a_0,a_1,\\cdots,a_{n-1}$。\n\n保证 $a_0=0$。", "outputFormat": "输出一行 $n$ 个整数，表示答案多项式中的系数 $f_0,f_1,\\cdots,f_{n-1}$。", "hint": "对于 $100\\%$ 的数据：$n\\leq10^5$，$a_i\\in[0,998244352]\\cap\\mathbb{Z}$。\n\n前 $5$ 个点 $type=0$，后 $5$ 个点 $type=1$。", "locale": "zh-CN", "translations": {"en": {"title": "Polynomial Trigonometric Functions", "background": "", "description": "Given a polynomial $A(x)$ of degree $n-1$, find a polynomial $F(x)$ modulo $x^n$ such that $F(x)\\equiv\\sin{A(x)}$ or $F(x)\\equiv\\cos{A(x)}$.\n\nAll operations are performed modulo $998244353$.", "inputFormat": "The first line contains **two** integers $n,type$. If $type=0$, compute $\\sin$; if $type=1$, compute $\\cos$.\n\nThe second line contains $n$ integers, which are the coefficients $a_0,a_1,\\cdots,a_{n-1}$ of the polynomial.\n\nIt is guaranteed that $a_0=0$.", "outputFormat": "Output one line with $n$ integers, representing the coefficients $f_0,f_1,\\cdots,f_{n-1}$ of the resulting polynomial.", "hint": "Constraints for $100\\%$ of the testdata: $n\\leq10^5$, $a_i\\in[0,998244352]\\cap\\mathbb{Z}$.\n\nFor the first $5$ test points, $type=0$; for the last $5$ test points, $type=1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "多项式三角函数", "background": "", "description": "给定一个 $n-1$ 次多项式 $A(x)$，求一个 $\\bmod{\\:x^n}$ 下的多项式 $F(x)$，满足 $F(x)\\equiv\\sin{A(x)}$ 或 $F(x)\\equiv\\cos{A(x)}$。\n\n所有运算在 $\\bmod\\ 998244353$ 意义下进行。", "inputFormat": "第一行 **两个** 整数 $n,type$，若 $type=0$ 代表求 $\\sin$，若 $type=1$ 代表求 $\\cos$；\n\n第二行 $n$ 个整数，依次表示多项式的系数 $a_0,a_1,\\cdots,a_{n-1}$。\n\n保证 $a_0=0$。", "outputFormat": "输出一行 $n$ 个整数，表示答案多项式中的系数 $f_0,f_1,\\cdots,f_{n-1}$。", "hint": "对于 $100\\%$ 的数据：$n\\leq10^5$，$a_i\\in[0,998244352]\\cap\\mathbb{Z}$。\n\n前 $5$ 个点 $type=0$，后 $5$ 个点 $type=1$。", "locale": "zh-CN"}}}
{"pid": "P5265", "type": "P", "difficulty": 7, "samples": [["8 0\n0 4 2 6 1 5 3 7", "0 4 2 665496252 17 399297879 332748370 570426983"], ["8 1\n0 4 2 6 1 5 3 7", "0 4 2 665496220 998244322 399297839 332748518 570424795"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["倍增", "O2优化", "构造", "快速数论变换 NTT"], "title": "多项式反三角函数", "background": "", "description": "给定一个 $n-1$ 次多项式 $A(x)$，求一个 $\\bmod{\\:x^n}$ 下的多项式 $F(x)$，满足 $F(x)\\equiv\\text{asin}\\:A(x)$ 或 $F(x)\\equiv\\text{atan}\\:A(x)$。\n\n所有运算在 $\\bmod\\ 998244353$ 意义下进行。", "inputFormat": "第一行 **两个** 整数 $n,type$，若 $type=0$ 代表求 $\\text{asin}$，若 $type=1$ 代表求 $\\text{atan}$；\n\n第二行 $n$ 个整数，依次表示多项式的系数 $a_0,a_1,\\cdots,a_{n-1}$。\n\n保证 $a_0=0$。", "outputFormat": "输出一行 $n$ 个整数，表示答案多项式中的系数 $f_0,f_1,\\cdots,f_{n-1}$。", "hint": "对于 $100\\%$ 的数据：$n\\leq10^5$，$a_i\\in[0,998244352]\\cap\\mathbb{Z}$。\n\n前 $5$ 个点 $type=0$，后 $5$ 个点 $type=1$。", "locale": "zh-CN", "translations": {"en": {"title": "Polynomial Inverse Trigonometric Functions", "background": "", "description": "Given an $(n - 1)$-degree polynomial $A(x)$, find a polynomial $F(x)$ modulo $x^n$ such that $F(x)\\equiv\\text{asin}\\:A(x)$ or $F(x)\\equiv\\text{atan}\\:A(x)$.\n\nAll operations are performed modulo $998244353$.", "inputFormat": "The first line contains **two** integers $n,type$. If $type=0$, compute $\\text{asin}$; if $type=1$, compute $\\text{atan}$.\n\nThe second line contains $n$ integers, representing the coefficients $a_0,a_1,\\cdots,a_{n-1}$ of the polynomial in order.\n\nIt is guaranteed that $a_0=0$.", "outputFormat": "Output one line with $n$ integers, representing the coefficients $f_0,f_1,\\cdots,f_{n-1}$ of the answer polynomial.", "hint": "For $100\\%$ of the testdata: $n\\leq10^5$, $a_i\\in[0,998244352]\\cap\\mathbb{Z}$.\n\nFor the first $5$ points, $type=0$; for the last $5$ points, $type=1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "多项式反三角函数", "background": "", "description": "给定一个 $n-1$ 次多项式 $A(x)$，求一个 $\\bmod{\\:x^n}$ 下的多项式 $F(x)$，满足 $F(x)\\equiv\\text{asin}\\:A(x)$ 或 $F(x)\\equiv\\text{atan}\\:A(x)$。\n\n所有运算在 $\\bmod\\ 998244353$ 意义下进行。", "inputFormat": "第一行 **两个** 整数 $n,type$，若 $type=0$ 代表求 $\\text{asin}$，若 $type=1$ 代表求 $\\text{atan}$；\n\n第二行 $n$ 个整数，依次表示多项式的系数 $a_0,a_1,\\cdots,a_{n-1}$。\n\n保证 $a_0=0$。", "outputFormat": "输出一行 $n$ 个整数，表示答案多项式中的系数 $f_0,f_1,\\cdots,f_{n-1}$。", "hint": "对于 $100\\%$ 的数据：$n\\leq10^5$，$a_i\\in[0,998244352]\\cap\\mathbb{Z}$。\n\n前 $5$ 个点 $type=0$，后 $5$ 个点 $type=1$。", "locale": "zh-CN"}}}
