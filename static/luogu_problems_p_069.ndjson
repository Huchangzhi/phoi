{"pid": "P2396", "type": "P", "difficulty": 5, "samples": [["8\n1 3 1 5 2 2 2 3\n0", "40320"], ["24\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n2\n10 15\n", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [228000, 228000, 228000, 228000, 228000, 228000, 228000, 228000, 228000, 228000]}, "tags": ["2015", "洛谷原创", "剪枝", "栈", "洛谷月赛", "状压 DP"], "title": "yyy loves Maths VII", "background": "yyy 对某些数字有着情有独钟的喜爱，他叫他们为“幸运数字”；然而他作死太多，所以把自己讨厌的数字称为“厄运数字”。", "description": "一群同学在和 yyy 玩一个游戏。\n\n每次,他们会给 yyy $n$ 张卡片，卡片上有数字，所有的数字都是“幸运数字”，我们认为第 $i$ 张卡片上数字是 $a_{i}$。\n\n每次 yyy 可以选择向前走 $a_{i}$ 步并且丢掉第 $i$ 张卡片。当他手上没有卡片的时候他就赢了。\n\n但是呢，大家对“厄运数字”的位置布置下了陷阱，如果 yyy 停在这个格子上，那么他就输了。注意：**即使到了终点，但是这个位置是厄运数字，那么也输了。**\n\n现在，有些同学开始问：yyy 有多大的概率会赢呢？\n\n大家觉得这是个好问题，有人立即让 yyy 写个程序：“电脑运行速度很快！$24$ 的阶乘也不过就 $620\\,448\\,401\\,733\\,239\\,439\\,360\\,000$，yyy 你快写个程序来算一算。”\n\nyyy 表示很无语，他表示他不想算概率，最多算算赢的方案数，而且是对 $10^9+7$ 取模后的值。\n\n大家都不会写程序，只好妥协。\n\n但是这时候 yyy 为难了，$24!$ 太大了，要跑好长时间。\n\n他时间严重不够！需要你的帮助！\n\n某个数字可能既属于幸运数字又属于厄运数字。", "inputFormat": "第一行一个整数 $n$。 \n\n下面一行 $n$ 个整数，第 $i$ 个整数代表第 $i$ 张卡片上的数字 $a_i$。\n\n第三行 $m$ 表示 yyy 的厄运数字个数（最多 $2$ 个）。\n\n若 $m>0$，第四行 $m$ 个数 $b_i$ 代表所有的厄运数字。", "outputFormat": "输出胜利方案数对 $10^9+7$ 取模的结果。", "hint": "- $10\\%$ 的数据 $n \\leq 10$；\n- $50\\%$ 的数据 $n \\leq 23$；\n- $100\\%$ 的数据 $n \\leq 24$，$0\\le m\\le 2$，$1\\le a_i,b_i\\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "yyy loves Maths VII", "background": "yyy has a special affection for certain numbers, which he calls \"lucky numbers\"; however, because he has tempted fate too many times, he calls the numbers he dislikes \"unlucky numbers\".", "description": "A group of classmates are playing a game with yyy.\n\nEach time, they give yyy $n$ cards with numbers on them. All the numbers are \"lucky numbers\". Let the number on the $i$-th card be $a_i$.\n\nOn each move, yyy may choose to move forward $a_i$ steps and discard the $i$-th card. He wins when he has no cards left.\n\nHowever, traps are set on positions that are \"unlucky numbers\". If yyy stops on such a cell, he loses. Note: even if he reaches the end, if that position is an unlucky number, he still loses.\n\nNow, some classmates begin to ask: what is the probability that yyy will win?\n\nThey think this is a good question, and someone immediately asks yyy to write a program: \"Computers are very fast! $24$ factorial is only $620\\,448\\,401\\,733\\,239\\,439\\,360\\,000$, yyy, hurry up and write a program to compute it.\"\n\nyyy is speechless. He says he does not want to compute the probability—at most he can compute the number of winning plans, and only modulo $10^9+7$.\n\nNone of them can code, so they have to compromise.\n\nBut now yyy is troubled: $24!$ is too large; it would take a long time to run.\n\nHe is seriously short on time and needs your help!\n\nA number may belong to both the lucky numbers and the unlucky numbers.", "inputFormat": "The first line contains an integer $n$.\n\nThe second line contains $n$ integers; the $i$-th integer is $a_i$, the number on the $i$-th card.\n\nThe third line contains an integer $m$ denoting the number of yyy's unlucky numbers (at most $2$).\n\nIf $m>0$, the fourth line contains $m$ integers $b_i$ representing all the unlucky numbers.", "outputFormat": "Output the number of winning plans modulo $10^9+7$.", "hint": "Constraints:\n- For $10\\%$ of the testdata, $n \\leq 10$.\n- For $50\\%$ of the testdata, $n \\leq 23$.\n- For $100\\%$ of the testdata, $n \\leq 24$, $0 \\le m \\le 2$, $1 \\le a_i, b_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "yyy loves Maths VII", "background": "yyy 对某些数字有着情有独钟的喜爱，他叫他们为“幸运数字”；然而他作死太多，所以把自己讨厌的数字称为“厄运数字”。", "description": "一群同学在和 yyy 玩一个游戏。\n\n每次,他们会给 yyy $n$ 张卡片，卡片上有数字，所有的数字都是“幸运数字”，我们认为第 $i$ 张卡片上数字是 $a_{i}$。\n\n每次 yyy 可以选择向前走 $a_{i}$ 步并且丢掉第 $i$ 张卡片。当他手上没有卡片的时候他就赢了。\n\n但是呢，大家对“厄运数字”的位置布置下了陷阱，如果 yyy 停在这个格子上，那么他就输了。注意：**即使到了终点，但是这个位置是厄运数字，那么也输了。**\n\n现在，有些同学开始问：yyy 有多大的概率会赢呢？\n\n大家觉得这是个好问题，有人立即让 yyy 写个程序：“电脑运行速度很快！$24$ 的阶乘也不过就 $620\\,448\\,401\\,733\\,239\\,439\\,360\\,000$，yyy 你快写个程序来算一算。”\n\nyyy 表示很无语，他表示他不想算概率，最多算算赢的方案数，而且是对 $10^9+7$ 取模后的值。\n\n大家都不会写程序，只好妥协。\n\n但是这时候 yyy 为难了，$24!$ 太大了，要跑好长时间。\n\n他时间严重不够！需要你的帮助！\n\n某个数字可能既属于幸运数字又属于厄运数字。", "inputFormat": "第一行一个整数 $n$。 \n\n下面一行 $n$ 个整数，第 $i$ 个整数代表第 $i$ 张卡片上的数字 $a_i$。\n\n第三行 $m$ 表示 yyy 的厄运数字个数（最多 $2$ 个）。\n\n若 $m>0$，第四行 $m$ 个数 $b_i$ 代表所有的厄运数字。", "outputFormat": "输出胜利方案数对 $10^9+7$ 取模的结果。", "hint": "- $10\\%$ 的数据 $n \\leq 10$；\n- $50\\%$ 的数据 $n \\leq 23$；\n- $100\\%$ 的数据 $n \\leq 24$，$0\\le m\\le 2$，$1\\le a_i,b_i\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P2397", "type": "P", "difficulty": 2, "samples": [["5\n2 3 3 3 3", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [5120, 5120, 5120, 5120, 5120, 5120, 5120, 5120, 5120]}, "tags": ["模拟", "2015", "洛谷原创", "洛谷月赛"], "title": "yyy loves Maths VI (mode) / 摩尔投票", "background": "自从上次 redbag 用加法好好的刁难过了 yyy 同学以后，yyy 十分愤怒。  \n他还击给了 redbag 一题，但是这题他惊讶的发现自己居然也不会，所以只好找你\n", "description": "一共有 $n$ 个正整数 $a_i$，他让 redbag 找众数。他还特意表示，这个众数出现次数超过了一半。  \n", "inputFormat": "第一行一个整数 $n$，表示数的个数。   \n第二行 $n$ 个正整数 $a_i$。\n", "outputFormat": "一行一个整数，表示众数。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 2\\times 10^6$，$a_i \\in [1,2^{31})$。\n\n有人想水过,但我告诉你这空间是不够的。\n\n//kkksc03偷偷地说：你随便输出一个数字吧，都有1/2的几率。不过这可是乐多赛，值得不值得你看着办。所以最好想一想正解。\n", "locale": "zh-CN", "translations": {"en": {"title": "yyy Loves Math VI (mode) / Moore Voting", "background": "Since last time redbag used addition to give yyy a hard time, yyy was furious. He struck back by giving redbag a problem, but to his surprise he could not solve it himself, so he turned to you.", "description": "There are $n$ positive integers $a_i$. He asks redbag to find the mode. He also specifically states that this mode occurs more than half of the $n$ elements.", "inputFormat": "The first line contains an integer $n$, the number of values.  \nThe second line contains $n$ positive integers $a_i$.", "outputFormat": "Output one line with a single integer, the mode.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le n \\le 2 \\times 10^6$, $a_i \\in [1, 2^{31})$.\n\nSome may want to take the easy way out, but the memory is not enough.\n\n//kkksc03 whispers: Just output any number; you have a 1/2 chance. But this is \"Le Duo Sai\", whether it is worth it is up to you. So you had better think about the proper solution.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "yyy loves Maths VI (mode) / 摩尔投票", "background": "自从上次 redbag 用加法好好的刁难过了 yyy 同学以后，yyy 十分愤怒。  \n他还击给了 redbag 一题，但是这题他惊讶的发现自己居然也不会，所以只好找你\n", "description": "一共有 $n$ 个正整数 $a_i$，他让 redbag 找众数。他还特意表示，这个众数出现次数超过了一半。  \n", "inputFormat": "第一行一个整数 $n$，表示数的个数。   \n第二行 $n$ 个正整数 $a_i$。\n", "outputFormat": "一行一个整数，表示众数。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 2\\times 10^6$，$a_i \\in [1,2^{31})$。\n\n有人想水过,但我告诉你这空间是不够的。\n\n//kkksc03偷偷地说：你随便输出一个数字吧，都有1/2的几率。不过这可是乐多赛，值得不值得你看着办。所以最好想一想正解。\n", "locale": "zh-CN"}}}
{"pid": "P2398", "type": "P", "difficulty": 4, "samples": [["2", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "洛谷原创", "素数判断,质数,筛法", "莫比乌斯反演", "容斥原理", "洛谷月赛", "欧拉函数"], "title": "GCD SUM", "background": "", "description": "求\n\n$$\\sum_{i=1}^n \\sum_{j=1}^n \\gcd(i, j)$$", "inputFormat": "第一行一个整数 $n$。", "outputFormat": "第一行一个整数表示答案。", "hint": "对于 $30\\%$ 的数据，$n\\leq 3000$。\n\n对于 $60\\%$ 的数据，$7000\\leq n\\leq 7100$。\n\n对于 $100\\%$ 的数据，$n\\leq 10^5$。\n", "locale": "zh-CN", "translations": {"en": {"title": "GCD SUM", "background": "", "description": "Compute\n$$\\sum_{i=1}^n \\sum_{j=1}^n \\gcd(i, j)$$.", "inputFormat": "The first line contains an integer $n$.", "outputFormat": "Output a single integer on the first line representing the answer.", "hint": "For 30% of the testdata, $n \\leq 3000$.\nFor 60% of the testdata, $7000 \\leq n \\leq 7100$.\nFor 100% of the testdata, $n \\leq 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "GCD SUM", "background": "", "description": "求\n\n$$\\sum_{i=1}^n \\sum_{j=1}^n \\gcd(i, j)$$", "inputFormat": "第一行一个整数 $n$。", "outputFormat": "第一行一个整数表示答案。", "hint": "对于 $30\\%$ 的数据，$n\\leq 3000$。\n\n对于 $60\\%$ 的数据，$7000\\leq n\\leq 7100$。\n\n对于 $100\\%$ 的数据，$n\\leq 10^5$。\n", "locale": "zh-CN"}}}
{"pid": "P2399", "type": "P", "difficulty": 4, "samples": [["1.32", "33/25"], ["1.(3)", "4/3"], ["1.0", "1/1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "数学", "洛谷原创"], "title": "non hates math", "background": "non 习惯将分数化成小数，但在数学中要以分数形式写，不能化成小数。\n\n因此 non 找到了会编程的你，帮助他将小数化回分数。", "description": "给出一个小数，将它化成最简分数的形式。\n\n小数的类型有2种：（不考虑无限不循环小数）\n\n1. 普通小数；\n2. 循环小数（会给出循环节，循环节用 `()` 表示）。", "inputFormat": "一个小数 $n$。", "outputFormat": "输出这个小数 $n$ 转化成最简分数的形式。", "hint": "输入小数的数据范围是 $0$ 至 $1000$，保证小数点后的字符数不超过 $9$。\n\n对于 $50\\%$ 的数据保证没有循环节。", "locale": "zh-CN", "translations": {"en": {"title": "non hates math", "background": "non is used to converting fractions into decimals, but in math they must write them as fractions and cannot convert them into decimals. Therefore, non turns to you, a programmer, to help convert decimals back to fractions.", "description": "Given a decimal, convert it into an improper fraction.\n\nThere are two types of decimals (we do not consider infinite non-repeating decimals):\n1. Terminating decimal;\n2. Repeating decimal (the repeating part is given and enclosed in `()`).", "inputFormat": "A decimal number $n$.", "outputFormat": "Output the reduced improper fraction form of the decimal $n$.", "hint": "The range of the input decimal is $0$ to $1000$, and the number of characters after the decimal point does not exceed $9$.  \nFor $50\\%$ of the testdata, there is no repeating part.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "non hates math", "background": "non 习惯将分数化成小数，但在数学中要以分数形式写，不能化成小数。\n\n因此 non 找到了会编程的你，帮助他将小数化回分数。", "description": "给出一个小数，将它化成最简分数的形式。\n\n小数的类型有2种：（不考虑无限不循环小数）\n\n1. 普通小数；\n2. 循环小数（会给出循环节，循环节用 `()` 表示）。", "inputFormat": "一个小数 $n$。", "outputFormat": "输出这个小数 $n$ 转化成最简分数的形式。", "hint": "输入小数的数据范围是 $0$ 至 $1000$，保证小数点后的字符数不超过 $9$。\n\n对于 $50\\%$ 的数据保证没有循环节。", "locale": "zh-CN"}}}
{"pid": "P2400", "type": "P", "difficulty": 4, "samples": [["AAAAAAAAAABABABCCD", "9(A)3(AB)CCD"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "福建省历届夏令营"], "title": "秘密文件", "background": null, "description": "某天，情报局得到了一份秘密文件。文件的内容是加密后的全部由大写字母组成字符串。情报局局长小明想将其发送给远在东方神秘的 xx 大陆上的老朋友小刘来解密。然而若字符串太长，则需要很长的发送时间，太不安全了，因此小明想尽量将其缩短。于是小明制定了这样一个缩短规则：若一个字符串 $t$ 连续出现 $k$ 次，则可以用 $k(t)$ 进行说明。如 `ABABAB` 可以缩成 `3(AB)`。当然，重复缩短是允许的，如 `ABABABAAAAAAABABABAAAAAA` 可以缩成 `2(3(AB)6(A))`。\n\n现在，小明想知道，对于给定的字符串，最短可以缩成什么样子。\n\n**注意：有多个最优方案时，输出其中字典序最大的。( thanks to @Dilute. )**", "inputFormat": "输入仅一行，为给定的字符串。", "outputFormat": "输出仅一行，为经过缩短操作后的字符串。", "hint": "【数据范围】\n\n对于 $100\\%$ 的数据，字符串的长度 $L \\le 100$。数据存在一定梯度。", "locale": "zh-CN", "translations": {"en": {"title": "Secret File", "background": "", "description": "One day, the intelligence agency obtained a secret file. Its content is an encrypted string consisting entirely of uppercase letters. The director, Xiaoming, wants to send it to his old friend Xiaoliu on the mysterious \"xx\" continent in the Far East for decryption. However, if the string is too long, transmission takes too much time and is unsafe, so Xiaoming wants to shorten it as much as possible.\n\nHe sets the following shortening rule: If a string t appears consecutively k times, it can be represented as k(t). For example, ABABAB can be shortened to 3(AB). Repeated (nested) shortening is allowed. For example, ABABABAAAAAAABABABAAAAAA can be shortened to 2(3(AB)6(A)).\n\nNow, given the string, determine the shortest possible result after applying the shortening rule.\n\nNote: If there are multiple optimal answers, output the lexicographically largest one (thanks to @Dilute.).", "inputFormat": "A single line containing the given string. The string consists only of uppercase letters.", "outputFormat": "A single line containing the string after shortening.", "hint": "Constraints.\n\n- For 100% of the testdata, the string length $L \\le 100$.\n- The testdata has certain gradation.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "秘密文件", "background": null, "description": "某天，情报局得到了一份秘密文件。文件的内容是加密后的全部由大写字母组成字符串。情报局局长小明想将其发送给远在东方神秘的 xx 大陆上的老朋友小刘来解密。然而若字符串太长，则需要很长的发送时间，太不安全了，因此小明想尽量将其缩短。于是小明制定了这样一个缩短规则：若一个字符串 $t$ 连续出现 $k$ 次，则可以用 $k(t)$ 进行说明。如 `ABABAB` 可以缩成 `3(AB)`。当然，重复缩短是允许的，如 `ABABABAAAAAAABABABAAAAAA` 可以缩成 `2(3(AB)6(A))`。\n\n现在，小明想知道，对于给定的字符串，最短可以缩成什么样子。\n\n**注意：有多个最优方案时，输出其中字典序最大的。( thanks to @Dilute. )**", "inputFormat": "输入仅一行，为给定的字符串。", "outputFormat": "输出仅一行，为经过缩短操作后的字符串。", "hint": "【数据范围】\n\n对于 $100\\%$ 的数据，字符串的长度 $L \\le 100$。数据存在一定梯度。", "locale": "zh-CN"}}}
{"pid": "P2401", "type": "P", "difficulty": 4, "samples": [["5 2", "66"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "福建省历届夏令营"], "title": "不等数列", "background": "", "description": "将 $1$ 到 $n$ 任意排列，然后在排列的每两个数之间根据他们的大小关系插入`>` 和 `<`。问在所有排列中，有多少个排列恰好有 $k$ 个 `<`。答案对 $2015$ 取模。\n\n注：$1 \\sim n$ 的排列指的是 $1 \\sim n$ 这 $n$ 个数各出现且仅出现一次的数列。", "inputFormat": "一行两个整数，表示 $n$ 和 $k$。", "outputFormat": "一个整数表示答案。\n", "hint": "对于 $30\\%$ 的数据，$n\\leq 10$；\n\n对于 $100\\%$ 的数据，$0\\leq k<n\\leq 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "Inequality Sequence", "background": "", "description": "Take any permutation of $1$ to $n$, and then, between every two adjacent numbers in the permutation, insert `>` or `<` according to their relative value. Among all permutations, how many permutations have exactly $k$ symbols `<$`? The answer is taken modulo $2015$.\n\nNote: A permutation of $1 \\sim n$ refers to a sequence in which each of the $n$ numbers from $1 \\sim n$ appears exactly once.", "inputFormat": "A single line with two integers, representing $n$ and $k$.", "outputFormat": "A single integer representing the answer.", "hint": "For $30\\%$ of the testdata, $n \\leq 10$.\n\nFor $100\\%$ of the testdata, $0 \\leq k < n \\leq 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "不等数列", "background": "", "description": "将 $1$ 到 $n$ 任意排列，然后在排列的每两个数之间根据他们的大小关系插入`>` 和 `<`。问在所有排列中，有多少个排列恰好有 $k$ 个 `<`。答案对 $2015$ 取模。\n\n注：$1 \\sim n$ 的排列指的是 $1 \\sim n$ 这 $n$ 个数各出现且仅出现一次的数列。", "inputFormat": "一行两个整数，表示 $n$ 和 $k$。", "outputFormat": "一个整数表示答案。\n", "hint": "对于 $30\\%$ 的数据，$n\\leq 10$；\n\n对于 $100\\%$ 的数据，$0\\leq k<n\\leq 1000$。", "locale": "zh-CN"}}}
{"pid": "P2402", "type": "P", "difficulty": 5, "samples": [["3 4 \n7 2 \n0 4 \n2 6 \n1 2 40 \n3 2 70 \n2 3 90 \n1 3 120\n", "110"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["福建省历届夏令营", "网络流"], "title": "奶牛隐藏", "background": "这本是一个非常简单的问题，然而奶牛们由于下雨已经非常混乱，无法完成这一计算，于是这个任务就交给了你。(奶牛混乱的原因看题目描述)\n", "description": "在一个农场里有 $n$ 块田地。某天下午，有一群牛在田地里吃草，他们分散在农场的诸多田地上，农场由 $m$ 条无向的路连接，每条路有不同的长度。\n\n突然，天降大雨，奶牛们非常混乱，想要快点去躲雨。已知每个田地都建立有一个牛棚，但是每个牛棚只能容纳一定数量的牛躲雨，如果超过这个数量，那多出的牛只能去别的田地躲雨。奶牛们每移动 $1$ 的距离花费 $1$ 时间，奶牛们想知道它们全部都躲进牛棚，最少需要多少时间。(即最后一头奶牛最少要花多久才能躲进牛棚)。\n", "inputFormat": "第一行有两个整数，分别代表田地数 $n$ 和道路数 $m$。\n\n接下来 $n$ 行，每行两个整数，第 $(i + 1)$ 行的整数 $s_i, p_i$ 分别表示第 $i$ 块田地的牛的数量以及该田地的牛棚最多可以容纳多少牛。\n\n接下来 $m$ 行，每行三个整数 $u, v, w$，代表存在一条长度为 $w$ 的连接 $u$ 和 $v$ 的道路。\n", "outputFormat": "输出一行一个整数表示所有奶牛全都躲进牛棚所用的最少时间。如果无法使全部奶牛都躲进牛棚，输出 $-1$。\n", "hint": "#### 样例输入输出 1 解释\n\n$1$ 号点的两只牛直接躲进 $1$ 号牛棚，剩下的 $5$ 只中，$4$ 只跑去 $2$ 号点，还有一只沿 $1 \\to 2 \\to 3$ 躲进 $3$ 号点, $3$ 号点的 $2$ 只牛也直接躲进去，这样最慢的牛花费的时间是 $110$。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证：\n- $1 \\leq n \\leq 200$，$1 \\leq m \\leq 1500$。\n- $1 \\leq u, v \\leq n$，$1 \\leq w \\leq 10^{15}$，$1 \\leq s_i, p_i \\leq 10^{16}$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Cow Hiding", "background": "This was supposed to be a very simple problem. However, the cows got very confused because of the rain and cannot finish the calculation, so the task is handed to you. (For the reason the cows are confused, see the problem description.)", "description": "There are $n$ fields on a farm. One afternoon, a herd of cows is grazing in the fields. They are spread across many fields of the farm, which are connected by $m$ undirected roads, each with a different length.\n\nSuddenly, heavy rain falls. The cows are very confused and want to find shelter quickly. It is known that each field has a barn, but each barn can only hold a limited number of cows. If the number of cows exceeds this capacity, the extra cows must go to other fields to shelter. Moving a distance of $1$ costs time $1$. The cows want to know the minimum time needed for all of them to get into barns, i.e., the minimum time the last cow needs to get into a barn.", "inputFormat": "- The first line contains two integers, the number of fields $n$ and the number of roads $m$.\n- The next $n$ lines each contain two integers. On the $(i + 1)$-th line, the integers $s_i, p_i$ denote the number of cows in field $i$ and the maximum capacity of the barn at that field, respectively.\n- The next $m$ lines each contain three integers $u, v, w$, indicating there is an undirected road of length $w$ connecting $u$ and $v$.", "outputFormat": "Output a single integer, the minimum time required for all cows to get into barns. If it is impossible for all cows to find shelter, output $-1$.", "hint": "Sample Input/Output 1 Explanation:\n\nThe two cows at node $1$ go directly into barn $1$. Among the remaining $5$ cows, $4$ run to node $2$, and one goes along $1 \\to 2 \\to 3$ to get into barn $3$. The $2$ cows at node $3$ also go directly into its barn. In this arrangement, the slowest cow spends time $110$.\n\nConstraints:\n\nFor $100\\%$ of the data, it is guaranteed that:\n- $1 \\leq n \\leq 200$, $1 \\leq m \\leq 1500$.\n- $1 \\leq u, v \\leq n$, $1 \\leq w \\leq 10^{15}$, $1 \\leq s_i, p_i \\leq 10^{16}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "奶牛隐藏", "background": "这本是一个非常简单的问题，然而奶牛们由于下雨已经非常混乱，无法完成这一计算，于是这个任务就交给了你。(奶牛混乱的原因看题目描述)\n", "description": "在一个农场里有 $n$ 块田地。某天下午，有一群牛在田地里吃草，他们分散在农场的诸多田地上，农场由 $m$ 条无向的路连接，每条路有不同的长度。\n\n突然，天降大雨，奶牛们非常混乱，想要快点去躲雨。已知每个田地都建立有一个牛棚，但是每个牛棚只能容纳一定数量的牛躲雨，如果超过这个数量，那多出的牛只能去别的田地躲雨。奶牛们每移动 $1$ 的距离花费 $1$ 时间，奶牛们想知道它们全部都躲进牛棚，最少需要多少时间。(即最后一头奶牛最少要花多久才能躲进牛棚)。\n", "inputFormat": "第一行有两个整数，分别代表田地数 $n$ 和道路数 $m$。\n\n接下来 $n$ 行，每行两个整数，第 $(i + 1)$ 行的整数 $s_i, p_i$ 分别表示第 $i$ 块田地的牛的数量以及该田地的牛棚最多可以容纳多少牛。\n\n接下来 $m$ 行，每行三个整数 $u, v, w$，代表存在一条长度为 $w$ 的连接 $u$ 和 $v$ 的道路。\n", "outputFormat": "输出一行一个整数表示所有奶牛全都躲进牛棚所用的最少时间。如果无法使全部奶牛都躲进牛棚，输出 $-1$。\n", "hint": "#### 样例输入输出 1 解释\n\n$1$ 号点的两只牛直接躲进 $1$ 号牛棚，剩下的 $5$ 只中，$4$ 只跑去 $2$ 号点，还有一只沿 $1 \\to 2 \\to 3$ 躲进 $3$ 号点, $3$ 号点的 $2$ 只牛也直接躲进去，这样最慢的牛花费的时间是 $110$。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证：\n- $1 \\leq n \\leq 200$，$1 \\leq m \\leq 1500$。\n- $1 \\leq u, v \\leq n$，$1 \\leq w \\leq 10^{15}$，$1 \\leq s_i, p_i \\leq 10^{16}$。\n", "locale": "zh-CN"}}}
{"pid": "P2403", "type": "P", "difficulty": 5, "samples": [["10 7 7\n2 2 1\n2 4 2\n1 7 2\n2 7 3\n4 2 2\n4 4 1\n6 7 3\n7 7 1\n7 5 2\n5 2 1", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2010", "各省省选", "山东", "拓扑排序", "强连通分量", "Tarjan"], "title": "[SDOI2010] 所驼门王的宝藏", "background": "", "description": "在宽广的非洲荒漠中，生活着一群勤劳勇敢的羊驼家族。被族人恭称为“先知”的 AlpacaL.Sotomon 是这个家族的领袖，外人也称其为“所驼门王”。所驼门王毕生致力于维护家族的安定与和谐，他曾亲自率军粉碎河蟹帝国主义的野蛮侵略，为族人立下赫赫战功。所驼门王一生财宝无数，但因其生性节俭低调，他将财宝埋藏在自己设计的地下宫殿里，这也是今天 Henry Curtis 故事的起点。Henry 是一个爱财如命的贪婪家伙，而又非常聪明，他费尽心机谋划了这次盗窃行动，破解重重机关后来到这座地下宫殿前。\n\n整座宫殿呈矩阵状，由 $R \\times C$ 间矩形宫室组成，其中有 $N$ 间宫室里埋藏着宝藏，称作藏宝宫室。宫殿里外、相邻宫室间都由坚硬的实体墙阻隔，由一间宫室到达另一间只能通过所驼门王独创的移动方式——传送门。所驼门王为这 $N$ 间藏宝宫室每间都架设了一扇传送门，没有宝藏的宫室不设传送门，所有的宫室传送门分为三种：\n\n1. “横天门”：由该门可以传送到同行的任一宫室；\n2. “纵寰门”：由该门可以传送到同列的任一宫室；\n3. “任意门”：由该门可以传送到以该门所在宫室为中心周围 $8$ 格中任一宫室（如果目标宫室存在的话）。\n\n深谋远虑的 Henry 当然事先就搞到了所驼门王当年的宫殿招标册，书册上详细记录了每扇传送门所属宫室及类型。而且，虽然宫殿内外相隔，但他自行准备了一种便携式传送门，可将自己传送到殿内任意一间宫室开始寻宝，并在任意一间宫室结束后传送出宫。整座宫殿只许进出一次，且便携门无法进行宫室之间的传送。不过好在宫室内传送门的使用没有次数限制，每间宫室也可以多次出入。\n\n现在 Henry 已经打开了便携门，即将选择一间宫室进入。为得到尽多宝藏，他希望安排一条路线，使走过的不同藏宝宫室尽可能多。请你告诉 Henry 这条路线最多行经不同藏宝宫室的数目。", "inputFormat": "第一行给出三个正整数 $N,R,C$。\n\n以下 $N$ 行，每行给出一扇传送门的信息，包含三个正整数 $x_i,y_i,T_i$，表示该传送门设在位于第 $x_i$ 行第 $y_i$ 列的藏宝宫室，类型为 $T_i$。$T_i$ 是一个 $1 \\sim 3$ 间的整数，$1$ 表示可以传送到第 $x_i$ 行任意一列的“横天门”，$2$ 表示可以传送到任意一行第 $y_i$ 列的“纵寰门”，$3$ 表示可以传送到周围 $8$ 格宫室的“任意门”。\n\n保证 $1 \\le x_i \\le R$，$1 \\le y_i \\le C$，所有的传送门位置互不相同。", "outputFormat": "输出只有一个正整数，表示你确定的路线所经过不同藏宝宫室的最大数目。\n", "hint": "数据规模和约定：\n\n![](https://cdn.luogu.com.cn/upload/pic/1594.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2010] The Treasure of the King of Sotomon", "background": "", "description": "In the vast African desert lives a hardworking and brave alpaca clan. AlpacaL.Sotomon, respectfully called the “Prophet” by his people, is the leader of the clan and is known to outsiders as the “King of Sotomon.” He devoted his life to maintaining the clan’s peace and harmony, and once personally led his army to crush the savage invasion of the River Crab imperialists, earning great merit. The King of Sotomon amassed countless treasures in his lifetime, but being frugal and low-key by nature, he buried them in an underground palace of his own design. This is where the story of Henry Curtis begins. Henry is a greedy yet shrewd man who meticulously planned this heist and, after overcoming numerous traps, arrived at the entrance of the underground palace.\n\nThe palace is arranged in a matrix of $R \\times C$ rectangular chambers. Treasures are buried in $N$ of these chambers, which are called treasure chambers. The palace is enclosed by solid walls, and adjacent chambers are separated by walls as well. One can move from one chamber to another only through a unique transportation method invented by the King of Sotomon: teleportation gates. Each of the $N$ treasure chambers is equipped with exactly one teleportation gate; chambers without treasures have no gates. All gates fall into one of three types:\n\n1. “Horizontal Gate”: from this gate, one can teleport to any chamber in the same row.\n2. “Vertical Gate”: from this gate, one can teleport to any chamber in the same column.\n3. “Any Gate”: from this gate, one can teleport to any of the 8 neighboring chambers around the current chamber (if the target chamber exists).\n\nBeing far-sighted, Henry had already obtained the palace’s original construction tender book, which records in detail the location and type of every teleportation gate. Although the palace is sealed from the outside, Henry has prepared a portable gate that can teleport him into any chamber to start his search and can teleport him out from any chamber after he finishes. He may enter the palace once and exit once in total, and the portable gate cannot be used to move between chambers. Fortunately, in-palace teleportation gates can be used without limit, and any chamber may be entered and left multiple times.\n\nNow that Henry has opened his portable gate and is about to choose a chamber to enter, he wants to plan a route that visits as many distinct treasure chambers as possible. Please tell Henry the maximum number of distinct treasure chambers that such a route can visit.", "inputFormat": "The first line contains three positive integers $N, R, C$.\n\nEach of the following $N$ lines describes a teleportation gate with three positive integers $x_i, y_i, T_i$, meaning there is a gate in the treasure chamber at row $x_i$, column $y_i$, and its type is $T_i$. $T_i$ is an integer between $1$ and $3$: $1$ means a “Horizontal Gate” that can teleport to any column in row $x_i$, $2$ means a “Vertical Gate” that can teleport to any row in column $y_i$, and $3$ means an “Any Gate” that can teleport to any of the 8 neighboring chambers.\n\nIt is guaranteed that $1 \\le x_i \\le R$, $1 \\le y_i \\le C$, and all gate positions are distinct.", "outputFormat": "Output a single positive integer: the maximum number of distinct treasure chambers that your determined route can visit.", "hint": "Constraints and Conventions:\n\n![](https://cdn.luogu.com.cn/upload/pic/1594.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2010] 所驼门王的宝藏", "background": "", "description": "在宽广的非洲荒漠中，生活着一群勤劳勇敢的羊驼家族。被族人恭称为“先知”的 AlpacaL.Sotomon 是这个家族的领袖，外人也称其为“所驼门王”。所驼门王毕生致力于维护家族的安定与和谐，他曾亲自率军粉碎河蟹帝国主义的野蛮侵略，为族人立下赫赫战功。所驼门王一生财宝无数，但因其生性节俭低调，他将财宝埋藏在自己设计的地下宫殿里，这也是今天 Henry Curtis 故事的起点。Henry 是一个爱财如命的贪婪家伙，而又非常聪明，他费尽心机谋划了这次盗窃行动，破解重重机关后来到这座地下宫殿前。\n\n整座宫殿呈矩阵状，由 $R \\times C$ 间矩形宫室组成，其中有 $N$ 间宫室里埋藏着宝藏，称作藏宝宫室。宫殿里外、相邻宫室间都由坚硬的实体墙阻隔，由一间宫室到达另一间只能通过所驼门王独创的移动方式——传送门。所驼门王为这 $N$ 间藏宝宫室每间都架设了一扇传送门，没有宝藏的宫室不设传送门，所有的宫室传送门分为三种：\n\n1. “横天门”：由该门可以传送到同行的任一宫室；\n2. “纵寰门”：由该门可以传送到同列的任一宫室；\n3. “任意门”：由该门可以传送到以该门所在宫室为中心周围 $8$ 格中任一宫室（如果目标宫室存在的话）。\n\n深谋远虑的 Henry 当然事先就搞到了所驼门王当年的宫殿招标册，书册上详细记录了每扇传送门所属宫室及类型。而且，虽然宫殿内外相隔，但他自行准备了一种便携式传送门，可将自己传送到殿内任意一间宫室开始寻宝，并在任意一间宫室结束后传送出宫。整座宫殿只许进出一次，且便携门无法进行宫室之间的传送。不过好在宫室内传送门的使用没有次数限制，每间宫室也可以多次出入。\n\n现在 Henry 已经打开了便携门，即将选择一间宫室进入。为得到尽多宝藏，他希望安排一条路线，使走过的不同藏宝宫室尽可能多。请你告诉 Henry 这条路线最多行经不同藏宝宫室的数目。", "inputFormat": "第一行给出三个正整数 $N,R,C$。\n\n以下 $N$ 行，每行给出一扇传送门的信息，包含三个正整数 $x_i,y_i,T_i$，表示该传送门设在位于第 $x_i$ 行第 $y_i$ 列的藏宝宫室，类型为 $T_i$。$T_i$ 是一个 $1 \\sim 3$ 间的整数，$1$ 表示可以传送到第 $x_i$ 行任意一列的“横天门”，$2$ 表示可以传送到任意一行第 $y_i$ 列的“纵寰门”，$3$ 表示可以传送到周围 $8$ 格宫室的“任意门”。\n\n保证 $1 \\le x_i \\le R$，$1 \\le y_i \\le C$，所有的传送门位置互不相同。", "outputFormat": "输出只有一个正整数，表示你确定的路线所经过不同藏宝宫室的最大数目。\n", "hint": "数据规模和约定：\n\n![](https://cdn.luogu.com.cn/upload/pic/1594.png)\n", "locale": "zh-CN"}}}
{"pid": "P2404", "type": "P", "difficulty": 2, "samples": [["7\n", "1+1+1+1+1+1+1\n1+1+1+1+1+2\n1+1+1+1+3\n1+1+1+2+2\n1+1+1+4\n1+1+2+3\n1+1+5\n1+2+2+2\n1+2+4\n1+3+3\n1+6\n2+2+3\n2+5\n3+4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索"], "title": "自然数的拆分问题", "background": "", "description": "任何一个大于 $1$ 的自然数 $n$，总可以拆分成若干个小于 $n$ 的自然数之和。现在给你一个自然数 $n$，要求你求出 $n$ 的拆分成一些数字的和。每个拆分后的序列中的数字从小到大排序。然后你需要输出这些序列，其中字典序小的序列需要优先输出。\n", "inputFormat": "输入：待拆分的自然数 $n$。\n", "outputFormat": "输出：若干数的加法式子。\n", "hint": "数据保证，$2\\leq n\\le 8$。", "locale": "zh-CN", "translations": {"en": {"title": "Decomposition of a Natural Number", "background": "", "description": "Any natural number $n$ greater than $1$ can be decomposed into a sum of several natural numbers that are each less than $n$. Given a natural number $n$, list all decompositions of $n$ into a sum of natural numbers, where every addend is less than $n$. In each decomposition, the numbers must be written in nondecreasing order. Then output these sequences in lexicographic order, with lexicographically smaller sequences printed first.", "inputFormat": "Input: a single natural number $n$.", "outputFormat": "Output: several addition expressions. Print one decomposition per line as $a_1+a_2+\\dots+a_k$, where each $a_i$ is a natural number less than $n$, the sequence is in nondecreasing order, and the lines are sorted in lexicographic order.", "hint": "Constraints: $2 \\leq n \\le 8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "自然数的拆分问题", "background": "", "description": "任何一个大于 $1$ 的自然数 $n$，总可以拆分成若干个小于 $n$ 的自然数之和。现在给你一个自然数 $n$，要求你求出 $n$ 的拆分成一些数字的和。每个拆分后的序列中的数字从小到大排序。然后你需要输出这些序列，其中字典序小的序列需要优先输出。\n", "inputFormat": "输入：待拆分的自然数 $n$。\n", "outputFormat": "输出：若干数的加法式子。\n", "hint": "数据保证，$2\\leq n\\le 8$。", "locale": "zh-CN"}}}
{"pid": "P2405", "type": "P", "difficulty": 6, "samples": [["99\r\n10\r\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "数学", "高精度", "2015", "线段树", "洛谷原创", "进制", "洛谷月赛"], "title": "non天平", "background": "non 最近正在为自己的体重而苦恼，他想称量自己的体重。于是，他找来一个天平与许多砝码。", "description": "砝码的重量均是 $n$ 的幂次，$n^1, n^2, n^3, n^4, n^5$ 的……non 想知道至少要多少个砝码才可以称出他的重量 $m$。注意砝码可以放左边，也可以放右边。", "inputFormat": "第一行一个正整数 $m$，表示 non 的重量；\n\n第二行一个正整数 $n$，表示砝码重量幂次的底。", "outputFormat": "一个整数表示最少所需的砝码数。\n", "hint": "### 数据范围及约定\n\n对于 $30\\%$ 的数据点，$m \\le 2^{63}-1$。\n\n对于 $100\\%$ 的数据点，$0 \\le m \\le 10^{10000}$，$0<n \\le 10000$。", "locale": "zh-CN", "translations": {"en": {"title": "non's Balance Scale", "background": "non has been worried about his weight recently, and he wants to weigh himself. So, he found a balance scale and many weights.", "description": "The weights each have masses that are powers of $n$: $n^1, n^2, n^3, n^4, n^5$, and so on. non wants to know the minimum number of weights needed to measure his weight $m$. Note that weights can be placed on either the left or the right pan.", "inputFormat": "The first line contains a non-negative integer $m$, representing non's weight.\n\nThe second line contains a positive integer $n$, representing the base of the powers for the weights.", "outputFormat": "Output a single integer representing the minimum number of weights required.", "hint": "### Constraints\n\nFor $30\\%$ of the testdata, $m \\le 2^{63} - 1$.\n\nFor $100\\%$ of the testdata, $0 \\le m \\le 10^{10000}$, $0 < n \\le 10000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "non天平", "background": "non 最近正在为自己的体重而苦恼，他想称量自己的体重。于是，他找来一个天平与许多砝码。", "description": "砝码的重量均是 $n$ 的幂次，$n^1, n^2, n^3, n^4, n^5$ 的……non 想知道至少要多少个砝码才可以称出他的重量 $m$。注意砝码可以放左边，也可以放右边。", "inputFormat": "第一行一个正整数 $m$，表示 non 的重量；\n\n第二行一个正整数 $n$，表示砝码重量幂次的底。", "outputFormat": "一个整数表示最少所需的砝码数。\n", "hint": "### 数据范围及约定\n\n对于 $30\\%$ 的数据点，$m \\le 2^{63}-1$。\n\n对于 $100\\%$ 的数据点，$0 \\le m \\le 10^{10000}$，$0<n \\le 10000$。", "locale": "zh-CN"}}}
{"pid": "P2406", "type": "P", "difficulty": 4, "samples": [["3 60", "12 15"], ["200 20000\n300 30000\n400 40000", "800 5000\n1200 7500\n1600 10000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学"], "title": "最小和", "background": "RSA 算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。所以今天只有短的 RSA 密钥才可能被强力方式破解。", "description": "已知 $a,b$ 是正整数且 $a \\leq b$。\n\n求满足条件且 $x+y$ 的值最小的 $x,y$。\n\n条件：\n\n- $\\gcd(x,y) = a$；\n- $\\mathrm{lcm}(x,y) = b$；\n- $x \\leq y$。", "inputFormat": "多组数据，EOF 判断结束。\n\n共有不超过 $10^3$ 行，每行两个数 $a,b$。", "outputFormat": "输出和输入文件行数相同，每行两个数 $x,y$，以一个半角空格隔开。", "hint": "$3 \\leq a, b < 2^{63}$。\n\nEOF 结束，没有代表行数的 $n$，第一行就是数据。\n\n数据随机生成。", "locale": "zh-CN", "translations": {"en": {"title": "Minimum Sum", "background": "The RSA algorithm is based on a very simple number-theoretic fact: multiplying two large primes is easy, but factoring their product is extremely difficult. Therefore, the product can be published as an encryption key. As a result, only short RSA keys can be cracked by brute force today.", "description": "Given that $a, b$ are positive integers with $a \\leq b$.\n\nFind $x, y$ that satisfy the conditions and minimize $x + y$.\n\nConditions:\n- $\\gcd(x, y) = a$;\n- $\\mathrm{lcm}(x, y) = b$;\n- $x \\leq y$.", "inputFormat": "Multiple test cases, terminated by EOF.\n\nThere are at most $10^3$ lines, each containing two numbers $a, b$.", "outputFormat": "Output the same number of lines as in the input. For each line, output two numbers $x, y$, separated by a single space.", "hint": "$3 \\leq a, b < 2^{63}$.\n\nTerminated by EOF; there is no line count $n$, and the first line is testdata.\n\nThe testdata are randomly generated.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最小和", "background": "RSA 算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。所以今天只有短的 RSA 密钥才可能被强力方式破解。", "description": "已知 $a,b$ 是正整数且 $a \\leq b$。\n\n求满足条件且 $x+y$ 的值最小的 $x,y$。\n\n条件：\n\n- $\\gcd(x,y) = a$；\n- $\\mathrm{lcm}(x,y) = b$；\n- $x \\leq y$。", "inputFormat": "多组数据，EOF 判断结束。\n\n共有不超过 $10^3$ 行，每行两个数 $a,b$。", "outputFormat": "输出和输入文件行数相同，每行两个数 $x,y$，以一个半角空格隔开。", "hint": "$3 \\leq a, b < 2^{63}$。\n\nEOF 结束，没有代表行数的 $n$，第一行就是数据。\n\n数据随机生成。", "locale": "zh-CN"}}}
{"pid": "P2407", "type": "P", "difficulty": 5, "samples": [["3 4\nTST.\nS.TT\nTSST\n", "o-o-o o\n|   |  \no o o-o\n|     |\no-o-o-o\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "各省省选", "山东", "最短路"], "title": "[SDOI2009] 地图复原", "background": null, "description": "很久以前，有一个传说中的“EWF”部族，他们世代生活在一个 $N×M$ 的矩形大地上。虽然，生活的地区有高山、有沼泽，但通过勤劳勇敢，渐渐地，他们在自己的地盘上修筑了一条回路。\n\n后来，“EWF”部族神秘地消失了。不过，考古学家在那片他们曾经生活过的地方找到了一份地图。地图是 $N\\times M$ 的矩阵，左上角的坐标为 $(0, 0)$，右下角的坐标为 $(N, M)$。矩阵中的每个格子，表示高山、沼泽、平地、房屋或是道路其中之一。如果一个格子表示道路，那么经过这个格子的道路要么是直走，要么是拐弯。如下图，左边2幅表示直走格子的，右边4幅表示需要拐弯的格子。一个表示道路的格子只能表示下列情况之一。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1588.png) \n\n可是，由于地图的年代久远，考古学家虽然能分清一个格子代表的地形，可对于道路的标记，考古学家们只能分清这一格是表示直走的还是拐弯的。现在，他们求助于你，希望你能帮助他们复原这份“EWF”部族的地图。", "inputFormat": "输入文件 `recover.in` 的第一行包含两个用空格分隔的正整数 $N$ 和 $M$，分别表示地图的高和长。\n\n接下来一个 $N$ 行 $M$ 列的矩阵描述地图，矩阵中没有多余字符。\n\n大写 `S`表示直走的道路，大写 `T` 表示拐弯的道路，点 `.` 表示高山、沼泽、平地和房屋。", "outputFormat": "输出文件 `recover.out` 包含 $2N-1$ 行，每行 $2M-1$ 个字符，描述了这条回路。\n\n所有第 $2i+1$ 行的 $2j+1$ 个字符为小写字母 `o`，表示了矩阵的第 $i$ 行第 $j$ 列的格子的中心 $(i, j)$。\n\n若回路包含了 $(i, j )$ 到 $(i, j+1)$ 或 $ (i, j+1)$ 到 $(i, j)$ 的一条路径，则第 $2i+1$ 行的第 $2j+2$ 个字符为减号 `-`（ASCII 码为 $45$）；\n\n若回路包含了 $(i, j)$ 到 $ (i+1, j)$ 或 $(i+1, j)$ 到 $(i, j)$ 的一条路径，则第 $2i+2$ 行的第 $ 2j+1$ 个字符为竖线 `|`（ASCII码为 $124$）。\n\n其它以上未说明位置上的字符为空格（ASCII 码为 $32$）。\n\n输入数据保证至少存在一个合法解，故你的输出应有且仅有一条回路。如果存在多组答案，请输出任意一组。", "hint": "对于 $20\\%$ 的数据，有 $N \\le 10$；\n\n对于 $40\\%$ 的数据，有 $1 \\le N, M \\le 80$；\n\n对于 $40\\%$ 的数据，输入没有 `.`，且 $N, M > 10$；\n\n对于 $100\\%$ 的数据，满足 $1 \\le N, M \\le 800$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2009] Map Restoration", "background": "", "description": "Long ago, there was a legendary tribe called \"EWF\" who lived on an $N \\times M$ rectangular land. Although there were mountains and swamps, through hard work and courage, they eventually built a loop on their territory.\n\nLater, the \"EWF\" tribe mysteriously disappeared. However, archaeologists found a map in the place where they once lived. The map is an $N \\times M$ matrix, with the top-left coordinate at $(0, 0)$ and the bottom-right coordinate at $(N, M)$. Each cell represents one of the following: mountain, swamp, plain, house, or road. If a cell represents a road, then the road passing through this cell is either straight or turning. As shown below, the two on the left are straight cells, and the four on the right are turning cells. A cell that represents a road can only be one of the cases below.\n\n![](https://cdn.luogu.com.cn/upload/pic/1588.png)\n\nHowever, due to the age of the map, while archaeologists can identify the type of terrain each cell represents, for road markings they can only distinguish whether a cell is straight or turning. Now they ask for your help to restore the \"EWF\" tribe’s map.", "inputFormat": "The first line of the input file recover.in contains two positive integers $N$ and $M$ separated by a space, representing the height and width of the map.\n\nThen follows an $N$-row, $M$-column matrix describing the map, with no extra characters.\n\nUppercase \"S\" denotes a straight road cell, uppercase \"T\" denotes a turning road cell, and \".\" denotes mountain, swamp, plain, or house.", "outputFormat": "The output file recover.out contains $2N - 1$ lines, each with $2M - 1$ characters, describing the loop.\n\nFor all positions at row $2i + 1$, column $2j + 1$, the character is the lowercase letter \"o\", representing the center $(i, j)$ of the cell in row $i$, column $j$ of the matrix.\n\nIf the loop contains a path from $(i, j)$ to $(i, j + 1)$ or from $(i, j + 1)$ to $(i, j)$, then the character at row $2i + 1$, column $2j + 2$ is a hyphen \"-\" (ASCII code 45).\n\nIf the loop contains a path from $(i, j)$ to $(i + 1, j)$ or from $(i + 1, j)$ to $(i, j)$, then the character at row $2i + 2$, column $2j + 1$ is a vertical bar \"|\" (ASCII code 124).\n\nAll other positions not mentioned above are spaces (ASCII code 32).\n\nThe input guarantees that there exists at least one valid solution, so your output should contain exactly one loop. If multiple answers exist, output any one of them.", "hint": "- For 20% of the testdata, $N \\le 10$.\n- For 40% of the testdata, $1 \\le N, M \\le 80$.\n- For 40% of the testdata, the input contains no \".\", and $N, M > 10$.\n- For 100% of the testdata, $1 \\le N, M \\le 800$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2009] 地图复原", "background": null, "description": "很久以前，有一个传说中的“EWF”部族，他们世代生活在一个 $N×M$ 的矩形大地上。虽然，生活的地区有高山、有沼泽，但通过勤劳勇敢，渐渐地，他们在自己的地盘上修筑了一条回路。\n\n后来，“EWF”部族神秘地消失了。不过，考古学家在那片他们曾经生活过的地方找到了一份地图。地图是 $N\\times M$ 的矩阵，左上角的坐标为 $(0, 0)$，右下角的坐标为 $(N, M)$。矩阵中的每个格子，表示高山、沼泽、平地、房屋或是道路其中之一。如果一个格子表示道路，那么经过这个格子的道路要么是直走，要么是拐弯。如下图，左边2幅表示直走格子的，右边4幅表示需要拐弯的格子。一个表示道路的格子只能表示下列情况之一。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1588.png) \n\n可是，由于地图的年代久远，考古学家虽然能分清一个格子代表的地形，可对于道路的标记，考古学家们只能分清这一格是表示直走的还是拐弯的。现在，他们求助于你，希望你能帮助他们复原这份“EWF”部族的地图。", "inputFormat": "输入文件 `recover.in` 的第一行包含两个用空格分隔的正整数 $N$ 和 $M$，分别表示地图的高和长。\n\n接下来一个 $N$ 行 $M$ 列的矩阵描述地图，矩阵中没有多余字符。\n\n大写 `S`表示直走的道路，大写 `T` 表示拐弯的道路，点 `.` 表示高山、沼泽、平地和房屋。", "outputFormat": "输出文件 `recover.out` 包含 $2N-1$ 行，每行 $2M-1$ 个字符，描述了这条回路。\n\n所有第 $2i+1$ 行的 $2j+1$ 个字符为小写字母 `o`，表示了矩阵的第 $i$ 行第 $j$ 列的格子的中心 $(i, j)$。\n\n若回路包含了 $(i, j )$ 到 $(i, j+1)$ 或 $ (i, j+1)$ 到 $(i, j)$ 的一条路径，则第 $2i+1$ 行的第 $2j+2$ 个字符为减号 `-`（ASCII 码为 $45$）；\n\n若回路包含了 $(i, j)$ 到 $ (i+1, j)$ 或 $(i+1, j)$ 到 $(i, j)$ 的一条路径，则第 $2i+2$ 行的第 $ 2j+1$ 个字符为竖线 `|`（ASCII码为 $124$）。\n\n其它以上未说明位置上的字符为空格（ASCII 码为 $32$）。\n\n输入数据保证至少存在一个合法解，故你的输出应有且仅有一条回路。如果存在多组答案，请输出任意一组。", "hint": "对于 $20\\%$ 的数据，有 $N \\le 10$；\n\n对于 $40\\%$ 的数据，有 $1 \\le N, M \\le 80$；\n\n对于 $40\\%$ 的数据，输入没有 `.`，且 $N, M > 10$；\n\n对于 $100\\%$ 的数据，满足 $1 \\le N, M \\le 800$。", "locale": "zh-CN"}}}
{"pid": "P2408", "type": "P", "difficulty": 6, "samples": [["5\naabaa", "11"], ["3\naba", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "动态规划 DP", "线性数据结构", "后缀自动机 SAM", "后缀数组 SA"], "title": "不同子串个数", "background": "因为 NOI 被虐傻了，蒟蒻的 YJQ 准备来学习一下字符串，于是它碰到了这样一道题：\n", "description": "给你一个长为 $n$ 的字符串，求不同的子串的个数。\n\n我们定义两个子串不同，当且仅当有这两个子串长度不一样或者长度一样且有任意一位不一样。\n\n子串的定义：原字符串中连续的一段字符组成的字符串。\n", "inputFormat": "第一行一个整数 $n$。\n\n接下来一行 $n$ 个字符表示给出的字符串。\n", "outputFormat": "一行一个整数，表示不一样的子串个数。\n", "hint": "### 提示\n\n请使用64位整数来进行输出。\n\n### 数据规模与约定\n- 对于 $30\\%$ 的数据，保证 $n\\le 1000$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\le 10^5$，字符串中只有小写英文字母。\n", "locale": "zh-CN", "translations": {"en": {"title": "Number of Distinct Substrings", "background": "After getting crushed by NOI, the \"ju ruo\" (rookie) YJQ decided to study strings and came across this problem.", "description": "Given a string of length $n$, find the number of distinct substrings.\n\nWe define two substrings to be different if and only if either their lengths are different, or their lengths are the same but there exists at least one position where they differ.\n\nA substring is defined as a contiguous segment of characters in the original string.", "inputFormat": "The first line contains an integer $n$.\n\nThe second line contains $n$ characters representing the given string.", "outputFormat": "Output a single integer in one line, representing the number of distinct substrings.", "hint": "Please use a 64-bit integer for the output.\n\nConstraints\n- For 30% of the testdata, $n \\le 1000$.\n- For 100% of the testdata, $1 \\leq n \\le 10^5$, and the string contains only lowercase English letters.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "不同子串个数", "background": "因为 NOI 被虐傻了，蒟蒻的 YJQ 准备来学习一下字符串，于是它碰到了这样一道题：\n", "description": "给你一个长为 $n$ 的字符串，求不同的子串的个数。\n\n我们定义两个子串不同，当且仅当有这两个子串长度不一样或者长度一样且有任意一位不一样。\n\n子串的定义：原字符串中连续的一段字符组成的字符串。\n", "inputFormat": "第一行一个整数 $n$。\n\n接下来一行 $n$ 个字符表示给出的字符串。\n", "outputFormat": "一行一个整数，表示不一样的子串个数。\n", "hint": "### 提示\n\n请使用64位整数来进行输出。\n\n### 数据规模与约定\n- 对于 $30\\%$ 的数据，保证 $n\\le 1000$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\le 10^5$，字符串中只有小写英文字母。\n", "locale": "zh-CN"}}}
{"pid": "P2409", "type": "P", "difficulty": 4, "samples": [["3 10\n4 1 3 4 5\n3 1 7 9\n4 1 2 3 5\n", "3 4 5 5 6 6 7 7 7 7\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2016", "洛谷原创", "洛谷月赛"], "title": "Y的积木", "background": "Y 是个大建筑师，他总能用最简单的积木拼出最有创意的造型。", "description": "Y 手上有 $n$ 盒积木，每个积木有个重量。现在他想从每盒积木中拿一块积木，放在一起，这一堆积木的重量为每块积木的重量和。现在他想知道重量和最小的 $k$ 种取法的重量分别是多少。（只要任意更换一块积木，就视为一种不同的取法。如果多种取法重量总和一样，我们需要输出多次。）", "inputFormat": "第一行输入两个整数，$n,k$，意义如题目所描述。\n\n每组数据接下来的 $n$ 行，第一个整数为 $m_i$，表示第 $i$ 盒积木的数量，在同一行有 $m_i$ 个整数，分别表示每个积木的重量。", "outputFormat": "一行，重量最小的 $k$ 种取法的重量，要求对于每个数据，从小到大输出。", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，$2 \\le m_i \\le 10$，$1 \\le n \\le 10$。\n- 对于 $50\\%$ 的数据，$2 \\le m_i \\le 50$，$1 \\le n \\le 50$。\n- 对于 $100\\%$ 的数据，$2 \\le m_i \\le 100$，$1 \\le n \\le 100$，$1 \\le k \\le 10^4$，每个积木的重量为不超过 $100$ 的正整数，所有 $m_i$ 的积大于等于 $k$。\n\n本题不卡常。", "locale": "zh-CN", "translations": {"en": {"title": "Y's Blocks", "background": "Y is a great architect. He can always build the most creative shapes with the simplest blocks.", "description": "Y has $n$ boxes of blocks, and each block has a weight. He wants to pick one block from each box and put them together; the total weight of this pile is the sum of the weights of the chosen blocks. Now he wants to know the weights of the $k$ selections with the smallest total weights. (As long as you replace any single block, it is considered a different selection. If multiple selections have the same total weight, we should output that weight multiple times.)", "inputFormat": "The first line contains two integers, $n,k$, as described.\n\nIn the next $n$ lines, line $i$ starts with an integer $m_i$, the number of blocks in the $i$-th box. On the same line, there are $m_i$ integers, which are the weights of the blocks.", "outputFormat": "Output one line containing the weights of the $k$ selections with the smallest total weights, in nondecreasing order.", "hint": "Constraints\n\n- For $30\\%$ of the testdata, $2 \\le m_i \\le 10$, $1 \\le n \\le 10$.\n- For $50\\%$ of the testdata, $2 \\le m_i \\le 50$, $1 \\le n \\le 50$.\n- For $100\\%$ of the testdata, $2 \\le m_i \\le 100$, $1 \\le n \\le 100$, $1 \\le k \\le 10^4$, each block’s weight is a positive integer not exceeding $100$, and the product of all $m_i$ is at least $k$.\n\nThis problem does not stress constant factors.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Y的积木", "background": "Y 是个大建筑师，他总能用最简单的积木拼出最有创意的造型。", "description": "Y 手上有 $n$ 盒积木，每个积木有个重量。现在他想从每盒积木中拿一块积木，放在一起，这一堆积木的重量为每块积木的重量和。现在他想知道重量和最小的 $k$ 种取法的重量分别是多少。（只要任意更换一块积木，就视为一种不同的取法。如果多种取法重量总和一样，我们需要输出多次。）", "inputFormat": "第一行输入两个整数，$n,k$，意义如题目所描述。\n\n每组数据接下来的 $n$ 行，第一个整数为 $m_i$，表示第 $i$ 盒积木的数量，在同一行有 $m_i$ 个整数，分别表示每个积木的重量。", "outputFormat": "一行，重量最小的 $k$ 种取法的重量，要求对于每个数据，从小到大输出。", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，$2 \\le m_i \\le 10$，$1 \\le n \\le 10$。\n- 对于 $50\\%$ 的数据，$2 \\le m_i \\le 50$，$1 \\le n \\le 50$。\n- 对于 $100\\%$ 的数据，$2 \\le m_i \\le 100$，$1 \\le n \\le 100$，$1 \\le k \\le 10^4$，每个积木的重量为不超过 $100$ 的正整数，所有 $m_i$ 的积大于等于 $k$。\n\n本题不卡常。", "locale": "zh-CN"}}}
{"pid": "P2410", "type": "P", "difficulty": 6, "samples": [["2 2\n90 10\n20 80\n1 1\n1 1\n", "10\n01\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2009", "各省省选", "山东", "Special Judge", "最短路"], "title": "[SDOI2009] 最优图像", "background": "小 E 在好友小 W 的家中发现一幅神奇的图画，对此颇有兴趣。", "description": "这幅画可以被看做一个包含 $n \\times m$ 个像素的黑白图像，为了方便起见，我们用 $0$ 表示白色像素，$1$ 表示黑色像素。小 E 认为这幅图画暗藏玄机，因此他记录下了这幅图像中每行、每列的黑色像素数量，以回去慢慢研究其中的奥妙。\n\n有一天，小 W 不慎将图画打湿，原本的图像已经很难分辨。他十分着急，于是找来小 E，希望共同还原这幅图画。根据打湿后的图画，他们无法确定真正的图像，然而可以推测出每个像素原本是黑色像素的概率 $p_{i,j}\\%$。那么，一个完整的图像的出现概率就可以定义为:\n\n$$\\prod\\limits_{i = 1}^n \\prod\\limits_{j = 1}^{m} p_{i, j}\\% \\times [s_{i, j} = 1]$$\n\n其中 $s_{i,j}$ 表示在还原后的图像中，像素是白色($0$)还是黑色($1$)，$[s_{i, j} = 1]$ 表示若 $s_{i, j} = 1$，则该表达式的值为 $1$，否则为 $0$。换句话说，一个完整图像出现概率就等于其所有黑色像素的出现概率之积。显然，图像的黑色像素不能包含概率为 $0$ 的像素。\n\n然而，小 E 对此也无能为力。因此他们找到了会编程的小 F，也就是你，请你根据以上信息，告诉他们最有可能是原始图像的答案是什么。\n\n", "inputFormat": "第一行是两个整数 $n, m$，表示图像大小。\n\n第 $2$ 到第 $(n + 1)$ 行，每行 $m$ 个整数，第 $(i + 1)$ 行的第 $j$ 个整数 $p_{i, j}$ 表示第 $i$ 行第 $j$ 列的像素是黑色的概率。\n\n接下来一行有 $n$ 个整数，第  $i$ 个整数 $a_i$ 表示第 $i$ 行中黑色像素的个数。\n\n接下来一行有 $m$ 个整数，第 $i$ 个整数 $b_i$ 表示第 $i$ 列中黑色像素的个数。\n", "outputFormat": "**本题存在 Special Judge**。\n\n输出 $n$ 行每行一个长度为 $m$ 的只含字符 `0` 和字符 `1` 的字符串，表示答案。\n\n输入数据保证至少存在一个可能的图像。如果有多种最优图像，任意输出一种即可。\n", "hint": "#### 样例输入输出 1 解释\n\n共有两种可能的图像：\n\n```plain\n01\n10\n```\n```plain\n10\n01\n```\n前者的出现概率是 $0.1×0.2=0.02$，后者的出现概率是 $0.9×0.8=0.72$，故后者是最优图像。\n\n---\n\n#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，保证 $n, m \\leq 5$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n, m \\leq 100$，$0 \\leq p_{i, j} \\leq 100$，$0 \\leq a_i \\leq m$，$0 \\leq b_i \\leq n$。\n\n---\n\n感谢 @[test12345](https://www.luogu.com.cn/user/23118) 提供 spj。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2009] Optimal Image", "background": "Xiao E found a magical picture at his friend Xiao W’s home and became very interested in it.", "description": "This picture can be regarded as a black-and-white image with $n \\times m$ pixels. For convenience, we use $0$ for white pixels and $1$ for black pixels. Xiao E believed the picture hid some secrets, so he recorded the number of black pixels in each row and each column to study later.\n\nOne day, Xiao W accidentally got the picture wet, and the original image became hard to recognize. Anxious, he asked Xiao E to help restore it. Based on the wet picture, they could not determine the exact image, but they could estimate the probability $p_{i, j}\\%$ that each pixel was originally black. Then, the occurrence probability of a complete image can be defined as:\n$$\\prod\\limits_{i = 1}^n \\prod\\limits_{j = 1}^{m} p_{i, j}\\% \\times [s_{i, j} = 1]$$\nHere $s_{i, j}$ denotes whether the pixel in the restored image is white ($0$) or black ($1$), and $[s_{i, j} = 1]$ means the value of this expression is $1$ if $s_{i, j} = 1$, and $0$ otherwise. In other words, the occurrence probability of a complete image equals the product of the probabilities of all its black pixels. Clearly, the set of black pixels in the image cannot include any pixel with probability $0$.\n\nHowever, Xiao E could not solve this either. So they turned to Xiao F, a programmer — that is, you. Please, based on the above information, tell them which image is the most likely original image.", "inputFormat": "The first line contains two integers $n, m$, denoting the size of the image.\n\nLines $2$ to $(n + 1)$ each contain $m$ integers. In the $(i + 1)$-th line, the $j$-th integer $p_{i, j}$ denotes the probability that the pixel in row $i$, column $j$ is black.\n\nThe next line contains $n$ integers. The $i$-th integer $a_i$ denotes the number of black pixels in row $i$.\n\nThe next line contains $m$ integers. The $i$-th integer $b_i$ denotes the number of black pixels in column $i$.", "outputFormat": "This problem uses a Special Judge.\n\nOutput $n$ lines, each containing a string of length $m$ consisting only of characters `0` and `1`, representing your answer.\n\nThe input guarantees that at least one valid image exists. If there are multiple optimal images, output any one of them.", "hint": "#### Explanation of Sample Input/Output 1\n\nThere are two possible images:\n\n```plain\n01\n10\n```\n```plain\n10\n01\n```\nThe occurrence probability of the former is $0.1×0.2=0.02$, and that of the latter is $0.9×0.8=0.72$, so the latter is the optimal image.\n\n---\n\n#### Constraints\n\n- For $20\\%$ of the testdata, $n, m \\leq 5$.\n- For $100\\%$ of the testdata, $1 \\leq n, m \\leq 100$, $0 \\leq p_{i, j} \\leq 100$, $0 \\leq a_i \\leq m$, $0 \\leq b_i \\leq n$.\n\n---\n\nThanks to @[test12345](https://www.luogu.com.cn/user/23118) for providing the spj.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2009] 最优图像", "background": "小 E 在好友小 W 的家中发现一幅神奇的图画，对此颇有兴趣。", "description": "这幅画可以被看做一个包含 $n \\times m$ 个像素的黑白图像，为了方便起见，我们用 $0$ 表示白色像素，$1$ 表示黑色像素。小 E 认为这幅图画暗藏玄机，因此他记录下了这幅图像中每行、每列的黑色像素数量，以回去慢慢研究其中的奥妙。\n\n有一天，小 W 不慎将图画打湿，原本的图像已经很难分辨。他十分着急，于是找来小 E，希望共同还原这幅图画。根据打湿后的图画，他们无法确定真正的图像，然而可以推测出每个像素原本是黑色像素的概率 $p_{i,j}\\%$。那么，一个完整的图像的出现概率就可以定义为:\n\n$$\\prod\\limits_{i = 1}^n \\prod\\limits_{j = 1}^{m} p_{i, j}\\% \\times [s_{i, j} = 1]$$\n\n其中 $s_{i,j}$ 表示在还原后的图像中，像素是白色($0$)还是黑色($1$)，$[s_{i, j} = 1]$ 表示若 $s_{i, j} = 1$，则该表达式的值为 $1$，否则为 $0$。换句话说，一个完整图像出现概率就等于其所有黑色像素的出现概率之积。显然，图像的黑色像素不能包含概率为 $0$ 的像素。\n\n然而，小 E 对此也无能为力。因此他们找到了会编程的小 F，也就是你，请你根据以上信息，告诉他们最有可能是原始图像的答案是什么。\n\n", "inputFormat": "第一行是两个整数 $n, m$，表示图像大小。\n\n第 $2$ 到第 $(n + 1)$ 行，每行 $m$ 个整数，第 $(i + 1)$ 行的第 $j$ 个整数 $p_{i, j}$ 表示第 $i$ 行第 $j$ 列的像素是黑色的概率。\n\n接下来一行有 $n$ 个整数，第  $i$ 个整数 $a_i$ 表示第 $i$ 行中黑色像素的个数。\n\n接下来一行有 $m$ 个整数，第 $i$ 个整数 $b_i$ 表示第 $i$ 列中黑色像素的个数。\n", "outputFormat": "**本题存在 Special Judge**。\n\n输出 $n$ 行每行一个长度为 $m$ 的只含字符 `0` 和字符 `1` 的字符串，表示答案。\n\n输入数据保证至少存在一个可能的图像。如果有多种最优图像，任意输出一种即可。\n", "hint": "#### 样例输入输出 1 解释\n\n共有两种可能的图像：\n\n```plain\n01\n10\n```\n```plain\n10\n01\n```\n前者的出现概率是 $0.1×0.2=0.02$，后者的出现概率是 $0.9×0.8=0.72$，故后者是最优图像。\n\n---\n\n#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，保证 $n, m \\leq 5$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n, m \\leq 100$，$0 \\leq p_{i, j} \\leq 100$，$0 \\leq a_i \\leq m$，$0 \\leq b_i \\leq n$。\n\n---\n\n感谢 @[test12345](https://www.luogu.com.cn/user/23118) 提供 spj。", "locale": "zh-CN"}}}
{"pid": "P2411", "type": "P", "difficulty": 5, "samples": [["4 8 \n0 0 0 1 0 0 0 0 \n0 0 0 0 0 2 0 1 \n0 0 0 0 0 4 0 0 \n3 0 0 0 0 0 1 0 \n", "2\n6\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "USACO"], "title": "[USACO07FEB] Silver Lilypad Pond S", "background": "", "description": "为了让奶牛们娱乐和锻炼，Famer John 建造了一个美丽的池塘。这个长方形的池子被分成了 $M \\times N$ 个方格（$1 \\le M,N \\le 30$）。一些格子是坚固得令人惊讶的莲花，还有一些格子是岩石，其余的只是美丽、纯净、湛蓝的水。\n\nBessie 正在练习芭蕾舞，她站在一朵莲花上，想跳到另一朵莲花上去，她只能从一朵莲花跳到另一朵莲花上，既不能跳到水里，也不能跳到岩石上。\n\nBessie 的舞步很像象棋中的马步：每次总是先横向移动一格，再纵向移动两格，或先纵向移动两格，再横向移动一格。最多时，Bessie 会有八个移动方向可供选择。\n\n约翰一直在观看 Bessie 的芭蕾练习，发现她有时候不能跳到终点，因为中间缺了一些荷叶。\n\n于是他想要添加几朵莲花来帮助 Bessie 完成任务。一贯节俭的 John 只想添加最少数量的莲花，当然，莲花不能放在石头上。\n\n请帮助 John确定必须要添加的莲花的最少数量。在添加莲花最少的基础上，确定 Bessie 从起点跳到目标需要的最少步数。最后，确定满足添加的莲花数量最少时，步数最少的路径条数。", "inputFormat": "第一行，输入两个用空格分开的整数：$M$ 和 $N$。\n\n第二行到 $M + 1$ 行：第 $i + 1$ 行有 $N$ 个用空格分开的整数，描述了池塘第 $i$ 行的状态：`0` 为水，`1` 为莲花，`2` 为岩石，`3` 为 Bessie 所在的起点，`4` 为 Bessie 想去的终点。", "outputFormat": "第一行，一个整数，表示需要添加的莲花的最少数目；如果无解，则输出 $-1$。\n\n第二行，一个整数，表示在添加莲花最少的基础上，贝西从起点跳到终点需要的最少步数；如果第一行是 $-1$，不输出这行。\n\n第三行，一个整数，表示在添加莲花最少的基础上，步数等于第二行输出的路径条数；如果第一行是 $-1$，不输出这行。", "hint": "池塘分成四行八列，贝西的起点在第四行第一列，想去的终点在第三行第六列，池塘里一共有五朵莲花和一块石头。\n\n最少要加两朵莲花，位置如 `x` 所示：\n\n```\n0 0 0 1 0 0 0 0    0 0 0 1 0 0 0 0 \n0 x 0 0 0 2 0 1    0 0 0 0 0 2 0 1 \n0 0 0 0 x 4 0 0    0 0 x 0 x 4 0 0 \n3 0 0 0 0 0 1 0    3 0 0 0 0 0 1 0 \n```\n\n贝西至少要跳六步，两种不同的跳法如下：\n\n```\n0 0 0 C 0 0 0 0    0 0 0 C 0 0 0 0 \n0 B 0 0 0 2 0 F    0 0 0 0 0 2 0 F \n0 0 0 0 D G 0 0    0 0 B 0 D G 0 0 \nA 0 0 0 0 0 E 0    A 0 0 0 0 0 E 0  \n```", "locale": "zh-CN", "translations": {"en": {"title": "[USACO07FEB] Silver Lilypad Pond S", "background": "", "description": "To entertain and exercise the cows, Farmer John built a beautiful pond. This rectangular pond is divided into $M \\times N$ cells ($1 \\le M, N \\le 30$). Some cells are surprisingly sturdy lilypads, some cells are rocks, and the rest are just beautiful, pure, azure water.\n\nBessie is practicing ballet. She is standing on a lilypad and wants to jump to another lilypad. She can only jump from one lilypad to another; she cannot land in water or on rocks.\n\nBessie’s steps are like a knight’s moves in chess: each time she either moves one square horizontally and then two squares vertically, or two squares vertically and then one square horizontally. At most, Bessie has eight possible directions to move.\n\nJohn has been watching Bessie’s ballet practice and noticed that sometimes she cannot reach the destination because some lilypads are missing along the way.\n\nSo he wants to add a few lilypads to help Bessie complete the task. Being thrifty as always, John wants to add the minimum number of lilypads; of course, lilypads cannot be placed on rocks.\n\nPlease help John determine the minimum number of lilypads that must be added. Under the condition of adding the fewest lilypads, determine the minimum number of jumps Bessie needs to go from the start to the target. Finally, under the same minimum additions, determine the number of paths whose length equals that minimum number of jumps.", "inputFormat": "The first line contains two integers separated by a space: $M$ and $N$.\n\nLines $2$ through $M + 1$: the $(i + 1)$-th line contains $N$ integers separated by spaces, describing the $i$-th row of the pond: `0` for water, `1` for a lilypad, `2` for a rock, `3` for Bessie’s starting cell, and `4` for Bessie’s target cell.", "outputFormat": "The first line contains a single integer: the minimum number of lilypads that must be added; if there is no solution, output $-1$.\n\nThe second line contains a single integer: under the condition of adding the fewest lilypads, the minimum number of jumps Bessie needs from the start to the target; if the first line is $-1$, do not output this line.\n\nThe third line contains a single integer: under the condition of adding the fewest lilypads, the number of paths whose length equals the number in the second line; if the first line is $-1$, do not output this line.", "hint": "The pond has four rows and eight columns. Bessie’s start is at row 4, column 1, and her target is at row 3, column 6. There are five lilypads and one rock in the pond.\n\nAt least two lilypads need to be added, at the positions marked with `x`:\n\n```\n0 0 0 1 0 0 0 0    0 0 0 1 0 0 0 0 \n0 x 0 0 0 2 0 1    0 0 0 0 0 2 0 1 \n0 0 0 0 x 4 0 0    0 0 x 0 x 4 0 0 \n3 0 0 0 0 0 1 0    3 0 0 0 0 0 1 0 \n```\n\nBessie needs at least six jumps. Two different sequences of jumps are as follows:\n\n```\n0 0 0 C 0 0 0 0    0 0 0 C 0 0 0 0 \n0 B 0 0 0 2 0 F    0 0 0 0 0 2 0 F \n0 0 0 0 D G 0 0    0 0 B 0 D G 0 0 \nA 0 0 0 0 0 E 0    A 0 0 0 0 0 E 0  \n```\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO07FEB] Silver Lilypad Pond S", "background": "", "description": "为了让奶牛们娱乐和锻炼，Famer John 建造了一个美丽的池塘。这个长方形的池子被分成了 $M \\times N$ 个方格（$1 \\le M,N \\le 30$）。一些格子是坚固得令人惊讶的莲花，还有一些格子是岩石，其余的只是美丽、纯净、湛蓝的水。\n\nBessie 正在练习芭蕾舞，她站在一朵莲花上，想跳到另一朵莲花上去，她只能从一朵莲花跳到另一朵莲花上，既不能跳到水里，也不能跳到岩石上。\n\nBessie 的舞步很像象棋中的马步：每次总是先横向移动一格，再纵向移动两格，或先纵向移动两格，再横向移动一格。最多时，Bessie 会有八个移动方向可供选择。\n\n约翰一直在观看 Bessie 的芭蕾练习，发现她有时候不能跳到终点，因为中间缺了一些荷叶。\n\n于是他想要添加几朵莲花来帮助 Bessie 完成任务。一贯节俭的 John 只想添加最少数量的莲花，当然，莲花不能放在石头上。\n\n请帮助 John确定必须要添加的莲花的最少数量。在添加莲花最少的基础上，确定 Bessie 从起点跳到目标需要的最少步数。最后，确定满足添加的莲花数量最少时，步数最少的路径条数。", "inputFormat": "第一行，输入两个用空格分开的整数：$M$ 和 $N$。\n\n第二行到 $M + 1$ 行：第 $i + 1$ 行有 $N$ 个用空格分开的整数，描述了池塘第 $i$ 行的状态：`0` 为水，`1` 为莲花，`2` 为岩石，`3` 为 Bessie 所在的起点，`4` 为 Bessie 想去的终点。", "outputFormat": "第一行，一个整数，表示需要添加的莲花的最少数目；如果无解，则输出 $-1$。\n\n第二行，一个整数，表示在添加莲花最少的基础上，贝西从起点跳到终点需要的最少步数；如果第一行是 $-1$，不输出这行。\n\n第三行，一个整数，表示在添加莲花最少的基础上，步数等于第二行输出的路径条数；如果第一行是 $-1$，不输出这行。", "hint": "池塘分成四行八列，贝西的起点在第四行第一列，想去的终点在第三行第六列，池塘里一共有五朵莲花和一块石头。\n\n最少要加两朵莲花，位置如 `x` 所示：\n\n```\n0 0 0 1 0 0 0 0    0 0 0 1 0 0 0 0 \n0 x 0 0 0 2 0 1    0 0 0 0 0 2 0 1 \n0 0 0 0 x 4 0 0    0 0 x 0 x 4 0 0 \n3 0 0 0 0 0 1 0    3 0 0 0 0 0 1 0 \n```\n\n贝西至少要跳六步，两种不同的跳法如下：\n\n```\n0 0 0 C 0 0 0 0    0 0 0 C 0 0 0 0 \n0 B 0 0 0 2 0 F    0 0 0 0 0 2 0 F \n0 0 0 0 D G 0 0    0 0 B 0 D G 0 0 \nA 0 0 0 0 0 E 0    A 0 0 0 0 0 E 0  \n```", "locale": "zh-CN"}}}
{"pid": "P2412", "type": "P", "difficulty": 3, "samples": [["5 5\nabsi\nhansbug\nlzn\nkkk\nyyy\n1 5\n1 1\n1 2\n2 3\n4 4", "yyy\nabsi\nhansbug\nlzn\nkkk\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "搜索", "2016", "线段树", "洛谷原创", "ST 表", "洛谷月赛"], "title": "查单词", "background": "滚粗了的 HansBug 在收拾旧英语书，然而他发现了什么奇妙的东西。", "description": "蒟蒻 HansBug 在一本英语书里面找到了一个单词表，包含 $N$ 个单词（每个单词内包含大小写字母）。现在他想要找出某一段连续的单词内字典序最大的单词。", "inputFormat": "第一行包含两个正整数 $N, M$，分别表示单词个数和询问个数。\n\n接下来 $N$ 行每行包含一个字符串，仅包含大小写字母，长度不超过 $15$，表示一个单词。单词**大小写不敏感**。\n\n再接下来 $M$ 行每行包含两个整数 $x, y$，表示查询求从第 $x$ 到第 $y$ 个单词中字典序最大的单词。如果有两个单词忽略大小写情况下字典序相同，**输出靠后的那个**。", "outputFormat": "输出包含 $M$ 行，每行为一个字符串，分别依次对应 $M$ 个询问的结果。", "hint": "### 样例说明\n\n第一次操作：在 $\\tt\\left\\{absi,hansbug,lzn,kkk,yyy\\right\\}$ 中找出字典序最大的，故为 $\\tt yyy$。\n\n第二次操作：在 $\\tt\\left\\{absi\\right\\}$ 中找出字典序最大的，故为 $\\tt absi$。\n\n第三次操作：在 $\\tt\\left\\{absi,hansbug\\right\\}$ 中找出字典序最大的，故为 $\\tt hansbug$。\n\n第四次操作：在 $\\tt\\left\\{hansbug,lzn\\right\\}$ 中找出字典序最大的，故为 $\\tt lzn$。\n\n第五次操作：在 $\\tt\\left\\{kkk\\right\\}$ 中找出字典序最大的，故为 $\\tt kkk$。\n\n### 数据规模\n\n ![](https://cdn.luogu.com.cn/upload/pic/2274.png)", "locale": "zh-CN", "translations": {"en": {"title": "Word Lookup", "background": "While sorting his old English books, HansBug found something curious.", "description": "HansBug found a word list in an English book, containing $N$ words (each word consists of uppercase and lowercase letters). He wants to find the lexicographically largest word within a contiguous segment.", "inputFormat": "The first line contains two positive integers $N$ and $M$, representing the number of words and the number of queries.\n\nThe next $N$ lines each contain a string consisting only of uppercase and lowercase letters, with length at most $15$, representing a word. Words are case-insensitive.\n\nThe next $M$ lines each contain two integers $x$ and $y$, asking for the lexicographically largest word from the $x$-th to the $y$-th word. If two words are the same in lexicographical order when ignoring case, output the one that appears later.", "outputFormat": "Output $M$ lines, each containing a string, corresponding to the results of the $M$ queries in order.", "hint": "### Sample Explanation\n\nFirst operation: find the lexicographically largest in $\\tt\\left\\{absi,hansbug,lzn,kkk,yyy\\right\\}$, which is $\\tt yyy$.\n\nSecond operation: find the lexicographically largest in $\\tt\\left\\{absi\\right\\}$, which is $\\tt absi$.\n\nThird operation: find the lexicographically largest in $\\tt\\left\\{absi,hansbug\\right\\}$, which is $\\tt hansbug$.\n\nFourth operation: find the lexicographically largest in $\\tt\\left\\{hansbug,lzn\\right\\}$, which is $\\tt lzn$.\n\nFifth operation: find the lexicographically largest in $\\tt\\left\\{kkk\\right\\}$, which is $\\tt kkk$.\n\n### Constraints\n\n![](https://cdn.luogu.com.cn/upload/pic/2274.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "查单词", "background": "滚粗了的 HansBug 在收拾旧英语书，然而他发现了什么奇妙的东西。", "description": "蒟蒻 HansBug 在一本英语书里面找到了一个单词表，包含 $N$ 个单词（每个单词内包含大小写字母）。现在他想要找出某一段连续的单词内字典序最大的单词。", "inputFormat": "第一行包含两个正整数 $N, M$，分别表示单词个数和询问个数。\n\n接下来 $N$ 行每行包含一个字符串，仅包含大小写字母，长度不超过 $15$，表示一个单词。单词**大小写不敏感**。\n\n再接下来 $M$ 行每行包含两个整数 $x, y$，表示查询求从第 $x$ 到第 $y$ 个单词中字典序最大的单词。如果有两个单词忽略大小写情况下字典序相同，**输出靠后的那个**。", "outputFormat": "输出包含 $M$ 行，每行为一个字符串，分别依次对应 $M$ 个询问的结果。", "hint": "### 样例说明\n\n第一次操作：在 $\\tt\\left\\{absi,hansbug,lzn,kkk,yyy\\right\\}$ 中找出字典序最大的，故为 $\\tt yyy$。\n\n第二次操作：在 $\\tt\\left\\{absi\\right\\}$ 中找出字典序最大的，故为 $\\tt absi$。\n\n第三次操作：在 $\\tt\\left\\{absi,hansbug\\right\\}$ 中找出字典序最大的，故为 $\\tt hansbug$。\n\n第四次操作：在 $\\tt\\left\\{hansbug,lzn\\right\\}$ 中找出字典序最大的，故为 $\\tt lzn$。\n\n第五次操作：在 $\\tt\\left\\{kkk\\right\\}$ 中找出字典序最大的，故为 $\\tt kkk$。\n\n### 数据规模\n\n ![](https://cdn.luogu.com.cn/upload/pic/2274.png)", "locale": "zh-CN"}}}
{"pid": "P2413", "type": "P", "difficulty": 4, "samples": [["5                            \n(A,B)((C)(D),E)\n0.2\n0.3\n0.4\n0.5\n0.6", "0.2992"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "字符串", "搜索", "洛谷原创", "洛谷月赛"], "title": "yyy loves physics IV", "background": "“颤抖吧，实验室！”\n\nyyy再一次来到了那个惨遭蹂躏的实验室。\n", "description": "这次，在 Round1 里几乎壮烈牺牲的电路君又被翻了出来。一共有 $N$（$1 \\le N \\le 26$）个元件。\n\n物理学霸 yyy 用一堆导线将他们连了起来，串联，并联，各种联……\n\n但由于 yyy 的操作太不规范，导致每个元件都有损坏的风险，yyy 用他那天才的脑子算出元件 $i$ 损坏而断开的概率是 $p_i$（$0 \\le p_i \\le 1$），因为电路太复杂，yyy 请你帮忙算出电路断路的概率。\n\n电路连接方式：\n\n- 一个元件是最小的电路，用 $A$ 表示元件 $1$，$B$ 表示元件 $2$，以此类推。\n\n- $K$ 个电路组成的串联电路表示为电路 $1,2,\\dots,K$。\n\n- $K$ 个电路组成的并联电路表示为（电路 $1$）（电路 $2$）......（电路 $K$）。", "inputFormat": "第 $1$ 行是一个整数 $n$，表示一共有多少个元件；\n\n第 $2$ 行是表示电路的字符串；\n\n最后是 $n$ 行，每行是一个实数 $p_i$，表示元件 $i$ 断路的概率。", "outputFormat": "一个实数，表示整个电路断路的概率，精确到小数点后 $4$ 位。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "yyy loves physics IV", "background": "“Tremble, laboratory!”\n\nyyy once again returned to that ravaged laboratory.", "description": "This time, the circuit that almost perished heroically in Round 1 has been brought out again. There are $N$ ($1 \\le N \\le 26$) components.\n\nThe physics ace yyy connected them with a bunch of wires—series, parallel, all kinds of combinations...\n\nHowever, because yyy’s operation was too nonstandard, each component has a risk of being damaged. Using his genius brain, yyy calculated that the probability that component $i$ fails and becomes open is $p_i$ ($0 \\le p_i \\le 1$). Because the circuit is too complex, yyy asks you to compute the probability that the entire circuit becomes open (disconnected).\n\nCircuit wiring rules:\n\n- A single component is the smallest circuit, with A denoting component 1, B denoting component 2, and so on.\n- A series circuit composed of $K$ subcircuits is written as circuit 1, 2, ..., $K$.\n- A parallel circuit composed of $K$ subcircuits is written as (circuit 1)(circuit 2)...(circuit $K$).", "inputFormat": "The first line contains an integer $n$, the number of components.\n\nThe second line contains a string that describes the circuit.\n\nThe next $n$ lines each contain a real number $p_i$, the probability that component $i$ becomes open.", "outputFormat": "Output a real number: the probability that the entire circuit becomes open, accurate to 4 decimal places.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "yyy loves physics IV", "background": "“颤抖吧，实验室！”\n\nyyy再一次来到了那个惨遭蹂躏的实验室。\n", "description": "这次，在 Round1 里几乎壮烈牺牲的电路君又被翻了出来。一共有 $N$（$1 \\le N \\le 26$）个元件。\n\n物理学霸 yyy 用一堆导线将他们连了起来，串联，并联，各种联……\n\n但由于 yyy 的操作太不规范，导致每个元件都有损坏的风险，yyy 用他那天才的脑子算出元件 $i$ 损坏而断开的概率是 $p_i$（$0 \\le p_i \\le 1$），因为电路太复杂，yyy 请你帮忙算出电路断路的概率。\n\n电路连接方式：\n\n- 一个元件是最小的电路，用 $A$ 表示元件 $1$，$B$ 表示元件 $2$，以此类推。\n\n- $K$ 个电路组成的串联电路表示为电路 $1,2,\\dots,K$。\n\n- $K$ 个电路组成的并联电路表示为（电路 $1$）（电路 $2$）......（电路 $K$）。", "inputFormat": "第 $1$ 行是一个整数 $n$，表示一共有多少个元件；\n\n第 $2$ 行是表示电路的字符串；\n\n最后是 $n$ 行，每行是一个实数 $p_i$，表示元件 $i$ 断路的概率。", "outputFormat": "一个实数，表示整个电路断路的概率，精确到小数点后 $4$ 位。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2414", "type": "P", "difficulty": 6, "samples": [["aPaPBbP\n3\n1 2\n1 3\n2 3", "2\n1\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "树形数据结构", "2011", "NOI", "深度优先搜索 DFS", "AC 自动机", "离线处理"], "title": "[NOI2011] 阿狸的打字机", "background": "", "description": "阿狸喜欢收藏各种稀奇古怪的东西，最近他淘到一台老式的打字机。打字机上只有 $28$ 个按键，分别印有 $26$ 个小写英文字母和 `B`、`P` 两个字母。经阿狸研究发现，这个打字机是这样工作的：\n\n* 输入小写字母，打字机的一个凹槽中会加入这个字母(这个字母加在凹槽的最后)。\n* 按一下印有 `B` 的按键，打字机凹槽中最后一个字母会消失。\n* 按一下印有 `P` 的按键，打字机会在纸上打印出凹槽中现有的所有字母并换行，但凹槽中的字母不会消失。\n\n例如，阿狸输入 `aPaPBbP`，纸上被打印的字符如下：\n\n```\na\naa\nab\n```\n\n我们把纸上打印出来的字符串从 $1$ 开始顺序编号，一直到 $n$。打字机有一个非常有趣的功能，在打字机中暗藏一个带数字的小键盘，在小键盘上输入两个数 $(x,y)$（其中 $1\\leq x,y\\leq n$），打字机会显示第 $x$ 个打印的字符串在第 $y$ 个打印的字符串中出现了多少次。\n\n阿狸发现了这个功能以后很兴奋，他想写个程序完成同样的功能，你能帮助他么？\n", "inputFormat": "输入的第一行包含一个字符串，按阿狸的输入顺序给出所有阿狸输入的字符。\n\n第二行包含一个整数 $m$，表示询问个数。\n\n接下来 $m$ 行描述所有由小键盘输入的询问。其中第 $i$ 行包含两个整数 $x, y$，表示第 $i$ 个询问为 $(x, y)$。\n", "outputFormat": "输出 $m$ 行，其中第 $i$ 行包含一个整数，表示第 $i$ 个询问的答案。\n", "hint": "### 数据范围\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 10^5$，$1\\leq m\\leq10^5$，第一行总长度 $\\leq 10^5$。\n\n|测试点|$n$ 的规模|$m$ 的规模|字符串长度|第一行长度|\n|:-:|:-:|:-:|:-:|:-:|\n|$1,2$|$1\\leq n\\leq 100$|$1\\leq m\\leq 10^3$| - |$\\leq 100$|\n|$3,4$|$1\\leq n\\leq 10^3$|$1\\leq m\\leq 10^4$|单个长度 $\\leq 10^3$，总长度 $\\leq 10^5$|$\\leq 10^5$|\n|$5\\sim 7$|$1\\leq n\\leq 10^4$|$1\\leq m\\leq 10^5$|总长度 $\\leq 10^5$|$\\leq 10^5$|\n|$8\\sim 10$|$1\\leq n\\leq 10^5$|$1\\leq m\\leq 10^5$| - |$\\leq 10^5$|\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2011] Ali's Typewriter", "background": "", "description": "Ali likes collecting all kinds of quirky things, and he recently found an old typewriter. The typewriter has only $28$ keys, labeled with the $26$ lowercase English letters and the two letters `B` and `P`. After some study, Ali found that the typewriter works as follows:\n\n- When a lowercase letter is entered, the letter is appended to a slot in the typewriter (this letter is added to the end of the slot).\n- When the `B` key is pressed once, the last letter in the slot disappears.\n- When the `P` key is pressed once, the typewriter prints all the current letters in the slot on the paper and starts a new line, but the letters in the slot remain.\n\nFor example, if Ali inputs `aPaPBbP`, the characters printed on the paper are:\n\n```\na\naa\nab\n```\n\nWe number the strings printed on the paper starting from $1$ up to $n$. The typewriter has a very interesting feature: it hides a numeric keypad. By entering two numbers $(x, y)$ (where $1 \\leq x, y \\leq n$) on the keypad, the typewriter will display how many times the $x$-th printed string appears in the $y$-th printed string.\n\nAfter discovering this feature, Ali became excited and wanted to write a program to achieve the same function. Can you help him?", "inputFormat": "The first line contains a string that lists all characters Ali inputs in order.\n\nThe second line contains an integer $m$, the number of queries.\n\nEach of the next $m$ lines describes one query entered via the keypad. The $i$-th line contains two integers $x, y$, representing the $i$-th query $(x, y)$.", "outputFormat": "Output $m$ lines. The $i$-th line should contain one integer, the answer to the $i$-th query.", "hint": "### Constraints\n\nFor $100\\%$ of the testdata, $1 \\leq n \\leq 10^5$, $1 \\leq m \\leq 10^5$, and the length of the first line $\\leq 10^5$.\n\n| Test Points | $n$ scale | $m$ scale | string length | first line length |\n|:-:|:-:|:-:|:-:|:-:|\n| $1,2$ | $1 \\leq n \\leq 100$ | $1 \\leq m \\leq 10^3$ | - | $\\leq 100$ |\n| $3,4$ | $1 \\leq n \\leq 10^3$ | $1 \\leq m \\leq 10^4$ | single length $\\leq 10^3$, total length $\\leq 10^5$ | $\\leq 10^5$ |\n| $5 \\sim 7$ | $1 \\leq n \\leq 10^4$ | $1 \\leq m \\leq 10^5$ | total length $\\leq 10^5$ | $\\leq 10^5$ |\n| $8 \\sim 10$ | $1 \\leq n \\leq 10^5$ | $1 \\leq m \\leq 10^5$ | - | $\\leq 10^5$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2011] 阿狸的打字机", "background": "", "description": "阿狸喜欢收藏各种稀奇古怪的东西，最近他淘到一台老式的打字机。打字机上只有 $28$ 个按键，分别印有 $26$ 个小写英文字母和 `B`、`P` 两个字母。经阿狸研究发现，这个打字机是这样工作的：\n\n* 输入小写字母，打字机的一个凹槽中会加入这个字母(这个字母加在凹槽的最后)。\n* 按一下印有 `B` 的按键，打字机凹槽中最后一个字母会消失。\n* 按一下印有 `P` 的按键，打字机会在纸上打印出凹槽中现有的所有字母并换行，但凹槽中的字母不会消失。\n\n例如，阿狸输入 `aPaPBbP`，纸上被打印的字符如下：\n\n```\na\naa\nab\n```\n\n我们把纸上打印出来的字符串从 $1$ 开始顺序编号，一直到 $n$。打字机有一个非常有趣的功能，在打字机中暗藏一个带数字的小键盘，在小键盘上输入两个数 $(x,y)$（其中 $1\\leq x,y\\leq n$），打字机会显示第 $x$ 个打印的字符串在第 $y$ 个打印的字符串中出现了多少次。\n\n阿狸发现了这个功能以后很兴奋，他想写个程序完成同样的功能，你能帮助他么？\n", "inputFormat": "输入的第一行包含一个字符串，按阿狸的输入顺序给出所有阿狸输入的字符。\n\n第二行包含一个整数 $m$，表示询问个数。\n\n接下来 $m$ 行描述所有由小键盘输入的询问。其中第 $i$ 行包含两个整数 $x, y$，表示第 $i$ 个询问为 $(x, y)$。\n", "outputFormat": "输出 $m$ 行，其中第 $i$ 行包含一个整数，表示第 $i$ 个询问的答案。\n", "hint": "### 数据范围\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 10^5$，$1\\leq m\\leq10^5$，第一行总长度 $\\leq 10^5$。\n\n|测试点|$n$ 的规模|$m$ 的规模|字符串长度|第一行长度|\n|:-:|:-:|:-:|:-:|:-:|\n|$1,2$|$1\\leq n\\leq 100$|$1\\leq m\\leq 10^3$| - |$\\leq 100$|\n|$3,4$|$1\\leq n\\leq 10^3$|$1\\leq m\\leq 10^4$|单个长度 $\\leq 10^3$，总长度 $\\leq 10^5$|$\\leq 10^5$|\n|$5\\sim 7$|$1\\leq n\\leq 10^4$|$1\\leq m\\leq 10^5$|总长度 $\\leq 10^5$|$\\leq 10^5$|\n|$8\\sim 10$|$1\\leq n\\leq 10^5$|$1\\leq m\\leq 10^5$| - |$\\leq 10^5$|\n\n", "locale": "zh-CN"}}}
{"pid": "P2415", "type": "P", "difficulty": 2, "samples": [["2 3\n", "10\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "2015", "洛谷原创", "排列组合", "洛谷月赛"], "title": "集合求和", "background": "", "description": "给定一个集合 $s$（集合元素数量 $\\le 30$），求出此集合所有子集元素之和。\n", "inputFormat": "集合中的元素（元素 $\\le 1000$）\n", "outputFormat": "$s$ 所有子集元素之和。", "hint": "**【样例解释】**\n\n子集为：$\\varnothing, \\{ 2 \\}, \\{ 3 \\}, \\{ 2, 3 \\}$，和为 $2 + 3 + 2 + 3 = 10$。\n\n----\n\n**【数据范围】**\n\n对于 $100 \\%$ 的数据，$1 \\le \\lvert s \\rvert \\le 30$，$1 \\le s_i \\le 1000$，$s$ 所有子集元素之和 $\\le {10}^{18}$。", "locale": "zh-CN", "translations": {"en": {"title": "Set Summation", "background": "", "description": "Given a set $s$ (the number of elements $\\le 30$), compute the sum of elements over all subsets of this set.", "inputFormat": "The elements in the set (each element $\\le 1000$).", "outputFormat": "The sum of elements over all subsets of $s$.", "hint": "**[Sample Explanation]**\n\nThe subsets are: $\\varnothing, \\{ 2 \\}, \\{ 3 \\}, \\{ 2, 3 \\}$, and the total is $2 + 3 + 2 + 3 = 10$.\n\n----\n\n**[Constraints]**\n\nFor $100\\%$ of the testdata, $1 \\le \\lvert s \\rvert \\le 30$, $1 \\le s_i \\le 1000$, and the sum of elements over all subsets of $s$ is $\\le {10}^{18}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "集合求和", "background": "", "description": "给定一个集合 $s$（集合元素数量 $\\le 30$），求出此集合所有子集元素之和。\n", "inputFormat": "集合中的元素（元素 $\\le 1000$）\n", "outputFormat": "$s$ 所有子集元素之和。", "hint": "**【样例解释】**\n\n子集为：$\\varnothing, \\{ 2 \\}, \\{ 3 \\}, \\{ 2, 3 \\}$，和为 $2 + 3 + 2 + 3 = 10$。\n\n----\n\n**【数据范围】**\n\n对于 $100 \\%$ 的数据，$1 \\le \\lvert s \\rvert \\le 30$，$1 \\le s_i \\le 1000$，$s$ 所有子集元素之和 $\\le {10}^{18}$。", "locale": "zh-CN"}}}
