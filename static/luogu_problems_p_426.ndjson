{"pid": "P9639", "type": "P", "difficulty": 5, "samples": [["4 3\n1 5 7 3\n1\n", "12\n13\n13\n"], ["5 5\n7 7 7 7 6\n1", "9\n9\n9\n9\n9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "树状数组", "O2优化"], "title": "「yyOI R1」youyou 的序列", "background": "", "description": "给定一个长度为 $n$ 的序列 $a_{1\\dots n}$，以及 $q$ 次操作。\n\n定义一次操作为：交换 $a_k$ 与 $a_{k+1}$ 的值，并**立即**询问所有以 $a_i \\;( i\\in [1,n])$ 为峰的[子序列](https://oi-wiki.org/string/basic/#%E5%AD%90%E5%BA%8F%E5%88%97)数量之和，对 $4294967296$ 取模。**这里的交换是暂时的，也就是说，它仅在下一次操作前有效。**\n\n在此我们认为，一个长度至少为 $1$ 的序列 $[a_1,a_2 ,\\cdots,a_{s-1},a_s,a_{s+1},\\cdots,a_{n-1},a_n ]$，满足 $a_1<a_2<\\cdots<a_{s-1}<a_s>a_{s+1}>\\cdots >a_{n-1}>a_n$，则称此序列为以 $a_s$ 为峰的序列。\n\n你的任务是回答出所有操作的答案。\n", "inputFormat": "第一行输入两个整数 $n,q$。\n\n第二行输入 $n$ 个正整数，表示一开始的序列 $a_{1\\dots n}$。\n\n第三行，输入一个整数 $k$，表示进行第一次操作（定义见上），保证 $1\\le k <n$。\n\n---\n\n第 $2$ 到第 $q$ 次操作的 $k$ 值由如下方法得到：\n\n```cpp\nint Answer(unsigned int ans)\n{\n    unsigned int BASE=998244353ll*ans+ans*ans+ans/9991+ans%2159;\n    BASE^=9810;\n    BASE^=51971;\n    BASE=BASE>>7;\n    BASE=BASE<<11;\n    BASE^=751669;\n    BASE^=23465695622566ll;\n    return BASE%(n-1)+1;\n}\n```\n当你每完成一次询问后，将你这次询问的答案 $ans$ 作为参数，**恰好**调用一次 `Answer(ans)` 。\n\n得到的返回值即为下一次操作的 $k$。\n\n**注意：本输入方式仅用于减少输入量，标准算法不依赖于此输入方式。**", "outputFormat": "你需要输出所有操作的答案，每个答案输出一行。", "hint": "### 样例解释 #1\n\n第一次操作的 $k$ 为 $1$。\n\n此时序列为 $[5,1,7,3]$。\n\n峰为 $a_1$：$[5]$，$[5,1]$，$[5,3]$。\n\n峰为 $a_2$：$[1]$。\n\n峰为 $a_3$：$[7]$，$[5,7]$，$[1,7]$，$[7,3]$，$[5,7,3]$，$[1,7,3]$。\n\n峰为 $a_4$：$[3]$，$[1,3]$。\n\n共计 $12$ 个不同的子序列，答案输出 $12$。\n\n第二次和第三次操作的 $k$ 均为 $3$ ，此时有 $13$ 个不同的序列满足条件。\n\n### 样例解释 #2\n\n第一次操作的 $k$ 为 $1$。\n\n此时序列为 $[7,7,7,7,6]$。\n\n峰为 $a_1$：$[7]$，$[7,6]$。\n\n峰为 $a_2$：$[7]$，$[7,6]$。\n\n峰为 $a_3$：$[7]$，$[7,6]$。\n\n峰为 $a_4$：$[7]$，$[7,6]$。\n\n峰为 $a_5$：$[6]$。\n\n共计 $9$ 个不同的子序列，答案输出 $9$。\n\n后四次操作同理。\n\n---\n\n### 数据范围\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | $n$ | $q$ | 分数 |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| $1$ | $\\le 500$ | $\\le 100 $ |$10$ |\n| $2$ | $\\le2\\times10^3$|$ \\le 5\\times10^3$ | $20$ |\n| $3$ | $\\le3\\times10^4$ |$\\le 10^4$ | $30$ |\n| $4$ | $\\le10^6$|$ \\le10^6$ | $40$ |\n\n对于 $100\\%$ 的数据，$2\\le n\\le10^6$，$1\\le q\\le10^6$，$1\\le a_i\\le10^4$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「yyOI R1」youyou 的序列", "background": "", "description": "给定一个长度为 $n$ 的序列 $a_{1\\dots n}$，以及 $q$ 次操作。\n\n定义一次操作为：交换 $a_k$ 与 $a_{k+1}$ 的值，并**立即**询问所有以 $a_i \\;( i\\in [1,n])$ 为峰的[子序列](https://oi-wiki.org/string/basic/#%E5%AD%90%E5%BA%8F%E5%88%97)数量之和，对 $4294967296$ 取模。**这里的交换是暂时的，也就是说，它仅在下一次操作前有效。**\n\n在此我们认为，一个长度至少为 $1$ 的序列 $[a_1,a_2 ,\\cdots,a_{s-1},a_s,a_{s+1},\\cdots,a_{n-1},a_n ]$，满足 $a_1<a_2<\\cdots<a_{s-1}<a_s>a_{s+1}>\\cdots >a_{n-1}>a_n$，则称此序列为以 $a_s$ 为峰的序列。\n\n你的任务是回答出所有操作的答案。\n", "inputFormat": "第一行输入两个整数 $n,q$。\n\n第二行输入 $n$ 个正整数，表示一开始的序列 $a_{1\\dots n}$。\n\n第三行，输入一个整数 $k$，表示进行第一次操作（定义见上），保证 $1\\le k <n$。\n\n---\n\n第 $2$ 到第 $q$ 次操作的 $k$ 值由如下方法得到：\n\n```cpp\nint Answer(unsigned int ans)\n{\n    unsigned int BASE=998244353ll*ans+ans*ans+ans/9991+ans%2159;\n    BASE^=9810;\n    BASE^=51971;\n    BASE=BASE>>7;\n    BASE=BASE<<11;\n    BASE^=751669;\n    BASE^=23465695622566ll;\n    return BASE%(n-1)+1;\n}\n```\n当你每完成一次询问后，将你这次询问的答案 $ans$ 作为参数，**恰好**调用一次 `Answer(ans)` 。\n\n得到的返回值即为下一次操作的 $k$。\n\n**注意：本输入方式仅用于减少输入量，标准算法不依赖于此输入方式。**", "outputFormat": "你需要输出所有操作的答案，每个答案输出一行。", "hint": "### 样例解释 #1\n\n第一次操作的 $k$ 为 $1$。\n\n此时序列为 $[5,1,7,3]$。\n\n峰为 $a_1$：$[5]$，$[5,1]$，$[5,3]$。\n\n峰为 $a_2$：$[1]$。\n\n峰为 $a_3$：$[7]$，$[5,7]$，$[1,7]$，$[7,3]$，$[5,7,3]$，$[1,7,3]$。\n\n峰为 $a_4$：$[3]$，$[1,3]$。\n\n共计 $12$ 个不同的子序列，答案输出 $12$。\n\n第二次和第三次操作的 $k$ 均为 $3$ ，此时有 $13$ 个不同的序列满足条件。\n\n### 样例解释 #2\n\n第一次操作的 $k$ 为 $1$。\n\n此时序列为 $[7,7,7,7,6]$。\n\n峰为 $a_1$：$[7]$，$[7,6]$。\n\n峰为 $a_2$：$[7]$，$[7,6]$。\n\n峰为 $a_3$：$[7]$，$[7,6]$。\n\n峰为 $a_4$：$[7]$，$[7,6]$。\n\n峰为 $a_5$：$[6]$。\n\n共计 $9$ 个不同的子序列，答案输出 $9$。\n\n后四次操作同理。\n\n---\n\n### 数据范围\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | $n$ | $q$ | 分数 |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| $1$ | $\\le 500$ | $\\le 100 $ |$10$ |\n| $2$ | $\\le2\\times10^3$|$ \\le 5\\times10^3$ | $20$ |\n| $3$ | $\\le3\\times10^4$ |$\\le 10^4$ | $30$ |\n| $4$ | $\\le10^6$|$ \\le10^6$ | $40$ |\n\n对于 $100\\%$ 的数据，$2\\le n\\le10^6$，$1\\le q\\le10^6$，$1\\le a_i\\le10^4$。\n", "locale": "zh-CN"}}}
{"pid": "P9640", "type": "P", "difficulty": 5, "samples": [["5\n9\n99\n999\n99999\n999999", "45\n615\n6570\n597600\n5689830"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "O2优化", "数位 DP", "陕西", "省赛/邀请赛"], "title": "[SNCPC2019] Digit Mode", "background": "", "description": "Let $m(x)$ be the $\\textit{mode}$ of the digits in decimal representation of positive integer $x$. The mode is the largest value that occurs most frequently in the sequence. For example, $m(15532)=5$, $m(25252)=2$, $m(103000)=0$, $m(364364)=6$, $m(114514)=1$, $m(889464)=8$.\n\nGiven a positive integer $n$, DreamGrid would like to know the value of $(\\sum\\limits_{x=1}^{n} m(x)) \\bmod (10^9+7)$.\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains a positive integer $n$ ($1 \\le n < 10^{50}$) without leading zeros.\n\nIt's guaranteed that the sum of $|n|$ of all test cases will not exceed $50$, where $|n|$ indicates the number of digits of $n$ in decimal representation.", "outputFormat": "For each test case output one line containing one integer, indicating the value of $(\\sum\\limits_{x=1}^{n} m(x)) \\bmod (10^9+7)$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[SNCPC2019] Digit Mode", "background": "", "description": "Let $m(x)$ be the $\\textit{mode}$ of the digits in decimal representation of positive integer $x$. The mode is the largest value that occurs most frequently in the sequence. For example, $m(15532)=5$, $m(25252)=2$, $m(103000)=0$, $m(364364)=6$, $m(114514)=1$, $m(889464)=8$.\n\nGiven a positive integer $n$, DreamGrid would like to know the value of $(\\sum\\limits_{x=1}^{n} m(x)) \\bmod (10^9+7)$.\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains a positive integer $n$ ($1 \\le n < 10^{50}$) without leading zeros.\n\nIt's guaranteed that the sum of $|n|$ of all test cases will not exceed $50$, where $|n|$ indicates the number of digits of $n$ in decimal representation.", "outputFormat": "For each test case output one line containing one integer, indicating the value of $(\\sum\\limits_{x=1}^{n} m(x)) \\bmod (10^9+7)$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[SNCPC2019] Digit Mode", "background": "", "description": "设 $m(x)$ 为正整数 $x$ 的十进制表示中数字的众数。众数是序列中出现频率最高的最大值。例如，$m(15532)=5$，$m(25252)=2$，$m(103000)=0$，$m(364364)=6$，$m(114514)=1$，$m(889464)=8$。\n\n给定一个正整数 $n$，DreamGrid 想知道 $(\\sum\\limits_{x=1}^{n} m(x)) \\bmod (10^9+7)$ 的值。", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行包含一个正整数 $n$ ($1 \\le n < 10^{50}$)，没有前导零。\n\n保证所有测试用例的 $|n|$ 的总和不超过 $50$，其中 $|n|$ 表示 $n$ 的十进制表示中的数字个数。", "outputFormat": "对于每个测试用例，输出一行包含一个整数，表示 $(\\sum\\limits_{x=1}^{n} m(x)) \\bmod (10^9+7)$ 的值。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9641", "type": "P", "difficulty": 3, "samples": [["2\n2 3\nrdd\nurl\n2 1 1\n1 1 2\n2 2\nrr\nrr\n1 1\n1 1", "Yes\nNo"]], "limits": {"time": [2000, 2000], "memory": [262144, 262144]}, "tags": ["2019", "并查集", "O2优化", "陕西", "省赛/邀请赛"], "title": "[SNCPC2019] Grid with Arrows", "background": "", "description": "BaoBao has just found a grid with $n$ rows and $m$ columns in his left pocket, where the cell in the $j$-th column of the $i$-th row (indicated by $(i, j)$) contains an arrow (pointing either upwards, downwards, leftwards or rightwards) and an integer $a_{i, j}$.\n\nBaoBao decides to play a game with the grid. He will first select a cell as the initial cell and tick it. After ticking a cell (let's say BaoBao has just ticked cell $(i, j)$), BaoBao will go on ticking another cell according to the arrow and the integer in cell $(i, j)$.\n\n- If the arrow in cell $(i, j)$ points upwards, BaoBao will go on ticking cell $(i-a_{i, j}, j)$ if it exists.\n- If the arrow in cell $(i, j)$ points downwards, BaoBao will go on ticking cell $(i+a_{i, j}, j)$ if it exists.\n- If the arrow in cell $(i, j)$ points leftwards, BaoBao will go on ticking cell $(i, j-a_{i, j})$ if it exists.\n- If the arrow in cell $(i, j)$ points rightwards, BaoBao will go on ticking cell $(i, j+a_{i, j})$ if it exists.\n\nIf the cell BaoBao decides to tick does not exist, or if the cell is already ticked, the game ends.\n\nBaoBao is wondering if he can select a proper initial cell, so that he can tick every cell in the grid exactly once before the game ends. Please help him find the answer.\n", "inputFormat": "There are multiple test cases. The first line contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n \\times m \\le 10^5$), indicating the number of rows and columns of the grid.\n\nFor the following $n$ lines, the $i$-th line contains a string $s_i$ consisting of lowercased English letters ($|s_i| = m$, $s_{i, j} \\in \\{\\text{`u' (ascii: 117)}, \\text{`d' (ascii: 100)}, \\text{`l' (ascii: 108)}, \\text{`r'(ascii: 114)}\\}$), where $s_{i, j}$ indicates the direction of arrow in cell $(i, j)$.\n\n- If $s_{i, j} = \\text{`u'}$, the arrow in cell $(i, j)$ points upwards.\n- If $s_{i, j} = \\text{`d'}$, the arrow in cell $(i, j)$ points downwards.\n- If $s_{i, j} = \\text{`l'}$, the arrow in cell $(i, j)$ points leftwards.\n- If $s_{i, j} = \\text{`r'}$, the arrow in cell $(i, j)$ points rightwards.\n\nFor the following $n$ lines, the $i$-th line contains $m$ integers $a_{i, 1}, a_{i, 2}, \\dots, a_{i, m}$ ($1 \\le a_{i, j} \\le \\max(n, m)$), where $a_{i, j}$ indicates the integer in cell $(i, j)$.\n\nIt's guaranteed that the sum of $n \\times m$ of all test cases does not exceed $10^6$.", "outputFormat": "For each test case output one line. If BaoBao can find a proper initial cell, print ``Yes`` (without quotes), otherwise print ``No`` (without quotes).\n", "hint": "For the first sample test case, BaoBao can select cell $(1, 2)$ as the initial cell, so that he can tick all the cells exactly once in the following order: $(1, 2), (2, 2), (2, 3), (2, 1), (1, 1), (1, 3)$.\n\nFor the second sample test case, BaoBao can only tick at most $2$ cells no matter which cell is selected as the initial cell.\n", "locale": "en", "translations": {"en": {"title": "[SNCPC2019] Grid with Arrows", "background": "", "description": "BaoBao has just found a grid with $n$ rows and $m$ columns in his left pocket, where the cell in the $j$-th column of the $i$-th row (indicated by $(i, j)$) contains an arrow (pointing either upwards, downwards, leftwards or rightwards) and an integer $a_{i, j}$.\n\nBaoBao decides to play a game with the grid. He will first select a cell as the initial cell and tick it. After ticking a cell (let's say BaoBao has just ticked cell $(i, j)$), BaoBao will go on ticking another cell according to the arrow and the integer in cell $(i, j)$.\n\n- If the arrow in cell $(i, j)$ points upwards, BaoBao will go on ticking cell $(i-a_{i, j}, j)$ if it exists.\n- If the arrow in cell $(i, j)$ points downwards, BaoBao will go on ticking cell $(i+a_{i, j}, j)$ if it exists.\n- If the arrow in cell $(i, j)$ points leftwards, BaoBao will go on ticking cell $(i, j-a_{i, j})$ if it exists.\n- If the arrow in cell $(i, j)$ points rightwards, BaoBao will go on ticking cell $(i, j+a_{i, j})$ if it exists.\n\nIf the cell BaoBao decides to tick does not exist, or if the cell is already ticked, the game ends.\n\nBaoBao is wondering if he can select a proper initial cell, so that he can tick every cell in the grid exactly once before the game ends. Please help him find the answer.\n", "inputFormat": "There are multiple test cases. The first line contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n \\times m \\le 10^5$), indicating the number of rows and columns of the grid.\n\nFor the following $n$ lines, the $i$-th line contains a string $s_i$ consisting of lowercased English letters ($|s_i| = m$, $s_{i, j} \\in \\{\\text{`u' (ascii: 117)}, \\text{`d' (ascii: 100)}, \\text{`l' (ascii: 108)}, \\text{`r'(ascii: 114)}\\}$), where $s_{i, j}$ indicates the direction of arrow in cell $(i, j)$.\n\n- If $s_{i, j} = \\text{`u'}$, the arrow in cell $(i, j)$ points upwards.\n- If $s_{i, j} = \\text{`d'}$, the arrow in cell $(i, j)$ points downwards.\n- If $s_{i, j} = \\text{`l'}$, the arrow in cell $(i, j)$ points leftwards.\n- If $s_{i, j} = \\text{`r'}$, the arrow in cell $(i, j)$ points rightwards.\n\nFor the following $n$ lines, the $i$-th line contains $m$ integers $a_{i, 1}, a_{i, 2}, \\dots, a_{i, m}$ ($1 \\le a_{i, j} \\le \\max(n, m)$), where $a_{i, j}$ indicates the integer in cell $(i, j)$.\n\nIt's guaranteed that the sum of $n \\times m$ of all test cases does not exceed $10^6$.", "outputFormat": "For each test case output one line. If BaoBao can find a proper initial cell, print ``Yes`` (without quotes), otherwise print ``No`` (without quotes).\n", "hint": "For the first sample test case, BaoBao can select cell $(1, 2)$ as the initial cell, so that he can tick all the cells exactly once in the following order: $(1, 2), (2, 2), (2, 3), (2, 1), (1, 1), (1, 3)$.\n\nFor the second sample test case, BaoBao can only tick at most $2$ cells no matter which cell is selected as the initial cell.\n", "locale": "en"}, "zh-CN": {"title": "[SNCPC2019] Grid with Arrows", "background": "", "description": "宝宝刚刚在他的左口袋里发现了一个 $n$ 行 $m$ 列的网格，其中第 $i$ 行第 $j$ 列的单元格（表示为 $(i, j)$）包含一个箭头（指向上、下、左或右）和一个整数 $a_{i, j}$。\n\n宝宝决定用这个网格玩一个游戏。他首先会选择一个单元格作为初始单元格并标记它。在标记一个单元格之后（假设宝宝刚刚标记了单元格 $(i, j)$），宝宝将根据单元格 $(i, j)$ 中的箭头和整数继续标记另一个单元格。\n\n- 如果单元格 $(i, j)$ 中的箭头指向上方，宝宝将继续标记单元格 $(i-a_{i, j}, j)$，如果该单元格存在的话。\n- 如果单元格 $(i, j)$ 中的箭头指向下方，宝宝将继续标记单元格 $(i+a_{i, j}, j)$，如果该单元格存在的话。\n- 如果单元格 $(i, j)$ 中的箭头指向左方，宝宝将继续标记单元格 $(i, j-a_{i, j})$，如果该单元格存在的话。\n- 如果单元格 $(i, j)$ 中的箭头指向右方，宝宝将继续标记单元格 $(i, j+a_{i, j})$，如果该单元格存在的话。\n如果宝宝决定标记的单元格不存在，或者该单元格已经被标记，游戏结束。\n\n宝宝想知道他是否可以选择一个合适的初始单元格，以便在游戏结束前恰好标记网格中的每一个单元格一次。请帮助他找到答案。", "inputFormat": "有多个测试用例。第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行包含两个整数 $n$ 和 $m$ ($1 \\le n \\times m \\le 10^5$)，表示网格的行数和列数。\n\n接下来的 $n$ 行中，第 $i$ 行包含一个字符串 $s_i$，由小写英文字母组成（$|s_i| = m$，$s_{i, j} \\in \\{\\text{`u' (ascii: 117)}, \\text{`d' (ascii: 100)}, \\text{`l' (ascii: 108)}, \\text{`r'(ascii: 114)}\\}$），其中 $s_{i, j}$ 表示单元格 $(i, j)$ 中箭头的方向。\n\n- 如果 $s_{i, j} = \\text{`u'}$，单元格 $(i, j)$ 中的箭头指向上方。\n- 如果 $s_{i, j} = \\text{`d'}$，单元格 $(i, j)$ 中的箭头指向下方。\n- 如果 $s_{i, j} = \\text{`l'}$，单元格 $(i, j)$ 中的箭头指向左方。\n- 如果 $s_{i, j} = \\text{`r'}$，单元格 $(i, j)$ 中的箭头指向右方。\n\n接下来的 $n$ 行中，第 $i$ 行包含 $m$ 个整数 $a_{i, 1}, a_{i, 2}, \\dots, a_{i, m}$ ($1 \\le a_{i, j} \\le \\max(n, m)$)，其中 $a_{i, j}$ 表示单元格 $(i, j)$ 中的整数。\n\n保证所有测试用例的 $n \\times m$ 之和不超过 $10^6$。", "outputFormat": "对于每个测试用例输出一行。如果宝宝可以找到一个合适的初始单元格，输出 “Yes”（不含引号），否则输出 “No”（不含引号）。\n\n**【样例解释】**\n\n对于第一个示例测试用例，宝宝可以选择单元格 $(1, 2)$ 作为初始单元格，这样他可以按以下顺序恰好打勾所有单元格：$(1, 2), (2, 2), (2, 3), (2, 1), (1, 1), (1, 3)$。\n\n对于第二个示例测试用例，无论选择哪个单元格作为初始单元格，宝宝最多只能打勾 2 个单元格。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9642", "type": "P", "difficulty": 3, "samples": [["2\n0689\n08", "8\n2"]], "limits": {"time": [2000, 2000], "memory": [262144, 262144]}, "tags": ["2019", "O2优化", "陕西", "前缀和", "省赛/邀请赛"], "title": "[SNCPC2019] 0689", "background": "", "description": "We call a string as a 0689-string if this string only consists of digits `0`, `6`, `8` and `9`. Given a 0689-string $s$ of length $n$, one $\\textbf{must}$ do the following operation exactly once: select a non-empty substring of $s$ and rotate it 180 degrees.\n\nMore formally, let $s_i$ be the $i$-th character in string $s$. After rotating the substring starting from $s_l$ and ending at $s_r$ 180 degrees ($1 \\le l \\le r \\le n$), string $s$ will become string $t$ of length $n$ extracted from the following equation, where $t_i$ indicates the $i$-th character in string $t$:\n\n$$t_i = \\begin{cases}\ns_i & \\text{if } 1 \\le i < l \\text{ or } r < i \\le n \\\\\n\\text{`0'} & \\text{if } l \\le i \\le r \\text{ and } s_{l+r-i} = \\text{`0'} \\\\\n\\text{`6'} & \\text{if } l \\le i \\le r \\text{ and } s_{l+r-i} = \\text{`9'} \\\\\n\\text{`8'} & \\text{if } l \\le i \\le r \\text{ and } s_{l+r-i} = \\text{`8'} \\\\\n\\text{`9'} & \\text{if } l \\le i \\le r \\text{ and } s_{l+r-i} = \\text{`6'} \\\\\n\\end{cases}$$\n\nWhat's the number of different strings one can get after the operation?", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first and only line contains a 0689-string $s$ ($1 \\le |s| \\le 10^6$).\n\nIt's guaranteed that the sum of $|s|$ of all test cases will not exceed $10^7$.\n", "outputFormat": "For each test case output one line containing one integer, indicating the number of different strings one can get after applying the operation exactly once.", "hint": "We hereby explain the first sample test case.\n\n$$\\begin{array}{|c|c||c|c|}\\hline \\textbf{Substring} & \\textbf{Result} & \\textbf{Substring} & \\textbf{Result} \\\\ \\hline 0 & 0689 & 68 & 0899 \\\\ \\hline 6 & 0989 & 89 & 0668 \\\\ \\hline 8 & 0689 & 068 & 8909 \\\\ \\hline 9 & 0686 & 689 & 0689 \\\\ \\hline 06 & 9089 & 0689 & 6890 \\\\ \\hline \\end{array}$$\n\nIt's easy to discover that we can get $8$ different strings after the operation.", "locale": "en", "translations": {"en": {"title": "[SNCPC2019] 0689", "background": "", "description": "We call a string as a 0689-string if this string only consists of digits `0`, `6`, `8` and `9`. Given a 0689-string $s$ of length $n$, one $\\textbf{must}$ do the following operation exactly once: select a non-empty substring of $s$ and rotate it 180 degrees.\n\nMore formally, let $s_i$ be the $i$-th character in string $s$. After rotating the substring starting from $s_l$ and ending at $s_r$ 180 degrees ($1 \\le l \\le r \\le n$), string $s$ will become string $t$ of length $n$ extracted from the following equation, where $t_i$ indicates the $i$-th character in string $t$:\n\n$$t_i = \\begin{cases}\ns_i & \\text{if } 1 \\le i < l \\text{ or } r < i \\le n \\\\\n\\text{`0'} & \\text{if } l \\le i \\le r \\text{ and } s_{l+r-i} = \\text{`0'} \\\\\n\\text{`6'} & \\text{if } l \\le i \\le r \\text{ and } s_{l+r-i} = \\text{`9'} \\\\\n\\text{`8'} & \\text{if } l \\le i \\le r \\text{ and } s_{l+r-i} = \\text{`8'} \\\\\n\\text{`9'} & \\text{if } l \\le i \\le r \\text{ and } s_{l+r-i} = \\text{`6'} \\\\\n\\end{cases}$$\n\nWhat's the number of different strings one can get after the operation?", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first and only line contains a 0689-string $s$ ($1 \\le |s| \\le 10^6$).\n\nIt's guaranteed that the sum of $|s|$ of all test cases will not exceed $10^7$.\n", "outputFormat": "For each test case output one line containing one integer, indicating the number of different strings one can get after applying the operation exactly once.", "hint": "We hereby explain the first sample test case.\n\n$$\\begin{array}{|c|c||c|c|}\\hline \\textbf{Substring} & \\textbf{Result} & \\textbf{Substring} & \\textbf{Result} \\\\ \\hline 0 & 0689 & 68 & 0899 \\\\ \\hline 6 & 0989 & 89 & 0668 \\\\ \\hline 8 & 0689 & 068 & 8909 \\\\ \\hline 9 & 0686 & 689 & 0689 \\\\ \\hline 06 & 9089 & 0689 & 6890 \\\\ \\hline \\end{array}$$\n\nIt's easy to discover that we can get $8$ different strings after the operation.", "locale": "en"}, "zh-CN": {"title": "[SNCPC2019] 0689", "background": "", "description": "我们称一个字符串为 0689-字符串，如果这个字符串只包含数字 0、6、8 和 9。给定一个长度为 $n$ 的 0689-字符串 $s$，必须执行以下操作一次：选择 $s$ 的一个非空子串并将其旋转 180 度。\n\n更正式地说，设 $s_i$ 为字符串 $s$ 的第 $i$ 个字符。在将从 $s_l$ 开始到 $s_r$ 结束的子串旋转180度后 ($1 \\le l \\le r \\le n$)，字符串 $s$ 将变成长度为 $n$ 的字符串 $t$，其通过以下公式得到，其中 $t_i$ 表示字符串 $t$ 中的第 $i$ 个字符：\n\n$$t_i = \\begin{cases}\ns_i & \\text{if } 1 \\le i < l \\text{ or } r < i \\le n \\\\\n\\text{`0'} & \\text{if } l \\le i \\le r \\text{ and } s_{l+r-i} = \\text{`0'} \\\\\n\\text{`6'} & \\text{if } l \\le i \\le r \\text{ and } s_{l+r-i} = \\text{`9'} \\\\\n\\text{`8'} & \\text{if } l \\le i \\le r \\text{ and } s_{l+r-i} = \\text{`8'} \\\\\n\\text{`9'} & \\text{if } l \\le i \\le r \\text{ and } s_{l+r-i} = \\text{`6'} \\\\\n\\end{cases}$$\n\n经过这个操作后，可以得到多少个不同的字符串？", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n- 第一行且唯一一行包含一个 0689-字符串 $s$ ($1 \\le |s| \\le 10^6$)。\n保证所有测试用例的 $|s|$ 之和不超过 $10^7$。", "outputFormat": "对于每个测试用例输出一行，包含一个整数，表示经过一次操作可以得到的不同字符串的数量。\n\n**【样例解释】**\n\n我们在此解释第一个样例测试用例。\n$$\\begin{array}{|c|c||c|c|}\\hline \\textbf{子串} & \\textbf{结果} & \\textbf{子串} & \\textbf{结果} \\\\ \\hline 0 & 0689 & 68 & 0899 \\\\ \\hline 6 & 0989 & 89 & 0668 \\\\ \\hline 8 & 0689 & 068 & 8909 \\\\ \\hline 9 & 0686 & 689 & 0689 \\\\ \\hline 06 & 9089 & 0689 & 6890 \\\\ \\hline \\end{array}$$\n很容易发现，经过这个操作可以得到 8 个不同的字符串。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9643", "type": "P", "difficulty": 5, "samples": [["3\n1 2\n0 2 1 0 2 2\n1 3\n1 1 0 1 3 1\n1 2\n0 0 100 100 1 1", "1.500000000000000\n1.000000000000000\n2.000000000000000"]], "limits": {"time": [2000, 2000], "memory": [262144, 262144]}, "tags": ["2019", "Special Judge", "O2优化", "陕西", "Ad-hoc", "省赛/邀请赛"], "title": "[SNCPC2019] Pick Up", "background": "", "description": "Grid City is a city on an infinite two-dimensional plane, where for all $k \\in \\mathbb{Z}$ ($\\mathbb{Z}$ is the set of all integers) lines $x = k$ and $y = k$ are the streets of the city. People can only move along the roads to go from one position to another. That's why the city is called the Grid City!\n\nTwo friends, BaoBao and DreamGrid, live happily in the city. Today BaoBao is heading from his home positioned at $(x_A, y_A)$ ($x_A, y_A \\in \\mathbb{Z}$) towards the shopping mall positioned at $(x_C, y_C)$ ($x_C, y_C \\in \\mathbb{Z}$). However, it's too far for him to walk there, so he decides to call DreamGrid whose home is positioned at $(x_B, y_B)$ ($x_B, y_B \\in \\mathbb{Z}$) for help.\n\nBaoBao and DreamGrid set out separately from their homes at the same time. Different from BaoBao who walks at a speed of $a$ units per minute, DreamGrid drives a car and moves at a speed of $b$ units per minute. When DreamGrid and BaoBao meet at the same point, DreamGrid can pick up BaoBao and they can then move at a speed of $b$ units per minute together. It takes no time to turn around or pick up BaoBao.\n\nWhat's the minimum time needed for BaoBao to go from his home to the shopping mall? Note that it's NOT necessary for DreamGrid to pick up BaoBao if it will be faster for BaoBao to get to the destination.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$($ 1 \\le T \\le 10^5$), indicating the number of test cases. For each test case:\n\nThe first line contains two integers $a$ and $b$ ($1 \\le a < b \\le 10^9$), indicating the walking speed of BaoBao and the driving speed of DreamGrid.\n\nThe second line contains six integers $x_A$, $y_A$, $x_B$, $y_B$, $x_C$ and $y_C$ ($-10^9 \\le x_A, y_A, x_B, y_B, x_C, y_C \\le 10^9$), indicating the position of BaoBao's home, DreamGrid's home and the shopping mall. It's guaranteed that these three points are different from each other.", "outputFormat": "For each test case output one line containing one number, indicating the shortest time for BaoBao to arrive at the shopping mall. Your answer will be considered correct if its absolute or relative error does not exceed $10^{-6}$.", "hint": "For the first sample test case, BaoBao and DreamGrid will meet at $D(1,2)$ and then DreamGrid drives BaoBao to the shopping mall.\n\nFor the second sample test case, BaoBao and DreamGrid will meet at $D(1.5,1)$ and then DreamGrid drives BaoBao to the shopping mall.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wexb0vmz.png)", "locale": "en", "translations": {"en": {"title": "[SNCPC2019] Pick Up", "background": "", "description": "Grid City is a city on an infinite two-dimensional plane, where for all $k \\in \\mathbb{Z}$ ($\\mathbb{Z}$ is the set of all integers) lines $x = k$ and $y = k$ are the streets of the city. People can only move along the roads to go from one position to another. That's why the city is called the Grid City!\n\nTwo friends, BaoBao and DreamGrid, live happily in the city. Today BaoBao is heading from his home positioned at $(x_A, y_A)$ ($x_A, y_A \\in \\mathbb{Z}$) towards the shopping mall positioned at $(x_C, y_C)$ ($x_C, y_C \\in \\mathbb{Z}$). However, it's too far for him to walk there, so he decides to call DreamGrid whose home is positioned at $(x_B, y_B)$ ($x_B, y_B \\in \\mathbb{Z}$) for help.\n\nBaoBao and DreamGrid set out separately from their homes at the same time. Different from BaoBao who walks at a speed of $a$ units per minute, DreamGrid drives a car and moves at a speed of $b$ units per minute. When DreamGrid and BaoBao meet at the same point, DreamGrid can pick up BaoBao and they can then move at a speed of $b$ units per minute together. It takes no time to turn around or pick up BaoBao.\n\nWhat's the minimum time needed for BaoBao to go from his home to the shopping mall? Note that it's NOT necessary for DreamGrid to pick up BaoBao if it will be faster for BaoBao to get to the destination.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$($ 1 \\le T \\le 10^5$), indicating the number of test cases. For each test case:\n\nThe first line contains two integers $a$ and $b$ ($1 \\le a < b \\le 10^9$), indicating the walking speed of BaoBao and the driving speed of DreamGrid.\n\nThe second line contains six integers $x_A$, $y_A$, $x_B$, $y_B$, $x_C$ and $y_C$ ($-10^9 \\le x_A, y_A, x_B, y_B, x_C, y_C \\le 10^9$), indicating the position of BaoBao's home, DreamGrid's home and the shopping mall. It's guaranteed that these three points are different from each other.", "outputFormat": "For each test case output one line containing one number, indicating the shortest time for BaoBao to arrive at the shopping mall. Your answer will be considered correct if its absolute or relative error does not exceed $10^{-6}$.", "hint": "For the first sample test case, BaoBao and DreamGrid will meet at $D(1,2)$ and then DreamGrid drives BaoBao to the shopping mall.\n\nFor the second sample test case, BaoBao and DreamGrid will meet at $D(1.5,1)$ and then DreamGrid drives BaoBao to the shopping mall.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wexb0vmz.png)", "locale": "en"}, "zh-CN": {"title": "[SNCPC2019] Pick Up", "background": "", "description": "格子城是一个位于无限二维平面上的城市，其中对于所有 $k \\in \\mathbb{Z}$（$\\mathbb{Z}$ 是所有整数的集合），直线 $x = k$ 和 $y = k$ 是城市的街道。人们只能沿着道路从一个位置移动到另一个位置。这就是为什么这个城市被称为格子城！\n\n两个朋友，宝宝和梦想格子，快乐地生活在这个城市里。今天宝宝正从他位于 $(x_A, y_A)$（$x_A, y_A \\in \\mathbb{Z}$）的家出发，前往位于 $(x_C, y_C)$（$x_C, y_C \\in \\mathbb{Z}$）的购物中心。然而，这段路对他来说太远了，所以他决定叫住在 $(x_B, y_B)$（$x_B, y_B \\in \\mathbb{Z}$）的梦想格子来帮忙。\n\n宝宝和梦想格子同时从他们的家出发。不同于以每分钟 $a$ 个单位速度步行的宝宝，梦想格子开车并以每分钟 $b$ 个单位速度移动。当梦想格子和宝宝在同一个点相遇时，梦想格子可以接上宝宝，然后他们可以一起以每分钟 $b$ 个单位速度移动。转身或接上宝宝不需要时间。\n\n从宝宝的家到购物中心所需的最短时间是多少？请注意，如果梦想格子接上宝宝会更慢，则不需要梦想格子接宝宝。", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$（$1 \\le T \\le 10^5$），表示测试用例的数量。对于每个测试用例：\n\n第一行包含两个整数 $a$ 和 $b$（$1 \\le a < b \\le 10^9$），表示宝宝的步行速度和梦想格子的驾驶速度。\n\n第二行包含六个整数 $x_A$，$y_A$，$x_B$，$y_B$，$x_C$ 和 $y_C$（$-10^9 \\le x_A, y_A, x_B, y_B, x_C, y_C \\le 10^9$），表示宝宝的家、梦想格子的家和购物中心的位置。保证这三点互不相同。", "outputFormat": "对于每个测试用例，输出一行，包含一个数字，表示宝宝到达购物中心的最短时间。如果你的答案的绝对误差或相对误差不超过 $10^{-6}$，则将被视为正确。\n\n**【样例解释】**\n\n对于第一个样例测试用例，宝宝和梦想格子将在 $D(1,2)$ 相遇，然后梦想格子载着宝宝去购物中心。\n\n对于第二个样例测试用例，宝宝和梦想格子将在 $D(1.5,1)$ 相遇，然后梦想格子载着宝宝去购物中心。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9644", "type": "P", "difficulty": 2, "samples": [["2\n10 4\n0101011111\n3 1\n010", "3\n1"]], "limits": {"time": [1000, 1000], "memory": [262144, 262144]}, "tags": ["2019", "二分", "O2优化", "陕西", "省赛/邀请赛"], "title": "[SNCPC2019] Turn It Off", "background": "", "description": "It's already 21:30 now, and it's time for BaoBao to go to bed. To ensure his sleeping quality, BaoBao decides to turn all the lights in his bedroom off.\n\nThere are $n$ lights, numbered from 1 to $n$, arranged in a row in BaoBao's bedroom. Each time BaoBao can select an integer $i$ and turn all the lights numbered from $i$ to $(i+L-1)$ (both inclusive) off, where $L$ is a predefined positive integer. Note that each time the value of $L$ must be the same.\n\nGiven the initial status of all the lights, please help BaoBao determine the smallest possible $L$ so that he can turn all the lights off within $k$ times.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $k$ ($1 \\le k \\le n \\le 2 \\times 10^5$).\n\nThe second line contains a string $s$ ($|s| = n$, $s \\in \\{\\text{`0'}, \\text{`1'}\\}$) indicating the initial status of the lights. Let $s_i$ be the $i$-th character in $s$, if $s_i = \\text{`1'}$ then the $i$-th light is initially on, otherwise it's initially off. It's guaranteed that there is at least one `1· in $s$.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $2 \\times 10^6$.", "outputFormat": "For each test case output one line containing one integer, indicating the smallest possible $L$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[SNCPC2019] Turn It Off", "background": "", "description": "It's already 21:30 now, and it's time for BaoBao to go to bed. To ensure his sleeping quality, BaoBao decides to turn all the lights in his bedroom off.\n\nThere are $n$ lights, numbered from 1 to $n$, arranged in a row in BaoBao's bedroom. Each time BaoBao can select an integer $i$ and turn all the lights numbered from $i$ to $(i+L-1)$ (both inclusive) off, where $L$ is a predefined positive integer. Note that each time the value of $L$ must be the same.\n\nGiven the initial status of all the lights, please help BaoBao determine the smallest possible $L$ so that he can turn all the lights off within $k$ times.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $k$ ($1 \\le k \\le n \\le 2 \\times 10^5$).\n\nThe second line contains a string $s$ ($|s| = n$, $s \\in \\{\\text{`0'}, \\text{`1'}\\}$) indicating the initial status of the lights. Let $s_i$ be the $i$-th character in $s$, if $s_i = \\text{`1'}$ then the $i$-th light is initially on, otherwise it's initially off. It's guaranteed that there is at least one `1· in $s$.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $2 \\times 10^6$.", "outputFormat": "For each test case output one line containing one integer, indicating the smallest possible $L$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[SNCPC2019] Turn It Off", "background": null, "description": "现在已经是 21:30 了，宝宝该上床睡觉了。为了确保他的睡眠质量，宝宝决定关掉卧室里的所有灯。\n\n宝宝的卧室里有 $n$ 盏灯，从 $1$ 到 $n$ 排成一排。每次宝宝可以选择一个整数 $i$，并将从第 $i$ 盏灯到第 $(i+L-1)$ 盏灯（包括两端）之间的所有灯关掉，其中 $L$ 是一个预定义的正整数。注意，每次操作的 $L$ 值必须相同。\n\n给定所有灯的初始状态，请帮助宝宝确定可能的最小 $L$ 使得他能在 $k$ 次操作内关掉所有的灯。", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行包含两个整数 $n$ 和 $k$（$1 \\le k \\le n \\le 2 \\times 10^5$）。\n\n第二行包含一个字符串 $s$（$|s| = n$, $s \\in \\{\\text{`0'}, \\text{`1'}\\}$）表示灯的初始状态。设 $s_i$ 为字符串 $s$ 的第 $i$ 个字符，如果 $s_i = \\text{`1'}$，则第 $i$ 盏灯初始是亮的，否则是灭的。保证 $s$ 中至少有一个 `1`。\n\n保证所有测试用例的 $n$ 之和不超过 $2 \\times 10^6$。", "outputFormat": "对于每个测试用例输出一行，包含一个整数，表示可能的最小 $L$。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P9645", "type": "P", "difficulty": 1, "samples": [["4\n11 18 5\n3 49 4\n1 9 1\n1 3 10", "12\n24\n3\n-1"]], "limits": {"time": [1000, 1000], "memory": [262144, 262144]}, "tags": ["数学", "2019", "Special Judge", "O2优化", "陕西", "省赛/邀请赛"], "title": "[SNCPC2019] K-hour Clock", "background": "", "description": "A $k$-hour clock is a day keeping method which follows the rules below:\n\n- A day is divided into $k$ hours, where the $i$-th hour is called the $(i-1)$ o' clock;\n- If it's $x$ o'clock now, it will be $(x+1)$ o'clock after $1$ hour if $0 \\le x < k - 1$;\n- If it's $(k - 1)$ o'clock now, it will be $0$ o'clock after $1$ hour.\n\nWe know that it's $x$ o'clock now, and after $y$ hours it will be $z$ o'clock. What's the value of $k$?\n", "inputFormat": "There are multiple test cases. The first line of the input is an integer $T$ (about $10^5$), indicating the number of test cases. For each test case:\n\nThe first and only line contains three integers $x$, $y$ and $z$ ($0 \\le x, z \\le 10^9$, $1 \\le y \\le 10^9$).", "outputFormat": "For each test case output one line containing one integer, indicating the value of $k$. Note that there must be $1 \\le k \\le 2 \\times 10^9$. If there are multiple valid answers, you can print any of them; If there is no valid answer, print ``-1`` (without quotes) instead.", "hint": "", "locale": "en", "translations": {"en": {"title": "[SNCPC2019] K-hour Clock", "background": "", "description": "A $k$-hour clock is a day keeping method which follows the rules below:\n\n- A day is divided into $k$ hours, where the $i$-th hour is called the $(i-1)$ o' clock;\n- If it's $x$ o'clock now, it will be $(x+1)$ o'clock after $1$ hour if $0 \\le x < k - 1$;\n- If it's $(k - 1)$ o'clock now, it will be $0$ o'clock after $1$ hour.\n\nWe know that it's $x$ o'clock now, and after $y$ hours it will be $z$ o'clock. What's the value of $k$?\n", "inputFormat": "There are multiple test cases. The first line of the input is an integer $T$ (about $10^5$), indicating the number of test cases. For each test case:\n\nThe first and only line contains three integers $x$, $y$ and $z$ ($0 \\le x, z \\le 10^9$, $1 \\le y \\le 10^9$).", "outputFormat": "For each test case output one line containing one integer, indicating the value of $k$. Note that there must be $1 \\le k \\le 2 \\times 10^9$. If there are multiple valid answers, you can print any of them; If there is no valid answer, print ``-1`` (without quotes) instead.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[SNCPC2019] K-hour Clock", "background": "", "description": "一个 $k$ 小时制的时钟是一种计时方法，遵循以下规则：\n\n- 一天被分为 $k$ 小时，其中第 $i$ 小时称为 $(i-1)$ 点；\n- 如果现在是 $x$ 点，那么在 $1$ 小时后将是 $(x+1)$ 点，前提是 $0 \\le x < k - 1$；\n- 如果现在是 $(k - 1)$ 点，那么在 $1$ 小时后将是 $0$ 点。\n\n我们知道现在是 $x$ 点，经过 $y$ 小时后将是 $z$ 点。求 $k$ 的值。", "inputFormat": "有多个测试用例。输入的第一行是一个整数 $T$（约 $10^5$），表示测试用例的数量。对于每个测试用例：\n\n第一行包含三个整数 $x$、$y$ 和 $z$（$0 \\le x, z \\le 10^9$，$1 \\le y \\le 10^9$）。", "outputFormat": "对于每个测试用例输出一行，包含一个整数，表示 $k$ 的值。注意必须有 $1 \\le k \\le 2 \\times 10^9$。如果有多个有效答案，可以输出其中任意一个；如果没有有效答案，则输出 “-1”（不带引号）。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9646", "type": "P", "difficulty": 6, "samples": [["3\n2 5\n11001\n11001\n5 7\n1001100\n0110011\n0101101\n0010010\n1000000\n3 2\n11\n11\n11", "1\n4\n0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "O2优化", "陕西", "Manacher 算法", "省赛/邀请赛"], "title": "[SNCPC2019] Paper-cutting", "background": "", "description": "Paper-cutting is one of the oldest and most popular folk arts in China. It can be geographically divided into a southern and a northern style. The southern style, represented by works from Yangzhou in Jiangsu Province and Yueqing in Zhejiang Province, features ingenious and beautiful designs, exquisite carving and interesting shapes. The northern style, mainly from Yuxian and Fengning in Hebei Province and best represented by works from northern Shaanxi, features exaggerated shapes, vigorousness, vivid depictions, and diverse patterns.\n\nThere are basic cut-outs, consisting of a single image, and symmetrical designs, that are usually created by some folding over a proportioned crease, and then cutting a shape, so that when unfolded, it forms a symmetrical design. Chinese paper cuttings are usually symmetrical. The paper cutouts are usually in an even number series of $2$, $4$, $24$, etc.\n\nYou are given a piece of paper in the shape of a matrix of size $n \\times m$. It is partitioned into $n \\times m$ blocks of size $1 \\times 1$. The piece of paper can be folded in the following way:\n\n- You choose a vertical line between two of its columns or a horizontal line between two of its rows. This line splits the paper into two sides. \n- You use the line as the folding axis and fold the smaller side of the paper onto the larger one going over the axis. If both sides of the paper are of equal size, you may fold from either side.\n\nYou would like to make a paper-cutting masterpiece from this paper. At first, you fold the paper using the method above several times (including zero times). Then you use scissors to cut the paper. Each time you cut, you can cut out a connected component from the folded paper (even if the component is not reachable from outside) and throw it away. Note that two $1 \\times 1$ blocks are connected if they share an edge.\n\nGiven the final look of the paper, which is a matrix of size $n \\times m$ containing $0$s and $1$s, you would like to know the minimum number of cuts needed when using the scissors. \n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n \\times m \\le 10^6$): the size of the paper.\n\nEach of the next $n$ lines contains a binary string of length $m$, where $\\texttt{0}$ means the $1 \\times 1$ block is cut out and $\\texttt{1}$ means the $1 \\times 1$ block remains on the final paper-cutting.\n\nIt is guaranteed that the sum of $n \\times m$ over all test cases does not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer, indicating the minimum number of cuts needed.", "hint": "For the first sample test case, you can fold in the following way and cut the only $0$ out:\n$$\\begin{array}{ccc|cc} 1&1&0&0&1\\\\1&1&0&0&1\\end{array} \\to \\begin{array}{ccc} 1&1&0\\\\ \\hline 1&1&0\\end{array} \\to \\begin{array}{ccc} 1&1&0\\end{array}$$\n\nFor the second sample test case, you can fold in the following way and cut the $4$ connected components of $0$s out:\n$$\\begin{array}{cccc|ccc} 1&0&0&1&1&0&0\\\\0&1&1&0&0&1&1\\\\0&1&0&1&1&0&1\\\\0&0&1&0&0&1&0\\\\1&0&0&0&0&0&0\\end{array} \\to \\begin{array}{cccc} 1&0&0&1\\\\0&1&1&0\\\\0&1&0&1\\\\0&0&1&0\\\\1&0&0&0\\end{array}$$", "locale": "en", "translations": {"en": {"title": "[SNCPC2019] Paper-cutting", "background": "", "description": "Paper-cutting is one of the oldest and most popular folk arts in China. It can be geographically divided into a southern and a northern style. The southern style, represented by works from Yangzhou in Jiangsu Province and Yueqing in Zhejiang Province, features ingenious and beautiful designs, exquisite carving and interesting shapes. The northern style, mainly from Yuxian and Fengning in Hebei Province and best represented by works from northern Shaanxi, features exaggerated shapes, vigorousness, vivid depictions, and diverse patterns.\n\nThere are basic cut-outs, consisting of a single image, and symmetrical designs, that are usually created by some folding over a proportioned crease, and then cutting a shape, so that when unfolded, it forms a symmetrical design. Chinese paper cuttings are usually symmetrical. The paper cutouts are usually in an even number series of $2$, $4$, $24$, etc.\n\nYou are given a piece of paper in the shape of a matrix of size $n \\times m$. It is partitioned into $n \\times m$ blocks of size $1 \\times 1$. The piece of paper can be folded in the following way:\n\n- You choose a vertical line between two of its columns or a horizontal line between two of its rows. This line splits the paper into two sides. \n- You use the line as the folding axis and fold the smaller side of the paper onto the larger one going over the axis. If both sides of the paper are of equal size, you may fold from either side.\n\nYou would like to make a paper-cutting masterpiece from this paper. At first, you fold the paper using the method above several times (including zero times). Then you use scissors to cut the paper. Each time you cut, you can cut out a connected component from the folded paper (even if the component is not reachable from outside) and throw it away. Note that two $1 \\times 1$ blocks are connected if they share an edge.\n\nGiven the final look of the paper, which is a matrix of size $n \\times m$ containing $0$s and $1$s, you would like to know the minimum number of cuts needed when using the scissors. \n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n \\times m \\le 10^6$): the size of the paper.\n\nEach of the next $n$ lines contains a binary string of length $m$, where $\\texttt{0}$ means the $1 \\times 1$ block is cut out and $\\texttt{1}$ means the $1 \\times 1$ block remains on the final paper-cutting.\n\nIt is guaranteed that the sum of $n \\times m$ over all test cases does not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer, indicating the minimum number of cuts needed.", "hint": "For the first sample test case, you can fold in the following way and cut the only $0$ out:\n$$\\begin{array}{ccc|cc} 1&1&0&0&1\\\\1&1&0&0&1\\end{array} \\to \\begin{array}{ccc} 1&1&0\\\\ \\hline 1&1&0\\end{array} \\to \\begin{array}{ccc} 1&1&0\\end{array}$$\n\nFor the second sample test case, you can fold in the following way and cut the $4$ connected components of $0$s out:\n$$\\begin{array}{cccc|ccc} 1&0&0&1&1&0&0\\\\0&1&1&0&0&1&1\\\\0&1&0&1&1&0&1\\\\0&0&1&0&0&1&0\\\\1&0&0&0&0&0&0\\end{array} \\to \\begin{array}{cccc} 1&0&0&1\\\\0&1&1&0\\\\0&1&0&1\\\\0&0&1&0\\\\1&0&0&0\\end{array}$$", "locale": "en"}, "zh-CN": {"title": "[SNCPC2019] Paper-cutting", "background": "", "description": "剪纸是中国最古老、最受欢迎的民间艺术之一。它在地理上可以分为南方风格和北方风格。以江苏扬州、浙江乐清作品为代表的南方风格，设计巧妙美观，雕刻精美，造型有趣。北方风格以河北蔚县、丰宁为主体，以陕北作品为代表，造型夸张、气势恢宏、刻画生动、图案多样。\n\n基本的裁剪由单个图像组成，还有对称的设计，通常是通过在成比例的折痕上折叠，然后裁成一个形状，当展开时，就形成了对称的设计。中国剪纸通常是对称的。剪纸通常是 $2$、 $4$ 、 $24$ 等偶数系列。\n\n你会得到一张大小为 $n \\times m$ 的纸， 它被划分为 $n \\times m$ 个大小为 $1 \\times 1$ 的块在。这张纸可以按以下方式折叠：\n\n- 可以在两列之间选择一条垂直线，也可以在两行之间选择一条水平线。这条线把纸分成两面。\n\n- 你用这条线作为对称轴，把小的一面折到大的一面上。如果纸的两面大小相等，从两边对折。\n\n你想用这张纸做一幅剪纸杰作。首先，使用上述方法将纸张折叠几次（包括零次）。然后你用剪刀剪纸。每次剪切时，都可以从折叠的纸上剪切出一个连接的部分（即使从外面无法接触到该部分并将其扔掉。请注意，如果两个 $ 1\\times 1$ 的块共享一条边，则它们是连接的。\n\n纸张的最终外观是一个包含 $0$ 和 $1$ 的大小为 $n \\times m$ 的矩阵，你想知道需要使用剪刀时的最小裁剪次数。", "inputFormat": "有多个测试数据。输入的第一行包含一个整数 $T$ ，表示测试数据的数量。对于每个测试数据：\n\n第一行包含两个整数 $n$ 和 $m$ ( $1 \\le n \\times m \\le 10^6$ )表示纸张的大小。\n\n接下来的 $n$ 行中的每一行都包含一个长度为 $m$ 的01字符串，其中 $\\texttt{0}$ 表示 $1\\times 1$ 块被剪切掉， $\\texttt{1}$ 意味着 $1 \\times 1$ 块保留在最后的剪纸上。\n\n保证所有测试数据的 $n \\times m$ 之和不超过 $10^6$ 。", "outputFormat": "对于每个测试数据输出一行，其中包含一个整数，表示所需的最小裁剪次数。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n3\n2 5\n11001\n11001\n5 7\n1001100\n0110011\n0101101\n0010010\n1000000\n3 2\n11\n11\n11\n```\n\n### 样例输出 #1\n\n```\n1\n4\n0\n```", "hint": "对于样例一,你可以通过这种方式将唯一的 $0$ 剪出:\n$$\\begin{array}{ccc|cc} 1&1&0&0&1\\\\1&1&0&0&1\\end{array} \\to \\begin{array}{ccc} 1&1&0\\\\ \\hline 1&1&0\\end{array} \\to \\begin{array}{ccc} 1&1&0\\end{array}$$\n\n对于样例二，你可以按照以下方式折叠并裁剪出 $0$ 的 $4$ 个连通块：\n$$\\begin{array}{cccc|ccc} 1&0&0&1&1&0&0\\\\0&1&1&0&0&1&1\\\\0&1&0&1&1&0&1\\\\0&0&1&0&0&1&0\\\\1&0&0&0&0&0&0\\end{array} \\to \\begin{array}{cccc} 1&0&0&1\\\\0&1&1&0\\\\0&1&0&1\\\\0&0&1&0\\\\1&0&0&0\\end{array}$$", "locale": "zh-CN"}}}
{"pid": "P9647", "type": "P", "difficulty": 4, "samples": [["3\n1\n4\n6\n", "0\n1 2 4\n2 2 4 3 6\n"]], "limits": {"time": [1000, 1000], "memory": [262144, 262144]}, "tags": ["2019", "Special Judge", "O2优化", "陕西", "素数判断,质数,筛法", "省赛/邀请赛"], "title": "[SNCPC2019] To the Park", "background": "", "description": "BaoBao and his $(n-1)$ classmates are going to the park. For convenience, their teacher DreamGrid has numbered the students from 1 to $n$ and decides to form the students into some groups, where each group consists of exactly two students.\n\nFor some reason, DreamGrid requires that the indices of the two students in the same group should have a common divisor greater than 1. Note that each student can only belong to at most one group, and it's not necessary that every student belongs to a group.\n\nPlease help DreamGrid form as many groups as possible.\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first and only line contains an integer $n$ ($1 \\le n \\le 10^5$), indicating the number of students.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.\n", "outputFormat": "For each test case output one line. The line first contains an integer $k$ indicating the number of groups, then $2k$ integers $a_1, a_2, \\dots, a_{2k}$ follow, indicating that student $a_1$ and $a_2$ belong to the same group, student $a_3$ and $a_4$ belong to the same group, ..., student $a_{2k-1}$ and $a_{2k}$ belong to the same group. The integers in a line are separated by a space. If there are multiple valid answers, you can print any of them.\n\nPlease, DO NOT output extra spaces at the end of each line, or your solution may be considered incorrect!", "hint": "", "locale": "en", "translations": {"en": {"title": "[SNCPC2019] To the Park", "background": "", "description": "BaoBao and his $(n-1)$ classmates are going to the park. For convenience, their teacher DreamGrid has numbered the students from 1 to $n$ and decides to form the students into some groups, where each group consists of exactly two students.\n\nFor some reason, DreamGrid requires that the indices of the two students in the same group should have a common divisor greater than 1. Note that each student can only belong to at most one group, and it's not necessary that every student belongs to a group.\n\nPlease help DreamGrid form as many groups as possible.\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first and only line contains an integer $n$ ($1 \\le n \\le 10^5$), indicating the number of students.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.\n", "outputFormat": "For each test case output one line. The line first contains an integer $k$ indicating the number of groups, then $2k$ integers $a_1, a_2, \\dots, a_{2k}$ follow, indicating that student $a_1$ and $a_2$ belong to the same group, student $a_3$ and $a_4$ belong to the same group, ..., student $a_{2k-1}$ and $a_{2k}$ belong to the same group. The integers in a line are separated by a space. If there are multiple valid answers, you can print any of them.\n\nPlease, DO NOT output extra spaces at the end of each line, or your solution may be considered incorrect!", "hint": "", "locale": "en"}, "zh-CN": {"title": "[SNCPC2019] To the Park", "background": "", "description": "宝宝和他的 $(n-1)$ 个同学要去公园。为了方便，他们的老师梦想格子将学生从 1 到 $n$ 编号，并决定将学生分成一些小组，每组恰好由两个学生组成。\n\n由于某种原因，梦想格子要求同组的两个学生的编号必须有一个大于 1 的公约数。注意，每个学生最多只能属于一个小组，并且不需要每个学生都属于一个小组。\n\n请帮助梦想格子组成尽可能多的小组。", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行且唯一一行包含一个整数 $n$ ($1 \\le n \\le 10^5$)，表示学生的数量。\n\n保证所有测试用例的 $n$ 之和不超过 $10^6$。", "outputFormat": "对于每个测试用例，输出一行。该行首先包含一个整数 $k$，表示小组的数量，然后是 $2k$ 个整数 $a_1, a_2, \\dots, a_{2k}$，表示学生 $a_1$ 和 $a_2$ 属于同一小组，学生 $a_3$ 和 $a_4$ 属于同一小组，以此类推。行内的整数由空格分隔。如果有多个有效答案，可以输出其中任何一个。\n\n请不要在每行的末尾输出多余的空格，否则你的解决方案可能会被认为不正确！\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9648", "type": "P", "difficulty": 4, "samples": [["2\n6\n3 1 a\n3 2 a\n3 4 b\n4 5 c\n4 6 d\n6\n3 1 a\n3 2 a\n3 4 b\n5 4 c\n6 4 c\n", "2\n0\n"]], "limits": {"time": [3000, 3000], "memory": [262144, 262144]}, "tags": ["2019", "O2优化", "陕西", "树的遍历", "省赛/邀请赛"], "title": "[SNCPC2019] Unrooted Trie", "background": "", "description": "Recall the definition of a trie:\n\n- A trie of size $n$ is a rooted tree with $n$ vertices and $(n-1)$ edges, where each edge is marked with a character;\n- Each vertex in a trie represents a string. Let $s(x)$ be the string vertex $x$ represents;\n- The root of the trie represents an empty string. Let vertex $u$ be the parent of vertex $v$, and let $c$ be the character marked on the edge connecting vertex $u$ and $v$, we have $s(v)$ = $s(u) + c$. Here $+$ indicates string concatenation, not the normal addition operation.\n\nWe say a trie is valid, if the string each vertex represents is distinct.\n\nGiven an unrooted tree with $n$ vertices and $(n-1)$ edges, where each edge is marked with a character, how many different vertices can be selected as the root of the tree so that the tree becomes a valid trie?\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^5$), indicating the size of the tree.\n\nFor the following $(n-1)$ lines, the $i$-th line contains two integers $u_i$, $v_i$ ($1 \\le u_i, v_i \\le n$) and a character $c_i$ separated by a space, indicating that there is an edge marked with a character $c_i$ connecting vertex $u_i$ and $v_i$. It's guaranteed that $c_i$ will only be lower-case English letters.\n\nIt's guaranteed that the given graph is a tree, and the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer, indicating the number of different vertices that can be selected as the root of the tree to make it a valid trie.\n", "hint": "For the first sample test case, we can only select vertex 1 or vertex 2 as the root, otherwise $s(1)$ and $s(2)$ will be the same.\n\nFor the second sample test case, no matter which vertex we select as the root, $s(1)$ and $s(2)$, or $s(5)$ and $s(6)$ will be the same.\n", "locale": "en", "translations": {"en": {"title": "[SNCPC2019] Unrooted Trie", "background": "", "description": "Recall the definition of a trie:\n\n- A trie of size $n$ is a rooted tree with $n$ vertices and $(n-1)$ edges, where each edge is marked with a character;\n- Each vertex in a trie represents a string. Let $s(x)$ be the string vertex $x$ represents;\n- The root of the trie represents an empty string. Let vertex $u$ be the parent of vertex $v$, and let $c$ be the character marked on the edge connecting vertex $u$ and $v$, we have $s(v)$ = $s(u) + c$. Here $+$ indicates string concatenation, not the normal addition operation.\n\nWe say a trie is valid, if the string each vertex represents is distinct.\n\nGiven an unrooted tree with $n$ vertices and $(n-1)$ edges, where each edge is marked with a character, how many different vertices can be selected as the root of the tree so that the tree becomes a valid trie?\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^5$), indicating the size of the tree.\n\nFor the following $(n-1)$ lines, the $i$-th line contains two integers $u_i$, $v_i$ ($1 \\le u_i, v_i \\le n$) and a character $c_i$ separated by a space, indicating that there is an edge marked with a character $c_i$ connecting vertex $u_i$ and $v_i$. It's guaranteed that $c_i$ will only be lower-case English letters.\n\nIt's guaranteed that the given graph is a tree, and the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer, indicating the number of different vertices that can be selected as the root of the tree to make it a valid trie.\n", "hint": "For the first sample test case, we can only select vertex 1 or vertex 2 as the root, otherwise $s(1)$ and $s(2)$ will be the same.\n\nFor the second sample test case, no matter which vertex we select as the root, $s(1)$ and $s(2)$, or $s(5)$ and $s(6)$ will be the same.\n", "locale": "en"}, "zh-CN": {"title": "[SNCPC2019] Unrooted Trie", "background": "", "description": "### 题目背景\n\ntrie 的定义是这样的：\n\n- 一棵大小为 $n$ 的 trie，是一棵有着 $n$ 个节点和 $(n-1)$ 条边的有根树，每一条边上都标有一个字符；\n\n- 在 trie 中，从根结点到树上某一结点的路径代表一个字符串，节点 $x$ 代表的字符串记为 $s(x)$，特别地，根节点代表的字符串为空串。\n\n- 若节点 $u$ 是节点 $v$ 的父节点，且 $c$ 是连接 $u$ 与 $v$ 的边上的字符，则有 $s(v) = s(u) + c$（这里的 $+$ 表示字符串的连接，而非普通的加法运算）。\n\n当每一个节点代表的字符串互不相同时，该 trie 是合法的。\n\n\n给出一个无根的 trie，求其中有多少节点可作为该 trie 的根，使得该 trie 合法。", "inputFormat": "**每个测试点由多组数据组成。**\n\n输入的第一行包含一个正整数 $T$，代表测试数据的组数。\n\n对于每组测试数据：\n\n数据的第一行包含一个正整数 $n$，代表 trie 的大小。\n\n接下来的 $(n-1)$ 行中，第 $i$ 行包含两个正整数 $u_i,v_i$ 以及一个字符 $c_i$，用空格隔开，表示有一条标有 $c_i$ 的边连接着 $u_i$ 和 $v_i$。", "outputFormat": "对于每组测试数据，输出一行一个正整数，表示可以成为根后可以使该 trie 合法的节点的个数。", "hint": "【样例解释】\n\n对于第一组测试数据，只能选择节点 $1$ 或节点 $2$ 作为根，否则 $s(1)$ 和 $s(2)$ 相同。\n\n对于第二组测试数据，无论如何选择节点作为根，$s(1)$ 和 $s(2)$ 或 $s(5)$ 和 $s(6)$ 相同。\n\n\n对于每组数据，$1 \\le n \\le 2 \\times 10^5$，$1 \\le u_i,v_i \\le n$，$c_i$ 都是小写字母。\n\n对于每个测试点，保证给出的图是一棵树，所有的 $n$ 之和不会超过 $10^6$。", "locale": "zh-CN"}}}
{"pid": "P9649", "type": "P", "difficulty": 3, "samples": [["2\n3\n0 8\n2 6\n3 9\n1\n1 100\n", "6\n100\n"]], "limits": {"time": [3000, 3000], "memory": [262144, 262144]}, "tags": ["贪心", "2019", "O2优化", "陕西", "进制", "省赛/邀请赛"], "title": "[SNCPC2019] Coolbits", "background": "", "description": "Given $n$ intervals $[l_1, r_1], [l_2, r_2], \\dots, [l_n, r_n]$, one must select an integer from each of the intervals and calculate their bitwise and value $b$. What's the maximum possible $b$ one can get?\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^5$), indicating the number of intervals.\n\nFor the following $n$ lines, the $i$-th line contains two integers $l_i$ and $r_i$ ($0 \\le l_i \\le r_i \\le 10^9$), indicating the $i$-th interval.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.\n", "outputFormat": "For each test case output one line containing one integer, indicating the maximum possible $b$ one can get.\n", "hint": "For the first sample test case, one can select 7, 6 and  7 from the three intervals and get their bitwise and value 6.", "locale": "en", "translations": {"en": {"title": "[SNCPC2019] Coolbits", "background": "", "description": "Given $n$ intervals $[l_1, r_1], [l_2, r_2], \\dots, [l_n, r_n]$, one must select an integer from each of the intervals and calculate their bitwise and value $b$. What's the maximum possible $b$ one can get?\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^5$), indicating the number of intervals.\n\nFor the following $n$ lines, the $i$-th line contains two integers $l_i$ and $r_i$ ($0 \\le l_i \\le r_i \\le 10^9$), indicating the $i$-th interval.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.\n", "outputFormat": "For each test case output one line containing one integer, indicating the maximum possible $b$ one can get.\n", "hint": "For the first sample test case, one can select 7, 6 and  7 from the three intervals and get their bitwise and value 6.", "locale": "en"}, "zh-CN": {"title": "[SNCPC2019] Coolbits", "background": "", "description": "给定 $n$ 个区间 $[l_1, r_1], [l_2, r_2], \\dots, [l_n, r_n]$，需要从每个区间中选择一个整数并计算它们的按位与值 $b$。能够得到的最大 $b$ 是多少？", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行包含一个整数 $n$ ($1 \\le n \\le 10^5$)，表示区间的数量。\n\n接下来的 $n$ 行，第 $i$ 行包含两个整数 $l_i$ 和 $r_i$ ($0 \\le l_i \\le r_i \\le 10^9$)，表示第 $i$ 个区间。\n\n保证所有测试用例的 $n$ 之和不超过 $10^6$。", "outputFormat": "对于每个测试用例输出一行，包含一个整数，表示能得到的最大可能 $b$。\n\n**【样例解释】**\n\n对于第一个样例测试用例，可以从三个区间中选择 7、6 和 7，并得到它们的按位与值 6。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9650", "type": "P", "difficulty": 4, "samples": [["2\n3 4 1\n3\n1 1 1\n1 2 1\n1 2 2\n2 3 1\n2 3 2\n3 2 2\n2 3\n2 0 0\n1 2 1\n1 3 1\n", "4\n-1\n"]], "limits": {"time": [4000, 4000], "memory": [262144, 262144]}, "tags": ["2019", "O2优化", "最短路", "陕西", "省赛/邀请赛"], "title": "[SNCPC2019] Escape Plan", "background": "", "description": "BaoBao, one of the most famous monster hunters, wakes up in the middle of Heltion City dominated by monsters. Having troubles remembering what has happened, BaoBao decides to escape from this horrible city as soon as possible. Despite arming no weapon, he luckily puts his hand on a map in his right pocket, which contains valuable information that can possibly help him find a way out.  \n\nAccording to the map, Heltion City is composed of $n$ spots connected by $m$ undirected paths. Starting from spot $1$, BaoBao must head towards any of the $k$ exits of the city to escape, where the $i$-th of them is located at spot $e_i$.\n\nHowever, it's not an easy task for BaoBao to escape since monsters are everywhere in the city! For all $1 \\le i \\le n$, $d_i$ monsters are wandering near the $i$-th spot, so right after BaoBao arrives at that spot, at most $d_i$ paths connecting the spot will be blocked by monsters and are unable for BaoBao to pass. When BaoBao leaves the $i$-th spot, the monsters will go back to their nests and the blocked paths are clear. Of course, if BaoBao comes back to the spot, at most $d_i$ paths will be again blocked by the monsters. The paths blocked each time may differ.\n\nAs BaoBao doesn't know which paths will be blocked, please help him calculate the shortest time he can escape from the city in the worst case.\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ (about $100$), indicating the number of test cases. For each test case:\n\nThe first line contains three integers $n$, $m$ and $k$ ($1 \\le n \\le 10^5$, $1 \\le m \\le 10^6$, $1 \\le k \\le n$), indicating the number of spots, the number of undirected paths and the number of exits of the city.\n\nThe second line contains $k$ distinct integers $e_1, e_2, \\dots, e_k$ ($1 \\le e_i \\le n$), indicating $k$ exits of Heltion City.\n\nThe third line contains $n$ integers $d_1, d_2, \\dots, d_n$ ($0 \\le d_i \\le m$), where $d_i$ indicates the number of monsters at the $i$-th spot.\n\nFor the following $m$ lines, the $i$-th line contains three integers $x_i$, $y_i$ and $w_i$ ($1 \\le x_i,y_i \\le n$, $x_i \\neq y_i$, $1 \\le w_i \\le 10^4$), indicating an undirected edge of length $w_i$ connecting spot $x_i$ and $y_i$.\n\nIt's guaranteed that the total sum of $n$ will not exceed $10^6$ and the total sum of $m$ will not exceed $3 \\times 10^6$. \n", "outputFormat": "For each case output one line containing one integer. If BaoBao can get to some exit in the worst case, output the shortest possible time cost; Otherwise if BaoBao cannot get to any exit in the worst case, output ``-1``  instead.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[SNCPC2019] Escape Plan", "background": "", "description": "BaoBao, one of the most famous monster hunters, wakes up in the middle of Heltion City dominated by monsters. Having troubles remembering what has happened, BaoBao decides to escape from this horrible city as soon as possible. Despite arming no weapon, he luckily puts his hand on a map in his right pocket, which contains valuable information that can possibly help him find a way out.  \n\nAccording to the map, Heltion City is composed of $n$ spots connected by $m$ undirected paths. Starting from spot $1$, BaoBao must head towards any of the $k$ exits of the city to escape, where the $i$-th of them is located at spot $e_i$.\n\nHowever, it's not an easy task for BaoBao to escape since monsters are everywhere in the city! For all $1 \\le i \\le n$, $d_i$ monsters are wandering near the $i$-th spot, so right after BaoBao arrives at that spot, at most $d_i$ paths connecting the spot will be blocked by monsters and are unable for BaoBao to pass. When BaoBao leaves the $i$-th spot, the monsters will go back to their nests and the blocked paths are clear. Of course, if BaoBao comes back to the spot, at most $d_i$ paths will be again blocked by the monsters. The paths blocked each time may differ.\n\nAs BaoBao doesn't know which paths will be blocked, please help him calculate the shortest time he can escape from the city in the worst case.\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ (about $100$), indicating the number of test cases. For each test case:\n\nThe first line contains three integers $n$, $m$ and $k$ ($1 \\le n \\le 10^5$, $1 \\le m \\le 10^6$, $1 \\le k \\le n$), indicating the number of spots, the number of undirected paths and the number of exits of the city.\n\nThe second line contains $k$ distinct integers $e_1, e_2, \\dots, e_k$ ($1 \\le e_i \\le n$), indicating $k$ exits of Heltion City.\n\nThe third line contains $n$ integers $d_1, d_2, \\dots, d_n$ ($0 \\le d_i \\le m$), where $d_i$ indicates the number of monsters at the $i$-th spot.\n\nFor the following $m$ lines, the $i$-th line contains three integers $x_i$, $y_i$ and $w_i$ ($1 \\le x_i,y_i \\le n$, $x_i \\neq y_i$, $1 \\le w_i \\le 10^4$), indicating an undirected edge of length $w_i$ connecting spot $x_i$ and $y_i$.\n\nIt's guaranteed that the total sum of $n$ will not exceed $10^6$ and the total sum of $m$ will not exceed $3 \\times 10^6$. \n", "outputFormat": "For each case output one line containing one integer. If BaoBao can get to some exit in the worst case, output the shortest possible time cost; Otherwise if BaoBao cannot get to any exit in the worst case, output ``-1``  instead.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[SNCPC2019] Escape Plan", "background": "", "description": "宝宝被困在了 Heltion 城中。\n\n城市可以看做由 $n$ 个点与 $m$ 条边组成的**有权无向图**，最开始宝宝在 $1$ 号节点。城市中存在 $k$ 个出口，第 $i$ 个出口位置在 $e_i$ 号点 ，而宝宝需要以最快的速度到达**这些出口中的任意一个**以逃离 Heltion 城。\n\n不巧的是，城市中有怪物游荡，对于点 $i$，有 $d_i$ 只怪物驻守在此。当宝宝到达点 $i$ 时，怪物会**随机封锁至多** $d_i$ **条**与之相邻的道路，宝宝不能通过这些被封锁的道路。而当宝宝**离开后**，点 $i$ 的怪物会回窝，这时被封锁的**道路会解开**。\n\n请帮帮宝宝，求出最坏情况下，他逃出 Heltion 城需要多久。", "inputFormat": "第一行为一个正整数 $T$，表示有 $T$ 组测试数据。\n\n对于每组数据，第一行包括三个正整数 $n$，$m$，$k$，分别表示城市的点数，边数和城市中出口的数量。\n\n第二行有 $k$ 个正整数 $e_1, e_2,\\dots , e_k$，表示第 $i$ 个出口在 $e_i$ 号节点。\n\n第三行有 $n$ 个正整数 $d_1, d_2,\\dots , d_n$，表示第 $i$ 个节点上有 $d_i$ 只怪物。\n\n接下来的 $m$ 行，一行三个正整数 $x_i$，$y_i$，$w_i$，表示第 $i$ 条双向边所连接的两点与边权。", "outputFormat": "共 $T$ 行，每行一个整数。第 $i$ 行的整数表示第 $i$ 组数据的答案。\n\n对于每组数据，若宝宝不能到达任何一个出口，请输出 `-1`。否则，输出宝宝到达任意一个出口所需要的最少时间。", "hint": "对于 $100\\%$ 的数据，$1\\le n \\le 10^5$，$\\sum n \\le 10^6$，$1\\le m \\le 10^6$，$\\sum m \\le 3\\times 10^6$，$1\\le k \\le n$，$1\\le e_i \\le n$，$0\\le d_i \\le m$，$1\\le x_i,y_i \\le n$，$1\\le w_i \\le 10^4$。数据保证 $x_i \\neq y_i$。", "locale": "zh-CN"}}}
{"pid": "P9651", "type": "P", "difficulty": 1, "samples": [["2\n1 9\n97 99\n", "362880\n367416\n"]], "limits": {"time": [1000, 1000], "memory": [262144, 262144]}, "tags": ["2019", "O2优化", "陕西", "省赛/邀请赛"], "title": "[SNCPC2019] Digit Product", "background": "", "description": "Define the ''digit product'' $f(x)$ of a positive integer $x$ as the product of all its digits. For example, $f(1234) = 1 \\times 2 \\times 3 \\times 4 = 24$, and $f(100) = 1 \\times 0 \\times 0 = 0$.\n\nGiven two integers $l$ and $r$, please calculate the following value:\n$$(\\prod_{i=l}^r f(i)) \\mod (10^9+7)$$ \nIn case that you don't know what $\\prod$ represents, the above expression is the same as \n$$(f(l) \\times f(l+1) \\times \\dots \\times f(r)) \\mod (10^9+7)$$\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ (about $10^5$), indicating the number of test cases. For each test case:\n\nThe first and only line contains two integers $l$ and $r$ ($1 \\le l \\le r \\le 10^9$), indicating the given two integers. The integers are given without leading zeros.\n", "outputFormat": "For each test case output one line containing one integer indicating the answer.", "hint": "For the first sample test case, the answer is $9! \\mod (10^9+7) = 362880$.\n\nFor the second sample test case, the answer is $(f(97) \\times f(98) \\times f(99)) \\mod (10^9+7) = (9 \\times 7 \\times 9 \\times 8 \\times 9 \\times 9) \\mod (10^9+7) = 367416$.\n", "locale": "en", "translations": {"en": {"title": "[SNCPC2019] Digit Product", "background": "", "description": "Define the ''digit product'' $f(x)$ of a positive integer $x$ as the product of all its digits. For example, $f(1234) = 1 \\times 2 \\times 3 \\times 4 = 24$, and $f(100) = 1 \\times 0 \\times 0 = 0$.\n\nGiven two integers $l$ and $r$, please calculate the following value:\n$$(\\prod_{i=l}^r f(i)) \\mod (10^9+7)$$ \nIn case that you don't know what $\\prod$ represents, the above expression is the same as \n$$(f(l) \\times f(l+1) \\times \\dots \\times f(r)) \\mod (10^9+7)$$\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ (about $10^5$), indicating the number of test cases. For each test case:\n\nThe first and only line contains two integers $l$ and $r$ ($1 \\le l \\le r \\le 10^9$), indicating the given two integers. The integers are given without leading zeros.\n", "outputFormat": "For each test case output one line containing one integer indicating the answer.", "hint": "For the first sample test case, the answer is $9! \\mod (10^9+7) = 362880$.\n\nFor the second sample test case, the answer is $(f(97) \\times f(98) \\times f(99)) \\mod (10^9+7) = (9 \\times 7 \\times 9 \\times 8 \\times 9 \\times 9) \\mod (10^9+7) = 367416$.\n", "locale": "en"}, "zh-CN": {"title": "[SNCPC2019] Digit Product", "background": "", "description": "定义正整数 $x$ 的 \"数字乘积\" $f(x)$ 为其所有数字的乘积。例如，$f(1234) = 1 \\times 2 \\times 3 \\times 4 = 24$，$f(100) = 1 \\times 0 \\times 0 = 0$。\n\n给定两个整数 $l$ 和 $r$，请计算以下值：\n$$(\\prod_{i=l}^r f(i)) \\mod (10^9+7)$$ \n如果你不知道 $\\prod$ 表示什么，上述表达式等同于 \n$$(f(l) \\times f(l+1) \\times \\dots \\times f(r)) \\mod (10^9+7)$$", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$（大约 $10^5$），表示测试用例的数量。对于每个测试用例：\n\n第一行且唯一一行包含两个整数 $l$ 和 $r$（$1 \\le l \\le r \\le 10^9$），表示给定的两个整数。这些整数没有前导零。", "outputFormat": "对于每个测试用例，输出一行，包含一个整数，表示答案。\n\n**【样例解释】**\n\n对于第一个样例测试用例，答案是 $9! \\mod (10^9+7) = 362880$。\n\n对于第二个样例测试用例，答案是 $(f(97) \\times f(98) \\times f(99)) \\mod (10^9+7) = (9 \\times 7 \\times 9 \\times 8 \\times 9 \\times 9) \\mod (10^9+7) = 367416$。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9652", "type": "P", "difficulty": 2, "samples": [["5\n1 5 4\n2 3 8\n1 5 10\n2 6 34\n1 3 1", "1 1 1 1 1\n2 2 3\n1 1 1 7 7\n1 1 4 5 1 4\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "洛谷原创", "Special Judge", "O2优化", "构造", "洛谷月赛"], "title": "『GROI-R2』 紫水晶", "background": "", "description": "爱丽丝不曾忘记过她曾经存在于纸牌的世界。\n\n于是魔法让她的手里出现了一些牌，同时魔法也让坦尼尔手里出现了一些牌，而且每张牌上都写着一个正整数——尽管他们如今所处的，是玻璃王国的世界中。\n\n牌张很快一消而散，而他们也准备启程。爱丽丝只记住了每相邻两张牌的**最大公约数之和**，坦尼尔只记住了每相邻两张牌的**最小公倍数之和**。\n\n你还在这个宫殿里，你想重现当时的牌张。\n\n**形式化题面**\n\n给定 $q$ 次询问，每次询问为以下两种之一：\n\n- ``1 n x`` 表示要求输出一长度为 $n$ 的**正整数**序列 $\\{a_n\\}$，使得 $\\sum\\limits_{i=1}^{n-1} \\gcd(a_i,a_{i+1})=x$。\n\n- ``2 n x`` 表示要求输出一长度为 $n$ 的**正整数**序列 $\\{a_n\\}$，使得 $\\sum\\limits_{i=1}^{n-1} \\operatorname{lcm}(a_i,a_{i+1})=x$。\n\n且对于任意输出的 $a_i$ 不应超出 C++ 语言中 ``int`` 的存储范围。\n\n其中 $\\gcd$ 和 $\\operatorname{lcm}$ 分别为最大公约数和最小公倍数，如有多解，输出任意一个即可。如果无解，输出 ``-1``。", "inputFormat": "第一行输入一个正整数 $q$ 表示询问次数。\n\n接下来 $q$ 行，每行输入三个正整数 $op,n,x$。\n\n- 当 $op=1$ 时表示爱丽丝的牌张数为 $n$，她记住的和为 $x$，要求还原她的牌张。\n\n- 当 $op=2$ 时表示坦尼尔的牌张数为 $n$，他记住的和为 $x$，要求还原他的牌张。", "outputFormat": "一共 $q$ 行，每行输出一个整数序列对应每次询问你构造的牌张序列，序列中相邻的两个数用一个空格隔开。\n\n如有多解，你可以输出任意一个。如果无解，输出 ``-1``。", "hint": "**数据范围**\n\n**本题采用捆绑测试**。\n\n| $\\text{Subtask}$ | $\\sum n\\le$ | $x\\le$ | 特殊性质 | 分值 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| $1$ | $5$ | $10$ | | $10$ |\n| $2$ | $50$ | $200$ | | $20$ |\n| $3$ | $5\\times 10^5$ | $2^{31}-1$ | $\\text{A}$ | $15$ |\n| $4$ | $5\\times 10^5$ | $2^{31}-1$ | $\\text{B}$ | $15$ |\n| $5$ | $5\\times 10^5$ | $2^{31}-1$ | | $40$ |\n\n特殊性质 $\\text{A}$：保证对于任意询问满足 $op=1$。\n\n特殊性质 $\\text{B}$：保证对于任意询问满足 $op=2$。\n\n对于 $100\\%$ 的数据满足 $2\\le n\\le 5\\times 10^5$，$2\\le \\sum n\\le 5\\times 10^5$，$1\\le x \\le 2^{31}-1$，$op\\in\\{1,2\\}$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『GROI-R2』 紫水晶", "background": "", "description": "爱丽丝不曾忘记过她曾经存在于纸牌的世界。\n\n于是魔法让她的手里出现了一些牌，同时魔法也让坦尼尔手里出现了一些牌，而且每张牌上都写着一个正整数——尽管他们如今所处的，是玻璃王国的世界中。\n\n牌张很快一消而散，而他们也准备启程。爱丽丝只记住了每相邻两张牌的**最大公约数之和**，坦尼尔只记住了每相邻两张牌的**最小公倍数之和**。\n\n你还在这个宫殿里，你想重现当时的牌张。\n\n**形式化题面**\n\n给定 $q$ 次询问，每次询问为以下两种之一：\n\n- ``1 n x`` 表示要求输出一长度为 $n$ 的**正整数**序列 $\\{a_n\\}$，使得 $\\sum\\limits_{i=1}^{n-1} \\gcd(a_i,a_{i+1})=x$。\n\n- ``2 n x`` 表示要求输出一长度为 $n$ 的**正整数**序列 $\\{a_n\\}$，使得 $\\sum\\limits_{i=1}^{n-1} \\operatorname{lcm}(a_i,a_{i+1})=x$。\n\n且对于任意输出的 $a_i$ 不应超出 C++ 语言中 ``int`` 的存储范围。\n\n其中 $\\gcd$ 和 $\\operatorname{lcm}$ 分别为最大公约数和最小公倍数，如有多解，输出任意一个即可。如果无解，输出 ``-1``。", "inputFormat": "第一行输入一个正整数 $q$ 表示询问次数。\n\n接下来 $q$ 行，每行输入三个正整数 $op,n,x$。\n\n- 当 $op=1$ 时表示爱丽丝的牌张数为 $n$，她记住的和为 $x$，要求还原她的牌张。\n\n- 当 $op=2$ 时表示坦尼尔的牌张数为 $n$，他记住的和为 $x$，要求还原他的牌张。", "outputFormat": "一共 $q$ 行，每行输出一个整数序列对应每次询问你构造的牌张序列，序列中相邻的两个数用一个空格隔开。\n\n如有多解，你可以输出任意一个。如果无解，输出 ``-1``。", "hint": "**数据范围**\n\n**本题采用捆绑测试**。\n\n| $\\text{Subtask}$ | $\\sum n\\le$ | $x\\le$ | 特殊性质 | 分值 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| $1$ | $5$ | $10$ | | $10$ |\n| $2$ | $50$ | $200$ | | $20$ |\n| $3$ | $5\\times 10^5$ | $2^{31}-1$ | $\\text{A}$ | $15$ |\n| $4$ | $5\\times 10^5$ | $2^{31}-1$ | $\\text{B}$ | $15$ |\n| $5$ | $5\\times 10^5$ | $2^{31}-1$ | | $40$ |\n\n特殊性质 $\\text{A}$：保证对于任意询问满足 $op=1$。\n\n特殊性质 $\\text{B}$：保证对于任意询问满足 $op=2$。\n\n对于 $100\\%$ 的数据满足 $2\\le n\\le 5\\times 10^5$，$2\\le \\sum n\\le 5\\times 10^5$，$1\\le x \\le 2^{31}-1$，$op\\in\\{1,2\\}$。\n", "locale": "zh-CN"}}}
{"pid": "P9653", "type": "P", "difficulty": 3, "samples": [["2\n3 1 3\n2 2 2\n5 2 4\n2 2 2 2 3", "3\n5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "洛谷原创", "O2优化", "洛谷月赛"], "title": "『GROI-R2』 不空白的画布", "background": "", "description": "我们都知道爱丽丝躲起来之后，坦尼尔坐在了空白画布面前，拿起炭笔开始作画。\n\n但是现在画布已经不再空白，因为画布上已经有了当下的风景。我们设画布的长度是 $n$，每一单位长度上的颜色可以用一个在 $[1,k]$ 范围内的正整数表示。\n\n坦尼尔还要画他已经翻了的茶杯。每一次作画，他可以选定画布上的任意一个位置，然后将这个位置上的颜色涂改成 $[1,k]$ 范围内的任意正整数。\n\n最后，我们都知道这幅画是有记忆的。定义画上留下的记忆碎片数量为画上的**相同颜色连续块个数**。现在坦尼尔想知道，如果给定他作画的次数**上限**，那么画上的记忆碎片个数**最多**有多少。\n\n**形式化题面**\n\n你有连续的 $n$ 个方格，每个方格上有一个初始颜色 $c_i$，且保证 $1\\le c_i \\le k$。\n\n你可以操作**至多** $m$ 次，每个操作为改变某个方格颜色，要求改变后的颜色范围仍在 $[1,k]$ 内。\n\n我们称一个**极长相同颜色连续段**为一块，要求求出经过至多 $m$ 次操作后的**最多**块数。\n", "inputFormat": "本题有多组测试数据。\n\n第一行输入一个正整数 $T$ 表示数据组数。\n\n对于每组测试数据，第一行输入三个正整数 $n,m,k$，表示画布的长度，坦尼尔作画的次数上限和颜色的取值范围。\n\n第二行输入一个长度为 $n$ 的整数序列 $c$，表示画布上每个位置的初始颜色。", "outputFormat": "对于每组测试数据，输出一行一个正整数，表示记忆碎片最多有多少个。", "hint": "**样例解释**\n\n对于第一组测试数据，坦尼尔可以将从左到右的第二个位置涂成颜色 $1$，得到 $\\{c_n\\}=\\{2,1,2\\}$，块数为 $3$。\n\n\n对于第二组测试数据，坦尼尔可以将从左到右的第二个位置涂成颜色 $1$，将从左到右的第三个位置涂成颜色 $3$，得到 $\\{c_n\\}=\\{2,1,3,2,3\\}$，块数为 $5$。\n\n**数据范围**\n\n**本题采用捆绑测试**。\n\n| $\\text{Subtask}$ | $\\sum n\\le$ | $m\\le$ | $k\\le$ | 分值 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------:  |\n| $1$ | $10$ | $10$ | $3$ | $10$ |\n| $2$ | $5\\times 10^5$ | $1$ | $5\\times 10^5$ | $10$ |\n| $3$ | $10^3$ | $10^3$ | $10^3$ | $15$ |\n| $4$ | $5\\times 10^5$ | $5\\times 10^5$ | $3$ | $25$ |\n| $5$ | $5\\times 10^5$ | $5\\times 10^5$ | $5\\times 10^5$ | $40$ |\n\n对于 $100\\%$ 的数据满足 $1\\le  n\\le 5\\times 10^5$，$1\\le \\sum n\\le 5\\times 10^5$，$1\\le m\\le n$，$3\\le  k \\le 5\\times 10^5$，$1\\le c_i\\le k$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『GROI-R2』 不空白的画布", "background": "", "description": "我们都知道爱丽丝躲起来之后，坦尼尔坐在了空白画布面前，拿起炭笔开始作画。\n\n但是现在画布已经不再空白，因为画布上已经有了当下的风景。我们设画布的长度是 $n$，每一单位长度上的颜色可以用一个在 $[1,k]$ 范围内的正整数表示。\n\n坦尼尔还要画他已经翻了的茶杯。每一次作画，他可以选定画布上的任意一个位置，然后将这个位置上的颜色涂改成 $[1,k]$ 范围内的任意正整数。\n\n最后，我们都知道这幅画是有记忆的。定义画上留下的记忆碎片数量为画上的**相同颜色连续块个数**。现在坦尼尔想知道，如果给定他作画的次数**上限**，那么画上的记忆碎片个数**最多**有多少。\n\n**形式化题面**\n\n你有连续的 $n$ 个方格，每个方格上有一个初始颜色 $c_i$，且保证 $1\\le c_i \\le k$。\n\n你可以操作**至多** $m$ 次，每个操作为改变某个方格颜色，要求改变后的颜色范围仍在 $[1,k]$ 内。\n\n我们称一个**极长相同颜色连续段**为一块，要求求出经过至多 $m$ 次操作后的**最多**块数。\n", "inputFormat": "本题有多组测试数据。\n\n第一行输入一个正整数 $T$ 表示数据组数。\n\n对于每组测试数据，第一行输入三个正整数 $n,m,k$，表示画布的长度，坦尼尔作画的次数上限和颜色的取值范围。\n\n第二行输入一个长度为 $n$ 的整数序列 $c$，表示画布上每个位置的初始颜色。", "outputFormat": "对于每组测试数据，输出一行一个正整数，表示记忆碎片最多有多少个。", "hint": "**样例解释**\n\n对于第一组测试数据，坦尼尔可以将从左到右的第二个位置涂成颜色 $1$，得到 $\\{c_n\\}=\\{2,1,2\\}$，块数为 $3$。\n\n\n对于第二组测试数据，坦尼尔可以将从左到右的第二个位置涂成颜色 $1$，将从左到右的第三个位置涂成颜色 $3$，得到 $\\{c_n\\}=\\{2,1,3,2,3\\}$，块数为 $5$。\n\n**数据范围**\n\n**本题采用捆绑测试**。\n\n| $\\text{Subtask}$ | $\\sum n\\le$ | $m\\le$ | $k\\le$ | 分值 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------:  |\n| $1$ | $10$ | $10$ | $3$ | $10$ |\n| $2$ | $5\\times 10^5$ | $1$ | $5\\times 10^5$ | $10$ |\n| $3$ | $10^3$ | $10^3$ | $10^3$ | $15$ |\n| $4$ | $5\\times 10^5$ | $5\\times 10^5$ | $3$ | $25$ |\n| $5$ | $5\\times 10^5$ | $5\\times 10^5$ | $5\\times 10^5$ | $40$ |\n\n对于 $100\\%$ 的数据满足 $1\\le  n\\le 5\\times 10^5$，$1\\le \\sum n\\le 5\\times 10^5$，$1\\le m\\le n$，$3\\le  k \\le 5\\times 10^5$，$1\\le c_i\\le k$。\n", "locale": "zh-CN"}}}
{"pid": "P9654", "type": "P", "difficulty": 6, "samples": [["4\n1 3 5 8", "1\n1 3 1 8"], ["3\n3 4 5", "1\n0 4 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "数学", "数论", "洛谷原创", "Special Judge", "O2优化", "构造", "洛谷月赛"], "title": "『GROI-R2』 记忆碎片", "background": "", "description": "记忆的碎片散落在各个角落，而爱丽丝想把它们拼合在一起。\n\n碎片的顺序是给定的，因为记忆显然不能反过来进行。但是，碎片各自的形状和内容是可以打磨和修正的——毕竟所有人的记忆都会歪曲和遗忘。\n\n每个碎片上的记忆都可以用一个**非负整数**来表示。而相邻的两个碎片能够完整地拼合起来，当且仅当它们记忆的和是一个**完全平方数**。\n\n现在，爱丽丝可以打磨若干块碎片，使得每一对相邻的碎片都能够完整地拼合起来。对于每一次打磨，爱丽丝可以选择一块碎片，将这块碎片上的记忆修改为任意一个**非负整数**。爱丽丝想知道，她至少要打磨多少块碎片，才能实现她的目标。同时，她还希望你给出打磨之后，每块碎片上留有的记忆是多少。\n\n**形式化题面**\n\n给定一个**非负整数**序列 $\\{a_n\\}$，我们定义一次操作是任意选择一个 $i\\in [1,n]$ 并将 $a_i$ 改为任意一个**非负整数** $x$。\n\n问至少进行几次操作才可以满足 $\\forall i\\in [1,n-1]$ 有 $a_i+a_{i+1}$ 为**完全平方数**，并给出修改方案。", "inputFormat": "第一行输入一个整数 $n$，表示记忆碎片的个数。\n\n第二行输入一个长度为 $n$ 的非负整数序列 $a$，表示每个记忆碎片上的记忆。", "outputFormat": "第一行输出一个整数，表示最少打磨次数。\n\n第二行输出一个长度为 $n$ 的整数序列，表示所有打磨过后的记忆碎片上的记忆。\n\n你必须保证你打磨后的记忆满足题目条件，且与你给出的最少打磨次数相符，并满足每个碎片上的记忆都在 $[0,10^{18}]$ 的范围内。", "hint": "**样例解释**\n\n对于第一组样例，不难证明爱丽丝至少要打磨一块碎片才能使所有的记忆满足条件。\n\n请一定注意记忆碎片的顺序是不能改变的。\n\n**评分规则**\n\n如果你对于某一测试点输出的最少打磨次数是正确的，你将获得该测试点 $30\\%$ 的分数。\n\n如果你在最少打磨次数正确的基础上给出了正确的构造，你将获得该测试点 $100\\%$ 的分数。\n\n如果你只会求解最少打磨次数，那也请你在第二行输出以空格隔开的 $n$ 个在 $[0,10^{18}]$ 范围内的整数，否则可能被判为 $0$ 分。\n\n请注意，你在每个 subtask 中得到的 $30\\%$ 分数会被下取整计算。\n\n**数据范围**\n\n**本题采用捆绑测试**。\n\n| $\\text{Subtask}$ | $n\\le$ | $a_i\\le$ | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $2$ | $10^8$ |  | $5$ |\n| $2$ | $3$ | $10^8$ |  | $20$ |\n| $3$ | $4$ | $10^8$ |  | $15$ |\n| $4$ | $10^3$ | $10^8$ |  | $15$ |\n| $5$ | $10^6$ | $10^4$ |  | $10$ |\n| $6$ | $10^6$ | $10^8$ | $\\text{A}$ | $10$ |\n| $7$ | $10^6$ | $10^8$ |  | $25$ |\n\n特殊性质 $\\text{A}$：$\\forall 1\\le i,j\\le n$ 满足 $a_i=a_j$。\n\n对于 $100\\%$ 的数据满足 $1\\le n\\le 10^6$，$0\\le a_i\\le 10^8$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『GROI-R2』 记忆碎片", "background": "", "description": "记忆的碎片散落在各个角落，而爱丽丝想把它们拼合在一起。\n\n碎片的顺序是给定的，因为记忆显然不能反过来进行。但是，碎片各自的形状和内容是可以打磨和修正的——毕竟所有人的记忆都会歪曲和遗忘。\n\n每个碎片上的记忆都可以用一个**非负整数**来表示。而相邻的两个碎片能够完整地拼合起来，当且仅当它们记忆的和是一个**完全平方数**。\n\n现在，爱丽丝可以打磨若干块碎片，使得每一对相邻的碎片都能够完整地拼合起来。对于每一次打磨，爱丽丝可以选择一块碎片，将这块碎片上的记忆修改为任意一个**非负整数**。爱丽丝想知道，她至少要打磨多少块碎片，才能实现她的目标。同时，她还希望你给出打磨之后，每块碎片上留有的记忆是多少。\n\n**形式化题面**\n\n给定一个**非负整数**序列 $\\{a_n\\}$，我们定义一次操作是任意选择一个 $i\\in [1,n]$ 并将 $a_i$ 改为任意一个**非负整数** $x$。\n\n问至少进行几次操作才可以满足 $\\forall i\\in [1,n-1]$ 有 $a_i+a_{i+1}$ 为**完全平方数**，并给出修改方案。", "inputFormat": "第一行输入一个整数 $n$，表示记忆碎片的个数。\n\n第二行输入一个长度为 $n$ 的非负整数序列 $a$，表示每个记忆碎片上的记忆。", "outputFormat": "第一行输出一个整数，表示最少打磨次数。\n\n第二行输出一个长度为 $n$ 的整数序列，表示所有打磨过后的记忆碎片上的记忆。\n\n你必须保证你打磨后的记忆满足题目条件，且与你给出的最少打磨次数相符，并满足每个碎片上的记忆都在 $[0,10^{18}]$ 的范围内。", "hint": "**样例解释**\n\n对于第一组样例，不难证明爱丽丝至少要打磨一块碎片才能使所有的记忆满足条件。\n\n请一定注意记忆碎片的顺序是不能改变的。\n\n**评分规则**\n\n如果你对于某一测试点输出的最少打磨次数是正确的，你将获得该测试点 $30\\%$ 的分数。\n\n如果你在最少打磨次数正确的基础上给出了正确的构造，你将获得该测试点 $100\\%$ 的分数。\n\n如果你只会求解最少打磨次数，那也请你在第二行输出以空格隔开的 $n$ 个在 $[0,10^{18}]$ 范围内的整数，否则可能被判为 $0$ 分。\n\n请注意，你在每个 subtask 中得到的 $30\\%$ 分数会被下取整计算。\n\n**数据范围**\n\n**本题采用捆绑测试**。\n\n| $\\text{Subtask}$ | $n\\le$ | $a_i\\le$ | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $2$ | $10^8$ |  | $5$ |\n| $2$ | $3$ | $10^8$ |  | $20$ |\n| $3$ | $4$ | $10^8$ |  | $15$ |\n| $4$ | $10^3$ | $10^8$ |  | $15$ |\n| $5$ | $10^6$ | $10^4$ |  | $10$ |\n| $6$ | $10^6$ | $10^8$ | $\\text{A}$ | $10$ |\n| $7$ | $10^6$ | $10^8$ |  | $25$ |\n\n特殊性质 $\\text{A}$：$\\forall 1\\le i,j\\le n$ 满足 $a_i=a_j$。\n\n对于 $100\\%$ 的数据满足 $1\\le n\\le 10^6$，$0\\le a_i\\le 10^8$。", "locale": "zh-CN"}}}
{"pid": "P9655", "type": "P", "difficulty": 6, "samples": [["3\n())\n1 2\n1 3", "3"], ["8\n()))())(\n1 2\n1 3\n3 4\n3 5\n3 6\n5 7\n2 8", "5"]], "limits": {"time": [1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["并查集", "树上启发式合并", "洛谷原创", "O2优化", "树形 DP", "最近公共祖先 LCA", "树论", "虚树", "洛谷月赛"], "title": "『GROI-R2』 Beside You", "background": "記憶の森\n\n始まりの謎 いつか\n\nこの未知の果てに告げ知らせて\n\n——江口孝宏《Beside You》", "description": "我相信所有读过这一段剧情的人都不想让别人也经历一样的痛苦，但是坦尼尔还是只能消失，对吗？\n\n坦尼尔最后留下了一棵以 $1$ 为根的有根树，在树的每个结点上，都有一个记忆碎片。有的碎片表示着一个世界记忆的开始，而另外的碎片表示着一个世界记忆的终结。\n\n这时，树上飞来了一只蝴蝶~~モリモリあつし~~。蝴蝶在树上飞舞的过程中，经过了一些结点。爱丽丝能确定蝴蝶经过的结点个数至少有 $2$ 个，但是她忘记了具体的点数。\n\n爱丽丝发现，蝴蝶经过的所有点都是互相连通的。当她把目光朝向每一条经过点数大于 $1$ 的从连通块**深度最小的结点**通往**连通块的任意一个叶子结点**（一个点是连通块的叶子结点，当且仅当它在树上没有子结点，或者它在树上的任意子结点均不在该连通块内）的简单路径时，她发现这些路径上的记忆都是完整的。爱丽丝认为一条路径上的记忆是完整的，当且仅当这条路径上既没有出现一个世界的记忆**没开始就结束**（路径中途在没有未结束的记忆的时候，出现了表示记忆终结的碎片）的情况，也没有出现一个世界的记忆**开始之后没有终结**（路径结束之后还有没结束的记忆）的情况。\n\n可惜她已经遗忘了蝴蝶经过了哪些点，所以你需要告诉她蝴蝶**最多**可能经过多少点。\n\n**形式化题面**\n\n给定一棵以 $1$ 为根的 $n$ 个节点的树 $T=(V,E)$，每个节点上的点权 $c_i$ 为一个**左括号或一个右括号**，节点编号为 $1\\sim n$。\n\n我们定义点集 $V'\\subseteq V$ 合法，当且仅当 $|V'|>1$（**即 $V'$ 的大小大于 $1$**） 且 $\\forall u,v \\in V'$，从 $u$ 到 $v$ 的简单路径只经过 $V'$ 中的点。\n\n同时我们定义 $E'\\subseteq E$ 为能使得 $\\forall u,v \\in V'$，从 $u$ 到 $v$ 的简单路径，只经过 $E'$ 中的边的大小最小的边集。\n\n定义一个合法点集 $V'$ 的根为 $V'$ 中深度最小的结点。\n\n定义 $u$ 为合法点集 $V'$ 的叶子节点，当且仅当 $u$ 不是 $V'$ 的根，且满足 $v \\in V', (u,v) \\in E'$ 的 $v$ 的数量为 $1$。\n\n求一个合法点集 $S$，**满足其根节点到其任意一个叶子的路径上，每个点的点权顺次相接为一个合法的括号序列**，并**最大化** $|S|$。\n\n我们通过如下规则定义一个合法的括号序列：\n\n- 空串（即长度为 $0$ 的串）是一个合法的括号序列。\n\n- 若串 $\\text{A,B}$ 都是合法的括号序列，则字符串 $\\text{AB}$ （即将字符串 $\\text{A}$ 与 $\\text{B}$ 按顺序拼接起来）也是合法的括号序列。\n\n- 若串 $\\text{A}$ 是合法的括号序列，则字符串 $\\text{(A)}$ 是一个合法的括号序列。\n\n你需要输出符合要求的最大 $|S|$。", "inputFormat": "第一行输入一个正整数 $n$ 表示树上结点个数。\n\n第二行输入一个长度为 $n$ 的字符串 $c$。$c_i$ 为 ``(`` 表示这个结点上有一个标志着记忆开始的碎片，$c_i$ 为 ``)`` 表示这个结点上有一个标志着记忆终结的碎片。\n\n接下来 $n-1$ 行，每行输入两个正整数 $u,v$，表示结点 $u,v$ 之间有一条边。", "outputFormat": "输出一行一个整数，表示答案。", "hint": "**样例解释**\n\n![](https://s1.ax1x.com/2023/08/07/pPEj56K.png)\n\n蝴蝶经过的最大合法点集 $S$ 为 $\\{1,2,3\\}$。\n\n![](https://s1.ax1x.com/2023/08/07/pPEv90g.png)\n\n蝴蝶经过的最大合法点集 $S$ 为 $\\{1,2,3,5,7\\}$。\n\n**数据范围**\n\n**本题采用捆绑测试**。\n\n| $\\text{Subtask}$ | $n\\le$ | 特殊性质 | 分值 |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| $1$ | $20$ |  | $5$ |\n| $2$ | $3000$ |  | $20$ |\n| $3$ | $5\\times10^5$ | $\\text{A}$ | $15$  |\n| $4$ | $5\\times10^5$ | $\\text{B}$ |  $10$ |\n| $5$ | $2\\times10^5$ |  | $15$ |\n| $6$ | $5\\times10^5$ |  | $35$ |\n\n特殊性质 $\\text{A}$：保证树退化成一条链（不保证 $1$ 号节点为其一个端点）。\n\n特殊性质 $\\text{B}$：保证原树上任意结点到叶子的路径上右括号数量不少于左括号数量。\n\n对于 $100\\%$ 的数据满足 $1\\le n\\le 5\\times 10^5$，$1\\le u,v \\le n$，$c_i$ 为 ``(`` 或 ``)``。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『GROI-R2』 Beside You", "background": "記憶の森\n\n始まりの謎 いつか\n\nこの未知の果てに告げ知らせて\n\n——江口孝宏《Beside You》", "description": "我相信所有读过这一段剧情的人都不想让别人也经历一样的痛苦，但是坦尼尔还是只能消失，对吗？\n\n坦尼尔最后留下了一棵以 $1$ 为根的有根树，在树的每个结点上，都有一个记忆碎片。有的碎片表示着一个世界记忆的开始，而另外的碎片表示着一个世界记忆的终结。\n\n这时，树上飞来了一只蝴蝶~~モリモリあつし~~。蝴蝶在树上飞舞的过程中，经过了一些结点。爱丽丝能确定蝴蝶经过的结点个数至少有 $2$ 个，但是她忘记了具体的点数。\n\n爱丽丝发现，蝴蝶经过的所有点都是互相连通的。当她把目光朝向每一条经过点数大于 $1$ 的从连通块**深度最小的结点**通往**连通块的任意一个叶子结点**（一个点是连通块的叶子结点，当且仅当它在树上没有子结点，或者它在树上的任意子结点均不在该连通块内）的简单路径时，她发现这些路径上的记忆都是完整的。爱丽丝认为一条路径上的记忆是完整的，当且仅当这条路径上既没有出现一个世界的记忆**没开始就结束**（路径中途在没有未结束的记忆的时候，出现了表示记忆终结的碎片）的情况，也没有出现一个世界的记忆**开始之后没有终结**（路径结束之后还有没结束的记忆）的情况。\n\n可惜她已经遗忘了蝴蝶经过了哪些点，所以你需要告诉她蝴蝶**最多**可能经过多少点。\n\n**形式化题面**\n\n给定一棵以 $1$ 为根的 $n$ 个节点的树 $T=(V,E)$，每个节点上的点权 $c_i$ 为一个**左括号或一个右括号**，节点编号为 $1\\sim n$。\n\n我们定义点集 $V'\\subseteq V$ 合法，当且仅当 $|V'|>1$（**即 $V'$ 的大小大于 $1$**） 且 $\\forall u,v \\in V'$，从 $u$ 到 $v$ 的简单路径只经过 $V'$ 中的点。\n\n同时我们定义 $E'\\subseteq E$ 为能使得 $\\forall u,v \\in V'$，从 $u$ 到 $v$ 的简单路径，只经过 $E'$ 中的边的大小最小的边集。\n\n定义一个合法点集 $V'$ 的根为 $V'$ 中深度最小的结点。\n\n定义 $u$ 为合法点集 $V'$ 的叶子节点，当且仅当 $u$ 不是 $V'$ 的根，且满足 $v \\in V', (u,v) \\in E'$ 的 $v$ 的数量为 $1$。\n\n求一个合法点集 $S$，**满足其根节点到其任意一个叶子的路径上，每个点的点权顺次相接为一个合法的括号序列**，并**最大化** $|S|$。\n\n我们通过如下规则定义一个合法的括号序列：\n\n- 空串（即长度为 $0$ 的串）是一个合法的括号序列。\n\n- 若串 $\\text{A,B}$ 都是合法的括号序列，则字符串 $\\text{AB}$ （即将字符串 $\\text{A}$ 与 $\\text{B}$ 按顺序拼接起来）也是合法的括号序列。\n\n- 若串 $\\text{A}$ 是合法的括号序列，则字符串 $\\text{(A)}$ 是一个合法的括号序列。\n\n你需要输出符合要求的最大 $|S|$。", "inputFormat": "第一行输入一个正整数 $n$ 表示树上结点个数。\n\n第二行输入一个长度为 $n$ 的字符串 $c$。$c_i$ 为 ``(`` 表示这个结点上有一个标志着记忆开始的碎片，$c_i$ 为 ``)`` 表示这个结点上有一个标志着记忆终结的碎片。\n\n接下来 $n-1$ 行，每行输入两个正整数 $u,v$，表示结点 $u,v$ 之间有一条边。", "outputFormat": "输出一行一个整数，表示答案。", "hint": "**样例解释**\n\n![](https://s1.ax1x.com/2023/08/07/pPEj56K.png)\n\n蝴蝶经过的最大合法点集 $S$ 为 $\\{1,2,3\\}$。\n\n![](https://s1.ax1x.com/2023/08/07/pPEv90g.png)\n\n蝴蝶经过的最大合法点集 $S$ 为 $\\{1,2,3,5,7\\}$。\n\n**数据范围**\n\n**本题采用捆绑测试**。\n\n| $\\text{Subtask}$ | $n\\le$ | 特殊性质 | 分值 |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| $1$ | $20$ |  | $5$ |\n| $2$ | $3000$ |  | $20$ |\n| $3$ | $5\\times10^5$ | $\\text{A}$ | $15$  |\n| $4$ | $5\\times10^5$ | $\\text{B}$ |  $10$ |\n| $5$ | $2\\times10^5$ |  | $15$ |\n| $6$ | $5\\times10^5$ |  | $35$ |\n\n特殊性质 $\\text{A}$：保证树退化成一条链（不保证 $1$ 号节点为其一个端点）。\n\n特殊性质 $\\text{B}$：保证原树上任意结点到叶子的路径上右括号数量不少于左括号数量。\n\n对于 $100\\%$ 的数据满足 $1\\le n\\le 5\\times 10^5$，$1\\le u,v \\le n$，$c_i$ 为 ``(`` 或 ``)``。", "locale": "zh-CN"}}}
{"pid": "P9656", "type": "P", "difficulty": 2, "samples": [["1\n2\n4 3\n2 1", "4 3 1 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["模拟", "2021", "Special Judge", "O2优化", "ICPC", "Ad-hoc", "澳门"], "title": "[ICPC 2021 Macao R] So I'll Max Out My Constructive Algorithm Skills", "background": "", "description": "BaoBao the Witch is stuck in a maze with $n$ rows and $n$ columns, where the height of the cell in the $i$-th row and the $j$-th column is $h_{i,j}$. To get out of the maze, BaoBao has to find a path which passes through each cell exactly once. Each time she can only move into the neighboring cell sharing a same edge with the current one. But as we know, BaoBao is super lazy, so every time when she climbs up (that is to say, moving from a cell with a smaller height to another with a larger height) her happiness value will decrease. As her helping hand, your task is to find a valid path so that when moving along the path, the number of times BaoBao climbs up will not be more than the number of times she climbs down.\n\nMore formally, you need to find a sequence $(x_1, y_1), (x_2, y_2), \\cdots, (x_{n^2}, y_{n^2})$ such that:\n- For all $1 \\le i \\le n^2$, $ 1 \\le x_i, y_i \\le n$;\n- For all $1 \\le i, j \\le n^2, i \\neq j$, $ (x_i, y_i) \\neq (x_j, y_j)$;\n- For all $2 \\le i \\le n^2$, $|x_i - x_{i-1}| + |y_i - y_{i-1}| = 1$;\n- $\\sum\\limits_{i=2}^{n^2}{[h_{x_{i-1}, y_{i-1}} < h_{x_i, y_i}]} \\le \\sum\\limits_{i=2}^{n^2}{[h_{x_{i-1}, y_{i-1}} > h_{x_i, y_i}]}$, where $[P]$ equals $1$ when $P$ is true, and equals $0$ when it is false.\n\nAdditionally, you discover that the heights in all cells are a permutation of $n^2$, so you just need to output the height of each cell in a valid path.\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\le T \\le 100$) indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($2 \\le n \\le 64$) indicating the size of the maze.\n\nFor the following $n$ lines, the $i$-th line contains $n$ integers $h_{i, 1}, h_{i, 2}, \\cdots, h_{i,n}$ ($1 \\le h_{i, j} \\le n^2$) where $h_{i,j}$ indicates the height of the cell in the $i$-th row and the $j$-th column. It's guaranteed that all integers in the input make up a permutation of $n^2$.", "outputFormat": "For each test case output one line containing $n^2$ separated by a space indicating the heights of each cell in a valid path. If there are multiple valid answers you can output any of them. It's easy to prove that an answer always exists.\n\nPlease, DO NOT output extra spaces at the end of each line, or your answer may be considered incorrect!", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Macao R] So I'll Max Out My Constructive Algorithm Skills", "background": "", "description": "BaoBao the Witch is stuck in a maze with $n$ rows and $n$ columns, where the height of the cell in the $i$-th row and the $j$-th column is $h_{i,j}$. To get out of the maze, BaoBao has to find a path which passes through each cell exactly once. Each time she can only move into the neighboring cell sharing a same edge with the current one. But as we know, BaoBao is super lazy, so every time when she climbs up (that is to say, moving from a cell with a smaller height to another with a larger height) her happiness value will decrease. As her helping hand, your task is to find a valid path so that when moving along the path, the number of times BaoBao climbs up will not be more than the number of times she climbs down.\n\nMore formally, you need to find a sequence $(x_1, y_1), (x_2, y_2), \\cdots, (x_{n^2}, y_{n^2})$ such that:\n- For all $1 \\le i \\le n^2$, $ 1 \\le x_i, y_i \\le n$;\n- For all $1 \\le i, j \\le n^2, i \\neq j$, $ (x_i, y_i) \\neq (x_j, y_j)$;\n- For all $2 \\le i \\le n^2$, $|x_i - x_{i-1}| + |y_i - y_{i-1}| = 1$;\n- $\\sum\\limits_{i=2}^{n^2}{[h_{x_{i-1}, y_{i-1}} < h_{x_i, y_i}]} \\le \\sum\\limits_{i=2}^{n^2}{[h_{x_{i-1}, y_{i-1}} > h_{x_i, y_i}]}$, where $[P]$ equals $1$ when $P$ is true, and equals $0$ when it is false.\n\nAdditionally, you discover that the heights in all cells are a permutation of $n^2$, so you just need to output the height of each cell in a valid path.\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\le T \\le 100$) indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($2 \\le n \\le 64$) indicating the size of the maze.\n\nFor the following $n$ lines, the $i$-th line contains $n$ integers $h_{i, 1}, h_{i, 2}, \\cdots, h_{i,n}$ ($1 \\le h_{i, j} \\le n^2$) where $h_{i,j}$ indicates the height of the cell in the $i$-th row and the $j$-th column. It's guaranteed that all integers in the input make up a permutation of $n^2$.", "outputFormat": "For each test case output one line containing $n^2$ separated by a space indicating the heights of each cell in a valid path. If there are multiple valid answers you can output any of them. It's easy to prove that an answer always exists.\n\nPlease, DO NOT output extra spaces at the end of each line, or your answer may be considered incorrect!", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Macao R] So I'll Max Out My Constructive Algorithm Skills", "background": "", "description": "宝宝女巫被困在一个 $n$ 行 $n$ 列的迷宫中，其中第 $i$ 行第 $j$ 列的单元格高度为 $h_{i,j}$。要走出迷宫，宝宝必须找到一条路径，该路径穿过每个单元格恰好一次。每次她只能移动到与当前单元格共享边的相邻单元格。但是众所周知，宝宝非常懒，所以每当她爬升（即从高度较低的单元格移动到高度较高的单元格）时，她的幸福值会减少。作为她的帮手，你的任务是找到一条有效的路径，使得沿着路径移动时，宝宝爬升的次数不多于她下降的次数。\n\n更正式地说，你需要找到一个序列 $(x_1, y_1), (x_2, y_2), \\cdots, (x_{n^2}, y_{n^2})$，使得：\n- 对于所有的 $1 \\le i \\le n^2$，$ 1 \\le x_i, y_i \\le n$；\n- 对于所有的 $1 \\le i, j \\le n^2, i \\neq j$，$ (x_i, y_i) \\neq (x_j, y_j)$；\n- 对于所有的 $2 \\le i \\le n^2$，$|x_i - x_{i-1}| + |y_i - y_{i-1}| = 1$；\n- $\\sum\\limits_{i=2}^{n^2}{[h_{x_{i-1}, y_{i-1}} < h_{x_i, y_i}]} \\le \\sum\\limits_{i=2}^{n^2}{[h_{x_{i-1}, y_{i-1}} > h_{x_i, y_i}]}$，其中 $[P]$ 当 $P$ 为真时等于 $1$，当为假时等于 $0$。\n\n此外，你发现所有单元格的高度都是 $n^2$ 的排列，所以你只需要输出有效路径中每个单元格的高度。", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$（$1 \\le T \\le 100$），表示测试用例的数量。对于每个测试用例：\n\n第一行包含一个整数 $n$（$2 \\le n \\le 64$），表示迷宫的大小。\n\n接下来的 $n$ 行，第 $i$ 行包含 $n$ 个整数 $h_{i, 1}, h_{i, 2}, \\cdots, h_{i,n}$（$1 \\le h_{i, j} \\le n^2$），其中 $h_{i,j}$ 表示第 $i$ 行第 $j$ 列单元格的高度。保证输入中的所有整数构成 $n^2$ 的排列。", "outputFormat": "对于每个测试用例，输出一行，包含 $n^2$ 个由空格分隔的整数，表示有效路径中每个单元格的高度。如果有多个有效答案，你可以输出其中任何一个。很容易证明答案总是存在。\n\n请不要在每行的末尾输出多余的空格，否则你的答案可能会被认为不正确！\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9657", "type": "P", "difficulty": 7, "samples": [["3", "*0*\n011\n8\n**1\n101\n7"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2021", "Special Judge", "O2优化", "前缀和", "ICPC", "澳门"], "title": "[ICPC 2021 Macao R] the Matching System", "background": "", "description": "As the leader of the safety department, you are asked to check an ancient matching system in your company. \n\nThe system is fed with two strings, a to-be-matched string and a pattern string, and will determine whether the former can match the latter. The former string is a strict binary string(i.e., contains only $\\textbf{0}$ and $\\textbf{1}$), and the latter string consists of four types of characters $\\textbf{0}$, $\\textbf{1}$, $\\textbf{*}$, $^$, where $\\textbf{*}$ means match zero or more arbitrary binary characters, and $^$ means match exactly one binary character. \n\nThe system has two matching methods: maximum matching and minimum matching.\n\nConsider the starting positions of the two strings. The maximum matching method will make different decisions based on the current character of the pattern string:\n- $\\textbf{*}$: The system will enumerate $i$ from $L$ to $0$, where $L$ is the remaining length of the to-be-matched string. Before each enumeration starts, the system consumes 1 unit of energy. Then it temporarily assumes that the current $\\textbf{*}$ in the pattern string matches the consecutive $i$ characters in the to-be-matched string, and tries to match the remaining positions of two strings recursively. As long as one attempt is successful, the system will give up the remaining enumeration and stop the whole system. Otherwise, it will try the next enumeration until all attempts are tried and finally return to the previous $\\textbf{*}$ enumeration.\n- $\\textbf{0,1}$: The system will stop and return to the previous $\\textbf{*}$ enumeration if the to-be-matched string has been exhausted. Otherwise, it consumes $1$ unit of energy to compare the current characters between the pattern string and the to-be-matched string. It will continue analyzing the remaining positions of these two strings if the result is the same, otherwise, return back to the previous $\\textbf{*}$ enumeration.\n- $^$: The system will stop and return to the previous $\\textbf{*}$ enumeration if the to-be-matched string has been exhausted. Otherwise, it consumes $1$ unit of energy and moves on of two strings.\n\nWhen the pattern string is exhausted, the system will check the to-be-matched string at the same time. It will return ``Yes`` and stop the whole process if the to-be-matched string is also exhausted, otherwise, it will return to the previous $\\textbf{*}$ enumeration. After all attempts are tried and no matching method is found, the system will eventually return ``No``.\n\nMinimum matching does a similar thing except for the enumeration order of $\\textbf{*}$ (i.e., enumerate $i$ from $0$ to $L$).\n\nThese two matching methods seem not very effective, so you want to hack them. Please construct both a pattern string and a to-be-matched string of length $n$ for each matching method, so that the system answers ``Yes`` and the energy consumption is as large as possible.\n", "inputFormat": "There is only one test case in each test file.\n\nThe first and only line contains an integer $n$ ($1 \\le n \\le 10^3$) indicating the length of strings need to be constructed.", "outputFormat": "Please output the pattern string, the to-be-matched string, and the energy cost for the maximum matching method in the first $3$ lines. Then output the pattern string, the to-be-matched string, and the energy cost for the minimum matching method in the next $3$ lines.\n\nIf there are multiple constructing ways, you can output any of them.\n\nThe energy cost may be very large, so you need to output the value modulo $(10^9+7)$. Note that this is only for your convenience and you need to maximize the energy cost before the modulus.", "hint": "**【题目描述】**\n\n作为安全部门的负责人，你被要求检查公司的一个古老匹配系统。\n\n该系统输入两个字符串，一个待匹配字符串和一个模式字符串，并确定前者是否能匹配后者。前者字符串是严格的二进制字符串（即仅包含 $\\textbf{0}$ 和 $\\textbf{1}$），而后者字符串由四种类型的字符组成 $\\textbf{0}$、$\\textbf{1}$、$\\textbf{*}$ 和 $^$，其中 $\\textbf{*}$ 表示匹配零个或多个任意二进制字符，$^$ 表示匹配恰好一个二进制字符。\n\n该系统有两种匹配方法：最大匹配和最小匹配。\n\n考虑两个字符串的起始位置。最大匹配方法将根据模式字符串的当前字符做出不同的决定：\n- $\\textbf{*}$: 系统将从 $L$ 到 $0$ 枚举 $i$，其中 $L$ 是待匹配字符串的剩余长度。在每次枚举开始之前，系统消耗 1 单位的能量。然后，它临时假设模式字符串中的当前 $\\textbf{*}$ 匹配待匹配字符串中的连续 $i$ 个字符，并尝试递归地匹配两个字符串的剩余位置。只要有一次尝试成功，系统将放弃剩余的枚举并停止整个系统。否则，它将尝试下一次枚举，直到所有尝试都尝试完毕，最后返回到先前的 $\\textbf{*}$ 枚举。\n- $\\textbf{0,1}$: 如果待匹配字符串已经耗尽，则系统将停止并返回到先前的 $\\textbf{*}$ 枚举。否则，它将消耗 $1$ 单位的能量来比较模式字符串和待匹配字符串之间的当前字符。如果结果相同，它将继续分析这两个字符串的剩余位置，否则，返回到先前的 $\\textbf{*}$ 枚举。\n- $^$: 如果待匹配字符串已经耗尽，则系统将停止并返回到先前的 $\\textbf{*}$ 枚举。否则，它将消耗 $1$ 单位的能量并继续分析两个字符串。\n\n当模式字符串耗尽时，系统将同时检查待匹配字符串。如果待匹配字符串也已经耗尽，则系统将返回“是”并停止整个过程，否则，它将返回到先前的 $\\textbf{*}$ 枚举。在尝试了所有尝试并找不到匹配方法后，系统最终将返回“否”。\n\n最小匹配执行类似的操作，除了 $\\textbf{*}$ 的枚举顺序（即从 $0$ 到 $L$ 枚举 $i$）。\n\n这两种匹配方法似乎不太有效，所以你想黑掉它们。请为每种匹配方法构造一个长度为 $n$ 的模式字符串和待匹配字符串，使得系统返回“是”，能量消耗尽可能大。\n\n**【输入格式】**\n\n每个测试文件中只有一个测试用例。\n\n第一行仅包含一个整数 $n$（$1 \\le n \\le 10^3$），表示需要构造的字符串的长度。\n\n请输出最大匹配方法的模式字符串、待匹配字符串和能量消耗的前 $3$ 行。然后输出最小匹配方法的模式字符串、待匹配字符串和能量消耗的后 $3$ 行。\n\n**【输出格式】**\n\n如果有多种构造方式，你可以输出任何一种。\n\n能量消耗可能非常大，所以你需要输出取模 $(10^9+7)$ 后的值。请注意，这仅供您方便，您需要在取模之前最大化能量消耗。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Macao R] the Matching System", "background": "", "description": "As the leader of the safety department, you are asked to check an ancient matching system in your company. \n\nThe system is fed with two strings, a to-be-matched string and a pattern string, and will determine whether the former can match the latter. The former string is a strict binary string(i.e., contains only $\\textbf{0}$ and $\\textbf{1}$), and the latter string consists of four types of characters $\\textbf{0}$, $\\textbf{1}$, $\\textbf{*}$, $^$, where $\\textbf{*}$ means match zero or more arbitrary binary characters, and $^$ means match exactly one binary character. \n\nThe system has two matching methods: maximum matching and minimum matching.\n\nConsider the starting positions of the two strings. The maximum matching method will make different decisions based on the current character of the pattern string:\n- $\\textbf{*}$: The system will enumerate $i$ from $L$ to $0$, where $L$ is the remaining length of the to-be-matched string. Before each enumeration starts, the system consumes 1 unit of energy. Then it temporarily assumes that the current $\\textbf{*}$ in the pattern string matches the consecutive $i$ characters in the to-be-matched string, and tries to match the remaining positions of two strings recursively. As long as one attempt is successful, the system will give up the remaining enumeration and stop the whole system. Otherwise, it will try the next enumeration until all attempts are tried and finally return to the previous $\\textbf{*}$ enumeration.\n- $\\textbf{0,1}$: The system will stop and return to the previous $\\textbf{*}$ enumeration if the to-be-matched string has been exhausted. Otherwise, it consumes $1$ unit of energy to compare the current characters between the pattern string and the to-be-matched string. It will continue analyzing the remaining positions of these two strings if the result is the same, otherwise, return back to the previous $\\textbf{*}$ enumeration.\n- $^$: The system will stop and return to the previous $\\textbf{*}$ enumeration if the to-be-matched string has been exhausted. Otherwise, it consumes $1$ unit of energy and moves on of two strings.\n\nWhen the pattern string is exhausted, the system will check the to-be-matched string at the same time. It will return ``Yes`` and stop the whole process if the to-be-matched string is also exhausted, otherwise, it will return to the previous $\\textbf{*}$ enumeration. After all attempts are tried and no matching method is found, the system will eventually return ``No``.\n\nMinimum matching does a similar thing except for the enumeration order of $\\textbf{*}$ (i.e., enumerate $i$ from $0$ to $L$).\n\nThese two matching methods seem not very effective, so you want to hack them. Please construct both a pattern string and a to-be-matched string of length $n$ for each matching method, so that the system answers ``Yes`` and the energy consumption is as large as possible.\n", "inputFormat": "There is only one test case in each test file.\n\nThe first and only line contains an integer $n$ ($1 \\le n \\le 10^3$) indicating the length of strings need to be constructed.", "outputFormat": "Please output the pattern string, the to-be-matched string, and the energy cost for the maximum matching method in the first $3$ lines. Then output the pattern string, the to-be-matched string, and the energy cost for the minimum matching method in the next $3$ lines.\n\nIf there are multiple constructing ways, you can output any of them.\n\nThe energy cost may be very large, so you need to output the value modulo $(10^9+7)$. Note that this is only for your convenience and you need to maximize the energy cost before the modulus.", "hint": "**【题目描述】**\n\n作为安全部门的负责人，你被要求检查公司的一个古老匹配系统。\n\n该系统输入两个字符串，一个待匹配字符串和一个模式字符串，并确定前者是否能匹配后者。前者字符串是严格的二进制字符串（即仅包含 $\\textbf{0}$ 和 $\\textbf{1}$），而后者字符串由四种类型的字符组成 $\\textbf{0}$、$\\textbf{1}$、$\\textbf{*}$ 和 $^$，其中 $\\textbf{*}$ 表示匹配零个或多个任意二进制字符，$^$ 表示匹配恰好一个二进制字符。\n\n该系统有两种匹配方法：最大匹配和最小匹配。\n\n考虑两个字符串的起始位置。最大匹配方法将根据模式字符串的当前字符做出不同的决定：\n- $\\textbf{*}$: 系统将从 $L$ 到 $0$ 枚举 $i$，其中 $L$ 是待匹配字符串的剩余长度。在每次枚举开始之前，系统消耗 1 单位的能量。然后，它临时假设模式字符串中的当前 $\\textbf{*}$ 匹配待匹配字符串中的连续 $i$ 个字符，并尝试递归地匹配两个字符串的剩余位置。只要有一次尝试成功，系统将放弃剩余的枚举并停止整个系统。否则，它将尝试下一次枚举，直到所有尝试都尝试完毕，最后返回到先前的 $\\textbf{*}$ 枚举。\n- $\\textbf{0,1}$: 如果待匹配字符串已经耗尽，则系统将停止并返回到先前的 $\\textbf{*}$ 枚举。否则，它将消耗 $1$ 单位的能量来比较模式字符串和待匹配字符串之间的当前字符。如果结果相同，它将继续分析这两个字符串的剩余位置，否则，返回到先前的 $\\textbf{*}$ 枚举。\n- $^$: 如果待匹配字符串已经耗尽，则系统将停止并返回到先前的 $\\textbf{*}$ 枚举。否则，它将消耗 $1$ 单位的能量并继续分析两个字符串。\n\n当模式字符串耗尽时，系统将同时检查待匹配字符串。如果待匹配字符串也已经耗尽，则系统将返回“是”并停止整个过程，否则，它将返回到先前的 $\\textbf{*}$ 枚举。在尝试了所有尝试并找不到匹配方法后，系统最终将返回“否”。\n\n最小匹配执行类似的操作，除了 $\\textbf{*}$ 的枚举顺序（即从 $0$ 到 $L$ 枚举 $i$）。\n\n这两种匹配方法似乎不太有效，所以你想黑掉它们。请为每种匹配方法构造一个长度为 $n$ 的模式字符串和待匹配字符串，使得系统返回“是”，能量消耗尽可能大。\n\n**【输入格式】**\n\n每个测试文件中只有一个测试用例。\n\n第一行仅包含一个整数 $n$（$1 \\le n \\le 10^3$），表示需要构造的字符串的长度。\n\n请输出最大匹配方法的模式字符串、待匹配字符串和能量消耗的前 $3$ 行。然后输出最小匹配方法的模式字符串、待匹配字符串和能量消耗的后 $3$ 行。\n\n**【输出格式】**\n\n如果有多种构造方式，你可以输出任何一种。\n\n能量消耗可能非常大，所以你需要输出取模 $(10^9+7)$ 后的值。请注意，这仅供您方便，您需要在取模之前最大化能量消耗。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Macao R] the Matching System", "background": "", "description": "作为安全部门的负责人，你被要求检查公司的一古老匹配系统。\n\n该系统输入两个字符串，一个待匹配字符串和一个模式字符串，并确定前者是否能匹配后者。前者字符串是严格的二进制字符串（即仅包含 $\\textbf{0}$ 和 $\\textbf{1}$），而后者字符串由四种类型的字符组成：$\\textbf{0}$、$\\textbf{1}$、$\\textbf{*}$ 和 $^$，其中 $\\textbf{*}$ 表示匹配零个或多个任意二进制字符，$^$ 表示匹配恰好一个二进制字符。\n\n该系统有两种匹配方法：最大匹配和最小匹配。\n\n考虑两个字符串的起始位置。最大匹配方法将根据模式字符串的当前字符做出不同的决定：\n- $\\textbf{*}$: 系统将从 $L$ 到 $0$ 枚举 $i$，其中 $L$ 是待匹配字符串的剩余长度。在每次枚举开始之前，系统消耗 1 单位的能量。然后它暂时假设模式字符串中的当前 $\\textbf{*}$ 匹配待匹配字符串中的连续 $i$ 个字符，并尝试递归地匹配两个字符串的剩余位置。只要有一次尝试成功，系统将放弃剩余的枚举并停止整个系统。否则，它将尝试下一个枚举，直到所有尝试都被尝试完毕，最后返回到先前的 $\\textbf{*}$ 枚举。\n- $\\textbf{0,1}$: 如果待匹配字符串已经耗尽，系统将停止并返回到先前的 $\\textbf{*}$ 枚举。否则，它消耗 $1$ 单位的能量来比较模式字符串和待匹配字符串之间的当前字符。如果结果相同，它将继续分析这两个字符串的剩余位置，否则返回到先前的 $\\textbf{*}$ 枚举。\n- $^$: 如果待匹配字符串已经耗尽，系统将停止并返回到先前的 $\\textbf{*}$ 枚举。否则，它消耗 $1$ 单位的能量并继续分析两个字符串。\n\n当模式字符串耗尽时，系统将同时检查待匹配字符串。如果待匹配字符串也已经耗尽，系统将返回“是”并停止整个过程，否则，它将返回到先前的 $\\textbf{*}$ 枚举。在尝试了所有尝试并找不到匹配方法后，系统最终将返回“否”。\n\n最小匹配执行类似的操作，除了 $\\textbf{*}$ 的枚举顺序（即从 $0$ 到 $L$ 枚举 $i$）。\n\n这两种匹配方法似乎不太有效，所以你想黑掉它们。请为每种匹配方法构造一个长度为 $n$ 的模式字符串和待匹配字符串，使得系统返回“是”，能量消耗尽可能大。", "inputFormat": "每个测试文件中只有一个测试用例。\n\n第一行仅包含一个整数 $n$（$1 \\le n \\le 10^3$），表示需要构造的字符串的长度。", "outputFormat": "请输出最大匹配方法的模式字符串、待匹配字符串和能量消耗的前 $3$ 行。然后输出最小匹配方法的模式字符串、待匹配字符串和能量消耗的后 $3$ 行。\n\n如果有多种构造方式，你可以输出任何一种。\n\n能量消耗可能非常大，所以你需要输出取模 $(10^9+7)$ 后的值。请注意，这仅供你方便，你需要在取模之前最大化能量消耗。", "hint": "题目描述\n\n作为安全部门的负责人，你被要求检查公司的一古老匹配系统。\n\n该系统输入两个字符串，一个待匹配字符串和一个模式字符串，并确定前者是否能匹配后者。前者字符串是严格的二进制字符串（即仅包含 $\\textbf{0}$ 和 $\\textbf{1}$），而后者字符串由四种类型的字符组成：$\\textbf{0}$、$\\textbf{1}$、$\\textbf{*}$ 和 $^$，其中 $\\textbf{*}$ 表示匹配零个或多个任意二进制字符，$^$ 表示匹配恰好一个二进制字符。\n\n该系统有两种匹配方法：最大匹配和最小匹配。\n\n考虑两个字符串的起始位置。最大匹配方法将根据模式字符串的当前字符做出不同的决定：\n- $\\textbf{*}$: 系统将从 $L$ 到 $0$ 枚举 $i$，其中 $L$ 是待匹配字符串的剩余长度。在每次枚举开始之前，系统消耗 1 单位的能量。然后它暂时假设模式字符串中的当前 $\\textbf{*}$ 匹配待匹配字符串中的连续 $i$ 个字符，并尝试递归地匹配两个字符串的剩余位置。只要有一次尝试成功，系统将放弃剩余的枚举并停止整个系统。否则，它将尝试下一个枚举，直到所有尝试都被尝试完毕，最后返回到先前的 $\\textbf{*}$ 枚举。\n- $\\textbf{0,1}$: 如果待匹配字符串已经耗尽，系统将停止并返回到先前的 $\\textbf{*}$ 枚举。否则，它消耗 $1$ 单位的能量来比较模式字符串和待匹配字符串之间的当前字符。如果结果相同，它将继续分析这两个字符串的剩余位置，否则返回到先前的 $\\textbf{*}$ 枚举。\n- $^$: 如果待匹配字符串已经耗尽，系统将停止并返回到先前的 $\\textbf{*}$ 枚举。否则，它消耗 $1$ 单位的能量并继续分析两个字符串。\n\n当模式字符串耗尽时，系统将同时检查待匹配字符串。如果待匹配字符串也已经耗尽，系统将返回“是”并停止整个过程，否则，它将返回到先前的 $\\textbf{*}$ 枚举。在尝试了所有尝试并找不到匹配方法后，系统最终将返回“否”。\n\n最小匹配执行类似的操作，除了 $\\textbf{*}$ 的枚举顺序（即从 $0$ 到 $L$ 枚举 $i$）。\n\n这两种匹配方法似乎不太有效，所以你想黑掉它们。请为每种匹配方法构造一个长度为 $n$ 的模式字符串和待匹配字符串，使得系统返回“是”，能量消耗尽可能大。\n\n输入格式\n\n每个测试文件中只有一个测试用例。\n\n第一行仅包含一个整数 $n$（$1 \\le n \\le 10^3$），表示需要构造的字符串的长度。\n\n输出格式\n\n请输出最大匹配方法的模式字符串、待匹配字符串和能量消耗的前 $3$ 行。然后输出最小匹配方法的模式字符串、待匹配字符串和能量消耗的后 $3$ 行。\n\n如果有多种构造方式，你可以输出任何一种。\n\n能量消耗可能非常大，所以你需要输出取模 $(10^9+7)$ 后的值。请注意，这仅供你方便，你需要在取模之前最大化能量消耗。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9658", "type": "P", "difficulty": 5, "samples": [["3\n2\n1 0\n2 0\n3\n1 0\n0 1\n-1 -1\n5\n2 -1\n1 2\n-1 2\n-2 -1\n0 -2", "0\n1\n2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["计算几何", "2021", "O2优化", "叉积", "ICPC", "双指针 two-pointer", "澳门"], "title": "[ICPC 2021 Macao R] Laser Trap", "background": "", "description": "BaoBao is playing the famous game $\\textit{Elden Ring}$ these days. It's an open-world game in which you can control your character to travel from places to places. However, your character could also enter a trap and you need to figure out how to escape. Right now, BaoBao's character is stuck in a 2-dimensional plane with deadly lasers. There are $n$ laser generators (each can be regarded as a point) shooting laser beams between every pair of them (so there are $\\frac{n(n-1)}{2}$ laser beams in total). The beams start and end at generator points and do not stretch to infinity.\n\nStarting at point $(0,0)$, BaoBao wants to escape to point $(10^{10^{10^{10^{10}}}}, 10^{10^{10^{10^{10}}}})$ without touching any laser beam or generator. In order to do so, BaoBao can ask her friend DreamGrid to remove any number of laser generators, together with any laser beam that starts or ends at these generators. Output the minimum number of laser generators that need to be erased for the escape.\n\nNote that BaoBao does not need to move in a specific direction to escape. Her escaping route can even be a curve if necessary.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^6$) indicating the number of laser generators.\n\nFor the following $n$ lines, the $i$-th line contains two integers $x_i$ and $y_i$ ($-10^9 \\le x_i, y_i \\le 10^9$) indicating the location of the $i$-th laser generator.\n\nIt is guaranteed that no two generators coincide, and no laser beam or generator will touch $(0,0)$.\n\nIt is also guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer indicating the minimum number of generators that need to be removed.", "hint": "The second and the third sample test cases are shown below. Solid dots and lines represent the remaining laser generators and beams, while hollow dots and dashed lines represent the removed laser generators and beams. The arrow is the escaping route.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b0sz7cm0.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dwcsdmj6.png)", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Macao R] Laser Trap", "background": "", "description": "BaoBao is playing the famous game $\\textit{Elden Ring}$ these days. It's an open-world game in which you can control your character to travel from places to places. However, your character could also enter a trap and you need to figure out how to escape. Right now, BaoBao's character is stuck in a 2-dimensional plane with deadly lasers. There are $n$ laser generators (each can be regarded as a point) shooting laser beams between every pair of them (so there are $\\frac{n(n-1)}{2}$ laser beams in total). The beams start and end at generator points and do not stretch to infinity.\n\nStarting at point $(0,0)$, BaoBao wants to escape to point $(10^{10^{10^{10^{10}}}}, 10^{10^{10^{10^{10}}}})$ without touching any laser beam or generator. In order to do so, BaoBao can ask her friend DreamGrid to remove any number of laser generators, together with any laser beam that starts or ends at these generators. Output the minimum number of laser generators that need to be erased for the escape.\n\nNote that BaoBao does not need to move in a specific direction to escape. Her escaping route can even be a curve if necessary.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^6$) indicating the number of laser generators.\n\nFor the following $n$ lines, the $i$-th line contains two integers $x_i$ and $y_i$ ($-10^9 \\le x_i, y_i \\le 10^9$) indicating the location of the $i$-th laser generator.\n\nIt is guaranteed that no two generators coincide, and no laser beam or generator will touch $(0,0)$.\n\nIt is also guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer indicating the minimum number of generators that need to be removed.", "hint": "The second and the third sample test cases are shown below. Solid dots and lines represent the remaining laser generators and beams, while hollow dots and dashed lines represent the removed laser generators and beams. The arrow is the escaping route.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b0sz7cm0.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dwcsdmj6.png)", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Macao R] Laser Trap", "background": "", "description": "最近，BaoBao 正在玩著名的游戏 $Elden Ring$。这是一款开放世界游戏，你可以控制角色在各个地方旅行。然而，你的角色也可能会进入陷阱，你需要想办法逃脱。现在，BaoBao 的角色被困在一个有致命激光的二维平面上。平面上有 $n$ 个激光发生器（每个可以看作一个点），它们之间的每一对都会发射激光束（因此总共有 $\\frac{n(n-1)}{2}$ 条激光束）。这些激光束从发生器点开始并在发生器点结束，不会延伸到无限远。\n\n从点 $(0,0)$ 开始，BaoBao 想要逃到点 $(10^{10^{10^{10^{10}}}}, 10^{10^{10^{10^{10}}}})$，而不触碰任何激光束或发生器。为了做到这一点，BaoBao 可以请求她的朋友 DreamGrid 移除任意数量的激光发生器，以及从这些发生器开始或结束的任何激光束。输出为逃脱所需移除的最小激光发生器数量。\n\n注意，BaoBao 不需要沿特定方向移动以逃脱。如果有必要，她的逃生路线甚至可以是曲线。", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行包含一个整数 $n$ ($1 \\le n \\le 10^6$)，表示激光发生器的数量。\n\n接下来的 $n$ 行中，第 $i$ 行包含两个整数 $x_i$ 和 $y_i$ ($-10^9 \\le x_i, y_i \\le 10^9$)，表示第 $i$ 个激光发生器的位置。\n\n保证没有两个发生器重合，并且没有激光束或发生器会接触到 $(0,0)$。\n\n还保证所有测试用例的 $n$ 的总和不超过 $10^6$。", "outputFormat": "对于每个测试用例，输出一行，包含一个整数，表示需要移除的最小发生器数量。", "hint": "第二个和第三个样例测试用例如下所示。实心点和线代表剩余的激光发生器和光束，而空心点和虚线代表被移除的激光发生器和光束。箭头是逃生路线。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b0sz7cm0.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dwcsdmj6.png)\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
