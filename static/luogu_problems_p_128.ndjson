{"pid": "P3594", "type": "P", "difficulty": 5, "samples": [["9 7 2\n3 4 1 9 4 1 7 1 3", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2015", "二分", "单调队列", "POI（波兰）", "双指针 two-pointer"], "title": "[POI 2015 R3] 狼坑 Trous de loup", "background": "", "description": "给定一个长度为 $n$ 的序列，你有一次机会选中一段连续的长度不超过 $d$ 的区间，将里面所有数字全部修改为 $0$。请找到最长的一段连续区间，使得该区间内所有数字之和不超过 $p$。", "inputFormat": "输入的第一行包含三个整数，分别代表 $n,p,d$。\n\n第二行包含 $n$ 个整数，第 $i$ 个整数代表序列中第 $i$ 个数 $w_i$。", "outputFormat": "包含一行一个整数，即修改后能找到的最长的符合条件的区间的长度。\n", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$1 \\le d \\le n \\le 2 \\times 10^6$，$0 \\le p \\le 10^{16}$，$1 \\leq w_i \\leq 10^9$。\n\n----\n\n原题名称：Wilcze doły。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R3] Wolf Pits (Trous de loup)", "background": "", "description": "Given a sequence of length $n$, you have one chance to choose a contiguous segment of length at most $d$ and change all numbers inside it to $0$. Find the longest contiguous segment such that the sum of all numbers within this segment does not exceed $p$.", "inputFormat": "The first line contains three integers, $n, p, d$.\n\nThe second line contains $n$ integers; the $i$-th integer is $w_i$, the $i$-th number in the sequence.", "outputFormat": "Output a single integer, the length of the longest valid segment after the modification.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, $1 \\le d \\le n \\le 2 \\times 10^6$, $0 \\le p \\le 10^{16}$, $1 \\leq w_i \\leq 10^9$.\n\n----\n\nOriginal title: Wilcze doły.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R3] 狼坑 Trous de loup", "background": "", "description": "给定一个长度为 $n$ 的序列，你有一次机会选中一段连续的长度不超过 $d$ 的区间，将里面所有数字全部修改为 $0$。请找到最长的一段连续区间，使得该区间内所有数字之和不超过 $p$。", "inputFormat": "输入的第一行包含三个整数，分别代表 $n,p,d$。\n\n第二行包含 $n$ 个整数，第 $i$ 个整数代表序列中第 $i$ 个数 $w_i$。", "outputFormat": "包含一行一个整数，即修改后能找到的最长的符合条件的区间的长度。\n", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$1 \\le d \\le n \\le 2 \\times 10^6$，$0 \\le p \\le 10^{16}$，$1 \\leq w_i \\leq 10^9$。\n\n----\n\n原题名称：Wilcze doły。", "locale": "zh-CN"}}}
{"pid": "P3596", "type": "P", "difficulty": 6, "samples": [["6\n1 2\n2 3\n2 4\n4 5\n6 5", "3 4 2 2 5\n5 2 1 1 6"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2015", "POI（波兰）", "Special Judge", "树形 DP", "树的直径"], "title": "[POI 2015 R3] 高速公路现代化 Highway modernization", "background": "", "description": "给定一棵无根树，边权都是 $1$，请去掉一条边并加上一条新边，定义直径为最远的两个点的距离，请输出所有可能的新树的直径的最小值和最大值。\n", "inputFormat": "第一行包含一个正整数 $n$，表示这棵树的点数。  \n接下来 $n-1$ 行，每行包含两个正整数，表示 $u,v$ 之间有一条边。", "outputFormat": "第一行输出五个正整数 $k,x_1,y_1,x_2,y_2$，其中 $k$表示新树直径的最小值，$x_1,y_1$ 表示这种情况下要去掉的边的两端点，$x_2,y_2$ 表示这种情况下要加上的边的两端点。\n\n第二行输出五个正整数 $k,x_1,y_1,x_2,y_2$，其中 $k$ 表示新树直径的最大值，$x_1,y_1$ 表示这种情况下要去掉的边的两端点，$x_2,y_2$ 表示这种情况下要加上的边的两端点。若有多组最优解，输出任意一组。", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 5 \\times 10 ^ 5$。\n\n----\n\n原题名称：Modernizacja autostrady。\n\n感谢 @cn：苏卿念 提供 spj", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R3] Highway Modernization", "background": "", "description": "You are given an unrooted tree with all edge weights equal to $1$. Remove one edge and add one new edge. The diameter is defined as the distance between the farthest pair of nodes. Among all possible new trees obtained this way, output the minimum and the maximum possible diameter.", "inputFormat": "The first line contains a positive integer $n$, the number of nodes in the tree.  \nThe next $n-1$ lines each contain two positive integers, indicating that there is an edge between $u$ and $v$.", "outputFormat": "On the first line, output five positive integers $k, x_1, y_1, x_2, y_2$, where $k$ is the minimum possible diameter of the new tree, $(x_1, y_1)$ are the endpoints of the edge to remove in this case, and $(x_2, y_2)$ are the endpoints of the edge to add in this case.\n\nOn the second line, output five positive integers $k, x_1, y_1, x_2, y_2$, where $k$ is the maximum possible diameter of the new tree, $(x_1, y_1)$ are the endpoints of the edge to remove in this case, and $(x_2, y_2)$ are the endpoints of the edge to add in this case. If there are multiple optimal solutions, output any one of them.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, $2 \\le n \\le 5 \\times 10^5$.\n\n----\n\nOriginal title: Modernizacja autostrady.\n\nThanks to @cn：苏卿念 for providing the spj.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R3] 高速公路现代化 Highway modernization", "background": "", "description": "给定一棵无根树，边权都是 $1$，请去掉一条边并加上一条新边，定义直径为最远的两个点的距离，请输出所有可能的新树的直径的最小值和最大值。\n", "inputFormat": "第一行包含一个正整数 $n$，表示这棵树的点数。  \n接下来 $n-1$ 行，每行包含两个正整数，表示 $u,v$ 之间有一条边。", "outputFormat": "第一行输出五个正整数 $k,x_1,y_1,x_2,y_2$，其中 $k$表示新树直径的最小值，$x_1,y_1$ 表示这种情况下要去掉的边的两端点，$x_2,y_2$ 表示这种情况下要加上的边的两端点。\n\n第二行输出五个正整数 $k,x_1,y_1,x_2,y_2$，其中 $k$ 表示新树直径的最大值，$x_1,y_1$ 表示这种情况下要去掉的边的两端点，$x_2,y_2$ 表示这种情况下要加上的边的两端点。若有多组最优解，输出任意一组。", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 5 \\times 10 ^ 5$。\n\n----\n\n原题名称：Modernizacja autostrady。\n\n感谢 @cn：苏卿念 提供 spj", "locale": "zh-CN"}}}
{"pid": "P3597", "type": "P", "difficulty": 6, "samples": [["6 6 11\n1 2 1\n2 3 2\n3 4 2\n4 5 1\n5 3 1\n4 6 3", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "POI（波兰）", "矩阵乘法"], "title": "[POI 2015 R3] 旅行 Trips", "background": "", "description": "给定一张 $n$ 个点 $m$ 条边的带权有向图，每条边的边权只可能是 $1$，$2$，$3$ 中的一种。\n\n将所有可能的路径按路径长度排序，请输出第 $k$ 小的路径的长度，注意路径不一定是简单路径，即可以重复走同一个点。", "inputFormat": "第一行包含三个整数 $n,m,k$（$1\\le n\\le 40$，$1\\le m\\le 1000$，$1\\le k\\le 10^{18}$）。\n\n接下来 $m$ 行，每行三个整数 $u,v,c$（$1\\leq u,v\\leq n$，$u\\neq v$，$1\\le c\\le 3$），表示从 $u$ 出发有一条到 $v$ 的单向边，边长为 $c$。\n\n**可能有重边**。", "outputFormat": "包含一行一个正整数，即第 $k$ 短的路径的长度，如果不存在，输出 $-1$。", "hint": "**【样例解释】**\n\n长度为 $1$ 的路径有 $1\\to 2$，$5\\to 3$，$4\\to 5$。长度为 $2$ 的路径有 $2\\to3$，$3\\to4$，$4\\to5\\to3$。长度为 $3$ 的路径有 $4\\to6$，$1\\to2\\to3$，$3\\to4\\to5$，$5\\to3\\to4$。长度为 $4$ 的路径有 $5\\to3\\to4\\to5$。\n\n----\n\n原题名称：Wycieczki。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R3] Trips", "background": "", "description": "Given a weighted directed graph with $n$ vertices and $m$ edges, where each edge weight is one of $1$, $2$, or $3$.\n\nSort all possible paths by their total length and output the length of the $k$-th shortest path. Note that a path does not have to be simple; the same vertex may be visited multiple times.", "inputFormat": "The first line contains three integers $n, m, k$ ($1 \\le n \\le 40$, $1 \\le m \\le 1000$, $1 \\le k \\le 10^{18}$).\n\nEach of the next $m$ lines contains three integers $u, v, c$ ($1 \\le u, v \\le n$, $u \\ne v$, $1 \\le c \\le 3$), indicating there is a directed edge from $u$ to $v$ with length $c$.\n\n**Parallel edges may exist.**", "outputFormat": "Output a single positive integer: the length of the $k$-th shortest path. If it does not exist, output $-1$.", "hint": "Sample explanation:\n\nPaths of length $1$: $1\\to 2$, $5\\to 3$, $4\\to 5$. Paths of length $2$: $2\\to 3$, $3\\to 4$, $4\\to 5\\to 3$. Paths of length $3$: $4\\to 6$, $1\\to 2\\to 3$, $3\\to 4\\to 5$, $5\\to 3\\to 4$. Paths of length $4$: $5\\to 3\\to 4\\to 5$.\n\n----\n\nOriginal title: Wycieczki.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R3] 旅行 Trips", "background": "", "description": "给定一张 $n$ 个点 $m$ 条边的带权有向图，每条边的边权只可能是 $1$，$2$，$3$ 中的一种。\n\n将所有可能的路径按路径长度排序，请输出第 $k$ 小的路径的长度，注意路径不一定是简单路径，即可以重复走同一个点。", "inputFormat": "第一行包含三个整数 $n,m,k$（$1\\le n\\le 40$，$1\\le m\\le 1000$，$1\\le k\\le 10^{18}$）。\n\n接下来 $m$ 行，每行三个整数 $u,v,c$（$1\\leq u,v\\leq n$，$u\\neq v$，$1\\le c\\le 3$），表示从 $u$ 出发有一条到 $v$ 的单向边，边长为 $c$。\n\n**可能有重边**。", "outputFormat": "包含一行一个正整数，即第 $k$ 短的路径的长度，如果不存在，输出 $-1$。", "hint": "**【样例解释】**\n\n长度为 $1$ 的路径有 $1\\to 2$，$5\\to 3$，$4\\to 5$。长度为 $2$ 的路径有 $2\\to3$，$3\\to4$，$4\\to5\\to3$。长度为 $3$ 的路径有 $4\\to6$，$1\\to2\\to3$，$3\\to4\\to5$，$5\\to3\\to4$。长度为 $4$ 的路径有 $5\\to3\\to4\\to5$。\n\n----\n\n原题名称：Wycieczki。", "locale": "zh-CN"}}}
{"pid": "P3598", "type": "P", "difficulty": 6, "samples": [["3 5\n1 2 4 5 0", "44044"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "洛谷原创", "洛谷月赛"], "title": "Koishi Loves Number Theory", "background": "", "description": "Koishi 十分喜欢数论。\n\n\n她的朋友 Flandre 为了检测她和数论是不是真爱，给了她一个问题。\n\n\n已知 $f(n)=\\sum_{i=0}^nx^i$\n\n给定 $x$ 和 $N$ 个数 $a_i$，求 $\\mathrm{lcm}(f(a_1),f(a_2),...,f(a_N))$ 对 $10^9+7$ 取模。\n\n\n按照套路，呆萌的 Koishi 当然假装不会做了，于是她来向你请教这个问题，希望你能在 $1$ 秒内给她答案。\n", "inputFormat": "第一行包含两个整数 $x$ 和 $N$，接下来一行 $N$ 个整数表示 $a_i$。\n", "outputFormat": "一个整数，表示答案。\n", "hint": "$\\mathrm{lcm}$ 表示若干个数的**最小公倍数**。\n\n\n对于 $10\\%$ 的数据，$1\\leq N\\leq 100$，$0\\leq a_i\\leq 9$，$x=2$。\n\n对于另外 $20\\%$ 的数据，$1\\leq N\\leq 50$，$0\\leq a_i\\leq 100$，$2\\leq x\\leq 10$。\n\n对于另外 $30\\%$ 的数据，$1\\leq N\\leq 16$，$0\\leq a_i\\leq 10^9$，$2\\leq x\\leq 10^{18}$。\n\n对于 $100\\%$ 的数据，$1\\leq N\\leq 100$，$0\\leq a_i\\leq 10^9$，$2\\leq x\\leq 10^{18}$，且 $x\\not\\equiv 1\\pmod{10^9+7}$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Koishi Loves Number Theory", "background": "", "description": "Koishi loves number theory.\n\nHer friend Flandre, to check whether her love for number theory is true, gave her a problem.\n\nGiven $f(n)=\\sum_{i=0}^n x^i$.\n\nGiven $x$ and $N$ numbers $a_i$, compute $\\mathrm{lcm}(f(a_1),f(a_2),...,f(a_N))$ modulo $10^9+7$.\n\nAs usual, the naive Koishi pretended she could not solve it and came to ask you, hoping you can give the answer within 1 second.", "inputFormat": "The first line contains two integers $x$ and $N$. The next line contains $N$ integers representing $a_i$.", "outputFormat": "One integer, the answer.", "hint": "$\\mathrm{lcm}$ denotes the least common multiple of several numbers.\n\nConstraints:\n- For $10\\%$ of the testdata, $1 \\leq N \\leq 100$, $0 \\leq a_i \\leq 9$, $x=2$.\n- For another $20\\%$ of the testdata, $1 \\leq N \\leq 50$, $0 \\leq a_i \\leq 100$, $2 \\leq x \\leq 10$.\n- For another $30\\%$ of the testdata, $1 \\leq N \\leq 16$, $0 \\leq a_i \\leq 10^9$, $2 \\leq x \\leq 10^{18}$.\n- For $100\\%$ of the testdata, $1 \\leq N \\leq 100$, $0 \\leq a_i \\leq 10^9$, $2 \\leq x \\leq 10^{18}$, and $x \\not\\equiv 1 \\pmod{10^9+7}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Koishi Loves Number Theory", "background": "", "description": "Koishi 十分喜欢数论。\n\n\n她的朋友 Flandre 为了检测她和数论是不是真爱，给了她一个问题。\n\n\n已知 $f(n)=\\sum_{i=0}^nx^i$\n\n给定 $x$ 和 $N$ 个数 $a_i$，求 $\\mathrm{lcm}(f(a_1),f(a_2),...,f(a_N))$ 对 $10^9+7$ 取模。\n\n\n按照套路，呆萌的 Koishi 当然假装不会做了，于是她来向你请教这个问题，希望你能在 $1$ 秒内给她答案。\n", "inputFormat": "第一行包含两个整数 $x$ 和 $N$，接下来一行 $N$ 个整数表示 $a_i$。\n", "outputFormat": "一个整数，表示答案。\n", "hint": "$\\mathrm{lcm}$ 表示若干个数的**最小公倍数**。\n\n\n对于 $10\\%$ 的数据，$1\\leq N\\leq 100$，$0\\leq a_i\\leq 9$，$x=2$。\n\n对于另外 $20\\%$ 的数据，$1\\leq N\\leq 50$，$0\\leq a_i\\leq 100$，$2\\leq x\\leq 10$。\n\n对于另外 $30\\%$ 的数据，$1\\leq N\\leq 16$，$0\\leq a_i\\leq 10^9$，$2\\leq x\\leq 10^{18}$。\n\n对于 $100\\%$ 的数据，$1\\leq N\\leq 100$，$0\\leq a_i\\leq 10^9$，$2\\leq x\\leq 10^{18}$，且 $x\\not\\equiv 1\\pmod{10^9+7}$。\n", "locale": "zh-CN"}}}
{"pid": "P3599", "type": "P", "difficulty": 6, "samples": [["1 1\n8", "2 8 7 6 5 4 3 2 1"], ["2 1\n11", "2 1 2 3 5 10 6 7 4 9 8 11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "洛谷原创", "Special Judge", "构造", "洛谷月赛"], "title": "Koishi Loves Construction", "background": "", "description": "Koishi 决定走出幻想乡成为数学大师！\n\nFlandre 听说她数学学的很好，就给 Koishi 出了这样一道构造题：\n\nTask1：试判断能否构造并构造一个长度为 $n$ 的 $1 \\dots n$ 的排列，满足其 $n$ 个前缀和在模 $n$ 的意义下互不相同。\n\nTask2：试判断能否构造并构造一个长度为 $n$ 的 $1 \\dots n$ 的排列，满足其 $n$ 个前缀积在模 $n$ 的意义下互不相同。\n\n按照套路，Koishi 假装自己根本不会捉，就来找你帮忙辣。", "inputFormat": "第一行两个整数 $X$ 和 $T$，分别表示 Task 类型和测试点内的数据组数。\n\n接下来 $T$ 行，每行一个整数表示每组数据中的 $n$。", "outputFormat": "为了方便 SPJ 的编写，您需要**遵从以下格式**输出。\n\n\n对于每组数据仅包含**一行**输出：\n\n1. 如果您认为当前数据不存在符合题意的构造，只需输出一个整数 $0$。\n2. 如果您认为当前数据存在符合题意的构造却不会构造，只需输出一个整数 $1$。\n3.  如果您认为当前数据存在符合题意的构造并成功构造，则需要先输出一个整数 $2$，再输出 $n$ 个整数表示构造的方案。\n\n**每两个整数之间需要有空格作为分隔符**。", "hint": "对于每组数据：\n\n1. 如果您对于构造的存在性判断正确，您将会得到 $30\\%$ 的分数，若您的构造符合题意或者确实不存在符合题意的构造，您将会得到剩余的 $70\\%$ 的分数。\n2. 如果您对于构造的存在性判断不正确，您将不会得到任何分数。\n\n对于每组测试点，您的得分将是本组数据点中得分的最小值。\n\n测试点类型 $1$：$10$ 分，满足 $X = 1$，$1 \\leq n \\leq 10$。  \n测试点类型 $2$：$40$ 分，满足 $X = 1$，$1 \\leq n \\leq {10}^5$。  \n测试点类型 $3$：$10$ 分，满足 $X = 2$，$1 \\leq n \\leq 10$。  \n测试点类型 $4$：$40$ 分，满足 $X = 2$，$1 \\leq n \\leq {10}^5$。\n\n对于所有测试点，满足 $1 \\leq T \\leq 10$。", "locale": "zh-CN", "translations": {"en": {"title": "Koishi Loves Construction", "background": "", "description": "Koishi decided to leave Gensokyo and become a math master!\n\nFlandre heard that her math is excellent, so she gave Koishi the following construction problem:\n\nTask 1: Determine whether it is possible, and if so construct, a permutation of $1 \\dots n$ of length $n$ such that its $n$ prefix sums are pairwise distinct modulo $n$.\n\nTask 2: Determine whether it is possible, and if so construct, a permutation of $1 \\dots n$ of length $n$ such that its $n$ prefix products are pairwise distinct modulo $n$.\n\nAs usual, Koishi pretended she could not do it and came to ask you for help.", "inputFormat": "The first line contains two integers $X$ and $T$, denoting the task type and the number of test cases in the test point, respectively.\n\nThen follow $T$ lines, each containing one integer $n$ for a test case.", "outputFormat": "For the convenience of the SPJ, you must follow the format below.\n\nFor each test case, output exactly one line:\n\n1. If you believe no valid construction exists, output a single integer $0$.\n2. If you believe a valid construction exists but you cannot construct it, output a single integer $1$.\n3. If you believe a valid construction exists and you successfully construct it, first output a single integer $2$, then output $n$ integers giving your construction.\n\nSeparate every two integers with a space.", "hint": "For each test case:\n\n1. If your existence judgment is correct, you will receive $30\\%$ of the score. If your construction satisfies the requirements or there truly is no valid construction, you will receive the remaining $70\\%$.\n2. If your existence judgment is incorrect, you will receive no points.\n\nTest point type $1$: $10$ points, with $X = 1$, $1 \\leq n \\leq 10$.\nTest point type $2$: $40$ points, with $X = 1$, $1 \\leq n \\leq {10}^5$.\nTest point type $3$: $10$ points, with $X = 2$, $1 \\leq n \\leq 10$.\nTest point type $4$: $40$ points, with $X = 2$, $1 \\leq n \\leq {10}^5$.\n\nFor all test points, it holds that $1 \\leq T \\leq 10$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Koishi Loves Construction", "background": "", "description": "Koishi 决定走出幻想乡成为数学大师！\n\nFlandre 听说她数学学的很好，就给 Koishi 出了这样一道构造题：\n\nTask1：试判断能否构造并构造一个长度为 $n$ 的 $1 \\dots n$ 的排列，满足其 $n$ 个前缀和在模 $n$ 的意义下互不相同。\n\nTask2：试判断能否构造并构造一个长度为 $n$ 的 $1 \\dots n$ 的排列，满足其 $n$ 个前缀积在模 $n$ 的意义下互不相同。\n\n按照套路，Koishi 假装自己根本不会捉，就来找你帮忙辣。", "inputFormat": "第一行两个整数 $X$ 和 $T$，分别表示 Task 类型和测试点内的数据组数。\n\n接下来 $T$ 行，每行一个整数表示每组数据中的 $n$。", "outputFormat": "为了方便 SPJ 的编写，您需要**遵从以下格式**输出。\n\n\n对于每组数据仅包含**一行**输出：\n\n1. 如果您认为当前数据不存在符合题意的构造，只需输出一个整数 $0$。\n2. 如果您认为当前数据存在符合题意的构造却不会构造，只需输出一个整数 $1$。\n3.  如果您认为当前数据存在符合题意的构造并成功构造，则需要先输出一个整数 $2$，再输出 $n$ 个整数表示构造的方案。\n\n**每两个整数之间需要有空格作为分隔符**。", "hint": "对于每组数据：\n\n1. 如果您对于构造的存在性判断正确，您将会得到 $30\\%$ 的分数，若您的构造符合题意或者确实不存在符合题意的构造，您将会得到剩余的 $70\\%$ 的分数。\n2. 如果您对于构造的存在性判断不正确，您将不会得到任何分数。\n\n对于每组测试点，您的得分将是本组数据点中得分的最小值。\n\n测试点类型 $1$：$10$ 分，满足 $X = 1$，$1 \\leq n \\leq 10$。  \n测试点类型 $2$：$40$ 分，满足 $X = 1$，$1 \\leq n \\leq {10}^5$。  \n测试点类型 $3$：$10$ 分，满足 $X = 2$，$1 \\leq n \\leq 10$。  \n测试点类型 $4$：$40$ 分，满足 $X = 2$，$1 \\leq n \\leq {10}^5$。\n\n对于所有测试点，满足 $1 \\leq T \\leq 10$。", "locale": "zh-CN"}}}
{"pid": "P3600", "type": "P", "difficulty": 6, "samples": [["2 2 1\n1 2", "499967501"], ["6 6 6\n1 3\n2 4\n3 5\n4 6\n5 6\n3 4", "88571635"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "洛谷原创", "O2优化", "期望", "洛谷月赛"], "title": "随机数生成器", "background": "", "description": "sol 研发了一个神奇的随机数系统，可以自动按照环境噪音生成真·随机数。\n\n现在 sol 打算生成 $n$ 个 $[1,x]$ 的整数 $a_1, ..., a_n$，然后进行一些询问。\n\n$q$ 次询问，每次询问 $i$ 有两个参数 $l_i$ 和 $r_i$，sol 会计算 $\\min_{l_i \\leq j \\leq r_i} a_j$（$a$ 数组中下标在 $l_i, r_i$ 之间的数的最小值）。\n\n最后测试结果会是这些询问得到的结果的最大值。\n\nsol 进行了很多次实验，现在他想问问你测试结果的期望大小是多少，对 $666623333$ 取模。\n", "inputFormat": "第一行三个数 $n, x, q$。\n\n下面 $q$ 行，第 $i$ 行两个数表示 $l_i$ 和 $r_i$。\n", "outputFormat": "一行一个数，表示答案。\n", "hint": "提示：一个分数 $\\frac{a}{b}$ 对 $666623333$ 取模的结果为 $a\\times b^{666623331}~\\mod~666623333$。\n\n对于 $10\\%$ 的数据，$n,x,q \\leq 6$。\n\n对于另外 $20\\%$ 的数据，$q=1$。\n\n对于 $50\\%$ 的数据，$n,x,q \\leq 300$。\n\n对于 $70\\%$ 的数据，$n,x,q \\leq 800$。\n\n对于 $100\\%$ 的数据，$1 \\leq n,x,q \\leq 2000$，对于每个 $i$，$1 \\leq l_i \\leq r_i \\leq n$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Random Number Generator", "background": "", "description": "sol developed a magical random number system that can automatically generate true random numbers from environmental noise.\n\nNow sol plans to generate $n$ integers in $[1,x]$, namely $a_1, ..., a_n$, and then handle some queries.\n\nThere are $q$ queries. For each query $i$ with parameters $l_i$ and $r_i$, sol will compute $\\min_{l_i \\leq j \\leq r_i} a_j$ (the minimum value of the numbers in the array $a$ whose indices are between $l_i$ and $r_i$).\n\nFinally, the test result is the maximum among the results of these queries.\n\nsol has conducted many experiments. Now he wants to ask you for the expected value of the test result, modulo $666623333$.", "inputFormat": "The first line contains three integers $n, x, q$.\n\nEach of the next $q$ lines contains two integers $l_i$ and $r_i$.", "outputFormat": "Output a single integer, the answer.", "hint": "Tip: The result of a fraction $\\frac{a}{b}$ modulo $666623333$ is $a\\times b^{666623331}~\\mod~666623333$.\n\nFor $10\\%$ of the testdata, $n,x,q \\leq 6$.\n\nFor another $20\\%$ of the testdata, $q=1$.\n\nFor $50\\%$ of the testdata, $n,x,q \\leq 300$.\n\nFor $70\\%$ of the testdata, $n,x,q \\leq 800$.\n\nFor $100\\%$ of the testdata, $1 \\leq n,x,q \\leq 2000$, and for each $i$, $1 \\leq l_i \\leq r_i \\leq n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "随机数生成器", "background": "", "description": "sol 研发了一个神奇的随机数系统，可以自动按照环境噪音生成真·随机数。\n\n现在 sol 打算生成 $n$ 个 $[1,x]$ 的整数 $a_1, ..., a_n$，然后进行一些询问。\n\n$q$ 次询问，每次询问 $i$ 有两个参数 $l_i$ 和 $r_i$，sol 会计算 $\\min_{l_i \\leq j \\leq r_i} a_j$（$a$ 数组中下标在 $l_i, r_i$ 之间的数的最小值）。\n\n最后测试结果会是这些询问得到的结果的最大值。\n\nsol 进行了很多次实验，现在他想问问你测试结果的期望大小是多少，对 $666623333$ 取模。\n", "inputFormat": "第一行三个数 $n, x, q$。\n\n下面 $q$ 行，第 $i$ 行两个数表示 $l_i$ 和 $r_i$。\n", "outputFormat": "一行一个数，表示答案。\n", "hint": "提示：一个分数 $\\frac{a}{b}$ 对 $666623333$ 取模的结果为 $a\\times b^{666623331}~\\mod~666623333$。\n\n对于 $10\\%$ 的数据，$n,x,q \\leq 6$。\n\n对于另外 $20\\%$ 的数据，$q=1$。\n\n对于 $50\\%$ 的数据，$n,x,q \\leq 300$。\n\n对于 $70\\%$ 的数据，$n,x,q \\leq 800$。\n\n对于 $100\\%$ 的数据，$1 \\leq n,x,q \\leq 2000$，对于每个 $i$，$1 \\leq l_i \\leq r_i \\leq n$。\n", "locale": "zh-CN"}}}
{"pid": "P3601", "type": "P", "difficulty": 5, "samples": [["233 2333", "1056499"], ["2333333333 2333666666", "153096296"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "洛谷原创", "O2优化", "洛谷月赛", "欧拉函数"], "title": "签到题", "background": "这是一道签到题！\n\n**建议做题之前仔细阅读数据范围！**\n", "description": "我们定义一个函数：$\\operatorname{qiandao}(x)$ 为小于等于 $x$ 的数中，与 $x$ **不互质**的数的个数。\n\n这题作为签到题，给出 $l$ 和 $r$，求出：\n\n$$\\sum_{i=l}^r \\operatorname{qiandao}(i)\\bmod 666623333$$\n", "inputFormat": "一行两个整数，$l$、$r$。\n", "outputFormat": "一行一个整数表示答案。\n", "hint": "- 对于 $30\\%$ 的数据，$l,r\\leq 10^3$。\n- 对于 $60\\%$ 的数据，$l,r\\leq 10^7$。\n- 对于 $100\\%$ 的数据，$1 \\leq l \\leq r \\leq 10^{12}$，$r-l \\leq 10^6$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Check-in Problem", "background": "This is a check-in problem.\nIt is recommended to carefully read the Constraints before solving.", "description": "We define a function $\\operatorname{qiandao}(x)$ as the number of integers less than or equal to $x$ that are not coprime with $x$.\nGiven $l$ and $r$, compute:\n$$\\sum_{i=l}^r \\operatorname{qiandao}(i)\\bmod 666623333.$$", "inputFormat": "One line with two integers, $l$ and $r$.", "outputFormat": "One line with one integer representing the answer.", "hint": "- For 30% of the testdata, $l,r\\leq 10^3$.\n- For 60% of the testdata, $l,r\\leq 10^7$.\n- For 100% of the testdata, $1 \\leq l \\leq r \\leq 10^{12}$, $r-l \\leq 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "签到题", "background": "这是一道签到题！\n\n**建议做题之前仔细阅读数据范围！**\n", "description": "我们定义一个函数：$\\operatorname{qiandao}(x)$ 为小于等于 $x$ 的数中，与 $x$ **不互质**的数的个数。\n\n这题作为签到题，给出 $l$ 和 $r$，求出：\n\n$$\\sum_{i=l}^r \\operatorname{qiandao}(i)\\bmod 666623333$$\n", "inputFormat": "一行两个整数，$l$、$r$。\n", "outputFormat": "一行一个整数表示答案。\n", "hint": "- 对于 $30\\%$ 的数据，$l,r\\leq 10^3$。\n- 对于 $60\\%$ 的数据，$l,r\\leq 10^7$。\n- 对于 $100\\%$ 的数据，$1 \\leq l \\leq r \\leq 10^{12}$，$r-l \\leq 10^6$。\n", "locale": "zh-CN"}}}
{"pid": "P3602", "type": "P", "difficulty": 5, "samples": [["4 3\n1 3\n2 4\n5 7\n6 8\n2 5\n3 1\n6 2", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "线段树", "离散化", "洛谷原创", "O2优化", "洛谷月赛"], "title": "Koishi Loves Segments", "background": "", "description": "Koishi 喜欢线段。\n\n她的 $n$ 条线段都能表示成数轴上的某个闭区间 $[l,r]$。Koishi 喜欢在把所有线段都放在数轴上，然后数出某些点被多少线段覆盖了。\n\nFlandre 看她和线段玩得很起开心，就抛给她一个问题：\n\n数轴上有 $m$ 个点突然兴奋，如果自己被身上覆盖了超过 $x$ 条线段，这个点就会浑身难受然后把 Koishi 批判一番。\n\nKoishi 十分善良，为了不让数轴上的点浑身难受，也为了让自己开心，她想在数轴上放入尽量多的线段。\n\n按照套路，Koishi 假装自己并不会做这道题，所以她就来求你帮忙。并承诺如果你解决了问题就给你打一通电话。", "inputFormat": "第一行两个个整数 $n,m$，分别表示插入的线段数和关键点数。\n\n接下来 $n$ 行，每行两个整数 $l,r(l\\leq r)$，表示线段 $[l,r]$ 的端点。\n\n接下来 $m$ 行，每行两个整数 $p,x$，表示有个位于 $p$ 的点突然兴奋，并认为自己身上不得覆盖超过 $x$ 条线段\n", "outputFormat": "一个整数，表示最多能放入的线段数。\n", "hint": "对于 $20\\%$ 的数据，满足$1\\leq n,m\\leq 20$。\n\n对于 $60\\%$ 的数据，满足$1\\leq n,m\\leq 100$。\n\n对于 $80\\%$的数据，满足$1\\leq n,m\\leq 5000$。\n\n对于 $100\\%$ 的数据，满足$1\\leq x\\leq n\\leq 2\\times 10^5,1\\leq m\\leq 4\\times 10^5,|l|,|r|,|p|\\leq 10^7$\n\n如果一个点兴奋了两次，那么 Koishi 应当满足它的**较严苛的要求**（也就是 $p$ 相同时 $x$ 取最小值啦）\n\n请适当使用读入优化。", "locale": "zh-CN", "translations": {"en": {"title": "Koishi Loves Segments", "background": "", "description": "Koishi likes segments.\n\nEach of her $n$ segments can be represented as a closed interval $[l, r]$ on the number line. Koishi likes to put all the segments on the number line and then count how many segments cover certain points.\n\nSeeing how happily she plays with segments, Flandre throws her a problem:\n\nThere are $m$ points on the number line that suddenly get excited. If a point is covered by more than $x$ segments, it will feel terrible and criticize Koishi.\n\nKoishi is very kind. To avoid making the points feel bad and to make herself happy, she wants to place as many segments on the number line as possible.\n\nAs usual, Koishi pretends she cannot solve this problem, so she asks you for help, and promises to give you a phone call if you solve it.", "inputFormat": "The first line contains two integers $n, m$, denoting the number of segments to insert and the number of excited points.\n\nEach of the next $n$ lines contains two integers $l, r$ ($l \\le r$), denoting the endpoints of a segment $[l, r]$.\n\nEach of the next $m$ lines contains two integers $p, x$, meaning that the point at position $p$ gets excited and requires that it should not be covered by more than $x$ segments.", "outputFormat": "Output a single integer, denoting the maximum number of segments that can be placed.", "hint": "- For 20% of the testdata, $1 \\le n, m \\le 20$.\n- For 60% of the testdata, $1 \\le n, m \\le 100$.\n- For 80% of the testdata, $1 \\le n, m \\le 5000$.\n- Constraints: $1 \\le x \\le n \\le 2\\times 10^5$, $1 \\le m \\le 4\\times 10^5$, $|l|, |r|, |p| \\le 10^7$.\n- If a point gets excited multiple times, Koishi should satisfy its stricter requirement (i.e., when $p$ is the same, take the minimum $x$).\n- Please use fast I/O appropriately.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Koishi Loves Segments", "background": "", "description": "Koishi 喜欢线段。\n\n她的 $n$ 条线段都能表示成数轴上的某个闭区间 $[l,r]$。Koishi 喜欢在把所有线段都放在数轴上，然后数出某些点被多少线段覆盖了。\n\nFlandre 看她和线段玩得很起开心，就抛给她一个问题：\n\n数轴上有 $m$ 个点突然兴奋，如果自己被身上覆盖了超过 $x$ 条线段，这个点就会浑身难受然后把 Koishi 批判一番。\n\nKoishi 十分善良，为了不让数轴上的点浑身难受，也为了让自己开心，她想在数轴上放入尽量多的线段。\n\n按照套路，Koishi 假装自己并不会做这道题，所以她就来求你帮忙。并承诺如果你解决了问题就给你打一通电话。", "inputFormat": "第一行两个个整数 $n,m$，分别表示插入的线段数和关键点数。\n\n接下来 $n$ 行，每行两个整数 $l,r(l\\leq r)$，表示线段 $[l,r]$ 的端点。\n\n接下来 $m$ 行，每行两个整数 $p,x$，表示有个位于 $p$ 的点突然兴奋，并认为自己身上不得覆盖超过 $x$ 条线段\n", "outputFormat": "一个整数，表示最多能放入的线段数。\n", "hint": "对于 $20\\%$ 的数据，满足$1\\leq n,m\\leq 20$。\n\n对于 $60\\%$ 的数据，满足$1\\leq n,m\\leq 100$。\n\n对于 $80\\%$的数据，满足$1\\leq n,m\\leq 5000$。\n\n对于 $100\\%$ 的数据，满足$1\\leq x\\leq n\\leq 2\\times 10^5,1\\leq m\\leq 4\\times 10^5,|l|,|r|,|p|\\leq 10^7$\n\n如果一个点兴奋了两次，那么 Koishi 应当满足它的**较严苛的要求**（也就是 $p$ 相同时 $x$ 取最小值啦）\n\n请适当使用读入优化。", "locale": "zh-CN"}}}
{"pid": "P3603", "type": "P", "difficulty": 6, "samples": [["10 1 0\n0 0 0 1 1 0 2 2 1 2 \n2 3\n1 2\n4 5\n3 4\n7 8\n6 7\n5 6\n9 10\n8 9\n1\n6 8", "2 1"], ["10 1 1\n0 0 1 0 0 2 2 0 0 0 \n2 3\n1 2\n4 5\n3 4\n7 8\n6 7\n5 6\n9 10\n8 9\n4\n1 7\n3 3\n1 1\n9 3\n", "3 3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["倍增", "洛谷原创", "O2优化", "最近公共祖先 LCA", "树链剖分", "分块", "洛谷月赛", "bitset"], "title": "雪辉", "background": "**时间限制3s，空间限制512MB**\n\n\n三周目的由乃被钦定成为了卡密，她立刻赶去二周目的世界寻找雪辉\n\n但是按照设定，两个平行世界是没法互相影响的，也就是原则上由乃是没法去二周目世界的\n\n这时候Deus又跳出来说，其实设定是作者骗你的，只要爱的力量足够强大什么都可以做到（好狗血）\n\n\nDeus：由乃你为了雪辉是不是什么都可以做呀\n\nyuno：当然啦这还用想\n\nDeus：那你帮我做个题吧\n\nyuno：只要不是数据结构，什么题我都做\n\nDeus：出题人是那个n????????呀，他出（抄）的题除了傻逼数据结构还有啥。。。\n\nyuno：你说的很有道理。。。\n\nDeus：上次那个题你不是两分钟就秒了吗，这个题比那个还简单\n\nyuno：（小声）其实那个是bzoj上面的大佬帮我做的\n\nDeus：好吧就这么愉快的钦定了\n\n![](https://cdn.luogu.com.cn/upload/pic/4134.png)\n", "description": "给一个n个点的树，点有点权，有m次询问，每次询问多条链的并有多少种不同的点权以及它的mex\n\nmex就是一个集合中最小的没有出现的非负整数，注意0要算\n\n比如说集合是1,9,2,6,0,8,1,7，则出现了0,1,2,6,7,8,9这7种不同的点权，因为没有3所以mex是3\n\n![](https://cdn.luogu.com.cn/upload/pic/4132.png)\n", "inputFormat": "第一行三个数n，m，意义如题所述，和一个数f\n\n如果f是0，代表Deus没有使用膜法，如果f是1，代表Deus使用了膜法\n\n之后一行n个数，表示点权\n\n之后n-1行，每行两个数x，y，表示x和y节点之间有一条边，保证是一个树\n\n之后m行，每行先是一个数a，表示这次输入a条链，紧接着2a个数(x1,y1)(x2,y2)...表示每条树链\n\n如果数据被Deus施了膜法，这2a个数都要异或上上一个询问的答案lastans，如果是第一次询问则这个lastans = 0，因为每次询问有两个答案，lastans为这两个答案的和\n\n如果没有膜法，则-1s并且不异或\n", "outputFormat": "m行，每行两个数表示点权种类数以及mex\n", "hint": "设a的和为q\n\n对于20%的数据，n,q<=1000，f=0\n\n对于另外30%的数据，n,q<=100000，树是一条链，f=0\n\n对于所有数据n,q<=100000,且点权<=30000\n\n\n最后，由乃祝大家新年快乐\n\n![](https://cdn.luogu.com.cn/upload/pic/4135.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "Yukiteru", "background": "Time limit 3 s, memory limit 512 MB.\n\nIn the third loop, Yuno was appointed as the kamisama, and she immediately rushed to the second loop to find Yukiteru.\n\nHowever, according to the setting, two parallel worlds cannot affect each other, which means in principle Yuno cannot go to the second world.\n\nAt this moment Deus popped out again and said, actually the setting was the author lying to you; as long as the power of love is strong enough, anything can be done (what a melodrama).\n\nDeus: Yuno, will you do anything for Yukiteru?\n\nYuno: Of course, that goes without saying.\n\nDeus: Then help me solve a problem.\n\nYuno: As long as it’s not data structures, I’ll do any problem.\n\nDeus: The problem setter is that n???????? guy. Besides dumb data structures, what else does he write (copy)...\n\nYuno: You have a point...\n\nDeus: Didn’t you insta-solve the last one in two minutes? This one is even easier.\n\nYuno: (quietly) Actually that one was done by a big shot on bzoj.\n\nDeus: Fine, it’s happily decided then.\n\n![](https://cdn.luogu.com.cn/upload/pic/4134.png)", "description": "Given a tree with n nodes. Each node has a weight. There are m queries. For each query, you are given multiple paths. Consider the union of these paths, and ask:\n- how many distinct node weights appear, and\n- the mex of those weights.\n\nThe mex of a set is the smallest non-negative integer that does not appear; note that 0 counts.\n\nFor example, if the set is 1, 9, 2, 6, 0, 8, 1, 7, then the distinct weights that appear are 0, 1, 2, 6, 7, 8, 9 (7 kinds). Since 3 does not appear, the mex is 3.\n\n![](https://cdn.luogu.com.cn/upload/pic/4132.png)", "inputFormat": "- The first line contains three integers n and m as described above, and an integer f.\n  - If f = 0, it means Deus did not use magic.\n  - If f = 1, it means Deus used magic.\n- The second line contains n integers, the node weights.\n- The next n − 1 lines each contain two integers x and y, indicating there is an edge between nodes x and y. It is guaranteed to be a tree.\n- The next m lines each describe a query:\n  - Each line starts with an integer a, the number of paths in this query.\n  - Then follow 2a integers representing the a pairs (x1, y1) (x2, y2) ... corresponding to the paths.\n  - If the testdata has been blessed by Deus’s magic (f = 1), then all these 2a integers must be xor-ed with the previous query’s answer lastans. For the first query, lastans = 0. Since each query has two answers, lastans is the sum of those two answers.\n  - If there is no magic (f = 0), then −1 s and do not xor.", "outputFormat": "Output m lines. Each line contains two integers: the number of distinct node weights and the mex.", "hint": "Let the sum of all a over all queries be q.\n\nConstraints:\n- For 20% of the testdata: n, q ≤ 1000, f = 0.\n- For an additional 30% of the testdata: n, q ≤ 100000, the tree is a path, f = 0.\n- For all testdata: n, q ≤ 100000, and node weights ≤ 30000.\n\nFinally, Yuno wishes everyone a Happy New Year.\n\n![](https://cdn.luogu.com.cn/upload/pic/4135.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "雪辉", "background": "**时间限制3s，空间限制512MB**\n\n\n三周目的由乃被钦定成为了卡密，她立刻赶去二周目的世界寻找雪辉\n\n但是按照设定，两个平行世界是没法互相影响的，也就是原则上由乃是没法去二周目世界的\n\n这时候Deus又跳出来说，其实设定是作者骗你的，只要爱的力量足够强大什么都可以做到（好狗血）\n\n\nDeus：由乃你为了雪辉是不是什么都可以做呀\n\nyuno：当然啦这还用想\n\nDeus：那你帮我做个题吧\n\nyuno：只要不是数据结构，什么题我都做\n\nDeus：出题人是那个n????????呀，他出（抄）的题除了傻逼数据结构还有啥。。。\n\nyuno：你说的很有道理。。。\n\nDeus：上次那个题你不是两分钟就秒了吗，这个题比那个还简单\n\nyuno：（小声）其实那个是bzoj上面的大佬帮我做的\n\nDeus：好吧就这么愉快的钦定了\n\n![](https://cdn.luogu.com.cn/upload/pic/4134.png)\n", "description": "给一个n个点的树，点有点权，有m次询问，每次询问多条链的并有多少种不同的点权以及它的mex\n\nmex就是一个集合中最小的没有出现的非负整数，注意0要算\n\n比如说集合是1,9,2,6,0,8,1,7，则出现了0,1,2,6,7,8,9这7种不同的点权，因为没有3所以mex是3\n\n![](https://cdn.luogu.com.cn/upload/pic/4132.png)\n", "inputFormat": "第一行三个数n，m，意义如题所述，和一个数f\n\n如果f是0，代表Deus没有使用膜法，如果f是1，代表Deus使用了膜法\n\n之后一行n个数，表示点权\n\n之后n-1行，每行两个数x，y，表示x和y节点之间有一条边，保证是一个树\n\n之后m行，每行先是一个数a，表示这次输入a条链，紧接着2a个数(x1,y1)(x2,y2)...表示每条树链\n\n如果数据被Deus施了膜法，这2a个数都要异或上上一个询问的答案lastans，如果是第一次询问则这个lastans = 0，因为每次询问有两个答案，lastans为这两个答案的和\n\n如果没有膜法，则-1s并且不异或\n", "outputFormat": "m行，每行两个数表示点权种类数以及mex\n", "hint": "设a的和为q\n\n对于20%的数据，n,q<=1000，f=0\n\n对于另外30%的数据，n,q<=100000，树是一条链，f=0\n\n对于所有数据n,q<=100000,且点权<=30000\n\n\n最后，由乃祝大家新年快乐\n\n![](https://cdn.luogu.com.cn/upload/pic/4135.png)\n", "locale": "zh-CN"}}}
{"pid": "P3604", "type": "P", "difficulty": 6, "samples": [["6 6\nzzqzzq\n1 6\n2 4\n3 4\n2 3\n4 5\n1 1", "16\n4\n2\n2\n3\n1"], ["6 6\naaabbb\n1 2\n2 3\n3 4\n4 5\n5 6\n1 6", "3\n3\n2\n3\n3\n17"], ["4 1\nyuno\n1 4", "4"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [162000, 162000, 162000, 162000, 162000, 162000, 162000, 162000, 162000, 162000]}, "tags": ["莫队", "洛谷原创", "洛谷月赛", "状压 DP"], "title": "美好的每一天", "background": "时间限制 $\\texttt{3s}$，空间限制 $\\texttt{158.2MB}$.\n\n\n素晴らしき日々\n\n我们的情人，不过是随便借个名字，用幻想吹出来的肥皂泡，把信拿去吧，你可以使假戏成真。我本来是无病呻吟，漫无目的的吐露爱情---现在这些漂泊不定的鸟儿有地方栖息了，你可以从信里看出来。拿去吧---由于不是出自真心，话就说得格外动听，拿去吧，就这么办吧……\n\n\n由于世界会在 $7$ 月 $20$ 日完结，作为救世主，间宫卓司要在 $19$ 日让所有人回归天空。\n\n现在已经是 $19$ 日傍晚，大家集合在 C 栋的天台上，一共 $n$ 个人。\n\n在他们面前，便是终之空，那终结的天空。\n\n![](https://cdn.luogu.com.cn/upload/pic/4139.png)", "description": "回归天空是一件庄重的事情，所以卓司决定让大家分批次进行，给每个人给了一个小写字母 $\\texttt{a}\\sim\\texttt{z}$ 作为编号。\n\n一个区间的人如果满足他们的**编号重排之后可以成为一个回文串**，则他们可以一起回归天空，即这个区间可以回归天空。\n\n由于卓司是一个喜欢妄想的人，他妄想了 $m$ 个区间，每次他想知道每个区间中有多少个子区间可以回归天空。\n\n因为世界末日要来了，所以卓司的信徒很多。\n\n![](https://cdn.luogu.com.cn/upload/pic/4138.png)", "inputFormat": "第一行，两个数 $n,m$。\n\n之后一行，一个长为 $n$ 的字符串，代表每个人的编号。\n\n之后 $m$ 行，每行两个数 $l,r$，代表每次卓司妄想的区间。", "outputFormat": "$m$ 行，每行一个数表示答案。", "hint": "对于 $10\\%$ 的数据，$n,m\\le 100$。\n\n对于 $30\\%$ 的数据，$n,m \\le 2000$。\n\n对于 $100\\%$ 的数据，$n,m\\le 60000$。\n\n**字符集大小有梯度**。\n\n\n在大家回归天空之后，彩名露出了阴冷的笑容。\n\n![](https://cdn.luogu.com.cn/upload/pic/4137.png)", "locale": "zh-CN", "translations": {"en": {"title": "Wonderful Everyday", "background": "Time limit $\\texttt{3s}$, memory limit $\\texttt{158.2MB}$.\n\nSubarashiki Hibi.\n\nOur lovers are just names we casually borrow, soap bubbles blown by imagination. Take the letter; you can turn make-believe into reality. I was lamenting without an illness, aimlessly pouring out love—now these drifting birds have a perch, as you can see in the letter. Take it—precisely because it isn’t from the heart, the words sound all the more charming. Take it; let’s do it this way....\n\nSince the world will end on $7$ 月 $20$ 日, as the savior, Mamiya Takuji must let everyone return to the sky on $19$ 日.\n\nIt is already the evening of $19$ 日; everyone has gathered on the rooftop of Building C, $n$ people in total.\n\nIn front of them lies the Terminal Sky, the sky of the end.\n\n![](https://cdn.luogu.com.cn/upload/pic/4139.png)", "description": "Returning to the sky is a solemn matter, so Takuji decides to proceed in batches, giving each person a lowercase letter $\\texttt{a}\\sim\\texttt{z}$ as an identifier.\n\nIf a contiguous interval of people satisfies that their **identifiers, after reordering, can form a palindrome**, then they may return to the sky together; that is, this interval can return to the sky.\n\nBecause Takuji is fond of delusions, he imagines $m$ intervals; for each, he wants to know how many subintervals within it can return to the sky.\n\nSince the end of the world is coming, Takuji has many followers.\n\n![](https://cdn.luogu.com.cn/upload/pic/4138.png)", "inputFormat": "The first line contains two integers $n, m$.\n\nThe next line contains a string of length $n$ representing each person’s identifier.\n\nThen follow $m$ lines; each line contains two integers $l, r$, representing one of Takuji’s imagined intervals.", "outputFormat": "Output $m$ lines, each containing one integer, the answer.", "hint": "For $10\\%$ of the testdata, $n, m \\le 100$.\n\nFor $30\\%$ of the testdata, $n, m \\le 2000$.\n\nFor $100\\%$ of the testdata, $n, m \\le 60000$.\n\nThe character set size varies across the testdata.\n\nAfter everyone returns to the sky, Ayana reveals a chilling smile.\n\n![](https://cdn.luogu.com.cn/upload/pic/4137.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "美好的每一天", "background": "时间限制 $\\texttt{3s}$，空间限制 $\\texttt{158.2MB}$.\n\n\n素晴らしき日々\n\n我们的情人，不过是随便借个名字，用幻想吹出来的肥皂泡，把信拿去吧，你可以使假戏成真。我本来是无病呻吟，漫无目的的吐露爱情---现在这些漂泊不定的鸟儿有地方栖息了，你可以从信里看出来。拿去吧---由于不是出自真心，话就说得格外动听，拿去吧，就这么办吧……\n\n\n由于世界会在 $7$ 月 $20$ 日完结，作为救世主，间宫卓司要在 $19$ 日让所有人回归天空。\n\n现在已经是 $19$ 日傍晚，大家集合在 C 栋的天台上，一共 $n$ 个人。\n\n在他们面前，便是终之空，那终结的天空。\n\n![](https://cdn.luogu.com.cn/upload/pic/4139.png)", "description": "回归天空是一件庄重的事情，所以卓司决定让大家分批次进行，给每个人给了一个小写字母 $\\texttt{a}\\sim\\texttt{z}$ 作为编号。\n\n一个区间的人如果满足他们的**编号重排之后可以成为一个回文串**，则他们可以一起回归天空，即这个区间可以回归天空。\n\n由于卓司是一个喜欢妄想的人，他妄想了 $m$ 个区间，每次他想知道每个区间中有多少个子区间可以回归天空。\n\n因为世界末日要来了，所以卓司的信徒很多。\n\n![](https://cdn.luogu.com.cn/upload/pic/4138.png)", "inputFormat": "第一行，两个数 $n,m$。\n\n之后一行，一个长为 $n$ 的字符串，代表每个人的编号。\n\n之后 $m$ 行，每行两个数 $l,r$，代表每次卓司妄想的区间。", "outputFormat": "$m$ 行，每行一个数表示答案。", "hint": "对于 $10\\%$ 的数据，$n,m\\le 100$。\n\n对于 $30\\%$ 的数据，$n,m \\le 2000$。\n\n对于 $100\\%$ 的数据，$n,m\\le 60000$。\n\n**字符集大小有梯度**。\n\n\n在大家回归天空之后，彩名露出了阴冷的笑容。\n\n![](https://cdn.luogu.com.cn/upload/pic/4137.png)", "locale": "zh-CN"}}}
{"pid": "P3605", "type": "P", "difficulty": 5, "samples": [["5\n804289384\n846930887\n681692778\n714636916\n957747794\n1\n1\n2\n3", "2\n0\n1\n0\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2017", "线段树", "USACO", "树状数组", "树上启发式合并", "离散化", "深度优先搜索 DFS", "线段树合并"], "title": "[USACO17JAN] Promotion Counting P", "background": null, "description": "奶牛们又一次试图创建一家创业公司，还是没有从过去的经验中吸取教训——牛是可怕的管理者！\n\n为了方便，把奶牛从 $1\\sim n$ 编号，把公司组织成一棵树，1 号奶牛作为总裁（这棵树的根节点）。除了总裁以外的每头奶牛都有一个单独的上司（它在树上的 “双亲结点”）。  \n\n所有的第 $i$ 头牛都有一个不同的能力指数 $p_i$，描述了她对其工作的擅长程度。如果奶牛 $i$ 是奶牛 $j$ 的祖先节点，那么我们把奶牛 $j$ 叫做 $i$ 的下属。\n\n不幸地是，奶牛们发现经常发生一个上司比她的一些下属能力低的情况，在这种情况下，上司应当考虑晋升她的一些下属。你的任务是帮助奶牛弄清楚这是什么时候发生的。简而言之，对于公司的中的每一头奶牛 $i$，请计算其下属 $j$ 的数量满足 $p_j > p_i$。", "inputFormat": "输入的第一行包括一个整数 $n$。\n\n接下来的 $n$ 行包括奶牛们的能力指数 $p_1,p_2 \\dots p_n$。保证所有数互不相同。\n\n接下来的 $n-1$ 行描述了奶牛 $2 \\sim n$ 的上司的编号。再次提醒，1 号奶牛作为总裁，没有上司。", "outputFormat": "输出包括 $n$ 行。输出的第 $i$ 行应当给出有多少奶牛 $i$ 的下属比奶牛 $i$ 能力高。", "hint": "对于 $100\\%$ 的数据，$1\\le n \\le 10^5$，$1 \\le p_i \\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO17JAN] Promotion Counting P", "background": null, "description": "The cows have once again tried to form a startup company, failing to remember from past experience that cows make terrible managers!\n\nThe cows, conveniently numbered $1 \\ldots N (1 \\leq N \\leq 100,000)$, organize the company as a tree, with cow 1 as the president (the root of the tree). Each cow except the president has a single manager (its \"parent\" in the tree). Each cow i has a distinct proficiency rating, $p(i)$, which describes how good she is at her job. If cow i is an ancestor (e.g., a manager of a manager of a manager) of cow $j$, then we say $j$ is a subordinate of $i$.\n\nUnfortunately, the cows find that it is often the case that a manager has less proficiency than several of her subordinates, in which case the manager should consider promoting some of her subordinates. Your task is to help the cows figure out when this is happening. For each cow $i$ in the company, please count the number of subordinates $j$ where $p(j) \\gt p(i)$.", "inputFormat": "The first line of input contains $N$.\n\nThe next $N$ lines of input contain the proficiency ratings $p(1) \\ldots p(N)$ for the cows. Each is a distinct integer in the range $1 \\ldots 1,000,000,000$.\n\nThe next $N-1$ lines describe the manager (parent) for cows $2 \\ldots N$. Recall that cow 1 has no manager, being the president.", "outputFormat": "Please print $N$ lines of output. The $i$-th line of output should tell the number of subordinates of cow $i$ with higher proficiency than cow $i$.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO17JAN] Promotion Counting P", "background": null, "description": "奶牛们又一次试图创建一家创业公司，还是没有从过去的经验中吸取教训——牛是可怕的管理者！\n\n为了方便，把奶牛从 $1\\sim n$ 编号，把公司组织成一棵树，1 号奶牛作为总裁（这棵树的根节点）。除了总裁以外的每头奶牛都有一个单独的上司（它在树上的 “双亲结点”）。  \n\n所有的第 $i$ 头牛都有一个不同的能力指数 $p_i$，描述了她对其工作的擅长程度。如果奶牛 $i$ 是奶牛 $j$ 的祖先节点，那么我们把奶牛 $j$ 叫做 $i$ 的下属。\n\n不幸地是，奶牛们发现经常发生一个上司比她的一些下属能力低的情况，在这种情况下，上司应当考虑晋升她的一些下属。你的任务是帮助奶牛弄清楚这是什么时候发生的。简而言之，对于公司的中的每一头奶牛 $i$，请计算其下属 $j$ 的数量满足 $p_j > p_i$。", "inputFormat": "输入的第一行包括一个整数 $n$。\n\n接下来的 $n$ 行包括奶牛们的能力指数 $p_1,p_2 \\dots p_n$。保证所有数互不相同。\n\n接下来的 $n-1$ 行描述了奶牛 $2 \\sim n$ 的上司的编号。再次提醒，1 号奶牛作为总裁，没有上司。", "outputFormat": "输出包括 $n$ 行。输出的第 $i$ 行应当给出有多少奶牛 $i$ 的下属比奶牛 $i$ 能力高。", "hint": "对于 $100\\%$ 的数据，$1\\le n \\le 10^5$，$1 \\le p_i \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P3606", "type": "P", "difficulty": 5, "samples": [["2 5\n10\n4", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "贪心", "2017", "二分", "USACO"], "title": "[USACO17JAN] Building a Tall Barn P", "background": "", "description": "Farmer John is building a brand new, $N$-story barn, with the help of his $K$ cows ($1 \\leq N \\leq K \\leq 10^{12}$ and $N \\leq 10^5$). To build it as quickly as possible, he needs your help to figure out how to allocate work among the cows.\n\nEach cow must be assigned to work on exactly one specific floor out of the $N$ total floors in the barn, and each floor must have at least one cow assigned to it. The $i$th floor requires $a_i$ units of total work, and each cow completes one unit of work per hour, so if $c$ cows work on floor $i$, it will be completed in $a_i / c$ units of time. For safety reasons, floor $i$ must be completed before construction can begin on floor $i+1$.\n\nPlease compute the minimum total time in which the barn can be completed, if the cows are allocated to work on floors in an optimal fashion. Output this number rounded to the nearest integer; it is guaranteed that the solution will be more than 0.1 from the boundary between two integers.", "inputFormat": "The first line of input contains $N$ and $K$.\n\nThe next $N$ lines contain $a_1 \\ldots a_N$, each a positive integer of size at most $10^{12}$.", "outputFormat": "Please output the minimum time required to build the barn, rounded to the\n\nnearest integer.\n\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO17JAN] Building a Tall Barn P", "background": "", "description": "Farmer John is building a brand new, $N$-story barn, with the help of his $K$ cows ($1 \\leq N \\leq K \\leq 10^{12}$ and $N \\leq 10^5$). To build it as quickly as possible, he needs your help to figure out how to allocate work among the cows.\n\nEach cow must be assigned to work on exactly one specific floor out of the $N$ total floors in the barn, and each floor must have at least one cow assigned to it. The $i$th floor requires $a_i$ units of total work, and each cow completes one unit of work per hour, so if $c$ cows work on floor $i$, it will be completed in $a_i / c$ units of time. For safety reasons, floor $i$ must be completed before construction can begin on floor $i+1$.\n\nPlease compute the minimum total time in which the barn can be completed, if the cows are allocated to work on floors in an optimal fashion. Output this number rounded to the nearest integer; it is guaranteed that the solution will be more than 0.1 from the boundary between two integers.", "inputFormat": "The first line of input contains $N$ and $K$.\n\nThe next $N$ lines contain $a_1 \\ldots a_N$, each a positive integer of size at most $10^{12}$.", "outputFormat": "Please output the minimum time required to build the barn, rounded to the\n\nnearest integer.\n\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO17JAN] Building a Tall Barn P", "background": null, "description": "### 题目大意\nFJ 正在他的 $K$ 头奶牛的帮助下建造一个全新的 $N$ 层谷仓（$1\\le N\\le K\\le 10^{12}，N\\le 10^5$)。为了能够尽快的建造它，他需要你帮助他来找出如何在奶牛间分配工作。\n\n每一头牛必须分配到 $N$ 层中的某一个特定楼层中，并且每一层楼必须至少有一头牛在其中工作。第 $i$ 层楼需要 $a_i$ 个单位的工作，并且每一头牛完成每一单位的工作需要一个单位时间。所以如果有 $C$ 头牛在第 $i$ 层工作，那么第 $i$ 层需要 $\\frac{a_i}{c}$ 个单位时间。为了安全起见，在开始施工第 $i+1$ 层楼之前，必须先完成第 $i$ 层。\n\n如果奶牛被分配以最佳方式在楼层上工作，请计算完成谷仓的最小总时间。输出这个时间四舍五入到整数的结果；数据保证答案离两个整数间的中界大于 $0.1$。", "inputFormat": "第一行包括两个数 $N$ 和 $K$。\n\n接下来 $N$ 行包括了$a_1\\dots a_n$，每行一个不大于 $10^{12}$ 的正整数。", "outputFormat": "请输出完成谷仓的最小总时间（四舍五入至整数）。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3607", "type": "P", "difficulty": 6, "samples": [["9\n1\n2\n3\n9\n5\n6\n8\n7\n4", "9\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2017", "USACO", "枚举"], "title": "[USACO17JAN] Subsequence Reversal P", "background": "", "description": "Farmer John is arranging his $N$ cows in a line to take a photo ($1 \\leq N \\leq 50$). The height of the $i$th cow in sequence is $a(i)$, and Farmer John thinks it would make for an aesthetically pleasing photo if the cow lineup has a large increasing subsequence of cows by height.\n\nTo recall, a subsequence is a subset $a(i_1), a(i_2), \\ldots, a(i_k)$ of elements from the cow sequence, found at some series of indices $i_1 < i_2 < \\ldots < i_k$. We say the subsequence is increasing if $a(i_1) \\leq a(i_2) \\leq \\ldots \\leq a(i_k)$.\n\nFJ would like there to be a long increasing subsequence within his ordering of the cows. In order to ensure this, he allows himself initially to choose any subsequence and reverse its elements.\n\nFor example, if we had the list\n\n```\n1 6 2 3 4 3 5 3 4\n```\n\nWe can reverse the chosen elements\n\n```\n1 6 2 3 4 3 5 3 4\n  ^         ^ ^ ^\n```\nto get\n\n```\n1 4 2 3 4 3 3 5 6\n  ^         ^ ^ ^\n```\nObserve how the subsequence being reversed ends up using the same indices as it initially occupied, leaving the other elements unchanged.\n\nPlease find the maximum possible length of an increasing subsequence, given that you can choose to reverse an arbitrary subsequence once.", "inputFormat": "The first line of input contains $N$. The remaining $N$ lines contain $a(1) \\ldots a(N)$, each an integer in the range $1 \\ldots 50$.", "outputFormat": "Output the number of elements that can possibly form a longest increasing subsequence after reversing the contents of at most one subsequence.", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO17JAN] Subsequence Reversal P", "background": "", "description": "Farmer John is arranging his $N$ cows in a line to take a photo ($1 \\leq N \\leq 50$). The height of the $i$th cow in sequence is $a(i)$, and Farmer John thinks it would make for an aesthetically pleasing photo if the cow lineup has a large increasing subsequence of cows by height.\n\nTo recall, a subsequence is a subset $a(i_1), a(i_2), \\ldots, a(i_k)$ of elements from the cow sequence, found at some series of indices $i_1 < i_2 < \\ldots < i_k$. We say the subsequence is increasing if $a(i_1) \\leq a(i_2) \\leq \\ldots \\leq a(i_k)$.\n\nFJ would like there to be a long increasing subsequence within his ordering of the cows. In order to ensure this, he allows himself initially to choose any subsequence and reverse its elements.\n\nFor example, if we had the list\n\n```\n1 6 2 3 4 3 5 3 4\n```\n\nWe can reverse the chosen elements\n\n```\n1 6 2 3 4 3 5 3 4\n  ^         ^ ^ ^\n```\nto get\n\n```\n1 4 2 3 4 3 3 5 6\n  ^         ^ ^ ^\n```\nObserve how the subsequence being reversed ends up using the same indices as it initially occupied, leaving the other elements unchanged.\n\nPlease find the maximum possible length of an increasing subsequence, given that you can choose to reverse an arbitrary subsequence once.", "inputFormat": "The first line of input contains $N$. The remaining $N$ lines contain $a(1) \\ldots a(N)$, each an integer in the range $1 \\ldots 50$.", "outputFormat": "Output the number of elements that can possibly form a longest increasing subsequence after reversing the contents of at most one subsequence.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO17JAN] Subsequence Reversal P", "background": "", "description": "Farmer John 正在将他的 $N$ 头奶牛排成一列拍照（$1 \\leq N \\leq 50$）。序列中第 $i$ 头奶牛的高度为 $a(i)$，Farmer John 认为如果奶牛队列中存在一个较长的按高度递增的子序列，那么这张照片会更具美感。\n\n回顾一下，子序列是指从奶牛序列中选出的一组元素 $a(i_1), a(i_2), \\ldots, a(i_k)$，这些元素位于一系列索引 $i_1 < i_2 < \\ldots < i_k$ 处。如果满足 $a(i_1) \\leq a(i_2) \\leq \\ldots \\leq a(i_k)$，则称该子序列是递增的。\n\nFJ 希望在他的奶牛排列中存在一个较长的递增子序列。为了确保这一点，他允许自己最初选择任意一个子序列并将其元素反转。\n\n例如，如果我们有以下序列：\n\n```\n1 6 2 3 4 3 5 3 4\n```\n\n我们可以反转选中的元素：\n\n```\n1 6 2 3 4 3 5 3 4\n  ^         ^ ^ ^\n```\n\n得到：\n\n```\n1 4 2 3 4 3 3 5 6\n  ^         ^ ^ ^\n```\n\n注意被反转的子序列最终仍然使用最初占据的索引，而其他元素保持不变。\n\n请找出在最多反转一个子序列的情况下，可能的最长递增子序列的长度。", "inputFormat": "输入的第一行包含 $N$。接下来的 $N$ 行包含 $a(1) \\ldots a(N)$，每个数均为 $1$ 到 $50$ 之间的整数。", "outputFormat": "输出在最多反转一个子序列后，可能形成的最长递增子序列的元素个数。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3608", "type": "P", "difficulty": 4, "samples": [["7\n34\n6\n23\n0\n5\n99\n2", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "USACO", "树状数组", "枚举", "前缀和"], "title": "[USACO17JAN] Balanced Photo G", "background": "", "description": "Farmer John is arranging his $N$ cows in a line to take a photo ($1 \\leq N \\leq 100,000$). The height of the $i$th cow in sequence is $h_i$, and the heights of all cows are distinct.\n\nAs with all photographs of his cows, FJ wants this one to come out looking as nice as possible. He decides that cow $i$ looks \"unbalanced\" if $L_i$ and $R_i$ differ by more than factor of 2, where $L_i$ and $R_i$ are the number of cows taller than $i$ on her left and right, respectively. That is, $i$ is unbalanced if the larger of $L_i$ and $R_i$ is strictly more than twice the smaller of these two numbers. FJ is hoping that not too many of his cows are unbalanced.\n\nPlease help FJ compute the total number of unbalanced cows.\n\n", "inputFormat": "The first line of input contains $N$.  The next $N$ lines contain $h_1 \\ldots h_N$, each a nonnegative integer at most 1,000,000,000.\n\n", "outputFormat": "Please output a count of the number of cows that are unbalanced.\n\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO17JAN] Balanced Photo G", "background": "", "description": "Farmer John is arranging his $N$ cows in a line to take a photo ($1 \\leq N \\leq 100,000$). The height of the $i$th cow in sequence is $h_i$, and the heights of all cows are distinct.\n\nAs with all photographs of his cows, FJ wants this one to come out looking as nice as possible. He decides that cow $i$ looks \"unbalanced\" if $L_i$ and $R_i$ differ by more than factor of 2, where $L_i$ and $R_i$ are the number of cows taller than $i$ on her left and right, respectively. That is, $i$ is unbalanced if the larger of $L_i$ and $R_i$ is strictly more than twice the smaller of these two numbers. FJ is hoping that not too many of his cows are unbalanced.\n\nPlease help FJ compute the total number of unbalanced cows.\n\n", "inputFormat": "The first line of input contains $N$.  The next $N$ lines contain $h_1 \\ldots h_N$, each a nonnegative integer at most 1,000,000,000.\n\n", "outputFormat": "Please output a count of the number of cows that are unbalanced.\n\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO17JAN] Balanced Photo G", "background": null, "description": "FJ 正在安排他的 $N$ 头奶牛站成一排来拍照（$1\\le N \\le 10^5$）。序列中的第 $i$ 头奶牛的高度是 $h_i$，且序列中所有的奶牛的身高都不同。\n\n就像他的所有牛的照片一样，FJ 希望这张照片看上去尽可能好。他认为，如果 $L_i$ 和 $R_i$ 的数目相差 $1$ 倍以上，第 $i$ 头奶牛就是不平衡的（$L_i$ 和 $R_i$ 分别代表第 $i$ 头奶牛左右两边比她高的奶牛的数量）。也就是说，如果 $L_i$ 和 $R_i$ 中的较大数大于较小数的 $2$ 倍，第 $i$ 头奶牛就是不平衡的。FJ 不希望他有太多的奶牛不平衡。\n\n请帮助 FJ 计算不平衡的奶牛数量。", "inputFormat": "第一行一个整数 $N$。\n\n接下 $N$ 行包括 $H_1$ 到 $H_n$，每行一个不超过 $10^9$ 的非负整数。", "outputFormat": "请输出不平衡的奶牛数量。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3609", "type": "P", "difficulty": 4, "samples": [["5 1\nP\nP\nH\nP\nS", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "动态规划 DP", "搜索", "2017", "USACO", "枚举", "记忆化搜索"], "title": "[USACO17JAN] Hoof, Paper, Scissor G", "background": "*本题与 [银组同名题目](/problem/P6120) 在题意上一致，唯一的差别在于对变手势次数的限制。*\n", "description": "你可能玩过“石头，剪刀，布”，这个游戏在奶牛中同样流行，不过它的名字变成了“蹄子，剪刀，布”。\n\n“蹄子，剪刀，布”和“石头，剪刀，布”的规则十分类似，两只奶牛数到三，然后出一个代表蹄子，剪刀或布的手势。蹄子胜过剪刀，剪刀胜过布，布胜过蹄子。特别地，如果两只奶牛的手势相同，则视为平局。\n\n现在 FJ 和 Bassie 要进行 $N$ 轮对抗。Bassie 已经预测了 FJ 每一轮要出的手势。然而 Bassie 很懒，她最多只想变换 $K$ 次手势。\n\n现在请你帮 Bassie 求出她最多能赢多少轮。", "inputFormat": "第一行输入两个整数 $N,K$（$1 \\leq N \\leq 10^5$，$0 \\leq K \\leq 20$）。\n\n接下来 $N$ 行，每行一个字母，代表 FJ 这一轮出的手势。`H` 代表蹄子（Hoof），`S` 代表剪刀（Scissors），`P` 代表布（Paper）。", "outputFormat": "输出一个整数，代表 Bassie 在最多变换 $K$ 次手势的前提下最多赢多少轮。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[USACO17JAN] Hoof, Paper, Scissors G", "background": "*This problem has the same statement as the [problem with the same name in the Silver division](/problem/P6120). The only difference is the limit on how many times the gesture can be changed.*", "description": "You might have played “Rock, Paper, Scissors.” This game is also popular among cows, but it is called “Hoof, Scissors, Paper.”\n\nThe rules of “Hoof, Scissors, Paper” are very similar to “Rock, Paper, Scissors.” Two cows count to three, then show one of the gestures representing hoof, scissors, or paper. Hoof beats scissors, scissors beat paper, and paper beats hoof. In particular, if both cows show the same gesture, it is a tie.\n\nNow FJ and Bessie will play $N$ rounds. Bessie has already predicted FJ’s gesture in each round. However, Bessie is lazy and wants to change her gesture at most $K$ times.\n\nPlease help Bessie determine the maximum number of rounds she can win.", "inputFormat": "The first line contains two integers $N,K$ ($1 \\leq N \\leq 10^5$, $0 \\leq K \\leq 20$).\n\nThe next $N$ lines each contain one letter, representing FJ’s gesture in that round. `H` stands for hoof (Hoof), `S` stands for scissors (Scissors), and `P` stands for paper (Paper).", "outputFormat": "Output a single integer, the maximum number of rounds Bessie can win if she can change her gesture at most $K$ times.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO17JAN] Hoof, Paper, Scissor G", "background": "*本题与 [银组同名题目](/problem/P6120) 在题意上一致，唯一的差别在于对变手势次数的限制。*\n", "description": "你可能玩过“石头，剪刀，布”，这个游戏在奶牛中同样流行，不过它的名字变成了“蹄子，剪刀，布”。\n\n“蹄子，剪刀，布”和“石头，剪刀，布”的规则十分类似，两只奶牛数到三，然后出一个代表蹄子，剪刀或布的手势。蹄子胜过剪刀，剪刀胜过布，布胜过蹄子。特别地，如果两只奶牛的手势相同，则视为平局。\n\n现在 FJ 和 Bassie 要进行 $N$ 轮对抗。Bassie 已经预测了 FJ 每一轮要出的手势。然而 Bassie 很懒，她最多只想变换 $K$ 次手势。\n\n现在请你帮 Bassie 求出她最多能赢多少轮。", "inputFormat": "第一行输入两个整数 $N,K$（$1 \\leq N \\leq 10^5$，$0 \\leq K \\leq 20$）。\n\n接下来 $N$ 行，每行一个字母，代表 FJ 这一轮出的手势。`H` 代表蹄子（Hoof），`S` 代表剪刀（Scissors），`P` 代表布（Paper）。", "outputFormat": "输出一个整数，代表 Bassie 在最多变换 $K$ 次手势的前提下最多赢多少轮。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3610", "type": "P", "difficulty": 3, "samples": [["3\nEHE\nEEE\nEEE", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "USACO", "广度优先搜索 BFS", "栈", "队列"], "title": "[USACO17JAN] Cow Navigation G", "background": "", "description": "Bessie has gotten herself stuck on the wrong side of Farmer John's barn again, and since her vision is so poor, she needs your help navigating across the barn.\n\nThe barn is described by an $N \\times N$ grid of square cells ($2 \\leq N \\leq 20$), some being empty and some containing impassable haybales. Bessie starts in the lower-left corner (cell 1,1) and wants to move to the upper-right corner (cell $N,N$). You can guide her by telling her a sequence of instructions, each of which is either \"forward\", \"turn left 90 degrees\", or \"turn right 90 degrees\". You want to issue the shortest sequence of instructions that will guide her to her destination. If you instruct Bessie to move off the grid (i.e., into the barn wall) or into a haybale, she will not move and will skip to the next command in your sequence.\n\nUnfortunately, Bessie doesn't know if she starts out facing up (towards cell 1,2) or right (towards cell 2,1). You need to give the shortest sequence of directions that will guide her to the goal regardless of which case is true. Once she reaches the goal she will ignore further commands.\n\n", "inputFormat": "The first line of input contains $N$.\n\nEach of the $N$ following lines contains a string of exactly $N$ characters, representing the barn. The first character of the last line is cell 1,1. The last character of the first line is cell N, N.\n\nEach character will either be an H to represent a haybale or an E to represent an empty square.\n\nIt is guaranteed that cells 1,1 and $N,N$ will be empty, and furthermore it is guaranteed that there is a path of empty squares from cell 1,1 to cell $N, N$.\n", "outputFormat": "On a single line of output, output the length of the shortest sequence of directions that will guide Bessie to the goal, irrespective whether she starts facing up or right.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO17JAN] Cow Navigation G", "background": "", "description": "Bessie has gotten herself stuck on the wrong side of Farmer John's barn again, and since her vision is so poor, she needs your help navigating across the barn.\n\nThe barn is described by an $N \\times N$ grid of square cells ($2 \\leq N \\leq 20$), some being empty and some containing impassable haybales. Bessie starts in the lower-left corner (cell 1,1) and wants to move to the upper-right corner (cell $N,N$). You can guide her by telling her a sequence of instructions, each of which is either \"forward\", \"turn left 90 degrees\", or \"turn right 90 degrees\". You want to issue the shortest sequence of instructions that will guide her to her destination. If you instruct Bessie to move off the grid (i.e., into the barn wall) or into a haybale, she will not move and will skip to the next command in your sequence.\n\nUnfortunately, Bessie doesn't know if she starts out facing up (towards cell 1,2) or right (towards cell 2,1). You need to give the shortest sequence of directions that will guide her to the goal regardless of which case is true. Once she reaches the goal she will ignore further commands.\n\n", "inputFormat": "The first line of input contains $N$.\n\nEach of the $N$ following lines contains a string of exactly $N$ characters, representing the barn. The first character of the last line is cell 1,1. The last character of the first line is cell N, N.\n\nEach character will either be an H to represent a haybale or an E to represent an empty square.\n\nIt is guaranteed that cells 1,1 and $N,N$ will be empty, and furthermore it is guaranteed that there is a path of empty squares from cell 1,1 to cell $N, N$.\n", "outputFormat": "On a single line of output, output the length of the shortest sequence of directions that will guide Bessie to the goal, irrespective whether she starts facing up or right.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO17JAN] Cow Navigation G", "background": null, "description": "Bessie 又一次被困在了 Farmer John 的谷仓的错误一侧，由于她的视力很差，她需要你的帮助来穿过谷仓。\n\n谷仓由一个 $N \\times N$ 的方格网格描述（$2 \\leq N \\leq 20$），其中一些格子是空的，另一些则包含无法通过的干草堆。Bessie 从左下角（格子 1,1）开始，想要移动到右上角（格子 $N,N$）。你可以通过告诉她一系列指令来引导她，每条指令可以是“前进”、“向左转 90 度”或“向右转 90 度”。你需要给出最短的指令序列，以引导她到达目的地。如果你指示 Bessie 移动到网格外（即撞到谷仓墙壁）或进入干草堆，她将不会移动，并跳到你序列中的下一条指令。\n\n不幸的是，Bessie 不知道她最初是面朝上（朝向格子 1,2）还是面朝右（朝向格子 2,1）。你需要给出一个最短的指令序列，无论她最初面朝哪个方向，都能引导她到达目标。一旦她到达目标，她将忽略后续的指令。", "inputFormat": "输入的第一行包含 $N$。\n\n接下来的 $N$ 行每行包含一个长度为 $N$ 的字符串，表示谷仓。最后一行的第一个字符是格子 1,1，第一行的最后一个字符是格子 $N,N$。\n\n每个字符要么是 H 表示干草堆，要么是 E 表示空方格。\n\n保证格子 1,1 和 $N,N$ 是空的，并且保证存在一条从格子 1,1 到格子 $N,N$ 的空方格路径。", "outputFormat": "输出一行，表示无论 Bessie 最初面朝哪个方向，都能引导她到达目标的最短指令序列的长度。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3611", "type": "P", "difficulty": 4, "samples": [["5 8\n4\n7\n8\n6\n4", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2017", "线段树", "二分", "USACO", "优先队列", "队列"], "title": "[USACO17JAN] Cow Dance Show S", "background": "", "description": "After several months of rehearsal, the cows are just about ready to put on their annual dance performance; this year they are performing the famous bovine ballet \"Cowpelia\".\n\nThe only aspect of the show that remains to be determined is the size of the stage. A stage of size $K$ can support $K$ cows dancing simultaneously. The $N$ cows in the herd ($1 \\leq N \\leq 10,000$) are conveniently numbered $1 \\ldots N$ in the order in which they must appear in the dance. Each cow $i$ plans to dance for a specific duration of time $d(i)$. Initially, cows $1 \\ldots K$ appear on stage and start dancing. When the first of these cows completes her part, she leaves the stage and cow $K+1$ immediately starts dancing, and so on, so there are always $K$ cows dancing (until the end of the show, when we start to run out of cows). The show ends when the last cow completes her dancing part, at time $T$.\n\nClearly, the larger the value of $K$, the smaller the value of $T$. Since the show cannot last too long, you are given as input an upper bound $T_{max}$ specifying the largest possible value of $T$. Subject to this constraint, please determine the smallest possible value of $K$.\n\n", "inputFormat": "The first line of input contains $N$ and $T_{max}$, where $T_{max}$ is an integer of value at most 1 million.\n\nThe next $N$ lines give the durations $d(1) \\ldots d(N)$ of the dancing parts for cows $1 \\ldots N$. Each $d(i)$ value is an integer in the range $1 \\ldots 100,000$.\n\nIt is guaranteed that if $K=N$, the show will finish in time.\n\n", "outputFormat": "Print out the smallest possible value of $K$ such that the dance performance will take no more than $T_{max}$ units of time.\n\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO17JAN] Cow Dance Show S", "background": "", "description": "After several months of rehearsal, the cows are just about ready to put on their annual dance performance; this year they are performing the famous bovine ballet \"Cowpelia\".\n\nThe only aspect of the show that remains to be determined is the size of the stage. A stage of size $K$ can support $K$ cows dancing simultaneously. The $N$ cows in the herd ($1 \\leq N \\leq 10,000$) are conveniently numbered $1 \\ldots N$ in the order in which they must appear in the dance. Each cow $i$ plans to dance for a specific duration of time $d(i)$. Initially, cows $1 \\ldots K$ appear on stage and start dancing. When the first of these cows completes her part, she leaves the stage and cow $K+1$ immediately starts dancing, and so on, so there are always $K$ cows dancing (until the end of the show, when we start to run out of cows). The show ends when the last cow completes her dancing part, at time $T$.\n\nClearly, the larger the value of $K$, the smaller the value of $T$. Since the show cannot last too long, you are given as input an upper bound $T_{max}$ specifying the largest possible value of $T$. Subject to this constraint, please determine the smallest possible value of $K$.\n\n", "inputFormat": "The first line of input contains $N$ and $T_{max}$, where $T_{max}$ is an integer of value at most 1 million.\n\nThe next $N$ lines give the durations $d(1) \\ldots d(N)$ of the dancing parts for cows $1 \\ldots N$. Each $d(i)$ value is an integer in the range $1 \\ldots 100,000$.\n\nIt is guaranteed that if $K=N$, the show will finish in time.\n\n", "outputFormat": "Print out the smallest possible value of $K$ such that the dance performance will take no more than $T_{max}$ units of time.\n\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO17JAN] Cow Dance Show S", "background": "", "description": "经过几个月的排练，奶牛们基本准备好展出她们的年度舞蹈表演。今年她们要表演的是著名的奶牛芭蕾——“cowpelia”。\n\n表演唯一有待决定的是舞台的尺寸。一个大小为 $K$ 的舞台可以支持 $K$ 头牛同时在舞台上跳舞。在牛群中的 $N$ 头牛按照她们必须出现在舞蹈中的顺序方便地编号为 $1,2,\\dots,N$。第 $i$ 头牛计划跳 $d_i$ 的特定持续时间。\n一开始，第 $1,2,\\dots,K$ 头牛出现在舞台上并开始跳舞。当这些牛中的某一头牛首先完成了她的部分，她会马上离开舞台并且第 $K+1$ 头牛会出现在舞台上并开始跳舞。所以，舞台上总有 $K$ 头奶牛在跳舞（直到表演的尾声，奶牛不够的时候）。当最后一头奶牛完成了她的舞蹈部分，表演结束，共花了 $T$ 个单位时间。\n\n显然，$K$ 的值越大，$T$ 就越小。由于表演不能拖太长，你得知了指定 $T$ 的最大可能值的上限 $T_{max}$。请根据这个约束，确定 $K$ 的最小值。", "inputFormat": "第一行包括 $N$ 和 $T_{max}$ 两个整数。\n\n接下来的 $N$ 行，第 $i$ 行给出了第 $i$ 头牛跳舞的持续时间 $d_i$。第 $i$ 行包括一个整数 $d_i$。\n\n保证 $K=N$ 时表演会按时完成。", "outputFormat": "输出在表演时间不大于 $T_{max}$ 时的 $K$ 的最小可能值。", "hint": "对于 $100\\%$ 的数据，$1 \\le N \\le 10^4$，$T_{max} \\le 10^6$，$1 \\le d_i \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P3612", "type": "P", "difficulty": 2, "samples": [["COW 8", "C"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2017", "USACO", "递归", "分治", "栈"], "title": "[USACO17JAN] Secret Cow Code S", "background": "", "description": "The cows are experimenting with secret codes, and have devised a method for creating an infinite-length string to be used as part of one of their codes.\n\nGiven a string $s$, let $F(s)$ be $s$ followed by $s$ \"rotated\" one character to the right (in a right rotation, the last character of $s$ rotates around and becomes the new first character). Given an initial string $s$, the cows build their infinite-length code string by repeatedly applying $F$; each step therefore doubles the length of the current string.\n\n\nGiven the initial string and an index $N$, please help the cows compute the character at the $N$th position within the infinite code string.\n\n", "inputFormat": "The input consists of a single line containing a string followed by $N$. The string consists of at most 30 uppercase characters, and $N \\leq 10^{18}$.\n\nNote that $N$ may be too large to fit into a standard 32-bit integer, so you may want to use a 64-bit integer type (e.g., a \"long long\" in C/C++).\n\n", "outputFormat": "Please output the $N$th character of the infinite code built from the initial string. The first character is $N=1$.\n\n\n", "hint": "In this example, the initial string COW expands as follows:\n\n\nCOW -> COWWCO -> COWWCOOCOWWC\n\n12345678\n\n\n", "locale": "en", "translations": {"en": {"title": "[USACO17JAN] Secret Cow Code S", "background": "", "description": "The cows are experimenting with secret codes, and have devised a method for creating an infinite-length string to be used as part of one of their codes.\n\nGiven a string $s$, let $F(s)$ be $s$ followed by $s$ \"rotated\" one character to the right (in a right rotation, the last character of $s$ rotates around and becomes the new first character). Given an initial string $s$, the cows build their infinite-length code string by repeatedly applying $F$; each step therefore doubles the length of the current string.\n\n\nGiven the initial string and an index $N$, please help the cows compute the character at the $N$th position within the infinite code string.\n\n", "inputFormat": "The input consists of a single line containing a string followed by $N$. The string consists of at most 30 uppercase characters, and $N \\leq 10^{18}$.\n\nNote that $N$ may be too large to fit into a standard 32-bit integer, so you may want to use a 64-bit integer type (e.g., a \"long long\" in C/C++).\n\n", "outputFormat": "Please output the $N$th character of the infinite code built from the initial string. The first character is $N=1$.\n\n\n", "hint": "In this example, the initial string COW expands as follows:\n\n\nCOW -> COWWCO -> COWWCOOCOWWC\n\n12345678\n\n\n", "locale": "en"}, "zh-CN": {"title": "[USACO17JAN] Secret Cow Code S", "background": "", "description": "奶牛们正在实验秘密代码，并设计了一种方法用于生成无限长度的字符串，作为他们代码的一部分。\n\n给定一个字符串 $s$，令 $F(s)$ 为 $s$ 后接 $s$ 向右“旋转”一个字符的结果（在右旋转中，$s$ 的最后一个字符旋转并成为新的第一个字符）。给定初始字符串 $s$，奶牛们通过重复应用 $F$ 来构建他们的无限长度代码字符串；因此每一步都会使当前字符串的长度翻倍。\n\n给定初始字符串和一个索引 $N$，请帮助奶牛计算无限代码字符串中第 $N$ 个位置的字符。", "inputFormat": "输入由一行组成，包含一个字符串和 $N$。字符串最多由 30 个大写字母组成，且 $N \\leq 10^{18}$。\n\n请注意，$N$ 可能太大，无法放入标准的 32 位整数中，因此你可能需要使用 64 位整数类型（例如，C/C++ 中的 \"long long\"）。", "outputFormat": "请输出从初始字符串构建的无限代码字符串的第 $N$ 个字符。第一个字符的位置为 $N=1$。", "hint": "在这个例子中，初始字符串 COW 按以下方式扩展：\n\nCOW -> COWWCO -> COWWCOOCOWWC", "locale": "zh-CN"}}}
{"pid": "P3613", "type": "P", "difficulty": 2, "samples": [["5 4\n1 3 10000 118014\n1 1 1 1\n2 3 10000\n2 1 1", "118014\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["STL"], "title": "【深基15.例2】寄包柜", "background": null, "description": "超市里有 $n(1\\le n\\le10^5)$ 个寄包柜。每个寄包柜格子数量不一，第 $i$ 个寄包柜有 $a_i(0\\le a_i\\le10^5)$ 个格子，不过我们并不知道各个 $a_i$ 的值。对于每个寄包柜，格子编号从 1 开始，一直到 $a_i$。现在有 $q(1 \\le q\\le10^5)$ 次操作：\n\n- `1 i j k`：在第 $i$ 个柜子的第 $j$ 个格子存入物品 $k(0\\le k\\le 10^9)$。当 $k=0$ 时说明清空该格子。\n- `2 i j`：查询第 $i$ 个柜子的第 $j$ 个格子中的物品是什么，保证查询的柜子有存过东西。\n\n已知超市里共计不会超过 $10^7$ 个寄包格子，$a_i$ 是确定然而未知的，但是保证一定不小于该柜子存物品请求的格子编号的最大值。当然也有可能某些寄包柜中一个格子都没有。", "inputFormat": "第一行 2 个整数 $n$ 和 $q$，寄包柜个数和询问次数。\n\n接下来 $q$ 个行，每行有若干个整数，表示一次操作。", "outputFormat": "对于查询操作时，输出答案，以换行隔开。", "hint": "$\\text{upd 2022.7.26}$：新增加一组 Hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "[Shenji 15. Example 2] Parcel Locker", "background": "", "description": "There are $n(1\\le n\\le10^5)$ parcel lockers in a supermarket. Each locker has a different number of compartments. The $i$-th locker has $a_i(0\\le a_i\\le10^5)$ compartments, but we do not know the values of $a_i$. For each locker, the compartments are numbered from 1 to $a_i$. Now there are $q(1 \\le q\\le10^5)$ operations:\n\n- `1 i j k`: Put item $k(0\\le k\\le 10^9)$ into compartment $j$ of locker $i$. When $k=0$, it means clearing that compartment.\n- `2 i j`: Query what item is in compartment $j$ of locker $i$. It is guaranteed that the queried locker has had items stored in it.\n\nIt is known that the total number of compartments in the supermarket will not exceed $10^7$. The values $a_i$ are fixed but unknown, and it is guaranteed that $a_i$ is at least the maximum compartment index ever used in a store-item request for that locker. Of course, it is also possible that some lockers do not have even a single compartment.", "inputFormat": "The first line contains 2 integers $n$ and $q$, the number of parcel lockers and the number of queries.\n\nThe next $q$ lines each contain several integers, representing one operation.", "outputFormat": "For each query operation, output the answer, one per line.", "hint": "$\\text{upd 2022.7.26}$: A new set of hack testdata has been added.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【深基15.例2】寄包柜", "background": null, "description": "超市里有 $n(1\\le n\\le10^5)$ 个寄包柜。每个寄包柜格子数量不一，第 $i$ 个寄包柜有 $a_i(0\\le a_i\\le10^5)$ 个格子，不过我们并不知道各个 $a_i$ 的值。对于每个寄包柜，格子编号从 1 开始，一直到 $a_i$。现在有 $q(1 \\le q\\le10^5)$ 次操作：\n\n- `1 i j k`：在第 $i$ 个柜子的第 $j$ 个格子存入物品 $k(0\\le k\\le 10^9)$。当 $k=0$ 时说明清空该格子。\n- `2 i j`：查询第 $i$ 个柜子的第 $j$ 个格子中的物品是什么，保证查询的柜子有存过东西。\n\n已知超市里共计不会超过 $10^7$ 个寄包格子，$a_i$ 是确定然而未知的，但是保证一定不小于该柜子存物品请求的格子编号的最大值。当然也有可能某些寄包柜中一个格子都没有。", "inputFormat": "第一行 2 个整数 $n$ 和 $q$，寄包柜个数和询问次数。\n\n接下来 $q$ 个行，每行有若干个整数，表示一次操作。", "outputFormat": "对于查询操作时，输出答案，以换行隔开。", "hint": "$\\text{upd 2022.7.26}$：新增加一组 Hack 数据。", "locale": "zh-CN"}}}
{"pid": "P3614", "type": "P", "difficulty": 6, "samples": [["7\n0\nxxoooxx\nxxoyoxx\noooyooo\nooooooo\nooooooo\nxxoooxx\nxxoooxx", "2 4 D"], ["7\n2\n2 4\n3 4", "3 4 U"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["洛谷原创", "提交答案", "Special Judge", "洛谷月赛"], "title": "yyy 棋 II", "background": "本题是提交答案题，所有测试数据的输入均开放下载。选手需要提供输出数据。洛谷评测机会根据提交的数据来评分。\n\n输入数据和 windows 的 checker\n\nhttp://pan.baidu.com/s/1jHU2UwQ\n\nlinux 的 checker\n\nhttp://pan.baidu.com/s/1nv8Yuy1\n\n#udp1：所有答案文件末尾必须有且只有一个回车", "description": "我们的英明的 yyy 某日无聊，发明了一款风靡世界的游戏。为了纪念这个伟大的发明，自己起名为“yyy棋”。\n\n在其中的一种情况下棋盘是长这样的：\n\n```\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n．．．．．．．\n．．．．．．．\n．．．．．．．\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n```\n这种情况下一个 $7\\times7$ 的棋盘，`.` 上可以走棋，而 `x` 上不能。只有1种棋子，我们假设是 `Y`。\n\n最开始的初始棋子和障碍都是系统给定的。我们假设是这个样子：\n\n```\nｘｘ．．．ｘｘ\nｘｘ．Ｙ．ｘｘ\n．．．Ｙ．．．\n．．．．．．．\n．．．．．．．\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n```\n走棋的规则很简单。任意一个棋子可以而且仅可以跳过它相邻的上下左右的一颗棋子而移动两格，而且目的地没有棋子且不是 `x`。跳过之后，被跳的那个棋子就会消失。所以像刚刚给出的的那个，我们可以将上方的一个棋子跳到下方，然后就成了这样：\n\n```\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n．．．．．．．\n．．．Ｙ．．．\n．．．．．．．\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n```\n我们的目标是通过一系列运动，消除尽可能多的棋子。希望最后可以只留下一个棋子。由于 yyy 有强迫症，他还希望最后的这一个棋子能够停留在**中央**。", "inputFormat": "所有输入数据 `yyychess1.in`~`yyychess10.in` ，分别对应 $10$ 个任务。\n\n对于每一个任务：\n\n第一行一个整数 $N$，表示棋盘的大小。\n\n为了方便选手，我们定义坐标 $(i,j)$ 为第 $i$ 行第 $j$ 列。\n\n接下来一行，一个自然数 $M$。\n\n- 如果 $M=0$，那么\n\n接下来是 $N\\times N$ 的矩阵序列。我们用 `x` 表示不可走的地方，`o` 表示可以走但是没有放棋的地方，`y` 表示放棋的地方。每个字符不用空格隔开。\n\n- 如果 $M>0$，那么\n\n接下来是 $M$ 行，每行两个数字，依次表示每个棋子的坐标。这种情况下，没有障碍点。", "outputFormat": "输出若干行，表示走法。\n\n对于每一行，输出两个数字和一个字母。两个数字代表 $(i,j)$ 也就是棋子的坐标，剩下的一个字母是 `UDLR` 中的一个，分别表示上下左右跳。", "hint": "### 样例解释\n\n两个样例描述的是同一个棋盘，只是第二个没有障碍点。\n\n第一个样例输出，可以拿 $100\\%$ 的分数。\n\n第二个样例输出，只能拿 $90\\%$ 的分数，因为最后没有在中心 $(\\frac{n+1}{2},\\frac{n+1}{2})$。\n\n### 评分标准\n\n当你的答案是合法的，并且最后只剩下一个棋子，而且这个棋子在最中心，得该点 $100\\%$ 的分数。\n\n当你的答案是合法的，并且最后只剩下一个棋子，而且这个棋子不在最中心，得该点 $90\\%$ 的分数。\n\n当你的答案是合法的，并且最后剩下 $2$ 个，$3$ 个，$4/5$ 个棋子，分别得该点 $80\\%$，$60\\%$，$40\\%$的分数。\n\n除此之外，包括有非法的走法以及剩下超过 $5$ 个棋子的，该点不得分。\n\n压缩文件提供 `checker.exe` 可供预先使用。\n\n#### 方法\n\n所有文件解压，在命令行中输入 `checker.exe yyychess1.in youranswer.txt youranswer.txt` (最后两个是你的输出文件，请输入两次)\n\n就会告诉你结果。", "locale": "zh-CN", "translations": {"en": {"title": "yyy Chess II", "background": "This is an output-only problem. All input testdata are available for download. Contestants need to provide output data. The Luogu judge will score based on the submitted data.\n\nInput testdata and checker for Windows:\nhttp://pan.baidu.com/s/1jHU2UwQ\n\nChecker for Linux:\nhttp://pan.baidu.com/s/1nv8Yuy1\n\nUpdate 1: All answer files must have exactly one trailing newline.", "description": "Our brilliant yyy once got bored and invented a game that took the world by storm. To commemorate this great invention, he named it “yyy Chess.”\n\nIn one scenario, the board looks like this:\n\n```\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n．．．．．．．\n．．．．．．．\n．．．．．．．\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n```\nIn this case, it is a $7\\times7$ board. You can move on `.`, but not on `x`. There is only one type of piece, which we denote as `Y`.\n\nThe initial pieces and obstacles are given by the system. Suppose it looks like this:\n\n```\nｘｘ．．．ｘｘ\nｘｘ．Ｙ．ｘｘ\n．．．Ｙ．．．\n．．．．．．．\n．．．．．．．\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n```\nThe rules are simple. Any piece can, and only can, jump over one adjacent piece in the up, down, left, or right direction, moving two squares, and the destination must be empty and not `x`. After the jump, the jumped-over piece disappears. For example, in the configuration above, we can jump the upper piece downward, after which it becomes:\n\n```\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n．．．．．．．\n．．．Ｙ．．．\n．．．．．．．\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n```\nOur goal is to eliminate as many pieces as possible through a sequence of moves, ideally leaving exactly one piece. Since yyy has OCD, he also wants the last piece to stay at the **center**.", "inputFormat": "All input data `yyychess1.in` ~ `yyychess10.in` correspond to $10$ tasks.\n\nFor each task:\n\nThe first line contains an integer $N$, the size of the board.\n\nFor convenience, we define coordinate $(i, j)$ as row $i$, column $j$.\n\nThe next line contains a natural number $M$.\n\n- If $M=0$, then\n\nNext comes an $N\\times N$ matrix. We use `x` to denote an unplayable cell, `o` for an empty playable cell, and `y` for a cell with a piece. Characters are not separated by spaces.\n\n- If $M>0$, then\n\nNext come $M$ lines, each with two numbers, giving the coordinates of each piece. In this case, there are no obstacle cells.", "outputFormat": "Output several lines, each representing a move.\n\nFor each line, output two numbers and one letter. The two numbers represent $(i,j)$, i.e., the coordinate of the piece, and the letter is one of `UDLR`, representing a jump in the up, down, left, or right direction, respectively.", "hint": "### Sample Explanation\n\nThe two samples describe the same board; the second one simply has no obstacle cells.\n\nWith the first sample output, you can score $100\\%$.\n\nWith the second sample output, you can only score $90\\%$, because the final piece is not at the center $(\\frac{n+1}{2},\\frac{n+1}{2})$.\n\n### Scoring Rules\n\nIf your answer is valid, and exactly one piece remains at the very center, you score $100\\%$ for that testcase.\n\nIf your answer is valid, and exactly one piece remains but not at the center, you score $90\\%$ for that testcase.\n\nIf your answer is valid, and $2$, $3$, or $4$/$5$ pieces remain, you score $80\\%$, $60\\%$, or $40\\%$ for that testcase, respectively.\n\nOtherwise, including having illegal moves or more than $5$ pieces remaining, you score $0$ for that testcase.\n\nThe archive provides `checker.exe` for preliminary use.\n\n#### Method\n\nUnzip all files, then run on the command line:\n`checker.exe yyychess1.in youranswer.txt youranswer.txt` (the last two are your output file; please enter it twice),\nand it will tell you the result.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "yyy 棋 II", "background": "本题是提交答案题，所有测试数据的输入均开放下载。选手需要提供输出数据。洛谷评测机会根据提交的数据来评分。\n\n输入数据和 windows 的 checker\n\nhttp://pan.baidu.com/s/1jHU2UwQ\n\nlinux 的 checker\n\nhttp://pan.baidu.com/s/1nv8Yuy1\n\n#udp1：所有答案文件末尾必须有且只有一个回车", "description": "我们的英明的 yyy 某日无聊，发明了一款风靡世界的游戏。为了纪念这个伟大的发明，自己起名为“yyy棋”。\n\n在其中的一种情况下棋盘是长这样的：\n\n```\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n．．．．．．．\n．．．．．．．\n．．．．．．．\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n```\n这种情况下一个 $7\\times7$ 的棋盘，`.` 上可以走棋，而 `x` 上不能。只有1种棋子，我们假设是 `Y`。\n\n最开始的初始棋子和障碍都是系统给定的。我们假设是这个样子：\n\n```\nｘｘ．．．ｘｘ\nｘｘ．Ｙ．ｘｘ\n．．．Ｙ．．．\n．．．．．．．\n．．．．．．．\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n```\n走棋的规则很简单。任意一个棋子可以而且仅可以跳过它相邻的上下左右的一颗棋子而移动两格，而且目的地没有棋子且不是 `x`。跳过之后，被跳的那个棋子就会消失。所以像刚刚给出的的那个，我们可以将上方的一个棋子跳到下方，然后就成了这样：\n\n```\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n．．．．．．．\n．．．Ｙ．．．\n．．．．．．．\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n```\n我们的目标是通过一系列运动，消除尽可能多的棋子。希望最后可以只留下一个棋子。由于 yyy 有强迫症，他还希望最后的这一个棋子能够停留在**中央**。", "inputFormat": "所有输入数据 `yyychess1.in`~`yyychess10.in` ，分别对应 $10$ 个任务。\n\n对于每一个任务：\n\n第一行一个整数 $N$，表示棋盘的大小。\n\n为了方便选手，我们定义坐标 $(i,j)$ 为第 $i$ 行第 $j$ 列。\n\n接下来一行，一个自然数 $M$。\n\n- 如果 $M=0$，那么\n\n接下来是 $N\\times N$ 的矩阵序列。我们用 `x` 表示不可走的地方，`o` 表示可以走但是没有放棋的地方，`y` 表示放棋的地方。每个字符不用空格隔开。\n\n- 如果 $M>0$，那么\n\n接下来是 $M$ 行，每行两个数字，依次表示每个棋子的坐标。这种情况下，没有障碍点。", "outputFormat": "输出若干行，表示走法。\n\n对于每一行，输出两个数字和一个字母。两个数字代表 $(i,j)$ 也就是棋子的坐标，剩下的一个字母是 `UDLR` 中的一个，分别表示上下左右跳。", "hint": "### 样例解释\n\n两个样例描述的是同一个棋盘，只是第二个没有障碍点。\n\n第一个样例输出，可以拿 $100\\%$ 的分数。\n\n第二个样例输出，只能拿 $90\\%$ 的分数，因为最后没有在中心 $(\\frac{n+1}{2},\\frac{n+1}{2})$。\n\n### 评分标准\n\n当你的答案是合法的，并且最后只剩下一个棋子，而且这个棋子在最中心，得该点 $100\\%$ 的分数。\n\n当你的答案是合法的，并且最后只剩下一个棋子，而且这个棋子不在最中心，得该点 $90\\%$ 的分数。\n\n当你的答案是合法的，并且最后剩下 $2$ 个，$3$ 个，$4/5$ 个棋子，分别得该点 $80\\%$，$60\\%$，$40\\%$的分数。\n\n除此之外，包括有非法的走法以及剩下超过 $5$ 个棋子的，该点不得分。\n\n压缩文件提供 `checker.exe` 可供预先使用。\n\n#### 方法\n\n所有文件解压，在命令行中输入 `checker.exe yyychess1.in youranswer.txt youranswer.txt` (最后两个是你的输出文件，请输入两次)\n\n就会告诉你结果。", "locale": "zh-CN"}}}
