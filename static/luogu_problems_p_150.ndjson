{"pid": "P4038", "type": "P", "difficulty": 4, "samples": [["1 2 1\n2 3 2\n3 1 6\n1 2 5\n2 3 3\n3 1 4\n0 0\n1 2 1\n2 3 2\n1 3 3\n2 4 4\n0 0\n0 0", "1 2 3 5 4 6\nRound trip does not exist."]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["图论", "Special Judge", "欧拉回路", "ICPC", "CERC"], "title": "[CERC 1995] John's Trip", "background": "", "description": "John 有很多朋友住在不同的街，John 想去访问每位朋友，同时希望走的路最少。因为道路很窄，John 在一条路上不能往回走。John 希望从家里出发，拜访完所有的朋友后回到自己的家，且总的路程最短。John 意识到如果可以每条道路都只走一次然后返回起点应该是最短的路径。写一个程序帮助 John 找到这样的路径。给出的每条街连接两个路口。街分别编号为 $1$ 到 $n$，路口分别编号为 $1$ 到 $m$。", "inputFormat": "多组数据。  \n\n每组数据有多行，每行由三个整数组成：$x,y,z$。$z$ 为这条街的编号，$x$ 和 $y$ 表示这条街连接的两个路口的编号。可能有自环。  \n\n对于每组数据，John 住在第一行中连接的两个顶点中编号较小的路口处。所有的街都可以连通到其他街上。`0 0` 表示一组数据的结束。  \n\n再一个`0 0`表示输入的结束。", "outputFormat": "如果能找到所有街道遍历一次的回路，输出找到的路径，两个整数之间用一个空格隔开，行末无空格。如果不存在，输出`Round trip does not exist.`。", "hint": "最多有 $1995$ 条街，最多 $44$ 个路口。", "locale": "zh-CN", "translations": {"en": {"title": "[CERC 1995] John's Trip", "background": "", "description": "John has many friends living on different streets and wants to visit each friend while traveling as little as possible. Because the streets are narrow, John cannot go back along the same street. He wants to start from his home, visit all his friends, and return home, with the minimum total distance. John realizes that if he can traverse each street exactly once and return to the starting point, that should be the shortest route. Write a program to help John find such a route. Each street connects two intersections. The streets are numbered from $1$ to $n$, and the intersections are numbered from $1$ to $m$.", "inputFormat": "Multiple testcases.  \n\nEach testcase consists of several lines, each line containing three integers: $x, y, z$. Here, $z$ is the index of the street, and $x$ and $y$ are the indices of the two intersections that the street connects. Self-loops may appear.  \n\nFor each testcase, John lives at the intersection with the smaller index among the two intersections listed on the first line. The graph is connected.  \n\nA line containing two integers `0 0` ends the current testcase. Two consecutive lines `0 0` indicate the end of input.", "outputFormat": "If there exists a circuit that traverses every street exactly once, output the route found as a sequence of street indices in the traversal order, with a single space between adjacent integers and no trailing space at the end of the line. Otherwise, output `Round trip does not exist.`.", "hint": "At most $1995$ streets and at most $44$ intersections.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC 1995] John's Trip", "background": "", "description": "John 有很多朋友住在不同的街，John 想去访问每位朋友，同时希望走的路最少。因为道路很窄，John 在一条路上不能往回走。John 希望从家里出发，拜访完所有的朋友后回到自己的家，且总的路程最短。John 意识到如果可以每条道路都只走一次然后返回起点应该是最短的路径。写一个程序帮助 John 找到这样的路径。给出的每条街连接两个路口。街分别编号为 $1$ 到 $n$，路口分别编号为 $1$ 到 $m$。", "inputFormat": "多组数据。  \n\n每组数据有多行，每行由三个整数组成：$x,y,z$。$z$ 为这条街的编号，$x$ 和 $y$ 表示这条街连接的两个路口的编号。可能有自环。  \n\n对于每组数据，John 住在第一行中连接的两个顶点中编号较小的路口处。所有的街都可以连通到其他街上。`0 0` 表示一组数据的结束。  \n\n再一个`0 0`表示输入的结束。", "outputFormat": "如果能找到所有街道遍历一次的回路，输出找到的路径，两个整数之间用一个空格隔开，行末无空格。如果不存在，输出`Round trip does not exist.`。", "hint": "最多有 $1995$ 条街，最多 $44$ 个路口。", "locale": "zh-CN"}}}
{"pid": "P4039", "type": "P", "difficulty": 7, "samples": [["1\n3 4\n4\n1001\n0000\n0010\n1001\n3\n000\n010\n000\n011\n2\n00\n10\n01\n00", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "各省省选", "江苏", "安徽"], "title": "[AHOI2014/JSOI2014] 拼图", "background": "", "description": "JYY 最近迷上了拼图游戏。作为一个计算机科学家，JYY 有一套黑白色的拼图，他希望通过合理的拼接，使得拼出的最终图案中，能包含面积最大的全白色子矩形。\n\nJYY 一共有 $S$ 块拼图，并且由 $1$ 到 $S$ 编号。编号为 $i$ 的拼图是一个 $N$ 行列的方格矩形，每个方格都为黑色或者白色。一开始 JYY 将他的这 $S$ 块拼图按照编号顺序左右相连依次放在桌上拼成了一个 $N$ 行 $M$ 列（这里 $M=\\sum_{i=1}^S W_i$）的大矩形。\n\n之后 JYY 发现，可以通过改变这 $S$ 块拼图的连接次序，使得拼成的 $N$ 行 $M$ 列的大矩形中，最大全白子矩形面积变大。\n\n现在 JYY 想知道，怎么拼才能得到最大的全白子矩形呢？请你帮助他计算出最佳的拼接方案。", "inputFormat": "第一行包含一个整数 $T$，代表测试数据的组数，接下来按顺序描述了每组测试数据。\n\n每组测试数据的第一行包含两个整数 $S$ 和 $N$。\n\n接下来 $S$ 组输入，第 $i$ 组对应编号为 $i$ 的拼图。\n\n在第 $i$ 组输入中，第一行包含一个整数 $W_i$；\n\n接下来 $N$ 行描述一个 $N$ 行 $W_i$ 列的 $0/1$ 矩形；\n\n其中第 $x$ 行 $y$ 列为 $0$ 则表示该拼图对应位置的颜色是白色，反之则为黑色。", "outputFormat": "对于每组数据输出一行包含一个整数 ans，表示最大可能的全白色子矩形的面积。", "hint": "对于 $100\\%$ 的数据满足$1\\le S,N,W \\le 10^5$，$N\\times \\sum W_i \\le10^5$，$1\\le T\\le3$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2014/JSOI2014] Puzzle", "background": "", "description": "JYY has recently become obsessed with jigsaw puzzles. As a computer scientist, JYY has a set of black-and-white puzzle pieces. He hopes that by concatenating them properly, the final assembled pattern will contain an all-white subrectangle with the largest possible area.\n\nJYY has $S$ puzzle pieces, numbered from $1$ to $S$. The piece numbered $i$ is a grid rectangle with $N$ rows and $W_i$ columns, where each cell is either black or white. At the beginning, JYY places these $S$ pieces on the table side by side from left to right in numerical order, forming a large $N$ by $M$ rectangle (where $M=\\sum_{i=1}^S W_i$).\n\nLater, JYY discovers that by changing the concatenation order of these $S$ pieces, the area of the maximum all-white subrectangle in the resulting $N$ by $M$ rectangle can be increased.\n\nNow JYY wants to know how to arrange the pieces to obtain the largest possible all-white subrectangle. Please help him compute the optimal concatenation order.", "inputFormat": "The first line contains an integer $T$, the number of test cases. The descriptions of the test cases follow.\n\nFor each test case, the first line contains two integers $S$ and $N$.\n\nThen follow $S$ groups of input, where the $i$-th group corresponds to puzzle piece $i$.\n\nIn the $i$-th group, the first line contains an integer $W_i$; then $N$ lines describe a $N$-row by $W_i$-column $0/1$ matrix; if the cell at row $x$, column $y$ is $0$, then the color at that position of the piece is white, otherwise it is black.", "outputFormat": "For each test case, output one line containing a single integer ans, which denotes the area of the largest possible all-white subrectangle.", "hint": "For $100\\%$ of the testdata, $1\\le S,N,W_i \\le 10^5$, $N \\times \\sum W_i \\le 10^5$, $1\\le T\\le 3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2014/JSOI2014] 拼图", "background": "", "description": "JYY 最近迷上了拼图游戏。作为一个计算机科学家，JYY 有一套黑白色的拼图，他希望通过合理的拼接，使得拼出的最终图案中，能包含面积最大的全白色子矩形。\n\nJYY 一共有 $S$ 块拼图，并且由 $1$ 到 $S$ 编号。编号为 $i$ 的拼图是一个 $N$ 行列的方格矩形，每个方格都为黑色或者白色。一开始 JYY 将他的这 $S$ 块拼图按照编号顺序左右相连依次放在桌上拼成了一个 $N$ 行 $M$ 列（这里 $M=\\sum_{i=1}^S W_i$）的大矩形。\n\n之后 JYY 发现，可以通过改变这 $S$ 块拼图的连接次序，使得拼成的 $N$ 行 $M$ 列的大矩形中，最大全白子矩形面积变大。\n\n现在 JYY 想知道，怎么拼才能得到最大的全白子矩形呢？请你帮助他计算出最佳的拼接方案。", "inputFormat": "第一行包含一个整数 $T$，代表测试数据的组数，接下来按顺序描述了每组测试数据。\n\n每组测试数据的第一行包含两个整数 $S$ 和 $N$。\n\n接下来 $S$ 组输入，第 $i$ 组对应编号为 $i$ 的拼图。\n\n在第 $i$ 组输入中，第一行包含一个整数 $W_i$；\n\n接下来 $N$ 行描述一个 $N$ 行 $W_i$ 列的 $0/1$ 矩形；\n\n其中第 $x$ 行 $y$ 列为 $0$ 则表示该拼图对应位置的颜色是白色，反之则为黑色。", "outputFormat": "对于每组数据输出一行包含一个整数 ans，表示最大可能的全白色子矩形的面积。", "hint": "对于 $100\\%$ 的数据满足$1\\le S,N,W \\le 10^5$，$N\\times \\sum W_i \\le10^5$，$1\\le T\\le3$。\n", "locale": "zh-CN"}}}
{"pid": "P4040", "type": "P", "difficulty": 6, "samples": [["32 5 2\n5 0\n10 2", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2014", "各省省选", "江苏", "安徽"], "title": "[AHOI2014/JSOI2014] 宅男计划", "background": "自从迷上了拼图，JYY 就变成了个彻底的宅男。为了解决温饱问题，JYY 不得不依靠叫外卖来维持生计。\n", "description": "外卖店一共有 $n$ 种食物，分别从 $1$ 到 $n$ 编号。第 $i$ 种食物有固定的价钱 $p_i$ 和保质期 $s_i$。第 $i$ 种食物会在 $s_i$ 天后过期。JYY 是不会吃过期食物的。\n\n比如 JYY 如果今天点了一份保质期为 $1$ 天的食物，那么 JYY 必须在今天或者明天把这个食物吃掉，否则这个食物就再也不能吃了。保质期可以为 $0$ 天，这样这份食物就必须在购买当天吃掉。\n\nJYY 现在有 $m$ 块钱，每一次叫外卖需要额外付给送外卖小哥外送费 $f$ 元。\n\n送外卖的小哥身强力壮，可以瞬间给 JYY 带来任意多份食物。JYY 想知道，在满足每天都能吃到至少一顿没过期的外卖的情况下，他可以最多宅多少天呢？\n", "inputFormat": "第一行包含三个整数，分别表示 $m, f, n$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行两个整数，第 $(i + 1)$ 行的整数表示第 $i$ 种食物的价格 $p_i$ 和保质期 $s_i$。", "outputFormat": "输出一行一个整数，表示 JYY 可以宅的最多的天数。\n", "hint": "#### 样例输入输出 1 解释\nJYY的最佳策略是：\n- 第一天买一份食物 $1$ 和一份食物 $2$ 并且吃一份食物 $1$；\n- 第二天吃一份食物 $2$；\n- 第三天买一份食物 $1$ 并且吃掉。\n\n#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n \\leq 200$，$0 \\leq s_i \\leq 10^{18}$，$1 \\leq f, p_i, m \\leq10^{18}$。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2014/JSOI2014] Otaku Plan", "background": "Since becoming obsessed with jigsaw puzzles, JYY has turned into a complete homebody. To make ends meet, JYY has to rely on ordering takeout to survive.", "description": "There are $n$ types of food, numbered from $1$ to $n$. The $i$-th type of food has a fixed price $p_i$ and a shelf life $s_i$. The $i$-th type expires after $s_i$ days. JYY will not eat expired food.\n\nFor example, if JYY orders a food with a shelf life of $1$ day today, then JYY must eat it today or tomorrow; otherwise, this food can no longer be eaten. The shelf life can be $0$ days, in which case the food must be eaten on the day of purchase.\n\nJYY currently has $m$ yuan. Each time he places a takeout order, he must additionally pay a delivery fee of $f$ yuan.\n\nThe delivery person is strong and can instantly bring JYY arbitrarily many portions of food in one order. JYY wants to know, while ensuring that he can eat at least one unexpired takeout meal every day, for how many days at most can he stay at home.", "inputFormat": "The first line contains three integers, representing $m, f, n$.\n\nLines $2$ to $(n + 1)$ each contain two integers; in line $(i + 1)$, the integers denote the price $p_i$ and the shelf life $s_i$ of the $i$-th type of food.", "outputFormat": "Output a single integer in one line, representing the maximum number of days JYY can stay at home.", "hint": "#### Explanation of Sample Input/Output 1\nJYY’s best strategy is:\n- On day 1, buy one portion of food $1$ and one portion of food $2$, and eat one portion of food $1$.\n- On day 2, eat one portion of food $2$.\n- On day 3, buy one portion of food $1$ and eat it.\n\n#### Constraints\nFor all test points, it is guaranteed that $1 \\leq n \\leq 200$, $0 \\leq s_i \\leq 10^{18}$, $1 \\leq f, p_i, m \\leq 10^{18}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2014/JSOI2014] 宅男计划", "background": "自从迷上了拼图，JYY 就变成了个彻底的宅男。为了解决温饱问题，JYY 不得不依靠叫外卖来维持生计。\n", "description": "外卖店一共有 $n$ 种食物，分别从 $1$ 到 $n$ 编号。第 $i$ 种食物有固定的价钱 $p_i$ 和保质期 $s_i$。第 $i$ 种食物会在 $s_i$ 天后过期。JYY 是不会吃过期食物的。\n\n比如 JYY 如果今天点了一份保质期为 $1$ 天的食物，那么 JYY 必须在今天或者明天把这个食物吃掉，否则这个食物就再也不能吃了。保质期可以为 $0$ 天，这样这份食物就必须在购买当天吃掉。\n\nJYY 现在有 $m$ 块钱，每一次叫外卖需要额外付给送外卖小哥外送费 $f$ 元。\n\n送外卖的小哥身强力壮，可以瞬间给 JYY 带来任意多份食物。JYY 想知道，在满足每天都能吃到至少一顿没过期的外卖的情况下，他可以最多宅多少天呢？\n", "inputFormat": "第一行包含三个整数，分别表示 $m, f, n$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行两个整数，第 $(i + 1)$ 行的整数表示第 $i$ 种食物的价格 $p_i$ 和保质期 $s_i$。", "outputFormat": "输出一行一个整数，表示 JYY 可以宅的最多的天数。\n", "hint": "#### 样例输入输出 1 解释\nJYY的最佳策略是：\n- 第一天买一份食物 $1$ 和一份食物 $2$ 并且吃一份食物 $1$；\n- 第二天吃一份食物 $2$；\n- 第三天买一份食物 $1$ 并且吃掉。\n\n#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n \\leq 200$，$0 \\leq s_i \\leq 10^{18}$，$1 \\leq f, p_i, m \\leq10^{18}$。", "locale": "zh-CN"}}}
{"pid": "P4041", "type": "P", "difficulty": 6, "samples": [["5 1 6\n+ 5\n- 3\n* 2\n- 7\n@ 2\n3\n2\n1\n5", "5\n3\n6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "线段树", "各省省选", "江苏", "安徽"], "title": "[AHOI2014/JSOI2014] 奇怪的计算器", "background": "JYY 有个奇怪的计算器，有一天这个计算器坏了，JYY 希望你能帮助他写一个程序来模拟这个计算器的运算。", "description": "JYY 的计算器可以执行 $N$ 条预设好的指令。每次 JYY 向计算器输入一个正整数 $X$，计算器就会以 $X$ 作为初始值，接着依次执行预设的 $N$ 条指令，最后把最终得出的结果返回给 JYY。\n\n每一条指令可以是以下四种指令之一：（这里 $a$ 表示一个正整数。）\n\n1. $+a$：表示将当前的结果加上 $a$；\n2. $-a$：表示将当前的结果减去 $a$；\n3. $\\times a$：表示将当前的结果乘以 $a$；\n4. $@a$：表示将当前的结果加上 $a\\times X$（$X$ 是一开始 JYY 输入的数）。\n\n计算器用于记录运算结果的变量的存储范围是有限的，所以每次运算结束之后会有计算结果溢出的问题。\n\nJYY 的计算器中，存储每计算结果的变量只能存储 $L$ 到 $R$ 之间的正整数，如果一次指令执行过后，计算结果超过了 $R$，那么计算器就会自动把结果变成 $R$，然后再以 $R$ 作为当前结果继续进行之后的计算。同理，如果运算结果小于 $L$，计算器也会把结果变成 $L$，再接着计算。\n\n比如，假设计算器可以存储 $1$ 到 $6$ 之间的值，如果当前的计算结果是 $2$，那么在执行 $+5$ 操作之后，存储结果的变量中的值将会是 $6$。虽然 $2+5$ 的实际结果是 $7$，但是由于 $7$ 超过了存储范围的上界，所以结果就被自动更正成了上界的大小，也就是 $6$。\n\nJYY 一共想在计算器上输入 $Q$ 个值，他想知道这 $Q$ 个值输入计算器之后，分别会得到什么结果呢？", "inputFormat": "第一行包含三个正整数，$N$，$L$ 和 $R$。\n\n接下来 $N$ 行，每行一个指令，每个指令如题述，由一个字符和一个正整数组成，字符和正整数中间有一个空格隔开。\n\n第 $N+2$ 行包含一个整数 $Q$，表示 JYY 希望输入的数的数量。\n\n第接下来 $Q$ 行每行一个正整数，第 $k$ 个正整数 $X_k$ 表示 JYY 在第 $k$ 次输入的整数。", "outputFormat": "输出 $Q$ 行每行一个正整数，第 $k$ 行的整数表示输入 $X_k$ 后，依次经过 $N$ 个指令进行计算所得到的结果。", "hint": "### 样例解释\n\n当 JYY 输入 $2$ 时，计算器会进行 $5$ 次运算，每一次运算之后得到的结果分别是 $6$（实际计算结果为 $7$ 但是超过了上界），$3,6,1$（实际结果为 $-1$ 但是低于了下界）和 $5$（由于一开始输入的是 $2$，所以这一次计算为 $1+2 \\times 2$）。\n\n### 数据范围及约定\n\n对于所有测试数据，$1\\le N$，$Q\\le 10^5$，$1\\le L\\le X_k\\le R\\le 10^9$，$1\\le a\\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2014/JSOI2014] Strange Calculator", "background": "JYY has a strange calculator. One day it broke, and JYY hopes you can help him write a program to simulate this calculator’s operations.", "description": "JYY’s calculator can execute $N$ preset instructions. Each time JYY inputs a positive integer $X$, the calculator uses $X$ as the initial value, then executes the $N$ preset instructions in order, and finally returns the resulting value to JYY.\n\nEach instruction is one of the following four types (here $a$ denotes a positive integer):\n1. $+a$: add $a$ to the current result.\n2. $-a$: subtract $a$ from the current result.\n3. $\\times a$: multiply the current result by $a$.\n4. $@a$: add $a \\times X$ to the current result (where $X$ is the number JYY initially input).\n\nThe variable that stores the computation result has a limited range, so overflow may occur after each computation.\n\nIn JYY’s calculator, the result variable can only store positive integers between $L$ and $R$. If after executing an instruction the result exceeds $R$, the calculator will automatically change it to $R$, then continue from $R$. Similarly, if the result is less than $L$, the calculator will change it to $L$, then continue computing.\n\nFor example, suppose the calculator can store values from $1$ to $6$. If the current result is $2$, then after executing $+5$, the stored value will be $6$. Although the actual result $2+5$ is $7$, since $7$ exceeds the upper bound, the result is clamped to the upper bound $6$.\n\nJYY plans to input $Q$ values into the calculator and wants to know what result each input will produce.", "inputFormat": "The first line contains three positive integers $N$, $L$, and $R$.\n\nThe next $N$ lines each contain one instruction. Each instruction, as described above, consists of one symbol and one positive integer, separated by a space.\n\nThe $(N+2)$-th line contains an integer $Q$, the number of values JYY will input.\n\nThe next $Q$ lines each contain a positive integer. The $k$-th positive integer $X_k$ is the integer JYY inputs on the $k$-th time.", "outputFormat": "Output $Q$ lines, each with a positive integer. The integer on the $k$-th line is the result obtained after inputting $X_k$ and then executing the $N$ instructions in order.", "hint": "Sample Explanation\n\nWhen JYY inputs $2$, the calculator performs $5$ operations. After each operation, the results are $6$ (the actual result is $7$ but it exceeds the upper bound), $3$, $6$, $1$ (the actual result is $-1$ but it is below the lower bound), and $5$ (since the initial input was $2$, this step computes $1 + 2 \\times 2$).\n\nConstraints\n\nFor all testdata, $1 \\le N, Q \\le 10^5$, $1 \\le L \\le X_k \\le R \\le 10^9$, $1 \\le a \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2014/JSOI2014] 奇怪的计算器", "background": "JYY 有个奇怪的计算器，有一天这个计算器坏了，JYY 希望你能帮助他写一个程序来模拟这个计算器的运算。", "description": "JYY 的计算器可以执行 $N$ 条预设好的指令。每次 JYY 向计算器输入一个正整数 $X$，计算器就会以 $X$ 作为初始值，接着依次执行预设的 $N$ 条指令，最后把最终得出的结果返回给 JYY。\n\n每一条指令可以是以下四种指令之一：（这里 $a$ 表示一个正整数。）\n\n1. $+a$：表示将当前的结果加上 $a$；\n2. $-a$：表示将当前的结果减去 $a$；\n3. $\\times a$：表示将当前的结果乘以 $a$；\n4. $@a$：表示将当前的结果加上 $a\\times X$（$X$ 是一开始 JYY 输入的数）。\n\n计算器用于记录运算结果的变量的存储范围是有限的，所以每次运算结束之后会有计算结果溢出的问题。\n\nJYY 的计算器中，存储每计算结果的变量只能存储 $L$ 到 $R$ 之间的正整数，如果一次指令执行过后，计算结果超过了 $R$，那么计算器就会自动把结果变成 $R$，然后再以 $R$ 作为当前结果继续进行之后的计算。同理，如果运算结果小于 $L$，计算器也会把结果变成 $L$，再接着计算。\n\n比如，假设计算器可以存储 $1$ 到 $6$ 之间的值，如果当前的计算结果是 $2$，那么在执行 $+5$ 操作之后，存储结果的变量中的值将会是 $6$。虽然 $2+5$ 的实际结果是 $7$，但是由于 $7$ 超过了存储范围的上界，所以结果就被自动更正成了上界的大小，也就是 $6$。\n\nJYY 一共想在计算器上输入 $Q$ 个值，他想知道这 $Q$ 个值输入计算器之后，分别会得到什么结果呢？", "inputFormat": "第一行包含三个正整数，$N$，$L$ 和 $R$。\n\n接下来 $N$ 行，每行一个指令，每个指令如题述，由一个字符和一个正整数组成，字符和正整数中间有一个空格隔开。\n\n第 $N+2$ 行包含一个整数 $Q$，表示 JYY 希望输入的数的数量。\n\n第接下来 $Q$ 行每行一个正整数，第 $k$ 个正整数 $X_k$ 表示 JYY 在第 $k$ 次输入的整数。", "outputFormat": "输出 $Q$ 行每行一个正整数，第 $k$ 行的整数表示输入 $X_k$ 后，依次经过 $N$ 个指令进行计算所得到的结果。", "hint": "### 样例解释\n\n当 JYY 输入 $2$ 时，计算器会进行 $5$ 次运算，每一次运算之后得到的结果分别是 $6$（实际计算结果为 $7$ 但是超过了上界），$3,6,1$（实际结果为 $-1$ 但是低于了下界）和 $5$（由于一开始输入的是 $2$，所以这一次计算为 $1+2 \\times 2$）。\n\n### 数据范围及约定\n\n对于所有测试数据，$1\\le N$，$Q\\le 10^5$，$1\\le L\\le X_k\\le R\\le 10^9$，$1\\le a\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4042", "type": "P", "difficulty": 5, "samples": [["4\n4 27 3 2 3 2\n3 5 1 2\n1 13 2 4 2\n5 6 1 2", "26"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "图论", "2014", "各省省选", "江苏", "安徽", "最短路"], "title": "[AHOI2014/JSOI2014] 骑士游戏", "background": "长期的宅男生活中，JYY 又挖掘出了一款 RPG 游戏。在这个游戏中 JYY 会扮演一个英勇的骑士，用他手中的长剑去杀死入侵村庄的怪兽。", "description": "在这个游戏中，JYY 一共有两种攻击方式，一种是普通攻击，一种是法术攻击。两种攻击方式都会消耗 JYY 一些体力。采用普通攻击进攻怪兽并不能把怪兽彻底杀死，怪兽的尸体可以变出其他一些新的怪兽，注意一个怪兽可能经过若干次普通攻击后变回一个或更多同样的怪兽；而采用法术攻击则可以彻底将一个怪兽杀死。当然了，一般来说，相比普通攻击，法术攻击会消耗更多的体力值（但由于游戏系统 bug，并不保证这一点）。\n\n游戏世界中一共有 $N$ 种不同的怪兽，分别由 $1$ 到 $N$ 编号，现在 $1$ 号怪兽入侵村庄了，JYY 想知道，最少花费多少体力值才能将所有村庄中的怪兽全部杀死呢？", "inputFormat": "第一行包含一个整数 $N$。\n\n接下来 $N$ 行，每行描述一个怪兽的信息；\n\n其中第 $i$ 行包含若干个整数，前三个整数为 $S_i$，$K_i$ 和 $R_i$，表示对于 $i$ 号怪兽，普通攻击需要消耗 $S_i$ 的体力，法术攻击需要消耗 $K_i$ 的体力，同时 $i$ 号怪兽死亡后会产生 $R_i$ 个新的怪兽。表示一个新出现的怪兽编号。同一编号的怪兽可以出现多个。", "outputFormat": "输出一行一个整数，表示最少需要的体力值。\n", "hint": "首先用消耗 $4$ 点体力用普通攻击，然后出现的怪兽编号是 $2$，$2$ 和 $3$。花费 $10$ 点体力用法术攻击杀死两个编号为 $2$ 的怪兽。剩下 $3$ 号怪兽花费 $1$ 点体力进行普通攻击。此时村庄里的怪兽编号是 $2$ 和 $4$。最后花费 $11$ 点体力用法术攻击将这两只怪兽彻底杀死。一共花费的体力是 $4+5+5+1+5+6=26$。\n\n对于所有数据 $2 \\le N \\le 2 \\times 10^5$，$1 \\le R_i,\\sum R_i \\le 10^6$，$1 \\le K_i,S_i \\le 5 \\times 10^{14}$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2014/JSOI2014] Knight Game", "background": "In his long homebody life, JYY dug up an RPG game. In this game, JYY plays a brave knight who uses his longsword to kill monsters invading the village.", "description": "In this game, JYY has two attack types: a normal attack and a spell attack. Both consume some of JYY’s stamina. Using a normal attack on a monster does not completely kill it; the monster’s corpse can transform into some new monsters. Note that after several normal attacks, a monster may turn into one or more monsters of the same type again. A spell attack, however, can permanently kill a monster. Of course, in general, compared with a normal attack, a spell attack consumes more stamina (but due to a game system bug, this is not guaranteed).\n\nThere are $N$ different kinds of monsters in the game world, numbered from $1$ to $N$. Now a monster of type $1$ has invaded the village. JYY wants to know the minimum stamina needed to kill all monsters in the village.", "inputFormat": "The first line contains an integer $N$.\n\nThen $N$ lines follow, each describing one monster type.\n\nThe $i$-th line contains several integers. The first three integers are $S_i$, $K_i$, and $R_i$, meaning: for monster type $i$, a normal attack costs $S_i$ stamina, a spell attack costs $K_i$ stamina, and after monster $i$ dies (by a normal attack), it spawns $R_i$ new monsters. After these three integers, there are exactly $R_i$ more integers, each giving the type number of one newly spawned monster. The same type number may appear multiple times.", "outputFormat": "Output one integer on a single line: the minimum stamina required.", "hint": "First use a normal attack costing $4$ stamina, and the spawned monster types are $2$, $2$, and $3$. Spend $10$ stamina using spell attacks to kill the two monsters of type $2$. For the remaining type $3$ monster, use a normal attack costing $1$ stamina. Now the monsters in the village are of types $2$ and $4$. Finally, spend $11$ stamina using spell attacks to permanently kill these two monsters. The total stamina spent is $4 + 5 + 5 + 1 + 5 + 6 = 26$.\n\nConstraints: For all testdata, $2 \\le N \\le 2 \\times 10^5$, $1 \\le R_i, \\sum R_i \\le 10^6$, $1 \\le K_i, S_i \\le 5 \\times 10^{14}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2014/JSOI2014] 骑士游戏", "background": "长期的宅男生活中，JYY 又挖掘出了一款 RPG 游戏。在这个游戏中 JYY 会扮演一个英勇的骑士，用他手中的长剑去杀死入侵村庄的怪兽。", "description": "在这个游戏中，JYY 一共有两种攻击方式，一种是普通攻击，一种是法术攻击。两种攻击方式都会消耗 JYY 一些体力。采用普通攻击进攻怪兽并不能把怪兽彻底杀死，怪兽的尸体可以变出其他一些新的怪兽，注意一个怪兽可能经过若干次普通攻击后变回一个或更多同样的怪兽；而采用法术攻击则可以彻底将一个怪兽杀死。当然了，一般来说，相比普通攻击，法术攻击会消耗更多的体力值（但由于游戏系统 bug，并不保证这一点）。\n\n游戏世界中一共有 $N$ 种不同的怪兽，分别由 $1$ 到 $N$ 编号，现在 $1$ 号怪兽入侵村庄了，JYY 想知道，最少花费多少体力值才能将所有村庄中的怪兽全部杀死呢？", "inputFormat": "第一行包含一个整数 $N$。\n\n接下来 $N$ 行，每行描述一个怪兽的信息；\n\n其中第 $i$ 行包含若干个整数，前三个整数为 $S_i$，$K_i$ 和 $R_i$，表示对于 $i$ 号怪兽，普通攻击需要消耗 $S_i$ 的体力，法术攻击需要消耗 $K_i$ 的体力，同时 $i$ 号怪兽死亡后会产生 $R_i$ 个新的怪兽。表示一个新出现的怪兽编号。同一编号的怪兽可以出现多个。", "outputFormat": "输出一行一个整数，表示最少需要的体力值。\n", "hint": "首先用消耗 $4$ 点体力用普通攻击，然后出现的怪兽编号是 $2$，$2$ 和 $3$。花费 $10$ 点体力用法术攻击杀死两个编号为 $2$ 的怪兽。剩下 $3$ 号怪兽花费 $1$ 点体力进行普通攻击。此时村庄里的怪兽编号是 $2$ 和 $4$。最后花费 $11$ 点体力用法术攻击将这两只怪兽彻底杀死。一共花费的体力是 $4+5+5+1+5+6=26$。\n\n对于所有数据 $2 \\le N \\le 2 \\times 10^5$，$1 \\le R_i,\\sum R_i \\le 10^6$，$1 \\le K_i,S_i \\le 5 \\times 10^{14}$。\n", "locale": "zh-CN"}}}
{"pid": "P4043", "type": "P", "difficulty": 6, "samples": [["6\n2 2 1 3 2\n2 4 3 5 4\n2 5 5 6 6\n0\n0\n0", "24"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "各省省选", "网络流", "江苏", "安徽", "上下界网络流", "费用流"], "title": "[AHOI2014/JSOI2014] 支线剧情", "background": "宅男 JYY 非常喜欢玩 RPG 游戏，比如仙剑，轩辕剑等等。不过 JYY 喜欢的并不是战斗场景，而是类似电视剧一般的充满恩怨情仇的剧情。这些游戏往往都有很多的支线剧情，现在 JYY 想花费最少的时间看完所有的支线剧情。", "description": "JYY 现在所玩的 RPG 游戏中，一共有 $N$ 个剧情点，由 $1$ 到 $N$ 编号，第 $i$ 个剧情点可以根据 JYY 的不同的选择，而经过不同的支线剧情，前往 $K_i$ 种不同的新的剧情点。当然如果为 $0$，则说明 $i$ 号剧情点是游戏的一个结局了。\n\nJYY 观看一个支线剧情需要一定的时间。JYY 一开始处在 $1$ 号剧情点，也就是游戏的开始。显然任何一个剧情点都是从 $1$ 号剧情点可达的。此外，随着游戏的进行，剧情是不可逆的。所以游戏保证从任意剧情点出发，都不能再回到这个剧情点。由于 JYY 过度使用修改器，导致游戏的“存档”和“读档”功能损坏了，\n\n所以 JYY 要想回到之前的剧情点，唯一的方法就是退出当前游戏，并开始新的游戏，也就是回到 $1$ 号剧情点。JYY 可以在任何时刻退出游戏并重新开始。不断开始新的游戏重复观看已经看过的剧情是很痛苦，JYY 希望花费最少的时间，看完所有不同的支线剧情。", "inputFormat": "输入一行包含一个正整数 $N$。\n\n接下来 $N$ 行，第 $i$ 行为 $i$ 号剧情点的信息；\n\n第一个整数为 $K_i$，接下来 $K_i$ 个整数对，$b_{i,j}$ 和 $t_{i,j}$，表示从剧情点 $i$ 可以前往剧情点 $b_{i,j}$，并且观看这段支线剧情需要花费 $t_{i,j}$ 的时间。", "outputFormat": "输出一行包含一个整数，表示 JYY 看完所有支线剧情所需要的最少时间。", "hint": "### 样例解释\n\nJYY 需要重新开始 $3$ 次游戏，加上一开始的一次游戏，$4$ 次游戏的进程是：\n\n- $1 \\to 2 \\to 4$；\n- $1 \\to 2 \\to 5$；\n- $1 \\to 3 \\to 5$；\n- $1 \\to 3 \\to 6$。\n\n对于 $100\\%$ 的数据满足 $N \\le 300$，$0 \\le K_i \\le 50$，$1 \\le T_{i,j} \\le 300$，$\\sum K_i \\le 5000$。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2014/JSOI2014] Branching Storylines", "background": "Homebody JYY really enjoys playing RPGs, such as Xianjian and Xuanyuanjian. However, JYY is not fond of combat scenes, but rather the drama-like storylines full of love and hate. These games often have many branching storylines. Now JYY wants to spend the least amount of time to watch all branching storylines.", "description": "In the RPG that JYY is currently playing, there are $N$ storyline points, numbered $1$ to $N$. At the $i$-th storyline point, depending on JYY’s choices, he can go through different branching storylines to $K_i$ different new storyline points. If $K_i = 0$, then point $i$ is an ending of the game.\n\nWatching a single branching storyline takes some time. JYY starts at storyline point $1$, which is the beginning of the game. Clearly, every storyline point is reachable from point $1$. Moreover, as the game progresses, the storyline is irreversible. Therefore, the game guarantees that starting from any storyline point, you can never return to this point again.\n\nDue to JYY’s excessive use of modifiers, the game’s “save” and “load” features are broken. The only way to return to a previous storyline point is to quit the current game and start a new game, i.e., return to point $1$. JYY may quit and restart at any time. Repeatedly starting new games to rewatch already seen storylines is painful, so JYY wants to minimize the total time to watch all different branching storylines.", "inputFormat": "The first line contains a single positive integer $N$.\n\nThen follow $N$ lines. The $i$-th line describes storyline point $i$:\n\n- The first integer is $K_i$, followed by $K_i$ pairs of integers $b_{i,j}$ and $t_{i,j}$, indicating that from storyline point $i$ you can go to storyline point $b_{i,j}$, and watching this branching storyline takes $t_{i,j}$ time.", "outputFormat": "Output a single integer on one line, the minimum total time JYY needs to watch all branching storylines.", "hint": "Sample explanation:\n\nJYY needs to restart the game $3$ times. Together with the initial playthrough, the $4$ playthroughs are:\n\n- $1 \\to 2 \\to 4$.\n- $1 \\to 2 \\to 5$.\n- $1 \\to 3 \\to 5$.\n- $1 \\to 3 \\to 6$.\n\nConstraints:\n\nFor $100\\%$ of the testdata, $N \\le 300$, $0 \\le K_i \\le 50$, $1 \\le t_{i,j} \\le 300$, $\\sum K_i \\le 5000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2014/JSOI2014] 支线剧情", "background": "宅男 JYY 非常喜欢玩 RPG 游戏，比如仙剑，轩辕剑等等。不过 JYY 喜欢的并不是战斗场景，而是类似电视剧一般的充满恩怨情仇的剧情。这些游戏往往都有很多的支线剧情，现在 JYY 想花费最少的时间看完所有的支线剧情。", "description": "JYY 现在所玩的 RPG 游戏中，一共有 $N$ 个剧情点，由 $1$ 到 $N$ 编号，第 $i$ 个剧情点可以根据 JYY 的不同的选择，而经过不同的支线剧情，前往 $K_i$ 种不同的新的剧情点。当然如果为 $0$，则说明 $i$ 号剧情点是游戏的一个结局了。\n\nJYY 观看一个支线剧情需要一定的时间。JYY 一开始处在 $1$ 号剧情点，也就是游戏的开始。显然任何一个剧情点都是从 $1$ 号剧情点可达的。此外，随着游戏的进行，剧情是不可逆的。所以游戏保证从任意剧情点出发，都不能再回到这个剧情点。由于 JYY 过度使用修改器，导致游戏的“存档”和“读档”功能损坏了，\n\n所以 JYY 要想回到之前的剧情点，唯一的方法就是退出当前游戏，并开始新的游戏，也就是回到 $1$ 号剧情点。JYY 可以在任何时刻退出游戏并重新开始。不断开始新的游戏重复观看已经看过的剧情是很痛苦，JYY 希望花费最少的时间，看完所有不同的支线剧情。", "inputFormat": "输入一行包含一个正整数 $N$。\n\n接下来 $N$ 行，第 $i$ 行为 $i$ 号剧情点的信息；\n\n第一个整数为 $K_i$，接下来 $K_i$ 个整数对，$b_{i,j}$ 和 $t_{i,j}$，表示从剧情点 $i$ 可以前往剧情点 $b_{i,j}$，并且观看这段支线剧情需要花费 $t_{i,j}$ 的时间。", "outputFormat": "输出一行包含一个整数，表示 JYY 看完所有支线剧情所需要的最少时间。", "hint": "### 样例解释\n\nJYY 需要重新开始 $3$ 次游戏，加上一开始的一次游戏，$4$ 次游戏的进程是：\n\n- $1 \\to 2 \\to 4$；\n- $1 \\to 2 \\to 5$；\n- $1 \\to 3 \\to 5$；\n- $1 \\to 3 \\to 6$。\n\n对于 $100\\%$ 的数据满足 $N \\le 300$，$0 \\le K_i \\le 50$，$1 \\le T_{i,j} \\le 300$，$\\sum K_i \\le 5000$。", "locale": "zh-CN"}}}
{"pid": "P4044", "type": "P", "difficulty": 6, "samples": [["2\n5 2\n10 0\n3 7", "44"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2014", "各省省选", "江苏", "安徽", "模拟退火"], "title": "[AHOI2014/JSOI2014] 保龄球", "background": "JYY 很喜欢打保龄球，虽然技术不高，但是还是总想着的高分。这里 JYY 将向你介绍他所参加的特殊保龄球比赛的规则，然后请你帮他得到尽量多的分数。\n", "description": "一场保龄球比赛一共有 $n$ 个轮次，每一轮都会有十个木瓶放置在木板道的另一端。每一轮中，选手都有两次投球的机会来尝试击倒全部的十个木瓶。对于每一次投球机会，选手投球的得分等于这一次投球所击倒的木瓶数量。选手每一轮的得分是他两次机会击倒全部木瓶的数量。\n\n对于每一个轮次，有如下三种情况：\n\n1、 “全中”：如果选手第一次尝试就击倒了全部十个木瓶，那么这一轮就为“全中”。在一个“全中”轮中，由于所有木瓶在第一次尝试中都已经被击倒，所以选手不需要再进行第二次投球尝试。同时，在计算总分时，选手在下一轮的得分将会被乘2计入总分。\n\n2、“补中”：如果选手使用两次尝试击倒了十个木瓶，那么这一轮就称为“补中”。同时，在计算总分时，选手在下一轮中的第一次尝试的得分将会以双倍计入总分。\n\n3、“失误”：如果选手未能通过两次尝试击倒全部的木瓶，那么这一轮就被称为“失误”。同时，在计算总分时，选手在下一轮的得分会被计入总分，没有分数被翻倍。此外，如果第 $n$ 轮是“全中”，那么选手可以进行一次附加轮：也就是，如果第 $n$ 轮是“全中”，那么选手将一共进行 $n+1$ 轮比赛。显然，在这种情况下，第 $n+1$ 轮的分数一定会被加倍。\n\n附加轮的规则只执行一次。也就是说，即使第 $n+1$ 轮选手又打出了“全中”，也不会进行第 $n+2$ 轮比赛。因而，附加轮的成绩不会使得其他轮的分数翻番。最后，选手的总得分就是附加轮规则执行过，并且分数按上述规则加倍后的每一轮分数之和。\n\nJYY 刚刚进行了一场 $n$ 个轮次的保龄球比赛，但是，JYY非常不满意他的得分。JYY想出了一个办法：他可以把记分表上，他所打出的所有轮次的顺序重新排列，这样重新排列之后，由于翻倍规则的存在，JYY就可以得到更高的分数了！\n\n当然了，JYY不希望做的太假，他希望保证重新排列之后，所需要进行的轮数和重排前所进行的轮数是一致的：比如如果重排前JYY在第 $n$ 轮打出了“全中”，那么重排之后，第 $n$ 轮还得是“全中”以保证比赛一共进行 $n+1$ 轮；同样的，如果 JYY 第 $n$ 轮没有打出“全中”，那么重排过后第 $n$ 轮也不能是全中。请你帮助 JYY 计算一下，他可以得到的最高的分数。\n", "inputFormat": "第一行包含一个整数 $n$，表示保龄球比赛所需要进行的轮数。\n\n接下来包含 $n$ 或 $n+1$ 行，第i行包含两个非负整数 $x_i,y_i$，表示 JYY 在这一轮两次投球尝试所得到的分数，$x_i$ 表示第一次尝试，$y_i$ 表示第二次尝试。\n\n特别地，`10 0` 表示一轮“全中”。\n\n读入数据存在 $n+1$ 行，当且仅当 $x_n=10$ 且 $y_n=0$。\n", "outputFormat": "输出一行一个整数，表示 JYY 最大可能得到的分数。\n", "hint": "【样例说明】  \n按照输入顺序，JYY 将得到 $37$ 分。\n最佳方案是排列成如下顺序：\n```plain\n3 7\n10 0\n5 2\n```\n\n【数据范围】\n对于 $100\\%$ 的数据，$1\\le n \\le 50$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2014/JSOI2014] Bowling", "background": "JYY loves bowling. Although his skill is not high, he always wants a high score. Here JYY will introduce the rules of a special bowling contest he played, and then ask you to help him get as many points as possible.", "description": "A bowling game has $n$ frames. In each frame, ten pins are set up at the end of the lane. The player has two rolls in each frame to try to knock down all ten pins. The score of each roll equals the number of pins knocked down in that roll. The score of a frame is the total number of pins knocked down in its two rolls.\n\nFor each frame, there are three cases:\n\n1. \"Strike\": If the player knocks down all ten pins on the first roll, the frame is a \"strike\". Because all pins have fallen, there is no second roll in that frame. When computing the total score, the entire score of the next frame is counted twice (doubled).\n\n2. \"Spare\": If the player uses both rolls to knock down all ten pins, the frame is a \"spare\". When computing the total score, the score of the first roll in the next frame is counted twice.\n\n3. \"Open frame\": If the player fails to knock down all ten pins in two rolls, the frame is an \"open frame\". When computing the total score, the next frame’s score is added normally, with no doubling.\n\nIn addition, if frame $n$ is a \"strike\", the player plays one extra frame: that is, there are in total $n+1$ frames. In this case, the score of frame $n+1$ will definitely be doubled.\n\nThe extra-frame rule is applied at most once. That is, even if frame $n+1$ is also a \"strike\", there will be no frame $n+2$. Therefore, the extra frame will not cause any other frame’s score to be doubled. The final total score is the sum of all frame scores after applying the above doubling rules, including the extra frame if it exists.\n\nJYY just played a game of $n$ frames, but he is very unhappy with his score. He came up with an idea: he can reorder the sequence of all the frames on the scoresheet. After reordering, due to the doubling rules, JYY may obtain a higher total score.\n\nOf course, JYY does not want it to look too fake. He wants to keep the number of frames the same as before after reordering. For example, if the original frame $n$ was a \"strike\", then after reordering, frame $n$ must still be a \"strike\" so that there are $n+1$ frames in total. Similarly, if the original frame $n$ was not a \"strike\", then after reordering, frame $n$ must also not be a \"strike\". Please help JYY compute the maximum possible total score he can obtain.", "inputFormat": "The first line contains an integer $n$, the number of frames in the bowling game.\n\nThen there are $n$ or $n+1$ lines. The $i$-th line contains two non-negative integers $x_i, y_i$, representing JYY’s scores on the two rolls in that frame, where $x_i$ is the first roll and $y_i$ is the second roll.\n\nIn particular, `10 0` represents a \"strike\".\n\nThere are $n+1$ lines if and only if $x_n = 10$ and $y_n = 0$.", "outputFormat": "Output a single integer: the maximum total score JYY can obtain.", "hint": "[Sample explanation] According to the input order, JYY will get $37$ points.  \nThe best arrangement is:\n```plain\n3 7\n10 0\n5 2\n```\n\nConstraints  \nFor 100% of the testdata, $1 \\le n \\le 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2014/JSOI2014] 保龄球", "background": "JYY 很喜欢打保龄球，虽然技术不高，但是还是总想着的高分。这里 JYY 将向你介绍他所参加的特殊保龄球比赛的规则，然后请你帮他得到尽量多的分数。\n", "description": "一场保龄球比赛一共有 $n$ 个轮次，每一轮都会有十个木瓶放置在木板道的另一端。每一轮中，选手都有两次投球的机会来尝试击倒全部的十个木瓶。对于每一次投球机会，选手投球的得分等于这一次投球所击倒的木瓶数量。选手每一轮的得分是他两次机会击倒全部木瓶的数量。\n\n对于每一个轮次，有如下三种情况：\n\n1、 “全中”：如果选手第一次尝试就击倒了全部十个木瓶，那么这一轮就为“全中”。在一个“全中”轮中，由于所有木瓶在第一次尝试中都已经被击倒，所以选手不需要再进行第二次投球尝试。同时，在计算总分时，选手在下一轮的得分将会被乘2计入总分。\n\n2、“补中”：如果选手使用两次尝试击倒了十个木瓶，那么这一轮就称为“补中”。同时，在计算总分时，选手在下一轮中的第一次尝试的得分将会以双倍计入总分。\n\n3、“失误”：如果选手未能通过两次尝试击倒全部的木瓶，那么这一轮就被称为“失误”。同时，在计算总分时，选手在下一轮的得分会被计入总分，没有分数被翻倍。此外，如果第 $n$ 轮是“全中”，那么选手可以进行一次附加轮：也就是，如果第 $n$ 轮是“全中”，那么选手将一共进行 $n+1$ 轮比赛。显然，在这种情况下，第 $n+1$ 轮的分数一定会被加倍。\n\n附加轮的规则只执行一次。也就是说，即使第 $n+1$ 轮选手又打出了“全中”，也不会进行第 $n+2$ 轮比赛。因而，附加轮的成绩不会使得其他轮的分数翻番。最后，选手的总得分就是附加轮规则执行过，并且分数按上述规则加倍后的每一轮分数之和。\n\nJYY 刚刚进行了一场 $n$ 个轮次的保龄球比赛，但是，JYY非常不满意他的得分。JYY想出了一个办法：他可以把记分表上，他所打出的所有轮次的顺序重新排列，这样重新排列之后，由于翻倍规则的存在，JYY就可以得到更高的分数了！\n\n当然了，JYY不希望做的太假，他希望保证重新排列之后，所需要进行的轮数和重排前所进行的轮数是一致的：比如如果重排前JYY在第 $n$ 轮打出了“全中”，那么重排之后，第 $n$ 轮还得是“全中”以保证比赛一共进行 $n+1$ 轮；同样的，如果 JYY 第 $n$ 轮没有打出“全中”，那么重排过后第 $n$ 轮也不能是全中。请你帮助 JYY 计算一下，他可以得到的最高的分数。\n", "inputFormat": "第一行包含一个整数 $n$，表示保龄球比赛所需要进行的轮数。\n\n接下来包含 $n$ 或 $n+1$ 行，第i行包含两个非负整数 $x_i,y_i$，表示 JYY 在这一轮两次投球尝试所得到的分数，$x_i$ 表示第一次尝试，$y_i$ 表示第二次尝试。\n\n特别地，`10 0` 表示一轮“全中”。\n\n读入数据存在 $n+1$ 行，当且仅当 $x_n=10$ 且 $y_n=0$。\n", "outputFormat": "输出一行一个整数，表示 JYY 最大可能得到的分数。\n", "hint": "【样例说明】  \n按照输入顺序，JYY 将得到 $37$ 分。\n最佳方案是排列成如下顺序：\n```plain\n3 7\n10 0\n5 2\n```\n\n【数据范围】\n对于 $100\\%$ 的数据，$1\\le n \\le 50$。\n", "locale": "zh-CN"}}}
{"pid": "P4045", "type": "P", "difficulty": 6, "samples": [["10 2\nhello\nworld", "2\nhelloworld\nworldhello"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2009", "各省省选", "江苏", "AC 自动机", "状压 DP"], "title": "[JSOI2009] 密码", "background": "", "description": "众所周知，密码在信息领域起到了不可估量的作用。对于普通的登陆口令以，唯一的破解方法就是暴力破解——逐个尝试所有可能的字母组合，但这是一项很耗时又容易被发现的工作。所以，为了获取对方的登陆口令，在暴力破解密码之前，必须先做大量的准备工作。经过情报的搜集，现在得到了若干有用信息，形如：\n\n> ​     “我观察到，密码中含有字符串*。”\n\n例如，对于一个 $10$ 位的密码以及观察到的字符串 `hello` 与 `world`，可能的密码组合为 `helloworld`与 `worldhello`；而对于 $6$ 位的密码以及到的字符串 `good` 与 `day`,可能的密码组合为 `gooday`。\n\n有了这些信息，就能够大大地减少尝试的次数了。请编一个程序，计算所有密码组合的可能。密码中仅可能包含 `a-z` 之间的小写字母。", "inputFormat": "输入数据首先输入两个整数 $L,N$，分别表示密码的长度与观察到子串的个数。\n\n接下来 $N$ 行，每行若干个字符，描述了每个观察到的字符串。\n", "outputFormat": "输出数据第一行为一个整数，代表了满足所有观察条件字符串的总数。\n\n若这个数字小于等于 $42$，则按字典顺序输出所有密码的可能情况，每行一个，否则，只输出满足所有观察条件字符串的总数即可。\n", "hint": "对于 $100\\%$ 的数据，$1\\leq L\\leq 25,1\\leq N\\leq 10$，每个观察到的字符串长不超过 $10$，并且保证输出结果小于 $2^{63}$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2009] Password", "background": "", "description": "It is well known that passwords play an invaluable role in the field of information. For ordinary login passwords, the only way to crack them is brute force—trying all possible letter combinations one by one—but this is time-consuming and easy to detect. Therefore, before attempting a brute-force attack, one must do a lot of preparation. After gathering intelligence, we have obtained several useful pieces of information of the form:\n\n> \"I observed that the password contains the string *.\"\n\nFor example, for a password of length $10$ and the observed substrings `hello` and `world`, possible passwords are `helloworld` and `worldhello`. For a password of length $6$ and the observed substrings `good` and `day`, a possible password is `gooday`.\n\nWith such information, the number of attempts can be greatly reduced. Please write a program to compute all possible passwords. The password may contain only lowercase letters in `a-z`.", "inputFormat": "The input begins with two integers $L, N$, denoting the password length and the number of observed substrings, respectively.\n\nThen follow $N$ lines, each containing a string that describes one observed substring.", "outputFormat": "The first line of the output contains a single integer: the total number of passwords that contain all observed substrings.\n\nIf this number is less than or equal to $42$, output all possible passwords in lexicographical order, one per line. Otherwise, output only the total count.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\le L \\le 25$, $1 \\le N \\le 10$, each observed substring has length at most $10$, and it is guaranteed that the output is less than $2^{63}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2009] 密码", "background": "", "description": "众所周知，密码在信息领域起到了不可估量的作用。对于普通的登陆口令以，唯一的破解方法就是暴力破解——逐个尝试所有可能的字母组合，但这是一项很耗时又容易被发现的工作。所以，为了获取对方的登陆口令，在暴力破解密码之前，必须先做大量的准备工作。经过情报的搜集，现在得到了若干有用信息，形如：\n\n> ​     “我观察到，密码中含有字符串*。”\n\n例如，对于一个 $10$ 位的密码以及观察到的字符串 `hello` 与 `world`，可能的密码组合为 `helloworld`与 `worldhello`；而对于 $6$ 位的密码以及到的字符串 `good` 与 `day`,可能的密码组合为 `gooday`。\n\n有了这些信息，就能够大大地减少尝试的次数了。请编一个程序，计算所有密码组合的可能。密码中仅可能包含 `a-z` 之间的小写字母。", "inputFormat": "输入数据首先输入两个整数 $L,N$，分别表示密码的长度与观察到子串的个数。\n\n接下来 $N$ 行，每行若干个字符，描述了每个观察到的字符串。\n", "outputFormat": "输出数据第一行为一个整数，代表了满足所有观察条件字符串的总数。\n\n若这个数字小于等于 $42$，则按字典顺序输出所有密码的可能情况，每行一个，否则，只输出满足所有观察条件字符串的总数即可。\n", "hint": "对于 $100\\%$ 的数据，$1\\leq L\\leq 25,1\\leq N\\leq 10$，每个观察到的字符串长不超过 $10$，并且保证输出结果小于 $2^{63}$。\n", "locale": "zh-CN"}}}
{"pid": "P4046", "type": "P", "difficulty": 4, "samples": [["4 \n0 5 0 6 \n6 0 5 6 \n1 6 0 6 \n1 1 1 0 \n1 1 1 1 4 4 2 2 2 3 ", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2010", "各省省选", "江苏", "枚举"], "title": "[JSOI2010] 快递服务", "background": "", "description": "「飞奔」快递公司成立之后，已经分别与市内许多中小企业公司签订邮件收送服务契约。由于有些公司是在同一栋大楼内，所以「飞奔」公司收件的地点（收件点）最多只有 $m$ 点（$1,2,\\dots,m$），因此「飞奔」仅先行采购了三辆货车并聘用了三名司机，每天早上分别从收件地点 $1,2,3$ 出发。而在与客户的服务契约中有明确订约：「飞奔」必须在客户提出邮件寄送要求的隔天派人至该公司（地点）收件。\n\n为了能更有效率的服务客户并节省收件时间，该公司设立了收件服务登记网站，客户如有邮件需要寄送，必须在需要收件的前一天就先上网登记。为了节省油量，「飞奔」就利用晚上先行安排三位司机隔天的收件路线。每位司机至各地点收件的顺序应与各公司上网登记的顺序相符且必须能在最省油的情况下完成当天所有的收件服务。因此每位司机有可能需要在不同时间重复到同一地点收件，或不同的司机有可能需在不同的时间点前往同一地点收件。\n\n如下面范例二（收件公司地点依序为：`4 2 4 1 5 4 3 2 1`）所示，虽然司机 $1$ 一开始就已经在收件地点 $1$ 了，但是他却不能先把后面第四个登记的公司（地点 $1$）邮件先收了再前往第一、第二、或第三个登记收件地点（地点 $4,2,4$）收件。但是如果前三个登记收件的服务是由司机 $2$ 或 $3$ 来负责，则司机 $1$ 就可以在地点 $1$ 收了第四个登记的邮件后再前往后面所登记的地点收件。此外，在某些情况下，不一定每辆车都要收到货，也就是说，最佳收件方式也有可能是只需出动一或两辆车去收货。请写一个程序来帮「飞奔」公司计算每天依预约顺序至各收件地点收件的最少总耗油量。\n\n### 简要题意\n\n给定一个 $m \\times m$ 的矩阵 $D$。我们规定一个序列 $a(a_0,a_1,a_2,\\dots,a_n)$ 的花费为 $\\sum\\limits_{i=1}^{n}D_{a_{i-1},a_i}$。\n\n现在给定你一个长度 $\\leq 1000$ 的序列 $s$，请你把它分成三个子序列 $a,b,c$，并且规定 $a_0=1,b_0=2,c_0=3$，求出所有划分方案中它们的最小化费和。\n\n特殊地，矩阵 $D$ 满足三角不等式，具体见输入格式中的详细解释。\n\n（By El_destructor）", "inputFormat": "输入文件第一行有一个整数 $m$，代表「飞奔」公司收件的地点数，以 $1$ 至 $m$ 之间的整数代号来表示每个地点。\n\n接下来的 $m$ 行（第 $2$ 到第 $m+1$ 行），每行有 $m$ 个整数，代表一个矩阵 $D$。第 $i$ 行的第 $j$ 个整数 $D(i,j)$ 表示司机开车从收件点 $i$ 到收件点 $j$ 所需耗油量。最后一行是一个序列，按照顺序为前一天上网登记要求收件的公司地点代号，最多会有 $1000$ 个收件请求。\n\n输入文件中任两个相邻的整数都以一个空格隔开。\n\n注意：油量矩阵 $D$ 满足三角不等式，也就是说 $\\forall 1 \\leq i,j,k \\leq m,D(i,j) \\leq D(i,k)+D(k,j)$。因此，每辆车前往下一个收件地点时一定是直接前往，不必先绕道至其它地点再抵达下个收件地点。", "outputFormat": "输出一个整数，代表收件所需最少总耗油量。\n", "hint": "#### 样例解释\n\n到每个请求收件地点的司机分别为 `1 1 1 1 3 3 2 2 2 1`，因此司机 $1$ 只需从起使点 $1$ 移动到地点 $3$，司机 $2$ 只需停留在地点 $2$，司机 $3$ 从起始点 $3$ 移动到地点 $4$。\n\n#### 数据范围\n\n$3 \\leq m \\leq 200,1 \\leq s_i \\leq m$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2010] Courier Service", "background": "", "description": "After the “Feiben” (pinyin) courier company was founded, it signed mail pickup-and-delivery service contracts with many small and medium-sized companies in the city. Since some companies are in the same building, the pickup locations (pickup points) that “Feiben” needs to visit are at most $m$ points ($1, 2, \\dots, m$). Therefore, “Feiben” purchased three trucks and hired three drivers, who set out every morning from pickup locations $1, 2, 3$ respectively. The service contract with clients clearly states that “Feiben” must send someone to the client’s company (location) to pick up the mail on the day after the client submits the mailing request.\n\nTo serve clients more efficiently and save pickup time, the company set up a pickup service registration website. If a client needs to send mail, they must register online one day in advance. To save fuel, “Feiben” plans the next day’s pickup routes for the three drivers at night. The order in which each driver visits their assigned locations must respect the online registration order, and all pickups must be completed using the least fuel. Thus, a driver may need to visit the same location multiple times at different times, and different drivers may also go to the same location at different times.\n\nAs shown in Example 2 below (the pickup locations in order are: `4 2 4 1 5 4 3 2 1`), although driver $1$ starts at pickup location $1$, he cannot first pick up the mail for the fourth registered company (location $1$) and then go to the first, second, or third registered pickup locations (locations $4, 2, 4$). However, if the first three registered pickups are handled by driver $2$ or $3$, then driver $1$ can pick up the fourth registered mail at location $1$ and then proceed to later registered locations. In some cases, not every truck needs to pick up mail; the optimal plan may use only one or two trucks. Please write a program to compute the minimum total fuel consumption to visit all pickup locations in the registered order.\n\nBrief statement:\nGiven an $m \\times m$ matrix $D$. We define the cost of a sequence $a(a_0, a_1, a_2, \\dots, a_n)$ as $\\sum\\limits_{i=1}^{n} D_{a_{i-1}, a_i}$.\n\nNow you are given a sequence $s$ with length $\\leq 1000$. Split it into three subsequences $a, b, c$, with $a_0 = 1, b_0 = 2, c_0 = 3$. Among all such partitions, minimize the sum of their costs.\n\nIn particular, the matrix $D$ satisfies the triangle inequality; see the detailed explanation in the Input Format.\n\n(By El_destructor.)", "inputFormat": "The first line of the input file contains an integer $m$, the number of pickup locations, identified by integers from $1$ to $m$.\n\nThe next $m$ lines (lines $2$ to $m+1$) each contain $m$ integers, representing a matrix $D$. On the $i$-th line, the $j$-th integer $D(i, j)$ is the fuel required to drive from pickup point $i$ to pickup point $j$. The last line is a sequence of location IDs in the order of the requests registered online on the previous day; there are at most $1000$ pickup requests.\n\nAny two adjacent integers in the input are separated by one space.\n\nNote: The fuel matrix $D$ satisfies the triangle inequality, that is, $\\forall 1 \\leq i, j, k \\leq m, D(i, j) \\leq D(i, k) + D(k, j)$. Therefore, when a truck goes to the next assigned pickup location, it always goes directly without detouring through other locations.", "outputFormat": "Output a single integer, the minimum total fuel required for all pickups.", "hint": "Sample explanation:\nThe drivers assigned to each request, in order, are `1 1 1 1 3 3 2 2 2 1`. Therefore, driver $1$ only needs to move from starting point $1$ to location $3$, driver $2$ can stay at location $2$, and driver $3$ moves from starting point $3$ to location $4$.\n\nConstraints:\n$3 \\leq m \\leq 200, 1 \\leq s_i \\leq m$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2010] 快递服务", "background": "", "description": "「飞奔」快递公司成立之后，已经分别与市内许多中小企业公司签订邮件收送服务契约。由于有些公司是在同一栋大楼内，所以「飞奔」公司收件的地点（收件点）最多只有 $m$ 点（$1,2,\\dots,m$），因此「飞奔」仅先行采购了三辆货车并聘用了三名司机，每天早上分别从收件地点 $1,2,3$ 出发。而在与客户的服务契约中有明确订约：「飞奔」必须在客户提出邮件寄送要求的隔天派人至该公司（地点）收件。\n\n为了能更有效率的服务客户并节省收件时间，该公司设立了收件服务登记网站，客户如有邮件需要寄送，必须在需要收件的前一天就先上网登记。为了节省油量，「飞奔」就利用晚上先行安排三位司机隔天的收件路线。每位司机至各地点收件的顺序应与各公司上网登记的顺序相符且必须能在最省油的情况下完成当天所有的收件服务。因此每位司机有可能需要在不同时间重复到同一地点收件，或不同的司机有可能需在不同的时间点前往同一地点收件。\n\n如下面范例二（收件公司地点依序为：`4 2 4 1 5 4 3 2 1`）所示，虽然司机 $1$ 一开始就已经在收件地点 $1$ 了，但是他却不能先把后面第四个登记的公司（地点 $1$）邮件先收了再前往第一、第二、或第三个登记收件地点（地点 $4,2,4$）收件。但是如果前三个登记收件的服务是由司机 $2$ 或 $3$ 来负责，则司机 $1$ 就可以在地点 $1$ 收了第四个登记的邮件后再前往后面所登记的地点收件。此外，在某些情况下，不一定每辆车都要收到货，也就是说，最佳收件方式也有可能是只需出动一或两辆车去收货。请写一个程序来帮「飞奔」公司计算每天依预约顺序至各收件地点收件的最少总耗油量。\n\n### 简要题意\n\n给定一个 $m \\times m$ 的矩阵 $D$。我们规定一个序列 $a(a_0,a_1,a_2,\\dots,a_n)$ 的花费为 $\\sum\\limits_{i=1}^{n}D_{a_{i-1},a_i}$。\n\n现在给定你一个长度 $\\leq 1000$ 的序列 $s$，请你把它分成三个子序列 $a,b,c$，并且规定 $a_0=1,b_0=2,c_0=3$，求出所有划分方案中它们的最小化费和。\n\n特殊地，矩阵 $D$ 满足三角不等式，具体见输入格式中的详细解释。\n\n（By El_destructor）", "inputFormat": "输入文件第一行有一个整数 $m$，代表「飞奔」公司收件的地点数，以 $1$ 至 $m$ 之间的整数代号来表示每个地点。\n\n接下来的 $m$ 行（第 $2$ 到第 $m+1$ 行），每行有 $m$ 个整数，代表一个矩阵 $D$。第 $i$ 行的第 $j$ 个整数 $D(i,j)$ 表示司机开车从收件点 $i$ 到收件点 $j$ 所需耗油量。最后一行是一个序列，按照顺序为前一天上网登记要求收件的公司地点代号，最多会有 $1000$ 个收件请求。\n\n输入文件中任两个相邻的整数都以一个空格隔开。\n\n注意：油量矩阵 $D$ 满足三角不等式，也就是说 $\\forall 1 \\leq i,j,k \\leq m,D(i,j) \\leq D(i,k)+D(k,j)$。因此，每辆车前往下一个收件地点时一定是直接前往，不必先绕道至其它地点再抵达下个收件地点。", "outputFormat": "输出一个整数，代表收件所需最少总耗油量。\n", "hint": "#### 样例解释\n\n到每个请求收件地点的司机分别为 `1 1 1 1 3 3 2 2 2 1`，因此司机 $1$ 只需从起使点 $1$ 移动到地点 $3$，司机 $2$ 只需停留在地点 $2$，司机 $3$ 从起始点 $3$ 移动到地点 $4$。\n\n#### 数据范围\n\n$3 \\leq m \\leq 200,1 \\leq s_i \\leq m$。", "locale": "zh-CN"}}}
{"pid": "P4047", "type": "P", "difficulty": 4, "samples": [["4 2\n0 0\n0 1\n1 1\n1 0\n", "1.00\n"], ["9 3\n2 2\n2 3\n3 2\n3 3\n3 5\n3 6\n4 6\n6 2\n6 3", "2.00"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "二分", "并查集", "各省省选", "江苏", "生成树"], "title": "[JSOI2010] 部落划分", "background": "", "description": "聪聪研究发现，荒岛野人总是过着群居的生活，但是，并不是整个荒岛上的所有野人都属于同一个部落，野人们总是拉帮结派形成属于自己的部落，不同的部落之间则经常发生争斗。只是，这一切都成为谜团了——聪聪根本就不知道部落究竟是如何分布的。\n\n不过好消息是，聪聪得到了一份荒岛的地图。地图上标注了 $n$ 个野人居住的地点（可以看作是平面上的坐标）。我们知道，同一个部落的野人总是生活在附近。我们把两个部落的距离，定义为部落中距离最近的那两个居住点的距离。聪聪还获得了一个有意义的信息——这些野人总共被分为了 $k$ 个部落！这真是个好消息。聪聪希望从这些信息里挖掘出所有部落的详细信息。他正在尝试这样一种算法：\n\n对于任意一种部落划分的方法，都能够求出两个部落之间的距离，聪聪希望求出一种部落划分的方法，使靠得最近的两个部落尽可能远离。\n\n例如，下面的左图表示了一个好的划分，而右图则不是。请你编程帮助聪聪解决这个难题。\n\n\n![](https://cdn.luogu.com.cn/upload/pic/30573.png)", "inputFormat": "输入文件第一行包含两个整数 $n$ 和 $k$，分别代表了野人居住点的数量和部落的数量。\n\n接下来 $n$ 行，每行包含两个整数 $x$，$y$，描述了一个居住点的坐标。", "outputFormat": "输出一行一个实数，为最优划分时，最近的两个部落的距离，精确到小数点后两位。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $2 \\leq k \\leq n \\leq 10^3$，$0 \\leq  x, y \\leq 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2010] Tribe Division", "background": "", "description": "Congcong discovered that the savages on a deserted island always live in groups. However, not all savages on the island belong to the same tribe; they form their own tribes and different tribes often fight. But all of this is a mystery—Congcong does not know how the tribes are distributed.\n\nThe good news is that Congcong obtained a map of the island. The map marks $n$ dwelling locations (viewed as coordinates on a plane). We know that members of the same tribe live close to each other. We define the distance between two tribes as the distance between the closest pair of dwellings, one from each tribe. Congcong also learned an important fact—the savages are divided into $k$ tribes in total. This is great news. He wants to extract detailed information about all tribes from this data. He is trying the following approach:\n\nFor any partition of the dwellings into tribes, we can compute the distance between any two tribes. Congcong wants to find a partition such that the closest pair of tribes are as far apart as possible.\n\nFor example, the left figure below shows a good partition, while the right one does not. Please write a program to help Congcong solve this problem.\n\n![](https://cdn.luogu.com.cn/upload/pic/30573.png)", "inputFormat": "The first line contains two integers $n$ and $k$, representing the number of dwelling locations and the number of tribes.\n\nThe next $n$ lines each contain two integers $x$, $y$, giving the coordinates of a dwelling.", "outputFormat": "Output a single real number: under the optimal partition, the distance between the two closest tribes, rounded to two decimal places.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that $2 \\leq k \\leq n \\leq 10^3$, $0 \\leq x, y \\leq 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2010] 部落划分", "background": "", "description": "聪聪研究发现，荒岛野人总是过着群居的生活，但是，并不是整个荒岛上的所有野人都属于同一个部落，野人们总是拉帮结派形成属于自己的部落，不同的部落之间则经常发生争斗。只是，这一切都成为谜团了——聪聪根本就不知道部落究竟是如何分布的。\n\n不过好消息是，聪聪得到了一份荒岛的地图。地图上标注了 $n$ 个野人居住的地点（可以看作是平面上的坐标）。我们知道，同一个部落的野人总是生活在附近。我们把两个部落的距离，定义为部落中距离最近的那两个居住点的距离。聪聪还获得了一个有意义的信息——这些野人总共被分为了 $k$ 个部落！这真是个好消息。聪聪希望从这些信息里挖掘出所有部落的详细信息。他正在尝试这样一种算法：\n\n对于任意一种部落划分的方法，都能够求出两个部落之间的距离，聪聪希望求出一种部落划分的方法，使靠得最近的两个部落尽可能远离。\n\n例如，下面的左图表示了一个好的划分，而右图则不是。请你编程帮助聪聪解决这个难题。\n\n\n![](https://cdn.luogu.com.cn/upload/pic/30573.png)", "inputFormat": "输入文件第一行包含两个整数 $n$ 和 $k$，分别代表了野人居住点的数量和部落的数量。\n\n接下来 $n$ 行，每行包含两个整数 $x$，$y$，描述了一个居住点的坐标。", "outputFormat": "输出一行一个实数，为最优划分时，最近的两个部落的距离，精确到小数点后两位。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $2 \\leq k \\leq n \\leq 10^3$，$0 \\leq  x, y \\leq 10^4$。", "locale": "zh-CN"}}}
{"pid": "P4048", "type": "P", "difficulty": 6, "samples": [["2 3 1\n-100 0 100 3\n100 0 100 5\n-100 -10\n100 10\n110 11\n5 5 10", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2010", "各省省选", "江苏", "枚举"], "title": "[JSOI2010] 冷冻波", "background": "", "description": "WJJ喜欢“魔兽争霸”这个游戏。在游戏中，巫妖是一种强大的英雄，它的技能Frozen Nova每次可以杀死一个小精灵。我们认为，巫妖和小精灵都可以看成是平面上的点。\n\n当巫妖和小精灵之间的直线距离不超过R，且巫妖看到小精灵的视线没有被树木阻挡（也就是说，巫妖和小精灵的连线与任何树木都没有公共点）的话，巫妖就可以瞬间杀灭一个小精灵。\n\n在森林里有N个巫妖，每个巫妖释放Frozen Nova之后，都需要等待一段时间，才能再次施放。不同的巫妖有不同的等待时间和施法范围，但相同的是，每次施放都可以杀死一个小精灵。\n\n现在巫妖的头目想知道，若从0时刻开始计算，至少需要花费多少时间，可以杀死所有的小精灵？\n", "inputFormat": "输入文件第一行包含三个整数N、M、K(N,M,K<=200)，分别代表巫妖的数量、小精灵的数量和树木的数量。\n\n接下来N行，每行包含四个整数x, y, r, t，分别代表了每个巫妖的坐标、攻击范围和施法间隔（单位为秒）。\n\n再接下来M行，每行两个整数x, y，分别代表了每个小精灵的坐标。\n\n再接下来K行，每行三个整数x, y, r，分别代表了每个树木的坐标。\n\n输入数据中所有坐标范围绝对值不超过10000，半径和施法间隔不超过20000。\n", "outputFormat": "输出一行，为消灭所有小精灵的最短时间（以秒计算）。如果永远无法消灭所有的小精灵，则输出-1。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2010] Frozen Nova", "background": "", "description": "WJJ likes the game \"Warcraft III.\" In the game, the Lich is a powerful hero whose skill Frozen Nova can kill exactly one sprite each time. We consider both liches and sprites as points on the plane.\n\nIf the Euclidean distance between a lich and a sprite does not exceed $R$, and the lich's line of sight to that sprite is not blocked by any tree (that is, the line segment between the lich and the sprite has no common point with any tree), then the lich can instantly kill that sprite.\n\nThere are $N$ liches in the forest. After casting Frozen Nova, each lich must wait for a cooldown period before casting again. Different liches have different cooldowns and cast ranges, but each cast always kills exactly one sprite.\n\nStarting from time $0$, what is the minimum time needed to kill all the sprites?", "inputFormat": "The first line contains three integers $N$, $M$, $K$ ($N, M, K \\le 200$), representing the number of liches, sprites, and trees.\n\nThe next $N$ lines each contain four integers $x, y, r, t$, representing the coordinates, attack range, and casting interval (in seconds) of each lich.\n\nThe next $M$ lines each contain two integers $x, y$, representing the coordinates of each sprite.\n\nThe next $K$ lines each contain three integers $x, y, r$, representing the coordinates and radius of each tree.\n\nAll coordinates have absolute values at most $10000$; radii and casting intervals are at most $20000$.", "outputFormat": "Output one line: the minimum time (in seconds) needed to eliminate all sprites. If it is impossible to eliminate all sprites, output $-1$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2010] 冷冻波", "background": "", "description": "WJJ喜欢“魔兽争霸”这个游戏。在游戏中，巫妖是一种强大的英雄，它的技能Frozen Nova每次可以杀死一个小精灵。我们认为，巫妖和小精灵都可以看成是平面上的点。\n\n当巫妖和小精灵之间的直线距离不超过R，且巫妖看到小精灵的视线没有被树木阻挡（也就是说，巫妖和小精灵的连线与任何树木都没有公共点）的话，巫妖就可以瞬间杀灭一个小精灵。\n\n在森林里有N个巫妖，每个巫妖释放Frozen Nova之后，都需要等待一段时间，才能再次施放。不同的巫妖有不同的等待时间和施法范围，但相同的是，每次施放都可以杀死一个小精灵。\n\n现在巫妖的头目想知道，若从0时刻开始计算，至少需要花费多少时间，可以杀死所有的小精灵？\n", "inputFormat": "输入文件第一行包含三个整数N、M、K(N,M,K<=200)，分别代表巫妖的数量、小精灵的数量和树木的数量。\n\n接下来N行，每行包含四个整数x, y, r, t，分别代表了每个巫妖的坐标、攻击范围和施法间隔（单位为秒）。\n\n再接下来M行，每行两个整数x, y，分别代表了每个小精灵的坐标。\n\n再接下来K行，每行三个整数x, y, r，分别代表了每个树木的坐标。\n\n输入数据中所有坐标范围绝对值不超过10000，半径和施法间隔不超过20000。\n", "outputFormat": "输出一行，为消灭所有小精灵的最短时间（以秒计算）。如果永远无法消灭所有的小精灵，则输出-1。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4049", "type": "P", "difficulty": 6, "samples": [["10 10\n0.1 0.2 0.7\n0.2 0.3 0.5\n0.3 0.4 0.3\n0.4 0.5 0.1\n0.5 0.1 0.4\n0.6 0.2 0.2\n0.7 0.3 0\n0.8 0.1 0.1\n0.9 0.1 0\n1 0 0\n0.1 0.2 0.7\n0.2 0.3 0.5\n0.3 0.4 0.3\n0.4 0.5 0.1\n0.5 0.1 0.4\n0.6 0.2 0.2\n0.7 0.3 0\n0.8 0.1 0.1\n0.9 0.1 0\n1 0 0", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2007", "各省省选", "江苏", "图论建模", "最短路", "凸包"], "title": "[JSOI2007] 合金", "background": "", "description": "某公司加工一种由铁、铝、锡组成的合金。他们的工作很简单。首先进口一些铁铝锡合金原材料，不同种类的原材料中铁铝锡的比重不同。然后，将每种原材料取出一定量，经过融解、混合，得到新的合金。新的合金的铁铝锡比重为用户所需要的比重。 \n\n现在，用户给出了 $n$ 种他们需要的合金，以及每种合金中铁铝锡的比重。公司希望能够订购最少种类的原材料，并且使用这些原材料可以加工出用户需要的所有种类的合金。", "inputFormat": "第一行两个整数 $m$ 和 $n$，分别表示原材料种数和用户需要的合金种数。\n\n第 $2$ 到 $m+1$ 行，每行三个实数 $a_i, b_i, c_i$，分别表示铁铝锡在一种原材料中所占的比重。\n\n第 $m+2$ 到 $m+n+1$ 行，每行三个实数 $d_i, e_i, f_i$，分别表示铁铝锡在一种用户需要的合金中所占的比重。", "outputFormat": "一个整数，表示最少需要的原材料种数。若无解，则输出 `–1`。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，满足 $1\\le m,n\\le 500$，$0 \\leq a_i,b_i,c_i,d_i,e_i,f_i \\leq 1$，且 $a_i+b_i+c_i=1$，$d_i+e_i+f_i=1$，小数点后最多有六位数字。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2007] Alloy", "background": "", "description": "A company processes an alloy composed of iron, aluminum, and tin. Their workflow is simple. First, they import several raw materials that are iron-aluminum-tin alloys, where the proportions of iron, aluminum, and tin differ among types. Then, they take certain amounts from each raw material, melt and mix them to obtain a new alloy. The new alloy has iron, aluminum, and tin proportions equal to what the customer requires.\n\nNow, the customers provide $n$ types of alloys they need, along with the proportions of iron, aluminum, and tin for each. The company wants to order the minimum number of raw material types such that using these raw materials they can produce all the requested alloys.", "inputFormat": "The first line contains two integers $m$ and $n$, denoting the number of raw material types and the number of alloy types requested by customers, respectively.\n\nLines $2$ through $m+1$ each contain three real numbers $a_i, b_i, c_i$, representing the proportions of iron, aluminum, and tin in a raw material type, respectively.\n\nLines $m+2$ through $m+n+1$ each contain three real numbers $d_i, e_i, f_i$, representing the proportions of iron, aluminum, and tin in a requested alloy type, respectively.", "outputFormat": "Output a single integer, the minimum number of raw material types required. If there is no solution, output `-1`.", "hint": "Constraints\n\nFor all test points, it holds that $1 \\le m, n \\le 500$, $0 \\le a_i, b_i, c_i, d_i, e_i, f_i \\le 1$, and $a_i + b_i + c_i = 1$, $d_i + e_i + f_i = 1$. There are at most six digits after the decimal point.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2007] 合金", "background": "", "description": "某公司加工一种由铁、铝、锡组成的合金。他们的工作很简单。首先进口一些铁铝锡合金原材料，不同种类的原材料中铁铝锡的比重不同。然后，将每种原材料取出一定量，经过融解、混合，得到新的合金。新的合金的铁铝锡比重为用户所需要的比重。 \n\n现在，用户给出了 $n$ 种他们需要的合金，以及每种合金中铁铝锡的比重。公司希望能够订购最少种类的原材料，并且使用这些原材料可以加工出用户需要的所有种类的合金。", "inputFormat": "第一行两个整数 $m$ 和 $n$，分别表示原材料种数和用户需要的合金种数。\n\n第 $2$ 到 $m+1$ 行，每行三个实数 $a_i, b_i, c_i$，分别表示铁铝锡在一种原材料中所占的比重。\n\n第 $m+2$ 到 $m+n+1$ 行，每行三个实数 $d_i, e_i, f_i$，分别表示铁铝锡在一种用户需要的合金中所占的比重。", "outputFormat": "一个整数，表示最少需要的原材料种数。若无解，则输出 `–1`。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，满足 $1\\le m,n\\le 500$，$0 \\leq a_i,b_i,c_i,d_i,e_i,f_i \\leq 1$，且 $a_i+b_i+c_i=1$，$d_i+e_i+f_i=1$，小数点后最多有六位数字。", "locale": "zh-CN"}}}
{"pid": "P4050", "type": "P", "difficulty": 3, "samples": [["9 4\n1 1 2 2 3 3 5 5 5 7 8 8 8", "6 7 9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "各省省选", "江苏", "枚举"], "title": "[JSOI2007] 麻将", "background": null, "description": "麻将是中国传统的娱乐工具之一。麻将牌的牌可以分为字牌（共有东、南、西、北、中、发、白七种）和序数牌（分为条子、饼子、万子三种花色，每种花色各有一到九的九种牌），每种牌各四张。\n\n在麻将中，通常情况下一组和了的牌（即完成的牌）由十四张牌组成。十四张牌中的两张组成对子（即完全相同的两张牌），剩余的十二张组成三张一组的四组，每一组须为顺子（即同花色且序数相连的序数牌，例如条子的三、四、五）或者是刻子（即完全相同的三张牌）。一组听牌的牌是指一组十三张牌，且再加上某一张牌就可以组成和牌。那一张加上的牌可以称为等待牌。\n\n在这里，我们考虑一种特殊的麻将。在这种特殊的麻将里，没有字牌，花色也只有一种。但是，序数不被限制在一到九的范围内，而是在 $1$ 到 $n$ 的范围内。同时，也没有每一种牌四张的限制。一组和了的牌由 $3m + 2$ 张牌组成，其中两张组成对子，其余 $3m$ 张组成三张一组的 $m$ 组，每组须为顺子或刻子。现给出一组 $3m + 1$ 张的牌，要求判断该组牌是否为听牌（即还差一张就可以和牌）。如果是的话，输出所有可能的等待牌。", "inputFormat": "输入包含两行。\n\n第一行包含两个由空格隔开的整数 $n,m$（$9\\le n\\le 400, 4 \\le m\\le 1000$）。\n\n第二行包含 $3m + 1$ 个由空格隔开的整数，每个数均在范围 $1$ 到 $n$ 之内。这些数代表要求判断听牌的牌的序数。", "outputFormat": "输出为一行。如果该组牌为听牌，则输出所有的可能的等待牌的序数，数字之间用一个空格隔开。所有的序数必须按从小到大的顺序输出。如果该组牌不是听牌，则输出 ```NO```。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2007] Mahjong", "background": "", "description": "Mahjong is one of China's traditional recreational tools. Mahjong tiles can be divided into honor tiles (there are seven kinds: east, south, west, north, red, green, and white) and numbered tiles (three suits: bamboo, dots, and characters, each suit has nine ranks from one to nine), and there are four copies of each tile.\n\nIn mahjong, a typical complete hand consists of fourteen tiles. Two of the fourteen tiles form a pair (two identical tiles), and the remaining twelve tiles form four groups of three, each group being either a sequence (three consecutive ranks in the same suit, such as 3, 4, 5 of bamboo) or a triplet (three identical tiles). A ready hand is a hand of thirteen tiles such that adding one tile can form a complete hand. That added tile is called a waiting tile.\n\nHere, we consider a special kind of mahjong. In this special mahjong, there are no honor tiles, and there is only one suit. However, the ranks are not limited to the range from one to nine, but are in the range from $1$ to $n$. Also, there is no limit of four copies for each tile. A complete hand consists of $3m + 2$ tiles, of which two form a pair, and the remaining $3m$ tiles form $m$ groups of three, each group being either a sequence or a triplet. Given a set of $3m + 1$ tiles, determine whether this hand is ready (i.e., it is one tile away from a complete hand). If it is, output all possible waiting tiles.", "inputFormat": "The input contains two lines.\n\nThe first line contains two integers $n, m$ separated by a space ($9 \\le n \\le 400$, $4 \\le m \\le 1000$).\n\nThe second line contains $3m + 1$ integers separated by spaces, each in the range $1$ to $n$. These numbers represent the ranks of the tiles in the hand to be checked for readiness.", "outputFormat": "Output a single line. If the hand is ready, output all possible waiting tiles’ ranks in ascending order, separated by a single space. If the hand is not ready, output NO.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2007] 麻将", "background": null, "description": "麻将是中国传统的娱乐工具之一。麻将牌的牌可以分为字牌（共有东、南、西、北、中、发、白七种）和序数牌（分为条子、饼子、万子三种花色，每种花色各有一到九的九种牌），每种牌各四张。\n\n在麻将中，通常情况下一组和了的牌（即完成的牌）由十四张牌组成。十四张牌中的两张组成对子（即完全相同的两张牌），剩余的十二张组成三张一组的四组，每一组须为顺子（即同花色且序数相连的序数牌，例如条子的三、四、五）或者是刻子（即完全相同的三张牌）。一组听牌的牌是指一组十三张牌，且再加上某一张牌就可以组成和牌。那一张加上的牌可以称为等待牌。\n\n在这里，我们考虑一种特殊的麻将。在这种特殊的麻将里，没有字牌，花色也只有一种。但是，序数不被限制在一到九的范围内，而是在 $1$ 到 $n$ 的范围内。同时，也没有每一种牌四张的限制。一组和了的牌由 $3m + 2$ 张牌组成，其中两张组成对子，其余 $3m$ 张组成三张一组的 $m$ 组，每组须为顺子或刻子。现给出一组 $3m + 1$ 张的牌，要求判断该组牌是否为听牌（即还差一张就可以和牌）。如果是的话，输出所有可能的等待牌。", "inputFormat": "输入包含两行。\n\n第一行包含两个由空格隔开的整数 $n,m$（$9\\le n\\le 400, 4 \\le m\\le 1000$）。\n\n第二行包含 $3m + 1$ 个由空格隔开的整数，每个数均在范围 $1$ 到 $n$ 之内。这些数代表要求判断听牌的牌的序数。", "outputFormat": "输出为一行。如果该组牌为听牌，则输出所有的可能的等待牌的序数，数字之间用一个空格隔开。所有的序数必须按从小到大的顺序输出。如果该组牌不是听牌，则输出 ```NO```。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P4051", "type": "P", "difficulty": 6, "samples": [["JSOI07", "I0O7SJ"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2007", "各省省选", "江苏", "后缀数组 SA"], "title": "[JSOI2007] 字符加密", "background": null, "description": "喜欢钻研问题的 JS 同学，最近又迷上了对加密方法的思考。一天，他突然想出了一种他认为是终极的加密办法：把需要加密的信息排成一圈，显然，它们有很多种不同的读法。\n\n例如‘JSOI07’，可以读作：  JSOI07 SOI07J OI07JS I07JSO 07JSOI 7JSOI0 把它们按照字符串的大小排序： 07JSOI 7JSOI0 I07JSO JSOI07 OI07JS SOI07J 读出最后一列字符：I0O7SJ，就是加密后的字符串（其实这个加密手段实在很容易破解，鉴于这是突然想出来的，那就^^）。 但是，如果想加密的字符串实在太长，你能写一个程序完成这个任务吗？", "inputFormat": "输入文件包含一行，欲加密的字符串。注意字符串的内容不一定是字母、数字，也可以是符号等。", "outputFormat": "输出一行，为加密后的字符串。", "hint": "对于 $40\\%$ 的数据字符串的长度不超过 $10^4$。\n\n对于 $100\\%$ 的数据字符串的长度不超过 $10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2007] Character Encryption", "background": "", "description": "A student JS who enjoys exploring problems has recently become fascinated with encryption methods. One day, he suddenly came up with what he thought was the ultimate encryption method: arrange the message to be encrypted in a circle; obviously, it can be read in many different ways.\n\nFor example, 'JSOI07' can be read as: JSOI07, SOI07J, OI07JS, I07JSO, 07JSOI, 7JSOI0. Sort them lexicographically: 07JSOI, 7JSOI0, I07JSO, JSOI07, OI07JS, SOI07J. Read the last column of characters: I0O7SJ, which is the encrypted string (this encryption is actually quite easy to crack, but since it was a sudden idea, just ^^). However, if the string to be encrypted is very long, can you write a program to complete this task?", "inputFormat": "The input contains one line: the string to be encrypted. Note that the string is not necessarily letters or digits; it may also contain symbols, etc.", "outputFormat": "Output one line: the encrypted string.", "hint": "For $40\\%$ of the testdata, the length of the string does not exceed $10^4$.\n\nFor $100\\%$ of the testdata, the length of the string does not exceed $10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2007] 字符加密", "background": null, "description": "喜欢钻研问题的 JS 同学，最近又迷上了对加密方法的思考。一天，他突然想出了一种他认为是终极的加密办法：把需要加密的信息排成一圈，显然，它们有很多种不同的读法。\n\n例如‘JSOI07’，可以读作：  JSOI07 SOI07J OI07JS I07JSO 07JSOI 7JSOI0 把它们按照字符串的大小排序： 07JSOI 7JSOI0 I07JSO JSOI07 OI07JS SOI07J 读出最后一列字符：I0O7SJ，就是加密后的字符串（其实这个加密手段实在很容易破解，鉴于这是突然想出来的，那就^^）。 但是，如果想加密的字符串实在太长，你能写一个程序完成这个任务吗？", "inputFormat": "输入文件包含一行，欲加密的字符串。注意字符串的内容不一定是字母、数字，也可以是符号等。", "outputFormat": "输出一行，为加密后的字符串。", "hint": "对于 $40\\%$ 的数据字符串的长度不超过 $10^4$。\n\n对于 $100\\%$ 的数据字符串的长度不超过 $10^5$。", "locale": "zh-CN"}}}
{"pid": "P4052", "type": "P", "difficulty": 6, "samples": [["2 2\nA\nB\n", "100"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2007", "各省省选", "江苏", "O2优化", "AC 自动机"], "title": "[JSOI2007] 文本生成器", "background": "", "description": "JSOI 交给队员 ZYX 一个任务，编制一个称之为“文本生成器”的电脑软件：该软件的使用者是一些低幼人群，他们现在使用的是 GW 文本生成器 v6 版。\n\n该软件可以随机生成一些文章——总是生成一篇长度固定且完全随机的文章。 也就是说，生成的文章中每个字符都是完全随机的。如果一篇文章中至少包含使用者们了解的一个单词，那么我们说这篇文章是可读的（我们称文章 $s$ 包含单词 $t$，当且仅当单词 $t$ 是文章 $s$ 的子串）。但是，即使按照这样的标准，使用者现在使用的 GW 文本生成器 v6 版所生成的文章也是几乎完全不可读的。ZYX 需要指出 GW 文本生成器 v6 生成的所有文本中，可读文本的数量，以便能够成功获得 v7 更新版。你能帮助他吗？\n\n答案对 $10^4 + 7$ 取模。", "inputFormat": "第一行有两个整数，分别表示使用者了解的单词总数 $n$ 和生成的文章长度 $m$。\n\n接下来 $n$ 行，每行一个字符串 $s_i$，表示一个使用者了解的单词。", "outputFormat": "输出一行一个整数表示答案对 $10^4 + 7$ 取模的结果。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证：\n\n- $1 \\leq n \\leq 60$，$1 \\leq m \\leq 100$。\n- $1 \\leq |s_i| \\leq 100$，其中 $|s_i|$ 表示字符串 $s_i$ 的长度。\n- $s_i$ 中只含大写英文字母。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2007] Text Generator", "background": "", "description": "JSOI assigned team member ZYX a task to develop a computer program called \"Text Generator.\" The users of this software are young children, and they are currently using the GW Text Generator v6.\n\nThis software can randomly generate some text — it always generates a text with fixed length and completely random characters. That is, each character in the generated text is completely random. If a text contains at least one word known by the users, then we say the text is readable (we say a text $s$ contains a word $t$ if and only if $t$ is a substring of $s$). However, even under such a standard, the texts generated by the current GW Text Generator v6 are almost entirely unreadable. ZYX needs to determine, among all texts generated by GW Text Generator v6, how many are readable, in order to successfully obtain the v7 update. Can you help him?\n\nOutput the answer modulo $10^4 + 7$.", "inputFormat": "The first line contains two integers, denoting the total number of words known by the users $n$ and the length of the generated text $m$.\n\nThe next $n$ lines each contain a string $s_i$, representing a word known by the users.", "outputFormat": "Output a single integer: the answer modulo $10^4 + 7$.", "hint": "Constraints and Conventions\n\nFor all test points, it is guaranteed that:\n- $1 \\leq n \\leq 60$, $1 \\leq m \\leq 100$.\n- $1 \\leq |s_i| \\leq 100$, where $|s_i|$ denotes the length of string $s_i$.\n- Each $s_i$ contains only uppercase English letters.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2007] 文本生成器", "background": "", "description": "JSOI 交给队员 ZYX 一个任务，编制一个称之为“文本生成器”的电脑软件：该软件的使用者是一些低幼人群，他们现在使用的是 GW 文本生成器 v6 版。\n\n该软件可以随机生成一些文章——总是生成一篇长度固定且完全随机的文章。 也就是说，生成的文章中每个字符都是完全随机的。如果一篇文章中至少包含使用者们了解的一个单词，那么我们说这篇文章是可读的（我们称文章 $s$ 包含单词 $t$，当且仅当单词 $t$ 是文章 $s$ 的子串）。但是，即使按照这样的标准，使用者现在使用的 GW 文本生成器 v6 版所生成的文章也是几乎完全不可读的。ZYX 需要指出 GW 文本生成器 v6 生成的所有文本中，可读文本的数量，以便能够成功获得 v7 更新版。你能帮助他吗？\n\n答案对 $10^4 + 7$ 取模。", "inputFormat": "第一行有两个整数，分别表示使用者了解的单词总数 $n$ 和生成的文章长度 $m$。\n\n接下来 $n$ 行，每行一个字符串 $s_i$，表示一个使用者了解的单词。", "outputFormat": "输出一行一个整数表示答案对 $10^4 + 7$ 取模的结果。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证：\n\n- $1 \\leq n \\leq 60$，$1 \\leq m \\leq 100$。\n- $1 \\leq |s_i| \\leq 100$，其中 $|s_i|$ 表示字符串 $s_i$ 的长度。\n- $s_i$ 中只含大写英文字母。", "locale": "zh-CN"}}}
{"pid": "P4053", "type": "P", "difficulty": 5, "samples": [["4\n100 200\n200 1300\n1000 1250\n2000 3200", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "2007", "各省省选", "江苏", "优先队列", "反悔贪心"], "title": "[JSOI2007] 建筑抢修", "background": "", "description": "小刚在玩 JSOI 提供的一个称之为“建筑抢修”的电脑游戏：经过了一场激烈的战斗，T 部落消灭了所有 Z 部落的入侵者。但是 T 部落的基地里已经有 $N$ 个建筑设施受到了严重的损伤，如果不尽快修复的话，这些建筑设施将会完全毁坏。现在的情况是：T 部落基地里只有一个修理工人，虽然他能瞬间到达任何一个建筑，但是修复每个建筑都需要一定的时间。同时，修理工人修理完一个建筑才能修理下一个建筑，不能同时修理多个建筑。如果某个建筑在一段时间之内没有完全修理完毕，这个建筑就报废了。你的任务是帮小刚合理的制订一个修理顺序，以抢修尽可能多的建筑。\n", "inputFormat": "第一行，一个整数 $N$。\n\n接下来 $N$ 行，每行两个整数 $T_1,T_2$ 描述一个建筑：修理这个建筑需要 $T_1$ 秒，如果在 $T_2$ 秒之内还没有修理完成，这个建筑就报废了。\n", "outputFormat": "输出一个整数 $S$，表示最多可以抢修 $S$ 个建筑。\n", "hint": "对于 $100 \\%$ 的数据，$1 \\le N < 150000$，$1 \\le T_1 < T_2 < 2^{31}$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2007] Emergency Building Repair", "background": "", "description": "Xiaogang is playing a computer game provided by JSOI called \"Emergency Building Repair\": after an intense battle, the T tribe has eliminated all invaders from the Z tribe. However, $N$ buildings in the T tribe’s base have been severely damaged and will be completely destroyed if not repaired quickly. There is only one repair worker in the base. Although he can reach any building instantly, repairing each building takes a certain amount of time. The worker can repair only one building at a time and must finish repairing one building before starting the next. If a building is not fully repaired within a certain period of time, it will be scrapped. Your task is to help Xiaogang determine a repair order to repair as many buildings as possible.", "inputFormat": "The first line contains an integer $N$.\n\nThe next $N$ lines each contain two integers $T_1, T_2$ describing a building: repairing this building takes $T_1$ seconds, and if the repair is not completed within $T_2$ seconds, the building will be scrapped.", "outputFormat": "Output an integer $S$, the maximum number of buildings that can be repaired.", "hint": "Constraints: For $100 \\%$ of the testdata, $1 \\le N < 150000$, and $1 \\le T_1 < T_2 < 2^{31}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2007] 建筑抢修", "background": "", "description": "小刚在玩 JSOI 提供的一个称之为“建筑抢修”的电脑游戏：经过了一场激烈的战斗，T 部落消灭了所有 Z 部落的入侵者。但是 T 部落的基地里已经有 $N$ 个建筑设施受到了严重的损伤，如果不尽快修复的话，这些建筑设施将会完全毁坏。现在的情况是：T 部落基地里只有一个修理工人，虽然他能瞬间到达任何一个建筑，但是修复每个建筑都需要一定的时间。同时，修理工人修理完一个建筑才能修理下一个建筑，不能同时修理多个建筑。如果某个建筑在一段时间之内没有完全修理完毕，这个建筑就报废了。你的任务是帮小刚合理的制订一个修理顺序，以抢修尽可能多的建筑。\n", "inputFormat": "第一行，一个整数 $N$。\n\n接下来 $N$ 行，每行两个整数 $T_1,T_2$ 描述一个建筑：修理这个建筑需要 $T_1$ 秒，如果在 $T_2$ 秒之内还没有修理完成，这个建筑就报废了。\n", "outputFormat": "输出一个整数 $S$，表示最多可以抢修 $S$ 个建筑。\n", "hint": "对于 $100 \\%$ 的数据，$1 \\le N < 150000$，$1 \\le T_1 < T_2 < 2^{31}$。", "locale": "zh-CN"}}}
{"pid": "P4054", "type": "P", "difficulty": 5, "samples": [["3 3\n1 2 3\n3 2 1\n2 1 3\n3\n2 1 2 1 2 1\n1 2 3 2\n2 2 3 2 3 2", "1\n2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2009", "各省省选", "树状数组", "江苏", "前缀和"], "title": "[JSOI2009] 计数问题", "background": null, "description": "一个 $n \\times m$ 的方格，初始时每个格子有一个整数权值。接下来每次有 2 种操作：\n\n- 改变一个格子的权值；\n\n- 求一个子矩阵中某种特定权值出现的个数。", "inputFormat": "第一行有两个数 $n,m$。\n\n接下来 $n$ 行，每行 $m$ 个数，第 $i+1$ 行第 $j$ 个数表示格子 $(i,j)$ 的初始权值。\n\n接下来输入一个整数 $Q$。\n\n之后 $Q$ 行，每行描述一个操作。\n\n操作 1：输入一行四个整数 $1\\ x\\ y\\ c$，表示将格子 $(x,y)$ 的权值改成 $c$。\n\n操作 2：输入一行六个整数 $2\\ x_1\\ x_2\\ y_1\\ y_2\\ c$。表示询问所有满足格子颜色为 $c$，且满足 $x_1\\le x\\le x_2,y_1\\le y\\le y_2$ 的格子个数。", "outputFormat": "对于每个操作 2，按照在输入中出现的顺序，依次输出一行一个整数表示所求得的个数。", "hint": "【数据规模与约定】\n\n对于 $30\\%$ 的数据，满足：$n,m\\le 30$，$Q\\le 5\\times 10^4$。\n\n对于 $100\\%$ 的数据，满足：$1\\le n,m\\le 300$，$1\\le Q\\le 2\\times 10^5$。\n\n对于操作 1，保证：$1\\le x\n\\le n$，$1\\le y\\le m$，$1\\le c\\le 100$；\n\n对于操作 2，保证：$1\\le x_1≤x_2\\le n$，$1\\le y_1\\le y_2\\le m$，$1\\le c\\le 100$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2009] Counting Problem", "background": "", "description": "There is an $n \\times m$ grid. Initially, each cell has an integer weight. Then there are 2 types of operations:\n\n- Change the weight of a cell.\n- Query how many times a specified weight appears in a submatrix.", "inputFormat": "The first line contains two integers $n, m$.\n\nThen follow $n$ lines, each with $m$ integers. In the $(i+1)$-th line, the $j$-th number is the initial weight of cell $(i, j)$.\n\nThen an integer $Q$ is given.\n\nThen there are $Q$ lines, each describing an operation.\n\nOperation 1: A line with four integers $1\\ x\\ y\\ c$, meaning set the weight of cell $(x, y)$ to $c$.\n\nOperation 2: A line with six integers $2\\ x_1\\ x_2\\ y_1\\ y_2\\ c$, meaning query the number of cells whose weight is $c$ and satisfy $x_1\\le x\\le x_2, y_1\\le y\\le y_2$.", "outputFormat": "For each operation 2, output one integer per line in the order they appear, representing the required count.", "hint": "Constraints\n\nFor $30\\%$ of the testdata: $n, m\\le 30$, $Q\\le 5\\times 10^4$.\n\nFor $100\\%$ of the testdata: $1\\le n, m\\le 300$, $1\\le Q\\le 2\\times 10^5$.\n\nFor operation 1, it is guaranteed that $1\\le x\\le n$, $1\\le y\\le m$, $1\\le c\\le 100$.\n\nFor operation 2, it is guaranteed that $1\\le x_1\\le x_2\\le n$, $1\\le y_1\\le y_2\\le m$, $1\\le c\\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2009] 计数问题", "background": null, "description": "一个 $n \\times m$ 的方格，初始时每个格子有一个整数权值。接下来每次有 2 种操作：\n\n- 改变一个格子的权值；\n\n- 求一个子矩阵中某种特定权值出现的个数。", "inputFormat": "第一行有两个数 $n,m$。\n\n接下来 $n$ 行，每行 $m$ 个数，第 $i+1$ 行第 $j$ 个数表示格子 $(i,j)$ 的初始权值。\n\n接下来输入一个整数 $Q$。\n\n之后 $Q$ 行，每行描述一个操作。\n\n操作 1：输入一行四个整数 $1\\ x\\ y\\ c$，表示将格子 $(x,y)$ 的权值改成 $c$。\n\n操作 2：输入一行六个整数 $2\\ x_1\\ x_2\\ y_1\\ y_2\\ c$。表示询问所有满足格子颜色为 $c$，且满足 $x_1\\le x\\le x_2,y_1\\le y\\le y_2$ 的格子个数。", "outputFormat": "对于每个操作 2，按照在输入中出现的顺序，依次输出一行一个整数表示所求得的个数。", "hint": "【数据规模与约定】\n\n对于 $30\\%$ 的数据，满足：$n,m\\le 30$，$Q\\le 5\\times 10^4$。\n\n对于 $100\\%$ 的数据，满足：$1\\le n,m\\le 300$，$1\\le Q\\le 2\\times 10^5$。\n\n对于操作 1，保证：$1\\le x\n\\le n$，$1\\le y\\le m$，$1\\le c\\le 100$；\n\n对于操作 2，保证：$1\\le x_1≤x_2\\le n$，$1\\le y_1\\le y_2\\le m$，$1\\le c\\le 100$。", "locale": "zh-CN"}}}
{"pid": "P4055", "type": "P", "difficulty": 6, "samples": [["3 3\n.##\n...\n#.#", "WIN\n2 3\n3 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "各省省选", "网络流", "江苏", "二分图"], "title": "[JSOI2009] 游戏", "background": "", "description": "小 AA 和小 YY 得到了《喜羊羊和灰太狼》的电影票，都很想去观看，但是电影票只有一张，于是他们用智力游戏决定胜负，赢得游戏的人可以获得电影票。\n\n在 $N \\times M$ 的迷宫中有一个棋子，小 AA 首先任意选择棋子放置的位置。然后，小 YY 和小 AA 轮流将棋子移动到相邻的格子里。游戏的规则规定，在一次游戏中，同一个格子不能进入两次，且不能将棋子移动到某些格子中去。当玩家无法继续移动棋子时，游戏结束，最后一个移动棋子的玩家赢得了游戏。\n\n例如下图所示的迷宫，迷宫中 `.` 表示棋子可以经过的格子，而 `#` 表示棋子不可以经过的格子：\n\n```cpp\n                                 .##\n                                 ...\n                                 #.# \n```                                 \n若小 AA 将棋子放置在 $(1,1)$，则小 AA 则无论如何都无法赢得游戏。\n\n而若小 AA 将棋子放置在 $(3,2)$ 或 $(2,3)$，则小 AA 能够赢得游戏。例如，小 AA 将棋子放置在 $(3,2)$，小 YY 只能将它移动到 $(2,2)$，此时小 AA 再将棋子移动到 $(2,3)$，就赢得了游戏。\n\n小 AA 和小 YY 都是绝顶聪明的小朋友，且从不失误。小 AA 到底能不能赢得这场游戏，从而得到珍贵的电影票呢？", "inputFormat": "输入数据首先输入两个整数 $N,M$，表示了迷宫的边长。\n\n接下来 $N$ 行，每行 $M$ 个字符，描述了迷宫。\n", "outputFormat": "若小 AA 能够赢得游戏，则输出一行 `WIN`，然后输出所有可以赢得游戏的起始位置，按行优先顺序输出，每行一个。\n\n否则输出一行 `LOSE`。\n", "hint": "- 对 $30\\%$ 的数据，有 $n,m \\leq 5$；\n- 对 $100\\%$ 的数据，有 $1 \\leq n,m \\leq 100$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2009] Game", "background": "", "description": "Little AA and Little YY got a movie ticket for \"Pleasant Goat and Big Big Wolf\". They both want to watch it, but there is only one ticket, so they decide the winner by playing a strategy game. The winner gets the ticket.\n\nIn an $N \\times M$ maze there is a piece. Little AA first chooses any starting cell to place the piece. Then Little YY and Little AA take turns moving the piece to an adjacent cell. The rules state that in a single game, the same cell cannot be visited twice, and the piece cannot be moved into certain cells. When a player can no longer move the piece, the game ends, and the player who made the last move wins.\n\nFor example, in the maze below, `.` indicates a passable cell for the piece, and `#` indicates an impassable cell:\n\n```cpp\n                                 .##\n                                 ...\n                                 #.# \n```\nIf Little AA places the piece at $(1, 1)$, then AA cannot win no matter what.\n\nIf Little AA places the piece at $(3, 2)$ or $(2, 3)$, then AA can win. For example, if AA places the piece at $(3, 2)$, Little YY can only move it to $(2, 2)$. Then AA moves the piece to $(2, 3)$ and wins the game.\n\nLittle AA and Little YY are both extremely smart and never make mistakes. Can Little AA win this game and get the precious movie ticket?", "inputFormat": "The input begins with two integers $N, M$, representing the dimensions of the maze.\n\nThen follow $N$ lines, each with $M$ characters describing the maze.", "outputFormat": "If Little AA can win the game, output a line `WIN`, then output all winning starting positions in row-major order, one per line. For each line, print the position as two integers $r$ and $c$ (1-based).\n\nOtherwise, output a single line `LOSE`.", "hint": "Constraints:\n- For $30\\%$ of the testdata, $N, M \\leq 5$.\n- For $100\\%$ of the testdata, $1 \\leq N, M \\leq 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2009] 游戏", "background": "", "description": "小 AA 和小 YY 得到了《喜羊羊和灰太狼》的电影票，都很想去观看，但是电影票只有一张，于是他们用智力游戏决定胜负，赢得游戏的人可以获得电影票。\n\n在 $N \\times M$ 的迷宫中有一个棋子，小 AA 首先任意选择棋子放置的位置。然后，小 YY 和小 AA 轮流将棋子移动到相邻的格子里。游戏的规则规定，在一次游戏中，同一个格子不能进入两次，且不能将棋子移动到某些格子中去。当玩家无法继续移动棋子时，游戏结束，最后一个移动棋子的玩家赢得了游戏。\n\n例如下图所示的迷宫，迷宫中 `.` 表示棋子可以经过的格子，而 `#` 表示棋子不可以经过的格子：\n\n```cpp\n                                 .##\n                                 ...\n                                 #.# \n```                                 \n若小 AA 将棋子放置在 $(1,1)$，则小 AA 则无论如何都无法赢得游戏。\n\n而若小 AA 将棋子放置在 $(3,2)$ 或 $(2,3)$，则小 AA 能够赢得游戏。例如，小 AA 将棋子放置在 $(3,2)$，小 YY 只能将它移动到 $(2,2)$，此时小 AA 再将棋子移动到 $(2,3)$，就赢得了游戏。\n\n小 AA 和小 YY 都是绝顶聪明的小朋友，且从不失误。小 AA 到底能不能赢得这场游戏，从而得到珍贵的电影票呢？", "inputFormat": "输入数据首先输入两个整数 $N,M$，表示了迷宫的边长。\n\n接下来 $N$ 行，每行 $M$ 个字符，描述了迷宫。\n", "outputFormat": "若小 AA 能够赢得游戏，则输出一行 `WIN`，然后输出所有可以赢得游戏的起始位置，按行优先顺序输出，每行一个。\n\n否则输出一行 `LOSE`。\n", "hint": "- 对 $30\\%$ 的数据，有 $n,m \\leq 5$；\n- 对 $100\\%$ 的数据，有 $1 \\leq n,m \\leq 100$。\n", "locale": "zh-CN"}}}
{"pid": "P4056", "type": "P", "difficulty": 6, "samples": [["4  10 \n1  1  20 \n10 10 10 \n3  5  60 \n5  3  30", "-4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2009", "各省省选", "江苏", "斜率优化"], "title": "[JSOI2009] 火星藏宝图", "background": "JSOI2009第三轮二试\n", "description": "在火星游玩多日,jyy 偶然地发现了一张藏宝图。根据藏宝图上说法，宝藏被埋藏在一个巨大的湖里的 $N$ 个岛上 $(2\\le N \\le 2 \\times 10^{5})$。为了方便描述，地图把整个湖划分成 $M$ 行 $M$ 列 $(1\\le M\\le 1000)$,共 $M \\times M$ 个小块，并把所有岛按照 $1...N$ 编了号。第 $i$ 个岛位于第 $X_i$ 行 $Y_i$ 列 (设其坐标为 $(X_i,Y_i)$的格子 （ $X_i,Y_i$ 均为整数，并且满足 $1<=X_i,Y_i<=M$ ）,岛上藏有价值财富 $V_i(1\\le V_i\\le 10,000)$。湖的左上角 $(1,1)$ 和右下角 $(M,M)$ 都有岛，有桥将它们与陆地相连。\n\njyy 没费多大劲，就找到了那个湖，同时哭笑不得地发现，所谓的财富，是各个岛上出产的珍稀水果。jyy 在左上角的岛的岸边找到了一条小木船，他可以划船到其他岛上去。划船是要消耗体力的，具体地说，等于两岛 Euclidean 距离的平方(即，从 $(X_1,Y_1)$ 划船到 $(X_2,Y_2)$ 所耗费的体力为 $(X_1-X_2)^2+(Y_1-Y_2)^2$ 个单位)。jyy 可以吃水果来恢复体力，吃掉 $1$ 单位价值的水果能恢复 $1$ 单位体力。\n\n现在 jyy 打算从 $(1,1)$ 旅行到 $(M,M)$，沿途收集珍稀水果。按藏宝图上的提示，jyy 离开一个岛后，就只能去该岛右下方的区域（正下和正右方向也是允许的），否则会遭遇水怪。jyy 可以在旅行途中饿一段时间，即体力为负。但抵达终点后，只要身边有足够多的水果，他就会通过吃水果将体力恢复到旅行前的水平。\n\njyy想知道，经过一次旅行，他最多能得到多少收益，即 `jyy 收集到的水果总价值- jyy 在旅途中花的总体力` 。(如果吃完所有水果他还饿着，收益就是负数，具体的例子见样例)", "inputFormat": "第 $1$ 行：两个整数 $N,M$。第 $2...N+1$ 行：每行 $3$ 个整数，第 $i+1$ 行的 $3$ 个整数分别为 $ X_i$，$Y_i$，$V_i$。每个岛的坐标不同。保证存在坐标 $(1,1)$ 和 $(M,M)$ 的岛。", "outputFormat": "第 $1$ 行：输出一个整数，表示最大收益。", "hint": "### 样例解释\n\n$20+60+10-\\left ( \\left(3-1 \\right )^2+\\left (5-1 \\right )^2 \\right )-\\left ( \\left (10-3 \\right )^2+\\left (10-5 \\right )^2 \\right )=-4$\n\n### 数据范围\n\n对 $20\\%$ 的数据 $M\\le 200$，且 $N\\le 2\\times 10^3$。\n\n对 $50\\%$ 的数据 $M\\le 200$，且 $N\\le 2\\times 10^4$。\n\n对 $100\\%$ 的数据 $M\\le 1000$，且 $N\\le 2\\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2009] Mars Treasure Map", "background": "JSOI 2009 Round 3, second exam.", "description": "After traveling on Mars for many days, jyy accidentally discovered a treasure map. According to the map, the treasure is buried on $N$ islands $(2\\le N \\le 2 \\times 10^{5})$ in a huge lake. For convenience, the map divides the entire lake into $M$ rows and $M$ columns $(1\\le M\\le 1000)$, a total of $M \\times M$ cells, and numbers all islands from $1$ to $N$. The $i$-th island is located at row $X_i$, column $Y_i$ (that is, on the cell with coordinates $(X_i,Y_i)$, where $X_i,Y_i$ are integers satisfying $1<=X_i,Y_i<=M$), and the island contains treasure worth $V_i(1\\le V_i\\le 10,000)$. There are islands at the top-left $(1,1)$ and bottom-right $(M,M)$ corners of the lake, and there are bridges connecting them to the land.\n\njyy soon found the lake and, to his amusement, discovered that the so-called treasure is the rare fruits produced on each island. At the shore of the island at the top-left corner, jyy found a small wooden boat, with which he can row to other islands. Rowing consumes stamina equal to the square of the Euclidean distance between two islands (that is, rowing from $(X_1,Y_1)$ to $(X_2,Y_2)$ costs $(X_1-X_2)^2+(Y_1-Y_2)^2$ units of stamina). jyy can eat fruit to restore stamina; consuming 1 unit of fruit value restores 1 unit of stamina.\n\nNow jyy plans to travel from $(1,1)$ to $(M,M)$, collecting rare fruits along the way. As hinted on the treasure map, after leaving an island, he may only go to the region to its lower-right (moving directly down or directly right is also allowed); otherwise, he will encounter a water monster. jyy may travel while hungry, i.e., stamina can be negative. Upon reaching the destination, as long as he has enough fruit with him, he will eat to restore his stamina to the pre-trip level.\n\njyy wants to know, after one trip, what is the maximum net gain, defined as jyy’s total collected fruit value minus jyy’s total stamina spent during the trip. (If he is still hungry after eating all the fruit, the net gain is negative; see the sample for a specific example.)", "inputFormat": "The first line contains two integers $N,M$.  \nLines $2$ to $N+1$: each line contains $3$ integers. On line $i+1$, the $3$ integers are $X_i$, $Y_i$, and $V_i$.  \nEach island has distinct coordinates. It is guaranteed that there are islands at coordinates $(1,1)$ and $(M,M)$.", "outputFormat": "Output a single integer on the first line, representing the maximum net gain.", "hint": "Sample Explanation:\n$20+60+10-\\left ( \\left(3-1 \\right )^2+\\left (5-1 \\right )^2 \\right )-\\left ( \\left (10-3 \\right )^2+\\left (10-5 \\right )^2 \\right )=-4$\n\nConstraints:\n- For $20\\%$ of the testdata, $M\\le 200$, and $N\\le 2\\times 10^3$.\n- For $50\\%$ of the testdata, $M\\le 200$, and $N\\le 2\\times 10^4$.\n- For $100\\%$ of the testdata, $M\\le 1000$, and $N\\le 2\\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2009] 火星藏宝图", "background": "JSOI2009第三轮二试\n", "description": "在火星游玩多日,jyy 偶然地发现了一张藏宝图。根据藏宝图上说法，宝藏被埋藏在一个巨大的湖里的 $N$ 个岛上 $(2\\le N \\le 2 \\times 10^{5})$。为了方便描述，地图把整个湖划分成 $M$ 行 $M$ 列 $(1\\le M\\le 1000)$,共 $M \\times M$ 个小块，并把所有岛按照 $1...N$ 编了号。第 $i$ 个岛位于第 $X_i$ 行 $Y_i$ 列 (设其坐标为 $(X_i,Y_i)$的格子 （ $X_i,Y_i$ 均为整数，并且满足 $1<=X_i,Y_i<=M$ ）,岛上藏有价值财富 $V_i(1\\le V_i\\le 10,000)$。湖的左上角 $(1,1)$ 和右下角 $(M,M)$ 都有岛，有桥将它们与陆地相连。\n\njyy 没费多大劲，就找到了那个湖，同时哭笑不得地发现，所谓的财富，是各个岛上出产的珍稀水果。jyy 在左上角的岛的岸边找到了一条小木船，他可以划船到其他岛上去。划船是要消耗体力的，具体地说，等于两岛 Euclidean 距离的平方(即，从 $(X_1,Y_1)$ 划船到 $(X_2,Y_2)$ 所耗费的体力为 $(X_1-X_2)^2+(Y_1-Y_2)^2$ 个单位)。jyy 可以吃水果来恢复体力，吃掉 $1$ 单位价值的水果能恢复 $1$ 单位体力。\n\n现在 jyy 打算从 $(1,1)$ 旅行到 $(M,M)$，沿途收集珍稀水果。按藏宝图上的提示，jyy 离开一个岛后，就只能去该岛右下方的区域（正下和正右方向也是允许的），否则会遭遇水怪。jyy 可以在旅行途中饿一段时间，即体力为负。但抵达终点后，只要身边有足够多的水果，他就会通过吃水果将体力恢复到旅行前的水平。\n\njyy想知道，经过一次旅行，他最多能得到多少收益，即 `jyy 收集到的水果总价值- jyy 在旅途中花的总体力` 。(如果吃完所有水果他还饿着，收益就是负数，具体的例子见样例)", "inputFormat": "第 $1$ 行：两个整数 $N,M$。第 $2...N+1$ 行：每行 $3$ 个整数，第 $i+1$ 行的 $3$ 个整数分别为 $ X_i$，$Y_i$，$V_i$。每个岛的坐标不同。保证存在坐标 $(1,1)$ 和 $(M,M)$ 的岛。", "outputFormat": "第 $1$ 行：输出一个整数，表示最大收益。", "hint": "### 样例解释\n\n$20+60+10-\\left ( \\left(3-1 \\right )^2+\\left (5-1 \\right )^2 \\right )-\\left ( \\left (10-3 \\right )^2+\\left (10-5 \\right )^2 \\right )=-4$\n\n### 数据范围\n\n对 $20\\%$ 的数据 $M\\le 200$，且 $N\\le 2\\times 10^3$。\n\n对 $50\\%$ 的数据 $M\\le 200$，且 $N\\le 2\\times 10^4$。\n\n对 $100\\%$ 的数据 $M\\le 1000$，且 $N\\le 2\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P4057", "type": "P", "difficulty": 2, "samples": [["2 3 5\n", "30"], ["3 4 6\n", "12"], ["10 100 1000\n", "1000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "O2优化", "最大公约数 gcd", "Code+"], "title": "[Code+#1] 晨跑", "background": null, "description": "“无体育，不清华”、“每天锻炼一小时，健康工作五十年，幸福生活一辈子”\n\n\n在清华，体育运动绝对是同学们生活中不可或缺的一部分。为了响应学校的号召，模范好学生王队长决定坚持晨跑。不过由于种种原因，每天都早起去跑步不太现实，所以王队长决定每 $a$ 天晨跑一次。换句话说，假如王队长某天早起去跑了步，之后他会休息 $a-1$ 天，然后第 $a$ 天继续去晨跑，并以此类推。\n\n\n王队长的好朋友小钦和小针深受王队长坚持锻炼的鼓舞，并决定自己也要坚持晨跑。为了适宜自己的情况，小钦决定每 $b$ 天早起跑步一次，而小针决定每 $c$ 天早起跑步一次。\n\n\n某天早晨，王队长、小钦和小针在早起跑步时相遇了，他们非常激动、相互鼓励，共同完成了一次完美的晨跑。为了表述方便，我们把三位同学相遇的这天记为第$0$天。假设三位同学每次晨跑的时间段和路线都相同，他们想知道，下一次三人在跑步时相遇是第几天。由于三位同学都不会算，所以希望由聪明的你来告诉他们答案。", "inputFormat": "输入共一行，包含三个正整数 $a,b,c$，表示王队长每隔 $a$ 天晨跑一次、小钦每隔 $b$ 天晨跑一次且小针每隔 $c$ 天晨跑一次。", "outputFormat": "输出共一行，包含一个正整数 $x$，表示三位同学下次将在第 $x$ 天相遇。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/12819.png) \n\n来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/何昊天 命题/何昊天 验题/卢政荣\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201711\n\n感谢腾讯公司对此次比赛的支持。", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#1] Morning Run", "background": "", "description": "\"Without sports, there is no Tsinghua.\" \"Exercise one hour a day, work healthily for fifty years, live a happy life for a lifetime.\"\n\nAt Tsinghua, sports are an indispensable part of students' lives. To respond to the school's call, model student Captain Wang decides to stick to morning runs. However, for various reasons, getting up early to run every day is not realistic, so Captain Wang decides to run once every $a$ days. In other words, if Captain Wang gets up early to run on a certain day, he will rest for $a-1$ days afterward, then run again on the $a$-th day, and so on.\n\nInspired by Captain Wang's persistence, his good friends Xiao Qin and Xiao Zhen also decide to keep up with morning runs. To suit their own situations, Xiao Qin decides to run once every $b$ days, and Xiao Zhen decides to run once every $c$ days.\n\nOne morning, Captain Wang, Xiao Qin, and Xiao Zhen meet during their early run. They are very excited, encourage each other, and complete a perfect morning run together. For convenience, we label this meeting day as day $0$. Assuming the time window and route of each morning run are the same, they want to know on which day they will meet again while running. Since none of them can do the math, they ask you to tell them the answer.", "inputFormat": "The input consists of one line containing three positive integers $a$, $b$, $c$, meaning Captain Wang runs every $a$ days, Xiao Qin runs every $b$ days, and Xiao Zhen runs every $c$ days.", "outputFormat": "Output one line containing a positive integer $x$, indicating that the next time the three students meet will be on day $x$.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/12819.png)\n\nFrom the CodePlus 2017 November Contest, presented with honor by the Student Algorithm and Programming Contest Association of the Department of Computer Science and Technology, Tsinghua University.\n\nCredit: idea/He Haotian, problem setting/He Haotian, verification/Lu Zhengrong.\n\nGit Repo: https://git.thusaac.org/publish/CodePlus201711\n\nThanks to Tencent for supporting this contest.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#1] 晨跑", "background": null, "description": "“无体育，不清华”、“每天锻炼一小时，健康工作五十年，幸福生活一辈子”\n\n\n在清华，体育运动绝对是同学们生活中不可或缺的一部分。为了响应学校的号召，模范好学生王队长决定坚持晨跑。不过由于种种原因，每天都早起去跑步不太现实，所以王队长决定每 $a$ 天晨跑一次。换句话说，假如王队长某天早起去跑了步，之后他会休息 $a-1$ 天，然后第 $a$ 天继续去晨跑，并以此类推。\n\n\n王队长的好朋友小钦和小针深受王队长坚持锻炼的鼓舞，并决定自己也要坚持晨跑。为了适宜自己的情况，小钦决定每 $b$ 天早起跑步一次，而小针决定每 $c$ 天早起跑步一次。\n\n\n某天早晨，王队长、小钦和小针在早起跑步时相遇了，他们非常激动、相互鼓励，共同完成了一次完美的晨跑。为了表述方便，我们把三位同学相遇的这天记为第$0$天。假设三位同学每次晨跑的时间段和路线都相同，他们想知道，下一次三人在跑步时相遇是第几天。由于三位同学都不会算，所以希望由聪明的你来告诉他们答案。", "inputFormat": "输入共一行，包含三个正整数 $a,b,c$，表示王队长每隔 $a$ 天晨跑一次、小钦每隔 $b$ 天晨跑一次且小针每隔 $c$ 天晨跑一次。", "outputFormat": "输出共一行，包含一个正整数 $x$，表示三位同学下次将在第 $x$ 天相遇。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/12819.png) \n\n来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/何昊天 命题/何昊天 验题/卢政荣\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201711\n\n感谢腾讯公司对此次比赛的支持。", "locale": "zh-CN"}}}
