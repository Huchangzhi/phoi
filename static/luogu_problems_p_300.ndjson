{"pid": "P7070", "type": "P", "difficulty": 5, "samples": [["3 1\n4 3\n2 2\n2 1\n", "15\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "ICPC", "NWRRC"], "title": "[NWRRC 2014] Kebab House", "background": "", "description": "\n\nThe young man Vahtang Bumerang makes kebabs at the world-famous fast-food chain Kebab House. Each kebab contains many ingredients.\n\nThis morning Vahtang has received an order to make $n$ kebabs. At first, he should put $q_{1}$ ingredients to the first kebab, then $q_{2}$ ingredients in the second one and so on. Vahtang spends one second to put one ingredient to a kebab, so it takes $q_{i}$ seconds to make the i-th kebab. When he finishes the kebab he immediately proceeds to the next one.\n\nVahtang often dreams about his lovely boomerang while making kebabs. Each dream takes exactly one second and Vahtang forgets to put one ingredient to kebab during this second. Fortunately, he never dreams twice in any consecutive $(t + 1)$ seconds.\n\nDue to dreams about boomerang, some kebabs may have lesser than the desired number of ingredients, but customers are still happy if the $i$-th kebab has at least $x_{i}$ ingredients in it.\n\nVahtang wants to calculate the number of ways to have dream seconds during his work while keeping all customers happy. Can you help him? The real answer may be very huge, so you have to calculate it modulo $10^{9} + 7$ .\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $n$ and $t$ — the number of kebabs and minimal possible time between dream seconds $(1 \\le n \\le 1000$ ; $0 \\le t \\le 100)$ .\n\nEach of the next $n$ lines contains two integers $q_{i}, x_{i}$ — the number of ingredients in the $i$-th kebab and the minimum number of ingredients to make the $i$-th customer happy $(1 \\le q_{i} \\le 250$ ; $0 \\le x_{i} \\le q_{i}).$\n\n", "outputFormat": "\n\nThe only line of the output file must contain one integer -- the number of ways to distribute dream seconds modulo $10^{9} + 7$ .\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2014] Kebab House", "background": "", "description": "\n\nThe young man Vahtang Bumerang makes kebabs at the world-famous fast-food chain Kebab House. Each kebab contains many ingredients.\n\nThis morning Vahtang has received an order to make $n$ kebabs. At first, he should put $q_{1}$ ingredients to the first kebab, then $q_{2}$ ingredients in the second one and so on. Vahtang spends one second to put one ingredient to a kebab, so it takes $q_{i}$ seconds to make the i-th kebab. When he finishes the kebab he immediately proceeds to the next one.\n\nVahtang often dreams about his lovely boomerang while making kebabs. Each dream takes exactly one second and Vahtang forgets to put one ingredient to kebab during this second. Fortunately, he never dreams twice in any consecutive $(t + 1)$ seconds.\n\nDue to dreams about boomerang, some kebabs may have lesser than the desired number of ingredients, but customers are still happy if the $i$-th kebab has at least $x_{i}$ ingredients in it.\n\nVahtang wants to calculate the number of ways to have dream seconds during his work while keeping all customers happy. Can you help him? The real answer may be very huge, so you have to calculate it modulo $10^{9} + 7$ .\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $n$ and $t$ — the number of kebabs and minimal possible time between dream seconds $(1 \\le n \\le 1000$ ; $0 \\le t \\le 100)$ .\n\nEach of the next $n$ lines contains two integers $q_{i}, x_{i}$ — the number of ingredients in the $i$-th kebab and the minimum number of ingredients to make the $i$-th customer happy $(1 \\le q_{i} \\le 250$ ; $0 \\le x_{i} \\le q_{i}).$\n\n", "outputFormat": "\n\nThe only line of the output file must contain one integer -- the number of ways to distribute dream seconds modulo $10^{9} + 7$ .\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2014] Kebab House", "background": "", "description": "年轻人 Vahtang Bumerang 在世界著名的快餐连锁店 Kebab House 制作烤肉串。每个烤肉串包含许多配料。\n\n今天早上，Vahtang 收到了制作 $n$ 个烤肉串的订单。首先，他需要在第一个烤肉串中放入 $q_{1}$ 种配料，然后在第二个烤肉串中放入 $q_{2}$ 种配料，依此类推。Vahtang 花费一秒钟将一种配料放入一个烤肉串中，因此制作第 $i$ 个烤肉串需要 $q_{i}$ 秒。当他完成一个烤肉串后，他会立即开始下一个。\n\nVahtang 在制作烤肉串时经常梦到他心爱的回旋镖。每个梦恰好持续一秒钟，并且在这一秒钟内 Vahtang 会忘记放入一种配料。幸运的是，他从未在任何连续的 $(t + 1)$ 秒内做过两次梦。\n\n由于梦到回旋镖，一些烤肉串可能会少于所需的配料数量，但如果第 $i$ 个烤肉串至少有 $x_{i}$ 种配料，顾客仍然会感到满意。\n\nVahtang 想计算在工作期间做梦的秒数有多少种分配方式，同时让所有顾客满意。你能帮他吗？由于真实答案可能非常大，所以你需要计算它对 $10^{9} + 7$ 取模的结果。", "inputFormat": "输入文件的第一行包含两个整数 $n$ 和 $t$ —— 烤肉串的数量和梦之间的最小可能时间 $(1 \\le n \\le 1000$；$0 \\le t \\le 100)$。\n\n接下来的 $n$ 行中的每一行包含两个整数 $q_{i}, x_{i}$ —— 第 $i$ 个烤肉串中的配料数量和使第 $i$ 个顾客满意的最小配料数量 $(1 \\le q_{i} \\le 250$；$0 \\le x_{i} \\le q_{i})$。", "outputFormat": "输出文件的唯一一行必须包含一个整数——分配梦秒数的方式数量，对 $10^{9} + 7$ 取模。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7071", "type": "P", "difficulty": 1, "samples": [["6\n", "4 2"], ["7", "-1"], ["126", "64 32 16 8 4 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["模拟", "2020", "进制", "CSP-J 入门级"], "title": "[CSP-J 2020] 优秀的拆分", "background": "", "description": "一般来说，一个正整数可以拆分成若干个正整数的和。\n\n例如，$1=1$，$10=1+2+3+4$ 等。对于正整数 $n$ 的一种特定拆分，我们称它为“优秀的”，当且仅当在这种拆分下，$n$ 被分解为了若干个**不同**的 $2$ 的**正整数**次幂。注意，一个数 $x$ 能被表示成 $2$ 的正整数次幂，当且仅当 $x$ 能通过正整数个 $2$ 相乘在一起得到。\n\n例如，$10=8+2=2^3+2^1$ 是一个优秀的拆分。但是，$7=4+2+1=2^2+2^1+2^0$ 就不是一个优秀的拆分，因为 $1$ 不是 $2$ 的正整数次幂。\n\n现在，给定正整数 $n$，你需要判断这个数的所有拆分中，是否存在优秀的拆分。若存在，请你给出具体的拆分方案。", "inputFormat": "输入只有一行，一个整数 $n$，代表需要判断的数。", "outputFormat": "如果这个数的所有拆分中，存在优秀的拆分。那么，你需要从大到小输出这个拆分中的每一个数，相邻两个数之间用一个空格隔开。可以证明，在规定了拆分数字的顺序后，该拆分方案是唯一的。\n\n若不存在优秀的拆分，输出 `-1`。", "hint": "### 样例 1 解释\n\n$6=4+2=2^2+2^1$ 是一个优秀的拆分。注意，$6=2+2+2$ 不是一个优秀的拆分，因为拆分成的 $3$ 个数不满足每个数互不相同。\n\n---\n\n### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，$n \\le 10$。\n- 对于另外 $20\\%$ 的数据，保证 $n$ 为奇数。\n- 对于另外 $20\\%$ 的数据，保证 $n$ 为 $2$ 的正整数次幂。\n- 对于 $80\\%$ 的数据，$n \\le 1024$。\n- 对于 $100\\%$ 的数据，$1 \\le n \\le {10}^7$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-J 2020] 优秀的拆分", "background": "", "description": "一般来说，一个正整数可以拆分成若干个正整数的和。\n\n例如，$1=1$，$10=1+2+3+4$ 等。对于正整数 $n$ 的一种特定拆分，我们称它为“优秀的”，当且仅当在这种拆分下，$n$ 被分解为了若干个**不同**的 $2$ 的**正整数**次幂。注意，一个数 $x$ 能被表示成 $2$ 的正整数次幂，当且仅当 $x$ 能通过正整数个 $2$ 相乘在一起得到。\n\n例如，$10=8+2=2^3+2^1$ 是一个优秀的拆分。但是，$7=4+2+1=2^2+2^1+2^0$ 就不是一个优秀的拆分，因为 $1$ 不是 $2$ 的正整数次幂。\n\n现在，给定正整数 $n$，你需要判断这个数的所有拆分中，是否存在优秀的拆分。若存在，请你给出具体的拆分方案。", "inputFormat": "输入只有一行，一个整数 $n$，代表需要判断的数。", "outputFormat": "如果这个数的所有拆分中，存在优秀的拆分。那么，你需要从大到小输出这个拆分中的每一个数，相邻两个数之间用一个空格隔开。可以证明，在规定了拆分数字的顺序后，该拆分方案是唯一的。\n\n若不存在优秀的拆分，输出 `-1`。", "hint": "### 样例 1 解释\n\n$6=4+2=2^2+2^1$ 是一个优秀的拆分。注意，$6=2+2+2$ 不是一个优秀的拆分，因为拆分成的 $3$ 个数不满足每个数互不相同。\n\n---\n\n### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，$n \\le 10$。\n- 对于另外 $20\\%$ 的数据，保证 $n$ 为奇数。\n- 对于另外 $20\\%$ 的数据，保证 $n$ 为 $2$ 的正整数次幂。\n- 对于 $80\\%$ 的数据，$n \\le 1024$。\n- 对于 $100\\%$ 的数据，$1 \\le n \\le {10}^7$。\n", "locale": "zh-CN"}}}
{"pid": "P7072", "type": "P", "difficulty": 2, "samples": [["10 60\n200 300 400 500 600 600 0 300 200 100\n", "200 300 400 400 400 500 400 400 300 300"], ["10 30\n100 100 600 100 100 100 100 100 100 100", "100 100 600 600 600 600 100 100 100 100"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["模拟", "2020", "排序", "CSP-J 入门级"], "title": "[CSP-J 2020] 直播获奖", "background": "", "description": "NOI2130 即将举行。为了增加观赏性，CCF 决定逐一评出每个选手的成绩，并直播即时的获奖分数线。本次竞赛的获奖率为 $w\\%$，即当前排名前 $w\\%$ 的选手的最低成绩就是即时的分数线。\n\n更具体地，若当前已评出了 $p$ 个选手的成绩，则当前计划获奖人数为 $\\max(1, \\lfloor p \\times w \\%\\rfloor)$，其中 $w$ 是获奖百分比，$\\lfloor x \\rfloor$ 表示对 $x$ 向下取整，$\\max(x,y)$ 表示 $x$ 和 $y$ 中较大的数。如有选手成绩相同，则所有成绩并列的选手都能获奖，因此实际获奖人数可能比计划中多。\n\n作为评测组的技术人员，请你帮 CCF 写一个直播程序。", "inputFormat": "第一行有两个整数 $n, w$。分别代表选手总数与获奖率。  \n第二行有 $n$ 个整数，依次代表逐一评出的选手成绩。", "outputFormat": "只有一行，包含 $n$ 个非负整数，依次代表选手成绩逐一评出后，即时的获奖分数线。相邻两个整数间用一个空格分隔。", "hint": "### 样例 1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l453vhow.png)\n\n---\n### 数据规模与约定\n\n各测试点的 $n$ 如下表：\n\n| 测试点编号 | $n=$ |\n| :--: | :--: |\n| $1 \\sim 3$ | $10$ |\n| $4 \\sim 6$ | $500$ |\n| $7 \\sim 10$ | $2000$ |\n| $11 \\sim 17$ | $10^4$ |\n| $18 \\sim 20$ | $10^5$ |\n\n\n对于所有测试点，每个选手的成绩均为不超过 $600$ 的非负整数，获奖百分比 $w$ 是一个正整数且 $1 \\le w \\le 99$。\n\n---\n### 提示\n\n在计算计划获奖人数时，如用浮点类型的变量（如 C/C++ 中的 `float` 、 `double`，Pascal 中的 `real` 、 `double` 、 `extended` 等）存储获奖比例 $w\\%$，则计算 $5 \\times 60\\%$ 时的结果可能为 $3.000001$，也可能为 $2.999999$，向下取整后的结果不确定。因此，建议仅使用整型变量，以计算出准确值。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-J 2020] 直播获奖", "background": "", "description": "NOI2130 即将举行。为了增加观赏性，CCF 决定逐一评出每个选手的成绩，并直播即时的获奖分数线。本次竞赛的获奖率为 $w\\%$，即当前排名前 $w\\%$ 的选手的最低成绩就是即时的分数线。\n\n更具体地，若当前已评出了 $p$ 个选手的成绩，则当前计划获奖人数为 $\\max(1, \\lfloor p \\times w \\%\\rfloor)$，其中 $w$ 是获奖百分比，$\\lfloor x \\rfloor$ 表示对 $x$ 向下取整，$\\max(x,y)$ 表示 $x$ 和 $y$ 中较大的数。如有选手成绩相同，则所有成绩并列的选手都能获奖，因此实际获奖人数可能比计划中多。\n\n作为评测组的技术人员，请你帮 CCF 写一个直播程序。", "inputFormat": "第一行有两个整数 $n, w$。分别代表选手总数与获奖率。  \n第二行有 $n$ 个整数，依次代表逐一评出的选手成绩。", "outputFormat": "只有一行，包含 $n$ 个非负整数，依次代表选手成绩逐一评出后，即时的获奖分数线。相邻两个整数间用一个空格分隔。", "hint": "### 样例 1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l453vhow.png)\n\n---\n### 数据规模与约定\n\n各测试点的 $n$ 如下表：\n\n| 测试点编号 | $n=$ |\n| :--: | :--: |\n| $1 \\sim 3$ | $10$ |\n| $4 \\sim 6$ | $500$ |\n| $7 \\sim 10$ | $2000$ |\n| $11 \\sim 17$ | $10^4$ |\n| $18 \\sim 20$ | $10^5$ |\n\n\n对于所有测试点，每个选手的成绩均为不超过 $600$ 的非负整数，获奖百分比 $w$ 是一个正整数且 $1 \\le w \\le 99$。\n\n---\n### 提示\n\n在计算计划获奖人数时，如用浮点类型的变量（如 C/C++ 中的 `float` 、 `double`，Pascal 中的 `real` 、 `double` 、 `extended` 等）存储获奖比例 $w\\%$，则计算 $5 \\times 60\\%$ 时的结果可能为 $3.000001$，也可能为 $2.999999$，向下取整后的结果不确定。因此，建议仅使用整型变量，以计算出准确值。", "locale": "zh-CN"}}}
{"pid": "P7073", "type": "P", "difficulty": 4, "samples": [["x1 x2 & x3 |\n3\n1 0 1\n3\n1\n2\n3\n", "1\n1\n0"], ["x1 ! x2 x4 | x3 x5 ! & & ! &\n5\n0 1 0 1 1\n3\n1\n3\n5\n", "0\n1\n1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["树形数据结构", "2020", "CSP-J 入门级"], "title": "[CSP-J 2020] 表达式", "background": "", "description": "小 C 热衷于学习数理逻辑。有一天，他发现了一种特别的逻辑表达式。在这种逻辑表达式中，所有操作数都是变量，且它们的取值只能为 $0$ 或 $1$，运算从左往右进行。如果表达式中有括号，则先计算括号内的子表达式的值。特别的，这种表达式有且仅有以下几种运算：\n1. 与运算：`a & b`。当且仅当 $a$ 和 $b$ 的值都为 $1$ 时，该表达式的值为 $1$。其余情况该表达式的值为 $0$。\n2. 或运算：`a | b`。当且仅当 $a$ 和 $b$ 的值都为 $0$ 时，该表达式的值为 $0$。其余情况该表达式的值为 $1$。\n3. 取反运算：`!a`。当且仅当 $a$ 的值为 $0$ 时，该表达式的值为 $1$。其余情况该表达式的值为 $0$。\n\n小 C 想知道，给定一个逻辑表达式和其中每一个操作数的初始取值后，再取反某一个操作数的值时，原表达式的值为多少。\n\n为了化简对表达式的处理，我们有如下约定：\n\n表达式将采用**后缀表达式**的方式输入。\n\n后缀表达式的定义如下：\n1. 如果 $E$ 是一个操作数，则 $E$ 的后缀表达式是它本身。\n2. 如果 $E$ 是 $E_1~\\texttt{op}~E_2$ 形式的表达式，其中 $\\texttt{op}$ 是任何二元操作符，且优先级不高于 $E_1$ 、$E_2$ 中括号外的操作符，则 $E$ 的后缀式为 $E_1' E_2' \\texttt{op}$，其中 $E_1'$ 、$E_2'$ 分别为 $E_1$、$E_2$ 的后缀式。\n3. 如果 $E$ 是 $E_1$ 形式的表达式，则 $E_1$ 的后缀式就是 $E$ 的后缀式。\n\n同时为了方便，输入中：\n\n1. 与运算符（&）、或运算符（|）、取反运算符（!）的左右**均有一个空格**，但**表达式末尾没有空格**。\n2. 操作数由小写字母 $x$ 与一个正整数拼接而成，正整数表示这个变量的下标。例如：`x10`，表示下标为 $10$ 的变量 $x_{10}$。数据保证**每个变量在表达式中出现恰好一次**。", "inputFormat": "第一行包含一个字符串 $s$，表示上文描述的表达式。  \n\n第二行包含一个正整数 $n$，表示表达式中变量的数量。表达式中变量的下标为 $1,2, \\cdots , n$。  \n\n第三行包含 $n$ 个整数，第 $i$ 个整数表示变量 $x_i$ 的初值。  \n\n第四行包含一个正整数 $q$，表示询问的个数。  \n\n接下来 $q$ 行，每行一个正整数，表示需要取反的变量的下标。注意，每一个询问的修改都是**临时的**，即之前询问中的修改不会对后续的询问造成影响。 \n\n数据保证输入的表达式合法。变量的初值为 $0$ 或 $1$。", "outputFormat": "输出一共有 $q$ 行，每行一个 $0$ 或 $1$，表示该询问下表达式的值。", "hint": "### 样例 1 解释\n\n\n该后缀表达式的中缀表达式形式为 $(x_1 \\operatorname{and} x_2) \\operatorname{or} x_3$。\n\n- 对于第一次询问，将 $x_1$ 的值取反。此时，三个操作数对应的赋值依次为 $0$，$0$，$1$。原表达式的值为 $(0\\&0)|1=1$。\n- 对于第二次询问，将 $x_2$ 的值取反。此时，三个操作数对应的赋值依次为 $1$，$1$，$1$。原表达式的值为 $(1\\&1)|1=1$。\n- 对于第三次询问，将 $x_3$ 的值取反。此时，三个操作数对应的赋值依次为 $1$，$0$，$0$。原表达式的值为 $(1\\&0)|0=0$。\n\n### 样例 2 解释\n\n\n该表达式的中缀表达式形式为 $(\\operatorname{not}x_1)\\operatorname{and}(\\operatorname{not}((x_2\\operatorname{or}x_4)\\operatorname{and}(x_3\\operatorname{and}(\\operatorname{not}x_5))))$。\n\n### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，表达式中有且仅有与运算（&）或者或运算（|）。\n- 对于另外 $30\\%$ 的数据，$|s| \\le 1000$，$q \\le 1000$，$n \\le 1000$。\n- 对于另外 $20\\%$ 的数据，变量的初值全为 $0$ 或全为 $1$。\n- 对于 $100\\%$ 的数据，$1 \\le |s| \\le 1 \\times 10^6$，$1 \\le q \\le 1 \\times 10^5$，$2 \\le n \\le 1 \\times 10^5$。\n\n其中，$|s|$ 表示字符串 $s$ 的长度。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-J 2020] 表达式", "background": "", "description": "小 C 热衷于学习数理逻辑。有一天，他发现了一种特别的逻辑表达式。在这种逻辑表达式中，所有操作数都是变量，且它们的取值只能为 $0$ 或 $1$，运算从左往右进行。如果表达式中有括号，则先计算括号内的子表达式的值。特别的，这种表达式有且仅有以下几种运算：\n1. 与运算：`a & b`。当且仅当 $a$ 和 $b$ 的值都为 $1$ 时，该表达式的值为 $1$。其余情况该表达式的值为 $0$。\n2. 或运算：`a | b`。当且仅当 $a$ 和 $b$ 的值都为 $0$ 时，该表达式的值为 $0$。其余情况该表达式的值为 $1$。\n3. 取反运算：`!a`。当且仅当 $a$ 的值为 $0$ 时，该表达式的值为 $1$。其余情况该表达式的值为 $0$。\n\n小 C 想知道，给定一个逻辑表达式和其中每一个操作数的初始取值后，再取反某一个操作数的值时，原表达式的值为多少。\n\n为了化简对表达式的处理，我们有如下约定：\n\n表达式将采用**后缀表达式**的方式输入。\n\n后缀表达式的定义如下：\n1. 如果 $E$ 是一个操作数，则 $E$ 的后缀表达式是它本身。\n2. 如果 $E$ 是 $E_1~\\texttt{op}~E_2$ 形式的表达式，其中 $\\texttt{op}$ 是任何二元操作符，且优先级不高于 $E_1$ 、$E_2$ 中括号外的操作符，则 $E$ 的后缀式为 $E_1' E_2' \\texttt{op}$，其中 $E_1'$ 、$E_2'$ 分别为 $E_1$、$E_2$ 的后缀式。\n3. 如果 $E$ 是 $E_1$ 形式的表达式，则 $E_1$ 的后缀式就是 $E$ 的后缀式。\n\n同时为了方便，输入中：\n\n1. 与运算符（&）、或运算符（|）、取反运算符（!）的左右**均有一个空格**，但**表达式末尾没有空格**。\n2. 操作数由小写字母 $x$ 与一个正整数拼接而成，正整数表示这个变量的下标。例如：`x10`，表示下标为 $10$ 的变量 $x_{10}$。数据保证**每个变量在表达式中出现恰好一次**。", "inputFormat": "第一行包含一个字符串 $s$，表示上文描述的表达式。  \n\n第二行包含一个正整数 $n$，表示表达式中变量的数量。表达式中变量的下标为 $1,2, \\cdots , n$。  \n\n第三行包含 $n$ 个整数，第 $i$ 个整数表示变量 $x_i$ 的初值。  \n\n第四行包含一个正整数 $q$，表示询问的个数。  \n\n接下来 $q$ 行，每行一个正整数，表示需要取反的变量的下标。注意，每一个询问的修改都是**临时的**，即之前询问中的修改不会对后续的询问造成影响。 \n\n数据保证输入的表达式合法。变量的初值为 $0$ 或 $1$。", "outputFormat": "输出一共有 $q$ 行，每行一个 $0$ 或 $1$，表示该询问下表达式的值。", "hint": "### 样例 1 解释\n\n\n该后缀表达式的中缀表达式形式为 $(x_1 \\operatorname{and} x_2) \\operatorname{or} x_3$。\n\n- 对于第一次询问，将 $x_1$ 的值取反。此时，三个操作数对应的赋值依次为 $0$，$0$，$1$。原表达式的值为 $(0\\&0)|1=1$。\n- 对于第二次询问，将 $x_2$ 的值取反。此时，三个操作数对应的赋值依次为 $1$，$1$，$1$。原表达式的值为 $(1\\&1)|1=1$。\n- 对于第三次询问，将 $x_3$ 的值取反。此时，三个操作数对应的赋值依次为 $1$，$0$，$0$。原表达式的值为 $(1\\&0)|0=0$。\n\n### 样例 2 解释\n\n\n该表达式的中缀表达式形式为 $(\\operatorname{not}x_1)\\operatorname{and}(\\operatorname{not}((x_2\\operatorname{or}x_4)\\operatorname{and}(x_3\\operatorname{and}(\\operatorname{not}x_5))))$。\n\n### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，表达式中有且仅有与运算（&）或者或运算（|）。\n- 对于另外 $30\\%$ 的数据，$|s| \\le 1000$，$q \\le 1000$，$n \\le 1000$。\n- 对于另外 $20\\%$ 的数据，变量的初值全为 $0$ 或全为 $1$。\n- 对于 $100\\%$ 的数据，$1 \\le |s| \\le 1 \\times 10^6$，$1 \\le q \\le 1 \\times 10^5$，$2 \\le n \\le 1 \\times 10^5$。\n\n其中，$|s|$ 表示字符串 $s$ 的长度。", "locale": "zh-CN"}}}
{"pid": "P7074", "type": "P", "difficulty": 4, "samples": [["3 4\n1 -1 3 2\n2 -1 4 -1\n-2 2 -3 -1\n", "9"], ["2 5\n-1 -1 -3 -2 -7\n-2 -1 -4 -1 -2\n", "-10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2020", "CSP-J 入门级"], "title": "[CSP-J 2020] 方格取数", "background": "", "description": "设有 $n \\times m$ 的方格图，每个方格中都有一个整数。现有一只小熊，想从图的左上角走到右下角，每一步只能向上、向下或向右走一格，并且不能重复经过已经走过的方格，也不能走出边界。小熊会取走所有经过的方格中的整数，求它能取到的整数之和的最大值。", "inputFormat": "第一行有两个整数 $n, m$。\n\n接下来 $n$ 行每行 $m$ 个整数，依次代表每个方格中的整数。", "outputFormat": "一个整数，表示小熊能取到的整数之和的最大值。", "hint": "### 样例 1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sq4638pa.png)\n---\n\n### 样例 2 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7tfdyabk.png)\n---\n\n### 数据规模与约定\n- 对于 $20\\%$ 的数据，$n, m \\le 5$。\n- 对于 $40\\%$ 的数据，$n, m \\le 50$。\n- 对于 $70\\%$ 的数据，$n, m \\le 300$。\n- 对于 $100\\%$ 的数据，$1 \\le n,m \\le 10^3$。方格中整数的绝对值不超过 $10^4$。\n\n\n\n------------\n2024/2/4 添加一组 hack 数据。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-J 2020] 方格取数", "background": "", "description": "设有 $n \\times m$ 的方格图，每个方格中都有一个整数。现有一只小熊，想从图的左上角走到右下角，每一步只能向上、向下或向右走一格，并且不能重复经过已经走过的方格，也不能走出边界。小熊会取走所有经过的方格中的整数，求它能取到的整数之和的最大值。", "inputFormat": "第一行有两个整数 $n, m$。\n\n接下来 $n$ 行每行 $m$ 个整数，依次代表每个方格中的整数。", "outputFormat": "一个整数，表示小熊能取到的整数之和的最大值。", "hint": "### 样例 1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sq4638pa.png)\n---\n\n### 样例 2 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7tfdyabk.png)\n---\n\n### 数据规模与约定\n- 对于 $20\\%$ 的数据，$n, m \\le 5$。\n- 对于 $40\\%$ 的数据，$n, m \\le 50$。\n- 对于 $70\\%$ 的数据，$n, m \\le 300$。\n- 对于 $100\\%$ 的数据，$1 \\le n,m \\le 10^3$。方格中整数的绝对值不超过 $10^4$。\n\n\n\n------------\n2024/2/4 添加一组 hack 数据。", "locale": "zh-CN"}}}
{"pid": "P7075", "type": "P", "difficulty": 4, "samples": [["3\n10\n100\n1000", "11 1 4713 BC\n10 4 4713 BC\n27 9 4711 BC"], ["3\n2000000\n3000000\n4000000", "14 9 763\n15 8 3501\n12 7 6239"], ["见附件中的 julian/julian3.in", "见附件中的 julian/julian3.ans"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["模拟", "数学", "2020", "二分", "CSP-S 提高级"], "title": "[CSP-S 2020] 儒略日", "background": "", "description": "为了简便计算，天文学家们使用儒略日（Julian day）来表达时间。所谓儒略日，其定义为从**公元前 4713 年 1 月 1 日正午 12 点到此后某一时刻间所经过的天数**，不满一天者用小数表达。若利用这一天文学历法，则每一个时刻都将被均匀的映射到数轴上，从而得以很方便的计算它们的差值。\n\n现在，给定一个不含小数部分的儒略日，请你帮忙计算出该儒略日（一定是某一天的中午 12 点）所对应的公历日期。\n\n我们现行的公历为格里高利历（Gregorian calendar），它是在公元 1582 年由教皇格里高利十三世在原有的儒略历（Julian calendar）的基础上修改得到的（注：儒略历与儒略日并无直接关系）。具体而言，现行的公历日期按照以下规则计算：\n\n1. 公元 1582 年 10 月 15 日（含）以后：适用格里高利历，每年一月 $31$ 天、 二月 $28$ 天或 $29$ 天、三月 $31$ 天、四月 $30$ 天、五月 $31$ 天、六月 $30$ 天、七月 $31$ 天、八月 $31$ 天、九月 $30$ 天、十月 $31$ 天、十一月 $30$ 天、十二月 $31$ 天。其中，闰年的二月为 $29$ 天，平年为 $28$ 天。当年份是 $400$ 的倍数，或日期年份是 $4$ 的倍数但不是 $100$ 的倍数时，该年为闰年。\n2. 公元 1582 年 10 月 5 日（含）至 10 月 14 日（含）：不存在，这些日期被删除，该年 10 月 4 日之后为 10 月 15 日。\n3. 公元 1582 年 10 月 4 日（含）以前：适用儒略历，每月天数与格里高利历相同，但只要年份是 $4$ 的倍数就是闰年。\n4. 尽管儒略历于公元前 45 年才开始实行，且初期经过若干次调整，但今天人类习惯于按照儒略历最终的规则反推一切 1582 年 10 月 4 日之前的时间。注意，**公元零年并不存在**，即公元前 1 年的下一年是公元 1 年。因此公元前 1 年、前 5 年、前 9 年、前 13 年……以此类推的年份应视为闰年。", "inputFormat": "第一行一个整数 $Q$，表示询问的组数。  \n接下来 $Q$ 行，每行一个非负整数 $r_i$，表示一个儒略日。", "outputFormat": "对于每一个儒略日 $r_i$，输出一行表示日期的字符串 $s_i$。共计 $Q$ 行。 $s_i$ 的格式如下：\n\n1. 若年份为公元后，输出格式为 `Day Month Year`。其中日（Day）、月（Month）、年（Year）均不含前导零，中间用一个空格隔开。例如：公元\n2020 年 11 月 7 日正午 12 点，输出为 `7 11 2020`。\n2. 若年份为公元前，输出格式为 `Day Month Year BC`。其中年（Year）输出该年份的数值，其余与公元后相同。例如：公元前 841 年 2 月 1 日正午 12\n点，输出为 `1 2 841 BC`。", "hint": "**【数据范围】**\n\n| 测试点编号 | $Q =$ | $r_i \\le$ |\n|:-:|:-:|:-:|\n| $1$ | $1000$ | $365$ |\n| $2$ | $1000$ | $10^4$ |\n| $3$ | $1000$ | $10^5$ |\n| $4$ | $10000$ | $3\\times 10^5$ |\n| $5$ | $10000$ | $2.5\\times 10^6$ |\n| $6$ | $10^5$ | $2.5\\times 10^6$ |\n| $7$ | $10^5$ | $5\\times 10^6$ |\n| $8$ | $10^5$ | $10^7$ |\n| $9$ | $10^5$ | $10^9$ |\n| $10$ | $10^5$ | 年份答案不超过 $10^9$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-S 2020] 儒略日", "background": "", "description": "为了简便计算，天文学家们使用儒略日（Julian day）来表达时间。所谓儒略日，其定义为从**公元前 4713 年 1 月 1 日正午 12 点到此后某一时刻间所经过的天数**，不满一天者用小数表达。若利用这一天文学历法，则每一个时刻都将被均匀的映射到数轴上，从而得以很方便的计算它们的差值。\n\n现在，给定一个不含小数部分的儒略日，请你帮忙计算出该儒略日（一定是某一天的中午 12 点）所对应的公历日期。\n\n我们现行的公历为格里高利历（Gregorian calendar），它是在公元 1582 年由教皇格里高利十三世在原有的儒略历（Julian calendar）的基础上修改得到的（注：儒略历与儒略日并无直接关系）。具体而言，现行的公历日期按照以下规则计算：\n\n1. 公元 1582 年 10 月 15 日（含）以后：适用格里高利历，每年一月 $31$ 天、 二月 $28$ 天或 $29$ 天、三月 $31$ 天、四月 $30$ 天、五月 $31$ 天、六月 $30$ 天、七月 $31$ 天、八月 $31$ 天、九月 $30$ 天、十月 $31$ 天、十一月 $30$ 天、十二月 $31$ 天。其中，闰年的二月为 $29$ 天，平年为 $28$ 天。当年份是 $400$ 的倍数，或日期年份是 $4$ 的倍数但不是 $100$ 的倍数时，该年为闰年。\n2. 公元 1582 年 10 月 5 日（含）至 10 月 14 日（含）：不存在，这些日期被删除，该年 10 月 4 日之后为 10 月 15 日。\n3. 公元 1582 年 10 月 4 日（含）以前：适用儒略历，每月天数与格里高利历相同，但只要年份是 $4$ 的倍数就是闰年。\n4. 尽管儒略历于公元前 45 年才开始实行，且初期经过若干次调整，但今天人类习惯于按照儒略历最终的规则反推一切 1582 年 10 月 4 日之前的时间。注意，**公元零年并不存在**，即公元前 1 年的下一年是公元 1 年。因此公元前 1 年、前 5 年、前 9 年、前 13 年……以此类推的年份应视为闰年。", "inputFormat": "第一行一个整数 $Q$，表示询问的组数。  \n接下来 $Q$ 行，每行一个非负整数 $r_i$，表示一个儒略日。", "outputFormat": "对于每一个儒略日 $r_i$，输出一行表示日期的字符串 $s_i$。共计 $Q$ 行。 $s_i$ 的格式如下：\n\n1. 若年份为公元后，输出格式为 `Day Month Year`。其中日（Day）、月（Month）、年（Year）均不含前导零，中间用一个空格隔开。例如：公元\n2020 年 11 月 7 日正午 12 点，输出为 `7 11 2020`。\n2. 若年份为公元前，输出格式为 `Day Month Year BC`。其中年（Year）输出该年份的数值，其余与公元后相同。例如：公元前 841 年 2 月 1 日正午 12\n点，输出为 `1 2 841 BC`。", "hint": "**【数据范围】**\n\n| 测试点编号 | $Q =$ | $r_i \\le$ |\n|:-:|:-:|:-:|\n| $1$ | $1000$ | $365$ |\n| $2$ | $1000$ | $10^4$ |\n| $3$ | $1000$ | $10^5$ |\n| $4$ | $10000$ | $3\\times 10^5$ |\n| $5$ | $10000$ | $2.5\\times 10^6$ |\n| $6$ | $10^5$ | $2.5\\times 10^6$ |\n| $7$ | $10^5$ | $5\\times 10^6$ |\n| $8$ | $10^5$ | $10^7$ |\n| $9$ | $10^5$ | $10^9$ |\n| $10$ | $10^5$ | 年份答案不超过 $10^9$ |", "locale": "zh-CN"}}}
{"pid": "P7076", "type": "P", "difficulty": 3, "samples": [["3 3 5 4\n1 4 6\n0 3\n2 4\n2 5", "13"], ["2 2 4 3\n1 2\n1 3\n2 4", "2"], ["见附件中的 zoo/zoo3.in", "见附件中的 zoo/zoo3.ans"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "贪心", "2020", "进制", "位运算", "CSP-S 提高级"], "title": "[CSP-S 2020] 动物园", "background": "", "description": "动物园里饲养了很多动物，饲养员小 A 会根据饲养动物的情况，按照《饲养指南》购买不同种类的饲料，并将购买清单发给采购员小 B。 \n\n具体而言，动物世界里存在 $2^k$ 种不同的动物，它们被编号为 $0 \\sim 2^k - 1$。动物园里饲养了其中的 $n$ 种，其中第 $i$ 种动物的编号为 $a_i$。\n\n《饲养指南》中共有 $m$ 条要求，第 $j$ 条要求形如“如果动物园中饲养着某种动物，满足其编号的二进制表示的第 $p_j$ 位为 $1$，则必须购买第 $q_j$ 种饲料”。其中饲料共有 $c$ 种，它们从 $1 \\sim c$ 编号。本题中我们将动物编号的二进制表示视为一个 $k$ 位 01 串，第 $0$ 位是最低位，第 $k - 1$ 位是最高位。 \n\n根据《饲养指南》，小 A 将会制定饲料清单交给小 B，由小 B 购买饲料。清单形如一个 $c$ 位 $01$ 串，第 $i$ 位为 $1$ 时，表示需要购买第 $i$ 种饲料；第 $i$ 位为 $0$ 时，表示不需要购买第 $i$ 种饲料。 实际上根据购买到的饲料，动物园可能可以饲养更多的动物。更具体地，如果将当前未被饲养的编号为 $x$ 的动物加入动物园饲养后，饲料清单没有变化，那么我们认为动物园当前还能饲养编号为 $x$ 的动物。\n\n现在小 B 想请你帮忙算算，动物园目前还能饲养多少种动物。", "inputFormat": "第一行包含四个以空格分隔的整数 $n, m, c, k$。  \n分别表示动物园中动物数量、《饲养指南》要求数、饲料种数与动物编号的二进制表示位数。   \n第二行 $n$ 个以空格分隔的整数，其中第 $i$ 个整数表示 $a_i$。  \n接下来 $m$ 行，每行两个整数 $p_i, q_i$ 表示一条要求。  \n数据保证所有 $a_i$ 互不相同，所有的 $q_i$ 互不相同。", "outputFormat": "仅一行一个整数表示答案。", "hint": "**【样例 #1 解释】**\n\n动物园里饲养了编号为 $1, 4, 6$ 的三种动物，《饲养指南》上的三条要求为：\n\n1. 若饲养的某种动物的编号的第 $0$ 个二进制位为 $1$，则需购买第 $3$ 种饲料。\n2. 若饲养的某种动物的编号的第 $2$ 个二进制位为 $1$，则需购买第 $4$ 种饲料。\n3. 若饲养的某种动物的编号的第 $2$ 个二进制位为 $1$，则需购买第 $5$ 种饲料。 \n\n饲料购买情况为：\n\n1. 编号为 $1$ 的动物的第 $0$ 个二进制位为 $1$，因此需要购买第 $3$ 种饲料；\n2. 编号为 $4, 6$ 的动物的第 $2$ 个二进制位为 $1$，因此需要购买第 $4, 5$ 种饲料。 \n\n由于在当前动物园中加入一种编号为 $0, 2, 3, 5, 7, 8, \\ldots , 15$ 之一的动物，购物清单都不会改变，因此答案为 $13$。\n\n**【数据范围】**\n\n对于 $20 \\%$ 的数据，$k \\le n \\le 5$，$m \\le 10$，$c \\le 10$，所有的 $p_i$ 互不相同。  \n对于 $40 \\%$ 的数据，$n \\le 15$，$k \\le 20$，$m \\le 20$，$c \\le 20$。  \n对于 $60 \\%$ 的数据，$n \\le 30$，$k \\le 30$，$m \\le 1000$。  \n对于 $100 \\%$ 的数据，$0 \\le n, m \\le 10^6$，$0 \\le k \\le 64$，$1 \\le c \\le 10^8$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-S 2020] 动物园", "background": "", "description": "动物园里饲养了很多动物，饲养员小 A 会根据饲养动物的情况，按照《饲养指南》购买不同种类的饲料，并将购买清单发给采购员小 B。 \n\n具体而言，动物世界里存在 $2^k$ 种不同的动物，它们被编号为 $0 \\sim 2^k - 1$。动物园里饲养了其中的 $n$ 种，其中第 $i$ 种动物的编号为 $a_i$。\n\n《饲养指南》中共有 $m$ 条要求，第 $j$ 条要求形如“如果动物园中饲养着某种动物，满足其编号的二进制表示的第 $p_j$ 位为 $1$，则必须购买第 $q_j$ 种饲料”。其中饲料共有 $c$ 种，它们从 $1 \\sim c$ 编号。本题中我们将动物编号的二进制表示视为一个 $k$ 位 01 串，第 $0$ 位是最低位，第 $k - 1$ 位是最高位。 \n\n根据《饲养指南》，小 A 将会制定饲料清单交给小 B，由小 B 购买饲料。清单形如一个 $c$ 位 $01$ 串，第 $i$ 位为 $1$ 时，表示需要购买第 $i$ 种饲料；第 $i$ 位为 $0$ 时，表示不需要购买第 $i$ 种饲料。 实际上根据购买到的饲料，动物园可能可以饲养更多的动物。更具体地，如果将当前未被饲养的编号为 $x$ 的动物加入动物园饲养后，饲料清单没有变化，那么我们认为动物园当前还能饲养编号为 $x$ 的动物。\n\n现在小 B 想请你帮忙算算，动物园目前还能饲养多少种动物。", "inputFormat": "第一行包含四个以空格分隔的整数 $n, m, c, k$。  \n分别表示动物园中动物数量、《饲养指南》要求数、饲料种数与动物编号的二进制表示位数。   \n第二行 $n$ 个以空格分隔的整数，其中第 $i$ 个整数表示 $a_i$。  \n接下来 $m$ 行，每行两个整数 $p_i, q_i$ 表示一条要求。  \n数据保证所有 $a_i$ 互不相同，所有的 $q_i$ 互不相同。", "outputFormat": "仅一行一个整数表示答案。", "hint": "**【样例 #1 解释】**\n\n动物园里饲养了编号为 $1, 4, 6$ 的三种动物，《饲养指南》上的三条要求为：\n\n1. 若饲养的某种动物的编号的第 $0$ 个二进制位为 $1$，则需购买第 $3$ 种饲料。\n2. 若饲养的某种动物的编号的第 $2$ 个二进制位为 $1$，则需购买第 $4$ 种饲料。\n3. 若饲养的某种动物的编号的第 $2$ 个二进制位为 $1$，则需购买第 $5$ 种饲料。 \n\n饲料购买情况为：\n\n1. 编号为 $1$ 的动物的第 $0$ 个二进制位为 $1$，因此需要购买第 $3$ 种饲料；\n2. 编号为 $4, 6$ 的动物的第 $2$ 个二进制位为 $1$，因此需要购买第 $4, 5$ 种饲料。 \n\n由于在当前动物园中加入一种编号为 $0, 2, 3, 5, 7, 8, \\ldots , 15$ 之一的动物，购物清单都不会改变，因此答案为 $13$。\n\n**【数据范围】**\n\n对于 $20 \\%$ 的数据，$k \\le n \\le 5$，$m \\le 10$，$c \\le 10$，所有的 $p_i$ 互不相同。  \n对于 $40 \\%$ 的数据，$n \\le 15$，$k \\le 20$，$m \\le 20$，$c \\le 20$。  \n对于 $60 \\%$ 的数据，$n \\le 30$，$k \\le 30$，$m \\le 1000$。  \n对于 $100 \\%$ 的数据，$0 \\le n, m \\le 10^6$，$0 \\le k \\le 64$，$1 \\le c \\le 10^8$。", "locale": "zh-CN"}}}
{"pid": "P7077", "type": "P", "difficulty": 5, "samples": [["3\n1 2 3\n3\n1 1 1\n2 2\n3 2 1 2\n2\n2 3\n", "6 8 12"], ["10\n1 2 3 4 5 6 7 8 9 10\n8\n3 2 2 3\n3 2 4 5\n3 2 5 8\n2 2\n3 2 6 7\n1 2 5\n1 7 6\n2 3\n3\n1 2 3", "36 282 108 144 180 216 504 288 324 360\n"], ["见附件中的 call/call3.in", "见附件中的 call/call3.ans"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "数学", "2020", "拓扑排序", "CSP-S 提高级"], "title": "[CSP-S 2020] 函数调用", "background": "", "description": "函数是各种编程语言中一项重要的概念，借助函数，我们总可以将复杂的任务分解成一个个相对简单的子任务，直到细化为十分简单的基础操作，从而使代码的组织更加严密、更加有条理。然而，过多的函数调用也会导致额外的开销，影响程序的运行效率。\n\n某数据库应用程序提供了若干函数用以维护数据。已知这些函数的功能可分为三类：\n\n1. 将数据中的指定元素加上一个值；\n2. 将数据中的每一个元素乘以一个相同值；\n3. **依次**执行若干次函数调用，保证不会出现递归（即不会直接或间接地调用本身）。\n\n在使用该数据库应用时，用户可一次性输入要调用的函数序列（一个函数可能被调用多次），在**依次**执行完序列中的函数后，系统中的数据被加以更新。某一天，小 A 在应用该数据库程序处理数据时遇到了困难：由于频繁而低效的函数调用，系统在执行操作时进入了无响应的状态，他只好强制结束了数据库程序。为了计算出正确数据，小 A 查阅了软件的文档，了解到每个函数的具体功能信息，现在他想请你根据这些信息帮他计算出更新后的数据应该是多少。", "inputFormat": "第一行一个正整数 $n$，表示数据的个数。  \n第二行 $n$ 个整数，第 $i$ 个整数表示下标为 $i$ 的数据的初始值为 $a_i$。  \n第三行一个正整数 $m$，表示数据库应用程序提供的函数个数。函数从 $1 \\sim m$ 编号。  \n接下来 $m$ 行中，第 $j$（$1 \\le j \\le m$）行的第一个整数为 $T_j$，表示 $j$ 号函数的类型：\n\n1. 若 $T_j = 1$，接下来两个整数 $P_j, V_j$ 分别表示要执行加法的元素的下标及其增加的值；\n2. 若 $T_j = 2$，接下来一个整数 $V_j$ 表示所有元素所乘的值；\n3. 若 $T_j = 3$，接下来一个正整数 $C_j$ 表示 $j$ 号函数要调用的函数个数，  \n  随后 $C_j$ 个整数 $g^{(j)}_1, g^{(j)}_2, \\ldots , g^{(j)}_{C_j}$ 依次表示其所调用的函数的编号。\n\n第 $m + 4$ 行一个正整数 $Q$，表示输入的函数操作序列长度。  \n第 $m + 5$ 行 $Q$ 个整数 $f_i$，第 $i$ 个整数表示第 $i$ 个执行的函数的编号。", "outputFormat": "一行 $n$ 个用空格隔开的整数，按照下标 $1 \\sim n$ 的顺序，分别输出在执行完输入的函数序列后，数据库中每一个元素的值。**答案对** $\\boldsymbol{998244353}$ **取模。**", "hint": "**【样例 #1 解释】**\n\n$1$ 号函数功能为将 $a_1$ 的值加一。$2$ 号函数功能为所有元素乘 $2$。$3$ 号函数将先调用 $1$ 号函数，再调用 $2$ 号函数。\n\n最终的函数序列先执行 $2$ 号函数，所有元素的值变为 $2, 4, 6$。\n\n再执行 $3$ 号函数时，先调用 $1$ 号函数，所有元素的值变为 $3, 4, 6$。再调用 $2$ 号函数，所有元素的值变为 $6, 8, 12$。\n\n**【数据范围】**\n\n::cute-table{tuack}\n\n| 测试点编号 | $n, m, Q \\le$ | $\\sum C_j$ | 其他特殊限制 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1 \\sim 2$ | $1000$ | $= m - 1$ | 函数调用关系构成一棵树 |\n| $3 \\sim 4$ | $1000$ | $\\le 100$ | 无 |\n| $5 \\sim 6$ | $20000$ | $\\le 40000$ | 不含第 $2$ 类函数或不含第 $1$ 类函数 |\n| $7$ | $20000$ | $= 0$ | 无 |\n| $8 \\sim 9$ | $20000$ | $= m - 1$ | 函数调用关系构成一棵树 |\n| $10 \\sim 11$ | $20000$ | $\\le 2 \\times 10^5$ | 无 |\n| $12 \\sim 13$ | $10^5$ | $\\le 2 \\times 10^5$ | 不含第 $2$ 类函数或不含第 $1$ 类函数 |\n| $14$ | $10^5$ | $= 0$ | 无 |\n| $15 \\sim 16$ | $10^5$ | $= m - 1$ | 函数调用关系构成一棵树 |\n| $17 \\sim 18$ | $10^5$ | $\\le 5 \\times 10^5$ | 无 |\n| $19 \\sim 20$ | $10^5$ | $\\le 10^6$ | 无 |\n\n对于所有数据：$0 \\le a_i \\le 10^4$，$T_j \\in \\{1,2,3\\}$，$1 \\le P_j \\le n$，$0 \\le V_j \\le 10^4$，$1 \\le g^{(j)}_k \\le m$，$1 \\le f_i \\le m$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-S 2020] 函数调用", "background": "", "description": "函数是各种编程语言中一项重要的概念，借助函数，我们总可以将复杂的任务分解成一个个相对简单的子任务，直到细化为十分简单的基础操作，从而使代码的组织更加严密、更加有条理。然而，过多的函数调用也会导致额外的开销，影响程序的运行效率。\n\n某数据库应用程序提供了若干函数用以维护数据。已知这些函数的功能可分为三类：\n\n1. 将数据中的指定元素加上一个值；\n2. 将数据中的每一个元素乘以一个相同值；\n3. **依次**执行若干次函数调用，保证不会出现递归（即不会直接或间接地调用本身）。\n\n在使用该数据库应用时，用户可一次性输入要调用的函数序列（一个函数可能被调用多次），在**依次**执行完序列中的函数后，系统中的数据被加以更新。某一天，小 A 在应用该数据库程序处理数据时遇到了困难：由于频繁而低效的函数调用，系统在执行操作时进入了无响应的状态，他只好强制结束了数据库程序。为了计算出正确数据，小 A 查阅了软件的文档，了解到每个函数的具体功能信息，现在他想请你根据这些信息帮他计算出更新后的数据应该是多少。", "inputFormat": "第一行一个正整数 $n$，表示数据的个数。  \n第二行 $n$ 个整数，第 $i$ 个整数表示下标为 $i$ 的数据的初始值为 $a_i$。  \n第三行一个正整数 $m$，表示数据库应用程序提供的函数个数。函数从 $1 \\sim m$ 编号。  \n接下来 $m$ 行中，第 $j$（$1 \\le j \\le m$）行的第一个整数为 $T_j$，表示 $j$ 号函数的类型：\n\n1. 若 $T_j = 1$，接下来两个整数 $P_j, V_j$ 分别表示要执行加法的元素的下标及其增加的值；\n2. 若 $T_j = 2$，接下来一个整数 $V_j$ 表示所有元素所乘的值；\n3. 若 $T_j = 3$，接下来一个正整数 $C_j$ 表示 $j$ 号函数要调用的函数个数，  \n  随后 $C_j$ 个整数 $g^{(j)}_1, g^{(j)}_2, \\ldots , g^{(j)}_{C_j}$ 依次表示其所调用的函数的编号。\n\n第 $m + 4$ 行一个正整数 $Q$，表示输入的函数操作序列长度。  \n第 $m + 5$ 行 $Q$ 个整数 $f_i$，第 $i$ 个整数表示第 $i$ 个执行的函数的编号。", "outputFormat": "一行 $n$ 个用空格隔开的整数，按照下标 $1 \\sim n$ 的顺序，分别输出在执行完输入的函数序列后，数据库中每一个元素的值。**答案对** $\\boldsymbol{998244353}$ **取模。**", "hint": "**【样例 #1 解释】**\n\n$1$ 号函数功能为将 $a_1$ 的值加一。$2$ 号函数功能为所有元素乘 $2$。$3$ 号函数将先调用 $1$ 号函数，再调用 $2$ 号函数。\n\n最终的函数序列先执行 $2$ 号函数，所有元素的值变为 $2, 4, 6$。\n\n再执行 $3$ 号函数时，先调用 $1$ 号函数，所有元素的值变为 $3, 4, 6$。再调用 $2$ 号函数，所有元素的值变为 $6, 8, 12$。\n\n**【数据范围】**\n\n::cute-table{tuack}\n\n| 测试点编号 | $n, m, Q \\le$ | $\\sum C_j$ | 其他特殊限制 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1 \\sim 2$ | $1000$ | $= m - 1$ | 函数调用关系构成一棵树 |\n| $3 \\sim 4$ | $1000$ | $\\le 100$ | 无 |\n| $5 \\sim 6$ | $20000$ | $\\le 40000$ | 不含第 $2$ 类函数或不含第 $1$ 类函数 |\n| $7$ | $20000$ | $= 0$ | 无 |\n| $8 \\sim 9$ | $20000$ | $= m - 1$ | 函数调用关系构成一棵树 |\n| $10 \\sim 11$ | $20000$ | $\\le 2 \\times 10^5$ | 无 |\n| $12 \\sim 13$ | $10^5$ | $\\le 2 \\times 10^5$ | 不含第 $2$ 类函数或不含第 $1$ 类函数 |\n| $14$ | $10^5$ | $= 0$ | 无 |\n| $15 \\sim 16$ | $10^5$ | $= m - 1$ | 函数调用关系构成一棵树 |\n| $17 \\sim 18$ | $10^5$ | $\\le 5 \\times 10^5$ | 无 |\n| $19 \\sim 20$ | $10^5$ | $\\le 10^6$ | 无 |\n\n对于所有数据：$0 \\le a_i \\le 10^4$，$T_j \\in \\{1,2,3\\}$，$1 \\le P_j \\le n$，$0 \\le V_j \\le 10^4$，$1 \\le g^{(j)}_k \\le m$，$1 \\le f_i \\le m$。", "locale": "zh-CN"}}}
{"pid": "P7078", "type": "P", "difficulty": 7, "samples": [["2\n3\n11 14 14\n3\n1 5 2 6 3 25", "3\n1"], ["2\n5\n13 31 33 39 42\n5\n1 7 2 10 3 24 4 48 5 50", "5\n3"], ["见附件中的 snakes/snakes3.in", "见附件中的 snakes/snakes3.ans"], ["见附件中的 snakes/snakes4.in", "见附件中的 snakes/snakes4.ans"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "2020", "堆", "队列", "CSP-S 提高级"], "title": "[CSP-S 2020] 贪吃蛇", "background": "", "description": "草原上有 $n$ 条蛇，编号分别为 $1, 2, \\ldots , n$。初始时每条蛇有一个体力值 $a_i$，我们称编号为 $x$ 的蛇实力比编号为 $y$ 的蛇强当且仅当它们当前的体力值满足 $a_x > a_y$，或者 $a_x = a_y$ 且 $x > y$。\n\n接下来这些蛇将进行决斗，决斗将持续若干轮，每一轮实力最强的蛇拥有选择权，可以选择吃或者不吃掉实力最弱的蛇：\n\n1. 如果选择吃，那么实力最强的蛇的体力值将减去实力最弱的蛇的体力值，实力最弱的蛇被吃掉，退出接下来的决斗。之后开始下一轮决斗。\n2. 如果选择不吃，决斗立刻结束。\n\n每条蛇希望在自己不被吃的前提下在决斗中尽可能多吃别的蛇（显然，蛇不会选择吃自己）。\n\n现在假设每条蛇都足够聪明，请你求出决斗结束后会剩几条蛇。\n\n本题有多组数据，对于第一组数据，每条蛇体力会全部由输入给出，之后的每一组数据，会相对于上一组的数据，修改一部分蛇的体力作为新的输入。", "inputFormat": "第一行一个正整数 $T$，表示数据组数。  \n接下来有 $T$ 组数据，对于第一组数据，第一行一个正整数 $n$，第二行 $n$ 个非负整数表示 $a_i$。  \n对于第二组到第 $T$ 组数据，每组数据：  \n第一行第一个非负整数 $k$ 表示体力修改的蛇的个数。  \n第二行 $2k$ 个整数，每两个整数组成一个二元组 $(x,y)$，表示依次将 $a_x$ 的值改为 $y$。一个位置可能被修改多次，以最后一次修改为准。", "outputFormat": "输出 $T$ 行，每行一个整数表示最终存活的蛇的条数。", "hint": "**【样例 #1 解释】**\n\n第一组数据，第一轮中 $3$ 号蛇最强，$1$ 号蛇最弱。若 $3$ 号蛇选择吃，那么它将在第二轮被 $2$ 号蛇吃掉。因此 $3$ 号蛇第一轮选择不吃，$3$ 条蛇都将存活。\n\n对于第二组数据，$3$ 条蛇体力变为 $5, 6, 25$。第一轮中 $3$ 号蛇最强，$1$ 号蛇最弱，若它选择吃，那么 $3$ 号蛇体力值变为 $20$，在第二轮中依然是最强蛇并能吃掉 $2$ 号蛇，因此 $3$ 号蛇会选择两轮都吃，最终只有 $1$ 条蛇存活。\n\n**【数据范围】**\n\n对于 $20 \\%$ 的数据，$n = 3$。  \n对于 $40 \\%$ 的数据，$n \\le 10$。  \n对于 $55 \\%$ 的数据，$n \\le 2000$。  \n对于 $70\\%$ 的数据，$n \\le 5 \\times {10}^4$。  \n对于 $100\\%$ 的数据：$3 \\le n \\le {10}^6$，$1 \\le T \\le 10$，$0 \\le k \\le {10}^5$，$0 \\le a_i, y \\le 10^9$。保证每组数据（包括所有修改完成后的）的 $a_i$ 以不降顺序排列。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-S 2020] 贪吃蛇", "background": "", "description": "草原上有 $n$ 条蛇，编号分别为 $1, 2, \\ldots , n$。初始时每条蛇有一个体力值 $a_i$，我们称编号为 $x$ 的蛇实力比编号为 $y$ 的蛇强当且仅当它们当前的体力值满足 $a_x > a_y$，或者 $a_x = a_y$ 且 $x > y$。\n\n接下来这些蛇将进行决斗，决斗将持续若干轮，每一轮实力最强的蛇拥有选择权，可以选择吃或者不吃掉实力最弱的蛇：\n\n1. 如果选择吃，那么实力最强的蛇的体力值将减去实力最弱的蛇的体力值，实力最弱的蛇被吃掉，退出接下来的决斗。之后开始下一轮决斗。\n2. 如果选择不吃，决斗立刻结束。\n\n每条蛇希望在自己不被吃的前提下在决斗中尽可能多吃别的蛇（显然，蛇不会选择吃自己）。\n\n现在假设每条蛇都足够聪明，请你求出决斗结束后会剩几条蛇。\n\n本题有多组数据，对于第一组数据，每条蛇体力会全部由输入给出，之后的每一组数据，会相对于上一组的数据，修改一部分蛇的体力作为新的输入。", "inputFormat": "第一行一个正整数 $T$，表示数据组数。  \n接下来有 $T$ 组数据，对于第一组数据，第一行一个正整数 $n$，第二行 $n$ 个非负整数表示 $a_i$。  \n对于第二组到第 $T$ 组数据，每组数据：  \n第一行第一个非负整数 $k$ 表示体力修改的蛇的个数。  \n第二行 $2k$ 个整数，每两个整数组成一个二元组 $(x,y)$，表示依次将 $a_x$ 的值改为 $y$。一个位置可能被修改多次，以最后一次修改为准。", "outputFormat": "输出 $T$ 行，每行一个整数表示最终存活的蛇的条数。", "hint": "**【样例 #1 解释】**\n\n第一组数据，第一轮中 $3$ 号蛇最强，$1$ 号蛇最弱。若 $3$ 号蛇选择吃，那么它将在第二轮被 $2$ 号蛇吃掉。因此 $3$ 号蛇第一轮选择不吃，$3$ 条蛇都将存活。\n\n对于第二组数据，$3$ 条蛇体力变为 $5, 6, 25$。第一轮中 $3$ 号蛇最强，$1$ 号蛇最弱，若它选择吃，那么 $3$ 号蛇体力值变为 $20$，在第二轮中依然是最强蛇并能吃掉 $2$ 号蛇，因此 $3$ 号蛇会选择两轮都吃，最终只有 $1$ 条蛇存活。\n\n**【数据范围】**\n\n对于 $20 \\%$ 的数据，$n = 3$。  \n对于 $40 \\%$ 的数据，$n \\le 10$。  \n对于 $55 \\%$ 的数据，$n \\le 2000$。  \n对于 $70\\%$ 的数据，$n \\le 5 \\times {10}^4$。  \n对于 $100\\%$ 的数据：$3 \\le n \\le {10}^6$，$1 \\le T \\le 10$，$0 \\le k \\le {10}^5$，$0 \\le a_i, y \\le 10^9$。保证每组数据（包括所有修改完成后的）的 $a_i$ 以不降顺序排列。", "locale": "zh-CN"}}}
{"pid": "P7079", "type": "P", "difficulty": 2, "samples": [["12\nArrangement_of_Contest\nBallot_Analyzing_Device\nCorrecting_Curiosity\nDwarf_Tower\nEnergy_Tycoon\nFlight_Boarding_Optimization\nGarage\nHeavy_Chain_Clusterization\nIntellectual_Property\nJ\nKids_in_a_Friendly_Class\nLonely_Mountain\n", "12\n"], ["3\nSnow_White_and_the_7_Dwarfs\nA_Problem\nAnother_Problem\n", "1\n"], ["2\nGood_Problem\nBetter_Problem\n", "0\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "ICPC", "NWRRC"], "title": "[NWRRC 2013] Arrangement of Contest", "background": "", "description": "\n\nLittle Dmitry and little Petr want to arrange a contest. Their little friends submitted several task proposals and now Dmitry and Petr want to select some of them for the contest. As they are just little boys, they cannot estimate quality of tasks, but they know for sure that in good contest title of the first problem starts with A , the title of the second one -- with $B$ , and so on.\n\nGiven titles of the proposed tasks, help little brothers to determine the maximal number of problems in a good contest they can arrange.\n\n", "inputFormat": "\n\nThe first line contains single integer $n$ -- the number of problem proposals received by the little brothers $(1 \\le n \\le 100)$ .\n\nNext $n$ lines contain titles of proposed problems, one per line. The length of each title does not exceed $30$ characters. Each title starts with an uppercase letter and contains only English letters, digits and underscores.\n\n", "outputFormat": "\n\nOutput a single number -- the maximal number of problems in a good contest. In case there is no good contest that may be arranged, output $0$ .\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2013] Arrangement of Contest", "background": "", "description": "\n\nLittle Dmitry and little Petr want to arrange a contest. Their little friends submitted several task proposals and now Dmitry and Petr want to select some of them for the contest. As they are just little boys, they cannot estimate quality of tasks, but they know for sure that in good contest title of the first problem starts with A , the title of the second one -- with $B$ , and so on.\n\nGiven titles of the proposed tasks, help little brothers to determine the maximal number of problems in a good contest they can arrange.\n\n", "inputFormat": "\n\nThe first line contains single integer $n$ -- the number of problem proposals received by the little brothers $(1 \\le n \\le 100)$ .\n\nNext $n$ lines contain titles of proposed problems, one per line. The length of each title does not exceed $30$ characters. Each title starts with an uppercase letter and contains only English letters, digits and underscores.\n\n", "outputFormat": "\n\nOutput a single number -- the maximal number of problems in a good contest. In case there is no good contest that may be arranged, output $0$ .\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2013] Arrangement of Contest", "background": "", "description": "小D和小P想要举行比赛。\n\n他们收到了许多建议书，现在他们想要从这些报名书中挑选一些好的建议。\n\n他们采纳的建议符合以下标准：第一个建议的开头为A，第二个建议的开头为B，以此类推。\n\n请你帮助他们，确定他们所能采纳的建议的最大数量。", "inputFormat": "第一行，一个正整数 $n$，表示建议数。\n\n第 $2$ 至 $n+1$ 行，一行一个字符串，表示建议名称。", "outputFormat": "一个整数，表示他们所能采纳的建议的最大数量。", "hint": "对于 $100\\%$ 的数据，$1\\leq n \\leq 100$", "locale": "zh-CN"}}}
{"pid": "P7080", "type": "P", "difficulty": 2, "samples": [["4 7\nLoudy\nApples\nDogman\nMiller\n.X..\nX...\n....\n..X.\n..XX\n..X.\n..X.\n", "Dogman 42.86%\nLoudy 14.29%\nApples 14.29%\nMiller 0.00%\nInvalid 28.57%\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "ICPC", "NWRRC"], "title": "[NWRRC 2013] Ballot Analyzing Device", "background": "", "description": "\n\nElection committee of Flatland is preparing for presidential elections. To minimize human factor in ballot counting they decided to develop an automated Ballot Analyzing Device $(BAD).$\n\nThere are $n$ candidates running for president. The ballot contains one square field for each candidate. The voter must mark exactly one of the fields. If no field is marked or there are two or more marked fields, the ballot is invalid. Each voter puts $his/her$ ballot to a special scanner in BAD. The scanner analyzes marks on the ballot and creates a special voting string of $n$ characters: $‘X'$ for marked field and $‘. '$ for unmarked one. Now voting strings must be analyzed to get the report. Your task is to develop a report generator for BAD.\n\nGiven voting strings for all ballots, your program must print the voting report. Candidates in the report must be arranged in order of decreasing number of votes. If two candidates have the same number of votes, they must have the same order as in a voting ballot. For each candidate calculate $his/her$ result in percent (if the candidate received $p$ votes, the result in percent is $100p/m)$ . The last line of the report must indicate the percentage of the invalid ballots.\n\n", "inputFormat": "\n\nThe first line contains two integers $n$ and $m$ -- the number of candidates and the number of ballots $(2 \\le n \\le 10$ ; $1 \\le m \\le 1000)$ . The following $n$ lines contain last names of candidates. Each name is a string of at most $100$ English letters. There is no candidate named `Invalid`.\n\nThen $m$ lines follow, each of them contains one voting string.\n\n", "outputFormat": "\n\nPrint n+ $1$ lines. First print results for candidates in percent. For each candidate print $his/her$ last name followed by a space and then $his/her$ result in percent and a percent sign $‘\\%'.$ The last line must specify the percentage of invalid ballots: a word `Invalid` followed by a space, the percentage of invalid ballots and a percent sign.\n\nRound all numbers to exactly two digits after the decimal point. If the number is exactly in the middle of two representable numbers, output the greater one (e.g . output `12 . $35`$ for $12$ . $345$) .\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2013] Ballot Analyzing Device", "background": "", "description": "\n\nElection committee of Flatland is preparing for presidential elections. To minimize human factor in ballot counting they decided to develop an automated Ballot Analyzing Device $(BAD).$\n\nThere are $n$ candidates running for president. The ballot contains one square field for each candidate. The voter must mark exactly one of the fields. If no field is marked or there are two or more marked fields, the ballot is invalid. Each voter puts $his/her$ ballot to a special scanner in BAD. The scanner analyzes marks on the ballot and creates a special voting string of $n$ characters: $‘X'$ for marked field and $‘. '$ for unmarked one. Now voting strings must be analyzed to get the report. Your task is to develop a report generator for BAD.\n\nGiven voting strings for all ballots, your program must print the voting report. Candidates in the report must be arranged in order of decreasing number of votes. If two candidates have the same number of votes, they must have the same order as in a voting ballot. For each candidate calculate $his/her$ result in percent (if the candidate received $p$ votes, the result in percent is $100p/m)$ . The last line of the report must indicate the percentage of the invalid ballots.\n\n", "inputFormat": "\n\nThe first line contains two integers $n$ and $m$ -- the number of candidates and the number of ballots $(2 \\le n \\le 10$ ; $1 \\le m \\le 1000)$ . The following $n$ lines contain last names of candidates. Each name is a string of at most $100$ English letters. There is no candidate named `Invalid`.\n\nThen $m$ lines follow, each of them contains one voting string.\n\n", "outputFormat": "\n\nPrint n+ $1$ lines. First print results for candidates in percent. For each candidate print $his/her$ last name followed by a space and then $his/her$ result in percent and a percent sign $‘\\%'.$ The last line must specify the percentage of invalid ballots: a word `Invalid` followed by a space, the percentage of invalid ballots and a percent sign.\n\nRound all numbers to exactly two digits after the decimal point. If the number is exactly in the middle of two representable numbers, output the greater one (e.g . output `12 . $35`$ for $12$ . $345$) .\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2013] Ballot Analyzing Device", "background": "", "description": "平地的选举委员会正在为总统选举做准备。为了尽量减少人工因素在选票计数中的影响，他们决定开发一个自动化的选票分析设备（BAD）。\n\n有 $n$ 名候选人竞选总统。选票上为每位候选人提供一个方框。选民必须在其中一个方框上做标记。如果没有标记任何方框或标记了两个或更多方框，则选票无效。每位选民将他的选票放入 BAD 的特殊扫描仪中。扫描仪分析选票上的标记并生成一个包含 $n$ 个字符的特殊投票字符串：标记的方框用 'X' 表示，未标记的用 '.' 表示。现在需要分析投票字符串以生成报告。你的任务是为 BAD 开发一个报告生成器。\n\n给定所有选票的投票字符串，你的程序必须打印投票报告。报告中的候选人必须按得票数降序排列。如果两名候选人的得票数相同，他们在投票选票中的顺序也必须相同。对于每位候选人，计算他/她的得票百分比（如果候选人获得 $p$ 票，百分比结果为 $100p/m$）。报告的最后一行必须指明无效选票的百分比。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$ —— 候选人数和选票数（$2 \\le n \\le 10$；$1 \\le m \\le 1000$）。接下来的 $n$ 行包含候选人的姓氏。每个名字是一个最多由 100 个英文字符组成的字符串。没有候选人名为 `Invalid`。\n\n接下来是 $m$ 行，每行包含一个投票字符串。", "outputFormat": "打印 $n+1$ 行。首先打印候选人的百分比结果。对于每位候选人，打印他/她的姓氏，后跟一个空格，然后是他/她的百分比结果和一个百分号 '% '。最后一行必须指定无效选票的百分比：一个单词 `Invalid` 后跟一个空格，无效选票的百分比和一个百分号。\n\n将所有数字四舍五入到小数点后两位。如果数字正好在两个可表示数字的中间，输出较大的一个（例如，对于 $12.345$ 输出 `12.35`）。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7081", "type": "P", "difficulty": 6, "samples": [["move left, move right; move up\nmove left, move down, move up\n", "s/right;/down,/g\n"], ["If not found: move x; else move -x\nIf found: move x; else move -x\n", "s/ not//g\n"], ["abababa\ncbc\n", "s/aba/c/g\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2013] Correcting Curiosity", "background": "", "description": "\n\nCuriosity is the rover that explores the Gale Crater on Mars. Recently it found an evidence of water in Martian soil, which will make it easier to plan the future manned missions. $ $\n\nCuriosity can communicate with Earth directly at speeds up to $32 Kbit/s$ , but on average $14$ minutes and $6$ seconds will be required for signals to travel between Earth and Mars.\n\n`You have just seen a stone and applied brakes, but you know that the rover is already passing that stone` -- Matt Heverly, the rover's driver, explains. `So we just plan the route, then write down a list of simple textual commands: move one meter ahead, turn left, make a photo and so on`.\n\nSometimes it is necessary to react very fast to some unexpected events. For example, if the cameras have seen something interesting, then you might want to change the route of the rover to make an additional photo. To do that, you send a substitution command of the form $s/〈string〉/〈replacement〉/g$ . This replaces all occurrences of $〈string〉,$ starting with the leftmost one, to $〈replacement〉.$\n\nMore formally, if A is a non-empty string and $B$ is a string, then to apply the substitution command $s/A/B/g$ to a string $S$ , you should do the following:\n\nFind the leftmost occurrence of A in $S$ , such that $S =$ SL $+$ A $+$ SR.\n\nIf there is no such occurrence, stop. Then, $S$ is the answer.\n\nLet $R$ be the result of applying $s/A/B/g$ to SR.\n\nThe answer is SL $+ B + R$ .\n\nThis means that:\n\nIf there are two overlapping occurrences of A in $S$ , only the leftmost one is replaced. For example, applying $`s/aba/c/g`$ to `abababa` yields `cbc`: after replacing the first occurrence of `aba` the string turns to `cbaba`, and only the last occurrence of `aba` can be replaced after that.\n\nNo substitution uses the results of previous substitutions. For example, applying $`s/a/ab/g`$ to `a` yields `ab`, applying $`s/a/ba/g`$ to `a` yields `ba`.\n\nYou know that the longer is the command, the bigger is the time necessary to transmit it. So, you have to write a program that finds shortest command that transforms the initial string to the final string.\n\n", "inputFormat": "\n\nThe first line contains the initial and the final strings. Both strings are non-empty and their lengths do not exceed $2000$ characters. The strings contain only English letters, spaces and punctuation signs (commas, colons, semicolons and hyphens: $‘,', ‘:', ‘;', ‘-').$ The given strings are not equal.\n\n", "outputFormat": "\n\nOutput the substitution command that transforms initial string to final string and has the minimum length. If there are several shortest substitution commands, output any of them.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2013] Correcting Curiosity", "background": "", "description": "\n\nCuriosity is the rover that explores the Gale Crater on Mars. Recently it found an evidence of water in Martian soil, which will make it easier to plan the future manned missions. $ $\n\nCuriosity can communicate with Earth directly at speeds up to $32 Kbit/s$ , but on average $14$ minutes and $6$ seconds will be required for signals to travel between Earth and Mars.\n\n`You have just seen a stone and applied brakes, but you know that the rover is already passing that stone` -- Matt Heverly, the rover's driver, explains. `So we just plan the route, then write down a list of simple textual commands: move one meter ahead, turn left, make a photo and so on`.\n\nSometimes it is necessary to react very fast to some unexpected events. For example, if the cameras have seen something interesting, then you might want to change the route of the rover to make an additional photo. To do that, you send a substitution command of the form $s/〈string〉/〈replacement〉/g$ . This replaces all occurrences of $〈string〉,$ starting with the leftmost one, to $〈replacement〉.$\n\nMore formally, if A is a non-empty string and $B$ is a string, then to apply the substitution command $s/A/B/g$ to a string $S$ , you should do the following:\n\nFind the leftmost occurrence of A in $S$ , such that $S =$ SL $+$ A $+$ SR.\n\nIf there is no such occurrence, stop. Then, $S$ is the answer.\n\nLet $R$ be the result of applying $s/A/B/g$ to SR.\n\nThe answer is SL $+ B + R$ .\n\nThis means that:\n\nIf there are two overlapping occurrences of A in $S$ , only the leftmost one is replaced. For example, applying $`s/aba/c/g`$ to `abababa` yields `cbc`: after replacing the first occurrence of `aba` the string turns to `cbaba`, and only the last occurrence of `aba` can be replaced after that.\n\nNo substitution uses the results of previous substitutions. For example, applying $`s/a/ab/g`$ to `a` yields `ab`, applying $`s/a/ba/g`$ to `a` yields `ba`.\n\nYou know that the longer is the command, the bigger is the time necessary to transmit it. So, you have to write a program that finds shortest command that transforms the initial string to the final string.\n\n", "inputFormat": "\n\nThe first line contains the initial and the final strings. Both strings are non-empty and their lengths do not exceed $2000$ characters. The strings contain only English letters, spaces and punctuation signs (commas, colons, semicolons and hyphens: $‘,', ‘:', ‘;', ‘-').$ The given strings are not equal.\n\n", "outputFormat": "\n\nOutput the substitution command that transforms initial string to final string and has the minimum length. If there are several shortest substitution commands, output any of them.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2013] Correcting Curiosity", "background": "", "description": "# [NWRRC2013] Correcting Curiosity\n\n\n“好奇号”是探索火星上盖尔陨石坑的火星车。最近，它在火星土壤中发现了水存在的证据，这将使未来的火星登陆任务变得更加容易。$ $\n\n“好奇号”可以用高达$32 Kbit/s$的速度与地球直接通信 ，但在地球和火星之间传输信号分别平均需要$14$秒和$6$秒。\n\n`你刚刚看到一块石头并踩下了刹车，但你知道火星车已经经过那块石头了` -- 火星车司机Matt Heverly解释道。`所以我们需要规划路线，然后写下一个简单的命令列表：如向前移动一米，左转，拍照等等`.\n\n有时你有必要对一些突发事件做出非常迅速的反应。例如，当相机看到了一些有趣的东西，那么你可能会想改变火星车的路线来拍摄的照片。为此，您需要发送一个形式为 $s/〈string〉/〈replacement〉/g$ . 这将替换所有出现的 $〈string〉,$ 从最左边的开始, 到 $〈replacement〉.$\n\n更确切地说，如果A是非空字符串，而$B$是字符串, 则要将替换命令$s/A/B/g$应用于字符串$s$，执行以下操作：\n\n在$S$中查找最左边出现的A，这样$S=$SL$+$A$+$SR。\n\n如果没有A，请停止操作。$S$就是答案。\n\n让$R$成为对SR应用$s/A/B/g$的结果。\n\n那么答案是SL$+B+R$。\n\n这就说明:\n\n如果在$S$中有两个重叠的A，那么只替换最左边的一个。例如，将$`s/aba/c/g`$应用于`abababa`会产生`cbc`：在替换第一个`aba `之后，字符串将变为`cbaba `，在此之后只能替换最后一个出现的` aba `。\n\n如果没有替换就使用先前替换的结果。例如，将$`s/a/ab/g`$应用于`a`产生`ab`，将$`s/s/a/ba/g`$应用于`a`产生`ba`。\n\n命令越长，传输它所需的时间就越长。因此，需要你编写一个程序，找到最短的命令，将初始字符串转换为最终字符串。", "inputFormat": "第一行输入包含初始字符串和最终字符串。这两个字符串都不是空的，并且它们的长度不超过$2000$。字符串仅包含英文字母、空格和标点符号（逗号、冒号、分号和连字符：$'，'，'：'，'；'，'-'）。$给定的字符串不相同。", "outputFormat": "输出将初始字符串转换为最终字符串并最短的替换命令。如果有多个最短的替换命令，请输出其中任何一个。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\nmove left, move right; move up\nmove left, move down, move up\n```\n\n### 样例输出 #1\n\n```\ns/right;/down,/g\n```\n\n## 样例 #2\n\n### 样例输入 #2\n\n```\nIf not found: move x; else move -x\nIf found: move x; else move -x\n```\n\n### 样例输出 #2\n\n```\ns/ not//g\n```\n\n## 样例 #3\n\n### 样例输入 #3\n\n```\nabababa\ncbc\n```\n\n### 样例输出 #3\n\n```\ns/aba/c/g\n```", "hint": "时间限制: 2 s, 内存限制: 256 MB.", "locale": "zh-CN"}}}
{"pid": "P7082", "type": "P", "difficulty": 5, "samples": [["5 3\n5 0 1 2 5\n5 2 3\n4 2 3\n1 4 5\n", "2\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "ICPC", "NWRRC"], "title": "[NWRRC 2013] Dwarf Tower", "background": "", "description": "Little Vasya is playing a new game named \"Dwarf Tower\". In this game there are $n$ different items, which you can put on your dwarf character. Items are numbered from $1$ to $n$ . Vasya wants to get the item with number $1$ .\n\nThere are two ways to obtain an item:\n\nYou can buy an item. The i-th item costs $c_i$ money.\n\nYou can craft an item. This game supports only $m$ types of crafting. To craft an item, you give two particular different items and get another one as a result.\n\nHelp Vasya to spend the least amount of money to get the item number $1$ .\n", "inputFormat": "The first line contains two integers $n$ and $m (1 \\le n \\le 10000 , 0 \\le m \\le 100000) -$ the number of different items and the number of crafting types.\n\nThe second line contains $n$ integers $c_i -$ values of the items $(0 \\le c_i \\le 10^9)$ .\n\nThe following $m$ lines describe crafting types, each line contains three distinct integers $a_i, x_i, y_i$ -- $a_i$ is the item that can be crafted from items $x_i$ and $y_i (1 \\le  a_i, x_i, y_i \\le n , a_i \\ne x_i, x_i \\ne y_i, y_i \\ne a_i)$.", "outputFormat": "\nPrint a single integer -- the least amount of money to spend. ", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2013] Dwarf Tower", "background": "", "description": "Little Vasya is playing a new game named \"Dwarf Tower\". In this game there are $n$ different items, which you can put on your dwarf character. Items are numbered from $1$ to $n$ . Vasya wants to get the item with number $1$ .\n\nThere are two ways to obtain an item:\n\nYou can buy an item. The i-th item costs $c_i$ money.\n\nYou can craft an item. This game supports only $m$ types of crafting. To craft an item, you give two particular different items and get another one as a result.\n\nHelp Vasya to spend the least amount of money to get the item number $1$ .\n", "inputFormat": "The first line contains two integers $n$ and $m (1 \\le n \\le 10000 , 0 \\le m \\le 100000) -$ the number of different items and the number of crafting types.\n\nThe second line contains $n$ integers $c_i -$ values of the items $(0 \\le c_i \\le 10^9)$ .\n\nThe following $m$ lines describe crafting types, each line contains three distinct integers $a_i, x_i, y_i$ -- $a_i$ is the item that can be crafted from items $x_i$ and $y_i (1 \\le  a_i, x_i, y_i \\le n , a_i \\ne x_i, x_i \\ne y_i, y_i \\ne a_i)$.", "outputFormat": "\nPrint a single integer -- the least amount of money to spend. ", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2013] Dwarf Tower", "background": null, "description": "小 Vasya 在玩一个新游戏叫做 Dwarf Tower。在这个游戏中有 $n$ 个不同的衣物给你的矮人。衣物从 $1$ 到 $n$ 进行编号。Vasya 想要获得编号为 $1$ 的衣物。\n\n现在有两种方法获得一件衣物：\n\n1. 你可以买它，第 $i$ 件物品花费 $c_i$ 元。\n\n1. 你还可以制作它，这个游戏支持 $m$ 种制作方法。要制作一个衣物，你需要花费两个特定的衣物。\n\n算出 Vasya 至少需要多少钱来获得一号衣物。", "inputFormat": "第一行输入两个整数 $n$ , $m$ $(1 \\le n \\le 10000 , 0 \\le m \\le 100000) $ 代表有 $n$ 种衣物和有 $m$ 种制作方法。\n\n第二行输入 $n$ 个整数，第 $i$ 个整数代表 $c_i$ $(0 \\le c_i \\le 10^9)$ 。\n\n接下来 $m$ 行每行有三个整数 $a_i, x_i, y_i$ $(1 \\le a_i, x_i, y_i \\le n , a_i \\ne x_i, x_i \\ne y_i, y_i \\ne a_i)$ ，$a_i$ 代表 $a_i$ 可以被 $x_i$ 和 $y_i$ 制作。", "outputFormat": "一个整数，代表 Vasya 至少需要多少钱来获得一号衣物。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P7083", "type": "P", "difficulty": 2, "samples": [["3\n21121\n", "10\n"], ["2\n12\n", "2\n"], ["2\n211\n", "4\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "ICPC", "NWRRC"], "title": "[NWRRC 2013] Energy Tycoon", "background": "", "description": "\n\nLittle Vasya is playing a new computer game -- turn-based strategy `Energy Tycoon`.\n\nThe rules of the game are quite simple:\n\nThe board contains $n$ slots arranged in a line.\n\nThere are power plants, one power plant occupies one or two consecutive slots, and produces one unit of energy.\n\nEach turn the game allows you to build one new power plant, you can put it on the board if you wish. If there is no place for the new power plant, you can remove some older power plants.\n\nAfter each turn, the computer counts the amount of energy produced by the power plants on the board and adds it to the total score.\n\n![](/upload/images2/enegrgytycoon.png)\n\nVasya already knows the types of power plant he will be able to build each turn. Now he wants to know, what the maximum possible score he can get is. Can you help him?\n\n", "inputFormat": "\n\nThe first line of the input contains one integer $n (1 \\le n \\le 100 000)$ -- the number of slots on the board. The second line contains the string $s$ . The i-th character of the string is $1$ if you can build one-slot power plant at the i-th turn and the character is $2$ if you can build two-slot power plant at the i-th turn. The number of turns does not exceed $100 000$ .\n\n", "outputFormat": "\n\nThe output should contain a single integer -- the maximal score that can be achieved.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2013] Energy Tycoon", "background": "", "description": "\n\nLittle Vasya is playing a new computer game -- turn-based strategy `Energy Tycoon`.\n\nThe rules of the game are quite simple:\n\nThe board contains $n$ slots arranged in a line.\n\nThere are power plants, one power plant occupies one or two consecutive slots, and produces one unit of energy.\n\nEach turn the game allows you to build one new power plant, you can put it on the board if you wish. If there is no place for the new power plant, you can remove some older power plants.\n\nAfter each turn, the computer counts the amount of energy produced by the power plants on the board and adds it to the total score.\n\n![](/upload/images2/enegrgytycoon.png)\n\nVasya already knows the types of power plant he will be able to build each turn. Now he wants to know, what the maximum possible score he can get is. Can you help him?\n\n", "inputFormat": "\n\nThe first line of the input contains one integer $n (1 \\le n \\le 100 000)$ -- the number of slots on the board. The second line contains the string $s$ . The i-th character of the string is $1$ if you can build one-slot power plant at the i-th turn and the character is $2$ if you can build two-slot power plant at the i-th turn. The number of turns does not exceed $100 000$ .\n\n", "outputFormat": "\n\nThe output should contain a single integer -- the maximal score that can be achieved.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2013] Energy Tycoon", "background": "", "description": "小 Vasya 正在玩一个新的电脑游戏——回合制策略游戏 `Energy Tycoon`。\n\n游戏的规则很简单：\n\n棋盘上有 $n$ 个槽位排成一行。\n\n有发电厂，一个发电厂占据一个或两个连续的槽位，并产生一个单位的能量。\n\n每回合游戏允许你建造一个新的发电厂，如果你愿意可以将其放在棋盘上。如果没有地方放新的发电厂，你可以移除一些旧的发电厂。\n\n每回合结束后，计算机会计算棋盘上发电厂产生的能量总量并将其加到总分中。\n\nVasya 已经知道他每回合可以建造的发电厂类型。现在他想知道，他能获得的最大可能分数是多少。你能帮助他吗？", "inputFormat": "输入的第一行包含一个整数 $n (1 \\le n \\le 100 000)$ —— 棋盘上的槽位数。第二行包含字符串 $s$。字符串的第 $i$ 个字符是 $1$ 表示你可以在第 $i$ 回合建造一个占一个槽位的发电厂，字符是 $2$ 表示你可以在第 $i$ 回合建造一个占两个槽位的发电厂。回合数不超过 $100 000$。", "outputFormat": "输出应包含一个整数 —— 可以达到的最大分数。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7084", "type": "P", "difficulty": 3, "samples": [["10 12 2\n6 4 2 5 2 3 1 11 8 5\n", "6\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "ICPC", "NWRRC"], "title": "[NWRRC 2013] Flight Boarding Optimization", "background": "", "description": "\n\nPeter is an executive boarding manager in Byteland airport. His job is to optimize the boarding process. The planes in Byteland have $s$ rows, numbered from $1$ to $s$ . Every row has six seats, labeled A to $F$ .\n\n![](/upload/images2/flgithseat.png)\n\nThere are $n$ passengers, they form a queue and board the plane one by one. If the i-th passenger sits in a row $r_{i}$ then the difficulty of boarding for him is equal to the number of passengers boarded before him and sit in rows $1$ . . . $r_{i}−1$ . The total difficulty of the boarding is the sum of difficulties for all passengers. For example, if there are ten passengers, and their seats are $6A, 4B, 2E, 5F, 2A, 3F, 1C, 10E, 8B, 5A,$ in the queue order, then the difficulties of their boarding are $0 , 0 , 0 , 2 , 0 , 2 , 0 , 7 , 7 , 5$ , and the total difficulty is $23$ .\n\nTo optimize the boarding, Peter wants to divide the plane into $k$ zones. Every zone must be a continuous range of rows. Than the boarding process is performed in $k$ phases. On every phase, one zone is selected and passengers whose seats are in this zone are boarding in the order they were in the initial queue. $ $\n\nIn the example above, if we divide the plane into two zones: rows $5-10$ and rows $1-4$ , then during the first phase the passengers will take seats $6A, 5F, 10E, 8B, 5A,$ and during the second phase the passengers will take seats $4B, 2E, 2A, 3F, 1C,$ in this order. The total difficulty of the boarding will be $6$ .\n\nHelp Peter to find the division of the plane into $k$ zones which minimizes the total difficulty of the boarding, given a specific queue of passengers.\n\n", "inputFormat": "\n\nThe first line contains three integers $n (1 \\le n \\le 1000) , s (1 \\le s \\le 1000)$ , and $k (1 \\le k \\le 50$ ; $k \\le s)$ . The next line contains $n$ integers $r_{i} (1 \\le r_{i} \\le s)$ .\n\nEach row is occupied by at most $6$ passengers.\n\n", "outputFormat": "\n\nOutput one number, the minimal possible difficulty of the boarding.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2013] Flight Boarding Optimization", "background": "", "description": "\n\nPeter is an executive boarding manager in Byteland airport. His job is to optimize the boarding process. The planes in Byteland have $s$ rows, numbered from $1$ to $s$ . Every row has six seats, labeled A to $F$ .\n\n![](/upload/images2/flgithseat.png)\n\nThere are $n$ passengers, they form a queue and board the plane one by one. If the i-th passenger sits in a row $r_{i}$ then the difficulty of boarding for him is equal to the number of passengers boarded before him and sit in rows $1$ . . . $r_{i}−1$ . The total difficulty of the boarding is the sum of difficulties for all passengers. For example, if there are ten passengers, and their seats are $6A, 4B, 2E, 5F, 2A, 3F, 1C, 10E, 8B, 5A,$ in the queue order, then the difficulties of their boarding are $0 , 0 , 0 , 2 , 0 , 2 , 0 , 7 , 7 , 5$ , and the total difficulty is $23$ .\n\nTo optimize the boarding, Peter wants to divide the plane into $k$ zones. Every zone must be a continuous range of rows. Than the boarding process is performed in $k$ phases. On every phase, one zone is selected and passengers whose seats are in this zone are boarding in the order they were in the initial queue. $ $\n\nIn the example above, if we divide the plane into two zones: rows $5-10$ and rows $1-4$ , then during the first phase the passengers will take seats $6A, 5F, 10E, 8B, 5A,$ and during the second phase the passengers will take seats $4B, 2E, 2A, 3F, 1C,$ in this order. The total difficulty of the boarding will be $6$ .\n\nHelp Peter to find the division of the plane into $k$ zones which minimizes the total difficulty of the boarding, given a specific queue of passengers.\n\n", "inputFormat": "\n\nThe first line contains three integers $n (1 \\le n \\le 1000) , s (1 \\le s \\le 1000)$ , and $k (1 \\le k \\le 50$ ; $k \\le s)$ . The next line contains $n$ integers $r_{i} (1 \\le r_{i} \\le s)$ .\n\nEach row is occupied by at most $6$ passengers.\n\n", "outputFormat": "\n\nOutput one number, the minimal possible difficulty of the boarding.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2013] Flight Boarding Optimization", "background": "", "description": "Peter是 Byteland 机场的高级登机管理人员。他的工作是优化登机流程。Byteland 中的飞机有$s$行，编号从1到$s$。每排有六个座位，标有$A$到$F$。\n\n有$n$名乘客，他们排成一队，一个接一个地登上飞机。如果第$i$位乘客坐在第$r_i$排，那么，他登机的难度等于在他前面登机的并且坐在第1......$r_i$ $-$1排的乘客人数之和。\n\n\n\n登机的总难度是所有乘客的登机难度之和。例如，如果有十名乘客，他们的座位分别是$6A、4B、2E、5F、2A、3F、1C、10E、8B、5A$，按照排队顺序排列，那么他们登机的难度分别是$0、0、0、2、0、2、0、7、7、5$，总难度是$23$。\n\n为了优化登机，Peter希望将飞机划分成$k$个区域。每个分区都必须是连续的行数。然后分成$k$段执行登机流程。在每个阶段，选择一个区域，座位在该区域的乘客将按照他们在初始队列中的顺序登机。\n\n在上面的示例中，如果我们将平面划分为两个区域：第 $5-10$ 行和第$1-4$ 行，则在第一阶段，乘客将依次就座$6A、5F、10E、8B、5A$。在第二阶段，乘客将依次就座$4B、2E、2A、3F、1C$。登机的总难度为$6$。\n\n帮助Peter找到将飞机划分为$k$个区域的方法，在给定特定乘客队列的情况下，将登机的总难度降至最低。", "inputFormat": "第一行包括三个整数$n(1≤n≤1000)$,$s(1≤s≤1000)$和$k(1≤k≤1000)$\n\n第二行包括$n$个整数$r_i(1≤r_i≤s)$", "outputFormat": "输出一行一个数，最小的登机总难度", "hint": "", "locale": "zh-CN"}}}
{"pid": "P7085", "type": "P", "difficulty": 2, "samples": [["11 4 3 2\n", "2\n"], ["10 8 3 4\n", "2\n"], ["15 7 4 2\n", "4\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "ICPC", "NWRRC"], "title": "[NWRRC 2013] Garage", "background": "", "description": "\n\nWow! What a lucky day! Your company has just won a social contract for building a garage complex. Almost all formalities are done: contract payment is already transferred to your account.\n\nSo now it is the right time to read the contract. Okay, there is a sandlot in the form of $W \\times H$ rectangle and you have to place some garages there. Garages are $w \\times h$ rectangles and their edges must be parallel to the corresponding edges of the sandlot (you may not rotate garages, even by $90^{◦}).$ The coordinates of garages may be non-integer.\n\nYou know that the economy must be economical, so you decided to place as few garages as possible. Unfortunately, there is an opposite requirement in the contract: placing maximum possible number of garages.\n\nNow let's see how these requirements are checked. . . The plan is accepted if it is impossible to add a new garage without moving the other garages (the new garage must also have edges parallel to corresponding sandlot edges).\n\n![](https://www.acmicpc.net/upload/images2/garage.png)\n\nTime is money, find the minimal number of garages that must be ordered, so that you can place them on the sandlot and there is no place for an extra garage.\n\n", "inputFormat": "\n\nThe only line contains four integers: $W , H , w , h$ -- dimensions of sandlot and garage in meters. You may assume that $1 \\le w \\le W \\le 30 000$ and $1 \\le h \\le H \\le 30 000$ .\n\n", "outputFormat": "\n\nOutput the optimal number of garages.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2013] Garage", "background": "", "description": "\n\nWow! What a lucky day! Your company has just won a social contract for building a garage complex. Almost all formalities are done: contract payment is already transferred to your account.\n\nSo now it is the right time to read the contract. Okay, there is a sandlot in the form of $W \\times H$ rectangle and you have to place some garages there. Garages are $w \\times h$ rectangles and their edges must be parallel to the corresponding edges of the sandlot (you may not rotate garages, even by $90^{◦}).$ The coordinates of garages may be non-integer.\n\nYou know that the economy must be economical, so you decided to place as few garages as possible. Unfortunately, there is an opposite requirement in the contract: placing maximum possible number of garages.\n\nNow let's see how these requirements are checked. . . The plan is accepted if it is impossible to add a new garage without moving the other garages (the new garage must also have edges parallel to corresponding sandlot edges).\n\n![](https://www.acmicpc.net/upload/images2/garage.png)\n\nTime is money, find the minimal number of garages that must be ordered, so that you can place them on the sandlot and there is no place for an extra garage.\n\n", "inputFormat": "\n\nThe only line contains four integers: $W , H , w , h$ -- dimensions of sandlot and garage in meters. You may assume that $1 \\le w \\le W \\le 30 000$ and $1 \\le h \\le H \\le 30 000$ .\n\n", "outputFormat": "\n\nOutput the optimal number of garages.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2013] Garage", "background": "", "description": "哇！多么幸运的一天！你的公司刚刚赢得了一个建造车库综合体的社会合同。几乎所有的手续都已完成：合同款项已经转入你的账户。\n\n所以现在是阅读合同的好时机。好的，有一个 $W \\times H$ 的矩形沙地，你需要在那里放置一些车库。车库是 $w \\times h$ 的矩形，并且它们的边必须与沙地的对应边平行（你不能旋转车库，即使是 $90^{\\circ}$）。车库的坐标可以是非整数。\n\n你知道经济必须是经济的，所以你决定尽可能少地放置车库。不幸的是，合同中有一个相反的要求：放置尽可能多的车库。\n\n现在让我们看看这些要求是如何被检查的……计划被接受的条件是：如果不移动其他车库，就不可能再添加一个新的车库（新车库的边也必须与沙地的对应边平行）。\n\n时间就是金钱，找出必须订购的最少车库数量，以便你可以将它们放置在沙地上，并且没有多余车库的空间。", "inputFormat": "唯一的一行包含四个整数：$W , H , w , h$ —— 沙地和车库的尺寸，单位为米。你可以假设 $1 \\le w \\le W \\le 30 000$ 且 $1 \\le h \\le H \\le 30 000$。", "outputFormat": "输出最优的车库数量。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7086", "type": "P", "difficulty": 6, "samples": [["4 1\nAA\nAB\nBB\nBA\n", "2\n2 1 2\n2 3 4\n"], ["3 2\nABA\nBAB\nXY\n", "3\n1 1\n1 2\n1 3\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2013] Heavy Chain Clusterization", "background": "", "description": "\n\nA group of biologists is trying to find a cure for a viral disease. They have tried many antibodies of various origins that could potentially fight the viral antigens, and have selected $n$ antibodies that seem to work best during experiments.\n\nEach antibody is identified by its heavy chain -- a sequence of amino acids.\n\nThe set of antibodies form a similarity cluster, if at least one of the following holds:\n\nk-prefixes (first $k$ amino acids) of all their heavy chains are equal;\n\nk-suffixes (last $k$ amino acids) of all their heavy chains are equal.\n\nIn order to simplify the future research, biologists want to group antibodies to similarity clusters.\n\nYou need to split the given antibodies to a minimum number of similarity clusters.\n\n", "inputFormat": "\n\nThe first line contains two integers $n$ and $k$ -- the number of heavy chains and the length of sequence of amino acids to coincide $(1 \\le n \\le 5 000 , 1 \\le k \\le 550)$ .\n\nThe following $n$ lines contain sequences of amino acids that form heavy chains of antibodies. Each amino acid described with an uppercase English letter. Each heavy chain contains at least $k$ and no more than $550$ amino acids.\n\n", "outputFormat": "\n\nThe first line of output must contain a single integer -- the minimum number of similarity clusters. The following lines must contain descriptions of clusters, one per line.\n\nEach description starts with $m_i$ -- the number of antibodies in the cluster and is followed by $m_i$ integers -- numbers of these antibodies. Antibodies are numbered in the order of appearance in the input starting from one.\n\nEach antibody must be present in exactly one cluster.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2013] Heavy Chain Clusterization", "background": "", "description": "\n\nA group of biologists is trying to find a cure for a viral disease. They have tried many antibodies of various origins that could potentially fight the viral antigens, and have selected $n$ antibodies that seem to work best during experiments.\n\nEach antibody is identified by its heavy chain -- a sequence of amino acids.\n\nThe set of antibodies form a similarity cluster, if at least one of the following holds:\n\nk-prefixes (first $k$ amino acids) of all their heavy chains are equal;\n\nk-suffixes (last $k$ amino acids) of all their heavy chains are equal.\n\nIn order to simplify the future research, biologists want to group antibodies to similarity clusters.\n\nYou need to split the given antibodies to a minimum number of similarity clusters.\n\n", "inputFormat": "\n\nThe first line contains two integers $n$ and $k$ -- the number of heavy chains and the length of sequence of amino acids to coincide $(1 \\le n \\le 5 000 , 1 \\le k \\le 550)$ .\n\nThe following $n$ lines contain sequences of amino acids that form heavy chains of antibodies. Each amino acid described with an uppercase English letter. Each heavy chain contains at least $k$ and no more than $550$ amino acids.\n\n", "outputFormat": "\n\nThe first line of output must contain a single integer -- the minimum number of similarity clusters. The following lines must contain descriptions of clusters, one per line.\n\nEach description starts with $m_i$ -- the number of antibodies in the cluster and is followed by $m_i$ integers -- numbers of these antibodies. Antibodies are numbered in the order of appearance in the input starting from one.\n\nEach antibody must be present in exactly one cluster.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2013] Heavy Chain Clusterization", "background": "", "description": "一组生物学家正在寻找一种治疗病毒性疾病的方法。他们尝试了多种可能对抗病毒抗原的抗体，并选出了在实验中效果最好的 $n$ 种抗体。  \n\n每种抗体通过其重链（由氨基酸序列组成）进行识别。  \n\n如果满足以下至少一个条件，则这些抗体形成一个相似簇：  \n\n- 所有重链的 k 前缀（前 $k$ 个氨基酸）相同；  \n- 所有重链的 k 后缀（后 $k$ 个氨基酸）相同。  \n\n为了简化未来的研究，生物学家希望将抗体分组为相似簇。  \n\n你需要将给定的抗体划分为最少数量的相似簇。", "inputFormat": "第一行包含两个整数 $n$ 和 $k$ —— 重链的数量和需要一致的氨基酸序列的长度 $(1 \\le n \\le 5 000 , 1 \\le k \\le 550)$。  \n\n接下来的 $n$ 行包含形成抗体重链的氨基酸序列。每个氨基酸用一个大写的英文字母描述。每个重链至少包含 $k$ 个氨基酸，最多不超过 $550$ 个氨基酸。", "outputFormat": "输出的第一行必须包含一个整数 —— 最小的相似簇数量。接下来的行必须包含簇的描述，每行一个。  \n\n每个描述以 $m_i$ 开头 —— 簇中抗体的数量，接下来是 $m_i$ 个整数 —— 这些抗体的编号。抗体按照输入中出现的顺序编号，从 1 开始。  \n\n每个抗体必须恰好出现在一个簇中。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7087", "type": "P", "difficulty": 6, "samples": [["4\n.....1...\n1........\n.2.....8.\n.........\n8....9...\n.........\n....7....\n...2...1.\n2...4....\n\n....2....\n...7.4...\n8.......9\n.8...2..1\n..2......\n.........\n.........\n..1.8....\n.........\n\n1........\n.........\n.........\n.........\n.........\n.........\n.........\n.........\n.........\n\n.....1...\n1........\n.2.....8.\n.........\n8....9...\n.........\n....7....\n...2...1.\n2...4....\n", "Yes\n7\nC 1 2\nD 5 3\nF\nr 7 9\nc 6 5\nC 2 3\nD 1 8\nNo\nYes\n0\nNo\nYes\n8\nR 1 2\nC 2 3\nc 4 5\nF\nr 5 6\nc 7 9\nD 1 8\nD 3 5\nNo\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2013] Intellectual Property", "background": "", "description": "\n\nErast Kopi is famous Sudoku puzzle designer. Resounding success of his puzzle compilations caused a number of imitations and plagiarisms. Prior to sending a lawsuit he decided to get more evidence.\n\nSudoku puzzle is a table $9 \\times 9$ , divided into $3 \\times 3$ subtables of $3 \\times 3$ cells each. Each cell may contain a digit from $1$ to $9$ . The task is to fill empty cells with digits in a way that each row, each column and each of the $9$ subtables $3 \\times 3$ contains each digit from $1$ to $9$ exactly once.\n\nKopi has a database of Sudoku puzzles and he wants to check if it contains similar puzzles. The puzzle $P$ is similar to the puzzle $Q$ , if it is possible to transform the puzzle $P$ into the puzzle $Q$ using a sequence of the following operations:\n\nchoose two digits $x$ and $y$ and replace all digits $x$ with $y$ and vice versa;\n\nswap two triples of rows: $(1 , 2 , 3) , (4 , 5 , 6) , (7 , 8 , 9)$ ;\n\nswap two rows in one triple of rows;\n\nswap two triples of columns: $(1 , 2 , 3) , (4 , 5 , 6) , (7 , 8 , 9)$ ;\n\nswap two columns in one triple of columns;\n\nflip along top-left -- bottom-right axis. After this operation columns become rows and vice versa.\n\n![](/upload/images2/ip.png)\n\nHelp Kopi to find similar puzzles in his database.\n\n", "inputFormat": "\n\nThe first line of the input contains single integer $n$ -- the number of puzzles in the database $(1 \\le n \\le 20)$ .\n\nThe rest of the input contains description of $n$ puzzles: $P_1 , P_2$ , . . . , Pn. Each puzzle is described by nine lines that contain nine characters each. Each character is either a digit from $1$ to $9$ , or a dot $(‘. ')$ denoting an empty cell. An empty line separates consecutive puzzles in the database.\n\nThere are no spaces in the input file.\n\nThe puzzles are not guaranteed to be solvable.\n\n", "outputFormat": "\n\nCheck if the puzzle $P_1$ is similar to puzzles $P_2$ , P3 , . . . , $P_n$ (in this order), than check if the puzzle $P_2$ is similar to puzzles P3 , P4 , . . . , $P_n$ (in this order) and so on.\n\nIf the puzzle $P_i$ is similar to the puzzle $Pj (1 \\le i < j \\le n)$ output `Yes`, otherwise output `No`. If the answer is positive, the next line should contain an integer qij -- the number of operations required to transform the puzzle $P_i$ to the puzzle $Pj$ . The number of operations is not required to be minimal, however it must not exceed $1000$ . In the following qij lines write the operations that transform the puzzle $P_i$ to the puzzle $Pj$ , one per line.\n\nOperations are encoded in the following way:\n\n`D $x$ y` for swapping digits $x$ and $y$ ;\n\n`R a b` for swapping triples of rows (3a $− 2$ , 3a $− 1 , 3a)$ and (3b $− 2$ , 3b $− 1 , 3b);$\n\n`r a b` for swapping rows a and $b$ , rows must belong to same triple of rows;\n\n`C a b` for swapping triples of columns (3a $− 2$ , 3a $− 1 , 3a)$ and (3b $− 2$ , 3b $− 1 , 3b);$\n\n`c a b` for swapping columns a and $b$ , columns must belong to same triple of columns;\n\n`F` for flipping along top-left -- bottom-right axis.\n\nThe columns are numbered from left to right and the rows are numbered from top to bottom as they are given in the input file, starting from one.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2013] Intellectual Property", "background": "", "description": "\n\nErast Kopi is famous Sudoku puzzle designer. Resounding success of his puzzle compilations caused a number of imitations and plagiarisms. Prior to sending a lawsuit he decided to get more evidence.\n\nSudoku puzzle is a table $9 \\times 9$ , divided into $3 \\times 3$ subtables of $3 \\times 3$ cells each. Each cell may contain a digit from $1$ to $9$ . The task is to fill empty cells with digits in a way that each row, each column and each of the $9$ subtables $3 \\times 3$ contains each digit from $1$ to $9$ exactly once.\n\nKopi has a database of Sudoku puzzles and he wants to check if it contains similar puzzles. The puzzle $P$ is similar to the puzzle $Q$ , if it is possible to transform the puzzle $P$ into the puzzle $Q$ using a sequence of the following operations:\n\nchoose two digits $x$ and $y$ and replace all digits $x$ with $y$ and vice versa;\n\nswap two triples of rows: $(1 , 2 , 3) , (4 , 5 , 6) , (7 , 8 , 9)$ ;\n\nswap two rows in one triple of rows;\n\nswap two triples of columns: $(1 , 2 , 3) , (4 , 5 , 6) , (7 , 8 , 9)$ ;\n\nswap two columns in one triple of columns;\n\nflip along top-left -- bottom-right axis. After this operation columns become rows and vice versa.\n\n![](/upload/images2/ip.png)\n\nHelp Kopi to find similar puzzles in his database.\n\n", "inputFormat": "\n\nThe first line of the input contains single integer $n$ -- the number of puzzles in the database $(1 \\le n \\le 20)$ .\n\nThe rest of the input contains description of $n$ puzzles: $P_1 , P_2$ , . . . , Pn. Each puzzle is described by nine lines that contain nine characters each. Each character is either a digit from $1$ to $9$ , or a dot $(‘. ')$ denoting an empty cell. An empty line separates consecutive puzzles in the database.\n\nThere are no spaces in the input file.\n\nThe puzzles are not guaranteed to be solvable.\n\n", "outputFormat": "\n\nCheck if the puzzle $P_1$ is similar to puzzles $P_2$ , P3 , . . . , $P_n$ (in this order), than check if the puzzle $P_2$ is similar to puzzles P3 , P4 , . . . , $P_n$ (in this order) and so on.\n\nIf the puzzle $P_i$ is similar to the puzzle $Pj (1 \\le i < j \\le n)$ output `Yes`, otherwise output `No`. If the answer is positive, the next line should contain an integer qij -- the number of operations required to transform the puzzle $P_i$ to the puzzle $Pj$ . The number of operations is not required to be minimal, however it must not exceed $1000$ . In the following qij lines write the operations that transform the puzzle $P_i$ to the puzzle $Pj$ , one per line.\n\nOperations are encoded in the following way:\n\n`D $x$ y` for swapping digits $x$ and $y$ ;\n\n`R a b` for swapping triples of rows (3a $− 2$ , 3a $− 1 , 3a)$ and (3b $− 2$ , 3b $− 1 , 3b);$\n\n`r a b` for swapping rows a and $b$ , rows must belong to same triple of rows;\n\n`C a b` for swapping triples of columns (3a $− 2$ , 3a $− 1 , 3a)$ and (3b $− 2$ , 3b $− 1 , 3b);$\n\n`c a b` for swapping columns a and $b$ , columns must belong to same triple of columns;\n\n`F` for flipping along top-left -- bottom-right axis.\n\nThe columns are numbered from left to right and the rows are numbered from top to bottom as they are given in the input file, starting from one.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2013] Intellectual Property", "background": "", "description": "Erast Kopi 是一位著名的数独谜题设计师。他的谜题合集取得了巨大成功，引发了许多模仿和抄袭。在提出诉讼之前，他决定收集更多证据。\n\n数独谜题是一个 $9 \\times 9$ 的表格，分为 $3 \\times 3$ 的子表格，每个子表格包含 $3 \\times 3$ 的单元格。每个单元格可以包含从 $1$ 到 $9$ 的一个数字。任务是用数字填充空单元格，使得每一行、每一列以及每个 $3 \\times 3$ 的子表格都恰好包含从 $1$ 到 $9$ 的每个数字一次。\n\nKopi 有一个数独谜题数据库，他想检查其中是否包含相似的谜题。谜题 $P$ 与谜题 $Q$ 相似，如果可以通过以下操作序列将谜题 $P$ 转换为谜题 $Q$：\n\n选择两个数字 $x$ 和 $y$，并将所有数字 $x$ 替换为 $y$，反之亦然；\n\n交换两组行：$(1 , 2 , 3) , (4 , 5 , 6) , (7 , 8 , 9)$；\n\n在一组行中交换两行；\n\n交换两组列：$(1 , 2 , 3) , (4 , 5 , 6) , (7 , 8 , 9)$；\n\n在一组列中交换两列；\n\n沿左上到右下轴翻转。此操作后，列变为行，反之亦然。\n\n帮助 Kopi 在他的数据库中找到相似的谜题。", "inputFormat": "输入的第一行包含一个整数 $n$，表示数据库中的谜题数量 $(1 \\le n \\le 20)$。\n\n输入的其余部分包含 $n$ 个谜题的描述：$P_1 , P_2$，……，$P_n$。每个谜题由九行描述，每行包含九个字符。每个字符要么是从 $1$ 到 $9$ 的数字，要么是表示空单元格的点（‘.’）。数据库中连续的谜题之间用空行分隔。\n\n输入文件中没有空格。\n\n这些谜题不保证可解。", "outputFormat": "检查谜题 $P_1$ 是否与谜题 $P_2$，$P_3$，……，$P_n$（按此顺序）相似，然后检查谜题 $P_2$ 是否与谜题 $P_3$，$P_4$，……，$P_n$（按此顺序）相似，依此类推。\n\n如果谜题 $P_i$ 与谜题 $P_j (1 \\le i < j \\le n)$ 相似，输出 `Yes`，否则输出 `No`。如果答案是肯定的，下一行应包含一个整数 $q_{ij}$，表示将谜题 $P_i$ 转换为谜题 $P_j$ 所需的操作数。操作数不要求是最小的，但不能超过 $1000$。在接下来的 $q_{ij}$ 行中，写出将谜题 $P_i$ 转换为谜题 $P_j$ 的操作，每行一个。\n\n操作以以下方式编码：\n\n`D $x$ y` 表示交换数字 $x$ 和 $y$；\n\n`R a b` 表示交换行组 $(3a - 2, 3a - 1, 3a)$ 和 $(3b - 2, 3b - 1, 3b)$；\n\n`r a b` 表示交换行 $a$ 和 $b$，行必须属于同一组行；\n\n`C a b` 表示交换列组 $(3a - 2, 3a - 1, 3a)$ 和 $(3b - 2, 3b - 1, 3b)$；\n\n`c a b` 表示交换列 $a$ 和 $b$，列必须属于同一组列；\n\n`F` 表示沿左上到右下轴翻转。\n\n列从左到右编号，行从上到下编号，编号从一开始。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7088", "type": "P", "difficulty": 5, "samples": [["5\n1 2 3 4 5\n+/*:X\n", "55\n"], ["5\n1 2 3 4 5\nN++/X-X+1\n", "0\n"], ["3\n11 56 37\n+/(3-+/*:*:X)-X**:X\n", "964602515\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "ICPC", "NWRRC"], "title": "[NWRRC 2013] J", "background": "", "description": "\n\nThe $J$ programming language, developed in the early $1990s$ by Kenneth $E$ . Iverson and Roger Hui, is a synthesis of APL (also by Iverson) and the FP and FL function-level languages created by John Backus.\n\nWikipedia. $J$ (programming language)\n\nAPL language family is famous for its support of advanced operations on vectors and arrays, and $J$ is not an exception. For example, all unary and binary numeric operations in these languages by default are applicable to vectors and arrays of different dimensions. Plus operation $(‘+')$ can add not only scalars, like in other languages, but also scalars and vectors (the scalar is added to each component of the vector), or vectors and vectors (the vectors are added component-wise).\n\nThe expressive power of $J$ is amazing (as well as its cryptic syntax), but for this problem we need just a small subset of the language. We consider a single expression, where we may use one vector variable $X$ , one scalar variable $N$ -- the length of the vector $X$ , and the following operations:\n\nWe can add $(‘+'),$ subtract $(‘-')$ or multiply $(‘ \\times ')$ two vectors, vector and scalar, or two scalars.\n\nWe can use unary minus $(‘-')$ and unary squaring operations $(‘ \\times :')$ for scalars and vectors $(component-wise).$\n\nWe can fold a vector with plus operation $(‘+/')$ -- that is, compute the sum of a vector (unary operation).\n\nOperations are evaluated right-to-left, natural precedence of operations is ignored in $J$ . The order of evaluation can be altered by parentheses. More precisely the syntax is specified in the following BNF.\n\n$〈expressio_n〉 ::= 〈ter_m〉 | 〈ter_m〉 (‘+' | ‘-' | ‘ \\times ') 〈expressio_n〉 | (‘-' | ‘ \\times :' | ‘+/') 〈expressio_n〉$\n\n$〈ter_m〉 ::= ‘('〈expressio_n〉‘)' | ‘X' | ‘N' | 〈number〉$\n\n$〈number〉 ::= (‘0' | ‘1' |$ . . . $| ‘9')^{+}$\n\nTo correctly impose one more limitation on expression syntax, let us define complexity of an expression:\n\ncomplexity of scalars (numbers, $‘N',$ and result of fold) is zero;\n\ncomplexity of $‘X'$ is one;\n\ncomplexity of addition and subtraction is the maximum of their operands' complexities;\n\ncomplexity of multiplication is the sum of its operands' complexities;\n\ncomplexity of unary squaring is twice the complexity of its operand.\n\nFor example, the complexity of expression $`(3-+/ \\times : \\times :X)-X \\times \\times :X`$ is $3$ , while the complexity of its subexpression $` \\times : \\times :X`$ is $4$ .\n\nYour program is given a scalar-valued expression and a value of the vector $X$ , and it should compute the expression result modulo $10^{9}.$ The complexity of each subexpression in the given expression does not exceed $10$ .\n\n", "inputFormat": "\n\nThe first line contains one integer number $N (1 \\le N \\le 10^{5})$ -- the length of the vector $X$ .\n\nThe second line contains $N$ integers -- components of the vector $X (0 \\le X_{i} < 10^{9}).$\n\nThe third line contains the expression to be computed, a non-empty string of not more than $105$ symbols. Each number in the expression is less than $109$ . The fold is never applied to a scalar.\n\n", "outputFormat": "\n\nOutput a single integer number -- the expression result modulo $10^{9}.$\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2013] J", "background": "", "description": "\n\nThe $J$ programming language, developed in the early $1990s$ by Kenneth $E$ . Iverson and Roger Hui, is a synthesis of APL (also by Iverson) and the FP and FL function-level languages created by John Backus.\n\nWikipedia. $J$ (programming language)\n\nAPL language family is famous for its support of advanced operations on vectors and arrays, and $J$ is not an exception. For example, all unary and binary numeric operations in these languages by default are applicable to vectors and arrays of different dimensions. Plus operation $(‘+')$ can add not only scalars, like in other languages, but also scalars and vectors (the scalar is added to each component of the vector), or vectors and vectors (the vectors are added component-wise).\n\nThe expressive power of $J$ is amazing (as well as its cryptic syntax), but for this problem we need just a small subset of the language. We consider a single expression, where we may use one vector variable $X$ , one scalar variable $N$ -- the length of the vector $X$ , and the following operations:\n\nWe can add $(‘+'),$ subtract $(‘-')$ or multiply $(‘ \\times ')$ two vectors, vector and scalar, or two scalars.\n\nWe can use unary minus $(‘-')$ and unary squaring operations $(‘ \\times :')$ for scalars and vectors $(component-wise).$\n\nWe can fold a vector with plus operation $(‘+/')$ -- that is, compute the sum of a vector (unary operation).\n\nOperations are evaluated right-to-left, natural precedence of operations is ignored in $J$ . The order of evaluation can be altered by parentheses. More precisely the syntax is specified in the following BNF.\n\n$〈expressio_n〉 ::= 〈ter_m〉 | 〈ter_m〉 (‘+' | ‘-' | ‘ \\times ') 〈expressio_n〉 | (‘-' | ‘ \\times :' | ‘+/') 〈expressio_n〉$\n\n$〈ter_m〉 ::= ‘('〈expressio_n〉‘)' | ‘X' | ‘N' | 〈number〉$\n\n$〈number〉 ::= (‘0' | ‘1' |$ . . . $| ‘9')^{+}$\n\nTo correctly impose one more limitation on expression syntax, let us define complexity of an expression:\n\ncomplexity of scalars (numbers, $‘N',$ and result of fold) is zero;\n\ncomplexity of $‘X'$ is one;\n\ncomplexity of addition and subtraction is the maximum of their operands' complexities;\n\ncomplexity of multiplication is the sum of its operands' complexities;\n\ncomplexity of unary squaring is twice the complexity of its operand.\n\nFor example, the complexity of expression $`(3-+/ \\times : \\times :X)-X \\times \\times :X`$ is $3$ , while the complexity of its subexpression $` \\times : \\times :X`$ is $4$ .\n\nYour program is given a scalar-valued expression and a value of the vector $X$ , and it should compute the expression result modulo $10^{9}.$ The complexity of each subexpression in the given expression does not exceed $10$ .\n\n", "inputFormat": "\n\nThe first line contains one integer number $N (1 \\le N \\le 10^{5})$ -- the length of the vector $X$ .\n\nThe second line contains $N$ integers -- components of the vector $X (0 \\le X_{i} < 10^{9}).$\n\nThe third line contains the expression to be computed, a non-empty string of not more than $105$ symbols. Each number in the expression is less than $109$ . The fold is never applied to a scalar.\n\n", "outputFormat": "\n\nOutput a single integer number -- the expression result modulo $10^{9}.$\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2013] J", "background": "", "description": "$J$ 编程语言由 Kenneth E. Iverson 和 Roger Hui 在 1990 年代早期开发，是 APL（也是由 Iverson 开发）与 John Backus 创建的 FP 和 FL 函数级语言的综合体。\n\nWikipedia. $J$ (编程语言)\n\nAPL 语言家族以其对向量和数组的高级操作支持而闻名，$J$ 也不例外。例如，这些语言中的所有一元和二元数值运算默认适用于不同维度的向量和数组。加法运算（‘+’）不仅可以像其他语言一样对标量进行加法运算，还可以对标量和向量进行加法运算（标量加到向量的每个分量上），或者对向量和向量进行加法运算（向量按分量相加）。\n\n$J$ 的表达能力令人惊叹（以及它的神秘语法），但对于这个问题，我们只需要语言的一个小子集。我们考虑一个单一表达式，其中可以使用一个向量变量 $X$，一个标量变量 $N$——向量 $X$ 的长度，以及以下操作：\n\n我们可以对两个向量、向量和标量或两个标量进行加法（‘+’）、减法（‘-’）或乘法（‘\\times’）运算。\n\n我们可以对标量和向量（按分量）使用一元负号（‘-’）和一元平方运算（‘\\times:’）。\n\n我们可以使用加法折叠向量（‘+/’）——即计算向量的和（一元运算）。\n\n运算从右到左进行评估，$J$ 中忽略运算的自然优先级。可以通过括号改变评估顺序。更准确地说，语法在以下 BNF 中指定。\n\n$\\langle expression \\rangle ::= \\langle term \\rangle | \\langle term \\rangle (‘+’ | ‘-’ | ‘\\times’) \\langle expression \\rangle | (‘-’ | ‘\\times:’ | ‘+/’) \\langle expression \\rangle$\n\n$\\langle term \\rangle ::= ‘(’\\langle expression \\rangle‘)’ | ‘X’ | ‘N’ | \\langle number \\rangle$\n\n$\\langle number \\rangle ::= (‘0’ | ‘1’ | \\ldots | ‘9’)^{+}$\n\n为了正确施加对表达式语法的一个限制，让我们定义表达式的复杂度：\n\n标量（数字，‘N’，以及折叠的结果）的复杂度为零；\n\n‘X’ 的复杂度为一；\n\n加法和减法的复杂度是其操作数复杂度的最大值；\n\n乘法的复杂度是其操作数复杂度的和；\n\n一元平方的复杂度是其操作数复杂度的两倍。\n\n例如，表达式 `(3-+/ \\times: \\times:X)-X \\times \\times:X` 的复杂度是 3，而其子表达式 `\\times: \\times:X` 的复杂度是 4。\n\n你的程序给定一个标量值的表达式和向量 $X$ 的值，它应该计算表达式结果对 $10^{9}$ 取模。给定表达式中每个子表达式的复杂度不超过 10。", "inputFormat": "第一行包含一个整数 $N (1 \\le N \\le 10^{5})$——向量 $X$ 的长度。\n\n第二行包含 $N$ 个整数——向量 $X$ 的分量 $(0 \\le X_{i} < 10^{9})$。\n\n第三行包含要计算的表达式，一个不超过 105 个符号的非空字符串。表达式中的每个数字都小于 109。折叠从不应用于标量。", "outputFormat": "输出一个整数——表达式结果对 $10^{9}$ 取模。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7089", "type": "P", "difficulty": 5, "samples": [["1 2 1 2\n", "2 4\n1 2\n1 3\n1 5\n2 4\n2 6\n3 4\n3 5\n4 6\n5 6\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2013] Kids in a Friendly Class", "background": "", "description": "Kevin resembles his class in primary school. There were girls and boys in his class. Some of them were friends, some were not. But if one person considered another person a friend, the opposite was also true.\n\nInterestingly, every girl had exactly a friends among girls and exactly $b$ friends among boys, whereas every boy had exactly $c$ friends among girls and exactly $d$ friends among boys.\n\nKevin does not remember the size of his class. Help him reconstruct the class with minimal possible number of kids, such that the above conditions are satisfied.", "inputFormat": "The only line contains four integers $a , b , c$ , and $d (1 \\le a , b , c , d \\le 50)$ .\n", "outputFormat": "\nOutput an example of a class of minimal possible size satisfying the above conditions.\n\nThe first line should contains two positive integers: $m$ -- the number of girls, and $n$ -- the number of boys.\n\nLet's assign numbers $1$ through $m$ to the girls and $m + 1$ through $m + n$ to the boys.\n\nEach of the next lines should contain a pair of distinct integers describing a pair of friends by their numbers. Each pair of friends should appear exactly once in this list. ", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2013] Kids in a Friendly Class", "background": "", "description": "Kevin resembles his class in primary school. There were girls and boys in his class. Some of them were friends, some were not. But if one person considered another person a friend, the opposite was also true.\n\nInterestingly, every girl had exactly a friends among girls and exactly $b$ friends among boys, whereas every boy had exactly $c$ friends among girls and exactly $d$ friends among boys.\n\nKevin does not remember the size of his class. Help him reconstruct the class with minimal possible number of kids, such that the above conditions are satisfied.", "inputFormat": "The only line contains four integers $a , b , c$ , and $d (1 \\le a , b , c , d \\le 50)$ .\n", "outputFormat": "\nOutput an example of a class of minimal possible size satisfying the above conditions.\n\nThe first line should contains two positive integers: $m$ -- the number of girls, and $n$ -- the number of boys.\n\nLet's assign numbers $1$ through $m$ to the girls and $m + 1$ through $m + n$ to the boys.\n\nEach of the next lines should contain a pair of distinct integers describing a pair of friends by their numbers. Each pair of friends should appear exactly once in this list. ", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2013] Kids in a Friendly Class", "background": "", "description": "凯文的班级里有女生也有男生。他们中有些人是朋友，有些人不是。但是，如果A认为B是他的朋友，那么B也认为A是他的朋友。\n\n有趣的是，每个女生都有 a 个女性朋友和 b 个男性朋友，而每个男生都有 c 个女性朋友和 d 个男性朋友。\n\n凯文不记得自己班级的人数。请算出班级的人数，使得班级人数尽可能少，同时又能满足上面的条件。", "inputFormat": "只有一行，包括4个整数 a , b , c，d (1≤a,b,c,d≤50) .", "outputFormat": "输出一个班级人数，使得其数量尽可能小又满足上述条件。\n\n第一行应该包括两个正整数 m —— 女生人数 n —— 男生人数。\n\n用编号1 到 m 表示女生，编号 m+1 到m+n 表示男生。\n\n接下来的每一行，都应该包含一对不同的整数，来表示一对朋友，而且每对朋友只出现一次。", "hint": "", "locale": "zh-CN"}}}
