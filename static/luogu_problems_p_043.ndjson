{"pid": "P1864", "type": "P", "difficulty": 6, "samples": [["4 10\n1 2 3 4\n1 2 3 4\n1 2 3 4\n", "29"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2009", "NOI", "区间 DP"], "title": "[NOI2009] 二叉查找树", "background": "", "description": "已知一棵特殊的二叉查找树。根据定义，该二叉查找树中每个结点的数据值都比它左儿子结点的数据值大，而比它右儿子结点的数据值小。\n\n另一方面，这棵查找树中每个结点都有一个权值，每个结点的权值都比它的儿子结点的权值要小。\n\n已知树中所有结点的数据值各不相同；所有结点的权值也各不相同。这时可得出这样一个有趣的结论：如果能够确定树中每个结点的数据值和权值，那么树的形态便可以唯一确定。因为这样的一棵树可以看成是按照权值从小到大顺序插入结点所得到的、按照数据值排序的二叉查找树。\n\n一个结点在树中的深度定义为它到树根的距离加 $1$。因此树的根结点的深度为 $1$。\n\n每个结点除了数据值和权值以外，还有一个访问频度。我们定义一个结点在树中的访问代价为它的访问频度乘以它在树中的深度。整棵树的访问代价定义为所有结点在树中的访问代价之和。\n\n现在给定每个结点的数据值、权值和访问频度，你可以根据需要修改某些结点的权值，但每次修改你会付出 $K$ 的额外修改代价。你可以把结点的权值改为任何实数，但是修改后所有结点的权值必须仍保持互不相同。现在你要解决的问题是，整棵树的访问代价与额外修改代价的和最小是多少？", "inputFormat": "输入文件中的第一行为两个正整数 $N,K$。其中 $N$ 表示结点的个数，$K$ 表示每次修改所需的额外修改代价。\n\n接下来的一行为 $N$ 个非负整数，表示每个结点的数据值。\n\n再接下来的一行为 $N$ 个非负整数，表示每个结点的权值。\n\n再接下来的一行为 $N$ 个非负整数，表示每个结点的访问频度。\n\n其中：所有的数据值、权值、访问频度均不超过 $4 \\times 10^5$。", "outputFormat": "输出文件中仅一行为一个数，即你所能得到的整棵树的访问代价与额外修改代价之和的最小值。\n", "hint": "### 样例解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/10bjubxe.png)\n\n输入的原图是左图，它的访问代价是 $1 \\times 1+2 \\times 2+3 \\times 3+4 \\times 4=30$。\n\n最佳的修改方案是把输入中的第 $3$ 个结点的权值改成 $0$，得到右图，访问代价是：$1 \\times 2+2 \\times 3+3 \\times 1+4 \\times 2=19$，加上额外修改代价 $10$，一共是 $29$。\n\n### 数据范围\n\n- 对于 $40\\%$ 的数据，满足 $N \\leq 30$；\n- 对于 $70\\%$ 的数据，满足 $N \\leq 50$；\n- 对于 $100\\%$ 的数据，满足：$1 \\leq N \\leq 70$，$1 \\leq K \\leq 3 \\times 10^7$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2009] Binary Search Tree", "background": "", "description": "You are given a special binary search tree (BST). By definition, in this BST the data value of each node is greater than the data value of its left child and less than the data value of its right child.\n\nOn the other hand, every node in this tree also has a weight, and the weight of each node is smaller than the weights of its children.\n\nAll data values in the tree are distinct, and all weights are also distinct. From this, we get an interesting conclusion: if the data value and the weight of every node are known, then the structure of the tree is uniquely determined. Equivalently, such a tree can be seen as the BST ordered by data values, obtained by inserting nodes in increasing order of weight.\n\nThe depth of a node in the tree is defined as its distance to the root plus $1$. Therefore, the depth of the root is $1$.\n\nBesides the data value and the weight, each node also has an access frequency. We define the access cost of a node to be its access frequency multiplied by its depth. The total access cost of the tree is the sum of the access costs of all nodes.\n\nNow you are given the data value, weight, and access frequency of every node. You may modify the weights of some nodes as needed, but each modification incurs an extra modification cost of $K$. You may change a node’s weight to any real number, but after all modifications the weights must remain pairwise distinct. Your task is to determine the minimum possible value of the sum of the total access cost of the tree and the extra modification cost.", "inputFormat": "The first line contains two positive integers $N, K$, where $N$ is the number of nodes and $K$ is the extra cost incurred by each modification.\n\nThe next line contains $N$ non-negative integers, the data values of the nodes.\n\nThe following line contains $N$ non-negative integers, the weights of the nodes.\n\nThe next line contains $N$ non-negative integers, the access frequencies of the nodes.\n\nAll data values, weights, and access frequencies do not exceed $4 \\times 10^5$.", "outputFormat": "Output a single line containing one number: the minimum possible sum of the total access cost and the extra modification cost.", "hint": "Sample explanation:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/10bjubxe.png)\n\nThe original tree from the input is shown on the left, and its access cost is $1 \\times 1 + 2 \\times 2 + 3 \\times 3 + 4 \\times 4 = 30$.\n\nThe optimal modification is to change the weight of the $3$rd node to $0$, yielding the tree on the right. Its access cost is $1 \\times 2 + 2 \\times 3 + 3 \\times 1 + 4 \\times 2 = 19$. Adding the extra modification cost $10$ gives a total of $29$.\n\nConstraints:\n- For $40\\%$ of the testdata, $N \\leq 30$.\n- For $70\\%$ of the testdata, $N \\leq 50$.\n- For $100\\%$ of the testdata, $1 \\leq N \\leq 70$, $1 \\leq K \\leq 3 \\times 10^7$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2009] 二叉查找树", "background": "", "description": "已知一棵特殊的二叉查找树。根据定义，该二叉查找树中每个结点的数据值都比它左儿子结点的数据值大，而比它右儿子结点的数据值小。\n\n另一方面，这棵查找树中每个结点都有一个权值，每个结点的权值都比它的儿子结点的权值要小。\n\n已知树中所有结点的数据值各不相同；所有结点的权值也各不相同。这时可得出这样一个有趣的结论：如果能够确定树中每个结点的数据值和权值，那么树的形态便可以唯一确定。因为这样的一棵树可以看成是按照权值从小到大顺序插入结点所得到的、按照数据值排序的二叉查找树。\n\n一个结点在树中的深度定义为它到树根的距离加 $1$。因此树的根结点的深度为 $1$。\n\n每个结点除了数据值和权值以外，还有一个访问频度。我们定义一个结点在树中的访问代价为它的访问频度乘以它在树中的深度。整棵树的访问代价定义为所有结点在树中的访问代价之和。\n\n现在给定每个结点的数据值、权值和访问频度，你可以根据需要修改某些结点的权值，但每次修改你会付出 $K$ 的额外修改代价。你可以把结点的权值改为任何实数，但是修改后所有结点的权值必须仍保持互不相同。现在你要解决的问题是，整棵树的访问代价与额外修改代价的和最小是多少？", "inputFormat": "输入文件中的第一行为两个正整数 $N,K$。其中 $N$ 表示结点的个数，$K$ 表示每次修改所需的额外修改代价。\n\n接下来的一行为 $N$ 个非负整数，表示每个结点的数据值。\n\n再接下来的一行为 $N$ 个非负整数，表示每个结点的权值。\n\n再接下来的一行为 $N$ 个非负整数，表示每个结点的访问频度。\n\n其中：所有的数据值、权值、访问频度均不超过 $4 \\times 10^5$。", "outputFormat": "输出文件中仅一行为一个数，即你所能得到的整棵树的访问代价与额外修改代价之和的最小值。\n", "hint": "### 样例解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/10bjubxe.png)\n\n输入的原图是左图，它的访问代价是 $1 \\times 1+2 \\times 2+3 \\times 3+4 \\times 4=30$。\n\n最佳的修改方案是把输入中的第 $3$ 个结点的权值改成 $0$，得到右图，访问代价是：$1 \\times 2+2 \\times 3+3 \\times 1+4 \\times 2=19$，加上额外修改代价 $10$，一共是 $29$。\n\n### 数据范围\n\n- 对于 $40\\%$ 的数据，满足 $N \\leq 30$；\n- 对于 $70\\%$ 的数据，满足 $N \\leq 50$；\n- 对于 $100\\%$ 的数据，满足：$1 \\leq N \\leq 70$，$1 \\leq K \\leq 3 \\times 10^7$。\n", "locale": "zh-CN"}}}
{"pid": "P1865", "type": "P", "difficulty": 3, "samples": [["2 5\n1 3\n2 6", "2\nCrossing the line"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "洛谷原创", "素数判断,质数,筛法", "前缀和"], "title": "A % B Problem", "background": "题目名称是吸引你点进来的。    \n实际上该题还是很水的。", "description": "给定 $l, r$，求区间 $[l, r]$ 内质数的个数。", "inputFormat": "第一行有两个整数，分别代表询问次数 $n$ 和给定区间的右端点最大值 $m$。\n\n接下来 $n$ 行，每行两个整数 $l, r$，代表一次查询。", "outputFormat": "对于每次查询输出一行，若 $l, r \\in [1, m]$，则输出区间质数个数，否则输出 `Crossing the line`。", "hint": "#### 数据范围与约定\n\n- 对于 $20\\%$ 的数据，保证 $n,m\\le 10$。\n- 对于 $100\\%$ 的数据，保证 $1\\le n\\le1000$，$1\\le m\\le10^6$，$-10^9\\le l\\le r\\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "A % B Problem", "background": "The title is just to get you to click. In fact, this problem is quite easy.", "description": "Given $l, r$, find the number of primes in the interval $[l, r]$.", "inputFormat": "The first line contains two integers, the number of queries $n$ and the maximum value of the right endpoint $m$.  \nThen follow $n$ lines, each with two integers $l, r$, representing one query.", "outputFormat": "For each query, output one line. If $l, r \\in [1, m]$, output the number of primes in the interval; otherwise, output `Crossing the line`.", "hint": "Constraints\n\n- For $20\\%$ of the testdata, $n, m \\le 10$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 1000$, $1 \\le m \\le 10^6$, $-10^9 \\le l \\le r \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "A % B Problem", "background": "题目名称是吸引你点进来的。    \n实际上该题还是很水的。", "description": "给定 $l, r$，求区间 $[l, r]$ 内质数的个数。", "inputFormat": "第一行有两个整数，分别代表询问次数 $n$ 和给定区间的右端点最大值 $m$。\n\n接下来 $n$ 行，每行两个整数 $l, r$，代表一次查询。", "outputFormat": "对于每次查询输出一行，若 $l, r \\in [1, m]$，则输出区间质数个数，否则输出 `Crossing the line`。", "hint": "#### 数据范围与约定\n\n- 对于 $20\\%$ 的数据，保证 $n,m\\le 10$。\n- 对于 $100\\%$ 的数据，保证 $1\\le n\\le1000$，$1\\le m\\le10^6$，$-10^9\\le l\\le r\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P1866", "type": "P", "difficulty": 2, "samples": [["2\n5 8\n", "35"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "递推", "NOI 导刊", "排序"], "title": "编号", "background": "", "description": "太郎有 $N$ 只兔子，现在为了方便识别它们，太郎要给他们编号。兔子们向太郎表达了它们对号码的喜好，每个兔子 $i$ 想要一个整数，介于 $1$ 和 $M_i$ 之间（可以为 $1$ 或 $M_i$）。当然，每个兔子的编号是不同的。现在太郎想知道一共有多少种编号的方法。\n\n你只用输出答案对 $10^9+7$ 取余的结果即可。如果这是不可能的，就输出 $0$。", "inputFormat": "第一行是一个整数 $N$。\n\n第二行 $N$ 个整数 $M_i$。", "outputFormat": "一个整数，表示方案总数。", "hint": "### 数据范围及约定\n\n对于全部数据，$1 \\le N \\le 50$，$1\\le M_i\\le 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "Numbering", "background": "", "description": "Taro has $N$ rabbits. To make them easier to identify, Taro will assign them numbers. The rabbits expressed their preferences: each rabbit $i$ wants an integer between $1$ and $M_i$ (it can be $1$ or $M_i$). Of course, the numbers assigned to different rabbits must be distinct. Now Taro wants to know how many ways there are to assign the numbers.\n\nYou only need to output the answer modulo $10^9+7$. If this is impossible, output $0$.", "inputFormat": "The first line contains an integer $N$.\nThe second line contains $N$ integers $M_i$.", "outputFormat": "Print a single integer, the total number of ways.", "hint": "Constraints\n\nFor all testdata, $1 \\le N \\le 50$, $1\\le M_i\\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "编号", "background": "", "description": "太郎有 $N$ 只兔子，现在为了方便识别它们，太郎要给他们编号。兔子们向太郎表达了它们对号码的喜好，每个兔子 $i$ 想要一个整数，介于 $1$ 和 $M_i$ 之间（可以为 $1$ 或 $M_i$）。当然，每个兔子的编号是不同的。现在太郎想知道一共有多少种编号的方法。\n\n你只用输出答案对 $10^9+7$ 取余的结果即可。如果这是不可能的，就输出 $0$。", "inputFormat": "第一行是一个整数 $N$。\n\n第二行 $N$ 个整数 $M_i$。", "outputFormat": "一个整数，表示方案总数。", "hint": "### 数据范围及约定\n\n对于全部数据，$1 \\le N \\le 50$，$1\\le M_i\\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P1867", "type": "P", "difficulty": 1, "samples": [["2\n5.5 15\n4.5 24\n", "4 0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "洛谷原创"], "title": "【Mc生存】经验值", "background": "初一福利第2弹。。。\n", "description": "话说 clearman 在 MC 世界开了个祥艺奶牛场，用岩浆、TNT 等丧心病狂的折磨牛，获取牛肉、牛奶等刷经验。他想知道他到底达到什么层次。\n\n他总共进行了 $n$ 项操作，每次操作要付出 $x$ 生命值（初始生命是 $10$ 点，初一党都知道！并且要先计算付出的生命值，如果小于等于 $0$，则死亡，本次及以下操作都无效。但切记：付出生命值可以是负数，也就是说可以回复 $−x$ 点生命值，但上限只能是 $10$！切记！），每次操作可以获得 $a$ 经验值（不能为负），他最后能达到 $m$ 级 $t$ 经验。\n\nP.S. 关于等级\n\n初始等级为 $0$。每加 $2^m$（$m$ 为当前等级）点经验可升一级。  \n\n1、假设 clearman 一共得到 $15$ 点经验，那么他应该为 $4$ 级（ $15-1-2-4-8=0$）加 $0$ 点经验。    \n2、假设 clearman 一共获得 $39$ 点经验，那么他应该为 $5$ 级（ $39-1-2-4-8-16=8$）加 $8$ 点经验。\n", "inputFormat": "第一行一个正整数 $n$，表示操作个数。\n\n接下来 $n$ 行，每行两个数，为 clearman 的一次操作。\n", "outputFormat": "一行，为等级和经验值。\n", "hint": "数据很弱，人肉输的，但是很坑。。。\n\n【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 20$。", "locale": "zh-CN", "translations": {"en": {"title": "【MC Survival】Experience Points", "background": "Seventh-grade benefit, round 2.", "description": "It is said that clearman opened a Xiangyi cattle ranch in the MC world, using lava, TNT, and other brutal methods to torment cows, farming beef, milk, and experience. He wants to know what level he ultimately reaches.\n\nHe performs a total of $n$ operations. Each operation costs $x$ HP (initial HP is 10; calculate the HP cost first—if HP becomes less than or equal to 0, he dies, and this operation and all subsequent operations are invalid. Note: the HP cost $x$ can be negative, meaning he restores $-x$ HP, but HP is capped at 10). Each operation grants $a$ experience points (cannot be negative). In the end, he will be at level $m$ with $t$ experience.\n\nP.S. About levels:\n\n- The initial level is $0$. Every additional $2^m$ (where $m$ is the current level) experience points increases the level by 1.\n- Example 1: If clearman gains a total of $15$ experience points, then he should be level $4$ with $0$ experience left ($15 - 1 - 2 - 4 - 8 = 0$).\n- Example 2: If clearman gains a total of $39$ experience points, then he should be level $5$ with $8$ experience left ($39 - 1 - 2 - 4 - 8 - 16 = 8$).\n\n# Description", "inputFormat": "The first line contains a positive integer $n$, the number of operations.\n\nThe next $n$ lines each contain two integers $x$ and $a$, representing one operation of clearman.", "outputFormat": "Output one line with two integers: the final level $m$ and the remaining experience $t$ toward the next level, separated by a space.", "hint": "The testdata is very weak and can be solved by hand, but it is tricky.\n\nConstraints  \nFor $100\\%$ of the testdata, $1 \\le n \\le 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【Mc生存】经验值", "background": "初一福利第2弹。。。\n", "description": "话说 clearman 在 MC 世界开了个祥艺奶牛场，用岩浆、TNT 等丧心病狂的折磨牛，获取牛肉、牛奶等刷经验。他想知道他到底达到什么层次。\n\n他总共进行了 $n$ 项操作，每次操作要付出 $x$ 生命值（初始生命是 $10$ 点，初一党都知道！并且要先计算付出的生命值，如果小于等于 $0$，则死亡，本次及以下操作都无效。但切记：付出生命值可以是负数，也就是说可以回复 $−x$ 点生命值，但上限只能是 $10$！切记！），每次操作可以获得 $a$ 经验值（不能为负），他最后能达到 $m$ 级 $t$ 经验。\n\nP.S. 关于等级\n\n初始等级为 $0$。每加 $2^m$（$m$ 为当前等级）点经验可升一级。  \n\n1、假设 clearman 一共得到 $15$ 点经验，那么他应该为 $4$ 级（ $15-1-2-4-8=0$）加 $0$ 点经验。    \n2、假设 clearman 一共获得 $39$ 点经验，那么他应该为 $5$ 级（ $39-1-2-4-8-16=8$）加 $8$ 点经验。\n", "inputFormat": "第一行一个正整数 $n$，表示操作个数。\n\n接下来 $n$ 行，每行两个数，为 clearman 的一次操作。\n", "outputFormat": "一行，为等级和经验值。\n", "hint": "数据很弱，人肉输的，但是很坑。。。\n\n【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 20$。", "locale": "zh-CN"}}}
{"pid": "P1868", "type": "P", "difficulty": 4, "samples": [["3\n1 3\n7 8\n3 4", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "线性数据结构", "二分"], "title": "饥饿的奶牛", "background": "", "description": "有一条奶牛冲出了围栏，来到了一处圣地（对于奶牛来说），上面用牛语写着一段文字。\n\n现用汉语翻译为：\n\n有 $N$ 个区间，每个区间 $x,y$ 表示提供的 $x\\sim y$ 共 $y-x+1$ 堆优质牧草。你可以选择任意区间但不能有重复的部分。\n\n对于奶牛来说，自然是吃的越多越好，然而奶牛智商有限，现在请你帮助他。", "inputFormat": "第一行一个整数 $N$。\n\n接下来 $N$ 行，每行两个数 $x,y$，描述一个区间。", "outputFormat": "输出最多能吃到的牧草堆数。", "hint": "$1 \\leq n \\leq 1.5 \\times 10^5$，$0 \\leq x \\leq y \\leq 3 \\times 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "Hungry Cow", "background": "", "description": "A cow broke through the fence and reached a sanctuary (for cows), where a message was written in the cow language.\n\nTranslated, it says:\n\nThere are $N$ intervals. Each interval $x,y$ provides $x \\sim y$, a total of $y-x+1$ piles of premium pasture. You may choose any intervals, but they must not overlap.\n\nFor the cow, the more it eats, the better. However, the cow is not very smart, so please help it.", "inputFormat": "The first line contains an integer $N$.\n\nThe next $N$ lines each contain two numbers $x,y$, describing an interval.", "outputFormat": "Output the maximum number of pasture piles the cow can eat.", "hint": "$1 \\leq n \\leq 1.5 \\times 10^5$，$0 \\leq x \\leq y \\leq 3 \\times 10^6$。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "饥饿的奶牛", "background": "", "description": "有一条奶牛冲出了围栏，来到了一处圣地（对于奶牛来说），上面用牛语写着一段文字。\n\n现用汉语翻译为：\n\n有 $N$ 个区间，每个区间 $x,y$ 表示提供的 $x\\sim y$ 共 $y-x+1$ 堆优质牧草。你可以选择任意区间但不能有重复的部分。\n\n对于奶牛来说，自然是吃的越多越好，然而奶牛智商有限，现在请你帮助他。", "inputFormat": "第一行一个整数 $N$。\n\n接下来 $N$ 行，每行两个数 $x,y$，描述一个区间。", "outputFormat": "输出最多能吃到的牧草堆数。", "hint": "$1 \\leq n \\leq 1.5 \\times 10^5$，$0 \\leq x \\leq y \\leq 3 \\times 10^6$。", "locale": "zh-CN"}}}
{"pid": "P1869", "type": "P", "difficulty": 3, "samples": [["3\n1 1\n1 0\n2 1", "1\n1\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学"], "title": "愚蠢的组合数", "background": null, "description": "最近老师教了狗狗怎么算组合数，狗狗又想到了一个问题。。。\n\n狗狗定义 $C(N,K)$ 表示从 $N$ 个元素中不重复地选取 $K$ 个元素的方案数。\n\n狗狗想知道的是 $C(N,K)$ 的奇偶性。\n\n当然，这个整天都老是用竖式算 $123456789 \\times 987654321=?$ 的人不会让你那么让自己那么轻松，它说：“ $N$ 和 $K$ 都可能相当大”。\n\n但是狗狗也犯难了，所以它就找到了你，想请你帮他解决这个问题。", "inputFormat": "第一行一个正整数 $t$，表示数据的组数。\n\n第 $2$ 至第 $2+t-1$ 行，每行有两个非负整数 $N$ 和 $K$，描述每组数据。数据保证 $K\\le N$。", "outputFormat": "每一组输入，如果 $C(N,K)$ 是奇数则输出 $1$，否则输出 $0$。", "hint": "### 数据范围及约定\n\n对于 $100\\%$ 的数据，$1\\le N\\le 10^5$，$1\\le t\\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Silly Binomial Coefficient", "background": "", "description": "Recently the teacher taught Doggy how to compute combinations, and Doggy came up with another problem...\n\nDoggy defines $C(N,K)$ as the number of ways to choose $K$ elements from $N$ elements without repetition.\n\nDoggy wants to know the parity of $C(N,K)$.\n\nOf course, the person who is always using long multiplication to compute $123456789 \\times 987654321=?$ all day won’t let you off easy. They say: “$N$ and $K$ can be quite large.”\n\nBut Doggy is also stumped, so it comes to you for help to solve this problem.", "inputFormat": "The first line contains a positive integer $t$, the number of test cases.\n\nLines $2$ through $2+t-1$ each contain two non-negative integers $N$ and $K$, describing each test case. The input guarantees $k\\le n$.", "outputFormat": "For each test case, output $1$ if $C(N,K)$ is odd; otherwise output $0$.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, $1\\le n\\le 10^5$, $1\\le t\\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "愚蠢的组合数", "background": null, "description": "最近老师教了狗狗怎么算组合数，狗狗又想到了一个问题。。。\n\n狗狗定义 $C(N,K)$ 表示从 $N$ 个元素中不重复地选取 $K$ 个元素的方案数。\n\n狗狗想知道的是 $C(N,K)$ 的奇偶性。\n\n当然，这个整天都老是用竖式算 $123456789 \\times 987654321=?$ 的人不会让你那么让自己那么轻松，它说：“ $N$ 和 $K$ 都可能相当大”。\n\n但是狗狗也犯难了，所以它就找到了你，想请你帮他解决这个问题。", "inputFormat": "第一行一个正整数 $t$，表示数据的组数。\n\n第 $2$ 至第 $2+t-1$ 行，每行有两个非负整数 $N$ 和 $K$，描述每组数据。数据保证 $K\\le N$。", "outputFormat": "每一组输入，如果 $C(N,K)$ 是奇数则输出 $1$，否则输出 $0$。", "hint": "### 数据范围及约定\n\n对于 $100\\%$ 的数据，$1\\le N\\le 10^5$，$1\\le t\\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P1870", "type": "P", "difficulty": 2, "samples": [["3 10 10000\r\n0 10\r\n5 11\r\n1000 1\r\n", "1000.5000\r\n1000.5000\r\n11000.0500\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟"], "title": "公交车", "background": "", "description": "某城市有个能容纳 $n$ 辆公交车的停车场。每一天，这些公交车都要依次有序离开停车库去另一个终点站。这终点站距离停车场有 $d$ 米的路程。当然第 $i$ 辆公交车离开停车场的时间是 $t_i$ 秒，并以最大速度不超过 $v_i$ 米/秒行驶，加速度最大值为 $a$。一辆公交车能瞬间减速，也能瞬间改变它的加速度。当然每辆车的最大加速度都一样为 $a$。\n\n不管有多大的马力，一辆公交车都不能超过其他另外的公交车，如果一辆公交车追上另一辆公交车，那么后面追上的车跟前面被追的车一起并排行驶同时到达终点站。当然司机都是尽可能快的驾车到达终点站的。\n\n作为公交公司老板的你，希望每辆公交车都尽可能快的到达终点站。当然，公交车到达终点站时，速度可以没必要达到 $0$。当一辆公交车离开停车场时，它的起始速度等于 $0$。通过物理的观点解释的话，公交车可以看成是抽象的一个物体而已，除了能加速和减速，其他对速度的影响都可以忽略掉。", "inputFormat": "第一行三个空格隔开的整数 $n, a, d$（$1 \\leq n \\leq 10^5$，$1 \\leq a, d \\leq 10^6$），分别表示公交车的数量，最大加速度。离终点站的距离。\n\n接下来 $n$ 行，每行有一对整数 $t_i, v_i$（$0 \\leq t_1 < t_2 < \\cdots < t_{n-1} < tn \\leq 10^6$，$1 \\leq v_i \\leq 10^6$），分别表示每辆车离开停车场的时刻和能够行驶的最大速度。", "outputFormat": "输出每辆公交车到达终点站的时刻。一行表示一辆公交车的到达时刻，输出时刻的公交车顺序按照输入的公交车顺序。输出答案的相对或绝对误差不能超过 $10^{-4}$（即末尾保留 $4$ 位小数）。", "hint": "【样例解释】\n\n第二辆公交车能追上第一辆公交车，在行驶到距离终点 $510.5$ 公里处。然后还剩 $9489.5$ 公里的路程，两辆车都以 $10$ km/h 的速度，一起到达终点的，它们到达终点的时刻是 $1000.5$ 秒，第三辆公交车不能赶上其他的公交车，他到达终点的时刻是 $11000.05$ 秒。", "locale": "zh-CN", "translations": {"en": {"title": "Bus", "background": "", "description": "A city has a parking lot that can hold $n$ buses. Each day, these buses leave the depot in order and head to a terminal that is $d$ meters away. The $i$-th bus leaves the parking lot at time $t_i$ seconds, travels with a maximum speed no greater than $v_i$ meters per second, and has a maximum acceleration of $a$. A bus can decelerate instantaneously and can change its acceleration instantaneously. The maximum acceleration is the same for every bus and equals $a$.\n\nNo matter how powerful a bus is, it may not overtake any other bus. If a bus catches up with another, the rear bus and the front bus travel side by side together and reach the terminal at the same time. Drivers always try to reach the terminal as fast as possible.\n\nAs the bus company owner, you want every bus to reach the terminal as quickly as possible. It is not required that the bus speed be $0$ upon arrival at the terminal. When a bus leaves the parking lot, its initial speed is $0$. From a physics perspective, treat a bus as an abstract point-like object; apart from being able to accelerate and decelerate, all other effects on speed can be ignored.", "inputFormat": "The first line contains three space-separated integers $n, a, d$ ($1 \\leq n \\leq 10^5$, $1 \\leq a, d \\leq 10^6$), denoting the number of buses, the maximum acceleration, and the distance to the terminal, respectively.\n\nThe next $n$ lines each contain a pair of integers $t_i, v_i$ ($0 \\leq t_1 < t_2 < \\cdots < t_{n-1} < t_n \\leq 10^6$, $1 \\leq v_i \\leq 10^6$), denoting the departure time of each bus and its maximum possible speed, respectively.", "outputFormat": "Output the arrival time at the terminal for each bus. Print one bus’s arrival time per line, in the same order as the input. The relative or absolute error of each answer must not exceed $10^{-4}$ (i.e., keep 4 decimal places at the end).", "hint": "[Sample explanation]\n\nThe second bus can catch up with the first bus at a point $510.5$ kilometers from the terminal. Then there are $9489.5$ kilometers remaining, and both buses travel together at $10$ km/h to reach the terminal at time $1000.5$ seconds. The third bus cannot catch up with any other bus, and its arrival time is $11000.05$ seconds.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "公交车", "background": "", "description": "某城市有个能容纳 $n$ 辆公交车的停车场。每一天，这些公交车都要依次有序离开停车库去另一个终点站。这终点站距离停车场有 $d$ 米的路程。当然第 $i$ 辆公交车离开停车场的时间是 $t_i$ 秒，并以最大速度不超过 $v_i$ 米/秒行驶，加速度最大值为 $a$。一辆公交车能瞬间减速，也能瞬间改变它的加速度。当然每辆车的最大加速度都一样为 $a$。\n\n不管有多大的马力，一辆公交车都不能超过其他另外的公交车，如果一辆公交车追上另一辆公交车，那么后面追上的车跟前面被追的车一起并排行驶同时到达终点站。当然司机都是尽可能快的驾车到达终点站的。\n\n作为公交公司老板的你，希望每辆公交车都尽可能快的到达终点站。当然，公交车到达终点站时，速度可以没必要达到 $0$。当一辆公交车离开停车场时，它的起始速度等于 $0$。通过物理的观点解释的话，公交车可以看成是抽象的一个物体而已，除了能加速和减速，其他对速度的影响都可以忽略掉。", "inputFormat": "第一行三个空格隔开的整数 $n, a, d$（$1 \\leq n \\leq 10^5$，$1 \\leq a, d \\leq 10^6$），分别表示公交车的数量，最大加速度。离终点站的距离。\n\n接下来 $n$ 行，每行有一对整数 $t_i, v_i$（$0 \\leq t_1 < t_2 < \\cdots < t_{n-1} < tn \\leq 10^6$，$1 \\leq v_i \\leq 10^6$），分别表示每辆车离开停车场的时刻和能够行驶的最大速度。", "outputFormat": "输出每辆公交车到达终点站的时刻。一行表示一辆公交车的到达时刻，输出时刻的公交车顺序按照输入的公交车顺序。输出答案的相对或绝对误差不能超过 $10^{-4}$（即末尾保留 $4$ 位小数）。", "hint": "【样例解释】\n\n第二辆公交车能追上第一辆公交车，在行驶到距离终点 $510.5$ 公里处。然后还剩 $9489.5$ 公里的路程，两辆车都以 $10$ km/h 的速度，一起到达终点的，它们到达终点的时刻是 $1000.5$ 秒，第三辆公交车不能赶上其他的公交车，他到达终点的时刻是 $11000.05$ 秒。", "locale": "zh-CN"}}}
{"pid": "P1871", "type": "P", "difficulty": 3, "samples": [["10 10 \n+ 6\n+ 10\n+ 5\n- 10\n- 5\n- 6\n+ 10 \n+ 3\n+ 6\n+ 3\n", "Success\nConflict with 6\nSuccess\nAlready off\nSuccess\nSuccess\nSuccess\nSuccess\nConflict with 3\nAlready on\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["Special Judge", "素数判断,质数,筛法"], "title": "对撞机", "background": null, "description": "在 2312 年，宇宙中发现了 $n$ 台巨型对撞机，这些对撞机分别用 $1 \\sim n$ 的自然数标识。科学家们不知道启动这些对撞机会发生什么危险事故，所以这些机器，刚开始都是出于关闭的状态。\n\n随着科学家们的研究发现，第 $i$ 台对撞机启动是安全的，当且仅当其他已经启动的对撞机的标识数都跟这台对撞机标识数互质。（例如假设前面启动的对撞机标识数是 $j$，如果 $i$ 能启动，那么 $i,j$ 互质，即 $\\gcd(i,j) = 1$）。如果两台对撞机的标识数不为互质数就启动，那么就会发生爆炸事故。\n\n基于前面的研究，科学家们准备做各种启动和关闭对撞机的实验。为了确保科学家们的生命安全，你要设计一个远程遥控的软件。\n\n刚开始，所有的对撞机都是关闭状态。你的程序将会收到许多询问，格式为“启动、关闭第 $i$ 台对撞机”。这个程序应该能处理这些询问（根据收到询问的先后顺序处理）。程序按照如下的格式输出处理结果。\n\n如果询问为 `+ i`（表示启动第 $i$ 台对撞机），程序应该按照下面三种情况之一输出结果。\n\n- `Success`，表示启动第 $i$ 台是安全的。\n- `Already on`，表示第 $i$ 台在询问之前就已经启动了。\n- `Conflict with j`，表示第 $i$ 台与前面已经启动的第 $j$ 台冲突。如果前面有多台对撞机跟 $i$ 冲突，那么只输出其中任何一台即可。\n\n如果询问为 `- i`（表示关闭第 $i$ 台对撞机），程序应该按照下面两种情况之一输出结果。\n\n- `Success`，表示关闭第 $i$ 台对撞机。\n- `Already off`，表示第 $i$ 台对撞机在询问之前就已经关闭了。", "inputFormat": "第一行输入两个以空格隔开的整数 $n$ 和 $m$，分别表示对撞机的数量和询问数。\n\n接下来 $m$ 行，表示询问，每行仅可能是 `+ i` 或 `- i`，表示开启或关闭第 $i$ 台对撞机。", "outputFormat": "输出 $m$ 行，输出结果按照上面题目给定格式输出。", "hint": "**数据范围**\n\n$1 \\le n,m \\le 10^5$，$1 \\le i \\le n$。\n\n---\n\n感谢 @cn：苏卿念 提供 Special Judge", "locale": "zh-CN", "translations": {"en": {"title": "Collider", "background": "", "description": "In the year 2312, $n$ giant colliders were discovered in the universe, labeled by the natural numbers $1 \\sim n$. Scientists do not know what dangerous accidents might occur when these colliders are turned on, so at the beginning all the machines are in the off state.\n\nThrough research, scientists found that turning on collider $i$ is safe if and only if the labels of all colliders that are already on are coprime with the label of collider $i$. (For example, suppose a previously turned on collider has label $j$, then if $i$ can be turned on, $i$ and $j$ are coprime, that is, $\\gcd(i,j) = 1$.) If two colliders with labels that are not coprime are turned on, an explosion will occur.\n\nBased on the above, scientists plan to run various experiments of turning colliders on and off. To ensure their safety, you need to design remote-control software.\n\nInitially, all colliders are off. Your program will receive many queries of the form “turn on or turn off collider $i$.” The program should process these queries in the order they are received and output results in the following format.\n\nIf a query is `+ i` (turn on collider $i$), the program should output exactly one of the following:\n\n- `Success`, meaning that turning on collider $i$ is safe.\n- `Already on`, meaning collider $i$ was already on before this query.\n- `Conflict with j`, meaning collider $i$ conflicts with some collider $j$ that is already on. If multiple colliders conflict with $i$, output any one of them.\n\nIf a query is `- i` (turn off collider $i$), the program should output exactly one of the following:\n\n- `Success`, meaning collider $i$ has been turned off.\n- `Already off`, meaning collider $i$ was already off before this query.", "inputFormat": "The first line contains two space-separated integers $n$ and $m$, the number of colliders and the number of queries.\n\nThe next $m$ lines are the queries. Each line is either `+ i` or `- i`, meaning to turn on or turn off collider $i$.", "outputFormat": "Output $m$ lines. For each query, output the result in the format specified above.", "hint": "Constraints\n\n$1 \\le n,m \\le 10^5$, $1 \\le i \\le n$.\n\n---\n\nThanks to @cn: 苏卿念 for providing the Special Judge.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "对撞机", "background": null, "description": "在 2312 年，宇宙中发现了 $n$ 台巨型对撞机，这些对撞机分别用 $1 \\sim n$ 的自然数标识。科学家们不知道启动这些对撞机会发生什么危险事故，所以这些机器，刚开始都是出于关闭的状态。\n\n随着科学家们的研究发现，第 $i$ 台对撞机启动是安全的，当且仅当其他已经启动的对撞机的标识数都跟这台对撞机标识数互质。（例如假设前面启动的对撞机标识数是 $j$，如果 $i$ 能启动，那么 $i,j$ 互质，即 $\\gcd(i,j) = 1$）。如果两台对撞机的标识数不为互质数就启动，那么就会发生爆炸事故。\n\n基于前面的研究，科学家们准备做各种启动和关闭对撞机的实验。为了确保科学家们的生命安全，你要设计一个远程遥控的软件。\n\n刚开始，所有的对撞机都是关闭状态。你的程序将会收到许多询问，格式为“启动、关闭第 $i$ 台对撞机”。这个程序应该能处理这些询问（根据收到询问的先后顺序处理）。程序按照如下的格式输出处理结果。\n\n如果询问为 `+ i`（表示启动第 $i$ 台对撞机），程序应该按照下面三种情况之一输出结果。\n\n- `Success`，表示启动第 $i$ 台是安全的。\n- `Already on`，表示第 $i$ 台在询问之前就已经启动了。\n- `Conflict with j`，表示第 $i$ 台与前面已经启动的第 $j$ 台冲突。如果前面有多台对撞机跟 $i$ 冲突，那么只输出其中任何一台即可。\n\n如果询问为 `- i`（表示关闭第 $i$ 台对撞机），程序应该按照下面两种情况之一输出结果。\n\n- `Success`，表示关闭第 $i$ 台对撞机。\n- `Already off`，表示第 $i$ 台对撞机在询问之前就已经关闭了。", "inputFormat": "第一行输入两个以空格隔开的整数 $n$ 和 $m$，分别表示对撞机的数量和询问数。\n\n接下来 $m$ 行，表示询问，每行仅可能是 `+ i` 或 `- i`，表示开启或关闭第 $i$ 台对撞机。", "outputFormat": "输出 $m$ 行，输出结果按照上面题目给定格式输出。", "hint": "**数据范围**\n\n$1 \\le n,m \\le 10^5$，$1 \\le i \\le n$。\n\n---\n\n感谢 @cn：苏卿念 提供 Special Judge", "locale": "zh-CN"}}}
{"pid": "P1872", "type": "P", "difficulty": 4, "samples": [["aaa", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": [], "title": "回文串计数", "background": null, "description": "小 $a$ 虽然是一名理科生，但他常常称自己是一名真正的文科生。不知为何，他对于背诵总有一种莫名其妙的热爱，这也促使他走向了以记忆量大而闻名的生物竞赛。然而，他很快发现这并不能满足他热爱背诵的心，但是作为一名强大的 OIER，他找到了这么一个方法——背诵基因序列。然而这实在是太困难了，小 $a$ 感觉有些招架不住。\n\n不过他发现，如果他能事先知道这个序列里有多少对互不相交的回文串，他或许可以找到记忆的妙法。为了进一步验证这个想法，小 $a$ 决定选取一个由小写字母构成的字符串 $SS$ 来实验。由于互不相关的回文串实在过多，他很快就数晕了。不过他相信，在你的面前这个问题不过是小菜一碟。\n\n1. 对于字符串 $SS$，设其长度为 Len，那么下文用 $S_i$ 表示 $SS$ 中第 $i$ 个字符（$1 \\le i \\le Le_n$）。\n\n2. $S[i,j]$ 表示 $SS$ 的一个子串，$S[i,j]=S_i S_{i+1}S_{i+2} \\cdots S_{j-2}S_{j-1}S_{j}$，比如当 $SS$ 为 `abcgfd` 时，$S[2,5]$ 就是 `bcgf`，$S[1,5]$ 是 `abcgf`。\n\n3. 当一个串被称为一个回文串当且仅当将这个串反写后与原串相同，如`abcba`。\n\n4. 考虑一个四元组 $(l,r,L,R)$，当 $S[l,r]$ 和 $S[L,R]$ 均为回文串时，且满足 $1 \\le l \\le r<L \\le R \\le \\text{Len}$ 时，我们称 $S[l,r]$ 和 $S[L,R]$ 为一对互不相交的回文串。即本题所求，也即为这种四元组的个数。两个四元组相同当且仅当对应的 $l,r,L,R$ 都相同。", "inputFormat": "输入仅一行，为字符串 $SS$，保证全部由小写字母构成，由换行符标志结束。\n\n$50$ ％的数据满足 $SS$ 的长度不超过 $200$；\n\n$100$ ％的数据满足 $SS$ 的长度不超过 $2000$。", "outputFormat": "仅一行，为一个整数，表示互不相关的回文串的对数。", "hint": "【样例数据说明】\n\nSS=\"aaa\"，SS 的任意一个字符串均为回文串，其中总计有 5 对互不相关的回文串：\n\n(1,1,2,2)，(1,1,2,3)，(1,1,3,3)，(1,2,3,3)，(2,2,3,3)。", "locale": "zh-CN", "translations": {"en": {"title": "Palindromic Substring Pair Count", "background": "", "description": "Although little $a$ is a science student, he often calls himself a true liberal arts student. For some reason, he has a strange love for recitation, which also led him to the biology contest, known for its heavy memorization. However, he soon found that this still could not satisfy his passion for reciting, but as a strong OIER, he found a method—reciting gene sequences. Yet this is too hard, and little $a$ felt overwhelmed.\n\nHe found that if he could know in advance how many pairs of disjoint palindromic substrings there are in the sequence, he might discover a trick for memorization. To further test this idea, little $a$ decided to choose a string $SS$ consisting of lowercase letters for experimentation. Since there were too many disjoint palindromic substrings, he quickly got dizzy counting them. But he believes this problem is a piece of cake for you.\n\n1. For the string $SS$, let its length be $\\text{Len}$. We use $S_i$ to denote the $i$-th character of $SS$ ($1 \\le i \\le \\text{Len}$).\n\n2. $S[i,j]$ denotes a substring of $SS$, where $S[i,j] = S_i S_{i+1} S_{i+2} \\cdots S_{j-2} S_{j-1} S_{j}$. For example, when $SS$ is `abcgfd`, $S[2,5]$ is `bcgf`, and $S[1,5]$ is `abcgf`.\n\n3. A string is called a palindrome if and only if the string is the same when reversed, such as `abcba`.\n\n4. Consider a quadruple $(l,r,L,R)$. If both $S[l,r]$ and $S[L,R]$ are palindromes, and $1 \\le l \\le r < L \\le R \\le \\text{Len}$ holds, then we call $S[l,r]$ and $S[L,R]$ a pair of disjoint palindromic substrings. This problem asks for the number of such quadruples. Two quadruples are the same if and only if the corresponding $l,r,L,R$ are all the same.", "inputFormat": "The input consists of a single line: the string $SS$, guaranteed to contain only lowercase letters, ending with a newline.\n\n50% of the testdata satisfies that the length of $SS$ does not exceed $200$;\n100% of the testdata satisfies that the length of $SS$ does not exceed $2000$.", "outputFormat": "Output a single line containing one integer: the number of pairs of disjoint palindromic substrings.", "hint": "[Sample explanation]\n\nWhen $SS = \\text{\"aaa\"}$, every substring of $SS$ is a palindrome. There are 5 pairs of disjoint palindromic substrings in total:\n$(1,1,2,2)$, $(1,1,2,3)$, $(1,1,3,3)$, $(1,2,3,3)$, $(2,2,3,3)$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "回文串计数", "background": null, "description": "小 $a$ 虽然是一名理科生，但他常常称自己是一名真正的文科生。不知为何，他对于背诵总有一种莫名其妙的热爱，这也促使他走向了以记忆量大而闻名的生物竞赛。然而，他很快发现这并不能满足他热爱背诵的心，但是作为一名强大的 OIER，他找到了这么一个方法——背诵基因序列。然而这实在是太困难了，小 $a$ 感觉有些招架不住。\n\n不过他发现，如果他能事先知道这个序列里有多少对互不相交的回文串，他或许可以找到记忆的妙法。为了进一步验证这个想法，小 $a$ 决定选取一个由小写字母构成的字符串 $SS$ 来实验。由于互不相关的回文串实在过多，他很快就数晕了。不过他相信，在你的面前这个问题不过是小菜一碟。\n\n1. 对于字符串 $SS$，设其长度为 Len，那么下文用 $S_i$ 表示 $SS$ 中第 $i$ 个字符（$1 \\le i \\le Le_n$）。\n\n2. $S[i,j]$ 表示 $SS$ 的一个子串，$S[i,j]=S_i S_{i+1}S_{i+2} \\cdots S_{j-2}S_{j-1}S_{j}$，比如当 $SS$ 为 `abcgfd` 时，$S[2,5]$ 就是 `bcgf`，$S[1,5]$ 是 `abcgf`。\n\n3. 当一个串被称为一个回文串当且仅当将这个串反写后与原串相同，如`abcba`。\n\n4. 考虑一个四元组 $(l,r,L,R)$，当 $S[l,r]$ 和 $S[L,R]$ 均为回文串时，且满足 $1 \\le l \\le r<L \\le R \\le \\text{Len}$ 时，我们称 $S[l,r]$ 和 $S[L,R]$ 为一对互不相交的回文串。即本题所求，也即为这种四元组的个数。两个四元组相同当且仅当对应的 $l,r,L,R$ 都相同。", "inputFormat": "输入仅一行，为字符串 $SS$，保证全部由小写字母构成，由换行符标志结束。\n\n$50$ ％的数据满足 $SS$ 的长度不超过 $200$；\n\n$100$ ％的数据满足 $SS$ 的长度不超过 $2000$。", "outputFormat": "仅一行，为一个整数，表示互不相关的回文串的对数。", "hint": "【样例数据说明】\n\nSS=\"aaa\"，SS 的任意一个字符串均为回文串，其中总计有 5 对互不相关的回文串：\n\n(1,1,2,2)，(1,1,2,3)，(1,1,3,3)，(1,2,3,3)，(2,2,3,3)。", "locale": "zh-CN"}}}
{"pid": "P1873", "type": "P", "difficulty": 2, "samples": [["4 7\n20 15 10 17", "15"], ["5 20\n4 42 40 26 46", "36"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "二分", "COCI（克罗地亚）"], "title": "[COCI 2011/2012 #5] EKO / 砍树", "background": "", "description": "伐木工人 Mirko 需要砍 $M$ 米长的木材。对 Mirko 来说这是很简单的工作，因为他有一个漂亮的新伐木机，可以如野火一般砍伐森林。不过，Mirko 只被允许砍伐一排树。\n\nMirko 的伐木机工作流程如下：Mirko 设置一个高度参数 $H$（米），伐木机升起一个巨大的锯片到高度 $H$，并锯掉所有树比 $H$ 高的部分（当然，树木不高于 $H$ 米的部分保持不变）。Mirko 就得到树木被锯下的部分。例如，如果一排树的高度分别为 $20,15,10$ 和 $17$，Mirko 把锯片升到 $15$ 米的高度，切割后树木剩下的高度将是 $15,15,10$ 和 $15$，而 Mirko 将从第 $1$ 棵树得到 $5$ 米，从第 $4$ 棵树得到 $2$ 米，共得到 $7$ 米木材。\n\nMirko 非常关注生态保护，所以他不会砍掉过多的木材。这也是他尽可能高地设定伐木机锯片的原因。请帮助 Mirko 找到伐木机锯片的最大的整数高度 $H$，使得他能得到的木材至少为 $M$ 米。换句话说，如果再升高 $1$ 米，他将得不到 $M$ 米木材。", "inputFormat": "第 $1$ 行 $2$ 个整数 $N$ 和 $M$，$N$ 表示树木的数量，$M$ 表示需要的木材总长度。\n\n第 $2$ 行 $N$ 个整数表示每棵树的高度。", "outputFormat": "$1$ 个整数，表示锯片的最高高度。", "hint": "对于 $100\\%$ 的测试数据，$1\\le N\\le10^6$，$1\\le M\\le2\\times10^9$，树的高度 $\\le 4\\times 10^5$，所有树的高度总和 $>M$。", "locale": "zh-CN", "translations": {"en": {"title": "[COCI 2011/2012 #5] EKO / Cutting Trees", "background": "", "description": "Lumberjack Mirko needs to cut $M$ meters of wood. This is easy for Mirko because he has a shiny new woodcutting machine that can cut through a forest like wildfire. However, Mirko is allowed to cut only one row of trees.\n\nThe machine works as follows: Mirko sets a height parameter $H$ (in meters), the machine raises a huge saw blade to height $H$, and it cuts off the part of every tree that is higher than $H$ (of course, trees not higher than $H$ remain unchanged). Mirko then collects the cut-off parts. For example, if a row of trees has heights $20, 15, 10$ and $17$, and Mirko raises the blade to $15$ meters, after cutting the remaining heights will be $15, 15, 10$ and $15$, and Mirko will get $5$ meters from the $1$st tree and $2$ meters from the $4$th tree, $7$ meters in total.\n\nMirko cares about the environment, so he will not cut more wood than necessary. This is why he sets the saw blade as high as possible. Help Mirko find the maximum integer height $H$ such that the amount of wood he obtains is at least $M$ meters. In other words, if he raised it by $1$ meter more, he would not obtain $M$ meters of wood.", "inputFormat": "The first line contains two integers $N$ and $M$, where $N$ is the number of trees and $M$ is the required total length of wood.\n\nThe second line contains $N$ integers, the heights of the trees.", "outputFormat": "Output a single integer, the highest possible blade height.", "hint": "For $100\\%$ of the testdata, $1 \\le N \\le 10^6$, $1 \\le M \\le 2 \\times 10^9$, tree height $\\le 4 \\times 10^5$, and the sum of all tree heights $> M$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[COCI 2011/2012 #5] EKO / 砍树", "background": "", "description": "伐木工人 Mirko 需要砍 $M$ 米长的木材。对 Mirko 来说这是很简单的工作，因为他有一个漂亮的新伐木机，可以如野火一般砍伐森林。不过，Mirko 只被允许砍伐一排树。\n\nMirko 的伐木机工作流程如下：Mirko 设置一个高度参数 $H$（米），伐木机升起一个巨大的锯片到高度 $H$，并锯掉所有树比 $H$ 高的部分（当然，树木不高于 $H$ 米的部分保持不变）。Mirko 就得到树木被锯下的部分。例如，如果一排树的高度分别为 $20,15,10$ 和 $17$，Mirko 把锯片升到 $15$ 米的高度，切割后树木剩下的高度将是 $15,15,10$ 和 $15$，而 Mirko 将从第 $1$ 棵树得到 $5$ 米，从第 $4$ 棵树得到 $2$ 米，共得到 $7$ 米木材。\n\nMirko 非常关注生态保护，所以他不会砍掉过多的木材。这也是他尽可能高地设定伐木机锯片的原因。请帮助 Mirko 找到伐木机锯片的最大的整数高度 $H$，使得他能得到的木材至少为 $M$ 米。换句话说，如果再升高 $1$ 米，他将得不到 $M$ 米木材。", "inputFormat": "第 $1$ 行 $2$ 个整数 $N$ 和 $M$，$N$ 表示树木的数量，$M$ 表示需要的木材总长度。\n\n第 $2$ 行 $N$ 个整数表示每棵树的高度。", "outputFormat": "$1$ 个整数，表示锯片的最高高度。", "hint": "对于 $100\\%$ 的测试数据，$1\\le N\\le10^6$，$1\\le M\\le2\\times10^9$，树的高度 $\\le 4\\times 10^5$，所有树的高度总和 $>M$。", "locale": "zh-CN"}}}
{"pid": "P1874", "type": "P", "difficulty": 3, "samples": [["99999\n45\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "搜索"], "title": "快速求和", "background": "2023-10-08 update: 新增两组 hack。\n\n2023-12-16 update: 新增两组 hack。", "description": "给定一个数字字符串，用最小次数的加法让字符串等于一个给定的目标数字。每次加法就是在字符串的某个位置插入一个加号。在里面要的所有加号都插入后，就像做普通加法那样来求值。\n\n例如，考虑字符串`12`，做 $0$ 次加法，我们得到数字 $12$。如果插入 $1$ 个加号，我们得到 $3$，因此，这个例子中，最少用 $1$ 次加法就得到数字 $3$。\n\n再举一例，考虑字符串`303`和目标数字 $6$，最佳方法不是`3+0+3`。而是`3+03`。能这样做是因为一个数的前导 $0$ 不会改变它的大小。", "inputFormat": "第一行：一个字符串 $s$。\n\n第二行：一个整数 $n$。", "outputFormat": "一行一个整数表示最少的加法次数让 $s$ 等于 $n$。如果怎么做都不能让 $s$ 等于 $n$ ，则输出 $-1$。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1\\le \\operatorname{len}(s)\\le40$，$1 \\leq n\\le10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Fast Summation", "background": "2023-10-08 update: Added two hack cases.\n\n2023-12-16 update: Added two hack cases.", "description": "Given a numeric string, make it equal to a given target number using the minimum number of additions. Each addition means inserting a plus sign at some position in the string. After all required plus signs are inserted, evaluate it as ordinary addition.\n\nFor example, consider the string `12`. With $0$ additions, we get the number $12$. If we insert $1$ plus sign, we get $3$. Therefore, in this case, the minimum number of additions to obtain the number $3$ is $1$.\n\nAnother example: consider the string `303` and the target number $6$. The optimal way is not `3+0+3`, but `3+03`. This works because a leading $0$ in a number does not change its value.", "inputFormat": "The first line: a string $s$.\n\nThe second line: an integer $n$.", "outputFormat": "Output a single integer on one line, the minimum number of additions to make $s$ equal to $n$. If it is impossible to make $s$ equal to $n$, output $-1$.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that $1 \\le \\operatorname{len}(s) \\le 40$, $1 \\le n \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "快速求和", "background": "2023-10-08 update: 新增两组 hack。\n\n2023-12-16 update: 新增两组 hack。", "description": "给定一个数字字符串，用最小次数的加法让字符串等于一个给定的目标数字。每次加法就是在字符串的某个位置插入一个加号。在里面要的所有加号都插入后，就像做普通加法那样来求值。\n\n例如，考虑字符串`12`，做 $0$ 次加法，我们得到数字 $12$。如果插入 $1$ 个加号，我们得到 $3$，因此，这个例子中，最少用 $1$ 次加法就得到数字 $3$。\n\n再举一例，考虑字符串`303`和目标数字 $6$，最佳方法不是`3+0+3`。而是`3+03`。能这样做是因为一个数的前导 $0$ 不会改变它的大小。", "inputFormat": "第一行：一个字符串 $s$。\n\n第二行：一个整数 $n$。", "outputFormat": "一行一个整数表示最少的加法次数让 $s$ 等于 $n$。如果怎么做都不能让 $s$ 等于 $n$ ，则输出 $-1$。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1\\le \\operatorname{len}(s)\\le40$，$1 \\leq n\\le10^5$。", "locale": "zh-CN"}}}
{"pid": "P1875", "type": "P", "difficulty": 4, "samples": [["7 \n10 5 6 3 2 2 3 \n1 2 0 \n4 5 1 \n3 6 2\n", "10 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["图论", "最短路"], "title": "佳佳的魔法药水【数据有误】", "background": "**存在 ab 相同 c 不同的情况，与题意相悖。题还是可以做，但数据待修正。**\n\n发完了 $k$ 张照片，佳佳却得到了一个坏消息：他的 MM 得病了！佳佳和大家一样焦急万分！治好 MM 的病只有一种办法，那就是传说中的 $0$ 号药水……怎么样才能得到 $0$ 号药水呢？你要知道佳佳的家境也不是很好，成本得足够低才行……", "description": "得到一种药水有两种方法：可以按照魔法书上的指导自己配置，也可以到魔法商店里去买——那里对于每种药水都有供应，虽然有可能价格很贵。在魔法书上有很多这样的记载：\n\n$1$ 份 A 药水混合 $1$ 份 B 药水就可以得到 $1$ 份 C 药水。（至于为什么 $1 + 1 = 1$，因为……这是魔法世界）好了，现在你知道了需要得到某种药水，还知道所有可能涉及到的药水的价格以及魔法书上所有的配置方法，现在要问的就是：\n\n1. 最少花多少钱可以配制成功这种珍贵的药水；\n2. 共有多少种不同的花费最少的方案（两种可行的配置方案如果有任何一个步骤不同则视为不同的）。假定初始时你手中并没有任何可以用的药水。", "inputFormat": "第一行有一个整数 $N$（$1 \\le N \\le 1000$），表示一共涉及到的药水总数。药水从 $0 \\sim N-1$ 顺序编号，$0$ 号药水就是最终要配制的药水。\n\n第二行有 $N$ 个整数，分别表示从 $0 \\sim N-1$ 顺序编号的所有药水在魔法商店的价格（都表示 $1$ 份的价格）。\n\n第三行开始，每行有三个整数 A、B、C，表示 $1$ 份 A 药水混合 $1$ 份 B 药水就可以得到 $1$ 份 C 药水。注意，某两种特定的药水搭配如果能配成新药水的话，那么结果是唯一的。也就是说不会出现某两行的 A、B 相同但 C 不同的情况。\n\n输入以一个空行结束。", "outputFormat": "输出两个用空格隔开的整数，分别表示得到 $0$ 号药水的最小花费以及花费最少的方案的个数。\n\n保证方案数不超过 $2^{63} - 1$。", "hint": "数据范围：\n\n每一种药水的价格均在 $[1, 2.8\\times 10^4]$ 范围内。\n\n样例说明：\n\n最优方案有 $3$ 种，分别是：\n\n- 直接买 $0$ 号药水；\n- 买 $4$ 号药水、$5$ 号药水配制成 $1$ 号药水，直接买 $2$ 号药水，然后配制成 $0$ 号药水；\n- 买 $4$ 号药水、$5$ 号药水配制成 $1$ 号药水，买 $3$ 号药水、$6$ 号药水配制成 $2$ 号药水，然后配制成 $0$ 号药水。", "locale": "zh-CN", "translations": {"en": {"title": "Jiajia's Magic Potion [Data Error]", "background": "**There exist cases where $a$, $b$ are the same but $c$ is different, which contradicts the statement. The problem is still solvable, but the testdata needs correction.**\n\nAfter sending $k$ photos, Jiajia received bad news: his MM got sick! Jiajia, like everyone else, is extremely anxious! There is only one way to cure MM’s illness, and that is the legendary potion No. $0$... How can we obtain potion No. $0$? You know Jiajia’s family is not well-off, so the cost must be low enough...", "description": "There are two ways to obtain a potion: you can either configure it yourself according to the magic book, or buy it at the magic shop — every kind of potion is available there, though the price may be high. The magic book contains many notes like this:\n\nMixing $1$ unit of potion A with $1$ unit of potion B yields $1$ unit of potion C. (As for why $1 + 1 = 1$, well... this is the magic world.) Now, you know which potion you need, you also know the prices of all potions that may be involved and all recipes in the magic book. The questions are:\n\n1. What is the minimum cost to successfully produce this precious potion?\n2. How many different minimum-cost plans are there (two feasible configuration plans are considered different if any step differs)? Assume you initially have no usable potion.", "inputFormat": "The first line contains an integer $N$ ($1 \\le N \\le 1000$), the total number of potions involved. Potions are numbered from $0$ to $N - 1$, and potion No. $0$ is the final target potion.\n\nThe second line contains $N$ integers, giving the prices (for $1$ unit each) of all potions numbered from $0$ to $N - 1$ in order at the magic shop.\n\nFrom the third line onward, each line contains three integers A, B, C, meaning mixing $1$ unit of potion A with $1$ unit of potion B yields $1$ unit of potion C. Note that if a specific pair of potions can be mixed to form a new potion, the result is unique. In other words, there will not be two lines where A and B are the same but C is different.\n\nThe input ends with a blank line.", "outputFormat": "Output two integers separated by a space, representing the minimum cost to obtain potion No. $0$ and the number of minimum-cost plans.\n\nIt is guaranteed that the number of plans does not exceed $2^{63} - 1$.", "hint": "Constraints:\n\nThe price of each potion is within $[1, 2.8\\times 10^4]$.\n\nSample explanation:\n\nThere are $3$ optimal plans:\n\n- Buy potion No. $0$ directly.\n- Buy potion No. $4$ and potion No. $5$ to make potion No. $1$, buy potion No. $2$ directly, then combine to make potion No. $0$.\n- Buy potion No. $4$ and potion No. $5$ to make potion No. $1$, buy potion No. $3$ and potion No. $6$ to make potion No. $2$, then combine to make potion No. $0$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "佳佳的魔法药水【数据有误】", "background": "**存在 ab 相同 c 不同的情况，与题意相悖。题还是可以做，但数据待修正。**\n\n发完了 $k$ 张照片，佳佳却得到了一个坏消息：他的 MM 得病了！佳佳和大家一样焦急万分！治好 MM 的病只有一种办法，那就是传说中的 $0$ 号药水……怎么样才能得到 $0$ 号药水呢？你要知道佳佳的家境也不是很好，成本得足够低才行……", "description": "得到一种药水有两种方法：可以按照魔法书上的指导自己配置，也可以到魔法商店里去买——那里对于每种药水都有供应，虽然有可能价格很贵。在魔法书上有很多这样的记载：\n\n$1$ 份 A 药水混合 $1$ 份 B 药水就可以得到 $1$ 份 C 药水。（至于为什么 $1 + 1 = 1$，因为……这是魔法世界）好了，现在你知道了需要得到某种药水，还知道所有可能涉及到的药水的价格以及魔法书上所有的配置方法，现在要问的就是：\n\n1. 最少花多少钱可以配制成功这种珍贵的药水；\n2. 共有多少种不同的花费最少的方案（两种可行的配置方案如果有任何一个步骤不同则视为不同的）。假定初始时你手中并没有任何可以用的药水。", "inputFormat": "第一行有一个整数 $N$（$1 \\le N \\le 1000$），表示一共涉及到的药水总数。药水从 $0 \\sim N-1$ 顺序编号，$0$ 号药水就是最终要配制的药水。\n\n第二行有 $N$ 个整数，分别表示从 $0 \\sim N-1$ 顺序编号的所有药水在魔法商店的价格（都表示 $1$ 份的价格）。\n\n第三行开始，每行有三个整数 A、B、C，表示 $1$ 份 A 药水混合 $1$ 份 B 药水就可以得到 $1$ 份 C 药水。注意，某两种特定的药水搭配如果能配成新药水的话，那么结果是唯一的。也就是说不会出现某两行的 A、B 相同但 C 不同的情况。\n\n输入以一个空行结束。", "outputFormat": "输出两个用空格隔开的整数，分别表示得到 $0$ 号药水的最小花费以及花费最少的方案的个数。\n\n保证方案数不超过 $2^{63} - 1$。", "hint": "数据范围：\n\n每一种药水的价格均在 $[1, 2.8\\times 10^4]$ 范围内。\n\n样例说明：\n\n最优方案有 $3$ 种，分别是：\n\n- 直接买 $0$ 号药水；\n- 买 $4$ 号药水、$5$ 号药水配制成 $1$ 号药水，直接买 $2$ 号药水，然后配制成 $0$ 号药水；\n- 买 $4$ 号药水、$5$ 号药水配制成 $1$ 号药水，买 $3$ 号药水、$6$ 号药水配制成 $2$ 号药水，然后配制成 $0$ 号药水。", "locale": "zh-CN"}}}
{"pid": "P1876", "type": "P", "difficulty": 1, "samples": [["5", "1 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "数学"], "title": "开灯", "background": "该题的题目是不是感到很眼熟呢?\n\n事实上，如果你懂的方法，该题的代码简直不能再短。\n\n但是如果你不懂得呢？那。。。（自己去想）", "description": "首先所有的灯都是关的（注意是关！），编号为 $1$ 的人走过来，把是 $1$ 的倍数的灯全部打开，编号为 $2$ 的人把是 $2$ 的倍数的灯全部关上，编号为 $3$ 的人又把是 $3$ 的倍数的灯开的关上，关的开起来……直到第 $N$ 个人为止。\n\n给定 $N$，求 $N$ 轮之后，还有哪几盏是开着的。", "inputFormat": "一个数 $N$，表示灯的个数和操作的轮数。", "outputFormat": "若干数，表示开着的电灯编号。", "hint": "**【数据范围】**\n\n对于 $100 \\%$ 的数据，$1 \\le N \\le 2^{40}$。\n\n**【其他说明】**\n\n数学题！", "locale": "zh-CN", "translations": {"en": {"title": "Turning On the Lights", "background": "Does this problem title look familiar? In fact, if you know the method, the code could hardly be shorter. But if you don’t? Well... figure it out yourself.", "description": "At the start, all lights are off (note: off!). The person numbered $1$ comes and turns on all lights whose indices are multiples of $1$. The person numbered $2$ turns off all lights whose indices are multiples of $2$. The person numbered $3$ toggles all lights whose indices are multiples of $3$ (those that are on are turned off, those that are off are turned on), and so on, until the person numbered $N$ finishes.\n\nGiven $N$, after $N$ rounds, determine which lights are still on.", "inputFormat": "A single number $N$, representing both the number of lights and the number of rounds.", "outputFormat": "Several numbers, the indices of the lights that are on.", "hint": "Constraints\n\nFor $100 \\%$ of the testdata, $1 \\le N \\le 2^{40}$.\n\nAdditional Notes\n\nMath problem!\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "开灯", "background": "该题的题目是不是感到很眼熟呢?\n\n事实上，如果你懂的方法，该题的代码简直不能再短。\n\n但是如果你不懂得呢？那。。。（自己去想）", "description": "首先所有的灯都是关的（注意是关！），编号为 $1$ 的人走过来，把是 $1$ 的倍数的灯全部打开，编号为 $2$ 的人把是 $2$ 的倍数的灯全部关上，编号为 $3$ 的人又把是 $3$ 的倍数的灯开的关上，关的开起来……直到第 $N$ 个人为止。\n\n给定 $N$，求 $N$ 轮之后，还有哪几盏是开着的。", "inputFormat": "一个数 $N$，表示灯的个数和操作的轮数。", "outputFormat": "若干数，表示开着的电灯编号。", "hint": "**【数据范围】**\n\n对于 $100 \\%$ 的数据，$1 \\le N \\le 2^{40}$。\n\n**【其他说明】**\n\n数学题！", "locale": "zh-CN"}}}
{"pid": "P1877", "type": "P", "difficulty": 2, "samples": [["3 5 10\n5 3 7\n", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2012", "河南", "各省省选", "枚举", "背包 DP"], "title": "[HAOI2012] 音量调节", "background": null, "description": "一个吉他手准备参加一场演出。他不喜欢在演出时始终使用同一个音量，所以他决定每一首歌之前他都需要改变一次音量。在演出开始之前，他已经做好一个列表，里面写着每首歌开始之前他想要改变的音量是多少。每一次改变音量，他可以选择调高也可以调低。\n\n音量用一个整数描述。输入文件中整数 $beginLevel$，代表吉他刚开始的音量，整数 $maxLevel$，代表吉他的最大音量。音量不能小于 $0$ 也不能大于 $maxLevel$。输入中还给定了 $n$ 个整数 $c_1,c_2,c_3,\\cdots,c_n$，表示在第 $i$ 首歌开始之前吉他手想要改变的音量是多少。\n\n吉他手想以最大的音量演奏最后一首歌，你的任务是找到这个最大音量是多少。", "inputFormat": "第一行依次为三个整数 $n$，$beginLevel$ 和 $maxLevel$。\n\n第二行依次为 $n$ 个整数 $c_1,c_2,c_3,\\cdots,c_n$。", "outputFormat": "输出演奏最后一首歌的最大音量。如果吉他手无法避免音量低于 $0$ 或者高于 $maxLevel$，输出 `-1`。", "hint": "$1\\le n\\le 50$，$1\\le c_i\\le maxLevel$，$1\\le maxLevel\\le 1000$，$0\\le beginLevel\\le maxLevel$。", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2012] Volume Adjustment", "background": "", "description": "A guitarist is preparing for a performance. He does not like to use the same volume throughout the show, so he decides that before each song he will change the volume once. Before the show starts, he makes a list that records by how much he wants to change the volume before each song. Each time he changes the volume, he can either turn it up or turn it down.\n\nThe volume is described by an integer. In the input, the integer $beginLevel$ represents the guitar’s initial volume, and the integer $maxLevel$ represents the guitar’s maximum volume. The volume cannot be less than $0$ or greater than $maxLevel$. The input also gives $n$ integers $c_1,c_2,c_3,\\cdots,c_n$, which means that before the $i$-th song begins, the guitarist wants to change the volume by that amount.\n\nThe guitarist wants to play the last song at the highest possible volume; your task is to find that maximum volume.", "inputFormat": "The first line contains three integers $n$, $beginLevel$ and $maxLevel$.\n\nThe second line contains $n$ integers $c_1,c_2,c_3,\\cdots,c_n$.", "outputFormat": "Output the maximum possible volume for the last song. If the guitarist cannot avoid the volume going below $0$ or above $maxLevel$, output `-1`.", "hint": "$1\\le n\\le 50$, $1\\le c_i\\le maxLevel$, $1\\le maxLevel\\le 1000$, $0\\le beginLevel\\le maxLevel$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2012] 音量调节", "background": null, "description": "一个吉他手准备参加一场演出。他不喜欢在演出时始终使用同一个音量，所以他决定每一首歌之前他都需要改变一次音量。在演出开始之前，他已经做好一个列表，里面写着每首歌开始之前他想要改变的音量是多少。每一次改变音量，他可以选择调高也可以调低。\n\n音量用一个整数描述。输入文件中整数 $beginLevel$，代表吉他刚开始的音量，整数 $maxLevel$，代表吉他的最大音量。音量不能小于 $0$ 也不能大于 $maxLevel$。输入中还给定了 $n$ 个整数 $c_1,c_2,c_3,\\cdots,c_n$，表示在第 $i$ 首歌开始之前吉他手想要改变的音量是多少。\n\n吉他手想以最大的音量演奏最后一首歌，你的任务是找到这个最大音量是多少。", "inputFormat": "第一行依次为三个整数 $n$，$beginLevel$ 和 $maxLevel$。\n\n第二行依次为 $n$ 个整数 $c_1,c_2,c_3,\\cdots,c_n$。", "outputFormat": "输出演奏最后一首歌的最大音量。如果吉他手无法避免音量低于 $0$ 或者高于 $maxLevel$，输出 `-1`。", "hint": "$1\\le n\\le 50$，$1\\le c_i\\le maxLevel$，$1\\le maxLevel\\le 1000$，$0\\le beginLevel\\le maxLevel$。", "locale": "zh-CN"}}}
{"pid": "P1878", "type": "P", "difficulty": 3, "samples": [["4\r\nBGBG\r\n4 2 4 3\r\n", "2\r\n3 4\r\n1 2\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["堆", "链表"], "title": "舞蹈课", "background": null, "description": "有 $n$ 个人参加一个舞蹈课。每个人的舞蹈技术由整数来决定。在舞蹈课的开始，他们从左到右站成一排。当这一排中至少有一对相邻的异性时，舞蹈技术相差最小的那一对会出列并开始跳舞。如果不止一对，那么最左边的那一对出列。一对异性出列之后，队伍中的空白按原顺序补上（即：若队伍为 `ABCD`，那么 `BC` 出列之后队伍变为 `AD`）。舞蹈技术相差最小即是 $a_i$ 的绝对值最小。\n\n任务是模拟以上过程，确定跳舞的配对及顺序。", "inputFormat": "第一行一个正整数 $n$ 表示队伍中的人数。\n\n第二行包含 $n$ 个字符 `B` 或者 `G`，`B` 代表男，`G` 代表女。\n\n第三行为 $n$ 个整数 $a_i$。所有信息按照从左到右的顺序给出。", "outputFormat": "第一行一个整数表示出列的总对数 $k$。\n\n接下来 $k$ 行，每行是两个整数。按跳舞顺序输出，两个整数代表这一对舞伴的编号（按输入顺序从左往右 $1$ 至 $n$ 编号）。请先输出较小的整数，再输出较大的整数。", "hint": "对于 $50\\%$ 的数据，$1\\leq n\\leq 200$。\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 2\\times 10^5$，$0\\le a_i\\le 10^7$。", "locale": "zh-CN", "translations": {"en": {"title": "Dance Class", "background": "", "description": "There are $n$ people attending a dance class. Each person’s dance skill is represented by an integer. At the beginning of the class, they stand in a line from left to right. Whenever there is at least one adjacent opposite-gender pair in the line, the pair with the smallest difference in dance skill will leave the line to start dancing. If multiple pairs have the same minimal difference, the leftmost such pair leaves. After a pair leaves, the gap in the line is closed while preserving the original order (that is, if the line is `ABCD`, then after `BC` leaves, the line becomes `AD`). Here, “smallest difference” means the absolute difference of their skill values is minimal, i.e., minimize $|a_i - a_j|$.\n\nYour task is to simulate the process and determine the dancing pairs and their order.", "inputFormat": "The first line contains a positive integer $n$ denoting the number of people in the line.\n\nThe second line contains $n$ characters `B` or `G`, where `B` denotes a boy and `G` denotes a girl.\n\nThe third line contains $n$ integers $a_i$. All information is given in left-to-right order.", "outputFormat": "The first line contains an integer $k$ denoting the total number of pairs that leave the line.\n\nThen output $k$ lines, each containing two integers. Print the pairs in the order they start dancing; each line contains the indices of the two partners (numbered from $1$ to $n$ in the left-to-right input order). Print the smaller index first, then the larger.", "hint": "For $50\\%$ of the testdata, $1 \\le n \\le 200$.\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 2 \\times 10^5$, $0 \\le a_i \\le 10^7$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "舞蹈课", "background": null, "description": "有 $n$ 个人参加一个舞蹈课。每个人的舞蹈技术由整数来决定。在舞蹈课的开始，他们从左到右站成一排。当这一排中至少有一对相邻的异性时，舞蹈技术相差最小的那一对会出列并开始跳舞。如果不止一对，那么最左边的那一对出列。一对异性出列之后，队伍中的空白按原顺序补上（即：若队伍为 `ABCD`，那么 `BC` 出列之后队伍变为 `AD`）。舞蹈技术相差最小即是 $a_i$ 的绝对值最小。\n\n任务是模拟以上过程，确定跳舞的配对及顺序。", "inputFormat": "第一行一个正整数 $n$ 表示队伍中的人数。\n\n第二行包含 $n$ 个字符 `B` 或者 `G`，`B` 代表男，`G` 代表女。\n\n第三行为 $n$ 个整数 $a_i$。所有信息按照从左到右的顺序给出。", "outputFormat": "第一行一个整数表示出列的总对数 $k$。\n\n接下来 $k$ 行，每行是两个整数。按跳舞顺序输出，两个整数代表这一对舞伴的编号（按输入顺序从左往右 $1$ 至 $n$ 编号）。请先输出较小的整数，再输出较大的整数。", "hint": "对于 $50\\%$ 的数据，$1\\leq n\\leq 200$。\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 2\\times 10^5$，$0\\le a_i\\le 10^7$。", "locale": "zh-CN"}}}
{"pid": "P1879", "type": "P", "difficulty": 5, "samples": [["2 3\n1 1 1\n0 1 0", "9\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2006", "USACO", "枚举", "轮廓线 DP", "状压 DP"], "title": "[USACO06NOV] Corn Fields G", "background": null, "description": "农场主 $\\rm John$ 新买了一块长方形的新牧场，这块牧场被划分成 $M$ 行 $N$ 列 $(1 \\le M \\le 12, 1 \\le  N \\le 12)$，每一格都是一块正方形的土地。 $\\rm John$ 打算在牧场上的某几格里种上美味的草，供他的奶牛们享用。\n\n遗憾的是，有些土地相当贫瘠，不能用来种草。并且，奶牛们喜欢独占一块草地的感觉，于是 $\\rm John$ 不会选择两块相邻的土地，也就是说，没有哪两块草地有公共边。\n\n$\\rm John$ 想知道，如果不考虑草地的总块数，那么，一共有多少种种植方案可供他选择？（当然，把新牧场完全荒废也是一种方案）", "inputFormat": "第一行：两个整数 $M$ 和 $N$，用空格隔开。\n\n第 $2$ 到第 $M+1$ 行：每行包含 $N$ 个用空格隔开的整数，描述了每块土地的状态。第 $i+1$ 行描述了第 $i$ 行的土地，所有整数均为 $0$ 或 $1$ ，是 $1$ 的话，表示这块土地足够肥沃，$0$ 则表示这块土地不适合种草。", "outputFormat": "一个整数，即牧场分配总方案数除以 $10^8$ 的余数。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "Corn Fields G", "background": null, "description": "Farmer John has purchased a lush new rectangular pasture composed of $M$ by $N$ ($1 \\le M \\le 12,1 \\le N \\le 12$) square parcels. He wants to grow some yummy corn for the cows on a number of squares. Regrettably, some of the squares are infertile and can't be planted. Canny FJ knows that the cows dislike eating close to each other, so when choosing which squares to plant, he avoids choosing squares that are adjacent; no two chosen squares share an edge. He has not yet made the final choice as to which squares to plant.\n\nBeing a very open-minded man, Farmer John wants to consider all possible options for how to choose the squares for planting. He is so open-minded that he considers choosing no squares as a valid option! Please help Farmer John determine the number of ways he can choose the squares to plant.", "inputFormat": "The first line contains two integers $M$ and $N$, separated by a space.\n\nThen there follow $M$ lines,each of them contains $N$ integers.All integers are either $0$ or $1$. If $1$, it indicates that the land is fertile enough, while $0$ indicates that the land is infertile.", "outputFormat": "An integer, which is the remainder of dividing the total number of ranch allocation plans by $10^8$.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO06NOV] Corn Fields G", "background": null, "description": "农场主 $\\rm John$ 新买了一块长方形的新牧场，这块牧场被划分成 $M$ 行 $N$ 列 $(1 \\le M \\le 12, 1 \\le  N \\le 12)$，每一格都是一块正方形的土地。 $\\rm John$ 打算在牧场上的某几格里种上美味的草，供他的奶牛们享用。\n\n遗憾的是，有些土地相当贫瘠，不能用来种草。并且，奶牛们喜欢独占一块草地的感觉，于是 $\\rm John$ 不会选择两块相邻的土地，也就是说，没有哪两块草地有公共边。\n\n$\\rm John$ 想知道，如果不考虑草地的总块数，那么，一共有多少种种植方案可供他选择？（当然，把新牧场完全荒废也是一种方案）", "inputFormat": "第一行：两个整数 $M$ 和 $N$，用空格隔开。\n\n第 $2$ 到第 $M+1$ 行：每行包含 $N$ 个用空格隔开的整数，描述了每块土地的状态。第 $i+1$ 行描述了第 $i$ 行的土地，所有整数均为 $0$ 或 $1$ ，是 $1$ 的话，表示这块土地足够肥沃，$0$ 则表示这块土地不适合种草。", "outputFormat": "一个整数，即牧场分配总方案数除以 $10^8$ 的余数。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P1880", "type": "P", "difficulty": 4, "samples": [["4\n4 5 9 4", "43\n54"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "NOI", "区间 DP", "四边形不等式"], "title": "[NOI1995] 石子合并", "background": "", "description": "在一个圆形操场的四周摆放 $N$ 堆石子，现要将石子有次序地合并成一堆，规定每次只能选相邻的 $2$ 堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。\n\n试设计出一个算法,计算出将 $N$ 堆石子合并成 $1$ 堆的最小得分和最大得分。\n", "inputFormat": "数据的第 $1$ 行是正整数 $N$，表示有 $N$ 堆石子。\n\n第 $2$ 行有 $N$ 个整数，第 $i$ 个整数 $a_i$ 表示第 $i$ 堆石子的个数。\n", "outputFormat": "输出共 $2$ 行，第 $1$ 行为最小得分，第 $2$ 行为最大得分。\n", "hint": "$1\\leq N\\leq 100$，$0\\leq a_i\\leq 20$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI1995] Merging Stones", "background": "", "description": "Along the circumference of a circular track, there are $N$ piles of stones. We want to merge the stones into one pile in some order. Each time, we can only choose two adjacent piles and merge them into a new pile; the number of stones in the new pile is recorded as the score for that merge.\n\nDesign an algorithm to compute the minimal total score and the maximal total score for merging $N$ piles into $1$ pile.", "inputFormat": "The first line contains the positive integer $N$, the number of piles.\n\nThe second line contains $N$ integers; the $i$-th integer $a_i$ denotes the number of stones in the $i$-th pile.", "outputFormat": "Output a total of $2$ lines. The first line is the minimal total score, and the second line is the maximal total score.", "hint": "Constraints: $1 \\leq N \\leq 100$, $0 \\leq a_i \\leq 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI1995] 石子合并", "background": "", "description": "在一个圆形操场的四周摆放 $N$ 堆石子，现要将石子有次序地合并成一堆，规定每次只能选相邻的 $2$ 堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。\n\n试设计出一个算法,计算出将 $N$ 堆石子合并成 $1$ 堆的最小得分和最大得分。\n", "inputFormat": "数据的第 $1$ 行是正整数 $N$，表示有 $N$ 堆石子。\n\n第 $2$ 行有 $N$ 个整数，第 $i$ 个整数 $a_i$ 表示第 $i$ 堆石子的个数。\n", "outputFormat": "输出共 $2$ 行，第 $1$ 行为最小得分，第 $2$ 行为最大得分。\n", "hint": "$1\\leq N\\leq 100$，$0\\leq a_i\\leq 20$。", "locale": "zh-CN"}}}
{"pid": "P1881", "type": "P", "difficulty": 2, "samples": [["5 10\r\n0 \r\n10 \r\n6 \r\n2 \r\n4\r\n", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["枚举"], "title": "绳子对折", "background": null, "description": "FJ 有一个长度为 $L$（$1 \\le L \\le 10,000$）的绳子。这个绳子上有 $N$（$1 \\le N \\le 100$）个结，包括两个端点。FJ 想将绳子对折，并使较短一边的绳子上的结与较长一边绳子上的结完全重合，如图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1spqhchu.png)\n\n找出 FJ 有多少种可行的折叠方案。", "inputFormat": "第一行：两个整数，$N$ 和 $L$。\n\n第 $2$ 至 $N+1$ 行：每一行包含一个整数表示一个结所在的位置，总有两个数为 $0$ 和 $L$。", "outputFormat": "第一行：一个整数表示 FJ 可折叠的方案数。", "hint": "(可在 1,2,3,8 点处折叠)", "locale": "zh-CN", "translations": {"en": {"title": "Folding the Rope", "background": "", "description": "FJ has a rope of length $L$ ($1 \\le L \\le 10,000$). There are $N$ ($1 \\le N \\le 100$) knots on the rope, including the two endpoints. FJ wants to fold the rope so that the knots on the shorter side coincide exactly with the knots on the longer side, as shown in the figure:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1spqhchu.png)\n\nFind how many valid folding positions FJ can choose.", "inputFormat": "The first line: two integers, $N$ and $L$.\n\nLines $2$ to $N+1$: each line contains one integer giving the position of a knot. Among them, $0$ and $L$ are always included.", "outputFormat": "The first line: one integer, the number of valid folding positions.", "hint": "(You can fold at positions 1, 2, 3, and 8.)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "绳子对折", "background": null, "description": "FJ 有一个长度为 $L$（$1 \\le L \\le 10,000$）的绳子。这个绳子上有 $N$（$1 \\le N \\le 100$）个结，包括两个端点。FJ 想将绳子对折，并使较短一边的绳子上的结与较长一边绳子上的结完全重合，如图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1spqhchu.png)\n\n找出 FJ 有多少种可行的折叠方案。", "inputFormat": "第一行：两个整数，$N$ 和 $L$。\n\n第 $2$ 至 $N+1$ 行：每一行包含一个整数表示一个结所在的位置，总有两个数为 $0$ 和 $L$。", "outputFormat": "第一行：一个整数表示 FJ 可折叠的方案数。", "hint": "(可在 1,2,3,8 点处折叠)", "locale": "zh-CN"}}}
{"pid": "P1882", "type": "P", "difficulty": 3, "samples": [["5\n4 2 2 4\n3 3 1 3 4\n7 1 5\n4 2 3 5\n1 0", "14"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": [], "title": "接力赛跑", "background": "", "description": "$N (1\\le N\\le 1000)$ 只奶牛（编号为 $1$ 到 $N$）在进行一个特别的接力赛跑，这个比赛特别之处在于，若干只奶牛可以同时跑。\n\n在 $t=0$ 时刻，牛 $1$ 开始沿着跑道跑。\n\n通常，牛 $i$ 跑完一圈需要的时间为 $L_i (1\\le L_i\\le 1000)$ 秒。当它重新越过起点线的瞬间，它会通知另外 $M_i (1\\le M_i\\le N)$ 只奶牛 $A_{ij} (1\\le j\\le M_i)$ 起跑。注意可能出现 $M_i=0$ 并且 $A_i$ 不存在的情况。\n\n每一只开始赛跑的奶牛，等到它回到起点时，都会通知其他奶牛起跑。可能出现多只奶牛通知同一只奶牛起跑的情况，但是每一只奶牛只愿意跑一圈，所以它被第二次叫到的时候就不愿意再跑了。\n\n农场主希望你帮他确定总的赛跑时间（也就是从比赛开始到最后一只奶牛越过终点的时间）。", "inputFormat": "第一行一个整数 $N$，表示参赛的牛的数量。\n\n第 $2$ 行到第 $N+1$ 行：第 $i+1$ 行包含多个用空格隔开的整数：$L_i$、$M_i$ 和 $M_i$ 个整数 $A_{ij}$。", "outputFormat": "一个整数，表示整个比赛结束的时间。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Relay Race", "background": "", "description": "There are $N (1\\le N\\le 1000)$ cows (numbered from $1$ to $N$) participating in a special relay race, where multiple cows are allowed to run simultaneously.\n\nAt time $t=0$, cow $1$ starts running along the track.\n\nNormally, cow $i$ needs $L_i (1\\le L_i\\le 1000)$ seconds to complete one lap. At the instant it crosses the start line again, it will notify $M_i (1\\le M_i\\le N)$ cows $A_{ij} (1\\le j\\le M_i)$ to start. Note that it is possible that $M_i=0$ and the list $A_i$ does not exist.\n\nEvery cow that starts racing will, upon returning to the start line, notify other cows to start. It is possible that multiple cows notify the same cow to start, but each cow is willing to run only one lap, so any cow starts at most once.\n\nThe farmer wants you to determine the total race time (that is, from the race start to the moment when the last cow crosses the finish line).", "inputFormat": "The first line contains an integer $N$, the number of participating cows.\n\nLines $2$ to $N+1$: line $i+1$ contains multiple space-separated integers: $L_i$, $M_i$, and $M_i$ integers $A_{ij}$.", "outputFormat": "Output a single integer, the time when the entire race ends.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "接力赛跑", "background": "", "description": "$N (1\\le N\\le 1000)$ 只奶牛（编号为 $1$ 到 $N$）在进行一个特别的接力赛跑，这个比赛特别之处在于，若干只奶牛可以同时跑。\n\n在 $t=0$ 时刻，牛 $1$ 开始沿着跑道跑。\n\n通常，牛 $i$ 跑完一圈需要的时间为 $L_i (1\\le L_i\\le 1000)$ 秒。当它重新越过起点线的瞬间，它会通知另外 $M_i (1\\le M_i\\le N)$ 只奶牛 $A_{ij} (1\\le j\\le M_i)$ 起跑。注意可能出现 $M_i=0$ 并且 $A_i$ 不存在的情况。\n\n每一只开始赛跑的奶牛，等到它回到起点时，都会通知其他奶牛起跑。可能出现多只奶牛通知同一只奶牛起跑的情况，但是每一只奶牛只愿意跑一圈，所以它被第二次叫到的时候就不愿意再跑了。\n\n农场主希望你帮他确定总的赛跑时间（也就是从比赛开始到最后一只奶牛越过终点的时间）。", "inputFormat": "第一行一个整数 $N$，表示参赛的牛的数量。\n\n第 $2$ 行到第 $N+1$ 行：第 $i+1$ 行包含多个用空格隔开的整数：$L_i$、$M_i$ 和 $M_i$ 个整数 $A_{ij}$。", "outputFormat": "一个整数，表示整个比赛结束的时间。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1883", "type": "P", "difficulty": 3, "samples": [["2\n1\n2 0 0\n2\n2 0 0\n2 -4 2\n", "0.0000\n0.5000\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["搜索", "2010", "二分", "三分", "ICPC", "模板题"], "title": "【模板】三分 / 函数 / [ICPC-Chengdu 2010] Error Curves", "background": null, "description": "给定 $n$ 个二次函数 $f_1(x),f_2(x),\\dots,f_n(x)$（均形如 $ax^2+bx+c$），设 $F(x)=\\max\\{f_1(x),f_2(x),...,f_n(x)\\}$，求 $F(x)$ 在区间 $[0,1000]$ 上的最小值。", "inputFormat": "输入第一行为正整数 $T$，表示有 $T$ 组数据。\n\n每组数据第一行一个正整数 $n$，接着 $n$ 行，每行 $3$ 个整数 $a,b,c$，用来表示每个二次函数的 $3$ 个系数，注意二次函数有可能退化成一次。", "outputFormat": "每组数据输出一行，表示 $F(x)$ 的在区间 $[0,1000]$ 上的最小值。答案精确到小数点后四位，四舍五入。", "hint": "对于 $50\\%$ 的数据，$n\\le 100$。\n\n对于 $100\\%$ 的数据，$T\\le 10$，$n\\le 10^4$，$0\\le a\\le 100$，$|b| \\le 5\\times 10^3$，$|c| \\le 5\\times 10^3$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Ternary Search / Function / [ICPC-Chengdu 2010] Error Curves", "background": null, "description": "Given $n$ quadratic functions $f_1(x), f_2(x), \\dots, f_n(x)$ (each of the form $ax^2+bx+c$), let $F(x)=\\max\\{f_1(x),f_2(x),...,f_n(x)\\}$. Find the minimum value of $F(x)$ on the interval $[0, 1000]$.", "inputFormat": "The first line contains a positive integer $T$, the number of test cases.\n\nFor each test case, the first line contains a positive integer $n$. Then $n$ lines follow, each with $3$ integers $a, b, c$ representing the three coefficients of a quadratic function. Note that a quadratic function may degenerate into a linear function.", "outputFormat": "For each test case, output one line with the minimum value of $F(x)$ on the interval $[0, 1000]$. The answer should be rounded to $4$ decimal places.", "hint": "For $50\\%$ of the testdata, $n \\le 100$.\n\nFor $100\\%$ of the testdata, $T < 10$, $n \\le 10^4$, $0 \\le a \\le 100$, $|b| \\le 5 \\times 10^3$, $|c| \\le 5 \\times 10^3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】三分 / 函数 / [ICPC-Chengdu 2010] Error Curves", "background": null, "description": "给定 $n$ 个二次函数 $f_1(x),f_2(x),\\dots,f_n(x)$（均形如 $ax^2+bx+c$），设 $F(x)=\\max\\{f_1(x),f_2(x),...,f_n(x)\\}$，求 $F(x)$ 在区间 $[0,1000]$ 上的最小值。", "inputFormat": "输入第一行为正整数 $T$，表示有 $T$ 组数据。\n\n每组数据第一行一个正整数 $n$，接着 $n$ 行，每行 $3$ 个整数 $a,b,c$，用来表示每个二次函数的 $3$ 个系数，注意二次函数有可能退化成一次。", "outputFormat": "每组数据输出一行，表示 $F(x)$ 的在区间 $[0,1000]$ 上的最小值。答案精确到小数点后四位，四舍五入。", "hint": "对于 $50\\%$ 的数据，$n\\le 100$。\n\n对于 $100\\%$ 的数据，$T\\le 10$，$n\\le 10^4$，$0\\le a\\le 100$，$|b| \\le 5\\times 10^3$，$|c| \\le 5\\times 10^3$。", "locale": "zh-CN"}}}
