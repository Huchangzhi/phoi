{"pid": "P14605", "type": "P", "difficulty": 2, "samples": [["42 2", "4 2"], ["2025225 9", "2025 225"], ["239239239 1001", "239239 239"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2025] Faulty Fraction", "background": "", "description": "Felix is studying basic arithmetic at school. Today he learned division. As a final task, he calculated the result of the division of a positive integer $a$ by a positive integer $b$. The result was a positive integer $c$, since $a$ was divisible by $b$. Felix wrote $a \\div b = c$ in his notebook and went outside to play football.\n\nHis little sister Fiona had been watching his studies with great interest. When Felix left, she decided to play a little trick on him: she took his notebook and erased the $\\div$ sign from the equation. As a result, the left-hand side of the equation became a single string of digits $s$.\n\nOnce Felix came back, he saw $s = c$ in his notebook. Unfortunately, he forgot the original values of $a$ and~$b$. Now he needs to split $s$ back into two parts using the $\\div$ sign to restore a correct division equation.\n\nHelp Felix find positive integers $a$ and $b$ such that $s$ is the concatenation of the decimal representations of $a$ and $b$, and $a \\div b = c$.", "inputFormat": "The only line contains a string of digits $s$ and an integer $c$. Both $s$ and $c$ consist of at least $1$ and at most $10^5$ digits and do not have leading zeros.\n\nIt is guaranteed that $s$ is a concatenation of two positive integers $a$ and $b$ written without leading zeros such that $a \\div b = c$.", "outputFormat": "Print two positive integers $a$ and $b$ without leading zeros such that $s$ is the concatenation of $a$ and $b$, and $a \\div b = c$. If there are multiple answers, print any of them.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NWRRC 2025] Faulty Fraction", "background": "", "description": "Felix is studying basic arithmetic at school. Today he learned division. As a final task, he calculated the result of the division of a positive integer $a$ by a positive integer $b$. The result was a positive integer $c$, since $a$ was divisible by $b$. Felix wrote $a \\div b = c$ in his notebook and went outside to play football.\n\nHis little sister Fiona had been watching his studies with great interest. When Felix left, she decided to play a little trick on him: she took his notebook and erased the $\\div$ sign from the equation. As a result, the left-hand side of the equation became a single string of digits $s$.\n\nOnce Felix came back, he saw $s = c$ in his notebook. Unfortunately, he forgot the original values of $a$ and~$b$. Now he needs to split $s$ back into two parts using the $\\div$ sign to restore a correct division equation.\n\nHelp Felix find positive integers $a$ and $b$ such that $s$ is the concatenation of the decimal representations of $a$ and $b$, and $a \\div b = c$.", "inputFormat": "The only line contains a string of digits $s$ and an integer $c$. Both $s$ and $c$ consist of at least $1$ and at most $10^5$ digits and do not have leading zeros.\n\nIt is guaranteed that $s$ is a concatenation of two positive integers $a$ and $b$ written without leading zeros such that $a \\div b = c$.", "outputFormat": "Print two positive integers $a$ and $b$ without leading zeros such that $s$ is the concatenation of $a$ and $b$, and $a \\div b = c$. If there are multiple answers, print any of them.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2025] Faulty Fraction", "background": "", "description": "Felix 正在学校学习基础算术。今天他学习了除法。作为最终任务，他计算了一个正整数 $a$ 除以一个正整数 $b$ 的结果。由于 $a$ 能被 $b$ 整除，结果是一个正整数 $c$。Felix 在笔记本上写下 $a \\div b = c$，然后出去踢足球了。\n\n他的妹妹 Fiona 一直非常感兴趣地观察他的学习。当 Felix 离开后，她决定跟他开个小玩笑：她拿起他的笔记本，从等式中擦除了 $\\div$ 符号。结果，等式的左边变成了一个数字字符串 $s$。\n\n当 Felix 回来时，他在笔记本上看到了 $s = c$。不幸的是，他忘记了 $a$ 和 $b$ 的原始值。现在他需要通过插入 $\\div$ 符号将 $s$ 分割成两部分，以恢复正确的除法等式。\n\n请帮助 Felix 找到正整数 $a$ 和 $b$，使得 $s$ 是 $a$ 和 $b$ 的十进制表示的连接，且 $a \\div b = c$。", "inputFormat": "仅一行包含一个数字字符串 $s$ 和一个整数 $c$。$s$ 和 $c$ 都至少包含 $1$ 个、最多包含 $10^5$ 个数字，且没有前导零。\n\n保证 $s$ 是两个没有前导零的正整数 $a$ 和 $b$ 的连接，且满足 $a \\div b = c$。", "outputFormat": "输出两个没有前导零的正整数 $a$ 和 $b$，使得 $s$ 是 $a$ 和 $b$ 的连接，且 $a \\div b = c$。如果有多个答案，输出其中任意一个。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14606", "type": "P", "difficulty": 6, "samples": [["3\n2 1\n1 2\n3 3\n1 2\n2 3\n3 1\n8 10\n1 2\n1 4\n1 7\n5 2\n5 4\n5 7\n5 3\n2 6\n2 8\n6 8", "1 1\n-1\n3 3 6 6 6 2 6 2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2025] Games of Chess", "background": "", "description": "There are $n$ friends and $n$ houses in Chess City, both numbered from $1$ to $n$, where friend $i$ lives in house $i$. The houses are connected by $m$ bidirectional roads, forming a connected network.\n\nChess City also has $n$ virtual chess clubs, numbered from $1$ to $n$. Each friend must choose exactly one club to join. These choices do not need to be distinct, so some clubs might not have any members.\n\nWhen friend $i$ hosts a chess party, it is attended by every friend who belongs to the same club as friend $i$ and lives in a house directly connected to house $i$ by a road. The party is considered $\\textit{successful}$ if the total number of attendees, including friend $i$, is even; in this case, they can all play chess simultaneously.\n\nChoose a club for each friend so that every friend's party is successful, or report that it is impossible.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$, denoting the number of houses and the number of roads ($2 \\le n \\le 10^5$; $n - 1 \\le m \\le 2 \\cdot 10^5$).\n\nEach of the following $m$ lines contains two integers $u$ and $v$, describing a bidirectional road between houses $u$ and $v$ ($1 \\le u, v \\le n$; $u \\ne v$). No two houses are connected by more than one road. It is possible to get from any house to any other one using the roads.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$, and the sum of $m$ over all test cases does not exceed $2 \\cdot 10^5$.", "outputFormat": "For each test case, print a single integer $-1$ if it is impossible to assign a chess club to each friend so that every friend's party is successful.\n\nOtherwise, print $n$ integers $c_1, c_2, \\ldots, c_n$, where $c_i$ is the number of the chess club that friend $i$ should join ($1 \\le c_i \\le n$). If there are multiple answers, print any of them.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NWRRC 2025] Games of Chess", "background": "", "description": "There are $n$ friends and $n$ houses in Chess City, both numbered from $1$ to $n$, where friend $i$ lives in house $i$. The houses are connected by $m$ bidirectional roads, forming a connected network.\n\nChess City also has $n$ virtual chess clubs, numbered from $1$ to $n$. Each friend must choose exactly one club to join. These choices do not need to be distinct, so some clubs might not have any members.\n\nWhen friend $i$ hosts a chess party, it is attended by every friend who belongs to the same club as friend $i$ and lives in a house directly connected to house $i$ by a road. The party is considered $\\textit{successful}$ if the total number of attendees, including friend $i$, is even; in this case, they can all play chess simultaneously.\n\nChoose a club for each friend so that every friend's party is successful, or report that it is impossible.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$, denoting the number of houses and the number of roads ($2 \\le n \\le 10^5$; $n - 1 \\le m \\le 2 \\cdot 10^5$).\n\nEach of the following $m$ lines contains two integers $u$ and $v$, describing a bidirectional road between houses $u$ and $v$ ($1 \\le u, v \\le n$; $u \\ne v$). No two houses are connected by more than one road. It is possible to get from any house to any other one using the roads.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$, and the sum of $m$ over all test cases does not exceed $2 \\cdot 10^5$.", "outputFormat": "For each test case, print a single integer $-1$ if it is impossible to assign a chess club to each friend so that every friend's party is successful.\n\nOtherwise, print $n$ integers $c_1, c_2, \\ldots, c_n$, where $c_i$ is the number of the chess club that friend $i$ should join ($1 \\le c_i \\le n$). If there are multiple answers, print any of them.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2025] Games of Chess", "background": "", "description": "在象棋城有 $n$ 个朋友和 $n$ 栋房子，都从 $1$ 到 $n$ 编号，其中朋友 $i$ 住在房子 $i$。这些房子通过 $m$ 条双向道路连接，形成一个连通网络。\n\n象棋城还有 $n$ 个虚拟象棋俱乐部，编号从 $1$ 到 $n$。每个朋友必须选择恰好一个俱乐部加入。这些选择不必互不相同，因此有些俱乐部可能没有任何成员。\n\n当朋友 $i$ 举办象棋派对时，所有与朋友 $i$ 属于同一俱乐部且住在与房子 $i$ 直接通过道路连接的房子里的朋友都会参加。如果包括朋友 $i$ 在内的总参加人数是偶数，则该派对被认为是 **成功的**；在这种情况下，他们可以同时下象棋。\n\n请为每个朋友选择一个俱乐部，使得每个朋友的派对都成功，或者报告这是不可能的。", "inputFormat": "每个测试包含多个测试用例。第一行包含测试用例的数量 $t$（$1 \\le t \\le 10^4$）。接下来是测试用例的描述。\n\n每个测试用例的第一行包含两个整数 $n$ 和 $m$，分别表示房子的数量和道路的数量（$2 \\le n \\le 10^5$；$n - 1 \\le m \\le 2 \\cdot 10^5$）。\n\n接下来的 $m$ 行每行包含两个整数 $u$ 和 $v$，描述房子 $u$ 和 $v$ 之间的双向道路（$1 \\le u, v \\le n$；$u \\ne v$）。任意两栋房子之间最多由一条道路连接。可以通过道路从任何房子到达任何其他房子。\n\n保证所有测试用例的 $n$ 之和不超过 $10^5$，所有测试用例的 $m$ 之和不超过 $2 \\cdot 10^5$。", "outputFormat": "对于每个测试用例，如果无法为每个朋友分配一个象棋俱乐部使得每个朋友的派对都成功，则输出单个整数 $-1$。\n\n否则，输出 $n$ 个整数 $c_1, c_2, \\ldots, c_n$，其中 $c_i$ 是朋友 $i$ 应该加入的象棋俱乐部的编号（$1 \\le c_i \\le n$）。如果有多个答案，输出其中任意一个。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14607", "type": "P", "difficulty": 4, "samples": [["1 2\n12", "1 8"], ["4 5\n4\n12\n10\n20", "2 4 2\n5 8 4 2 2 4\n-1\n3 2 4 8"], ["1 16\n19956", "1 2048\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2025] High Score", "background": "", "description": "Hermione loves to play the following computer game, in which the player controls an unordered multiset of integers. Initially, the multiset is empty and the player's score is $0$. At any moment in the game, the multiset contains at most $k$ integers (not necessarily distinct). In one turn, the player can choose one of the following moves:\n\n- $\\textbf{Insert}$. Choose an integer $2$ or $4$ and insert it into the multiset. This move does not change the score, and it is only allowed if the size of the multiset before the move is strictly less than $k$.\n- $\\textbf{Merge}$. Choose an integer $x$ such that the multiset contains at least two copies of $x$. Remove two copies of $x$ from the multiset, and insert one copy of $2x$ into the multiset. This move adds the value $2x$ to the player's score.\n\nThe player can stop the game after any turn, at which point the player's score becomes final.\n\nHermione has been on vacation for the whole summer, and she hasn't played the game in a while. Today, she opened the game on her laptop and saw the leaderboard with the highest scores she's ever had: $h_1, h_2, \\ldots, h_n$ in some order. Now she is curious how she managed to achieve those scores.\n\nFor each $h_i$, find any multiset of integers that Hermione could have at the end of the game if her final score was $h_i$, or determine that it is impossible to achieve such a score.", "inputFormat": "The first line contains two integers $n$ and $k$, denoting the number of scores on the leaderboard and the maximum size of the multiset ($1 \\le n \\le 10^4$; $2 \\le k \\le 16$).\n\nEach of the next $n$ lines contains a single integer $h_i$, denoting a score on the leaderboard ($1 \\le h_i \\le 10^9$).", "outputFormat": "For each score $h_i$, print the final size of the multiset $s$, followed by $s$ integers describing the contents of the multiset in any order ($0 \\le s \\le k$). It must be possible to achieve the score $h_i$ with this multiset at the end of the game. If there are multiple answers, print any of them.\n\nIf it is impossible to have the score $h_i$ at the end of the game, print a single integer $-1$ instead.", "hint": "A possible sequence of moves for the first test is shown below:\n\n$$\\{\\} \\xrightarrow{\\texttt{insert 2}} \\{2\\} \\xrightarrow{\\texttt{insert 2}} \\{2, 2\\} \\xrightarrow[\\texttt{score += 4}]{\\texttt{merge, x = 2}} \\{4\\} \\xrightarrow{\\texttt{insert 4}} \\{4, 4\\} \\xrightarrow[\\texttt{score += 8}]{\\texttt{merge, x = 4}} \\{8\\} $$", "locale": "en", "translations": {"en": {"title": "[NWRRC 2025] High Score", "background": "", "description": "Hermione loves to play the following computer game, in which the player controls an unordered multiset of integers. Initially, the multiset is empty and the player's score is $0$. At any moment in the game, the multiset contains at most $k$ integers (not necessarily distinct). In one turn, the player can choose one of the following moves:\n\n- $\\textbf{Insert}$. Choose an integer $2$ or $4$ and insert it into the multiset. This move does not change the score, and it is only allowed if the size of the multiset before the move is strictly less than $k$.\n- $\\textbf{Merge}$. Choose an integer $x$ such that the multiset contains at least two copies of $x$. Remove two copies of $x$ from the multiset, and insert one copy of $2x$ into the multiset. This move adds the value $2x$ to the player's score.\n\nThe player can stop the game after any turn, at which point the player's score becomes final.\n\nHermione has been on vacation for the whole summer, and she hasn't played the game in a while. Today, she opened the game on her laptop and saw the leaderboard with the highest scores she's ever had: $h_1, h_2, \\ldots, h_n$ in some order. Now she is curious how she managed to achieve those scores.\n\nFor each $h_i$, find any multiset of integers that Hermione could have at the end of the game if her final score was $h_i$, or determine that it is impossible to achieve such a score.", "inputFormat": "The first line contains two integers $n$ and $k$, denoting the number of scores on the leaderboard and the maximum size of the multiset ($1 \\le n \\le 10^4$; $2 \\le k \\le 16$).\n\nEach of the next $n$ lines contains a single integer $h_i$, denoting a score on the leaderboard ($1 \\le h_i \\le 10^9$).", "outputFormat": "For each score $h_i$, print the final size of the multiset $s$, followed by $s$ integers describing the contents of the multiset in any order ($0 \\le s \\le k$). It must be possible to achieve the score $h_i$ with this multiset at the end of the game. If there are multiple answers, print any of them.\n\nIf it is impossible to have the score $h_i$ at the end of the game, print a single integer $-1$ instead.", "hint": "A possible sequence of moves for the first test is shown below:\n\n$$\\{\\} \\xrightarrow{\\texttt{insert 2}} \\{2\\} \\xrightarrow{\\texttt{insert 2}} \\{2, 2\\} \\xrightarrow[\\texttt{score += 4}]{\\texttt{merge, x = 2}} \\{4\\} \\xrightarrow{\\texttt{insert 4}} \\{4, 4\\} \\xrightarrow[\\texttt{score += 8}]{\\texttt{merge, x = 4}} \\{8\\} $$", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2025] High Score", "background": "", "description": "Hermione 喜欢玩以下电脑游戏，玩家在游戏中控制一个无序整数多重集合。初始时，多重集合为空，玩家得分为 $0$。在游戏的任何时刻，多重集合最多包含 $k$ 个整数（不一定互异）。在一个回合中，玩家可以选择以下操作之一：\n\n- **插入**。选择一个整数 $2$ 或 $4$ 并将其插入多重集合。此操作不改变得分，且仅当操作前多重集合的大小严格小于 $k$ 时才允许执行。\n- **合并**。选择一个整数 $x$，使得多重集合中至少包含两个 $x$ 的副本。从多重集合中移除两个 $x$ 的副本，并插入一个 $2x$ 的副本。此操作将值 $2x$ 加到玩家得分上。\n\n玩家可以在任何回合后停止游戏，此时玩家的得分成为最终得分。\n\nHermione 整个夏天都在度假，她已经有一段时间没玩这个游戏了。今天，她在笔记本电脑上打开游戏，看到了她曾经获得的最高分排行榜：$h_1, h_2, \\ldots, h_n$，以某种顺序排列。现在她很好奇自己是如何达到这些分数的。\n\n对于每个 $h_i$，找出 Hermione 在最终得分为 $h_i$ 时可能拥有的任意一个整数多重集合，或者确定无法达到这样的分数。", "inputFormat": "第一行包含两个整数 $n$ 和 $k$，分别表示排行榜上的分数数量和多重集合的最大大小（$1 \\le n \\le 10^4$；$2 \\le k \\le 16$）。\n\n接下来的 $n$ 行每行包含一个整数 $h_i$，表示排行榜上的一个分数（$1 \\le h_i \\le 10^9$）。\n", "outputFormat": "对于每个分数 $h_i$，输出多重集合的最终大小 $s$，后跟 $s$ 个以任意顺序描述多重集合内容的整数（$0 \\le s \\le k$）。必须能够以游戏结束时使用此多重集合达到分数 $h_i$。如果有多个答案，输出其中任意一个。\n\n如果无法在游戏结束时拥有分数 $h_i$，则输出单个整数 $-1$。", "hint": "第一个测试的可能操作序列如下所示：\n\n$$\\{\\} \\xrightarrow{\\texttt{插入 2}} \\{2\\} \\xrightarrow{\\texttt{插入 2}} \\{2, 2\\} \\xrightarrow[\\texttt{得分 += 4}]{\\texttt{合并, x = 2}} \\{4\\} \\xrightarrow{\\texttt{插入 4}} \\{4, 4\\} \\xrightarrow[\\texttt{得分 += 8}]{\\texttt{合并, x = 4}} \\{8\\} $$\n\n---\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14608", "type": "P", "difficulty": 6, "samples": [["2\n10 4\n3 5 8 4 6 7 1 10 2 9\n1 7\n7 10\n1 10\n3 4\n8 2\n1 2 3 4 5 6 7 8\n1 8\n1 8", "4\n3\n5\n1\n6\n12"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2025] Infection Investigation", "background": "", "description": "Isaac is a biologist who specializes in diagnosing viral diseases. The virus modifies the host genome (a sequence of genes) by altering it to suit its own needs. Isaac is writing a paper investigating viral infection in genomes. He has some samples and asks you to help analyze them.\n\nFor simplicity, we will assume that the viral genome consists of genes $1, 2, \\ldots, n$ in this order. The host genome is a permutation of genes $1, 2, \\ldots n$: it consists of genes $a_1, a_2, \\ldots, a_n$ in this order.\n\nConsider a genomic segment $[l; r]$ consisting of genes $a_l, a_{l+1}, \\ldots, a_r$. The infection level of this segment is measured as the length of the longest subsequence of genes shared with the viral genome. Formally, the infection level is the maximum $k$ such that there exist $l \\le i_1 < i_2 < \\dots < i_k \\le r$ for which the inequalities $a_{i_1} < a_{i_2} < \\dots < a_{i_{k}}$ hold.\n\nTo analyze the genome, Isaac needs to estimate the infection levels of $q$ genomic segments. To secure the funding, Isaac only needs approximate results: an error factor of up to $1.5$ is allowed.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $q$, denoting the host genome length and the number of genomic segments Isaac is interested in ($1 \\le n, q \\le 2 \\cdot 10^5$).\n\nThe second line contains $n$ distinct integers $a_1, a_2, \\ldots, a_n$, describing the host genome ($1 \\le a_i \\le n$).\n\nEach of the following $q$ lines contains two integers $l$ and $r$, denoting the boundaries of a genomic segment for which the infection level should be estimated ($1 \\le l \\le r \\le n$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2\\cdot 10^5$, and the sum of $q$ over all test cases does not exceed $2 \\cdot 10^5$.", "outputFormat": "For each test case, print $q$ positive integers, denoting the infection levels of the corresponding genomic segments.\n\nFor each genomic segment, let your answer be $x$ and let the true answer be $y$. Your answer will be considered correct if it differs from the true answer by a factor of at most $1.5$, that is, if $\\max\\left(\\frac{x}{y}, \\frac{y}{x}\\right) \\le 1.5$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NWRRC 2025] Infection Investigation", "background": "", "description": "Isaac is a biologist who specializes in diagnosing viral diseases. The virus modifies the host genome (a sequence of genes) by altering it to suit its own needs. Isaac is writing a paper investigating viral infection in genomes. He has some samples and asks you to help analyze them.\n\nFor simplicity, we will assume that the viral genome consists of genes $1, 2, \\ldots, n$ in this order. The host genome is a permutation of genes $1, 2, \\ldots n$: it consists of genes $a_1, a_2, \\ldots, a_n$ in this order.\n\nConsider a genomic segment $[l; r]$ consisting of genes $a_l, a_{l+1}, \\ldots, a_r$. The infection level of this segment is measured as the length of the longest subsequence of genes shared with the viral genome. Formally, the infection level is the maximum $k$ such that there exist $l \\le i_1 < i_2 < \\dots < i_k \\le r$ for which the inequalities $a_{i_1} < a_{i_2} < \\dots < a_{i_{k}}$ hold.\n\nTo analyze the genome, Isaac needs to estimate the infection levels of $q$ genomic segments. To secure the funding, Isaac only needs approximate results: an error factor of up to $1.5$ is allowed.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $q$, denoting the host genome length and the number of genomic segments Isaac is interested in ($1 \\le n, q \\le 2 \\cdot 10^5$).\n\nThe second line contains $n$ distinct integers $a_1, a_2, \\ldots, a_n$, describing the host genome ($1 \\le a_i \\le n$).\n\nEach of the following $q$ lines contains two integers $l$ and $r$, denoting the boundaries of a genomic segment for which the infection level should be estimated ($1 \\le l \\le r \\le n$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2\\cdot 10^5$, and the sum of $q$ over all test cases does not exceed $2 \\cdot 10^5$.", "outputFormat": "For each test case, print $q$ positive integers, denoting the infection levels of the corresponding genomic segments.\n\nFor each genomic segment, let your answer be $x$ and let the true answer be $y$. Your answer will be considered correct if it differs from the true answer by a factor of at most $1.5$, that is, if $\\max\\left(\\frac{x}{y}, \\frac{y}{x}\\right) \\le 1.5$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2025] Infection Investigation", "background": "", "description": "Isaac 是一位专门诊断病毒性疾病的生物学家。病毒通过改变宿主基因组（基因序列）来适应自身需求。Isaac 正在撰写一篇研究基因组中病毒感染的论文。他有一些样本，并请你帮助分析。\n\n为简化问题，我们假设病毒基因组按顺序包含基因 $1, 2, \\ldots, n$。宿主基因组是基因 $1, 2, \\ldots n$ 的一个排列：按顺序包含基因 $a_1, a_2, \\ldots, a_n$。\n\n考虑一个基因组片段 $[l; r]$，包含基因 $a_l, a_{l+1}, \\ldots, a_r$。该片段的感染水平通过其与病毒基因组共享的最长子序列的长度来测量。形式化地说，感染水平是最大的 $k$，使得存在 $l \\le i_1 < i_2 < \\dots < i_k \\le r$ 满足不等式 $a_{i_1} < a_{i_2} < \\dots < a_{i_{k}}$。\n\n为了分析基因组，Isaac 需要估计 $q$ 个基因组片段的感染水平。为了确保资金，Isaac 只需要近似结果：允许最多 $1.5$ 倍的误差因子。", "inputFormat": "每个测试包含多个测试用例。第一行包含测试用例的数量 $t$（$1 \\le t \\le 10^4$）。接下来是测试用例的描述。\n\n每个测试用例的第一行包含两个整数 $n$ 和 $q$，分别表示宿主基因组长度和 Isaac 感兴趣的基因组片段数量（$1 \\le n, q \\le 2 \\cdot 10^5$）。\n\n第二行包含 $n$ 个不同的整数 $a_1, a_2, \\ldots, a_n$，描述宿主基因组（$1 \\le a_i \\le n$）。\n\n接下来的 $q$ 行每行包含两个整数 $l$ 和 $r$，表示需要估计感染水平的基因组片段的边界（$1 \\le l \\le r \\le n$）。\n\n保证所有测试用例的 $n$ 之和不超过 $2 \\cdot 10^5$，所有测试用例的 $q$ 之和不超过 $2 \\cdot 10^5$。", "outputFormat": "对于每个测试用例，输出 $q$ 个正整数，表示相应基因组片段的感染水平。\n\n对于每个基因组片段，设你的答案为 $x$，真实答案为 $y$。如果你的答案与真实答案最多相差 $1.5$ 倍，即满足 $\\max\\left(\\frac{x}{y}, \\frac{y}{x}\\right) \\le 1.5$，则你的答案将被视为正确。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14609", "type": "P", "difficulty": 2, "samples": [["3\n4\nk shaped\nh shaped\neight shaped\neight connected\n3\nk shaped\neight connected\neight shaped\n4\njudging problem\njudging logic\nbinary problem\nlogic problem", "Yes\nNo\nYes"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "ICPC", "NWRRC"], "title": "[NWRRC 2025] Judging Problem", "background": "", "description": "The judges of NWRRC came up with $n$ problems on a similar topic and decided to use them for $n$ consecutive years, one problem per year. The only question was: in what order should they be used?\n\nEach problem's name consists of two words. Let's call two names $\\textit{similar}$ if either their first words are the same or their second words are the same. For example, $\\texttt{eight shaped}$ and $\\texttt{eight connected}$ are similar, while $\\texttt{hello world}$ and $\\texttt{world hello}$ are not.\n\nThe judges decided to implement the following rule: in the first year, they chose a problem arbitrarily. In every subsequent year, if there was a problem with a name similar to the previous year's problem that was still unused, they chose one of such problems; otherwise, they chose any unused problem.\n\nYou are given the names of the problems in chronological order of their use. Determine whether the judges correctly followed the rule above, or if they made a mistake.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$, denoting the number of problems ($2 \\le n \\le 10^5$).\n\nThe $i$-th of the following $n$ lines contains the name of the $i$-th problem in chronological order: two words consisting of at least $1$ and at most $10$ lowercase English letters each. All problem names are distinct.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.", "outputFormat": "For each test case, print $\\tt{Yes}$ if the judges followed the rule correctly, and $\\tt{No}$ otherwise.", "hint": "In the first test case, each subsequent problem name is similar to the previous one.\n\nIn the second test case, the judges should have chosen $\\tt{eight\\ shaped}$ for the second year.\n\nIn the third test case, neither $\\tt{binary\\ problem}$ nor $\\tt{logic\\ problem}$ is similar to $\\tt{judging\\ logic}$; the judges could have chosen either of those problems for the third year.", "locale": "en", "translations": {"en": {"title": "[NWRRC 2025] Judging Problem", "background": "", "description": "The judges of NWRRC came up with $n$ problems on a similar topic and decided to use them for $n$ consecutive years, one problem per year. The only question was: in what order should they be used?\n\nEach problem's name consists of two words. Let's call two names $\\textit{similar}$ if either their first words are the same or their second words are the same. For example, $\\texttt{eight shaped}$ and $\\texttt{eight connected}$ are similar, while $\\texttt{hello world}$ and $\\texttt{world hello}$ are not.\n\nThe judges decided to implement the following rule: in the first year, they chose a problem arbitrarily. In every subsequent year, if there was a problem with a name similar to the previous year's problem that was still unused, they chose one of such problems; otherwise, they chose any unused problem.\n\nYou are given the names of the problems in chronological order of their use. Determine whether the judges correctly followed the rule above, or if they made a mistake.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$, denoting the number of problems ($2 \\le n \\le 10^5$).\n\nThe $i$-th of the following $n$ lines contains the name of the $i$-th problem in chronological order: two words consisting of at least $1$ and at most $10$ lowercase English letters each. All problem names are distinct.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.", "outputFormat": "For each test case, print $\\tt{Yes}$ if the judges followed the rule correctly, and $\\tt{No}$ otherwise.", "hint": "In the first test case, each subsequent problem name is similar to the previous one.\n\nIn the second test case, the judges should have chosen $\\tt{eight\\ shaped}$ for the second year.\n\nIn the third test case, neither $\\tt{binary\\ problem}$ nor $\\tt{logic\\ problem}$ is similar to $\\tt{judging\\ logic}$; the judges could have chosen either of those problems for the third year.", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2025] Judging Problem", "background": "", "description": "NWRRC 的评委们想出了 $n$ 个相似主题的题目，并决定在连续的 $n$ 年中每年使用一道题。唯一的问题是：应该按什么顺序使用它们？\n\n每道题的名称由两个单词组成。如果两个名称的第一个单词相同或第二个单词相同，我们称这两个名称 **相似**。例如，`eight shaped` 和 `eight connected` 是相似的，而 `hello world` 和 `world hello` 则不相似。\n\n评委们决定实施以下规则：在第一年，他们任意选择一道题。在之后的每一年，如果存在与上一年题目名称相似且尚未使用的题目，则从这些题目中选择一道；否则，选择任意一道未使用的题目。\n\n给定按使用时间顺序排列的题目名称。请判断评委们是否正确遵循了上述规则，或者他们是否犯了错误。", "inputFormat": "每个测试包含多个测试用例。第一行包含测试用例的数量 $t$（$1 \\le t \\le 10^4$）。接下来是测试用例的描述。\n\n每个测试用例的第一行包含一个整数 $n$，表示题目的数量（$2 \\le n \\le 10^5$）。\n\n接下来的 $n$ 行中，第 $i$ 行按时间顺序包含第 $i$ 道题的名称：由两个单词组成，每个单词包含至少 $1$ 个、最多 $10$ 个小写英文字母。所有题目名称互不相同。\n\n保证所有测试用例的 $n$ 之和不超过 $10^5$。", "outputFormat": "对于每个测试用例，如果评委正确遵循了规则，输出 `Yes`；否则输出 `No`。\n", "hint": "在第一个测试用例中，每个后续的题目名称都与前一个相似。\n\n在第二个测试用例中，评委本应在第二年选择 `eight shaped`。\n\n在第三个测试用例中，`binary problem` 和 `logic problem` 都与 `judging logic` 不相似；评委可以在第三年选择这两道题中的任意一道。\n\n---\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14610", "type": "P", "difficulty": 6, "samples": [["3\n5 5 13\n3 7\n8 14\n-1 11\n9 1\n2 10\n4 40 0\n20 80\n50 30\n70 60\n90 10\n1 -1 6\n11 8", "32\n-1\n7"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "ICPC", "NWRRC"], "title": "[NWRRC 2025] Keys and Grates", "background": "", "description": "Katniss is in a very long straight tunnel and wants to get out of it. She can move along the tunnel in both directions. There is exactly one hatch in the tunnel, and if she reaches it, she can exit.\n\nUnfortunately, it's not that simple. There are grates blocking the entire width of the tunnel at $n$ locations. The grates are locked, and Katniss cannot pass through a grate until she unlocks it. Fortunately, there are $n$ keys located at $n$ points along the tunnel. Each grate can be unlocked by exactly one of these $n$ keys. Once a grate is unlocked, Katniss can freely and repeatedly pass through it. She can pick up and hold an unlimited number of keys.\n\nKatniss knows her own location, as well as the locations of all $n$ keys, all $n$ grates, and the hatch. She also knows which key unlocks which grate. Determine the minimum distance she must travel to escape.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 5 \\cdot 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $s$, and $h$, denoting the number of grates, the~initial coordinate of Katniss, and the coordinate of the hatch ($1 \\le n \\le 2 \\cdot 10^5$; $-10^6 \\le s, h \\le 10^6$).\n\nThe $i$-th of the following $n$ lines contains two integers $k_i$ and $g_i$, denoting the coordinate of the $i$-th key and the coordinate of the grate that can be unlocked with this key ($-10^6 \\le k_i, g_i \\le 10^6$).\n\nAll $2n+2$ integers $s$, $h$, $k_i$, and $\\ell_i$ are distinct.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.", "outputFormat": "For each test case, print the minimum possible length of Katniss' escape route. If it is impossible to escape, print $-1$ instead.", "hint": "In the first test case, one of the shortest escape routes goes as follows: $5$ (initial) $\\rightarrow$ $3$ (pick up key $1$) $\\rightarrow$ $7$ (unlock grate $1$) $\\rightarrow$ $9$ (pick up key $4$) $\\rightarrow$ $1$ (unlock grate $4$) $\\rightarrow$ $-1$ (pick up key $3$) $\\rightarrow$ $2$ (pick up key $5$) $\\rightarrow$ $10$ (unlock grate $5$) $\\rightarrow$ $11$ (unlock grate $3$) $\\rightarrow$ $13$ (hatch).", "locale": "en", "translations": {"en": {"title": "[NWRRC 2025] Keys and Grates", "background": "", "description": "Katniss is in a very long straight tunnel and wants to get out of it. She can move along the tunnel in both directions. There is exactly one hatch in the tunnel, and if she reaches it, she can exit.\n\nUnfortunately, it's not that simple. There are grates blocking the entire width of the tunnel at $n$ locations. The grates are locked, and Katniss cannot pass through a grate until she unlocks it. Fortunately, there are $n$ keys located at $n$ points along the tunnel. Each grate can be unlocked by exactly one of these $n$ keys. Once a grate is unlocked, Katniss can freely and repeatedly pass through it. She can pick up and hold an unlimited number of keys.\n\nKatniss knows her own location, as well as the locations of all $n$ keys, all $n$ grates, and the hatch. She also knows which key unlocks which grate. Determine the minimum distance she must travel to escape.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 5 \\cdot 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $s$, and $h$, denoting the number of grates, the~initial coordinate of Katniss, and the coordinate of the hatch ($1 \\le n \\le 2 \\cdot 10^5$; $-10^6 \\le s, h \\le 10^6$).\n\nThe $i$-th of the following $n$ lines contains two integers $k_i$ and $g_i$, denoting the coordinate of the $i$-th key and the coordinate of the grate that can be unlocked with this key ($-10^6 \\le k_i, g_i \\le 10^6$).\n\nAll $2n+2$ integers $s$, $h$, $k_i$, and $\\ell_i$ are distinct.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.", "outputFormat": "For each test case, print the minimum possible length of Katniss' escape route. If it is impossible to escape, print $-1$ instead.", "hint": "In the first test case, one of the shortest escape routes goes as follows: $5$ (initial) $\\rightarrow$ $3$ (pick up key $1$) $\\rightarrow$ $7$ (unlock grate $1$) $\\rightarrow$ $9$ (pick up key $4$) $\\rightarrow$ $1$ (unlock grate $4$) $\\rightarrow$ $-1$ (pick up key $3$) $\\rightarrow$ $2$ (pick up key $5$) $\\rightarrow$ $10$ (unlock grate $5$) $\\rightarrow$ $11$ (unlock grate $3$) $\\rightarrow$ $13$ (hatch).", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2025] Keys and Grates", "background": "", "description": "Katniss 身处一条非常长的笔直隧道中，想要离开。她可以沿着隧道双向移动。隧道中恰好有一个舱口，如果她到达那里，就可以离开。\n\n不幸的是，事情没那么简单。隧道中有 $n$ 个位置设有栅栏，阻挡了整个隧道的宽度。栅栏被锁住了，Katniss 在解锁之前无法通过栅栏。幸运的是，隧道中有 $n$ 个钥匙分布在 $n$ 个点上。每个栅栏恰好可以用这 $n$ 把钥匙中的一把来解锁。一旦栅栏被解锁，Katniss 就可以自由且反复地通过它。她可以拾取并持有无限数量的钥匙。\n\nKatniss 知道她自己的位置，以及所有 $n$ 把钥匙、所有 $n$ 个栅栏和舱口的位置。她还知道哪把钥匙可以解锁哪个栅栏。请确定她逃脱必须行走的最小距离。", "inputFormat": "每个测试包含多个测试用例。第一行包含测试用例的数量 $t$（$1 \\le t \\le 5 \\cdot 10^4$）。接下来是测试用例的描述。\n\n每个测试用例的第一行包含三个整数 $n$、$s$ 和 $h$，分别表示栅栏的数量、Katniss 的初始坐标和舱口的坐标（$1 \\le n \\le 2 \\cdot 10^5$；$-10^6 \\le s, h \\le 10^6$）。\n\n接下来的 $n$ 行中，第 $i$ 行包含两个整数 $k_i$ 和 $g_i$，分别表示第 $i$ 把钥匙的坐标和可以用这把钥匙解锁的栅栏的坐标（$-10^6 \\le k_i, g_i \\le 10^6$）。\n\n所有 $2n+2$ 个整数 $s$、$h$、$k_i$ 和 $g_i$ 都是互不相同的。\n\n保证所有测试用例的 $n$ 之和不超过 $2 \\cdot 10^5$。", "outputFormat": "对于每个测试用例，输出 Katniss 逃脱路线的最小可能长度。如果无法逃脱，则输出 $-1$。\n", "hint": "在第一个测试用例中，其中一条最短逃脱路线如下：$5$（初始）$\\rightarrow$ $3$（拾取钥匙 $1$）$\\rightarrow$ $7$（解锁栅栏 $1$）$\\rightarrow$ $9$（拾取钥匙 $4$）$\\rightarrow$ $1$（解锁栅栏 $4$）$\\rightarrow$ $-1$（拾取钥匙 $3$）$\\rightarrow$ $2$（拾取钥匙 $5$）$\\rightarrow$ $10$（解锁栅栏 $5$）$\\rightarrow$ $11$（解锁栅栏 $3$）$\\rightarrow$ $13$（舱口）。\n\n---\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14611", "type": "P", "difficulty": 6, "samples": [["3\n3 2 1\n5 5 3\n7 1 10", "2.6250000000\n10.0000000000\n35.5000000000"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2025] Lucky Number Theory", "background": "", "description": "Lucy is a frequent arcade visitor. All machines at the arcade give out tickets to exchange for prizes! Lucy's favorite machine works as follows.\n\nThe machine only has two buttons: \"Roll\" and \"Withdraw\". Whenever Lucy presses \"Roll\", the machine increases the counter on the screen by a randomly generated $\\textbf{real}$ number between $0$ and $d$. At any moment, she can press \"Withdraw\" to get the number of tickets equal to the counter, which gets reset. In case it's not an integer, the machine generously rounds the counter up before handing out the tickets.\n\nMore formally, the machine stores a real number $S$, initially equal to 0. On each \"Roll\" press, the machine generates $\\Delta$ --- a random $\\textbf{real}$ number picked uniformly from the interval $(0, d)$. Then, $S$ increases by the value of $\\Delta$. When the \"Withdraw\" button is pressed, the machine rounds $S$ up, giving the player $\\lceil S \\rceil$ tickets, and then resets $S$ back to zero. Lucy can see the value of $S$ on the screen at any moment with as much precision as she wants, and she can use it to decide whether to roll or withdraw.\n\nLucy has enough arcade tokens to press \"Roll\" $n$ times, and \"Withdraw\" $k$ times. Find a strategy that maximizes the expected number of tickets Lucy can get, and print this maximum expected number.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 2000$). The description of the test cases follows.\n\nThe only line of each test case contains three integers $n$, $k$, and $d$, denoting the number of rolls, the number of withdrawals, and the upper bound on roll values ($1 \\le k \\le n \\le 2000$; $1 \\le d \\le 2000$).", "outputFormat": "For each test case, print the maximum expected number of tickets Lucy can get, as a floating point number. Your answer will be considered correct if its absolute or relative error doesn't exceed $10^{-6}$.", "hint": "In the first test case, with $n = 3$ rolls, $k = 2$ withdrawals, and $d = 1$, the optimal strategy is as follows:\n\nLucy starts with a roll. Depending on the number $S$, there are two possibilities:\n\n- The number is less than $\\frac 12$. In this case, Lucy should withdraw, then roll two more times, and withdraw at the end. The expected number of tickets in this case is $1 + \\frac 32 = 2.5$ ($1$ ticket for the first withdrawal, and $\\frac 32$ tickets on average after two rolls).\n- The number is at least $\\frac 12$. In this case, it's optimal to roll again, withdraw, then roll for the last time, and withdraw at the end. For the first withdrawal, she will get only one ticket with probability~$\\frac 14$ (the probability that the sum of the first two rolls is at most 1, given that the first roll was over $\\frac 12$), and two tickets with probability $\\frac 34$. The expected number of tickets is $1 + 2 \\cdot \\frac 34 + 1 \\cdot \\frac 14 = 2.75$.\n\nEach case happens with probability $\\frac 12$, so the total expected value for this strategy is $\\frac 12 (2.5 + 2.75) = 2.625$.\n\nIn the second test case, Lucy can withdraw after every roll, each time getting $2$ tickets on average.\n\nIn the third test case, Lucy can only withdraw once, and she should do it after all $7$ rolls.", "locale": "en", "translations": {"en": {"title": "[NWRRC 2025] Lucky Number Theory", "background": "", "description": "Lucy is a frequent arcade visitor. All machines at the arcade give out tickets to exchange for prizes! Lucy's favorite machine works as follows.\n\nThe machine only has two buttons: \"Roll\" and \"Withdraw\". Whenever Lucy presses \"Roll\", the machine increases the counter on the screen by a randomly generated $\\textbf{real}$ number between $0$ and $d$. At any moment, she can press \"Withdraw\" to get the number of tickets equal to the counter, which gets reset. In case it's not an integer, the machine generously rounds the counter up before handing out the tickets.\n\nMore formally, the machine stores a real number $S$, initially equal to 0. On each \"Roll\" press, the machine generates $\\Delta$ --- a random $\\textbf{real}$ number picked uniformly from the interval $(0, d)$. Then, $S$ increases by the value of $\\Delta$. When the \"Withdraw\" button is pressed, the machine rounds $S$ up, giving the player $\\lceil S \\rceil$ tickets, and then resets $S$ back to zero. Lucy can see the value of $S$ on the screen at any moment with as much precision as she wants, and she can use it to decide whether to roll or withdraw.\n\nLucy has enough arcade tokens to press \"Roll\" $n$ times, and \"Withdraw\" $k$ times. Find a strategy that maximizes the expected number of tickets Lucy can get, and print this maximum expected number.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 2000$). The description of the test cases follows.\n\nThe only line of each test case contains three integers $n$, $k$, and $d$, denoting the number of rolls, the number of withdrawals, and the upper bound on roll values ($1 \\le k \\le n \\le 2000$; $1 \\le d \\le 2000$).", "outputFormat": "For each test case, print the maximum expected number of tickets Lucy can get, as a floating point number. Your answer will be considered correct if its absolute or relative error doesn't exceed $10^{-6}$.", "hint": "In the first test case, with $n = 3$ rolls, $k = 2$ withdrawals, and $d = 1$, the optimal strategy is as follows:\n\nLucy starts with a roll. Depending on the number $S$, there are two possibilities:\n\n- The number is less than $\\frac 12$. In this case, Lucy should withdraw, then roll two more times, and withdraw at the end. The expected number of tickets in this case is $1 + \\frac 32 = 2.5$ ($1$ ticket for the first withdrawal, and $\\frac 32$ tickets on average after two rolls).\n- The number is at least $\\frac 12$. In this case, it's optimal to roll again, withdraw, then roll for the last time, and withdraw at the end. For the first withdrawal, she will get only one ticket with probability~$\\frac 14$ (the probability that the sum of the first two rolls is at most 1, given that the first roll was over $\\frac 12$), and two tickets with probability $\\frac 34$. The expected number of tickets is $1 + 2 \\cdot \\frac 34 + 1 \\cdot \\frac 14 = 2.75$.\n\nEach case happens with probability $\\frac 12$, so the total expected value for this strategy is $\\frac 12 (2.5 + 2.75) = 2.625$.\n\nIn the second test case, Lucy can withdraw after every roll, each time getting $2$ tickets on average.\n\nIn the third test case, Lucy can only withdraw once, and she should do it after all $7$ rolls.", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2025] Lucky Number Theory", "background": "", "description": "Lucy 是游戏厅的常客。游戏厅的所有机器都会发放可用于兑换奖品的奖券！Lucy 最喜欢的机器运作方式如下。\n\n这台机器只有两个按钮：\"投掷\"和\"取票\"。每当 Lucy 按下\"投掷\"，机器就会将屏幕上的计数器增加一个在 $0$ 到 $d$ 之间随机生成的 **实数**。在任何时刻，她可以按下\"取票\"来获得与计数器数值相等的奖券数量，然后计数器会被重置。如果计数器不是整数，机器会慷慨地将计数器向上取整后再发放奖券。\n\n更正式地说，机器存储一个实数 $S$，初始值为 $0$。每次按下\"投掷\"，机器生成 $\\Delta$——一个从区间 $(0, d)$ 中均匀随机选取的 **实数**。然后，$S$ 增加 $\\Delta$ 的值。当按下\"取票\"按钮时，机器将 $S$ 向上取整，给予玩家 $\\lceil S \\rceil$ 张奖券，然后将 $S$ 重置为零。Lucy 可以随时在屏幕上看到 $S$ 的值，精度任意，她可以利用这个值来决定是继续投掷还是取票。\n\nLucy 有足够的游戏币来按下 $n$ 次\"投掷\"和 $k$ 次\"取票\"。请找出一个策略，使 Lucy 能获得的期望奖券数最大化，并输出这个最大期望值。", "inputFormat": "每个测试包含多个测试用例。第一行包含测试用例的数量 $t$（$1 \\le t \\le 2000$）。接下来是测试用例的描述。\n\n每个测试用例的唯一一行包含三个整数 $n$、$k$ 和 $d$，分别表示投掷次数、取票次数和投掷值的上限（$1 \\le k \\le n \\le 2000$；$1 \\le d \\le 2000$）。", "outputFormat": "对于每个测试用例，输出 Lucy 能获得的最大期望奖券数，作为一个浮点数。如果你的答案的绝对误差或相对误差不超过 $10^{-6}$，则被视为正确。", "hint": "在第一个测试用例中，$n = 3$ 次投掷，$k = 2$ 次取票，$d = 1$，最优策略如下：\n\nLucy 从一次投掷开始。根据数值 $S$，有两种可能：\n\n- 该数值小于 $\\frac 12$。在这种情况下，Lucy 应该取票，然后再投掷两次，最后再次取票。这种情况下的期望奖券数为 $1 + \\frac 32 = 2.5$（第一次取票得 $1$ 张奖券，两次投掷后平均获得 $\\frac 32$ 张奖券）。\n- 该数值至少为 $\\frac 12$。在这种情况下，最优策略是再投掷一次，然后取票，接着进行最后一次投掷，最后取票。对于第一次取票，她以 $\\frac 14$ 的概率获得 $1$ 张奖券（在第一次投掷超过 $\\frac 12$ 的条件下，前两次投掷之和不超过 $1$ 的概率），以 $\\frac 34$ 的概率获得 $2$ 张奖券。期望奖券数为 $1 + 2 \\cdot \\frac 34 + 1 \\cdot \\frac 14 = 2.75$。\n\n每种情况发生的概率均为 $\\frac 12$，因此该策略的总期望值为 $\\frac 12 (2.5 + 2.75) = 2.625$。\n\n在第二个测试用例中，Lucy 可以在每次投掷后立即取票，每次平均获得 $2$ 张奖券。\n\n在第三个测试用例中，Lucy 只能取票一次，她应该在所有 $7$ 次投掷后进行取票。\n\n---\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14612", "type": "P", "difficulty": 2, "samples": [["2 3\n676\n679", "2"], ["3 3\n888\n888\n888", "0"], ["1 1\n7", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["模拟", "2019", "高校校赛"], "title": "[2019 KAIST RUN Fall] 6789", "background": "", "description": "Jaehyun likes digits. Among the 10 digits, 6, 7, 8, and 9 are his favorite. Therefore, he made a special card set consisting of only 6, 7, 8 and 9. \n\nCurrently, Jaehyun has $N\\times M$ cards. Jaehyun wants to make a magical $N$ by $M$ matrix of cards. Each row of the matrix should contain $M$ cards. He already arranged his cards in a shape of $N$ by $M$ matrix.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/0oyaem7q.png)\n\nFigure 1. Initial state, not point symmetric.\n:::\n\nTo be a magic matrix, the matrix must be point symmetrical: Rotating the matrix 180 degrees results in the same original matrix. For example, 8 is point symmetrical with itself, and 6 and 9 are point symmetrical with each other.\nJaehyun doesn't want to switch the position of the cards, so his goal is to make the matrix point symmetrical by only rotating the cards in their original positions.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/8r8fmjt1.png)\n\nFigure 2. After rotating two cards, they are point symmetric.\n:::\n\nFind the minimum number of cards you have to turn to make a magic matrix.", "inputFormat": "The first line contains two integers, $N$ and $M$. ($ 1 \\le N, M \\le 500$)\n\nEach of the next $N$ lines contains a string of $M$ characters which denotes the numbers written in each card. It is guaranteed that each character is one of $\\texttt{6}$, $\\texttt{7}$, $\\texttt{8}$, or $\\texttt{9}$.", "outputFormat": "Print the minimum number of cards you have to turn to make a magic matrix in the first line. If it is not possible to make a magic matrix, print $\\texttt{-1}$. (without quotes)", "hint": "", "locale": "en", "translations": {"en": {"title": "[2019 KAIST RUN Fall] 6789", "background": "", "description": "Jaehyun likes digits. Among the 10 digits, 6, 7, 8, and 9 are his favorite. Therefore, he made a special card set consisting of only 6, 7, 8 and 9. \n\nCurrently, Jaehyun has $N\\times M$ cards. Jaehyun wants to make a magical $N$ by $M$ matrix of cards. Each row of the matrix should contain $M$ cards. He already arranged his cards in a shape of $N$ by $M$ matrix.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/0oyaem7q.png)\n\nFigure 1. Initial state, not point symmetric.\n:::\n\nTo be a magic matrix, the matrix must be point symmetrical: Rotating the matrix 180 degrees results in the same original matrix. For example, 8 is point symmetrical with itself, and 6 and 9 are point symmetrical with each other.\nJaehyun doesn't want to switch the position of the cards, so his goal is to make the matrix point symmetrical by only rotating the cards in their original positions.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/8r8fmjt1.png)\n\nFigure 2. After rotating two cards, they are point symmetric.\n:::\n\nFind the minimum number of cards you have to turn to make a magic matrix.", "inputFormat": "The first line contains two integers, $N$ and $M$. ($ 1 \\le N, M \\le 500$)\n\nEach of the next $N$ lines contains a string of $M$ characters which denotes the numbers written in each card. It is guaranteed that each character is one of $\\texttt{6}$, $\\texttt{7}$, $\\texttt{8}$, or $\\texttt{9}$.", "outputFormat": "Print the minimum number of cards you have to turn to make a magic matrix in the first line. If it is not possible to make a magic matrix, print $\\texttt{-1}$. (without quotes)", "hint": "", "locale": "en"}, "zh-CN": {"title": "[2019 KAIST RUN Fall] 6789", "background": "", "description": "Jaehyun 喜欢数字。在 10 个数字中，6、7、8 和 9 是他的最爱。因此，他制作了一套只包含 6、7、8 和 9 的特殊卡牌。\n\n目前，Jaehyun 拥有 $N \\times M$ 张卡牌。他想要制作一个神奇的 $N$ 行 $M$ 列的卡牌矩阵。矩阵的每一行应包含 $M$ 张卡牌。他已经将自己的卡牌排列成一个 $N$ 行 $M$ 列的矩阵。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/0oyaem7q.png)\n\n图 1. 初始状态，不满足点对称。\n:::\n\n要成为一个神奇矩阵，该矩阵必须是点对称的：将矩阵旋转 180 度后得到的结果与原矩阵相同。例如，8 与自身点对称，而 6 和 9 相互点对称。\nJaehyun 不想改变卡牌的位置，因此他的目标是通过仅在原始位置上旋转卡牌来使矩阵点对称。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/8r8fmjt1.png)\n\n图 2. 旋转两张卡牌后，它们点对称。\n:::\n\n请找出使矩阵成为神奇矩阵所需旋转的最小卡牌数量。", "inputFormat": "第一行包含两个整数 $N$ 和 $M$（$1 \\le N, M \\le 500$）。\n\n接下来的 $N$ 行，每行包含一个由 $M$ 个字符组成的字符串，表示每张卡牌上写的数字。保证每个字符是 $\\texttt{6}$、$\\texttt{7}$、$\\texttt{8}$ 或 $\\texttt{9}$ 之一。", "outputFormat": "第一行输出使矩阵成为神奇矩阵所需旋转的最小卡牌数量。如果无法制作神奇矩阵，则输出 $\\texttt{-1}$（不带引号）。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14613", "type": "P", "difficulty": 2, "samples": [["20 1\n20 0\n20 3\n10 0\n10 0\n10 0\n30 0\n30 0\n30 0\n20 0\n20 10", "1360"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "2019", "高校校赛"], "title": "[2019 KAIST RUN Fall] And the Winner Is... Ourselves!", "background": "", "description": "Let us remind you about how the total penalties are calculated for this contest:\n\n- When you solve a problem at $T$ minutes, $T+20V$ is added to your penalty, where $V$ is the number of incorrect verdicts (except compile errors) received on that problem.\n- If you do not solve a problem before the contest ends, the incorrect verdicts on that problem are not counted as penalties.\n\nHere is a bad news for all of you: we, the problem setters, are planning to join the competition and solve our own problems!\n\nWe know our problems really well, so we can solve all the problems before the contest ends. Furthermore, we can precisely predict how long it takes to solve each problem, and how many incorrect verdicts (except compile errors) we get in each problem. Depending on the order of the problems we solve, our total penalty might differ. What is the minimum penalty if we solve all problems?", "inputFormat": "11 lines are given as the input. The $i$-th line contains two integers, $D_i$ and $V_i$, where $D_i$ is the amount of minutes required to solve the $i$-th problem, and $V_i$ is the number of incorrect verdicts on the $i$-th problem.\n\nFor each $i$, $1 \\leq D_i$ and $0 \\leq V_i \\leq 1000$. Also, $\\sum_{i=1}^{11} D_i \\leq 300$.", "outputFormat": "Output the minimum penalty if we solve all problems.", "hint": "The sample input does not necessarily reflect the actual difficulties of the problems.\n\nThe problem statement does not necessarily reflect the actual situation of the contest.", "locale": "en", "translations": {"en": {"title": "[2019 KAIST RUN Fall] And the Winner Is... Ourselves!", "background": "", "description": "Let us remind you about how the total penalties are calculated for this contest:\n\n- When you solve a problem at $T$ minutes, $T+20V$ is added to your penalty, where $V$ is the number of incorrect verdicts (except compile errors) received on that problem.\n- If you do not solve a problem before the contest ends, the incorrect verdicts on that problem are not counted as penalties.\n\nHere is a bad news for all of you: we, the problem setters, are planning to join the competition and solve our own problems!\n\nWe know our problems really well, so we can solve all the problems before the contest ends. Furthermore, we can precisely predict how long it takes to solve each problem, and how many incorrect verdicts (except compile errors) we get in each problem. Depending on the order of the problems we solve, our total penalty might differ. What is the minimum penalty if we solve all problems?", "inputFormat": "11 lines are given as the input. The $i$-th line contains two integers, $D_i$ and $V_i$, where $D_i$ is the amount of minutes required to solve the $i$-th problem, and $V_i$ is the number of incorrect verdicts on the $i$-th problem.\n\nFor each $i$, $1 \\leq D_i$ and $0 \\leq V_i \\leq 1000$. Also, $\\sum_{i=1}^{11} D_i \\leq 300$.", "outputFormat": "Output the minimum penalty if we solve all problems.", "hint": "The sample input does not necessarily reflect the actual difficulties of the problems.\n\nThe problem statement does not necessarily reflect the actual situation of the contest.", "locale": "en"}, "zh-CN": {"title": "[2019 KAIST RUN Fall] And the Winner Is... Ourselves!", "background": "", "description": "让我们提醒您本次比赛的总罚时是如何计算的：\n\n- 当你在第 $T$ 分钟解决一道题目时，$T+20V$ 将被添加到你的罚时中，其中 $V$ 是在该题上收到的错误提交次数（编译错误除外）。\n- 如果你在比赛结束前没有解决某道题目，则该题上的错误提交不计入罚时。\n\n这里有一个对你们所有人都不利的消息：我们，出题人，计划参加比赛并解决我们自己出的题目！\n\n我们非常了解自己的题目，所以我们可以在比赛结束前解决所有题目。此外，我们可以精确预测解决每道题目所需的时间，以及在每道题目上会得到多少次错误提交（编译错误除外）。根据我们解题的顺序，我们的总罚时可能会有所不同。如果我们解决所有题目，最小的罚时是多少？", "inputFormat": "输入给出 11 行数据。第 $i$ 行包含两个整数 $D_i$ 和 $V_i$，其中 $D_i$ 是解决第 $i$ 道题目所需的分钟数，$V_i$ 是第 $i$ 道题上的错误提交次数。\n\n对于每个 $i$，$1 \\leq D_i$ 且 $0 \\leq V_i \\leq 1000$。同时，$\\sum_{i=1}^{11} D_i \\leq 300$。\n", "outputFormat": "输出当我们解决所有题目时的最小罚时。\n", "hint": "样例输入不一定反映题目的实际难度。\n\n题目描述不一定反映比赛的实际状况。\n\n---\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14614", "type": "P", "difficulty": 6, "samples": [["<There are no inputs>", "5 6\n....SS\n....SS\n.#BB#.\n..BB.P\n......"]], "limits": {"time": [1000], "memory": [1048576]}, "tags": ["2019", "Special Judge", "高校校赛"], "title": "[2019 KAIST RUN Fall] Bigger Sokoban 40k", "background": "", "description": "$\\textbf{Sokoban}$ is a famous puzzle game, where the player moves around in the $N \\times M$-size grid, and pushes $1 \\times 1$-size boxes to $1 \\times 1$-size storage locations.\n\n$\\textbf{Bigger Sokoban}$ is a possible variation of Sokoban, but the size of boxes and storage locations are bigger than $1 \\times 1$. This problem especially uses $2 \\times 2$ for both.\n\nThe rule of Bigger Sokoban is the same as Sokoban. Each square in the grid is an empty square or a wall. Some $2 \\times 2$ area of empty squares contain $2 \\times 2$-size box each and some $2 \\times 2$ area of empty squares are marked as $2 \\times 2$-size storage location each.\n\nThe player is in the grid and may move up, down, left, right to the adjacent empty squares, but should not go through walls, boxes, or outside of the grid. If the player tries to move into a box, it is pushed to the adjacent squares in that direction. Boxes must not be pushed to other boxes, walls, or outside of the grid, and they cannot be pulled. The number of boxes is equal to the number of storage locations. The puzzle is solved when all boxes are at the storage locations.\n\nYour mission is to make a Bigger Sokoban grid that needs at least $\\textbf{40,000}$ moves to solve. To make the situation easier, the grid must satisfy the following constraints:\n\n- $1 \\leq N, \\; M, \\; N+M \\leq 100$.\n- The grid contains $\\textbf{one}$ box and $\\textbf{one}$ storage location.\n- The player, the box, and the storage location must not intersect.", "inputFormat": "There is no input for this problem.", "outputFormat": "In the first line, print two space-separated integers $N, M$; they describe the size of the grid.\n\nIn each of the following $N$ lines, print a string of length $M$; it describes each row of the grid. Each string must consist of $\\texttt{.}, \\texttt{\\#}, \\texttt{P}, \\texttt{B}, \\texttt{S}$; each character means empty square, wall, player, box, storage location respectively.\n\nThe grid must contain exactly one $\\texttt{P}$, exactly four $\\texttt{B}$, and exactly four $\\texttt{S}$. $\\texttt{B}$ and $\\texttt{S}$ each must form a $2 \\times 2$ square. The grid, of course, must be solvable.\n\nNote that the sample output is only to demonstrate a well-formatted output. Since it can be solved in less than 40,000 moves, it is not a correct answer.", "hint": "", "locale": "en", "translations": {"en": {"title": "[2019 KAIST RUN Fall] Bigger Sokoban 40k", "background": "", "description": "$\\textbf{Sokoban}$ is a famous puzzle game, where the player moves around in the $N \\times M$-size grid, and pushes $1 \\times 1$-size boxes to $1 \\times 1$-size storage locations.\n\n$\\textbf{Bigger Sokoban}$ is a possible variation of Sokoban, but the size of boxes and storage locations are bigger than $1 \\times 1$. This problem especially uses $2 \\times 2$ for both.\n\nThe rule of Bigger Sokoban is the same as Sokoban. Each square in the grid is an empty square or a wall. Some $2 \\times 2$ area of empty squares contain $2 \\times 2$-size box each and some $2 \\times 2$ area of empty squares are marked as $2 \\times 2$-size storage location each.\n\nThe player is in the grid and may move up, down, left, right to the adjacent empty squares, but should not go through walls, boxes, or outside of the grid. If the player tries to move into a box, it is pushed to the adjacent squares in that direction. Boxes must not be pushed to other boxes, walls, or outside of the grid, and they cannot be pulled. The number of boxes is equal to the number of storage locations. The puzzle is solved when all boxes are at the storage locations.\n\nYour mission is to make a Bigger Sokoban grid that needs at least $\\textbf{40,000}$ moves to solve. To make the situation easier, the grid must satisfy the following constraints:\n\n- $1 \\leq N, \\; M, \\; N+M \\leq 100$.\n- The grid contains $\\textbf{one}$ box and $\\textbf{one}$ storage location.\n- The player, the box, and the storage location must not intersect.", "inputFormat": "There is no input for this problem.", "outputFormat": "In the first line, print two space-separated integers $N, M$; they describe the size of the grid.\n\nIn each of the following $N$ lines, print a string of length $M$; it describes each row of the grid. Each string must consist of $\\texttt{.}, \\texttt{\\#}, \\texttt{P}, \\texttt{B}, \\texttt{S}$; each character means empty square, wall, player, box, storage location respectively.\n\nThe grid must contain exactly one $\\texttt{P}$, exactly four $\\texttt{B}$, and exactly four $\\texttt{S}$. $\\texttt{B}$ and $\\texttt{S}$ each must form a $2 \\times 2$ square. The grid, of course, must be solvable.\n\nNote that the sample output is only to demonstrate a well-formatted output. Since it can be solved in less than 40,000 moves, it is not a correct answer.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[2019 KAIST RUN Fall] Bigger Sokoban 40k", "background": "", "description": "**推箱子**（Sokoban）是一款著名的益智游戏，玩家在 $N \\times M$ 大小的网格中移动，并将 $1 \\times 1$ 大小的箱子推到 $1 \\times 1$ 大小的目标位置。\n\n**更大推箱子**（Bigger Sokoban）是推箱子的一种可能变体，但箱子和目标位置的尺寸都大于 $1 \\times 1$。本题特别使用 $2 \\times 2$ 的尺寸作为箱子和目标位置的大小。\n\n更大推箱子的规则与推箱子相同。网格中的每个格子是空地或墙壁。一些 $2 \\times 2$ 的空地区域各包含一个 $2 \\times 2$ 大小的箱子，而一些 $2 \\times 2$ 的空地区域各被标记为 $2 \\times 2$ 大小的目标位置。\n\n玩家位于网格中，可以向上、下、左、右移动到相邻的空地格子，但不能穿过墙壁、箱子或网格边界。如果玩家试图移动到一个箱子的位置，箱子会被向该方向推到相邻的格子。箱子不能被推到其他箱子、墙壁或网格边界上，且箱子不能被拉动。箱子的数量等于目标位置的数量。当所有箱子都位于目标位置上时，谜题即被解决。\n\n你的任务是设计一个需要至少 **40,000** 步才能解决的更大推箱子网格。为了使情况更简单，网格必须满足以下约束：\n\n- $1 \\leq N, M, N+M \\leq 100$。\n- 网格包含 **一个** 箱子和 **一个** 目标位置。\n- 玩家、箱子和目标位置必须互不重叠。", "inputFormat": "本题没有输入。", "outputFormat": "第一行输出两个以空格分隔的整数 $N, M$，表示网格的尺寸。\n\n接下来的 $N$ 行，每行输出一个长度为 $M$ 的字符串，描述网格的每一行。每个字符串必须由 $\\texttt{.}$、$\\texttt{\\#}$、$\\texttt{P}$、$\\texttt{B}$、$\\texttt{S}$ 组成；每个字符分别表示空地、墙壁、玩家、箱子、目标位置。\n\n网格必须恰好包含一个 $\\texttt{P}$，恰好四个 $\\texttt{B}$，以及恰好四个 $\\texttt{S}$。$\\texttt{B}$ 和 $\\texttt{S}$ 必须各自形成一个 $2 \\times 2$ 的正方形。当然，网格必须是可解的。\n\n请注意，样例输出仅用于演示格式正确的输出。由于它可以在少于 40,000 步内解决，因此不是一个正确答案。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14615", "type": "P", "difficulty": 3, "samples": [["2 1\n1 2", "1\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["搜索", "图论", "2019", "广度优先搜索 BFS", "深度优先搜索 DFS", "图论建模", "高校校赛"], "title": "[2019 KAIST RUN Fall] Capital", "background": "", "description": "You are given $N$ cities connected by $M$ roads. Cities are numbered from 1 through $N$, and roads are numbered from 1 through $M$. For each pair of cities, there is a sequence of roads that connects those two cities. Road $i$ has the length $L_i$ kilometre and connects city $A_i$ and city $B_i$ bidirectionally. Every road has a positive length, so $L_i > 0$. Unfortunately, you have forgotten the length of each road.\n\nYou observed that, for each road, all people on road $i$ are going from $A_i$ to $B_i$, in a single direction. So, you assumed the hypothesis as follows:\n\n- There is a capital city called $S$.\n- People are moving from the capital city to other cities. \n- People try to move in the shortest path. So the length of the shortest path from $S$ to $A_i$ is less than or equal to the length of the shortest path from $S$ to $B_i$.\n\nCan you find the capital city $S$ which meets the criteria when you can assign the length of each road to be any positive real number? You may assume that there is at least one city that meets the criteria.", "inputFormat": "The first line of the input contains two integers $N$ ($2 \\le N \\le 500$) and $M$ ($N-1 \\le M \\le \\frac{N(N-1)}{2}$).\n\nIn the $i$-th line of next $M$ lines, $A_i$ and $B_i$ are given. ($1 \\le A_i, B_i \\le N$) \n\nThere are no loops or multiple edges. Formally, $A_i \\ne B_i$, and $\\{A_i, B_i\\} = \\{A_j, B_j\\} \\implies i = j$.", "outputFormat": "In the first line, print the number of possible capital cities, $K$.\n\nIn the second line, print $K$ space-separated integers which denotes all possible cities for the capital, in increasing order.", "hint": "", "locale": "en", "translations": {"en": {"title": "[2019 KAIST RUN Fall] Capital", "background": "", "description": "You are given $N$ cities connected by $M$ roads. Cities are numbered from 1 through $N$, and roads are numbered from 1 through $M$. For each pair of cities, there is a sequence of roads that connects those two cities. Road $i$ has the length $L_i$ kilometre and connects city $A_i$ and city $B_i$ bidirectionally. Every road has a positive length, so $L_i > 0$. Unfortunately, you have forgotten the length of each road.\n\nYou observed that, for each road, all people on road $i$ are going from $A_i$ to $B_i$, in a single direction. So, you assumed the hypothesis as follows:\n\n- There is a capital city called $S$.\n- People are moving from the capital city to other cities. \n- People try to move in the shortest path. So the length of the shortest path from $S$ to $A_i$ is less than or equal to the length of the shortest path from $S$ to $B_i$.\n\nCan you find the capital city $S$ which meets the criteria when you can assign the length of each road to be any positive real number? You may assume that there is at least one city that meets the criteria.", "inputFormat": "The first line of the input contains two integers $N$ ($2 \\le N \\le 500$) and $M$ ($N-1 \\le M \\le \\frac{N(N-1)}{2}$).\n\nIn the $i$-th line of next $M$ lines, $A_i$ and $B_i$ are given. ($1 \\le A_i, B_i \\le N$) \n\nThere are no loops or multiple edges. Formally, $A_i \\ne B_i$, and $\\{A_i, B_i\\} = \\{A_j, B_j\\} \\implies i = j$.", "outputFormat": "In the first line, print the number of possible capital cities, $K$.\n\nIn the second line, print $K$ space-separated integers which denotes all possible cities for the capital, in increasing order.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[2019 KAIST RUN Fall] Capital", "background": "", "description": "给定由 $M$ 条道路连接的 $N$ 个城市。城市编号从 $1$ 到 $N$，道路编号从 $1$ 到 $M$。对于任意两个城市，都存在一系列道路连接这两个城市。道路 $i$ 的长度为 $L_i$ 公里，并双向连接城市 $A_i$ 和城市 $B_i$。每条道路的长度均为正数，即 $L_i > 0$。不幸的是，你忘记了每条道路的具体长度。\n\n你观察到，对于每条道路 $i$，所有在该道路上的人都从 $A_i$ 单向前往 $B_i$。因此，你提出了以下假设：\n\n- 存在一个称为 $S$ 的首都城市。\n- 人们从首都城市前往其他城市。\n- 人们尝试沿最短路径移动。因此从 $S$ 到 $A_i$ 的最短路径长度小于等于从 $S$ 到 $B_i$ 的最短路径长度。\n\n当你可以将每条道路的长度任意分配为正实数时，能否找到满足条件的首都城市 $S$？你可以假设至少存在一个城市满足条件。", "inputFormat": "输入的第一行包含两个整数 $N$（$2 \\le N \\le 500$）和 $M$（$N-1 \\le M \\le \\frac{N(N-1)}{2}$）。\n\n接下来的 $M$ 行中，第 $i$ 行给出 $A_i$ 和 $B_i$（$1 \\le A_i, B_i \\le N$）。\n\n输入中不存在自环或重边。形式化地说，$A_i \\ne B_i$，且 $\\{A_i, B_i\\} = \\{A_j, B_j\\} \\implies i = j$。\n", "outputFormat": "第一行输出可能的首都城市数量 $K$。\n\n第二行以递增顺序输出 $K$ 个用空格分隔的整数，表示所有可能作为首都的城市。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14616", "type": "P", "difficulty": 5, "samples": [["5\n1\n-\n2\n-W\nL-\n3\n-LW\nW-L\nLW-\n4\n-WLW\nL-WL\nWL-W\nLWL-\n5\n-WLLW\nL-LLW\nWW-LL\nWWW-W\nLLWL-", "1\n1 2\n3 2\n3 1 4\n4 3 1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "Special Judge", "高校校赛"], "title": "[2019 KAIST RUN Fall] Gosu 2", "background": "", "description": "Ho is an expert in martial arts called $\\textit{Taebo}$. She runs a Taebo school, and there are $N$ students in her school. To increase the inner competition inside the Taebo school, she is going to make a $\\textit{Taebo ranking website}$ which assigns all students to a certain rank. To find a suitable rank, Ho made all $N(N-1)/2$ pairs of students do a Taebo matchup with each other. In a Taebo matchup, exactly one person wins the match, and another person loses the match. The outcome of Taebo matchups may not be very simple: For example, there might be a case that student A beats B, B beats C, and C beats A. Such situation would make the ranking assignment pretty complicated as there is no definite winner from those three students.\n\nTo overcome the issue, Ho will find a $\\textbf{standard ranking chain}$ and assign other students with respect to such a chain. A $\\textbf{standard ranking chain}$ of length $K$, is a sequence of $K$ different students $S_1, S_2, \\ldots, S_k$ such that $S_i$ beats $S_j$ if and only if $i < j$. In other words, $S_1$ can beat all other students in the chain, $S_2$ can beat all other students in the chain except $S_1$, $S_3$ can beat all other students in the chain except $S_1, S_2$, and so on, and $S_k$ can beat no other student in the chain. Ho's website will assign other students based on such a chain, which will make the assignment easier.\n\nHo is not only an expert in Taebo, but she is a math genius too. Ho knows, that for any Taebo matchup, she can find the standard ranking chain of length $1 + \\lfloor \\log_2(N) \\rfloor$, where $\\log_2(N)$ is a base 2 logarithm. In other words, for any $k \\geq 1$ such that $2^{k-1} \\le N$, Ho can find a standard ranking chain of such a length. \n\nWhile Ho is very good at computer programming too, she is a little bit lazy, therefore she delegates her work to you. You should find a standard ranking chain of length exactly $1 + \\lfloor \\log_2(N) \\rfloor$.", "inputFormat": "In the first line, the number of test cases $T$ is given. For each test case, the following instances are given:\n\nIn the first line, the number of students $N$ is given.\n\nIn the $i$-th line of the next $N$ lines, a string $s_i$ consisting of $\\texttt{W}$, $\\texttt{L}$, and $\\texttt{-}$, is given. Let's denote the $j$-th character of $s_i$ as $s_{i,j}$. $s_{i,j}$ is given as follows:\n\n- $s_{i,j}=$ $\\texttt{-}$, if $i=j$.\n- $s_{i,j}=$ $\\texttt{W}$, if student $i$ won student $j$.\n- $s_{i,j}=$ $\\texttt{L}$, if student $j$ won student $i$.\n- $1 \\le T \\le 250\\,000$\n- $1 \\le N \\le 512$\n- The sum of $N^2$ for all test cases does not exceed $2\\,500\\,000$.\n- $s_{i, i} =$ $\\texttt{-}$ ($1 \\le i \\le N$)\n- If $i \\neq j$, then $s_{i, j}=$ $\\texttt{W}$ or $s_{i, j}=$ $\\texttt{L}$. ($1 \\le i \\le N$)\n- If $s_{i, j} = $ $\\texttt{W}$, then $s_{j, i} = $ $\\texttt{L}$. ($1 \\le i,\\ j \\le N$)\n- If $s_{i, j} = $ $\\texttt{L}$, then $s_{j, i} = $ $\\texttt{W}$. ($1 \\le i,\\ j \\le N$)", "outputFormat": "For each test case, print exactly $1 + \\lfloor \\log_2(N) \\rfloor$ integers in a single line, denoting the students in a standard ranking chain in the order of their skills. It can be proved that such a chain exists for every possible input.", "hint": "", "locale": "en", "translations": {"en": {"title": "[2019 KAIST RUN Fall] Gosu 2", "background": "", "description": "Ho is an expert in martial arts called $\\textit{Taebo}$. She runs a Taebo school, and there are $N$ students in her school. To increase the inner competition inside the Taebo school, she is going to make a $\\textit{Taebo ranking website}$ which assigns all students to a certain rank. To find a suitable rank, Ho made all $N(N-1)/2$ pairs of students do a Taebo matchup with each other. In a Taebo matchup, exactly one person wins the match, and another person loses the match. The outcome of Taebo matchups may not be very simple: For example, there might be a case that student A beats B, B beats C, and C beats A. Such situation would make the ranking assignment pretty complicated as there is no definite winner from those three students.\n\nTo overcome the issue, Ho will find a $\\textbf{standard ranking chain}$ and assign other students with respect to such a chain. A $\\textbf{standard ranking chain}$ of length $K$, is a sequence of $K$ different students $S_1, S_2, \\ldots, S_k$ such that $S_i$ beats $S_j$ if and only if $i < j$. In other words, $S_1$ can beat all other students in the chain, $S_2$ can beat all other students in the chain except $S_1$, $S_3$ can beat all other students in the chain except $S_1, S_2$, and so on, and $S_k$ can beat no other student in the chain. Ho's website will assign other students based on such a chain, which will make the assignment easier.\n\nHo is not only an expert in Taebo, but she is a math genius too. Ho knows, that for any Taebo matchup, she can find the standard ranking chain of length $1 + \\lfloor \\log_2(N) \\rfloor$, where $\\log_2(N)$ is a base 2 logarithm. In other words, for any $k \\geq 1$ such that $2^{k-1} \\le N$, Ho can find a standard ranking chain of such a length. \n\nWhile Ho is very good at computer programming too, she is a little bit lazy, therefore she delegates her work to you. You should find a standard ranking chain of length exactly $1 + \\lfloor \\log_2(N) \\rfloor$.", "inputFormat": "In the first line, the number of test cases $T$ is given. For each test case, the following instances are given:\n\nIn the first line, the number of students $N$ is given.\n\nIn the $i$-th line of the next $N$ lines, a string $s_i$ consisting of $\\texttt{W}$, $\\texttt{L}$, and $\\texttt{-}$, is given. Let's denote the $j$-th character of $s_i$ as $s_{i,j}$. $s_{i,j}$ is given as follows:\n\n- $s_{i,j}=$ $\\texttt{-}$, if $i=j$.\n- $s_{i,j}=$ $\\texttt{W}$, if student $i$ won student $j$.\n- $s_{i,j}=$ $\\texttt{L}$, if student $j$ won student $i$.\n- $1 \\le T \\le 250\\,000$\n- $1 \\le N \\le 512$\n- The sum of $N^2$ for all test cases does not exceed $2\\,500\\,000$.\n- $s_{i, i} =$ $\\texttt{-}$ ($1 \\le i \\le N$)\n- If $i \\neq j$, then $s_{i, j}=$ $\\texttt{W}$ or $s_{i, j}=$ $\\texttt{L}$. ($1 \\le i \\le N$)\n- If $s_{i, j} = $ $\\texttt{W}$, then $s_{j, i} = $ $\\texttt{L}$. ($1 \\le i,\\ j \\le N$)\n- If $s_{i, j} = $ $\\texttt{L}$, then $s_{j, i} = $ $\\texttt{W}$. ($1 \\le i,\\ j \\le N$)", "outputFormat": "For each test case, print exactly $1 + \\lfloor \\log_2(N) \\rfloor$ integers in a single line, denoting the students in a standard ranking chain in the order of their skills. It can be proved that such a chain exists for every possible input.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[2019 KAIST RUN Fall] Gosu 2", "background": "", "description": "Ho 是一种名为 **跆博**（Taebo）的武术专家。她经营着一所跆博学校，学校里有 $N$ 名学生。为了增加学校内部的竞争，她打算创建一个 **跆博排名网站**，为所有学生分配一定的排名。为了找到合适的排名，Ho 让所有 $N(N-1)/2$ 对学生相互进行了跆博对决。在跆博对决中，恰好有一人获胜，另一人失败。跆博对决的结果可能并不简单：例如，可能存在学生 A 击败 B，B 击败 C，而 C 击败 A 的情况。这种情况会使排名分配变得相当复杂，因为无法从这三名学生中确定明确的胜者。\n\n为了解决这个问题，Ho 将找到一个 **标准排名链**，并基于该链为其他学生分配排名。一个长度为 $K$ 的 **标准排名链** 是一个由 $K$ 名不同学生组成的序列 $S_1, S_2, \\ldots, S_k$，满足 $S_i$ 击败 $S_j$ 当且仅当 $i < j$。换句话说，$S_1$ 可以击败链中的所有其他学生，$S_2$ 可以击败链中除 $S_1$ 外的所有学生，$S_3$ 可以击败链中除 $S_1, S_2$ 外的所有学生，依此类推，而 $S_k$ 无法击败链中的任何其他学生。Ho 的网站将基于这样的链为其他学生分配排名，这将使分配过程更简单。\n\nHo 不仅是跆博专家，还是一位数学天才。Ho 知道，对于任何跆博对决结果，她都能找到一个长度为 $1 + \\lfloor \\log_2(N) \\rfloor$ 的标准排名链，其中 $\\log_2(N)$ 是以 $2$ 为底的对数。换句话说，对于任意满足 $2^{k-1} \\le N$ 的 $k \\geq 1$，Ho 都能找到这样一个长度的标准排名链。\n\n虽然 Ho 也非常擅长计算机编程，但她有点懒，因此她把这项工作委托给了你。你需要找到一个长度恰好为 $1 + \\lfloor \\log_2(N) \\rfloor$ 的标准排名链。", "inputFormat": "第一行给出测试用例的数量 $T$。对于每个测试用例，给出以下信息：\n\n第一行给出学生数量 $N$。\n\n接下来的 $N$ 行中，第 $i$ 行给出一个由字符 $\\texttt{W}$、$\\texttt{L}$ 和 $\\texttt{-}$ 组成的字符串 $s_i$。记 $s_i$ 的第 $j$ 个字符为 $s_{i,j}$。$s_{i,j}$ 的给出规则如下：\n\n- 若 $i = j$，则 $s_{i,j} = \\texttt{-}$。\n- 若学生 $i$ 击败了学生 $j$，则 $s_{i,j} = \\texttt{W}$。\n- 若学生 $j$ 击败了学生 $i$，则 $s_{i,j} = \\texttt{L}$。\n\n约束条件：\n- $1 \\le T \\le 250,000$\n- $1 \\le N \\le 512$\n- 所有测试用例的 $N^2$ 之和不超过 $2,500,000$\n- $s_{i, i} = \\texttt{-}$（$1 \\le i \\le N$）\n- 若 $i \\neq j$，则 $s_{i, j} = \\texttt{W}$ 或 $s_{i, j} = \\texttt{L}$（$1 \\le i \\le N$）\n- 若 $s_{i, j} = \\texttt{W}$，则 $s_{j, i} = \\texttt{L}$（$1 \\le i, j \\le N$）\n- 若 $s_{i, j} = \\texttt{L}$，则 $s_{j, i} = \\texttt{W}$（$1 \\le i, j \\le N$）", "outputFormat": "对于每个测试用例，在一行中输出恰好 $1 + \\lfloor \\log_2(N) \\rfloor$ 个整数，表示标准排名链中的学生编号，按技能顺序排列。可以证明对于所有可能的输入，这样的链总是存在的。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14617", "type": "P", "difficulty": 6, "samples": [["10\n3 0\n1 3\n2 1 2\n1 0\n3 10\n2 2 5\n1 5\n1 0\n3 5\n2 3 3", "0\n1\n0\n9\n4\n4"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "线段树", "高校校赛"], "title": "[2019 KAIST RUN Fall] Hilbert' s Hotel", "background": "", "description": "Hilbert's hotel has infinitely many rooms, numbered 0, 1, 2, ... At most one guest occupies each room. Since people tend to check-in in groups, the hotel has a group counter variable $G$.\n\nHilbert's hotel had a grand opening today. Soon after, infinitely many people arrived at once, filling every room in the hotel. All guests got the group number 0, and $G$ is set to 1.\n\nIronically, the hotel can accept more guests even though every room is filled:\n\n- If $k$ ($k \\geq 1$) people arrive at the hotel, then for each room number $x$, the guest in room $x$ moves to room $x+k$. After that, the new guests fill all the rooms from 0 to $k-1$.\n- If infinitely many people arrive at the hotel, then for each room number $x$, the guest in room $x$ moves to room $2x$. After that, the new guests fill all the rooms with odd numbers.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/6rjmwf4t.png)\n:::\n\nYou have to write a program to process the following queries: \n\n- $\\tt{1\\ k}$ - If $k \\geq 1$, then $k$ people arrive at the hotel. If $k = 0$, then infinitely many people arrive at the hotel. Assign the group number $G$ to the new guests, and then increment $G$ by 1.\n- $\\tt{2\\ g\\ x}$ - Find the $x$-th smallest room number that contains a guest with the group number $g$. Output it modulo $10^9 + 7$, followed by a newline.\n- $\\tt{3\\ x}$ - Output the group number of the guest in room $x$, followed by a newline.", "inputFormat": "In the first line, an integer $Q$ ($1 \\leq Q \\leq 300,000$) denoting the number of queries is given. Each of the next lines contains a query. All numbers in the queries are integers.\n\n- For the $\\tt{1\\ k}$ queries, $0 \\leq k \\leq 10^9$.\n- For the $\\tt{2\\ g\\ x}$ queries, $g < G$, $1 \\leq x \\leq 10^9$, and at least $x$ guests have the group number $g$.\n- For the $\\tt{3\\ x}$ queries, $0 \\leq x \\leq 10^9$.", "outputFormat": "Process all queries and output as required. It is guaranteed that the output is not empty.", "hint": "If you know about ``cardinals``, please assume that ``infinite`` refers only to ``countably infinite``. If you don't know about it, then you don't have to worry.", "locale": "en", "translations": {"en": {"title": "[2019 KAIST RUN Fall] Hilbert' s Hotel", "background": "", "description": "Hilbert's hotel has infinitely many rooms, numbered 0, 1, 2, ... At most one guest occupies each room. Since people tend to check-in in groups, the hotel has a group counter variable $G$.\n\nHilbert's hotel had a grand opening today. Soon after, infinitely many people arrived at once, filling every room in the hotel. All guests got the group number 0, and $G$ is set to 1.\n\nIronically, the hotel can accept more guests even though every room is filled:\n\n- If $k$ ($k \\geq 1$) people arrive at the hotel, then for each room number $x$, the guest in room $x$ moves to room $x+k$. After that, the new guests fill all the rooms from 0 to $k-1$.\n- If infinitely many people arrive at the hotel, then for each room number $x$, the guest in room $x$ moves to room $2x$. After that, the new guests fill all the rooms with odd numbers.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/6rjmwf4t.png)\n:::\n\nYou have to write a program to process the following queries: \n\n- $\\tt{1\\ k}$ - If $k \\geq 1$, then $k$ people arrive at the hotel. If $k = 0$, then infinitely many people arrive at the hotel. Assign the group number $G$ to the new guests, and then increment $G$ by 1.\n- $\\tt{2\\ g\\ x}$ - Find the $x$-th smallest room number that contains a guest with the group number $g$. Output it modulo $10^9 + 7$, followed by a newline.\n- $\\tt{3\\ x}$ - Output the group number of the guest in room $x$, followed by a newline.", "inputFormat": "In the first line, an integer $Q$ ($1 \\leq Q \\leq 300,000$) denoting the number of queries is given. Each of the next lines contains a query. All numbers in the queries are integers.\n\n- For the $\\tt{1\\ k}$ queries, $0 \\leq k \\leq 10^9$.\n- For the $\\tt{2\\ g\\ x}$ queries, $g < G$, $1 \\leq x \\leq 10^9$, and at least $x$ guests have the group number $g$.\n- For the $\\tt{3\\ x}$ queries, $0 \\leq x \\leq 10^9$.", "outputFormat": "Process all queries and output as required. It is guaranteed that the output is not empty.", "hint": "If you know about ``cardinals``, please assume that ``infinite`` refers only to ``countably infinite``. If you don't know about it, then you don't have to worry.", "locale": "en"}, "zh-CN": {"title": "[2019 KAIST RUN Fall] Hilbert' s Hotel", "background": "", "description": "希尔伯特旅馆拥有无限多个房间，编号为 0, 1, 2, ... 每个房间最多住一位客人。由于人们倾向于团体入住，旅馆有一个团体计数器变量 $G$。\n\n希尔伯特旅馆今天盛大开业。不久之后，无限多人同时到达，住满了旅馆的每个房间。所有客人都获得了团体编号 0，并且 $G$ 被设置为 1。\n\n讽刺的是，即使每个房间都已住满，旅馆仍然可以接受更多客人：\n\n- 如果有 $k$（$k \\geq 1$）个人到达旅馆，那么对于每个房间号 $x$，房间 $x$ 的客人移动到房间 $x+k$。之后，新客人填满从 0 到 $k-1$ 的所有房间。\n- 如果有无限多个人到达旅馆，那么对于每个房间号 $x$，房间 $x$ 的客人移动到房间 $2x$。之后，新客人填满所有奇数编号的房间。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/6rjmwf4t.png)\n:::\n\n你需要编写一个程序来处理以下查询：\n\n- $\\tt{1\\ k}$ - 如果 $k \\geq 1$，那么 $k$ 个人到达旅馆。如果 $k = 0$，那么无限多个人到达旅馆。将团体编号 $G$ 分配给新客人，然后将 $G$ 增加 1。\n- $\\tt{2\\ g\\ x}$ - 找到包含团体编号为 $g$ 的客人的第 $x$ 小的房间号。输出其对 $10^9 + 7$ 取模的结果，然后换行。\n- $\\tt{3\\ x}$ - 输出房间 $x$ 中客人的团体编号，然后换行。", "inputFormat": "第一行给出一个整数 $Q$（$1 \\leq Q \\leq 300,000$），表示查询的数量。接下来的每行包含一个查询。查询中的所有数字都是整数。\n\n- 对于 $\\tt{1\\ k}$ 查询，$0 \\leq k \\leq 10^9$。\n- 对于 $\\tt{2\\ g\\ x}$ 查询，$g < G$，$1 \\leq x \\leq 10^9$，并且至少有 $x$ 个客人的团体编号为 $g$。\n- 对于 $\\tt{3\\ x}$ 查询，$0 \\leq x \\leq 10^9$。", "outputFormat": "处理所有查询并按需输出。保证输出不为空。", "hint": "如果你了解“基数”的概念，请假设“无限”仅指“可数无限”。如果你不了解，则无需担心。\n\n---\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14618", "type": "P", "difficulty": 4, "samples": [["3 3 1 3\n1 2 1\n2 3 7\n1 3 5", "1 7"], ["3 4 1 3\n1 2 1\n2 1 2\n2 3 7\n1 3 5", "TOO LONG"], ["2 0 2 1", "IMPOSSIBLE"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["图论", "贪心", "2019", "高校校赛"], "title": "[2019 KAIST RUN Fall] Lexicographically Minimum Walk", "background": "", "description": "There is a directed graph $G$ with $N$ nodes and $M$ edges. Each node is numbered $1$ through $N$, and each edge is numbered $1$ through $M$. For each $i$ ($1 \\le i \\le M$), edge $i$ goes from vertex $u_i$ to vertex $v_i$ and has a $\\textbf{unique}$ color $c_i$.\n\nA $\\textit{walk}$ is defined as a sequence of edges $e_1$, $e_2$, $\\cdots$, $e_{l}$ where for each $1 \\le k < l$, $v_{e_k}$ (the tail of edge $e_k$) is the same as $u_{e_{k+1}}$ (the head of edge $e_{k+1}$). We can say a walk $e_1, e_2, \\cdots, e_l$ starts at vertex $u_{e_1}$ and ends at vertex $v_{e_l}$. Note that the same edge can appear multiple times in a walk.\n\nThe $\\textit{color sequence}$ of a walk $e_1, e_2, \\cdots, e_l$ is defined as $c_{e_1}, c_{e_2}, \\cdots, c_{e_l}$.\n\nConsider all color sequences of walks of length at most $10^{100}$ from vertex $S$ to vertex $T$ in $G$. Write a program that finds the lexicographically minimum sequence among them.", "inputFormat": "The first line of the input contains four space-separated integers $N$, $M$, $S$, and $T$ ($1 \\le N \\le 100\\,000$, $0 \\le M \\le 300\\,000$, $1 \\le S \\le N$, $1 \\le T \\le N$, $S \\neq T$).\n\nThen $M$ lines follow: the $j$ ($1 \\le j \\le M$)-th of them contains three space-separated integers $u_i$, $v_i$ and $c_i$ ($1 \\le u_i, v_i \\le N$, $u_i \\neq v_i$, $1 \\le c_i \\le 10^{9}$); it describes a directional edge from vertex $u_i$ to vertex $v_i$ with color $c_i$.\n\nThe graph doesn't have multiple edges and each edge has a unique color. Formally, for any $1 \\le i < j \\le M$, $c_i \\neq c_j$ and $(u_i, v_i) \\neq (u_j, v_j)$ holds. ", "outputFormat": "If there is no walk from vertex $S$ to vertex $T$, print $\\texttt{IMPOSSIBLE}$.  (without quotes)\n\nOtherwise, let's say $a_1, a_2, \\cdots, a_l$ is the lexicographically minimum sequence among all color sequences of length at most $10^{100}$ from vertex $S$ to vertex $T$.\n\n- If $l \\le 10^{6}$, print $a_1, a_2, \\cdots, a_l$ in the first line. There should be a space between each printed integer.\n- If $l > 10^{6}$, print $\\texttt{TOO LONG}$. (without quotes)", "hint": "Sequence $p_1, p_2, \\cdots, p_{n}$ is lexicographically smaller than another sequence $q_1, q_2, \\cdots, q_{m}$ if and only if one of the following holds:\n\n- There exists a unique $j$ ($0 \\le j < \\min(n, m)$) where $p_1 = q_1$, $p_2 = q_2$, $\\cdots$, $p_{j} = q_{j}$ and $p_{j+1} < q_{j+1}$.\n- $n < m$ and $p_1 = q_1$, $p_2 = q_2$, $\\cdots$, $p_n = q_n$. In other words, $p$ is a strict prefix of $q$.", "locale": "en", "translations": {"en": {"title": "[2019 KAIST RUN Fall] Lexicographically Minimum Walk", "background": "", "description": "There is a directed graph $G$ with $N$ nodes and $M$ edges. Each node is numbered $1$ through $N$, and each edge is numbered $1$ through $M$. For each $i$ ($1 \\le i \\le M$), edge $i$ goes from vertex $u_i$ to vertex $v_i$ and has a $\\textbf{unique}$ color $c_i$.\n\nA $\\textit{walk}$ is defined as a sequence of edges $e_1$, $e_2$, $\\cdots$, $e_{l}$ where for each $1 \\le k < l$, $v_{e_k}$ (the tail of edge $e_k$) is the same as $u_{e_{k+1}}$ (the head of edge $e_{k+1}$). We can say a walk $e_1, e_2, \\cdots, e_l$ starts at vertex $u_{e_1}$ and ends at vertex $v_{e_l}$. Note that the same edge can appear multiple times in a walk.\n\nThe $\\textit{color sequence}$ of a walk $e_1, e_2, \\cdots, e_l$ is defined as $c_{e_1}, c_{e_2}, \\cdots, c_{e_l}$.\n\nConsider all color sequences of walks of length at most $10^{100}$ from vertex $S$ to vertex $T$ in $G$. Write a program that finds the lexicographically minimum sequence among them.", "inputFormat": "The first line of the input contains four space-separated integers $N$, $M$, $S$, and $T$ ($1 \\le N \\le 100\\,000$, $0 \\le M \\le 300\\,000$, $1 \\le S \\le N$, $1 \\le T \\le N$, $S \\neq T$).\n\nThen $M$ lines follow: the $j$ ($1 \\le j \\le M$)-th of them contains three space-separated integers $u_i$, $v_i$ and $c_i$ ($1 \\le u_i, v_i \\le N$, $u_i \\neq v_i$, $1 \\le c_i \\le 10^{9}$); it describes a directional edge from vertex $u_i$ to vertex $v_i$ with color $c_i$.\n\nThe graph doesn't have multiple edges and each edge has a unique color. Formally, for any $1 \\le i < j \\le M$, $c_i \\neq c_j$ and $(u_i, v_i) \\neq (u_j, v_j)$ holds. ", "outputFormat": "If there is no walk from vertex $S$ to vertex $T$, print $\\texttt{IMPOSSIBLE}$.  (without quotes)\n\nOtherwise, let's say $a_1, a_2, \\cdots, a_l$ is the lexicographically minimum sequence among all color sequences of length at most $10^{100}$ from vertex $S$ to vertex $T$.\n\n- If $l \\le 10^{6}$, print $a_1, a_2, \\cdots, a_l$ in the first line. There should be a space between each printed integer.\n- If $l > 10^{6}$, print $\\texttt{TOO LONG}$. (without quotes)", "hint": "Sequence $p_1, p_2, \\cdots, p_{n}$ is lexicographically smaller than another sequence $q_1, q_2, \\cdots, q_{m}$ if and only if one of the following holds:\n\n- There exists a unique $j$ ($0 \\le j < \\min(n, m)$) where $p_1 = q_1$, $p_2 = q_2$, $\\cdots$, $p_{j} = q_{j}$ and $p_{j+1} < q_{j+1}$.\n- $n < m$ and $p_1 = q_1$, $p_2 = q_2$, $\\cdots$, $p_n = q_n$. In other words, $p$ is a strict prefix of $q$.", "locale": "en"}, "zh-CN": {"title": "[2019 KAIST RUN Fall] Lexicographically Minimum Walk", "background": "", "description": "有一个包含 $N$ 个节点和 $M$ 条边的有向图 $G$。每个节点编号为 $1$ 到 $N$，每条边编号为 $1$ 到 $M$。对于每个 $i$（$1 \\le i \\le M$），边 $i$ 从顶点 $u_i$ 指向顶点 $v_i$，并且具有 **唯一** 的颜色 $c_i$。\n\n一条 **路径** 定义为边的序列 $e_1, e_2, \\cdots, e_{l}$，其中对于每个 $1 \\le k < l$，$v_{e_k}$（边 $e_k$ 的终点）与 $u_{e_{k+1}}$（边 $e_{k+1}$ 的起点）相同。我们可以说路径 $e_1, e_2, \\cdots, e_l$ 从顶点 $u_{e_1}$ 开始，到顶点 $v_{e_l}$ 结束。注意同一条边可以在一条路径中出现多次。\n\n路径 $e_1, e_2, \\cdots, e_l$ 的 **颜色序列** 定义为 $c_{e_1}, c_{e_2}, \\cdots, c_{e_l}$。\n\n考虑图 $G$ 中从顶点 $S$ 到顶点 $T$ 的所有长度不超过 $10^{100}$ 的路径的颜色序列。请编写一个程序，找出这些序列中字典序最小的序列。", "inputFormat": "输入的第一行包含四个以空格分隔的整数 $N$、$M$、$S$ 和 $T$（$1 \\le N \\le 100,000$，$0 \\le M \\le 300,000$，$1 \\le S \\le N$，$1 \\le T \\le N$，$S \\neq T$）。\n\n接下来是 $M$ 行：第 $j$（$1 \\le j \\le M$）行包含三个以空格分隔的整数 $u_i$、$v_i$ 和 $c_i$（$1 \\le u_i, v_i \\le N$，$u_i \\neq v_i$，$1 \\le c_i \\le 10^{9}$）；它描述了一条从顶点 $u_i$ 指向顶点 $v_i$ 且颜色为 $c_i$ 的有向边。\n\n图中没有重边，且每条边有唯一的颜色。形式化地说，对于任意 $1 \\le i < j \\le M$，$c_i \\neq c_j$ 且 $(u_i, v_i) \\neq (u_j, v_j)$ 成立。", "outputFormat": "如果不存在从顶点 $S$ 到顶点 $T$ 的路径，输出 `IMPOSSIBLE`（不带引号）。\n\n否则，设 $a_1, a_2, \\cdots, a_l$ 是从顶点 $S$ 到顶点 $T$ 的所有长度不超过 $10^{100}$ 的路径的颜色序列中字典序最小的序列。\n\n- 如果 $l \\le 10^{6}$，在第一行输出 $a_1, a_2, \\cdots, a_l$。每个输出的整数之间应有空格。\n- 如果 $l > 10^{6}$，输出 `TOO LONG`（不带引号）。", "hint": "序列 $p_1, p_2, \\cdots, p_{n}$ 在字典序上小于另一个序列 $q_1, q_2, \\cdots, q_{m}$，当且仅当以下条件之一成立：\n\n- 存在唯一的 $j$（$0 \\le j < \\min(n, m)$）使得 $p_1 = q_1$，$p_2 = q_2$，$\\cdots$，$p_{j} = q_{j}$ 且 $p_{j+1} < q_{j+1}$。\n- $n < m$ 且 $p_1 = q_1$，$p_2 = q_2$，$\\cdots$，$p_n = q_n$。换句话说，$p$ 是 $q$ 的严格前缀。\n\n---\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14619", "type": "P", "difficulty": 4, "samples": [["3\n1 2 3\n1 2 3", "2"], ["4\n3 4 1 2\n3 2 4 1", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "高校校赛"], "title": "[2019 KAIST RUN Fall] Maximizer", "background": "", "description": "Maximizer has two permutations $A=[a_1,a_2,\\cdots,a_N]$ and $B=[b_1,b_2,\\cdots,b_N]$. Both $A, B$ have length $N$ and consists of $\\textbf{distinct integers}$ from $1$ to $N$. \n\nMaximizer wants to maximize the sum of differences of each element, $\\sum_{i=1}^{N} |a_i - b_i|$. But he can only swap two adjacent elements in $A$. Precisely, he can only swap $a_i$ and $a_{i+1}$ for some $i$ from $1$ to $N-1$. He can swap as many times as he wants.\n\nWhat is the minimum number of swaps required for maximizing the difference sum?", "inputFormat": "The first line contains an integer $N$. ($1 \\leq N \\leq 250 000$)\n\nThe second line contains $N$ integers $a_1,a_2,\\cdots,a_N$ ($1 \\leq a_i \\leq N$).\n\nThe third line contains $N$ integers $b_1,b_2,\\cdots,b_N$ ($1 \\leq b_i \\leq N$).\n\nEach of $[a_1,a_2,\\cdots,a_N]$ and $[b_1,b_2,\\cdots,b_N]$ is a permutation. In other words, it is consisted of distinct integers from $1$ to $N$.", "outputFormat": "Print an integer, the minimum number of swaps required for maximizing the difference sum.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[2019 KAIST RUN Fall] Maximizer", "background": "", "description": "Maximizer has two permutations $A=[a_1,a_2,\\cdots,a_N]$ and $B=[b_1,b_2,\\cdots,b_N]$. Both $A, B$ have length $N$ and consists of $\\textbf{distinct integers}$ from $1$ to $N$. \n\nMaximizer wants to maximize the sum of differences of each element, $\\sum_{i=1}^{N} |a_i - b_i|$. But he can only swap two adjacent elements in $A$. Precisely, he can only swap $a_i$ and $a_{i+1}$ for some $i$ from $1$ to $N-1$. He can swap as many times as he wants.\n\nWhat is the minimum number of swaps required for maximizing the difference sum?", "inputFormat": "The first line contains an integer $N$. ($1 \\leq N \\leq 250 000$)\n\nThe second line contains $N$ integers $a_1,a_2,\\cdots,a_N$ ($1 \\leq a_i \\leq N$).\n\nThe third line contains $N$ integers $b_1,b_2,\\cdots,b_N$ ($1 \\leq b_i \\leq N$).\n\nEach of $[a_1,a_2,\\cdots,a_N]$ and $[b_1,b_2,\\cdots,b_N]$ is a permutation. In other words, it is consisted of distinct integers from $1$ to $N$.", "outputFormat": "Print an integer, the minimum number of swaps required for maximizing the difference sum.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[2019 KAIST RUN Fall] Maximizer", "background": "", "description": "Maximizer 有两个排列 $A=[a_1,a_2,\\cdots,a_N]$ 和 $B=[b_1,b_2,\\cdots,b_N]$。$A$ 和 $B$ 的长度均为 $N$，且都由 $1$ 到 $N$ 的 **互不相同的整数** 组成。\n\nMaximizer 想要最大化每个元素差值的和，即 $\\sum_{i=1}^{N} |a_i - b_i|$。但他只能交换 $A$ 中相邻的两个元素。具体来说，他只能交换 $a_i$ 和 $a_{i+1}$，其中 $i$ 从 $1$ 到 $N-1$。他可以进行任意多次交换。\n\n为了最大化差值之和，所需的最小交换次数是多少？", "inputFormat": "第一行包含一个整数 $N$（$1 \\leq N \\leq 250,000$）。\n\n第二行包含 $N$ 个整数 $a_1,a_2,\\cdots,a_N$（$1 \\leq a_i \\leq N$）。\n\n第三行包含 $N$ 个整数 $b_1,b_2,\\cdots,b_N$（$1 \\leq b_i \\leq N$）。\n\n$[a_1,a_2,\\cdots,a_N]$ 和 $[b_1,b_2,\\cdots,b_N]$ 都是排列。换句话说，它们都由 $1$ 到 $N$ 的互不相同的整数组成。", "outputFormat": "输出一个整数，表示为了最大化差值之和所需的最小交换次数。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14620", "type": "P", "difficulty": 5, "samples": [["3 3\n1 2 1\n2 3 1\n3 1 1", "2\n1 2\n3 1"], ["6 7\n1 2 10\n2 3 20\n1 3 30\n3 4 1000\n4 5 30\n5 6 20\n4 6 10", "1060\n3 4\n6 4\n5 6\n2 3\n1 2"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["图论", "2019", "Special Judge", "最短路", "高校校赛"], "title": "[2019 KAIST RUN Fall] Minimum Diameter Spanning Tree", "background": "", "description": "You are given a simple connected undirected weighted graph $G$ with $N$ nodes and $M$ edges. Each node is numbered 1 through $N$.\n\nA spanning tree of $G$ is a subgraph of $G$, which is a tree and connects all the vertices of $G$. The diameter of a tree is the length of the longest path among the paths between any two nodes in the tree. A minimum diameter spanning tree of $G$ is a spanning tree of $G$ that has a minimum diameter.\n\nWrite a program that finds any minimum diameter spanning tree.", "inputFormat": "The first line of the input contains two integers $N$ ($2 \\le N \\le 500$) and $M$ ($N-1 \\le M \\le \\frac{N(N-1)}{2}$).\n\nThen $M$ lines follow: The $i$ ($1 \\le i \\le M$)-th line contains three space-separated integers $u_i$, $v_i$ and $l_i$ ($1 \\le u_i, v_i \\le N$, $1 \\le l_i \\le 10^9$); it describes a bidirectional edge connecting vertex $u_i$ and vertex $v_i$ with length $l_i$.\n\nIt is guaranteed that the given graph doesn't have any loops or multiple edges, and the graph is connected. ", "outputFormat": "In the first line, print the diameter of the minimum diameter spanning tree of $G$. \n\nIn the next $N-1$ lines, print the description of the edges in the minimum diameter spanning tree of $G$. The $j$ ($1 \\le j \\le N-1$)-th line should contain two space-separated integers $x_i$ and $y_i$ ($1 \\le x_i, y_i \\le N$); it describes a bidirectional edge connecting vertex $x_i$ and $y_i$. \n\nIf there are several possible answers, print any one of them.", "hint": "", "locale": "en", "translations": {"en": {"title": "[2019 KAIST RUN Fall] Minimum Diameter Spanning Tree", "background": "", "description": "You are given a simple connected undirected weighted graph $G$ with $N$ nodes and $M$ edges. Each node is numbered 1 through $N$.\n\nA spanning tree of $G$ is a subgraph of $G$, which is a tree and connects all the vertices of $G$. The diameter of a tree is the length of the longest path among the paths between any two nodes in the tree. A minimum diameter spanning tree of $G$ is a spanning tree of $G$ that has a minimum diameter.\n\nWrite a program that finds any minimum diameter spanning tree.", "inputFormat": "The first line of the input contains two integers $N$ ($2 \\le N \\le 500$) and $M$ ($N-1 \\le M \\le \\frac{N(N-1)}{2}$).\n\nThen $M$ lines follow: The $i$ ($1 \\le i \\le M$)-th line contains three space-separated integers $u_i$, $v_i$ and $l_i$ ($1 \\le u_i, v_i \\le N$, $1 \\le l_i \\le 10^9$); it describes a bidirectional edge connecting vertex $u_i$ and vertex $v_i$ with length $l_i$.\n\nIt is guaranteed that the given graph doesn't have any loops or multiple edges, and the graph is connected. ", "outputFormat": "In the first line, print the diameter of the minimum diameter spanning tree of $G$. \n\nIn the next $N-1$ lines, print the description of the edges in the minimum diameter spanning tree of $G$. The $j$ ($1 \\le j \\le N-1$)-th line should contain two space-separated integers $x_i$ and $y_i$ ($1 \\le x_i, y_i \\le N$); it describes a bidirectional edge connecting vertex $x_i$ and $y_i$. \n\nIf there are several possible answers, print any one of them.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[2019 KAIST RUN Fall] Minimum Diameter Spanning Tree", "background": "", "description": "给定一个具有 $N$ 个节点和 $M$ 条边的简单连通无向加权图 $G$。每个节点编号为 $1$ 到 $N$。\n\n$G$ 的一棵生成树是 $G$ 的一个子图，它是一棵树并且连接了 $G$ 的所有顶点。一棵树的直径是树中任意两个节点之间的路径中最长路径的长度。$G$ 的一棵最小直径生成树是 $G$ 的生成树中直径最小的那棵。\n\n请编写一个程序，找出任意一棵最小直径生成树。", "inputFormat": "输入的第一行包含两个整数 $N$（$2 \\le N \\le 500$）和 $M$（$N-1 \\le M \\le \\frac{N(N-1)}{2}$）。\n\n接下来是 $M$ 行：第 $i$（$1 \\le i \\le M$）行包含三个以空格分隔的整数 $u_i$、$v_i$ 和 $l_i$（$1 \\le u_i, v_i \\le N$，$1 \\le l_i \\le 10^9$）；它描述了一条连接顶点 $u_i$ 和顶点 $v_i$、长度为 $l_i$ 的双向边。\n\n保证给定的图没有任何自环或多重边，并且图是连通的。", "outputFormat": "第一行输出 $G$ 的最小直径生成树的直径。\n\n接下来的 $N-1$ 行，输出最小直径生成树中边的描述。第 $j$（$1 \\le j \\le N-1$）行应包含两个以空格分隔的整数 $x_i$ 和 $y_i$（$1 \\le x_i, y_i \\le N$）；它描述了一条连接顶点 $x_i$ 和 $y_i$ 的双向边。\n\n如果有多个可能的答案，输出其中任意一个。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14621", "type": "P", "difficulty": 6, "samples": [["6\n1 2 10\n2 3 10\n1 3 21\n3 4 10\n4 5 10\n3 5 19", "41 80 80 80 80 80"], ["4\n1 5 1\n2 5 1\n3 5 1\n4 5 1", "1 2 3 4\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "贪心", "2019", "高校校赛", "启发式合并"], "title": "[2019 KAIST RUN Fall] Parklife", "background": "", "description": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/4t1vehaj.png)\n\nGapcheon and an Expo bridge in a cloudy day\n:::\n\n$\\textit{Gapcheon}$ is a stream that flows through the $\\textit{Daedeok Innopolis}$: A research district in Daejeon which includes KAIST, Expo Science Park, National Science Museum, among many others. The waterfront of Gapcheon is used as a park, which is a facility for leisure and recreation. \n\nIn this problem, we model the $\\textit{Gapcheon}$ as a slightly curved arc. In the arc, there are exactly $10^6$ points marked by each centimeter. In $\\textit{Gapcheon}$, there are $N$ bridges that connect two distinct points in the arc in a straight line segment. Such a line segment may touch other segments in an endpoint but never crosses them otherwise. For each pair of points, there exists at most one bridge that directly connects those two points.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/xjyso302.png)\n\n$x, y, z$ are bridges that do not cross but only touch each other in an endpoint. This can be a possible input instance. Points with number $8 \\ldots 10^6$ are omitted for brevity.\n:::\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/t1kvvdps.png)\n\n$x, y$ are bridges that cross each other. This is not a possible input instance. Points with number $8 \\ldots 10^6$ are omitted for brevity.\n:::\n\nThe city council is planning to place some lights in the bridges, to make Gapcheon as a more enjoyable place in the night. For each bridge, the city council calculated the aesthetical value if the lights are installed in these bridges. These value can be represented as a positive integer. \n\nHowever, too many lightings will annoy the residents at midnight. To address this issue, the council decided to make some regulations: for every arc between two adjacent points, there should be at most $k$ lighted bridges visible from there. We call a line segment $\\textbf{visible}$ from an arc connecting $i, i+1$, when one endpoint of the segment has an index at most $i$, and another endpoint of the segment has an index at least $i+1$.\n\nThe city council wants to consider the tradeoff between light pollution and the night view, so you should provide the maximum possible sum of aesthetical value, for all integers $1 \\le k \\le N$.", "inputFormat": "The first line contains an integer $N$. ($1 \\le N \\le 250\\,000$)\n\nThe next $N$ lines contain three integers $S_i, E_i, V_i$, which denotes there is a straight line bridge connecting points $S_i, E_i$, and having aesthetic value $V_i$. ($1 \\le S_i < E_i \\le 10^6, 1 \\le V_i \\le 10^9$).\n\nIt's guaranteed that no lines connect the same pair of points, and no two different line segments cross.", "outputFormat": "Print $N$ integers separated by a space. The $i$-th integer ($1 \\le i \\le N$) should be the answer if $k = i$. ", "hint": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/a4g7soot.png)\n\nDepiction of Sample Input 1.\n:::\n\nCopyright notice for Figure 1: 사진제공(한국관광공사 김지호)-한국관광공사 ", "locale": "en", "translations": {"en": {"title": "[2019 KAIST RUN Fall] Parklife", "background": "", "description": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/4t1vehaj.png)\n\nGapcheon and an Expo bridge in a cloudy day\n:::\n\n$\\textit{Gapcheon}$ is a stream that flows through the $\\textit{Daedeok Innopolis}$: A research district in Daejeon which includes KAIST, Expo Science Park, National Science Museum, among many others. The waterfront of Gapcheon is used as a park, which is a facility for leisure and recreation. \n\nIn this problem, we model the $\\textit{Gapcheon}$ as a slightly curved arc. In the arc, there are exactly $10^6$ points marked by each centimeter. In $\\textit{Gapcheon}$, there are $N$ bridges that connect two distinct points in the arc in a straight line segment. Such a line segment may touch other segments in an endpoint but never crosses them otherwise. For each pair of points, there exists at most one bridge that directly connects those two points.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/xjyso302.png)\n\n$x, y, z$ are bridges that do not cross but only touch each other in an endpoint. This can be a possible input instance. Points with number $8 \\ldots 10^6$ are omitted for brevity.\n:::\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/t1kvvdps.png)\n\n$x, y$ are bridges that cross each other. This is not a possible input instance. Points with number $8 \\ldots 10^6$ are omitted for brevity.\n:::\n\nThe city council is planning to place some lights in the bridges, to make Gapcheon as a more enjoyable place in the night. For each bridge, the city council calculated the aesthetical value if the lights are installed in these bridges. These value can be represented as a positive integer. \n\nHowever, too many lightings will annoy the residents at midnight. To address this issue, the council decided to make some regulations: for every arc between two adjacent points, there should be at most $k$ lighted bridges visible from there. We call a line segment $\\textbf{visible}$ from an arc connecting $i, i+1$, when one endpoint of the segment has an index at most $i$, and another endpoint of the segment has an index at least $i+1$.\n\nThe city council wants to consider the tradeoff between light pollution and the night view, so you should provide the maximum possible sum of aesthetical value, for all integers $1 \\le k \\le N$.", "inputFormat": "The first line contains an integer $N$. ($1 \\le N \\le 250\\,000$)\n\nThe next $N$ lines contain three integers $S_i, E_i, V_i$, which denotes there is a straight line bridge connecting points $S_i, E_i$, and having aesthetic value $V_i$. ($1 \\le S_i < E_i \\le 10^6, 1 \\le V_i \\le 10^9$).\n\nIt's guaranteed that no lines connect the same pair of points, and no two different line segments cross.", "outputFormat": "Print $N$ integers separated by a space. The $i$-th integer ($1 \\le i \\le N$) should be the answer if $k = i$. ", "hint": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/a4g7soot.png)\n\nDepiction of Sample Input 1.\n:::\n\nCopyright notice for Figure 1: 사진제공(한국관광공사 김지호)-한국관광공사 ", "locale": "en"}, "zh-CN": {"title": "[2019 KAIST RUN Fall] Parklife", "background": "", "description": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/4t1vehaj.png)\n\n阴天时的甲川和世博桥\n:::\n\n**甲川**（Gapcheon）是一条流经 **大德研发特区** 的溪流：这是大田市的一个研究区，包括韩国科学技术院（KAIST）、世博科学公园、国家科学博物馆等许多机构。甲川的滨水区被用作公园，是休闲娱乐的设施。\n\n在这个问题中，我们将 **甲川** 建模为一个略微弯曲的弧形。在这个弧形中，每隔一厘米恰好标记了 $10^6$ 个点。在 **甲川** 上有 $N$ 座桥，每座桥以直线段连接弧上的两个不同点。这样的线段可能在端点处接触其他线段，但除此之外永远不会相交。对于任意一对点，最多存在一座桥直接连接这两个点。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/xjyso302.png)\n\n$x, y, z$ 是互不交叉但仅在端点处接触的桥。这是一个可能的输入实例。编号为 $8 \\ldots 10^6$ 的点为简洁起见被省略。\n:::\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/t1kvvdps.png)\n\n$x, y$ 是相互交叉的桥。这不是一个可能的输入实例。编号为 $8 \\ldots 10^6$ 的点为简洁起见被省略。\n:::\n\n市议会计划在桥上安装一些灯光，使甲川在夜晚成为更宜人的场所。对于每座桥，市议会计算了在这些桥上安装灯光的审美价值。这些价值可以用正整数表示。\n\n然而，过多的灯光会在午夜打扰居民。为了解决这个问题，议会制定了一些规定：对于每两个相邻点之间的弧段，从该处可见的点亮桥梁最多为 $k$ 座。当一条线段的一个端点索引不大于 $i$，另一个端点索引不小于 $i+1$ 时，我们称该线段从连接 $i$ 和 $i+1$ 的弧段 **可见**。\n\n市议会希望考虑光污染和夜景之间的权衡，因此你需要为所有整数 $1 \\le k \\le N$ 提供可能的最大审美价值总和。", "inputFormat": "第一行包含一个整数 $N$（$1 \\le N \\le 250,000$）。\n\n接下来的 $N$ 行每行包含三个整数 $S_i, E_i, V_i$，表示存在一座直线桥连接点 $S_i$ 和 $E_i$，并具有审美价值 $V_i$（$1 \\le S_i < E_i \\le 10^6$，$1 \\le V_i \\le 10^9$）。\n\n保证没有桥连接相同的点对，且没有两条不同的线段相交。", "outputFormat": "输出 $N$ 个以空格分隔的整数。第 $i$ 个整数（$1 \\le i \\le N$）应为 $k = i$ 时的答案。\n", "hint": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/a4g7soot.png)\n\n样例输入 1 的图示。\n:::\n\n图 1 的版权声明：사진제공(한국관광공사 김지호)-한국관광공사\n\n---\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14622", "type": "P", "difficulty": 6, "samples": [["5\n1 2 10\n2 4 20\n3 4 30\n4 5 50\n1 2 15\n1 3 25\n1 4 35\n1 5 25", "25\n25\n85\n65\n105"], ["9\n5 7 6577\n4 5 8869\n5 9 9088\n2 1 124\n6 2 410\n2 8 8154\n4 8 4810\n3 4 4268\n3 9 763\n6 2 8959\n7 4 7984\n3 8 504\n8 6 9085\n5 2 4861\n1 9 8539\n1 7 7834", "18084\n9369\n9582\n23430\n26694\n9369\n23430\n9582\n22988"]], "limits": {"time": [12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "点分治", "高校校赛"], "title": "[2019 KAIST RUN Fall] Wind of Change", "background": "", "description": "The original title of this problem is \"Tree Product Metric Voronoi Diagram Query Without One Point\".\n\nYou are given two weighted trees $T_1,\\ T_2$ of size $N$, where each vertex are labeled with numbers $1 \\ldots N$. Let $dist(T_1,\\ i,\\ j)$ be the total weight of the shortest path from node $i$ to $j$ in tree $T_1$, and define $dist(T_2,\\ i,\\ j)$ similarly. \n\nConsider a point set of size $N$. Similar to Manhattan metric (in fact, this is a generalization of it), we can define the distance between two points $1 \\le i,\\ j \\le N$: It is the sum of two distances, $dist(T_1,\\ i,\\ j) + dist(T_2,\\ i,\\ j)$. For each $1 \\le i \\le N$, please determine the \"closest point\" from the point $i$. Formally, for each $i$, you should find $\\min_{j \\neq i}{dist(T_1,\\ i,\\ j) + dist(T_2,\\ i,\\ j)}$. ", "inputFormat": "In the first line, a single integer $N$ denoting the number of vertices in both trees is given. ($2 \\le N \\le 250\\,000$)\n\nIn the next $N-1$ lines, description of the first tree is given. Each of the $N-1$ lines contains three integers $S_i, E_i, W_i$, which indicates there is an edge connecting two vertices $S_i, E_i$ with weight $W_i$ ($1 \\le S_i, E_i \\le N, 1 \\le W_i \\le 10^9$)\n\nIn the next $N-1$ lines, description of the second tree is given in the same format.", "outputFormat": "Print $N$ lines containing a single integer. In the $i$-th line, you should print a single integer denoting the answer for the point $i$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[2019 KAIST RUN Fall] Wind of Change", "background": "", "description": "The original title of this problem is \"Tree Product Metric Voronoi Diagram Query Without One Point\".\n\nYou are given two weighted trees $T_1,\\ T_2$ of size $N$, where each vertex are labeled with numbers $1 \\ldots N$. Let $dist(T_1,\\ i,\\ j)$ be the total weight of the shortest path from node $i$ to $j$ in tree $T_1$, and define $dist(T_2,\\ i,\\ j)$ similarly. \n\nConsider a point set of size $N$. Similar to Manhattan metric (in fact, this is a generalization of it), we can define the distance between two points $1 \\le i,\\ j \\le N$: It is the sum of two distances, $dist(T_1,\\ i,\\ j) + dist(T_2,\\ i,\\ j)$. For each $1 \\le i \\le N$, please determine the \"closest point\" from the point $i$. Formally, for each $i$, you should find $\\min_{j \\neq i}{dist(T_1,\\ i,\\ j) + dist(T_2,\\ i,\\ j)}$. ", "inputFormat": "In the first line, a single integer $N$ denoting the number of vertices in both trees is given. ($2 \\le N \\le 250\\,000$)\n\nIn the next $N-1$ lines, description of the first tree is given. Each of the $N-1$ lines contains three integers $S_i, E_i, W_i$, which indicates there is an edge connecting two vertices $S_i, E_i$ with weight $W_i$ ($1 \\le S_i, E_i \\le N, 1 \\le W_i \\le 10^9$)\n\nIn the next $N-1$ lines, description of the second tree is given in the same format.", "outputFormat": "Print $N$ lines containing a single integer. In the $i$-th line, you should print a single integer denoting the answer for the point $i$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[2019 KAIST RUN Fall] Wind of Change", "background": "", "description": "本题的原标题是“无一点树乘积度量 Voronoi 图查询”。\n\n给定两个大小为 $N$ 的带权树 $T_1$ 和 $T_2$，其中每个顶点用数字 $1 \\ldots N$ 标记。设 $dist(T_1,\\ i,\\ j)$ 为树 $T_1$ 中从节点 $i$ 到节点 $j$ 的最短路径的总权重，类似地定义 $dist(T_2,\\ i,\\ j)$。\n\n考虑一个大小为 $N$ 的点集。类似于曼哈顿度量（实际上，这是它的推广），我们可以定义两个点 $1 \\le i,\\ j \\le N$ 之间的距离：它是两个距离之和，即 $dist(T_1,\\ i,\\ j) + dist(T_2,\\ i,\\ j)$。对于每个 $1 \\le i \\le N$，请确定从点 $i$ 出发的\"最近点\"。形式化地说，对于每个 $i$，你需要找到 $\\min_{j \\neq i}{dist(T_1,\\ i,\\ j) + dist(T_2,\\ i,\\ j)}$。", "inputFormat": "第一行给出一个整数 $N$，表示两棵树中的顶点数（$2 \\le N \\le 250,000$）。\n\n接下来的 $N-1$ 行给出第一棵树的描述。这 $N-1$ 行中的每一行包含三个整数 $S_i, E_i, W_i$，表示存在一条连接顶点 $S_i$ 和 $E_i$ 且权重为 $W_i$ 的边（$1 \\le S_i, E_i \\le N$，$1 \\le W_i \\le 10^9$）。\n\n接下来的 $N-1$ 行以相同格式给出第二棵树的描述。", "outputFormat": "输出 $N$ 行，每行包含一个整数。在第 $i$ 行，你应输出一个整数表示点 $i$ 的答案。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14623", "type": "P", "difficulty": 5, "samples": [["6 5 5\n1 3\n2 3\n1 4\n6 3\n5 2\n5 1 3\n6 2 2\n2 3 1\n4 4 1\n1 5 0", "1\n2\n2\n3\n1"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "线段树", "颜色段均摊（珂朵莉树 ODT）", "树链剖分", "动态树 LCT", "高校校赛"], "title": "[2018 KAIST RUN Fall] Coloring Roads", "background": "", "description": "In RUN-land, there are $n$ cities numbered $1$ to $n$. Some pairs of cities are connected by a bidirectional road. It happens that there are $n-1$ roads in total and that for any two cities, and there is a unique path from one to the other.\n\nThe city number $1$ is the capital. Initially all roads have no color. Alex, the king of RUN-land asks you to perform the following query $Q$ times.\n\n- $\\tt{u\\ c\\ m}$: Given a city $u$, a color $c$, and an integer $m$, color all the roads on the unique path from $u$ to the capital in the color $c$. Even if a road already has a color, change its color to $c$. After coloring, compute the number of colors in which exactly $m$ roads are colored.\n\nGiven $Q$ queries in total, compute the answer for the second part of each query.", "inputFormat": "The first line of the input contains three integers $n,C,Q$ ($1\\leq n,C,Q\\leq 2\\times 10^5$), separated by a single space, which are the number of cities in RUN-land, the number of possible colors, and the number of queries, respectively. Each of the next $n-1$ lines contains two integers $u,v$ ($1\\leq u,v\\leq n$) meaning that there is a bidirectional road directly connecting the cities numbered $u$ and $v$.\n\nEach of the next $Q$ lines contains a query, which contains $3$ integers $u,c,m$ as described in the statement. ($1\\leq u\\leq n$, $1\\leq c\\leq C$, $0\\leq m\\leq n-1$)", "outputFormat": "Print $Q$ lines, one for each query. Each line must contain one integer, the answer to the corresponding query.", "hint": "The answer for the last query is $1$ since color $5$ is used in $0$ roads.", "locale": "en", "translations": {"en": {"title": "[2018 KAIST RUN Fall] Coloring Roads", "background": "", "description": "In RUN-land, there are $n$ cities numbered $1$ to $n$. Some pairs of cities are connected by a bidirectional road. It happens that there are $n-1$ roads in total and that for any two cities, and there is a unique path from one to the other.\n\nThe city number $1$ is the capital. Initially all roads have no color. Alex, the king of RUN-land asks you to perform the following query $Q$ times.\n\n- $\\tt{u\\ c\\ m}$: Given a city $u$, a color $c$, and an integer $m$, color all the roads on the unique path from $u$ to the capital in the color $c$. Even if a road already has a color, change its color to $c$. After coloring, compute the number of colors in which exactly $m$ roads are colored.\n\nGiven $Q$ queries in total, compute the answer for the second part of each query.", "inputFormat": "The first line of the input contains three integers $n,C,Q$ ($1\\leq n,C,Q\\leq 2\\times 10^5$), separated by a single space, which are the number of cities in RUN-land, the number of possible colors, and the number of queries, respectively. Each of the next $n-1$ lines contains two integers $u,v$ ($1\\leq u,v\\leq n$) meaning that there is a bidirectional road directly connecting the cities numbered $u$ and $v$.\n\nEach of the next $Q$ lines contains a query, which contains $3$ integers $u,c,m$ as described in the statement. ($1\\leq u\\leq n$, $1\\leq c\\leq C$, $0\\leq m\\leq n-1$)", "outputFormat": "Print $Q$ lines, one for each query. Each line must contain one integer, the answer to the corresponding query.", "hint": "The answer for the last query is $1$ since color $5$ is used in $0$ roads.", "locale": "en"}, "zh-CN": {"title": "[2018 KAIST RUN Fall] Coloring Roads", "background": "", "description": "在 RUN 国，有 $n$ 个编号为 $1$ 到 $n$ 的城市。一些城市对之间由双向道路连接。恰好总共有 $n-1$ 条道路，并且对于任意两个城市，都存在唯一的路径连接它们。\n\n编号为 $1$ 的城市是首都。最初所有道路都没有颜色。RUN 国的国王 Alex 要求你执行以下查询 $Q$ 次。\n\n- $\\tt{u\\ c\\ m}$：给定一个城市 $u$，一种颜色 $c$，和一个整数 $m$，将从 $u$ 到首都的唯一路径上的所有道路涂成颜色 $c$。即使道路已经有颜色，也要将其颜色改为 $c$。染色后，计算恰好有 $m$ 条道路被染色的颜色数量。\n\n给定总共 $Q$ 次查询，计算每次查询第二部分的答案。", "inputFormat": "输入的第一行包含三个整数 $n, C, Q$（$1 \\leq n, C, Q \\leq 2 \\times 10^5$），以单个空格分隔，分别表示 RUN 国的城市数量、可能的颜色数量和查询数量。接下来的 $n-1$ 行每行包含两个整数 $u, v$（$1 \\leq u, v \\leq n$），表示存在一条直接连接编号为 $u$ 和 $v$ 的城市之间的双向道路。\n\n接下来的 $Q$ 行每行包含一个查询，包含 $3$ 个整数 $u, c, m$，如题目描述所述（$1 \\leq u \\leq n$，$1 \\leq c \\leq C$，$0 \\leq m \\leq n-1$）。", "outputFormat": "输出 $Q$ 行，每行对应一个查询。每行必须包含一个整数，即对应查询的答案。\n", "hint": "最后一个查询的答案是 $1$，因为颜色 $5$ 被用于 $0$ 条道路。\n\n---\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14624", "type": "P", "difficulty": 0, "samples": [["3 3\n1 3\n1 3\n1 3\n1 2\n2 3\n3 1", "-1"], ["3 3\n1 3\n1 3\n1 3\n1 2\n2 3\n1 3", "1\n2\n3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "Special Judge", "高校校赛"], "title": "[2018 KAIST RUN Fall] Dumae", "background": "", "description": "Do you know $\\textit{Dumae}$? It is a nickname of the most famous restaurant nearby KAIST, $\\textit{Dumae Charcoal-grilled Barbecue}$. Because $\\textit{Dumae}$ is a very famous restaurant, lots of KAIST students stand in line even though it has not opened yet. Students wonder how long they have to wait, so they started to guess their order.\n\nThere are $N$ students in waiting line and each of them has a distinct student ID from $1$ to $N$. Student $i$ (student with student ID $i$) guessed that he/she is either $L_i$-th, $(L_i+1)$-th, ..., $(R_i-1)$-th, or $R_i$-th person in the line. (i.e. the number of people standing relatively in front of him/her is in the interval $\\left[L_{i} - 1, R_{i} - 1\\right]$) Also, $M$ claims are made, of which the $i$-th says that student $v_i$ can see student $u_i$ in the waiting line. It means student $u_i$ is relatively in front of student $v_i$.\n\nYou wonder if all of students' guesses and claims were right. Find an order of waiting line that satisfies all the guesses and claims, or report that such an order does not exist.", "inputFormat": "The first line contains two space-separated integers $N, M$. ($1 \\leq N \\leq 300\\,000, 0 \\leq M \\leq 1\\,000\\,000$)\n\nIn the next $N$ lines, two space-separated integers $L_i, R_i$ are given. ($1 \\leq L_i \\leq R_i \\leq N$)\n\nIn the next $M$ lines, two space-separated integers $u_i, v_i$ are given. ($1 \\leq u_i \\leq N$, $1 \\leq v_i \\leq N$, $u_i \\neq v_i$)", "outputFormat": "If there is no answer that satisfies the condition, print $-1$.\n\nOtherwise, print $N$ lines.\nIn the $i$-th line, print the student ID of the $i$-th student from the front.", "hint": "", "locale": "en", "translations": {"en": {"title": "[2018 KAIST RUN Fall] Dumae", "background": "", "description": "Do you know $\\textit{Dumae}$? It is a nickname of the most famous restaurant nearby KAIST, $\\textit{Dumae Charcoal-grilled Barbecue}$. Because $\\textit{Dumae}$ is a very famous restaurant, lots of KAIST students stand in line even though it has not opened yet. Students wonder how long they have to wait, so they started to guess their order.\n\nThere are $N$ students in waiting line and each of them has a distinct student ID from $1$ to $N$. Student $i$ (student with student ID $i$) guessed that he/she is either $L_i$-th, $(L_i+1)$-th, ..., $(R_i-1)$-th, or $R_i$-th person in the line. (i.e. the number of people standing relatively in front of him/her is in the interval $\\left[L_{i} - 1, R_{i} - 1\\right]$) Also, $M$ claims are made, of which the $i$-th says that student $v_i$ can see student $u_i$ in the waiting line. It means student $u_i$ is relatively in front of student $v_i$.\n\nYou wonder if all of students' guesses and claims were right. Find an order of waiting line that satisfies all the guesses and claims, or report that such an order does not exist.", "inputFormat": "The first line contains two space-separated integers $N, M$. ($1 \\leq N \\leq 300\\,000, 0 \\leq M \\leq 1\\,000\\,000$)\n\nIn the next $N$ lines, two space-separated integers $L_i, R_i$ are given. ($1 \\leq L_i \\leq R_i \\leq N$)\n\nIn the next $M$ lines, two space-separated integers $u_i, v_i$ are given. ($1 \\leq u_i \\leq N$, $1 \\leq v_i \\leq N$, $u_i \\neq v_i$)", "outputFormat": "If there is no answer that satisfies the condition, print $-1$.\n\nOtherwise, print $N$ lines.\nIn the $i$-th line, print the student ID of the $i$-th student from the front.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[2018 KAIST RUN Fall] Dumae", "background": "", "description": "你知道 **Dumae** 吗？这是 KAIST 附近最著名的餐厅 **Dumae 炭火烧烤** 的昵称。因为 **Dumae** 是一家非常著名的餐厅，所以很多 KAIST 学生在餐厅还没开门时就开始排队。学生们想知道他们需要等多久，于是开始猜测自己的排队顺序。\n\n等待队列中有 $N$ 名学生，每名学生有一个从 $1$ 到 $N$ 的唯一学号。学生 $i$（学号为 $i$ 的学生）猜测他/她在队列中是第 $L_i$ 个、第 $(L_i+1)$ 个、……、第 $(R_i-1)$ 个或第 $R_i$ 个人。（即，排在他/她前面的人数在区间 $\\left[L_{i} - 1, R_{i} - 1\\right]$ 内）此外，还有 $M$ 条声称，其中第 $i$ 条声称学生 $v_i$ 可以在等待队列中看到学生 $u_i$。这意味着学生 $u_i$ 排在学生 $v_i$ 的前面。\n\n你想知道是否所有学生的猜测和声称都是正确的。找到一个满足所有猜测和声称的排队顺序，或者报告这样的顺序不存在。", "inputFormat": "第一行包含两个以空格分隔的整数 $N, M$（$1 \\leq N \\leq 300,000$，$0 \\leq M \\leq 1,000,000$）。\n\n接下来的 $N$ 行中，每行给出两个以空格分隔的整数 $L_i, R_i$（$1 \\leq L_i \\leq R_i \\leq N$）。\n\n接下来的 $M$ 行中，每行给出两个以空格分隔的整数 $u_i, v_i$（$1 \\leq u_i \\leq N$，$1 \\leq v_i \\leq N$，$u_i \\neq v_i$）。", "outputFormat": "如果没有满足条件的答案，输出 $-1$。\n\n否则，输出 $N$ 行。\n在第 $i$ 行，输出从前面数第 $i$ 个学生的学号。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
