{"pid": "P9679", "type": "P", "difficulty": 3, "samples": [["2\n3\n9 99 999\n1\n12345", "5\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "O2优化", "ICPC", "济南"], "title": "[ICPC 2022 Jinan R] Best Carry Player", "background": "", "description": "Prof. Pang is given $n$ numbers $a_1,\\ldots, a_n$. It is easy to add the numbers up using a computer. But Prof. Pang treasures his computer so much and wants to reduce its workload. He decides to simulate the following program by hand. \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ajtj92in.png)\n\n\nUnlike a computer, the time needed for Prof. Pang to simulate the program is proportional to the total number of **carries**(which means “进位” in Chinese) when calculating $s+a[i]$ for each $i$ from $1$ to $n$. Prof. Pang adds numbers **by column addition in base-ten**, just like what we normally do in primary school. For example, there are two carries in the following addition.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/c779jeox.png)\n\nPlease permute the array $a_1,\\ldots, a_n$ so that the total number of carries when Prof. Pang simulates the program is as small as possible. (By ''permute an array'', we mean that you can change the order of the elements arbitrarily.)\n", "inputFormat": "The first line contains one integer $T~(1\\le T \\le 10^5)$, the number of test cases.\n\nFor each test case, the first line contains one positive integer $n~(1\\le n \\le 10^5)$. The next line contains $n$ integers $a_1,\\ldots, a_n~(1 \\le a_i\\le 10^9)$ denoting the numbers Prof. Pang is given. \n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $10^5$.", "outputFormat": "For each test case, output one line containing the minimum amount of carries.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Jinan R] Best Carry Player", "background": "", "description": "Prof. Pang is given $n$ numbers $a_1,\\ldots, a_n$. It is easy to add the numbers up using a computer. But Prof. Pang treasures his computer so much and wants to reduce its workload. He decides to simulate the following program by hand. \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ajtj92in.png)\n\n\nUnlike a computer, the time needed for Prof. Pang to simulate the program is proportional to the total number of **carries**(which means “进位” in Chinese) when calculating $s+a[i]$ for each $i$ from $1$ to $n$. Prof. Pang adds numbers **by column addition in base-ten**, just like what we normally do in primary school. For example, there are two carries in the following addition.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/c779jeox.png)\n\nPlease permute the array $a_1,\\ldots, a_n$ so that the total number of carries when Prof. Pang simulates the program is as small as possible. (By ''permute an array'', we mean that you can change the order of the elements arbitrarily.)\n", "inputFormat": "The first line contains one integer $T~(1\\le T \\le 10^5)$, the number of test cases.\n\nFor each test case, the first line contains one positive integer $n~(1\\le n \\le 10^5)$. The next line contains $n$ integers $a_1,\\ldots, a_n~(1 \\le a_i\\le 10^9)$ denoting the numbers Prof. Pang is given. \n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $10^5$.", "outputFormat": "For each test case, output one line containing the minimum amount of carries.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Jinan R] Best Carry Player", "background": "", "description": "### 简要题面\n\n这里我们定义一个电脑运行 $a+b$ 的速度是 $a+b$ 中出现的进位的次数。\n\n给定一个数组 $a_1,a_2,...,a_n$，请找出正确的排序使得计算这个数组的和时运行的速度最短，请找出最少的进位次数。", "inputFormat": "**本题有多组数据**。\n\n第一行一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n第一行一个整数 $n$。  \n\n接下来一行 $n$ 个整数，表示输入的数组 $a$。", "outputFormat": "对于每组数据，输出最小的进位次数。", "hint": "对于 $100 \\%$ 的数据： $1 \\leq \\sum n \\leq 10^5$， $1 \\leq a_i \\leq 10^9$", "locale": "zh-CN"}}}
{"pid": "P9680", "type": "P", "difficulty": 2, "samples": [["6\nstring a(\"cxyakioi\");\nstring_view b(\"cxyakapio\");\nstring c(b);\nstring_view d(a);\nstring_view cxyakioi(c);\nstring cxyakapio(d);", "25"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "字符串", "洛谷原创", "O2优化", "洛谷月赛"], "title": "string[_view]", "background": "C++ 的 string 类是一个功能强大的字符串类，然而由于其字符串算法和内存管理绑定的机制，所以在处理 C 风格字符串时效率低下。\n\n为了解决这个问题，C++17 标准引入了 string\\_view 类型，将内存管理和字符串算法分离，从而更好地适配了 C 风格字符串的处理。", "description": "你需要模拟一个简单的 C++ 程序，该程序的每一行必然为如下两种形式之一：\n\n- `string <variable-name>(<initializer>);`\n- `string_view <variable-name>(<initializer>);`\n\n其中 `variable-name` 为声明的变量名（保证之前未出现过，且长度不超过 $10$），`initializer` 为初始化该变量的内容，可以是：\n\n- 字符串字面量，即用双引号引起的字符串（形如 `\"abc\"`）；\n- 之前出现过的变量名 `source`，此时应将 `source` 对应的字符串赋给 `variable-name`。\n\n具体而言，将任意一个字符串 $s$ 赋给 string 类型会进行 $|s|$ 次字符拷贝，而赋给 string\\_view 类型不会拷贝字符。其中 $|s|$ 为字符串 $s$ 的长度。\n\n你需要计算出该程序中字符拷贝的总次数。", "inputFormat": "第一行输入一个整数 $L$，代表程序行数。\n\n接下来 $L$ 行，输入一段代码。", "outputFormat": "输出一个整数，代表字符拷贝总次数。", "hint": "  对于每组数据，保证代码长度均不超过 $10^4$（不包括换行符）。\n\n保证字符串字面量（除去两侧引号）和变量名中只有拉丁字母，且给定的代码严格满足题目要求。\n\n### 子任务\n\n|  #   |            特殊性质            | 分值 |\n| :--: | :----------------------------: | :--: |\n|  0   |              样例              | 0  |\n|  1   | 所有变量均为 string\\_view 类型 | 10 |\n|  2   |    只使用字符串字面量初始化    | 20 |\n|  3   |               -                | 70 |\n\n---\n\n好消息：GCC 9.3.0 支持 string_view。\n\n坏消息：NOI 不开 C++17。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "string[_view]", "background": "C++ 的 string 类是一个功能强大的字符串类，然而由于其字符串算法和内存管理绑定的机制，所以在处理 C 风格字符串时效率低下。\n\n为了解决这个问题，C++17 标准引入了 string\\_view 类型，将内存管理和字符串算法分离，从而更好地适配了 C 风格字符串的处理。", "description": "你需要模拟一个简单的 C++ 程序，该程序的每一行必然为如下两种形式之一：\n\n- `string <variable-name>(<initializer>);`\n- `string_view <variable-name>(<initializer>);`\n\n其中 `variable-name` 为声明的变量名（保证之前未出现过，且长度不超过 $10$），`initializer` 为初始化该变量的内容，可以是：\n\n- 字符串字面量，即用双引号引起的字符串（形如 `\"abc\"`）；\n- 之前出现过的变量名 `source`，此时应将 `source` 对应的字符串赋给 `variable-name`。\n\n具体而言，将任意一个字符串 $s$ 赋给 string 类型会进行 $|s|$ 次字符拷贝，而赋给 string\\_view 类型不会拷贝字符。其中 $|s|$ 为字符串 $s$ 的长度。\n\n你需要计算出该程序中字符拷贝的总次数。", "inputFormat": "第一行输入一个整数 $L$，代表程序行数。\n\n接下来 $L$ 行，输入一段代码。", "outputFormat": "输出一个整数，代表字符拷贝总次数。", "hint": "  对于每组数据，保证代码长度均不超过 $10^4$（不包括换行符）。\n\n保证字符串字面量（除去两侧引号）和变量名中只有拉丁字母，且给定的代码严格满足题目要求。\n\n### 子任务\n\n|  #   |            特殊性质            | 分值 |\n| :--: | :----------------------------: | :--: |\n|  0   |              样例              | 0  |\n|  1   | 所有变量均为 string\\_view 类型 | 10 |\n|  2   |    只使用字符串字面量初始化    | 20 |\n|  3   |               -                | 70 |\n\n---\n\n好消息：GCC 9.3.0 支持 string_view。\n\n坏消息：NOI 不开 C++17。", "locale": "zh-CN"}}}
{"pid": "P9681", "type": "P", "difficulty": 4, "samples": [["4 3\n3 -4 -1 2\n1 2\n3 4\n1 4\n", "1\n2\n3\n"], ["7 6\n-1 2 -1 -1 -1 2 -1\n2 5\n4 7\n1 7\n5 5\n1 3\n2 4\n", "1\n2\n4\n0\n2\n1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "O2优化", "前缀和", "洛谷月赛"], "title": "幽默的世界。", "background": "@【数据删除】 : 大家觉得呢 || @【数据删除】 : oi 生活总是充满了幽默。 不过学文化课或许也好不了多少？", "description": "给定一个长为 $n$ 的序列 $a_1,a_2,\\cdots,a_n$，定义 $a$ 的一个连续子序列 $a_l,a_{l+1},\\cdots,a_r$ 是幽默的，当且仅当：\n\n- $\\sum\\limits_{i=l}^ra_i>0$；\n- 对于所有 $l\\le x\\le y<r$，满足 $\\sum\\limits_{i=x}^y a_i\\le 0$。\n\n$q$ 次询问，每次给定两个整数 $l,r$，查询满足以下条件的数对 $(l',r')$ 个数：\n\n- $l\\le l'\\le r'\\le r$；\n- 连续子序列 $a_{l'},a_{l'+1},\\cdots a_{r'}$ 是幽默的。", "inputFormat": "第一行输入两个整数 $n,q$。\n\n接下来一行输入 $n$ 个整数，第 $i$ 个整数代表 $a_i$。\n\n接下来 $q$ 行，每行输入两个整数 $l,r$，代表一次询问。", "outputFormat": "对于每组询问，输出一行一个整数，代表答案。", "hint": "对于所有数据，保证 $1\\le n,q\\le 2\\times 10^5$，$1\\le l\\le r\\le n$，$|a_i|\\le 10^9$。\n\n### 子任务\n\n|  #   |       特殊性质        | 分值 |\n| :--: | :-------------------: | :--: |\n|  0   |         样例          |  0   |\n|  1   |      $n,q\\le 50$      |  15  |\n|  2   | $n,q\\le 3\\times 10^3$ |  20  |\n|  3   |  对于所有询问，$r=n$  |  15  |\n|  4   |  对于所有询问，$l=1$  |  15  |\n|  5   |           -           |  35  |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "幽默的世界。", "background": "@【数据删除】 : 大家觉得呢 || @【数据删除】 : oi 生活总是充满了幽默。 不过学文化课或许也好不了多少？", "description": "给定一个长为 $n$ 的序列 $a_1,a_2,\\cdots,a_n$，定义 $a$ 的一个连续子序列 $a_l,a_{l+1},\\cdots,a_r$ 是幽默的，当且仅当：\n\n- $\\sum\\limits_{i=l}^ra_i>0$；\n- 对于所有 $l\\le x\\le y<r$，满足 $\\sum\\limits_{i=x}^y a_i\\le 0$。\n\n$q$ 次询问，每次给定两个整数 $l,r$，查询满足以下条件的数对 $(l',r')$ 个数：\n\n- $l\\le l'\\le r'\\le r$；\n- 连续子序列 $a_{l'},a_{l'+1},\\cdots a_{r'}$ 是幽默的。", "inputFormat": "第一行输入两个整数 $n,q$。\n\n接下来一行输入 $n$ 个整数，第 $i$ 个整数代表 $a_i$。\n\n接下来 $q$ 行，每行输入两个整数 $l,r$，代表一次询问。", "outputFormat": "对于每组询问，输出一行一个整数，代表答案。", "hint": "对于所有数据，保证 $1\\le n,q\\le 2\\times 10^5$，$1\\le l\\le r\\le n$，$|a_i|\\le 10^9$。\n\n### 子任务\n\n|  #   |       特殊性质        | 分值 |\n| :--: | :-------------------: | :--: |\n|  0   |         样例          |  0   |\n|  1   |      $n,q\\le 50$      |  15  |\n|  2   | $n,q\\le 3\\times 10^3$ |  20  |\n|  3   |  对于所有询问，$r=n$  |  15  |\n|  4   |  对于所有询问，$l=1$  |  15  |\n|  5   |           -           |  35  |\n", "locale": "zh-CN"}}}
{"pid": "P9682", "type": "P", "difficulty": 6, "samples": [["+?+-", "1"], ["??+-?-+", "11"], ["-????-?+?--????", "2523"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "洛谷原创", "O2优化", "组合数学", "洛谷月赛"], "title": "Electro Master", "background": "I might be wrong.", "description": "考虑一个由四种微观粒子构成的系统：正负 A 子 $\\text{a}^+,\\text{a}^-$，正负 B 子 $\\text{b}^+,\\text{b}^-$。\n\n一开始，一条直线上放置了 $n$ 个 A 子；然后以某种方式给粒子以初速度，使得带正电荷的粒子向左，反之则向右运动。我们忽略粒子之间的相互作用，认为粒子在加速后速率一定，且均沿直线运动。\n\n当两个粒子相撞时，粒子会反弹，沿着相反的方向继续运动。同时满足如下的变换规律：\n\n- 若两种粒子的电荷相同，则无事发生；\n- 若两种粒子的电荷不同，则改变成另一种同电荷的粒子。\n\n例如：$\\text{a}^-$ 和 $\\text{b}^+$ 相撞后，$\\text{a}^-$ 会变成 $\\text{b}^-$，$\\text{b}^+$ 会变成 $\\text{a}^+$，并各自沿着相反的方向运动。\n\n定义一种摆放方式的权值为，经过足够长的时间后，在左侧收集到的 B 子个数。\n\n现在已经确定了一些 A 子的正负性，剩下的 A 子可能带正电，也有可能带负电。请求出对于所有可能方案的权值之和。\n\n你需要将答案对 $998\\,244\\,353$ 取模。", "inputFormat": "输入一行一个长为 $n$ 的字符串 $s$，代表从左到右的 A 子的正负性。具体而言：\n\n- 若 $s_i$ 为 `+`，则第 $i$ 个 A 子带正电；\n- 若 $s_i$ 为 `-`，则第 $i$ 个 A 子带负电；\n- 若 $s_i$ 为 `?`，则第 $i$ 个 A 子可能带正电，也可能带负电。", "outputFormat": "输出一行一个数，代表答案对 $998\\,244\\,353$ 取模后的结果。", "hint": "#### 样例 1 解释\n\n有两种可能的填法：`+++-` 或 `+-+-`。其权值分别为 $0,1$，所以最终的答案即为 $1$。\n\n### 数据规模与约定\n\n对于所有数据，保证 $1\\le n\\le 2000$，$s_i\\in \\{\\texttt{+},\\texttt{-},\\texttt{?}\\}$。\n\n| # | $n\\le $ | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: | :----------: |\n| 0 | - | 样例 | $0$ |\n| 1 | $100$ | $s$ 中没有 `?` | $10$ |\n| 2 | $100$ | - | $20$ |\n| 3 | $300$ | $s$ 中 `?` 不超过 $15$ 个 | $15$ |\n| 4 | $300$ | - | $20$ |\n| 5 | - | - | $35$ |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Electro Master", "background": "I might be wrong.", "description": "考虑一个由四种微观粒子构成的系统：正负 A 子 $\\text{a}^+,\\text{a}^-$，正负 B 子 $\\text{b}^+,\\text{b}^-$。\n\n一开始，一条直线上放置了 $n$ 个 A 子；然后以某种方式给粒子以初速度，使得带正电荷的粒子向左，反之则向右运动。我们忽略粒子之间的相互作用，认为粒子在加速后速率一定，且均沿直线运动。\n\n当两个粒子相撞时，粒子会反弹，沿着相反的方向继续运动。同时满足如下的变换规律：\n\n- 若两种粒子的电荷相同，则无事发生；\n- 若两种粒子的电荷不同，则改变成另一种同电荷的粒子。\n\n例如：$\\text{a}^-$ 和 $\\text{b}^+$ 相撞后，$\\text{a}^-$ 会变成 $\\text{b}^-$，$\\text{b}^+$ 会变成 $\\text{a}^+$，并各自沿着相反的方向运动。\n\n定义一种摆放方式的权值为，经过足够长的时间后，在左侧收集到的 B 子个数。\n\n现在已经确定了一些 A 子的正负性，剩下的 A 子可能带正电，也有可能带负电。请求出对于所有可能方案的权值之和。\n\n你需要将答案对 $998\\,244\\,353$ 取模。", "inputFormat": "输入一行一个长为 $n$ 的字符串 $s$，代表从左到右的 A 子的正负性。具体而言：\n\n- 若 $s_i$ 为 `+`，则第 $i$ 个 A 子带正电；\n- 若 $s_i$ 为 `-`，则第 $i$ 个 A 子带负电；\n- 若 $s_i$ 为 `?`，则第 $i$ 个 A 子可能带正电，也可能带负电。", "outputFormat": "输出一行一个数，代表答案对 $998\\,244\\,353$ 取模后的结果。", "hint": "#### 样例 1 解释\n\n有两种可能的填法：`+++-` 或 `+-+-`。其权值分别为 $0,1$，所以最终的答案即为 $1$。\n\n### 数据规模与约定\n\n对于所有数据，保证 $1\\le n\\le 2000$，$s_i\\in \\{\\texttt{+},\\texttt{-},\\texttt{?}\\}$。\n\n| # | $n\\le $ | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: | :----------: |\n| 0 | - | 样例 | $0$ |\n| 1 | $100$ | $s$ 中没有 `?` | $10$ |\n| 2 | $100$ | - | $20$ |\n| 3 | $300$ | $s$ 中 `?` 不超过 $15$ 个 | $15$ |\n| 4 | $300$ | - | $20$ |\n| 5 | - | - | $35$ |\n", "locale": "zh-CN"}}}
{"pid": "P9683", "type": "P", "difficulty": 6, "samples": [["2\n2 1 1\n2 3 4", "1\n2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "交互题", "Special Judge", "O2优化", "构造", "洛谷月赛"], "title": "A Certain Forbidden Index", "background": "**这是一道函数式交互题。本题仅支持 C++ 提交。（出于某些原因，请不要使用 GCC 9 提交）**\n\n**本地编译、提交时请在程序里加入以下函数声明语句：**\n\n```cpp\nint query(int, int);\n```\n\n**任何在赛时攻击交互库而得分的行为均视为作弊。**\n", "description": "有一个长为 $n=2^k$ 的序列，基于这个序列建立了一棵[线段树](https://oi-wiki.org/ds/seg/)。现在线段树上有恰好一个节点被标记了。\n\n你可以进行若干次询问，每次询问给定一个区间 $[l,r]$，交互库会在被修改的线段树上进行一次区间查询，你可以得知在被修改的线段树上这个区间对应的所有节点中，是否有节点被标记。\n\n你需要在尽可能少的询问内找到这个节点。具体而言，若最优策略在最坏情况下需要 $Q$ 次询问，则你最多可以使用 $Q$ 次询问。\n\n### 交互流程\n\n你不需要，也不应该实现主函数，你只需要实现如下函数：\n\n```cpp\nstd::pair<int, int> solve(int k);\n```\n\n该函数需要在得到答案后返回一个数对 $(x,y)$，表示被标记的线段树节点所对应的区间为 $[x,y]$。\n\n你可以调用交互库提供的方法：\n\n```cpp\nint query(int l, int r);\n```\n\n传入的 `l` 和 `r` 代表询问的区间为 $[l,r]$。交互库会返回对应的结果。你需要保证 $1\\le l\\le r\\le n$。具体而言：\n\n- 当没有节点被标记时，交互库返回 $0$；\n- 当有节点被标记时，交互库返回 $1$；\n- 当询问的区间不合法时，交互库会返回 $-1$，此时你需要立即结束这组数据的交互（不是整个测试点），否则可能导致不可预知的错误。\n\n本题无询问次数限制，但过多的询问会导致时间超限，详细信息请看“数据规模与约定”。", "inputFormat": "下面给出样例交互库的输入输出格式：\n\n第一行输入一个整数 $T$，表示数据组数。\n\n对于每组数据，第一行输入三个整数 $k,l,r$ 代表 $n=2^k$，且将对应区间为 $[l,r]$ 的线段树节点修改。\n\n注意样例交互库不会检查输入数据的正确性。", "outputFormat": "对于每组数据，如果你得到的答案正确，输出一个整数表示你使用的交互次数，否则：\n\n- 若你的询问不合法，输出 `Wrong Answer [1]`；\n- 若你返回的区间不正确，输出 `Wrong Answer [2]`。", "hint": "#### 样例 1 解释\n\n下面是一种可能的交互流程：\n\n| 交互库 | 选手程序 | 备注 |\n| :----------: | :----------: | :----------: |\n| 调用 `solve(2)` |  | 开始测试 |\n| 返回 $1$ | 调用 `query(1,1)` | $[1,1]$ 就是答案节点 |\n|  | 返回 $(1,1)$ | 答案正确 |\n| 调用 `solve(2)` |  | 开始下一组数据的评测 |\n| 返回 $1$ | 调用 `query(2,4)` | $[2,4]$ 对应的节点是 $[2,2]$ 和 $[3,4]$，包括了答案节点 |\n| 返回 $0$ | 调用 `query(1,4)` | $[1,4]$ 对应的节点只有 $[1,4]$，不包括答案节点 |\n|  | 返回 $(3,4)$ | 答案正确，评测结束 |\n\n\n### 计分方式\n\n本题首先会受到和传统题相同的限制。例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制等会导致相应测试点得 $0$ 分等。\n\n如果你找到的节点是错误的，或者你给出的询问不合法，在该测试点将会得到 $0$ 分。\n\n否则，设在一组数据中，答案最坏需要 $x$ 次询问，而你使用了 $y$ 次询问，满分为 $t$，则这组数据的分数是 $t\\times \\min\\left(1,\\mathrm{e}^{-\\frac{y}{x}+1}\\right)$。\n\n每个测试点取所有数据组中得分的最小值，向下保留两位小数。你的得分是所有测试点得分之和。\n\n### 数据规模与约定\n\n对于所有数据，保证 $1\\le k\\le 14$，$1\\le T\\le 300$。\n\n本题共 $14$ 个测试点，对于第 $i$ 个测试点，保证 $k=i$。对于 $1\\le k\\le 4$ 的测试点，满分 $10$ 分。对于 $5\\le k\\le 14$ 的测试点，满分 $6$ 分。\n\n保证在每组数据进行 $2n$ 次询问时，单个测试点内，交互库使用的时间不超过 0.6s，空间不超过 8MiB。\n\n### 下发文件说明\n\n下发文件中有一个可以通过样例的程序示例 `sample.cpp`，以及一个样例交互库 `grader.cpp`。假设你的答案文件为 `answer.cpp`，则可以使用如下命令将其编译成可执行文件 `answer`：\n\n```shell\ng++ grader.cpp answer.cpp -o answer -O2\n```\n\n实际评测时的交互库可能是自适应的，即被修改的节点可能不会在交互一开始时确定。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "A Certain Forbidden Index", "background": "**这是一道函数式交互题。本题仅支持 C++ 提交。（出于某些原因，请不要使用 GCC 9 提交）**\n\n**本地编译、提交时请在程序里加入以下函数声明语句：**\n\n```cpp\nint query(int, int);\n```\n\n**任何在赛时攻击交互库而得分的行为均视为作弊。**\n", "description": "有一个长为 $n=2^k$ 的序列，基于这个序列建立了一棵[线段树](https://oi-wiki.org/ds/seg/)。现在线段树上有恰好一个节点被标记了。\n\n你可以进行若干次询问，每次询问给定一个区间 $[l,r]$，交互库会在被修改的线段树上进行一次区间查询，你可以得知在被修改的线段树上这个区间对应的所有节点中，是否有节点被标记。\n\n你需要在尽可能少的询问内找到这个节点。具体而言，若最优策略在最坏情况下需要 $Q$ 次询问，则你最多可以使用 $Q$ 次询问。\n\n### 交互流程\n\n你不需要，也不应该实现主函数，你只需要实现如下函数：\n\n```cpp\nstd::pair<int, int> solve(int k);\n```\n\n该函数需要在得到答案后返回一个数对 $(x,y)$，表示被标记的线段树节点所对应的区间为 $[x,y]$。\n\n你可以调用交互库提供的方法：\n\n```cpp\nint query(int l, int r);\n```\n\n传入的 `l` 和 `r` 代表询问的区间为 $[l,r]$。交互库会返回对应的结果。你需要保证 $1\\le l\\le r\\le n$。具体而言：\n\n- 当没有节点被标记时，交互库返回 $0$；\n- 当有节点被标记时，交互库返回 $1$；\n- 当询问的区间不合法时，交互库会返回 $-1$，此时你需要立即结束这组数据的交互（不是整个测试点），否则可能导致不可预知的错误。\n\n本题无询问次数限制，但过多的询问会导致时间超限，详细信息请看“数据规模与约定”。", "inputFormat": "下面给出样例交互库的输入输出格式：\n\n第一行输入一个整数 $T$，表示数据组数。\n\n对于每组数据，第一行输入三个整数 $k,l,r$ 代表 $n=2^k$，且将对应区间为 $[l,r]$ 的线段树节点修改。\n\n注意样例交互库不会检查输入数据的正确性。", "outputFormat": "对于每组数据，如果你得到的答案正确，输出一个整数表示你使用的交互次数，否则：\n\n- 若你的询问不合法，输出 `Wrong Answer [1]`；\n- 若你返回的区间不正确，输出 `Wrong Answer [2]`。", "hint": "#### 样例 1 解释\n\n下面是一种可能的交互流程：\n\n| 交互库 | 选手程序 | 备注 |\n| :----------: | :----------: | :----------: |\n| 调用 `solve(2)` |  | 开始测试 |\n| 返回 $1$ | 调用 `query(1,1)` | $[1,1]$ 就是答案节点 |\n|  | 返回 $(1,1)$ | 答案正确 |\n| 调用 `solve(2)` |  | 开始下一组数据的评测 |\n| 返回 $1$ | 调用 `query(2,4)` | $[2,4]$ 对应的节点是 $[2,2]$ 和 $[3,4]$，包括了答案节点 |\n| 返回 $0$ | 调用 `query(1,4)` | $[1,4]$ 对应的节点只有 $[1,4]$，不包括答案节点 |\n|  | 返回 $(3,4)$ | 答案正确，评测结束 |\n\n\n### 计分方式\n\n本题首先会受到和传统题相同的限制。例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制等会导致相应测试点得 $0$ 分等。\n\n如果你找到的节点是错误的，或者你给出的询问不合法，在该测试点将会得到 $0$ 分。\n\n否则，设在一组数据中，答案最坏需要 $x$ 次询问，而你使用了 $y$ 次询问，满分为 $t$，则这组数据的分数是 $t\\times \\min\\left(1,\\mathrm{e}^{-\\frac{y}{x}+1}\\right)$。\n\n每个测试点取所有数据组中得分的最小值，向下保留两位小数。你的得分是所有测试点得分之和。\n\n### 数据规模与约定\n\n对于所有数据，保证 $1\\le k\\le 14$，$1\\le T\\le 300$。\n\n本题共 $14$ 个测试点，对于第 $i$ 个测试点，保证 $k=i$。对于 $1\\le k\\le 4$ 的测试点，满分 $10$ 分。对于 $5\\le k\\le 14$ 的测试点，满分 $6$ 分。\n\n保证在每组数据进行 $2n$ 次询问时，单个测试点内，交互库使用的时间不超过 0.6s，空间不超过 8MiB。\n\n### 下发文件说明\n\n下发文件中有一个可以通过样例的程序示例 `sample.cpp`，以及一个样例交互库 `grader.cpp`。假设你的答案文件为 `answer.cpp`，则可以使用如下命令将其编译成可执行文件 `answer`：\n\n```shell\ng++ grader.cpp answer.cpp -o answer -O2\n```\n\n实际评测时的交互库可能是自适应的，即被修改的节点可能不会在交互一开始时确定。", "locale": "zh-CN"}}}
{"pid": "P9684", "type": "P", "difficulty": 7, "samples": [["6 3", "324429415\n948332136\n224604980\n224604980\n948332136\n324429415"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "多项式", "洛谷原创", "O2优化", "洛谷月赛"], "title": "Hello, Solitude.", "background": "@【数据删除】 : 我【数据删除】了。 || @【数据删除】 : 你投哪个 || @【数据删除】 : 雪乃对美琴（悲）", "description": "有一张很长的桌子，桌子一边摆了 $n+2$ 张椅子，从左到右依次标号为 $0,1,\\dots,n+1$，任意两张相邻的椅子的距离相同。\n\n初始 $0$ 号和 $n+1$ 号椅子上各坐着一个人。然后有 $m$ 个人依次按照如下的规则入座：\n\n- 先均匀随机选择一个空着的座位。\n- 若移动到相邻的座位，能使其到相邻的人的最小距离增大，则移动到相邻座位。可以证明上述操作进行有限步后一定会停下。\n\n对于 $1\\sim n$ 号的每一张椅子，求出其上面有人坐的概率。", "inputFormat": "第一行输入两个整数 $n,m$。", "outputFormat": "输出 $n$ 行，每行一个整数，第 $i$ 行的整数代表第 $i$ 张椅子上有人坐的概率对 $998\\,244\\,353$ 取模的结果。", "hint": "#### 样例 1 解释\n\n下面是一种可能的落座方法：\n\n0. 初始 $1\\sim n$ 都没有人落座。\n1. 选定 $x=2$，到最近的人（位于座位 $0$）距离为 $2$；\n   1. 向右移动到 $3$ 号椅子后，到最近的人的距离增大至 $3$，所以 $x\\gets x+1$；\n   2. 再向右移动到 $4$ 的话，到最近的人（位于座位 $6$）的距离依旧为 $3$，所以在 $3$ 号椅子落座。\n2. 选定 $x=6$，到最近的人（位于座位 $7$）距离为 $1$；\n   1. 向左移动到 $5$ 号椅子后，到最近的人的距离增大至 $2$，所以 $x\\gets x-1$；\n   2. 再向左/右移动话，到最近的人的距离均会减小，所以在 $5$ 号椅子落座。\n3. 选定 $x=4$，由于无法左右移动，所以直接在 $4$ 号椅子落座。\n\n最终，$3,4,5$ 号椅子上有人坐。\n\n### 数据规模与约定\n\n对于所有数据，$1\\le n\\le 5\\times 10^5$，$0\\le m\\le n$。\n\n### 子任务\n\n| # | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: |\n| 0 | 样例 | 0 |\n| 1 | $n\\le20$ | 9 |\n| 2 | $n\\le100$ | 10 |\n| 3 | $n\\le500$ | 12 |\n| 4 | $n\\le2000$ | 11 |\n| 5 | $n\\le5000$ | 12 |\n| 6 | $\\exists k\\in \\mathbb{N}$ 使得 $n=2^k-1$ | 13 |\n| 7 | $n\\le 10^5$ | 15 |\n| 8 | - | 18 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Hello, Solitude.", "background": "@【数据删除】 : 我【数据删除】了。 || @【数据删除】 : 你投哪个 || @【数据删除】 : 雪乃对美琴（悲）", "description": "有一张很长的桌子，桌子一边摆了 $n+2$ 张椅子，从左到右依次标号为 $0,1,\\dots,n+1$，任意两张相邻的椅子的距离相同。\n\n初始 $0$ 号和 $n+1$ 号椅子上各坐着一个人。然后有 $m$ 个人依次按照如下的规则入座：\n\n- 先均匀随机选择一个空着的座位。\n- 若移动到相邻的座位，能使其到相邻的人的最小距离增大，则移动到相邻座位。可以证明上述操作进行有限步后一定会停下。\n\n对于 $1\\sim n$ 号的每一张椅子，求出其上面有人坐的概率。", "inputFormat": "第一行输入两个整数 $n,m$。", "outputFormat": "输出 $n$ 行，每行一个整数，第 $i$ 行的整数代表第 $i$ 张椅子上有人坐的概率对 $998\\,244\\,353$ 取模的结果。", "hint": "#### 样例 1 解释\n\n下面是一种可能的落座方法：\n\n0. 初始 $1\\sim n$ 都没有人落座。\n1. 选定 $x=2$，到最近的人（位于座位 $0$）距离为 $2$；\n   1. 向右移动到 $3$ 号椅子后，到最近的人的距离增大至 $3$，所以 $x\\gets x+1$；\n   2. 再向右移动到 $4$ 的话，到最近的人（位于座位 $6$）的距离依旧为 $3$，所以在 $3$ 号椅子落座。\n2. 选定 $x=6$，到最近的人（位于座位 $7$）距离为 $1$；\n   1. 向左移动到 $5$ 号椅子后，到最近的人的距离增大至 $2$，所以 $x\\gets x-1$；\n   2. 再向左/右移动话，到最近的人的距离均会减小，所以在 $5$ 号椅子落座。\n3. 选定 $x=4$，由于无法左右移动，所以直接在 $4$ 号椅子落座。\n\n最终，$3,4,5$ 号椅子上有人坐。\n\n### 数据规模与约定\n\n对于所有数据，$1\\le n\\le 5\\times 10^5$，$0\\le m\\le n$。\n\n### 子任务\n\n| # | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: |\n| 0 | 样例 | 0 |\n| 1 | $n\\le20$ | 9 |\n| 2 | $n\\le100$ | 10 |\n| 3 | $n\\le500$ | 12 |\n| 4 | $n\\le2000$ | 11 |\n| 5 | $n\\le5000$ | 12 |\n| 6 | $\\exists k\\in \\mathbb{N}$ 使得 $n=2^k-1$ | 13 |\n| 7 | $n\\le 10^5$ | 15 |\n| 8 | - | 18 |", "locale": "zh-CN"}}}
{"pid": "P9685", "type": "P", "difficulty": 7, "samples": [["3\n5 2 1\n3 0 1\n-2 2 2\n1 -3 3\n-2 -1 4\n0 0 5\n2\n5\n5 4 2\n3 0 1\n-2 2 2\n1 -3 3\n-2 -1 4\n0 0 5\n2 3\n2 4\n5 1\n3 5\n5 6 3\n3 0 1\n-2 2 2\n1 -3 3\n-2 -1 4\n0 0 5\n3 5 4\n2 5 3\n4 2 1\n2 4 3\n3 1 2\n3 1 4", "10\n0110\n100101"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["计算几何", "洛谷原创", "O2优化", "洛谷月赛"], "title": "三色", "background": "我的心脏还在跳动着啊。", "description": "给定 $n$ 个三元组 $(a_i,b_i,c_i)$。$q$ 次询问，每次给定一个集合 $S$，查询是否存在实数三元组 $(p,q,r)$ 满足：对于所有满足 $pa_i+qb_i+r>0$ 的 $i$，其 $c_i$ 构成的集合恰好为 $S$。", "inputFormat": "第一行输入一个整数 $T$，代表数据组数。\n\n对于每组数据，第一行输入三个数 $n,q,k$，其中 $k=|S|$。\n\n接下来 $n$ 行，每行输入三个整数 $a_i,b_i,c_i$。\n\n接下来 $q$ 行，第 $i$ 行输入 $k$ 个整数 $s_{i,1},s_{i,2},\\dots,s_{i,k}$，代表第 $i$ 组询问中 $S$ 的元素。保证元素不重复。", "outputFormat": "对于每组数据，输出一行一个长为 $q$ 的字符串 $R$，对于第 $i$ 组询问，若答案为存在，则 $R_i$ 为 $\\tt 1$，否则为 $\\tt 0$。", "hint": "### 数据规模与约定\n\n对于所有数据，$1\\le n,\\sum n\\le 10^5$，$1\\le q,\\sum q \\le 3\\times 10^5$，$1\\le k\\le 3$，$1\\le c_i,s_{i,j}\\le n$，$|a_i|,|b_i|\\le 10^9$。\n\n对于任意 $i\\neq j$，保证 $(a_i,b_i)\\neq (a_j,b_j)$，且不存在 $(p,q)$ 和三个不同的下标 $i,j,k$ 满足 $pa_i+qb_i=pa_j+qb_j=pa_k+qb_k$。\n\n### 子任务\n\n| # | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: |\n| 0 | 样例 | 0 |\n| 1 | $n\\le 3$ | 2 |\n| 2 | $k=1$ | 11 |\n| 3 | $\\sum n^2\\le 10^6$ | 23 |\n| 4 | $k=2$ | 29 |\n| 5 | $k=3$ | 35 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "三色", "background": "我的心脏还在跳动着啊。", "description": "给定 $n$ 个三元组 $(a_i,b_i,c_i)$。$q$ 次询问，每次给定一个集合 $S$，查询是否存在实数三元组 $(p,q,r)$ 满足：对于所有满足 $pa_i+qb_i+r>0$ 的 $i$，其 $c_i$ 构成的集合恰好为 $S$。", "inputFormat": "第一行输入一个整数 $T$，代表数据组数。\n\n对于每组数据，第一行输入三个数 $n,q,k$，其中 $k=|S|$。\n\n接下来 $n$ 行，每行输入三个整数 $a_i,b_i,c_i$。\n\n接下来 $q$ 行，第 $i$ 行输入 $k$ 个整数 $s_{i,1},s_{i,2},\\dots,s_{i,k}$，代表第 $i$ 组询问中 $S$ 的元素。保证元素不重复。", "outputFormat": "对于每组数据，输出一行一个长为 $q$ 的字符串 $R$，对于第 $i$ 组询问，若答案为存在，则 $R_i$ 为 $\\tt 1$，否则为 $\\tt 0$。", "hint": "### 数据规模与约定\n\n对于所有数据，$1\\le n,\\sum n\\le 10^5$，$1\\le q,\\sum q \\le 3\\times 10^5$，$1\\le k\\le 3$，$1\\le c_i,s_{i,j}\\le n$，$|a_i|,|b_i|\\le 10^9$。\n\n对于任意 $i\\neq j$，保证 $(a_i,b_i)\\neq (a_j,b_j)$，且不存在 $(p,q)$ 和三个不同的下标 $i,j,k$ 满足 $pa_i+qb_i=pa_j+qb_j=pa_k+qb_k$。\n\n### 子任务\n\n| # | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: |\n| 0 | 样例 | 0 |\n| 1 | $n\\le 3$ | 2 |\n| 2 | $k=1$ | 11 |\n| 3 | $\\sum n^2\\le 10^6$ | 23 |\n| 4 | $k=2$ | 29 |\n| 5 | $k=3$ | 35 |", "locale": "zh-CN"}}}
{"pid": "P9686", "type": "P", "difficulty": 1, "samples": [["5\nAC\nWA\nAC\nTLE\nMLE", "2 4 5"], ["5\nAC\nAC\nAC\nMLE\nTLE", "4 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "O2优化", "洛谷月赛"], "title": "Judg.", "background": "", "description": "小 M 正在兴致勃勃地敲打着代码，他突然发现提交代码的评测机无响应了。\n\n你查看了后台数据，请你根据这些已有数据判断他没有通过的测试点有哪些。\n\n已知评测结果与测试点是否通过有如下关系：\n\n|评测结果|测试点是否通过|\n| :-----------: | :-----------: |\n| $\\texttt{AC}$ | 是 |\n| $\\texttt{WA}$ | 否 |\n| $\\texttt{TLE}$ | 否 |\n| $\\texttt{MLE}$ | 否 |\n", "inputFormat": "第一行输入一个正整数 $n$，表示评测数据的个数。\n\n第 $2 \\sim n+1$ 行，每行输入一个字符串，依次表示测试点 $1\\sim n$ 的评测结果，数据保证这些字符串一定为 $\\{\\texttt{AC},\\texttt{WA},\\texttt{TLE},\\texttt{MLE}\\}$ 中的一个。", "outputFormat": "输出一行 $m$ 个正整数，其中第 $i$ 个数字 $a_i$ 表示第 $a_i$ 个测试点没有通过。\n\n特别地，你需要保证这 $m$ 个数字递增。", "hint": "#### 【数据范围】\n\n对于所有测试数据，满足 $1 \\le n \\le 10^5$，输入的字符串一定在 $\\{\\texttt{AC},\\texttt{WA},\\texttt{TLE},\\texttt{MLE}\\}$ 之中。\n\n**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\\text{Subtask}$。**\n\n各测试点的附加限制如下表所示。\n\n|测试点 |$n \\le$  |\n| :-----------: | :-----------: |\n| $1 \\sim 5$ | $10$ |\n| $6 \\sim 12$ | $2 \\times 10^3$ |\n| $13 \\sim 20$ | $10^5$ |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Judg.", "background": "", "description": "小 M 正在兴致勃勃地敲打着代码，他突然发现提交代码的评测机无响应了。\n\n你查看了后台数据，请你根据这些已有数据判断他没有通过的测试点有哪些。\n\n已知评测结果与测试点是否通过有如下关系：\n\n|评测结果|测试点是否通过|\n| :-----------: | :-----------: |\n| $\\texttt{AC}$ | 是 |\n| $\\texttt{WA}$ | 否 |\n| $\\texttt{TLE}$ | 否 |\n| $\\texttt{MLE}$ | 否 |\n", "inputFormat": "第一行输入一个正整数 $n$，表示评测数据的个数。\n\n第 $2 \\sim n+1$ 行，每行输入一个字符串，依次表示测试点 $1\\sim n$ 的评测结果，数据保证这些字符串一定为 $\\{\\texttt{AC},\\texttt{WA},\\texttt{TLE},\\texttt{MLE}\\}$ 中的一个。", "outputFormat": "输出一行 $m$ 个正整数，其中第 $i$ 个数字 $a_i$ 表示第 $a_i$ 个测试点没有通过。\n\n特别地，你需要保证这 $m$ 个数字递增。", "hint": "#### 【数据范围】\n\n对于所有测试数据，满足 $1 \\le n \\le 10^5$，输入的字符串一定在 $\\{\\texttt{AC},\\texttt{WA},\\texttt{TLE},\\texttt{MLE}\\}$ 之中。\n\n**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\\text{Subtask}$。**\n\n各测试点的附加限制如下表所示。\n\n|测试点 |$n \\le$  |\n| :-----------: | :-----------: |\n| $1 \\sim 5$ | $10$ |\n| $6 \\sim 12$ | $2 \\times 10^3$ |\n| $13 \\sim 20$ | $10^5$ |\n", "locale": "zh-CN"}}}
{"pid": "P9687", "type": "P", "difficulty": 2, "samples": [["5\n5 1\n3 1\n5 3\n5 4\n5 5", "00101\n101\n-1\n-1\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "洛谷原创", "O2优化", "构造", "洛谷月赛"], "title": "Maps.", "background": "", "description": "小 Y 希望得到一幅地图，这份地图有些与众不同。\n\n这份地图是一幅长为 $n$ 个单位，宽为一个单位的网格图，每个网格必须被涂鸦成白色（$0$）或者黑色（$1$）。\n\n你希望满足小 Y 的愿望送给他一幅这样的地图，但是这时小 Y 又提出了两点要求：\n\n- 对于每个不在网格图两端的白色格子，恰好有 $p$ 个满足它的左右两个格子都被涂鸦成黑色。\n- 在满足上述所有条件的情况下，这幅地图从左到右的字符构成的字符串的字典序最小。\n\n你心想，这些要求也是小菜一碟，于是开始了你的创作。", "inputFormat": "本题有多组数据。\n\n第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据：\n\n输入共一行两个整数 $n,p$，表示你需要构造的地图的长度和小 Y 对你的要求。\n\n", "outputFormat": "对于每组数据：输出一行一个长度为 $n$ 的 01 字符串，表示你构造的地图；如果无法找到任何一幅地图满足小 Y 的要求，输出 $-1$。", "hint": "#### 【样例解释 #1】\n\n对于第一组数据：只有位于第 $4$ 个字符上的数，满足本身是 $0$，不在地图边缘且周围两个都是 $1$，因此符合条件。可以证明这是满足条件的字典序最小的方案。\n\n对于第三组数据：可以证明没有任何一个解满足长度为 $5$ 且有 $3$ 个数本身是 $0$，不在地图边缘且周围两个字符都是 $1$。\n\n#### 【数据范围】\n\n对于所有测试数据，满足 $1 \\le T \\le 100$，$1 \\le n,p \\le 10^5$。\n\n**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\\text{Subtask}$。**\n\n各测试点的附加限制如下表所示。\n\n| 测试点 | $n,p \\le$ |\n| :-----------: | :-----------: |\n| $1 \\sim 3$ | $10$ |\n| $4 \\sim 5$ | $10^3$ |\n| $6\\sim 10$ | $10^5$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Maps.", "background": "", "description": "小 Y 希望得到一幅地图，这份地图有些与众不同。\n\n这份地图是一幅长为 $n$ 个单位，宽为一个单位的网格图，每个网格必须被涂鸦成白色（$0$）或者黑色（$1$）。\n\n你希望满足小 Y 的愿望送给他一幅这样的地图，但是这时小 Y 又提出了两点要求：\n\n- 对于每个不在网格图两端的白色格子，恰好有 $p$ 个满足它的左右两个格子都被涂鸦成黑色。\n- 在满足上述所有条件的情况下，这幅地图从左到右的字符构成的字符串的字典序最小。\n\n你心想，这些要求也是小菜一碟，于是开始了你的创作。", "inputFormat": "本题有多组数据。\n\n第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据：\n\n输入共一行两个整数 $n,p$，表示你需要构造的地图的长度和小 Y 对你的要求。\n\n", "outputFormat": "对于每组数据：输出一行一个长度为 $n$ 的 01 字符串，表示你构造的地图；如果无法找到任何一幅地图满足小 Y 的要求，输出 $-1$。", "hint": "#### 【样例解释 #1】\n\n对于第一组数据：只有位于第 $4$ 个字符上的数，满足本身是 $0$，不在地图边缘且周围两个都是 $1$，因此符合条件。可以证明这是满足条件的字典序最小的方案。\n\n对于第三组数据：可以证明没有任何一个解满足长度为 $5$ 且有 $3$ 个数本身是 $0$，不在地图边缘且周围两个字符都是 $1$。\n\n#### 【数据范围】\n\n对于所有测试数据，满足 $1 \\le T \\le 100$，$1 \\le n,p \\le 10^5$。\n\n**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\\text{Subtask}$。**\n\n各测试点的附加限制如下表所示。\n\n| 测试点 | $n,p \\le$ |\n| :-----------: | :-----------: |\n| $1 \\sim 3$ | $10$ |\n| $4 \\sim 5$ | $10^3$ |\n| $6\\sim 10$ | $10^5$ |", "locale": "zh-CN"}}}
{"pid": "P9688", "type": "P", "difficulty": 3, "samples": [["5 2\n1 2 1 3 2\n5 3 1 100 100", "6"], ["10 3\n1 3 4 2 9 3 4 2 5 1\n1 5 2 3 9 8 1 2 3 10", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "洛谷原创", "O2优化", "背包 DP", "洛谷月赛"], "title": "Colo.", "background": "", "description": "小 F 和小 Y 经常在一起玩耍，因为小 F 是一个画家，他喜欢在一个长度为 $n$，宽度为 $1$ 的网格图上画画，从左往右第 $i$ 个方格被涂成了一种颜色 $a_i$。\n\n你觉得他的随意涂鸦太难看了，想要保留恰好 $k$ 种颜色（**你不能保留没在网格图上出现的颜色**），使得网格图上没被涂成任何一种你喜欢的颜色的网格都被剪掉，最后会剩下一些网格，你希望这些网格从左到右颜色的编号是单调不下降的。\n\n此外，小 Y 使用的第 $i$ 种颜色有一个价值 $b_i$，小 Y 看到了你裁剪后的网格图很是高兴，于是决定付给你你选择的颜色的价值总和。\n\n你需要求出你能够获得的最大的价值是多少。", "inputFormat": "第一行两个整数 $n,k$，表示小 Y 画画的网格图的大小和你需要保留颜色的种类数。   \n第二行 $n$ 个整数 $a_i$，表示小 Y 画出来的网格图从左往右第 $i$ 个格子的颜色。  \n第三行 $n$ 个整数 $b_i$，表示第 $i$ 种颜色的价值。", "outputFormat": "一行一个整数，表示你能够获得的最大价值；特别地，如果无法找到选择颜色的方法满足要求，输出 $-1$。", "hint": "#### 【样例解释 #1】\n\n对于第一组样例，我们可以选择 $1$ 号和 $3$ 号颜色保留，剩下的网格图即为 $[1,1,3]$，满足单调不下降这一个限制，获得的价值即为 $b_1+b_3=5+1=6$，可以证明这是最优的办法。\n\n#### 【数据范围】\n\n对于所有测试数据，满足 $1 \\le n \\le 500$，$1 \\le k \\le 500$，$1 \\le a_i \\le n$，$1 \\le b_i \\le 10^9$。\n\n**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\\text{Subtask}$。**\n\n各测试点的附加限制如下表所示。\n\n| 测试点 | $n,k \\le $ | 特殊性质 |\n| :-----------: | :-----------: | :-----------: |\n| $1 \\sim 3$ | $10$ | 无 |\n| $4 \\sim 5$ | $100$ | 无 |\n| $6 \\sim 10$ | $500$ | 不同的颜色不超过 $10$ 种 |\n| $11 \\sim 15$ | $500$ | 每种颜色出现的次数不超过 $2$ 次 |\n| $16 \\sim 20$ | $500$ | 无 |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Colo.", "background": "", "description": "小 F 和小 Y 经常在一起玩耍，因为小 F 是一个画家，他喜欢在一个长度为 $n$，宽度为 $1$ 的网格图上画画，从左往右第 $i$ 个方格被涂成了一种颜色 $a_i$。\n\n你觉得他的随意涂鸦太难看了，想要保留恰好 $k$ 种颜色（**你不能保留没在网格图上出现的颜色**），使得网格图上没被涂成任何一种你喜欢的颜色的网格都被剪掉，最后会剩下一些网格，你希望这些网格从左到右颜色的编号是单调不下降的。\n\n此外，小 Y 使用的第 $i$ 种颜色有一个价值 $b_i$，小 Y 看到了你裁剪后的网格图很是高兴，于是决定付给你你选择的颜色的价值总和。\n\n你需要求出你能够获得的最大的价值是多少。", "inputFormat": "第一行两个整数 $n,k$，表示小 Y 画画的网格图的大小和你需要保留颜色的种类数。   \n第二行 $n$ 个整数 $a_i$，表示小 Y 画出来的网格图从左往右第 $i$ 个格子的颜色。  \n第三行 $n$ 个整数 $b_i$，表示第 $i$ 种颜色的价值。", "outputFormat": "一行一个整数，表示你能够获得的最大价值；特别地，如果无法找到选择颜色的方法满足要求，输出 $-1$。", "hint": "#### 【样例解释 #1】\n\n对于第一组样例，我们可以选择 $1$ 号和 $3$ 号颜色保留，剩下的网格图即为 $[1,1,3]$，满足单调不下降这一个限制，获得的价值即为 $b_1+b_3=5+1=6$，可以证明这是最优的办法。\n\n#### 【数据范围】\n\n对于所有测试数据，满足 $1 \\le n \\le 500$，$1 \\le k \\le 500$，$1 \\le a_i \\le n$，$1 \\le b_i \\le 10^9$。\n\n**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\\text{Subtask}$。**\n\n各测试点的附加限制如下表所示。\n\n| 测试点 | $n,k \\le $ | 特殊性质 |\n| :-----------: | :-----------: | :-----------: |\n| $1 \\sim 3$ | $10$ | 无 |\n| $4 \\sim 5$ | $100$ | 无 |\n| $6 \\sim 10$ | $500$ | 不同的颜色不超过 $10$ 种 |\n| $11 \\sim 15$ | $500$ | 每种颜色出现的次数不超过 $2$ 次 |\n| $16 \\sim 20$ | $500$ | 无 |\n", "locale": "zh-CN"}}}
{"pid": "P9689", "type": "P", "difficulty": 4, "samples": [["6\n3 0\n3 1\n3 2\n3 3\n3 4\n3 5", "5\n3\n3\n1\n1\n-1"], ["10\n5 5\n10 0\n999 155\n135 92\n1000232 234255\n10293845 1239485\n123948 1239454\n12394 2131094\n1000000000 98765432\n1000000000 999999999", "3\n40\n52377\n1161\n27487764480\n5864061665280\n-1\n-1\n19215358392218419\n4969489234738635"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "洛谷原创", "O2优化", "分治", "洛谷月赛"], "title": "Bina.", "background": "", "description": "小 J 家门前有两棵树，一棵是二叉树，一棵是三叉树。\n\n你被小 J 叫来修剪他的二叉树，使得他的二叉树的“美丽值”最大，所谓一棵树的美丽值 $=$ 这棵树的点的编号之和 $\\div$ 这棵树的深度（结果向下取整）。\n\n这棵二叉树有一个构建参数 $n$，构建方式如下：\n\n```cpp\nvoid build(int s,int t,int p){\n  if(s==t) return ;\n  build(s,(s+t)/2,2*p);\n  build((s+t)/2+1,t,2*p+1);\n  add_edge(p,2*p),add_edge(p,2*p+1);\n}\n\nint main(){\n  build(1,n,1);\n  return 0;\n}\n```\n\n其中 `build(s,t,p)` 函数参数中的 $p$ 是当前点的编号，`add_edge(x,y)` 函数是指将编号为 $x$ 的点向编号为 $y$ 的点连接一条有向边。\n\n容易发现这棵树的根节点是 $1$，并且我们规定节点的深度为节点到根节点路径上经过的点的个数（包括自己和根节点），这棵树的深度即为所有节点深度的最大值。\n\n对于 $n=3$ 的情况，最后构建出来的结果如下，这棵树的深度为 $3$，你需要选择一个深度 $k$ 把深度大于 $k$ 的点都剪掉，但是 $k$ 必须**大于等于** $1$ 且**小于等于**这棵树的深度。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ueggbyn8.png)\n\n小 J 还给了你一个要求，你剪去的节点个数一定得大于等于 $m$ 他才会高兴，你需要保证让他高兴的同时树的“美丽值”最大。\n\n现在小 J 给了你构建树的参数 $n$ 和至少剪的节点个数 $m$，要你求出来他的树在你修剪后最大的美丽值是多少，如果无论如何你也不可能让小 J 高兴，输出 $-1$。", "inputFormat": "本题有多组数据。\n\n第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据：\n\n输入共一行两个整数 $n,m$，表示构建二叉树的参数和你至少剪掉的节点个数。", "outputFormat": "对于每组数据：输出一行一个整数，表示能够获得的最大的“美丽值”，如果无法让小 J 高兴，输出 $-1$。", "hint": "#### 【样例解释 #1】\n\n对于第一组样例，$n$ 都等于 $3$，构建出来的树同题面所示。\n\n如果我们选择把深度大于 $1$ 的节点全部剪掉，那么我们剪掉了 $2,3,4,5$ 共 $4$ 个节点，美丽值为 $1$。\n\n如果我们选择把深度大于 $2$ 的节点全部剪掉，那么我们剪掉了 $4,5$ 共 $2$ 个节点，美丽值为 $\\lfloor \\dfrac{1+2+3}{2}\\rfloor = 3$。\n\n如果我们选择把深度大于 $3$ 的节点全部剪掉，那么我们没有剪掉任何节点，美丽值为 $\\lfloor \\dfrac{1+2+3+4+5}{3}\\rfloor = 5$。\n\n所以对于 $m=0$ 的情况，答案为 $5$；对于 $1 \\le m \\le 2$ 的情况，答案为 $3$；对于 $3 \\le m \\le 4$ 的情况，答案为 $1$；其它情况，无解输出 $-1$。\n\n#### 【数据范围】\n\n对于所有测试数据，满足 $1 \\le T \\le 10^5$，$1 \\le n \\le 10^9$，$0 \\le m \\le 2 \\times 10^9$。\n\n**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\\text{Subtask}$。**\n\n各测试点的附加限制如下表所示。\n\n| 测试点 | $n \\le$ | $m \\le$ | $T \\le$ | 特殊限制 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| $1 \\sim 2$ | $10^3$ | $10^5$ | $10^3$ | 无 |\n| $3 \\sim 4$ | $10^6$ | $2 \\times 10^6$ | $10^5$ | 无 |\n| $5$ | $10^9$ | $1$ | $10^5$ | 无 |\n| $6$ | $10^9$ | $2$ | $10^5$ | 无 |\n| $7 \\sim 8$ | $10^9$ | $3$ | $10^5$ | 无 |\n| $9 \\sim 10$ | $10^9$ | $2 \\times 10^9$ | $10^5$ | $m \\ge 1$ |\n| $11 \\sim 12$ | $10^9$ | $10^3$ | $10^5$ | 无 |\n| $13 \\sim 16$ | $10^9$ | $2 \\times 10^9$ | $10$ | 无 |\n| $17 \\sim 20$ | $10^9$ | $2 \\times 10^9$ | $10^5$ | 所有 $n$ 均相同 |\n| $21 \\sim 25$ | $10^9$ | $2 \\times 10^9$ | $10^5$ | 无 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Bina.", "background": "", "description": "小 J 家门前有两棵树，一棵是二叉树，一棵是三叉树。\n\n你被小 J 叫来修剪他的二叉树，使得他的二叉树的“美丽值”最大，所谓一棵树的美丽值 $=$ 这棵树的点的编号之和 $\\div$ 这棵树的深度（结果向下取整）。\n\n这棵二叉树有一个构建参数 $n$，构建方式如下：\n\n```cpp\nvoid build(int s,int t,int p){\n  if(s==t) return ;\n  build(s,(s+t)/2,2*p);\n  build((s+t)/2+1,t,2*p+1);\n  add_edge(p,2*p),add_edge(p,2*p+1);\n}\n\nint main(){\n  build(1,n,1);\n  return 0;\n}\n```\n\n其中 `build(s,t,p)` 函数参数中的 $p$ 是当前点的编号，`add_edge(x,y)` 函数是指将编号为 $x$ 的点向编号为 $y$ 的点连接一条有向边。\n\n容易发现这棵树的根节点是 $1$，并且我们规定节点的深度为节点到根节点路径上经过的点的个数（包括自己和根节点），这棵树的深度即为所有节点深度的最大值。\n\n对于 $n=3$ 的情况，最后构建出来的结果如下，这棵树的深度为 $3$，你需要选择一个深度 $k$ 把深度大于 $k$ 的点都剪掉，但是 $k$ 必须**大于等于** $1$ 且**小于等于**这棵树的深度。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ueggbyn8.png)\n\n小 J 还给了你一个要求，你剪去的节点个数一定得大于等于 $m$ 他才会高兴，你需要保证让他高兴的同时树的“美丽值”最大。\n\n现在小 J 给了你构建树的参数 $n$ 和至少剪的节点个数 $m$，要你求出来他的树在你修剪后最大的美丽值是多少，如果无论如何你也不可能让小 J 高兴，输出 $-1$。", "inputFormat": "本题有多组数据。\n\n第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据：\n\n输入共一行两个整数 $n,m$，表示构建二叉树的参数和你至少剪掉的节点个数。", "outputFormat": "对于每组数据：输出一行一个整数，表示能够获得的最大的“美丽值”，如果无法让小 J 高兴，输出 $-1$。", "hint": "#### 【样例解释 #1】\n\n对于第一组样例，$n$ 都等于 $3$，构建出来的树同题面所示。\n\n如果我们选择把深度大于 $1$ 的节点全部剪掉，那么我们剪掉了 $2,3,4,5$ 共 $4$ 个节点，美丽值为 $1$。\n\n如果我们选择把深度大于 $2$ 的节点全部剪掉，那么我们剪掉了 $4,5$ 共 $2$ 个节点，美丽值为 $\\lfloor \\dfrac{1+2+3}{2}\\rfloor = 3$。\n\n如果我们选择把深度大于 $3$ 的节点全部剪掉，那么我们没有剪掉任何节点，美丽值为 $\\lfloor \\dfrac{1+2+3+4+5}{3}\\rfloor = 5$。\n\n所以对于 $m=0$ 的情况，答案为 $5$；对于 $1 \\le m \\le 2$ 的情况，答案为 $3$；对于 $3 \\le m \\le 4$ 的情况，答案为 $1$；其它情况，无解输出 $-1$。\n\n#### 【数据范围】\n\n对于所有测试数据，满足 $1 \\le T \\le 10^5$，$1 \\le n \\le 10^9$，$0 \\le m \\le 2 \\times 10^9$。\n\n**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\\text{Subtask}$。**\n\n各测试点的附加限制如下表所示。\n\n| 测试点 | $n \\le$ | $m \\le$ | $T \\le$ | 特殊限制 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| $1 \\sim 2$ | $10^3$ | $10^5$ | $10^3$ | 无 |\n| $3 \\sim 4$ | $10^6$ | $2 \\times 10^6$ | $10^5$ | 无 |\n| $5$ | $10^9$ | $1$ | $10^5$ | 无 |\n| $6$ | $10^9$ | $2$ | $10^5$ | 无 |\n| $7 \\sim 8$ | $10^9$ | $3$ | $10^5$ | 无 |\n| $9 \\sim 10$ | $10^9$ | $2 \\times 10^9$ | $10^5$ | $m \\ge 1$ |\n| $11 \\sim 12$ | $10^9$ | $10^3$ | $10^5$ | 无 |\n| $13 \\sim 16$ | $10^9$ | $2 \\times 10^9$ | $10$ | 无 |\n| $17 \\sim 20$ | $10^9$ | $2 \\times 10^9$ | $10^5$ | 所有 $n$ 均相同 |\n| $21 \\sim 25$ | $10^9$ | $2 \\times 10^9$ | $10^5$ | 无 |", "locale": "zh-CN"}}}
{"pid": "P9690", "type": "P", "difficulty": 1, "samples": [["4\n2003\n1 2020\n2023\n2003\n1 2020\n2003\n2345\n0\n3456\n3000\n4 3001 3003 3004 3008\n3007", "20\n1\n1112\n5"]], "limits": {"time": [1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "广东", "O2优化", "省赛/邀请赛"], "title": "[GDCPC 2023] Programming Contest", "background": "", "description": "Guangdong Province is one of the earliest province in China which holds its own provincial collegiate programming contest. Sun Yat-sen University hosted the first Guangdong Collegiate Programming Contest in year $2003$. After that, other universities in Guangdong, such as South China Agricultural University, South China University of Technology and South China Normal University, also hosted the contest. The contest is held once a year except for year $2020$ due to the epidemic. In year $2023$, Shenzhen Technology University will host the twentieth Guangdong Collegiate Programming Contest. We are looking forward to seeing participants' outstanding performance!\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nvct1s9o.png)\n\nIn another world, a programming contest has been held once a year since year $y_1$, except for the $n$ years $s_1, s_2, \\cdots, s_n$ when it was not held due to special reasons.\n\nCalculate the number of times the competition has been held up to year $y_2$ (inclusive).", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\le T \\le 20$) indicating the number of test cases. For each test case:\n\nThe first line contains an integer $y_1$ ($1970 \\le y_1 \\le 9999$) indicating the first year when the contest was held.\n\nThe second line first contains an integer $n$ ($0 \\le n \\le 100$) indicating the number of years the contest was not held. Then $n$ integers $s_1, s_2, \\cdots, s_n$ ($y_1 < s_i \\le 9999$) follow, indicating the years when the contest was not held. These years are given in increasing order and have no duplicates.\n\nThe third line contains an integer $y_2$ ($y_1 \\le y_2 \\le 9999$). It's guaranteed that $y_2$ is not a year when the contest was not held.", "outputFormat": "For each test case output one line containing one integer, indicating the number of times the competition has been held up to year $y_2$ (inclusive).\n", "hint": "For the first sample test case, as described in the problem description, the answer is $20$.\n\nFor the second sample test case, because year $2003$ is the $1$-st year when the contest was held, the answer is $1$.\n\nFor the third sample test case, because the contest was held every year, the answer is $3456 - 2345 + 1 = 1112$.\n\nFor the fourth sample test case, the first $5$ years when the contest was held is $3000$, $3002$, $3005$, $3006$ and $3007$. So the answer is $5$.", "locale": "en", "translations": {"en": {"title": "[GDCPC 2023] Programming Contest", "background": "", "description": "Guangdong Province is one of the earliest province in China which holds its own provincial collegiate programming contest. Sun Yat-sen University hosted the first Guangdong Collegiate Programming Contest in year $2003$. After that, other universities in Guangdong, such as South China Agricultural University, South China University of Technology and South China Normal University, also hosted the contest. The contest is held once a year except for year $2020$ due to the epidemic. In year $2023$, Shenzhen Technology University will host the twentieth Guangdong Collegiate Programming Contest. We are looking forward to seeing participants' outstanding performance!\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nvct1s9o.png)\n\nIn another world, a programming contest has been held once a year since year $y_1$, except for the $n$ years $s_1, s_2, \\cdots, s_n$ when it was not held due to special reasons.\n\nCalculate the number of times the competition has been held up to year $y_2$ (inclusive).", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\le T \\le 20$) indicating the number of test cases. For each test case:\n\nThe first line contains an integer $y_1$ ($1970 \\le y_1 \\le 9999$) indicating the first year when the contest was held.\n\nThe second line first contains an integer $n$ ($0 \\le n \\le 100$) indicating the number of years the contest was not held. Then $n$ integers $s_1, s_2, \\cdots, s_n$ ($y_1 < s_i \\le 9999$) follow, indicating the years when the contest was not held. These years are given in increasing order and have no duplicates.\n\nThe third line contains an integer $y_2$ ($y_1 \\le y_2 \\le 9999$). It's guaranteed that $y_2$ is not a year when the contest was not held.", "outputFormat": "For each test case output one line containing one integer, indicating the number of times the competition has been held up to year $y_2$ (inclusive).\n", "hint": "For the first sample test case, as described in the problem description, the answer is $20$.\n\nFor the second sample test case, because year $2003$ is the $1$-st year when the contest was held, the answer is $1$.\n\nFor the third sample test case, because the contest was held every year, the answer is $3456 - 2345 + 1 = 1112$.\n\nFor the fourth sample test case, the first $5$ years when the contest was held is $3000$, $3002$, $3005$, $3006$ and $3007$. So the answer is $5$.", "locale": "en"}, "zh-CN": {"title": "[GDCPC 2023] Programming Contest", "background": "", "description": "广东省是全国较早一批将程序设计竞赛引入省内大学生竞赛体系的省份之一。$2003$ 年，中山大学承办了第一届广东省大学生程序设计竞赛。此后，华南农业大学、华南理工大学、华南师范大学等省内高校也先后承办了此赛事，除 $2020$ 年因疫情停办外，每年一届。$2023$ 年，深圳技术大学将承办第二十届广东省大学生程序设计竞赛，让我们期待选手们出色的表现！\n\n在另一个世界中，某程序设计竞赛自 $y_1$ 年起开始举办。除了 $s_1, s_2, \\cdots, s_n$ 这 $n$ 年由于特殊原因无法举办之外，其他年份每年举办一次。\n\n求 $y_2$ 年是该竞赛的第几次举办。\n\n\n对于第二组样例数据，由于 $2003$ 就是该竞赛第 $1$ 次举办的年份，因此答案为 $1$。\n\n对于第三组样例数据，由于竞赛从未停办，因此答案为 $3456 - 2345 + 1 = 1112$。\n\n对于第四组样例数据，该竞赛前 $5$ 次举办的年份为 $3000$，$3002$，$3005$，$3006$ 与 $3007$。因此答案为 $5$。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$（$1 \\le T \\le 20$）表示测试数据组数。对于每组测试数据：\n\n第一行输入一个整数 $y_1$（$1970 \\le y_1 \\le 9999$），表示该竞赛第一次举办的年份。\n\n第二行首先输入一个整数 $n$（$0 \\le n \\le 100$）表示该竞赛停办的年份数，之后输入 $n$ 个整数 $s_1, s_2, \\cdots, s_n$（$y_1 < s_i \\le 9999$）表示该竞赛的停办年份。停办年份按递增顺序给出，且没有重复的年份。\n\n第三行输入一个整数 $y_2$（$y_1 \\le y_2 \\le 9999$）。保证 $y_2$ 不是停办年份之一。", "outputFormat": "每组数据输出一行一个整数，表示 $y_2$ 年是该竞赛的第几次举办。\n\n**【样例解释】**", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9691", "type": "P", "difficulty": 4, "samples": [["2\n5\n3 2 4 1 100\n3\n1 3\n2 4\n5 5\n5\n7 3 4 2 2\n3\n1 4\n2 3\n4 5", "102\n5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "单调队列", "2023", "广东", "O2优化", "省赛/邀请赛"], "title": "[GDCPC 2023] Base Station Construction", "background": "", "description": "China Mobile Shenzhen Branch was registered in $1999$. Four years later, Guangdong Collegiate Programming Contest was held for the first time. China Mobile Shenzhen Branch, along with Guangdong Collegiate Programming Contest, witnesses the prosperity and development of the computer industry in Guangdong.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/md6qj7fz.png)\n\nDuring the construction of a communication line, it is critical to carefully choose the locations for base stations. The distance from west to east of a city is $n$ kilometers. The engineers have investigated the cost to build a base station at $1, 2, \\cdots, n$ kilometers from west to east, which are $a_1, a_2, \\cdots, a_n$ respectively.\n\nTo ensure communication quality for the residents, the locations of base stations also need to meet $m$ requirements. The $i$-th requirement can be represented as a pair of integers $l_i$ and $r_i$ ($1 \\le l_i \\le r_i \\le n$), indicating that there must be at least $1$ base station between $l_i$ kilometers and $r_i$ kilometers (both inclusive) from west to east.\n\nAs the chief engineer, you need to decide the number of base stations to build and their locations, and finally calculate the minimum total cost to satisfy all requirements.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 5 \\times 10^5$) indicating the distance from west to east of the city.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le 10^9$) where $a_i$ indicates the cost to build a base station at $i$ kilometers from west to east.\n\nThe third line contains an integer $m$ ($1 \\le m \\le 5 \\times 10^5$) indicating the number of requirements.\n\nFor the following $m$ lines, the $i$-th line contains two integers $l_i$ and $r_i$ ($1 \\le l_i \\le r_i \\le n$) indicating that there must be at least $1$ base station between $l_i$ kilometers and $r_i$ kilometers (both inclusive) from west to east.\n\nIt's guaranteed that neither the sum of $n$ nor the sum of $m$ of all test cases will exceed $5 \\times 10^5$.", "outputFormat": "For each test case output one line containing one integer indicating the minimum total cost to satisfy all requirements.", "hint": "For the first sample test case the optimal solution is to build base stations at $2$ kilometers and $5$ kilometers from west to east. The total cost is $2 + 100 = 102$.\n\nFor the second sample test case the optimal solution is to build base stations at $2$ kilometers and $4$ kilometers from west to east. The total cost is $3 + 2 = 5$.", "locale": "en", "translations": {"en": {"title": "[GDCPC 2023] Base Station Construction", "background": "", "description": "China Mobile Shenzhen Branch was registered in $1999$. Four years later, Guangdong Collegiate Programming Contest was held for the first time. China Mobile Shenzhen Branch, along with Guangdong Collegiate Programming Contest, witnesses the prosperity and development of the computer industry in Guangdong.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/md6qj7fz.png)\n\nDuring the construction of a communication line, it is critical to carefully choose the locations for base stations. The distance from west to east of a city is $n$ kilometers. The engineers have investigated the cost to build a base station at $1, 2, \\cdots, n$ kilometers from west to east, which are $a_1, a_2, \\cdots, a_n$ respectively.\n\nTo ensure communication quality for the residents, the locations of base stations also need to meet $m$ requirements. The $i$-th requirement can be represented as a pair of integers $l_i$ and $r_i$ ($1 \\le l_i \\le r_i \\le n$), indicating that there must be at least $1$ base station between $l_i$ kilometers and $r_i$ kilometers (both inclusive) from west to east.\n\nAs the chief engineer, you need to decide the number of base stations to build and their locations, and finally calculate the minimum total cost to satisfy all requirements.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 5 \\times 10^5$) indicating the distance from west to east of the city.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le 10^9$) where $a_i$ indicates the cost to build a base station at $i$ kilometers from west to east.\n\nThe third line contains an integer $m$ ($1 \\le m \\le 5 \\times 10^5$) indicating the number of requirements.\n\nFor the following $m$ lines, the $i$-th line contains two integers $l_i$ and $r_i$ ($1 \\le l_i \\le r_i \\le n$) indicating that there must be at least $1$ base station between $l_i$ kilometers and $r_i$ kilometers (both inclusive) from west to east.\n\nIt's guaranteed that neither the sum of $n$ nor the sum of $m$ of all test cases will exceed $5 \\times 10^5$.", "outputFormat": "For each test case output one line containing one integer indicating the minimum total cost to satisfy all requirements.", "hint": "For the first sample test case the optimal solution is to build base stations at $2$ kilometers and $5$ kilometers from west to east. The total cost is $2 + 100 = 102$.\n\nFor the second sample test case the optimal solution is to build base stations at $2$ kilometers and $4$ kilometers from west to east. The total cost is $3 + 2 = 5$.", "locale": "en"}, "zh-CN": {"title": "[GDCPC 2023] Base Station Construction", "background": "", "description": "中国移动通信集团广东有限公司深圳分公司（以下简称``深圳移动``）于 $1999$ 年正式注册。四年后，广东省大学生程序设计竞赛第一次举办。深圳移动与广东省大学生程序设计竞赛一起见证了广东省计算机行业的兴旺与发展。\n\n在建设通信线路的过程中，信号基站的选址是一个非常关键的问题。某城市从西到东的距离为 $n$ 千米，工程师们已经考察了在从西往东 $1, 2, \\cdots, n$ 千米的位置建设基站的成本，分别是 $a_1, a_2, \\cdots, a_n$。\n\n为了保证居民的通信质量，基站的选址还需要满足 $m$ 条需求。第 $i$ 条需求可以用一对整数 $l_i$ 和 $r_i$ 表示（$1 \\le l_i \\le r_i \\le n$），代表从西往东 $l_i$ 千米到 $r_i$ 千米的位置之间（含两端）至少需要建设 $1$ 座基站。\n\n作为总工程师，您需要决定基站的数量与位置，并计算满足所有需求的最小总成本。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数，对于每组测试数据：\n\n第一行输入一个整数 $n$（$1 \\le n \\le 5 \\times 10^5$）表示城市从西到东的距离。\n\n第二行输入 $n$ 个整数 $a_1, a_2, \\cdots, a_n$（$1 \\le a_i \\le 10^9$），其中 $a_i$ 表示在从西往东 $i$ 千米的位置建设基站的成本。\n\n第三行输入一个整数 $m$（$1 \\le m \\le 5 \\times 10^5$）表示需求的数量。\n\n对于接下来 $m$ 行，第 $i$ 行输入两个整数 $l_i$ 和 $r_i$（$1 \\le l_i \\le r_i \\le n$）表示从西往东 $l_i$ 千米到 $r_i$ 千米的位置之间（含两端）至少需要建设 $1$ 座基站。\n\n保证所有数据 $n$ 之和与 $m$ 之和均不超过 $5 \\times 10^5$。", "outputFormat": "每组数据输出一行一个整数，表示满足所有需求的最小总成本。\n\n**【样例解释】**\n\n对于第一组样例数据，最优方案是在从西往东 $2$ 千米和 $5$ 千米的位置建设基站。总成本为 $2 + 100 = 102$。\n\n对于第二组样例数据，最优方案是在从西往东 $2$ 千米和 $4$ 千米的位置建设基站。总成本为 $3 + 2 = 5$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9692", "type": "P", "difficulty": 2, "samples": [["2\n4\n10 2\n30 7\n20 4\n50 1\n2\n1 100\n1 1000", "100\n0"]], "limits": {"time": [1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "广东", "O2优化", "省赛/邀请赛"], "title": "[GDCPC 2023] Trading", "background": "", "description": "Twenty years ago, the northern section of Beijing Road Pedestrian Street in Guangzhou unearthed eleven layers of pavement from the Tang Dynasty to the Republic of China, and the southern section excavated the foundation of Gongbei Building with five layers from the Song Dynasty to the Ming and Qing Dynasties. This proves that Beijing Road has a long history as a commercial pedestrian street since the Song Dynasty. At the same time, the first Guangdong Province Collegiate Programming Contest was also held at Sun Yat-sen University in Guangzhou. Today, twenty years later, Beijing Road Pedestrian Street has become one of Guangzhou's most famous tourist attractions and shopping destinations, and the Guangdong Province Collegiate Programming Contest is also celebrating its twentieth birthday.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qaieoirq.png)\n\nThere are $n$ stores in the pedestrian street which buy and sell the same type of product. The buying and selling price of one such product in the $i$-th store are both $a_i$. To avoid over-trading, the pedestrian street has a regulation, that one can only trade $b_i$ times in the $i$-th store (each buy or each sell both count as a trade) and can only trade one product each time.\n\nYou're going to earn money by buying and selling the products in the pedestrian street. If you have infinite amount of money at the beginning (that is to say, you can't be short of money when buying a product), what's the maximum total profit you can make? More precisely, \\textit{profit} means the total amount of money earned by selling the products, minus the total amount of money spent for buying the products.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^5$) indicating the number of stores.\n\nFor the following $n$ lines, the $i$-th line contains two integers $a_i$ and $b_i$ ($1 \\le a_i, b_i \\le 10^6$) indicating the price and the maximum number of trades in the $i$-th store.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum total profit.", "hint": "For the first sample test case, the optimal strategy is to buy $2$ products from the $1$-st store, buy $4$ products from the $3$-rd store, sell $5$ products to the $2$-nd store and sell $1$ product to the $4$-th store. The total profit is $30 \\times 5 + 50 \\times 1 - 10 \\times 2 - 20 \\times 4 = 100$.\n\nFor the second sample test case, because all stores have the same price, there is no profit.", "locale": "en", "translations": {"en": {"title": "[GDCPC 2023] Trading", "background": "", "description": "Twenty years ago, the northern section of Beijing Road Pedestrian Street in Guangzhou unearthed eleven layers of pavement from the Tang Dynasty to the Republic of China, and the southern section excavated the foundation of Gongbei Building with five layers from the Song Dynasty to the Ming and Qing Dynasties. This proves that Beijing Road has a long history as a commercial pedestrian street since the Song Dynasty. At the same time, the first Guangdong Province Collegiate Programming Contest was also held at Sun Yat-sen University in Guangzhou. Today, twenty years later, Beijing Road Pedestrian Street has become one of Guangzhou's most famous tourist attractions and shopping destinations, and the Guangdong Province Collegiate Programming Contest is also celebrating its twentieth birthday.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qaieoirq.png)\n\nThere are $n$ stores in the pedestrian street which buy and sell the same type of product. The buying and selling price of one such product in the $i$-th store are both $a_i$. To avoid over-trading, the pedestrian street has a regulation, that one can only trade $b_i$ times in the $i$-th store (each buy or each sell both count as a trade) and can only trade one product each time.\n\nYou're going to earn money by buying and selling the products in the pedestrian street. If you have infinite amount of money at the beginning (that is to say, you can't be short of money when buying a product), what's the maximum total profit you can make? More precisely, \\textit{profit} means the total amount of money earned by selling the products, minus the total amount of money spent for buying the products.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^5$) indicating the number of stores.\n\nFor the following $n$ lines, the $i$-th line contains two integers $a_i$ and $b_i$ ($1 \\le a_i, b_i \\le 10^6$) indicating the price and the maximum number of trades in the $i$-th store.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum total profit.", "hint": "For the first sample test case, the optimal strategy is to buy $2$ products from the $1$-st store, buy $4$ products from the $3$-rd store, sell $5$ products to the $2$-nd store and sell $1$ product to the $4$-th store. The total profit is $30 \\times 5 + 50 \\times 1 - 10 \\times 2 - 20 \\times 4 = 100$.\n\nFor the second sample test case, because all stores have the same price, there is no profit.", "locale": "en"}, "zh-CN": {"title": "[GDCPC 2023] Trading", "background": "", "description": "二十年前，广州的北京路步行街北段出土了自唐代直到民国时期的十一层路面，南段则发掘出宋代至明清时期共五层的拱北楼建筑基址，佐证了北京路自宋代以来作为商业步行街的悠久历史；同时第一届广东省大学生程序设计竞赛也在位处广州的中山大学举办。二十年后的今天，北京路步行街已成为广州最负盛名的景点和购物胜地之一，而广东省大学生程序设计竞赛也迎来了自己的二十岁生日。\n\n在步行街中，有 $n$ 间商店买卖同一种商品，第 $i$ 间商店一件商品的收购价和出售价均为 $a_i$ 元。为了防止过度交易，步行街有一个规定：您在第 $i$ 间商店最多进行 $b_i$ 次交易（一次买或一次卖均计为一次交易），且每次只能交易一件商品。\n\n您准备通过在步行街中买卖这种商品来赚钱。假如初始时有无限的金钱（也就是说，不会因为钱不够而买不了一件商品），您最多能在步行街中赚到多少总利润？具体来说，``利润``指的是卖出商品获得的金钱总额，减去购买商品花费的金钱总额。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：\n\n第一行输入一个整数 $n$（$1 \\le n \\le 10^5$），表示商店的数量。\n\n对于接下来 $n$ 行，第 $i$ 行输入两个整数 $a_i$ 和 $b_i$（$1 \\le a_i, b_i \\le 10^6$），分别表示第 $i$ 间商店的商品价格，以及该商店可以交易的最大次数。\n\n保证所有数据 $n$ 之和不超过 $10^6$。", "outputFormat": "每组数据输出一行一个整数，表示在步行街中赚到的最大总利润。\n\n**【样例解释】**\n\n对于第一组样例数据，最优方案是在第 $1$ 间商店买入 $2$ 件商品，在第 $3$ 间商店买入 $4$ 件商品，在第 $2$ 间商店卖出 $5$ 件商品，在第 $4$ 间商店卖出 $1$ 件商品。总利润为 $30 \\times 5 + 50 \\times 1 - 10 \\times 2 - 20 \\times 4 = 100$。\n\n对于第二组样例数据，由于所有商店的商品价格都相同，因此无法获得利润。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9693", "type": "P", "difficulty": 3, "samples": [["3\n4 5\n1 100\n100 1\n100 1\n100 1\n2 2\n1 10\n1 10\n2 3\n100 50\n1 1000", "400\n2\n1050"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "广东", "O2优化", "省赛/邀请赛"], "title": "[GDCPC 2023] New Houses", "background": "", "description": "With the construction and development of Guangdong, more and more people choose to come to Guangdong to start a new life. In a recently built community, there will be $n$ people moving into $m$ houses which are arranged in a row. The houses are numbered from $1$ to $m$ (both inclusive). House $u$ and $v$ are neighboring houses, if and only if $|u-v|=1$. We need to assign each person to a house so that no two people will move into the same house. If two people move into a pair of neighboring houses, they will become neighbors of each other.\n\nSome people like to have neighbors while some don't. For the $i$-th person, if he has at least one neighbor, his happiness will be $a_i$; Otherwise if he does not have any neighbor, his happiness will be $b_i$.\n\nAs the planner of this community, you need to maximize the total happiness.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n \\le 5 \\times 10^5$, $1 \\le m \\le 10^9$, $n \\le m$) indicating the number of people and the number of houses.\n\nFor the following $n$ lines, the $i$-th line contains two integers $a_i$ and $b_i$ ($1 \\le a_i, b_i \\le 10^9$) indicating the happiness of the $i$-th person with and without neighbors.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum total happiness.", "hint": "For the first sample test case, the optimal strategy is to let person $1$ move into house $1$ and let person $2$ to $4$ move into house $3$ to $5$. Thus, person $1$ have no neighbors while person $2$ to $4$ have neighbors. The answer is $100 + 100 + 100 + 100 = 400$. Of course, we can also let person $2$ to $4$ move into house $1$ to $3$ and let person $1$ move into house $5$. This will also give us $400$ total happiness.\n\nFor the second sample test case, as there are only $2$ houses, person $1$ and $2$ have to be neighbors. The answer is $1 + 1 = 2$.\n\nFor the third sample test case, the optimal strategy is to let person $1$ move into house $1$ and let person $2$ move into house $3$. Thus, both of them have no neighbors. The answer is $50 + 1000 = 1050$.", "locale": "en", "translations": {"en": {"title": "[GDCPC 2023] New Houses", "background": "", "description": "With the construction and development of Guangdong, more and more people choose to come to Guangdong to start a new life. In a recently built community, there will be $n$ people moving into $m$ houses which are arranged in a row. The houses are numbered from $1$ to $m$ (both inclusive). House $u$ and $v$ are neighboring houses, if and only if $|u-v|=1$. We need to assign each person to a house so that no two people will move into the same house. If two people move into a pair of neighboring houses, they will become neighbors of each other.\n\nSome people like to have neighbors while some don't. For the $i$-th person, if he has at least one neighbor, his happiness will be $a_i$; Otherwise if he does not have any neighbor, his happiness will be $b_i$.\n\nAs the planner of this community, you need to maximize the total happiness.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n \\le 5 \\times 10^5$, $1 \\le m \\le 10^9$, $n \\le m$) indicating the number of people and the number of houses.\n\nFor the following $n$ lines, the $i$-th line contains two integers $a_i$ and $b_i$ ($1 \\le a_i, b_i \\le 10^9$) indicating the happiness of the $i$-th person with and without neighbors.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum total happiness.", "hint": "For the first sample test case, the optimal strategy is to let person $1$ move into house $1$ and let person $2$ to $4$ move into house $3$ to $5$. Thus, person $1$ have no neighbors while person $2$ to $4$ have neighbors. The answer is $100 + 100 + 100 + 100 = 400$. Of course, we can also let person $2$ to $4$ move into house $1$ to $3$ and let person $1$ move into house $5$. This will also give us $400$ total happiness.\n\nFor the second sample test case, as there are only $2$ houses, person $1$ and $2$ have to be neighbors. The answer is $1 + 1 = 2$.\n\nFor the third sample test case, the optimal strategy is to let person $1$ move into house $1$ and let person $2$ move into house $3$. Thus, both of them have no neighbors. The answer is $50 + 1000 = 1050$.", "locale": "en"}, "zh-CN": {"title": "[GDCPC 2023] New Houses", "background": "", "description": "随着广东的建设与发展，越来越多人选择来到广东开始新生活。在一片新建的小区，有 $n$ 个人要搬进 $m$ 栋排成一行的房子，房子的编号从 $1$ 到 $m$（含两端）。房子 $u$ 和 $v$ 相邻，当且仅当 $|u-v|=1$。我们需要为每一个人安排一栋房子，要求所有人入住的房子互不相同。若两个人住进了一对相邻的房子，则这两个人互为邻居。\n\n有的人喜欢自己有邻居，而有的人不喜欢。对于第 $i$ 个人，如果他有至少一位邻居，则他的满意度为 $a_i$；否则如果他没有邻居，则他的满意度为 $b_i$。\n\n您作为小区的规划者，需要最大化所有人的总满意度。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：\n\n第一行输入两个整数 $n$ 和 $m$（$1 \\le n \\le 5 \\times 10^5$，$1 \\le m \\le 10^9$，$n \\le m$），表示人数和房子数。\n\n对于接下来的 $n$ 行，第 $i$ 行输入两个整数 $a_i$ 和 $b_i$（$1 \\le a_i, b_i \\le 10^9$），表示第 $i$ 个人在有邻居和没有邻居时的满意度。\n\n保证所有数据 $n$ 之和不超过 $10^6$。", "outputFormat": "每组数据输出一行一个整数表示最大总满意度。\n\n**【样例解释】**\n\n对于第一组样例数据，最优方案是让第 $1$ 个人入住房子 $1$，第 $2$ 到 $4$ 个人入住房子 $3$ 到 $5$。这样，第 $1$ 个人没有邻居，而第 $2$ 到 $4$ 个人都有邻居。答案为 $100 + 100 + 100 + 100 = 400$。当然，也可以让第 $2$ 到 $4$ 个人入住房子 $1$ 到 $3$，第 $1$ 个人入住房子 $5$，也能得到 $400$ 的总满意度。\n\n对于第二组样例数据，由于只有 $2$ 栋房子，因此第 $1$ 和第 $2$ 个人必须成为邻居。答案为 $1 + 1 = 2$。\n\n对于第三组样例数据，最优方案是让第 $1$ 个人入住房子 $1$，第 $2$ 个人入住房子 $3$。这样，两个人都没有邻居。答案为 $50 + 1000 = 1050$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9694", "type": "P", "difficulty": 5, "samples": [["2\n5 3\ngdcpc\ngdcpcpcp\nsuasua\nsuas\nsususua\n3 3\na\nb\nc", "gdcpc\nEMPTY"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "广东", "O2优化", "字典树 Trie", "省赛/邀请赛"], "title": "[GDCPC 2023] New but Nostalgic Problem", "background": "", "description": "Given $n$ strings $w_1, w_2, \\cdots, w_n$, please select $k$ strings among them, so that the lexicographic order of string $v$ is minimized, and output the optimal string $v$. String $v$ satisfies the following constraint: $v$ is the longest common prefix of two selected strings with different indices. Also, $v$ is the lexicographically largest string among all strings satisfying the constraint.\n\nMore formally, let $\\mathbb{S}$ be a set of size $k$, where all the elements in the set are integers between $1$ and $n$ (both inclusive) and there are no duplicated elements. Let $\\text{lcp}(w_i, w_j)$ be the longest common prefix of string $w_i$ and $w_j$, please find a set $\\mathbb{S}$ to minimize the lexicographic order of the following string $v$ and output the optimal string $v$.\n\n$$\nv = \\max\\limits_{i \\in \\mathbb{S}, j \\in \\mathbb{S}, i \\ne j} \\text{lcp}(w_i, w_j)\n$$\n\nIn the above expression, $\\max$ is calculated by comparing the lexicographic order of strings.\n\nRecall that:\n- String $p$ is a prefix of string $s$, if we can append some number of characters (including zero characters) at the end of $p$ so that it changes to $s$. Specifically, empty string is a prefix of any string.\n- The longest common prefix of string $s$ and string $t$ is the longest string $p$ such that $p$ is a prefix of both $s$ and $t$. For example, the longest common prefix of ``abcde`` and ``abcef`` is ``abc``, while the longest common prefix of ``abcde`` and ``bcdef`` is an empty string.\n- String $s$ is lexicographically smaller than string $t$ ($s \\ne t$), if\n  - $s$ is a prefix of $t$, or\n  - $s_{|p| + 1} < t_{|p| + 1}$, where $p$ is the longest common prefix of $s$ and $t$, $|p|$ is the length of $p$, $s_i$ is the $i$-th character of string $s$, and $t_i$ is the $i$-th character of string $t$.\n- Specifically, empty string is the string with the smallest lexicographic order.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $k$ ($2\\leq n\\leq 10^6$, $2\\leq k\\leq n$) indicating the total number of strings and the number of strings to be selected.\n\nFor the following $n$ lines, the $i$-th line contains a string $w_i$ ($1\\leq |w_i|\\leq 10^6$) consisting of lower-cased English letters.\n\nIt's guaranteed that the total length of all strings of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one string indicating the answer. Specifically, if the answer is an empty string, print $\\texttt{EMPTY}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[GDCPC 2023] New but Nostalgic Problem", "background": "", "description": "Given $n$ strings $w_1, w_2, \\cdots, w_n$, please select $k$ strings among them, so that the lexicographic order of string $v$ is minimized, and output the optimal string $v$. String $v$ satisfies the following constraint: $v$ is the longest common prefix of two selected strings with different indices. Also, $v$ is the lexicographically largest string among all strings satisfying the constraint.\n\nMore formally, let $\\mathbb{S}$ be a set of size $k$, where all the elements in the set are integers between $1$ and $n$ (both inclusive) and there are no duplicated elements. Let $\\text{lcp}(w_i, w_j)$ be the longest common prefix of string $w_i$ and $w_j$, please find a set $\\mathbb{S}$ to minimize the lexicographic order of the following string $v$ and output the optimal string $v$.\n\n$$\nv = \\max\\limits_{i \\in \\mathbb{S}, j \\in \\mathbb{S}, i \\ne j} \\text{lcp}(w_i, w_j)\n$$\n\nIn the above expression, $\\max$ is calculated by comparing the lexicographic order of strings.\n\nRecall that:\n- String $p$ is a prefix of string $s$, if we can append some number of characters (including zero characters) at the end of $p$ so that it changes to $s$. Specifically, empty string is a prefix of any string.\n- The longest common prefix of string $s$ and string $t$ is the longest string $p$ such that $p$ is a prefix of both $s$ and $t$. For example, the longest common prefix of ``abcde`` and ``abcef`` is ``abc``, while the longest common prefix of ``abcde`` and ``bcdef`` is an empty string.\n- String $s$ is lexicographically smaller than string $t$ ($s \\ne t$), if\n  - $s$ is a prefix of $t$, or\n  - $s_{|p| + 1} < t_{|p| + 1}$, where $p$ is the longest common prefix of $s$ and $t$, $|p|$ is the length of $p$, $s_i$ is the $i$-th character of string $s$, and $t_i$ is the $i$-th character of string $t$.\n- Specifically, empty string is the string with the smallest lexicographic order.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $k$ ($2\\leq n\\leq 10^6$, $2\\leq k\\leq n$) indicating the total number of strings and the number of strings to be selected.\n\nFor the following $n$ lines, the $i$-th line contains a string $w_i$ ($1\\leq |w_i|\\leq 10^6$) consisting of lower-cased English letters.\n\nIt's guaranteed that the total length of all strings of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one string indicating the answer. Specifically, if the answer is an empty string, print $\\texttt{EMPTY}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[GDCPC 2023] New but Nostalgic Problem", "background": "", "description": "给定 $n$ 个字符串 $w_1, w_2, \\cdots, w_n$，请选出恰好 $k$ 个字符串，最小化字符串 $v$ 的字典序，并输出这个最优的字符串 $v$。其中 $v$ 满足以下条件：$v$ 是被选出的字符串中，某两个编号不同的字符串的最长公共前缀。而且，$v$ 是所有满足条件的字符串中，字典序最大的字符串。\n\n更正式地，令 $\\mathbb{S}$ 表示一个大小为 $k$ 的集合，集合中的元素均为从 $1$ 到 $n$ 的整数（含两端），且没有重复的元素。令 $\\text{lcp}(w_i, w_j)$ 表示字符串 $w_i$ 和 $w_j$ 的最长公共前缀，您需要找到一个集合 $\\mathbb{S}$ 以最小化下述字符串 $v$ 的字典序，并输出这个最优的字符串 $v$。\n\n$$\nv = \\max\\limits_{i \\in \\mathbb{S}, j \\in \\mathbb{S}, i \\ne j} \\text{lcp}(w_i, w_j)\n$$\n\n上式中的 $\\max$ 通过字典序比较两个字符串。\n\n请回忆：\n- 称字符串 $p$ 是字符串 $s$ 的前缀，若可以在 $p$ 的末尾添加若干个字符（包括零个字符）将它变成 $s$。特别地，空字符串是任意字符串的前缀。\n- 字符串 $s$ 和 $t$ 的最长公共前缀是一个最长的字符串 $p$，满足 $p$ 既是 $s$ 的前缀，又是 $t$ 的前缀。例如，``abcde`` 与``abcef`` 的最长公共前缀为 ``abc``，而 ``abcde`` 与 ``bcdef`` 的最长公共前缀为空字符串。\n- 称字符串 $s$ 的字典序小于字符串 $t$（$s \\ne t$），若\n  - $s$ 是 $t$ 的前缀，或\n  - $s_{|p| + 1} < t_{|p| + 1}$，其中 $p$ 为 $s$ 和 $t$ 的最长公共前缀，$|p|$ 为 $p$ 的长度，$s_i$ 表示字符串 $s$ 的第 $i$ 个字符，$t_i$ 表示字符串 $t$ 的第 $i$ 个字符。\n- 特别地，空字符串是字典序最小的字符串。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：\n\n第一行输入两个整数 $n$ 和 $k$（$2\\leq n\\leq 10^6$，$2\\leq k\\leq n$），表示字符串的总数和需要选择的字符串的数量。\n\n对于接下来 $n$ 行，第 $i$ 行输入一个由小写字母构成的字符串 $w_i$（$1\\leq |w_i|\\leq 10^6$）。\n\n保证所有数据中字符串长度之和不超过 $10^6$。", "outputFormat": "每组数据输出一行一个字符串表示答案。特别地，若答案为空字符串，输出 $\\texttt{EMPTY}$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9695", "type": "P", "difficulty": 5, "samples": [["2\n5 10\n1 2 3 1 2\n1 10 100 1000 10000\n3 3 1 3\n3 3 2 2 3\n2 5 20000\n2 3 200\n3 3 2 1 3\n3 3 3 1 2 3\n1 3 4\n2 1 100000\n1 2 2\n3 1 2 1 2\n4 1\n1 2 3 4\n1000000 1000000 1000000 1000000\n3 4 4 1 2 3 4", "100\n110\n1200\n21211\n100010\n4000000"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "树状数组", "2023", "广东", "O2优化", "分块", "省赛/邀请赛"], "title": "[GDCPC 2023] Traveling in Cells", "background": "", "description": "There are $n$ cells arranged in a row. The $i$-th cell has a color $c_i$ and contains a ball with value $v_i$.\n\nYou're going to travel several times in the cells. For each travel, you'll be given an integer $x$ and a set of colors $\\mathbb{A} = \\{a_1, a_2, \\cdots, a_k\\}$ where $c_x \\in \\mathbb{A}$. The travel starts from cell $x$. During the travel, if you're located in cell $i$ you can next move to cell $(i - 1)$ or $(i + 1)$. Note that you can't move out of these $n$ cells. Also at any time, the color of cell you're located in must belong to set $\\mathbb{A}$.\n\nWhen you're in cell $i$, you can choose to remove the ball in the cell and gain its value $v_i$. As there is only one ball in each cell, you can only remove the ball from each cell once.\n\nYour task is to process $q$ operations in order. Each operation is one of the following three types:\n\n- $1\\; p \\; x$: Change $c_p$ to $x$.\n- $2\\; p \\; x$: Change $v_p$ to $x$.\n- $3\\; x\\; k\\; a_1\\; a_2 \\; \\ldots\\; a_k$: Given the starting cell $x$ and the color set $\\mathbb{A} = \\{a_1, a_2, \\cdots, a_k\\}$ of a travel, imagine that you're going on this travel, calculate the maximum total value you can gain. Note that this travel is only an imagination, thus the balls won't be truely removed. That is, all queries are independent.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $q$ ($1 \\leq n \\leq 10^5$, $1 \\leq q \\leq 10^5$) indicating the number of cells and the number of operations.\n\nThe second line contains $n$ integers $c_1, c_2, \\ldots, c_n$ ($1 \\leq c_i \\leq n$) where $c_i$ is the initial color of the $i$-th cell.\n\nThe third line contains $n$ integers $v_1, v_2, \\ldots, v_n$ ($1 \\leq v_i \\leq 10^9$) where $v_i$ is the initial value of ball in the $i$-th cell.\n\nFor the following $q$ lines, the $i$-th line describes the $i$-th operation. The input format is listed as follows:\n\n- $1\\; p\\; x$: $1 \\leq p \\leq n$ and $1 \\leq x \\leq n$.\n- $2\\; p\\; x$: $1 \\leq p \\leq n$ and $1 \\leq x \\leq 10^9$.\n- $3\\; x\\; k\\; a_1\\; a_2\\; \\ldots \\; a_k$: $1 \\leq x \\leq n$, $1 \\leq a_1 < a_2 < \\ldots < a_k \\leq n$ and $c_x \\in \\{a_1, a_2, \\cdots, a_k\\}$.\n\nIt's guaranteed that neither the sum of $n$ nor the sum of $q$ of all test cases will exceed $3 \\times 10^5$. Also the sum of $k$ of all test cases will not exceed $10^6$.", "outputFormat": "For each operation of type $3$ output one line containing one integer, indicating the maximum total value you can gain.", "hint": "", "locale": "en", "translations": {"en": {"title": "[GDCPC 2023] Traveling in Cells", "background": "", "description": "There are $n$ cells arranged in a row. The $i$-th cell has a color $c_i$ and contains a ball with value $v_i$.\n\nYou're going to travel several times in the cells. For each travel, you'll be given an integer $x$ and a set of colors $\\mathbb{A} = \\{a_1, a_2, \\cdots, a_k\\}$ where $c_x \\in \\mathbb{A}$. The travel starts from cell $x$. During the travel, if you're located in cell $i$ you can next move to cell $(i - 1)$ or $(i + 1)$. Note that you can't move out of these $n$ cells. Also at any time, the color of cell you're located in must belong to set $\\mathbb{A}$.\n\nWhen you're in cell $i$, you can choose to remove the ball in the cell and gain its value $v_i$. As there is only one ball in each cell, you can only remove the ball from each cell once.\n\nYour task is to process $q$ operations in order. Each operation is one of the following three types:\n\n- $1\\; p \\; x$: Change $c_p$ to $x$.\n- $2\\; p \\; x$: Change $v_p$ to $x$.\n- $3\\; x\\; k\\; a_1\\; a_2 \\; \\ldots\\; a_k$: Given the starting cell $x$ and the color set $\\mathbb{A} = \\{a_1, a_2, \\cdots, a_k\\}$ of a travel, imagine that you're going on this travel, calculate the maximum total value you can gain. Note that this travel is only an imagination, thus the balls won't be truely removed. That is, all queries are independent.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $q$ ($1 \\leq n \\leq 10^5$, $1 \\leq q \\leq 10^5$) indicating the number of cells and the number of operations.\n\nThe second line contains $n$ integers $c_1, c_2, \\ldots, c_n$ ($1 \\leq c_i \\leq n$) where $c_i$ is the initial color of the $i$-th cell.\n\nThe third line contains $n$ integers $v_1, v_2, \\ldots, v_n$ ($1 \\leq v_i \\leq 10^9$) where $v_i$ is the initial value of ball in the $i$-th cell.\n\nFor the following $q$ lines, the $i$-th line describes the $i$-th operation. The input format is listed as follows:\n\n- $1\\; p\\; x$: $1 \\leq p \\leq n$ and $1 \\leq x \\leq n$.\n- $2\\; p\\; x$: $1 \\leq p \\leq n$ and $1 \\leq x \\leq 10^9$.\n- $3\\; x\\; k\\; a_1\\; a_2\\; \\ldots \\; a_k$: $1 \\leq x \\leq n$, $1 \\leq a_1 < a_2 < \\ldots < a_k \\leq n$ and $c_x \\in \\{a_1, a_2, \\cdots, a_k\\}$.\n\nIt's guaranteed that neither the sum of $n$ nor the sum of $q$ of all test cases will exceed $3 \\times 10^5$. Also the sum of $k$ of all test cases will not exceed $10^6$.", "outputFormat": "For each operation of type $3$ output one line containing one integer, indicating the maximum total value you can gain.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[GDCPC 2023] Traveling in Cells", "background": "", "description": "有 $n$ 个格子排成一行，第 $i$ 个格子的颜色为 $c_i$，上面放置着一个权值为 $v_i$ 的球。\n\n您将要在格子中进行若干次旅行。每次旅行时，您会得到旅行的起点 $x$ 与一个颜色集合 $\\mathbb{A} = \\{a_1, a_2, \\cdots, a_k\\}$，且保证 $c_x \\in \\mathbb{A}$。旅行将从第 $x$ 个格子上开始。在旅行期间，如果您在格子 $i$ 处，那么您可以向格子 $(i - 1)$ 或 $(i + 1)$ 处移动，但不能移动到这 $n$ 个格子之外。且在任意时刻，您所处的格子的颜色必须在集合 $\\mathbb{A}$ 中。\n\n当您位于格子 $i$ 时，您可以选择将格子上的球取走，并获得 $v_i$ 的权值。由于每个格子上只有一个球，因此一个格子上的球只能被取走一次。\n\n您的任务是依次处理 $q$ 次操作，每次操作形如以下三种操作之一：\n\n- $1\\; p \\; x$：将 $c_p$ 修改为 $x$。\n- $2\\; p \\; x$：将 $v_p$ 修改为 $x$。\n- $3\\; x\\; k\\; a_1\\; a_2 \\; \\ldots\\; a_k$：给定旅行的起点 $x$ 与一个颜色集合 $\\mathbb{A} = \\{a_1, a_2, \\cdots, a_k\\}$。假设如果进行这样的一次旅行，求出取走的球的权值之和最大是多少。注意，由于我们仅仅假设进行一次旅行，因此并不会真的取走任何球。即，所有询问之间是独立的。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：\n\n第一行输入两个整数 $n$ 和 $q$（$1 \\leq n \\leq 10^5$，$1 \\leq q \\leq 10^5$）表示格子的数量和操作的数量。\n\n第二行输入 $n$ 个整数 $c_1, c_2, \\ldots, c_n$（$1 \\leq c_i \\leq n$），其中 $c_i$ 表示第 $i$ 个格子的初始颜色。\n\n第三行输入 $n$ 个整数 $v_1, v_2, \\ldots, v_n$（$1 \\leq v_i \\leq 10^9$），其中 $v_i$ 表示第 $i$ 个格子里的球的初始权值。\n\n对于接下来 $q$ 行，第 $i$ 行描述第 $i$ 次操作，格式如下：\n\n- $1\\; p\\; x$：保证 $1 \\leq p \\leq n$ 且 $1 \\leq x \\leq n$。\n- $2\\; p\\; x$：保证 $1 \\leq p \\leq n$ 且 $1 \\leq x \\leq 10^9$。\n- $3\\; x\\; k\\; a_1\\; a_2\\; \\ldots \\; a_k$：保证 $1 \\leq x \\leq n$ 且 $1 \\leq a_1 < a_2 < \\ldots < a_k \\leq n$ 且 $c_x \\in \\{a_1, a_2, \\cdots, a_k\\}$。\n\n保证所有数据 $n$ 之和与 $q$ 之和均不超过 $3 \\times 10^5$，且所有数据 $k$ 之和不超过 $10^6$。", "outputFormat": "对于每次操作 $3$ 输出一行一个整数，表示取走的球的权值之和的最大值。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9696", "type": "P", "difficulty": 6, "samples": [["3\n6\n6 5 4 3 5 6\n6\n1 2 1 1 2 2\n5\n1 1 2 2 2", "7\n3\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "广东", "O2优化", "前缀和", "省赛/邀请赛"], "title": "[GDCPC 2023] Swapping Operation", "background": "", "description": "Given a non-negative integer sequence $A = a_1, a_2, \\dots, a_n$ of length $n$, define\n\n$$\nF(A)=\\max\\limits_{1\\leq k<n} ((a_1 \\,\\&\\, a_2 \\,\\&\\, \\cdots \\,\\&\\, a_k)+(a_{k+1} \\,\\&\\, a_{k+2} \\,\\&\\, \\cdots \\,\\&\\, a_n))\n$$\n\nwhere $\\&$ is the bitwise-and operator.\n\nYou can perform the swapping operation at most once: choose two indices $i$ and $j$ such that $1\\leq i < j\\leq n$ and then swap the values of $a_i$ and $a_j$.\n\nCalculate the maximum possible value of $F(A)$ after performing at most one swapping operation.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($2\\leq n\\leq 10^5$) indicating the length of sequence $A$.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($0\\leq a_i\\leq 10^9$) indicating the given sequence $A$.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $10^5$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum possible value of $F(A)$ after performing at most one swapping operation.", "hint": "For the first sample test case, we can swap $a_4$ and $a_6$ so the sequence becomes $\\{6, 5, 4, 6, 5, 3\\}$. We can then choose $k = 5$ so that $F(A) = (6 \\,\\&\\, 5 \\,\\&\\, 4 \\,\\&\\, 6 \\,\\&\\, 5) + (3) = 7$.\n\nFor the second sample test case, we can swap $a_2$ and $a_4$ so the sequence becomes $\\{1, 1, 1, 2, 2, 2\\}$. We can then choose $k = 3$ so that $F(A) = (1 \\,\\&\\, 1 \\,\\&\\, 1) + (2 \\,\\&\\, 2 \\,\\&\\, 2) = 3$.\n\nFor the third sample test case we do not perform the swapping operation. We can then choose $k = 2$ so that $F(A) = (1 \\,\\&\\, 1) + (2 \\,\\&\\, 2 \\,\\&\\, 2) = 3$.", "locale": "en", "translations": {"en": {"title": "[GDCPC 2023] Swapping Operation", "background": "", "description": "Given a non-negative integer sequence $A = a_1, a_2, \\dots, a_n$ of length $n$, define\n\n$$\nF(A)=\\max\\limits_{1\\leq k<n} ((a_1 \\,\\&\\, a_2 \\,\\&\\, \\cdots \\,\\&\\, a_k)+(a_{k+1} \\,\\&\\, a_{k+2} \\,\\&\\, \\cdots \\,\\&\\, a_n))\n$$\n\nwhere $\\&$ is the bitwise-and operator.\n\nYou can perform the swapping operation at most once: choose two indices $i$ and $j$ such that $1\\leq i < j\\leq n$ and then swap the values of $a_i$ and $a_j$.\n\nCalculate the maximum possible value of $F(A)$ after performing at most one swapping operation.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($2\\leq n\\leq 10^5$) indicating the length of sequence $A$.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($0\\leq a_i\\leq 10^9$) indicating the given sequence $A$.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $10^5$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum possible value of $F(A)$ after performing at most one swapping operation.", "hint": "For the first sample test case, we can swap $a_4$ and $a_6$ so the sequence becomes $\\{6, 5, 4, 6, 5, 3\\}$. We can then choose $k = 5$ so that $F(A) = (6 \\,\\&\\, 5 \\,\\&\\, 4 \\,\\&\\, 6 \\,\\&\\, 5) + (3) = 7$.\n\nFor the second sample test case, we can swap $a_2$ and $a_4$ so the sequence becomes $\\{1, 1, 1, 2, 2, 2\\}$. We can then choose $k = 3$ so that $F(A) = (1 \\,\\&\\, 1 \\,\\&\\, 1) + (2 \\,\\&\\, 2 \\,\\&\\, 2) = 3$.\n\nFor the third sample test case we do not perform the swapping operation. We can then choose $k = 2$ so that $F(A) = (1 \\,\\&\\, 1) + (2 \\,\\&\\, 2 \\,\\&\\, 2) = 3$.", "locale": "en"}, "zh-CN": {"title": "[GDCPC 2023] Swapping Operation", "background": "", "description": "给定长度为 $n$ 的非负整数序列 $A = a_1, a_2, \\dots, a_n$，定义\n\n$$\nF(A)=\\max\\limits_{1\\leq k<n} ((a_1 \\,\\&\\, a_2 \\,\\&\\, \\cdots \\,\\&\\, a_k)+(a_{k+1} \\,\\&\\, a_{k+2} \\,\\&\\, \\cdots \\,\\&\\, a_n))\n$$\n\n其中 $\\&$ 表示按位与操作。\n\n您可以进行至多一次交换操作：选择两个下标 $i$ 和 $j$ 满足 $1\\leq i < j\\leq n$，交换 $a_i$ 与 $a_j$ 的值。\n\n求经过至多一次交换后，$F(A)$ 的最大值。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：\n\n第一行输入一个整数 $n$（$2\\leq n\\leq 10^5$)，表示序列 $A$ 的长度。\n\n第二行输入 $n$ 个整数 $a_1, a_2, \\cdots, a_n$（$0\\leq a_i\\leq 10^9$)，表示给定的序列 $A$。\n\n保证所有数据 $n$ 之和不超过 $10^5$。", "outputFormat": "每组数据输出一行一个整数，表示经过至多一次交换后 $F(A)$ 的最大值。\n\n**【样例解释】**\n\n对于第一组样例数据，可以交换 $a_4$ 和 $a_6$ 将序列变为 $\\{6, 5, 4, 6, 5, 3\\}$，然后选择 $k = 5$，就得到了 $F(A) = (6 \\,\\&\\, 5 \\,\\&\\, 4 \\,\\&\\, 6 \\,\\&\\, 5) + (3) = 7$。\n\n对于第二组样例数据，可以交换 $a_2$ 和 $a_4$ 将序列变为 $\\{1, 1, 1, 2, 2, 2\\}$，然后选择 $k = 3$，就得到了 $F(A) = (1 \\,\\&\\, 1 \\,\\&\\, 1) + (2 \\,\\&\\, 2 \\,\\&\\, 2) = 3$。\n\n对于第三组样例数据，不进行交换操作，然后选择 $k = 2$，就得到了 $F(A) = (1 \\,\\&\\, 1) + (2 \\,\\&\\, 2 \\,\\&\\, 2) = 3$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9697", "type": "P", "difficulty": 6, "samples": [["2\n4 4\n1 1 2 2\n3 2 4 1\n1 2 3 2\n2 1 4 1\n4 2\n3 2 4 1\n1 2 3 1", "7\n4 1 3 2\n5\n2 1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["图论", "2023", "广东", "Special Judge", "O2优化", "图论建模", "强连通分量", "省赛/邀请赛"], "title": "[GDCPC 2023] Canvas", "background": "", "description": "There is a sequence of length $n$. At the beginning, all elements in the sequence equal to $0$. There are also $m$ operations, where the $i$-th operation will change the value of the $l_i$-th element in the sequence to $x_i$, and also change the value of the $r_i$-th element in the sequence to $y_i$. Each operation must be performed exactly once.\n\nFind the optimal order to perform the operations, so that after all operations, the sum of all elements in the sequence is maximized.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($2 \\leq n, m \\leq 5 \\times 10^5$) indicating the length of the sequence and the number of operations.\n\nFor the following $m$ lines, the $i$-th line contains four integers $l_i$, $x_i$, $r_i$ and $y_i$ ($1 \\leq l_i<r_i \\leq n$, $1 \\leq x_i,y_i \\leq 2$) indicating the $i$-th operation.\n\nIt's guaranteed that neither the sum of $n$ nor the sum of $m$ of all test cases will exceed $5 \\times 10^5$.", "outputFormat": "For each test case, first output one line containing one integer, indicating the maximum sum of all elements in the sequence after all operations. Then output another line containing $m$ integers $a_1, a_2, \\cdots, a_m$ separated by a space, indicating the optimal order to perform the operations, where $a_i$ is the index of the $i$-th operation to be performed. Each integer from $1$ to $m$ (both inclusive) must appear exactly once. If there are multiple valid answers, you can output any of them.", "hint": "For the first sample test case, after performing operations $4, 1, 3, 2$ in order, the sequence becomes $\\{2, 2, 2, 1\\}$. The sum of all elements is $7$.\n\nFor the second sample test case, after performing operations $2, 1$ in order, the sequence becomes $\\{2, 0, 2, 1\\}$. The sum of all elements is $5$.", "locale": "en", "translations": {"en": {"title": "[GDCPC 2023] Canvas", "background": "", "description": "There is a sequence of length $n$. At the beginning, all elements in the sequence equal to $0$. There are also $m$ operations, where the $i$-th operation will change the value of the $l_i$-th element in the sequence to $x_i$, and also change the value of the $r_i$-th element in the sequence to $y_i$. Each operation must be performed exactly once.\n\nFind the optimal order to perform the operations, so that after all operations, the sum of all elements in the sequence is maximized.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($2 \\leq n, m \\leq 5 \\times 10^5$) indicating the length of the sequence and the number of operations.\n\nFor the following $m$ lines, the $i$-th line contains four integers $l_i$, $x_i$, $r_i$ and $y_i$ ($1 \\leq l_i<r_i \\leq n$, $1 \\leq x_i,y_i \\leq 2$) indicating the $i$-th operation.\n\nIt's guaranteed that neither the sum of $n$ nor the sum of $m$ of all test cases will exceed $5 \\times 10^5$.", "outputFormat": "For each test case, first output one line containing one integer, indicating the maximum sum of all elements in the sequence after all operations. Then output another line containing $m$ integers $a_1, a_2, \\cdots, a_m$ separated by a space, indicating the optimal order to perform the operations, where $a_i$ is the index of the $i$-th operation to be performed. Each integer from $1$ to $m$ (both inclusive) must appear exactly once. If there are multiple valid answers, you can output any of them.", "hint": "For the first sample test case, after performing operations $4, 1, 3, 2$ in order, the sequence becomes $\\{2, 2, 2, 1\\}$. The sum of all elements is $7$.\n\nFor the second sample test case, after performing operations $2, 1$ in order, the sequence becomes $\\{2, 0, 2, 1\\}$. The sum of all elements is $5$.", "locale": "en"}, "zh-CN": {"title": "[GDCPC 2023] Canvas", "background": "", "description": "有一个长度为 $n$ 的序列，一开始序列中的所有元素均为 $0$。另外还有 $m$ 个操作，其中第 $i$ 个操作会将序列中第 $l_i$ 个元素的值改为 $x_i$，以及将序列中第 $r_i$ 个元素的值改为 $y_i$。每个操作必须恰好执行一次。\n\n求执行操作的最优顺序，使得所有操作执行完成后，序列中所有元素之和最大。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：\n\n第一行输入两个整数 $n$ 和 $m$（$2 \\leq n, m \\leq 5 \\times 10^5$）表示序列的长度和操作的个数。\n\n对于接下来 $m$ 行，第 $i$ 行输入四个整数 $l_i$，$x_i$，$r_i$ 和 $y_i$（$1 \\leq l_i<r_i \\leq n$，$1 \\leq x_i,y_i \\leq 2$）表示第 $i$ 个操作。\n\n保证所有数据 $n$ 之和与 $m$ 之和均不超过 $5 \\times 10^5$。", "outputFormat": "每组数据首先输出一行一个整数，表示执行操作后，所有元素的最大和。接下来输出一行 $m$ 个由单个空格分隔的整数 $a_1, a_2, \\cdots, a_m$ 表示执行操作的最优顺序，其中 $a_i$ 表示第 $i$ 次执行的操作的编号。从 $1$ 到 $m$ 的每个整数（含两端）必须恰好出现一次。若有多种合法答案，您可以输出任意一种。\n\n**【样例解释】**\n\n对于第一组样例数据，按 $4, 1, 3, 2$ 的顺序执行操作后，序列变为 $\\{2, 2, 2, 1\\}$，元素之和为 $7$。\n\n对于第二组样例数据，按 $2, 1$ 的顺序执行操作后，序列变为 $\\{2, 0, 2, 1\\}$，元素之和为 $5$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9698", "type": "P", "difficulty": 3, "samples": [["2\n2 3\n1 2 4\n3 0 5\n1 5\n1 3 0 4 2", "3\n5"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["二分", "2023", "广东", "O2优化", "省赛/邀请赛"], "title": "[GDCPC 2023] Path Planning", "background": "", "description": "There is a grid with $n$ rows and $m$ columns. Each cell of the grid has an integer in it, where $a_{i, j}$ indicates the integer in the cell located at the $i$-th row and the $j$-th column. Each integer from $0$ to $(n \\times m - 1)$ (both inclusive) appears exactly once in the grid.\n\nLet $(i, j)$ be the cell located at the $i$-th row and the $j$-th column. You now start from $(1, 1)$ and need to reach $(n, m)$. When you are in cell $(i, j)$, you can either move to its right cell $(i, j + 1)$ if $j < m$ or move to its bottom cell $(i + 1, j)$ if $i < n$.\n\nLet $\\mathbb{S}$ be the set consisting of integers in each cell on your path, including $a_{1, 1}$ and $a_{n, m}$. Let $\\text{mex}(\\mathbb{S})$ be the smallest non-negative integer which does not belong to $\\mathbb{S}$. Find a path to maximize $\\text{mex}(\\mathbb{S})$ and calculate this maximum possible value.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n, m \\le 10^6$, $1 \\le n \\times m \\le 10^6$) indicating the number of rows and columns of the grid.\n\nFor the following $n$ lines, the $i$-th line contains $m$ integers $a_{i, 1}, a_{i, 2}, \\cdots, a_{i, m}$ ($0 \\le a_{i, j} < n \\times m$) where $a_{i, j}$ indicates the integer in cell $(i, j)$. Each integer from $0$ to $(n \\times m - 1)$ (both inclusive) appears exactly once in the grid.\n\nIt's guaranteed that the sum of $n \\times m$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum possible value of $\\text{mex}(\\mathbb{S})$.", "hint": "For the first sample test case there are $3$ possible paths.\n\n- The first path is $(1, 1) \\to (1, 2) \\to (1, 3) \\to (2, 3)$. $\\mathbb{S} = \\{1, 2, 4, 5\\}$ so $\\text{mex}(\\mathbb{S}) = 0$.\n- The second path is $(1, 1) \\to (1, 2) \\to (2, 2) \\to (2, 3)$. $\\mathbb{S} = \\{1, 2, 0, 5\\}$ so $\\text{mex}(\\mathbb{S}) = 3$.\n- The third path is $(1, 1) \\to (2, 1) \\to (2, 2) \\to (2, 3)$. $\\mathbb{S} = \\{1, 3, 0, 5\\}$ so $\\text{mex}(\\mathbb{S}) = 2$.\n\nSo the answer is $3$.\n\nFor the second sample test case there is only $1$ possible path, which is $(1, 1) \\to (1, 2) \\to (1, 3) \\to (1, 4) \\to (1, 5)$. $\\mathbb{S} = \\{1, 3, 0, 4, 2\\}$ so $\\text{mex}(\\mathbb{S}) = 5$.", "locale": "en", "translations": {"en": {"title": "[GDCPC 2023] Path Planning", "background": "", "description": "There is a grid with $n$ rows and $m$ columns. Each cell of the grid has an integer in it, where $a_{i, j}$ indicates the integer in the cell located at the $i$-th row and the $j$-th column. Each integer from $0$ to $(n \\times m - 1)$ (both inclusive) appears exactly once in the grid.\n\nLet $(i, j)$ be the cell located at the $i$-th row and the $j$-th column. You now start from $(1, 1)$ and need to reach $(n, m)$. When you are in cell $(i, j)$, you can either move to its right cell $(i, j + 1)$ if $j < m$ or move to its bottom cell $(i + 1, j)$ if $i < n$.\n\nLet $\\mathbb{S}$ be the set consisting of integers in each cell on your path, including $a_{1, 1}$ and $a_{n, m}$. Let $\\text{mex}(\\mathbb{S})$ be the smallest non-negative integer which does not belong to $\\mathbb{S}$. Find a path to maximize $\\text{mex}(\\mathbb{S})$ and calculate this maximum possible value.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n, m \\le 10^6$, $1 \\le n \\times m \\le 10^6$) indicating the number of rows and columns of the grid.\n\nFor the following $n$ lines, the $i$-th line contains $m$ integers $a_{i, 1}, a_{i, 2}, \\cdots, a_{i, m}$ ($0 \\le a_{i, j} < n \\times m$) where $a_{i, j}$ indicates the integer in cell $(i, j)$. Each integer from $0$ to $(n \\times m - 1)$ (both inclusive) appears exactly once in the grid.\n\nIt's guaranteed that the sum of $n \\times m$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum possible value of $\\text{mex}(\\mathbb{S})$.", "hint": "For the first sample test case there are $3$ possible paths.\n\n- The first path is $(1, 1) \\to (1, 2) \\to (1, 3) \\to (2, 3)$. $\\mathbb{S} = \\{1, 2, 4, 5\\}$ so $\\text{mex}(\\mathbb{S}) = 0$.\n- The second path is $(1, 1) \\to (1, 2) \\to (2, 2) \\to (2, 3)$. $\\mathbb{S} = \\{1, 2, 0, 5\\}$ so $\\text{mex}(\\mathbb{S}) = 3$.\n- The third path is $(1, 1) \\to (2, 1) \\to (2, 2) \\to (2, 3)$. $\\mathbb{S} = \\{1, 3, 0, 5\\}$ so $\\text{mex}(\\mathbb{S}) = 2$.\n\nSo the answer is $3$.\n\nFor the second sample test case there is only $1$ possible path, which is $(1, 1) \\to (1, 2) \\to (1, 3) \\to (1, 4) \\to (1, 5)$. $\\mathbb{S} = \\{1, 3, 0, 4, 2\\}$ so $\\text{mex}(\\mathbb{S}) = 5$.", "locale": "en"}, "zh-CN": {"title": "[GDCPC 2023] Path Planning", "background": "", "description": "有一个 $n$ 行 $m$ 列的网格。网格里的每个格子都写着一个整数，其中第 $i$ 行第 $j$ 列的格子里写着整数 $a_{i, j}$。从 $0$ 到 $(n \\times m - 1)$ 的每个整数（含两端）在网格里都恰好出现一次。\n\n令 $(i, j)$ 表示位于第 $i$ 行第 $j$ 列的格子。您现在需要从 $(1, 1)$ 出发并前往 $(n, m)$。当您位于格子 $(i, j)$ 时，您可以选择走到右方的格子 $(i, j + 1)$（若 $j < m$），也可以选择走到下方的格子 $(i + 1, j)$（若 $i < n$）。\n\n令 $\\mathbb{S}$ 表示路径上每个格子里的整数形成的集合，包括 $a_{1, 1}$ 和 $a_{n, m}$。令 $\\text{mex}(\\mathbb{S})$ 表示不属于 $\\mathbb{S}$ 的最小非负整数。请找出一条路径以最大化 $\\text{mex}(\\mathbb{S})$，并求出这个最大的值。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：\n\n第一行输入两个整数 $n$ 和 $m$（$1 \\le n, m \\le 10^6$，$1 \\le n \\times m \\le 10^6$）表示网格的行数和列数。\n\n对于接下来 $n$ 行，第 $i$ 行输入 $m$ 个整数 $a_{i, 1}, a_{i, 2}, \\cdots, a_{i, m}$（$0 \\le a_{i, j} < n \\times m$），其中 $a_{i, j}$ 表示格子 $(i, j)$ 里的整数。从 $0$ 到 $(n \\times m - 1)$ 的每个整数（含两端）在网格里都恰好出现一次。\n\n保证所有数据 $n \\times m$ 之和不超过 $10^6$。", "outputFormat": "每组数据输出一行一个整数，表示最大的 $\\text{mex}(\\mathbb{S})$。\n\n**【样例解释】**\n\n对于第一组样例数据，共有 $3$ 条可能的路径。\n\n- 第一条路径为 $(1, 1) \\to (1, 2) \\to (1, 3) \\to (2, 3)$。$\\mathbb{S} = \\{1, 2, 4, 5\\}$ 因此 $\\text{mex}(\\mathbb{S}) = 0$。\n- 第二条路径为 $(1, 1) \\to (1, 2) \\to (2, 2) \\to (2, 3)$。$\\mathbb{S} = \\{1, 2, 0, 5\\}$ 因此 $\\text{mex}(\\mathbb{S}) = 3$。\n- 第三条路径为 $(1, 1) \\to (2, 1) \\to (2, 2) \\to (2, 3)$。$\\mathbb{S} = \\{1, 3, 0, 5\\}$ 因此 $\\text{mex}(\\mathbb{S}) = 2$。\n\n因此答案为 $3$。\n\n对于第二组样例数据，只有 $1$ 条可能的路径，即 $(1, 1) \\to (1, 2) \\to (1, 3) \\to (1, 4) \\to (1, 5)$。$\\mathbb{S} = \\{1, 3, 0, 4, 2\\}$ 因此 $\\text{mex}(\\mathbb{S}) = 5$。", "hint": "", "locale": "zh-CN"}}}
