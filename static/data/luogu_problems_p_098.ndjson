{"pid": "P2988", "type": "P", "difficulty": 3, "samples": [["6 2 \n0 \n3 \n", "3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO"], "title": "[USACO10MAR] Test Taking S", "background": "", "description": "Farmer John has to take his annual farming license test. The test comprises N (1 <= N <= 1,000,000) true/false questions. After FJ's dismal performance on last year's test Bessie wishes to help him.\n\nBessie has inside information that the number of questions whose answer is true will be one of t\\_1, t\\_2, t\\_3,..., or t\\_K (0 <= t\\_i <= N; 0 <= K <= 10,000) -- even though Bessie has no information about any answer to any specific question. Bessie wants to know the best score that FJ is guaranteed achieve by exploiting this information carefully, even if he doesn't know the actual answers to any test questions.\n\nTo demonstrate Bessie's idea, consider a license test with N=6 questions where Bessie knows that the number of questions with the answer 'true' is either 0 or 3. FJ can always get at least 3 answers correct using logic like this: If FJ answers 'false' on every\n\nquestion and there are 0 questions with the answer 'true' then he will get all 6 correct. If there are 3 questions with the answer 'true' then he will get 3 answers correct. So as long as he marks every answer as 'false' he is guaranteed to get at least 3 correct without knowing any answer to the test questions.\n\nOn the other hand, consider what happens if FJ chooses an inferior strategy: he guesses that some 3 answers are 'true' and the other 3 are 'false'. If it turns out that NO answers are 'true' then FJ will get 3 answers correct, the ones he guessed were false. If 3 answers are 'true' then FJ could get as few as 0 answers correct. If he answered incorrectly on all 3 of that answers for which he guessed 'true', and the other 3 (for which he guessed 'false') are true, then he gets 0 correct answers. Even though FJ could get 3 correct in this case by guessing 'false' every time, he can not always guarantee even 1 correct by guessing some 3 answers as 'true', so this strategy can not guarantee getting any answer correct. FJ should use the previous paragraph's strategy.\n\nGiven Bessie's inside information, determine the number of answers FJ can always get correct using this information assuming he uses it optimally.\n\n\nFarmer John要参加一年一度的农民资格考试。考试很简单，只有N个 （1≤N≤1，000，000)true/false的判断题。然而FJ去年考试却“杯具”了，Bessie：希望今年能帮帮他。\n\n\nBessie得到可靠的内部消息，有可能有T\\_1，T\\_2，T\\_3，...，或T\\_K(0≤T\\_i≤N；0≤K≤10，000)\n\n\n道题的答案为ture：，但具体哪道题的答案是什么却不知道。Bessie希望知道在认真研究了这些内部消息后(虽然不能确定任何一道题的具体答案)，一定保证FJ考试时能获得的最高分数是多少?\n\n\n为了说明Bessie的想法，考虑N=6的一次考试，Bessie知道答案为true的题的数量是0或者3。FJ可以按这样的做题策略来答对至少3题：如果FJ全部答'false'，那么当有0道题的正确答案是'true'，则FJ答对6题；而当有3道题的正确答案是'true'，则FJ答对3题。因此，只要FJ部答'false'，那么至少一定能答对3题，尽管FJ并不知道每道题的确切答案。\n\n\n另一方面，考虑如果FJ选择了另一种非最优的做题策略：他猜测某3道题为'true'而另3道题为'false'。当所有题目的正确答案是'false'时，那么FJ能答对3道题。而当有3道题的正确答案是'true'时，那么FJ有可能一道题都答不对。这是因为FJ有可能把3道正确答案为'true'的题全猜成'false'!这说明这种做题策略不如前一种优秀。\n\n给出Bessie获得的内部消息，计算出FJ采用最优做题策略保证能得到的最高分数是多少?\n\n第1行：2个整数N，K\n\n第2…K+1行：第i+1行包含一个整数t_i\n\n第1行：一个整数，表示FJ一定能获得的最高分数", "inputFormat": "\\* Line 1: Two space-separated integers: N and K\n\n\\* Lines 2..K+1: Line i+1 contains a single integer: t\\_i\n\n第1行：2个整数N，K\n\n\n第2…K+1行：第i+1行包含一个整数t\\_i\n\n\n第1行：一个整数，表示FJ一定能获得的最高分数\n", "outputFormat": "\\* Line 1: A single integer, the best score FJ is guaranteed to achieve\n", "hint": "翻译提供： @fan404\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10MAR] Test Taking S", "background": "", "description": "Farmer John has to take his annual farming license test. The test has $N$ ($1 \\le N \\le 1{,}000{,}000$) true/false questions. After last year's poor performance, Bessie wants to help him.\n\nBessie knows that the number of questions whose answer is 'true' is one of $t_1, t_2, \\dots, t_K$ ($0 \\le t_i \\le N$; $0 \\le K \\le 10{,}000$). She has no information about which particular questions are true. Using only this information, she wants to know the best score Farmer John can always guarantee, even without knowing any individual answers.\n\nExample: For $N = 6$ and possible counts $\\{0, 3\\}$, if FJ answers 'false' on every question, then if the true count is $0$ he gets $6$ correct, and if it is $3$ he gets $3$ correct. So he can guarantee at least $3$ correct.\n\nBy contrast, if FJ answers 'true' on exactly $3$ questions and 'false' on the other $3$, then if the true count is $0$ he gets $3$ correct, but if the true count is $3$ he could get as few as $0$ correct (if he guessed 'true' on the $3$ that are actually 'false'). So this strategy does not guarantee any correct answers.\n\nGiven Bessie's information, compute the maximum number of answers FJ can always get correct if he uses an optimal strategy.\n\nConstraints: $1 \\le N \\le 1{,}000{,}000$, $0 \\le K \\le 10{,}000$, $0 \\le t_i \\le N$.", "inputFormat": "- Line 1: Two space-separated integers $N$ and $K$.\n- Lines $2..K+1$: Line $i+1$ contains a single integer $t_i$.", "outputFormat": "- Line 1: A single integer, the best score FJ is guaranteed to achieve.", "hint": "Translation provided by @fan404.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO10MAR] Test Taking S", "background": "", "description": "Farmer John has to take his annual farming license test. The test comprises N (1 <= N <= 1,000,000) true/false questions. After FJ's dismal performance on last year's test Bessie wishes to help him.\n\nBessie has inside information that the number of questions whose answer is true will be one of t\\_1, t\\_2, t\\_3,..., or t\\_K (0 <= t\\_i <= N; 0 <= K <= 10,000) -- even though Bessie has no information about any answer to any specific question. Bessie wants to know the best score that FJ is guaranteed achieve by exploiting this information carefully, even if he doesn't know the actual answers to any test questions.\n\nTo demonstrate Bessie's idea, consider a license test with N=6 questions where Bessie knows that the number of questions with the answer 'true' is either 0 or 3. FJ can always get at least 3 answers correct using logic like this: If FJ answers 'false' on every\n\nquestion and there are 0 questions with the answer 'true' then he will get all 6 correct. If there are 3 questions with the answer 'true' then he will get 3 answers correct. So as long as he marks every answer as 'false' he is guaranteed to get at least 3 correct without knowing any answer to the test questions.\n\nOn the other hand, consider what happens if FJ chooses an inferior strategy: he guesses that some 3 answers are 'true' and the other 3 are 'false'. If it turns out that NO answers are 'true' then FJ will get 3 answers correct, the ones he guessed were false. If 3 answers are 'true' then FJ could get as few as 0 answers correct. If he answered incorrectly on all 3 of that answers for which he guessed 'true', and the other 3 (for which he guessed 'false') are true, then he gets 0 correct answers. Even though FJ could get 3 correct in this case by guessing 'false' every time, he can not always guarantee even 1 correct by guessing some 3 answers as 'true', so this strategy can not guarantee getting any answer correct. FJ should use the previous paragraph's strategy.\n\nGiven Bessie's inside information, determine the number of answers FJ can always get correct using this information assuming he uses it optimally.\n\n\nFarmer John要参加一年一度的农民资格考试。考试很简单，只有N个 （1≤N≤1，000，000)true/false的判断题。然而FJ去年考试却“杯具”了，Bessie：希望今年能帮帮他。\n\n\nBessie得到可靠的内部消息，有可能有T\\_1，T\\_2，T\\_3，...，或T\\_K(0≤T\\_i≤N；0≤K≤10，000)\n\n\n道题的答案为ture：，但具体哪道题的答案是什么却不知道。Bessie希望知道在认真研究了这些内部消息后(虽然不能确定任何一道题的具体答案)，一定保证FJ考试时能获得的最高分数是多少?\n\n\n为了说明Bessie的想法，考虑N=6的一次考试，Bessie知道答案为true的题的数量是0或者3。FJ可以按这样的做题策略来答对至少3题：如果FJ全部答'false'，那么当有0道题的正确答案是'true'，则FJ答对6题；而当有3道题的正确答案是'true'，则FJ答对3题。因此，只要FJ部答'false'，那么至少一定能答对3题，尽管FJ并不知道每道题的确切答案。\n\n\n另一方面，考虑如果FJ选择了另一种非最优的做题策略：他猜测某3道题为'true'而另3道题为'false'。当所有题目的正确答案是'false'时，那么FJ能答对3道题。而当有3道题的正确答案是'true'时，那么FJ有可能一道题都答不对。这是因为FJ有可能把3道正确答案为'true'的题全猜成'false'!这说明这种做题策略不如前一种优秀。\n\n给出Bessie获得的内部消息，计算出FJ采用最优做题策略保证能得到的最高分数是多少?\n\n第1行：2个整数N，K\n\n第2…K+1行：第i+1行包含一个整数t_i\n\n第1行：一个整数，表示FJ一定能获得的最高分数", "inputFormat": "\\* Line 1: Two space-separated integers: N and K\n\n\\* Lines 2..K+1: Line i+1 contains a single integer: t\\_i\n\n第1行：2个整数N，K\n\n\n第2…K+1行：第i+1行包含一个整数t\\_i\n\n\n第1行：一个整数，表示FJ一定能获得的最高分数\n", "outputFormat": "\\* Line 1: A single integer, the best score FJ is guaranteed to achieve\n", "hint": "翻译提供： @fan404\n", "locale": "zh-CN"}}}
{"pid": "P2989", "type": "P", "difficulty": 3, "samples": [["1500 100 4 \n250 25 \n150 9 \n120 5 \n200 8 \n", "2 \n3 \n4 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO"], "title": "[USACO10MAR] Need For Speed S", "background": "", "description": "Bessie is preparing her race car for the upcoming Grand Prix, but she wants to buy some extra parts to improve the car's performance. Her race car currently has mass M (1 <= M <= 1,000) and is able to push itself forward with a force of F (1 <= F <= 1,000,000). The Race Car Performance Store has N (1 <= N <= 10,000) parts\n\nconveniently numbered 1..N. Bessie can buy as many or as few parts as she wishes though the store stocks no more than one instance of each part.\n\nPart P\\_i adds force F\\_i (1 <= F\\_i <= 1,000,000) and has mass\n\nM\\_i (1 <= M\\_i <= 1,000). Newton's Second Law decrees that F =\n\nMA, where F is force, M is mass, and A is acceleration. If Bessie wants to maximize the total acceleration of her race car (and\n\nminimize the mass otherwise), which extra parts should she choose?\n\nConsider a race car with initial F=1500 and M=100. Four parts are available for enhancement:\n\ni  F\\_i  M\\_i\n\n1  250   25\n\n2  150    9\n\n3  120    5\n\n4  200    8\n\nAdding just part 2, e.g., would result in an acceleration of\n\n(1500+150)/(100+9) = 1650/109 = 15.13761. \n\nBelow is a chart of showing the acceleration for all possible \n\ncombinations of adding/not-adding the four parts (in column one, 1=part added, 0=part not added): \n\nParts   Aggregate   Aggregate\n\n1234        F           M       F/M\n\n0000      1500         100    15.0000\n\n0001      1700         108    15.7407\n\n0010      1620         105    15.4286\n\n0011      1820         113    16.1062\n\n0100      1650         109    15.1376\n\n0101      1850         117    15.8120\n\n0110      1770         114    15.5263\n\n0111      1970         122    16.1475 <-- highest F/M \n\n1000      1750         125    14.0000\n\n1001      1950         133    14.6617\n\n1010      1870         130    14.3846\n\n1011      2070         138    15.0000\n\n1100      1900         134    14.1791\n\n1101      2100         142    14.7887\n\n1110      2020         139    14.5324\n\n1111      2220         147    15.1020\n\nThus, the best additional part combination is parts 2, 3, and 4.\n", "inputFormat": "\\* Line 1: Three space-separated integers: F, M, and N\n\n\\* Lines 2..N+1: Line i+1 contains two space separated integers: F\\_i and M\\_i\n", "outputFormat": "\\* Lines 1..P: The index values of P extra parts, one per line, that Bessie should add to her racecar. If she should not add any, output 'NONE' (without quotes). The output should be given in increasing order, so if the optimal set of parts is {2,4,6,7}, then the output should be in the order 2,4,6,7 and not, for example, 4,2,7,6. Solutions will be unique.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO10MAR] Need For Speed S", "background": "", "description": "Bessie is preparing her race car for the upcoming Grand Prix, but she wants to buy some extra parts to improve the car's performance. Her race car currently has mass M (1 <= M <= 1,000) and is able to push itself forward with a force of F (1 <= F <= 1,000,000). The Race Car Performance Store has N (1 <= N <= 10,000) parts\n\nconveniently numbered 1..N. Bessie can buy as many or as few parts as she wishes though the store stocks no more than one instance of each part.\n\nPart P\\_i adds force F\\_i (1 <= F\\_i <= 1,000,000) and has mass\n\nM\\_i (1 <= M\\_i <= 1,000). Newton's Second Law decrees that F =\n\nMA, where F is force, M is mass, and A is acceleration. If Bessie wants to maximize the total acceleration of her race car (and\n\nminimize the mass otherwise), which extra parts should she choose?\n\nConsider a race car with initial F=1500 and M=100. Four parts are available for enhancement:\n\ni  F\\_i  M\\_i\n\n1  250   25\n\n2  150    9\n\n3  120    5\n\n4  200    8\n\nAdding just part 2, e.g., would result in an acceleration of\n\n(1500+150)/(100+9) = 1650/109 = 15.13761. \n\nBelow is a chart of showing the acceleration for all possible \n\ncombinations of adding/not-adding the four parts (in column one, 1=part added, 0=part not added): \n\nParts   Aggregate   Aggregate\n\n1234        F           M       F/M\n\n0000      1500         100    15.0000\n\n0001      1700         108    15.7407\n\n0010      1620         105    15.4286\n\n0011      1820         113    16.1062\n\n0100      1650         109    15.1376\n\n0101      1850         117    15.8120\n\n0110      1770         114    15.5263\n\n0111      1970         122    16.1475 <-- highest F/M \n\n1000      1750         125    14.0000\n\n1001      1950         133    14.6617\n\n1010      1870         130    14.3846\n\n1011      2070         138    15.0000\n\n1100      1900         134    14.1791\n\n1101      2100         142    14.7887\n\n1110      2020         139    14.5324\n\n1111      2220         147    15.1020\n\nThus, the best additional part combination is parts 2, 3, and 4.\n", "inputFormat": "\\* Line 1: Three space-separated integers: F, M, and N\n\n\\* Lines 2..N+1: Line i+1 contains two space separated integers: F\\_i and M\\_i\n", "outputFormat": "\\* Lines 1..P: The index values of P extra parts, one per line, that Bessie should add to her racecar. If she should not add any, output 'NONE' (without quotes). The output should be given in increasing order, so if the optimal set of parts is {2,4,6,7}, then the output should be in the order 2,4,6,7 and not, for example, 4,2,7,6. Solutions will be unique.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO10MAR] Need For Speed S", "background": "", "description": "Bessie 正在为即将到来的赛车比赛作准备。\n\n她有一辆赛车，质量为 $M$，且可以提供 $F$ 的力。现在她想要给这辆赛车安装一些零件（总共有 $N$ 个零件），每个零件具有属性 $M_i$ 和 $F_i$，表示其质量以及可以提供的力。\n\n设 $X_i = 1$ 或 $0$，表示第 $i$ 个零件选或不选。在最大化\n\n$$\\dfrac{F+\\sum_{i=1}^{n}X_i \\cdot F_i}{M+\\sum_{i=1}^{n}X_i \\cdot M_i}$$\n\n\n的前提下最小化\n\n$$\\sum_{i=1}^{n}X_i \\cdot M_i + M.$$", "inputFormat": "第一行是三个用空格分开的正整数 $F,\\,M,\\,N$。\n\n接下来 $N$ 行，每行两个用空格分开的正整数，第 $i+1$ 行的两个数代表 $F_i$ 和 $M_i$。", "outputFormat": "输出包含 $P$ 行，表示 Bessie 需要安装的 $P$ 个零件的下标。若 Bessie 不需要给这辆车安装零件，输出 `NONE`。\n\n输出应按递增顺序给出，如果最佳零件集为 $\\{2,4,6,7\\}$，则输出应按 $2,4,6,7$ 的顺序，而不是 $4,2,7,6$ 的顺序。解决方案将是唯一的。", "hint": "#### 数据范围\n\n$1 \\le N \\le 10\\,000$；\n\n$1 \\le M,M_i\\le1\\,000$；\n\n$1 \\le F,F_i \\le 1\\,000\\,000$。\n\n\n感谢 @tyqtyq 提供的翻译。", "locale": "zh-CN"}}}
{"pid": "P2990", "type": "P", "difficulty": 5, "samples": [["6 3 \n0 \n1 \n2 \n-3 \n4 \n5 \n", "12 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO"], "title": "[USACO10OPEN] Cow Hopscotch G", "background": null, "description": "奶牛们正在回味童年，玩一个类似跳格子的游戏，在这个游戏里，奶牛们在草地上画了一行 $N$ 个格子，编号为 $1\\dots N$。\n\n就像任何一个好游戏一样，这样的跳格子游戏也有奖励！第 $i$ 个格子标有一个数字 $v_i$ 表示这个格子的钱。奶牛们想看看最后谁能得到最多的钱。\n\n规则很简单：\n\n* 每个奶牛从 $0$ 号格子出发。($0$ 号格子在 $1$ 号之前，那里没钱)\n\n* 然后她执行一个可能为空的跳跃序列前往格子 $N$。她每次落地所在的格子距离前一个格子最多 $K$ 个格子（例如，如果 $K=2$，从格子 $1$ 出发，她最多可以跳到格子 $2$ 或 $3$）。\n\n* 在任何时候，她都可以选择回头往 $0$ 号格子跳，直到跳到 $0$ 号格子。\n\n另外，除了以上规则之外（包括 $K$ 限制），回头跳的时候还有两条规则：\n\n* 不可以跳到前进序列中的格子（格子 $0$ 除外）。\n\n* 除了 $0$ 号格子之外，她在回来的时候，停留的格子必须是恰巧过去的时候停留的某个格子的前一格（尽管她可能在返回时做一些更大的跳跃，从而跳过一些潜在的返回格子）。\n\n她赚取的金钱数量等于她跳过的所有格子的金钱价值之和。请找出奶牛能赚到的最大金额。\n\n举例说明，考虑一个有六个格子的路线，其中 $K = 3$。\n\n```\n格子编号:       0      1      2      3      4      5      6 \n            +---+  +---+  +---+  +---+  +---+  +---+  +---+ \n            |///|--|   |--|   |--|   |--|   |--|   |--|   | \n            +---+  +---+  +---+  +---+  +---+  +---+  +---+ \n值:            -      0      1      2     -3      4      5 \n```\n\nBessie 的一种最优途径为（括号中表示当前格子的金钱收益）： $0[0] \\to 1[0]\\to 3[2]\\to 6[5] \\to 5[4] \\to 2[1] \\to 0[0]$。\n\n如果 Bessie 跳了一个以 $0, 1, 2, 3, 4, \\dots$ 开始的序列，那么她将无法返回，因为她无法合法地跳回到一个未被触碰过的格子上。", "inputFormat": "第一行，两个用空格隔开的整数 $N, K$。\n\n接下来 $N$ 行，每行一个整数 $V_i$。", "outputFormat": "第一行，输出一个整数表示最大的钱数是多少。", "hint": "**【数据范围】**\n\n\n数据保证：$-2 \n\\times 10 ^9 \\le V_i \\le 2 \\times 10 ^ 9$，$3 \\le N \\le 2.5 \\times 10^5$，$2 \\le K \\le N$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10OPEN] Cow Hopscotch G", "background": null, "description": "The cows have reverted to their childhood and are playing a game similar to human hopscotch. Their hopscotch game features a line of $N (3 \\le N \\le 250,000)$ squares conveniently labeled $1\\dots N$ that are chalked onto the grass.\n\nLike any good game, this version of hopscotch has prizes!  Square i is labeled with some integer monetary value $V_i (-2 \\times 10^9 \\le V_i \\le 2 \\times 10^9)$. The cows play the game to see who can earn the most money.\n\nThe rules are fairly simple:\n\n* A cow starts at square $0$ (located just before square $1$; it has no monetary value).\n\n* She then executes a potentially empty sequence of jumps toward square N. Each square she lands on can be a maximum of $K (2 \\le K \\le N)$ squares from its predecessor square (i.e., from square $1$, she can jump outbound to squares $2$ or $3$ if $K=2$).\n\n* Whenever she wishes, the cow turns around and jumps back towards square $0$, stopping when she arrives there.\n\n\n\nIn addition to the restrictions above (including the $K$ limit), two additional restrictions apply:\n\n* She is not allowed to land on any square she touched on her outbound trip (except square $0$, of course).\n\n* Except for square $0$, the squares she lands on during the return trip must directly precede squares she landed on.\n\nduring the outbound trip (though she might make some larger leaps that skip potential return squares altogether).\n\nShe earns an amount of money equal to the sum of the monetary values of all the squares she jumped on. Find the largest amount of cash a cow can earn.\n\nBy way of example, consider this six-box cow-hopscotch course where $K$ has the value $3$:\n\n```\nSquare Num:    0      1      2      3      4      5      6 \n+---+  +---+  +---+  +---+  +---+  +---+  +---+ \n|///|--|   |--|   |--|   |--|   |--|   |--|   | \n+---+  +---+  +---+  +---+  +---+  +---+  +---+ \nValue:    -      0      1      2     -3      4      5 \n```\nOne (optimal) sequence Bessie could jump (shown with respective bracketed monetary values) is:  \n$1[0], 3[2], 6[5], 5[4], 2[1], 0[0]$ would yield a monetary total of $0+2+5+4+1+0=12$.\n\nIf Bessie jumped a sequence beginning with $0, 1, 2, 3, 4, \\dots$ then she would be unable to return since she could not legally jump back to an untouched square.", "inputFormat": "- Line $1$: Two space separated integers: N and K\n\n- Lines $2 \\dots N+1$: Line $i+1$ contains a single integer: $V_i$", "outputFormat": "* Line $1$: A single line with a single integer that is the maximum amount of money a cow can earn", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO10OPEN] Cow Hopscotch G", "background": null, "description": "奶牛们正在回味童年，玩一个类似跳格子的游戏，在这个游戏里，奶牛们在草地上画了一行 $N$ 个格子，编号为 $1\\dots N$。\n\n就像任何一个好游戏一样，这样的跳格子游戏也有奖励！第 $i$ 个格子标有一个数字 $v_i$ 表示这个格子的钱。奶牛们想看看最后谁能得到最多的钱。\n\n规则很简单：\n\n* 每个奶牛从 $0$ 号格子出发。($0$ 号格子在 $1$ 号之前，那里没钱)\n\n* 然后她执行一个可能为空的跳跃序列前往格子 $N$。她每次落地所在的格子距离前一个格子最多 $K$ 个格子（例如，如果 $K=2$，从格子 $1$ 出发，她最多可以跳到格子 $2$ 或 $3$）。\n\n* 在任何时候，她都可以选择回头往 $0$ 号格子跳，直到跳到 $0$ 号格子。\n\n另外，除了以上规则之外（包括 $K$ 限制），回头跳的时候还有两条规则：\n\n* 不可以跳到前进序列中的格子（格子 $0$ 除外）。\n\n* 除了 $0$ 号格子之外，她在回来的时候，停留的格子必须是恰巧过去的时候停留的某个格子的前一格（尽管她可能在返回时做一些更大的跳跃，从而跳过一些潜在的返回格子）。\n\n她赚取的金钱数量等于她跳过的所有格子的金钱价值之和。请找出奶牛能赚到的最大金额。\n\n举例说明，考虑一个有六个格子的路线，其中 $K = 3$。\n\n```\n格子编号:       0      1      2      3      4      5      6 \n            +---+  +---+  +---+  +---+  +---+  +---+  +---+ \n            |///|--|   |--|   |--|   |--|   |--|   |--|   | \n            +---+  +---+  +---+  +---+  +---+  +---+  +---+ \n值:            -      0      1      2     -3      4      5 \n```\n\nBessie 的一种最优途径为（括号中表示当前格子的金钱收益）： $0[0] \\to 1[0]\\to 3[2]\\to 6[5] \\to 5[4] \\to 2[1] \\to 0[0]$。\n\n如果 Bessie 跳了一个以 $0, 1, 2, 3, 4, \\dots$ 开始的序列，那么她将无法返回，因为她无法合法地跳回到一个未被触碰过的格子上。", "inputFormat": "第一行，两个用空格隔开的整数 $N, K$。\n\n接下来 $N$ 行，每行一个整数 $V_i$。", "outputFormat": "第一行，输出一个整数表示最大的钱数是多少。", "hint": "**【数据范围】**\n\n\n数据保证：$-2 \n\\times 10 ^9 \\le V_i \\le 2 \\times 10 ^ 9$，$3 \\le N \\le 2.5 \\times 10^5$，$2 \\le K \\le N$。", "locale": "zh-CN"}}}
{"pid": "P2991", "type": "P", "difficulty": 5, "samples": [["3 4 1 \n2 3 5 \n1 2 5 \n1 3 9 \n2 3 3 \n", "9 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO"], "title": "[USACO10OPEN] Water Slides G", "background": "", "description": "Inspired by the new water park at Machu Picchu in Peru, Farmer John has decided to build one for the cows. Its biggest\n\nattraction is to be a giant water slide of a peculiar design. The superslide comprises E (1 <= E <=\n\n150,000) mini slides connecting V (2 <= V <= 50,000) small pools conveniently labeled 1..V. Every mini slide must be traversed in its proper direction and may not be traversed backwards. The cows start at pool number 1 and traverse successive mini slides until they end up in the pool number V, the final pool. Every pool (except 1, the first one) includes at least one mini slide entering it and (except V, the last one) at least one (different) mini slide exiting it.\n\nFurthermore, a cow can reach the end of the ride (pool V) from any pool by going down a sequence of mini slides. Finally, since this is a slide, it is not possible to leave a pool and then encounter that pool again after traversing some set of mini slides.\n\nEach mini slide i runs from pool P\\_i to pool Q\\_i (1 <= P\\_i <= V; 1 <= Q\\_i <= V; P\\_i != Q\\_i) and has an associated fun value F\\_i (0 <= F\\_i <= 2,000,000,000). Bessie's total fun for any given trip down the superslide is the sum of the fun values of all the mini slides traversed.\n\nBessie naturally wants to have as much fun as possible, given the long time that she spends in the slide's queue waiting for the ride. Generally, she carefully chooses which mini slide to follow out of each pool. She is a cow, however, and no more than K (1 <= K <= 10) times as she splashes down the slide, she loses control and follows a random mini slide out of a pool (this can even happen on pool 1).\n\nIf Bessie chooses so as to maximize her fun in the worst case, how much fun is she guaranteed to have for a given super-slide?\n\nBy way of example, consider a small park that has 3 pools (pool id's shown in brackets) and four mini slides; K has the value 1 (fun values shown outside of brackets):\n\n[1]\n/   \\\n5 -> /     \\ <- 9 \n\n/       \\\n\n[2]---3---[3]\n\n\\_\\_5\\_\\_/\n\nShe alway starts at pool 1 and ends and pool 3. If she had her way, she'd ride direct from pool 1 to pool 2 and then on the higher-fun mini slide (with fun value 5) to slide 3 for a total fun value of 5+5=10. But, if she loses control at pool 1, she might slide directly from pool 1 to pool 3 for total fun 9. If she loses control at pool 2, she could reduce her total fun to just 5+3 = 8.\n\nBessie wants to find the most fun she can have so she strives to choose 1->3 for a total fun of 9. If she loses control at pool 1 and ends up on mini slide 1->2, she knows she will not lose control at pool 2 and will end up with fun 10. Thus, she knows her minimum fun will always be at least 9.\n", "inputFormat": "\\* Line 1: Three space separated integers: V, E, and K\n\n\\* Lines 2..E + 1: Line i+1 contains three space separated integers: P\\_i, Q\\_i, and F\\_i\n", "outputFormat": "\\* Line 1: A single line with a single integer that is the minimum fun that Bessie can guarantee she can have.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO10OPEN] Water Slides G", "background": "", "description": "Inspired by the new water park at Machu Picchu in Peru, Farmer John has decided to build one for the cows. Its biggest\n\nattraction is to be a giant water slide of a peculiar design. The superslide comprises E (1 <= E <=\n\n150,000) mini slides connecting V (2 <= V <= 50,000) small pools conveniently labeled 1..V. Every mini slide must be traversed in its proper direction and may not be traversed backwards. The cows start at pool number 1 and traverse successive mini slides until they end up in the pool number V, the final pool. Every pool (except 1, the first one) includes at least one mini slide entering it and (except V, the last one) at least one (different) mini slide exiting it.\n\nFurthermore, a cow can reach the end of the ride (pool V) from any pool by going down a sequence of mini slides. Finally, since this is a slide, it is not possible to leave a pool and then encounter that pool again after traversing some set of mini slides.\n\nEach mini slide i runs from pool P\\_i to pool Q\\_i (1 <= P\\_i <= V; 1 <= Q\\_i <= V; P\\_i != Q\\_i) and has an associated fun value F\\_i (0 <= F\\_i <= 2,000,000,000). Bessie's total fun for any given trip down the superslide is the sum of the fun values of all the mini slides traversed.\n\nBessie naturally wants to have as much fun as possible, given the long time that she spends in the slide's queue waiting for the ride. Generally, she carefully chooses which mini slide to follow out of each pool. She is a cow, however, and no more than K (1 <= K <= 10) times as she splashes down the slide, she loses control and follows a random mini slide out of a pool (this can even happen on pool 1).\n\nIf Bessie chooses so as to maximize her fun in the worst case, how much fun is she guaranteed to have for a given super-slide?\n\nBy way of example, consider a small park that has 3 pools (pool id's shown in brackets) and four mini slides; K has the value 1 (fun values shown outside of brackets):\n\n[1]\n/   \\\n5 -> /     \\ <- 9 \n\n/       \\\n\n[2]---3---[3]\n\n\\_\\_5\\_\\_/\n\nShe alway starts at pool 1 and ends and pool 3. If she had her way, she'd ride direct from pool 1 to pool 2 and then on the higher-fun mini slide (with fun value 5) to slide 3 for a total fun value of 5+5=10. But, if she loses control at pool 1, she might slide directly from pool 1 to pool 3 for total fun 9. If she loses control at pool 2, she could reduce her total fun to just 5+3 = 8.\n\nBessie wants to find the most fun she can have so she strives to choose 1->3 for a total fun of 9. If she loses control at pool 1 and ends up on mini slide 1->2, she knows she will not lose control at pool 2 and will end up with fun 10. Thus, she knows her minimum fun will always be at least 9.\n", "inputFormat": "\\* Line 1: Three space separated integers: V, E, and K\n\n\\* Lines 2..E + 1: Line i+1 contains three space separated integers: P\\_i, Q\\_i, and F\\_i\n", "outputFormat": "\\* Line 1: A single line with a single integer that is the minimum fun that Bessie can guarantee she can have.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO10OPEN] Water Slides G", "background": null, "description": "受到秘鲁马丘比丘新建水上乐园的启发，约翰农夫决定为奶牛们建造一个水上乐园。其最大的吸引力将是一个设计独特的巨型滑梯。超级滑梯由 $E(1 \\le E\\le150,000)$ 个迷你滑梯连接 $V(2\\le V\\le50,000)$ 个小水池，这些水池被方便地标记为 $1$ 到 $V$。每个迷你滑梯必须按照正确的方向滑行，不能逆向滑行。奶牛们从编号为 $1$ 的水池出发，依次滑过迷你滑梯，直到到达编号为 $V$ 的终点水池。每个水池（除了第一个水池 $1$）至少有一个迷你滑梯进入它，（除了最后一个水池 $V$）至少有一个（不同的）迷你滑梯从它出去。\n\n此外，奶牛可以通过一系列迷你滑梯从任何水池到达终点水池 $V$。最后，由于这是一个滑梯，不可能离开一个水池后，再经过一系列迷你滑梯后重新回到该水池。\n\n每个迷你滑梯 $i$ 从水池 $P_i$ 到水池 $Q_i$ （$1\\le P_i\\le V; 1\\le Q_i\\le V; P_i\\ne Q_i$），并且有一个与之关联的乐趣值 $F_i(0\\le F_i\\le 2,000,000,000)$。对于任何一次超级滑梯的滑行，贝茜的总乐趣是所有经过的迷你滑梯的乐趣值之和。\n\n贝茜自然希望在滑梯排队等待的漫长时间里尽可能多地享受乐趣。通常，她会仔细选择从每个水池出来的迷你滑梯。然而，她是一头奶牛，在滑下滑梯的过程中最多有 $K(1\\le K\\le 10)$ 次会失去控制，随机选择一个迷你滑梯离开水池（这甚至可能发生在水池 $1$）。\n\n如果贝茜选择以最坏情况下最大化她的乐趣，她在给定的超级滑梯上能保证获得多少乐趣？\n\n例如，考虑一个有 $3$ 个水池（水池编号如括号中所示）和四个迷你滑梯的小型乐园；$K$ 的值为 $1$（乐趣值如括号外所示）：\n\n[1]\n/   \\ 5 -> /     \\ <- 9 \n\n/       \\ \n[2]---3---[3]\n\n\\_\\_5\\_\\_/\n\n她总是从水池 $1$ 开始，到达水池 $3$。如果她可以选择，她会直接从水池 $1$ 到水池 $2$，然后通过乐趣值较高的迷你滑梯（乐趣值为 $5$）到达滑梯 $3$，总乐趣值为 $5+5=10$。但是，如果她在水池 $1$ 失去控制，她可能会直接从水池 $1$ 滑到水池 $3$，总乐趣为 $9$。如果她在水池 $2$ 失去控制，她的总乐趣可能会减少到 $5+3 = 8$。\n\n贝茜希望找到她能获得的最大乐趣，因此她努力选择 $1\\to3$，总乐趣为 $9$。如果她在水池 $1$ 失去控制而滑到迷你滑梯 $1\\to2$，她知道她在水池 $2$ 不会失去控制，并且最终乐趣为 $10$。因此，她知道她的最小乐趣总是至少为 $9$。", "inputFormat": "\\* 第 $1$ 行：三个用空格分隔的整数：$V$，$E$ 和 $K$。\n\n\\* 第 $2$ 行到第 $E+1$ 行：第 $i+1$ 行包含三个用空格分隔的整数：$P_i$，$Q_i$ 和 $F_i$。", "outputFormat": "\\* 第 $1$ 行：一个整数，表示贝茜可以保证获得的最小乐趣。", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2992", "type": "P", "difficulty": 5, "samples": [["5 \n-5 0 \n0 2 \n11 2 \n-11 -6 \n11 -5 \n", "5 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2010", "USACO", "排序", "容斥原理", "双指针 two-pointer"], "title": "[USACO10OPEN] Triangle Counting G", "background": "", "description": "在一只大灰狼偷偷潜入 Farmer Don 的牛群被群牛发现后，贝西现在不得不履行着她站岗的职责。从她的守卫塔向下瞭望简直就是一件烦透了的事情。她决定做一些开发智力的小练习，防止她睡着了。\n\n想象牧场是一个 $X\\times Y$ 平面的网格。她将 $N$ 只奶牛标记为 $1\\cdots N$，每只奶牛的坐标为 $X_i,Y_i$ ($1 \\le i \\le N$)。然后她脑海里想象着所有可能由奶牛构成的三角形。如果一个三角形完全包含了原点 $(0,0)$，那么她称这个三角形为“黄金三角形”。原点不会落在任何一对奶牛的连线上。另外，不会有奶牛在原点。\n\n给出奶牛的坐标，计算出有多少个“黄金三角形”。", "inputFormat": "第一行，包含一个正整数 $N$。\n\n第 $2\\sim N+1$ 行，每行两个正整数 $X_i,Y_i$ 表示第 $i$ 头牛的坐标。", "outputFormat": "一行一个正整数表示答案。", "hint": "$1 \\le N \\le 100,000$\n\n$-100,000 \\le X_i,Y_i \\le 100,000$", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10OPEN] Triangle Counting G", "background": "Bessie is standing guard duty after the big bad wolf was spotted stalking cows over at Farmer Don's spread. \n\nLooking down from her guard tower in \nutter boredom, she's decided to \nperform intellectual exercises in order to keep awake.", "description": "After imagining the field as an $X\\times Y$ grid, she recorded the coordinates of the N ($1 \\le N \\le 100,000$, conveniently numbered $1\\cdots N$) cows as $X_i,Y_i$ ($-100,000 \\le X_i \\le 100,000; \n-100,000 \\le Y_i \\le 100,000; 1 \\le i \\le N$). She then mentally formed all possible triangles that could be made from subsets of the entire set of cow coordinates. She counts a triangle as 'golden' if it wholly contains the origin (0,0). The origin does not fall on the line between any pair of cows. Additionally, no cow is standing exactly on the origin. \n\nGiven the list of cow locations, calculate the number of 'golden' triangles that contain the origin so Bessie will know if she's doing a good job. \n\nBy way of example, consider 5 cows at these locations:\n\n$(-5,0)$   $(0,2)$   $(11,2)$   $(-11,-6)$   $(11,-5)$\n\nBelow is a schematic layout of the field from Betsy's point of view:\n\n```cpp\n............|............ \n............*..........*. \n............|............ \n-------*----+------------ \n............|............ \n............|............ \n............|............ \n............|............ \n............|..........*. \n.*..........|............ \n............|............ \n```\n\nTen triangles can be formed from the five points above.\n\nBy inspection, 5 of them contain the origin and hence are 'golden'.", "inputFormat": "\\* Line 1: A single integer: $N$\n\n\\* Lines $2\\cdots N+1$: Each line contains two integers, the coordinates of a single cow: $X_i$ and $Y_i$", "outputFormat": "\\* Line 1: A single line with a single integer that is the count of the number of times a triangle formed by the cow locations contains the origin", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO10OPEN] Triangle Counting G", "background": "", "description": "在一只大灰狼偷偷潜入 Farmer Don 的牛群被群牛发现后，贝西现在不得不履行着她站岗的职责。从她的守卫塔向下瞭望简直就是一件烦透了的事情。她决定做一些开发智力的小练习，防止她睡着了。\n\n想象牧场是一个 $X\\times Y$ 平面的网格。她将 $N$ 只奶牛标记为 $1\\cdots N$，每只奶牛的坐标为 $X_i,Y_i$ ($1 \\le i \\le N$)。然后她脑海里想象着所有可能由奶牛构成的三角形。如果一个三角形完全包含了原点 $(0,0)$，那么她称这个三角形为“黄金三角形”。原点不会落在任何一对奶牛的连线上。另外，不会有奶牛在原点。\n\n给出奶牛的坐标，计算出有多少个“黄金三角形”。", "inputFormat": "第一行，包含一个正整数 $N$。\n\n第 $2\\sim N+1$ 行，每行两个正整数 $X_i,Y_i$ 表示第 $i$ 头牛的坐标。", "outputFormat": "一行一个正整数表示答案。", "hint": "$1 \\le N \\le 100,000$\n\n$-100,000 \\le X_i,Y_i \\le 100,000$", "locale": "zh-CN"}}}
{"pid": "P2993", "type": "P", "difficulty": 6, "samples": [["6 6 4\n1 2 1\n2 3 1\n3 4 1\n2 5 1\n3 6 1\n5 6 1", "3 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2014", "各省省选", "福建"], "title": "[FJOI2014] 最短路径树问题", "background": "", "description": "给一个包含 $n$ 个点，$m$ 条边的无向连通图。从顶点 $1$ 出发，往其余所有点分别走一次并返回。\n\n往某一个点走时，选择总长度最短的路径走。若有多条长度最短的路径，则选择经过的顶点序列字典序最小的那条路径（如路径 A 为 $1,32,11$，路径 B 为 $1,3,2,11$，路径 B 字典序较小。注意是序列的字典序的最小，而非路径中节点编号相连的字符串字典序最小）。到达该点后按原路返回，然后往其他点走，直到所有点都走过。\n\n可以知道，经过的边会构成一棵最短路径树。请问，在这棵最短路径树上，最长的包含 $K$ 个点的简单路径长度为多长？包含 $K$ 个点的长度为该最长长度的不同路径有多少条？\n\n这里的简单路径是指：对于一个点最多只经过一次的路径。不同路径是指路径两端端点至少有一个不同，点 A 到点 B 的路径和点 B 到点 A 视为同一条路径。", "inputFormat": "第一行输入三个正整数 $n,m,K$，表示有 $n$ 个点 $m$ 条边，要求的路径需要经过 $K$ 个点。\n\n接下来输入 $m$ 行，每行三个正整数 $A_i,B_i,C_i(1\\leq Ai,Bi\\leq n,1\\leq C_i \\leq 10000)$，表示 $A_i$ 和 $B_i$ 间有一条长度为 $C_i$ 的边。\n\n数据保证输入的是连通的无向图。", "outputFormat": "输出一行两个整数，以一个空格隔开，第一个整数表示包含 $K$ 个点的路径最长为多长，第二个整数表示包含 $K$ 个点的长度为该最长长度的不同路径有多少条。", "hint": "对于所有数据 $n\\leq 30000,m\\leq 60000，2\\leq K\\leq n$。\n\n数据保证最短路径树上至少存在一条长度为 $K$ 的路径。", "locale": "zh-CN", "translations": {"en": {"title": "[FJOI2014] Shortest Path Tree Problem", "background": "", "description": "You are given a connected undirected graph with $n$ vertices and $m$ edges. Starting from vertex 1, for each of the other vertices, walk to it once and then return.\n\nWhen walking to a vertex, choose a path with the smallest total length. If there are multiple shortest paths, choose the one whose sequence of visited vertices is lexicographically smallest (for example, path A is 1,32,11 and path B is 1,3,2,11; path B is lexicographically smaller. Note that we compare the lexicographical order of the vertex sequence, not the lex order of the concatenated string of node labels). After reaching that vertex, return along the same path, then proceed to the next vertex, until all vertices have been visited.\n\nIt can be shown that the edges traversed form a shortest path tree. On this shortest path tree, what is the length of the longest simple path that contains $K$ vertices? How many different paths that contain $K$ vertices achieve this maximum length?\n\nA simple path means a path that visits any vertex at most once. Different paths mean the two endpoints are not the same pair; the path from A to B and the path from B to A are considered the same path.", "inputFormat": "The first line contains three positive integers $n, m, K$, meaning there are $n$ vertices and $m$ edges, and the required path must contain $K$ vertices.\n\nEach of the next $m$ lines contains three positive integers $A_i, B_i, C_i$ ($1 \\leq A_i, B_i \\leq n, 1 \\leq C_i \\leq 10000$), indicating there is an edge of length $C_i$ between $A_i$ and $B_i$.\n\nIt is guaranteed that the input graph is connected and undirected.", "outputFormat": "Output one line with two integers separated by a space. The first integer is the maximum length of a simple path that contains $K$ vertices, and the second integer is the number of different paths that contain $K$ vertices and achieve this maximum length.", "hint": "Constraints: For all testdata, $n \\leq 30000$, $m \\leq 60000$, $2 \\leq K \\leq n$.\n\nIt is guaranteed that the shortest path tree contains at least one path that visits $K$ vertices.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[FJOI2014] 最短路径树问题", "background": "", "description": "给一个包含 $n$ 个点，$m$ 条边的无向连通图。从顶点 $1$ 出发，往其余所有点分别走一次并返回。\n\n往某一个点走时，选择总长度最短的路径走。若有多条长度最短的路径，则选择经过的顶点序列字典序最小的那条路径（如路径 A 为 $1,32,11$，路径 B 为 $1,3,2,11$，路径 B 字典序较小。注意是序列的字典序的最小，而非路径中节点编号相连的字符串字典序最小）。到达该点后按原路返回，然后往其他点走，直到所有点都走过。\n\n可以知道，经过的边会构成一棵最短路径树。请问，在这棵最短路径树上，最长的包含 $K$ 个点的简单路径长度为多长？包含 $K$ 个点的长度为该最长长度的不同路径有多少条？\n\n这里的简单路径是指：对于一个点最多只经过一次的路径。不同路径是指路径两端端点至少有一个不同，点 A 到点 B 的路径和点 B 到点 A 视为同一条路径。", "inputFormat": "第一行输入三个正整数 $n,m,K$，表示有 $n$ 个点 $m$ 条边，要求的路径需要经过 $K$ 个点。\n\n接下来输入 $m$ 行，每行三个正整数 $A_i,B_i,C_i(1\\leq Ai,Bi\\leq n,1\\leq C_i \\leq 10000)$，表示 $A_i$ 和 $B_i$ 间有一条长度为 $C_i$ 的边。\n\n数据保证输入的是连通的无向图。", "outputFormat": "输出一行两个整数，以一个空格隔开，第一个整数表示包含 $K$ 个点的路径最长为多长，第二个整数表示包含 $K$ 个点的长度为该最长长度的不同路径有多少条。", "hint": "对于所有数据 $n\\leq 30000,m\\leq 60000，2\\leq K\\leq n$。\n\n数据保证最短路径树上至少存在一条长度为 $K$ 的路径。", "locale": "zh-CN"}}}
{"pid": "P2994", "type": "P", "difficulty": 4, "samples": [["2 1 \n0 1 \n1 0 \n1 10 \n", "2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2010", "USACO", "排序"], "title": "[USACO10OCT] Dinner Time S", "background": "", "description": "Farmer John's N (1 <= N <= 1,000) cows conveniently numbered 1..N are participating in the IOI in Bulgaria. The cows like the Bulgarian sun and are enjoying their holiday. All seems well.\n\nThis changes around dinner time. The restaurant is rather small, having only M (1 <= M <= N) cow seats conveniently numbered 1..M. Each cow starts at a location CX\\_i, CY\\_i (-1,000,000 <= CX\\_i <= 1,000,000; -1,000,000 <= CY\\_i <= 1,000,000); the seats can be found at SX\\_j, SY\\_j (-1,000,000 <= SX\\_j <= 1,000,000; -1,000,000 <= SY\\_j <= 1,000,000).\n\nThe cows have a very efficient (though primitive) method to distribute themselves into the seats. As soon as a cow is certain she will get to a seat first, she rushes there as fast as she can (all cows runs equally fast).\n\nFarmer John's cows, like all prize cows, have no problem jumping over seats, tables, or other cows, so they can run in a straight line. When multiple cows can reach a seat at the very same time, the oldest cow (the one appearing earlier in the input data) gets the seat.  Likewise, when a cow can be the first to reach multiple seats she will also choose the one appearing earliest in the input.\n\nSome cows won't be able to eat dinner, and those hungry cows are collectively planning to steal Farmer John's very own food. Farmer John would like a list of cows he should be wary of. (In the case when there are no hungry cows, output 0). Can you help him?\n\nNOTE: Standard distance calculations will likely require an\n\nintermediate result that will fit into a 64-bit integer but not into a 32-bit integer.", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N+1: Line i+1 contains two space separated integers: CX\\_i and CY\\_i\n\n\\* Lines N+2..N+M+1: Line j+N+1 contains two space separated integers: SX\\_j and SY\\_j", "outputFormat": "\\* Lines 1..N-M: Line i contains the number of the ith cow that Farmer John should be wary of. The cow numbers should be listed in increasing order.", "hint": "2 cows: Cow 1 starts at (0, 1) and cow 2 at (1, 0). There \n\nis only 1 seat at (1, 10). \n\nCow 1 is closer to the seat than cow 2, so cow 1 will get the only seat.\n", "locale": "en", "translations": {"en": {"title": "[USACO10OCT] Dinner Time S", "background": "", "description": "Farmer John's N (1 <= N <= 1,000) cows conveniently numbered 1..N are participating in the IOI in Bulgaria. The cows like the Bulgarian sun and are enjoying their holiday. All seems well.\n\nThis changes around dinner time. The restaurant is rather small, having only M (1 <= M <= N) cow seats conveniently numbered 1..M. Each cow starts at a location CX\\_i, CY\\_i (-1,000,000 <= CX\\_i <= 1,000,000; -1,000,000 <= CY\\_i <= 1,000,000); the seats can be found at SX\\_j, SY\\_j (-1,000,000 <= SX\\_j <= 1,000,000; -1,000,000 <= SY\\_j <= 1,000,000).\n\nThe cows have a very efficient (though primitive) method to distribute themselves into the seats. As soon as a cow is certain she will get to a seat first, she rushes there as fast as she can (all cows runs equally fast).\n\nFarmer John's cows, like all prize cows, have no problem jumping over seats, tables, or other cows, so they can run in a straight line. When multiple cows can reach a seat at the very same time, the oldest cow (the one appearing earlier in the input data) gets the seat.  Likewise, when a cow can be the first to reach multiple seats she will also choose the one appearing earliest in the input.\n\nSome cows won't be able to eat dinner, and those hungry cows are collectively planning to steal Farmer John's very own food. Farmer John would like a list of cows he should be wary of. (In the case when there are no hungry cows, output 0). Can you help him?\n\nNOTE: Standard distance calculations will likely require an\n\nintermediate result that will fit into a 64-bit integer but not into a 32-bit integer.", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N+1: Line i+1 contains two space separated integers: CX\\_i and CY\\_i\n\n\\* Lines N+2..N+M+1: Line j+N+1 contains two space separated integers: SX\\_j and SY\\_j", "outputFormat": "\\* Lines 1..N-M: Line i contains the number of the ith cow that Farmer John should be wary of. The cow numbers should be listed in increasing order.", "hint": "2 cows: Cow 1 starts at (0, 1) and cow 2 at (1, 0). There \n\nis only 1 seat at (1, 10). \n\nCow 1 is closer to the seat than cow 2, so cow 1 will get the only seat.\n", "locale": "en"}, "zh-CN": {"title": "[USACO10OCT] Dinner Time S", "background": "", "description": "农场主约翰的 $N$（$1 \\le N \\le 10 ^ 3$）头奶牛被编号为 $1 \\sim N$，它们正在保加利亚参加 IOI。奶牛们喜欢保加利亚的太阳并享受着它们的假日，一切看起来都没问题。\n\n变化发生在晚餐时间前后。这家餐馆很小，只有 $M$（$1 \\le M \\le N$）个座位，编号为 $1 \\sim M$。每头牛从一个位置 $CX_i$，$CY_i$ 进入餐馆（$-10 ^ 6 \\le CX_i \\le 10 ^ 6,-10 ^ 6 \\le CY_i \\le 10 ^ 6$）；座位可以在 $SX_j$，$SY_j$ 找到（$-10 ^ 6 \\le SX_j \\le10 ^ 6,-10 ^ 6\\le SY_j\\le 10 ^ 6$）。\n\n\n\n奶牛有一种非常有效的（尽管很原始）方法把自己分配到座位上。一旦某只奶牛确定她会先到某个座位上，她就会尽快赶到那里（所有的奶牛都跑得一样快）。\n\n\n\n农场主约翰的奶牛和所有获奖的奶牛一样，跳过座位、桌子或其他奶牛都没有问题，因此它们可以直线奔跑。当多头牛可以同时到达一个座位时，最老的牛（在输入数据中出现得更早的牛）获得座位。当一头牛可以第一个到达多个座位时，她也会选择在输入中最早出现的座位。\n\n\n\n一些奶牛将不能吃晚饭，这些吃不到饭的饥饿的奶牛正集体计划偷农场主约翰自己的食物。农场主约翰想要一份他应该提防的奶牛名单。（如果没有饥饿的奶牛，则输出 $0$）。你能帮他吗？\n\n\n\n注：在计算中可能会有超过 $32$ 位整数范围但在 $64$ 位整数范围内的数。\n\n------------", "inputFormat": "第一行：两个空格分隔的整数：$N$ 和 $M$。\n\n第 $2 \\sim N + 1$ 行：第 $i+1$ 行包含两个空格分隔的整数：$CX_i$ 和 $CY_i$。\n\n\n\n第 $N+2 \\sim N+M+1$ 行：行 $j+N+1$ 包含两个空格分隔的整数：$SX_j$ 和 $SY_j$。\n\n\n------------", "outputFormat": "第 $1$ 行到第 $(N-M)$ 行：第 $i$ 行包含农场主约翰应该提防的第 $i$ 头牛的编号。奶牛的编号应递增排序。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2995", "type": "P", "difficulty": 5, "samples": [["5 \n3 \n5 \n4 \n2 \n1 \n", "2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO", "O2优化"], "title": "[USACO10NOV] Cow Photographs G", "background": "", "description": "Farmer John wants to take a picture of his entire herd of N (1 <= N <= 100,000) cows conveniently numbered 1..N so he can show off to his friends.\n\nOn picture day, the cows run to form a single line in some arbitrary order with position i containing cow c\\_i (1 <= c\\_i <= N). Farmer John has his own ideas about how the cows should line up.\n\nFJ thinks cow i may stand only to the left of cow i+1 (for all i, 1 <= i <= N-1) and that cow N may only stand to the left of Cow 1. Of course, no cow will stand to the left of the first (leftmost) cow in the line.\n\nThe cows are hungry for the promised post-photo dinner, so Farmer John wants to take the picture as quickly as possible. Cows are not great at following directions, so he will only choose a pair of adjacent cows and have them switch places once per minute. How quickly is Farmer John able to get them into some acceptable order?\n\nConsider a set of 5 cows whose initial lineup looks like this:\n\nLeft           Right\n\n3  5  4  2  1\n\nHe can first swap the second pair of cows:\n\n3  4  5  2 1\n\nand then swap the rightmost pair: \n\n3  4  5  1  2\n\nto yield an acceptable lineup that required but two minutes of cow swapping.\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains the number of the i-th cow in line: c\\_i\n", "outputFormat": "\\* Line 1: The minimum amount of time, in minutes, that it takes Farmer John to get the cows into some appropriate order.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO10NOV] Cow Photographs G", "background": "", "description": "Farmer John wants to take a picture of his entire herd of N (1 <= N <= 100,000) cows conveniently numbered 1..N so he can show off to his friends.\n\nOn picture day, the cows run to form a single line in some arbitrary order with position i containing cow c\\_i (1 <= c\\_i <= N). Farmer John has his own ideas about how the cows should line up.\n\nFJ thinks cow i may stand only to the left of cow i+1 (for all i, 1 <= i <= N-1) and that cow N may only stand to the left of Cow 1. Of course, no cow will stand to the left of the first (leftmost) cow in the line.\n\nThe cows are hungry for the promised post-photo dinner, so Farmer John wants to take the picture as quickly as possible. Cows are not great at following directions, so he will only choose a pair of adjacent cows and have them switch places once per minute. How quickly is Farmer John able to get them into some acceptable order?\n\nConsider a set of 5 cows whose initial lineup looks like this:\n\nLeft           Right\n\n3  5  4  2  1\n\nHe can first swap the second pair of cows:\n\n3  4  5  2 1\n\nand then swap the rightmost pair: \n\n3  4  5  1  2\n\nto yield an acceptable lineup that required but two minutes of cow swapping.\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains the number of the i-th cow in line: c\\_i\n", "outputFormat": "\\* Line 1: The minimum amount of time, in minutes, that it takes Farmer John to get the cows into some appropriate order.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO10NOV] Cow Photographs G", "background": "", "description": "农夫约翰想要给他全部的 N (1 <= N <= 100,000) 头奶牛拍张照片，这些奶牛被方便地编号为 1 到 N，以便他能向朋友们炫耀。\n\n在拍照日，奶牛们会跑到一起形成一条单行队列，位置 i 上是奶牛 c\\_i (1 <= c\\_i <= N)。农夫约翰有他自己关于奶牛应该如何排列的想法。\n\n约翰认为奶牛 i 只能站在奶牛 i+1 的左边（对于所有 i，1 <= i <= N-1），并且奶牛 N 只能站在奶牛 1 的左边。当然，没有奶牛会站在队列中第一头（最左边的）奶牛的左边。\n\n奶牛们渴望拍照后承诺的晚餐，因此农夫约翰想尽快拍完照片。奶牛们不太擅长遵循指示，所以他每分钟只能选择一对相邻的奶牛并让它们交换位置。农夫约翰能多快将它们排成某种合适的顺序？\n\n考虑一组 5 头奶牛，其初始排列如下：\n\n左           右\n\n3  5  4  2  1\n\n他可以先交换第二对奶牛：\n\n3  4  5  2 1\n\n然后交换最右边的一对：\n\n3  4  5  1  2\n\n这样就得到一个合适的排列，只需要两分钟的奶牛交换。\n", "inputFormat": "\\* 第 1 行：一个整数：N\n\n\\* 第 2 行到第 N+1 行：第 i+1 行包含第 i 头奶牛在队列中的编号：c\\_i\n", "outputFormat": "\\* 第 1 行：农夫约翰将奶牛排成某种合适顺序所需的最少时间，以分钟为单位。\n", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2996", "type": "P", "difficulty": 3, "samples": [["7 \n6 2 \n3 4 \n2 3 \n1 2 \n7 6 \n5 6 \n", "4 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO", "树形 DP"], "title": "[USACO10NOV] Visiting Cows G", "background": null, "description": "经过了几周的辛苦工作，Bessie 终于迎来了一个假期。\n\n作为奶牛群中最会社交的牛，她希望去拜访 $N(1 \\le N \\le 50000)$ 个朋友。这些朋友被标号为 $1,2,\\dots,N$。这些奶牛有一个不同寻常的交通系统，里面有 $N-1$ 条路，每条路连接了一对编号为 $C_1$ 和 $C_2$ 的奶牛 $(1 \\le C_1 \\le N, 1 \\le C_2 \\le N, C_1 \\ne C_2)$。这样，在每一对奶牛之间都有一条唯一的通路。\n\nFJ 希望 Bessie 尽快的回到农场。于是，他就指示 Bessie：如果对于一条路直接相连的两个奶牛，Bessie 只能拜访其中的一个。当然，Bessie 希望她的假期越长越好，所以她想知道她可以拜访的奶牛的最大数目。", "inputFormat": "第一行，$1$ 个整数 $N$。\n\n接下来 $N - 1$ 行，每行 $2$ 个整数 $C_1,C_2$，表示有一条通路连接了编号为 $C_1$ 和 $C_2$ 的奶牛。", "outputFormat": "第一行，$1$ 个整数，代表 Bessie 最多能拜访有多少头奶牛。", "hint": "Bessie 希望去拜访 $7$ 头奶牛。第六头和第二头通过一条道路直接连接，像第三头和第四头、第二头和第三头等一样。下方的插图描述了连接奶牛们的所有道路。\n\n```plain\n1--2--3--4\n   |\n5--6--7\n```\n\nBessie 能拜访 $4$ 头奶牛。最好的组合包含 $2$ 头在上面的奶牛与 $2$ 头在底下的奶牛（如上图）。她不能在同时拜访第五和第七头奶牛的情况下拜访第六头奶牛。因此，她拜访了第五和第七头。她还可以拜访在上面的奶牛：第 $(1,3), (1,4)$ 或者第 $(2,4)$ 头奶牛。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10NOV] Visiting Cows G", "background": null, "description": "After many weeks of hard work, Bessie is finally getting a vacation. She wants to visit $N$ friends, labeled $1,2 \\dots, N$. The cows have set up an unusual road network with exactly $N - 1$ roads connecting pairs of cows $C_1$ and $C_2$ ($1 \\le C_1 \\le N$, $1 \\le C_2 \\le N$, $C_1 \\ne C_2$), so that there is a unique path between any two cows.\n\nFJ wants Bessie to come back to the farm soon; therefore, if two cows are directly connected by a road, she may not visit both. Bessie would like her vacation to be as long as possible, so she wants to determine the maximum number of cows she can visit.\n\nConstraints: $1 \\le N \\le 50000$.", "inputFormat": "* Line 1: A single integer $N$.\n* Lines 2..$N$: Each line describes one road with two space-separated integers: $C_1$ and $C_2$.", "outputFormat": "* Line 1: A single integer representing the maximum number of cows that Bessie can visit.", "hint": "Bessie knows $7$ cows. The roads form the following tree:\n```plain\n1--2--3--4\n   |\n5--6--7\n```\nBessie can visit four cows. The best combinations include two cows on the top row and two on the bottom. She cannot visit cow 6 since that would prevent visiting cows 5 and 7; thus she visits 5 and 7. She can also visit two cows on the top row: $\\{1, 3\\}$, $\\{1, 4\\}$, or $\\{2, 4\\}$.", "locale": "en"}, "zh-CN": {"title": "[USACO10NOV] Visiting Cows G", "background": null, "description": "经过了几周的辛苦工作，Bessie 终于迎来了一个假期。\n\n作为奶牛群中最会社交的牛，她希望去拜访 $N(1 \\le N \\le 50000)$ 个朋友。这些朋友被标号为 $1,2,\\dots,N$。这些奶牛有一个不同寻常的交通系统，里面有 $N-1$ 条路，每条路连接了一对编号为 $C_1$ 和 $C_2$ 的奶牛 $(1 \\le C_1 \\le N, 1 \\le C_2 \\le N, C_1 \\ne C_2)$。这样，在每一对奶牛之间都有一条唯一的通路。\n\nFJ 希望 Bessie 尽快的回到农场。于是，他就指示 Bessie：如果对于一条路直接相连的两个奶牛，Bessie 只能拜访其中的一个。当然，Bessie 希望她的假期越长越好，所以她想知道她可以拜访的奶牛的最大数目。", "inputFormat": "第一行，$1$ 个整数 $N$。\n\n接下来 $N - 1$ 行，每行 $2$ 个整数 $C_1,C_2$，表示有一条通路连接了编号为 $C_1$ 和 $C_2$ 的奶牛。", "outputFormat": "第一行，$1$ 个整数，代表 Bessie 最多能拜访有多少头奶牛。", "hint": "Bessie 希望去拜访 $7$ 头奶牛。第六头和第二头通过一条道路直接连接，像第三头和第四头、第二头和第三头等一样。下方的插图描述了连接奶牛们的所有道路。\n\n```plain\n1--2--3--4\n   |\n5--6--7\n```\n\nBessie 能拜访 $4$ 头奶牛。最好的组合包含 $2$ 头在上面的奶牛与 $2$ 头在底下的奶牛（如上图）。她不能在同时拜访第五和第七头奶牛的情况下拜访第六头奶牛。因此，她拜访了第五和第七头。她还可以拜访在上面的奶牛：第 $(1,3), (1,4)$ 或者第 $(2,4)$ 头奶牛。", "locale": "zh-CN"}}}
{"pid": "P2997", "type": "P", "difficulty": 3, "samples": [["2 1 2 3 \n", "2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO"], "title": "[USACO10NOV] Banner S", "background": "题目大意(by:曹彦臣)：\n\n\n平面上有(0,0)到(n,m)的(n+1)\\*(m+1)个点。问有多少点对所连的线段不过其他点，且长度在[l,h]范围内。\n", "description": "Bessie is returning from a long trip abroad, and Farmer John wants to erect a nice 'Welcome Home' banner in her pasture for her arrival. The banner will hang between two poles on a wire whose length is in the range L1..L2 (1 <= L1 <= L2; L1 <= L2 <= 1,500).\n\nThe pasture's size is W x H (1 <= W <= 1,000; 1 <= H <= 1,000), and Farmer John has installed a post at every point with integer\n\ncoordinates. Of these (W + 1) \\* (H + 1) points, Farmer John must pick just two that will hold either end of the wire from which he will hang the banner.\n\nFJ wants no interference with his banner as it hangs and requires that no post be directly under the tight wire he stretches between the two chosen posts.\n\nFarmer John needs your help to figure out how many possible ways he can hang the banner. He knows the number is large and that a 32-bit integer might not be sufficient to compute the answer.\n\nConsider the example pasture below, with W = 2 and H = 1: \n\n\\* \\* \\*\n\\* \\* \\*\nThe banner size is in the range 2..3. This pasture contains (2+1) \\* (1+1) = 6 points and has (6 take 2) = (6\\*5)/(2\\*1) = 15 different potential pairs of points between which the banner-holding wire might stretch:\n\n```cpp\n(0,0)-(0,1)   (0,0)-(2,1)   (0,1)-(2,1)   (1,1)-(2,0) \n(0,0)-(1,0)   (0,1)-(1,0)   (1,0)-(1,1)   (1,1)-(2,1) \n(0,0)-(1,1)   (0,1)-(1,1)   (1,0)-(2,0)   (2,0)-(2,1) \n(0,0)-(2,0)   (0,1)-(2,0)   (1,0)-(2,1) \n```\nOf these pairs, only four have a length in the range 2..3:\nLen                       Len\n\n(0,0)-(2,0) 2.00          (0,1)-(2,0) 2.24 \n\n(0,0)-(2,1) 2.24          (0,1)-(2,1) 2.00 \n\nOf these four, the pairs (0,0)-(2,0) and (0,1)-(2,1) both have a post directly on the line between the endpoints, and thus are \n\nunsuitable.\n\nSo, just two pairs of points out of 15 are acceptable candidates for hanging the banner wire.\n", "inputFormat": "\\* Line 1: Four space-separated integers: W, H, L1, and L2\n", "outputFormat": "\\* Line 1: A single integer denoting the number of possible banners\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO10NOV] Banner S", "background": "题目大意(by:曹彦臣)：\n\n\n平面上有(0,0)到(n,m)的(n+1)\\*(m+1)个点。问有多少点对所连的线段不过其他点，且长度在[l,h]范围内。\n", "description": "Bessie is returning from a long trip abroad, and Farmer John wants to erect a nice 'Welcome Home' banner in her pasture for her arrival. The banner will hang between two poles on a wire whose length is in the range L1..L2 (1 <= L1 <= L2; L1 <= L2 <= 1,500).\n\nThe pasture's size is W x H (1 <= W <= 1,000; 1 <= H <= 1,000), and Farmer John has installed a post at every point with integer\n\ncoordinates. Of these (W + 1) \\* (H + 1) points, Farmer John must pick just two that will hold either end of the wire from which he will hang the banner.\n\nFJ wants no interference with his banner as it hangs and requires that no post be directly under the tight wire he stretches between the two chosen posts.\n\nFarmer John needs your help to figure out how many possible ways he can hang the banner. He knows the number is large and that a 32-bit integer might not be sufficient to compute the answer.\n\nConsider the example pasture below, with W = 2 and H = 1: \n\n\\* \\* \\*\n\\* \\* \\*\nThe banner size is in the range 2..3. This pasture contains (2+1) \\* (1+1) = 6 points and has (6 take 2) = (6\\*5)/(2\\*1) = 15 different potential pairs of points between which the banner-holding wire might stretch:\n\n```cpp\n(0,0)-(0,1)   (0,0)-(2,1)   (0,1)-(2,1)   (1,1)-(2,0) \n(0,0)-(1,0)   (0,1)-(1,0)   (1,0)-(1,1)   (1,1)-(2,1) \n(0,0)-(1,1)   (0,1)-(1,1)   (1,0)-(2,0)   (2,0)-(2,1) \n(0,0)-(2,0)   (0,1)-(2,0)   (1,0)-(2,1) \n```\nOf these pairs, only four have a length in the range 2..3:\nLen                       Len\n\n(0,0)-(2,0) 2.00          (0,1)-(2,0) 2.24 \n\n(0,0)-(2,1) 2.24          (0,1)-(2,1) 2.00 \n\nOf these four, the pairs (0,0)-(2,0) and (0,1)-(2,1) both have a post directly on the line between the endpoints, and thus are \n\nunsuitable.\n\nSo, just two pairs of points out of 15 are acceptable candidates for hanging the banner wire.\n", "inputFormat": "\\* Line 1: Four space-separated integers: W, H, L1, and L2\n", "outputFormat": "\\* Line 1: A single integer denoting the number of possible banners\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO10NOV] Banner S", "background": "", "description": "Bessie 刚从国外长途旅行回来，农夫约翰想在她的牧场里竖起一个漂亮的「欢迎回家」横幅。横幅将挂在两根柱子之间的电线上，电线的长度范围是 $L_1..L_2$，其中 $1 \\le L_1 \\le L_2$，且 $L_1 \\le L_2 \\le 1,500$。\n\n牧场的大小为 $W \\times H$，其中 $1 \\le W \\le 1,000$，$1 \\le H \\le 1,000$，农夫约翰在每个整数坐标点上都安装了一根柱子。在这些 $(W + 1) \\times (H + 1)$ 个点中，农夫约翰必须选择两个点来固定电线的两端，以便悬挂横幅。\n\n约翰希望横幅悬挂时不受干扰，并要求在他拉紧的电线下方没有柱子。\n\n农夫约翰需要你的帮助来计算他有多少种可能的方式来悬挂横幅。他知道这个数量很大，32 位整数可能不足以计算出答案。\n\n考虑下面的牧场示例，其中 $W = 2$ 和 $H = 1$：\n\n\\* \\* \\*\n\\* \\* \\*\n横幅的长度范围是 $2..3$。这个牧场包含 $(2+1) \\times (1+1) = 6$ 个点，并且有 $\\binom{6}{2} = \\frac{6\\times5}{2\\times1} = 15$ 对不同的点对，可以在其间拉伸横幅固定电线：\n\n```cpp\n(0,0)-(0,1)   (0,0)-(2,1)   (0,1)-(2,1)   (1,1)-(2,0) \n(0,0)-(1,0)   (0,1)-(1,0)   (1,0)-(1,1)   (1,1)-(2,1) \n(0,0)-(1,1)   (0,1)-(1,1)   (1,0)-(2,0)   (2,0)-(2,1) \n(0,0)-(2,0)   (0,1)-(2,0)   (1,0)-(2,1) \n```\n在这些点对中，只有四对的长度在 $2..3$ 的范围内：\n长度                       长度\n\n(0,0)-(2,0) 2.00          (0,1)-(2,0) 2.24 \n\n(0,0)-(2,1) 2.24          (0,1)-(2,1) 2.00 \n\n在这四对中，点对 (0,0)-(2,0) 和 (0,1)-(2,1) 的连线上都有柱子，因此不合适。\n\n所以，在 15 对点中，只有两对是合适的悬挂横幅电线的候选者。\n", "inputFormat": "\\* 第 1 行：四个用空格分隔的整数：$W$，$H$，$L_1$ 和 $L_2$。\n", "outputFormat": "\\* 第 1 行：一个整数，表示可能的横幅数量。\n", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2998", "type": "P", "difficulty": 4, "samples": [["10 2 2 1 \n3 \n5 \n4 \n2 \n", "12 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO"], "title": "[USACO10NOV] Candy S", "background": null, "description": "FJ 知道贝茜喜欢吃糖果。FJ 有 $N (1 \\le N \\le 40000)$ 颗糖果，他想在若干天内将这些糖果送给贝茜。每一天，FJ 会让贝茜从他提供的一个列表中选择她当天想吃多少糖果，该列表有 $Nopt(1 \\le Nopt \\le 50)$ 种不同的选项 $C_i (1 \\le C_i \\le N)$ 。她必须恰好拿走 $C_i$ 颗糖果。\n\n农夫约翰给出了 $F(1 \\le F \\le 50)$ 个他喜欢的数字 $FN_i (1 \\le FN_i \\le N)$ 。每当一天结束时，如果剩余的糖果数量恰好等于这些数字之一，贝茜可以选择添加 $M（1 \\le M \\le 100)$ 颗糖果。如果添加糖果后又出现了另一个 FJ 喜欢的数字，贝茜可能会再次获得添加 $M$ 颗糖果的机会。在最好的情况下，贝茜可以获得无限多的糖果！\n\n当贝茜无法在列表中选择糖果数量（因为糖果不够）时，她就无法再获得更多糖果。\n\n不幸的是，贝茜不知道该如何规划才能吃掉尽可能多的糖果，所以她需要你的帮助。\n\n举例来说，考虑以下场景：\n\n* FJ 最初有 $10$ 颗糖果\n* 贝茜每天可以选择吃掉 $3$ 或 $5$ 颗糖果\n* 当剩余的糖果数量是 $2$ 或 $4$ 时，FJ 会添加 $1$ 颗糖果\n\n贝茜可以使用以下选择来最大化她能吃掉的糖果数量：\n\n```cpp\n                  初始糖果数     吃掉糖果数     剩余糖果数     奖励糖果数     最终糖果数\n        第1天        10            3            7             0            7\n        第2天         7            3            4             1            5\n        第3天         5            3            2             1            3\n        第4天         3            3            0             0            0\n```", "inputFormat": "* 第 $1$ 行：四个由空格分隔的整数：$N,Nopt,F,M$\n* 第 $2$ 行到第 $Nopt+1$ 行：第 $i+1$ 行包含一个整数：$C_i$\n* 第 $Nopt+2$ 行到第 $Nopt+F+1$ 行：第 $i+Nopt+1$ 行包含一个整数：$FN_i$", "outputFormat": "* 第 $1$ 行：一个整数，表示贝茜能吃掉的最大糖果数量，如果贝茜能吃掉无限多的糖果，则输出 `-1`。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[USACO10NOV] Candy S", "background": "", "description": "Farmer John knows that Bessie loves to eat candy. FJ has N (1 <= N <= 40,000) candies that he wants to give Bessie over some number of days. Each day, Farmer John gives Bessie a choice of how many candies she chooses to eat that day by choosing the number from a master list FJ supplies that has Nopt (1 <= Nopt <= 50) different options, C\\_i (1 <= C\\_i <= N). She must take exactly C\\_i candies, no more, no less.\n\nFarmer John has also disclosed F (1 <= F <= 50) of his favorite numbers, FN\\_i (1 <= FN\\_i <= N). Whenever the number of candies remaining at the end of the day precisely matches one of these favorite numbers, Bessie has the option to have him add exactly M (1 <= M <= 100) more candies to the candy supply. Bessie might get another option to add M candies several times if adding candies creates another favorite number. In the best circumstances, Bessie can obtain an infinite amount of candy!\n\nWhen Bessie cannot choose some amount of candy to take (because there is not enough), and the number of candies remaining is not any of FJ's favorite numbers, she cannot have any more candy.\n\nUnfortunately, Bessie cannot think ahead as far as she'd like to, so she needs your help in order to eat as many candies as possible.\n\nBy way of example, consider this scenario:\n\n\\* Farmer John's basket initially contains 10 candies\n\n\\* Bessie can chose to eat either 3 or 5 candies each day\n\n\\* Farmer John will add 1 candy any time the remaining number of candies is 2 or 4\n\nBessie could use this set of choices to maximize the amount of candy she can eat:\n\n```cpp\n\n                  Initial      # Candies   Remaining     Bonus     Final\n        Day      # Candies       Eaten      Candies     Candies   Candies\n\n         1          10             3          7            0        7\n         2           7             3          4            1        5\n         3           5             3          2            1        3\n         4           3             3          0            0        0\n\n```\n\nTotal candies eaten = 3 + 3 + 3 + 3 = 12. \n\n", "inputFormat": "\\* Line 1: Four space-separated integers: N, Nopt, F, and M\n\n\\* Lines 2..Nopt+1: Line i+1 contains a single integer: C\\_i\n\n\\* Lines Nopt+2..Nopt+F+1: Line i+Nopt+1 contains a single integer: FN\\_i\n\n\n\n", "outputFormat": "\\* Line 1: A single integer, denoting the maximum amount of candies Bessie can eat, or -1 if  Bessie can eat an infinite amount of candy.\n\n\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO10NOV] Candy S", "background": null, "description": "FJ 知道贝茜喜欢吃糖果。FJ 有 $N (1 \\le N \\le 40000)$ 颗糖果，他想在若干天内将这些糖果送给贝茜。每一天，FJ 会让贝茜从他提供的一个列表中选择她当天想吃多少糖果，该列表有 $Nopt(1 \\le Nopt \\le 50)$ 种不同的选项 $C_i (1 \\le C_i \\le N)$ 。她必须恰好拿走 $C_i$ 颗糖果。\n\n农夫约翰给出了 $F(1 \\le F \\le 50)$ 个他喜欢的数字 $FN_i (1 \\le FN_i \\le N)$ 。每当一天结束时，如果剩余的糖果数量恰好等于这些数字之一，贝茜可以选择添加 $M（1 \\le M \\le 100)$ 颗糖果。如果添加糖果后又出现了另一个 FJ 喜欢的数字，贝茜可能会再次获得添加 $M$ 颗糖果的机会。在最好的情况下，贝茜可以获得无限多的糖果！\n\n当贝茜无法在列表中选择糖果数量（因为糖果不够）时，她就无法再获得更多糖果。\n\n不幸的是，贝茜不知道该如何规划才能吃掉尽可能多的糖果，所以她需要你的帮助。\n\n举例来说，考虑以下场景：\n\n* FJ 最初有 $10$ 颗糖果\n* 贝茜每天可以选择吃掉 $3$ 或 $5$ 颗糖果\n* 当剩余的糖果数量是 $2$ 或 $4$ 时，FJ 会添加 $1$ 颗糖果\n\n贝茜可以使用以下选择来最大化她能吃掉的糖果数量：\n\n```cpp\n                  初始糖果数     吃掉糖果数     剩余糖果数     奖励糖果数     最终糖果数\n        第1天        10            3            7             0            7\n        第2天         7            3            4             1            5\n        第3天         5            3            2             1            3\n        第4天         3            3            0             0            0\n```", "inputFormat": "* 第 $1$ 行：四个由空格分隔的整数：$N,Nopt,F,M$\n* 第 $2$ 行到第 $Nopt+1$ 行：第 $i+1$ 行包含一个整数：$C_i$\n* 第 $Nopt+2$ 行到第 $Nopt+F+1$ 行：第 $i+Nopt+1$ 行包含一个整数：$FN_i$", "outputFormat": "* 第 $1$ 行：一个整数，表示贝茜能吃掉的最大糖果数量，如果贝茜能吃掉无限多的糖果，则输出 `-1`。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2999", "type": "P", "difficulty": 3, "samples": [["9 \n1 4 \n3 5 \n2 4 \n5 6 \n6 7 \n7 8 \n4 6 \n7 9 \n", "6 \n7 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO"], "title": "[USACO10NOV] Chocolate Milk S", "background": "", "description": "Farmer John's milk production and shipping system is an intricate one! He uses milking machines for his many cows to harvest the milk that then flows into pipes.\n\nEach of these pipes connects a milking machine to a joint, where it might be joined by exactly one more pipe (the milk flowing through both pipes merges). The milk then flows through additional pipes (which all start and end at joints) until it reaches the long central pipe connecting to the distribution room.\n\nThe milk then goes through a reverse process of splitting at various joints until it is flows into milk tanks that are picked up and taken to market.\n\nFarmer John notices that there is at most one way for milk to travel from one joint to any other joint. Furthermore, since Farmer John is an efficient man by nature, he has made sure that milk will flow through each and every pipe; in other words, no pipe is unneeded.\n\nIf we think of a milking machine, joint, or milk tank as a node, there are N (2 <= N <= 100,000) nodes in total (and N-1 pipes\n\nconnecting them). The input describes each pipe as an ordered pair of nodes, A\\_i (1 <= A\\_i <= N) and B\\_i (1 <= B\\_i <= N; A\\_i < B\\_i) indicating milk flows from node A\\_i to node B\\_i. If there is no pipe coming in to A\\_i, it is a milking machine. Likewise, if no pipe goes out from B\\_i, it is a tank.\n\nThe demand of chocolate milk has skyrocketed in recent months, and Farmer John wants to install a chocolate inserter at one of the joints so he can create delicious chocolate milk for customers.\n\nBeing thrifty, Farmer John has only bought one chocolate inserter, so he wants to place it at a joint through which all the milk passes. He knows that such a joint exists.\n\nHelp Farmer John find all the possible places he can install the chocolate inserter.  (Note that Farmer John cannot install the chocolate inserter at the same location as a milking machine.)\n\nAs an example, consider a milking setup like this one:\n\n```cpp\n\n           1 ----+\n                 |\n                 v\n           2 --> 4 --> 6 ------------------> 7 --> 8\n                       ^                     |\n                       |                     |\n           3 --> 5 ----+                     + --> 9\n\n```\nVisual inspection shows that the chocolate inserter can be installed at either joint 6 or 7, as all milk flows through those joints.\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N: Line i+1 contains two space-separated integers that describe a pipe's connectivity: A\\_i and B\\_i\n", "outputFormat": "\\* Lines 1..??: Integers, one per line and in ascending order, each denoting a possible joint at which to install the chocolate inserter.", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO10NOV] Chocolate Milk S", "background": "", "description": "Farmer John's milk production and shipping system is an intricate one! He uses milking machines for his many cows to harvest the milk that then flows into pipes.\n\nEach of these pipes connects a milking machine to a joint, where it might be joined by exactly one more pipe (the milk flowing through both pipes merges). The milk then flows through additional pipes (which all start and end at joints) until it reaches the long central pipe connecting to the distribution room.\n\nThe milk then goes through a reverse process of splitting at various joints until it is flows into milk tanks that are picked up and taken to market.\n\nFarmer John notices that there is at most one way for milk to travel from one joint to any other joint. Furthermore, since Farmer John is an efficient man by nature, he has made sure that milk will flow through each and every pipe; in other words, no pipe is unneeded.\n\nIf we think of a milking machine, joint, or milk tank as a node, there are N (2 <= N <= 100,000) nodes in total (and N-1 pipes\n\nconnecting them). The input describes each pipe as an ordered pair of nodes, A\\_i (1 <= A\\_i <= N) and B\\_i (1 <= B\\_i <= N; A\\_i < B\\_i) indicating milk flows from node A\\_i to node B\\_i. If there is no pipe coming in to A\\_i, it is a milking machine. Likewise, if no pipe goes out from B\\_i, it is a tank.\n\nThe demand of chocolate milk has skyrocketed in recent months, and Farmer John wants to install a chocolate inserter at one of the joints so he can create delicious chocolate milk for customers.\n\nBeing thrifty, Farmer John has only bought one chocolate inserter, so he wants to place it at a joint through which all the milk passes. He knows that such a joint exists.\n\nHelp Farmer John find all the possible places he can install the chocolate inserter.  (Note that Farmer John cannot install the chocolate inserter at the same location as a milking machine.)\n\nAs an example, consider a milking setup like this one:\n\n```cpp\n\n           1 ----+\n                 |\n                 v\n           2 --> 4 --> 6 ------------------> 7 --> 8\n                       ^                     |\n                       |                     |\n           3 --> 5 ----+                     + --> 9\n\n```\nVisual inspection shows that the chocolate inserter can be installed at either joint 6 or 7, as all milk flows through those joints.\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N: Line i+1 contains two space-separated integers that describe a pipe's connectivity: A\\_i and B\\_i\n", "outputFormat": "\\* Lines 1..??: Integers, one per line and in ascending order, each denoting a possible joint at which to install the chocolate inserter.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO10NOV] Chocolate Milk S", "background": null, "description": "农民约翰的牛奶生产和运输是一个复杂的过程，他用挤奶器给他的那么多头奶牛挤奶，然后流入管道。\n\n每一个管道把一台挤奶器和一个可能连有一台或多台挤奶器的接口连接起来（这样几个管道里的牛奶就汇合了）。然后牛奶流入附加管道（连在各个接口之间的管道）直到流到中央管道，通向储存室。 然后这些牛奶又经历一个逆向的过程通过管道分流到各个牛奶桶，最后被运至市场。\n\n约翰发现对于牛奶来说，最多只有一种方式从一个接口流到另一个接口。并且由于约翰是一个高效率的人，他需要确保每一个管道都有牛奶经过，也就是说，没有多余的管道。\n\n如果我们把每个挤奶机、接口和奶罐都看成一个节点，就共有 $N$ 个节点，输入有序的节点对 $A_{i}$ 和 $B_{i}$ ，代表牛奶从 $A_{i}$ 节点流到 $B_{i}$ 节点，如果没有相对应的父节点，那就说明这是一个挤奶器，同样的如果没有对应的尾节点，则这是一个奶罐。\n\n这几个月巧克力牛奶的需求量激增，所以约翰想要在某一个接口处安装一个巧克力混合器以得到巧克力牛奶，为了节约，约翰只买了一个巧克力混合器。所以他想把这个东西放到一个所有牛奶都能经过的接口，事实上，有这种接口存在。\n\n帮助约翰找到这样的节点（注意：不能把巧克力混合器放在挤奶机里）。\n```\n\n           1 ----+\n                 |\n                 v\n           2 --> 4 --> 6 ------------------> 7 --> 8\n                       ^                     |\n                       |                     |\n           3 --> 5 ----+                     + --> 9\n\n```\n所有的牛奶都会流经6号或7号节点，所以巧克力混合器可以放在这两个节点上。", "inputFormat": "第 $1$ 行一个整数 $N$（$2\\le N\\le10^5$）。\n\n第 $2$ 到第 $N$ 行：包含空格分隔的两个整数，描述第 $i$ 个管道连接的两个节点：$A_{i}$ 和 $B_{i}$（$1\\le A_{i}<B_{i}\\le N$）。", "outputFormat": "第 $1$ 行到 ？？行：每行一个整数，升序输出每个可以安装巧克力混合器的节点。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3000", "type": "P", "difficulty": 5, "samples": [["7 2 \n6 7 \n3 4 \n6 5 \n1 2 \n3 2 \n4 5 \n", "2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "二分", "USACO", "树的直径"], "title": "[USACO10DEC] Cow Calisthenics G", "background": null, "description": "Farmer John 为了保持奶牛们的健康，让可怜的奶牛们不停在牧场之间的小路上奔跑。这些奶牛的路径集合可以被表示成一个点集和一些连接两个顶点的双向路，使得每对点之间恰好有一条简单路径。简单的说来， 这些点的布局就是一棵树，且每条边等长，都为 $1$。\n\n对于给定的一个奶牛路径集合，精明的奶牛们会计算出任意点对路径的最大值， 我们称之为这个路径集合的直径。如果直径太大，奶牛们就会拒绝锻炼。\n\nFarmer John 把每个点标记为 $1\\cdots V(2\\le V\\le 10^5)$。为了获得更加短的直径，他可以选择封锁一些已经存在的道路，这样就可以得到更多的路径集合， 从而减小一些路径集合的直径。我们从一棵树开始，Farmer John 可以选择封锁 $S(1\\le S\\le V-1)$ 条双向路，从而获得 $S+1$个路径集合。\n\n你要做的是计算出最佳的封锁方案，使得他得到的所有路径集合直径的最大值尽可能小。Farmer John 告诉你所有 $V-1$ 条双向道路，每条表述为：顶点 $A_i(1\\le A_i\\le V)$ 和 $B_i(1\\le B_i\\le V,A_i\\ne B_i)$ 连接。", "inputFormat": "第 $1$ 行：两个空格分隔的整数：$V$ 和 $S$，\n\n第 $2$ 到 $V$ 行：两个空格分隔的整数：$A_i$ 和 $B_i$。", "outputFormat": "一个整数，这是 FJ 用 $s$ 块可以实现的最佳最大路径长度", "hint": "Consider this rather linear cowpath set (a tree with 7 vertices):\n\n1---2---3---4---5---6---7\n\nIf FJ can block two paths, he might choose them to make a map like this:\n\n1---2 | 3---4 | 5---6---7 where the longest pathlength is 2, which would be the answer in this case. He can do no better than this.", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10DEC] Cow Calisthenics G", "background": "", "description": "To keep the cows healthy, Farmer John makes the poor cows run back and forth along paths between pastures. The cows’ path system can be represented as a set of vertices and some bidirectional roads connecting pairs of vertices, such that between every pair of vertices there is exactly one simple path. In other words, the layout of these vertices forms a tree, and every edge has the same length, equal to $1$.\n\nFor a given cowpath set, the clever cows compute the maximum distance between any pair of vertices, which we call the diameter of this path set. If the diameter is too large, the cows will refuse to exercise.\n\nFarmer John labels each vertex $1\\cdots V(2\\le V\\le 10^5)$. To obtain a smaller diameter, he can choose to block some existing roads, thus producing more cowpath sets and potentially reducing the diameters of some of them. Starting from a tree, Farmer John may block $S(1\\le S\\le V-1)$ bidirectional roads, thereby obtaining $S+1$ cowpath sets.\n\nYour task is to compute the best blocking plan so that the maximum diameter among all resulting cowpath sets is as small as possible. Farmer John gives you all $V-1$ bidirectional roads, each described as: vertices $A_i(1\\le A_i\\le V)$ and $B_i(1\\le B_i\\le V,A_i\\ne B_i)$ are connected.", "inputFormat": "Line 1: Two space-separated integers: $V$ and $S$.\n\nLines 2 to $V$: Two space-separated integers: $A_i$ and $B_i$.", "outputFormat": "A single integer, the best possible maximum path length that FJ can achieve using $S$ blocked roads.", "hint": "Consider this rather linear cowpath set (a tree with 7 vertices):\n\n1---2---3---4---5---6---7\n\nIf FJ can block two paths, he might choose them to make a map like this:\n\n1---2 | 3---4 | 5---6---7 where the longest path length is 2, which would be the answer in this case. He can do no better than this.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO10DEC] Cow Calisthenics G", "background": null, "description": "Farmer John 为了保持奶牛们的健康，让可怜的奶牛们不停在牧场之间的小路上奔跑。这些奶牛的路径集合可以被表示成一个点集和一些连接两个顶点的双向路，使得每对点之间恰好有一条简单路径。简单的说来， 这些点的布局就是一棵树，且每条边等长，都为 $1$。\n\n对于给定的一个奶牛路径集合，精明的奶牛们会计算出任意点对路径的最大值， 我们称之为这个路径集合的直径。如果直径太大，奶牛们就会拒绝锻炼。\n\nFarmer John 把每个点标记为 $1\\cdots V(2\\le V\\le 10^5)$。为了获得更加短的直径，他可以选择封锁一些已经存在的道路，这样就可以得到更多的路径集合， 从而减小一些路径集合的直径。我们从一棵树开始，Farmer John 可以选择封锁 $S(1\\le S\\le V-1)$ 条双向路，从而获得 $S+1$个路径集合。\n\n你要做的是计算出最佳的封锁方案，使得他得到的所有路径集合直径的最大值尽可能小。Farmer John 告诉你所有 $V-1$ 条双向道路，每条表述为：顶点 $A_i(1\\le A_i\\le V)$ 和 $B_i(1\\le B_i\\le V,A_i\\ne B_i)$ 连接。", "inputFormat": "第 $1$ 行：两个空格分隔的整数：$V$ 和 $S$，\n\n第 $2$ 到 $V$ 行：两个空格分隔的整数：$A_i$ 和 $B_i$。", "outputFormat": "一个整数，这是 FJ 用 $s$ 块可以实现的最佳最大路径长度", "hint": "Consider this rather linear cowpath set (a tree with 7 vertices):\n\n1---2---3---4---5---6---7\n\nIf FJ can block two paths, he might choose them to make a map like this:\n\n1---2 | 3---4 | 5---6---7 where the longest pathlength is 2, which would be the answer in this case. He can do no better than this.", "locale": "zh-CN"}}}
{"pid": "P3001", "type": "P", "difficulty": 3, "samples": [["3 4 60 1 2 \n1 2 0.2 \n1 3 5 \n3 2 0.5 \n2 1 5 \n", "12.00 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO", "Special Judge", "最短路"], "title": "[USACO10DEC] Big Macs Around the World G", "background": "", "description": "Bessie is studying her favorite subject, Macroeconomics, in cowllege. For her final project, she will be presenting research on exchange rates between countries around the world.\n\n\nIn order to make her presentation more lively, she would like to show the relative prices of Big Macs around the world, despite their rather unsavory contents. To illustrate, suppose that Bessie would like to find smallest value of a Big Mac in a country given its value in some initial country and exchange rates from which other country's values can be calculated (as illustrated below):\n\n\n\n\n```cpp\n* A Big Mac is worth 60 dollars in the United States \n* The exchange rate from US dollars to Canadian dollars is 0.2 Canadian dollars per US dollar \n* The exchange rate from US dollars to British Pounds is 5.00 British Pounds per US Dollar \n* The exchange rate from British Pounds to Canadian dollars is 0.5 Canadian dollars per British Pound \n* The exchange rate between Canadian dollars to US dollars is 5.00 US dollars per Canadian dollar and Bessie would like to find the smallest possible value of a Big Mac in Canada that can be obtained by exchanging currencies. There are two ways: \n* Going from US dollars directly to Canada dollars would yield a burger worth 60.00 US dollars * 0.2 Canadian dollars / US dollar = 12.00 Canadian dollars \n* Going from US dollars to British Pounds to Canadian dollars would yield a burger worth 60.00 US$ * 5.00 GBP / 1 US$ * 0.5 C$ / 1 GBP = 150.00 C$ (Canadian dollars). \n```\nBessie would choose the former option, since she would much rather pay 12.00 Canadian dollars instead of 150.00 Canadian dollars for a Big Mac in Canada. \n\nBessie has N (1 <= N <= 2,000) countries conveniently labeled 1 to N that she would like to consider along with a list of M (1 <= M <= 25,000) exchange rates e_ij (0.1 < e_ij <= 10), each between countries i and j (1 <= i <= N; 1 <= j <= N). \n\nGiven the value V (1 <= V <= 1,000,000,000,000), which is not necessarily an integer, of the Big Mac in her starting country A (1 <= A <= N), help her find the smallest possible value of a Big Mac in country B (1 <= B <= N; B != A) after a series of currency conversions. If there is no minimum, output 0. \n\nIt is guaranteed that the answer is, if not 0, between 1 and 10^15.\n\nIt is also guaranteed that, for any country's currency, it is possible to get to any other country's currency.\n\n\n\n", "inputFormat": "Line 1: Five space-separated numbers: N, M, V, A, B\n\nLines 2..M+1: Three space-separated numbers: i, j, e\\_ij\n", "outputFormat": "Line 1: A single positive number, the price of the Big Mac, with absolute or relative error at most 10^-6. If there is no minimum, output 0.", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO10DEC] Big Macs Around the World G", "background": "", "description": "Bessie is studying her favorite subject, Macroeconomics, in cowllege. For her final project, she will be presenting research on exchange rates between countries around the world.\n\n\nIn order to make her presentation more lively, she would like to show the relative prices of Big Macs around the world, despite their rather unsavory contents. To illustrate, suppose that Bessie would like to find smallest value of a Big Mac in a country given its value in some initial country and exchange rates from which other country's values can be calculated (as illustrated below):\n\n\n\n\n```cpp\n* A Big Mac is worth 60 dollars in the United States \n* The exchange rate from US dollars to Canadian dollars is 0.2 Canadian dollars per US dollar \n* The exchange rate from US dollars to British Pounds is 5.00 British Pounds per US Dollar \n* The exchange rate from British Pounds to Canadian dollars is 0.5 Canadian dollars per British Pound \n* The exchange rate between Canadian dollars to US dollars is 5.00 US dollars per Canadian dollar and Bessie would like to find the smallest possible value of a Big Mac in Canada that can be obtained by exchanging currencies. There are two ways: \n* Going from US dollars directly to Canada dollars would yield a burger worth 60.00 US dollars * 0.2 Canadian dollars / US dollar = 12.00 Canadian dollars \n* Going from US dollars to British Pounds to Canadian dollars would yield a burger worth 60.00 US$ * 5.00 GBP / 1 US$ * 0.5 C$ / 1 GBP = 150.00 C$ (Canadian dollars). \n```\nBessie would choose the former option, since she would much rather pay 12.00 Canadian dollars instead of 150.00 Canadian dollars for a Big Mac in Canada. \n\nBessie has N (1 <= N <= 2,000) countries conveniently labeled 1 to N that she would like to consider along with a list of M (1 <= M <= 25,000) exchange rates e_ij (0.1 < e_ij <= 10), each between countries i and j (1 <= i <= N; 1 <= j <= N). \n\nGiven the value V (1 <= V <= 1,000,000,000,000), which is not necessarily an integer, of the Big Mac in her starting country A (1 <= A <= N), help her find the smallest possible value of a Big Mac in country B (1 <= B <= N; B != A) after a series of currency conversions. If there is no minimum, output 0. \n\nIt is guaranteed that the answer is, if not 0, between 1 and 10^15.\n\nIt is also guaranteed that, for any country's currency, it is possible to get to any other country's currency.\n\n\n\n", "inputFormat": "Line 1: Five space-separated numbers: N, M, V, A, B\n\nLines 2..M+1: Three space-separated numbers: i, j, e\\_ij\n", "outputFormat": "Line 1: A single positive number, the price of the Big Mac, with absolute or relative error at most 10^-6. If there is no minimum, output 0.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO10DEC] Big Macs Around the World G", "background": "", "description": "Bessie 正在学习她最喜欢的科目宏观经济学，作为她最后一门学科，她将对世界各种货币的汇率进行研究。\n\n为了让她的演讲更加生动，她会展示一个叫做 BM 的商品在全世界的相对价格。举个例子，Bessie 会通过其他国家的汇率去找到一件 BM 在一个国家的最小价值。\n\n- 一件 BM 在美国值 $60$ 美元；\n- 美元与加拿大元的汇率为 $1$ 美元换 $0.2$ 加拿大元（$1:0.2$）。\n- 美元与英镑的汇率为 $1$ 美元换 $5$ 英镑（$1:5$）。\n- 英镑与加拿大元的汇率为 $1$ 英镑换 $0.5$ 加拿大元（$1:0.5$）。\n- 加拿大元与美元的汇率是 $5$ 美元换一加拿大元（$5:1$），Bessie 有两种方法通过货币兑换在加拿大这个国家找到一件 BM 的最低价值：\n\n1. 拿着美元直接去加拿大，通过汇率得出一件 BM 只要 $12$ 加拿大元；\n2. 拿着美元去英国，兑换为英镑后再去加拿大，得出一件 BM 要 $150$ 加拿大元。\n\nBessie 会选择前一种方案因为她更乐意为在加拿大买一件 BM 支付 $12$ 加元而不是 $150$ 加元。\n\nBessie 有 $N(1\\leq N\\leq 2000)$ 个国家的信息和 $M(1\\leq M\\leq25000)$ 种汇率，在 $i,j$ 国间的汇率表示为 $e_{ij}(0.1\\leq e_{ij}\\leq 10)$。\n\n给你一个值 $V(1\\leq V\\leq 10^{12})$，$V$ 不一定是一个整数。$V$ 是 BM 在起始国家 A 的价格，帮助 Bessie 寻找到在 B 国 BM 最低的价格，如果不存在，则输出 $0$。\n\n据保证答案小于 $10^{15}$，也保证所有国家都可以通过汇率将钱币转为别的国家的。", "inputFormat": "第 $1$ 行：五个数：$N,M,V,A,B$，分别一个空格隔开。\n\n第 $2$ 到 $M+1$ 行：三个数 $i,j,e_{ij}$，分别一个空格隔开。", "outputFormat": "一行：BM 在 B 国的最低价格，精确到 $10^{-6}$。如果没有最小值，输出 $0$。\n\n**注意，本题的汇率是单向的**。\n\n感谢 @JJYZ\\_cbh 的耐心翻译", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3002", "type": "P", "difficulty": 6, "samples": [["38 9 \nTHEQUICKBROWNFOXDO \nGJUMPSOVERTHELAZYDOG \nFOXDOG \nDOG \n", "2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2010", "USACO", "后缀自动机 SAM", "后缀数组 SA"], "title": "[USACO10DEC] Threatening Letter G", "background": null, "description": "FJ 刚刚和邻居发生了一场可怕的争吵，他咽不下这口气，于是决定佚名发给他的邻居一封脏话连篇的信。他有无限张完全相同的已经打印好的纸张，都包含 $N$ 个字母（用一个长为 $N$ 的字符串表示）。他有一把举世无双的剪刀，可以从某张纸中通过一刀剪出连续的一段（也可以通过一刀获得整个字符串），然后将剪出的段落拼成 $M$ 个字母长的一封信（用一个长为 $M$ 的字符串表示）。他想知道获得这封信最少需要剪多少刀。保证这总是可能的。\n\n注意：输入中以上两个字符串均被摊到了若干行中。", "inputFormat": "第一行，两个正整数 $N, M$，含义见上。\n\n接下来若干行，一共 $N$ 个字母，表示纸上原有内容。\n\n接下来若干行，一共 $M$ 个字母，表示 FJ 想要拼出的信的内容。\n\n保证每行不超过 $80$ 个字符。", "outputFormat": "一行一个整数，表示最少需要剪多少次。", "hint": "$1\\le N,M\\le 5*10^4$", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10DEC] Threatening Letter G", "background": null, "description": "FJ has had a terrible fight with his neighbor and wants to send him a nasty letter, but wants to remain anonymous. As so many before him have done, he plans to cut out printed letters and paste them onto a sheet of paper. He has an infinite number of the most recent issue of the Moo York Times that has $N$ ($1 \\le N \\le 50,000$) uppercase letters laid out in a long string (though read in as a series of shorter strings). Likewise, he has a message he'd like to compose that is a single long string of letters but that is read in as a set of shorter strings.\n\nBeing lazy, he wants to make the smallest possible number of cuts. FJ has a really great set of scissors that enables him to remove any single-line snippet from the Moo York Times with one cut. He notices that he can cut entire words or phrases with a single cut, thus reducing his total number of cuts.\n\nWhat is the minimum amount of cuts he has to make to construct his letter of $M$ ($1 \\le M \\le 50,000$) letters?\n\nIt is guaranteed that it is possible for FJ to complete his task.\n\nConsider a 38 letter Moo York Times:\n\n```cpp\nTHEQUICKBROWNFOXDO \nGJUMPSOVERTHELAZYDOG\n```\nfrom which FJ wants to construct a 9 letter message: \n```cpp\nFOXDOG \nDOG \n```\n\nThese input lines represent a pair of strings:\n\n`THEQUICKBROWNFOXDOGJUMPSOVERTHELAZYDOG`\n\n`FOXDOGDOG `\n\nSince `FOXDOG` exists in the newspaper, FJ can cut this piece out and then get the last `DOG` by cutting out either instance of the word `DOG`. \n\nThus, he requires but two cuts.", "inputFormat": "\\* Line 1: Two space-separated integers: $N$ and $M$\n\n\\* Lines 2..?: $N$ letters laid out on several input lines; this is the text of the one copy of the Moo York Times. Each line will have no more than 80 characters.\n\n\\* Lines ?..?: $M$ letters that are the text of FJ's letter. Each line will have no more than 80 characters.", "outputFormat": "\\* Line 1: The minimum number of cuts FJ has to make to create his message", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO10DEC] Threatening Letter G", "background": null, "description": "FJ 刚刚和邻居发生了一场可怕的争吵，他咽不下这口气，于是决定佚名发给他的邻居一封脏话连篇的信。他有无限张完全相同的已经打印好的纸张，都包含 $N$ 个字母（用一个长为 $N$ 的字符串表示）。他有一把举世无双的剪刀，可以从某张纸中通过一刀剪出连续的一段（也可以通过一刀获得整个字符串），然后将剪出的段落拼成 $M$ 个字母长的一封信（用一个长为 $M$ 的字符串表示）。他想知道获得这封信最少需要剪多少刀。保证这总是可能的。\n\n注意：输入中以上两个字符串均被摊到了若干行中。", "inputFormat": "第一行，两个正整数 $N, M$，含义见上。\n\n接下来若干行，一共 $N$ 个字母，表示纸上原有内容。\n\n接下来若干行，一共 $M$ 个字母，表示 FJ 想要拼出的信的内容。\n\n保证每行不超过 $80$ 个字符。", "outputFormat": "一行一个整数，表示最少需要剪多少次。", "hint": "$1\\le N,M\\le 5*10^4$", "locale": "zh-CN"}}}
{"pid": "P3003", "type": "P", "difficulty": 3, "samples": [["9 7 5 1 4 \n5 1 7 \n6 7 2 \n4 7 2 \n5 6 1 \n5 2 4 \n4 3 2 \n1 2 3 \n3 2 2 \n2 6 3 \n", "12 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO", "最短路"], "title": "[USACO10DEC] Apple Delivery S", "background": "", "description": "Bessie has two crisp red apples to deliver to two of her friends in the herd. Of course, she travels the C (1 <= C <= 200,000)\n\ncowpaths which are arranged as the usual graph which connects P (1 <= P <= 100,000) pastures conveniently numbered from 1..P: no cowpath leads from a pasture to itself, cowpaths are bidirectional, each cowpath has an associated distance, and, best of all, it is always possible to get from any pasture to any other pasture. Each cowpath connects two differing pastures P1\\_i (1 <= P1\\_i <= P) and P2\\_i (1 <= P2\\_i <= P) with a distance between them of D\\_i. The sum of all the distances D\\_i does not exceed 2,000,000,000.\n\nWhat is the minimum total distance Bessie must travel to deliver both apples by starting at pasture PB (1 <= PB <= P) and visiting pastures PA1 (1 <= PA1 <= P) and PA2 (1 <= PA2 <= P) in any order. All three of these pastures are distinct, of course.\n\nConsider this map of bracketed pasture numbers and cowpaths with distances:\n\n```cpp\n               3        2       2\n           [1]-----[2]------[3]-----[4]\n             \\     / \\              /\n             7\\   /4  \\3           /2\n               \\ /     \\          /\n               [5]-----[6]------[7]\n                    1       2\n```\nIf Bessie starts at pasture [5] and delivers apples to pastures [1] and [4], her best path is:\n\n5 -> 6-> 7 -> 4\\* -> 3 -> 2 -> 1\\*\n\nwith a total distance of 12.", "inputFormat": "\\* Line 1: Line 1 contains five space-separated integers: C, P, PB, PA1, and PA2\n\n\\* Lines 2..C+1: Line i+1 describes cowpath i by naming two pastures it connects and the distance between them: P1\\_i, P2\\_i, D\\_i\n", "outputFormat": "\\* Line 1: The shortest distance Bessie must travel to deliver both apples\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO10DEC] Apple Delivery S", "background": "", "description": "Bessie has two crisp red apples to deliver to two of her friends in the herd. Of course, she travels the C (1 <= C <= 200,000)\n\ncowpaths which are arranged as the usual graph which connects P (1 <= P <= 100,000) pastures conveniently numbered from 1..P: no cowpath leads from a pasture to itself, cowpaths are bidirectional, each cowpath has an associated distance, and, best of all, it is always possible to get from any pasture to any other pasture. Each cowpath connects two differing pastures P1\\_i (1 <= P1\\_i <= P) and P2\\_i (1 <= P2\\_i <= P) with a distance between them of D\\_i. The sum of all the distances D\\_i does not exceed 2,000,000,000.\n\nWhat is the minimum total distance Bessie must travel to deliver both apples by starting at pasture PB (1 <= PB <= P) and visiting pastures PA1 (1 <= PA1 <= P) and PA2 (1 <= PA2 <= P) in any order. All three of these pastures are distinct, of course.\n\nConsider this map of bracketed pasture numbers and cowpaths with distances:\n\n```cpp\n               3        2       2\n           [1]-----[2]------[3]-----[4]\n             \\     / \\              /\n             7\\   /4  \\3           /2\n               \\ /     \\          /\n               [5]-----[6]------[7]\n                    1       2\n```\nIf Bessie starts at pasture [5] and delivers apples to pastures [1] and [4], her best path is:\n\n5 -> 6-> 7 -> 4\\* -> 3 -> 2 -> 1\\*\n\nwith a total distance of 12.", "inputFormat": "\\* Line 1: Line 1 contains five space-separated integers: C, P, PB, PA1, and PA2\n\n\\* Lines 2..C+1: Line i+1 describes cowpath i by naming two pastures it connects and the distance between them: P1\\_i, P2\\_i, D\\_i\n", "outputFormat": "\\* Line 1: The shortest distance Bessie must travel to deliver both apples\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO10DEC] Apple Delivery S", "background": null, "description": "Bessie 有两只鲜红的苹果要送给她在牛群中的两个朋友。当然，她要走 $C$ 条牛道（$1 \\le C \\le 2\\times 10^5$），这些牛道构成了一个常见的图，方便地连接了 $P$ 个牧场（$1 \\le P \\le 10^5$），这些牧场的编号从 $1$ 到 $P$：没有牛道从一个牧场通向自身，牛道是双向的，每条牛道都有一个相关的距离，最重要的是，总是可以从任何一个牧场到达另一个牧场。每条牛道连接两个不同的牧场 $P1_i$（$1 \\le P1_i \\le P$）和 $P2_i$（$1 \\le P2_i \\le P$），它们之间的距离为 $D_i$。所有距离 $D_i$ 的总和不超过 $2\\times 10^9$。\n\nBessie 要从牧场 $PB$（$1 \\le PB \\le P$）出发，按任意顺序访问牧场 $PA_1$（$1 \\le PA_1 \\le P$）和 $PA_2$（$1 \\le PA_2 \\le P$），送完两个苹果后，求她必须行走的最小总距离。当然，这三个牧场是不同的。\n\n考虑这个用括号标注牧场编号和牛道距离的地图：\n\n```cpp\n               3        2       2\n           [1]-----[2]------[3]-----[4]\n             \\     / \\              /\n             7\\   /4  \\3           /2\n               \\ /     \\          /\n               [5]-----[6]------[7]\n                    1       2\n```\n如果 Bessie 从牧场 $[5]$ 出发，将苹果送到牧场 $[1]$ 和 $[4]$，她的最佳路径是：\n\n$5$ -> $6$ -> $7$ -> $4*$ -> $3$ -> $2$ -> $1*$\n\n总距离为 $12$。", "inputFormat": "\\* 第 $1$ 行：包含五个用空格分隔的整数：$C, P, PB, PA_1 $ 和 $PA_2$。\n\n\\* 第 $2$ 行到第 $C+1$ 行：第 $i+1$ 行描述牛道 $i$，给出它连接的两个牧场及其之间的距离：$P1_i$, $P2_i$, $D_i$。", "outputFormat": "\\* 第 $1$ 行：Bessie 必须行走的最短距离。", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P3004", "type": "P", "difficulty": 4, "samples": [["4 \n30 \n25 \n10 \n35 \n", "60 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["动态规划 DP", "递推", "2010", "USACO"], "title": "[USACO10DEC] Treasure Chest S", "background": "", "description": "Bessie and Bonnie have found a treasure chest full of marvelous gold coins! Being cows, though, they can't just walk into a store and buy stuff, so instead they decide to have some fun with the coins.\n\nThe N (1 <= N <= 5,000) coins, each with some value C\\_i (1 <= C\\_i <= 5,000) are placed in a straight line. Bessie and Bonnie take turns, and for each cow's turn, she takes exactly one coin off of either the left end or the right end of the line. The game ends when there are no coins left.\n\nBessie and Bonnie are each trying to get as much wealth as possible for themselves. Bessie goes first. Help her figure out the maximum value she can win, assuming that both cows play optimally.\n\nConsider a game in which four coins are lined up with these values:\n\n30  25  10  35\n\nConsider this game sequence:\n\nBessie    Bonnie       New Coin\n\nPlayer   Side   CoinValue   Total     Total         Line\n\nBessie   Right     35        35         0       30  25  10\n\nBonnie   Left      30        35        30         25  10\n\nBessie   Left      25        60        30           10\n\nBonnie   Right     10        60        40           --\n\nThis is the best game Bessie can play.\n\n小 A 和小 B 在玩游戏。\n\n初始时，有 $n$ 个硬币被摆成了一行，从左至右数第 $i$ 个硬币的价值为 $c_i$。\n\n小 A 和小 B 每人一回合，在一个人的回合中，他可以选择**当前**硬币序列最左侧或者最右侧的硬币，并将他从序列中取出，将其价值累加到自己获得的累计价值中，然后进行另一个人的回合。当硬币全部被取走时，游戏结束。\n\n请求出在双方都尽可能的使自己累计价值最大的情况下，若由小 A 进行第一回合，那么他能获得的累计价值最大是多少。", "inputFormat": "输入的第一行是一个整数 $n$，代表硬币的个数。\n\n第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i + 1)$ 行的整数代表第 $i$ 个硬币的价值 $c_i$。", "outputFormat": "输出一行一个整数，代表小 A 能获得的最大累计价值。", "hint": "#### 输入输出样例 $1$ 解释\n\n初始时，硬币序列为 $\\{30,~25,~10,~35\\}$。\n\n第一回合，小 A 取走最右侧的硬币，序列变为 $\\{30,~25,~10\\}$，小 A 的累加价值为 $35$。\n\n第二回合，小 B 取走最左侧的硬币，序列变为 $\\{25,~10\\}$，小 B 的累加价值为 $30$。\n\n第三回合，小 A 取走最左侧的硬币，序列变为 $\\{10\\}$，小 A 的累加价值为 $35 + 25 = 60$。\n\n第四回合，小 B 取走最左侧的硬币，序列变为空，小 B 的累加价值为 $30 + 10 = 40$，游戏结束。\n\n小 A 获得的最大累计价值为 $60$。\n\n#### 数据范围与约定\n\n对于全部的测试点，$1 \\leq n \\leq 5 \\times 10^3$，$1 \\leq c_i \\leq 5 \\times 10^3$。\n\n**提示：请注意，本题的空间限制为 $64$ Mib。**", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10DEC] Treasure Chest S", "background": "", "description": "Two players, A and B, are playing a game.\n\nInitially, there are $n$ coins in a line. From left to right, the value of the $i$-th coin is $c_i$.\n\nA and B take turns, one move per turn. On a player's turn, they must choose the leftmost or the rightmost coin from the current sequence, remove it from the sequence, and add its value to their own total. The game ends when all coins have been taken.\n\nAssuming both players play optimally to maximize their own total value, and player A moves first, determine the maximum total value that A can obtain.", "inputFormat": "- The first line contains an integer $n$, the number of coins.\n- Lines $2$ to $(n + 1)$ each contain one integer. The integer on line $(i + 1)$ is the value $c_i$ of the $i$-th coin.", "outputFormat": "Output a single integer: the maximum total value that player A can obtain.", "hint": "- Sample explanation:\n\n  Initially, the coin sequence is $\\{30,~25,~10,~35\\}$.\n\n  - Turn 1: A takes the rightmost coin, the sequence becomes $\\{30,~25,~10\\}$, and A’s total is $35$.\n  - Turn 2: B takes the leftmost coin, the sequence becomes $\\{25,~10\\}$, and B’s total is $30$.\n  - Turn 3: A takes the leftmost coin, the sequence becomes $\\{10\\}$, and A’s total is $35 + 25 = 60$.\n  - Turn 4: B takes the leftmost coin, the sequence becomes empty, and B’s total is $30 + 10 = 40$. The game ends.\n\n  The maximum total value that A can obtain is $60$.\n\n- Constraints:\n\n  For all testdata, $1 \\leq n \\leq 5 \\times 10^3$, $1 \\leq c_i \\leq 5 \\times 10^3$.\n\n- Note: The memory limit is $64$ MiB.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO10DEC] Treasure Chest S", "background": "", "description": "Bessie and Bonnie have found a treasure chest full of marvelous gold coins! Being cows, though, they can't just walk into a store and buy stuff, so instead they decide to have some fun with the coins.\n\nThe N (1 <= N <= 5,000) coins, each with some value C\\_i (1 <= C\\_i <= 5,000) are placed in a straight line. Bessie and Bonnie take turns, and for each cow's turn, she takes exactly one coin off of either the left end or the right end of the line. The game ends when there are no coins left.\n\nBessie and Bonnie are each trying to get as much wealth as possible for themselves. Bessie goes first. Help her figure out the maximum value she can win, assuming that both cows play optimally.\n\nConsider a game in which four coins are lined up with these values:\n\n30  25  10  35\n\nConsider this game sequence:\n\nBessie    Bonnie       New Coin\n\nPlayer   Side   CoinValue   Total     Total         Line\n\nBessie   Right     35        35         0       30  25  10\n\nBonnie   Left      30        35        30         25  10\n\nBessie   Left      25        60        30           10\n\nBonnie   Right     10        60        40           --\n\nThis is the best game Bessie can play.\n\n小 A 和小 B 在玩游戏。\n\n初始时，有 $n$ 个硬币被摆成了一行，从左至右数第 $i$ 个硬币的价值为 $c_i$。\n\n小 A 和小 B 每人一回合，在一个人的回合中，他可以选择**当前**硬币序列最左侧或者最右侧的硬币，并将他从序列中取出，将其价值累加到自己获得的累计价值中，然后进行另一个人的回合。当硬币全部被取走时，游戏结束。\n\n请求出在双方都尽可能的使自己累计价值最大的情况下，若由小 A 进行第一回合，那么他能获得的累计价值最大是多少。", "inputFormat": "输入的第一行是一个整数 $n$，代表硬币的个数。\n\n第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i + 1)$ 行的整数代表第 $i$ 个硬币的价值 $c_i$。", "outputFormat": "输出一行一个整数，代表小 A 能获得的最大累计价值。", "hint": "#### 输入输出样例 $1$ 解释\n\n初始时，硬币序列为 $\\{30,~25,~10,~35\\}$。\n\n第一回合，小 A 取走最右侧的硬币，序列变为 $\\{30,~25,~10\\}$，小 A 的累加价值为 $35$。\n\n第二回合，小 B 取走最左侧的硬币，序列变为 $\\{25,~10\\}$，小 B 的累加价值为 $30$。\n\n第三回合，小 A 取走最左侧的硬币，序列变为 $\\{10\\}$，小 A 的累加价值为 $35 + 25 = 60$。\n\n第四回合，小 B 取走最左侧的硬币，序列变为空，小 B 的累加价值为 $30 + 10 = 40$，游戏结束。\n\n小 A 获得的最大累计价值为 $60$。\n\n#### 数据范围与约定\n\n对于全部的测试点，$1 \\leq n \\leq 5 \\times 10^3$，$1 \\leq c_i \\leq 5 \\times 10^3$。\n\n**提示：请注意，本题的空间限制为 $64$ Mib。**", "locale": "zh-CN"}}}
{"pid": "P3005", "type": "P", "difficulty": 3, "samples": [["4 4 \n1000 1 \n0110 1 \n1001 1 \n0011 1 \n", "1010 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO"], "title": "[USACO10DEC] The Trough Game S", "background": "", "description": "Farmer John and Bessie are playing games again. This one has to do with troughs of water.\n\nFarmer John has hidden N (1 <= N <= 20) troughs behind the barn, and has filled some of them with food. Bessie has asked M (1 <= M <= 100) questions of the form, 'How many troughs from this list (which she recites) are filled?'.\n\nBessie needs your help to deduce which troughs are actually filled.\n\nConsider an example with four troughs where Bessie has asked these questions (and received the indicated answers):\n\n1) 'How many of these troughs are filled: trough 1' -->  1 trough is filled\n\n2) 'How many of these troughs are filled: troughs 2 and 3' -->  1 trough is filled\n\n3) 'How many of these troughs are filled: troughs 1 and 4' -->  1 trough is filled\n\n4) 'How many of these troughs are filled: troughs 3 and 4' -->  1 trough is filled\n\nFrom question 1, we know trough 1 is filled.\n\nFrom question 3, we then know trough 4 is empty. \n\nFrom question 4, we then know that trough 3 is filled. \n\nFrom question 2, we then know that trough 2 is empty. \n\nFarmer John 和 Bessie 在玩一个游戏。\n\nFarmer John 准备了 $n$ 个槽（$1\\le n\\le20$），其中一些槽中藏有食物。Bessie 为了知道哪些槽中有食物，会询问 $m$ 个形如“第 $x_1\\cdots x_k$ 号槽中是否有食物？”的问题（$1\\le m\\le100,1\\le k\\le n$）。\n\n请你帮忙求出哪几个槽中有食物。\n\n\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..M+1: A subset of troughs, specified as a sequence of contiguous N 0's and 1's, followed by a single integer that is the number of troughs in the specified subset that are filled.\n\n第一行包含两个整数 $n,m$，分别表示槽的个数和 Bessie 询问的问题数。\n\n接下来 $m$ 行每行包含一个长度为 $n$ 的 $01$ 序列和一个整数 $t$，其中 $01$ 序列中的 $1$ 表示询问中提到了这个位置的槽，$t$ 表示这些槽中有 $t$ 份食物。\n", "outputFormat": "\\* Line 1: A single line with:\n\n\\* The string 'IMPOSSIBLE' if there is no possible set of filled troughs compatible with Farmer John's answers.\n\n\\* The string 'NOT UNIQUE' if Bessie cannot determine from the given data exactly what troughs are filled.\n\n\\* Otherwise, a sequence of contiguous N 0's and 1's specifying which troughs are filled.\n\n\n\n输出共一行。\n\n若无解，则输出 `IMPOSSIBLE`。\n\n若不止一个解，则输出 `NOT UNIQUE`。\n\n若有唯一解，则输出一个 $01$ 序列，其中 $1$ 表示这个位置的槽中有食物。", "hint": "### 样例解释\n四个序列分别表示如下对话：\n\n1. 问：在第一个槽中有多少个槽里有食物？——答：$1$ 个。\n2. 问：在第二个和第三个槽中有多少个槽里有食物？——答：$1$ 个。\n3. 问：在第一个和第四个槽中有多少个槽里有食物？——答：$1$ 个。\n4. 问：在第三个和第四个槽中有多少个槽里有食物？——答：$1$ 个。\n\n从第一个问题可以知道，第一个槽是有食物的。\n\n从第三个问题可以知道，第四个槽是没有食物的。\n\n从第四个问题可以知道，第三个槽是有食物的。\n\n从第二个问题可以知道，第二个槽是没有食物的。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10DEC] The Trough Game S", "background": "", "description": "Farmer John and Bessie are playing games again. This one has to do with troughs of water.\n\nFarmer John has hidden N (1 <= N <= 20) troughs behind the barn, and has filled some of them with food. Bessie has asked M (1 <= M <= 100) questions of the form, 'How many troughs from this list (which she recites) are filled?'.\n\nBessie needs your help to deduce which troughs are actually filled.\n\nConsider an example with four troughs where Bessie has asked these questions (and received the indicated answers):\n\n1) 'How many of these troughs are filled: trough 1' --> 1 trough is filled.\n\n2) 'How many of these troughs are filled: troughs 2 and 3' --> 1 trough is filled.\n\n3) 'How many of these troughs are filled: troughs 1 and 4' --> 1 trough is filled.\n\n4) 'How many of these troughs are filled: troughs 3 and 4' --> 1 trough is filled.\n\nFrom question 1, we know trough 1 is filled.\n\nFrom question 3, we then know trough 4 is empty.\n\nFrom question 4, we then know that trough 3 is filled.\n\nFrom question 2, we then know that trough 2 is empty.\n\nFarmer John and Bessie are playing a game.\n\nFarmer John has prepared $n$ troughs ($1 \\le n \\le 20$), and some of them contain food. To figure out which troughs contain food, Bessie asks $m$ questions of the form “How many of the troughs numbered $x_1 \\cdots x_k$ are filled?” ($1 \\le m \\le 100$, $1 \\le k \\le n$).\n\nPlease determine which troughs contain food.", "inputFormat": "- Line 1: Two space-separated integers: N and M.\n\n- Lines 2..M+1: A subset of troughs, specified as a sequence of contiguous N 0's and 1's, followed by a single integer that is the number of troughs in the specified subset that are filled.\n\nThe first line contains two integers $n, m$, denoting the number of troughs and the number of questions, respectively.\n\nEach of the next $m$ lines contains a $01$ string of length $n$ and an integer $t$, where a $1$ in the $01$ string indicates the trough at that position is included in the query, and $t$ is the number of included troughs that are filled.", "outputFormat": "- Line 1: A single line with:\n- The string 'IMPOSSIBLE' if there is no possible set of filled troughs compatible with Farmer John's answers.\n- The string 'NOT UNIQUE' if Bessie cannot determine from the given data exactly what troughs are filled.\n- Otherwise, a sequence of contiguous N 0's and 1's specifying which troughs are filled.\n\nIf there is no solution, print `IMPOSSIBLE`.\n\nIf there is more than one solution, print `NOT UNIQUE`.\n\nIf there is a unique solution, print a $01$ string in which a $1$ indicates the trough at that position contains food.", "hint": "Sample explanation:\nThe four sequences correspond to the following dialogue:\n\n1. Q: How many of the first troughs contain food? — A: $1$.\n2. Q: How many of the second and third troughs contain food? — A: $1$.\n3. Q: How many of the first and fourth troughs contain food? — A: $1$.\n4. Q: How many of the third and fourth troughs contain food? — A: $1$.\n\nFrom the first question, we can tell the first trough contains food.\n\nFrom the third question, we can tell the fourth trough does not contain food.\n\nFrom the fourth question, we can tell the third trough contains food.\n\nFrom the second question, we can tell the second trough does not contain food.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO10DEC] The Trough Game S", "background": "", "description": "Farmer John and Bessie are playing games again. This one has to do with troughs of water.\n\nFarmer John has hidden N (1 <= N <= 20) troughs behind the barn, and has filled some of them with food. Bessie has asked M (1 <= M <= 100) questions of the form, 'How many troughs from this list (which she recites) are filled?'.\n\nBessie needs your help to deduce which troughs are actually filled.\n\nConsider an example with four troughs where Bessie has asked these questions (and received the indicated answers):\n\n1) 'How many of these troughs are filled: trough 1' -->  1 trough is filled\n\n2) 'How many of these troughs are filled: troughs 2 and 3' -->  1 trough is filled\n\n3) 'How many of these troughs are filled: troughs 1 and 4' -->  1 trough is filled\n\n4) 'How many of these troughs are filled: troughs 3 and 4' -->  1 trough is filled\n\nFrom question 1, we know trough 1 is filled.\n\nFrom question 3, we then know trough 4 is empty. \n\nFrom question 4, we then know that trough 3 is filled. \n\nFrom question 2, we then know that trough 2 is empty. \n\nFarmer John 和 Bessie 在玩一个游戏。\n\nFarmer John 准备了 $n$ 个槽（$1\\le n\\le20$），其中一些槽中藏有食物。Bessie 为了知道哪些槽中有食物，会询问 $m$ 个形如“第 $x_1\\cdots x_k$ 号槽中是否有食物？”的问题（$1\\le m\\le100,1\\le k\\le n$）。\n\n请你帮忙求出哪几个槽中有食物。\n\n\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..M+1: A subset of troughs, specified as a sequence of contiguous N 0's and 1's, followed by a single integer that is the number of troughs in the specified subset that are filled.\n\n第一行包含两个整数 $n,m$，分别表示槽的个数和 Bessie 询问的问题数。\n\n接下来 $m$ 行每行包含一个长度为 $n$ 的 $01$ 序列和一个整数 $t$，其中 $01$ 序列中的 $1$ 表示询问中提到了这个位置的槽，$t$ 表示这些槽中有 $t$ 份食物。\n", "outputFormat": "\\* Line 1: A single line with:\n\n\\* The string 'IMPOSSIBLE' if there is no possible set of filled troughs compatible with Farmer John's answers.\n\n\\* The string 'NOT UNIQUE' if Bessie cannot determine from the given data exactly what troughs are filled.\n\n\\* Otherwise, a sequence of contiguous N 0's and 1's specifying which troughs are filled.\n\n\n\n输出共一行。\n\n若无解，则输出 `IMPOSSIBLE`。\n\n若不止一个解，则输出 `NOT UNIQUE`。\n\n若有唯一解，则输出一个 $01$ 序列，其中 $1$ 表示这个位置的槽中有食物。", "hint": "### 样例解释\n四个序列分别表示如下对话：\n\n1. 问：在第一个槽中有多少个槽里有食物？——答：$1$ 个。\n2. 问：在第二个和第三个槽中有多少个槽里有食物？——答：$1$ 个。\n3. 问：在第一个和第四个槽中有多少个槽里有食物？——答：$1$ 个。\n4. 问：在第三个和第四个槽中有多少个槽里有食物？——答：$1$ 个。\n\n从第一个问题可以知道，第一个槽是有食物的。\n\n从第三个问题可以知道，第四个槽是没有食物的。\n\n从第四个问题可以知道，第三个槽是有食物的。\n\n从第二个问题可以知道，第二个槽是没有食物的。", "locale": "zh-CN"}}}
{"pid": "P3006", "type": "P", "difficulty": 6, "samples": [["4 1 \n1 1 5 \n2 12 7 \n3 12 3 \n5 \n", "25 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "线段树", "USACO", "最短路", "树链剖分"], "title": "[USACO11JAN] Bottleneck G", "background": "", "description": "Farmer John is gathering the cows. His farm contains a network of N (1 <= N <= 100,000) fields conveniently numbered 1..N and connected by N-1 unidirectional paths that eventually lead to field 1. The fields and paths form a tree.\n\nEach field i > 1 has a single one-way, exiting path to field P\\_i, and currently contains C\\_i cows (1 <= C\\_i <= 1,000,000,000). In each time unit, no more than M\\_i (0 <= M\\_i <= 1,000,000,000) cows can travel from field i to field P\\_i (1 <= P\\_i <= N) (i.e., only M\\_i cows can traverse the path).\n\nFarmer John wants all the cows to congregate in field 1 (which has no limit on the number of cows it may have). Rules are as follows:\n\n\\* Time is considered in discrete units.\n\n\\* Any given cow might traverse multiple paths in the same time unit. However, no more than M\\_i total cows can leave field i (i.e., traverse its exit path) in the same time unit.\n\n\\* Cows never move \\*away\\* from field #1.\n\nIn other words, every time step, each cow has the choice either to\n\na) stay in its current field\n\nb) move through one or more fields toward field #1, as long as the bottleneck constraints for each path are not violated\n\nFarmer John wants to know how many cows can arrive in field 1 by certain times. In particular, he has a list of K (1 <= K <= 10,000) times T\\_i (1 <= T\\_i <= 1,000,000,000), and he wants to know, for each T\\_i in the list, the maximum number of cows that can arrive at field 1 by T\\_i if scheduled to optimize this quantity.\n\nConsider an example where the tree is a straight line, and the T\\_i list contains only T\\_1=5, and cows are distibuted as shown:\n\n```cpp\nLocn:      1---2---3---4      <-- Pasture ID numbers \nC_i:       0   1   12  12     <-- Current number of cows \nM_i:           5   8   3      <-- Limits on path traversal; field 1 has no limit since it has no exit \nThe solution is as follows; the goal is to move cows to field 1: \n```\nTree:      1---2---3---4\n```cpp\nt=0        0   1   12  12     <-- Initial state \nt=1        5   4   7   9      <-- field 1 has cows from field 2 and 3 t=2        10  7   2   6 \nt=3        15  7   0   3 \nt=4        20  5   0   0 \nt=5        25  0   0   0 \nThus, the answer is 25: all 25 cows can arrive at field 1 by time t=5. \n", "inputFormat": "\\* Line 1: Two space-separated integers: N and K\n\n\\* Lines 2..N: Line i (not i+1) describes field i with three \n\nspace-separated integers: P\\_i, C\\_i, and M\\_i\n\n\\* Lines N+1..N+K: Line N+i contains a single integer: T\\_i\n", "outputFormat": "\\* Lines 1..K: Line i contains a single integer that is the maximum number of cows that can arrive at field 1 by time T\\_i.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO11JAN] Bottleneck G", "background": "", "description": "Farmer John is gathering the cows. His farm contains a network of N (1 <= N <= 100,000) fields conveniently numbered 1..N and connected by N-1 unidirectional paths that eventually lead to field 1. The fields and paths form a tree.\n\nEach field i > 1 has a single one-way, exiting path to field P\\_i, and currently contains C\\_i cows (1 <= C\\_i <= 1,000,000,000). In each time unit, no more than M\\_i (0 <= M\\_i <= 1,000,000,000) cows can travel from field i to field P\\_i (1 <= P\\_i <= N) (i.e., only M\\_i cows can traverse the path).\n\nFarmer John wants all the cows to congregate in field 1 (which has no limit on the number of cows it may have). Rules are as follows:\n\n\\* Time is considered in discrete units.\n\n\\* Any given cow might traverse multiple paths in the same time unit. However, no more than M\\_i total cows can leave field i (i.e., traverse its exit path) in the same time unit.\n\n\\* Cows never move \\*away\\* from field #1.\n\nIn other words, every time step, each cow has the choice either to\n\na) stay in its current field\n\nb) move through one or more fields toward field #1, as long as the bottleneck constraints for each path are not violated\n\nFarmer John wants to know how many cows can arrive in field 1 by certain times. In particular, he has a list of K (1 <= K <= 10,000) times T\\_i (1 <= T\\_i <= 1,000,000,000), and he wants to know, for each T\\_i in the list, the maximum number of cows that can arrive at field 1 by T\\_i if scheduled to optimize this quantity.\n\nConsider an example where the tree is a straight line, and the T\\_i list contains only T\\_1=5, and cows are distibuted as shown:\n\n```cpp\nLocn:      1---2---3---4      <-- Pasture ID numbers \nC_i:       0   1   12  12     <-- Current number of cows \nM_i:           5   8   3      <-- Limits on path traversal; field 1 has no limit since it has no exit \nThe solution is as follows; the goal is to move cows to field 1: \n```\nTree:      1---2---3---4\n```cpp\nt=0        0   1   12  12     <-- Initial state \nt=1        5   4   7   9      <-- field 1 has cows from field 2 and 3 t=2        10  7   2   6 \nt=3        15  7   0   3 \nt=4        20  5   0   0 \nt=5        25  0   0   0 \nThus, the answer is 25: all 25 cows can arrive at field 1 by time t=5. \n", "inputFormat": "\\* Line 1: Two space-separated integers: N and K\n\n\\* Lines 2..N: Line i (not i+1) describes field i with three \n\nspace-separated integers: P\\_i, C\\_i, and M\\_i\n\n\\* Lines N+1..N+K: Line N+i contains a single integer: T\\_i\n", "outputFormat": "\\* Lines 1..K: Line i contains a single integer that is the maximum number of cows that can arrive at field 1 by time T\\_i.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO11JAN] Bottleneck G", "background": null, "description": "Farmer John 正在聚集他的奶牛。他的农场包含了一个网络，这个网络由 $N(1\\le N\\le10^5)$ 块编号从 $1$ 到 $N$ 的田地构成，田地之间由 $N-1$ 条有向的路径连接，保证从每块田地出发都能到达 $1$ 号田地。这些田地和路径形成了一棵树的结构。\n\n每块满足编号大于 $1$ 的田地 $i$ 有一条有向路径连向 $P_i(1\\le P_i\\le N)$，同时这块田地上面有 $C_i(1\\le C_i\\le10^9)$ 头奶牛。在每个单位时间内，最多 $M_i(0\\le M_i\\le10^9)$ 头奶牛可以通过从 $i$ 连向 $P_i$ 的这条路径。\n\nFarmer John 想要让所有的奶牛集合到没有奶牛数量限制的田地 $1$ 上。但是这一过程要符合以下规则：\n\n- 时间是离散的。\n\n- 任何给定的奶牛在同一时间单位内都可能穿过多条路径。但在每个单位时间内，最多 $M_i(0\\le M_i\\le10^9)$ 头奶牛可以通过从 $i$ 连向 $P_i$ 的这条路径。\n\n- 奶牛不会从田地 $1$ 离开。\n\n换句话说，每一时刻，奶牛都必须从以下几项中选择一项：\n\n- 在它现在所在的田地里待着；\n\n- 沿着路径向着田地 $1$ 经过一块或多块田地，同时不能违反每条路径的 $M_i$ 的限制。\n\nFarmer John 想要知道在特定时间内有多少奶牛可以到达田地 $1$。具体的，他有一个包含了 $K(1\\le K\\le10^4)$ 个时间 $T_i(1\\le T_i\\le 10^9)$ 的列表，他想要知道，对于每一个列表中的 $T_i$，最多有多少头奶牛可以在 $T_i$ 时间内到达田地 $1$。", "inputFormat": "第一行：两个用空格分隔的整数：$N$ 和 $K$。\n\n第 $2$ 至 $N$ 行：第 $i$ 行用三个用空格分隔的整数描述了田地 $i$：$P_i$，$C_i$ 和 $M_i$。\n\n第 $N+1$ 至 $N+K$ 行：第 $N+i$ 行包含一个整数：$T_i$。", "outputFormat": "第 $1$ 至 $K$ 行：第 $i$ 行包含一个整数，表示可以在 $T_i$ 时间内到达田地 $1$ 的奶牛的数量的最大值。\n\ntranslated by 350558", "hint": "$1\\le P_i\\le N\\le10^5$，$1\\le C_i,T_i\\le10^9$，$0\\le M_i\\le10^9$，$1\\le K\\le10^4$。", "locale": "zh-CN"}}}
{"pid": "P3007", "type": "P", "difficulty": 5, "samples": [["3 4 \n1 Y 2 N \n1 N 2 N \n1 Y 3 Y \n1 Y 2 Y \n", "YN? \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "USACO", "2-SAT"], "title": "[USACO11JAN] The Continental Cowngress G", "background": "", "description": "Displeased with Farmer John's leadership, the cows have seceded from the farm and have formed the first Continental Cowngress. Built on the principle of 'every cow gets something they want,' they've decided on the following voting system:\n\nThe M (1 <= M <= 4000) cows in attendance will vote on  N (1 <= N <= 1,000) legislative bills. Each cow casts a 'yes' or 'no' vote (denoted as 'Y' or 'N' in the input file) on exactly two (distinct) bills B\\_i and C\\_i (1 <= B\\_i <= N; 1 <= C\\_i <= N). The votes are called VB\\_i (VB\\_i in {'Y', 'N'}) and VC\\_i (VC\\_i in {'Y', 'N'}) respectively.\n\nFinally, the bills are to be passed or not in such a way that every cow gets her way on at least one of her votes. For example, if Bessie votes 'yes' on Bill 1, and 'no' on Bill 2, then in any valid solution, it must be the case that either Bill 1 gets passed or Bill 2 gets rejected (or both).\n\nGiven the votes of each of the cows, it's your job to figure out which bills will be passed and which bills will be rejected in order to conform to the rules above.  If there is no solution, print 'IMPOSSIBLE'. If there is at least one solution, then for each bill, display:\n\nY  if in every solution this bill passes\n\nN  if in every solution this bill fails\n\n?  if there are solutions where this bill passes and solutions where it does not pass\n\nConsider the following set of votes (two for each cow): \n```\n- - - - - BILL - - - - -\n\n1        2        3\n\nCow 1   YES      NO\n\nCow 2   NO       NO\n\nCow 3   YES               YES\n\nCow 4   YES      YES\n```\nFrom this, two solutions satisfy every cow:\n\n\\* Bill 1 passes (this then satisfies cows 1, 3, and 4) \n\n\\* Bill 2 fails (this then satisfies cow 2) \n\n\\* Bill 3 could pass or fail (and this is the reason there are two solutions) \n\nIn fact, these are the only two solutions, so the answer is the three character string below:\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..M+1: Line i+1 describes cow i's votes with four\n\nspace-separated fields -- an integer, a vote, another integer, and another vote: B\\_i, VB\\_i, C\\_i, VC\\_i\n", "outputFormat": "\\* Line 1: A string with N characters, where the ith character is either a 'Y' if the ith bill must pass, an 'N' if the ith bill must fail, or a '?' if it cannot be determined whether the bill passes from these votes.\n\nIf there is no solution which satisfies every cow, then output the single line 'IMPOSSIBLE'.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO11JAN] The Continental Cowngress G", "background": "", "description": "Displeased with Farmer John's leadership, the cows have seceded from the farm and have formed the first Continental Cowngress. Built on the principle of 'every cow gets something they want,' they've decided on the following voting system:\n\nThe M (1 <= M <= 4000) cows in attendance will vote on  N (1 <= N <= 1,000) legislative bills. Each cow casts a 'yes' or 'no' vote (denoted as 'Y' or 'N' in the input file) on exactly two (distinct) bills B\\_i and C\\_i (1 <= B\\_i <= N; 1 <= C\\_i <= N). The votes are called VB\\_i (VB\\_i in {'Y', 'N'}) and VC\\_i (VC\\_i in {'Y', 'N'}) respectively.\n\nFinally, the bills are to be passed or not in such a way that every cow gets her way on at least one of her votes. For example, if Bessie votes 'yes' on Bill 1, and 'no' on Bill 2, then in any valid solution, it must be the case that either Bill 1 gets passed or Bill 2 gets rejected (or both).\n\nGiven the votes of each of the cows, it's your job to figure out which bills will be passed and which bills will be rejected in order to conform to the rules above.  If there is no solution, print 'IMPOSSIBLE'. If there is at least one solution, then for each bill, display:\n\nY  if in every solution this bill passes\n\nN  if in every solution this bill fails\n\n?  if there are solutions where this bill passes and solutions where it does not pass\n\nConsider the following set of votes (two for each cow): \n```\n- - - - - BILL - - - - -\n\n1        2        3\n\nCow 1   YES      NO\n\nCow 2   NO       NO\n\nCow 3   YES               YES\n\nCow 4   YES      YES\n```\nFrom this, two solutions satisfy every cow:\n\n\\* Bill 1 passes (this then satisfies cows 1, 3, and 4) \n\n\\* Bill 2 fails (this then satisfies cow 2) \n\n\\* Bill 3 could pass or fail (and this is the reason there are two solutions) \n\nIn fact, these are the only two solutions, so the answer is the three character string below:\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..M+1: Line i+1 describes cow i's votes with four\n\nspace-separated fields -- an integer, a vote, another integer, and another vote: B\\_i, VB\\_i, C\\_i, VC\\_i\n", "outputFormat": "\\* Line 1: A string with N characters, where the ith character is either a 'Y' if the ith bill must pass, an 'N' if the ith bill must fail, or a '?' if it cannot be determined whether the bill passes from these votes.\n\nIf there is no solution which satisfies every cow, then output the single line 'IMPOSSIBLE'.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO11JAN] The Continental Cowngress G", "background": null, "description": "由于对农场主约翰的领导不满，奶牛们已经从农场中分离出来，并成立了第一个大陆奶牛议会。基于「每头奶牛都能得到她想要的东西」这一原则，她们决定采用以下投票系统：\n\n出席的 $M$ 头奶牛将对 $N$ 项立法议案进行投票。每头奶牛对两个（不同的）议案 $B_i$ 和 $C_i$ 分别投下「赞成」或「反对」票（在输入文件中用 `Y` 或 `N` 表示）。这些投票分别称为 $VB_i$ 和 $VC_i$。\n\n最终，议案的通过与否必须满足每头奶牛至少有一个投票结果符合她的意愿。例如，如果 Bessie 对议案 $1$ 投了「赞成」票，对议案 $2$ 投了「反对」票，那么在任何有效的解决方案中，要么议案 $1$ 通过，要么议案 $2$ 被否决（或者两者都满足）。\n\n给定每头奶牛的投票情况，你的任务是找出哪些议案将被通过，哪些议案将被否决，以符合上述规则。如果没有解决方案，请输出 `IMPOSSIBLE`。如果至少有一个解决方案，那么对于每个议案，显示：\n\n`Y` 如果在每个解决方案中该议案都通过\n\n`N` 如果在每个解决方案中该议案都被否决\n\n`?` 如果存在一些解决方案中该议案通过，而在另一些解决方案中该议案没有通过\n\n考虑以下投票集（每头奶牛投两票）：  \n\n|编号|$1$|$2$|$3$|\n|:-:|:-:|:-:|:-:\n|奶牛 $1$|赞成|反对\n|奶牛 $2$|反对|反对\n|奶牛 $3$|赞成||赞成\n|奶牛 $4$|赞成|赞成\n\n由此，两个解决方案满足每头奶牛：\n\n+ 议案 $1$ 通过（这满足了奶牛 $1$、$3$ 和 $4$）\n+ 议案 $2$ 被否决（这满足了奶牛 $2$）\n+ 议案 $3$ 可以通过或被否决（这就是有两个解决方案的原因）\n\n事实上，这些是仅有的两个解决方案，因此答案是 `YN?`。", "inputFormat": "第 $1$ 行：两个用空格分隔的整数：$N$ 和 $M$\n\n第 $2$ 行到第 $M+1$ 行：第 $i+1$ 行描述奶牛 $i$ 的投票情况，包含四个用空格分隔的字段——一个整数，一个投票，另一个整数，和另一个投票：$B_i,VB_i,C_i,VC_i$", "outputFormat": "第 $1$ 行：一个包含 $N$ 个字符的字符串，其中第 $i$ 个字符是 `Y` 表示第 $i$ 个议案必须通过，`N` 表示第 $i$ 个议案必须被否决，或者 `?` 表示无法从这些投票中确定该议案是否通过。\n\n如果没有满足每头奶牛的解决方案，则输出单行 `IMPOSSIBLE`。", "hint": "对于 $100\\%$ 的数据，$1\\le M\\le4000$，$1\\le N\\le1000$，$1\\le B_i,C_i\\le N$，$VB_i,VC_i\\in\\{Y,N\\}$。  \n（本题由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
