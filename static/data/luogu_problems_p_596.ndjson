{"pid": "P13095", "type": "P", "difficulty": 2, "samples": [["6 2\n3 2 4 5 3 6\n2\n2 4\n3 6", "5\n6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "福建", "省赛/邀请赛"], "title": "[FJCPC 2025] 炒股高手", "background": "", "description": "小 A 立志成为一名炒股高手。经过长时间的学习，他自信已掌握了丰富的理论知识，并精心挑选出了一支股票，决定在接下来的 $n$ 个交易日内进行实战操作。\n\n股票之神向小 A 投来了注视，他帮你预知了接下来 $n$ 个交易日中这只股票的股价。由于股票之神擅长数学，所有价格均以自然对数的形式给出。也就是说，在第 $i$ 天（$1 \\leq i \\leq n$），会得到一个正整数 $a_i$，表示当天该股票的价格为 $e^{a_i}$ 元。需要注意的是，在本题中，小 A 可以购买非整数份的股票。\n\n由于手头资金有限，小 A 决定公开向他人借款，称为\"鸡债\"。为了方便管理和收益核算，他规定每位出借人均提供固定的 $e^k$ 元借款。\n\n在这 $n$ 天内，共有 $m$ 位出借人愿意向小 A 提供鸡债。\n\n对于第 $i$ 位出借人，他会在第 $s_i$ 天开盘前向小 A 提供 $e^k$ 元，在第 $t_i$ 天收盘后要求结算收益。在这段时间内，小 A 可自由使用这笔资金进行任意次数的买入与卖出操作。\n\n你的任务是：对于每一笔鸡债，计算小 A 在最优操作下所能获得的最终总资产（即本金加收益）的自然对数值 $k$，并输出该整数。\n换句话说，若小 A 最终通过操作将手中 $e^k$ 元变为 $e^w$ 元，则你应输出该整数 $w$。", "inputFormat": "第一行包含两个正整数 $n$（$1 \\leq n \\leq 10^5$） 和 $m$（$1 \\leq m \\leq 10^5$），分别表示交易日的数量以及鸡债的数量。\n\n第二行包含 $n$ 个正整数 $a_1, a_2, \\dots, a_n$（$1 \\leq a_i \\leq 10^4$），其中第 $i$ 天的股票价格为$e^{a_i}$。\n\n第三行包含一个正整数 $k$（$1 \\leq k \\leq 10^9$），表示每份鸡债提供的借款金额为$e^k$。\n\n接下来 $m$ 行，每行包含两个整数 $s_i$ 和 $t_i$（$1 \\leq s_i \\leq t_i \\leq n$），表示第 $i$ 份鸡债的借款开始日和收益结算日。", "outputFormat": "输出共 $m$ 行，每行一个正整数 $w_i$，表示第 $i$ 份鸡债的本金加收益总额为 $e^{w_i}$ 元。", "hint": "在样例中，一共有 $6$ 个交易日，$2$ 份鸡债。\n\n每天的股价为 $e^3, e^2, e^4, e^5, e^3, e^6$ 。\n\n鸡债的本金均为 $e^2$ 。\n\n第 $1$ 份鸡债：第 $2$ 天借出，在第 $4$ 天归还。\n\n第 $2$ 份鸡债：第 $3$ 天借出，在第 $6$ 天归还。\n\n对于第 $1$ 份鸡债：三天的股价为 $[e^2, e^4, e^5]$ ，最优方案为第 $2$ 天买入，第 $4$ 天卖出。最终资产为 $e^2 \\div e^2 \\times e^5 = e^5$ 。\n\n输出答案为 $5$ 。\n\n对于第 $2$ 份鸡债：四天的股价为 $[e^4, e^5, e^3, e^6]$ ，最优方案为第 $3$ 天买入，第 $4$ 天卖出，第 $5$ 天再买入，第 $6$ 天再卖出。最终资产为 $e^2 \\div e^4 \\times e^5 \\div e^3 \\times e ^6 = e^6$ 。\n\n输出答案为 $6$ 。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[FJCPC 2025] 炒股高手", "background": "", "description": "小 A 立志成为一名炒股高手。经过长时间的学习，他自信已掌握了丰富的理论知识，并精心挑选出了一支股票，决定在接下来的 $n$ 个交易日内进行实战操作。\n\n股票之神向小 A 投来了注视，他帮你预知了接下来 $n$ 个交易日中这只股票的股价。由于股票之神擅长数学，所有价格均以自然对数的形式给出。也就是说，在第 $i$ 天（$1 \\leq i \\leq n$），会得到一个正整数 $a_i$，表示当天该股票的价格为 $e^{a_i}$ 元。需要注意的是，在本题中，小 A 可以购买非整数份的股票。\n\n由于手头资金有限，小 A 决定公开向他人借款，称为\"鸡债\"。为了方便管理和收益核算，他规定每位出借人均提供固定的 $e^k$ 元借款。\n\n在这 $n$ 天内，共有 $m$ 位出借人愿意向小 A 提供鸡债。\n\n对于第 $i$ 位出借人，他会在第 $s_i$ 天开盘前向小 A 提供 $e^k$ 元，在第 $t_i$ 天收盘后要求结算收益。在这段时间内，小 A 可自由使用这笔资金进行任意次数的买入与卖出操作。\n\n你的任务是：对于每一笔鸡债，计算小 A 在最优操作下所能获得的最终总资产（即本金加收益）的自然对数值 $k$，并输出该整数。\n换句话说，若小 A 最终通过操作将手中 $e^k$ 元变为 $e^w$ 元，则你应输出该整数 $w$。", "inputFormat": "第一行包含两个正整数 $n$（$1 \\leq n \\leq 10^5$） 和 $m$（$1 \\leq m \\leq 10^5$），分别表示交易日的数量以及鸡债的数量。\n\n第二行包含 $n$ 个正整数 $a_1, a_2, \\dots, a_n$（$1 \\leq a_i \\leq 10^4$），其中第 $i$ 天的股票价格为$e^{a_i}$。\n\n第三行包含一个正整数 $k$（$1 \\leq k \\leq 10^9$），表示每份鸡债提供的借款金额为$e^k$。\n\n接下来 $m$ 行，每行包含两个整数 $s_i$ 和 $t_i$（$1 \\leq s_i \\leq t_i \\leq n$），表示第 $i$ 份鸡债的借款开始日和收益结算日。", "outputFormat": "输出共 $m$ 行，每行一个正整数 $w_i$，表示第 $i$ 份鸡债的本金加收益总额为 $e^{w_i}$ 元。", "hint": "在样例中，一共有 $6$ 个交易日，$2$ 份鸡债。\n\n每天的股价为 $e^3, e^2, e^4, e^5, e^3, e^6$ 。\n\n鸡债的本金均为 $e^2$ 。\n\n第 $1$ 份鸡债：第 $2$ 天借出，在第 $4$ 天归还。\n\n第 $2$ 份鸡债：第 $3$ 天借出，在第 $6$ 天归还。\n\n对于第 $1$ 份鸡债：三天的股价为 $[e^2, e^4, e^5]$ ，最优方案为第 $2$ 天买入，第 $4$ 天卖出。最终资产为 $e^2 \\div e^2 \\times e^5 = e^5$ 。\n\n输出答案为 $5$ 。\n\n对于第 $2$ 份鸡债：四天的股价为 $[e^4, e^5, e^3, e^6]$ ，最优方案为第 $3$ 天买入，第 $4$ 天卖出，第 $5$ 天再买入，第 $6$ 天再卖出。最终资产为 $e^2 \\div e^4 \\times e^5 \\div e^3 \\times e ^6 = e^6$ 。\n\n输出答案为 $6$ 。\n", "locale": "zh-CN"}}}
{"pid": "P13096", "type": "P", "difficulty": 4, "samples": [["3\n5 5\n2 3\n10000\n01000\n00110\n11001\n11111\n7 8\n3 3\n10101000\n01010100\n10000100\n01000010\n00100100\n00011010\n00000001\n7 8\n4 4\n10101000\n01010100\n10000100\n01000010\n00100100\n00011010\n00000001", "2\n3\n3\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "福建", "广度优先搜索 BFS", "省赛/邀请赛"], "title": "[FJCPC 2025] 难以控制的滑板火箭", "background": "", "description": "在一个 $n\\times m$ 的 `01` 网格中，其中第 $i$ 行第 $j$ 列的元素为 $a_{i,j}$，若 $a_{i,j}=1$ 则表示这个位置为空地，反之若 $a_{i,j}=0$ 则表示这个位置上有障碍物。\n\n现在小猫从 $(1,1)$ 出发，想要去 $(n,m)$。\n\n若小猫当前在 $(x,y)$ 则**一次移动**后可以到 $(x-1,y)$、$(x+1,y)$、$(x,y-1)$、$(x,y+1)$、$(x-1,y-1)$、$(x+1,y-1)$、$(x-1,y+1)$、$(x+1,y+1)$ 的位置上，注意不能移动到地图外，也不能走到障碍物上。即任意时候 $1\\leq x\\leq n,1\\leq y\\leq m,a_{x,y}=1$。\n\n因为小猫使用了难以控制的滑板火箭，每一分钟都会移动 $[l,r]$ 次。\n\n现在需要你求出小猫最少需要几分钟才能成功抵达终点（**必须要某一分钟的移动全部结束后小猫的位置在 $(n,m)$ 才算成功抵达**），如果无论经过多久都不能成功抵达请输出 `-1`。", "inputFormat": "第一行一个整数 $t$（$1\\leq t\\leq 1000$），表示测试数据组数。\n\n接下来对于每一组测试数据，第一行两个整数 $n,m$（$2\\leq n,m\\leq 1000$），表示 `01` 网格的大小。\n\n接下来一行包含两个整数 $l,r$（$1\\leq l\\leq r\\leq 10^9$），表示在一分钟内移动次数的限制范围。\n\n接下来 $n$ 行，每行 $m$ 个字符，表示网格的元素 $a_{i,j}$，字符仅会出现 `0` 或 `1`，且 $a_{1,1}$ 与 $a_{n,m}$ 一定为 $1$。\n\n保证所有测试数据的 $n\\times m$ 的和不超过 $10^6$。", "outputFormat": "对于每一组测试数据输出一行，如果小猫能在有限时间内抵达 $(n,m)$，那么输出最少需要的分钟数，否则输出 `-1`。", "hint": "对于第一组样例：\n\n在第一分钟 $(1,1)\\rightarrow (2,2)\\rightarrow (3,3)\\rightarrow (3,4)$；\n\n在第二分钟 $(3,4)\\rightarrow (4,5)\\rightarrow (5,5)$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[FJCPC 2025] 难以控制的滑板火箭", "background": "", "description": "在一个 $n\\times m$ 的 `01` 网格中，其中第 $i$ 行第 $j$ 列的元素为 $a_{i,j}$，若 $a_{i,j}=1$ 则表示这个位置为空地，反之若 $a_{i,j}=0$ 则表示这个位置上有障碍物。\n\n现在小猫从 $(1,1)$ 出发，想要去 $(n,m)$。\n\n若小猫当前在 $(x,y)$ 则**一次移动**后可以到 $(x-1,y)$、$(x+1,y)$、$(x,y-1)$、$(x,y+1)$、$(x-1,y-1)$、$(x+1,y-1)$、$(x-1,y+1)$、$(x+1,y+1)$ 的位置上，注意不能移动到地图外，也不能走到障碍物上。即任意时候 $1\\leq x\\leq n,1\\leq y\\leq m,a_{x,y}=1$。\n\n因为小猫使用了难以控制的滑板火箭，每一分钟都会移动 $[l,r]$ 次。\n\n现在需要你求出小猫最少需要几分钟才能成功抵达终点（**必须要某一分钟的移动全部结束后小猫的位置在 $(n,m)$ 才算成功抵达**），如果无论经过多久都不能成功抵达请输出 `-1`。", "inputFormat": "第一行一个整数 $t$（$1\\leq t\\leq 1000$），表示测试数据组数。\n\n接下来对于每一组测试数据，第一行两个整数 $n,m$（$2\\leq n,m\\leq 1000$），表示 `01` 网格的大小。\n\n接下来一行包含两个整数 $l,r$（$1\\leq l\\leq r\\leq 10^9$），表示在一分钟内移动次数的限制范围。\n\n接下来 $n$ 行，每行 $m$ 个字符，表示网格的元素 $a_{i,j}$，字符仅会出现 `0` 或 `1`，且 $a_{1,1}$ 与 $a_{n,m}$ 一定为 $1$。\n\n保证所有测试数据的 $n\\times m$ 的和不超过 $10^6$。", "outputFormat": "对于每一组测试数据输出一行，如果小猫能在有限时间内抵达 $(n,m)$，那么输出最少需要的分钟数，否则输出 `-1`。", "hint": "对于第一组样例：\n\n在第一分钟 $(1,1)\\rightarrow (2,2)\\rightarrow (3,3)\\rightarrow (3,4)$；\n\n在第二分钟 $(3,4)\\rightarrow (4,5)\\rightarrow (5,5)$。", "locale": "zh-CN"}}}
{"pid": "P13097", "type": "P", "difficulty": 4, "samples": [["2\n4\n11\n7\n11000", "-1\n6\n1 2\n1 3\n1 4\n2 5\n2 6\n3 7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "2025", "福建", "Special Judge", "构造", "省赛/邀请赛"], "title": "[FJCPC 2025] 割点", "background": null, "description": "给定一个正整数 $n$ 和一个长度为 $n-2$ 的 01 序列 $a_{2}, a_{3}, \\dots, a_{n-1}$，要求你构造一个 $n$ 个点的**无向简单连通图** $G$，使得：\n\n- 点 $1$ 是割点，点 $n$ 不是割点。\n\n- 对于每个 $1 < i < n$：\n\n若 $a_{i} = 1$，则点 $i$ 在图 $G$ 中是割点；\n\n若 $a_{i} = 0$，则点 $i$ 在图 $G$ 中不是割点。\n\n- 图 $G$ 中各顶点的度数满足：$\\rm{deg}_1\\geq \\rm{deg}_2\\geq\\dots\\geq \\rm{deg}_n$。\n\n如果存在多种可行的图，输出任意一种；如果不存在满足条件的图，则输出 $-1$。\n\n简单图的定义为：无重边（即任意一对点之间至多只有一条边）且无自环（即不存在一条边两端点相同）的图。\n\n割点的定义为：删掉该点以及它连的边后，使得图连通块个数增加的点。", "inputFormat": "**本题包含多组测试数据。**\n\n第一行一个正整数 $T$（$1\\leq T\\leq 500$），表示测试数据的组数。\n\n对于每组数据：\n\n第一行一个正整数 $n$（$4\\le n \\leq 1000$），表示图中点的个数。\n\n接下来一个长度为 $n - 2$ 的 01 串，表示序列 $a_{2}, a_{3}, \\dots, a_{n-1}$。\n\n保证所有数据的 $\\sum n\\leq 2000$。", "outputFormat": "对于每组数据：\n\n若无解，输出 $-1$；\n\n若有解，第一行输出 $m$ （$0<m\\leq \\frac{n(n-1)}{2}$），表示图的边数。接下来 $m$ 行，每行输出两个正整数，第 $i$ 行的两个正整数表示第 $i$ 条边两个点的编号。若有多种满足题意的图，你可以输出任意一种。", "hint": "对于样例一，可以证明不存在满足题意的图。\n\n对于样例二，图如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/49d4fgs7.png?x-oss-process=image/resize,m_lfit,h_170,w_225)\n\n其中点 $1,2,3$ 是割点，$\\rm{deg}_1\\sim\\rm{deg}_7$ 分别为：$3,3,2,1,1,1,1$，符合题意。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[FJCPC 2025] 割点", "background": null, "description": "给定一个正整数 $n$ 和一个长度为 $n-2$ 的 01 序列 $a_{2}, a_{3}, \\dots, a_{n-1}$，要求你构造一个 $n$ 个点的**无向简单连通图** $G$，使得：\n\n- 点 $1$ 是割点，点 $n$ 不是割点。\n\n- 对于每个 $1 < i < n$：\n\n若 $a_{i} = 1$，则点 $i$ 在图 $G$ 中是割点；\n\n若 $a_{i} = 0$，则点 $i$ 在图 $G$ 中不是割点。\n\n- 图 $G$ 中各顶点的度数满足：$\\rm{deg}_1\\geq \\rm{deg}_2\\geq\\dots\\geq \\rm{deg}_n$。\n\n如果存在多种可行的图，输出任意一种；如果不存在满足条件的图，则输出 $-1$。\n\n简单图的定义为：无重边（即任意一对点之间至多只有一条边）且无自环（即不存在一条边两端点相同）的图。\n\n割点的定义为：删掉该点以及它连的边后，使得图连通块个数增加的点。", "inputFormat": "**本题包含多组测试数据。**\n\n第一行一个正整数 $T$（$1\\leq T\\leq 500$），表示测试数据的组数。\n\n对于每组数据：\n\n第一行一个正整数 $n$（$4\\le n \\leq 1000$），表示图中点的个数。\n\n接下来一个长度为 $n - 2$ 的 01 串，表示序列 $a_{2}, a_{3}, \\dots, a_{n-1}$。\n\n保证所有数据的 $\\sum n\\leq 2000$。", "outputFormat": "对于每组数据：\n\n若无解，输出 $-1$；\n\n若有解，第一行输出 $m$ （$0<m\\leq \\frac{n(n-1)}{2}$），表示图的边数。接下来 $m$ 行，每行输出两个正整数，第 $i$ 行的两个正整数表示第 $i$ 条边两个点的编号。若有多种满足题意的图，你可以输出任意一种。", "hint": "对于样例一，可以证明不存在满足题意的图。\n\n对于样例二，图如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/49d4fgs7.png?x-oss-process=image/resize,m_lfit,h_170,w_225)\n\n其中点 $1,2,3$ 是割点，$\\rm{deg}_1\\sim\\rm{deg}_7$ 分别为：$3,3,2,1,1,1,1$，符合题意。", "locale": "zh-CN"}}}
{"pid": "P13098", "type": "P", "difficulty": 3, "samples": [["2\n2025\n182", "0 \n3\n7 3 4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "2025", "福建", "Special Judge", "构造", "省赛/邀请赛"], "title": "[FJCPC 2025] 构造大师贝贝", "background": "", "description": "贝贝励志成为 FJ-ACM 中最强的构造选手，于是他每日苦练构造题。\n\n为了检验贝贝的训练成果，宁宁同学提出了一道十分甚至九分困难的构造题来检验他的学习成果：\n\n给定一个正整数 $n$，请在 $100$ 次操作以内，将其变为一个完全平方数。每次操作的内容为如下：\n\n* 选择一个当前数字 $n$ 的约数 $x$，即 $n \\bmod x = 0$；\n\n* 每次选择的 $x$ 需跟之前**任何一次**选择的都不同；\n\n* 随后让 $n$ 加上 $x$。\n\n在整个操作过程中，$n$ 不允许超过 $10^{18}$。\n\n这可难坏了贝贝，于是他找到了无比聪明的你来解决这个问题。\n\n其中，$n \\bmod x$ 表示 $n$ 除以 $x$ 的余数。", "inputFormat": "本题包含多组评测用例。\n\n第一行，包含一个整数 $T( 1\\le T \\le 1000 )$，表示评测用例组数。\n\n接下来的 $T$ 行，一行一个正整数 $n(1\\le n\\le 10^{12})$。\n\n", "outputFormat": "对于每组评测用例：\n\n第一行，输出一个整数 $m(0\\le m\\le 100)$，表示操作次数。\n\n第二行，包含 $m$ 个由空格分隔的不同的数字，表示每次操作所加上的数字 $x$。\n\n在整个操作过程中，你需要保证 $n$ 不超过 $10^{18}$。", "hint": "对于第 $1$ 个评测用例的说明如下：\n\n- 因为 $2025=45\\times 45$ 原本就是平方数，故无需操作。\n\n对于第 $2$ 个评测用例的说明如下：\n\n- 第一次操作：\n\n  - 选择 $x=7$，数字 $7$ 是 $182$ 的因子；\n\n  - 令 $n:=182+7=189$。\n\n- 第二次操作：\n\n  - 选择 $x=3$，数字 $3$ 是 $189$ 的因子且 $3$ 不在之前选择的数字集合 $\\{7\\}$ 中；\n\n  - 令 $n:=189+3=192$；\n\n- 第三次操作：\n\n  - 选择 $x=4$，数字 $4$ 是 $192$ 的因子且 $4$ 不在之前选择的数字集合 $\\{7,3\\}$ 中；  \n\n  - 令 $n:=192+4=196$；\n\n  - $196=14\\times 14$ 是完全平方数，结束。\n\n其中 $:=$ 表示赋值符号。\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[FJCPC 2025] 构造大师贝贝", "background": "", "description": "贝贝励志成为 FJ-ACM 中最强的构造选手，于是他每日苦练构造题。\n\n为了检验贝贝的训练成果，宁宁同学提出了一道十分甚至九分困难的构造题来检验他的学习成果：\n\n给定一个正整数 $n$，请在 $100$ 次操作以内，将其变为一个完全平方数。每次操作的内容为如下：\n\n* 选择一个当前数字 $n$ 的约数 $x$，即 $n \\bmod x = 0$；\n\n* 每次选择的 $x$ 需跟之前**任何一次**选择的都不同；\n\n* 随后让 $n$ 加上 $x$。\n\n在整个操作过程中，$n$ 不允许超过 $10^{18}$。\n\n这可难坏了贝贝，于是他找到了无比聪明的你来解决这个问题。\n\n其中，$n \\bmod x$ 表示 $n$ 除以 $x$ 的余数。", "inputFormat": "本题包含多组评测用例。\n\n第一行，包含一个整数 $T( 1\\le T \\le 1000 )$，表示评测用例组数。\n\n接下来的 $T$ 行，一行一个正整数 $n(1\\le n\\le 10^{12})$。\n\n", "outputFormat": "对于每组评测用例：\n\n第一行，输出一个整数 $m(0\\le m\\le 100)$，表示操作次数。\n\n第二行，包含 $m$ 个由空格分隔的不同的数字，表示每次操作所加上的数字 $x$。\n\n在整个操作过程中，你需要保证 $n$ 不超过 $10^{18}$。", "hint": "对于第 $1$ 个评测用例的说明如下：\n\n- 因为 $2025=45\\times 45$ 原本就是平方数，故无需操作。\n\n对于第 $2$ 个评测用例的说明如下：\n\n- 第一次操作：\n\n  - 选择 $x=7$，数字 $7$ 是 $182$ 的因子；\n\n  - 令 $n:=182+7=189$。\n\n- 第二次操作：\n\n  - 选择 $x=3$，数字 $3$ 是 $189$ 的因子且 $3$ 不在之前选择的数字集合 $\\{7\\}$ 中；\n\n  - 令 $n:=189+3=192$；\n\n- 第三次操作：\n\n  - 选择 $x=4$，数字 $4$ 是 $192$ 的因子且 $4$ 不在之前选择的数字集合 $\\{7,3\\}$ 中；  \n\n  - 令 $n:=192+4=196$；\n\n  - $196=14\\times 14$ 是完全平方数，结束。\n\n其中 $:=$ 表示赋值符号。\n\n", "locale": "zh-CN"}}}
{"pid": "P13099", "type": "P", "difficulty": 3, "samples": [["5\n1 2 5\n1 3 4\n2 5 7\n3 4 2", "YES\n3 2 1 1 5"], ["4\n1 2 5\n2 3 9\n3 4 4", "NO"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "福建", "Special Judge", "树论", "省赛/邀请赛"], "title": "[FJCPC 2025] VERTeX", "background": "", "description": "给定一棵有 $n$ 个结点的树，结点依次以 $1, 2, \\dots, n$ 标号。第 $i$（$1\\leq i\\leq n$）个结点有**正整数**权值 $b_i > 0$。对于连接结点 $u$ 与 $v$ 的树边，其边权为 $w_{uv} = b_u + b_v$。\n\n现在给定树的形态与每条树边的边权，你需要判断是否存在满足条件的一组结点权值。若存在，则求出任意一组结点权值。", "inputFormat": "第一行，一个正整数 $n$（$1\\leq n\\leq 2\\times 10^5$），表示结点数量。\n\n接下来 $n - 1$ 行，每行三个整数 $u, v, w_{uv}$（$1\\leq u,v\\leq n$，$1\\leq w_{uv}\\leq 10^9$），表示一条连接结点 $u$ 与 $v$ 的边权为 $w_{uv}$ 的树边。", "outputFormat": "若满足条件的一组结点权值不存在，则输出一行一个字符串 `NO`。\n\n否则，第一行输出一个字符串 `YES`，第二行输出 $n$ 个正整数 $b_1, \\dots, b_n$，表示你求出的一组结点权值。你需要保证对于任意 $1\\leq i\\leq n$ 有 $b_i \\leq 10^9$。\n\n若存在多组满足条件的答案，输出任意一组均可。", "hint": "对于第一组样例，可以验证给出的权值满足条件。注意到 $w_{34} = b_3 + b_4 = 2$，因此 $b_3$ 与 $b_4$ 只能取 $1$，继而可以确定其他结点的权值。\n\n对于第二组样例，注意到 $b_2 + b_3 = w_{23} = 9 = w_{12} + w_{34} = b_1 + b_2 + b_3 + b_4$，从而 $b_1 + b_4 = 0$，而这与 $b_1 > 0$ 且 $b_4 > 0$ 矛盾，因此不存在满足条件的结点权值。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[FJCPC 2025] VERTeX", "background": "", "description": "给定一棵有 $n$ 个结点的树，结点依次以 $1, 2, \\dots, n$ 标号。第 $i$（$1\\leq i\\leq n$）个结点有**正整数**权值 $b_i > 0$。对于连接结点 $u$ 与 $v$ 的树边，其边权为 $w_{uv} = b_u + b_v$。\n\n现在给定树的形态与每条树边的边权，你需要判断是否存在满足条件的一组结点权值。若存在，则求出任意一组结点权值。", "inputFormat": "第一行，一个正整数 $n$（$1\\leq n\\leq 2\\times 10^5$），表示结点数量。\n\n接下来 $n - 1$ 行，每行三个整数 $u, v, w_{uv}$（$1\\leq u,v\\leq n$，$1\\leq w_{uv}\\leq 10^9$），表示一条连接结点 $u$ 与 $v$ 的边权为 $w_{uv}$ 的树边。", "outputFormat": "若满足条件的一组结点权值不存在，则输出一行一个字符串 `NO`。\n\n否则，第一行输出一个字符串 `YES`，第二行输出 $n$ 个正整数 $b_1, \\dots, b_n$，表示你求出的一组结点权值。你需要保证对于任意 $1\\leq i\\leq n$ 有 $b_i \\leq 10^9$。\n\n若存在多组满足条件的答案，输出任意一组均可。", "hint": "对于第一组样例，可以验证给出的权值满足条件。注意到 $w_{34} = b_3 + b_4 = 2$，因此 $b_3$ 与 $b_4$ 只能取 $1$，继而可以确定其他结点的权值。\n\n对于第二组样例，注意到 $b_2 + b_3 = w_{23} = 9 = w_{12} + w_{34} = b_1 + b_2 + b_3 + b_4$，从而 $b_1 + b_4 = 0$，而这与 $b_1 > 0$ 且 $b_4 > 0$ 矛盾，因此不存在满足条件的结点权值。", "locale": "zh-CN"}}}
{"pid": "P13100", "type": "P", "difficulty": 3, "samples": [["3\n6\n1 1 4 5 1 4\n5\n1 2 3 4 5\n5\n1 2 2 1 2", "2 2 5 6 6 6\n2 4 4 5 6\n2 4 4 3 3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "福建", "省赛/邀请赛"], "title": "[FJCPC 2025] 众数", "background": "", "description": "有 $n$ 个整数构成的序列 $a_i$（下标 $1\\sim n$），对于序列的每个前缀 $a_1,a_2,\\cdots,a_k$（$1\\leq k\\leq n$），考虑选择其中一个非空下标集合 $S$，定义 $f(S)=\\min\\{a_i\\mid i\\in S\\}+\\max\\{a_i\\mid i\\in S\\}$。\n\n求对于序列 $a$ 的每个前缀，在其对应的 $2^k-1$ 种情况下，$f(S)$ 的值的众数（出现最多的数），如果有多种数出现次数一样均为最多，则输出其中最大的数。", "inputFormat": "第一行一个整数 $t$（$1\\leq t\\leq 1000$），表示接下来有 $t$ 组测试数据。\n\n接下来对于每一组测试数据，第一行包含一个整数 $n$（$1\\leq n\\leq 10^6$），表示整数的个数。\n\n接下来一行包含 $n$ 个整数表示 $a_i$（$1\\leq a_i\\leq 10^9$）。\n\n保证所有测试数据的 $n$ 的总和不超过 $10^6$。", "outputFormat": "对于每一组数据输出一行，包含 $n$ 个由空格隔开的整数，依次表示每一个前缀的 $f(S)$ 的值的最大众数。", "hint": "前 $1$ 个数中，$2$ 出现了 $1$ 次，最大众数为 $2$；\n\n前 $2$ 个数中，$2$ 出现了 $3$ 次，最大众数为 $2$；\n\n前 $3$ 个数中，$2$ 出现了 $3$ 次，$5$ 出现了 $3$ 次，$8$ 出现了 $1$ 次，最大众数为 $5$；\n\n前 $4$ 个数中，$2$ 出现了 $3$ 次，$5$ 出现了 $3$ 次，$6$ 出现了 $6$ 次，$8$ 出现了 $1$ 次，$9$ 出现了 $1$ 次，$10$ 出现了 $1$ 次，最大众数为 $6$；\n\n前 $5$ 个数中，$2$ 出现了 $7$ 次，$5$ 出现了 $7$ 次，$6$ 出现了 $14$ 次，$8$ 出现了 $1$ 次，$9$ 出现了 $1$ 次，$10$ 出现了 $1$ 次，最大众数为 $6$；\n\n前 $6$ 个数中，$2$ 出现了 $7$ 次，$5$ 出现了 $21$ 次，$6$ 出现了 $28$ 次，$8$ 出现了 $3$ 次，$9$ 出现了 $3$ 次，$10$ 出现了 $1$ 次，最大众数为 $6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[FJCPC 2025] 众数", "background": "", "description": "有 $n$ 个整数构成的序列 $a_i$（下标 $1\\sim n$），对于序列的每个前缀 $a_1,a_2,\\cdots,a_k$（$1\\leq k\\leq n$），考虑选择其中一个非空下标集合 $S$，定义 $f(S)=\\min\\{a_i\\mid i\\in S\\}+\\max\\{a_i\\mid i\\in S\\}$。\n\n求对于序列 $a$ 的每个前缀，在其对应的 $2^k-1$ 种情况下，$f(S)$ 的值的众数（出现最多的数），如果有多种数出现次数一样均为最多，则输出其中最大的数。", "inputFormat": "第一行一个整数 $t$（$1\\leq t\\leq 1000$），表示接下来有 $t$ 组测试数据。\n\n接下来对于每一组测试数据，第一行包含一个整数 $n$（$1\\leq n\\leq 10^6$），表示整数的个数。\n\n接下来一行包含 $n$ 个整数表示 $a_i$（$1\\leq a_i\\leq 10^9$）。\n\n保证所有测试数据的 $n$ 的总和不超过 $10^6$。", "outputFormat": "对于每一组数据输出一行，包含 $n$ 个由空格隔开的整数，依次表示每一个前缀的 $f(S)$ 的值的最大众数。", "hint": "前 $1$ 个数中，$2$ 出现了 $1$ 次，最大众数为 $2$；\n\n前 $2$ 个数中，$2$ 出现了 $3$ 次，最大众数为 $2$；\n\n前 $3$ 个数中，$2$ 出现了 $3$ 次，$5$ 出现了 $3$ 次，$8$ 出现了 $1$ 次，最大众数为 $5$；\n\n前 $4$ 个数中，$2$ 出现了 $3$ 次，$5$ 出现了 $3$ 次，$6$ 出现了 $6$ 次，$8$ 出现了 $1$ 次，$9$ 出现了 $1$ 次，$10$ 出现了 $1$ 次，最大众数为 $6$；\n\n前 $5$ 个数中，$2$ 出现了 $7$ 次，$5$ 出现了 $7$ 次，$6$ 出现了 $14$ 次，$8$ 出现了 $1$ 次，$9$ 出现了 $1$ 次，$10$ 出现了 $1$ 次，最大众数为 $6$；\n\n前 $6$ 个数中，$2$ 出现了 $7$ 次，$5$ 出现了 $21$ 次，$6$ 出现了 $28$ 次，$8$ 出现了 $3$ 次，$9$ 出现了 $3$ 次，$10$ 出现了 $1$ 次，最大众数为 $6$。", "locale": "zh-CN"}}}
{"pid": "P13101", "type": "P", "difficulty": 1, "samples": [["1", "FZU"], ["2", "FNU"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "福建", "省赛/邀请赛"], "title": "[FJCPC 2025] 致谢 | FJCPC2025全体参赛选手&赛事staff", "background": "", "description": "亲爱的参赛者：\n\n衷心感谢你参与第十二届福建省大学生程序设计竞赛暨福建邀请赛。\n\n同时，向在比赛幕后默默付出的教练老师和赛事组织人员致以诚挚的谢意，正是因为你们的辛勤付出，比赛才能顺利进行。\n\n此外，也要感谢历届福建省赛(FJCPC)的承办院校为该系列赛事所做出的巨大贡献。\n\n接下来是历届福建省赛(FJCPC)的承办院校及其比赛时间的具体信息：\n\n| 届数 | 比赛时间     | 承办院校               | 英文名                          | 缩写 |\n|------|----------------|--------------|-----------------|----------|\n| 1    | 2010-5-23    | 福州大学               | Fuzhou University               | FZU      |\n| 2    | 2011-5-15    | 福建师范大学           | Fujian Normal University        | FNU      |\n| 3    | 2012-12-02   | 福州大学               | Fuzhou University               | FZU      |\n| 4    | 2013-12-15   | 福州大学               | Fuzhou University               | FZU      |\n| 5    | 2014-11-30   | 福建农林大学           | Fujian Agriculture and Forestry University | FAFU     |\n| 6    | 2015-12-20   | 华侨大学               | Huaqiao University              | HQU      |\n| 7    | 2016-5-22    | 闽江学院               | Minjiang University             | MJU      |\n| 8    | 2017-5-17    | 厦门理工学院           | Xiamen University of Technology | XMUT     |\n| 9    | 2018-6-10    | 泉州师范学院           | Quanzhou Normal University      | QNU      |\n| 10   | 2019-5-19    | 集美大学               | Jimei University                | JMU      |\n| 11   | 2024-5-26    | 福州大学               | Fuzhou University               | FZU      |\n\n CFJ 希望你能输出第 $n$ 届FJCPC的承办院校英文缩写。\n\n再次向所有为第十二届福建省大学生程序设计竞赛暨福建邀请赛奉献力量的每一个人表示最衷心的感谢！\n\n也祝愿你能比赛中取得理想的成绩！", "inputFormat": "输入一个正整数 $n(1\\leq n \\leq 11)$。\n\n", "outputFormat": "输出第 $n$ 届 FJCPC 的承办院校英文缩写。", "hint": "由表可知，第一届 FJCPC 承办校是福州大学，第二届 FJCPC 承办校是福建师范大学。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[FJCPC 2025] 致谢 | FJCPC2025全体参赛选手&赛事staff", "background": "", "description": "亲爱的参赛者：\n\n衷心感谢你参与第十二届福建省大学生程序设计竞赛暨福建邀请赛。\n\n同时，向在比赛幕后默默付出的教练老师和赛事组织人员致以诚挚的谢意，正是因为你们的辛勤付出，比赛才能顺利进行。\n\n此外，也要感谢历届福建省赛(FJCPC)的承办院校为该系列赛事所做出的巨大贡献。\n\n接下来是历届福建省赛(FJCPC)的承办院校及其比赛时间的具体信息：\n\n| 届数 | 比赛时间     | 承办院校               | 英文名                          | 缩写 |\n|------|----------------|--------------|-----------------|----------|\n| 1    | 2010-5-23    | 福州大学               | Fuzhou University               | FZU      |\n| 2    | 2011-5-15    | 福建师范大学           | Fujian Normal University        | FNU      |\n| 3    | 2012-12-02   | 福州大学               | Fuzhou University               | FZU      |\n| 4    | 2013-12-15   | 福州大学               | Fuzhou University               | FZU      |\n| 5    | 2014-11-30   | 福建农林大学           | Fujian Agriculture and Forestry University | FAFU     |\n| 6    | 2015-12-20   | 华侨大学               | Huaqiao University              | HQU      |\n| 7    | 2016-5-22    | 闽江学院               | Minjiang University             | MJU      |\n| 8    | 2017-5-17    | 厦门理工学院           | Xiamen University of Technology | XMUT     |\n| 9    | 2018-6-10    | 泉州师范学院           | Quanzhou Normal University      | QNU      |\n| 10   | 2019-5-19    | 集美大学               | Jimei University                | JMU      |\n| 11   | 2024-5-26    | 福州大学               | Fuzhou University               | FZU      |\n\n CFJ 希望你能输出第 $n$ 届FJCPC的承办院校英文缩写。\n\n再次向所有为第十二届福建省大学生程序设计竞赛暨福建邀请赛奉献力量的每一个人表示最衷心的感谢！\n\n也祝愿你能比赛中取得理想的成绩！", "inputFormat": "输入一个正整数 $n(1\\leq n \\leq 11)$。\n\n", "outputFormat": "输出第 $n$ 届 FJCPC 的承办院校英文缩写。", "hint": "由表可知，第一届 FJCPC 承办校是福州大学，第二届 FJCPC 承办校是福建师范大学。", "locale": "zh-CN"}}}
{"pid": "P13102", "type": "P", "difficulty": 3, "samples": [["3\n4\n940\n4444", "Case #1: 2 2\nCase #2: 852 88\nCase #3: 667 3777"]], "limits": {"time": [10000, 10000, 10000, 10000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "2019", "Special Judge", "Google Code Jam"], "title": "[GCJ 2019 Qualification] Foregone Solution", "background": "", "description": "Someone just won the Code Jam lottery, and we owe them $N$ jamcoins! However, when we tried to print out an oversized check, we encountered a problem. The value of $N$, which is an integer, includes at least one digit that is a `4...` and the 4 key on the keyboard of our oversized check printer is broken.\n\nFortunately, we have a workaround: we will send our winner two checks for positive integer amounts $A$ and $B$, such that neither $A$ nor $B$ contains any digit that is a 4, and $A + B = N$. Please help us find any pair of values $A$ and $B$ that satisfy these conditions.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow; each consists of one line with an integer $N$.\n", "outputFormat": "For each test case, output one line containing `Case #x: A B`, where $x$ is the test case number (starting from 1), and $A$ and $B$ are positive integers as described above.\n\nIt is guaranteed that at least one solution exists. If there are multiple solutions, you may output any one of them.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, notice that A and B can be the same. The only other possible answers are 1 3 and 3 1.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- At least one of the digits of $N$ is a 4.\n\n**Test set 1 (6 Pts, Visible)**\n\n- $1 < N < 10^5$.\n\n**Test set 2 (10 Pts, Visible)**\n\n- $1 < N < 10^9$.\n\nSolving the first two test sets for this problem should get you a long way toward advancing. The third test set is worth only 1 extra point, for extra fun and bragging rights!\n\n**Test set 3 (1 Pts, Hidden)**\n\n- $1 < N < 10^{100}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 Qualification] Foregone Solution", "background": "", "description": "Someone just won the Code Jam lottery, and we owe them $N$ jamcoins! However, when we tried to print out an oversized check, we encountered a problem. The value of $N$, which is an integer, includes at least one digit that is a `4...` and the 4 key on the keyboard of our oversized check printer is broken.\n\nFortunately, we have a workaround: we will send our winner two checks for positive integer amounts $A$ and $B$, such that neither $A$ nor $B$ contains any digit that is a 4, and $A + B = N$. Please help us find any pair of values $A$ and $B$ that satisfy these conditions.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow; each consists of one line with an integer $N$.\n", "outputFormat": "For each test case, output one line containing `Case #x: A B`, where $x$ is the test case number (starting from 1), and $A$ and $B$ are positive integers as described above.\n\nIt is guaranteed that at least one solution exists. If there are multiple solutions, you may output any one of them.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, notice that A and B can be the same. The only other possible answers are 1 3 and 3 1.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- At least one of the digits of $N$ is a 4.\n\n**Test set 1 (6 Pts, Visible)**\n\n- $1 < N < 10^5$.\n\n**Test set 2 (10 Pts, Visible)**\n\n- $1 < N < 10^9$.\n\nSolving the first two test sets for this problem should get you a long way toward advancing. The third test set is worth only 1 extra point, for extra fun and bragging rights!\n\n**Test set 3 (1 Pts, Hidden)**\n\n- $1 < N < 10^{100}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 Qualification] Foregone Solution", "background": null, "description": "有人刚刚赢得了 Code Jam 彩票，我们需要支付给他们 $N$ 个 jamcoin！然而，当我们尝试打印一张超大支票时遇到了问题。$N$ 是一个整数，其中至少包含一个数字 $4$，而我们的超大支票打印机上的 $4$ 键坏了。\n\n幸运的是，我们有一个解决办法：我们将给获奖者发送两张金额为正整数 $A$ 和 $B$ 的支票，使得 $A$ 和 $B$ 都不包含数字 $4$，并且 $A + B = N$。请帮助我们找到任意一组满足条件的 $A$ 和 $B$。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。接下来的 $T$ 行，每行包含一个整数 $N$。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: A B`，其中 $x$ 是测试用例编号（从 1 开始），$A$ 和 $B$ 是满足上述条件的正整数。\n\n保证至少存在一个解。如果有多个解，你可以输出其中任意一个。", "hint": "**样例解释**\n\n在样例第 1 个测试用例中，注意 $A$ 和 $B$ 可以相同。唯一其他可能的答案是 1 3 和 3 1。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $N$ 的数字中至少有一个是 $4$。\n\n**测试点 1（6 分，可见）**\n\n- $1 < N < 10^5$。\n\n**测试点 2（10 分，可见）**\n\n- $1 < N < 10^9$。\n\n解决前两个测试点即可获得大部分分数。第三个测试点仅额外给 1 分，适合挑战和炫耀！\n\n**测试点 3（1 分，隐藏）**\n\n- $1 < N < 10^{100}$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13103", "type": "P", "difficulty": 2, "samples": [["2\n2\nSE\n5\nEESSSESE", "Case #1: ES\nCase #2: SEEESSES"]], "limits": {"time": [15000, 15000, 15000, 15000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["字符串", "2019", "Special Judge", "Google Code Jam"], "title": "[GCJ 2019 Qualification] You Can Go Your Own Way", "background": "", "description": "You have just entered the world's easiest maze. You start in the northwest cell of an $N$ by $N$ grid of unit cells, and you must reach the southeast cell. You have only two types of moves available: a unit move to the east, and a unit move to the south. You can move into any cell, but you may not make a move that would cause you to leave the grid.\n\nYou are excited to be the first in the world to solve the maze, but then you see footprints. Your rival, Labyrinth Lydia, has already solved the maze before you, using the same rules described above!\n\nAs an original thinker, you do not want to reuse any of Lydia's moves. Specifically, if her path includes a unit move from some cell A to some adjacent cell B, your path cannot also include a move from A to B. (However, in that case, it is OK for your path to visit A or visit B, as long as you do not go from A to B.) Please find such a path.\n\nIn the following picture, Lydia's path is indicated in blue, and one possible valid path for you is indicated in orange:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n9xdyxsk.png)", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow; each case consists of two lines. The first line contains one integer $N$, giving the dimensions of the maze, as described above. The second line contains a string $P$ of $2N - 2$ characters, each of which is either uppercase E (for east) or uppercase S (for south), representing Lydia's valid path through the maze.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is a string of $2N - 2$ characters each of which is either uppercase E (for east) or uppercase S (for south), representing your valid path through the maze that does not conflict with Lydia's path, as described above. It is guaranteed that at least one answer exists.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the maze is so small that there is only one valid solution left for us.\n\nSample Case #2 corresponds to the picture above. Notice that it is acceptable for the paths to cross.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $P$ contains exactly $N - 1$ E characters and exactly $N - 1$ S characters.\n\n**Test set 1 (5 Pts, Visible)**\n\n- $2 \\leq N \\leq 10$.\n\n**Test set 2 (9 Pts, Visible)**\n\n- $2 \\leq N \\leq 1000$.\n\n**Test set 3 (10 Pts, Hidden)**\n\n- For at most 10 cases, $2 \\leq N \\leq 50000$.\n- For all other cases, $2 \\leq N \\leq 10000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 Qualification] You Can Go Your Own Way", "background": "", "description": "You have just entered the world's easiest maze. You start in the northwest cell of an $N$ by $N$ grid of unit cells, and you must reach the southeast cell. You have only two types of moves available: a unit move to the east, and a unit move to the south. You can move into any cell, but you may not make a move that would cause you to leave the grid.\n\nYou are excited to be the first in the world to solve the maze, but then you see footprints. Your rival, Labyrinth Lydia, has already solved the maze before you, using the same rules described above!\n\nAs an original thinker, you do not want to reuse any of Lydia's moves. Specifically, if her path includes a unit move from some cell A to some adjacent cell B, your path cannot also include a move from A to B. (However, in that case, it is OK for your path to visit A or visit B, as long as you do not go from A to B.) Please find such a path.\n\nIn the following picture, Lydia's path is indicated in blue, and one possible valid path for you is indicated in orange:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n9xdyxsk.png)", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow; each case consists of two lines. The first line contains one integer $N$, giving the dimensions of the maze, as described above. The second line contains a string $P$ of $2N - 2$ characters, each of which is either uppercase E (for east) or uppercase S (for south), representing Lydia's valid path through the maze.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is a string of $2N - 2$ characters each of which is either uppercase E (for east) or uppercase S (for south), representing your valid path through the maze that does not conflict with Lydia's path, as described above. It is guaranteed that at least one answer exists.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the maze is so small that there is only one valid solution left for us.\n\nSample Case #2 corresponds to the picture above. Notice that it is acceptable for the paths to cross.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $P$ contains exactly $N - 1$ E characters and exactly $N - 1$ S characters.\n\n**Test set 1 (5 Pts, Visible)**\n\n- $2 \\leq N \\leq 10$.\n\n**Test set 2 (9 Pts, Visible)**\n\n- $2 \\leq N \\leq 1000$.\n\n**Test set 3 (10 Pts, Hidden)**\n\n- For at most 10 cases, $2 \\leq N \\leq 50000$.\n- For all other cases, $2 \\leq N \\leq 10000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 Qualification] You Can Go Your Own Way", "background": null, "description": "你刚刚进入了世界上最简单的迷宫。你从一个 $N \\times N$ 的单位方格的西北角单元格出发，目标是到达东南角单元格。你只能进行两种类型的移动：向东移动一格，或向南移动一格。你可以进入任意单元格，但不能移动出格子外。\n\n你本以为自己是第一个解开这个迷宫的人，但你发现了脚印。你的对手 Labyrinth Lydia 已经按照上述规则走完了迷宫！\n\n作为一个有创意的人，你不想重复 Lydia 的任何一步。具体来说，如果她的路径包含了从某个单元格 A 移动到相邻单元格 B 的一步，你的路径中不能包含从 A 到 B 的移动（但你可以访问 A 或 B，只要不是从 A 到 B）。请你找出一条满足条件的路径。\n\n下图中，Lydia 的路径用蓝色表示，你的一种可行路径用橙色表示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n9xdyxsk.png)", "inputFormat": "输入的第一行是测试用例数 $T$。接下来有 $T$ 组测试数据，每组包含两行。第一行包含一个整数 $N$，表示迷宫的尺寸。第二行包含一个长度为 $2N-2$ 的字符串 $P$，每个字符为大写字母 E（表示向东）或 S（表示向南），表示 Lydia 的一条合法路径。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是一个长度为 $2N-2$ 的字符串，每个字符为大写字母 E 或 S，表示你的一条合法路径，且不与 Lydia 的路径冲突。保证至少存在一个解。", "hint": "**样例解释**\n\n样例 1 中，迷宫太小，你只剩下唯一一种合法解法。\n\n样例 2 对应上图。注意，路径可以交叉。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $P$ 恰好包含 $N-1$ 个 E 和 $N-1$ 个 S。\n\n**测试点 1（5 分，可见）**\n\n- $2 \\leq N \\leq 10$。\n\n**测试点 2（9 分，可见）**\n\n- $2 \\leq N \\leq 1000$。\n\n**测试点 3（10 分，隐藏）**\n\n- 最多 10 个用例满足 $2 \\leq N \\leq 50000$。\n- 其余用例满足 $2 \\leq N \\leq 10000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13104", "type": "P", "difficulty": 4, "samples": [["2\n103 31\n217 1891 4819 2291 2987 3811 1739 2491 4717 445 65 1079 8383 5353 901 187 649 1003 697 3239 7663 291 123 779 1007 3551 1943 2117 1679 989 3053\n10000 25\n3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543", "Case #1: CJQUIZKNOWBEVYOFDPFLUXALGORITHMS\nCase #2: SUBDERMATOGLYPHICFJKNQVWXZ"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["数学", "2019", "数论", "Google Code Jam"], "title": "[GCJ 2019 Qualification] Cryptopangrams", "background": "", "description": "On the Code Jam team, we enjoy sending each other pangrams, which are phrases that use each letter of the English alphabet at least once. One common example of a pangram is \"the quick brown fox jumps over the lazy dog\". Sometimes our pangrams contain confidential information — for example, `CJ QUIZ: KNOW BEVY OF DP FLUX ALGORITHMS` — so we need to keep them secure.\n\nWe looked through a cryptography textbook for a few minutes, and we learned that it is very hard to factor products of two large prime numbers, so we devised an encryption scheme based on that fact. First, we made some preparations:\n\n* We chose 26 different prime numbers, none of which is larger than some integer $N$.\n* We sorted those primes in increasing order. Then, we assigned the smallest prime to the letter A, the second smallest prime to the letter B, and so on.\n* Everyone on the team memorized this list.\n\nNow, whenever we want to send a pangram as a message, we first remove all spacing to form a plaintext message. Then we write down the product of the prime for the first letter of the plaintext and the prime for the second letter of the plaintext. Then we write down the product of the primes for the second and third plaintext letters, and so on, ending with the product of the primes for the next-to-last and last plaintext letters. This new list of values is our ciphertext. The number of values is one smaller than the number of characters in the plaintext message.\n\nFor example, suppose that $N = 103$ and we chose to use the first 26 odd prime numbers, because we worry that it is too easy to factor even numbers. Then $A = 3$, $B = 5$, $C = 7$, $D = 11$, and so on, up to $Z = 103$. Also suppose that we want to encrypt the `CJ QUIZ KNOW BEVY OF DP FLUX ALGORITHMS` pangram above, so our plaintext is `CJQUIZKNOWBEVYOFDPFLUXALGORITHMS`. Then the first value in our ciphertext is $7$ (the prime for `C`) times $31$ (the prime for `J`) $= 217$; the next value is $1891$, and so on, ending with $3053$.\n\nWe will give you a ciphertext message and the value of $N$ that we used. We will not tell you which primes we used, or how to decrypt the ciphertext. Do you think you can recover the plaintext anyway?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow; each test case consists of two lines. The first line contains two integers: $N$, as described above, and $L$, the length of the list of values in the ciphertext. The second line contains $L$ integers: the list of values in the ciphertext.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is a string of $L + 1$ uppercase English alphabet letters: the plaintext.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $25 \\leq L \\leq 100$.\n- The plaintext contains each English alphabet letter at least once.\n\n**Test set 1 (10 Pts, Visible)**\n\n- $101 \\leq N \\leq 10000$.\n\n**Test set 2 (15 Pts, Hidden)**\n\n- $101 \\leq N \\leq 10^{100}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 Qualification] Cryptopangrams", "background": "", "description": "On the Code Jam team, we enjoy sending each other pangrams, which are phrases that use each letter of the English alphabet at least once. One common example of a pangram is \"the quick brown fox jumps over the lazy dog\". Sometimes our pangrams contain confidential information — for example, `CJ QUIZ: KNOW BEVY OF DP FLUX ALGORITHMS` — so we need to keep them secure.\n\nWe looked through a cryptography textbook for a few minutes, and we learned that it is very hard to factor products of two large prime numbers, so we devised an encryption scheme based on that fact. First, we made some preparations:\n\n* We chose 26 different prime numbers, none of which is larger than some integer $N$.\n* We sorted those primes in increasing order. Then, we assigned the smallest prime to the letter A, the second smallest prime to the letter B, and so on.\n* Everyone on the team memorized this list.\n\nNow, whenever we want to send a pangram as a message, we first remove all spacing to form a plaintext message. Then we write down the product of the prime for the first letter of the plaintext and the prime for the second letter of the plaintext. Then we write down the product of the primes for the second and third plaintext letters, and so on, ending with the product of the primes for the next-to-last and last plaintext letters. This new list of values is our ciphertext. The number of values is one smaller than the number of characters in the plaintext message.\n\nFor example, suppose that $N = 103$ and we chose to use the first 26 odd prime numbers, because we worry that it is too easy to factor even numbers. Then $A = 3$, $B = 5$, $C = 7$, $D = 11$, and so on, up to $Z = 103$. Also suppose that we want to encrypt the `CJ QUIZ KNOW BEVY OF DP FLUX ALGORITHMS` pangram above, so our plaintext is `CJQUIZKNOWBEVYOFDPFLUXALGORITHMS`. Then the first value in our ciphertext is $7$ (the prime for `C`) times $31$ (the prime for `J`) $= 217$; the next value is $1891$, and so on, ending with $3053$.\n\nWe will give you a ciphertext message and the value of $N$ that we used. We will not tell you which primes we used, or how to decrypt the ciphertext. Do you think you can recover the plaintext anyway?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow; each test case consists of two lines. The first line contains two integers: $N$, as described above, and $L$, the length of the list of values in the ciphertext. The second line contains $L$ integers: the list of values in the ciphertext.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is a string of $L + 1$ uppercase English alphabet letters: the plaintext.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $25 \\leq L \\leq 100$.\n- The plaintext contains each English alphabet letter at least once.\n\n**Test set 1 (10 Pts, Visible)**\n\n- $101 \\leq N \\leq 10000$.\n\n**Test set 2 (15 Pts, Hidden)**\n\n- $101 \\leq N \\leq 10^{100}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 Qualification] Cryptopangrams", "background": null, "description": "在 Code Jam 团队中，我们喜欢互相发送全字母短语（pangram），即包含英语字母表中每个字母至少一次的短语。一个常见的例子是 “the quick brown fox jumps over the lazy dog”。有时我们的全字母短语中包含机密信息，例如 `CJ QUIZ: KNOW BEVY OF DP FLUX ALGORITHMS`，因此我们需要保证它们的安全。\n\n我们翻看了一本密码学教材几分钟，了解到分解两个大质数的乘积非常困难，于是我们基于这个事实设计了一种加密方案。首先，我们做了一些准备：\n\n- 我们选择了 $26$ 个不同的质数，且每个质数都不大于某个整数 $N$。\n- 我们将这些质数按升序排列。然后，将最小的质数分配给字母 $A$，第二小的分配给 $B$，以此类推。\n- 团队中的每个人都记住了这份列表。\n\n现在，每当我们想要发送一个全字母短语作为消息时，我们首先去除所有空格，形成明文消息。然后，我们记录下明文第一个字母对应的质数与第二个字母对应的质数的乘积。接着，记录第二个和第三个字母对应质数的乘积，依此类推，直到倒数第二个和最后一个字母对应质数的乘积。这个新的数值列表就是我们的密文。密文中的数值个数比明文字符数少 $1$。\n\n例如，假设 $N = 103$，我们选择了前 $26$ 个奇质数，因为我们担心偶数太容易分解。那么 $A = 3$，$B = 5$，$C = 7$，$D = 11$，以此类推，直到 $Z = 103$。又假设我们想加密上面的全字母短语 `CJ QUIZ KNOW BEVY OF DP FLUX ALGORITHMS`，那么明文为 `CJQUIZKNOWBEVYOFDPFLUXALGORITHMS`。此时密文的第一个数值是 $7$（`C` 对应的质数）乘以 $31$（`J` 对应的质数）$= 217$；下一个数值是 $1891$，以此类推，最后一个数值是 $3053$。\n\n我们会给你一个密文消息和我们使用的 $N$ 的值。我们不会告诉你用的是哪些质数，也不会告诉你如何解密密文。你能否恢复出明文呢？", "inputFormat": "输入的第一行包含测试用例的数量 $T$。接下来有 $T$ 组测试用例，每组测试用例包含两行。第一行包含两个整数：$N$（如上所述）和 $L$，即密文数值列表的长度。第二行包含 $L$ 个整数，表示密文数值列表。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是由 $L+1$ 个大写英文字母组成的明文字符串。", "hint": "**限制条件**\n\n- $1 \\leq T \\leq 100$。\n- $25 \\leq L \\leq 100$。\n- 明文包含每个英文字母至少一次。\n\n**测试点 1（10 分，可见）**\n\n- $101 \\leq N \\leq 10000$。\n\n**测试点 2（15 分，隐藏）**\n\n- $101 \\leq N \\leq 10^{100}$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13105", "type": "P", "difficulty": 5, "samples": [["", ""]], "limits": {"time": [20000, 20000], "memory": [1048576, 1048576]}, "tags": ["2019", "交互题", "Special Judge", "位运算", "Google Code Jam"], "title": "[GCJ 2019 Qualification] Dat Bae", "background": "", "description": "A research consortium has built a new database system for their new data center. The database is made up of one master computer and $N$ worker computers, which are given IDs from 0 to $N-1$. Each worker stores exactly one bit of information... which seems rather wasteful, but this is very important data!\n\nYou have been hired to evaluate the following instruction for the database:\n\n* TEST\\_STORE <bits>: The master reads in <bits>, which is a string of $N$ bits, and sends the $i$-th bit to the $i$-th worker for storage. The master will then read the bits back from the workers and return them to the user, in the same order in which they were read in.\n\nDuring normal operation, TEST\\_STORE should return the same string of bits that it read in, but unfortunately, $B$ of the workers are broken!\n\nThe broken workers are correctly able to store the bits given to them, but whenever the master tries to read from a broken worker, no bit is returned. This causes the TEST\\_STORE operation to return only $N-B$ bits, which are the bits stored on the non-broken workers (in ascending order of their IDs). For example, suppose $N = 5$ and the 0th and 3rd workers are broken (so $B = 2$). Then:\n\n* TEST\\_STORE 01101 returns 111.\n* TEST\\_STORE 00110 returns 010.\n* TEST\\_STORE 01010 returns 100.\n* TEST\\_STORE 11010 also returns 100.\n\nFor security reasons, the database is hidden in an underground mountain vault, so calls to TEST\\_STORE take a very long time. You have been tasked with working out which workers are broken using at most $F$ calls to TEST\\_STORE.\n\n### Interactive Protocol\n\nThis is an interactive problem. \n\nInitially, your program should read a single line containing a single integer $T$ indicating the number of test cases. Then, you need to process $T$ test cases.\n\nFor each test case, your program will first read a single line containing three integers $N$, $B$, and $F$, indicating the number of workers, the number of broken workers, and the number of lines you may send (as described below).\n\nThen you may send the judge up to $F$ lines, each containing a string of exactly $N$ characters, each either 0 or 1. Each time you send a line, the judge will check that you have not made more than $F$ calls. If you have, the judge will send you a single line containing a single -1, and then finish all communication and wait for your program to finish. Otherwise, the judge will send a string of length $N-B$: the string returned by TEST\\_STORE, as described above.\n\nOnce your program knows the index of the $B$ broken workers, it can finish the test case by sending $B$ space-separated integers: the IDs of the broken workers, in sorted order. This does not count as one of your $F$ calls.\n\nIf the $B$ integers are not exactly the IDs of the $B$ broken workers, you will receive a Wrong Answer verdict, and the judge will send a single line containing -1, and then no additional communication. If your answer was correct, the judge will send a single line with 1, followed by the line that begins the next test case (or exit, if that was the last test case).", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\nThe following interaction meets the limits for Test set 1.\n\n```\n  t = readline_int()           // Reads 2 into t\n  n, b, f = readline_int_list()  // Reads 5, 2, 10 into n, b, f\n  printline 01101 to stdout    // The next four outputs match the example in\n                               // the problem statement.\n  flush stdout\n  response = readline_str()    // Reads 111 into response. (At this point, we\n                               // could determine the answer; the remaining\n                               // queries are just examples!)\n  printline 00110 to stdout\n  flush stdout\n  response = readline_str()    // Reads 010 into response\n  printline 01010 to stdout\n  flush stdout\n  response = readline_str()    // Reads 100 into response\n  printline 11010 to stdout\n  flush stdout\n  response = readline_str()    // Reads 100 into response\n  printline 0 3 to stdout      // Guesses the answer. Notice that we were\n                               // not required to use all 10 of our allowed\n                               // queries.\n  flush stdout\n  verdict = readline_int()     // Reads 1 into verdict. We got that test case\n                               // right!\n  n, b, f = readline_int_list()  // Reads 2, 1, 10 into n, b, f.\n  printline 01 to stdout       // 01 is a query, not a guess at the final\n                               // answer (if we wanted to guess that just\n                               // worker 1 were broken, we would have to\n                               // send 1 as we do below)\n  flush stdout\n  response = readline_str()    // Reads 1 into response.\n  printline 1 to stdout        // Makes a (bad) wild guess.\n  verdict = readline_str()     // Reads -1 into verdict.\n  exit                         // exits to avoid an ambiguous TLE error\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $2 \\leq N \\leq 1024$.\n- $1 \\leq B \\leq \\min(15, N-1)$.\n\n**Test set 1 (14 Pts, Visible)**\n\n- $F = 10$.\n\n**Test set 2 (20 Pts, Hidden)**\n\n- $F = 5$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 Qualification] Dat Bae", "background": "", "description": "A research consortium has built a new database system for their new data center. The database is made up of one master computer and $N$ worker computers, which are given IDs from 0 to $N-1$. Each worker stores exactly one bit of information... which seems rather wasteful, but this is very important data!\n\nYou have been hired to evaluate the following instruction for the database:\n\n* TEST\\_STORE <bits>: The master reads in <bits>, which is a string of $N$ bits, and sends the $i$-th bit to the $i$-th worker for storage. The master will then read the bits back from the workers and return them to the user, in the same order in which they were read in.\n\nDuring normal operation, TEST\\_STORE should return the same string of bits that it read in, but unfortunately, $B$ of the workers are broken!\n\nThe broken workers are correctly able to store the bits given to them, but whenever the master tries to read from a broken worker, no bit is returned. This causes the TEST\\_STORE operation to return only $N-B$ bits, which are the bits stored on the non-broken workers (in ascending order of their IDs). For example, suppose $N = 5$ and the 0th and 3rd workers are broken (so $B = 2$). Then:\n\n* TEST\\_STORE 01101 returns 111.\n* TEST\\_STORE 00110 returns 010.\n* TEST\\_STORE 01010 returns 100.\n* TEST\\_STORE 11010 also returns 100.\n\nFor security reasons, the database is hidden in an underground mountain vault, so calls to TEST\\_STORE take a very long time. You have been tasked with working out which workers are broken using at most $F$ calls to TEST\\_STORE.\n\n### Interactive Protocol\n\nThis is an interactive problem. \n\nInitially, your program should read a single line containing a single integer $T$ indicating the number of test cases. Then, you need to process $T$ test cases.\n\nFor each test case, your program will first read a single line containing three integers $N$, $B$, and $F$, indicating the number of workers, the number of broken workers, and the number of lines you may send (as described below).\n\nThen you may send the judge up to $F$ lines, each containing a string of exactly $N$ characters, each either 0 or 1. Each time you send a line, the judge will check that you have not made more than $F$ calls. If you have, the judge will send you a single line containing a single -1, and then finish all communication and wait for your program to finish. Otherwise, the judge will send a string of length $N-B$: the string returned by TEST\\_STORE, as described above.\n\nOnce your program knows the index of the $B$ broken workers, it can finish the test case by sending $B$ space-separated integers: the IDs of the broken workers, in sorted order. This does not count as one of your $F$ calls.\n\nIf the $B$ integers are not exactly the IDs of the $B$ broken workers, you will receive a Wrong Answer verdict, and the judge will send a single line containing -1, and then no additional communication. If your answer was correct, the judge will send a single line with 1, followed by the line that begins the next test case (or exit, if that was the last test case).", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\nThe following interaction meets the limits for Test set 1.\n\n```\n  t = readline_int()           // Reads 2 into t\n  n, b, f = readline_int_list()  // Reads 5, 2, 10 into n, b, f\n  printline 01101 to stdout    // The next four outputs match the example in\n                               // the problem statement.\n  flush stdout\n  response = readline_str()    // Reads 111 into response. (At this point, we\n                               // could determine the answer; the remaining\n                               // queries are just examples!)\n  printline 00110 to stdout\n  flush stdout\n  response = readline_str()    // Reads 010 into response\n  printline 01010 to stdout\n  flush stdout\n  response = readline_str()    // Reads 100 into response\n  printline 11010 to stdout\n  flush stdout\n  response = readline_str()    // Reads 100 into response\n  printline 0 3 to stdout      // Guesses the answer. Notice that we were\n                               // not required to use all 10 of our allowed\n                               // queries.\n  flush stdout\n  verdict = readline_int()     // Reads 1 into verdict. We got that test case\n                               // right!\n  n, b, f = readline_int_list()  // Reads 2, 1, 10 into n, b, f.\n  printline 01 to stdout       // 01 is a query, not a guess at the final\n                               // answer (if we wanted to guess that just\n                               // worker 1 were broken, we would have to\n                               // send 1 as we do below)\n  flush stdout\n  response = readline_str()    // Reads 1 into response.\n  printline 1 to stdout        // Makes a (bad) wild guess.\n  verdict = readline_str()     // Reads -1 into verdict.\n  exit                         // exits to avoid an ambiguous TLE error\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $2 \\leq N \\leq 1024$.\n- $1 \\leq B \\leq \\min(15, N-1)$.\n\n**Test set 1 (14 Pts, Visible)**\n\n- $F = 10$.\n\n**Test set 2 (20 Pts, Hidden)**\n\n- $F = 5$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 Qualification] Dat Bae", "background": null, "description": "一个研究联盟为他们的新数据中心建立了一个新的数据库系统。该数据库由一台主控计算机和 $N$ 台工作计算机组成，工作计算机的编号从 $0$ 到 $N-1$。每台工作计算机只存储一位信息……这看起来似乎很浪费，但这些数据非常重要！\n\n你被雇佣来评估数据库的以下指令：\n\n- TEST\\_STORE <bits>：主控计算机读取 <bits>，这是一个长度为 $N$ 的二进制字符串，并将第 $i$ 位发送给第 $i$ 个工作计算机进行存储。随后，主控计算机会从工作计算机中读取这些位，并按照输入时的顺序返回给用户。\n\n在正常情况下，TEST\\_STORE 应该返回与输入相同的二进制字符串，但不幸的是，有 $B$ 台工作计算机损坏了！\n\n损坏的工作计算机能够正确存储分配给它们的位，但当主控计算机尝试从损坏的工作计算机读取数据时，将无法返回任何位。这导致 TEST\\_STORE 操作只返回 $N-B$ 位，这些位是存储在未损坏工作计算机上的（按照它们的编号升序排列）。例如，假设 $N = 5$，第 0 和第 3 号工作计算机损坏（即 $B = 2$）。那么：\n\n- TEST\\_STORE 01101 返回 111。\n- TEST\\_STORE 00110 返回 010。\n- TEST\\_STORE 01010 返回 100。\n- TEST\\_STORE 11010 也返回 100。\n\n出于安全原因，数据库被隐藏在地下山体仓库中，因此每次调用 TEST\\_STORE 都需要很长时间。你的任务是在最多 $F$ 次 TEST\\_STORE 调用内，找出哪些工作计算机损坏了。\n\n### 交互协议\n\n这是一个交互题。\n\n程序开始时，应读取一行，包含一个整数 $T$，表示测试用例的数量。然后，你需要处理 $T$ 个测试用例。\n\n对于每个测试用例，程序首先会读取一行，包含三个整数 $N$、$B$ 和 $F$，分别表示工作计算机的数量、损坏的工作计算机数量以及你可以发送的最多查询次数（如下所述）。\n\n接下来，你可以向评测机最多发送 $F$ 行，每行包含一个长度为 $N$ 的字符串，每个字符为 0 或 1。每当你发送一行时，评测机会检查你是否已超过 $F$ 次调用。如果超过，评测机会返回一行，内容为 -1，然后结束所有通信并等待你的程序结束。否则，评测机会返回一个长度为 $N-B$ 的字符串，即 TEST\\_STORE 操作的返回值，如上所述。\n\n一旦你确定了 $B$ 个损坏的工作计算机的编号，可以通过发送一行 $B$ 个用空格分隔的整数（按升序排列）来提交答案。这一步不计入 $F$ 次调用之内。\n\n如果你提交的 $B$ 个整数不是准确的损坏工作计算机编号，你将收到 Wrong Answer 判定，评测机会返回一行 -1，之后不再进行任何通信。如果你的答案正确，评测机会返回一行 1，随后进入下一个测试用例（或结束，如果这是最后一个测试用例）。", "inputFormat": "见交互协议。", "outputFormat": "见交互协议。", "hint": "**交互样例**\n\n以下交互过程符合测试集 1 的限制。\n\n```\n  t = readline_int()           // 读取 t=2\n  n, b, f = readline_int_list()  // 读取 n=5, b=2, f=10\n  printline 01101 to stdout    // 以下四次输出与题目描述中的例子一致\n  flush stdout\n  response = readline_str()    // 读取 response=111（此时我们已可确定答案，后续查询仅为示例）\n  printline 00110 to stdout\n  flush stdout\n  response = readline_str()    // 读取 response=010\n  printline 01010 to stdout\n  response = readline_str()    // 读取 response=100\n  printline 11010 to stdout\n  flush stdout\n  response = readline_str()    // 读取 response=100\n  printline 0 3 to stdout      // 猜测答案。注意不要求用完所有 10 次查询。\n  flush stdout\n  verdict = readline_int()     // 读取 verdict=1，说明本测试用例正确！\n  n, b, f = readline_int_list()  // 读取 n=2, b=1, f=10\n  printline 01 to stdout       // 01 是一次查询，不是最终答案（如果想猜测只有 1 号损坏，应像下方一样输出）\n  flush stdout\n  response = readline_str()    // 读取 response=1\n  printline 1 to stdout        // 随意猜测\n  verdict = readline_str()     // 读取 verdict=-1\n  exit                         // 退出以避免歧义性 TLE 错误\n```\n\n你可以使用本地测试工具在本地或平台上进行测试。要在本地测试，你需要让测试工具与你的代码并行运行；你可以使用我们的 [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)。更多信息请阅读该文件中的注释说明。\n\n测试工具的使用说明已包含在工具的注释中。我们鼓励你添加自己的测试用例。请注意，虽然测试工具旨在模拟评测系统，但它**不是**真实的评测系统，可能会有不同的表现。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $2 \\leq N \\leq 1024$。\n- $1 \\leq B \\leq \\min(15, N-1)$。\n\n**测试集 1（14 分，公开）**\n\n- $F = 10$。\n\n**测试集 2（20 分，隐藏）**\n\n- $F = 5$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13106", "type": "P", "difficulty": 5, "samples": [["2\n2 2\n2 5", "Case #1: IMPOSSIBLE\nCase #2: POSSIBLE\n2 3\n1 1\n2 4\n1 2\n2 5\n1 3\n2 1\n1 5\n2 2\n1 4"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2019", "Special Judge", "Google Code Jam"], "title": "[GCJ 2019 #1A] Pylons", "background": "", "description": "Our Battlestarcraft Algorithmica ship is being chased through space by persistent robots called Pylons! We have just teleported to a new galaxy to try to shake them off of our tail, and we want to stay here for as long as possible so we can buy time to plan our next move... but we do not want to get caught!\n\nThis galaxy is a flat grid of $R$ rows and $C$ columns; the rows are numbered from 1 to $R$ from top to bottom, and the columns are numbered from 1 to $C$ from left to right. We can choose which cell to start in, and we must continue to jump between cells until we have visited each cell in the galaxy exactly once. That is, we can never revisit a cell, including our starting cell.\n\nWe do not want to make it too easy for the Pylons to guess where we will go next. Each time we jump from our current cell, we must choose a destination cell that does not share a row, column, or diagonal with that current cell. Let $(i, j)$ denote the cell in the $i$-th row and $j$-th column; then a jump from a current cell $(r, c)$ to a destination cell $(r', c')$ is invalid if and only if any of these is true:\n\n* $r = r'$\n* $c = c'$\n* $r - c = r' - c'$\n* $r + c = r' + c'$\n\nCan you help us find an order in which to visit each of the $R \\times C$ cells, such that the move between any pair of consecutive cells in the sequence is valid? Or is it impossible for us to escape from the Pylons?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each consists of one line containing two integers $R$ and $C$: the numbers of rows and columns in this galaxy.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $y$ is a string of uppercase letters: either `POSSIBLE` or `IMPOSSIBLE`, according to whether it is possible to fulfill the conditions in the problem statement. Then, if it is possible, output $R \\times C$ more lines. The $i$-th of these lines represents the $i$-th cell you will visit (counting starting from 1), and should contain two integers $r_i$ and $c_i$: the row and column of that cell. Note that the first of these lines represents your chosen starting cell.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, no matter which starting cell we choose, we have nowhere to jump, since all of the remaining cells share a row, column, or diagonal with our starting cell.\n\nIn Sample Case #2, we have chosen the cell in row 2, column 3 as our starting cell. Notice that it is fine for our final cell to share a row, column, or diagonal with our starting cell. The following diagram shows the order in which the cells are visited:\n\n```\n2 4 6 10 8\n7 9 1 3  5\n```\n\n**Limits**\n\n**Test set 1 (8 Pts, Visible)**\n\n- $\\text{T} = 16.$\n- $2 \\leqslant \\text{R} \\leqslant 5.$\n- $2 \\leqslant \\text{C} \\leqslant 5.$\n\n**Test set 2 (23 Pts, Hidden)**\n\n- $1 \\leqslant \\text{T} \\leqslant 100.$\n- $2 \\leqslant \\text{R} \\leqslant 20.$\n- $2 \\leqslant \\text{C} \\leqslant 20.$", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #1A] Pylons", "background": "", "description": "Our Battlestarcraft Algorithmica ship is being chased through space by persistent robots called Pylons! We have just teleported to a new galaxy to try to shake them off of our tail, and we want to stay here for as long as possible so we can buy time to plan our next move... but we do not want to get caught!\n\nThis galaxy is a flat grid of $R$ rows and $C$ columns; the rows are numbered from 1 to $R$ from top to bottom, and the columns are numbered from 1 to $C$ from left to right. We can choose which cell to start in, and we must continue to jump between cells until we have visited each cell in the galaxy exactly once. That is, we can never revisit a cell, including our starting cell.\n\nWe do not want to make it too easy for the Pylons to guess where we will go next. Each time we jump from our current cell, we must choose a destination cell that does not share a row, column, or diagonal with that current cell. Let $(i, j)$ denote the cell in the $i$-th row and $j$-th column; then a jump from a current cell $(r, c)$ to a destination cell $(r', c')$ is invalid if and only if any of these is true:\n\n* $r = r'$\n* $c = c'$\n* $r - c = r' - c'$\n* $r + c = r' + c'$\n\nCan you help us find an order in which to visit each of the $R \\times C$ cells, such that the move between any pair of consecutive cells in the sequence is valid? Or is it impossible for us to escape from the Pylons?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each consists of one line containing two integers $R$ and $C$: the numbers of rows and columns in this galaxy.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $y$ is a string of uppercase letters: either `POSSIBLE` or `IMPOSSIBLE`, according to whether it is possible to fulfill the conditions in the problem statement. Then, if it is possible, output $R \\times C$ more lines. The $i$-th of these lines represents the $i$-th cell you will visit (counting starting from 1), and should contain two integers $r_i$ and $c_i$: the row and column of that cell. Note that the first of these lines represents your chosen starting cell.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, no matter which starting cell we choose, we have nowhere to jump, since all of the remaining cells share a row, column, or diagonal with our starting cell.\n\nIn Sample Case #2, we have chosen the cell in row 2, column 3 as our starting cell. Notice that it is fine for our final cell to share a row, column, or diagonal with our starting cell. The following diagram shows the order in which the cells are visited:\n\n```\n2 4 6 10 8\n7 9 1 3  5\n```\n\n**Limits**\n\n**Test set 1 (8 Pts, Visible)**\n\n- $\\text{T} = 16.$\n- $2 \\leqslant \\text{R} \\leqslant 5.$\n- $2 \\leqslant \\text{C} \\leqslant 5.$\n\n**Test set 2 (23 Pts, Hidden)**\n\n- $1 \\leqslant \\text{T} \\leqslant 100.$\n- $2 \\leqslant \\text{R} \\leqslant 20.$\n- $2 \\leqslant \\text{C} \\leqslant 20.$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #1A] Pylons", "background": null, "description": "我们的 Battlestarcraft Algorithmica 飞船正在太空中被名为 Pylons 的顽固机器人追赶！我们刚刚传送到一个新的星系，试图甩掉它们，并希望能在这里停留尽可能长的时间，以便为下一步行动争取时间……但我们绝不能被抓住！\n\n这个星系是一个 $R$ 行 $C$ 列的平面网格；行从上到下编号为 $1$ 到 $R$，列从左到右编号为 $1$ 到 $C$。我们可以选择从任意一个格子开始，并且必须不断地跳跃到其他格子，直到每个格子都恰好访问一次。也就是说，我们不能重复访问任何格子，包括起始格子。\n\n我们不希望让 Pylons 太容易猜到我们下一步会去哪里。每次从当前格子跳跃时，必须选择一个不与当前格子在同一行、同一列或同一对角线上的目标格子。设 $(i, j)$ 表示第 $i$ 行第 $j$ 列的格子；那么从当前格子 $(r, c)$ 跳到目标格子 $(r', c')$ 是无效的，当且仅当以下任一条件成立：\n\n- $r = r'$\n- $c = c'$\n- $r - c = r' - c'$\n- $r + c = r' + c'$\n\n你能帮我们找到一种访问 $R \\times C$ 个格子的顺序，使得任意一对相邻格子的移动都是有效的吗？或者说，我们根本无法逃脱 Pylons 的追捕？", "inputFormat": "输入的第一行是测试用例数 $T$。接下来有 $T$ 个测试用例。每个测试用例包含一行，包含两个整数 $R$ 和 $C$，分别表示这个星系的行数和列数。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $y$ 是一个大写字母字符串：如果可以满足题目要求则为 `POSSIBLE`，否则为 `IMPOSSIBLE`。如果可能，请接着输出 $R \\times C$ 行，第 $i$ 行表示你访问的第 $i$ 个格子（从 $1$ 开始计数），包含两个整数 $r_i$ 和 $c_i$，分别表示该格子的行号和列号。注意，第一行表示你选择的起始格子。", "hint": "**样例解释**\n\n在样例第 1 组中，无论选择哪个起始格子，都无法跳到其他格子，因为剩下的所有格子都与起始格子在同一行、同一列或同一对角线上。\n\n在样例第 2 组中，我们选择了第 2 行第 3 列的格子作为起始格子。注意，最后一个格子可以与起始格子在同一行、同一列或同一对角线上。下图展示了访问格子的顺序：\n\n```\n2 4 6 10 8\n7 9 1 3  5\n```\n\n**数据范围**\n\n**测试点 1（8 分，可见）**\n\n- $\\text{T} = 16$\n- $2 \\leqslant \\text{R} \\leqslant 5$\n- $2 \\leqslant \\text{C} \\leqslant 5$\n\n**测试点 2（23 分，隐藏）**\n\n- $1 \\leqslant \\text{T} \\leqslant 100$\n- $2 \\leqslant \\text{R} \\leqslant 20$\n- $2 \\leqslant \\text{C} \\leqslant 20$\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13107", "type": "P", "difficulty": 5, "samples": [["", ""]], "limits": {"time": [20000, 20000], "memory": [1048576, 1048576]}, "tags": ["2019", "交互题", "Special Judge", "中国剩余定理 CRT", "Google Code Jam"], "title": "[GCJ 2019 #1A] Golf Gophers", "background": "", "description": "Last year, a bunch of pesky gophers took up residence in our orchard. We tried to change our line of work by opening up a miniature golf course, but it looks like the gophers have followed us here! Once again, we need to figure out how many gophers there are, but we cannot observe them directly because they are secretive and nocturnal, whereas we like to sleep at night. We do know there are between 1 and M gophers, inclusive.\n\nOur mini golf course is famous for having a small electronic windmill on each of its 18 holes. The i-th windmill has $2 \\leqslant \\mathbf{B}_{\\mathrm{i}} \\leqslant 18$ blades, which are numbered from 0 to $\\mathbf{B}_{\\mathrm{i}}-1$, clockwise. Each night, before going to sleep, we turn off the windmills and set each one such that blade 0 is pointing downward, which is important so that the windmills can charge up properly for the next day. However, we have noticed that when we wake up, the windmills have been disturbed. Since our mini golf course is in a windless area, we think the mischievous gophers must be responsible!\n\nWe know that every night, all of the gophers emerge, one by one; each of them chooses one of the windmills independently and uniformly at random and rotates it counterclockwise by one blade. So, for example, for a windmill with 3 blades for which 0 is pointing downward, the first gopher to interact with it turns it so that 1 is pointing downward, and then the next gophers to interact with that windmill make the downward-pointing blade have number 2, then 0, then 1, and so on.\n\nWe have devised a plan. We designed our windmills so that we can easily change the number of blades (to modulate the difficulty of our course), and we will now take advantage of this! Each night, before going to sleep, we can choose the number of blades on each of the 18 windmills, within the given limits; we do not have to use the same number of blades on each windmill, or make the same choices every night. In the morning, we will observe the number on each windmill's downward-pointing blade.\n\nWe have $\\mathbf{N}$ nights in which to figure out $\\mathbf{G}$, the number of gophers. Can you help us?\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing three integers $\\mathbf{T}$, $\\mathbf{N}$ and $\\mathbf{M}$, the number of test cases, the number of nights allowed per test case and the maximum number of gophers, respectively. Then, you need to process $\\mathbf{T}$ test cases.\n\nIn each test case, your program processes up to $\\mathbf{N}+1$ exchanges with our judge. You may make up to $\\mathbf{N}$ exchanges of the following form:\n\n* Your program outputs one line with eighteen integers between 2 and 18, inclusive; the i-th of these represents the number of blades you want the i-th windmill to have on that night.\n* The judge responds with one line with eighteen integers; the i-th of these represents the number on the downward-pointing blade of the i-th windmill in the morning, after the gophers have worked their mischief. If you sent invalid data (e.g., a number out of range, or a malformed line), the judge instead responds with -1.\n\nOn each night, for each gopher, the choice of which windmill the gopher turns is uniform at (pseudo)-random, and independent of any other choice by any gopher (including itself) on any night.\n\nAfter making between 0 and $\\mathbf{N}$ exchanges as explained above, you must make one more exchange of the following form:\n\n* Your program outputs one integer: your guess for $\\mathbf{G}$, the number of gophers.\n* The judge responds with one line with a single integer: 1 if your answer is correct, and -1 if it is not (or you have provided a malformed line).\n\nAfter the judge sends -1 to your input stream (because of either invalid data or an incorrect answer), it will not send any other output. If your program continues to wait for the judge after receiving -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\nThis interaction corresponds to Test set 1. Suppose that, unbeknownst to us, the judge has decided that there are 10 gophers.\n\n```\n  t, n, m = readline_int_list()   // Reads 20 into t, 365 into n and 100 into m.\n  // Choose numbers of blades for day 1.\n  printline 2 2 2 2 18 3 3 3 3 3 3 4 4 4 4 5 2 2 to stdout\n  flush stdout\n  // Reads 0 0 0 0 0 0 1 2 1 0 1 2 0 0 0 0 1 0 into res.\n  res = readline_int_list()\n  // Choose numbers of blades for day 2.\n  printline 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 2 to stdout\n  flush stdout\n  // Reads 0 1 1 2 0 0 1 0 0 0 0 0 0 1 0 0 0 0 into res.\n  res = readline_int_list()\n  printline 8 to stdout        // We make a wrong guess even though we could\n  flush stdout                 // have investigated for up to 363 more nights.\n  verdict = readline_int()     // Reads -1 into verdict (judge has decided our\n                               //   solution is incorrect)\n  exit                         // Exits to avoid an ambiguous TLE error\n```\n\nNotice that even though the guess was consistent with the information we received from the judge, we were still wrong because we did not find the correct value.\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 20 .$\n\n**Test set 1 (11 Pts, Visible)**\n\n- $\\mathrm{N}=365$.\n- $\\mathrm{M}=100$.\n\n**Test set 2 (21 Pts, Hidden)**\n\n- $\\mathrm{N}=7$.\n- $\\mathrm{M}=10^{6}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #1A] Golf Gophers", "background": "", "description": "Last year, a bunch of pesky gophers took up residence in our orchard. We tried to change our line of work by opening up a miniature golf course, but it looks like the gophers have followed us here! Once again, we need to figure out how many gophers there are, but we cannot observe them directly because they are secretive and nocturnal, whereas we like to sleep at night. We do know there are between 1 and M gophers, inclusive.\n\nOur mini golf course is famous for having a small electronic windmill on each of its 18 holes. The i-th windmill has $2 \\leqslant \\mathbf{B}_{\\mathrm{i}} \\leqslant 18$ blades, which are numbered from 0 to $\\mathbf{B}_{\\mathrm{i}}-1$, clockwise. Each night, before going to sleep, we turn off the windmills and set each one such that blade 0 is pointing downward, which is important so that the windmills can charge up properly for the next day. However, we have noticed that when we wake up, the windmills have been disturbed. Since our mini golf course is in a windless area, we think the mischievous gophers must be responsible!\n\nWe know that every night, all of the gophers emerge, one by one; each of them chooses one of the windmills independently and uniformly at random and rotates it counterclockwise by one blade. So, for example, for a windmill with 3 blades for which 0 is pointing downward, the first gopher to interact with it turns it so that 1 is pointing downward, and then the next gophers to interact with that windmill make the downward-pointing blade have number 2, then 0, then 1, and so on.\n\nWe have devised a plan. We designed our windmills so that we can easily change the number of blades (to modulate the difficulty of our course), and we will now take advantage of this! Each night, before going to sleep, we can choose the number of blades on each of the 18 windmills, within the given limits; we do not have to use the same number of blades on each windmill, or make the same choices every night. In the morning, we will observe the number on each windmill's downward-pointing blade.\n\nWe have $\\mathbf{N}$ nights in which to figure out $\\mathbf{G}$, the number of gophers. Can you help us?\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing three integers $\\mathbf{T}$, $\\mathbf{N}$ and $\\mathbf{M}$, the number of test cases, the number of nights allowed per test case and the maximum number of gophers, respectively. Then, you need to process $\\mathbf{T}$ test cases.\n\nIn each test case, your program processes up to $\\mathbf{N}+1$ exchanges with our judge. You may make up to $\\mathbf{N}$ exchanges of the following form:\n\n* Your program outputs one line with eighteen integers between 2 and 18, inclusive; the i-th of these represents the number of blades you want the i-th windmill to have on that night.\n* The judge responds with one line with eighteen integers; the i-th of these represents the number on the downward-pointing blade of the i-th windmill in the morning, after the gophers have worked their mischief. If you sent invalid data (e.g., a number out of range, or a malformed line), the judge instead responds with -1.\n\nOn each night, for each gopher, the choice of which windmill the gopher turns is uniform at (pseudo)-random, and independent of any other choice by any gopher (including itself) on any night.\n\nAfter making between 0 and $\\mathbf{N}$ exchanges as explained above, you must make one more exchange of the following form:\n\n* Your program outputs one integer: your guess for $\\mathbf{G}$, the number of gophers.\n* The judge responds with one line with a single integer: 1 if your answer is correct, and -1 if it is not (or you have provided a malformed line).\n\nAfter the judge sends -1 to your input stream (because of either invalid data or an incorrect answer), it will not send any other output. If your program continues to wait for the judge after receiving -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\nThis interaction corresponds to Test set 1. Suppose that, unbeknownst to us, the judge has decided that there are 10 gophers.\n\n```\n  t, n, m = readline_int_list()   // Reads 20 into t, 365 into n and 100 into m.\n  // Choose numbers of blades for day 1.\n  printline 2 2 2 2 18 3 3 3 3 3 3 4 4 4 4 5 2 2 to stdout\n  flush stdout\n  // Reads 0 0 0 0 0 0 1 2 1 0 1 2 0 0 0 0 1 0 into res.\n  res = readline_int_list()\n  // Choose numbers of blades for day 2.\n  printline 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 2 to stdout\n  flush stdout\n  // Reads 0 1 1 2 0 0 1 0 0 0 0 0 0 1 0 0 0 0 into res.\n  res = readline_int_list()\n  printline 8 to stdout        // We make a wrong guess even though we could\n  flush stdout                 // have investigated for up to 363 more nights.\n  verdict = readline_int()     // Reads -1 into verdict (judge has decided our\n                               //   solution is incorrect)\n  exit                         // Exits to avoid an ambiguous TLE error\n```\n\nNotice that even though the guess was consistent with the information we received from the judge, we were still wrong because we did not find the correct value.\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 20 .$\n\n**Test set 1 (11 Pts, Visible)**\n\n- $\\mathrm{N}=365$.\n- $\\mathrm{M}=100$.\n\n**Test set 2 (21 Pts, Hidden)**\n\n- $\\mathrm{N}=7$.\n- $\\mathrm{M}=10^{6}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #1A] Golf Gophers", "background": null, "description": "去年，一群讨厌的地鼠在我们的果园里安了家。我们试图转行，开了一家迷你高尔夫球场，但看起来地鼠们又跟着我们来了！我们再次需要弄清楚有多少只地鼠，但我们无法直接观察它们，因为它们很隐秘且是夜行性动物，而我们喜欢晚上睡觉。我们只知道地鼠的数量在 $1$ 到 $M$ 之间（包含两端）。\n\n我们的迷你高尔夫球场以每个球洞上都有一个小型电子风车而闻名，一共 18 个球洞。第 $i$ 个风车有 $2 \\leqslant \\mathbf{B}_{\\mathrm{i}} \\leqslant 18$ 片叶片，编号从 $0$ 到 $\\mathbf{B}_{\\mathrm{i}}-1$，顺时针排列。每天晚上，睡觉前我们会关闭所有风车，并将每个风车设置为 0 号叶片朝下，这样风车才能为第二天正常充电。然而，我们注意到，早上醒来时风车的位置已经被扰乱。由于我们的球场没有风，所以我们认为一定是这些调皮的地鼠搞的鬼！\n\n我们知道，每天晚上，所有地鼠都会依次出现；每只地鼠会独立且等概率地选择一个风车，并将其逆时针旋转一片叶片。例如，对于一个有 3 片叶片、0 号叶片朝下的风车，第一只地鼠会让 1 号叶片朝下，之后每有一只地鼠操作该风车，朝下的叶片编号依次变为 2、0、1，依此类推。\n\n我们已经想好了一个计划。我们的风车设计允许我们轻松更改叶片数量（以调整球场难度），现在我们要利用这一点！每天晚上睡觉前，我们可以为每个风车选择叶片数量，范围在给定的限制内；我们不需要每晚为每个风车选择相同的叶片数，也不需要每晚都做相同的选择。第二天早上，我们会观察每个风车朝下的叶片编号。\n\n我们有 $\\mathbf{N}$ 个夜晚来推断出 $\\mathbf{G}$，即地鼠的数量。你能帮我们吗？\n\n### 交互协议\n\n这是一个交互题。\n\n最开始，你的程序应读取一行，包含三个整数 $\\mathbf{T}$、$\\mathbf{N}$ 和 $\\mathbf{M}$，分别表示测试用例数量、每个用例允许的夜晚数和地鼠数量的最大值。然后，你需要处理 $\\mathbf{T}$ 个测试用例。\n\n在每个测试用例中，你的程序最多与评测器进行 $\\mathbf{N}+1$ 次交互。你可以进行最多 $\\mathbf{N}$ 次如下形式的交互：\n\n- 你的程序输出一行 18 个整数，每个整数在 2 到 18 之间（包含），第 $i$ 个数表示你希望第 $i$ 个风车当晚拥有的叶片数。\n- 评测器返回一行 18 个整数，第 $i$ 个数表示早上第 $i$ 个风车朝下的叶片编号（经过地鼠捣乱后）。如果你输出了非法数据（如超出范围的数字或格式错误），评测器会返回 -1。\n\n每个夜晚，对于每只地鼠，选择哪个风车是独立且等概率的（伪）随机选择，与其他地鼠（包括自己）在任何夜晚的选择都无关。\n\n在进行 0 到 $\\mathbf{N}$ 次上述交互后，你必须再进行一次如下形式的交互：\n\n- 你的程序输出一个整数，表示你猜测的地鼠数量 $\\mathbf{G}$。\n- 评测器返回一行一个整数：如果你的答案正确则为 1，否则为 -1（或你输出了格式错误的行）。\n\n当评测器向你的输入流发送 -1（因为数据非法或答案错误）后，不会再发送其他输出。如果你的程序在收到 -1 后仍然等待评测器输出，将会超时（TLE）。请注意，你有责任在收到 -1 后及时退出，以获得 Wrong Answer 判决而不是 Time Limit Exceeded。如果超出内存限制或发生运行时错误，将获得相应的判决。", "inputFormat": "见交互协议。", "outputFormat": "见交互协议。", "hint": "**交互样例**\n\n本交互对应于测试集 1。假设评测器实际设定的地鼠数量为 10。\n\n```\n  t, n, m = readline_int_list()   // 读取 t=20, n=365, m=100。\n  // 第一天选择风车叶片数。\n  printline 2 2 2 2 18 3 3 3 3 3 3 4 4 4 4 5 2 2 到标准输出\n  flush stdout\n  // 读取 0 0 0 0 0 0 1 2 1 0 1 2 0 0 0 0 1 0 到 res。\n  res = readline_int_list()\n  // 第二天选择风车叶片数。\n  printline 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 2 到标准输出\n  flush stdout\n  // 读取 0 1 1 2 0 0 1 0 0 0 0 0 0 1 0 0 0 0 到 res。\n  res = readline_int_list()\n  printline 8 到标准输出        // 我们做了一个错误的猜测，尽管还可以调查 363 个夜晚。\n  flush stdout\n  // 读取 -1 到 verdict（评测器判定我们的解答错误）\n  exit                         // 退出以避免 TLE 错误\n```\n\n注意，即使猜测与已知信息一致，如果不是正确答案，依然会判错。\n\n你可以使用本题的测试工具在本地或平台上测试。若要在本地测试，你需要让测试工具与代码并行运行；你可以使用我们的 [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)。更多信息请阅读该文件注释中的说明。\n\n测试工具的使用说明已包含在工具注释中。我们鼓励你添加自己的测试用例。请注意，虽然测试工具旨在模拟评测系统，但它**不是**真实的评测系统，可能会有不同表现。\n\n**数据范围**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 20$。\n\n**测试集 1（11 分，可见）**\n\n- $\\mathrm{N}=365$。\n- $\\mathrm{M}=100$。\n\n**测试集 2（21 分，隐藏）**\n\n- $\\mathrm{N}=7$。\n- $\\mathrm{M}=10^{6}$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13108", "type": "P", "difficulty": 4, "samples": [["4\n2\nTARPOL\nPROL\n3\nTARPOR\nPROL\nTARPRO\n6\nCODEJAM\nJAM\nHAM\nNALAM\nHUM\nNOLOM\n4\nPI\nHI\nWI\nFI", "Case #1: 2\nCase #2: 0\nCase #3: 6\nCase #4: 2"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2019", "字典树 Trie", "Google Code Jam"], "title": "[GCJ 2019 #1A] Alien Rhyme", "background": "", "description": "During some extraterrestrial exploration, you found evidence of alien poetry! Your team of linguists has determined that each word in the alien language has an accent on exactly one position (letter) in the word; the part of the word starting from the accented letter is called the accent-suffix. Two words are said to rhyme if both of their accent-suffixes are equal. For example, the words $\\text{PROL}$ and $\\text{TARPOL}$ rhyme if the accented letter in both is the $\\text{o}$ or the $\\text{L}$, but they do not rhyme if the accented letters are the $\\text{RS}$, or the $\\text{R}$ in $\\text{PROL}$ and the $\\text{P}$ in $\\text{TARPOL}$, or the $\\text{O}$ in $\\text{PROL}$ and the $\\text{L}$ in $\\text{TARPOL}$.\n\nYou have recovered a list of $N$ words that may be part of an alien poem. Unfortunately, you do not know which is the accented letter for each word. You believe that you can discard zero or more of these words, assign accented letters to the remaining words, and then arrange those words into pairs such that each word rhymes only with the other word in its pair, and with none of the words in other pairs.\n\nYou want to know the largest number of words that can be arranged into pairs in this way.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case starts with a line with a single integer $N$. Then, $N$ lines follow, each of which contains a string $W_i$ of uppercase English letters, representing a distinct word. Notice that the same word can have different accentuations in different test cases.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the size of the largest subset of words meeting the criteria described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the two words can rhyme with an appropriate accent assignment, as described above, so the largest subset is the entire input.\n\nIn Sample Case #2, no two words can rhyme regardless of how we assign accents, because any two suffixes will differ at least in the last letter. Therefore, the largest subset is the empty one, of size 0.\n\nIn Sample Case #3, we can use the entire set of words if we accentuate `CODEJAM` and `JAM` at the `J`s, `HAM` and `NALAM` at their last `A`s and `HUM` and `NOLOM` at the Ms.\n\nIn Sample Case #4, any two words can be made to rhyme, but always by making the accented letter the `I`. Therefore, if we add two pairs to the subset, words from different pairs will rhyme. We can, thus, only form a subset of size 2, by choosing any 2 of the input words.\n\n**Limits**\n\n- $1 \\leq T \\leq 100.$\n- $1 \\leq \\text{length of } W_i \\leq 50,$ for all $i.$\n- $W_i$ consists of uppercase English letters, for all $i.$\n- $W_i \\neq W_j,$ for all $i \\neq j.$ (Words are not repeated within a test case.)\n\n**Test set 1 (10 Pts, Visible)**\n\n- $2 \\leq N \\leq 6.$\n\n**Test set 2 (27 Pts, Hidden)**\n\n- $2 \\leq N \\leq 1000.$", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #1A] Alien Rhyme", "background": "", "description": "During some extraterrestrial exploration, you found evidence of alien poetry! Your team of linguists has determined that each word in the alien language has an accent on exactly one position (letter) in the word; the part of the word starting from the accented letter is called the accent-suffix. Two words are said to rhyme if both of their accent-suffixes are equal. For example, the words $\\text{PROL}$ and $\\text{TARPOL}$ rhyme if the accented letter in both is the $\\text{o}$ or the $\\text{L}$, but they do not rhyme if the accented letters are the $\\text{RS}$, or the $\\text{R}$ in $\\text{PROL}$ and the $\\text{P}$ in $\\text{TARPOL}$, or the $\\text{O}$ in $\\text{PROL}$ and the $\\text{L}$ in $\\text{TARPOL}$.\n\nYou have recovered a list of $N$ words that may be part of an alien poem. Unfortunately, you do not know which is the accented letter for each word. You believe that you can discard zero or more of these words, assign accented letters to the remaining words, and then arrange those words into pairs such that each word rhymes only with the other word in its pair, and with none of the words in other pairs.\n\nYou want to know the largest number of words that can be arranged into pairs in this way.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case starts with a line with a single integer $N$. Then, $N$ lines follow, each of which contains a string $W_i$ of uppercase English letters, representing a distinct word. Notice that the same word can have different accentuations in different test cases.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the size of the largest subset of words meeting the criteria described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the two words can rhyme with an appropriate accent assignment, as described above, so the largest subset is the entire input.\n\nIn Sample Case #2, no two words can rhyme regardless of how we assign accents, because any two suffixes will differ at least in the last letter. Therefore, the largest subset is the empty one, of size 0.\n\nIn Sample Case #3, we can use the entire set of words if we accentuate `CODEJAM` and `JAM` at the `J`s, `HAM` and `NALAM` at their last `A`s and `HUM` and `NOLOM` at the Ms.\n\nIn Sample Case #4, any two words can be made to rhyme, but always by making the accented letter the `I`. Therefore, if we add two pairs to the subset, words from different pairs will rhyme. We can, thus, only form a subset of size 2, by choosing any 2 of the input words.\n\n**Limits**\n\n- $1 \\leq T \\leq 100.$\n- $1 \\leq \\text{length of } W_i \\leq 50,$ for all $i.$\n- $W_i$ consists of uppercase English letters, for all $i.$\n- $W_i \\neq W_j,$ for all $i \\neq j.$ (Words are not repeated within a test case.)\n\n**Test set 1 (10 Pts, Visible)**\n\n- $2 \\leq N \\leq 6.$\n\n**Test set 2 (27 Pts, Hidden)**\n\n- $2 \\leq N \\leq 1000.$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #1A] Alien Rhyme", "background": null, "description": "在一次外星探索中，你发现了外星诗歌的证据！你的语言学家团队确定，外星语言中的每个单词都有且只有一个字母带有重音；从重音字母开始到单词结尾的部分称为“重音后缀”。如果两个单词的重音后缀相同，则称这两个单词押韵。例如，单词 $\\text{PROL}$ 和 $\\text{TARPOL}$，如果它们的重音字母都是 $\\text{o}$ 或 $\\text{L}$，则它们押韵；但如果重音字母分别是 $\\text{RS}$，或者 $\\text{PROL}$ 的重音字母是 $\\text{R}$ 而 $\\text{TARPOL}$ 的重音字母是 $\\text{P}$，又或者 $\\text{PROL}$ 的重音字母是 $\\text{O}$ 而 $\\text{TARPOL}$ 的重音字母是 $\\text{L}$，则它们不押韵。\n\n你找回了一份包含 $N$ 个单词的列表，这些单词可能是外星诗歌的一部分。不幸的是，你并不知道每个单词的重音字母是哪一个。你可以选择丢弃零个或多个单词，对剩下的单词分配重音字母，然后将这些单词两两配对，使得每个单词只与它的配对单词押韵，并且不与其他配对中的单词押韵。\n\n你想知道，最多能有多少个单词可以这样被配对。", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行为一个整数 $N$。接下来的 $N$ 行，每行包含一个由大写英文字母组成的字符串 $W_i$，表示一个不同的单词。注意，在不同的测试用例中，相同的单词可以有不同的重音分配方式。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是满足上述条件的最大单词数量。", "hint": "**样例解释**\n\n在样例 1 中，这两个单词可以通过合适的重音分配使其押韵，因此最大子集就是全部单词。\n\n在样例 2 中，无论如何分配重音，都没有两个单词能押韵，因为任何两个后缀的最后一个字母都不同。因此最大子集为空，大小为 0。\n\n在样例 3 中，如果将 `CODEJAM` 和 `JAM` 的重音都放在 `J` 上，将 `HAM` 和 `NALAM` 的重音都放在最后一个 `A` 上，将 `HUM` 和 `NOLOM` 的重音都放在 `M` 上，则可以使用全部单词。\n\n在样例 4 中，任意两个单词都可以押韵，但总是通过把重音放在 `I` 上实现。因此，如果选取两个配对，来自不同配对的单词也会押韵。因此最多只能选取 2 个单词组成一个配对。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq W_i$ 的长度 $\\leq 50$。\n- $W_i$ 仅包含大写英文字母。\n- 对于同一测试用例，$W_i \\neq W_j$，即单词不重复。\n\n**测试点 1（10 分，可见）**\n\n- $2 \\leq N \\leq 6$。\n\n**测试点 2（27 分，隐藏）**\n\n- $2 \\leq N \\leq 1000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13109", "type": "P", "difficulty": 3, "samples": [["3\n1 10\n5 5 N\n4 10\n2 4 N\n2 6 S\n1 5 E\n3 5 W\n8 10\n0 2 S\n0 3 N\n0 3 N\n0 4 N\n0 5 S\n0 5 S\n0 8 S\n1 5 W", "Case #1: 0 6\nCase #2: 2 5\nCase #3: 0 4"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2019", "差分", "Google Code Jam"], "title": "[GCJ 2019 #1B] Manhattan Crepe Cart", "background": "", "description": "There are a lot of great streetside food vendors in Manhattan, but without a doubt, the one with the tastiest food is the Code Jam Crepe Cart!\n\nYou want to find the cart, but you do not know where it is, except that it is at some street intersection. You believe that people from across Manhattan are currently walking toward that intersection, so you will try to identify the intersection toward which the most people are traveling.\n\nFor the purposes of this problem, Manhattan is a regular grid with its axes aligned to compass lines and bounded between 0 and $\\mathbf{Q}$, inclusive, on each axis. There are west-east streets corresponding to gridlines $y = 0$, $y = 1$, $y = 2$, $\\cdots$, $y = \\mathbf{Q}$ and south-north streets corresponding to gridlines $x = 0$, $x = 1$, $x = 2$, $\\cdots$, $x = \\mathbf{Q}$, and people move only along these streets. The points where the lines meet — e.g., $(0, 0)$ and $(1, 2)$ — are intersections. The shortest distance between two intersections is measured via the Manhattan distance — that is, by the sum of the absolute horizontal difference and the absolute vertical difference between the two sets of coordinates.\n\nYou know the locations of $\\mathbf{P}$ people, all of whom are standing at intersections, and the compass direction each person is headed: north (increasing $y$ direction), south (decreasing $y$ direction), east (increasing $x$ direction), or west (decreasing $x$ direction). A person is moving toward a street intersection if their current movement is on a shortest path to that street intersection within the Manhattan grid. For example, if a person located at $(x_0, y_0)$ is moving north, then they are moving toward all street intersections that have coordinates $(x, y)$ with $y > y_0$.\n\nYou think the crepe cart is at the intersection toward which the most people are traveling. Moreover, you believe that more southern and western parts of the island are most likely to have a crepe cart, so if there are multiple such intersections, you will choose the one with the smallest non-negative $x$ coordinate, and if there are multiple such intersections with that same $x$ coordinate, the one among those with the smallest non-negative $y$ coordinate. Which intersection will you choose?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with one line containing two integers $\\mathbf{P}$ and $\\mathbf{Q}$: the number of people, and the maximum possible value of an $x$ or $y$ coordinate in Manhattan, as described above. Then, there are $\\mathbf{P}$ more lines. The $i$-th of those lines contains two integers $\\mathbf{X}_i$ and $\\mathbf{Y}_i$, the current location (street corner) of a person, and a character $\\mathbf{D}_i$, the direction that person is headed. $\\mathbf{D}_i$ is one of the uppercase letters N, S, E, or W, which stand for north, south, east, and west, respectively.", "outputFormat": "For each test case, output one line containing `Case #t: x y`, where $t$ is the test case number (starting from 1) and $x$ and $y$ are the horizontal and vertical coordinates of the intersection where you believe the crepe cart is located.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there is only one person, and they are moving north from $(5, 5)$. This means that all street corners with $y \\geqslant 6$ are possible locations for the crepe cart. Of those possibilities, we choose the one with lowest $x \\geqslant 0$ and then lowest $y \\geqslant 6$.\n\nIn Sample Case #2, there are four people, all moving toward location $(2, 5)$. There is no other location that has as many people moving toward it.\n\nIn Sample Case #3, six of the eight people are moving toward location $(0, 4)$. There is no other location that has as many people moving toward it.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{P} \\leqslant 500$.\n- $0 \\leqslant \\mathbf{X}_i \\leqslant \\mathbf{Q}$, for all $i$.\n- $0 \\leqslant \\mathbf{Y}_i \\leqslant \\mathbf{Q}$, for all $i$.\n- For all $i$, if $\\mathbf{X}_i = 0$, $\\mathbf{D}_i \\neq \\text{w}$.\n- For all $i$, if $\\mathbf{Y}_i = 0$, $\\mathbf{D}_i \\neq \\text{s}$.\n- For all $i$, if $\\mathbf{X}_i = \\mathbf{Q}$, $\\mathbf{D}_i \\neq \\text{E}$.\n- For all $i$, if $\\mathbf{Y}_i = \\mathbf{Q}$, $\\mathbf{D}_i \\neq \\text{N}$.\n\n**Test set 1 (9 Pts, Visible)**\n\n- $\\mathbf{Q} = 10$.\n\n**Test set 2 (18 Pts, Hidden)**\n\n- $\\mathbf{Q} = 10^5$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #1B] Manhattan Crepe Cart", "background": "", "description": "There are a lot of great streetside food vendors in Manhattan, but without a doubt, the one with the tastiest food is the Code Jam Crepe Cart!\n\nYou want to find the cart, but you do not know where it is, except that it is at some street intersection. You believe that people from across Manhattan are currently walking toward that intersection, so you will try to identify the intersection toward which the most people are traveling.\n\nFor the purposes of this problem, Manhattan is a regular grid with its axes aligned to compass lines and bounded between 0 and $\\mathbf{Q}$, inclusive, on each axis. There are west-east streets corresponding to gridlines $y = 0$, $y = 1$, $y = 2$, $\\cdots$, $y = \\mathbf{Q}$ and south-north streets corresponding to gridlines $x = 0$, $x = 1$, $x = 2$, $\\cdots$, $x = \\mathbf{Q}$, and people move only along these streets. The points where the lines meet — e.g., $(0, 0)$ and $(1, 2)$ — are intersections. The shortest distance between two intersections is measured via the Manhattan distance — that is, by the sum of the absolute horizontal difference and the absolute vertical difference between the two sets of coordinates.\n\nYou know the locations of $\\mathbf{P}$ people, all of whom are standing at intersections, and the compass direction each person is headed: north (increasing $y$ direction), south (decreasing $y$ direction), east (increasing $x$ direction), or west (decreasing $x$ direction). A person is moving toward a street intersection if their current movement is on a shortest path to that street intersection within the Manhattan grid. For example, if a person located at $(x_0, y_0)$ is moving north, then they are moving toward all street intersections that have coordinates $(x, y)$ with $y > y_0$.\n\nYou think the crepe cart is at the intersection toward which the most people are traveling. Moreover, you believe that more southern and western parts of the island are most likely to have a crepe cart, so if there are multiple such intersections, you will choose the one with the smallest non-negative $x$ coordinate, and if there are multiple such intersections with that same $x$ coordinate, the one among those with the smallest non-negative $y$ coordinate. Which intersection will you choose?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with one line containing two integers $\\mathbf{P}$ and $\\mathbf{Q}$: the number of people, and the maximum possible value of an $x$ or $y$ coordinate in Manhattan, as described above. Then, there are $\\mathbf{P}$ more lines. The $i$-th of those lines contains two integers $\\mathbf{X}_i$ and $\\mathbf{Y}_i$, the current location (street corner) of a person, and a character $\\mathbf{D}_i$, the direction that person is headed. $\\mathbf{D}_i$ is one of the uppercase letters N, S, E, or W, which stand for north, south, east, and west, respectively.", "outputFormat": "For each test case, output one line containing `Case #t: x y`, where $t$ is the test case number (starting from 1) and $x$ and $y$ are the horizontal and vertical coordinates of the intersection where you believe the crepe cart is located.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there is only one person, and they are moving north from $(5, 5)$. This means that all street corners with $y \\geqslant 6$ are possible locations for the crepe cart. Of those possibilities, we choose the one with lowest $x \\geqslant 0$ and then lowest $y \\geqslant 6$.\n\nIn Sample Case #2, there are four people, all moving toward location $(2, 5)$. There is no other location that has as many people moving toward it.\n\nIn Sample Case #3, six of the eight people are moving toward location $(0, 4)$. There is no other location that has as many people moving toward it.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{P} \\leqslant 500$.\n- $0 \\leqslant \\mathbf{X}_i \\leqslant \\mathbf{Q}$, for all $i$.\n- $0 \\leqslant \\mathbf{Y}_i \\leqslant \\mathbf{Q}$, for all $i$.\n- For all $i$, if $\\mathbf{X}_i = 0$, $\\mathbf{D}_i \\neq \\text{w}$.\n- For all $i$, if $\\mathbf{Y}_i = 0$, $\\mathbf{D}_i \\neq \\text{s}$.\n- For all $i$, if $\\mathbf{X}_i = \\mathbf{Q}$, $\\mathbf{D}_i \\neq \\text{E}$.\n- For all $i$, if $\\mathbf{Y}_i = \\mathbf{Q}$, $\\mathbf{D}_i \\neq \\text{N}$.\n\n**Test set 1 (9 Pts, Visible)**\n\n- $\\mathbf{Q} = 10$.\n\n**Test set 2 (18 Pts, Hidden)**\n\n- $\\mathbf{Q} = 10^5$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #1B] Manhattan Crepe Cart", "background": null, "description": "曼哈顿有许多很棒的街头小吃摊，但毫无疑问，味道最棒的是 Code Jam 可丽饼车！\n\n你想找到这辆小吃车，但你只知道它在某个街道交叉口。你认为来自曼哈顿各地的人们正朝着这个交叉口走去，因此你会尝试找出最多人正前往的那个交叉口。\n\n在本题中，曼哈顿是一张规则的网格，坐标轴与罗盘方向对齐，每个坐标轴的取值范围为 $0$ 到 $\\mathbf{Q}$（包含 $0$ 和 $\\mathbf{Q}$）。东西向的街道对应于 $y = 0, y = 1, y = 2, \\cdots, y = \\mathbf{Q}$ 的网格线，南北向的街道对应于 $x = 0, x = 1, x = 2, \\cdots, x = \\mathbf{Q}$ 的网格线，人们只能沿着这些街道行走。网格线的交点（如 $(0, 0)$ 和 $(1, 2)$）即为街道交叉口。两个交叉口之间的最短距离是曼哈顿距离，即横向距离与纵向距离的绝对值之和。\n\n你知道有 $\\mathbf{P}$ 个人的位置，他们都站在交叉口上，并且你知道每个人当前前进的方向：北（$y$ 增大方向）、南（$y$ 减小方向）、东（$x$ 增大方向）或西（$x$ 减小方向）。如果某个人当前的移动方向在曼哈顿网格中是通往某个交叉口的最短路径之一，则认为此人正朝该交叉口前进。例如，如果某人位于 $(x_0, y_0)$ 并向北移动，则他们正朝所有 $y > y_0$ 的交叉口前进。\n\n你认为可丽饼车就在最多人正前往的交叉口处。此外，你认为岛屿的更南部和更西部更有可能有可丽饼车，因此如果有多个这样的交叉口，你会选择 $x$ 坐标最小的那个，如果仍有多个，则选择 $y$ 坐标最小的那个。你会选择哪个交叉口？", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。接下来是 $\\mathbf{T}$ 组测试用例。每组测试用例的第一行包含两个整数 $\\mathbf{P}$ 和 $\\mathbf{Q}$，分别表示人数和曼哈顿坐标的最大值。接下来的 $\\mathbf{P}$ 行，每行包含两个整数 $\\mathbf{X}_i$ 和 $\\mathbf{Y}_i$，表示第 $i$ 个人当前所在的交叉口，以及一个字符 $\\mathbf{D}_i$，表示该人前进的方向。$\\mathbf{D}_i$ 是大写字母 N、S、E 或 W，分别代表北、南、东和西。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #t: x y`，其中 $t$ 是测试用例编号（从 1 开始），$x$ 和 $y$ 分别为你认为可丽饼车所在交叉口的横纵坐标。", "hint": "**样例解释**\n\n在样例 1 中，只有一个人，他从 $(5, 5)$ 向北移动。这意味着所有 $y \\geqslant 6$ 的交叉口都是可丽饼车可能的位置。在这些位置中，选择 $x \\geqslant 0$ 最小的，再选择 $y \\geqslant 6$ 最小的。\n\n在样例 2 中，有四个人都朝着 $(2, 5)$ 这个位置移动，没有其他位置有这么多人朝向。\n\n在样例 3 中，八个人中有六个人都朝着 $(0, 4)$ 这个位置移动，没有其他位置有这么多人朝向。\n\n**数据范围**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$。\n- $1 \\leqslant \\mathbf{P} \\leqslant 500$。\n- $0 \\leqslant \\mathbf{X}_i \\leqslant \\mathbf{Q}$，对所有 $i$。\n- $0 \\leqslant \\mathbf{Y}_i \\leqslant \\mathbf{Q}$，对所有 $i$。\n- 对所有 $i$，如果 $\\mathbf{X}_i = 0$，则 $\\mathbf{D}_i \\neq \\text{W}$。\n- 对所有 $i$，如果 $\\mathbf{Y}_i = 0$，则 $\\mathbf{D}_i \\neq \\text{S}$。\n- 对所有 $i$，如果 $\\mathbf{X}_i = \\mathbf{Q}$，则 $\\mathbf{D}_i \\neq \\text{E}$。\n- 对所有 $i$，如果 $\\mathbf{Y}_i = \\mathbf{Q}$，则 $\\mathbf{D}_i \\neq \\text{N}$。\n\n**测试点 1（9 分，可见）**\n\n- $\\mathbf{Q} = 10$。\n\n**测试点 2（18 分，隐藏）**\n\n- $\\mathbf{Q} = 10^5$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13110", "type": "P", "difficulty": 4, "samples": [["", ""]], "limits": {"time": [20000, 20000], "memory": [1048576, 1048576]}, "tags": ["2019", "交互题", "Special Judge", "进制", "位运算", "Google Code Jam"], "title": "[GCJ 2019 #1B] Draupnir", "background": "", "description": "Odin has some magical rings which produce copies of themselves. Each \"X-day ring\" produces one more X-day ring every X days after the day it came into existence. These rings come in six possible varieties: 1-day, 2-day, ..., all the way up to 6-day.\n\nFor example, a 3-day ring that came into existence on day 0 would do nothing until day 3, when it would produce another 3-day ring. Then, on day 6, each of those two rings would produce another 3-day ring, and so on.\n\nYou know that Odin had no rings before day 0. On day 0, some rings came into existence. At the end of day 0, Odin had $R_i$ i-day rings, for each $1 \\leqslant i \\leqslant 6$. You know that $0 \\leqslant R_i \\leqslant 100$, for all $i$, and at least one of the $R_i$ values is positive.\n\nFortunately, you also have access to the secret well of knowledge. Each time you use it, you can find out the total number of rings that Odin had at the end of a particular day between day 1 and day 500, inclusive. The well will give you the answer modulo $2^{63}$, because even it can only hold so much information! Moreover, you can only use the well up to W times.\n\nYour goal is to determine how many rings of each type Odin had at the end of day 0 — that is, you must find each of the $R_i$ values.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing two integers $\\mathbf{T}$, the number of test cases, and $\\mathbf{W}$, the number of times you are allowed to use the well of knowledge per test case. Then, you need to process $\\mathbf{T}$ test cases.\n\nIn each test case, your program processes up to $\\mathbf{W} + 1$ exchanges with our judge. You may make up to $\\mathbf{W}$ exchanges of the following form:\n\n* Your program outputs one line with a single integer $\\mathbf{D}$ between 1 and 500, inclusive.\n* The judge responds with one line with a single integer: the total number of rings that Odin had at the end of day $\\mathbf{D}$, modulo $2^{63}$. If you send invalid data (e.g., a number out of range, or a malformed line), the judge instead responds with -1.\n\nAfter between 0 and $\\mathbf{W}$ exchanges as explained above, you must perform one more exchange of the following form:\n\n* Your program outputs one line with six integers $\\mathbf{R}_1$, $\\mathbf{R}_2$, $\\mathbf{R}_3$, $\\mathbf{R}_4$, $\\mathbf{R}_5$, $\\mathbf{R}_6$, where $\\mathbf{R}_i$ represents the number of i-day rings that Odin had at the end of day 0.\n* The judge responds with one line with a single integer: 1 if your answer is correct, and -1 if it is not (or you have provided a malformed line).\n\nAfter the judge sends -1 to your input stream (because of either invalid data or an incorrect answer), it will not send any other output. If your program continues to wait for the judge after receiving -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\nThis interaction corresponds to Test set 1. Suppose that, unbeknownst to us, the judge has decided that Odin had one ring of each of the six types at the end of day 0.\n\n```\n  t, w = readline_int_list()   // Reads 50 into t and 6 into w\n  printline 3 to stdout        // Asks about day 3.\n  flush stdout\n  n = readline_int()           // Reads 15 into n.\n  printline 1 to stdout        // Asks about day 1.\n  flush stdout\n  n = readline_int()           // Reads 7 into n.\n  printline 1 1 1 3 0 0 to stdout\n  flush stdout                 // We make a guess even though we could have\n                               // queried the well up to four more times.\n  verdict = readline_int()     // Reads -1 into verdict (judge has decided our\n                               //   solution is incorrect)\n  exit                         // Exits to avoid an ambiguous TLE error\n```\n\nNotice that even though the guess was consistent with the information we received from the judge, we were still wrong because we did not find the correct values.\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $1 \\leq T \\leq 50$.\n\n**Test set 1 (10 Pts, Visible)**\n\n- $W = 6$.\n\n**Test set 2 (21 Pts, Hidden)**\n\n- $W = 2$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #1B] Draupnir", "background": "", "description": "Odin has some magical rings which produce copies of themselves. Each \"X-day ring\" produces one more X-day ring every X days after the day it came into existence. These rings come in six possible varieties: 1-day, 2-day, ..., all the way up to 6-day.\n\nFor example, a 3-day ring that came into existence on day 0 would do nothing until day 3, when it would produce another 3-day ring. Then, on day 6, each of those two rings would produce another 3-day ring, and so on.\n\nYou know that Odin had no rings before day 0. On day 0, some rings came into existence. At the end of day 0, Odin had $R_i$ i-day rings, for each $1 \\leqslant i \\leqslant 6$. You know that $0 \\leqslant R_i \\leqslant 100$, for all $i$, and at least one of the $R_i$ values is positive.\n\nFortunately, you also have access to the secret well of knowledge. Each time you use it, you can find out the total number of rings that Odin had at the end of a particular day between day 1 and day 500, inclusive. The well will give you the answer modulo $2^{63}$, because even it can only hold so much information! Moreover, you can only use the well up to W times.\n\nYour goal is to determine how many rings of each type Odin had at the end of day 0 — that is, you must find each of the $R_i$ values.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing two integers $\\mathbf{T}$, the number of test cases, and $\\mathbf{W}$, the number of times you are allowed to use the well of knowledge per test case. Then, you need to process $\\mathbf{T}$ test cases.\n\nIn each test case, your program processes up to $\\mathbf{W} + 1$ exchanges with our judge. You may make up to $\\mathbf{W}$ exchanges of the following form:\n\n* Your program outputs one line with a single integer $\\mathbf{D}$ between 1 and 500, inclusive.\n* The judge responds with one line with a single integer: the total number of rings that Odin had at the end of day $\\mathbf{D}$, modulo $2^{63}$. If you send invalid data (e.g., a number out of range, or a malformed line), the judge instead responds with -1.\n\nAfter between 0 and $\\mathbf{W}$ exchanges as explained above, you must perform one more exchange of the following form:\n\n* Your program outputs one line with six integers $\\mathbf{R}_1$, $\\mathbf{R}_2$, $\\mathbf{R}_3$, $\\mathbf{R}_4$, $\\mathbf{R}_5$, $\\mathbf{R}_6$, where $\\mathbf{R}_i$ represents the number of i-day rings that Odin had at the end of day 0.\n* The judge responds with one line with a single integer: 1 if your answer is correct, and -1 if it is not (or you have provided a malformed line).\n\nAfter the judge sends -1 to your input stream (because of either invalid data or an incorrect answer), it will not send any other output. If your program continues to wait for the judge after receiving -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\nThis interaction corresponds to Test set 1. Suppose that, unbeknownst to us, the judge has decided that Odin had one ring of each of the six types at the end of day 0.\n\n```\n  t, w = readline_int_list()   // Reads 50 into t and 6 into w\n  printline 3 to stdout        // Asks about day 3.\n  flush stdout\n  n = readline_int()           // Reads 15 into n.\n  printline 1 to stdout        // Asks about day 1.\n  flush stdout\n  n = readline_int()           // Reads 7 into n.\n  printline 1 1 1 3 0 0 to stdout\n  flush stdout                 // We make a guess even though we could have\n                               // queried the well up to four more times.\n  verdict = readline_int()     // Reads -1 into verdict (judge has decided our\n                               //   solution is incorrect)\n  exit                         // Exits to avoid an ambiguous TLE error\n```\n\nNotice that even though the guess was consistent with the information we received from the judge, we were still wrong because we did not find the correct values.\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $1 \\leq T \\leq 50$.\n\n**Test set 1 (10 Pts, Visible)**\n\n- $W = 6$.\n\n**Test set 2 (21 Pts, Hidden)**\n\n- $W = 2$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #1B] Draupnir", "background": null, "description": "奥丁拥有一些能够自我复制的魔法戒指。每个“X 天戒指”会在其诞生后的每隔 $X$ 天生产一个同样的 X 天戒指。这些戒指共有六种类型：1 天、2 天、……，一直到 6 天。\n\n例如，一个在第 0 天诞生的 3 天戒指，在第 3 天才会产生另一个 3 天戒指。然后在第 6 天，这两个戒指都会各自再产生一个 3 天戒指，以此类推。\n\n你知道奥丁在第 0 天之前没有任何戒指。在第 0 天，有一些戒指诞生了。在第 0 天结束时，奥丁拥有 $R_i$ 个 $i$ 天戒指，其中 $1 \\leqslant i \\leqslant 6$。你知道 $0 \\leqslant R_i \\leqslant 100$，且至少有一个 $R_i$ 是正数。\n\n幸运的是，你还可以使用知识之井。每次使用时，你可以得知奥丁在某一天（第 1 天到第 500 天之间，包含端点）结束时拥有的戒指总数。由于知识之井的信息容量有限，答案会对 $2^{63}$ 取模。此外，每个测试用例你最多只能使用知识之井 $W$ 次。\n\n你的目标是确定奥丁在第 0 天结束时每种类型的戒指数量——也就是找出每个 $R_i$ 的值。\n\n### 交互协议\n\n这是一个交互题。\n\n最开始，你的程序应读取一行，包含两个整数 $\\mathbf{T}$（测试用例数量）和 $\\mathbf{W}$（每个测试用例允许使用知识之井的次数）。然后，你需要处理 $\\mathbf{T}$ 个测试用例。\n\n在每个测试用例中，你的程序最多可以与评测机进行 $\\mathbf{W} + 1$ 次交互。你可以进行最多 $\\mathbf{W}$ 次如下形式的交互：\n\n- 你的程序输出一行，包含一个整数 $\\mathbf{D}$，表示询问第 $\\mathbf{D}$ 天（$1 \\leqslant D \\leqslant 500$）。\n- 评测机回复一行，包含一个整数：奥丁在第 $\\mathbf{D}$ 天结束时拥有的戒指总数，对 $2^{63}$ 取模。如果你发送了无效数据（如超出范围的数字或格式错误），评测机会回复 $-1$。\n\n在上述 0 到 $\\mathbf{W}$ 次交互后，你必须再进行一次如下形式的交互：\n\n- 你的程序输出一行，包含六个整数 $\\mathbf{R}_1, \\mathbf{R}_2, \\mathbf{R}_3, \\mathbf{R}_4, \\mathbf{R}_5, \\mathbf{R}_6$，分别表示奥丁在第 0 天结束时拥有的 1 天至 6 天戒指数量。\n- 评测机回复一行，包含一个整数：如果你的答案正确，则为 $1$，否则为 $-1$（或格式错误）。\n\n当评测机向你的输入流发送 $-1$（无效数据或答案错误时），它不会再发送其他输出。如果你的程序在收到 $-1$ 后仍然等待评测机回复，将会超时（TLE）。请确保你的程序在收到 $-1$ 后及时退出，以获得 Wrong Answer 判定而不是 Time Limit Exceeded。如果超出内存限制或运行时错误，将获得相应的判定。\n\n#", "inputFormat": "见交互协议。\n\n#", "outputFormat": "见交互协议。\n\n#", "hint": "**交互样例**\n\n该交互对应于测试集 1。假设我们不知道，评测机设定奥丁在第 0 天拥有每种类型各一个戒指。\n\n```\n  t, w = readline_int_list()   // 读取 t=50, w=6\n  printline 3 to stdout        // 询问第 3 天\n  flush stdout\n  n = readline_int()           // 读取 n=15\n  printline 1 to stdout        // 询问第 1 天\n  flush stdout\n  n = readline_int()           // 读取 n=7\n  printline 1 1 1 3 0 0 to stdout\n  flush stdout                 // 我们做出猜测，尽管还可以再询问四次\n  verdict = readline_int()     // 读取 verdict=-1（评测机判定答案错误）\n  exit                         // 及时退出，避免超时\n```\n\n注意，即使我们的猜测与评测机返回的信息一致，但如果答案不正确，依然会被判错。\n\n你可以使用测试工具在本地或平台上测试。若在本地测试，需要并行运行测试工具和你的代码；你可以使用我们的 [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)。更多信息请阅读该文件中的注释。\n\n测试工具的使用说明已包含在工具的注释中。建议你添加自己的测试用例。请注意，虽然测试工具旨在模拟评测系统，但它**不是**真实的评测系统，行为可能有所不同。\n\n**数据范围**\n\n- $1 \\leq T \\leq 50$。\n\n**测试集 1（10 分，可见）**\n\n- $W = 6$。\n\n**测试集 2（21 分，隐藏）**\n\n- $W = 2$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13111", "type": "P", "difficulty": 5, "samples": [["6\n4 0\n1 1 1 8\n8 8 8 8\n3 0\n0 1 1\n1 1 0\n1 0\n3\n3\n5 0\n0 8 0 8 0\n4 0 4 0 4\n3 0\n1 0 0\n0 1 2\n5 2\n1 2 3 4 5\n5 5 5 5 10", "Case #1: 4\nCase #2: 4\nCase #3: 1\nCase #4: 0\nCase #5: 1\nCase #6: 7"]], "limits": {"time": [30000, 30000, 30000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2019", "单调栈", "Google Code Jam"], "title": "[GCJ 2019 #1B] Fair Fight", "background": "", "description": "En garde! Charles and Delila are about to face off against each other in the final fight of the Swordmaster fencing tournament.\n\nAlong one wall of the fencing arena, there is a rack with $\\mathbf{N}$ different types of swords; the swords are numbered by type, from 1 to $\\mathbf{N}$. As the head judge, you will pick a pair of integers $(L, R)$ (with $1 \\leqslant \\mathbf{L} \\leqslant \\mathbf{R} \\leqslant \\mathbf{N}$), and only the L-th through R-th types of swords (inclusive) will be available for the fight.\n\nDifferent types of sword are used in different ways, and being good with one type of sword does not necessarily mean you are good with another! Charles and Delila have skill levels of $\\mathbf{C}_i$ and $\\mathbf{D}_i$, respectively, with the i-th type of sword. Each of them will look at the types of sword you have made available for this fight, and then each will choose a type with which they are most skilled. If there are multiple available types with which a fighter is equally skilled, and that skill level exceeds the fighter's skill level in all other available types, then the fighter will make one of those equally good choices at random. Notice that it is possible for Charles and Delila to choose the same type of sword, which is fine — there are multiple copies of each type of sword available.\n\nThe fight is *fair* if the absolute difference between Charles's skill level with his chosen sword type and Delila's skill level with her chosen sword type is at most $\\mathbf{K}$. To keep the fight exciting, you'd like to know how many different pairs $(L, R)$ you can choose that will result in a fair fight.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case begins with a line containing the two integers $\\mathbf{N}$ and $\\mathbf{K}$, as described above. Then, two more lines follow. The first of these lines contains $\\mathbf{N}$ integers $\\mathbf{C}_i$, giving Charles's skill levels for each type of sword, as described above. Similarly, the second line contains $\\mathbf{N}$ integers $\\mathbf{D}_i$, giving Delila's skill levels.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of choices you can make that result in a fair fight, as described above.", "hint": "**Sample Explanation**\n\n- In Sample Case #1, the fight is fair if and only if Charles can use the last type of sword, so the answer is $4$.\n- In Sample Case #2, there are $4$ fair fights: $(1, 2)$, $(1, 3)$, $(2, 2)$, and $(2, 3)$. Notice that for pairs like $(1, 3)$, Charles and Delila both have multiple swords they could choose that they are most skilled with; however, each pair only counts as one fair fight.\n- In Sample Case #3, there is $1$ fair fight: $(1, 1)$.\n- In Sample Case #4, there are no fair fights, so the answer is $0$.\n- In Sample Case #5, remember that the *duelists* are not trying to make the fights fair; they choose the type of sword that they are most skilled with. For example, $(1, 3)$ is not a fair fight, because Charles will choose the first type of sword, and Delila will choose the third type of sword. Delila will not go easy on Charles by choosing a weaker sword!\n- In Sample Case #6, there are $7$ fair fights: $(1, 3)$, $(1, 4)$, $(2, 3)$, $(2, 4)$, $(3, 3)$, $(3, 4)$, and $(4, 4)$.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $0 \\leqslant \\mathbf{K} \\leqslant 10^5$.\n- $0 \\leqslant \\mathbf{C}_i \\leqslant 10^5$, for all $i$.\n- $0 \\leqslant \\mathbf{D}_i \\leqslant 10^5$, for all $i$.\n\n**Test set 1 (14 Pts, Visible)**\n\n- $1 \\leqslant \\mathbf{N} \\leqslant 100$.\n\n**Test set 2 (28 Pts, Hidden)**\n\n- $\\mathbf{N} = 10^5$, for exactly 8 test cases.\n- $1 \\leqslant \\mathbf{N} \\leqslant 1000$, for all but 8 test cases.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #1B] Fair Fight", "background": "", "description": "En garde! Charles and Delila are about to face off against each other in the final fight of the Swordmaster fencing tournament.\n\nAlong one wall of the fencing arena, there is a rack with $\\mathbf{N}$ different types of swords; the swords are numbered by type, from 1 to $\\mathbf{N}$. As the head judge, you will pick a pair of integers $(L, R)$ (with $1 \\leqslant \\mathbf{L} \\leqslant \\mathbf{R} \\leqslant \\mathbf{N}$), and only the L-th through R-th types of swords (inclusive) will be available for the fight.\n\nDifferent types of sword are used in different ways, and being good with one type of sword does not necessarily mean you are good with another! Charles and Delila have skill levels of $\\mathbf{C}_i$ and $\\mathbf{D}_i$, respectively, with the i-th type of sword. Each of them will look at the types of sword you have made available for this fight, and then each will choose a type with which they are most skilled. If there are multiple available types with which a fighter is equally skilled, and that skill level exceeds the fighter's skill level in all other available types, then the fighter will make one of those equally good choices at random. Notice that it is possible for Charles and Delila to choose the same type of sword, which is fine — there are multiple copies of each type of sword available.\n\nThe fight is *fair* if the absolute difference between Charles's skill level with his chosen sword type and Delila's skill level with her chosen sword type is at most $\\mathbf{K}$. To keep the fight exciting, you'd like to know how many different pairs $(L, R)$ you can choose that will result in a fair fight.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case begins with a line containing the two integers $\\mathbf{N}$ and $\\mathbf{K}$, as described above. Then, two more lines follow. The first of these lines contains $\\mathbf{N}$ integers $\\mathbf{C}_i$, giving Charles's skill levels for each type of sword, as described above. Similarly, the second line contains $\\mathbf{N}$ integers $\\mathbf{D}_i$, giving Delila's skill levels.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of choices you can make that result in a fair fight, as described above.", "hint": "**Sample Explanation**\n\n- In Sample Case #1, the fight is fair if and only if Charles can use the last type of sword, so the answer is $4$.\n- In Sample Case #2, there are $4$ fair fights: $(1, 2)$, $(1, 3)$, $(2, 2)$, and $(2, 3)$. Notice that for pairs like $(1, 3)$, Charles and Delila both have multiple swords they could choose that they are most skilled with; however, each pair only counts as one fair fight.\n- In Sample Case #3, there is $1$ fair fight: $(1, 1)$.\n- In Sample Case #4, there are no fair fights, so the answer is $0$.\n- In Sample Case #5, remember that the *duelists* are not trying to make the fights fair; they choose the type of sword that they are most skilled with. For example, $(1, 3)$ is not a fair fight, because Charles will choose the first type of sword, and Delila will choose the third type of sword. Delila will not go easy on Charles by choosing a weaker sword!\n- In Sample Case #6, there are $7$ fair fights: $(1, 3)$, $(1, 4)$, $(2, 3)$, $(2, 4)$, $(3, 3)$, $(3, 4)$, and $(4, 4)$.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $0 \\leqslant \\mathbf{K} \\leqslant 10^5$.\n- $0 \\leqslant \\mathbf{C}_i \\leqslant 10^5$, for all $i$.\n- $0 \\leqslant \\mathbf{D}_i \\leqslant 10^5$, for all $i$.\n\n**Test set 1 (14 Pts, Visible)**\n\n- $1 \\leqslant \\mathbf{N} \\leqslant 100$.\n\n**Test set 2 (28 Pts, Hidden)**\n\n- $\\mathbf{N} = 10^5$, for exactly 8 test cases.\n- $1 \\leqslant \\mathbf{N} \\leqslant 1000$, for all but 8 test cases.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #1B] Fair Fight", "background": null, "description": "准备好！Charles 和 Delila 即将在剑术大师击剑锦标赛的决赛中一决高下。\n\n在击剑场的一面墙上，有一个剑架，上面放着 $N$ 种不同类型的剑；这些剑按照类型编号，从 $1$ 到 $N$。作为主裁判，你将选择一对整数 $(L, R)$（满足 $1 \\leqslant L \\leqslant R \\leqslant N$），只有第 $L$ 种到第 $R$ 种（包含两端）的剑可以用于本场比赛。\n\n不同类型的剑使用方式各异，擅长一种剑并不意味着擅长另一种！Charles 和 Delila 分别对第 $i$ 种剑的熟练度为 $C_i$ 和 $D_i$。他们会查看你为本场比赛指定的可用剑的类型，然后各自选择自己最擅长的一种剑。如果有多种可用类型的剑熟练度相同，且该熟练度高于其他所有可用类型，则选手会在这些同样擅长的类型中随机选择一种。注意，Charles 和 Delila 可能会选择同一种剑，这没有问题——每种剑有多把可用。\n\n如果 Charles 选择的剑类型的熟练度与 Delila 选择的剑类型的熟练度之差的绝对值不超过 $K$，则这场比赛是“公平”的。为了让比赛更精彩，你想知道有多少种不同的 $(L, R)$ 选择会导致一场公平的比赛。", "inputFormat": "第一行输入测试用例的数量 $T$。接下来有 $T$ 组测试用例。每组测试用例的第一行包含两个整数 $N$ 和 $K$，含义如上所述。接下来两行，每行包含 $N$ 个整数。第一行为 $C_i$，表示 Charles 对每种剑的熟练度。第二行为 $D_i$，表示 Delila 对每种剑的熟练度。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是能导致公平比赛的 $(L, R)$ 选择的数量。", "hint": "**样例解释**\n\n- 样例 1 中，只有当 Charles 能使用最后一种剑时，比赛才是公平的，所以答案是 $4$。\n- 样例 2 中，有 $4$ 种公平的比赛区间：$(1, 2)$、$(1, 3)$、$(2, 2)$ 和 $(2, 3)$。注意，对于像 $(1, 3)$ 这样的区间，Charles 和 Delila 都有多种最擅长的剑可以选择；但每个区间只计为一次公平比赛。\n- 样例 3 中，只有 $1$ 种公平比赛：$(1, 1)$。\n- 样例 4 中，没有公平比赛，所以答案是 $0$。\n- 样例 5 中，要注意选手不会为了让比赛公平而选择较弱的剑。例如 $(1, 3)$ 不是公平比赛，因为 Charles 会选择第一种剑，Delila 会选择第三种剑。Delila 不会为了照顾 Charles 而选择较弱的剑！\n- 样例 6 中，有 $7$ 种公平比赛区间：$(1, 3)$、$(1, 4)$、$(2, 3)$、$(2, 4)$、$(3, 3)$、$(3, 4)$ 和 $(4, 4)$。\n\n**数据范围**\n\n- $1 \\leqslant T \\leqslant 100$。\n- $0 \\leqslant K \\leqslant 10^5$。\n- $0 \\leqslant C_i \\leqslant 10^5$，对于所有 $i$。\n- $0 \\leqslant D_i \\leqslant 10^5$，对于所有 $i$。\n\n**测试点 1（14 分，公开）**\n\n- $1 \\leqslant N \\leqslant 100$。\n\n**测试点 2（28 分，隐藏）**\n\n- 有 8 个测试用例满足 $N = 10^5$。\n- 除这 8 个测试用例外，其余均满足 $1 \\leqslant N \\leqslant 1000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13112", "type": "P", "difficulty": 4, "samples": [["3\n1\nRS\n3\nR\nP\nS\n7\nRS\nRS\nRS\nRS\nRS\nRS\nRS", "Case #1: RSRSRSP\nCase #2: IMPOSSIBLE\nCase #3: P"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["贪心", "2019", "Special Judge", "Google Code Jam"], "title": "[GCJ 2019 #1C] Robot Programming Strategy", "background": "", "description": "After many sleepless nights, you have finally finished teaching a robotic arm to make the hand gestures required for the Rock-Paper-Scissors game. Now you just need to program it to compete in the upcoming robot tournament!\n\nIn this tournament, each robot uses a program that is a series of moves, each of which must be one of the following: R (for \"Rock\"), P (for \"Paper\"), or S (for \"Scissors\"). Paper beats Rock and loses to Scissors; Rock beats Scissors and loses to Paper; Scissors beats Paper and loses to Rock.\n\nWhen two robots face off in a match, the first robot to play a winning move wins. To start, each robot plays the first move of its program. If the two moves are different, one of the moves beats the other and thus one of the robots wins the match. If the moves are the same, each robot plays the next move in its program, and so on.\n\nWhenever a robot has reached the end of its program and needs its next move, it returns to the start of its program. So, for example, the fifth move of a robot with the program RSSP would be R. If a match goes on for over a googol ($10^{100}$) of moves, the judges flip a fair coin to determine the winner.\n\nOnce a match is over, the winning robot resets, so it has no memory of that match. In its next match, it starts by playing the first move of its program, and so on.\n\nThe tournament is played in K rounds and has a single-elimination \"bracket\" structure. There are N = $2^K$ robots in total, numbered 0 through N - 1. In the first round, robot 0 plays a match against robot 1, robot 2 plays a match against robot 3, and so on, up to robots N - 2 and N - 1. The losers of those matches are eliminated from the tournament. In the second round, the winner of the 0-1 match faces off against the winner of the 2-3 match, and so on. Once we get to the K-th round, there is only one match, and it determines the overall winner of the tournament.\n\nAll of the other contestants are so confident that they have already publicly posted their robots' programs online. However, the robots have not yet been assigned numbers, so nobody knows in advance who their opponents will be. Knowing all of the other programs, is it possible for you to write a program that is guaranteed to win the tournament, no matter how the robot numbers are assigned?", "inputFormat": "The first line of the input gives the number of test cases, $T$; $T$ test cases follow. Each test case begins with one line containing an integer $A$: the number of adversaries (other robots) in the tournament. Then, there are $A$ more lines; the i-th of these contains a string $C_i$ of uppercase letters that represent the program of the i-th opponent's robot.", "outputFormat": "For each test case, output one line containing `Case #x: y`. If there is a string of between 1 and 500 characters that is guaranteed to win the tournament, as described above, then $y$ should be the string of uppercase letters representing that program. Otherwise, $y$ should be IMPOSSIBLE, in uppercase letters.", "hint": "**Sample Explanation**\n\nNote: Although all the opponents in each of these sample cases have programs of the same length, this is not necessarily the case. Opponents within a test case might have programs of different lengths.\n\nIn Sample Case #1, there is only one opponent, with the program RS. Our answer matches the opponent's moves for a while, and the opponent loops through its program several times. As is starts its fourth pass through its program, we beat it with P. Other valid solutions exist, like P, RR, and R.\n\nIn Sample Case #2, there are three opponents, with the programs R, P, and S. It is up to you to figure out why this case is IMPOSSIBLE!\n\nIn Sample Case #3, all seven opponents use the same program. Using the program P, for example, guarantees that you will win. Remember that each robot begins at the start of its program at the start of each match against a new opponent.\n\n**Limits**\n\n- $1 \\leqslant T \\leqslant 100 .$\n- Each character in $\\mathbf{C}_{\\mathbf{i}}$ is uppercase $\\mathbf{R}, \\mathbf{P}$, or $\\mathbf{s}$, for all $\\mathbf{i}$.\n- $\\mathbf{A}=2^{\\mathbf{K}}-1$ for some integer $\\mathbf{K} \\geqslant 1$.\n\n**Test set 1 (10 Pts, Visible)**\n\n- $1 \\leqslant \\mathbf{A} \\leqslant 7$.\n- $\\mathbf{C}_{\\mathbf{i}}$ is between 1 and 5 characters long, for all $\\mathbf{i}$.\n\n**Test set 2 (18 Pts, Hidden)**\n\n- $1 \\leqslant \\mathbf{A} \\leqslant 255$.\n- $\\mathbf{C}_{\\mathbf{i}}$ is between 1 and 500 characters long, for all $\\mathbf{i}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #1C] Robot Programming Strategy", "background": "", "description": "After many sleepless nights, you have finally finished teaching a robotic arm to make the hand gestures required for the Rock-Paper-Scissors game. Now you just need to program it to compete in the upcoming robot tournament!\n\nIn this tournament, each robot uses a program that is a series of moves, each of which must be one of the following: R (for \"Rock\"), P (for \"Paper\"), or S (for \"Scissors\"). Paper beats Rock and loses to Scissors; Rock beats Scissors and loses to Paper; Scissors beats Paper and loses to Rock.\n\nWhen two robots face off in a match, the first robot to play a winning move wins. To start, each robot plays the first move of its program. If the two moves are different, one of the moves beats the other and thus one of the robots wins the match. If the moves are the same, each robot plays the next move in its program, and so on.\n\nWhenever a robot has reached the end of its program and needs its next move, it returns to the start of its program. So, for example, the fifth move of a robot with the program RSSP would be R. If a match goes on for over a googol ($10^{100}$) of moves, the judges flip a fair coin to determine the winner.\n\nOnce a match is over, the winning robot resets, so it has no memory of that match. In its next match, it starts by playing the first move of its program, and so on.\n\nThe tournament is played in K rounds and has a single-elimination \"bracket\" structure. There are N = $2^K$ robots in total, numbered 0 through N - 1. In the first round, robot 0 plays a match against robot 1, robot 2 plays a match against robot 3, and so on, up to robots N - 2 and N - 1. The losers of those matches are eliminated from the tournament. In the second round, the winner of the 0-1 match faces off against the winner of the 2-3 match, and so on. Once we get to the K-th round, there is only one match, and it determines the overall winner of the tournament.\n\nAll of the other contestants are so confident that they have already publicly posted their robots' programs online. However, the robots have not yet been assigned numbers, so nobody knows in advance who their opponents will be. Knowing all of the other programs, is it possible for you to write a program that is guaranteed to win the tournament, no matter how the robot numbers are assigned?", "inputFormat": "The first line of the input gives the number of test cases, $T$; $T$ test cases follow. Each test case begins with one line containing an integer $A$: the number of adversaries (other robots) in the tournament. Then, there are $A$ more lines; the i-th of these contains a string $C_i$ of uppercase letters that represent the program of the i-th opponent's robot.", "outputFormat": "For each test case, output one line containing `Case #x: y`. If there is a string of between 1 and 500 characters that is guaranteed to win the tournament, as described above, then $y$ should be the string of uppercase letters representing that program. Otherwise, $y$ should be IMPOSSIBLE, in uppercase letters.", "hint": "**Sample Explanation**\n\nNote: Although all the opponents in each of these sample cases have programs of the same length, this is not necessarily the case. Opponents within a test case might have programs of different lengths.\n\nIn Sample Case #1, there is only one opponent, with the program RS. Our answer matches the opponent's moves for a while, and the opponent loops through its program several times. As is starts its fourth pass through its program, we beat it with P. Other valid solutions exist, like P, RR, and R.\n\nIn Sample Case #2, there are three opponents, with the programs R, P, and S. It is up to you to figure out why this case is IMPOSSIBLE!\n\nIn Sample Case #3, all seven opponents use the same program. Using the program P, for example, guarantees that you will win. Remember that each robot begins at the start of its program at the start of each match against a new opponent.\n\n**Limits**\n\n- $1 \\leqslant T \\leqslant 100 .$\n- Each character in $\\mathbf{C}_{\\mathbf{i}}$ is uppercase $\\mathbf{R}, \\mathbf{P}$, or $\\mathbf{s}$, for all $\\mathbf{i}$.\n- $\\mathbf{A}=2^{\\mathbf{K}}-1$ for some integer $\\mathbf{K} \\geqslant 1$.\n\n**Test set 1 (10 Pts, Visible)**\n\n- $1 \\leqslant \\mathbf{A} \\leqslant 7$.\n- $\\mathbf{C}_{\\mathbf{i}}$ is between 1 and 5 characters long, for all $\\mathbf{i}$.\n\n**Test set 2 (18 Pts, Hidden)**\n\n- $1 \\leqslant \\mathbf{A} \\leqslant 255$.\n- $\\mathbf{C}_{\\mathbf{i}}$ is between 1 and 500 characters long, for all $\\mathbf{i}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #1C] Robot Programming Strategy", "background": null, "description": "经过无数个不眠之夜，你终于教会了机械臂做出石头剪刀布游戏所需的手势。现在你只需要编写程序，让它在即将到来的机器人锦标赛中参赛！\n\n在本次锦标赛中，每个机器人都使用一个程序，该程序是一系列动作，每个动作必须是以下三者之一：R（代表“石头”）、P（代表“布”）或 S（代表“剪刀”）。布胜石头，输给剪刀；石头胜剪刀，输给布；剪刀胜布，输给石头。\n\n当两个机器人进行对决时，先出制胜动作的机器人获胜。比赛开始时，每个机器人出程序中的第一个动作。如果两个动作不同，其中一个动作会击败另一个动作，从而有一个机器人获胜。如果两个动作相同，则每个机器人出程序中的下一个动作，依此类推。\n\n每当一个机器人走到程序末尾需要下一个动作时，它会回到程序的开头。例如，程序为 RSSP 的机器人，第五步将是 R。如果一场比赛持续超过一个 googol（$10^{100}$）步，裁判会抛硬币决定胜者。\n\n一场比赛结束后，获胜的机器人会重置，因此它不会记得这场比赛。在下一场比赛中，它会从程序的第一个动作开始，依此类推。\n\n锦标赛共进行 $K$ 轮，采用单败淘汰“对阵表”结构。共有 $N=2^K$ 个机器人，编号为 $0$ 到 $N-1$。第一轮中，机器人 $0$ 对阵机器人 $1$，机器人 $2$ 对阵机器人 $3$，以此类推，直到机器人 $N-2$ 和 $N-1$。这些比赛的失败者被淘汰。第二轮中，$0-1$ 比赛的胜者对阵 $2-3$ 比赛的胜者，依此类推。到第 $K$ 轮时，只剩下一场比赛，决定锦标赛的总冠军。\n\n其他参赛者都非常自信，已经在网上公开了他们机器人的程序。然而，机器人编号尚未分配，因此没人提前知道对手是谁。已知所有其他机器人的程序，你能否编写一个程序，无论机器人编号如何分配，都能保证你赢得锦标赛？", "inputFormat": "输入的第一行给出测试用例数 $T$；接下来是 $T$ 组测试数据。每组测试数据的第一行包含一个整数 $A$，表示锦标赛中对手（其他机器人）的数量。接下来有 $A$ 行，第 $i$ 行包含一个字符串 $C_i$，表示第 $i$ 个对手机器人的程序，由大写字母组成。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`。如果存在一个长度在 $1$ 到 $500$ 之间的字符串，能保证你赢得锦标赛，则 $y$ 应为表示该程序的大写字母字符串。否则，$y$ 应为大写字母 `IMPOSSIBLE`。", "hint": "**样例说明**\n\n注意：虽然每个样例中所有对手的程序长度相同，但实际情况并非如此。一个测试用例中的对手程序长度可能不同。\n\n在样例 1 中，只有一个对手，程序为 RS。我们的答案在一段时间内与对手的动作相同，对手的程序循环多次。当对手开始第四次循环时，我们用 P 击败了它。其他有效答案还包括 P、RR 和 R。\n\n在样例 2 中，有三个对手，程序分别为 R、P 和 S。你需要自己思考为什么这个用例的答案是 IMPOSSIBLE！\n\n在样例 3 中，所有七个对手都使用相同的程序。例如，使用程序 P 可以保证你获胜。记住，每次对阵新对手时，每个机器人都会从程序的第一个动作开始。\n\n**数据范围**\n\n- $1 \\leqslant T \\leqslant 100$。\n- 每个 $\\mathbf{C}_i$ 的每个字符均为大写字母 $\\mathbf{R}$、$\\mathbf{P}$ 或 $\\mathbf{S}$。\n- $\\mathbf{A}=2^{\\mathbf{K}}-1$，其中整数 $\\mathbf{K} \\geqslant 1$。\n\n**测试点 1（10 分，可见）**\n\n- $1 \\leqslant \\mathbf{A} \\leqslant 7$。\n- 每个 $\\mathbf{C}_i$ 的长度为 $1$ 到 $5$。\n\n**测试点 2（18 分，隐藏）**\n\n- $1 \\leqslant \\mathbf{A} \\leqslant 255$。\n- 每个 $\\mathbf{C}_i$ 的长度为 $1$ 到 $500$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13113", "type": "P", "difficulty": 4, "samples": [["", ""]], "limits": {"time": [40000, 40000], "memory": [1048576, 1048576]}, "tags": ["2019", "交互题", "Special Judge", "Google Code Jam"], "title": "[GCJ 2019 #1C] Power Arrangers", "background": "", "description": "Go, go, Power Arrangers! Everyone loves this team of five superhero high school students who wear the letters A, B, C, D, and E. When they stand side by side to confront evil monsters, they arrange their team in one of 120 possible different left-to-right orders, giving them various different tactical superpowers. They are even more popular than the Teenage Permutant Ninja Turtles!\n\nSome critics of the show claim that the team only has its arrangement gimmick so that the owners of the show can sell 120 separate sets of 5 action figures, each of which features the team in a different left-to-right order, glued to a base so that the set cannot be rearranged. As an avid Power Arrangers fan, you have collected 119 of these sets, but you do not remember which set you are missing. Your 119 sets are lined up horizontally along a shelf, such that there are a total of $119 \\times 5 = 595$ action figures in left-to-right order. You do not remember how the sets are arranged, but you know that the permutation of the sets is selected uniformly at random from all possible permutations, and independently for each case.\n\nYou do not want to waste any time figuring out which set you are missing, so you plan to look at the letters on at most $\\mathbf{F}$ figures on the shelf. For instance, you might choose to look at the letter on the eighth figure from the left, which would be the third figure from the left in the second set from the left. When looking at a figure, you only get the letter from that one figure; the letters are hard to see, and the different team members look very similar otherwise!\n\nAfter checking at most $\\mathbf{F}$ figures, you must figure out which of the sets is missing, so you can complete your collection and be ready to face any possible evil threat!\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing two integers $\\mathbf{T}$, the number of test cases, and $\\mathbf{F}$, the number of figures you are allowed to inspect per test case. Then, you need to process $\\mathbf{T}$ test cases.\n\nWithin each test case, the missing set of figures is chosen uniformly at random from all possible sets, and the order of the remaining sets is chosen uniformly at random from all possible orders as well. Every choice is made independently of all other choices and of your inputs.\n\nIn each test case, your program will process up to $\\mathbf{F} + 1$ exchanges with our judge. You may make up to $\\mathbf{F}$ exchanges of the following form:\n\n* Your program outputs one line containing a single integer between 1 and 595, inclusive, indicating which figure (in left-to-right order along the shelf) you wish to look at. As a further example, 589 would represent the fourth figure from the left in the second set from the right.\n* The judge responds with one line containing a single uppercase letter A, B, C, D, or E, indicating the letter on that figure. If you sent invalid data (e.g., a number out of range, or a malformed line), the judge will instead respond with one line containing the single uppercase letter N.\n\nThen, after you have made as many of the $\\mathbf{F}$ exchanges above as you want, you must make one more exchange of the following form:\n\n* Your program outputs one line containing a single string of five uppercase letters: the permutation corresponding to the missing set (e.g., CADBE).\n* The judge responds with one line containing a single uppercase letter: Y if your answer was correct, and N if it was not (or you provided a malformed line). If you receive Y, you should begin the next test case, or stop sending input if there are no more test cases.\n\nAfter the judge sends N to your input stream (because of either invalid data or an incorrect answer), it will not send any other output. If your program continues to wait for the judge after receiving N, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "This interaction corresponds to Test set 1.\n\n```\n  t, f = readline_int_list()   // Reads 50 into t and 475 into f\n  printline 10 to stdout       // Looks at the last figure in the second set\n                               // from the left\n  flush stdout\n  n = readline_string()        // Reads B into n. Ooh, team member B! They may\n                               // not have the leadership ability of A, or the\n                               // technical skill of C, but they entertain the\n                               // team with clever quips!\n  printline 11 to stdout       // Looks at the first figure in the third set\n                               // from the left\n  flush stdout\n  n = readline_string()        // Reads B into n. Notice that B is at the start\n                               // of the third set, whereas they were at the\n                               // end of the second set.\n  printline 14 to stdout       // Looks at the fourth figure in the third set\n                               // from the left\n  flush stdout\n  n = readline_string()        // Reads D into n. Silent and brooding, team\n                               // member D nonetheless fights fiercely to\n                               // protect their friends... and the world!\n  printline ABCDE to stdout    // We foolishly make a wild guess even though we\n                               // could have looked at up to 472 more figures.\n  flush stdout\n  verdict = readline_string()  // Reads N into verdict (judge has decided our\n                               //   solution is incorrect)\n  exit                         // Exits to avoid an ambiguous TLE error\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 50$.\n- The missing set, and the order of the remaining sets, are chosen uniformly and independently at random.\n\n**Test set 1 (11 Pts, Visible)**\n\n- $\\mathbf{F} = 475$.\n\n**Test set 2 (21 Pts, Hidden)**\n\n- $\\mathbf{F} = 150$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #1C] Power Arrangers", "background": "", "description": "Go, go, Power Arrangers! Everyone loves this team of five superhero high school students who wear the letters A, B, C, D, and E. When they stand side by side to confront evil monsters, they arrange their team in one of 120 possible different left-to-right orders, giving them various different tactical superpowers. They are even more popular than the Teenage Permutant Ninja Turtles!\n\nSome critics of the show claim that the team only has its arrangement gimmick so that the owners of the show can sell 120 separate sets of 5 action figures, each of which features the team in a different left-to-right order, glued to a base so that the set cannot be rearranged. As an avid Power Arrangers fan, you have collected 119 of these sets, but you do not remember which set you are missing. Your 119 sets are lined up horizontally along a shelf, such that there are a total of $119 \\times 5 = 595$ action figures in left-to-right order. You do not remember how the sets are arranged, but you know that the permutation of the sets is selected uniformly at random from all possible permutations, and independently for each case.\n\nYou do not want to waste any time figuring out which set you are missing, so you plan to look at the letters on at most $\\mathbf{F}$ figures on the shelf. For instance, you might choose to look at the letter on the eighth figure from the left, which would be the third figure from the left in the second set from the left. When looking at a figure, you only get the letter from that one figure; the letters are hard to see, and the different team members look very similar otherwise!\n\nAfter checking at most $\\mathbf{F}$ figures, you must figure out which of the sets is missing, so you can complete your collection and be ready to face any possible evil threat!\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing two integers $\\mathbf{T}$, the number of test cases, and $\\mathbf{F}$, the number of figures you are allowed to inspect per test case. Then, you need to process $\\mathbf{T}$ test cases.\n\nWithin each test case, the missing set of figures is chosen uniformly at random from all possible sets, and the order of the remaining sets is chosen uniformly at random from all possible orders as well. Every choice is made independently of all other choices and of your inputs.\n\nIn each test case, your program will process up to $\\mathbf{F} + 1$ exchanges with our judge. You may make up to $\\mathbf{F}$ exchanges of the following form:\n\n* Your program outputs one line containing a single integer between 1 and 595, inclusive, indicating which figure (in left-to-right order along the shelf) you wish to look at. As a further example, 589 would represent the fourth figure from the left in the second set from the right.\n* The judge responds with one line containing a single uppercase letter A, B, C, D, or E, indicating the letter on that figure. If you sent invalid data (e.g., a number out of range, or a malformed line), the judge will instead respond with one line containing the single uppercase letter N.\n\nThen, after you have made as many of the $\\mathbf{F}$ exchanges above as you want, you must make one more exchange of the following form:\n\n* Your program outputs one line containing a single string of five uppercase letters: the permutation corresponding to the missing set (e.g., CADBE).\n* The judge responds with one line containing a single uppercase letter: Y if your answer was correct, and N if it was not (or you provided a malformed line). If you receive Y, you should begin the next test case, or stop sending input if there are no more test cases.\n\nAfter the judge sends N to your input stream (because of either invalid data or an incorrect answer), it will not send any other output. If your program continues to wait for the judge after receiving N, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "This interaction corresponds to Test set 1.\n\n```\n  t, f = readline_int_list()   // Reads 50 into t and 475 into f\n  printline 10 to stdout       // Looks at the last figure in the second set\n                               // from the left\n  flush stdout\n  n = readline_string()        // Reads B into n. Ooh, team member B! They may\n                               // not have the leadership ability of A, or the\n                               // technical skill of C, but they entertain the\n                               // team with clever quips!\n  printline 11 to stdout       // Looks at the first figure in the third set\n                               // from the left\n  flush stdout\n  n = readline_string()        // Reads B into n. Notice that B is at the start\n                               // of the third set, whereas they were at the\n                               // end of the second set.\n  printline 14 to stdout       // Looks at the fourth figure in the third set\n                               // from the left\n  flush stdout\n  n = readline_string()        // Reads D into n. Silent and brooding, team\n                               // member D nonetheless fights fiercely to\n                               // protect their friends... and the world!\n  printline ABCDE to stdout    // We foolishly make a wild guess even though we\n                               // could have looked at up to 472 more figures.\n  flush stdout\n  verdict = readline_string()  // Reads N into verdict (judge has decided our\n                               //   solution is incorrect)\n  exit                         // Exits to avoid an ambiguous TLE error\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 50$.\n- The missing set, and the order of the remaining sets, are chosen uniformly and independently at random.\n\n**Test set 1 (11 Pts, Visible)**\n\n- $\\mathbf{F} = 475$.\n\n**Test set 2 (21 Pts, Hidden)**\n\n- $\\mathbf{F} = 150$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #1C] Power Arrangers", "background": null, "description": "Go, go, Power Arrangers！每个人都喜欢这支由五名高中生超级英雄组成的团队，他们分别佩戴字母 A、B、C、D 和 E。当他们并肩站立对抗邪恶怪兽时，会以 120 种不同的从左到右的排列方式排列队伍，从而获得各种不同的战术超能力。他们甚至比“忍者神龟”还要受欢迎！\n\n一些评论家认为，这个团队之所以有排列的噱头，只是为了让节目拥有者能够售卖 120 套不同的 5 人手办，每一套都以不同的从左到右顺序固定在底座上，无法重新排列。作为一名狂热的 Power Arrangers 粉丝，你已经收集了其中的 119 套，但你不记得自己缺少哪一套。你的 119 套手办水平排列在书架上，总共有 $119 \\times 5 = 595$ 个手办，按从左到右的顺序排列。你不记得这些套装的排列顺序，但你知道这些套装的排列是从所有可能的排列中等概率随机选择的，并且每种情况都是独立的。\n\n你不想浪费时间去找出自己缺少哪一套，因此你计划最多查看 $\\mathbf{F}$ 个手办上的字母。例如，你可以选择查看从左数第八个手办上的字母，这就是从左数第二套中的第三个手办。当你查看一个手办时，你只能获得该手办上的字母；这些字母很难看清，而且不同的队员外观非常相似！\n\n在最多检查 $\\mathbf{F}$ 个手办后，你必须判断出缺少的是哪一套，这样你才能完成你的收藏，随时准备对抗任何邪恶威胁！\n\n### 交互协议\n\n这是一个交互题。\n\n最开始，你的程序应读取一行，包含两个整数 $\\mathbf{T}$（测试用例数量）和 $\\mathbf{F}$（每个测试用例允许检查的手办数量）。然后，你需要处理 $\\mathbf{T}$ 个测试用例。\n\n在每个测试用例中，缺失的那套手办会从所有可能的套装中等概率随机选择，剩下套装的排列顺序也会从所有可能的顺序中等概率随机选择。每一次选择都是独立的。\n\n在每个测试用例中，你最多可以与评测器进行 $\\mathbf{F} + 1$ 次交互。你可以进行最多 $\\mathbf{F}$ 次如下形式的交互：\n\n- 你的程序输出一行，包含一个介于 1 到 595 之间的整数，表示你想查看的手办（从左到右编号）。例如，589 表示从右数第二套中的第四个手办。\n- 评测器会回复一行，包含一个大写字母 A、B、C、D 或 E，表示该手办上的字母。如果你发送了无效数据（例如，超出范围的数字或格式错误的行），评测器会回复一行，内容为大写字母 N。\n\n在你完成最多 $\\mathbf{F}$ 次上述交互后，你还必须进行一次如下形式的交互：\n\n- 你的程序输出一行，包含一个由五个大写字母组成的字符串，表示缺失套装的排列（例如，CADBE）。\n- 评测器会回复一行，内容为一个大写字母：如果你的答案正确，则为 Y，否则为 N（或格式错误时也为 N）。如果你收到 Y，应开始下一个测试用例；如果没有更多测试用例，则停止输入。\n\n如果评测器向你的输入流发送了 N（因为无效数据或答案错误），它将不会再发送任何输出。如果你的程序在收到 N 后继续等待评测器回复，将会超时，导致 Time Limit Exceeded 错误。请注意，你有责任让程序及时退出，以获得 Wrong Answer 判定，而不是 Time Limit Exceeded。如果超出内存限制或程序运行时出错，将会收到相应的判定。\n\n如常规，若超出内存限制或程序运行时出错，将会收到相应的判定。\n\n你可以使用本地测试工具进行测试。要在本地测试，你需要让测试工具与你的代码并行运行；你可以使用我们的 [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)。更多信息请阅读该文件中的注释说明。\n\n测试工具的使用说明已包含在工具的注释中。我们鼓励你添加自己的测试用例。请注意，虽然测试工具旨在模拟评测系统，但它**不是**真实的评测系统，可能会有不同的表现。\n\n**限制条件**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 50$。\n- 缺失的套装和剩余套装的顺序均为等概率独立随机选择。\n\n**测试点 1（11 分，可见）**\n\n- $\\mathbf{F} = 475$。\n\n**测试点 2（21 分，隐藏）**\n\n- $\\mathbf{F} = 150$。", "inputFormat": "参见交互协议。", "outputFormat": "参见交互协议。", "hint": "本交互对应测试点 1。\n\n```\n  t, f = readline_int_list()   // 读取 t=50, f=475\n  printline 10 to stdout       // 查看从左数第二套中的最后一个手办\n  flush stdout\n  n = readline_string()        // 读取 n=B。哦，队员 B！虽然他没有 A 的领导力，也没有 C 的技术能力，但他用机智的俏皮话娱乐着团队！\n  printline 11 to stdout       // 查看从左数第三套中的第一个手办\n  flush stdout\n  n = readline_string()        // 读取 n=B。注意，B 在第三套的开头，而在第二套的结尾。\n  printline 14 to stdout       // 查看从左数第三套中的第四个手办\n  flush stdout\n  n = readline_string()        // 读取 n=D。沉默寡言的 D，虽然性格内敛，但为了保护朋友和世界而英勇战斗！\n  printline ABCDE to stdout    // 我们鲁莽地猜测，尽管还可以再查看 472 个手办。\n  flush stdout\n  verdict = readline_string()  // 读取 verdict=N（评测器判定我们的答案错误）\n  exit                         // 退出，避免出现超时错误\n```\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13114", "type": "P", "difficulty": 6, "samples": [["5\n2 2\n..\n.#\n4 4\n.#..\n..#.\n#...\n...#\n3 4\n#.##\n....\n#.##\n1 1\n.\n1 2\n##", "Case #1: 0\nCase #2: 0\nCase #3: 7\nCase #4: 2\nCase #5: 0"]], "limits": {"time": [30000, 30000, 30000], "memory": [1048576, 1048576, 1048576]}, "tags": ["博弈论", "2019", "SG 函数", "Google Code Jam"], "title": "[GCJ 2019 #1C] Bacterial Tactics", "background": "", "description": "Becca and Terry are microbiologists who have a friendly rivalry. When they need a break from their research, they like to play a game together. The game is played on a matrix of unit cells with $\\mathbf{R}$ rows and $\\mathbf{C}$ columns. Initially, each cell is either empty, or contains radioactive material.\n\nOn each player's turn, if there are no empty cells in the matrix, that player loses the game. Otherwise, they choose an empty cell and place a colony of bacteria there. Bacteria colonies come in two types: H (for \"horizontal\") and V (for \"vertical\").\n\n* When a type H colony is placed into an empty cell, it occupies that cell (making it non-empty), and also tries to spread into the cell immediately to the west (if there is one) and the cell immediately to the east (if there is one).\n* When a type V colony is placed into an empty cell, it occupies that cell (making it non-empty), and also tries to spread into the cell immediately to the south (if there is one) and the cell immediately to the north (if there is one).\n\nWhenever a colony (of either type) tries to spread into a cell:\n\n* If the cell contains radioactive material, the colony mutates and the player who placed the colony loses the game.\n* If that cell is empty, the colony occupies that cell (making it non-empty), and then the rule above is triggered again (i.e. the colony will try to spread further).\n* If the cell already contains bacteria (of any type), the colony does not spread into that cell.\n\nNotice that it may be possible that all of a player's available moves would cause them to lose the game, and so they are doomed. See the sample case explanations below for examples of how the game works.\n\nBecca makes the first move, and then the two players alternate moves until one of them loses the game. If both players play optimally, who will win? And, if Becca will win, how many distinct winning opening moves does she have? (Two opening moves are distinct if and only if they either use different cells, or different kinds of colony, or both.)\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case begins with one line containing two integers $\\mathbf{R}$ and $\\mathbf{C}$: the number of rows and columns, respectively, in the matrix. Then, there are $\\mathbf{R}$ more rows of $\\mathbf{C}$ characters each. The j-th character on the i-th of these lines represents the j-th column of the i-th row of the matrix. Each character is either . (an empty cell) or # (a cell with radioactive material).\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1), and $y$ is an integer: either 0 if Becca will not win, or, if Becca will win, the number of distinct winning opening moves she can make, as described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, Becca cannot place an H colony in the southwest empty cell or a V colony in the northeast empty cell, because those would spread onto a radioactive cell and Becca would lose. She has only two possible strategies that do not cause her to lose immediately:\n\n1. Place an H colony in the northwest or northeast empty cells. The colony will also spread to the other of those two cells.\n2. Place a V colony in the northwest or southwest empty cell. The colony will also spread to the other of those two cells.\n\nIf Becca chooses strategy 1, Terry can place a V colony in the southwest empty cell. If Becca chooses strategy 2, Terry can place an H colony in the northeast empty cell. Either way, Becca has no empty cells to choose from on her next turn, so she loses and Terry wins.\n\nIn Sample Case #2, any of Becca's opening moves would cause a mutation.\n\nIn Sample Case #3, five of Becca's possible opening moves would cause a mutation, but the other seven are winning. She can place an H colony in any of the cells of the second row, or she can place a V colony in any of the cells of the second column. In either case, she leaves two disconnected sets of 1 or 2 cells each. In each of those sets, only one type of colony can be played, and playing it consumes all of the empty cells in that set. So, whichever of those sets Terry chooses to consume, Becca can consume the other, leaving Terry with no moves.\n\nIn Sample Case #4, both of Becca's two distinct possible opening moves are winning.\n\nIn Sample Case #5, Becca has no possible opening moves.\n\n**Limits**\n\n$1 \\leq \\mathbf{T} \\leq 100$.\n\n**Test set 1 (Visible)**\n\n- $1 \\leq \\mathbf{R} \\leq 4$.\n- $1 \\leq \\mathbf{C} \\leq 4$.\n\n**Test set 2 (Hidden)**\n\n- $1 \\leq \\mathbf{R} \\leq 15$.\n- $1 \\leq \\mathbf{C} \\leq 15$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #1C] Bacterial Tactics", "background": "", "description": "Becca and Terry are microbiologists who have a friendly rivalry. When they need a break from their research, they like to play a game together. The game is played on a matrix of unit cells with $\\mathbf{R}$ rows and $\\mathbf{C}$ columns. Initially, each cell is either empty, or contains radioactive material.\n\nOn each player's turn, if there are no empty cells in the matrix, that player loses the game. Otherwise, they choose an empty cell and place a colony of bacteria there. Bacteria colonies come in two types: H (for \"horizontal\") and V (for \"vertical\").\n\n* When a type H colony is placed into an empty cell, it occupies that cell (making it non-empty), and also tries to spread into the cell immediately to the west (if there is one) and the cell immediately to the east (if there is one).\n* When a type V colony is placed into an empty cell, it occupies that cell (making it non-empty), and also tries to spread into the cell immediately to the south (if there is one) and the cell immediately to the north (if there is one).\n\nWhenever a colony (of either type) tries to spread into a cell:\n\n* If the cell contains radioactive material, the colony mutates and the player who placed the colony loses the game.\n* If that cell is empty, the colony occupies that cell (making it non-empty), and then the rule above is triggered again (i.e. the colony will try to spread further).\n* If the cell already contains bacteria (of any type), the colony does not spread into that cell.\n\nNotice that it may be possible that all of a player's available moves would cause them to lose the game, and so they are doomed. See the sample case explanations below for examples of how the game works.\n\nBecca makes the first move, and then the two players alternate moves until one of them loses the game. If both players play optimally, who will win? And, if Becca will win, how many distinct winning opening moves does she have? (Two opening moves are distinct if and only if they either use different cells, or different kinds of colony, or both.)\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case begins with one line containing two integers $\\mathbf{R}$ and $\\mathbf{C}$: the number of rows and columns, respectively, in the matrix. Then, there are $\\mathbf{R}$ more rows of $\\mathbf{C}$ characters each. The j-th character on the i-th of these lines represents the j-th column of the i-th row of the matrix. Each character is either . (an empty cell) or # (a cell with radioactive material).\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1), and $y$ is an integer: either 0 if Becca will not win, or, if Becca will win, the number of distinct winning opening moves she can make, as described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, Becca cannot place an H colony in the southwest empty cell or a V colony in the northeast empty cell, because those would spread onto a radioactive cell and Becca would lose. She has only two possible strategies that do not cause her to lose immediately:\n\n1. Place an H colony in the northwest or northeast empty cells. The colony will also spread to the other of those two cells.\n2. Place a V colony in the northwest or southwest empty cell. The colony will also spread to the other of those two cells.\n\nIf Becca chooses strategy 1, Terry can place a V colony in the southwest empty cell. If Becca chooses strategy 2, Terry can place an H colony in the northeast empty cell. Either way, Becca has no empty cells to choose from on her next turn, so she loses and Terry wins.\n\nIn Sample Case #2, any of Becca's opening moves would cause a mutation.\n\nIn Sample Case #3, five of Becca's possible opening moves would cause a mutation, but the other seven are winning. She can place an H colony in any of the cells of the second row, or she can place a V colony in any of the cells of the second column. In either case, she leaves two disconnected sets of 1 or 2 cells each. In each of those sets, only one type of colony can be played, and playing it consumes all of the empty cells in that set. So, whichever of those sets Terry chooses to consume, Becca can consume the other, leaving Terry with no moves.\n\nIn Sample Case #4, both of Becca's two distinct possible opening moves are winning.\n\nIn Sample Case #5, Becca has no possible opening moves.\n\n**Limits**\n\n$1 \\leq \\mathbf{T} \\leq 100$.\n\n**Test set 1 (Visible)**\n\n- $1 \\leq \\mathbf{R} \\leq 4$.\n- $1 \\leq \\mathbf{C} \\leq 4$.\n\n**Test set 2 (Hidden)**\n\n- $1 \\leq \\mathbf{R} \\leq 15$.\n- $1 \\leq \\mathbf{C} \\leq 15$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #1C] Bacterial Tactics", "background": null, "description": "Becca 和 Terry 是微生物学家，他们之间有着友好的竞争。当他们需要从研究中休息时，会一起玩一个游戏。该游戏在一个由 $\\mathbf{R}$ 行 $\\mathbf{C}$ 列组成的单元格矩阵上进行。最初，每个格子要么是空的，要么含有放射性物质。\n\n每位玩家轮流行动，如果矩阵中没有空格子，则该玩家输掉游戏。否则，玩家选择一个空格子并在其中放置一个细菌菌落。细菌菌落有两种类型：H（代表“水平”）和 V（代表“垂直”）。\n\n- 当在一个空格子中放置 H 型菌落时，它会占据该格子（使其变为非空），并尝试向西边（如果有）和东边（如果有）的相邻格子扩散。\n- 当在一个空格子中放置 V 型菌落时，它会占据该格子（使其变为非空），并尝试向南边（如果有）和北边（如果有）的相邻格子扩散。\n\n每当菌落（无论哪种类型）尝试扩散到某个格子时：\n\n- 如果该格子含有放射性物质，菌落发生变异，放置该菌落的玩家输掉游戏。\n- 如果该格子为空，菌落占据该格子（使其变为非空），然后再次触发上述规则（即菌落会继续尝试扩散）。\n- 如果该格子已经含有细菌（任意类型），菌落不会扩散到该格子。\n\n注意，可能存在玩家所有可选的行动都会导致自己输掉游戏的情况，因此该玩家注定失败。下面的样例解释中有关于游戏玩法的示例。\n\nBecca 先手，然后两位玩家轮流行动，直到其中一方输掉游戏。如果双方都采取最优策略，谁会获胜？如果 Becca 会获胜，她有多少种不同的必胜开局？（只有当使用的格子不同，或菌落类型不同，或两者都不同，两个开局才算作不同。）", "inputFormat": "输入的第一行为测试用例数 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试数据。每组数据的第一行为两个整数 $\\mathbf{R}$ 和 $\\mathbf{C}$，分别表示矩阵的行数和列数。接下来有 $\\mathbf{R}$ 行，每行有 $\\mathbf{C}$ 个字符。第 $i$ 行第 $j$ 个字符表示矩阵第 $i$ 行第 $j$ 列的格子。每个字符要么是 .（空格子），要么是 #（含有放射性物质的格子）。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是一个整数：如果 Becca 无法获胜，则为 0；如果 Becca 能获胜，则为她拥有的不同必胜开局数量，如上所述。", "hint": "**样例解释**\n\n在样例 1 中，Becca 不能在西南角的空格子放置 H 型菌落，也不能在东北角的空格子放置 V 型菌落，因为那样会扩散到放射性格子，Becca 会输。她只有两种不会立即输掉的策略：\n\n1. 在西北角或东北角的空格子放置 H 型菌落。该菌落还会扩散到另一个角的空格子。\n2. 在西北角或西南角的空格子放置 V 型菌落。该菌落还会扩散到另一个角的空格子。\n\n如果 Becca 选择策略 1，Terry 可以在西南角的空格子放置 V 型菌落。如果 Becca 选择策略 2，Terry 可以在东北角的空格子放置 H 型菌落。无论哪种情况，Becca 下一轮都没有空格可选，因此她会输，Terry 获胜。\n\n在样例 2 中，Becca 的任何开局都会导致变异。\n\n在样例 3 中，Becca 有 5 种可能的开局会导致变异，但另外 7 种是必胜的。她可以在第二行的任意格子放置 H 型菌落，或者在第二列的任意格子放置 V 型菌落。无论哪种情况，她都会留下两个不相连的 1 或 2 个格子的集合。在每个集合中，只能放置一种类型的菌落，且放置后会消耗掉该集合内所有空格。因此，无论 Terry 选择消耗哪一个集合，Becca 都可以消耗另一个集合，使 Terry 无法行动。\n\n在样例 4 中，Becca 的两种不同开局都是必胜的。\n\n在样例 5 中，Becca 没有可行的开局。\n\n**数据范围**\n\n$1 \\leq \\mathbf{T} \\leq 100$。\n\n**测试点 1（可见）**\n\n- $1 \\leq \\mathbf{R} \\leq 4$。\n- $1 \\leq \\mathbf{C} \\leq 4$。\n\n**测试点 2（隐藏）**\n\n- $1 \\leq \\mathbf{R} \\leq 15$。\n- $1 \\leq \\mathbf{C} \\leq 15$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
