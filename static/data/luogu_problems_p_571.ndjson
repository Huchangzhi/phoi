{"pid": "P12591", "type": "P", "difficulty": 3, "samples": [], "limits": {"time": [1000], "memory": [524288]}, "tags": ["搜索", "枚举"], "title": "承受雨加雪", "background": "", "description": "给定如下的数字矩阵：\n\n```plain\n2 4 3 4 3 0 \n2 0 1 3 0 1 \n3 3 4 2 3 2 \n3 2 1 2 0 1 \n4 0 3 1 1 4 \n1 3 3 1 2 1 \n```\n\n你要求出：有多少种方案，可以从矩阵中选出连续的四个数字，选出的数的位置处于同一行或同一列或同一斜线（平行或重合于主或副对角线）且连续，把选出的数按顺序写在一行，在其中添加适当的加、减、乘运算符和括号后，算出的结果是 $24$。\n\n顺序是指：对于不同行的元素，上面的行里的元素在前；对同一行里的元素，左边的元素在前。\n\n注意：\n1. 任意相邻两个原数字之前都必须有至少一个运算符，即不能把 `1 2` 看成 `12`。\n2. 一个左括号后不能直接跟一个 `-`，算式开头也不能有 `-`。即只能添加「减法运算」而不能直接把一个数变成其相反数。\n\n两种方案不同当且仅当取出来的数字在原矩阵里的位置不同。", "inputFormat": "", "outputFormat": "这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只需要**编写一个程序输出这个整数**，输出多余的内容将无法得分。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "承受雨加雪", "background": "", "description": "给定如下的数字矩阵：\n\n```plain\n2 4 3 4 3 0 \n2 0 1 3 0 1 \n3 3 4 2 3 2 \n3 2 1 2 0 1 \n4 0 3 1 1 4 \n1 3 3 1 2 1 \n```\n\n你要求出：有多少种方案，可以从矩阵中选出连续的四个数字，选出的数的位置处于同一行或同一列或同一斜线（平行或重合于主或副对角线）且连续，把选出的数按顺序写在一行，在其中添加适当的加、减、乘运算符和括号后，算出的结果是 $24$。\n\n顺序是指：对于不同行的元素，上面的行里的元素在前；对同一行里的元素，左边的元素在前。\n\n注意：\n1. 任意相邻两个原数字之前都必须有至少一个运算符，即不能把 `1 2` 看成 `12`。\n2. 一个左括号后不能直接跟一个 `-`，算式开头也不能有 `-`。即只能添加「减法运算」而不能直接把一个数变成其相反数。\n\n两种方案不同当且仅当取出来的数字在原矩阵里的位置不同。", "inputFormat": "", "outputFormat": "这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只需要**编写一个程序输出这个整数**，输出多余的内容将无法得分。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12592", "type": "P", "difficulty": 2, "samples": [["3\naba\nabab\nabcd", "Yes\nYes\nNo"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "字符串"], "title": "重生有惊喜", "background": "\n---\n\n在本题中，对于一个字符串 $x$，用 $|x|$ 表示 $x$ 的长度，$x_i$ 表示 $x$ 的第 $i$ 个字符（$1 \\leq i \\leq |x|$，即字符串下标从 $1$ 起）。称 $x$ 是一个回文串当且仅当对全部的 $1 \\leq i \\leq |x|$ 都有 $x_i = x_{|x| - i + 1}$。\n", "description": "\n给定一个字符串 $s$，你可以做如下操作**任意多**（可以为 $0$）次：\n\n- 选择两个下标 $i,j$ 满足 $1 \\leq i , j \\leq |s|$。\n- 交换 $s_i$ 和 $s_j$，即交换字符串 $s$ 的第 $i$ 个和第 $j$ 个字符。\n\n你要求出：是否存在一种方法，使得在若干次操作后，得到的字符串是一个**回文串**。\n", "inputFormat": "\n**本题单个测试点内有多组测试数据**。第一行是一个整数，表示数据组数 $T$。\n\n接下来 $T$ 行，每行一个字符串，表示一组数据给定的 $s$。\n", "outputFormat": "\n对每组测试数据依次输出答案，每组数据一行。\n\n如果可以通过若干次操作得到回文串，输出一行一个字符串 $\\texttt{Yes}$，否则输出 $\\texttt{No}$。\n", "hint": "- 对 $40\\%$ 的数据，$T = 1$。\n- 对 $70\\%$ 的数据，$|s| \\leq 9$。\n- 对 $100\\%$ 的数据，$1 \\leq T \\leq 10$，$1 \\leq |s| \\leq 10^4$，$s$ 中仅含小写英文字母。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "重生有惊喜", "background": "\n---\n\n在本题中，对于一个字符串 $x$，用 $|x|$ 表示 $x$ 的长度，$x_i$ 表示 $x$ 的第 $i$ 个字符（$1 \\leq i \\leq |x|$，即字符串下标从 $1$ 起）。称 $x$ 是一个回文串当且仅当对全部的 $1 \\leq i \\leq |x|$ 都有 $x_i = x_{|x| - i + 1}$。\n", "description": "\n给定一个字符串 $s$，你可以做如下操作**任意多**（可以为 $0$）次：\n\n- 选择两个下标 $i,j$ 满足 $1 \\leq i , j \\leq |s|$。\n- 交换 $s_i$ 和 $s_j$，即交换字符串 $s$ 的第 $i$ 个和第 $j$ 个字符。\n\n你要求出：是否存在一种方法，使得在若干次操作后，得到的字符串是一个**回文串**。\n", "inputFormat": "\n**本题单个测试点内有多组测试数据**。第一行是一个整数，表示数据组数 $T$。\n\n接下来 $T$ 行，每行一个字符串，表示一组数据给定的 $s$。\n", "outputFormat": "\n对每组测试数据依次输出答案，每组数据一行。\n\n如果可以通过若干次操作得到回文串，输出一行一个字符串 $\\texttt{Yes}$，否则输出 $\\texttt{No}$。\n", "hint": "- 对 $40\\%$ 的数据，$T = 1$。\n- 对 $70\\%$ 的数据，$|s| \\leq 9$。\n- 对 $100\\%$ 的数据，$1 \\leq T \\leq 10$，$1 \\leq |s| \\leq 10^4$，$s$ 中仅含小写英文字母。", "locale": "zh-CN"}}}
{"pid": "P12593", "type": "P", "difficulty": 2, "samples": [["6 8\n1 3 10\n1 5 20\n1 6 30\n2 5 10\n2 6 20\n3 4 30\n3 5 10\n5 6 20", "240"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["枚举", "状压 DP"], "title": "沉石鱼惊旋", "background": "> 绝代有佳人，幽居在空谷。", "description": "小 C 有一张 $n$ 个点 $m$ 条边的简单无向带权连通图 $G$。\n\n现在你可以进行 $n$ 次操作，每次操作如下：\n\n选择一个仍未被删除的点 $u$，然后删除点 $u$ 和当前与 $u$ 相连的所有边（即其中一个端点是 $u$ 的边）。假设本次删除的边的边权分别是 $w_1, w_2,\\dots w_k$，则本次操作的代价是  $k\\times (w_1+w_2+\\dots+w_k)$。\n\n你的总代价是这 $n$ 次操作的代价和。\n\n显然 $n$ 次操作后，所有的边和点都将被删除。现在小 C 想知道，将图中所有点和边都删除（即把图删空）的最小总代价是多少。当然，在过程中你不需要保证图每次操作后仍然连通。\n\n> 天寒翠袖薄，日暮倚修竹。", "inputFormat": "第一行，两个整数 $n,m$。\n\n接下来的 $m$ 行，每行 $3$ 个整数 $u,v,w$，表示 $u$ 和 $v$ 之间有一条边权为 $w$ 的边。", "outputFormat": "一行，一个整数，表示删空图 $G$ 的最小代价。", "hint": "在样例 1 中，这张图有 $8$ 条边：$(1,3,10),(1,5,20),(1,6,30),(2,5,10),(2,6,20),(3,4,30),(3,5,10),(5,6,20)$。一个可行的最优策略如下：\n\n- 选择 $u=4$ 删除，花费 $1\\times (30)=30$ 的代价。\n- 选择 $u=3$ 删除，花费 $2\\times (10+10)=40$ 的代价。\n- 选择 $u=2$ 删除，花费 $2\\times (10+20)=60$ 的代价。\n- 选择 $u=5$ 删除，花费 $2\\times (20+20)=80$ 的代价。\n- 选择 $u=6$ 删除，花费 $1\\times (30)=30$ 的代价。\n- 选择 $u=1$ 删除，没有边，花费 $0$ 的代价。\n\n故总代价为 $30+40+60+80+30+0=240$。\n\n---\n\n- 对于 $10\\%$ 的数据，边权 $w=1$。\n- 对于另外 $20\\%$ 的数据，$m=n-1$。\n- 对于 $100\\%$ 的数据，$1\\leq n\\leq 8$，$n-1\\leq m\\leq \\frac{n(n-1)}{2}$，$1\\leq u,v\\leq n$，$1\\leq w\\leq 10^9$。保证图中没有重边和自环。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "沉石鱼惊旋", "background": "> 绝代有佳人，幽居在空谷。", "description": "小 C 有一张 $n$ 个点 $m$ 条边的简单无向带权连通图 $G$。\n\n现在你可以进行 $n$ 次操作，每次操作如下：\n\n选择一个仍未被删除的点 $u$，然后删除点 $u$ 和当前与 $u$ 相连的所有边（即其中一个端点是 $u$ 的边）。假设本次删除的边的边权分别是 $w_1, w_2,\\dots w_k$，则本次操作的代价是  $k\\times (w_1+w_2+\\dots+w_k)$。\n\n你的总代价是这 $n$ 次操作的代价和。\n\n显然 $n$ 次操作后，所有的边和点都将被删除。现在小 C 想知道，将图中所有点和边都删除（即把图删空）的最小总代价是多少。当然，在过程中你不需要保证图每次操作后仍然连通。\n\n> 天寒翠袖薄，日暮倚修竹。", "inputFormat": "第一行，两个整数 $n,m$。\n\n接下来的 $m$ 行，每行 $3$ 个整数 $u,v,w$，表示 $u$ 和 $v$ 之间有一条边权为 $w$ 的边。", "outputFormat": "一行，一个整数，表示删空图 $G$ 的最小代价。", "hint": "在样例 1 中，这张图有 $8$ 条边：$(1,3,10),(1,5,20),(1,6,30),(2,5,10),(2,6,20),(3,4,30),(3,5,10),(5,6,20)$。一个可行的最优策略如下：\n\n- 选择 $u=4$ 删除，花费 $1\\times (30)=30$ 的代价。\n- 选择 $u=3$ 删除，花费 $2\\times (10+10)=40$ 的代价。\n- 选择 $u=2$ 删除，花费 $2\\times (10+20)=60$ 的代价。\n- 选择 $u=5$ 删除，花费 $2\\times (20+20)=80$ 的代价。\n- 选择 $u=6$ 删除，花费 $1\\times (30)=30$ 的代价。\n- 选择 $u=1$ 删除，没有边，花费 $0$ 的代价。\n\n故总代价为 $30+40+60+80+30+0=240$。\n\n---\n\n- 对于 $10\\%$ 的数据，边权 $w=1$。\n- 对于另外 $20\\%$ 的数据，$m=n-1$。\n- 对于 $100\\%$ 的数据，$1\\leq n\\leq 8$，$n-1\\leq m\\leq \\frac{n(n-1)}{2}$，$1\\leq u,v\\leq n$，$1\\leq w\\leq 10^9$。保证图中没有重边和自环。", "locale": "zh-CN"}}}
{"pid": "P12594", "type": "P", "difficulty": 4, "samples": [["9\n1\n{4},1h[4:1]/2h[4:1],\n1\n{4},1h[4:1]/2,\n1\n{4},1h[4:1]/2/3,\n1\n{4},1/2/3,\n1\n{4},1h[4:1]/2h[8:1],\n1\n{16},1h[8:1]/2h[8:1],3,\n1\n{16},1h[8:1]/2h[8:1],,3,,\n1\n{16},1h[8:1],1,\n1\n{16},1h[16:1],1,", "Yes\nYes\nNo\nNo\nYes\nNo\nNo\nNo\nNo"], ["2\n2\n{16},1,2,3,\n{12},1,2,3,\n2\n{16},1h[4:1],2h[4:1],\n{8},,3,4,", "Yes\nNo"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟"], "title": "炽声音节旋", "background": "扶苏是一个舞萌吃。她今天学习了如何编写舞萌的谱面！现在，她要来教一下你了。\n\n舞萌是一款街机游戏，游戏框体共有两个机位，玩家可以单人游玩，亦可以双人组队，其玩法与大多数音乐游戏相似，音符则从屏幕中心向四周移动，玩家需要在合适的时机拍击按键或者触摸屏幕外侧，并达到一定分数才可通关。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6gy8gk1p.png)\n\n_图片来源：wikipedia_", "description": "\n舞萌框体共有 8 个可供拍打的外键，写谱时以右上角为 1 号键，顺时针进行编号，如下所示：\n\n```\n\t\t\t8\t  1\n\t\t\t\n\t\t7\t\t  \t  2\n\t\t\n\t\t6\t\t\t  3\n\t\t\n\t\t\t5\t  4\n```\n\n舞萌谱面使用一种名为 s-simai (simplified-simai) 的语言进行编写。为了方便处理，我们对 s-simai 做进一步简化。\n\n### 节拍与时值\n\n一拍是谱面的一个基本时间单位，被称为一个**四分音**或一个**四分音符**。在本题中，可以认为一拍对应一个固定的时间长度，其具体数值并不重要，你无需区分接下来表述中音符的「时值」和「时长」，可以认为二者是统一的。如果你愿意，可以认为一拍是 $0.5$ 秒，即一个四分音符占 $0.5$ 秒的时间。\n\n除了四分音符外，还有其他时长的音符。一个 $x$ 分音符的时长是一拍的 $\\frac{4}{x}$ 倍。例如，一个 $8$ 分音符的时长是一拍的一半，即半拍。如果一拍是 $0.5$ 秒，则一个八分音占 $0.25$ 秒。一个 $12$ 分音符（虽然乐理中一般不采用「十二分音」这样的表述，但这里为了方便描述做了统一）的时长是一拍的 $\\frac{1}{3}$。我们保证 $x$ 是 $\\{4,8,12,16,24,32\\}$ 六个数字之一。\n\n简化的 s-simai 语言一行表示若干个时长相同的音符，以 `{x},` 开头，表示本行音符的时值（时长）。音符与音符之间以 `,` 分隔。例如，`{16},A,B,C,D,` 表示了接下来连续 $4$ 个十六分音的音符分别是 `A`,`B`,`C`,`D`。多行 s-simai 表示的时间是连续的。例如：\n\n```\n{16},A,B,C,D,\n{8},E,F,\n```\n\n就表示了连续的四个 $16$ 分音和两个 $8$ 分音的谱面，谱面的总长度是两拍。\n\n\n接下来我们介绍音符的具体表示法。\n\n### 休止符\n\n如果在某一个时值内什么都不做，则谱面中当前音符为空，例如 `{16},,,C,D,` 表示前两个十六分音什么都不做（没有音符），后两个十六分音分别是 `C`，`D` 两个音符。\n\n### Tap 音符\n\nTap 音符需要在一个音符**开始**的瞬间拍击某一个标号的按键，然后瞬间松开。在谱面中直接写出需要拍击的按键编号。例如，`{16},1,,2,,` 表示接下来一拍（四个 $16$ 分音）内，在第一个和第三个 $16$ 分音的开始时刻分别拍击 $1$ 号和 $2$ 号按键，第二个和第四个 $16$ 分音里什么都不做。\n\n如果同一个时刻要拍击多个按键，可以把按键的编号用 `/` 隔开。例如，`{16},1/8,,2/7,,` 表示在第一个 $16$ 分音的开始时刻同时拍击 $1$ 和 $8$ 号键，在第三个 $16$ 分音的开始时刻同时拍击 $2$ 和 $7$ 号键。\n\n### Hold 音符\n\n这是一种需要持续按压的音符，用 `ph[x:y]` 表示在 $p$ 号键上出现一个 Hold 音符，在当前分音开始的瞬间开始按压，持续按压 $y$ 个 $x$ 分音符的长度， 保证 $x$ 是 $\\{4,8,12,16,24,32\\}$ 六个数字之一。例如，``{16},1h[8:1],,2h[8:1],,`` 表示在第一个 $16$ 分音的开始时刻起按压 $1$ 号键，持续时间为 $1$ 个八分音符，即在第二个 $16$ 分音的结束时刻（也是第三个 $16$ 分音的开始时刻）松开按压；然后在第三个 $16$ 分音的开始时刻类似地按压 $2$ 号按键。同样的，在同一时刻拍击的多个 Hold 音符也可以用 `/` 分隔；`/` 也可以用于分隔 Tap 音符和 `Hold` 音符。例如，下面的谱面都是合法的：\n\n- `{4},1h[4:1]/2h[4:1],`\n- `{4},1h[4:1]/2,`\n- `{4},1h[4:1]/2/3,`\n- `{4},1/2/3,`\n- `{4},1h[4:1]/2h[8:1],`\n\n我们保证 `/` 分隔开的**按键编号**是不同的，即不会出现 `{4},1/1` 或 `{4},1/1h[8:1]` 这样的情况。\n\n### 无理检测\n\n因为你只有两只手，所以谱面必须保证在任何时刻，都只有**至多**两个按键被按下（含拍击）。类似这样的谱面被称为**多押无理**：`{16},1h[8:1]/2h[8:1],3,`，因为在第二个 $16$ 分音开始时，你的两只手分别正在按压 $1$ 号和 $2$ 号按键，没有多余的手来按压 $3$ 号按键。特别的，`{16},1h[8:1]/2h[8:1],,3,,` 也是多押无理，因为 Hold 音符结束时刻（第二个 $16$ 分音结束时）和 Tap 拍击时刻（第三个 $16$ 分音开始时）是同一个时刻。\n\n在 Hold 音符持续过程内，按键持续处于按下状态，因此无法拍击同一位置上的 Tap 音符。因此这样的谱面被称为**嵌套无理**：`{16},1h[8:1],1,`，因为第二个 $16$ 分音开始时，$1$ 号键处于按下状态，无法拍击。在一个 Hold 音符的结束时刻于同一按键出现一个 Tap 音符也属于嵌套无理，如 `{16},1h[16:1],1`。\n\n给定一个 s-simai 谱面，你需要判定该谱面是否含有上述两种无理。\n", "inputFormat": "**本题单个测试点内有多组测试数据**。输入的第一行为一个整数 $T$，表示接下来将给出 $T$ 个 s-simai 谱面。对每个谱面，按如下格式给出：\n\n第一行是一个整数 $n$，表示谱面文件的行数。  \n接下来 $n$ 行，每行是一个字符串，表示 s-simai 谱面的一行。", "outputFormat": "对每组数据依次输出一行一个字符串表示答案。\n\n如果谱面没有无理，输出 `Yes`，否则输出 `No`。", "hint": "## 数据规模与约定\n\n| 测试点编号 | $n\\leq$ | 特殊约定 |\n| :-: | :-: | :-: |\n| $1$ | $1$ | $T = 0$ |\n| $2$ | $1$ | AB |\n| $3$ | $1$ | A |\n| $4$ | $1$ | B |\n| $5$ | $1$ | 无 |\n| $6$ | $3$ | AB |\n| $7$ | $3$ | A |\n| $8$ | $3$ | B |\n| $9,10$ | $3$ | 无 |\n\n特殊约定中，A 表示谱面中不含 Hold 音符，B 表示谱面中不含用 `/` 分隔的音符，AB 表示同时满足上述约定。\n\n对于全部的测试数据，保证 $1 \\leq n \\leq 3$，$0 \\leq T \\leq 1000$，输入的谱面是合法的 s-simai 谱面，保证一个测试点内输入谱面的总行数不超过 $1000$。\n\n一行合法的 s-simai 谱面做如下保证：\n\n1. 以 `{x},` 开头，其中 $x \\in \\{4,8,12,16,24,32\\}$\n2. 以 `,` 结尾，且每行至少包含两个 `,`。\n3. 一行的相邻两个 `,` 之间要么是空串（没有字符），要么是若干个 Tap 或 Hold。如果是多个音符，用 `/` 隔开。\n4. 一个 Tap 是一个整数 $p$，保证 $1 \\leq p \\leq 8$。\n5. 一个 Hold 表示为 `ph[x:y]`，其中 $p$ 是整数表示按键编号，$y$ 和 $x$ 也都是整数，`h` 是字符 $\\texttt{h}$。满足 $1 \\leq p \\leq 8$，$x \\in \\{4,8,12,16,24,32\\}$，$1 \\leq y \\leq 9$。\n6. 保证用 `/` 隔开的音符不会要求按压或拍击同一个按键。\n7. 保证一行里字符 `,` 的数量不会超过 $17$ 个。\n\n形式化地，一行 s-simai 谱面满足如下 BNF 范式：\n\n```\n<LINE> = \\{<NOTEVALUE>\\},<BODY>,\n<BODY> = <NOTES> | ε | <BODY>,<BODY>\n<NOTES> = <NOTE> | <NOTE>/<NOTES>\n<NOTE> = <TAP> | <HOLD>\n<TAP> = <BUTTON>\n<HOLD> = <BUTTON>h\\[<NOTEVALUE>:<DIGIT>\\]\n<BUTTON> = [1-8]\n<DIGIT> = [1-9]\n<NOTEVALUE> = 4 | 8 | 12 | 16 | 24 | 32\n```\n\n特别地，保证一个 `<NOTES>` 里 `<BUTTON>` 互不相同，`<BODY>` 展开不会超过 $16$ 次。\n\n\n一个合法的 s-simai 谱面是若干行合法的 s-simai 谱面。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "炽声音节旋", "background": "扶苏是一个舞萌吃。她今天学习了如何编写舞萌的谱面！现在，她要来教一下你了。\n\n舞萌是一款街机游戏，游戏框体共有两个机位，玩家可以单人游玩，亦可以双人组队，其玩法与大多数音乐游戏相似，音符则从屏幕中心向四周移动，玩家需要在合适的时机拍击按键或者触摸屏幕外侧，并达到一定分数才可通关。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6gy8gk1p.png)\n\n_图片来源：wikipedia_", "description": "\n舞萌框体共有 8 个可供拍打的外键，写谱时以右上角为 1 号键，顺时针进行编号，如下所示：\n\n```\n\t\t\t8\t  1\n\t\t\t\n\t\t7\t\t  \t  2\n\t\t\n\t\t6\t\t\t  3\n\t\t\n\t\t\t5\t  4\n```\n\n舞萌谱面使用一种名为 s-simai (simplified-simai) 的语言进行编写。为了方便处理，我们对 s-simai 做进一步简化。\n\n### 节拍与时值\n\n一拍是谱面的一个基本时间单位，被称为一个**四分音**或一个**四分音符**。在本题中，可以认为一拍对应一个固定的时间长度，其具体数值并不重要，你无需区分接下来表述中音符的「时值」和「时长」，可以认为二者是统一的。如果你愿意，可以认为一拍是 $0.5$ 秒，即一个四分音符占 $0.5$ 秒的时间。\n\n除了四分音符外，还有其他时长的音符。一个 $x$ 分音符的时长是一拍的 $\\frac{4}{x}$ 倍。例如，一个 $8$ 分音符的时长是一拍的一半，即半拍。如果一拍是 $0.5$ 秒，则一个八分音占 $0.25$ 秒。一个 $12$ 分音符（虽然乐理中一般不采用「十二分音」这样的表述，但这里为了方便描述做了统一）的时长是一拍的 $\\frac{1}{3}$。我们保证 $x$ 是 $\\{4,8,12,16,24,32\\}$ 六个数字之一。\n\n简化的 s-simai 语言一行表示若干个时长相同的音符，以 `{x},` 开头，表示本行音符的时值（时长）。音符与音符之间以 `,` 分隔。例如，`{16},A,B,C,D,` 表示了接下来连续 $4$ 个十六分音的音符分别是 `A`,`B`,`C`,`D`。多行 s-simai 表示的时间是连续的。例如：\n\n```\n{16},A,B,C,D,\n{8},E,F,\n```\n\n就表示了连续的四个 $16$ 分音和两个 $8$ 分音的谱面，谱面的总长度是两拍。\n\n\n接下来我们介绍音符的具体表示法。\n\n### 休止符\n\n如果在某一个时值内什么都不做，则谱面中当前音符为空，例如 `{16},,,C,D,` 表示前两个十六分音什么都不做（没有音符），后两个十六分音分别是 `C`，`D` 两个音符。\n\n### Tap 音符\n\nTap 音符需要在一个音符**开始**的瞬间拍击某一个标号的按键，然后瞬间松开。在谱面中直接写出需要拍击的按键编号。例如，`{16},1,,2,,` 表示接下来一拍（四个 $16$ 分音）内，在第一个和第三个 $16$ 分音的开始时刻分别拍击 $1$ 号和 $2$ 号按键，第二个和第四个 $16$ 分音里什么都不做。\n\n如果同一个时刻要拍击多个按键，可以把按键的编号用 `/` 隔开。例如，`{16},1/8,,2/7,,` 表示在第一个 $16$ 分音的开始时刻同时拍击 $1$ 和 $8$ 号键，在第三个 $16$ 分音的开始时刻同时拍击 $2$ 和 $7$ 号键。\n\n### Hold 音符\n\n这是一种需要持续按压的音符，用 `ph[x:y]` 表示在 $p$ 号键上出现一个 Hold 音符，在当前分音开始的瞬间开始按压，持续按压 $y$ 个 $x$ 分音符的长度， 保证 $x$ 是 $\\{4,8,12,16,24,32\\}$ 六个数字之一。例如，``{16},1h[8:1],,2h[8:1],,`` 表示在第一个 $16$ 分音的开始时刻起按压 $1$ 号键，持续时间为 $1$ 个八分音符，即在第二个 $16$ 分音的结束时刻（也是第三个 $16$ 分音的开始时刻）松开按压；然后在第三个 $16$ 分音的开始时刻类似地按压 $2$ 号按键。同样的，在同一时刻拍击的多个 Hold 音符也可以用 `/` 分隔；`/` 也可以用于分隔 Tap 音符和 `Hold` 音符。例如，下面的谱面都是合法的：\n\n- `{4},1h[4:1]/2h[4:1],`\n- `{4},1h[4:1]/2,`\n- `{4},1h[4:1]/2/3,`\n- `{4},1/2/3,`\n- `{4},1h[4:1]/2h[8:1],`\n\n我们保证 `/` 分隔开的**按键编号**是不同的，即不会出现 `{4},1/1` 或 `{4},1/1h[8:1]` 这样的情况。\n\n### 无理检测\n\n因为你只有两只手，所以谱面必须保证在任何时刻，都只有**至多**两个按键被按下（含拍击）。类似这样的谱面被称为**多押无理**：`{16},1h[8:1]/2h[8:1],3,`，因为在第二个 $16$ 分音开始时，你的两只手分别正在按压 $1$ 号和 $2$ 号按键，没有多余的手来按压 $3$ 号按键。特别的，`{16},1h[8:1]/2h[8:1],,3,,` 也是多押无理，因为 Hold 音符结束时刻（第二个 $16$ 分音结束时）和 Tap 拍击时刻（第三个 $16$ 分音开始时）是同一个时刻。\n\n在 Hold 音符持续过程内，按键持续处于按下状态，因此无法拍击同一位置上的 Tap 音符。因此这样的谱面被称为**嵌套无理**：`{16},1h[8:1],1,`，因为第二个 $16$ 分音开始时，$1$ 号键处于按下状态，无法拍击。在一个 Hold 音符的结束时刻于同一按键出现一个 Tap 音符也属于嵌套无理，如 `{16},1h[16:1],1`。\n\n给定一个 s-simai 谱面，你需要判定该谱面是否含有上述两种无理。\n", "inputFormat": "**本题单个测试点内有多组测试数据**。输入的第一行为一个整数 $T$，表示接下来将给出 $T$ 个 s-simai 谱面。对每个谱面，按如下格式给出：\n\n第一行是一个整数 $n$，表示谱面文件的行数。  \n接下来 $n$ 行，每行是一个字符串，表示 s-simai 谱面的一行。", "outputFormat": "对每组数据依次输出一行一个字符串表示答案。\n\n如果谱面没有无理，输出 `Yes`，否则输出 `No`。", "hint": "## 数据规模与约定\n\n| 测试点编号 | $n\\leq$ | 特殊约定 |\n| :-: | :-: | :-: |\n| $1$ | $1$ | $T = 0$ |\n| $2$ | $1$ | AB |\n| $3$ | $1$ | A |\n| $4$ | $1$ | B |\n| $5$ | $1$ | 无 |\n| $6$ | $3$ | AB |\n| $7$ | $3$ | A |\n| $8$ | $3$ | B |\n| $9,10$ | $3$ | 无 |\n\n特殊约定中，A 表示谱面中不含 Hold 音符，B 表示谱面中不含用 `/` 分隔的音符，AB 表示同时满足上述约定。\n\n对于全部的测试数据，保证 $1 \\leq n \\leq 3$，$0 \\leq T \\leq 1000$，输入的谱面是合法的 s-simai 谱面，保证一个测试点内输入谱面的总行数不超过 $1000$。\n\n一行合法的 s-simai 谱面做如下保证：\n\n1. 以 `{x},` 开头，其中 $x \\in \\{4,8,12,16,24,32\\}$\n2. 以 `,` 结尾，且每行至少包含两个 `,`。\n3. 一行的相邻两个 `,` 之间要么是空串（没有字符），要么是若干个 Tap 或 Hold。如果是多个音符，用 `/` 隔开。\n4. 一个 Tap 是一个整数 $p$，保证 $1 \\leq p \\leq 8$。\n5. 一个 Hold 表示为 `ph[x:y]`，其中 $p$ 是整数表示按键编号，$y$ 和 $x$ 也都是整数，`h` 是字符 $\\texttt{h}$。满足 $1 \\leq p \\leq 8$，$x \\in \\{4,8,12,16,24,32\\}$，$1 \\leq y \\leq 9$。\n6. 保证用 `/` 隔开的音符不会要求按压或拍击同一个按键。\n7. 保证一行里字符 `,` 的数量不会超过 $17$ 个。\n\n形式化地，一行 s-simai 谱面满足如下 BNF 范式：\n\n```\n<LINE> = \\{<NOTEVALUE>\\},<BODY>,\n<BODY> = <NOTES> | ε | <BODY>,<BODY>\n<NOTES> = <NOTE> | <NOTE>/<NOTES>\n<NOTE> = <TAP> | <HOLD>\n<TAP> = <BUTTON>\n<HOLD> = <BUTTON>h\\[<NOTEVALUE>:<DIGIT>\\]\n<BUTTON> = [1-8]\n<DIGIT> = [1-9]\n<NOTEVALUE> = 4 | 8 | 12 | 16 | 24 | 32\n```\n\n特别地，保证一个 `<NOTES>` 里 `<BUTTON>` 互不相同，`<BODY>` 展开不会超过 $16$ 次。\n\n\n一个合法的 s-simai 谱面是若干行合法的 s-simai 谱面。", "locale": "zh-CN"}}}
{"pid": "P12595", "type": "P", "difficulty": 4, "samples": [["5 7 0 2\n1 2 3", "89001694"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": [], "title": "出生于驾校", "background": "", "description": "\n扶苏有一个长度为 $n$ 的数列 $a = [a_0, a_1, \\dots a_{n - 1}]$。您要帮她支持如下操作，共 $q$ 次：\n\n- `1 x`：给数列里每个数都加上 $x$，即对 $0 \\leq i < n$，都执行 $a_i := a_i + x$，其中 $:=$ 表示赋值。\n- `2 x`：给数列里每个数都乘上 $x$，即对 $0 \\leq i \\lt n$，都执行 $a_i := a_i \\times x$，其中 $:=$ 表示赋值。\n- `3 k p`：对所有满足 $i \\equiv p \\pmod {2^k}$ 的 $i$，求 $a_i$ 的和对 $998,244,353$ 取模的结果，即求 $(\\sum_{i = 0}^{n - 1} a_i \\times [i \\equiv p \\pmod {2^k}]) \\bmod 998,244,353$，其中 $[]$ 是[艾佛森括号](https://baike.baidu.com/item/%E8%89%BE%E4%BD%9B%E6%A3%AE%E6%8B%AC%E5%8F%B7)。\n\n为了避免输出过大，你只需要输出所有操作 $3$ 的结果的**按位异或和**。\n\n本题的输入规模非常巨大，因此我们提供了一个随机数生成器来生成数列和询问。你可以参考输入格式来具体查阅内容。", "inputFormat": "为了避免读入过大，我们将提供如下数据生成器：\n\n标准输入共两行，第一行有四个整数 $n, q, \\mathrm{minK}, \\mathrm{maxK}$。其中 $n$ 和 $q$ 表示数列长度和操作次数，$\\mathrm{minK}$ 和 $\\mathrm{maxK}$ 表示输入 $k$ 的最小和最大值。数据生成器将用到这两个数值。  \n\n**我们提供了 C++、Java、Python 三种语言的数据生成器参考代码，你可以在说明/提示中直接参考和使用这些代码，而无需被担心判定为作弊**。\n\n标准输入第二行有三个参数 $X, Y, Z$，这三个参数是 **32 位无符号整型**，数据生成器将利用这三个参数生成随机数。\n\n你应该定义如下函数：\n\n```cpp\ntypedef uint32_t ui;\nui X, Y, Z;\n\nui nextInt(ui &x = X, ui &y = Y, ui &z = Z) {\n  x ^= y << (z & 31);\n  y ^= z >> (x & 31);\n  z ^= x << (y & 31);\n  x ^= x >> 5; y ^= y << 17; z ^= z >> 6;\n  return x;\n}\n```\n\n接下来，每次调用 `nextInt()` 函数，你都将得到一个 $32$ 位无符号整数。\n\n读入标准输入里的两行 $7$ 个整数后，你已经得到了 $n$ 和 $q$ 的值，接下来按如下代码生成数列 $a$：\n\n```cpp\nconst int lim = 998'244'353;\nstd::vector<int> genArr(int n) {\n  std::vector<int> ret(n);\n  for (int i = 0; i < n; ++i) ret[i] = nextInt() % lim;\n  return ret;\n}\n```\n接下来，你要生成 $q$ 次操作，对每次操作，方法如下：\n\n- 令 `op = nextInt() % 3 + 1`\n- 若 $op = 1$ 或 $op = 2$，取 `x = nextInt() % lim`\n- 否则**依次**取：`k = nextInt() % (maxK - minK + 1) + minK, p = nextInt() % (1 << k)`\n\n这样，你就能拿到每次操作的信息了。\n\n", "outputFormat": "输出一行一个整数，表示所有操作 $3$ 的结果的按位异或和。", "hint": "### 样例解释\n\n调用数据生成器得到的序列 $a = [17,17301653,16795857,17320599,754976961]$；\n\n得到的操作依次是：\n```plain\n2 558452929\n2 832199221\n1 38834385\n3 0 0\n3 1 1\n1 818308198\n2 135235876\n```\n\n### 数据规模与约定\n| 测试点编号 | $n \\le $ | $q \\le$ | 特殊约定 |\n| :-: | :-: | :-: | :-: |\n| $1,2$ | $10^3$ | $10^3$ | 无 |\n| $3$ | $10^5$ | $10^5$ | $k=0$ |\n| $4$ | $10^5$ | $10^5$ | $k=1$ |\n| $5$ | $10^5$ | $10^5$ | $k = 10$ |\n| $6$ | $10^5$ | $10^5$ | 无 |\n| $7$ | $10^5$ | $4 \\times 10^7$ | 无 |\n| $8$ | $4 \\times 10^7$ | $10^5$ | 无 |\n| $9, 10$ | $4 \\times 10^7$ |$4 \\times 10^7$ | 无 |\n\n对全部的测试数据，保证 $1 \\leq n, q \\leq 4 \\times 10^7$，$1 \\leq op \\leq 3$，$0 \\leq k \\leq \\log_2 n$，$0 \\leq p < 2^k$，$0 \\leq a_i,x < 998,244,353$。\n\n为了帮助你快速判断当前测试点的特殊约定，我们保证：编号为 $i$ 的测试点所读入的 $n$ 的末位数字为 $i \\bmod 10$。\n\n### 参考实现\n\n【C++ 参考实现】\n```cpp\n#include <bits/stdc++.h>\n\ntypedef uint32_t ui;\nint n, q, minK, maxK;\nui X, Y, Z;\n\nui nextInt(ui &x = X, ui &y = Y, ui &z = Z) {\n  x ^= y << (z & 31);\n  y ^= z >> (x & 31);\n  z ^= x << (y & 31);\n  x ^= x >> 5; y ^= y << 17; z ^= z >> 6;\n  return x;\n}\n\nconst int lim = 998'244'353;\nstd::vector<int> genArr(int n) {\n  std::vector<int> ret(n);\n  for (int i = 0; i < n; ++i) ret[i] = nextInt() % lim;\n  return ret;\n}\n\nint main() {\n  std::cin >> n >> q >> minK >> maxK;\n  std::cin >> X >> Y >> Z;\n  std::vector<int> a = genArr(n);\n  for (int _ = 1; _ <= q; ++_) {\n    int op = nextInt() % 3 + 1;\n    if (op == 1) {\n      int x = nextInt() % lim;\n      //fill your code here\n    } else if (op == 2) {\n      int x = nextInt() % lim;\n      //fill your code here\n    } else {\n      int k = nextInt() % (maxK - minK + 1) + minK;\n      int p = nextInt() % (1 << k);\n      //fill your code here\n    }\n  }\n  //fill your code here\n}\n```\n\n【Java 参考实现】\n```java\nimport java.util.Scanner;\n\npublic class Main {\n  private static final int lim = 998244353;\n  private static long X, Y, Z;\n\n  private static long maskToU32(long x) {\n    return x & 0xFFFFFFFFL;\n  }\n\n  private static long nextInt() {\n    long x = X;\n    long y = Y;\n    long z = Z;\n\n    x ^= y << (z & 31);\n    x = maskToU32(x);\n    y ^= z >>> (x & 31);\n    y = maskToU32(y);\n    z ^= x << (y & 31);\n    z = maskToU32(z);\n\n    x ^= x >>> 5;\n    x = maskToU32(x);\n    y ^= y << 17;\n    y = maskToU32(y);\n    z ^= z >>> 6;\n    z = maskToU32(z);\n\n    X = x;\n    Y = y;\n    Z = z;\n\n    return X;\n  }\n\n  private static int[] genArr(int n) {\n    int[] ret = new int[n];\n    for (int i = 0; i < n; ++i) {\n      ret[i] = (int)(nextInt() % lim);\n    }\n    return ret;\n  }\n\n  public static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    int n = scanner.nextInt();\n    int q = scanner.nextInt();\n    int minK = scanner.nextInt();\n    int maxK = scanner.nextInt();\n    X = scanner.nextLong();\n    Y = scanner.nextLong();\n    Z = scanner.nextLong();\n\n    int[] a = genArr(n);\n\n    for (int qId = 1; qId <= q; qId++) {\n      long op = nextInt() % 3 + 1;\n      if (op == 1) {\n        int x = (int)(nextInt() % lim);\n        // fill your code here\n      } else if (op == 2) {\n        int x = (int)(nextInt() % lim);\n        // fill your code here\n      } else {\n        int k = (int)(nextInt() % (maxK - minK + 1) + minK);\n        int p = (int)(nextInt() % (1 << k));\n        // fill your code here\n      }\n    }\n    // fill your code here\n  }\n}\n```\n【Python 参考实现】\n```py\nX = 0\nY = 0\nZ = 0\n\nlim = 998244353\n\n\ndef nextInt():\n  global X, Y, Z\n  x = X\n  y = Y\n  z = Z\n\n  x ^= (y << (z & 31)) & 0xFFFFFFFF\n  x &= 0xFFFFFFFF\n\n  y ^= (z >> (x & 31)) & 0xFFFFFFFF\n  y &= 0xFFFFFFFF\n\n  z ^= (x << (y & 31)) & 0xFFFFFFFF\n  z &= 0xFFFFFFFF\n\n  x ^= (x >> 5)\n  x &= 0xFFFFFFFF\n\n  y ^= (y << 17) & 0xFFFFFFFF\n  y &= 0xFFFFFFFF\n\n  z ^= (z >> 6)\n  z &= 0xFFFFFFFF\n\n  X, Y, Z = x, y, z\n  return X\n\n\nn, q, minK, maxK = map(int, input().split())\nX, Y, Z = map(int, input().split())\n\na = [nextInt() % lim for _ in range(n)]\n\nfor _ in range(q):\n  op = nextInt() % 3 + 1\n  if op == 1:\n    x = nextInt() % lim\n    #fill your code here\n  elif op == 2:\n    x = nextInt() % lim\n    #fill your code here\n  elif op == 3:\n    k = nextInt() % (maxK - minK + 1) + minK\n    p = nextInt() % (1 << k)\n    #fill your code here\n\n#fill your code here\n```", "locale": "zh-CN", "translations": {"zh-CN": {"title": "出生于驾校", "background": "", "description": "\n扶苏有一个长度为 $n$ 的数列 $a = [a_0, a_1, \\dots a_{n - 1}]$。您要帮她支持如下操作，共 $q$ 次：\n\n- `1 x`：给数列里每个数都加上 $x$，即对 $0 \\leq i < n$，都执行 $a_i := a_i + x$，其中 $:=$ 表示赋值。\n- `2 x`：给数列里每个数都乘上 $x$，即对 $0 \\leq i \\lt n$，都执行 $a_i := a_i \\times x$，其中 $:=$ 表示赋值。\n- `3 k p`：对所有满足 $i \\equiv p \\pmod {2^k}$ 的 $i$，求 $a_i$ 的和对 $998,244,353$ 取模的结果，即求 $(\\sum_{i = 0}^{n - 1} a_i \\times [i \\equiv p \\pmod {2^k}]) \\bmod 998,244,353$，其中 $[]$ 是[艾佛森括号](https://baike.baidu.com/item/%E8%89%BE%E4%BD%9B%E6%A3%AE%E6%8B%AC%E5%8F%B7)。\n\n为了避免输出过大，你只需要输出所有操作 $3$ 的结果的**按位异或和**。\n\n本题的输入规模非常巨大，因此我们提供了一个随机数生成器来生成数列和询问。你可以参考输入格式来具体查阅内容。", "inputFormat": "为了避免读入过大，我们将提供如下数据生成器：\n\n标准输入共两行，第一行有四个整数 $n, q, \\mathrm{minK}, \\mathrm{maxK}$。其中 $n$ 和 $q$ 表示数列长度和操作次数，$\\mathrm{minK}$ 和 $\\mathrm{maxK}$ 表示输入 $k$ 的最小和最大值。数据生成器将用到这两个数值。  \n\n**我们提供了 C++、Java、Python 三种语言的数据生成器参考代码，你可以在说明/提示中直接参考和使用这些代码，而无需被担心判定为作弊**。\n\n标准输入第二行有三个参数 $X, Y, Z$，这三个参数是 **32 位无符号整型**，数据生成器将利用这三个参数生成随机数。\n\n你应该定义如下函数：\n\n```cpp\ntypedef uint32_t ui;\nui X, Y, Z;\n\nui nextInt(ui &x = X, ui &y = Y, ui &z = Z) {\n  x ^= y << (z & 31);\n  y ^= z >> (x & 31);\n  z ^= x << (y & 31);\n  x ^= x >> 5; y ^= y << 17; z ^= z >> 6;\n  return x;\n}\n```\n\n接下来，每次调用 `nextInt()` 函数，你都将得到一个 $32$ 位无符号整数。\n\n读入标准输入里的两行 $7$ 个整数后，你已经得到了 $n$ 和 $q$ 的值，接下来按如下代码生成数列 $a$：\n\n```cpp\nconst int lim = 998'244'353;\nstd::vector<int> genArr(int n) {\n  std::vector<int> ret(n);\n  for (int i = 0; i < n; ++i) ret[i] = nextInt() % lim;\n  return ret;\n}\n```\n接下来，你要生成 $q$ 次操作，对每次操作，方法如下：\n\n- 令 `op = nextInt() % 3 + 1`\n- 若 $op = 1$ 或 $op = 2$，取 `x = nextInt() % lim`\n- 否则**依次**取：`k = nextInt() % (maxK - minK + 1) + minK, p = nextInt() % (1 << k)`\n\n这样，你就能拿到每次操作的信息了。\n\n", "outputFormat": "输出一行一个整数，表示所有操作 $3$ 的结果的按位异或和。", "hint": "### 样例解释\n\n调用数据生成器得到的序列 $a = [17,17301653,16795857,17320599,754976961]$；\n\n得到的操作依次是：\n```plain\n2 558452929\n2 832199221\n1 38834385\n3 0 0\n3 1 1\n1 818308198\n2 135235876\n```\n\n### 数据规模与约定\n| 测试点编号 | $n \\le $ | $q \\le$ | 特殊约定 |\n| :-: | :-: | :-: | :-: |\n| $1,2$ | $10^3$ | $10^3$ | 无 |\n| $3$ | $10^5$ | $10^5$ | $k=0$ |\n| $4$ | $10^5$ | $10^5$ | $k=1$ |\n| $5$ | $10^5$ | $10^5$ | $k = 10$ |\n| $6$ | $10^5$ | $10^5$ | 无 |\n| $7$ | $10^5$ | $4 \\times 10^7$ | 无 |\n| $8$ | $4 \\times 10^7$ | $10^5$ | 无 |\n| $9, 10$ | $4 \\times 10^7$ |$4 \\times 10^7$ | 无 |\n\n对全部的测试数据，保证 $1 \\leq n, q \\leq 4 \\times 10^7$，$1 \\leq op \\leq 3$，$0 \\leq k \\leq \\log_2 n$，$0 \\leq p < 2^k$，$0 \\leq a_i,x < 998,244,353$。\n\n为了帮助你快速判断当前测试点的特殊约定，我们保证：编号为 $i$ 的测试点所读入的 $n$ 的末位数字为 $i \\bmod 10$。\n\n### 参考实现\n\n【C++ 参考实现】\n```cpp\n#include <bits/stdc++.h>\n\ntypedef uint32_t ui;\nint n, q, minK, maxK;\nui X, Y, Z;\n\nui nextInt(ui &x = X, ui &y = Y, ui &z = Z) {\n  x ^= y << (z & 31);\n  y ^= z >> (x & 31);\n  z ^= x << (y & 31);\n  x ^= x >> 5; y ^= y << 17; z ^= z >> 6;\n  return x;\n}\n\nconst int lim = 998'244'353;\nstd::vector<int> genArr(int n) {\n  std::vector<int> ret(n);\n  for (int i = 0; i < n; ++i) ret[i] = nextInt() % lim;\n  return ret;\n}\n\nint main() {\n  std::cin >> n >> q >> minK >> maxK;\n  std::cin >> X >> Y >> Z;\n  std::vector<int> a = genArr(n);\n  for (int _ = 1; _ <= q; ++_) {\n    int op = nextInt() % 3 + 1;\n    if (op == 1) {\n      int x = nextInt() % lim;\n      //fill your code here\n    } else if (op == 2) {\n      int x = nextInt() % lim;\n      //fill your code here\n    } else {\n      int k = nextInt() % (maxK - minK + 1) + minK;\n      int p = nextInt() % (1 << k);\n      //fill your code here\n    }\n  }\n  //fill your code here\n}\n```\n\n【Java 参考实现】\n```java\nimport java.util.Scanner;\n\npublic class Main {\n  private static final int lim = 998244353;\n  private static long X, Y, Z;\n\n  private static long maskToU32(long x) {\n    return x & 0xFFFFFFFFL;\n  }\n\n  private static long nextInt() {\n    long x = X;\n    long y = Y;\n    long z = Z;\n\n    x ^= y << (z & 31);\n    x = maskToU32(x);\n    y ^= z >>> (x & 31);\n    y = maskToU32(y);\n    z ^= x << (y & 31);\n    z = maskToU32(z);\n\n    x ^= x >>> 5;\n    x = maskToU32(x);\n    y ^= y << 17;\n    y = maskToU32(y);\n    z ^= z >>> 6;\n    z = maskToU32(z);\n\n    X = x;\n    Y = y;\n    Z = z;\n\n    return X;\n  }\n\n  private static int[] genArr(int n) {\n    int[] ret = new int[n];\n    for (int i = 0; i < n; ++i) {\n      ret[i] = (int)(nextInt() % lim);\n    }\n    return ret;\n  }\n\n  public static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    int n = scanner.nextInt();\n    int q = scanner.nextInt();\n    int minK = scanner.nextInt();\n    int maxK = scanner.nextInt();\n    X = scanner.nextLong();\n    Y = scanner.nextLong();\n    Z = scanner.nextLong();\n\n    int[] a = genArr(n);\n\n    for (int qId = 1; qId <= q; qId++) {\n      long op = nextInt() % 3 + 1;\n      if (op == 1) {\n        int x = (int)(nextInt() % lim);\n        // fill your code here\n      } else if (op == 2) {\n        int x = (int)(nextInt() % lim);\n        // fill your code here\n      } else {\n        int k = (int)(nextInt() % (maxK - minK + 1) + minK);\n        int p = (int)(nextInt() % (1 << k));\n        // fill your code here\n      }\n    }\n    // fill your code here\n  }\n}\n```\n【Python 参考实现】\n```py\nX = 0\nY = 0\nZ = 0\n\nlim = 998244353\n\n\ndef nextInt():\n  global X, Y, Z\n  x = X\n  y = Y\n  z = Z\n\n  x ^= (y << (z & 31)) & 0xFFFFFFFF\n  x &= 0xFFFFFFFF\n\n  y ^= (z >> (x & 31)) & 0xFFFFFFFF\n  y &= 0xFFFFFFFF\n\n  z ^= (x << (y & 31)) & 0xFFFFFFFF\n  z &= 0xFFFFFFFF\n\n  x ^= (x >> 5)\n  x &= 0xFFFFFFFF\n\n  y ^= (y << 17) & 0xFFFFFFFF\n  y &= 0xFFFFFFFF\n\n  z ^= (z >> 6)\n  z &= 0xFFFFFFFF\n\n  X, Y, Z = x, y, z\n  return X\n\n\nn, q, minK, maxK = map(int, input().split())\nX, Y, Z = map(int, input().split())\n\na = [nextInt() % lim for _ in range(n)]\n\nfor _ in range(q):\n  op = nextInt() % 3 + 1\n  if op == 1:\n    x = nextInt() % lim\n    #fill your code here\n  elif op == 2:\n    x = nextInt() % lim\n    #fill your code here\n  elif op == 3:\n    k = nextInt() % (maxK - minK + 1) + minK\n    p = nextInt() % (1 << k)\n    #fill your code here\n\n#fill your code here\n```", "locale": "zh-CN"}}}
{"pid": "P12596", "type": "P", "difficulty": 4, "samples": [["4\n0 2\n8 1\n9 4\n9 6\n7 5", "19"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["计算几何", "双指针 two-pointer"], "title": "测速仪惊吓", "background": "", "description": "给定一个 $n$ 个点的凸包和凸包内的一点 $P$。选择凸包上两个不同顶点 $A, B$ 并连接 $PA$、$PB$，该凸包会被分成两部分。求两部分面积差的绝对值的最小值，输出其乘二后的结果。可以证明，这个数为整数。", "inputFormat": "第一行一个正整数 $n$。\n\n接下来 $n$ 行，每行两个非负整数，按逆时针顺序表示凸包上的每个顶点的坐标。\n\n最后一行两个非负整数，表示 $P$ 的坐标。", "outputFormat": "一行一个非负整数，表示两部分面积差的绝对值的最小值乘二后的值。", "hint": "对于任意输入数字，其值在 $[0, 10^9]$ 内。\n\n各数据点规模如下表：\n\n| 测试点编号 | $n = $ |\n| :----------: | :----------: |\n| $1$ | $3$ |\n| $2$ | $4$ |\n| $3$ | $10$ |\n| $4$ | $50$ |\n| $5 \\sim 6$ | $300$ |\n| $7 \\sim 8$ | $5000$ |\n| $9 \\sim 10$ | $10 ^ 5$ |\n\n保证点 $P$ 在凸包内部。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "测速仪惊吓", "background": "", "description": "给定一个 $n$ 个点的凸包和凸包内的一点 $P$。选择凸包上两个不同顶点 $A, B$ 并连接 $PA$、$PB$，该凸包会被分成两部分。求两部分面积差的绝对值的最小值，输出其乘二后的结果。可以证明，这个数为整数。", "inputFormat": "第一行一个正整数 $n$。\n\n接下来 $n$ 行，每行两个非负整数，按逆时针顺序表示凸包上的每个顶点的坐标。\n\n最后一行两个非负整数，表示 $P$ 的坐标。", "outputFormat": "一行一个非负整数，表示两部分面积差的绝对值的最小值乘二后的值。", "hint": "对于任意输入数字，其值在 $[0, 10^9]$ 内。\n\n各数据点规模如下表：\n\n| 测试点编号 | $n = $ |\n| :----------: | :----------: |\n| $1$ | $3$ |\n| $2$ | $4$ |\n| $3$ | $10$ |\n| $4$ | $50$ |\n| $5 \\sim 6$ | $300$ |\n| $7 \\sim 8$ | $5000$ |\n| $9 \\sim 10$ | $10 ^ 5$ |\n\n保证点 $P$ 在凸包内部。\n", "locale": "zh-CN"}}}
{"pid": "P12597", "type": "P", "difficulty": 3, "samples": [["3\nxyzdabc\nxaybzc\nabc\nxyz\nabbcd\naabbdcd", "abc\n\nabbcd"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "字符串", "有限状态自动机", "双指针 two-pointer"], "title": "穿睡衣军训", "background": "在本题中，我们称一个串 $x$ 是一个串 $y$ 的**子串**当且仅当在 $y$ 开头和结尾删除若干个（可以为 $0$ 个）字符后得到的字符串与 $x$ 相同。例如，$\\texttt{bc}$,$\\texttt{abc}$,$\\texttt{a}$,$\\texttt{abcd}$ 都是字符串 $\\texttt{abcd}$ 的子串，但 $\\texttt{abd}$ 不是。\n\n我们称一个串 $x$ 是一个串 $y$ 的**子序列**当且仅当在 $y$ 中删除若干个（可以为 $0$ 个）字符后得到的字符串与 $x$ 相同。例如，$\\texttt{bc}$,$\\texttt{abc}$,$\\texttt{a}$,$\\texttt{abcd}$,$\\texttt{abd}$ 都是字符串 $\\texttt{abcd}$ 的子串，但 $\\texttt{dcba}$ 不是。\n\n特别的，空串是任何串的子串，也是任何串的子序列。", "description": "给定两个字符串 $s,t$，扶苏想让你求出一个字符串 $x$，满足：\n\n- $x$ 是 $s$ 的**子串**。\n- $x$ 是 $t$ 的**子序列**。\n- 在所有满足前述两条的字符串中，$x$ 的长度最长。\n- 在所有满足前述三条的字符串中，$x$ 的字典序最小。\n\n请你帮她求出这样的字符串 $x$。", "inputFormat": "**本题单个测试点内有多组测试数据**，第一行是一个整数，表示数据组数 $T$。\n\n对每组数据，输入两行，每行一个字符串，依次表示 $s$ 和 $t$。", "outputFormat": "对每组数据，输出一行一个字符串，表示你找到的 $x$。  \n特别的，如果 $x$ 是空串，你需要输出一个空行。", "hint": "## 数据规模与约定\n\n用 $|x|$ 表示字符串 $x$ 的长度。\n\n- 对 $10\\%$ 的数据，$T = 0$。\n- 对 $30\\%$ 的数据，$|s| = 1$。\n- 对 $50\\%$ 的数据，$|s|, |t| \\leq 10$。\n- 对 $80\\%$ 的数据，$|s|, |t| \\leq 100$。\n- 对 $100\\%$ 的数据，保证 $0 \\leq T \\leq 10$，$1 \\leq |s|\\leq 10^3$，$1 \\leq |t| \\leq 10^5$，输入字符串只含小写英文字母。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "穿睡衣军训", "background": "在本题中，我们称一个串 $x$ 是一个串 $y$ 的**子串**当且仅当在 $y$ 开头和结尾删除若干个（可以为 $0$ 个）字符后得到的字符串与 $x$ 相同。例如，$\\texttt{bc}$,$\\texttt{abc}$,$\\texttt{a}$,$\\texttt{abcd}$ 都是字符串 $\\texttt{abcd}$ 的子串，但 $\\texttt{abd}$ 不是。\n\n我们称一个串 $x$ 是一个串 $y$ 的**子序列**当且仅当在 $y$ 中删除若干个（可以为 $0$ 个）字符后得到的字符串与 $x$ 相同。例如，$\\texttt{bc}$,$\\texttt{abc}$,$\\texttt{a}$,$\\texttt{abcd}$,$\\texttt{abd}$ 都是字符串 $\\texttt{abcd}$ 的子串，但 $\\texttt{dcba}$ 不是。\n\n特别的，空串是任何串的子串，也是任何串的子序列。", "description": "给定两个字符串 $s,t$，扶苏想让你求出一个字符串 $x$，满足：\n\n- $x$ 是 $s$ 的**子串**。\n- $x$ 是 $t$ 的**子序列**。\n- 在所有满足前述两条的字符串中，$x$ 的长度最长。\n- 在所有满足前述三条的字符串中，$x$ 的字典序最小。\n\n请你帮她求出这样的字符串 $x$。", "inputFormat": "**本题单个测试点内有多组测试数据**，第一行是一个整数，表示数据组数 $T$。\n\n对每组数据，输入两行，每行一个字符串，依次表示 $s$ 和 $t$。", "outputFormat": "对每组数据，输出一行一个字符串，表示你找到的 $x$。  \n特别的，如果 $x$ 是空串，你需要输出一个空行。", "hint": "## 数据规模与约定\n\n用 $|x|$ 表示字符串 $x$ 的长度。\n\n- 对 $10\\%$ 的数据，$T = 0$。\n- 对 $30\\%$ 的数据，$|s| = 1$。\n- 对 $50\\%$ 的数据，$|s|, |t| \\leq 10$。\n- 对 $80\\%$ 的数据，$|s|, |t| \\leq 100$。\n- 对 $100\\%$ 的数据，保证 $0 \\leq T \\leq 10$，$1 \\leq |s|\\leq 10^3$，$1 \\leq |t| \\leq 10^5$，输入字符串只含小写英文字母。", "locale": "zh-CN"}}}
{"pid": "P12598", "type": "P", "difficulty": 6, "samples": [["9 2\n1 1 2 2 3 3 4 4 4\n1 9\n5 9", "6\n3"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["莫队"], "title": "参数要吉祥", "background": "", "description": "\n扶苏是一个大型语言模型。她共有 $n$ 个参数，依次为 $a_1, a_2, \\dots a_n$。现在，你要和她进行 $q$ 次交互。扶苏有先进的混合专家模型（MoE）技术，每轮交互你都会给定一个区间 $[l, r]$，扶苏只有 $a_l, a_{l + 1}, \\dots a_r$ 这些参数会被激活。\n\n对于整数 $x$，我们定义其吉祥程度为在一组激活的参数里出现次数为 $x$ 的数的种类数，记为 $c(x)$。对于每次交互，你要找到一个 $x$ 使 $x \\times c(x)$ 最大，输出 $x \\times c(x)$。\n\n例如，对于一组参数 $[1,1,2,2,33,33,444,444,444]$，则有 $1,2,33$ 这三种数出现了 $2$ 次，取 $x = 2$，得到 $x \\times c(x) = 6$。\n", "inputFormat": "\n第一行是两个整数，表示参数个数 $n$ 和交互次数 $q$。  \n第二行有 $n$ 个整数，表示 $a_1, a_2, \\dots a_n$。  \n接下来 $q$ 行，每行两个整数，表示一次交互激活的参数区间 $[l, r]$。\n", "outputFormat": "\n对每次交互，输出一行一个整数，表示最大的 $x \\times c(x)$。\n", "hint": "### 数据规模与约定\n\n|测试点编号| $n,q\\leq$|特殊约定|\n|:-: | :-: | :-: | \n| $1 \\sim 4$ | $100$ | 无  |\n| $5 \\sim 9$ | $10^3$ | 无 |\n| $10 \\sim 15$ | $3 \\times 10^4$ | 无|\n| $16 \\sim 21$ | $2 \\times 10^5$ | 每个数出现次数均不超过 $100$|\n| $22 \\sim 25$ | $2 \\times 10^5$ | 无 |\n\n对全部的测试数据，保证 $1 \\leq n,a_i, q \\leq 2 \\times 10^5$，$1 \\leq l \\leq r \\leq n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "参数要吉祥", "background": "", "description": "\n扶苏是一个大型语言模型。她共有 $n$ 个参数，依次为 $a_1, a_2, \\dots a_n$。现在，你要和她进行 $q$ 次交互。扶苏有先进的混合专家模型（MoE）技术，每轮交互你都会给定一个区间 $[l, r]$，扶苏只有 $a_l, a_{l + 1}, \\dots a_r$ 这些参数会被激活。\n\n对于整数 $x$，我们定义其吉祥程度为在一组激活的参数里出现次数为 $x$ 的数的种类数，记为 $c(x)$。对于每次交互，你要找到一个 $x$ 使 $x \\times c(x)$ 最大，输出 $x \\times c(x)$。\n\n例如，对于一组参数 $[1,1,2,2,33,33,444,444,444]$，则有 $1,2,33$ 这三种数出现了 $2$ 次，取 $x = 2$，得到 $x \\times c(x) = 6$。\n", "inputFormat": "\n第一行是两个整数，表示参数个数 $n$ 和交互次数 $q$。  \n第二行有 $n$ 个整数，表示 $a_1, a_2, \\dots a_n$。  \n接下来 $q$ 行，每行两个整数，表示一次交互激活的参数区间 $[l, r]$。\n", "outputFormat": "\n对每次交互，输出一行一个整数，表示最大的 $x \\times c(x)$。\n", "hint": "### 数据规模与约定\n\n|测试点编号| $n,q\\leq$|特殊约定|\n|:-: | :-: | :-: | \n| $1 \\sim 4$ | $100$ | 无  |\n| $5 \\sim 9$ | $10^3$ | 无 |\n| $10 \\sim 15$ | $3 \\times 10^4$ | 无|\n| $16 \\sim 21$ | $2 \\times 10^5$ | 每个数出现次数均不超过 $100$|\n| $22 \\sim 25$ | $2 \\times 10^5$ | 无 |\n\n对全部的测试数据，保证 $1 \\leq n,a_i, q \\leq 2 \\times 10^5$，$1 \\leq l \\leq r \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P12599", "type": "P", "difficulty": 6, "samples": [["3\n1\n3\n5", "1\n3\n43\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": [], "title": "常数要较小", "background": "你说得对，但是我不玩原神，我玩【数据删除】。", "description": "给定正整数 $n$，求：\n\n$$\\sum_{i=1}^{n}\\sum_{j=1}^{n}\\mu(ij)ij$$\n\n其中 $\\mu$ 是数论莫比乌斯函数，其定义为：\n\n$$\n\\mu(x) = \\begin{cases}1, &x = 1,\\\\0,& x ~\\text{存在一个大于}~1~\\text{的因子是完全平方数}, \\\\(-1)^k, &\\text{否则，其中}~k~\\text{表示}~x~\\text{的质因子个数}\\\\\\end{cases}\n$$\n\n答案对于 $998244353$ 取模。", "inputFormat": "**本题包含多组测试数据。**\n\n输入的第一行包含一个整数 $T$，表示测试数据的组数。\n\n接下来包含 $T$ 组数据，每组数据的格式如下：\n\n第一行包含一个整数 $n$。", "outputFormat": "对于每组测试数据输出一行，包含一个整数，表示答案对 $998244353$ 取模的结果。", "hint": "- 对于 $10\\%$ 的数据，满足 $1 \\leq n,T \\leq 100$。\n- 对于 $30\\%$ 的数据，满足 $1 \\leq n,T \\leq 5000$。\n- 对于 $100\\%$ 的数据，满足 $1 \\leq T \\leq 10^4$，$1 \\leq n \\leq 10^6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "常数要较小", "background": "你说得对，但是我不玩原神，我玩【数据删除】。", "description": "给定正整数 $n$，求：\n\n$$\\sum_{i=1}^{n}\\sum_{j=1}^{n}\\mu(ij)ij$$\n\n其中 $\\mu$ 是数论莫比乌斯函数，其定义为：\n\n$$\n\\mu(x) = \\begin{cases}1, &x = 1,\\\\0,& x ~\\text{存在一个大于}~1~\\text{的因子是完全平方数}, \\\\(-1)^k, &\\text{否则，其中}~k~\\text{表示}~x~\\text{的质因子个数}\\\\\\end{cases}\n$$\n\n答案对于 $998244353$ 取模。", "inputFormat": "**本题包含多组测试数据。**\n\n输入的第一行包含一个整数 $T$，表示测试数据的组数。\n\n接下来包含 $T$ 组数据，每组数据的格式如下：\n\n第一行包含一个整数 $n$。", "outputFormat": "对于每组测试数据输出一行，包含一个整数，表示答案对 $998244353$ 取模的结果。", "hint": "- 对于 $10\\%$ 的数据，满足 $1 \\leq n,T \\leq 100$。\n- 对于 $30\\%$ 的数据，满足 $1 \\leq n,T \\leq 5000$。\n- 对于 $100\\%$ 的数据，满足 $1 \\leq T \\leq 10^4$，$1 \\leq n \\leq 10^6$。", "locale": "zh-CN"}}}
{"pid": "P12600", "type": "P", "difficulty": 2, "samples": [["2\n2 1", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": [], "title": "连号子序列数", "background": "原题来自 [2025 年洛谷愚人节比赛](https://www.luogu.com.cn/contest/231658)的 [B 题](T568868)。\n\n---\n\n本题是[连号区间数](P8600)的加强版。", "description": "小 S 这些天一直在思考这样一个奇怪而有趣的问题：\n\n在 $1\\sim N$ 的某个全排列中有多少个连号子序列呢？这里所说的连号子序列的定义是：\n\n如果一个子序列里的所有元素递增排序后能得到一个“连续”数列，则称这个子序列连号子序列。\n\n当 $N$ 很小的时候，小 S 可以很快地算出答案，但是当 $N$ 变大的时候，问题就不是那么简单了，现在小 S 需要你的帮助。", "inputFormat": "第一行是一个正整数 $N (1 \\le N \\le 500000)$，表示全排列的规模。\n\n第二行是 $N$ 个不同的数字 $P_i(1 \\le P_i \\le N)$，表示这 $N$ 个数字的某一全排列。", "outputFormat": "输出一个整数，表示不同连号子序列的数目。", "hint": "对于 $20\\%$ 的数据，$N\\le 20$。\n\n对于 $40\\%$ 的数据，$N\\le 500$。\n\n对于 $60\\%$ 的数据，$N\\le 5000$。\n\n对于 $100\\%$ 的数据，$N\\le 500000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "连号子序列数", "background": "原题来自 [2025 年洛谷愚人节比赛](https://www.luogu.com.cn/contest/231658)的 [B 题](T568868)。\n\n---\n\n本题是[连号区间数](P8600)的加强版。", "description": "小 S 这些天一直在思考这样一个奇怪而有趣的问题：\n\n在 $1\\sim N$ 的某个全排列中有多少个连号子序列呢？这里所说的连号子序列的定义是：\n\n如果一个子序列里的所有元素递增排序后能得到一个“连续”数列，则称这个子序列连号子序列。\n\n当 $N$ 很小的时候，小 S 可以很快地算出答案，但是当 $N$ 变大的时候，问题就不是那么简单了，现在小 S 需要你的帮助。", "inputFormat": "第一行是一个正整数 $N (1 \\le N \\le 500000)$，表示全排列的规模。\n\n第二行是 $N$ 个不同的数字 $P_i(1 \\le P_i \\le N)$，表示这 $N$ 个数字的某一全排列。", "outputFormat": "输出一个整数，表示不同连号子序列的数目。", "hint": "对于 $20\\%$ 的数据，$N\\le 20$。\n\n对于 $40\\%$ 的数据，$N\\le 500$。\n\n对于 $60\\%$ 的数据，$N\\le 5000$。\n\n对于 $100\\%$ 的数据，$N\\le 500000$。", "locale": "zh-CN"}}}
{"pid": "P12601", "type": "P", "difficulty": 7, "samples": [["1", "见附件 sample1.txt"], ["3", "= a 4080\n! a"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["提交答案", "Special Judge"], "title": "旷野小计算", "background": "原题来自 [2025 年洛谷愚人节比赛](https://www.luogu.com.cn/contest/231658)的 [E 题](T571828)。\n\n---\n\n**提示：若是使用“提交代码”的方式进行提交，在评测时会给程序输入一个数字（1, 2, 3, ..., 7）表示测试点编号，请在程序中直接输出对应测试点的答案。**", "description": "> 关于什么是寄存器：理解成变量即可。\n\n您需要编写指令，完成给定的计算任务。\n\n在以下指令中，小写字母 `v` 开头的参数表示十进制无符号常数，大写字母 `R` 开头的参数表示寄存器。寄存器均为 64 位无符号整数。您可以自由使用的寄存器有六个：`a`、`b`、`c`、`d`、`x`、`y`。除非特别说明，否则所有寄存器初始值均为 $0$。\n\n| 指令格式 | 描述 |\n| :----------: | :----------: |\n| `+ R1 R2` | 使 R1 寄存器加上 R2 的值 |\n| `- R1 R2` | 使 R1 寄存器减去 R2 的值 |\n| `< R1 v` | 使 R1 寄存器左移 $v$ 位，低位补 0 |\n| `> R1 v` | 使 R1 寄存器右移 $v$ 位，高位补 0 |\n| `^ R1 R2` | 使 R1 寄存器异或上 R2 的值  |\n| `! R1` | 输出 R1 寄存器的值 |\n| `= R1 v` | 使 R1 寄存器的值变为 $v$ |\n| `* R1 R2` | 使 R1 寄存器乘上 R2 的值  |\n| `/ R1 R2` | 使 R1 寄存器除以 R2 的值  |\n\n\n| 编号 | 输入方式 | 任务 | PC 数限制 |  特殊条件 | 分值|\n| :----------: | :----------: | :--------: | :----------: | :-------: |:----------: |\n| 1 | 寄存器 `x` 里保存 $x$ | 输出 $4080x$ | $5\\color{green}+15$ | | $10$ |\n| 2 | 寄存器 `x` 里保存 $x$ |输出 $\\frac{x}{4080}$（下取整） | $16\\color{green}+8$ | $x$ 在 32 位无符号整数范围内 | $10$ |\n| 3 | 寄存器 `x` 里保存 $x$ |输出 $4080$ | $16\\color{green}+8$ | 保证 $x$ 不为 $0$ | $10$ |\n| 4 | 寄存器 `x`、`y` 里保存 $x$、$y$ | 输出 $x \\times y$ 的值 | $1024\\color{green}+512$ | 答案自然溢出即可（即对 $2^{64}$ 取模） | $10$ |\n| 5 | 寄存器 `x`、`y` 里保存 $x$、$y$ | 输出 $\\frac x y$ 的值 （下取整）| $1024\\color{green}+512$ | $x$ 和 $y$ 在 32 位无符号整数范围内，保证 $y$ 不为 $0$ | $20$ |\n| 6 | 寄存器 `x` 里保存 $x$ | 输出 $\\sqrt x$ 的值 （下取整） | $1024\\color{green}+16384$ |  | $20$ |\n| 7 | 寄存器 `x` 里保存 $x$ | 输出大于等于 $x$ 的最小的 $2$ 的次幂 | $96\\color{green}+128$ | 保证 $x$ 不为 $0$ 且答案在 64 位无符号整数范围内 | $20$ |\n\n\n", "inputFormat": "一行一个整数，表示任务编号。", "outputFormat": "若干行，一行一条指令。指令格式如题干所述。\n\n为了方便有基础的选手更清晰地阅读代码，除了按照题干所述的方式书写指令，允许使用助记符格式。\n\n| 指令格式 | 助记符格式 | |寄存器名 | 助记符格式 |\n| :----------: | :----------: |:----------: |:----------: |:----------: |\n| `+ R1 R2` | `add R1, R2` | | `a` | `rax` |\n| `- R1 R2` | `sub R1, R2` | | `b` | `rbx` |\n| `< R1 v` | `shl R1, v` | | `c` | `rcx` |\n| `> R1 v` | `shr R1, v` | | `d` | `rdx` |\n| `^ R1 R2` | `xor R1, R2`  | | `x` | `rsi` |\n| `! R1` | `write R1` | | `y` | `rdi` |\n| `= R1 v` | `movabs R1, v` | | | |\n| `* R1 R2` | `mul R1, R2`  | | | |\n| `/ R1 R2` | `div R1, R2`  | | | |\n\n另外，可使用英文分号 `;` 书写单行注释，如：\n\n```asm\nxor rax, rax    ; set rax to 0\n```\n", "hint": "请注意：\n\n- 程序的大小非常关键，运行的指令条数超过了 PC 数限制就会扣除分数。PC 数限制 $x\\color{green}+y$ 表示：\n\n\t- 当运行的指令条数 $c \\le x$ 时，获得该测试点的全部分数；\n    - 当运行的指令条数 $c >x+y$ 时，不得分；\n    - 当运行的指令条数 $c \\in (x, x+y)$ 时，获得该测试点 $(x+y-c)/y\\times 100\\%$ 的分数（即：线性衰减）。\n\n- 常数、乘法、除法指令（即表格中后三条指令）是非常昂贵的，使用了就会扣除所有的分数。\n\n因此，两个样例的输出实际均不能得到分数。\n\n附件提供 `chk.exe`，供交互式运行指令，输入单条指令回车后即可运行。为方便给寄存器赋值，额外提供指令（评测机内不识别该指令）：\n\n| 指令格式 | 助记符格式 | 说明 |\n|:----------: |:----------: |:----------: |\n| `? R1` | `read R1` |从标准输入读入一个 64 位无符号整数，保存到 R1 寄存器中 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "旷野小计算", "background": "原题来自 [2025 年洛谷愚人节比赛](https://www.luogu.com.cn/contest/231658)的 [E 题](T571828)。\n\n---\n\n**提示：若是使用“提交代码”的方式进行提交，在评测时会给程序输入一个数字（1, 2, 3, ..., 7）表示测试点编号，请在程序中直接输出对应测试点的答案。**", "description": "> 关于什么是寄存器：理解成变量即可。\n\n您需要编写指令，完成给定的计算任务。\n\n在以下指令中，小写字母 `v` 开头的参数表示十进制无符号常数，大写字母 `R` 开头的参数表示寄存器。寄存器均为 64 位无符号整数。您可以自由使用的寄存器有六个：`a`、`b`、`c`、`d`、`x`、`y`。除非特别说明，否则所有寄存器初始值均为 $0$。\n\n| 指令格式 | 描述 |\n| :----------: | :----------: |\n| `+ R1 R2` | 使 R1 寄存器加上 R2 的值 |\n| `- R1 R2` | 使 R1 寄存器减去 R2 的值 |\n| `< R1 v` | 使 R1 寄存器左移 $v$ 位，低位补 0 |\n| `> R1 v` | 使 R1 寄存器右移 $v$ 位，高位补 0 |\n| `^ R1 R2` | 使 R1 寄存器异或上 R2 的值  |\n| `! R1` | 输出 R1 寄存器的值 |\n| `= R1 v` | 使 R1 寄存器的值变为 $v$ |\n| `* R1 R2` | 使 R1 寄存器乘上 R2 的值  |\n| `/ R1 R2` | 使 R1 寄存器除以 R2 的值  |\n\n\n| 编号 | 输入方式 | 任务 | PC 数限制 |  特殊条件 | 分值|\n| :----------: | :----------: | :--------: | :----------: | :-------: |:----------: |\n| 1 | 寄存器 `x` 里保存 $x$ | 输出 $4080x$ | $5\\color{green}+15$ | | $10$ |\n| 2 | 寄存器 `x` 里保存 $x$ |输出 $\\frac{x}{4080}$（下取整） | $16\\color{green}+8$ | $x$ 在 32 位无符号整数范围内 | $10$ |\n| 3 | 寄存器 `x` 里保存 $x$ |输出 $4080$ | $16\\color{green}+8$ | 保证 $x$ 不为 $0$ | $10$ |\n| 4 | 寄存器 `x`、`y` 里保存 $x$、$y$ | 输出 $x \\times y$ 的值 | $1024\\color{green}+512$ | 答案自然溢出即可（即对 $2^{64}$ 取模） | $10$ |\n| 5 | 寄存器 `x`、`y` 里保存 $x$、$y$ | 输出 $\\frac x y$ 的值 （下取整）| $1024\\color{green}+512$ | $x$ 和 $y$ 在 32 位无符号整数范围内，保证 $y$ 不为 $0$ | $20$ |\n| 6 | 寄存器 `x` 里保存 $x$ | 输出 $\\sqrt x$ 的值 （下取整） | $1024\\color{green}+16384$ |  | $20$ |\n| 7 | 寄存器 `x` 里保存 $x$ | 输出大于等于 $x$ 的最小的 $2$ 的次幂 | $96\\color{green}+128$ | 保证 $x$ 不为 $0$ 且答案在 64 位无符号整数范围内 | $20$ |\n\n\n", "inputFormat": "一行一个整数，表示任务编号。", "outputFormat": "若干行，一行一条指令。指令格式如题干所述。\n\n为了方便有基础的选手更清晰地阅读代码，除了按照题干所述的方式书写指令，允许使用助记符格式。\n\n| 指令格式 | 助记符格式 | |寄存器名 | 助记符格式 |\n| :----------: | :----------: |:----------: |:----------: |:----------: |\n| `+ R1 R2` | `add R1, R2` | | `a` | `rax` |\n| `- R1 R2` | `sub R1, R2` | | `b` | `rbx` |\n| `< R1 v` | `shl R1, v` | | `c` | `rcx` |\n| `> R1 v` | `shr R1, v` | | `d` | `rdx` |\n| `^ R1 R2` | `xor R1, R2`  | | `x` | `rsi` |\n| `! R1` | `write R1` | | `y` | `rdi` |\n| `= R1 v` | `movabs R1, v` | | | |\n| `* R1 R2` | `mul R1, R2`  | | | |\n| `/ R1 R2` | `div R1, R2`  | | | |\n\n另外，可使用英文分号 `;` 书写单行注释，如：\n\n```asm\nxor rax, rax    ; set rax to 0\n```\n", "hint": "请注意：\n\n- 程序的大小非常关键，运行的指令条数超过了 PC 数限制就会扣除分数。PC 数限制 $x\\color{green}+y$ 表示：\n\n\t- 当运行的指令条数 $c \\le x$ 时，获得该测试点的全部分数；\n    - 当运行的指令条数 $c >x+y$ 时，不得分；\n    - 当运行的指令条数 $c \\in (x, x+y)$ 时，获得该测试点 $(x+y-c)/y\\times 100\\%$ 的分数（即：线性衰减）。\n\n- 常数、乘法、除法指令（即表格中后三条指令）是非常昂贵的，使用了就会扣除所有的分数。\n\n因此，两个样例的输出实际均不能得到分数。\n\n附件提供 `chk.exe`，供交互式运行指令，输入单条指令回车后即可运行。为方便给寄存器赋值，额外提供指令（评测机内不识别该指令）：\n\n| 指令格式 | 助记符格式 | 说明 |\n|:----------: |:----------: |:----------: |\n| `? R1` | `read R1` |从标准输入读入一个 64 位无符号整数，保存到 R1 寄存器中 |", "locale": "zh-CN"}}}
{"pid": "P12602", "type": "P", "difficulty": 6, "samples": [["123\n", "3\n"], ["1234\n", "4\n"], ["54321\n", "5\n"], ["123456\n", "6\n"], ["114\n", "6\n"], ["CCF\n", "6\n"], ["add\n", "5\n"], ["eleven\n", "54\n"], ["BV1fy411e7ue\n", "645\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": [], "title": "指鹿为马", "background": "原题来自 [2025 年洛谷愚人节比赛](https://www.luogu.com.cn/contest/231658)的 [F 题](T568349)。\n\n---\n\n![](bilibili:BV1fy411e7ue)", "description": "给定一个字符串 $S$。\n\n你有一个随机打字机。这个随机打字机打出的第一个字符一定是 $S$ 的第一位，之后打出的所有字符的概率分布只和它打出的上一个字符有关，并且按照如下规则进行：\n\n- 将字符串 $S$ 首尾相接连成一个环，记录下每种字符的下一个字符的种类和出现次数；\n- 那么，如果它打出的上一个字符是 $i$，此时它接下来打出字符 $j$ 的概率为 $\\frac{cnt_{i,j}}{cnt_i}$。\n- 其中，$cnt_i$ 为字符 $i$ 在 $S$ 中的出现次数，$cnt_{i,j}$ 为子串 $ij$ 在环状的 $S$ 中的出现次数。\n\n每个新打出的字符会接在上一个打出的字符的后面。\n\n当 $S$ （注意不是环状的 $S$）首次成为打字机打出的字符串的子串时，记录下当前打字机打出的字符总数。求这个总数的期望值模 $998244353$ 的结果。", "inputFormat": "一行一个字符串 $S$，由大小写字母和数字组成。长度不超过 $300000$。", "outputFormat": "一行一个整数表示答案模 $998244353$ 的结果。", "hint": "设 $n$ 为字符串的长度。\n\n|   测试点编号    | 特殊性质 A | 特殊性质 B | 无特殊性质 |\n| :-------------------: | :--------: | :--------: | :--------: |\n|   $n\\le 5$    |     1      |    2, 3    |    4, 5    |\n|   $n\\le 10$   |     6      |    7, 8    |   9, 10    |\n|   $n\\le 20$   |     11     |   12, 13   |   14, 15   |\n|  $n\\le 100$   |     16     |   17, 18   |   19, 20   |\n|  $n\\le 200$   |     21     |   22, 23   |   24, 25   |\n|  $n\\le 300$   |     26     |   27, 28   |   29, 30   |\n|  $n\\le 1000$  |     31     |   32, 33   |   34, 35   |\n|  $n\\le 2000$  |     36     |   37, 38   |   39, 40   |\n| $n\\le 2\\times 10^5$ |     41     |   42, 43   |   44, 45   |\n| $n\\le 3\\times 10^5$ |     46     |   47, 48   |   49, 50   |\n\n特殊性质 A：保证输入的字符串是由一个没有重复字符的字符串重复若干次得到，比如 `cat`，`catcat`，`meowmeowmeow`。\n\n特殊性质 B：保证输入的字符串的首字母在字符串中出现恰好一次。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "指鹿为马", "background": "原题来自 [2025 年洛谷愚人节比赛](https://www.luogu.com.cn/contest/231658)的 [F 题](T568349)。\n\n---\n\n![](bilibili:BV1fy411e7ue)", "description": "给定一个字符串 $S$。\n\n你有一个随机打字机。这个随机打字机打出的第一个字符一定是 $S$ 的第一位，之后打出的所有字符的概率分布只和它打出的上一个字符有关，并且按照如下规则进行：\n\n- 将字符串 $S$ 首尾相接连成一个环，记录下每种字符的下一个字符的种类和出现次数；\n- 那么，如果它打出的上一个字符是 $i$，此时它接下来打出字符 $j$ 的概率为 $\\frac{cnt_{i,j}}{cnt_i}$。\n- 其中，$cnt_i$ 为字符 $i$ 在 $S$ 中的出现次数，$cnt_{i,j}$ 为子串 $ij$ 在环状的 $S$ 中的出现次数。\n\n每个新打出的字符会接在上一个打出的字符的后面。\n\n当 $S$ （注意不是环状的 $S$）首次成为打字机打出的字符串的子串时，记录下当前打字机打出的字符总数。求这个总数的期望值模 $998244353$ 的结果。", "inputFormat": "一行一个字符串 $S$，由大小写字母和数字组成。长度不超过 $300000$。", "outputFormat": "一行一个整数表示答案模 $998244353$ 的结果。", "hint": "设 $n$ 为字符串的长度。\n\n|   测试点编号    | 特殊性质 A | 特殊性质 B | 无特殊性质 |\n| :-------------------: | :--------: | :--------: | :--------: |\n|   $n\\le 5$    |     1      |    2, 3    |    4, 5    |\n|   $n\\le 10$   |     6      |    7, 8    |   9, 10    |\n|   $n\\le 20$   |     11     |   12, 13   |   14, 15   |\n|  $n\\le 100$   |     16     |   17, 18   |   19, 20   |\n|  $n\\le 200$   |     21     |   22, 23   |   24, 25   |\n|  $n\\le 300$   |     26     |   27, 28   |   29, 30   |\n|  $n\\le 1000$  |     31     |   32, 33   |   34, 35   |\n|  $n\\le 2000$  |     36     |   37, 38   |   39, 40   |\n| $n\\le 2\\times 10^5$ |     41     |   42, 43   |   44, 45   |\n| $n\\le 3\\times 10^5$ |     46     |   47, 48   |   49, 50   |\n\n特殊性质 A：保证输入的字符串是由一个没有重复字符的字符串重复若干次得到，比如 `cat`，`catcat`，`meowmeowmeow`。\n\n特殊性质 B：保证输入的字符串的首字母在字符串中出现恰好一次。", "locale": "zh-CN"}}}
{"pid": "P12603", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384]}, "tags": [], "title": "RuShiA", "background": "原题来自 [2025 年洛谷愚人节比赛](https://www.luogu.com.cn/contest/231658)的 [M 题](T574918)。\n\n---\n\n> 已经了解 RSA 算法的选手可以略过题目背景。\n\nRSA 算法是一种非对称加密算法。\n\n前期准备工作：\n\n- 生成两个很大的质数 $p$ 和 $q$。\n- 计算 $n=pq$。\n- 选择一个合适的质数 $e$（不需要太大）。\n- 令 $r=(p-1)(q-1)$。\n- 计算 $e$ 在模 $r$ 下的逆元，记作 $d$。即：解方程 $ed \\equiv 1 (\\bmod r) $。\n- 公开 $n$ 和 $e$，即公钥。$p$、$q$、$d$ 保密，即私钥。\n\n加密消息：\n\n- 对于明文 $m$，计算 $c=m^e \\bmod n$。$c$ 即为密文。\n\n解密消息：\n\n- 对于密文 $c$，计算 $m=c^d \\bmod n$。$m$ 即为明文。\n\n作为破解者，可以知道的只有公钥 $n$、$e$ 和密文 $c$。\n\n要想计算出 $m$，就必须知道 $d$。若要通过 $n$ 计算出 $d=(p-1)(q-1)$，相当于要通过分解 $n$ 计算 $p$ 和 $q$。\n\n但是 $p$ 和 $q$ 是很大的质数，对 $n$ 做质因数分解非常困难。这是 RSA 算法安全性的基础。\n\n不过，如果 RSA 运用得不好（比如，$p$ 和 $q$ 选取得太小），那么还是有破解的可能（比如，因为质数太小直接暴力分解 $n$）。\n\n请试着破解下面几组密文。", "description": "**本题为提交答案题**。\n\n密文已经下发，请在附件中下载。一共有 $9$ 批密文。请自行尝试解密这些密文。\n\n一批密文内可能含多组 $n$ 和 $c$。若无特殊说明，$e=65537$。\n\n解密出来的 $m$ 请转化为字符串。转化方式为：将 $m$ 标识为 \n16 进制字符串，按字节转化为 ASCII 编码，得到信息。信息中包含了 flag——你不需要提交整条信息，只需要提交该 flag。\n\nflag 会用花括号包围起来，例如：`This is your flag: {wxyz9876}`。则 flag 是 `wxyz9876`。\n\n例如，$m=581758585144958727177341$，转化为十六进制为 $\\texttt{7b31323334414243447d}$，按字节转化为 ASCII 编码后得到消息 `{1234ABCD}`，则你需要提交 `1234ABCD` 作为答案。", "inputFormat": "一个整数 $n$ 表示密文批次编号，从 $1$ 到 $9$。", "outputFormat": "一行，包含一条字符串，对应批次解密得到的 flag。", "hint": "| Subtask 编号 | 特殊性质 | 密文组数 | 分值 |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| 1 |  | 1 | 5 |\n| 2 | $p>10^{298}\\times q$  | 1 | 5 |\n| 3 | $p$，$q$ 差值小于 $10^3$ | 1 | 10 |\n| 4 | $p_1=p_2$ | 2 | 10 |\n| 5 | $e=3$ | 1| 10 |\n| 6 | $e_1=65537$，$e_2=70001$，$m_1=m_2$ | 2| 15 |\n| 7 | $e_1=e_2=e_3=3$，$m_1=m_2=m_3$ | 3 | 15 |\n| 8 | 提供 $a=(p+2)(q+2)$  | 1| 15 |\n| 9 |  | 1 |  15 |\n\n如果你使用 Python，那么下面这些可能可以帮助你：\n\n- Python 自带函数 `pow(x, a, p)`，计算 $x^a \\bmod p$。\n- $d$ 的计算可以参考如下代码（需要 `primefac` 包）：\n\n```python\nfrom primefac import modinv\np = ...\nq = ...\ne = ...\nr = (p - 1) * (q - 1)\nd = modinv(e, r) % r\n```", "locale": "zh-CN", "translations": {"zh-CN": {"title": "RuShiA", "background": "原题来自 [2025 年洛谷愚人节比赛](https://www.luogu.com.cn/contest/231658)的 [M 题](T574918)。\n\n---\n\n> 已经了解 RSA 算法的选手可以略过题目背景。\n\nRSA 算法是一种非对称加密算法。\n\n前期准备工作：\n\n- 生成两个很大的质数 $p$ 和 $q$。\n- 计算 $n=pq$。\n- 选择一个合适的质数 $e$（不需要太大）。\n- 令 $r=(p-1)(q-1)$。\n- 计算 $e$ 在模 $r$ 下的逆元，记作 $d$。即：解方程 $ed \\equiv 1 (\\bmod r) $。\n- 公开 $n$ 和 $e$，即公钥。$p$、$q$、$d$ 保密，即私钥。\n\n加密消息：\n\n- 对于明文 $m$，计算 $c=m^e \\bmod n$。$c$ 即为密文。\n\n解密消息：\n\n- 对于密文 $c$，计算 $m=c^d \\bmod n$。$m$ 即为明文。\n\n作为破解者，可以知道的只有公钥 $n$、$e$ 和密文 $c$。\n\n要想计算出 $m$，就必须知道 $d$。若要通过 $n$ 计算出 $d=(p-1)(q-1)$，相当于要通过分解 $n$ 计算 $p$ 和 $q$。\n\n但是 $p$ 和 $q$ 是很大的质数，对 $n$ 做质因数分解非常困难。这是 RSA 算法安全性的基础。\n\n不过，如果 RSA 运用得不好（比如，$p$ 和 $q$ 选取得太小），那么还是有破解的可能（比如，因为质数太小直接暴力分解 $n$）。\n\n请试着破解下面几组密文。", "description": "**本题为提交答案题**。\n\n密文已经下发，请在附件中下载。一共有 $9$ 批密文。请自行尝试解密这些密文。\n\n一批密文内可能含多组 $n$ 和 $c$。若无特殊说明，$e=65537$。\n\n解密出来的 $m$ 请转化为字符串。转化方式为：将 $m$ 标识为 \n16 进制字符串，按字节转化为 ASCII 编码，得到信息。信息中包含了 flag——你不需要提交整条信息，只需要提交该 flag。\n\nflag 会用花括号包围起来，例如：`This is your flag: {wxyz9876}`。则 flag 是 `wxyz9876`。\n\n例如，$m=581758585144958727177341$，转化为十六进制为 $\\texttt{7b31323334414243447d}$，按字节转化为 ASCII 编码后得到消息 `{1234ABCD}`，则你需要提交 `1234ABCD` 作为答案。", "inputFormat": "一个整数 $n$ 表示密文批次编号，从 $1$ 到 $9$。", "outputFormat": "一行，包含一条字符串，对应批次解密得到的 flag。", "hint": "| Subtask 编号 | 特殊性质 | 密文组数 | 分值 |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| 1 |  | 1 | 5 |\n| 2 | $p>10^{298}\\times q$  | 1 | 5 |\n| 3 | $p$，$q$ 差值小于 $10^3$ | 1 | 10 |\n| 4 | $p_1=p_2$ | 2 | 10 |\n| 5 | $e=3$ | 1| 10 |\n| 6 | $e_1=65537$，$e_2=70001$，$m_1=m_2$ | 2| 15 |\n| 7 | $e_1=e_2=e_3=3$，$m_1=m_2=m_3$ | 3 | 15 |\n| 8 | 提供 $a=(p+2)(q+2)$  | 1| 15 |\n| 9 |  | 1 |  15 |\n\n如果你使用 Python，那么下面这些可能可以帮助你：\n\n- Python 自带函数 `pow(x, a, p)`，计算 $x^a \\bmod p$。\n- $d$ 的计算可以参考如下代码（需要 `primefac` 包）：\n\n```python\nfrom primefac import modinv\np = ...\nq = ...\ne = ...\nr = (p - 1) * (q - 1)\nd = modinv(e, r) % r\n```", "locale": "zh-CN"}}}
{"pid": "P12604", "type": "P", "difficulty": 5, "samples": [["2 -1\n2 1 1\n1 2 1\n1 2 2\n3 3 1\n1 2 1\n2 3 1\n1 3 1\n1 3 2", "1\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "并查集", "数论", "交互题", "O2优化", "二分图"], "title": "「FAOI-R6」魂灵之影", "background": "此题因撞题已移出 FAOI Round 6.\n\n> Draw me to the light, let the curse be lifted  \nWe can rise above the roar  \nWith the bite of every devil  \nWe've felled before  \nDrown them out  \nLet the fog give way to clarity  \nThere is power in the strain of every drop I bleed  \nI am the venom and the cure  \nTake me  \nThrough the fear, through the heart that's broken  \nOur world lies in wait for me  \nEvery tear, every scar left open  \nThis is the taming of the beast  \nI'll end this war you started  \nI'll stitch this wound with bloodshed  \nYou are my wicked victory  \n\n<https://music.163.com/#/song?id=2672191019>", "description": "给定一个无向**连通**图，边带权，可能存在重边自环。有 $q$ 次查询，每次给定 $x,y,z$，求所有以 $x$ 为起点，$y$ 为终点的路径（不要求为简单路径）中，边权和 $\\bmod\\ z$ 的最小值是多少。\n\n### 交互方式\n\n**本题为交互题，只支持 C++ 语言提交，并且不支持 C++14 (GCC 9)。**\n\n你需要编写以下三个函数：\n\n```cpp\nvoid Ready(int T, int subtask_id)\n```\n\n该函数在每个测试点中仅会调用一次，两个参数表示该测试点的数据组数和子任务编号。样例的子任务编号为 $-1$。\n\n```cpp\nvoid Set(int n, int m, int q, vector <int> u, vector <int> v, vector <int> w)\n```\n\n在调用 `Ready` 之后，该函数会（在每个测试点中）被调用 $T$ 次，其中 $n,m$ 分别表示图的边数和点数。$u,v,w$ 的大小均为 $m$，$u[i],v[i],w[i]$ 表示图的一条边。\n\n```cpp\nint Go(int x, int y, int z)\n```\n\n每次调用 `Set` 之后，该函数会（在每组数据中）被调用 $q$ 次，每次调用表示一次查询。返回值应为本次查询的答案。\n\n你可以直接以下发文件中的 `template.cpp` 为基础编写。", "inputFormat": "**以下格式只对本地测试有效，但变量名的含义与实际评测相同。在实际评测中，请不要试图从标准输入（stdin）读取任何内容。**\n\n**本题有多组数据。**\n\n第一行两个非负整数 $T$ 和 $\\text{subtask\\_id}$，分别表示数据组数和 Subtask 编号。\n\n特别地，样例满足 $\\text{subtask\\_id}=-1$。\n\n对于每组数据：\n- 第一行是空行。\n- 第二行三个非负整数 $n,m,q$。\n- 接下来 $m$ 行，每行三个非负整数 $u,v,w$，表示一条边。\n- 接下来 $q$ 行，每行三个正整数 $x,y,z$，表示一次查询。", "outputFormat": "**以下格式只对本地测试有效，但变量名的含义与实际评测相同。在实际评测中，请不要试图向标准输出（stdout）打印任何内容。**\n\n对于每组数据：\n- 第一行是空行。\n- 下面 $q$ 行，每行一个非负整数，表示答案。", "hint": "#### 【样例解释】\n\n对于第 $1$ 组数据的唯一一组询问，所有路径均形如 $1\\to 2\\to 1\\to \\dots \\to 1\\to 2$，可以证明所有路径的权值均为 $1$。\n\n对于第 $2$ 组数据的唯一一组询问，路径 $1\\to 2\\to 3$ 权值为 $2\\bmod 2=0$，路径 $1\\to 3$ 的答案为 $1\\bmod 2=1$，所以答案为 $0$。\n\n#### 【数据范围】\n\n对于 $100\\%$ 的数据，$0\\le T\\le 1.5 \\times 10^4$，$-1 \\le \\text{subtask\\_id} \\le 9$，$0\\le n,m,q\\le 10^6$，$1\\le u,v,x,y\\le n$，$0\\le w\\le 10^9$，$1\\le z\\le 10^9$，保证图连通。\n\n请下载附件中的 `judge_result.jpeg` 以了解交互库所占用资源的规模。如果你不想下载附件的话，我们在这里用一句话概括一下：保证交互库的运行时间不超过 0.15 秒，占用的内存不超过 60 MB。\n\n**本题开启子任务捆绑测试。**\n\n- Subtask 0 - Subtask 4（10 pts）：$n,m,q,w,z\\le 10$，$T \\le 1.5 \\times 10^4$。\n  - Subtask 0（2 pts）：$n=0$。\n  - Subtask 1（2 pts）：$n=1$。\n  - Subtask 2（1 pts）：$n=2$，$m \\le 3$。\n  - Subtask 3（4 pts）：$n \\le 4$，$m \\le 6$，$w \\le 8$。\n  - Subtask 4（1 pts）：在 Subtask 0 - Subtask 4 下无特殊限制。\n- Subtask 5 - Subtask 9（90 pts）：$n,m,q\\le 10^6$，$w,z \\le 10^9$，$T=1$。\n  - Subtask 5（20 pts）：$n,m,q,w,z\\le 100$。\n  - Subtask 6（20 pts）：$n,m,q,w,z\\le 10^3$。\n  - Subtask 7（10 pts）：$w,z\\le 5$。\n  - Subtask 8（10 pts）：$w=1$。\n  - Subtask 9（30 pts）：在 Subtask 5 - Subtask 9 下无特殊限制。\n\n\nIdea：ppip，Solution：喵仔牛奶，Code：ppip，Data：035966_L3", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「FAOI-R6」魂灵之影", "background": "此题因撞题已移出 FAOI Round 6.\n\n> Draw me to the light, let the curse be lifted  \nWe can rise above the roar  \nWith the bite of every devil  \nWe've felled before  \nDrown them out  \nLet the fog give way to clarity  \nThere is power in the strain of every drop I bleed  \nI am the venom and the cure  \nTake me  \nThrough the fear, through the heart that's broken  \nOur world lies in wait for me  \nEvery tear, every scar left open  \nThis is the taming of the beast  \nI'll end this war you started  \nI'll stitch this wound with bloodshed  \nYou are my wicked victory  \n\n<https://music.163.com/#/song?id=2672191019>", "description": "给定一个无向**连通**图，边带权，可能存在重边自环。有 $q$ 次查询，每次给定 $x,y,z$，求所有以 $x$ 为起点，$y$ 为终点的路径（不要求为简单路径）中，边权和 $\\bmod\\ z$ 的最小值是多少。\n\n### 交互方式\n\n**本题为交互题，只支持 C++ 语言提交，并且不支持 C++14 (GCC 9)。**\n\n你需要编写以下三个函数：\n\n```cpp\nvoid Ready(int T, int subtask_id)\n```\n\n该函数在每个测试点中仅会调用一次，两个参数表示该测试点的数据组数和子任务编号。样例的子任务编号为 $-1$。\n\n```cpp\nvoid Set(int n, int m, int q, vector <int> u, vector <int> v, vector <int> w)\n```\n\n在调用 `Ready` 之后，该函数会（在每个测试点中）被调用 $T$ 次，其中 $n,m$ 分别表示图的边数和点数。$u,v,w$ 的大小均为 $m$，$u[i],v[i],w[i]$ 表示图的一条边。\n\n```cpp\nint Go(int x, int y, int z)\n```\n\n每次调用 `Set` 之后，该函数会（在每组数据中）被调用 $q$ 次，每次调用表示一次查询。返回值应为本次查询的答案。\n\n你可以直接以下发文件中的 `template.cpp` 为基础编写。", "inputFormat": "**以下格式只对本地测试有效，但变量名的含义与实际评测相同。在实际评测中，请不要试图从标准输入（stdin）读取任何内容。**\n\n**本题有多组数据。**\n\n第一行两个非负整数 $T$ 和 $\\text{subtask\\_id}$，分别表示数据组数和 Subtask 编号。\n\n特别地，样例满足 $\\text{subtask\\_id}=-1$。\n\n对于每组数据：\n- 第一行是空行。\n- 第二行三个非负整数 $n,m,q$。\n- 接下来 $m$ 行，每行三个非负整数 $u,v,w$，表示一条边。\n- 接下来 $q$ 行，每行三个正整数 $x,y,z$，表示一次查询。", "outputFormat": "**以下格式只对本地测试有效，但变量名的含义与实际评测相同。在实际评测中，请不要试图向标准输出（stdout）打印任何内容。**\n\n对于每组数据：\n- 第一行是空行。\n- 下面 $q$ 行，每行一个非负整数，表示答案。", "hint": "#### 【样例解释】\n\n对于第 $1$ 组数据的唯一一组询问，所有路径均形如 $1\\to 2\\to 1\\to \\dots \\to 1\\to 2$，可以证明所有路径的权值均为 $1$。\n\n对于第 $2$ 组数据的唯一一组询问，路径 $1\\to 2\\to 3$ 权值为 $2\\bmod 2=0$，路径 $1\\to 3$ 的答案为 $1\\bmod 2=1$，所以答案为 $0$。\n\n#### 【数据范围】\n\n对于 $100\\%$ 的数据，$0\\le T\\le 1.5 \\times 10^4$，$-1 \\le \\text{subtask\\_id} \\le 9$，$0\\le n,m,q\\le 10^6$，$1\\le u,v,x,y\\le n$，$0\\le w\\le 10^9$，$1\\le z\\le 10^9$，保证图连通。\n\n请下载附件中的 `judge_result.jpeg` 以了解交互库所占用资源的规模。如果你不想下载附件的话，我们在这里用一句话概括一下：保证交互库的运行时间不超过 0.15 秒，占用的内存不超过 60 MB。\n\n**本题开启子任务捆绑测试。**\n\n- Subtask 0 - Subtask 4（10 pts）：$n,m,q,w,z\\le 10$，$T \\le 1.5 \\times 10^4$。\n  - Subtask 0（2 pts）：$n=0$。\n  - Subtask 1（2 pts）：$n=1$。\n  - Subtask 2（1 pts）：$n=2$，$m \\le 3$。\n  - Subtask 3（4 pts）：$n \\le 4$，$m \\le 6$，$w \\le 8$。\n  - Subtask 4（1 pts）：在 Subtask 0 - Subtask 4 下无特殊限制。\n- Subtask 5 - Subtask 9（90 pts）：$n,m,q\\le 10^6$，$w,z \\le 10^9$，$T=1$。\n  - Subtask 5（20 pts）：$n,m,q,w,z\\le 100$。\n  - Subtask 6（20 pts）：$n,m,q,w,z\\le 10^3$。\n  - Subtask 7（10 pts）：$w,z\\le 5$。\n  - Subtask 8（10 pts）：$w=1$。\n  - Subtask 9（30 pts）：在 Subtask 5 - Subtask 9 下无特殊限制。\n\n\nIdea：ppip，Solution：喵仔牛奶，Code：ppip，Data：035966_L3", "locale": "zh-CN"}}}
{"pid": "P12605", "type": "P", "difficulty": 3, "samples": [["5\n1 2 3 4 5", "3"], ["6\n2 3 7 4 5 8", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "洛谷原创", "前缀和", "洛谷月赛"], "title": "求和", "background": "", "description": "给定长为 $n$ 的整数序列 $a$。\n\n您可以对这个序列进行若干次（可以为 $0$ 次）操作，每次操作形如：\n\n选定满足 $1\\le i,j\\le n$ 的下标 $i$ 和 $j$，将 $a_i$ 赋值为 $a_i+1$，同时将 $a_j$ 赋值为 $a_j-1$。$i$ 和 $j$ 不能相同。\n\n求使得前缀和之和等于后缀和之和的最小操作次数。\n\n也就是说，令 $s_i=a_1+a_2+\\dots+a_i,t_i=a_i+a_{i+1}+\\dots+a_n$，有 $s_1+s_2+\\dots+s_n=t_1+t_2+\\dots+t_n$。\n\n注意，$a_i$ 可以变为负数。", "inputFormat": "第一行一个整数 $n$。\n\n第二行用空格隔开的 $n$ 个整数，表示 $a$ 序列。", "outputFormat": "输出一行一个整数表示最小操作次数。\n\n若无解，输出 $-1$。", "hint": "**本题采用捆绑测试。**\n\n- Subtask 1（30 pts）：$1 \\le n \\le 2$；\n- Subtask 2（30 pts）：$a_i=i$；\n- Subtask 3（5 pts）：$a_i=1$；\n- Subtask 4（35 pts）：无特殊限制。\n\n对于所有数据，保证 $1 \\le n,a_i \\le 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "A. Prefixsuffix Sums", "background": "", "description": "You are given an integer sequence $a$ of length $n$.\n\nYou can perform the following operations any number of times (possibly, zero):\n\nSelect indices $1 \\le i, j \\le n$ such that $i \\ne j$, and perform the operation: $a_i \\leftarrow a_i + 1$, $a_j \\leftarrow a_j - 1$ simultaneously.\n\nYour task is to compute the minimum number of operations needed to make the sum of the prefix sums of $a$ equal to the sum of the suffix sums of $a$.\n\nThat is, let $s_i=a_1+a_2+\\dots+a_i,t_i=a_i+a_{i+1}+\\dots+a_n$, you need to make  $s_1+s_2+\\dots+s_n$ equal to $t_1+t_2+\\dots+t_n$. \n\nNote that $a_i$ can become negative after several operations.", "inputFormat": "The first line contains a single  integer $n$.\n\nThe second line contains $n$ integers $a_1,a_2,\\dots,a_n$.", "outputFormat": "Print a single integer — the minimum number of operations needed.\n\nIf it is impossible to satisfy the condition within $10^{100}$ operations, print $-1$.", "hint": "This problem has subtasks.\n\n- Subtask 1 (30 points): $1 \\le n \\le 2$\n- Subtask 2 (30 points): $a_i = i$\n- Subtask 3 (5 points): $a_i = 1$\n- Subtask 4 (35 points): No additional constraints\n\nIt is guaranteed that for all testcases, $1 \\le n,a_i \\le 10^6$.", "locale": "en"}, "zh-CN": {"title": "求和", "background": "", "description": "给定长为 $n$ 的整数序列 $a$。\n\n您可以对这个序列进行若干次（可以为 $0$ 次）操作，每次操作形如：\n\n选定满足 $1\\le i,j\\le n$ 的下标 $i$ 和 $j$，将 $a_i$ 赋值为 $a_i+1$，同时将 $a_j$ 赋值为 $a_j-1$。$i$ 和 $j$ 不能相同。\n\n求使得前缀和之和等于后缀和之和的最小操作次数。\n\n也就是说，令 $s_i=a_1+a_2+\\dots+a_i,t_i=a_i+a_{i+1}+\\dots+a_n$，有 $s_1+s_2+\\dots+s_n=t_1+t_2+\\dots+t_n$。\n\n注意，$a_i$ 可以变为负数。", "inputFormat": "第一行一个整数 $n$。\n\n第二行用空格隔开的 $n$ 个整数，表示 $a$ 序列。", "outputFormat": "输出一行一个整数表示最小操作次数。\n\n若无解，输出 $-1$。", "hint": "**本题采用捆绑测试。**\n\n- Subtask 1（30 pts）：$1 \\le n \\le 2$；\n- Subtask 2（30 pts）：$a_i=i$；\n- Subtask 3（5 pts）：$a_i=1$；\n- Subtask 4（35 pts）：无特殊限制。\n\n对于所有数据，保证 $1 \\le n,a_i \\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P12606", "type": "P", "difficulty": 4, "samples": [["3 3 3", "1 2 1\n2 1 2\n3 3 3"]], "limits": {"time": [400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "Special Judge", "构造", "洛谷月赛"], "title": "碰碰车大战", "background": "[别样的碰碰车大战 2](https://www.luogu.com.cn/article/ne0xme6i)", "description": "我原本以为我恐吓了肚子的，肚子的应该躲在机房，不敢找我，可正当这时，我听见了音乐声，原来是我洛谷私信响了，一看，竟然是构造 $k$ 个 $m$ 元组 $(x_{i,1},x_{i,2},\\dots,x_{i,m})$，满足：\n\n- 任意一个 $m$ 元组的任意一个元素均为 $[1,n]$ 中的整数；\n- 任意两个 $m$ 元组删去相同位置的任意一对元素后得到的两个 $m-1$ 元组不相等，换句话说就是仍存在某一对位置相同的元素取值不相等。\n\n形式化地，需要满足：\n\n- $\\forall 1\\le i\\le k,1\\le j\\le m,x_{i,j}\\in [1,n] \\cap \\mathbb{Z^+}$；\n- $\\forall 1\\le i<j\\le k,1\\le p\\le m,\\exists 1\\le l\\le m,l\\neq p,x_{i,l}\\neq x_{j,l}$。\n", "inputFormat": "一行三个整数 $n,m$ 和 $k$，表示每个元素的取值上限，元组的大小和元组的个数。", "outputFormat": "输出 $k$ 行，每行表示一个 $m$ 元组。\n\n第 $i$ 行 $m$ 个整数，第 $j$ 个表示 $x_{i,j}$。", "hint": "本题输出规模巨大，推荐使用 I/O 优化。\n\n本题采取子任务依赖，未通过当前子任务依赖的子任务会导致当前子任务得零分。\n\n对于 $100\\%$ 的数据，$1\\le n\\le 10^9,2\\le m\\le 10^5,1\\le k \\le n^{m-1},k\\times m\\le 10^6$。\n\n|子任务|$n$|$m$|$k$|分值|依赖子任务|\n|:-------:|:-:|:-:|:-:|:--:|:-:|\n|$1$|$\\le 10^9$|$=2$|$\\le n$|$10$|-|\n|$2$|$\\le 10^9$|$\\le 10^5$|$\\le n$|$5$|$1$|\n|$3$|$\\le 10$|$=3$|-|$20$|-|\n|$4$|$\\le 10$|$\\le 10$|$\\le 10$|$20$|-|\n|$5$|$\\le 10^4$|$\\le 100$|-|$20$|$3,4$|\n|$6$|$\\le 10^9$|$\\le 10^5$|-|$25$|$1\\sim 5$|\n\n后来，他构造出了 $k$ 个 $m$ 元组，不知不觉的睡着了，我趁着这个好机会，使用宇宙射线远程轰击他的评测机让他爆零，挂的他不敢还手，对他的打击比 freopen 写错还大。", "locale": "zh-CN", "translations": {"en": {"title": "B. Car Crashing Challenge", "background": "The problem background is not important.", "description": "You are given integers $n$, $m$, and $k$.\n\nYour task is to construct $k$ tuples $(x_{i,1},x_{i,2},\\dots,x_{i,m})$ of size $m$ that satisfy the conditions below:\n\n- $x_{i,j}$ is an integer in $[1,n]$;\n- For any two tuples, after removing an element from the same position in both tuples, the resulting tuples (which have size $m-1$) are not equal. In other words, there still exists at least one position at which the remaining elements differ.\n\nFormally, you need to satisfy: \n\n- $\\forall 1\\le i\\le k,1\\le j\\le m,x_{i,j}\\in [1,n] \\cap \\mathbb{Z^+}$; \n- $\\forall 1\\le i<j\\le k,1\\le p\\le m,\\exists 1\\le l\\le m,l\\neq p,x_{i,l}\\neq x_{j,l}$. ", "inputFormat": "The first line contains three integers $n$, $m$, and $k$.", "outputFormat": "Print $k$ lines. Each line should contain $m$ integers — the $j$-th integer in the $i$-th line represents $x_{i,j}$.", "hint": "This problem involves a large output size, so I/O optimization is recommended.\n\nThe problem uses subtask dependencies: failing a prerequisite subtask will result in a score of zero for any subtask.\n\nIt is guaranteed that for all testcases, $1\\le n\\le 10^9,2\\le m\\le 10^5,1\\le k \\le n^{m-1},k\\times m\\le 10^6$。\n\n|#|$n$|$m$|$k$|Points|Depends On|\n|:-------:|:-:|:-:|:-:|:--:|:-:|\n|$1$|$\\le 10^9$|$=2$|$\\le n$|$10$|-|\n|$2$|$\\le 10^9$|$\\le 10^5$|$\\le n$|$5$|$1$|\n|$3$|$\\le 10$|$=3$|-|$20$|-|\n|$4$|$\\le 10$|$\\le 10$|$\\le 10$|$20$|-|\n|$5$|$\\le 10^4$|$\\le 100$|-|$20$|$3,4$|\n|$6$|$\\le 10^9$|$\\le 10^5$|-|$25$|$1\\sim 5$|", "locale": "en"}, "zh-CN": {"title": "碰碰车大战", "background": "[别样的碰碰车大战 2](https://www.luogu.com.cn/article/ne0xme6i)", "description": "我原本以为我恐吓了肚子的，肚子的应该躲在机房，不敢找我，可正当这时，我听见了音乐声，原来是我洛谷私信响了，一看，竟然是构造 $k$ 个 $m$ 元组 $(x_{i,1},x_{i,2},\\dots,x_{i,m})$，满足：\n\n- 任意一个 $m$ 元组的任意一个元素均为 $[1,n]$ 中的整数；\n- 任意两个 $m$ 元组删去相同位置的任意一对元素后得到的两个 $m-1$ 元组不相等，换句话说就是仍存在某一对位置相同的元素取值不相等。\n\n形式化地，需要满足：\n\n- $\\forall 1\\le i\\le k,1\\le j\\le m,x_{i,j}\\in [1,n] \\cap \\mathbb{Z^+}$；\n- $\\forall 1\\le i<j\\le k,1\\le p\\le m,\\exists 1\\le l\\le m,l\\neq p,x_{i,l}\\neq x_{j,l}$。\n", "inputFormat": "一行三个整数 $n,m$ 和 $k$，表示每个元素的取值上限，元组的大小和元组的个数。", "outputFormat": "输出 $k$ 行，每行表示一个 $m$ 元组。\n\n第 $i$ 行 $m$ 个整数，第 $j$ 个表示 $x_{i,j}$。", "hint": "本题输出规模巨大，推荐使用 I/O 优化。\n\n本题采取子任务依赖，未通过当前子任务依赖的子任务会导致当前子任务得零分。\n\n对于 $100\\%$ 的数据，$1\\le n\\le 10^9,2\\le m\\le 10^5,1\\le k \\le n^{m-1},k\\times m\\le 10^6$。\n\n|子任务|$n$|$m$|$k$|分值|依赖子任务|\n|:-------:|:-:|:-:|:-:|:--:|:-:|\n|$1$|$\\le 10^9$|$=2$|$\\le n$|$10$|-|\n|$2$|$\\le 10^9$|$\\le 10^5$|$\\le n$|$5$|$1$|\n|$3$|$\\le 10$|$=3$|-|$20$|-|\n|$4$|$\\le 10$|$\\le 10$|$\\le 10$|$20$|-|\n|$5$|$\\le 10^4$|$\\le 100$|-|$20$|$3,4$|\n|$6$|$\\le 10^9$|$\\le 10^5$|-|$25$|$1\\sim 5$|\n\n后来，他构造出了 $k$ 个 $m$ 元组，不知不觉的睡着了，我趁着这个好机会，使用宇宙射线远程轰击他的评测机让他爆零，挂的他不敢还手，对他的打击比 freopen 写错还大。", "locale": "zh-CN"}}}
{"pid": "P12607", "type": "P", "difficulty": 6, "samples": [["3\n?12", "3"], ["3\n???", "19"], ["4\n0211", "1"], ["10\n21??1?2??0", "161"], ["30\n???1????0????1???0????2???????", "744432249"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "洛谷月赛"], "title": "三叉求和", "background": "很久很久以前，小 A 在一棵无穷深的三叉树上摘苹果，这棵苹果树的根没有苹果，每个点三个儿子的苹果的数量分别是这个点的苹果数量的三倍加上 $0,1,2$，小 A 从根节点一直往下走了正好 $d$ 步并摘到了 $k$ 个苹果，可惜的是，小 A 只记得 $k$ 在三进制下的某些位，他想知道有多少种方式符合他的记忆。", "description": "有一棵深度无穷大的以 $0$ 为根的三叉树，节点 $i$ 的儿子分别是节点 $3i+1,3i+2,3i+3$。\n\n设节点 $i$ 的点权为 $a_i$。对于 $0\\le j\\le 2$，有 $a_{3i+j+1}=3\\times a_i+j$，特别的，$a_0=0$。\n\n你的任务是求从根出发，找长度 $=d$ 的简单路径，并使得该路径经过的所有点的点权和为 $k$。你需要求出所有合法路径的条数。\n\n然而 $k$ 并不唯一，$k$ 的三进制表示中仅有某些位是已知的，而其它的位将以字符 $\\tt ?$ 表示。你需要对所有可能的 $k$ 在上述问题中的答案求和，最后再对 $10^9+7$ 取模。\n", "inputFormat": "第一行一个整数 $d$。\n\n第二行一个长度为 $d$ 的字符串，表示三进制形式的 $k$。注意 $k$ 可能有前导零。", "outputFormat": "输出一行一个整数，表示你所求的答案。", "hint": "### 样例 #1 解释\n\n合法的路径有：\n- $[0,1,5,17]$\n- $[0,2,7,23]$\n- $[0,2,9,30]$\n\n对应的点权分别为：\n\n- $[0,0,1,4]$\n- $[0,1,3,10]$\n- $[0,1,5,17]$\n### 数据范围\n|测试点编号|$d$|特殊性质|\n|:----:|:----:|:----:|\n|$1\\sim 2$|$\\leq15$|-|\n|$3$|$\\leq50$|A|\n|$4$|$\\leq50$|B|\n|$5\\sim 8$|$\\leq50$|-|\n|$9\\sim 10$|$\\leq300$|A|\n|$11\\sim 12$|$\\leq300$|B|\n|$13\\sim 14$|$\\leq300$|-|\n|$15$|$\\leq2000$|A|\n|$16$|$\\leq2000$|B|\n|$17\\sim 20$|$\\leq2000$|-|\n\n特殊性质 A：保证 $k$ 中 $?$ 的数量 $\\leq 1$。\n\n特殊性质 B：保证所有的位置均为 $?$。\n\n对于 $100\\%$ 的数据，$1\\le d\\le 2000,0\\le k\\lt 3^{d+1}$。", "locale": "zh-CN", "translations": {"en": {"title": "C. Ternary Tree Traversal", "background": "The problem background is not important.", "description": "You are given an infinite ternary tree rooted at vertex $0$. The children of vertex $i$ are the vertices $3i+1$, $3i+2$, and $3i+3$.\n\nLet $a_i$ denote the value written on vertex $i$. It is guaranteed that for all $i \\ge 0$ and $0 \\le j \\le 2$, we have $a_{3i + j + 1} = 3 \\times a_i + j$.\n\nYour task is to count the number of simple paths with length equal to $d$ starting at vertex $0$ such that the sum of the values along the path equals $k$.\n\nHowever, $k$ is not completely specified: some digits in its ternary representation are replaced with the character $?$, indicating unknown digits.\n\nYour task is to compute the total number of such paths across all valid values of $k$, considering all ways to replace each $?$ with a digit from ${0,1,2}$.\n", "inputFormat": "The first line contains a single integer $d$.\n\nNext line contains the ternary representation of $k$. The ternary string may contain leading zeros and question marks, and its length is exactly $d$.", "outputFormat": "Print a single integer — the total number of valid simple paths modulo $10^9 + 7$.", "hint": "### Sample Explanation #1\n\nThe legal paths are: \n- $[0,1,5,17]$\n- $[0,2,7,23]$\n- $[0,2,9,30]$\n\nThese paths correspond to the following sequences of vertex values:\n\n- $[0,0,1,4]$\n- $[0,1,3,10]$\n- $[0,1,5,17]$\n### Data Range\n|TestCase #|$d$|Special Constraints|\n|:----:|:----:|:----:|\n|$1\\sim 2$|$\\leq15$|-|\n|$3$|$\\leq50$|A|\n|$4$|$\\leq50$|B|\n|$5\\sim 8$|$\\leq50$|-|\n|$9\\sim 10$|$\\leq300$|A|\n|$11\\sim 12$|$\\leq300$|B|\n|$13\\sim 14$|$\\leq300$|-|\n|$15$|$\\leq2000$|A|\n|$16$|$\\leq2000$|B|\n|$17\\sim 20$|$\\leq2000$|-|\n\nA: It is guaranteed that the number of $?$s in $k$ is no more than $1$.\n\nB: $k$ only contains $?$. \n\nIt is guaranteed that for all testcases, $1\\le d\\le 2000,0\\le k\\lt 3^{d+1}$.", "locale": "en"}, "zh-CN": {"title": "三叉求和", "background": "很久很久以前，小 A 在一棵无穷深的三叉树上摘苹果，这棵苹果树的根没有苹果，每个点三个儿子的苹果的数量分别是这个点的苹果数量的三倍加上 $0,1,2$，小 A 从根节点一直往下走了正好 $d$ 步并摘到了 $k$ 个苹果，可惜的是，小 A 只记得 $k$ 在三进制下的某些位，他想知道有多少种方式符合他的记忆。", "description": "有一棵深度无穷大的以 $0$ 为根的三叉树，节点 $i$ 的儿子分别是节点 $3i+1,3i+2,3i+3$。\n\n设节点 $i$ 的点权为 $a_i$。对于 $0\\le j\\le 2$，有 $a_{3i+j+1}=3\\times a_i+j$，特别的，$a_0=0$。\n\n你的任务是求从根出发，找长度 $=d$ 的简单路径，并使得该路径经过的所有点的点权和为 $k$。你需要求出所有合法路径的条数。\n\n然而 $k$ 并不唯一，$k$ 的三进制表示中仅有某些位是已知的，而其它的位将以字符 $\\tt ?$ 表示。你需要对所有可能的 $k$ 在上述问题中的答案求和，最后再对 $10^9+7$ 取模。\n", "inputFormat": "第一行一个整数 $d$。\n\n第二行一个长度为 $d$ 的字符串，表示三进制形式的 $k$。注意 $k$ 可能有前导零。", "outputFormat": "输出一行一个整数，表示你所求的答案。", "hint": "### 样例 #1 解释\n\n合法的路径有：\n- $[0,1,5,17]$\n- $[0,2,7,23]$\n- $[0,2,9,30]$\n\n对应的点权分别为：\n\n- $[0,0,1,4]$\n- $[0,1,3,10]$\n- $[0,1,5,17]$\n### 数据范围\n|测试点编号|$d$|特殊性质|\n|:----:|:----:|:----:|\n|$1\\sim 2$|$\\leq15$|-|\n|$3$|$\\leq50$|A|\n|$4$|$\\leq50$|B|\n|$5\\sim 8$|$\\leq50$|-|\n|$9\\sim 10$|$\\leq300$|A|\n|$11\\sim 12$|$\\leq300$|B|\n|$13\\sim 14$|$\\leq300$|-|\n|$15$|$\\leq2000$|A|\n|$16$|$\\leq2000$|B|\n|$17\\sim 20$|$\\leq2000$|-|\n\n特殊性质 A：保证 $k$ 中 $?$ 的数量 $\\leq 1$。\n\n特殊性质 B：保证所有的位置均为 $?$。\n\n对于 $100\\%$ 的数据，$1\\le d\\le 2000,0\\le k\\lt 3^{d+1}$。", "locale": "zh-CN"}}}
{"pid": "P12608", "type": "P", "difficulty": 7, "samples": [["5\n9\n1 1 1 2 2 2 3 3 3\n4\n1 1 2 2\n5\n1 1 2 2 1\n10\n1 2 2 1 1 2 3 2 3 3\n12\n1 1 2 3 3 2 1 2 3 3 2 1", "25\n8\n11\n26\n34"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "分治", "哈希 hashing", "随机化", "洛谷月赛", "哈希表"], "title": "骷髅打金服", "background": "下图是一个经典算法的错误实现。", "description": "长为 $n$ 的序列 $a$ 的一个非空连续子段是合法的，当且仅当其中**所有出现过的元素**出现次数全相等。\n\n求合法的非空子段个数。两个子段不同当且仅当它们在原序列中的出现位置不同。", "inputFormat": "第一行一个整数 $T$，表示数据组数。\n\n接下来 $T$ 组数据，每组数据格式如下：\n\n第一行一个整数 $n$。\n\n接下来一行 $n$ 个整数，描述序列 $a$。", "outputFormat": "$T$ 行，每行一个整数，表示一组数据的答案。", "hint": "### 样例解释 #1\n\n对于第三组数据，合法的连续非空子序列如下：\n\n- $[1,1]$\n- $[1,2]$\n- $[1,4]$\n- $[2,2]$\n- $[2,3]$\n- $[2,5]$\n- $[3,3]$\n- $[3,4]$\n- $[4,4]$\n- $[4,5]$\n- $[5,5]$\n\n### 数据范围\n\n本题采取子任务依赖，未通过当前子任务依赖的子任务会导致当前子任务得零分。\n\n对于 $100\\%$ 的数据，$T\\ge 1,1\\le n,\\sum n\\le 10^6,1\\le a_i\\le n$。\n\n|子任务|$n\\le$|$\\sum n\\le$|特殊性质|分值|时限|依赖子任务|\n|:-------:|:-:|:-:|:-----:|:--:|:--:|:-:|\n|$1$|$100$|$1000$|-|$10$|1s| |\n|$2$|$8000$|$4\\times 10^4$|-|$10$|1s|$1$|\n|$3$|-|$2\\times 10^5$|$1\\le a_i \\le 4$|$20$|1s| |\n|$4$|-|$2\\times 10^5$|$a$ 的每个元素在 $[1,n]$ 均匀随机|$10$|1s| |\n|$5$|-|$2\\times 10^5$|$1\\le a_i\\le 14$|$20$|1s|$3$|\n|$6$|-|$2\\times 10^5$|-|$10$|1s|$1\\sim 5$|\n|$7$|-|$5\\times 10^5$|-|$10$|2s|$1\\sim 6$|\n|$8$|-|$10^6$|-|$10$|3s|$1\\sim 7$|\n", "locale": "zh-CN", "translations": {"en": {"title": "D. Goners' Gold-Grinding Garage", "background": "The problem background is not important.", "description": "You are given an integer sequence of size $n$.\n\nA **non-empty contiguous** subsequence of $a$ is called beautiful if and only if every element appearing in it occurs the same number of times.\n\nYour task is to compute the number of beautiful contiguous subsequences. The same beautiful subsequence appearing at different positions is counted multiple times.", "inputFormat": "The first line contains a single integer $t$ — the number of test cases.\n\nFor each test case, the first line contains an integer $n$.\n\nThe second line contains $n$ integers $a_1,a_2,\\dots,a_n$.", "outputFormat": "For each test case, print a single integer — the number of beautiful contiguous subsequences in that test case.", "hint": "### Sample Explanation\n\nIn the third example, the intervals representing all beautiful subsequences are:\n\n- $[1,1]$\n- $[1,2]$\n- $[1,4]$\n- $[2,2]$\n- $[2,3]$\n- $[2,5]$\n- $[3,3]$\n- $[3,4]$\n- $[4,4]$\n- $[4,5]$\n- $[5,5]$\n\n### Data Range\n\nThe problem uses subtask dependencies: failing a prerequisite subtask will result in a score of zero for any subtask.\n\nIt is guaranteed that for all testcases, $T\\ge 1,1\\le n,\\sum n\\le 10^6,1\\le a_i\\le n$。\n\n|#|$n\\le$|$\\sum n\\le\\ $|Special Constraints|Points|Time Limit|Depends On|\n|:-------:|:-:|:-:|:-----:|:--:|:--:|:-:|\n|$1$|$100$|$1000$|-|$10$|1s| |\n|$2$|$8000$|$4\\times 10^4$|-|$10$|1s|$1$|\n|$3$|-|$2\\times 10^5$|$1\\le a_i \\le 4$|$20$|1s| |\n|$4$|-|$2\\times 10^5$|all $a_i$s are generated uniformly random from $[1,n]$|$10$|1s| |\n|$5$|-|$2\\times 10^5$|$1\\le a_i\\le 14$|$20$|1s|$3$|\n|$6$|-|$2\\times 10^5$|-|$10$|1s|$1\\sim 5$|\n|$7$|-|$5\\times 10^5$|-|$10$|2s|$1\\sim 6$|\n|$8$|-|$10^6$|-|$10$|3s|$1\\sim 7$|\n", "locale": "en"}, "zh-CN": {"title": "骷髅打金服", "background": "下图是一个经典算法的错误实现。", "description": "长为 $n$ 的序列 $a$ 的一个非空连续子段是合法的，当且仅当其中**所有出现过的元素**出现次数全相等。\n\n求合法的非空子段个数。两个子段不同当且仅当它们在原序列中的出现位置不同。", "inputFormat": "第一行一个整数 $T$，表示数据组数。\n\n接下来 $T$ 组数据，每组数据格式如下：\n\n第一行一个整数 $n$。\n\n接下来一行 $n$ 个整数，描述序列 $a$。", "outputFormat": "$T$ 行，每行一个整数，表示一组数据的答案。", "hint": "### 样例解释 #1\n\n对于第三组数据，合法的连续非空子序列如下：\n\n- $[1,1]$\n- $[1,2]$\n- $[1,4]$\n- $[2,2]$\n- $[2,3]$\n- $[2,5]$\n- $[3,3]$\n- $[3,4]$\n- $[4,4]$\n- $[4,5]$\n- $[5,5]$\n\n### 数据范围\n\n本题采取子任务依赖，未通过当前子任务依赖的子任务会导致当前子任务得零分。\n\n对于 $100\\%$ 的数据，$T\\ge 1,1\\le n,\\sum n\\le 10^6,1\\le a_i\\le n$。\n\n|子任务|$n\\le$|$\\sum n\\le$|特殊性质|分值|时限|依赖子任务|\n|:-------:|:-:|:-:|:-----:|:--:|:--:|:-:|\n|$1$|$100$|$1000$|-|$10$|1s| |\n|$2$|$8000$|$4\\times 10^4$|-|$10$|1s|$1$|\n|$3$|-|$2\\times 10^5$|$1\\le a_i \\le 4$|$20$|1s| |\n|$4$|-|$2\\times 10^5$|$a$ 的每个元素在 $[1,n]$ 均匀随机|$10$|1s| |\n|$5$|-|$2\\times 10^5$|$1\\le a_i\\le 14$|$20$|1s|$3$|\n|$6$|-|$2\\times 10^5$|-|$10$|1s|$1\\sim 5$|\n|$7$|-|$5\\times 10^5$|-|$10$|2s|$1\\sim 6$|\n|$8$|-|$10^6$|-|$10$|3s|$1\\sim 7$|\n", "locale": "zh-CN"}}}
{"pid": "P12609", "type": "P", "difficulty": 1, "samples": [["14\n3\n2", "no"], ["12\n4\n3", "yes"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "CCC（加拿大）"], "title": "[CCC 2025 Junior] Roller Coaster Ride", "background": "Score: 15.", "description": "You are spending the day at the CEMC's funfair. One of the rides at the funfair is a roller coaster which has one train with a number of cars. Each car holds the same number of people.\n\nWhen you arrive at the roller coaster, you see that there is a line. Your job is to determine whether or not you will be on the next train ride, assuming that every car is fully occupied for every ride.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/21u2ygag.png)", "inputFormat": "The first line of input contains a positive integer, $N$, representing your place in line. For example, if $N$ is $5$ then you are the fifth person in line.\n\nThe second line contains a positive integer, $C$, representing the number of cars the train has.\n\nThe third line contains a positive integer, $P$, representing the number of people a single car\nholds.", "outputFormat": "Output either `yes` or `no`, indicating whether or not you will be on the next train ride.", "hint": "**Explanation of Output for Sample Input 1**\n\nThe train has 3 cars and each car holds 2 people. Therefore, 6 people can ride the next train. Since you are the 14th person in line, you will not be on the next train ride.\n\n**Explanation of Output for Sample Input 2**\n\nThe train has 4 cars and each car holds 3 people. Therefore, 12 people can ride the next train. Since you are the 12th person in line, you will be on the next train ride.", "locale": "en", "translations": {"en": {"title": "[CCC 2025 Junior] Roller Coaster Ride", "background": "Score: 15.", "description": "You are spending the day at the CEMC's funfair. One of the rides at the funfair is a roller coaster which has one train with a number of cars. Each car holds the same number of people.\n\nWhen you arrive at the roller coaster, you see that there is a line. Your job is to determine whether or not you will be on the next train ride, assuming that every car is fully occupied for every ride.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/21u2ygag.png)", "inputFormat": "The first line of input contains a positive integer, $N$, representing your place in line. For example, if $N$ is $5$ then you are the fifth person in line.\n\nThe second line contains a positive integer, $C$, representing the number of cars the train has.\n\nThe third line contains a positive integer, $P$, representing the number of people a single car\nholds.", "outputFormat": "Output either `yes` or `no`, indicating whether or not you will be on the next train ride.", "hint": "**Explanation of Output for Sample Input 1**\n\nThe train has 3 cars and each car holds 2 people. Therefore, 6 people can ride the next train. Since you are the 14th person in line, you will not be on the next train ride.\n\n**Explanation of Output for Sample Input 2**\n\nThe train has 4 cars and each car holds 3 people. Therefore, 12 people can ride the next train. Since you are the 12th person in line, you will be on the next train ride.", "locale": "en"}, "zh-CN": {"title": "[CCC 2025 Junior] Roller Coaster Ride", "background": "本题满分 15 分。", "description": "你正在 CEMC 游乐场度过一天。游乐场中的一个项目是一列拥有若干车厢的过山车，每节车厢可容纳相同数量的乘客。\n\n当你到达过山车时，发现已经排起了长队。你的任务是判断自己是否能登上下一班过山车，假设每班过山车的所有车厢都会满载运行。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/21u2ygag.png)\n", "inputFormat": "第一行输入一个正整数 $N$，表示你在队伍中的位置。例如，若 $N$ 为 $5$，则你是队伍中的第五人。\n\n第二行输入一个正整数 $C$，表示过山车的车厢数量。\n\n第三行输入一个正整数 $P$，表示单节车厢可容纳的乘客数量。\n", "outputFormat": "输出 `yes` 或 `no`，表示你是否能登上下一班过山车。\n", "hint": "**样例输入 1 的输出解释**\n\n过山车有 3 节车厢，每节可容纳 2 人。因此下一班过山车可承载 $3 \\times 2 = 6$ 人。由于你是队伍中的第 14 人，故无法登上下一班。\n\n**样例输入 2 的输出解释**\n\n过山车有 4 节车厢，每节可容纳 3 人。因此下一班过山车可承载 $4 \\times 3 = 12$ 人。由于你是队伍中的第 12 人，故可以登上下一班。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12610", "type": "P", "difficulty": 1, "samples": [["10\n3\n+\n24\n-\n6\n-\n12", "16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "CCC（加拿大）"], "title": "[CCC 2025 Junior] Donut Shop", "background": "Score: 15.", "description": "The owner of a donut shop spends the day baking and selling donuts.\n\nGiven the events that happen over the course of the day, your job is to determine the number of donuts remaining when the shop closes.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3n3cysdu.png)", "inputFormat": "The first line of input contains a non-negative integer, $D$, representing the number of donuts available when the shop first opens.\n\nThe second line contains a positive integer, $E$, representing the number of events that happen over the course of the day. The next $E$ pairs of input lines describe these events. The first line in the pair contains either the $+$ (plus) symbol, indicating that donuts have been baked, or the $-$ (minus) symbol, indicating that donuts have been sold. The second line in the pair contains a positive integer, $Q$, representing the quantity of donuts associated with the event.\n\nFor each sale of donuts, the value of $Q$ will be less than or equal to the number of donuts\navailable at that time.", "outputFormat": "Output the non-negative integer, $R$, which is the number of donuts remaining when the shop closes.", "hint": "**Explanation of Output for Sample Input**\n\nThe shop opened with $10$ donuts and there were $3$ events during the day. The owner first baked $24$ donuts. Then the owner sold $6$ donuts, followed by another $12$. The number of donuts remaining is $10 + 24 - 6 - 12 = 16$.", "locale": "en", "translations": {"en": {"title": "[CCC 2025 Junior] Donut Shop", "background": "Score: 15.", "description": "The owner of a donut shop spends the day baking and selling donuts.\n\nGiven the events that happen over the course of the day, your job is to determine the number of donuts remaining when the shop closes.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3n3cysdu.png)", "inputFormat": "The first line of input contains a non-negative integer, $D$, representing the number of donuts available when the shop first opens.\n\nThe second line contains a positive integer, $E$, representing the number of events that happen over the course of the day. The next $E$ pairs of input lines describe these events. The first line in the pair contains either the $+$ (plus) symbol, indicating that donuts have been baked, or the $-$ (minus) symbol, indicating that donuts have been sold. The second line in the pair contains a positive integer, $Q$, representing the quantity of donuts associated with the event.\n\nFor each sale of donuts, the value of $Q$ will be less than or equal to the number of donuts\navailable at that time.", "outputFormat": "Output the non-negative integer, $R$, which is the number of donuts remaining when the shop closes.", "hint": "**Explanation of Output for Sample Input**\n\nThe shop opened with $10$ donuts and there were $3$ events during the day. The owner first baked $24$ donuts. Then the owner sold $6$ donuts, followed by another $12$. The number of donuts remaining is $10 + 24 - 6 - 12 = 16$.", "locale": "en"}, "zh-CN": {"title": "[CCC 2025 Junior] Donut Shop", "background": "本题满分 15 分。", "description": "一家甜甜圈商店的店主整天都在烘焙和销售甜甜圈。\n\n根据一天中发生的事件，你的任务是计算商店关门时剩余的甜甜圈数量。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3n3cysdu.png)", "inputFormat": "第一行输入一个非负整数 $D$，表示商店开门时已有的甜甜圈数量。\n\n第二行输入一个正整数 $E$，表示一天中发生的事件数量。接下来的 $E$ 组输入行描述这些事件。每组的第一行包含一个 $+$（加号）符号，表示烘焙了甜甜圈；或一个 $-$（减号）符号，表示售出了甜甜圈。每组的第二行包含一个正整数 $Q$，表示该事件涉及的甜甜圈数量。\n\n对于每次销售事件，$Q$ 的值不会超过当时可用的甜甜圈数量。", "outputFormat": "输出一个非负整数 $R$，表示商店关门时剩余的甜甜圈数量。\n", "hint": "**样例输入 1 的输出解释**\n\n商店开门时有 $10$ 个甜甜圈，当天发生了 $3$ 个事件。店主首先烘焙了 $24$ 个甜甜圈，然后售出了 $6$ 个，接着又售出了 $12$ 个。剩余的甜甜圈数量为 $10 + 24 - 6 - 12 = 16$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
