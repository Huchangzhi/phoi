{"pid": "P12183", "type": "P", "difficulty": 6, "samples": [["3", "1 2 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "Special Judge", "O2优化", "构造"], "title": "DerrickLo's Milk Loong (UBC002F)", "background": "", "description": "给定正整数 $n$，构造 $n$ 个正整数 $a_1,a_2,\\cdots,a_n$，使得 $\\displaystyle\\sum_{i=1}^n a_i=\\operatorname{lcm}(a_1,a_2,\\cdots,a_n)$（其中 $\\operatorname{lcm}$ 为最小公倍数运算），并且这组数的极差是所有构造的极差中最小的。极差指一组数当中的最大值减最小值。\n\n**并且，你构造的这 $n$ 个数的最小公倍数不得超过 $10^{12}$。否则，SPJ 可能出现未定义行为。**", "inputFormat": "一个整数 $n$。", "outputFormat": "$n$ 个正整数，表示你构造的答案（你可以用任意顺序输出），并用空格分隔。\n\n**请勿在行末输出多余的空格，否则你的输出可能被判为错误。**", "hint": "#### 样例说明\n\n容易证明，$n=3$ 时不存在极差小于 $2$ 的构造方案，因此输出一组极差为 $2$ 的构造符合题意。另外，`1 3 2`，`3 2 1` 等也符合条件。\n\n#### 数据范围\n\n$3\\le n\\le 5\\times 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "DerrickLo's Milk Loong (UBC002F)", "background": "", "description": "You are given an integer $n$, print $n$ integers $a_1,a_2,\\cdots,a_n$ that satisfies $\\displaystyle\\sum_{i=1}^n a_i=\\operatorname{lcm}(a_1,a_2,\\cdots,a_n)$. You should also minimize $(\\max_{i=1}^n a_i)-(\\min_{i=1}^n a_i)$. $(1\\le n\\le 5\\times 10^6)$.\n\n**Note that the least common multiple of the $n$ integers you print should not exceed $10^{12}$, or your answer will be judged as a wrong answer.**", "inputFormat": "The first line contains one integer $n$.", "outputFormat": "Print your answer in any order seperated by space.\n\n**Do not print any spaces in the end of the line, or your answer will be judged as a wrong answer.**", "hint": "It can be proved that the range cannot be less that $2$ when $n=3$. Thus, this answer is acceptable. Besides, `1 3 2` , `3 2 1` are also acceptable answers.", "locale": "en"}, "zh-CN": {"title": "DerrickLo's Milk Loong (UBC002F)", "background": "", "description": "给定正整数 $n$，构造 $n$ 个正整数 $a_1,a_2,\\cdots,a_n$，使得 $\\displaystyle\\sum_{i=1}^n a_i=\\operatorname{lcm}(a_1,a_2,\\cdots,a_n)$（其中 $\\operatorname{lcm}$ 为最小公倍数运算），并且这组数的极差是所有构造的极差中最小的。极差指一组数当中的最大值减最小值。\n\n**并且，你构造的这 $n$ 个数的最小公倍数不得超过 $10^{12}$。否则，SPJ 可能出现未定义行为。**", "inputFormat": "一个整数 $n$。", "outputFormat": "$n$ 个正整数，表示你构造的答案（你可以用任意顺序输出），并用空格分隔。\n\n**请勿在行末输出多余的空格，否则你的输出可能被判为错误。**", "hint": "#### 样例说明\n\n容易证明，$n=3$ 时不存在极差小于 $2$ 的构造方案，因此输出一组极差为 $2$ 的构造符合题意。另外，`1 3 2`，`3 2 1` 等也符合条件。\n\n#### 数据范围\n\n$3\\le n\\le 5\\times 10^6$。", "locale": "zh-CN"}}}
{"pid": "P12184", "type": "P", "difficulty": 2, "samples": [], "limits": {"time": [10000], "memory": [2097152]}, "tags": ["2025", "枚举", "蓝桥杯省赛"], "title": "[蓝桥杯 2025 省 Python A] 偏蓝", "background": "本站蓝桥杯 2025 省赛测试数据均为洛谷自造，与官方数据可能存在差异，仅供学习参考。", "description": "小蓝特别喜欢蓝色。最近，小蓝学习了颜色在计算机中的一种表示方法：用三个 $0$ 至 $255$ 之间的整数（包含 $0$ 和 $255$）分别表示颜色的红、绿、蓝三个分量。\n\n在这种颜色的表示方法下，小蓝定义了一种颜色是偏蓝的，是指蓝色分量大于红色分量，且蓝色分量大于绿色分量。例如，红、绿、蓝分别为 $10$、$10$、$11$ 时是偏蓝的；红、绿、蓝分别为 $100$、$200$、$200$ 时不是偏蓝的。\n\n小蓝想知道，有多少种不同的颜色是偏蓝的。两种颜色如果在红、绿、蓝中至少有一个分量值不同，就认为是不同的。", "inputFormat": "", "outputFormat": "这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只需要**编写一个程序输出这个整数**，输出多余的内容将无法得分。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2025 省 Python A] 偏蓝", "background": "本站蓝桥杯 2025 省赛测试数据均为洛谷自造，与官方数据可能存在差异，仅供学习参考。", "description": "小蓝特别喜欢蓝色。最近，小蓝学习了颜色在计算机中的一种表示方法：用三个 $0$ 至 $255$ 之间的整数（包含 $0$ 和 $255$）分别表示颜色的红、绿、蓝三个分量。\n\n在这种颜色的表示方法下，小蓝定义了一种颜色是偏蓝的，是指蓝色分量大于红色分量，且蓝色分量大于绿色分量。例如，红、绿、蓝分别为 $10$、$10$、$11$ 时是偏蓝的；红、绿、蓝分别为 $100$、$200$、$200$ 时不是偏蓝的。\n\n小蓝想知道，有多少种不同的颜色是偏蓝的。两种颜色如果在红、绿、蓝中至少有一个分量值不同，就认为是不同的。", "inputFormat": "", "outputFormat": "这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只需要**编写一个程序输出这个整数**，输出多余的内容将无法得分。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12185", "type": "P", "difficulty": 4, "samples": [], "limits": {"time": [3000], "memory": [524288]}, "tags": ["数学", "2025", "枚举", "组合数学", "蓝桥杯省赛"], "title": "[蓝桥杯 2025 省 Python A/研究生组] IPv6", "background": "", "description": "小蓝最近在学习网络工程相关的知识。他最近学习到，IPv6 地址本质上是一个 $128$ 位的二进制数，而字符串形式的 IPv6 地址是由被冒号分开的八段 $16$ 进制数组成的，例如, 下面每行是一个字符串形式的 IPv6 地址:\n\n```plain\n0000:0000:0000:0000:0000:0000:0000:0000\n0000:0001:0000:0000:0000:0001:0000:0000\n0000:0001:00ab:0000:0023:0000:0a00:0e00\n0000:0000:00ab:0000:000a:0001:0a00:0e00\n0000:0000:00ab:0000:0000:0001:0a00:0e00\n```\n\n其中，每一段最长 $4$ 位，且每一段的前导零都可以去掉 (如果 $4$ 位都为 $0$ 需要写成 $0$ )。\n\n另外，IPv6 地址还可以将其中相邻的值为 $0$ 的段合并压缩起来，用两个冒号来表示，不过只能压缩一段。\n\n例如上述地址最短的压缩后的形式分别为：\n\n```plain\n:: \n0:1::1:0:0\n0:1:ab::23:0:a00:e00\n::ab:0:a:1:a00:e00\n0:0:ab::1:a00:e00\n```\n\n小蓝想知道，所有 IPv6 地址的最短压缩形式的长度的和为多少？由于答案很大 (甚至超过了 $128$ 位二进制整数的范围)，请填写答案时填写这个总和除以 $10^{9} + 7$ 的余数。", "inputFormat": "", "outputFormat": "这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只需要**编写一个程序输出这个整数**，输出多余的内容将无法得分。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2025 省 Python A/研究生组] IPv6", "background": "", "description": "小蓝最近在学习网络工程相关的知识。他最近学习到，IPv6 地址本质上是一个 $128$ 位的二进制数，而字符串形式的 IPv6 地址是由被冒号分开的八段 $16$ 进制数组成的，例如, 下面每行是一个字符串形式的 IPv6 地址:\n\n```plain\n0000:0000:0000:0000:0000:0000:0000:0000\n0000:0001:0000:0000:0000:0001:0000:0000\n0000:0001:00ab:0000:0023:0000:0a00:0e00\n0000:0000:00ab:0000:000a:0001:0a00:0e00\n0000:0000:00ab:0000:0000:0001:0a00:0e00\n```\n\n其中，每一段最长 $4$ 位，且每一段的前导零都可以去掉 (如果 $4$ 位都为 $0$ 需要写成 $0$ )。\n\n另外，IPv6 地址还可以将其中相邻的值为 $0$ 的段合并压缩起来，用两个冒号来表示，不过只能压缩一段。\n\n例如上述地址最短的压缩后的形式分别为：\n\n```plain\n:: \n0:1::1:0:0\n0:1:ab::23:0:a00:e00\n::ab:0:a:1:a00:e00\n0:0:ab::1:a00:e00\n```\n\n小蓝想知道，所有 IPv6 地址的最短压缩形式的长度的和为多少？由于答案很大 (甚至超过了 $128$ 位二进制整数的范围)，请填写答案时填写这个总和除以 $10^{9} + 7$ 的余数。", "inputFormat": "", "outputFormat": "这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只需要**编写一个程序输出这个整数**，输出多余的内容将无法得分。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12186", "type": "P", "difficulty": 5, "samples": [["3", "30"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "高精度", "2025", "排序", "蓝桥杯省赛"], "title": "[蓝桥杯 2025 省 Python A/研究生组] 最大数字", "background": "", "description": "我们有 $n$ 个连续的整数 $1, 2, 3, \\cdots, n$，可以自由排列它们的顺序。\n\n然后，我们把这些数字转换成二进制表示，按照排列顺序拼接形成一个新的二进制数。\n\n我们的目标是让这个二进制数的值最大，并输出这个二进制对应的十进制表示。", "inputFormat": "输入一行包含一个正整数 $n$。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "### 评测用例规模与约定\n\n- 对于 $20\\%$ 的评测用例，$1 \\leq n \\leq 10$；\n- 对于 $40\\%$ 的评测用例，$1 \\leq n \\leq 100$；\n- 对于 $60\\%$ 的评测用例，$1 \\leq n \\leq 500$；\n- 对于 $80\\%$ 的评测用例，$1 \\leq n \\leq 1000$；\n- 对于所有评测用例，$1 \\leq n \\leq 10000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2025 省 Python A/研究生组] 最大数字", "background": "", "description": "我们有 $n$ 个连续的整数 $1, 2, 3, \\cdots, n$，可以自由排列它们的顺序。\n\n然后，我们把这些数字转换成二进制表示，按照排列顺序拼接形成一个新的二进制数。\n\n我们的目标是让这个二进制数的值最大，并输出这个二进制对应的十进制表示。", "inputFormat": "输入一行包含一个正整数 $n$。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "### 评测用例规模与约定\n\n- 对于 $20\\%$ 的评测用例，$1 \\leq n \\leq 10$；\n- 对于 $40\\%$ 的评测用例，$1 \\leq n \\leq 100$；\n- 对于 $60\\%$ 的评测用例，$1 \\leq n \\leq 500$；\n- 对于 $80\\%$ 的评测用例，$1 \\leq n \\leq 1000$；\n- 对于所有评测用例，$1 \\leq n \\leq 10000$。", "locale": "zh-CN"}}}
{"pid": "P12187", "type": "P", "difficulty": 4, "samples": [["3 5 1\n99 9 1\n3 4 99\n1 2 190", "201"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "堆", "2025", "蓝桥杯省赛"], "title": "[蓝桥杯 2025 省 Python A/Java A/研究生组] 原料采购", "background": "", "description": "小蓝负责一家工厂的原料采购。\n\n工厂有一辆运货卡车，其容量为 $m$。\n\n工厂附近的采购点都在同一条路的同一方向上，一共有 $n$ 个，每个采购点和工厂的距离各不相同。其中，第 $i$ 个采购点的价格为 $a_i$, 库存为 $b_i$, 距离为 $c_i$。\n\n卡车每行驶一单位长度的路径就需要额外花费 $o$。（返程没有花费，你也可以认为 $o$ 实际是行驶两单位长度的花费）\n\n请计算将卡车装满最少需要花费多少钱，如果没有任何方案可以装满请输出 $-1$。", "inputFormat": "输入的第一行包含三个正整数 $n, m, o$，相邻整数之间使用一个空格分隔。\n\n接下来 $n$ 行，每行包含三个正整数 $a_i, b_i, c_i$ 表示一个采购点，相邻整数之间使用一个空格分隔。", "outputFormat": "输出一行包含一个整数表示答案，即装满卡车所需的最小花费。", "hint": "### 评测用例规模与约定\n\n- 对于 $40\\%$ 的评测用例，$n \\leq 5000$, $m \\leq 50000$;\n- 对于 $60\\%$ 的评测用例，$m \\leq 10^5$;\n- 对于所有评测用例，$1 \\leq n \\leq 10^5$, $1 \\leq m, o \\leq 10^9$, $1 \\leq a_i, b_i, c_i \\leq 10^9$, 保证对于 $i > 1$, 一定有 $c_{i-1} < c_i$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2025 省 Python A/Java A/研究生组] 原料采购", "background": "", "description": "小蓝负责一家工厂的原料采购。\n\n工厂有一辆运货卡车，其容量为 $m$。\n\n工厂附近的采购点都在同一条路的同一方向上，一共有 $n$ 个，每个采购点和工厂的距离各不相同。其中，第 $i$ 个采购点的价格为 $a_i$, 库存为 $b_i$, 距离为 $c_i$。\n\n卡车每行驶一单位长度的路径就需要额外花费 $o$。（返程没有花费，你也可以认为 $o$ 实际是行驶两单位长度的花费）\n\n请计算将卡车装满最少需要花费多少钱，如果没有任何方案可以装满请输出 $-1$。", "inputFormat": "输入的第一行包含三个正整数 $n, m, o$，相邻整数之间使用一个空格分隔。\n\n接下来 $n$ 行，每行包含三个正整数 $a_i, b_i, c_i$ 表示一个采购点，相邻整数之间使用一个空格分隔。", "outputFormat": "输出一行包含一个整数表示答案，即装满卡车所需的最小花费。", "hint": "### 评测用例规模与约定\n\n- 对于 $40\\%$ 的评测用例，$n \\leq 5000$, $m \\leq 50000$;\n- 对于 $60\\%$ 的评测用例，$m \\leq 10^5$;\n- 对于所有评测用例，$1 \\leq n \\leq 10^5$, $1 \\leq m, o \\leq 10^9$, $1 \\leq a_i, b_i, c_i \\leq 10^9$, 保证对于 $i > 1$, 一定有 $c_{i-1} < c_i$。", "locale": "zh-CN"}}}
{"pid": "P12188", "type": "P", "difficulty": 2, "samples": [["2\n5 7\n2", "20 63"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2025", "进制", "蓝桥杯省赛"], "title": "[蓝桥杯 2025 省 Java A/研究生组] 变换数组", "background": "", "description": "输入一个数组 $a$，包含有 $n$ 个元素 $a_1, a_2, \\cdots, a_n$。对这个数组进行 $m$ 次变换，每次变换会将数组 $a$ 中的每个元素 $a_i$ 转换为 $a_i \\cdot \\text{bitCount}(a_i)$。其中 $\\text{bitCount}(x)$ 表示数字 $x$ 的二进制表示中 $1$ 出现的次数，例如 $\\text{bitCount}(3) = 2$，因为 $3$ 的二进制表示为 $11$，其中 $1$ 出现了两次。\n\n请输出变换之后的数组内容。", "inputFormat": "输入的第一行包含一个正整数 $n$，表示数组 $a$ 中的元素个数。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\cdots, a_n$，相邻整数之间使用一个空格分隔。\n\n第三行包含一个整数 $m$，表示变换次数。", "outputFormat": "输出一行，包含 $n$ 个整数，相邻整数之间使用一个空格分隔，表示变换之后得到的数组 $a$。", "hint": "### 样例说明\n\n- $5 = (101)_2$，$7 = (111)_2$，第一次变化后 $a = [10, 21]$。\n- $10 = (1010)_2$，$21 = (10101)_2$，第二次变换后 $a = [20, 63]$。\n\n### 评测用例规模与约定\n\n- 对于 $30\\%$ 的评测用例，$1 \\leq n \\leq 10$；\n- 对于 $60\\%$ 的评测用例，$1 \\leq n \\leq 100$；\n- 对于所有评测用例，$1 \\leq n \\leq 10^3$，$0 \\leq m \\leq 5$，$0 \\leq a_i \\leq 1000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2025 省 Java A/研究生组] 变换数组", "background": "", "description": "输入一个数组 $a$，包含有 $n$ 个元素 $a_1, a_2, \\cdots, a_n$。对这个数组进行 $m$ 次变换，每次变换会将数组 $a$ 中的每个元素 $a_i$ 转换为 $a_i \\cdot \\text{bitCount}(a_i)$。其中 $\\text{bitCount}(x)$ 表示数字 $x$ 的二进制表示中 $1$ 出现的次数，例如 $\\text{bitCount}(3) = 2$，因为 $3$ 的二进制表示为 $11$，其中 $1$ 出现了两次。\n\n请输出变换之后的数组内容。", "inputFormat": "输入的第一行包含一个正整数 $n$，表示数组 $a$ 中的元素个数。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\cdots, a_n$，相邻整数之间使用一个空格分隔。\n\n第三行包含一个整数 $m$，表示变换次数。", "outputFormat": "输出一行，包含 $n$ 个整数，相邻整数之间使用一个空格分隔，表示变换之后得到的数组 $a$。", "hint": "### 样例说明\n\n- $5 = (101)_2$，$7 = (111)_2$，第一次变化后 $a = [10, 21]$。\n- $10 = (1010)_2$，$21 = (10101)_2$，第二次变换后 $a = [20, 63]$。\n\n### 评测用例规模与约定\n\n- 对于 $30\\%$ 的评测用例，$1 \\leq n \\leq 10$；\n- 对于 $60\\%$ 的评测用例，$1 \\leq n \\leq 100$；\n- 对于所有评测用例，$1 \\leq n \\leq 10^3$，$0 \\leq m \\leq 5$，$0 \\leq a_i \\leq 1000$。", "locale": "zh-CN"}}}
{"pid": "P12189", "type": "P", "difficulty": 3, "samples": [["6 3\n6 7 3 4 9 12\n2 3 5", "2"], ["2 1\n4 5\n6", "-1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2025", "蓝桥杯省赛"], "title": "[蓝桥杯 2025 省 Java A/研究生组] 甘蔗", "background": "", "description": "小蓝种了一排甘蔗，甘蔗共 $n$ 根，第 $i$ 根甘蔗的高度为 $a_i$。小蓝想砍一些甘蔗下来品尝，但是他有强迫症，不希望甘蔗的高度显得乱糟糟的。具体来说，他给出了一个大小为 $m$ 的整数集合 $B = \\{b_1, b_2, \\cdots, b_m\\}$，他希望在砍完甘蔗后，任意两根相邻的甘蔗之间的高度差 $|a_i - a_{i+1}|$ 都要在这个集合 $B$ 中。小蓝想知道他最少需要砍多少根甘蔗（对于高度为 $h$ 的甘蔗，他可以将其砍成 $x$ 高度的甘蔗，$x \\in \\{0, 1, 2, \\cdots, h-1\\}$）。", "inputFormat": "输入的第一行包含两个正整数 $n, m$，用一个空格分隔。\n\n第二行包含 $n$ 个正整数 $a_1, a_2, \\cdots, a_n$，相邻整数之间使用一个空格分隔。\n\n第三行包含 $m$ 个正整数 $b_1, b_2, \\cdots, b_m$，相邻整数之间使用一个空格分隔。", "outputFormat": "输出一行包含一个整数表示答案。如果不能满足条件，输出 $-1$。", "hint": "### 样例说明 1\n\n其中一种方案：将 $a_2$ 砍为 $3$，再将 $a_3$ 砍为 $1$。\n\n### 评测用例规模与约定\n\n- 对于 $40\\%$ 的评测用例，$1 \\leq n, m \\leq 8$；\n- 对于所有评测用例，$1 \\leq n, m \\leq 500$，$1 \\leq a_i \\leq 1000$，$0 \\leq b_i \\leq 1000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2025 省 Java A/研究生组] 甘蔗", "background": "", "description": "小蓝种了一排甘蔗，甘蔗共 $n$ 根，第 $i$ 根甘蔗的高度为 $a_i$。小蓝想砍一些甘蔗下来品尝，但是他有强迫症，不希望甘蔗的高度显得乱糟糟的。具体来说，他给出了一个大小为 $m$ 的整数集合 $B = \\{b_1, b_2, \\cdots, b_m\\}$，他希望在砍完甘蔗后，任意两根相邻的甘蔗之间的高度差 $|a_i - a_{i+1}|$ 都要在这个集合 $B$ 中。小蓝想知道他最少需要砍多少根甘蔗（对于高度为 $h$ 的甘蔗，他可以将其砍成 $x$ 高度的甘蔗，$x \\in \\{0, 1, 2, \\cdots, h-1\\}$）。", "inputFormat": "输入的第一行包含两个正整数 $n, m$，用一个空格分隔。\n\n第二行包含 $n$ 个正整数 $a_1, a_2, \\cdots, a_n$，相邻整数之间使用一个空格分隔。\n\n第三行包含 $m$ 个正整数 $b_1, b_2, \\cdots, b_m$，相邻整数之间使用一个空格分隔。", "outputFormat": "输出一行包含一个整数表示答案。如果不能满足条件，输出 $-1$。", "hint": "### 样例说明 1\n\n其中一种方案：将 $a_2$ 砍为 $3$，再将 $a_3$ 砍为 $1$。\n\n### 评测用例规模与约定\n\n- 对于 $40\\%$ 的评测用例，$1 \\leq n, m \\leq 8$；\n- 对于所有评测用例，$1 \\leq n, m \\leq 500$，$1 \\leq a_i \\leq 1000$，$0 \\leq b_i \\leq 1000$。", "locale": "zh-CN"}}}
{"pid": "P12190", "type": "P", "difficulty": 3, "samples": [["2", "6"], ["3", "13"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "2025", "蓝桥杯省赛"], "title": "[蓝桥杯 2025 省 Java C] 小说", "background": "", "description": "小蓝是一位网络小说家。现在他正在撰写一部新的推理小说，这部小说有 $n$ 个不同的人物。\n\n小说的每一章都有以下三种情节的一种：\n\n1. A 发现 B 不知道真相。  \n2. A 发现 B 知道真相。  \n3. A 知道了真相。  \n\n为了保证读者的协调和新鲜感，小蓝的小说还要满足以下要求：\n\n1. “B 发现 A 不知道真相”不能在 “A 知道了真相”后。  \n2. “B 发现 A 知道真相”不能在 “A 知道了真相”前。  \n3. “B 发现 A 不知道真相”不能在 “B 发现 A 知道真相”后。  \n4. 相邻的两章情节类型不同，例如如果第一章是 A 发现 B 不知道真相那么第二章就不能是 C 发现 D 不知道真相。  \n5. 完全相同的情节不能出现两次。  \n\n现在小蓝希望知道，他最多能写多少章。", "inputFormat": "输入的第一行包含一个正整数 $ n $，表示小说人数。\n", "outputFormat": "输出一行包含一个整数表示答案，即小蓝最多能写多少章小说。", "hint": "### 样例说明 1\n\n以下是一种可能的情况：\n1. B 发现 A 不知道真相。\n2. A 知道了真相。\n3. B 发现 A 知道真相。\n4. A 发现 B 不知道真相。\n5. B 知道了真相。\n6. A 发现 B 知道真相。\n\n小蓝一共能写 6 章。\n\n### 评测用例规模与约定\n\n对于 $30\\%$ 的评测用例，$n \\leq 5 $；  \n\n对于所有评测用例，$ 1 \\leq n \\leq 10^9 $。  ", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2025 省 Java C] 小说", "background": "", "description": "小蓝是一位网络小说家。现在他正在撰写一部新的推理小说，这部小说有 $n$ 个不同的人物。\n\n小说的每一章都有以下三种情节的一种：\n\n1. A 发现 B 不知道真相。  \n2. A 发现 B 知道真相。  \n3. A 知道了真相。  \n\n为了保证读者的协调和新鲜感，小蓝的小说还要满足以下要求：\n\n1. “B 发现 A 不知道真相”不能在 “A 知道了真相”后。  \n2. “B 发现 A 知道真相”不能在 “A 知道了真相”前。  \n3. “B 发现 A 不知道真相”不能在 “B 发现 A 知道真相”后。  \n4. 相邻的两章情节类型不同，例如如果第一章是 A 发现 B 不知道真相那么第二章就不能是 C 发现 D 不知道真相。  \n5. 完全相同的情节不能出现两次。  \n\n现在小蓝希望知道，他最多能写多少章。", "inputFormat": "输入的第一行包含一个正整数 $ n $，表示小说人数。\n", "outputFormat": "输出一行包含一个整数表示答案，即小蓝最多能写多少章小说。", "hint": "### 样例说明 1\n\n以下是一种可能的情况：\n1. B 发现 A 不知道真相。\n2. A 知道了真相。\n3. B 发现 A 知道真相。\n4. A 发现 B 不知道真相。\n5. B 知道了真相。\n6. A 发现 B 知道真相。\n\n小蓝一共能写 6 章。\n\n### 评测用例规模与约定\n\n对于 $30\\%$ 的评测用例，$n \\leq 5 $；  \n\n对于所有评测用例，$ 1 \\leq n \\leq 10^9 $。  ", "locale": "zh-CN"}}}
{"pid": "P12191", "type": "P", "difficulty": 4, "samples": [["7", "5"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "2025", "进制", "蓝桥杯省赛"], "title": "[蓝桥杯 2025 省研究生组] 01 串", "background": "", "description": "给定一个由 $0, 1, 2, 3 \\dots$ 的二进制表示拼接而成的长度无限的 $01$ 串。其前若干位形如 $011011100101110111\\dots$。\n\n请求出这个串的前 $x$ 位里有多少个 $1$。", "inputFormat": "输入的第一行包含一个正整数 $x$。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "### 样例说明\n\n给定的串的前 $7$ 位为 $0110111$。\n\n### 评测用例规模与约定\n\n- 对于 $60\\%$ 的评测用例，$x \\leq 10^6$；\n- 对于所有评测用例，$1 \\leq x \\leq 10^{18}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2025 省研究生组] 01 串", "background": "", "description": "给定一个由 $0, 1, 2, 3 \\dots$ 的二进制表示拼接而成的长度无限的 $01$ 串。其前若干位形如 $011011100101110111\\dots$。\n\n请求出这个串的前 $x$ 位里有多少个 $1$。", "inputFormat": "输入的第一行包含一个正整数 $x$。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "### 样例说明\n\n给定的串的前 $7$ 位为 $0110111$。\n\n### 评测用例规模与约定\n\n- 对于 $60\\%$ 的评测用例，$x \\leq 10^6$；\n- 对于所有评测用例，$1 \\leq x \\leq 10^{18}$。", "locale": "zh-CN"}}}
{"pid": "P12192", "type": "P", "difficulty": 1, "samples": [["3\n7\n7\n5\n9\n8\n1", "15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "2025", "NOISG（新加坡）"], "title": "[NOISG 2025 Prelim] Train Or Bus", "background": "", "description": "You are a tourist who wishes to explore some cities. There are $n + 1$ cities, numbered from $1$ to $n + 1$ in sequence. There are some buses and trains running between these cities.\n\nTo travel between cities $i$ and $i + 1$, you have two transportation options:\n\n- Take a **train**, which takes $a[i]$ units of time.\n- Take a **bus**, which takes $b[i]$ units of time.\n\nDetermine the minimum total time required to travel from city $1$ to city $n + 1$.\n", "inputFormat": "Your program must read from standard input.\n\nThe first line of input contains one integer $n$.\n\nThe following $n$ lines of input each contain one integer. The $i$-th of these lines contains $a[i]$.\n\nThe following $n$ lines of input each contain one integer. The $i$-th of these lines contains $b[i]$.\n", "outputFormat": "Your program must print to standard output.\n\nOutput a single integer, the shortest time taken to travel from city $1$ to city $n + 1$.\n\nThe output should contain only a single integer. Do not print any additional text such as `Enter a number` or `The answer is`.\n", "hint": "### Subtasks\n\nFor all testcases, the input will satisfy the following bounds:\n\n- $1 \\leq n \\leq 10$\n- $1 \\leq a[i] \\leq 10$ for all $1 \\leq i \\leq n$\n- $1 \\leq b[i] \\leq 10$ for all $1 \\leq i \\leq n$\n\nYour program will be tested on input instances that satisfy the following restrictions:\n\n| Subtask | Marks | Additional Constraints |\n| :-: | :-: | :-: |\n| $0$ | $0$ | Sample test cases |\n| $1$ | $100$ | No additional constraints |\n\n### Sample Test Case 1 Explanation\n\nYou start at city $1$. You then:\n\n- Take the train from city $1$ to city $2$ ($7$ units of time taken).\n- Take the train from city $2$ to city $3$ ($7$ units of time taken).\n- Take the bus from city $3$ to city $4$ ($1$ unit of time taken).\n\nThe total time taken is $15$.\n", "locale": "en", "translations": {"en": {"title": "[NOISG 2025 Prelim] Train Or Bus", "background": "", "description": "You are a tourist who wishes to explore some cities. There are $n + 1$ cities, numbered from $1$ to $n + 1$ in sequence. There are some buses and trains running between these cities.\n\nTo travel between cities $i$ and $i + 1$, you have two transportation options:\n\n- Take a **train**, which takes $a[i]$ units of time.\n- Take a **bus**, which takes $b[i]$ units of time.\n\nDetermine the minimum total time required to travel from city $1$ to city $n + 1$.\n", "inputFormat": "Your program must read from standard input.\n\nThe first line of input contains one integer $n$.\n\nThe following $n$ lines of input each contain one integer. The $i$-th of these lines contains $a[i]$.\n\nThe following $n$ lines of input each contain one integer. The $i$-th of these lines contains $b[i]$.\n", "outputFormat": "Your program must print to standard output.\n\nOutput a single integer, the shortest time taken to travel from city $1$ to city $n + 1$.\n\nThe output should contain only a single integer. Do not print any additional text such as `Enter a number` or `The answer is`.\n", "hint": "### Subtasks\n\nFor all testcases, the input will satisfy the following bounds:\n\n- $1 \\leq n \\leq 10$\n- $1 \\leq a[i] \\leq 10$ for all $1 \\leq i \\leq n$\n- $1 \\leq b[i] \\leq 10$ for all $1 \\leq i \\leq n$\n\nYour program will be tested on input instances that satisfy the following restrictions:\n\n| Subtask | Marks | Additional Constraints |\n| :-: | :-: | :-: |\n| $0$ | $0$ | Sample test cases |\n| $1$ | $100$ | No additional constraints |\n\n### Sample Test Case 1 Explanation\n\nYou start at city $1$. You then:\n\n- Take the train from city $1$ to city $2$ ($7$ units of time taken).\n- Take the train from city $2$ to city $3$ ($7$ units of time taken).\n- Take the bus from city $3$ to city $4$ ($1$ unit of time taken).\n\nThe total time taken is $15$.\n", "locale": "en"}, "zh-CN": {"title": "[NOISG 2025 Prelim] Train Or Bus", "background": "", "description": "你是一名游客，希望探索一些城市。有 $n + 1$ 个城市，按顺序从 $1$ 到 $n + 1$ 编号。这些城市之间有一些公交车和火车运行。\n\n为了在城市 $i$ 和城市 $i + 1$ 之间旅行，你有两种交通选项：\n\n- 乘坐**火车**，需要 $a[i]$ 单位时间。\n- 乘坐**公交车**，需要 $b[i]$ 单位时间。\n\n确定从城市 $1$ 到城市 $n + 1$ 所需的最短总时间。\n", "inputFormat": "你的程序必须从标准输入读取数据。\n\n输入的第一行包含一个整数 $n$。\n\n接下来的 $n$ 行输入中每行包含一个整数。这些行中的第 $i$ 行包含 $a[i]$。\n\n再接下来的 $n$ 行输入中每行包含一个整数。这些行中的第 $i$ 行包含 $b[i]$。\n", "outputFormat": "你的程序必须将结果打印到标准输出。\n\n输出一个整数，从城市 $1$ 到城市 $n + 1$ 的最短时间。\n\n输出应只包含一个整数。不要打印任何额外的文本，如 `输入一个数字` 或 `答案是`。\n", "hint": "### 子任务\n\n对于所有测试用例，输入将满足以下约束条件：\n\n- $1 \\leq n \\leq 10$\n- 对所有 $1 \\leq i \\leq n$，都有 $1 \\leq a[i] \\leq 10$\n- 对所有 $1 \\leq i \\leq n$，都有 $1 \\leq b[i] \\leq 10$\n\n你的程序将在满足以下特殊性质的输入数据上进行测试：\n\n| 子任务 | 分数 | 特殊性质 |\n| :-: | :-: | :-: |\n| $0$ | $0$ | 样例 |\n| $1$ | $100$ | 无 |\n\n### 样例 1 解释\n\n你从城市 $1$ 出发。然后：\n\n- 从城市 $1$ 到城市 $2$ 乘坐火车（耗时 $7$ 单位）。\n- 从城市 $2$ 到城市 $3$ 乘坐火车（耗时 $7$ 单位）。\n- 从城市 $3$ 到城市 $4$ 乘坐公交车（耗时 $1$ 单位）。\n\n总耗时为 $15$。\n", "locale": "zh-CN"}}}
{"pid": "P12193", "type": "P", "difficulty": 2, "samples": [["2 199\n175 42", "42"], ["5 3\n1 1 0 1 0", "3"], ["5 7\n2 2 2 2 2", "8"], ["7 5\n1 3 3 4 5 5 5", "30"], ["8 9\n7 6 6 6 3 3 3 1", "28"], ["8 5\n2 3 5 1 4 2 1 0", "21"], ["4 1000000000\n1 1 1 999999999", "2999999997"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "NOISG（新加坡）"], "title": "[NOISG 2025 Prelim] Ducks And Buttons", "background": "", "description": "**Warning for C++ users: The large size of integers involved in this problem may require the use of the `long long` data type instead of the `int` data type.**\n\nShor the Duck is playing a game with his friends! The game is played on a 1-dimensional grid consisting of $n$ cells in, arranged in a row and numbered from $1$ to $n$ from left to right.\n\nEach cell has a button. The button on cell $i$ will be permanently pressed if at any point in time there are at least $a[i]$ ducks on that cell. Even if the ducks leave, the button remains pressed. To win the game, all $n$ buttons must be pressed.\n\nInitially, there are $d$ ducks on cell $1$. In one move, a single duck can move one cell left or right.\n\nDetermine the minimum total number of moves required to win the game. **It is guaranteed that it is possible to win the game with some number of moves.**", "inputFormat": "Your program must read from standard input.\n\nThe first line of input contains two space-separated integers $n$ and $d$.\n\nThe second line of input contains $n$ space-separated integers $a[1], a[2], \\ldots, a[n]$.\n", "outputFormat": "Your program must print to standard output.\n\nOutput a single integer, the minimum total number of moves required to win the game.\n", "hint": "### Subtasks\n\nFor all test cases, the input will satisfy the following bounds:\n\n- $1 \\leq n \\leq 200\\,000$\n- $1 \\leq d \\leq 10^9$\n- $0 \\leq a[i] \\leq d$ for all $1 \\leq i \\leq n$\n- It is possible to win the game with some number of moves.\n\nYour program will be tested on input instances that satisfy the following restrictions:\n\n| Subtask | Marks | Additional Constraints |\n| :-: | :-: | :-: |\n| $0$ | $0$ | Sample test cases |\n| $1$ | $8$ | $n = 2$ |\n| $2$ | $5$ | $a[i] = 0$ |\n| $3$ | $11$ | $a[i] \\leq 1$ |\n| $4$ | $6$ | All values of $a[i]$ are equal |\n| $5$ | $19$ | $n, d \\leq 1000$ |\n| $6$ | $12$ | $a[i]$ is non-decreasing |\n| $7$ | $16$ | $a[i]$ is non-increasing |\n| $8$ | $23$ | No additional constraints |\n\n### Sample Test Case 1 Explanation\n\nThis test case is valid for subtasks $1, 5, 7$, and $8$.\n\n### Sample Test Case 2 Explanation\n\nThis test case is valid for subtasks $3, 5$, and $8$.\n\n### Sample Test Case 3 Explanation\n\nThis test case is valid for subtasks $4, 5, 6, 7$, and $8$.\n\n### Sample Test Case 4 Explanation\n\nThis test case is valid for subtasks $5, 6$, and $8$.\n\n### Sample Test Case 5 Explanation\n\nThis test case is valid for subtasks $5, 7$, and $8$.\n\n### Sample Test Case 6 Explanation\n\nThis test case is valid for subtasks $5$ and $8$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/eof0jice.png)\n\nOne possible sequence of moves that minimises the total number of moves is shown above. Each red arrow is a move, and the number above it indicates the order of the moves, with move $1$ coming first.\n\n- Button $1$ is first pressed before any moves occur.\n- Button $2$ is first pressed after move $3$.\n- Button $3$ is first pressed after move $10$.\n- Button $4$ is first pressed after move $11$.\n- Button $5$ is first pressed after move $18$.\n- Button $6$ is first pressed after move $20$.\n- Button $7$ is first pressed after move $21$.\n- Button $8$ is first pressed before any moves occur (since $a[8] = 0$).\n\nSince all buttons are pressed by the end of all $21$ moves, $21$ moves is sufficient to win the game. It can be proven that $21$ moves is the minimum total number of moves needed.\n\n### Sample Test Case 7 Explanation\n\nThis test case is valid for subtasks $4, 6$, and $8$.\n", "locale": "en", "translations": {"en": {"title": "[NOISG 2025 Prelim] Ducks And Buttons", "background": "", "description": "**Warning for C++ users: The large size of integers involved in this problem may require the use of the `long long` data type instead of the `int` data type.**\n\nShor the Duck is playing a game with his friends! The game is played on a 1-dimensional grid consisting of $n$ cells in, arranged in a row and numbered from $1$ to $n$ from left to right.\n\nEach cell has a button. The button on cell $i$ will be permanently pressed if at any point in time there are at least $a[i]$ ducks on that cell. Even if the ducks leave, the button remains pressed. To win the game, all $n$ buttons must be pressed.\n\nInitially, there are $d$ ducks on cell $1$. In one move, a single duck can move one cell left or right.\n\nDetermine the minimum total number of moves required to win the game. **It is guaranteed that it is possible to win the game with some number of moves.**", "inputFormat": "Your program must read from standard input.\n\nThe first line of input contains two space-separated integers $n$ and $d$.\n\nThe second line of input contains $n$ space-separated integers $a[1], a[2], \\ldots, a[n]$.\n", "outputFormat": "Your program must print to standard output.\n\nOutput a single integer, the minimum total number of moves required to win the game.\n", "hint": "### Subtasks\n\nFor all test cases, the input will satisfy the following bounds:\n\n- $1 \\leq n \\leq 200\\,000$\n- $1 \\leq d \\leq 10^9$\n- $0 \\leq a[i] \\leq d$ for all $1 \\leq i \\leq n$\n- It is possible to win the game with some number of moves.\n\nYour program will be tested on input instances that satisfy the following restrictions:\n\n| Subtask | Marks | Additional Constraints |\n| :-: | :-: | :-: |\n| $0$ | $0$ | Sample test cases |\n| $1$ | $8$ | $n = 2$ |\n| $2$ | $5$ | $a[i] = 0$ |\n| $3$ | $11$ | $a[i] \\leq 1$ |\n| $4$ | $6$ | All values of $a[i]$ are equal |\n| $5$ | $19$ | $n, d \\leq 1000$ |\n| $6$ | $12$ | $a[i]$ is non-decreasing |\n| $7$ | $16$ | $a[i]$ is non-increasing |\n| $8$ | $23$ | No additional constraints |\n\n### Sample Test Case 1 Explanation\n\nThis test case is valid for subtasks $1, 5, 7$, and $8$.\n\n### Sample Test Case 2 Explanation\n\nThis test case is valid for subtasks $3, 5$, and $8$.\n\n### Sample Test Case 3 Explanation\n\nThis test case is valid for subtasks $4, 5, 6, 7$, and $8$.\n\n### Sample Test Case 4 Explanation\n\nThis test case is valid for subtasks $5, 6$, and $8$.\n\n### Sample Test Case 5 Explanation\n\nThis test case is valid for subtasks $5, 7$, and $8$.\n\n### Sample Test Case 6 Explanation\n\nThis test case is valid for subtasks $5$ and $8$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/eof0jice.png)\n\nOne possible sequence of moves that minimises the total number of moves is shown above. Each red arrow is a move, and the number above it indicates the order of the moves, with move $1$ coming first.\n\n- Button $1$ is first pressed before any moves occur.\n- Button $2$ is first pressed after move $3$.\n- Button $3$ is first pressed after move $10$.\n- Button $4$ is first pressed after move $11$.\n- Button $5$ is first pressed after move $18$.\n- Button $6$ is first pressed after move $20$.\n- Button $7$ is first pressed after move $21$.\n- Button $8$ is first pressed before any moves occur (since $a[8] = 0$).\n\nSince all buttons are pressed by the end of all $21$ moves, $21$ moves is sufficient to win the game. It can be proven that $21$ moves is the minimum total number of moves needed.\n\n### Sample Test Case 7 Explanation\n\nThis test case is valid for subtasks $4, 6$, and $8$.\n", "locale": "en"}, "zh-CN": {"title": "[NOISG 2025 Prelim] Ducks And Buttons", "background": "", "description": "**C++ 用户注意：由于此问题中涉及的整数数值较大，可能需要使用 `long long` 数据类型来代替 `int` 数据类型。**\n\nShor 小鸭正在和他的朋友们玩一个游戏！这个游戏是在一个一维的网格上进行的，该网格由 $n$ 个单元格排成一行组成，从左到右编号为 $1$ 到 $n$。\n\n每个单元格上都有一个按钮。如果某一时刻在第 $i$ 个单元格上有不少于 $a[i]$ 只鸭子，那么该单元格上的按钮就会被永久按下。即使这些鸭子离开了，该按钮也仍然保持按下状态。为了赢得这场游戏，所有 $n$ 个按钮都必须被按下。\n\n一开始，第 $1$ 个单元格上有 $d$ 只鸭子。每次移动中，一只鸭子可以向左或向右移动一个单元格。\n\n请确定赢得这场游戏所需的最少总移动次数。**题目保证存在某种移动方式可以赢得这场游戏。**\n", "inputFormat": "你的程序必须从标准输入读取数据。\n\n输入的第一行包含两个用空格分隔的整数 $n$ 和 $d$。\n\n第二行包含 $n$ 个用空格分隔的整数 $a[1], a[2], \\ldots, a[n]$。\n", "outputFormat": "你的程序必须将结果打印到标准输出。\n\n输出一个整数，表示赢得这场游戏所需的最少总移动次数。\n", "hint": "### 子任务\n\n对于所有测试用例，输入将满足以下约束条件：\n\n- $1 \\leq n \\leq 200\\,000$\n- $1 \\leq d \\leq 10^9$\n- 对于所有 $1 \\leq i \\leq n$，都有 $0 \\leq a[i] \\leq d$\n- 题目保证存在某种移动方式可以赢得这场游戏\n\n你的程序将在满足以下特殊性质的输入数据上进行测试：\n\n| 子任务 | 分值 | 特殊性质 |\n| :-: | :-: | :-: |\n| $0$ | $0$ | 样例 |\n| $1$ | $8$ | $n = 2$ |\n| $2$ | $5$ | $a[i] = 0$ |\n| $3$ | $11$ | $a[i] \\leq 1$ |\n| $4$ | $6$ | 所有的 $a[i]$ 值相等 |\n| $5$ | $19$ | $n, d \\leq 1000$ |\n| $6$ | $12$ | $a[i]$ 是单调不减的 |\n| $7$ | $16$ | $a[i]$ 是单调不升的 |\n| $8$ | $23$ | 无 |\n\n### 样例 1 解释\n\n此样例适用于子任务 $1, 5, 7, 8$。\n\n### 样例 2 解释\n\n此样例适用于子任务 $3, 5, 8$。\n\n### 样例 3 解释\n\n此样例适用于子任务 $4, 5, 6, 7, 8$。\n\n### 样例 4 解释\n\n此样例适用于子任务 $5, 6, 8$。\n\n### 样例 5 解释\n\n此样例适用于子任务 $5, 7, 8$。\n\n### 样例 6 解释\n\n此样例适用于子任务 $5, 8$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/eof0jice.png)\n\n下图展示了一种可以最小化总移动次数的移动序列。每一个红色箭头代表一次移动，箭头上方的数字表示移动的顺序，移动 $1$ 最先发生。\n\n- 按钮 $1$ 在所有移动发生之前就已被按下。\n- 按钮 $2$ 在第 $3$ 次移动后被按下。\n- 按钮 $3$ 在第 $10$ 次移动后被按下。\n- 按钮 $4$ 在第 $11$ 次移动后被按下。\n- 按钮 $5$ 在第 $18$ 次移动后被按下。\n- 按钮 $6$ 在第 $20$ 次移动后被按下。\n- 按钮 $7$ 在第 $21$ 次移动后被按下。\n- 按钮 $8$ 在所有移动发生之前就已被按下（因为 $a[8] = 0$）。\n\n由于在第 $21$ 次移动结束后所有按钮都已被按下，因此 $21$ 次移动是足够的。可以证明这是赢得游戏所需的最少移动次数。\n\n### 样例 7 解释\n\n此样例适用于子任务 $4, 6, 8$。\n", "locale": "zh-CN"}}}
{"pid": "P12194", "type": "P", "difficulty": 4, "samples": [["5 3\n1 6 2 4 6\n6 6 3\n2 2 3\n3 3 5", "19\n13\n14\n20"], ["6 4\n929 121 5 3 919 72\n1 133 0\n70 79 0\n900 999 0\n1 1000 0", "2049\n1848\n1848\n0\n0"], ["6 5\n7 72 727 123 321 9\n7 9 10\n10 72 727\n111 222 30\n123 727 99\n111 222 333", "1259\n1263\n3352\n3259\n525\n525"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "平衡树", "2025", "颜色段均摊（珂朵莉树 ODT）", "NOISG（新加坡）", "STL"], "title": "[NOISG 2025 Prelim] Snacks", "background": "", "description": "Shor the Duck has prepared $n$ plates of snacks to enjoy while watching movies! The $i$-th plate initially contains a snack with a deliciousness value of $a[i]$.\n\nYou need to process $q$ queries. In the $j$-th query, Shor will do **both** of the following, in order:\n\n1. Eat every snack whose deliciousness is between $l[j]$ and $r[j]$ (inclusive).\n2. Then, replace each eaten snack with a new snack of deliciousness $x[j]$.\n\nBefore processing any queries, and after each query, Shor wants you to determine the sum of deliciousness of snacks across all plates.\n\nFormally, you are given an array $a$ of length $n$ and must process $q$ queries. Before processing any queries, print the sum of all elements in $a$. In the $j$-th query, update every element $a[i]$ such that $l[j] \\leq a[i] \\leq r[j]$ by setting $a[i] = x[j]$, then print the updated sum of all elements in $a$.\n", "inputFormat": "Your program must read from standard input.\n\nThe first line of input contains two space-separated integers $n$ and $q$.\n\nThe second line of input contains $n$ space-separated integers $a[1], a[2], \\ldots, a[n]$.\n\nThe following $q$ lines of input each contain three space-separated integers. The $j$-th of these lines contains $l[j], r[j]$, and $x[j]$, describing the $j$-th query.\n", "outputFormat": "Your program must print to standard output.\n\nThe output should contain $q + 1$ lines.\n\nThe first line of output should contain a single integer, the sum of all elements in a before all queries.\n\nThe following $q$ lines of input should each contain one integer. The $i$-th of these lines should contain the sum of elements in a after the $i$-th query.\n", "hint": "### Subtasks\n\nFor all test cases, the input will satisfy the following bounds:\n\n- $1 \\leq n \\leq 200\\,000$\n- $0 \\leq q \\leq 200\\,000$\n- $0 \\leq a[i] \\leq 10^9$ for all $1 \\leq i \\leq n$\n- $0 \\leq x[j] \\leq 10^9$ for all $1 \\leq j \\leq q$\n- $0 \\leq l[j] \\leq r[j] \\leq 10^9$ for all $1 \\leq j \\leq q$\n\nYour program will be tested on input instances that satisfy the following restrictions:\n\n| Subtask | Marks | Additional Constraints |\n| :-: | :-: | :-: |\n| $0$ | $0$ | Sample test cases |\n| $1$ | $5$ | $q = 0$ |\n| $2$ | $12$ | $n, q \\leq 2000$ |\n| $3$ | $21$ | $l[j] = r[j] \\leq 200\\,000$ and $a[i], x[j] \\leq 200\\,000$ |\n| $4$ | $13$ | $l[j] = r[j]$ |\n| $5$ | $16$ | $x[j] = 0$ |\n| $6$ | $33$ | No additional constraints |\n\n### Sample Test Case 1 Explanation\n\nThis test case is valid for subtasks $2, 3, 4$, and $6$.\n\n### Sample Test Case 2 Explanation\n\nThis test case is valid for subtasks $2, 5$, and $6$.\n\n### Sample Test Case 3 Explanation\n\nThis test case is valid for subtasks $2$ and $6$.\n\nBefore all queries, the array a is $[7, 72, 727, 123, 321, 9]$, with a sum of $1259$.\n\nAfter the first query, the array a becomes $[10, 72, 727, 123, 321, 10]$, with a sum of $1263$.\n\nAfter the second query, the array a becomes $[727, 727, 727, 123, 321, 727]$, with a sum of $3352$.\n\nAfter the third query, the array a becomes $[727, 727, 727, 30, 321, 727]$, with a sum of $3259$.\n\nAfter the fourth query, the array a becomes $[99, 99, 99, 30, 99, 99]$, with a sum of $525$.\n\nAfter the fifth query, the array a becomes $[99, 99, 99, 30, 99, 99]$, with a sum of $525$.\n", "locale": "en", "translations": {"en": {"title": "[NOISG 2025 Prelim] Snacks", "background": "", "description": "Shor the Duck has prepared $n$ plates of snacks to enjoy while watching movies! The $i$-th plate initially contains a snack with a deliciousness value of $a[i]$.\n\nYou need to process $q$ queries. In the $j$-th query, Shor will do **both** of the following, in order:\n\n1. Eat every snack whose deliciousness is between $l[j]$ and $r[j]$ (inclusive).\n2. Then, replace each eaten snack with a new snack of deliciousness $x[j]$.\n\nBefore processing any queries, and after each query, Shor wants you to determine the sum of deliciousness of snacks across all plates.\n\nFormally, you are given an array $a$ of length $n$ and must process $q$ queries. Before processing any queries, print the sum of all elements in $a$. In the $j$-th query, update every element $a[i]$ such that $l[j] \\leq a[i] \\leq r[j]$ by setting $a[i] = x[j]$, then print the updated sum of all elements in $a$.\n", "inputFormat": "Your program must read from standard input.\n\nThe first line of input contains two space-separated integers $n$ and $q$.\n\nThe second line of input contains $n$ space-separated integers $a[1], a[2], \\ldots, a[n]$.\n\nThe following $q$ lines of input each contain three space-separated integers. The $j$-th of these lines contains $l[j], r[j]$, and $x[j]$, describing the $j$-th query.\n", "outputFormat": "Your program must print to standard output.\n\nThe output should contain $q + 1$ lines.\n\nThe first line of output should contain a single integer, the sum of all elements in a before all queries.\n\nThe following $q$ lines of input should each contain one integer. The $i$-th of these lines should contain the sum of elements in a after the $i$-th query.\n", "hint": "### Subtasks\n\nFor all test cases, the input will satisfy the following bounds:\n\n- $1 \\leq n \\leq 200\\,000$\n- $0 \\leq q \\leq 200\\,000$\n- $0 \\leq a[i] \\leq 10^9$ for all $1 \\leq i \\leq n$\n- $0 \\leq x[j] \\leq 10^9$ for all $1 \\leq j \\leq q$\n- $0 \\leq l[j] \\leq r[j] \\leq 10^9$ for all $1 \\leq j \\leq q$\n\nYour program will be tested on input instances that satisfy the following restrictions:\n\n| Subtask | Marks | Additional Constraints |\n| :-: | :-: | :-: |\n| $0$ | $0$ | Sample test cases |\n| $1$ | $5$ | $q = 0$ |\n| $2$ | $12$ | $n, q \\leq 2000$ |\n| $3$ | $21$ | $l[j] = r[j] \\leq 200\\,000$ and $a[i], x[j] \\leq 200\\,000$ |\n| $4$ | $13$ | $l[j] = r[j]$ |\n| $5$ | $16$ | $x[j] = 0$ |\n| $6$ | $33$ | No additional constraints |\n\n### Sample Test Case 1 Explanation\n\nThis test case is valid for subtasks $2, 3, 4$, and $6$.\n\n### Sample Test Case 2 Explanation\n\nThis test case is valid for subtasks $2, 5$, and $6$.\n\n### Sample Test Case 3 Explanation\n\nThis test case is valid for subtasks $2$ and $6$.\n\nBefore all queries, the array a is $[7, 72, 727, 123, 321, 9]$, with a sum of $1259$.\n\nAfter the first query, the array a becomes $[10, 72, 727, 123, 321, 10]$, with a sum of $1263$.\n\nAfter the second query, the array a becomes $[727, 727, 727, 123, 321, 727]$, with a sum of $3352$.\n\nAfter the third query, the array a becomes $[727, 727, 727, 30, 321, 727]$, with a sum of $3259$.\n\nAfter the fourth query, the array a becomes $[99, 99, 99, 30, 99, 99]$, with a sum of $525$.\n\nAfter the fifth query, the array a becomes $[99, 99, 99, 30, 99, 99]$, with a sum of $525$.\n", "locale": "en"}, "zh-CN": {"title": "[NOISG 2025 Prelim] Snacks", "background": "", "description": "Shor 小鸭已经准备了 $n$ 个小吃盘子，准备一边看电影一边享用！第 $i$ 个盘子最初装有一个美味值为 $a[i]$ 的小吃。\n\n你需要处理 $q$ 个查询。在第 $j$ 个查询中，Shor 将按顺序执行以下两个操作：\n\n1. 吃掉所有美味值在 $l[j]$ 到 $r[j]$（包含）之间的小吃。\n2. 然后，将每一个被吃掉的小吃替换为一个美味值为 $x[j]$ 的新小吃。\n\n在处理任何查询之前，以及每次处理完查询之后，Shor 都希望你确定所有盘子中小吃的美味值总和。\n\n形式化地说，给定一个长度为 $n$ 的数组 $a$，你必须处理 $q$ 个查询。在处理所有查询之前，打印 $a$ 中所有元素的总和。在第 $j$ 个查询中，将所有满足 $l[j] \\leq a[i] \\leq r[j]$ 的元素 $a[i]$ 更新为 $x[j]$，然后打印更新后的 $a$ 中所有元素的总和。\n", "inputFormat": "你的程序必须从标准输入读取数据。\n\n输入的第一行包含两个用空格分隔的整数 $n$ 和 $q$。\n\n第二行包含 $n$ 个用空格分隔的整数 $a[1], a[2], \\ldots, a[n]$。\n\n接下来的 $q$ 行输入中，每一行包含三个用空格分隔的整数。第 $j$ 行包含 $l[j], r[j]$ 和 $x[j]$，描述了第 $j$ 个查询。\n", "outputFormat": "你的程序必须将结果打印到标准输出。\n\n输出应包含 $q + 1$ 行。\n\n输出的第一行应包含一个整数，表示在所有查询之前 $a$ 中所有元素的总和。\n\n接下来的 $q$ 行中，第 $i$ 行应包含一个整数，表示第 $i$ 个查询后 $a$ 中所有元素的总和。\n", "hint": "### 子任务\n\n对于所有测试用例，输入将满足以下约束条件：\n\n- $1 \\leq n \\leq 200\\,000$\n- $0 \\leq q \\leq 200\\,000$\n- $0 \\leq a[i] \\leq 10^9$ 对于所有 $1 \\leq i \\leq n$\n- $0 \\leq x[j] \\leq 10^9$ 对于所有 $1 \\leq j \\leq q$\n- $0 \\leq l[j] \\leq r[j] \\leq 10^9$ 对于所有 $1 \\leq j \\leq q$\n\n你的程序将在满足以下特殊性质的输入数据上进行测试：\n\n| 子任务 | 分值 | 特殊性质 |\n| :-: | :-: | :-: |\n| $0$ | $0$ | 样例 |\n| $1$ | $5$ | $q = 0$ |\n| $2$ | $12$ | $n, q \\leq 2000$ |\n| $3$ | $21$ | $l[j] = r[j] \\leq 200\\,000$ 且 $a[i], x[j] \\leq 200\\,000$ |\n| $4$ | $13$ | $l[j] = r[j]$ |\n| $5$ | $16$ | $x[j] = 0$ |\n| $6$ | $33$ | 无 |\n\n### 样例 1 解释\n\n此样例适用于子任务 $2, 3, 4, 6$。\n\n### 样例 2 解释\n\n此样例适用于子任务 $2, 5, 6$。\n\n### 样例 3 解释\n\n此样例适用于子任务 $2, 6$。\n\n在所有查询之前，数组 $a$ 为 $[7, 72, 727, 123, 321, 9]$，总和为 $1259$。\n\n第一次查询后，数组 $a$ 变为 $[10, 72, 727, 123, 321, 10]$，总和为 $1263$。\n\n第二次查询后，数组 $a$ 变为 $[727, 727, 727, 123, 321, 727]$，总和为 $3352$。\n\n第三次查询后，数组 $a$ 变为 $[727, 727, 727, 30, 321, 727]$，总和为 $3259$。\n\n第四次查询后，数组 $a$ 变为 $[99, 99, 99, 30, 99, 99]$，总和为 $525$。\n\n第五次查询后，数组 $a$ 变为 $[99, 99, 99, 30, 99, 99]$，总和为 $525$。\n", "locale": "zh-CN"}}}
{"pid": "P12195", "type": "P", "difficulty": 4, "samples": [["8 4\n1 3\n2 4\n3 4\n4 6\n5 3\n2 8\n7 4\n3 5 2 7", "1\n0\n1\n1\n0\n1\n1\n0"], ["8 4\n1 3\n2 4\n3 4\n4 6\n5 3\n2 8\n7 4\n3 2 5 7", "0\n0\n0\n0\n0\n0\n0\n0"], ["4 7\n1 2\n1 3\n1 4\n2 1 2 1 2 1 2", "0\n0\n0\n0"], ["5 2\n1 2\n2 3\n3 4\n4 5\n2 4", "1\n1\n1\n1\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "NOISG（新加坡）"], "title": "[NOISG 2025 Prelim] Itinerary", "background": "", "description": "The Scientific Committee is planning to visit $n$ cities. The $n$ cities are connected by exactly $n - 1$ roads such that it is possible to move between all pairs of cities using the roads. Road $i$ is built between cities $u[i]$ and $v[i]$.\n\nEach city has its own airport. To begin the trip, the committee will fly from Singapore to one of the cities. To make the most out of their trip in the most efficient way possible, the committee wants to visit each city **at least once** by using each road **exactly twice** (once in each direction), before flying back home from the last city they find themselves in. A trip satisfying this condition is called a **tour**.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/glw0pqmy.png)\n\nFor example, let the diagram above represent a map of $n = 8$ cities. One possible tour starting from city $1$ is $1 \\to 3 \\to 5 \\to 3 \\to 4 \\to 2 \\to 8 \\to 2 \\to 4 \\to 6 \\to 4 \\to 7 \\to 4 \\to 3 \\to 1$. Observe that this tour visits all cities a total of $2n - 1$ (equal to $15$) times and ends at the same city it started from (city $1$). It can be shown that these two properties are true for all tours in all possible maps of cities.\n\nThe committee also wants to visit $m$ events which will happen in order from event $1$ to event $m$. Event $j$ will be held in city $s[j]$. A city can hold zero, one or multiple events, but no two consecutive events are held in the same city, i.e., $s[j] = s[j + 1]$.\n\nA tour that allows the committee to visit all events must visit the cities $s[1], s[2], \\ldots, s[m]$ in order, not necessarily consecutively. Such a tour is called an **itinerary**. Formally, let $t[1], t[2], \\ldots, t[2n - 1]$ be the sequence of cities visited in some tour. A tour is an itinerary if and only if $s$ is a subsequence of $t$. That is, $s$ can be obtained by deleting zero or more elements from $t$ and maintaining the order of the remaining elements. Using the same example as above, suppose that $m = 4$ and $s = [3, 5, 2, 7]$, then the tour $1 \\to \\textbf{3} \\to \\textbf{5} \\to 3 \\to 4 \\to \\textbf{2} \\to 8 \\to 2 \\to 4 \\to 6 \\to 4 \\to \\textbf{7} \\to 4 \\to 3 \\to 1$ above is an itinerary because the cities $3, 5, 2, 7$ are visited in order during the tour (underlined and marked in bold).\n\nThe committee is still deciding which city to start from, but they agree that a city is a good choice to start from if there exists an itinerary that starts from it. For all cities, help the committee determine if there exists at least one itinerary starting from that city.\n", "inputFormat": "Your program must read from standard input.\n\nThe first line of input contains two space-separated integers $n$ and $m$, describing the number of cities and the number of events respectively.\n\nThe following $n - 1$ lines of input each contain two space-separated integers. The $i$-th of these lines contains $u[i]$ and $v[i]$, describing the endpoints of the $i$-th road.\n\nThe last line of input contains $m$ space-separated integers $s[1], s[2], \\ldots, s[m]$, describing the cities that are holding events.\n", "outputFormat": "Your program must print to standard output.\n\nThe output should contain $n$ lines. If there exists an itinerary starting from city $i$, then the $i$-th line should contain a single integer $1$. Otherwise, the $i$-th line should contain a single integer $0$.\n", "hint": "### Subtasks\n\nFor all test cases, the input will satisfy the following bounds:\n\n- $2 \\leq n \\leq 200\\,000$\n- $1 \\leq m \\leq 2n - 1$\n- $1 \\leq u[i], v[i] \\leq n$ for all $1 \\leq i \\leq n - 1$\n- $1 \\leq s[j] \\leq n$ for all $1 \\leq j \\leq m$\n- $s[j] \\neq s[j + 1]$ for all $1 \\leq j \\leq m - 1$\n- It is possible to move between all pairs of cities using the roads.\n\nYour program will be tested on input instances that satisfy the following restrictions:\n\n| Subtask | Marks | Additional Constraints |\n| :-: | :-: | :-: |\n| $0$ | $0$ | Sample test cases |\n| $1$ | $7$ | $n \\leq 1000, m = 2n - 1$ |\n| $2$ | $10$ | $u[i] = 1, v[i] = i + 1$ |\n| $3$ | $6$ | $n \\leq 1000, u[i] = i, v[i] = i + 1$ |\n| $4$ | $7$ | $u[i] = i, v[i] = i + 1$ |\n| $5$ | $14$ | $n \\leq 1000, m \\leq 10$ |\n| $6$ | $5$ | $n \\leq 1000$ |\n| $7$ | $19$ | $m \\leq 10$ |\n| $8$ | $11$ | $s[1] = s[m]$ |\n| $9$ | $21$ | No additional constraints |\n\n### Sample Test Case 1 Explanation\n\nThis test case is valid for subtasks $5, 6, 7$, and $9$.\n\nThis test case is described as an example in the problem statement.\n\nThere are itineraries starting from cities $1, 3, 4, 6$, and $7$. An itinerary starting from city $1$ is given in the problem statement.\n\nOn the other hand, it can be shown that there are no itineraries starting from cities $2, 5$, and $8$.\n\n### Sample Test Case 2 Explanation\n\nThis test case is valid for subtasks $5, 6, 7$, and $9$.\n\nThis test case is the same as the example in the problem statement, except $s[2]$ and $s[3]$ are swapped. No itineraries exist at all.\n\n### Sample Test Case 3 Explanation\n\nThis test case is valid for subtasks $1, 2, 5, 6, 7, 8$, and $9$.\n\n### Sample Test Case 4 Explanation\n\nThis test case is valid for subtasks $3, 4, 5, 6, 7$, and $9$.", "locale": "en", "translations": {"en": {"title": "[NOISG 2025 Prelim] Itinerary", "background": "", "description": "The Scientific Committee is planning to visit $n$ cities. The $n$ cities are connected by exactly $n - 1$ roads such that it is possible to move between all pairs of cities using the roads. Road $i$ is built between cities $u[i]$ and $v[i]$.\n\nEach city has its own airport. To begin the trip, the committee will fly from Singapore to one of the cities. To make the most out of their trip in the most efficient way possible, the committee wants to visit each city **at least once** by using each road **exactly twice** (once in each direction), before flying back home from the last city they find themselves in. A trip satisfying this condition is called a **tour**.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/glw0pqmy.png)\n\nFor example, let the diagram above represent a map of $n = 8$ cities. One possible tour starting from city $1$ is $1 \\to 3 \\to 5 \\to 3 \\to 4 \\to 2 \\to 8 \\to 2 \\to 4 \\to 6 \\to 4 \\to 7 \\to 4 \\to 3 \\to 1$. Observe that this tour visits all cities a total of $2n - 1$ (equal to $15$) times and ends at the same city it started from (city $1$). It can be shown that these two properties are true for all tours in all possible maps of cities.\n\nThe committee also wants to visit $m$ events which will happen in order from event $1$ to event $m$. Event $j$ will be held in city $s[j]$. A city can hold zero, one or multiple events, but no two consecutive events are held in the same city, i.e., $s[j] = s[j + 1]$.\n\nA tour that allows the committee to visit all events must visit the cities $s[1], s[2], \\ldots, s[m]$ in order, not necessarily consecutively. Such a tour is called an **itinerary**. Formally, let $t[1], t[2], \\ldots, t[2n - 1]$ be the sequence of cities visited in some tour. A tour is an itinerary if and only if $s$ is a subsequence of $t$. That is, $s$ can be obtained by deleting zero or more elements from $t$ and maintaining the order of the remaining elements. Using the same example as above, suppose that $m = 4$ and $s = [3, 5, 2, 7]$, then the tour $1 \\to \\textbf{3} \\to \\textbf{5} \\to 3 \\to 4 \\to \\textbf{2} \\to 8 \\to 2 \\to 4 \\to 6 \\to 4 \\to \\textbf{7} \\to 4 \\to 3 \\to 1$ above is an itinerary because the cities $3, 5, 2, 7$ are visited in order during the tour (underlined and marked in bold).\n\nThe committee is still deciding which city to start from, but they agree that a city is a good choice to start from if there exists an itinerary that starts from it. For all cities, help the committee determine if there exists at least one itinerary starting from that city.\n", "inputFormat": "Your program must read from standard input.\n\nThe first line of input contains two space-separated integers $n$ and $m$, describing the number of cities and the number of events respectively.\n\nThe following $n - 1$ lines of input each contain two space-separated integers. The $i$-th of these lines contains $u[i]$ and $v[i]$, describing the endpoints of the $i$-th road.\n\nThe last line of input contains $m$ space-separated integers $s[1], s[2], \\ldots, s[m]$, describing the cities that are holding events.\n", "outputFormat": "Your program must print to standard output.\n\nThe output should contain $n$ lines. If there exists an itinerary starting from city $i$, then the $i$-th line should contain a single integer $1$. Otherwise, the $i$-th line should contain a single integer $0$.\n", "hint": "### Subtasks\n\nFor all test cases, the input will satisfy the following bounds:\n\n- $2 \\leq n \\leq 200\\,000$\n- $1 \\leq m \\leq 2n - 1$\n- $1 \\leq u[i], v[i] \\leq n$ for all $1 \\leq i \\leq n - 1$\n- $1 \\leq s[j] \\leq n$ for all $1 \\leq j \\leq m$\n- $s[j] \\neq s[j + 1]$ for all $1 \\leq j \\leq m - 1$\n- It is possible to move between all pairs of cities using the roads.\n\nYour program will be tested on input instances that satisfy the following restrictions:\n\n| Subtask | Marks | Additional Constraints |\n| :-: | :-: | :-: |\n| $0$ | $0$ | Sample test cases |\n| $1$ | $7$ | $n \\leq 1000, m = 2n - 1$ |\n| $2$ | $10$ | $u[i] = 1, v[i] = i + 1$ |\n| $3$ | $6$ | $n \\leq 1000, u[i] = i, v[i] = i + 1$ |\n| $4$ | $7$ | $u[i] = i, v[i] = i + 1$ |\n| $5$ | $14$ | $n \\leq 1000, m \\leq 10$ |\n| $6$ | $5$ | $n \\leq 1000$ |\n| $7$ | $19$ | $m \\leq 10$ |\n| $8$ | $11$ | $s[1] = s[m]$ |\n| $9$ | $21$ | No additional constraints |\n\n### Sample Test Case 1 Explanation\n\nThis test case is valid for subtasks $5, 6, 7$, and $9$.\n\nThis test case is described as an example in the problem statement.\n\nThere are itineraries starting from cities $1, 3, 4, 6$, and $7$. An itinerary starting from city $1$ is given in the problem statement.\n\nOn the other hand, it can be shown that there are no itineraries starting from cities $2, 5$, and $8$.\n\n### Sample Test Case 2 Explanation\n\nThis test case is valid for subtasks $5, 6, 7$, and $9$.\n\nThis test case is the same as the example in the problem statement, except $s[2]$ and $s[3]$ are swapped. No itineraries exist at all.\n\n### Sample Test Case 3 Explanation\n\nThis test case is valid for subtasks $1, 2, 5, 6, 7, 8$, and $9$.\n\n### Sample Test Case 4 Explanation\n\nThis test case is valid for subtasks $3, 4, 5, 6, 7$, and $9$.", "locale": "en"}, "zh-CN": {"title": "[NOISG 2025 Prelim] Itinerary", "background": "", "description": "科学委员会计划访问 $n$ 个城市。这 $n$ 个城市通过恰好 $n - 1$ 条道路连接，使得可以使用这些道路在所有城市对之间移动。第 $i$ 条道路建在城市 $u[i]$ 和 $v[i]$ 之间。\n\n每个城市都有自己的机场。为了开始旅程，委员会将从新加坡飞往其中一个城市。为了尽可能高效地利用旅程，委员会希望通过每条道路**恰好两次**（每个方向一次）来访问每个城市**至少一次**，然后从他们最终到达的城市飞回家。满足这个条件的旅程称为**巡游**。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/glw0pqmy.png)\n\n例如，设上图表示一个有 $n = 8$ 个城市的地图。从城市 $1$ 开始的一种可能的巡游是 $1 \\to 3 \\to 5 \\to 3 \\to 4 \\to 2 \\to 8 \\to 2 \\to 4 \\to 6 \\to 4 \\to 7 \\to 4 \\to 3 \\to 1$。注意这个巡游总共访问了所有城市 $2n - 1$ 次（等于 $15$），并且以起始城市（城市 $1$）结束。可以证明，对于所有可能的城市地图，所有巡游都满足这两个性质。\n\n委员会还希望访问 $m$ 个按顺序从事件 $1$ 到事件 $m$ 发生的活动。事件 $j$ 将在城市 $s[j]$ 举行。一个城市可以举办零个、一个或多个活动，但不会有两个连续的活动在同一个城市举行，即 $s[j] = s[j + 1]$。\n\n允许委员会访问所有活动的巡游必须按顺序访问城市 $s[1], s[2], \\ldots, s[m]$，但不必连续。这样的巡游称为**行程**。形式上，设 $t[1], t[2], \\ldots, t[2n - 1]$ 为某个巡游访问的城市序列。当且仅当 $s$ 是 $t$ 的一个子序列时，该巡游是一个行程。也就是说，可以通过删除 $t$ 中的零个或多个元素并保持剩下元素的顺序，得到 $s$。仍以上面的例子为例，假设 $m = 4$ 且 $s = [3, 5, 2, 7]$，那么巡游 $1 \\to \\textbf{3} \\to \\textbf{5} \\to 3 \\to 4 \\to \\textbf{2} \\to 8 \\to 2 \\to 4 \\to 6 \\to 4 \\to \\textbf{7} \\to 4 \\to 3 \\to 1$ 是一个行程，因为城市 $3, 5, 2, 7$ 按顺序在巡游中被访问（用粗体标记并下划线）。\n\n委员会仍在决定从哪个城市出发，但他们同意：如果存在某个以该城市出发的行程，那么该城市就是一个好的出发选择。请帮助委员会判断对于所有城市，是否存在至少一个以该城市出发的行程。\n", "inputFormat": "你的程序必须从标准输入读取数据。\n\n输入的第一行包含两个用空格分隔的整数 $n$ 和 $m$，分别表示城市数量和事件数量。\n\n接下来的 $n - 1$ 行中每行包含两个用空格分隔的整数。第 $i$ 行包含 $u[i]$ 和 $v[i]$，表示第 $i$ 条道路连接的两个城市。\n\n最后一行输入包含 $m$ 个用空格分隔的整数 $s[1], s[2], \\ldots, s[m]$，表示举办活动的城市。\n", "outputFormat": "你的程序必须将结果打印到标准输出。\n\n输出应包含 $n$ 行。如果存在以城市 $i$ 出发的行程，那么第 $i$ 行应包含一个整数 $1$。否则，输出一个整数 $0$。\n", "hint": "### 子任务\n\n对于所有测试用例，输入将满足以下约束条件：\n\n- $2 \\leq n \\leq 200\\,000$\n- $1 \\leq m \\leq 2n - 1$\n- $1 \\leq u[i], v[i] \\leq n$ 对所有 $1 \\leq i \\leq n - 1$\n- $1 \\leq s[j] \\leq n$ 对所有 $1 \\leq j \\leq m$\n- $s[j] \\neq s[j + 1]$ 对所有 $1 \\leq j \\leq m - 1$\n- 可以通过道路在所有城市对之间移动。\n\n你的程序将在满足以下特殊性质的输入数据上进行测试：\n\n| 子任务 | 分值 | 特殊性质 |\n| :-: | :-: | :-: |\n| $0$ | $0$ | 样例 |\n| $1$ | $7$ | $n \\leq 1000, m = 2n - 1$ |\n| $2$ | $10$ | $u[i] = 1, v[i] = i + 1$ |\n| $3$ | $6$ | $n \\leq 1000, u[i] = i, v[i] = i + 1$ |\n| $4$ | $7$ | $u[i] = i, v[i] = i + 1$ |\n| $5$ | $14$ | $n \\leq 1000, m \\leq 10$ |\n| $6$ | $5$ | $n \\leq 1000$ |\n| $7$ | $19$ | $m \\leq 10$ |\n| $8$ | $11$ | $s[1] = s[m]$ |\n| $9$ | $21$ | 无 |\n\n### 样例 1 解释\n\n此样例适用于子任务 $5, 6, 7, 9$。\n\n这个样例在题目中已经作为示例说明。\n\n存在以城市 $1, 3, 4, 6$ 和 $7$ 开始的行程。在题目中已给出一个以城市 $1$ 开始的行程。\n\n另一方面，可以证明城市 $2, 5$ 和 $8$ 没有任何行程可以以它们为起点。\n\n### 样例 2 解释\n\n此样例适用于子任务 $5, 6, 7, 9$。\n\n这个测试用例与题目示例相同，除了 $s[2]$ 和 $s[3]$ 被交换了。此时不存在任何行程。\n\n### 样例 3 解释\n\n此样例适用于子任务 $1, 2, 5, 6, 7, 8, 9$。\n\n### 样例 4 解释\n\n此样例适用于子任务 $3, 4, 5, 6, 7, 9$。", "locale": "zh-CN"}}}
{"pid": "P12196", "type": "P", "difficulty": 6, "samples": [["3 10 10\n2 5 9\n1 3 1\n4 7 10", "6"], ["10 10 50\n8 8 0\n3 3 0\n6 6 2\n7 7 9\n1 1 50\n5 5 21\n6 6 4\n10 10 4\n10 10 3\n10 10 3", "9"], ["4 17 0\n2 4 1000000000\n6 9 1000000000\n8 13 1000000000\n15 16 1000000000", "4"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "NOISG（新加坡）"], "title": "[NOISG 2025 Prelim] Lasers 2", "background": "", "description": "Pavement has purchased a laser toy from Gohcart (who originally bought it from Rar the Cat). The toy features a grid of $h$ rows and $w$ columns. The rows of the grid are numbered $1$ to $h$ from top to bottom, and the columns of the grid are numbered $1$ to $w$ from left to right.\n\nEach row contains exactly one locked sliding wall. Initially, the wall in the $i$-th row spans columns $l[i]$ to $r[i]$ ($1$-indexed), and can be unlocked for $c[i]$ dollars. Once unlocked, it can be slid horizontally to any position along the $i$-th row, as long as it is aligned to the edges of the grid. No part of the wall can leave the left or right edges of the toy.\n\nEach column contains a downward-facing laser positioned at the top of the column. If any sliding wall is contained in the $i$-th column, it will block the path of the laser in the $i$-th column.\n\nA possible toy with $h = 3$ and $w = 10$ is depicted in the diagram below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4cah8wpf.png)\n\nGiven a total budget of $k$ dollars, Pavement aims to maximise the number of lasers that are not blocked after optimally unlocking and sliding the walls. Determine the maximum number of unblocked lasers he can achieve.\n", "inputFormat": "Your program must read from standard input.\n\nThe first line of input contains three space-separated integers $h, w$ and $k$, describing the number of rows, the number of columns and the budget, respectively.\n\nThe next $h$ lines of input each contain three space-separated integers. The $i$-th of these lines contains $l[i], r[i]$, and $c[i]$, describing the sliding wall in the $i$-th row.\n", "outputFormat": "Your program must print to standard output.\n\nOutput a single integer, the maximum number of unblocked lasers achievable.\n", "hint": "### Subtasks\n\nFor all testcases, the input will satisfy the following bounds:\n\n- $1 \\leq h, w \\leq 2000$\n- $0 \\leq k \\leq 10^9$\n- $1 \\leq l[i] \\leq r[i] \\leq w$ for all $1 \\leq i \\leq h$\n- $0 \\leq c[i] \\leq 10^9$ for all $1 \\leq i \\leq h$\n\nYour program will be tested on input instances that satisfy the following restrictions:\n\n| Subtask | Marks | Additional constraints |\n| :-: | :-: | :-: |\n| $0$ | $0$ | Sample test cases |\n| $1$ | $6$ | $k = 0, c[i] = 10^9$ |\n| $2$ | $9$ | $l[i] = r[i]$ |\n| $3$ | $10$ | $h, w \\leq 18$ |\n| $4$ | $7$ | $h, w \\leq 100, k \\leq 2000$ |\n| $5$ | $15$ | $h, w \\leq 100$ |\n| $6$ | $23$ | $h, w \\leq 500$ |\n| $7$ | $8$ | $r[1] − l[1] = r[2] − l[2] = \\ldots = r[h] − l[h]$ |\n| $8$ | $22$ | No additional constraints |\n\n### Sample Test Case 1 Explanation\n\nThis test case is valid for subtasks $3, 4, 5, 6$, and $8$.\n\nThe laser toy in the above figure corresponds to this test case. Pavement can unlock the first and second sliding walls for a total cost of $9 + 1 = 10$ dollars. He can then slide the first sliding wall such that it spans columns $4$ to $7$, and slide the second sliding wall to span columns $5$ to $7$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/glj93dtp.png)\n\nThis leaves $6$ lasers (in columns $1, 2, 3, 8, 9$, and $10$) unblocked, which is the maximum possible.\n\n### Sample Test Case 2 Explanation\n\nThis test case is valid for subtasks $2$ to $8$.\n\n### Sample Test Case 3 Explanation\n\nThis test case is valid for subtasks $1, 3, 4, 5, 6$, and $8$.", "locale": "en", "translations": {"en": {"title": "[NOISG 2025 Prelim] Lasers 2", "background": "", "description": "Pavement has purchased a laser toy from Gohcart (who originally bought it from Rar the Cat). The toy features a grid of $h$ rows and $w$ columns. The rows of the grid are numbered $1$ to $h$ from top to bottom, and the columns of the grid are numbered $1$ to $w$ from left to right.\n\nEach row contains exactly one locked sliding wall. Initially, the wall in the $i$-th row spans columns $l[i]$ to $r[i]$ ($1$-indexed), and can be unlocked for $c[i]$ dollars. Once unlocked, it can be slid horizontally to any position along the $i$-th row, as long as it is aligned to the edges of the grid. No part of the wall can leave the left or right edges of the toy.\n\nEach column contains a downward-facing laser positioned at the top of the column. If any sliding wall is contained in the $i$-th column, it will block the path of the laser in the $i$-th column.\n\nA possible toy with $h = 3$ and $w = 10$ is depicted in the diagram below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4cah8wpf.png)\n\nGiven a total budget of $k$ dollars, Pavement aims to maximise the number of lasers that are not blocked after optimally unlocking and sliding the walls. Determine the maximum number of unblocked lasers he can achieve.\n", "inputFormat": "Your program must read from standard input.\n\nThe first line of input contains three space-separated integers $h, w$ and $k$, describing the number of rows, the number of columns and the budget, respectively.\n\nThe next $h$ lines of input each contain three space-separated integers. The $i$-th of these lines contains $l[i], r[i]$, and $c[i]$, describing the sliding wall in the $i$-th row.\n", "outputFormat": "Your program must print to standard output.\n\nOutput a single integer, the maximum number of unblocked lasers achievable.\n", "hint": "### Subtasks\n\nFor all testcases, the input will satisfy the following bounds:\n\n- $1 \\leq h, w \\leq 2000$\n- $0 \\leq k \\leq 10^9$\n- $1 \\leq l[i] \\leq r[i] \\leq w$ for all $1 \\leq i \\leq h$\n- $0 \\leq c[i] \\leq 10^9$ for all $1 \\leq i \\leq h$\n\nYour program will be tested on input instances that satisfy the following restrictions:\n\n| Subtask | Marks | Additional constraints |\n| :-: | :-: | :-: |\n| $0$ | $0$ | Sample test cases |\n| $1$ | $6$ | $k = 0, c[i] = 10^9$ |\n| $2$ | $9$ | $l[i] = r[i]$ |\n| $3$ | $10$ | $h, w \\leq 18$ |\n| $4$ | $7$ | $h, w \\leq 100, k \\leq 2000$ |\n| $5$ | $15$ | $h, w \\leq 100$ |\n| $6$ | $23$ | $h, w \\leq 500$ |\n| $7$ | $8$ | $r[1] − l[1] = r[2] − l[2] = \\ldots = r[h] − l[h]$ |\n| $8$ | $22$ | No additional constraints |\n\n### Sample Test Case 1 Explanation\n\nThis test case is valid for subtasks $3, 4, 5, 6$, and $8$.\n\nThe laser toy in the above figure corresponds to this test case. Pavement can unlock the first and second sliding walls for a total cost of $9 + 1 = 10$ dollars. He can then slide the first sliding wall such that it spans columns $4$ to $7$, and slide the second sliding wall to span columns $5$ to $7$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/glj93dtp.png)\n\nThis leaves $6$ lasers (in columns $1, 2, 3, 8, 9$, and $10$) unblocked, which is the maximum possible.\n\n### Sample Test Case 2 Explanation\n\nThis test case is valid for subtasks $2$ to $8$.\n\n### Sample Test Case 3 Explanation\n\nThis test case is valid for subtasks $1, 3, 4, 5, 6$, and $8$.", "locale": "en"}, "zh-CN": {"title": "[NOISG 2025 Prelim] Lasers 2", "background": "", "description": "Pavement 从 Gohcart 那里购买了一个激光玩具（Gohcart 原先是从 Rar the Cat 那里买的）。这个玩具有一个由 $h$ 行 $w$ 列组成的网格。网格的行编号从上到下为 $1$ 到 $h$，列编号从左到右为 $1$ 到 $w$。\n\n每一行恰好包含一个上锁的滑动墙。初始时，第 $i$ 行的墙覆盖第 $l[i]$ 列到第 $r[i]$ 列（从 $1$ 开始编号），解锁它需要花费 $c[i]$ 美元。墙一旦解锁，就可以在第 $i$ 行上水平滑动到任意位置，只要它对齐在网格的边缘内即可。墙的任何部分都不能超出玩具的左边缘或右边缘。\n\n每一列的顶部都有一个朝下的激光。如果某个滑动墙位于第 $i$ 列，那么它将阻挡第 $i$ 列上的激光。\n\n一个可能的玩具示例如下，其中 $h = 3$，$w = 10$：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4cah8wpf.png)\n\n给定总预算 $k$ 美元，Pavement 的目标是在合理解锁并滑动墙壁的情况下，最大化未被阻挡的激光数量。请你确定他最多可以实现多少束未被阻挡的激光。\n", "inputFormat": "你的程序必须从标准输入读取数据。\n\n第一行输入包含三个用空格分隔的整数 $h, w$ 和 $k$，分别表示网格的行数、列数和预算。\n\n接下来的 $h$ 行中，每行包含三个用空格分隔的整数，表示第 $i$ 行的滑动墙的信息，分别是 $l[i], r[i]$ 和 $c[i]$。\n", "outputFormat": "你的程序必须将结果打印到标准输出。\n\n输出一个整数，表示最多可以实现的未被阻挡的激光数量。\n", "hint": "### 子任务\n\n对于所有测试用例，输入将满足以下约束条件：\n\n- $1 \\leq h, w \\leq 2000$\n- $0 \\leq k \\leq 10^9$\n- 对所有 $1 \\leq i \\leq h$，满足 $1 \\leq l[i] \\leq r[i] \\leq w$\n- 对所有 $1 \\leq i \\leq h$，满足 $0 \\leq c[i] \\leq 10^9$\n\n你的程序将在满足以下特殊性质的输入数据上进行测试：\n\n| 子任务 | 分数 | 特殊性质 |\n| :-: | :-: | :-: |\n| $0$ | $0$ | 样例 |\n| $1$ | $6$ | $k = 0, c[i] = 10^9$ |\n| $2$ | $9$ | $l[i] = r[i]$ |\n| $3$ | $10$ | $h, w \\leq 18$ |\n| $4$ | $7$ | $h, w \\leq 100, k \\leq 2000$ |\n| $5$ | $15$ | $h, w \\leq 100$ |\n| $6$ | $23$ | $h, w \\leq 500$ |\n| $7$ | $8$ | $r[1] − l[1] = r[2] − l[2] = \\ldots = r[h] − l[h]$ |\n| $8$ | $22$ | 无 |\n\n### 样例 1 解释\n\n上图的激光玩具正对应该测试用例。Pavement 可以以 $9 + 1 = 10$ 美元的总价解锁第一个和第二个滑动墙。然后他可以将第一个滑动墙滑动到覆盖第 $4$ 到 $7$ 列，将第二个滑动墙滑动到覆盖第 $5$ 到 $7$ 列。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/glj93dtp.png)\n\n这样一来，$6$ 束激光（第 $1, 2, 3, 8, 9, 10$ 列）未被阻挡，这是能够实现的最大数量。\n\n此样例适用于子任务 $3, 4, 5, 6, 8$。\n\n### 样例 2 解释\n\n此样例适用于子任务 $2$ 到 $8$。\n\n### 样例 3 解释\n\n此样例适用于子任务 $1, 3, 4, 5, 6, 8$。", "locale": "zh-CN"}}}
{"pid": "P12197", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [1000], "memory": [524288]}, "tags": ["Special Judge", "哈希 hashing", "构造"], "title": "Hash Killer I", "background": "", "description": "这天天气不错，hzhwcmhf 神犇给 VFleaKing 出了一道题：\n\n给你一个长度为 $n$ 的字符串 $s$，求有多少个不同的长度为 $l$ 的连续子串。\n\n两个字符串被认为是不同的当且仅当某个位置上的字符不同。\n\nVFleaKing 一看觉得这不是 Hash 的裸题么！于是果断写了哈希 + 排序。\n\n而 hzhwcmhf 神犇心里自然知道，这题就是后缀数组的 height 中 $< l$ 的个数 +1，就是后缀自动机上代表的长度区间包含 $l$ 的结点个数，就是后缀树深度为 $l$ 的结点的数量。\n\n但是 hzhwcmhf 神犇看了看 VFleaKing 的做法表示非常汗。于是想卡掉他。\n\nVFleaKing 使用的是字典序哈希，其代码大致如下：\n\n```cpp\nu64 val = 0;\nfor (int i = 0; i < l; i++)\n    val = val * base + s[i] - 'a';\n```\n\nu64 是无符号 int64，范围是 $[0, 2^{64})$。VFleaKing 让 val 自然溢出。\n\nbase 是一个常量，VFleaKing 会根据心情决定其值。\n\nVFleaKing 还求出来了 $base^l$，即 base 的 $l$ 次方，这样就能方便地求出所有长度为 $l$ 的子串的哈希值。\n\n然后 VFleaKing 给哈希值排序，去重，求出有多少个不同的哈希值，把这个数作为结果。\n\n其算法的 C++ 代码如下:\n\n```cpp\ntypedef unsigned long long u64;\nconst int MaxN = 100000;\ninline int hash_handle(const char *s, const int &n, const int &l, const int &base)\n{\n    u64 hash_pow_l = 1;\n    for (int i = 1; i <= l; i++)\n        hash_pow_l *= base;\n    int li_n = 0;\n    static u64 li[MaxN];\n    u64 val = 0;\n    for (int i = 0; i < l; i++)\n        val = val * base + s[i] - 'a';\n    li[li_n++] = val;\n    for (int i = l; i < n; i++)\n    {\n        val = val * base + s[i] - 'a';\n        val -= (s[i - l] - 'a') * hash_pow_l;\n        li[li_n++] = val;\n    }\n    sort(li, li + li_n);\n    li_n = unique(li, li + li_n) - li;\n    return li_n;\n}\n```\n\nhzhwcmhf 当然知道怎么卡啦！但是他想考考你。", "inputFormat": "", "outputFormat": "你需要输出一组数据使得 VFleaKing 的代码 WA 掉。我们会使用 Special Judge 检查你的结果的正确性。\n\n输出文件共两行。\n\n第一行两个用空格隔开的数 $n, l$。\n\n第二行是一个长度为 $n$ 的字符串。只能包含小写字母。\n\n需要保证 $1 \\le n \\le 10^5, 1 \\le l \\le n$，不符合以上格式会 WA。不要有多余字符，很可能导致你 WA。", "hint": "本题的评分为：在 SPJ 中预设了 10 个 base 用作测试，每让一个 base 出现哈希冲突记 10 分，满分为 100 分。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Hash Killer I", "background": "", "description": "这天天气不错，hzhwcmhf 神犇给 VFleaKing 出了一道题：\n\n给你一个长度为 $n$ 的字符串 $s$，求有多少个不同的长度为 $l$ 的连续子串。\n\n两个字符串被认为是不同的当且仅当某个位置上的字符不同。\n\nVFleaKing 一看觉得这不是 Hash 的裸题么！于是果断写了哈希 + 排序。\n\n而 hzhwcmhf 神犇心里自然知道，这题就是后缀数组的 height 中 $< l$ 的个数 +1，就是后缀自动机上代表的长度区间包含 $l$ 的结点个数，就是后缀树深度为 $l$ 的结点的数量。\n\n但是 hzhwcmhf 神犇看了看 VFleaKing 的做法表示非常汗。于是想卡掉他。\n\nVFleaKing 使用的是字典序哈希，其代码大致如下：\n\n```cpp\nu64 val = 0;\nfor (int i = 0; i < l; i++)\n    val = val * base + s[i] - 'a';\n```\n\nu64 是无符号 int64，范围是 $[0, 2^{64})$。VFleaKing 让 val 自然溢出。\n\nbase 是一个常量，VFleaKing 会根据心情决定其值。\n\nVFleaKing 还求出来了 $base^l$，即 base 的 $l$ 次方，这样就能方便地求出所有长度为 $l$ 的子串的哈希值。\n\n然后 VFleaKing 给哈希值排序，去重，求出有多少个不同的哈希值，把这个数作为结果。\n\n其算法的 C++ 代码如下:\n\n```cpp\ntypedef unsigned long long u64;\nconst int MaxN = 100000;\ninline int hash_handle(const char *s, const int &n, const int &l, const int &base)\n{\n    u64 hash_pow_l = 1;\n    for (int i = 1; i <= l; i++)\n        hash_pow_l *= base;\n    int li_n = 0;\n    static u64 li[MaxN];\n    u64 val = 0;\n    for (int i = 0; i < l; i++)\n        val = val * base + s[i] - 'a';\n    li[li_n++] = val;\n    for (int i = l; i < n; i++)\n    {\n        val = val * base + s[i] - 'a';\n        val -= (s[i - l] - 'a') * hash_pow_l;\n        li[li_n++] = val;\n    }\n    sort(li, li + li_n);\n    li_n = unique(li, li + li_n) - li;\n    return li_n;\n}\n```\n\nhzhwcmhf 当然知道怎么卡啦！但是他想考考你。", "inputFormat": "", "outputFormat": "你需要输出一组数据使得 VFleaKing 的代码 WA 掉。我们会使用 Special Judge 检查你的结果的正确性。\n\n输出文件共两行。\n\n第一行两个用空格隔开的数 $n, l$。\n\n第二行是一个长度为 $n$ 的字符串。只能包含小写字母。\n\n需要保证 $1 \\le n \\le 10^5, 1 \\le l \\le n$，不符合以上格式会 WA。不要有多余字符，很可能导致你 WA。", "hint": "本题的评分为：在 SPJ 中预设了 10 个 base 用作测试，每让一个 base 出现哈希冲突记 10 分，满分为 100 分。", "locale": "zh-CN"}}}
{"pid": "P12198", "type": "P", "difficulty": 5, "samples": [], "limits": {"time": [1000], "memory": [524288]}, "tags": ["Special Judge", "哈希 hashing", "概率论"], "title": "Hash Killer II", "background": "", "description": "这天天气不错，hzhwcmhf 神犇给 VFleaKing 出了一道题：\n\n给你一个长度为 $n$ 的字符串 $s$，求有多少个不同的长度为 $l$ 的连续子串。\n\n两个字符串被认为是不同的当且仅当某个位置上的字符不同。\n\nVFleaKing 一看觉得这不是 Hash 的裸题么！于是果断写了哈希 + 排序。\n\n而 hzhwcmhf 神犇心里自然知道，这题就是后缀数组的 height 中 $< l$ 的个数 +1，就是后缀自动机上代表的长度区间包含 $l$ 的结点个数，就是后缀树深度为 $l$ 的结点的数量。\n\n但是 hzhwcmhf 神犇看了看 VFleaKing 的做法表示非常汗。于是想卡掉他。\n\nVFleaKing 使用的是字典序哈希，其代码大致如下：\n\n```cpp\nu64 val = 0;\nfor (int i = 0; i < l; i++)\n    val = (val * base + s[i] - 'a') % MOD;\n```\n\nu64 是无符号 int64，范围是 $[0, 2^{64})$。VFleaKing 让 val 自然溢出。\n\nbase 是一个常量，VFleaKing 会根据心情决定其值。\n\n$\\text{MOD}=10^9+7$\n\nVFleaKing 还求出来了 $base^l \\bmod \\text{MOD}$，即 base 的 $l$ 次方除以 $\\text{MOD}$ 的余数，这样就能方便地求出所有长度为 $l$ 的子串的哈希值。\n\n然后 VFleaKing 给哈希值排序，去重，求出有多少个不同的哈希值，把这个数作为结果。\n\n其算法的 C++ 代码如下:\n\n```cpp\ntypedef unsigned long long u64;\nconst int MaxN = 100000;\ninline int hash_handle(const char *s, const int &n, const int &l, const int &base)\n{\n    const int Mod = 1000000007;\n    u64 hash_pow_l = 1;\n    for (int i = 1; i <= l; i++)\n        hash_pow_l = (hash_pow_l * base) % Mod;\n    int li_n = 0;\n    static int li[MaxN];\n    u64 val = 0;\n    for (int i = 0; i < l; i++)\n        val = (val * base + s[i] - 'a') % Mod;\n    li[li_n++] = val;\n    for (int i = l; i < n; i++)\n    {\n        val = (val * base + s[i] - 'a') % Mod;\n        val = (val + Mod - ((s[i - l] - 'a') * hash_pow_l) % Mod) % Mod;\n        li[li_n++] = val;\n    }\n    sort(li, li + li_n);\n    li_n = unique(li, li + li_n) - li;\n    return li_n;\n}\n\n```\n\nhzhwcmhf 当然知道怎么卡啦！但是他想考考你。", "inputFormat": "", "outputFormat": "你需要输出一组数据使得 VFleaKing 的代码 WA 掉。我们会使用 Special Judge 检查你的结果的正确性。\n\n输出文件共两行。\n\n第一行两个用空格隔开的数 $n, l$。\n\n第二行是一个长度为 $n$ 的字符串。只能包含小写字母。\n\n需要保证 $1 \\le n \\le 10^5, 1 \\le l \\le n$，不符合以上格式会 WA。不要有多余字符，很可能导致你 WA。", "hint": "本题的评分为：在 SPJ 中预设了 10 个 base 用作测试，每让一个 base 出现哈希冲突记 10 分，满分为 100 分。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Hash Killer II", "background": "", "description": "这天天气不错，hzhwcmhf 神犇给 VFleaKing 出了一道题：\n\n给你一个长度为 $n$ 的字符串 $s$，求有多少个不同的长度为 $l$ 的连续子串。\n\n两个字符串被认为是不同的当且仅当某个位置上的字符不同。\n\nVFleaKing 一看觉得这不是 Hash 的裸题么！于是果断写了哈希 + 排序。\n\n而 hzhwcmhf 神犇心里自然知道，这题就是后缀数组的 height 中 $< l$ 的个数 +1，就是后缀自动机上代表的长度区间包含 $l$ 的结点个数，就是后缀树深度为 $l$ 的结点的数量。\n\n但是 hzhwcmhf 神犇看了看 VFleaKing 的做法表示非常汗。于是想卡掉他。\n\nVFleaKing 使用的是字典序哈希，其代码大致如下：\n\n```cpp\nu64 val = 0;\nfor (int i = 0; i < l; i++)\n    val = (val * base + s[i] - 'a') % MOD;\n```\n\nu64 是无符号 int64，范围是 $[0, 2^{64})$。VFleaKing 让 val 自然溢出。\n\nbase 是一个常量，VFleaKing 会根据心情决定其值。\n\n$\\text{MOD}=10^9+7$\n\nVFleaKing 还求出来了 $base^l \\bmod \\text{MOD}$，即 base 的 $l$ 次方除以 $\\text{MOD}$ 的余数，这样就能方便地求出所有长度为 $l$ 的子串的哈希值。\n\n然后 VFleaKing 给哈希值排序，去重，求出有多少个不同的哈希值，把这个数作为结果。\n\n其算法的 C++ 代码如下:\n\n```cpp\ntypedef unsigned long long u64;\nconst int MaxN = 100000;\ninline int hash_handle(const char *s, const int &n, const int &l, const int &base)\n{\n    const int Mod = 1000000007;\n    u64 hash_pow_l = 1;\n    for (int i = 1; i <= l; i++)\n        hash_pow_l = (hash_pow_l * base) % Mod;\n    int li_n = 0;\n    static int li[MaxN];\n    u64 val = 0;\n    for (int i = 0; i < l; i++)\n        val = (val * base + s[i] - 'a') % Mod;\n    li[li_n++] = val;\n    for (int i = l; i < n; i++)\n    {\n        val = (val * base + s[i] - 'a') % Mod;\n        val = (val + Mod - ((s[i - l] - 'a') * hash_pow_l) % Mod) % Mod;\n        li[li_n++] = val;\n    }\n    sort(li, li + li_n);\n    li_n = unique(li, li + li_n) - li;\n    return li_n;\n}\n\n```\n\nhzhwcmhf 当然知道怎么卡啦！但是他想考考你。", "inputFormat": "", "outputFormat": "你需要输出一组数据使得 VFleaKing 的代码 WA 掉。我们会使用 Special Judge 检查你的结果的正确性。\n\n输出文件共两行。\n\n第一行两个用空格隔开的数 $n, l$。\n\n第二行是一个长度为 $n$ 的字符串。只能包含小写字母。\n\n需要保证 $1 \\le n \\le 10^5, 1 \\le l \\le n$，不符合以上格式会 WA。不要有多余字符，很可能导致你 WA。", "hint": "本题的评分为：在 SPJ 中预设了 10 个 base 用作测试，每让一个 base 出现哈希冲突记 10 分，满分为 100 分。", "locale": "zh-CN"}}}
{"pid": "P12199", "type": "P", "difficulty": 0, "samples": [], "limits": {"time": [10000], "memory": [2097152]}, "tags": ["Special Judge"], "title": "Hash Killer III【Open Problem】", "background": "[图灵奖官网](https://amturing.acm.org/)。", "description": "这天天气不错，hzhwcmhf 神犇给 VFleaKing 出了一道题：\n\n给你一个长度为 $n$ 的字符串 $s$，求有多少个不同的长度为 $l$ 的连续子串。\n\n两个字符串被认为是不同的当且仅当某个位置上的字符不同。\n\nVFleaKing 一看觉得这不是 Hash 的裸题么！于是果断写了哈希 + 排序。\n\n而 hzhwcmhf 神犇心里自然知道，这题就是后缀数组的 height 中 $< l$ 的个数 +1，就是后缀自动机上代表的长度区间包含 $l$ 的结点个数，就是后缀树深度为 $l$ 的结点的数量。\n\n但是 hzhwcmhf 神犇看了看 VFleaKing 的做法表示非常汗。于是想卡掉他。\n\nVFleaKing 使用的是字典序哈希，其代码大致如下：\n\n```cpp\nu64 val = 0;\nfor (int i = 0; i < l; i++)\n    val = (val * base + s[i] - 'a') % MOD;\n```\n\nu64 是无符号 int64，范围是 $[0, 2^{64})$。VFleaKing 让 val 自然溢出。\n\nbase 是一个常量，VFleaKing 会根据心情决定其值。\n\n$\\text{MOD}$ 是 `int32` 范围内的素数，即 $\\text{MOD}$ 的范围是 $[0,2^{31})$，且是个素数。VFleaKing 还求出来了 $base^l \\bmod \\text{MOD}$，即 base 的 $l$ 次方除以 $\\text{MOD}$ 的余数，这样就能方便地求出所有长度为 $l$ 的子串的哈希值。\n\n然后 VFleaKing 给哈希值排序，去重，求出有多少个不同的哈希值，把这个数作为结果。\n\n但是 VFleaKing 意识到这样会被坑，于是采用了两个 $\\text{MOD}$ 来解决问题。两个 $\\text{MOD}$ 模出来的值都相同才被认为是相同。\n\n其算法的 C++ 代码如下:\n\n```cpp\ntypedef unsigned long long u64;\ntypedef pair<int, int> PII;\nconst int MaxN = 100000;\ninline int hash_handle(\nconst char *s, const int &n, const int &l, const int &base,\nconst int &mod1, const int &mod2)\n{\n    int li_n;\n    static PII li[MaxN];\n    u64 hash_pow_l;\n    u64 val;\n    hash_pow_l = 1;\n    for (int i = 1; i <= l; i++)\n        hash_pow_l = (hash_pow_l * base) % mod1;\n    li_n = 0;\n    val = 0;\n    for (int i = 0; i < l; i++)\n        val = (val * base + s[i] - 'a') % mod1;\n    li[li_n++].first = val;\n    for (int i = l; i < n; i++)\n    {\n        val = (val * base + s[i] - 'a') % mod1;\n        val = (val + mod1 - ((s[i - l] - 'a') * hash_pow_l) % mod1) % mod1; li[li_n++].first = val;\n    }\n    hash_pow_l = 1;\n    for (int i = 1; i <= l; i++)\n        hash_pow_l = (hash_pow_l * base) % mod2;\n    li_n = 0;\n    val = 0;\n    for (int i = 0; i < l; i++)\n        val = (val * base + s[i] - 'a') % mod2;\n    li[li_n++].second = val;\n    for (int i = l; i < n; i++)\n    {\n        val = (val * base + s[i] - 'a') % mod2;\n        val = (val + mod2 - ((s[i - l] - 'a') * hash_pow_l) % mod2) % mod2;\n        li[li_n++].second = val;\n    }\n    sort(li, li + li_n);\n    li_n = unique(li, li + li_n) - li;\n    return li_n;\n}\n```\n\nhzhwcmhf 当然知道怎么卡啦！但是他想考考你。", "inputFormat": "", "outputFormat": "你需要输出一组数据使得 VFleaKing 的代码 WA 掉。我们会使用 Special Judge 检查你的结果的正确性。\n\n输出文件共两行。\n\n第一行两个用空格隔开的数 $n, l$。\n\n第二行是一个长度为 $n$ 的字符串。只能包含小写字母。\n\n需要保证 $1 \\le n \\le 10^5, 1 \\le l \\le n$，不符合以上格式会 WA。不要有多余字符，很可能导致你 WA。", "hint": "本题的评分为：SPJ 会随机生成 $20$ 个 base 和 $20$ 组双哈希模数，且保证均为质数，且不会退化成单哈希。每让一个 base 出现哈希冲突记 5 分，满分为 100 分。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Hash Killer III【Open Problem】", "background": "[图灵奖官网](https://amturing.acm.org/)。", "description": "这天天气不错，hzhwcmhf 神犇给 VFleaKing 出了一道题：\n\n给你一个长度为 $n$ 的字符串 $s$，求有多少个不同的长度为 $l$ 的连续子串。\n\n两个字符串被认为是不同的当且仅当某个位置上的字符不同。\n\nVFleaKing 一看觉得这不是 Hash 的裸题么！于是果断写了哈希 + 排序。\n\n而 hzhwcmhf 神犇心里自然知道，这题就是后缀数组的 height 中 $< l$ 的个数 +1，就是后缀自动机上代表的长度区间包含 $l$ 的结点个数，就是后缀树深度为 $l$ 的结点的数量。\n\n但是 hzhwcmhf 神犇看了看 VFleaKing 的做法表示非常汗。于是想卡掉他。\n\nVFleaKing 使用的是字典序哈希，其代码大致如下：\n\n```cpp\nu64 val = 0;\nfor (int i = 0; i < l; i++)\n    val = (val * base + s[i] - 'a') % MOD;\n```\n\nu64 是无符号 int64，范围是 $[0, 2^{64})$。VFleaKing 让 val 自然溢出。\n\nbase 是一个常量，VFleaKing 会根据心情决定其值。\n\n$\\text{MOD}$ 是 `int32` 范围内的素数，即 $\\text{MOD}$ 的范围是 $[0,2^{31})$，且是个素数。VFleaKing 还求出来了 $base^l \\bmod \\text{MOD}$，即 base 的 $l$ 次方除以 $\\text{MOD}$ 的余数，这样就能方便地求出所有长度为 $l$ 的子串的哈希值。\n\n然后 VFleaKing 给哈希值排序，去重，求出有多少个不同的哈希值，把这个数作为结果。\n\n但是 VFleaKing 意识到这样会被坑，于是采用了两个 $\\text{MOD}$ 来解决问题。两个 $\\text{MOD}$ 模出来的值都相同才被认为是相同。\n\n其算法的 C++ 代码如下:\n\n```cpp\ntypedef unsigned long long u64;\ntypedef pair<int, int> PII;\nconst int MaxN = 100000;\ninline int hash_handle(\nconst char *s, const int &n, const int &l, const int &base,\nconst int &mod1, const int &mod2)\n{\n    int li_n;\n    static PII li[MaxN];\n    u64 hash_pow_l;\n    u64 val;\n    hash_pow_l = 1;\n    for (int i = 1; i <= l; i++)\n        hash_pow_l = (hash_pow_l * base) % mod1;\n    li_n = 0;\n    val = 0;\n    for (int i = 0; i < l; i++)\n        val = (val * base + s[i] - 'a') % mod1;\n    li[li_n++].first = val;\n    for (int i = l; i < n; i++)\n    {\n        val = (val * base + s[i] - 'a') % mod1;\n        val = (val + mod1 - ((s[i - l] - 'a') * hash_pow_l) % mod1) % mod1; li[li_n++].first = val;\n    }\n    hash_pow_l = 1;\n    for (int i = 1; i <= l; i++)\n        hash_pow_l = (hash_pow_l * base) % mod2;\n    li_n = 0;\n    val = 0;\n    for (int i = 0; i < l; i++)\n        val = (val * base + s[i] - 'a') % mod2;\n    li[li_n++].second = val;\n    for (int i = l; i < n; i++)\n    {\n        val = (val * base + s[i] - 'a') % mod2;\n        val = (val + mod2 - ((s[i - l] - 'a') * hash_pow_l) % mod2) % mod2;\n        li[li_n++].second = val;\n    }\n    sort(li, li + li_n);\n    li_n = unique(li, li + li_n) - li;\n    return li_n;\n}\n```\n\nhzhwcmhf 当然知道怎么卡啦！但是他想考考你。", "inputFormat": "", "outputFormat": "你需要输出一组数据使得 VFleaKing 的代码 WA 掉。我们会使用 Special Judge 检查你的结果的正确性。\n\n输出文件共两行。\n\n第一行两个用空格隔开的数 $n, l$。\n\n第二行是一个长度为 $n$ 的字符串。只能包含小写字母。\n\n需要保证 $1 \\le n \\le 10^5, 1 \\le l \\le n$，不符合以上格式会 WA。不要有多余字符，很可能导致你 WA。", "hint": "本题的评分为：SPJ 会随机生成 $20$ 个 base 和 $20$ 组双哈希模数，且保证均为质数，且不会退化成单哈希。每让一个 base 出现哈希冲突记 5 分，满分为 100 分。", "locale": "zh-CN"}}}
{"pid": "P12200", "type": "P", "difficulty": 5, "samples": [["37 131", "bbbbbbbbbbbbbbbb\ncaabbbbbbcbbbbbb"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "Special Judge"], "title": "Hash Killer Extra", "background": "本题为给定 base 和 mod 的情况下卡单哈希，参考了 [北航 2024 国庆思维训练特别赛](https://accoding.buaa.edu.cn/contest-ng/index.html#/1109)，向出题人表示感谢。", "description": "请你找到任意两个字符串，使它们满足以下条件：\n- 仅由小写字母 $\\tt{a}\\sim \\tt{z}$ 组成；\n- 两者长度相同，且长度 $n$ 满足：$1\\leq n\\leq 10^4$；\n- 两者不完全相同，却在给定的 $b,p$ 下有着一致的哈希值；\n\n本题中参考的 hash 代码为：\n\n```cpp\nint strhash(const string &s, int b, int p) {\n    int val = 0;\n    for (int i = 0; i < s.length(); i++)\n        val = (1ll * val * b + s[i] - 'a' + 1) % p;\n    return val;\n}\n```", "inputFormat": "输入两个正整数 $b,p$。", "outputFormat": "输出两行，表示满足题目条件的两个字符串。对于同一组测试数据输出可能有很多种，任意一组符合条件的字符串均为可接受的答案。", "hint": "### 数据范围\n\n- 对于 $40\\%$ 的测试数据，$31\\leq b<p\\leq 10007$；\n- 对于所有测试数据，$31\\leq b<p\\leq 10^9+7$；\n\n测试数据保证 $p$ 一定是质数。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Hash Killer Extra", "background": "本题为给定 base 和 mod 的情况下卡单哈希，参考了 [北航 2024 国庆思维训练特别赛](https://accoding.buaa.edu.cn/contest-ng/index.html#/1109)，向出题人表示感谢。", "description": "请你找到任意两个字符串，使它们满足以下条件：\n- 仅由小写字母 $\\tt{a}\\sim \\tt{z}$ 组成；\n- 两者长度相同，且长度 $n$ 满足：$1\\leq n\\leq 10^4$；\n- 两者不完全相同，却在给定的 $b,p$ 下有着一致的哈希值；\n\n本题中参考的 hash 代码为：\n\n```cpp\nint strhash(const string &s, int b, int p) {\n    int val = 0;\n    for (int i = 0; i < s.length(); i++)\n        val = (1ll * val * b + s[i] - 'a' + 1) % p;\n    return val;\n}\n```", "inputFormat": "输入两个正整数 $b,p$。", "outputFormat": "输出两行，表示满足题目条件的两个字符串。对于同一组测试数据输出可能有很多种，任意一组符合条件的字符串均为可接受的答案。", "hint": "### 数据范围\n\n- 对于 $40\\%$ 的测试数据，$31\\leq b<p\\leq 10007$；\n- 对于所有测试数据，$31\\leq b<p\\leq 10^9+7$；\n\n测试数据保证 $p$ 一定是质数。", "locale": "zh-CN"}}}
{"pid": "P12201", "type": "P", "difficulty": 6, "samples": [["31 131\n37 233", "ylnylnaylaylylnylnaylylnaylyln\nylnaylaylylnylnaylylnaylylnyln"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "Special Judge", "随机化"], "title": "Hash Killer Phantasm", "background": "本题为给定 base 和 mod 的情况下卡双哈希，参考了 [北航 2024 国庆思维训练特别赛](https://accoding.buaa.edu.cn/contest-ng/index.html#/1109)，向出题人表示感谢。", "description": "请你找到任意两个字符串，使它们满足以下条件：\n- 仅由小写字母 $\\tt{a}\\sim \\tt{z}$ 组成；\n- 两者长度相同，且长度 $n$ 满足：$1\\leq n\\leq 10^4$；\n- 两者不完全相同，却在给定的 $(b_1,p_1)$ 和 $(b_2,p_2)$ 下有着一致的哈希值；\n\n本题中参考的 hash 代码为：\n\n```cpp\nint strhash(const string &s, int b, int p) {\n    int val = 0;\n    for (int i = 0; i < s.length(); i++)\n        val = (1ll * val * b + s[i] - 'a' + 1) % p;\n    return val;\n}\n```", "inputFormat": "输入两行，每行 $2$ 个正整数 $b,p$。", "outputFormat": "输出两行，表示满足题目条件的两个字符串。对于同一组测试数据输出可能有很多种，任意一组符合条件的字符串均为可接受的答案。", "hint": "### 数据范围\n\n- 对于 $40\\%$ 的测试数据，$31\\leq b_1,b_2<p_1,p_2\\leq 10007$；\n- 对于所有测试数据，$31\\leq b_1,b_2<p_1,p_2\\leq 10^9+7$；\n\n测试数据保证 $p$ 一定是质数。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Hash Killer Phantasm", "background": "本题为给定 base 和 mod 的情况下卡双哈希，参考了 [北航 2024 国庆思维训练特别赛](https://accoding.buaa.edu.cn/contest-ng/index.html#/1109)，向出题人表示感谢。", "description": "请你找到任意两个字符串，使它们满足以下条件：\n- 仅由小写字母 $\\tt{a}\\sim \\tt{z}$ 组成；\n- 两者长度相同，且长度 $n$ 满足：$1\\leq n\\leq 10^4$；\n- 两者不完全相同，却在给定的 $(b_1,p_1)$ 和 $(b_2,p_2)$ 下有着一致的哈希值；\n\n本题中参考的 hash 代码为：\n\n```cpp\nint strhash(const string &s, int b, int p) {\n    int val = 0;\n    for (int i = 0; i < s.length(); i++)\n        val = (1ll * val * b + s[i] - 'a' + 1) % p;\n    return val;\n}\n```", "inputFormat": "输入两行，每行 $2$ 个正整数 $b,p$。", "outputFormat": "输出两行，表示满足题目条件的两个字符串。对于同一组测试数据输出可能有很多种，任意一组符合条件的字符串均为可接受的答案。", "hint": "### 数据范围\n\n- 对于 $40\\%$ 的测试数据，$31\\leq b_1,b_2<p_1,p_2\\leq 10007$；\n- 对于所有测试数据，$31\\leq b_1,b_2<p_1,p_2\\leq 10^9+7$；\n\n测试数据保证 $p$ 一定是质数。", "locale": "zh-CN"}}}
{"pid": "P12202", "type": "P", "difficulty": 5, "samples": [], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "交互题", "Special Judge", "COI（克罗地亚）"], "title": "[COI 2022] 回文子串 / Madioničar", "background": "译自 [HIO (COI) 2022](https://hsin.hr/hio2022/zadaci/) T1。", "description": "**这是一道交互题**。本题中，交互库是非自适应的。\n\n魔术师 Malnar 需要确定志愿者想象的单词的最长回文子串长度。单词由 $N$ 个小写字母组成，你需要通过以下交互过程推断出最长回文子串的长度 $L$：\n\n1. **提问**：输出 `? l r`，询问区间 $[l, r]$ 的子串是否是回文，程序会返回 $1$（是回文）或 $0$（不是回文），最多允许提问 $200000$ 次。\n\n2. **回答**：确定最长回文子串长度 $L$ 后，输出 `! L` 并结束程序。\n\n### 交互规则\n- 所有输出后需立即刷新缓冲区（例如 Python 使用 `flush=True`）。\n- 输入中的 $N$ 表示单词长度，所有区间 $[l, r]$ 需满足 $1 \\leq l \\leq r \\leq N$。\n", "inputFormat": "输入仅在第一行包含一个整数 $N$，表示单词长度，后续交互通过提问和回答进行（详见样例）。", "outputFormat": "- 每行提问格式为 `? l r`。\n- 最终答案格式为 `! L`。", "hint": "### 输入输出样例\n\n**交互过程：**\n\n| 程序输出     | 输入（程序回答） | 说明                                                                 |\n|--------------|------------------|----------------------------------------------------------------------|\n| `? 1 1`      | `1`              | 询问单字符子串 `n` 是否是回文（是）。                               |\n| `? 2 3`      | `0`              | 询问子串 `ev` 是否是回文（否）。                                    |\n| `? 2 4`      | `1`              | 询问子串 `eve` 是否是回文（是）。                                   |\n| `? 3 5`      | `0`              | 询问子串 `ven` 是否是回文（否）。                                   |\n| `? 1 5`      | `1`              | 询问整个单词 `neven` 是否是回文（是）。                            |\n| `! 5`        |                  | 确定最长回文子串长度为 5。                                          | \n\n**样例解释：**\n\n志愿者想象的单词为 neven，其最长回文子串为整个字符串，长度为 $5$。\n\n### 数据规模与约定\n对于所有数据，满足 $1 \\leq N \\leq 100000$。\n\n**子任务及分值**：\n\n| 子任务 | 分值 | 限制条件                                      |\n|--------|------|-----------------------------------------------|\n| $1$      | $13$  | $N \\leq 7500$                                 |\n| $2$      | $25$   | $N \\leq 65000$                                |\n| $3$      | $25$   | $N \\leq 100000$，单词仅由 `a` 和 `b` 组成     |\n| $4$      | $37$   | $N \\leq 100000$，无额外限制                   |\n\n### 提示\n- 回文的定义为正读和反读相同的字符串。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COI 2022] 回文子串 / Madioničar", "background": "译自 [HIO (COI) 2022](https://hsin.hr/hio2022/zadaci/) T1。", "description": "**这是一道交互题**。本题中，交互库是非自适应的。\n\n魔术师 Malnar 需要确定志愿者想象的单词的最长回文子串长度。单词由 $N$ 个小写字母组成，你需要通过以下交互过程推断出最长回文子串的长度 $L$：\n\n1. **提问**：输出 `? l r`，询问区间 $[l, r]$ 的子串是否是回文，程序会返回 $1$（是回文）或 $0$（不是回文），最多允许提问 $200000$ 次。\n\n2. **回答**：确定最长回文子串长度 $L$ 后，输出 `! L` 并结束程序。\n\n### 交互规则\n- 所有输出后需立即刷新缓冲区（例如 Python 使用 `flush=True`）。\n- 输入中的 $N$ 表示单词长度，所有区间 $[l, r]$ 需满足 $1 \\leq l \\leq r \\leq N$。\n", "inputFormat": "输入仅在第一行包含一个整数 $N$，表示单词长度，后续交互通过提问和回答进行（详见样例）。", "outputFormat": "- 每行提问格式为 `? l r`。\n- 最终答案格式为 `! L`。", "hint": "### 输入输出样例\n\n**交互过程：**\n\n| 程序输出     | 输入（程序回答） | 说明                                                                 |\n|--------------|------------------|----------------------------------------------------------------------|\n| `? 1 1`      | `1`              | 询问单字符子串 `n` 是否是回文（是）。                               |\n| `? 2 3`      | `0`              | 询问子串 `ev` 是否是回文（否）。                                    |\n| `? 2 4`      | `1`              | 询问子串 `eve` 是否是回文（是）。                                   |\n| `? 3 5`      | `0`              | 询问子串 `ven` 是否是回文（否）。                                   |\n| `? 1 5`      | `1`              | 询问整个单词 `neven` 是否是回文（是）。                            |\n| `! 5`        |                  | 确定最长回文子串长度为 5。                                          | \n\n**样例解释：**\n\n志愿者想象的单词为 neven，其最长回文子串为整个字符串，长度为 $5$。\n\n### 数据规模与约定\n对于所有数据，满足 $1 \\leq N \\leq 100000$。\n\n**子任务及分值**：\n\n| 子任务 | 分值 | 限制条件                                      |\n|--------|------|-----------------------------------------------|\n| $1$      | $13$  | $N \\leq 7500$                                 |\n| $2$      | $25$   | $N \\leq 65000$                                |\n| $3$      | $25$   | $N \\leq 100000$，单词仅由 `a` 和 `b` 组成     |\n| $4$      | $37$   | $N \\leq 100000$，无额外限制                   |\n\n### 提示\n- 回文的定义为正读和反读相同的字符串。", "locale": "zh-CN"}}}
