{"pid": "P11324", "type": "P", "difficulty": 5, "samples": [["4 3\n4 6 2 7\n1 2 5\n2 3 2\n2 4 4\n1 1\n3 4\n3 3", "12\n10\n6"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "倍增", "O2优化", "树链剖分", "梦熊比赛"], "title": "【MX-S7-T2】「SMOI-R2」Speaker", "background": "原题链接：<https://oier.team/problems/S7B>。", "description": "M 国有 $n$ 个城市和 $n - 1$ 条双向道路，城市编号为 $1,2,\\dots,n$，**保证这些城市连通**，即**构成了一棵树**。其中，第 $i$ 条道路连接了城市 $u_i$ 和城市 $v_i$，路费为 $w_i$。你是一名演说家，每天都要在 M 国举办三场演讲，每场演讲都会在某一个城市进行。在城市 $i$ 举办一场演讲可以获得 $c_i$ 的收入，**同一天内可以在同一个城市举办多场演讲**。\n\n接下来有 $q$ 天，第 $i$ 天的安排如下：你的第一场演讲必须在城市 $x_i$ 举行，第三场演讲必须在城市 $y_i$ 举行，而第二场演讲所在的城市可以自由选择。设第二场演讲所在的城市为 $z_i$，你需要向交通管理局支付经过 $x_i \\to z_i$ 路径以及 $z_i \\to y_i$ 路径上所有道路的路费。**注意，一条道路如果被多次经过，每次经过都需要支付相应的路费**。\n\n对于每一天，请计算当天可以获得的最大利润，即**总收入减去总路费的最大值**。**注意，答案可能是负数**。", "inputFormat": "第一行，两个正整数 $n,q$。\n\n第二行，$n$ 个非负整数 $c_1,c_2,\\dots,c_n$。\n\n接下来 $n - 1$ 行，每行三个非负整数 $u_i,v_i,w_i$，表示第 $i$ 条道路。\n\n接下来 $q$ 行，每行两个正整数 $x_i,y_i$，表示第 $i$ 天的安排。", "outputFormat": "$q$ 行，每行一个整数，表示第 $i$ 天的最大利润。", "hint": "**【样例解释 #1】**\n\n+ 第一天选择城市 $1$，答案为 $4 + 4 + 4 - 0 - 0 = 12$。\n+ 第二天选择城市 $4$，答案为 $2 + 7 + 7 - 6 - 0 = 10$。\n+ 第三天选择城市 $2$，答案为 $2 + 6 + 2 - 2 - 2 = 6$。\n\n**【样例 #2】**\n\n见附件中的 `speaker/speaker2.in` 与 `speaker/speaker2.ans`。\n\n该组样例满足测试点 $7\\sim 8$ 的约束条件。\n\n**【样例 #3】**\n\n见附件中的 `speaker/speaker3.in` 与 `speaker/speaker3.ans`。\n\n该组样例满足测试点 $11\\sim 13$ 的约束条件。\n\n**【样例 #4】**\n\n见附件中的 `speaker/speaker4.in` 与 `speaker/speaker4.ans`。\n\n该组样例满足测试点 $17\\sim 19$ 的约束条件。\n\n**【数据范围】**\n\n对于所有测试数据，保证：$1\\le n, q\\le 2\\times 10^5$，$1\\le u_i, v_i \\le n$，$0\\le w_i, c_i\\le 10^9$，所有城市和道路构成了一棵树，$1\\le x_i, y_i \\le n$。\n\n|测试点编号|$n\\le $|$q\\le $|特殊性质|\n|:-:|:-:|:-:|:-:|\n|$1\\sim 4$|$400$|$400$|无|\n|$5$|$2000$|$2000$|A|\n|$6$|$2000$|$2000$|B|\n|$7\\sim 8$|$2000$|$2000$|无|\n|$9$|$2000$|$2\\times 10^5$|A|\n|$10$|$2000$|$2\\times 10^5$|C|\n|$11\\sim 13$|$2000$|$2\\times 10^5$|无|\n|$14\\sim 15$|$2\\times 10^5$|$3$|无|\n|$16$|$2\\times 10^5$|$2\\times 10^5$|A|\n|$17\\sim 19$|$2\\times 10^5$|$2\\times 10^5$|C|\n|$20\\sim 25$|$2\\times 10^5$|$2\\times 10^5$|无|\n\n- 特殊性质 A：每个城市至多被两条道路连接。\n- 特殊性质 B：存在一座城市 $i$（$1\\le i\\le n$），满足对于所有其他城市 $j$（$1\\le j\\le n$、$j \\ne i$），都存在连接城市 $i$ 与城市 $j$ 的道路。\n- 特殊性质 C：对所有 $1 \\le i \\le q$，都有 $x_i = 1$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "【MX-S7-T2】「SMOI-R2」Speaker", "background": "原题链接：<https://oier.team/problems/S7B>。", "description": "M 国有 $n$ 个城市和 $n - 1$ 条双向道路，城市编号为 $1,2,\\dots,n$，**保证这些城市连通**，即**构成了一棵树**。其中，第 $i$ 条道路连接了城市 $u_i$ 和城市 $v_i$，路费为 $w_i$。你是一名演说家，每天都要在 M 国举办三场演讲，每场演讲都会在某一个城市进行。在城市 $i$ 举办一场演讲可以获得 $c_i$ 的收入，**同一天内可以在同一个城市举办多场演讲**。\n\n接下来有 $q$ 天，第 $i$ 天的安排如下：你的第一场演讲必须在城市 $x_i$ 举行，第三场演讲必须在城市 $y_i$ 举行，而第二场演讲所在的城市可以自由选择。设第二场演讲所在的城市为 $z_i$，你需要向交通管理局支付经过 $x_i \\to z_i$ 路径以及 $z_i \\to y_i$ 路径上所有道路的路费。**注意，一条道路如果被多次经过，每次经过都需要支付相应的路费**。\n\n对于每一天，请计算当天可以获得的最大利润，即**总收入减去总路费的最大值**。**注意，答案可能是负数**。", "inputFormat": "第一行，两个正整数 $n,q$。\n\n第二行，$n$ 个非负整数 $c_1,c_2,\\dots,c_n$。\n\n接下来 $n - 1$ 行，每行三个非负整数 $u_i,v_i,w_i$，表示第 $i$ 条道路。\n\n接下来 $q$ 行，每行两个正整数 $x_i,y_i$，表示第 $i$ 天的安排。", "outputFormat": "$q$ 行，每行一个整数，表示第 $i$ 天的最大利润。", "hint": "**【样例解释 #1】**\n\n+ 第一天选择城市 $1$，答案为 $4 + 4 + 4 - 0 - 0 = 12$。\n+ 第二天选择城市 $4$，答案为 $2 + 7 + 7 - 6 - 0 = 10$。\n+ 第三天选择城市 $2$，答案为 $2 + 6 + 2 - 2 - 2 = 6$。\n\n**【样例 #2】**\n\n见附件中的 `speaker/speaker2.in` 与 `speaker/speaker2.ans`。\n\n该组样例满足测试点 $7\\sim 8$ 的约束条件。\n\n**【样例 #3】**\n\n见附件中的 `speaker/speaker3.in` 与 `speaker/speaker3.ans`。\n\n该组样例满足测试点 $11\\sim 13$ 的约束条件。\n\n**【样例 #4】**\n\n见附件中的 `speaker/speaker4.in` 与 `speaker/speaker4.ans`。\n\n该组样例满足测试点 $17\\sim 19$ 的约束条件。\n\n**【数据范围】**\n\n对于所有测试数据，保证：$1\\le n, q\\le 2\\times 10^5$，$1\\le u_i, v_i \\le n$，$0\\le w_i, c_i\\le 10^9$，所有城市和道路构成了一棵树，$1\\le x_i, y_i \\le n$。\n\n|测试点编号|$n\\le $|$q\\le $|特殊性质|\n|:-:|:-:|:-:|:-:|\n|$1\\sim 4$|$400$|$400$|无|\n|$5$|$2000$|$2000$|A|\n|$6$|$2000$|$2000$|B|\n|$7\\sim 8$|$2000$|$2000$|无|\n|$9$|$2000$|$2\\times 10^5$|A|\n|$10$|$2000$|$2\\times 10^5$|C|\n|$11\\sim 13$|$2000$|$2\\times 10^5$|无|\n|$14\\sim 15$|$2\\times 10^5$|$3$|无|\n|$16$|$2\\times 10^5$|$2\\times 10^5$|A|\n|$17\\sim 19$|$2\\times 10^5$|$2\\times 10^5$|C|\n|$20\\sim 25$|$2\\times 10^5$|$2\\times 10^5$|无|\n\n- 特殊性质 A：每个城市至多被两条道路连接。\n- 特殊性质 B：存在一座城市 $i$（$1\\le i\\le n$），满足对于所有其他城市 $j$（$1\\le j\\le n$、$j \\ne i$），都存在连接城市 $i$ 与城市 $j$ 的道路。\n- 特殊性质 C：对所有 $1 \\le i \\le q$，都有 $x_i = 1$。", "locale": "zh-CN"}}}
{"pid": "P11325", "type": "P", "difficulty": 5, "samples": [["5\n-190 133 210 155 -442\n1 3 2 4 5", "308"], ["10\n-205 -268 -487 -112 -82 -330 153 133 -219 -157\n5 6 7 9 2 1 4 10 3 8", "0"], ["5\n-288 479 205 -310 -66\n1 3 2 4 5", "396"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "梦熊比赛"], "title": "【MX-S7-T3】「SMOI-R2」Monotonic Queue", "background": "原题链接：<https://oier.team/problems/S7C>。", "description": "给定一个正整数 $n$ 和 $n$ 个整数 $c_1, \\ldots, c_n$（这些数可能为负），以及一个 $1 \\sim n$ 的排列 $(a_1, \\ldots, a_n)$。\n\n为了考验朋友小 L 的能力，你设计了一道这样一道题目：\n\n> 给定 $n$ 个区间 $[l_1, r_1], [l_2, r_2], \\dots, [l_n, r_n]$，它们满足以下条件：  \n> - $1 \\leq l_i \\leq r_i \\leq n$；  \n> - $l_1 \\leq l_2 \\leq \\dots \\leq l_n$；  \n> - $r_1 \\leq r_2 \\leq \\dots \\leq r_n$。  \n>\n> 对于每个区间 $[l_i, r_i]$，小 L 需要求出 $a_{l_i \\sim r_i}$ 中最大值的位置，记为 $b_i$。\n\n小 L 准备使用**单调队列**来高效地完成这个题目。他的算法核心伪代码如下：\n\n---\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/15a9sbx6.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)\n\n---\n\n对应的 C++ 实现代码如下：\n\n```cpp\ndeque<int> Q;\nl[0] = r[0] = sum = 0;\nfor (int i = 1; i <= n; i++) {\n    for (int j = r[i - 1] + 1; j <= r[i]; j++) {\n        while (!Q.empty() && a[Q.back()] < a[j]) {\n            sum = sum + c[Q.back()];\n            Q.pop_back();\n        }\n        Q.push_back(j);\n    }\n    while (Q.front() < l[i]) Q.pop_front();\n    b[i] = Q.front();\n}\n```\n\n你发现小 L 一遍就通过了这道题目，但是你突然对 `sum` 的值非常感兴趣。现在你想知道，在所有满足条件的 $n$ 个区间的组合中，算法结束后 `sum` 的最大值是多少。", "inputFormat": "第一行，一个正整数 $n$。\n\n第二行，$n$ 个整数 $c_1, \\ldots, c_n$。\n\n第三行，$n$ 个正整数 $a_1, \\ldots, a_n$，保证 $(a_1, \\ldots, a_n)$ 为 $1 \\sim n$ 的排列。", "outputFormat": "仅一行，一个整数，表示答案。", "hint": "**【样例解释 #1】**\n\n若所有区间都为 $[5,5]$，则算法结束后 `sum` 的值为 $308$。可以证明没有使 `sum` 更大的方案。\n\n**【样例解释 #2】**\n\n若所有区间都为 $[1,1]$，则算法结束后 `sum` 的值为 $0$。可以证明没有使 `sum` 更大的方案。\n\n**【样例解释 #3】**\n\n若 $5$ 个区间分别为 $[2,2]$、$[2,2]$、$[2,4]$、$[2,4]$、$[2,4]$，则算法结束后 `sum` 的值为 $396$。可以证明没有使 `sum` 更大的方案。\n\n**【样例 #4】**\n\n见附件中的 `queue/queue4.in` 与 `queue/queue4.ans`。\n\n该组样例满足测试点 $2\\sim 5$ 的约束条件。\n\n**【样例 #5】**\n\n见附件中的 `queue/queue5.in` 与 `queue/queue5.ans`。\n\n该组样例满足测试点 $8\\sim 12$ 的约束条件。\n\n**【样例 #6】**\n\n见附件中的 `queue/queue6.in` 与 `queue/queue6.ans`。\n\n该组样例满足测试点 $15\\sim 16$ 的约束条件。\n\n**【数据范围】**\n\n对于所有测试数据，保证：$2\\le n\\le 5\\times 10^5$，$\\lvert c_i \\rvert\\le 10^9$，$1 \\le a_i \\le n$，$(a_1, \\ldots, a_n)$ 为 $1\\sim n$ 的排列。\n\n|测试点编号|$n\\le $|特殊性质|\n|:-:|:-:|:-:|\n|$1$|$6$|无|\n|$2\\sim 5$|$15$|无|\n|$6\\sim 7$|$5\\times 10^5$|A|\n|$8\\sim 12$|$5000$|无|\n|$13\\sim 14$|$2\\times 10^5$|B|\n|$15\\sim 16$|$2\\times 10^5$|C|\n|$17\\sim 19$|$10^5$|无|\n|$20\\sim 25$|$5\\times 10^5$|无|\n\n- 特殊性质 A：满足 $c_i > 0$ 的 $i$ 不超过 $1$ 个。\n- 特殊性质 B：满足 $c_i < 0$ 的 $i$ 不超过 $2$ 个。\n- 特殊性质 C：满足 $c_i < 0$ 的 $i$ 不超过 $10$ 个。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "【MX-S7-T3】「SMOI-R2」Monotonic Queue", "background": "原题链接：<https://oier.team/problems/S7C>。", "description": "给定一个正整数 $n$ 和 $n$ 个整数 $c_1, \\ldots, c_n$（这些数可能为负），以及一个 $1 \\sim n$ 的排列 $(a_1, \\ldots, a_n)$。\n\n为了考验朋友小 L 的能力，你设计了一道这样一道题目：\n\n> 给定 $n$ 个区间 $[l_1, r_1], [l_2, r_2], \\dots, [l_n, r_n]$，它们满足以下条件：  \n> - $1 \\leq l_i \\leq r_i \\leq n$；  \n> - $l_1 \\leq l_2 \\leq \\dots \\leq l_n$；  \n> - $r_1 \\leq r_2 \\leq \\dots \\leq r_n$。  \n>\n> 对于每个区间 $[l_i, r_i]$，小 L 需要求出 $a_{l_i \\sim r_i}$ 中最大值的位置，记为 $b_i$。\n\n小 L 准备使用**单调队列**来高效地完成这个题目。他的算法核心伪代码如下：\n\n---\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/15a9sbx6.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)\n\n---\n\n对应的 C++ 实现代码如下：\n\n```cpp\ndeque<int> Q;\nl[0] = r[0] = sum = 0;\nfor (int i = 1; i <= n; i++) {\n    for (int j = r[i - 1] + 1; j <= r[i]; j++) {\n        while (!Q.empty() && a[Q.back()] < a[j]) {\n            sum = sum + c[Q.back()];\n            Q.pop_back();\n        }\n        Q.push_back(j);\n    }\n    while (Q.front() < l[i]) Q.pop_front();\n    b[i] = Q.front();\n}\n```\n\n你发现小 L 一遍就通过了这道题目，但是你突然对 `sum` 的值非常感兴趣。现在你想知道，在所有满足条件的 $n$ 个区间的组合中，算法结束后 `sum` 的最大值是多少。", "inputFormat": "第一行，一个正整数 $n$。\n\n第二行，$n$ 个整数 $c_1, \\ldots, c_n$。\n\n第三行，$n$ 个正整数 $a_1, \\ldots, a_n$，保证 $(a_1, \\ldots, a_n)$ 为 $1 \\sim n$ 的排列。", "outputFormat": "仅一行，一个整数，表示答案。", "hint": "**【样例解释 #1】**\n\n若所有区间都为 $[5,5]$，则算法结束后 `sum` 的值为 $308$。可以证明没有使 `sum` 更大的方案。\n\n**【样例解释 #2】**\n\n若所有区间都为 $[1,1]$，则算法结束后 `sum` 的值为 $0$。可以证明没有使 `sum` 更大的方案。\n\n**【样例解释 #3】**\n\n若 $5$ 个区间分别为 $[2,2]$、$[2,2]$、$[2,4]$、$[2,4]$、$[2,4]$，则算法结束后 `sum` 的值为 $396$。可以证明没有使 `sum` 更大的方案。\n\n**【样例 #4】**\n\n见附件中的 `queue/queue4.in` 与 `queue/queue4.ans`。\n\n该组样例满足测试点 $2\\sim 5$ 的约束条件。\n\n**【样例 #5】**\n\n见附件中的 `queue/queue5.in` 与 `queue/queue5.ans`。\n\n该组样例满足测试点 $8\\sim 12$ 的约束条件。\n\n**【样例 #6】**\n\n见附件中的 `queue/queue6.in` 与 `queue/queue6.ans`。\n\n该组样例满足测试点 $15\\sim 16$ 的约束条件。\n\n**【数据范围】**\n\n对于所有测试数据，保证：$2\\le n\\le 5\\times 10^5$，$\\lvert c_i \\rvert\\le 10^9$，$1 \\le a_i \\le n$，$(a_1, \\ldots, a_n)$ 为 $1\\sim n$ 的排列。\n\n|测试点编号|$n\\le $|特殊性质|\n|:-:|:-:|:-:|\n|$1$|$6$|无|\n|$2\\sim 5$|$15$|无|\n|$6\\sim 7$|$5\\times 10^5$|A|\n|$8\\sim 12$|$5000$|无|\n|$13\\sim 14$|$2\\times 10^5$|B|\n|$15\\sim 16$|$2\\times 10^5$|C|\n|$17\\sim 19$|$10^5$|无|\n|$20\\sim 25$|$5\\times 10^5$|无|\n\n- 特殊性质 A：满足 $c_i > 0$ 的 $i$ 不超过 $1$ 个。\n- 特殊性质 B：满足 $c_i < 0$ 的 $i$ 不超过 $2$ 个。\n- 特殊性质 C：满足 $c_i < 0$ 的 $i$ 不超过 $10$ 个。", "locale": "zh-CN"}}}
{"pid": "P11326", "type": "P", "difficulty": 6, "samples": [["5\n3 0\n5 2\n2 0\n4 1\n6 3\n1 0\n2 1\n4 1\n1234 4\n52 1\n110 1\n520 0\n999 1\n114514 0", "3\n12\n32\n27109943\n596672839"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "矩阵乘法", "梦熊比赛"], "title": "【MX-S7-T4】「SMOI-R2」XA-Game", "background": "原题链接：<https://oier.team/problems/S7D>。", "description": "Alice 和 Bob 在玩一个游戏。\n\n初始地，有一个长度为 $n$ 的 01 序列，位置编号为 $1,2,\\dots,n$。双方轮流操作，Alice 先操作。  \n\nAlice 的操作是任意选择序列中位置相邻的两个数，将它们合并为它们的**异或值**（即 C++ 中的 `^` 操作）。  \n\nBob 的操作是任意选择序列中位置相邻的两个数，将它们合并为它们的**与值**（即 C++ 中的 `&` 操作）。  \n\n游戏将持续进行，直至序列中仅剩一个数。如果最后剩下的数是 $1$，Alice 获胜；否则，Bob 获胜。\n\n在游戏开始前，Bob 施展了 $m$ 次魔法调整初始序列，第 $i$ 次魔法将第 $a_i$ 个位置的数改为 $v_i$。\n\nAlice 想知道，如果双方都使用最优策略，有多少种可能的**初始序列**（在 Bob 施展魔法之前）能够让她赢得游戏。由于答案可能非常大，你需要将结果对质数 $10^9 + 7$ 取模。", "inputFormat": "**本题有多组测试数据。**\n\n第一行，一个正整数 $T$，表示数据组数。接下来，对于每组数据：\n- 第一行，两个非负整数 $n, m$，分别表示 01 序列的长度和 Bob 的魔法操作次数。\n- 接下来 $m$ 行，第 $i$ 行两个非负整数 $a_i, v_i$，表示第 $i$ 次魔法操作将第 $a_i$ 个位置的数改为 $v_i$。**保证 $\\boldsymbol{a_i}$ 严格递增给出，即 $\\boldsymbol{1 \\le a_1 < a_2 < \\cdots < a_m \\le n}$。**", "outputFormat": "对于每组测试数据：\n- 仅一行，一个整数，表示答案对 $10^9 + 7$ 取模后的结果。", "hint": "**【样例解释 #1】**\n\n第一组数据中，可以让 Alice 赢的序列有 $110$、$101$、$011$ 共 $3$ 种。\n\n第二组数据中，可以让 Alice 赢的序列有 $10100$、$11100$、$10110$、$11110$、$10001$、$11001$、$00101$、$01101$、$10011$、$11011$、$00111$、$01111$ 共 $12$ 种。\n\n其中序列 $11100$，在 Bob 实施完魔法后变成了 $10110$。Alice 第一次操作可以合并第四个数和第五个数，序列变成 $1011$，可以发现 Bob 无论怎么操作 Alice 都会赢。\n\n**【样例 #2】**\n\n见附件中的 `game/game2.in` 与 `game/game2.ans`。\n\n该组样例满足测试点 $5\\sim6$ 的约束条件。\n\n**【样例 #3】**\n\n见附件中的 `game/game3.in` 与 `game/game3.ans`。\n\n该组样例满足测试点 $10\\sim11$ 的约束条件。\n\n**【样例 #4】**\n\n见附件中的 `game/game4.in` 与 `game/game4.ans`。\n\n该组样例满足测试点 $12\\sim13$ 的约束条件。\n\n**【样例 #5】**\n\n见附件中的 `game/game5.in` 与 `game/game5.ans`。\n\n该组样例满足测试点 $18\\sim20$ 的约束条件。\n\n**【数据范围】**\n\n对于所有测试数据，保证：$1\\le T\\le5\\times 10^5$，$1\\le n\\le 10^{15}$，$0\\le m\\le n$，$\\sum m \\le5\\times 10^5$，$1\\le a_i\\le n$，$a_i < a_{i + 1}$，$v_i\\in\\{0,1\\}$。\n\n|测试点编号|$T\\le$|$n\\le$|$\\sum m\\le$|特殊性质|\n|:-:|:-:|:-:|:-:|:-:|\n|$1$|$40$|$20$|$40$|无|\n|$2\\sim4$|$10^3$|$5\\times10^2$|$5\\times10^5$|A|\n|$5\\sim6$|$10^3$|$5\\times10^2$|$5\\times10^5$|B|\n|$7\\sim9$|$10^3$|$5\\times10^2$|$5\\times10^5$|C|\n|$10\\sim11$|$2\\times 10^5$|$10^6$|$0$|无|\n|$12\\sim13$|$2\\times 10^5$|$10^6$|$2\\times10^5$|无|\n|$14$|$2\\times 10^3$|$10^{15}$|$0$|无|\n|$15\\sim16$|$2\\times 10^3$|$10^{15}$|$2\\times10^3$|无|\n|$17$|$5\\times 10^5$|$10^{15}$|$0$|无|\n|$18\\sim20$|$5\\times 10^5$|$10^{15}$|$5\\times10^5$|无|\n\n- 特殊性质 A：$n = m$。\n- 特殊性质 B：$n = m$，且 $v_i=1$。\n- 特殊性质 C：$n = m$，且 $v$ 中没有相邻的两个 $0$，即 $v_i + v_{i + 1} \\ne 0$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "【MX-S7-T4】「SMOI-R2」XA-Game", "background": "原题链接：<https://oier.team/problems/S7D>。", "description": "Alice 和 Bob 在玩一个游戏。\n\n初始地，有一个长度为 $n$ 的 01 序列，位置编号为 $1,2,\\dots,n$。双方轮流操作，Alice 先操作。  \n\nAlice 的操作是任意选择序列中位置相邻的两个数，将它们合并为它们的**异或值**（即 C++ 中的 `^` 操作）。  \n\nBob 的操作是任意选择序列中位置相邻的两个数，将它们合并为它们的**与值**（即 C++ 中的 `&` 操作）。  \n\n游戏将持续进行，直至序列中仅剩一个数。如果最后剩下的数是 $1$，Alice 获胜；否则，Bob 获胜。\n\n在游戏开始前，Bob 施展了 $m$ 次魔法调整初始序列，第 $i$ 次魔法将第 $a_i$ 个位置的数改为 $v_i$。\n\nAlice 想知道，如果双方都使用最优策略，有多少种可能的**初始序列**（在 Bob 施展魔法之前）能够让她赢得游戏。由于答案可能非常大，你需要将结果对质数 $10^9 + 7$ 取模。", "inputFormat": "**本题有多组测试数据。**\n\n第一行，一个正整数 $T$，表示数据组数。接下来，对于每组数据：\n- 第一行，两个非负整数 $n, m$，分别表示 01 序列的长度和 Bob 的魔法操作次数。\n- 接下来 $m$ 行，第 $i$ 行两个非负整数 $a_i, v_i$，表示第 $i$ 次魔法操作将第 $a_i$ 个位置的数改为 $v_i$。**保证 $\\boldsymbol{a_i}$ 严格递增给出，即 $\\boldsymbol{1 \\le a_1 < a_2 < \\cdots < a_m \\le n}$。**", "outputFormat": "对于每组测试数据：\n- 仅一行，一个整数，表示答案对 $10^9 + 7$ 取模后的结果。", "hint": "**【样例解释 #1】**\n\n第一组数据中，可以让 Alice 赢的序列有 $110$、$101$、$011$ 共 $3$ 种。\n\n第二组数据中，可以让 Alice 赢的序列有 $10100$、$11100$、$10110$、$11110$、$10001$、$11001$、$00101$、$01101$、$10011$、$11011$、$00111$、$01111$ 共 $12$ 种。\n\n其中序列 $11100$，在 Bob 实施完魔法后变成了 $10110$。Alice 第一次操作可以合并第四个数和第五个数，序列变成 $1011$，可以发现 Bob 无论怎么操作 Alice 都会赢。\n\n**【样例 #2】**\n\n见附件中的 `game/game2.in` 与 `game/game2.ans`。\n\n该组样例满足测试点 $5\\sim6$ 的约束条件。\n\n**【样例 #3】**\n\n见附件中的 `game/game3.in` 与 `game/game3.ans`。\n\n该组样例满足测试点 $10\\sim11$ 的约束条件。\n\n**【样例 #4】**\n\n见附件中的 `game/game4.in` 与 `game/game4.ans`。\n\n该组样例满足测试点 $12\\sim13$ 的约束条件。\n\n**【样例 #5】**\n\n见附件中的 `game/game5.in` 与 `game/game5.ans`。\n\n该组样例满足测试点 $18\\sim20$ 的约束条件。\n\n**【数据范围】**\n\n对于所有测试数据，保证：$1\\le T\\le5\\times 10^5$，$1\\le n\\le 10^{15}$，$0\\le m\\le n$，$\\sum m \\le5\\times 10^5$，$1\\le a_i\\le n$，$a_i < a_{i + 1}$，$v_i\\in\\{0,1\\}$。\n\n|测试点编号|$T\\le$|$n\\le$|$\\sum m\\le$|特殊性质|\n|:-:|:-:|:-:|:-:|:-:|\n|$1$|$40$|$20$|$40$|无|\n|$2\\sim4$|$10^3$|$5\\times10^2$|$5\\times10^5$|A|\n|$5\\sim6$|$10^3$|$5\\times10^2$|$5\\times10^5$|B|\n|$7\\sim9$|$10^3$|$5\\times10^2$|$5\\times10^5$|C|\n|$10\\sim11$|$2\\times 10^5$|$10^6$|$0$|无|\n|$12\\sim13$|$2\\times 10^5$|$10^6$|$2\\times10^5$|无|\n|$14$|$2\\times 10^3$|$10^{15}$|$0$|无|\n|$15\\sim16$|$2\\times 10^3$|$10^{15}$|$2\\times10^3$|无|\n|$17$|$5\\times 10^5$|$10^{15}$|$0$|无|\n|$18\\sim20$|$5\\times 10^5$|$10^{15}$|$5\\times10^5$|无|\n\n- 特殊性质 A：$n = m$。\n- 特殊性质 B：$n = m$，且 $v_i=1$。\n- 特殊性质 C：$n = m$，且 $v$ 中没有相邻的两个 $0$，即 $v_i + v_{i + 1} \\ne 0$。", "locale": "zh-CN"}}}
{"pid": "P11327", "type": "P", "difficulty": 4, "samples": [["3 2 1\n2\n0 1 100\n1 2 200\n1\n0 10 20 1000 2000 -1", "280"], ["2 0 1\n1\n1\n0 -1 -1 -1 -1 -1", "-1"], ["6 3 2\n4 5\n0 4 100\n1 4 200\n2 5 300\n4\n0 -1 -1 -1 -1 -1\n1 20 40 10 100 4\n2 1 2 3 4 0\n3 0 -1 0 0 0\n", "100\n104\n150\n-1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "最短路", "NOISG（新加坡）"], "title": "[NOISG 2022 Finals] Voting Cities", "background": null, "description": "你所在的国家的国家主席 $\\bf{Lord\\ Pooty}$ 将要退休了！他希望选择他的一个儿子作为他的继承人，出于各方面因素的考虑，他决定进行一次投票！他所在的国家中共有 $N$ 个国家，编号从 $0$ 到 $N-1$，其中 $K$ 个城市是可以投票的，第 $i$ 个可以投票的城市编号为 $T_i$。\n\n你认为，投票是你作为公民应该做的义务。于是你决定去某一个能投票的城市参与投票！所有城市之间有 $E$ 条公路，第 $j$ 条公路**单向**从城市 $U_j$ 通往城市 $V_j$，通过这条公路需要交过路税 $C_j$。幸运的是，为了更好的完成投票，国家颁布了一系列过路税优惠政策。\n\n具体的来说，你有 $5$ 种优惠券可以购买，使用第 $x$ 种优惠券通过一条过路税为 $y$ 的公路时，可以减少付 $y \\times (10x)\\%$。但是，由于很多人都想投票，需要使用优惠券，所以每一种优惠券你最多只能买 $1$ 张。\n\n你是个大忙人，你既不知道从哪个城市出发，也不知道每种优惠券的价格。你现在设想了 $Q$ 种情况，包括出发城市 $S$ 和优惠券价格 $P_1,P_2,P_3,P_4$ 和 $P_5$。**在有些情况下某些优惠券甚至已经被抢光了，你不能购买它们，此时这些无法购买的优惠券的价格将被表示为 $-1$。**\n\n现在你需要分别对这 $Q$ 种情况，输出到达某一个投票城市的最小花费。**请注意，你不一定总是能通过公路到达某一个投票城市，如果不能到达，你应该输出 $-1$。**", "inputFormat": "第一行，三个整数 $N,E,K$。\n\n第二行，$K$ 个整数，表示 $T_i$。\n\n接下来 $E$ 行，每行三个整数 $U_j,V_j,C_j$。**保证 $C_j$ 是 $10$ 的倍数。**\n\n接下来一行一个整数 $Q$。\n\n接下来 $Q$ 行，每行 $6$ 个整数 $S,P_1,P_2,P_3,P_4,P_5$。", "outputFormat": "共 $Q$ 行，每行一个整数表示答案。", "hint": "### 【样例 #1 解释】\n\n该样例满足 $\\tt{Subtask\\ 4,5,7,8}$ 的限制。\n\n对于这种情况，最佳方案是在 $1 \\to 2$ 的道路上使用一张 $2$ 类优惠券，在 $0 \\to 1$ 的道路上使用一张 $1$ 类优惠券，花费为 $200 \\times (1 - \\frac{2}{10})+100 \\times (1 - \\frac{1}{10})\\%+10+20=160+90+10+20=280$。\n\n### 【样例 #2 解释】\n\n该样例满足所有 $\\tt{Subtask}$ 的限制。\n\n没有道路可以从出发城市到达一个投票城市，所以输出 $-1$。\n\n### 【样例 #3 解释】\n\n该样例满足 $\\tt{Subtask\\ 7,8}$ 的限制。\n\n---\n\n\n### 【数据范围】\n\n|$\\tt{Subtask}$|分值|特殊性质|\n|:-:|:-:|:-:|\n|$1$|$5$|对于所有 $i$，$P_i=-1$。换句话说，没有可用的优惠券。$Q=1,K=1$|\n|$2$|$5$|对于所有 $i$，$P_i=-1$。换句话说，没有可用的优惠券。$K=1$|\n|$3$|$5$|对于所有 $i$，$P_i=-1$。换句话说，没有可用的优惠券。|\n|$4$|$5$|$Q=1,K=1$|\n|$5$|$5$|$K=1$|\n|$6$|$10$|对于每种情况，最多有 $1$ 张优惠券可用。\n|$7$|$15$|$1 \\le N \\le 100,1 \\le E \\le 1000$|\n|$8$|$50$|无|\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 5000,0 \\le E \\le 10000,1 \\le Q \\le 100,0 \\le K \\le N,0 \\le T_i < N,1 \\le C_i \\le 10^9,-1 \\le P_i \\le 10^9$，且对于所有 $1 \\le i < j \\le K$，有 $T_i \\not = T_j$；对于所有 $1 \\le i \\le E$，保证 $C_i$ 是 $10$ 的倍数，$0 \\le U_i,V_i < N,U_i\\not=V_i$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2022 Finals] Voting Cities", "background": null, "description": "你所在的国家的国家主席 $\\bf{Lord\\ Pooty}$ 将要退休了！他希望选择他的一个儿子作为他的继承人，出于各方面因素的考虑，他决定进行一次投票！他所在的国家中共有 $N$ 个国家，编号从 $0$ 到 $N-1$，其中 $K$ 个城市是可以投票的，第 $i$ 个可以投票的城市编号为 $T_i$。\n\n你认为，投票是你作为公民应该做的义务。于是你决定去某一个能投票的城市参与投票！所有城市之间有 $E$ 条公路，第 $j$ 条公路**单向**从城市 $U_j$ 通往城市 $V_j$，通过这条公路需要交过路税 $C_j$。幸运的是，为了更好的完成投票，国家颁布了一系列过路税优惠政策。\n\n具体的来说，你有 $5$ 种优惠券可以购买，使用第 $x$ 种优惠券通过一条过路税为 $y$ 的公路时，可以减少付 $y \\times (10x)\\%$。但是，由于很多人都想投票，需要使用优惠券，所以每一种优惠券你最多只能买 $1$ 张。\n\n你是个大忙人，你既不知道从哪个城市出发，也不知道每种优惠券的价格。你现在设想了 $Q$ 种情况，包括出发城市 $S$ 和优惠券价格 $P_1,P_2,P_3,P_4$ 和 $P_5$。**在有些情况下某些优惠券甚至已经被抢光了，你不能购买它们，此时这些无法购买的优惠券的价格将被表示为 $-1$。**\n\n现在你需要分别对这 $Q$ 种情况，输出到达某一个投票城市的最小花费。**请注意，你不一定总是能通过公路到达某一个投票城市，如果不能到达，你应该输出 $-1$。**", "inputFormat": "第一行，三个整数 $N,E,K$。\n\n第二行，$K$ 个整数，表示 $T_i$。\n\n接下来 $E$ 行，每行三个整数 $U_j,V_j,C_j$。**保证 $C_j$ 是 $10$ 的倍数。**\n\n接下来一行一个整数 $Q$。\n\n接下来 $Q$ 行，每行 $6$ 个整数 $S,P_1,P_2,P_3,P_4,P_5$。", "outputFormat": "共 $Q$ 行，每行一个整数表示答案。", "hint": "### 【样例 #1 解释】\n\n该样例满足 $\\tt{Subtask\\ 4,5,7,8}$ 的限制。\n\n对于这种情况，最佳方案是在 $1 \\to 2$ 的道路上使用一张 $2$ 类优惠券，在 $0 \\to 1$ 的道路上使用一张 $1$ 类优惠券，花费为 $200 \\times (1 - \\frac{2}{10})+100 \\times (1 - \\frac{1}{10})\\%+10+20=160+90+10+20=280$。\n\n### 【样例 #2 解释】\n\n该样例满足所有 $\\tt{Subtask}$ 的限制。\n\n没有道路可以从出发城市到达一个投票城市，所以输出 $-1$。\n\n### 【样例 #3 解释】\n\n该样例满足 $\\tt{Subtask\\ 7,8}$ 的限制。\n\n---\n\n\n### 【数据范围】\n\n|$\\tt{Subtask}$|分值|特殊性质|\n|:-:|:-:|:-:|\n|$1$|$5$|对于所有 $i$，$P_i=-1$。换句话说，没有可用的优惠券。$Q=1,K=1$|\n|$2$|$5$|对于所有 $i$，$P_i=-1$。换句话说，没有可用的优惠券。$K=1$|\n|$3$|$5$|对于所有 $i$，$P_i=-1$。换句话说，没有可用的优惠券。|\n|$4$|$5$|$Q=1,K=1$|\n|$5$|$5$|$K=1$|\n|$6$|$10$|对于每种情况，最多有 $1$ 张优惠券可用。\n|$7$|$15$|$1 \\le N \\le 100,1 \\le E \\le 1000$|\n|$8$|$50$|无|\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 5000,0 \\le E \\le 10000,1 \\le Q \\le 100,0 \\le K \\le N,0 \\le T_i < N,1 \\le C_i \\le 10^9,-1 \\le P_i \\le 10^9$，且对于所有 $1 \\le i < j \\le K$，有 $T_i \\not = T_j$；对于所有 $1 \\le i \\le E$，保证 $C_i$ 是 $10$ 的倍数，$0 \\le U_i,V_i < N,U_i\\not=V_i$。", "locale": "zh-CN"}}}
{"pid": "P11328", "type": "P", "difficulty": 5, "samples": [["5\n4 6 3 5 2\n10 6 4 8 12\n", "4"], ["5\n3 9 4 2 6\n10 10 10 10 10", "4"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["贪心", "2022", "NOISG（新加坡）", "反悔贪心"], "title": "[NOISG 2022 Finals] Gym Badges", "background": null, "description": "你是一只初始等级为 $0$ 的 $\\text{Wabbit}$。你希望到 $N$ 个比赛中提升自己的实力，并收集这些比赛的徽章。\n\n目前将要举行的比赛共有 $N$ 个。第 $i$ 个比赛可以用 $L_i$ 和 $X_i$ 来描述。如果你的当前等级 $\\le L_i$，那么你可以参加第 $i$ 个比赛，让自己的等级提升 $X_i$ 并获得一个徽章。\n\n你可以以任意顺序参加这些比赛。求出如果按照最佳顺序参加，你最多可以获得多少个徽章。", "inputFormat": "第一行，一个正整数 $N$；\n\n第二行 $N$ 个整数，表示 $X_i$。\n\n第三行 $N$ 个整数，表示 $L_i$。", "outputFormat": "一行一个整数，表示最多能收集到的徽章个数。", "hint": "**【样例 #1 解释】**\n\n一种最优的参加方式为 $3 \\to 4 \\to 1 \\to 5$。\n\n**【样例 #2 解释】**\n\n一种最优的参加方式为 $1 \\to 3 \\to 4 \\to 2$。\n\n**【数据范围】**\n\n|$\\text{Subtask}$|分值|特殊性质|\n|:-:|:-:|:-:|\n|$0$|$0$|样例|\n|$1$|$15$|$1\\le N\\le10$|\n|$2$|$9$|所有 $L_i$ 均相等|\n|$3$|$27$|$1\\le N\\le5000$|\n|$4$|$49$|无|\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 5 \\times 10 ^ 5, 1 \\le X_i, L_i \\le 10 ^ 9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2022 Finals] Gym Badges", "background": null, "description": "你是一只初始等级为 $0$ 的 $\\text{Wabbit}$。你希望到 $N$ 个比赛中提升自己的实力，并收集这些比赛的徽章。\n\n目前将要举行的比赛共有 $N$ 个。第 $i$ 个比赛可以用 $L_i$ 和 $X_i$ 来描述。如果你的当前等级 $\\le L_i$，那么你可以参加第 $i$ 个比赛，让自己的等级提升 $X_i$ 并获得一个徽章。\n\n你可以以任意顺序参加这些比赛。求出如果按照最佳顺序参加，你最多可以获得多少个徽章。", "inputFormat": "第一行，一个正整数 $N$；\n\n第二行 $N$ 个整数，表示 $X_i$。\n\n第三行 $N$ 个整数，表示 $L_i$。", "outputFormat": "一行一个整数，表示最多能收集到的徽章个数。", "hint": "**【样例 #1 解释】**\n\n一种最优的参加方式为 $3 \\to 4 \\to 1 \\to 5$。\n\n**【样例 #2 解释】**\n\n一种最优的参加方式为 $1 \\to 3 \\to 4 \\to 2$。\n\n**【数据范围】**\n\n|$\\text{Subtask}$|分值|特殊性质|\n|:-:|:-:|:-:|\n|$0$|$0$|样例|\n|$1$|$15$|$1\\le N\\le10$|\n|$2$|$9$|所有 $L_i$ 均相等|\n|$3$|$27$|$1\\le N\\le5000$|\n|$4$|$49$|无|\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 5 \\times 10 ^ 5, 1 \\le X_i, L_i \\le 10 ^ 9$。", "locale": "zh-CN"}}}
{"pid": "P11329", "type": "P", "difficulty": 5, "samples": [["3\n1 1\n1 6\n1 5\n", "110"], ["6\n1 1\n1 2\n2 1\n2 2\n3 1\n3 2", "110011"], ["8\n1 13\n2 13\n7 27\n7 13\n7 2\n2 27\n7 4\n4 13", "10101101"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2022", "Special Judge", "NOISG（新加坡）"], "title": "[NOISG 2022 Finals] Towers", "background": "### SPJ 已修复。", "description": "兔子 $\\text{Benson}$ 喜欢塔楼。在他的国家中有 $N$ 座城市，其中第 $i$ 座城市在坐标系中的位置为 $(X_i,Y_i)$。**没有两座城市在同一位置。**\n\n$\\text{Benson}$ 希望在这 $N$ 座城市中的一些城市修建塔楼，使得下面的条件全部满足：\n\n- 对于所有的整数 $a$，最多有两座塔楼的 $x$ 坐标为 $a$；\n\n- 对于所有的整数 $b$，最多有两座塔楼的 $y$ 坐标为 $b$；\n\n- 这 $N$ 座城市要么修建了塔楼，要么处在一条与坐标轴平行的线上的两座塔楼中间。换句话说，假设一个城市在 $(x,y)$，如果这座城市没有塔楼，那么需要有两座塔楼在 $(x,c)$ 和 $(x,d)$，其中 $c \\le y \\le d$，或者有两座塔楼在 $(e,y)$ 和 $(f,y)$，使得 $e \\le x \\le f$。\n\n$\\text{Benson}$ 知道肯定有一种可行的方案，但他不知道这种方案是什么。请你帮他找出符合条件的建造方案。", "inputFormat": "第一行，一个正整数 $N$；\n\n接下来 $N$ 行，每行两个整数 $X_i,Y_i$。", "outputFormat": "一行一个长度为 $N$ 的 $01$ 串 $A_1A_2\\dots A_n$，表示你的建造方案。$A_i$ 为 $1$ 表示第 $i$ 个城市建塔楼，反之亦然。\n\n**如果有多种可行的方案，你可以输出任意一种。**", "hint": "**【样例 #1 解释】**\n\n在第 1 和第 2 座城市建塔楼，第 3 座城市与他们有相同的 $x$ 坐标，且位于这两座城市之间。\n\n一种不符合要求的建设方法是`111`，它违反了最多有两座塔楼的 $x$ 坐标为 $1$ 的限制。\n\n另一种不符合要求的建设方法是`101`，第 2 座城市尽管与第 1、3 座城市有相同的 $x$ 坐标，但并不位于他们之间的线段上。\n\n**【数据范围】**\n\n|$\\text{Subtask}$|分值|特殊性质|\n|:-:|:-:|:-:|\n|$0$|$0$|样例|\n|$1$|$5$|$N\\le3$|\n|$2$|$11$|$N\\le16$|\n|$3$|$7$|$N=ab$，其中 $a$ 和 $b$ 是两个正整数，且对于所有满足 $0 \\le i \\le b-1,1 \\le j \\le a$ 的整数 $i,j$，有 $(X_{ai+j},Y_{ai+j})=(i+1,j)$|\n|$4$|$6$|对于所有整数 $a$，最多有两座城市的 $x$ 坐标为 $a$|\n|$5$|$31$|$N\\le5000$|\n|$6$|$21$|$N\\le100000$|\n|$7$|$19$|无|\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10^6, 1 \\le X_i,Y_i \\le 10^6$，保证对于所有 $1 \\le i < j \\le n$ 都有要么 $X_i\\not=X_j$，要么 $Y_i\\not=Y_j$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2022 Finals] Towers", "background": "### SPJ 已修复。", "description": "兔子 $\\text{Benson}$ 喜欢塔楼。在他的国家中有 $N$ 座城市，其中第 $i$ 座城市在坐标系中的位置为 $(X_i,Y_i)$。**没有两座城市在同一位置。**\n\n$\\text{Benson}$ 希望在这 $N$ 座城市中的一些城市修建塔楼，使得下面的条件全部满足：\n\n- 对于所有的整数 $a$，最多有两座塔楼的 $x$ 坐标为 $a$；\n\n- 对于所有的整数 $b$，最多有两座塔楼的 $y$ 坐标为 $b$；\n\n- 这 $N$ 座城市要么修建了塔楼，要么处在一条与坐标轴平行的线上的两座塔楼中间。换句话说，假设一个城市在 $(x,y)$，如果这座城市没有塔楼，那么需要有两座塔楼在 $(x,c)$ 和 $(x,d)$，其中 $c \\le y \\le d$，或者有两座塔楼在 $(e,y)$ 和 $(f,y)$，使得 $e \\le x \\le f$。\n\n$\\text{Benson}$ 知道肯定有一种可行的方案，但他不知道这种方案是什么。请你帮他找出符合条件的建造方案。", "inputFormat": "第一行，一个正整数 $N$；\n\n接下来 $N$ 行，每行两个整数 $X_i,Y_i$。", "outputFormat": "一行一个长度为 $N$ 的 $01$ 串 $A_1A_2\\dots A_n$，表示你的建造方案。$A_i$ 为 $1$ 表示第 $i$ 个城市建塔楼，反之亦然。\n\n**如果有多种可行的方案，你可以输出任意一种。**", "hint": "**【样例 #1 解释】**\n\n在第 1 和第 2 座城市建塔楼，第 3 座城市与他们有相同的 $x$ 坐标，且位于这两座城市之间。\n\n一种不符合要求的建设方法是`111`，它违反了最多有两座塔楼的 $x$ 坐标为 $1$ 的限制。\n\n另一种不符合要求的建设方法是`101`，第 2 座城市尽管与第 1、3 座城市有相同的 $x$ 坐标，但并不位于他们之间的线段上。\n\n**【数据范围】**\n\n|$\\text{Subtask}$|分值|特殊性质|\n|:-:|:-:|:-:|\n|$0$|$0$|样例|\n|$1$|$5$|$N\\le3$|\n|$2$|$11$|$N\\le16$|\n|$3$|$7$|$N=ab$，其中 $a$ 和 $b$ 是两个正整数，且对于所有满足 $0 \\le i \\le b-1,1 \\le j \\le a$ 的整数 $i,j$，有 $(X_{ai+j},Y_{ai+j})=(i+1,j)$|\n|$4$|$6$|对于所有整数 $a$，最多有两座城市的 $x$ 坐标为 $a$|\n|$5$|$31$|$N\\le5000$|\n|$6$|$21$|$N\\le100000$|\n|$7$|$19$|无|\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10^6, 1 \\le X_i,Y_i \\le 10^6$，保证对于所有 $1 \\le i < j \\le n$ 都有要么 $X_i\\not=X_j$，要么 $Y_i\\not=Y_j$。", "locale": "zh-CN"}}}
{"pid": "P11330", "type": "P", "difficulty": 6, "samples": [["7 11\n1 2 2\n2 3 4\n5 6 1\n5 3 6\n3 7 6\n2 4 9\n2 6\n2 4\n2 7\n1 1\n3 2 3 0\n1 1\n3 6 5 0\n1 1\n3 3 5 0\n3 2 4 0\n1 1\n", "11\n8\n8\n2"], ["6 11\n1 2 3\n1 3 4\n2 4 1\n2 5 4\n3 6 6\n2 3\n1 2\n2 4\n3 1 3 2\n1 1\n2 3\n3 2 1 2\n2 4\n1 3\n2 2\n1 3\n", "7\n2\n-1\n4"], ["7 8\n1 2 2\n2 3 3\n3 6 2\n4 6 1\n5 6 4\n6 7 3\n2 3\n1 4\n2 3\n2 5\n1 1\n3 6 7 4\n1 5\n1 7\n", "3\n11\n0\n8"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2022", "树链剖分", "NOISG（新加坡）"], "title": "[NOISG 2022 Finals] Grapevine", "background": "", "description": "Syrup 有一个巨大的葡萄藤。这个葡萄藤上共有 $N$ 片叶子，用 $1 \\sim N$ 编号；这些叶子之间有 $N-1$ 条藤连接。第 $i$ 条藤连接第 $A_i$ 和第 $B_i$ 片叶子，长度为 $W_i$。换句话说，这些叶子和藤组成了一棵树。没有两个葡萄藤的两端相同，且这些叶子之间都可以相互到达。\n\nSyrup 精通养护葡萄藤。他可以向一个叶子 $j$ **浇水**，使得这里飞速生长。如果这片叶子上还没有葡萄，那么浇完水后会立刻长出；如果已经有葡萄了，那么这个葡萄会因为水分过多而消失。\n\n他也可以选择一条树枝，并**改变它的长度**。因为这个葡萄藤实在太大了，所以他需要站在叶子上，并快速**找到**离它距离最近的一个葡萄。\n\n现在，刚刚经历过暴风雨的葡萄藤上没有葡萄。在这一周内，Syrup 打算进行 $Q$ 次以上操作，他想让你帮他快速回答出他的问题。", "inputFormat": "第一行，两个整数 $N,Q$；\n\n接下来 $N-1$ 行，每行三个整数 $A_i,B_i,W_i$。\n\n接下来 $Q$ 行，表示 $Q$ 个操作：\n\n- `1 q`：现在 Syrup 站在编号为 $q$ 的叶子上，他想找到离它最近的葡萄，请你输出这个最小距离。\n\n- `2 u`：向编号为 $u$ 的叶子浇水。\n\n- `3 a b w`：将第 $a$ 片叶子和第 $b$ 片叶子之间的树枝长度改为 $w$。", "outputFormat": "对于每个 `1` 操作，输出距离的最小值。如果当前没有任何一个葡萄，输出 `-1`。", "hint": "**【数据范围】**\n\n|$\\text{Subtask}$|分值|特殊性质|\n|:-:|:-:|:-:|\n|$0$|$0$|样例|\n|$1$|$6$|$N,Q\\le2000$|\n|$2$|$14$|对于所有查询操作，保证 $q=1$|\n|$3$|$15$|整个葡萄藤是一颗完全二叉树，$A_i=\\lfloor\\frac{i+1}{2}\\rfloor,B_i=i+1$|\n|$4$|$15$|在任意时刻整个葡萄藤上都最多只有一个葡萄|\n|$5$|$18$|所有 `2` 操作都在 `1` 和 `3` 操作之前，且对于所有 `3` 操作，$w=0$|\n|$6$|$32$|无|\n\n对于 $100\\%$ 的数据，$2 \\le N \\le 100000,1 \\le Q \\le 100000,1 \\le A_i \\not = B_i \\le N,0 \\le W_i \\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2022 Finals] Grapevine", "background": "", "description": "Syrup 有一个巨大的葡萄藤。这个葡萄藤上共有 $N$ 片叶子，用 $1 \\sim N$ 编号；这些叶子之间有 $N-1$ 条藤连接。第 $i$ 条藤连接第 $A_i$ 和第 $B_i$ 片叶子，长度为 $W_i$。换句话说，这些叶子和藤组成了一棵树。没有两个葡萄藤的两端相同，且这些叶子之间都可以相互到达。\n\nSyrup 精通养护葡萄藤。他可以向一个叶子 $j$ **浇水**，使得这里飞速生长。如果这片叶子上还没有葡萄，那么浇完水后会立刻长出；如果已经有葡萄了，那么这个葡萄会因为水分过多而消失。\n\n他也可以选择一条树枝，并**改变它的长度**。因为这个葡萄藤实在太大了，所以他需要站在叶子上，并快速**找到**离它距离最近的一个葡萄。\n\n现在，刚刚经历过暴风雨的葡萄藤上没有葡萄。在这一周内，Syrup 打算进行 $Q$ 次以上操作，他想让你帮他快速回答出他的问题。", "inputFormat": "第一行，两个整数 $N,Q$；\n\n接下来 $N-1$ 行，每行三个整数 $A_i,B_i,W_i$。\n\n接下来 $Q$ 行，表示 $Q$ 个操作：\n\n- `1 q`：现在 Syrup 站在编号为 $q$ 的叶子上，他想找到离它最近的葡萄，请你输出这个最小距离。\n\n- `2 u`：向编号为 $u$ 的叶子浇水。\n\n- `3 a b w`：将第 $a$ 片叶子和第 $b$ 片叶子之间的树枝长度改为 $w$。", "outputFormat": "对于每个 `1` 操作，输出距离的最小值。如果当前没有任何一个葡萄，输出 `-1`。", "hint": "**【数据范围】**\n\n|$\\text{Subtask}$|分值|特殊性质|\n|:-:|:-:|:-:|\n|$0$|$0$|样例|\n|$1$|$6$|$N,Q\\le2000$|\n|$2$|$14$|对于所有查询操作，保证 $q=1$|\n|$3$|$15$|整个葡萄藤是一颗完全二叉树，$A_i=\\lfloor\\frac{i+1}{2}\\rfloor,B_i=i+1$|\n|$4$|$15$|在任意时刻整个葡萄藤上都最多只有一个葡萄|\n|$5$|$18$|所有 `2` 操作都在 `1` 和 `3` 操作之前，且对于所有 `3` 操作，$w=0$|\n|$6$|$32$|无|\n\n对于 $100\\%$ 的数据，$2 \\le N \\le 100000,1 \\le Q \\le 100000,1 \\le A_i \\not = B_i \\le N,0 \\le W_i \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P11331", "type": "P", "difficulty": 7, "samples": [["5\n-1 -1 -1 -1 -1\n1 1 1 1 1", "1 2 3 4 5\n"], ["5\n-1 3 -1 -1 -1\n1 2 2 2 3\n", "3 4 7 9 9"], ["13\n-1 -1 5 6 -1 -1 7 11 -1 -1 10\n-1 -1\n1 1 1 1 1 1 1 1 1 1 1 1 1\n", "1 2 3 4 5 6 6 7 8 9 9 9 9"], ["10\n-1 -1 -1 -1 5 -1 -1 -1 9 -1\n5 11 24 27 35 60 72 81 91 92", "92 173 245 305 305 332 356 367 406 498\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "线段树", "2022", "颜色段均摊（珂朵莉树 ODT）", "NOISG（新加坡）"], "title": "[NOISG 2022 Finals] Fruits", "background": "", "description": "超市里通常有专门的一区卖水果。\n\n兔子 $\\text{Benson}$ 常去的超市一共有 $N$ 个柜台用来卖 $N$ 种水果。柜台编号从 $1 \\sim N$，水果编号从 $1 \\sim N$。第 $i$ 种水果的美味度是 $i$，购买需要花费 $C_i$ 元。**保证对于所有的 $1 \\le i < j \\le N$，有 $C_i \\le C_j$。**\n\n每一个柜台都只买一种水果，每一种水果都有且仅有一个柜台售卖。现在，工作人员规定了每个柜台卖哪一种水果。第 $i$ 个柜台卖第 $A_i$ 种水果。如果 $A_i=-1$，则表示这个柜台还没有确定卖什么。\n\n当所有柜台的水果都摆放好，$\\text{Benson}$ 就会进店抢购。他会按照 $1 \\sim N$ 的顺序去这些柜台。当他到了一个柜台，如果他的购物车里还是空的，或当前柜台水果的美味度大于所有他购物车里的水果，那么他就会购买这种水果，将其放进购物车中。\n\n现在你需要让商店赚到最多的钱。你需要计算怎么来摆放那些 $A_i=-1$ 的柜台使得利润最大化。由于 $\\text{Benson}$ 很赶时间，他可能不会逛完所有柜台，所以你需要对于所有的 $1 \\le k \\le N$ 计算如果 $\\text{Benson}$ 只逛第 $1 \\sim k$ 个柜台，那么这些柜台应该如何摆放最优。", "inputFormat": "第一行，一个正整数 $N$；\n\n第二行 $N$ 个整数，表示 $A_i$；\n\n第三行 $N$ 个整数，表示 $C_i$。", "outputFormat": "一行 $N$ 个整数，第 $k$ 个表示如果 $\\text{Benson}$ 只逛前 $k$ 个柜台且水果按照最优方案摆放，商店可获得的最大钱数。", "hint": "**【数据范围】**\n\n|$\\text{Subtask}$|分值|特殊性质|\n|:-:|:-:|:-:|\n|$0$|$0$|样例|\n|$1$|$6$|$N\\le8$|\n|$2$|$5$|对于所有 $1\\le j\\le N$，$A_j=-1$|\n|$3$|$11$|$N\\le200$|\n|$4$|$13$|$N\\le2000$|\n|$5$|$23$|对于所有 $1\\le j\\le N$，$C_j=1$|\n|$6$|$42$|无|\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 400000,1 \\le A_j \\le N$ 或 $A_j=-1,1 \\le C_i \\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2022 Finals] Fruits", "background": "", "description": "超市里通常有专门的一区卖水果。\n\n兔子 $\\text{Benson}$ 常去的超市一共有 $N$ 个柜台用来卖 $N$ 种水果。柜台编号从 $1 \\sim N$，水果编号从 $1 \\sim N$。第 $i$ 种水果的美味度是 $i$，购买需要花费 $C_i$ 元。**保证对于所有的 $1 \\le i < j \\le N$，有 $C_i \\le C_j$。**\n\n每一个柜台都只买一种水果，每一种水果都有且仅有一个柜台售卖。现在，工作人员规定了每个柜台卖哪一种水果。第 $i$ 个柜台卖第 $A_i$ 种水果。如果 $A_i=-1$，则表示这个柜台还没有确定卖什么。\n\n当所有柜台的水果都摆放好，$\\text{Benson}$ 就会进店抢购。他会按照 $1 \\sim N$ 的顺序去这些柜台。当他到了一个柜台，如果他的购物车里还是空的，或当前柜台水果的美味度大于所有他购物车里的水果，那么他就会购买这种水果，将其放进购物车中。\n\n现在你需要让商店赚到最多的钱。你需要计算怎么来摆放那些 $A_i=-1$ 的柜台使得利润最大化。由于 $\\text{Benson}$ 很赶时间，他可能不会逛完所有柜台，所以你需要对于所有的 $1 \\le k \\le N$ 计算如果 $\\text{Benson}$ 只逛第 $1 \\sim k$ 个柜台，那么这些柜台应该如何摆放最优。", "inputFormat": "第一行，一个正整数 $N$；\n\n第二行 $N$ 个整数，表示 $A_i$；\n\n第三行 $N$ 个整数，表示 $C_i$。", "outputFormat": "一行 $N$ 个整数，第 $k$ 个表示如果 $\\text{Benson}$ 只逛前 $k$ 个柜台且水果按照最优方案摆放，商店可获得的最大钱数。", "hint": "**【数据范围】**\n\n|$\\text{Subtask}$|分值|特殊性质|\n|:-:|:-:|:-:|\n|$0$|$0$|样例|\n|$1$|$6$|$N\\le8$|\n|$2$|$5$|对于所有 $1\\le j\\le N$，$A_j=-1$|\n|$3$|$11$|$N\\le200$|\n|$4$|$13$|$N\\le2000$|\n|$5$|$23$|对于所有 $1\\le j\\le N$，$C_j=1$|\n|$6$|$42$|无|\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 400000,1 \\le A_j \\le N$ 或 $A_j=-1,1 \\le C_i \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P11332", "type": "P", "difficulty": 2, "samples": [["5\n1 3 -2 1", "1 2 5 3 4"], ["5\n2 2 -3 1", "1 3 5 2 3"], ["2\n0", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "NOISG（新加坡）"], "title": "[NOISG 2020 Finals] Labels", "background": "今天是快递员 Charles 的第一天工作。", "description": "今天是快递员 Charles 的第一天工作。他需要派送 $N$ 个包裹，每个包裹都有一个标签编号，编号范围为 $1$ 到 $N$（不一定唯一）。每天结束时，他需要记录一个长度为 $N$ 的序列 $A$，其中 $A_i$ 是第 $i$ 个派送包裹的标签编号。\n\n为了节省存储空间，Charles 决定使用差分编码记录一个长度为 $N-1$ 的序列 $D$，其中 $D_i = A_{i+1} - A_i$。\n\n完成派送后，Charles 发现他不知道如何从 $D$ 恢复出 $A$。你的任务是帮助他恢复 $A$，或者判断是否无法唯一确定 $A$。", "inputFormat": "- 第一行一个整数 $N$，表示包裹数量。\n- 第二行一个长度为 $N-1$ 的整数序列 $D$，其中 $D_i$ 表示第 $i+1$ 个包裹和第 $i$ 个包裹标签编号的差。", "outputFormat": "- 如果可以唯一恢复 $A$，输出 $N$ 个用空格分隔的整数，表示序列 $A$。  \n- 如果无法唯一恢复 $A$，输出 `-1`。", "hint": "【样例解释】\n\n对于样例 #1，差分序列 $D = [1, 3, -2, 1]$，恢复出的序列为 $A = [1, 2, 5, 3, 4]$，验证如下：\n  - $A_2 - A_1 = 2 - 1 = 1 = D_1$\n  - $A_3 - A_2 = 5 - 2 = 3 = D_2$\n  - $A_4 - A_3 = 3 - 5 = -2 = D_3$\n  - $A_5 - A_4 = 4 - 3 = 1 = D_4$\n\n对于样例 #2，可以唯一恢复 $A = [1, 3, 5, 2, 3]$。\n\n对于样例 #3，差分序列 $D = [0]$，序列可能为 $A = [1, 1]$ 或 $A = [2, 2]$，因此无法唯一恢复，输出 $-1$。\n\n【数据范围】\n\n- $2 \\leq N \\leq 3 \\times 10^5$\n- $1 \\leq A_i \\leq N$\n- $-N < D_i < N$\n\n| 子任务编号 | 分值 | 限制条件          |\n|:---:|:---:|:---:|\n| $1$ | $7$  | $N = 2$          |\n| $2$ | $15$ | $2 \\leq N \\leq 6$ |\n| $3$ | $25$ | $2 \\leq N \\leq 10^3$ |\n| $4$ | $18$ | $-1 \\leq D_i \\leq 1$ |\n| $5$ | $35$ | 无额外限制        |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2020 Finals] Labels", "background": "今天是快递员 Charles 的第一天工作。", "description": "今天是快递员 Charles 的第一天工作。他需要派送 $N$ 个包裹，每个包裹都有一个标签编号，编号范围为 $1$ 到 $N$（不一定唯一）。每天结束时，他需要记录一个长度为 $N$ 的序列 $A$，其中 $A_i$ 是第 $i$ 个派送包裹的标签编号。\n\n为了节省存储空间，Charles 决定使用差分编码记录一个长度为 $N-1$ 的序列 $D$，其中 $D_i = A_{i+1} - A_i$。\n\n完成派送后，Charles 发现他不知道如何从 $D$ 恢复出 $A$。你的任务是帮助他恢复 $A$，或者判断是否无法唯一确定 $A$。", "inputFormat": "- 第一行一个整数 $N$，表示包裹数量。\n- 第二行一个长度为 $N-1$ 的整数序列 $D$，其中 $D_i$ 表示第 $i+1$ 个包裹和第 $i$ 个包裹标签编号的差。", "outputFormat": "- 如果可以唯一恢复 $A$，输出 $N$ 个用空格分隔的整数，表示序列 $A$。  \n- 如果无法唯一恢复 $A$，输出 `-1`。", "hint": "【样例解释】\n\n对于样例 #1，差分序列 $D = [1, 3, -2, 1]$，恢复出的序列为 $A = [1, 2, 5, 3, 4]$，验证如下：\n  - $A_2 - A_1 = 2 - 1 = 1 = D_1$\n  - $A_3 - A_2 = 5 - 2 = 3 = D_2$\n  - $A_4 - A_3 = 3 - 5 = -2 = D_3$\n  - $A_5 - A_4 = 4 - 3 = 1 = D_4$\n\n对于样例 #2，可以唯一恢复 $A = [1, 3, 5, 2, 3]$。\n\n对于样例 #3，差分序列 $D = [0]$，序列可能为 $A = [1, 1]$ 或 $A = [2, 2]$，因此无法唯一恢复，输出 $-1$。\n\n【数据范围】\n\n- $2 \\leq N \\leq 3 \\times 10^5$\n- $1 \\leq A_i \\leq N$\n- $-N < D_i < N$\n\n| 子任务编号 | 分值 | 限制条件          |\n|:---:|:---:|:---:|\n| $1$ | $7$  | $N = 2$          |\n| $2$ | $15$ | $2 \\leq N \\leq 6$ |\n| $3$ | $25$ | $2 \\leq N \\leq 10^3$ |\n| $4$ | $18$ | $-1 \\leq D_i \\leq 1$ |\n| $5$ | $35$ | 无额外限制        |", "locale": "zh-CN"}}}
{"pid": "P11333", "type": "P", "difficulty": 6, "samples": [["5\n1 3 2 6 3", "27"], ["7\n1 1 2 2 2 2 2", "14"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "NOISG（新加坡）"], "title": "[NOISG 2020 Finals] Discharging", "background": "为了成为最强的电力供应者，Pichuu 这只电鼠开启了一项新业务：使用他最爱的技能 Discharge 为顾客充电。由于业务的高效，Pichuu 每天都有许多顾客排队等待充电。", "description": "在某一天，Pichuu 有 $N$ 名顾客等待充电。Pichuu 可以同时为多部手机充电，每部手机的充电功率相同且恒定。然而，不同型号的手机电池容量不同，因此完全充满所需的时间也不同。第 $i$ 部手机需要 $T_i$ 分钟才能完全充满。\n\nPichuu 不会停止充电，直到所有手机都充满电。为了避免顾客等待过久，Pichuu 可以将顾客分成若干连续的组，然后按顺序为每组充电。每组中的顾客必须等待前面的组完成充电后，才能开始充电。\n\n对于第 $k$ 组，组内充电所需的时间为该组中 $T_i$ 的最大值（记为 $M_k$）。第 $i$ 名顾客的总等待时间 $W_i$ 是他所在组及其之前所有组的充电时间之和：\n\n$$\nW_i = \\sum_{n=1}^{G_i} M_n\n$$\n\n其中，$G_i$ 表示第 $i$ 名顾客所属的组编号。\n\nPichuu 希望通过合理分组最小化顾客的总等待时间。你的任务是帮助 Pichuu 计算最小的总等待时间。", "inputFormat": "- 第一行包含一个整数 $N$，表示顾客数量。\n- 第二行包含 $N$ 个整数，第 $i$ 个整数表示第 $i$ 部手机完全充电所需的时间 $T_i$。", "outputFormat": "- 输出一个整数，表示最小的总等待时间。", "hint": "【样例解释】\n\n对于样例 #1：\n- 最优分组为 $(1, 3, 2)$ 和 $(6, 3)$。两组的充电时间分别为 $3$ 和 $6$。  \n- 第一组的等待时间为 $3$（每名顾客），第二组的等待时间为 $3 + 6 = 9$（每名顾客）。  \n- 总等待时间为 $3 + 3 + 3 + 9 + 9 = 27$。\n\n对于样例 #2：\n- 最优分组为一个整体，等待时间为 $2$（每名顾客）。  \n- 总等待时间为 $2 + 2 + 2 + 2 + 2 + 2 + 2 = 14$。\n\n【数据范围】\n\n- $1 \\leq N \\leq 10^6$\n- $1 \\leq T_i \\leq 10^9$\n\n| 子任务编号 | 分值 | 限制条件                     |\n|:---:|:---:|:---:|\n| $1$ | $9$  | $1 \\leq N \\leq 3$              |\n| $2$ | $13$ | $1 \\leq N \\leq 1500$ 且 $T_i$ 非递减。 |\n| $3$ | $25$ | $T_i$ 非递减。                  |\n| $4$ | $11$ | $T_i$ 非递增。                  |\n| $5$ | $14$ | $1 \\leq N \\leq 1500$           |\n| $6$ | $28$ | 无额外限制。                    |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2020 Finals] Discharging", "background": "为了成为最强的电力供应者，Pichuu 这只电鼠开启了一项新业务：使用他最爱的技能 Discharge 为顾客充电。由于业务的高效，Pichuu 每天都有许多顾客排队等待充电。", "description": "在某一天，Pichuu 有 $N$ 名顾客等待充电。Pichuu 可以同时为多部手机充电，每部手机的充电功率相同且恒定。然而，不同型号的手机电池容量不同，因此完全充满所需的时间也不同。第 $i$ 部手机需要 $T_i$ 分钟才能完全充满。\n\nPichuu 不会停止充电，直到所有手机都充满电。为了避免顾客等待过久，Pichuu 可以将顾客分成若干连续的组，然后按顺序为每组充电。每组中的顾客必须等待前面的组完成充电后，才能开始充电。\n\n对于第 $k$ 组，组内充电所需的时间为该组中 $T_i$ 的最大值（记为 $M_k$）。第 $i$ 名顾客的总等待时间 $W_i$ 是他所在组及其之前所有组的充电时间之和：\n\n$$\nW_i = \\sum_{n=1}^{G_i} M_n\n$$\n\n其中，$G_i$ 表示第 $i$ 名顾客所属的组编号。\n\nPichuu 希望通过合理分组最小化顾客的总等待时间。你的任务是帮助 Pichuu 计算最小的总等待时间。", "inputFormat": "- 第一行包含一个整数 $N$，表示顾客数量。\n- 第二行包含 $N$ 个整数，第 $i$ 个整数表示第 $i$ 部手机完全充电所需的时间 $T_i$。", "outputFormat": "- 输出一个整数，表示最小的总等待时间。", "hint": "【样例解释】\n\n对于样例 #1：\n- 最优分组为 $(1, 3, 2)$ 和 $(6, 3)$。两组的充电时间分别为 $3$ 和 $6$。  \n- 第一组的等待时间为 $3$（每名顾客），第二组的等待时间为 $3 + 6 = 9$（每名顾客）。  \n- 总等待时间为 $3 + 3 + 3 + 9 + 9 = 27$。\n\n对于样例 #2：\n- 最优分组为一个整体，等待时间为 $2$（每名顾客）。  \n- 总等待时间为 $2 + 2 + 2 + 2 + 2 + 2 + 2 = 14$。\n\n【数据范围】\n\n- $1 \\leq N \\leq 10^6$\n- $1 \\leq T_i \\leq 10^9$\n\n| 子任务编号 | 分值 | 限制条件                     |\n|:---:|:---:|:---:|\n| $1$ | $9$  | $1 \\leq N \\leq 3$              |\n| $2$ | $13$ | $1 \\leq N \\leq 1500$ 且 $T_i$ 非递减。 |\n| $3$ | $25$ | $T_i$ 非递减。                  |\n| $4$ | $11$ | $T_i$ 非递增。                  |\n| $5$ | $14$ | $1 \\leq N \\leq 1500$           |\n| $6$ | $28$ | 无额外限制。                    |", "locale": "zh-CN"}}}
{"pid": "P11334", "type": "P", "difficulty": 5, "samples": [["10 6\n1 2 3 4 1 2 3 4 5 5\n3 1 10\n1 1 4 -1 -1\n3 1 10\n3 9 10\n2 5 10 -2 -2\n3 1 10", "5\n6\n2\n7"], ["10 5\n1 2 3 4 1 2 3 4 5 5\n3 1 10\n1 1 10 1 2\n3 1 10\n2 1 10 3 4\n3 1 10", "5\n5\n10"], ["10 5\n1 2 3 4 1 2 3 4 5 5\n3 1 4\n3 4 5\n3 2 4\n3 5 9\n3 10 10", "4\n2\n3\n5\n1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "NOISG（新加坡）"], "title": "[NOISG 2020 Finals] Progression", "background": "Damian 正在开发一款视频游戏！", "description": "该游戏包含 $N$ 个任务，第 $i$ 个任务的初始难度为 $D_i$。为了让玩家感受到难度的渐进性，Damian 对任务难度进行了若干次调整操作。\n\n游戏设计支持两种操作：\n\n1. **补丁操作**：将任务 $L$ 到 $R$ 的难度按公式 $D_i = D_i + S + (i - L) \\times C$ 增加。\n2. **重写操作**：将任务 $L$ 到 $R$ 的难度直接设置为 $D_i = S + (i - L) \\times C$。\n\n为了让游戏更加有趣，Damian 希望找到任务的连续子序列，使它们的难度呈等差数列。玩家可以按顺序或倒序完成任务。任务 $a$ 到 $b$ ($1 \\leq a \\leq b \\leq N$) 构成可玩子段当且仅当对所有 $a \\leq i < b$，满足 $D_{i+1} - D_i = k$（$k$ 为某个整数，可以为负）。单个任务也构成长度为 $1$ 的可玩子段。\n\nDamian 有时需要回答一个查询：找出某一区间内最长的可玩子段长度。你需要帮助 Damian 处理这些查询。", "inputFormat": "- 第一行包含两个整数 $N$ 和 $Q$，分别表示任务的数量和操作与查询的总数。\n- 第二行包含 $N$ 个整数，表示任务的初始难度 $D_1, D_2, \\dots, D_N$。\n- 接下来的 $Q$ 行描述操作或查询：\n  - 若行首为 $1$，接下来为 $L, R, S, C$，表示补丁操作。\n  - 若行首为 $2$，接下来为 $L, R, S, C$，表示重写操作。\n  - 若行首为 $3$，接下来为 $L, R$，表示查询操作。", "outputFormat": "对于每个查询操作，输出一个整数，表示指定区间内最长的可玩子段长度。", "hint": "【样例解释】\n\n对于样例 #1：\n- 第一次查询时，任务 $5$ 到 $9$ 构成最长可玩子段。\n- 第一次补丁操作后，任务难度变为 $[0, 0, 0, 0, 1, 2, 3, 4, 5, 5]$。  \n  第二次查询时，任务 $4$ 到 $9$ 构成最长可玩子段。  \n- 第二次补丁操作后，任务难度变为 $[0, 0, 0, 0, -2, -4, -6, -8, -10, -12]$。  \n  最后一次查询时，任务 $4$ 到 $10$ 构成最长可玩子段。\n\n【数据范围】\n\n- $1 \\leq N, Q \\leq 3 \\times 10^5$\n- $-10^6 \\leq D_i, S, C \\leq 10^6$\n- $1 \\leq L \\leq R \\leq N$\n\n| 子任务编号 | 分值 | 限制条件                     |\n|:---:|:---:|:---:|\n| $1$ | $9$  | $L = 1, R = N$                |\n| $2$ | $15$ | $1 \\leq N, Q \\leq 10^3$       |\n| $3$ | $35$ | 无补丁和重写操作。            |\n| $4$ | $11$ | $L = R$                      |\n| $5$ | $13$ | 无重写操作。                  |\n| $6$ | $17$ | 无额外限制。                  |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2020 Finals] Progression", "background": "Damian 正在开发一款视频游戏！", "description": "该游戏包含 $N$ 个任务，第 $i$ 个任务的初始难度为 $D_i$。为了让玩家感受到难度的渐进性，Damian 对任务难度进行了若干次调整操作。\n\n游戏设计支持两种操作：\n\n1. **补丁操作**：将任务 $L$ 到 $R$ 的难度按公式 $D_i = D_i + S + (i - L) \\times C$ 增加。\n2. **重写操作**：将任务 $L$ 到 $R$ 的难度直接设置为 $D_i = S + (i - L) \\times C$。\n\n为了让游戏更加有趣，Damian 希望找到任务的连续子序列，使它们的难度呈等差数列。玩家可以按顺序或倒序完成任务。任务 $a$ 到 $b$ ($1 \\leq a \\leq b \\leq N$) 构成可玩子段当且仅当对所有 $a \\leq i < b$，满足 $D_{i+1} - D_i = k$（$k$ 为某个整数，可以为负）。单个任务也构成长度为 $1$ 的可玩子段。\n\nDamian 有时需要回答一个查询：找出某一区间内最长的可玩子段长度。你需要帮助 Damian 处理这些查询。", "inputFormat": "- 第一行包含两个整数 $N$ 和 $Q$，分别表示任务的数量和操作与查询的总数。\n- 第二行包含 $N$ 个整数，表示任务的初始难度 $D_1, D_2, \\dots, D_N$。\n- 接下来的 $Q$ 行描述操作或查询：\n  - 若行首为 $1$，接下来为 $L, R, S, C$，表示补丁操作。\n  - 若行首为 $2$，接下来为 $L, R, S, C$，表示重写操作。\n  - 若行首为 $3$，接下来为 $L, R$，表示查询操作。", "outputFormat": "对于每个查询操作，输出一个整数，表示指定区间内最长的可玩子段长度。", "hint": "【样例解释】\n\n对于样例 #1：\n- 第一次查询时，任务 $5$ 到 $9$ 构成最长可玩子段。\n- 第一次补丁操作后，任务难度变为 $[0, 0, 0, 0, 1, 2, 3, 4, 5, 5]$。  \n  第二次查询时，任务 $4$ 到 $9$ 构成最长可玩子段。  \n- 第二次补丁操作后，任务难度变为 $[0, 0, 0, 0, -2, -4, -6, -8, -10, -12]$。  \n  最后一次查询时，任务 $4$ 到 $10$ 构成最长可玩子段。\n\n【数据范围】\n\n- $1 \\leq N, Q \\leq 3 \\times 10^5$\n- $-10^6 \\leq D_i, S, C \\leq 10^6$\n- $1 \\leq L \\leq R \\leq N$\n\n| 子任务编号 | 分值 | 限制条件                     |\n|:---:|:---:|:---:|\n| $1$ | $9$  | $L = 1, R = N$                |\n| $2$ | $15$ | $1 \\leq N, Q \\leq 10^3$       |\n| $3$ | $35$ | 无补丁和重写操作。            |\n| $4$ | $11$ | $L = R$                      |\n| $5$ | $13$ | 无重写操作。                  |\n| $6$ | $17$ | 无额外限制。                  |", "locale": "zh-CN"}}}
{"pid": "P11335", "type": "P", "difficulty": 5, "samples": [["6 4\n1 2 3 4\n3 1 2 6", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2020", "Dilworth 定理", "NOISG（新加坡）", "线性 DP"], "title": "[NOISG 2020 Finals] Arcade", "background": "Emily 是一只外星章鱼，她正在玩一个街机游戏。", "description": "游戏机上有 $N$ 个按钮，从左到右编号为 $1$ 到 $N$。游戏的规则是按照时间顺序按下 $M$ 个按钮，每秒按一个按钮。在第 $T_i$ 秒时，需要按下按钮 $A_i$。注意，可能存在 $T_i = T_j$ 且 $A_i = A_j$，即使 $i \\neq j$。\n\nEmily 的每只手可以从任意位置开始游戏，每只手从一个按钮移动到相邻按钮需要正好 $1$ 秒的时间。Emily 的手可以同时移动，按下按钮所需时间为 $0$ 秒。由于外星章鱼拥有无限数量的手，她总是可以获得游戏的最高分。然而，由于 Emily 很懒，她不想使用太多的手。让我们计算完成游戏所需的最少手数 $S$。\n\n你的任务是帮助 Emily 计算完成游戏所需的最少手数 $S$。", "inputFormat": "- 第一行包含两个整数 $N$ 和 $M$，分别表示按钮数量和按键次数。\n- 第二行包含 $M$ 个整数，第 $i$ 个整数表示第 $T_i$ 秒。\n- 第三行包含 $M$ 个整数，第 $i$ 个整数表示需要按下的按钮编号 $A_i$。", "outputFormat": "- 输出一个整数，表示完成游戏所需的最少手数。", "hint": "【样例解释】\n\n对于样例 #1：  \n- 游戏开始时，Emily 的右手在按钮 $3$，左手在按钮 $1$。\n- 接下来的一秒中，右手移动到按钮 $4$，左手按下按钮 $1$。\n- 随后，右手和左手同时移动到按钮 $2$，并分别按下按钮。\n- 最后，右手移动到按钮 $6$ 并按下。\n- 总共需要 $2$ 只手完成任务，因此输出为 $2$。\n\n【数据范围】\n\n- $1 \\leq N \\leq 10^9$\n- $1 \\leq M \\leq 5 \\times 10^5$\n- $1 \\leq A_i \\leq N$\n- $1 \\leq T_i \\leq 10^9$\n\n| 子任务编号 | 分值 | 限制条件                     |\n|:---:|:---:|:---:|\n| $1$ | $7$  | $1 \\leq N, M, T_i \\leq 100$, $1 \\leq S \\leq 2$ |\n| $2$ | $11$ | $1 \\leq N, M, T_i \\leq 100$, $1 \\leq S \\leq 3$ |\n| $3$ | $12$ | $1 \\leq N, M, T_i \\leq 100$, $1 \\leq S \\leq 4$ |\n| $4$ | $21$ | $1 \\leq M \\leq 300$             |\n| $5$ | $14$ | $1 \\leq M \\leq 15,000$         |\n| $6$ | $20$ | $1 \\leq M \\leq 100,000$        |\n| $7$ | $15$ | 无额外限制                     |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2020 Finals] Arcade", "background": "Emily 是一只外星章鱼，她正在玩一个街机游戏。", "description": "游戏机上有 $N$ 个按钮，从左到右编号为 $1$ 到 $N$。游戏的规则是按照时间顺序按下 $M$ 个按钮，每秒按一个按钮。在第 $T_i$ 秒时，需要按下按钮 $A_i$。注意，可能存在 $T_i = T_j$ 且 $A_i = A_j$，即使 $i \\neq j$。\n\nEmily 的每只手可以从任意位置开始游戏，每只手从一个按钮移动到相邻按钮需要正好 $1$ 秒的时间。Emily 的手可以同时移动，按下按钮所需时间为 $0$ 秒。由于外星章鱼拥有无限数量的手，她总是可以获得游戏的最高分。然而，由于 Emily 很懒，她不想使用太多的手。让我们计算完成游戏所需的最少手数 $S$。\n\n你的任务是帮助 Emily 计算完成游戏所需的最少手数 $S$。", "inputFormat": "- 第一行包含两个整数 $N$ 和 $M$，分别表示按钮数量和按键次数。\n- 第二行包含 $M$ 个整数，第 $i$ 个整数表示第 $T_i$ 秒。\n- 第三行包含 $M$ 个整数，第 $i$ 个整数表示需要按下的按钮编号 $A_i$。", "outputFormat": "- 输出一个整数，表示完成游戏所需的最少手数。", "hint": "【样例解释】\n\n对于样例 #1：  \n- 游戏开始时，Emily 的右手在按钮 $3$，左手在按钮 $1$。\n- 接下来的一秒中，右手移动到按钮 $4$，左手按下按钮 $1$。\n- 随后，右手和左手同时移动到按钮 $2$，并分别按下按钮。\n- 最后，右手移动到按钮 $6$ 并按下。\n- 总共需要 $2$ 只手完成任务，因此输出为 $2$。\n\n【数据范围】\n\n- $1 \\leq N \\leq 10^9$\n- $1 \\leq M \\leq 5 \\times 10^5$\n- $1 \\leq A_i \\leq N$\n- $1 \\leq T_i \\leq 10^9$\n\n| 子任务编号 | 分值 | 限制条件                     |\n|:---:|:---:|:---:|\n| $1$ | $7$  | $1 \\leq N, M, T_i \\leq 100$, $1 \\leq S \\leq 2$ |\n| $2$ | $11$ | $1 \\leq N, M, T_i \\leq 100$, $1 \\leq S \\leq 3$ |\n| $3$ | $12$ | $1 \\leq N, M, T_i \\leq 100$, $1 \\leq S \\leq 4$ |\n| $4$ | $21$ | $1 \\leq M \\leq 300$             |\n| $5$ | $14$ | $1 \\leq M \\leq 15,000$         |\n| $6$ | $20$ | $1 \\leq M \\leq 100,000$        |\n| $7$ | $15$ | 无额外限制                     |", "locale": "zh-CN"}}}
{"pid": "P11336", "type": "P", "difficulty": 6, "samples": [["6 8\n5 6 2\n3 1 4\n1 2 2\n6 2 3\n5 3 3\n3 2 1\n4 6 3\n2 4 2", "8"], ["5 6\n1 2 1\n4 3 1\n2 4 1\n3 2 1\n1 3 1\n4 5 1", "3"], ["7 6\n2 1 4\n1 3 3\n4 5 4\n5 7 3\n4 6 2\n1 4 0", "10"], ["5 5\n4 3 3\n1 4 4\n3 1 3\n4 5 2\n2 3 1", "8"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "NOISG（新加坡）"], "title": "[NOISG 2020 Finals] Aesthetic", "background": "", "description": "Syrup 是一只生活在城镇中的乌龟，这个城镇包含 $N$ 个地点和 $M$ 条双向道路。每个地点从 $1$ 到 $N$ 编号，每条道路从 $1$ 到 $M$ 编号。第 $i$ 条道路直接连接地点 $A_i$ 和 $B_i$，长度为 $W_i$，可以双向通行。所有地点通过这些道路直接或间接连通，且没有两条道路共享相同的端点。\n\n城镇的居民根据道路的美观性进行了排序，道路编号越大，美观性越高。现在，居民们计划将一条美观性更高的道路复制到一条美观性更低的道路上。这将使得美观性较低的道路长度增加，同时保留原有道路的其他属性。具体来说，如果道路 $j$ 被复制到道路 $i$，需要满足 $i < j$，且复制后道路 $i$ 的长度变为 $W_i + W_j$。\n\nSyrup 通常从他的家（地点 $N$）前往主广场（地点 $1$）。他希望知道在完成上述项目后，从地点 $1$ 到地点 $N$ 的最短路径长度可能达到的最大值。", "inputFormat": "- 第一行包含两个整数 $N$ 和 $M$，分别表示地点数量和道路数量。\n- 接下来的 $M$ 行中，每行包含三个整数 $A_i, B_i, W_i$，描述一条道路。", "outputFormat": "输出一个整数，表示在完成项目后，从地点 $1$ 到地点 $N$ 的最短路径长度的最大值。", "hint": "【数据范围】\n\n- $3 \\leq N \\leq 300,000$\n- $2 \\leq M \\leq 300,000$\n- $1 \\leq A_i, B_i \\leq N$ 且 $A_i \\neq B_i$\n- $0 \\leq W_i \\leq 10^9$\n\n| 子任务编号 | 分值 | 限制条件                |\n|:---:|:---:|:---:|\n| $1$ | $5$  | $N, M \\leq 100$         |\n| $2$ | $8$  | $N, M \\leq 2000$        |\n| $3$ | $7$  | $M = N - 1$             |\n| $4$ | $15$ | $M = N$                 |\n| $5$ | $16$ | $W_i = 1$               |\n| $6$ | $22$ | $0 \\leq W_i \\leq 10$    |\n| $7$ | $27$ | 无额外限制              |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2020 Finals] Aesthetic", "background": "", "description": "Syrup 是一只生活在城镇中的乌龟，这个城镇包含 $N$ 个地点和 $M$ 条双向道路。每个地点从 $1$ 到 $N$ 编号，每条道路从 $1$ 到 $M$ 编号。第 $i$ 条道路直接连接地点 $A_i$ 和 $B_i$，长度为 $W_i$，可以双向通行。所有地点通过这些道路直接或间接连通，且没有两条道路共享相同的端点。\n\n城镇的居民根据道路的美观性进行了排序，道路编号越大，美观性越高。现在，居民们计划将一条美观性更高的道路复制到一条美观性更低的道路上。这将使得美观性较低的道路长度增加，同时保留原有道路的其他属性。具体来说，如果道路 $j$ 被复制到道路 $i$，需要满足 $i < j$，且复制后道路 $i$ 的长度变为 $W_i + W_j$。\n\nSyrup 通常从他的家（地点 $N$）前往主广场（地点 $1$）。他希望知道在完成上述项目后，从地点 $1$ 到地点 $N$ 的最短路径长度可能达到的最大值。", "inputFormat": "- 第一行包含两个整数 $N$ 和 $M$，分别表示地点数量和道路数量。\n- 接下来的 $M$ 行中，每行包含三个整数 $A_i, B_i, W_i$，描述一条道路。", "outputFormat": "输出一个整数，表示在完成项目后，从地点 $1$ 到地点 $N$ 的最短路径长度的最大值。", "hint": "【数据范围】\n\n- $3 \\leq N \\leq 300,000$\n- $2 \\leq M \\leq 300,000$\n- $1 \\leq A_i, B_i \\leq N$ 且 $A_i \\neq B_i$\n- $0 \\leq W_i \\leq 10^9$\n\n| 子任务编号 | 分值 | 限制条件                |\n|:---:|:---:|:---:|\n| $1$ | $5$  | $N, M \\leq 100$         |\n| $2$ | $8$  | $N, M \\leq 2000$        |\n| $3$ | $7$  | $M = N - 1$             |\n| $4$ | $15$ | $M = N$                 |\n| $5$ | $16$ | $W_i = 1$               |\n| $6$ | $22$ | $0 \\leq W_i \\leq 10$    |\n| $7$ | $27$ | 无额外限制              |", "locale": "zh-CN"}}}
{"pid": "P11337", "type": "P", "difficulty": 6, "samples": [["3\n5\n1 2 2 2 3\n2 1 3 3 2\n2 3 1 3 4\n2 3 3 1 3\n3 2 4 3 1", "1 2 3 4 4\n1 2\n1 3\n1 4\n2 5"], ["2\n4\n1 2 3 3\n2 1 2 2\n3 2 1 2\n3 2 2 1", "1 2 3 2\n1 2\n2 3\n3 4"], ["1\n5\n1 2 2 2 2\n2 1 1 2 2\n2 1 1 2 2\n2 2 2 1 2\n2 2 2 2 1", "1 2 2 1 2\n1 2\n2 3\n2 4\n1 5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2019", "Special Judge", "COI（克罗地亚）"], "title": "[COI 2019] IZLET", "background": "", "description": "**译自 [COI 2019](https://hsin.hr/coci/archive/2018_2019/) T1「[IZLET](https://hsin.hr/coci/archive/2018_2019/olympiad_tasks.pdf)」**\n\nNikola 在观察一棵树。这是一颗 $N$ 个节点的树，每个节点有一个颜色，颜色在 $1$ 到 $N$ 之间。Nikola 记录下了这样一个 $N \\times N$ 的矩阵：\n\n矩阵的第 $i$ 行第 $j$ 列表示，节点 $i$ 到节点 $j$ 的路径上总共出现的颜色的数量。\n\n现在 Nikola 只记得这个矩阵，而忘记了树的具体信息！现在他把这个矩阵告诉你，请你找出一棵树并且给每个节点标上颜色，使得符合矩阵记录的信息。\n\nNikola 的记录和记忆都是正确的，所以你至少能找出一种合法的方案。\n", "inputFormat": "第一行输入一个正整数 $T$ 表示数据类型。\n\n第二行输入一个正整数 $N$ 表示节点数。\n\n接下来输入共 $N$ 行，每行 $N$ 个正整数，即输入 Nikola 记录下的矩阵。\n", "outputFormat": "第一行输出 $N$ 个正整数，表示每个节点的颜色。\n\n接下来输出 $N - 1$ 行，每行两个正整数 $A,B$ 表示节点 $A,B$ 间有一条边。\n", "hint": "对于 $100\\%$ 的数据，保证 $1\\le N\\le 3000$。\n\n| 子任务编号 $T$ | 分值 | 特殊性质 |\n|:-:|:-:|:-:|\n| $1$ | $18$ | 矩阵中的数均不超过 $2$ |\n| $2$ | $25$ | 存在一组解使得树的结构是一条链，每个节点 $i(1\\le i<n)$ 与 $i+1$ 间有一条边 |\n| $3$ | $57$ | |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COI 2019] IZLET", "background": "", "description": "**译自 [COI 2019](https://hsin.hr/coci/archive/2018_2019/) T1「[IZLET](https://hsin.hr/coci/archive/2018_2019/olympiad_tasks.pdf)」**\n\nNikola 在观察一棵树。这是一颗 $N$ 个节点的树，每个节点有一个颜色，颜色在 $1$ 到 $N$ 之间。Nikola 记录下了这样一个 $N \\times N$ 的矩阵：\n\n矩阵的第 $i$ 行第 $j$ 列表示，节点 $i$ 到节点 $j$ 的路径上总共出现的颜色的数量。\n\n现在 Nikola 只记得这个矩阵，而忘记了树的具体信息！现在他把这个矩阵告诉你，请你找出一棵树并且给每个节点标上颜色，使得符合矩阵记录的信息。\n\nNikola 的记录和记忆都是正确的，所以你至少能找出一种合法的方案。\n", "inputFormat": "第一行输入一个正整数 $T$ 表示数据类型。\n\n第二行输入一个正整数 $N$ 表示节点数。\n\n接下来输入共 $N$ 行，每行 $N$ 个正整数，即输入 Nikola 记录下的矩阵。\n", "outputFormat": "第一行输出 $N$ 个正整数，表示每个节点的颜色。\n\n接下来输出 $N - 1$ 行，每行两个正整数 $A,B$ 表示节点 $A,B$ 间有一条边。\n", "hint": "对于 $100\\%$ 的数据，保证 $1\\le N\\le 3000$。\n\n| 子任务编号 $T$ | 分值 | 特殊性质 |\n|:-:|:-:|:-:|\n| $1$ | $18$ | 矩阵中的数均不超过 $2$ |\n| $2$ | $25$ | 存在一组解使得树的结构是一条链，每个节点 $i(1\\le i<n)$ 与 $i+1$ 间有一条边 |\n| $3$ | $57$ | |\n", "locale": "zh-CN"}}}
{"pid": "P11338", "type": "P", "difficulty": 5, "samples": [["3 0\nLR\n101\n110", "11"], ["4 2\nLRR\n1010\n1110", "37"], ["5 2\nRLLR\n10010\n10111", "82"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2019", "COI（克罗地亚）"], "title": "[COI 2019] LJEPOTICA", "background": "", "description": "**译自 [COI 2019](https://hsin.hr/coci/archive/2018_2019/) T2「[LJEPOTICA](https://hsin.hr/coci/archive/2018_2019/olympiad_tasks.pdf)」**\n\n*[Beauty and the Geek](https://www.imdb.com/title/tt0460625/?ref_=tt_sims_tt)* 是一档电视真人秀节目。这档节目旨在将美女和男性极客联系起来，达到「终极社会实验」的目的。这道题旨在将电视节目和编程竞赛联系起来，达到出一道有趣的题的目的。\n\n我们的主人公是小姐姐 Ena，她现在被困在一棵深度为 $N$ 的完全二叉树中。树上每一个节点都有一个值：根节点的值为 $1$，对于每个值为 $x$ 的节点，其左儿子的值为 $2x$，右儿子的值为 $2x+1$。Ena 可以从一个节点出发到它的某个儿子去，她要前往位于某一个叶子节点的出口（叶子节点指深度为 $N$ 且没有儿子的节点）。\n\nEna 确切地知道一条从根节点到出口叶子节点的路径，更确切地说，她知道一个正确的长为 $N-1$ 的移动序列，每一项为「左」或「右」，它可以引导 Ena 从根节点走到出口处。遗憾的是，Ena 分不清左右。因此，在她前往出口的途中，她恰好改变了 $K$ 次「左」和「右」表示的方向。在她改变主意后，她会保持她认为的左右方向一直走到一个叶子节点或下一次改变主意。Ena 只能在移动之前改变主意（包括第一个节点）一次。并且，没人知道 Ena 在进入根节点的时候她认为的左右是否是正确的方向。\n\n节目制作人将拯救迷路的 Ena。但是需要你，Ena 的极客同伴，正确回答如下问题：只考虑值在 $A$ 到 $B$（包括两端）中的叶子节点，Ena 结束移动的叶子节点值的和是多少。", "inputFormat": "第一行两个整数 $N,K$，意义如题目描述；\n\n接下来一行包含一个长为 $N-1$ 的字符串，只包含字母 `L` 和 `R`，表示从根到有出口的叶子节点的一条路径；\n\n第三行一个 $01$ 串，为 $A$ 的二进制表示，无前导 $0$，意义如题目描述；\n\n第四行一个 $01$ 串，为 $B$ 的二进制表示，无前导 $0$，意义如题目描述。", "outputFormat": "输出所求的和对 $10^9+7$ 取模后的值。", "hint": "### 样例 1 解释\n\nEna 不会改变她对左右方向的认识，但是我们不知道她在进入根节点之前认识到的左右方向是否正确。因此她可能按照正确的左右方向先左后右走到节点 $5$，也可能先右后左走到节点 $6$，两个叶子节点分别为 $A$ 和 $B$，因此答案为 $5+6=11$。\n\n### 样例 2 解释\n\nEna 经过路径的可能（按正确的左右方向）：\n- $\\{\\texttt{L, L, L}\\}$；\n- $\\{\\texttt{L, L, R}\\}$；\n- $\\{\\texttt{L, R, L}\\}$；\n- $\\{\\texttt{R, L, R}\\}$；\n- $\\{\\texttt{R, R, L}\\}$；\n- $\\{\\texttt{R, R, R}\\}$。\n\n### 数据范围 \n\n对于全部数据，$2\\le N\\le 10^3,0\\le K\\le N-1$。保证 Ena 可以到达值为 $A$ 和 $B$ 的两个叶子节点。\n\n详细子任务附加限制及分值如下表：\n\n|子任务编号|附加限制|分值|\n|:-:|:-:|:-:|\n|$1$|$K=0$|$8$|\n|$2$|$N\\le 25$|$14$|\n|$3$|$A$ 是 Ena 可能结束的叶子节点最小值，$B$ 是可能的最大值|$17$|\n|$4$|无附加限制|$61$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COI 2019] LJEPOTICA", "background": "", "description": "**译自 [COI 2019](https://hsin.hr/coci/archive/2018_2019/) T2「[LJEPOTICA](https://hsin.hr/coci/archive/2018_2019/olympiad_tasks.pdf)」**\n\n*[Beauty and the Geek](https://www.imdb.com/title/tt0460625/?ref_=tt_sims_tt)* 是一档电视真人秀节目。这档节目旨在将美女和男性极客联系起来，达到「终极社会实验」的目的。这道题旨在将电视节目和编程竞赛联系起来，达到出一道有趣的题的目的。\n\n我们的主人公是小姐姐 Ena，她现在被困在一棵深度为 $N$ 的完全二叉树中。树上每一个节点都有一个值：根节点的值为 $1$，对于每个值为 $x$ 的节点，其左儿子的值为 $2x$，右儿子的值为 $2x+1$。Ena 可以从一个节点出发到它的某个儿子去，她要前往位于某一个叶子节点的出口（叶子节点指深度为 $N$ 且没有儿子的节点）。\n\nEna 确切地知道一条从根节点到出口叶子节点的路径，更确切地说，她知道一个正确的长为 $N-1$ 的移动序列，每一项为「左」或「右」，它可以引导 Ena 从根节点走到出口处。遗憾的是，Ena 分不清左右。因此，在她前往出口的途中，她恰好改变了 $K$ 次「左」和「右」表示的方向。在她改变主意后，她会保持她认为的左右方向一直走到一个叶子节点或下一次改变主意。Ena 只能在移动之前改变主意（包括第一个节点）一次。并且，没人知道 Ena 在进入根节点的时候她认为的左右是否是正确的方向。\n\n节目制作人将拯救迷路的 Ena。但是需要你，Ena 的极客同伴，正确回答如下问题：只考虑值在 $A$ 到 $B$（包括两端）中的叶子节点，Ena 结束移动的叶子节点值的和是多少。", "inputFormat": "第一行两个整数 $N,K$，意义如题目描述；\n\n接下来一行包含一个长为 $N-1$ 的字符串，只包含字母 `L` 和 `R`，表示从根到有出口的叶子节点的一条路径；\n\n第三行一个 $01$ 串，为 $A$ 的二进制表示，无前导 $0$，意义如题目描述；\n\n第四行一个 $01$ 串，为 $B$ 的二进制表示，无前导 $0$，意义如题目描述。", "outputFormat": "输出所求的和对 $10^9+7$ 取模后的值。", "hint": "### 样例 1 解释\n\nEna 不会改变她对左右方向的认识，但是我们不知道她在进入根节点之前认识到的左右方向是否正确。因此她可能按照正确的左右方向先左后右走到节点 $5$，也可能先右后左走到节点 $6$，两个叶子节点分别为 $A$ 和 $B$，因此答案为 $5+6=11$。\n\n### 样例 2 解释\n\nEna 经过路径的可能（按正确的左右方向）：\n- $\\{\\texttt{L, L, L}\\}$；\n- $\\{\\texttt{L, L, R}\\}$；\n- $\\{\\texttt{L, R, L}\\}$；\n- $\\{\\texttt{R, L, R}\\}$；\n- $\\{\\texttt{R, R, L}\\}$；\n- $\\{\\texttt{R, R, R}\\}$。\n\n### 数据范围 \n\n对于全部数据，$2\\le N\\le 10^3,0\\le K\\le N-1$。保证 Ena 可以到达值为 $A$ 和 $B$ 的两个叶子节点。\n\n详细子任务附加限制及分值如下表：\n\n|子任务编号|附加限制|分值|\n|:-:|:-:|:-:|\n|$1$|$K=0$|$8$|\n|$2$|$N\\le 25$|$14$|\n|$3$|$A$ 是 Ena 可能结束的叶子节点最小值，$B$ 是可能的最大值|$17$|\n|$4$|无附加限制|$61$|", "locale": "zh-CN"}}}
{"pid": "P11339", "type": "P", "difficulty": 0, "samples": [["2\n1 2 3\n4 5 6\n0", "600\n1500"], ["3\n5 5 5\n6 2 10\n10 9 2\n2\n100 199", "1496\n1799\n2075"], ["5\n2 2 2\n6 6 6\n8 8 8\n9 9 9\n10 10 10\n2\n297 298", "600\n1790\n2386\n2676\n2973"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2019", "COI（克罗地亚）"], "title": "[COI 2019] SEGWAY", "background": "", "description": "**译自 [COI 2019](https://hsin.hr/coci/archive/2018_2019/) T3「[SEGWAY](https://hsin.hr/coci/archive/2018_2019/olympiad_tasks.pdf)」**\n\n在杜布罗夫尼克举行了一次平衡车比赛。赛道包含三段，每段长 $100$ 米，即，赛道总长是 $300$ 米。基于选手平衡车的电池限制，每个选手都有一个策略：在第一段上的速度，在第二段上的速度和在第三段上的速度，除非允许加速到最大速度（具体操作会在下一段解释）。遗憾的是，平衡车很慢，它们的速度在 $1$ 到 $50$ **秒每米**之间。因此，题目中速度单位为**秒每米**（而不是米每秒）。\n\n在赛道沿途有一些加速点（放置加速器）。当选手到达加速点处时，他的平衡车就会获得额外的能量，可以以 $1$ 秒每米的速度行驶 $X\\bmod 20$ 米，这里 $X$ 是在他到达加速点处时，严格在他前面的人数（包含已到达终点的人）。选手不能在额外获得的能量用尽之前使用加速器。额外的能量用尽时，如果没有新的加速器，他将按原定速度继续行驶。\n\n假设选手有能用的加速器就会用，即使不是最优的。一个加速器可以被多人同时使用，并且不会使用后不会失效。你的任务是模拟这次比赛。假设所有选手同时出发，输出他们到达终点所用的时间。", "inputFormat": "第一行包含一个整数 $N$，表示选手数；\n\n接下来 $N$ 行，分别描述选手的策略，每行包含一个范围在 $[1,50]$ 的整数，分别表示在第一段，第二段和第三段的速度；\n\n接下来一行一个整数 $M$，表示加速器个数；\n\n如果 $M>0$，接下来一行有 $M$ 个范围在 $[1,299]$ 的整数，表示每个加速器到起点的距离。距离按严格递增的顺序给出。", "outputFormat": "输出 $N$ 行，每行一个整数，第 $i$ 行输出第 $i$ 名选手到达终点的用时。", "hint": "### 样例 1 解释\n\n因为没有加速器，所以所有选手按原定速度进行比赛。\n\n### 样例 2 解释\n\n第一名选手不会使用第一个加速器（因为在他前面没有选手），但是他会使用第二个加速器，因为第二名选手在此时超过了他。总得来说，第一名选手以 $5$ 秒每米的速度行驶了 $299$ 米，以 $1$ 秒每米的速度行驶了 $1$ 米。\n\n第二名选手会使用第一个加速器（他前面有一名选手），但是他不会使用第二个加速器。总得来说，第二名选手以 $6$ 秒每米的速度行驶了 $100$ 米，以 $1$ 秒每米的速度行驶了 $1$ 米，以 $2$ 秒每米的速度行驶了 $99$ 米，以 $10$ 秒每米的速度行驶了 $100$ 米。\n\n第三名选手在两个加速器处均会以 $1$ 秒每米的速度行驶 $2$ 米。总得来说，第三名选手以 $10$ 秒每米的速度行驶了 $100$ 米，以 $1$ 秒每米的速度行驶了 $2$ 米，以 $9$ 秒每米的速度行驶了 $97$ 米，以 $1$ 秒每米的速度行驶了 $2$ 米，以 $2$ 秒每米的速度行驶了 $99$ 米。\n\n### 样例 3 解释\n\n两个加速器离终点都很近。第一名选手不会使用任何加速器，第二名选手使用两个加速器（均加速 $1$ 米），然后剩下最后 $1$ 米按原速度行驶，第三名选手会使用第一个加速器（加速 $2$ 米），然后剩下 $1$ 米按原速度行驶。最后两名选手利用最后额外的能量加速冲线。\n\n### 数据范围 \n\n对于所有数据，$1\\le N\\le 2\\times 10^4$。\n\n详细子任务附加限制及分值如下表：\n\n|子任务编号|附加限制|分值|\n|:-:|:-:|:-:|\n|$1$|$M=1$|$15$|\n|$2$|$N\\le 300$|$40$|\n|$3$|无附加限制|$45$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COI 2019] SEGWAY", "background": "", "description": "**译自 [COI 2019](https://hsin.hr/coci/archive/2018_2019/) T3「[SEGWAY](https://hsin.hr/coci/archive/2018_2019/olympiad_tasks.pdf)」**\n\n在杜布罗夫尼克举行了一次平衡车比赛。赛道包含三段，每段长 $100$ 米，即，赛道总长是 $300$ 米。基于选手平衡车的电池限制，每个选手都有一个策略：在第一段上的速度，在第二段上的速度和在第三段上的速度，除非允许加速到最大速度（具体操作会在下一段解释）。遗憾的是，平衡车很慢，它们的速度在 $1$ 到 $50$ **秒每米**之间。因此，题目中速度单位为**秒每米**（而不是米每秒）。\n\n在赛道沿途有一些加速点（放置加速器）。当选手到达加速点处时，他的平衡车就会获得额外的能量，可以以 $1$ 秒每米的速度行驶 $X\\bmod 20$ 米，这里 $X$ 是在他到达加速点处时，严格在他前面的人数（包含已到达终点的人）。选手不能在额外获得的能量用尽之前使用加速器。额外的能量用尽时，如果没有新的加速器，他将按原定速度继续行驶。\n\n假设选手有能用的加速器就会用，即使不是最优的。一个加速器可以被多人同时使用，并且不会使用后不会失效。你的任务是模拟这次比赛。假设所有选手同时出发，输出他们到达终点所用的时间。", "inputFormat": "第一行包含一个整数 $N$，表示选手数；\n\n接下来 $N$ 行，分别描述选手的策略，每行包含一个范围在 $[1,50]$ 的整数，分别表示在第一段，第二段和第三段的速度；\n\n接下来一行一个整数 $M$，表示加速器个数；\n\n如果 $M>0$，接下来一行有 $M$ 个范围在 $[1,299]$ 的整数，表示每个加速器到起点的距离。距离按严格递增的顺序给出。", "outputFormat": "输出 $N$ 行，每行一个整数，第 $i$ 行输出第 $i$ 名选手到达终点的用时。", "hint": "### 样例 1 解释\n\n因为没有加速器，所以所有选手按原定速度进行比赛。\n\n### 样例 2 解释\n\n第一名选手不会使用第一个加速器（因为在他前面没有选手），但是他会使用第二个加速器，因为第二名选手在此时超过了他。总得来说，第一名选手以 $5$ 秒每米的速度行驶了 $299$ 米，以 $1$ 秒每米的速度行驶了 $1$ 米。\n\n第二名选手会使用第一个加速器（他前面有一名选手），但是他不会使用第二个加速器。总得来说，第二名选手以 $6$ 秒每米的速度行驶了 $100$ 米，以 $1$ 秒每米的速度行驶了 $1$ 米，以 $2$ 秒每米的速度行驶了 $99$ 米，以 $10$ 秒每米的速度行驶了 $100$ 米。\n\n第三名选手在两个加速器处均会以 $1$ 秒每米的速度行驶 $2$ 米。总得来说，第三名选手以 $10$ 秒每米的速度行驶了 $100$ 米，以 $1$ 秒每米的速度行驶了 $2$ 米，以 $9$ 秒每米的速度行驶了 $97$ 米，以 $1$ 秒每米的速度行驶了 $2$ 米，以 $2$ 秒每米的速度行驶了 $99$ 米。\n\n### 样例 3 解释\n\n两个加速器离终点都很近。第一名选手不会使用任何加速器，第二名选手使用两个加速器（均加速 $1$ 米），然后剩下最后 $1$ 米按原速度行驶，第三名选手会使用第一个加速器（加速 $2$ 米），然后剩下 $1$ 米按原速度行驶。最后两名选手利用最后额外的能量加速冲线。\n\n### 数据范围 \n\n对于所有数据，$1\\le N\\le 2\\times 10^4$。\n\n详细子任务附加限制及分值如下表：\n\n|子任务编号|附加限制|分值|\n|:-:|:-:|:-:|\n|$1$|$M=1$|$15$|\n|$2$|$N\\le 300$|$40$|\n|$3$|无附加限制|$45$|", "locale": "zh-CN"}}}
{"pid": "P11340", "type": "P", "difficulty": 6, "samples": [["4 4\n1 2 3 4\n2 1 3 4\n2 4 3 1\n1 1\n1 4\n2 3 1 4\n1 4", "DA\nDA\nNE"], ["6 7\n4 6 1 5 3 2\n5 1 4 2 6 3\n4 6 1 5 2 3\n1 2\n2 2 4 5\n1 1\n2 2 4 5\n2 2 5 6\n1 2\n1 1", "DA\nNE\nNE\nDA"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2019", "COI（克罗地亚）"], "title": "[COI 2019] TENIS", "background": "", "description": "**译自 [COI 2019](https://hsin.hr/coci/archive/2018_2019/) T4「[TENIS](https://hsin.hr/coci/archive/2018_2019/olympiad_tasks.pdf)」**\n\nVito 十分喜欢打网球。不久，他就会组织一次大规模的锦标赛。这次锦标赛会有 $N$ 名选手参加，编号为从 $1$ 到 $N$。Vito 在过去几年跟踪了这些选手的数据。因此，他确定了这些选手在三种不同的球场：红土，草地和硬地上比赛的能力值。也就是说，对于每种场地，他都按最强到最弱的顺序确定了选手的排名。\n\nVito 的锦标赛赛制有点与众不同。一共会进行 $N-1$ 轮比赛。在每场比赛中，还没有被淘汰的两名选手会在某种特定的场地上进行比赛。在这种场地上较弱的选手会被淘汰出局。$N-1$ 轮比赛后唯一的胜者就是这次锦标赛的冠军。\n\nVito 是一个很有影响力的人，可以操纵比赛的结果。即对于每场比赛，Vito 可以选择参赛选手和比赛场地。当然，他只能选择未被淘汰的选手。\n\nVito 经常更新他收集的数据，他有时会交换在某种场地上两名选手的排名。并且他有很多朋友，有些朋友会问他：「选手 $X$ 是我的外甥，他有机会夺冠吗？」（*wink*），为了回答这些询问，你需要写一个程序帮助 Vito 更新排名，并根据当前时刻 Vito 的排名表回答他朋友的提问。", "inputFormat": "第一行两个整数 $N,Q$，分别表示选手数和事件数；\n\n接下来三行，每行包含一个 $\\{1,2,\\ldots , N\\}$ 的排列，表示选手在这种特定的球场上的排名，按从最强到最弱的顺序给出。\n\n接下来 $Q$ 行，每行表示一个事件：\n- `1 X`：表示 Vito 的朋友想知道选手 $X$ 能否夺冠；\n- `2 P A B`：表示 Vito 意识到需要交换第 $P$ 个排名表中选手 $A$ 和选手 $B$ 的排名位置。", "outputFormat": "对于每个 `1` 类型的询问输出一行，包含 `DA` 或 `NE`（克罗地亚语中的「是」和「否」）。", "hint": "### 样例 1 解释\n\n如果所有比赛都在第一种场地上进行，选手 $1$ 会夺冠；\n\n选手 $4$ 夺冠的方式：\n- 选手 $3$ 和 $4$ 在第三种场地上进行比赛，选手 $4$ 赢了；\n- 选手 $1$ 和 $2$ 在第一种场地上进行比赛，选手 $1$ 赢了；\n- 选手 $1$ 和 $4$ 在第三种场地上进行比赛，选手 $4$ 赢了。\n\n在更新第三种场地上的选手排名后（排名变为：$\\{2,1,3,4\\}$），选手 $4$ 变成了在所有场地上都是最弱的了，因此他不可能夺冠。\n\n### 数据范围\n\n对于全部数据，$1\\le N,Q\\le 10^5,1\\le X,A,B\\le N,1\\le P\\le 3,A\\neq B$。\n\n详细子任务附加限制及分值如下表：\n\n|子任务编号|附加限制|分值|\n|:-:|:-:|:-:|\n|$1$|$N\\le 15,Q\\le 10$|$7$|\n|$2$|$N\\le 10^3,Q\\le 10$|$11$|\n|$3$|$Q\\le 10$|$12$|\n|$4$|所有的事件类型都是 `1` 类型|$21$|\n|$5$|无附加限制|$49$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COI 2019] TENIS", "background": "", "description": "**译自 [COI 2019](https://hsin.hr/coci/archive/2018_2019/) T4「[TENIS](https://hsin.hr/coci/archive/2018_2019/olympiad_tasks.pdf)」**\n\nVito 十分喜欢打网球。不久，他就会组织一次大规模的锦标赛。这次锦标赛会有 $N$ 名选手参加，编号为从 $1$ 到 $N$。Vito 在过去几年跟踪了这些选手的数据。因此，他确定了这些选手在三种不同的球场：红土，草地和硬地上比赛的能力值。也就是说，对于每种场地，他都按最强到最弱的顺序确定了选手的排名。\n\nVito 的锦标赛赛制有点与众不同。一共会进行 $N-1$ 轮比赛。在每场比赛中，还没有被淘汰的两名选手会在某种特定的场地上进行比赛。在这种场地上较弱的选手会被淘汰出局。$N-1$ 轮比赛后唯一的胜者就是这次锦标赛的冠军。\n\nVito 是一个很有影响力的人，可以操纵比赛的结果。即对于每场比赛，Vito 可以选择参赛选手和比赛场地。当然，他只能选择未被淘汰的选手。\n\nVito 经常更新他收集的数据，他有时会交换在某种场地上两名选手的排名。并且他有很多朋友，有些朋友会问他：「选手 $X$ 是我的外甥，他有机会夺冠吗？」（*wink*），为了回答这些询问，你需要写一个程序帮助 Vito 更新排名，并根据当前时刻 Vito 的排名表回答他朋友的提问。", "inputFormat": "第一行两个整数 $N,Q$，分别表示选手数和事件数；\n\n接下来三行，每行包含一个 $\\{1,2,\\ldots , N\\}$ 的排列，表示选手在这种特定的球场上的排名，按从最强到最弱的顺序给出。\n\n接下来 $Q$ 行，每行表示一个事件：\n- `1 X`：表示 Vito 的朋友想知道选手 $X$ 能否夺冠；\n- `2 P A B`：表示 Vito 意识到需要交换第 $P$ 个排名表中选手 $A$ 和选手 $B$ 的排名位置。", "outputFormat": "对于每个 `1` 类型的询问输出一行，包含 `DA` 或 `NE`（克罗地亚语中的「是」和「否」）。", "hint": "### 样例 1 解释\n\n如果所有比赛都在第一种场地上进行，选手 $1$ 会夺冠；\n\n选手 $4$ 夺冠的方式：\n- 选手 $3$ 和 $4$ 在第三种场地上进行比赛，选手 $4$ 赢了；\n- 选手 $1$ 和 $2$ 在第一种场地上进行比赛，选手 $1$ 赢了；\n- 选手 $1$ 和 $4$ 在第三种场地上进行比赛，选手 $4$ 赢了。\n\n在更新第三种场地上的选手排名后（排名变为：$\\{2,1,3,4\\}$），选手 $4$ 变成了在所有场地上都是最弱的了，因此他不可能夺冠。\n\n### 数据范围\n\n对于全部数据，$1\\le N,Q\\le 10^5,1\\le X,A,B\\le N,1\\le P\\le 3,A\\neq B$。\n\n详细子任务附加限制及分值如下表：\n\n|子任务编号|附加限制|分值|\n|:-:|:-:|:-:|\n|$1$|$N\\le 15,Q\\le 10$|$7$|\n|$2$|$N\\le 10^3,Q\\le 10$|$11$|\n|$3$|$Q\\le 10$|$12$|\n|$4$|所有的事件类型都是 `1` 类型|$21$|\n|$5$|无附加限制|$49$|", "locale": "zh-CN"}}}
{"pid": "P11341", "type": "P", "difficulty": 0, "samples": [["5\n-1 -1 -1 -1 -1\n-1 -1 1 -1 -1\n-1 -1 -1 -1 -1\n-1 -1 1 -1 -1\n-1 -1 -1 -1 -1", "-9\n"], ["5\n1 2 3 4 5\n2 3 4 5 1\n3 4 5 1 2\n4 5 1 2 3\n5 1 2 3 4", "60"], ["5\n1 1 -1 -1 1\n-1 1 -1 1 1\n1 1 1 1 -1\n1 -1 -1 1 -1\n1 -1 -1 1 1", "15"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["2023", "交互题", "KOI（韩国）"], "title": "[KTSC 2023 R1] 地牢", "background": "**请勿使用 C++14 (GCC 9) 提交。**\n\n你需要在文件开头加入如下代码：\n\n```cpp\n#include<vector>\nint max_item_sum(std::vector<std::vector<int>> V);\n```", "description": "**题目译自 [2023년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2023/)  T1 「[던전](https://assets.ioikorea.kr/ioitst/2023/1/dungeon/dungeon_statement.pdf)」**\n\n哲洙和英姬在游戏中需要穿越一个地牢。地牢是一个 $N \\times N$ 的网格。网格的行从上到下编号为 $0$ 到 $N-1$，列从左到右编号为 $0$ 到 $N-1$。位于第 $i$ 行，第 $j$ 列的格子记为 $(i, j)$。\n\n穿越地牢的规则如下：\n\n- 哲洙从地牢的左上角出发，移动到右下角。每次移动时，哲洙只能向右或向下移动到相邻的格子。\n- 英姬从地牢的右上角出发，移动到左下角。每次移动时，英姬只能向左或向下移动到相邻的格子。\n\n地牢的每个格子里都有一个物品。每个物品的价值可以是正整数、$0$ 或负整数，位于 $(i, j)$ 格子的物品价值为 $V[i][j]$。哲洙和英姬已经知道所有格子中物品的价值。穿越地牢后，哲洙和英姬会收集他们经过的所有格子的物品。如果两人都经过同一个格子，那么这个格子的物品只会被收集一次。\n\n请编写一个程序，计算哲洙和英姬能够收集的物品价值的最大可能总和。\n\n你需要实现以下函数：\n\n```cpp\nint max_item_sum(std::vector<std::vector<int>> V);\n```\n\n- `V`：大小为 $N \\times N$ 的二维整数数组。对于所有 $i, j$ $(0 \\leq i, j \\leq N-1)$，$V[i][j]$ 是地牢中 $(i, j)$ 格子的物品价值。\n- 该函数返回哲洙和英姬能够收集的物品价值的最大可能总和。\n\n注意，提交的代码中不应包含任何输入输出操作。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N$\n- 第 $2+i$ $(0 \\leq i \\leq N-1)$ 行：$V[i][0]\\,V[i][1]\\,\\cdots\\,V[i][N-1]$", "outputFormat": "示例评测程序按以下格式输出：\n\n- 第 $1$ 行：函数 `max_item_sum` 返回的值\n", "hint": "### 样例 1 解释\n\n考虑 $N=5, V=[[-1,-1,-1,-1,-1],[-1,-1,1,-1,-1],[-1,-1,-1,-1,-1],[-1,-1,1,-1,-1],[-1,-1,-1,-1,-1]]$ 的情况。\n\n评测程序将调用如下函数：\n\n```cpp\nmax_item_sum([[-1,-1,-1,-1,-1],[-1,-1,1,-1,-1],[-1,-1,-1,-1,-1],[-1,-1,1,-1,-1],[-1,-1,-1,-1,-1]]);\n```\n\n下图展示了地牢的情况。每个格子中的值表示该格子的物品价值。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ig9pxx8x.png)\n\n下图左侧的蓝色格子表示哲洙经过的格子，右侧的黄色格子表示英姬经过的格子。哲洙经过的格子中物品的总价值为 $-4$，英姬经过的格子中物品的总价值也是 $-4$，两人都经过的格子中物品的总价值为 $-1$。因此，物品的总价值为 $-9$，这是可能的最大总和。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lx2xn39p.png)\n\n函数应返回 `-9`。\n\n### 数据范围\n\n对于所有输入数据，满足：\n\n- $2 \\leq N \\leq 1000$\n- 对于所有 $i,j$ $(0 \\leq i, j \\leq N-1)$，$-10^5 \\leq V[i][j] \\leq 10^5$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :-: | :-: | :-: |\n| $1$ | $11$ | $N \\leq 5$ |\n| $2$ | $44$ | $N \\leq 300$ |\n| $3$ | $15$ | 对于所有 $i,j$ $(0 \\leq i, j \\leq N-1)$，$V[i][j] \\geq 0$ |\n| $4$ | $30$ | 无附加限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KTSC 2023 R1] 地牢", "background": "**请勿使用 C++14 (GCC 9) 提交。**\n\n你需要在文件开头加入如下代码：\n\n```cpp\n#include<vector>\nint max_item_sum(std::vector<std::vector<int>> V);\n```", "description": "**题目译自 [2023년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2023/)  T1 「[던전](https://assets.ioikorea.kr/ioitst/2023/1/dungeon/dungeon_statement.pdf)」**\n\n哲洙和英姬在游戏中需要穿越一个地牢。地牢是一个 $N \\times N$ 的网格。网格的行从上到下编号为 $0$ 到 $N-1$，列从左到右编号为 $0$ 到 $N-1$。位于第 $i$ 行，第 $j$ 列的格子记为 $(i, j)$。\n\n穿越地牢的规则如下：\n\n- 哲洙从地牢的左上角出发，移动到右下角。每次移动时，哲洙只能向右或向下移动到相邻的格子。\n- 英姬从地牢的右上角出发，移动到左下角。每次移动时，英姬只能向左或向下移动到相邻的格子。\n\n地牢的每个格子里都有一个物品。每个物品的价值可以是正整数、$0$ 或负整数，位于 $(i, j)$ 格子的物品价值为 $V[i][j]$。哲洙和英姬已经知道所有格子中物品的价值。穿越地牢后，哲洙和英姬会收集他们经过的所有格子的物品。如果两人都经过同一个格子，那么这个格子的物品只会被收集一次。\n\n请编写一个程序，计算哲洙和英姬能够收集的物品价值的最大可能总和。\n\n你需要实现以下函数：\n\n```cpp\nint max_item_sum(std::vector<std::vector<int>> V);\n```\n\n- `V`：大小为 $N \\times N$ 的二维整数数组。对于所有 $i, j$ $(0 \\leq i, j \\leq N-1)$，$V[i][j]$ 是地牢中 $(i, j)$ 格子的物品价值。\n- 该函数返回哲洙和英姬能够收集的物品价值的最大可能总和。\n\n注意，提交的代码中不应包含任何输入输出操作。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N$\n- 第 $2+i$ $(0 \\leq i \\leq N-1)$ 行：$V[i][0]\\,V[i][1]\\,\\cdots\\,V[i][N-1]$", "outputFormat": "示例评测程序按以下格式输出：\n\n- 第 $1$ 行：函数 `max_item_sum` 返回的值\n", "hint": "### 样例 1 解释\n\n考虑 $N=5, V=[[-1,-1,-1,-1,-1],[-1,-1,1,-1,-1],[-1,-1,-1,-1,-1],[-1,-1,1,-1,-1],[-1,-1,-1,-1,-1]]$ 的情况。\n\n评测程序将调用如下函数：\n\n```cpp\nmax_item_sum([[-1,-1,-1,-1,-1],[-1,-1,1,-1,-1],[-1,-1,-1,-1,-1],[-1,-1,1,-1,-1],[-1,-1,-1,-1,-1]]);\n```\n\n下图展示了地牢的情况。每个格子中的值表示该格子的物品价值。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ig9pxx8x.png)\n\n下图左侧的蓝色格子表示哲洙经过的格子，右侧的黄色格子表示英姬经过的格子。哲洙经过的格子中物品的总价值为 $-4$，英姬经过的格子中物品的总价值也是 $-4$，两人都经过的格子中物品的总价值为 $-1$。因此，物品的总价值为 $-9$，这是可能的最大总和。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lx2xn39p.png)\n\n函数应返回 `-9`。\n\n### 数据范围\n\n对于所有输入数据，满足：\n\n- $2 \\leq N \\leq 1000$\n- 对于所有 $i,j$ $(0 \\leq i, j \\leq N-1)$，$-10^5 \\leq V[i][j] \\leq 10^5$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :-: | :-: | :-: |\n| $1$ | $11$ | $N \\leq 5$ |\n| $2$ | $44$ | $N \\leq 300$ |\n| $3$ | $15$ | 对于所有 $i,j$ $(0 \\leq i, j \\leq N-1)$，$V[i][j] \\geq 0$ |\n| $4$ | $30$ | 无附加限制 |", "locale": "zh-CN"}}}
{"pid": "P11342", "type": "P", "difficulty": 6, "samples": [["4\n0 9\n0 8\n0 0\n9 9 9", "9"], ["11\n0 9\n0 8\n2 0\n3 7\n3 1\n2 6\n0 0\n7 7\n7 1\n9 6\n1000000000000 1000000000000 1000000000000 1000000000000 1000000000000 1000000000000", "1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["2023", "交互题", "KOI（韩国）"], "title": "[KTSC 2023 R1] 外环道路 2", "background": "**请勿使用 C++14 (GCC 9) 提交。**\n\n请在程序开头加入如下代码：\n\n```cpp\n#include<vector>\nlong long place_police(std::vector<int> P, std::vector<long long> C, std::vector<long long> W);\n```", "description": "**题目译自 [2023년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2023/)  T2 「[외곽 순환 도로 2](https://assets.ioikorea.kr/ioitst/2023/1/ringroad2/ringroad2_statement.pdf)」**\n\nKOI 城市由 $N$ 个交叉路口和 $N-1$ 条双向道路组成，任意两个不同的交叉路口都可以通过这些道路互相到达。也就是说，城市的道路网络是一个树结构。道路位于二维平面上，除了端点外，任何两条道路都不相交。每条道路都有一个非负整数的权重。\n\nKOI 城市几十年前还是一个小村庄，但随着人口的涌入和城市的扩张，变得越来越大。在快速扩张的过程中，市长为了方便管理，给交叉路口编号为 $0$ 到 $N-1$。这种编号系统具有以下特性：\n\n- $0$ 号交叉路口是城市的中心，保证至少有两条道路与其相连。\n- 交叉路口的编号是以 $0$ 号交叉路口为根的树的前序遍历顺序之一。\n- 对于每个交叉路口，考虑与其相邻的（直接连接的）交叉路口中编号最小的一个。从这个交叉路口开始，按逆时针方向列出相邻交叉路口的编号，编号是递增的。\n\n随着越来越多的人涌入 KOI 城市，交通拥堵问题变得越来越严重。市长决定通过建设外环道路来解决这个问题。将所有只有一条道路相连的交叉路口按编号递增的顺序排列，得到列表 $\\{V[0], V[1], \\ldots, V[K-1]\\}$。市长决定在所有 $i$ $(0 \\leq i \\leq K-1)$ 的情况下，建设连接 $V[i]$ 和 $V[(i+1) \\bmod K]$ 的双向道路。每条道路的权重为非负整数 $W[i]$。根据编号系统的特性，可以确保这些外环道路不会在端点之外的任何位置相交。\n\nKOI 城市的邪恶犯罪团伙 Dlalswp 对市民造成了很大伤害。市长决定派遣情报人员来抓捕 Dlalswp 犯罪团伙。根据情报，Dlalswp 犯罪团伙将长度为奇数的简单环作为犯罪区域，并在这些环上进行犯罪活动。\n\n为了抓捕臭名昭著的 Dlalswp 犯罪团伙，市长决定在所有长度为奇数的简单环上部署警察。每条道路上部署警察的成本等于该道路的权重。请计算市长实现目标所需的最小成本。\n\n你需要实现以下函数：\n\n```cpp\nlong long place_police(vector<int> P, vector<long long> C, vector<long long> W);\n```\n\n- 该函数只会被调用一次。\n- `P`：大小为 $N-1$ 的整数数组，表示建设外环道路前 KOI 城市的原始道路。对于每个 $0 \\leq i \\leq N-2$，存在一条连接 $P[i]$ 和 $i+1$ 的道路。\n- `C`：大小为 $N-1$ 的整数数组。对于每个 $i$ $(0 \\leq i \\leq N-2)$，连接 $P[i]$ 和 $i+1$ 的道路的权重为 $C[i]$。\n- `W`：大小为 $K$ 的整数数组。对于每个 $i$ $(0 \\leq i \\leq K-1)$，连接 $V[i]$ 和 $V[(i+1) \\bmod K]$ 的双向道路的权重为 $W[i]$。\n- 该函数返回在所有长度为奇数的简单环上部署警察的最小成本。\n\n注意，提交的代码中不应包含任何输入输出操作。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N$\n- 第 $2+i$ $(0 \\leq i \\leq N-2)$ 行：$P[i]\\,C[i]$\n- 第 $1+N$ 行：$W[0]\\,W[1]\\,\\cdots\\,W[K-1]$", "outputFormat": "示例评测程序按以下格式输出：\n\n- 第 $1$ 行：函数 `place_police` 返回的值", "hint": "### 样例 1 解释\n考虑 $N=4, P=[0,0,0], C=[9,8,0], W=[9,9,9]$ 的情况。\n\n评测程序将调用如下函数：\n\n```cpp\nplace_police([0, 0, 0], [9, 8, 0], [9, 9, 9]);\n```\n\nKOI 城市中共有 $4$ 个奇数环，分别是 $\\{0,1,2\\},\\{0,2,3\\},\\{0,3,1\\},\\{1,2,3\\}$。如果市长在连接 $(0,3)$ 的权重为 $0$ 的道路和连接 $(1,2)$ 的权重为 $9$ 的道路上部署警察，那么所有奇数环上至少有一条道路上部署了警察。这个部署的成本是 $0+9=9$，这是实现目标的最小成本。\n\n函数应返回 `9`。\n\n### 样例 2 解释\n\n考虑 $N=11$,\n$P=[0,0,2,3,3,2,0,7,7,9]$,\n$C=[9,8,0,7,1,6,0,7,1,6]$,\n$W=[1000000000000, \\ldots, 1000000000000]$ 的情况。$W$ 的大小为 $6$，所有元素均为 $10^{12}$。\n\n评测程序将调用如下函数：\n\n```cpp\nplace_police([0, 0, 2, 3, 3, 2, 0, 7, 7, 9], [9, 8, 0, 7, 1, 6, 0, 7, 1, 6], [1000000000000, 1000000000000, 1000000000000, 1000000000000, 1000000000000, 1000000000000]);\n```\n\n如果市长在连接 $(2,3)$ 的权重为 0 的道路、连接 $(0,7)$ 的权重为 0 的道路和连接 $(3,5)$ 的权重为 1 的道路上部署警察，那么所有奇数环上至少有一条道路上部署了警察。这个部署的成本是 $0+0+1=1$，这是实现目标的最小成本。\n\n函数应返回 `1`。\n\n### 数据范围\n\n对于所有输入数据，满足：\n\n- $4 \\leq N \\leq 10^5$\n- 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$0 \\leq P[i] \\leq i$\n- 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$0 \\leq C[i] \\leq 10^{12}$\n- 对于所有 $i$ $(0 \\leq i \\leq K-1)$，$0 \\leq W[i] \\leq 10^{12}$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :-: | :-: | :-: |\n| $1$ | $6$ | $K \\leq 5$ |\n| $2$ | $8$ | 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$P[i]=0$ |\n| $3$ | $5$ | 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$C[i] \\leq 10^{6}$；对于所有 $i$ $(0 \\leq i \\leq K-1)$，$W[i]=10^{12}$；$K$ 为偶数 |\n| $4$ | $15$ | 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$C[i] \\leq 10^{6}$；对于所有 $i$ $(0 \\leq i \\leq K-1)$，$W[i]=10^{12}$ |\n| $5$ | $57$ | 不存在与 $4$ 条以上道路相连的交叉路口 |\n| $6$ | $9$ | 无附加限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KTSC 2023 R1] 外环道路 2", "background": "**请勿使用 C++14 (GCC 9) 提交。**\n\n请在程序开头加入如下代码：\n\n```cpp\n#include<vector>\nlong long place_police(std::vector<int> P, std::vector<long long> C, std::vector<long long> W);\n```", "description": "**题目译自 [2023년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2023/)  T2 「[외곽 순환 도로 2](https://assets.ioikorea.kr/ioitst/2023/1/ringroad2/ringroad2_statement.pdf)」**\n\nKOI 城市由 $N$ 个交叉路口和 $N-1$ 条双向道路组成，任意两个不同的交叉路口都可以通过这些道路互相到达。也就是说，城市的道路网络是一个树结构。道路位于二维平面上，除了端点外，任何两条道路都不相交。每条道路都有一个非负整数的权重。\n\nKOI 城市几十年前还是一个小村庄，但随着人口的涌入和城市的扩张，变得越来越大。在快速扩张的过程中，市长为了方便管理，给交叉路口编号为 $0$ 到 $N-1$。这种编号系统具有以下特性：\n\n- $0$ 号交叉路口是城市的中心，保证至少有两条道路与其相连。\n- 交叉路口的编号是以 $0$ 号交叉路口为根的树的前序遍历顺序之一。\n- 对于每个交叉路口，考虑与其相邻的（直接连接的）交叉路口中编号最小的一个。从这个交叉路口开始，按逆时针方向列出相邻交叉路口的编号，编号是递增的。\n\n随着越来越多的人涌入 KOI 城市，交通拥堵问题变得越来越严重。市长决定通过建设外环道路来解决这个问题。将所有只有一条道路相连的交叉路口按编号递增的顺序排列，得到列表 $\\{V[0], V[1], \\ldots, V[K-1]\\}$。市长决定在所有 $i$ $(0 \\leq i \\leq K-1)$ 的情况下，建设连接 $V[i]$ 和 $V[(i+1) \\bmod K]$ 的双向道路。每条道路的权重为非负整数 $W[i]$。根据编号系统的特性，可以确保这些外环道路不会在端点之外的任何位置相交。\n\nKOI 城市的邪恶犯罪团伙 Dlalswp 对市民造成了很大伤害。市长决定派遣情报人员来抓捕 Dlalswp 犯罪团伙。根据情报，Dlalswp 犯罪团伙将长度为奇数的简单环作为犯罪区域，并在这些环上进行犯罪活动。\n\n为了抓捕臭名昭著的 Dlalswp 犯罪团伙，市长决定在所有长度为奇数的简单环上部署警察。每条道路上部署警察的成本等于该道路的权重。请计算市长实现目标所需的最小成本。\n\n你需要实现以下函数：\n\n```cpp\nlong long place_police(vector<int> P, vector<long long> C, vector<long long> W);\n```\n\n- 该函数只会被调用一次。\n- `P`：大小为 $N-1$ 的整数数组，表示建设外环道路前 KOI 城市的原始道路。对于每个 $0 \\leq i \\leq N-2$，存在一条连接 $P[i]$ 和 $i+1$ 的道路。\n- `C`：大小为 $N-1$ 的整数数组。对于每个 $i$ $(0 \\leq i \\leq N-2)$，连接 $P[i]$ 和 $i+1$ 的道路的权重为 $C[i]$。\n- `W`：大小为 $K$ 的整数数组。对于每个 $i$ $(0 \\leq i \\leq K-1)$，连接 $V[i]$ 和 $V[(i+1) \\bmod K]$ 的双向道路的权重为 $W[i]$。\n- 该函数返回在所有长度为奇数的简单环上部署警察的最小成本。\n\n注意，提交的代码中不应包含任何输入输出操作。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N$\n- 第 $2+i$ $(0 \\leq i \\leq N-2)$ 行：$P[i]\\,C[i]$\n- 第 $1+N$ 行：$W[0]\\,W[1]\\,\\cdots\\,W[K-1]$", "outputFormat": "示例评测程序按以下格式输出：\n\n- 第 $1$ 行：函数 `place_police` 返回的值", "hint": "### 样例 1 解释\n考虑 $N=4, P=[0,0,0], C=[9,8,0], W=[9,9,9]$ 的情况。\n\n评测程序将调用如下函数：\n\n```cpp\nplace_police([0, 0, 0], [9, 8, 0], [9, 9, 9]);\n```\n\nKOI 城市中共有 $4$ 个奇数环，分别是 $\\{0,1,2\\},\\{0,2,3\\},\\{0,3,1\\},\\{1,2,3\\}$。如果市长在连接 $(0,3)$ 的权重为 $0$ 的道路和连接 $(1,2)$ 的权重为 $9$ 的道路上部署警察，那么所有奇数环上至少有一条道路上部署了警察。这个部署的成本是 $0+9=9$，这是实现目标的最小成本。\n\n函数应返回 `9`。\n\n### 样例 2 解释\n\n考虑 $N=11$,\n$P=[0,0,2,3,3,2,0,7,7,9]$,\n$C=[9,8,0,7,1,6,0,7,1,6]$,\n$W=[1000000000000, \\ldots, 1000000000000]$ 的情况。$W$ 的大小为 $6$，所有元素均为 $10^{12}$。\n\n评测程序将调用如下函数：\n\n```cpp\nplace_police([0, 0, 2, 3, 3, 2, 0, 7, 7, 9], [9, 8, 0, 7, 1, 6, 0, 7, 1, 6], [1000000000000, 1000000000000, 1000000000000, 1000000000000, 1000000000000, 1000000000000]);\n```\n\n如果市长在连接 $(2,3)$ 的权重为 0 的道路、连接 $(0,7)$ 的权重为 0 的道路和连接 $(3,5)$ 的权重为 1 的道路上部署警察，那么所有奇数环上至少有一条道路上部署了警察。这个部署的成本是 $0+0+1=1$，这是实现目标的最小成本。\n\n函数应返回 `1`。\n\n### 数据范围\n\n对于所有输入数据，满足：\n\n- $4 \\leq N \\leq 10^5$\n- 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$0 \\leq P[i] \\leq i$\n- 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$0 \\leq C[i] \\leq 10^{12}$\n- 对于所有 $i$ $(0 \\leq i \\leq K-1)$，$0 \\leq W[i] \\leq 10^{12}$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :-: | :-: | :-: |\n| $1$ | $6$ | $K \\leq 5$ |\n| $2$ | $8$ | 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$P[i]=0$ |\n| $3$ | $5$ | 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$C[i] \\leq 10^{6}$；对于所有 $i$ $(0 \\leq i \\leq K-1)$，$W[i]=10^{12}$；$K$ 为偶数 |\n| $4$ | $15$ | 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$C[i] \\leq 10^{6}$；对于所有 $i$ $(0 \\leq i \\leq K-1)$，$W[i]=10^{12}$ |\n| $5$ | $57$ | 不存在与 $4$ 条以上道路相连的交叉路口 |\n| $6$ | $9$ | 无附加限制 |", "locale": "zh-CN"}}}
{"pid": "P11343", "type": "P", "difficulty": 7, "samples": [["5\n10 5 13 4 3\n10 7 5 9 1\n1 0 1\n0 2 5\n3 2 10\n2 4 3", "20\n60\n104\n88"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["点分治", "2023", "交互题", "斜率优化", "KOI（韩国）"], "title": "[KTSC 2023 R1] 出租车旅行", "background": "**请勿用 C++14 (GCC 9) 提交。**\n\n请在程序开头加入如下代码：\n\n```cpp\n#include<vector>\nstd::vector<long long> travel(std::vector<long long> A, std::vector<int> B, std::vector<int> U, std::vector<int> V, std::vector<int> W);\n```", "description": "**题目译自 [2023년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2023/)  T3 「[택시 여행](https://assets.ioikorea.kr/ioitst/2023/1/taxi/taxi_statement.pdf)」**\n\nIOI 国由 $N$ 个城市和连接这些城市的 $N-1$ 条双向道路组成，任意两个不同的城市都可以通过这些道路互相到达。也就是说，IOI 国的道路网络是一个树结构。\n\n每个城市都有一个编号，从 $0$ 到 $N-1$，其中 $0$ 号城市是 IOI 国的首都。对于每个 $i$ $(0 \\leq i \\leq N-2)$，第 $i$ 条道路连接 $U[i]$ 号城市和 $V[i]$ 号城市，道路长度为 $W[i]$ 公里。\n\n在 IOI 国，不同城市的出租车费用不同。具体来说，对于每个 $i$ $(0 \\leq i \\leq N-1)$，从 $i$ 号城市出发的出租车有一个基本费用 $A[i]$ 元和每公里的费用 $B[i]$ 元。这意味着，如果从 $i$ 号城市出发并行驶 $d$ 公里，需要支付 $A[i] + d \\times B[i]$ 元。\n\n小明目前住在首都 $0$ 号城市，他计划乘坐出租车去其他城市旅行。当他到达一个城市时，可以选择继续乘坐当前的出租车，或者换乘该城市出发的出租车。当然，换乘出租车需要支付基本费用，并且每公里的费用也可能不同。请计算从 0 号城市出发到达其他所有城市的最小费用。\n\n你需要实现以下函数：\n\n```cpp\nvector<long long> travel(vector<long long> A, vector<int> B, vector<int> U, vector<int> V, vector<int> W);\n```\n\n- 该函数只会被调用一次。\n- `A`：大小为 $N$ 的整数数组。对于每个 $i$ $(0 \\leq i \\leq N-1)$，$A[i]$ 是从 $i$ 号城市出发的出租车的基本费用。\n- `B`：大小为 $N$ 的整数数组。对于每个 $i$ $(0 \\leq i \\leq N-1)$，$B[i]$ 是从 $i$ 号城市出发的出租车的每公里费用。\n- `U, V, W`：大小为 $N-1$ 的整数数组。对于每个 $i$ $(0 \\leq i \\leq N-2)$，$U[i]$ 号城市和 $V[i]$ 号城市之间有一条长度为 $W[i]$ 公里的道路。\n- 该函数返回一个大小为 $N-1$ 的数组 $C$。对于每个 $i$ $(0 \\leq i \\leq N-2)$，$C[i]$ 是从 $0$ 号城市出发到达 $i+1$ 号城市的最小费用。\n\n注意，提交的代码中不应包含任何输入输出操作。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N$\n- 第 $2$ 行：$A[0]\\,A[1]\\,\\cdots\\,A[N-1]$\n- 第 $3$ 行：$B[0]\\,B[1]\\,\\cdots\\,B[N-1]$\n- 第 $4+i$ $(0 \\leq i \\leq N-2)$ 行：$U[i]\\,V[i]\\,W[i]$", "outputFormat": "示例评测程序按以下格式输出：\n\n- 第 $i$ 行：函数 `travel` 返回的数组的第 $i$ 个元素", "hint": "### 样例解释\n\n考虑 $N=5, A=[10,5,13,4,3], B=[10,7,5,9,1], U=[1,0,3,2], V=[0,2,2,4], W=[1,5,10,3]$ 的情况。\n\n评测程序将调用如下函数：\n\n```cpp\ntravel([10, 5, 13, 4, 3], [10, 7, 5, 9, 1], [1, 0, 3, 2], [0, 2, 2, 4], [1, 5, 10, 3]);\n```\n\n- 从 $0$ 号城市到 $1$ 号城市的最优方案是直接从 $0$ 号城市乘坐出租车，总费用为 $20$ 元。\n- 从 $0$ 号城市到 $2$ 号城市的最优方案是直接从 $0$ 号城市乘坐出租车，总费用为 $60$ 元。\n- 从 $0$ 号城市到 $4$ 号城市的最优方案是先从 $0$ 号城市乘坐出租车到 $1$ 号城市，然后换乘，再经过 $0$ 号和 $2$ 号城市到达 $4$ 号城市，总费用为 $88$ 元。\n- 从 $0$ 号城市到 $3$ 号城市的最优方案是先从 $0$ 号城市乘坐出租车到 $1$ 号城市，然后换乘，再经过 $0$ 号和 $2$ 号城市到达 $4$ 号城市，再换乘，经过 $2$ 号城市到达 $3$ 号城市，总费用为 $104$ 元。\n\n函数应返回 `[20, 60, 104, 88]`。\n\n### 数据范围\n\n对于所有输入数据，满足：\n\n- $2 \\leq N \\leq 10^5$\n- 对于所有 $i$ $(0 \\leq i \\leq N-1)$，$0 \\leq A[i] \\leq 10^{12}$\n- 对于所有 $i$ $(0 \\leq i \\leq N-1)$，$0 \\leq B[i] \\leq 10^6$\n- 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$0 \\leq U[i], V[i] \\leq N-1 ; U[i] \\neq V[i]$\n- 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$1 \\leq W[i] \\leq 10^6$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :-: | :-: | :-: |\n| $1$ | $7$ | $N \\leq 20$ |\n| $2$ | $8$ | 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$U[i]=i ; V[i]=i+1$ |\n| $3$ | $13$ | $N \\leq 2000$ |\n| $4$ | $17$ | 对于所有 $i$ $(0 \\leq i \\leq N-1)$，$B[i] \\leq 30$ |\n| $5$ | $29$ | $B[i] \\neq 0$ $(0 \\leq i \\leq N-1)$ 的 $i$ 不超过 $2000$ 个 |\n| $6$ | $26$ | 无附加限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KTSC 2023 R1] 出租车旅行", "background": "**请勿用 C++14 (GCC 9) 提交。**\n\n请在程序开头加入如下代码：\n\n```cpp\n#include<vector>\nstd::vector<long long> travel(std::vector<long long> A, std::vector<int> B, std::vector<int> U, std::vector<int> V, std::vector<int> W);\n```", "description": "**题目译自 [2023년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2023/)  T3 「[택시 여행](https://assets.ioikorea.kr/ioitst/2023/1/taxi/taxi_statement.pdf)」**\n\nIOI 国由 $N$ 个城市和连接这些城市的 $N-1$ 条双向道路组成，任意两个不同的城市都可以通过这些道路互相到达。也就是说，IOI 国的道路网络是一个树结构。\n\n每个城市都有一个编号，从 $0$ 到 $N-1$，其中 $0$ 号城市是 IOI 国的首都。对于每个 $i$ $(0 \\leq i \\leq N-2)$，第 $i$ 条道路连接 $U[i]$ 号城市和 $V[i]$ 号城市，道路长度为 $W[i]$ 公里。\n\n在 IOI 国，不同城市的出租车费用不同。具体来说，对于每个 $i$ $(0 \\leq i \\leq N-1)$，从 $i$ 号城市出发的出租车有一个基本费用 $A[i]$ 元和每公里的费用 $B[i]$ 元。这意味着，如果从 $i$ 号城市出发并行驶 $d$ 公里，需要支付 $A[i] + d \\times B[i]$ 元。\n\n小明目前住在首都 $0$ 号城市，他计划乘坐出租车去其他城市旅行。当他到达一个城市时，可以选择继续乘坐当前的出租车，或者换乘该城市出发的出租车。当然，换乘出租车需要支付基本费用，并且每公里的费用也可能不同。请计算从 0 号城市出发到达其他所有城市的最小费用。\n\n你需要实现以下函数：\n\n```cpp\nvector<long long> travel(vector<long long> A, vector<int> B, vector<int> U, vector<int> V, vector<int> W);\n```\n\n- 该函数只会被调用一次。\n- `A`：大小为 $N$ 的整数数组。对于每个 $i$ $(0 \\leq i \\leq N-1)$，$A[i]$ 是从 $i$ 号城市出发的出租车的基本费用。\n- `B`：大小为 $N$ 的整数数组。对于每个 $i$ $(0 \\leq i \\leq N-1)$，$B[i]$ 是从 $i$ 号城市出发的出租车的每公里费用。\n- `U, V, W`：大小为 $N-1$ 的整数数组。对于每个 $i$ $(0 \\leq i \\leq N-2)$，$U[i]$ 号城市和 $V[i]$ 号城市之间有一条长度为 $W[i]$ 公里的道路。\n- 该函数返回一个大小为 $N-1$ 的数组 $C$。对于每个 $i$ $(0 \\leq i \\leq N-2)$，$C[i]$ 是从 $0$ 号城市出发到达 $i+1$ 号城市的最小费用。\n\n注意，提交的代码中不应包含任何输入输出操作。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N$\n- 第 $2$ 行：$A[0]\\,A[1]\\,\\cdots\\,A[N-1]$\n- 第 $3$ 行：$B[0]\\,B[1]\\,\\cdots\\,B[N-1]$\n- 第 $4+i$ $(0 \\leq i \\leq N-2)$ 行：$U[i]\\,V[i]\\,W[i]$", "outputFormat": "示例评测程序按以下格式输出：\n\n- 第 $i$ 行：函数 `travel` 返回的数组的第 $i$ 个元素", "hint": "### 样例解释\n\n考虑 $N=5, A=[10,5,13,4,3], B=[10,7,5,9,1], U=[1,0,3,2], V=[0,2,2,4], W=[1,5,10,3]$ 的情况。\n\n评测程序将调用如下函数：\n\n```cpp\ntravel([10, 5, 13, 4, 3], [10, 7, 5, 9, 1], [1, 0, 3, 2], [0, 2, 2, 4], [1, 5, 10, 3]);\n```\n\n- 从 $0$ 号城市到 $1$ 号城市的最优方案是直接从 $0$ 号城市乘坐出租车，总费用为 $20$ 元。\n- 从 $0$ 号城市到 $2$ 号城市的最优方案是直接从 $0$ 号城市乘坐出租车，总费用为 $60$ 元。\n- 从 $0$ 号城市到 $4$ 号城市的最优方案是先从 $0$ 号城市乘坐出租车到 $1$ 号城市，然后换乘，再经过 $0$ 号和 $2$ 号城市到达 $4$ 号城市，总费用为 $88$ 元。\n- 从 $0$ 号城市到 $3$ 号城市的最优方案是先从 $0$ 号城市乘坐出租车到 $1$ 号城市，然后换乘，再经过 $0$ 号和 $2$ 号城市到达 $4$ 号城市，再换乘，经过 $2$ 号城市到达 $3$ 号城市，总费用为 $104$ 元。\n\n函数应返回 `[20, 60, 104, 88]`。\n\n### 数据范围\n\n对于所有输入数据，满足：\n\n- $2 \\leq N \\leq 10^5$\n- 对于所有 $i$ $(0 \\leq i \\leq N-1)$，$0 \\leq A[i] \\leq 10^{12}$\n- 对于所有 $i$ $(0 \\leq i \\leq N-1)$，$0 \\leq B[i] \\leq 10^6$\n- 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$0 \\leq U[i], V[i] \\leq N-1 ; U[i] \\neq V[i]$\n- 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$1 \\leq W[i] \\leq 10^6$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :-: | :-: | :-: |\n| $1$ | $7$ | $N \\leq 20$ |\n| $2$ | $8$ | 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$U[i]=i ; V[i]=i+1$ |\n| $3$ | $13$ | $N \\leq 2000$ |\n| $4$ | $17$ | 对于所有 $i$ $(0 \\leq i \\leq N-1)$，$B[i] \\leq 30$ |\n| $5$ | $29$ | $B[i] \\neq 0$ $(0 \\leq i \\leq N-1)$ 的 $i$ 不超过 $2000$ 个 |\n| $6$ | $26$ | 无附加限制 |", "locale": "zh-CN"}}}
