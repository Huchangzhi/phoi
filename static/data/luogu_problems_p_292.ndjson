{"pid": "P6910", "type": "P", "difficulty": 7, "samples": [["3\n1000 1 30 1 1\n60 2 10 2 5\n59 2 10 2 5\n", "5\n3\nimpossible\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2015", "ICPC", "WF"], "title": "[ICPC 2015 WF] Pipe Stream", "background": "", "description": " ![](https://vj.z180.cn/ba87a214c6b94e2e93a88f7b226c2064?v=1602042036)  \n\nYour hometown has hired some contractors – including you! – to manage its municipal pipe network. They built the network, at great expense, to supply Flubber to every home in town. Unfortunately, nobody has found a use for Flubber yet, but never mind. It was a Flubber network or a fire department, and honestly, houses burn down so rarely, a fire department hardly seems necessary. \n\nIn the possible event that somebody somewhere decides they want some Flubber, they would like to know how quickly it will flow through the pipes. Measuring its rate of flow is your job.\n\nYou have access to one of the pipes connected to the network. The pipe is $l$ meters long, and you can start the flow of Flubber through this pipe at a time of your choosing. You know that it flows with a constant real-valued speed, which is at least $v_1$ meters/second and at most $v_2$ meters/second. You want to estimate this speed with an absolute error of at most $\\frac{t}{2}$ meters/second.\n\nUnfortunately, the pipe is opaque, so the only thing you can do is to knock on the pipe at any point along its length, that is, in the closed real-valued range $[0,l]$. Listening to the sound of the knock will tell you whether or not the Flubber has reached that point. You are not infinitely fast. Your first knock must be at least $s$ seconds after starting the flow, and there must be at least $s$ seconds between knocks.\n\nDetermine a strategy that will require the fewest knocks, in the worst case, to estimate how fast the Flubber is flowing. Note that in some cases the desired estimation might be impossible (for example, if the Flubber reaches the end of the pipe too quickly).", "inputFormat": "The input consists of multiple test cases. The first line of input contains an integer $c$ ($1 \\leq c \\leq 100$), the number of test cases. Each of the next $c$ lines describes one test case. Each test case contains the five integers $l$, $v_1$, $v_2$, $t$ and $s$ ($1 \\leq l, v_1, v_2, t, s \\leq 10^9$ and $v_1 < v_2$), which are described above.", "outputFormat": "For each test case, display the minimal number of knocks required to estimate the flow speed in the worst case. If it might be impossible to measure the flow speed accurately enough, display impossible instead.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en", "translations": {"en": {"title": "[ICPC 2015 WF] Pipe Stream", "background": "", "description": " ![](https://vj.z180.cn/ba87a214c6b94e2e93a88f7b226c2064?v=1602042036)  \n\nYour hometown has hired some contractors – including you! – to manage its municipal pipe network. They built the network, at great expense, to supply Flubber to every home in town. Unfortunately, nobody has found a use for Flubber yet, but never mind. It was a Flubber network or a fire department, and honestly, houses burn down so rarely, a fire department hardly seems necessary. \n\nIn the possible event that somebody somewhere decides they want some Flubber, they would like to know how quickly it will flow through the pipes. Measuring its rate of flow is your job.\n\nYou have access to one of the pipes connected to the network. The pipe is $l$ meters long, and you can start the flow of Flubber through this pipe at a time of your choosing. You know that it flows with a constant real-valued speed, which is at least $v_1$ meters/second and at most $v_2$ meters/second. You want to estimate this speed with an absolute error of at most $\\frac{t}{2}$ meters/second.\n\nUnfortunately, the pipe is opaque, so the only thing you can do is to knock on the pipe at any point along its length, that is, in the closed real-valued range $[0,l]$. Listening to the sound of the knock will tell you whether or not the Flubber has reached that point. You are not infinitely fast. Your first knock must be at least $s$ seconds after starting the flow, and there must be at least $s$ seconds between knocks.\n\nDetermine a strategy that will require the fewest knocks, in the worst case, to estimate how fast the Flubber is flowing. Note that in some cases the desired estimation might be impossible (for example, if the Flubber reaches the end of the pipe too quickly).", "inputFormat": "The input consists of multiple test cases. The first line of input contains an integer $c$ ($1 \\leq c \\leq 100$), the number of test cases. Each of the next $c$ lines describes one test case. Each test case contains the five integers $l$, $v_1$, $v_2$, $t$ and $s$ ($1 \\leq l, v_1, v_2, t, s \\leq 10^9$ and $v_1 < v_2$), which are described above.", "outputFormat": "For each test case, display the minimal number of knocks required to estimate the flow speed in the worst case. If it might be impossible to measure the flow speed accurately enough, display impossible instead.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en"}, "zh-CN": {"title": "[ICPC 2015 WF] Pipe Stream", "background": "", "description": "你的家乡雇了一些承包商——包括你！—— 来管理市政管道网络。他们花费巨资建设了该网络，以向城镇中的每个家庭供应弹力胶。不幸的是，目前还没有人找到弹力胶的用途，但没关系。这要么是一个弹力胶网络，要么是一个消防部门。但老实说，房屋很少烧毁，似乎并不需要消防部门。\n\n假设某个地方有人决定要制作一些弹力胶，他们希望知道它会在管道中以多快的速度流动。测量它的流动速度就是你的工作。\n\n你可以访问与网络连接的其中一根管道。该管道长度为 $l$ 米，并且你可以在选择的时间开始通过此管道传输弹力胶。你知道它以恒定的实数速度流动，该速度至少为 $v_1$ 米/秒，最多为 $v_2$ 米/秒。你希望以至多 $\\frac{t}{2}$ 米/秒的绝对误差估计此速度(即绝对误差不大于 $\\frac {t}{2}$)。\n\n不幸的是，管道是不透明的，所以你唯一能做的事就是在管道的任意一点敲打，即在闭合的实数范围 $[0,l]$ 内。通过听到敲打声，你可以知道弹力胶是否到达了那个点。你的速度并不是无限快的。你第一次敲打必须在开始流动后至少 $s$ 秒，并且敲打之间必须有至少 $s$ 秒的间隔。\n\n你的任务是确定一种策略，需要在最坏情况下用最少的敲击来估算弹力胶的流速。注意，在某些情况下，所需的估计可能是不可能的（例如，弹力胶可能过快地到达管道的末端）。", "inputFormat": "输入包含多组数据。输入的第一行包含一个整数 $c$ $(1 \\le c \\le 100)$，表示数据组数。接下来的 $c$ 行描述了每组数据。每组数据包含五个整数 $l$，$v_1$，$v_2$ ，$t$ 和 $s$ $（1 \\le l, v_1, v_2, t, s \\le 10^9 \\text{并且}v_1<v_2)$，含义如上所述。", "outputFormat": "对于每组数据，输出在最坏情况下估计流速所需的最小敲击次数。如果无法准确测量流速，则输出 \"$impossible$\"(不含引号)。", "hint": "时间限制：$1000$ ms，空间限制：$1048576$ kB。\n\n### 题目来源\n\n> International Collegiate Programming Contest (ACM-ICPC) World Finals 2015\n\n> [icpc2015.pdf](https://icpc.global/worldfinals/problems/2015-ICPC-World-Finals/icpc2015.pdf)", "locale": "zh-CN"}}}
{"pid": "P6911", "type": "P", "difficulty": 5, "samples": [["8 4 1\n", "31.500000\n3.000000\n"], ["195 65 2\n", "12220.000000\n48.000000\n108.000000\n"], ["10000 1 1000\n", "30141.885677\n9.956721\n19.913443\n29.870164\n39.826887\n49.783610\n59.740334\n69.697060\n79.653786\n89.610515\n99.567245\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2015", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2015 WF] Qanat", "background": "", "description": "A qanat is an irrigation system widely used to deliver water in hot, arid climates. The technology was originally developed by Persians over 2000 years ago. In Morocco, qanats are known as khettara and are still used today in the southern part of the country.\n\nThe basic feature of a qanat is an essentially horizontal channel that brings water from an underground water source to an outlet near a civilization. There is also a shaft known as a mother well that rises vertically from the underground water source to the surface of a mountain or hill. Creating such a system is extremely expensive, and was especially so in ancient times, since all of the materials excavated from the channel and mother well must be carried above ground, either through the channel outlet or the top of the mother well. To aid in the construction, there are often one or more additional vertical shafts placed at strategic locations above the underground channel. Although these shafts must also be excavated, they provide a means for lifting additional dirt from the horizontal channel as illustrated in Figure 1.\n\n  ![](https://vj.z180.cn/4dea3d690f1497e79acad3985c8a9915?v=1603314265) \n\n   Figure 1: An illustration of a qanat. \n\nFor this problem, model the cross-section of a qanat as shown in Figure 2, with the channel outlet at $(0,0)$, the water source at $(w,0)$, and the top of the mother well at $(w,h)$ with $w > h$. The surface of the mountain extends along a straight line from $(w,h)$ to $(0,0)$.\n\n  ![](https://vj.z180.cn/a58cc42544b91877083973369ca77d3c?v=1603314265) \n\n   Figure 2: A simplified model of a qanat cross-section. \n\nEvery qanat must have a vertical mother well from the water source to the mountain surface above, along with $n$ additional vertical shafts. The channel and all shafts are modeled as line segments. Your goal is to determine the placement for those additional shafts so as to minimize the overall excavation cost. This cost is equal to the sum of the distances that each piece of excavated dirt must be transported to reach the surface (using any combination of horizontal and vertical movement). For example, the cost of excavating a continuous section of dirt starting from the surface and going along a path of length $\\ell $ (possibly including turns) is $\\int _0^{\\ell } x \\, dx = \\frac{1}{2} \\ell ^2$.", "inputFormat": "The input consists of a single line containing three integers $w$ ($1 \\le w \\le 10\\, 000$), $h$ ($1 \\le h < w$), and $n$ ($1 \\le n \\le 1\\, 000$). The value $w$ is the horizontal distance from the water source to the qanat outlet. The value $h$ is the vertical distance from the water source to the mountain surface. The value $n$ is the number of vertical shafts that must be used in addition to the mother well.", "outputFormat": "First, display the minimum overall excavation cost. Next, display the $x$-coordinates, in increasing order, for $n$ optimally placed vertical shafts. If $n > 10$, display only the first $10$ $x$-coordinates. Answers within an absolute or relative error of $10^{-4}$ will be accepted. You may assume that there is a unique solution. No test case will result in a shaft within $0.001$ units from the outlet of the qanat channel or from another shaft.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en", "translations": {"en": {"title": "[ICPC 2015 WF] Qanat", "background": "", "description": "A qanat is an irrigation system widely used to deliver water in hot, arid climates. The technology was originally developed by Persians over 2000 years ago. In Morocco, qanats are known as khettara and are still used today in the southern part of the country.\n\nThe basic feature of a qanat is an essentially horizontal channel that brings water from an underground water source to an outlet near a civilization. There is also a shaft known as a mother well that rises vertically from the underground water source to the surface of a mountain or hill. Creating such a system is extremely expensive, and was especially so in ancient times, since all of the materials excavated from the channel and mother well must be carried above ground, either through the channel outlet or the top of the mother well. To aid in the construction, there are often one or more additional vertical shafts placed at strategic locations above the underground channel. Although these shafts must also be excavated, they provide a means for lifting additional dirt from the horizontal channel as illustrated in Figure 1.\n\n  ![](https://vj.z180.cn/4dea3d690f1497e79acad3985c8a9915?v=1603314265) \n\n   Figure 1: An illustration of a qanat. \n\nFor this problem, model the cross-section of a qanat as shown in Figure 2, with the channel outlet at $(0,0)$, the water source at $(w,0)$, and the top of the mother well at $(w,h)$ with $w > h$. The surface of the mountain extends along a straight line from $(w,h)$ to $(0,0)$.\n\n  ![](https://vj.z180.cn/a58cc42544b91877083973369ca77d3c?v=1603314265) \n\n   Figure 2: A simplified model of a qanat cross-section. \n\nEvery qanat must have a vertical mother well from the water source to the mountain surface above, along with $n$ additional vertical shafts. The channel and all shafts are modeled as line segments. Your goal is to determine the placement for those additional shafts so as to minimize the overall excavation cost. This cost is equal to the sum of the distances that each piece of excavated dirt must be transported to reach the surface (using any combination of horizontal and vertical movement). For example, the cost of excavating a continuous section of dirt starting from the surface and going along a path of length $\\ell $ (possibly including turns) is $\\int _0^{\\ell } x \\, dx = \\frac{1}{2} \\ell ^2$.", "inputFormat": "The input consists of a single line containing three integers $w$ ($1 \\le w \\le 10\\, 000$), $h$ ($1 \\le h < w$), and $n$ ($1 \\le n \\le 1\\, 000$). The value $w$ is the horizontal distance from the water source to the qanat outlet. The value $h$ is the vertical distance from the water source to the mountain surface. The value $n$ is the number of vertical shafts that must be used in addition to the mother well.", "outputFormat": "First, display the minimum overall excavation cost. Next, display the $x$-coordinates, in increasing order, for $n$ optimally placed vertical shafts. If $n > 10$, display only the first $10$ $x$-coordinates. Answers within an absolute or relative error of $10^{-4}$ will be accepted. You may assume that there is a unique solution. No test case will result in a shaft within $0.001$ units from the outlet of the qanat channel or from another shaft.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en"}, "zh-CN": {"title": "[ICPC 2015 WF] Qanat", "background": "", "description": "[原题面链接](https://icpc.global/worldfinals/problems/2015-ICPC-World-Finals/icpc2015.pdf)\n\n\nqanat 是一种广泛用在气候炎热、干旱的地区中供水的灌溉系统。这项技术最初由波斯人在 $2000$ 多年前发明。在摩洛哥，qanat 被称为 khettara。至今该系统在该国南部地区仍然被使用。\n\nqanat 的基本特点是用一个基本上是水平的沟渠，把水从地下水源带到靠近城市的出水口。还有一个被称为母井的轴垂直向上延升，从地下水源上升到山脉或山丘的地表。建设这样的系统非常昂贵，在古代更加如此，因为从沟渠和母井中挖出的所有材料都必须在地表运输。这可以通过沟渠出口或母井顶部来进行。为了帮助施工，通常在地下沟渠上方的关键位置还会放置一个或多个额外的垂直井口。尽管这些井口也必须需要被挖掘，但它们提供了一种从水平沟渠中运输额外泥土的手段，如图 $1$ 所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s71tofvr.png)\n\n对于这个问题，模拟一个 qanat 的横截面，如图 $2$ 所示，其中通道出口在 $(0,0)$，水源在 $(w,0)$，母井顶部在 $(w,h)$，其中 $w > h$。山的表面沿着一条直线延伸，从 $(w,h)$ 到 $(0,0)$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4bk00ojs.png)\n\n每个 qanat 必须从水源到山体表面上有一个垂直的母井，还需要 $n$ 个额外的垂直井。水道和所有垂直井都被建模为线段。你的目标是确定这些额外井的位置，以最小化整体的挖掘成本。这个成本等于每块挖掘的土壤必须被运输到表面的距离的总和（任何水平和垂直运动的组合）。例如，从表面开始并沿着长度为 $l$ 的路径挖掘连续的土壤的成本为 $\\int_0^l x \\ \\mathop{}\\!\\mathrm{dx}=\\frac{1}{2}l^2$。", "inputFormat": "输入是一行，包含三个整数 $w$ $(1\\le w\\le 10000)$， $h$ $(1\\le h<w)$，和 $n$ $(1\\le n\\le 1000)$，分别表示水源到 qanat 出口的水平距离，水源到山体表面的垂直距离和除了母井之外必须使用的垂直井口的数量。", "outputFormat": "首先，输出最小开挖成本。接下来，按照递增顺序输出 $n$ 个最优放置的竖井的 $x$ 坐标。如果 $n > 10$，则仅输出前 $10$ 个 $x$ 坐标。相对误差可以在 $10^{-4}$ 之内。你可以假设存在唯一解决方案。没有数据会导致竖井距离 qanat 渠道出口或其他竖井小于0.001单位。\n\n### **说明/提示**\n\n时间限制：$2000$ ms，空间限制：$1048576$ kB。\n\n来源：\n\n> International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6912", "type": "P", "difficulty": 0, "samples": [["3 100 5 10 0 100\nE 2 100 -300 50 -100\nW 3 10 60 50 200 200 400\nE 1 100 -300\n", "6.00000000\n"], ["1 100 5 10 0 200\nW 4 100 100 100 300 100 700 100 900\n", "50.00000000\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2015", "ICPC", "WF"], "title": "[ICPC 2015 WF] Ship Traffic", "background": "", "description": "Ferries crossing the Strait of Gibraltar from Morocco to Spain must carefully navigate to avoid the heavy ship traffic along the strait. Write a program to help ferry captains find the largest gaps in strait traffic for a safe crossing.\n\nYour program will use a simple model as follows. The strait has several parallel shipping lanes in east-west direction. Ships run with the same constant speed either eastbound or westbound. All ships in the same lane run in the same direction. Satellite data provides the positions of the ships in each lane. The ships may have different lengths. Ships do not change lanes and do not change speed for the crossing ferry.\n\nThe ferry waits for an appropriate time when there is an adequate gap in the ship traffic. It then crosses the strait heading northbound along a north-south line at a constant speed. From the moment a ferry enters a lane until the moment it leaves the lane, no ship in that lane may touch the crossing line. Ferries are so small you can neglect their size. Figure 1 illustrates the lanes and ships for Sample Input 1. Your task is to find the largest time interval within which the ferry can safely cross the strait.\n\n![](https://cdn.vjudge.net.cn/35b69cfdbd76aaea80c318132bb285b0)\n\n   Figure 1: Sample Input 1. ", "inputFormat": "The first line of input contains six integers: the number of lanes $n$ ($1 \\leq n \\leq 10^5$), the width $w$ of each lane ($1 \\leq w \\leq 1\\, 000$), the speed $u$ of ships and the speed $v$ of the ferry ($1 \\leq u, v \\leq 100$), the ferry’s earliest start time $t_1$ and the ferry’s latest start time $t_2$ ($0 \\leq t_1 < t_2 \\leq 10^6$). All lengths are given in meters, all speeds are given in meters/second, and all times are given in seconds.\n\nEach of the next $n$ lines contains the data for one lane. Each line starts with either E or W, where E indicates that ships in this lane are eastbound and W indicates that ships in this lane are westbound. Next in the line is an integer $m_ i$, the number of ships in this lane ($0 \\leq m_ i \\leq 10^5$ for each $1 \\leq i \\leq n$). It is followed by $m_ i$ pairs of integers $l_{ij}$ and $p_{ij}$ ($1 \\leq l_{ij} \\leq 1\\, 000$ and $-10^6 \\leq p_{ij} \\leq 10^6$). The length of ship $j$ in lane $i$ is $l_{ij}$, and $p_{ij}$ is the position at time $0$ of its forward end, that is, its front in the direction it moves.\n\nShip positions within each lane are relative to the ferry’s crossing line. Negative positions are west of the crossing line and positive positions are east of it. Ships do not overlap or touch, and are sorted in increasing order of their positions. Lanes are ordered by increasing distance from the ferry’s starting point, which is just south of the first lane. There is no space between lanes. The total number of ships is at least $1$ and at most $10^5$.", "outputFormat": "Display the maximal value $d$ for which there is a time $s$ such that the ferry can start a crossing at any time $t$ with $s \\leq t \\leq s+d$. Additionally the crossing must not start before time $t_1$ and must start no later than time $t_2$. The output must have an absolute or relative error of at most $10^{-3}$. You may assume that there is a time interval with $d > 0.1$ seconds for the ferry to cross.", "hint": "Time limit: 3000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en", "translations": {"en": {"title": "[ICPC 2015 WF] Ship Traffic", "background": "", "description": "Ferries crossing the Strait of Gibraltar from Morocco to Spain must carefully navigate to avoid the heavy ship traffic along the strait. Write a program to help ferry captains find the largest gaps in strait traffic for a safe crossing.\n\nYour program will use a simple model as follows. The strait has several parallel shipping lanes in east-west direction. Ships run with the same constant speed either eastbound or westbound. All ships in the same lane run in the same direction. Satellite data provides the positions of the ships in each lane. The ships may have different lengths. Ships do not change lanes and do not change speed for the crossing ferry.\n\nThe ferry waits for an appropriate time when there is an adequate gap in the ship traffic. It then crosses the strait heading northbound along a north-south line at a constant speed. From the moment a ferry enters a lane until the moment it leaves the lane, no ship in that lane may touch the crossing line. Ferries are so small you can neglect their size. Figure 1 illustrates the lanes and ships for Sample Input 1. Your task is to find the largest time interval within which the ferry can safely cross the strait.\n\n![](https://cdn.vjudge.net.cn/35b69cfdbd76aaea80c318132bb285b0)\n\n   Figure 1: Sample Input 1. ", "inputFormat": "The first line of input contains six integers: the number of lanes $n$ ($1 \\leq n \\leq 10^5$), the width $w$ of each lane ($1 \\leq w \\leq 1\\, 000$), the speed $u$ of ships and the speed $v$ of the ferry ($1 \\leq u, v \\leq 100$), the ferry’s earliest start time $t_1$ and the ferry’s latest start time $t_2$ ($0 \\leq t_1 < t_2 \\leq 10^6$). All lengths are given in meters, all speeds are given in meters/second, and all times are given in seconds.\n\nEach of the next $n$ lines contains the data for one lane. Each line starts with either E or W, where E indicates that ships in this lane are eastbound and W indicates that ships in this lane are westbound. Next in the line is an integer $m_ i$, the number of ships in this lane ($0 \\leq m_ i \\leq 10^5$ for each $1 \\leq i \\leq n$). It is followed by $m_ i$ pairs of integers $l_{ij}$ and $p_{ij}$ ($1 \\leq l_{ij} \\leq 1\\, 000$ and $-10^6 \\leq p_{ij} \\leq 10^6$). The length of ship $j$ in lane $i$ is $l_{ij}$, and $p_{ij}$ is the position at time $0$ of its forward end, that is, its front in the direction it moves.\n\nShip positions within each lane are relative to the ferry’s crossing line. Negative positions are west of the crossing line and positive positions are east of it. Ships do not overlap or touch, and are sorted in increasing order of their positions. Lanes are ordered by increasing distance from the ferry’s starting point, which is just south of the first lane. There is no space between lanes. The total number of ships is at least $1$ and at most $10^5$.", "outputFormat": "Display the maximal value $d$ for which there is a time $s$ such that the ferry can start a crossing at any time $t$ with $s \\leq t \\leq s+d$. Additionally the crossing must not start before time $t_1$ and must start no later than time $t_2$. The output must have an absolute or relative error of at most $10^{-3}$. You may assume that there is a time interval with $d > 0.1$ seconds for the ferry to cross.", "hint": "Time limit: 3000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en"}, "zh-CN": {"title": "[ICPC 2015 WF] Ship Traffic", "background": "", "description": "从摩洛哥到西班牙穿越直布罗陀海峡的渡轮必须小心导航，以避免海峡内繁忙的船只交通。编写一个程序帮助渡轮船长找到海峡交通中最大的空隙，以便安全穿越。\n\n你的程序将使用如下简单模型。海峡有几条东西方向的平行航道。船只以相同的恒定速度向东或向西航行。同一航道上的所有船只都朝同一方向航行。卫星数据提供了每条航道上船只的位置。船只可能有不同的长度。船只在渡轮穿越时不会改变航道，也不会改变速度。\n\n渡轮等待适当的时间，当船只交通中有足够的空隙时，它就穿越海峡，沿南北方向以恒定速度航行。从渡轮进入航道的那一刻起，直到它离开航道的那一刻，该航道中的任何船只都不得碰触渡轮的穿越线。渡轮非常小，你可以忽略它的大小。下图展示了样例输入 1 的航道和船只。你的任务是找到渡轮可以安全穿越海峡的最大时间间隔。\n\n![](https://cdn.vjudge.net.cn/35b69cfdbd76aaea80c318132bb285b0)", "inputFormat": "输入的第一行包含六个整数：航道数量 $n$ ($1 \\leq n \\leq 10^5$)，每条航道的宽度 $w$ ($1 \\leq w \\leq 1,000$)，船只的速度 $u$ 和渡轮的速度 $v$ ($1 \\leq u, v \\leq 100$)，渡轮最早的出发时间 $t_1$ 和最晚的出发时间 $t_2$ ($0 \\leq t_1 < t_2 \\leq 10^6$)。所有长度以米为单位，所有速度以米/秒为单位，所有时间以秒为单位。\n\n接下来的 $n$ 行中，每行包含一个航道的数据。每行以 E 或 W 开头，其中 E 表示该航道上的船只向东航行，W 表示向西航行。接下来是一个整数 $m_i$，表示该航道上的船只数量 ($0 \\leq m_i \\leq 10^5$，对于每个 $1 \\leq i \\leq n$)。接下来是 $m_i$ 对整数 $l_{ij}$ 和 $p_{ij}$ ($1 \\leq l_{ij} \\leq 1,000$ 和 $-10^6 \\leq p_{ij} \\leq 10^6$)。航道 $i$ 上船只 $j$ 的长度为 $l_{ij}$，$p_{ij}$ 是其前端在时间 $0$ 的位置，即其移动方向上的前端。\n\n每条航道内的船只位置相对于渡轮的穿越线。负位置在穿越线的西侧，正位置在东侧。船只不重叠或接触，并按位置递增排序。航道按距离渡轮起点的距离递增排序，渡轮起点在第一条航道的正南方。航道之间没有空隙。船只总数至少为 $1$ 且最多为 $10^5$。", "outputFormat": "显示最大值 $d$，对于某个时间 $s$，渡轮可以在任何时间 $t$ 开始穿越，满足 $s \\leq t \\leq s+d$。此外，穿越不得早于时间 $t_1$ 开始，且不得晚于时间 $t_2$ 开始。输出的绝对或相对误差必须不超过 $10^{-3}$。你可以假设有一个时间间隔满足 $d > 0.1$ 秒，渡轮可以穿越。", "hint": "时间限制：3000 毫秒，内存限制：1048576 KB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2015\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6913", "type": "P", "difficulty": 6, "samples": [["2\n4 4\n2 6\n", "4 8\n6 20\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2015", "线段树", "ST 表", "快速傅里叶变换 FFT", "ICPC", "WF"], "title": "[ICPC 2015 WF] Tile Cutting", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/f8fpcjx7.png) \n\nYoussef is a Moroccan tile installer who specializes in mosaics like the one shown on the right. He has rectangular tiles of many dimensions at his disposal, and the dimensions of all his tiles are integer numbers of centimeters. When Youssef needs parallelogram-shaped tiles, he cuts them from his supply on hand. To make this work easier, he invented a tile cutting machine that superimposes a centimeter grid on the cutting surface to guide the cuts on the tiles. Due to machine limitations, aesthetic sensibilities, and Youssef’s dislike of wasted tiles, the following rules determine the possible cuts. \n\nThe rectangular tile to be cut must be positioned in the bottom left corner of the cutting surface and the edges must be aligned with the grid lines.\n\nThe cutting blade can cut along any line connecting two different grid points on the tile boundary as long as the points are on adjacent boundary edges.\n\nThe four corners of the resulting parallelogram tile must lie on the four sides of the original rectangular tile.\n\nNo edge of the parallelogram tile can lie along an edge of the rectangular tile.\n\nFigure 1 shows the eight different ways in which a parallelogram tile of area $4$ square centimeters can be cut out of a rectangular tile, subject to these restrictions.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/figekxdx.png)\n\n   Figure 1: The eight different ways for cutting a parallelogram of area 4. \n\nYoussef needs to cut tiles of every area between $a_{\\text {lo}}$ and $a_{\\text {hi}}$. Now he wonders, for which area $a$ in this range can he cut the maximum number of different tiles?", "inputFormat": "The input consists of multiple test cases. The first line of input contains an integer $n$ ($1 \\le n \\le 500$), the number of test cases. The next $n$ lines each contain two integers $a_{\\text {lo}}, a_{\\text {hi}}$ ($1 \\le a_{\\text {lo}} \\le a_{\\text {hi}} \\le 500\\, 000$), the range of areas of the tiles.", "outputFormat": "For each test case $a_{\\text {lo}}$, $a_{\\text {hi}}$, display the value $a$ between $a_{\\text {lo}}$ and $a_{\\text {hi}}$ such that the number of possible ways to cut a parallelogram of area $a$ is maximized as well as the number of different ways $w$ in which such a parallelogram can be cut. If there are multiple possible values of $a$ display the smallest one.", "hint": "Time limit: 11000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en", "translations": {"en": {"title": "[ICPC 2015 WF] Tile Cutting", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/f8fpcjx7.png) \n\nYoussef is a Moroccan tile installer who specializes in mosaics like the one shown on the right. He has rectangular tiles of many dimensions at his disposal, and the dimensions of all his tiles are integer numbers of centimeters. When Youssef needs parallelogram-shaped tiles, he cuts them from his supply on hand. To make this work easier, he invented a tile cutting machine that superimposes a centimeter grid on the cutting surface to guide the cuts on the tiles. Due to machine limitations, aesthetic sensibilities, and Youssef’s dislike of wasted tiles, the following rules determine the possible cuts. \n\nThe rectangular tile to be cut must be positioned in the bottom left corner of the cutting surface and the edges must be aligned with the grid lines.\n\nThe cutting blade can cut along any line connecting two different grid points on the tile boundary as long as the points are on adjacent boundary edges.\n\nThe four corners of the resulting parallelogram tile must lie on the four sides of the original rectangular tile.\n\nNo edge of the parallelogram tile can lie along an edge of the rectangular tile.\n\nFigure 1 shows the eight different ways in which a parallelogram tile of area $4$ square centimeters can be cut out of a rectangular tile, subject to these restrictions.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/figekxdx.png)\n\n   Figure 1: The eight different ways for cutting a parallelogram of area 4. \n\nYoussef needs to cut tiles of every area between $a_{\\text {lo}}$ and $a_{\\text {hi}}$. Now he wonders, for which area $a$ in this range can he cut the maximum number of different tiles?", "inputFormat": "The input consists of multiple test cases. The first line of input contains an integer $n$ ($1 \\le n \\le 500$), the number of test cases. The next $n$ lines each contain two integers $a_{\\text {lo}}, a_{\\text {hi}}$ ($1 \\le a_{\\text {lo}} \\le a_{\\text {hi}} \\le 500\\, 000$), the range of areas of the tiles.", "outputFormat": "For each test case $a_{\\text {lo}}$, $a_{\\text {hi}}$, display the value $a$ between $a_{\\text {lo}}$ and $a_{\\text {hi}}$ such that the number of possible ways to cut a parallelogram of area $a$ is maximized as well as the number of different ways $w$ in which such a parallelogram can be cut. If there are multiple possible values of $a$ display the smallest one.", "hint": "Time limit: 11000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en"}, "zh-CN": {"title": "[ICPC 2015 WF] Tile Cutting", "background": "", "description": "Youssef 是一名专业贴瓷砖的修墙工，并且擅长用瓷砖贴出马赛克图案（如上图所示）。所有的瓷砖的尺寸长度均为整数，单位为 $cm$。在马赛克图案中，平行四边形是不可或缺的。因此，Youssef 会使用切割机，将矩形的瓷砖进行切割。在切割过程中，Youssef 选择使用网格辅助切割机进行切割（在瓷砖上布上 $cm$ 的网格方便切割）。\n\n切割过程有以下要求：\n\n1.\t可以从两个不同端点的连线切割（可以斜着切割）\n2.\t新平行四边形的四个角必须在矩形瓷砖的最外侧边上\n3.\t平行四边形的边不能与矩形的任意一条边边重叠\n\n现在给出切割的面积的两个边界值 $a_{lo}$ 和 $a_{hi}$，求出 Youssef 能够最多切割掉的小矩形瓷砖数量。", "inputFormat": "给出测试样例数量$n$($1≤n≤500$)。下面$n$行给出切割面积的两个边界值$a_{lo}$和$a_{hi}$（$1≤a_{lo}≤a_{hi}≤500 000$）", "outputFormat": "每行先输出平行四边形面积$a$，再输出小矩形最多切割数量$w$。如果$a$有不同值的时候，输出最小的即可。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6914", "type": "P", "difficulty": 7, "samples": [["4 5\n1 2\n2 3\n3 4\n1 4\n1 3\n", "1\n"], ["6 6\n1 2\n2 3\n1 3\n1 4\n2 5\n3 6\n", "1 3\n"]], "limits": {"time": [1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2015", "ICPC", "WF"], "title": "[ICPC 2015 WF] Tours", "background": "", "description": "The Arca Carania Mountain national park is opening up for tourist traffic. The national park has a number of sites worth seeing and roads that connect pairs of sites. The park commissioners have put together a set of round tours in the park in which visitors can ride buses to view various sites. Each round tour starts at some site (potentially different sites for different tours), visits a number of other sites without repeating any, and then returns to where it started. At least 3 different sites are visited in each round tour. At least one round tour is possible in the national park.\n\nThe park commissioners have decided that, for any given road, all buses will be operated by a single company. The commissioners do not want to be accused of favoritism, so they want to be sure that each possible round tour in the park has exactly the same number of roads assigned to each bus company. They realize this may be difficult to achieve. Thus, they want to learn what numbers of bus companies allow for a valid assignment of companies to roads.\n\nConsider Sample Input 1, which is illustrated in Figure 1. There are a total of three round tours for these sites. Some company is assigned road 1-3. It must also be assigned some road on the round tour 1-2-3-4-1, say 2-3. But then it is assigned to two of the three roads on the round tour 1-2-3-1, and no other company can match this – so there can be no other companies. In Sample Input 2 there is only one round tour, so it is enough to assign the roads of this tour equally between companies.\n\n  ![](https://vj.z180.cn/17b3ab5defe058e1bc8649098ddaa63e?v=1603764959) \n\n   Figure 1: Sample Input 1. ", "inputFormat": "The first line of input contains two integers $n$ ($1 \\le n \\le 2\\, 000$), which is the number of sites in the park, and $m$ ($1 \\le m \\le 2\\, 000$), which is the number of roads between the sites. Following that are $m$ lines, each containing two integers $a_ i$ and $b_ i$ ($1 \\leq a_ i < b_ i \\leq n$), meaning the sites $a_ i$ and $b_ i$ are connected by a bidirectional road. No pair of sites is listed twice.", "outputFormat": "Display all integers $k$ such that it is possible to assign the roads to $k$ companies in the desired way. These integers should be in ascending order.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en", "translations": {"en": {"title": "[ICPC 2015 WF] Tours", "background": "", "description": "The Arca Carania Mountain national park is opening up for tourist traffic. The national park has a number of sites worth seeing and roads that connect pairs of sites. The park commissioners have put together a set of round tours in the park in which visitors can ride buses to view various sites. Each round tour starts at some site (potentially different sites for different tours), visits a number of other sites without repeating any, and then returns to where it started. At least 3 different sites are visited in each round tour. At least one round tour is possible in the national park.\n\nThe park commissioners have decided that, for any given road, all buses will be operated by a single company. The commissioners do not want to be accused of favoritism, so they want to be sure that each possible round tour in the park has exactly the same number of roads assigned to each bus company. They realize this may be difficult to achieve. Thus, they want to learn what numbers of bus companies allow for a valid assignment of companies to roads.\n\nConsider Sample Input 1, which is illustrated in Figure 1. There are a total of three round tours for these sites. Some company is assigned road 1-3. It must also be assigned some road on the round tour 1-2-3-4-1, say 2-3. But then it is assigned to two of the three roads on the round tour 1-2-3-1, and no other company can match this – so there can be no other companies. In Sample Input 2 there is only one round tour, so it is enough to assign the roads of this tour equally between companies.\n\n  ![](https://vj.z180.cn/17b3ab5defe058e1bc8649098ddaa63e?v=1603764959) \n\n   Figure 1: Sample Input 1. ", "inputFormat": "The first line of input contains two integers $n$ ($1 \\le n \\le 2\\, 000$), which is the number of sites in the park, and $m$ ($1 \\le m \\le 2\\, 000$), which is the number of roads between the sites. Following that are $m$ lines, each containing two integers $a_ i$ and $b_ i$ ($1 \\leq a_ i < b_ i \\leq n$), meaning the sites $a_ i$ and $b_ i$ are connected by a bidirectional road. No pair of sites is listed twice.", "outputFormat": "Display all integers $k$ such that it is possible to assign the roads to $k$ companies in the desired way. These integers should be in ascending order.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en"}, "zh-CN": {"title": "[ICPC 2015 WF] Tours", "background": "", "description": "给定一张 $n$ 个点 $m$ 条边的无向图，你需要选择一个颜色种类数 $k$，然后用这 $k$ 种颜色给每条边染色，要求对于图中任意一个简单环，每种颜色的边的数量都相同。求所有可行的 $k$。\n\n保证图无重边，无自环。", "inputFormat": "第一行两个正整数 $n, m$（$1\\leq n, m\\leq 2\\times 10 ^ 3$）。\n\n接下来 $m$ 行，每行两个正整数 $x, y$（$1\\leq x < y \\leq n$），表示一条无向边。", "outputFormat": "一行按递增顺序输出所有可行的 $k$，用空格隔开。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6915", "type": "P", "difficulty": 6, "samples": [["2\n0.9 0.049999 0.05 0.000001\n", "1.457510\n"], ["20\n0.25 0.25 0.25 0.25\n", "40.000000\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2015", "Special Judge", "霍夫曼树", "ICPC", "WF"], "title": "[ICPC 2015 WF] Weather Report", "background": "", "description": " ![](https://cdn.luogu.com.cn/upload/image_hosting/xqo70y6n.png)\n\nYou have been hired by the Association for Climatological Measurement, a scientific organization interested in tracking global weather trends over a long period of time. Of course, this is no easy task. They have deployed many small devices around the world, designed to take periodic measurements of the local weather conditions. These are cheap devices with somewhat restricted capabilities. Every day they observe which of the four standard kinds of weather occurred: Sunny, Cloudy, Rainy, or Frogs. After every $n$ of these observations have been made, the results are reported to the main server for analysis. However, the massive number of devices has caused the available communication bandwidth to be overloaded. The Association needs your help to come up with a method of compressing these reports into fewer bits. \n\nFor a particular device’s location, you may assume that the weather each day is an independent random event, and you are given the predicted probabilities of the four possible weather types. Each of the $4^ n$ possible weather reports for a device must be encoded as a unique sequence of bits, such that no sequence is a prefix of any other sequence (an important property, or else the server would not know when each sequence ends). The goal is to use an encoding that minimizes the expected number of transmitted bits.", "inputFormat": "The first line of input contains an integer $1 \\le n \\le 20$, the number of observations that go into each report. The second line contains four positive floating-point numbers, $p_{\\text {sunny}}$, $p_{\\text {cloudy}}$, $p_{\\text {rainy}}$, and $p_{\\text {frogs}}$, representing the respective weather probabilities. These probabilities have at most 6 digits after the decimal point and sum to 1.", "outputFormat": "Display the minimum expected number of bits in the encoding of a report, with an absolute or relative error of at most $10^{-4}$.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en", "translations": {"en": {"title": "[ICPC 2015 WF] Weather Report", "background": "", "description": " ![](https://cdn.luogu.com.cn/upload/image_hosting/xqo70y6n.png)\n\nYou have been hired by the Association for Climatological Measurement, a scientific organization interested in tracking global weather trends over a long period of time. Of course, this is no easy task. They have deployed many small devices around the world, designed to take periodic measurements of the local weather conditions. These are cheap devices with somewhat restricted capabilities. Every day they observe which of the four standard kinds of weather occurred: Sunny, Cloudy, Rainy, or Frogs. After every $n$ of these observations have been made, the results are reported to the main server for analysis. However, the massive number of devices has caused the available communication bandwidth to be overloaded. The Association needs your help to come up with a method of compressing these reports into fewer bits. \n\nFor a particular device’s location, you may assume that the weather each day is an independent random event, and you are given the predicted probabilities of the four possible weather types. Each of the $4^ n$ possible weather reports for a device must be encoded as a unique sequence of bits, such that no sequence is a prefix of any other sequence (an important property, or else the server would not know when each sequence ends). The goal is to use an encoding that minimizes the expected number of transmitted bits.", "inputFormat": "The first line of input contains an integer $1 \\le n \\le 20$, the number of observations that go into each report. The second line contains four positive floating-point numbers, $p_{\\text {sunny}}$, $p_{\\text {cloudy}}$, $p_{\\text {rainy}}$, and $p_{\\text {frogs}}$, representing the respective weather probabilities. These probabilities have at most 6 digits after the decimal point and sum to 1.", "outputFormat": "Display the minimum expected number of bits in the encoding of a report, with an absolute or relative error of at most $10^{-4}$.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en"}, "zh-CN": {"title": "[ICPC 2015 WF] Weather Report", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/xqo70y6n.png)\n\n你被气候测量协会雇佣，这是一家对长期跟踪全球天气趋势感兴趣的科学组织。当然，这不是一项简单的任务。他们在世界各地部署了许多小型设备，旨在定期测量当地的天气状况。这些设备价格低廉，功能有所限制。每天它们会观察四种标准天气中的哪一种发生：晴天、多云、雨天或青蛙雨。在每进行 $n$ 次这样的观察后，结果会被报告给主服务器进行分析。然而，设备数量庞大导致可用通信带宽超载。协会需要你的帮助来想出一种方法，将这些报告压缩成更少的比特。\n\n对于某个设备的位置，你可以假设每天的天气是一个独立的随机事件，并且你会得到四种可能天气类型的预测概率。设备的每一个 $4^n$ 种可能的天气报告必须被编码为一个唯一的比特序列，且没有序列是其他序列的前缀（这是一个重要的属性，否则服务器将不知道每个序列何时结束）。目标是使用一种编码，最小化传输比特的期望数量。", "inputFormat": "输入的第一行包含一个整数 $1 \\le n \\le 20$，表示每个报告中的观察次数。第二行包含四个正浮点数，$p_{\\text {sunny}}$，$p_{\\text {cloudy}}$，$p_{\\text {rainy}}$ 和 $p_{\\text {frogs}}$，表示各自的天气概率。这些概率小数点后最多有 6 位数字，并且总和为 1。", "outputFormat": "显示报告编码中比特的最小期望数量，绝对误差或相对误差最多为 $10^{-4}$。", "hint": "时间限制：1000 毫秒，内存限制：1048576 KB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2015。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6916", "type": "P", "difficulty": 6, "samples": [["320 200\nOPEN 50 50 10 10\nOPEN 70 55 10 10\nOPEN 90 50 10 10\nRESIZE 55 55 40 40\nRESIZE 55 55 15 15\nMOVE 55 55 40 0\nCLOSE 55 55\nCLOSE 110 60\nMOVE 95 55 0 -100\n", "Command 4: RESIZE - window does not fit\nCommand 7: CLOSE - no window at given position\nCommand 9: MOVE - moved 50 instead of 100\n2 window(s):\n90 0 15 15\n115 50 10 10\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2015", "ICPC", "WF"], "title": "[ICPC 2015 WF] Window Manager", "background": "", "description": "The past few years have seen a revolution in user interface technology. For many years, keyboards and mice were the tools used to interact with computers. But with the introduction of smart phones and tablets, people are increasingly using their computers by tapping and moving their fingers on the screen. Naturally this has led to new paradigms in user interface design. One important principle is that objects on the display obey “physical” laws. In this problem, you will see an example of this.\n\nYou have been hired to build a simulator for the window manager to be used in the next generation of smart phones from Advanced Cellular Manufacturers (ACM). Each phone they produce will have a rectangular screen that fully displays zero or more rectangular windows. That is, no window exceeds the boundaries of the screen or overlaps any other window. The simulator must support the following commands.\n\nOPEN $x$ $y$ $w$ $h$ — open a new window with top-left corner coordinates $(x,y)$, width $w$ pixels and height $h$ pixels.\n\nCLOSE $x$ $y$ — close an open window that includes the pixel at $(x,y)$. This allows a user to tap anywhere on a window to close it.\n\nRESIZE $x$ $y$ $w$ $h$ — set the dimensions of the window that includes the pixel at $(x,y)$ to width $w$ and height $h$. The top-left corner of the window does not move.\n\nMOVE $x$ $y$ $d_ x$ $d_ y$ — move the window that includes the pixel at $(x,y)$. The movement is either $d_ x$ pixels in the horizontal direction or $d_ y$ pixels in the vertical direction. At most one of $d_ x$ and $d_ y$ will be non-zero.\n\nThe OPEN and RESIZE commands succeed only if the resulting window does not overlap any other windows and does not extend beyond the screen boundaries. The MOVE command will move the window by as many of the requested pixels as possible. For example, if $d_ x$ is 30 but the window can move only 15 pixels to the right, then it will move 15 pixels.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3zw4uj2x.png)\n\n   Figure 1: MOVE example \n\nACM is particularly proud of the MOVE command. A window being moved might “bump into” another window. In this case, the first window will push the second window in the same direction as far as appropriate, exactly as if the windows were physical objects. This behavior can cascade – a moving window might encounter additional windows which are also pushed along as necessary. Figure 1 shows an example with three windows, where window A is moved to the right, pushing the other two along.", "inputFormat": "The first line of input contains two positive integers $x_{\\max }$ and $y_{\\max }$, the horizontal and vertical dimensions of the screen, measured in pixels. Each is at most $10^9$ (ACM is planning on building displays with very high resolution). The top-left pixel of the screen has coordinates $(0,0)$. Each of the following lines contains a command as described above. One or more spaces separate the command name and the parameters from each other. The command parameters are integers that satisfy these conditions: $0 \\leq x < x_{\\max }$, $0 \\leq y < y_{\\max }$, $1 \\leq w,h \\leq 10^9$, and $|d_ x|,|d_ y| \\leq 10^9$. There will be at most 256 commands.", "outputFormat": "The output must follow the format illustrated in the sample output below.\n\nSimulate the commands in the order they appear in the input. If any errors are detected during a command’s simulation, display the command number, command name, and the first appropriate message from the following list, and ignore the results of simulating that command (except as noted).\n\nno window at given position — for the CLOSE, RESIZE, and MOVE commands — if there is no window that includes the pixel at the specified position.\n\nwindow does not fit — for the OPEN and RESIZE commands — if the resulting window would overlap another window or extend beyond the screen boundaries.\n\nmoved $d’$ instead of $d$ — for the MOVE command — if the command asked to move a window $d$ pixels, but it could only move $d’$ pixels before requiring a window to move beyond the screen boundaries. The values $d$ and $d’$ are the absolute number of pixels requested and moved, respectively. The window is still moved in this case, but only for the smaller distance.\n\nAfter all commands have been simulated and any error messages have been displayed, indicate the number of windows that are still open. Then for each open window, in the same order that they were opened, display the coordinates of the top-left corner $(x,y)$, the width, and the height.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en", "translations": {"en": {"title": "[ICPC 2015 WF] Window Manager", "background": "", "description": "The past few years have seen a revolution in user interface technology. For many years, keyboards and mice were the tools used to interact with computers. But with the introduction of smart phones and tablets, people are increasingly using their computers by tapping and moving their fingers on the screen. Naturally this has led to new paradigms in user interface design. One important principle is that objects on the display obey “physical” laws. In this problem, you will see an example of this.\n\nYou have been hired to build a simulator for the window manager to be used in the next generation of smart phones from Advanced Cellular Manufacturers (ACM). Each phone they produce will have a rectangular screen that fully displays zero or more rectangular windows. That is, no window exceeds the boundaries of the screen or overlaps any other window. The simulator must support the following commands.\n\nOPEN $x$ $y$ $w$ $h$ — open a new window with top-left corner coordinates $(x,y)$, width $w$ pixels and height $h$ pixels.\n\nCLOSE $x$ $y$ — close an open window that includes the pixel at $(x,y)$. This allows a user to tap anywhere on a window to close it.\n\nRESIZE $x$ $y$ $w$ $h$ — set the dimensions of the window that includes the pixel at $(x,y)$ to width $w$ and height $h$. The top-left corner of the window does not move.\n\nMOVE $x$ $y$ $d_ x$ $d_ y$ — move the window that includes the pixel at $(x,y)$. The movement is either $d_ x$ pixels in the horizontal direction or $d_ y$ pixels in the vertical direction. At most one of $d_ x$ and $d_ y$ will be non-zero.\n\nThe OPEN and RESIZE commands succeed only if the resulting window does not overlap any other windows and does not extend beyond the screen boundaries. The MOVE command will move the window by as many of the requested pixels as possible. For example, if $d_ x$ is 30 but the window can move only 15 pixels to the right, then it will move 15 pixels.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3zw4uj2x.png)\n\n   Figure 1: MOVE example \n\nACM is particularly proud of the MOVE command. A window being moved might “bump into” another window. In this case, the first window will push the second window in the same direction as far as appropriate, exactly as if the windows were physical objects. This behavior can cascade – a moving window might encounter additional windows which are also pushed along as necessary. Figure 1 shows an example with three windows, where window A is moved to the right, pushing the other two along.", "inputFormat": "The first line of input contains two positive integers $x_{\\max }$ and $y_{\\max }$, the horizontal and vertical dimensions of the screen, measured in pixels. Each is at most $10^9$ (ACM is planning on building displays with very high resolution). The top-left pixel of the screen has coordinates $(0,0)$. Each of the following lines contains a command as described above. One or more spaces separate the command name and the parameters from each other. The command parameters are integers that satisfy these conditions: $0 \\leq x < x_{\\max }$, $0 \\leq y < y_{\\max }$, $1 \\leq w,h \\leq 10^9$, and $|d_ x|,|d_ y| \\leq 10^9$. There will be at most 256 commands.", "outputFormat": "The output must follow the format illustrated in the sample output below.\n\nSimulate the commands in the order they appear in the input. If any errors are detected during a command’s simulation, display the command number, command name, and the first appropriate message from the following list, and ignore the results of simulating that command (except as noted).\n\nno window at given position — for the CLOSE, RESIZE, and MOVE commands — if there is no window that includes the pixel at the specified position.\n\nwindow does not fit — for the OPEN and RESIZE commands — if the resulting window would overlap another window or extend beyond the screen boundaries.\n\nmoved $d’$ instead of $d$ — for the MOVE command — if the command asked to move a window $d$ pixels, but it could only move $d’$ pixels before requiring a window to move beyond the screen boundaries. The values $d$ and $d’$ are the absolute number of pixels requested and moved, respectively. The window is still moved in this case, but only for the smaller distance.\n\nAfter all commands have been simulated and any error messages have been displayed, indicate the number of windows that are still open. Then for each open window, in the same order that they were opened, display the coordinates of the top-left corner $(x,y)$, the width, and the height.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en"}, "zh-CN": {"title": "[ICPC 2015 WF] Window Manager", "background": null, "description": "过去几年，用户界面技术发生了一场革命。多年来，键盘和鼠标一直是与计算机交互的工具。但随着智能手机和平板电脑的推出，人们越来越多地通过在屏幕上敲击和移动手指来使用电脑。这自然导致了用户界面设计的新范式。一个重要的原则是显示器上的对象遵守“物理”定律。在这个问题中，您将看到一个例子。\n\n您已被聘请为 window manager 构建一个模拟器，用于高级手机制造商（Advanced Cellular Manufacturers，ACM）的下一代智能手机。他们生产的每款手机都有一个矩形屏幕，可以完全显示零个或多个矩形窗口。也就是说，没有窗口超出屏幕边界或与任何其他窗口重叠。模拟器必须支持以下命令。\n\n`OPEN x y w h` —— 打开一个具有左上角坐标 $(x,y)$、宽度 $w$ 像素和高度 $h$ 像素的新窗口。\n\n`CLOSE x y` —— 关闭一个打开的窗口，其中包括 $(x,y)$ 处的像素。这允许用户点击窗口上的任意位置以关闭窗口。\n\n`RESIZE x y w h` —— 将包含 $(x,y)$ 处像素的窗口尺寸设置为宽度 $w$  像素和高度 $h$  像素。窗口的左上角不移动。\n\n`MOVE x y dx dy` —— 移动包含 $(x,y)$ 处像素的窗口。移动是水平方向上的 $dx$ 像素或垂直方向上的 $dy$ 像素。$dx$ 和 $dy$ 中最多有一个为非零。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3zw4uj2x.png)\n\n _（图 1：移动示例）_ \n\nACM 对 `MOVE` 命令特别自豪。正在移动的窗口可能会“撞上”另一个窗口。在这种情况下，第一个窗口将以相同的方向尽可能远地推动第二个窗口，就像这些窗口是物理对象一样。此行为可能会层叠 —— 移动的窗口可能会遇到其他窗口，这些窗口也会根据需要被推送。图 $1$ 显示了一个有三个窗口的示例，其中窗口 A 向右移动，推动其他两个窗口。", "inputFormat": "第一行输入包含两个正整数 $x_{\\max}$ 和 $y_{\\max}$，即屏幕的水平和垂直尺寸，以像素为单位。\n\n每个显示器的最大分辨率为 $10^9$（ACM 正计划建造具有极高分辨率的显示器）。\n\n屏幕左上角的像素具有坐标 $(0,0)$。\n\n下面的每一行都包含一个如上所述的命令。\n\n命令名和参数之间用一个或多个空格分隔。\n\n命令参数是满足这些条件的整数：\n\n- $0 \\le x < x_{\\max}$；\n- $0 \\le y < y_{\\max}$；\n- $1 \\le w,h \\le 10^9$；\n- $-10^9 \\le dx,dy \\le 10^9$；\n- $dx \\cdot dy = 0$。\n\n最多有 $256$ 条命令。", "outputFormat": "输出必须遵循以下示例输出中所示的格式。\n\n按照命令在输入中出现的顺序模拟命令。如果在命令模拟过程中检测到任何错误，请显示命令编号、命令名称和下表中的第一条适当消息，并忽略模拟该命令的结果（除非另有说明）。\n\n如果在指定位置没有包含像素的窗口，则在给定位置没有窗口（用于关闭、调整大小和移动命令）。\n\n如果生成的窗口与另一个窗口重叠或超出屏幕边界，则窗口不适用于“打开”和“调整大小”命令。\n\n如果命令要求移动窗口 $d$ 个像素，则移动 $d'$ 而不是 $d$ —— 对于 `MOVE` 命令，但在要求窗口移动到屏幕边界之外之前，它只能移动 $d'$ 个像素。值 $d$ 和 $d'$ 分别是请求和移动的像素的绝对数量。在这种情况下，窗口仍会移动，但仅移动较小的距离。\n\n模拟所有命令并显示任何错误消息后，指示仍打开的窗口数。然后，对于每个打开的窗口，按照打开的顺序显示左上角 $(x,y)$ 的坐标、宽度和高度。", "hint": "时间限制：1000 毫秒，内存限制：1048576 kB。\n\n该题出自：2015 年国际大学生编程大赛（ACM-ICPC）世界总决赛。", "locale": "zh-CN"}}}
{"pid": "P6917", "type": "P", "difficulty": 5, "samples": [["6 5\n2 1 6 3 5 3\n1 2 5 3 5\n", "1\n\n"], ["6 4\n2 1 6 3 5 3\n1 2 5 3\n", "forever\n\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2016", "ICPC", "WF"], "title": "[ICPC 2016 WF] Balanced Diet", "background": "", "description": "Every day, Danny buys one sweet from the candy store and eats it. The store has $m$ types of sweets, numbered from $1$ to $m$. Danny knows that a balanced diet is important and is applying this concept to his sweet purchasing. To each sweet type $i$, he has assigned a target fraction, which is a real number $f_ i$ ($0 < f_ i \\le 1$). He wants the fraction of sweets of type $i$ among all sweets he has eaten to be roughly equal to $f_ i$. To be more precise, let $s_ i$ denote the number of sweets of type $i$ that Danny has eaten, and let $n = \\sum _{i=1}^ m s_ i$. We say the set of sweets is balanced if for every $i$ we have\n\n\\[ n f_ i - 1 < s_ i < n f_ i + 1. \\] \n\nDanny has been buying and eating sweets for a while and during this entire time the set of sweets has been balanced. He is now wondering how many more sweets he can buy while still fulfilling this condition. Given the target fractions $f_ i$ and the sequence of sweets he has eaten so far, determine how many more sweets he can buy and eat so that at any time the set of sweets is balanced.", "inputFormat": "The input consists of three lines. The first line contains two integers $m$ ($1 \\le m \\le 10^5$), which is the number of types of sweets, and $k$ ($0 \\le k \\le 10^5$), which is the number of sweets Danny has already eaten.\n\nThe second line contains $m$ positive integers $a_1, \\ldots , a_ m$. These numbers are proportional to $f_1, \\ldots , f_ m$, that is, $\\displaystyle f_ i = \\frac{a_ i}{\\sum _{j = 1}^ m a_ j}$. It is guaranteed that the sum of all $a_ j$ is no larger than $10^5$.\n\nThe third line contains $k$ integers $b_1, \\ldots , b_ k$ ($1 \\le b_ i \\le m$), where each $b_ i$ denotes the type of sweet Danny bought and ate on the $i^\\text {th}$ day. It is guaranteed that every prefix of this sequence (including the whole sequence) is balanced.", "outputFormat": "Display the maximum number of additional sweets that Danny can buy and eat while keeping his diet continuously balanced. If there is no upper limit on the number of sweets, display the word forever.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en", "translations": {"en": {"title": "[ICPC 2016 WF] Balanced Diet", "background": "", "description": "Every day, Danny buys one sweet from the candy store and eats it. The store has $m$ types of sweets, numbered from $1$ to $m$. Danny knows that a balanced diet is important and is applying this concept to his sweet purchasing. To each sweet type $i$, he has assigned a target fraction, which is a real number $f_ i$ ($0 < f_ i \\le 1$). He wants the fraction of sweets of type $i$ among all sweets he has eaten to be roughly equal to $f_ i$. To be more precise, let $s_ i$ denote the number of sweets of type $i$ that Danny has eaten, and let $n = \\sum _{i=1}^ m s_ i$. We say the set of sweets is balanced if for every $i$ we have\n\n\\[ n f_ i - 1 < s_ i < n f_ i + 1. \\] \n\nDanny has been buying and eating sweets for a while and during this entire time the set of sweets has been balanced. He is now wondering how many more sweets he can buy while still fulfilling this condition. Given the target fractions $f_ i$ and the sequence of sweets he has eaten so far, determine how many more sweets he can buy and eat so that at any time the set of sweets is balanced.", "inputFormat": "The input consists of three lines. The first line contains two integers $m$ ($1 \\le m \\le 10^5$), which is the number of types of sweets, and $k$ ($0 \\le k \\le 10^5$), which is the number of sweets Danny has already eaten.\n\nThe second line contains $m$ positive integers $a_1, \\ldots , a_ m$. These numbers are proportional to $f_1, \\ldots , f_ m$, that is, $\\displaystyle f_ i = \\frac{a_ i}{\\sum _{j = 1}^ m a_ j}$. It is guaranteed that the sum of all $a_ j$ is no larger than $10^5$.\n\nThe third line contains $k$ integers $b_1, \\ldots , b_ k$ ($1 \\le b_ i \\le m$), where each $b_ i$ denotes the type of sweet Danny bought and ate on the $i^\\text {th}$ day. It is guaranteed that every prefix of this sequence (including the whole sequence) is balanced.", "outputFormat": "Display the maximum number of additional sweets that Danny can buy and eat while keeping his diet continuously balanced. If there is no upper limit on the number of sweets, display the word forever.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en"}, "zh-CN": {"title": "[ICPC 2016 WF] Balanced Diet", "background": "", "description": "每天，Danny 都会从糖果店买一颗糖并吃掉它。糖果店中有 $m$ 种糖，编号为 $1 \\dots m$ 。\n\nDanny 知道均衡饮食很重要，他正在尝试在购买糖果时有一个均衡的饮食。因此他给每种糖 $i$ 分配了一个目标分数 $f_i (0 \\le f_i \\le 1, f_i$ 为一个实数 $) $, 。他希望他所吃的所有糖中，第 $i$ 种糖的数量占比大概为 $f_i$ 。\n\n准确的说， 令 $s_ i$ 表示 Danny 已经吃掉的第 $i$ 种糖的数量,  $n = \\sum _{i=1}^ m s_ i$, 我们认为一种吃糖的方法是均衡的仅当对于所有的 $i$，满足：\n\n$$n f_ i - 1 < s_ i < n f_ i + 1$$\n\nDanny 已经购买并吃掉了一些糖，并且他保证每个前缀的饮食都是均衡的。他想知道在保证每个前缀均衡饮食的条件下，他最多还能吃多少颗糖。\n\n给定目标分数 $f_i$\n和他已经吃过的糖果序列，请你确定在保证每个前缀均衡饮食的条件下，Danny 最多还能购买并吃掉多少颗糖果。", "inputFormat": "输入包含三行。第一行包括两个整数 m $1 \\le m \\le 10^5$ 表示糖果的种类, $k(0 \\le k \\le 10^5)$ 表示 Danny 已经吃掉的糖果数量。\n\n第二行包括 $m$ 个正整数 $a_1 \\dots a_m$, 有   $ \\displaystyle f_ i = \\frac{a_ i}{\\sum _{j = 1}^ m a_ j}$, 保证\n$\\sum_{i=1}^m a_i \\le 10^5$ 。\n\n第三行包括 $k$ 个正整数 $b_1 \\dots b_k (1 \\le b_i \\le m)$, 表示 Danny 在第 $i$ 天购买并吃掉的糖的种类。保证序列的每个前缀（包括整个序列）是饮食均衡的。", "outputFormat": "输出在保证每个前缀饮食均衡的条件下，Danny 最多还能购买并吃掉多少颗糖。\n\n如果糖果的数量没有上限（即 Danny 能一直买下去），输出 `forever`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6918", "type": "P", "difficulty": 6, "samples": [["5 4 2 10\n5 2 1\n2 5 1\n3 5 5\n4 5 0\n1 5 1\n2 3 1\n3 2 5\n2 4 5\n2 1 1\n3 4 2\n", "13\n"], ["5 4 2 10\n5 2 1\n2 5 1\n3 5 5\n4 5 10\n1 5 1\n2 3 1\n3 2 5\n2 4 5\n2 1 1\n3 4 2\n", "24\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "四边形不等式", "ICPC", "WF"], "title": "[ICPC 2016 WF] Branch Assignment", "background": "", "description": "The Innovative Consumer Products Company (ICPC) is planning to start a top-secret project. This project consists of $s$ subprojects. There will be $b \\ge s$ branches of ICPC involved in this project and ICPC wants to assign each branch to one of the subprojects. In other words, the branches will form $s$ disjoint groups, with each group in charge of a subproject.\n\nAt the end of each month, each branch will send a message to every other branch in its group (a different message to each branch). ICPC has a particular protocol for its communications. Each branch $i$ has a secret key $k_ i$ known only to the branch and the ICPC headquarters. Assume branch $i$ wants to send a message to branch $j$. Branch $i$ encrypts its message with its key $k_ i$. A trusted courier picks up this message from this branch and delivers it to the ICPC headquarters. Headquarters decrypts the message with key $k_ i$ and re-encrypts it with key $k_ j$. The courier then delivers this newly encrypted message to branch $j$, which decrypts it with its own key $k_ j$. For security reasons, a courier can carry only one message at a time.\n\nGiven a road network and the locations of branches and the headquarters in this network, your task is to determine the minimum total distance that the couriers will need to travel to deliver all the end-of-month messages, over all possible assignments of branches to subprojects.", "inputFormat": "The first line of input contains four integers $n$, $b$, $s$, and $r$, where $n$ ($2 \\le n \\le 5\\, 000$) is the number of intersections, $b$ ($1 \\le b \\le n-1$) is the number of branches, $s$ ($1 \\le s \\le b$) is the number of subprojects, and $r$ ($1 \\le r \\le 50\\, 000$) is the number of roads. The intersections are numbered from $1$ through $n$. The branches are at intersections $1$ through $b$, and the headquarters is at intersection $b + 1$. Each of the next $r$ lines contains three integers $u$, $v$, and $\\ell $, indicating a one-way road from intersection $u$ to a different intersection $v$ ($1 \\leq u,v \\leq n$) of length $\\ell $ ($0 \\leq \\ell \\leq 10\\, 000$). No ordered pair $(u,v)$ appears more than once, and from any intersection it is possible to reach every other intersection.", "outputFormat": "Display the minimum total distance that the couriers will need to travel.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en", "translations": {"en": {"title": "[ICPC 2016 WF] Branch Assignment", "background": "", "description": "The Innovative Consumer Products Company (ICPC) is planning to start a top-secret project. This project consists of $s$ subprojects. There will be $b \\ge s$ branches of ICPC involved in this project and ICPC wants to assign each branch to one of the subprojects. In other words, the branches will form $s$ disjoint groups, with each group in charge of a subproject.\n\nAt the end of each month, each branch will send a message to every other branch in its group (a different message to each branch). ICPC has a particular protocol for its communications. Each branch $i$ has a secret key $k_ i$ known only to the branch and the ICPC headquarters. Assume branch $i$ wants to send a message to branch $j$. Branch $i$ encrypts its message with its key $k_ i$. A trusted courier picks up this message from this branch and delivers it to the ICPC headquarters. Headquarters decrypts the message with key $k_ i$ and re-encrypts it with key $k_ j$. The courier then delivers this newly encrypted message to branch $j$, which decrypts it with its own key $k_ j$. For security reasons, a courier can carry only one message at a time.\n\nGiven a road network and the locations of branches and the headquarters in this network, your task is to determine the minimum total distance that the couriers will need to travel to deliver all the end-of-month messages, over all possible assignments of branches to subprojects.", "inputFormat": "The first line of input contains four integers $n$, $b$, $s$, and $r$, where $n$ ($2 \\le n \\le 5\\, 000$) is the number of intersections, $b$ ($1 \\le b \\le n-1$) is the number of branches, $s$ ($1 \\le s \\le b$) is the number of subprojects, and $r$ ($1 \\le r \\le 50\\, 000$) is the number of roads. The intersections are numbered from $1$ through $n$. The branches are at intersections $1$ through $b$, and the headquarters is at intersection $b + 1$. Each of the next $r$ lines contains three integers $u$, $v$, and $\\ell $, indicating a one-way road from intersection $u$ to a different intersection $v$ ($1 \\leq u,v \\leq n$) of length $\\ell $ ($0 \\leq \\ell \\leq 10\\, 000$). No ordered pair $(u,v)$ appears more than once, and from any intersection it is possible to reach every other intersection.", "outputFormat": "Display the minimum total distance that the couriers will need to travel.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en"}, "zh-CN": {"title": "[ICPC 2016 WF] Branch Assignment", "background": "", "description": "创新消费品公司（ICPC）计划启动一个绝密项目。该项目由 $s$ 个子项目组成。将有 $b \\ge s$ 个 ICPC 的分支机构参与此项目，ICPC 希望将每个分支机构分配给一个子项目。换句话说，这些分支机构将形成 $s$ 个不相交的组，每个组负责一个子项目。\n\n每个月底，每个分支机构将向其组内的每个其他分支机构发送一条消息（每个分支机构接收不同的消息）。ICPC 有一个特定的通信协议。每个分支机构 $i$ 有一个只有该分支机构和 ICPC 总部知道的密钥 $k_i$。假设分支机构 $i$ 想要向分支机构 $j$ 发送消息。分支机构 $i$ 用其密钥 $k_i$ 加密消息。一个可信的信使从该分支机构取走消息并将其交付给 ICPC 总部。总部用密钥 $k_i$ 解密消息，并用密钥 $k_j$ 重新加密。然后信使将这个新加密的消息交付给分支机构 $j$，分支机构 $j$ 用其自己的密钥 $k_j$ 解密。出于安全原因，信使一次只能携带一条消息。\n\n给定一个道路网络以及分支机构和总部在此网络中的位置，你的任务是确定信使在所有可能的分支机构到子项目的分配中，传递所有月底消息所需的最小总距离。", "inputFormat": "输入的第一行包含四个整数 $n$、$b$、$s$ 和 $r$，其中 $n$ ($2 \\le n \\le 5\\, 000$) 是交叉路口的数量，$b$ ($1 \\le b \\le n-1$) 是分支机构的数量，$s$ ($1 \\le s \\le b$) 是子项目的数量，$r$ ($1 \\le r \\le 50\\, 000$) 是道路的数量。交叉路口编号从 $1$ 到 $n$。分支机构位于交叉路口 $1$ 到 $b$，总部位于交叉路口 $b + 1$。接下来的 $r$ 行中的每一行包含三个整数 $u$、$v$ 和 $\\ell$，表示从交叉路口 $u$ 到不同交叉路口 $v$ ($1 \\leq u,v \\leq n$) 的一条单向道路，长度为 $\\ell$ ($0 \\leq \\ell \\leq 10\\, 000$)。没有有序对 $(u,v)$ 会出现多次，并且从任何交叉路口都可以到达每个其他交叉路口。", "outputFormat": "输出信使需要行驶的最小总距离。", "hint": "时间限制：2000 毫秒，内存限制：1048576 kB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2016。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6919", "type": "P", "difficulty": 4, "samples": [["5 3\n2 7 1\n3 1 4\n1 5 9\n2 6 5\n9 7 3\n", "4\n"], ["3 4\n3 1 2 40000\n3 4 2 1\n33 42 17 23\n", "2\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "ICPC", "WF"], "title": "[ICPC 2016 WF] Ceiling Function", "background": "", "description": "Advanced Ceiling Manufacturers (ACM) is analyzing the properties of its new series of Incredibly Collapse-Proof Ceilings (ICPCs). An ICPC consists of $n$ layers of material, each with a different value of collapse resistance (measured as a positive integer). The analysis ACM wants to run will take the collapse-resistance values of the layers, store them in a binary search tree, and check whether the shape of this tree in any way correlates with the quality of the whole construction. Because, well, why should it not?\n\nTo be precise, ACM takes the collapse-resistance values for the layers, ordered from the top layer to the bottom layer, and inserts them one-by-one into a tree. The rules for inserting a value $v$ are:\n\nIf the tree is empty, make $v$ the root of the tree.\n\nIf the tree is not empty, compare $v$ with the root of the tree. If $v$ is smaller, insert $v$ into the left subtree of the root, otherwise insert $v$ into the right subtree.\n\nACM has a set of ceiling prototypes it wants to analyze by trying to collapse them. It wants to take each group of ceiling prototypes that have trees of the same shape and analyze them together.\n\nFor example, assume ACM is considering five ceiling prototypes with three layers each, as described by Sample Input 1 and shown in Figure 1. Notice that the first prototype’s top layer has collapse-resistance value 2, the middle layer has value 7, and the bottom layer has value 1. The second prototype has layers with collapse-resistance values of 3, 1, and 4 – and yet these two prototypes induce the same tree shape, so ACM will analyze them together.\n\nGiven a set of prototypes, your task is to determine how many different tree shapes they induce.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xvdteesl.png)\n\n   Figure 1: The four tree shapes induced by the ceiling prototypes in Sample Input 1. ", "inputFormat": "The first line of the input contains two integers $n$ ($1 \\le n \\le 50$), which is the number of ceiling prototypes to analyze, and $k$ ($1 \\le k \\le 20$), which is the number of layers in each of the prototypes.\n\nThe next $n$ lines describe the ceiling prototypes. Each of these lines contains $k$ distinct integers (between $1$ and $10^6$, inclusive), which are the collapse-resistance values of the layers in a ceiling prototype, ordered from top to bottom.", "outputFormat": "Display the number of different tree shapes.", "hint": "Time limit: 5000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en", "translations": {"en": {"title": "[ICPC 2016 WF] Ceiling Function", "background": "", "description": "Advanced Ceiling Manufacturers (ACM) is analyzing the properties of its new series of Incredibly Collapse-Proof Ceilings (ICPCs). An ICPC consists of $n$ layers of material, each with a different value of collapse resistance (measured as a positive integer). The analysis ACM wants to run will take the collapse-resistance values of the layers, store them in a binary search tree, and check whether the shape of this tree in any way correlates with the quality of the whole construction. Because, well, why should it not?\n\nTo be precise, ACM takes the collapse-resistance values for the layers, ordered from the top layer to the bottom layer, and inserts them one-by-one into a tree. The rules for inserting a value $v$ are:\n\nIf the tree is empty, make $v$ the root of the tree.\n\nIf the tree is not empty, compare $v$ with the root of the tree. If $v$ is smaller, insert $v$ into the left subtree of the root, otherwise insert $v$ into the right subtree.\n\nACM has a set of ceiling prototypes it wants to analyze by trying to collapse them. It wants to take each group of ceiling prototypes that have trees of the same shape and analyze them together.\n\nFor example, assume ACM is considering five ceiling prototypes with three layers each, as described by Sample Input 1 and shown in Figure 1. Notice that the first prototype’s top layer has collapse-resistance value 2, the middle layer has value 7, and the bottom layer has value 1. The second prototype has layers with collapse-resistance values of 3, 1, and 4 – and yet these two prototypes induce the same tree shape, so ACM will analyze them together.\n\nGiven a set of prototypes, your task is to determine how many different tree shapes they induce.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xvdteesl.png)\n\n   Figure 1: The four tree shapes induced by the ceiling prototypes in Sample Input 1. ", "inputFormat": "The first line of the input contains two integers $n$ ($1 \\le n \\le 50$), which is the number of ceiling prototypes to analyze, and $k$ ($1 \\le k \\le 20$), which is the number of layers in each of the prototypes.\n\nThe next $n$ lines describe the ceiling prototypes. Each of these lines contains $k$ distinct integers (between $1$ and $10^6$, inclusive), which are the collapse-resistance values of the layers in a ceiling prototype, ordered from top to bottom.", "outputFormat": "Display the number of different tree shapes.", "hint": "Time limit: 5000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en"}, "zh-CN": {"title": "[ICPC 2016 WF] Ceiling Function", "background": "", "description": "高级天花板制造商（ACM）正在分析其新系列的极其防坍塌天花板（ICPC）的特性。一个 ICPC 由 $n$ 层材料组成，每层都有不同的抗坍塌值（以正整数表示）。ACM 想要进行的分析将把各层的抗坍塌值存储在一个二叉搜索树中，并检查该树的形状是否与整个结构的质量相关。因为，为什么不呢？\n\n具体来说，ACM 将从顶层到底层依次获取各层的抗坍塌值，并将它们逐一插入到树中。插入值 $v$ 的规则是：\n\n如果树是空的，则将 $v$ 作为树的根。\n\n如果树不为空，将 $v$ 与树的根进行比较。如果 $v$ 较小，则将 $v$ 插入到根的左子树中，否则插入到右子树中。\n\nACM 有一组天花板原型，它想通过尝试坍塌它们来进行分析。它想将具有相同树形状的天花板原型分组并一起分析。\n\n例如，假设 ACM 正在考虑五个具有三层的天花板原型，如样例输入 1 所述并如图 1 所示。注意，第一个原型的顶层抗坍塌值为 2，中间层的值为 7，底层的值为 1。第二个原型的层的抗坍塌值为 3、1 和 4——然而这两个原型产生了相同的树形状，因此 ACM 将一起分析它们。\n\n给定一组原型，您的任务是确定它们产生了多少种不同的树形状。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xvdteesl.png)\n\n图 1：样例输入 1 中天花板原型所产生的四种树形状。", "inputFormat": "输入的第一行包含两个整数 $n$ ($1 \\le n \\le 50$)，表示要分析的天花板原型的数量，以及 $k$ ($1 \\le k \\le 20$)，表示每个原型的层数。\n\n接下来的 $n$ 行描述了天花板原型。每行包含 $k$ 个不同的整数（范围在 $1$ 到 $10^6$ 之间，包括边界），这些整数是天花板原型中各层的抗坍塌值，从上到下排列。", "outputFormat": "输出不同树形状的数量。", "hint": "时间限制：5000 毫秒，内存限制：1048576 KB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2016。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6920", "type": "P", "difficulty": 6, "samples": [["3\n......XX.....XX...XX.\n.....X..X...X..X....X\n.....X..X.X.X..X....X\n.............XX...XX.\n.....X..X......X.X..X\n.....X..X......X.X..X\n......XX.....XX...XX.\n\n......XX.....XX...XX.\n.....X..X...X..X....X\n.....X..X.X.X..X....X\n.............XX...XX.\n.....X..X......X.X..X\n.....X..X......X.X..X\n......XX.....XX...XX.\n\n.............XX...XX.\n........X...X..X....X\n........X.X.X..X....X\n.............XX......\n........X...X..X.X..X\n........X...X..X.X..X\n......XX.....XX...XX.\n", ".??...WW.....??...??.\n?..?.W..?...?..1.0..?\n?..?.W..?.?.?..1.0..?\n.??...??.....11...WW.\n?..?.W..?.0.W..?.1..?\n?..?.W..?...W..?.1..?\n.??...11.....??...??.\n"], ["2\n......XX.....XX...XX.\n...X....X...X..X.X..X\n...X....X.X.X..X.X..X\n......XX..........XX.\n...X.X....X.X..X.X..X\n...X.X......X..X.X..X\n......XX.....XX...XX.\n\n......XX.....XX......\n...X....X...X..X.....\n...X....X.X.X..X.....\n......XX.............\n...X.X....X.X..X.....\n...X.X......X..X.....\n......XX.....XX......\n", "impossible\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2016", "枚举", "ICPC", "WF"], "title": "[ICPC 2016 WF] Clock Breaking", "background": "", "description": "After numerous unfortunate freak fatalities and the lawsuits, settlements, protests, and boycotts that naturally followed, the beleaguered executives at ACME Clock Manufacturers have decided they need to finally fix their disastrous quality control issues. It has been known for years that the digital clocks they manufacture have an unacceptably high ratio of faulty liquid-crystal display (LCD) screens, and yet these heartless souls have repeatedly failed to address the issue, or even warn their hapless consumers!\n\nYou have been called in as a quality consultant to finally put a stop to the madness. Your job is to write an automated program that can test a clock and find faults in its display.\n\nThese clocks use a standard 7-segment LCD display for all digits (shown on the left in Figure 1), plus two small segments for the ‘:’, and show all times in a 24-hour format. The minute before midnight is 23:59, and midnight is 0:00. The ‘:’ segments of a working clock are on at all times. The representation of each digit using the seven segments is shown on the right in Figure 1.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3ornshtp.png)\n\n   Figure 1: LCD display of each digit. \n\nYour program will be given the display of a clock at several consecutive minutes, although you do not know exactly what time these displays start. Some of the LCD segments are burnt out (permanently off) and some are burnt in (permanently on). Your program must determine, where possible, which segments are definitely malfunctioning and which are definitely in working order.", "inputFormat": "The first input line contains a single integer $n$ ($1 \\leq n \\leq 100$), which is the number of consecutive minutes of a clock’s display. The next $8n-1$ lines contain $n$ ASCII images of these clock displays of size $7 \\times 21$, with a single blank line separating the representations.\n\nAll digit segments are represented by two characters, and each colon segment is represented by one character. The character ‘X’ indicates a segment that is on. The character ‘.’ indicates anything else (segments that are off or non-segment portions of the display). See the sample input/output for details; the first output shows every possible LCD segment along with the smaller segments used to represent the ‘:’. No clock representation has an ‘X’ in a non-segment position or only half of a segment showing.", "outputFormat": "Display a $7 \\times 21$ ASCII image with a ‘0’ for every segment that is burnt out, a ‘1’ for every segment that is burnt in, a ‘W’ for every segment that is definitely working, and a ‘?’ for every segment for which the status cannot be determined. Use ‘.’ for non-segments. If the given displays cannot come from consecutive minutes, display impossible.", "hint": "Time limit: 3000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en", "translations": {"en": {"title": "[ICPC 2016 WF] Clock Breaking", "background": "", "description": "After numerous unfortunate freak fatalities and the lawsuits, settlements, protests, and boycotts that naturally followed, the beleaguered executives at ACME Clock Manufacturers have decided they need to finally fix their disastrous quality control issues. It has been known for years that the digital clocks they manufacture have an unacceptably high ratio of faulty liquid-crystal display (LCD) screens, and yet these heartless souls have repeatedly failed to address the issue, or even warn their hapless consumers!\n\nYou have been called in as a quality consultant to finally put a stop to the madness. Your job is to write an automated program that can test a clock and find faults in its display.\n\nThese clocks use a standard 7-segment LCD display for all digits (shown on the left in Figure 1), plus two small segments for the ‘:’, and show all times in a 24-hour format. The minute before midnight is 23:59, and midnight is 0:00. The ‘:’ segments of a working clock are on at all times. The representation of each digit using the seven segments is shown on the right in Figure 1.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3ornshtp.png)\n\n   Figure 1: LCD display of each digit. \n\nYour program will be given the display of a clock at several consecutive minutes, although you do not know exactly what time these displays start. Some of the LCD segments are burnt out (permanently off) and some are burnt in (permanently on). Your program must determine, where possible, which segments are definitely malfunctioning and which are definitely in working order.", "inputFormat": "The first input line contains a single integer $n$ ($1 \\leq n \\leq 100$), which is the number of consecutive minutes of a clock’s display. The next $8n-1$ lines contain $n$ ASCII images of these clock displays of size $7 \\times 21$, with a single blank line separating the representations.\n\nAll digit segments are represented by two characters, and each colon segment is represented by one character. The character ‘X’ indicates a segment that is on. The character ‘.’ indicates anything else (segments that are off or non-segment portions of the display). See the sample input/output for details; the first output shows every possible LCD segment along with the smaller segments used to represent the ‘:’. No clock representation has an ‘X’ in a non-segment position or only half of a segment showing.", "outputFormat": "Display a $7 \\times 21$ ASCII image with a ‘0’ for every segment that is burnt out, a ‘1’ for every segment that is burnt in, a ‘W’ for every segment that is definitely working, and a ‘?’ for every segment for which the status cannot be determined. Use ‘.’ for non-segments. If the given displays cannot come from consecutive minutes, display impossible.", "hint": "Time limit: 3000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en"}, "zh-CN": {"title": "[ICPC 2016 WF] Clock Breaking", "background": "", "description": "在无数不幸的畸形死亡事件以及随之而来的诉讼、和解、抗议和抵制之后，ACME时钟制造商的高管们决定最终解决灾难性的质量控制问题。多年来，人们都知道，他们制造的数字钟的液晶显示屏故障率高得令人无法接受，然而，这些无情的人们却一再未能解决这个问题，甚至未能警告他们不幸的消费者！  \n\n你被邀请担任质量顾问，最终制止了这种疯狂。你的工作是编写一个自动程序，可以测试时钟并发现其显示中的故障。  \n\n这些时钟使用标准的7段LCD显示屏显示所有数字（如图1左侧所示），加上两个小段显示`：`，并以24小时计时法显示所有时间。午夜前一分钟是23:59，午夜是0:00。工作时钟的`：`段始终打开。图1右侧显示了使用七段表示的`0~9`每个数字。  \n\n![图1：每个数字的LCD显示。](https://cdn.luogu.com.cn/upload/image_hosting/3ornshtp.png)   \n\n图1：每个数字的LCD显示。", "inputFormat": "第一行有一个数$n(1\\ \\le\\ n\\ \\le\\ 100)$，这是时钟显示的连续分钟数。  \n\n接下来$8n-1$行包括$n$个时钟显示的$7\\times 21$的ASCII图像，每两个之间会有一行的空白用于间隔  \n\n所有表示数字的段由两个连续的字符表示，每个表示冒号的段由一个字符表示。字符`X`表示打开的段。字符`.`指示其他任何内容（显示的分段或非分段部分）。详见样本输入、输出；第一个输出显示每个可能的LCD段以及用于表示`：`的较小段。没有时钟表示在非段位置有`X`，或仅显示段的一半。", "outputFormat": "显示一个$7\\times 21$ASCII图像，每个烧坏的段显示一个`0`，每个烧进的段显示`1`，每个正常工作的段显示为`W`，以及一个`？`对于无法确定状态的每个段。使用`.`对于非分段。如果给定的显示不能来自连续分钟，则显示`impossible`。  \n\n### 输入输出样例", "hint": "时间限制：3000ms=3s  \n\n空间限制：1048576KB=1024MB=1GB  \n\n出处:2016年国际大学生编程大赛（`ACM-ICPC`）世界总决赛", "locale": "zh-CN"}}}
{"pid": "P6921", "type": "P", "difficulty": 5, "samples": [["32 20\n", "16\n"], ["2016 100\n", "42\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2016", "ICPC", "WF"], "title": "[ICPC 2016 WF] Forever Young", "background": "", "description": "My birthday is coming up. Alas, I am getting old and would like to feel young again. Fortunately, I have come up with an excellent way of feeling younger: if I write my age as a number in an appropriately chosen base $b$, then it appears to be smaller. For instance, suppose my age in base $10$ is $32$. Written in base $16$ it is only $20$!\n\nHowever, I cannot choose an arbitrary base when doing this. If my age written in base $b$ contains digits other than $0$ to $9$, then it will be obvious that I am cheating, which defeats the purpose. In addition, if my age written in base $b$ is too small then it would again be obvious that I am cheating.\n\nGiven my age $y$ and a lower bound $\\ell $ on how small I want my age to appear, find the largest base $b$ such that $y$ written in base $b$ contains only decimal digits, and is at least $\\ell $ when interpreted as a number in base $10$.", "inputFormat": "The input consists of a single line containing two base 10 integers $y$ ($10 \\le y \\le 10^{18}$ – yes, I am very old) and $\\ell $ ($10 \\le \\ell \\le y$).", "outputFormat": "Display the largest base $b$ as described above.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en", "translations": {"en": {"title": "[ICPC 2016 WF] Forever Young", "background": "", "description": "My birthday is coming up. Alas, I am getting old and would like to feel young again. Fortunately, I have come up with an excellent way of feeling younger: if I write my age as a number in an appropriately chosen base $b$, then it appears to be smaller. For instance, suppose my age in base $10$ is $32$. Written in base $16$ it is only $20$!\n\nHowever, I cannot choose an arbitrary base when doing this. If my age written in base $b$ contains digits other than $0$ to $9$, then it will be obvious that I am cheating, which defeats the purpose. In addition, if my age written in base $b$ is too small then it would again be obvious that I am cheating.\n\nGiven my age $y$ and a lower bound $\\ell $ on how small I want my age to appear, find the largest base $b$ such that $y$ written in base $b$ contains only decimal digits, and is at least $\\ell $ when interpreted as a number in base $10$.", "inputFormat": "The input consists of a single line containing two base 10 integers $y$ ($10 \\le y \\le 10^{18}$ – yes, I am very old) and $\\ell $ ($10 \\le \\ell \\le y$).", "outputFormat": "Display the largest base $b$ as described above.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en"}, "zh-CN": {"title": "[ICPC 2016 WF] Forever Young", "background": "", "description": "# 题目大意\n\n我的生日快到了！唉，但如今我已经老了，我想重新获得年轻的感觉。\n\n幸运的是，我想出了一个让人感觉更年轻的好方法：如果我把我的年龄以适当选择的 $b$ 进制书写，那么它看起来会更小。例如，假设我以 $10$ 进制书写的年龄是 $32$ 岁；以 $16$ 进制书写，它只有 $20$（$\\texttt{0x20}$）！\n\n然而，在这样做时，我不能选择任意进制数。如果以 $b$ 进制为数写的我的年龄包含 $0-9$ 以外的数字，那么很明显我在作弊，这违背了目的。此外，如果我的年龄写成 $b$ 进制后数字太小，那么很明显我在作弊。\n\n在我希望我的年龄看起来有多小的问题上，考虑到我的年龄 $y$ 和下限 $l$，找到最大的进制数 $b$，这样写在基数 $b$ 中的 $y$ 只包含十进制数字，并且当将其看做一个十进制数字时至少是 $l$。", "inputFormat": "输入由一行组成，其中包含两个 $10$ 进制的整数 $y$（$10\\le y\\le10^{18}$ – 是的,我很老）和 $l$（$10\\le l \\le y$）", "outputFormat": "如上所述，输出最大进制数 $b$。", "hint": "时间限制：1s，内存限制：1GB。\n\n\n2016 年国际大学生编程大赛 ACM-ICPC 世界总决赛。", "locale": "zh-CN"}}}
{"pid": "P6922", "type": "P", "difficulty": 6, "samples": [["6 2\nPaSak 0 513\nNan 2 675\nYom 2 700\nWang 1 335\nPing 1 305\nThaChin 0 765\n0 353\n0 65\n", "PaSak 5\nNan 2\nYom 1\nWang 3\nPing 4\nThaChin 1\n"]], "limits": {"time": [9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "ICPC", "WF"], "title": "[ICPC 2016 WF] Longest Rivers", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/4ul9evsl.png)\n\nThe Chao Phraya River System is the main river system of Thailand. Its six longest rivers listed by decreasing length are:\n\nTha Chin ($765$ km)\n\nNan ($740$ km)\n\nYom ($700$ km)\n\nPing ($658$ km)\n\nPa Sak ($513$ km)\n\nWang ($335$ km)\n\nA simplified model of this river system is shown in Figure 1, where the smaller red numbers indicate the lengths of various sections of each river. The point where two or more rivers meet as they flow downstream is called a confluence. Confluences are labeled with the larger black numbers. In this model, each river either ends at a confluence or flows into the sea, which is labeled with the special confluence number $0$. When two or more rivers meet at a confluence (other than confluence $0$), the resulting merged river takes the name of one of those rivers. For example, the Ping and the Wang meet at confluence $1$ with the resulting merged river retaining the name Ping. With this naming, the Ping has length $658$ km while the Wang is only $335$ km. If instead the merged river had been named Wang, then the length of the Wang would be $688$ km while the length of the Ping would be only $305$ km.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n8uvzv81.png)\n\n   Figure 1: The river system in Sample Input 1. Same-colored edges indicate a river. \n\nThe raised awareness of this phenomenon causes bitter rivalries among the towns along the rivers. For example, the townspeople along the Wang protest that maybe with a proper naming scheme, their river could actually be the longest, or maybe the second longest (or at least not last!). To end all the guessing, your task is to validate all such claims.\n\nThe rank of a river is its position in a list of all rivers ordered by decreasing length, where the best rank is $1$ for the longest river. For each river, determine its best possible rank over all naming schemes. At any confluence, the name of a new, larger river in any naming scheme must be one of the names of the smaller rivers which join at that confluence. If two or more rivers have equal lengths in a naming scheme, all the tied rivers are considered to have the best possible ranking. For example, if one river is the longest and all other rivers are equal, those rivers all have rank $2$.", "inputFormat": "The first line of input contains two integers $n$ $(1 \\le n \\le 500\\, 000)$, which is the number of river sources in the system, and $m$ $(0 \\le m \\le n - 1)$, which is the number of confluences with positive labels. These confluences are numbered from $1$ to $m$.\n\nThe next $n$ lines describe the rivers. Each of these lines consists of a string, which is the name of the river at the source, and two integers $c$ $(0 \\leq c \\leq m)$ and $d$ $(1 \\leq d \\leq 10^9)$, where $c$ is the identifier of the nearest confluence downstream, and $d$ is the distance from the source to that confluence in kilometers. River names use only lowercase and uppercase letters a–z, and consist of between $1$ and $10$ characters, inclusive.\n\nThe final $m$ lines describe confluences $1$ to $m$ in a similar fashion. The $k^\\text {th}$ of these lines describes the confluence with identifier $k$ and contains two integers: the identifier of the nearest confluence downstream and the distance from confluence $k$ to this confluence in kilometers.\n\nIt is guaranteed that each confluence $1$ through $m$ appears as “the nearest downstream” at least twice, confluence $0$ appears at least once, and all sources are connected to confluence $0$.", "outputFormat": "Display one river per line in the same order as in the input. On that line, display the name of the river and its best possible rank.", "hint": "Time limit: 9000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en", "translations": {"en": {"title": "[ICPC 2016 WF] Longest Rivers", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/4ul9evsl.png)\n\nThe Chao Phraya River System is the main river system of Thailand. Its six longest rivers listed by decreasing length are:\n\nTha Chin ($765$ km)\n\nNan ($740$ km)\n\nYom ($700$ km)\n\nPing ($658$ km)\n\nPa Sak ($513$ km)\n\nWang ($335$ km)\n\nA simplified model of this river system is shown in Figure 1, where the smaller red numbers indicate the lengths of various sections of each river. The point where two or more rivers meet as they flow downstream is called a confluence. Confluences are labeled with the larger black numbers. In this model, each river either ends at a confluence or flows into the sea, which is labeled with the special confluence number $0$. When two or more rivers meet at a confluence (other than confluence $0$), the resulting merged river takes the name of one of those rivers. For example, the Ping and the Wang meet at confluence $1$ with the resulting merged river retaining the name Ping. With this naming, the Ping has length $658$ km while the Wang is only $335$ km. If instead the merged river had been named Wang, then the length of the Wang would be $688$ km while the length of the Ping would be only $305$ km.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n8uvzv81.png)\n\n   Figure 1: The river system in Sample Input 1. Same-colored edges indicate a river. \n\nThe raised awareness of this phenomenon causes bitter rivalries among the towns along the rivers. For example, the townspeople along the Wang protest that maybe with a proper naming scheme, their river could actually be the longest, or maybe the second longest (or at least not last!). To end all the guessing, your task is to validate all such claims.\n\nThe rank of a river is its position in a list of all rivers ordered by decreasing length, where the best rank is $1$ for the longest river. For each river, determine its best possible rank over all naming schemes. At any confluence, the name of a new, larger river in any naming scheme must be one of the names of the smaller rivers which join at that confluence. If two or more rivers have equal lengths in a naming scheme, all the tied rivers are considered to have the best possible ranking. For example, if one river is the longest and all other rivers are equal, those rivers all have rank $2$.", "inputFormat": "The first line of input contains two integers $n$ $(1 \\le n \\le 500\\, 000)$, which is the number of river sources in the system, and $m$ $(0 \\le m \\le n - 1)$, which is the number of confluences with positive labels. These confluences are numbered from $1$ to $m$.\n\nThe next $n$ lines describe the rivers. Each of these lines consists of a string, which is the name of the river at the source, and two integers $c$ $(0 \\leq c \\leq m)$ and $d$ $(1 \\leq d \\leq 10^9)$, where $c$ is the identifier of the nearest confluence downstream, and $d$ is the distance from the source to that confluence in kilometers. River names use only lowercase and uppercase letters a–z, and consist of between $1$ and $10$ characters, inclusive.\n\nThe final $m$ lines describe confluences $1$ to $m$ in a similar fashion. The $k^\\text {th}$ of these lines describes the confluence with identifier $k$ and contains two integers: the identifier of the nearest confluence downstream and the distance from confluence $k$ to this confluence in kilometers.\n\nIt is guaranteed that each confluence $1$ through $m$ appears as “the nearest downstream” at least twice, confluence $0$ appears at least once, and all sources are connected to confluence $0$.", "outputFormat": "Display one river per line in the same order as in the input. On that line, display the name of the river and its best possible rank.", "hint": "Time limit: 9000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en"}, "zh-CN": {"title": "[ICPC 2016 WF] Longest Rivers", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/4ul9evsl.png)\n\n湄南河系统是泰国的主要河流系统。按长度递减排列的六条最长的河流是：\n\nTha Chin（$765$ 公里）\n\nNan（$740$ 公里）\n\nYom（$700$ 公里）\n\nPing（$658$ 公里）\n\nPa Sak（$513$ 公里）\n\nWang（$335$ 公里）\n\n图 1 展示了该河流系统的简化模型，其中较小的红色数字表示各河段的长度。两个或多个河流在下游汇合的点称为汇合点。汇合点用较大的黑色数字标记。在这个模型中，每条河流要么在汇合点结束，要么流入大海，流入大海的汇合点标记为特殊的汇合点编号 $0$。当两条或多条河流在汇合点（汇合点 $0$ 除外）汇合时，合并后的河流会取其中一条河流的名字。例如，Ping 和 Wang 在汇合点 $1$ 汇合，合并后的河流保留了 Ping 的名字。这样命名下，Ping 的长度为 $658$ 公里，而 Wang 只有 $335$ 公里。如果合并后的河流命名为 Wang，那么 Wang 的长度将为 $688$ 公里，而 Ping 的长度只有 $305$ 公里。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n8uvzv81.png)\n\n图 1：样例输入 1 中的河流系统。同色的边表示一条河流。\n\n对这一现象的关注引发了沿河城镇之间的激烈竞争。例如，沿 Wang 河的居民抗议说，也许通过适当的命名方案，他们的河流实际上可能是最长的，或者可能是第二长的（至少不是最后一名！）。为了结束所有的猜测，你的任务是验证所有这样的说法。\n\n河流的排名是按长度递减排列的所有河流中的位置，最长的河流排名为 $1$。对于每条河流，确定在所有命名方案中其可能的最佳排名。在任何汇合点，任何命名方案中新、较大的河流的名称必须是该汇合点汇合的较小河流之一的名称。如果在某个命名方案中两条或多条河流长度相等，则所有并列的河流被视为具有可能的最佳排名。例如，如果一条河流是最长的，而所有其他河流相等，则这些河流的排名均为 $2$。", "inputFormat": "输入的第一行包含两个整数 $n$ $(1 \\le n \\le 500\\, 000)$，表示系统中的河流源数量，以及 $m$ $(0 \\le m \\le n - 1)$，表示带有正标签的汇合点数量。这些汇合点编号从 $1$ 到 $m$。\n\n接下来的 $n$ 行描述了河流。每行由一个字符串（表示河流源头的名称）和两个整数 $c$ $(0 \\leq c \\leq m)$ 和 $d$ $(1 \\leq d \\leq 10^9)$ 组成，其中 $c$ 是下游最近的汇合点的标识符，$d$ 是从源头到该汇合点的距离（以公里为单位）。河流名称仅使用小写和大写字母 a–z，长度在 $1$ 到 $10$ 个字符之间（含）。\n\n最后的 $m$ 行以类似的方式描述了汇合点 $1$ 到 $m$。第 $k^\\text {th}$ 行描述了标识符为 $k$ 的汇合点，并包含两个整数：下游最近的汇合点的标识符和从汇合点 $k$ 到该汇合点的距离（以公里为单位）。\n\n保证每个汇合点 $1$ 到 $m$ 至少出现两次作为“下游最近的汇合点”，汇合点 $0$ 至少出现一次，并且所有源头都连接到汇合点 $0$。", "outputFormat": "按输入顺序每行显示一条河流。在该行上，显示河流的名称及其可能的最佳排名。", "hint": "时间限制：9000 毫秒，内存限制：1048576 KB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2016。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6923", "type": "P", "difficulty": 7, "samples": [["8\n0 0\n0 10\n10 10\n15 15\n24 6\n24 10\n30 10\n30 0\n7\n-5 0\n-5 10\n10 10\n15 5\n20 10\n35 10\n35 0\n", "30.142135624\n"], ["3\n1 0\n0 30\n40 0\n3\n1 0\n0 30\n40 0\n", "50\n"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2016 WF] Polygonal Puzzle", "background": "", "description": "During last year’s ACM ICPC World Finals in Marrakesh, one of the judges bought a pretty wooden puzzle depicting a camel and palm trees (see Figure 1). Unlike traditional jigsaw puzzles, which are usually created by cutting up an existing rectangular picture, all the pieces of this puzzle have been cut and painted separately. As a result, adjacent pieces often do not share common picture elements or colors. Moreover, the resulting picture itself is irregularly shaped. Given these properties, the shape of individual pieces is often the only possible way to tell where each piece should be placed.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ug8atpvc.png)\n\n   Figure 1: The judge’s wooden puzzle. \n\nThe judge has been wondering ever since last year whether it is possible to write a program to solve this puzzle. An important part of such a program is a method to evaluate how well two puzzle pieces “match” each other. The better the match, the more likely it is that those pieces are adjacent in the puzzle.\n\nPieces are modeled as simple polygons. Your task is to find a placement of two given polygons such that their interiors do not overlap but the polygons touch with their boundaries and the length of the common boundary is maximized. For this placement, polygons can be translated and rotated, but not reflected or resized. Figure 2 illustrates the optimal placement for Sample Input 1.\n\n ![](https://cdn.luogu.com.cn/upload/image_hosting/xhl8b2h0.png)\n\n   Figure 2: Sample Input 1 and its optimal placement. ", "inputFormat": "The input contains the description of two polygons, one after the other. Each polygon description starts with a line containing an integer $n$ ($3 \\leq n \\leq 50$) denoting the number of vertices of the polygon. This is followed by $n$ lines, each containing two integer coordinates $x$, $y$ of a polygon vertex ($|x|, |y| \\leq 100$). The vertices of each polygon are given in clockwise order, and no three consecutive vertices are collinear.\n\nThe input data is chosen so that even if the vertices were moved by a distance of up to $10^{-7}$, the answer would not increase by more than $10^{-4}$.", "outputFormat": "Display the maximum possible length of the common boundary of these polygons when they are optimally placed. Your answer should have an absolute or relative error of less than $10^{-3}$.", "hint": "Time limit: 18000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en", "translations": {"en": {"title": "[ICPC 2016 WF] Polygonal Puzzle", "background": "", "description": "During last year’s ACM ICPC World Finals in Marrakesh, one of the judges bought a pretty wooden puzzle depicting a camel and palm trees (see Figure 1). Unlike traditional jigsaw puzzles, which are usually created by cutting up an existing rectangular picture, all the pieces of this puzzle have been cut and painted separately. As a result, adjacent pieces often do not share common picture elements or colors. Moreover, the resulting picture itself is irregularly shaped. Given these properties, the shape of individual pieces is often the only possible way to tell where each piece should be placed.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ug8atpvc.png)\n\n   Figure 1: The judge’s wooden puzzle. \n\nThe judge has been wondering ever since last year whether it is possible to write a program to solve this puzzle. An important part of such a program is a method to evaluate how well two puzzle pieces “match” each other. The better the match, the more likely it is that those pieces are adjacent in the puzzle.\n\nPieces are modeled as simple polygons. Your task is to find a placement of two given polygons such that their interiors do not overlap but the polygons touch with their boundaries and the length of the common boundary is maximized. For this placement, polygons can be translated and rotated, but not reflected or resized. Figure 2 illustrates the optimal placement for Sample Input 1.\n\n ![](https://cdn.luogu.com.cn/upload/image_hosting/xhl8b2h0.png)\n\n   Figure 2: Sample Input 1 and its optimal placement. ", "inputFormat": "The input contains the description of two polygons, one after the other. Each polygon description starts with a line containing an integer $n$ ($3 \\leq n \\leq 50$) denoting the number of vertices of the polygon. This is followed by $n$ lines, each containing two integer coordinates $x$, $y$ of a polygon vertex ($|x|, |y| \\leq 100$). The vertices of each polygon are given in clockwise order, and no three consecutive vertices are collinear.\n\nThe input data is chosen so that even if the vertices were moved by a distance of up to $10^{-7}$, the answer would not increase by more than $10^{-4}$.", "outputFormat": "Display the maximum possible length of the common boundary of these polygons when they are optimally placed. Your answer should have an absolute or relative error of less than $10^{-3}$.", "hint": "Time limit: 18000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en"}, "zh-CN": {"title": "[ICPC 2016 WF] Polygonal Puzzle", "background": null, "description": "有两个多边形，可以平移旋转（但不能对称、缩放等），求这两个多边形贴在一起但不重合的情况下贴贴部分的最大总长度。", "inputFormat": "第一行一个数字 $n_1$，表示第一个多边形是 $n_1$ 边形。\n\n接下来 $n_1$ 行，每行两个数字，表示第一个多边形每个端点的横、纵坐标。\n\n接下来一个数字 $n_2$，表示第二个多边形是 $n_2$ 边形。\n\n最后 $n_2$ 行，每行两个数字，表示第二个多边形每个端点的横、纵坐标。", "outputFormat": "一行，最大的贴贴部分长度，绝对误差或相对误差任一小于 $10^{-3}$ 即可通过。", "hint": "$3 \\leq n_1, n_2 \\leq 50$，横纵坐标均为整数且绝对值不超过 $100$。", "locale": "zh-CN"}}}
{"pid": "P6924", "type": "P", "difficulty": 7, "samples": [["3\n0 50 -1\n55 0 40\n-1 40 0\n1\n0 2 120\n3\n0 1\n1 2\n1 0\n", "0 1 50.0 80.0\n1 2 40.0 70.0\n1 0 55.0 110.0\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2016", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2016 WF] Road Times", "background": "", "description": "5s,1024MB\n\nUbol Narongdid is the founder of a brash new startup company called Special D-Liver-E. She wants to corner the market on overnight deliveries of organs between hospitals in the Phuket area. For scheduling purposes it is important to have accurate estimates for the times to perform such deliveries. Several trips between various hospitals have already been performed, so delivery times between those pairs of hospitals are known. The company currently has software to estimate times for other (as yet untraveled) trips, but so far all the estimates have been woefully inaccurate.\n\nYou have been asked to come up with a method to improve these estimates. You have at your disposal the following information: 1) the length (in kilometers) of the roads connecting each pair of cities in the Phuket area, and 2) a set of times (in minutes) for various previously executed deliveries.\n\nYou know that roads are one-way, and each road has a fixed speed limit that lies between $30$ and $60$ kilometers per hour. Speed limits are real-valued and need not be integers. You also know that delivery trucks always take the route that minimizes distance traveled, and on each road will always travel at a constant speed equal to that road’s speed limit. Thus you know, for example, that if a given trip is $50$ kilometers, the time it will take is between $50$ and $100$ minutes inclusive, in the absence of any other information. Ah, but you do have other information, namely the times of previous deliveries. It is up to you to use it to produce the best possible estimates.", "inputFormat": "The input starts with a line containing an integer $n$ ($1 \\le n \\leq 30$) indicating the number of cities, numbered $0$ to $n-1$. After that are $n$ lines each containing $n$ integers specifying the distance in kilometers between cities: the $j^{\\text {th}}$ value on the $i^{\\text {th}}$ line indicates the distance when traveling directly from city $i$ to city $j$. A value of $-1$ indicates there is no road directly connecting the two cities, and the distance from any city to itself is always $0$; all other distances are positive and at most $1\\, 000$. There are at most $100$ roads.\n\nFollowing this is a line with a single integer $r$ ($1 \\le r \\leq 100$) indicating the number of previously executed routes. The next $r$ lines each contain three integers $s$, $d$, and $t$, where $s$ and $d$ are the source and destination cities and $t$ is how long the delivery from $s$ to $d$ took, in minutes.\n\nFinally there is a line containing a single integer $q$ ($1 \\le q \\leq 100$) indicating the number of future delivery queries. The next $q$ lines each contain two integers $s$ and $d$ giving the source and destination cities for the query.\n\nYou may assume that for each of the $r+q$ source/destination pairs in the input there is a unique minimum-distance route.", "outputFormat": "Display a single line for each query containing the source and destination cities for that query, followed by the best low and high bounds on the estimate for the travel time, accurate to within an absolute or relative error of $10^{-6}$.", "hint": "Time limit: 5000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en", "translations": {"en": {"title": "[ICPC 2016 WF] Road Times", "background": "", "description": "5s,1024MB\n\nUbol Narongdid is the founder of a brash new startup company called Special D-Liver-E. She wants to corner the market on overnight deliveries of organs between hospitals in the Phuket area. For scheduling purposes it is important to have accurate estimates for the times to perform such deliveries. Several trips between various hospitals have already been performed, so delivery times between those pairs of hospitals are known. The company currently has software to estimate times for other (as yet untraveled) trips, but so far all the estimates have been woefully inaccurate.\n\nYou have been asked to come up with a method to improve these estimates. You have at your disposal the following information: 1) the length (in kilometers) of the roads connecting each pair of cities in the Phuket area, and 2) a set of times (in minutes) for various previously executed deliveries.\n\nYou know that roads are one-way, and each road has a fixed speed limit that lies between $30$ and $60$ kilometers per hour. Speed limits are real-valued and need not be integers. You also know that delivery trucks always take the route that minimizes distance traveled, and on each road will always travel at a constant speed equal to that road’s speed limit. Thus you know, for example, that if a given trip is $50$ kilometers, the time it will take is between $50$ and $100$ minutes inclusive, in the absence of any other information. Ah, but you do have other information, namely the times of previous deliveries. It is up to you to use it to produce the best possible estimates.", "inputFormat": "The input starts with a line containing an integer $n$ ($1 \\le n \\leq 30$) indicating the number of cities, numbered $0$ to $n-1$. After that are $n$ lines each containing $n$ integers specifying the distance in kilometers between cities: the $j^{\\text {th}}$ value on the $i^{\\text {th}}$ line indicates the distance when traveling directly from city $i$ to city $j$. A value of $-1$ indicates there is no road directly connecting the two cities, and the distance from any city to itself is always $0$; all other distances are positive and at most $1\\, 000$. There are at most $100$ roads.\n\nFollowing this is a line with a single integer $r$ ($1 \\le r \\leq 100$) indicating the number of previously executed routes. The next $r$ lines each contain three integers $s$, $d$, and $t$, where $s$ and $d$ are the source and destination cities and $t$ is how long the delivery from $s$ to $d$ took, in minutes.\n\nFinally there is a line containing a single integer $q$ ($1 \\le q \\leq 100$) indicating the number of future delivery queries. The next $q$ lines each contain two integers $s$ and $d$ giving the source and destination cities for the query.\n\nYou may assume that for each of the $r+q$ source/destination pairs in the input there is a unique minimum-distance route.", "outputFormat": "Display a single line for each query containing the source and destination cities for that query, followed by the best low and high bounds on the estimate for the travel time, accurate to within an absolute or relative error of $10^{-6}$.", "hint": "Time limit: 5000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en"}, "zh-CN": {"title": "[ICPC 2016 WF] Road Times", "background": "", "description": "5 秒，1024 MB\n\nUbol Narongdid 是一家名为 Special D-Liver-E 的新兴初创公司的创始人。她想要垄断普吉岛地区医院之间的器官隔夜递送市场。为了安排计划，准确估计执行这些递送所需的时间非常重要。已经在一些医院之间进行了多次递送，因此这些医院对之间的递送时间是已知的。公司目前有软件来估计其他（尚未旅行过的）行程的时间，但到目前为止，所有的估计都非常不准确。\n\n你被要求提出一种方法来改善这些估计。你可以使用以下信息：1）普吉岛地区每对城市之间连接道路的长度（以公里为单位），以及 2）一组先前执行的各种递送的时间（以分钟为单位）。\n\n你知道道路是单向的，每条道路都有一个固定的速度限制，介于 $30$ 到 $60$ 公里每小时之间。速度限制是实数，不必是整数。你还知道递送卡车总是选择最小化行驶距离的路线，并且在每条道路上总是以等于该道路速度限制的恒定速度行驶。因此，例如，如果某次旅行是 $50$ 公里，所需时间在 $50$ 到 $100$ 分钟之间（包括边界），在没有其他信息的情况下。但你确实有其他信息，即先前递送的时间。你需要利用这些信息来产生尽可能好的估计。", "inputFormat": "输入以一行包含一个整数 $n$ ($1 \\le n \\leq 30$) 开始，表示城市的数量，编号为 $0$ 到 $n-1$。之后是 $n$ 行，每行包含 $n$ 个整数，指定城市之间的距离（以公里为单位）：第 $i$ 行的第 $j$ 个值表示从城市 $i$ 直接到城市 $j$ 的距离。当两个城市之间没有直接连接的道路时，值为 $-1$，从任何城市到自身的距离总是 $0$；所有其他距离为正数且最多为 $1\\, 000$。最多有 $100$ 条道路。\n\n接下来是一行包含一个整数 $r$ ($1 \\le r \\leq 100$)，表示先前执行的路线数量。接下来的 $r$ 行每行包含三个整数 $s$、$d$ 和 $t$，其中 $s$ 和 $d$ 是起始和目的城市，$t$ 是从 $s$ 到 $d$ 的递送所花费的时间，以分钟为单位。\n\n最后是一行包含一个整数 $q$ ($1 \\le q \\leq 100$)，表示未来递送查询的数量。接下来的 $q$ 行每行包含两个整数 $s$ 和 $d$，给出查询的起始和目的城市。\n\n你可以假设输入中的每对 $r+q$ 起始/目的地对都有唯一的最小距离路线。", "outputFormat": "对于每个查询，显示一行，包含该查询的起始和目的城市，后跟对旅行时间估计的最佳低和高界限，精确到绝对或相对误差为 $10^{-6}$。", "hint": "时间限制：5000 毫秒，内存限制：1048576 kB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2016。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6925", "type": "P", "difficulty": 7, "samples": [["6\n0 10 0\n10 0 1\n12 8 1\n5 5 0\n11 2 1\n11 3 0\n", "4\n"], ["10\n6 1 1\n0 2 0\n2 1 1\n6 1 1\n8 2 0\n4 4 0\n4 0 0\n2 3 1\n6 1 0\n6 3 1\n", "8\n"], ["5\n5 7 0\n3 4 0\n5 7 0\n5 7 1\n9 4 0\n", "1\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2016", "ICPC", "WF"], "title": "[ICPC 2016 WF] Spin Doctor", "background": "", "description": "As an employee of the world’s most respected political polling corporation, you must take complex, real-world issues and simplify them down to a few numbers. It isn’t always easy. A big election is coming up and, at the request of Candidate X, you have just finished polling $n$ people. You have gathered three pieces of information from each person, with the values for the $i^\\text {th}$ person recorded as:\n\n$a_ i$ – the number of digits of $\\pi $ they have memorized\n\n$b_ i$ – the number of hairs on their head\n\n$c_ i$ – whether they will vote for Candidate X\n\nUnfortunately, you are beginning to wonder if these are really the most relevant questions to ask. In fact, you cannot see any correlation between $a$, $b$, and $c$ in the data. Of course, you cannot just contradict your customer – that is a good way to lose your job!\n\nPerhaps the answer is to find some weighting formula to make the results look meaningful. You will pick two real values $S$ and $T$, and sort the poll results $(a_ i, b_ i, c_ i)$ by the measure $a_ i \\cdot S + b_ i \\cdot T$. The sort will look best if the results having $c_ i$ true are clustered as close to each other as possible. More precisely, if $j$ and $k$ are the indices of the first and last results with $c_ i$ true, you want to minimize the cluster size which is $k-j+1$. Note that some choices of $S$ and $T$ will result in ties among the $(a_ i,b_ i,c_ i)$ triples. When this happens, you should assume the worst possible ordering occurs (that which maximizes the cluster size for this $(S, T)$ pair).", "inputFormat": "The input starts with a line containing $n$ ($1 \\leq n \\leq 250\\, 000$), which is the number of people polled. This is followed by one line for each person polled. Each of those lines contains integers $a_ i$ ($0 \\leq a_ i \\leq 2\\, 000\\, 000$), $b_ i$ ($0 \\leq b_ i \\leq 2\\, 000\\, 000$), and $c_ i$, where $c_ i$ is $1$ if the person will vote for Candidate X and $0$ otherwise. The input is guaranteed to contain at least one person who will vote for Candidate X.", "outputFormat": "Display the smallest possible cluster size over all possible $(S, T)$ pairs.", "hint": "Time limit: 5000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en", "translations": {"en": {"title": "[ICPC 2016 WF] Spin Doctor", "background": "", "description": "As an employee of the world’s most respected political polling corporation, you must take complex, real-world issues and simplify them down to a few numbers. It isn’t always easy. A big election is coming up and, at the request of Candidate X, you have just finished polling $n$ people. You have gathered three pieces of information from each person, with the values for the $i^\\text {th}$ person recorded as:\n\n$a_ i$ – the number of digits of $\\pi $ they have memorized\n\n$b_ i$ – the number of hairs on their head\n\n$c_ i$ – whether they will vote for Candidate X\n\nUnfortunately, you are beginning to wonder if these are really the most relevant questions to ask. In fact, you cannot see any correlation between $a$, $b$, and $c$ in the data. Of course, you cannot just contradict your customer – that is a good way to lose your job!\n\nPerhaps the answer is to find some weighting formula to make the results look meaningful. You will pick two real values $S$ and $T$, and sort the poll results $(a_ i, b_ i, c_ i)$ by the measure $a_ i \\cdot S + b_ i \\cdot T$. The sort will look best if the results having $c_ i$ true are clustered as close to each other as possible. More precisely, if $j$ and $k$ are the indices of the first and last results with $c_ i$ true, you want to minimize the cluster size which is $k-j+1$. Note that some choices of $S$ and $T$ will result in ties among the $(a_ i,b_ i,c_ i)$ triples. When this happens, you should assume the worst possible ordering occurs (that which maximizes the cluster size for this $(S, T)$ pair).", "inputFormat": "The input starts with a line containing $n$ ($1 \\leq n \\leq 250\\, 000$), which is the number of people polled. This is followed by one line for each person polled. Each of those lines contains integers $a_ i$ ($0 \\leq a_ i \\leq 2\\, 000\\, 000$), $b_ i$ ($0 \\leq b_ i \\leq 2\\, 000\\, 000$), and $c_ i$, where $c_ i$ is $1$ if the person will vote for Candidate X and $0$ otherwise. The input is guaranteed to contain at least one person who will vote for Candidate X.", "outputFormat": "Display the smallest possible cluster size over all possible $(S, T)$ pairs.", "hint": "Time limit: 5000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en"}, "zh-CN": {"title": "[ICPC 2016 WF] Spin Doctor", "background": "", "description": "作为世界上最受尊敬的政治民意调查公司的员工，你必须将复杂的现实问题简化为几个数字。这并不总是容易的。一场重要的选举即将到来，应候选人 X 的要求，你刚刚完成了对 $n$ 人的民意调查。你从每个人那里收集了三条信息，第 $i$ 个人的信息记录为：\n\n$a_i$ —— 他们记住的 $\\pi$ 的位数\n\n$b_i$ —— 他们头上的头发数量\n\n$c_i$ —— 他们是否会投票给候选人 X\n\n不幸的是，你开始怀疑这些问题是否真的最相关。事实上，你在数据中看不到 $a$、$b$ 和 $c$ 之间的任何相关性。当然，你不能直接反驳你的客户——那是丢掉工作的好方法！\n\n也许答案是找到某种加权公式，使结果看起来有意义。你将选择两个实数 $S$ 和 $T$，并按测量值 $a_i \\cdot S + b_i \\cdot T$ 对民意调查结果 $(a_i, b_i, c_i)$ 进行排序。如果结果中 $c_i$ 为真的部分尽可能接近在一起，排序看起来会最好。更准确地说，如果 $j$ 和 $k$ 是 $c_i$ 为真的第一个和最后一个结果的索引，你希望最小化簇大小，即 $k-j+1$。注意，某些 $S$ 和 $T$ 的选择会导致 $(a_i, b_i, c_i)$ 三元组之间的平局。当这种情况发生时，你应该假设发生了最糟糕的排序（即最大化该 $(S, T)$ 对的簇大小）。", "inputFormat": "输入以一行开始，包含 $n$ ($1 \\leq n \\leq 250,000$)，即调查的人数。接下来是每个被调查者的一行。每行包含整数 $a_i$ ($0 \\leq a_i \\leq 2,000,000$)、$b_i$ ($0 \\leq b_i \\leq 2,000,000$) 和 $c_i$，其中 $c_i$ 为 $1$ 表示该人将投票给候选人 X，否则为 $0$。输入保证至少有一个人会投票给候选人 X。", "outputFormat": "输出所有可能的 $(S, T)$ 对中最小的簇大小。", "hint": "时间限制：5000 毫秒，内存限制：1048576 kB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2016。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6926", "type": "P", "difficulty": 5, "samples": [["5\n2 1 1 1 3\n", "2\n"], ["1\n22\n", "4\n"], ["1\n1\n", "no quotation\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "ICPC", "WF"], "title": "[ICPC 2016 WF] String Theory", "background": "", "description": "Nested quotations are great not only for writing literature with a complex narrative structure, but also in programming languages. While it may seem necessary to use different quotation marks at different nesting levels for clarity, there is an alternative. We can display various nesting levels using $k$-quotations, which are defined as follows.\n\nA $1$-quotation is a string that begins with a quote character, ends with another quote character and contains no quote characters in-between. These are just the usual (unnested) quotations. For example, 'this is a string' is a $1$-quotation.\n\nFor $k > 1$, a $k$-quotation is a string that begins with $k$ quote characters, ends with another $k$ quote characters and contains a nested string in-between. The nested string is a non-empty sequence of $(k-1)$-quotations, which may be preceded, separated, and/or succeeded by any number of non-quote characters. For example, ''All 'work' and no 'play''' is a $2$-quotation.\n\nGiven a description of a string, you must determine its maximum possible nesting level.", "inputFormat": "The input consists of two lines. The first line contains an integer $n$ ($1 \\le n \\le 100$). The second line contains $n$ integers $a_1, a_2, \\ldots , a_ n$ ($1 \\le a_ i \\le 100$), which describe a string as follows. The string starts with $a_1$ quote characters, which are followed by a positive number of non-quote characters, which are followed by $a_2$ quote characters, which are followed by a positive number of non-quote characters, and so on, until the string ends with $a_ n$ quote characters.", "outputFormat": "Display the largest number $k$ such that a string described by the input is a $k$-quotation. If there is no such $k$, display no quotation instead.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en", "translations": {"en": {"title": "[ICPC 2016 WF] String Theory", "background": "", "description": "Nested quotations are great not only for writing literature with a complex narrative structure, but also in programming languages. While it may seem necessary to use different quotation marks at different nesting levels for clarity, there is an alternative. We can display various nesting levels using $k$-quotations, which are defined as follows.\n\nA $1$-quotation is a string that begins with a quote character, ends with another quote character and contains no quote characters in-between. These are just the usual (unnested) quotations. For example, 'this is a string' is a $1$-quotation.\n\nFor $k > 1$, a $k$-quotation is a string that begins with $k$ quote characters, ends with another $k$ quote characters and contains a nested string in-between. The nested string is a non-empty sequence of $(k-1)$-quotations, which may be preceded, separated, and/or succeeded by any number of non-quote characters. For example, ''All 'work' and no 'play''' is a $2$-quotation.\n\nGiven a description of a string, you must determine its maximum possible nesting level.", "inputFormat": "The input consists of two lines. The first line contains an integer $n$ ($1 \\le n \\le 100$). The second line contains $n$ integers $a_1, a_2, \\ldots , a_ n$ ($1 \\le a_ i \\le 100$), which describe a string as follows. The string starts with $a_1$ quote characters, which are followed by a positive number of non-quote characters, which are followed by $a_2$ quote characters, which are followed by a positive number of non-quote characters, and so on, until the string ends with $a_ n$ quote characters.", "outputFormat": "Display the largest number $k$ such that a string described by the input is a $k$-quotation. If there is no such $k$, display no quotation instead.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en"}, "zh-CN": {"title": "[ICPC 2016 WF] String Theory", "background": "", "description": "嵌套引号不仅在写作具有复杂叙述结构的文学作品时很有用，在编程语言中也是如此。虽然在不同的嵌套层次使用不同的引号似乎是必要的，但还有一种替代方法。我们可以使用 $k$-引号来表示各种嵌套层次，其定义如下。\n\n一个 $1$-引号是一个以引号字符开始，以另一个引号字符结束且中间不包含引号字符的字符串。这只是通常的（未嵌套的）引号。例如，'this is a string' 是一个 $1$-引号。\n\n对于 $k > 1$，一个 $k$-引号是一个以 $k$ 个引号字符开始，以另一个 $k$ 个引号字符结束且中间包含一个嵌套字符串的字符串。嵌套字符串是一个非空的 $(k-1)$-引号序列，可以在前、后或中间被任意数量的非引号字符分隔。例如，''All 'work' and no 'play''' 是一个 $2$-引号。\n\n给定一个字符串的描述，你必须确定其最大可能的嵌套层次。", "inputFormat": "输入由两行组成。第一行包含一个整数 $n$ ($1 \\le n \\le 100$)。第二行包含 $n$ 个整数 $a_1, a_2, \\ldots , a_n$ ($1 \\le a_i \\le 100$)，描述一个字符串如下。字符串以 $a_1$ 个引号字符开始，后跟一个正数个非引号字符，接着是 $a_2$ 个引号字符，再跟一个正数个非引号字符，依此类推，直到字符串以 $a_n$ 个引号字符结束。", "outputFormat": "输出一个最大的数字 $k$，使得输入描述的字符串是一个 $k$-引号。如果没有这样的 $k$，则输出 no quotation。", "hint": "时间限制：2000 毫秒，内存限制：1048576 kB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2016。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6927", "type": "P", "difficulty": 5, "samples": [["4\n6 6\n1 7\n3 5\n3 5\n", "1\n"], ["4\n2 2\n3 3\n5 1\n5 10\n", "5\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2016", "排序", "ICPC", "WF"], "title": "[ICPC 2016 WF] Swap Space", "background": "", "description": "You administer a large cluster of computers with hard drives that use various file system types to store data. You recently decided to unify the file systems to the same type. That is quite a challenge since all the drives are currently in use, all of them are filled with important data to the limits of their capacities, and you cannot afford to lose any of the data. Moreover, reformatting a drive to use a new file system may significantly change the drive’s capacity. To make the reformat possible, you will have to buy an extra hard drive. Obviously, you want to save money by minimizing the size of such extra storage.\n\nYou can reformat the drives in any order. Prior to reformatting a drive, you must move all data from that drive to one or more other drives, splitting the data if necessary. After a drive is reformatted, you can immediately start using it to store data from other drives. It is not necessary to put all the data on the same drives they originally started on – in fact, this might even be impossible if some of the drives have smaller capacity with the new file system. It is also allowed for some data to end up on the extra drive.\n\nAs an example, suppose you have four drives $A$, $B$, $C$, and $D$ with drive capacities $6$, $1$, $3$, and $3$ GB. Under the new file system, the capacities become $6$, $7$, $5$, and $5$ GB, respectively. If you buy only $1$ GB of extra space, you can move the data from drive $B$ there and then reformat drive $B$. Now you have $7$ GB free on drive $B$, so you can move the $6$ GB from drive $A$ there and reformat drive $A$. Finally, you move the six total gigabytes from drives $C$ and $D$ to drive $A$, and reformat $C$ and $D$.", "inputFormat": "The input begins with a line containing one integer $n$ ($1 \\le n \\le 10^6$), which is the number of drives in your cluster. Following this are $n$ lines, each describing a drive as two integers $a$ and $b$, where $a$ is the capacity with the old file system and $b$ is the capacity with the new file system.\n\nAll capacities are given in gigabytes and satisfy $1 \\le a,b \\le 10^9$. (One thousand petabytes should be enough for everyone, right?)", "outputFormat": "Display the total extra capacity in gigabytes you must buy to reformat the drives.", "hint": "Time limit: 5000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en", "translations": {"en": {"title": "[ICPC 2016 WF] Swap Space", "background": "", "description": "You administer a large cluster of computers with hard drives that use various file system types to store data. You recently decided to unify the file systems to the same type. That is quite a challenge since all the drives are currently in use, all of them are filled with important data to the limits of their capacities, and you cannot afford to lose any of the data. Moreover, reformatting a drive to use a new file system may significantly change the drive’s capacity. To make the reformat possible, you will have to buy an extra hard drive. Obviously, you want to save money by minimizing the size of such extra storage.\n\nYou can reformat the drives in any order. Prior to reformatting a drive, you must move all data from that drive to one or more other drives, splitting the data if necessary. After a drive is reformatted, you can immediately start using it to store data from other drives. It is not necessary to put all the data on the same drives they originally started on – in fact, this might even be impossible if some of the drives have smaller capacity with the new file system. It is also allowed for some data to end up on the extra drive.\n\nAs an example, suppose you have four drives $A$, $B$, $C$, and $D$ with drive capacities $6$, $1$, $3$, and $3$ GB. Under the new file system, the capacities become $6$, $7$, $5$, and $5$ GB, respectively. If you buy only $1$ GB of extra space, you can move the data from drive $B$ there and then reformat drive $B$. Now you have $7$ GB free on drive $B$, so you can move the $6$ GB from drive $A$ there and reformat drive $A$. Finally, you move the six total gigabytes from drives $C$ and $D$ to drive $A$, and reformat $C$ and $D$.", "inputFormat": "The input begins with a line containing one integer $n$ ($1 \\le n \\le 10^6$), which is the number of drives in your cluster. Following this are $n$ lines, each describing a drive as two integers $a$ and $b$, where $a$ is the capacity with the old file system and $b$ is the capacity with the new file system.\n\nAll capacities are given in gigabytes and satisfy $1 \\le a,b \\le 10^9$. (One thousand petabytes should be enough for everyone, right?)", "outputFormat": "Display the total extra capacity in gigabytes you must buy to reformat the drives.", "hint": "Time limit: 5000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en"}, "zh-CN": {"title": "[ICPC 2016 WF] Swap Space", "background": "", "description": "你有许多电脑，它们的硬盘用不同的文件系统储存数据。你想要通过格式化来统一文件系统。格式化硬盘可能使它的容量发生变化。为了格式化，你需要买额外的硬盘。当然，你想要买容量最小的额外储存设备以便省钱。你可以按任意顺序格式化硬盘。格式化之前，你要把该硬盘上所有数据移到一个或更多的其他硬盘上（可以分割数据）。格式化后，该硬盘可以立刻开始使用。你没有必要把数据放到它原来所在的硬盘上。数据也可以被放到你额外买的硬盘上。举个例子，假设你有4个硬盘A、B、C、D，容量分别为6、1、3、3(GB)。新的文件系统下，它们的容量变为6、7、5、5(GB)。如果你只买1GB额外空间，你可以把B硬盘的数据放过去然后格式化硬盘B。现在你的B硬盘有7GB容量了，那么你就可以把A的数据放过去然后格式化A，最后把C、D的数据放到A上，再格式化C和D。", "inputFormat": "第一行一个数 $n(1≤n≤1,000,000)$，表示你的硬盘数。接下来 $n$ 行，每行两个数 $a$ 和 $b$，分别表示该硬盘的原容量和新文件系统下的容量。所有容量都以 GB 为单位，且$1≤a,b≤1,000,000,000$。", "outputFormat": "输出如果要格式化所有硬盘，你最少需要购买多少额外空间(GB)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6928", "type": "P", "difficulty": 6, "samples": [["3 1\n50 2 5 C1 L1 C1 U1 C1\n1 1 5 C1 L1 C100 U1 C1\n70 3 1 C1\n", "106\n107\n71\n"], ["3 3\n5 3 5 C1 L1 C1 U1 C1\n3 2 9 C1 L2 C1 L3 C1 U3 C1 U2 C1\n1 1 9 C1 L3 C3 L2 C1 U2 C1 U3 C1\n", "8\n15\n16\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2016", "ICPC", "WF"], "title": "[ICPC 2016 WF] What Really Happened on Mars?", "background": "", "description": "Real-time software in the Mars Pathfinder spacecraft suffered from an issue known as priority inversion. One technique to address this issue is to use the Priority Ceiling Protocol.\n\nIn this problem, you will simulate the execution of multiple tasks according to this protocol. The tasks share a collection of resources, each of which can be used by only one task at a time. To ensure this, resources must be locked before use and unlocked after use. Each task is defined by a start time, a unique base priority, and a sequence of instructions. Each task also has a current priority, which may change during execution. Instructions come in three types:\n\ncompute – perform a computation for one microsecond\n\nlock $k$ – lock resource $k$ (which takes no processor time)\n\nunlock $k$ – unlock resource $k$ (which takes no processor time)\n\nAfter locking a resource, a task is said to own the resource until the task unlocks it. A task will unlock only the owned resource it most recently locked, will not lock a resource it already owns, and will complete with no owned resources.\n\nEach resource has a fixed priority ceiling, which is the highest base priority of any task that contains an instruction to lock that resource.\n\nThere is a single processor that executes the tasks. When the processor starts, it initializes its clock to zero and then runs an infinite loop with the following steps:\n\n  Step 1.\n\nIdentify running tasks. A task is running if its start time is less than or equal to the current processor clock and not all of its instructions have been executed.\n\n  Step 2.\n\nDetermine the current priorities of the running tasks and which of the running tasks are blocked. A running task $T$ is blocked if the next instruction in $T$ is to lock resource $k$ and either resource $k$ is already owned or at least one other task owns a resource $\\ell $ whose priority ceiling is greater than or equal to the current priority of $T$. If $T$ is blocked, it is said to be blocked by every task owning such $k$ or $\\ell $. The current priority of a task $T$ is the maximum of $T$’s base priority and the current priorities of all tasks that $T$ blocks.\n\n  Step 3.\n\nExecute the next instruction of the non-blocked running task (if any) with the highest current priority. If there was no such task or if a compute instruction was executed, increment the processor clock by one microsecond. If a lock or unlock instruction was executed, do not increment the clock.\n\nThe Priority Ceiling Protocol defined above has the following properties:\n\nCurrent priority is defined in terms of current priority and blocking, and blocking is defined in terms of current priority. While this may appear circular, there will always be a unique set of current priorities that satisfy the definitions.\n\nAll tasks will eventually complete.\n\nThere will never be a tie in step 3.", "inputFormat": "The first line of the input contains two integers $t$ $(1 \\leq t \\leq 20)$, which is the number of tasks, and $r$ ($1 \\leq r \\leq 20$), which is the number of resources. This is followed by $t$ lines, where the $i^\\text {th}$ of these lines describes task $i$. The description of a task begins with three integers: the task’s start time $s$ ($1 \\leq s \\leq 10\\, 000$), its base priority $b$ ($1 \\leq b \\leq t$), and an integer $a$ ($1 \\leq a \\leq 100$). A task description is concluded by a sequence of $a$ strings describing the instructions. Each string is a letter (C or L or U) followed by an integer. The string C$n$ ($1 \\leq n \\leq 100$) indicates a sequence of $n$ compute instructions. The strings L$k$ and U$k$ ($1 \\leq k \\leq r$) indicate instructions locking and unlocking resource $k$ respectively.\n\nNo two tasks have the same base priority.", "outputFormat": "For each task, display the time it completes execution, in the same order that the tasks are given in the input.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en", "translations": {"en": {"title": "[ICPC 2016 WF] What Really Happened on Mars?", "background": "", "description": "Real-time software in the Mars Pathfinder spacecraft suffered from an issue known as priority inversion. One technique to address this issue is to use the Priority Ceiling Protocol.\n\nIn this problem, you will simulate the execution of multiple tasks according to this protocol. The tasks share a collection of resources, each of which can be used by only one task at a time. To ensure this, resources must be locked before use and unlocked after use. Each task is defined by a start time, a unique base priority, and a sequence of instructions. Each task also has a current priority, which may change during execution. Instructions come in three types:\n\ncompute – perform a computation for one microsecond\n\nlock $k$ – lock resource $k$ (which takes no processor time)\n\nunlock $k$ – unlock resource $k$ (which takes no processor time)\n\nAfter locking a resource, a task is said to own the resource until the task unlocks it. A task will unlock only the owned resource it most recently locked, will not lock a resource it already owns, and will complete with no owned resources.\n\nEach resource has a fixed priority ceiling, which is the highest base priority of any task that contains an instruction to lock that resource.\n\nThere is a single processor that executes the tasks. When the processor starts, it initializes its clock to zero and then runs an infinite loop with the following steps:\n\n  Step 1.\n\nIdentify running tasks. A task is running if its start time is less than or equal to the current processor clock and not all of its instructions have been executed.\n\n  Step 2.\n\nDetermine the current priorities of the running tasks and which of the running tasks are blocked. A running task $T$ is blocked if the next instruction in $T$ is to lock resource $k$ and either resource $k$ is already owned or at least one other task owns a resource $\\ell $ whose priority ceiling is greater than or equal to the current priority of $T$. If $T$ is blocked, it is said to be blocked by every task owning such $k$ or $\\ell $. The current priority of a task $T$ is the maximum of $T$’s base priority and the current priorities of all tasks that $T$ blocks.\n\n  Step 3.\n\nExecute the next instruction of the non-blocked running task (if any) with the highest current priority. If there was no such task or if a compute instruction was executed, increment the processor clock by one microsecond. If a lock or unlock instruction was executed, do not increment the clock.\n\nThe Priority Ceiling Protocol defined above has the following properties:\n\nCurrent priority is defined in terms of current priority and blocking, and blocking is defined in terms of current priority. While this may appear circular, there will always be a unique set of current priorities that satisfy the definitions.\n\nAll tasks will eventually complete.\n\nThere will never be a tie in step 3.", "inputFormat": "The first line of the input contains two integers $t$ $(1 \\leq t \\leq 20)$, which is the number of tasks, and $r$ ($1 \\leq r \\leq 20$), which is the number of resources. This is followed by $t$ lines, where the $i^\\text {th}$ of these lines describes task $i$. The description of a task begins with three integers: the task’s start time $s$ ($1 \\leq s \\leq 10\\, 000$), its base priority $b$ ($1 \\leq b \\leq t$), and an integer $a$ ($1 \\leq a \\leq 100$). A task description is concluded by a sequence of $a$ strings describing the instructions. Each string is a letter (C or L or U) followed by an integer. The string C$n$ ($1 \\leq n \\leq 100$) indicates a sequence of $n$ compute instructions. The strings L$k$ and U$k$ ($1 \\leq k \\leq r$) indicate instructions locking and unlocking resource $k$ respectively.\n\nNo two tasks have the same base priority.", "outputFormat": "For each task, display the time it completes execution, in the same order that the tasks are given in the input.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016", "locale": "en"}, "zh-CN": {"title": "[ICPC 2016 WF] What Really Happened on Mars?", "background": null, "description": "你有 $t$ 个进程和 $r$ 个资源，每个进程包含其起始时间与**基础优先级**（保证两两不同），以及若干条指令。指令有以下三种：\n\n- `compute`：进行计算，消耗 $1$ 微秒。\n- `lock k`：锁定编号为 $k$ 的资源，不耗时。\n- `unlock k`：解锁编号为 $k$ 的资源，不耗时。\n\n在进程锁定资源后，这个进程就拥有了这个资源直到这个进程将它解锁。保证任意进程只会解锁最近锁定的资源，不会锁定自身拥有的资源，且在进程结束时不会拥有任何资源。\n\n每个资源有一个固定的属性**最高优先级**，即包含锁定该资源指令的所有进程的最高**基础优先级**。\n\n有一个处理器处理这些进程。处理器有一个时钟初始为 $0$，然后重复执行下列步骤：\n\n1. 找出所有正在运行的进程。如果进程开始的时间不大于处理器的时钟且该进程的指令未运行完毕，那么称这个进程正在运行。\n\n2. 决定当前所有正在运行的进程的优先级，以及哪些正在运行的进程会被阻塞。进程 $T$ 会被阻塞当且仅当：\n\n   - 进程 $T$ 的下一条指令是锁定资源 $k$。\n   - 资源 $k$ 已经被其他进程拥有，或存在另一个进程拥有某个资源 $\\ell$，$\\ell$ 的**最高优先级**大于等于 $T$ 的**当前优先级**。\n\n   此时我们称进程 $T$ 被所有拥有资源 $k$ 或满足条件的资源 $\\ell$ 的进程阻塞。定义 $T$ 的**当前优先级**为所有它阻塞的进程的**当前优先级**与它本身的**基础优先级**的最大值。\n\n3. 执行**当前优先级**最高且没有被阻塞的进程的下一条指令。如果不存在这样的进程或者执行的指令是 `compute`，则将时钟加 $1$ 微秒。\n\n你需要求所有进程的结束时间。可以证明所有进程一定会结束。", "inputFormat": "第一行两个整数 $t,r$ 表示进程和资源个数。\n\n接下来 $t$ 行每行描述一个进程，格式如下：\n\n- 三个整数 $s,b,a$，表示进程起始时间、基础优先级、指令条数。\n- 接下来 $a$ 个字符串，每个字符串表示一条指令。字符串形如 `Cn` 表示连续 $n$ 个 `compute` 指令（**相互独立**），`Lk` 表示锁定资源 $k$，`Rk` 表示解锁资源 `k`。", "outputFormat": "$t$ 行每行一个整数表示进程执行完毕的时间。\n\n数据范围：$1 \\le t,r \\le 20,s \\le 10^4,1 \\le b \\le t$ 且互不相同，$a \\le 100$，`Cn` 中 $n \\le 100$，`Lk,Rk` 中 $1 \\le k \\le r$。\n\nTranslated by pokefunc (uid=188716)", "hint": null, "locale": "zh-CN"}}}
{"pid": "P6929", "type": "P", "difficulty": 6, "samples": [["7\n0 20\n40 0\n40 20\n70 50\n50 70\n30 50\n0 50\n", "76.157731059\n"], ["3\n0 2017\n-2017 -2017\n2017 0\n", "4510.149110617\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["计算几何", "2017", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2017 WF] Airport Construction", "background": "", "description": "\n\nThe tropical island nation of Piconesia is famous for its beautiful beaches, lush vegetation, cocoa and coffee plantations, and wonderful weather all year round. This paradise is being considered as a future location for the World Finals of the ACM International Collegiate Programming Contest (or at the very least a vacation spot for the executive council). There is only one small problem: the island is really hard to reach.\n\nCurrently, the fastest way to reach the island takes three days from the nearest airport, and uses a combination of fishing boat, oil tanker, kayak, and submarine. To make attending the ICPC World Finals slightly easier and to jump-start the island's tourism business, Piconesia is planning to build its first airport.\n\nSince longer landing strips can accommodate larger airplanes, Piconesia has decided to build the longest possible landing strip on their island. Unfortunately, they have been unable to determine where this landing strip should be located. Maybe you can help?\n\nFor this problem we model the boundary of Piconesia as a polygon. Given this polygon, you need to compute the length of the longest landing strip (i.e., straight line segment) that can be built on the island. The landing strip must not intersect the sea, but it may touch or run along the boundary of the island. Figure A.1 shows an example corresponding to the first sample input.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14633/1.png)\n\nFigure A.1 : The island modeled as a polygon. The longest possible landing strip is shown as a thick line.\n\n", "inputFormat": "\n\nThe input starts with a line containing an integer $n (3 \\le n \\le 200)$ specifying the number of vertices of the polygon. This is followed by $n$ lines, each containing two integers $x$ and $y (|x|, |y| \\le 10^{6})$ that give the coordinates $(x , y)$ of the vertices of the polygon in counter-clockwise order. The polygon is simple, i.e., its vertices are distinct and no two edges of the polygon intersect or touch, except that consecutive edges touch at their common vertex. In addition, no two consecutive edges are collinear.\n\n", "outputFormat": "\n\nDisplay the length of the longest straight line segment that fits inside the polygon, with an absolute or relative error of at most $10^{−6}.$\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[ICPC 2017 WF] Airport Construction", "background": "", "description": "\n\nThe tropical island nation of Piconesia is famous for its beautiful beaches, lush vegetation, cocoa and coffee plantations, and wonderful weather all year round. This paradise is being considered as a future location for the World Finals of the ACM International Collegiate Programming Contest (or at the very least a vacation spot for the executive council). There is only one small problem: the island is really hard to reach.\n\nCurrently, the fastest way to reach the island takes three days from the nearest airport, and uses a combination of fishing boat, oil tanker, kayak, and submarine. To make attending the ICPC World Finals slightly easier and to jump-start the island's tourism business, Piconesia is planning to build its first airport.\n\nSince longer landing strips can accommodate larger airplanes, Piconesia has decided to build the longest possible landing strip on their island. Unfortunately, they have been unable to determine where this landing strip should be located. Maybe you can help?\n\nFor this problem we model the boundary of Piconesia as a polygon. Given this polygon, you need to compute the length of the longest landing strip (i.e., straight line segment) that can be built on the island. The landing strip must not intersect the sea, but it may touch or run along the boundary of the island. Figure A.1 shows an example corresponding to the first sample input.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14633/1.png)\n\nFigure A.1 : The island modeled as a polygon. The longest possible landing strip is shown as a thick line.\n\n", "inputFormat": "\n\nThe input starts with a line containing an integer $n (3 \\le n \\le 200)$ specifying the number of vertices of the polygon. This is followed by $n$ lines, each containing two integers $x$ and $y (|x|, |y| \\le 10^{6})$ that give the coordinates $(x , y)$ of the vertices of the polygon in counter-clockwise order. The polygon is simple, i.e., its vertices are distinct and no two edges of the polygon intersect or touch, except that consecutive edges touch at their common vertex. In addition, no two consecutive edges are collinear.\n\n", "outputFormat": "\n\nDisplay the length of the longest straight line segment that fits inside the polygon, with an absolute or relative error of at most $10^{−6}.$\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[ICPC 2017 WF] Airport Construction", "background": "", "description": "热带岛国 Piconesia 以其美丽的海滩、郁郁葱葱的植被、可可和咖啡种植园以及全年宜人的天气而闻名。这个天堂般的地方正被考虑作为 ACM 国际大学生程序设计竞赛（ICPC）世界总决赛的未来举办地（或者至少是执行委员会的度假胜地）。只有一个小问题：这个岛屿真的很难到达。\n\n目前，最快到达该岛的方法需要从最近的机场出发，历时三天，并结合使用渔船、油轮、皮划艇和潜艇。为了使参加 ICPC 世界总决赛稍微容易一些，并启动该岛的旅游业务，Piconesia 计划建造其第一个机场。\n\n由于较长的跑道可以容纳更大的飞机，Piconesia 决定在他们的岛上建造尽可能长的跑道。不幸的是，他们无法确定这条跑道应该建在哪里。也许你可以帮忙？\n\n对于这个问题，我们将 Piconesia 的边界建模为一个多边形。给定这个多边形，你需要计算可以在岛上建造的最长跑道（即直线段）的长度。跑道不得与海相交，但可以接触或沿着岛的边界。图 A.1 显示了与第一个样例输入对应的示例。\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14633/1.png)\n\n图 A.1：将岛屿建模为多边形。最长的可能跑道显示为粗线。", "inputFormat": "输入以一行整数 $n (3 \\le n \\le 200)$ 开始，指定多边形的顶点数。接下来是 $n$ 行，每行包含两个整数 $x$ 和 $y (|x|, |y| \\le 10^{6})$，给出多边形顶点的坐标 $(x , y)$，按逆时针顺序排列。该多边形是简单的，即其顶点是不同的，并且多边形的两条边不相交或接触，除了相邻边在其公共顶点处接触。此外，没有两条相邻的边是共线的。", "outputFormat": "显示适合在多边形内的最长直线段的长度，绝对误差或相对误差不超过 $10^{-6}$。", "hint": "时间限制：2 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
