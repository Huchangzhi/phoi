{"pid": "P14726", "type": "P", "difficulty": 4, "samples": [["9 7 3\n3 2\n6 3 2\n3 0 3\n0 1 12\n1 0 4\n1 2 2\n1 5 4\n4 1 8\n5 4 7\n5 2 5\n0 1 2\n4 1 5\n1 5 2", "36"], ["4 4 1\n0 3\n0 1 2\n1 2 3\n0 2 7\n2 3 10\n0 1 2", "17"], ["4 4 0\n0 3\n0 1 2\n1 2 3\n0 2 7\n2 3 10", "15"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2022", "最短路", "ICPC", "首尔"], "title": "[ICPC 2022 Seoul R] Forbidden Turns", "background": "", "description": "A GPS navigation company ICPC (International Control Perfection Company) designs a car navigation system for a transportation network. The system abstracts the transportation network as a directed graph $G(V, E)$ with edge cost $c$. For a directed edge $(v, w) \\in E$, $c(v, w)$ denotes the distance from a place $v \\in V$ to another place $w \\in V$. The company wants to implement the shortest path module in the system. To reflect the normal situation that we cannot turn to some directions in a junction of transportation network, we want to find the shortest path that does not contain forbidden turns as a subpath.\n\nA path from $v$ to $w$ is a sequence of vertices $(v_1, v_2, \\cdots, v_k)$ where $v_1 = v$, $v_k = w$, $(v_i, v_{i+1}) \\in E$ for $1 \\leq i \\leq k-1$. Unlike the common definition of the path, you are here allowed to repeat the same vertices in a path one or more. A subpath of a path is a contiguous subsequence of the sequence that corresponds to the path. A forbidden turn is a path (i.e., triplet) $(x, y, z)$ such that $x, y, z \\in V$ and $(x, y) \\in E$ and $(y, z) \\in E$. The distance of a path $(v_1, v_2, \\cdots, v_k)$ is defined as $\\sum_{i=1}^{k-1} c(v_i, v_{i+1})$. The shortest path from $v \\in V$ to $w \\in V$ is a path from $v$ to $w$ with the minimum distance. The company wants to find the distance of the shortest path that avoids the forbidden turns between two designated vertices. Note that the shortest path from $v \\in V$ to $v \\in V$ has distance 0 and it avoids all the forbidden turns.\n\nLet's see the following example in the figure below. Each edge cost lies beside each edge and the list of three forbidden turns are in the right box. The shortest path without forbidden turns from the vertex 3 to the vertex 2 is $(3, 0, 1, 5, 4, 1, 2)$ which is denoted as blue arrows in the following figure. The distance of the shortest path is $3 + 12 + 4 + 7 + 8 + 2 = 36$. Note that we cannot take the shorter paths $(3, 0, 1, 2)$ and $(3, 0, 1, 5, 2)$ since they contain forbidden turns $(0, 1, 2)$ and $(1, 5, 2)$, respectively.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/62gazcnt.png)\n:::\n\nGiven a directed graph $G(V, E)$ with the edge cost $c$, a set of forbidden turns $F$, and two vertices $v$ and $w$, write a program to output the distance of the shortest path from $v$ to $w$ that avoids all the forbidden turns. We assume that out-degree of each vertex $v$, i.e., the number of edges that starts from $v$ is at most 10.", "inputFormat": "Your program is to read from standard input. The input starts with a line containing three integers, $m$, $n$, and $k$. ($0 \\leq m \\leq 10n$, $1 \\leq n \\leq 30,000$, $0 \\leq k \\leq 500,000$), where $m$ is the number of directed edges, $n$ is the number of vertices, and $k$ is the number of forbidden turns of the given directed graph $G(V, E)$. Here, $k$ is less than or equal to the number of all the possible forbidden turns in the given directed graph $G(V, E)$. The vertices are numbered from 0 to $n-1$. The second line contains two integers $v$ and $w$ which denote the source and destination vertices, respectively. In the following $m$ lines, the $i$-th line contains three integers $x_i$, $y_i$, and $c_i$ ($0 \\leq x_i \\ne y_i \\leq n-1$ and $0 \\leq c_i \\leq 10^3$) which denotes an edge $(x_i, y_i) \\in E$ and its cost, respectively. In the following $k$ lines, the $i$-th line contains three integers $x_i$, $y_i$, and $z_i$ which denote a forbidden turn $(x_i, y_i, z_i)$.", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain an integer that represents the distance of the shortest path from $v$ to $w$ which avoids all the forbidden turns. If such a path does not exist, the line should contain $-1$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Seoul R] Forbidden Turns", "background": "", "description": "A GPS navigation company ICPC (International Control Perfection Company) designs a car navigation system for a transportation network. The system abstracts the transportation network as a directed graph $G(V, E)$ with edge cost $c$. For a directed edge $(v, w) \\in E$, $c(v, w)$ denotes the distance from a place $v \\in V$ to another place $w \\in V$. The company wants to implement the shortest path module in the system. To reflect the normal situation that we cannot turn to some directions in a junction of transportation network, we want to find the shortest path that does not contain forbidden turns as a subpath.\n\nA path from $v$ to $w$ is a sequence of vertices $(v_1, v_2, \\cdots, v_k)$ where $v_1 = v$, $v_k = w$, $(v_i, v_{i+1}) \\in E$ for $1 \\leq i \\leq k-1$. Unlike the common definition of the path, you are here allowed to repeat the same vertices in a path one or more. A subpath of a path is a contiguous subsequence of the sequence that corresponds to the path. A forbidden turn is a path (i.e., triplet) $(x, y, z)$ such that $x, y, z \\in V$ and $(x, y) \\in E$ and $(y, z) \\in E$. The distance of a path $(v_1, v_2, \\cdots, v_k)$ is defined as $\\sum_{i=1}^{k-1} c(v_i, v_{i+1})$. The shortest path from $v \\in V$ to $w \\in V$ is a path from $v$ to $w$ with the minimum distance. The company wants to find the distance of the shortest path that avoids the forbidden turns between two designated vertices. Note that the shortest path from $v \\in V$ to $v \\in V$ has distance 0 and it avoids all the forbidden turns.\n\nLet's see the following example in the figure below. Each edge cost lies beside each edge and the list of three forbidden turns are in the right box. The shortest path without forbidden turns from the vertex 3 to the vertex 2 is $(3, 0, 1, 5, 4, 1, 2)$ which is denoted as blue arrows in the following figure. The distance of the shortest path is $3 + 12 + 4 + 7 + 8 + 2 = 36$. Note that we cannot take the shorter paths $(3, 0, 1, 2)$ and $(3, 0, 1, 5, 2)$ since they contain forbidden turns $(0, 1, 2)$ and $(1, 5, 2)$, respectively.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/62gazcnt.png)\n:::\n\nGiven a directed graph $G(V, E)$ with the edge cost $c$, a set of forbidden turns $F$, and two vertices $v$ and $w$, write a program to output the distance of the shortest path from $v$ to $w$ that avoids all the forbidden turns. We assume that out-degree of each vertex $v$, i.e., the number of edges that starts from $v$ is at most 10.", "inputFormat": "Your program is to read from standard input. The input starts with a line containing three integers, $m$, $n$, and $k$. ($0 \\leq m \\leq 10n$, $1 \\leq n \\leq 30,000$, $0 \\leq k \\leq 500,000$), where $m$ is the number of directed edges, $n$ is the number of vertices, and $k$ is the number of forbidden turns of the given directed graph $G(V, E)$. Here, $k$ is less than or equal to the number of all the possible forbidden turns in the given directed graph $G(V, E)$. The vertices are numbered from 0 to $n-1$. The second line contains two integers $v$ and $w$ which denote the source and destination vertices, respectively. In the following $m$ lines, the $i$-th line contains three integers $x_i$, $y_i$, and $c_i$ ($0 \\leq x_i \\ne y_i \\leq n-1$ and $0 \\leq c_i \\leq 10^3$) which denotes an edge $(x_i, y_i) \\in E$ and its cost, respectively. In the following $k$ lines, the $i$-th line contains three integers $x_i$, $y_i$, and $z_i$ which denote a forbidden turn $(x_i, y_i, z_i)$.", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain an integer that represents the distance of the shortest path from $v$ to $w$ which avoids all the forbidden turns. If such a path does not exist, the line should contain $-1$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Seoul R] Forbidden Turns", "background": "", "description": "一家 GPS 导航公司 ICPC（国际精准控制公司）为交通网络设计了一套汽车导航系统。该系统将交通网络抽象为一个有向图 $G(V, E)$，其中边具有成本 $c$。对于一条有向边 $(v, w) \\in E$，$c(v, w)$ 表示从地点 $v \\in V$ 到另一地点 $w \\in V$ 的距离。公司希望在系统中实现最短路径模块。为了反映交通网络交叉路口处某些转向通常不允许的现实情况，我们希望找到一条不包含被禁止转向作为子路径的最短路径。\n\n从 $v$ 到 $w$ 的一条路径是一个顶点序列 $(v_1, v_2, \\cdots, v_k)$，其中 $v_1 = v$，$v_k = w$，且 $(v_i, v_{i+1}) \\in E$ 对于 $1 \\leq i \\leq k-1$。与路径的常见定义不同，这里允许在一条路径中重复访问相同的顶点一次或多次。路径的一个**子路径**是对应该序列的一个连续子序列。一个**被禁止的转向**是一条路径（即三元组）$(x, y, z)$，满足 $x, y, z \\in V$ 且 $(x, y) \\in E$ 和 $(y, z) \\in E$。一条路径 $(v_1, v_2, \\cdots, v_k)$ 的距离定义为 $\\sum_{i=1}^{k-1} c(v_i, v_{i+1})$。从 $v \\in V$ 到 $w \\in V$ 的**最短路径**是一条从 $v$ 到 $w$ 且具有最小距离的路径。公司希望找到两个指定顶点之间避免所有被禁止转向的最短路径的距离。注意，从 $v \\in V$ 到 $v \\in V$ 的最短路径距离为 $0$，并且它避开了所有被禁止的转向。\n\n请看下图的示例。每条边的成本标注在边旁，三个被禁止转向的列表在右侧框中。从顶点 $3$ 到顶点 $2$ 的不包含被禁止转向的最短路径是 $(3, 0, 1, 5, 4, 1, 2)$，在下图中用蓝色箭头表示。该最短路径的距离为 $3 + 12 + 4 + 7 + 8 + 2 = 36$。注意，我们不能采用更短的路径 $(3, 0, 1, 2)$ 和 $(3, 0, 1, 5, 2)$，因为它们分别包含被禁止转向 $(0, 1, 2)$ 和 $(1, 5, 2)$。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/62gazcnt.png)\n:::\n\n给定一个有向图 $G(V, E)$ 及其边成本 $c$、一个被禁止转向的集合 $F$ 以及两个顶点 $v$ 和 $w$，请编写一个程序，输出从 $v$ 到 $w$ 的、避开所有被禁止转向的最短路径的距离。我们假设每个顶点 $v$ 的出度（即从 $v$ 出发的边的数量）最多为 $10$。", "inputFormat": "你的程序需要从标准输入读取数据。输入的第一行包含三个整数 $m$、$n$ 和 $k$（$0 \\leq m \\leq 10n$， $1 \\leq n \\leq 30,000$， $0 \\leq k \\leq 500,000$），其中 $m$ 是有向边的数量，$n$ 是顶点数量，$k$ 是给定有向图 $G(V, E)$ 中被禁止转向的数量。这里，$k$ 小于等于给定有向图 $G(V, E)$ 中所有可能的被禁止转向的数量。顶点编号从 $0$ 到 $n-1$。第二行包含两个整数 $v$ 和 $w$，分别表示源点和目标顶点。接下来的 $m$ 行中，第 $i$ 行包含三个整数 $x_i$、$y_i$ 和 $c_i$ ($0 \\leq x_i \\ne y_i \\leq n-1$ 且 $0 \\leq c_i \\leq 10^3$)，分别表示一条边 $(x_i, y_i) \\in E$ 及其成本。接下来的 $k$ 行中，第 $i$ 行包含三个整数 $x_i$、$y_i$ 和 $z_i$，表示一个被禁止转向 $(x_i, y_i, z_i)$。", "outputFormat": "你的程序需要向标准输出写入数据。输出恰好一行。该行应包含一个整数，表示从 $v$ 到 $w$ 的、避开所有被禁止转向的最短路径的距离。如果这样的路径不存在，则该行应包含 $-1$。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14727", "type": "P", "difficulty": 3, "samples": [["4 3\n0 2\n0 3\n3 5\n6 7\n4 2 3", "2"], ["4 3\n0 2\n0 3\n3 5\n6 7\n2 3 2", "0"], ["8 5\n1 8\n2 4\n5 11\n13 15\n15 17\n16 18\n19 22\n20 22\n3 7 4 6 3", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["递推", "2022", "前缀和", "ICPC", "首尔"], "title": "[ICPC 2022 Seoul R] Frog Jump", "background": "", "description": "A frog is living in a beautiful lake. On the lake, there are a lot of lotus leaves floating in a row, which are represented by closed intervals on the line. The frog likes to be on lotus leaves and moves between them.\n\nThe $n$ closed intervals, representing lotus leaves, on the line, that is, on the x-axis are given and the frog is initially on some interval $I_0$. The frog can move from an interval $I$ to an interval $J$ if they overlap. Two intervals overlap if they share a common point. So the frog can move through overlapping intervals. When the frog is moving to the right (left) through the overlapping intervals, it may reach an interval $H$, where it can no longer move to the right (left) from the right (left) endpoint of $H$. In this case, the frog can jump to the interval $K$ with the smallest (largest) left (right) endpoint among intervals whose left (right) endpoint is greater (smaller) than the right (left) endpoint of $H$ if they exist. Then, the jump length is defined to be the length between the right (left) endpoint of $H$ and the left (right) endpoint of $K$. See Figure F.1.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/mnuh5hwt.png)\n\nFigure F.1 Jump length\n:::\n\nA sequence of $k$ intervals $I_1, I_2, \\dots, I_k$ is given and the frog should visit the intervals in order from the initial interval $I_0$. In this travel, the frog has to jump if necessary.\n\nFor example, in Figure F.2, eight intervals $[1,8]$, $[2,4]$, $[5,11]$, $[13,15]$, $[15,17]$, $[16,18]$, $[19,22]$ and $[20,22]$ are given and numbered from 1 and 8. The frog is initially on interval 1. Intervals 3, 7, 4, 6, 3 which the frog should visit in a sequence are given. Then the frog moves from interval 1 to 3 with no jump, and it moves from 3 to 7 with two jumps, say, $3 \\to 4$ and $6 \\to 7$ whose jump length is 3 totally. In this movement, the frog passes through the interval 4. Nevertheless, it should visit the interval 4 after the interval 7. Then, there are two jumps during the movements from 7 to 4 and from 6 to 3 whose jump length is 3 totally. Thus after the frog visits all the given intervals, the total jump length is 6.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/gkev6tv8.png)\n:::\n\nGiven $n$ intervals on the line and a sequence of $k$ intervals, write a program to output the total jump length during the travel that the frog visits the $k$ intervals in order from its initial interval 1.", "inputFormat": "Your program is to read from standard input. The input starts with a line containing two integers, $n$ and $k$ ($1 \\leq n \\leq 100,000$ and $1 \\leq k \\leq 1,000,000$), where $n$ is the number of intervals and $k$ is the number of intervals which the frog should visit. The intervals are numbered from 1 to $n$ and the initial location of the frog is always 1. In the following $n$ lines, the $i$-th line contains two integers $a$ and $b$ ($0 \\leq a < b \\leq 10^9$) that represent the left and right endpoints of interval $i$, respectively. The intervals are given in increasing order of their left endpoints — if they are same, then in increasing order of the right endpoints. Also the intervals are all distinct. The next line contains $k$ integers that represent the intervals which the frog should visit in order. These integers are between 1 and $n$ and can be in duplicate.", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain the total jump length of frog when it visits the given $k$ intervals in order.", "hint": "翻译由 DeepSeek V3 完成", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Seoul R] Frog Jump", "background": "", "description": "A frog is living in a beautiful lake. On the lake, there are a lot of lotus leaves floating in a row, which are represented by closed intervals on the line. The frog likes to be on lotus leaves and moves between them.\n\nThe $n$ closed intervals, representing lotus leaves, on the line, that is, on the x-axis are given and the frog is initially on some interval $I_0$. The frog can move from an interval $I$ to an interval $J$ if they overlap. Two intervals overlap if they share a common point. So the frog can move through overlapping intervals. When the frog is moving to the right (left) through the overlapping intervals, it may reach an interval $H$, where it can no longer move to the right (left) from the right (left) endpoint of $H$. In this case, the frog can jump to the interval $K$ with the smallest (largest) left (right) endpoint among intervals whose left (right) endpoint is greater (smaller) than the right (left) endpoint of $H$ if they exist. Then, the jump length is defined to be the length between the right (left) endpoint of $H$ and the left (right) endpoint of $K$. See Figure F.1.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/mnuh5hwt.png)\n\nFigure F.1 Jump length\n:::\n\nA sequence of $k$ intervals $I_1, I_2, \\dots, I_k$ is given and the frog should visit the intervals in order from the initial interval $I_0$. In this travel, the frog has to jump if necessary.\n\nFor example, in Figure F.2, eight intervals $[1,8]$, $[2,4]$, $[5,11]$, $[13,15]$, $[15,17]$, $[16,18]$, $[19,22]$ and $[20,22]$ are given and numbered from 1 and 8. The frog is initially on interval 1. Intervals 3, 7, 4, 6, 3 which the frog should visit in a sequence are given. Then the frog moves from interval 1 to 3 with no jump, and it moves from 3 to 7 with two jumps, say, $3 \\to 4$ and $6 \\to 7$ whose jump length is 3 totally. In this movement, the frog passes through the interval 4. Nevertheless, it should visit the interval 4 after the interval 7. Then, there are two jumps during the movements from 7 to 4 and from 6 to 3 whose jump length is 3 totally. Thus after the frog visits all the given intervals, the total jump length is 6.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/gkev6tv8.png)\n:::\n\nGiven $n$ intervals on the line and a sequence of $k$ intervals, write a program to output the total jump length during the travel that the frog visits the $k$ intervals in order from its initial interval 1.", "inputFormat": "Your program is to read from standard input. The input starts with a line containing two integers, $n$ and $k$ ($1 \\leq n \\leq 100,000$ and $1 \\leq k \\leq 1,000,000$), where $n$ is the number of intervals and $k$ is the number of intervals which the frog should visit. The intervals are numbered from 1 to $n$ and the initial location of the frog is always 1. In the following $n$ lines, the $i$-th line contains two integers $a$ and $b$ ($0 \\leq a < b \\leq 10^9$) that represent the left and right endpoints of interval $i$, respectively. The intervals are given in increasing order of their left endpoints — if they are same, then in increasing order of the right endpoints. Also the intervals are all distinct. The next line contains $k$ integers that represent the intervals which the frog should visit in order. These integers are between 1 and $n$ and can be in duplicate.", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain the total jump length of frog when it visits the given $k$ intervals in order.", "hint": "翻译由 DeepSeek V3 完成", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Seoul R] Frog Jump", "background": "", "description": "一只青蛙住在一个美丽的湖中。湖面上有许多荷叶排成一行漂浮着，这些荷叶用直线上的闭区间表示。青蛙喜欢待在荷叶上，并在它们之间移动。\n\n给定直线上（即 $x$ 轴上）表示荷叶的 $n$ 个闭区间，青蛙初始位于某个区间 $I_0$ 上。如果两个区间重叠，青蛙可以从一个区间 $I$ 移动到另一个区间 $J$。两个区间重叠当它们共享一个公共点。因此，青蛙可以通过重叠的区间移动。当青蛙通过重叠区间向右（左）移动时，它可能会到达一个区间 $H$，此时它无法再从 $H$ 的右（左）端点向右（左）移动。在这种情况下，如果存在满足以下条件的区间 $K$：其左（右）端点大于（小于）$H$ 的右（左）端点，并且在其左（右）端点最小（最大）的区间中，青蛙可以跳转到区间 $K$。然后，跳跃长度定义为 $H$ 的右（左）端点与 $K$ 的左（右）端点之间的距离。参见图 F.1。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/mnuh5hwt.png)\n\n图 F.1 跳跃长度\n:::\n\n给定一个由 $k$ 个区间 $I_1, I_2, \\dots, I_k$ 组成的序列，青蛙需要从初始区间 $I_0$ 出发，按顺序访问这些区间。在此旅行中，青蛙在必要时必须进行跳跃。\n\n例如，在图 F.2 中，给出了八个区间 $[1,8]$、$[2,4]$、$[5,11]$、$[13,15]$、$[15,17]$、$[16,18]$、$[19,22]$ 和 $[20,22]$，并从 $1$ 到 $8$ 编号。青蛙初始位于区间 $1$。给定青蛙需按顺序访问的区间序列：$3$、$7$、$4$、$6$、$3$。那么青蛙从区间 $1$ 移动到 $3$ 时没有跳跃，从区间 $3$ 移动到 $7$ 时有两次跳跃，即 $3 \\to 4$ 和 $6 \\to 7$，跳跃总长度为 $3$。在此移动过程中，青蛙经过了区间 $4$。然而，它需要在访问区间 $7$ 之后再访问区间 $4$。然后，从区间 $7$ 到 $4$ 以及从 $6$ 到 $3$ 的移动过程中有两次跳跃，跳跃总长度为 $3$。因此，在青蛙访问完所有给定区间后，总跳跃长度为 $6$。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/gkev6tv8.png)\n:::\n\n给定直线上的 $n$ 个区间以及一个由 $k$ 个区间组成的序列，请编写一个程序，输出青蛙从初始区间 $1$ 出发按顺序访问这 $k$ 个区间的旅行过程中总跳跃长度。", "inputFormat": "你的程序需要从标准输入读取数据。输入的第一行包含两个整数 $n$ 和 $k$ ($1 \\leq n \\leq 100,000$ 且 $1 \\leq k \\leq 1,000,000$)，其中 $n$ 是区间数量，$k$ 是青蛙需要访问的区间数量。区间从 $1$ 到 $n$ 编号，青蛙的初始位置始终是区间 $1$。接下来的 $n$ 行中，第 $i$ 行包含两个整数 $a$ 和 $b$ ($0 \\leq a < b \\leq 10^9$)，分别表示区间 $i$ 的左端点和右端点。区间按其左端点递增的顺序给出——如果左端点相同，则按右端点递增顺序给出。此外，所有区间互不相同。接下来的一行包含 $k$ 个整数，表示青蛙按顺序需要访问的区间。这些整数在 $1$ 到 $n$ 之间，可以重复。\n", "outputFormat": "你的程序需要向标准输出写入数据。输出恰好一行。该行应包含青蛙按顺序访问给定的 $k$ 个区间时的总跳跃长度。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14728", "type": "P", "difficulty": 7, "samples": [["6 0\n0 0\n5 -1\n9 6\n3 0\n4 2\n3 1", "2.166667"], ["6 1\n0 0\n5 -1\n9 6\n3 0\n4 2\n3 1", "1.000000"], ["6 2\n0 0\n5 -1\n9 6\n3 0\n4 2\n3 1", "0.500000"], ["6 3\n0 0\n5 -1\n9 6\n3 0\n4 2\n3 1", "0.083333"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2022", "Special Judge", "ICPC", "首尔"], "title": "[ICPC 2022 Seoul R] Linear Regression", "background": "An extra 5 second time limit is provided.", "description": "Chansu is a graduate student at University of ICPC, working in a laboratory for his master’s degree. His research theme is to reveal a relation between the obesity and the yearly income of individuals in a certain group G.\n\nChansu collected data of the form $(x_i, y_i)$ from $n$ persons in G, where $x_i$ and $y_i$ denote the obesity index and the yearly income of the $i$-th person, and made an apparent hypothesis:\n\n> There is a linear dependency between the obesity and the yearly income of individuals in group G.\n\nTo prove his hypothesis, Chansu tried to find an optimal linear function $f^*(x)$ with real coefficients such that the error with respect to the collected data is minimized. More specifically, the error of $f$ with respect to the data is defined to be the maximum of $|y_i - f(x_i)|$ over all $i = 1, \\dots, n$.\n\nHowever, the result was disappointing because the error of the optimal function $f^*(x)$ was unexpectedly big. This means that his hypothesis cannot be proven in this way.\n\nChansu tried to figure out the reason of the big errors. One day, he plotted the data $(x_i, y_i)$ as points on the coordinated plane and realized that there are a small number $k$ of points that are unusually far from the others, so the error of the optimal function can be drastically reduced after removing them.\n\nYou, as a friend of Chansu, would love to help Chansu. Write a program that finds an optimal linear function minimizing the error after removing some $k$ values from the given data $\\{(x_1, y_1), \\dots, (x_n, y_n)\\}$ and prints out the error value, when the number $k$ is given as part of input.\n", "inputFormat": "Your program is to read from standard input. The input starts with a line containing two integers, $n$ and $k$ ($1 \\leq n \\leq 50,000$, $0 \\leq k \\leq \\min\\left\\{\\frac{n}{2}, 300\\right\\}$), where $n$ is the number of collected data values. In each of the following $n$ lines, each data value $(x_i, y_i)$ is given by two integers $x_i$ and $y_i$ ($-10^9 \\leq x_i, y_i \\leq 10^9$) for $i = 1, \\dots, n$. You can assume that no three of them are collinear when plotting them in the coordinated plane.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain a real number $z$ representing the minimum possible error of a linear function with respect to the data after removing some $k$ values. Your output $z$ should be in the format that consists of its integer part, a decimal point, and its fractional part, and will be decided to be “correct” if it holds that $a - 10^{-6} < z < a + 10^{-6}$, where $a$ denotes the exact answer.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Seoul R] Linear Regression", "background": "An extra 5 second time limit is provided.", "description": "Chansu is a graduate student at University of ICPC, working in a laboratory for his master’s degree. His research theme is to reveal a relation between the obesity and the yearly income of individuals in a certain group G.\n\nChansu collected data of the form $(x_i, y_i)$ from $n$ persons in G, where $x_i$ and $y_i$ denote the obesity index and the yearly income of the $i$-th person, and made an apparent hypothesis:\n\n> There is a linear dependency between the obesity and the yearly income of individuals in group G.\n\nTo prove his hypothesis, Chansu tried to find an optimal linear function $f^*(x)$ with real coefficients such that the error with respect to the collected data is minimized. More specifically, the error of $f$ with respect to the data is defined to be the maximum of $|y_i - f(x_i)|$ over all $i = 1, \\dots, n$.\n\nHowever, the result was disappointing because the error of the optimal function $f^*(x)$ was unexpectedly big. This means that his hypothesis cannot be proven in this way.\n\nChansu tried to figure out the reason of the big errors. One day, he plotted the data $(x_i, y_i)$ as points on the coordinated plane and realized that there are a small number $k$ of points that are unusually far from the others, so the error of the optimal function can be drastically reduced after removing them.\n\nYou, as a friend of Chansu, would love to help Chansu. Write a program that finds an optimal linear function minimizing the error after removing some $k$ values from the given data $\\{(x_1, y_1), \\dots, (x_n, y_n)\\}$ and prints out the error value, when the number $k$ is given as part of input.\n", "inputFormat": "Your program is to read from standard input. The input starts with a line containing two integers, $n$ and $k$ ($1 \\leq n \\leq 50,000$, $0 \\leq k \\leq \\min\\left\\{\\frac{n}{2}, 300\\right\\}$), where $n$ is the number of collected data values. In each of the following $n$ lines, each data value $(x_i, y_i)$ is given by two integers $x_i$ and $y_i$ ($-10^9 \\leq x_i, y_i \\leq 10^9$) for $i = 1, \\dots, n$. You can assume that no three of them are collinear when plotting them in the coordinated plane.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain a real number $z$ representing the minimum possible error of a linear function with respect to the data after removing some $k$ values. Your output $z$ should be in the format that consists of its integer part, a decimal point, and its fractional part, and will be decided to be “correct” if it holds that $a - 10^{-6} < z < a + 10^{-6}$, where $a$ denotes the exact answer.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Seoul R] Linear Regression", "background": "额外提供了 5 秒的时间限制。", "description": "Chansu 是 ICPC 大学的一名研究生，正在实验室攻读硕士学位。他的研究主题是揭示特定群体 G 中个体肥胖程度与年收入之间的关系。\n\nChansu 从 G 中的 $n$ 个人收集了形式为 $(x_i, y_i)$ 的数据，其中 $x_i$ 和 $y_i$ 分别表示第 $i$ 个人的肥胖指数和年收入，并提出了一个初步假设：\n\n> 群体 G 中个体的肥胖程度与年收入之间存在线性依赖关系。\n\n为了证明他的假设，Chansu 试图找到一个具有实系数的最优线性函数 $f^*(x)$，使得相对于收集数据的误差最小。更具体地说，函数 $f$ 相对于数据的误差定义为所有 $i = 1, \\dots, n$ 中 $|y_i - f(x_i)|$ 的最大值。\n\n然而，结果令人失望，因为最优函数 $f^*(x)$ 的误差出乎意料地大。这意味着他的假设无法通过这种方式得到证明。\n\nChansu 试图找出大误差的原因。有一天，他将数据 $(x_i, y_i)$ 绘制为坐标平面上的点，并意识到有少数 $k$ 个点异常远离其他点，因此移除这些点后，最优函数的误差可以大幅减小。\n\n作为 Chansu 的朋友，你非常乐意帮助他。请编写一个程序，在给定允许从数据 $\\{(x_1, y_1), \\dots, (x_n, y_n)\\}$ 中移除 $k$ 个值（$k$ 作为输入的一部分给出）的情况下，找到最小化误差的最优线性函数，并输出误差值。\n", "inputFormat": "你的程序需要从标准输入读取数据。输入的第一行包含两个整数 $n$ 和 $k$ ($1 \\leq n \\leq 50,000$, $0 \\leq k \\leq \\min\\left\\{\\frac{n}{2}, 300\\right\\}$)，其中 $n$ 是收集的数据值的数量。接下来的 $n$ 行中，每行给出一个数据值 $(x_i, y_i)$，由两个整数 $x_i$ 和 $y_i$ 表示 ($-10^9 \\leq x_i, y_i \\leq 10^9$)，对应 $i = 1, \\dots, n$。你可以假设当将这些点绘制在坐标平面上时，没有三点共线。", "outputFormat": "你的程序需要向标准输出写入数据。输出恰好一行。该行应包含一个实数 $z$，表示在移除 $k$ 个值后，线性函数相对于数据的最小可能误差。你的输出 $z$ 应以整数部分、小数点和小数部分的格式给出，如果满足 $a - 10^{-6} < z < a + 10^{-6}$，则将被判定为“正确”，其中 $a$ 表示精确答案。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14729", "type": "P", "difficulty": 6, "samples": [["ababa", "5 2 1 0 0"], ["aaaaaaaa", "8 7 6 5 4 3 2 1"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2022", "后缀自动机 SAM", "ICPC", "根号分治", "启发式合并", "首尔"], "title": "[ICPC 2022 Seoul R] Longest Substring", "background": "", "description": "For a string $S$ of length $n \\geq 1$ and a positive integer $k$ ($1 \\leq k \\leq n$), a non-empty substring of $S$ is called a $k$-substring if the substring appears **exactly** $k$ times. Such $k$ occurrences are not necessarily disjoint, i.e., are possibly overlapping. For example, if $S = \\text{ababa}$, the $k$-substrings of $S$ for every $k = 1, ..., 5$ are as follows:\n\n- There are four 1-substrings in $S$, $\\text{abab}$, $\\text{ababa}$, $\\text{bab}$, and $\\text{baba}$ because these substrings appear exactly once in $S$. Note that $\\text{aba}$ is not a 1-substring because it appears twice.\n- There are four 2-substrings in $S$, $\\text{ab}$, $\\text{aba}$, $\\text{b}$, and $\\text{ba}$. The substring $\\text{ab}$ appears exactly twice without overlapping. Two occurrences of the substring $\\text{aba}$ are overlapped at a common character $\\text{a}$, but it does not appear three times or more.\n- There is only one 3-substring in $S$, $\\text{a}$.\n- Neither 4-substrings nor 5-substrings exist in $S$.\n\nFor a $k$-substring $T$ of $S$, let $d(T)$ be the maximum number of the disjoint occurrences of $T$ in $S$. For example, a 2-substring $T = \\text{ab}$ can be selected twice without overlapping, that is, the maximum number of the disjoint occurrences is two, so $d(T) = 2$. For a 2-substring $T = \\text{aba}$, it cannot be selected twice without overlapping, so $d(T) = 1$. For a 3-substring $T = \\text{a}$, it can be selected three times without overlapping, which is the maximum, so $d(T) = 3$.\n\nLet $f(k)$ be the length of the longest one among all $k$-substring $T$ with the largest $d(T)$ for $1 \\leq k \\leq n$. For example, $f(k)$ for $S = \\text{ababa}$ and $k = 1, ..., 5$ is as follows:\n\n- For $k = 1$, all 1-substrings $T$ can be selected only once without overlapping, so $d(T) = 1$. Thus, the longest one among all 1-substrings with $d(T) = 1$ is $\\text{ababa}$, so $f(1) = 5$.\n- For $k = 2$, $d(T) = 1$ for $T = \\text{aba}$, but $d(T) = 2$ for the other 2-substrings $T = \\text{ab}$, $\\text{b}$, $\\text{ba}$. Among 2-substrings with $d(T) = 2$, $\\text{ab}$ and $\\text{ba}$ are the longest ones, so $f(2) = 2$.\n- For $k = 3$, $f(3) = 1$ because there is only one 3-substring $\\text{a}$.\n- For $k = 4, 5$, there are no $k$-substrings, so $f(4) = 0$ and $f(5) = 0$.\n\nGiven a string $S$ of length $n$, write a program to output $n$ values of $f(k)$ from $k = 1$ to $k = n$. For the above example, the output should be $5\\ 2\\ 1\\ 0\\ 0$.", "inputFormat": "Your program is to read from standard input. The input starts with a line containing the string $S$ consisting of $n$ ($1 \\leq n \\leq 50,000$) lowercase alphabets.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain exactly $n$ non-negative integers, separated by a space, that represent $f(k)$ from $k = 1$ to $k = n$ in order, that is, $f(1)\\ f(2)\\ ...\\ f(n)$. Note that $f(k)$ should be zero if there is no $k$-substring for some $k$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Seoul R] Longest Substring", "background": "", "description": "For a string $S$ of length $n \\geq 1$ and a positive integer $k$ ($1 \\leq k \\leq n$), a non-empty substring of $S$ is called a $k$-substring if the substring appears **exactly** $k$ times. Such $k$ occurrences are not necessarily disjoint, i.e., are possibly overlapping. For example, if $S = \\text{ababa}$, the $k$-substrings of $S$ for every $k = 1, ..., 5$ are as follows:\n\n- There are four 1-substrings in $S$, $\\text{abab}$, $\\text{ababa}$, $\\text{bab}$, and $\\text{baba}$ because these substrings appear exactly once in $S$. Note that $\\text{aba}$ is not a 1-substring because it appears twice.\n- There are four 2-substrings in $S$, $\\text{ab}$, $\\text{aba}$, $\\text{b}$, and $\\text{ba}$. The substring $\\text{ab}$ appears exactly twice without overlapping. Two occurrences of the substring $\\text{aba}$ are overlapped at a common character $\\text{a}$, but it does not appear three times or more.\n- There is only one 3-substring in $S$, $\\text{a}$.\n- Neither 4-substrings nor 5-substrings exist in $S$.\n\nFor a $k$-substring $T$ of $S$, let $d(T)$ be the maximum number of the disjoint occurrences of $T$ in $S$. For example, a 2-substring $T = \\text{ab}$ can be selected twice without overlapping, that is, the maximum number of the disjoint occurrences is two, so $d(T) = 2$. For a 2-substring $T = \\text{aba}$, it cannot be selected twice without overlapping, so $d(T) = 1$. For a 3-substring $T = \\text{a}$, it can be selected three times without overlapping, which is the maximum, so $d(T) = 3$.\n\nLet $f(k)$ be the length of the longest one among all $k$-substring $T$ with the largest $d(T)$ for $1 \\leq k \\leq n$. For example, $f(k)$ for $S = \\text{ababa}$ and $k = 1, ..., 5$ is as follows:\n\n- For $k = 1$, all 1-substrings $T$ can be selected only once without overlapping, so $d(T) = 1$. Thus, the longest one among all 1-substrings with $d(T) = 1$ is $\\text{ababa}$, so $f(1) = 5$.\n- For $k = 2$, $d(T) = 1$ for $T = \\text{aba}$, but $d(T) = 2$ for the other 2-substrings $T = \\text{ab}$, $\\text{b}$, $\\text{ba}$. Among 2-substrings with $d(T) = 2$, $\\text{ab}$ and $\\text{ba}$ are the longest ones, so $f(2) = 2$.\n- For $k = 3$, $f(3) = 1$ because there is only one 3-substring $\\text{a}$.\n- For $k = 4, 5$, there are no $k$-substrings, so $f(4) = 0$ and $f(5) = 0$.\n\nGiven a string $S$ of length $n$, write a program to output $n$ values of $f(k)$ from $k = 1$ to $k = n$. For the above example, the output should be $5\\ 2\\ 1\\ 0\\ 0$.", "inputFormat": "Your program is to read from standard input. The input starts with a line containing the string $S$ consisting of $n$ ($1 \\leq n \\leq 50,000$) lowercase alphabets.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain exactly $n$ non-negative integers, separated by a space, that represent $f(k)$ from $k = 1$ to $k = n$ in order, that is, $f(1)\\ f(2)\\ ...\\ f(n)$. Note that $f(k)$ should be zero if there is no $k$-substring for some $k$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Seoul R] Longest Substring", "background": "", "description": "对于一个长度为 $n \\geq 1$ 的字符串 $S$ 和一个正整数 $k$ ($1 \\leq k \\leq n$)，$S$ 的一个非空子串被称为 **$k$-子串**，如果该子串在 $S$ 中**恰好**出现 $k$ 次。这 $k$ 次出现不一定是互不重叠的，即可能重叠。例如，如果 $S = \\text{ababa}$，则对于每个 $k = 1, ..., 5$，$S$ 的 $k$-子串如下：\n\n- $S$ 中有四个 1-子串：$\\text{abab}$、$\\text{ababa}$、$\\text{bab}$ 和 $\\text{baba}$，因为这些子串在 $S$ 中恰好出现一次。注意，$\\text{aba}$ 不是 1-子串，因为它出现了两次。\n- $S$ 中有四个 2-子串：$\\text{ab}$、$\\text{aba}$、$\\text{b}$ 和 $\\text{ba}$。子串 $\\text{ab}$ 恰好不重叠地出现了两次。子串 $\\text{aba}$ 的两次出现在字符 $\\text{a}$ 处重叠，但它的出现次数不超过两次。\n- $S$ 中只有一个 3-子串：$\\text{a}$。\n- $S$ 中不存在 4-子串或 5-子串。\n\n对于 $S$ 的一个 $k$-子串 $T$，令 $d(T)$ 表示 $T$ 在 $S$ 中互不重叠出现的最大次数。例如，一个 2-子串 $T = \\text{ab}$ 可以不重叠地选择两次，即互不重叠出现的最大次数为 $2$，所以 $d(T) = 2$。对于一个 2-子串 $T = \\text{aba}$，它无法不重叠地选择两次，所以 $d(T) = 1$。对于一个 3-子串 $T = \\text{a}$，它可以不重叠地选择三次，这是最大值，所以 $d(T) = 3$。\n\n令 $f(k)$ 表示对于 $1 \\leq k \\leq n$，在所有 $k$-子串 $T$ 中，具有最大 $d(T)$ 的那些子串中最长的长度。例如，对于 $S = \\text{ababa}$ 和 $k = 1, ..., 5$，$f(k)$ 如下：\n\n- 当 $k = 1$ 时，所有 1-子串 $T$ 只能不重叠地选择一次，因此 $d(T) = 1$。所以，在所有 $d(T) = 1$ 的 1-子串中，最长的是 $\\text{ababa}$，因此 $f(1) = 5$。\n- 当 $k = 2$ 时，对于 $T = \\text{aba}$ 有 $d(T) = 1$，但对于其他 2-子串 $T = \\text{ab}$、$\\text{b}$、$\\text{ba}$ 有 $d(T) = 2$。在 $d(T) = 2$ 的 2-子串中，$\\text{ab}$ 和 $\\text{ba}$ 是最长的，因此 $f(2) = 2$。\n- 当 $k = 3$ 时，因为只有一个 3-子串 $\\text{a}$，所以 $f(3) = 1$。\n- 当 $k = 4, 5$ 时，不存在 $k$-子串，因此 $f(4) = 0$，$f(5) = 0$。\n\n给定一个长度为 $n$ 的字符串 $S$，请编写一个程序，输出 $f(k)$ 从 $k = 1$ 到 $k = n$ 的 $n$ 个值。对于上面的例子，输出应为 $5\\ 2\\ 1\\ 0\\ 0$。", "inputFormat": "你的程序需要从标准输入读取数据。输入的第一行包含一个由 $n$ ($1 \\leq n \\leq 50,000$) 个小写字母组成的字符串 $S$。", "outputFormat": "你的程序需要向标准输出写入数据。输出恰好一行。该行应包含恰好 $n$ 个非负整数，用空格分隔，表示按顺序从 $k = 1$ 到 $k = n$ 的 $f(k)$ 值，即 $f(1)\\ f(2)\\ ...\\ f(n)$。注意，如果对于某个 $k$ 不存在 $k$-子串，则 $f(k)$ 应为 $0$。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14730", "type": "P", "difficulty": 2, "samples": [["aababaa", "0"], ["abccbbab", "2"], ["acmicpc", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["搜索", "2022", "深度优先搜索 DFS", "ICPC", "双指针 two-pointer", "首尔"], "title": "[ICPC 2022 Seoul R] Palindrome Type", "background": "", "description": "A **palindrome** string is a word which reads the same backward as forward, such as $\\text{madam}$ or $\\text{racecar}$. In this problem we only consider strings with lowercase alphabets.\n\nWe newly define the types of palindromes. If a string is not a palindrome, we try to make it a palindrome by removing the minimum number of characters in the string. For a string $w$, if $k$ is the minimum number of characters removed to make the string a palindrome, we call the string $w$ a **type-$k$ palindrome**. Thus, if $w$ is a palindrome, then $w$ is a type-0 palindrome.\n\nGiven a string $w$, write a program to determine if $w$ is a type-$k$ palindrome where $k = 0, 1, 2, 3$.\n", "inputFormat": "Your program is to read from standard input. The input is a single line containing a string $w$ with length $n$ ($5 \\leq n \\leq 10^5$) of lowercase alphabets.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain a number $k$ among $\\{0, 1, 2, 3, -1\\}$ if the input string is a type-$k$ palindrome where $k = 0, 1, 2, 3$ and otherwise $-1$. The negative number $-1$ means the input string is not a type-$k$ palindrome where $k = 0, 1, 2, 3$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Seoul R] Palindrome Type", "background": "", "description": "A **palindrome** string is a word which reads the same backward as forward, such as $\\text{madam}$ or $\\text{racecar}$. In this problem we only consider strings with lowercase alphabets.\n\nWe newly define the types of palindromes. If a string is not a palindrome, we try to make it a palindrome by removing the minimum number of characters in the string. For a string $w$, if $k$ is the minimum number of characters removed to make the string a palindrome, we call the string $w$ a **type-$k$ palindrome**. Thus, if $w$ is a palindrome, then $w$ is a type-0 palindrome.\n\nGiven a string $w$, write a program to determine if $w$ is a type-$k$ palindrome where $k = 0, 1, 2, 3$.\n", "inputFormat": "Your program is to read from standard input. The input is a single line containing a string $w$ with length $n$ ($5 \\leq n \\leq 10^5$) of lowercase alphabets.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain a number $k$ among $\\{0, 1, 2, 3, -1\\}$ if the input string is a type-$k$ palindrome where $k = 0, 1, 2, 3$ and otherwise $-1$. The negative number $-1$ means the input string is not a type-$k$ palindrome where $k = 0, 1, 2, 3$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Seoul R] Palindrome Type", "background": "", "description": "**回文串** 是指正着读和反着读都一样的单词，例如 $\\text{madam}$ 或 $\\text{racecar}$。在本问题中，我们只考虑由小写字母组成的字符串。\n\n我们新定义几种回文类型。如果一个字符串不是回文串，我们尝试通过移除字符串中**最少数量的字符**使其变为回文串。对于一个字符串 $w$，如果使其变为回文串所需移除的最小字符数为 $k$，则称字符串 $w$ 为 **类型-$k$ 回文串**。因此，如果 $w$ 是回文串，则 $w$ 是类型-$0$ 回文串。\n\n给定一个字符串 $w$，请编写一个程序，判断 $w$ 是否为类型-$k$ 回文串，其中 $k = 0, 1, 2, 3$。", "inputFormat": "你的程序需要从标准输入读取数据。输入为一行，包含一个长度为 $n$ ($5 \\leq n \\leq 10^5$) 的小写字母字符串 $w$。", "outputFormat": "你的程序需要向标准输出写入数据。输出恰好一行。该行应包含一个数字 $k$，取自 $\\{0, 1, 2, 3, -1\\}$。如果输入字符串是类型-$k$ 回文串且 $k = 0, 1, 2, 3$，则输出对应的 $k$；否则输出 $-1$。负数 $-1$ 表示输入字符串不是 $k = 0, 1, 2, 3$ 中的任何一种类型回文串。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14731", "type": "P", "difficulty": 2, "samples": [["((()()())())", "7"], ["(()((()(()))()))", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2022", "栈", "ICPC", "首尔"], "title": "[ICPC 2022 Seoul R] Parentheses Tree", "background": "", "description": "A rooted ordered tree $T$ can be expressed as a string of matched parentheses $p(T)$. The string representation $p(T)$ can be defined recursively. As a base case, a tree consisting of a single node is expressed by a pair of parentheses $()$. When a rooted ordered tree $T$ consists of a root node and $k$ ordered subtrees $T_1, T_2, ..., T_k$ having their roots as child nodes of the root node, the string representation $p(T)$ is defined as follows:\n\n$$\np(T) := ( + p(T_1) + p(T_2) + \\cdots + p(T_k) + )\n$$\n\nIn the above expression, the operator $+$ means the concatenation of two strings. The figure below shows two examples of rooted ordered trees. The string representations $p(T_L)$ and $p(T_R)$ are $((())()())$ and $(()((()(()))()))$, respectively.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/uo30vk5n.png)\n:::\n\nThe distance from the root node to a leaf node is defined as the number of edges to be traversed to reach the leaf from the root. In the figure above, the root nodes are colored in blue, and the distances from the root node to all leaf nodes are shown. For trees $T_L$ and $T_R$, the sum of the distances from the root to all leaf nodes are 7 and 10, respectively.\n\nGiven a string of matched parentheses representing only one rooted ordered tree, write a program to output the sum of the distances from the root of the tree to all leaf nodes.\n", "inputFormat": "Your program is to read from standard input. The input consists of one line containing a string of matched parentheses which represents only one rooted ordered tree. The input does not contain any characters other than parentheses, and the length of string is at least 2 and no more than $10^7$.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain the sum of the distances from the root of the rooted ordered tree to all leaf nodes.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Seoul R] Parentheses Tree", "background": "", "description": "A rooted ordered tree $T$ can be expressed as a string of matched parentheses $p(T)$. The string representation $p(T)$ can be defined recursively. As a base case, a tree consisting of a single node is expressed by a pair of parentheses $()$. When a rooted ordered tree $T$ consists of a root node and $k$ ordered subtrees $T_1, T_2, ..., T_k$ having their roots as child nodes of the root node, the string representation $p(T)$ is defined as follows:\n\n$$\np(T) := ( + p(T_1) + p(T_2) + \\cdots + p(T_k) + )\n$$\n\nIn the above expression, the operator $+$ means the concatenation of two strings. The figure below shows two examples of rooted ordered trees. The string representations $p(T_L)$ and $p(T_R)$ are $((())()())$ and $(()((()(()))()))$, respectively.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/uo30vk5n.png)\n:::\n\nThe distance from the root node to a leaf node is defined as the number of edges to be traversed to reach the leaf from the root. In the figure above, the root nodes are colored in blue, and the distances from the root node to all leaf nodes are shown. For trees $T_L$ and $T_R$, the sum of the distances from the root to all leaf nodes are 7 and 10, respectively.\n\nGiven a string of matched parentheses representing only one rooted ordered tree, write a program to output the sum of the distances from the root of the tree to all leaf nodes.\n", "inputFormat": "Your program is to read from standard input. The input consists of one line containing a string of matched parentheses which represents only one rooted ordered tree. The input does not contain any characters other than parentheses, and the length of string is at least 2 and no more than $10^7$.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain the sum of the distances from the root of the rooted ordered tree to all leaf nodes.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Seoul R] Parentheses Tree", "background": "", "description": "一棵有根有序树 $T$ 可以用一个匹配括号字符串 $p(T)$ 来表示。字符串表示 $p(T)$ 可以递归地定义。作为基本情况，仅包含单个节点的树用一对括号 $()$ 表示。当一棵有根有序树 $T$ 由一个根节点和 $k$ 棵有序子树 $T_1, T_2, ..., T_k$ 组成，且这些子树的根节点是根节点的子节点时，字符串表示 $p(T)$ 定义如下：\n\n$$\np(T) := ( + p(T_1) + p(T_2) + \\cdots + p(T_k) + )\n$$\n\n在上面的表达式中，运算符 $+$ 表示两个字符串的连接。下图展示了两棵有根有序树的示例。其字符串表示 $p(T_L)$ 和 $p(T_R)$ 分别为 $((())()())$ 和 $(()((()(()))()))$。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/uo30vk5n.png)\n:::\n\n从根节点到叶节点的距离定义为从根节点出发到达叶节点需要遍历的边的数量。在上图中，根节点用蓝色标出，并显示了从根节点到所有叶节点的距离。对于树 $T_L$ 和 $T_R$，从根节点到所有叶节点的距离之和分别为 $7$ 和 $10$。\n\n给定一个表示唯一有根有序树的匹配括号字符串，请编写一个程序，输出从该树的根节点到所有叶节点的距离之和。", "inputFormat": "你的程序需要从标准输入读取数据。输入包含一行，是一个表示唯一有根有序树的匹配括号字符串。输入中不包含括号以外的任何字符，且字符串长度至少为 $2$，最多不超过 $10^7$。", "outputFormat": "你的程序需要向标准输出写入数据。输出恰好一行。该行应包含从该有根有序树的根节点到所有叶节点的距离之和。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14732", "type": "P", "difficulty": 3, "samples": [["5 2 3\nCJ D5 HA C2 S7\nD5 HA\nCJ S7 C2", "4"], ["6 3 3\nC9 HK SQ SQ H2 CA\nCA HK SQ\nH2 C9 SQ", "4"], ["7 3 4\nS9 C10 DJ S6 S7 SA DQ\nDJ S6 S7\nS9 C10 SA DQ", "7"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["动态规划 DP", "2022", "ICPC", "首尔"], "title": "[ICPC 2022 Seoul R] Shuffle Game", "background": "", "description": "Shuffle Game is a simple card game between the dealer and the player. Initially, the same deck of $n$ cards is given to both the dealer and the player. Each card in the deck suits with one of the four symbols ($C, D, H,$ or $S$), followed by the one of 13 kinds ($2, 3, 4, 5, 6, 7, 8, 9, 10, A, J, K$ or $Q$). Therefore, there are 52 different types of cards and the same cards can exist in the deck. After the cards are given to the dealer and the player, the dealer first creates their own deck $X$ from the deck given to the dealer using any shuffling method and shows $X$ to the player. After that, the player creates the deck $Y$ by the following steps: $Y$ is initially empty.\n\n**Step 1.** Create two decks $P1$ and $P2$ from the deck given to the player. The number of cards in $P1$ and $P2$ can be different.\n\n**Step 2.** Interleave $P1$ and $P2$. That is, move a card at the bottom of $P1$ or $P2$ to the current top of $Y$, until there is no card on both $P1$ and $P2$. Note that the player does not need to move the cards in $P1$ and $P2$ alternately to $Y$. Also, since both the dealer and the player create their own deck from the same deck of $n$ cards, $Y$ always consists of the same cards as $X$.\n\nWe define a sequence of a deck as the sequence of the cards in the deck from bottom to top. Then the player’s score is defined as the length of the longest common subsequence between the sequences $X$ and $Y$. For example, suppose the deck of $n = 5$ cards, $(C2, CJ, D5, HA, S7)$ is given to both the dealer and the player (here, we represent the deck as its sequence). Then the dealer creates the deck $X = (CJ, D5, HA, C2, S7)$ and shows $X$ to the player. After that, the player creates their deck by (i) creating two decks $P1 = (D5, HA)$ and $P2 = (CJ, S7, C2)$ from the given deck and (ii) create $Y = (D5, CJ, S7, HA, C2)$ by interleaving $P1$ and $P2$. In this example, the player’s score is 3 since $(CJ, HA, C2)$ is the longest common subsequences between the sequences of $X$ and $Y$. Now, after finishing Step 1, the player wants to know the maximum possible score that the player can achieve after applying Step 2. For example, the maximum possible score from $X$ and $Y$ in the previous example is 4 since it is possible to create $Y$ from $P1$ and $P2$ as $(CJ, D5, HA, S7, C2)$.\n\nGiven $n, X, P1$ and $P2$, write a program to compute the maximum possible score that the player can achieve.\n", "inputFormat": "Your program is to read from standard input. The input starts with a line containing three positive integers $n$, $p$ and $q$ ($3 \\leq n \\leq 500$, $p + q = n$), where $n$ is the number of cards in the initial deck, and $p$ and $q$ are the number of cards in $P1$ and $P2$, respectively. In the following three lines, the dealer’s deck $X$ consisting of $n$ cards, and the player’s two decks $P1$ and $P2$ consisting of $p$ and $q$ cards, respectively, are given. Each card in $X$, $P1$, and $P2$ is represented as its suit (uppercase alphabet $C, D, H,$ or $S$) followed by its kind ($2, 3, 4, 5, 6, 7, 8, 9, 10$, uppercase alphabet $A, J, K$ or $Q$). The cards in the same line are ordered from bottom to top of the corresponding deck.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain the maximum possible score that the player can achieve from $X$, $P1$ and $P2$ after applying Step 2.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Seoul R] Shuffle Game", "background": "", "description": "Shuffle Game is a simple card game between the dealer and the player. Initially, the same deck of $n$ cards is given to both the dealer and the player. Each card in the deck suits with one of the four symbols ($C, D, H,$ or $S$), followed by the one of 13 kinds ($2, 3, 4, 5, 6, 7, 8, 9, 10, A, J, K$ or $Q$). Therefore, there are 52 different types of cards and the same cards can exist in the deck. After the cards are given to the dealer and the player, the dealer first creates their own deck $X$ from the deck given to the dealer using any shuffling method and shows $X$ to the player. After that, the player creates the deck $Y$ by the following steps: $Y$ is initially empty.\n\n**Step 1.** Create two decks $P1$ and $P2$ from the deck given to the player. The number of cards in $P1$ and $P2$ can be different.\n\n**Step 2.** Interleave $P1$ and $P2$. That is, move a card at the bottom of $P1$ or $P2$ to the current top of $Y$, until there is no card on both $P1$ and $P2$. Note that the player does not need to move the cards in $P1$ and $P2$ alternately to $Y$. Also, since both the dealer and the player create their own deck from the same deck of $n$ cards, $Y$ always consists of the same cards as $X$.\n\nWe define a sequence of a deck as the sequence of the cards in the deck from bottom to top. Then the player’s score is defined as the length of the longest common subsequence between the sequences $X$ and $Y$. For example, suppose the deck of $n = 5$ cards, $(C2, CJ, D5, HA, S7)$ is given to both the dealer and the player (here, we represent the deck as its sequence). Then the dealer creates the deck $X = (CJ, D5, HA, C2, S7)$ and shows $X$ to the player. After that, the player creates their deck by (i) creating two decks $P1 = (D5, HA)$ and $P2 = (CJ, S7, C2)$ from the given deck and (ii) create $Y = (D5, CJ, S7, HA, C2)$ by interleaving $P1$ and $P2$. In this example, the player’s score is 3 since $(CJ, HA, C2)$ is the longest common subsequences between the sequences of $X$ and $Y$. Now, after finishing Step 1, the player wants to know the maximum possible score that the player can achieve after applying Step 2. For example, the maximum possible score from $X$ and $Y$ in the previous example is 4 since it is possible to create $Y$ from $P1$ and $P2$ as $(CJ, D5, HA, S7, C2)$.\n\nGiven $n, X, P1$ and $P2$, write a program to compute the maximum possible score that the player can achieve.\n", "inputFormat": "Your program is to read from standard input. The input starts with a line containing three positive integers $n$, $p$ and $q$ ($3 \\leq n \\leq 500$, $p + q = n$), where $n$ is the number of cards in the initial deck, and $p$ and $q$ are the number of cards in $P1$ and $P2$, respectively. In the following three lines, the dealer’s deck $X$ consisting of $n$ cards, and the player’s two decks $P1$ and $P2$ consisting of $p$ and $q$ cards, respectively, are given. Each card in $X$, $P1$, and $P2$ is represented as its suit (uppercase alphabet $C, D, H,$ or $S$) followed by its kind ($2, 3, 4, 5, 6, 7, 8, 9, 10$, uppercase alphabet $A, J, K$ or $Q$). The cards in the same line are ordered from bottom to top of the corresponding deck.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain the maximum possible score that the player can achieve from $X$, $P1$ and $P2$ after applying Step 2.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Seoul R] Shuffle Game", "background": "", "description": "洗牌游戏是庄家和玩家之间的一种简单纸牌游戏。初始时，庄家和玩家都得到一副相同的 $n$ 张牌。牌堆中的每张牌由四种花色之一（$C$, $D$, $H$ 或 $S$）和 13 种点数之一（$2$, $3$, $4$, $5$, $6$, $7$, $8$, $9$, $10$, $A$, $J$, $K$ 或 $Q$）组成。因此，共有 $52$ 种不同类型的牌，且相同的牌可以在牌堆中出现多张。将牌分发给庄家和玩家后，庄家首先从自己得到的牌堆中通过任意洗牌方法创建自己的牌堆 $X$，并将其展示给玩家。之后，玩家通过以下步骤创建牌堆 $Y$：初始时 $Y$ 为空。\n\n**步骤 1.** 从玩家得到的牌堆中创建两个牌堆 $P1$ 和 $P2$。$P1$ 和 $P2$ 中的牌数可以不同。\n\n**步骤 2.** 交错合并 $P1$ 和 $P2$。即，将 $P1$ 或 $P2$ 底部的牌移至 $Y$ 的当前顶部，直到 $P1$ 和 $P2$ 中都没有牌为止。注意，玩家不需要交替地将 $P1$ 和 $P2$ 中的牌移至 $Y$。此外，由于庄家和玩家都从相同的 $n$ 张牌堆创建自己的牌堆，$Y$ 总是由与 $X$ 相同的牌组成。\n\n我们将一个牌堆的序列定义为从底部到顶部牌的顺序。那么玩家的得分定义为序列 $X$ 和 $Y$ 之间的最长公共子序列的长度。例如，假设庄家和玩家都得到 $n = 5$ 张牌的牌堆 $(C2, CJ, D5, HA, S7)$（这里，我们用其序列表示牌堆）。然后庄家创建牌堆 $X = (CJ, D5, HA, C2, S7)$ 并将其展示给玩家。之后，玩家通过以下方式创建自己的牌堆：(i) 从给定牌堆中创建两个牌堆 $P1 = (D5, HA)$ 和 $P2 = (CJ, S7, C2)$，以及 (ii) 通过交错合并 $P1$ 和 $P2$ 创建 $Y = (D5, CJ, S7, HA, C2)$。在此示例中，玩家的得分为 $3$，因为 $(CJ, HA, C2)$ 是 $X$ 和 $Y$ 序列之间的最长公共子序列。现在，在完成步骤 1 后，玩家希望在应用步骤 2 后知道自己可能获得的最大得分。例如，在前一个示例中，$X$ 和 $Y$ 的最大可能得分为 $4$，因为可以从 $P1$ 和 $P2$ 创建 $Y$ 为 $(CJ, D5, HA, S7, C2)$。\n\n给定 $n$、$X$、$P1$ 和 $P2$，请编写一个程序计算玩家可能获得的最大得分。", "inputFormat": "你的程序需要从标准输入读取数据。输入的第一行包含三个正整数 $n$、$p$ 和 $q$ ($3 \\leq n \\leq 500$, $p + q = n$)，其中 $n$ 是初始牌堆中的牌数，$p$ 和 $q$ 分别是 $P1$ 和 $P2$ 中的牌数。接下来的三行中，分别给出庄家的牌堆 $X$（包含 $n$ 张牌），以及玩家的两个牌堆 $P1$ 和 $P2$（分别包含 $p$ 和 $q$ 张牌）。$X$、$P1$ 和 $P2$ 中的每张牌由其花色（大写字母 $C$、$D$、$H$ 或 $S$）和点数（$2$、$3$、$4$、$5$、$6$、$7$、$8$、$9$、$10$，或大写字母 $A$、$J$、$K$、$Q$）表示。同一行中的牌按对应牌堆从底部到顶部的顺序排列。", "outputFormat": "你的程序需要向标准输出写入数据。输出恰好一行。该行应包含玩家在应用步骤 2 后，基于 $X$、$P1$ 和 $P2$ 可能获得的最大得分。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14733", "type": "P", "difficulty": 4, "samples": [["4\n1 2\n1 3\n1 4\n2 3\n2 4", "3\n1 2 3\n1 2 4"], ["5\n1 2\n1 3\n1 4\n1 5\n2 3\n2 5\n3 4", "3\n1 2 3\n1 3 4"], ["7\n1 2\n3 4\n5 6\n5 2\n3 1\n6 1\n4 2\n4 5\n2 6\n3 6\n1 5", "4\n6 1 5 2\n4 2 1 3"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2022", "Special Judge", "ICPC", "首尔"], "title": "[ICPC 2022 Seoul R] Two Choreographies", "background": "", "description": "Somim and Eunjoo are famous dancers and very talented choreographers, but they haven't won a contest recently. To win the contest this year, they are trying to help each other to make new choreographies. Actually, nobody has tried smoothly appending static motions, and they are going to give it a try for the first time!\n\nSomim and Eunjoo want to make two choreographies consisting of $n$ static motions for each of them. They have a good understanding of how to smoothly append static motions, and they concluded that exactly $2n - 3$ unordered pairs of static motions are enough for them to perform freely. The order of static motions in a pair $\\{A, B\\}$ does not matter, i.e., if motion $B$ can be appended after motion $A$, then $A$ can also be appended after $B$.\n\nThe choreographies which Somim and Eunjoo want to perform are as follows. The two choreographies last for the same amount of time, which means that each one should consist of the same number of static motions. Each choreography should end at its first static motion. More precisely, two choreographies $C_1$ and $C_2$ are sequences of distinct $l$ static motions, $C_1 = (a_0, a_1, ..., a_l)$ and $C_2 = (b_0, b_1, ..., b_l)$ where $a_0 = a_l$ and $b_0 = b_l$. For the entertainment of the audience, $C_1$ and $C_2$ should be different, that is, there should be some $0 \\leq i \\leq l - 1$ which $\\{a_i, a_{i+1}\\}$ in $C_1$ is not equal to any of $\\{b_j, b_{j+1}\\}$ in $C_2$ for $0 \\leq j \\leq l - 1$. (For example, $(1,2,3,4,5,1)$ and $(3,4,5,2,1,3)$ are different but $(1,2,3,4,5,1)$ and $(3,4,5,1,2,3)$ are not.) Also, the audience easily gets bored, so the choreography should not be too short, and contain at least 3 distinct static motions, that is, $l \\geq 3$.\n\nFor this, you are given $2n - 3$ unordered pairs $P$ of static motions from $n$ distinct static motions $m_1, ..., m_n$ that two dancers can perform. For a pair $\\{m_i, m_j\\}$ where $i \\neq j$, one of $m_i$ and $m_j$ can appear after the other in the sequence; there is no specific order between them. You should write a program to find two different choreographies $C_1 = (a_0, a_1, ..., a_l)$ and $C_2 = (b_0, b_1, ..., b_l)$ of the same length $l \\geq 3$ such that $\\{a_i, a_{i+1}\\} \\in P$, $\\{b_i, b_{i+1}\\} \\in P$ for any $0 \\leq i \\leq l - 1$, and $a_0 = a_l$ and $b_0 = b_l$.\n", "inputFormat": "Your program is to read from standard input. The input starts with a line containing a single integer, $n$ ($4 \\leq n \\leq 100,000$), where $n$ is the number of static motions two dancers can represent. Each static motion is numbered as an integer from 1 to $n$. The following $2n - 3$ lines represent $2n - 3$ unordered pairs of static motions, $P$. Each line contains two distinct integers representing two static motions of a pair of $P$. Note that no two pairs in $P$ are identical.\n", "outputFormat": "Your program is to write to standard output. If you cannot find two choreographies of static motions, then print $-1$. If not, you should print exactly three lines. The first line contains an integer $l \\geq 3$ which is the number of distinct static motions in each choreography. The second line contains exactly $l$ integers, separated by a space, each representing a choreography of the $l$ static motions in order. The last repeated motion should be omitted. The third line contains exactly $l$ integers representing the other choreography.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Seoul R] Two Choreographies", "background": "", "description": "Somim and Eunjoo are famous dancers and very talented choreographers, but they haven't won a contest recently. To win the contest this year, they are trying to help each other to make new choreographies. Actually, nobody has tried smoothly appending static motions, and they are going to give it a try for the first time!\n\nSomim and Eunjoo want to make two choreographies consisting of $n$ static motions for each of them. They have a good understanding of how to smoothly append static motions, and they concluded that exactly $2n - 3$ unordered pairs of static motions are enough for them to perform freely. The order of static motions in a pair $\\{A, B\\}$ does not matter, i.e., if motion $B$ can be appended after motion $A$, then $A$ can also be appended after $B$.\n\nThe choreographies which Somim and Eunjoo want to perform are as follows. The two choreographies last for the same amount of time, which means that each one should consist of the same number of static motions. Each choreography should end at its first static motion. More precisely, two choreographies $C_1$ and $C_2$ are sequences of distinct $l$ static motions, $C_1 = (a_0, a_1, ..., a_l)$ and $C_2 = (b_0, b_1, ..., b_l)$ where $a_0 = a_l$ and $b_0 = b_l$. For the entertainment of the audience, $C_1$ and $C_2$ should be different, that is, there should be some $0 \\leq i \\leq l - 1$ which $\\{a_i, a_{i+1}\\}$ in $C_1$ is not equal to any of $\\{b_j, b_{j+1}\\}$ in $C_2$ for $0 \\leq j \\leq l - 1$. (For example, $(1,2,3,4,5,1)$ and $(3,4,5,2,1,3)$ are different but $(1,2,3,4,5,1)$ and $(3,4,5,1,2,3)$ are not.) Also, the audience easily gets bored, so the choreography should not be too short, and contain at least 3 distinct static motions, that is, $l \\geq 3$.\n\nFor this, you are given $2n - 3$ unordered pairs $P$ of static motions from $n$ distinct static motions $m_1, ..., m_n$ that two dancers can perform. For a pair $\\{m_i, m_j\\}$ where $i \\neq j$, one of $m_i$ and $m_j$ can appear after the other in the sequence; there is no specific order between them. You should write a program to find two different choreographies $C_1 = (a_0, a_1, ..., a_l)$ and $C_2 = (b_0, b_1, ..., b_l)$ of the same length $l \\geq 3$ such that $\\{a_i, a_{i+1}\\} \\in P$, $\\{b_i, b_{i+1}\\} \\in P$ for any $0 \\leq i \\leq l - 1$, and $a_0 = a_l$ and $b_0 = b_l$.\n", "inputFormat": "Your program is to read from standard input. The input starts with a line containing a single integer, $n$ ($4 \\leq n \\leq 100,000$), where $n$ is the number of static motions two dancers can represent. Each static motion is numbered as an integer from 1 to $n$. The following $2n - 3$ lines represent $2n - 3$ unordered pairs of static motions, $P$. Each line contains two distinct integers representing two static motions of a pair of $P$. Note that no two pairs in $P$ are identical.\n", "outputFormat": "Your program is to write to standard output. If you cannot find two choreographies of static motions, then print $-1$. If not, you should print exactly three lines. The first line contains an integer $l \\geq 3$ which is the number of distinct static motions in each choreography. The second line contains exactly $l$ integers, separated by a space, each representing a choreography of the $l$ static motions in order. The last repeated motion should be omitted. The third line contains exactly $l$ integers representing the other choreography.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Seoul R] Two Choreographies", "background": "", "description": "Somim 和 Eunjoo 是著名的舞者和非常有才华的编舞家，但他们最近没有赢得比赛。为了今年赢得比赛，他们正试图互相帮助创作新的编舞。实际上，还没有人尝试过流畅地衔接静态动作，而他们将首次尝试！\n\nSomim 和 Eunjoo 想为各自创作一套包含 $n$ 个静态动作的编舞。他们非常了解如何流畅地衔接静态动作，并得出结论：恰好 $2n - 3$ 个无序静态动作对足以让他们自由表演。动作对 $\\{A, B\\}$ 的顺序无关紧要，即如果动作 $B$ 可以在动作 $A$ 之后衔接，那么 $A$ 也可以在 $B$ 之后衔接。\n\nSomim 和 Eunjoo 想要表演的编舞如下：两套编舞持续时间相同，这意味着每套编舞应包含相同数量的静态动作。每套编舞应以其第一个静态动作结束。更准确地说，两套编舞 $C_1$ 和 $C_2$ 是由 $l$ 个不同的静态动作组成的序列，$C_1 = (a_0, a_1, ..., a_l)$ 且 $C_2 = (b_0, b_1, ..., b_l)$，其中 $a_0 = a_l$ 且 $b_0 = b_l$。为了让观众感到有趣，$C_1$ 和 $C_2$ 应该不同，即存在某个 $0 \\leq i \\leq l - 1$，使得 $C_1$ 中的 $\\{a_i, a_{i+1}\\}$ 不等于 $C_2$ 中任何 $0 \\leq j \\leq l - 1$ 对应的 $\\{b_j, b_{j+1}\\}$。（例如，$(1,2,3,4,5,1)$ 和 $(3,4,5,2,1,3)$ 是不同的，但 $(1,2,3,4,5,1)$ 和 $(3,4,5,1,2,3)$ 是相同的。）此外，观众容易感到无聊，所以编舞不能太短，必须包含至少 $3$ 个不同的静态动作，即 $l \\geq 3$。\n\n为此，给定 $2n - 3$ 个无序动作对 $P$，这些动作对来自 $n$ 个不同的静态动作 $m_1, ..., m_n$，两位舞者可以表演。对于一对 $\\{m_i, m_j\\}$（$i \\neq j$），$m_i$ 和 $m_j$ 中的一个可以在序列中出现在另一个之后；它们之间没有特定的顺序。你需要编写一个程序，找出两套不同的编舞 $C_1 = (a_0, a_1, ..., a_l)$ 和 $C_2 = (b_0, b_1, ..., b_l)$，长度相同且 $l \\geq 3$，使得对于任意 $0 \\leq i \\leq l - 1$，有 $\\{a_i, a_{i+1}\\} \\in P$，$\\{b_i, b_{i+1}\\} \\in P$，且 $a_0 = a_l$，$b_0 = b_l$。", "inputFormat": "你的程序需要从标准输入读取数据。输入的第一行包含一个整数 $n$ ($4 \\leq n \\leq 100,000$)，其中 $n$ 是两位舞者可以表演的静态动作数量。每个静态动作被编号为 $1$ 到 $n$ 的整数。接下来的 $2n - 3$ 行表示 $2n - 3$ 个无序静态动作对 $P$。每行包含两个不同的整数，表示 $P$ 中的一个动作对。注意，$P$ 中没有两个对是相同的。", "outputFormat": "你的程序需要向标准输出写入数据。如果你找不到两套静态动作编舞，则输出 $-1$。否则，你应该恰好输出三行。第一行包含一个整数 $l \\geq 3$，表示每套编舞中不同静态动作的数量。第二行包含恰好 $l$ 个整数，用空格分隔，按顺序表示一套编舞的 $l$ 个静态动作。最后一个重复的动作应省略。第三行包含恰好 $l$ 个整数，表示另一套编舞。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14734", "type": "P", "difficulty": 6, "samples": [["5 5\n1 2 2 2 1\n1 2\n3 1\n3 4\n3 5\nQ 2 5 2\nQ 2 4 2\nU 3 3\nQ 2 5 2\nQ 2 4 2", "2\n1\n-1\n3"], ["4 6\n2 1 1 1\n1 2\n1 3\n1 4\nQ 2 3 1\nQ 2 4 1\nQ 3 4 1\nU 1 1\nQ 2 3 1\nQ 2 4 1", "2\n2\n2\n1\n1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "2021", "树链剖分", "ICPC", "首尔"], "title": "[ICPC 2021 Seoul R] Ant Colonies", "background": "", "description": "A group of scientists analyzed an ant nest where several ant colonies live. They found that the ant nest is a tree structure in which each node represents the physical place where an ant colony lives, and each edge represents a tunnel connecting two ant colonies. The most interesting thing is that each colony has exactly one color and it sometimes changes its color. The color change mechanism depends on the closest pair of colonies with a certain color $c$ among the colonies lying on the path between two given colonies $A$ and $B$. The distance between two colonies is the number of tunnels of the path connecting them, that is, the number of edges of the path connecting two corresponding nodes in the tree structure.\n\nFor example, Figure A.1 (a) shows a tree structure with five ant colonies numbered 1 to 5 of colors $1, 2, 2, 2, 1$, labelled in orange above the colonies, in order from colony 1 to colony 5, respectively. For color $2$ and two colonies $2$ and $5$, the closest pair of colonies with color $2$ on the path between colony $2$ and colony $5$ is the pair (colony $2$, colony $3$). But for colony $2$ and colony $4$, the closest pair with color $2$ is the pair (colony $3$, colony $4$).\n\nSuppose now that the current color $2$ of colony $3$ changes to color $3$ as shown in Figure A.1 (b). Then there is no closest pair of colonies with color $2$ on the path between colony $2$ and colony $5$ because only one colony has color $2$. The closest pair with color $2$ for colony $2$ and colony $4$ becomes (colony $2$, colony $4$).\n\nGiven colors of ant colonies, a tree structure of the ant nest, and an ordered list of update commands for the color change and query commands for the closest pair, write a program to find the closest pair of colonies with color $c$ between the two colonies $A$ and $B$ for each query $(A, B, c)$.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/qi82z0p0.png)\n\nFigure A.1 An ant nest with five colonies. The numbers in orange represent colony colors.\n:::", "inputFormat": "Your program is to read from standard input. The input starts with a line containing two integers, $n$ and $q$ ($2 \\leq n \\leq 100,000$, $2 \\leq q \\leq 100,000$), where $n$ is the number of ant colonies and $q$ is the number of update and query commands. Ant colonies are numbered from $1$ to $n$, and colors are identified with integers from $\\{1,2,...,n\\}$. The next line consists of $n$ positive integers representing colors for ant colonies, in order from colony $1$ to colony $n$. In the following $n-1$ lines, the $i$-th line contains a pair of integers $a_i, b_i$ ($1 \\leq a_i, b_i \\leq n, a_i \\neq b_i$) specifying the numbers of two ant colonies connected by a tunnel, which corresponds to an edge in the tree structure. In the following $q$ lines, the $i$-th line has a form of $(S,A,c)$ or $(S,A,B,c)$, where $S$ is a single uppercase character either 'U' or 'Q', representing the update and the query, respectively. In the case that $S = U$, it has the form of $(S,A,c)$ which is an update command to change (update) the current color of colony $A$ to color $c$ ($1 \\leq A, c \\leq n$). In the case of $S = Q$, it has the form of $(S,A,B,c)$ which is a query command to output the distance of the closest pair of colonies with color $c$ on the path between colony $A$ and colony $B$ ($1 \\leq A,B,c \\leq n$). These commands must be executed in the order given in the input.", "outputFormat": "Your program is to write to standard output. For every query $(S,A,B,c)$ with $S = Q$, print exactly one line containing the distance of the closest pair of colonies with color $c$ on the path between colonies $A$ and $B$ under the current status of the ant nest. If there is no pair with color $c$ between them, print $-1$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Seoul R] Ant Colonies", "background": "", "description": "A group of scientists analyzed an ant nest where several ant colonies live. They found that the ant nest is a tree structure in which each node represents the physical place where an ant colony lives, and each edge represents a tunnel connecting two ant colonies. The most interesting thing is that each colony has exactly one color and it sometimes changes its color. The color change mechanism depends on the closest pair of colonies with a certain color $c$ among the colonies lying on the path between two given colonies $A$ and $B$. The distance between two colonies is the number of tunnels of the path connecting them, that is, the number of edges of the path connecting two corresponding nodes in the tree structure.\n\nFor example, Figure A.1 (a) shows a tree structure with five ant colonies numbered 1 to 5 of colors $1, 2, 2, 2, 1$, labelled in orange above the colonies, in order from colony 1 to colony 5, respectively. For color $2$ and two colonies $2$ and $5$, the closest pair of colonies with color $2$ on the path between colony $2$ and colony $5$ is the pair (colony $2$, colony $3$). But for colony $2$ and colony $4$, the closest pair with color $2$ is the pair (colony $3$, colony $4$).\n\nSuppose now that the current color $2$ of colony $3$ changes to color $3$ as shown in Figure A.1 (b). Then there is no closest pair of colonies with color $2$ on the path between colony $2$ and colony $5$ because only one colony has color $2$. The closest pair with color $2$ for colony $2$ and colony $4$ becomes (colony $2$, colony $4$).\n\nGiven colors of ant colonies, a tree structure of the ant nest, and an ordered list of update commands for the color change and query commands for the closest pair, write a program to find the closest pair of colonies with color $c$ between the two colonies $A$ and $B$ for each query $(A, B, c)$.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/qi82z0p0.png)\n\nFigure A.1 An ant nest with five colonies. The numbers in orange represent colony colors.\n:::", "inputFormat": "Your program is to read from standard input. The input starts with a line containing two integers, $n$ and $q$ ($2 \\leq n \\leq 100,000$, $2 \\leq q \\leq 100,000$), where $n$ is the number of ant colonies and $q$ is the number of update and query commands. Ant colonies are numbered from $1$ to $n$, and colors are identified with integers from $\\{1,2,...,n\\}$. The next line consists of $n$ positive integers representing colors for ant colonies, in order from colony $1$ to colony $n$. In the following $n-1$ lines, the $i$-th line contains a pair of integers $a_i, b_i$ ($1 \\leq a_i, b_i \\leq n, a_i \\neq b_i$) specifying the numbers of two ant colonies connected by a tunnel, which corresponds to an edge in the tree structure. In the following $q$ lines, the $i$-th line has a form of $(S,A,c)$ or $(S,A,B,c)$, where $S$ is a single uppercase character either 'U' or 'Q', representing the update and the query, respectively. In the case that $S = U$, it has the form of $(S,A,c)$ which is an update command to change (update) the current color of colony $A$ to color $c$ ($1 \\leq A, c \\leq n$). In the case of $S = Q$, it has the form of $(S,A,B,c)$ which is a query command to output the distance of the closest pair of colonies with color $c$ on the path between colony $A$ and colony $B$ ($1 \\leq A,B,c \\leq n$). These commands must be executed in the order given in the input.", "outputFormat": "Your program is to write to standard output. For every query $(S,A,B,c)$ with $S = Q$, print exactly one line containing the distance of the closest pair of colonies with color $c$ on the path between colonies $A$ and $B$ under the current status of the ant nest. If there is no pair with color $c$ between them, print $-1$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Seoul R] Ant Colonies", "background": "", "description": "一组科学家研究了一个居住着多个蚁群的蚁巢。他们发现蚁巢是一种树形结构，其中每个节点代表一个蚁群生活的物理位置，每条边代表连接两个蚁群的隧道。最有趣的是，每个蚁群恰好有一种颜色，并且有时会改变其颜色。颜色变化机制依赖于两个给定蚁群 $A$ 和 $B$ 之间路径上所有蚁群中，具有特定颜色 $c$ 的**最近的一对蚁群**。两个蚁群之间的距离是连接它们的路径上的隧道数量，即树形结构中连接两个对应节点的路径上的边数。\n\n例如，图 A.1 (a) 展示了一个包含五个蚁群的树形结构，蚁群编号从 $1$ 到 $5$，颜色分别为 $1, 2, 2, 2, 1$（用橙色标签标在蚁群上方）。对于颜色 $2$ 和两个蚁群 $2$ 与 $5$，在蚁群 $2$ 和蚁群 $5$ 之间路径上具有颜色 $2$ 的最近一对蚁群是（蚁群 $2$, 蚁群 $3$）。但对于蚁群 $2$ 和蚁群 $4$，具有颜色 $2$ 的最近一对是（蚁群 $3$, 蚁群 $4$）。\n\n假设现在蚁群 $3$ 的当前颜色 $2$ 变为颜色 $3$，如图 A.1 (b) 所示。那么在蚁群 $2$ 和蚁群 $5$ 之间的路径上，就不存在具有颜色 $2$ 的最近一对蚁群，因为只有一个蚁群具有颜色 $2$。对于蚁群 $2$ 和蚁群 $4$，具有颜色 $2$ 的最近一对变为（蚁群 $2$, 蚁群 $4$）。\n\n给定蚁群的颜色、蚁巢的树形结构以及颜色更新的命令列表和查询最近一对的查询命令，请编写一个程序，针对每个查询 $(A, B, c)$，找出蚁群 $A$ 和 $B$ 之间路径上具有颜色 $c$ 的最近一对蚁群。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/qi82z0p0.png)\n\n图 A.1 一个包含五个蚁群的蚁巢。橙色数字表示蚁群颜色。\n:::", "inputFormat": "你的程序需要从标准输入读取数据。输入的第一行包含两个整数 $n$ 和 $q$ ($2 \\leq n \\leq 100,000$, $2 \\leq q \\leq 100,000$)，其中 $n$ 是蚁群的数量，$q$ 是更新和查询命令的数量。蚁群编号从 $1$ 到 $n$，颜色用 $1$ 到 $n$ 的整数标识。第二行包含 $n$ 个正整数，按从蚁群 $1$ 到蚁群 $n$ 的顺序表示蚁群的颜色。接下来的 $n-1$ 行中，第 $i$ 行包含两个整数 $a_i, b_i$ ($1 \\leq a_i, b_i \\leq n, a_i \\neq b_i$)，表示由一条隧道连接的两个蚁群的编号，对应树形结构中的一条边。接下来的 $q$ 行中，第 $i$ 行的格式为 $(S,A,c)$ 或 $(S,A,B,c)$，其中 $S$ 是一个大写字符，取值为 'U' 或 'Q'，分别代表更新和查询。如果 $S = U$，则格式为 $(S,A,c)$，这是一个更新命令，表示将蚁群 $A$ 的当前颜色更改为颜色 $c$ ($1 \\leq A, c \\leq n$)。如果 $S = Q$，则格式为 $(S,A,B,c)$，这是一个查询命令，要求输出在蚁群 $A$ 和 $B$ 之间路径上具有颜色 $c$ 的最近一对蚁群的距离 ($1 \\leq A,B,c \\leq n$)。这些命令必须按照输入中给出的顺序执行。", "outputFormat": "你的程序需要向标准输出写入数据。对于每个 $S = Q$ 的查询 $(S,A,B,c)$，输出恰好一行，包含在当前蚁巢状态下，蚁群 $A$ 和 $B$ 之间路径上具有颜色 $c$ 的最近一对蚁群的距离。如果它们之间不存在具有颜色 $c$ 的蚁群对，则输出 $-1$。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14735", "type": "P", "difficulty": 3, "samples": [["10 4\n1\n2\n3\n1\n1\n4\n2\n4\n3\n3", "5"], ["6 3\n1\n1\n2\n2\n3\n3", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["单调队列", "2021", "ICPC", "双指针 two-pointer", "首尔"], "title": "[ICPC 2021 Seoul R] Double Rainbow", "background": "", "description": "Let $P$ be a set of $n$ points on the x-axis and each of the points is colored with one of the colors $1, 2, \\ldots, k$. For each color $i$ of the $k$ colors, there is at least one point in $P$ which is colored with $i$. For a set $P'$ of consecutive points from $P$, if both $P'$ and $P \\setminus P'$ contain at least one point of each color, then we say that $P'$ makes a **double rainbow**. See the below figure as an example. The set $P$ consists of ten points and each of the points is colored by one of the colors $1, 2, 3$, and $4$. The set $P'$ of the five consecutive points contained in the rectangle makes a double rainbow.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/irrqpjlt.png)\n:::\n\nGiven a set $P$ of points and the number $k$ of colors as input, write a program that computes and prints out the minimum size of $P'$ that makes a double rainbow.", "inputFormat": "Your program is to read from standard input. The input starts with a line containing two integers $n$ and $k$ ($1 \\leq k \\leq n \\leq 10,000$), where $n$ is the number of the points in $P$ and $k$ is the number of the colors. Each of the following $n$ lines consists of an integer from $1$ to $k$, inclusively, and the $i$-th line corresponds to the color of the $i$-th point of $P$ from the left.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain the minimum size of $P'$ that makes a double rainbow. If there is no such $P'$, print $0$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Seoul R] Double Rainbow", "background": "", "description": "Let $P$ be a set of $n$ points on the x-axis and each of the points is colored with one of the colors $1, 2, \\ldots, k$. For each color $i$ of the $k$ colors, there is at least one point in $P$ which is colored with $i$. For a set $P'$ of consecutive points from $P$, if both $P'$ and $P \\setminus P'$ contain at least one point of each color, then we say that $P'$ makes a **double rainbow**. See the below figure as an example. The set $P$ consists of ten points and each of the points is colored by one of the colors $1, 2, 3$, and $4$. The set $P'$ of the five consecutive points contained in the rectangle makes a double rainbow.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/irrqpjlt.png)\n:::\n\nGiven a set $P$ of points and the number $k$ of colors as input, write a program that computes and prints out the minimum size of $P'$ that makes a double rainbow.", "inputFormat": "Your program is to read from standard input. The input starts with a line containing two integers $n$ and $k$ ($1 \\leq k \\leq n \\leq 10,000$), where $n$ is the number of the points in $P$ and $k$ is the number of the colors. Each of the following $n$ lines consists of an integer from $1$ to $k$, inclusively, and the $i$-th line corresponds to the color of the $i$-th point of $P$ from the left.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain the minimum size of $P'$ that makes a double rainbow. If there is no such $P'$, print $0$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Seoul R] Double Rainbow", "background": "", "description": "设 $P$ 是 $x$ 轴上 $n$ 个点的集合，每个点被染成 $k$ 种颜色 $1, 2, \\ldots, k$ 中的一种。对于 $k$ 种颜色中的每种颜色 $i$，$P$ 中至少有一个点被染成颜色 $i$。对于 $P$ 的一个连续点子集 $P'$，如果 $P'$ 和 $P \\setminus P'$ 都包含每种颜色的至少一个点，那么我们称 $P'$ 构成一个 **双彩虹**。请参见下图作为示例。集合 $P$ 包含十个点，每个点被染成颜色 $1$、$2$、$3$、$4$ 之一。矩形中包含的五个连续点组成的集合 $P'$ 构成了一个双彩虹。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/irrqpjlt.png)\n:::\n\n给定点集 $P$ 和颜色数量 $k$ 作为输入，请编写一个程序，计算并输出构成双彩虹的 $P'$ 的最小大小。", "inputFormat": "你的程序需要从标准输入读取数据。输入的第一行包含两个整数 $n$ 和 $k$ ($1 \\leq k \\leq n \\leq 10,000$)，其中 $n$ 是 $P$ 中点的数量，$k$ 是颜色的数量。接下来的 $n$ 行每行包含一个 $1$ 到 $k$（含）之间的整数，第 $i$ 行对应于 $P$ 中从左数第 $i$ 个点的颜色。", "outputFormat": "你的程序需要向标准输出写入数据。输出恰好一行。该行应包含构成双彩虹的 $P'$ 的最小大小。如果不存在这样的 $P'$，则输出 $0$。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14736", "type": "P", "difficulty": 2, "samples": [["4\n3 R 4\n0 L 2\n7 L 5\n-2 R 5\n0", "2"], ["5\n3 L 3\n-1 R 11\n5 L 6\n1 R 4\n10 L 7\n1", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["模拟", "2021", "ICPC", "首尔"], "title": "[ICPC 2021 Seoul R] Find the House", "background": "", "description": "Younghee is currently on a one-dimensional road and looking for her friend Jisun's house. To know the exact position of Jisun's house, Younghee sends a message to Jisun with her current position (assume that all the positions are represented as integers). A couple of minutes later, Younghee gets a reply as a list of $n$ triples from Jisun with an additional explanation as follows:\n\n- For each triple $(i, j, k)$ in the list, $i$ is an integer which denotes the current position, $j$ denotes the direction to move from $i$, represented as $L$ (left) or $R$ (right), and $k$ is a positive integer which denotes the distance to move from $i$.\n- For any two triples $(i, j, k)$ and $(i', j', k')$ in the list, $i$ and $i'$ are distinct.\n- If you are currently on the position $i$, there always exists a triple $(i, j, k)$ in the list (unless all the triples in the list are referred before). In this case, refer to the triple $(i, j, k)$ and move to $i - k$ (if $j = L$) or $i + k$ (if $j = R$).\n- Each of the triples in the list is referred exactly once.\n- The position after referring to all the triples in the list is a position of Jisun's house.\n\nFor example, suppose Younghee is currently at the position $0$ with a list of four triples -- $(3, R, 4)$, $(0, L, 2)$, $(7, L, 5)$, and $(-2, R, 5)$. Then Younghee first refers to the triple $(0, L, 2)$ and move to the position $0 - 2 = -2$. After that, Younghee refers to the triples $(-2, R, 5)$, $(3, R, 4)$, and $(7, L, 5)$ in order and moves to the position $2$, which is the position of Jisun's house. Given $n$, Younghee's current position, and a list of $n$ triples, write a program to find Jisun's house's position.", "inputFormat": "Your program is to read from standard input. The input starts with a line containing an integer $n$ ($1 \\leq n \\leq 10,000$), where $n$ is the number of triples in the list. In the following $n$ lines, $n$ triples are given where each triple is represented as three values $i$, $j$, and $k$, consisting of two integers $i$ and $j$ and one character $k$ ($-1,000,000 \\leq i \\leq 1,000,000$, $j \\in \\{L, R\\}$, and $1 \\leq k \\leq 2,000,000$). After $n$ lines of triples, there is a line containing Younghee's current position as an integer between $-1,000,000$ and $1,000,000$.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain the position of Jisun's house.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Seoul R] Find the House", "background": "", "description": "Younghee is currently on a one-dimensional road and looking for her friend Jisun's house. To know the exact position of Jisun's house, Younghee sends a message to Jisun with her current position (assume that all the positions are represented as integers). A couple of minutes later, Younghee gets a reply as a list of $n$ triples from Jisun with an additional explanation as follows:\n\n- For each triple $(i, j, k)$ in the list, $i$ is an integer which denotes the current position, $j$ denotes the direction to move from $i$, represented as $L$ (left) or $R$ (right), and $k$ is a positive integer which denotes the distance to move from $i$.\n- For any two triples $(i, j, k)$ and $(i', j', k')$ in the list, $i$ and $i'$ are distinct.\n- If you are currently on the position $i$, there always exists a triple $(i, j, k)$ in the list (unless all the triples in the list are referred before). In this case, refer to the triple $(i, j, k)$ and move to $i - k$ (if $j = L$) or $i + k$ (if $j = R$).\n- Each of the triples in the list is referred exactly once.\n- The position after referring to all the triples in the list is a position of Jisun's house.\n\nFor example, suppose Younghee is currently at the position $0$ with a list of four triples -- $(3, R, 4)$, $(0, L, 2)$, $(7, L, 5)$, and $(-2, R, 5)$. Then Younghee first refers to the triple $(0, L, 2)$ and move to the position $0 - 2 = -2$. After that, Younghee refers to the triples $(-2, R, 5)$, $(3, R, 4)$, and $(7, L, 5)$ in order and moves to the position $2$, which is the position of Jisun's house. Given $n$, Younghee's current position, and a list of $n$ triples, write a program to find Jisun's house's position.", "inputFormat": "Your program is to read from standard input. The input starts with a line containing an integer $n$ ($1 \\leq n \\leq 10,000$), where $n$ is the number of triples in the list. In the following $n$ lines, $n$ triples are given where each triple is represented as three values $i$, $j$, and $k$, consisting of two integers $i$ and $j$ and one character $k$ ($-1,000,000 \\leq i \\leq 1,000,000$, $j \\in \\{L, R\\}$, and $1 \\leq k \\leq 2,000,000$). After $n$ lines of triples, there is a line containing Younghee's current position as an integer between $-1,000,000$ and $1,000,000$.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain the position of Jisun's house.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Seoul R] Find the House", "background": "", "description": "Younghee 目前正在一条一维道路上寻找她的朋友 Jisun 的家。为了知道 Jisun 家的确切位置，Younghee 向 Jisun 发送了一条消息，告知她自己当前的位置（假设所有位置都用整数表示）。几分钟后，Younghee 收到了 Jisun 的回复，是一个包含 $n$ 个三元组的列表，并附有如下说明：\n\n- 对于列表中的每个三元组 $(i, j, k)$，$i$ 是一个表示当前位置的整数，$j$ 表示从 $i$ 出发的移动方向，用 $L$（左）或 $R$（右）表示，$k$ 是一个正整数，表示从 $i$ 出发移动的距离。\n- 对于列表中任意两个三元组 $(i, j, k)$ 和 $(i', j', k')$，$i$ 和 $i'$ 是不同的。\n- 如果你当前在位置 $i$，列表中总是存在一个三元组 $(i, j, k)$（除非列表中的所有三元组都已被引用过）。在这种情况下，引用该三元组 $(i, j, k)$ 并移动到 $i - k$（如果 $j = L$）或 $i + k$（如果 $j = R$）。\n- 列表中的每个三元组恰好被引用一次。\n- 引用完列表中所有三元组后的位置，就是 Jisun 家的位置。\n\n例如，假设 Younghee 当前在位置 $0$，并有一个包含四个三元组的列表：$(3, R, 4)$、$(0, L, 2)$、$(7, L, 5)$ 和 $(-2, R, 5)$。那么 Younghee 首先引用三元组 $(0, L, 2)$，并移动到位置 $0 - 2 = -2$。之后，Younghee 按顺序引用三元组 $(-2, R, 5)$、$(3, R, 4)$ 和 $(7, L, 5)$，并移动到位置 $2$，这就是 Jisun 家的位置。给定 $n$、Younghee 的当前位置以及一个包含 $n$ 个三元组的列表，请编写一个程序来找到 Jisun 家的位置。", "inputFormat": "你的程序需要从标准输入读取数据。输入的第一行包含一个整数 $n$ ($1 \\leq n \\leq 10,000$)，其中 $n$ 是列表中三元组的数量。接下来的 $n$ 行中，给出了 $n$ 个三元组，每个三元组由三个值 $i$、$j$ 和 $k$ 表示，包括两个整数 $i$ 和 $k$ 以及一个字符 $j$ ($-1,000,000 \\leq i \\leq 1,000,000$, $j \\in \\{L, R\\}$, $1 \\leq k \\leq 2,000,000$)。在 $n$ 行三元组之后，有一行包含一个整数，表示 Younghee 的当前位置（在 $-1,000,000$ 到 $1,000,000$ 之间）。", "outputFormat": "你的程序需要向标准输出写入数据。输出恰好一行。该行应包含 Jisun 家的位置。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14737", "type": "P", "difficulty": 4, "samples": [["7 13\n1 2\n2 3\n3 1\n3 4\n3 5\n3 6\n3 7\n4 5\n5 7\n7 6\n6 4\n4 7\n5 6", "1"], ["5 5\n1 2\n2 3\n3 4\n4 5\n5 1", "-1"], ["4 4\n4 3\n3 2\n2 1\n1 4", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["图论", "2021", "ICPC", "bitset", "首尔"], "title": "[ICPC 2021 Seoul R] Friendship Graphs", "background": "", "description": "Given a collection of people who interact, we can define a graph whose vertices are people, with an edge between two people if and only if they are friends with one another. Such graphs are called **social networks** and are well defined on any set of people, for example, the students in a college or the residents of a small town. An entire science analyzing social networks has sprung up in recent years, because many interesting aspects of people and their behavior are best understood as properties of this **friendship graph**.\n\nGiven a friendship graph where the vertices are the students in the Problem Solving class, your job is to write a program that decomposes the students in the class into two groups, $A$ and $B$, so that the following three conditions are satisfied simultaneously:\n\n- Each student in the class belongs to exactly one group, $A$ or $B$.\n- Any two students in each group are friends with each other.\n- The difference between the sizes of groups $A$ and $B$, denoted as $||A| - |B||$, is as small as possible.\n\nFor example, suppose we are given a friendship graph shown in the figure below. Decomposing the students into $A = \\{u_1, u_2, u_3, u_6\\}$ and $B = \\{u_4, u_5, u_7\\}$ is not possible because $u_2$ and $u_6$ are not friends. On the other hand, in the decomposition into $A = \\{u_1, u_2\\}$ and $B = \\{u_3, u_4, u_5, u_6, u_7\\}$, any two students in each group are friends with each other; however, the size difference ($|2 - 5| = 3$) between the two groups is larger than the difference ($|3 - 4| = 1$) in the decomposition into $A = \\{u_1, u_2, u_3\\}$ and $B = \\{u_4, u_5, u_6, u_7\\}$. The last one is an optimal decomposition we want.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/z3h20qpt.png)\n:::", "inputFormat": "Your program is to read from standard input. The first line contains two integers $n$ and $m$, respectively indicating the numbers of vertices and edges of a friendship graph, in which we assume $2 \\leq n \\leq 1,000$ and $0 \\leq m \\leq \\binom{n}{2}$. The vertices are indexed from $1$ to $n$. In the following $m$ lines, each line contains two integers $u$ and $v$ which represent an edge $(u, v)$ of the graph.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line that contains an integer. The integer should be the minimum of the size differences between two groups if the students can be decomposed into two groups satisfying the above three conditions; otherwise, the integer should be $-1$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Seoul R] Friendship Graphs", "background": "", "description": "Given a collection of people who interact, we can define a graph whose vertices are people, with an edge between two people if and only if they are friends with one another. Such graphs are called **social networks** and are well defined on any set of people, for example, the students in a college or the residents of a small town. An entire science analyzing social networks has sprung up in recent years, because many interesting aspects of people and their behavior are best understood as properties of this **friendship graph**.\n\nGiven a friendship graph where the vertices are the students in the Problem Solving class, your job is to write a program that decomposes the students in the class into two groups, $A$ and $B$, so that the following three conditions are satisfied simultaneously:\n\n- Each student in the class belongs to exactly one group, $A$ or $B$.\n- Any two students in each group are friends with each other.\n- The difference between the sizes of groups $A$ and $B$, denoted as $||A| - |B||$, is as small as possible.\n\nFor example, suppose we are given a friendship graph shown in the figure below. Decomposing the students into $A = \\{u_1, u_2, u_3, u_6\\}$ and $B = \\{u_4, u_5, u_7\\}$ is not possible because $u_2$ and $u_6$ are not friends. On the other hand, in the decomposition into $A = \\{u_1, u_2\\}$ and $B = \\{u_3, u_4, u_5, u_6, u_7\\}$, any two students in each group are friends with each other; however, the size difference ($|2 - 5| = 3$) between the two groups is larger than the difference ($|3 - 4| = 1$) in the decomposition into $A = \\{u_1, u_2, u_3\\}$ and $B = \\{u_4, u_5, u_6, u_7\\}$. The last one is an optimal decomposition we want.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/z3h20qpt.png)\n:::", "inputFormat": "Your program is to read from standard input. The first line contains two integers $n$ and $m$, respectively indicating the numbers of vertices and edges of a friendship graph, in which we assume $2 \\leq n \\leq 1,000$ and $0 \\leq m \\leq \\binom{n}{2}$. The vertices are indexed from $1$ to $n$. In the following $m$ lines, each line contains two integers $u$ and $v$ which represent an edge $(u, v)$ of the graph.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line that contains an integer. The integer should be the minimum of the size differences between two groups if the students can be decomposed into two groups satisfying the above three conditions; otherwise, the integer should be $-1$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Seoul R] Friendship Graphs", "background": "", "description": "给定一组相互交往的人，我们可以定义一个图：图的顶点是人，如果两个人是朋友，则他们之间有一条边。这样的图被称为**社交网络**，可以定义在任何人群集合上，例如一所大学的学生或一个小镇的居民。近年来，一门分析社交网络的全新科学已经兴起，因为关于人及其行为的许多有趣方面，最好通过**友谊图**的性质来理解。\n\n给定一个友谊图，其中顶点是“问题求解”课程中的学生，你的任务是编写一个程序，将班级中的学生分解为两个小组 $A$ 和 $B$，使得以下三个条件同时满足：\n\n- 班级中的每个学生恰好属于一个小组，$A$ 或 $B$。\n- 每个小组中的任意两个学生互为朋友。\n- 两个小组的规模之差 $||A| - |B||$ 尽可能小。\n\n例如，假设给定如下图所示的友谊图。将学生分解为 $A = \\{u_1, u_2, u_3, u_6\\}$ 和 $B = \\{u_4, u_5, u_7\\}$ 是不可能的，因为 $u_2$ 和 $u_6$ 不是朋友。另一方面，在分解为 $A = \\{u_1, u_2\\}$ 和 $B = \\{u_3, u_4, u_5, u_6, u_7\\}$ 时，每个小组中的任意两个学生互为朋友；然而，两个小组的规模之差（$|2 - 5| = 3$）大于分解为 $A = \\{u_1, u_2, u_3\\}$ 和 $B = \\{u_4, u_5, u_6, u_7\\}$ 时的差值（$|3 - 4| = 1$）。最后一种分解就是我们想要的最优分解。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/z3h20qpt.png)\n:::", "inputFormat": "你的程序需要从标准输入读取数据。第一行包含两个整数 $n$ 和 $m$，分别表示友谊图的顶点数和边数，其中 $2 \\leq n \\leq 1,000$，$0 \\leq m \\leq \\binom{n}{2}$。顶点编号从 $1$ 到 $n$。接下来的 $m$ 行中，每行包含两个整数 $u$ 和 $v$，表示图中的一条边 $(u, v)$。\n", "outputFormat": "你的程序需要向标准输出写入数据。输出恰好一行，包含一个整数。如果可以将学生分解为满足上述三个条件的两个小组，则该整数应为两个小组规模之差的最小值；否则，该整数应为 $-1$。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14738", "type": "P", "difficulty": 5, "samples": [["3 3 3", "48"], ["3 3 2", "16"], ["3 2 2", "0"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2021", "组合数学", "ICPC", "首尔"], "title": "[ICPC 2021 Seoul R] Grid Triangle", "background": "", "description": "A grid triangle in the 3-dimensional grid system is a triangle of three integral points including the origin $(0,0,0)$ that satisfy the following property:\n\nThere exist three different positive integers $X, Y, Z$ such that for every pair of the three points of the triangle, you can rotate and translate the cuboid of size $X \\times Y \\times Z$ in parallel with the grid system so that the pair are diagonally opposite (and so the farthest way) vertices of the cuboid.\n\nFor instance, the triangle of the three points $(0,0,0), (1,2,3), (-2,3,1)$ is a grid triangle with the cuboid of size $1 \\times 2 \\times 3$. More specifically, the two points $(1,2,3), (-2,3,1)$ are the diagonally opposite vertices of the cuboid $\\{(x,y,z) \\mid -2 \\le x \\le 1, 2 \\le y \\le 3, 1 \\le z \\le 3\\}$ of size $3 \\times 1 \\times 2$; the two points $(0,0,0), (1,2,3)$ are the diagonally opposite vertices of the cuboid $\\{(x,y,z) \\mid 0 \\le x \\le 1, 0 \\le y \\le 2, 0 \\le z \\le 3\\}$ of size $1 \\times 2 \\times 3$; and the two points $(0,0,0), (-2,3,1)$ are the diagonally opposite vertices of the cuboid $\\{(x,y,z) \\mid -2 \\le x \\le 0, 0 \\le y \\le 3, 0 \\le z \\le 1\\}$ of size $2 \\times 3 \\times 1$. Further, all three cuboids are parallel with the grid system.\n\nWrite a program to output the number of grid triangles within a bounded 3-dimensional grid system. The grid system is bounded by three given positive integers, $A, B, C$, in such a way that all points of grid triangles should be within $\\{(x,y,z) \\mid -A \\le x \\le A, -B \\le y \\le B, -C \\le z \\le C\\}$.", "inputFormat": "Your program is to read from standard input. The input is exactly one line containing three integers, $A, B, C$ ($1 \\le A, B, C \\le 10,000,000$).\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain the number of grid triangles in the 3-dimensional grid system bounded by $A, B, C$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Seoul R] Grid Triangle", "background": "", "description": "A grid triangle in the 3-dimensional grid system is a triangle of three integral points including the origin $(0,0,0)$ that satisfy the following property:\n\nThere exist three different positive integers $X, Y, Z$ such that for every pair of the three points of the triangle, you can rotate and translate the cuboid of size $X \\times Y \\times Z$ in parallel with the grid system so that the pair are diagonally opposite (and so the farthest way) vertices of the cuboid.\n\nFor instance, the triangle of the three points $(0,0,0), (1,2,3), (-2,3,1)$ is a grid triangle with the cuboid of size $1 \\times 2 \\times 3$. More specifically, the two points $(1,2,3), (-2,3,1)$ are the diagonally opposite vertices of the cuboid $\\{(x,y,z) \\mid -2 \\le x \\le 1, 2 \\le y \\le 3, 1 \\le z \\le 3\\}$ of size $3 \\times 1 \\times 2$; the two points $(0,0,0), (1,2,3)$ are the diagonally opposite vertices of the cuboid $\\{(x,y,z) \\mid 0 \\le x \\le 1, 0 \\le y \\le 2, 0 \\le z \\le 3\\}$ of size $1 \\times 2 \\times 3$; and the two points $(0,0,0), (-2,3,1)$ are the diagonally opposite vertices of the cuboid $\\{(x,y,z) \\mid -2 \\le x \\le 0, 0 \\le y \\le 3, 0 \\le z \\le 1\\}$ of size $2 \\times 3 \\times 1$. Further, all three cuboids are parallel with the grid system.\n\nWrite a program to output the number of grid triangles within a bounded 3-dimensional grid system. The grid system is bounded by three given positive integers, $A, B, C$, in such a way that all points of grid triangles should be within $\\{(x,y,z) \\mid -A \\le x \\le A, -B \\le y \\le B, -C \\le z \\le C\\}$.", "inputFormat": "Your program is to read from standard input. The input is exactly one line containing three integers, $A, B, C$ ($1 \\le A, B, C \\le 10,000,000$).\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain the number of grid triangles in the 3-dimensional grid system bounded by $A, B, C$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Seoul R] Grid Triangle", "background": null, "description": "在三维网格中，**格点三角形**指由三个整点构成、且其中一个整点为原点 $(0,0,0)$ 的三角形，并满足如下性质：\n\n存在三个互不相同的正整数 $X, Y, Z$，使得对于该三角形的任意一对顶点，都可以将一个尺寸为 $X \\times Y \\times Z$ 的长方体在三个坐标轴方向上平移和旋转（即把长方体的三条边分别重新对应到 $x,y,z$ 轴），并在保证长方体的三条边分别与对应的坐标轴平行的前提下，使得这对点恰好成为该长方体的**一对对角顶点（也就是距离最远的一对顶点）**。\n\n例如，由三点 $(0,0,0)$、$(1,2,3)$、$(-2,3,1)$ 构成的三角形就是一个格点三角形，其对应的长方体尺寸为 $1 \\times 2 \\times 3$。具体来说：\n\n* 两点 $(1,2,3)$ 与 $(-2,3,1)$ 是长方体\n\n  $$\n  \\{(x,y,z)\\mid -2 \\le x \\le 1,\\ 2 \\le y \\le 3,\\ 1 \\le z \\le 3\\}\n  $$\n\n  的一对对角顶点，该长方体尺寸为 $3 \\times 1 \\times 2$；\n\n* 两点 $(0,0,0)$ 与 $(1,2,3)$ 是长方体\n\n  $$\n  \\{(x,y,z)\\mid 0 \\le x \\le 1,\\ 0 \\le y \\le 2,\\ 0 \\le z \\le 3\\}\n  $$\n\n  的一对对角顶点，该长方体尺寸为 $1 \\times 2 \\times 3$；\n\n* 两点 $(0,0,0)$ 与 $(-2,3,1)$ 是长方体\n\n  $$\n  \\{(x,y,z)\\mid -2 \\le x \\le 0,\\ 0 \\le y \\le 3,\\ 0 \\le z \\le 1\\}\n  $$\n\n  的一对对角顶点，该长方体尺寸为 $2 \\times 3 \\times 1$。\n\n并且，这三个长方体都与网格坐标轴平行。\n\n你的任务是：在给定边界的三维网格中，计算满足上述条件的格点三角形的数量。边界由三个正整数 $A,B,C$ 给出，要求三角形的所有点都必须位于集合\n\n$$\n\\{(x,y,z)\\mid -A \\le x \\le A,\\ -B \\le y \\le B,\\ -C \\le z \\le C\\}\n$$\n\n之内。", "inputFormat": "你的程序需要从标准输入读取数据。输入恰好为一行，包含三个整数 $A, B, C$（$1 \\le A, B, C \\le 10,000,000$）。", "outputFormat": "你的程序需要向标准输出写入数据。输出恰好一行。该行应包含在由 $A, B, C$ 界定的三维网格内的格点三角形的数量。", "hint": "由 ChatGPT 5.2 翻译", "locale": "zh-CN"}}}
{"pid": "P14739", "type": "P", "difficulty": 4, "samples": [["2\n10 30\n10 20", "30"], ["3\n20 30 40\n30 20 10", "40"], ["4\n24 68 51 10\n20 40 50 30", "68"]], "limits": {"time": [1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "二分", "2021", "ICPC", "首尔"], "title": "[ICPC 2021 Seoul R] John' s Gift", "background": "", "description": "Every morning, John, a storekeeper, receives $n$ goods of distinct values and $n$ price tags all of which have different prices. As John wants to sell as many goods as possible, he sets up a match between the goods and the price tags to minimize the maximum difference (max-difference in short) between the two pair, where different goods should match different price tags. For example, if John has two goods of values $10, 30$ and two price tags of prices $10, 20$, then the max-difference can be minimized to $10$ by matching $(10, 10)$ and $(30, 20)$. This smallest max-difference is called the matching score.\n\nToday, Jane, a friend of John, has a birthday party and John decides to pick a birthday gift from his goods. When selecting a good, he does not want to lose too much profit, and therefore wants to select a good whose removal results in the smallest matching score for the remaining $n-1$ goods against the original $n$ price tags. By the way, when matching $n-1$ goods, John leaves one price tag unpaired to make a proper match.\n\nFor instance, John has two goods $G_1$ and $G_2$ whose values are $10$ and $30$, respectively, and two price tags $10$ and $20$. If he picks $G_1$ for a gift, then a possible price for $G_2$ is either $10$ or $20$. Then the matching score is $10$ when $G_2$ is priced at $20$. On the other hand, if he picks $G_2$ for a gift, then the matching score is zero when $G_1$ is priced at $10$. Therefore, in order to obtain the smallest matching score, John would select $G_2$ as a gift. In other words, among $n$ goods, John can pick any single good as gift, and this defines a new matching score between the remaining $n-1$ goods and the $n$ price tags. Among $n$ possible gift choices, John wants to find a good whose removal produces the smallest matching score.\n\nGiven $n$ good values and $n$ price tags, write a program that prints a value of a gift good that John should pick in order to produce the smallest matching score between the remaining $n-1$ goods and the $n$ price tags. If there are two or more candidate goods to select, print the smallest value of the candidate goods.", "inputFormat": "Your program is to read from standard input. The input starts with a line containing an integer $n$ ($2 \\le n \\le 10^6$), where $n$ is the number of goods and the number of price tags. The following line contains $n$ positive and distinct integers that represent $n$ good values. The third line contains $n$ positive and distinct integers that represent $n$ price tags. The good values and the tag prices are no more than $10^9$.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain the value of the good that John picks for Jane's birthday gift such that its removal produces the smallest matching score in the remaining $n-1$ goods. If there are multiple candidate goods, print the smallest value among the candidate goods.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Seoul R] John' s Gift", "background": "", "description": "Every morning, John, a storekeeper, receives $n$ goods of distinct values and $n$ price tags all of which have different prices. As John wants to sell as many goods as possible, he sets up a match between the goods and the price tags to minimize the maximum difference (max-difference in short) between the two pair, where different goods should match different price tags. For example, if John has two goods of values $10, 30$ and two price tags of prices $10, 20$, then the max-difference can be minimized to $10$ by matching $(10, 10)$ and $(30, 20)$. This smallest max-difference is called the matching score.\n\nToday, Jane, a friend of John, has a birthday party and John decides to pick a birthday gift from his goods. When selecting a good, he does not want to lose too much profit, and therefore wants to select a good whose removal results in the smallest matching score for the remaining $n-1$ goods against the original $n$ price tags. By the way, when matching $n-1$ goods, John leaves one price tag unpaired to make a proper match.\n\nFor instance, John has two goods $G_1$ and $G_2$ whose values are $10$ and $30$, respectively, and two price tags $10$ and $20$. If he picks $G_1$ for a gift, then a possible price for $G_2$ is either $10$ or $20$. Then the matching score is $10$ when $G_2$ is priced at $20$. On the other hand, if he picks $G_2$ for a gift, then the matching score is zero when $G_1$ is priced at $10$. Therefore, in order to obtain the smallest matching score, John would select $G_2$ as a gift. In other words, among $n$ goods, John can pick any single good as gift, and this defines a new matching score between the remaining $n-1$ goods and the $n$ price tags. Among $n$ possible gift choices, John wants to find a good whose removal produces the smallest matching score.\n\nGiven $n$ good values and $n$ price tags, write a program that prints a value of a gift good that John should pick in order to produce the smallest matching score between the remaining $n-1$ goods and the $n$ price tags. If there are two or more candidate goods to select, print the smallest value of the candidate goods.", "inputFormat": "Your program is to read from standard input. The input starts with a line containing an integer $n$ ($2 \\le n \\le 10^6$), where $n$ is the number of goods and the number of price tags. The following line contains $n$ positive and distinct integers that represent $n$ good values. The third line contains $n$ positive and distinct integers that represent $n$ price tags. The good values and the tag prices are no more than $10^9$.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain the value of the good that John picks for Jane's birthday gift such that its removal produces the smallest matching score in the remaining $n-1$ goods. If there are multiple candidate goods, print the smallest value among the candidate goods.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Seoul R] John' s Gift", "background": "", "description": "每天早晨，店主 John 会收到 $n$ 件价值各不相同的商品，以及 $n$ 张价格互不相同的价签。John 希望尽可能多地售出商品，因此他会在商品和价签之间建立一个配对，以最小化配对中两者差值的最大值（简称为 max-difference），且不同的商品必须与不同的价签配对。例如，若 John 有两件价值分别为 $10$ 和 $30$ 的商品，以及两张价格分别为 $10$ 和 $20$ 的价签，那么通过配对 $(10, 10)$ 和 $(30, 20)$，可以将 max-difference 最小化为 $10$。这个最小的 max-difference 被称为 **匹配得分**。\n\n今天，John 的朋友 Jane 要举办生日派对，John 决定从他的商品中挑选一件作为生日礼物。在选择商品时，他不希望损失太多利润，因此希望选择一件商品，使得将其移除后，剩下的 $n-1$ 件商品与原有的 $n$ 张价签之间能够获得最小的匹配得分。顺便一提，在匹配 $n-1$ 件商品时，John 会留下一张价签不参与配对，以形成合理的匹配。\n\n例如，John 有两件商品 $G_1$ 和 $G_2$，其价值分别为 $10$ 和 $30$，以及两张价签，价格分别为 $10$ 和 $20$。如果他选择 $G_1$ 作为礼物，那么 $G_2$ 可能的定价是 $10$ 或 $20$。当 $G_2$ 定价为 $20$ 时，匹配得分为 $10$。另一方面，如果他选择 $G_2$ 作为礼物，那么当 $G_1$ 定价为 $10$ 时，匹配得分为 $0$。因此，为了获得最小的匹配得分，John 会选择 $G_2$ 作为礼物。换句话说，在 $n$ 件商品中，John 可以选择任意一件作为礼物，这将定义出剩下的 $n-1$ 件商品与 $n$ 张价签之间的一个新的匹配得分。在 $n$ 种可能的礼物选择中，John 希望找到一件商品，其移除后能产生最小的匹配得分。\n\n给定 $n$ 件商品的价值和 $n$ 张价签的价格，编写一个程序，输出 John 为了使得剩下的 $n-1$ 件商品与 $n$ 张价签之间的匹配得分最小，所应挑选的礼物的价值。如果存在两个或更多候选商品，则输出候选商品中价值最小的那个。", "inputFormat": "你的程序需要从标准输入读取数据。输入的第一行包含一个整数 $n$ ($2 \\le n \\le 10^6$)，其中 $n$ 表示商品和价签的数量。第二行包含 $n$ 个互不相同正整数，表示 $n$ 件商品的价值。第三行包含 $n$ 个互不相同的正整数，表示 $n$ 张价签的价格。商品价值和价签价格均不超过 $10^9$。\n", "outputFormat": "你的程序需要向标准输出写入结果。输出恰好一行。该行应包含 John 为 Jane 的生日礼物所挑选的商品的价值，该商品的移除将使得剩下的 $n-1$ 件商品获得最小的匹配得分。如果有多个候选商品，则输出候选商品中价值最小的那个。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14740", "type": "P", "difficulty": 5, "samples": [["9 1\n2 1\n7 3\n3 4\n4 5\n6 5\n7 8\n3 2\n8 9", "3"], ["9 2\n2 1\n7 3\n3 4\n4 5\n6 5\n7 8\n3 2\n8 9", "3"], ["9 8\n2 1\n7 3\n3 4\n4 5\n6 5\n7 8\n3 2\n8 9", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "2021", "树形 DP", "ICPC", "首尔"], "title": "[ICPC 2021 Seoul R] Logistical Warehouse 2", "background": "", "description": "KOPANG is one of largest online vendors in Korea and introduced so called \"early-morning delivery\" for the first time. To cope with the growing demand, KOPANG plans to build new logistical warehouses. The locations of logistical warehouses must be within a certain distance from customers to keep the delivery time guaranteed by KOPANG to the customers.\n\nThe logistics network is modelled as a connected tree $T$. Each node of $T$ represents a region such as a city or a province in Korea, and each edge of $T$ represents a transportation road connecting two regions. KOPANG wants to select one or more nodes of $T$ satisfying the **distance restriction** for the logistical warehouses. Before the selection, KOPANG first fixed a distance parameter $K$ through sufficient research. KOPANG now wants to select the minimum number of nodes satisfying the distance restriction that the distance from every node of $T$ to its closest selected node (warehouse) is at most $K$. The distance of two nodes $u$ and $v$ is the number of edges of the (unique) path in $T$ that connects $u$ and $v$. Note that the distance is defined as zero if $u = v$.\n\nFor example, Figure G.1 below shows a tree $T$ with nine nodes and eight edges. For $K = 1$, if three warehouses are located at nodes 2, 5, and 8, marked with red circles as in Figure G.1 (a), then the distance of every node of $T$ to the closest warehouse is at most one. Two warehouses are not enough to satisfy the distance restriction, so three warehouses are the minimum. For $K = 2$, three warehouses are still required; warehouses at nodes 2, 5, and 8 for $K = 1$ are the ones for $K = 2$. Of course, the locations of the minimum number of warehouses are not unique; three warehouses at nodes 4, 7, and 1 as in Figure G.1 (b) also satisfy the distance restriction for $K = 2$.\n\nGiven a connected tree $T$ and a positive integer $K$, write a program to select the minimum number of nodes (warehouses) of $T$ satisfying the distance restriction, that is, the distance of every node of $T$ to its closest warehouse is at most $K$.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/j51fgnld.png)\n\nFigure G.1 The nodes marked with red circles are the ones selected for warehouses.\n:::", "inputFormat": "Your program is to read from standard input. The input starts with a line containing two integers $n$ and $K$ ($1 \\le K \\le n \\le 10^5$), where $n$ is the number of nodes in a connected tree and the maximum distance from each node in the tree to its closest selected node is at most $K$. In the following $n-1$ lines, the edge information is given; the $i$-th line contains two positive integers representing two indices of the end nodes of the $i$-th edge. The nodes are indexed from 1 to $n$.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line that contains the minimum number of the selected nodes for logistical warehouses satisfying the distance restriction for the given tree and the distance parameter $K$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Seoul R] Logistical Warehouse 2", "background": "", "description": "KOPANG is one of largest online vendors in Korea and introduced so called \"early-morning delivery\" for the first time. To cope with the growing demand, KOPANG plans to build new logistical warehouses. The locations of logistical warehouses must be within a certain distance from customers to keep the delivery time guaranteed by KOPANG to the customers.\n\nThe logistics network is modelled as a connected tree $T$. Each node of $T$ represents a region such as a city or a province in Korea, and each edge of $T$ represents a transportation road connecting two regions. KOPANG wants to select one or more nodes of $T$ satisfying the **distance restriction** for the logistical warehouses. Before the selection, KOPANG first fixed a distance parameter $K$ through sufficient research. KOPANG now wants to select the minimum number of nodes satisfying the distance restriction that the distance from every node of $T$ to its closest selected node (warehouse) is at most $K$. The distance of two nodes $u$ and $v$ is the number of edges of the (unique) path in $T$ that connects $u$ and $v$. Note that the distance is defined as zero if $u = v$.\n\nFor example, Figure G.1 below shows a tree $T$ with nine nodes and eight edges. For $K = 1$, if three warehouses are located at nodes 2, 5, and 8, marked with red circles as in Figure G.1 (a), then the distance of every node of $T$ to the closest warehouse is at most one. Two warehouses are not enough to satisfy the distance restriction, so three warehouses are the minimum. For $K = 2$, three warehouses are still required; warehouses at nodes 2, 5, and 8 for $K = 1$ are the ones for $K = 2$. Of course, the locations of the minimum number of warehouses are not unique; three warehouses at nodes 4, 7, and 1 as in Figure G.1 (b) also satisfy the distance restriction for $K = 2$.\n\nGiven a connected tree $T$ and a positive integer $K$, write a program to select the minimum number of nodes (warehouses) of $T$ satisfying the distance restriction, that is, the distance of every node of $T$ to its closest warehouse is at most $K$.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/j51fgnld.png)\n\nFigure G.1 The nodes marked with red circles are the ones selected for warehouses.\n:::", "inputFormat": "Your program is to read from standard input. The input starts with a line containing two integers $n$ and $K$ ($1 \\le K \\le n \\le 10^5$), where $n$ is the number of nodes in a connected tree and the maximum distance from each node in the tree to its closest selected node is at most $K$. In the following $n-1$ lines, the edge information is given; the $i$-th line contains two positive integers representing two indices of the end nodes of the $i$-th edge. The nodes are indexed from 1 to $n$.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line that contains the minimum number of the selected nodes for logistical warehouses satisfying the distance restriction for the given tree and the distance parameter $K$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Seoul R] Logistical Warehouse 2", "background": "", "description": "**KOPANG** 是韩国最大的在线零售商之一，并首次推出了所谓的“清晨配送”服务。为了应对不断增长的需求，**KOPANG** 计划建设新的物流仓库。物流仓库的位置必须与客户保持在一定距离之内，以确保 **KOPANG** 向客户承诺的配送时间。\n\n物流网络被建模为一棵连通的树 $T$。$T$ 的每个节点代表一个区域，例如韩国的城市或省份；$T$ 的每条边代表连接两个区域的运输道路。**KOPANG** 希望选择一个或多个 $T$ 的节点作为物流仓库，以满足 **距离限制**。在选择之前，**KOPANG** 首先通过充分的研究确定了一个距离参数 $K$。现在，**KOPANG** 希望选择最少数量的节点来满足距离限制，即 $T$ 中每个节点到其最近被选节点（仓库）的距离不超过 $K$。两个节点 $u$ 和 $v$ 之间的距离定义为连接 $u$ 和 $v$ 的（唯一）路径上的边数。注意，如果 $u = v$，距离定义为 $0$。\n\n例如，下图 G.1 展示了一棵有九个节点和八条边的树 $T$。对于 $K = 1$，如果将三个仓库设在节点 2、5 和 8（如图 G.1 (a) 中红色圆圈标记所示），那么 $T$ 中每个节点到最近仓库的距离都至多为 $1$。两个仓库不足以满足距离限制，因此三个仓库是最小数。对于 $K = 2$，仍然需要三个仓库；$K = 1$ 时在节点 2、5 和 8 设立的仓库对 $K = 2$ 也适用。当然，最小数量仓库的位置并不唯一；如图 G.1 (b) 所示，在节点 4、7 和 1 设立三个仓库也能满足 $K = 2$ 时的距离限制。\n\n给定一棵连通的树 $T$ 和一个正整数 $K$，请编写一个程序来选择最少数量的节点（仓库）以满足距离限制，即 $T$ 中每个节点到其最近仓库的距离不超过 $K$。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/j51fgnld.png)\n\n图 G.1 用红色圆圈标记的节点是被选为仓库的节点。\n:::\n", "inputFormat": "你的程序需要从标准输入读取数据。输入的第一行包含两个整数 $n$ 和 $K$ ($1 \\le K \\le n \\le 10^5$)，其中 $n$ 是连通树中的节点数，树中每个节点到其最近被选节点的最大距离不超过 $K$。接下来的 $n-1$ 行给出边的信息；第 $i$ 行包含两个正整数，表示第 $i$ 条边两个端节点的索引。节点的索引从 $1$ 到 $n$。", "outputFormat": "你的程序需要向标准输出写入结果。输出恰好一行，包含为满足给定树和距离参数 $K$ 的距离限制而选择的物流仓库的最小数量。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14741", "type": "P", "difficulty": 6, "samples": [["5 4 2\n-20 -15 20 30 10", "90"], ["5 4 1\n-20 -15 20 30 10", "80"], ["7 1 2\n10 13 -30 24 50 -5 -21", "-1"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2021", "ICPC", "首尔"], "title": "[ICPC 2021 Seoul R] Postman", "background": "", "description": "There is a straight road on which two types trams run. One is an east-to-west tram which moves from east to west, and the other is a west-to-east tram. For each type, several trams run regularly, so anyone can ride the tram in any direction at any time. To use the tram, you have to pay a ticket for each direction you take. In other words, to use a tram that moves from east to west, you must pay a W-ticket (west bound ticket), and conversely, to use a tram that moves from west to east, you must pay an E-ticket (east bound ticket). You can get on and off the tram at any time and place you want, and once you get on the tram, you can ride it as long as you want.\n\nBob, a post office worker, goes to the post office every day to deliver the mails assigned to him. He uses the tram to deliver them. Each location where mail will be delivered is represented by an $x$-coordinate for convenience, and the post office locates at $x = 0$.\n\nTo deliver $n$ pieces of mail, the post office gives Bob $n$ tram tickets. Bob uses one ticket to deliver one piece of mail. However, among the $n$ tickets provided by the post office, the number of W-tickets is $w$ and that of E-tickets is $e$ ($e = n - w$). By using the tickets he received at the post office, Bob wants not only to figure out the order in which the $n$ pieces of mail should be delivered, but also to minimize the distance he travels using the tram.\n\nDepending on the order in which the pieces of mail are delivered, it is divided into two types. The first type, denoted by $t = 1$, is the case that the order of mail delivery is not important. The second type, denoted by $t = 2$, is the case one specific designated piece of mail must be delivered at last and all the others can be delivered in any order.\n\nFor example, suppose that $n = 5$, $w = 4$ (the number of W-tickets), $t = 2$, and the $x$-coordinates of the places where the mails should be delivered are $(-20, -15, 20, 30, 10)$, and that the $x$-coordinate of the specific designated mail which must be finally delivered is $x = 10$. The optimal delivery route is shown in Figure H.1 and the total distance moved using trams is 90. As shown in Figure H.1, four W-tickets and one E-ticket are used and the designated mail is delivered at last.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/ft5nqp36.png)\n:::\n\nConsider another example where all information is the same as above except for $t = 1$. The optimal delivery route for this case is shown in Figure H.2 and the total distance is 80. In this case, you can see that four W-tickets and one E-ticket are used as well.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/t1mjpfvw.png)\n:::\n\nGiven information about the mail that Bob should deliver, write a program that finds the minimum distance he travels using trams.\n", "inputFormat": "Your program is to read from standard input. The input starts with a line containing three integers, $n$, $w$ and $t$ ($1 \\leq n \\leq 3 \\times 10^5$, $0 \\leq w \\leq n$, $1 \\leq t \\leq 2$), where $n$ is the number of pieces of mail, $w$ is the number of W-tickets, and $t$ indicates the delivery order type as explained above. Note that the number of E-tickets is $n - w$. In the following line, $n$ integers are given. The $i$-th integer $x_i$ ($1 \\leq i \\leq n$, $-10^9 \\leq x_i \\leq 10^9$, $x_i \\neq 0$) is the $x$-coordinate of the location where the $i$-th mail should be delivered. When $t = 2$, $x_n$ denotes the $x$-coordinate of the specific designated mail that must be delivered at last.\n\nYou can assume no two $x_i$'s are the same.", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain the minimum distance Bob travels to deliver all the pieces of mail. If it is impossible for Bob to deliver them using the tickets print $-1$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Seoul R] Postman", "background": "", "description": "There is a straight road on which two types trams run. One is an east-to-west tram which moves from east to west, and the other is a west-to-east tram. For each type, several trams run regularly, so anyone can ride the tram in any direction at any time. To use the tram, you have to pay a ticket for each direction you take. In other words, to use a tram that moves from east to west, you must pay a W-ticket (west bound ticket), and conversely, to use a tram that moves from west to east, you must pay an E-ticket (east bound ticket). You can get on and off the tram at any time and place you want, and once you get on the tram, you can ride it as long as you want.\n\nBob, a post office worker, goes to the post office every day to deliver the mails assigned to him. He uses the tram to deliver them. Each location where mail will be delivered is represented by an $x$-coordinate for convenience, and the post office locates at $x = 0$.\n\nTo deliver $n$ pieces of mail, the post office gives Bob $n$ tram tickets. Bob uses one ticket to deliver one piece of mail. However, among the $n$ tickets provided by the post office, the number of W-tickets is $w$ and that of E-tickets is $e$ ($e = n - w$). By using the tickets he received at the post office, Bob wants not only to figure out the order in which the $n$ pieces of mail should be delivered, but also to minimize the distance he travels using the tram.\n\nDepending on the order in which the pieces of mail are delivered, it is divided into two types. The first type, denoted by $t = 1$, is the case that the order of mail delivery is not important. The second type, denoted by $t = 2$, is the case one specific designated piece of mail must be delivered at last and all the others can be delivered in any order.\n\nFor example, suppose that $n = 5$, $w = 4$ (the number of W-tickets), $t = 2$, and the $x$-coordinates of the places where the mails should be delivered are $(-20, -15, 20, 30, 10)$, and that the $x$-coordinate of the specific designated mail which must be finally delivered is $x = 10$. The optimal delivery route is shown in Figure H.1 and the total distance moved using trams is 90. As shown in Figure H.1, four W-tickets and one E-ticket are used and the designated mail is delivered at last.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/ft5nqp36.png)\n:::\n\nConsider another example where all information is the same as above except for $t = 1$. The optimal delivery route for this case is shown in Figure H.2 and the total distance is 80. In this case, you can see that four W-tickets and one E-ticket are used as well.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/t1mjpfvw.png)\n:::\n\nGiven information about the mail that Bob should deliver, write a program that finds the minimum distance he travels using trams.\n", "inputFormat": "Your program is to read from standard input. The input starts with a line containing three integers, $n$, $w$ and $t$ ($1 \\leq n \\leq 3 \\times 10^5$, $0 \\leq w \\leq n$, $1 \\leq t \\leq 2$), where $n$ is the number of pieces of mail, $w$ is the number of W-tickets, and $t$ indicates the delivery order type as explained above. Note that the number of E-tickets is $n - w$. In the following line, $n$ integers are given. The $i$-th integer $x_i$ ($1 \\leq i \\leq n$, $-10^9 \\leq x_i \\leq 10^9$, $x_i \\neq 0$) is the $x$-coordinate of the location where the $i$-th mail should be delivered. When $t = 2$, $x_n$ denotes the $x$-coordinate of the specific designated mail that must be delivered at last.\n\nYou can assume no two $x_i$'s are the same.", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain the minimum distance Bob travels to deliver all the pieces of mail. If it is impossible for Bob to deliver them using the tickets print $-1$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Seoul R] Postman", "background": "", "description": "有一条笔直的道路，两种类型的有轨电车在上面运行。一种是**从东向西**行驶的电车，另一种是**从西向东**行驶的电车。每种类型的电车都有多班定期运行，因此任何人都可以在任何时间乘坐任意方向的电车。要乘坐电车，你需要为每次乘坐的方向支付车票。换句话说，要乘坐从东向西移动的电车，你必须支付一张 **西行车票**；反之，要乘坐从西向东移动的电车，你必须支付一张 **东行车票**。你可以在任何时间、任何地点上下车，并且一旦上车，你可以想坐多久就坐多久。\n\nBob 是一名邮局工作人员，他每天去邮局投递分配给他的邮件。他使用电车来投递。为了方便起见，每个需要投递邮件的地点用一个 $x$ 坐标表示，而邮局位于 $x = 0$。\n\n为了投递 $n$ 封邮件，邮局给了 Bob $n$ 张电车票。Bob 使用一张票来投递一封邮件。然而，在邮局提供的 $n$ 张票中，**西行车票**的数量是 $w$，**东行车票**的数量是 $e$ ($e = n - w$)。Bob 希望利用他在邮局收到的这些票，不仅规划出这 $n$ 封邮件的投递顺序，还要最小化他乘坐电车所旅行的总距离。\n\n根据邮件投递顺序的不同，可以分为两种类型。第一种类型，记作 $t = 1$，表示邮件的投递顺序不重要。第二种类型，记作 $t = 2$，表示有一封特定的指定邮件必须在最后投递，而其他所有邮件的投递顺序可以任意。\n\n例如，假设 $n = 5$，$w = 4$ (**西行车票**的数量)，$t = 2$，需要投递邮件地点的 $x$ 坐标是 $(-20, -15, 20, 30, 10)$，并且必须最后投递的特定邮件的 $x$ 坐标是 $x = 10$。最优的投递路线如图 H.1 所示，乘坐电车移动的总距离是 90。如图 H.1 所示，使用了四张 **西行车票** 和一张 **东行车票**，并且指定邮件在最后被投递。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/ft5nqp36.png)\n:::\n\n考虑另一个例子，除了 $t = 1$ 以外，所有信息都与上面相同。这种情况下的最优投递路线如图 H.2 所示，总距离是 80。在这种情况下，你可以看到同样使用了四张 **西行车票** 和一张 **东行车票**。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/t1mjpfvw.png)\n:::\n\n给定关于 Bob 需要投递的邮件的信息，编写一个程序，求出他乘坐电车所需旅行的最小距离。\n", "inputFormat": "你的程序需要从标准输入读取数据。输入的第一行包含三个整数 $n$, $w$ 和 $t$ ($1 \\leq n \\leq 3 \\times 10^5$, $0 \\leq w \\leq n$, $1 \\leq t \\leq 2$)，其中 $n$ 是邮件的数量，$w$ 是 **西行车票** 的数量，$t$ 表示如上所述的投递顺序类型。注意，**东行车票**的数量是 $n - w$。接下来的一行给出 $n$ 个整数。第 $i$ 个整数 $x_i$ ($1 \\leq i \\leq n$, $-10^9 \\leq x_i \\leq 10^9$, $x_i \\neq 0$) 是第 $i$ 封邮件需要投递地点的 $x$ 坐标。当 $t = 2$ 时，$x_n$ 表示必须最后投递的特定邮件的 $x$ 坐标。\n\n你可以假设没有两个 $x_i$ 是相同的。", "outputFormat": "你的程序需要向标准输出写入结果。输出恰好一行。该行应包含 Bob 投递所有邮件所需旅行的最小距离。如果 Bob 无法使用这些车票完成投递，则输出 $-1$。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14742", "type": "P", "difficulty": 7, "samples": [["20\n5 1\n14 1\n14 7\n16 7\n16 9\n18 9\n18 11\n13 11\n13 13\n11 13\n11 4\n9 4\n9 6\n7 6\n7 10\n3 10\n3 12\n1 12\n1 8\n5 8", "3"], ["12\n12 5\n4 5\n4 3\n1 3\n1 1\n6 1\n6 3\n9 3\n9 1\n15 1\n15 3\n12 3", "2"]], "limits": {"time": [800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2021", "ICPC", "首尔"], "title": "[ICPC 2021 Seoul R] Security System", "background": "", "description": "The management committee plans to introduce a new security system to monitor the museum at night time. The floor plane of the museum has a shape of a rectilinear polygon $P$ whose edges are either horizontal or vertical. In addition, $P$ has the $x$-monotone boundary, that is, the intersection of $P$ and any vertical line is either empty or a single line segment.\n\nThe new security system is based on infrared laser beam sensors. Moving along a straight track placed inside of $P$, an infrared laser beam sensor unit emits the laser beam in a direction perpendicular to the track. When it detects any motion, an emergency alarm is issued immediately.\n\nTracks are represented as horizontal or vertical line segments. Tracks are unlimited in length. A point $q$ in $P$ is monitored by a sensor located at a point $p$ on a track if $q = p$ or the following conditions are satisfied.\n\n(i) The line segment connecting $p$ and $q$ does not meet the outside of $P$.\n\n(ii) The track and the line segment connecting $p$ and $q$ are orthogonal to each other.\n\nA polygon $P$ is said to be completely monitored by a set $T$ of tracks if each point inside $P$ is monitored by a sensor on a track of $T$. The committee wants to know the minimum number of infrared laser beam sensor units required to completely monitor the museum. There are two things to note. The first is that the boundary of $P$ do not intersect a track excluding its endpoints, and the second is that the tracks must not intersect each other, even at their endpoints. For example, at least 3 sensor units are required to monitor the $x$-monotone rectilinear polygon as shown in the figure below. In this figure, blue lines represent tracks.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/g4qqt9f0.png)\n:::\n\nGiven an $x$-monotone rectilinear polygon, write a program to compute the minimum number of sensor units required to completely monitor the polygon.", "inputFormat": "Your program is to read from standard input. The input starts with a line containing an integer, $n$ ($4 \\leq n \\leq 100,000$), where $n$ is the number of vertices of an $x$-monotone rectilinear simple polygon. The following $n$ lines give the coordinates of the vertices in counterclockwise direction. Each vertex is represented by two numbers separated by a single space, which are the $x$-coordinate and the $y$-coordinate of the vertex, respectively. Each coordinate is given as an integer between $-100,000,000$ and $100,000,000$, inclusively.", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain an integer representing the minimum number of sensor units required to completely monitor the given polygon.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Seoul R] Security System", "background": "", "description": "The management committee plans to introduce a new security system to monitor the museum at night time. The floor plane of the museum has a shape of a rectilinear polygon $P$ whose edges are either horizontal or vertical. In addition, $P$ has the $x$-monotone boundary, that is, the intersection of $P$ and any vertical line is either empty or a single line segment.\n\nThe new security system is based on infrared laser beam sensors. Moving along a straight track placed inside of $P$, an infrared laser beam sensor unit emits the laser beam in a direction perpendicular to the track. When it detects any motion, an emergency alarm is issued immediately.\n\nTracks are represented as horizontal or vertical line segments. Tracks are unlimited in length. A point $q$ in $P$ is monitored by a sensor located at a point $p$ on a track if $q = p$ or the following conditions are satisfied.\n\n(i) The line segment connecting $p$ and $q$ does not meet the outside of $P$.\n\n(ii) The track and the line segment connecting $p$ and $q$ are orthogonal to each other.\n\nA polygon $P$ is said to be completely monitored by a set $T$ of tracks if each point inside $P$ is monitored by a sensor on a track of $T$. The committee wants to know the minimum number of infrared laser beam sensor units required to completely monitor the museum. There are two things to note. The first is that the boundary of $P$ do not intersect a track excluding its endpoints, and the second is that the tracks must not intersect each other, even at their endpoints. For example, at least 3 sensor units are required to monitor the $x$-monotone rectilinear polygon as shown in the figure below. In this figure, blue lines represent tracks.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/g4qqt9f0.png)\n:::\n\nGiven an $x$-monotone rectilinear polygon, write a program to compute the minimum number of sensor units required to completely monitor the polygon.", "inputFormat": "Your program is to read from standard input. The input starts with a line containing an integer, $n$ ($4 \\leq n \\leq 100,000$), where $n$ is the number of vertices of an $x$-monotone rectilinear simple polygon. The following $n$ lines give the coordinates of the vertices in counterclockwise direction. Each vertex is represented by two numbers separated by a single space, which are the $x$-coordinate and the $y$-coordinate of the vertex, respectively. Each coordinate is given as an integer between $-100,000,000$ and $100,000,000$, inclusively.", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain an integer representing the minimum number of sensor units required to completely monitor the given polygon.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Seoul R] Security System", "background": "", "description": "管理委员会计划引入一个新的安全系统，用于在夜间监控博物馆。博物馆的平面图是一个直边多边形 $P$，其边均为水平或垂直的。此外，$P$ 具有 **$x$ 单调边界**，即 $P$ 与任意垂直线的交要么为空，要么为一条线段。\n\n新安全系统基于红外激光束传感器。一个红外激光束传感器单元沿着放置在 $P$ 内部的一条直线轨道移动，并朝与轨道垂直的方向发射激光束。当检测到任何动静时，会立即发出紧急警报。\n\n轨道表示为水平或垂直的线段。轨道的长度是无限的。对于 $P$ 内的一点 $q$，如果它位于轨道上点 $p$ 处的传感器满足 $q = p$ 或以下条件，则称该点被该传感器监控。\n\n(i) 连接 $p$ 和 $q$ 的线段不接触 $P$ 的外部。\n\n(ii) 轨道与连接 $p$ 和 $q$ 的线段相互正交。\n\n如果一个多边形 $P$ 内的每一点都被轨道集合 $T$ 中某条轨道上的传感器所监控，则称 $P$ 被 $T$ **完全监控**。委员会希望知道完全监控博物馆所需的最少红外激光束传感器单元数量。有两点需要注意：第一，$P$ 的边界（端点除外）不与轨道相交；第二，轨道之间不得相互交叉，即使在端点处也不行。例如，要监控下图所示的 $x$ 单调直边多边形，至少需要 3 个传感器单元。在下图中，蓝线代表轨道。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/g4qqt9f0.png)\n:::\n\n给定一个 $x$ 单调直边多边形，编写一个程序来计算完全监控该多边形所需的最少传感器单元数量。", "inputFormat": "你的程序需要从标准输入读取数据。输入的第一行包含一个整数 $n$ ($4 \\leq n \\leq 100,000$)，其中 $n$ 是一个 $x$ 单调直边简单多边形的顶点数。接下来的 $n$ 行按逆时针方向给出各顶点的坐标。每个顶点由两个用单个空格分隔的数字表示，分别是该顶点的 $x$ 坐标和 $y$ 坐标。每个坐标均为介于 $-100,000,000$ 和 $100,000,000$ 之间（含）的整数。", "outputFormat": "你的程序需要向标准输出写入结果。输出恰好一行。该行应包含一个整数，表示完全监控给定多边形所需的最少传感器单元数量。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14743", "type": "P", "difficulty": 7, "samples": [["1 2 3", "2\n3 2\n3 1"], ["1 4 6", "3\n2 1\n3 1\n1 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2021", "Special Judge", "ICPC", "首尔"], "title": "[ICPC 2021 Seoul R] Squid Game", "background": "", "description": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/q9zc5e3f.png)\n:::\n\nYou are one of the $456$ players participating in a series of children's games with deadly penalties. Passing through a number of maze-like hallways and stairways, you have opened the gate of the next game. There are three buckets with infinite capacity, each of which contains an integral number of liters of water. The buckets are numbered from $1$ to $3$. The amounts of water initially contained in buckets $1$, $2$, and $3$ are given as $X$, $Y$, and $Z$, respectively.\n\nAt any time, you can double the amount of one bucket by pouring into it from another one. Specifically, you can pour from a bucket of $y$ liters into one of $x$ ($x \\leq y$) liters until the latter contains $2x$ liters and the former does $y - x$ liters. Note that $x$ and $y$ are always integers and $x \\leq y$. See the Figure J.1.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/kfp8act9.png)\n\nFigure J.1 A process of pouring\n:::\n\nIn order to survive, you have to empty one of the buckets in a limited number of pouring. Fortunately, it is always possible to empty one of the buckets. Given the initial amounts $X$, $Y$, and $Z$ of water in three buckets, write a program to output a sequence of pouring until one of the buckets is empty for the first time.", "inputFormat": "Your program is to read from standard input. The input starts with a line containing three integers $X$, $Y$, and $Z$ ($1 \\leq X \\leq Y \\leq Z \\leq 10^9$), representing the initial amounts of water in buckets $1$, $2$, and $3$, respectively.\n", "outputFormat": "Your program is to write to standard output. The first line should contain the number $m$ of pouring until one of the buckets is empty for the first time. The number $m$ should be no more than $1,000$. Each of the following $m$ lines contains two integers $A$ and $B$ ($1 \\leq A \\neq B \\leq 3$), which means you pour from bucket $A$ into bucket $B$ in a process of pouring. You should guarantee that one of buckets is empty for the first time after the $m$ pouring. If there are several ways to empty one of the buckets, then print one of them.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Seoul R] Squid Game", "background": "", "description": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/q9zc5e3f.png)\n:::\n\nYou are one of the $456$ players participating in a series of children's games with deadly penalties. Passing through a number of maze-like hallways and stairways, you have opened the gate of the next game. There are three buckets with infinite capacity, each of which contains an integral number of liters of water. The buckets are numbered from $1$ to $3$. The amounts of water initially contained in buckets $1$, $2$, and $3$ are given as $X$, $Y$, and $Z$, respectively.\n\nAt any time, you can double the amount of one bucket by pouring into it from another one. Specifically, you can pour from a bucket of $y$ liters into one of $x$ ($x \\leq y$) liters until the latter contains $2x$ liters and the former does $y - x$ liters. Note that $x$ and $y$ are always integers and $x \\leq y$. See the Figure J.1.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/kfp8act9.png)\n\nFigure J.1 A process of pouring\n:::\n\nIn order to survive, you have to empty one of the buckets in a limited number of pouring. Fortunately, it is always possible to empty one of the buckets. Given the initial amounts $X$, $Y$, and $Z$ of water in three buckets, write a program to output a sequence of pouring until one of the buckets is empty for the first time.", "inputFormat": "Your program is to read from standard input. The input starts with a line containing three integers $X$, $Y$, and $Z$ ($1 \\leq X \\leq Y \\leq Z \\leq 10^9$), representing the initial amounts of water in buckets $1$, $2$, and $3$, respectively.\n", "outputFormat": "Your program is to write to standard output. The first line should contain the number $m$ of pouring until one of the buckets is empty for the first time. The number $m$ should be no more than $1,000$. Each of the following $m$ lines contains two integers $A$ and $B$ ($1 \\leq A \\neq B \\leq 3$), which means you pour from bucket $A$ into bucket $B$ in a process of pouring. You should guarantee that one of buckets is empty for the first time after the $m$ pouring. If there are several ways to empty one of the buckets, then print one of them.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Seoul R] Squid Game", "background": "", "description": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/q9zc5e3f.png)\n:::\n\n你是参加一系列带有致命惩罚的儿童游戏的 $456$ 名玩家之一。穿过若干迷宫般的走廊和楼梯后，你打开了下一个游戏的大门。场上有三个容量无限的桶，每个桶中都装有整数升的水。桶的编号从 $1$ 到 $3$。桶 $1$、$2$ 和 $3$ 中初始的水量分别给定为 $X$、$Y$ 和 $Z$。\n\n在任何时候，你可以通过从一个桶向另一个桶倒水，使后一个桶中的水量翻倍。具体来说，你可以从一个装有 $y$ 升水的桶，向一个装有 $x$ 升水的桶（其中 $x \\leq y$）倒水，直到后者装有 $2x$ 升水，而前者剩余 $y - x$ 升水。注意 $x$ 和 $y$ 始终是整数，且 $x \\leq y$。参见图 J.1。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/kfp8act9.png)\n\n图 J.1 一次倒水过程\n:::\n\n为了生存，你必须在有限次倒水内清空其中一个桶。幸运的是，这总是可能的。给定三个桶中水的初始量 $X$、$Y$ 和 $Z$，请编写一个程序，输出一系列倒水操作，直到其中一个桶首次变空为止。", "inputFormat": "你的程序需要从标准输入读取数据。输入的第一行包含三个整数 $X$、$Y$ 和 $Z$ ($1 \\leq X \\leq Y \\leq Z \\leq 10^9$)，分别表示桶 $1$、$2$ 和 $3$ 中水的初始量。", "outputFormat": "你的程序需要向标准输出写入结果。第一行应输出直到其中一个桶首次变空为止的倒水次数 $m$。$m$ 应不超过 $1,000$。接下来的 $m$ 行，每行包含两个整数 $A$ 和 $B$ ($1 \\leq A \\neq B \\leq 3$)，表示你在一次倒水过程中从桶 $A$ 向桶 $B$ 倒水。你必须保证在第 $m$ 次倒水后，其中一个桶首次变空。如果有多种方法可以清空其中一个桶，则输出其中任意一种即可。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14744", "type": "P", "difficulty": 5, "samples": [["5 12\n500 560 600 680 580\n30 25 40 60 70 90 65 30 35 50 55 40", "3 8"], ["5 15\n1000 1200 1400 1700 1350\n1 2 3 4 5 6 7 8 7 6 5 4 3 2 1", "0"], ["6 14\n33 40 22 40 41 28\n10 20 16 27 32 12 32 33 20 25 15 25 31 17", "4 9"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "2021", "哈希 hashing", "ICPC", "首尔"], "title": "[ICPC 2021 Seoul R] Stock Price Prediction", "background": "", "description": "Mr. Kim is a stock market analyst. Recently, he found something interesting while looking at the stock charts of several companies. Most of the stocks that rose for four consecutive days fell the next day. Also, the stock price that fell on the fifth day was often located between the price of the second and third days of the stock price during the four days of the uptrend. For example, Company A's stock price was $500$ won, $560$ won, $600$ won, and $680$ won for four consecutive days, and the fifth day's stock price of Company A was $580$ won. Also, Company B's stock price was $1,000$ won, $1,200$ won, $1,400$ won, and $1,700$ won for four consecutive days, and the fifth day's stock price of Company B was $1,350$ won.\n\nMr. Kim thinks that if he can find a part in the previous stock price sequence that matches the price movement pattern over the last few days, he will be able to predict the stock price for the next day quite accurately. He also thinks that the relative ranks in a stock price sequence are more important than the actual prices because if the relative ranks of two stock price sequences are the same, their patterns in charts look similar. In the above example, the stock price sequence of Company A for five consecutive days, $500$ won, $560$ won, $600$ won, $680$ won, $580$ won, can be represented as $(1,2,4,5,3)$ because $500$ is the smallest among the five numbers, $550$ is the second smallest, $600$ is the fourth, and so on. Moreover, the stock price of Company B for five consecutive days, $1,000$ won, $1,200$ won, $1,400$ won, $1,700$ won, $1,350$ won, can also be represented as $(1,2,4,5,3)$ due to the same reason. Their relative ranks are the same and their charts of five consecutive days look very similar as shown in Figure K.1.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/tyiu5u8o.png)\n\nFigure K.1 Charts of Company A and B for five consecutive days \n:::\n\nMr. Kim decided to consider two sequences as a match if all the relative ranks of same positions of two sequences are the same. Mr. Kim formally defined **R-match** of two sequences of same length (number of integers) as follows: Two sequences of integers $x = (x_1, ..., x_m)$ and $y = (y_1, ..., y_m)$ of the same length are an **R-match** if and only if for each $i$ ($1 \\le i \\le m$), $x_i$'s rank in $x$ and $y_i$'s rank in $y$ are the same. Next, he defined the **R-pattern matching problem** as follows: Given two sequences of integers $x$ of length $m$ and $y$ of length $n$ ($m \\le n$), find every position $i$ of $y$ such that $x$ and $(y_i, ..., y_{i+m-1})$ are an **R-match**. For example, when $x = (33,40,22,40,41,28)$, and $y = (10,20,16,27,32,12,32,33,20,25,15,25,31,17)$, $x$ and $(y_4, ..., y_9)$ are an **R-match**. Also, $x$ and $(y_9, ..., y_{14})$ are an **R-match**.\n\nGiven two sequences of integers $x$ of length $m$ and $y$ of length $n$ ($m \\leq n$), write a program to solve the R-pattern matching problem for $x$ and $y$.", "inputFormat": "Your program is to read from standard input. The input starts with a line containing two integers, $m$ and $n$ ($1 \\leq m \\leq 10,000$, $1 \\leq n \\leq 1,000,000$, $m \\leq n$), where $m$ is the length of $x$, and $n$ is the length of $y$. In the second line, the $m$ integers in $x$ are given in turn. In the third line, the $n$ integers in $y$ are given in turn. Each integer in $x$ and $y$ ranges from $1$ to $10^9$.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain every position $i$ of $y$ such that $x$ and $(y_i, \\dots, y_{i+m-1})$ are an R-match. Each position must appear in increasing order. If there is no such position, print $0$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Seoul R] Stock Price Prediction", "background": "", "description": "Mr. Kim is a stock market analyst. Recently, he found something interesting while looking at the stock charts of several companies. Most of the stocks that rose for four consecutive days fell the next day. Also, the stock price that fell on the fifth day was often located between the price of the second and third days of the stock price during the four days of the uptrend. For example, Company A's stock price was $500$ won, $560$ won, $600$ won, and $680$ won for four consecutive days, and the fifth day's stock price of Company A was $580$ won. Also, Company B's stock price was $1,000$ won, $1,200$ won, $1,400$ won, and $1,700$ won for four consecutive days, and the fifth day's stock price of Company B was $1,350$ won.\n\nMr. Kim thinks that if he can find a part in the previous stock price sequence that matches the price movement pattern over the last few days, he will be able to predict the stock price for the next day quite accurately. He also thinks that the relative ranks in a stock price sequence are more important than the actual prices because if the relative ranks of two stock price sequences are the same, their patterns in charts look similar. In the above example, the stock price sequence of Company A for five consecutive days, $500$ won, $560$ won, $600$ won, $680$ won, $580$ won, can be represented as $(1,2,4,5,3)$ because $500$ is the smallest among the five numbers, $550$ is the second smallest, $600$ is the fourth, and so on. Moreover, the stock price of Company B for five consecutive days, $1,000$ won, $1,200$ won, $1,400$ won, $1,700$ won, $1,350$ won, can also be represented as $(1,2,4,5,3)$ due to the same reason. Their relative ranks are the same and their charts of five consecutive days look very similar as shown in Figure K.1.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/tyiu5u8o.png)\n\nFigure K.1 Charts of Company A and B for five consecutive days \n:::\n\nMr. Kim decided to consider two sequences as a match if all the relative ranks of same positions of two sequences are the same. Mr. Kim formally defined **R-match** of two sequences of same length (number of integers) as follows: Two sequences of integers $x = (x_1, ..., x_m)$ and $y = (y_1, ..., y_m)$ of the same length are an **R-match** if and only if for each $i$ ($1 \\le i \\le m$), $x_i$'s rank in $x$ and $y_i$'s rank in $y$ are the same. Next, he defined the **R-pattern matching problem** as follows: Given two sequences of integers $x$ of length $m$ and $y$ of length $n$ ($m \\le n$), find every position $i$ of $y$ such that $x$ and $(y_i, ..., y_{i+m-1})$ are an **R-match**. For example, when $x = (33,40,22,40,41,28)$, and $y = (10,20,16,27,32,12,32,33,20,25,15,25,31,17)$, $x$ and $(y_4, ..., y_9)$ are an **R-match**. Also, $x$ and $(y_9, ..., y_{14})$ are an **R-match**.\n\nGiven two sequences of integers $x$ of length $m$ and $y$ of length $n$ ($m \\leq n$), write a program to solve the R-pattern matching problem for $x$ and $y$.", "inputFormat": "Your program is to read from standard input. The input starts with a line containing two integers, $m$ and $n$ ($1 \\leq m \\leq 10,000$, $1 \\leq n \\leq 1,000,000$, $m \\leq n$), where $m$ is the length of $x$, and $n$ is the length of $y$. In the second line, the $m$ integers in $x$ are given in turn. In the third line, the $n$ integers in $y$ are given in turn. Each integer in $x$ and $y$ ranges from $1$ to $10^9$.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain every position $i$ of $y$ such that $x$ and $(y_i, \\dots, y_{i+m-1})$ are an R-match. Each position must appear in increasing order. If there is no such position, print $0$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Seoul R] Stock Price Prediction", "background": "", "description": "金先生是一位股票市场分析师。最近，他在查看几家公司的股票图表时发现了一些有趣的现象。大多数连续上涨四天的股票在第五天会下跌。而且，第五天下跌时的股价，通常位于这四天上涨期间第二天和第三天的股价之间。例如，A 公司的股价连续四天为 $500$ 韩元、$560$ 韩元、$600$ 韩元和 $680$ 韩元，而 A 公司第五天的股价是 $580$ 韩元。同样，B 公司的股价连续四天为 $1,000$ 韩元、$1,200$ 韩元、$1,400$ 韩元和 $1,700$ 韩元，而 B 公司第五天的股价是 $1,350$ 韩元。\n\n金先生认为，如果能在之前的股价序列中找到与最近几天价格变动模式相匹配的部分，他将能够相当准确地预测下一天的股价。他还认为，股价序列中的相对排名比实际价格更重要，因为如果两个股价序列的相对排名相同，它们在图表上的形态看起来就会相似。在上面的例子中，A 公司连续五天的股价序列 $500$ 韩元、$560$ 韩元、$600$ 韩元、$680$ 韩元、$580$ 韩元可以表示为 $(1,2,4,5,3)$，因为 $500$ 是五个数中最小的，$560$ 是第二小的，$600$ 是第四小的，依此类推。此外，B 公司连续五天的股价序列 $1,000$ 韩元、$1,200$ 韩元、$1,400$ 韩元、$1,700$ 韩元、$1,350$ 韩元，由于同样的原因，也可以表示为 $(1,2,4,5,3)$。它们的相对排名相同，并且它们连续五天的图表看起来非常相似，如图 K.1 所示。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/tyiu5u8o.png)\n\n图 K.1 A 公司和 B 公司连续五天的图表\n:::\n\n金先生决定，如果两个序列相同位置的相对排名都相同，则认为这两个序列匹配。金先生正式定义了相同长度（整数个数）的两个序列的 **R 匹配** 如下：两个长度相同的整数序列 $x = (x_1, ..., x_m)$ 和 $y = (y_1, ..., y_m)$ 是 **R 匹配** 当且仅当对于每个 $i$ ($1 \\le i \\le m$)，$x_i$ 在 $x$ 中的排名与 $y_i$ 在 $y$ 中的排名相同。接着，他将 **R 模式匹配问题** 定义如下：给定两个整数序列 $x$（长度为 $m$）和 $y$（长度为 $n$，$m \\le n$），找出 $y$ 中所有满足 $x$ 与 $(y_i, ..., y_{i+m-1})$ 是 **R 匹配** 的位置 $i$。例如，当 $x = (33,40,22,40,41,28)$，$y = (10,20,16,27,32,12,32,33,20,25,15,25,31,17)$ 时，$x$ 与 $(y_4, ..., y_9)$ 是 **R 匹配**，并且 $x$ 与 $(y_9, ..., y_{14})$ 也是 **R 匹配**。\n\n给定两个整数序列 $x$（长度为 $m$）和 $y$（长度为 $n$，$m \\leq n$），请编写一个程序来解决 $x$ 和 $y$ 的 R 模式匹配问题。", "inputFormat": "你的程序需要从标准输入读取数据。输入的第一行包含两个整数 $m$ 和 $n$ ($1 \\leq m \\leq 10,000$, $1 \\leq n \\leq 1,000,000$, $m \\leq n$)，其中 $m$ 是 $x$ 的长度，$n$ 是 $y$ 的长度。第二行依次给出 $x$ 中的 $m$ 个整数。第三行依次给出 $y$ 中的 $n$ 个整数。$x$ 和 $y$ 中的每个整数均在 $1$ 到 $10^9$ 的范围内。", "outputFormat": "你的程序需要向标准输出写入结果。输出恰好一行。该行应包含 $y$ 中所有满足 $x$ 与 $(y_i, \\dots, y_{i+m-1})$ 是 R 匹配的位置 $i$。每个位置必须按递增顺序出现。如果没有这样的位置，则输出 $0$。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14745", "type": "P", "difficulty": 4, "samples": [["6\n1234\n1235\n1244\n1233\n7133\n8133", "1"], ["9\n1234\n5678\n9123\n4567\n8912\n3456\n7891\n2345\n6789", "84"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2021", "枚举", "ICPC", "首尔"], "title": "[ICPC 2021 Seoul R] Trio", "background": "", "description": "Let $A$ be any set of $n$ natural numbers whose decimal representations consist of exactly four digits without $0$ in any decimal place.\n\nA **trio** is a set of three numbers $\\{a, b, c\\}$ chosen from $A$ such that the following conditions are fulfilled simultaneously:\n- The ones decimals of three numbers $a, b, c$ are either all equal or all distinct.\n- The tens decimals of three numbers $a, b, c$ are either all equal or all distinct.\n- The hundreds decimals of three numbers $a, b, c$ are either all equal or all distinct.\n- The thousands decimals of three numbers $a, b, c$ are either all equal or all distinct.\n\nFor examples, $\\{1425, 1113, 1354\\}$ is a trio if the three numbers are members of $A$ because the ones decimals of the three numbers are all distinct, their tens decimals are all distinct, their hundreds decimals are all distinct, and their thousands decimals are all equal. The set $\\{1425, 1113, 5436\\}$, however, is not a trio, even if $A$ contains those three numbers.\n\nGiven a set $A$ as input, write a program that computes and prints out the number of different trios.\n", "inputFormat": "Your program is to read from standard input. The input starts with a line consisting of a single integer $n$ ($1 \\leq n \\leq 2,000$) that represents the number of members in $A$. Each of the following $n$ lines consists of a positive integer in decimal form that consists of exactly four digits without $0$ in any decimal place. These $n$ numbers are supposed to be all distinct and the members of the input set $A$.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should consist of a single integer that represents the number of different trios for the input set $A$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Seoul R] Trio", "background": "", "description": "Let $A$ be any set of $n$ natural numbers whose decimal representations consist of exactly four digits without $0$ in any decimal place.\n\nA **trio** is a set of three numbers $\\{a, b, c\\}$ chosen from $A$ such that the following conditions are fulfilled simultaneously:\n- The ones decimals of three numbers $a, b, c$ are either all equal or all distinct.\n- The tens decimals of three numbers $a, b, c$ are either all equal or all distinct.\n- The hundreds decimals of three numbers $a, b, c$ are either all equal or all distinct.\n- The thousands decimals of three numbers $a, b, c$ are either all equal or all distinct.\n\nFor examples, $\\{1425, 1113, 1354\\}$ is a trio if the three numbers are members of $A$ because the ones decimals of the three numbers are all distinct, their tens decimals are all distinct, their hundreds decimals are all distinct, and their thousands decimals are all equal. The set $\\{1425, 1113, 5436\\}$, however, is not a trio, even if $A$ contains those three numbers.\n\nGiven a set $A$ as input, write a program that computes and prints out the number of different trios.\n", "inputFormat": "Your program is to read from standard input. The input starts with a line consisting of a single integer $n$ ($1 \\leq n \\leq 2,000$) that represents the number of members in $A$. Each of the following $n$ lines consists of a positive integer in decimal form that consists of exactly four digits without $0$ in any decimal place. These $n$ numbers are supposed to be all distinct and the members of the input set $A$.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should consist of a single integer that represents the number of different trios for the input set $A$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Seoul R] Trio", "background": "", "description": "设 $A$ 为任意一个由 $n$ 个自然数组成的集合，其中每个数的十进制表示恰好由四位数字组成，且任何数位上都不包含数字 $0$。\n\n一个 **三元组** 是指从 $A$ 中选出的三个数组成的集合 $\\{a, b, c\\}$，它同时满足以下条件：\n- 三个数 $a, b, c$ 的**个位**数字要么全部相同，要么全部不同。\n- 三个数 $a, b, c$ 的**十位**数字要么全部相同，要么全部不同。\n- 三个数 $a, b, c$ 的**百位**数字要么全部相同，要么全部不同。\n- 三个数 $a, b, c$ 的**千位**数字要么全部相同，要么全部不同。\n\n例如，如果这三个数都是 $A$ 的成员，那么集合 $\\{1425, 1113, 1354\\}$ 是一个三元组，因为这三个数的个位数字全部不同，它们的十位数字全部不同，它们的百位数字全部不同，并且它们的千位数字全部相同。然而，即使 $A$ 包含这三个数，集合 $\\{1425, 1113, 5436\\}$ 也不是一个三元组。\n\n给定一个集合 $A$ 作为输入，请编写一个程序，计算并输出不同三元组的数量。", "inputFormat": "你的程序需要从标准输入读取数据。输入的第一行包含一个整数 $n$ ($1 \\leq n \\leq 2,000$)，表示集合 $A$ 中元素的数量。接下来的 $n$ 行，每行包含一个十进制表示的正整数，该数恰好由四位数字组成，且任何数位上都不包含数字 $0$。这 $n$ 个数被认为是互不相同的，并且是输入集合 $A$ 的成员。\n", "outputFormat": "你的程序需要向标准输出写入结果。输出恰好一行。该行应包含一个整数，表示对于输入集合 $A$ 的不同三元组的数量。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
