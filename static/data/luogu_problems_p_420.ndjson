{"pid": "P9519", "type": "P", "difficulty": 4, "samples": [["5 5\n3 3 3 3 3\n1 2 3 4 5", "2"], ["5 2\n5 2 6 3 1\n2 5", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["二分", "洛谷原创", "O2优化"], "title": "pay", "background": "", "description": "今天是 L 公司发工资的一天。\n\n$n$ 名员工排成一排准备领工资，编号为 $1\\sim n$，第 $i$ 名员工有一个期望快乐值 $a_i$。\n\n老板非常扣，在这 $n$ 名员工中只选择了 $m$ 名员工 $b_1,b_2,\\cdots,b_m$ 发 $k$ 元工资。\n\n员工们都非常具有同理心，不仅自己获得工资时会增加快乐值，当周围的员工获得工资时自己也会增加快乐值。\n\n具体地，当与一名员工 A 距离为 $d$ 的员工获得了工资，A 的快乐值会增加 $\\max(0, k - d)$。特别地，如果 A 本身就获得了工资，A 的快乐值会增加 $k$。\n\n老板希望，你能找到最小的整数 $k$，使得所有员工的快乐值不低于他的期望。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数 $a_1,a_2,\\cdots,a_n$。\n\n第三行 $m$ 个整数 $b_1,b_2,\\cdots,b_m$。", "outputFormat": "一个整数，表示你求出的最小的 $k$。", "hint": "**【样例说明】**\n\n样例 $1$ 中，$k=2$ 时，每个人的快乐值分别为 $3,4,4,4,3$，满足要求。\n\n样例 $2$ 中，$k=5$ 时，每个人的快乐值分别为 $5,7,7,7,7$，满足要求。\n\n**【数据范围】**\n\n对于 $10\\%$ 的数据，满足 $n=1$。\n\n对于 $30\\%$ 的数据，满足 $n\\le 300$。\n\n对于 $60\\%$ 的数据，满足 $n\\le 5000$。\n\n对于另外 $10\\%$ 的数据，满足 $m=1$。\n\n对于 $100\\%$ 的数据，满足 $1\\le m\\le n\\le 10^6$，$0\\le a_i\\le 10^9$，$1\\le b_i\\le n$ 且 $b_i$ 互不相同。\n\n**本题输入量较大，请注意使用合理的输入方式。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "pay", "background": "", "description": "今天是 L 公司发工资的一天。\n\n$n$ 名员工排成一排准备领工资，编号为 $1\\sim n$，第 $i$ 名员工有一个期望快乐值 $a_i$。\n\n老板非常扣，在这 $n$ 名员工中只选择了 $m$ 名员工 $b_1,b_2,\\cdots,b_m$ 发 $k$ 元工资。\n\n员工们都非常具有同理心，不仅自己获得工资时会增加快乐值，当周围的员工获得工资时自己也会增加快乐值。\n\n具体地，当与一名员工 A 距离为 $d$ 的员工获得了工资，A 的快乐值会增加 $\\max(0, k - d)$。特别地，如果 A 本身就获得了工资，A 的快乐值会增加 $k$。\n\n老板希望，你能找到最小的整数 $k$，使得所有员工的快乐值不低于他的期望。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数 $a_1,a_2,\\cdots,a_n$。\n\n第三行 $m$ 个整数 $b_1,b_2,\\cdots,b_m$。", "outputFormat": "一个整数，表示你求出的最小的 $k$。", "hint": "**【样例说明】**\n\n样例 $1$ 中，$k=2$ 时，每个人的快乐值分别为 $3,4,4,4,3$，满足要求。\n\n样例 $2$ 中，$k=5$ 时，每个人的快乐值分别为 $5,7,7,7,7$，满足要求。\n\n**【数据范围】**\n\n对于 $10\\%$ 的数据，满足 $n=1$。\n\n对于 $30\\%$ 的数据，满足 $n\\le 300$。\n\n对于 $60\\%$ 的数据，满足 $n\\le 5000$。\n\n对于另外 $10\\%$ 的数据，满足 $m=1$。\n\n对于 $100\\%$ 的数据，满足 $1\\le m\\le n\\le 10^6$，$0\\le a_i\\le 10^9$，$1\\le b_i\\le n$ 且 $b_i$ 互不相同。\n\n**本题输入量较大，请注意使用合理的输入方式。**", "locale": "zh-CN"}}}
{"pid": "P9520", "type": "P", "difficulty": 6, "samples": [["1\n8\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 8\n2\n3 4\n4 8", "Yes"], ["2\n7\n1 2\n2 3\n3 4\n4 5\n3 6\n6 7\n2\n4 1\n5 7\n4\n1 2\n1 3\n1 4\n3\n2 3\n3 4\n4 2", "Yes\nNo"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "2022", "O2优化", "图论建模", "JOISC/JOIST（日本）"], "title": "[JOIST 2022] 监狱 / Jail", "background": "JOIST2022 D1T1", "description": "在 JOI 王国，安保最严格的地方就是 IOI 监狱。IOI 监狱中有 $N$ 个房间，以 $1,\\dots,N$ 编号。其中有 $N-1$ 条通道。第 $i$ $(1\\le i\\le N-1)$ 条通道双向地连接房间 $A_i$ 和 $B_i$。任意两个房间都可以相互到达。\n\nIOI 监狱中有 $M$ 个囚犯，以 $1,\\dots,M$ 编号。第 $j$ $(1\\le j\\le M)$ 个囚犯的卧室和工作室分别是房间 $S_j,T_j$。一个囚犯可能在另一个囚犯的卧室工作。然而，每个房间最多成为一个囚犯的卧室，一个囚犯的工作室。\n\n一天早上，这 $M$ 个囚犯需要从他们的卧室移动到他们的工作室。典狱长 APIO 先生需要按如下方式指示囚犯移动：  \n- **指令**：选择一个囚犯，然后命令他从当前所在的房间移动到一个与该房间有直接连边的房间。为了避免囚犯交流，不允许将囚犯移动到有其他囚犯在的房间。\n\n为了尽早开始工作，APIO 先生想知道，是否存在一种给出任意条指令的方案使得每个囚犯以**最短路径**从卧室到达工作室。\n\n请编写一个程序，在给定如上房间、通道和罪犯的所有信息后判断是否存在满足条件的方案。", "inputFormat": "每个测试数据包含多组测试用例。\n\n第一行一个整数 $Q$，表示这个测试数据包含 $Q$ 组测试用例。\n\n对于每组测试用例：\n\n第一行一个整数 $N$，表示房间个数。\n\n接下来 $N-1$ 行每行两个整数 $A_i,B_i$ 表示通道连接房间的编号。\n\n接下来一行一个整数 $M$ 表示囚犯个数。\n\n接下来 $M$ 行，每行两个整数 $S_i,T_i$ 表示囚犯的卧室和工作室。", "outputFormat": "输出 $Q$ 行，第 $i$ 行表示对于第 $i$ 组测试用例，如果存在一种满足题意的方案，输出 `Yes`，否则输出 `No`。", "hint": "**【样例解释 #1】**\n\n可以通过发送如下指令完成任务：\n\n1. 让囚犯 $2$ 从 $4$ 号房间移动到 $5$ 号房间。\n2. 让囚犯 $1$ 从 $3$ 号房间移动到 $4$ 号房间。\n3. 让囚犯 $2$ 从 $5$ 号房间移动到 $6$ 号房间。\n4. 让囚犯 $2$ 从 $6$ 号房间移动到 $7$ 号房间。\n5. 让囚犯 $2$ 从 $7$ 号房间移动到 $8$ 号房间。\n\n这组样例满足所有子任务的限制。\n\n**【样例解释 #2】**\n\n这组样例满足子任务 $1,3,4,5,6,7$ 的限制。\n\n**【数据范围】**\n\n对于所有数据，满足：\n\n- $1\\leq Q\\leq 1000$。\n- $1\\leq N\\leq 120000$。\n- $1\\leq A_i\\lt B_i\\leq N$ $(i\\in [1,N-1])$。\n- $2\\leq M\\leq N$。\n- $1\\leq S_i,T_i\\leq N$ $(i\\in [1,M])$。\n- $S_i$ $(i\\in[1,M])$ 互不相同。\n- $T_i$ $(i\\in[1,M])$ 互不相同。\n- $S_j \\ne T_j$ $(j\\in [1, M])$。\n- 任意两个房间之间可以通过给定道路互相到达。\n- 对于所有测试用例，$N$ 的总和不超过 $120000$。\n\n详细子任务附加限制及分值如下表所示：\n\n|子任务编号|附加限制|分值|\n|:-:|:-:|:-:|\n|$1$|$A_i=i,B_i=i+1~(i\\in[1,N-1])$|$5$|\n|$2$|$Q\\leq 20, N\\leq 250, M=2$|$5$|\n|$3$|$Q\\leq 20, N\\leq 250, M\\leq 6$|$16$|\n|$4$|$Q\\leq 20, N\\leq 250, M\\leq 100$|$28$|\n|$5$|$Q\\leq 20, M\\leq 500$|$12$|\n|$6$|任意两个房间之间都可以通过不超过 $20$ 条道路到达。|$11$|\n|$7$|无附加限制|$23$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIST 2022] 监狱 / Jail", "background": "JOIST2022 D1T1", "description": "在 JOI 王国，安保最严格的地方就是 IOI 监狱。IOI 监狱中有 $N$ 个房间，以 $1,\\dots,N$ 编号。其中有 $N-1$ 条通道。第 $i$ $(1\\le i\\le N-1)$ 条通道双向地连接房间 $A_i$ 和 $B_i$。任意两个房间都可以相互到达。\n\nIOI 监狱中有 $M$ 个囚犯，以 $1,\\dots,M$ 编号。第 $j$ $(1\\le j\\le M)$ 个囚犯的卧室和工作室分别是房间 $S_j,T_j$。一个囚犯可能在另一个囚犯的卧室工作。然而，每个房间最多成为一个囚犯的卧室，一个囚犯的工作室。\n\n一天早上，这 $M$ 个囚犯需要从他们的卧室移动到他们的工作室。典狱长 APIO 先生需要按如下方式指示囚犯移动：  \n- **指令**：选择一个囚犯，然后命令他从当前所在的房间移动到一个与该房间有直接连边的房间。为了避免囚犯交流，不允许将囚犯移动到有其他囚犯在的房间。\n\n为了尽早开始工作，APIO 先生想知道，是否存在一种给出任意条指令的方案使得每个囚犯以**最短路径**从卧室到达工作室。\n\n请编写一个程序，在给定如上房间、通道和罪犯的所有信息后判断是否存在满足条件的方案。", "inputFormat": "每个测试数据包含多组测试用例。\n\n第一行一个整数 $Q$，表示这个测试数据包含 $Q$ 组测试用例。\n\n对于每组测试用例：\n\n第一行一个整数 $N$，表示房间个数。\n\n接下来 $N-1$ 行每行两个整数 $A_i,B_i$ 表示通道连接房间的编号。\n\n接下来一行一个整数 $M$ 表示囚犯个数。\n\n接下来 $M$ 行，每行两个整数 $S_i,T_i$ 表示囚犯的卧室和工作室。", "outputFormat": "输出 $Q$ 行，第 $i$ 行表示对于第 $i$ 组测试用例，如果存在一种满足题意的方案，输出 `Yes`，否则输出 `No`。", "hint": "**【样例解释 #1】**\n\n可以通过发送如下指令完成任务：\n\n1. 让囚犯 $2$ 从 $4$ 号房间移动到 $5$ 号房间。\n2. 让囚犯 $1$ 从 $3$ 号房间移动到 $4$ 号房间。\n3. 让囚犯 $2$ 从 $5$ 号房间移动到 $6$ 号房间。\n4. 让囚犯 $2$ 从 $6$ 号房间移动到 $7$ 号房间。\n5. 让囚犯 $2$ 从 $7$ 号房间移动到 $8$ 号房间。\n\n这组样例满足所有子任务的限制。\n\n**【样例解释 #2】**\n\n这组样例满足子任务 $1,3,4,5,6,7$ 的限制。\n\n**【数据范围】**\n\n对于所有数据，满足：\n\n- $1\\leq Q\\leq 1000$。\n- $1\\leq N\\leq 120000$。\n- $1\\leq A_i\\lt B_i\\leq N$ $(i\\in [1,N-1])$。\n- $2\\leq M\\leq N$。\n- $1\\leq S_i,T_i\\leq N$ $(i\\in [1,M])$。\n- $S_i$ $(i\\in[1,M])$ 互不相同。\n- $T_i$ $(i\\in[1,M])$ 互不相同。\n- $S_j \\ne T_j$ $(j\\in [1, M])$。\n- 任意两个房间之间可以通过给定道路互相到达。\n- 对于所有测试用例，$N$ 的总和不超过 $120000$。\n\n详细子任务附加限制及分值如下表所示：\n\n|子任务编号|附加限制|分值|\n|:-:|:-:|:-:|\n|$1$|$A_i=i,B_i=i+1~(i\\in[1,N-1])$|$5$|\n|$2$|$Q\\leq 20, N\\leq 250, M=2$|$5$|\n|$3$|$Q\\leq 20, N\\leq 250, M\\leq 6$|$16$|\n|$4$|$Q\\leq 20, N\\leq 250, M\\leq 100$|$28$|\n|$5$|$Q\\leq 20, M\\leq 500$|$12$|\n|$6$|任意两个房间之间都可以通过不超过 $20$ 条道路到达。|$11$|\n|$7$|无附加限制|$23$|", "locale": "zh-CN"}}}
{"pid": "P9521", "type": "P", "difficulty": 6, "samples": [["2 2\n1 3\n2 5", "5"], ["5 5\n7 1 5 2 8\n7 2 4 1 6", "20"], ["4 6\n454863204 543362989 866044086 813602010\n71574269 17945210 688720933 392135202 38174709 168241720", "2737473954"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "2022", "O2优化", "凸包", "双指针 two-pointer", "JOISC/JOIST（日本）"], "title": "[JOIST 2022] 京都观光 / Sightseeing in Kyoto", "background": "JOISC2022 D1T2", "description": "京都是世界级的观光圣地，它也被称为网格城市。你来到了京都观光，并且你计划步行游览一个著名的景点。本题中，我们考虑如下的简化问题。\n\n在城市中，有 $H$ 条东西方向的街道和 $W$ 条南北方向的街道，因此城市是一个 $(H-1)\\times(W-1)$ 的网格。从北数第 $i$ 条街道和从西数第 $j$ 条街道的交叉点记作路口 $(i,j)$。\n\n不同的街道可能有不同的材质、宽度和拥挤程度，因此你的步行速度有可能不同。对于每条街道，你的步行速度如下：\n\n- 如果你在从北数第 $i$ 条街道上行走单位长度，需要 $A_i$ 秒。即从路口 $(i,c)~\\left(i\\in[1,H],c\\in[1,W)\\right)$ 走到路口 $(i,c+1)$ 需要 $A_i$ 秒。\n\n- 如果你在从西数第 $j$ 条街道上行走单位长度，需要 $B_j$ 秒。即从路口 $(c,j)~\\left(c\\in[1,H),j\\in[1,W]\\right)$ 走到路口 $(c+1,j)$ 需要 $B_j$ 秒。\n\n你现在在路口 $(1,1)$，你想前往 $(H,W)$，你必须沿着街道行走，并且你不希望走远路，即你不会向北或向西走。\n\n你希望尽早到达目的地，请你求出，在给定的条件下，从路口 $(1,1)$ 前往路口 $(H,W)$ 所需的最少时间。", "inputFormat": "第一行两个整数 $H,W$ 表示街道条数。\n\n第二行 $H$ 个整数，第 $i$ 个整数 $A_i$ 表示从北数第 $i$ 条东西方向街道的步行速度。\n\n第三行 $W$ 个整数，第 $i$ 个整数 $B_i$ 表示从西数第 $i$ 条南北方向街道的步行速度。", "outputFormat": "一行一个整数，表示所需的最小步行时间。", "hint": "**【样例解释 #1】**\n\n有两条从 $(1,1)$ 到 $(2,2)$ 的路线：\n\n1. $(1,1)\\rightarrow(1,2)\\rightarrow(2,2)$，所需时间为 $1+5=6$ 秒。\n2. $(1,1)\\rightarrow(2,1)\\rightarrow(2,2)$，所需时间为 $2+3=5$ 秒。\n\n因此最少花费时间为 $5$ 秒。\n\n这个样例满足所有子任务的限制。\n\n**【样例解释 #2】**\n\n最优路线如下图：\n\n![样例解释](https://cdn.luogu.com.cn/upload/image_hosting/mqsalajm.png)\n\n这个样例满足所有子任务的限制。\n\n**【样例解释 #3】**\n\n这个样例满足子任务 $1,3$ 的限制。\n\n**【数据范围】**\n\n对于所有数据，满足：\n\n- $2\\leq H,W\\leq 100000$。\n- $1\\leq A_i\\leq 10^9$ $(i\\in[1,H])$。\n- $1\\leq B_i\\leq 10^9$ $(i\\in[1,W])$。\n\n详细子任务附加限制及分值如下表所示：\n\n|子任务编号|附加限制|分值|\n|:-:|:-:|:-:|\n|$1$|$H,W\\leq 1000$|$10$|\n|$2$|$A_i\\leq 1000, B_i\\leq 1000$|$30$|\n|$3$|无附加限制|$60$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIST 2022] 京都观光 / Sightseeing in Kyoto", "background": "JOISC2022 D1T2", "description": "京都是世界级的观光圣地，它也被称为网格城市。你来到了京都观光，并且你计划步行游览一个著名的景点。本题中，我们考虑如下的简化问题。\n\n在城市中，有 $H$ 条东西方向的街道和 $W$ 条南北方向的街道，因此城市是一个 $(H-1)\\times(W-1)$ 的网格。从北数第 $i$ 条街道和从西数第 $j$ 条街道的交叉点记作路口 $(i,j)$。\n\n不同的街道可能有不同的材质、宽度和拥挤程度，因此你的步行速度有可能不同。对于每条街道，你的步行速度如下：\n\n- 如果你在从北数第 $i$ 条街道上行走单位长度，需要 $A_i$ 秒。即从路口 $(i,c)~\\left(i\\in[1,H],c\\in[1,W)\\right)$ 走到路口 $(i,c+1)$ 需要 $A_i$ 秒。\n\n- 如果你在从西数第 $j$ 条街道上行走单位长度，需要 $B_j$ 秒。即从路口 $(c,j)~\\left(c\\in[1,H),j\\in[1,W]\\right)$ 走到路口 $(c+1,j)$ 需要 $B_j$ 秒。\n\n你现在在路口 $(1,1)$，你想前往 $(H,W)$，你必须沿着街道行走，并且你不希望走远路，即你不会向北或向西走。\n\n你希望尽早到达目的地，请你求出，在给定的条件下，从路口 $(1,1)$ 前往路口 $(H,W)$ 所需的最少时间。", "inputFormat": "第一行两个整数 $H,W$ 表示街道条数。\n\n第二行 $H$ 个整数，第 $i$ 个整数 $A_i$ 表示从北数第 $i$ 条东西方向街道的步行速度。\n\n第三行 $W$ 个整数，第 $i$ 个整数 $B_i$ 表示从西数第 $i$ 条南北方向街道的步行速度。", "outputFormat": "一行一个整数，表示所需的最小步行时间。", "hint": "**【样例解释 #1】**\n\n有两条从 $(1,1)$ 到 $(2,2)$ 的路线：\n\n1. $(1,1)\\rightarrow(1,2)\\rightarrow(2,2)$，所需时间为 $1+5=6$ 秒。\n2. $(1,1)\\rightarrow(2,1)\\rightarrow(2,2)$，所需时间为 $2+3=5$ 秒。\n\n因此最少花费时间为 $5$ 秒。\n\n这个样例满足所有子任务的限制。\n\n**【样例解释 #2】**\n\n最优路线如下图：\n\n![样例解释](https://cdn.luogu.com.cn/upload/image_hosting/mqsalajm.png)\n\n这个样例满足所有子任务的限制。\n\n**【样例解释 #3】**\n\n这个样例满足子任务 $1,3$ 的限制。\n\n**【数据范围】**\n\n对于所有数据，满足：\n\n- $2\\leq H,W\\leq 100000$。\n- $1\\leq A_i\\leq 10^9$ $(i\\in[1,H])$。\n- $1\\leq B_i\\leq 10^9$ $(i\\in[1,W])$。\n\n详细子任务附加限制及分值如下表所示：\n\n|子任务编号|附加限制|分值|\n|:-:|:-:|:-:|\n|$1$|$H,W\\leq 1000$|$10$|\n|$2$|$A_i\\leq 1000, B_i\\leq 1000$|$30$|\n|$3$|无附加限制|$60$|", "locale": "zh-CN"}}}
{"pid": "P9522", "type": "P", "difficulty": 6, "samples": [["3 2\n1 3\n3 2", "5876"], ["5 6\n1 2\n1 5\n2 4\n5 4\n5 3\n4 3", "656981"], ["10 9\n3 6\n4 6\n6 7\n7 9\n10 8\n9 8\n8 5\n5 2\n5 1", "206289833\n"], ["7 6\n1 3\n3 4\n4 6\n6 5\n5 7\n7 2", "7125651"], ["5 4\n2 4\n4 3\n3 5\n5 1", "61451"]], "limits": {"time": [3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "O2优化", "JOISC/JOIST（日本）"], "title": "[JOIST 2022] 错误拼写 / Misspelling", "background": "JOISC2022 D1T3", "description": "从前，K 总统有着一个长度为 $N$ 的字符串 $S$，仅由小写字母组成。然而，他忘记了它。  \n他还有一个词典，其中包含了各式各样的错误拼写。而他曾看过那本词典，现在他确认到 $S$ 满足以下条件：\n\n- 令 $T_i$ $(1\\le i\\le N)$ 为 $S$ 删去第 $i$ 个字符并将前后字符相接所得的字符串。对于每个 $j$ $(1\\le j\\le M)$ 满足 $T_{A_j} \\le T_{B_j}$。\n\n其中 $T_{A_j} \\le T_{B_j}$ 表示 $T_{A_j}$ 等于 $T_{B_j}$ 或 $T_{A_j}$ 在字典序上小于 $T_{B_j}$。\n\n请写一个程序，对于 K 总统给定的如上关于 $S$ 的信息，输出可能的 $S$ 的个数，对 $10^9+7$ 取模。", "inputFormat": "第一行，两个正整数 $N,M$，表示 $S$ 的长度与限制的个数。\n\n以下 $M$ 行，其中第 $j$ $(1 \\le j \\le M)$ 行包含两个正整数 $A_j, B_j$，表示一条限制。", "outputFormat": "一行一个非负整数，表示可能的 $S$ 的个数对 $10^9+7$ 取模的结果。", "hint": "**【样例解释 #1】**\n\n举例说明，若 $S=\\texttt{bab}$，则 $T_1 = \\texttt{ab}, T_2 = \\texttt{bb}, T_3 = \\texttt{ba}$。其满足 $T_1 \\le T_3$ 和 $T_3 \\le T_2$。所以该 $S$ 是合法的。  \n可以证明，总共有 $5876$ 种合法的 $S$。因此，输出 $5876$。\n\n另一方面，若 $S=\\texttt{aab}$，则 $T_1 = \\texttt{ab}, T_2 = \\texttt{ab}, T_3 = \\texttt{aa}$。其不满足 $T_1 \\le T_3$。所以该 $S$ 不合法。\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #2】**\n\n该样例满足子任务 $1,2,4,5$ 的限制。\n\n**【样例解释 #3】**\n\n取模前的结果为 $824\\,206\\,295\\,601$，所以输出 $206\\,289\\,833$。\n\n该样例满足子任务 $1,2,4,5$ 的限制。\n\n**【样例解释 #4】**\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #5】**\n\n该样例满足所有子任务的限制。\n\n**【数据范围】**\n\n对于所有数据，满足：\n\n- $2 \\le N \\le 500\\,000$。  \n- $1 \\le M \\le 500\\,000$。\n- $1 \\le A_j,B_j \\le N$ $(1 \\le j \\le M)$。\n- $A_j\\ne B_j$ $(1 \\le j \\le M)$。\n- $(A_j,B_j)\\ne(A_k,B_k)$ $(1 \\le j < k \\le M)$。\n\n详细子任务附加限制及分值如下表所示：\n\n|子任务编号|附加限制|分值|\n|:-:|:-:|:-:|\n|$1$|$N \\le 10$|$8$|\n|$2$|$N \\le 200$|$20$|\n|$3$|存在 $\\{1,2,\\dots,N\\}$ 的排列 $P$ 满足 $A_j = P_j, B_j = P_{j+1}$ $(1 \\le j \\le M=N-1)$|$29$|\n|$4$|$N \\le 20\\,000$|$32$|\n|$5$|无附加限制|$11$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIST 2022] 错误拼写 / Misspelling", "background": "JOISC2022 D1T3", "description": "从前，K 总统有着一个长度为 $N$ 的字符串 $S$，仅由小写字母组成。然而，他忘记了它。  \n他还有一个词典，其中包含了各式各样的错误拼写。而他曾看过那本词典，现在他确认到 $S$ 满足以下条件：\n\n- 令 $T_i$ $(1\\le i\\le N)$ 为 $S$ 删去第 $i$ 个字符并将前后字符相接所得的字符串。对于每个 $j$ $(1\\le j\\le M)$ 满足 $T_{A_j} \\le T_{B_j}$。\n\n其中 $T_{A_j} \\le T_{B_j}$ 表示 $T_{A_j}$ 等于 $T_{B_j}$ 或 $T_{A_j}$ 在字典序上小于 $T_{B_j}$。\n\n请写一个程序，对于 K 总统给定的如上关于 $S$ 的信息，输出可能的 $S$ 的个数，对 $10^9+7$ 取模。", "inputFormat": "第一行，两个正整数 $N,M$，表示 $S$ 的长度与限制的个数。\n\n以下 $M$ 行，其中第 $j$ $(1 \\le j \\le M)$ 行包含两个正整数 $A_j, B_j$，表示一条限制。", "outputFormat": "一行一个非负整数，表示可能的 $S$ 的个数对 $10^9+7$ 取模的结果。", "hint": "**【样例解释 #1】**\n\n举例说明，若 $S=\\texttt{bab}$，则 $T_1 = \\texttt{ab}, T_2 = \\texttt{bb}, T_3 = \\texttt{ba}$。其满足 $T_1 \\le T_3$ 和 $T_3 \\le T_2$。所以该 $S$ 是合法的。  \n可以证明，总共有 $5876$ 种合法的 $S$。因此，输出 $5876$。\n\n另一方面，若 $S=\\texttt{aab}$，则 $T_1 = \\texttt{ab}, T_2 = \\texttt{ab}, T_3 = \\texttt{aa}$。其不满足 $T_1 \\le T_3$。所以该 $S$ 不合法。\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #2】**\n\n该样例满足子任务 $1,2,4,5$ 的限制。\n\n**【样例解释 #3】**\n\n取模前的结果为 $824\\,206\\,295\\,601$，所以输出 $206\\,289\\,833$。\n\n该样例满足子任务 $1,2,4,5$ 的限制。\n\n**【样例解释 #4】**\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #5】**\n\n该样例满足所有子任务的限制。\n\n**【数据范围】**\n\n对于所有数据，满足：\n\n- $2 \\le N \\le 500\\,000$。  \n- $1 \\le M \\le 500\\,000$。\n- $1 \\le A_j,B_j \\le N$ $(1 \\le j \\le M)$。\n- $A_j\\ne B_j$ $(1 \\le j \\le M)$。\n- $(A_j,B_j)\\ne(A_k,B_k)$ $(1 \\le j < k \\le M)$。\n\n详细子任务附加限制及分值如下表所示：\n\n|子任务编号|附加限制|分值|\n|:-:|:-:|:-:|\n|$1$|$N \\le 10$|$8$|\n|$2$|$N \\le 200$|$20$|\n|$3$|存在 $\\{1,2,\\dots,N\\}$ 的排列 $P$ 满足 $A_j = P_j, B_j = P_{j+1}$ $(1 \\le j \\le M=N-1)$|$29$|\n|$4$|$N \\le 20\\,000$|$32$|\n|$5$|无附加限制|$11$|", "locale": "zh-CN"}}}
{"pid": "P9523", "type": "P", "difficulty": 6, "samples": [["11\nmississippi\n10\n5\n2", "88"], ["16\naaaaaaaaaaaaaaaa\n1\n1\n1", "9"], ["18\naababbbababbbaabbb\n1000000000\n100000\n10000000", "8060200000"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["字符串", "2022", "后缀自动机 SAM", "O2优化", "区间 DP", "动态规划优化", "哈希 hashing", "JOISC/JOIST（日本）"], "title": "[JOIST 2022] 复制粘贴 3 / Copy and Paste 3", "background": "JOISC2022 D2T1", "description": "JOI 公司是一家以“没啥用发明”而闻名的公司。最近，JOI 公司开发了一款名为“没啥用编辑器”的编辑器。\n\n在这个编辑器中，可以执行如下几种操作来输入某个字符串，设 $X$ 为屏幕上的字符串，$Y$ 为剪切板中的字符串，初始均为空串：\n\n- 操作 A：输入字符 $c$，即将 $X$ 更新为 $X+c$。\n- 操作 B：选择所有字符并剪切，即将 $Y$ 更新为 $X$，并将 $X$ 置为空串。\n- 操作 C：将剪切板中的字符串粘贴到当前字符串末尾，即将 $X$ 更新为 $X+Y$。\n\n对于字符串或字符 $x,y$，$x+y$ 表示将 $x$ 和 $y$ 顺次拼接得到的结果。使用一次操作 A,B,C 分别要花费 $A,B,C$ 单位时间。\n\n你安装了“没啥用编辑器”，并想要尽可能快地输入一个长度为 $N$ 的字符串 $S$。\n\n你需要计算出最少需要花费多少时间。", "inputFormat": "第一行一个整数 $N$ 表示字符串长度。\n\n第二行一个长度为 $N$ 的字符串 $S$ 表示要输入的字符串。\n\n第三行一个整数 $A$ 表示操作 A 的代价。\n\n第四行一个整数 $B$ 表示操作 B 的代价。\n\n第五行一个整数 $C$ 表示操作 C 的代价。", "outputFormat": "一行一个整数表示输入字符串 $S$ 最少要多少单位时间。", "hint": "**【样例解释 #1】**\n\n以下是一组最优操作：\n\n| 轮次 | 操作 | 解释 | $X$ | $Y$ | 代价 | 总时间 |\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n| - | - | - | `\"\"` | `\"\"` | - | $0$ |\n| $1$ | 操作 A | 输入字符 | `\"s\"` | `\"\"` | $10$ | $10$ |\n| $2$ | 操作 B | 全选并剪切 |` \"\"` | `\"s\"`| $5$ | $15$ |\n| $3$ | 操作 C | 在尾部粘贴 | `\"s\"` | `\"s\"`| $2$ | $17$ |\n| $4$ | 操作 C | 在尾部粘贴 | `\"ss\"` | `\"s\"`| $2$ | $19$ |\n| $5$ | 操作 A | 输入字符 | `\"ssi\"` | `\"s\"`| $10$ | $29$ |\n| $6$ | 操作 B | 全选并剪切 |` \"\"` | `\"ssi\"`| $5$ | $34$ |\n| $7$ | 操作 A | 输入字符 | `\"m\"` | `\"ssi\"`| $10$ | $44$ |\n| $8$ | 操作 A | 输入字符 | `\"mi\"` | `\"ssi\"`| $10$ | $54$ |\n| $9$ | 操作 C | 在尾部粘贴 | `\"missi\"` | `\"ssi\"`| $2$ | $56$ |\n| $10$ | 操作 C | 在尾部粘贴 | `\"mississi\"` | `\"ssi\"`| $2$ | $58$ |\n| $11$ | 操作 A | 输入字符 | `\"mississip\"` | `\"ssi\"`| $10$ | $68$ |\n| $12$ | 操作 A | 输入字符 | `\"mississipp\"` | `\"ssi\"`| $10$ | $78$ |\n| $13$ | 操作 A | 输入字符 | `\"mississippi\"` | `\"ssi\"`| $10$ | $88$ |\n\n这组样例满足子任务 $3,4,5,6$ 的限制。\n\n**【样例解释 #2】**\n\n一组最优策略如下：\n\n| 轮次 | 操作 | 解释 | $X$ | $Y$ | 代价 | 总时间 |\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n| - | - | - | `\"\"` | `\"\"` | - | $0$ |\n| $1$ | 操作 A | 输入字符 | ` \"a\"` | `\"\"` | $1$ | $1$ |\n| $2$ | 操作 A | 输入字符 | ` \"aa\"` | `\"\"` | $1$ | $2$ |\n| $3$ | 操作 A | 输入字符 | ` \"aaa\"` | `\"\"` | $1$ | $3$ |\n| $4$ | 操作 A | 输入字符 | ` \"aaaa\"` | `\"\"` | $1$ | $4$ |\n| $5$ | 操作 B | 全选并剪切 | `\"\"` | `\"aaaa\"` | $1$ | $5$ |\n| $6$ | 操作 C | 在尾部粘贴 | `\"aaaa\"` | `\"aaaa\"` | $1$ | $6$ |\n| $7$ | 操作 C | 在尾部粘贴 | `\"aaaaaaaa\"` | `\"aaaa\"` | $1$ | $7$ |\n| $8$ | 操作 C | 在尾部粘贴 | `\"aaaaaaaaaaaa\"` | `\"aaaa\"` | $1$ | $8$ |\n| $9$ | 操作 C | 在尾部粘贴 | `\"aaaaaaaaaaaaaaaa\"` | `\"aaaa\"` | $1$ | $9$ |\n\n这组样例满足子任务 $2,3,4,5,6$ 的限制。\n\n**【样例解释 #3】**\n\n这组样例满足子任务 $3,4,5,6$ 的限制。\n\n**【数据范围】**\n\n对于所有数据，满足：\n\n- $1\\leq N\\leq 2500$\n- $S$ 是一个长度为 $N$ 的小写字母串。\n- $1\\leq A,B,C\\leq 10^9$\n\n详细子任务附加限制及分值如下表所示：\n\n|子任务编号|附加限制|分数|\n|:-:|:-:|:-:|\n|$1$|$N=3$|$1$|\n|$2$|$S$ 只包含字符 $\\texttt a$|$5$|\n|$3$|$N\\le 30$|$14$|\n|$4$|$N\\le 200$|$10$|\n|$5$|$N \\le 1000$|$32$|\n|$6$|无附加限制|$38$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIST 2022] 复制粘贴 3 / Copy and Paste 3", "background": "JOISC2022 D2T1", "description": "JOI 公司是一家以“没啥用发明”而闻名的公司。最近，JOI 公司开发了一款名为“没啥用编辑器”的编辑器。\n\n在这个编辑器中，可以执行如下几种操作来输入某个字符串，设 $X$ 为屏幕上的字符串，$Y$ 为剪切板中的字符串，初始均为空串：\n\n- 操作 A：输入字符 $c$，即将 $X$ 更新为 $X+c$。\n- 操作 B：选择所有字符并剪切，即将 $Y$ 更新为 $X$，并将 $X$ 置为空串。\n- 操作 C：将剪切板中的字符串粘贴到当前字符串末尾，即将 $X$ 更新为 $X+Y$。\n\n对于字符串或字符 $x,y$，$x+y$ 表示将 $x$ 和 $y$ 顺次拼接得到的结果。使用一次操作 A,B,C 分别要花费 $A,B,C$ 单位时间。\n\n你安装了“没啥用编辑器”，并想要尽可能快地输入一个长度为 $N$ 的字符串 $S$。\n\n你需要计算出最少需要花费多少时间。", "inputFormat": "第一行一个整数 $N$ 表示字符串长度。\n\n第二行一个长度为 $N$ 的字符串 $S$ 表示要输入的字符串。\n\n第三行一个整数 $A$ 表示操作 A 的代价。\n\n第四行一个整数 $B$ 表示操作 B 的代价。\n\n第五行一个整数 $C$ 表示操作 C 的代价。", "outputFormat": "一行一个整数表示输入字符串 $S$ 最少要多少单位时间。", "hint": "**【样例解释 #1】**\n\n以下是一组最优操作：\n\n| 轮次 | 操作 | 解释 | $X$ | $Y$ | 代价 | 总时间 |\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n| - | - | - | `\"\"` | `\"\"` | - | $0$ |\n| $1$ | 操作 A | 输入字符 | `\"s\"` | `\"\"` | $10$ | $10$ |\n| $2$ | 操作 B | 全选并剪切 |` \"\"` | `\"s\"`| $5$ | $15$ |\n| $3$ | 操作 C | 在尾部粘贴 | `\"s\"` | `\"s\"`| $2$ | $17$ |\n| $4$ | 操作 C | 在尾部粘贴 | `\"ss\"` | `\"s\"`| $2$ | $19$ |\n| $5$ | 操作 A | 输入字符 | `\"ssi\"` | `\"s\"`| $10$ | $29$ |\n| $6$ | 操作 B | 全选并剪切 |` \"\"` | `\"ssi\"`| $5$ | $34$ |\n| $7$ | 操作 A | 输入字符 | `\"m\"` | `\"ssi\"`| $10$ | $44$ |\n| $8$ | 操作 A | 输入字符 | `\"mi\"` | `\"ssi\"`| $10$ | $54$ |\n| $9$ | 操作 C | 在尾部粘贴 | `\"missi\"` | `\"ssi\"`| $2$ | $56$ |\n| $10$ | 操作 C | 在尾部粘贴 | `\"mississi\"` | `\"ssi\"`| $2$ | $58$ |\n| $11$ | 操作 A | 输入字符 | `\"mississip\"` | `\"ssi\"`| $10$ | $68$ |\n| $12$ | 操作 A | 输入字符 | `\"mississipp\"` | `\"ssi\"`| $10$ | $78$ |\n| $13$ | 操作 A | 输入字符 | `\"mississippi\"` | `\"ssi\"`| $10$ | $88$ |\n\n这组样例满足子任务 $3,4,5,6$ 的限制。\n\n**【样例解释 #2】**\n\n一组最优策略如下：\n\n| 轮次 | 操作 | 解释 | $X$ | $Y$ | 代价 | 总时间 |\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n| - | - | - | `\"\"` | `\"\"` | - | $0$ |\n| $1$ | 操作 A | 输入字符 | ` \"a\"` | `\"\"` | $1$ | $1$ |\n| $2$ | 操作 A | 输入字符 | ` \"aa\"` | `\"\"` | $1$ | $2$ |\n| $3$ | 操作 A | 输入字符 | ` \"aaa\"` | `\"\"` | $1$ | $3$ |\n| $4$ | 操作 A | 输入字符 | ` \"aaaa\"` | `\"\"` | $1$ | $4$ |\n| $5$ | 操作 B | 全选并剪切 | `\"\"` | `\"aaaa\"` | $1$ | $5$ |\n| $6$ | 操作 C | 在尾部粘贴 | `\"aaaa\"` | `\"aaaa\"` | $1$ | $6$ |\n| $7$ | 操作 C | 在尾部粘贴 | `\"aaaaaaaa\"` | `\"aaaa\"` | $1$ | $7$ |\n| $8$ | 操作 C | 在尾部粘贴 | `\"aaaaaaaaaaaa\"` | `\"aaaa\"` | $1$ | $8$ |\n| $9$ | 操作 C | 在尾部粘贴 | `\"aaaaaaaaaaaaaaaa\"` | `\"aaaa\"` | $1$ | $9$ |\n\n这组样例满足子任务 $2,3,4,5,6$ 的限制。\n\n**【样例解释 #3】**\n\n这组样例满足子任务 $3,4,5,6$ 的限制。\n\n**【数据范围】**\n\n对于所有数据，满足：\n\n- $1\\leq N\\leq 2500$\n- $S$ 是一个长度为 $N$ 的小写字母串。\n- $1\\leq A,B,C\\leq 10^9$\n\n详细子任务附加限制及分值如下表所示：\n\n|子任务编号|附加限制|分数|\n|:-:|:-:|:-:|\n|$1$|$N=3$|$1$|\n|$2$|$S$ 只包含字符 $\\texttt a$|$5$|\n|$3$|$N\\le 30$|$14$|\n|$4$|$N\\le 200$|$10$|\n|$5$|$N \\le 1000$|$32$|\n|$6$|无附加限制|$38$|", "locale": "zh-CN"}}}
{"pid": "P9524", "type": "P", "difficulty": 7, "samples": [], "limits": {"time": [4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2022", "交互题", "Special Judge", "通信题", "JOISC/JOIST（日本）"], "title": "[JOIST 2022] 飞机旅行 / Flights", "background": "请使用 C++ 20 提交。\n\n**不要**引入头文件，并在文件头加入以下内容：\n\n```cpp\nvoid SetID(int, int);\n```", "description": "\n\n在 JOI 共和国中，有 $N$ 个机场，编号从 $0$ 到 $N - 1$。有 $N - 1$ 条航线，编号从 $0$ 到 $N - 2$。航线 $i$（$0 \\le i \\le N - 2$）双向连接机场 $U_i$ 与机场 $V_i$。通过若干条航线相连，可以从任意一个机场到达任意另一个机场。对每个机场，连接它与其他机场的航线数量至多为 $3$。\n\nBenjamin 计划在 JOI 共和国旅行。在旅程的最后一天，他想到达温泉所在的机场。游乐园位于机场 $x$，温泉位于机场 $y$。由于 Benjamin 对航线一无所知，他将与航空公司的工作人员 Ali 沟通。Benjamin 想知道：从游乐园所在的机场出发，到达温泉所在的机场，最少需要乘坐多少条航线。Ali 掌握航线信息，但 Benjamin 并不知道自己应当乘坐哪些航线。\n\n1. Ali 为每个机场设置一个 **ID 码**。ID 码是介于 $0$ 和 $2N + 19$（含）之间的整数。\n2. Benjamin 得到游乐园所在机场的 ID 码 $X$，以及温泉所在机场的 ID 码 $Y$。\n3. Benjamin 向 Ali 发送一封电子邮件。该邮件是一串长度 **恰好** 等于 $20$ 的字符串，字符串的每个字符均为 $0$ 或 $1$。\n4. Ali 给 Benjamin 回一封信。该信是一串长度在 $1$ 到 $300\\,000$（含）之间的字符串，字符串的每个字符均为 $0$ 或 $1$。\n\n请编写程序，实现航空公司工作人员 Ali 与旅客 Benjamin 的策略。注意：在第 $2$ 步中，Benjamin 能得到游乐园与温泉所在机场的 ID 码 $X, Y$，**然而 Benjamin 不能获得机场编号 $x, y$**。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jd1zwpzu.png)\n\n### 实现细节\n\n你需要提交两个文件。\n\n#### `Ali.cpp`\n\n该文件应实现 Ali 的策略，并实现下述两个函数。程序应使用预处理指令 `#include` 引入 `Ali.h`。\n\n- `void Init(int N, std::vector<int> U, std::vector<int> V)`  \n  该函数用于为每个机场设置 ID 码（见「评分」中的场景说明），每个场景调用 **恰好一次**。\n  - 参数 $N$ 为 JOI 共和国中的机场数量。\n  - 参数 $U, V$ 为长度为 $N - 1$ 的数组，即 $U[i], V[i]$ 分别是航线 $i$（$0 \\le i \\le N - 2$）连接的机场 $U_i, V_i$。\n- `std::string SendA(std::string S)`  \n  该函数实现 Ali 给 Benjamin 的回信策略（见「评分」中的场景说明），在调用 `SendB`（见下文）之后、每个场景调用 **恰好一次**。\n  - 参数 $S$ 是长度为 $20$ 的字符串，即 Benjamin 发给 Ali 的电子邮件。\n  - 函数 `SendA` 应返回一个字符串，即 Ali 给 Benjamin 的回信。\n  - 返回值的长度必须在 $1$ 到 $300\\,000$（含）之间。若不满足，则判为 **Wrong Answer [5]**。\n  - 返回值的每个字符必须为 $0$ 或 $1$。若不满足，则判为 **Wrong Answer [6]**。\n\n对每次调用 `Init`，下述函数必须对每个机场调用一次，总计调用 $N$ 次：\n\n- `void SetID(int p, int value)`  \n  - 参数 $p$ 表示为机场 $p$ 设置 ID 码。必须满足 $0 \\le p \\le N - 1$。若不满足，则判为 **Wrong Answer [1]**。\n  - 参数 `value` 是 Ali 指定的该机场的 ID 码。必须满足 $0 \\le value \\le 2N + 19$。若不满足，则判为 **Wrong Answer [2]**。\n  - 不允许对同一个 $p$ 调用多次 `SetID`。若不满足，则判为 **Wrong Answer [3]**。\n  - 当 `Init` 结束时，`SetID` 的调用次数应为 $N$。若不满足，则判为 **Wrong Answer [4]**。\n\n一旦某次 `SetID` 调用被判为 Wrong Answer，程序将立即终止。\n\n#### `Benjamin.cpp`\n\n该文件应实现 Benjamin 的策略，并实现下述两个函数。程序应使用预处理指令 `#include` 引入 `Benjamin.h`。\n\n- `std::string SendB(int N, int X, int Y)`  \n  该函数实现 Benjamin 发给 Ali 的电子邮件策略（见「评分」中的场景说明），在 `Init` 调用之后、每个场景调用 **恰好一次**。\n  - 参数 $N$ 为 JOI 共和国中的机场数量。\n  - 参数 $X$ 为游乐园所在机场的 ID 码。\n  - 参数 $Y$ 为温泉所在机场的 ID 码。\n  - 函数 `SendB` 应返回 Benjamin 发给 Ali 的邮件字符串。\n  - 若返回值不是长度为 $20$ 的字符串，则判为 **Wrong Answer [7]**。\n  - 若返回值的任一字符不是 $0$ 或 $1$，则判为 **Wrong Answer [8]**。\n- `int Answer(std::string T)`  \n  该函数应计算从机场 $x$ 到机场 $y$ 的最少乘坐航线数（见「评分」中的场景说明），在 `SendA` 调用之后、每个场景调用 **恰好一次**。\n  - 参数 $T$ 为 Ali 发给 Benjamin 的回信字符串，长度在 $1$ 到 $300\\,000$（含）之间。\n  - 函数应返回从机场 $x$ 到机场 $y$ 所需的最少航线数量。\n\n### 重要注意事项\n\n- 程序可以实现其他内部使用的函数，或使用全局变量。提交的文件将与评测器一同编译，组成单个可执行文件。为避免与其他文件冲突，所有全局变量与内部函数都应声明在匿名命名空间中。评测时将分别作为 Ali 与 Benjamin 两个进程执行。Ali 进程与 Benjamin 进程 **不能共享** 全局变量。\n- 程序 **不得** 使用标准输入与标准输出。程序 **不得** 通过任何方式与其他文件通信。但你可以向标准错误输出调试信息。\n\n### 评分\n\n一个测试用例由 $Q$ 个场景组成，编号为 $0$ 到 $Q - 1$。每个场景给定如下数据（取值范围见「约束」）：\n\n- JOI 共和国的机场数量 $N$。\n- 游乐园所在的机场编号 $x$。\n- 温泉所在的机场编号 $y$。\n- 航线信息 $(U_0, V_0), (U_1, V_1), \\dots, (U_{N - 2}, V_{N - 2})$。\n\n对每个场景，依次调用 `Init`、`SendB`、`SendA`、`Answer`。你的程序应在这些调用中使用合法参数并返回合法值。调用顺序如下：\n\n1. 对 $k = 0, 1, \\dots, Q - 1$，依次执行步骤 $2$–$5$。\n2. 调用 `Init`，参数按场景 $k$ 的「实现细节」说明设置。\n3. 调用 `SendB`，参数按场景 $k$ 的「实现细节」说明设置。\n4. 调用 `SendA`，参数按场景 $k$ 的「实现细节」说明设置。\n5. 调用 `Answer`，参数按场景 $k$ 的「实现细节」说明设置。\n\n若程序在这些过程中任一处被判为 Wrong Answer，程序将立即终止，并视为未通过该测试用例。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sfw8wp0j.png)\n\n### 编译与本地测试\n\n你可以从竞赛网页下载包含样例评测器的压缩包，用于本地测试。压缩包中也包含你程序的样例源文件。\n\n样例评测器文件名为 `grader.cpp`。为测试你的程序，请将 `grader.cpp`、`Ali.cpp`、`Benjamin.cpp`、`Ali.h`、`Benjamin.h` 放在同一目录下，并运行以下命令进行编译：\n\n```\ng++ -std=gnu++17 -O2 -o grader grader.cpp Ali.cpp Benjamin.cpp\n```\n\n若编译成功，将生成可执行文件 `grader`。\n\n注意：实际评测器与样例评测器不同。样例评测器作为单进程执行，从标准输入读取数据并向标准输出写出结果。", "inputFormat": "\n样例评测器从标准输入读取如下数据。所有输入值均为整数。\n\n> $Q$  \n>（场景 $0$ 的输入）  \n>（场景 $1$ 的输入）  \n>$\\vdots$  \n>（场景 $Q - 1$ 的输入）\n\n每个场景的输入格式如下：\n\n> $N$ $x$ $y$  \n> $U_0$ $V_0$  \n> $U_1$ $V_1$  \n>$\\vdots$  \n> $U_{N - 2}$ $V_{N - 2}$", "outputFormat": "\n如果程序被判为 Wrong Answer [1]–[8] 中的任意一种，样例评测器会输出其类型（引号仅为说明）：“Wrong Answer [1]”。\n\n否则，对每个场景，它会输出函数 `Answer` 的返回值以及 Ali 发给 Benjamin 的字符串的最大长度。样例评测器 **不会** 检查 `Answer` 的返回值是否正确。\n\n```\nScenario 0: Your Answer = 3\nScenario 1: Your Answer = 1\nScenario 2: Your Answer = 4\nScenario 3: Your Answer = 1\nScenario 4: Your Answer = 5\nAccepted: Maximum Length = 24\n```\n\n如果你的程序同时满足多种 Wrong Answer 的判定条件，样例评测器只报告其中一种。此外，即使你的程序在后续场景被判为 Wrong Answer [1]–[8]，只要在第一个场景未被判错，样例评测器也可能先输出如下中间结果：\n\n```\nScenario 0: Your Answer = 3\nScenario 1: Your Answer = 1\nScenario 2: Your Answer = 4\nWrong Answer [8]\n```", "hint": "\n#### 约束\n- $1 \\le Q \\le 50$。\n- $2 \\le N \\le 10\\,000$。\n- $0 \\le U_i < V_i \\le N - 1$（$0 \\le i \\le N - 2$）。\n- $0 \\le x \\le N - 1$。\n- $0 \\le y \\le N - 1$。\n- $x \\ne y$。\n- 通过若干条航线相连，可以从任意一个机场到达任意另一个机场。\n- 对每个机场，连接它与其他机场的航线数量至多为 $3$。\n\n#### 子任务\n1.（$15$ 分）$Q = 1$。  \n2.（$85$ 分）$Q \\ge 2$。\n\n#### 子任务 1 的评分\n若你的程序在子任务 $1$ 的任意场景中被判为 Wrong Answer，则该子任务得分为 $0$。\n\n若你的程序正确回答子任务 $1$ 的所有测试用例，得分按下述规则计算。设 $L_1$ 为 Ali 发给 Benjamin 的字符串的最大长度。\n\n| $L_1$ 的取值 | 得分 |\n| :--- | :--- |\n| $150\\,001 \\le L_1 \\le 300\\,000$ | $7$ 分 |\n| $20\\,001 \\le L_1 \\le 150\\,000$ | $11$ 分 |\n| $L_1 \\le 20\\,000$ | $15$ 分 |\n\n#### 子任务 2 的评分\n若你的程序在子任务 $2$ 的任意场景中被判为 Wrong Answer，则该子任务得分为 $0$。\n\n若你的程序正确回答子任务 $2$ 的所有测试用例，得分按下述规则计算。设 $L_2$ 为 Ali 发给 Benjamin 的字符串的最大长度。**注意：若 $1\\,401 \\le L_2$，该子任务得分为 $0$。**\n\n| $L_2$ 的取值 | 得分 |\n| :--- | :--- |\n| $1\\,401 \\le L_2 \\le 300\\,000$ | $0$ 分 |\n| $71 \\le L_2 \\le 1\\,400$ | $52 - 35 \\times \\log_{10}\\!\\bigl(\\frac{L_2}{70}\\bigr)$ 分（向下取整） |\n| $45 \\le L_2 \\le 70$ | $87 - 0.5 \\times L_2$ 分（向下取整） |\n| $25 \\le L_2 \\le 44$ | $109 - L_2$ 分 |\n| $L_2 \\le 24$ | $85$ 分 |\n\n### 样例交互\n\n以下为样例评测器的样例输入与对应的函数调用。在该示例中，Ali 在 `Init` 中为机场 $0, 1, 2, 3$ 设置的 ID 码分别为 $12, 21, 25, 27$。\n\n#### 样例输入 1\n\n| Ali 的调用 | Ali 的返回值 | Benjamin 的调用 | Benjamin 的返回值 |\n| :--- | :--- | :--- | :--- |\n| $\\texttt{Init(4,[0,1,2],[1,2,3])}$ |  |  |  |\n| $\\texttt{SetID(0,12)}$ |  |  |  |\n| $\\texttt{SetID(1,21)}$ |  |  |  |\n| $\\texttt{SetID(2,25)}$ |  |  |  |\n| $\\texttt{SetID(3,27)}$ |  |  |  |\n|  |  | $\\texttt{SendB(12,25)}$ | $\\texttt{\"0000011111000011111\"}$ |\n| $\\texttt{SendA(\"00...11\")}$ | $\\texttt{\"10\"}$ |  |  |\n|  |  | $\\texttt{Answer(\"10\")}$ | $\\texttt{2}$ |\n\n在该样例中，有 $N (= 4)$ 个机场与三条航线：\n- 一条连接机场 $0$ 与机场 $1$ 的航线；\n- 一条连接机场 $1$ 与机场 $2$ 的航线；\n- 一条连接机场 $2$ 与机场 $3$ 的航线。\n\n从机场 $x (= 0)$ 到机场 $y (= 2)$ 至少需要乘坐 $2$ 条航线，因此 `Answer` 应返回 $2$。\n\n注意：`SendB` 的返回值并不是机场编号 $(x, y) = (0, 2)$，而是机场的 ID 码 $(X, Y) = (12, 25)$。\n\n#### 样例输入 2\n```\n2\n10 0 9\n0 1\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 8\n8 9\n15 12 8\n0 1\n0 2\n1 3\n1 4\n2 5\n2 6\n3 7\n3 8\n4 9\n4 10\n5 11\n5 12\n6 13\n6 14\n```\n在该样例中，$Q = 2$ 个场景：\n- 对于第一个场景，`Answer` 应返回 $9$。\n- 对于第二个场景，`Answer` 应返回 $6$。\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[JOISC 2022] Flights", "background": "", "description": " In Republic of JOI, there are $N$ airports numbered from $0$ to $N-1$. There are $N-1$ airline routes numbered from $0$ to $N-2$. The airline route $i$ ($0 \\le i \\le N-2$) connects the airport $U_i$ and the airport $V_i$ bidirectionally. It is possible to travel from any airport to any other airport by connecting several airline routes. For every airport, there are at most 3 airline routes connecting it with another airport.\n\nBenjamin is planning to take a trip in Republic of JOI. On the last day of the trip, he wants to arrive at the airport where the hot spring is located. The amusement park is located at the airport $x$, and the hot spring is located at the airport $y$. Since Benjamin does not know anything about the airline routes, he will communicate with Ali, a staff of the airplane company. Benjamin wants to know the minimum number of airline routes he has to take to travel from the airport where the amusement park is located to the airport where the hot spring is located. Ali knows information of the airline routes. But Benjamin does not know which airline routes he has to take.\n\n1.  Ali sets an **ID code** for each airport. An ID code is an integer between $0$ and $2N+19$, inclusive.\n2.  Benjamin gets the ID code $X$ of the airport where the amusement park is located, and the ID code $Y$ of the airport where the hot spring is located.\n3.  Benjamin sends an e-mail message to Ali. The message is a string whose length is **exactly** equal to 20. Every character of the message is either 0 or 1.\n4.  Ali writes a letter to Benjamin. The letter contains a string whose length is between 1 and 300 000, inclusive. Every character of the letter is either 0 or 1.\n\nWrite programs which implement the strategy of Ali, a staff of the airplane company, and the strategy of Benjamin, a traveler. Note that in Step 2, Benjamin can get the ID codes $X, Y$ of the airports where the amusement park and the hot spring are located. **However, Benjamin cannot get the airport numbers $x, y$.**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jd1zwpzu.png)\n\n### Implementation Details\n\nYou need to submit two files.\n\nThe first file is `Ali.cpp`. It should implement Ali's strategy. It should implement the following two functions. The program should include `Ali.h` using the preprocessing directive `#include`.\n\n*   `void Init(int N, std::vector<int> U, std::vector<int> V)`\n    This function implements Ali's strategy to set ID codes for each airport. For each scenario (see Grading for details), this function is called exactly once.\n    *   The parameter $N$ is the number of airports in Republic of JOI.\n    *   The parameters $U$, $V$ are arrays of length $N-1$. This means $U[i]$, $V[i]$ are the airports $U_i, V_i$ connected by the airline route $i$ ($0 \\le i \\le N-2$).\n*   `std::string SendA(std::string S)`\n    This function implements Ali's strategy to send a letter to Benjamin. For each scenario (see Grading for details), this function is called exactly once after the function `SendB` (see below) is called.\n    *   The parameter $S$ is a string of length 20. It is an e-mail message sent by Benjamin to Ali.\n    *   The function `SendA` should return a string. It is a letter written by Ali to Benjamin.\n    *   The return value should be a string whose length is between 1 and 300 000, inclusive. If this condition is not satisfied, your program is judged as **Wrong Answer [5]**.\n    *   Each character of the return value should be either 0 or 1. If this condition is not satisfied, your program is judged as **Wrong Answer [6]**.\n\nFor each function call to `Init`, the following function should be called once for each airport. In total, it should be called $N$ times.\n\n*   `void SetID(int p, int value)`\n    *   The parameter $p$ means Ali sets the ID code for the airport $p$. Here $0 \\le p \\le N-1$ should be satisfied. If this condition is not satisfied, your program is judged as **Wrong Answer [1]**.\n    *   The parameter `value` is the ID code for the airport specified by Ali. Here $0 \\le value \\le 2N+19$ should be satisfied. If this condition is not satisfied, your program is judged as **Wrong Answer [2]**.\n    *   It is not allowed to call the function `SetID` with same parameter $p$ more than once. If this condition is not satisfied, your program is judged as **Wrong Answer [3]**.\n    *   When the function `Init` terminates, the number of function calls to `SetID` should be $N$. If this condition is not satisfied, your program is judged as **Wrong Answer [4]**.\n\nWhen the function call to `SetID` is judged as Wrong Answer, your program is terminated immediately.\n\nThe second file is `Benjamin.cpp`. It should implement Benjamin's strategy. It should implement the following two functions. The program should include `Benjamin.h` using the preprocessing directive `#include`.\n\n*   `std::string SendB(int N, int X, int Y)`\n    This function implements Benjamin's strategy to send an e-mail message to Ali. For each scenario (see Grading for details), this function is called exactly once after the function `Init` is called.\n    *   The parameter $N$ is the number of airports in Republic of JOI.\n    *   The parameter $X$ is the ID code of the airport where the amusement park is located.\n    *   The parameter $Y$ is the ID code of the airport where the hot spring is located.\n    *   The function `SendB` should return a string which is the e-mail message sent by Benjamin to Ali.\n    *   If the return value is not a string of length 20, your program is judged as **Wrong Answer [7]**.\n    *   Each character of the return value should be either 0 or 1. If this condition is not satisfied, your program is judged as **Wrong Answer [8]**.\n*   `int Answer(std::string T)`\n    This function should calculate the minimum number of airline routes Benjamin has to take to travel from the airport $x$ to the airport $y$. For each scenario (see Grading for details), this function is called exactly once after the function `SendA` is called.\n    *   The parameter $T$ is a string whose length is between 1 and 300 000, inclusive. It is the letter sent by Ali to Benjamin.\n    *   This function should return the minimum number of airline routes Benjamin has to take to travel from the airport $x$ to the airport $y$.\n\n ### Important Notices\n\n*   Your program can implement other functions for internal use, or use global variables. Submitted files will be compiled with the grader, and become a single executable file. All global variables and internal functions should be declared in an unnamed namespace to avoid confliction with other files. When it is graded, it will be executed as two processes of Ali and Benjamin. The process of Ali and the process of Benjamin cannot share global variables.\n*   Your program must not use the standard input and the standard output. Your program must not communicate with other files by any methods. However, your program may output debugging information to the standard error.\n\n### Grading\n\nA test case consists of $Q$ scenarios, numbered from 0 to $Q-1$. The following values are specified for each scenario. For the range of these values, see Constraints.\n\n*   The number $N$ of airports in Republic of JOI.\n*   The airport number $x$ of the airport where the amusement park is located.\n*   The airport number $y$ of the airport where the hot spring is located.\n*   The information of the airline routes $(U_0, V_0), (U_1, V_1), \\dots, (U_{N-2}, V_{N-2})$.\n\nFor each scenario, the functions `Init`, `SendB`, `SendA`, `Answer` are called. Your program should call appropriate functions with valid parameters, and return appropriate values. These functions are called in the following order.\n\n1.  For $k = 0, 1, \\dots, Q-1$, the following procedures 2–5 are performed in this order.\n2.  The function `Init` is called. The parameters are set for the scenario $k$ as specified in Implementation Details.\n3.  The function `SendB` is called. The parameters are set for the scenario $k$ as specified in Implementation Details.\n4.  The function `SendA` is called. The parameters are set for the scenario $k$ as specified in Implementation Details.\n5.  The function `Answer` is called. The parameters are set for the scenario $k$ as specified in Implementation Details.\n\nIf your program is judged as Wrong Answer during these procedures, your program is terminated immediately, and your program is considered to fail the test case.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sfw8wp0j.png)\n\n### Compilation and Test Run\n\nYou can download an archive file from the contest webpage which contains the sample grader to test your program. The archive file also contains a sample source file of your program.\n\nThe sample grader is the file `grader.cpp`. In order to test your program, put `grader.cpp`, `Ali.cpp`, `Benjamin.cpp`, `Ali.h`, `Benjamin.h` in the same directory, and run the following command to compile your programs.\n\n```\ng++ -std=gnu++17 -O2 -o grader grader.cpp Ali.cpp Benjamin.cpp\n```\n\nWhen the compilation succeeds, the executable file `grader` is generated.\n\nNote that the actual grader is different from the sample grader. The sample grader will be executed as a single process, which will read input from the standard input and write the results to the standard output.\n", "inputFormat": "\nThe sample grader reads the following data from the standard input. The input values should be all integers.\n\n\n> $Q$\\\n> (Input for Scenario $0$)\\\n> (Input for Scenario $1$)\\\n> $\\vdots$\\\n> (Input for Scenario $Q - 1$)\n\nThe format of the input data for each scenario is as follows.\n\n\n> $N$ $x$ $y$\\\n> $U_0$ $V_0$\\\n> $U_1$ $V_1$\\\n> $\\vdots$\\\n> $U_{N-2}$ $V_{N-2}$", "outputFormat": "\nIf your program is judged as any one of Wrong Answer [1]-[8], the sample grader writes its type as “Wrong Answer [1]” (quotes for clarity).\n\nOtherwise, for each scenario, it writes the return value of the function `Answer` and the maximum length of the strings sent by Ali to Benjamin. The sample grader does not check whether the return value of the function `Answer` is correct or not.\n\n```\nScenario 0: Your Answer = 3\nScenario 1: Your Answer = 1\nScenario 2: Your Answer = 4\nScenario 3: Your Answer = 1\nScenario 4: Your Answer = 5\nAccepted: Maximum Length = 24\n```\n\nIf your program satisfies the conditions of several types of Wrong Answer, the sample grader reports only one of them. Moreover, if your program is not judged as Wrong Answer for the first scenario, the sample grader may output intermediate results as follows even if your program is judged as one of Wrong Answer [1]-[8] for a later scenario.\n\n```\nScenario 0: Your Answer = 3\nScenario 1: Your Answer = 1\nScenario 2: Your Answer = 4\nWrong Answer [8]\n```\n", "hint": "\n ### Constraints\n* $1 \\le Q \\le 50$.\n* $2 \\le N \\le 10\\,000$.\n* $0 \\le U_i < V_i \\le N - 1$ ($0 \\le i \\le N - 2$).\n* $0 \\le x \\le N - 1$.\n* $0 \\le y \\le N - 1$.\n* $x \\ne y$.\n* It is possible to travel from any airport to any other airport by connecting several airline routes.\n* For every airport, there are at most 3 airline routes connecting it with another airport.\n\n### Subtasks\n1. (15 points) $Q = 1$.\n2. (85 points) $Q \\ge 2$.\n\n### Grading for Subtask 1\nIf your program is judged as Wrong Answer in any of the scenarios for Subtask 1, your score for this subtask is 0.\n\nIf your program answers all the test cases for Subtask 1 correctly, your score for this subtask is calculated as follows. Here, $L_1$ is the maximum length of the strings sent by Ali to Benjamin.\n\n| The value of $L_1$ | Score |\n| :--- | :--- |\n| $150\\,001 \\le L_1 \\le 300\\,000$ | 7 points |\n| $20\\,001 \\le L_1 \\le 150\\,000$ | 11 points |\n| $L_1 \\le 20\\,000$ | 15 points |\n\n### Grading for Subtask 2\nIf your program is judged as Wrong Answer in any of the scenarios for Subtask 2, your score for this subtask is 0.\n\nIf your program answers all the test cases for Subtask 2 correctly, your score for this subtask is calculated as follows. Here, $L_2$ is the maximum length of the strings sent by Ali to Benjamin. **Note that if $1\\,401 \\le L_2$, your score for this subtask is 0.**\n\n| The value of $L_2$ | Score |\n| :--- | :--- |\n| $1\\,401 \\le L_2 \\le 300\\,000$ | 0 points |\n| $71 \\le L_2 \\le 1\\,400$ | $52 - 35 \\times \\log_{10}(\\frac{L_2}{70})$ points (rounded down to the nearest integer) |\n| $45 \\le L_2 \\le 70$ | $87 - 0.5 \\times L_2$ points (rounded down to the nearest integer) |\n| $25 \\le L_2 \\le 44$ | $109 - L_2$ points |\n| $L_2 \\le 24$ | 85 points |\n\n### Sample Communication\nHere is a sample input for the sample grader and corresponding function calls. In the following example, the ID codes of the airports 0, 1, 2, 3 set by Ali by calling the function `Init` are 12, 21, 25, 27, respectively.\n\n#### Sample Input 1\n\n```\n1\n4 0 2\n0 1\n1 2\n2 3\n```\n\n| Ali's Call | Ali's Return Value | Benjamin's Call | Benjamin's Return Value |\n| :--- | :--- | :--- | :--- |\n| $\\texttt{Init(4,[0,1,2],[1,2,3])}$ | | | |\n| $\\texttt{SetID(0,12)}$ | | | |\n| $\\texttt{SetID(1,21)}$ | | | |\n| $\\texttt{SetID(2,25)}$ | | | |\n| $\\texttt{SetID(3,27)}$ | | | |\n| | | $\\texttt{SendB(12,25)}$ | $\\texttt{\"0000011111000011111\"}$ |\n| $\\texttt{SendA(\"00...11\")}$ | $\\texttt{\"10\"}$ | | |\n| | | $\\texttt{Answer(\"10\")}$ | $\\texttt{2}$ |\n\nIn this sample input, there are $N (= 4)$ airports and three airline routes.\n* An airline route connecting the airport 0 with the airport 1.\n* An airline route connecting the airport 1 with the airport 2.\n* An airline route connecting the airport 2 with the airport 3.\n\nSince we need to take at least two airline routes to travel from the airport $x (= 0)$ to the airport $y (= 2)$, the function `Answer` should return 2.\n\nNote that the return value of the function `SendB` is not the airport numbers $(x, y) = (0, 2)$. It returns the ID codes of the airports $(X, Y) = (12, 25)$.\n\n\n#### Sample Input 2\n\n```\n2\n10 0 9\n0 1\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 8\n8 9\n15 12 8\n0 1\n0 2\n1 3\n1 4\n2 5\n2 6\n3 7\n3 8\n4 9\n4 10\n5 11\n5 12\n6 13\n6 14\n```\n\n\nIn this sample input, there are $Q = 2$ scenarios.\n* For the first scenario, the function `Answer` should return 9.\n* For the second scenario, the function `Answer` should return 6.\n\n", "locale": "en"}, "zh-CN": {"title": "[JOIST 2022] 飞机旅行 / Flights", "background": "请使用 C++ 20 提交。\n\n**不要**引入头文件，并在文件头加入以下内容：\n\n```cpp\nvoid SetID(int, int);\n```", "description": "\n\n在 JOI 共和国中，有 $N$ 个机场，编号从 $0$ 到 $N - 1$。有 $N - 1$ 条航线，编号从 $0$ 到 $N - 2$。航线 $i$（$0 \\le i \\le N - 2$）双向连接机场 $U_i$ 与机场 $V_i$。通过若干条航线相连，可以从任意一个机场到达任意另一个机场。对每个机场，连接它与其他机场的航线数量至多为 $3$。\n\nBenjamin 计划在 JOI 共和国旅行。在旅程的最后一天，他想到达温泉所在的机场。游乐园位于机场 $x$，温泉位于机场 $y$。由于 Benjamin 对航线一无所知，他将与航空公司的工作人员 Ali 沟通。Benjamin 想知道：从游乐园所在的机场出发，到达温泉所在的机场，最少需要乘坐多少条航线。Ali 掌握航线信息，但 Benjamin 并不知道自己应当乘坐哪些航线。\n\n1. Ali 为每个机场设置一个 **ID 码**。ID 码是介于 $0$ 和 $2N + 19$（含）之间的整数。\n2. Benjamin 得到游乐园所在机场的 ID 码 $X$，以及温泉所在机场的 ID 码 $Y$。\n3. Benjamin 向 Ali 发送一封电子邮件。该邮件是一串长度 **恰好** 等于 $20$ 的字符串，字符串的每个字符均为 $0$ 或 $1$。\n4. Ali 给 Benjamin 回一封信。该信是一串长度在 $1$ 到 $300\\,000$（含）之间的字符串，字符串的每个字符均为 $0$ 或 $1$。\n\n请编写程序，实现航空公司工作人员 Ali 与旅客 Benjamin 的策略。注意：在第 $2$ 步中，Benjamin 能得到游乐园与温泉所在机场的 ID 码 $X, Y$，**然而 Benjamin 不能获得机场编号 $x, y$**。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jd1zwpzu.png)\n\n### 实现细节\n\n你需要提交两个文件。\n\n#### `Ali.cpp`\n\n该文件应实现 Ali 的策略，并实现下述两个函数。程序应使用预处理指令 `#include` 引入 `Ali.h`。\n\n- `void Init(int N, std::vector<int> U, std::vector<int> V)`  \n  该函数用于为每个机场设置 ID 码（见「评分」中的场景说明），每个场景调用 **恰好一次**。\n  - 参数 $N$ 为 JOI 共和国中的机场数量。\n  - 参数 $U, V$ 为长度为 $N - 1$ 的数组，即 $U[i], V[i]$ 分别是航线 $i$（$0 \\le i \\le N - 2$）连接的机场 $U_i, V_i$。\n- `std::string SendA(std::string S)`  \n  该函数实现 Ali 给 Benjamin 的回信策略（见「评分」中的场景说明），在调用 `SendB`（见下文）之后、每个场景调用 **恰好一次**。\n  - 参数 $S$ 是长度为 $20$ 的字符串，即 Benjamin 发给 Ali 的电子邮件。\n  - 函数 `SendA` 应返回一个字符串，即 Ali 给 Benjamin 的回信。\n  - 返回值的长度必须在 $1$ 到 $300\\,000$（含）之间。若不满足，则判为 **Wrong Answer [5]**。\n  - 返回值的每个字符必须为 $0$ 或 $1$。若不满足，则判为 **Wrong Answer [6]**。\n\n对每次调用 `Init`，下述函数必须对每个机场调用一次，总计调用 $N$ 次：\n\n- `void SetID(int p, int value)`  \n  - 参数 $p$ 表示为机场 $p$ 设置 ID 码。必须满足 $0 \\le p \\le N - 1$。若不满足，则判为 **Wrong Answer [1]**。\n  - 参数 `value` 是 Ali 指定的该机场的 ID 码。必须满足 $0 \\le value \\le 2N + 19$。若不满足，则判为 **Wrong Answer [2]**。\n  - 不允许对同一个 $p$ 调用多次 `SetID`。若不满足，则判为 **Wrong Answer [3]**。\n  - 当 `Init` 结束时，`SetID` 的调用次数应为 $N$。若不满足，则判为 **Wrong Answer [4]**。\n\n一旦某次 `SetID` 调用被判为 Wrong Answer，程序将立即终止。\n\n#### `Benjamin.cpp`\n\n该文件应实现 Benjamin 的策略，并实现下述两个函数。程序应使用预处理指令 `#include` 引入 `Benjamin.h`。\n\n- `std::string SendB(int N, int X, int Y)`  \n  该函数实现 Benjamin 发给 Ali 的电子邮件策略（见「评分」中的场景说明），在 `Init` 调用之后、每个场景调用 **恰好一次**。\n  - 参数 $N$ 为 JOI 共和国中的机场数量。\n  - 参数 $X$ 为游乐园所在机场的 ID 码。\n  - 参数 $Y$ 为温泉所在机场的 ID 码。\n  - 函数 `SendB` 应返回 Benjamin 发给 Ali 的邮件字符串。\n  - 若返回值不是长度为 $20$ 的字符串，则判为 **Wrong Answer [7]**。\n  - 若返回值的任一字符不是 $0$ 或 $1$，则判为 **Wrong Answer [8]**。\n- `int Answer(std::string T)`  \n  该函数应计算从机场 $x$ 到机场 $y$ 的最少乘坐航线数（见「评分」中的场景说明），在 `SendA` 调用之后、每个场景调用 **恰好一次**。\n  - 参数 $T$ 为 Ali 发给 Benjamin 的回信字符串，长度在 $1$ 到 $300\\,000$（含）之间。\n  - 函数应返回从机场 $x$ 到机场 $y$ 所需的最少航线数量。\n\n### 重要注意事项\n\n- 程序可以实现其他内部使用的函数，或使用全局变量。提交的文件将与评测器一同编译，组成单个可执行文件。为避免与其他文件冲突，所有全局变量与内部函数都应声明在匿名命名空间中。评测时将分别作为 Ali 与 Benjamin 两个进程执行。Ali 进程与 Benjamin 进程 **不能共享** 全局变量。\n- 程序 **不得** 使用标准输入与标准输出。程序 **不得** 通过任何方式与其他文件通信。但你可以向标准错误输出调试信息。\n\n### 评分\n\n一个测试用例由 $Q$ 个场景组成，编号为 $0$ 到 $Q - 1$。每个场景给定如下数据（取值范围见「约束」）：\n\n- JOI 共和国的机场数量 $N$。\n- 游乐园所在的机场编号 $x$。\n- 温泉所在的机场编号 $y$。\n- 航线信息 $(U_0, V_0), (U_1, V_1), \\dots, (U_{N - 2}, V_{N - 2})$。\n\n对每个场景，依次调用 `Init`、`SendB`、`SendA`、`Answer`。你的程序应在这些调用中使用合法参数并返回合法值。调用顺序如下：\n\n1. 对 $k = 0, 1, \\dots, Q - 1$，依次执行步骤 $2$–$5$。\n2. 调用 `Init`，参数按场景 $k$ 的「实现细节」说明设置。\n3. 调用 `SendB`，参数按场景 $k$ 的「实现细节」说明设置。\n4. 调用 `SendA`，参数按场景 $k$ 的「实现细节」说明设置。\n5. 调用 `Answer`，参数按场景 $k$ 的「实现细节」说明设置。\n\n若程序在这些过程中任一处被判为 Wrong Answer，程序将立即终止，并视为未通过该测试用例。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sfw8wp0j.png)\n\n### 编译与本地测试\n\n你可以从竞赛网页下载包含样例评测器的压缩包，用于本地测试。压缩包中也包含你程序的样例源文件。\n\n样例评测器文件名为 `grader.cpp`。为测试你的程序，请将 `grader.cpp`、`Ali.cpp`、`Benjamin.cpp`、`Ali.h`、`Benjamin.h` 放在同一目录下，并运行以下命令进行编译：\n\n```\ng++ -std=gnu++17 -O2 -o grader grader.cpp Ali.cpp Benjamin.cpp\n```\n\n若编译成功，将生成可执行文件 `grader`。\n\n注意：实际评测器与样例评测器不同。样例评测器作为单进程执行，从标准输入读取数据并向标准输出写出结果。", "inputFormat": "\n样例评测器从标准输入读取如下数据。所有输入值均为整数。\n\n> $Q$  \n>（场景 $0$ 的输入）  \n>（场景 $1$ 的输入）  \n>$\\vdots$  \n>（场景 $Q - 1$ 的输入）\n\n每个场景的输入格式如下：\n\n> $N$ $x$ $y$  \n> $U_0$ $V_0$  \n> $U_1$ $V_1$  \n>$\\vdots$  \n> $U_{N - 2}$ $V_{N - 2}$", "outputFormat": "\n如果程序被判为 Wrong Answer [1]–[8] 中的任意一种，样例评测器会输出其类型（引号仅为说明）：“Wrong Answer [1]”。\n\n否则，对每个场景，它会输出函数 `Answer` 的返回值以及 Ali 发给 Benjamin 的字符串的最大长度。样例评测器 **不会** 检查 `Answer` 的返回值是否正确。\n\n```\nScenario 0: Your Answer = 3\nScenario 1: Your Answer = 1\nScenario 2: Your Answer = 4\nScenario 3: Your Answer = 1\nScenario 4: Your Answer = 5\nAccepted: Maximum Length = 24\n```\n\n如果你的程序同时满足多种 Wrong Answer 的判定条件，样例评测器只报告其中一种。此外，即使你的程序在后续场景被判为 Wrong Answer [1]–[8]，只要在第一个场景未被判错，样例评测器也可能先输出如下中间结果：\n\n```\nScenario 0: Your Answer = 3\nScenario 1: Your Answer = 1\nScenario 2: Your Answer = 4\nWrong Answer [8]\n```", "hint": "\n#### 约束\n- $1 \\le Q \\le 50$。\n- $2 \\le N \\le 10\\,000$。\n- $0 \\le U_i < V_i \\le N - 1$（$0 \\le i \\le N - 2$）。\n- $0 \\le x \\le N - 1$。\n- $0 \\le y \\le N - 1$。\n- $x \\ne y$。\n- 通过若干条航线相连，可以从任意一个机场到达任意另一个机场。\n- 对每个机场，连接它与其他机场的航线数量至多为 $3$。\n\n#### 子任务\n1.（$15$ 分）$Q = 1$。  \n2.（$85$ 分）$Q \\ge 2$。\n\n#### 子任务 1 的评分\n若你的程序在子任务 $1$ 的任意场景中被判为 Wrong Answer，则该子任务得分为 $0$。\n\n若你的程序正确回答子任务 $1$ 的所有测试用例，得分按下述规则计算。设 $L_1$ 为 Ali 发给 Benjamin 的字符串的最大长度。\n\n| $L_1$ 的取值 | 得分 |\n| :--- | :--- |\n| $150\\,001 \\le L_1 \\le 300\\,000$ | $7$ 分 |\n| $20\\,001 \\le L_1 \\le 150\\,000$ | $11$ 分 |\n| $L_1 \\le 20\\,000$ | $15$ 分 |\n\n#### 子任务 2 的评分\n若你的程序在子任务 $2$ 的任意场景中被判为 Wrong Answer，则该子任务得分为 $0$。\n\n若你的程序正确回答子任务 $2$ 的所有测试用例，得分按下述规则计算。设 $L_2$ 为 Ali 发给 Benjamin 的字符串的最大长度。**注意：若 $1\\,401 \\le L_2$，该子任务得分为 $0$。**\n\n| $L_2$ 的取值 | 得分 |\n| :--- | :--- |\n| $1\\,401 \\le L_2 \\le 300\\,000$ | $0$ 分 |\n| $71 \\le L_2 \\le 1\\,400$ | $52 - 35 \\times \\log_{10}\\!\\bigl(\\frac{L_2}{70}\\bigr)$ 分（向下取整） |\n| $45 \\le L_2 \\le 70$ | $87 - 0.5 \\times L_2$ 分（向下取整） |\n| $25 \\le L_2 \\le 44$ | $109 - L_2$ 分 |\n| $L_2 \\le 24$ | $85$ 分 |\n\n### 样例交互\n\n以下为样例评测器的样例输入与对应的函数调用。在该示例中，Ali 在 `Init` 中为机场 $0, 1, 2, 3$ 设置的 ID 码分别为 $12, 21, 25, 27$。\n\n#### 样例输入 1\n\n| Ali 的调用 | Ali 的返回值 | Benjamin 的调用 | Benjamin 的返回值 |\n| :--- | :--- | :--- | :--- |\n| $\\texttt{Init(4,[0,1,2],[1,2,3])}$ |  |  |  |\n| $\\texttt{SetID(0,12)}$ |  |  |  |\n| $\\texttt{SetID(1,21)}$ |  |  |  |\n| $\\texttt{SetID(2,25)}$ |  |  |  |\n| $\\texttt{SetID(3,27)}$ |  |  |  |\n|  |  | $\\texttt{SendB(12,25)}$ | $\\texttt{\"0000011111000011111\"}$ |\n| $\\texttt{SendA(\"00...11\")}$ | $\\texttt{\"10\"}$ |  |  |\n|  |  | $\\texttt{Answer(\"10\")}$ | $\\texttt{2}$ |\n\n在该样例中，有 $N (= 4)$ 个机场与三条航线：\n- 一条连接机场 $0$ 与机场 $1$ 的航线；\n- 一条连接机场 $1$ 与机场 $2$ 的航线；\n- 一条连接机场 $2$ 与机场 $3$ 的航线。\n\n从机场 $x (= 0)$ 到机场 $y (= 2)$ 至少需要乘坐 $2$ 条航线，因此 `Answer` 应返回 $2$。\n\n注意：`SendB` 的返回值并不是机场编号 $(x, y) = (0, 2)$，而是机场的 ID 码 $(X, Y) = (12, 25)$。\n\n#### 样例输入 2\n```\n2\n10 0 9\n0 1\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 8\n8 9\n15 12 8\n0 1\n0 2\n1 3\n1 4\n2 5\n2 6\n3 7\n3 8\n4 9\n4 10\n5 11\n5 12\n6 13\n6 14\n```\n在该样例中，$Q = 2$ 个场景：\n- 对于第一个场景，`Answer` 应返回 $9$。\n- 对于第二个场景，`Answer` 应返回 $6$。\n\n", "locale": "zh-CN"}}}
{"pid": "P9525", "type": "P", "difficulty": 5, "samples": [["5\n3 1 4\n2 3 1\n1 5 5\n4 4 2\n5 2 3", "13"], ["8\n1 1 1\n1 1 5\n1 5 1\n5 1 1\n1 5 5\n5 1 5\n5 5 1\n5 5 5", "15"], ["4\n1 2 3\n1 2 3\n1 2 3\n1 2 3", "-1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "2022", "O2优化", "优先队列", "JOISC/JOIST（日本）"], "title": "[JOIST 2022] 团队竞技 / Team Contest", "background": "JOISC2022 D2T3", "description": "JOI 大学有 $N$ 只海狸，他们都参与竞技编程。每只海狸有三项能力值：思考值，行动值和运气值。如果一个能力值很大，意味着他这项能力比较强大。对于第 $i~(i\\in[1,N])$ 只海狸，他的思考值为 $X_i$，行动值为 $Y_i$，运气值为 $Z_i$。\n\n今年 JOI 大学的海狸们将参与一场团体竞技编程，一支队伍由三名队员组成。Bitaro 是 JOI 大学的教练，由于团队合作很重要，Bitaro 决定从 $N$ 只海狸中选出三只海狸组成队伍，这三只海狸要满足以下条件：\n\n**条件**：每个成员都有自己的优势，这意味着每个成员都有一项能力值严格大于其他两人的对应能力值。\n\n在所有符合条件的组队中，Bitaro 想要选一个总能力最强的队伍，一个队伍的总能力定义为：三人最大思考值，三人最大行动值和三人最大运气值之和。\n\n请你求出，是否存在一个符合条件的组队，如果是，计算队伍总能力可能的最大值。", "inputFormat": "第一行一个整数 $N$ 表示海狸数。\n\n接下来 $N$ 行每行三个整数 $X_i,Y_i,Z_i$ 表示海狸的各项能力值。", "outputFormat": "一行一个整数，如果不存在符合条件的组队，输出 `-1`，否则输出队伍总能力的最大值。", "hint": "**【样例解释 #1】**\n\n由海狸 $1,4,5$ 组成的队伍符合条件，因为：\n\n1. 海狸 $1$ 的优势是运气。\n2. 海狸 $4$ 的优势是行动。\n3. 海狸 $5$ 的优势是思考。\n\n总能力值为：$5+4+4=13$。\n\n可以证明这是符合条件的组队中，总能力值最高的队伍。\n\n注意如果选择海狸 $1,3,5$，总能力值将达到 $15$，但是这会导致海狸 $1$ 没有特长。\n\n这组样例满足所有子任务的限制。\n\n**【样例解释 #2】**\n\n最优组队为：海狸 $2,3,4$。\n\n这组样例满足所有子任务的限制。\n\n**【样例解释 #3】**\n\n任何组队方式都会导致队员没有特长，不存在符合条件的组队。\n\n这组样例满足所有子任务的限制。\n\n**【数据范围】**\n\n对于所有数据，满足：\n\n- $3\\leq N\\leq 150000$。\n- $1\\leq X_i,Y_i,Z_i\\leq 10^8$ $(1\\leq i\\leq N)$。\n\n详细子任务附加限制及分值如下表所示：\n\n|子任务编号|附加限制|分值|\n|:-:|:-:|:-:|\n|$1$|$N\\leq 300$|$8$|\n|$2$|$N\\leq 4000$|$29$|\n|$3$|$X_i,Y_i,Z_i\\leq 5$ $(i\\in[1,N])$|$9$|\n|$4$|$X_i,Y_i,Z_i\\leq 20$ $(i\\in[1,N])$|$9$|\n|$5$|$X_i,Y_i,Z_i\\leq 300$ $(i\\in[1,N])$|$9$|\n|$6$|$X_i,Y_i,Z_i\\leq 4000$ $(i\\in[1,N])$|$9$|\n|$7$|无附加限制|$27$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIST 2022] 团队竞技 / Team Contest", "background": "JOISC2022 D2T3", "description": "JOI 大学有 $N$ 只海狸，他们都参与竞技编程。每只海狸有三项能力值：思考值，行动值和运气值。如果一个能力值很大，意味着他这项能力比较强大。对于第 $i~(i\\in[1,N])$ 只海狸，他的思考值为 $X_i$，行动值为 $Y_i$，运气值为 $Z_i$。\n\n今年 JOI 大学的海狸们将参与一场团体竞技编程，一支队伍由三名队员组成。Bitaro 是 JOI 大学的教练，由于团队合作很重要，Bitaro 决定从 $N$ 只海狸中选出三只海狸组成队伍，这三只海狸要满足以下条件：\n\n**条件**：每个成员都有自己的优势，这意味着每个成员都有一项能力值严格大于其他两人的对应能力值。\n\n在所有符合条件的组队中，Bitaro 想要选一个总能力最强的队伍，一个队伍的总能力定义为：三人最大思考值，三人最大行动值和三人最大运气值之和。\n\n请你求出，是否存在一个符合条件的组队，如果是，计算队伍总能力可能的最大值。", "inputFormat": "第一行一个整数 $N$ 表示海狸数。\n\n接下来 $N$ 行每行三个整数 $X_i,Y_i,Z_i$ 表示海狸的各项能力值。", "outputFormat": "一行一个整数，如果不存在符合条件的组队，输出 `-1`，否则输出队伍总能力的最大值。", "hint": "**【样例解释 #1】**\n\n由海狸 $1,4,5$ 组成的队伍符合条件，因为：\n\n1. 海狸 $1$ 的优势是运气。\n2. 海狸 $4$ 的优势是行动。\n3. 海狸 $5$ 的优势是思考。\n\n总能力值为：$5+4+4=13$。\n\n可以证明这是符合条件的组队中，总能力值最高的队伍。\n\n注意如果选择海狸 $1,3,5$，总能力值将达到 $15$，但是这会导致海狸 $1$ 没有特长。\n\n这组样例满足所有子任务的限制。\n\n**【样例解释 #2】**\n\n最优组队为：海狸 $2,3,4$。\n\n这组样例满足所有子任务的限制。\n\n**【样例解释 #3】**\n\n任何组队方式都会导致队员没有特长，不存在符合条件的组队。\n\n这组样例满足所有子任务的限制。\n\n**【数据范围】**\n\n对于所有数据，满足：\n\n- $3\\leq N\\leq 150000$。\n- $1\\leq X_i,Y_i,Z_i\\leq 10^8$ $(1\\leq i\\leq N)$。\n\n详细子任务附加限制及分值如下表所示：\n\n|子任务编号|附加限制|分值|\n|:-:|:-:|:-:|\n|$1$|$N\\leq 300$|$8$|\n|$2$|$N\\leq 4000$|$29$|\n|$3$|$X_i,Y_i,Z_i\\leq 5$ $(i\\in[1,N])$|$9$|\n|$4$|$X_i,Y_i,Z_i\\leq 20$ $(i\\in[1,N])$|$9$|\n|$5$|$X_i,Y_i,Z_i\\leq 300$ $(i\\in[1,N])$|$9$|\n|$6$|$X_i,Y_i,Z_i\\leq 4000$ $(i\\in[1,N])$|$9$|\n|$7$|无附加限制|$27$|", "locale": "zh-CN"}}}
{"pid": "P9526", "type": "P", "difficulty": 7, "samples": [], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "交互题", "Special Judge", "通信题", "JOISC/JOIST（日本）"], "title": "[JOIST 2022] 坏掉的设备 2 / Broken Device 2", "background": "不要引入头文件，并使用 **C++ 20** 提交。", "description": "\nAnna 和 Bruno 是赌术大师。他们将和担任庄家的 D-taro 玩一个游戏。在这个游戏中，Anna 和 Bruno 分别待在不同的房间里。他们只能使用一台损坏的装置相互通信。D-taro 会给 Anna 一个整数。对于 Anna 和 Bruno 来说，这个游戏的目标是使用该装置，把给定的整数从 Anna 传递给 Bruno。\n\n当游戏开始时，一开始，Anna 声明一个整数 $m$，其取值在 1 到 2 000（含）之间。然后他们进行 $Q$ 轮。第 $i$ 轮（$1 \\le i \\le Q$）按如下方式进行。\n\n1. D-taro 给 Anna 一个整数 $A_i$。\n2. Anna 向装置输入数组 $s_i, t_i$。数组 $s_i, t_i$ 的每个元素都必须为 0 或 1。数组 $s_i, t_i$ 的长度必须相同，且长度在 1 到 $m$（含）之间。\n3. 令 $u_i$ 为由数组 $s_i$ 和 $t_i$ 通过 **riffle shuffle**（见下文）得到的数组。然后装置将 $u_i$ 发送给 Bruno。\n4. Bruno 向 D-taro 发送一个整数。若该整数与 D-taro 给 Anna 的整数 $A_i$ 相同，则 Anna 和 Bruno 在本轮获胜。\n\n请编写实现 Anna 和 Bruno 策略的程序，使他们在全部 $Q$ 轮中都能获胜。\n\n### 洗牌交错（riffle shuffle）\n\n若能将数组 $Z$ 的元素划分为两组，并满足以下两个条件，则称数组 $Z$ 是由数组 $X$ 和数组 $Y$ 通过 riffle shuffle 得到的。\n\n* 由第一组元素按原有顺序组成的数组等于数组 $X$。\n* 由第二组元素按原有顺序组成的数组等于数组 $Y$。\n\n例如，数组 $Z = [1, 1, 1, 0, 0, 0]$ 可由 $X = [1, 1, 0]$ 与 $Y = [1, 0, 0]$ 通过 riffle shuffle 得到，因为由 $Z$ 的第 1、2、4 个元素按原顺序组成的数组为 $[1, 1, 0]$，而由第 3、5、6 个元素按原顺序组成的数组为 $[1, 0, 0]$。\n\n另一方面，若 $X = [1, 1, 0]$、$Y = [1, 0, 0]$，而 $Z = [0, 0, 0, 1, 1, 1]$，则数组 $Z$ 不是由 $X$ 和 $Y$ 通过 riffle shuffle 得到的。\n\n### 实现细节\n\n你需要提交两个文件。\n\n第一个文件是 `Anna.cpp`。它应实现 Anna 的策略，并实现下列函数。程序应通过预处理指令 `#include` 包含 `Anna.h`。\n\n* `int Declare()`\n\n  该函数在开始时被调用一次。\n  * 返回值是 Anna 声明的整数 $m$。\n  * 整数 $m$ 必须在 1 到 2 000（含）之间。若不满足此条件，你的程序将被判为 **Wrong Answer [1]**。\n\n* `std::pair<std::vector<int>, std::vector<int>> Anna(long long A)`\n\n  在调用 `Declare` 之后，该函数将被调用 $Q$ 次。第 $i$ 次调用（$1 \\le i \\le Q$）对应第 $i$ 轮的步骤 1 和步骤 2。\n  * 参数 $A$ 是 D-taro 给 Anna 的整数 $A_i$。\n  * 返回值是 Anna 输入到装置中的两个数组 $s_i, t_i$ 组成的二元组。\n  * 数组 $s_i, t_i$ 的每个元素都必须为 0 或 1。若不满足此条件，你的程序将被判为 **Wrong Answer [2]**。\n  * 数组 $s_i, t_i$ 的长度都必须在 1 到 $m$（含）之间。若不满足此条件，你的程序将被判为 **Wrong Answer [3]**。\n  * 数组 $s_i, t_i$ 的长度必须相同。若不满足此条件，你的程序将被判为 **Wrong Answer [4]**。\n\n第二个文件是 `Bruno.cpp`。它应实现 Bruno 的策略，并实现下列函数。程序应通过预处理指令 `#include` 包含 `Bruno.h`。\n\n* `long long Bruno(std::vector<int> u)`\n\n  在 Anna 向装置输入数组之后，该函数会被调用一次。总共，该函数会被调用 $Q$ 次。第 $i$ 次调用（$1 \\le i \\le Q$）对应第 $i$ 轮的步骤 3 和步骤 4。\n  * 参数 `u` 是装置在第 $i$ 轮发送给 Bruno 的数组 $u_i$。\n  * 返回值是 Bruno 发送给 D-taro 的整数。\n  * 返回值必须与 D-taro 给 Anna 的整数 $A_i$ 相同。若不满足此条件，你的程序将被判为 **Wrong Answer [5]**。\n\n### 重要注意事项\n\n* 你的程序可以实现其他用于内部的函数，或使用全局变量。提交的文件将与评测器一起编译，变成一个可执行文件。所有全局变量和内部函数都应当声明在未命名命名空间中，以避免与其他文件冲突。评测时会以 Anna 进程和 Bruno 进程两个进程形式运行。Anna 进程与 Bruno 进程不能共享全局变量。\n* 你的程序不得使用标准输入与标准输出。你的程序不得通过任何方式与其他文件通信。但是，你的程序可以向标准错误输出调试信息。\n\n### 编译与本地测试\n\n你可以从竞赛网页下载一个压缩包，其中包含用于本地测试你程序的样例评测器。压缩包还包含你程序的样例源代码。\n\n样例评测器为文件 `grader.cpp`。为了测试你的程序，请将 `grader.cpp`、`Anna.cpp`、`Bruno.cpp`、`Anna.h`、`Bruno.h` 放在同一目录下，并运行如下命令以编译程序。\n\n```\ng++ -std=gnu++17 -O2 -o grader grader.cpp Anna.cpp Bruno.cpp\n```\n\n编译成功后，会生成名为 `grader` 的可执行文件。\n\n请注意，实际评测器与样例评测器不同。样例评测器以单进程形式运行，从标准输入读入数据，并将结果写到标准输出。\n", "inputFormat": "\n样例评测器从标准输入读取如下数据。\n\n> $Q$ \\\n> $A_1$ \\\n> $A_2$ \\\n> $\\vdots$ \\\n> $A_Q$\n", "outputFormat": "\n样例评测器向标准输出写出如下信息（引号仅为说明）。\n\n* 若你的程序被判定为正确，它会输出函数 `Declare` 的返回值 $m$，例如 “Accepted: 2000”。\n* 若你的程序被判定为任一类 Wrong Answer，样例评测器会写出其类型，例如 “Wrong Answer [1]”。\n\n如果你的程序同时触犯多类 Wrong Answer 的条件，样例评测器只报告其中一种。\n\n样例评测器在每一轮计算 riffle shuffle 时使用伪随机数。其结果在不同执行中不会改变。为了更改伪随机数的种子，请如下方式执行样例评测器。\n\n```\n./grader 2022\n```\n\n第一个参数应为一个整数。\n", "hint": "\n#### 约束\n\n* $1 \\le Q \\le 1\\,000$。\n* $1 \\le A_i \\le 1\\,000\\,000\\,000\\,000\\,000\\,000 \\ (= 10^{18}) \\ (1 \\le i \\le Q)$。\n\n#### 子任务\n\n1. （5 分）$A_i \\le 2\\,000 \\ (1 \\le i \\le Q)$。\n2. （5 分）$A_i \\le 4\\,000\\,000 \\ (1 \\le i \\le Q)$。\n3. （3 分）$A_i \\le 10\\,000\\,000 \\ (= 10^7) \\ (1 \\le i \\le Q)$。\n4. （12 分）$A_i \\le 100\\,000\\,000 \\ (= 10^8) \\ (1 \\le i \\le Q)$。\n5. （15 分）$A_i \\le 100\\,000\\,000\\,000 \\ (= 10^{11}) \\ (1 \\le i \\le Q)$。\n6. （60 分）无限制。对于本子任务，你的得分计算如下。\n   * 令 $m^*$ 为本子任务所有测试中，Anna 声明的整数 $m$ 的最大值。\n   * 你的得分如下所示。\n\n| $m^*$ 的取值 | 分数 |\n| :--- | :--- |\n| $201 \\le m^* \\le 2\\,000$ | $40 - 25 \\times \\log_{10}\\!\\left(\\dfrac{m^*}{200}\\right)$ 分（向下取整为整数） |\n| $161 \\le m^* \\le 200$ | 40 分 |\n| $156 \\le m^* \\le 160$ | 44 分 |\n| $151 \\le m^* \\le 155$ | 48 分 |\n| $146 \\le m^* \\le 150$ | 52 分 |\n| $141 \\le m^* \\le 145$ | 56 分 |\n| $m^* \\le 140$ | 60 分 |\n\n### 样例通信\n\n下面给出样例评测器的一个样例输入以及相应的函数调用。\n\n#### 样例输入 1\n\n```\n2\n42\n2000\n```\n\n| 调用 | 返回值 |\n| :--- | :--- |\n| `Declare()` | 4 |\n| `Anna(42)` | `([0, 0, 1, 0], [1, 1, 0, 1])` |\n| `Bruno([1, 0, 0, 1, 0, 1, 0, 1])` | 42 |\n| `Anna(2000)` | `([0, 1], [0, 0])` |\n| `Bruno([0, 0, 1, 0])` | 2000 |\n\n在该样例输入中，共有 $Q \\ (= 2)$ 轮。对于第 1 轮，D-taro 给 Anna 的整数为 $A_1 \\ (= 42)$。\n\n对于第 2 轮，D-taro 给 Anna 的整数为 $A_2 \\ (= 2000)$。\n\n该样例输入满足所有子任务的约束。\n", "locale": "zh-CN", "translations": {"en": {"title": "[JOISC 2022] Broken Device 2", "background": "", "description": " Anna and Bruno are gamble masters. They will play a game with D-taro who is the dealer of the game. In this game, Anna and Bruno stay in different rooms. They can communicate with each other using a broken device only. D-taro gives an integer to Anna. For Anna and Bruno, the purpose of this game is to send the given integer from Anna to Bruno using the device.\n\nWhen the game starts, in the beginning, Anna declares an integer $m$ between 1 and 2 000, inclusive. Then they play $Q$ rounds. The round $i$ ($1 \\le i \\le Q$) is performed as follows.\n\n1. D-taro gives an integer $A_i$ to Anna.\n2. Anna inputs arrays $s_i, t_i$ into the device. Every element of the arrays $s_i, t_i$ should be either 0 or 1. The arrays $s_i, t_i$ should have the same length, and the length is between 1 and $m$, inclusive.\n3. Let $u_i$ be an array obtained from the arrays $s_i$ and $t_i$ by **riffle shuffle** (see below). Then the device sends $u_i$ to Bruno.\n4. Bruno sends an integer to D-taro. If this integer is the same as the integer $A_i$ given by D-taro to Anna, Anna and Bruno win for this round.\n\nWrite programs which implements the strategies of Anna and Bruno so that theory win for all the $Q$ rounds.\n\n### Riffle Shuffle\n\nWe say an array $Z$ is obtained from the arrays $X$ and $Y$ by riffle shuffle if we can divide the elements of the array $Z$ into two groups so that the following two conditions are satisfied.\n\n*   The array consisting of the elements in the first group in the same order is equal to the array $X$.\n*   The array consisting of the elements in the second group in the same order is equal to the array $Y$.\n\nFor example, the array $Z = [1, 1, 1, 0, 0, 0]$ is obtained from $X = [1, 1, 0]$ and $Y = [1, 0, 0]$ by riffle shuffle because the array consisting of the first, second, fourth elements of $Z$ in the same order is the array $[1, 1, 0]$, and the array consisting of the third, fifth, sixth elements of $Z$ in the same order is the array $[1, 0, 0]$.\n\nOn the other hand, if $X = [1, 1, 0]$, $Y = [1, 0, 0]$, and $Z = [0, 0, 0, 1, 1, 1]$, the array $Z$ is not obtained from $X$ and $Y$ by riffle shuffle.\n\n### Implementation Details\n\nYou need to submit two files.\n\nThe first file is `Anna.cpp`. It should implement Anna's strategy. It should implement the following functions. The program should include `Anna.h` using the preprocessing directive `#include`.\n\n*   `int Declare()`\n    This function is called once in the beginning.\n    *   The return value is the integer $m$ declared by Anna.\n    *   The integer $m$ should be between 1 and 2 000, inclusive. If this condition is not satisfied, your program is judged as **Wrong Answer [1]**.\n*   `std::pair<std::vector<int>, std::vector<int>> Anna(long long A)`\n    After the function `Declare` is called, this function is called $Q$ times. The $i$-th call ($1 \\le i \\le Q$) to this function corresponds to Step 1 and Step 2 for the round $i$.\n    *   The parameter $A$ is the integer $A_i$ given by D-taro to Anna.\n    *   The return value is the pair of the two arrays $s_i, t_i$ input by Anna into the device.\n    *   Every element of the arrays $s_i, t_i$ should be either 0 or 1. If this condition is not satisfied, your program is judged as **Wrong Answer [2]**.\n    *   Both of the lengths of the arrays $s_i, t_i$ should be between 1 and $m$, inclusive. If this condition is not satisfied, your program is judged as **Wrong Answer [3]**.\n    *   The arrays $s_i, t_i$ should have the same length. If this condition is not satisfied, your program is judged as **Wrong Answer [4]**.\n\nThe second file is `Bruno.cpp`. It should implement Bruno's strategy. It should implement the following function. The program should include `Bruno.h` using the preprocessing directive `#include`.\n\n*   `long long Bruno(std::vector<int> u)`\n    After Anna inputs the arrays into the device, this function is called once. In total, this function is called $Q$ times. The $i$-th call ($1 \\le i \\le Q$) to this function corresponds to Step 3 and Step 4 for the round $i$.\n    *   The parameter `u` is the array $u_i$ sent by the device to Bruno for the round $i$.\n    *   The return value is the integer sent by Bruno to D-taro.\n    *   The return value should be the same as the integer $A_i$ given by D-taro to Anna. If this condition is not satisfied, your program is judged as **Wrong Answer [5]**.\n\n### Important Notices\n\n*  Your program can implement other functions for internal use, or use global variables. Submitted files will be compiled with the grader, and become a single executable file. All global variables and internal functions should be declared in an unnamed namespace to avoid confliction with other files. When it is graded, it will be executed as two processes of Anna and Bruno. The process of Anna and the process of\nBruno cannot share global variables.\n* Your program must not use the standard input and the standard output. Your program must not communicate with other files by any methods. However, your program may output debugging information to\nthe standard error.\n\n ### Compilation and Test Run\n\nYou can download an archive file from the contest webpage which contains the sample grader to test your program. The archive file also contains a sample source file of your program.\n\nThe sample grader is the file `grader.cpp`. In order to test your program, put `grader.cpp`, `Anna.cpp`, `Bruno.cpp`, `Anna.h`, `Bruno.h` in the same directory, and run the following command to compile your programs.\n\n```\ng++ -std=gnu++17 -O2 -o grader grader.cpp Anna.cpp Bruno.cpp\n```\n\nWhen the compilation succeeds, the executable file `grader` is generated.\n\nNote that the actual grader is different from the sample grader. The sample grader will be executed as a single process, which will read input data from the standard input and write the results to the standard output.\n", "inputFormat": "\nThe sample grader reads the following data from the standard input.\n\n> $Q$ \\\n> $A_1$ \\\n> $A_2$ \\\n> $\\vdots$ \\\n> $A_Q$ \n", "outputFormat": "\nThe sample grader outputs the following information to the standard output (quotes for clarity).\n\n*   If your program is judged as correct, it writes the return value $m$ of the function `Declare` as “Accepted: 2000”.\n*   If your program is judged as any one of Wrong Answer, the sample grader writes its type as “Wrong Answer [1]”.\n\nIf your program satisfies the conditions of several types of Wrong Answer, the sample grader reports only one of them.\n\nWhen the sample grader is executed, the riffle shuffle for each round is calculated using pseudo random numbers. Their results do not change for executions. In order to change the seed of pseudo random numbers, execute the sample grader by the following way.\n\n```\n./grader 2022\n```\n\nThe first argument should be an integer.", "hint": "\n### Constraints\n\n*   $1 \\le Q \\le 1\\,000$.\n*   $1 \\le A_i \\le 1\\,000\\,000\\,000\\,000\\,000\\,000 (= 10^{18}) (1 \\le i \\le Q)$.\n\n### Subtasks\n\n1.  (5 points) $A_i \\le 2\\,000 (1 \\le i \\le Q)$.\n2.  (5 points) $A_i \\le 4\\,000\\,000 (1 \\le i \\le Q)$.\n3.  (3 points) $A_i \\le 10\\,000\\,000 (= 10^7) (1 \\le i \\le Q)$.\n4.  (12 points) $A_i \\le 100\\,000\\,000 (= 10^8) (1 \\le i \\le Q)$.\n5.  (15 points) $A_i \\le 100\\,000\\,000\\,000 (= 10^{11}) (1 \\le i \\le Q)$.\n6.  (60 points) No additional constraints. For this subtask, your score is calculated as follows.\n    *   Let $m^*$ be the maximum of the integers $m$ declared by Anna for all test cases of this subtask.\n    *   Your score is as follows.\n\n| The value of $m^*$ | Score |\n| :--- | :--- |\n| $201 \\le m^* \\le 2\\,000$ | $40 - 25 \\times \\log_{10}(\\frac{m^*}{200})$ points (rounded down to the nearest integer) |\n| $161 \\le m^* \\le 200$ | 40 points |\n| $156 \\le m^* \\le 160$ | 44 points |\n| $151 \\le m^* \\le 155$ | 48 points |\n| $146 \\le m^* \\le 150$ | 52 points |\n| $141 \\le m^* \\le 145$ | 56 points |\n| $m^* \\le 140$ | 60 points |\n\n### Sample Communication\n\nHere is a sample input for the sample grader and corresponding function calls.\n\n#### Sample Input 1\n\n```\n2\n42\n2000\n```\n\n| Call | Return Value |\n| :--- | :--- |\n| `Declare()` | 4 |\n| `Anna(42)` | `([0, 0, 1, 0], [1, 1, 0, 1])` |\n| `Bruno([1, 0, 0, 1, 0, 1, 0, 1])` | 42 |\n| `Anna(2000)` | `([0, 1], [0, 0])` |\n| `Bruno([0, 0, 1, 0])` | 2000 |\n\nIn this sample input, there are $Q (= 2)$ rounds. For the round 1, D-taro gives the integer $A_1 (= 42)$ to Anna.\n\nFor the round 2, D-taro gives the integer $A_2 (= 2000)$ to Anna.\n\nThis sample input satisfies the constraints of all the subtasks.\n\n", "locale": "en"}, "zh-CN": {"title": "[JOIST 2022] 坏掉的设备 2 / Broken Device 2", "background": "不要引入头文件，并使用 **C++ 20** 提交。", "description": "\nAnna 和 Bruno 是赌术大师。他们将和担任庄家的 D-taro 玩一个游戏。在这个游戏中，Anna 和 Bruno 分别待在不同的房间里。他们只能使用一台损坏的装置相互通信。D-taro 会给 Anna 一个整数。对于 Anna 和 Bruno 来说，这个游戏的目标是使用该装置，把给定的整数从 Anna 传递给 Bruno。\n\n当游戏开始时，一开始，Anna 声明一个整数 $m$，其取值在 1 到 2 000（含）之间。然后他们进行 $Q$ 轮。第 $i$ 轮（$1 \\le i \\le Q$）按如下方式进行。\n\n1. D-taro 给 Anna 一个整数 $A_i$。\n2. Anna 向装置输入数组 $s_i, t_i$。数组 $s_i, t_i$ 的每个元素都必须为 0 或 1。数组 $s_i, t_i$ 的长度必须相同，且长度在 1 到 $m$（含）之间。\n3. 令 $u_i$ 为由数组 $s_i$ 和 $t_i$ 通过 **riffle shuffle**（见下文）得到的数组。然后装置将 $u_i$ 发送给 Bruno。\n4. Bruno 向 D-taro 发送一个整数。若该整数与 D-taro 给 Anna 的整数 $A_i$ 相同，则 Anna 和 Bruno 在本轮获胜。\n\n请编写实现 Anna 和 Bruno 策略的程序，使他们在全部 $Q$ 轮中都能获胜。\n\n### 洗牌交错（riffle shuffle）\n\n若能将数组 $Z$ 的元素划分为两组，并满足以下两个条件，则称数组 $Z$ 是由数组 $X$ 和数组 $Y$ 通过 riffle shuffle 得到的。\n\n* 由第一组元素按原有顺序组成的数组等于数组 $X$。\n* 由第二组元素按原有顺序组成的数组等于数组 $Y$。\n\n例如，数组 $Z = [1, 1, 1, 0, 0, 0]$ 可由 $X = [1, 1, 0]$ 与 $Y = [1, 0, 0]$ 通过 riffle shuffle 得到，因为由 $Z$ 的第 1、2、4 个元素按原顺序组成的数组为 $[1, 1, 0]$，而由第 3、5、6 个元素按原顺序组成的数组为 $[1, 0, 0]$。\n\n另一方面，若 $X = [1, 1, 0]$、$Y = [1, 0, 0]$，而 $Z = [0, 0, 0, 1, 1, 1]$，则数组 $Z$ 不是由 $X$ 和 $Y$ 通过 riffle shuffle 得到的。\n\n### 实现细节\n\n你需要提交两个文件。\n\n第一个文件是 `Anna.cpp`。它应实现 Anna 的策略，并实现下列函数。程序应通过预处理指令 `#include` 包含 `Anna.h`。\n\n* `int Declare()`\n\n  该函数在开始时被调用一次。\n  * 返回值是 Anna 声明的整数 $m$。\n  * 整数 $m$ 必须在 1 到 2 000（含）之间。若不满足此条件，你的程序将被判为 **Wrong Answer [1]**。\n\n* `std::pair<std::vector<int>, std::vector<int>> Anna(long long A)`\n\n  在调用 `Declare` 之后，该函数将被调用 $Q$ 次。第 $i$ 次调用（$1 \\le i \\le Q$）对应第 $i$ 轮的步骤 1 和步骤 2。\n  * 参数 $A$ 是 D-taro 给 Anna 的整数 $A_i$。\n  * 返回值是 Anna 输入到装置中的两个数组 $s_i, t_i$ 组成的二元组。\n  * 数组 $s_i, t_i$ 的每个元素都必须为 0 或 1。若不满足此条件，你的程序将被判为 **Wrong Answer [2]**。\n  * 数组 $s_i, t_i$ 的长度都必须在 1 到 $m$（含）之间。若不满足此条件，你的程序将被判为 **Wrong Answer [3]**。\n  * 数组 $s_i, t_i$ 的长度必须相同。若不满足此条件，你的程序将被判为 **Wrong Answer [4]**。\n\n第二个文件是 `Bruno.cpp`。它应实现 Bruno 的策略，并实现下列函数。程序应通过预处理指令 `#include` 包含 `Bruno.h`。\n\n* `long long Bruno(std::vector<int> u)`\n\n  在 Anna 向装置输入数组之后，该函数会被调用一次。总共，该函数会被调用 $Q$ 次。第 $i$ 次调用（$1 \\le i \\le Q$）对应第 $i$ 轮的步骤 3 和步骤 4。\n  * 参数 `u` 是装置在第 $i$ 轮发送给 Bruno 的数组 $u_i$。\n  * 返回值是 Bruno 发送给 D-taro 的整数。\n  * 返回值必须与 D-taro 给 Anna 的整数 $A_i$ 相同。若不满足此条件，你的程序将被判为 **Wrong Answer [5]**。\n\n### 重要注意事项\n\n* 你的程序可以实现其他用于内部的函数，或使用全局变量。提交的文件将与评测器一起编译，变成一个可执行文件。所有全局变量和内部函数都应当声明在未命名命名空间中，以避免与其他文件冲突。评测时会以 Anna 进程和 Bruno 进程两个进程形式运行。Anna 进程与 Bruno 进程不能共享全局变量。\n* 你的程序不得使用标准输入与标准输出。你的程序不得通过任何方式与其他文件通信。但是，你的程序可以向标准错误输出调试信息。\n\n### 编译与本地测试\n\n你可以从竞赛网页下载一个压缩包，其中包含用于本地测试你程序的样例评测器。压缩包还包含你程序的样例源代码。\n\n样例评测器为文件 `grader.cpp`。为了测试你的程序，请将 `grader.cpp`、`Anna.cpp`、`Bruno.cpp`、`Anna.h`、`Bruno.h` 放在同一目录下，并运行如下命令以编译程序。\n\n```\ng++ -std=gnu++17 -O2 -o grader grader.cpp Anna.cpp Bruno.cpp\n```\n\n编译成功后，会生成名为 `grader` 的可执行文件。\n\n请注意，实际评测器与样例评测器不同。样例评测器以单进程形式运行，从标准输入读入数据，并将结果写到标准输出。\n", "inputFormat": "\n样例评测器从标准输入读取如下数据。\n\n> $Q$ \\\n> $A_1$ \\\n> $A_2$ \\\n> $\\vdots$ \\\n> $A_Q$\n", "outputFormat": "\n样例评测器向标准输出写出如下信息（引号仅为说明）。\n\n* 若你的程序被判定为正确，它会输出函数 `Declare` 的返回值 $m$，例如 “Accepted: 2000”。\n* 若你的程序被判定为任一类 Wrong Answer，样例评测器会写出其类型，例如 “Wrong Answer [1]”。\n\n如果你的程序同时触犯多类 Wrong Answer 的条件，样例评测器只报告其中一种。\n\n样例评测器在每一轮计算 riffle shuffle 时使用伪随机数。其结果在不同执行中不会改变。为了更改伪随机数的种子，请如下方式执行样例评测器。\n\n```\n./grader 2022\n```\n\n第一个参数应为一个整数。\n", "hint": "\n#### 约束\n\n* $1 \\le Q \\le 1\\,000$。\n* $1 \\le A_i \\le 1\\,000\\,000\\,000\\,000\\,000\\,000 \\ (= 10^{18}) \\ (1 \\le i \\le Q)$。\n\n#### 子任务\n\n1. （5 分）$A_i \\le 2\\,000 \\ (1 \\le i \\le Q)$。\n2. （5 分）$A_i \\le 4\\,000\\,000 \\ (1 \\le i \\le Q)$。\n3. （3 分）$A_i \\le 10\\,000\\,000 \\ (= 10^7) \\ (1 \\le i \\le Q)$。\n4. （12 分）$A_i \\le 100\\,000\\,000 \\ (= 10^8) \\ (1 \\le i \\le Q)$。\n5. （15 分）$A_i \\le 100\\,000\\,000\\,000 \\ (= 10^{11}) \\ (1 \\le i \\le Q)$。\n6. （60 分）无限制。对于本子任务，你的得分计算如下。\n   * 令 $m^*$ 为本子任务所有测试中，Anna 声明的整数 $m$ 的最大值。\n   * 你的得分如下所示。\n\n| $m^*$ 的取值 | 分数 |\n| :--- | :--- |\n| $201 \\le m^* \\le 2\\,000$ | $40 - 25 \\times \\log_{10}\\!\\left(\\dfrac{m^*}{200}\\right)$ 分（向下取整为整数） |\n| $161 \\le m^* \\le 200$ | 40 分 |\n| $156 \\le m^* \\le 160$ | 44 分 |\n| $151 \\le m^* \\le 155$ | 48 分 |\n| $146 \\le m^* \\le 150$ | 52 分 |\n| $141 \\le m^* \\le 145$ | 56 分 |\n| $m^* \\le 140$ | 60 分 |\n\n### 样例通信\n\n下面给出样例评测器的一个样例输入以及相应的函数调用。\n\n#### 样例输入 1\n\n```\n2\n42\n2000\n```\n\n| 调用 | 返回值 |\n| :--- | :--- |\n| `Declare()` | 4 |\n| `Anna(42)` | `([0, 0, 1, 0], [1, 1, 0, 1])` |\n| `Bruno([1, 0, 0, 1, 0, 1, 0, 1])` | 42 |\n| `Anna(2000)` | `([0, 1], [0, 0])` |\n| `Bruno([0, 0, 1, 0])` | 2000 |\n\n在该样例输入中，共有 $Q \\ (= 2)$ 轮。对于第 1 轮，D-taro 给 Anna 的整数为 $A_1 \\ (= 42)$。\n\n对于第 2 轮，D-taro 给 Anna 的整数为 $A_2 \\ (= 2000)$。\n\n该样例输入满足所有子任务的约束。\n", "locale": "zh-CN"}}}
{"pid": "P9527", "type": "P", "difficulty": 5, "samples": [["4 7\n1 2\n2 3\n3 4\n1\n1\n1\n1\n11\n1 2 1 2\n1 1 0 2\n2 1\n2 2\n2 3\n2 4\n1 4 10 2\n2 1\n2 2\n2 3\n2 4", "4\n2\n2\n1\n1\n4\n4\n2"], ["6 10\n5 6\n1 2\n1 4\n2 6\n3 6\n9\n2\n3\n4\n9\n1\n10\n1 5 1 7\n2 4\n1 4 1 9\n1 5 0 7\n2 1\n1 1 1 3\n1 6 1 4\n2 5\n2 4\n2 3", "4\n1\n4\n8\n2"], ["8 10\n1 3\n3 5\n4 7\n6 7\n4 5\n7 8\n2 4\n5\n8\n6\n4\n6\n2\n9\n3\n11\n1 2 2 0\n2 1\n1 6 1 0\n2 4\n2 6\n1 5 2 0\n2 8\n1 7 2 0\n2 6\n2 7\n2 4", "5\n0\n0\n3\n0\n0\n0"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "O2优化", "JOISC/JOIST（日本）"], "title": "[JOIST 2022] 洒水器 / Sprinkler", "background": "JOISC2022 D3T2", "description": "JOI 君有多年在自家菜园种植蔬菜的经验，现在他计划管理 IOI 农场。\n\nIOI 农场由 $N$ 块土地组成。土地间有 $N-1$ 条双向道路相连，编号从 $1$ 到 $N-1$，第 $i$ 条道路连接土地 $A_i$ 和 $B_i$，任意两块土地间都可以通过道路互达。农场的每块土地上都有一个洒水器，使用洒水器可以向附近的土地洒水。\n\nJOI 君计划在 IOI 农场种植 JOI 谷。JOI 谷是一种奇特的作物，它在被浇水时高度会立刻发生变化。但是同时，JOI 谷是一种脆弱的植物，若它的高度大于等于 $L$，JOI 谷顶部长为 $L$ 的部分会立刻断裂并掉落。JOI 君会收获掉落的部分。\n\n初始时，JOI 君在土地 $j$ 上种了一株高度为 $H_j$ 的 JOI 谷，之后的 $Q$ 天，JOI 君都会照料这些 JOI 谷，在第 $k$ 天，JOI 君会做如下两个操作之一：\n\n- 操作 $1$：JOI 君使用土地 $X_k$ 上的洒水器，向与土地 $X_k$ 距离不超过 $D_k$ 的土地上浇水，使这些土地上的 JOI 谷高度乘以 $W_k$。由于 JOI 谷会不断断裂，因此若对一株原高度为 $h$ 的 JOI 谷洒水，它的高度会变为 $hW_k\\bmod L$。\n- 操作 $2$：JOI 君测量土地 $X_k$ 上 JOI 谷的高度。\n\n土地 $x$ 和土地 $y$ 间距离的定义为：从土地 $x$ 前往土地 $y$ 经过道路数的最小值。\n\nJOI 君希望 JOI 谷按照计划长大，因此，他希望提前算出每次操作 $2$ 应当测量出 JOI 谷的高度。", "inputFormat": "第一行两个整数 $N,L$，表示土地块数和 JOI 谷的断裂阈值。\n\n接下来 $N-1$ 行，每行两个整数 $A_i,B_i$ 表示一条道路。\n\n接下来 $N$ 行，每行一个整数 $H_i$ 表示 JOI 谷的初始高度。\n\n接下来一行一个整数 $Q$ 表示操作次数。\n\n接下来 $Q$ 行，第 $k$ 行以 $T_k$ 开头，表示这次操作类型，接下来：\n\n- 若 $T_k=1$，这是一次操作 $1$，接下来三个整数 $X_k,D_k,W_k$ 分别表示洒水器编号，洒水半径和生长参数。\n- 若 $T_k=2$，这是一次操作 $2$，接下来一个整数 $X_k$ 表示需要测量的 JOI 谷的编号。", "outputFormat": "对于每一次操作 $2$，输出一个整数表示 JOI 谷的预期高度。", "hint": "**【样例解释 #1】**\n\n初始时，JOI 君在所有土地上种植了高度为 $1$ 的 JOI 谷。\n\n第一天，JOI 君使用土地 $2$ 的洒水器，土地 $1,2,3$ 的 JOI 谷被影响，高度乘以 $2$，四株 JOI 谷的高度变为 $2,2,2,1$。\n\n第二天，JOI 君使用土地 $1$ 的洒水器，土地 $1$ 的 JOI 谷被影响，高度乘以 $2$，四株 JOI 谷的高度变为 $4,2,2,1$。\n\n第七天，JOI 君使用土地 $4$ 的洒水器，土地 $1,2,3,4$ 的 JOI 谷被影响，高度乘以 $2$，第一株 JOI 谷的高度变为 $8$，发生断裂，因此四株 JOI 谷的高度变为 $1,4,4,2$。\n\n这组样例满足子任务 $1,5,6$ 的限制。\n\n**【样例解释 #2】**\n\n第一天，JOI 君使用土地 $5$ 的洒水器，土地 $5,6$ 上的 JOI 谷高度乘以 $7$，高度分别变为 $63,7$，因此，土地 $5$ 上的 JOI 谷会不断断裂，高度变为 $3$。\n\n这组样例满足子任务 $1,2,3,6$ 的限制。\n\n**【样例解释 #3】**\n\n这组样例满足子任务 $1,3,4,6$ 的限制。\n\n**【数据范围】**\n\n对于所有数据，满足：\n\n- $2\\leq N\\leq 200000$。\n- $2\\leq L\\leq 10^9$。\n- $1\\leq A_i\\lt B_i\\leq N$ $(i\\in[1,N-1])$。\n- 任意土地之间都可以通过若干条道路到达。\n- $0\\leq H_j\\lt L$ $(1\\leq j\\leq N)$。\n- $1\\leq Q\\leq 400000$。\n- $T_k$ 均为 $1$ 或 $2$。\n- 对于满足 $T_k=1$ $(k\\in[1, Q])$ 的 $k$，保证 $1\\leq X_k\\leq N, 0\\leq D_k\\leq 40, 0\\leq W_k\\lt L$。\n- 对于满足 $T_k=2$ $(k\\in[1, Q])$ 的 $k$，保证 $1\\leq X_k\\leq N$。\n\n详细子任务附加限制及分值如下表所示：\n\n|子任务编号|附加限制|分值|\n|:-:|:-:|:-:|\n|$1$|$N,Q\\le 1000$|$3$|\n|$2$|对于满足 $T_k=1$ 的 $k$，保证 $D_k\\leq 1$|$9$|\n|$3$|对于满足 $T_k=1$ 的 $k$，保证 $D_k\\leq 2$|$29$|\n|$4$|对于满足 $T_k=1$ 的 $k$，保证 $W_k=0$|$12$|\n|$5$|对于满足 $T_k=1$ 的 $k$，保证 $W_k=2$|$30$|\n|$6$|无附加限制|$17$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIST 2022] 洒水器 / Sprinkler", "background": "JOISC2022 D3T2", "description": "JOI 君有多年在自家菜园种植蔬菜的经验，现在他计划管理 IOI 农场。\n\nIOI 农场由 $N$ 块土地组成。土地间有 $N-1$ 条双向道路相连，编号从 $1$ 到 $N-1$，第 $i$ 条道路连接土地 $A_i$ 和 $B_i$，任意两块土地间都可以通过道路互达。农场的每块土地上都有一个洒水器，使用洒水器可以向附近的土地洒水。\n\nJOI 君计划在 IOI 农场种植 JOI 谷。JOI 谷是一种奇特的作物，它在被浇水时高度会立刻发生变化。但是同时，JOI 谷是一种脆弱的植物，若它的高度大于等于 $L$，JOI 谷顶部长为 $L$ 的部分会立刻断裂并掉落。JOI 君会收获掉落的部分。\n\n初始时，JOI 君在土地 $j$ 上种了一株高度为 $H_j$ 的 JOI 谷，之后的 $Q$ 天，JOI 君都会照料这些 JOI 谷，在第 $k$ 天，JOI 君会做如下两个操作之一：\n\n- 操作 $1$：JOI 君使用土地 $X_k$ 上的洒水器，向与土地 $X_k$ 距离不超过 $D_k$ 的土地上浇水，使这些土地上的 JOI 谷高度乘以 $W_k$。由于 JOI 谷会不断断裂，因此若对一株原高度为 $h$ 的 JOI 谷洒水，它的高度会变为 $hW_k\\bmod L$。\n- 操作 $2$：JOI 君测量土地 $X_k$ 上 JOI 谷的高度。\n\n土地 $x$ 和土地 $y$ 间距离的定义为：从土地 $x$ 前往土地 $y$ 经过道路数的最小值。\n\nJOI 君希望 JOI 谷按照计划长大，因此，他希望提前算出每次操作 $2$ 应当测量出 JOI 谷的高度。", "inputFormat": "第一行两个整数 $N,L$，表示土地块数和 JOI 谷的断裂阈值。\n\n接下来 $N-1$ 行，每行两个整数 $A_i,B_i$ 表示一条道路。\n\n接下来 $N$ 行，每行一个整数 $H_i$ 表示 JOI 谷的初始高度。\n\n接下来一行一个整数 $Q$ 表示操作次数。\n\n接下来 $Q$ 行，第 $k$ 行以 $T_k$ 开头，表示这次操作类型，接下来：\n\n- 若 $T_k=1$，这是一次操作 $1$，接下来三个整数 $X_k,D_k,W_k$ 分别表示洒水器编号，洒水半径和生长参数。\n- 若 $T_k=2$，这是一次操作 $2$，接下来一个整数 $X_k$ 表示需要测量的 JOI 谷的编号。", "outputFormat": "对于每一次操作 $2$，输出一个整数表示 JOI 谷的预期高度。", "hint": "**【样例解释 #1】**\n\n初始时，JOI 君在所有土地上种植了高度为 $1$ 的 JOI 谷。\n\n第一天，JOI 君使用土地 $2$ 的洒水器，土地 $1,2,3$ 的 JOI 谷被影响，高度乘以 $2$，四株 JOI 谷的高度变为 $2,2,2,1$。\n\n第二天，JOI 君使用土地 $1$ 的洒水器，土地 $1$ 的 JOI 谷被影响，高度乘以 $2$，四株 JOI 谷的高度变为 $4,2,2,1$。\n\n第七天，JOI 君使用土地 $4$ 的洒水器，土地 $1,2,3,4$ 的 JOI 谷被影响，高度乘以 $2$，第一株 JOI 谷的高度变为 $8$，发生断裂，因此四株 JOI 谷的高度变为 $1,4,4,2$。\n\n这组样例满足子任务 $1,5,6$ 的限制。\n\n**【样例解释 #2】**\n\n第一天，JOI 君使用土地 $5$ 的洒水器，土地 $5,6$ 上的 JOI 谷高度乘以 $7$，高度分别变为 $63,7$，因此，土地 $5$ 上的 JOI 谷会不断断裂，高度变为 $3$。\n\n这组样例满足子任务 $1,2,3,6$ 的限制。\n\n**【样例解释 #3】**\n\n这组样例满足子任务 $1,3,4,6$ 的限制。\n\n**【数据范围】**\n\n对于所有数据，满足：\n\n- $2\\leq N\\leq 200000$。\n- $2\\leq L\\leq 10^9$。\n- $1\\leq A_i\\lt B_i\\leq N$ $(i\\in[1,N-1])$。\n- 任意土地之间都可以通过若干条道路到达。\n- $0\\leq H_j\\lt L$ $(1\\leq j\\leq N)$。\n- $1\\leq Q\\leq 400000$。\n- $T_k$ 均为 $1$ 或 $2$。\n- 对于满足 $T_k=1$ $(k\\in[1, Q])$ 的 $k$，保证 $1\\leq X_k\\leq N, 0\\leq D_k\\leq 40, 0\\leq W_k\\lt L$。\n- 对于满足 $T_k=2$ $(k\\in[1, Q])$ 的 $k$，保证 $1\\leq X_k\\leq N$。\n\n详细子任务附加限制及分值如下表所示：\n\n|子任务编号|附加限制|分值|\n|:-:|:-:|:-:|\n|$1$|$N,Q\\le 1000$|$3$|\n|$2$|对于满足 $T_k=1$ 的 $k$，保证 $D_k\\leq 1$|$9$|\n|$3$|对于满足 $T_k=1$ 的 $k$，保证 $D_k\\leq 2$|$29$|\n|$4$|对于满足 $T_k=1$ 的 $k$，保证 $W_k=0$|$12$|\n|$5$|对于满足 $T_k=1$ 的 $k$，保证 $W_k=2$|$30$|\n|$6$|无附加限制|$17$|", "locale": "zh-CN"}}}
{"pid": "P9528", "type": "P", "difficulty": 7, "samples": [["4 1\n1 1 1\n2 2 1\n1 3 1\n2 0 1", "0\n1\n1\n2"], ["20 1\n2 16 778913911\n1 7 558407445\n1 1 589762439\n1 17 74646747\n1 1 149104909\n1 15 956697952\n2 6 389372991\n2 4 867453845\n1 15 157353445\n1 9 846177695\n1 7 747107163\n2 10 525670462\n2 16 478912944\n2 6 301733761\n2 12 132966485\n1 1 748012313\n2 10 830922632\n1 19 969484637\n1 13 370330582\n1 1 464798040", "0\n0\n0\n74646747\n74646747\n778913911\n1168286902\n1168286902\n1168286902\n1168286902\n1168286902\n1693957364\n2103741597\n2405475358\n2405475358\n2405475358\n2725982591\n2725982591\n2858949076\n2858949076"], ["20 6\n2 27 12\n2 9 11\n1 36 10\n2 39 4\n2 14 9\n2 33 7\n2 38 20\n2 0 20\n2 25 16\n1 14 3\n1 13 19\n2 6 4\n2 15 6\n2 33 4\n1 12 11\n1 44 1\n2 17 14\n2 12 19\n1 48 18\n2 30 16", "0\n0\n0\n4\n4\n10\n10\n10\n10\n13\n30\n30\n32\n32\n40\n41\n44\n44\n44\n44"], ["20 268886972\n1 984472666 733463744\n1 478477245 94817772\n1 242536956 330762563\n1 65794782 319137646\n1 320548477 937296140\n1 815011370 938193848\n1 565184190 917533785\n1 245417414 534089975\n1 529908772 977043962\n1 603891865 700935654\n2 167042244 479827216\n2 173921297 798343455\n2 916159596 810126726\n2 999299355 465535307\n2 965968070 501768990\n2 936073643 174976034\n2 832859952 778072072\n2 955489596 704853861\n2 246733786 382428992\n2 227669861 390905006", "0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n479827216\n1278170671\n2088297397\n2553832704\n2949828263\n2949828263\n3727900335\n3727900335\n4110329327\n4501234333"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "O2优化", "JOISC/JOIST（日本）"], "title": "[JOIST 2022] 蚂蚁与方糖 / Ants and Sugar", "background": "JOISC2022 D3T3", "description": "JOI 君是一个生物学家。他准备对蚂蚁和方糖做一些实验。\n\nJOI 君的实验在一个长度为 $10^9$ 的木条上进行。这根木条被从左往右放置。木条上距离左端点 $x$ 的点被称作坐标为 $x$ 的点。\n\n现在，木条上什么都没有。JOI 君将会进行 $Q$ 次操作。第 $i$ 个操作 $(1 \\le i \\le Q)$ 由三个整数 $T_i,X_i,A_i$ 描述，表示：\n\n- 若 $T_i=1$，JOI 君在坐标为 $X_i$ 的点处放了 $A_i$ 个蚂蚁。\n- 若 $T_i=2$，JOI 君在坐标为 $X_i$ 的点处放了 $A_i$ 块方糖。\n\n由于蚂蚁和方糖都很小，所以可能会有一些蚂蚁和方糖放在同一个点上。JOI 君也可能在同一个点执行多次操作。\n\n这次实验中使用的蚂蚁具有「好奇心强」的萌点。具体地，当 JOI 君拍手时，每个蚂蚁会执行以下操作：\n\n- 如果存在一块方糖与该蚂蚁距离不超过 $L$，它会选择任意一块并吃掉。\n\n可能存在多个蚂蚁同时吃掉一块方糖的情况。\n\n对于每个 $k$ $(1\\le k \\le Q)$，JOI 君想要知道以下问题的答案。\n\n- 假设 JOI 君在第 $k$ 次操作后拍了一次手，最多有多少块方糖被至少一个蚂蚁吃掉了？\n\n请写一个程序，对于给定的 JOI 君执行的操作和 $L$ 的值，对于所有 $k$ 回答 JOI 君的每个问题。\n\n注意 JOI 君并不会真的拍手。因此蚂蚁的位置不会改变，方糖也不会被吃掉。", "inputFormat": "第一行，两个正整数 $Q,L$，表示操作个数和蚂蚁可能吃到的方糖的范围。\n\n接下来 $Q$ 行，其中第 $i$ $(1 \\le i \\le Q)$ 包含三个整数 $T_i,X_i,A_i$，表示一次操作。", "outputFormat": "输出 $Q$ 行，第 $k$ $(1 \\le k \\le Q)$ 行包含一个整数，表示若 JOI 君在第 $k$ 次操作后拍了一次手，被至少一个蚂蚁吃掉的方糖的个数可能的最大值。", "hint": "**【样例解释 #1】**\n\n在这组样例中，所有操作和每个 $k$ 的答案如下：\n\n 1. JOI 君在坐标为 $1$ 的点放了一个蚂蚁。  \n    由于没有方糖，对应的答案为 $0$。\n 2. JOI 君在坐标为 $2$ 的点放了一块方糖。  \n    假设 JOI 君此时拍手，则坐标为 $1$ 的蚂蚁会吃掉坐标为 $2$ 的方糖，所以对应的答案为 $1$。\n 3. JOI 君在坐标为 $3$ 的点放了一个蚂蚁。  \n    假设 JOI 君此时拍手，则坐标为 $1,3$ 的蚂蚁会同时吃掉坐标为 $2$ 的方糖，所以对应的答案为 $1$。\n 4. JOI 君在坐标为 $0$ 的点放了一块方糖。  \n    假设 JOI 君此时拍手，则坐标为 $1,3$ 的蚂蚁可以分别吃掉坐标为 $0,2$ 的方糖，所以对应的答案为 $2$。\n\n这组样例满足子任务 $1,2,4$ 的限制。\n\n**【样例解释 #2】**\n\n这组样例满足子任务 $1,2,4$ 的限制。\n\n**【样例解释 #3】**\n\n这组样例满足子任务 $1,4$ 的限制。\n\n**【样例解释 #4】**\n\n这组样例满足子任务 $1,3,4$ 的限制。\n\n**【数据范围】**\n\n对于所有数据，满足：\n\n- $1 \\le Q \\le 500\\,000$。\n- $1 \\le L \\le 10^9$。\n- $T_i \\in \\{1,2\\}$。\n- $0 \\le X_i \\le 10^9$ $(1 \\le i \\le Q)$。\n- $1 \\le A_i \\le 10^9$ $(1 \\le i \\le Q)$。\n\n详细子任务附加限制及分值如下表所示：\n\n|子任务编号|附加限制|分值|\n|:-:|:-:|:-:|\n|$1$|$Q \\le 3\\,000$|$6$|\n|$2$|$L=1$，$X_i \\le Q-1$，$X_i+T_i$ 是偶数 $(1\\le i\\le Q)$|$16$|\n|$3$|$Q$ 是偶数，$T_i = 1$ $(1 \\le i \\le Q/2)$，$T_i = 2$ $(Q/2+1 \\le i \\le Q)$|$26$|\n|$4$|无附加限制|$52$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIST 2022] 蚂蚁与方糖 / Ants and Sugar", "background": "JOISC2022 D3T3", "description": "JOI 君是一个生物学家。他准备对蚂蚁和方糖做一些实验。\n\nJOI 君的实验在一个长度为 $10^9$ 的木条上进行。这根木条被从左往右放置。木条上距离左端点 $x$ 的点被称作坐标为 $x$ 的点。\n\n现在，木条上什么都没有。JOI 君将会进行 $Q$ 次操作。第 $i$ 个操作 $(1 \\le i \\le Q)$ 由三个整数 $T_i,X_i,A_i$ 描述，表示：\n\n- 若 $T_i=1$，JOI 君在坐标为 $X_i$ 的点处放了 $A_i$ 个蚂蚁。\n- 若 $T_i=2$，JOI 君在坐标为 $X_i$ 的点处放了 $A_i$ 块方糖。\n\n由于蚂蚁和方糖都很小，所以可能会有一些蚂蚁和方糖放在同一个点上。JOI 君也可能在同一个点执行多次操作。\n\n这次实验中使用的蚂蚁具有「好奇心强」的萌点。具体地，当 JOI 君拍手时，每个蚂蚁会执行以下操作：\n\n- 如果存在一块方糖与该蚂蚁距离不超过 $L$，它会选择任意一块并吃掉。\n\n可能存在多个蚂蚁同时吃掉一块方糖的情况。\n\n对于每个 $k$ $(1\\le k \\le Q)$，JOI 君想要知道以下问题的答案。\n\n- 假设 JOI 君在第 $k$ 次操作后拍了一次手，最多有多少块方糖被至少一个蚂蚁吃掉了？\n\n请写一个程序，对于给定的 JOI 君执行的操作和 $L$ 的值，对于所有 $k$ 回答 JOI 君的每个问题。\n\n注意 JOI 君并不会真的拍手。因此蚂蚁的位置不会改变，方糖也不会被吃掉。", "inputFormat": "第一行，两个正整数 $Q,L$，表示操作个数和蚂蚁可能吃到的方糖的范围。\n\n接下来 $Q$ 行，其中第 $i$ $(1 \\le i \\le Q)$ 包含三个整数 $T_i,X_i,A_i$，表示一次操作。", "outputFormat": "输出 $Q$ 行，第 $k$ $(1 \\le k \\le Q)$ 行包含一个整数，表示若 JOI 君在第 $k$ 次操作后拍了一次手，被至少一个蚂蚁吃掉的方糖的个数可能的最大值。", "hint": "**【样例解释 #1】**\n\n在这组样例中，所有操作和每个 $k$ 的答案如下：\n\n 1. JOI 君在坐标为 $1$ 的点放了一个蚂蚁。  \n    由于没有方糖，对应的答案为 $0$。\n 2. JOI 君在坐标为 $2$ 的点放了一块方糖。  \n    假设 JOI 君此时拍手，则坐标为 $1$ 的蚂蚁会吃掉坐标为 $2$ 的方糖，所以对应的答案为 $1$。\n 3. JOI 君在坐标为 $3$ 的点放了一个蚂蚁。  \n    假设 JOI 君此时拍手，则坐标为 $1,3$ 的蚂蚁会同时吃掉坐标为 $2$ 的方糖，所以对应的答案为 $1$。\n 4. JOI 君在坐标为 $0$ 的点放了一块方糖。  \n    假设 JOI 君此时拍手，则坐标为 $1,3$ 的蚂蚁可以分别吃掉坐标为 $0,2$ 的方糖，所以对应的答案为 $2$。\n\n这组样例满足子任务 $1,2,4$ 的限制。\n\n**【样例解释 #2】**\n\n这组样例满足子任务 $1,2,4$ 的限制。\n\n**【样例解释 #3】**\n\n这组样例满足子任务 $1,4$ 的限制。\n\n**【样例解释 #4】**\n\n这组样例满足子任务 $1,3,4$ 的限制。\n\n**【数据范围】**\n\n对于所有数据，满足：\n\n- $1 \\le Q \\le 500\\,000$。\n- $1 \\le L \\le 10^9$。\n- $T_i \\in \\{1,2\\}$。\n- $0 \\le X_i \\le 10^9$ $(1 \\le i \\le Q)$。\n- $1 \\le A_i \\le 10^9$ $(1 \\le i \\le Q)$。\n\n详细子任务附加限制及分值如下表所示：\n\n|子任务编号|附加限制|分值|\n|:-:|:-:|:-:|\n|$1$|$Q \\le 3\\,000$|$6$|\n|$2$|$L=1$，$X_i \\le Q-1$，$X_i+T_i$ 是偶数 $(1\\le i\\le Q)$|$16$|\n|$3$|$Q$ 是偶数，$T_i = 1$ $(1 \\le i \\le Q/2)$，$T_i = 2$ $(Q/2+1 \\le i \\le Q)$|$26$|\n|$4$|无附加限制|$52$|", "locale": "zh-CN"}}}
{"pid": "P9529", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "交互题", "Special Judge", "O2优化", "JOISC/JOIST（日本）"], "title": "[JOIST 2022] 一流团子师傅 / Super Dango Maker", "background": "JOISC2022 D4T1\n\n**特别提醒，由于洛谷交互机制的特殊性，你不能在程序中引用 `dango3.h`，而需要把 `dango3.h` 中的内容加入文件的开头。即，在程序中 `void Solve(int N, int M)` 的前面加入以下几行语句：**\n\n```cpp\n#include <vector>\n\nvoid Solve(int N, int M);\n\nint Query(const std::vector<int> &x);\nvoid Answer(const std::vector<int> &a);\n```", "description": "JOI 君是一位专业的团子师傅。在 JOI 君的店里，团子的颜色很有讲究。一共有 $N$ 种颜色，编号为 $1,2,\\dots,N$。\n\n**一流团子串**是 JOI 君的店里的招牌食品。制作一个一流团子串，需要将 $N$ 个**颜色不同**的团子串在一根竹签上。\n\n对于每一种颜色，JOI 君都制作了 $M$ 个这种颜色的团子。因此，JOI 君总共有了 $NM$ 个团子。这些团子被编号为 $1,2,\\dots,NM$。使用这些团子和 $M$ 根竹签，JOI 君希望串出 $M$ 个一流团子串。\n\n为了避免在颜色上犯错误，JOI 君将会启用他的团子检测器。如果 JOI 君输入一些团子的编号，团子检测器会返回使用这些团子能制作的一流团子串的个数的最大值。当然，前提是充分使用竹签。\n\nJOI 君希望能通过使用若干次团子检测器将 $NM$ 个团子分为 $M$ 组。其中，每一组包含 $N$ 个团子，且每种颜色的团子恰有一个。\n\nJOI 君想在使用不超过 $50\\,000$ 次团子检测器的前提下完成这件事。\n\n请写一个程序，对于给定的团子的信息，实现 JOI 君使用不超过 $50\\,000$ 次团子检测器来完成任务的策略。\n\n---\n\n**【实现细节】**\n\n你的程序需要实现以下函数。\n\n  - `void Solve(int N, int M)`。  \n    对于每组测试数据，该函数会被调用恰好一次。\n      - 参数 $\\texttt N$ 是团子的颜色数 $N$。\n      - 参数 $\\texttt M$ 是 JOI 君想制作的一流团子串的个数 $M$。\n\n你的程序可以调用以下函数。\n\n  - `int Query(const std::vector<int> &x)`。  \n    你的程序可以通过调用这个函数来使用团子检测器。\n      - 参数 `x` 是输入给团子检测器的团子的编号列表。\n      - 该函数返回使用 `x` 中的团子能制作的一流团子串的最大值。\n      - `x` 中的每个元素都应当是 $[1,NM]$ 中的整数。否则你的程序会被判定为 **Wrong Answer [1]**。\n      - `x` 中的元素应当互不相同。否则你的程序会被判定为 **Wrong Answer [2]**。\n      - 你的程序不得调用该函数超过 $50\\,000$ 次。否则你的程序会被判定为 **Wrong Answer [3]**。\n\n  - `void Answer(const std::vector<int> &a)`。  \n    你的程序可以通过调用这个程序来报告分组方案。\n      - 参数 `a` 是你分出的一组团子的编号列表。\n      - `a` 的长度应当为 $N$。否则你的程序会被判定为 **Wrong Answer [4]**。\n      - `a` 中的每个元素都应当是 $[1,NM]$ 中的整数。否则你的程序会被判定为 **Wrong Answer [5]**。\n      - 在整个过程中，同一个团子不能出现在参数中多于一次。否则你的程序会被判定为 **Wrong Answer [6]**。\n      - 如果用 `a` 中的团子并不能制作一个一流团子串，你的程序会被判定为 **Wrong Answer [7]**。\n      - 该函数应当被调用恰好 $M$ 次。否则你的程序会被判定为 **Wrong Answer [8]**。\n  \n**【提示】**\n  \n  - 你的程序可以实现其他函数以供内部使用，或者使用全局变量。\n  - 你的程序不得使用标准输入输出流，也不得以任何方式访问任何文件。然而，你可以输出调试信息到标准错误流。\n  \n**【编译与测试运行】**\n  \n你可以从「附加文件」中下载样例评分器来测试你的程序。「附加文件」中也提供了你应当提交的程序的一个样例。\n\n样例评分器即 `grader.cpp`。为了测试你的程序，请将 `grader.cpp,dango3.cpp` 放置在同一个目录下，并执行如下命令来编译你的程序。\n\n`g++ -std=gnu++17 -O2 -o grader grader.cpp dango3.cpp`\n\n若编译成功，将会生成一个可执行文件 `grader`。\n\n请注意，实际使用的评分器与下发的样例评分器不同。样例评分器仅会有单个进程，从标准输入中读取输入数据并将结果输出到标准输出。\n  \n**【样例评分器输入格式】**\n  \n第一行，两个正整数 $N,M$。表示团子的颜色数和 JOI 君想制作的一流团子串的个数。\n\n第二行，$N\\times M$ 个正整数 $C_1,C_2,\\dots,C_{NM}$。其中 $C_i$ 是一个 $[1,N]$ 内的正整数，表示第 $i$ 个团子的颜色。\n  \n**【样例评分器输出格式】**\n  \n- 如果你的程序被判定为正确，样例评分器会输出调用 `Query` 的次数，如 “$\\texttt{Accepted: 2022}$”。\n- 如果你的程序被判定为任意一种 Wrong Answer，样例评分器会输出其类型，如 “$\\texttt{Wrong Answer [4]}$”。\n\n如果你的程序属于多种 Wrong Answer，样例评分器只会输出其中一种。", "inputFormat": "", "outputFormat": "", "hint": "**【样例交互】**\n\n这里是样例评分器的一组样例输入和对应的交互过程。\n\n```plain\n3 2\n3 3 1 2 1 2\n```\n\n|调用|调用|返回值|\n|:-|:-|:-|\n|$\\texttt{Solve(3, 2)}$|||\n||$\\texttt{Query([])}$|$\\texttt 0$|\n||$\\texttt{Query([4, 2, 1, 3])}$|$\\texttt 1$|\n||$\\texttt{Query([3, 4, 5])}$|$\\texttt 0$|\n||$\\texttt{Query([2, 6, 5])}$|$\\texttt 1$|\n||$\\texttt{Query([6, 5, 4, 3, 2, 1])}$|$\\texttt 2$|\n||$\\texttt{Answer([1, 6, 5])}$||\n||$\\texttt{Answer([2, 3, 4])}$||\n\n注意，这组样例**不满足任意子任务的限制**。\n\n从「附加文件」中可以下载到 $\\texttt{sample-02.txt}$，其满足子任务 $1$ 的限制。\n\n**【数据范围】**\n\n对于所有测试数据，满足：\n\n- $1 \\le C_i \\le N$ $(1 \\le i \\le NM)$。\n- 对于每个 $j$ $(1 \\le j \\le N)$，恰有 $M$ 个 $i$ $(1 \\le i \\le NM)$ 满足 $C_i = j$。  \n- $N,M$ 是正整数。\n- $C_i$ $(1 \\le i \\le NM)$ 是一个 $[1,N]$ 内的整数。\n\n详细子任务附加限制及分值如下表所示：\n\n|子任务编号|附加限制|分值|\n|:-:|:-:|:-:|\n|$1$|$N=M=4$|$2$|\n|$2$|$N=100$，$M=10$|$5$|\n|$3$|$N=200$，$M=25$|$15$|\n|$4$|$N=400$，$M=25$|$78$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIST 2022] 一流团子师傅 / Super Dango Maker", "background": "JOISC2022 D4T1\n\n**特别提醒，由于洛谷交互机制的特殊性，你不能在程序中引用 `dango3.h`，而需要把 `dango3.h` 中的内容加入文件的开头。即，在程序中 `void Solve(int N, int M)` 的前面加入以下几行语句：**\n\n```cpp\n#include <vector>\n\nvoid Solve(int N, int M);\n\nint Query(const std::vector<int> &x);\nvoid Answer(const std::vector<int> &a);\n```", "description": "JOI 君是一位专业的团子师傅。在 JOI 君的店里，团子的颜色很有讲究。一共有 $N$ 种颜色，编号为 $1,2,\\dots,N$。\n\n**一流团子串**是 JOI 君的店里的招牌食品。制作一个一流团子串，需要将 $N$ 个**颜色不同**的团子串在一根竹签上。\n\n对于每一种颜色，JOI 君都制作了 $M$ 个这种颜色的团子。因此，JOI 君总共有了 $NM$ 个团子。这些团子被编号为 $1,2,\\dots,NM$。使用这些团子和 $M$ 根竹签，JOI 君希望串出 $M$ 个一流团子串。\n\n为了避免在颜色上犯错误，JOI 君将会启用他的团子检测器。如果 JOI 君输入一些团子的编号，团子检测器会返回使用这些团子能制作的一流团子串的个数的最大值。当然，前提是充分使用竹签。\n\nJOI 君希望能通过使用若干次团子检测器将 $NM$ 个团子分为 $M$ 组。其中，每一组包含 $N$ 个团子，且每种颜色的团子恰有一个。\n\nJOI 君想在使用不超过 $50\\,000$ 次团子检测器的前提下完成这件事。\n\n请写一个程序，对于给定的团子的信息，实现 JOI 君使用不超过 $50\\,000$ 次团子检测器来完成任务的策略。\n\n---\n\n**【实现细节】**\n\n你的程序需要实现以下函数。\n\n  - `void Solve(int N, int M)`。  \n    对于每组测试数据，该函数会被调用恰好一次。\n      - 参数 $\\texttt N$ 是团子的颜色数 $N$。\n      - 参数 $\\texttt M$ 是 JOI 君想制作的一流团子串的个数 $M$。\n\n你的程序可以调用以下函数。\n\n  - `int Query(const std::vector<int> &x)`。  \n    你的程序可以通过调用这个函数来使用团子检测器。\n      - 参数 `x` 是输入给团子检测器的团子的编号列表。\n      - 该函数返回使用 `x` 中的团子能制作的一流团子串的最大值。\n      - `x` 中的每个元素都应当是 $[1,NM]$ 中的整数。否则你的程序会被判定为 **Wrong Answer [1]**。\n      - `x` 中的元素应当互不相同。否则你的程序会被判定为 **Wrong Answer [2]**。\n      - 你的程序不得调用该函数超过 $50\\,000$ 次。否则你的程序会被判定为 **Wrong Answer [3]**。\n\n  - `void Answer(const std::vector<int> &a)`。  \n    你的程序可以通过调用这个程序来报告分组方案。\n      - 参数 `a` 是你分出的一组团子的编号列表。\n      - `a` 的长度应当为 $N$。否则你的程序会被判定为 **Wrong Answer [4]**。\n      - `a` 中的每个元素都应当是 $[1,NM]$ 中的整数。否则你的程序会被判定为 **Wrong Answer [5]**。\n      - 在整个过程中，同一个团子不能出现在参数中多于一次。否则你的程序会被判定为 **Wrong Answer [6]**。\n      - 如果用 `a` 中的团子并不能制作一个一流团子串，你的程序会被判定为 **Wrong Answer [7]**。\n      - 该函数应当被调用恰好 $M$ 次。否则你的程序会被判定为 **Wrong Answer [8]**。\n  \n**【提示】**\n  \n  - 你的程序可以实现其他函数以供内部使用，或者使用全局变量。\n  - 你的程序不得使用标准输入输出流，也不得以任何方式访问任何文件。然而，你可以输出调试信息到标准错误流。\n  \n**【编译与测试运行】**\n  \n你可以从「附加文件」中下载样例评分器来测试你的程序。「附加文件」中也提供了你应当提交的程序的一个样例。\n\n样例评分器即 `grader.cpp`。为了测试你的程序，请将 `grader.cpp,dango3.cpp` 放置在同一个目录下，并执行如下命令来编译你的程序。\n\n`g++ -std=gnu++17 -O2 -o grader grader.cpp dango3.cpp`\n\n若编译成功，将会生成一个可执行文件 `grader`。\n\n请注意，实际使用的评分器与下发的样例评分器不同。样例评分器仅会有单个进程，从标准输入中读取输入数据并将结果输出到标准输出。\n  \n**【样例评分器输入格式】**\n  \n第一行，两个正整数 $N,M$。表示团子的颜色数和 JOI 君想制作的一流团子串的个数。\n\n第二行，$N\\times M$ 个正整数 $C_1,C_2,\\dots,C_{NM}$。其中 $C_i$ 是一个 $[1,N]$ 内的正整数，表示第 $i$ 个团子的颜色。\n  \n**【样例评分器输出格式】**\n  \n- 如果你的程序被判定为正确，样例评分器会输出调用 `Query` 的次数，如 “$\\texttt{Accepted: 2022}$”。\n- 如果你的程序被判定为任意一种 Wrong Answer，样例评分器会输出其类型，如 “$\\texttt{Wrong Answer [4]}$”。\n\n如果你的程序属于多种 Wrong Answer，样例评分器只会输出其中一种。", "inputFormat": "", "outputFormat": "", "hint": "**【样例交互】**\n\n这里是样例评分器的一组样例输入和对应的交互过程。\n\n```plain\n3 2\n3 3 1 2 1 2\n```\n\n|调用|调用|返回值|\n|:-|:-|:-|\n|$\\texttt{Solve(3, 2)}$|||\n||$\\texttt{Query([])}$|$\\texttt 0$|\n||$\\texttt{Query([4, 2, 1, 3])}$|$\\texttt 1$|\n||$\\texttt{Query([3, 4, 5])}$|$\\texttt 0$|\n||$\\texttt{Query([2, 6, 5])}$|$\\texttt 1$|\n||$\\texttt{Query([6, 5, 4, 3, 2, 1])}$|$\\texttt 2$|\n||$\\texttt{Answer([1, 6, 5])}$||\n||$\\texttt{Answer([2, 3, 4])}$||\n\n注意，这组样例**不满足任意子任务的限制**。\n\n从「附加文件」中可以下载到 $\\texttt{sample-02.txt}$，其满足子任务 $1$ 的限制。\n\n**【数据范围】**\n\n对于所有测试数据，满足：\n\n- $1 \\le C_i \\le N$ $(1 \\le i \\le NM)$。\n- 对于每个 $j$ $(1 \\le j \\le N)$，恰有 $M$ 个 $i$ $(1 \\le i \\le NM)$ 满足 $C_i = j$。  \n- $N,M$ 是正整数。\n- $C_i$ $(1 \\le i \\le NM)$ 是一个 $[1,N]$ 内的整数。\n\n详细子任务附加限制及分值如下表所示：\n\n|子任务编号|附加限制|分值|\n|:-:|:-:|:-:|\n|$1$|$N=M=4$|$2$|\n|$2$|$N=100$，$M=10$|$5$|\n|$3$|$N=200$，$M=25$|$15$|\n|$4$|$N=400$，$M=25$|$78$|", "locale": "zh-CN"}}}
{"pid": "P9530", "type": "P", "difficulty": 7, "samples": [["5\n6 4 2 2 6\n6\n2 1 5\n2 1 3\n1 3 1\n2 2 5\n2 1 5\n2 2 4", "5\n2\n2\n3\n1"], ["13\n10 4 2 5 20 5 4 8 20 10 3 3 7\n1\n2 1 13", "7"], ["12\n32 32 4 1 1 1 1 4 4 16 32 128\n7\n2 1 12\n2 2 6\n2 8 10\n2 1 9\n2 3 8\n2 5 9\n2 2 12", "12\n1\n1\n2\n6\n2\n1"], ["10\n2 3 5 10 1 3 4 9 5 2\n8\n2 1 10\n1 10 5\n2 1 10\n1 4 1000000000\n2 1 10\n1 8 20\n1 4 8\n2 1 10", "4\n6\n1\n6"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "O2优化", "JOISC/JOIST（日本）"], "title": "[JOIST 2022] 鱼 2 / Fish 2", "background": "JOISC2022 D4T2", "description": "JOI 君有 $N$ 条鱼，编号为 $1,2,\\dots,N$。第 $i$ $(1 \\le i \\le N)$ 条鱼的大小为 $A_i$。\n\n当我们养鱼的时候，需要注意如下的一个事实：如果有两条鱼离得很近，那么随着时间的流逝，可能会有其中一条吃掉另一条。其中，两条鱼离得很近，当且仅当它们中间没有鱼。  \n更具体地，如果鱼 $x$ 的大小不小于鱼 $y$ 的大小，且鱼 $x,y$ 离得很近，那么 $x$ 可以吃掉 $y$，且 $x$ 的大小变为原来 $x,y$ 的大小之和。如果 $x,y$ 一样大，那么 $x$ 吃掉 $y$ 或 $y$ 吃掉 $x$ 都可能发生。\n\nJOI 君会养 $Q$ 天鱼。为了消磨时光，他会进行如下的思想实验。在第 $j$ 天 $(1 \\le j \\le Q)$，JOI 君会进行如下行动中的一个：\n\n- 第一类：JOI 君给鱼 $X_j$ 吃了某些秘制的食物。这会将鱼 $X_j$ 的大小变为 $Y_j$。\n\n- 第二类：JOI 君将编号在区间 $[L_j,R_j]$ 内的鱼单独拿出来，并进行以下实验：  \n  JOI 君将鱼 $L_j,L_j+1,\\dots,R_j$ 从左到右依次放在一个鱼缸中。由于鱼们具有如上所述的特点，最后只有一条鱼会存活。存活的这条鱼的编号取决于在哪些时刻哪些鱼吃掉了哪些鱼。JOI 君想知道可能成为最后存活者的鱼的条数。在实验中，鱼的编号不会改变，也不能有两条鱼同时吃掉同一条鱼。\n\n请写一个程序，对于给定的 JOI 君的鱼和实验的信息，计算每个第二类行动的答案来让 JOI 君能够证明或证伪自己的观点。注意这只是思想实验，并没有任何鱼真的被吃掉。", "inputFormat": "第一行，一个正整数 $N$，表示鱼的条数。\n\n第二行，$N$ 个正整数 $A_1,A_2,\\dots,A_N$，表示每条鱼的大小。\n\n第三行，一个正整数 $Q$，表示养鱼的天数。  \n接下来 $Q$ 行，其中第 $j$ $(1 \\le j \\le Q)$ 行包含若干个由空格分隔的整数，其中第一个整数为 $T_j$，表示操作类型。\n  - 若 $T_j=1$，则该行还包含两个正整数 $X_j,Y_j$，表示 JOI 君第 $j$ 天进行了第一类行动。鱼 $X_j$ 的大小变为 $Y_j$。\n  - 若 $T_j=2$，则该行还包含两个正整数 $L_j,R_j$，表示 JOI 君第 $j$ 天进行了第二类行动。JOI 君对编号在 $[L_j,R_j]$ 内的鱼进行了一次实验。", "outputFormat": "对于每次第二类行动（即，对于每个满足 $T_j=2$ 的 $j$ $(1 \\le j \\le Q)$），输出一行一个整数，表示可能成为最后存活者的鱼的条数。", "hint": "**【样例解释 #1】**\n\n在 $6$ 天中，JOI 君进行了以下行动：\n\n- 第一天，他对鱼 $1,2,3,4,5$ 进行了一次实验。\n- 第二天，他对鱼 $1,2,3$ 进行了一次实验。\n- 第三天，他给鱼 $3$ 吃了秘制食物，使其大小变为 $1$。\n- 第四天，他对鱼 $2,3,4,5$ 进行了一次实验。\n- 第五天，他对鱼 $1,2,3,4,5$ 进行了一次实验。\n- 第六天，他对鱼 $2,3,4$ 进行了一次实验。\n\n第一天的实验的结果如下：\n\n- 鱼缸中的鱼的大小依次为 $[6,4,2,2,6]$。\n- 例如，经过如下过程，鱼 $2$ 会成为最后存活者。（其中粗体为鱼 $2$ 的大小。）  \n  $[6,\\textbf 4,2,2,6]$（初始状态）$\\longrightarrow$ $[6,\\textbf 4,4,6]$（鱼 $4$ 吃掉鱼 $3$）$\\longrightarrow$ $[6,\\textbf 8,6]$（鱼 $2$ 吃掉鱼 $4$）$\\longrightarrow$ $[\\textbf{14},6]$（鱼 $2$ 吃掉鱼 $1$）$\\longrightarrow$ $[\\textbf{20}]$（鱼 $2$ 吃掉鱼 $5$）。\n- 类似地，鱼 $1,2,3,4,5$ 都可能成为最后存活者。因此答案为 $5$。\n\n该样例满足子任务 $1,3,6$ 的限制。\n\n**【样例解释 #2】**\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #3】**\n\n该样例满足子任务 $1,3,4,6$ 的限制。\n\n**【样例解释 #4】**\n\n该样例满足子任务 $1,3,5,6$ 的限制。\n\n**【数据范围】**\n\n对于所有数据，满足：\n\n- $1 \\le N,Q \\le 100\\,000$。\n- $1 \\le A_i \\le 10^9$ $(1\\le i\\le N)$。\n- $T_j \\in \\{1,2\\}$。\n- $1 \\le X_j \\le N$ $(1\\le j\\le Q)$。\n- $1 \\le Y_j \\le 10^9$。\n- $1 \\le L_j \\le R_j \\le N$ $(1 \\le j \\le Q)$。\n\n详细子任务附加限制及分值如下表所示：\n\n|子任务编号|附加限制|分值|\n|:-:|:-:|:-:|\n|$1$|$N \\le 500$，$Q \\le 500$|$5$|\n|$2$|$Q=1$，$T_j=2$，$L_j=1$，$R_j=N$ $(1 \\le j \\le Q)$|$8$|\n|$3$|$Q\\le 1\\,000$|$12$|\n|$4$|$T_j=2$ $(1 \\le j\\le Q)$|$23$|\n|$5$|对于每个满足 $T_j=2$ 的 $j$ $(1\\le j\\le Q)$，满足 $L_j=1$，$R_j=N$|$35$|\n|$6$|无附加限制|$17$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIST 2022] 鱼 2 / Fish 2", "background": "JOISC2022 D4T2", "description": "JOI 君有 $N$ 条鱼，编号为 $1,2,\\dots,N$。第 $i$ $(1 \\le i \\le N)$ 条鱼的大小为 $A_i$。\n\n当我们养鱼的时候，需要注意如下的一个事实：如果有两条鱼离得很近，那么随着时间的流逝，可能会有其中一条吃掉另一条。其中，两条鱼离得很近，当且仅当它们中间没有鱼。  \n更具体地，如果鱼 $x$ 的大小不小于鱼 $y$ 的大小，且鱼 $x,y$ 离得很近，那么 $x$ 可以吃掉 $y$，且 $x$ 的大小变为原来 $x,y$ 的大小之和。如果 $x,y$ 一样大，那么 $x$ 吃掉 $y$ 或 $y$ 吃掉 $x$ 都可能发生。\n\nJOI 君会养 $Q$ 天鱼。为了消磨时光，他会进行如下的思想实验。在第 $j$ 天 $(1 \\le j \\le Q)$，JOI 君会进行如下行动中的一个：\n\n- 第一类：JOI 君给鱼 $X_j$ 吃了某些秘制的食物。这会将鱼 $X_j$ 的大小变为 $Y_j$。\n\n- 第二类：JOI 君将编号在区间 $[L_j,R_j]$ 内的鱼单独拿出来，并进行以下实验：  \n  JOI 君将鱼 $L_j,L_j+1,\\dots,R_j$ 从左到右依次放在一个鱼缸中。由于鱼们具有如上所述的特点，最后只有一条鱼会存活。存活的这条鱼的编号取决于在哪些时刻哪些鱼吃掉了哪些鱼。JOI 君想知道可能成为最后存活者的鱼的条数。在实验中，鱼的编号不会改变，也不能有两条鱼同时吃掉同一条鱼。\n\n请写一个程序，对于给定的 JOI 君的鱼和实验的信息，计算每个第二类行动的答案来让 JOI 君能够证明或证伪自己的观点。注意这只是思想实验，并没有任何鱼真的被吃掉。", "inputFormat": "第一行，一个正整数 $N$，表示鱼的条数。\n\n第二行，$N$ 个正整数 $A_1,A_2,\\dots,A_N$，表示每条鱼的大小。\n\n第三行，一个正整数 $Q$，表示养鱼的天数。  \n接下来 $Q$ 行，其中第 $j$ $(1 \\le j \\le Q)$ 行包含若干个由空格分隔的整数，其中第一个整数为 $T_j$，表示操作类型。\n  - 若 $T_j=1$，则该行还包含两个正整数 $X_j,Y_j$，表示 JOI 君第 $j$ 天进行了第一类行动。鱼 $X_j$ 的大小变为 $Y_j$。\n  - 若 $T_j=2$，则该行还包含两个正整数 $L_j,R_j$，表示 JOI 君第 $j$ 天进行了第二类行动。JOI 君对编号在 $[L_j,R_j]$ 内的鱼进行了一次实验。", "outputFormat": "对于每次第二类行动（即，对于每个满足 $T_j=2$ 的 $j$ $(1 \\le j \\le Q)$），输出一行一个整数，表示可能成为最后存活者的鱼的条数。", "hint": "**【样例解释 #1】**\n\n在 $6$ 天中，JOI 君进行了以下行动：\n\n- 第一天，他对鱼 $1,2,3,4,5$ 进行了一次实验。\n- 第二天，他对鱼 $1,2,3$ 进行了一次实验。\n- 第三天，他给鱼 $3$ 吃了秘制食物，使其大小变为 $1$。\n- 第四天，他对鱼 $2,3,4,5$ 进行了一次实验。\n- 第五天，他对鱼 $1,2,3,4,5$ 进行了一次实验。\n- 第六天，他对鱼 $2,3,4$ 进行了一次实验。\n\n第一天的实验的结果如下：\n\n- 鱼缸中的鱼的大小依次为 $[6,4,2,2,6]$。\n- 例如，经过如下过程，鱼 $2$ 会成为最后存活者。（其中粗体为鱼 $2$ 的大小。）  \n  $[6,\\textbf 4,2,2,6]$（初始状态）$\\longrightarrow$ $[6,\\textbf 4,4,6]$（鱼 $4$ 吃掉鱼 $3$）$\\longrightarrow$ $[6,\\textbf 8,6]$（鱼 $2$ 吃掉鱼 $4$）$\\longrightarrow$ $[\\textbf{14},6]$（鱼 $2$ 吃掉鱼 $1$）$\\longrightarrow$ $[\\textbf{20}]$（鱼 $2$ 吃掉鱼 $5$）。\n- 类似地，鱼 $1,2,3,4,5$ 都可能成为最后存活者。因此答案为 $5$。\n\n该样例满足子任务 $1,3,6$ 的限制。\n\n**【样例解释 #2】**\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #3】**\n\n该样例满足子任务 $1,3,4,6$ 的限制。\n\n**【样例解释 #4】**\n\n该样例满足子任务 $1,3,5,6$ 的限制。\n\n**【数据范围】**\n\n对于所有数据，满足：\n\n- $1 \\le N,Q \\le 100\\,000$。\n- $1 \\le A_i \\le 10^9$ $(1\\le i\\le N)$。\n- $T_j \\in \\{1,2\\}$。\n- $1 \\le X_j \\le N$ $(1\\le j\\le Q)$。\n- $1 \\le Y_j \\le 10^9$。\n- $1 \\le L_j \\le R_j \\le N$ $(1 \\le j \\le Q)$。\n\n详细子任务附加限制及分值如下表所示：\n\n|子任务编号|附加限制|分值|\n|:-:|:-:|:-:|\n|$1$|$N \\le 500$，$Q \\le 500$|$5$|\n|$2$|$Q=1$，$T_j=2$，$L_j=1$，$R_j=N$ $(1 \\le j \\le Q)$|$8$|\n|$3$|$Q\\le 1\\,000$|$12$|\n|$4$|$T_j=2$ $(1 \\le j\\le Q)$|$23$|\n|$5$|对于每个满足 $T_j=2$ 的 $j$ $(1\\le j\\le Q)$，满足 $L_j=1$，$R_j=N$|$35$|\n|$6$|无附加限制|$17$|", "locale": "zh-CN"}}}
{"pid": "P9531", "type": "P", "difficulty": 7, "samples": [["5 10\n1 2 8\n1 3 13\n1 4 5\n1 5 11\n1 5 3\n2 3 7\n2 4 15\n3 4 6\n3 5 6\n4 5 2\n6\n3\n6\n8\n10\n13\n17", "8\n2\n5\n10\n9\n21"], ["3 4\n1 2 1\n1 2 4\n2 3 2\n2 3 4\n4\n1\n2\n3\n4", "1\n1\n2\n0"], ["10 20\n6 7 914727791\n1 8 771674531\n3 5 632918108\n5 9 329296846\n1 7 237501112\n4 9 303328173\n2 6 216298255\n2 10 504024991\n3 8 158236886\n1 10 10176179\n8 9 918271145\n3 6 217165898\n3 6 624543444\n4 9 70147274\n8 9 976983490\n6 9 210108505\n2 9 972711062\n1 10 564567289\n3 7 411395464\n4 7 952470985\n10\n115721165\n198969744\n356664401\n429802521\n513343279\n610443927\n741016686\n786597783\n898772266\n903568946", "1121073688\n761832468\n1026806785\n1316097872\n1321500065\n1445238392\n1637513141\n1621778548\n1733953031\n1738749711"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "O2优化", "JOISC/JOIST（日本）"], "title": "[JOIST 2022] 复兴计划 / Reconstruction Project", "background": "JOISC2022 D4T3", "description": "JOI 镇是一个曾经辉煌的工业区。为了运输产品，其中建起了许多铁轨与火车站。尽管 JOI 镇已经衰落，那里仍有许多不再被使用的铁轨与火车站。\n\nJOI 镇中有 $N$ 个火车站，编号为 $1,2,\\dots,N$。其中还剩下 $M$ 条铁轨。第 $i$ 条铁轨 $(1\\le i \\le M)$ 双向连接火车站 $A_i$ 和 $B_i$，且其宽度为 $W_i$。保证能够从任意火车站经过若干条铁轨到达任意其他火车站。\n\n你是 JOI 镇的镇长。你计划吸引铁路公司来使用 JOI 镇中留下的铁轨与火车站，使得 JOI 镇复苏成为「铁路之镇」。 \n \n于是，共有 $Q$ 个铁路公司申请参与这个复兴计划。然而，不同公司的火车所需的铁轨宽度也有所不同。这意味着你需要重建这些铁轨，使得它们都匹配对应公司的火车。 \n\n第 $j$ $(1\\le j\\le Q)$ 家铁路公司的火车所需的铁轨宽度为 $X_j$。为了迎合公司 $j$，要求满足以下条件：\n- **条件**：保证能够从任意火车站只经过宽度为 $X_j$ 的铁轨到达任意其他火车站。\n\n为了满足上述条件，你可以按如下方式重建铁轨任意次：\n- **重建**：选择一条铁轨，你可以重建其使得其宽度增加或减少 $1$ 并花费 $1$。然而，若其宽度为 $1$，则不能再减少其宽度。\n\n为了确定你能满足哪些公司，你需要求出迎合公司 $j$ 所需要的最小花费。\n\n请写一个程序，对于给定的火车站、铁轨与铁路公司的信息，计算迎合公司 $j$ 所需要的最小花费。", "inputFormat": "第一行，两个正整数 $N,M$，表示火车站的个数和铁轨的条数。\n\n接下来 $M$ 行，其中第 $i$ $(1 \\le i \\le M)$ 行包含三个正整数 $A_i, B_i, W_i$，表示第 $i$ 条铁轨连接的火车站和其宽度。\n\n第 $M+2$ 行，一个正整数 $Q$，表示铁路公司的个数。\n\n接下来 $Q$ 行，其中第 $j$ $(1 \\le j \\le Q)$ 行包含一个正整数 $X_j$，表示第 $j$ 个铁路公司的火车需要的铁路宽度。", "outputFormat": "输出 $Q$ 行，第 $j$ $(1\\le j\\le Q)$ 包含一个整数，表示迎合公司 $j$ 所需要的最小花费。", "hint": "**【样例解释 #1】**\n\n例如，为了迎合公司 $1$，若你按如下方式重建铁轨，将会花费 $8$。\n\n1. 将铁轨 $6$ 的宽度减少 $4$。\n2. 将铁轨 $9$ 的宽度减少 $3$。\n3. 将铁轨 $10$ 的宽度增加 $1$。\n\n可以证明不可能用少于 $8$ 的花费迎合公司 $1$。因此，在第一行输出 $8$。\n\n该样例满足子任务 $1,2,4,5,6$ 的限制。\n\n**【样例解释 #2】**\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #3】**\n\n该样例满足子任务 $2,4,5,6$ 的限制。\n\n**【数据范围】**\n\n对于所有数据，满足：\n\n- $2 \\le N \\le 500$。\n- $N-1 \\le M \\le 100\\,000$。\n- $1 \\le Q \\le 1\\,000\\,000$。\n- $1 \\le A_i < B_i \\le N$ $(1\\le i\\le M)$。\n- $1 \\le W_i \\le 10^9$ $(1\\le i\\le M)$。\n- $(A_i,B_i,W_i)\\ne(A_j,B_j,W_j)$ $(1\\le i<j\\le M)$。\n- 保证能够从任意火车站经过若干条铁轨到达任意其他火车站。\n- $1 \\le X_j \\le 10^9$ $(1\\le j\\le Q)$。\n- $X_j < X_{j+1}$ $(1\\le j<Q)$。\n\n详细子任务附加限制及分值如下表所示：\n\n|子任务编号|附加限制|分值|\n|:-:|:-:|:-:|\n|$1$|$M \\le 16$，$Q \\le 10$|$3$|\n|$2$|$Q\\le 10$|$4$|\n|$3$|$B_i = A_i+1$ $(1\\le i\\le M)$|$7$|\n|$4$|$M\\le 1\\,000$|$28$|\n|$5$|$Q\\le 20\\,000$|$35$|\n|$6$|无附加限制|$23$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIST 2022] 复兴计划 / Reconstruction Project", "background": "JOISC2022 D4T3", "description": "JOI 镇是一个曾经辉煌的工业区。为了运输产品，其中建起了许多铁轨与火车站。尽管 JOI 镇已经衰落，那里仍有许多不再被使用的铁轨与火车站。\n\nJOI 镇中有 $N$ 个火车站，编号为 $1,2,\\dots,N$。其中还剩下 $M$ 条铁轨。第 $i$ 条铁轨 $(1\\le i \\le M)$ 双向连接火车站 $A_i$ 和 $B_i$，且其宽度为 $W_i$。保证能够从任意火车站经过若干条铁轨到达任意其他火车站。\n\n你是 JOI 镇的镇长。你计划吸引铁路公司来使用 JOI 镇中留下的铁轨与火车站，使得 JOI 镇复苏成为「铁路之镇」。 \n \n于是，共有 $Q$ 个铁路公司申请参与这个复兴计划。然而，不同公司的火车所需的铁轨宽度也有所不同。这意味着你需要重建这些铁轨，使得它们都匹配对应公司的火车。 \n\n第 $j$ $(1\\le j\\le Q)$ 家铁路公司的火车所需的铁轨宽度为 $X_j$。为了迎合公司 $j$，要求满足以下条件：\n- **条件**：保证能够从任意火车站只经过宽度为 $X_j$ 的铁轨到达任意其他火车站。\n\n为了满足上述条件，你可以按如下方式重建铁轨任意次：\n- **重建**：选择一条铁轨，你可以重建其使得其宽度增加或减少 $1$ 并花费 $1$。然而，若其宽度为 $1$，则不能再减少其宽度。\n\n为了确定你能满足哪些公司，你需要求出迎合公司 $j$ 所需要的最小花费。\n\n请写一个程序，对于给定的火车站、铁轨与铁路公司的信息，计算迎合公司 $j$ 所需要的最小花费。", "inputFormat": "第一行，两个正整数 $N,M$，表示火车站的个数和铁轨的条数。\n\n接下来 $M$ 行，其中第 $i$ $(1 \\le i \\le M)$ 行包含三个正整数 $A_i, B_i, W_i$，表示第 $i$ 条铁轨连接的火车站和其宽度。\n\n第 $M+2$ 行，一个正整数 $Q$，表示铁路公司的个数。\n\n接下来 $Q$ 行，其中第 $j$ $(1 \\le j \\le Q)$ 行包含一个正整数 $X_j$，表示第 $j$ 个铁路公司的火车需要的铁路宽度。", "outputFormat": "输出 $Q$ 行，第 $j$ $(1\\le j\\le Q)$ 包含一个整数，表示迎合公司 $j$ 所需要的最小花费。", "hint": "**【样例解释 #1】**\n\n例如，为了迎合公司 $1$，若你按如下方式重建铁轨，将会花费 $8$。\n\n1. 将铁轨 $6$ 的宽度减少 $4$。\n2. 将铁轨 $9$ 的宽度减少 $3$。\n3. 将铁轨 $10$ 的宽度增加 $1$。\n\n可以证明不可能用少于 $8$ 的花费迎合公司 $1$。因此，在第一行输出 $8$。\n\n该样例满足子任务 $1,2,4,5,6$ 的限制。\n\n**【样例解释 #2】**\n\n该样例满足所有子任务的限制。\n\n**【样例解释 #3】**\n\n该样例满足子任务 $2,4,5,6$ 的限制。\n\n**【数据范围】**\n\n对于所有数据，满足：\n\n- $2 \\le N \\le 500$。\n- $N-1 \\le M \\le 100\\,000$。\n- $1 \\le Q \\le 1\\,000\\,000$。\n- $1 \\le A_i < B_i \\le N$ $(1\\le i\\le M)$。\n- $1 \\le W_i \\le 10^9$ $(1\\le i\\le M)$。\n- $(A_i,B_i,W_i)\\ne(A_j,B_j,W_j)$ $(1\\le i<j\\le M)$。\n- 保证能够从任意火车站经过若干条铁轨到达任意其他火车站。\n- $1 \\le X_j \\le 10^9$ $(1\\le j\\le Q)$。\n- $X_j < X_{j+1}$ $(1\\le j<Q)$。\n\n详细子任务附加限制及分值如下表所示：\n\n|子任务编号|附加限制|分值|\n|:-:|:-:|:-:|\n|$1$|$M \\le 16$，$Q \\le 10$|$3$|\n|$2$|$Q\\le 10$|$4$|\n|$3$|$B_i = A_i+1$ $(1\\le i\\le M)$|$7$|\n|$4$|$M\\le 1\\,000$|$28$|\n|$5$|$Q\\le 20\\,000$|$35$|\n|$6$|无附加限制|$23$|", "locale": "zh-CN"}}}
{"pid": "P9532", "type": "P", "difficulty": 2, "samples": [["3\n2 2\n3 2\n4 2", "2\n2\n4"], ["3\n3 1\n3 2\n3 4", "2\n2\n4"], ["3\n2 6\n3 6\n4 6", "6\n6\n12"], ["3\n3 3\n3 6\n3 12", "6\n6\n12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "洛谷原创", "O2优化", "洛谷月赛"], "title": "[YsOI2023] 前缀和", "background": "Ysuperman 模板测试的试机题。\n\n小心立秋，小心秋丽。", "description": "立秋有一个长度为 $n$ 的数组 $a$，所有数字都是正整数，并且除了其中第一个数字以外其它数字都等于前面所有数字的和。\n\n例如，数组 $[1,1,2,4,8,16]$ 就有可能是立秋有的一个数组，因为除了第一个数字 $1$，后面的每个数字都是前面数字的和，例如：\n\n- 第二个数字 $1=1$。\n- 第三个数字 $2=1+1$。\n- 第四个数字 $4=1+1+2$。\n- 第五个数字 $8=1+1+2+4$。\n- 第六个数字 $16=1+1+2+4+8$。 \n\n现在立秋告诉了秋丽数字 $x$ 存在于这个数组中，秋丽希望知道 $a_n$ 最小会是多少，或者说整个数组最后一个数字最小有多少。", "inputFormat": "本题有多组测试数据。\n\n输入第一行一个数字 $T$ 表示测试数据组数。\n\n接下来 $T$ 行每行两个正整数 $n,x$。", "outputFormat": "输出共 $T$ 行，分别表示每组测试数据的答案。\n\n对于某组数据 $n,x$，输出一行一个正整数表示可能的最小的 $a_n$。", "hint": "#### 样例 1 解释\n\n- 第一组数据只有唯一可能的数组 $[2,2]$，所以答案为 $2$；\n- 第二组数据有两种可能的数组，分别是 $[2,2,4]$ 和 $[1,1,2]$，所以答案为 $2$；\n- 第三组数据有两种可能的数组，分别是 $[2,2,4,8]$ 和 $[1,1,2,4]$，所以答案为 $4$。\n\n#### 样例 2 解释\n\n- 第一组数据只有唯一可能的数组 $[1,1,2]$，所以答案为 $2$；\n- 第二组数据有两种可能的数组 $[1,1,2]$ 和 $[2,2,4]$，所以答案为 $2$；\n- 第三组数据有两种可能的数组 $[2,2,4]$ 和 $[4,4,8]$，所以答案为 $4$。\n\n#### 数据范围\n\n对于前 $30\\%$ 的数据，满足 $x$ 不能被 $2$ 整除，或者说 $2$ 不是 $x$ 的一个因数，或者说 $x$ 是奇数。\n\n另有 $30\\%$ 的数据，满足 $x$ 可以被 $2^{n-2}$ 整除，或者说 $2^{n-2}$ 是 $x$ 的一个因数。\n\n另有 $20\\%$ 的数据，满足 $x\\le 1000$，可以证明在这个数据范围下答案可以使用一个 `int` 类型变量存储。\n\n对于 $100\\%$ 的数据，满足 $1\\le T\\le 10^4$，$2\\le n\\le 20$，$1\\le x\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[YsOI2023] 前缀和", "background": "Ysuperman 模板测试的试机题。\n\n小心立秋，小心秋丽。", "description": "立秋有一个长度为 $n$ 的数组 $a$，所有数字都是正整数，并且除了其中第一个数字以外其它数字都等于前面所有数字的和。\n\n例如，数组 $[1,1,2,4,8,16]$ 就有可能是立秋有的一个数组，因为除了第一个数字 $1$，后面的每个数字都是前面数字的和，例如：\n\n- 第二个数字 $1=1$。\n- 第三个数字 $2=1+1$。\n- 第四个数字 $4=1+1+2$。\n- 第五个数字 $8=1+1+2+4$。\n- 第六个数字 $16=1+1+2+4+8$。 \n\n现在立秋告诉了秋丽数字 $x$ 存在于这个数组中，秋丽希望知道 $a_n$ 最小会是多少，或者说整个数组最后一个数字最小有多少。", "inputFormat": "本题有多组测试数据。\n\n输入第一行一个数字 $T$ 表示测试数据组数。\n\n接下来 $T$ 行每行两个正整数 $n,x$。", "outputFormat": "输出共 $T$ 行，分别表示每组测试数据的答案。\n\n对于某组数据 $n,x$，输出一行一个正整数表示可能的最小的 $a_n$。", "hint": "#### 样例 1 解释\n\n- 第一组数据只有唯一可能的数组 $[2,2]$，所以答案为 $2$；\n- 第二组数据有两种可能的数组，分别是 $[2,2,4]$ 和 $[1,1,2]$，所以答案为 $2$；\n- 第三组数据有两种可能的数组，分别是 $[2,2,4,8]$ 和 $[1,1,2,4]$，所以答案为 $4$。\n\n#### 样例 2 解释\n\n- 第一组数据只有唯一可能的数组 $[1,1,2]$，所以答案为 $2$；\n- 第二组数据有两种可能的数组 $[1,1,2]$ 和 $[2,2,4]$，所以答案为 $2$；\n- 第三组数据有两种可能的数组 $[2,2,4]$ 和 $[4,4,8]$，所以答案为 $4$。\n\n#### 数据范围\n\n对于前 $30\\%$ 的数据，满足 $x$ 不能被 $2$ 整除，或者说 $2$ 不是 $x$ 的一个因数，或者说 $x$ 是奇数。\n\n另有 $30\\%$ 的数据，满足 $x$ 可以被 $2^{n-2}$ 整除，或者说 $2^{n-2}$ 是 $x$ 的一个因数。\n\n另有 $20\\%$ 的数据，满足 $x\\le 1000$，可以证明在这个数据范围下答案可以使用一个 `int` 类型变量存储。\n\n对于 $100\\%$ 的数据，满足 $1\\le T\\le 10^4$，$2\\le n\\le 20$，$1\\le x\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P9533", "type": "P", "difficulty": 3, "samples": [["3\n1 1 1", "2"], ["4\n3 1 2 3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "O2优化", "前缀和", "位运算", "洛谷月赛"], "title": "[YsOI2023] 区间翻转区间异或和", "background": "Ysuperman 模板测试的数据结构题。\n\n符卡可以是人名也可以是队名。", "description": "符卡有一个长度为 $n$ 的整数数组 $a$，符卡认为一个区间 $[l,r]$ 是灵异区间当且仅当 $\\bigoplus_{i=l}^ra_i=0$，或者说这个区间内所有数字异或起来刚好等于 $0$。\n\n符卡有特殊的魔法，可以把**任意**一个灵异区间翻转。具体来说，如果 $[l,r]$ 区间是灵异区间，那么符卡就可以对这个区间使用魔法，整个数组就会变成 $a_1,a_2,\\dots,a_{l-1},a_r,a_{r-1},\\dots,a_l,a_{r+1},a_{r+2}\\dots,a_n$。\n\n现在符卡可以使用任意次数的魔法，符卡希望最后得到的数组的灵异区间数量能够尽可能多，你能告诉她最后最多有多少个灵异区间吗？", "inputFormat": "第一行一个正整数 $n$，表示数组长度。\n\n第二行 $n$ 个非负整数 $a_1,a_2,\\dots,a_n$ 表示整个数组。", "outputFormat": "输出一行一个整数，表示符卡使用任意次魔法后灵异区间最多有多少个。", "hint": "#### 样例 1 解释\n\n无论符卡发动多少次魔法，数组都是 $1,1,1$，所以发不发动魔法都没有任何关系。灵异区间永远都是 $[1,2],[2,3]$ 两个。\n\n#### 样例 2 解释\n\n这里给出可能的一种魔法发动方法。\n\n选择灵异区间 $[1,3]$ 发动魔法，得到的新数组是 $2,1,3,3$，这个数组共有两个灵异区间，分别是 $[1,3]$ 和 $[3,4]$。\n\n可以证明答案无法超过 $2$。\n\n#### 数据范围\n\n对于前 $20\\%$ 的数据，保证 $n\\le 10$。\n\n对于前 $40\\%$ 的数据，保证 $n\\le 2000$。\n\n另有 $10\\%$ 的数据，保证 $a_i$ 全部相等。\n\n另有 $10\\%$ 的数据，保证 $a_i$ 只有两种可能的取值。\n\n另有 $10\\%$ 的数据，保证 $0\\le a_i<2^{10}$。\n\n对于 $100\\%$ 的数据，满足 $1\\le n\\le 10^5$，$0\\le a_i< 2^{20}$。\n\n#### 彩蛋\n\n灵异区间的名字其实是“零异（或）区间”的谐音。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[YsOI2023] 区间翻转区间异或和", "background": "Ysuperman 模板测试的数据结构题。\n\n符卡可以是人名也可以是队名。", "description": "符卡有一个长度为 $n$ 的整数数组 $a$，符卡认为一个区间 $[l,r]$ 是灵异区间当且仅当 $\\bigoplus_{i=l}^ra_i=0$，或者说这个区间内所有数字异或起来刚好等于 $0$。\n\n符卡有特殊的魔法，可以把**任意**一个灵异区间翻转。具体来说，如果 $[l,r]$ 区间是灵异区间，那么符卡就可以对这个区间使用魔法，整个数组就会变成 $a_1,a_2,\\dots,a_{l-1},a_r,a_{r-1},\\dots,a_l,a_{r+1},a_{r+2}\\dots,a_n$。\n\n现在符卡可以使用任意次数的魔法，符卡希望最后得到的数组的灵异区间数量能够尽可能多，你能告诉她最后最多有多少个灵异区间吗？", "inputFormat": "第一行一个正整数 $n$，表示数组长度。\n\n第二行 $n$ 个非负整数 $a_1,a_2,\\dots,a_n$ 表示整个数组。", "outputFormat": "输出一行一个整数，表示符卡使用任意次魔法后灵异区间最多有多少个。", "hint": "#### 样例 1 解释\n\n无论符卡发动多少次魔法，数组都是 $1,1,1$，所以发不发动魔法都没有任何关系。灵异区间永远都是 $[1,2],[2,3]$ 两个。\n\n#### 样例 2 解释\n\n这里给出可能的一种魔法发动方法。\n\n选择灵异区间 $[1,3]$ 发动魔法，得到的新数组是 $2,1,3,3$，这个数组共有两个灵异区间，分别是 $[1,3]$ 和 $[3,4]$。\n\n可以证明答案无法超过 $2$。\n\n#### 数据范围\n\n对于前 $20\\%$ 的数据，保证 $n\\le 10$。\n\n对于前 $40\\%$ 的数据，保证 $n\\le 2000$。\n\n另有 $10\\%$ 的数据，保证 $a_i$ 全部相等。\n\n另有 $10\\%$ 的数据，保证 $a_i$ 只有两种可能的取值。\n\n另有 $10\\%$ 的数据，保证 $0\\le a_i<2^{10}$。\n\n对于 $100\\%$ 的数据，满足 $1\\le n\\le 10^5$，$0\\le a_i< 2^{20}$。\n\n#### 彩蛋\n\n灵异区间的名字其实是“零异（或）区间”的谐音。", "locale": "zh-CN"}}}
{"pid": "P9534", "type": "P", "difficulty": 5, "samples": [["4 4\n2 1\n1 3\n2 4\n4 3\n0 1 1 3", "1 3\n3 4\n1 2\n2 4\n"], ["8 9\n7 8\n6 1\n5 4\n7 1\n4 1\n3 7\n2 6\n7 5\n2 4\n0 6 7 1 4 1 1 7", "6 2\n7 3\n4 5\n1 6\n7 8\n1 4\n1 7\n2 4\n5 7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "Special Judge", "O2优化", "广度优先搜索 BFS", "拓扑排序", "最近公共祖先 LCA", "洛谷月赛"], "title": "[YsOI2023] 广度优先遍历", "background": "Ysuperman 模板测试的图论题。\n\n【数据删除】", "description": "今天的模板测试是无向图上的广度优先遍历，【数据删除】马上写好了代码：\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\nconst int maxn = 100005;\nvector<int> G[maxn];\nqueue<int> q;\nint pa[maxn];\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    for (int i = 1; i <= m; ++i)\n    {\n        int u, v;\n        cin >> u >> v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    memset(pa, -1, sizeof pa);\n    q.push(1);\n    pa[1] = 0;\n    while (!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        for (auto v : G[u])\n        {\n            if (pa[v] != -1)\n                continue;\n            pa[v] = u;\n            q.push(v);\n        }\n    }\n    for (int i = 1; i <= n; ++i)\n    {\n        cout << pa[i];\n        if (i != n)\n            cout << \" \";\n    }\n    cout << endl;\n    return 0;\n}\n```\n\n如你所见，这份代码会输入一个 $n$ 个点 $m$ 条边的无向图，并且求出这张图以 $1$ 为根的一棵“广度优先遍历树”，最后输出所有点的父亲节点编号。\n\n不过值得注意的是，这棵“广度优先遍历树”的具体形态和“边的输入顺序”有关，也就是说，不同的输入顺序可能会得到不同的父亲节点编号。\n\n现在【数据删除】告诉了你 $n,m$、这 $m$ 条边以及在某个“边输入顺序”情况下他的代码的输出，你需要还原出这个“边输入顺序”。如果有多种边输入顺序对应的都是这样的输出，你**只需要输出其中任意一种**即可。\n\n特别的，保证有解，且无向图连通，无自环（但是有可能有重边）。", "inputFormat": "第一行两个正整数 $n,m$ 分别表示无向图的点数和边数。\n\n接下来 $m$ 行每行两个整数 $u,v$ 表示存在 $u$ 与 $v$ 之间存在一条无向边。\n\n最后一行 $n$ 个整数表示【数据删除】代码的输出。（由题意可知他输出的是某个“边输入顺序”情况下他得到的“广度优先遍历树”中 $1\\sim n$ 这些节点的父亲节点编号）", "outputFormat": "输出包含 $m$ 行，每行两个整数 $u,v$ 表示 $u$ 和 $v$ 之间存在一条无向边，你的输出顺序表示你给出的“边输入顺序”。\n\n请注意，你需要保证如果输入给出的图中 $u,v$ 间连了 $k$ 条边，那么你给出的图中 $u,v$ 间也要连有 $k$ 条边。\n\n如果有多种“边输入顺序”合法，**输出其中任意一种都会被判断为正确**。另外，由于是无向边，所以你输出的**一条边两个点的排列顺序对答案判定没有影响**。", "hint": "#### 样例 1 解释\n\n直接运行【数据删除】的代码即可。\n\n如果不改变边输入顺序，将下面数据输入【数据删除】的代码：\n\n```\n4 4\n2 1\n1 3\n2 4\n4 3\n```\n\n他的代码跑出来结果如下：\n\n```\n0 1 1 2\n```\n\n如果按照样例 1 输出给出的顺序，即，将下面数据输入他的代码：\n\n```\n4 4\n1 3\n3 4\n1 2\n2 4\n```\n\n输出为：\n\n```\n0 1 1 3\n```\n\n#### 数据范围\n\n对于前 $10\\%$ 的数据，满足 $n\\le 8$，$m\\le 10$。\n\n对于前 $40\\%$ 的数据，满足 $n\\le 1000$，$m\\le 2000$。\n\n另有 $10\\%$ 的数据，满足 $m=n-1$。\n\n对于 $100\\%$ 的数据，满足 $1\\le n\\le 10^5$，$1\\le m\\le 2\\times 10^5$。\n\n#### 提示\n\n为什么有可能会有重边，因为懒得去重了，这个家伙出图论题就是懒得判重边的（）\n\n附件下发了本题 checker。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[YsOI2023] 广度优先遍历", "background": "Ysuperman 模板测试的图论题。\n\n【数据删除】", "description": "今天的模板测试是无向图上的广度优先遍历，【数据删除】马上写好了代码：\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\nconst int maxn = 100005;\nvector<int> G[maxn];\nqueue<int> q;\nint pa[maxn];\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    for (int i = 1; i <= m; ++i)\n    {\n        int u, v;\n        cin >> u >> v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    memset(pa, -1, sizeof pa);\n    q.push(1);\n    pa[1] = 0;\n    while (!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        for (auto v : G[u])\n        {\n            if (pa[v] != -1)\n                continue;\n            pa[v] = u;\n            q.push(v);\n        }\n    }\n    for (int i = 1; i <= n; ++i)\n    {\n        cout << pa[i];\n        if (i != n)\n            cout << \" \";\n    }\n    cout << endl;\n    return 0;\n}\n```\n\n如你所见，这份代码会输入一个 $n$ 个点 $m$ 条边的无向图，并且求出这张图以 $1$ 为根的一棵“广度优先遍历树”，最后输出所有点的父亲节点编号。\n\n不过值得注意的是，这棵“广度优先遍历树”的具体形态和“边的输入顺序”有关，也就是说，不同的输入顺序可能会得到不同的父亲节点编号。\n\n现在【数据删除】告诉了你 $n,m$、这 $m$ 条边以及在某个“边输入顺序”情况下他的代码的输出，你需要还原出这个“边输入顺序”。如果有多种边输入顺序对应的都是这样的输出，你**只需要输出其中任意一种**即可。\n\n特别的，保证有解，且无向图连通，无自环（但是有可能有重边）。", "inputFormat": "第一行两个正整数 $n,m$ 分别表示无向图的点数和边数。\n\n接下来 $m$ 行每行两个整数 $u,v$ 表示存在 $u$ 与 $v$ 之间存在一条无向边。\n\n最后一行 $n$ 个整数表示【数据删除】代码的输出。（由题意可知他输出的是某个“边输入顺序”情况下他得到的“广度优先遍历树”中 $1\\sim n$ 这些节点的父亲节点编号）", "outputFormat": "输出包含 $m$ 行，每行两个整数 $u,v$ 表示 $u$ 和 $v$ 之间存在一条无向边，你的输出顺序表示你给出的“边输入顺序”。\n\n请注意，你需要保证如果输入给出的图中 $u,v$ 间连了 $k$ 条边，那么你给出的图中 $u,v$ 间也要连有 $k$ 条边。\n\n如果有多种“边输入顺序”合法，**输出其中任意一种都会被判断为正确**。另外，由于是无向边，所以你输出的**一条边两个点的排列顺序对答案判定没有影响**。", "hint": "#### 样例 1 解释\n\n直接运行【数据删除】的代码即可。\n\n如果不改变边输入顺序，将下面数据输入【数据删除】的代码：\n\n```\n4 4\n2 1\n1 3\n2 4\n4 3\n```\n\n他的代码跑出来结果如下：\n\n```\n0 1 1 2\n```\n\n如果按照样例 1 输出给出的顺序，即，将下面数据输入他的代码：\n\n```\n4 4\n1 3\n3 4\n1 2\n2 4\n```\n\n输出为：\n\n```\n0 1 1 3\n```\n\n#### 数据范围\n\n对于前 $10\\%$ 的数据，满足 $n\\le 8$，$m\\le 10$。\n\n对于前 $40\\%$ 的数据，满足 $n\\le 1000$，$m\\le 2000$。\n\n另有 $10\\%$ 的数据，满足 $m=n-1$。\n\n对于 $100\\%$ 的数据，满足 $1\\le n\\le 10^5$，$1\\le m\\le 2\\times 10^5$。\n\n#### 提示\n\n为什么有可能会有重边，因为懒得去重了，这个家伙出图论题就是懒得判重边的（）\n\n附件下发了本题 checker。", "locale": "zh-CN"}}}
{"pid": "P9535", "type": "P", "difficulty": 7, "samples": [["4 4\n2 1 1 1", "3"], ["4 5\n1 1 1 1", "6"], ["5 6\n1 1 2 1 1", "27"], ["6 6\n1 2 3 1 1 1", "30"], ["6 5\n2 1 1 1 1 4", "4"], ["8 7\n1 1 3 1 2 2 2 2", "360"], ["8 8\n1 1 1 1 2 2 2 2", "2520"], ["8 9\n1 1 1 1 1 1 2 3", "9240"], ["10 11\n1 1 1 4 2 2 2 1 1 1", "105840"], ["12 13\n1 1 1 1 1 1 1 1 1 1 1 1", "518269694\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "洛谷原创", "O2优化", "洛谷月赛"], "title": "[YsOI2023] 连通图计数", "background": "Ysuperman 模板测试的多项式题。\n\n【数据删除】", "description": "请问有多少个 $n$ 个点 $m$ 条边的**无向简单连通**图，无自环无重边，满足删掉编号为 $i$ 的点后无向图被分成了 $a_i$ 个连通块。特殊地，我们保证 $n-1\\le m\\le n+1$，且答案不为 $0$。\n\n答案对 $998,244,353$ 取模。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数，第 $i$ 个整数为 $a_i$。", "outputFormat": "输出一行一个整数，表示答案对 $998,244,353$ 取模得到的结果。", "hint": "#### 样例 1 解释\n\n共有三种可能的图，连的四条边分别为：\n\n1. $(1,2),(1,3),(1,4),(2,3)$。\n2. $(1,2),(1,3),(1,4),(2,4)$。\n3. $(1,2),(1,3),(1,4),(3,4)$。\n\n#### 数据范围\n\n|测试点编号|$n,m$|特殊性质|\n|:-:|:-:|:-:|\n|$1\\sim 4$|$m=n-1$|无|\n|$5\\sim 6$|$m=n$，$n\\le 7$|无|\n|$7\\sim 8$|$m=n$|$a_i=1$|\n|$9\\sim 12$|$m=n$|无|\n|$13\\sim 14$|$m=n+1$，$n\\le 7$|无|\n|$15\\sim 16$|$m=n+1$|$a_i=1$|\n|$17\\sim 20$|$m=n+1$|无|\n\n对于所有的数据，满足 $4\\le n\\le 10^5$，$n-1\\le m\\le n+1$，$1\\le a_i<n$，$n\\le \\sum_{i=1}^na_i\\le 2n-2$，且保证答案非 $0$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[YsOI2023] 连通图计数", "background": "Ysuperman 模板测试的多项式题。\n\n【数据删除】", "description": "请问有多少个 $n$ 个点 $m$ 条边的**无向简单连通**图，无自环无重边，满足删掉编号为 $i$ 的点后无向图被分成了 $a_i$ 个连通块。特殊地，我们保证 $n-1\\le m\\le n+1$，且答案不为 $0$。\n\n答案对 $998,244,353$ 取模。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数，第 $i$ 个整数为 $a_i$。", "outputFormat": "输出一行一个整数，表示答案对 $998,244,353$ 取模得到的结果。", "hint": "#### 样例 1 解释\n\n共有三种可能的图，连的四条边分别为：\n\n1. $(1,2),(1,3),(1,4),(2,3)$。\n2. $(1,2),(1,3),(1,4),(2,4)$。\n3. $(1,2),(1,3),(1,4),(3,4)$。\n\n#### 数据范围\n\n|测试点编号|$n,m$|特殊性质|\n|:-:|:-:|:-:|\n|$1\\sim 4$|$m=n-1$|无|\n|$5\\sim 6$|$m=n$，$n\\le 7$|无|\n|$7\\sim 8$|$m=n$|$a_i=1$|\n|$9\\sim 12$|$m=n$|无|\n|$13\\sim 14$|$m=n+1$，$n\\le 7$|无|\n|$15\\sim 16$|$m=n+1$|$a_i=1$|\n|$17\\sim 20$|$m=n+1$|无|\n\n对于所有的数据，满足 $4\\le n\\le 10^5$，$n-1\\le m\\le n+1$，$1\\le a_i<n$，$n\\le \\sum_{i=1}^na_i\\le 2n-2$，且保证答案非 $0$。", "locale": "zh-CN"}}}
{"pid": "P9536", "type": "P", "difficulty": 7, "samples": [["4 3\n2 4 3\n", "2 666666673 1"], ["6 4\n4 6 5 2", "4 1 1 3 2"], ["10 12\n6 9 2 10 1 5 5 9 10 7 8 3\n", "585858594 60606064 8080810 834343444 638383846 785858595 913131322 595959602 286868692"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 153600]}, "tags": ["动态规划 DP", "洛谷原创", "O2优化", "洛谷月赛"], "title": "[YsOI2023] Prüfer 序列", "background": "Ysuperman 模板测试的计数题。\n\n众所周知，Prüfer 序列几乎没有在正赛中出现过，所以它需要出现在洛谷月赛中。", "description": "众所周知，一棵 $n$ 个点的有标号无根树与他的 Prüfer 序列一一对应。如果你不知道 Prüfer 序列指的是什么，可以参考下面提示说明中对 Prüfer 序列的解释。\n\n现在给你一个长度为 $m$ 的正整数序列 $a$，其中 $a_i\\in[1,n]$。等概率随机选择这个序列的一个长度为 $n-2$ 的子序列（只要选择下标不同就认为两个子序列不同）作为 Prüfer 序列构造得到一棵树 $T$，对于所有 $1\\le i<n$，你需要求出 $\\mathrm{dist}(i,n)$ 的期望（$\\mathrm{dist}(u,v)$ 定义为 $u,v$ 两点简单路径的边数）。\n\n答案对 $10^9+7$ 取模。", "inputFormat": "输入第一行两个正整数 $n,m$。\n\n第二行 $m$ 个整数表示序列 $a$，保证 $1\\le a_i\\le n$。", "outputFormat": "输出 $n-1$ 个非负整数，第 $i$ 个整数表示 $\\mathrm{dist}(i,n)$ 的期望。", "hint": "#### 对 Prüfer 序列的解释\n\n对于一棵给定的无根有标号树，Prüfer 序列的构建过程如下：每次选择一个编号最小的叶结点并删掉它，然后在序列中记录下它连接到的那个结点，重复 $n-2$ 次后就只剩下两个结点，此时记录下来的那个序列就是这棵无根有标号树的 Prüfer 序列。\n\n我们可以证明，一棵结点数量大于 $1$ 的无根有标号树和一个 Prüfer 序列是一一对应的，并且任意一个长度为 $n-2$ 每个数取 $[1,n]$ 范围内的整数的 Prüfer 序列都有唯一对应它的树，所以同样的，我们也可以根据一个 Prüfer 序列还原出一棵树。\n\n有关 Prüfer 序列更加详细的内容，你可以参考 [OI wiki 上关于 Prüfer 序列的描述](https://oi-wiki.org/graph/prufer/)。\n\n#### 样例 1 解释\n\n共有三种等可能选择的子序列：$2,4$，$2,3$，$4,3$。\n\n1. $2,4$ 对应的树为一条链 $1-2-4-3$，其中 $1,2,3$ 与 $4$ 的距离分别为 $2,1,1$。\n2. $2,3$ 对应的树为一条链 $1-2-3-4$，其中 $1,2,3$ 与 $4$ 的距离分别为 $3,2,1$。\n3. $4,3$ 对应的树为一条链 $1-4-3-2$，其中 $1,2,3$ 与 $4$ 的距离分别为 $1,2,1$。\n\n所以 $\\mathrm{dist}(1,4)$ 期望为 $(2+3+1)/3=2$，$\\mathrm{dist}(2,4)$ 期望为 $(1+2+2)/3=5/3\\equiv 666666673\\pmod{10^9+7}$，$\\mathrm{dist}(3,4)$ 期望为 $(1+1+1)/3=1$。\n\n#### 样例 2 解释\n\n仅有一种可能的子序列 $4,6,5,2$，对应的树为一条链 $1-4-5-2-6-3$，$1,2,3,4,5$ 与 $6$ 的距离依次为 $4,1,1,3,2$，即为答案。\n\n#### 数据范围\n\n本题共 $20$ 个测试点：\n\n|测试点编号|$n$|$m$|\n|:-:|:-:|:-:|\n|$1$|$=4$|$=6$|\n|$2$|$=8$|$=15$|\n|$3$|$=10$|$=20$|\n|$4$|$=10$|$=50$|\n|$5$|$=10$|$=200$|\n|$6$|$=10$|$=1000$|\n|$7$|$=10$|$=1750$|\n|$8$|$=10$|$=2500$|\n|$9$|$=11$|$=500$|\n|$10$|$=11$|$=1000$|\n|$11$|$=12$|$=250$|\n|$12$|$=12$|$=375$|\n|$13$|$=12$|$=400$|\n|$14$|$=13$|$=80$|\n|$15$|$=13$|$=120$|\n|$16$|$=13$|$=160$|\n|$17$|$=13$|$=200$|\n|$18$|$=14$|$=60$|\n|$19$|$=14$|$=90$|\n|$20$|$=15$|$=40$|\n\n另外，对于所有数据，保证 $1\\le a_i\\le n$。\n\n**请注意，前 $19$ 个测试点空间限制为 $512\\rm{MB}$，最后一个点空间限制为 $150\\rm{MB}$。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[YsOI2023] Prüfer 序列", "background": "Ysuperman 模板测试的计数题。\n\n众所周知，Prüfer 序列几乎没有在正赛中出现过，所以它需要出现在洛谷月赛中。", "description": "众所周知，一棵 $n$ 个点的有标号无根树与他的 Prüfer 序列一一对应。如果你不知道 Prüfer 序列指的是什么，可以参考下面提示说明中对 Prüfer 序列的解释。\n\n现在给你一个长度为 $m$ 的正整数序列 $a$，其中 $a_i\\in[1,n]$。等概率随机选择这个序列的一个长度为 $n-2$ 的子序列（只要选择下标不同就认为两个子序列不同）作为 Prüfer 序列构造得到一棵树 $T$，对于所有 $1\\le i<n$，你需要求出 $\\mathrm{dist}(i,n)$ 的期望（$\\mathrm{dist}(u,v)$ 定义为 $u,v$ 两点简单路径的边数）。\n\n答案对 $10^9+7$ 取模。", "inputFormat": "输入第一行两个正整数 $n,m$。\n\n第二行 $m$ 个整数表示序列 $a$，保证 $1\\le a_i\\le n$。", "outputFormat": "输出 $n-1$ 个非负整数，第 $i$ 个整数表示 $\\mathrm{dist}(i,n)$ 的期望。", "hint": "#### 对 Prüfer 序列的解释\n\n对于一棵给定的无根有标号树，Prüfer 序列的构建过程如下：每次选择一个编号最小的叶结点并删掉它，然后在序列中记录下它连接到的那个结点，重复 $n-2$ 次后就只剩下两个结点，此时记录下来的那个序列就是这棵无根有标号树的 Prüfer 序列。\n\n我们可以证明，一棵结点数量大于 $1$ 的无根有标号树和一个 Prüfer 序列是一一对应的，并且任意一个长度为 $n-2$ 每个数取 $[1,n]$ 范围内的整数的 Prüfer 序列都有唯一对应它的树，所以同样的，我们也可以根据一个 Prüfer 序列还原出一棵树。\n\n有关 Prüfer 序列更加详细的内容，你可以参考 [OI wiki 上关于 Prüfer 序列的描述](https://oi-wiki.org/graph/prufer/)。\n\n#### 样例 1 解释\n\n共有三种等可能选择的子序列：$2,4$，$2,3$，$4,3$。\n\n1. $2,4$ 对应的树为一条链 $1-2-4-3$，其中 $1,2,3$ 与 $4$ 的距离分别为 $2,1,1$。\n2. $2,3$ 对应的树为一条链 $1-2-3-4$，其中 $1,2,3$ 与 $4$ 的距离分别为 $3,2,1$。\n3. $4,3$ 对应的树为一条链 $1-4-3-2$，其中 $1,2,3$ 与 $4$ 的距离分别为 $1,2,1$。\n\n所以 $\\mathrm{dist}(1,4)$ 期望为 $(2+3+1)/3=2$，$\\mathrm{dist}(2,4)$ 期望为 $(1+2+2)/3=5/3\\equiv 666666673\\pmod{10^9+7}$，$\\mathrm{dist}(3,4)$ 期望为 $(1+1+1)/3=1$。\n\n#### 样例 2 解释\n\n仅有一种可能的子序列 $4,6,5,2$，对应的树为一条链 $1-4-5-2-6-3$，$1,2,3,4,5$ 与 $6$ 的距离依次为 $4,1,1,3,2$，即为答案。\n\n#### 数据范围\n\n本题共 $20$ 个测试点：\n\n|测试点编号|$n$|$m$|\n|:-:|:-:|:-:|\n|$1$|$=4$|$=6$|\n|$2$|$=8$|$=15$|\n|$3$|$=10$|$=20$|\n|$4$|$=10$|$=50$|\n|$5$|$=10$|$=200$|\n|$6$|$=10$|$=1000$|\n|$7$|$=10$|$=1750$|\n|$8$|$=10$|$=2500$|\n|$9$|$=11$|$=500$|\n|$10$|$=11$|$=1000$|\n|$11$|$=12$|$=250$|\n|$12$|$=12$|$=375$|\n|$13$|$=12$|$=400$|\n|$14$|$=13$|$=80$|\n|$15$|$=13$|$=120$|\n|$16$|$=13$|$=160$|\n|$17$|$=13$|$=200$|\n|$18$|$=14$|$=60$|\n|$19$|$=14$|$=90$|\n|$20$|$=15$|$=40$|\n\n另外，对于所有数据，保证 $1\\le a_i\\le n$。\n\n**请注意，前 $19$ 个测试点空间限制为 $512\\rm{MB}$，最后一个点空间限制为 $150\\rm{MB}$。**", "locale": "zh-CN"}}}
{"pid": "P9537", "type": "P", "difficulty": 7, "samples": [["3\n1 2 3\n", "15"], ["5\n6 8 10 17 19\n", "378"], ["9\n2 3 4 6 7 8 12 16 18\n", "106533"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["博弈论", "洛谷原创", "O2优化", "洛谷月赛"], "title": "[YsOI2023] Qingshan and Daniel 2", "background": "Ysuperman 模板测试的博弈论题。\n\n都什么年代了，还在玩传统对称博弈，快来玩玩非传统非对称博弈。\n\n猜猜题目名称啥意思，没错就是要你快去做 CF1764B！！！另外这题融合了 CF1495、CF1707、CF1764 的梗（）", "description": "今天 Ysuperman 发现了一款非对称博弈游戏，名字叫做 Bugaboo，具体规则如下：\n\n> 在游戏的一开始，Qingshan 手中有一个正整数集 $S$，Daniel 手中有一个正整数集 $T$。\n>\n> Qingshan 和 Daniel 依次如下操作（Qingshan 先手）：选择在自己数集中的任意两个**不同的**数字 $x,y$，并且还需要满足 $|x-y|$ 不属于**对方的数集**，然后将 $|x-y|$ 加入**对方的数集**。最终无法操作的人失败。\n>\n> 可以注意到在游戏的进行过程中一个人手中的数集是会不断变化的，他在选择数字 $x,y$ 时既可以选择初始自己拥有的数字，也可以选择后面新增的数字。\n\n现在 Ysuperman 给了你一个正整数集 $R$，Ysuperman 想要知道如果 Qingshan 一开始拥有的集合 $S$ 是 $R$ 的 $2^{|R|}$ 个子集中的任意一个，而 Daniel 一开始拥有的集合 $T$ 也是 $R$ 的 $2^{|R|}$ 个子集中的任意一个，那么在多少种情况下 Qingshan 会赢。\n\n由于答案可能很大， Ysuperman 不想为难你，于是只要你求出答案对 $998,244,353$ 取模后的结果。", "inputFormat": "第一行一个整数 $n$ 表示集合 $R$ 的大小。\n\n接下来一行 $n$ 个整数 $a_1,a_2,\\dots,a_n$ 表示集合 $R$ 中的所有数。", "outputFormat": "输出一行一个数表示答案对 $998,244,353$ 取模后的结果。", "hint": "#### 样例 1 解释\n\n对于第一组样例，显然 Qingshan 要赢的一个必要条件是她一开始的集合有至少两个数：\n\n1. 当 $S=\\{1,2\\}$ 时，Qingshan 赢当 $T=\\{\\},\\{2\\},\\{3\\},\\{2,3\\}$。\n1. 当 $S=\\{1,3\\}$ 时，Qingshan 赢当 $T=\\{\\},\\{1\\},\\{3\\}$。\n1. 当 $S=\\{2,3\\}$ 时，Qingshan 赢当 $T=\\{\\},\\{3\\}$。\n1. 当 $S=\\{1,2,3\\}$ 时，Qingshan 赢当 $T=\\{\\},\\{1\\},\\{2\\},\\{3\\},\\{1,3\\},\\{2,3\\}$。\n\n所以答案为 $4+3+2+6=15$。\n\n#### 数据范围\n\n对于 $15\\%$ 的数据，有 $a_i\\le 10$。\n\n对于 $30\\%$ 的数据，有 $n\\le 10$。\n\n对于 $50\\%$ 的数据，有 $a_i\\le 1000$。\n\n对于 $70\\%$ 的数据，有 $n\\le 1000$。\n\n对于 $100\\%$ 的数据，有 $1\\le n\\le 20000$，$1\\le a_1<a_2<\\cdots<a_n\\le 20000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[YsOI2023] Qingshan and Daniel 2", "background": "Ysuperman 模板测试的博弈论题。\n\n都什么年代了，还在玩传统对称博弈，快来玩玩非传统非对称博弈。\n\n猜猜题目名称啥意思，没错就是要你快去做 CF1764B！！！另外这题融合了 CF1495、CF1707、CF1764 的梗（）", "description": "今天 Ysuperman 发现了一款非对称博弈游戏，名字叫做 Bugaboo，具体规则如下：\n\n> 在游戏的一开始，Qingshan 手中有一个正整数集 $S$，Daniel 手中有一个正整数集 $T$。\n>\n> Qingshan 和 Daniel 依次如下操作（Qingshan 先手）：选择在自己数集中的任意两个**不同的**数字 $x,y$，并且还需要满足 $|x-y|$ 不属于**对方的数集**，然后将 $|x-y|$ 加入**对方的数集**。最终无法操作的人失败。\n>\n> 可以注意到在游戏的进行过程中一个人手中的数集是会不断变化的，他在选择数字 $x,y$ 时既可以选择初始自己拥有的数字，也可以选择后面新增的数字。\n\n现在 Ysuperman 给了你一个正整数集 $R$，Ysuperman 想要知道如果 Qingshan 一开始拥有的集合 $S$ 是 $R$ 的 $2^{|R|}$ 个子集中的任意一个，而 Daniel 一开始拥有的集合 $T$ 也是 $R$ 的 $2^{|R|}$ 个子集中的任意一个，那么在多少种情况下 Qingshan 会赢。\n\n由于答案可能很大， Ysuperman 不想为难你，于是只要你求出答案对 $998,244,353$ 取模后的结果。", "inputFormat": "第一行一个整数 $n$ 表示集合 $R$ 的大小。\n\n接下来一行 $n$ 个整数 $a_1,a_2,\\dots,a_n$ 表示集合 $R$ 中的所有数。", "outputFormat": "输出一行一个数表示答案对 $998,244,353$ 取模后的结果。", "hint": "#### 样例 1 解释\n\n对于第一组样例，显然 Qingshan 要赢的一个必要条件是她一开始的集合有至少两个数：\n\n1. 当 $S=\\{1,2\\}$ 时，Qingshan 赢当 $T=\\{\\},\\{2\\},\\{3\\},\\{2,3\\}$。\n1. 当 $S=\\{1,3\\}$ 时，Qingshan 赢当 $T=\\{\\},\\{1\\},\\{3\\}$。\n1. 当 $S=\\{2,3\\}$ 时，Qingshan 赢当 $T=\\{\\},\\{3\\}$。\n1. 当 $S=\\{1,2,3\\}$ 时，Qingshan 赢当 $T=\\{\\},\\{1\\},\\{2\\},\\{3\\},\\{1,3\\},\\{2,3\\}$。\n\n所以答案为 $4+3+2+6=15$。\n\n#### 数据范围\n\n对于 $15\\%$ 的数据，有 $a_i\\le 10$。\n\n对于 $30\\%$ 的数据，有 $n\\le 10$。\n\n对于 $50\\%$ 的数据，有 $a_i\\le 1000$。\n\n对于 $70\\%$ 的数据，有 $n\\le 1000$。\n\n对于 $100\\%$ 的数据，有 $1\\le n\\le 20000$，$1\\le a_1<a_2<\\cdots<a_n\\le 20000$。", "locale": "zh-CN"}}}
{"pid": "P9538", "type": "P", "difficulty": 2, "samples": [["4\n33\n2023\n10\n0", "8\n18\n9\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": [], "title": "「AWOI Round 2 A」最大和", "background": "", "description": "给你一个整数 $n$，你需要对这个数进行 $m$ 次操作。其中 $m$ 为当前需要操作的数的位数（默认自然数 $0$ 是一位数），且**可能随着 $n$ 的改变而改变**。\n\n第 $i$ $(1\\leqslant i \\leqslant m)$ 次操作有以下三种选择：\n\n1. $n\\gets n+10^{i-1}$。\n2. $n\\gets n-10^{i-1}$。\n3. $n$ 不变。\n\n要求最大化操作后的各个数位上数字之和。", "inputFormat": "本题一个测试点中含有多组测试数据。\n\n第一行一个正整数 $T$，代表有 $T$ 组数据。\n\n接下来的 $T$ 行，每行包含一个整数 $n$。", "outputFormat": "共 $T$ 行，每行一个整数，表示每组数据的 $n$ 经操作后最大的各个数位上数字之和。", "hint": "**【样例解释】**\n- 对于 $33$，每次操作都选择操作 $1$，得到最大值 $4+4=8$。\n- 对于 $2023$，第一、二、四次操作都选择操作 $1$，第三次操作选择操作 $2$，得到 $2+9+3+4 = 18$。\n- 对于 $10$，选择操作 $2$，得到 $9$，此时 $m$ 变为 $1$。因为已经操作了一次，所以不再操作。\n- 对于 $0$，选择操作 $1$ 即可。\n\n**【数据范围】**\n\n对于 $30\\%$ 的数据，$1 \\leqslant T \n\\leqslant10^4$，$0 \\leqslant n \\leqslant 10^4$。\n\n对于 $100\\%$ 的数据，$1 \\leqslant T \\leqslant 10^5$，$0 \\leqslant n \\leqslant 10^9$。\n\n**【工作人员】**\n\n| $\\text{Idea}$ | $\\text{Data}$ | $\\text{Check}$ | $\\text{Solution}$ |\n| :----------: | :----------: | :----------: | :----------: | \n| [S__X](/user/310466) | [S__X](/user/310466)|  [y_kx_b](/user/592895) | [S__X](/user/310466) | ", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「AWOI Round 2 A」最大和", "background": "", "description": "给你一个整数 $n$，你需要对这个数进行 $m$ 次操作。其中 $m$ 为当前需要操作的数的位数（默认自然数 $0$ 是一位数），且**可能随着 $n$ 的改变而改变**。\n\n第 $i$ $(1\\leqslant i \\leqslant m)$ 次操作有以下三种选择：\n\n1. $n\\gets n+10^{i-1}$。\n2. $n\\gets n-10^{i-1}$。\n3. $n$ 不变。\n\n要求最大化操作后的各个数位上数字之和。", "inputFormat": "本题一个测试点中含有多组测试数据。\n\n第一行一个正整数 $T$，代表有 $T$ 组数据。\n\n接下来的 $T$ 行，每行包含一个整数 $n$。", "outputFormat": "共 $T$ 行，每行一个整数，表示每组数据的 $n$ 经操作后最大的各个数位上数字之和。", "hint": "**【样例解释】**\n- 对于 $33$，每次操作都选择操作 $1$，得到最大值 $4+4=8$。\n- 对于 $2023$，第一、二、四次操作都选择操作 $1$，第三次操作选择操作 $2$，得到 $2+9+3+4 = 18$。\n- 对于 $10$，选择操作 $2$，得到 $9$，此时 $m$ 变为 $1$。因为已经操作了一次，所以不再操作。\n- 对于 $0$，选择操作 $1$ 即可。\n\n**【数据范围】**\n\n对于 $30\\%$ 的数据，$1 \\leqslant T \n\\leqslant10^4$，$0 \\leqslant n \\leqslant 10^4$。\n\n对于 $100\\%$ 的数据，$1 \\leqslant T \\leqslant 10^5$，$0 \\leqslant n \\leqslant 10^9$。\n\n**【工作人员】**\n\n| $\\text{Idea}$ | $\\text{Data}$ | $\\text{Check}$ | $\\text{Solution}$ |\n| :----------: | :----------: | :----------: | :----------: | \n| [S__X](/user/310466) | [S__X](/user/310466)|  [y_kx_b](/user/592895) | [S__X](/user/310466) | ", "locale": "zh-CN"}}}
