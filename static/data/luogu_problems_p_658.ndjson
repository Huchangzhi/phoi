{"pid": "P14339", "type": "P", "difficulty": 5, "samples": [["11\nS+?-(R+?)*P\nS", "6"], ["15\n?+?-?*?+?-?*?+?\nR", "2187"], ["13\n(((((R)))))+?\nP", "1"], ["1\nP\nS", "0"], ["27\nR+((?+S-?*P+?)-P*?+S-?)*R+?\nP", "381"], ["83\n((R+?)*(?+?))*((?+?)*(?+?))*((?+?)*(?+?))-((S+?)*(?+?))*((?+?)*(?+?))*((?+?)*(?+?))\nP", "460353133"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2019", "栈", "JOI（日本）"], "title": "[JOI2020 预选赛 R2] 剪刀石头布 / Rock-Scissors-Paper Expression", "background": "", "description": "本题中，将剪刀石头布中的“石头”“剪刀”“布”分别用 $ R $、$ S $、$ P $ 表示。规则为：$ R $ 胜 $ S $，$ S $ 胜 $ P $，$ P $ 胜 $ R $。\n\n当 $ x $、$ y $ 为剪刀石头布的手势时，定义 $ x + y $、$ x - y $、$ x * y $ 如下（注意：这些运算并非通常意义下的加法、减法、乘法）：\n\n- $ x + y $：当 $ x \\ne y $ 时，结果为 $ x $ 与 $ y $ 中的胜者；当 $ x = y $ 时，结果为 $ x $。\n- $ x - y $：当 $ x \\ne y $ 时，结果为 $ x $ 与 $ y $ 中的败者；当 $ x = y $ 时，结果为 $ x $。\n- $ x * y $：当 $ x \\ne y $ 时，结果为 $ R $、$ S $、$ P $ 中既不是 $ x $ 也不是 $ y $ 的那个手势；当 $ x = y $ 时，结果为 $ x $。\n\n由剪刀石头布手势与 $ + $、$ - $、$ * $ 以及括号组成的表达式，按以下规则计算：\n\n- 先计算括号内的表达式。例如，$ R * (P + S) = R * S = P $。\n- 对于相同层级的括号部分：\n  - 优先计算 $ * $，再计算 $ + $ 和 $ - $。例如，$ R - P * S = R - (P * S) = R - R = R $。\n  - 对于优先级相同的运算符（如 $ + $ 与 $ + $、$ - $ 与 $ - $、$ + $ 与 $ - $、$ * $ 与 $ * $），按从左到右的顺序计算。例如，$ R - P + S = (R - P) + S = R + S = R $。\n\nJOI 先生原本持有一个剪刀石头布表达式，但其中部分 $ R $、$ S $、$ P $ 已经看不清了。已知看不清的部分由字符 `?` 表示，且整个表达式长度为 $ N $。JOI 先生想知道，将每个 `?` 替换为 $ R $、$ S $、$ P $ 中的任意一个手势，有多少种替换方式能使整个表达式的计算结果等于给定值 $ A $。由于该数目可能非常大，因此要求输出其对 $ 1\\,000\\,000\\,007 $ 取模的结果。\n\n本题所用的文法采用 BNF（巴科斯-瑙尔范式），定义如下。其中，表达式中看不清的部分用 `<expression>` 表示：\n\n```\n<expression> ::= <term> | <expression> \"+\" <term> | <expression> \"-\" <term>\n<term> ::= <factor> | <term> \"*\" <factor>\n<factor> ::= \"R\" | \"S\" | \"P\" | \"?\" | \"(\" <expression> \")\"\n```\n\n以上文法的含义是：一个字符串是 `<expression>`，当且仅当它是一个 `<term>`，或是一个 `<expression>`、字符 `+`、一个 `<term>` 按顺序连接而成，或是一个 `<expression>`、字符 `-`、一个 `<term>` 按顺序连接而成。这是一种递归定义。\n\n给定一个长度为 $ N $ 的字符串 $ E $（其中包含若干 `?`），以及目标结果 $ A $，请编写程序，计算将每个 `?` 替换为 $ R $、$ S $、$ P $ 中的任意一个手势后，能使表达式计算结果为 $ A $ 的替换方案总数，并输出该总数对 $ 1\\,000\\,000\\,007 $ 取模的结果。", "inputFormat": "输入通过标准输入以如下格式给出：\n\n$ N $\n\n$ E $\n\n$ A $", "outputFormat": "在标准输出中，输出一行，表示将每个 `?` 替换为 $ R $、$ S $、$ P $ 中的任意一个手势后，能使表达式计算结果等于 $ A $ 的方案总数，对 $ 1\\,000\\,000\\,007 $ 取模的结果。\n", "hint": "### 样例 1 解释\n\n将两个 `?` 分别替换为 $ R $、$ S $、$ P $ 中的任意一个手势，使得表达式计算结果为 $ S $ 的方法共有以下 6 种：\n\n- $ S + R - (R + R) * P $\n- $ S + R - (R + S) * P $\n- $ S + S - (R + R) * P $\n- $ S + S - (R + S) * P $\n- $ S + P - (R + R) * P $\n- $ S + P - (R + S) * P $\n\n### 数据范围\n\n- $ 1 \\le N \\le 200\\,000 $。\n- $ E $ 是长度为 $ N $ 的字符串。\n- $ E $ 是题目中定义的 `<expression>`。\n- $ A $ 是字符 `'R'`、`'S'` 或 `'P'` 之一。\n\n### 子任务\n\n1. （20 分）$ N \\le 15 $。\n2. （20 分）$ N \\le 200 $。\n3. （60 分）无额外限制。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOI2020 预选赛 R2] 剪刀石头布 / Rock-Scissors-Paper Expression", "background": "", "description": "本题中，将剪刀石头布中的“石头”“剪刀”“布”分别用 $ R $、$ S $、$ P $ 表示。规则为：$ R $ 胜 $ S $，$ S $ 胜 $ P $，$ P $ 胜 $ R $。\n\n当 $ x $、$ y $ 为剪刀石头布的手势时，定义 $ x + y $、$ x - y $、$ x * y $ 如下（注意：这些运算并非通常意义下的加法、减法、乘法）：\n\n- $ x + y $：当 $ x \\ne y $ 时，结果为 $ x $ 与 $ y $ 中的胜者；当 $ x = y $ 时，结果为 $ x $。\n- $ x - y $：当 $ x \\ne y $ 时，结果为 $ x $ 与 $ y $ 中的败者；当 $ x = y $ 时，结果为 $ x $。\n- $ x * y $：当 $ x \\ne y $ 时，结果为 $ R $、$ S $、$ P $ 中既不是 $ x $ 也不是 $ y $ 的那个手势；当 $ x = y $ 时，结果为 $ x $。\n\n由剪刀石头布手势与 $ + $、$ - $、$ * $ 以及括号组成的表达式，按以下规则计算：\n\n- 先计算括号内的表达式。例如，$ R * (P + S) = R * S = P $。\n- 对于相同层级的括号部分：\n  - 优先计算 $ * $，再计算 $ + $ 和 $ - $。例如，$ R - P * S = R - (P * S) = R - R = R $。\n  - 对于优先级相同的运算符（如 $ + $ 与 $ + $、$ - $ 与 $ - $、$ + $ 与 $ - $、$ * $ 与 $ * $），按从左到右的顺序计算。例如，$ R - P + S = (R - P) + S = R + S = R $。\n\nJOI 先生原本持有一个剪刀石头布表达式，但其中部分 $ R $、$ S $、$ P $ 已经看不清了。已知看不清的部分由字符 `?` 表示，且整个表达式长度为 $ N $。JOI 先生想知道，将每个 `?` 替换为 $ R $、$ S $、$ P $ 中的任意一个手势，有多少种替换方式能使整个表达式的计算结果等于给定值 $ A $。由于该数目可能非常大，因此要求输出其对 $ 1\\,000\\,000\\,007 $ 取模的结果。\n\n本题所用的文法采用 BNF（巴科斯-瑙尔范式），定义如下。其中，表达式中看不清的部分用 `<expression>` 表示：\n\n```\n<expression> ::= <term> | <expression> \"+\" <term> | <expression> \"-\" <term>\n<term> ::= <factor> | <term> \"*\" <factor>\n<factor> ::= \"R\" | \"S\" | \"P\" | \"?\" | \"(\" <expression> \")\"\n```\n\n以上文法的含义是：一个字符串是 `<expression>`，当且仅当它是一个 `<term>`，或是一个 `<expression>`、字符 `+`、一个 `<term>` 按顺序连接而成，或是一个 `<expression>`、字符 `-`、一个 `<term>` 按顺序连接而成。这是一种递归定义。\n\n给定一个长度为 $ N $ 的字符串 $ E $（其中包含若干 `?`），以及目标结果 $ A $，请编写程序，计算将每个 `?` 替换为 $ R $、$ S $、$ P $ 中的任意一个手势后，能使表达式计算结果为 $ A $ 的替换方案总数，并输出该总数对 $ 1\\,000\\,000\\,007 $ 取模的结果。", "inputFormat": "输入通过标准输入以如下格式给出：\n\n$ N $\n\n$ E $\n\n$ A $", "outputFormat": "在标准输出中，输出一行，表示将每个 `?` 替换为 $ R $、$ S $、$ P $ 中的任意一个手势后，能使表达式计算结果等于 $ A $ 的方案总数，对 $ 1\\,000\\,000\\,007 $ 取模的结果。\n", "hint": "### 样例 1 解释\n\n将两个 `?` 分别替换为 $ R $、$ S $、$ P $ 中的任意一个手势，使得表达式计算结果为 $ S $ 的方法共有以下 6 种：\n\n- $ S + R - (R + R) * P $\n- $ S + R - (R + S) * P $\n- $ S + S - (R + R) * P $\n- $ S + S - (R + S) * P $\n- $ S + P - (R + R) * P $\n- $ S + P - (R + S) * P $\n\n### 数据范围\n\n- $ 1 \\le N \\le 200\\,000 $。\n- $ E $ 是长度为 $ N $ 的字符串。\n- $ E $ 是题目中定义的 `<expression>`。\n- $ A $ 是字符 `'R'`、`'S'` 或 `'P'` 之一。\n\n### 子任务\n\n1. （20 分）$ N \\le 15 $。\n2. （20 分）$ N \\le 200 $。\n3. （60 分）无额外限制。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN"}}}
{"pid": "P14340", "type": "P", "difficulty": 6, "samples": [["5 4\n35 100\n70 70\n45 15\n80 40\n20 95\n20 50 120\n10 10 100\n60 60 80\n0 100 100", "2\n4\n1\n1"], ["10 10\n41304 98327\n91921 28251\n85635 59191\n30361 72671\n28949 96958\n99041 37826\n10245 2726\n19387 20282\n60366 87723\n95388 49726\n52302 69501 66009\n43754 45346 3158\n25224 58881 18727\n7298 24412 63782\n24107 10583 61508\n65025 29140 7278\n36104 56758 2775\n23126 67608 122051\n56910 17272 62933\n39675 15874 117117", "1\n3\n5\n8\n8\n3\n3\n3\n5\n6"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "树状数组", "cdq 分治", "扫描线", "离线处理", "JOISC/JOIST（日本）"], "title": "[JOISC 2019] 考试 / Examination", "background": "", "description": "$N$ 名学生参加了一场考试，考试包含数学和信息学两个部分。第 $i$ 名学生（$1 \\le i \\le N$）在数学部分得了 $S_i$ 分，在信息学部分得了 $T_i$ 分。T 教授和 I 教授将根据分数决定每名学生是否通过考试。\n\n- T 教授认为两门科目都重要；他希望数学得分至少为 $A$ 分且信息学得分至少为 $B$ 分的学生才能通过。\n- I 教授只关心总分；他希望总分至少为 $C$ 分的学生才能通过。\n- 只有两位教授都希望其通过的学生才能通过考试。\n\n你不知道这些标准的具体数值：即 $A$、$B$ 和 $C$ 的值。相反，给定 $Q$ 组整数三元组 $(X_j, Y_j, Z_j)$（$1 \\le j \\le Q$），你希望知道当 $A = X_j$、$B = Y_j$、$C = Z_j$ 时，通过考试的学生人数。\n\n编写一个程序，输入学生人数、每名学生的分数以及一些标准，计算在每组标准下通过考试的学生人数。", "inputFormat": "从标准输入读取以下数据。输入中的所有值均为整数。\n\n$N\\ Q$\n\n$S_1\\ T_1$\n\n$\\vdots$\n\n$S_N\\ T_N$\n\n$X_1\\ Y_1\\ Z_1$\n\n$\\vdots$\n\n$X_Q\\ Y_Q\\ Z_Q$", "outputFormat": "向标准输出写入 $Q$ 行。第 $j$ 行（$1 \\le j \\le Q$）应包含当 $A = X_j$、$B = Y_j$、$C = Z_j$ 时通过考试的学生人数。\n", "hint": "### 样例 1 解释\n\n- 当 $A = 20$、$B = 50$ 且 $C = 120$ 时，只有第 1 名和第 2 名学生能在数学中至少得 20 分，在信息学中至少得 50 分，且总分至少为 120 分。因此，通过考试的学生人数为 2。\n- 当 $A = 10$、$B = 10$ 且 $C = 100$ 时，只有第 1 名、第 2 名、第 4 名和第 5 名学生能在数学中至少得 10 分，在信息学中至少得 10 分，且总分至少为 100 分。因此，通过考试的学生人数为 4。\n- 当 $A = 60$、$B = 60$ 且 $C = 80$ 时，只有第 2 名学生能在数学中至少得 60 分，在信息学中至少得 60 分，且总分至少为 80 分。因此，通过考试的学生人数为 1。\n- 当 $A = 0$、$B = 100$ 且 $C = 100$ 时，只有第 1 名学生能在数学中至少得 0 分，在信息学中至少得 100 分，且总分至少为 100 分。因此，通过考试的学生人数为 1。\n\n### 数据范围\n\n- $1 \\le N \\le 100\\,000$。\n- $1 \\le Q \\le 100\\,000$。\n- $0 \\le S_i \\le 1\\,000\\,000\\,000$（$1 \\le i \\le N$）。\n- $0 \\le T_i \\le 1\\,000\\,000\\,000$（$1 \\le i \\le N$）。\n- $0 \\le X_j \\le 1\\,000\\,000\\,000$（$1 \\le j \\le Q$）。\n- $0 \\le Y_j \\le 1\\,000\\,000\\,000$（$1 \\le j \\le Q$）。\n- $0 \\le Z_j \\le 2\\,000\\,000\\,000$（$1 \\le j \\le Q$）。\n\n### 子任务\n\n1. （2 分）$N \\le 3\\,000$，$Q \\le 3\\,000$。\n2. （20 分）$S_i \\le 100\\,000$，$T_i \\le 100\\,000$（$1 \\le i \\le N$），$X_j \\le 100\\,000$，$Y_j \\le 100\\,000$，$Z_j = 0$（$1 \\le j \\le Q$）。\n3. （21 分）$S_i \\le 100\\,000$，$T_i \\le 100\\,000$（$1 \\le i \\le N$），$X_j \\le 100\\,000$，$Y_j \\le 100\\,000$，$Z_j \\le 200\\,000$（$1 \\le j \\le Q$）。\n4. （57 分）无额外约束。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2019] 考试 / Examination", "background": "", "description": "$N$ 名学生参加了一场考试，考试包含数学和信息学两个部分。第 $i$ 名学生（$1 \\le i \\le N$）在数学部分得了 $S_i$ 分，在信息学部分得了 $T_i$ 分。T 教授和 I 教授将根据分数决定每名学生是否通过考试。\n\n- T 教授认为两门科目都重要；他希望数学得分至少为 $A$ 分且信息学得分至少为 $B$ 分的学生才能通过。\n- I 教授只关心总分；他希望总分至少为 $C$ 分的学生才能通过。\n- 只有两位教授都希望其通过的学生才能通过考试。\n\n你不知道这些标准的具体数值：即 $A$、$B$ 和 $C$ 的值。相反，给定 $Q$ 组整数三元组 $(X_j, Y_j, Z_j)$（$1 \\le j \\le Q$），你希望知道当 $A = X_j$、$B = Y_j$、$C = Z_j$ 时，通过考试的学生人数。\n\n编写一个程序，输入学生人数、每名学生的分数以及一些标准，计算在每组标准下通过考试的学生人数。", "inputFormat": "从标准输入读取以下数据。输入中的所有值均为整数。\n\n$N\\ Q$\n\n$S_1\\ T_1$\n\n$\\vdots$\n\n$S_N\\ T_N$\n\n$X_1\\ Y_1\\ Z_1$\n\n$\\vdots$\n\n$X_Q\\ Y_Q\\ Z_Q$", "outputFormat": "向标准输出写入 $Q$ 行。第 $j$ 行（$1 \\le j \\le Q$）应包含当 $A = X_j$、$B = Y_j$、$C = Z_j$ 时通过考试的学生人数。\n", "hint": "### 样例 1 解释\n\n- 当 $A = 20$、$B = 50$ 且 $C = 120$ 时，只有第 1 名和第 2 名学生能在数学中至少得 20 分，在信息学中至少得 50 分，且总分至少为 120 分。因此，通过考试的学生人数为 2。\n- 当 $A = 10$、$B = 10$ 且 $C = 100$ 时，只有第 1 名、第 2 名、第 4 名和第 5 名学生能在数学中至少得 10 分，在信息学中至少得 10 分，且总分至少为 100 分。因此，通过考试的学生人数为 4。\n- 当 $A = 60$、$B = 60$ 且 $C = 80$ 时，只有第 2 名学生能在数学中至少得 60 分，在信息学中至少得 60 分，且总分至少为 80 分。因此，通过考试的学生人数为 1。\n- 当 $A = 0$、$B = 100$ 且 $C = 100$ 时，只有第 1 名学生能在数学中至少得 0 分，在信息学中至少得 100 分，且总分至少为 100 分。因此，通过考试的学生人数为 1。\n\n### 数据范围\n\n- $1 \\le N \\le 100\\,000$。\n- $1 \\le Q \\le 100\\,000$。\n- $0 \\le S_i \\le 1\\,000\\,000\\,000$（$1 \\le i \\le N$）。\n- $0 \\le T_i \\le 1\\,000\\,000\\,000$（$1 \\le i \\le N$）。\n- $0 \\le X_j \\le 1\\,000\\,000\\,000$（$1 \\le j \\le Q$）。\n- $0 \\le Y_j \\le 1\\,000\\,000\\,000$（$1 \\le j \\le Q$）。\n- $0 \\le Z_j \\le 2\\,000\\,000\\,000$（$1 \\le j \\le Q$）。\n\n### 子任务\n\n1. （2 分）$N \\le 3\\,000$，$Q \\le 3\\,000$。\n2. （20 分）$S_i \\le 100\\,000$，$T_i \\le 100\\,000$（$1 \\le i \\le N$），$X_j \\le 100\\,000$，$Y_j \\le 100\\,000$，$Z_j = 0$（$1 \\le j \\le Q$）。\n3. （21 分）$S_i \\le 100\\,000$，$T_i \\le 100\\,000$（$1 \\le i \\le N$），$X_j \\le 100\\,000$，$Y_j \\le 100\\,000$，$Z_j \\le 200\\,000$（$1 \\le j \\le Q$）。\n4. （57 分）无额外约束。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN"}}}
{"pid": "P14341", "type": "P", "difficulty": 6, "samples": [["5\n0 1\n0 2\n1 3\n1 4", ""]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "交互题", "Special Judge", "随机化", "树的重心", "JOISC/JOIST（日本）"], "title": "[JOISC 2019] 海狸的会面 / Meetings", "background": null, "description": "有 $N$ 个海狸居住的岛屿，编号从 $0$ 到 $N-1$。这些岛屿由 $N-1$ 座双向桥梁连接。可以通过一些桥梁在任意两个岛屿之间通行。对于每个岛屿，最多有 $18$ 座桥梁直接与其相连。每个岛屿上居住着一只海狸。\n\n有时，一些海狸会在某个岛屿上聚集开会。当恰好三只海狸相遇时，它们会在以下岛屿上聚集：\n\n使这三只海狸在聚集过程中经过的桥梁总数最少的岛屿（这样的岛屿是唯一的）。\n\n请注意，该岛屿可能与其中一只海狸所居住的岛屿重合。\n\n你对这 $N$ 个岛屿如何通过桥梁连接感兴趣。你无法直接前往并检查岛屿，因此你将向海狸发出一些指令。每条指令如下：\n\n- 你指定三个岛屿 $u$、$v$ 和 $w$（$0 \\le u \\le N-1$，$0 \\le v \\le N-1$，$0 \\le w \\le N-1$，$u \\ne v$，$u \\ne w$，$v \\ne w$），并让居住在岛屿 $u$、$v$ 和 $w$ 上的海狸召开会议。\n- 然后，你可以看到三只海狸聚集的岛屿。\n\n你希望用尽可能少的指令确定岛屿之间的连接方式。\n\n编写一个程序，在给定岛屿数量并和海狸通信后，确定岛屿之间的连接方式。\n\n### 实现细节\n\n这是一道交互题。你需要实现这一个函数：\n\n- `void Solve(int N)`\n  - 此函数在每个测试用例中被调用且仅调用一次。\n  - 参数 $N$ 表示岛屿的数量 $N$。\n\n你的程序可以调用以下函数：\n\n- `int Query(int u, int v, int w)`\n  - 此函数返回你指定的三个岛屿索引所对应的海狸聚集开会的岛屿的索引。\n  - 你通过参数 $u$、$v$ 和 $w$ 分别指定三个岛屿的索引。这些值必须满足 $0 \\le u \\le N-1$、$0 \\le v \\le N-1$、$0 \\le w \\le N-1$，且 $u \\ne v$、$u \\ne w$、$v \\ne w$。否则，你的程序将被视为 **Wrong Answer [1]**。\n  - 函数 `Query` 的调用次数不得超过 $100\\,000$ 次。否则，你的程序将被视为 **Wrong Answer [2]**。\n\n- `void Bridge(int u, int v)`\n\n  - 使用此函数，你需回答岛屿之间如何通过桥梁连接。\n  - 参数 $u$ 和 $v$ 表示岛屿 $u$ 和 $v$ 通过一座桥梁直接相连。\n  - 若 $0 \\le u < v \\le N-1$ 不成立，你的程序将被视为 **Wrong Answer [3]**。\n  - 若岛屿 $u$ 和 $v$ 并未通过桥梁直接相连，你的程序将被视为 **Wrong Answer [4]**。\n  - 若函数 `Bridge` 以相同的参数 $u$ 和 $v$ 被多次调用，你的程序将被视为 **Wrong Answer [5]**。\n  - 由于共有 $N-1$ 座桥梁，函数 `Bridge` 必须被调用恰好 $N-1$ 次。若在函数 `Solve` 执行结束时，对函数 `Bridge` 的调用次数不等于 $N-1$，你的程序将被视为 **Wrong Answer [6]**。\n\n### 编译与测试运行\n\n示例评测器是文件 `grader.cpp`。为了测试你的程序，请将 `grader.cpp`、`meetings.cpp` 和 `meetings.h` 放在同一目录下，并运行以下命令来编译你的程序：\n\n```\ng++ -std=gnu++14 -O2 -o grader grader.cpp meetings.cpp\n```\n\n当编译成功时，将生成可执行文件 `grader`。\n\n**请注意，在洛谷上提交代码时，不应引入头文件 meetings.h**，而是应当加入这两行代码，并且选择不低于 C++17 的语言版本提交：\n\n```cpp\nint Query(int u, int v, int w);\nvoid Bridge(int u, int v);\n```", "inputFormat": "示例评测器从标准输入读取以下数据：\n\n$N$\n\n$A_0\\ B_0$\n\n$\\vdots$\n\n$A_{N-2}\\ B_{N-2}$\n\n其中，$A_i$ 和 $B_i$（$0 \\le i \\le N-2$）表示岛屿 $A_i$ 和 $B_i$ 通过一座桥梁直接相连。", "outputFormat": "当程序成功终止时，示例评测器将以下信息写入标准输出（引号仅用于清晰说明）：\n\n- 若你的程序被视为正确，它将输出函数 `Query` 的调用次数，格式为 “Accepted: 100”。\n- 若你的程序被视为 **Wrong Answer**，它将输出其类型，格式为 “Wrong Answer [1]”。\n\n若你的程序被判定为多种类型的 **Wrong Answer**，示例评测器仅报告其中一种。", "hint": "### 样例 1 解释\n\n| 调用 | 调用 | 返回值 |\n|:-:|:-:|:-:|\n| Solve(5)  |   |   |\n|   | Query(0, 1, 2) | 0 |\n|   | Query(0, 3, 4) | 1 |\n|   | Bridge(1, 3) |   |\n|   | Bridge(0, 2) |   |\n|   | Bridge(1, 4) |   |\n|   | Bridge(0, 1) |   |\n\n### 数据范围\n\n有关 $A_i$ 和 $B_i$ 的定义，请参阅“示例评测器的输入”部分。\n\n- $3 \\le N \\le 2000$。\n- $0 \\le A_i < B_i \\le N-1$（$0 \\le i \\le N-2$）。\n- 可以通过若干座桥梁在任意两个岛屿之间通行。\n- 对于每个岛屿，最多有 $18$ 座桥梁直接与其相连。\n\n### 子任务\n\n1. （7 分）$N\\le7$。\n2. （10 分）$N\\le50$。\n3. （12 分）$N\\le300$。\n4. （71 分）没有额外的约束。\n\n- 对于子任务 1,2,3，如果您的程序对于子任务中的所有测试用例都是正确的，那么您将得到完整的测试用例得分。\n- 对于子任务 4，如果您的程序对于所有测试用例都是正确的，那么您的分数将如下所示，其中 $X$ 是针对测试用例调用 `Query` 函数的最大次数。\n  - 49 分当 $40000<X\\le100000$，\n  - 71 分当 $X\\le40000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2019] 海狸的会面 / Meetings", "background": null, "description": "有 $N$ 个海狸居住的岛屿，编号从 $0$ 到 $N-1$。这些岛屿由 $N-1$ 座双向桥梁连接。可以通过一些桥梁在任意两个岛屿之间通行。对于每个岛屿，最多有 $18$ 座桥梁直接与其相连。每个岛屿上居住着一只海狸。\n\n有时，一些海狸会在某个岛屿上聚集开会。当恰好三只海狸相遇时，它们会在以下岛屿上聚集：\n\n使这三只海狸在聚集过程中经过的桥梁总数最少的岛屿（这样的岛屿是唯一的）。\n\n请注意，该岛屿可能与其中一只海狸所居住的岛屿重合。\n\n你对这 $N$ 个岛屿如何通过桥梁连接感兴趣。你无法直接前往并检查岛屿，因此你将向海狸发出一些指令。每条指令如下：\n\n- 你指定三个岛屿 $u$、$v$ 和 $w$（$0 \\le u \\le N-1$，$0 \\le v \\le N-1$，$0 \\le w \\le N-1$，$u \\ne v$，$u \\ne w$，$v \\ne w$），并让居住在岛屿 $u$、$v$ 和 $w$ 上的海狸召开会议。\n- 然后，你可以看到三只海狸聚集的岛屿。\n\n你希望用尽可能少的指令确定岛屿之间的连接方式。\n\n编写一个程序，在给定岛屿数量并和海狸通信后，确定岛屿之间的连接方式。\n\n### 实现细节\n\n这是一道交互题。你需要实现这一个函数：\n\n- `void Solve(int N)`\n  - 此函数在每个测试用例中被调用且仅调用一次。\n  - 参数 $N$ 表示岛屿的数量 $N$。\n\n你的程序可以调用以下函数：\n\n- `int Query(int u, int v, int w)`\n  - 此函数返回你指定的三个岛屿索引所对应的海狸聚集开会的岛屿的索引。\n  - 你通过参数 $u$、$v$ 和 $w$ 分别指定三个岛屿的索引。这些值必须满足 $0 \\le u \\le N-1$、$0 \\le v \\le N-1$、$0 \\le w \\le N-1$，且 $u \\ne v$、$u \\ne w$、$v \\ne w$。否则，你的程序将被视为 **Wrong Answer [1]**。\n  - 函数 `Query` 的调用次数不得超过 $100\\,000$ 次。否则，你的程序将被视为 **Wrong Answer [2]**。\n\n- `void Bridge(int u, int v)`\n\n  - 使用此函数，你需回答岛屿之间如何通过桥梁连接。\n  - 参数 $u$ 和 $v$ 表示岛屿 $u$ 和 $v$ 通过一座桥梁直接相连。\n  - 若 $0 \\le u < v \\le N-1$ 不成立，你的程序将被视为 **Wrong Answer [3]**。\n  - 若岛屿 $u$ 和 $v$ 并未通过桥梁直接相连，你的程序将被视为 **Wrong Answer [4]**。\n  - 若函数 `Bridge` 以相同的参数 $u$ 和 $v$ 被多次调用，你的程序将被视为 **Wrong Answer [5]**。\n  - 由于共有 $N-1$ 座桥梁，函数 `Bridge` 必须被调用恰好 $N-1$ 次。若在函数 `Solve` 执行结束时，对函数 `Bridge` 的调用次数不等于 $N-1$，你的程序将被视为 **Wrong Answer [6]**。\n\n### 编译与测试运行\n\n示例评测器是文件 `grader.cpp`。为了测试你的程序，请将 `grader.cpp`、`meetings.cpp` 和 `meetings.h` 放在同一目录下，并运行以下命令来编译你的程序：\n\n```\ng++ -std=gnu++14 -O2 -o grader grader.cpp meetings.cpp\n```\n\n当编译成功时，将生成可执行文件 `grader`。\n\n**请注意，在洛谷上提交代码时，不应引入头文件 meetings.h**，而是应当加入这两行代码，并且选择不低于 C++17 的语言版本提交：\n\n```cpp\nint Query(int u, int v, int w);\nvoid Bridge(int u, int v);\n```", "inputFormat": "示例评测器从标准输入读取以下数据：\n\n$N$\n\n$A_0\\ B_0$\n\n$\\vdots$\n\n$A_{N-2}\\ B_{N-2}$\n\n其中，$A_i$ 和 $B_i$（$0 \\le i \\le N-2$）表示岛屿 $A_i$ 和 $B_i$ 通过一座桥梁直接相连。", "outputFormat": "当程序成功终止时，示例评测器将以下信息写入标准输出（引号仅用于清晰说明）：\n\n- 若你的程序被视为正确，它将输出函数 `Query` 的调用次数，格式为 “Accepted: 100”。\n- 若你的程序被视为 **Wrong Answer**，它将输出其类型，格式为 “Wrong Answer [1]”。\n\n若你的程序被判定为多种类型的 **Wrong Answer**，示例评测器仅报告其中一种。", "hint": "### 样例 1 解释\n\n| 调用 | 调用 | 返回值 |\n|:-:|:-:|:-:|\n| Solve(5)  |   |   |\n|   | Query(0, 1, 2) | 0 |\n|   | Query(0, 3, 4) | 1 |\n|   | Bridge(1, 3) |   |\n|   | Bridge(0, 2) |   |\n|   | Bridge(1, 4) |   |\n|   | Bridge(0, 1) |   |\n\n### 数据范围\n\n有关 $A_i$ 和 $B_i$ 的定义，请参阅“示例评测器的输入”部分。\n\n- $3 \\le N \\le 2000$。\n- $0 \\le A_i < B_i \\le N-1$（$0 \\le i \\le N-2$）。\n- 可以通过若干座桥梁在任意两个岛屿之间通行。\n- 对于每个岛屿，最多有 $18$ 座桥梁直接与其相连。\n\n### 子任务\n\n1. （7 分）$N\\le7$。\n2. （10 分）$N\\le50$。\n3. （12 分）$N\\le300$。\n4. （71 分）没有额外的约束。\n\n- 对于子任务 1,2,3，如果您的程序对于子任务中的所有测试用例都是正确的，那么您将得到完整的测试用例得分。\n- 对于子任务 4，如果您的程序对于所有测试用例都是正确的，那么您的分数将如下所示，其中 $X$ 是针对测试用例调用 `Query` 函数的最大次数。\n  - 49 分当 $40000<X\\le100000$，\n  - 71 分当 $X\\le40000$。", "locale": "zh-CN"}}}
{"pid": "P14342", "type": "P", "difficulty": 6, "samples": [["2 5\n2 7 1 8 2\n3 1 4 1 5", "14 5\n2 1"], ["7 1\n1\n2\n3\n4\n5\n6\n7", "1 7\n2 7\n3 7\n4 7\n5 7\n6 7\n3 1 4 2 7 6 5"], ["5 3\n2 3 1\n1 1 1\n2 2 1\n1 2 2\n1 2 1", "15 28\n35 28\n50 28\n70 28\n3 1 5 2 4"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "2019", "Special Judge", "JOISC/JOIST（日本）"], "title": "[JOISC 2019] 馕 / Naan", "background": "", "description": "JOI 咖喱店以供应非常长的馕而闻名。他们有 $L$ 种口味，编号从 $1$ 到 $L$，分别对应不同口味的馕。“JOI 特制馕”是该店最受欢迎的菜品。馕的长度为 $L$ 厘米。我们定义“位置 $x$”为距离馕左端 $x$ 厘米处的位置。位置 $j-1$ 与位置 $j$ 之间的线段由第 $j$ 种口味调味（$1 \\le j \\le L$）。\n\n有 $N$ 个人来到 JOI 咖喱店。他们的口味偏好各不相同。具体而言，当第 $i$ 个人（$1 \\le i \\le N$）食用第 $j$ 种口味的馕（$1 \\le j \\le L$）时，他每厘米可获得 $V_{i,j}$ 的幸福感。\n\n他们只点了一份“JOI 特制馕”。他们将按以下方式分享这份馕：\n\n1. 选择 $N-1$ 个有理数 $X_1, \\ldots, X_{N-1}$，满足 $0 < X_1 < X_2 < \\cdots < X_{N-1} < L$。\n2. 选择 $N$ 个整数 $P_1, \\ldots, P_N$，它们构成 $1, \\ldots, N$ 的一个排列。\n3. 对于每个 $k$（$1 \\le k \\le N-1$），在位置 $X_k$ 处切开馕。这样，馕将被分成 $N$ 块。\n4. 对于每个 $k$（$1 \\le k \\le N$），将位置 $X_{k-1}$ 与位置 $X_k$ 之间的那块馕分给第 $P_k$ 个人。我们约定 $X_0 = 0$，$X_N = L$。\n\n我们希望公平地分配这份馕。我们称一种分配方式是**公平**的，当且仅当每个人获得的幸福感不少于他独自食用整份“JOI 特制馕”时所获得幸福感的 $\\frac{1}{N}$。\n\n编写一个程序，在给定 $N$ 个人的口味偏好信息后，判断是否可能以公平的方式分配馕；若可能，找出一种公平的分配方案。\n", "inputFormat": "从标准输入读取以下数据。输入中的所有数值均为整数。\n\n$N\\ L$\n\n$V_{1,1}\\ V_{1,2}\\ \\cdots\\ V_{1,L}$\n\n$\\vdots$\n\n$V_{N,1}\\ V_{N,2}\\ \\cdots\\ V_{N,L}$", "outputFormat": "向标准输出写入结果。若无法以公平方式分配馕，请在一行中输出 $-1$。若可以公平分配，则输出 $N-1$ 个有理数 $X_1, \\ldots, X_{N-1}$ 和 $N$ 个整数 $P_1, \\ldots, P_N$，它们代表一种公平的分配方案，输出格式如下：\n\n$A_1\\ B_1$\n\n$A_2\\ B_2$\n\n$\\vdots$\n\n$A_{N-1}\\ B_{N-1}$\n\n$P_1\\ P_2\\ \\cdots\\ P_N$\n\n其中，$A_k$ 和 $B_k$ 是一对整数，满足 $X_k = \\frac{A_k}{B_k}$（$1 \\le k \\le N-1$）。这些整数需满足“输出约束”部分的要求。", "hint": "### 样例 1 解释\n\n在本样例中，第一个人食用整份馕时将获得幸福感 $2 + 7 + 1 + 8 + 2 = 20$，第二个人食用整份馕时将获得幸福感 $3 + 1 + 4 + 1 + 5 = 14$。因此，若第一个人获得的幸福感不少于 $\\frac{20}{2} = 10$，且第二个人获得的幸福感不少于 $\\frac{14}{2} = 7$，则该分配是公平的。\n\n若在位置 $\\frac{14}{5}$ 处切开馕，则第一个人将获得幸福感 $1 \\times \\frac{1}{5} + 8 + 2 = \\frac{51}{5}$，第二个人将获得幸福感 $3 + 1 + 4 \\times \\frac{4}{5} = \\frac{36}{5}$。因此，这是一种公平的分配方案。\n\n### 样例 2 解释\n\n在本样例中，馕只有一种口味。若将馕平均分成 7 块，则无论 $P_1, \\ldots, P_N$ 如何取值，该分配都是公平的。\n\n### 样例 3 解释\n\n请注意 $A_k$ 和 $B_k$ 可以不互质（$1 \\leq k \\leq N-1$）。\n\n### 输入限制\n\n- $2 \\le N \\le 2000$。\n- $1 \\le L \\le 2000$。\n- $1 \\le V_{i,j} \\le 100\\,000$（$1 \\le i \\le N$，$1 \\le j \\le L$）。\n\n### 输出限制\n\n若可以公平分配馕，则输出必须满足以下约束：\n\n- $1 \\le B_k \\le 1\\,000\\,000\\,000$（$1 \\le k \\le N-1$）。\n- $0 < \\frac{A_1}{B_1} < \\frac{A_2}{B_2} < \\cdots < \\frac{A_{N-1}}{B_{N-1}} < L$。\n- $P_1, \\ldots, P_N$ 是 $1, \\ldots, N$ 的一个排列。\n- 在该分配方案中，第 $i$ 个人获得的幸福感不少于 $\\frac{V_{i,1} + V_{i,2} + \\cdots + V_{i,L}}{N}$（$1 \\le i \\le N$）。\n\n$A_k$ 和 $B_k$ 不必互质（$1 \\le k \\le N-1$）。\n\n在输入约束下，可以证明：若存在公平分配方案，则必存在一个满足 $1 \\le B_k \\le 1\\,000\\,000\\,000$（$1 \\le k \\le N-1$）的正确输出。\n\n### 子任务\n\n1. （5 分）$N = 2$。\n2. （24 分）$N \\le 6$，且 $V_{i,j} \\le 10$（$1 \\le i \\le N$，$1 \\le j \\le L$）。\n3. （71 分）无额外约束。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2019] 馕 / Naan", "background": "", "description": "JOI 咖喱店以供应非常长的馕而闻名。他们有 $L$ 种口味，编号从 $1$ 到 $L$，分别对应不同口味的馕。“JOI 特制馕”是该店最受欢迎的菜品。馕的长度为 $L$ 厘米。我们定义“位置 $x$”为距离馕左端 $x$ 厘米处的位置。位置 $j-1$ 与位置 $j$ 之间的线段由第 $j$ 种口味调味（$1 \\le j \\le L$）。\n\n有 $N$ 个人来到 JOI 咖喱店。他们的口味偏好各不相同。具体而言，当第 $i$ 个人（$1 \\le i \\le N$）食用第 $j$ 种口味的馕（$1 \\le j \\le L$）时，他每厘米可获得 $V_{i,j}$ 的幸福感。\n\n他们只点了一份“JOI 特制馕”。他们将按以下方式分享这份馕：\n\n1. 选择 $N-1$ 个有理数 $X_1, \\ldots, X_{N-1}$，满足 $0 < X_1 < X_2 < \\cdots < X_{N-1} < L$。\n2. 选择 $N$ 个整数 $P_1, \\ldots, P_N$，它们构成 $1, \\ldots, N$ 的一个排列。\n3. 对于每个 $k$（$1 \\le k \\le N-1$），在位置 $X_k$ 处切开馕。这样，馕将被分成 $N$ 块。\n4. 对于每个 $k$（$1 \\le k \\le N$），将位置 $X_{k-1}$ 与位置 $X_k$ 之间的那块馕分给第 $P_k$ 个人。我们约定 $X_0 = 0$，$X_N = L$。\n\n我们希望公平地分配这份馕。我们称一种分配方式是**公平**的，当且仅当每个人获得的幸福感不少于他独自食用整份“JOI 特制馕”时所获得幸福感的 $\\frac{1}{N}$。\n\n编写一个程序，在给定 $N$ 个人的口味偏好信息后，判断是否可能以公平的方式分配馕；若可能，找出一种公平的分配方案。\n", "inputFormat": "从标准输入读取以下数据。输入中的所有数值均为整数。\n\n$N\\ L$\n\n$V_{1,1}\\ V_{1,2}\\ \\cdots\\ V_{1,L}$\n\n$\\vdots$\n\n$V_{N,1}\\ V_{N,2}\\ \\cdots\\ V_{N,L}$", "outputFormat": "向标准输出写入结果。若无法以公平方式分配馕，请在一行中输出 $-1$。若可以公平分配，则输出 $N-1$ 个有理数 $X_1, \\ldots, X_{N-1}$ 和 $N$ 个整数 $P_1, \\ldots, P_N$，它们代表一种公平的分配方案，输出格式如下：\n\n$A_1\\ B_1$\n\n$A_2\\ B_2$\n\n$\\vdots$\n\n$A_{N-1}\\ B_{N-1}$\n\n$P_1\\ P_2\\ \\cdots\\ P_N$\n\n其中，$A_k$ 和 $B_k$ 是一对整数，满足 $X_k = \\frac{A_k}{B_k}$（$1 \\le k \\le N-1$）。这些整数需满足“输出约束”部分的要求。", "hint": "### 样例 1 解释\n\n在本样例中，第一个人食用整份馕时将获得幸福感 $2 + 7 + 1 + 8 + 2 = 20$，第二个人食用整份馕时将获得幸福感 $3 + 1 + 4 + 1 + 5 = 14$。因此，若第一个人获得的幸福感不少于 $\\frac{20}{2} = 10$，且第二个人获得的幸福感不少于 $\\frac{14}{2} = 7$，则该分配是公平的。\n\n若在位置 $\\frac{14}{5}$ 处切开馕，则第一个人将获得幸福感 $1 \\times \\frac{1}{5} + 8 + 2 = \\frac{51}{5}$，第二个人将获得幸福感 $3 + 1 + 4 \\times \\frac{4}{5} = \\frac{36}{5}$。因此，这是一种公平的分配方案。\n\n### 样例 2 解释\n\n在本样例中，馕只有一种口味。若将馕平均分成 7 块，则无论 $P_1, \\ldots, P_N$ 如何取值，该分配都是公平的。\n\n### 样例 3 解释\n\n请注意 $A_k$ 和 $B_k$ 可以不互质（$1 \\leq k \\leq N-1$）。\n\n### 输入限制\n\n- $2 \\le N \\le 2000$。\n- $1 \\le L \\le 2000$。\n- $1 \\le V_{i,j} \\le 100\\,000$（$1 \\le i \\le N$，$1 \\le j \\le L$）。\n\n### 输出限制\n\n若可以公平分配馕，则输出必须满足以下约束：\n\n- $1 \\le B_k \\le 1\\,000\\,000\\,000$（$1 \\le k \\le N-1$）。\n- $0 < \\frac{A_1}{B_1} < \\frac{A_2}{B_2} < \\cdots < \\frac{A_{N-1}}{B_{N-1}} < L$。\n- $P_1, \\ldots, P_N$ 是 $1, \\ldots, N$ 的一个排列。\n- 在该分配方案中，第 $i$ 个人获得的幸福感不少于 $\\frac{V_{i,1} + V_{i,2} + \\cdots + V_{i,L}}{N}$（$1 \\le i \\le N$）。\n\n$A_k$ 和 $B_k$ 不必互质（$1 \\le k \\le N-1$）。\n\n在输入约束下，可以证明：若存在公平分配方案，则必存在一个满足 $1 \\le B_k \\le 1\\,000\\,000\\,000$（$1 \\le k \\le N-1$）的正确输出。\n\n### 子任务\n\n1. （5 分）$N = 2$。\n2. （24 分）$N \\le 6$，且 $V_{i,j} \\le 10$（$1 \\le i \\le N$，$1 \\le j \\le L$）。\n3. （71 分）无额外约束。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN"}}}
{"pid": "P14343", "type": "P", "difficulty": 6, "samples": [["5\n10 2 4\n1 1 1\n2 1 3\n1 1 1\n100 1 1\n5\n1 2\n2 3\n1 3\n1 4\n1 5", "-1\n1\n8\n8\n99"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "扫描线", "吉司机线段树 segment tree beats", "JOISC/JOIST（日本）"], "title": "[JOISC 2019] 两个天线 / Two Antennas", "background": null, "description": "有 $N$ 个天线，沿直线从 $1$ 到 $N$ 编号。每两个相邻天线之间的距离为 1 千米。天线 $i$（$1 \\le i \\le N$）的高度为 $H_i$。天线 $i$ 可以向距离其 $A_i$ 千米至 $B_i$ 千米（含端点）范围内的天线发送信息。当且仅当天线 $x$ 与天线 $y$（$1 \\le x < y \\le N$）能够互相发送信息时，这对天线处于通信状态，其通信成本为 $|H_x - H_y|$。\n\nJOI 共和国总理 K 先生已收到市民关于通信不良的 $Q$ 项投诉。一项研究表明，对于第 $j$ 项投诉（$1 \\le j \\le Q$），天线 $L_j \\sim R_j$ 中的某些天线存在故障。你的任务是判断在天线 $L_j \\sim R_j$ 中是否存在一对处于通信状态的天线；若存在，还需找出所有此类天线对中的最大通信成本。\n\n编写一个程序，在给定天线信息和投诉信息后，判断在天线 $L_j \\sim R_j$ 中是否存在一对处于通信状态的天线，并在存在时计算出所有此类天线对中的最大通信成本。", "inputFormat": "从标准输入读取以下数据。输入中的所有数值均为整数。\n\n第一行一个整数 $N$。\n\n接下来的 $N$ 行，每行三个整数表示 $H_i,A_i,B_i$。\n\n然后一行一个整数 $Q$。\n\n最后 $Q$ 行每行两个整数表示 $L_i, R_i$。", "outputFormat": "向标准输出写入 $Q$ 行。第 $j$ 行（$1 \\le j \\le Q$）应为 $-1$，若在天线 $L_j \\sim R_j$ 中不存在任何处于通信状态的天线对；否则，输出所有此类天线对中的最大通信成本。", "hint": "### 样例 1 解释\n\n天线 1 与天线 2 之间无法通信，因此第 1 项投诉的答案为 $-1$。\n\n对于第 2、3、4、5 项投诉，通信成本最大的通信天线对分别为 $(2, 3)$、$(1, 3)$、$(1, 3)$ 和 $(4, 5)$。\n\n### 数据范围\n\n- $2 \\le N \\le 2\\times 10^5$。\n- $1 \\le H_i \\le 10^9$（$1 \\le i \\le N$）。\n- $1 \\le A_i \\le B_i \\le N - 1$（$1 \\le i \\le N$）。\n- $1 \\le Q \\le 2\\times 10^5$。\n- $1 \\le L_j < R_j \\le N$（$1 \\le j \\le Q$）。\n\n### 子任务\n\n1. （2 分）$N \\le 300$，$Q \\le 300$。\n2. （11 分）$N \\le 2000$。\n3. （22 分）$Q = 1$，$L_1 = 1$，$R_1 = N$。\n4. （65 分）无额外约束。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2019] 两个天线 / Two Antennas", "background": null, "description": "有 $N$ 个天线，沿直线从 $1$ 到 $N$ 编号。每两个相邻天线之间的距离为 1 千米。天线 $i$（$1 \\le i \\le N$）的高度为 $H_i$。天线 $i$ 可以向距离其 $A_i$ 千米至 $B_i$ 千米（含端点）范围内的天线发送信息。当且仅当天线 $x$ 与天线 $y$（$1 \\le x < y \\le N$）能够互相发送信息时，这对天线处于通信状态，其通信成本为 $|H_x - H_y|$。\n\nJOI 共和国总理 K 先生已收到市民关于通信不良的 $Q$ 项投诉。一项研究表明，对于第 $j$ 项投诉（$1 \\le j \\le Q$），天线 $L_j \\sim R_j$ 中的某些天线存在故障。你的任务是判断在天线 $L_j \\sim R_j$ 中是否存在一对处于通信状态的天线；若存在，还需找出所有此类天线对中的最大通信成本。\n\n编写一个程序，在给定天线信息和投诉信息后，判断在天线 $L_j \\sim R_j$ 中是否存在一对处于通信状态的天线，并在存在时计算出所有此类天线对中的最大通信成本。", "inputFormat": "从标准输入读取以下数据。输入中的所有数值均为整数。\n\n第一行一个整数 $N$。\n\n接下来的 $N$ 行，每行三个整数表示 $H_i,A_i,B_i$。\n\n然后一行一个整数 $Q$。\n\n最后 $Q$ 行每行两个整数表示 $L_i, R_i$。", "outputFormat": "向标准输出写入 $Q$ 行。第 $j$ 行（$1 \\le j \\le Q$）应为 $-1$，若在天线 $L_j \\sim R_j$ 中不存在任何处于通信状态的天线对；否则，输出所有此类天线对中的最大通信成本。", "hint": "### 样例 1 解释\n\n天线 1 与天线 2 之间无法通信，因此第 1 项投诉的答案为 $-1$。\n\n对于第 2、3、4、5 项投诉，通信成本最大的通信天线对分别为 $(2, 3)$、$(1, 3)$、$(1, 3)$ 和 $(4, 5)$。\n\n### 数据范围\n\n- $2 \\le N \\le 2\\times 10^5$。\n- $1 \\le H_i \\le 10^9$（$1 \\le i \\le N$）。\n- $1 \\le A_i \\le B_i \\le N - 1$（$1 \\le i \\le N$）。\n- $1 \\le Q \\le 2\\times 10^5$。\n- $1 \\le L_j < R_j \\le N$（$1 \\le j \\le Q$）。\n\n### 子任务\n\n1. （2 分）$N \\le 300$，$Q \\le 300$。\n2. （11 分）$N \\le 2000$。\n3. （22 分）$Q = 1$，$L_1 = 1$，$R_1 = N$。\n4. （65 分）无额外约束。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN"}}}
{"pid": "P14344", "type": "P", "difficulty": 7, "samples": [["4 3\n2 1 1\n3 8 1\n2 13 1\n1 13 1\n3 6 1\n2 11 1\n2 15 1", "6"], ["5 7\n16 73 16\n17 73 10\n20 73 1\n14 73 16\n18 73 10\n3 73 2\n10 73 7\n16 73 19\n12 73 4\n15 73 15\n20 73 14\n15 73 8", "63"], ["9 11\n86 565 58\n41 469 -95\n73 679 28\n91 585 -78\n17 513 -63\n48 878 -66\n66 901 59\n72 983 -70\n68 1432 11\n42 386 -87\n36 895 57\n100 164 10\n96 812 -6\n23 961 -66\n54 193 51\n37 709 82\n62 148 -36\n28 853 22\n15 44 53\n77 660 -19", "99"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2019", "线段树", "动态规划优化", "JOISC/JOIST（日本）"], "title": "[JOISC 2019] 两道料理 / Two Dishes", "background": "本题测试数据较大，可能需要 1-1.5 分钟的时间加载测试数据。", "description": "Bitaro 正在参加一场烹饪比赛。在本比赛中，参赛者需要制作两道菜：IOI 盖饭和 JOI 咖喱。\n\nIOI 盖饭的烹饪过程包含 $N$ 个步骤。第 $i$ 步（$1 \\le i \\le N$）恰好需要 $A_i$ 分钟。初始时，他只能执行第一步。要执行第 $i$ 步（$2 \\le i \\le N$），他必须先完成第 $(i-1)$ 步。\n\nJOI 咖喱的烹饪过程包含 $M$ 个步骤。第 $j$ 步（$1 \\le j \\le M$）恰好需要 $B_j$ 分钟。初始时，他只能执行第一步。要执行第 $j$ 步（$2 \\le j \\le M$），他必须先完成第 $(j-1)$ 步。\n\n步骤需要集中精力，因此一旦他开始执行某个步骤，就必须完成该步骤后才能执行其他步骤。在步骤之间，他可以从一道菜切换到另一道菜。比赛开始后，他必须完成两道菜后才能休息。\n\n顺便说明，在本比赛中，参赛者将获得如下**艺术评分**：\n\n- 若他在比赛开始后 $S_i$ 分钟内完成 IOI 盖饭的第 $i$ 步（$1 \\le i \\le N$），则获得 $P_i$ 分。此处，$P_i$ 的值可能为负数。\n- 若他在比赛开始后 $T_j$ 分钟内完成 JOI 咖喱的第 $j$ 步（$1 \\le j \\le M$），则获得 $Q_j$ 分。此处，$Q_j$ 的值可能为负数。\n\nBitaro 希望最大化他的总艺术评分。\n\n编写一个程序，在给定烹饪步骤数量、各步骤所需时间以及艺术评分信息后，计算 Bitaro 能获得的最大总艺术评分。", "inputFormat": "从标准输入读取以下数据。输入中的所有数值均为整数。\n\n$N\\ M$\n\n$A_1\\ S_1\\ P_1$\n\n$\\vdots$\n\n$A_N\\ S_N\\ P_N$\n\n$B_1\\ T_1\\ Q_1$\n\n$\\vdots$\n\n$B_M\\ T_M\\ Q_M$", "outputFormat": "向标准输出写入一行。输出应包含 Bitaro 能获得的最大总艺术评分。", "hint": "### 样例 1 解释\n\n本样例输入满足子任务 2 的约束条件。\n\n在本样例输入中，Bitaro 可按如下方式执行烹饪步骤，例如：\n\n1. 他执行 JOI 咖喱的第 1 步。他在比赛开始后 3 分钟完成。由于该时间在 6 分钟内，他获得 1 分。\n2. 他执行 IOI 盖饭的第 1 步。他在比赛开始后 5 分钟完成。由于该时间不在 1 分钟内，他未获得艺术评分。\n3. 他执行 IOI 盖饭的第 2 步。他在比赛开始后 8 分钟完成。由于该时间在 8 分钟内，他获得 1 分。\n4. 他执行 JOI 咖喱的第 2 步。他在比赛开始后 10 分钟完成。由于该时间在 11 分钟内，他获得 1 分。\n5. 他执行 IOI 盖饭的第 3 步。他在比赛开始后 12 分钟完成。由于该时间在 13 分钟内，他获得 1 分。\n6. 他执行 IOI 盖饭的第 4 步。他在比赛开始后 13 分钟完成。由于该时间在 13 分钟内，他获得 1 分。\n7. 他执行 JOI 咖喱的第 3 步。他在比赛开始后 15 分钟完成。由于该时间在 15 分钟内，他获得 1 分。\n\n此处，总艺术评分为 6 分。他无法获得超过 6 分，因此输出 6。\n\n### 数据范围\n\n- $1 \\le N \\le 1\\,000\\,000$。\n- $1 \\le M \\le 1\\,000\\,000$。\n- $1 \\le A_i \\le 1\\,000\\,000\\,000$（$1 \\le i \\le N$）。\n- $1 \\le B_j \\le 1\\,000\\,000\\,000$（$1 \\le j \\le M$）。\n- $1 \\le S_i \\le 2\\,000\\,000\\,000\\,000\\,000 = 2 \\times 10^{15}$（$1 \\le i \\le N$）。\n- $1 \\le T_j \\le 2\\,000\\,000\\,000\\,000\\,000 = 2 \\times 10^{15}$（$1 \\le j \\le M$）。\n- $-1\\,000\\,000\\,000 \\le P_i \\le 1\\,000\\,000\\,000$（$1 \\le i \\le N$）。\n- $-1\\,000\\,000\\,000 \\le Q_j \\le 1\\,000\\,000\\,000$（$1 \\le j \\le M$）。\n\n### 子任务\n\n1. （5 分）$N \\le 200\\,000$，$M \\le 200\\,000$，$S_1 = \\cdots = S_N = T_1 = \\cdots = T_M$。\n2. （3 分）$N \\le 12$，$M \\le 12$，$P_i = 1$（$1 \\le i \\le N$），$Q_j = 1$（$1 \\le j \\le M$）。\n3. （7 分）$N \\le 2\\,000$，$M \\le 2\\,000$，$P_i = 1$（$1 \\le i \\le N$），$Q_j = 1$（$1 \\le j \\le M$）。\n4. （39 分）$N \\le 200\\,000$，$M \\le 200\\,000$，$P_i = 1$（$1 \\le i \\le N$），$Q_j = 1$（$1 \\le j \\le M$）。\n5. （11 分）$N \\le 200\\,000$，$M \\le 200\\,000$，$1 \\le P_i$（$1 \\le i \\le N$），$1 \\le Q_j$（$1 \\le j \\le M$）。\n6. （9 分）$1 \\le P_i$（$1 \\le i \\le N$），$1 \\le Q_j$（$1 \\le j \\le M$）。\n7. （17 分）$N \\le 200\\,000$，$M \\le 200\\,000$。\n8. （9 分）无额外约束。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2019] 两道料理 / Two Dishes", "background": "本题测试数据较大，可能需要 1-1.5 分钟的时间加载测试数据。", "description": "Bitaro 正在参加一场烹饪比赛。在本比赛中，参赛者需要制作两道菜：IOI 盖饭和 JOI 咖喱。\n\nIOI 盖饭的烹饪过程包含 $N$ 个步骤。第 $i$ 步（$1 \\le i \\le N$）恰好需要 $A_i$ 分钟。初始时，他只能执行第一步。要执行第 $i$ 步（$2 \\le i \\le N$），他必须先完成第 $(i-1)$ 步。\n\nJOI 咖喱的烹饪过程包含 $M$ 个步骤。第 $j$ 步（$1 \\le j \\le M$）恰好需要 $B_j$ 分钟。初始时，他只能执行第一步。要执行第 $j$ 步（$2 \\le j \\le M$），他必须先完成第 $(j-1)$ 步。\n\n步骤需要集中精力，因此一旦他开始执行某个步骤，就必须完成该步骤后才能执行其他步骤。在步骤之间，他可以从一道菜切换到另一道菜。比赛开始后，他必须完成两道菜后才能休息。\n\n顺便说明，在本比赛中，参赛者将获得如下**艺术评分**：\n\n- 若他在比赛开始后 $S_i$ 分钟内完成 IOI 盖饭的第 $i$ 步（$1 \\le i \\le N$），则获得 $P_i$ 分。此处，$P_i$ 的值可能为负数。\n- 若他在比赛开始后 $T_j$ 分钟内完成 JOI 咖喱的第 $j$ 步（$1 \\le j \\le M$），则获得 $Q_j$ 分。此处，$Q_j$ 的值可能为负数。\n\nBitaro 希望最大化他的总艺术评分。\n\n编写一个程序，在给定烹饪步骤数量、各步骤所需时间以及艺术评分信息后，计算 Bitaro 能获得的最大总艺术评分。", "inputFormat": "从标准输入读取以下数据。输入中的所有数值均为整数。\n\n$N\\ M$\n\n$A_1\\ S_1\\ P_1$\n\n$\\vdots$\n\n$A_N\\ S_N\\ P_N$\n\n$B_1\\ T_1\\ Q_1$\n\n$\\vdots$\n\n$B_M\\ T_M\\ Q_M$", "outputFormat": "向标准输出写入一行。输出应包含 Bitaro 能获得的最大总艺术评分。", "hint": "### 样例 1 解释\n\n本样例输入满足子任务 2 的约束条件。\n\n在本样例输入中，Bitaro 可按如下方式执行烹饪步骤，例如：\n\n1. 他执行 JOI 咖喱的第 1 步。他在比赛开始后 3 分钟完成。由于该时间在 6 分钟内，他获得 1 分。\n2. 他执行 IOI 盖饭的第 1 步。他在比赛开始后 5 分钟完成。由于该时间不在 1 分钟内，他未获得艺术评分。\n3. 他执行 IOI 盖饭的第 2 步。他在比赛开始后 8 分钟完成。由于该时间在 8 分钟内，他获得 1 分。\n4. 他执行 JOI 咖喱的第 2 步。他在比赛开始后 10 分钟完成。由于该时间在 11 分钟内，他获得 1 分。\n5. 他执行 IOI 盖饭的第 3 步。他在比赛开始后 12 分钟完成。由于该时间在 13 分钟内，他获得 1 分。\n6. 他执行 IOI 盖饭的第 4 步。他在比赛开始后 13 分钟完成。由于该时间在 13 分钟内，他获得 1 分。\n7. 他执行 JOI 咖喱的第 3 步。他在比赛开始后 15 分钟完成。由于该时间在 15 分钟内，他获得 1 分。\n\n此处，总艺术评分为 6 分。他无法获得超过 6 分，因此输出 6。\n\n### 数据范围\n\n- $1 \\le N \\le 1\\,000\\,000$。\n- $1 \\le M \\le 1\\,000\\,000$。\n- $1 \\le A_i \\le 1\\,000\\,000\\,000$（$1 \\le i \\le N$）。\n- $1 \\le B_j \\le 1\\,000\\,000\\,000$（$1 \\le j \\le M$）。\n- $1 \\le S_i \\le 2\\,000\\,000\\,000\\,000\\,000 = 2 \\times 10^{15}$（$1 \\le i \\le N$）。\n- $1 \\le T_j \\le 2\\,000\\,000\\,000\\,000\\,000 = 2 \\times 10^{15}$（$1 \\le j \\le M$）。\n- $-1\\,000\\,000\\,000 \\le P_i \\le 1\\,000\\,000\\,000$（$1 \\le i \\le N$）。\n- $-1\\,000\\,000\\,000 \\le Q_j \\le 1\\,000\\,000\\,000$（$1 \\le j \\le M$）。\n\n### 子任务\n\n1. （5 分）$N \\le 200\\,000$，$M \\le 200\\,000$，$S_1 = \\cdots = S_N = T_1 = \\cdots = T_M$。\n2. （3 分）$N \\le 12$，$M \\le 12$，$P_i = 1$（$1 \\le i \\le N$），$Q_j = 1$（$1 \\le j \\le M$）。\n3. （7 分）$N \\le 2\\,000$，$M \\le 2\\,000$，$P_i = 1$（$1 \\le i \\le N$），$Q_j = 1$（$1 \\le j \\le M$）。\n4. （39 分）$N \\le 200\\,000$，$M \\le 200\\,000$，$P_i = 1$（$1 \\le i \\le N$），$Q_j = 1$（$1 \\le j \\le M$）。\n5. （11 分）$N \\le 200\\,000$，$M \\le 200\\,000$，$1 \\le P_i$（$1 \\le i \\le N$），$1 \\le Q_j$（$1 \\le j \\le M$）。\n6. （9 分）$1 \\le P_i$（$1 \\le i \\le N$），$1 \\le Q_j$（$1 \\le j \\le M$）。\n7. （17 分）$N \\le 200\\,000$，$M \\le 200\\,000$。\n8. （9 分）无额外约束。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN"}}}
{"pid": "P14345", "type": "P", "difficulty": 6, "samples": [["4 3 4\n0 1 6\n2 1 4\n2 0 10\n1 2 3\n3 1 1\n3 2 3\n3 0 7", ""]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "交互题", "Special Judge", "最短路", "通信题", "JOISC/JOIST（日本）"], "title": "[JOISC 2019] 两种交通 / Two Transportations", "background": "**请使用 C++ 20 提交**。不要引入头文件，并在文件头粘贴如下内容：\n\n```cpp\n#include <vector>\nvoid InitA(int, int, std::vector<int>, std::vector<int>, std::vector<int>);\nvoid ReceiveA(bool);\nstd::vector<int> Answer();\nvoid SendA(bool);\nvoid InitB(int, int, std::vector<int>, std::vector<int>, std::vector<int>);\nvoid ReceiveB(bool);\nvoid SendB(bool);\n```", "description": "JOI 国有 $N$ 座城市，编号从 $0$ 到 $N-1$。有 $A$ 条铁路线，编号从 $0$ 到 $A-1$。铁路线 $i$（$0 \\le i \\le A-1$）双向连接城市 $U_i$ 与城市 $V_i$，票价为 $C_i$。不同的铁路线连接不同的城市对。另有 $B$ 条公交线路，编号从 $0$ 到 $B-1$。公交线路 $j$（$0 \\le j \\le B-1$）双向连接城市 $S_j$ 与城市 $T_j$，票价为 $D_j$。不同的公交线路连接不同的城市对，但一条铁路线与一条公交线路可能连接相同的城市对。通过铁路和/或公交，可以在任意两座城市之间通行。\n\nAzer 想知道从城市 $0$ 到每个城市的最小总票价。由于 Azer 仅了解铁路线的信息，他与仅了解公交线路信息的 Baijan 合作。\n\n他们通过发送和接收字符 0 或 1 进行通信。发送的字符总数应小于或等于 58000。\n\n编写程序，Azer 的程序接收铁路线信息，Baijan 的程序接收公交线路信息，二者通过通信协作，帮助 Azer 找到从城市 $0$ 到每个城市的最小总票价。\n\n### 实现细节\n\n你需要实现两个文件。\n\n第一个文件的名称为 `Azer.cpp`。它表示 Azer 的行为，应实现以下函数。该文件应包含 `Azer.h`。\n\n- `void InitA(int N, int A, std::vector<int> U, std::vector<int> V, std::vector<int> C)`  \n  此函数在程序开始时恰好执行一次。  \n  - 参数 $N$ 是城市数量 $N$。  \n  - 参数 $A$ 是铁路线数量 $A$。  \n  - 参数 $U$、$V$ 是长度为 $A$ 的数组。$U[i]$ 和 $V[i]$ 是由铁路线 $i$（$0 \\le i \\le A-1$）连接的两座城市。  \n  - 参数 $C$ 是长度为 $A$ 的数组。$C[i]$ 是铁路线 $i$（$0 \\le i \\le A-1$）的票价 $C_i$。\n- `void ReceiveA(bool x)`  \n  此函数在 Baijan 每发送一个字符时执行一次。  \n  - 参数 $x$ 表示 Baijan 发送的字符：`true` 代表字符 1，`false` 代表字符 0。\n- `std::vector<int> Answer()`  \n  此函数在所有发送的字符均被接收后恰好执行一次。该函数必须返回一个数组 $Z$，其中包含从城市 $0$ 到每个城市的最小总票价。  \n  - 返回值 $Z$ 必须是一个长度为 $N$ 的数组。若其长度不为 $N$，你的程序将被判定为 **Wrong Answer [1]**。  \n  - $Z[k]$（$0 \\le k \\le N-1$）必须是从城市 $0$ 到城市 $k$ 所需的最小总票价。特别地，需满足 $Z[0] = 0$。\n\n你的程序可在本文件中调用以下函数：\n- `void SendA(bool y)`  \n  使用此函数向 Baijan 发送一个字符。  \n  - 参数 $y$ 表示要发送给 Baijan 的字符：`true` 代表字符 1，`false` 代表字符 0。\n \n第二个文件的名称为 `Baijan.cpp`。它表示 Baijan 的行为，应实现以下函数。该文件应包含 `Baijan.h`。\n\n- `void InitB(int N, int B, std::vector<int> S, std::vector<int> T, std::vector<int> D)`  \n  此函数在程序开始时恰好执行一次。  \n  - 参数 $N$ 是城市数量 $N$。  \n  - 参数 $B$ 是公交线路数量 $B$。  \n  - 参数 $S$、$T$ 是长度为 $B$ 的数组。$S[j]$ 和 $T[j]$ 是由公交线路 $j$（$0 \\le j \\le B-1$）连接的两座城市 $S_j$ 与 $T_j$。  \n  - 参数 $D$ 是长度为 $B$ 的数组。$D[j]$ 是公交线路 $j$（$0 \\le j \\le B-1$）的票价 $D_j$。\n- `void ReceiveB(bool y)`  \n  此函数在 Azer 每发送一个字符时执行一次。  \n  - 参数 $y$ 表示 Azer 发送的字符：`true` 代表字符 1，`false` 代表字符 0。\n\n你的程序可在本文件中调用以下函数：\n\n- `void SendB(bool x)`  \n  使用此函数向 Azer 发送一个字符。  \n  - 参数 $x$ 表示要发送给 Azer 的字符：`true` 代表字符 1，`false` 代表字符 0。\n\n你可以假设程序按如下方式执行。对于每个测试用例，准备两个队列：$Q_Y$，用于存储 Azer 发送的字符；以及 $Q_X$，用于存储 Baijan 发送的字符。首先，执行 `InitA` 和 `InitB`，并将发送的字符推入对应的队列。\n\n- 若 $Q_X$ 或 $Q_Y$ 非空，则从其中一个队列中弹出一个字符，并执行对应的 `ReceiveA` 或 `ReceiveB`。然而，若 $Q_X$ 与 $Q_Y$ 均非空，则无法确定执行 `ReceiveA` 还是 `ReceiveB`。\n- 当在 `ReceiveA` 执行期间调用 `SendA` 时，所发送的字符将被推入 $Q_Y$。\n- 当在 `ReceiveB` 执行期间调用 `SendB` 时，所发送的字符将被推入 $Q_X$。\n- 若两个队列均为空，则执行 `Answer`，程序结束。\n\nAzer 与 Baijan 发送的字符总数应小于或等于 58000。若超过该限制，你的程序将被判定为 **Wrong Answer [2]**。\n\n### 重要提示\n\n- 你的程序可为内部用途实现其他函数，或使用全局变量。提交的文件将与评测程序一起编译，生成一个可执行文件。所有全局变量与内部函数应声明于一个未命名命名空间中，以避免与其他文件冲突。在评测时，程序将作为 Azer 与 Baijan 两个独立进程运行。Azer 进程与 Baijan 进程不能共享全局变量。\n- 你的程序不应使用标准输入与标准输出。你的程序不应以任何方式与其他文件通信。然而，你的程序可向标准错误输出调试信息。", "inputFormat": "示例评测程序从标准输入读取如下格式的数据：\n\n$N\\ A\\ B$\n\n$U_0\\ V_0\\ C_0$\n\n$\\vdots$\n\n$U_{A-1}\\ V_{A-1}\\ C_{A-1}$\n\n$S_0\\ T_0\\ D_0$\n\n$\\vdots$\n\n$S_{B-1}\\ T_{B-1}\\ D_{B-1}$", "outputFormat": "示例评测程序将以下信息写入标准输出和标准错误（为清晰起见，此处使用引号）：\n\n- 若你的程序被判定为 **Wrong Answer [1]** 或 **Wrong Answer [2]**，它会将类型写作 “Wrong Answer [1]” 输出至标准错误，且不会向标准输出写入任何内容。\n- 否则，它会将发送字符的总数 $L$ 以 “Accepted: L” 的形式写入标准错误。同时，它会按以下格式将你的答案 $Z$ 写入标准输出：\n\n  $Z[0]$\n\n  $\\vdots$\n\n  $Z[N - 1]$\n\n  示例评测程序不会检查 $Z$ 的值是否正确。\n\n若你的程序被判定为多种类型的 **Wrong Answer**，示例评测程序仅报告其中一种。", "hint": "### 数据范围\n\n- $1 \\le N \\le 2000$。\n- $0 \\le A \\le 500000$。\n- $0 \\le B \\le 500000$。\n- $0 \\le U_i \\le N - 1$（$0 \\le i \\le A - 1$）。\n- $0 \\le V_i \\le N - 1$（$0 \\le i \\le A - 1$）。\n- $U_i \\ne V_i$（$0 \\le i \\le A - 1$）。\n- $(U_{i_1}, V_{i_1}) \\ne (U_{i_2}, V_{i_2})$ 且 $(U_{i_1}, V_{i_1}) \\ne (V_{i_2}, U_{i_2})$（$0 \\le i_1 < i_2 \\le A - 1$）。\n- $0 \\le S_j \\le N - 1$（$0 \\le j \\le B - 1$）。\n- $0 \\le T_j \\le N - 1$（$0 \\le j \\le B - 1$）。\n- $S_j \\ne T_j$（$0 \\le j \\le B - 1$）。\n- $(S_{j_1}, T_{j_1}) \\ne (S_{j_2}, T_{j_2})$ 且 $(S_{j_1}, T_{j_1}) \\ne (T_{j_2}, S_{j_2})$（$0 \\le j_1 < j_2 \\le B - 1$）。\n- 任意两座城市之间均可通过铁路和/或公交线路到达。\n- $1 \\le C_i \\le 500$（$0 \\le i \\le A - 1$）。\n- $1 \\le D_j \\le 500$（$0 \\le j \\le B - 1$）。\n\n### 子任务\n\n1. （6 分）$A = 0$。\n2. （8 分）$B \\le 1000$。\n3. （8 分）$A + B = N - 1$。\n4. （38 分）$N \\le 900$。\n5. （14 分）$N \\le 1100$。\n6. （10 分）$N \\le 1400$。\n7. （16 分）无额外约束。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2019] 两种交通 / Two Transportations", "background": "**请使用 C++ 20 提交**。不要引入头文件，并在文件头粘贴如下内容：\n\n```cpp\n#include <vector>\nvoid InitA(int, int, std::vector<int>, std::vector<int>, std::vector<int>);\nvoid ReceiveA(bool);\nstd::vector<int> Answer();\nvoid SendA(bool);\nvoid InitB(int, int, std::vector<int>, std::vector<int>, std::vector<int>);\nvoid ReceiveB(bool);\nvoid SendB(bool);\n```", "description": "JOI 国有 $N$ 座城市，编号从 $0$ 到 $N-1$。有 $A$ 条铁路线，编号从 $0$ 到 $A-1$。铁路线 $i$（$0 \\le i \\le A-1$）双向连接城市 $U_i$ 与城市 $V_i$，票价为 $C_i$。不同的铁路线连接不同的城市对。另有 $B$ 条公交线路，编号从 $0$ 到 $B-1$。公交线路 $j$（$0 \\le j \\le B-1$）双向连接城市 $S_j$ 与城市 $T_j$，票价为 $D_j$。不同的公交线路连接不同的城市对，但一条铁路线与一条公交线路可能连接相同的城市对。通过铁路和/或公交，可以在任意两座城市之间通行。\n\nAzer 想知道从城市 $0$ 到每个城市的最小总票价。由于 Azer 仅了解铁路线的信息，他与仅了解公交线路信息的 Baijan 合作。\n\n他们通过发送和接收字符 0 或 1 进行通信。发送的字符总数应小于或等于 58000。\n\n编写程序，Azer 的程序接收铁路线信息，Baijan 的程序接收公交线路信息，二者通过通信协作，帮助 Azer 找到从城市 $0$ 到每个城市的最小总票价。\n\n### 实现细节\n\n你需要实现两个文件。\n\n第一个文件的名称为 `Azer.cpp`。它表示 Azer 的行为，应实现以下函数。该文件应包含 `Azer.h`。\n\n- `void InitA(int N, int A, std::vector<int> U, std::vector<int> V, std::vector<int> C)`  \n  此函数在程序开始时恰好执行一次。  \n  - 参数 $N$ 是城市数量 $N$。  \n  - 参数 $A$ 是铁路线数量 $A$。  \n  - 参数 $U$、$V$ 是长度为 $A$ 的数组。$U[i]$ 和 $V[i]$ 是由铁路线 $i$（$0 \\le i \\le A-1$）连接的两座城市。  \n  - 参数 $C$ 是长度为 $A$ 的数组。$C[i]$ 是铁路线 $i$（$0 \\le i \\le A-1$）的票价 $C_i$。\n- `void ReceiveA(bool x)`  \n  此函数在 Baijan 每发送一个字符时执行一次。  \n  - 参数 $x$ 表示 Baijan 发送的字符：`true` 代表字符 1，`false` 代表字符 0。\n- `std::vector<int> Answer()`  \n  此函数在所有发送的字符均被接收后恰好执行一次。该函数必须返回一个数组 $Z$，其中包含从城市 $0$ 到每个城市的最小总票价。  \n  - 返回值 $Z$ 必须是一个长度为 $N$ 的数组。若其长度不为 $N$，你的程序将被判定为 **Wrong Answer [1]**。  \n  - $Z[k]$（$0 \\le k \\le N-1$）必须是从城市 $0$ 到城市 $k$ 所需的最小总票价。特别地，需满足 $Z[0] = 0$。\n\n你的程序可在本文件中调用以下函数：\n- `void SendA(bool y)`  \n  使用此函数向 Baijan 发送一个字符。  \n  - 参数 $y$ 表示要发送给 Baijan 的字符：`true` 代表字符 1，`false` 代表字符 0。\n \n第二个文件的名称为 `Baijan.cpp`。它表示 Baijan 的行为，应实现以下函数。该文件应包含 `Baijan.h`。\n\n- `void InitB(int N, int B, std::vector<int> S, std::vector<int> T, std::vector<int> D)`  \n  此函数在程序开始时恰好执行一次。  \n  - 参数 $N$ 是城市数量 $N$。  \n  - 参数 $B$ 是公交线路数量 $B$。  \n  - 参数 $S$、$T$ 是长度为 $B$ 的数组。$S[j]$ 和 $T[j]$ 是由公交线路 $j$（$0 \\le j \\le B-1$）连接的两座城市 $S_j$ 与 $T_j$。  \n  - 参数 $D$ 是长度为 $B$ 的数组。$D[j]$ 是公交线路 $j$（$0 \\le j \\le B-1$）的票价 $D_j$。\n- `void ReceiveB(bool y)`  \n  此函数在 Azer 每发送一个字符时执行一次。  \n  - 参数 $y$ 表示 Azer 发送的字符：`true` 代表字符 1，`false` 代表字符 0。\n\n你的程序可在本文件中调用以下函数：\n\n- `void SendB(bool x)`  \n  使用此函数向 Azer 发送一个字符。  \n  - 参数 $x$ 表示要发送给 Azer 的字符：`true` 代表字符 1，`false` 代表字符 0。\n\n你可以假设程序按如下方式执行。对于每个测试用例，准备两个队列：$Q_Y$，用于存储 Azer 发送的字符；以及 $Q_X$，用于存储 Baijan 发送的字符。首先，执行 `InitA` 和 `InitB`，并将发送的字符推入对应的队列。\n\n- 若 $Q_X$ 或 $Q_Y$ 非空，则从其中一个队列中弹出一个字符，并执行对应的 `ReceiveA` 或 `ReceiveB`。然而，若 $Q_X$ 与 $Q_Y$ 均非空，则无法确定执行 `ReceiveA` 还是 `ReceiveB`。\n- 当在 `ReceiveA` 执行期间调用 `SendA` 时，所发送的字符将被推入 $Q_Y$。\n- 当在 `ReceiveB` 执行期间调用 `SendB` 时，所发送的字符将被推入 $Q_X$。\n- 若两个队列均为空，则执行 `Answer`，程序结束。\n\nAzer 与 Baijan 发送的字符总数应小于或等于 58000。若超过该限制，你的程序将被判定为 **Wrong Answer [2]**。\n\n### 重要提示\n\n- 你的程序可为内部用途实现其他函数，或使用全局变量。提交的文件将与评测程序一起编译，生成一个可执行文件。所有全局变量与内部函数应声明于一个未命名命名空间中，以避免与其他文件冲突。在评测时，程序将作为 Azer 与 Baijan 两个独立进程运行。Azer 进程与 Baijan 进程不能共享全局变量。\n- 你的程序不应使用标准输入与标准输出。你的程序不应以任何方式与其他文件通信。然而，你的程序可向标准错误输出调试信息。", "inputFormat": "示例评测程序从标准输入读取如下格式的数据：\n\n$N\\ A\\ B$\n\n$U_0\\ V_0\\ C_0$\n\n$\\vdots$\n\n$U_{A-1}\\ V_{A-1}\\ C_{A-1}$\n\n$S_0\\ T_0\\ D_0$\n\n$\\vdots$\n\n$S_{B-1}\\ T_{B-1}\\ D_{B-1}$", "outputFormat": "示例评测程序将以下信息写入标准输出和标准错误（为清晰起见，此处使用引号）：\n\n- 若你的程序被判定为 **Wrong Answer [1]** 或 **Wrong Answer [2]**，它会将类型写作 “Wrong Answer [1]” 输出至标准错误，且不会向标准输出写入任何内容。\n- 否则，它会将发送字符的总数 $L$ 以 “Accepted: L” 的形式写入标准错误。同时，它会按以下格式将你的答案 $Z$ 写入标准输出：\n\n  $Z[0]$\n\n  $\\vdots$\n\n  $Z[N - 1]$\n\n  示例评测程序不会检查 $Z$ 的值是否正确。\n\n若你的程序被判定为多种类型的 **Wrong Answer**，示例评测程序仅报告其中一种。", "hint": "### 数据范围\n\n- $1 \\le N \\le 2000$。\n- $0 \\le A \\le 500000$。\n- $0 \\le B \\le 500000$。\n- $0 \\le U_i \\le N - 1$（$0 \\le i \\le A - 1$）。\n- $0 \\le V_i \\le N - 1$（$0 \\le i \\le A - 1$）。\n- $U_i \\ne V_i$（$0 \\le i \\le A - 1$）。\n- $(U_{i_1}, V_{i_1}) \\ne (U_{i_2}, V_{i_2})$ 且 $(U_{i_1}, V_{i_1}) \\ne (V_{i_2}, U_{i_2})$（$0 \\le i_1 < i_2 \\le A - 1$）。\n- $0 \\le S_j \\le N - 1$（$0 \\le j \\le B - 1$）。\n- $0 \\le T_j \\le N - 1$（$0 \\le j \\le B - 1$）。\n- $S_j \\ne T_j$（$0 \\le j \\le B - 1$）。\n- $(S_{j_1}, T_{j_1}) \\ne (S_{j_2}, T_{j_2})$ 且 $(S_{j_1}, T_{j_1}) \\ne (T_{j_2}, S_{j_2})$（$0 \\le j_1 < j_2 \\le B - 1$）。\n- 任意两座城市之间均可通过铁路和/或公交线路到达。\n- $1 \\le C_i \\le 500$（$0 \\le i \\le A - 1$）。\n- $1 \\le D_j \\le 500$（$0 \\le j \\le B - 1$）。\n\n### 子任务\n\n1. （6 分）$A = 0$。\n2. （8 分）$B \\le 1000$。\n3. （8 分）$A + B = N - 1$。\n4. （38 分）$N \\le 900$。\n5. （14 分）$N \\le 1100$。\n6. （10 分）$N \\le 1400$。\n7. （16 分）无额外约束。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN"}}}
{"pid": "P14346", "type": "P", "difficulty": 6, "samples": [["4\n1 2 1 2\n1 3 3 4\n1 4 5 6\n2\n1\n2", "9\n1"], ["5\n1 3 13 6\n5 1 17 8\n5 2 6 10\n1 4 16 11\n1\n1\n", "36\n"], ["6\n1 6 6 12\n6 2 5 16\n1 4 13 4\n5 1 19 3\n3 1 9 13\n1\n2\n", "14\n"], ["15\n14 5 12 7\n14 12 6 5\n14 10 14 16\n9 14 16 12\n13 7 4 15\n1 3 8 1\n6 7 15 13\n15 4 4 6\n9 1 12 6\n13 1 7 6\n13 4 5 15\n2 6 11 19\n8 4 12 7\n13 11 14 5\n3\n3\n6\n7\n", "44\n12\n6\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2019", "线段树", "树形 DP", "JOISC/JOIST（日本）"], "title": "[JOISC 2019] 指定城市 / Designated Cities", "background": "", "description": "JOI 国内共有 $N$ 座城市，城市编号从 $1$ 到 $N$。国内有 $N - 1$ 条道路，编号从 $1$ 到 $N - 1$。对于第 $i$ 条道路（$1 \\le i \\le N - 1$），它包含两条车道：一条从城市 $A_i$ 指向城市 $B_i$，另一条从城市 $B_i$ 指向城市 $A_i$。因此，所有道路均为双向通行。任意两座城市之间均可通过道路相互到达。\n\n目前，所有道路的所有车道均未铺设路面。对于每条道路的每条车道，我们已知铺设该车道的成本。对于第 $i$ 条道路（$1 \\le i \\le N - 1$），从城市 $A_i$ 指向城市 $B_i$ 的车道铺设成本为 $C_i$，从城市 $B_i$ 指向城市 $A_i$ 的车道铺设成本为 $D_i$。\n\nJOI 国总理 Mr. K 可选择若干城市并将其指定为 **度假城市**。当他将城市 $x$（$1 \\le x \\le N$）指定为度假城市时，以下事件将对每条道路 $i$（$1 \\le i \\le N - 1$）发生：\n\n在城市 $A_i$ 与 $B_i$ 中，设 $a$ 为距离城市 $x$ 更近的城市，$b$ 为距离城市 $x$ 更远的城市。此处，“距离城市 $x$ 更近”是指从该城市出发，到达城市 $x$ 所需经过的道路数量更少。随后，从城市 $b$ 指向城市 $a$ 的车道将被铺设（若尚未铺设）。\n\n因指定度假城市而产生的车道铺设费用将由税收支付。然而，指定后仍保持未铺设状态的车道的铺设费用需由 Mr. K 自掏腰包支付。\n\n现共有 $Q$ 个方案提交给 Mr. K。在第 $j$ 个方案（$1 \\le j \\le Q$）中，他将从无任何度假城市、且所有道路的所有车道均未铺设的初始状态出发，并恰好指定 $E_j$ 座城市为度假城市。但具体指定哪些城市尚未确定。他希望知道，对于每个方案，需由他自掏腰包支付的最小总铺设费用是多少。\n\n请编写一个程序，输入 JOI 国的城市数量、道路信息及各方案信息，计算并输出每个方案中需由 Mr. K 自掏腰包支付的最小总铺设费用。\n", "inputFormat": "从标准输入读取以下数据。输入中的所有值均为整数。\n\n$N$\n\n$A_1\\ B_1\\ C_1\\ D_1$\n\n$\\vdots$\n\n$A_{N-1}\\ B_{N-1}\\ C_{N-1}\\ D_{N-1}$\n\n$Q$\n\n$E_1$\n\n$\\vdots$\n\n$E_Q$", "outputFormat": "向标准输出写入 $Q$ 行。第 $j$ 行（$1 \\le j \\le Q$）应包含第 $j$ 个方案中需由 Mr. K 自掏腰包支付的最小总铺设费用。\n", "hint": "### 样例 1 解释\n\n考虑方案 1：Mr. K 将恰好指定 1 座城市为度假城市。若他指定城市 1 为度假城市，则道路 1 上从城市 2 指向城市 1 的车道、道路 2 上从城市 3 指向城市 1 的车道、以及道路 3 上从城市 4 指向城市 1 的车道将被铺设。因此，以下车道将保持未铺设状态：道路 1 上从城市 1 指向城市 2 的车道、道路 2 上从城市 1 指向城市 3 的车道、以及道路 3 上从城市 1 指向城市 4 的车道。铺设这些车道的总成本为 $1 + 3 + 5 = 9$。不存在任何指定方式能使总成本低于 9。因此，答案为 9。\n\n考虑方案 2：Mr. K 将恰好指定 2 座城市为度假城市。若他指定城市 3 和城市 4 为度假城市，则道路 1 上从城市 1 指向城市 2 的车道将是唯一保持未铺设的车道。铺设该车道的成本为 1。不存在任何指定 2 座城市的方式能使总成本低于 1。因此，答案为 1。\n\n### 约束条件\n\n- $2 \\le N \\le 200000$。\n- $1 \\le A_i \\le N$（$1 \\le i \\le N - 1$）。\n- $1 \\le B_i \\le N$（$1 \\le i \\le N - 1$）。\n- $A_i \\ne B_i$（$1 \\le i \\le N - 1$）。\n- 任意两座城市之间均可通过道路相互到达。\n- $1 \\le C_i \\le 1000000000$（$1 \\le i \\le N - 1$）。\n- $1 \\le D_i \\le 1000000000$（$1 \\le i \\le N - 1$）。\n- $1 \\le Q \\le N$。\n- $1 \\le E_j \\le N$（$1 \\le j \\le Q$）。\n\n### 子任务\n\n1. （6 分）$N \\le 16$。\n2. （7 分）$Q = 1$，$E_1 = 1$。\n3. （9 分）$Q = 1$，$E_1 = 2$。\n4. （17 分）$N \\le 2000$。\n5. （17 分）$Q = 1$。\n6. （44 分）无额外约束。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2019] 指定城市 / Designated Cities", "background": "", "description": "JOI 国内共有 $N$ 座城市，城市编号从 $1$ 到 $N$。国内有 $N - 1$ 条道路，编号从 $1$ 到 $N - 1$。对于第 $i$ 条道路（$1 \\le i \\le N - 1$），它包含两条车道：一条从城市 $A_i$ 指向城市 $B_i$，另一条从城市 $B_i$ 指向城市 $A_i$。因此，所有道路均为双向通行。任意两座城市之间均可通过道路相互到达。\n\n目前，所有道路的所有车道均未铺设路面。对于每条道路的每条车道，我们已知铺设该车道的成本。对于第 $i$ 条道路（$1 \\le i \\le N - 1$），从城市 $A_i$ 指向城市 $B_i$ 的车道铺设成本为 $C_i$，从城市 $B_i$ 指向城市 $A_i$ 的车道铺设成本为 $D_i$。\n\nJOI 国总理 Mr. K 可选择若干城市并将其指定为 **度假城市**。当他将城市 $x$（$1 \\le x \\le N$）指定为度假城市时，以下事件将对每条道路 $i$（$1 \\le i \\le N - 1$）发生：\n\n在城市 $A_i$ 与 $B_i$ 中，设 $a$ 为距离城市 $x$ 更近的城市，$b$ 为距离城市 $x$ 更远的城市。此处，“距离城市 $x$ 更近”是指从该城市出发，到达城市 $x$ 所需经过的道路数量更少。随后，从城市 $b$ 指向城市 $a$ 的车道将被铺设（若尚未铺设）。\n\n因指定度假城市而产生的车道铺设费用将由税收支付。然而，指定后仍保持未铺设状态的车道的铺设费用需由 Mr. K 自掏腰包支付。\n\n现共有 $Q$ 个方案提交给 Mr. K。在第 $j$ 个方案（$1 \\le j \\le Q$）中，他将从无任何度假城市、且所有道路的所有车道均未铺设的初始状态出发，并恰好指定 $E_j$ 座城市为度假城市。但具体指定哪些城市尚未确定。他希望知道，对于每个方案，需由他自掏腰包支付的最小总铺设费用是多少。\n\n请编写一个程序，输入 JOI 国的城市数量、道路信息及各方案信息，计算并输出每个方案中需由 Mr. K 自掏腰包支付的最小总铺设费用。\n", "inputFormat": "从标准输入读取以下数据。输入中的所有值均为整数。\n\n$N$\n\n$A_1\\ B_1\\ C_1\\ D_1$\n\n$\\vdots$\n\n$A_{N-1}\\ B_{N-1}\\ C_{N-1}\\ D_{N-1}$\n\n$Q$\n\n$E_1$\n\n$\\vdots$\n\n$E_Q$", "outputFormat": "向标准输出写入 $Q$ 行。第 $j$ 行（$1 \\le j \\le Q$）应包含第 $j$ 个方案中需由 Mr. K 自掏腰包支付的最小总铺设费用。\n", "hint": "### 样例 1 解释\n\n考虑方案 1：Mr. K 将恰好指定 1 座城市为度假城市。若他指定城市 1 为度假城市，则道路 1 上从城市 2 指向城市 1 的车道、道路 2 上从城市 3 指向城市 1 的车道、以及道路 3 上从城市 4 指向城市 1 的车道将被铺设。因此，以下车道将保持未铺设状态：道路 1 上从城市 1 指向城市 2 的车道、道路 2 上从城市 1 指向城市 3 的车道、以及道路 3 上从城市 1 指向城市 4 的车道。铺设这些车道的总成本为 $1 + 3 + 5 = 9$。不存在任何指定方式能使总成本低于 9。因此，答案为 9。\n\n考虑方案 2：Mr. K 将恰好指定 2 座城市为度假城市。若他指定城市 3 和城市 4 为度假城市，则道路 1 上从城市 1 指向城市 2 的车道将是唯一保持未铺设的车道。铺设该车道的成本为 1。不存在任何指定 2 座城市的方式能使总成本低于 1。因此，答案为 1。\n\n### 约束条件\n\n- $2 \\le N \\le 200000$。\n- $1 \\le A_i \\le N$（$1 \\le i \\le N - 1$）。\n- $1 \\le B_i \\le N$（$1 \\le i \\le N - 1$）。\n- $A_i \\ne B_i$（$1 \\le i \\le N - 1$）。\n- 任意两座城市之间均可通过道路相互到达。\n- $1 \\le C_i \\le 1000000000$（$1 \\le i \\le N - 1$）。\n- $1 \\le D_i \\le 1000000000$（$1 \\le i \\le N - 1$）。\n- $1 \\le Q \\le N$。\n- $1 \\le E_j \\le N$（$1 \\le j \\le Q$）。\n\n### 子任务\n\n1. （6 分）$N \\le 16$。\n2. （7 分）$Q = 1$，$E_1 = 1$。\n3. （9 分）$Q = 1$，$E_1 = 2$。\n4. （17 分）$N \\le 2000$。\n5. （17 分）$Q = 1$。\n6. （44 分）无额外约束。", "locale": "zh-CN"}}}
{"pid": "P14347", "type": "P", "difficulty": 5, "samples": [["8\n11011100\n01101001", "4"], ["13\n1010010010100\n0000111001011", "3"], ["18\n001100010010000110\n110110001000100101", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2019", "JOISC/JOIST（日本）"], "title": "[JOISC 2019] 灯 / Lamps", "background": "", "description": "一条长走廊上排列着 $N$ 盏灯，灯的编号从 $1$ 到 $N$。每盏灯的状态为关闭或开启。存在一种特殊机制可改变灯的状态。在一次操作中，我们可以执行以下三种操作之一：\n\n- 选择满足 $1 \\le p \\le q \\le N$ 的整数 $p$ 和 $q$，并将灯 $p, p+1, \\dots, q$ 全部关闭。\n- 选择满足 $1 \\le p \\le q \\le N$ 的整数 $p$ 和 $q$，并将灯 $p, p+1, \\dots, q$ 全部开启。\n- 选择满足 $1 \\le p \\le q \\le N$ 的整数 $p$ 和 $q$，并将灯 $p, p+1, \\dots, q$ 的状态全部翻转（关闭变开启，开启变关闭）。\n\n灯的当前状态由长度为 $N$ 的字符串 $A$ 表示。若灯 $i$（$1 \\le i \\le N$）处于关闭状态，则字符串 $A$ 的第 $i$ 个字符为 $0$；若处于开启状态，则为 $1$。我们希望将灯的状态变为由长度为 $N$ 的字符串 $B$ 所表示的目标状态，且操作次数尽可能少。若希望灯 $i$（$1 \\le i \\le N$）处于关闭状态，则字符串 $B$ 的第 $i$ 个字符为 $0$；若希望其处于开启状态，则为 $1$。\n\n请编写一个程序，输入灯的数量、当前状态和目标状态，计算并输出达到目标状态所需的最少操作次数。", "inputFormat": "从标准输入读取以下数据：\n\n$N$\n\n$A$\n\n$B$", "outputFormat": "向标准输出写入一行。该行应包含达到目标状态所需的最少操作次数。", "hint": "### 数据范围\n\n- $1 \\le N \\le 1000000$。\n- $A$ 和 $B$ 均为长度为 $N$ 的字符串。\n- 字符串 $A$ 和 $B$ 中的每个字符均为 $0$ 或 $1$。\n\n### 子任务\n\n1. （6 分）$N \\le 18$。\n2. （41 分）$N \\le 2000$。\n3. （4 分）字符串 $A$ 中的每个字符均为 $0$。\n4. （49 分）无额外约束。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2019] 灯 / Lamps", "background": "", "description": "一条长走廊上排列着 $N$ 盏灯，灯的编号从 $1$ 到 $N$。每盏灯的状态为关闭或开启。存在一种特殊机制可改变灯的状态。在一次操作中，我们可以执行以下三种操作之一：\n\n- 选择满足 $1 \\le p \\le q \\le N$ 的整数 $p$ 和 $q$，并将灯 $p, p+1, \\dots, q$ 全部关闭。\n- 选择满足 $1 \\le p \\le q \\le N$ 的整数 $p$ 和 $q$，并将灯 $p, p+1, \\dots, q$ 全部开启。\n- 选择满足 $1 \\le p \\le q \\le N$ 的整数 $p$ 和 $q$，并将灯 $p, p+1, \\dots, q$ 的状态全部翻转（关闭变开启，开启变关闭）。\n\n灯的当前状态由长度为 $N$ 的字符串 $A$ 表示。若灯 $i$（$1 \\le i \\le N$）处于关闭状态，则字符串 $A$ 的第 $i$ 个字符为 $0$；若处于开启状态，则为 $1$。我们希望将灯的状态变为由长度为 $N$ 的字符串 $B$ 所表示的目标状态，且操作次数尽可能少。若希望灯 $i$（$1 \\le i \\le N$）处于关闭状态，则字符串 $B$ 的第 $i$ 个字符为 $0$；若希望其处于开启状态，则为 $1$。\n\n请编写一个程序，输入灯的数量、当前状态和目标状态，计算并输出达到目标状态所需的最少操作次数。", "inputFormat": "从标准输入读取以下数据：\n\n$N$\n\n$A$\n\n$B$", "outputFormat": "向标准输出写入一行。该行应包含达到目标状态所需的最少操作次数。", "hint": "### 数据范围\n\n- $1 \\le N \\le 1000000$。\n- $A$ 和 $B$ 均为长度为 $N$ 的字符串。\n- 字符串 $A$ 和 $B$ 中的每个字符均为 $0$ 或 $1$。\n\n### 子任务\n\n1. （6 分）$N \\le 18$。\n2. （41 分）$N \\le 2000$。\n3. （4 分）字符串 $A$ 中的每个字符均为 $0$。\n4. （49 分）无额外约束。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN"}}}
{"pid": "P14348", "type": "P", "difficulty": 6, "samples": [["3 3\n0 5\n0 5\n2 1 3 3 3\n1 2 0 1\n2 1 3 3 3", "2\n4"], ["5 5\n3 5\n4 8\n2 6\n5 10\n2 5 3 1 10\n2 2 6 5 6\n1 3 4 6\n2 3 3 4 3\n2 4 5 1 5", "4\n3\n2\n3"], ["7 7\n112103440 659752416\n86280800 902409187\n104535475 965602300\n198700180 945132880\n137957976 501365807\n257419446 565237610\n2 4 646977260 7 915994878\n2 1 221570340 6 606208433\n2 7 948545948 4 604273995\n2 7 247791098 5 944822313\n2 7 250362511 2 50167280\n2 3 364109400 4 555412865\n2 7 33882587 7 186961394", "145611455\n0\n447180143\n0\n207252171\n0\n0"], ["7 7\n535825574 705426142\n964175291 996597835\n481817391 649559926\n4519006 410772613\n74521477 274584126\n256535565 899389890\n1 6 511428966 602601933\n1 1 69986642 201421232\n2 3 636443425 4 625975977\n1 6 235225515 405336399\n2 3 866680458 3 701821857\n1 6 180606048 900533151\n1 6 612564160 720179605", "10467449\n164858601"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "线段树", "JOISC/JOIST（日本）"], "title": "[JOISC 2019] 穿越时空 Bitaro / Bitaro, who Leaps through Time", "background": "", "description": "Beaverland 由 $N$ 座城市组成，编号从 $1$ 到 $N$。共有 $N-1$ 条道路连接这些城市。第 $i$ 条道路（$1 \\le i \\le N-1$）双向连接城市 $i$ 和城市 $i+1$。在 Beaverland，他们使用 Byou 作为时间单位。Beaverland 中的每一天长度为 $1000000000$ Byous。每天从时刻 $0$ 开始，到时刻 $x$（$0 \\le x < 1000000000$）称为时间 $x$。通过任意一条道路需要 $1$ Byou，且第 $i$ 条道路每天仅能在时间 $L_i$ 到 $R_i$ 之间通行。具体而言，要通过第 $i$ 条道路，必须在时间 $x$（满足 $L_i \\le x \\le R_i - 1$）从城市 $i$ 或城市 $i+1$ 出发，并在时间 $x+1$ 到达另一座城市。\n\nBitaro 曾是 Beaverland 中一名普通的海狸。然而，为了应对他的迟到问题，他最终习得了“穿越时间”的技能。使用该技能一次，他可以回到 1 Byou 之前的时间。但他无法回到当天之前：如果他在时间 $0$ 到 $1$ 之间使用该技能，他将回到当天的时间 $0$。他只能在位于某座城市时使用该技能。使用该技能不会改变 Bitaro 的位置。\n\nBitaro 在使用该技能时会感到疲惫。为了寻找使用该技能次数更少的旅行方式，他决定进行一个包含 $Q$ 步的思维实验。在思维实验的第 $j$ 步（$1 \\le j \\le Q$），他执行以下操作之一：\n\n- 修改第 $P_j$ 条道路的可通行时间段。修改后，该道路仅能在时间 $S_j$ 到 $E_j$ 之间通行。\n- 假设他在时间 $B_j$ 位于城市 $A_j$，计算到达城市 $C_j$ 且时间为 $D_j$ 的当天所需的最少技能使用次数。\n\n他想知道该思维实验的结果。\n\n请编写一个程序，输入 Beaverland 的城市数量、道路信息以及思维实验的细节，计算并输出该思维实验的结果。", "inputFormat": "从标准输入读取以下数据。输入中的所有值均为整数。\n\n$N\\ Q$\n\n$L_1\\ R_1$\n\n$\\vdots$\n\n$L_{N-1}\\ R_{N-1}$\n\n（Query 1）\n\n$\\vdots$\n\n（Query $Q$）\n\n此处，每个（Query $j$）由 4 或 5 个以空格分隔的整数组成。令 $T_j$ 为其第一个整数。则：\n\n- 若 $T_j = 1$，（Query $j$）包含 4 个整数 $T_j$、$P_j$、$S_j$ 和 $E_j$。这意味着，在思维实验的第 $j$ 步中，第 $P_j$ 条道路的可通行时间段被修改为从时间 $S_j$ 到时间 $E_j$。\n- 若 $T_j = 2$，（Query $j$）包含 5 个整数 $T_j$、$A_j$、$B_j$、$C_j$ 和 $D_j$。这意味着，在思维实验的第 $j$ 步中，你的程序应在假设 Bitaro 在时间 $B_j$ 位于城市 $A_j$ 的前提下，计算在当天时间 $D_j$ 到达城市 $C_j$ 所需的最少技能使用次数。", "outputFormat": "对于每个满足 $T_j = 2$ 的步骤，按顺序在标准输出中输出一行，包含所需的最少技能使用次数。\n", "hint": "### 样例 1 解释\n\n在思维实验的第 1 步中，Bitaro 从城市 1 出发，用 1 Byou 移动到城市 2，再用 1 Byou 从城市 2 移动到城市 3，从而在时间 5 到达城市 3。因此，通过使用技能两次，他可以在时间 3 到达城市 3。\n\n在思维实验的第 2 步中，第 2 条道路的可通行时间段被修改为从时间 0 到时间 1。\n\n在思维实验的第 3 步中，Bitaro 从城市 1 出发，用 1 Byou 移动到城市 2，从而在时间 4 到达城市 2。然后，他使用技能四次，用 1 Byou 移动到城市 3，并等待 2 Byous，从而在时间 3 到达城市 3。\n\n\n### 数据范围\n\n- $1 \\le N \\le 300000$。\n- $1 \\le Q \\le 300000$。\n- $0 \\le L_i < R_i \\le 999999999$（$1 \\le i \\le N-1$）。\n- $1 \\le T_j \\le 2$（$1 \\le j \\le Q$）。\n- $1 \\le P_j \\le N-1$（$1 \\le j \\le Q$，$T_j = 1$）。\n- $0 \\le S_j < E_j \\le 999999999$（$1 \\le j \\le Q$，$T_j = 1$）。\n- $1 \\le A_j \\le N$（$1 \\le j \\le Q$，$T_j = 2$）。\n- $0 \\le B_j \\le 999999999$（$1 \\le j \\le Q$，$T_j = 2$）。\n- $1 \\le C_j \\le N$（$1 \\le j \\le Q$，$T_j = 2$）。\n- $0 \\le D_j \\le 999999999$（$1 \\le j \\le Q$，$T_j = 2$）。\n\n### 子任务\n\n1. （4 分）$N \\le 1000$，$Q \\le 1000$。\n2. （30 分）$T_j = 2$（$1 \\le j \\le Q$）。\n3. （66 分）无额外约束。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2019] 穿越时空 Bitaro / Bitaro, who Leaps through Time", "background": "", "description": "Beaverland 由 $N$ 座城市组成，编号从 $1$ 到 $N$。共有 $N-1$ 条道路连接这些城市。第 $i$ 条道路（$1 \\le i \\le N-1$）双向连接城市 $i$ 和城市 $i+1$。在 Beaverland，他们使用 Byou 作为时间单位。Beaverland 中的每一天长度为 $1000000000$ Byous。每天从时刻 $0$ 开始，到时刻 $x$（$0 \\le x < 1000000000$）称为时间 $x$。通过任意一条道路需要 $1$ Byou，且第 $i$ 条道路每天仅能在时间 $L_i$ 到 $R_i$ 之间通行。具体而言，要通过第 $i$ 条道路，必须在时间 $x$（满足 $L_i \\le x \\le R_i - 1$）从城市 $i$ 或城市 $i+1$ 出发，并在时间 $x+1$ 到达另一座城市。\n\nBitaro 曾是 Beaverland 中一名普通的海狸。然而，为了应对他的迟到问题，他最终习得了“穿越时间”的技能。使用该技能一次，他可以回到 1 Byou 之前的时间。但他无法回到当天之前：如果他在时间 $0$ 到 $1$ 之间使用该技能，他将回到当天的时间 $0$。他只能在位于某座城市时使用该技能。使用该技能不会改变 Bitaro 的位置。\n\nBitaro 在使用该技能时会感到疲惫。为了寻找使用该技能次数更少的旅行方式，他决定进行一个包含 $Q$ 步的思维实验。在思维实验的第 $j$ 步（$1 \\le j \\le Q$），他执行以下操作之一：\n\n- 修改第 $P_j$ 条道路的可通行时间段。修改后，该道路仅能在时间 $S_j$ 到 $E_j$ 之间通行。\n- 假设他在时间 $B_j$ 位于城市 $A_j$，计算到达城市 $C_j$ 且时间为 $D_j$ 的当天所需的最少技能使用次数。\n\n他想知道该思维实验的结果。\n\n请编写一个程序，输入 Beaverland 的城市数量、道路信息以及思维实验的细节，计算并输出该思维实验的结果。", "inputFormat": "从标准输入读取以下数据。输入中的所有值均为整数。\n\n$N\\ Q$\n\n$L_1\\ R_1$\n\n$\\vdots$\n\n$L_{N-1}\\ R_{N-1}$\n\n（Query 1）\n\n$\\vdots$\n\n（Query $Q$）\n\n此处，每个（Query $j$）由 4 或 5 个以空格分隔的整数组成。令 $T_j$ 为其第一个整数。则：\n\n- 若 $T_j = 1$，（Query $j$）包含 4 个整数 $T_j$、$P_j$、$S_j$ 和 $E_j$。这意味着，在思维实验的第 $j$ 步中，第 $P_j$ 条道路的可通行时间段被修改为从时间 $S_j$ 到时间 $E_j$。\n- 若 $T_j = 2$，（Query $j$）包含 5 个整数 $T_j$、$A_j$、$B_j$、$C_j$ 和 $D_j$。这意味着，在思维实验的第 $j$ 步中，你的程序应在假设 Bitaro 在时间 $B_j$ 位于城市 $A_j$ 的前提下，计算在当天时间 $D_j$ 到达城市 $C_j$ 所需的最少技能使用次数。", "outputFormat": "对于每个满足 $T_j = 2$ 的步骤，按顺序在标准输出中输出一行，包含所需的最少技能使用次数。\n", "hint": "### 样例 1 解释\n\n在思维实验的第 1 步中，Bitaro 从城市 1 出发，用 1 Byou 移动到城市 2，再用 1 Byou 从城市 2 移动到城市 3，从而在时间 5 到达城市 3。因此，通过使用技能两次，他可以在时间 3 到达城市 3。\n\n在思维实验的第 2 步中，第 2 条道路的可通行时间段被修改为从时间 0 到时间 1。\n\n在思维实验的第 3 步中，Bitaro 从城市 1 出发，用 1 Byou 移动到城市 2，从而在时间 4 到达城市 2。然后，他使用技能四次，用 1 Byou 移动到城市 3，并等待 2 Byous，从而在时间 3 到达城市 3。\n\n\n### 数据范围\n\n- $1 \\le N \\le 300000$。\n- $1 \\le Q \\le 300000$。\n- $0 \\le L_i < R_i \\le 999999999$（$1 \\le i \\le N-1$）。\n- $1 \\le T_j \\le 2$（$1 \\le j \\le Q$）。\n- $1 \\le P_j \\le N-1$（$1 \\le j \\le Q$，$T_j = 1$）。\n- $0 \\le S_j < E_j \\le 999999999$（$1 \\le j \\le Q$，$T_j = 1$）。\n- $1 \\le A_j \\le N$（$1 \\le j \\le Q$，$T_j = 2$）。\n- $0 \\le B_j \\le 999999999$（$1 \\le j \\le Q$，$T_j = 2$）。\n- $1 \\le C_j \\le N$（$1 \\le j \\le Q$，$T_j = 2$）。\n- $0 \\le D_j \\le 999999999$（$1 \\le j \\le Q$，$T_j = 2$）。\n\n### 子任务\n\n1. （4 分）$N \\le 1000$，$Q \\le 1000$。\n2. （30 分）$T_j = 2$（$1 \\le j \\le Q$）。\n3. （66 分）无额外约束。", "locale": "zh-CN"}}}
{"pid": "P14349", "type": "P", "difficulty": 6, "samples": [["5 3\n2 1\n4 2\n6 4\n8 8\n10 16", "6"], ["8 4\n112103441 501365808\n659752417 137957977\n86280801 257419447\n902409188 565237611\n965602301 689654312\n104535476 646977261\n945132881 114821749\n198700181 915994879", "2323231661"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2019", "四边形不等式", "决策单调性", "JOISC/JOIST（日本）"], "title": "[JOISC 2019] 蛋糕 3 / Cake 3", "background": "", "description": "今天是 IOI-chan 的生日，所以她的哥哥 JOI-kun 预订了她的生日蛋糕。虽然他本打算买一个完整的蛋糕，却误订了 $N$ 块蛋糕。这些蛋糕从 $1$ 到 $N$ 编号，每块蛋糕都有价值和颜色。第 $i$ 块蛋糕（$1 \\le i \\le N$）的价值为 $V_i$，其颜色的深度为 $C_i$。\n\n为了组成一个完整的蛋糕，他决定选择 $M$ 块不同的蛋糕，并将它们按任意顺序排列成环形。他所制作的完整蛋糕的“美丽值”定义为：\n\n$$\n\\sum_{j=1}^{M} V_{k_j} - \\sum_{j=1}^{M} \\left| C_{k_j} - C_{k_{j+1}} \\right|\n$$\n\n如果他选择了蛋糕 $k_1, \\dots, k_M$ 并按此顺序排列（这里我们设 $k_{M+1} = k_1$）。换句话说，完整蛋糕的美丽值等于其所有蛋糕价值之和，减去每两个相邻蛋糕颜色深度之差的绝对值之和。JOI-kun 希望使完整蛋糕尽可能美丽。\n\n请编写一个程序，给定蛋糕总数、组成完整蛋糕所需的蛋糕数，以及每块蛋糕的价值和颜色深度，计算 JOI-kun 能制作出的完整蛋糕的最大美丽值。", "inputFormat": "从标准输入读取以下数据。输入中的所有值均为整数。\n\n$N$ $M$\n\n$V_1$ $C_1$\n\n$\\vdots$\n\n$V_N$ $C_N$\n", "outputFormat": "向标准输出写入一行。输出应包含 JOI-kun 能制作出的完整蛋糕的最大美丽值。", "hint": "### 样例 1 解释\n\n如果 JOI-kun 选择蛋糕 1、3 和 2，并按此顺序排列，则其蛋糕价值之和为 $2 + 6 + 4 = 12$，颜色深度之差的绝对值之和为 $|1 - 4| + |4 - 2| + |2 - 1| = 6$。因此，完整蛋糕的美丽值为 $12 - 6 = 6$。\n\n如果他选择蛋糕 2、3 和 4 并按此顺序排列，也能制作出美丽值为 6 的完整蛋糕。\n\n由于他无法制作出更美丽的完整蛋糕，你应输出 6。\n\n### 数据范围\n\n- $3 \\le N \\le 200\\,000$。\n- $3 \\le M \\le N$。\n- $1 \\le V_i \\le 1\\,000\\,000\\,000$（$1 \\le i \\le N$）。\n- $1 \\le C_i \\le 1\\,000\\,000\\,000$（$1 \\le i \\le N$）。\n\n### 子任务\n\n1. （5 分）$N \\le 100$。\n2. （19 分）$N \\le 2000$。\n3. （76 分）无额外限制。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2019] 蛋糕 3 / Cake 3", "background": "", "description": "今天是 IOI-chan 的生日，所以她的哥哥 JOI-kun 预订了她的生日蛋糕。虽然他本打算买一个完整的蛋糕，却误订了 $N$ 块蛋糕。这些蛋糕从 $1$ 到 $N$ 编号，每块蛋糕都有价值和颜色。第 $i$ 块蛋糕（$1 \\le i \\le N$）的价值为 $V_i$，其颜色的深度为 $C_i$。\n\n为了组成一个完整的蛋糕，他决定选择 $M$ 块不同的蛋糕，并将它们按任意顺序排列成环形。他所制作的完整蛋糕的“美丽值”定义为：\n\n$$\n\\sum_{j=1}^{M} V_{k_j} - \\sum_{j=1}^{M} \\left| C_{k_j} - C_{k_{j+1}} \\right|\n$$\n\n如果他选择了蛋糕 $k_1, \\dots, k_M$ 并按此顺序排列（这里我们设 $k_{M+1} = k_1$）。换句话说，完整蛋糕的美丽值等于其所有蛋糕价值之和，减去每两个相邻蛋糕颜色深度之差的绝对值之和。JOI-kun 希望使完整蛋糕尽可能美丽。\n\n请编写一个程序，给定蛋糕总数、组成完整蛋糕所需的蛋糕数，以及每块蛋糕的价值和颜色深度，计算 JOI-kun 能制作出的完整蛋糕的最大美丽值。", "inputFormat": "从标准输入读取以下数据。输入中的所有值均为整数。\n\n$N$ $M$\n\n$V_1$ $C_1$\n\n$\\vdots$\n\n$V_N$ $C_N$\n", "outputFormat": "向标准输出写入一行。输出应包含 JOI-kun 能制作出的完整蛋糕的最大美丽值。", "hint": "### 样例 1 解释\n\n如果 JOI-kun 选择蛋糕 1、3 和 2，并按此顺序排列，则其蛋糕价值之和为 $2 + 6 + 4 = 12$，颜色深度之差的绝对值之和为 $|1 - 4| + |4 - 2| + |2 - 1| = 6$。因此，完整蛋糕的美丽值为 $12 - 6 = 6$。\n\n如果他选择蛋糕 2、3 和 4 并按此顺序排列，也能制作出美丽值为 6 的完整蛋糕。\n\n由于他无法制作出更美丽的完整蛋糕，你应输出 6。\n\n### 数据范围\n\n- $3 \\le N \\le 200\\,000$。\n- $3 \\le M \\le N$。\n- $1 \\le V_i \\le 1\\,000\\,000\\,000$（$1 \\le i \\le N$）。\n- $1 \\le C_i \\le 1\\,000\\,000\\,000$（$1 \\le i \\le N$）。\n\n### 子任务\n\n1. （5 分）$N \\le 100$。\n2. （19 分）$N \\le 2000$。\n3. （76 分）无额外限制。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN"}}}
{"pid": "P14350", "type": "P", "difficulty": 5, "samples": [["5 4\n1 2\n2 3\n3 4\n3 5\n1\n2\n1\n3\n4", "1"], ["5 4\n1 2\n2 3\n3 4\n4 5\n1\n2\n3\n4\n1", "0"], ["2 2\n1 2\n1\n2", "1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "并查集", "JOISC/JOIST（日本）"], "title": "[JOISC 2019] 合并 / Mergers", "background": "", "description": "JOI 国有 $N$ 个城市，编号从 $1$ 到 $N$，以及 $N-1$ 条高速公路，编号从 $1$ 到 $N-1$。第 $i$ 条高速公路（$1 \\le i \\le N-1$）双向连接城市 $A_i$ 与城市 $B_i$。人们可以通过高速公路在任意两个城市之间通行。\n\n目前，JOI 国由 $K$ 个州组成，编号从 $1$ 到 $K$。城市 $j$（$1 \\le j \\le N$）属于州 $S_j$。每个州至少包含一个城市。\n\nJOI 国总统 Mr. K 担心国家分裂。若能将所有城市划分为 Group X 与 Group Y，且满足以下条件，则称 JOI 国是 **可分的**：\n\n- 任意城市属于 Group X 或 Group Y 之一。\n- Group X 至少包含一个城市。\n- Group Y 至少包含一个城市。\n- 对于任意一个州，该州内所有城市必须属于同一个组。\n- 仅通过 Group X 内的城市，可以在 Group X 内的任意两个城市之间通行。\n- 仅通过 Group Y 内的城市，可以在 Group Y 内的任意两个城市之间通行。\n\nMr. K 计划通过合并州来使 JOI 国不可分。当他合并州时，他选择两个州并将它们合并为一个州；合并后的州包含这两个州的所有城市。Mr. K 希望通过尽可能少的合并次数，使 JOI 国变得不可分。\n\n请注意，若 JOI 国仅剩一个州，则该国不可分。\n\n请编写一个程序，给定城市、高速公路和州的信息，计算使 JOI 国不可分所需的最少合并次数。", "inputFormat": "从标准输入读取以下数据。输入中的所有值均为整数。\n\n$N$ $K$\n\n$A_1$ $B_1$\n\n$\\vdots$\n\n$A_{N-1}$ $B_{N-1}$\n\n$S_1$\n\n$\\vdots$\n\n$S_N$", "outputFormat": "向标准输出写入一个整数，表示使 JOI 国不可分所需的最少合并次数。\n", "hint": "### 限制条件\n\n- $1 \\le N \\le 500\\,000$。\n- $1 \\le K \\le N$。\n- $1 \\le A_i \\le N$（$1 \\le i \\le N-1$）。\n- $1 \\le B_i \\le N$（$1 \\le i \\le N-1$）。\n- 任意两个城市之间均可通过高速公路通行。\n- $1 \\le S_j \\le K$（$1 \\le j \\le N$）。\n- 对于任意 $k$（$1 \\le k \\le K$），存在某个 $j$（$1 \\le j \\le N$）使得 $S_j = k$。\n\n### 子任务\n\n1. （10 分）$N \\le 100$，$K \\le 7$。\n2. （24 分）$N \\le 3\\,000$。\n3. （14 分）$N \\le 100\\,000$，$K \\le 50$。\n4. （22 分）$N \\le 100\\,000$。初始状态下，同一州内的任意两个城市之间最多可通过 100 条高速公路通行。\n5. （30 分）无额外限制。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2019] 合并 / Mergers", "background": "", "description": "JOI 国有 $N$ 个城市，编号从 $1$ 到 $N$，以及 $N-1$ 条高速公路，编号从 $1$ 到 $N-1$。第 $i$ 条高速公路（$1 \\le i \\le N-1$）双向连接城市 $A_i$ 与城市 $B_i$。人们可以通过高速公路在任意两个城市之间通行。\n\n目前，JOI 国由 $K$ 个州组成，编号从 $1$ 到 $K$。城市 $j$（$1 \\le j \\le N$）属于州 $S_j$。每个州至少包含一个城市。\n\nJOI 国总统 Mr. K 担心国家分裂。若能将所有城市划分为 Group X 与 Group Y，且满足以下条件，则称 JOI 国是 **可分的**：\n\n- 任意城市属于 Group X 或 Group Y 之一。\n- Group X 至少包含一个城市。\n- Group Y 至少包含一个城市。\n- 对于任意一个州，该州内所有城市必须属于同一个组。\n- 仅通过 Group X 内的城市，可以在 Group X 内的任意两个城市之间通行。\n- 仅通过 Group Y 内的城市，可以在 Group Y 内的任意两个城市之间通行。\n\nMr. K 计划通过合并州来使 JOI 国不可分。当他合并州时，他选择两个州并将它们合并为一个州；合并后的州包含这两个州的所有城市。Mr. K 希望通过尽可能少的合并次数，使 JOI 国变得不可分。\n\n请注意，若 JOI 国仅剩一个州，则该国不可分。\n\n请编写一个程序，给定城市、高速公路和州的信息，计算使 JOI 国不可分所需的最少合并次数。", "inputFormat": "从标准输入读取以下数据。输入中的所有值均为整数。\n\n$N$ $K$\n\n$A_1$ $B_1$\n\n$\\vdots$\n\n$A_{N-1}$ $B_{N-1}$\n\n$S_1$\n\n$\\vdots$\n\n$S_N$", "outputFormat": "向标准输出写入一个整数，表示使 JOI 国不可分所需的最少合并次数。\n", "hint": "### 限制条件\n\n- $1 \\le N \\le 500\\,000$。\n- $1 \\le K \\le N$。\n- $1 \\le A_i \\le N$（$1 \\le i \\le N-1$）。\n- $1 \\le B_i \\le N$（$1 \\le i \\le N-1$）。\n- 任意两个城市之间均可通过高速公路通行。\n- $1 \\le S_j \\le K$（$1 \\le j \\le N$）。\n- 对于任意 $k$（$1 \\le k \\le K$），存在某个 $j$（$1 \\le j \\le N$）使得 $S_j = k$。\n\n### 子任务\n\n1. （10 分）$N \\le 100$，$K \\le 7$。\n2. （24 分）$N \\le 3\\,000$。\n3. （14 分）$N \\le 100\\,000$，$K \\le 50$。\n4. （22 分）$N \\le 100\\,000$。初始状态下，同一州内的任意两个城市之间最多可通过 100 条高速公路通行。\n5. （30 分）无额外限制。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN"}}}
{"pid": "P14351", "type": "P", "difficulty": 6, "samples": [["4\n1 5\n2 6\n3 4\n7 8", ""]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "交互题", "Special Judge", "JOISC/JOIST（日本）"], "title": "[JOISC 2019] 矿物 / Minerals", "background": "在洛谷上提交本题，需要定义函数 `int Query(int x);`、`void Answer(int a, int b);` 而非引用头文件 `minerals.h`。", "description": "JOI 教授的实验室正在研究 $N$ 种矿物。每种矿物有 2 片样本，总共有 $2N$ 片样本，编号从 $1$ 到 $2N$。\n\n某天，助手 Bitaro 不慎将装有这 $2N$ 片样本的盒子打翻，他已无法分辨哪两片样本属于同一种矿物。\n\n实验室拥有一种设备，可通过测量每种矿物吸收的波长，来统计设备内当前包含的矿物种类数量。Bitaro 的任务是从 $2N$ 片样本中找出所有 $N$ 对同种矿物。初始时，设备内没有放入任何样本。Bitaro 可执行以下操作：\n\n- 将一片样本插入设备中，Bitaro 会得知设备内当前包含的矿物种类数量。\n- 从设备中取出一片样本，Bitaro 会得知设备内当前包含的矿物种类数量。\n\n为避免被 JOI 教授发现 Bitaro 惹出麻烦，他总共最多只能执行 $1\\,000\\,000$ 次操作。\n\n请编写一个程序，给定矿物种类数 $N$，利用该设备，找出所有同种矿物的配对。\n\n### 实现细节\n\n程序应实现以下函数：\n\n- `void Solve(int N)`  \n  此函数在每个测试用例中**恰好被调用一次**。  \n  - 参数 $N$ 表示矿物种类的数量。\n\n你的程序可以调用以下函数：\n\n- `int Query(int x)`  \n  对于你指定的样本编号 $x$，若该样本已在设备中，则将其取出；否则将其插入设备中。然后返回设备中当前包含的矿物种类数量。  \n  - 你通过参数 $x$ 指定样本编号，必须满足 $1 \\le x \\le 2N$。否则，你的程序将被判定为 **Wrong Answer [1]**。\n  - 函数 `Query` 的调用次数不得超过 $1\\,000\\,000$ 次。否则，你的程序将被判定为 **Wrong Answer [2]**。\n- `void Answer(int a, int b)`  \n  使用此函数，你将输出同种矿物的配对。  \n  - 参数 $a$ 和 $b$ 表示第 $a$ 片样本与第 $b$ 片样本属于同一种矿物。它们必须满足 $1 \\le a \\le 2N$ 且 $1 \\le b \\le 2N$。否则，你的程序将被判定为 **Wrong Answer [3]**。  \n  - 若在 $a$ 或 $b$ 中，同一数值出现超过一次，你的程序将被判定为 **Wrong Answer [4]**。  \n  - 若指定的样本属于不同种类的矿物，你的程序将被判定为 **Wrong Answer [5]**。  \n\n函数 `Answer` 必须**恰好被调用 $N$ 次**。若在函数 `Solve` 执行结束时，对 `Answer` 的调用次数不等于 $N$，你的程序将被判定为 **Wrong Answer [6]**。\n\n### 重要提示\n\n- 你的程序可以为内部使用实现其他函数，或使用全局变量。\n- 你的程序**不得**使用标准输入和标准输出，也不得通过任何方式与其他文件通信。但你的程序可以向 stderr 输出调试信息。\n\n### 编译与测试运行\n\n你可以从竞赛网页下载一个归档文件，其中包含用于测试你程序的样例评测器。该归档文件还包含你程序的样例源代码文件。\n\n样例评测器是文件 `grader.cpp`。为测试你的程序，请将 `grader.cpp`、`minerals.cpp` 和 `minerals.h` 放在同一目录下，并运行以下命令编译你的程序：\n\n```\ng++ -std=gnu++14 -O2 -o grader grader.cpp minerals.cpp\n```\n\n当编译成功后，将生成可执行文件 `grader`。\n\n请注意，实际评测器与样例评测器不同。样例评测器将以单进程方式运行，从标准输入读取输入数据，并将结果写入标准输出。", "inputFormat": "样例评测器从标准输入读取以下数据：\n\n$N$\n\n$X_1\\ Y_1$\n\n$\\vdots$\n\n$X_N\\ Y_N$\n\n其中，$X_i$ 和 $Y_i$（$1 \\le i \\le N$）表示第 $X_i$ 片样本与第 $Y_i$ 片样本属于同一种矿物。", "outputFormat": "当程序成功终止时，样例评测器将以下信息写入标准输出（引号仅用于清晰说明）：\n\n- 若你的程序被判定为正确，它将输出调用函数 `Query` 的次数，格式为 “Accepted: 100”。\n- 若你的程序被判定为 **Wrong Answer**，它将输出其类型，格式为 “Wrong Answer [1]”。\n\n若你的程序被判定为多种类型的 **Wrong Answer**，样例评测器仅报告其中一种。", "hint": "### 样例 1 解释\n\n| 调用          | 调用          | 返回值 |\n|:-------------:|:-------------:|:------:|\n| `Solve(4)`    |               |        |\n|               | `Query(1)`    | 1      |\n|               | `Query(2)`    | 2      |\n|               | `Query(5)`    | 2      |\n|               | `Query(2)`    | 1      |\n|               | `Answer(3, 4)`| （无） |\n|               | `Answer(5, 1)`| （无） |\n|               | `Answer(8, 7)`| （无） |\n|               | `Answer(2, 6)`| （无） |\n\n### 数据范围\n\n关于 $X_i$ 和 $Y_i$ 的定义，请参阅“样例评测器的输入”部分。\n\n- $1 \\le N \\le 43\\,000$。\n- $1 \\le X_i \\le 2N$（$1 \\le i \\le N$）。\n- $1 \\le Y_i \\le 2N$（$1 \\le i \\le N$）。\n- $X_i \\ne X_j$（$1 \\le i < j \\le N$）。\n- $Y_i \\ne Y_j$（$1 \\le i < j \\le N$）。\n- $X_i \\ne Y_j$（$1 \\le i \\le N$，$1 \\le j \\le N$）。\n\n### 子任务\n\n1. （6 分）$N \\le 100$。\n2. （25 分）$N \\le 15\\,000$，且对所有 $1 \\le i \\le N$，满足 $1 \\le X_i \\le N$，$N + 1 \\le Y_i \\le 2N$。\n3. （9 分）$N \\le 15\\,000$。\n4. （30 分）$N \\le 38\\,000$。\n5. （5 分）$N \\le 39\\,000$。\n6. （5 分）$N \\le 40\\,000$。\n7. （5 分）$N \\le 41\\,000$。\n8. （5 分）$N \\le 42\\,000$。\n9. （10 分）无额外约束。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2019] 矿物 / Minerals", "background": "在洛谷上提交本题，需要定义函数 `int Query(int x);`、`void Answer(int a, int b);` 而非引用头文件 `minerals.h`。", "description": "JOI 教授的实验室正在研究 $N$ 种矿物。每种矿物有 2 片样本，总共有 $2N$ 片样本，编号从 $1$ 到 $2N$。\n\n某天，助手 Bitaro 不慎将装有这 $2N$ 片样本的盒子打翻，他已无法分辨哪两片样本属于同一种矿物。\n\n实验室拥有一种设备，可通过测量每种矿物吸收的波长，来统计设备内当前包含的矿物种类数量。Bitaro 的任务是从 $2N$ 片样本中找出所有 $N$ 对同种矿物。初始时，设备内没有放入任何样本。Bitaro 可执行以下操作：\n\n- 将一片样本插入设备中，Bitaro 会得知设备内当前包含的矿物种类数量。\n- 从设备中取出一片样本，Bitaro 会得知设备内当前包含的矿物种类数量。\n\n为避免被 JOI 教授发现 Bitaro 惹出麻烦，他总共最多只能执行 $1\\,000\\,000$ 次操作。\n\n请编写一个程序，给定矿物种类数 $N$，利用该设备，找出所有同种矿物的配对。\n\n### 实现细节\n\n程序应实现以下函数：\n\n- `void Solve(int N)`  \n  此函数在每个测试用例中**恰好被调用一次**。  \n  - 参数 $N$ 表示矿物种类的数量。\n\n你的程序可以调用以下函数：\n\n- `int Query(int x)`  \n  对于你指定的样本编号 $x$，若该样本已在设备中，则将其取出；否则将其插入设备中。然后返回设备中当前包含的矿物种类数量。  \n  - 你通过参数 $x$ 指定样本编号，必须满足 $1 \\le x \\le 2N$。否则，你的程序将被判定为 **Wrong Answer [1]**。\n  - 函数 `Query` 的调用次数不得超过 $1\\,000\\,000$ 次。否则，你的程序将被判定为 **Wrong Answer [2]**。\n- `void Answer(int a, int b)`  \n  使用此函数，你将输出同种矿物的配对。  \n  - 参数 $a$ 和 $b$ 表示第 $a$ 片样本与第 $b$ 片样本属于同一种矿物。它们必须满足 $1 \\le a \\le 2N$ 且 $1 \\le b \\le 2N$。否则，你的程序将被判定为 **Wrong Answer [3]**。  \n  - 若在 $a$ 或 $b$ 中，同一数值出现超过一次，你的程序将被判定为 **Wrong Answer [4]**。  \n  - 若指定的样本属于不同种类的矿物，你的程序将被判定为 **Wrong Answer [5]**。  \n\n函数 `Answer` 必须**恰好被调用 $N$ 次**。若在函数 `Solve` 执行结束时，对 `Answer` 的调用次数不等于 $N$，你的程序将被判定为 **Wrong Answer [6]**。\n\n### 重要提示\n\n- 你的程序可以为内部使用实现其他函数，或使用全局变量。\n- 你的程序**不得**使用标准输入和标准输出，也不得通过任何方式与其他文件通信。但你的程序可以向 stderr 输出调试信息。\n\n### 编译与测试运行\n\n你可以从竞赛网页下载一个归档文件，其中包含用于测试你程序的样例评测器。该归档文件还包含你程序的样例源代码文件。\n\n样例评测器是文件 `grader.cpp`。为测试你的程序，请将 `grader.cpp`、`minerals.cpp` 和 `minerals.h` 放在同一目录下，并运行以下命令编译你的程序：\n\n```\ng++ -std=gnu++14 -O2 -o grader grader.cpp minerals.cpp\n```\n\n当编译成功后，将生成可执行文件 `grader`。\n\n请注意，实际评测器与样例评测器不同。样例评测器将以单进程方式运行，从标准输入读取输入数据，并将结果写入标准输出。", "inputFormat": "样例评测器从标准输入读取以下数据：\n\n$N$\n\n$X_1\\ Y_1$\n\n$\\vdots$\n\n$X_N\\ Y_N$\n\n其中，$X_i$ 和 $Y_i$（$1 \\le i \\le N$）表示第 $X_i$ 片样本与第 $Y_i$ 片样本属于同一种矿物。", "outputFormat": "当程序成功终止时，样例评测器将以下信息写入标准输出（引号仅用于清晰说明）：\n\n- 若你的程序被判定为正确，它将输出调用函数 `Query` 的次数，格式为 “Accepted: 100”。\n- 若你的程序被判定为 **Wrong Answer**，它将输出其类型，格式为 “Wrong Answer [1]”。\n\n若你的程序被判定为多种类型的 **Wrong Answer**，样例评测器仅报告其中一种。", "hint": "### 样例 1 解释\n\n| 调用          | 调用          | 返回值 |\n|:-------------:|:-------------:|:------:|\n| `Solve(4)`    |               |        |\n|               | `Query(1)`    | 1      |\n|               | `Query(2)`    | 2      |\n|               | `Query(5)`    | 2      |\n|               | `Query(2)`    | 1      |\n|               | `Answer(3, 4)`| （无） |\n|               | `Answer(5, 1)`| （无） |\n|               | `Answer(8, 7)`| （无） |\n|               | `Answer(2, 6)`| （无） |\n\n### 数据范围\n\n关于 $X_i$ 和 $Y_i$ 的定义，请参阅“样例评测器的输入”部分。\n\n- $1 \\le N \\le 43\\,000$。\n- $1 \\le X_i \\le 2N$（$1 \\le i \\le N$）。\n- $1 \\le Y_i \\le 2N$（$1 \\le i \\le N$）。\n- $X_i \\ne X_j$（$1 \\le i < j \\le N$）。\n- $Y_i \\ne Y_j$（$1 \\le i < j \\le N$）。\n- $X_i \\ne Y_j$（$1 \\le i \\le N$，$1 \\le j \\le N$）。\n\n### 子任务\n\n1. （6 分）$N \\le 100$。\n2. （25 分）$N \\le 15\\,000$，且对所有 $1 \\le i \\le N$，满足 $1 \\le X_i \\le N$，$N + 1 \\le Y_i \\le 2N$。\n3. （9 分）$N \\le 15\\,000$。\n4. （30 分）$N \\le 38\\,000$。\n5. （5 分）$N \\le 39\\,000$。\n6. （5 分）$N \\le 40\\,000$。\n7. （5 分）$N \\le 41\\,000$。\n8. （5 分）$N \\le 42\\,000$。\n9. （10 分）无额外约束。", "locale": "zh-CN"}}}
{"pid": "P14352", "type": "P", "difficulty": 4, "samples": [["4 5", "24"], ["3 1", "4"], ["30 1", "536870912"], ["99 37", "286701794"], ["1000000000000000000 1919810", "235483917"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["排序", "组合数学"], "title": "排序", "background": "", "description": "对于一个长度为 $n$ 的排列 $a$，定义一个排序算法 $A(k)$ 如下：\n\n- 执行 $k$ 轮如下操作：\n  - 依次从 $1\\sim n-1$ 枚举 $i$：\n    - 若 $a_i>a_{i+1}$，则交换 $a_i$ 和 $a_{i+1}$。\n   \n给定 $n$ 和 $k$，求出有多少个长度为 $n$ 的排列 $a$ **执行**如上排序算法 $A(k)$ 后对于任意满足 $1\\leq i<n$ 的 $i$ 均满足 $a_i<a_{i+1}$，答案对 $998244353$ 取模。", "inputFormat": "共一行两个数 $n,k$，意义同题目描述。", "outputFormat": "输出一个非负整数表示符合条件的排列的个数，对 $998244353$ 取模。", "hint": "**【样例解释 #1】**\n\n所有的排列都符合要求。\n\n该样例满足测试点 $7$ 的限制。\n\n**【样例解释 #2】**\n\n在所有的排列中，有以下排列满足要求。\n\n$[1,2,3],[1,3,2],[2,1,3],[3,1,2]$。\n\n所以答案为 $4$。\n\n该样例满足测试点 $14$ 的限制。\n\n**【数据范围】**\n\n对于所有测试数据：$1\\leq n\\leq 10^{18}$，$1\\leq k\\leq 2\\times 10^7$。\n\n对于测试点 $1\\sim 10$：$k>n$。\n\n对于测试点 $11\\sim 65$：$k\\leq n\\leq 10$。\n\n对于测试点 $66\\sim 80$：$n\\leq 100$，$k=1$。\n\n对于测试点 $81\\sim 90$：$n\\leq 100$。\n\n对于测试点 $91\\sim 95$：$n\\leq 10^7$。\n\n对于测试点 $96\\sim 100$：无特殊性质。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "排序", "background": "", "description": "对于一个长度为 $n$ 的排列 $a$，定义一个排序算法 $A(k)$ 如下：\n\n- 执行 $k$ 轮如下操作：\n  - 依次从 $1\\sim n-1$ 枚举 $i$：\n    - 若 $a_i>a_{i+1}$，则交换 $a_i$ 和 $a_{i+1}$。\n   \n给定 $n$ 和 $k$，求出有多少个长度为 $n$ 的排列 $a$ **执行**如上排序算法 $A(k)$ 后对于任意满足 $1\\leq i<n$ 的 $i$ 均满足 $a_i<a_{i+1}$，答案对 $998244353$ 取模。", "inputFormat": "共一行两个数 $n,k$，意义同题目描述。", "outputFormat": "输出一个非负整数表示符合条件的排列的个数，对 $998244353$ 取模。", "hint": "**【样例解释 #1】**\n\n所有的排列都符合要求。\n\n该样例满足测试点 $7$ 的限制。\n\n**【样例解释 #2】**\n\n在所有的排列中，有以下排列满足要求。\n\n$[1,2,3],[1,3,2],[2,1,3],[3,1,2]$。\n\n所以答案为 $4$。\n\n该样例满足测试点 $14$ 的限制。\n\n**【数据范围】**\n\n对于所有测试数据：$1\\leq n\\leq 10^{18}$，$1\\leq k\\leq 2\\times 10^7$。\n\n对于测试点 $1\\sim 10$：$k>n$。\n\n对于测试点 $11\\sim 65$：$k\\leq n\\leq 10$。\n\n对于测试点 $66\\sim 80$：$n\\leq 100$，$k=1$。\n\n对于测试点 $81\\sim 90$：$n\\leq 100$。\n\n对于测试点 $91\\sim 95$：$n\\leq 10^7$。\n\n对于测试点 $96\\sim 100$：无特殊性质。", "locale": "zh-CN"}}}
{"pid": "P14353", "type": "P", "difficulty": 5, "samples": [["5 0\n1 2 3 4 5", "14"], ["8 0\n5 2 7 1 4 3 8 6", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": [], "title": "重排", "background": null, "description": "给定长度为 $n$ 的正整数序列 $a$，求 $g(a)$ 的值：\n\n$$\ng(a)=\\max_{a'}\\{f(a')\\}\\\\\nf(a)=\\sum_{i=2}^{n} |a_{i}-a_{i-1}|\n$$\n\n其中，$a'$ 是序列 $a$ 经过任意重排后得到的任意一个序列。\n\n但是这实在是一个三岁小宝宝都会的简单题，因此你想对 $m$ 个序列都求出上述式子的最大值，这 $m$ 个序列满足以下条件。\n\n- 第 $i$ 个序列 $p_i$ 长度为 $i$。\n- 第一个序列 $p_1$ 为 $[b'_1=b_1]$。\n- 第 $i$（$2\\leq i\\leq m$）个序列 $p_i$ 满足：对于任意满足 $1\\leq j<i$ 的正整数 $j$ 满足 $p_{i,j}=p_{i-1,j}$，且 $p_{i,i} = b'_i=b_i\\oplus (T\\cdot g(p_{i-1}))$。\n\n其中，$\\oplus$ 表示二进制按位异或。", "inputFormat": "第一行两个非负整数 $m$ 和 $T$，分别表示你需要求出重排后 $f$ 最大值的序列个数以及生成序列参数。\n\n第二行 $m$ 个非负整数表示 $b_1,\\dots,b_m$。\n\n**注意：【数据范围】一节仅对 $b'_i$ 的范围做出了保证，没有对 $b_i$ 的范围做出保证。**", "outputFormat": "共一行一个非负整数，为 $\\oplus_{i=1}^{m} g(p_i)$。", "hint": "**【样例解释 #1】**\n\n$g(p_1),g(p_2),\\dots,g(p_m)$ 分别为 $0,1,3,7,11$。\n\n令 $p'_i$ 为 $p_i$ 重排后**任意**满足 $f(p'_i)$ 最大的序列。\n\n$p_1=[1]$，$p'_1=[1]$，$f(p'_1)=0$。\n\n$p_2=[1,2]$，$p'_2=[1,2]$，$f(p'_2)=|1-2|=1$。\n\n$p_3=[1,2,3]$，$p'_3=[1,3,2]$，$f(p'_3)=|1-3|+|3-2|=3$。\n\n$p_4=[1,2,3,4]$，$p'_4=[3,1,4,2]$，$f(p'_4)=|3-1|+|1-4|+|4-2|=7$。\n\n$p_5=[1,2,3,4,5]$，$p'_5=[4,2,5,1,3]$，$f(p'_5)=|4-2|+|2-5|+|5-1|+|1-3|=11$。\n\n该样例满足测试点 $1$ 的限制。\n\n**【样例解释 #2】**\n\n$g(p_1),g(p_2),\\dots,g(p_m)$ 分别为 $0,3,8,15,17,19,27,31$。\n\n该样例满足测试点 $3$ 的限制。\n\n**【数据范围】**\n\n对于全部测试点：$1\\leq m\\leq 3\\times 10^6$，$1\\leq b'_i\\leq 10^9$，$T\\in \\{0,1\\}$。\n\n| 测试点编号  |    $m\\leq$     | $T=$ | 特殊性质 |\n| :---------: | :------------: | :--: | :------: |\n|  $1$  |      $8$       | $0$  |    AB    |\n|  $2$  |     $100$      | $0$  |    AB    |\n|  $3$  |     $10^3$     | $0$  |    AB    |\n| $4$  | $2\\times 10^5$ | $0$  |    AB    |\n| $5$ | $2\\times 10^5$ | $0$  |    A     |\n| $6$ | $2\\times 10^5$ | $1$  |    AB    |\n| $7$ | $2\\times 10^5$ | $1$  |    A     |\n| $8$ | $2\\times 10^5$ | $1$  |    无    |\n| $9$ |     $10^6$     | $1$  |    无    |\n| $10$ | $3\\times 10^6$ | $1$  |    无    |\n\n特殊性质 A：$b'_i\\leq m$（$1\\leq i\\leq m$）。\n\n特殊性质 B：$b'_i\\neq b'_j$（$1\\leq i<j\\leq m$）。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "重排", "background": null, "description": "给定长度为 $n$ 的正整数序列 $a$，求 $g(a)$ 的值：\n\n$$\ng(a)=\\max_{a'}\\{f(a')\\}\\\\\nf(a)=\\sum_{i=2}^{n} |a_{i}-a_{i-1}|\n$$\n\n其中，$a'$ 是序列 $a$ 经过任意重排后得到的任意一个序列。\n\n但是这实在是一个三岁小宝宝都会的简单题，因此你想对 $m$ 个序列都求出上述式子的最大值，这 $m$ 个序列满足以下条件。\n\n- 第 $i$ 个序列 $p_i$ 长度为 $i$。\n- 第一个序列 $p_1$ 为 $[b'_1=b_1]$。\n- 第 $i$（$2\\leq i\\leq m$）个序列 $p_i$ 满足：对于任意满足 $1\\leq j<i$ 的正整数 $j$ 满足 $p_{i,j}=p_{i-1,j}$，且 $p_{i,i} = b'_i=b_i\\oplus (T\\cdot g(p_{i-1}))$。\n\n其中，$\\oplus$ 表示二进制按位异或。", "inputFormat": "第一行两个非负整数 $m$ 和 $T$，分别表示你需要求出重排后 $f$ 最大值的序列个数以及生成序列参数。\n\n第二行 $m$ 个非负整数表示 $b_1,\\dots,b_m$。\n\n**注意：【数据范围】一节仅对 $b'_i$ 的范围做出了保证，没有对 $b_i$ 的范围做出保证。**", "outputFormat": "共一行一个非负整数，为 $\\oplus_{i=1}^{m} g(p_i)$。", "hint": "**【样例解释 #1】**\n\n$g(p_1),g(p_2),\\dots,g(p_m)$ 分别为 $0,1,3,7,11$。\n\n令 $p'_i$ 为 $p_i$ 重排后**任意**满足 $f(p'_i)$ 最大的序列。\n\n$p_1=[1]$，$p'_1=[1]$，$f(p'_1)=0$。\n\n$p_2=[1,2]$，$p'_2=[1,2]$，$f(p'_2)=|1-2|=1$。\n\n$p_3=[1,2,3]$，$p'_3=[1,3,2]$，$f(p'_3)=|1-3|+|3-2|=3$。\n\n$p_4=[1,2,3,4]$，$p'_4=[3,1,4,2]$，$f(p'_4)=|3-1|+|1-4|+|4-2|=7$。\n\n$p_5=[1,2,3,4,5]$，$p'_5=[4,2,5,1,3]$，$f(p'_5)=|4-2|+|2-5|+|5-1|+|1-3|=11$。\n\n该样例满足测试点 $1$ 的限制。\n\n**【样例解释 #2】**\n\n$g(p_1),g(p_2),\\dots,g(p_m)$ 分别为 $0,3,8,15,17,19,27,31$。\n\n该样例满足测试点 $3$ 的限制。\n\n**【数据范围】**\n\n对于全部测试点：$1\\leq m\\leq 3\\times 10^6$，$1\\leq b'_i\\leq 10^9$，$T\\in \\{0,1\\}$。\n\n| 测试点编号  |    $m\\leq$     | $T=$ | 特殊性质 |\n| :---------: | :------------: | :--: | :------: |\n|  $1$  |      $8$       | $0$  |    AB    |\n|  $2$  |     $100$      | $0$  |    AB    |\n|  $3$  |     $10^3$     | $0$  |    AB    |\n| $4$  | $2\\times 10^5$ | $0$  |    AB    |\n| $5$ | $2\\times 10^5$ | $0$  |    A     |\n| $6$ | $2\\times 10^5$ | $1$  |    AB    |\n| $7$ | $2\\times 10^5$ | $1$  |    A     |\n| $8$ | $2\\times 10^5$ | $1$  |    无    |\n| $9$ |     $10^6$     | $1$  |    无    |\n| $10$ | $3\\times 10^6$ | $1$  |    无    |\n\n特殊性质 A：$b'_i\\leq m$（$1\\leq i\\leq m$）。\n\n特殊性质 B：$b'_i\\neq b'_j$（$1\\leq i<j\\leq m$）。", "locale": "zh-CN"}}}
{"pid": "P14354", "type": "P", "difficulty": 7, "samples": [["0 5\n2 2\n2 4\n3 5\n3 5\n1 3 5\n2 3 4 5 6\n4 4\n1 4 5 9\n2 3 7 7\n3 8\n7 9 9\n4 4 4 4 8 8 8 8\n5 4\n2 4 5 7 9\n3 6 8 10", "7\n6\n8\n13\n12"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["集训队互测", "2025", "交互题", "Special Judge"], "title": "[集训队互测 2025] 怦然心动", "background": "Some of us get dipped in flat, some in satin, some in gloss. But every once in a while you find someone who's iridescent, and when you do, nothing will ever compare. [Flipped](https://www.bilibili.com/bangumi/play/ep291708)\n\n**这是一道交互题，仅支持 C++ 提交。在洛谷上提交该试题时，请使用不低于 C++17 的语言标准，无需引入头文件 flipped.h，而是在程序开头添加 `std::pair<int,int> move(int t,int x);\n`**。\n", "description": "小 $\\delta$ 需要陪小 $\\tau$ 去购物。小 $\\tau$ 想要买一件衣服和一条裤子。商场里有 $n$ 件衣服，价格分别为 $a_0, a_1, \\cdots, a_{n-1}$，以及 $m$ 条裤子，价格分别为 $b_0, b_1, \\cdots, b_{m-1}$。\n\n小 $\\tau$ 希望买到尽可能贵的衣物，但最终是小 $\\delta$ 结账，而小 $\\delta$ 不希望花太多的钱。因此，两人决定在购物之前通过一个游戏决定需要买什么东西。\n\n这个游戏由两人交替行动，小 $\\tau$ 先手，初始时候选清单包括商场里的所有衣服和裤子。每次操作的人会选择一件衣服或一条裤子，并将它从候选清单中永久删除。两人事先约定好了一个阈值 $B$，表示小 $\\delta$ 能接受的最大价格。游戏的胜负判定标准如下：\n\n1. 如果在任意时刻，不存在任何衣服，或不存在任何裤子了，那么他们只能不去购物。此时小 $\\delta$ 不会破产，但小 $\\tau$ 没有买到她想要的衣物，因此视作小 $\\delta$ 获胜。\n\n2. 否则如果在任意时刻，对于所有从剩余的衣服与裤子中分别选择一件的方案，都满足衣服和裤子的价格之和 $\\leq B$，小 $\\delta$ 可以在不破产的情况下满足 $\\tau$ 的要求，但小 $\\tau$ 不得不接受质量稍差的衣物，因此视作小 $\\delta$ 获胜。\n\n3. 否则如果在任意时刻，对于所有从剩余的衣服与裤子中分别选择一件的方案，都满足衣服和裤子的价格之和 $> B$，小 $\\delta$ 会意识到他无法拥有足够多的钱以满足小 $\\tau$。但由于小 $\\tau$ 对于他非常重要，他只得四处借钱去结账，但此时小 $\\tau$ 会很开心，因此视作小 $\\tau$ 获胜。\n\n形式化地，每次可以选择一个 $a_i (0 \\leq i < n)$ 或者 $b_i (0 \\leq i < m)$，并将其从对应序列中删除（并将 $n, m$ 对应地 $-1$）。如果任意时刻 $n = 0$ 或 $m = 0$ 或 $\\forall_{0 \\leq i < n, 0 \\leq j < m} a_i + b_j \\leq B$，则小 $\\delta$ 获胜。否则如果任意时刻 $\\forall_{0 \\leq i < n, 0 \\leq j < m} a_i + b_j > B$，则小 $\\tau$ 获胜。\n\n请注意，如果没有人操作时的初始局面满足某个判定标准，则游戏会依据该判定标准直接结束。\n\n现在小 $\\delta$ 已经列出了所有 $a_i$ 和 $b_j$，他想在游戏开始前知道，能够使得他保证获胜的最小阈值 $B$，这样他才能提前准备好足够的钱。有些时候，他还希望你给出一个具体的游戏过程，使得他能够赢下游戏。\n\n### 实现细节\n\n你不需要也不应该实现主函数。你需要实现以下函数：\n\n```cpp\nint solve(std::vector<int> a,std::vector<int> b);\n```\n\n这个函数需要返回给定局面的最小阈值 $B$。$a, b$ 即为题面中给定的初始序列 $\\{a_i\\}$ 与 $\\{b_i\\}$。**保证给定的序列按照单调递增顺序排序。**\n\n你还需要实现函数：\n\n```cpp\nvoid play(std::vector<int> a,std::vector<int> b,int B);\n```\n\n在这个函数中，你需要与交互库玩游戏，其中 $a, b$ 为给定的初始序列 $\\{a_i\\}$ 与 $\\{b_i\\}$，$B$ 为给定的阈值。**保证给定的序列按照单调递增顺序排序。**\n\n你可以调用函数\n\n```cpp\nstd::pair<int,int> move(int t,int x);\n```\n\n进行一步操作，并获得交互库的下一步操作。其中 $t = 0$ 表示你选择了序列 $a$，$t = 1$ 表示你选择了序列 $b$，而 $x$ 表示你选择的是对应序列中的第几个元素（编号从 0 开始）。交互库会返回一个 `std::pair<int,int>` $(t, x)$，含义如下：\n\n1. 如果 $(t, x) = (-1, -1)$，则表示你的操作不合法，或游戏已经结束（无论是你操作后结束，还是交互库再操作后结束），此时你应该直接返回。\n\n2. 否则 $(t, x)$ 用和之前一样的格式表示了先手进行的下一步操作。你需要继续进行交互的过程。\n\n请注意，在删除一个元素后，剩余的元素会按照原来的顺序拼接形成一个新的序列，所有操作的下标均按照最新的序列中的下标表示。\n\n具体的游戏过程如下：\n\n首先，你需要判定小 $\\delta$（后手）是否能够获胜。如果你认为不能获胜，请调用一次 $\\text{move}(0, 0)$ 并返回（此时 $\\text{move}$ 函数的返回值并不重要）。特别地，如果在游戏开始前小 $\\tau$ 已经获胜，同样视作这种情况。\n\n否则，请调用一次 $\\text{move}(1, 0)$，交互库会按照之前的格式返回交互库的第一步操作。特别地，如果游戏开始之前，小 $\\delta$ 已经获胜了，交互库会返回 $(-1, -1)$，此时请在调用 $\\text{move}(1, 0)$ 后立即返回。\n\n在这之后，你需要不断调用 $\\text{move}$ 来与交互库进行游戏，直到交互库返回 $(-1, -1)$。注意你不需要判定游戏是否结束，交互库会自动帮你判定。\n\n在一组测试数据中可能会多次调用 $\\text{solve}$ 或 $\\text{play}$ 函数，不同的调用之间可能会保留对全局变量的修改，请注意多测清空问题。\n\n下发文件中提供了一个参考实现 flipped.cpp。这个程序对于求值部分会返回 $114514$，而对于交互部分，会始终认为有解，并选择某个序列的最后一个元素将其删除。可以参考样例程序理解交互过程。\n\n### 测试程序方式\n\n下发文件中提供了一个交互库的参考实现 grader.cpp。最终测试时所用的交互库实现与该实现不同，因此选手的解法不应依赖交互库的具体实现。\n\n你需要在本题目录下使用以下编译命令得到可执行程序：\n\n```cpp\ng++ flipped.cpp grader.cpp -o flipped -O2\n```\n\n样例交互库将按照如下格式进行测试：\n\n首先读入一个变量 $o = 0/1$，其中 $o = 0$ 表示进行的是求值部分的测试，$o = 1$ 表示进行的是交互部分的测试。\n\n接下来，如果 $o = 0$，则：\n\n- 读入一个整数 $T$，表示测试数据组数，对于每组数据：\n- 读入两个整数 $n, m$，表示两个序列的大小。\n- 接下来一行读入 $n$ 个单调递增的整数 $a_1, a_2, \\cdots, a_n$，表示传入的序列 $a$。\n- 接下来一行读入 $m$ 个单调递增的整数 $b_1, b_2, \\cdots, b_m$，表示传入的序列 $b$。\n- 交互库会自动帮你调用 $\\text{solve}(a, b)$，并将返回的结果写入标准输出。\n\n如果 $o = 1$，则：\n\n- 读入一个整数 $T$，表示测试数据组数，对于每组数据：\n- 读入四个整数 $n, m, B, t$，表示两个序列的大小，给定的阈值 $B$，以及 $t = 0/1$ 表示当前局面是否为后手必胜（$t = 1$ 则后手必胜，$t = 0$ 则先手必胜）。\n- 接下来一行读入 $n$ 个单调递增的整数 $a_1, a_2, \\cdots, a_n$，表示传入的序列 $a$。\n- 接下来一行读入 $m$ 个单调递增的整数 $b_1, b_2, \\cdots, b_m$，表示传入的序列 $b$。\n- 交互库会调用 $\\text{play}(a, b, B)$ 并与你进行交互，对于每组数据，交互库的输出如下：\n- 如果你在第一次调用时没有正确判定是否必胜，交互库会输出 $\\text{Wrong Answer}$。\n- 如果你的操作不合法，交互库会输出 $\\text{Invalid Operation: MESSAGE}$，其中 $\\text{MESSAGE}$ 为用英文表达的不合法原因。如不理解英文，请自行查看 $\\text{grader.cpp}$。\n- 如果你的所有操作均合法，但最终没有获胜（包括在游戏没有结束时提前返回），交互库会输出 $\\text{You didn't win}$。\n- 如果你的所有操作均合法，且最终获胜，交互库会输出 $\\text{OK}$。\n\n请注意，由于题目保证了传入 $\\text{solve}$ 的 $a, b$ 序列均递增排列，请保证输入的 $a, b$ 也按照递增顺序排列，否则可能会出现不可预料的结果。同时，如果你尝试进行不合法的交互行为，也可能会出现不可预料的结果，所有潜在的后果请自行承担。\n\n样例交互库使用的策略是非常简单的，你可以根据自己的需求自行改动样例交互库的策略。最终评测时，交互库会使用不一样的策略，但请注意，**最终评测时，交互库不一定会使用最优策略**，你的代码需要能够应对任何交互库可能的操作。", "inputFormat": "见【测试程序方式】。", "outputFormat": "见【测试程序方式】。", "hint": "选手不应该通过非法方式获得交互库的内部信息，或者以任何形式攻击交互库（包括但不限于与标准 IO 进行交互），这种行为视为作弊。\n\n保证在所有操作合法的情况下，交互库不会使用超过 $0.5$s 的时间，也不会使用超过 $128$MB 的空间。也即，你至少有 $1.5$s 的时间和 $384$MB 的内存可以使用。\n\n对于所有数据，满足 $1 \\leq T \\leq 10^5$, $n, m \\geq 1$, $2 \\leq \\sum n + m \\leq 5 \\times 10^5$, $1 \\leq a_i, b_i \\leq 10^9$, $1 \\leq B \\leq 2 \\times 10^9$。\n\n下表中给出了所有子任务的数据范围，表格中的数字表示对应子任务的分值。其中：\n\n- “求值”一列对应的子任务中，交互库仅会调用 $\\text{solve}$ 函数，你能够获得分数当且仅当对于该子任务的所有 $\\text{solve}$ 函数都返回了正确的结果。\n- “交互”一列对应的子任务中，交互库仅会调用 $\\text{play}$ 函数，你能够获得分数当且仅当对于该子任务的所有 $\\text{play}$ 的调用，都能正确判定游戏的结果，且对于可以获胜的数据，能够成功完成游戏并最终获胜。\n\n本题采用子任务捆绑测试，有子任务依赖。具体地，每个子任务将依赖所有在其左上方的子任务。特别地，这意味着所有交互部分的子任务会依赖与其数据规模相同的求值部分子任务。\n\n在洛谷评测中，子任务编号将从左上至右下依次编号为 $1 \\sim 10$（例如第三档部分分的交互部分子任务编号为 $6$）。\n\n| $n + m \\leq$ | $\\sum n + m \\leq$ | 求值 | 交互 |\n| :--: | :--: | :--: | :--: |\n| $50$ | $1000$ | $3$ | $2$ |\n| $500$ | $5000$ | $13$ | $7$ |\n| $2500$ | $10^4$ | $15$ | $10$ |\n| $10^5$ | $5 \\times 10^5$ | $14$ | $8$ |\n| $5 \\times 10^5$ | $5 \\times 10^5$ | $12$ | $16$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[集训队互测 2025] 怦然心动", "background": "Some of us get dipped in flat, some in satin, some in gloss. But every once in a while you find someone who's iridescent, and when you do, nothing will ever compare. [Flipped](https://www.bilibili.com/bangumi/play/ep291708)\n\n**这是一道交互题，仅支持 C++ 提交。在洛谷上提交该试题时，请使用不低于 C++17 的语言标准，无需引入头文件 flipped.h，而是在程序开头添加 `std::pair<int,int> move(int t,int x);\n`**。\n", "description": "小 $\\delta$ 需要陪小 $\\tau$ 去购物。小 $\\tau$ 想要买一件衣服和一条裤子。商场里有 $n$ 件衣服，价格分别为 $a_0, a_1, \\cdots, a_{n-1}$，以及 $m$ 条裤子，价格分别为 $b_0, b_1, \\cdots, b_{m-1}$。\n\n小 $\\tau$ 希望买到尽可能贵的衣物，但最终是小 $\\delta$ 结账，而小 $\\delta$ 不希望花太多的钱。因此，两人决定在购物之前通过一个游戏决定需要买什么东西。\n\n这个游戏由两人交替行动，小 $\\tau$ 先手，初始时候选清单包括商场里的所有衣服和裤子。每次操作的人会选择一件衣服或一条裤子，并将它从候选清单中永久删除。两人事先约定好了一个阈值 $B$，表示小 $\\delta$ 能接受的最大价格。游戏的胜负判定标准如下：\n\n1. 如果在任意时刻，不存在任何衣服，或不存在任何裤子了，那么他们只能不去购物。此时小 $\\delta$ 不会破产，但小 $\\tau$ 没有买到她想要的衣物，因此视作小 $\\delta$ 获胜。\n\n2. 否则如果在任意时刻，对于所有从剩余的衣服与裤子中分别选择一件的方案，都满足衣服和裤子的价格之和 $\\leq B$，小 $\\delta$ 可以在不破产的情况下满足 $\\tau$ 的要求，但小 $\\tau$ 不得不接受质量稍差的衣物，因此视作小 $\\delta$ 获胜。\n\n3. 否则如果在任意时刻，对于所有从剩余的衣服与裤子中分别选择一件的方案，都满足衣服和裤子的价格之和 $> B$，小 $\\delta$ 会意识到他无法拥有足够多的钱以满足小 $\\tau$。但由于小 $\\tau$ 对于他非常重要，他只得四处借钱去结账，但此时小 $\\tau$ 会很开心，因此视作小 $\\tau$ 获胜。\n\n形式化地，每次可以选择一个 $a_i (0 \\leq i < n)$ 或者 $b_i (0 \\leq i < m)$，并将其从对应序列中删除（并将 $n, m$ 对应地 $-1$）。如果任意时刻 $n = 0$ 或 $m = 0$ 或 $\\forall_{0 \\leq i < n, 0 \\leq j < m} a_i + b_j \\leq B$，则小 $\\delta$ 获胜。否则如果任意时刻 $\\forall_{0 \\leq i < n, 0 \\leq j < m} a_i + b_j > B$，则小 $\\tau$ 获胜。\n\n请注意，如果没有人操作时的初始局面满足某个判定标准，则游戏会依据该判定标准直接结束。\n\n现在小 $\\delta$ 已经列出了所有 $a_i$ 和 $b_j$，他想在游戏开始前知道，能够使得他保证获胜的最小阈值 $B$，这样他才能提前准备好足够的钱。有些时候，他还希望你给出一个具体的游戏过程，使得他能够赢下游戏。\n\n### 实现细节\n\n你不需要也不应该实现主函数。你需要实现以下函数：\n\n```cpp\nint solve(std::vector<int> a,std::vector<int> b);\n```\n\n这个函数需要返回给定局面的最小阈值 $B$。$a, b$ 即为题面中给定的初始序列 $\\{a_i\\}$ 与 $\\{b_i\\}$。**保证给定的序列按照单调递增顺序排序。**\n\n你还需要实现函数：\n\n```cpp\nvoid play(std::vector<int> a,std::vector<int> b,int B);\n```\n\n在这个函数中，你需要与交互库玩游戏，其中 $a, b$ 为给定的初始序列 $\\{a_i\\}$ 与 $\\{b_i\\}$，$B$ 为给定的阈值。**保证给定的序列按照单调递增顺序排序。**\n\n你可以调用函数\n\n```cpp\nstd::pair<int,int> move(int t,int x);\n```\n\n进行一步操作，并获得交互库的下一步操作。其中 $t = 0$ 表示你选择了序列 $a$，$t = 1$ 表示你选择了序列 $b$，而 $x$ 表示你选择的是对应序列中的第几个元素（编号从 0 开始）。交互库会返回一个 `std::pair<int,int>` $(t, x)$，含义如下：\n\n1. 如果 $(t, x) = (-1, -1)$，则表示你的操作不合法，或游戏已经结束（无论是你操作后结束，还是交互库再操作后结束），此时你应该直接返回。\n\n2. 否则 $(t, x)$ 用和之前一样的格式表示了先手进行的下一步操作。你需要继续进行交互的过程。\n\n请注意，在删除一个元素后，剩余的元素会按照原来的顺序拼接形成一个新的序列，所有操作的下标均按照最新的序列中的下标表示。\n\n具体的游戏过程如下：\n\n首先，你需要判定小 $\\delta$（后手）是否能够获胜。如果你认为不能获胜，请调用一次 $\\text{move}(0, 0)$ 并返回（此时 $\\text{move}$ 函数的返回值并不重要）。特别地，如果在游戏开始前小 $\\tau$ 已经获胜，同样视作这种情况。\n\n否则，请调用一次 $\\text{move}(1, 0)$，交互库会按照之前的格式返回交互库的第一步操作。特别地，如果游戏开始之前，小 $\\delta$ 已经获胜了，交互库会返回 $(-1, -1)$，此时请在调用 $\\text{move}(1, 0)$ 后立即返回。\n\n在这之后，你需要不断调用 $\\text{move}$ 来与交互库进行游戏，直到交互库返回 $(-1, -1)$。注意你不需要判定游戏是否结束，交互库会自动帮你判定。\n\n在一组测试数据中可能会多次调用 $\\text{solve}$ 或 $\\text{play}$ 函数，不同的调用之间可能会保留对全局变量的修改，请注意多测清空问题。\n\n下发文件中提供了一个参考实现 flipped.cpp。这个程序对于求值部分会返回 $114514$，而对于交互部分，会始终认为有解，并选择某个序列的最后一个元素将其删除。可以参考样例程序理解交互过程。\n\n### 测试程序方式\n\n下发文件中提供了一个交互库的参考实现 grader.cpp。最终测试时所用的交互库实现与该实现不同，因此选手的解法不应依赖交互库的具体实现。\n\n你需要在本题目录下使用以下编译命令得到可执行程序：\n\n```cpp\ng++ flipped.cpp grader.cpp -o flipped -O2\n```\n\n样例交互库将按照如下格式进行测试：\n\n首先读入一个变量 $o = 0/1$，其中 $o = 0$ 表示进行的是求值部分的测试，$o = 1$ 表示进行的是交互部分的测试。\n\n接下来，如果 $o = 0$，则：\n\n- 读入一个整数 $T$，表示测试数据组数，对于每组数据：\n- 读入两个整数 $n, m$，表示两个序列的大小。\n- 接下来一行读入 $n$ 个单调递增的整数 $a_1, a_2, \\cdots, a_n$，表示传入的序列 $a$。\n- 接下来一行读入 $m$ 个单调递增的整数 $b_1, b_2, \\cdots, b_m$，表示传入的序列 $b$。\n- 交互库会自动帮你调用 $\\text{solve}(a, b)$，并将返回的结果写入标准输出。\n\n如果 $o = 1$，则：\n\n- 读入一个整数 $T$，表示测试数据组数，对于每组数据：\n- 读入四个整数 $n, m, B, t$，表示两个序列的大小，给定的阈值 $B$，以及 $t = 0/1$ 表示当前局面是否为后手必胜（$t = 1$ 则后手必胜，$t = 0$ 则先手必胜）。\n- 接下来一行读入 $n$ 个单调递增的整数 $a_1, a_2, \\cdots, a_n$，表示传入的序列 $a$。\n- 接下来一行读入 $m$ 个单调递增的整数 $b_1, b_2, \\cdots, b_m$，表示传入的序列 $b$。\n- 交互库会调用 $\\text{play}(a, b, B)$ 并与你进行交互，对于每组数据，交互库的输出如下：\n- 如果你在第一次调用时没有正确判定是否必胜，交互库会输出 $\\text{Wrong Answer}$。\n- 如果你的操作不合法，交互库会输出 $\\text{Invalid Operation: MESSAGE}$，其中 $\\text{MESSAGE}$ 为用英文表达的不合法原因。如不理解英文，请自行查看 $\\text{grader.cpp}$。\n- 如果你的所有操作均合法，但最终没有获胜（包括在游戏没有结束时提前返回），交互库会输出 $\\text{You didn't win}$。\n- 如果你的所有操作均合法，且最终获胜，交互库会输出 $\\text{OK}$。\n\n请注意，由于题目保证了传入 $\\text{solve}$ 的 $a, b$ 序列均递增排列，请保证输入的 $a, b$ 也按照递增顺序排列，否则可能会出现不可预料的结果。同时，如果你尝试进行不合法的交互行为，也可能会出现不可预料的结果，所有潜在的后果请自行承担。\n\n样例交互库使用的策略是非常简单的，你可以根据自己的需求自行改动样例交互库的策略。最终评测时，交互库会使用不一样的策略，但请注意，**最终评测时，交互库不一定会使用最优策略**，你的代码需要能够应对任何交互库可能的操作。", "inputFormat": "见【测试程序方式】。", "outputFormat": "见【测试程序方式】。", "hint": "选手不应该通过非法方式获得交互库的内部信息，或者以任何形式攻击交互库（包括但不限于与标准 IO 进行交互），这种行为视为作弊。\n\n保证在所有操作合法的情况下，交互库不会使用超过 $0.5$s 的时间，也不会使用超过 $128$MB 的空间。也即，你至少有 $1.5$s 的时间和 $384$MB 的内存可以使用。\n\n对于所有数据，满足 $1 \\leq T \\leq 10^5$, $n, m \\geq 1$, $2 \\leq \\sum n + m \\leq 5 \\times 10^5$, $1 \\leq a_i, b_i \\leq 10^9$, $1 \\leq B \\leq 2 \\times 10^9$。\n\n下表中给出了所有子任务的数据范围，表格中的数字表示对应子任务的分值。其中：\n\n- “求值”一列对应的子任务中，交互库仅会调用 $\\text{solve}$ 函数，你能够获得分数当且仅当对于该子任务的所有 $\\text{solve}$ 函数都返回了正确的结果。\n- “交互”一列对应的子任务中，交互库仅会调用 $\\text{play}$ 函数，你能够获得分数当且仅当对于该子任务的所有 $\\text{play}$ 的调用，都能正确判定游戏的结果，且对于可以获胜的数据，能够成功完成游戏并最终获胜。\n\n本题采用子任务捆绑测试，有子任务依赖。具体地，每个子任务将依赖所有在其左上方的子任务。特别地，这意味着所有交互部分的子任务会依赖与其数据规模相同的求值部分子任务。\n\n在洛谷评测中，子任务编号将从左上至右下依次编号为 $1 \\sim 10$（例如第三档部分分的交互部分子任务编号为 $6$）。\n\n| $n + m \\leq$ | $\\sum n + m \\leq$ | 求值 | 交互 |\n| :--: | :--: | :--: | :--: |\n| $50$ | $1000$ | $3$ | $2$ |\n| $500$ | $5000$ | $13$ | $7$ |\n| $2500$ | $10^4$ | $15$ | $10$ |\n| $10^5$ | $5 \\times 10^5$ | $14$ | $8$ |\n| $5 \\times 10^5$ | $5 \\times 10^5$ | $12$ | $16$ |", "locale": "zh-CN"}}}
{"pid": "P14355", "type": "P", "difficulty": 7, "samples": [["3 1\n1 3 1\n2 5 1\n4 6 1", "2"], ["10 2\n4 10 14\n2 17 87\n5 12 84\n6 11 71\n1 13 62\n8 9 55\n7 14 6\n15 20 87\n3 19 18\n16 18 96", "338"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["集训队互测", "2025"], "title": "[集训队互测 2025] 封印", "background": "", "description": "你是一名大魔法师，现在遇到了 $n$ 只怪物，第 $i$ 只怪物的出现时间为 $[l_i, r_i)$，有经验值 $w_i$。对于怪物 $i$，你可以选择一个实数 $k_i \\in [l_i, r_i]$，并在 $[l_i, k_i)$ 时间内施展封印术控制这只怪物。特别地，如果 $k_i = l_i$，表示你没有对这种怪物施展封印术。由于人是有极限的，在同一时刻，你最多对 $K$ 个怪物施展法术，$K$ 为给定常数。\n\n你有一个熟练度 $W$，由于已经很久没有使用过封印术了，在 $0$ 时刻 $W = 0$。对于怪物 $i$，如果 $k_i = r_i$，那么就成功封印了这只怪物，所以在 $r_i$ 时刻熟练度就会增加 $w_i$；如果 $k_i < r_i$，那么怪物就会在 $k_i$ 时刻攻击你，使得熟练度重置为 $0$。\n\n在任意时刻，你可以选择施展终极秘术，将时间线上的所有的 $n$ 只怪物变成 $W$ 枚金币，并带着它们离开。如果同一时刻发生多个事件（熟练度增加、熟练度重置、终极秘术），它们之间的生效顺序可以任意安排。\n\n现在，请求出最多能带着多少枚金币离开。", "inputFormat": "第一行两个正整数 $n, K$。\n\n接下来 $n$ 行，每行三个正整数 $l_i, r_i, w_i$，表示一只怪物。", "outputFormat": "输出一行一个整数表示答案。", "hint": "### 样例 3\n\n见附加文件中的 `ex_seal3.in/ans`，该样例符合子任务 5,6 的限制。\n\n### 样例解释\n\n对于样例 1，取 $k_1 = 3, k_2 = 2, k_3 = 6$，那么 2 时刻 $W$ 重置为 0，3 时刻 $W$ 增加 1，6 时刻 $W$ 增加 1，此时可以获得 2 枚金币。容易发现不可能获得 3 枚金币。\n\n### 限制与约定\n\n对于所有数据，$n, l_i, r_i, w_i, K$ 均为正整数，$1 \\leq K \\leq n \\leq 3 \\times 10^5$, $1 \\leq w_i \\leq 10^9$, $1 \\leq l_i < r_i \\leq 2n$，且保证 $l_1, l_2, \\dots, l_n, r_1, r_2, \\dots, r_n$ 构成 $1 \\sim 2n$ 的排列。\n\n各子任务特殊约束及分值如下：\n\n| 子任务编号 | $n \\leq$ | 特殊性质 | 分值 | 子任务依赖 |\n| :--: | :--: | :--: | :--: | :--: |\n| 1 | $20$ | - | $5$ | - |\n| 2 | $2500$ | $w_i = 1$ | $15$ | - |\n| 3 | $3 \\times 10^5$ | $w_i = 1$ | $20$ | $2$ |\n| 4 | $2500$ | - | $15$ | $1, 2$ |\n| 5 | $10^5$ | $K \\leq 30$ | $20$ | - |\n| 6 | $3 \\times 10^5$ | - | $25$ | $3, 4, 5$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[集训队互测 2025] 封印", "background": "", "description": "你是一名大魔法师，现在遇到了 $n$ 只怪物，第 $i$ 只怪物的出现时间为 $[l_i, r_i)$，有经验值 $w_i$。对于怪物 $i$，你可以选择一个实数 $k_i \\in [l_i, r_i]$，并在 $[l_i, k_i)$ 时间内施展封印术控制这只怪物。特别地，如果 $k_i = l_i$，表示你没有对这种怪物施展封印术。由于人是有极限的，在同一时刻，你最多对 $K$ 个怪物施展法术，$K$ 为给定常数。\n\n你有一个熟练度 $W$，由于已经很久没有使用过封印术了，在 $0$ 时刻 $W = 0$。对于怪物 $i$，如果 $k_i = r_i$，那么就成功封印了这只怪物，所以在 $r_i$ 时刻熟练度就会增加 $w_i$；如果 $k_i < r_i$，那么怪物就会在 $k_i$ 时刻攻击你，使得熟练度重置为 $0$。\n\n在任意时刻，你可以选择施展终极秘术，将时间线上的所有的 $n$ 只怪物变成 $W$ 枚金币，并带着它们离开。如果同一时刻发生多个事件（熟练度增加、熟练度重置、终极秘术），它们之间的生效顺序可以任意安排。\n\n现在，请求出最多能带着多少枚金币离开。", "inputFormat": "第一行两个正整数 $n, K$。\n\n接下来 $n$ 行，每行三个正整数 $l_i, r_i, w_i$，表示一只怪物。", "outputFormat": "输出一行一个整数表示答案。", "hint": "### 样例 3\n\n见附加文件中的 `ex_seal3.in/ans`，该样例符合子任务 5,6 的限制。\n\n### 样例解释\n\n对于样例 1，取 $k_1 = 3, k_2 = 2, k_3 = 6$，那么 2 时刻 $W$ 重置为 0，3 时刻 $W$ 增加 1，6 时刻 $W$ 增加 1，此时可以获得 2 枚金币。容易发现不可能获得 3 枚金币。\n\n### 限制与约定\n\n对于所有数据，$n, l_i, r_i, w_i, K$ 均为正整数，$1 \\leq K \\leq n \\leq 3 \\times 10^5$, $1 \\leq w_i \\leq 10^9$, $1 \\leq l_i < r_i \\leq 2n$，且保证 $l_1, l_2, \\dots, l_n, r_1, r_2, \\dots, r_n$ 构成 $1 \\sim 2n$ 的排列。\n\n各子任务特殊约束及分值如下：\n\n| 子任务编号 | $n \\leq$ | 特殊性质 | 分值 | 子任务依赖 |\n| :--: | :--: | :--: | :--: | :--: |\n| 1 | $20$ | - | $5$ | - |\n| 2 | $2500$ | $w_i = 1$ | $15$ | - |\n| 3 | $3 \\times 10^5$ | $w_i = 1$ | $20$ | $2$ |\n| 4 | $2500$ | - | $15$ | $1, 2$ |\n| 5 | $10^5$ | $K \\leq 30$ | $20$ | - |\n| 6 | $3 \\times 10^5$ | - | $25$ | $3, 4, 5$ |", "locale": "zh-CN"}}}
{"pid": "P14356", "type": "P", "difficulty": 7, "samples": [["3 26\nct\nctt\ncts", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["集训队互测", "2025"], "title": "[集训队互测 2025] 第二基地", "background": "群星的尽头", "description": "给定整数 $m$，定义字符集 $\\Sigma$ 为前 $m$ 个小写字母，对于两个字符集为 $\\Sigma$ 的串 $A, B$，定义 $f(A, B)$ 为如下问题的答案：存在一个有限大小的自动机 $M$，使得输入字符集为 $\\Sigma$ 的，任意长度的字符串 $S$，都可以比较 $A$ 与 $B$ 在 $S$ 中的出现次数（返回 $<$, $=$, $>$）。如果存在，则 $f(A, B) = 1$，否则 $f(A, B) = 0$。给定 $n$ 个串 $s_1 \\sim s_n$，你要求出 $\\sum_{1 \\leq i < j \\leq n} f(s_i, s_j)$\n\n在本题中，我们定义自动机 $M$ 是一个五元组 $(Q, \\Sigma, \\delta, q_0, F)$，其中 $Q$ 是状态集合，$\\Sigma$ 是字符集，$\\delta: Q \\times \\Sigma \\to Q$ 是转移函数，$q_0$ 是起始状态，$F: Q \\to \\{<, =, >\\}$ 表示每个状态对应的结果。定义这个自动机可以比较 $A$ 和 $B$ 在 $S$ 中的出现次数，当且仅当 $F(\\delta(\\dots\\delta(\\delta(q_0, S_1), S_2)\\dots, S_{|S|})) \\in \\{<, =, >\\}$ 为 $A$ 和 $B$ 在 $S$ 中出现次数的大小关系。", "inputFormat": "第一行两个正整数 $n,m$。\n\n接下来 $n$ 行，第 $i$ 行一个字符串 $s_i$，字符集为前 $m$ 个小写字母。", "outputFormat": "输出一行一个整数，表示答案。", "hint": "### 样例 2~7\n\n见附加文件中的 $\\text{ex\\_dfa2.in/out}$ 到 $\\text{ex\\_dfa7.in/out}$，第 $i+1$ 个样例满足子任务 $i$ 的限制。\n\n### 数据范围\n\n对于所有测试点，$2 \\leq n \\leq 10^6$, $N = \\sum_{i=1}^{n} |s_i| \\leq 10^6$, $2 \\leq m \\leq 26$。\n\n| 子任务编号 | $N \\leq$ | 特殊性质 | 分数 |\n| :--: | :--: | :--: | :--: |\n| 1 | $1000$ | $\\lvert s_i\\rvert \\leq 3$, $m \\leq 3$ | $10$ |\n| 2 | $5000$ | $m = 10$ | $10$ |\n| 3 | $10^6$ | $m = 10$ | $20$ |\n| 4 | $500$ | 无 | $20$ |\n| 5 | $5000$ | 无 | $10$ |\n| 6 | $10^6$ | 无 | $30$ |\n\n本题开启合理的子任务依赖。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[集训队互测 2025] 第二基地", "background": "群星的尽头", "description": "给定整数 $m$，定义字符集 $\\Sigma$ 为前 $m$ 个小写字母，对于两个字符集为 $\\Sigma$ 的串 $A, B$，定义 $f(A, B)$ 为如下问题的答案：存在一个有限大小的自动机 $M$，使得输入字符集为 $\\Sigma$ 的，任意长度的字符串 $S$，都可以比较 $A$ 与 $B$ 在 $S$ 中的出现次数（返回 $<$, $=$, $>$）。如果存在，则 $f(A, B) = 1$，否则 $f(A, B) = 0$。给定 $n$ 个串 $s_1 \\sim s_n$，你要求出 $\\sum_{1 \\leq i < j \\leq n} f(s_i, s_j)$\n\n在本题中，我们定义自动机 $M$ 是一个五元组 $(Q, \\Sigma, \\delta, q_0, F)$，其中 $Q$ 是状态集合，$\\Sigma$ 是字符集，$\\delta: Q \\times \\Sigma \\to Q$ 是转移函数，$q_0$ 是起始状态，$F: Q \\to \\{<, =, >\\}$ 表示每个状态对应的结果。定义这个自动机可以比较 $A$ 和 $B$ 在 $S$ 中的出现次数，当且仅当 $F(\\delta(\\dots\\delta(\\delta(q_0, S_1), S_2)\\dots, S_{|S|})) \\in \\{<, =, >\\}$ 为 $A$ 和 $B$ 在 $S$ 中出现次数的大小关系。", "inputFormat": "第一行两个正整数 $n,m$。\n\n接下来 $n$ 行，第 $i$ 行一个字符串 $s_i$，字符集为前 $m$ 个小写字母。", "outputFormat": "输出一行一个整数，表示答案。", "hint": "### 样例 2~7\n\n见附加文件中的 $\\text{ex\\_dfa2.in/out}$ 到 $\\text{ex\\_dfa7.in/out}$，第 $i+1$ 个样例满足子任务 $i$ 的限制。\n\n### 数据范围\n\n对于所有测试点，$2 \\leq n \\leq 10^6$, $N = \\sum_{i=1}^{n} |s_i| \\leq 10^6$, $2 \\leq m \\leq 26$。\n\n| 子任务编号 | $N \\leq$ | 特殊性质 | 分数 |\n| :--: | :--: | :--: | :--: |\n| 1 | $1000$ | $\\lvert s_i\\rvert \\leq 3$, $m \\leq 3$ | $10$ |\n| 2 | $5000$ | $m = 10$ | $10$ |\n| 3 | $10^6$ | $m = 10$ | $20$ |\n| 4 | $500$ | 无 | $20$ |\n| 5 | $5000$ | 无 | $10$ |\n| 6 | $10^6$ | 无 | $30$ |\n\n本题开启合理的子任务依赖。", "locale": "zh-CN"}}}
{"pid": "P14357", "type": "P", "difficulty": 2, "samples": [["5", "5"], ["290es1q0", "92100"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2025", "O2优化", "排序", "CSP-J 入门级"], "title": "[CSP-J 2025] 拼数", "background": "", "description": "小 R 正在学习字符串处理。小 X 给了小 R 一个字符串 $s$，其中 $s$ 仅包含小写英文字母及数字，且**包含至少一个 $1 \\sim 9$ 中的数字**。小 X 希望小 R 使用 $s$ 中的任意多个数字，按任意顺序拼成一个正整数。**注意：小 R 可以选择 $s$ 中相同的数字，但每个数字只能使用一次**。例如，若 $s$ 为 $\\tt 1a01b$，则小 R 可以同时选择第 $1,3,4$ 个字符，分别为 $1,0,1$，拼成正整数 $101$ 或 $110$；但小 R 不能拼成正整数 $111$，因为 $s$ 仅包含两个数字 $1$。小 R 想知道，在他所有能拼成的正整数中，最大的是多少。你需要帮助小 R 求出他能拼成的正整数的最大值。\n", "inputFormat": "输入的第一行包含一个字符串 $s$，表示小 X 给小 R 的字符串。", "outputFormat": "输出一行一个正整数，表示小 R 能拼成的正整数的最大值。", "hint": "### 【样例 2 解释】\n\n$s$ 包含数字 $2,9,0,1,0$。可以证明，小 R 拼成的正整数的最大值为 $92100$。\n\n### 【样例 3】\n\n见选手目录下的 $number/number3.in$ 与 $number/number3.ans$。该样例满足测试点 $9 \\sim 11$ 的约束条件。\n\n### 【样例 4】\n\n见选手目录下的 $number/number4.in$ 与 $number/number4.ans$。该样例满足测试点 $20$ 的约束条件。\n\n### 【数据范围】\n\n设 $|s|$ 为字符串 $s$ 的长度。对于所有测试数据，保证：\n- $1 \\leq |s| \\leq 10^6$；\n- $s$ 仅包含小写英文字母及数字，且包含至少一个 $1 \\sim 9$ 中的数字。\n\n::cute-table{tuack}\n\n| 测试点编号 | $\\lvert s\\rvert \\leq$ | 特殊性质 |\n| :--: | :--: | :--: |\n| $1$ | $1$ | A |\n| $2$ | $2$ | ^ |\n| $3$ | ^ | 无 |\n| $4$ | $10$ | A |\n| $5,6$ | ^ | 无 |\n| $7,8$ | $10^2$ | A |\n| $9 \\sim 11$ | ^ | 无 |\n| $12$ | $10^3$ | A |\n| $13,14$ | ^ | 无 |\n| $15$ | $10^5$ | A |\n| $16,17$ | ^ | B |\n| $18,19$ | ^ | 无 |\n| $20$ | $10^6$ | A |\n| $21,22$ | ^ | B |\n| $23 \\sim 25$ | ^ | 无 |\n\n- 特殊性质 A：$s$ 仅包含数字。\n- 特殊性质 B：$s$ 仅包含不超过 $10^3$ 个数字。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-J 2025] 拼数", "background": "", "description": "小 R 正在学习字符串处理。小 X 给了小 R 一个字符串 $s$，其中 $s$ 仅包含小写英文字母及数字，且**包含至少一个 $1 \\sim 9$ 中的数字**。小 X 希望小 R 使用 $s$ 中的任意多个数字，按任意顺序拼成一个正整数。**注意：小 R 可以选择 $s$ 中相同的数字，但每个数字只能使用一次**。例如，若 $s$ 为 $\\tt 1a01b$，则小 R 可以同时选择第 $1,3,4$ 个字符，分别为 $1,0,1$，拼成正整数 $101$ 或 $110$；但小 R 不能拼成正整数 $111$，因为 $s$ 仅包含两个数字 $1$。小 R 想知道，在他所有能拼成的正整数中，最大的是多少。你需要帮助小 R 求出他能拼成的正整数的最大值。\n", "inputFormat": "输入的第一行包含一个字符串 $s$，表示小 X 给小 R 的字符串。", "outputFormat": "输出一行一个正整数，表示小 R 能拼成的正整数的最大值。", "hint": "### 【样例 2 解释】\n\n$s$ 包含数字 $2,9,0,1,0$。可以证明，小 R 拼成的正整数的最大值为 $92100$。\n\n### 【样例 3】\n\n见选手目录下的 $number/number3.in$ 与 $number/number3.ans$。该样例满足测试点 $9 \\sim 11$ 的约束条件。\n\n### 【样例 4】\n\n见选手目录下的 $number/number4.in$ 与 $number/number4.ans$。该样例满足测试点 $20$ 的约束条件。\n\n### 【数据范围】\n\n设 $|s|$ 为字符串 $s$ 的长度。对于所有测试数据，保证：\n- $1 \\leq |s| \\leq 10^6$；\n- $s$ 仅包含小写英文字母及数字，且包含至少一个 $1 \\sim 9$ 中的数字。\n\n::cute-table{tuack}\n\n| 测试点编号 | $\\lvert s\\rvert \\leq$ | 特殊性质 |\n| :--: | :--: | :--: |\n| $1$ | $1$ | A |\n| $2$ | $2$ | ^ |\n| $3$ | ^ | 无 |\n| $4$ | $10$ | A |\n| $5,6$ | ^ | 无 |\n| $7,8$ | $10^2$ | A |\n| $9 \\sim 11$ | ^ | 无 |\n| $12$ | $10^3$ | A |\n| $13,14$ | ^ | 无 |\n| $15$ | $10^5$ | A |\n| $16,17$ | ^ | B |\n| $18,19$ | ^ | 无 |\n| $20$ | $10^6$ | A |\n| $21,22$ | ^ | B |\n| $23 \\sim 25$ | ^ | 无 |\n\n- 特殊性质 A：$s$ 仅包含数字。\n- 特殊性质 B：$s$ 仅包含不超过 $10^3$ 个数字。", "locale": "zh-CN"}}}
{"pid": "P14358", "type": "P", "difficulty": 2, "samples": [["2 2\n99 100 97 98", "1 2"], ["2 2\n98 99 100 97", "2 2"], ["3 3\n94 95 96 97 98 99 100 93 92", "3 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "数学", "2025", "O2优化", "排序", "CSP-J 入门级"], "title": "[CSP-J 2025] 座位", "background": "", "description": "CSP-J 2025 第二轮正在进行。小 R 所在的考场共有 $n \\times m$ 名考生，其中所有考生的 CSP-J 2025 第一轮成绩**互不相同**。所有 $n \\times m$ 名考生将按照 CSP-J 2025 第一轮的成绩，**由高到低蛇形分配座位**，排列成 $n$ **行** $m$ **列**。具体地，设小 R 所在的考场的所有考生的成绩**从高到低**分别为 $s_1 > s_2 > \\dots > s_{n \\times m}$，则成绩为 $s_1$ 的考生的座位为第 1 **列**第 $1$ **行**，成绩为 $s_2$ 的考生的座位为第 $1$ **列**第 $2$ **行**，$\\dots$，成绩为 $s_n$ 的考生的座位为第 $1$ **列**第 $n$ **行**，成绩为 $s_{n+1}$ 的考生的座位为第 $2$ **列**第 $n$ **行**，$\\dots$，成绩为 $s_{2n}$ 的考生的座位为第 $2$ **列**第 $1$ **行**，成绩为 $s_{2n+1}$ 的考生的座位为第 $3$ **列**第 $1$ **行**，以此类推。\n\n例如，若 $n = 4, m = 5$，则所有 $4 \\times 5 = 20$ 名考生将按照 CSP-J 2025 第一轮成绩从高到低的顺序，根据下图中的箭头顺序分配座位。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/hfprtmco.png)\n:::\n\n给定小 R 所在的考场座位的**行数** $n$ 与**列数** $m$，以及小 R 所在的考场的所有考生 CSP-J 2025 第一轮的成绩 $a_1, a_2, \\dots, a_{n \\times m}$，其中 $a_1$ 为小 R CSP-J 2025 第一轮的成绩，你需要帮助小 R 求出，他的座位为第几**列**第几**行**。", "inputFormat": "输入的第一行包含两个正整数 $n, m$，分别表示小 R 所在的考场座位的**行数**与**列数**。\n\n输入的第二行包含 $n \\times m$ 个正整数 $a_1, a_2, \\dots, a_{n \\times m}$，分别表示小 R 所在的考场的所有考生 CSP-J 2025 第一轮的成绩，其中 $a_1$ 为小 R CSP-J 2025 第一轮的成绩。", "outputFormat": "输出一行两个正整数 $c, r$，表示小 R 的座位为第 $c$ **列**第 $r$ **行**。", "hint": "### 【样例 1 解释】\n\n按照成绩从高到低的顺序，成绩为 $100$ 的考生的座位为第 $1$ **列**第 $1$ **行**，成绩为 $99$ 的考生的座位为第 $1$ **列**第 $2$ **行**，成绩为 $98$ 的考生的座位为第 $2$ **列**第 $2$ **行**，成绩为 $97$ 的考生的座位为第 $2$ **列**第 $1$ **行**。小 R 的成绩为 $99$，因此座位为第 $1$ **列**第 $2$ **行**。\n\n### 【样例 2 解释】\n\n按照成绩从高到低的顺序，成绩为 $100$ 的考生的座位为第 $1$ **列**第 $1$ **行**，成绩为 $99$ 的考生的座位为第 $1$ **列**第 $2$ **行**，成绩为 $98$ 的考生的座位为第 $2$ **列**第 $2$ **行**，成绩为 $97$ 的考生的座位为第 $2$ **列**第 $1$ **行**。小 R 的成绩为 $98$，因此座位为第 $2$ **列**第 $2$ **行**。\n\n### 【数据范围】\n\n对于所有测试数据，保证：\n- $1 \\leq n \\leq 10$, $1 \\leq m \\leq 10$;\n- 对于所有 $1 \\leq i \\leq n \\times m$，均有 $1 \\leq a_i \\leq 100$，且 $a_1, a_2, \\dots, a_{n \\times m}$ 互不相同。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n \\leq$ | $m \\leq$ | 特殊性质 |\n| :--: | :--: | :--: | :--: |\n| $1$ | $1$ | $1$ | AB |\n| $2, 3$ | ^ | $10$ | 无 |\n| $4, 5$ | $10$ | $1$ | ^ |\n| $6$ | $2$ | $2$ | A |\n| $7$ | ^ | ^ | B |\n| $8, 9$ | ^ | ^ | 无 |\n| $10$ | ^ | $10$ | A |\n| $11$ | ^ | ^ | B |\n| $12 \\sim 14$ | ^ | ^ | 无 |\n| $15 \\sim 17$ | $10$ | $2$ | ^ |\n| $18 \\sim 20$ | ^ | $10$ | ^ |\n\n特殊性质 A：对于所有 $1 \\leq i \\leq n \\times m$，均有 $a_i = i$。\n\n特殊性质 B：对于所有 $1 \\leq i \\leq n \\times m$，均有 $a_i = n \\times m - i + 1$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-J 2025] 座位", "background": "", "description": "CSP-J 2025 第二轮正在进行。小 R 所在的考场共有 $n \\times m$ 名考生，其中所有考生的 CSP-J 2025 第一轮成绩**互不相同**。所有 $n \\times m$ 名考生将按照 CSP-J 2025 第一轮的成绩，**由高到低蛇形分配座位**，排列成 $n$ **行** $m$ **列**。具体地，设小 R 所在的考场的所有考生的成绩**从高到低**分别为 $s_1 > s_2 > \\dots > s_{n \\times m}$，则成绩为 $s_1$ 的考生的座位为第 1 **列**第 $1$ **行**，成绩为 $s_2$ 的考生的座位为第 $1$ **列**第 $2$ **行**，$\\dots$，成绩为 $s_n$ 的考生的座位为第 $1$ **列**第 $n$ **行**，成绩为 $s_{n+1}$ 的考生的座位为第 $2$ **列**第 $n$ **行**，$\\dots$，成绩为 $s_{2n}$ 的考生的座位为第 $2$ **列**第 $1$ **行**，成绩为 $s_{2n+1}$ 的考生的座位为第 $3$ **列**第 $1$ **行**，以此类推。\n\n例如，若 $n = 4, m = 5$，则所有 $4 \\times 5 = 20$ 名考生将按照 CSP-J 2025 第一轮成绩从高到低的顺序，根据下图中的箭头顺序分配座位。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/hfprtmco.png)\n:::\n\n给定小 R 所在的考场座位的**行数** $n$ 与**列数** $m$，以及小 R 所在的考场的所有考生 CSP-J 2025 第一轮的成绩 $a_1, a_2, \\dots, a_{n \\times m}$，其中 $a_1$ 为小 R CSP-J 2025 第一轮的成绩，你需要帮助小 R 求出，他的座位为第几**列**第几**行**。", "inputFormat": "输入的第一行包含两个正整数 $n, m$，分别表示小 R 所在的考场座位的**行数**与**列数**。\n\n输入的第二行包含 $n \\times m$ 个正整数 $a_1, a_2, \\dots, a_{n \\times m}$，分别表示小 R 所在的考场的所有考生 CSP-J 2025 第一轮的成绩，其中 $a_1$ 为小 R CSP-J 2025 第一轮的成绩。", "outputFormat": "输出一行两个正整数 $c, r$，表示小 R 的座位为第 $c$ **列**第 $r$ **行**。", "hint": "### 【样例 1 解释】\n\n按照成绩从高到低的顺序，成绩为 $100$ 的考生的座位为第 $1$ **列**第 $1$ **行**，成绩为 $99$ 的考生的座位为第 $1$ **列**第 $2$ **行**，成绩为 $98$ 的考生的座位为第 $2$ **列**第 $2$ **行**，成绩为 $97$ 的考生的座位为第 $2$ **列**第 $1$ **行**。小 R 的成绩为 $99$，因此座位为第 $1$ **列**第 $2$ **行**。\n\n### 【样例 2 解释】\n\n按照成绩从高到低的顺序，成绩为 $100$ 的考生的座位为第 $1$ **列**第 $1$ **行**，成绩为 $99$ 的考生的座位为第 $1$ **列**第 $2$ **行**，成绩为 $98$ 的考生的座位为第 $2$ **列**第 $2$ **行**，成绩为 $97$ 的考生的座位为第 $2$ **列**第 $1$ **行**。小 R 的成绩为 $98$，因此座位为第 $2$ **列**第 $2$ **行**。\n\n### 【数据范围】\n\n对于所有测试数据，保证：\n- $1 \\leq n \\leq 10$, $1 \\leq m \\leq 10$;\n- 对于所有 $1 \\leq i \\leq n \\times m$，均有 $1 \\leq a_i \\leq 100$，且 $a_1, a_2, \\dots, a_{n \\times m}$ 互不相同。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n \\leq$ | $m \\leq$ | 特殊性质 |\n| :--: | :--: | :--: | :--: |\n| $1$ | $1$ | $1$ | AB |\n| $2, 3$ | ^ | $10$ | 无 |\n| $4, 5$ | $10$ | $1$ | ^ |\n| $6$ | $2$ | $2$ | A |\n| $7$ | ^ | ^ | B |\n| $8, 9$ | ^ | ^ | 无 |\n| $10$ | ^ | $10$ | A |\n| $11$ | ^ | ^ | B |\n| $12 \\sim 14$ | ^ | ^ | 无 |\n| $15 \\sim 17$ | $10$ | $2$ | ^ |\n| $18 \\sim 20$ | ^ | $10$ | ^ |\n\n特殊性质 A：对于所有 $1 \\leq i \\leq n \\times m$，均有 $a_i = i$。\n\n特殊性质 B：对于所有 $1 \\leq i \\leq n \\times m$，均有 $a_i = n \\times m - i + 1$。", "locale": "zh-CN"}}}
