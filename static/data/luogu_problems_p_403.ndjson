{"pid": "P9174", "type": "P", "difficulty": 5, "samples": [["2 1 2", "500000004"], ["10 2 5", "1"], ["3 141592653589793 2", "468261332"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2022", "矩阵加速", "状态合并", "COCI（克罗地亚）", "状压 DP"], "title": "[COCI 2022/2023 #4] Bojanje", "background": "", "description": "Oliver 是一只不仅能找出 bug 并且喜欢画画的小黄鸭。他最新的画有 $n$ 个部分，每部分用一种不同的颜色涂色。在此之后他得到了很多批评，因为他的画太可预测了。他决定用 $t$ 次迭代修改他的画。在每次迭代中他将做以下操作：\n\nOliver 会均匀随机选择一个下标 $i\\ (1\\le i\\le n)$，然后记住画中第 $i$ 部分的颜色。\nOliver 会再均匀随机选择一个下标 $j\\ (1\\le j\\le n)$。他会把画中第 $j$ 部分涂成和第 $i$ 部分一样的颜色。如果第 $j$ 部分的颜色和第 $i$ 部分相同，那么不会有任何改变。注意 $i$ 可以等于 $j$。\n现在，Oliver 害怕他的画会变得十分单调或者无聊。他认为一幅画是好的，如果画上至少有 $k$ 种不同的颜色。请帮他计算最后这幅画是好的这个事件的概率。", "inputFormat": "第一行包含三个整数 $n,t,k\\ (2\\le k\\le n\\le 10,1\\le t\\le 10^{18})$，意义如题目描述。", "outputFormat": "输出一行一个数，表示答案对 $10^9+7$ 取模后的值。\n\n形式化地，令 $m=10^9+7$。可以知道答案可以用不可约分数  $\\frac{p}{q}$ 表示，其中 $p$ 和 $q$ 是整数，$q\\not\\equiv 0 \\pmod m$。输出 $p\\cdot q^{-1}\\bmod m$。换句话说，输出满足 $0\\le x<m$ 且 $x\\cdot q\\equiv p\\pmod m$ 的整数 $x$。", "hint": "样例 $1$ 解释：画上有两种颜色，所以一次迭代后画和未操作之前相同的概率是 $\\frac{1}{2}$。\n\n样例 $2$ 解释：在两次迭代后，不同的颜色数不可能从 $10$ 变为小于 $5$，所以在任何情况下这幅画都会有至少 $5$ 种不同的颜色。\n \n| 子任务编号 | 附加限制 | 分值 |\n|:-:|:-:|:-:|\n| $0$ | 是样例 | $0$ |\n| $1$ |\t$k=n$ | $28$ |\n| $2$ |\t$t\\le 1000$ | $36$ |\n| $3$ |\t无附加限制 | $36$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2022/2023 #4] Bojanje", "background": "", "description": "Oliver 是一只不仅能找出 bug 并且喜欢画画的小黄鸭。他最新的画有 $n$ 个部分，每部分用一种不同的颜色涂色。在此之后他得到了很多批评，因为他的画太可预测了。他决定用 $t$ 次迭代修改他的画。在每次迭代中他将做以下操作：\n\nOliver 会均匀随机选择一个下标 $i\\ (1\\le i\\le n)$，然后记住画中第 $i$ 部分的颜色。\nOliver 会再均匀随机选择一个下标 $j\\ (1\\le j\\le n)$。他会把画中第 $j$ 部分涂成和第 $i$ 部分一样的颜色。如果第 $j$ 部分的颜色和第 $i$ 部分相同，那么不会有任何改变。注意 $i$ 可以等于 $j$。\n现在，Oliver 害怕他的画会变得十分单调或者无聊。他认为一幅画是好的，如果画上至少有 $k$ 种不同的颜色。请帮他计算最后这幅画是好的这个事件的概率。", "inputFormat": "第一行包含三个整数 $n,t,k\\ (2\\le k\\le n\\le 10,1\\le t\\le 10^{18})$，意义如题目描述。", "outputFormat": "输出一行一个数，表示答案对 $10^9+7$ 取模后的值。\n\n形式化地，令 $m=10^9+7$。可以知道答案可以用不可约分数  $\\frac{p}{q}$ 表示，其中 $p$ 和 $q$ 是整数，$q\\not\\equiv 0 \\pmod m$。输出 $p\\cdot q^{-1}\\bmod m$。换句话说，输出满足 $0\\le x<m$ 且 $x\\cdot q\\equiv p\\pmod m$ 的整数 $x$。", "hint": "样例 $1$ 解释：画上有两种颜色，所以一次迭代后画和未操作之前相同的概率是 $\\frac{1}{2}$。\n\n样例 $2$ 解释：在两次迭代后，不同的颜色数不可能从 $10$ 变为小于 $5$，所以在任何情况下这幅画都会有至少 $5$ 种不同的颜色。\n \n| 子任务编号 | 附加限制 | 分值 |\n|:-:|:-:|:-:|\n| $0$ | 是样例 | $0$ |\n| $1$ |\t$k=n$ | $28$ |\n| $2$ |\t$t\\le 1000$ | $36$ |\n| $3$ |\t无附加限制 | $36$ |", "locale": "zh-CN"}}}
{"pid": "P9175", "type": "P", "difficulty": 6, "samples": [["6\n1 2 5 7 10\n1 3 4 8 9\n3 4 7 1 15\n3 5 6 3 11\n3 6 5 6 8\n3\n2 4 15\n6 4 5\n3 5 10", "7\n5\n11"], ["4\n1 2 5 5 8\n2 3 4 6 9\n3 4 6 10 7\n4\n1 4 16\n2 4 16\n1 4 10\n3 4 10", "6\n7\n5\n7"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "可持久化线段树", "整体二分", "COCI（克罗地亚）"], "title": "[COCI 2022/2023 #4] Mreža", "background": "### 卡评测封号。", "description": "市长 Mirko 住在一个有 $n$ 个社区的城市里，这 $n$ 个社区用 $n-1$ 条双向道路连接，满足从任何社区出发都可以到达任意其他社区。\n\nMirko 想升级一些道路以疏导交通。对于每条路，我们知道目前在这条路上汽车的行驶速度 $v_i$，升级所需花费 $c_i$ 和升级后在这条路上汽车的行驶速度 $s_i$。\n\n有 $q$ 个不满意的市民来见 Mirko。每个人都有他们自己的升级建议。第 $i$ 个市民的建议是：「我们应该在升级社区 $a_i$ 和 $b_i$ 之间的道路上投资 $e_i$ 欧元。」\n\n对于每个建议，Mirko 感兴趣的是，如果他的目标是使社区 $a_i$ 和 $b_i$ 之间的最低驾驶速度最大化，那么他在升级道路上最多花费 $e_i$ 欧元的话这个最低驾驶速度是多少。\n\nMirko 瞬间意识到这个问题不简单，并且他雇佣你来帮助他！\n", "inputFormat": "第一行包含一个整数 $n\\ (2\\le n\\le 10^5)$，表示社区总数。\n\n接下来 $n-1$ 行，每行五个整数 $x_i,y_i,v_i,c_i,s_i\\ (1\\le x_i,y_i\\le n,1\\le v_i<s_i\\le 10^9,1\\le c_i\\le 10^9)$，表示社区 $x_i$ 和 $y_i$ 之间有一条路相连，目前在这条路上汽车的行驶速度为 $v_i$，升级所需花费为 $c_i$，升级后在这条路上汽车的行驶速度为 $s_i$。\n\n接下来一行一个整数 $q\\ (1\\le q\\le 10^5)$，表示不满意的市民总数。\n\n接下来 $q$ 行，每行三个整数 $a_i,b_i,e_i\\ (1\\le a_i,b_i\\le n,a_i\\neq b_i,1\\le e_i\\le 10^{18})$，意义如题目描述。", "outputFormat": "输出 $q$ 行，表示对每个市民建议的答案。", "hint": "样例解释 $1$：下图展示了这个城市和社区。边上写的分别是目前汽车的行驶速度，升级花费和升级后的汽车行驶速度。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/umum0365.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)\n\n如果我们升级 $1$ 和 $2$，$1$ 和 $3$ 之间的道路，从 $2$ 到 $4$ 的行驶速度将变成 $10,9,7$。最小为 $7$。\n\n如果我们升级 $4$ 和 $3$ 之间的道路，从 $6$ 到 $4$ 的行驶速度将变成 $5,15$。最小为 $5$。\n\n如果我们升级 $3$ 和 $5$ 之间的道路，从 $5$ 到 $3$ 的行驶速度将变成 $11$。\n\n|子任务编号|\t附加限制|\t分值|\n|:-:|:-:|:-:|\n| $0$ | 是样例 | $0$ |\n| $1$ | $n,q\\le 1000$ |\t$19$ |\n| $2$ |\t每个社区最多与两个其他社区相连 | $26$ |\n| $3$ |\t无附加限制 | $55$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2022/2023 #4] Mreža", "background": "### 卡评测封号。", "description": "市长 Mirko 住在一个有 $n$ 个社区的城市里，这 $n$ 个社区用 $n-1$ 条双向道路连接，满足从任何社区出发都可以到达任意其他社区。\n\nMirko 想升级一些道路以疏导交通。对于每条路，我们知道目前在这条路上汽车的行驶速度 $v_i$，升级所需花费 $c_i$ 和升级后在这条路上汽车的行驶速度 $s_i$。\n\n有 $q$ 个不满意的市民来见 Mirko。每个人都有他们自己的升级建议。第 $i$ 个市民的建议是：「我们应该在升级社区 $a_i$ 和 $b_i$ 之间的道路上投资 $e_i$ 欧元。」\n\n对于每个建议，Mirko 感兴趣的是，如果他的目标是使社区 $a_i$ 和 $b_i$ 之间的最低驾驶速度最大化，那么他在升级道路上最多花费 $e_i$ 欧元的话这个最低驾驶速度是多少。\n\nMirko 瞬间意识到这个问题不简单，并且他雇佣你来帮助他！\n", "inputFormat": "第一行包含一个整数 $n\\ (2\\le n\\le 10^5)$，表示社区总数。\n\n接下来 $n-1$ 行，每行五个整数 $x_i,y_i,v_i,c_i,s_i\\ (1\\le x_i,y_i\\le n,1\\le v_i<s_i\\le 10^9,1\\le c_i\\le 10^9)$，表示社区 $x_i$ 和 $y_i$ 之间有一条路相连，目前在这条路上汽车的行驶速度为 $v_i$，升级所需花费为 $c_i$，升级后在这条路上汽车的行驶速度为 $s_i$。\n\n接下来一行一个整数 $q\\ (1\\le q\\le 10^5)$，表示不满意的市民总数。\n\n接下来 $q$ 行，每行三个整数 $a_i,b_i,e_i\\ (1\\le a_i,b_i\\le n,a_i\\neq b_i,1\\le e_i\\le 10^{18})$，意义如题目描述。", "outputFormat": "输出 $q$ 行，表示对每个市民建议的答案。", "hint": "样例解释 $1$：下图展示了这个城市和社区。边上写的分别是目前汽车的行驶速度，升级花费和升级后的汽车行驶速度。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/umum0365.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)\n\n如果我们升级 $1$ 和 $2$，$1$ 和 $3$ 之间的道路，从 $2$ 到 $4$ 的行驶速度将变成 $10,9,7$。最小为 $7$。\n\n如果我们升级 $4$ 和 $3$ 之间的道路，从 $6$ 到 $4$ 的行驶速度将变成 $5,15$。最小为 $5$。\n\n如果我们升级 $3$ 和 $5$ 之间的道路，从 $5$ 到 $3$ 的行驶速度将变成 $11$。\n\n|子任务编号|\t附加限制|\t分值|\n|:-:|:-:|:-:|\n| $0$ | 是样例 | $0$ |\n| $1$ | $n,q\\le 1000$ |\t$19$ |\n| $2$ |\t每个社区最多与两个其他社区相连 | $26$ |\n| $3$ |\t无附加限制 | $55$ |", "locale": "zh-CN"}}}
{"pid": "P9176", "type": "P", "difficulty": 4, "samples": [["3\n2 1\n3 1\n1 1", "2\n2\n2"], ["4\n17 2\n23 5\n11 4\n9 5", "17\n23\n17\n11"], ["3\n10 20\n100 5\n1000 5", "10\n10\n10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "COCI（克罗地亚）"], "title": "[COCI 2022/2023 #4] Vrsta", "background": "", "description": "Domagoj 最喜欢的课是体育课。每节体育课都以热身运动开始。体育老师有一个有趣的方法来选择带领其他同学做热身运动的学生。学生们按身高从低到高的顺序站成一排，老师会选择站在队伍中间的学生。如果有两个学生在中间，他将选择较矮的那个。例如：如果学生的身高为 $1, 3, 5, 7, 11$，身高为 $5$ 的学生将带领其他同学做热身运动。\n\nDomagoj 记不住他同学的身高。幸运的是，站在他旁边的 Lovro 十分擅长估计他人的身高。他给了 Domagoj $n$ 条信息：「有 $a_i$ 个身高为 $v_i$ 的学生进入了体育馆。」在 Lovro 说完每条信息之后，Domagoj 都对带领其他同学做热身运动的那个同学的身高感兴趣。假定所有进入体育馆的同学都是来上体育课的。请帮他回答他的问题！", "inputFormat": "第一行一个整数 $n\\ (1\\le n\\le 200\\ 000)$，表示 Lovro 的信息条数。\n\n接下来 $n$ 行包含两个整数 $v_i,a_i\\ (1\\le v_i,a_i\\le 10^9)$，表示 Lovro 所给信息中的身高和人数。", "outputFormat": "输出 $n$ 行，表示在 Lovro 给出第 $i$ 条信息后，对 Domagoj 问题的回答。", "hint": "|子任务编号|\t附加限制|\t分值|\n|:-:|:-:|:-:|\n| $0$ | 是样例 | $0$ |\n| $1$ | $n,v_i\\le 1000$ | $17$ |\n| $2$ | $a_1=a_2=\\ldots=a_n=1$ | $24$ |\n| $3$ | $v_1<v_2<\\ldots <v_n$ |\t$26$ |\n| $4$ |\t无附加限制 |\t$33$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2022/2023 #4] Vrsta", "background": "", "description": "Domagoj 最喜欢的课是体育课。每节体育课都以热身运动开始。体育老师有一个有趣的方法来选择带领其他同学做热身运动的学生。学生们按身高从低到高的顺序站成一排，老师会选择站在队伍中间的学生。如果有两个学生在中间，他将选择较矮的那个。例如：如果学生的身高为 $1, 3, 5, 7, 11$，身高为 $5$ 的学生将带领其他同学做热身运动。\n\nDomagoj 记不住他同学的身高。幸运的是，站在他旁边的 Lovro 十分擅长估计他人的身高。他给了 Domagoj $n$ 条信息：「有 $a_i$ 个身高为 $v_i$ 的学生进入了体育馆。」在 Lovro 说完每条信息之后，Domagoj 都对带领其他同学做热身运动的那个同学的身高感兴趣。假定所有进入体育馆的同学都是来上体育课的。请帮他回答他的问题！", "inputFormat": "第一行一个整数 $n\\ (1\\le n\\le 200\\ 000)$，表示 Lovro 的信息条数。\n\n接下来 $n$ 行包含两个整数 $v_i,a_i\\ (1\\le v_i,a_i\\le 10^9)$，表示 Lovro 所给信息中的身高和人数。", "outputFormat": "输出 $n$ 行，表示在 Lovro 给出第 $i$ 条信息后，对 Domagoj 问题的回答。", "hint": "|子任务编号|\t附加限制|\t分值|\n|:-:|:-:|:-:|\n| $0$ | 是样例 | $0$ |\n| $1$ | $n,v_i\\le 1000$ | $17$ |\n| $2$ | $a_1=a_2=\\ldots=a_n=1$ | $24$ |\n| $3$ | $v_1<v_2<\\ldots <v_n$ |\t$26$ |\n| $4$ |\t无附加限制 |\t$33$ |", "locale": "zh-CN"}}}
{"pid": "P9177", "type": "P", "difficulty": 1, "samples": [["31 3", "+---------------------+\n|........1..2..3..4..5|\n|..6..7..8..9.10.11.12|\n|.13.14.15.16.17.18.19|\n|.20.21.22.23.24.25.26|\n|.27.28.29.30.31......|\n+---------------------+"], ["1 5", "+---------------------+\n|..............1......|\n+---------------------+"], ["28 7", "+---------------------+\n|....................1|\n|..2..3..4..5..6..7..8|\n|..9.10.11.12.13.14.15|\n|.16.17.18.19.20.21.22|\n|.23.24.25.26.27.28...|\n+---------------------+"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "COCI（克罗地亚）"], "title": "[COCI 2022/2023 #5] Kalendar", "background": "", "description": "Magdalena 喜欢日历，她为每个月制作自己的日历。\n\n每月的每一天都正好用三个字符表示：\n\n- 如果天数是一位数，则表示为 `..X`。例如：数字 $7$ 被表示为 `..7`。\n- 如果天数是两位数，那么它表示为 `.XY`。例如：数字 $17$ 被表示为 `.17`。\n\n日历的每一行代表一个星期，每个星期由 $7$ 天组成。如果\n一周没有所有的 $7$ 天（因为有可能这个月不是从星期一开始的，或者不是在星期日结束的），那么缺失的日子就用 `...` 表示。\n\nMagdalena 也希望她的日历是漂亮的。她将用以下方式来装饰它：\n她将在上下两边填上 `-`（ASCII 45），左右两边填上 `|`（ASCII 124），而四个角落用 `+`（ASCII 43）。\n\n你的任务是确定 Magdalena 日历的格式，如果它有 $n$ 天，并且每月的第一天是一周的第 $x$ 天。例如，如果 $x=1$，这个月就从星期一开始，如果 $x=5$，就从星期五开始。\n\n我们假设一周的第一天是星期一。", "inputFormat": "一行，包含整数 $n$ 和 $x(1\\leq n\\leq 99,1\\leq x\\leq 7)$，表示该月的天数，以及该月的起始日。", "outputFormat": "输出 Magdalena 日历的样子。", "hint": "| Subtask | $pts$ | 限制 |\n| :----------: | :----------: | :----------: |\n| $0$ | $0$ | 是样例 |\n| $1$ | $7$ | $n+x\\leq 8$ |\n| $2$ | $19$ | $x=1$ |\n| $3$ | $24$ | 无 |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2022/2023 #5] Kalendar", "background": "", "description": "Magdalena 喜欢日历，她为每个月制作自己的日历。\n\n每月的每一天都正好用三个字符表示：\n\n- 如果天数是一位数，则表示为 `..X`。例如：数字 $7$ 被表示为 `..7`。\n- 如果天数是两位数，那么它表示为 `.XY`。例如：数字 $17$ 被表示为 `.17`。\n\n日历的每一行代表一个星期，每个星期由 $7$ 天组成。如果\n一周没有所有的 $7$ 天（因为有可能这个月不是从星期一开始的，或者不是在星期日结束的），那么缺失的日子就用 `...` 表示。\n\nMagdalena 也希望她的日历是漂亮的。她将用以下方式来装饰它：\n她将在上下两边填上 `-`（ASCII 45），左右两边填上 `|`（ASCII 124），而四个角落用 `+`（ASCII 43）。\n\n你的任务是确定 Magdalena 日历的格式，如果它有 $n$ 天，并且每月的第一天是一周的第 $x$ 天。例如，如果 $x=1$，这个月就从星期一开始，如果 $x=5$，就从星期五开始。\n\n我们假设一周的第一天是星期一。", "inputFormat": "一行，包含整数 $n$ 和 $x(1\\leq n\\leq 99,1\\leq x\\leq 7)$，表示该月的天数，以及该月的起始日。", "outputFormat": "输出 Magdalena 日历的样子。", "hint": "| Subtask | $pts$ | 限制 |\n| :----------: | :----------: | :----------: |\n| $0$ | $0$ | 是样例 |\n| $1$ | $7$ | $n+x\\leq 8$ |\n| $2$ | $19$ | $x=1$ |\n| $3$ | $24$ | 无 |\n", "locale": "zh-CN"}}}
{"pid": "P9178", "type": "P", "difficulty": 4, "samples": [["4 4\n9 12 9 11\n", "2 3 2 3"], ["4 4\n5 7 3 9", "2 3 2 3\n"], ["4 4\n3 4 6 10\n", "3 3 2 3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2022", "位运算", "COCI（克罗地亚）"], "title": "[COCI 2022/2023 #5] Diskurs", "background": null, "description": "给你 $n$ 个非负整数 $a_1, a_2, \\cdots a\n_n$，任何一个都小于 $2^m$。\n\n对于其中的每一个数，你都要找出它与数组中其他元素之间的最大哈明距离。\n\n两个非负整数的哈明距离被定义为在这些数字的二进制表示中，它们之间有多少个不同的位置（如果有必要，加上前导零）。\n\n形式上，对于每个 $i$ 求：\n\n$$\\max\\limits_{1\\leq j\\leq n} \\operatorname{hamming}(a_i,a_j)$$", "inputFormat": "第一行包含两个整数 $n$ 和 $m(1\\leq n\\leq 2^\nm,1\\leq m\\leq 20)$。\n第二行包含 $n$ 个数字 $a_i(0 \\leq a_i < 2^\nm)$。", "outputFormat": "一行 $n$ 个数，第 $i$ 个数表示 $a_i$ 与数组中其他元素之间的最大哈明距离。", "hint": "| Subatask | $\\text{pts}$ | 限制 |\n| :----------: | :----------: | :----------: |\n| $0$ | $0$ | 是样例 |\n| $1$ | $20$ | $m\\leq 10$ |\n| $2$ | $25$ | $m\\leq 16$ |\n| $3$ | $25$ | 无 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2022/2023 #5] Diskurs", "background": null, "description": "给你 $n$ 个非负整数 $a_1, a_2, \\cdots a\n_n$，任何一个都小于 $2^m$。\n\n对于其中的每一个数，你都要找出它与数组中其他元素之间的最大哈明距离。\n\n两个非负整数的哈明距离被定义为在这些数字的二进制表示中，它们之间有多少个不同的位置（如果有必要，加上前导零）。\n\n形式上，对于每个 $i$ 求：\n\n$$\\max\\limits_{1\\leq j\\leq n} \\operatorname{hamming}(a_i,a_j)$$", "inputFormat": "第一行包含两个整数 $n$ 和 $m(1\\leq n\\leq 2^\nm,1\\leq m\\leq 20)$。\n第二行包含 $n$ 个数字 $a_i(0 \\leq a_i < 2^\nm)$。", "outputFormat": "一行 $n$ 个数，第 $i$ 个数表示 $a_i$ 与数组中其他元素之间的最大哈明距离。", "hint": "| Subatask | $\\text{pts}$ | 限制 |\n| :----------: | :----------: | :----------: |\n| $0$ | $0$ | 是样例 |\n| $1$ | $20$ | $m\\leq 10$ |\n| $2$ | $25$ | $m\\leq 16$ |\n| $3$ | $25$ | 无 |", "locale": "zh-CN"}}}
{"pid": "P9179", "type": "P", "difficulty": 4, "samples": [["6 6\n1\n2\n3\n4\n5\n6\n", "-1\n2\n1\n2\n0\n1\n"], ["20 5\n7\n8\n2\n19\n12\n", "1\n9\n9\n0\n5\n"], ["10000 4\n1234\n2345\n3456\n7890\n", "15\n148\n3332\n37\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "2022", "素数判断,质数,筛法", "COCI（克罗地亚）"], "title": "[COCI 2022/2023 #5] Logaritam", "background": "", "description": "定义对数序列为一个长为 $n$ 的对数序列 $(a_1,a_2,\\ldots,a_n)$，满足对于所有正整数 $x,y$ 且 $xy\\le n$，有 $a_{xy}=a_x+a_y$。一个长为 $6$ 的对数序列例子为 $0,1,\\pi,2,0.7,1+\\pi$。\n\n有 $q$ 个长度为 $n$ 的对数序列，但是现在每个序列都恰好有一个元素被改掉了。给你序列个数 $q$，序列长度 $n$ 和每个序列被改动的元素位置 $x_i$，对于每个序列，输出在不改动已经更改的元素的情况下，至少要修改序列中多少个位置的元素才能使这个序列仍然是对数序列。\n\n注：可以证明对于任意的初始对数序列，改动同一位置后，在不改动这个位置的情况下将序列变为对数序列的最小改动数都是相等的。", "inputFormat": "第一行两个正整数 $n,q\\ (1\\le n\\le 10^8,1\\le q\\le 10^4)$，分别表示序列长度和序列个数。\n\n接下来 $q$ 行，第 $i$ 行一个正整数 $x_i\\ (1\\le x_i\\le n)$，表示第 $i$ 个序列中修改的元素下标。", "outputFormat": "如果第 $i$ 个序列无法在不改动已经更改的元素的情况下，将原序列变为对数序列，则输出 `-1`，否则输出最少更改元素个数。", "hint": "样例 $1$ 解释：\n\n假设初始序列是 $0,1,\\pi,2,0.7,1+\\pi$，修改第四个元素为 8，那就可以把第二个元素改为 $4$，把第六个元素改为 $4+\\pi$，这样序列变成 $0,4,\\pi,8,0.7,4+\\pi$，又变成了对数序列。\n\n|子任务编号|\t附加限制|\t分值|\n|:-:|:-:|:-:|\n|$0$|\t是样例\t|$0$|\n|$1$|\t$n\\le 20,q\\le 20$\t|$17$|\n|$2$|\t$q\\le 8$\t|$24$|\n|$3$|\t$n\\le 10^4$\t|$26$|\n|$4$|\t无附加限制\t|$33$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2022/2023 #5] Logaritam", "background": "", "description": "定义对数序列为一个长为 $n$ 的对数序列 $(a_1,a_2,\\ldots,a_n)$，满足对于所有正整数 $x,y$ 且 $xy\\le n$，有 $a_{xy}=a_x+a_y$。一个长为 $6$ 的对数序列例子为 $0,1,\\pi,2,0.7,1+\\pi$。\n\n有 $q$ 个长度为 $n$ 的对数序列，但是现在每个序列都恰好有一个元素被改掉了。给你序列个数 $q$，序列长度 $n$ 和每个序列被改动的元素位置 $x_i$，对于每个序列，输出在不改动已经更改的元素的情况下，至少要修改序列中多少个位置的元素才能使这个序列仍然是对数序列。\n\n注：可以证明对于任意的初始对数序列，改动同一位置后，在不改动这个位置的情况下将序列变为对数序列的最小改动数都是相等的。", "inputFormat": "第一行两个正整数 $n,q\\ (1\\le n\\le 10^8,1\\le q\\le 10^4)$，分别表示序列长度和序列个数。\n\n接下来 $q$ 行，第 $i$ 行一个正整数 $x_i\\ (1\\le x_i\\le n)$，表示第 $i$ 个序列中修改的元素下标。", "outputFormat": "如果第 $i$ 个序列无法在不改动已经更改的元素的情况下，将原序列变为对数序列，则输出 `-1`，否则输出最少更改元素个数。", "hint": "样例 $1$ 解释：\n\n假设初始序列是 $0,1,\\pi,2,0.7,1+\\pi$，修改第四个元素为 8，那就可以把第二个元素改为 $4$，把第六个元素改为 $4+\\pi$，这样序列变成 $0,4,\\pi,8,0.7,4+\\pi$，又变成了对数序列。\n\n|子任务编号|\t附加限制|\t分值|\n|:-:|:-:|:-:|\n|$0$|\t是样例\t|$0$|\n|$1$|\t$n\\le 20,q\\le 20$\t|$17$|\n|$2$|\t$q\\le 8$\t|$24$|\n|$3$|\t$n\\le 10^4$\t|$26$|\n|$4$|\t无附加限制\t|$33$|", "locale": "zh-CN"}}}
{"pid": "P9180", "type": "P", "difficulty": 5, "samples": [["5 6\n1 2 3 4 5\n1 1\n1 2\n1 3\n1 4\n1 6\n1 5\n", "4"], ["5 3\n1 3 2 2 1\n3 1\n1 3\n2 2\n", "2"], ["9 5\n1 3 2 5 1 4 6 2 1\n3 2\n2 3\n1 1\n1 2\n1 1\n", "4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2022", "COCI（克罗地亚）"], "title": "[COCI 2022/2023 #5] Slastičarnica", "background": null, "description": "有一列数 $a_1,\\ldots,a_n$ 和 $q$ 次操作，每次操作形如「删掉长为 $d_i$ 的前缀或后缀，且需要保证这个前缀和后缀中所有元素都大于等于 $s_i$。」每次操作前，你可以选择长度任意的前缀或后缀（可以为空，且两端可同时选择），并删除它。如果某次操作无法进行，则停止这次和之后的所有操作。问最多可以进行多少次操作。", "inputFormat": "第一行两个正整数 $n,q\\ (1\\le n\\le 5\\ 000,1\\le q\\le 2\\cdot 10^5)$，表示序列长度和操作次数。\n\n第二行 $n$ 个正整数 $a_i\\ (1\\le a_i\\le 10^9)$，表示这个数列。\n\n接下来 $q$ 行，每行两个整数 $d_i,s_i\\ (1\\le d_i\\le n,1\\le s_i\\le 10^9)$，表示一次操作。", "outputFormat": "输出一行一个整数，表示最多能进行多少次操作。", "hint": "样例 $3$ 解释：\n\n首先删除前缀 $(1)$，之后进行第一次操作，删除前缀 $(3,2,5)$。此时序列变为 $(1,4,6,2,1)$。\n\n然后删除前缀 $(1)$，之后进行第二次操作，删除前缀 $(4,6)$，此时序列变为 $(2,1)$。\n\n然后不删除任何前缀或后缀，之后进行第三次操作，删除后缀 $(1)$，此时序列变为 $(2)$。\n\n然后不删除任何前缀或后缀，之后进行第四次操作，删除唯一剩余的 $(2)$，此时序列变为空序列。\n\n最后一次操作由于序列为空无法完成，操作停止。\n\n因此一共进行了四次操作。\n\n|子任务编号|\t附加限制|\t分值|\n|:-:|:-:|:-:|\n|$0$|\t是样例|\t$0$|\n|$1$|\t$n,q\\le 100$|\t$19$|\n|$2$|\t$d_1=d_2=\\ldots=d_q=1$|\t$28$|\n|$3$|\t无附加限制|\t$53$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2022/2023 #5] Slastičarnica", "background": null, "description": "有一列数 $a_1,\\ldots,a_n$ 和 $q$ 次操作，每次操作形如「删掉长为 $d_i$ 的前缀或后缀，且需要保证这个前缀和后缀中所有元素都大于等于 $s_i$。」每次操作前，你可以选择长度任意的前缀或后缀（可以为空，且两端可同时选择），并删除它。如果某次操作无法进行，则停止这次和之后的所有操作。问最多可以进行多少次操作。", "inputFormat": "第一行两个正整数 $n,q\\ (1\\le n\\le 5\\ 000,1\\le q\\le 2\\cdot 10^5)$，表示序列长度和操作次数。\n\n第二行 $n$ 个正整数 $a_i\\ (1\\le a_i\\le 10^9)$，表示这个数列。\n\n接下来 $q$ 行，每行两个整数 $d_i,s_i\\ (1\\le d_i\\le n,1\\le s_i\\le 10^9)$，表示一次操作。", "outputFormat": "输出一行一个整数，表示最多能进行多少次操作。", "hint": "样例 $3$ 解释：\n\n首先删除前缀 $(1)$，之后进行第一次操作，删除前缀 $(3,2,5)$。此时序列变为 $(1,4,6,2,1)$。\n\n然后删除前缀 $(1)$，之后进行第二次操作，删除前缀 $(4,6)$，此时序列变为 $(2,1)$。\n\n然后不删除任何前缀或后缀，之后进行第三次操作，删除后缀 $(1)$，此时序列变为 $(2)$。\n\n然后不删除任何前缀或后缀，之后进行第四次操作，删除唯一剩余的 $(2)$，此时序列变为空序列。\n\n最后一次操作由于序列为空无法完成，操作停止。\n\n因此一共进行了四次操作。\n\n|子任务编号|\t附加限制|\t分值|\n|:-:|:-:|:-:|\n|$0$|\t是样例|\t$0$|\n|$1$|\t$n,q\\le 100$|\t$19$|\n|$2$|\t$d_1=d_2=\\ldots=d_q=1$|\t$28$|\n|$3$|\t无附加限制|\t$53$|", "locale": "zh-CN"}}}
{"pid": "P9181", "type": "P", "difficulty": 6, "samples": [["2 3\n4 5\n", "6.5200982141\n"], ["1 6\n10\n", "24.0000000000\n"], ["4 7\n5 5 6 6\n", "18.5706715170\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "Special Judge", "COCI（克罗地亚）"], "title": "[COCI 2022/2023 #5] Zastave", "background": "", "description": "有 $n$ 个直角三角形，第 $i$ 个直角三角形的斜边长度为 $r_i$，这些直角三角形的高度和不超过 $S$。求这 $n$ 个直角三角形的最大面积和。", "inputFormat": "第一行两个整数 $n,S\\ (1\\le n\\le 10^5,1\\le S\\le 10^{10})$，表示三角形个数和这些三角形的高度之和的最大值。\n\n第二行 $n$ 个整数 $r_i\\ (1\\le r_i\\le 10^5)$。", "outputFormat": "输出这 $n$ 个直角三角形的最大面积和（保留 $10$ 位小数）。如果你的输出与答案的绝对误差或相对误差不超过 $10^{-6}$ 则认为你的输出正确。", "hint": "样例 $2$ 解释：\n\n最大可能的情况是这个三角形的三边长为 $6,8,10$，面积为 $24$。\n\n|子任务编号|\t附加限制|\t分值|\n|:-:|:-:|:-:|\n|$0$|\t是样例|\t$0$|\n|$1$|\t$n\\le 100$|\t$37$|\n|$2$|\t$n\\le 1000$|\t$20$|\n|$3$|\t无附加限制|\t$43$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2022/2023 #5] Zastave", "background": "", "description": "有 $n$ 个直角三角形，第 $i$ 个直角三角形的斜边长度为 $r_i$，这些直角三角形的高度和不超过 $S$。求这 $n$ 个直角三角形的最大面积和。", "inputFormat": "第一行两个整数 $n,S\\ (1\\le n\\le 10^5,1\\le S\\le 10^{10})$，表示三角形个数和这些三角形的高度之和的最大值。\n\n第二行 $n$ 个整数 $r_i\\ (1\\le r_i\\le 10^5)$。", "outputFormat": "输出这 $n$ 个直角三角形的最大面积和（保留 $10$ 位小数）。如果你的输出与答案的绝对误差或相对误差不超过 $10^{-6}$ 则认为你的输出正确。", "hint": "样例 $2$ 解释：\n\n最大可能的情况是这个三角形的三边长为 $6,8,10$，面积为 $24$。\n\n|子任务编号|\t附加限制|\t分值|\n|:-:|:-:|:-:|\n|$0$|\t是样例|\t$0$|\n|$1$|\t$n\\le 100$|\t$37$|\n|$2$|\t$n\\le 1000$|\t$20$|\n|$3$|\t无附加限制|\t$43$|", "locale": "zh-CN"}}}
{"pid": "P9183", "type": "P", "difficulty": 4, "samples": [["4\nBEEF\n", "2\n1\n2\n"], ["9\nFEBFEBFEB\n", "2\n2\n3"], ["10\nBFFFFFEBFE", "3\n2\n4\n6"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "贪心", "USACO", "2023", "分类讨论"], "title": "[USACO23OPEN] FEB B", "background": "", "description": "Bessie and Elsie are plotting to overthrow Farmer John at last! They plan it out\nover $N$ text messages. Their conversation can be\nrepresented by a string $S$ of length $N$ where $S_i$ is either `B` or `E`,\nmeaning the $i$ th message was sent by Bessie or Elsie, respectively. \n\nHowever, Farmer John hears of the plan and attempts to intercept their\nconversation. Thus, some letters of $S$ are `F`, meaning Farmer John obfuscated\nthe message and the sender is unknown.\n\nThe  **excitement level** of a non-obfuscated conversation is the number of\ntimes a cow double-sends - that is, the number of occurrences of substring `BB`\nor `EE` in $S$. You want to find the excitement level of the original message,\nbut you don’t know which of Farmer John’s messages were actually Bessie’s\n/ Elsie’s. Over all possibilities, output all possible excitement levels of\n$S$.", "inputFormat": "The first line will consist of one integer $N$.\n\nThe next line contains $S$.", "outputFormat": "First output $K$, the number of distinct excitement levels possible. On the next\n$K$ lines, output the excitement levels, in increasing order.", "hint": "$1\\le N\\le 2\\cdot 10^5$.\n\n- Inputs 4-8: $N\\le 10$.\n- Inputs 9-20: No additional constraints.", "locale": "en", "translations": {"en": {"title": "[USACO23OPEN] FEB B", "background": "", "description": "Bessie and Elsie are plotting to overthrow Farmer John at last! They plan it out\nover $N$ text messages. Their conversation can be\nrepresented by a string $S$ of length $N$ where $S_i$ is either `B` or `E`,\nmeaning the $i$ th message was sent by Bessie or Elsie, respectively. \n\nHowever, Farmer John hears of the plan and attempts to intercept their\nconversation. Thus, some letters of $S$ are `F`, meaning Farmer John obfuscated\nthe message and the sender is unknown.\n\nThe  **excitement level** of a non-obfuscated conversation is the number of\ntimes a cow double-sends - that is, the number of occurrences of substring `BB`\nor `EE` in $S$. You want to find the excitement level of the original message,\nbut you don’t know which of Farmer John’s messages were actually Bessie’s\n/ Elsie’s. Over all possibilities, output all possible excitement levels of\n$S$.", "inputFormat": "The first line will consist of one integer $N$.\n\nThe next line contains $S$.", "outputFormat": "First output $K$, the number of distinct excitement levels possible. On the next\n$K$ lines, output the excitement levels, in increasing order.", "hint": "$1\\le N\\le 2\\cdot 10^5$.\n\n- Inputs 4-8: $N\\le 10$.\n- Inputs 9-20: No additional constraints.", "locale": "en"}, "zh-CN": {"title": "[USACO23OPEN] FEB B", "background": "", "description": "贝西和埃尔希正在密谋最终推翻他们的主人——农夫约翰！他们通过 $N$ 条短信进行计划。他们的对话可以用一个长度为 $N$ 的字符串 $S$ 来表示。     \n其中 $S_i$ 是字母 ```B``` 或 ```E```，这意味着第 $i$ 条消息分别由贝西或埃尔希发送的。\n\n\n然而，农夫约翰听说了这个消息，并试图拦截他们的谈话。因此，字符串 $S$ 的一些字母是 ```F```，这意味着农夫约翰混淆了信息，发件人未知（贝西、埃尔希都有可能）。   \n**注：约翰没有发送信息！他只是在干扰奶牛间的通话！**\n\n\n未混淆对话的兴奋程度是**一只奶牛重复发送信息的次数**。也就是说，子串 ```BB``` 或 ```EE``` 在 $S$ 中出现的次数。你想找到原始信息的兴奋程度，但你不知道约翰的信息中哪一条实际上是贝西或埃尔希的。在所有可能的情况下，**从小到大输出**所有可能的兴奋程度。", "inputFormat": "第一行：一个整数 $N$（通话长度）。       \n第二行：一个字符串 $S$（通话内容）。", "outputFormat": "第一行：输出一个整数 $K$，为**不同**兴奋程度的可能数量。   \n随后 $K$ 行：每行一个整数，为每种兴奋程度。**注意按照从小到大的顺序输出。**", "hint": "$1 \\le N \\le 2 \\times 10^5$。\n- 测试点 4~8：$N \\le 10$\n- 测试点 9~20：无额外限制。", "locale": "zh-CN"}}}
{"pid": "P9184", "type": "P", "difficulty": 4, "samples": [["3\n1 1 1\nbessie noun\n10 5 4\nbessie noun\ntaught transitive-verb\nflew intransitive-verb\nelsie noun\nfarmer noun\njohn noun\nand conjunction\nand conjunction\nnhoj noun\nmooed intransitive-verb\n24 5 4\nbut conjunction\nbessie noun\ntaught transitive-verb\nflew intransitive-verb\nelsie noun\nfarmer noun\njohn noun\nand conjunction\nand conjunction\nnhoj noun\nmooed intransitive-verb\nbob noun\nimpressed transitive-verb\ncow noun\nimpressed transitive-verb\nleaped intransitive-verb\nelsie noun\nbella noun\nbuttercup noun\npushed transitive-verb\nmooed intransitive-verb\nenvy noun\njohn noun\nnhoj noun\n", "0\n\n9\nnhoj mooed. farmer taught elsie, bessie and john flew.\n23\nnhoj mooed. nhoj impressed john, farmer, elsie, bessie and cow impressed bob. bella pushed elsie and buttercup flew. envy mooed but john leaped."]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["模拟", "字符串", "贪心", "USACO", "2023", "Special Judge"], "title": "[USACO23OPEN] Moo Language B", "background": "Farmer John is interested in better interacting with his fellow cows, so he\ndecided he will learn the moo language!", "description": "Moo language is actually quite similar to English, but more minimalistic. There\nare only four types of words: nouns, transitive verbs, intransitive verbs, and\nconjunctions. Every two consecutive words must be separated by a space.  There\nare also only two types of punctuation: periods and commas.  When a period or\ncomma appears after a word, it appears directly after the word, and is then\nfollowed  by a space if another word appears next.\n\nA sentence needs to follow one of the following formats:\n- Type 1: noun + intransitive verb.\n- Type 2: noun + transitive verb + noun(s). Specifically, at least one noun\nmust follow the transitive verb, and there must be a comma in front of every \nfollowing noun besides the first following noun.\n\nTwo sentences may be joined into a compound sentence if a conjunction is placed\nin between them.  The resulting compound sentence cannot be further joined with\nother sentences or other compound sentences.  Every sentence (or compound\nsentence, if two sentences are joined) must end with a period.\n\nFarmer John has a word bank of $N$ words, $C$ commas, and $P$ periods. He may only use a word or punctuation mark as\nmany times as it appears in the word bank. Help him output a sequence of\nsentences containing the maximum possible number of words.\n\nEach input file contains $T$ independent instances of this\nproblem.\n", "inputFormat": "The first line contains $T$, the number of instances. Each instance is specified\nas follows:\n\nThe first line consists of three integers $N, C$ and $P$.\n\nThe $N$ following lines will consist of two strings. The first string will be\nthe word itself that FJ can use (a string of at least $1$ and at most $10$ lowercase\nletters), and the second string will be either one of the following: noun,\ntransitive-verb, intransitive-verb, or conjunction, denoting the type of the\nword. It is possible the same word occurs more than once in FJ's word bank, but\nit will always have the same type each time it appears.", "outputFormat": "In the first line, output the maximum possible number of words.\n\nIn the second line, output any sequence of sentences with the maximum possible\nnumber of words. Any valid sequence will be accepted.\n\n**The grader is sensitive to whitespace, so make sure not to output any\nextraneous spaces, particularly at the end of each line.**", "hint": "$1\\le T\\le 100$，$1 \\leq P,C\\le N \\leq 10^3$.\n\n- Inputs 2-6: $N\\le 10$.\n- Inputs 7-11: $N\\le 100$.\n- Inputs 12-16: $N\\le 1000$.\n- Inputs with remainder 2 when divided by 5: There are no transitive\nverbs.\n- Inputs with remainder 3 when divided by 5: There are no intransitive\nverbs.\n- Inputs with remainder 4 when divided by 5: There are no conjunctions.", "locale": "en", "translations": {"en": {"title": "[USACO23OPEN] Moo Language B", "background": "Farmer John is interested in better interacting with his fellow cows, so he\ndecided he will learn the moo language!", "description": "Moo language is actually quite similar to English, but more minimalistic. There\nare only four types of words: nouns, transitive verbs, intransitive verbs, and\nconjunctions. Every two consecutive words must be separated by a space.  There\nare also only two types of punctuation: periods and commas.  When a period or\ncomma appears after a word, it appears directly after the word, and is then\nfollowed  by a space if another word appears next.\n\nA sentence needs to follow one of the following formats:\n- Type 1: noun + intransitive verb.\n- Type 2: noun + transitive verb + noun(s). Specifically, at least one noun\nmust follow the transitive verb, and there must be a comma in front of every \nfollowing noun besides the first following noun.\n\nTwo sentences may be joined into a compound sentence if a conjunction is placed\nin between them.  The resulting compound sentence cannot be further joined with\nother sentences or other compound sentences.  Every sentence (or compound\nsentence, if two sentences are joined) must end with a period.\n\nFarmer John has a word bank of $N$ words, $C$ commas, and $P$ periods. He may only use a word or punctuation mark as\nmany times as it appears in the word bank. Help him output a sequence of\nsentences containing the maximum possible number of words.\n\nEach input file contains $T$ independent instances of this\nproblem.\n", "inputFormat": "The first line contains $T$, the number of instances. Each instance is specified\nas follows:\n\nThe first line consists of three integers $N, C$ and $P$.\n\nThe $N$ following lines will consist of two strings. The first string will be\nthe word itself that FJ can use (a string of at least $1$ and at most $10$ lowercase\nletters), and the second string will be either one of the following: noun,\ntransitive-verb, intransitive-verb, or conjunction, denoting the type of the\nword. It is possible the same word occurs more than once in FJ's word bank, but\nit will always have the same type each time it appears.", "outputFormat": "In the first line, output the maximum possible number of words.\n\nIn the second line, output any sequence of sentences with the maximum possible\nnumber of words. Any valid sequence will be accepted.\n\n**The grader is sensitive to whitespace, so make sure not to output any\nextraneous spaces, particularly at the end of each line.**", "hint": "$1\\le T\\le 100$，$1 \\leq P,C\\le N \\leq 10^3$.\n\n- Inputs 2-6: $N\\le 10$.\n- Inputs 7-11: $N\\le 100$.\n- Inputs 12-16: $N\\le 1000$.\n- Inputs with remainder 2 when divided by 5: There are no transitive\nverbs.\n- Inputs with remainder 3 when divided by 5: There are no intransitive\nverbs.\n- Inputs with remainder 4 when divided by 5: There are no conjunctions.", "locale": "en"}, "zh-CN": {"title": "[USACO23OPEN] Moo Language B", "background": "", "description": "### 题目背景\n\nFJ 对与奶牛更好地互动感兴趣，所以他决定学习 moo 语言！\n\n\nmoo 语言与英语相似，但更为简单。单词只有四种类型：名词、及物动词、不及物动词和连词，每两个单词之间必须用空格隔开。标点符号仅包含逗号和句号，它会跟在单词后面，若该标点符号后面存在单词，则需要隔一个空格再放单词。\n\n对于每个句子，都需要遵循以下格式中的一条：\n\n1. 名词+不及物动词。\n2. 名词+及物动词+名词（可以有多个）。及物动词后面必须有至少一个名词。除及物动词后面的第一个名词外，后面的每个名词前面都必须加一个逗号。\n\n也可以在两个句子之间加一个连词，形成复合句，复合句不能与其他句子用连词连接。每一个句子（包括复合句）都必须以句号结尾。\n\nFJ 的词库中有 $N$ 个单词、$C$ 个逗号和 $P$ 个句号。每个单词的使用次数不能超过这个单词在词库中出现的次数。现在，你要帮他输出几个符合以上要求的句子，使总单词数尽量多。\n\n每个输入文件中共包含 $T$ 组样例。", "inputFormat": "第一行输入 $T$，表示样例组数。对于每组样例，格式如下：\n\n第一行输入三个正整数 $N$、$C$ 和 $P$。\n\n在接下来的 $N$ 行，每行输入两个字符串。第一个字符串输入一个 FJ 可以用的单词（全为小写字母，长度为 $1$ 至 $10$），第二个字符串为以下字符串中的任意一个，表示该单词的类型：\n\n- `noun`（名词）；\n- `transitive-verb`（及物动词）；\n- `intransitive-verb`（不及物动词）；\n- `conjunction`（连词）。\n\n同一个单词可能在词库中出现多次，但是每次出现时它们的类型都相同。", "outputFormat": "第一行输出组成符合以上要求的句子序列的最大单词数。\n\n在第二行中，输出句子序列，使单词数最多。本题开启 SPJ，任何符合以上要求的句子序列均可通过。\n\n**请不要输出多余的空格，尤其是在每行末尾。**", "hint": "$1 \\leq T \\leq 100$，$1 \\leq P, C \\leq N \\leq 10^3$。\n\n- 输入 2-6：$N \\leq 10$。\n- 输入 7-11：$N \\leq 100$。\n- 输入 12-16：$N \\leq 1000$。\n- 输入编号除以 5 余 2 的测试点：没有及物动词。\n- 输入编号除以 5 余 3 的测试点：没有不及物动词。\n- 输入编号除以 5 余 4 的测试点：没有连词。\n\ntranslated by [liyuanchen2021](https://www.luogu.com.cn/user/557680)", "locale": "zh-CN"}}}
{"pid": "P9185", "type": "P", "difficulty": 4, "samples": [["5 3 4\n0 2 3\n", "1 2 3 4 0\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["模拟", "数学", "倍增", "USACO", "2023"], "title": "[USACO23OPEN] Rotate and Shift B", "background": "", "description": "**Note: The time limit for this problem is 4s, 2x the default.**\n\nTo celebrate the start of spring, Farmer John's $N$ cows have invented an intriguing new dance, where they stand in a circle and re-order themselves in a predictable way.\n\nSpecifically, there are $N$ positions around the circle, numbered sequentially from $0$ to $N-1$, with position $0$ following position $N-1$.  A cow resides at each position.  The cows are also numbered sequentially from $0$ to $N-1$.  Initially, cow $i$ starts in position $i$.  You are told a set of $K$ positions $0=A_1<A_2<\\dots<A_K<N$ that are \"active\", meaning the cows in these positions are the next to move.\n\nIn each minute of the dance, two things happen.  First, the cows in the active positions rotate: the cow at position $A_1$ moves to position $A_2$, the cow at position $A_2$ moves to position $A_3$, and so on, with the cow at position $A_K$ moving to position $A_1$.  All of these $K$ moves happen simultaneously, so the after the rotation is complete, all of the active positions still contain exactly one cow.  Next, the active positions themselves shift:\n$A_1$ becomes $A_1+1$, $A_2$ becomes $A_2+1$, and so on (if $A_i = N-1$ for some active position, then $A_i$ circles back around to $0$).\n\nPlease calculate the order of the cows after $T$ minutes of the dance.", "inputFormat": "The first line contains three integers $N, K$ and $T$.\n\nThe second line contains $K$ integers representing the initial set of active positions\n$A_1,A_2, \\dots, A_K$.  Recall that $A_1 = 0$ and that these are given in increasing order.", "outputFormat": "Output the order of the cows after $T$ minutes, starting with the cow in position $0$, separated by\nspaces.", "hint": "For the example above, here are the cow orders and $A$ for the first four timesteps:\n```\nInitial, T = 0: order = [0 1 2 3 4], A = [0 2 3]\nT = 1: order = [3 1 0 2 4]\nT = 1: A = [1 3 4]\nT = 2: order = [3 4 0 1 2]\nT = 2: A = [2 4 0]\nT = 3: order = [2 4 3 1 0]\nT = 3: A = [3 0 1]\nT = 4: order = [1 2 3 4 0]\n```\n\n$1 \\leq K \\leq N \\leq 2 \\cdot 10^5$, $1\\le T\\le 10^9$.\n\n- Inputs 2-7: $N \\leq 1000, T \\leq 10000$.\n- Inputs 8-13: No additional constraints.", "locale": "en", "translations": {"en": {"title": "[USACO23OPEN] Rotate and Shift B", "background": "", "description": "**Note: The time limit for this problem is 4s, 2x the default.**\n\nTo celebrate the start of spring, Farmer John's $N$ cows have invented an intriguing new dance, where they stand in a circle and re-order themselves in a predictable way.\n\nSpecifically, there are $N$ positions around the circle, numbered sequentially from $0$ to $N-1$, with position $0$ following position $N-1$.  A cow resides at each position.  The cows are also numbered sequentially from $0$ to $N-1$.  Initially, cow $i$ starts in position $i$.  You are told a set of $K$ positions $0=A_1<A_2<\\dots<A_K<N$ that are \"active\", meaning the cows in these positions are the next to move.\n\nIn each minute of the dance, two things happen.  First, the cows in the active positions rotate: the cow at position $A_1$ moves to position $A_2$, the cow at position $A_2$ moves to position $A_3$, and so on, with the cow at position $A_K$ moving to position $A_1$.  All of these $K$ moves happen simultaneously, so the after the rotation is complete, all of the active positions still contain exactly one cow.  Next, the active positions themselves shift:\n$A_1$ becomes $A_1+1$, $A_2$ becomes $A_2+1$, and so on (if $A_i = N-1$ for some active position, then $A_i$ circles back around to $0$).\n\nPlease calculate the order of the cows after $T$ minutes of the dance.", "inputFormat": "The first line contains three integers $N, K$ and $T$.\n\nThe second line contains $K$ integers representing the initial set of active positions\n$A_1,A_2, \\dots, A_K$.  Recall that $A_1 = 0$ and that these are given in increasing order.", "outputFormat": "Output the order of the cows after $T$ minutes, starting with the cow in position $0$, separated by\nspaces.", "hint": "For the example above, here are the cow orders and $A$ for the first four timesteps:\n```\nInitial, T = 0: order = [0 1 2 3 4], A = [0 2 3]\nT = 1: order = [3 1 0 2 4]\nT = 1: A = [1 3 4]\nT = 2: order = [3 4 0 1 2]\nT = 2: A = [2 4 0]\nT = 3: order = [2 4 3 1 0]\nT = 3: A = [3 0 1]\nT = 4: order = [1 2 3 4 0]\n```\n\n$1 \\leq K \\leq N \\leq 2 \\cdot 10^5$, $1\\le T\\le 10^9$.\n\n- Inputs 2-7: $N \\leq 1000, T \\leq 10000$.\n- Inputs 8-13: No additional constraints.", "locale": "en"}, "zh-CN": {"title": "[USACO23OPEN] Rotate and Shift B", "background": "", "description": "**注意：本题的时间限制为 4 秒，是默认时间限制的 2 倍。**\n\n为了庆祝春天的到来，Farmer John 的 $N$ 头奶牛发明了一种有趣的舞蹈，她们围成一个圆圈，并以一种可预测的方式重新排列自己。\n\n具体来说，圆圈上有 $N$ 个位置，编号从 $0$ 到 $N-1$，其中位置 $0$ 紧接着位置 $N-1$。每个位置上有一头奶牛。奶牛的编号也从 $0$ 到 $N-1$。初始时，奶牛 $i$ 位于位置 $i$。你会被告知一组 $K$ 个“活跃”位置 $0 = A_1 < A_2 < \\dots < A_K < N$，这意味着这些位置上的奶牛是下一批要移动的。\n\n在舞蹈的每一分钟，会发生两件事。首先，活跃位置上的奶牛会旋转：位置 $A_1$ 的奶牛移动到位置 $A_2$，位置 $A_2$ 的奶牛移动到位置 $A_3$，依此类推，位置 $A_K$ 的奶牛移动到位置 $A_1$。所有这些 $K$ 次移动同时发生，因此在旋转完成后，所有活跃位置仍然恰好有一头奶牛。接下来，活跃位置本身会移动：$A_1$ 变为 $A_1 + 1$，$A_2$ 变为 $A_2 + 1$，依此类推（如果某个活跃位置 $A_i = N-1$，则 $A_i$ 会循环回到 $0$）。\n\n请计算舞蹈进行 $T$ 分钟后奶牛的顺序。", "inputFormat": "第一行包含三个整数 $N$、$K$ 和 $T$。\n\n第二行包含 $K$ 个整数，表示初始的活跃位置 $A_1, A_2, \\dots, A_K$。注意 $A_1 = 0$，并且这些位置是按递增顺序给出的。", "outputFormat": "输出 $T$ 分钟后奶牛的顺序，从位置 $0$ 的奶牛开始，用空格分隔。", "hint": "对于上述样例，以下是前四个时间步的奶牛顺序和活跃位置 $A$：\n```\n初始，T = 0：顺序 = [0 1 2 3 4]，A = [0 2 3]\nT = 1：顺序 = [3 1 0 2 4]\nT = 1：A = [1 3 4]\nT = 2：顺序 = [3 4 0 1 2]\nT = 2：A = [2 4 0]\nT = 3：顺序 = [2 4 3 1 0]\nT = 3：A = [3 0 1]\nT = 4：顺序 = [1 2 3 4 0]\n```\n\n$1 \\leq K \\leq N \\leq 2 \\cdot 10^5$，$1 \\leq T \\leq 10^9$。\n\n- 输入 2-7：$N \\leq 1000$，$T \\leq 10000$。\n- 输入 8-13：没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P9186", "type": "P", "difficulty": 4, "samples": [["5\n1 10 4 2 6\n3\n2 1\n2 8\n4 5\n", "55\n81\n98\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "二分", "USACO", "2023", "前缀和"], "title": "[USACO23OPEN] Milk Sum S", "background": "", "description": "**Note: The time limit for this problem is 4s, 2x the default.**\n\nFarmer John's $N$ cows have integer milk production\nvalues $a_1,\\dots,a_N$.  That is, the $i$ th cow produces $a_i$ units of milk per\nminute.  \n\nEach morning, Farmer John starts with all $N$ cows hooked up to his milking\nmachine in the barn.  He is required to unhook them one by one, sending them out\nfor their daily exercise routine.  The first cow he sends out is unhooked after\njust 1 minute of milking, the second cow he sends out is unhooked after another\nminute of milking, and so on.  Since the first cow (say, cow $x$) only spends\none minute on the milking machine, she contributes only $a_x$ units of total\nmilk.  The second cow (say, cow $y$) spends two total minutes on the milking\nmachine, and therefore contributes $2a_y$ units of total milk.  The third cow\n(say, cow $z$) contributes $3a_z$ total units, and so on.  Let $T$ represent the\nmaximum possible amount of milk, in total, that Farmer John can collect, if he\nunhooks his cows in an optimal order.\n\nFarmer John is curious how $T$ would be affected if some of the milk production\nvalues in his herd were different.  For each of $Q$ queries,\neach specified by two integers $i$ and $j$, please calculate what would be the \nnew value of $T$ if $a_i$ were set to $j$.  Note that\neach query is considering a temporary potential change independent of all other\nqueries; that is, $a_i$ reverts back to its original value before the next query\nis considered.\n\n", "inputFormat": "The first line contains $N$. \n\nThe second line contains $a_1\\dots a_N$.\n\nThe third line contains $Q$.\n\nThe next $Q$ lines each contain two space-separated integers $i$ and $j$.", "outputFormat": "Please print the value of $T$ for each of the $Q$ queries on separate lines.\n", "hint": "For the first query, $a$ would become $[1,1,4,2,6]$, and\n$T =\n1 \\cdot 1 + 2 \\cdot 1 + 3 \\cdot 2 + 4 \\cdot 4 + 5 \\cdot 6 = 55$.\n\nFor the second query, $a$ would become $[1,8,4,2,6]$, and\n$T =\n1 \\cdot 1 + 2 \\cdot 2 + 3 \\cdot 4 + 4 \\cdot 6 + 5 \\cdot 8 = 81$.\n\nFor the third query, $a$ would become $[1,10,4,5,6]$, and\n$T =\n1 \\cdot 1 + 2 \\cdot 4 + 3 \\cdot 5 + 4 \\cdot 6 + 5 \\cdot 10 = 98$.\n\n$1\\le N\\le 1.5\\cdot 10^5$, $0 \\leq a_i \\leq 10^8$,$1\\le Q\\le 1.5\\cdot 10^5$，$0 \\leq j \\leq 10^8$.\n\n- Inputs 2-4: $N,Q\\le 1000$.\n- Inputs 5-11: No additional constraints.", "locale": "en", "translations": {"en": {"title": "[USACO23OPEN] Milk Sum S", "background": "", "description": "**Note: The time limit for this problem is 4s, 2x the default.**\n\nFarmer John's $N$ cows have integer milk production\nvalues $a_1,\\dots,a_N$.  That is, the $i$ th cow produces $a_i$ units of milk per\nminute.  \n\nEach morning, Farmer John starts with all $N$ cows hooked up to his milking\nmachine in the barn.  He is required to unhook them one by one, sending them out\nfor their daily exercise routine.  The first cow he sends out is unhooked after\njust 1 minute of milking, the second cow he sends out is unhooked after another\nminute of milking, and so on.  Since the first cow (say, cow $x$) only spends\none minute on the milking machine, she contributes only $a_x$ units of total\nmilk.  The second cow (say, cow $y$) spends two total minutes on the milking\nmachine, and therefore contributes $2a_y$ units of total milk.  The third cow\n(say, cow $z$) contributes $3a_z$ total units, and so on.  Let $T$ represent the\nmaximum possible amount of milk, in total, that Farmer John can collect, if he\nunhooks his cows in an optimal order.\n\nFarmer John is curious how $T$ would be affected if some of the milk production\nvalues in his herd were different.  For each of $Q$ queries,\neach specified by two integers $i$ and $j$, please calculate what would be the \nnew value of $T$ if $a_i$ were set to $j$.  Note that\neach query is considering a temporary potential change independent of all other\nqueries; that is, $a_i$ reverts back to its original value before the next query\nis considered.\n\n", "inputFormat": "The first line contains $N$. \n\nThe second line contains $a_1\\dots a_N$.\n\nThe third line contains $Q$.\n\nThe next $Q$ lines each contain two space-separated integers $i$ and $j$.", "outputFormat": "Please print the value of $T$ for each of the $Q$ queries on separate lines.\n", "hint": "For the first query, $a$ would become $[1,1,4,2,6]$, and\n$T =\n1 \\cdot 1 + 2 \\cdot 1 + 3 \\cdot 2 + 4 \\cdot 4 + 5 \\cdot 6 = 55$.\n\nFor the second query, $a$ would become $[1,8,4,2,6]$, and\n$T =\n1 \\cdot 1 + 2 \\cdot 2 + 3 \\cdot 4 + 4 \\cdot 6 + 5 \\cdot 8 = 81$.\n\nFor the third query, $a$ would become $[1,10,4,5,6]$, and\n$T =\n1 \\cdot 1 + 2 \\cdot 4 + 3 \\cdot 5 + 4 \\cdot 6 + 5 \\cdot 10 = 98$.\n\n$1\\le N\\le 1.5\\cdot 10^5$, $0 \\leq a_i \\leq 10^8$,$1\\le Q\\le 1.5\\cdot 10^5$，$0 \\leq j \\leq 10^8$.\n\n- Inputs 2-4: $N,Q\\le 1000$.\n- Inputs 5-11: No additional constraints.", "locale": "en"}, "zh-CN": {"title": "[USACO23OPEN] Milk Sum S", "background": "", "description": "**注意：本题的时间限制为 4 秒，是默认时间限制的 2 倍。**\n\nFarmer John 的 $N$ 头奶牛的产奶量为整数 $a_1, \\dots, a_N$。也就是说，第 $i$ 头奶牛每分钟产 $a_i$ 单位的牛奶。\n\n每天早上，Farmer John 会将所有 $N$ 头奶牛连接到谷仓的挤奶机上。他需要依次断开连接，将奶牛送去进行日常锻炼。第一头奶牛在挤奶 1 分钟后被断开连接，第二头奶牛在再挤奶 1 分钟后被断开连接，依此类推。由于第一头奶牛（假设是奶牛 $x$）只在挤奶机上停留了 1 分钟，她总共贡献了 $a_x$ 单位的牛奶。第二头奶牛（假设是奶牛 $y$）在挤奶机上停留了总共 2 分钟，因此贡献了 $2a_y$ 单位的牛奶。第三头奶牛（假设是奶牛 $z$）贡献了 $3a_z$ 单位的牛奶，依此类推。设 $T$ 表示 Farmer John 以最优顺序断开奶牛连接时，可以收集到的最大总牛奶量。\n\nFarmer John 很好奇，如果某些奶牛的产奶量发生变化，$T$ 会如何变化。对于每个由两个整数 $i$ 和 $j$ 指定的 $Q$ 个查询，请计算如果将 $a_i$ 设置为 $j$，新的 $T$ 值会是多少。注意，每个查询都是独立的临时变化，即在考虑下一个查询之前，$a_i$ 会恢复为原始值。", "inputFormat": "第一行包含 $N$。\n\n第二行包含 $a_1 \\dots a_N$。\n\n第三行包含 $Q$。\n\n接下来的 $Q$ 行，每行包含两个用空格分隔的整数 $i$ 和 $j$。", "outputFormat": "请为每个查询输出一行，表示对应的 $T$ 值。", "hint": "对于第一个查询，$a$ 将变为 $[1,1,4,2,6]$，此时 $T = 1 \\cdot 1 + 2 \\cdot 1 + 3 \\cdot 2 + 4 \\cdot 4 + 5 \\cdot 6 = 55$。\n\n对于第二个查询，$a$ 将变为 $[1,8,4,2,6]$，此时 $T = 1 \\cdot 1 + 2 \\cdot 2 + 3 \\cdot 4 + 4 \\cdot 6 + 5 \\cdot 8 = 81$。\n\n对于第三个查询，$a$ 将变为 $[1,10,4,5,6]$，此时 $T = 1 \\cdot 1 + 2 \\cdot 4 + 3 \\cdot 5 + 4 \\cdot 6 + 5 \\cdot 10 = 98$。\n\n$1 \\leq N \\leq 1.5 \\cdot 10^5$，$0 \\leq a_i \\leq 10^8$，$1 \\leq Q \\leq 1.5 \\cdot 10^5$，$0 \\leq j \\leq 10^8$。\n\n- 输入 2-4：$N, Q \\leq 1000$。\n- 输入 5-11：没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P9187", "type": "P", "difficulty": 4, "samples": [["5 3\nGHGGH\nGHHHH\nHGHHG", "5\n3\n5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "数学", "USACO", "2023", "位运算"], "title": "[USACO23OPEN] Field Day S", "background": "", "description": "**Note: The time limit for this problem in Python is 15s.  Other languages have the default time limit of 2s.**\n\nEach of Farmer John's $N$ barns has selected a team of $C$ \ncows to participate in field day. The breed of every cow is\neither a Guernsey or a Holstein.  \n\nThe difference between two teams is defined to be the number of positions $i$\n($1 \\leq i \\leq C$) at which the breeds of the cows in the $i$ th positions\ndiffer. For every team $t$ from $1 \\ldots N$, please compute the maximum\ndifference between team $t$ and any other team.", "inputFormat": "The first line contains $C$ and $N$.\n\nThe next $N$ lines each contain a string of length $C$ of `G`s and `H`s.  Each line\ncorresponds to a team.", "outputFormat": "For each team, print the maximum difference.\n", "hint": "The first and third teams differ by $5$. The second and third teams differ by\n$3$.\n\n$2\\le N\\le 10^5$, $1\\le C\\le 18$.\n\n- Inputs 2-5: $C = 10$.\n- Inputs 6-9: All answers are at least $C-3$.\n- Inputs 10-20: No additional constraints.", "locale": "en", "translations": {"en": {"title": "[USACO23OPEN] Field Day S", "background": "", "description": "**Note: The time limit for this problem in Python is 15s.  Other languages have the default time limit of 2s.**\n\nEach of Farmer John's $N$ barns has selected a team of $C$ \ncows to participate in field day. The breed of every cow is\neither a Guernsey or a Holstein.  \n\nThe difference between two teams is defined to be the number of positions $i$\n($1 \\leq i \\leq C$) at which the breeds of the cows in the $i$ th positions\ndiffer. For every team $t$ from $1 \\ldots N$, please compute the maximum\ndifference between team $t$ and any other team.", "inputFormat": "The first line contains $C$ and $N$.\n\nThe next $N$ lines each contain a string of length $C$ of `G`s and `H`s.  Each line\ncorresponds to a team.", "outputFormat": "For each team, print the maximum difference.\n", "hint": "The first and third teams differ by $5$. The second and third teams differ by\n$3$.\n\n$2\\le N\\le 10^5$, $1\\le C\\le 18$.\n\n- Inputs 2-5: $C = 10$.\n- Inputs 6-9: All answers are at least $C-3$.\n- Inputs 10-20: No additional constraints.", "locale": "en"}, "zh-CN": {"title": "[USACO23OPEN] Field Day S", "background": "", "description": "**提示：本题的 Python 时限为 15s。其它语言默认 2s。**\n\nFarmer John 的 $N$ 个牛棚都会选出包含 $C$ 只奶牛的队伍去参加户外聚会。所有奶牛的品种都只可能是根西牛（`G`）或荷斯坦奶牛（`H`）。\n\n我们将两个奶牛队伍中，同一位置对应的两头奶牛品种不同的所有位置 $i(1 \\leq i \\leq C)$ 的个数，定义为的两个奶牛队伍的差异。对于编号 $1...N$ 的每个奶牛队伍 $t$，请计算出 $t$ 和其它所有队伍的差异的最大值。", "inputFormat": "第一行包含两个整数 $C$ 与 $N$。\n\n接下来 $N$ 行，每行有一个长度为 $C$ 的，仅包含字母 `G` 和 `H` 的字符串，每行对应一支奶牛队伍。", "outputFormat": "对于每个队伍，输出差异最大值。", "hint": "第一个和第三个队伍的差异为 $5$。第二个和第三个队伍的差异为 $3$。\n\n$2 \\leq N \\leq 10^5,1 \\leq C \\leq 18$。\n\n- 对于测试点 2-5：$C = 10$。\n- 对于测试点 6-9：所有答案最少为 $C - 3$。\n- 对于测试点 10-20：没有额外条件。", "locale": "zh-CN"}}}
{"pid": "P9188", "type": "P", "difficulty": 4, "samples": [["bessiebessie\n", "14\n"], ["abcdefghssijebessie\n", "28\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "USACO", "2023"], "title": "[USACO23OPEN] Pareidolia S", "background": "**Note: The time limit for this problem is 4s, 2x the default.**\n\nPareidolia is the phenomenon where your eyes tend to see familiar patterns in\nimages where none really exist -- for example seeing a face in a cloud.  As you\nmight imagine, with Farmer John's constant proximity to cows, he often sees\ncow-related patterns in everyday objects.  For example, if he looks at the\nstring \"bqessiyexbesszieb\", Farmer John's  eyes ignore some of the letters and\nall he sees is \"bessiebessie\".  ", "description": "Given a string $s$, let $B(s)$ represent the maximum number of repeated copies\nof \"bessie\" one can form by deleting zero or more of the characters from $s$. \nIn the example above, $B(\\text{``bqessiyexbesszieb\"}) = 2$.\n\nComputing $B(s)$ is an interesting challenge, but Farmer John is interested in\nsolving a challenge that is even more interesting: Given a string $t$ of length\nat most $3\\cdot 10^5$ consisting only of characters a-z, compute the sum of\n$B(s)$ over all contiguous substrings $s$ of $t$.", "inputFormat": "The input consists of a nonempty string of length at most $3\\cdot 10^5$ whose\ncharacters are all lowercase English letters.", "outputFormat": "Output a single number, the total number of bessies that can be made across all\nsubstrings of the input string.", "hint": "For the first sample, twelve substrings contain exactly $1$ \"bessie\", and $1$ string contains exactly $2$ \"bessie\"s, so the total is $12\\cdot 1+1\\cdot 2=14$.\n\n- Inputs 3-5: The string has length at most $5000$.\n- Inputs 6-12: No additional constraints.", "locale": "en", "translations": {"en": {"title": "[USACO23OPEN] Pareidolia S", "background": "**Note: The time limit for this problem is 4s, 2x the default.**\n\nPareidolia is the phenomenon where your eyes tend to see familiar patterns in\nimages where none really exist -- for example seeing a face in a cloud.  As you\nmight imagine, with Farmer John's constant proximity to cows, he often sees\ncow-related patterns in everyday objects.  For example, if he looks at the\nstring \"bqessiyexbesszieb\", Farmer John's  eyes ignore some of the letters and\nall he sees is \"bessiebessie\".  ", "description": "Given a string $s$, let $B(s)$ represent the maximum number of repeated copies\nof \"bessie\" one can form by deleting zero or more of the characters from $s$. \nIn the example above, $B(\\text{``bqessiyexbesszieb\"}) = 2$.\n\nComputing $B(s)$ is an interesting challenge, but Farmer John is interested in\nsolving a challenge that is even more interesting: Given a string $t$ of length\nat most $3\\cdot 10^5$ consisting only of characters a-z, compute the sum of\n$B(s)$ over all contiguous substrings $s$ of $t$.", "inputFormat": "The input consists of a nonempty string of length at most $3\\cdot 10^5$ whose\ncharacters are all lowercase English letters.", "outputFormat": "Output a single number, the total number of bessies that can be made across all\nsubstrings of the input string.", "hint": "For the first sample, twelve substrings contain exactly $1$ \"bessie\", and $1$ string contains exactly $2$ \"bessie\"s, so the total is $12\\cdot 1+1\\cdot 2=14$.\n\n- Inputs 3-5: The string has length at most $5000$.\n- Inputs 6-12: No additional constraints.", "locale": "en"}, "zh-CN": {"title": "[USACO23OPEN] Pareidolia S", "background": "", "description": "### 题目背景\n\n**注意：本题的时间限制为 4 秒，是默认时间限制的 2 倍。**\n\nPareidolia 是一种现象，指的是人们倾向于在并不真正存在的地方看到熟悉的图案——例如在云中看到一张脸。可以想象，由于农夫 John 经常与奶牛接触，他常常在日常物品中看到与奶牛相关的图案。例如，如果他看到字符串 \"bqessiyexbesszieb\"，农夫 John 的眼睛会忽略其中的一些字母，而他看到的只是 \"bessiebessie\"。\n\n\n给定一个字符串 $s$，令 $B(s)$ 表示通过删除 $s$ 中的零个或多个字符后，能够形成的 \"bessie\" 的最大重复次数。在上面的例子中，$B(\\text{``bqessiyexbesszieb\"}) = 2$。\n\n计算 $B(s)$ 是一个有趣的挑战，但农夫 John 对解决一个更有趣的挑战感兴趣：给定一个长度不超过 $3 \\cdot 10^5$ 的字符串 $t$，且仅由字符 a-z 组成，计算所有连续子串 $s$ 的 $B(s)$ 之和。", "inputFormat": "输入由一个非空字符串组成，长度不超过 $3 \\cdot 10^5$，且所有字符均为小写英文字母。", "outputFormat": "输出一个数字，表示输入字符串的所有子串中能够形成的 \"bessie\" 的总数。", "hint": "对于第一个样例，有 12 个子串恰好包含 $1$ 个 \"bessie\"，有 $1$ 个子串恰好包含 $2$ 个 \"bessie\"，因此总数为 $12 \\cdot 1 + 1 \\cdot 2 = 14$。\n\n- 输入 3-5：字符串长度不超过 $5000$。\n- 输入 6-12：没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P9189", "type": "P", "difficulty": 5, "samples": [["2\n\n5 5\n4 3 2 4 3\n3 4 3 4 2\n2 3 4 4 3\n1 2\n2 3\n3 1\n4 1\n4 5\n\n4 3\n3 2 4 1\n2 3 4 4\n4 2 3 4\n4 2\n4 1\n4 3\n", "YES\nNO\n"], ["5\n\n2 0\n1 2\n2 2\n2 2\n\n2 1\n1 1\n2 1\n2 1\n1 2\n\n2 1\n1 1\n2 1\n1 2\n1 2\n\n2 1\n1 1\n1 2\n2 1\n1 2\n\n5 4\n1 2 3 4 4\n2 3 5 4 2\n5 3 2 4 2\n1 2\n1 3\n1 4\n4 5\n", "YES\nYES\nNO\nYES\nNO\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["搜索", "图论", "USACO", "2023"], "title": "[USACO23OPEN] Custodial Cleanup G", "background": "", "description": "Due to the disorganized structure of his mootels (much like motels but with\nbovine rather than human guests), Farmer John has decided to take up the role of\nthe mootel custodian to restore order to the stalls.\n\nEach mootel has $N$ stalls labeled $1$ through $N$ and $M$ corridors that connect pairs of stalls to each other\nbidirectionally. The $i$ th stall is painted with color $C_i$ and initially has a\nsingle key of color $S_i$ in it. FJ will have to rearrange the keys to appease\nthe cows and restore order to the stalls.\n\nFJ starts out in stall $1$ without holding any keys and is allowed to repeatedly\ndo one of the following moves:\n- Pick up a key in the stall he is currently in. FJ can hold multiple keys at\na time.\n- Place down a key he is holding into the stall he is currently\nin. A stall may hold multiple keys at a time.\n- Enter stall $1$ by\nmoving through a corridor.\n- Enter a stall other than stall $1$ by\nmoving through a corridor. He can only do this if he currently holds a key that\nis the same color as the stall he is entering.\n\nUnfortunately, it seems that the keys are not in their intended locations. To\nrestore order to FJ's mootel, the $i$th stall requires that a single key of\ncolor $F_i$ is in it. It is guaranteed that $S$ is a permutation of $F$.\n\nFor $T$ different mootels, FJ starts in stall $1$ and needs\nto place every key in its appropriate location, ending back in stall $1$. For\neach of the $T$ mootels, please answer if it is possible to do this.", "inputFormat": "The first line contains $T$, the number of mootels (test cases).\n\nEach test case will be preceded by a blank line. Then, the first line \nof each test case contains two integers $N$ and $M$.\n\nThe second line of each test case contains $N$ integers. The $i$-th integer on\nthis line $C_i$ means that stall $i$ has color $C_i$.\n\nThe third line of each test case contains $N$ integers. The $i$-th integer on\nthis line $S_i$ means that stall $i$ initially holds a key of color $S_i$.\n\nThe fourth line of each test case contains $N$ integers. The $i$-th integer on\nthis line $F_i$ means that stall $i$ needs to have a key of color $F_i$ in it.\n\nThe next $M$ lines of each test case follow. The $i$-th of these lines contains\ntwo distinct integers $u_i$ and $v_i$. This represents\nthat a corridor exists between stalls $u_i$ and $v_i$. No corridors are\nrepeated.\n", "outputFormat": "For each mootel, output `YES` on a new line if there exists a way for FJ to return\na key of color $F_i$ to each stall $i$ and end back in stall $1$. Otherwise,\noutput `NO` on a new line.", "hint": "For the first test case of the first sample, here is a possible sequence of moves:\n\n```\nCurrent stall: 1. Keys held: []. Keys in stalls: [3, 4, 3, 4, 2]\n(pick up key of color 3)\nCurrent stall: 1. Keys held: [3]. Keys in stalls: [x, 4, 3, 4, 2]\n(move from stall 1 to 2, allowed since we have a key of color C_2=3)\nCurrent stall: 2. Keys held: [3]. Keys in stalls: [x, 4, 3, 4, 2]\n(pick up key of color 4)\nCurrent stall: 2. Keys held: [3, 4]. Keys in stalls: [x, x, 3, 4, 2]\n(move from stall 2 to 1 to 4 to 5, allowed since we have keys of colors C_4=4 and C_5=3)\nCurrent stall: 5. Keys held: [3, 4]. Keys in stalls: [x, x, 3, 4, 2]\n(pick up key of color 2 and place key of color 3)\nCurrent stall: 5. Keys held: [2, 4]. Keys in stalls: [x, x, 3, 4, 3]\n(move from stall 5 to 4 to 1 to 3, allowed since we have keys of colors C_4=4 and C_3=2)\nCurrent stall: 3. Keys held: [2, 4]. Keys in stalls: [x, x, 3, 4, 3]\n(pick up key of color 3 and place key of color 4)\nCurrent stall: 3. Keys held: [2, 3]. Keys in stalls: [x, x, 4, 4, 3]\n(move from stall 3 to stall 2 and place key of color 3)\nCurrent stall: 2. Keys held: [2]. Keys in stalls: [x, 3, 4, 4, 3]\n(move from stall 2 to stall 1 and place key of color 2)\nCurrent stall: 1. Keys held: []. Keys in stalls: [2, 3, 4, 4, 3]\n```\n\nFor the second test case of the first sample, there exists no way for FJ to return a key of color\n$F_i$ to each stall $i$ and end back at stall $1$.\n\n$0 \\le M \\le 10^5$, $1 \\le C_i, S_i, F_i, u_i, v_i \\le N \\le 10^5$.   \n$1 \\le T \\le 100$, $1 \\le \\sum N \\le 10^5$, $1 \\le \\sum M \\le 2\\cdot 10^5$.\n\n- Test cases 3-6 satisfy $N,M\\le 8$.\n- Test cases 7-10 satisfy $C_i=F_i$.\n- Test cases 11-18 satisfy no additional constraints.\n", "locale": "en", "translations": {"en": {"title": "[USACO23OPEN] Custodial Cleanup G", "background": "", "description": "Due to the disorganized structure of his mootels (much like motels but with\nbovine rather than human guests), Farmer John has decided to take up the role of\nthe mootel custodian to restore order to the stalls.\n\nEach mootel has $N$ stalls labeled $1$ through $N$ and $M$ corridors that connect pairs of stalls to each other\nbidirectionally. The $i$ th stall is painted with color $C_i$ and initially has a\nsingle key of color $S_i$ in it. FJ will have to rearrange the keys to appease\nthe cows and restore order to the stalls.\n\nFJ starts out in stall $1$ without holding any keys and is allowed to repeatedly\ndo one of the following moves:\n- Pick up a key in the stall he is currently in. FJ can hold multiple keys at\na time.\n- Place down a key he is holding into the stall he is currently\nin. A stall may hold multiple keys at a time.\n- Enter stall $1$ by\nmoving through a corridor.\n- Enter a stall other than stall $1$ by\nmoving through a corridor. He can only do this if he currently holds a key that\nis the same color as the stall he is entering.\n\nUnfortunately, it seems that the keys are not in their intended locations. To\nrestore order to FJ's mootel, the $i$th stall requires that a single key of\ncolor $F_i$ is in it. It is guaranteed that $S$ is a permutation of $F$.\n\nFor $T$ different mootels, FJ starts in stall $1$ and needs\nto place every key in its appropriate location, ending back in stall $1$. For\neach of the $T$ mootels, please answer if it is possible to do this.", "inputFormat": "The first line contains $T$, the number of mootels (test cases).\n\nEach test case will be preceded by a blank line. Then, the first line \nof each test case contains two integers $N$ and $M$.\n\nThe second line of each test case contains $N$ integers. The $i$-th integer on\nthis line $C_i$ means that stall $i$ has color $C_i$.\n\nThe third line of each test case contains $N$ integers. The $i$-th integer on\nthis line $S_i$ means that stall $i$ initially holds a key of color $S_i$.\n\nThe fourth line of each test case contains $N$ integers. The $i$-th integer on\nthis line $F_i$ means that stall $i$ needs to have a key of color $F_i$ in it.\n\nThe next $M$ lines of each test case follow. The $i$-th of these lines contains\ntwo distinct integers $u_i$ and $v_i$. This represents\nthat a corridor exists between stalls $u_i$ and $v_i$. No corridors are\nrepeated.\n", "outputFormat": "For each mootel, output `YES` on a new line if there exists a way for FJ to return\na key of color $F_i$ to each stall $i$ and end back in stall $1$. Otherwise,\noutput `NO` on a new line.", "hint": "For the first test case of the first sample, here is a possible sequence of moves:\n\n```\nCurrent stall: 1. Keys held: []. Keys in stalls: [3, 4, 3, 4, 2]\n(pick up key of color 3)\nCurrent stall: 1. Keys held: [3]. Keys in stalls: [x, 4, 3, 4, 2]\n(move from stall 1 to 2, allowed since we have a key of color C_2=3)\nCurrent stall: 2. Keys held: [3]. Keys in stalls: [x, 4, 3, 4, 2]\n(pick up key of color 4)\nCurrent stall: 2. Keys held: [3, 4]. Keys in stalls: [x, x, 3, 4, 2]\n(move from stall 2 to 1 to 4 to 5, allowed since we have keys of colors C_4=4 and C_5=3)\nCurrent stall: 5. Keys held: [3, 4]. Keys in stalls: [x, x, 3, 4, 2]\n(pick up key of color 2 and place key of color 3)\nCurrent stall: 5. Keys held: [2, 4]. Keys in stalls: [x, x, 3, 4, 3]\n(move from stall 5 to 4 to 1 to 3, allowed since we have keys of colors C_4=4 and C_3=2)\nCurrent stall: 3. Keys held: [2, 4]. Keys in stalls: [x, x, 3, 4, 3]\n(pick up key of color 3 and place key of color 4)\nCurrent stall: 3. Keys held: [2, 3]. Keys in stalls: [x, x, 4, 4, 3]\n(move from stall 3 to stall 2 and place key of color 3)\nCurrent stall: 2. Keys held: [2]. Keys in stalls: [x, 3, 4, 4, 3]\n(move from stall 2 to stall 1 and place key of color 2)\nCurrent stall: 1. Keys held: []. Keys in stalls: [2, 3, 4, 4, 3]\n```\n\nFor the second test case of the first sample, there exists no way for FJ to return a key of color\n$F_i$ to each stall $i$ and end back at stall $1$.\n\n$0 \\le M \\le 10^5$, $1 \\le C_i, S_i, F_i, u_i, v_i \\le N \\le 10^5$.   \n$1 \\le T \\le 100$, $1 \\le \\sum N \\le 10^5$, $1 \\le \\sum M \\le 2\\cdot 10^5$.\n\n- Test cases 3-6 satisfy $N,M\\le 8$.\n- Test cases 7-10 satisfy $C_i=F_i$.\n- Test cases 11-18 satisfy no additional constraints.\n", "locale": "en"}, "zh-CN": {"title": "[USACO23OPEN] Custodial Cleanup G", "background": "", "description": "由于他的“牛旅馆”（类似于汽车旅馆，但以牛为客人）的结构混乱，农夫约翰决定担任牛旅馆管理员的角色，以恢复牛舍的秩序。\n\n每个牛旅馆有 $N$ 个牛舍，标记为 $1$ 到 $N$，以及 $M$ 条双向连接牛舍的走廊。第 $i$ 个牛舍被涂上颜色 $C_i$，并且最初有一个颜色为 $S_i$ 的钥匙。FJ 需要重新安排钥匙以安抚奶牛并恢复牛舍的秩序。\n\nFJ 从牛舍 $1$ 开始，没有持有任何钥匙，并且可以反复执行以下操作之一：\n- 拿起他当前所在牛舍的钥匙。FJ 可以同时持有多个钥匙。\n- 将他持有的钥匙放入他当前所在的牛舍。一个牛舍可以同时容纳多个钥匙。\n- 通过走廊进入牛舍 $1$。\n- 通过走廊进入除牛舍 $1$ 以外的牛舍。只有当他当前持有的钥匙与他要进入的牛舍颜色相同时，他才能这样做。\n\n不幸的是，钥匙似乎不在它们预定的位置。为了恢复 FJ 的牛旅馆的秩序，第 $i$ 个牛舍需要有一个颜色为 $F_i$ 的钥匙。保证 $S$ 是 $F$ 的一个排列。\n\n对于 $T$ 个不同的牛旅馆，FJ 从牛舍 $1$ 开始，需要将每个钥匙放到其适当的位置，最后回到牛舍 $1$。对于每个 $T$ 个牛旅馆，请回答是否可以做到这一点。", "inputFormat": "第一行包含 $T$，表示牛旅馆的数量（测试用例）。\n\n每个测试用例前都有一个空行。然后，每个测试用例的第一行包含两个整数 $N$ 和 $M$。\n\n每个测试用例的第二行包含 $N$ 个整数。第 $i$ 个整数 $C_i$ 表示牛舍 $i$ 的颜色为 $C_i$。\n\n每个测试用例的第三行包含 $N$ 个整数。第 $i$ 个整数 $S_i$ 表示牛舍 $i$ 最初持有一个颜色为 $S_i$ 的钥匙。\n\n每个测试用例的第四行包含 $N$ 个整数。第 $i$ 个整数 $F_i$ 表示牛舍 $i$ 需要有一个颜色为 $F_i$ 的钥匙。\n\n每个测试用例接下来的 $M$ 行中，第 $i$ 行包含两个不同的整数 $u_i$ 和 $v_i$。这表示在牛舍 $u_i$ 和 $v_i$ 之间存在一条走廊。没有重复的走廊。", "outputFormat": "对于每个牛旅馆，如果存在一种方法可以让 FJ 将颜色为 $F_i$ 的钥匙返回到每个牛舍 $i$ 并最终回到牛舍 $1$，则在新行中输出 `YES`。否则，在新行中输出 `NO`。", "hint": "对于第一个样例的第一个测试用例，这里是一个可能的移动序列：\n\n```\n当前牛舍：1。持有的钥匙：[]。牛舍中的钥匙：[3, 4, 3, 4, 2]\n（拿起颜色为 3 的钥匙）\n当前牛舍：1。持有的钥匙：[3]。牛舍中的钥匙：[x, 4, 3, 4, 2]\n（从牛舍 1 移动到 2，因为我们有颜色为 $C_2=3$ 的钥匙）\n当前牛舍：2。持有的钥匙：[3]。牛舍中的钥匙：[x, 4, 3, 4, 2]\n（拿起颜色为 4 的钥匙）\n当前牛舍：2。持有的钥匙：[3, 4]。牛舍中的钥匙：[x, x, 3, 4, 2]\n（从牛舍 2 移动到 1 到 4 到 5，因为我们有颜色为 $C_4=4$ 和 $C_5=3$ 的钥匙）\n当前牛舍：5。持有的钥匙：[3, 4]。牛舍中的钥匙：[x, x, 3, 4, 2]\n（拿起颜色为 2 的钥匙并放下颜色为 3 的钥匙）\n当前牛舍：5。持有的钥匙：[2, 4]。牛舍中的钥匙：[x, x, 3, 4, 3]\n（从牛舍 5 移动到 4 到 1 到 3，因为我们有颜色为 $C_4=4$ 和 $C_3=2$ 的钥匙）\n当前牛舍：3。持有的钥匙：[2, 4]。牛舍中的钥匙：[x, x, 3, 4, 3]\n（拿起颜色为 3 的钥匙并放下颜色为 4 的钥匙）\n当前牛舍：3。持有的钥匙：[2, 3]。牛舍中的钥匙：[x, x, 4, 4, 3]\n（从牛舍 3 移动到牛舍 2 并放下颜色为 3 的钥匙）\n当前牛舍：2。持有的钥匙：[2]。牛舍中的钥匙：[x, 3, 4, 4, 3]\n（从牛舍 2 移动到牛舍 1 并放下颜色为 2 的钥匙）\n当前牛舍：1。持有的钥匙：[]。牛舍中的钥匙：[2, 3, 4, 4, 3]\n```\n\n对于第一个样例的第二个测试用例，没有办法让 FJ 将颜色为 $F_i$ 的钥匙返回到每个牛舍 $i$ 并最终回到牛舍 $1$。\n\n$0 \\le M \\le 10^5$, $1 \\le C_i, S_i, F_i, u_i, v_i \\le N \\le 10^5$。\n$1 \\le T \\le 100$, $1 \\le \\sum N \\le 10^5$, $1 \\le \\sum M \\le 2\\cdot 10^5$。\n\n- 测试用例 3-6 满足 $N,M\\le 8$。\n- 测试用例 7-10 满足 $C_i=F_i$。\n- 测试用例 11-18 不满足任何附加约束。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9190", "type": "P", "difficulty": 5, "samples": [["besssie\n1 1 5 4 6 1 1\n", "1\n4\n"], ["bebesconsiete\n6 5 2 3 6 5 7 9 8 1 4 5 1\n", "1\n21\n"], ["besgiraffesiebessibessie\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n", "2\n7\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["字符串", "动态规划 DP", "USACO", "2023"], "title": "[USACO23OPEN] Pareidolia G", "background": "Pareidolia is the phenomenon where your eyes tend to see familiar patterns in\nimages where none really exist -- for example seeing a face in a cloud.  As you\nmight imagine, with Farmer John's constant proximity to cows, he often sees\ncow-related patterns in everyday objects.  For example, if he looks at the\nstring \"bqessiyexbesszieb\", Farmer John's eyes ignore some of the letters and\nall he sees is \"bessiexbessieb\" -- a string that has contains two contiguous\nsubstrings equal to \"bessie\". ", "description": "Given a string of length at most $2\\cdot 10^5$ consisting only of characters\na-z, where each character has an associated deletion cost, compute the maximum\nnumber of contiguous substrings that equal \"bessie\" you can form by deleting\nzero or more characters from it, and the minimum total cost of the characters you need to\ndelete in order to do this.", "inputFormat": "The first line contains the string. The second line contains the deletion cost\nassociated with each character (an integer in the range $\\left[1,1000\\right]$).", "outputFormat": "The maximum number of occurrences, and the minimum cost to produce this number\nof occurrences.", "hint": "For the first sample, by deleting the 's' at position 4 we can make the whole string \"bessie\". The\ncharacter at position 4 has a cost of $4$, so our answer is cost $4$ for $1$\ninstance of \"bessie\", which is the best we can do.\n\nFor the second sample, by deleting the \"con\" at positions 5-7, we can make the string \"bebessiete\"\nwhich has \"bessie\" in the middle. Characters 5-7 have costs $5 + 7 + 9 = 21$, so\nour answer is cost $21$ for $1$ instance of \"bessie\", which is the best we can\ndo.\n\nFor the third sample, by deleting the \"giraffe\" at positions 4-10, we can make the string\n\"bessiebessibessie\", which has \"bessie\" at the beginning and the end. \"giraffe\"\nhas 7 characters and all characters have cost $1$, so our answer is cost $7$ for\n$2$ instances of \"bessie\", which is the best we can do. This sample satisfies the constraints for the second subtask.\n\n- Inputs 4-5: $N\\le 2000$.\n- Inputs 6-8: All costs are $1$.\n- Inputs 9-17: No additional constraints.", "locale": "en", "translations": {"en": {"title": "[USACO23OPEN] Pareidolia G", "background": "Pareidolia is the phenomenon where your eyes tend to see familiar patterns in\nimages where none really exist -- for example seeing a face in a cloud.  As you\nmight imagine, with Farmer John's constant proximity to cows, he often sees\ncow-related patterns in everyday objects.  For example, if he looks at the\nstring \"bqessiyexbesszieb\", Farmer John's eyes ignore some of the letters and\nall he sees is \"bessiexbessieb\" -- a string that has contains two contiguous\nsubstrings equal to \"bessie\". ", "description": "Given a string of length at most $2\\cdot 10^5$ consisting only of characters\na-z, where each character has an associated deletion cost, compute the maximum\nnumber of contiguous substrings that equal \"bessie\" you can form by deleting\nzero or more characters from it, and the minimum total cost of the characters you need to\ndelete in order to do this.", "inputFormat": "The first line contains the string. The second line contains the deletion cost\nassociated with each character (an integer in the range $\\left[1,1000\\right]$).", "outputFormat": "The maximum number of occurrences, and the minimum cost to produce this number\nof occurrences.", "hint": "For the first sample, by deleting the 's' at position 4 we can make the whole string \"bessie\". The\ncharacter at position 4 has a cost of $4$, so our answer is cost $4$ for $1$\ninstance of \"bessie\", which is the best we can do.\n\nFor the second sample, by deleting the \"con\" at positions 5-7, we can make the string \"bebessiete\"\nwhich has \"bessie\" in the middle. Characters 5-7 have costs $5 + 7 + 9 = 21$, so\nour answer is cost $21$ for $1$ instance of \"bessie\", which is the best we can\ndo.\n\nFor the third sample, by deleting the \"giraffe\" at positions 4-10, we can make the string\n\"bessiebessibessie\", which has \"bessie\" at the beginning and the end. \"giraffe\"\nhas 7 characters and all characters have cost $1$, so our answer is cost $7$ for\n$2$ instances of \"bessie\", which is the best we can do. This sample satisfies the constraints for the second subtask.\n\n- Inputs 4-5: $N\\le 2000$.\n- Inputs 6-8: All costs are $1$.\n- Inputs 9-17: No additional constraints.", "locale": "en"}, "zh-CN": {"title": "[USACO23OPEN] Pareidolia G", "background": "", "description": "### 题目背景\n\nPareidolia 是一种现象，指的是人们倾向于在并不真正存在的地方看到熟悉的图案——例如在云中看到一张脸。可以想象，由于农夫 John 经常与奶牛接触，他常常在日常物品中看到与奶牛相关的图案。例如，如果他看到字符串 \"bqessiyexbesszieb\"，农夫 John 的眼睛会忽略其中的一些字母，而他看到的只是 \"bessiexbessieb\"——一个包含两个连续子串等于 \"bessie\" 的字符串。\n\n\n给定一个长度不超过 $2 \\cdot 10^5$ 的字符串，且仅由字符 a-z 组成，其中每个字符都有一个相关的删除成本。计算通过删除零个或多个字符后，能够形成的等于 \"bessie\" 的连续子串的最大数量，以及为了实现这一目标所需删除字符的最小总成本。", "inputFormat": "第一行包含字符串。第二行包含每个字符的删除成本（一个在 $\\left[1,1000\\right]$ 范围内的整数）。", "outputFormat": "输出最大数量的 \"bessie\" 出现次数，以及实现这一数量所需的最小成本。", "hint": "对于第一个样例，通过删除位置 4 的 's'，我们可以使整个字符串变为 \"bessie\"。位置 4 的字符成本为 $4$，因此我们的答案是成本 $4$ 得到 $1$ 个 \"bessie\"，这是我们可以做到的最佳结果。\n\n对于第二个样例，通过删除位置 5-7 的 \"con\"，我们可以使字符串变为 \"bebessiete\"，其中包含中间的 \"bessie\"。位置 5-7 的字符成本为 $5 + 7 + 9 = 21$，因此我们的答案是成本 $21$ 得到 $1$ 个 \"bessie\"，这是我们可以做到的最佳结果。\n\n对于第三个样例，通过删除位置 4-10 的 \"giraffe\"，我们可以使字符串变为 \"bessiebessibessie\"，其中包含开头和结尾的 \"bessie\"。\"giraffe\" 有 7 个字符，且所有字符的成本均为 $1$，因此我们的答案是成本 $7$ 得到 $2$ 个 \"bessie\"，这是我们可以做到的最佳结果。此样例满足第二个子任务的约束条件。\n\n- 输入 4-5：$N \\le 2000$。\n- 输入 6-8：所有成本均为 $1$。\n- 输入 9-17：没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P9191", "type": "P", "difficulty": 5, "samples": [["1\n8\n7 5\n2 1\n4 2\n5 1\n3 2\n8 5\n6 2\n4\n8 5\n5 1\n6 5\n", "4\n2 5\n4 8\n3 8\n7 8\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "USACO", "2023", "Special Judge", "构造"], "title": "[USACO23OPEN] Tree Merging G", "background": "", "description": "Having just completed a course in graph algorithms, Bessie the cow has begun\ncoding her very own graph visualizer! Currently, her graph visualizer is only\ncapable of visualizing rooted trees with nodes of distinct values, and it can\nonly perform one kind of operation: merging.\n\nIn particular, a merging operation takes any two distinct nodes in a tree with\nthe same parent and merges them into one node, with value equal to the maximum\nof the values of the two nodes merged, and children a union of all the children\nof the nodes merged (if any).\n\nUnfortunately, after Bessie performed some merging operations on a tree, her\nprogram crashed, losing the history of the merging operations she performed. All\nBessie remembers is the tree she started with and the tree she ended with after\nshe performed all her merging operations. \n\nGiven her initial and final trees, please determine a sequence of merging\noperations Bessie could have performed. It is guaranteed that a sequence exists.\n\nEach input consists of $T$ independent test cases. It is\nguaranteed that the sum of $N$  over all test cases does not exceed $1000$.", "inputFormat": "The first line contains $T$, the number of independent test cases. Each test\ncase is formatted as follows.\n\nThe first line of each test case contains the number of nodes $N$ in Bessie's initial tree, which have values $1\\dots N$. \n\nEach of the next $N-1$ lines contains two space-separated node values $v_i$ and\n$p_i$ indicating that the node with value $v_i$ is a\nchild node of the node with value $p_i$ in Bessie's initial tree.\n\nThe next line contains the number of nodes $M$ in Bessie's\nfinal tree. \n\nEach of the next $M-1$ lines contains two space-separated node values $v_i$ and\n$p_i$ indicating that the node with value $v_i$ is a\nchild node of the node with value $p_i$ in Bessie's final tree.", "outputFormat": "For each test case, output the number of merging operations, followed by an\nordered sequence of merging operations of that length, one per line. \n\nEach merging operation should be formatted as two distinct space-separated\nintegers: the values of the two nodes to merge in any order. \n\nIf there are multiple solutions, output any.", "hint": "$1\\le T\\le 100$, $2 \\leq N \\leq 1000$, $1 \\leq v_i, p_i \\leq N$,$2 \\leq M \\leq N$.\n\n- Inputs 2-6: The initial and final trees have the same number of leaves.\n- Inputs 7-16: No additional constraints.", "locale": "en", "translations": {"en": {"title": "[USACO23OPEN] Tree Merging G", "background": "", "description": "Having just completed a course in graph algorithms, Bessie the cow has begun\ncoding her very own graph visualizer! Currently, her graph visualizer is only\ncapable of visualizing rooted trees with nodes of distinct values, and it can\nonly perform one kind of operation: merging.\n\nIn particular, a merging operation takes any two distinct nodes in a tree with\nthe same parent and merges them into one node, with value equal to the maximum\nof the values of the two nodes merged, and children a union of all the children\nof the nodes merged (if any).\n\nUnfortunately, after Bessie performed some merging operations on a tree, her\nprogram crashed, losing the history of the merging operations she performed. All\nBessie remembers is the tree she started with and the tree she ended with after\nshe performed all her merging operations. \n\nGiven her initial and final trees, please determine a sequence of merging\noperations Bessie could have performed. It is guaranteed that a sequence exists.\n\nEach input consists of $T$ independent test cases. It is\nguaranteed that the sum of $N$  over all test cases does not exceed $1000$.", "inputFormat": "The first line contains $T$, the number of independent test cases. Each test\ncase is formatted as follows.\n\nThe first line of each test case contains the number of nodes $N$ in Bessie's initial tree, which have values $1\\dots N$. \n\nEach of the next $N-1$ lines contains two space-separated node values $v_i$ and\n$p_i$ indicating that the node with value $v_i$ is a\nchild node of the node with value $p_i$ in Bessie's initial tree.\n\nThe next line contains the number of nodes $M$ in Bessie's\nfinal tree. \n\nEach of the next $M-1$ lines contains two space-separated node values $v_i$ and\n$p_i$ indicating that the node with value $v_i$ is a\nchild node of the node with value $p_i$ in Bessie's final tree.", "outputFormat": "For each test case, output the number of merging operations, followed by an\nordered sequence of merging operations of that length, one per line. \n\nEach merging operation should be formatted as two distinct space-separated\nintegers: the values of the two nodes to merge in any order. \n\nIf there are multiple solutions, output any.", "hint": "$1\\le T\\le 100$, $2 \\leq N \\leq 1000$, $1 \\leq v_i, p_i \\leq N$,$2 \\leq M \\leq N$.\n\n- Inputs 2-6: The initial and final trees have the same number of leaves.\n- Inputs 7-16: No additional constraints.", "locale": "en"}, "zh-CN": {"title": "[USACO23OPEN] Tree Merging G", "background": "", "description": "刚刚完成了一门图算法课程的奶牛 Bessie 开始编写她自己的图可视化工具！目前，她的图可视化工具只能可视化具有不同节点值的有根树，并且只能执行一种操作：合并。\n\n具体来说，合并操作会选取树中具有相同父节点的任意两个不同节点，并将它们合并为一个节点，新节点的值等于被合并的两个节点值的最大值，而新节点的子节点是被合并节点的所有子节点的并集（如果有的话）。\n\n不幸的是，在 Bessie 对一棵树执行了一些合并操作后，她的程序崩溃了，丢失了她执行的所有合并操作的历史记录。Bessie 只记得她最初开始的树以及执行完所有合并操作后得到的最终树。\n\n给定她的初始树和最终树，请确定 Bessie 可能执行的一系列合并操作。保证存在这样的操作序列。\n\n每个输入包含 $T$ 个独立的测试用例。保证所有测试用例的 $N$ 之和不超过 $1000$。", "inputFormat": "第一行包含 $T$，表示独立测试用例的数量。每个测试用例的格式如下。\n\n每个测试用例的第一行包含 Bessie 初始树中的节点数 $N$，节点值为 $1 \\dots N$。\n\n接下来的 $N-1$ 行，每行包含两个以空格分隔的节点值 $v_i$ 和 $p_i$，表示在 Bessie 的初始树中，值为 $v_i$ 的节点是值为 $p_i$ 的节点的子节点。\n\n接下来的一行包含 Bessie 最终树中的节点数 $M$。\n\n接下来的 $M-1$ 行，每行包含两个以空格分隔的节点值 $v_i$ 和 $p_i$，表示在 Bessie 的最终树中，值为 $v_i$ 的节点是值为 $p_i$ 的节点的子节点。", "outputFormat": "对于每个测试用例，首先输出合并操作的数量，然后按顺序输出相应数量的合并操作，每行一个操作。\n\n每个合并操作应格式化为两个以空格分隔的不同整数：被合并的两个节点的值（顺序任意）。\n\n如果有多个解，输出任意一个即可。", "hint": "$1 \\le T \\le 100$，$2 \\leq N \\leq 1000$，$1 \\leq v_i, p_i \\leq N$，$2 \\leq M \\leq N$。\n\n- 输入 2-6：初始树和最终树的叶子节点数量相同。\n- 输入 7-16：没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P9192", "type": "P", "difficulty": 6, "samples": [["bessiebessie\n3\n3 l\n7 s\n3 s", "14\n7\n1\n7"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "线段树", "USACO", "2023", "矩阵加速"], "title": "[USACO23OPEN] Pareidolia P", "background": "", "description": "Pareidolia is the phenomenon where your eyes tend to see familiar patterns in images where none really exist -- for example seeing a face in a cloud. As you might imagine, with Farmer John's constant proximity to cows, he often sees cow-related patterns in everyday objects. For example, if he looks at the string `bqessiyexbesszieb`, Farmer John's eyes ignore some of the letters and all he sees is `bessiebessie`.\n\nGiven a string $s$, let $B(s)$ represent the maximum number of repeated copies of `bessie` one can form by deleting zero or more of the characters from $s$. In the example above, $B(bqessiyexbesszieb)=2$. Furthermore, given a string $t$, let $A(t)$ represent the sum of $B(s)$ over all contiguous substrings $s$ of $t$.\n\nFarmer John has a string t of length at most $2\\times10^5$ consisting only of characters a-z. Please compute A(t), and how A(t) would change after $U (1\\le U\\le2\\times10^5)$ updates, each changing a character of t. Updates are cumulative.", "inputFormat": "The first line of input contains $t$.\n\nThe next line contains $U$, followed by $U$ lines each containing a position $p$ $(1\\le p\\le N)$ and a character $c$ in the range a-z, meaning that the pth character of $t$ is changed to $c$.", "outputFormat": "Output $U+1$ lines, the total number of bessies that can be made across all substrings of $t$ before any updates and after each update.", "hint": "Before any updates, twelve substrings contain exactly $1$ `bessie` and $1$ string contains exactly $2$ `bessie`s, so the total number of bessies is $12⋅1+1⋅2=14$.\n\nAfter one update, $t$ is `belsiebessie`. Seven substrings contain exactly one `bessie`.\n\nAfter two updates, $t$ is `belsiesessie`. Only the entire string contains `bessie`.\n\n\nInput $2$: $|t|,U\\le300$;\n\nInputs $3-5$: $U\\le10$;\n\nInputs $6-13$: $|t|,U\\le10^5$;\n\nInputs $14-21$: No additional constraints.", "locale": "en", "translations": {"en": {"title": "[USACO23OPEN] Pareidolia P", "background": "", "description": "Pareidolia is the phenomenon where your eyes tend to see familiar patterns in images where none really exist -- for example seeing a face in a cloud. As you might imagine, with Farmer John's constant proximity to cows, he often sees cow-related patterns in everyday objects. For example, if he looks at the string `bqessiyexbesszieb`, Farmer John's eyes ignore some of the letters and all he sees is `bessiebessie`.\n\nGiven a string $s$, let $B(s)$ represent the maximum number of repeated copies of `bessie` one can form by deleting zero or more of the characters from $s$. In the example above, $B(bqessiyexbesszieb)=2$. Furthermore, given a string $t$, let $A(t)$ represent the sum of $B(s)$ over all contiguous substrings $s$ of $t$.\n\nFarmer John has a string t of length at most $2\\times10^5$ consisting only of characters a-z. Please compute A(t), and how A(t) would change after $U (1\\le U\\le2\\times10^5)$ updates, each changing a character of t. Updates are cumulative.", "inputFormat": "The first line of input contains $t$.\n\nThe next line contains $U$, followed by $U$ lines each containing a position $p$ $(1\\le p\\le N)$ and a character $c$ in the range a-z, meaning that the pth character of $t$ is changed to $c$.", "outputFormat": "Output $U+1$ lines, the total number of bessies that can be made across all substrings of $t$ before any updates and after each update.", "hint": "Before any updates, twelve substrings contain exactly $1$ `bessie` and $1$ string contains exactly $2$ `bessie`s, so the total number of bessies is $12⋅1+1⋅2=14$.\n\nAfter one update, $t$ is `belsiebessie`. Seven substrings contain exactly one `bessie`.\n\nAfter two updates, $t$ is `belsiesessie`. Only the entire string contains `bessie`.\n\n\nInput $2$: $|t|,U\\le300$;\n\nInputs $3-5$: $U\\le10$;\n\nInputs $6-13$: $|t|,U\\le10^5$;\n\nInputs $14-21$: No additional constraints.", "locale": "en"}, "zh-CN": {"title": "[USACO23OPEN] Pareidolia P", "background": "", "description": "Pareidolia 是一种现象，指的是人们倾向于在并不真正存在的地方看到熟悉的图案——例如在云中看到一张脸。可以想象，由于农夫 John 经常与奶牛接触，他常常在日常物品中看到与奶牛相关的图案。例如，如果他看到字符串 `bqessiyexbesszieb`，农夫 John 的眼睛会忽略其中的一些字母，而他看到的只是 `bessiebessie`。\n\n给定一个字符串 $s$，令 $B(s)$ 表示通过删除 $s$ 中的零个或多个字符后，能够形成的 `bessie` 的最大重复次数。在上面的例子中，$B(bqessiyexbesszieb)=2$。此外，给定一个字符串 $t$，令 $A(t)$ 表示所有连续子串 $s$ 的 $B(s)$ 之和。\n\n农夫 John 有一个长度不超过 $2 \\times 10^5$ 的字符串 $t$，且仅由字符 a-z 组成。请计算 $A(t)$，以及在 $U (1 \\le U \\le 2 \\times 10^5)$ 次更新后 $A(t)$ 的变化情况，每次更新会修改 $t$ 中的一个字符。更新是累积的。", "inputFormat": "第一行输入包含 $t$。\n\n接下来的一行包含 $U$，随后是 $U$ 行，每行包含一个位置 $p$ $(1 \\le p \\le N)$ 和一个字符 $c$（范围为 a-z），表示将 $t$ 的第 $p$ 个字符修改为 $c$。", "outputFormat": "输出 $U+1$ 行，分别表示在没有任何更新之前以及每次更新后，$t$ 的所有子串中能够形成的 `bessie` 的总数。", "hint": "在没有任何更新之前，有 12 个子串恰好包含 $1$ 个 `bessie`，有 $1$ 个子串恰好包含 $2$ 个 `bessie`，因此 `bessie` 的总数为 $12 \\cdot 1 + 1 \\cdot 2 = 14$。\n\n第一次更新后，$t$ 变为 `belsiebessie`。有 7 个子串恰好包含一个 `bessie`。\n\n第二次更新后，$t$ 变为 `belsiesessie`。只有整个字符串包含 `bessie`。\n\n输入 $2$：$|t|, U \\le 300$；\n\n输入 $3-5$：$U \\le 10$；\n\n输入 $6-13$：$|t|, U \\le 10^5$；\n\n输入 $14-21$：没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P9193", "type": "P", "difficulty": 6, "samples": [["6\n1 1\n3 5\n4 7\n8 20\n4 10\n27 21\n", "1\n5\n7\n10\n6\n13"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["递推", "USACO", "2023", "O2优化", "向量"], "title": "[USACO23OPEN] Good Bitstrings P", "background": "", "description": "For any two positive integers $a$ and $b$, define the function `gen_string(a,b)` by the following Python code:\n\n```\ndef gen_string(a: int, b: int):\n\tres = \"\"\n\tia, ib = 0, 0\n\twhile ia + ib < a + b:\n\t\tif ia * b <= ib * a:\n\t\t\tres += '0'\n\t\t\tia += 1\n\t\telse:\n\t\t\tres += '1'\n\t\t\tib += 1\n\treturn res\n```\n\nEquivalent C++ code:\n\n```\nstring gen_string(int64_t a, int64_t b) {\n\tstring res;\n\tint ia = 0, ib = 0;\n\twhile (ia + ib < a + b) {\n\t\tif ((__int128)ia * b <= (__int128)ib * a) {\n\t\t\tres += '0';\n\t\t\tia++;\n\t\t} else {\n\t\t\tres += '1';\n\t\t\tib++;\n\t\t}\n\t}\n\treturn res;\n}\n```\n\n$ia$ will equal $a$ and $ib$ will equal $b$ when the loop terminates, so this function returns a bitstring of length $a+b$ with exactly $a$ zeroes and $b$ ones. For example, `gen_string(4,10)=01110110111011`.\n\nCall $a$ bitstring $s$ **good** if there exist positive integers $x$ and $y$ such that s=`gen_string(x,y)`. Given two positive integers $A$ and $B$ $(1\\le A,B\\le10^{18})$, your job is to compute the number of good prefixes of `gen_string(A,B)`. For example, there are $6$ good prefixes of `gen_string(4,10)`:\n\n```\nx = 1 | y = 1 | gen_string(x, y) = 01\nx = 1 | y = 2 | gen_string(x, y) = 011\nx = 1 | y = 3 | gen_string(x, y) = 0111\nx = 2 | y = 5 | gen_string(x, y) = 0111011\nx = 3 | y = 7 | gen_string(x, y) = 0111011011\nx = 4 | y = 10 | gen_string(x, y) = 01110110111011\n```", "inputFormat": "The first line contains $T$ $(1\\le T\\le10)$, the number of independent test cases.\n\nEach of the next $T$ lines contains two integers $A$ and $B$.", "outputFormat": "The answer for each test case on a new line.", "hint": "Input $2$: $A,B\\le100$;\\\nInput $3$: $A,B\\le1000$;\\\nInputs $4-7$: $A,B\\le10^6$;\\\nInputs $8-13$: All answers are at most $10^5$.\\\nInputs $14-21$: No additional constraints.", "locale": "en", "translations": {"en": {"title": "[USACO23OPEN] Good Bitstrings P", "background": "", "description": "For any two positive integers $a$ and $b$, define the function `gen_string(a,b)` by the following Python code:\n\n```\ndef gen_string(a: int, b: int):\n\tres = \"\"\n\tia, ib = 0, 0\n\twhile ia + ib < a + b:\n\t\tif ia * b <= ib * a:\n\t\t\tres += '0'\n\t\t\tia += 1\n\t\telse:\n\t\t\tres += '1'\n\t\t\tib += 1\n\treturn res\n```\n\nEquivalent C++ code:\n\n```\nstring gen_string(int64_t a, int64_t b) {\n\tstring res;\n\tint ia = 0, ib = 0;\n\twhile (ia + ib < a + b) {\n\t\tif ((__int128)ia * b <= (__int128)ib * a) {\n\t\t\tres += '0';\n\t\t\tia++;\n\t\t} else {\n\t\t\tres += '1';\n\t\t\tib++;\n\t\t}\n\t}\n\treturn res;\n}\n```\n\n$ia$ will equal $a$ and $ib$ will equal $b$ when the loop terminates, so this function returns a bitstring of length $a+b$ with exactly $a$ zeroes and $b$ ones. For example, `gen_string(4,10)=01110110111011`.\n\nCall $a$ bitstring $s$ **good** if there exist positive integers $x$ and $y$ such that s=`gen_string(x,y)`. Given two positive integers $A$ and $B$ $(1\\le A,B\\le10^{18})$, your job is to compute the number of good prefixes of `gen_string(A,B)`. For example, there are $6$ good prefixes of `gen_string(4,10)`:\n\n```\nx = 1 | y = 1 | gen_string(x, y) = 01\nx = 1 | y = 2 | gen_string(x, y) = 011\nx = 1 | y = 3 | gen_string(x, y) = 0111\nx = 2 | y = 5 | gen_string(x, y) = 0111011\nx = 3 | y = 7 | gen_string(x, y) = 0111011011\nx = 4 | y = 10 | gen_string(x, y) = 01110110111011\n```", "inputFormat": "The first line contains $T$ $(1\\le T\\le10)$, the number of independent test cases.\n\nEach of the next $T$ lines contains two integers $A$ and $B$.", "outputFormat": "The answer for each test case on a new line.", "hint": "Input $2$: $A,B\\le100$;\\\nInput $3$: $A,B\\le1000$;\\\nInputs $4-7$: $A,B\\le10^6$;\\\nInputs $8-13$: All answers are at most $10^5$.\\\nInputs $14-21$: No additional constraints.", "locale": "en"}, "zh-CN": {"title": "[USACO23OPEN] Good Bitstrings P", "background": "", "description": "对于任意两个正整数 $a$ 和 $b$，定义函数 `gen_string(a,b)` 如下 Python 代码所示：\n\n```python\ndef gen_string(a: int, b: int):\n\tres = \"\"\n\tia, ib = 0, 0\n\twhile ia + ib < a + b:\n\t\tif ia * b <= ib * a:\n\t\t\tres += '0'\n\t\t\tia += 1\n\t\telse:\n\t\t\tres += '1'\n\t\t\tib += 1\n\treturn res\n```\n\n等效的 C++ 代码如下：\n\n```cpp\nstring gen_string(int64_t a, int64_t b) {\n\tstring res;\n\tint ia = 0, ib = 0;\n\twhile (ia + ib < a + b) {\n\t\tif ((__int128)ia * b <= (__int128)ib * a) {\n\t\t\tres += '0';\n\t\t\tia++;\n\t\t} else {\n\t\t\tres += '1';\n\t\t\tib++;\n\t\t}\n\t}\n\treturn res;\n}\n```\n\n当循环结束时，$ia$ 将等于 $a$，$ib$ 将等于 $b$，因此该函数返回一个长度为 $a+b$ 的比特串，其中恰好包含 $a$ 个零和 $b$ 个一。例如，`gen_string(4,10)=01110110111011`。\n\n称一个 $0/1$ 串 $s$ 是**好的**，如果存在正整数 $x$ 和 $y$，使得 $s = \\text{gen\\_string}(x,y)$。给定两个正整数 $A$ 和 $B$ $(1 \\le A, B \\le 10^{18})$，你的任务是计算 `gen_string(A,B)` 的所有好前缀的数量。例如，`gen_string(4,10)` 有 $6$ 个好前缀：\n\n```\nx = 1 | y = 1 | gen_string(x, y) = 01\nx = 1 | y = 2 | gen_string(x, y) = 011\nx = 1 | y = 3 | gen_string(x, y) = 0111\nx = 2 | y = 5 | gen_string(x, y) = 0111011\nx = 3 | y = 7 | gen_string(x, y) = 0111011011\nx = 4 | y = 10 | gen_string(x, y) = 01110110111011\n```", "inputFormat": "第一行包含 $T$ $(1 \\le T \\le 10)$，表示独立测试用例的数量。\n\n接下来的 $T$ 行，每行包含两个整数 $A$ 和 $B$。", "outputFormat": "每个测试用例的答案单独占一行。", "hint": "输入 $2$：$A, B \\le 100$；\\\n输入 $3$：$A, B \\le 1000$；\\\n输入 $4-7$：$A, B \\le 10^6$；\\\n输入 $8-13$：所有答案不超过 $10^5$；\\\n输入 $14-21$：没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P9194", "type": "P", "difficulty": 7, "samples": [["3\n1 2\n2 3\n", "2\n0\n0\n"], ["4\n1 2\n1 3\n1 4\n", "6\n6\n0\n0\n"], ["5\n3 5\n5 1\n1 4\n1 2\n", "8\n10\n2\n0\n0\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "USACO", "并查集", "2023", "仙人掌", "圆方树"], "title": "[USACO23OPEN] Triples of Cows P", "background": "", "description": "There are initially $N-1$ pairs of friends among FJ's $N$ cows labeled $1\\dots N$, forming a tree. The cows are\nleaving the farm for vacation one by one. On day $i$, the $i$ th cow leaves the\nfarm, and then all pairs of the $i$ th cow's friends still present on the farm\nbecome friends. \n\nFor each $i$ from $1$ to $N$, just before the $i$ th cow leaves,  how many\nordered triples of distinct cows $(a,b,c)$ are there such that none of $a,b,c$\nare on vacation, $a$ is friends with $b$, and $b$ is friends with $c$?", "inputFormat": "The first line contains $N$.\n\nThe next $N-1$ lines contain two integers $u_i$ and $v_i$ denoting that cows\n$u_i$ and $v_i$ are initially friends.", "outputFormat": "The answers for $i$ from $1$ to $N$ on separate lines.", "hint": "For the first sample:  \n$(1,2,3)$ and $(3,2,1)$ are the triples just before cow $1$ leaves.  \nAfter cow\n$1$ leaves, there are less than $3$ cows left, so no triples are possible.\n\nFor the second sample:  \nAt the beginning, cow $1$ is friends with all other cows, and no other pairs of\ncows are friends, so the triples are $(a, 1, c)$ where $a, c$ are different cows\nfrom $\\{2, 3, 4\\}$, which gives $3 \\cdot 2 = 6$ triples.  \nAfter cow $1$ leaves, the remaining three cows are all friends, so the triples\nare just those three cows in any of the $3! = 6$ possible orders.  \nAfter cow $2$ leaves, there are less than $3$ cows left, so no triples are\npossible.  \n\n$2\\le N\\le 2\\cdot 10^5$, $1\\le u_i,v_i\\le N$.\n\n- Inputs 4-5: $N\\le 500$.\n- Inputs 6-10: $N\\le 5000$.\n- Inputs 11-20: No additional constraints.\n", "locale": "en", "translations": {"en": {"title": "[USACO23OPEN] Triples of Cows P", "background": "", "description": "There are initially $N-1$ pairs of friends among FJ's $N$ cows labeled $1\\dots N$, forming a tree. The cows are\nleaving the farm for vacation one by one. On day $i$, the $i$ th cow leaves the\nfarm, and then all pairs of the $i$ th cow's friends still present on the farm\nbecome friends. \n\nFor each $i$ from $1$ to $N$, just before the $i$ th cow leaves,  how many\nordered triples of distinct cows $(a,b,c)$ are there such that none of $a,b,c$\nare on vacation, $a$ is friends with $b$, and $b$ is friends with $c$?", "inputFormat": "The first line contains $N$.\n\nThe next $N-1$ lines contain two integers $u_i$ and $v_i$ denoting that cows\n$u_i$ and $v_i$ are initially friends.", "outputFormat": "The answers for $i$ from $1$ to $N$ on separate lines.", "hint": "For the first sample:  \n$(1,2,3)$ and $(3,2,1)$ are the triples just before cow $1$ leaves.  \nAfter cow\n$1$ leaves, there are less than $3$ cows left, so no triples are possible.\n\nFor the second sample:  \nAt the beginning, cow $1$ is friends with all other cows, and no other pairs of\ncows are friends, so the triples are $(a, 1, c)$ where $a, c$ are different cows\nfrom $\\{2, 3, 4\\}$, which gives $3 \\cdot 2 = 6$ triples.  \nAfter cow $1$ leaves, the remaining three cows are all friends, so the triples\nare just those three cows in any of the $3! = 6$ possible orders.  \nAfter cow $2$ leaves, there are less than $3$ cows left, so no triples are\npossible.  \n\n$2\\le N\\le 2\\cdot 10^5$, $1\\le u_i,v_i\\le N$.\n\n- Inputs 4-5: $N\\le 500$.\n- Inputs 6-10: $N\\le 5000$.\n- Inputs 11-20: No additional constraints.\n", "locale": "en"}, "zh-CN": {"title": "[USACO23OPEN] Triples of Cows P", "background": "", "description": "最初，农夫 John 的 $N$ 头编号为 $1 \\dots N$ 的奶牛中有 $N-1$ 对朋友关系，形成一棵树。奶牛们依次离开农场去度假。在第 $i$ 天，第 $i$ 头奶牛离开农场，然后所有仍在农场中的第 $i$ 头奶牛的朋友之间会成为朋友。\n\n对于每个 $i$ 从 $1$ 到 $N$，在第 $i$ 头奶牛离开之前，有多少个有序三元组 $(a, b, c)$ 满足以下条件：$a, b, c$ 均未离开农场，$a$ 与 $b$ 是朋友，且 $b$ 与 $c$ 是朋友？", "inputFormat": "第一行包含 $N$。\n\n接下来的 $N-1$ 行，每行包含两个整数 $u_i$ 和 $v_i$，表示奶牛 $u_i$ 和 $v_i$ 最初是朋友。", "outputFormat": "输出 $N$ 行，第 $i$ 行表示在第 $i$ 头奶牛离开之前的答案。", "hint": "对于第一个样例：  \n- 在第 $1$ 头奶牛离开之前，三元组为 $(1, 2, 3)$ 和 $(3, 2, 1)$。  \n- 在第 $1$ 头奶牛离开后，剩下的奶牛少于 $3$ 头，因此没有三元组。\n\n对于第二个样例：  \n- 最初，奶牛 $1$ 与所有其他奶牛是朋友，而其他奶牛之间没有朋友关系，因此三元组为 $(a, 1, c)$，其中 $a, c$ 是 $\\{2, 3, 4\\}$ 中的不同奶牛，共有 $3 \\cdot 2 = 6$ 个三元组。  \n- 在第 $1$ 头奶牛离开后，剩下的三头奶牛彼此都是朋友，因此三元组为这三头奶牛的任意排列，共有 $3! = 6$ 个三元组。  \n- 在第 $2$ 头奶牛离开后，剩下的奶牛少于 $3$ 头，因此没有三元组。  \n\n$2 \\le N \\le 2 \\cdot 10^5$，$1 \\le u_i, v_i \\le N$。\n\n- 输入 4-5：$N \\le 500$。\n- 输入 6-10：$N \\le 5000$。\n- 输入 11-20：没有额外限制。", "locale": "zh-CN"}}}
