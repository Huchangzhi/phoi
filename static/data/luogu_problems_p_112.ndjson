{"pid": "P3269", "type": "P", "difficulty": 7, "samples": [["2\nhello\n4\nhe\nl\nl\no\nabacaba\n4\nab\nba\na\nc", "4 5 \n4 6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2016", "各省省选", "吉林"], "title": "[JLOI2016] 字符串覆盖", "background": null, "description": "字符串 $A$ 有 $N$ 个子串 $B_1,B_2,...,B_n$。如果将这 $n$ 个子串分别放在恰好一个它在 $A$ 中出现的位置上（子串之间可以重叠）这样 $A$ 中的若干字符就被这 $N$ 个子串覆盖了。问 $A$ 中能被覆盖字符个数的最小值和最大值。", "inputFormat": "第一行包含一个正整数 $T$，表示数据组数。保证 $T \\le 10$。\n\n接下来依次描述 $T$ 组数据，每组数据中：\n\n第一行包含一个由小写字母组成的字符串，表示母串 $A$。\n\n第二行包含一个整数 $N$，表示子串的个数。\n\n接下来 $N$ 行，每行包含一个由小写字母组成的字符串，描述子串。数据保证所有子串均在母串中出现。", "outputFormat": "输出为 $T$  行，对应每组数据的答案。每行包含两个整数 $Minans$ 和 $Maxans$，分别表示对应数据中能被覆盖字符数量的最小值和最大值。", "hint": "字符串长度 $A \\le 10000$,$N \\le 4$,$\\text{子串长度} \\le 10000$。", "locale": "zh-CN", "translations": {"en": {"title": "[JLOI2016] String Coverage", "background": "", "description": "String $A$ has $N$ substrings $B_1,B_2,...,B_n$. If we place each of these $n$ substrings at exactly one position where it occurs in $A$ (substrings may overlap), then some characters in $A$ will be covered by these $N$ substrings. Find the minimum and maximum possible numbers of covered characters in $A$.", "inputFormat": "The first line contains a positive integer $T$, the number of test cases. It is guaranteed that $T \\le 10$.\n\nThen the $T$ test cases follow. For each test case:\n\n- The first line contains a string of lowercase letters, the main string $A$.\n- The second line contains an integer $N$, the number of substrings.\n- The next $N$ lines each contain a string of lowercase letters, describing a substring. It is guaranteed that every substring occurs in the main string.", "outputFormat": "Output $T$ lines, one for each test case. Each line contains two integers $Minans$ and $Maxans$, the minimum and maximum numbers of characters that can be covered, respectively.", "hint": "Constraints: $|A| \\le 10000$, $N \\le 4$, substring length $\\le 10000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JLOI2016] 字符串覆盖", "background": null, "description": "字符串 $A$ 有 $N$ 个子串 $B_1,B_2,...,B_n$。如果将这 $n$ 个子串分别放在恰好一个它在 $A$ 中出现的位置上（子串之间可以重叠）这样 $A$ 中的若干字符就被这 $N$ 个子串覆盖了。问 $A$ 中能被覆盖字符个数的最小值和最大值。", "inputFormat": "第一行包含一个正整数 $T$，表示数据组数。保证 $T \\le 10$。\n\n接下来依次描述 $T$ 组数据，每组数据中：\n\n第一行包含一个由小写字母组成的字符串，表示母串 $A$。\n\n第二行包含一个整数 $N$，表示子串的个数。\n\n接下来 $N$ 行，每行包含一个由小写字母组成的字符串，描述子串。数据保证所有子串均在母串中出现。", "outputFormat": "输出为 $T$  行，对应每组数据的答案。每行包含两个整数 $Minans$ 和 $Maxans$，分别表示对应数据中能被覆盖字符数量的最小值和最大值。", "hint": "字符串长度 $A \\le 10000$,$N \\le 4$,$\\text{子串长度} \\le 10000$。", "locale": "zh-CN"}}}
{"pid": "P3270", "type": "P", "difficulty": 6, "samples": [["3 2 1\n2 2\n1 2", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "2016", "各省省选", "吉林", "容斥原理"], "title": "[JLOI2016] 成绩比较", "background": "", "description": "G 系共有 $N$ 位同学，$M$ 门必修课。这 $N$ 位同学的编号为 $0$ 到 $N-1$ 的整数，其中 B 神的编号为 $0$ 号。这 $M$ 门必修课编号为 $0$ 到 $M-1$ 的整数。一位同学在必修课上可以获得的分数是 $1$ 到 $U_i$ 中的一个整数。\n\n如果在每门课上 A 获得的成绩均小于等于 B 获得的成绩，则称 A 被 B 碾压。在 B 神的说法中，G 系共有 $K$ 位同学被他碾压（不包括他自己），而其他 $N-K-1$ 位同学则没有被他碾压。D 神查到了 B 神每门必修课的排名。\n\n这里的排名是指：如果 B 神某门课的排名为 $R$，则表示有且仅有 $R-1$ 位同学这门课的分数大于 B 神的分数，有且仅有 $N-R$ 位同学这门课的分数小于等于 B 神（不包括他自己）。\n\n我们需要求出全系所有同学每门必修课得分的情况数，使其既能满足 B 神的说法，也能符合 D 神查到的排名。这里两种情况不同当且仅当有任意一位同学在任意一门课上获得的分数不同。\n\n你不需要像 D 神那么厉害，你只需要计算出情况数模 $10^9+7$ 的余数就可以了。", "inputFormat": "第一行包含三个正整数 $N,M,K$，分别表示 G 系的同学数量（包括 B 神），必修课的数量和被 B 神碾压的同学数量。\n\n第二行包含 $M$ 个正整数，依次表示每门课的最高分 $U_i$。\n\n第三行包含 $M$ 个正整数，依次表示 B 神在每门课上的排名 $R_i$。\n\n数据保证至少有 $1$ 种情况使得 B 神说的话成立。", "outputFormat": "仅一行一个正整数，表示满足条件的情况数模 $10^9+7$ 的余数。", "hint": "$1\\leq N\\leq 100$，$1\\leq M\\leq 100$，$1\\leq U_i\\leq 10^9$，$1\\leq R_i\\leq N$。", "locale": "zh-CN", "translations": {"en": {"title": "[JLOI2016] Grade Comparison", "background": "", "description": "The G Department has $N$ students and $M$ required courses. The students are numbered by integers from $0$ to $N-1$, and B Shen's number is $0$. The $M$ required courses are numbered from $0$ to $M-1$. In each required course, a student can earn an integer score from $1$ to $U_i$ inclusive.\n\nIf in every course A's score is less than or equal to B's score, then A is said to be dominated by B. According to B Shen, there are $K$ students whom he dominates (excluding himself), and the other $N-K-1$ students are not dominated by him. D Shen has found B Shen's rank in each required course.\n\nHere, rank means: if B Shen's rank in some course is $R$, then exactly $R-1$ students have a score strictly greater than B Shen's score in that course, and exactly $N-R$ students have a score less than or equal to B Shen's score in that course (excluding himself).\n\nWe need to count the number of possible score assignments for all students in all required courses that satisfy both B Shen's statement and the ranks found by D Shen. Two assignments are different if and only if there exists at least one student and one course where the assigned score differs.\n\nYou do not need to be as powerful as D Shen; just compute the answer modulo $10^9+7$.", "inputFormat": "- The first line contains three positive integers $N, M, K$, denoting the number of students in the G Department (including B Shen), the number of required courses, and the number of students dominated by B Shen.\n- The second line contains $M$ positive integers, the maximum score $U_i$ of each course in order.\n- The third line contains $M$ positive integers, B Shen's rank $R_i$ in each course in order.\n- It is guaranteed that there is at least one assignment that makes B Shen's statement hold.", "outputFormat": "Output a single integer on one line, the number of valid assignments modulo $10^9+7$.", "hint": "Constraints: $1 \\leq N \\leq 100$, $1 \\leq M \\leq 100$, $1 \\leq U_i \\leq 10^9$, $1 \\leq R_i \\leq N$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JLOI2016] 成绩比较", "background": "", "description": "G 系共有 $N$ 位同学，$M$ 门必修课。这 $N$ 位同学的编号为 $0$ 到 $N-1$ 的整数，其中 B 神的编号为 $0$ 号。这 $M$ 门必修课编号为 $0$ 到 $M-1$ 的整数。一位同学在必修课上可以获得的分数是 $1$ 到 $U_i$ 中的一个整数。\n\n如果在每门课上 A 获得的成绩均小于等于 B 获得的成绩，则称 A 被 B 碾压。在 B 神的说法中，G 系共有 $K$ 位同学被他碾压（不包括他自己），而其他 $N-K-1$ 位同学则没有被他碾压。D 神查到了 B 神每门必修课的排名。\n\n这里的排名是指：如果 B 神某门课的排名为 $R$，则表示有且仅有 $R-1$ 位同学这门课的分数大于 B 神的分数，有且仅有 $N-R$ 位同学这门课的分数小于等于 B 神（不包括他自己）。\n\n我们需要求出全系所有同学每门必修课得分的情况数，使其既能满足 B 神的说法，也能符合 D 神查到的排名。这里两种情况不同当且仅当有任意一位同学在任意一门课上获得的分数不同。\n\n你不需要像 D 神那么厉害，你只需要计算出情况数模 $10^9+7$ 的余数就可以了。", "inputFormat": "第一行包含三个正整数 $N,M,K$，分别表示 G 系的同学数量（包括 B 神），必修课的数量和被 B 神碾压的同学数量。\n\n第二行包含 $M$ 个正整数，依次表示每门课的最高分 $U_i$。\n\n第三行包含 $M$ 个正整数，依次表示 B 神在每门课上的排名 $R_i$。\n\n数据保证至少有 $1$ 种情况使得 B 神说的话成立。", "outputFormat": "仅一行一个正整数，表示满足条件的情况数模 $10^9+7$ 的余数。", "hint": "$1\\leq N\\leq 100$，$1\\leq M\\leq 100$，$1\\leq U_i\\leq 10^9$，$1\\leq R_i\\leq N$。", "locale": "zh-CN"}}}
{"pid": "P3271", "type": "P", "difficulty": 6, "samples": [["2 2 4\n1 0\n1 2\n0 1\n2 1", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "各省省选", "吉林", "枚举", "容斥原理"], "title": "[JLOI2016] 方", "background": null, "description": "上帝说，不要圆，要方，于是便有了这道题。\n\n由于我们应该方，而且最好能够尽量方，所以上帝派我们来找正方形。上帝把我们派到了一个有 $N$ 行 $M$ 列的方格图上，图上一共有 $(N+1)\\times(M+1)$ 个格点，我们需要做的就是找出这些格点形成了多少个正方形（换句话说，正方形的四个顶点都是格点）。\n\n但是这个问题对于我们来说太难了，因为点数太多了，所以上帝删掉了这 $(N+1)\\times(M+1)$ 中的 $K$ 个点。既然点变少了，问题也就变简单了，那么这个时候这些格点组成了多少个正方形呢？", "inputFormat": "第一行三个整数 $N, M, K$，代表棋盘的行数、 列数和不能选取的顶点个数。保证 $N, M \\ge 1$， $K \\le (N + 1) \\times(M + 1)$。\n\n约定每行的格点从上到下依次用整数 $0$ 到 $N$ 编号，每列的格点依次用 $0$ 到 $M$ 编号。\n\n接下来 $K$ 行，每行两个整数 $x,y$ 代表第 $x$ 行第 $y$ 列的格点被删掉了。\n\n保证 $0 \\le x \\le N \\le 10^6$，$0 \\le y \\le M \\le 10^6$，$K \\le 2000$ 且不会出现重复的格点。", "outputFormat": "仅一行一个正整数，代表正方形个数对 $100000007 ( 10^8 + 7)$ 取模之后的值。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[JLOI2016] Square", "background": "", "description": "God said, do not be round, be square; thus this problem.\n\nSince we should be square, and preferably as square as possible, God sent us to find squares. We are placed on a grid with $N$ rows and $M$ columns, containing $(N+1)\\times(M+1)$ grid points. Our task is to count how many squares can be formed such that all four vertices are grid points.\n\nHowever, the problem is too hard because there are too many points, so God deleted $K$ of these $(N+1)\\times(M+1)$ points. With fewer points, the problem becomes easier. Now, how many squares can be formed from the remaining grid points?", "inputFormat": "The first line contains three integers $N, M, K$, representing the number of rows, the number of columns, and the number of vertices that cannot be used. It is guaranteed that $N, M \\ge 1$, $K \\le (N+1)\\times(M+1)$.\n\nWe number the rows from top to bottom by integers $0$ to $N$, and the columns from left to right by $0$ to $M$.\n\nThe next $K$ lines each contain two integers $x, y$, indicating that the grid point at row $x$, column $y$ is deleted.\n\nIt is guaranteed that $0 \\le x \\le N \\le 10^6$, $0 \\le y \\le M \\le 10^6$, $K \\le 2000$, and no grid point is repeated.", "outputFormat": "Output a single positive integer: the number of squares modulo $100000007$ ($10^8 + 7$).", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JLOI2016] 方", "background": null, "description": "上帝说，不要圆，要方，于是便有了这道题。\n\n由于我们应该方，而且最好能够尽量方，所以上帝派我们来找正方形。上帝把我们派到了一个有 $N$ 行 $M$ 列的方格图上，图上一共有 $(N+1)\\times(M+1)$ 个格点，我们需要做的就是找出这些格点形成了多少个正方形（换句话说，正方形的四个顶点都是格点）。\n\n但是这个问题对于我们来说太难了，因为点数太多了，所以上帝删掉了这 $(N+1)\\times(M+1)$ 中的 $K$ 个点。既然点变少了，问题也就变简单了，那么这个时候这些格点组成了多少个正方形呢？", "inputFormat": "第一行三个整数 $N, M, K$，代表棋盘的行数、 列数和不能选取的顶点个数。保证 $N, M \\ge 1$， $K \\le (N + 1) \\times(M + 1)$。\n\n约定每行的格点从上到下依次用整数 $0$ 到 $N$ 编号，每列的格点依次用 $0$ 到 $M$ 编号。\n\n接下来 $K$ 行，每行两个整数 $x,y$ 代表第 $x$ 行第 $y$ 列的格点被删掉了。\n\n保证 $0 \\le x \\le N \\le 10^6$，$0 \\le y \\le M \\le 10^6$，$K \\le 2000$ 且不会出现重复的格点。", "outputFormat": "仅一行一个正整数，代表正方形个数对 $100000007 ( 10^8 + 7)$ 取模之后的值。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3272", "type": "P", "difficulty": 7, "samples": [["2 2\n*_\n__", "1"], ["3 3\n ___\n _*_\n ___", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2011", "四川", "各省省选", "O2优化", "广度优先搜索 BFS", "进制", "轮廓线 DP"], "title": "[SCOI2011] 地板", "background": "", "description": "lxhgww 的小名叫“小 L”，这是因为他总是很喜欢 L 型的东西。\n\n小 L 家的客厅是一个 $r\\times c$ 的矩形，现在他想用 L 型的地板来铺满整个客厅，客厅里有些位置有柱子，不能铺地板。\n\n现在小 L 想知道，用 L 型的地板铺满整个客厅有多少种不同的方案？\n\n需要注意的是，如下图所示，L 型地板的两端长度可以任意变化，但不能长度为 $0$。\n\n![](https://cdn.luogu.com.cn/upload/pic/4636.png)\n\n铺设完成后，客厅里面所有没有柱子的地方都必须铺上地板，但同一个地方不能被铺多次。", "inputFormat": "输入的第一行包含两个整数，$r$ 和 $c$，表示客厅的大小。\n\n接着是 $r$ 行，每行 $c$ 个字符，字符要么是 `_`，要么是 `*`，`_` 表示对应的位置是空的，必须铺地板；`*` 表示对应的位置有柱子，不能铺地板。", "outputFormat": "输出一行，包含一个整数，表示铺满整个客厅的方案数。由于这个数可能很大，只需输出它除以 $20110520$ 的余数。", "hint": "#### 数据规模与约定\n| 测试点编号 | 数据限制 |\n| :----------: | :----------: |\n| $1\\sim 2$ | $1\\le r\\times c\\le 25$ |\n| $3\\sim 5$ | $1\\le r\\times c\\le 100$ 并且 （$r=2$ 或者 $c=2$） |\n| $6\\sim 10$ | $1\\le r\\times c\\le 100$ |", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2011] Floor", "background": "", "description": "lxhgww’s nickname is “Little L” (Xiao L), because he always likes L-shaped things.\n\nLittle L’s living room is an $r\\times c$ rectangle. He wants to cover the entire living room with L-shaped tiles. Some positions contain pillars and cannot be tiled.\n\nLittle L wants to know how many different ways there are to tile the living room using L-shaped tiles.\n\nNote that, as shown in the figure below, the two arms of an L-shaped tile can have any positive lengths, but neither arm can have length $0$.\n\n![](https://cdn.luogu.com.cn/upload/pic/4636.png)\n\nAfter tiling, every position without a pillar must be covered by tiles, and no position may be covered more than once.", "inputFormat": "The first line contains two integers, $r$ and $c$, representing the size of the living room.\n\nThen follow $r$ lines, each containing $c$ characters. Each character is either `_` or `*`. `_` indicates the position is empty and must be tiled; `*` indicates the position has a pillar and cannot be tiled.", "outputFormat": "Output one line containing an integer: the number of tiling schemes. Since this number can be large, print the remainder when it is divided by $20110520$.", "hint": "#### Constraints\n| Test point ID | Limits |\n| :----------: | :----------: |\n| $1\\sim 2$ | $1\\le r\\times c\\le 25$ |\n| $3\\sim 5$ | $1\\le r\\times c\\le 100$ and ($r=2$ or $c=2$) |\n| $6\\sim 10$ | $1\\le r\\times c\\le 100$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2011] 地板", "background": "", "description": "lxhgww 的小名叫“小 L”，这是因为他总是很喜欢 L 型的东西。\n\n小 L 家的客厅是一个 $r\\times c$ 的矩形，现在他想用 L 型的地板来铺满整个客厅，客厅里有些位置有柱子，不能铺地板。\n\n现在小 L 想知道，用 L 型的地板铺满整个客厅有多少种不同的方案？\n\n需要注意的是，如下图所示，L 型地板的两端长度可以任意变化，但不能长度为 $0$。\n\n![](https://cdn.luogu.com.cn/upload/pic/4636.png)\n\n铺设完成后，客厅里面所有没有柱子的地方都必须铺上地板，但同一个地方不能被铺多次。", "inputFormat": "输入的第一行包含两个整数，$r$ 和 $c$，表示客厅的大小。\n\n接着是 $r$ 行，每行 $c$ 个字符，字符要么是 `_`，要么是 `*`，`_` 表示对应的位置是空的，必须铺地板；`*` 表示对应的位置有柱子，不能铺地板。", "outputFormat": "输出一行，包含一个整数，表示铺满整个客厅的方案数。由于这个数可能很大，只需输出它除以 $20110520$ 的余数。", "hint": "#### 数据规模与约定\n| 测试点编号 | 数据限制 |\n| :----------: | :----------: |\n| $1\\sim 2$ | $1\\le r\\times c\\le 25$ |\n| $3\\sim 5$ | $1\\le r\\times c\\le 100$ 并且 （$r=2$ 或者 $c=2$） |\n| $6\\sim 10$ | $1\\le r\\times c\\le 100$ |", "locale": "zh-CN"}}}
{"pid": "P3273", "type": "P", "difficulty": 6, "samples": [["3\n0 0 0\n8\nA1 3 -20\nA1 2 20\nU 1 3\nA2 1 10\nF1 3\nF2 3\nA3 -10\nF3", "-10\n10\n10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "四川", "线段树", "各省省选", "深度优先搜索 DFS", "连通块", "可并堆", "启发式合并"], "title": "[SCOI2011] 棘手的操作", "background": "", "description": "有 $N$ 个节点，标号从 $1$ 到 $N$，这 $N$ 个节点一开始相互不连通。第i个节点的初始权值为 $a_i$，接下来有如下一些操作：\n- `U x y`: 加一条边，连接第 $x$ 个节点和第 $y$ 个节点；\n- `A1 x v`: 将第 $x$ 个节点的权值增加 $v$；\n- `A2 x v`: 将第 $x$ 个节点所在的连通块的所有节点的权值都增加 $v$；\n- `A3 v`: 将所有节点的权值都增加 $v$；\n- `F1 x`: 输出第 $x$ 个节点当前的权值；\n- `F2 x`: 输出第 $x$ 个节点所在的连通块中，权值最大的节点的权值；\n- `F3`: 输出所有节点中，权值最大的节点的权值。", "inputFormat": "输入的第一行是一个整数 $N$，代表节点个数。接下来一行输入 $N$ 个整数，$a_1,a_2,\\dots,a_N$，代表 $N$ 个节点的初始权值。\n\n再下一行输入一个整数 $Q$，代表接下来的操作数。\n\n最后输入 $Q$ 行，每行的格式如题目描述所示。", "outputFormat": "对于操作 `F1 x`,`F2 x`,`F3`，输出对应的结果，每个结果占一行。", "hint": "对于 $30\\%$ 的数据，保证 $N\\le 100，Q\\le 10000$；\n\n对于 $80\\%$ 的数据，保证 $N\\le 100000$，$Q\\le 100000$；\n\n对于 $100\\%$ 的数据，保证 $N\\le 300000$，$Q\\le 300000$；\n\n对于所有的数据，保证输入合法，并且 $-1000\\le v,a_1,a_2,\\dots,a_N \\le 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2011] Tricky Operations", "background": "", "description": "There are $N$ nodes labeled from $1$ to $N$, initially all disconnected. The initial weight of the $i$-th node is $a_i$. Then the following operations occur:\n- `U x y`: add an edge connecting node $x$ and node $y$.\n- `A1 x v`: increase the weight of node $x$ by $v$.\n- `A2 x v`: increase the weights of all nodes in the connected component containing node $x$ by $v$.\n- `A3 v`: increase the weights of all nodes by $v$.\n- `F1 x`: output the current weight of node $x$.\n- `F2 x`: output the maximum weight within the connected component containing node $x$.\n- `F3`: output the maximum weight among all nodes.", "inputFormat": "The first line contains an integer $N$, the number of nodes. The second line contains $N$ integers $a_1,a_2,\\dots,a_N$, the initial weights of the $N$ nodes.\n\nThe next line contains an integer $Q$, the number of subsequent operations.\n\nEach of the following $Q$ lines is in one of the formats described above.", "outputFormat": "For operations `F1 x`, `F2 x`, and `F3`, output the corresponding result, one per line.", "hint": "Constraints:\n- For $30\\%$ of the testdata, $N \\le 100$, $Q \\le 10000$.\n- For $80\\%$ of the testdata, $N \\le 100000$, $Q \\le 100000$.\n- For $100\\%$ of the testdata, $N \\le 300000$, $Q \\le 300000$.\n- For all testdata, the input is guaranteed to be valid, and $-1000 \\le v, a_1, a_2, \\dots, a_N \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2011] 棘手的操作", "background": "", "description": "有 $N$ 个节点，标号从 $1$ 到 $N$，这 $N$ 个节点一开始相互不连通。第i个节点的初始权值为 $a_i$，接下来有如下一些操作：\n- `U x y`: 加一条边，连接第 $x$ 个节点和第 $y$ 个节点；\n- `A1 x v`: 将第 $x$ 个节点的权值增加 $v$；\n- `A2 x v`: 将第 $x$ 个节点所在的连通块的所有节点的权值都增加 $v$；\n- `A3 v`: 将所有节点的权值都增加 $v$；\n- `F1 x`: 输出第 $x$ 个节点当前的权值；\n- `F2 x`: 输出第 $x$ 个节点所在的连通块中，权值最大的节点的权值；\n- `F3`: 输出所有节点中，权值最大的节点的权值。", "inputFormat": "输入的第一行是一个整数 $N$，代表节点个数。接下来一行输入 $N$ 个整数，$a_1,a_2,\\dots,a_N$，代表 $N$ 个节点的初始权值。\n\n再下一行输入一个整数 $Q$，代表接下来的操作数。\n\n最后输入 $Q$ 行，每行的格式如题目描述所示。", "outputFormat": "对于操作 `F1 x`,`F2 x`,`F3`，输出对应的结果，每个结果占一行。", "hint": "对于 $30\\%$ 的数据，保证 $N\\le 100，Q\\le 10000$；\n\n对于 $80\\%$ 的数据，保证 $N\\le 100000$，$Q\\le 100000$；\n\n对于 $100\\%$ 的数据，保证 $N\\le 300000$，$Q\\le 300000$；\n\n对于所有的数据，保证输入合法，并且 $-1000\\le v,a_1,a_2,\\dots,a_N \\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P3274", "type": "P", "difficulty": 7, "samples": [["4 2 1\n1 2\n5 2", "2 2\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "四川", "线段树", "各省省选", "平衡树", "连通块"], "title": "[SCOI2011] 植物大战僵尸", "background": "", "description": "坚果保龄球是植物大战僵尸中的一个小游戏。现在疯狂戴夫只给了 lxhgww 一些最普通的坚果，让 lxhgww 像保龄球一样把坚果扔出去，砸死院子里的僵尸。\n\n院子一共由 $N$ 条轨道组成，从上到下依次编号从 $1$ 到 $N$，每条轨道又被分成若干格。院子里一共有 $M$ 只僵尸，每只僵尸站在某个格子内，并且可以认为它的位置不会变化。\n\n游戏可以分成 $K$ 个回合，在每个回合中，你可以选择一条轨道，把一个坚果扔出去。被扔出去的坚果首先会沿着轨道直线的从左往右滚动，直到撞到第一只僵尸之后，它开始沿着 $45$ 度的斜线滚动，并且向中心的一侧滚动（即前 $N/2$ 行的向右下滚动，后 $N/2$ 行的向右上滚动，题目保证 $N$ 是偶数）。院子的两边是围墙。斜着走的坚果撞到围墙或者僵尸会反弹，即从往右上走变成往右下走，或者反过来。直到坚果不再能打到任何僵尸之后，该回合结束。\n\n注意：多只僵尸可能站在同一格，这个时候坚果每次只会撞死该格子的其中一只僵尸。为了砸死尽量多的僵尸，现在 lxhgww 决定在每回合的开始，选择在当前情况下可以砸死最多僵尸的一条路线扔出坚果。在出现相同的情况时，他会选择编号最小的轨道扔出。\n\n为了了解这个做法的效果，现在 lxhgww 需要你帮助他计算这个方法可以砸死的僵尸数目。\n", "inputFormat": "输入的第一行有 3 个整数，$N$，$M$，$K$。接下来 $M$ 行，每行两个整数 $X_i$, $Y_i$，表示第 $i$ 个僵尸位于第 $Y_i$ 条轨道，从左数第 $X_i$ 个格子中。\n", "outputFormat": "输出数据包括 $K+1$ 行。前 $K$ 行，每行2个数据 $A_i, B_i$，表示在第 $i$ 个回合，从第 $A_i$ 条轨道扔出坚果，这个坚果在运行过程中打到了 $B_i$ 个僵尸。最后一行是一个数字，表示被打到的僵尸总数。\n", "hint": "【数据范围】\n\n对于 $20\\%$ 的数据，保证： $N\\le200$，$M\\le500$，$K\\le200$，$X_i\\le200$；\n\n对于 $50\\%$ 的数据，保证： $N\\le200$，$M\\le2\\times 10^5$，$K\\le200$，$X_i\\le10^6$；\n\n对于 $100\\%$ 的数据，保证： $N\\le20000$，$M\\le2\\times 10^5$，$K\\le10^5$，$Xi\\le10^6$。\n\n对于所有的数据，保证：$1\\le Y_i\\le N$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2011] Plants vs. Zombies", "background": "", "description": "Walnut Bowling is a minigame in Plants vs. Zombies. Now Crazy Dave only gave lxhgww some ordinary walnuts and asked lxhgww to throw them like bowling balls to smash the zombies in the yard.\n\nThe yard consists of $N$ lanes, numbered from $1$ to $N$ from top to bottom. Each lane is divided into cells. There are $M$ zombies in total, each standing in some cell, and you may assume their positions are fixed.\n\nThe game has $K$ rounds. In each round, you can choose one lane and throw a walnut. The thrown walnut first rolls straight from left to right along that lane. After it hits the first zombie, it begins to roll along a $45$-degree diagonal toward the center line of the yard (that is, in the first $N/2$ lanes it rolls down-right, and in the last $N/2$ lanes it rolls up-right; it is guaranteed that $N$ is even). The yard is bounded by walls. When a diagonally moving walnut hits a wall or a zombie, it bounces: up-right becomes down-right, or vice versa. The round ends when the walnut can no longer hit any zombie.\n\nNote: Multiple zombies may stand in the same cell; in that case, each time the walnut only kills one zombie in that cell. To kill as many zombies as possible, at the start of each round lxhgww chooses the lane whose resulting path will kill the maximum number of zombies under the current state. When there is a tie, he chooses the lane with the smallest index.\n\nTo evaluate this strategy, lxhgww needs your help to compute the number of zombies that can be killed by this method.", "inputFormat": "The first line contains three integers $N$, $M$, $K$. Then each of the next $M$ lines contains two integers $X_i$, $Y_i$, meaning that the $i$-th zombie is at lane $Y_i$, column $X_i$ (the $X_i$-th cell from the left).", "outputFormat": "Output $K+1$ lines. The first $K$ lines each contain two integers $A_i, B_i$, meaning that in the $i$-th round, the walnut is thrown from lane $A_i$ and hits $B_i$ zombies during its movement. The last line contains a single integer: the total number of zombies hit.", "hint": "Constraints\n\nFor $20\\%$ of the testdata, it is guaranteed that: $N \\le 200$, $M \\le 500$, $K \\le 200$, $X_i \\le 200$.\n\nFor $50\\%$ of the testdata, it is guaranteed that: $N \\le 200$, $M \\le 2\\times 10^5$, $K \\le 200$, $X_i \\le 10^6$.\n\nFor $100\\%$ of the testdata, it is guaranteed that: $N \\le 20000$, $M \\le 2\\times 10^5$, $K \\le 10^5$, $X_i \\le 10^6$.\n\nFor all testdata, it is guaranteed that: $1 \\le Y_i \\le N$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2011] 植物大战僵尸", "background": "", "description": "坚果保龄球是植物大战僵尸中的一个小游戏。现在疯狂戴夫只给了 lxhgww 一些最普通的坚果，让 lxhgww 像保龄球一样把坚果扔出去，砸死院子里的僵尸。\n\n院子一共由 $N$ 条轨道组成，从上到下依次编号从 $1$ 到 $N$，每条轨道又被分成若干格。院子里一共有 $M$ 只僵尸，每只僵尸站在某个格子内，并且可以认为它的位置不会变化。\n\n游戏可以分成 $K$ 个回合，在每个回合中，你可以选择一条轨道，把一个坚果扔出去。被扔出去的坚果首先会沿着轨道直线的从左往右滚动，直到撞到第一只僵尸之后，它开始沿着 $45$ 度的斜线滚动，并且向中心的一侧滚动（即前 $N/2$ 行的向右下滚动，后 $N/2$ 行的向右上滚动，题目保证 $N$ 是偶数）。院子的两边是围墙。斜着走的坚果撞到围墙或者僵尸会反弹，即从往右上走变成往右下走，或者反过来。直到坚果不再能打到任何僵尸之后，该回合结束。\n\n注意：多只僵尸可能站在同一格，这个时候坚果每次只会撞死该格子的其中一只僵尸。为了砸死尽量多的僵尸，现在 lxhgww 决定在每回合的开始，选择在当前情况下可以砸死最多僵尸的一条路线扔出坚果。在出现相同的情况时，他会选择编号最小的轨道扔出。\n\n为了了解这个做法的效果，现在 lxhgww 需要你帮助他计算这个方法可以砸死的僵尸数目。\n", "inputFormat": "输入的第一行有 3 个整数，$N$，$M$，$K$。接下来 $M$ 行，每行两个整数 $X_i$, $Y_i$，表示第 $i$ 个僵尸位于第 $Y_i$ 条轨道，从左数第 $X_i$ 个格子中。\n", "outputFormat": "输出数据包括 $K+1$ 行。前 $K$ 行，每行2个数据 $A_i, B_i$，表示在第 $i$ 个回合，从第 $A_i$ 条轨道扔出坚果，这个坚果在运行过程中打到了 $B_i$ 个僵尸。最后一行是一个数字，表示被打到的僵尸总数。\n", "hint": "【数据范围】\n\n对于 $20\\%$ 的数据，保证： $N\\le200$，$M\\le500$，$K\\le200$，$X_i\\le200$；\n\n对于 $50\\%$ 的数据，保证： $N\\le200$，$M\\le2\\times 10^5$，$K\\le200$，$X_i\\le10^6$；\n\n对于 $100\\%$ 的数据，保证： $N\\le20000$，$M\\le2\\times 10^5$，$K\\le10^5$，$Xi\\le10^6$。\n\n对于所有的数据，保证：$1\\le Y_i\\le N$。\n", "locale": "zh-CN"}}}
{"pid": "P3275", "type": "P", "difficulty": 5, "samples": [["5 7\n1 1 2\n2 3 2\n4 4 1\n3 4 5\n5 4 5\n2 3 5\n4 5 1", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2011", "四川", "各省省选", "拓扑排序", "Tarjan", "差分约束"], "title": "[SCOI2011] 糖果", "background": null, "description": "幼儿园里有 $N$ 个小朋友，$\\text{lxhgww}$ 老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果的时候，$\\text{lxhgww}$ 需要满足小朋友们的 $K$ 个要求。幼儿园的糖果总是有限的，$\\text{lxhgww}$ 想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。", "inputFormat": "输入的第一行是两个整数 $N,K$。接下来 $K$ 行，每行 $3$ 个数字 $X,A,B$，表示小朋友们的要求。\n\n+ 如果 $X=1$， 表示第 $A$ 个小朋友分到的糖果必须和第 $B$ 个小朋友分到的糖果一样多；\n+ 如果 $X=2$， 表示第 $A$ 个小朋友分到的糖果必须少于第 $B$ 个小朋友分到的糖果；\n+ 如果 $X=3$， 表示第 $A$ 个小朋友分到的糖果必须不少于第 $B$ 个小朋友分到的糖果；\n+ 如果 $X=4$， 表示第 $A$ 个小朋友分到的糖果必须多于第 $B$ 个小朋友分到的糖果；\n+ 如果 $X=5$， 表示第 $A$ 个小朋友分到的糖果必须不多于第 $B$ 个小朋友分到的糖果；", "outputFormat": "输出一行一个整数，表示 $\\text{lxhgww}$ 老师至少需要准备的糖果数，如果不能满足小朋友们的所有要求，则输出 $-1$。", "hint": "对于 $30\\%$ 的数据，$N\\leq100$；\n\n对于 $100\\%$ 的数据，$1\\leq N,K\\leq10^5, 1\\leq X\\leq5, 1\\leq A, B\\leq N$。\n\n---\n\n$\\text{upd 2022.7.6}$：新添加 $21$ 组 [Hack 数据](https://www.luogu.com.cn/discuss/454051)。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2011] Candy", "background": "", "description": "There are $N$ children in a kindergarten. Teacher $\\text{lxhgww}$ wants to distribute candies to them, and every child must receive at least one candy. However, the children can be jealous and may raise some requests. For example, Xiao Ming does not want Xiao Hong to receive more candies than he does. Therefore, when distributing candies, $\\text{lxhgww}$ needs to satisfy $K$ requests from the children. Since the total number of candies is limited, $\\text{lxhgww}$ wants to know the minimum number of candies he needs to prepare so that every child receives candies and all requests are satisfied.", "inputFormat": "The first line contains two integers $N, K$. The next $K$ lines each contain $3$ integers $X, A, B$, describing a request from the children.\n\n+ If $X=1$, the $A$-th child must receive the same number of candies as the $B$-th child.\n+ If $X=2$, the $A$-th child must receive fewer candies than the $B$-th child.\n+ If $X=3$, the $A$-th child must receive no fewer candies than the $B$-th child.\n+ If $X=4$, the $A$-th child must receive more candies than the $B$-th child.\n+ If $X=5$, the $A$-th child must receive no more candies than the $B$-th child.", "outputFormat": "Output a single integer: the minimum number of candies $\\text{lxhgww}$ needs to prepare. If it is impossible to satisfy all the requests, output $-1$.", "hint": "For $30\\%$ of the testdata, $N \\leq 100$.\n\nFor $100\\%$ of the testdata, $1 \\leq N, K \\leq 10^5$, $1 \\leq X \\leq 5$, $1 \\leq A, B \\leq N$.\n\n---\n\n$\\text{upd 2022.7.6}$: Added $21$ sets of [Hack testdata](https://www.luogu.com.cn/discuss/454051).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2011] 糖果", "background": null, "description": "幼儿园里有 $N$ 个小朋友，$\\text{lxhgww}$ 老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果的时候，$\\text{lxhgww}$ 需要满足小朋友们的 $K$ 个要求。幼儿园的糖果总是有限的，$\\text{lxhgww}$ 想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。", "inputFormat": "输入的第一行是两个整数 $N,K$。接下来 $K$ 行，每行 $3$ 个数字 $X,A,B$，表示小朋友们的要求。\n\n+ 如果 $X=1$， 表示第 $A$ 个小朋友分到的糖果必须和第 $B$ 个小朋友分到的糖果一样多；\n+ 如果 $X=2$， 表示第 $A$ 个小朋友分到的糖果必须少于第 $B$ 个小朋友分到的糖果；\n+ 如果 $X=3$， 表示第 $A$ 个小朋友分到的糖果必须不少于第 $B$ 个小朋友分到的糖果；\n+ 如果 $X=4$， 表示第 $A$ 个小朋友分到的糖果必须多于第 $B$ 个小朋友分到的糖果；\n+ 如果 $X=5$， 表示第 $A$ 个小朋友分到的糖果必须不多于第 $B$ 个小朋友分到的糖果；", "outputFormat": "输出一行一个整数，表示 $\\text{lxhgww}$ 老师至少需要准备的糖果数，如果不能满足小朋友们的所有要求，则输出 $-1$。", "hint": "对于 $30\\%$ 的数据，$N\\leq100$；\n\n对于 $100\\%$ 的数据，$1\\leq N,K\\leq10^5, 1\\leq X\\leq5, 1\\leq A, B\\leq N$。\n\n---\n\n$\\text{upd 2022.7.6}$：新添加 $21$ 组 [Hack 数据](https://www.luogu.com.cn/discuss/454051)。", "locale": "zh-CN"}}}
{"pid": "P3276", "type": "P", "difficulty": 7, "samples": [["10\n2\n6\n6\n2\n6\n6", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "四川", "并查集", "各省省选", "平衡树", "数位 DP", "连通块", "进制", "分类讨论"], "title": "[SCOI2011] 镜像拆分", "background": "", "description": "lxhgww 非常喜欢数字游戏，他发现，很多数都可以表示成两个相互反转的数之和，他把这个现象称为数的“镜像拆分”。比如 $66$ 共有五种镜像拆分方法：$66=15+51=24+42=33+33=42+24=51+15$。注意，前导 0 是不允许的，所以 $66=60+06$ 不算做合法的镜像拆分。现在 lxhgww 想知道，在 K 进制下，对于在 $[A,B]$ 区间内的数，其镜像拆分的方案数之和是多少？", "inputFormat": "输入的第一行是一个数 $K$。输入的第二行是一个数 $n$，表示数字 $A$ 的长度。接下来 $n$ 行，表示 $A$ 从低位开始的每一位数字。然后是一个数 $m$，表示数字 $B$ 的长度。接下来 $m$ 行，表示 $B$ 从低位开始的每一位数字。\n", "outputFormat": "输出一行，包含一个整数，表示镜像拆分的方案数之和。由于这个答案非常大，只需要输出这个答案除以 $20110521$ 的余数。\n", "hint": "对于 $20\\%$ 的数据，保证：$2\\le K\\le100$，$1\\le n,m\\le100$。\n\n对于 $50\\%$ 的数据，保证：$2\\le K\\le1000$，$1\\le n,m\\le1000$。\n\n对于 $100\\%$ 的数据，保证：$2\\le K\\le10^5$，$1\\le n,m\\le10 ^ 5$。\n\n对于所有的数据，保证：$0\\lt A\\le B$。$A,B$ 的每一位数字都在 $[0, K-1]$ 的范围内，没有前导零。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2011] Mirror Decomposition", "background": "", "description": "lxhgww loves number games. He discovered that many numbers can be expressed as the sum of two numbers that are reverses of each other; he calls this phenomenon a number’s “mirror decomposition”. For example, $66$ has five mirror decompositions: $66=15+51=24+42=33+33=42+24=51+15$. Note that leading zeros are not allowed, so $66=60+06$ is not counted as a valid mirror decomposition. Now lxhgww wants to know, in base $K$, for the numbers in the interval $[A,B]$, what is the sum of the counts of their mirror decompositions?", "inputFormat": "The first line of input is a number $K$. The second line is a number $n$, denoting the length of the number $A$. The next $n$ lines give each digit of $A$ starting from the least significant digit. Then comes a number $m$, denoting the length of the number $B$. The next $m$ lines give each digit of $B$ starting from the least significant digit.", "outputFormat": "Output one line containing an integer, which is the sum of the counts of mirror decompositions. Since the answer can be very large, output the remainder when this answer is divided by $20110521$.", "hint": "- For $20\\%$ of the testdata, it is guaranteed that: $2\\le K\\le100$, $1\\le n,m\\le100$.\n- For $50\\%$ of the testdata, it is guaranteed that: $2\\le K\\le1000$, $1\\le n,m\\le1000$.\n- For $100\\%$ of the testdata, it is guaranteed that: $2\\le K\\le10^5$, $1\\le n,m\\le10 ^ 5$.\n- For all the testdata, it is guaranteed that: $0\\lt A\\le B$. Each digit of $A$ and $B$ is in the range $[0, K-1]$, and there are no leading zeros.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2011] 镜像拆分", "background": "", "description": "lxhgww 非常喜欢数字游戏，他发现，很多数都可以表示成两个相互反转的数之和，他把这个现象称为数的“镜像拆分”。比如 $66$ 共有五种镜像拆分方法：$66=15+51=24+42=33+33=42+24=51+15$。注意，前导 0 是不允许的，所以 $66=60+06$ 不算做合法的镜像拆分。现在 lxhgww 想知道，在 K 进制下，对于在 $[A,B]$ 区间内的数，其镜像拆分的方案数之和是多少？", "inputFormat": "输入的第一行是一个数 $K$。输入的第二行是一个数 $n$，表示数字 $A$ 的长度。接下来 $n$ 行，表示 $A$ 从低位开始的每一位数字。然后是一个数 $m$，表示数字 $B$ 的长度。接下来 $m$ 行，表示 $B$ 从低位开始的每一位数字。\n", "outputFormat": "输出一行，包含一个整数，表示镜像拆分的方案数之和。由于这个答案非常大，只需要输出这个答案除以 $20110521$ 的余数。\n", "hint": "对于 $20\\%$ 的数据，保证：$2\\le K\\le100$，$1\\le n,m\\le100$。\n\n对于 $50\\%$ 的数据，保证：$2\\le K\\le1000$，$1\\le n,m\\le1000$。\n\n对于 $100\\%$ 的数据，保证：$2\\le K\\le10^5$，$1\\le n,m\\le10 ^ 5$。\n\n对于所有的数据，保证：$0\\lt A\\le B$。$A,B$ 的每一位数字都在 $[0, K-1]$ 的范围内，没有前导零。", "locale": "zh-CN"}}}
{"pid": "P3277", "type": "P", "difficulty": 6, "samples": [["5\n1 2 2 10 20\n1 3 2 15 25\n2 2 5 200 170", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "四川", "线段树", "并查集", "各省省选", "连通块"], "title": "[SCOI2011] 飞镖", "background": "", "description": "飞镖是在欧洲颇为流行的一项运动。它的镖盘上分为20个扇形区域，分别标有1到20的分值，每个区域中有单倍、双倍和三倍的区域，打中对应的区域会得到分值乘以倍数所对应的分数。\n\n例如打中18分里面的三倍区域，就会得到54分。\n\n另外，在镖盘的中央，还有”小红心“和”大红心“，分别是25分和50分。\n\n通常的飞镖规则还有一条，那就是在最后一镖的时候，必须以双倍结束战斗，才算获胜。也就是说，当还剩12分的时候，必须打中双倍的6才算赢，而打中单倍的12或者三倍的4则不算。\n\n特别的，”大红心“也算双倍(双倍的25)。在这样的规则下，3镖能解决的最多分数是170分(两个三倍的20，最后用大红心结束)。\n\n现在，lxhgww把原来的1到20分的分值变为了1到K分，同时把小红心的分数变为了M分(大红心是其双倍)，现在lxhgww想知道能否在3镖内（可以不一定用满3镖）解决X分。同样的，最后一镖必须是双倍（包括大红心）。\n", "inputFormat": "输入的第一行是一个整数T，包括了T组数据。\n\n第二行是5个整数，$A_1,B_1,C_1,D_1,K_1$，表示第一组数据的镖盘是从1到$K_1$分的，随后数据的镖盘由公式$K_i=(A_1K^2_{i-1}+B_1K_{i-1}+C_1)mod D_1 + 20$决定，其中第$i(1<i\\le T)$组数据的镖盘是从1到$K_i$分的。\n\n第三行是5个整数，$A_2,B_2,C_2,D_2,M_1$，表示第一组数据的小红心$M_1$分的，随后数据的镖盘由公式$M_i=(A_2M^2_{i-1}+B_2M_{i-1}+C_2)mod D_2 + 20$决定，其中第$i(1<i\\le T)$组数据的小红心是$M_i$分。\n\n\n第四行是5个整数，$A_3,B_3,C_3,D_3,X_1$，表示第一组数据需要解决的分数是$X_1$分的，随后数据的镖盘由公式$X_i=(A_3X^2_{i-1}+B_3X_{i-1}+C_3)mod D_3 + 20$决定，其中第$i(1<i\\le T)$组数据需要解决的分数是$X_i$分。\n", "outputFormat": "一行，包括一个数字，表示这T组数据中，能够被解决的数据数目。\n", "hint": "对于30%的数据，保证$1\\le T\\le 20$,$20\\le K1,M1,X1,D1,D2,D3\\le 1000$\n\n对于100%的数据，保证$1\\le T\\le 10^6$,$20\\le K1,M1,X1,D1,D2,D3\\le 10^9$\n\n对于所有的数据，保证$0\\le A1,B1,A2,B2,C2,A3,B3,C3 \\le 10^9$\n", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2011] Darts", "background": "", "description": "Darts is a popular sport in Europe. The dartboard is divided into 20 sector areas labeled 1 to 20. Each sector has single, double, and triple rings; hitting a ring yields the sector value multiplied by the corresponding multiplier.\n\nFor example, hitting the triple ring of 18 scores 54 points.\n\nIn addition, at the center of the board there are the outer bull and the inner bull, worth 25 and 50 points respectively.\n\nA common darts rule is that you must finish on a double with your last dart to win. That is, if 12 points remain, you must hit double 6 to win; hitting single 12 or triple 4 does not count.\n\nIn particular, the inner bull also counts as a double (double 25). Under these rules, the maximum score that can be finished in 3 darts is 170 (two triple 20s and finishing on the inner bull).\n\nNow, lxhgww changes the sector values from 1–20 to 1–$K$, and changes the outer bull to be worth $M$ points (the inner bull is twice that). lxhgww wants to know whether a total of $X$ points can be finished within 3 darts (you may use fewer than 3 darts). Likewise, the last dart must be a double (including the inner bull).", "inputFormat": "The first line contains an integer $T$, the number of test cases.\n\nThe second line contains 5 integers $A_1,B_1,C_1,D_1,K_1$, indicating that in the first test case the board has sectors from 1 to $K_1$. For subsequent test cases, the board parameter is determined by\n$K_i=(A_1K^2_{i-1}+B_1K_{i-1}+C_1)mod D_1 + 20$, and in the $i$-th test case ($1<i\\le T$) the board has sectors from 1 to $K_i$.\n\nThe third line contains 5 integers $A_2,B_2,C_2,D_2,M_1$, indicating that in the first test case the outer bull is worth $M_1$ points. For subsequent test cases, the value is determined by\n$M_i=(A_2M^2_{i-1}+B_2M_{i-1}+C_2)mod D_2 + 20$, and in the $i$-th test case ($1<i\\le T$) the outer bull is worth $M_i$ points.\n\nThe fourth line contains 5 integers $A_3,B_3,C_3,D_3,X_1$, indicating that in the first test case the required total is $X_1$ points. For subsequent test cases, the target is determined by\n$X_i=(A_3X^2_{i-1}+B_3X_{i-1}+C_3)mod D_3 + 20$, and in the $i$-th test case ($1<i\\le T$) the required total is $X_i$ points.", "outputFormat": "Output one line containing a single integer, the number of test cases among the $T$ that are solvable.", "hint": "For 30% of the testdata, it is guaranteed that $1 \\le T \\le 20$, $20 \\le K_1,M_1,X_1,D_1,D_2,D_3 \\le 1000$.\n\nFor 100% of the testdata, it is guaranteed that $1 \\le T \\le 10^6$, $20 \\le K_1,M_1,X_1,D_1,D_2,D_3 \\le 10^9$.\n\nFor all testdata, it is guaranteed that $0 \\le A_1,B_1,A_2,B_2,C_2,A_3,B_3,C_3 \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2011] 飞镖", "background": "", "description": "飞镖是在欧洲颇为流行的一项运动。它的镖盘上分为20个扇形区域，分别标有1到20的分值，每个区域中有单倍、双倍和三倍的区域，打中对应的区域会得到分值乘以倍数所对应的分数。\n\n例如打中18分里面的三倍区域，就会得到54分。\n\n另外，在镖盘的中央，还有”小红心“和”大红心“，分别是25分和50分。\n\n通常的飞镖规则还有一条，那就是在最后一镖的时候，必须以双倍结束战斗，才算获胜。也就是说，当还剩12分的时候，必须打中双倍的6才算赢，而打中单倍的12或者三倍的4则不算。\n\n特别的，”大红心“也算双倍(双倍的25)。在这样的规则下，3镖能解决的最多分数是170分(两个三倍的20，最后用大红心结束)。\n\n现在，lxhgww把原来的1到20分的分值变为了1到K分，同时把小红心的分数变为了M分(大红心是其双倍)，现在lxhgww想知道能否在3镖内（可以不一定用满3镖）解决X分。同样的，最后一镖必须是双倍（包括大红心）。\n", "inputFormat": "输入的第一行是一个整数T，包括了T组数据。\n\n第二行是5个整数，$A_1,B_1,C_1,D_1,K_1$，表示第一组数据的镖盘是从1到$K_1$分的，随后数据的镖盘由公式$K_i=(A_1K^2_{i-1}+B_1K_{i-1}+C_1)mod D_1 + 20$决定，其中第$i(1<i\\le T)$组数据的镖盘是从1到$K_i$分的。\n\n第三行是5个整数，$A_2,B_2,C_2,D_2,M_1$，表示第一组数据的小红心$M_1$分的，随后数据的镖盘由公式$M_i=(A_2M^2_{i-1}+B_2M_{i-1}+C_2)mod D_2 + 20$决定，其中第$i(1<i\\le T)$组数据的小红心是$M_i$分。\n\n\n第四行是5个整数，$A_3,B_3,C_3,D_3,X_1$，表示第一组数据需要解决的分数是$X_1$分的，随后数据的镖盘由公式$X_i=(A_3X^2_{i-1}+B_3X_{i-1}+C_3)mod D_3 + 20$决定，其中第$i(1<i\\le T)$组数据需要解决的分数是$X_i$分。\n", "outputFormat": "一行，包括一个数字，表示这T组数据中，能够被解决的数据数目。\n", "hint": "对于30%的数据，保证$1\\le T\\le 20$,$20\\le K1,M1,X1,D1,D2,D3\\le 1000$\n\n对于100%的数据，保证$1\\le T\\le 10^6$,$20\\le K1,M1,X1,D1,D2,D3\\le 10^9$\n\n对于所有的数据，保证$0\\le A1,B1,A2,B2,C2,A3,B3,C3 \\le 10^9$\n", "locale": "zh-CN"}}}
{"pid": "P3278", "type": "P", "difficulty": 6, "samples": [["6\nadd 0 1 7\nquery 1\nmul 0 1 7\nquery 2\nmulx 0 1\nquery 3", "14\n147\n588\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2013", "四川", "各省省选", "平衡树"], "title": "[SCOI2013] 多项式的运算", "background": "", "description": "某天，mzry1992 一边思考着一个项目问题一边在高速公路上骑着摩托车。一个光头踢了他一脚，摩托车损坏，而他也被送进校医院打吊针。现在该项目的截止日期将近，他不得不请你来帮助他完成这个项目。\n\n\n该项目的目的是维护一个动态的关于x 的无穷多项式 ，这个多项式初始时对于所有i有$a_i = 0$。\n\n$f(x)=a_0x^0+a_1x^1+a_2x^2...$\n\n操作者可以进行四种操作：\n\n\n将$x^L$ 到$x^R$ 这些项的系数乘上某个定值v\n\n\n将$x^L$ 到$x^R$ 这些项的系数加上某个定值v\n\n\n将$x^L 到x^R $这些项乘上x变量\n\n\n将某个定值v代入多项式F(x)，并输出代入后多项式的值，之后多项式还原为代入前的状况\n\n经过观察，项目组发现使用者的操作集中在前三种，第四种操作不会出现超过10次。mzry1992 负责这个项目的核心代码，你能帮他实现么？\n", "inputFormat": "输入的第一行有一个整数n 代表操作的个数。\n\n\n接下来n 行，每行一个操作，格式如下：\n\n\nmul L R v 代表第一种操作\n\n\nadd L R v 代表第二种操作\n\n\nmulx L R 代表第三种操作\n\n\nquery v 代表第四种操作\n\n", "outputFormat": "对于每个query 操作，输出对应的答案，结果可能较大，需要模上20130426。\n", "hint": "【样例解释】\n\n操作一之后，多项式为F(x) = 7x + 7。\n\n操作三之后，多项式为F(x) = 49x + 49。\n\n操作五之后，多项式为F(x) = 49x^2 + 49x。\n\n【数据范围与约定】\n\n对于30% 的数据：N ≤ 5000，0 ≤ L ≤ R ≤ 5000，0 ≤ v ≤ 10^9\n\n\n另有20% 的数据：N ≤ 10^5，0 ≤ L ≤ R ≤ 10^5，0 ≤ v ≤ 10^9，没有mulx 操作\n\n\n剩下的50% 的数据：N ≤ 10^5，0 ≤ L ≤ R ≤ 10^5，0 ≤v ≤ 10^9\n", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2013] Polynomial Operations", "background": "", "description": "One day, while thinking about a project, mzry1992 was riding a motorcycle on the highway. A bald guy kicked him, his motorcycle broke down, and he was sent to the school hospital for an IV drip. With the deadline approaching, he has to ask you to help finish the project.\n\nThe goal of this project is to maintain a dynamic infinite polynomial in $x$. Initially, for all $i$, we have $a_i = 0$.\n\n$F(x) = a_0 x^0 + a_1 x^1 + a_2 x^2 + \\dots$.\n\nThere are four types of operations:\n\n- Multiply the coefficients of the terms from $x^L$ to $x^R$ by a fixed value $v$.\n- Add a fixed value $v$ to the coefficients of the terms from $x^L$ to $x^R$.\n- Multiply the terms from $x^L$ to $x^R$ by the variable $x$.\n- Substitute a fixed value $v$ into $F(x)$ and output the resulting value. After the query, the polynomial is restored to its previous state.\n\nAfter observation, the team found that users mainly use the first three operations, and the fourth operation appears no more than $10$ times. mzry1992 is responsible for the core code of this project. Can you help him implement it?", "inputFormat": "The first line contains an integer $n$, representing the number of operations.\n\nThen follow $n$ lines, each containing one operation in one of the following formats:\n\n- mul L R v: the first type of operation.\n- add L R v: the second type of operation.\n- mulx L R: the third type of operation.\n- query v: the fourth type of operation.", "outputFormat": "For each query operation, output the corresponding answer. Since the result may be large, print it modulo $20130426$.", "hint": "[Sample Explanation]\n\nAfter operation 1, the polynomial is $F(x) = 7 x + 7$.\n\nAfter operation 3, the polynomial is $F(x) = 49 x + 49$.\n\nAfter operation 5, the polynomial is $F(x) = 49 x^2 + 49 x$.\n\nConstraints\n\n- For $30\\%$ of the testdata: $N \\le 5000$, $0 \\le L \\le R \\le 5000$, $0 \\le v \\le 10^9$.\n- For another $20\\%$ of the testdata: $N \\le 10^5$, $0 \\le L \\le R \\le 10^5$, $0 \\le v \\le 10^9$, and there is no mulx operation.\n- For the remaining $50\\%$ of the testdata: $N \\le 10^5$, $0 \\le L \\le R \\le 10^5$, $0 \\le v \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2013] 多项式的运算", "background": "", "description": "某天，mzry1992 一边思考着一个项目问题一边在高速公路上骑着摩托车。一个光头踢了他一脚，摩托车损坏，而他也被送进校医院打吊针。现在该项目的截止日期将近，他不得不请你来帮助他完成这个项目。\n\n\n该项目的目的是维护一个动态的关于x 的无穷多项式 ，这个多项式初始时对于所有i有$a_i = 0$。\n\n$f(x)=a_0x^0+a_1x^1+a_2x^2...$\n\n操作者可以进行四种操作：\n\n\n将$x^L$ 到$x^R$ 这些项的系数乘上某个定值v\n\n\n将$x^L$ 到$x^R$ 这些项的系数加上某个定值v\n\n\n将$x^L 到x^R $这些项乘上x变量\n\n\n将某个定值v代入多项式F(x)，并输出代入后多项式的值，之后多项式还原为代入前的状况\n\n经过观察，项目组发现使用者的操作集中在前三种，第四种操作不会出现超过10次。mzry1992 负责这个项目的核心代码，你能帮他实现么？\n", "inputFormat": "输入的第一行有一个整数n 代表操作的个数。\n\n\n接下来n 行，每行一个操作，格式如下：\n\n\nmul L R v 代表第一种操作\n\n\nadd L R v 代表第二种操作\n\n\nmulx L R 代表第三种操作\n\n\nquery v 代表第四种操作\n\n", "outputFormat": "对于每个query 操作，输出对应的答案，结果可能较大，需要模上20130426。\n", "hint": "【样例解释】\n\n操作一之后，多项式为F(x) = 7x + 7。\n\n操作三之后，多项式为F(x) = 49x + 49。\n\n操作五之后，多项式为F(x) = 49x^2 + 49x。\n\n【数据范围与约定】\n\n对于30% 的数据：N ≤ 5000，0 ≤ L ≤ R ≤ 5000，0 ≤ v ≤ 10^9\n\n\n另有20% 的数据：N ≤ 10^5，0 ≤ L ≤ R ≤ 10^5，0 ≤ v ≤ 10^9，没有mulx 操作\n\n\n剩下的50% 的数据：N ≤ 10^5，0 ≤ L ≤ R ≤ 10^5，0 ≤v ≤ 10^9\n", "locale": "zh-CN"}}}
{"pid": "P3279", "type": "P", "difficulty": 6, "samples": [["3\n1 1 1\n0 0", "abc\n"], ["3\n1 3 1\n0 0", "aba"], ["3\n1 3 1\n2 2", "aaa"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2013", "四川", "线段树", "并查集", "各省省选", "ST 表", "Manacher 算法"], "title": "[SCOI2013] 密码", "background": "", "description": "Fish是一条生活在海里的鱼。有一天他很无聊，就到处去寻宝。他找到了位于海底深处的宫殿，但是一扇带有密码锁的大门却阻止了他的前进。\n\n通过翻阅古籍，Fish 得知了这个密码的相关信息：\n\n1. 该密码的长度为N。\n\n2. 密码仅含小写字母。\n\n3. 以每一个字符为中心的最长回文串长度。\n\n4. 以每两个相邻字符的间隙为中心的最长回文串长度。\n\n很快Fish 发现可能有无数种满足条件的密码。经过分析，他觉得这些密码中字典序最小的一个最有可能是答案，你能帮他找到这个密码么？\n\n注意：对于两个串A和B，如果它们的前i个字符都相同，而A的第i+1个字符比B的第i+1个字符小，那么认为是则称密码A 的字典序小于密码B 的字典序，例如字符串abc 字典序小于字符串acb。如果密码A的字典序比其他所有满足条件的密码的字典序都小，则密码A是这些密码中字典序最小的一个。\n", "inputFormat": "输入由三行组成。第一行仅含一个整数N，表示密码的长度。第二行包含N 个整数，表示以每个字符为中心的最长回文串长度。第三行包含N - 1 个整数，表示每两个相邻字符的间隙为中心的最长回文串长度。\n", "outputFormat": "输出仅一行。输出满足条件的最小字典序密码。古籍中的信息是一定正确的，故一定存在满足条件的密码。\n", "hint": "对于20% 的数据，1 <= n <= 100。\n\n另有30% 的数据，1 <= n <= 1000。\n\n最后50% 的数据，1 <= n <= 10^5。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2013] Password", "background": "", "description": "Fish is a fish that lives in the sea. One day he got bored and went treasure hunting. He found a palace deep on the seabed, but a gate with a combination lock blocked his way.\n\nBy consulting ancient books, Fish learned the following information about the password:\n\n1. The length of the password is $N$.\n2. The password contains only lowercase letters.\n3. The lengths of the longest palindromic substrings centered at each character.\n4. The lengths of the longest palindromic substrings centered between every pair of adjacent characters.\n\nFish soon realized that there might be infinitely many passwords that satisfy the conditions. After some analysis, he believes the lexicographically smallest one among them is most likely the answer. Can you help him find this password?\n\nNote: For two strings $A$ and $B$, if their first $i$ characters are the same, and the $(i+1)$-th character of $A$ is smaller than that of $B$, then $A$ is said to be lexicographically smaller than $B$. For example, the string abc is lexicographically smaller than acb. If the lexicographic order of $A$ is smaller than that of all other passwords that satisfy the conditions, then $A$ is the lexicographically smallest one among them.", "inputFormat": "The input consists of three lines. The first line contains a single integer $N$, the length of the password. The second line contains $N$ integers, giving the lengths of the longest palindromic substrings centered at each character. The third line contains $N-1$ integers, giving the lengths of the longest palindromic substrings centered between every pair of adjacent characters.", "outputFormat": "Output a single line: the lexicographically smallest password that satisfies the conditions. The information from the ancient book is guaranteed to be correct, so there is always at least one valid password.", "hint": "Constraints:\n- For 20% of the testdata, $1 \\le N \\le 100$.\n- For another 30% of the testdata, $1 \\le N \\le 1000$.\n- For the remaining 50% of the testdata, $1 \\le N \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2013] 密码", "background": "", "description": "Fish是一条生活在海里的鱼。有一天他很无聊，就到处去寻宝。他找到了位于海底深处的宫殿，但是一扇带有密码锁的大门却阻止了他的前进。\n\n通过翻阅古籍，Fish 得知了这个密码的相关信息：\n\n1. 该密码的长度为N。\n\n2. 密码仅含小写字母。\n\n3. 以每一个字符为中心的最长回文串长度。\n\n4. 以每两个相邻字符的间隙为中心的最长回文串长度。\n\n很快Fish 发现可能有无数种满足条件的密码。经过分析，他觉得这些密码中字典序最小的一个最有可能是答案，你能帮他找到这个密码么？\n\n注意：对于两个串A和B，如果它们的前i个字符都相同，而A的第i+1个字符比B的第i+1个字符小，那么认为是则称密码A 的字典序小于密码B 的字典序，例如字符串abc 字典序小于字符串acb。如果密码A的字典序比其他所有满足条件的密码的字典序都小，则密码A是这些密码中字典序最小的一个。\n", "inputFormat": "输入由三行组成。第一行仅含一个整数N，表示密码的长度。第二行包含N 个整数，表示以每个字符为中心的最长回文串长度。第三行包含N - 1 个整数，表示每两个相邻字符的间隙为中心的最长回文串长度。\n", "outputFormat": "输出仅一行。输出满足条件的最小字典序密码。古籍中的信息是一定正确的，故一定存在满足条件的密码。\n", "hint": "对于20% 的数据，1 <= n <= 100。\n\n另有30% 的数据，1 <= n <= 1000。\n\n最后50% 的数据，1 <= n <= 10^5。\n", "locale": "zh-CN"}}}
{"pid": "P3280", "type": "P", "difficulty": 6, "samples": [["3 3 2\n2 3 1\n-6 5 -3\n1 3 5\n2 3 2\n2 1 6\n1 3\n", "3\n2\n\n"], ["4 4 0\n1 2 3 4\n5 4 -6 -1\n1 2 4\n2 3 100\n3 4 1\n4 1 4", "6\n1 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2013", "四川", "倍增", "各省省选", "生成树"], "title": "[SCOI2013] 摩托车交易", "background": "", "description": "mzry1992 在打完吊针出院之后，买了辆新摩托车，开始了在周边城市的黄金运送生意。在 mzry1992 生活的地方，城市之间是用双向高速公路连接的。另外，每条高速公路有一个载重上限，即在不考虑驾驶员和摩托车重量的情况下，如果所载货物的量超过某个值，则不能驶上该条高速公路。\n\n今年，mzry1992 一共收到了来自 $n$ 个不同城市的 $n$ 份定订单，每个订单要求卖出上限为一定量的黄金，或是要求买入上限为一定量的黄金。由于订单并不是同时发来的，为了维护生意上的名声，mzry1992 不得不按照订单发来的顺序与客户进行交易。他与第i 个客户进行交易的具体步骤是：\n\n1. 前往第 $i$ 个客户所在城市。当然，中途是完全允许经过其他城市的。 \n2. 与第 $i$ 个客户进行交易，在此过程中他希望有限制的让交易额尽量大。具体的限制有两个：    \n(a) 他希望与最后一个客户完成交易后，手上没有剩余黄金。  \n(b) 由于黄金是很贵重的物品，不能出现因为买入过多黄金而造成在以后的运送过程中不得不丢弃黄金的情况。\n\n一开始，mzry1992 位于第一个订单客户所在的城市。现在有一个好消息，有人提供了 mzry1992 免费试用周边城市的列车系统的资格。具体来讲，如果mzry1992希望从 $A$ 城市到达 $B$ 城市，且 $A$、$B$ 城市均有列车站的话，他可以携带着黄金与摩托车从 $A$ 城市乘坐列车到 $B$ 城市，这里假定乘坐列车没有载重限制。\n\n现在已知城市间的交通系统情况和订单情况，请帮助 mzry1992 计算每个向 mzry1992 购买黄金的客户的购买量。\n", "inputFormat": "输入的第一行有三个整数 $n,m,q$，分别表示城市数，连通城市的高速公路数和有列车站的城市数。\n\n接下来的一行有 $n$ 个数，每个数均不相同，且值介于 $1$ 到 $n$ 之间，代表订单的顺序。\n\n第三行有 $n$ 个数，第 $i$ 个数表示 $i$ 号城市的订单的上限额 $b_i$，$b_i$ 为正值表示该订单为买入交易（针对mzry1992 而言），上限为 $b_i$，$b_i$ 为负值表示该订单为卖出交易（同样针对mzry1992 而言）上限为 $-b_i$。\n\n接下来的 $m$ 行每行有三个数，$u, v, w$，表示城市 $u$ 和城市 $v$ 之间有一条载重上限为 $w$ 的高速公路，这里假定所有高速公路都是双向的，城市的序号是从 $1$ 到 $n$ 的。\n\n输入的最后一行有 $q$ 个数，代表有列车站城市的序号。\n", "outputFormat": "按照订单顺序对于每个卖出交易，输出一行，该行只有一个整数 $x$，表示卖出黄金的量。\n", "hint": "### 样例解释\n\n第一组样例：其中一种合法的方案是最初从 $2$ 号城市买入 $5$ 单位的黄金，先走第三条高速公路到 $1$ 号城市，然后再坐列车到 $3$ 号城市，在 $3$ 号城市卖出 $3$ 单位的黄金，然后乘坐列车到 $1$ 城市，在 $1$ 号城市卖出 $2$ 单位的黄金。\n\n\n第二组样例：其中一种合法的方案是最初从 $1$ 号城市买入 $4$ 单位的黄金，走第一条高速公路，在 $2$ 号城市买入 $3$ 单位的黄金，走第二条高速公路，在三城市点卖出 $6$ 单位的黄金，走第三条高速公路，在 $4$ 号城市卖出 $1$ 单位的黄金。\n\n### 数据范围与约定\n\n- 对于 $20\\%$ 数据，$n \\le 100$，$m \\le 200$。\n- 对于 $50\\%$ 数据，$n \\le 3000$，$m \\le 6000$。\n- 对于 $100\\%$ 数据，$1 \\le n \\le 10^5$，$n - 1 \\le m \\le 2\\times 10^5$，$0 \\le q \\le n$，$0 < |b_i| < 10^9$，$0 < w < 10^9$，保证任意两个城市之间是通过高速公路连通的。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2013] Motorcycle Trading", "background": "", "description": "After being discharged from the hospital, mzry1992 bought a new motorcycle and started a gold delivery business among nearby cities. In the place where mzry1992 lives, cities are connected by bidirectional highways. In addition, each highway has a load limit: ignoring the weight of the rider and the motorcycle, if the amount of cargo carried exceeds a certain value, that highway cannot be used.\n\nThis year, mzry1992 received $n$ orders from $n$ different cities. Each order either requests to buy up to a certain amount of gold from him, or to sell up to a certain amount of gold to him. Since orders do not arrive simultaneously, to maintain his reputation, mzry1992 must trade with customers in the order the orders arrive. When trading with the $i$-th customer, he performs the following steps:\n\n1. Travel to the city of the $i$-th customer. Passing through other cities en route is fully allowed.\n2. Trade with the $i$-th customer. In this process, he wants to maximize the transaction amount subject to the following two constraints:\n   (a) After finishing the transaction with the last customer, he must hold no gold.\n   (b) Because gold is valuable, he is not allowed to overbuy in a way that would force him to discard gold later during transportation.\n\nInitially, mzry1992 is located in the city of the first order. Here is some good news: someone has given mzry1992 a free trial to use the railway system among nearby cities. Specifically, if he wants to travel from city $A$ to city $B$, and both $A$ and $B$ have railway stations, then he can carry both gold and his motorcycle by train from $A$ to $B$, assuming there is no load limit on the train.\n\nGiven the transportation network and the orders, please help mzry1992 compute, for each customer who buys gold from him (i.e., his sell transactions), the quantity they purchase.", "inputFormat": "The first line contains three integers $n, m, q$, denoting the number of cities, the number of highways, and the number of cities with railway stations, respectively.\n\nThe second line contains $n$ distinct integers, each between $1$ and $n$, representing a permutation of the cities: the order in which the orders arrive.\n\nThe third line contains $n$ integers, where the $i$-th number is the upper limit $b_i$ of the order in city $i$. If $b_i > 0$, then from the perspective of mzry1992 it is a buy order (he buys gold) with upper limit $b_i$. If $b_i < 0$, then it is a sell order (he sells gold) with upper limit $-b_i$.\n\nEach of the next $m$ lines contains three integers $u, v, w$, meaning there is a bidirectional highway between cities $u$ and $v$ with load limit $w$. City indices are from $1$ to $n$.\n\nThe last line contains $q$ integers, which are the indices of the cities that have railway stations.", "outputFormat": "In the order of the orders, for each sell transaction, output one line containing a single integer $x$, the amount of gold sold.", "hint": "Sample explanation:\n\n- First sample: One valid plan is to initially buy $5$ units of gold in city $2$, take the third highway to city $1$, then take the train to city $3$, sell $3$ units of gold in city $3$, take the train back to city $1$, and sell $2$ units of gold in city $1$.\n- Second sample: One valid plan is to initially buy $4$ units of gold in city $1$, take the first highway, buy $3$ units of gold in city $2$, take the second highway, sell $6$ units of gold in city $3$, take the third highway, and sell $1$ unit of gold in city $4$.\n\nConstraints:\n\n- For $20\\%$ of the testdata, $n \\le 100$, $m \\le 200$.\n- For $50\\%$ of the testdata, $n \\le 3000$, $m \\le 6000$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 10^5$, $n - 1 \\le m \\le 2\\times 10^5$, $0 \\le q \\le n$, $0 < |b_i| < 10^9$, $0 < w < 10^9$. It is guaranteed that any two cities are connected via highways.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2013] 摩托车交易", "background": "", "description": "mzry1992 在打完吊针出院之后，买了辆新摩托车，开始了在周边城市的黄金运送生意。在 mzry1992 生活的地方，城市之间是用双向高速公路连接的。另外，每条高速公路有一个载重上限，即在不考虑驾驶员和摩托车重量的情况下，如果所载货物的量超过某个值，则不能驶上该条高速公路。\n\n今年，mzry1992 一共收到了来自 $n$ 个不同城市的 $n$ 份定订单，每个订单要求卖出上限为一定量的黄金，或是要求买入上限为一定量的黄金。由于订单并不是同时发来的，为了维护生意上的名声，mzry1992 不得不按照订单发来的顺序与客户进行交易。他与第i 个客户进行交易的具体步骤是：\n\n1. 前往第 $i$ 个客户所在城市。当然，中途是完全允许经过其他城市的。 \n2. 与第 $i$ 个客户进行交易，在此过程中他希望有限制的让交易额尽量大。具体的限制有两个：    \n(a) 他希望与最后一个客户完成交易后，手上没有剩余黄金。  \n(b) 由于黄金是很贵重的物品，不能出现因为买入过多黄金而造成在以后的运送过程中不得不丢弃黄金的情况。\n\n一开始，mzry1992 位于第一个订单客户所在的城市。现在有一个好消息，有人提供了 mzry1992 免费试用周边城市的列车系统的资格。具体来讲，如果mzry1992希望从 $A$ 城市到达 $B$ 城市，且 $A$、$B$ 城市均有列车站的话，他可以携带着黄金与摩托车从 $A$ 城市乘坐列车到 $B$ 城市，这里假定乘坐列车没有载重限制。\n\n现在已知城市间的交通系统情况和订单情况，请帮助 mzry1992 计算每个向 mzry1992 购买黄金的客户的购买量。\n", "inputFormat": "输入的第一行有三个整数 $n,m,q$，分别表示城市数，连通城市的高速公路数和有列车站的城市数。\n\n接下来的一行有 $n$ 个数，每个数均不相同，且值介于 $1$ 到 $n$ 之间，代表订单的顺序。\n\n第三行有 $n$ 个数，第 $i$ 个数表示 $i$ 号城市的订单的上限额 $b_i$，$b_i$ 为正值表示该订单为买入交易（针对mzry1992 而言），上限为 $b_i$，$b_i$ 为负值表示该订单为卖出交易（同样针对mzry1992 而言）上限为 $-b_i$。\n\n接下来的 $m$ 行每行有三个数，$u, v, w$，表示城市 $u$ 和城市 $v$ 之间有一条载重上限为 $w$ 的高速公路，这里假定所有高速公路都是双向的，城市的序号是从 $1$ 到 $n$ 的。\n\n输入的最后一行有 $q$ 个数，代表有列车站城市的序号。\n", "outputFormat": "按照订单顺序对于每个卖出交易，输出一行，该行只有一个整数 $x$，表示卖出黄金的量。\n", "hint": "### 样例解释\n\n第一组样例：其中一种合法的方案是最初从 $2$ 号城市买入 $5$ 单位的黄金，先走第三条高速公路到 $1$ 号城市，然后再坐列车到 $3$ 号城市，在 $3$ 号城市卖出 $3$ 单位的黄金，然后乘坐列车到 $1$ 城市，在 $1$ 号城市卖出 $2$ 单位的黄金。\n\n\n第二组样例：其中一种合法的方案是最初从 $1$ 号城市买入 $4$ 单位的黄金，走第一条高速公路，在 $2$ 号城市买入 $3$ 单位的黄金，走第二条高速公路，在三城市点卖出 $6$ 单位的黄金，走第三条高速公路，在 $4$ 号城市卖出 $1$ 单位的黄金。\n\n### 数据范围与约定\n\n- 对于 $20\\%$ 数据，$n \\le 100$，$m \\le 200$。\n- 对于 $50\\%$ 数据，$n \\le 3000$，$m \\le 6000$。\n- 对于 $100\\%$ 数据，$1 \\le n \\le 10^5$，$n - 1 \\le m \\le 2\\times 10^5$，$0 \\le q \\le n$，$0 < |b_i| < 10^9$，$0 < w < 10^9$，保证任意两个城市之间是通过高速公路连通的。\n", "locale": "zh-CN"}}}
{"pid": "P3281", "type": "P", "difficulty": 6, "samples": [["10\n3 1 0 3\n3 1 0 3", "120\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串", "2013", "四川", "各省省选", "数位 DP", "进制"], "title": "[SCOI2013] 数数", "background": null, "description": "Fish 是一条生活在海里的鱼，有一天他很无聊，就开始数数玩。他数数玩的具体规则是：\n\n1. 确定数数的进制 $B$。\n\n2. 确定一个数数的区间 $[L, R]$。\n\n3. 对于 $[L, R]$ 间的每一个数，把该数视为一个字符串，列出该字符串的每一个（连续的）子串对应的 $B$ 进制数的值。\n\n4. 对所有列出的数求和。现在 Fish 数了一遍数，但是不确定自己的结果是否正确了。由于 $[L, R]$ 较大，他没有多余精力去验证是否正确，你能写一个程序来帮他验证吗？", "inputFormat": "输入包含三行。\n\n第一行仅有一个数 $B$，表示数数的进制。\n\n第二行有 $N+1$ 个数，第一个数为 $N$，表示数 $L$ 在 $B$ 进制下的长度为 $N$，接下里的 $N$ 个数从高位到低位的表示数 $L$ 的具体每一位。\n\n第三行有 $M+ 1$ 个数，第一个数为 $M$，表示数 $R$ 在 $B$ 进制下的长度为 $M$，接下里的 $M$ 个数从高位到低位的表示数 $R$ 的具体每一位。", "outputFormat": "输出仅一行，即按照 Fish 数数规则的结果，结果用 $10$ 进制表示，由于该数可能很大，输出该数模上 $20130427$ 的模数。\n\n数据中有 $r<l$ 的情况，输出的是 $-ans[r+1,l-1]\\bmod 20130427$。", "hint": "**【样例解释】**\n\n$[103, 103]$ 之间仅有数 $103$，该数的所有子串包括$1, 10, 103, 0, 03, 3$，其和为 $120$。\n\n**【数据范围与约定】**\n\n$20\\%$ 数据，$0 \\le L \\le R \\le 10^5$。\n\n$50\\%$ 数据，$2 \\le B \\le 1000，1 \\le N,M \n\\le 1000$。\n\n$100\\%$ 数据，$2 \\le B \\le 10^5，1 \\le N,M \\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2013] Counting", "background": "", "description": "Fish is a fish living in the sea. One day he felt bored and started a counting game. The detailed rules are:\n\n1. Fix a base $B$ for counting.\n\n2. Fix an interval $[L, R]$.\n\n3. For each number in $[L, R]$, regard the number as a string, and list the value in base $B$ of each (contiguous) substring of that string.\n\n4. Sum all the listed numbers. Now Fish has finished one round of counting, but he is not sure whether his result is correct. Since $[L, R]$ is large, he does not have the extra energy to verify it. Can you write a program to help him verify it?", "inputFormat": "The input contains three lines.\n\nThe first line contains only one number $B$, which is the base for counting.\n\nThe second line contains $N+1$ numbers. The first number is $N$, meaning that the length of $L$ in base $B$ is $N$. The next $N$ numbers, from the most significant digit to the least significant digit, represent each digit of $L$.\n\nThe third line contains $M+ 1$ numbers. The first number is $M$, meaning that the length of $R$ in base $B$ is $M$. The next $M$ numbers, from the most significant digit to the least significant digit, represent each digit of $R$.", "outputFormat": "Output exactly one line: the result according to Fish’s counting rules, expressed in base $10$. Since the number can be large, output the result modulo $20130427$.\n\nIn the testdata, there may be cases where $r<l$. In such cases, the output is $-ans[r+1,l-1]\\bmod 20130427$.", "hint": "Sample Explanation:\n\n$[103, 103]$ contains only the number 103. All its substrings include 1, 10, 103, 0, 03, 3, and their sum is 120.\n\nConstraints:\n\n$20\\%$ of the testdata: $0 \\le L \\le R \\le 10^5$.\n\n$50\\%$ of the testdata: $2 \\le B \\le 1000, 1 \\le N, M \\le 1000$.\n\n$100\\%$ of the testdata: $2 \\le B \\le 10^5, 1 \\le N, M \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2013] 数数", "background": null, "description": "Fish 是一条生活在海里的鱼，有一天他很无聊，就开始数数玩。他数数玩的具体规则是：\n\n1. 确定数数的进制 $B$。\n\n2. 确定一个数数的区间 $[L, R]$。\n\n3. 对于 $[L, R]$ 间的每一个数，把该数视为一个字符串，列出该字符串的每一个（连续的）子串对应的 $B$ 进制数的值。\n\n4. 对所有列出的数求和。现在 Fish 数了一遍数，但是不确定自己的结果是否正确了。由于 $[L, R]$ 较大，他没有多余精力去验证是否正确，你能写一个程序来帮他验证吗？", "inputFormat": "输入包含三行。\n\n第一行仅有一个数 $B$，表示数数的进制。\n\n第二行有 $N+1$ 个数，第一个数为 $N$，表示数 $L$ 在 $B$ 进制下的长度为 $N$，接下里的 $N$ 个数从高位到低位的表示数 $L$ 的具体每一位。\n\n第三行有 $M+ 1$ 个数，第一个数为 $M$，表示数 $R$ 在 $B$ 进制下的长度为 $M$，接下里的 $M$ 个数从高位到低位的表示数 $R$ 的具体每一位。", "outputFormat": "输出仅一行，即按照 Fish 数数规则的结果，结果用 $10$ 进制表示，由于该数可能很大，输出该数模上 $20130427$ 的模数。\n\n数据中有 $r<l$ 的情况，输出的是 $-ans[r+1,l-1]\\bmod 20130427$。", "hint": "**【样例解释】**\n\n$[103, 103]$ 之间仅有数 $103$，该数的所有子串包括$1, 10, 103, 0, 03, 3$，其和为 $120$。\n\n**【数据范围与约定】**\n\n$20\\%$ 数据，$0 \\le L \\le R \\le 10^5$。\n\n$50\\%$ 数据，$2 \\le B \\le 1000，1 \\le N,M \n\\le 1000$。\n\n$100\\%$ 数据，$2 \\le B \\le 10^5，1 \\le N,M \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P3282", "type": "P", "difficulty": 5, "samples": [["4.000000 10.000000\n5\n-2.00000000 9.00000000 3\n1.00000000 7.26794919 10\n-3.00000000 7.26794919 3\n2.00000000 9.00000000 10\n0.00000000 9.00000000 10\n5\n66.60 10\n106.20 3\n88.20 5\n91.80 5\n84.60 5", "34"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "四川", "各省省选"], "title": "[SCOI2013] 泡泡鱼", "background": "", "description": "Fish 是一条生活在海里的鱼，有一天他很无聊，想起了一个人类玩的游戏泡泡龙，于是他打算玩一把泡泡鱼。Fish 并不是特别清楚泡泡龙的规则（我们也是），于是他采用自己定的近似规则。\n\n这里我们把海底想象成一个平面区域，它的上边界离发射点距离为H，左右边界离发射点的距离均为W。\n\n起初时在这个区域的某些位置上有一些各种颜色的泡泡，且每个泡泡的直径为2（这里视泡泡为圆形）。\n\n如果两个相同颜色的泡泡相切，我们就说这两个泡泡相邻。\n\n如果两个相同颜色的泡泡相邻或者可以通过第三个相同颜色的泡泡相连，我们就说这两个泡泡相连。\n\n为了方便描述，我们定义发射点的坐标为(0, 0)，每次Fish 会在发射点以某个给定角度发射某种颜色的泡泡。\n\n如果泡泡撞到墙壁或者其他泡泡（即在某个时间第一次与墙壁或者其他泡泡相切），这个泡泡就会停住。如果这个泡泡与超过一个泡泡相连，那么这些泡泡就会消失，而Fish 就会得到消失泡泡数量的平方的分数值。\n\n请注意，初始时如果有超过两个泡泡相连，这些泡泡并不会消失。现在已知初始泡泡的情况和每次发射泡泡的颜色和角度（相对于+x 轴逆时针方向），请你给出最终的总得分。注意，在上一次发射出去的泡泡停止之前，Fish 不能够继续发射泡泡。\n", "inputFormat": "输入的第一行有两个实数W，H，表示游戏区域的边界坐标，精确到小数点后六位。\n\n接下来一行有一个整数n，表示初始泡泡的个数。\n\n接下来n 行，第i 行首先是两个浮点数xi 和yi，表示第i 个泡泡的圆心坐标，精确到小数点后八位，然后是一个整数ci，表示第i 个泡泡的颜色。\n\n接下来一行有一个整数q，表示发射的泡泡的个数。最后q 行，第i 行首先是一个浮点数ai，精确到小数点后两位，表示第i 次发射的泡泡的角度，然后是一个整数ci，表示第i 次发射的泡泡的颜色。\n\n数据保证刚开始所有的泡泡均在区域内！数据保证泡泡刚发射的位置永远不会停放有泡泡！\n\n由于泡泡会在海水中浮动（以及计算机浮点的精度误差），我们认为当(xa-xb)^2 + (ya-yb)^2  <= (2 [1]\\* 1)^2 + 10^-6成立时，泡泡a 和泡泡b 相切！数据保证初始时不存在相交的泡泡\n", "outputFormat": "输出只有一行，这一行只有一个整数，代表Fish 最后的总得分。\n", "hint": "对于30% 的数据，1 <= n <= 10，1 <= q <= 10。\n\n另有50% 的数据，1 <= n <= 1000，1 <= q <= 1000。\n\n剩下20% 的数据，1 <= n <= 10^5，1 <= q <= 10。\n\n对于所有的数据，有0 < a < 180，0 < W, H <= 1000，1 <= ci <= 100。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2013] Bubble Fish", "background": "", "description": "Fish is a fish living in the sea. One day he felt bored and remembered a human game called Puzzle Bobble, so he decided to play a variant named Bubble Fish. Fish is not very clear about the rules of Puzzle Bobble (neither are we), so he adopts his own approximate rules.\n\nImagine the seabed as a planar region. Its top boundary is at distance $H$ from the launch point, and both the left and right boundaries are at distance $W$ from the launch point.\n\nInitially, there are some bubbles of various colors placed at certain positions within this region, and each bubble has diameter $2$ (bubbles are treated as circles).\n\nIf two bubbles of the same color are tangent, we say these two bubbles are adjacent.\n\nIf two bubbles of the same color are adjacent, or can be connected through a chain of bubbles of the same color, we say these two bubbles are connected.\n\nFor convenience, we define the coordinates of the launch point to be $(0, 0)$. Each time, Fish fires a bubble of a given color from the launch point at a given angle.\n\nIf the bubble hits a wall or another bubble (that is, at the first moment it becomes tangent to the wall or another bubble), it stops. If this bubble becomes connected to more than one bubble of the same color (i.e., the connected component of that color including the new bubble has size at least $3$), then all bubbles in that component disappear, and Fish earns a score equal to the square of the number of disappeared bubbles.\n\nNote that initially, even if there is a connected component of size greater than $2$, those bubbles do not disappear. Given the initial configuration of bubbles and, for each shot, the color and the angle (measured counterclockwise from the $+x$-axis), output the final total score. Note that Fish cannot fire the next bubble until the previously fired bubble has stopped.", "inputFormat": "The first line contains two real numbers $W, H$, the boundary distances of the game region, accurate to six decimal places.\n\nThe next line contains an integer $n$, the number of initial bubbles.\n\nThe following $n$ lines: line $i$ contains two floating-point numbers $x_i$ and $y_i$, the center coordinates of the $i$-th bubble, accurate to eight decimal places, followed by an integer $c_i$, the color of the $i$-th bubble.\n\nThe next line contains an integer $q$, the number of fired bubbles. The last $q$ lines: line $i$ contains a floating-point number $a_i$, accurate to two decimal places, the firing angle of the $i$-th bubble, followed by an integer $c_i$, the color of the $i$-th bubble.\n\nThe testdata guarantees that all initial bubbles lie within the region. It is guaranteed that at the moment of firing, there is never a bubble parked at the launch position.\n\nBecause bubbles float in seawater (and due to floating-point precision), we consider bubbles $a$ and $b$ tangent when\n$(x_a - x_b)^2 + (y_a - y_b)^2 \\le (2 \\cdot 1)^2 + 10^{-6}$.\nThe testdata guarantees that initially there are no intersecting bubbles.", "outputFormat": "Output a single line containing one integer, the final total score of Fish.", "hint": "For 30% of the testdata, $1 \\le n \\le 10$, $1 \\le q \\le 10$.\n\nFor another 50% of the testdata, $1 \\le n \\le 1000$, $1 \\le q \\le 1000$.\n\nFor the remaining 20% of the testdata, $1 \\le n \\le 10^5$, $1 \\le q \\le 10$.\n\nFor all testdata, $0 < a_i < 180$, $0 < W, H \\le 1000$, $1 \\le c_i \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2013] 泡泡鱼", "background": "", "description": "Fish 是一条生活在海里的鱼，有一天他很无聊，想起了一个人类玩的游戏泡泡龙，于是他打算玩一把泡泡鱼。Fish 并不是特别清楚泡泡龙的规则（我们也是），于是他采用自己定的近似规则。\n\n这里我们把海底想象成一个平面区域，它的上边界离发射点距离为H，左右边界离发射点的距离均为W。\n\n起初时在这个区域的某些位置上有一些各种颜色的泡泡，且每个泡泡的直径为2（这里视泡泡为圆形）。\n\n如果两个相同颜色的泡泡相切，我们就说这两个泡泡相邻。\n\n如果两个相同颜色的泡泡相邻或者可以通过第三个相同颜色的泡泡相连，我们就说这两个泡泡相连。\n\n为了方便描述，我们定义发射点的坐标为(0, 0)，每次Fish 会在发射点以某个给定角度发射某种颜色的泡泡。\n\n如果泡泡撞到墙壁或者其他泡泡（即在某个时间第一次与墙壁或者其他泡泡相切），这个泡泡就会停住。如果这个泡泡与超过一个泡泡相连，那么这些泡泡就会消失，而Fish 就会得到消失泡泡数量的平方的分数值。\n\n请注意，初始时如果有超过两个泡泡相连，这些泡泡并不会消失。现在已知初始泡泡的情况和每次发射泡泡的颜色和角度（相对于+x 轴逆时针方向），请你给出最终的总得分。注意，在上一次发射出去的泡泡停止之前，Fish 不能够继续发射泡泡。\n", "inputFormat": "输入的第一行有两个实数W，H，表示游戏区域的边界坐标，精确到小数点后六位。\n\n接下来一行有一个整数n，表示初始泡泡的个数。\n\n接下来n 行，第i 行首先是两个浮点数xi 和yi，表示第i 个泡泡的圆心坐标，精确到小数点后八位，然后是一个整数ci，表示第i 个泡泡的颜色。\n\n接下来一行有一个整数q，表示发射的泡泡的个数。最后q 行，第i 行首先是一个浮点数ai，精确到小数点后两位，表示第i 次发射的泡泡的角度，然后是一个整数ci，表示第i 次发射的泡泡的颜色。\n\n数据保证刚开始所有的泡泡均在区域内！数据保证泡泡刚发射的位置永远不会停放有泡泡！\n\n由于泡泡会在海水中浮动（以及计算机浮点的精度误差），我们认为当(xa-xb)^2 + (ya-yb)^2  <= (2 [1]\\* 1)^2 + 10^-6成立时，泡泡a 和泡泡b 相切！数据保证初始时不存在相交的泡泡\n", "outputFormat": "输出只有一行，这一行只有一个整数，代表Fish 最后的总得分。\n", "hint": "对于30% 的数据，1 <= n <= 10，1 <= q <= 10。\n\n另有50% 的数据，1 <= n <= 1000，1 <= q <= 1000。\n\n剩下20% 的数据，1 <= n <= 10^5，1 <= q <= 10。\n\n对于所有的数据，有0 < a < 180，0 < W, H <= 1000，1 <= ci <= 100。\n", "locale": "zh-CN"}}}
{"pid": "P3283", "type": "P", "difficulty": 6, "samples": [["3 2\n", "17"], ["3 3", "71"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "四川", "各省省选", "深度优先搜索 DFS", "容斥原理"], "title": "[SCOI2013] 火柴棍数字", "background": "", "description": "Fish是一条生活在海里的鱼，有一天他很无聊，于是他去捡了人类扔进海里的垃圾，打算用这些来玩些什么。\n\n他从捡回来的垃圾堆里找到了不少火柴棍，便把这些火柴棍拼成了一个长度为n 的十进制数，每个数字的拼法如下图所示\n\n注意：每个数字占据的宽度和摆放方式是固定的，故以下情况均不合法。 ![](https://cdn.luogu.com.cn/upload/pic/4633.png)\n\n ![](https://cdn.luogu.com.cn/upload/pic/4634.png) \n\n拼完之后他好累，感觉再也不会拼了。他对拼出来的数大小不满意，希望通过移动一些火柴棍的位置来把这个数变得尽量大。\n\n由于太累，他只能最多移动k 根火柴棍。而且由于数字的最低位放在墙边，他不能在该数的低位后面添加数字，但他可以在该数的前面添加数字。\n\n你能帮他算出他移动火柴棍之后的数最大能是多大吗？\n\n注意：火柴棍对于Fish 来说是很贵重的物品，所以不允许折断或丢弃火柴棍。\n\n注意：火柴头的方向不影响数字的辨识，例如下面几种情况都是数字1\n\n![](https://cdn.luogu.com.cn/upload/pic/4635.png)\n", "inputFormat": "输入仅含一行，分别是长度为n 的十进制数x 和最多移动火柴棍的数量k。x 没有前导零。\n", "outputFormat": "输出仅一行，表示移动火柴棍之后的最大数。\n", "hint": "对于30% 的数据，1 <= n <= 10，0 <= k <= 10。\n\n对于100% 的数据，1 <= n <= 500，0 <=k <=3500。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2013] Matchstick Number", "background": "", "description": "Fish is a fish that lives in the sea. One day he was bored, so he picked up trash that humans had thrown into the sea, planning to play with it.\n\nFrom the pile of trash he found many matchsticks, and he used them to form a base-10 number of length $n$. Each digit is assembled as shown in the figures below.\n\nNote: The width and placement of each digit are fixed, so the following cases are all invalid.\n![](https://cdn.luogu.com.cn/upload/pic/4633.png)\n\n![](https://cdn.luogu.com.cn/upload/pic/4634.png)\n\nAfter finishing, he was exhausted and felt he could not build anymore. He was not satisfied with the number he formed and wanted to make it as large as possible by moving some matchsticks.\n\nBecause he is too tired, he can move at most $k$ matchsticks. Also, since the least significant digit is against a wall, he cannot append digits to the low end of the number; however, he may prepend digits to the front of the number.\n\nCan you help him compute the maximum possible number after he moves the matchsticks?\n\nNote: Matchsticks are precious to Fish, so breaking or discarding matchsticks is not allowed.\n\nNote: The orientation of a match head does not affect digit recognition. For example, the following are all the digit 1.\n![](https://cdn.luogu.com.cn/upload/pic/4635.png)", "inputFormat": "The input contains a single line with a base-10 number $x$ of length $n$ and an integer $k$, the maximum number of matchsticks that may be moved. The number $x$ has no leading zero.", "outputFormat": "Output a single line containing the maximum possible number after moving the matchsticks.", "hint": "For 30% of the testdata, $1 \\le n \\le 10$, $0 \\le k \\le 10$.\n\nFor 100% of the testdata, $1 \\le n \\le 500$, $0 \\le k \\le 3500$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2013] 火柴棍数字", "background": "", "description": "Fish是一条生活在海里的鱼，有一天他很无聊，于是他去捡了人类扔进海里的垃圾，打算用这些来玩些什么。\n\n他从捡回来的垃圾堆里找到了不少火柴棍，便把这些火柴棍拼成了一个长度为n 的十进制数，每个数字的拼法如下图所示\n\n注意：每个数字占据的宽度和摆放方式是固定的，故以下情况均不合法。 ![](https://cdn.luogu.com.cn/upload/pic/4633.png)\n\n ![](https://cdn.luogu.com.cn/upload/pic/4634.png) \n\n拼完之后他好累，感觉再也不会拼了。他对拼出来的数大小不满意，希望通过移动一些火柴棍的位置来把这个数变得尽量大。\n\n由于太累，他只能最多移动k 根火柴棍。而且由于数字的最低位放在墙边，他不能在该数的低位后面添加数字，但他可以在该数的前面添加数字。\n\n你能帮他算出他移动火柴棍之后的数最大能是多大吗？\n\n注意：火柴棍对于Fish 来说是很贵重的物品，所以不允许折断或丢弃火柴棍。\n\n注意：火柴头的方向不影响数字的辨识，例如下面几种情况都是数字1\n\n![](https://cdn.luogu.com.cn/upload/pic/4635.png)\n", "inputFormat": "输入仅含一行，分别是长度为n 的十进制数x 和最多移动火柴棍的数量k。x 没有前导零。\n", "outputFormat": "输出仅一行，表示移动火柴棍之后的最大数。\n", "hint": "对于30% 的数据，1 <= n <= 10，0 <= k <= 10。\n\n对于100% 的数据，1 <= n <= 500，0 <=k <=3500。\n", "locale": "zh-CN"}}}
{"pid": "P3284", "type": "P", "difficulty": 7, "samples": [["2\n5 1 4 27 3 15", "2700"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2014", "四川", "各省省选"], "title": "[SCOI2014] 方伯伯打扑克", "background": null, "description": "方伯伯有一些空白的扑克牌。方伯伯想要用这些牌来玩一个数学游戏。\n\n方伯伯首先决定好他要用这些空白的扑克牌组成 $m$ 个牌堆，每一堆牌的张数都是 $2$ 的整数次幂。确切地说，第 $i$ 堆（**注意**：从 $0$ 开始计数）牌将会有 $2^{n_i}$ 张牌。方伯伯首先决定好第 $0$ 堆牌要有 $2^{n_0}$ 张牌，然后将这堆牌从上到下按次序标记 $1 \\sim 2^{n_0}$ 的十进制数字。\n\n方伯伯开始游戏前决定要先洗牌，他决定好要洗 $x_0$ 次牌。他洗牌有一个固定的模式，每次洗牌操作等同于以下两个步骤的操作：\n\n1. 将所有奇数位上的牌依次取出组成新的一堆牌。\n2. 将新的一堆牌放在旧有的牌前面。\n\n如当 $n_0=3$ 时，第 $0$ 堆牌从上到下一开始为 ``12345678``，洗一次牌得到 ``13572468``，洗两次牌得到 ``15263748``。\n\n洗完牌后，方伯伯在心中决定好把其中从上往下数第 $l_0$ 到第 $r_0$ 张牌上的数字均加上一个数字 $t_0$，并依次（转换成二进制）异或之后得到一个异或值；方伯伯把第 $0$ 堆牌的这个异或值取模 $\\bmod  \\ 2^{n_0-1}$ 的值记作 $\\mathrm{ans}_0$。\n\n类似地，方伯伯将按同样的方式用剩下的 $m-1$ 个牌堆。具体地说，他决定按照如下几个公式来对每一堆牌组进行游戏：\n1. 对于第 $i$ 堆牌，牌堆中将会有 $2^{n_i}$ 张牌，并从上到下标有 $1\\sim 2^{n_i}$ 的十进制整数。其中，$n_i=(\\mathrm{ans}_{i-1}+i-1) \\bmod 5 \\mathrel{+} \\mathrm{base}$， $\\mathrm{base}$ 是一个方伯伯事先决定好的正整数。\n2. 方伯伯将会先决定好自己用来游戏的牌处于牌堆中的什么位置。方伯伯首先决定好他要看的第一张牌应该是第 $l_i$ 张，其中 $l_i=(2\\mathrm{ans}_{i-1}+l_{i-1}+i-1)\\bmod 2^{n_i} \\mathrel{+} 1$。\n3. 方伯伯接着决定他要看的最后一张牌应该是第 $r_i$ 张，其中 $r_i=\\bigl(\\mathrm{ans}_{i-1}+1+2^{\\lfloor n_i/2 \\rfloor}(l_i\\bmod 2^{\\lfloor n_i/2 \\rfloor})\\bigr)\\bmod 2^{n_i} \\mathrel{+}1$。\n4. 因为上面两个式子并不简单，有可能会产生 $l_i>r_i$ 的结果，此时将它们的值互换。\n5. 想好自己要看什么牌后，方伯伯就会以此决定自己要洗 $x_i$ 次牌，其中 $x_i=(r_i-l_i+t_{i-1}+i-1)\\bmod 2^{n_i}$。\n6. 方伯伯同时还会想好他要给每张牌要加上数字的是 $t_i$，其中 $t_i=(l_i+r_i)\\bmod 2^{n_i}$。\n7. 方伯伯洗完牌后，把其中从上往下数第 $l_i$ 到第 $r_i$ 张牌上的数字均加上数字 $t_i$，并依次（转换成二进制）异或之后得到一个异或值；方伯伯把第 $i$ 堆牌的这个异或值取模 $\\bmod 2^{n_i-1}$ 的值记作 $\\mathrm{ans}_i$，接着回到第一步玩下一个牌堆。\n\n方伯伯听说你有高超的信息学能力，他想知道你能否在他完成游戏前就算出最后一个牌堆，即第 $m-1$ 个牌堆，得到的游戏结果 $\\mathrm{ans}_{m-1}$。你能做到吗？", "inputFormat": "第一行包含一个整数 $m$，表示牌组的个数。\n\n\n接下来一行包含六个整数，分别为 $n_0, x_0 ,l_0 ,r_0, t_0 , \\mathrm{Base}$。", "outputFormat": "输出为一个数，表示最后的答案。", "hint": "## 数据范围\n\n对于 $10\\%$ 的数据，$m\\le 100$。           \n对于 $20\\%$ 的数据，$m\\le 5\\times 10^5$，$n_i\\le 20$，$ \\mathrm{Base}\\le 16$。  \n对于 $60\\%$ 的数据，$m\\le 5\\times 10^5$，$n_i\\le 60$，$\\mathrm{Base}\\le 55$。           \n对于所有数据，$m \\leq 5\\times 10^6,\\ n_i \\leq 60,\\ 0<l_i \\leq r_i \\leq 2^{n_i},\\ 0<x_i,t_i<10^9,\\ \\mathrm{Base} \\leq 55$。\n\n## 样例解释\n\n$ans_0=1$，$n_1=16$，$l_1=7$，$r_1=1795$，$x_1=1791$，$t_1=1802$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2014] Uncle Fang Plays Poker", "background": "", "description": "Uncle Fang has some blank playing cards. He wants to use them to play a math game.\n\nHe first decides to form $m$ piles from these blank cards, with the size of each pile being an integer power of $2$. Specifically, the $i$-th pile (note: indexed from $0$) will have $2^{n_i}$ cards. He first decides that pile $0$ has $2^{n_0}$ cards, and then labels the cards in this pile from top to bottom with the decimal numbers $1 \\sim 2^{n_0}$ in order.\n\nBefore starting the game, Uncle Fang decides to shuffle, and he decides to shuffle $x_0$ times. He has a fixed shuffling pattern: each shuffle is equivalent to the following two steps:\n1. Take out all cards in odd positions (counted from the top) in order to form a new pile.\n2. Place this new pile on top of the remaining old pile.\n\nFor example, when $n_0 = 3$, pile $0$ starts from top to bottom as ``12345678'', after one shuffle it becomes ``13572468'', and after two shuffles it becomes ``15263748''.\n\nAfter shuffling, Uncle Fang decides to add a number $t_0$ to the labels of the cards from the $l_0$-th to the $r_0$-th from top to bottom. He then converts these labels to binary and XORs them in order to obtain a value; he records the value modulo $2^{n_0-1}$ as $\\mathrm{ans}_0$.\n\nSimilarly, Uncle Fang will play with the remaining $m-1$ piles in the same way. Specifically, he decides to operate on each pile according to the following formulas:\n1. For the $i$-th pile, the pile will have $2^{n_i}$ cards, labeled from top to bottom with the decimal integers $1 \\sim 2^{n_i}$. Here,\n   $n_i = (\\mathrm{ans}_{i-1} + i - 1) \\bmod 5 \\mathrel{+} \\mathrm{Base}$, where $\\mathrm{Base}$ is a positive integer decided in advance.\n2. He first decides the position of the first card he will look at, denoted by $l_i$, where\n   $l_i = (2\\mathrm{ans}_{i-1} + l_{i-1} + i - 1) \\bmod 2^{n_i} \\mathrel{+} 1$.\n3. He then decides the position of the last card he will look at, denoted by $r_i$, where\n   $r_i = \\bigl(\\mathrm{ans}_{i-1} + 1 + 2^{\\lfloor n_i/2 \\rfloor}(l_i \\bmod 2^{\\lfloor n_i/2 \\rfloor})\\bigr) \\bmod 2^{n_i} \\mathrel{+} 1$.\n4. Since the above two formulas are not simple, it is possible that $l_i > r_i$. In that case, swap their values.\n5. After deciding which cards to look at, he decides to shuffle $x_i$ times, where\n   $x_i = (r_i - l_i + t_{i-1} + i - 1) \\bmod 2^{n_i}$.\n6. He also decides the number $t_i$ to add to each selected card, where\n   $t_i = (l_i + r_i) \\bmod 2^{n_i}$.\n7. After shuffling, he adds $t_i$ to each card from the $l_i$-th to the $r_i$-th from top to bottom, converts them to binary and XORs them in order to obtain a value; he records the value modulo $2^{n_i-1}$ as $\\mathrm{ans}_i$, and then returns to Step 1 to play with the next pile.\n\nUncle Fang has heard about your outstanding informatics skills. He wants to know whether you can compute in advance the game result $\\mathrm{ans}_{m-1}$ for the last pile, i.e., pile $m-1$. Can you do it?", "inputFormat": "The first line contains an integer $m$, the number of piles.\n\nThe next line contains six integers: $n_0, x_0, l_0, r_0, t_0, \\mathrm{Base}$.", "outputFormat": "Output a single integer, the final answer.", "hint": "Constraints\n- For $10\\%$ of the testdata, $m \\le 100$.\n- For $20\\%$ of the testdata, $m \\le 5\\times 10^5$, $n_i \\le 20$, $\\mathrm{Base} \\le 16$.\n- For $60\\%$ of the testdata, $m \\le 5\\times 10^5$, $n_i \\le 60$, $\\mathrm{Base} \\le 55$.\n- For all testdata, $m \\le 5\\times 10^6,\\ n_i \\le 60,\\ 0 < l_i \\le r_i \\le 2^{n_i},\\ 0 < x_i, t_i < 10^9,\\ \\mathrm{Base} \\le 55$.\n\nSample Explanation\n$\\mathrm{ans}_0 = 1$, $n_1 = 16$, $l_1 = 7$, $r_1 = 1795$, $x_1 = 1791$, $t_1 = 1802$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2014] 方伯伯打扑克", "background": null, "description": "方伯伯有一些空白的扑克牌。方伯伯想要用这些牌来玩一个数学游戏。\n\n方伯伯首先决定好他要用这些空白的扑克牌组成 $m$ 个牌堆，每一堆牌的张数都是 $2$ 的整数次幂。确切地说，第 $i$ 堆（**注意**：从 $0$ 开始计数）牌将会有 $2^{n_i}$ 张牌。方伯伯首先决定好第 $0$ 堆牌要有 $2^{n_0}$ 张牌，然后将这堆牌从上到下按次序标记 $1 \\sim 2^{n_0}$ 的十进制数字。\n\n方伯伯开始游戏前决定要先洗牌，他决定好要洗 $x_0$ 次牌。他洗牌有一个固定的模式，每次洗牌操作等同于以下两个步骤的操作：\n\n1. 将所有奇数位上的牌依次取出组成新的一堆牌。\n2. 将新的一堆牌放在旧有的牌前面。\n\n如当 $n_0=3$ 时，第 $0$ 堆牌从上到下一开始为 ``12345678``，洗一次牌得到 ``13572468``，洗两次牌得到 ``15263748``。\n\n洗完牌后，方伯伯在心中决定好把其中从上往下数第 $l_0$ 到第 $r_0$ 张牌上的数字均加上一个数字 $t_0$，并依次（转换成二进制）异或之后得到一个异或值；方伯伯把第 $0$ 堆牌的这个异或值取模 $\\bmod  \\ 2^{n_0-1}$ 的值记作 $\\mathrm{ans}_0$。\n\n类似地，方伯伯将按同样的方式用剩下的 $m-1$ 个牌堆。具体地说，他决定按照如下几个公式来对每一堆牌组进行游戏：\n1. 对于第 $i$ 堆牌，牌堆中将会有 $2^{n_i}$ 张牌，并从上到下标有 $1\\sim 2^{n_i}$ 的十进制整数。其中，$n_i=(\\mathrm{ans}_{i-1}+i-1) \\bmod 5 \\mathrel{+} \\mathrm{base}$， $\\mathrm{base}$ 是一个方伯伯事先决定好的正整数。\n2. 方伯伯将会先决定好自己用来游戏的牌处于牌堆中的什么位置。方伯伯首先决定好他要看的第一张牌应该是第 $l_i$ 张，其中 $l_i=(2\\mathrm{ans}_{i-1}+l_{i-1}+i-1)\\bmod 2^{n_i} \\mathrel{+} 1$。\n3. 方伯伯接着决定他要看的最后一张牌应该是第 $r_i$ 张，其中 $r_i=\\bigl(\\mathrm{ans}_{i-1}+1+2^{\\lfloor n_i/2 \\rfloor}(l_i\\bmod 2^{\\lfloor n_i/2 \\rfloor})\\bigr)\\bmod 2^{n_i} \\mathrel{+}1$。\n4. 因为上面两个式子并不简单，有可能会产生 $l_i>r_i$ 的结果，此时将它们的值互换。\n5. 想好自己要看什么牌后，方伯伯就会以此决定自己要洗 $x_i$ 次牌，其中 $x_i=(r_i-l_i+t_{i-1}+i-1)\\bmod 2^{n_i}$。\n6. 方伯伯同时还会想好他要给每张牌要加上数字的是 $t_i$，其中 $t_i=(l_i+r_i)\\bmod 2^{n_i}$。\n7. 方伯伯洗完牌后，把其中从上往下数第 $l_i$ 到第 $r_i$ 张牌上的数字均加上数字 $t_i$，并依次（转换成二进制）异或之后得到一个异或值；方伯伯把第 $i$ 堆牌的这个异或值取模 $\\bmod 2^{n_i-1}$ 的值记作 $\\mathrm{ans}_i$，接着回到第一步玩下一个牌堆。\n\n方伯伯听说你有高超的信息学能力，他想知道你能否在他完成游戏前就算出最后一个牌堆，即第 $m-1$ 个牌堆，得到的游戏结果 $\\mathrm{ans}_{m-1}$。你能做到吗？", "inputFormat": "第一行包含一个整数 $m$，表示牌组的个数。\n\n\n接下来一行包含六个整数，分别为 $n_0, x_0 ,l_0 ,r_0, t_0 , \\mathrm{Base}$。", "outputFormat": "输出为一个数，表示最后的答案。", "hint": "## 数据范围\n\n对于 $10\\%$ 的数据，$m\\le 100$。           \n对于 $20\\%$ 的数据，$m\\le 5\\times 10^5$，$n_i\\le 20$，$ \\mathrm{Base}\\le 16$。  \n对于 $60\\%$ 的数据，$m\\le 5\\times 10^5$，$n_i\\le 60$，$\\mathrm{Base}\\le 55$。           \n对于所有数据，$m \\leq 5\\times 10^6,\\ n_i \\leq 60,\\ 0<l_i \\leq r_i \\leq 2^{n_i},\\ 0<x_i,t_i<10^9,\\ \\mathrm{Base} \\leq 55$。\n\n## 样例解释\n\n$ans_0=1$，$n_1=16$，$l_1=7$，$r_1=1795$，$x_1=1791$，$t_1=1802$。", "locale": "zh-CN"}}}
{"pid": "P3285", "type": "P", "difficulty": 6, "samples": [["10 10\n1 2 11\n3 13\n2 5\n3 7\n2 8\n2 10\n2 11\n3 14\n2 18\n4 9", "2\n2\n2\n4\n3\n5\n5\n7\n8\n11"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2014", "四川", "线段树", "各省省选", "平衡树"], "title": "[SCOI2014] 方伯伯的OJ", "background": "", "description": "方伯伯正在做他的 OJ。现在他在处理 OJ 上的用户排名问题。OJ 上注册了 $n$ 个用户，编号为 $1\\sim n$，一开始他们按照编号排名。\n\n方伯伯会按照心情对这些用户做以下四种操作，修改用户的排名和编号：\n\n1. 操作格式为 $1\\ \\ x\\ \\ y$，意味着将编号为 $x$ 的用户编号改为 $y$，而排名不变，执行完该操作后需要输出该用户在队列中的位置，数据保证 $x$ 必然出现在队列中，同时，$y$ 是一个当前不在排名中的编号。\n2. 操作格式为 $2\\ \\ x$，意味着将编号为 $x$ 的用户的排名提升到第一位，执行完该操作后需要输出执行该操作前编号为 $x$ 用户的排名。\n3. 操作格式为 $3\\ \\ x$，意味着将编号为 $x$ 的用户的排名降到最后一位，执行完该操作后需要输出执行该操作前编号为 $x$ 用户的排名。\n4. 操作格式为 $4\\ \\ k$，意味着查询当前排名为 $k$ 的用户编号，执行完该操作后需要输出当前操作用户的编号。\n\n但同时为了防止别人监听自己的工作，方伯伯对他的操作进行了加密，即将四种操作的格式分别改为了：\n\n- $1\\ \\ x+a\\ \\ y+a$；\n- $2\\ \\ x+a$；\n- $3\\ \\ x+a$；\n- $4\\ \\ k+a$；\n- 其中 $a$ 为上一次操作得到的输出，一开始 $a=0$。\n\n例如：上一次操作得到的输出是 $5$，这一次操作的输入为：$1\\ \\ 13\\ \\ 15$ 因为这个输入是经过加密后的，所以你应该处理的操作是 $1\\ \\ 8\\ \\ 10$。\n\n现在你截获了方伯伯的所有操作，希望你能给出结果。", "inputFormat": "输入的第 $1$ 行包含 $2$ 个用空格分隔的整数 $n$ 和 $m$，表示初始用户数和操作数。此后有 $m$ 行，每行是一个询问，询问格式如上所示。", "outputFormat": "输出包含 $m$ 行。每行包含一个整数，其中第 $i$ 行的整数表示第 $i$ 个操作的输出。", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 10^8$，$1 \\le m \\le 10^5$。\n\n输入保证对于所有的操作 $1,2,3$，$x$ 必然已经出现在队列中，同时对于所有操作 $1$，$1 \\le y \\le 2\\times 10^8$，并且 $y$ 没有出现在队列中。\n\n对于所有操作 $4$，保证 $1 \\le k \\le n$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2014] Uncle Fang's OJ", "background": "", "description": "Uncle Fang is building his OJ. Now he is handling the user ranking problem on the OJ. There are $n$ registered users on the OJ, numbered $1\\sim n$, and initially they are ranked in ascending order of their IDs.\n\nDepending on his mood, Uncle Fang performs the following four operations to modify users’ ranks and IDs:\n\n1. Operation format $1\\ \\ x\\ \\ y$ means: change the user whose ID is $x$ to have ID $y$, while keeping their rank unchanged. After this operation, output that user’s position in the queue. It is guaranteed that $x$ appears in the queue, and $y$ is an ID not currently present in the ranking.\n2. Operation format $2\\ \\ x$ means: move the user whose ID is $x$ to the first position. After this operation, output the rank of user $x$ before the move.\n3. Operation format $3\\ \\ x$ means: move the user whose ID is $x$ to the last position. After this operation, output the rank of user $x$ before the move.\n4. Operation format $4\\ \\ k$ means: query the ID of the user whose current rank is $k$. After this operation, output that user’s ID.\n\nTo prevent others from snooping on his work, Uncle Fang encrypts his operations by changing the four formats to:\n\n- $1\\ \\ x+a\\ \\ y+a$；\n- $2\\ \\ x+a$；\n- $3\\ \\ x+a$；\n- $4\\ \\ k+a$；\n- where $a$ is the output of the previous operation, and initially $a=0$.\n\nExample: if the previous operation’s output is $5$, and this operation’s input is $1\\ \\ 13\\ \\ 15$, since the input is encrypted, the operation you should process is $1\\ \\ 8\\ \\ 10$.\n\nYou have intercepted all of Uncle Fang’s operations. Please produce the results.", "inputFormat": "The first line contains two integers $n$ and $m$, representing the initial number of users and the number of operations. Then follow $m$ lines, each containing one query in the formats described above.", "outputFormat": "Output $m$ lines. The integer on the $i$-th line is the output of the $i$-th operation.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le 10^8$, $1 \\le m \\le 10^5$.\n\nIt is guaranteed that for all operations $1,2,3$, $x$ already appears in the queue. For all operations $1$, $1 \\le y \\le 2\\times 10^8$, and $y$ does not appear in the queue.\n\nFor all operations $4$, it is guaranteed that $1 \\le k \\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2014] 方伯伯的OJ", "background": "", "description": "方伯伯正在做他的 OJ。现在他在处理 OJ 上的用户排名问题。OJ 上注册了 $n$ 个用户，编号为 $1\\sim n$，一开始他们按照编号排名。\n\n方伯伯会按照心情对这些用户做以下四种操作，修改用户的排名和编号：\n\n1. 操作格式为 $1\\ \\ x\\ \\ y$，意味着将编号为 $x$ 的用户编号改为 $y$，而排名不变，执行完该操作后需要输出该用户在队列中的位置，数据保证 $x$ 必然出现在队列中，同时，$y$ 是一个当前不在排名中的编号。\n2. 操作格式为 $2\\ \\ x$，意味着将编号为 $x$ 的用户的排名提升到第一位，执行完该操作后需要输出执行该操作前编号为 $x$ 用户的排名。\n3. 操作格式为 $3\\ \\ x$，意味着将编号为 $x$ 的用户的排名降到最后一位，执行完该操作后需要输出执行该操作前编号为 $x$ 用户的排名。\n4. 操作格式为 $4\\ \\ k$，意味着查询当前排名为 $k$ 的用户编号，执行完该操作后需要输出当前操作用户的编号。\n\n但同时为了防止别人监听自己的工作，方伯伯对他的操作进行了加密，即将四种操作的格式分别改为了：\n\n- $1\\ \\ x+a\\ \\ y+a$；\n- $2\\ \\ x+a$；\n- $3\\ \\ x+a$；\n- $4\\ \\ k+a$；\n- 其中 $a$ 为上一次操作得到的输出，一开始 $a=0$。\n\n例如：上一次操作得到的输出是 $5$，这一次操作的输入为：$1\\ \\ 13\\ \\ 15$ 因为这个输入是经过加密后的，所以你应该处理的操作是 $1\\ \\ 8\\ \\ 10$。\n\n现在你截获了方伯伯的所有操作，希望你能给出结果。", "inputFormat": "输入的第 $1$ 行包含 $2$ 个用空格分隔的整数 $n$ 和 $m$，表示初始用户数和操作数。此后有 $m$ 行，每行是一个询问，询问格式如上所示。", "outputFormat": "输出包含 $m$ 行。每行包含一个整数，其中第 $i$ 行的整数表示第 $i$ 个操作的输出。", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 10^8$，$1 \\le m \\le 10^5$。\n\n输入保证对于所有的操作 $1,2,3$，$x$ 必然已经出现在队列中，同时对于所有操作 $1$，$1 \\le y \\le 2\\times 10^8$，并且 $y$ 没有出现在队列中。\n\n对于所有操作 $4$，保证 $1 \\le k \\le n$。", "locale": "zh-CN"}}}
{"pid": "P3286", "type": "P", "difficulty": 6, "samples": [["3 8 3", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "贪心", "2014", "四川", "各省省选", "O2优化", "枚举", "数位 DP"], "title": "[SCOI2014] 方伯伯的商场之旅", "background": "", "description": "方伯伯有一天去参加一个商场举办的游戏。商场派了一些工作人员排成一行。每个人面前有几堆石子。\n\n说来也巧，位置在 $i$ 的人面前的第 $j$ 堆的石子的数量，刚好是 $i$ 写成 $K$ 进制后的第 $j$ 位。现在方伯伯要玩一个游戏，商场会给方伯伯两个整数 $L,R$。\n\n方伯伯要把位置在 $[L, R]$ 中的每个人的石子都合并成一堆石子。每次操作，他可以选择一个人面前的两堆石子，将其中的一堆中的某些石子移动到另一堆，代价是移动的石子数量 $\\times$ 移动的距离。\n\n商场承诺，方伯伯只要完成任务，就给他一些椰子，代价越小，给他的椰子越多。所以方伯伯很着急，想请你告诉他最少的代价是多少。例如：$10$ 进制下的位置在 $12312$ 的人，合并石子的最少代价为：$1 \\times 2 + 2 \\times 1 + 3 \\times 0 + 1 \\times1 + 2 \\times 2 = 9$即把所有的石子都合并在第三堆。\n", "inputFormat": "输入仅有 $1$ 行，包含 $3$ 个用空格分隔的整数 $L,R,K$，表示商场给方伯伯的 $2$ 个整数，以及进制数。", "outputFormat": "输出仅有 $1$ 行，包含 $1$ 个整数，表示最少的代价。", "hint": "对于 $100\\%$ 的数据，$1 \\le L \\le R \\le 10^{15}, 2 \\le K \\le 20$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2014] Uncle Fang's Trip to the Mall", "background": "", "description": "One day, Uncle Fang went to a game hosted by a mall. The mall arranged some staff members in a line. In front of each person, there are several piles of stones.\n\nBy coincidence, for the person at position $i$, the number of stones in the $j$-th pile is exactly the $j$-th digit of $i$ when written in base $K$. Now Uncle Fang is going to play a game: the mall will give him two integers $L, R$.\n\nUncle Fang needs to merge all the piles in front of each person whose position is in $[L, R]$ into a single pile. In each operation, he may choose two piles in front of one person and move some stones from one pile to the other. The cost is equal to (the number of stones moved) $\\times$ (the distance moved).\n\nThe mall promises that as long as Uncle Fang completes the task, they will give him some coconuts; the smaller the cost, the more coconuts he will receive. So he is anxious and asks you to tell him the minimum cost. For example, for the person at position $12312$ in base $10$, the minimum cost to merge the stones is $1 \\times 2 + 2 \\times 1 + 3 \\times 0 + 1 \\times 1 + 2 \\times 2 = 9$, that is, merge all stones into the third pile.", "inputFormat": "The input consists of only $1$ line containing $3$ space-separated integers $L, R, K$, representing the two integers given by the mall and the base.", "outputFormat": "Output only $1$ line containing $1$ integer, the minimum cost.", "hint": "For $100\\%$ of the testdata, $1 \\le L \\le R \\le 10^{15}$, $2 \\le K \\le 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2014] 方伯伯的商场之旅", "background": "", "description": "方伯伯有一天去参加一个商场举办的游戏。商场派了一些工作人员排成一行。每个人面前有几堆石子。\n\n说来也巧，位置在 $i$ 的人面前的第 $j$ 堆的石子的数量，刚好是 $i$ 写成 $K$ 进制后的第 $j$ 位。现在方伯伯要玩一个游戏，商场会给方伯伯两个整数 $L,R$。\n\n方伯伯要把位置在 $[L, R]$ 中的每个人的石子都合并成一堆石子。每次操作，他可以选择一个人面前的两堆石子，将其中的一堆中的某些石子移动到另一堆，代价是移动的石子数量 $\\times$ 移动的距离。\n\n商场承诺，方伯伯只要完成任务，就给他一些椰子，代价越小，给他的椰子越多。所以方伯伯很着急，想请你告诉他最少的代价是多少。例如：$10$ 进制下的位置在 $12312$ 的人，合并石子的最少代价为：$1 \\times 2 + 2 \\times 1 + 3 \\times 0 + 1 \\times1 + 2 \\times 2 = 9$即把所有的石子都合并在第三堆。\n", "inputFormat": "输入仅有 $1$ 行，包含 $3$ 个用空格分隔的整数 $L,R,K$，表示商场给方伯伯的 $2$ 个整数，以及进制数。", "outputFormat": "输出仅有 $1$ 行，包含 $1$ 个整数，表示最少的代价。", "hint": "对于 $100\\%$ 的数据，$1 \\le L \\le R \\le 10^{15}, 2 \\le K \\le 20$。", "locale": "zh-CN"}}}
{"pid": "P3287", "type": "P", "difficulty": 6, "samples": [["3 1\n2 1 3", "3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2014", "四川", "各省省选", "树状数组", "O2优化"], "title": "[SCOI2014] 方伯伯的玉米田", "background": "", "description": "方伯伯在自己的农田边散步，他突然发现田里的一排玉米非常的不美。这排玉米一共有 $N$ 株，它们的高度参差不齐。方伯伯认为单调不下降序列很美，所以他决定先把一些玉米拔高，再把破坏美感的玉米拔除掉，使得剩下的玉米的高度构成一个单调不下降序列。方伯伯可以选择一个区间，把这个区间的玉米全部拔高 $1$ 单位高度，他可以进行最多 $K$ 次这样的操作。拔玉米则可以随意选择一个集合的玉米拔掉。问能最多剩多少株玉米，来构成一排美丽的玉米。", "inputFormat": "第一行包含两个整数 $n, K$，分别表示这排玉米的数目以及最多可进行多少次操作。第二行包含 $n$ 个整数，第 $i$ 个数表示这排玉米，从左到右第 $i$ 株玉米的高度 $a_i$。", "outputFormat": "输出一个整数，最多剩下的玉米数。\n", "hint": "$100\\%$ 的数据满足：$2 \\le N \\lt 10^4 $，$2 \\le K \\le 500$，$1 \\leq a_i \\leq 5000$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2014] Uncle Fang's Cornfield", "background": "", "description": "While walking along the edge of his farmland, Uncle Fang suddenly noticed that one row of corn looked very unattractive. There are $N$ stalks in this row, and their heights vary. Uncle Fang thinks a non-decreasing sequence is beautiful, so he decides to first raise some stalks and then pull out any stalks that spoil the beauty, so that the heights of the remaining stalks form a non-decreasing sequence. He may choose an interval and increase every stalk in that interval by 1 unit of height; he may perform at most $K$ such operations. He may also freely choose any set of stalks to remove. What is the maximum number of stalks that can remain to form a beautiful row?", "inputFormat": "The first line contains two integers $n$, $K$, denoting the number of stalks in this row and the maximum number of operations allowed, respectively. The second line contains $n$ integers; the $i$-th number is the height $a_i$ of the $i$-th stalk from left to right.", "outputFormat": "Output a single integer, the maximum number of remaining stalks.", "hint": "Constraints: $100\\%$ of the testdata satisfies: $2 \\le N \\lt 10^4 $, $2 \\le K \\le 500$, $1 \\leq a_i \\leq 5000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2014] 方伯伯的玉米田", "background": "", "description": "方伯伯在自己的农田边散步，他突然发现田里的一排玉米非常的不美。这排玉米一共有 $N$ 株，它们的高度参差不齐。方伯伯认为单调不下降序列很美，所以他决定先把一些玉米拔高，再把破坏美感的玉米拔除掉，使得剩下的玉米的高度构成一个单调不下降序列。方伯伯可以选择一个区间，把这个区间的玉米全部拔高 $1$ 单位高度，他可以进行最多 $K$ 次这样的操作。拔玉米则可以随意选择一个集合的玉米拔掉。问能最多剩多少株玉米，来构成一排美丽的玉米。", "inputFormat": "第一行包含两个整数 $n, K$，分别表示这排玉米的数目以及最多可进行多少次操作。第二行包含 $n$ 个整数，第 $i$ 个数表示这排玉米，从左到右第 $i$ 株玉米的高度 $a_i$。", "outputFormat": "输出一个整数，最多剩下的玉米数。\n", "hint": "$100\\%$ 的数据满足：$2 \\le N \\lt 10^4 $，$2 \\le K \\le 500$，$1 \\leq a_i \\leq 5000$。", "locale": "zh-CN"}}}
{"pid": "P3288", "type": "P", "difficulty": 6, "samples": [["5 10\n1 5 13 13 0 412\n2 5 30 18 396 148\n1 5 33 31 0 39\n4 5 22 4 0 786\n4 5 13 32 0 561\n4 5 3 48 0 460\n2 5 32 47 604 258\n5 7 44 37 75 164\n5 7 34 50 925 441\n6 2 26 38 1000 22", "103.00"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "四川", "各省省选", "网络流", "负权环", "分数规划"], "title": "[SCOI2014] 方伯伯运椰子", "background": null, "description": "四川的方伯伯为了致富，决定引进海南的椰子树。方伯伯的椰子园十分现代化，椰子园中有一套独特的交通系统。\n\n现在用点来表示交通节点，边来表示道路。这样，方伯伯的椰子园就可以看作一个有 $N + 2$ 个交通节点，$M$ 条边的有向无环图。$N + 1$ 号点为入口，$N + 2$ 号点为出口。每条道路都有 $6$ 个参数，$u_i,v_i,a_i,b_i,c_i,d_i$，分别表示该道路从 $u_i$ 号点通向 $v_i$ 号点，将它的容量压缩一次要 $a_i$ 的花费，容量扩大一次要 $b_i$ 的花费，该条道路当前的运输容量上限为 $c_i$，并且每单位运输量通过该道路要 $d_i$ 的费用。\n\n在这个交通网络中，只有一条道路与起点相连。因为弄坏了这条道路就会导致整个交通网络瘫痪，聪明的方伯伯决定绝不对这条道路进行调整，也就是说，现在除了这条道路之外，对其余道路都可以进行调整。\n\n有两种调整方式：\n\n- 选择一条道路，将其进行一次压缩，这条道路的容量会下降 $1$ 单位。\n\n- 选择一条道路，将其进行一次扩容，这条道路的容量会上升 $1$ 单位。\n\n一条道路可以被多次调整。\n\n由于很久以前，方伯伯就请过一个工程师，对这个交通网络进行过一次大的优化调整。所以现在所有的道路都被完全地利用起来了，即每条道路的负荷都是满的（每条道路的流量等于其容量）。\n\n但方伯伯一想到自己的海南椰子会大丰收，就十分担心巨大的运输量下，会导致过多的花费。因此，方伯伯决定至少进行一次调整，调整之后，必须要保持每条道路满负荷，且总交通量不会减少。\n\n设调整后的总费用是 $Y$，调整之前的总费用是 $X$。现在方伯伯想知道，最优调整比率是多少，即假设他进行了  $k$ 次调整，$\\dfrac{X - Y}{k}$ 最大能是多少？\n\n注：总费用 $=$ 交通网络的运输花费 $+$ 调整的花费。", "inputFormat": "第一行包含二个整数 $N, M$。接下来 $M$ 行代表 $M$ 条边，表示这个交通网络，每行六个整数，表示 $u_i,v_i,a_i,b_i,c_i,d_i$。", "outputFormat": "一个浮点数，保留二位小数，表示答案。数据保证答案大于 $0$。", "hint": "对于所有数据，$1 \\le N \\le 5 \\times 10^3$，$1 \\le M \\le 3 \\times 10^3$，$1 \\le u_i, v_i \\le N + 2$，$0 \\le a_i, b_i \\le 500$，$0 \\le c_i \\le 10^4$，$0 \\le d_i \\le 10^3$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2014] Uncle Fang Transports Coconuts", "background": "", "description": "To get rich, Uncle Fang from Sichuan decides to introduce coconut trees from Hainan. His coconut plantation is highly modernized, with a unique transportation system inside.\n\nWe model transportation junctions as nodes and roads as edges. Thus, the plantation can be seen as a directed acyclic graph (DAG) with $N + 2$ transportation nodes and $M$ edges. Node $N + 1$ is the entrance (source), and node $N + 2$ is the exit (sink). Each road has six parameters $u_i, v_i, a_i, b_i, c_i, d_i$, meaning the road goes from node $u_i$ to node $v_i$; compressing its capacity by $1$ unit costs $a_i$; expanding its capacity by $1$ unit costs $b_i$; its current capacity upper bound is $c_i$; and transporting each unit of flow along this road costs $d_i$.\n\nIn this transportation network, there is exactly one edge outgoing from the source. Since damaging this road would paralyze the entire network, the clever Uncle Fang decides never to adjust this road. That is, all other roads can be adjusted.\n\nThere are two types of adjustments:\n- Choose a road and compress it once; the capacity of this road decreases by $1$ unit.\n- Choose a road and expand it once; the capacity of this road increases by $1$ unit.\n\nA road can be adjusted multiple times.\n\nA long time ago, Uncle Fang hired an engineer to optimize this transportation network. So now every road is fully utilized, i.e., the load on each road is at its limit (the flow on each road equals its capacity).\n\nHowever, thinking of the upcoming bumper harvest of Hainan coconuts, Uncle Fang worries that the huge transportation volume will cause excessive costs. Therefore, he decides to perform at least one adjustment. After the adjustments, every road must remain fully utilized, and the total throughput must not decrease.\n\nLet the total cost after adjustments be $Y$, and the total cost before adjustments be $X$. Uncle Fang wants to know the optimal adjustment ratio, i.e., if he performs $k$ adjustments in total, what is the maximum possible value of $\\dfrac{X - Y}{k}$?\n\nNote: total cost $=$ transportation cost $+$ adjustment cost.", "inputFormat": "The first line contains two integers $N, M$. The next $M$ lines describe the $M$ edges of the transportation network. Each line contains six integers $u_i, v_i, a_i, b_i, c_i, d_i$.", "outputFormat": "Output a floating-point number with two decimal places, representing the answer. The testdata guarantees the answer is greater than $0$.", "hint": "Constraints:\nFor all testdata, $1 \\le N \\le 5 \\times 10^3$, $1 \\le M \\le 3 \\times 10^3$, $1 \\le u_i, v_i \\le N + 2$, $0 \\le a_i, b_i \\le 500$, $0 \\le c_i \\le 10^4$, $0 \\le d_i \\le 10^3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2014] 方伯伯运椰子", "background": null, "description": "四川的方伯伯为了致富，决定引进海南的椰子树。方伯伯的椰子园十分现代化，椰子园中有一套独特的交通系统。\n\n现在用点来表示交通节点，边来表示道路。这样，方伯伯的椰子园就可以看作一个有 $N + 2$ 个交通节点，$M$ 条边的有向无环图。$N + 1$ 号点为入口，$N + 2$ 号点为出口。每条道路都有 $6$ 个参数，$u_i,v_i,a_i,b_i,c_i,d_i$，分别表示该道路从 $u_i$ 号点通向 $v_i$ 号点，将它的容量压缩一次要 $a_i$ 的花费，容量扩大一次要 $b_i$ 的花费，该条道路当前的运输容量上限为 $c_i$，并且每单位运输量通过该道路要 $d_i$ 的费用。\n\n在这个交通网络中，只有一条道路与起点相连。因为弄坏了这条道路就会导致整个交通网络瘫痪，聪明的方伯伯决定绝不对这条道路进行调整，也就是说，现在除了这条道路之外，对其余道路都可以进行调整。\n\n有两种调整方式：\n\n- 选择一条道路，将其进行一次压缩，这条道路的容量会下降 $1$ 单位。\n\n- 选择一条道路，将其进行一次扩容，这条道路的容量会上升 $1$ 单位。\n\n一条道路可以被多次调整。\n\n由于很久以前，方伯伯就请过一个工程师，对这个交通网络进行过一次大的优化调整。所以现在所有的道路都被完全地利用起来了，即每条道路的负荷都是满的（每条道路的流量等于其容量）。\n\n但方伯伯一想到自己的海南椰子会大丰收，就十分担心巨大的运输量下，会导致过多的花费。因此，方伯伯决定至少进行一次调整，调整之后，必须要保持每条道路满负荷，且总交通量不会减少。\n\n设调整后的总费用是 $Y$，调整之前的总费用是 $X$。现在方伯伯想知道，最优调整比率是多少，即假设他进行了  $k$ 次调整，$\\dfrac{X - Y}{k}$ 最大能是多少？\n\n注：总费用 $=$ 交通网络的运输花费 $+$ 调整的花费。", "inputFormat": "第一行包含二个整数 $N, M$。接下来 $M$ 行代表 $M$ 条边，表示这个交通网络，每行六个整数，表示 $u_i,v_i,a_i,b_i,c_i,d_i$。", "outputFormat": "一个浮点数，保留二位小数，表示答案。数据保证答案大于 $0$。", "hint": "对于所有数据，$1 \\le N \\le 5 \\times 10^3$，$1 \\le M \\le 3 \\times 10^3$，$1 \\le u_i, v_i \\le N + 2$，$0 \\le a_i, b_i \\le 500$，$0 \\le c_i \\le 10^4$，$0 \\le d_i \\le 10^3$。", "locale": "zh-CN"}}}
