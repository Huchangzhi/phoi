{"pid": "P5872", "type": "P", "difficulty": 4, "samples": [["8 12\n1 2 2 10\n2 3 1 10\n3 8 2 10\n1 4 10 3\n4 5 10 2\n5 6 10 4\n6 8 10 2\n1 7 10 5\n4 7 10 2\n5 7 10 2\n6 7 10 1\n7 8 10 1\n3\n1 3\n2 2\n3 0\n4\n4 5 6 7", "2\n4 5"], ["6 6\n1 4 1 3\n4 6 1 1\n4 2 1 6\n2 6 6 6\n3 4 2 3\n1 3 4 5\n2\n1 2\n2 0\n4\n6 5 3 4", "0"]], "limits": {"time": [400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "最短路", "ICPC", "双指针 two-pointer", "SEERC"], "title": "[SEERC 2018] Rabbit vs Turtle", "background": "", "description": "一只兔子和一只乌龟决定赛跑。由于乌龟来自 Craiova 而兔子来自 Ardeal，乌龟比兔子跑得快的多。我们的目标是帮助兔子赢得比赛。\n\n比赛在一个 $N$ 个点 $M$ 条边的图上进行，比赛在点 $1$ 开始，点 $N$ 结束。比赛前，兔子和乌龟都要先选出一条比赛时他们各自使用的路径。因此，他们知道这个图的情况和经过图上每条边的时间。\n\n乌龟可能跑的比兔子快，但他还是一只乌龟（后文叫做 George）。George 会在他的路径上选出一些点来睡一会。如果某一时刻他知道了兔子在作弊，George 就不再睡觉，直到完成比赛。\n\n兔子（后文叫做 Stan）只有一个优势，他的一个祖祖祖……祖母是一只狐狸，因此他也有狡猾的一面。Stan 并不打算按照他选好的路径来比赛（但 George 会按照路径比赛）。他计划在某一点更改路线，直接通过最短路径到达点 $N$。唯一的问题是他必须做出明智的选择，因为 George 一旦发现 Stan 在作弊，就会不再睡觉，这是不利的。\n\nStan 只能在到达一个点后更改路线（还在边上移动的时候是不能更改的）。他并不知道 George 的休息计划，但你知道！计算出 Stan 可以更改路线并赢得比赛的时间点数量。当 Stan 开始作弊的时候，George 只要没有在睡觉，就会立即察觉到。如果那时 George 在睡觉，则他醒来的时候才会察觉。", "inputFormat": "第一行包含两个整数 $N$ 和 $M$。接下来 $M$ 行用 $(A,B,T,R)$ 的格式来描述图中的边：有一条边连接点 $A$ 和 $B$，乌龟经过这条边需要花费 $T$ 时间，兔子需要花费 $R$ 时间。边按输入顺序从 $1$ 到 $M$ 编号。\n\n接下来一行包含一个整数 $P_T$，代表 George 路径上的边数。接下来 $P_T$ 行用 (边的编号, 睡眠时间) 来描述路径上的边：路径上有一条给定编号的边，在经过这条边后，George 会睡一会，睡眠时间给定。最后一条边的睡眠时间是没有意义的，因为 George 已经到终点了。\n\n接下来一行包含一个整数 $P_R$，代表 Stan 最开始选择的路径上的边数。最后一行包含 $P_R$ 个整数，代表 Stan 最开始路径上的边的编号。", "outputFormat": "输出第一行包含一个整数 $x$，代表 Stan 可以开始作弊的时间点（也就是开始作弊所在的点）数量。第二行包含 $x$ 个递增顺序的整数，代表 Stan 可以开始作弊的点的编号。", "hint": "- $2 \\leq N \\leq 100,000$\n- $1 \\leq P_R, P_T < 100,000$\n- $1 \\leq M \\leq 200,000$\n- $1 \\leq T,R \\leq 1,000,000,000$\n- $0 \\leq$ 睡眠时间 $\\leq 1,000,000,000$\n- 数据保证按照正确的顺序描述比赛路径上的边（即相邻两条边终点、起点相同）。\n- 数据保证乌龟路径上的点不重复。\n- 数据保证兔子路径上的点不重复。\n- 如果兔子和乌龟同时到达终点，认为兔子赢了。\n- 如果兔子在乌龟开始睡觉的时候开始作弊，那么乌龟会睡着，醒来时才察觉兔子在作弊。\n- 认为兔子在作弊当且仅当他改变了路径且新路径严格快于原来的路径（否则就没必要作弊了）。\n- 作弊路径可能与原始路径有相同的点。唯一的要求是在开始作弊的时候，兔子前往和原路径不同的点。在某些情况中，他也可能会回到之前经过的点。", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2018] Rabbit vs Turtle", "background": "", "description": "A rabbit and a turtle decide to race. Since the turtle is from Craiova and the rabbit is from Ardeal, the turtle runs much faster than the rabbit. Our goal is to help the rabbit win the race.\n\nThe race takes place on a graph with $N$ nodes and $M$ edges. The race starts at node $1$ and ends at node $N$. Before the race, both the rabbit and the turtle choose a path that they will use during the race. Therefore, they know the graph and the time needed to traverse each edge.\n\nThe turtle may be faster than the rabbit, but he is still a turtle (called George below). George will choose some nodes on his path to sleep for a while. If at some moment he finds out that the rabbit is cheating, George will stop sleeping until he finishes the race.\n\nThe rabbit (called Stan below) has only one advantage: one of his great-great-great... grandmothers was a fox, so he also has a crafty side. Stan does not plan to follow his chosen path during the race (but George will follow his path). He plans to change his route at some node and then go directly to node $N$ via the shortest path. The only problem is that he must make a wise choice, because once George discovers that Stan is cheating, George will no longer sleep, which is unfavorable.\n\nStan can change his route only after arriving at a node (he cannot change while moving along an edge). He does not know George’s sleeping plan, but you do. Compute how many nodes allow Stan to change his route and win the race. When Stan starts cheating, if George is not sleeping, he will notice immediately. If George is sleeping at that moment, he will notice only when he wakes up.", "inputFormat": "The first line contains two integers $N$ and $M$. The next $M$ lines describe the edges in the format $(A,B,T,R)$: there is an edge connecting nodes $A$ and $B$, the turtle needs $T$ time to traverse this edge, and the rabbit needs $R$ time. The edges are numbered from $1$ to $M$ in the input order.\n\nThe next line contains an integer $P_T$, the number of edges in George’s path. The next $P_T$ lines describe the path as (edge id, sleep time): the path uses the edge with the given id, and after traversing this edge, George will sleep for a while, with the given sleep time. The sleep time after the last edge is meaningless, because George has already reached the finish.\n\nThe next line contains an integer $P_R$, the number of edges in Stan’s initially chosen path. The last line contains $P_R$ integers, the edge ids of the edges in Stan’s initial path.", "outputFormat": "Output on the first line an integer $x$, the number of nodes where Stan can start cheating (i.e., the node where he starts cheating). On the second line output $x$ integers in increasing order, the ids of the nodes where Stan can start cheating.", "hint": "- $2 \\leq N \\leq 100,000$.\n- $1 \\leq P_R, P_T < 100,000$.\n- $1 \\leq M \\leq 200,000$.\n- $1 \\leq T,R \\leq 1,000,000,000$.\n- $0 \\leq$ sleep time $\\leq 1,000,000,000$.\n- The testdata guarantees that the edges on the race paths are described in the correct order (i.e., the end of one edge is the start of the next).\n- The testdata guarantees that the nodes on the turtle’s path do not repeat.\n- The testdata guarantees that the nodes on the rabbit’s path do not repeat.\n- If the rabbit and the turtle arrive at the finish at the same time, the rabbit is considered to win.\n- If the rabbit starts cheating exactly when the turtle starts sleeping, then the turtle will fall asleep and will notice the cheating only when he wakes up.\n- The rabbit is considered cheating if and only if he changes his path and the new path is strictly faster than the original path (otherwise there is no need to cheat).\n- The cheating path may share nodes with the original path. The only requirement is that when he starts cheating, the rabbit moves to a different next node than in the original path. In some cases, he may also return to a node he visited before.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2018] Rabbit vs Turtle", "background": "", "description": "一只兔子和一只乌龟决定赛跑。由于乌龟来自 Craiova 而兔子来自 Ardeal，乌龟比兔子跑得快的多。我们的目标是帮助兔子赢得比赛。\n\n比赛在一个 $N$ 个点 $M$ 条边的图上进行，比赛在点 $1$ 开始，点 $N$ 结束。比赛前，兔子和乌龟都要先选出一条比赛时他们各自使用的路径。因此，他们知道这个图的情况和经过图上每条边的时间。\n\n乌龟可能跑的比兔子快，但他还是一只乌龟（后文叫做 George）。George 会在他的路径上选出一些点来睡一会。如果某一时刻他知道了兔子在作弊，George 就不再睡觉，直到完成比赛。\n\n兔子（后文叫做 Stan）只有一个优势，他的一个祖祖祖……祖母是一只狐狸，因此他也有狡猾的一面。Stan 并不打算按照他选好的路径来比赛（但 George 会按照路径比赛）。他计划在某一点更改路线，直接通过最短路径到达点 $N$。唯一的问题是他必须做出明智的选择，因为 George 一旦发现 Stan 在作弊，就会不再睡觉，这是不利的。\n\nStan 只能在到达一个点后更改路线（还在边上移动的时候是不能更改的）。他并不知道 George 的休息计划，但你知道！计算出 Stan 可以更改路线并赢得比赛的时间点数量。当 Stan 开始作弊的时候，George 只要没有在睡觉，就会立即察觉到。如果那时 George 在睡觉，则他醒来的时候才会察觉。", "inputFormat": "第一行包含两个整数 $N$ 和 $M$。接下来 $M$ 行用 $(A,B,T,R)$ 的格式来描述图中的边：有一条边连接点 $A$ 和 $B$，乌龟经过这条边需要花费 $T$ 时间，兔子需要花费 $R$ 时间。边按输入顺序从 $1$ 到 $M$ 编号。\n\n接下来一行包含一个整数 $P_T$，代表 George 路径上的边数。接下来 $P_T$ 行用 (边的编号, 睡眠时间) 来描述路径上的边：路径上有一条给定编号的边，在经过这条边后，George 会睡一会，睡眠时间给定。最后一条边的睡眠时间是没有意义的，因为 George 已经到终点了。\n\n接下来一行包含一个整数 $P_R$，代表 Stan 最开始选择的路径上的边数。最后一行包含 $P_R$ 个整数，代表 Stan 最开始路径上的边的编号。", "outputFormat": "输出第一行包含一个整数 $x$，代表 Stan 可以开始作弊的时间点（也就是开始作弊所在的点）数量。第二行包含 $x$ 个递增顺序的整数，代表 Stan 可以开始作弊的点的编号。", "hint": "- $2 \\leq N \\leq 100,000$\n- $1 \\leq P_R, P_T < 100,000$\n- $1 \\leq M \\leq 200,000$\n- $1 \\leq T,R \\leq 1,000,000,000$\n- $0 \\leq$ 睡眠时间 $\\leq 1,000,000,000$\n- 数据保证按照正确的顺序描述比赛路径上的边（即相邻两条边终点、起点相同）。\n- 数据保证乌龟路径上的点不重复。\n- 数据保证兔子路径上的点不重复。\n- 如果兔子和乌龟同时到达终点，认为兔子赢了。\n- 如果兔子在乌龟开始睡觉的时候开始作弊，那么乌龟会睡着，醒来时才察觉兔子在作弊。\n- 认为兔子在作弊当且仅当他改变了路径且新路径严格快于原来的路径（否则就没必要作弊了）。\n- 作弊路径可能与原始路径有相同的点。唯一的要求是在开始作弊的时候，兔子前往和原路径不同的点。在某些情况中，他也可能会回到之前经过的点。", "locale": "zh-CN"}}}
{"pid": "P5873", "type": "P", "difficulty": 6, "samples": [["5\n1 2 3\n1 2 2\n1 3 4\n2 1 1 5 5\n2 2 2 2 2", "0\n0\n0\n3\n4"], ["4\n2 1 1 3 3\n2 1 1 2 2\n1 2 2\n1 2 2", "0\n0\n2\n4"], ["7\n1 5 5\n1 5 5\n1 5 5\n2 2 2 9 9\n2 1 1 5 5\n2 1 1 2 2\n1 2 2", "0\n0\n0\n3\n6\n6\n9"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "cdq 分治", "ICPC", "SEERC"], "title": "[SEERC 2018] Points and Rectangles", "background": "", "description": "给定一个空的二维平面，给定 $q$ 次询问。询问有两种类型：\n\n- $1 \\ x \\ y$ — 向平面中添加一个坐标为 $(x,y)$ 的点。\n- $2 \\ x_1 \\ y_1 \\ x_2 \\ y_2$ — 添加一个左下角坐标为 $(x_1,y_1)$、右上角坐标为 $(x_2,y_2)$ 的矩形。矩形的面积可以是 $0$，矩形也可以退化成一个点。\n\n矩形和点可能会重叠。\n\n每次询问操作完成之后，计算出使点在矩形内部或边上的点-矩形对数。", "inputFormat": "第一行包含一个整数 $q \\ (1 \\leq q \\leq 10^5)$，代表询问数。\n\n接下来 $q$ 行每行描述一个询问：\n\n- $1 \\ x \\ y \\ (1 \\leq x,y \\leq 10^9)$ — 向平面中添加一个坐标为 $(x,y)$ 的点。\n- $2 \\ x_1 \\ y_1 \\ x_2 \\ y_2 \\ (1 \\leq x_1 \\leq x_2 \\leq 10^9, 1 \\leq y_1 \\leq y_2 \\leq 10^9)$ — 添加一个左下角坐标为 $(x_1,y_1)$、右上角坐标为 $(x_2,y_2)$ 的矩形。", "outputFormat": "你需要输出 $q$ 行，第 $i$ 行包含一个整数，代表使点在矩形内部或边上的点-矩形对数。", "hint": "第一个样例的解释：\n\n第一次询问操作后，平面上有一个点 $(2,3)$，但没有矩形，因此没有满足条件的点-矩形对。\n\n第二次询问操作后，平面上仍然没有矩形，因此仍然没有这样的对。\n\n第三次询问操作后依然没有矩形。\n\n在第四次询问中，我们向平面中添加了一个左下角为 $(1,1)$、右上角为 $(5,5)$ 的矩形。之前添加的所有的点都在这个矩形中，因此这样的对有 $3$ 个。\n\n第五次询问操作后，我们有 $4$ 个这样的对：上面的 $3$ 对，以及第二次询问插入的点在第五次询问插入的矩形中新增的 $1$ 对。\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2018] Points and Rectangles", "background": "", "description": "You are given an empty 2D plane and $q$ queries. There are two types of queries:\n\n- $1 \\ x \\ y$ — Add a point with coordinates $(x,y)$ to the plane.\n- $2 \\ x_1 \\ y_1 \\ x_2 \\ y_2$ — Add a rectangle whose bottom-left corner is $(x_1,y_1)$ and top-right corner is $(x_2,y_2)$. The area of the rectangle can be $0$, and the rectangle may degenerate into a point.\n\nRectangles and points may overlap.\n\nAfter each query is processed, compute the number of point-rectangle pairs such that the point is inside the rectangle or on its boundary.", "inputFormat": "The first line contains an integer $q \\ (1 \\leq q \\leq 10^5)$, denoting the number of queries.\n\nThe next $q$ lines each describe one query:\n\n- $1 \\ x \\ y \\ (1 \\leq x,y \\leq 10^9)$ — Add a point with coordinates $(x,y)$ to the plane.\n- $2 \\ x_1 \\ y_1 \\ x_2 \\ y_2 \\ (1 \\leq x_1 \\leq x_2 \\leq 10^9, 1 \\leq y_1 \\leq y_2 \\leq 10^9)$ — Add a rectangle whose bottom-left corner is $(x_1,y_1)$ and top-right corner is $(x_2,y_2)$.", "outputFormat": "Output $q$ lines. The $i$-th line should contain one integer, representing the number of point-rectangle pairs such that the point is inside the rectangle or on its boundary.", "hint": "Explanation of the first sample:\n\nAfter the first query, there is one point $(2,3)$ on the plane, but there are no rectangles, so there are no valid point-rectangle pairs.\n\nAfter the second query, there are still no rectangles, so there are still no such pairs.\n\nAfter the third query, there are still no rectangles.\n\nIn the fourth query, we add a rectangle with bottom-left corner $(1,1)$ and top-right corner $(5,5)$. All points added before are inside this rectangle, so there are $3$ such pairs.\n\nAfter the fifth query, we have $4$ such pairs: the $3$ pairs above, plus $1$ new pair where the point inserted in the second query lies inside the rectangle inserted in the fifth query.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2018] Points and Rectangles", "background": "", "description": "给定一个空的二维平面，给定 $q$ 次询问。询问有两种类型：\n\n- $1 \\ x \\ y$ — 向平面中添加一个坐标为 $(x,y)$ 的点。\n- $2 \\ x_1 \\ y_1 \\ x_2 \\ y_2$ — 添加一个左下角坐标为 $(x_1,y_1)$、右上角坐标为 $(x_2,y_2)$ 的矩形。矩形的面积可以是 $0$，矩形也可以退化成一个点。\n\n矩形和点可能会重叠。\n\n每次询问操作完成之后，计算出使点在矩形内部或边上的点-矩形对数。", "inputFormat": "第一行包含一个整数 $q \\ (1 \\leq q \\leq 10^5)$，代表询问数。\n\n接下来 $q$ 行每行描述一个询问：\n\n- $1 \\ x \\ y \\ (1 \\leq x,y \\leq 10^9)$ — 向平面中添加一个坐标为 $(x,y)$ 的点。\n- $2 \\ x_1 \\ y_1 \\ x_2 \\ y_2 \\ (1 \\leq x_1 \\leq x_2 \\leq 10^9, 1 \\leq y_1 \\leq y_2 \\leq 10^9)$ — 添加一个左下角坐标为 $(x_1,y_1)$、右上角坐标为 $(x_2,y_2)$ 的矩形。", "outputFormat": "你需要输出 $q$ 行，第 $i$ 行包含一个整数，代表使点在矩形内部或边上的点-矩形对数。", "hint": "第一个样例的解释：\n\n第一次询问操作后，平面上有一个点 $(2,3)$，但没有矩形，因此没有满足条件的点-矩形对。\n\n第二次询问操作后，平面上仍然没有矩形，因此仍然没有这样的对。\n\n第三次询问操作后依然没有矩形。\n\n在第四次询问中，我们向平面中添加了一个左下角为 $(1,1)$、右上角为 $(5,5)$ 的矩形。之前添加的所有的点都在这个矩形中，因此这样的对有 $3$ 个。\n\n第五次询问操作后，我们有 $4$ 个这样的对：上面的 $3$ 对，以及第二次询问插入的点在第五次询问插入的矩形中新增的 $1$ 对。\n\n", "locale": "zh-CN"}}}
{"pid": "P5874", "type": "P", "difficulty": 5, "samples": [["3\n2 1 3\n3 4 1\n1\n2 1 2\n", "8\n6\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "2015", "线段树", "IOI"], "title": "[IOI 2015] horses", "background": "", "description": "像他的祖先一样，Mansur 喜欢繁殖马匹。目前，他拥有哈萨克斯坦最大的马场。以前情况可不是这样，$N$ 年前 Mansur 年轻时，他只拥有一匹马，但他一直梦想着成为富豪，最终,他美梦成真。\n\n按照时间的先后顺序将年份编号为 $0$ 到 $N-1$（即 $N-1$ 年是最近的一年）。每年的天气会影响马匹的繁殖。Mansur 用一个正整数 $X[i]$ 记录第 $i$ 年的繁殖系数，如果第 $i$ 年开始时有 $h$ 匹马，那么这一年结束时会有 $h \\times X[i]$ 匹马。\n\n每年，只有年底的时候可以出售马匹。Mansur 用一个正整数 $Y[i]$ 记录第 $i$ 年末卖出一匹马的售价。Mansur 可以卖出任意多匹马，每匹售价均为 $Y[i]$。\n\n现在，Mansur 想知道如果在 $N$ 年中，他总能在最佳时间出售马匹，他能获得的最大收益是多少？你正好在 Mansur 家做客，所以他想请你帮他回答这个问题。\n\nMansur 对记录下的 $X$ 和 $Y$ 做了 $M$ 次更新，每次更新，Mansur 要么改变一个 $X[i]$，要么改变一个 $Y[i]$。每次更新后，他都会问你出售马匹能获得的最大收益。Mansur 的更新是累加的，即你的每个回答时都应该考虑之前的所有更新。注意：某个 $X[i]$ 或者 $Y[i]$ 可能会被更新多次。\n\n对于 Mansur 的问题，实际的答案可能是一个非常大的数字，你只要给出实际答案模 $10^9+7$ 后的结果即可。", "inputFormat": "- 第 $1$ 行，一个整数 $N$，表示总共有 $N$ 年。\n- 第 $2$ 行，共 $N$ 个正整数 $X[0],\\cdots,X[N - 1]$，对于 $0\\le i \\le N-1$，$X[i]$ 表示 $i$ 年的繁殖系数。\n- 第 $3$ 行，共 $N$ 个正整数 $Y[0],\\cdots,Y[N - 1]$，对于 $0\\le i \\le N-1$，$Y[i]$ 表示 $i$ 年末出售一匹马的价格。\n- 第 $4$ 行，一个整数 $M$，表示更新次数。\n- 第 $5,\\cdots,M+4$ 行，每行 $3$ 个数字 $type$，$pos$，$val$ （$type=1$ 表示更改 $X[ pos ]$ 为 $val$，$type=2$ 表示更改 $Y[ pos ]$ 为 $val$）。", "outputFormat": "- 共 $M+1$ 行\n- 第 $1$ 行：一个整数表示初始状态下，Mansur 获得的最大收益模 $10^9+7$ 后的值。\n- 第 $2,\\cdots,M+1$ 行：每行一个整数，表示这次更新后 Mansur 获得的最大收益模 $10^9+7$ 后的值。", "hint": "对于 $100\\%$ 的数据，$1\\le N\\le 5\\times 10^5$，$0 \\le M \\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2015] horses", "background": "", "description": "Like his ancestors, Mansur enjoys breeding horses. He currently owns the largest horse ranch in Kazakhstan. It was not always like this: $N$ years ago, when Mansur was young, he only owned one horse, but he kept dreaming of becoming rich, and in the end his dream came true.\n\nNumber the years in chronological order from $0$ to $N-1$ (that is, year $N-1$ is the most recent year). Each year’s weather affects horse breeding. Mansur records a positive integer $X[i]$ as the breeding factor of year $i$. If there are $h$ horses at the beginning of year $i$, then there will be $h \\times X[i]$ horses at the end of that year.\n\nEach year, horses can only be sold at the end of the year. Mansur records a positive integer $Y[i]$ as the price for selling one horse at the end of year $i$. Mansur may sell any number of horses, and each horse is sold for $Y[i]$.\n\nNow, Mansur wants to know: over these $N$ years, if he always sells horses at the best time, what is the maximum total revenue he can obtain? You happen to be visiting Mansur’s home, so he asks you to help answer this question.\n\nMansur performed $M$ updates to the recorded arrays $X$ and $Y$. In each update, Mansur either changes one $X[i]$ or changes one $Y[i]$. After each update, he asks you again for the maximum revenue from selling horses. Mansur’s updates are cumulative, meaning each answer should take into account all previous updates. Note that some $X[i]$ or $Y[i]$ may be updated multiple times.\n\nThe real answer to Mansur’s question may be extremely large. You only need to output the real answer modulo $10^9+7$.", "inputFormat": "- Line $1$: An integer $N$, the total number of years.\n- Line $2$: $N$ positive integers $X[0],\\cdots,X[N - 1]$. For $0\\le i \\le N-1$, $X[i]$ is the breeding factor of year $i$.\n- Line $3$: $N$ positive integers $Y[0],\\cdots,Y[N - 1]$. For $0\\le i \\le N-1$, $Y[i]$ is the price of selling one horse at the end of year $i$.\n- Line $4$: An integer $M$, the number of updates.\n- Lines $5$ to $M+4$: Each line contains three numbers $type$, $pos$, $val$ ($type=1$ means changing $X[ pos ]$ to $val$, $type=2$ means changing $Y[ pos ]$ to $val$).", "outputFormat": "- A total of $M+1$ lines.\n- Line $1$: One integer, the maximum revenue in the initial state modulo $10^9+7$.\n- Lines $2$ to $M+1$: One integer per line, the maximum revenue after this update modulo $10^9+7$.", "hint": "Constraints: for $100\\%$ of the data, $1\\le N\\le 5\\times 10^5$, $0 \\le M \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2015] horses", "background": "", "description": "像他的祖先一样，Mansur 喜欢繁殖马匹。目前，他拥有哈萨克斯坦最大的马场。以前情况可不是这样，$N$ 年前 Mansur 年轻时，他只拥有一匹马，但他一直梦想着成为富豪，最终,他美梦成真。\n\n按照时间的先后顺序将年份编号为 $0$ 到 $N-1$（即 $N-1$ 年是最近的一年）。每年的天气会影响马匹的繁殖。Mansur 用一个正整数 $X[i]$ 记录第 $i$ 年的繁殖系数，如果第 $i$ 年开始时有 $h$ 匹马，那么这一年结束时会有 $h \\times X[i]$ 匹马。\n\n每年，只有年底的时候可以出售马匹。Mansur 用一个正整数 $Y[i]$ 记录第 $i$ 年末卖出一匹马的售价。Mansur 可以卖出任意多匹马，每匹售价均为 $Y[i]$。\n\n现在，Mansur 想知道如果在 $N$ 年中，他总能在最佳时间出售马匹，他能获得的最大收益是多少？你正好在 Mansur 家做客，所以他想请你帮他回答这个问题。\n\nMansur 对记录下的 $X$ 和 $Y$ 做了 $M$ 次更新，每次更新，Mansur 要么改变一个 $X[i]$，要么改变一个 $Y[i]$。每次更新后，他都会问你出售马匹能获得的最大收益。Mansur 的更新是累加的，即你的每个回答时都应该考虑之前的所有更新。注意：某个 $X[i]$ 或者 $Y[i]$ 可能会被更新多次。\n\n对于 Mansur 的问题，实际的答案可能是一个非常大的数字，你只要给出实际答案模 $10^9+7$ 后的结果即可。", "inputFormat": "- 第 $1$ 行，一个整数 $N$，表示总共有 $N$ 年。\n- 第 $2$ 行，共 $N$ 个正整数 $X[0],\\cdots,X[N - 1]$，对于 $0\\le i \\le N-1$，$X[i]$ 表示 $i$ 年的繁殖系数。\n- 第 $3$ 行，共 $N$ 个正整数 $Y[0],\\cdots,Y[N - 1]$，对于 $0\\le i \\le N-1$，$Y[i]$ 表示 $i$ 年末出售一匹马的价格。\n- 第 $4$ 行，一个整数 $M$，表示更新次数。\n- 第 $5,\\cdots,M+4$ 行，每行 $3$ 个数字 $type$，$pos$，$val$ （$type=1$ 表示更改 $X[ pos ]$ 为 $val$，$type=2$ 表示更改 $Y[ pos ]$ 为 $val$）。", "outputFormat": "- 共 $M+1$ 行\n- 第 $1$ 行：一个整数表示初始状态下，Mansur 获得的最大收益模 $10^9+7$ 后的值。\n- 第 $2,\\cdots,M+1$ 行：每行一个整数，表示这次更新后 Mansur 获得的最大收益模 $10^9+7$ 后的值。", "hint": "对于 $100\\%$ 的数据，$1\\le N\\le 5\\times 10^5$，$0 \\le M \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P5875", "type": "P", "difficulty": 5, "samples": [["6\n13 3 6 20 10 15\n0 0 0 1 1 2 2 1 0 0\n", "35\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384]}, "tags": ["2014", "IOI", "交互题"], "title": "[IOI 2014] friend 朋友", "background": "**这是一道交互题**", "description": "我们建立了一个由编号为 $0,\\cdots,n - 1$ 的 $n$ 个人组成的社交网络。网络中的有些对会成为朋友。如果 $x$ 号人成为 $y$ 号人的朋友，则 $y$ 号人同时也会成为 $x$ 号人的朋友。\n\n这些人将通过 $n$ 个阶段加入这个网络，阶段也编号为 $0$ 至 $n−1$。第 $i$ 号人在第 $i$ 个阶段加入。在阶段 $0$，$0$ 号人加入网络并成为唯一的人。此后 $n - 1$ 个阶段的各个阶段，都有一个人会被主持人加入到网络中，而这个主持人可以是已在网络中的任何一个人。在阶段 $i$ 中（$1\\le i\\le n−1$），该阶段的主持人可以用如下三种方式之一把第 $i$ 号人加入到网络中：\n\n- IAmYourFriend：将第 $i$ 号人仅变成主持人的朋友。\n- MyFriendsAreYourFriends：将第 $i$ 号人变成主持人当前的每一个朋友的朋友。 注意，这个方式不会将第 $i$ 号人变成主持人的朋友。\n- WeAreYourFriends：将第 $i$ 号人变成主持人的朋友，同时也变成主持人当前的每一个朋友的朋友。\n\n在建立此网络之后，我们想挑选一个调查的样本，也就是说要从网络中选择一组人。由于朋友之间通常拥有相似的兴趣，因此样本不应包含任何一对互为朋友的人。每个人都会有一个调查的可信度，表示为一个正整数，而我们想要找出一个可信度总和最大的样本。\n\n### 任务\n\n给定各阶段的描述以及每个人的可信度值，请找出一个可信度总和最大的样本。你只需要实现函数 `findSample`。\n\n* `findSample(n, confidence, host, protocol)`\n\t* $n$: 人数.\n\t* `confidence`: 大小为 $n$ 的数组；`confidence[i]` 表示第 $i$ 号人的可信度。\n\t* `host`: 大小为 $n$ 的数组；`host[i]` 表示阶段 i 的主持人。\n\t* `protocol`: 大小为 $n$ 的数组；`protocol[i]` 表示在阶段 （$0<i<n$） 所采用的方式的代码: `0` 代表 IAmYourFriend，`1` 代表 MyFriendsAreYourFriends，而 `2` 代表 WeAreYourFriends。\n\t* 由于在阶段 `0` 中没有主持人，因此 `host[0]` 和 `protocol[0]` 是没有被定义的，而且在你的程序中也不应访问它们。\n\n这个函数应该返回样本可信度总和的最大值。", "inputFormat": "以下为交互库的输入格式。\n\n第 $1$ 行：一个正整数 $n$，为人数。\n\n第 $2$ 行：共 $n$ 个整数 $\\mathrm{confidence}[0],\\ldots,\\mathrm{confidence}[n-1]$.\n\n第 $3$ 行：共 $2n-2$ 个整数 $\\mathrm{host}[1],\\mathrm{protocol}[1], \\mathrm{host}[2], \\mathrm{protocol}[2],\\cdots, \\mathrm{host}[n-1], \\mathrm{protocol}[n-1]$。", "outputFormat": "本题只支持 C++ 系列语言。\n\n你只能提交一个源文件实现上述的函数，其命名与接口需遵循下面的要求。**不需要添加额外的头文件**。\n\n`int findSample(int n, int confidence[], int host[], int protocol[]);`", "hint": "对于 $100\\%$ 的数据，$2 \\le n \\le 10^5$，$1 \\le \\mathrm{confidence}[i] \\le 10^6$。\n\n|**子任务**|**分值**|$n$|**可信度**|**采用的方式**|\n|:-:|:-:|:-:|:-:|:-:|\n|1|$11$|$n\\leq 10$|$1\\leq \\mathrm{confidence}\\leq 10^6$|全部三种方式|\n|2|$8$|$n\\leq 1000$|$1\\leq \\mathrm{confidence}\\leq 10^6$|只有 `MyFriendsAreYourFriends`|\n|3|$8$|$n\\leq 1000$|$1\\leq \\mathrm{confidence}\\leq 10^6$|只有 `WeAreYourFriends`|\n|4|$19$|$n\\leq 1000$|$1\\leq \\mathrm{confidence}\\leq 10^6$|只有 `IAmYourFriend`|\n|5|$23$|$n\\leq 1000$|所有可信度值均为 $1$|只有 `MyFriendsAreYourFriends` 和 `IAmYourFriend` 两种方式|\n|6|$31$|$n\\leq 10^5$|$1\\leq \\mathrm{confidence}\\leq 10^4$|全部三种方式|", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2014] friend", "background": "**This is an interactive problem.**", "description": "We build a social network consisting of $n$ people numbered $0,\\cdots,n - 1$. Some pairs of people in the network will become friends. If person $x$ becomes a friend of person $y$, then person $y$ will also become a friend of person $x$.\n\nThese people will join the network in $n$ stages, also numbered from $0$ to $n-1$. Person $i$ joins in stage $i$. In stage $0$, person $0$ joins the network and is the only person. After that, in each of the remaining $n - 1$ stages, one person will be added to the network by a host, and this host can be any person already in the network. In stage $i$ ($1\\le i\\le n−1$), the host can add person $i$ to the network using one of the following three methods:\n\n- IAmYourFriend: Make person $i$ become friends only with the host.\n- MyFriendsAreYourFriends: Make person $i$ become friends with each of the host's current friends. Note that this method does not make person $i$ become friends with the host.\n- WeAreYourFriends: Make person $i$ become friends with the host, and also become friends with each of the host's current friends.\n\nAfter building the network, we want to choose a survey sample, that is, select a group of people from the network. Since friends usually have similar interests, the sample should not contain any pair of people who are friends with each other. Each person has a survey credibility value, given as a positive integer, and we want to find a sample with the maximum total credibility.\n\n### Task\n\nGiven the description of each stage and the credibility value of each person, find a sample with the maximum total credibility. You only need to implement the function `findSample`.\n\n* `findSample(n, confidence, host, protocol)`\n\t* $n$: the number of people.\n\t* `confidence`: an array of size $n$; `confidence[i]` is the credibility of person $i$.\n\t* `host`: an array of size $n$; `host[i]` is the host of stage $i$.\n\t* `protocol`: an array of size $n$; `protocol[i]` is the code of the method used in stage ($0<i<n$): `0` means IAmYourFriend, `1` means MyFriendsAreYourFriends, and `2` means WeAreYourFriends.\n\t* Since there is no host in stage `0`, `host[0]` and `protocol[0]` are undefined, and your program must not access them.\n\nThis function should return the maximum possible total credibility of the sample.", "inputFormat": "Below is the input format for the interactive library.\n\nLine $1$: a positive integer $n$, the number of people.\n\nLine $2$: $n$ integers $\\mathrm{confidence}[0],\\ldots,\\mathrm{confidence}[n-1]$.\n\nLine $3$: $2n-2$ integers $\\mathrm{host}[1],\\mathrm{protocol}[1], \\mathrm{host}[2], \\mathrm{protocol}[2],\\cdots, \\mathrm{host}[n-1], \\mathrm{protocol}[n-1]$.", "outputFormat": "This problem only supports the C++ language series.\n\nYou can only submit one source file implementing the function above. The name and interface must follow the requirements below. **Do not add extra header files.**\n\n`int findSample(int n, int confidence[], int host[], int protocol[]);`", "hint": "For $100\\%$ of the testdata, $2 \\le n \\le 10^5$, $1 \\le \\mathrm{confidence}[i] \\le 10^6$.\n\n|**Subtask**|**Score**|$n$|**Credibility**|**Method used**|\n|:-:|:-:|:-:|:-:|:-:|\n|1|$11$|$n\\leq 10$|$1\\leq \\mathrm{confidence}\\leq 10^6$|all three methods|\n|2|$8$|$n\\leq 1000$|$1\\leq \\mathrm{confidence}\\leq 10^6$|only `MyFriendsAreYourFriends`|\n|3|$8$|$n\\leq 1000$|$1\\leq \\mathrm{confidence}\\leq 10^6$|only `WeAreYourFriends`|\n|4|$19$|$n\\leq 1000$|$1\\leq \\mathrm{confidence}\\leq 10^6$|only `IAmYourFriend`|\n|5|$23$|$n\\leq 1000$|all credibility values are $1$|only `MyFriendsAreYourFriends` and `IAmYourFriend`|\n|6|$31$|$n\\leq 10^5$|$1\\leq \\mathrm{confidence}\\leq 10^4$|all three methods|\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2014] friend 朋友", "background": "**这是一道交互题**", "description": "我们建立了一个由编号为 $0,\\cdots,n - 1$ 的 $n$ 个人组成的社交网络。网络中的有些对会成为朋友。如果 $x$ 号人成为 $y$ 号人的朋友，则 $y$ 号人同时也会成为 $x$ 号人的朋友。\n\n这些人将通过 $n$ 个阶段加入这个网络，阶段也编号为 $0$ 至 $n−1$。第 $i$ 号人在第 $i$ 个阶段加入。在阶段 $0$，$0$ 号人加入网络并成为唯一的人。此后 $n - 1$ 个阶段的各个阶段，都有一个人会被主持人加入到网络中，而这个主持人可以是已在网络中的任何一个人。在阶段 $i$ 中（$1\\le i\\le n−1$），该阶段的主持人可以用如下三种方式之一把第 $i$ 号人加入到网络中：\n\n- IAmYourFriend：将第 $i$ 号人仅变成主持人的朋友。\n- MyFriendsAreYourFriends：将第 $i$ 号人变成主持人当前的每一个朋友的朋友。 注意，这个方式不会将第 $i$ 号人变成主持人的朋友。\n- WeAreYourFriends：将第 $i$ 号人变成主持人的朋友，同时也变成主持人当前的每一个朋友的朋友。\n\n在建立此网络之后，我们想挑选一个调查的样本，也就是说要从网络中选择一组人。由于朋友之间通常拥有相似的兴趣，因此样本不应包含任何一对互为朋友的人。每个人都会有一个调查的可信度，表示为一个正整数，而我们想要找出一个可信度总和最大的样本。\n\n### 任务\n\n给定各阶段的描述以及每个人的可信度值，请找出一个可信度总和最大的样本。你只需要实现函数 `findSample`。\n\n* `findSample(n, confidence, host, protocol)`\n\t* $n$: 人数.\n\t* `confidence`: 大小为 $n$ 的数组；`confidence[i]` 表示第 $i$ 号人的可信度。\n\t* `host`: 大小为 $n$ 的数组；`host[i]` 表示阶段 i 的主持人。\n\t* `protocol`: 大小为 $n$ 的数组；`protocol[i]` 表示在阶段 （$0<i<n$） 所采用的方式的代码: `0` 代表 IAmYourFriend，`1` 代表 MyFriendsAreYourFriends，而 `2` 代表 WeAreYourFriends。\n\t* 由于在阶段 `0` 中没有主持人，因此 `host[0]` 和 `protocol[0]` 是没有被定义的，而且在你的程序中也不应访问它们。\n\n这个函数应该返回样本可信度总和的最大值。", "inputFormat": "以下为交互库的输入格式。\n\n第 $1$ 行：一个正整数 $n$，为人数。\n\n第 $2$ 行：共 $n$ 个整数 $\\mathrm{confidence}[0],\\ldots,\\mathrm{confidence}[n-1]$.\n\n第 $3$ 行：共 $2n-2$ 个整数 $\\mathrm{host}[1],\\mathrm{protocol}[1], \\mathrm{host}[2], \\mathrm{protocol}[2],\\cdots, \\mathrm{host}[n-1], \\mathrm{protocol}[n-1]$。", "outputFormat": "本题只支持 C++ 系列语言。\n\n你只能提交一个源文件实现上述的函数，其命名与接口需遵循下面的要求。**不需要添加额外的头文件**。\n\n`int findSample(int n, int confidence[], int host[], int protocol[]);`", "hint": "对于 $100\\%$ 的数据，$2 \\le n \\le 10^5$，$1 \\le \\mathrm{confidence}[i] \\le 10^6$。\n\n|**子任务**|**分值**|$n$|**可信度**|**采用的方式**|\n|:-:|:-:|:-:|:-:|:-:|\n|1|$11$|$n\\leq 10$|$1\\leq \\mathrm{confidence}\\leq 10^6$|全部三种方式|\n|2|$8$|$n\\leq 1000$|$1\\leq \\mathrm{confidence}\\leq 10^6$|只有 `MyFriendsAreYourFriends`|\n|3|$8$|$n\\leq 1000$|$1\\leq \\mathrm{confidence}\\leq 10^6$|只有 `WeAreYourFriends`|\n|4|$19$|$n\\leq 1000$|$1\\leq \\mathrm{confidence}\\leq 10^6$|只有 `IAmYourFriend`|\n|5|$23$|$n\\leq 1000$|所有可信度值均为 $1$|只有 `MyFriendsAreYourFriends` 和 `IAmYourFriend` 两种方式|\n|6|$31$|$n\\leq 10^5$|$1\\leq \\mathrm{confidence}\\leq 10^4$|全部三种方式|", "locale": "zh-CN"}}}
{"pid": "P5876", "type": "P", "difficulty": 2, "samples": [["3   \nabc \nefg \nijh", "a\ne\ni\n"], ["3\naac\naad\naae", "aac\naad\naae"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["NOI 导刊"], "title": "化简单词", "background": "", "description": "最近情报人员得到了一些经过加密的文章，每个单词都很长。破译人员想到先把单词化简一下，方法是把每个单词尽量取短些的前缀，但所取的前缀不能是其他单词的前缀。\n\n这个任务现在就交给你来完成。\n\n解释：“字符串 $\\text{S}_1$ 是 $\\text{S}_2$ 的前缀”是说把字符串 $\\text{S}_2$ 的后面去掉某些，只保留与 $\\text{S}_1$ 相同长度时，$\\text{S}_2$ 就与 $\\text{S}_1$ 完全相同。如：$\\texttt{abc}$ 是 $\\texttt{abcaade}$ 和 $\\texttt{abc}$ 的前缀，但不是 $\\texttt{abadc}$ 的前缀。\n", "inputFormat": "第一行一个整数 $N$，表示单词的个数。\n\n下面有 $N$ 行，每行一个单词。", "outputFormat": "共 $N$ 行，每行一个单词，对应上面的 $N$ 个单词化简后的单词。", "hint": "对于 $100\\%$ 的数据，$1 \\le N \\le 50$，每个单词长度不超过 $50$，并且都是由小写字母构成。\n\n保证所给单词没有一个单词是另一个单词的前缀。\n", "locale": "zh-CN", "translations": {"en": {"title": "Simplify Words", "background": "", "description": "Recently, intelligence officers obtained some encrypted articles, and every word is very long. The codebreakers want to simplify the words first. The method is to take, for each word, the shortest possible prefix, but the chosen prefix must not be a prefix of any other word.\n\nThis task is now assigned to you.\n\nExplanation: “String $\\text{S}_1$ is a prefix of $\\text{S}_2$” means that if you delete some characters from the end of string $\\text{S}_2$ and keep only the part with the same length as $\\text{S}_1$, then $\\text{S}_2$ becomes exactly the same as $\\text{S}_1$. For example, $\\texttt{abc}$ is a prefix of $\\texttt{abcaade}$ and $\\texttt{abc}$, but it is not a prefix of $\\texttt{abadc}$.", "inputFormat": "The first line contains an integer $N$, representing the number of words.\n\nThe following $N$ lines each contain one word.", "outputFormat": "Output $N$ lines, each containing one word, which is the simplified version of the corresponding word above.", "hint": "For $100\\%$ of the testdata, $1 \\le N \\le 50$, each word has length at most $50$, and all words consist of lowercase letters.\n\nIt is guaranteed that none of the given words is a prefix of another word.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "化简单词", "background": "", "description": "最近情报人员得到了一些经过加密的文章，每个单词都很长。破译人员想到先把单词化简一下，方法是把每个单词尽量取短些的前缀，但所取的前缀不能是其他单词的前缀。\n\n这个任务现在就交给你来完成。\n\n解释：“字符串 $\\text{S}_1$ 是 $\\text{S}_2$ 的前缀”是说把字符串 $\\text{S}_2$ 的后面去掉某些，只保留与 $\\text{S}_1$ 相同长度时，$\\text{S}_2$ 就与 $\\text{S}_1$ 完全相同。如：$\\texttt{abc}$ 是 $\\texttt{abcaade}$ 和 $\\texttt{abc}$ 的前缀，但不是 $\\texttt{abadc}$ 的前缀。\n", "inputFormat": "第一行一个整数 $N$，表示单词的个数。\n\n下面有 $N$ 行，每行一个单词。", "outputFormat": "共 $N$ 行，每行一个单词，对应上面的 $N$ 个单词化简后的单词。", "hint": "对于 $100\\%$ 的数据，$1 \\le N \\le 50$，每个单词长度不超过 $50$，并且都是由小写字母构成。\n\n保证所给单词没有一个单词是另一个单词的前缀。\n", "locale": "zh-CN"}}}
{"pid": "P5877", "type": "P", "difficulty": 3, "samples": [["3 5    \n1 1 1  \n1 1 2  \n0 2 2  \n1 3 1  \n1 2 1  \n", "1 \n1 \n2 \n3 \n2\n"], ["3 5\n1 1 2\n1 2 1\n1 3 2\n1 2 3\n1 2 2\n", "1\n2\n3\n4\n1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["并查集", "NOI 导刊"], "title": "棋盘游戏", "background": "", "description": "为了增强幼儿园小朋友的数数能力，小虎老师给了一个家庭游戏作业。让小虎那一块空的围棋盘，随机在一些方格中放些棋子（有黑白两种颜色），如果一个方格和它的上、下、左、右四个方格之一有相同颜色的棋子，则认为两个格子是相互连通的。这期间，要求小虎不断统计共有多少个连通块。\n\n如下图是一个 $5\\times 9$ 的一块棋盘，其中 `.` 表示空格，`*` 表示黑棋子，`@`表示白棋子。\n\n则有 $4$ 块连通子块。\n```\n.  .  .  .  .  .  .  .  .\n.  .  *  *  .  .  @  @  .\n.  *  *  @  @  .  @  @  .\n.  .  *  @  .  .  *  .  .\n.  .  .  .  .  .  .  .  .\n```\n\n哥哥大虎在一边看一边想，如果棋盘是 $N\\times N$ 的，共放了 $M$ 个棋子，如何使用计算机解决这个问题呢？", "inputFormat": "第一行两个整数：$N,M$。\n\n接下来有 $M$ 行，每行三个整数：$c, x, y$。分别表示依次放入棋子的颜色（$0$ 表示白色，$1$ 表示黑色）、要放入格子的横坐标和格子的纵坐标。\n", "outputFormat": "共 $M$ 行。第 $i$ 行一个整数，表示放入第 $i$ 个棋子后，当前有多少个棋子连通块。", "hint": "对于 $30\\%$ 数据：$1\\le N \\le 10$。\n\n对于 $60\\%$ 数据：$1\\le N\\le 100$。\n\n对于 $100\\%$ 数据：$1\\le N\\le 500$，$1\\le M \\le N \\times N$，$ 0 \\le c \\le 1$，$ 1\\le x, y \\le N$。", "locale": "zh-CN", "translations": {"en": {"title": "Board Game.", "background": "", "description": "To improve kindergarten kids’ counting skills, Teacher Xiaohu gave a family game homework. He asked Xiaohu to take an empty Go board and randomly place some pieces (in two colors: black and white) on some cells. If a cell and one of its four neighbors (up, down, left, right) both contain pieces of the same color, then the two cells are considered connected. During this process, Xiaohu must keep counting how many connected components there are in total.\n\nThe figure below shows a $5\\times 9$ board, where `.` means an empty cell, `*` means a black piece, and `@` means a white piece.\n\nThen there are $4$ connected components.\n```\n.  .  .  .  .  .  .  .  .\n.  .  *  *  .  .  @  @  .\n.  *  *  @  @  .  @  @  .\n.  .  *  @  .  .  *  .  .\n.  .  .  .  .  .  .  .  .\n```\n\nBig brother Dahu watched and thought: if the board is $N\\times N$ and a total of $M$ pieces are placed, how can we solve this problem using a computer?", "inputFormat": "The first line contains two integers: $N, M$.\n\nThe next $M$ lines each contain three integers: $c, x, y$. They represent, in order, the color of the piece to be placed ($0$ means white, $1$ means black), the row coordinate, and the column coordinate of the cell where it is placed.", "outputFormat": "Output $M$ lines in total. The $i$-th line contains one integer, which is the number of connected components of pieces after placing the $i$-th piece.", "hint": "For $30\\%$ of the testdata: $1\\le N \\le 10$.\n\nFor $60\\%$ of the testdata: $1\\le N\\le 100$.\n\nFor $100\\%$ of the testdata: $1\\le N\\le 500$, $1\\le M \\le N \\times N$, $ 0 \\le c \\le 1$, $ 1\\le x, y \\le N$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "棋盘游戏", "background": "", "description": "为了增强幼儿园小朋友的数数能力，小虎老师给了一个家庭游戏作业。让小虎那一块空的围棋盘，随机在一些方格中放些棋子（有黑白两种颜色），如果一个方格和它的上、下、左、右四个方格之一有相同颜色的棋子，则认为两个格子是相互连通的。这期间，要求小虎不断统计共有多少个连通块。\n\n如下图是一个 $5\\times 9$ 的一块棋盘，其中 `.` 表示空格，`*` 表示黑棋子，`@`表示白棋子。\n\n则有 $4$ 块连通子块。\n```\n.  .  .  .  .  .  .  .  .\n.  .  *  *  .  .  @  @  .\n.  *  *  @  @  .  @  @  .\n.  .  *  @  .  .  *  .  .\n.  .  .  .  .  .  .  .  .\n```\n\n哥哥大虎在一边看一边想，如果棋盘是 $N\\times N$ 的，共放了 $M$ 个棋子，如何使用计算机解决这个问题呢？", "inputFormat": "第一行两个整数：$N,M$。\n\n接下来有 $M$ 行，每行三个整数：$c, x, y$。分别表示依次放入棋子的颜色（$0$ 表示白色，$1$ 表示黑色）、要放入格子的横坐标和格子的纵坐标。\n", "outputFormat": "共 $M$ 行。第 $i$ 行一个整数，表示放入第 $i$ 个棋子后，当前有多少个棋子连通块。", "hint": "对于 $30\\%$ 数据：$1\\le N \\le 10$。\n\n对于 $60\\%$ 数据：$1\\le N\\le 100$。\n\n对于 $100\\%$ 数据：$1\\le N\\le 500$，$1\\le M \\le N \\times N$，$ 0 \\le c \\le 1$，$ 1\\le x, y \\le N$。", "locale": "zh-CN"}}}
{"pid": "P5878", "type": "P", "difficulty": 4, "samples": [["2 100\n10 8 10 10 13 11\n12 20 6 10 17 24\n", "5"], ["3 65\n10 5 7 10 13 14\n10 5 8 11 14 15\n10 5 9 12 15 16\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["NOI 导刊"], "title": "奖品", "background": "", "description": "学校刚开完运动会，准备为尽可能多的同学评奖，并为每个人颁发一份奖品。一份奖品包括 $N$ 个物品，如：$5$ 支铅笔、$10$ 本练习薄等。每份奖品完全一样。虽然学校的保管室里还有一些办去年运动会后剩余的物品。在商店里，每种物品都有很多，但是，只有两种包装：大盒或小盒，并且不拆开买。\n\n现在的问题是，充分利用这 $M$ 元钱，最多可准备多少分这样的奖品？\n", "inputFormat": "第一行两个整数：$N,M$。\n\n下面有 $N$ 行，每行有六个正整数 $x,y,sm,pm,sv,pv$，分别表示一种物品的相关数据：\n\n* $x$，一份奖品中，这种物品需要的件数。\n* $y$，这种物品去年剩余的件数。\n* $sm$，这种物品小包装的件数。\n* $pm$，这种物品小包装的一盒价格。\n* $sv$，这种物品大包装里的件数。\n* $pv$，这种物品大包装的一盒价格。\n", "outputFormat": "一个整数，最多可准备的礼品份数。", "hint": "对于全部的数据，满足：\n\n$1 \\le N \\le 100$，$1 \\le M \\le 10^5$。\n\n$10 \\le x, pm \\le 100$，$1 \\le y, sm \\le 100$，$sm < sv \\le 100$，$pm<pv\\le 100$。", "locale": "zh-CN", "translations": {"en": {"title": "Prizes", "background": "", "description": "The school has just finished its sports meeting and plans to give awards to as many students as possible, giving each person a prize. Each prize contains $N$ kinds of items, such as $5$ pencils, $10$ exercise books, and so on. Every prize is exactly the same. The school storeroom still has some items left over from last year’s sports meeting. In the store, there are plenty of each kind of item, but there are only two types of packaging: a large box or a small box, and you must buy whole boxes without opening them.\n\nNow the problem is: with this $M$ yuan, making full use of the money, what is the maximum number of such prizes that can be prepared?", "inputFormat": "The first line contains two integers: $N, M$.\n\nThen there are $N$ lines. Each line contains six positive integers $x, y, sm, pm, sv, pv$, describing one kind of item:\n\n- $x$: the number of this item needed in one prize.\n- $y$: the number of this item left over from last year.\n- $sm$: the number of this item in one small box.\n- $pm$: the price of one small box of this item.\n- $sv$: the number of this item in one large box.\n- $pv$: the price of one large box of this item.", "outputFormat": "Output one integer: the maximum number of prizes that can be prepared.", "hint": "For all testdata, it holds that:\n\n$1 \\le N \\le 100$, $1 \\le M \\le 10^5$.\n\n$10 \\le x, pm \\le 100$, $1 \\le y, sm \\le 100$, $sm < sv \\le 100$, $pm < pv \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "奖品", "background": "", "description": "学校刚开完运动会，准备为尽可能多的同学评奖，并为每个人颁发一份奖品。一份奖品包括 $N$ 个物品，如：$5$ 支铅笔、$10$ 本练习薄等。每份奖品完全一样。虽然学校的保管室里还有一些办去年运动会后剩余的物品。在商店里，每种物品都有很多，但是，只有两种包装：大盒或小盒，并且不拆开买。\n\n现在的问题是，充分利用这 $M$ 元钱，最多可准备多少分这样的奖品？\n", "inputFormat": "第一行两个整数：$N,M$。\n\n下面有 $N$ 行，每行有六个正整数 $x,y,sm,pm,sv,pv$，分别表示一种物品的相关数据：\n\n* $x$，一份奖品中，这种物品需要的件数。\n* $y$，这种物品去年剩余的件数。\n* $sm$，这种物品小包装的件数。\n* $pm$，这种物品小包装的一盒价格。\n* $sv$，这种物品大包装里的件数。\n* $pv$，这种物品大包装的一盒价格。\n", "outputFormat": "一个整数，最多可准备的礼品份数。", "hint": "对于全部的数据，满足：\n\n$1 \\le N \\le 100$，$1 \\le M \\le 10^5$。\n\n$10 \\le x, pm \\le 100$，$1 \\le y, sm \\le 100$，$sm < sv \\le 100$，$pm<pv\\le 100$。", "locale": "zh-CN"}}}
{"pid": "P5879", "type": "P", "difficulty": 4, "samples": [["2", "4"], ["3", "13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["NOI 导刊"], "title": "放棋子", "background": "", "description": "小虎刚刚上了幼儿园，老师让他做一个家庭作业：首先画 $3$ 行格子，第一行有三个格子，第二行有 $2$ 个格子，第三行有 $1$ 个格子。每行的格子从左到右可以放棋子，但要求除第一行外，每行放的棋子数不能超过上一行的棋子。第一行的棋子数不能为 $0$，但剩下行可以为空。玩了一会儿，小虎对哥哥大虎说：”这个作业有很多种摆放法，我想找到，但我不知道有多少种方案，你能帮助我吗？”\n\n大虎是学校信息学集训队的，立刻想到用计算机来解决这个问题，并很快有了解答：$13$。\n\n第二天他把问题拿到学校，并说如果第一行有 $N$ 个格子，第二行有 $N-1$ 个格子，……，第 $N$ 行有 $1$ 个格子，怎么办？现在请你一块来帮助他解决这个难题。", "inputFormat": "仅一行，一个正整数 $N$。", "outputFormat": "一行，方案总数。", "hint": "样例 1 说明：$N=2$ 时，有如下 $4$ 种摆放棋子法（`*` 表示棋子，`_` 表示空格）：\n|  方案数| 1 | 2 | 3 | 4 |\n| :----------- | :----------- | :----------- | :----------- | :----------- |\n| **第一行** | `*_` | `**` | `*_` | `**` |\n| **第二行** | `_` | `_` | `*` | `*` |\n\n\n对于 $30\\%$ 数据：$1\\le N\\le 12$。\n\n对于 $50\\%$ 数据：$1\\le N\\le 30$。\n\n对于 $100\\%$ 数据：$1\\le N\\le 100$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Placing Pieces", "background": "", "description": "Xiaohu has just started kindergarten. The teacher gave him homework: first draw $3$ rows of cells. The first row has $3$ cells, the second row has $2$ cells, and the third row has $1$ cell. In each row, pieces can be placed from left to right, but except for the first row, the number of pieces placed in each row cannot exceed the number of pieces in the previous row. The number of pieces in the first row cannot be $0$, but the remaining rows may be empty. After playing for a while, Xiaohu said to his older brother Dahu: “There are many ways to place the pieces for this homework. I want to find them, but I do not know how many arrangements there are. Can you help me?”\n\nDahu is in the school’s informatics training team, and he immediately thought of using a computer to solve this problem. He quickly got the answer: $13$.\n\nThe next day, he brought the problem to school and asked: what if the first row has $N$ cells, the second row has $N-1$ cells, …, and the $N$-th row has $1$ cell? Now please help him solve this difficult problem.", "inputFormat": "Only one line: a positive integer $N$.", "outputFormat": "One line: the total number of arrangements.", "hint": "Explanation for Sample 1: when $N=2$, there are the following $4$ ways to place pieces (`*` represents a piece, `_` represents an empty cell):\n|  Arrangement | 1 | 2 | 3 | 4 |\n| :----------- | :----------- | :----------- | :----------- | :----------- |\n| **First row** | `*_` | `**` | `*_` | `**` |\n| **Second row** | `_` | `_` | `*` | `*` |\n\nConstraints:\n\nFor $30\\%$ of the testdata: $1\\le N\\le 12$.\n\nFor $50\\%$ of the testdata: $1\\le N\\le 30$.\n\nFor $100\\%$ of the testdata: $1\\le N\\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "放棋子", "background": "", "description": "小虎刚刚上了幼儿园，老师让他做一个家庭作业：首先画 $3$ 行格子，第一行有三个格子，第二行有 $2$ 个格子，第三行有 $1$ 个格子。每行的格子从左到右可以放棋子，但要求除第一行外，每行放的棋子数不能超过上一行的棋子。第一行的棋子数不能为 $0$，但剩下行可以为空。玩了一会儿，小虎对哥哥大虎说：”这个作业有很多种摆放法，我想找到，但我不知道有多少种方案，你能帮助我吗？”\n\n大虎是学校信息学集训队的，立刻想到用计算机来解决这个问题，并很快有了解答：$13$。\n\n第二天他把问题拿到学校，并说如果第一行有 $N$ 个格子，第二行有 $N-1$ 个格子，……，第 $N$ 行有 $1$ 个格子，怎么办？现在请你一块来帮助他解决这个难题。", "inputFormat": "仅一行，一个正整数 $N$。", "outputFormat": "一行，方案总数。", "hint": "样例 1 说明：$N=2$ 时，有如下 $4$ 种摆放棋子法（`*` 表示棋子，`_` 表示空格）：\n|  方案数| 1 | 2 | 3 | 4 |\n| :----------- | :----------- | :----------- | :----------- | :----------- |\n| **第一行** | `*_` | `**` | `*_` | `**` |\n| **第二行** | `_` | `_` | `*` | `*` |\n\n\n对于 $30\\%$ 数据：$1\\le N\\le 12$。\n\n对于 $50\\%$ 数据：$1\\le N\\le 30$。\n\n对于 $100\\%$ 数据：$1\\le N\\le 100$。\n", "locale": "zh-CN"}}}
{"pid": "P5880", "type": "P", "difficulty": 4, "samples": [["4\n1 1 1 1\n", "28"], ["3\n1 2 3\n", "68"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000]}, "tags": ["O2优化", "组合数学", "排列组合"], "title": "【地理】划分", "background": "小蒟建立了一个城市，$\\texttt{TA}$ 凭借优（cu）异（bi）的人文地理素养，管理着城市并进行规划。", "description": "对于一座新建的城市，可以将其视为一片连通的区域。\n\n现在，小蒟需要建造一些道路，将城市分为若干片互不连通的区域。\n\n首先，小蒟要建造 $a_1$ 条主干道。主干道是一条贯通整个城市的直线。\n\n接着，小蒟要建造 $a_2$ 个环岛。环岛是一条首尾相接的圆形道路。\n\n然后，小蒟要建造一些道路网络。这些道路网络包括 $a_3$ 条正三角形道路（即三条道路连成一个封闭的三角形），$a_4$ 条正四边形道路……$a_n$ 条正 $n$ 边形道路。\n\n小蒟希望用这些道路将城市划分为尽可能多片互不连通区域。可是他不会计算最多能划分成为多少个区域，所以他只能来求助你。\n\n由于最后的答案可能很大很大，你只需要输出答案对 $10^9+7$ 取模的值。", "inputFormat": "第一行，一个正整数 $n$，代表小蒟的计划中边数最多的道路网络是几边形。\n\n第二行，$n$ 个整数，为 $a_{1\\dots n}$。\n", "outputFormat": "一行一个整数，表示答案对 $10^9+7$ 取模后的值。", "hint": "#### 样例解释#1\n\n如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ntmr3tgn.png)\n\n#### 数据范围\n\n对于 $20\\%$ 的数据：$1\\le n \\le 10^3$，$0 \\le a_i \\le 100$。\n\n对于 $100\\%$ 的数据：$1\\le n \\le 3 \\times 10^6$，$0 \\le a_i \\le 10^3$。\n\n**注意内存限制，你的 UKE 很有可能就是 MLE**。\n\n**若 $n=1$ 则只存在直线道路，若 $n=2$ 则只存在直线道路和圆形道路。**", "locale": "zh-CN", "translations": {"en": {"title": "[Geography] Partition", "background": "Xiao Ju built a city. With excellent (and “cheating-level”) human geography skills, $\\texttt{TA}$ manages and plans the city.", "description": "For a newly built city, we can treat it as one connected region.\n\nNow, Xiao Ju needs to build some roads to divide the city into several regions that are disconnected from each other.\n\nFirst, Xiao Ju will build $a_1$ trunk roads. A trunk road is a straight line that goes through the entire city.\n\nNext, Xiao Ju will build $a_2$ roundabouts. A roundabout is a circular road whose start and end connect together.\n\nThen, Xiao Ju will build some road networks. These road networks include $a_3$ regular triangle roads (that is, three roads form a closed triangle), $a_4$ regular quadrilateral roads, $\\ldots$, and $a_n$ regular $n$-gon roads.\n\nXiao Ju wants to use these roads to partition the city into as many disconnected regions as possible. But he cannot compute the maximum number of regions, so he asks you for help.\n\nSince the final answer may be extremely large, you only need to output the answer modulo $10^9+7$.", "inputFormat": "The first line contains a positive integer $n$, meaning that in Xiao Ju’s plan, the road network with the largest number of sides is an $n$-gon.\n\nThe second line contains $n$ integers, which are $a_{1\\dots n}$.", "outputFormat": "Output one integer per line, the answer modulo $10^9+7$.", "hint": "#### Sample Explanation #1\n\nAs shown in the figure below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ntmr3tgn.png)\n\n#### Constraints\n\nFor $20\\%$ of the testdata: $1\\le n \\le 10^3$, $0 \\le a_i \\le 100$.\n\nFor $100\\%$ of the testdata: $1\\le n \\le 3 \\times 10^6$, $0 \\le a_i \\le 10^3$.\n\n**Note the memory limit: your UKE is very likely to get MLE**.\n\n**If $n=1$, then only straight roads exist. If $n=2$, then only straight roads and circular roads exist.**\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【地理】划分", "background": "小蒟建立了一个城市，$\\texttt{TA}$ 凭借优（cu）异（bi）的人文地理素养，管理着城市并进行规划。", "description": "对于一座新建的城市，可以将其视为一片连通的区域。\n\n现在，小蒟需要建造一些道路，将城市分为若干片互不连通的区域。\n\n首先，小蒟要建造 $a_1$ 条主干道。主干道是一条贯通整个城市的直线。\n\n接着，小蒟要建造 $a_2$ 个环岛。环岛是一条首尾相接的圆形道路。\n\n然后，小蒟要建造一些道路网络。这些道路网络包括 $a_3$ 条正三角形道路（即三条道路连成一个封闭的三角形），$a_4$ 条正四边形道路……$a_n$ 条正 $n$ 边形道路。\n\n小蒟希望用这些道路将城市划分为尽可能多片互不连通区域。可是他不会计算最多能划分成为多少个区域，所以他只能来求助你。\n\n由于最后的答案可能很大很大，你只需要输出答案对 $10^9+7$ 取模的值。", "inputFormat": "第一行，一个正整数 $n$，代表小蒟的计划中边数最多的道路网络是几边形。\n\n第二行，$n$ 个整数，为 $a_{1\\dots n}$。\n", "outputFormat": "一行一个整数，表示答案对 $10^9+7$ 取模后的值。", "hint": "#### 样例解释#1\n\n如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ntmr3tgn.png)\n\n#### 数据范围\n\n对于 $20\\%$ 的数据：$1\\le n \\le 10^3$，$0 \\le a_i \\le 100$。\n\n对于 $100\\%$ 的数据：$1\\le n \\le 3 \\times 10^6$，$0 \\le a_i \\le 10^3$。\n\n**注意内存限制，你的 UKE 很有可能就是 MLE**。\n\n**若 $n=1$ 则只存在直线道路，若 $n=2$ 则只存在直线道路和圆形道路。**", "locale": "zh-CN"}}}
{"pid": "P5881", "type": "P", "difficulty": 6, "samples": [["5 5\n36 72 4 9 16\n2 4 6 8 10\n2 3 4 5 6\n", "3 5\n4 7\n4 7\n4 7\n5 8"]], "limits": {"time": [1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "并查集", "O2优化", "素数判断,质数,筛法"], "title": "【化学】实验", "background": "小 Z 紧张地坐在了一张化学实验桌前，进行着化学实验。\n\n教室里又传来了一阵哀叹声：\n\n我…我好像又错了…我能再试一次吗?", "description": "在她的面前，摆放着 $n$ 个试管。试管里装着不明液体。对于每种不明液体，有 $2$ 个已知的化学属性：$a$ 和 $b$。第 $i$ 种液体的两个属性值分别为 $a_i$ 和 $b_i$。\n\n现在，老师给她布置了 $m$ 个实验。\n\n对于每一次实验，有一个参照量 $x$（第 $i$ 次实验的参照量记作 $x_i$）。她需要把不明液体分成尽可能多的组，且满足：任意两种不同组的液体$i$和$j$， $\\operatorname{gcsd(a_i,a_j)}$ 都不能大于 $x^2$。\n\n其中 $\\operatorname{gcsd}$ 代表他们的最大公约平方数。$k$是两个数的公约平方数，当且仅当满足以下两个条件：\n\n- $k$ 为这两个数的公约数；\n\n- $k$ 为完全平方数。\n\n而最大公约平方数 $\\operatorname{gcsd}$ 为所有满足条件的 $k$ 中的最大者。\n\n形象的说， $\\operatorname{gcsd}$ 可以理解成两个数的最大公约数的算术平方根的整数因式部分的平方。\n\n例如：\n\n求 $\\operatorname{gcsd(24,64)}$，就是先求出 $24,64$ 的最大公约数，是 $8$ ，然后 $\\sqrt 8=2\\sqrt 2$，其整数因式是 $2$，所以 $\\operatorname{gcsd(24,64)}=2^2=4$。\n\n她还需要在分组数最多的情况下，使自己的实验得分最大。\n\n实验得分的定义：对于每一种试剂，定义其得分 $c_i$ 为 $b_i$ 分解质因数之后最大的**指数**。\n\n例如：$b_i=12=2^2\\times 3^1$，$c_i=\\max\\{2,1\\}=2$。\n\n$b_i=90=2^1\\times 3^2\\times 5^1$，$c_i=\\max\\{1,2,1\\}=2$。\n\n而实验得分即为所有组内的 $c_i$ 的最大值之和。\n\n当然，她的 $IQ$ 并不高，所以需要请求你的帮助。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数 $a_{1\\dots n}$。\n\n第三行 $n$ 个整数 $b_{1\\dots n}$。\n\n第四行 $m$ 个整数 $x_{1\\dots m}$。", "outputFormat": "共 $m$ 行，对于第 $i$ 行，输出 $2$ 个整数：第 $i$ 次试验的组数和实验得分。", "hint": "#### 样例解释 #1\n\n$b_1=2=2^1,c_1=1$。\n\n$b_2=4=2^2,c_2=2$。\n\n$b_3=6=2^1\\times 3^1,c_3=\\max\\{1,1\\}=1$。\n\n$b_4=8=2^3,c_4=3$。\n\n$b_5=10=2^1\\times 5^1,c_5=\\max\\{1,1\\}=1$。\n\n当 $x=2$ 时，可分为三组：$\\{1,2,4\\},\\{3\\},\\{5\\}$。\n\n实验得分为$\\max\\{1,2,3\\}+\\max\\{1\\}+\\max\\{1\\}=5$。\n\n----------\n\n#### 数据范围\n\n**「本题采用捆绑测试」**\n\n| subtask | $n\\le$ | $m\\le$ | $a_i \\le$ | $b_i\\le$ | $x \\le$ | 分值 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |:-----------:|\n| $1$ | $4$ | $6$ | $100$ | $4 \\times 10^4$ | $100$ | $5$ |\n| $2$ | $8$ | $7$ | $20$ | $10^3$ | $10$ | $5$ |\n| $3$ |$20$ | $30$ | $50$ | $8 \\times 10^3$ | $100$ | $10$ |\n| $4$ |$100$ | $60$ | $100$ | $4 \\times 10^4$ | $10^3$ | $10$ |\n| $5$ |$5 \\times 10^3$ | $110$ |  $10^3$| $10^5$ | $4 \\times 10^3$ | $10$ |\n| $6$ |$2 \\times 10^4$ | $250$ | $3 \\times 10^3$ | $10^6$ | $3 \\times 10^3$ | $10$ |\n| $7$ |$ 5 \\times 10^4$| $10^3$ | $10^4$ | $2 \\times 10^7$ | $1.5 \\times 10^4$ | $15$ |\n| $8$ |$10^5$  | $8 \\times 10^3$ | $2 \\times 10^4$ | $2 \\times 10^7$ | $2.2 \\times 10^4$ | $15$ |\n| $9$ |$2 \\times 10^5$  | $2 \\times 10^5$ | $4 \\times 10^4$ | $2 \\times 10^7$ | $3 \\times 10^4$ | $20$ |\n\n\n对于 $100\\%$ 的数据：\n\n$1 \\le n,m \\le 2\\times 10^5$，$2 \\le a_i \\le 4\\times 10^4$，$2 \\le b_i \\le 2\\times 10^7$，$2 \\le x \\le 3\\times 10^4$。\n\n我$\\dots$我好像又错了$\\dots$我能再试一次吗?", "locale": "zh-CN", "translations": {"en": {"title": "[Chemistry] Experiment", "background": "Xiao Z sat nervously in front of a chemistry lab table, doing a chemistry experiment.\n\nA sigh came from the classroom again:\n\nI... I think I made a mistake again... Can I try one more time?", "description": "In front of her, there are $n$ test tubes. Each test tube contains an unknown liquid. For each kind of unknown liquid, there are $2$ known chemical attributes: $a$ and $b$. The two attribute values of the $i$-th liquid are $a_i$ and $b_i$.\n\nNow, the teacher assigns her $m$ experiments.\n\nFor each experiment, there is a reference value $x$ (the reference value of the $i$-th experiment is denoted as $x_i$). She needs to divide the unknown liquids into as many groups as possible, such that: for any two liquids $i$ and $j$ in different groups, $\\operatorname{gcsd(a_i,a_j)}$ must not be greater than $x^2$.\n\nHere, $\\operatorname{gcsd}$ denotes the greatest common square divisor. $k$ is a common square divisor of two numbers if and only if it satisfies both of the following:\n\n- $k$ is a common divisor of the two numbers;\n- $k$ is a perfect square.\n\nThe greatest common square divisor $\\operatorname{gcsd}$ is the maximum $k$ among all $k$ that satisfy the conditions.\n\nIntuitively, $\\operatorname{gcsd}$ can be understood as: take the greatest common divisor of the two numbers, take its square root, keep only the integer factor part, and then square it back.\n\nFor example:\n\nTo compute $\\operatorname{gcsd(24,64)}$, first compute the greatest common divisor of $24$ and $64$, which is $8$. Then $\\sqrt 8=2\\sqrt 2$. Its integer factor is $2$, so $\\operatorname{gcsd(24,64)}=2^2=4$.\n\nShe also needs, under the condition that the number of groups is maximized, to maximize her experiment score.\n\nDefinition of the experiment score: for each reagent, define its score $c_i$ as the largest **exponent** in the prime factorization of $b_i$.\n\nFor example: $b_i=12=2^2\\times 3^1$, so $c_i=\\max\\{2,1\\}=2$.\n\n$b_i=90=2^1\\times 3^2\\times 5^1$, so $c_i=\\max\\{1,2,1\\}=2$.\n\nThe experiment score is the sum, over all groups, of the maximum $c_i$ within each group.\n\nOf course, her $IQ$ is not very high, so she needs to ask for your help.", "inputFormat": "The first line contains two integers $n,m$.\n\nThe second line contains $n$ integers $a_{1\\dots n}$.\n\nThe third line contains $n$ integers $b_{1\\dots n}$.\n\nThe fourth line contains $m$ integers $x_{1\\dots m}$.", "outputFormat": "Output $m$ lines. For the $i$-th line, output $2$ integers: the number of groups and the experiment score for the $i$-th experiment.", "hint": "#### Sample Explanation #1\n\n$b_1=2=2^1,c_1=1$.\n\n$b_2=4=2^2,c_2=2$.\n\n$b_3=6=2^1\\times 3^1,c_3=\\max\\{1,1\\}=1$.\n\n$b_4=8=2^3,c_4=3$.\n\n$b_5=10=2^1\\times 5^1,c_5=\\max\\{1,1\\}=1$.\n\nWhen $x=2$, it can be divided into three groups: $\\{1,2,4\\},\\{3\\},\\{5\\}$.\n\nThe experiment score is $\\max\\{1,2,3\\}+\\max\\{1\\}+\\max\\{1\\}=5$.\n\n----------\n\n#### Constraints\n\n**\"This problem uses bundled testdata.\"**\n\n| subtask | $n\\le$ | $m\\le$ | $a_i \\le$ | $b_i\\le$ | $x \\le$ | Score |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |:-----------:|\n| $1$ | $4$ | $6$ | $100$ | $4 \\times 10^4$ | $100$ | $5$ |\n| $2$ | $8$ | $7$ | $20$ | $10^3$ | $10$ | $5$ |\n| $3$ |$20$ | $30$ | $50$ | $8 \\times 10^3$ | $100$ | $10$ |\n| $4$ |$100$ | $60$ | $100$ | $4 \\times 10^4$ | $10^3$ | $10$ |\n| $5$ |$5 \\times 10^3$ | $110$ |  $10^3$| $10^5$ | $4 \\times 10^3$ | $10$ |\n| $6$ |$2 \\times 10^4$ | $250$ | $3 \\times 10^3$ | $10^6$ | $3 \\times 10^3$ | $10$ |\n| $7$ |$ 5 \\times 10^4$| $10^3$ | $10^4$ | $2 \\times 10^7$ | $1.5 \\times 10^4$ | $15$ |\n| $8$ |$10^5$  | $8 \\times 10^3$ | $2 \\times 10^4$ | $2 \\times 10^7$ | $2.2 \\times 10^4$ | $15$ |\n| $9$ |$2 \\times 10^5$  | $2 \\times 10^5$ | $4 \\times 10^4$ | $2 \\times 10^7$ | $3 \\times 10^4$ | $20$ |\n\nFor $100\\%$ of the data:\n\n$1 \\le n,m \\le 2\\times 10^5$, $2 \\le a_i \\le 4\\times 10^4$, $2 \\le b_i \\le 2\\times 10^7$, $2 \\le x \\le 3\\times 10^4$.\n\nI... I think I made a mistake again... Can I try one more time?\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【化学】实验", "background": "小 Z 紧张地坐在了一张化学实验桌前，进行着化学实验。\n\n教室里又传来了一阵哀叹声：\n\n我…我好像又错了…我能再试一次吗?", "description": "在她的面前，摆放着 $n$ 个试管。试管里装着不明液体。对于每种不明液体，有 $2$ 个已知的化学属性：$a$ 和 $b$。第 $i$ 种液体的两个属性值分别为 $a_i$ 和 $b_i$。\n\n现在，老师给她布置了 $m$ 个实验。\n\n对于每一次实验，有一个参照量 $x$（第 $i$ 次实验的参照量记作 $x_i$）。她需要把不明液体分成尽可能多的组，且满足：任意两种不同组的液体$i$和$j$， $\\operatorname{gcsd(a_i,a_j)}$ 都不能大于 $x^2$。\n\n其中 $\\operatorname{gcsd}$ 代表他们的最大公约平方数。$k$是两个数的公约平方数，当且仅当满足以下两个条件：\n\n- $k$ 为这两个数的公约数；\n\n- $k$ 为完全平方数。\n\n而最大公约平方数 $\\operatorname{gcsd}$ 为所有满足条件的 $k$ 中的最大者。\n\n形象的说， $\\operatorname{gcsd}$ 可以理解成两个数的最大公约数的算术平方根的整数因式部分的平方。\n\n例如：\n\n求 $\\operatorname{gcsd(24,64)}$，就是先求出 $24,64$ 的最大公约数，是 $8$ ，然后 $\\sqrt 8=2\\sqrt 2$，其整数因式是 $2$，所以 $\\operatorname{gcsd(24,64)}=2^2=4$。\n\n她还需要在分组数最多的情况下，使自己的实验得分最大。\n\n实验得分的定义：对于每一种试剂，定义其得分 $c_i$ 为 $b_i$ 分解质因数之后最大的**指数**。\n\n例如：$b_i=12=2^2\\times 3^1$，$c_i=\\max\\{2,1\\}=2$。\n\n$b_i=90=2^1\\times 3^2\\times 5^1$，$c_i=\\max\\{1,2,1\\}=2$。\n\n而实验得分即为所有组内的 $c_i$ 的最大值之和。\n\n当然，她的 $IQ$ 并不高，所以需要请求你的帮助。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数 $a_{1\\dots n}$。\n\n第三行 $n$ 个整数 $b_{1\\dots n}$。\n\n第四行 $m$ 个整数 $x_{1\\dots m}$。", "outputFormat": "共 $m$ 行，对于第 $i$ 行，输出 $2$ 个整数：第 $i$ 次试验的组数和实验得分。", "hint": "#### 样例解释 #1\n\n$b_1=2=2^1,c_1=1$。\n\n$b_2=4=2^2,c_2=2$。\n\n$b_3=6=2^1\\times 3^1,c_3=\\max\\{1,1\\}=1$。\n\n$b_4=8=2^3,c_4=3$。\n\n$b_5=10=2^1\\times 5^1,c_5=\\max\\{1,1\\}=1$。\n\n当 $x=2$ 时，可分为三组：$\\{1,2,4\\},\\{3\\},\\{5\\}$。\n\n实验得分为$\\max\\{1,2,3\\}+\\max\\{1\\}+\\max\\{1\\}=5$。\n\n----------\n\n#### 数据范围\n\n**「本题采用捆绑测试」**\n\n| subtask | $n\\le$ | $m\\le$ | $a_i \\le$ | $b_i\\le$ | $x \\le$ | 分值 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |:-----------:|\n| $1$ | $4$ | $6$ | $100$ | $4 \\times 10^4$ | $100$ | $5$ |\n| $2$ | $8$ | $7$ | $20$ | $10^3$ | $10$ | $5$ |\n| $3$ |$20$ | $30$ | $50$ | $8 \\times 10^3$ | $100$ | $10$ |\n| $4$ |$100$ | $60$ | $100$ | $4 \\times 10^4$ | $10^3$ | $10$ |\n| $5$ |$5 \\times 10^3$ | $110$ |  $10^3$| $10^5$ | $4 \\times 10^3$ | $10$ |\n| $6$ |$2 \\times 10^4$ | $250$ | $3 \\times 10^3$ | $10^6$ | $3 \\times 10^3$ | $10$ |\n| $7$ |$ 5 \\times 10^4$| $10^3$ | $10^4$ | $2 \\times 10^7$ | $1.5 \\times 10^4$ | $15$ |\n| $8$ |$10^5$  | $8 \\times 10^3$ | $2 \\times 10^4$ | $2 \\times 10^7$ | $2.2 \\times 10^4$ | $15$ |\n| $9$ |$2 \\times 10^5$  | $2 \\times 10^5$ | $4 \\times 10^4$ | $2 \\times 10^7$ | $3 \\times 10^4$ | $20$ |\n\n\n对于 $100\\%$ 的数据：\n\n$1 \\le n,m \\le 2\\times 10^5$，$2 \\le a_i \\le 4\\times 10^4$，$2 \\le b_i \\le 2\\times 10^7$，$2 \\le x \\le 3\\times 10^4$。\n\n我$\\dots$我好像又错了$\\dots$我能再试一次吗?", "locale": "zh-CN"}}}
{"pid": "P5882", "type": "P", "difficulty": 5, "samples": [["5 5\n1\n2\n3\n4\n5\n1 2 2 0.7\n3 4 2 0.9\n1 3 1 1.1\n2 4 1 1.3\n4 5 10 2\n", "4.762887\n8.621053\n9.378947\n67.237113\n0.000000\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2015", "Special Judge", "CTSC/CTS"], "title": "[CTSC2015] misc", "background": "", "description": "小强和 B 君是好朋友。 \n\n小强除了 B 君还有很多好朋友，比如洁妹。 \n\nB 君除了小强也还有很多好朋友，比如R君。他们还有很多共同的好朋友，比如小花，葱娘和其他 $3$ 个人。 \n\nB 君发现，人与人之间的关系可以看成是一个无向图，每个人看成一个点，人与人之间的关系看成一条边。 \n\n不同的人在社会中的号召力不一样，我们用 $a_i$ 来表示第 $i$ 个人的号召力。 \n\n人与人之间的关系也各不相同，可能非常友好，可能只是泛泛之交；可能天天腻在一起，可能一年才联系一次。为此，我们用长度边权 $b_j$ 来刻画第 $j$ 条边对应的两个用户的亲密程度，长度约小，双方就越亲密；同时，我们用宽度边权 $c_j$ 来刻画第 $j$ 条边对应的两个用户的交流频率，宽度越大，两个人沟通的频率也就越高。\n\n一条路径的长度指的是这条路径上的所有边的长度边权之和，一条路径的宽度指的是这条路径上的所有边的宽度边权的乘积。 \n\n当两个人 $s$ 和 $t$ 想要交流的时候，他们会选择长度最短的路径来交流。由于最短路可能有多个，我们称 $s$ 到 $t$ 的最短路的宽度为 $\\sigma_{st}$，是所有 $s$ 到 $t$ 的长度最短的路径的宽度和。同时，我们用 $\\sigma_{st} (v)$ 表示所有从 $s$ 到 $t$，且经过 $v$ 的长度最短的路径的宽度和，即 $v$ 对 $s$,$t$ 的影响力。 \n一个人 $v$ 在图中的传播力 $R(v)$ 可以被定义为如下函数： \n\n $$R(v)=\\sum\\limits_{s \\ne v \\ne t} \\frac{a_s a_t \\sigma_{st}(v)}{\\sigma_{st}}$$\n\n即对图中所有不包含 $v$ 的点对，分别计算 $v$ 对该点对的影响力除以该点对的最短路的宽度，再乘上这个点对中两个点的号召力，最后将所有点对的计算结果加和得到节点在图中的传播力。\n \nB 君想快速知道所有节点在图中的传播力。当他去问小强的时候，小强说：“我有一个绝妙的做法，可惜题面太短，写不下。” \n\n你知道怎么做吗？ ", "inputFormat": "第一行包含 $2$ 个正整数 $n$,$m$，分别表示图的点数和边数。 \n\n接下来 $n$ 行中的第 $i$ 行有 $1$ 个非负整数 $a_i$，表示第 $i$ 个人的号召力。 \n接下来 $m$ 行中的第 $j$ 行有 $3$ 个整数 $x_j$,$y_j$,$b_j$ 和一个实数 $c_j$ ，表示点 $x_j$ 和点 $y_j$ 之间有一条长度边权为 $b_j$，宽度边权为 $c_j$ 的边。 ", "outputFormat": "共 $n$ 行，每行一个实数 $R(i)$，表示第 $i$ 个点在图中的传播力。 ", "hint": "**评分标准**\n\n我们会将输出文件的每个数与参考答案进行比较，如果该数与参考答案的相对误差或绝对误差不超过 $10^{-6}$，则判定该数正确。对于参考答案为 $0$ 的数，必须满足绝对误差不超过 $10^{-6}$ 才判定为正确。 \n\n如果输出正确数的个数为 $q$，那么你在该测试点上的得分是 $\\left\\lfloor\\ 5(\\dfrac{q}{n})^7 \\right\\rfloor$ \n\n**数据规模和约定** \n\n对于测试点 $1$,$2$,$3$,$4$，有 $n \\le 100$。 \n\n对于测试点 $5$,$6$,$7$,$8$，所有 $b_j=1$。 \n\n对于测试点 $9$,$10$,$11$,$12$，有 $m=n-1$。 \n\n对于测试点 $1$,$3$,$5$,$7$,$9$,$11$,$13$,$15$,$17$,$19$，所有 $a_i=1$。 \n\n对于测试点 $1$,$2$,$5$,$6$,$9$,$10$,$13$,$14$,$17$,$18$，所有 $c_j=1$。 \n\n对于所有的数据，有 $n \\le 1000$，$m \\le 4 \\times 10^3$，$0<a_j \\le 255$，$0<b_j \\le 15$，$0.5 \\le c_j \\le 2$，$c_j$ 的小数部分最多 $12$ 位。数据保证图是连通的。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2015] misc", "background": "", "description": "Xiaoqiang and Mr. B are good friends.\n\nBesides Mr. B, Xiaoqiang also has many good friends, such as Jie Mei.\n\nBesides Xiaoqiang, Mr. B also has many good friends, such as Mr. R. They also have many mutual friends, such as Xiaohua, Cong Niang, and another $3$ people.\n\nMr. B realized that relationships between people can be viewed as an undirected graph: each person is a vertex, and each relationship is an edge.\n\nDifferent people have different influence in society. Let $a_i$ denote the influence of the $i$-th person.\n\nRelationships between people also vary: they may be very close, or just casual acquaintances; they may stick together every day, or contact only once a year. Therefore, we use a length edge weight $b_j$ to describe the closeness of the two users connected by the $j$-th edge: the smaller the length, the closer they are. At the same time, we use a width edge weight $c_j$ to describe the communication frequency of the two users connected by the $j$-th edge: the larger the width, the more frequently they communicate.\n\nThe length of a path is the sum of the length edge weights of all edges on the path. The width of a path is the product of the width edge weights of all edges on the path.\n\nWhen two people $s$ and $t$ want to communicate, they will choose a shortest path (in terms of length). Since there may be multiple shortest paths, we define the width of the shortest paths from $s$ to $t$ as $\\sigma_{st}$, which is the sum of the widths of all shortest (minimum-length) paths from $s$ to $t$. Also, let $\\sigma_{st}(v)$ denote the sum of the widths of all shortest paths from $s$ to $t$ that pass through $v$, i.e., the influence of $v$ on $s,t$.\n\nThe spreading power $R(v)$ of a person $v$ in the graph is defined as:\n\n$$R(v)=\\sum\\limits_{s \\ne v \\ne t} \\frac{a_s a_t \\sigma_{st}(v)}{\\sigma_{st}}$$\n\nThat is, for all ordered pairs of vertices in the graph that do not include $v$, compute the influence of $v$ on that pair divided by the total width of the shortest paths for that pair, then multiply by the influences of the two endpoints, and finally sum the results over all such pairs to obtain the spreading power of the vertex.\n\nMr. B wants to quickly know the spreading power of every vertex in the graph. When he asked Xiaoqiang, Xiaoqiang said: “I have a brilliant method, but the statement is too short to write it down.”\n\nDo you know how to do it?", "inputFormat": "The first line contains $2$ positive integers $n$ and $m$, representing the number of vertices and the number of edges in the graph.\n\nThe next $n$ lines: the $i$-th line contains one non-negative integer $a_i$, representing the influence of the $i$-th person.\n\nThe next $m$ lines: the $j$-th line contains $3$ integers $x_j$, $y_j$, $b_j$ and one real number $c_j$, meaning there is an edge between vertex $x_j$ and vertex $y_j$ with length edge weight $b_j$ and width edge weight $c_j$.", "outputFormat": "Output $n$ lines. The $i$-th line contains one real number $R(i)$, representing the spreading power of the $i$-th vertex in the graph.", "hint": "**Scoring**\n\nWe will compare each number in the output file with the reference answer. If the relative error or absolute error of that number does not exceed $10^{-6}$, it will be judged correct. For numbers whose reference answer is $0$, the absolute error must not exceed $10^{-6}$ to be judged correct.\n\nIf the number of correct outputs is $q$, then your score on that test point is $\\left\\lfloor\\ 5(\\dfrac{q}{n})^7 \\right\\rfloor$.\n\n**Constraints**\n\nFor test points $1,2,3,4$, $n \\le 100$.\n\nFor test points $5,6,7,8$, all $b_j=1$.\n\nFor test points $9,10,11,12$, $m=n-1$.\n\nFor test points $1,3,5,7,9,11,13,15,17,19$, all $a_i=1$.\n\nFor test points $1,2,5,6,9,10,13,14,17,18$, all $c_j=1$.\n\nFor all testdata, $n \\le 1000$, $m \\le 4 \\times 10^3$, $0<a_j \\le 255$, $0<b_j \\le 15$, $0.5 \\le c_j \\le 2$, and the fractional part of $c_j$ has at most $12$ digits. The graph is guaranteed to be connected.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2015] misc", "background": "", "description": "小强和 B 君是好朋友。 \n\n小强除了 B 君还有很多好朋友，比如洁妹。 \n\nB 君除了小强也还有很多好朋友，比如R君。他们还有很多共同的好朋友，比如小花，葱娘和其他 $3$ 个人。 \n\nB 君发现，人与人之间的关系可以看成是一个无向图，每个人看成一个点，人与人之间的关系看成一条边。 \n\n不同的人在社会中的号召力不一样，我们用 $a_i$ 来表示第 $i$ 个人的号召力。 \n\n人与人之间的关系也各不相同，可能非常友好，可能只是泛泛之交；可能天天腻在一起，可能一年才联系一次。为此，我们用长度边权 $b_j$ 来刻画第 $j$ 条边对应的两个用户的亲密程度，长度约小，双方就越亲密；同时，我们用宽度边权 $c_j$ 来刻画第 $j$ 条边对应的两个用户的交流频率，宽度越大，两个人沟通的频率也就越高。\n\n一条路径的长度指的是这条路径上的所有边的长度边权之和，一条路径的宽度指的是这条路径上的所有边的宽度边权的乘积。 \n\n当两个人 $s$ 和 $t$ 想要交流的时候，他们会选择长度最短的路径来交流。由于最短路可能有多个，我们称 $s$ 到 $t$ 的最短路的宽度为 $\\sigma_{st}$，是所有 $s$ 到 $t$ 的长度最短的路径的宽度和。同时，我们用 $\\sigma_{st} (v)$ 表示所有从 $s$ 到 $t$，且经过 $v$ 的长度最短的路径的宽度和，即 $v$ 对 $s$,$t$ 的影响力。 \n一个人 $v$ 在图中的传播力 $R(v)$ 可以被定义为如下函数： \n\n $$R(v)=\\sum\\limits_{s \\ne v \\ne t} \\frac{a_s a_t \\sigma_{st}(v)}{\\sigma_{st}}$$\n\n即对图中所有不包含 $v$ 的点对，分别计算 $v$ 对该点对的影响力除以该点对的最短路的宽度，再乘上这个点对中两个点的号召力，最后将所有点对的计算结果加和得到节点在图中的传播力。\n \nB 君想快速知道所有节点在图中的传播力。当他去问小强的时候，小强说：“我有一个绝妙的做法，可惜题面太短，写不下。” \n\n你知道怎么做吗？ ", "inputFormat": "第一行包含 $2$ 个正整数 $n$,$m$，分别表示图的点数和边数。 \n\n接下来 $n$ 行中的第 $i$ 行有 $1$ 个非负整数 $a_i$，表示第 $i$ 个人的号召力。 \n接下来 $m$ 行中的第 $j$ 行有 $3$ 个整数 $x_j$,$y_j$,$b_j$ 和一个实数 $c_j$ ，表示点 $x_j$ 和点 $y_j$ 之间有一条长度边权为 $b_j$，宽度边权为 $c_j$ 的边。 ", "outputFormat": "共 $n$ 行，每行一个实数 $R(i)$，表示第 $i$ 个点在图中的传播力。 ", "hint": "**评分标准**\n\n我们会将输出文件的每个数与参考答案进行比较，如果该数与参考答案的相对误差或绝对误差不超过 $10^{-6}$，则判定该数正确。对于参考答案为 $0$ 的数，必须满足绝对误差不超过 $10^{-6}$ 才判定为正确。 \n\n如果输出正确数的个数为 $q$，那么你在该测试点上的得分是 $\\left\\lfloor\\ 5(\\dfrac{q}{n})^7 \\right\\rfloor$ \n\n**数据规模和约定** \n\n对于测试点 $1$,$2$,$3$,$4$，有 $n \\le 100$。 \n\n对于测试点 $5$,$6$,$7$,$8$，所有 $b_j=1$。 \n\n对于测试点 $9$,$10$,$11$,$12$，有 $m=n-1$。 \n\n对于测试点 $1$,$3$,$5$,$7$,$9$,$11$,$13$,$15$,$17$,$19$，所有 $a_i=1$。 \n\n对于测试点 $1$,$2$,$5$,$6$,$9$,$10$,$13$,$14$,$17$,$18$，所有 $c_j=1$。 \n\n对于所有的数据，有 $n \\le 1000$，$m \\le 4 \\times 10^3$，$0<a_j \\le 255$，$0<b_j \\le 15$，$0.5 \\le c_j \\le 2$，$c_j$ 的小数部分最多 $12$ 位。数据保证图是连通的。", "locale": "zh-CN"}}}
{"pid": "P5883", "type": "P", "difficulty": 6, "samples": [["3 3\n2 3 0\n2 2 1\n1 3 1\n", "2/3\n2/9\n3/2\n1/1\n0/1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "线段树", "Special Judge", "期望", "CTSC/CTS"], "title": "[CTSC2013] 没头脑和不高兴", "background": null, "description": "没头脑和不高兴是一对形影不离的好朋友，他们一起上学也一起玩耍。\n\n这天，这对好朋友聚在一起玩纸牌游戏。他们所玩的纸牌总共有 $N$ 张，每一张上面都有一个 $1-N$ 的数字，任意两张纸牌上的数字都不相同。根据他们制定的游戏规则，在每局游戏的开始，所有的牌需要按照从 $1-N$ 的顺序排好。在开心地玩完了一局牌之后，他们发现牌的顺序被弄得乱七八糟，将它们排好序是一件挺麻烦的事情。\n\n他们将凌乱的纸牌在桌面上排成一排，然后开始了排序工作。不高兴由于在上一局游戏中输了牌，非常不高兴。他只将其中**奇数位置**的牌排成了升序，然后把剩下的任务推给了没头脑。没头脑非常没头脑，他采取了一个有些笨的排序方式。每次，他找到两张相邻并且顺序不对的牌交换它们，直到整个序列被排好序为止。\n\n乐于探究的你，想要研究在初始排列随机的情况下没头脑花在交换纸牌上的时间。假设没头脑每交换一对纸牌花费的时间为 $1$，你希望求出他排序时间的期望。此外，为了更好地分析这个问题，你还希望能够计算出所花时间的方差。更进一步地，如果**被不高兴排好序的位置发生了变化**，你是否还能求出没头脑用来排序时间的期望呢？", "inputFormat": "- 输入文件共 $M+1$ 行。\n- 第一行包含两个正整数 $N$,$M$。\n- 接下来 $M$ 行，每行包含三个整数 $l$,$r$,$v$。其中 $1 \\le l \\le r \\le n$，$v\\in\\{0,1\\}$。若 $v=0$ 则表示不高兴不再对 $l$ 到 $r$ 之间的位置排序；反之若 $v=1$ 则表示被不高兴排序的位置将涵盖 $l$ 到 $r$。", "outputFormat": "- 输出文件共 $M+2$ 行。每行输出一个形如 `p/q` 的有理数，其中 $\\gcd(p,q)=1$，$q \\ge 1$，$p,q \\in Z$。\n- 第一行输出在初始条件下没头脑排序时间的期望。\n- 第二行输出在初始条件下没头脑排序时间的方差。\n- 接下来 $M$ 行，每行分别输出在对不高兴排序的位置进行了前若干次修改之后没头脑排序时间的期望。", "hint": "**样例说明**\n\n在初始条件下，不高兴会将位置 $1$ 和 $3$ 的纸牌排好顺序。对于排列 $(1,2,3)$ 和 $(3,2,1)$，他将排列成 $(1,2,3)$，没头脑不需要操作；对于排列 $(1,3,2)$ 和 $(2,3,1)$，他将排列成 $(1,3,2)$ ，没头脑需要交换一次；对于排列 $(2,1,3)$ 和 $(3,1,2)$，他将排列成 $(2,1,3)$，没头脑需要交换一次。因此没头脑所花的时间期望为$\\frac{0 \\times 2+1 \\times 2+1\\times 2}{6}=\\frac{2}{3}$；方差为 $\\frac{ (0-\\frac{2}{3})^2 \\times 2 + (1-\\frac{2}{3})^2 \\times 2+(1-\\frac{2}{3})^2 \\times 2 }{6}=\\frac{2}{9}$。\n\n在进行了第一次修改之后，不高兴会只对位置 $1$ 排序，这和没有排序的效果一样；第二次修改之后，他会对位置 $1$,$2$ 排序；最后一次修改之后，他会对位置 $1$,$2$,$3$ 排序，这样没头脑完全不用参与排序工作。可据此求出对应情况下没头脑排序时间的期望。\n\n**评分标准**\n- 如果选手的前两行正确，其余行出现错误，可以得到 $40\\%$ 的分数。\n- 如果选手的前两行出现错误，其余行正确，可以得到 $50\\%$ 的分数。\n- 如果选手的所有行输出完全正确，可以得到 $100\\%$ 的分数。\n- 其余情况选手不得分。\n\n\n**数据规模和约定**\n\n| 测试点编号 | $N$ 的值 | $M$ 的值 |\n| :----------: | :----------: | :----------: |\n| $1$ | $4$ | $10$ |\n| $2$ | $11$ | $100$ |\n| $3$ | $100$ | $10^3$ |\n| $4$ | $1001$ | $10^4$ |\n| $5$ | $78590$ | $10^5$ |\n| $6$ | $87933$ | $10^5$ |\n| $7$ | $95000$ | $10^5$|\n| $8$ | $99445$ | $10^5$ |\n| $9$ | $99999$ | $10^5$ |\n| $10$ | $100000$ |  $10^5$|", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2013] Not Thinking and Unhappy", "background": "", "description": "Not Thinking and Unhappy are a pair of inseparable good friends. They go to school together and play together.\n\nOne day, they got together to play a card game. There are a total of $N$ cards, and each card has a number from $1-N$ on it. The numbers on any two cards are different. According to the rules they made, at the start of each round, all cards must be arranged in order from $1-N$. After happily finishing a round, they found that the order of the cards had become a complete mess, and sorting them back is quite troublesome.\n\nThey laid the messy cards in a row on the table and began sorting. Unhappy, having lost in the last round, was very unhappy. He only sorted the cards in the **odd positions** into increasing order, and then pushed the remaining work to Not Thinking. Not Thinking was really not thinking: he used a somewhat clumsy sorting method. Each time, he finds two adjacent cards that are in the wrong order and swaps them, until the whole sequence is sorted.\n\nYou, who enjoy exploring, want to study how much time Not Thinking spends swapping cards when the initial permutation is random. Assume each swap costs time $1$. You want to find the expected value of his sorting time. In addition, to analyze this better, you also want to compute the variance of the time spent. Furthermore, if **the positions sorted by Unhappy change**, can you still find the expected sorting time of Not Thinking?", "inputFormat": "- The input file has $M+1$ lines.\n- The first line contains two positive integers $N$, $M$.\n- The next $M$ lines each contain three integers $l$, $r$, $v$. Here $1 \\le l \\le r \\le n$, $v\\in\\{0,1\\}$. If $v=0$, it means Unhappy will no longer sort positions from $l$ to $r$; otherwise, if $v=1$, it means the positions sorted by Unhappy will include $l$ to $r$.", "outputFormat": "- The output file has $M+2$ lines. Each line outputs a rational number in the form `p/q`, where $\\gcd(p,q)=1$, $q \\ge 1$, $p,q \\in Z$.\n- The first line outputs the expected sorting time of Not Thinking under the initial condition.\n- The second line outputs the variance of Not Thinking's sorting time under the initial condition.\n- The next $M$ lines output, respectively, the expected sorting time of Not Thinking after the first several modifications to the positions sorted by Unhappy.", "hint": "**Sample Explanation**\n\nUnder the initial condition, Unhappy will sort the cards at positions $1$ and $3$. For permutations $(1,2,3)$ and $(3,2,1)$, he will make them into $(1,2,3)$, so Not Thinking does not need to do anything. For permutations $(1,3,2)$ and $(2,3,1)$, he will make them into $(1,3,2)$, and Not Thinking needs one swap. For permutations $(2,1,3)$ and $(3,1,2)$, he will make them into $(2,1,3)$, and Not Thinking needs one swap. Therefore, the expected time Not Thinking spends is $\\frac{0 \\times 2+1 \\times 2+1\\times 2}{6}=\\frac{2}{3}$; the variance is $\\frac{ (0-\\frac{2}{3})^2 \\times 2 + (1-\\frac{2}{3})^2 \\times 2+(1-\\frac{2}{3})^2 \\times 2 }{6}=\\frac{2}{9}$.\n\nAfter the first modification, Unhappy will only sort position $1$, which is the same as not sorting at all. After the second modification, he will sort positions $1$, $2$. After the last modification, he will sort positions $1$, $2$, $3$, so Not Thinking does not need to participate in sorting at all. Based on this, you can compute the expected sorting time of Not Thinking in the corresponding cases.\n\n**Scoring**\n\n- If the first two lines are correct but the remaining lines are wrong, you can get $40\\%$ of the score.\n- If the first two lines are wrong but the remaining lines are correct, you can get $50\\%$ of the score.\n- If all output lines are completely correct, you can get $100\\%$ of the score.\n- In all other cases, you get no score.\n\n**Constraints**\n\n| Test Point ID | Value of $N$ | Value of $M$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $4$ | $10$ |\n| $2$ | $11$ | $100$ |\n| $3$ | $100$ | $10^3$ |\n| $4$ | $1001$ | $10^4$ |\n| $5$ | $78590$ | $10^5$ |\n| $6$ | $87933$ | $10^5$ |\n| $7$ | $95000$ | $10^5$ |\n| $8$ | $99445$ | $10^5$ |\n| $9$ | $99999$ | $10^5$ |\n| $10$ | $100000$ | $10^5$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2013] 没头脑和不高兴", "background": null, "description": "没头脑和不高兴是一对形影不离的好朋友，他们一起上学也一起玩耍。\n\n这天，这对好朋友聚在一起玩纸牌游戏。他们所玩的纸牌总共有 $N$ 张，每一张上面都有一个 $1-N$ 的数字，任意两张纸牌上的数字都不相同。根据他们制定的游戏规则，在每局游戏的开始，所有的牌需要按照从 $1-N$ 的顺序排好。在开心地玩完了一局牌之后，他们发现牌的顺序被弄得乱七八糟，将它们排好序是一件挺麻烦的事情。\n\n他们将凌乱的纸牌在桌面上排成一排，然后开始了排序工作。不高兴由于在上一局游戏中输了牌，非常不高兴。他只将其中**奇数位置**的牌排成了升序，然后把剩下的任务推给了没头脑。没头脑非常没头脑，他采取了一个有些笨的排序方式。每次，他找到两张相邻并且顺序不对的牌交换它们，直到整个序列被排好序为止。\n\n乐于探究的你，想要研究在初始排列随机的情况下没头脑花在交换纸牌上的时间。假设没头脑每交换一对纸牌花费的时间为 $1$，你希望求出他排序时间的期望。此外，为了更好地分析这个问题，你还希望能够计算出所花时间的方差。更进一步地，如果**被不高兴排好序的位置发生了变化**，你是否还能求出没头脑用来排序时间的期望呢？", "inputFormat": "- 输入文件共 $M+1$ 行。\n- 第一行包含两个正整数 $N$,$M$。\n- 接下来 $M$ 行，每行包含三个整数 $l$,$r$,$v$。其中 $1 \\le l \\le r \\le n$，$v\\in\\{0,1\\}$。若 $v=0$ 则表示不高兴不再对 $l$ 到 $r$ 之间的位置排序；反之若 $v=1$ 则表示被不高兴排序的位置将涵盖 $l$ 到 $r$。", "outputFormat": "- 输出文件共 $M+2$ 行。每行输出一个形如 `p/q` 的有理数，其中 $\\gcd(p,q)=1$，$q \\ge 1$，$p,q \\in Z$。\n- 第一行输出在初始条件下没头脑排序时间的期望。\n- 第二行输出在初始条件下没头脑排序时间的方差。\n- 接下来 $M$ 行，每行分别输出在对不高兴排序的位置进行了前若干次修改之后没头脑排序时间的期望。", "hint": "**样例说明**\n\n在初始条件下，不高兴会将位置 $1$ 和 $3$ 的纸牌排好顺序。对于排列 $(1,2,3)$ 和 $(3,2,1)$，他将排列成 $(1,2,3)$，没头脑不需要操作；对于排列 $(1,3,2)$ 和 $(2,3,1)$，他将排列成 $(1,3,2)$ ，没头脑需要交换一次；对于排列 $(2,1,3)$ 和 $(3,1,2)$，他将排列成 $(2,1,3)$，没头脑需要交换一次。因此没头脑所花的时间期望为$\\frac{0 \\times 2+1 \\times 2+1\\times 2}{6}=\\frac{2}{3}$；方差为 $\\frac{ (0-\\frac{2}{3})^2 \\times 2 + (1-\\frac{2}{3})^2 \\times 2+(1-\\frac{2}{3})^2 \\times 2 }{6}=\\frac{2}{9}$。\n\n在进行了第一次修改之后，不高兴会只对位置 $1$ 排序，这和没有排序的效果一样；第二次修改之后，他会对位置 $1$,$2$ 排序；最后一次修改之后，他会对位置 $1$,$2$,$3$ 排序，这样没头脑完全不用参与排序工作。可据此求出对应情况下没头脑排序时间的期望。\n\n**评分标准**\n- 如果选手的前两行正确，其余行出现错误，可以得到 $40\\%$ 的分数。\n- 如果选手的前两行出现错误，其余行正确，可以得到 $50\\%$ 的分数。\n- 如果选手的所有行输出完全正确，可以得到 $100\\%$ 的分数。\n- 其余情况选手不得分。\n\n\n**数据规模和约定**\n\n| 测试点编号 | $N$ 的值 | $M$ 的值 |\n| :----------: | :----------: | :----------: |\n| $1$ | $4$ | $10$ |\n| $2$ | $11$ | $100$ |\n| $3$ | $100$ | $10^3$ |\n| $4$ | $1001$ | $10^4$ |\n| $5$ | $78590$ | $10^5$ |\n| $6$ | $87933$ | $10^5$ |\n| $7$ | $95000$ | $10^5$|\n| $8$ | $99445$ | $10^5$ |\n| $9$ | $99999$ | $10^5$ |\n| $10$ | $100000$ |  $10^5$|", "locale": "zh-CN"}}}
{"pid": "P5884", "type": "P", "difficulty": 4, "samples": [["4\n0 3\n1 0\n0 2\n3 1\n1 2\n2 3\n", "0\n1\n0\n1\n0\n1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "IOI", "Special Judge"], "title": "[IOI 2014] game 游戏", "background": "", "description": "健佳是一个喜欢做游戏的小男生。当有人问问题时，他更喜欢通过玩游戏的方式作答，而不是直接回答。健佳碰到了他的朋友梅玉，跟她讲了台湾的航空网。在台湾有 $n$ 个城市（编号为 $0,\\cdots,n−1$），其中有些城市之间有航线。每个航线连接两个城市，并且是双向的。\n\n梅玉问健佳，是否任意两个城市之间都可以坐飞机互达（直接或间接），健佳不想直接回答，而是要通过做游戏的方式来告诉她。梅玉可以问\"城市 $u$ 和 $v$ 之间有直接航线吗？\"，健佳会立刻直接回答该问题。梅玉会询问每对城市恰好一次，因此总计会有 $r = \\frac{n (n−1)}{2}$ 个问题。如果由前 $i$（$i<r$）个问题的答案可以推断出整个航空网是否连通，也就是说，是否任意一对城市之间都可以坐飞机互达（直接或间接），梅玉就获胜。否则意味着她需要知道全部 $r$ 个回答，此时健佳获胜。\n\n为了让游戏更好玩，他们俩同意，健佳可以不要管台湾的真实航空网，而是可以随着游戏的进展而编造航空网，也就是根据梅玉此前的提问来决定此后如何作答。你的任务是，通过决定健佳如何回答，来帮助他赢得游戏。", "inputFormat": "- 第 $1$ 行：一个正整数 $n$，代表城市数量。\n- 余下 $r$ 行：每行包含两个整数 $u$ 和 $v$，表示对城市 $u$ 和 $v$ 的提问。", "outputFormat": "- 共 $r$ 行，对于每次梅玉的提问，你必须回答在城市 $v$ 和 $u$ 之间是否有直接航线。具体而言，返回值 $1$ 表示有，$0$ 表示没有。", "hint": "**子任务及数据规模**\n\n| 子任务 | 分值 | $n$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $15$ | $n=4$ |\n| $2$ | $27$ | $4 \\le n \\le 80$ |\n| $3$ | $58$ | $4 \\le n \\le 1500$ |\n", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2014] game", "background": "", "description": "Jianjia is a boy who likes playing games. When someone asks him a question, he prefers to answer by playing a game instead of answering directly. Jianjia met his friend Meiyu and told her about Taiwan’s airline network. In Taiwan there are $n$ cities (numbered $0,\\cdots,n−1$), and there are air routes between some pairs of cities. Each route connects two cities and is bidirectional.\n\nMeiyu asked Jianjia whether it is possible to travel by plane between any two cities (directly or indirectly). Jianjia does not want to answer directly, and instead wants to tell her through a game. Meiyu may ask, “Is there a direct air route between cities $u$ and $v$?”, and Jianjia must answer immediately. Meiyu will ask about each pair of cities exactly once, so in total there will be $r = \\frac{n (n−1)}{2}$ questions. If from the answers to the first $i$ questions ($i<r$) it is already possible to determine whether the whole airline network is connected, that is, whether it is possible to travel between any pair of cities by plane (directly or indirectly), then Meiyu wins. Otherwise, this means she needs to know all $r$ answers, and then Jianjia wins.\n\nTo make the game more fun, they agreed that Jianjia does not have to follow the real airline network in Taiwan. Instead, he may make up the airline network as the game progresses, that is, he can decide how to answer later based on Meiyu’s previous questions. Your task is to help him win the game by deciding how Jianjia should answer.", "inputFormat": "- Line $1$: A positive integer $n$, the number of cities.\n- The remaining $r$ lines: Each line contains two integers $u$ and $v$, representing a question about cities $u$ and $v$.", "outputFormat": "- Output $r$ lines. For each question from Meiyu, you must answer whether there is a direct air route between cities $v$ and $u$. Specifically, output $1$ if there is, and $0$ if there is not.", "hint": "**Subtasks and Constraints**\n\n| Subtask | Score | $n$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $15$ | $n=4$ |\n| $2$ | $27$ | $4 \\le n \\le 80$ |\n| $3$ | $58$ | $4 \\le n \\le 1500$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2014] game 游戏", "background": "", "description": "健佳是一个喜欢做游戏的小男生。当有人问问题时，他更喜欢通过玩游戏的方式作答，而不是直接回答。健佳碰到了他的朋友梅玉，跟她讲了台湾的航空网。在台湾有 $n$ 个城市（编号为 $0,\\cdots,n−1$），其中有些城市之间有航线。每个航线连接两个城市，并且是双向的。\n\n梅玉问健佳，是否任意两个城市之间都可以坐飞机互达（直接或间接），健佳不想直接回答，而是要通过做游戏的方式来告诉她。梅玉可以问\"城市 $u$ 和 $v$ 之间有直接航线吗？\"，健佳会立刻直接回答该问题。梅玉会询问每对城市恰好一次，因此总计会有 $r = \\frac{n (n−1)}{2}$ 个问题。如果由前 $i$（$i<r$）个问题的答案可以推断出整个航空网是否连通，也就是说，是否任意一对城市之间都可以坐飞机互达（直接或间接），梅玉就获胜。否则意味着她需要知道全部 $r$ 个回答，此时健佳获胜。\n\n为了让游戏更好玩，他们俩同意，健佳可以不要管台湾的真实航空网，而是可以随着游戏的进展而编造航空网，也就是根据梅玉此前的提问来决定此后如何作答。你的任务是，通过决定健佳如何回答，来帮助他赢得游戏。", "inputFormat": "- 第 $1$ 行：一个正整数 $n$，代表城市数量。\n- 余下 $r$ 行：每行包含两个整数 $u$ 和 $v$，表示对城市 $u$ 和 $v$ 的提问。", "outputFormat": "- 共 $r$ 行，对于每次梅玉的提问，你必须回答在城市 $v$ 和 $u$ 之间是否有直接航线。具体而言，返回值 $1$ 表示有，$0$ 表示没有。", "hint": "**子任务及数据规模**\n\n| 子任务 | 分值 | $n$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $15$ | $n=4$ |\n| $2$ | $27$ | $4 \\le n \\le 80$ |\n| $3$ | $58$ | $4 \\le n \\le 1500$ |\n", "locale": "zh-CN"}}}
{"pid": "P5885", "type": "P", "difficulty": 7, "samples": [["10\n1 1 1 0 0 1 1 1 0 0\n1 1 1 0 0 0 0 0 1 1\n0\n100\n", "0101111001\n"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "2014", "O2优化", "快速数论变换 NTT", "CTSC/CTS"], "title": "[CTSC2014] 随机数", "background": "", "description": "露露、花花和萱萱最近对计算机中的随机数产生了兴趣。为大家所熟知的是，有计算机生成的随机数序列并非真正的随机数，而是由一定法则生成的伪随机数。 \n\n某一天，露露了解了一种生成随机数的方法，称为 Mersenne twister。给定初始参数 $m \\in Z+$，$ x \\le Z+\\cap[0,2m)$ 和初值 $M_0 \\in Z+\\cap [0,2m)$，它通过下列递推式构造伪随机数列$\\{M_n\\}$: \n\n $$M_n=\\begin{cases}2M_{n-1} & 2M_{n-1}<2^m\\\\(2M_{n-1}-2^m) \\ XOR \\ x & 2M_{n-1}\\geq 2^m\\end{cases}$$\n \n\n 其中 $XOR$ 是二进制异或运算（C/C++ 中的 $^$ 运算）。而参数 $x$ 的选取若使得该数列在长度趋于无穷时，近似等概率地在 $Z+ \\cap (0,2m)$ 中取值，就称 $x$ 为好的。例如，在 $m>1$时 $x=0$ 就显然不是好的。 \n \n在露露向伙伴们介绍了 Mersenne twister 之后，花花想用这一些经典的随机性测试来检验它的随机性强度。为此，花花使用计算机计算\n了一些 $M_k$。 \n\n但细心的萱萱注意到，花花在某次使用二进制输入 $k$ 时，在末尾多输入了 $l$ 个 $0$。她正想告诉花花这个疏忽，然而花花已经计算并记录了\n错误的 $M_k$ 而没有记录 $k$ 的值。虽然这其实不是什么致命的问题，但是在萱萱告诉花花她这个疏漏时，作为完美主义者的花花还是恳求萱萱帮她修正 $M_k$ 的值。萱萱便把这个任务交给了她的 AI ——你。 ", "inputFormat": "- 第一行包含一个正整数 $m$； \n- 第二行为二进制表示的 $x$（共 $m$ 个数，从低位到高位排列）；\n- 第三行为二进制表示的 $M_0$（排列方式同 $x$）； \n- 第四行包含一个整数 $type$。 \n\n接下来分为两种可能的情况： \n1. $type=0$（萱萱记下了花花的输入）：则第五行包含一个整数，表示萱萱记下来的正确的 $k$ 值。 \n2. $type=1$（萱萱未能记下花花的输入）：则第五行为 $l$，第六行输入花花计算出错误的二进制表示的 $M_k$。 ", "outputFormat": "仅一行，为m位的01串，表示你求得的正确Mk（同样要求从低位到高位）。 ", "hint": "对于 $type=0$ 的部分，要么 $m,k \\le 10^6$ 要么 $m\\le 2000,k\\le 10^{18}$；\n\n对于 $type=1$ 的部分，$m \\le 10^3$，$k \\le 10^{18}$，$l \\le 10$，$x$ 是“好的”。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2014] Random Numbers", "background": "", "description": "Lulu, Huahua, and Xuanxuan have recently become interested in random numbers in computers. As is well known, random number sequences generated by computers are not truly random; they are pseudorandom numbers produced by certain rules.\n\nOne day, Lulu learned a method for generating random numbers called the Mersenne twister. Given initial parameters $m \\in Z+$, $ x \\le Z+\\cap[0,2m)$ and an initial value $M_0 \\in Z+\\cap [0,2m)$, it constructs a pseudorandom sequence $\\{M_n\\}$ by the following recurrence:\n\n$$M_n=\\begin{cases}2M_{n-1} & 2M_{n-1}<2^m\\\\(2M_{n-1}-2^m) \\ XOR \\ x & 2M_{n-1}\\geq 2^m\\end{cases}$$\n\nHere, $XOR$ is the bitwise exclusive OR operation (the $^$ operator in C/C++). If the choice of parameter $x$ makes the sequence, as its length tends to infinity, take values in $Z+ \\cap (0,2m)$ approximately with equal probability, then $x$ is called good. For example, when $m>1$, $x=0$ is obviously not good.\n\nAfter Lulu introduced the Mersenne twister to her partners, Huahua wanted to use some classic randomness tests to check its randomness strength. For this, Huahua used a computer to compute some $M_k$.\n\nBut careful Xuanxuan noticed that when Huahua entered $k$ in binary, she accidentally typed $l$ extra $0$’s at the end. Xuanxuan was about to tell Huahua about this mistake, but Huahua had already computed and recorded the wrong $M_k$ without recording the value of $k$. Although this is not a fatal problem, when Xuanxuan told Huahua about the oversight, the perfectionist Huahua still begged Xuanxuan to help her correct the value of $M_k$. Xuanxuan then handed this task to her AI—you.", "inputFormat": "- The first line contains a positive integer $m$.\n- The second line is the binary representation of $x$ (a total of $m$ bits, arranged from low bit to high bit).\n- The third line is the binary representation of $M_0$ (arranged in the same way as $x$).\n- The fourth line contains an integer $type$.\n\nNext, there are two possible cases:\n1. $type=0$ (Xuanxuan recorded Huahua’s input): the fifth line contains an integer, meaning the correct value of $k$ that Xuanxuan recorded.\n2. $type=1$ (Xuanxuan failed to record Huahua’s input): the fifth line is $l$, and the sixth line gives the wrong binary representation of $M_k$ computed by Huahua.", "outputFormat": "Only one line: an $m$-bit 01 string, representing the correct $M_k$ you computed (also required to be from low bit to high bit).", "hint": "For the part with $type=0$, either $m,k \\le 10^6$, or $m \\le 2000,k \\le 10^{18}$.\n\nFor the part with $type=1$, $m \\le 10^3$, $k \\le 10^{18}$, $l \\le 10$, and $x$ is good.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2014] 随机数", "background": "", "description": "露露、花花和萱萱最近对计算机中的随机数产生了兴趣。为大家所熟知的是，有计算机生成的随机数序列并非真正的随机数，而是由一定法则生成的伪随机数。 \n\n某一天，露露了解了一种生成随机数的方法，称为 Mersenne twister。给定初始参数 $m \\in Z+$，$ x \\le Z+\\cap[0,2m)$ 和初值 $M_0 \\in Z+\\cap [0,2m)$，它通过下列递推式构造伪随机数列$\\{M_n\\}$: \n\n $$M_n=\\begin{cases}2M_{n-1} & 2M_{n-1}<2^m\\\\(2M_{n-1}-2^m) \\ XOR \\ x & 2M_{n-1}\\geq 2^m\\end{cases}$$\n \n\n 其中 $XOR$ 是二进制异或运算（C/C++ 中的 $^$ 运算）。而参数 $x$ 的选取若使得该数列在长度趋于无穷时，近似等概率地在 $Z+ \\cap (0,2m)$ 中取值，就称 $x$ 为好的。例如，在 $m>1$时 $x=0$ 就显然不是好的。 \n \n在露露向伙伴们介绍了 Mersenne twister 之后，花花想用这一些经典的随机性测试来检验它的随机性强度。为此，花花使用计算机计算\n了一些 $M_k$。 \n\n但细心的萱萱注意到，花花在某次使用二进制输入 $k$ 时，在末尾多输入了 $l$ 个 $0$。她正想告诉花花这个疏忽，然而花花已经计算并记录了\n错误的 $M_k$ 而没有记录 $k$ 的值。虽然这其实不是什么致命的问题，但是在萱萱告诉花花她这个疏漏时，作为完美主义者的花花还是恳求萱萱帮她修正 $M_k$ 的值。萱萱便把这个任务交给了她的 AI ——你。 ", "inputFormat": "- 第一行包含一个正整数 $m$； \n- 第二行为二进制表示的 $x$（共 $m$ 个数，从低位到高位排列）；\n- 第三行为二进制表示的 $M_0$（排列方式同 $x$）； \n- 第四行包含一个整数 $type$。 \n\n接下来分为两种可能的情况： \n1. $type=0$（萱萱记下了花花的输入）：则第五行包含一个整数，表示萱萱记下来的正确的 $k$ 值。 \n2. $type=1$（萱萱未能记下花花的输入）：则第五行为 $l$，第六行输入花花计算出错误的二进制表示的 $M_k$。 ", "outputFormat": "仅一行，为m位的01串，表示你求得的正确Mk（同样要求从低位到高位）。 ", "hint": "对于 $type=0$ 的部分，要么 $m,k \\le 10^6$ 要么 $m\\le 2000,k\\le 10^{18}$；\n\n对于 $type=1$ 的部分，$m \\le 10^3$，$k \\le 10^{18}$，$l \\le 10$，$x$ 是“好的”。", "locale": "zh-CN"}}}
{"pid": "P5886", "type": "P", "difficulty": 1, "samples": [["4 3 2\n2 2 3\n1 1\n3 1 2 3\n2 1 3\n", "1\n2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["洛谷月赛"], "title": "Hello, 2020!", "background": "时针与分针重合在「零」的那一霎那，嘀嗒声便宣告了新一年的到来。\n\n在过去的一年里，世事无常。屏幕面前的你可能不久前才听闻「OI」，也可能暂时地结束了竞赛生涯；可能在赛场上叱咤风云名列榜首，也可能独自承受着比赛失利的落寞。\n\n无论如何，过去仍旧是过去，将来依然是将来。\n\n以此题为开端，迎接你的 2020 吧！", "description": "本场比赛有 $n$ 名出题人，$m$ 名选手。\n\n出题人从 $1$ 至 $n$ 依次标号，选手从 $1$ 至 $m$ 依次标号。\n\n比赛结束后选手的最终排名为 $1$ 至 $m$ 中其一，且互不相同。\n\n报名结束后，第 $i$ 位出题人看了看报名列表，对其他出题人说：「我觉得只有这 $k_i$ 位选手有可能最终排名第一，他们分别是 $a_{i,1},a_{i,2},\\dots,a_{i,k_i}$。其他人不可能最终排名第一。」\n\n你面前屏幕上的这道题的出题人通过时空隧道，预先得知了谁是最终排名第一的选手。\n\n出题人把这 $n$ 位出题人的预测都告诉了你，还告诉你恰好只有 $p$ 个出题人的预测是正确的。\n\n请你求出哪些选手可能最终获得第一名，并以从小到大的顺序依次输出这些选手的编号。", "inputFormat": "从标准输入中读取数据。\n\n第一行，三个正整数 $n,m,p$，表示出题人数，选手数，与正确预测数。\n\n接下来 $n$ 行，每行第一个非负整数 $k_i$ 表示第 $i$ 位出题人预测可能最终排名第一的选手位数；接下来 $k_i$ 个正整数 $a_{i,1},a_{i,2},\\dots,a_{i,k_i}$，表示这位出题人预测可能最终排名第一的选手编号。", "outputFormat": "输出数据至标准输出中。\n\n第一行，输出一个非负整数，表示可能最终获得第一名的选手个数。\n\n第二行，以从小到大的顺序依次输出这些选手的编号。", "hint": "子任务 1（$6\\%$）：$n\\leq 20$，$m\\leq 20$。\n\n子任务 2（$30\\%$）：$n\\leq 100$，$m\\leq 100$，$\\sum k_i \\leq 10^4$。\n\n子任务 3（$24\\%$）：$n\\leq 1000$，$m\\leq 1000$。\n\n子任务 4（$40\\%$）：无特殊限制。\n\n对于全部数据，$1\\leq n\\leq 10^5$，$1\\leq m\\leq 10^6$，$0\\leq \\sum k_i \\leq 10^6$，$0\\leq p\\leq n$。", "locale": "zh-CN", "translations": {"en": {"title": "Hello, 2020!", "background": "At the moment when the hour hand and the minute hand overlap at “zero”, the ticking sound announces the arrival of a new year.\n\nIn the past year, the world has been unpredictable. You in front of the screen may have only heard of “OI” not long ago, or you may have temporarily ended your contest journey; you may have dominated the contest and topped the leaderboard, or you may have borne the loneliness of failure by yourself.\n\nNo matter what, the past is still the past, and the future is still the future.\n\nLet this problem be the beginning, and welcome your 2020!", "description": "In this contest, there are $n$ problem setters and $m$ contestants.\n\nThe problem setters are numbered from $1$ to $n$, and the contestants are numbered from $1$ to $m$.\n\nAfter the contest ends, the final ranking of contestants is a permutation of $1$ to $m$, and all ranks are distinct.\n\nAfter registration ends, the $i$-th problem setter looked at the registration list and said to the other problem setters: “I think only these $k_i$ contestants might finally rank first. They are $a_{i,1},a_{i,2},\\dots,a_{i,k_i}$. No one else can possibly end up in first place.”\n\nThe problem setter of the problem on your screen learned in advance, through a time tunnel, who the contestant that finally ranks first is.\n\nThe problem setter told you all $n$ predictions made by these problem setters, and also told you that exactly $p$ problem setters’ predictions are correct.\n\nPlease determine which contestants could possibly end up in first place, and output their IDs in increasing order.", "inputFormat": "Read the input from standard input.\n\nThe first line contains three positive integers $n,m,p$, representing the number of problem setters, the number of contestants, and the number of correct predictions.\n\nThe next $n$ lines each start with a non-negative integer $k_i$, indicating how many contestants the $i$-th problem setter predicts could finally rank first; then follow $k_i$ positive integers $a_{i,1},a_{i,2},\\dots,a_{i,k_i}$, indicating the contestant IDs that this problem setter predicts could finally rank first.", "outputFormat": "Write the output to standard output.\n\nThe first line outputs a non-negative integer, indicating the number of contestants who could possibly end up in first place.\n\nThe second line outputs these contestants’ IDs in increasing order.", "hint": "Subtask 1 ($6\\%$): $n\\leq 20$, $m\\leq 20$.\n\nSubtask 2 ($30\\%$): $n\\leq 100$, $m\\leq 100$, $\\sum k_i \\leq 10^4$.\n\nSubtask 3 ($24\\%$): $n\\leq 1000$, $m\\leq 1000$.\n\nSubtask 4 ($40\\%$): no special constraints.\n\nConstraints for all data: $1\\leq n\\leq 10^5$, $1\\leq m\\leq 10^6$, $0\\leq \\sum k_i \\leq 10^6$, $0\\leq p\\leq n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Hello, 2020!", "background": "时针与分针重合在「零」的那一霎那，嘀嗒声便宣告了新一年的到来。\n\n在过去的一年里，世事无常。屏幕面前的你可能不久前才听闻「OI」，也可能暂时地结束了竞赛生涯；可能在赛场上叱咤风云名列榜首，也可能独自承受着比赛失利的落寞。\n\n无论如何，过去仍旧是过去，将来依然是将来。\n\n以此题为开端，迎接你的 2020 吧！", "description": "本场比赛有 $n$ 名出题人，$m$ 名选手。\n\n出题人从 $1$ 至 $n$ 依次标号，选手从 $1$ 至 $m$ 依次标号。\n\n比赛结束后选手的最终排名为 $1$ 至 $m$ 中其一，且互不相同。\n\n报名结束后，第 $i$ 位出题人看了看报名列表，对其他出题人说：「我觉得只有这 $k_i$ 位选手有可能最终排名第一，他们分别是 $a_{i,1},a_{i,2},\\dots,a_{i,k_i}$。其他人不可能最终排名第一。」\n\n你面前屏幕上的这道题的出题人通过时空隧道，预先得知了谁是最终排名第一的选手。\n\n出题人把这 $n$ 位出题人的预测都告诉了你，还告诉你恰好只有 $p$ 个出题人的预测是正确的。\n\n请你求出哪些选手可能最终获得第一名，并以从小到大的顺序依次输出这些选手的编号。", "inputFormat": "从标准输入中读取数据。\n\n第一行，三个正整数 $n,m,p$，表示出题人数，选手数，与正确预测数。\n\n接下来 $n$ 行，每行第一个非负整数 $k_i$ 表示第 $i$ 位出题人预测可能最终排名第一的选手位数；接下来 $k_i$ 个正整数 $a_{i,1},a_{i,2},\\dots,a_{i,k_i}$，表示这位出题人预测可能最终排名第一的选手编号。", "outputFormat": "输出数据至标准输出中。\n\n第一行，输出一个非负整数，表示可能最终获得第一名的选手个数。\n\n第二行，以从小到大的顺序依次输出这些选手的编号。", "hint": "子任务 1（$6\\%$）：$n\\leq 20$，$m\\leq 20$。\n\n子任务 2（$30\\%$）：$n\\leq 100$，$m\\leq 100$，$\\sum k_i \\leq 10^4$。\n\n子任务 3（$24\\%$）：$n\\leq 1000$，$m\\leq 1000$。\n\n子任务 4（$40\\%$）：无特殊限制。\n\n对于全部数据，$1\\leq n\\leq 10^5$，$1\\leq m\\leq 10^6$，$0\\leq \\sum k_i \\leq 10^6$，$0\\leq p\\leq n$。", "locale": "zh-CN"}}}
{"pid": "P5887", "type": "P", "difficulty": 2, "samples": [["4 2 2\n0 1\n", "0"], ["4 2 2\n0 2\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["洛谷月赛"], "title": "Ringed Genesis", "background": "Enzyme runs through the Ringed Genesis，just like Rabbit runs through a Ring. ", "description": "有一个长长的环，环由 $n$ 个格子首尾相接形成，依次编号 $0$ 至 $n-1$。\n\n还有一种动物——兔子。兔子的步长为 $k$。若兔子当前在第 $i$ 个格子，那么下一秒它将跳到第 $(i+k)\\bmod n$ 个格子。\n\n现在有 $m$ 只兔子，第 $i$ 只兔子的初始格子为第 $p_i$ 个格子。随着时间的流逝，有些格子被兔子经过了，有些却一直没有被兔子经过。\n\n你需要求出的是，有多少个格子永远不可能被兔子经过。", "inputFormat": "从标准输入中读取数据。\n\n第一行，三个正整数 $n,m,k$，表示环长，兔子数，步长。\n\n第二行，$m$ 个非负整数 $p_1,p_2,\\dots,p_m$，表示兔子的初始格子。", "outputFormat": "输出数据至标准输出中。\n\n共一行，一个整数，表示答案。", "hint": "子任务 1（$10\\%$）：$k=1$。\n\n子任务 2（$20\\%$）：$k|n$，也即 $\\gcd(k,n)=k$。\n\n子任务 3（$25\\%$）：$1\\leq n\\leq 1000$，$1\\leq m\\leq 1000$。\n\n子任务 4（$45\\%$）：无特殊限制。\n\n对于全部数据，$1 \\leq n \\leq 10^6$，$1 \\leq m \\leq 10^6$，$1 \\leq k \\leq n$。", "locale": "zh-CN", "translations": {"en": {"title": "Ringed Genesis", "background": "Enzyme runs through the Ringed Genesis, just like Rabbit runs through a Ring.", "description": "There is a long ring made by connecting $n$ cells end to end, numbered from $0$ to $n-1$ in order.\n\nThere is also an animal called a rabbit. The rabbit’s step length is $k$. If the rabbit is currently on the $i$-th cell, then in the next second it will jump to the $((i+k)\\bmod n)$-th cell.\n\nNow there are $m$ rabbits. The initial cell of the $i$-th rabbit is the $p_i$-th cell. As time goes by, some cells are visited by rabbits, while some cells are never visited.\n\nYou need to find how many cells can never be visited by any rabbit.", "inputFormat": "Read input from standard input.\n\nThe first line contains three positive integers $n, m, k$, representing the ring length, the number of rabbits, and the step length.\n\nThe second line contains $m$ non-negative integers $p_1, p_2, \\dots, p_m$, representing the initial cells of the rabbits.", "outputFormat": "Write output to standard output.\n\nOutput one line with one integer, which is the answer.", "hint": "Subtask 1 ($10\\%$): $k = 1$.\n\nSubtask 2 ($20\\%$): $k \\mid n$, i.e. $\\gcd(k, n) = k$.\n\nSubtask 3 ($25\\%$): $1 \\leq n \\leq 1000$, $1 \\leq m \\leq 1000$.\n\nSubtask 4 ($45\\%$): no special constraints.\n\nFor all testdata, $1 \\leq n \\leq 10^6$, $1 \\leq m \\leq 10^6$, $1 \\leq k \\leq n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Ringed Genesis", "background": "Enzyme runs through the Ringed Genesis，just like Rabbit runs through a Ring. ", "description": "有一个长长的环，环由 $n$ 个格子首尾相接形成，依次编号 $0$ 至 $n-1$。\n\n还有一种动物——兔子。兔子的步长为 $k$。若兔子当前在第 $i$ 个格子，那么下一秒它将跳到第 $(i+k)\\bmod n$ 个格子。\n\n现在有 $m$ 只兔子，第 $i$ 只兔子的初始格子为第 $p_i$ 个格子。随着时间的流逝，有些格子被兔子经过了，有些却一直没有被兔子经过。\n\n你需要求出的是，有多少个格子永远不可能被兔子经过。", "inputFormat": "从标准输入中读取数据。\n\n第一行，三个正整数 $n,m,k$，表示环长，兔子数，步长。\n\n第二行，$m$ 个非负整数 $p_1,p_2,\\dots,p_m$，表示兔子的初始格子。", "outputFormat": "输出数据至标准输出中。\n\n共一行，一个整数，表示答案。", "hint": "子任务 1（$10\\%$）：$k=1$。\n\n子任务 2（$20\\%$）：$k|n$，也即 $\\gcd(k,n)=k$。\n\n子任务 3（$25\\%$）：$1\\leq n\\leq 1000$，$1\\leq m\\leq 1000$。\n\n子任务 4（$45\\%$）：无特殊限制。\n\n对于全部数据，$1 \\leq n \\leq 10^6$，$1 \\leq m \\leq 10^6$，$1 \\leq k \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P5888", "type": "P", "difficulty": 4, "samples": [["2 1 0", "0"], ["3 3 0", "2"], ["7 13 5\n1 3\n4 5\n5 4\n6 1\n2 2", "443723615"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "洛谷月赛"], "title": "传球游戏", "background": "羊城有善蹴鞠者。会足协之杯，于校园之东北角，施两球场，蹴鞠者站球场中，$n$ 人，一球，二门，三裁判而已。观众团坐。少倾，但闻球场中哨声一响，满坐寂然，无敢哗者。\n\n当是时，传球声，微微风声，队员疾跑声，教练呼喊声，拉拉队助威声，一时齐发，众妙毕备。满场观众无不伸颈，侧目，微笑，默叹，以为妙绝。\n\n未几，我球员施一长传，彼球员截之，望我龙门冲来。\n\n但见守门员 oql 立于门，若有所思——", "description": "**原来他在想这么一个问题：**\n\n场上的 $n$ 个球员围成一圈，编号从 $1$ 到 $n$ ，刚开始球在 $1$ 号球员手中。一共 $m$ 次传球，每次传球必须传给一个人，但不能传到自己手中。求第 $m$ 次传球以后传回 $1$ 号球员的方案数。\n\n但他觉得这个问题太简单了，于是加了 $k$ 条限制，每条限制形如 $a,b$，表示 $a$ 号球员不能将球传给 $b$ 号球员。\n\n为了使得 oql 的注意力转移回球场上，你需要在最短的时间内告诉他这个方案数是多少。\n\n你只需要告诉他答案对 $998244353$ 取模后的结果。", "inputFormat": "输入数据包括 $k+1$ 行：\n\n第一行三个整数 $n,m,k$，分表代表球员数，传球次数，限制条数。\n\n接下来 $k$ 行，每行两个整数 $a_i,b_i$，表示 $a_i$ 号球员不能将球传给 $b_i$ 号球员。\n\n数据保证不会出现不同的 $i,j$ 使得 $a_i=a_j$ 且 $b_i=b_j$。", "outputFormat": "输出一个整数，表示 $m$ 轮后传回 $1$ 号球员的合法方案数对 $998244353$ 取模后的结果。", "hint": "对于 $10\\%$ 的数据，$k=0$。\n\n对于另外 $15\\%$ 的数据，$n\\leq 500$。\n\n对于另外 $20\\%$ 的数据，$n\\leq 5\\times 10^4$。\n\n对于另外 $20\\%$ 的数据，$k\\leq 300$。\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 10^9$，$0\\leq m\\leq 200$，$0\\leq k \\leq \\min(n\\times(n-1),5\\times 10^4)$，$1\\leq a_i,b_i\\leq n$，**不保证 $a_i,b_i$ 不相等**。", "locale": "zh-CN", "translations": {"en": {"title": "Passing Game", "background": "In Yangcheng, there are people who are good at playing cuju. During the Football Association Cup, at the northeast corner of the campus, two fields are set up. The cuju players stand in the field: $n$ people, one ball, two goals, three referees, that is all. The audience sits around. After a while, as soon as the whistle on the field blows, everyone becomes silent, and no one dares to make noise.\n\nAt that moment, the sound of passing, the faint sound of wind, the sound of players sprinting, the coach shouting, and the cheerleaders cheering all burst out together, and every wonderful sound is present. The whole audience stretches their necks, looks sideways, smiles, and sighs silently, thinking it is amazing.\n\nSoon, one of our players makes a long pass. Their player intercepts it and charges toward our goal.\n\nThen we see the goalkeeper oql standing at the goal, as if thinking about something.", "description": "**It turns out he is thinking about this problem:**\n\nThere are $n$ players standing in a circle, numbered from $1$ to $n$. At the beginning, the ball is in the hands of player $1$. There are $m$ passes in total. In each pass, the ball must be passed to someone, but it cannot be passed to oneself. Find the number of ways such that after the $m$-th pass, the ball is passed back to player $1$.\n\nBut he thinks this problem is too easy, so he adds $k$ restrictions. Each restriction is of the form $a,b$, meaning that player $a$ cannot pass the ball to player $b$.\n\nTo bring oql’s attention back to the match as soon as possible, you need to tell him this number of ways in the shortest time.\n\nYou only need to output the result modulo $998244353$.", "inputFormat": "The input consists of $k+1$ lines:\n\nThe first line contains three integers $n,m,k$, which represent the number of players, the number of passes, and the number of restrictions.\n\nThe next $k$ lines each contain two integers $a_i,b_i$, indicating that player $a_i$ cannot pass the ball to player $b_i$.\n\nThe data guarantees that there do not exist different $i,j$ such that $a_i=a_j$ and $b_i=b_j$.", "outputFormat": "Output one integer, representing the number of valid ways for the ball to return to player $1$ after $m$ passes, modulo $998244353$.", "hint": "For $10\\%$ of the data, $k=0$.\n\nFor another $15\\%$ of the data, $n\\leq 500$.\n\nFor another $20\\%$ of the data, $n\\leq 5\\times 10^4$.\n\nFor another $20\\%$ of the data, $k\\leq 300$.\n\nFor $100\\%$ of the data, $1\\leq n\\leq 10^9$, $0\\leq m\\leq 200$, $0\\leq k \\leq \\min(n\\times(n-1),5\\times 10^4)$, $1\\leq a_i,b_i\\leq n$, **it is not guaranteed that $a_i$ and $b_i$ are different**.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "传球游戏", "background": "羊城有善蹴鞠者。会足协之杯，于校园之东北角，施两球场，蹴鞠者站球场中，$n$ 人，一球，二门，三裁判而已。观众团坐。少倾，但闻球场中哨声一响，满坐寂然，无敢哗者。\n\n当是时，传球声，微微风声，队员疾跑声，教练呼喊声，拉拉队助威声，一时齐发，众妙毕备。满场观众无不伸颈，侧目，微笑，默叹，以为妙绝。\n\n未几，我球员施一长传，彼球员截之，望我龙门冲来。\n\n但见守门员 oql 立于门，若有所思——", "description": "**原来他在想这么一个问题：**\n\n场上的 $n$ 个球员围成一圈，编号从 $1$ 到 $n$ ，刚开始球在 $1$ 号球员手中。一共 $m$ 次传球，每次传球必须传给一个人，但不能传到自己手中。求第 $m$ 次传球以后传回 $1$ 号球员的方案数。\n\n但他觉得这个问题太简单了，于是加了 $k$ 条限制，每条限制形如 $a,b$，表示 $a$ 号球员不能将球传给 $b$ 号球员。\n\n为了使得 oql 的注意力转移回球场上，你需要在最短的时间内告诉他这个方案数是多少。\n\n你只需要告诉他答案对 $998244353$ 取模后的结果。", "inputFormat": "输入数据包括 $k+1$ 行：\n\n第一行三个整数 $n,m,k$，分表代表球员数，传球次数，限制条数。\n\n接下来 $k$ 行，每行两个整数 $a_i,b_i$，表示 $a_i$ 号球员不能将球传给 $b_i$ 号球员。\n\n数据保证不会出现不同的 $i,j$ 使得 $a_i=a_j$ 且 $b_i=b_j$。", "outputFormat": "输出一个整数，表示 $m$ 轮后传回 $1$ 号球员的合法方案数对 $998244353$ 取模后的结果。", "hint": "对于 $10\\%$ 的数据，$k=0$。\n\n对于另外 $15\\%$ 的数据，$n\\leq 500$。\n\n对于另外 $20\\%$ 的数据，$n\\leq 5\\times 10^4$。\n\n对于另外 $20\\%$ 的数据，$k\\leq 300$。\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 10^9$，$0\\leq m\\leq 200$，$0\\leq k \\leq \\min(n\\times(n-1),5\\times 10^4)$，$1\\leq a_i,b_i\\leq n$，**不保证 $a_i,b_i$ 不相等**。", "locale": "zh-CN"}}}
{"pid": "P5889", "type": "P", "difficulty": 5, "samples": [["3 5 4\n1 2 3 3 1\n1 3 4 5\n1 2 2 4\n2 3 1\n1 1 2 3", "2\n1\n6"]], "limits": {"time": [1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2020", "线段树", "O2优化", "哈希 hashing", "洛谷月赛"], "title": "跳树", "background": "兔子喜欢跳树。", "description": "一天，兔子在一棵点数为 $2^n-1$ 完全二叉树上的一个结点上，他准备进行若干次如下的跳跃。\n\n- 跳到这个点的左儿子，保证这个点有左儿子。\n- 跳到这个点的右儿子，保证这个点有右儿子。\n- 跳到这个点的父亲，**若这个点是根，无视此操作**。\n\n其中，$i$ 号点要么没有儿子，要么有左儿子 $2 \\times i$ 和右儿子 $2 \\times i + 1$。\n\n兔子会计划性地跳树，他写下了一个长度为 $m$ 的序列 $op$。$op$ 中的每个数都是 $1$, $2$, $3$ 中的一种。操作 $i$ 对应从上到下第 $i$ 种跳跃方式。\n\n每次，兔子会选择一段区间 $[l,r]$，依次进行跳跃 $op_l,op_{l+1},\\ldots,op_r$。\n\n有时兔子会对一个点的 $op$ 值进行修改。\n\n现在你需要求出兔子每次会跳到哪个结点。\n\n阅读样例解释可以对题意获得更好的理解。", "inputFormat": "第一行三个整数 $n, m, q$，表示树的大小的幂次、$op$ 的长度、操作的次数。\n\n第二行包含 $m$ 个整数 $op_{1,2,\\ldots,m}$，表示序列的初值。\n\n接下来 $q$ 行，每行一个整数 $type$，若 $type$ 为 $1$，接下来三个整数 $s,l,r$，描述起点和进行跳跃的区间；若 $type$ 为 $2$ ，接下来两个整数 $x,y$，描述修改的位置与值。", "outputFormat": "对于每一个 $type=1$，输出一个数，表示跳跃到的结点。", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/jxigowfv.png)\n\n其中红边为第一次跳跃的路径，蓝边为第二次，绿边为第三次。\n\n所有测试数据的范围和特点如下表所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lost2xr2.png)\n\n对于 $100\\%$ 的数据，$1\\leq n \\leq 30$，$1\\leq m,q \\leq  5 \\times 10^5$，$1\\leq op_i\\leq 3$。", "locale": "zh-CN", "translations": {"en": {"title": "Jumping on a Tree.", "background": "Rabbits like jumping on trees.", "description": "One day, a rabbit is on a node of a perfect binary tree with $2^n-1$ nodes, and he plans to perform several jumps of the following types:\n\n- Jump to the left child of the current node. It is guaranteed that the node has a left child.\n- Jump to the right child of the current node. It is guaranteed that the node has a right child.\n- Jump to the parent of the current node. **If the current node is the root, ignore this operation.**\n\nFor node $i$, it either has no children, or it has a left child $2 \\times i$ and a right child $2 \\times i + 1$.\n\nThe rabbit will jump in a planned way. He writes down a sequence $op$ of length $m$. Each number in $op$ is one of $1$, $2$, or $3$. Operation $i$ corresponds to the $i$-th jump type listed above from top to bottom.\n\nEach time, the rabbit chooses an interval $[l,r]$ and performs the jumps $op_l,op_{l+1},\\ldots,op_r$ in order.\n\nSometimes, the rabbit will modify the $op$ value at a position.\n\nNow you need to determine which node the rabbit ends up at for each query.\n\nReading the sample explanation can help you understand the statement better.", "inputFormat": "The first line contains three integers $n, m, q$, representing the exponent determining the tree size, the length of $op$, and the number of operations.\n\nThe second line contains $m$ integers $op_{1,2,\\ldots,m}$, representing the initial sequence.\n\nThe next $q$ lines each contain an integer $type$. If $type$ is $1$, then three integers $s,l,r$ follow, describing the starting node and the interval of jumps to perform. If $type$ is $2$, then two integers $x,y$ follow, describing the position to modify and the new value.", "outputFormat": "For each query with $type=1$, output one number, the node where the rabbit ends up after the jumps.", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/jxigowfv.png)\n\nThe red edges show the path of the first jump, the blue edges the second, and the green edges the third.\n\nThe constraints and characteristics of all testdata are shown in the table below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lost2xr2.png)\n\nFor $100\\%$ of the data, $1\\leq n \\leq 30$, $1\\leq m,q \\leq  5 \\times 10^5$, and $1\\leq op_i\\leq 3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "跳树", "background": "兔子喜欢跳树。", "description": "一天，兔子在一棵点数为 $2^n-1$ 完全二叉树上的一个结点上，他准备进行若干次如下的跳跃。\n\n- 跳到这个点的左儿子，保证这个点有左儿子。\n- 跳到这个点的右儿子，保证这个点有右儿子。\n- 跳到这个点的父亲，**若这个点是根，无视此操作**。\n\n其中，$i$ 号点要么没有儿子，要么有左儿子 $2 \\times i$ 和右儿子 $2 \\times i + 1$。\n\n兔子会计划性地跳树，他写下了一个长度为 $m$ 的序列 $op$。$op$ 中的每个数都是 $1$, $2$, $3$ 中的一种。操作 $i$ 对应从上到下第 $i$ 种跳跃方式。\n\n每次，兔子会选择一段区间 $[l,r]$，依次进行跳跃 $op_l,op_{l+1},\\ldots,op_r$。\n\n有时兔子会对一个点的 $op$ 值进行修改。\n\n现在你需要求出兔子每次会跳到哪个结点。\n\n阅读样例解释可以对题意获得更好的理解。", "inputFormat": "第一行三个整数 $n, m, q$，表示树的大小的幂次、$op$ 的长度、操作的次数。\n\n第二行包含 $m$ 个整数 $op_{1,2,\\ldots,m}$，表示序列的初值。\n\n接下来 $q$ 行，每行一个整数 $type$，若 $type$ 为 $1$，接下来三个整数 $s,l,r$，描述起点和进行跳跃的区间；若 $type$ 为 $2$ ，接下来两个整数 $x,y$，描述修改的位置与值。", "outputFormat": "对于每一个 $type=1$，输出一个数，表示跳跃到的结点。", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/jxigowfv.png)\n\n其中红边为第一次跳跃的路径，蓝边为第二次，绿边为第三次。\n\n所有测试数据的范围和特点如下表所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lost2xr2.png)\n\n对于 $100\\%$ 的数据，$1\\leq n \\leq 30$，$1\\leq m,q \\leq  5 \\times 10^5$，$1\\leq op_i\\leq 3$。", "locale": "zh-CN"}}}
{"pid": "P5890", "type": "P", "difficulty": 6, "samples": [["4\n4 4\n8 6\n15 14\n114514 1", "Yes\n0101\nNo\nYes\n010100000111101\nNo"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["Special Judge", "O2优化", "洛谷月赛"], "title": "小欧与回文串构造", "background": "", "description": "小欧很喜欢字符串，尤其是只有 `0` 和 `1` 两种字符的回文串。\n\n小欧也喜欢回文串，尤其是有那么一些回文子串但不是很多的串。\n\n小欧更喜欢构造，所以他思考如下问题：\n\n给定正整数 $n$ 和 $k$，保证 $k\\le n$，能否构造一个长为 $n$ 的，只含有字符 `0` 和 `1` 的字符串 $S$，使得 $S$ 的本质不同非空回文子串个数恰好为 $k$ 呢？\n\n小欧是构造小鬼，打不过已经爆切十万甚至九万道构造的先辈们，因此他找你帮忙解决这个问题，并希望你在有解时给出任意一个构造。\n\n下面给出一些关于字符串的基本定义，字符串大手子可以跳过不读。\n\n- 对于长为 $n$ 的字符串 $S$，定义 $S_i$ 为字符串 $S$ 的从左至右第 $i$ 个字符，\n- 对于长为 $n$ 的字符串 $S$，定义其子串 $S[l;r]\\; (1\\le l\\le r\\le n)$ 为将字符 $S_l,S_{l+1},\\ldots,S_{r}$ 自左至右拼接形成的字符串。特别地，空串也是 $S$ 的子串。\n- 称 $S$ 的两个子串 $S[l_1;r_1]$ 和 $S[l_2;r_2]$ 本质不同，当且仅当 $S[l_1;r_1] \\ne S[l_2;r_2]$。\n- 对于长为 $n$ 的字符串 $S$，定义它的反串 $S^{T}$ 为将字符 $S_n,S_{n-1},\\ldots,S_1$ 自左至右拼接形成的字符串。\n- 字符串 $S$ 为回文串，当且仅当 $S=S^{T}$。", "inputFormat": "**本题有多组数据**。\n\n第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据：\n\n一行两个正整数，表示这组数据给出的 $n$ 和 $k$。\n", "outputFormat": "对于每组数据：\n\n若该组数据没有解，输出一行一个字符串 `No`；\n\n否则输出两行，第一行一个字符串 `Yes`，接下来一行一个长为 $n$ 的 `01` 串，为你构造的解。有多个解输出任意一个即可。\n", "hint": "对于第一组数据，本质不同的回文子串有：`1`，`0`，`101`，`010` 共四个。\n\n### 数据范围与约定\n\n对于 $20\\%$ 的数据，$n\\le 15$。  \n另有 $10\\%$ 的数据，$k=n$。  \n另有 $20\\%$ 的数据，$1000\\le n\\le 2000$，$k\\ge \\left\\lfloor\\dfrac{n}{2}\\right\\rfloor+100$。  \n对于 $100\\%$ 的数据，$1 \\le T \\le 10$，$1\\le k\\le  n\\le 2\\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Xiao Ou and Palindrome String Construction", "background": "", "description": "Xiao Ou likes strings, especially palindromic strings that contain only the two characters `0` and `1`.\n\nXiao Ou also likes palindromes, especially strings that have some palindromic substrings, but not too many.\n\nXiao Ou likes construction even more, so he thinks about the following problem:\n\nGiven positive integers $n$ and $k$, with $k \\le n$ guaranteed, can you construct a string $S$ of length $n$ consisting only of characters `0` and `1`, such that the number of essentially different non-empty palindromic substrings of $S$ is exactly $k$?\n\nXiao Ou is a construction newbie and cannot beat the predecessors who have already brute-forced 100,000 or even 90,000 construction problems, so he asks you to help solve this problem, and hopes that when a solution exists, you can output any valid construction.\n\nSome basic definitions about strings are given below. If you are very familiar with strings, you may skip this part.\n\n- For a string $S$ of length $n$, let $S_i$ be the $i$-th character of $S$ from left to right.\n- For a string $S$ of length $n$, define its substring $S[l;r]\\; (1\\le l\\le r\\le n)$ as the string formed by concatenating $S_l, S_{l+1}, \\ldots, S_r$ from left to right. In particular, the empty string is also a substring of $S$.\n- Two substrings $S[l_1;r_1]$ and $S[l_2;r_2]$ of $S$ are called essentially different if and only if $S[l_1;r_1] \\ne S[l_2;r_2]$.\n- For a string $S$ of length $n$, define its reverse string $S^{T}$ as the string formed by concatenating $S_n, S_{n-1}, \\ldots, S_1$ from left to right.\n- A string $S$ is a palindrome if and only if $S = S^{T}$.", "inputFormat": "**This problem has multiple test cases**.\n\nThe first line contains a positive integer $T$, representing the number of test cases.\n\nFor each test case:\n\nOne line contains two positive integers, representing $n$ and $k$ for this test case.", "outputFormat": "For each test case:\n\nIf there is no solution, output one line with the string `No`.\n\nOtherwise, output two lines. The first line is the string `Yes`, and the next line is a `01` string of length $n$, which is your constructed solution. If there are multiple solutions, output any one.", "hint": "For the first test case, the essentially different palindromic substrings are: `1`, `0`, `101`, `010`, for a total of four.\n\n### Constraints and Notes\n\nFor $20\\%$ of the testdata, $n \\le 15$.  \nFor another $10\\%$ of the testdata, $k = n$.  \nFor another $20\\%$ of the testdata, $1000 \\le n \\le 2000$, $k \\ge \\left\\lfloor\\dfrac{n}{2}\\right\\rfloor + 100$.  \nFor $100\\%$ of the testdata, $1 \\le T \\le 10$, $1 \\le k \\le n \\le 2\\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小欧与回文串构造", "background": "", "description": "小欧很喜欢字符串，尤其是只有 `0` 和 `1` 两种字符的回文串。\n\n小欧也喜欢回文串，尤其是有那么一些回文子串但不是很多的串。\n\n小欧更喜欢构造，所以他思考如下问题：\n\n给定正整数 $n$ 和 $k$，保证 $k\\le n$，能否构造一个长为 $n$ 的，只含有字符 `0` 和 `1` 的字符串 $S$，使得 $S$ 的本质不同非空回文子串个数恰好为 $k$ 呢？\n\n小欧是构造小鬼，打不过已经爆切十万甚至九万道构造的先辈们，因此他找你帮忙解决这个问题，并希望你在有解时给出任意一个构造。\n\n下面给出一些关于字符串的基本定义，字符串大手子可以跳过不读。\n\n- 对于长为 $n$ 的字符串 $S$，定义 $S_i$ 为字符串 $S$ 的从左至右第 $i$ 个字符，\n- 对于长为 $n$ 的字符串 $S$，定义其子串 $S[l;r]\\; (1\\le l\\le r\\le n)$ 为将字符 $S_l,S_{l+1},\\ldots,S_{r}$ 自左至右拼接形成的字符串。特别地，空串也是 $S$ 的子串。\n- 称 $S$ 的两个子串 $S[l_1;r_1]$ 和 $S[l_2;r_2]$ 本质不同，当且仅当 $S[l_1;r_1] \\ne S[l_2;r_2]$。\n- 对于长为 $n$ 的字符串 $S$，定义它的反串 $S^{T}$ 为将字符 $S_n,S_{n-1},\\ldots,S_1$ 自左至右拼接形成的字符串。\n- 字符串 $S$ 为回文串，当且仅当 $S=S^{T}$。", "inputFormat": "**本题有多组数据**。\n\n第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据：\n\n一行两个正整数，表示这组数据给出的 $n$ 和 $k$。\n", "outputFormat": "对于每组数据：\n\n若该组数据没有解，输出一行一个字符串 `No`；\n\n否则输出两行，第一行一个字符串 `Yes`，接下来一行一个长为 $n$ 的 `01` 串，为你构造的解。有多个解输出任意一个即可。\n", "hint": "对于第一组数据，本质不同的回文子串有：`1`，`0`，`101`，`010` 共四个。\n\n### 数据范围与约定\n\n对于 $20\\%$ 的数据，$n\\le 15$。  \n另有 $10\\%$ 的数据，$k=n$。  \n另有 $20\\%$ 的数据，$1000\\le n\\le 2000$，$k\\ge \\left\\lfloor\\dfrac{n}{2}\\right\\rfloor+100$。  \n对于 $100\\%$ 的数据，$1 \\le T \\le 10$，$1\\le k\\le  n\\le 2\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P5891", "type": "P", "difficulty": 7, "samples": [["7 19\n1 3 -8\n1 4 8\n1 13 -1\n2 2\n1 1 -10\n1 1 8\n2 12\n", "-10\n-10\n"], ["29 1066163924\n2 680224223\n1 440869582 -1203\n2 993311885\n1 729027357 9874\n2 665374856\n1 192704973 -9712\n1 681750770 -1099\n2 239837676\n1 938998353 -109\n2 174153423\n1 781133679 7360\n2 522379034\n2 125773599\n1 483114333 -376\n2 723115805\n2 699246389\n1 527125403 9279\n1 930492461 -9753\n1 14775627 -3676\n1 152692805 5045\n1 945645197 2710\n2 298593273\n1 888744817 2514\n1 651751441 4559\n2 963653895\n1 986621281 -8296\n2 10216021\n2 848072343\n2 482342087\n", "0\n-5264389353\n181209893739\n-398925734374\n-431628986929\n-73026998100\n-298228449649\n73714612345\n53926122085\n97102847037\n96145153438\n110646771673\n199641765482\n314932271763\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["O2优化", "洛谷月赛"], "title": "Fracture Ray", "background": "破碎的镜面里倒映着破碎的射线；\n\n破碎的文字中隐藏着破碎的——", "description": "有一个 `long long` 类型的数组 `a[]`。\n\n在给出所有操作之前，给定上界参数 $v$。\n\n共有 $q$ 次操作。每次操作为以下两个函数之一：\n\n```\nvoid modify(int u,int p)\n{\n    for (int i=u;i<=v;i+=count(i))\n        a[i]+=p;\n}\nlong long query(long long u)\n{\n    long long ret=0;\n    for (int i=u;i<=v;i+=count(i))\n        ret+=a[i];\n    return ret;\n}\n```\n\n上述程序为 C++ 代码，其中 `count(i)` 表示 $i$ 二进制下 $1$ 的个数，例如 `count(0)` 的返回值为 $0$，而 `count(10001279)` 的返回值为 $15$。\n\n上述程序中出现的变量 `v` 即上界参数 $v$。\n\n你需要执行上述操作，并在每次执行 `query()` 函数后，输出函数的返回值。", "inputFormat": "从标准输入中读取数据。\n\n第一行，两个正整数 $q,v$，表示操作数，以及上界参数。\n\n接下来 $q$ 行，每行为以下二者之一：\n\n+ `1 u p` 表示执行 `modify(u,p)`；\n+ `2 u` 表示执行 `query(u)` 并输出一行一个整数，为函数的返回值。", "outputFormat": "在每次执行 `query()` 函数后，输出函数的返回值。", "hint": "子任务 1（$8$ 分）：$1\\leq q\\leq 10^3$，$1\\leq v\\leq 10^4$。\n\n子任务 2（$23$ 分）：$1\\leq v\\leq 10^5$。\n\n子任务 3（$16$ 分）：$1\\leq q\\leq 50$。\n\n子任务 4（$28$ 分）：$1\\leq q\\leq 1000$。\n\n子任务 5（$25$ 分）：无特殊限制。\n\n对于全部数据，$1\\leq q\\leq 2\\times 10^5$，$1\\leq u\\leq v< 2^{30}$，$-10^4\\leq p\\leq 10^4$。\n\n请选手注意代码实现时常数因子带来的程序效率上的影响。\n\n已加入 hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "Fracture Ray", "background": "Broken rays are reflected in a broken mirror;\n\nbroken words hide something broken—", "description": "There is an array `a[]` of type `long long`.\n\nBefore giving all operations, an upper bound parameter $v$ is given.\n\nThere are $q$ operations in total. Each operation is one of the following two functions:\n\n```\nvoid modify(int u,int p)\n{\n    for (int i=u;i<=v;i+=count(i))\n        a[i]+=p;\n}\nlong long query(long long u)\n{\n    long long ret=0;\n    for (int i=u;i<=v;i+=count(i))\n        ret+=a[i];\n    return ret;\n}\n```\n\nThe above program is C++ code, where `count(i)` denotes the number of $1$ bits in the binary representation of $i$. For example, `count(0)` returns $0$, and `count(10001279)` returns $15$.\n\nThe variable `v` appearing in the program is exactly the upper bound parameter $v$.\n\nYou need to execute the operations above, and after each execution of `query()`, output the return value of the function.", "inputFormat": "Read input from standard input.\n\nThe first line contains two positive integers $q, v$, representing the number of operations and the upper bound parameter.\n\nThe next $q$ lines are one of the following:\n\n+ `1 u p` means executing `modify(u,p)`.\n+ `2 u` means executing `query(u)` and outputting one integer per line, which is the return value of the function.", "outputFormat": "After each execution of `query()`, output the return value of the function.", "hint": "Subtask 1 ($8$ points): $1\\leq q\\leq 10^3$, $1\\leq v\\leq 10^4$.\n\nSubtask 2 ($23$ points): $1\\leq v\\leq 10^5$.\n\nSubtask 3 ($16$ points): $1\\leq q\\leq 50$.\n\nSubtask 4 ($28$ points): $1\\leq q\\leq 1000$.\n\nSubtask 5 ($25$ points): no special restrictions.\n\nFor all data, $1\\leq q\\leq 2\\times 10^5$, $1\\leq u\\leq v< 2^{30}$, $-10^4\\leq p\\leq 10^4$.\n\nPlease pay attention to the impact of constant factors on program efficiency when implementing the code.\n\nHack testdata has been added.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Fracture Ray", "background": "破碎的镜面里倒映着破碎的射线；\n\n破碎的文字中隐藏着破碎的——", "description": "有一个 `long long` 类型的数组 `a[]`。\n\n在给出所有操作之前，给定上界参数 $v$。\n\n共有 $q$ 次操作。每次操作为以下两个函数之一：\n\n```\nvoid modify(int u,int p)\n{\n    for (int i=u;i<=v;i+=count(i))\n        a[i]+=p;\n}\nlong long query(long long u)\n{\n    long long ret=0;\n    for (int i=u;i<=v;i+=count(i))\n        ret+=a[i];\n    return ret;\n}\n```\n\n上述程序为 C++ 代码，其中 `count(i)` 表示 $i$ 二进制下 $1$ 的个数，例如 `count(0)` 的返回值为 $0$，而 `count(10001279)` 的返回值为 $15$。\n\n上述程序中出现的变量 `v` 即上界参数 $v$。\n\n你需要执行上述操作，并在每次执行 `query()` 函数后，输出函数的返回值。", "inputFormat": "从标准输入中读取数据。\n\n第一行，两个正整数 $q,v$，表示操作数，以及上界参数。\n\n接下来 $q$ 行，每行为以下二者之一：\n\n+ `1 u p` 表示执行 `modify(u,p)`；\n+ `2 u` 表示执行 `query(u)` 并输出一行一个整数，为函数的返回值。", "outputFormat": "在每次执行 `query()` 函数后，输出函数的返回值。", "hint": "子任务 1（$8$ 分）：$1\\leq q\\leq 10^3$，$1\\leq v\\leq 10^4$。\n\n子任务 2（$23$ 分）：$1\\leq v\\leq 10^5$。\n\n子任务 3（$16$ 分）：$1\\leq q\\leq 50$。\n\n子任务 4（$28$ 分）：$1\\leq q\\leq 1000$。\n\n子任务 5（$25$ 分）：无特殊限制。\n\n对于全部数据，$1\\leq q\\leq 2\\times 10^5$，$1\\leq u\\leq v< 2^{30}$，$-10^4\\leq p\\leq 10^4$。\n\n请选手注意代码实现时常数因子带来的程序效率上的影响。\n\n已加入 hack 数据。", "locale": "zh-CN"}}}
