{"pid": "B2101", "type": "B", "difficulty": 1, "samples": [["3 3\n3 4 1\n3 7 1\n2 0 1", "15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["数组"], "title": "计算矩阵边缘元素之和", "background": "", "description": "输入一个整数矩阵，计算位于矩阵边缘的元素之和。\n\n所谓矩阵边缘的元素，就是第一行和最后一行的元素以及第一列和最后一列的元素。", "inputFormat": "第 $1$ 行包含两个整数，分别为行数 $m$ 和列数 $n$，两个整数之间空格隔开。\n\n第 $2$ 行开始有 $m$ 行数据，每行包含 $n$ 个整数，整数之间空格隔开。", "outputFormat": "对应矩阵的边缘元素和。", "hint": "$1 \\le m,n \\le 100$。保证答案在 int 范围内。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "计算矩阵边缘元素之和", "background": "", "description": "输入一个整数矩阵，计算位于矩阵边缘的元素之和。\n\n所谓矩阵边缘的元素，就是第一行和最后一行的元素以及第一列和最后一列的元素。", "inputFormat": "第 $1$ 行包含两个整数，分别为行数 $m$ 和列数 $n$，两个整数之间空格隔开。\n\n第 $2$ 行开始有 $m$ 行数据，每行包含 $n$ 个整数，整数之间空格隔开。", "outputFormat": "对应矩阵的边缘元素和。", "hint": "$1 \\le m,n \\le 100$。保证答案在 int 范围内。", "locale": "zh-CN"}}}
{"pid": "B2102", "type": "B", "difficulty": 1, "samples": [["11 3 5 6 9\n12 4 7 8 10\n10 5 6 9 11\n8  6 4 7 2\n15 10 11 20 25", "4 1 8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数组"], "title": "计算鞍点", "background": "", "description": "给定一个 $5 \\times 5$ 的矩阵，每行只有一个最大值，每列只有一个最小值，寻找这个矩阵的鞍点。鞍点指的是矩阵中的一个元素，它是所在行的最大值，并且是所在列的最小值。\n\n例如：在下面的例子中，第 $4$ 行第 $1$ 列的元素就是鞍点，值为 $8$。\n\n```\n11 3 5 6 9\n12 4 7 8 10\n10 5 6 9 11\n8  6 4 7 2\n15 10 11 20 25\n```", "inputFormat": "输入包含一个 $5$ 行 $5$ 列的矩阵。", "outputFormat": "如果存在鞍点，输出鞍点所在的行、列及其值，如果不存在，输出 `not found`。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "计算鞍点", "background": "", "description": "给定一个 $5 \\times 5$ 的矩阵，每行只有一个最大值，每列只有一个最小值，寻找这个矩阵的鞍点。鞍点指的是矩阵中的一个元素，它是所在行的最大值，并且是所在列的最小值。\n\n例如：在下面的例子中，第 $4$ 行第 $1$ 列的元素就是鞍点，值为 $8$。\n\n```\n11 3 5 6 9\n12 4 7 8 10\n10 5 6 9 11\n8  6 4 7 2\n15 10 11 20 25\n```", "inputFormat": "输入包含一个 $5$ 行 $5$ 列的矩阵。", "outputFormat": "如果存在鞍点，输出鞍点所在的行、列及其值，如果不存在，输出 `not found`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "B2103", "type": "B", "difficulty": 1, "samples": [["3 3\n1 0 1\n0 0 1\n1 1 0\n1 1 0\n0 0 1\n0 0 1", "44.44"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数组"], "title": "图像相似度", "background": "", "description": "给出两幅相同大小的黑白图像（用 $0-1$ 矩阵）表示，求它们的相似度。\n\n说明：若两幅图像在相同位置上的像素点颜色相同，则称它们在该位置具有相同的像素点。两幅图像的相似度定义为相同像素点数占总像素点数的百分比。", "inputFormat": "第一行包含两个整数 $m$ 和 $n$，表示图像的行数和列数，中间用单个空格隔开。$1 \\le m \\le 100,1 \\le n \\le 100$。\n\n之后 $m$ 行，每行 $n$ 个整数 $0$ 或 $1$，表示第一幅黑白图像上各像素点的颜色。相邻两个数之间用单个空格隔开。\n\n之后 $m$ 行，每行 $n$ 个整数 $0$ 或 $1$，表示第二幅黑白图像上各像素点的颜色。相邻两个数之间用单个空格隔开。", "outputFormat": "一个实数，表示相似度（以百分比的形式给出），精确到小数点后两位。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "图像相似度", "background": "", "description": "给出两幅相同大小的黑白图像（用 $0-1$ 矩阵）表示，求它们的相似度。\n\n说明：若两幅图像在相同位置上的像素点颜色相同，则称它们在该位置具有相同的像素点。两幅图像的相似度定义为相同像素点数占总像素点数的百分比。", "inputFormat": "第一行包含两个整数 $m$ 和 $n$，表示图像的行数和列数，中间用单个空格隔开。$1 \\le m \\le 100,1 \\le n \\le 100$。\n\n之后 $m$ 行，每行 $n$ 个整数 $0$ 或 $1$，表示第一幅黑白图像上各像素点的颜色。相邻两个数之间用单个空格隔开。\n\n之后 $m$ 行，每行 $n$ 个整数 $0$ 或 $1$，表示第二幅黑白图像上各像素点的颜色。相邻两个数之间用单个空格隔开。", "outputFormat": "一个实数，表示相似度（以百分比的形式给出），精确到小数点后两位。", "hint": "", "locale": "zh-CN"}}}
{"pid": "B2104", "type": "B", "difficulty": 1, "samples": [["3 3\n1 2 3\n1 2 3\n1 2 3\n1 2 3\n4 5 6\n7 8 9", "2 4 6\n5 7 9\n8 10 12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["矩阵运算", "数组"], "title": "矩阵加法", "background": "", "description": "输入两个 $n$ 行 $m$ 列的矩阵 $A$ 和 $B$，输出它们的和 $A+B$，矩阵加法的规则是两个矩阵中对应位置的值进行加和，具体参照样例。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$，表示矩阵的行数和列数 $(1 \\le n \\le 100$，$1 \\le m \\le 100)$。\n\n接下来 $n$ 行，每行 $m$ 个整数，表示矩阵 $A$ 的元素。\n\n接下来 $n$ 行，每行 $m$ 个整数，表示矩阵 $B$ 的元素。\n\n相邻两个整数之间用单个空格隔开，每个元素均在 $1 \\sim 1000$ 之间。", "outputFormat": "$n$ 行，每行 $m$ 个整数，表示矩阵加法的结果。相邻两个整数之间用单个空格隔开。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "矩阵加法", "background": "", "description": "输入两个 $n$ 行 $m$ 列的矩阵 $A$ 和 $B$，输出它们的和 $A+B$，矩阵加法的规则是两个矩阵中对应位置的值进行加和，具体参照样例。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$，表示矩阵的行数和列数 $(1 \\le n \\le 100$，$1 \\le m \\le 100)$。\n\n接下来 $n$ 行，每行 $m$ 个整数，表示矩阵 $A$ 的元素。\n\n接下来 $n$ 行，每行 $m$ 个整数，表示矩阵 $B$ 的元素。\n\n相邻两个整数之间用单个空格隔开，每个元素均在 $1 \\sim 1000$ 之间。", "outputFormat": "$n$ 行，每行 $m$ 个整数，表示矩阵加法的结果。相邻两个整数之间用单个空格隔开。", "hint": "", "locale": "zh-CN"}}}
{"pid": "B2105", "type": "B", "difficulty": 2, "samples": [["3 2 3\n1 1\n1 1\n1 1\n1 1 1\n1 1 1", "2 2 2\n2 2 2\n2 2 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["矩阵运算", "矩阵乘法", "数组"], "title": "矩阵乘法", "background": "", "description": "计算两个矩阵的乘法。$n \\times m$ 阶的矩阵 $A$ 乘以 $m \\times k$ 阶的矩阵 $B$ 得到的矩阵 $C$ 是 $n \\times k$ 阶的，且 $C[i][j]=A[i][0] \\times B[0][j]+A[i][1] \\times B[1][j]+$ …… $+A[i][m-1] \\times B[m-1][j](C[i][j]$ 表示 $C$ 矩阵中第 $i$ 行第 $j$ 列元素）。", "inputFormat": "第一行为 $n,m,k$，表示 $A$ 矩阵是 $n$ 行 $m$ 列，$B$ 矩阵是 $m$ 行 $k$ 列，$n,m,k$ 均小于 $100$。\n\n然后先后输入 $A$ 和 $B$ 两个矩阵，$A$ 矩阵 $n$ 行 $m$ 列，$B$ 矩阵 $m$ 行 $k$ 列，矩阵中每个元素的绝对值不会大于 $1000$。", "outputFormat": "输出矩阵 $C$，一共 $n$ 行，每行 $k$ 个整数，整数之间以一个空格分开。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "矩阵乘法", "background": "", "description": "计算两个矩阵的乘法。$n \\times m$ 阶的矩阵 $A$ 乘以 $m \\times k$ 阶的矩阵 $B$ 得到的矩阵 $C$ 是 $n \\times k$ 阶的，且 $C[i][j]=A[i][0] \\times B[0][j]+A[i][1] \\times B[1][j]+$ …… $+A[i][m-1] \\times B[m-1][j](C[i][j]$ 表示 $C$ 矩阵中第 $i$ 行第 $j$ 列元素）。", "inputFormat": "第一行为 $n,m,k$，表示 $A$ 矩阵是 $n$ 行 $m$ 列，$B$ 矩阵是 $m$ 行 $k$ 列，$n,m,k$ 均小于 $100$。\n\n然后先后输入 $A$ 和 $B$ 两个矩阵，$A$ 矩阵 $n$ 行 $m$ 列，$B$ 矩阵 $m$ 行 $k$ 列，矩阵中每个元素的绝对值不会大于 $1000$。", "outputFormat": "输出矩阵 $C$，一共 $n$ 行，每行 $k$ 个整数，整数之间以一个空格分开。", "hint": "", "locale": "zh-CN"}}}
{"pid": "B2106", "type": "B", "difficulty": 1, "samples": [["3 3\n1 2 3\n4 5 6\n7 8 9", "1 4 7\n2 5 8\n3 6 9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["数组"], "title": "矩阵转置", "background": "", "description": "输入一个 $n$ 行 $m$ 列的矩阵 $A$，输出它的转置 $A^T$。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$，表示矩阵 $A$ 的行数和列数。$1 \\le n \\le 100$，$1 \\le m \\le 100$。\n\n接下来 $n$ 行，每行 $m$ 个整数，表示矩阵 $A$ 的元素。相邻两个整数之间用单个空格隔开，每个元素均在 $1 \\sim 1000$ 之间。", "outputFormat": "$m$ 行，每行 $n$ 个整数，为矩阵 $A$ 的转置。相邻两个整数之间用单个空格隔开。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "矩阵转置", "background": "", "description": "输入一个 $n$ 行 $m$ 列的矩阵 $A$，输出它的转置 $A^T$。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$，表示矩阵 $A$ 的行数和列数。$1 \\le n \\le 100$，$1 \\le m \\le 100$。\n\n接下来 $n$ 行，每行 $m$ 个整数，表示矩阵 $A$ 的元素。相邻两个整数之间用单个空格隔开，每个元素均在 $1 \\sim 1000$ 之间。", "outputFormat": "$m$ 行，每行 $n$ 个整数，为矩阵 $A$ 的转置。相邻两个整数之间用单个空格隔开。", "hint": "", "locale": "zh-CN"}}}
{"pid": "B2107", "type": "B", "difficulty": 1, "samples": [["3 3\n1 2 3\n4 5 6\n7 8 9", "7 4 1\n8 5 2\n9 6 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数组"], "title": "图像旋转", "background": "", "description": "输入一个 $n$ 行 $m$ 列的黑白图像，将它顺时针旋转 $90$ 度后输出。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$，表示图像包含像素点的行数和列数。$1 \\le n \\le 100$，$1 \\le m \\le 100$。\n\n接下来 $n$ 行，每行 $m$ 个整数，表示图像的每个像素点灰度。相邻两个整数之间用单个空格隔开，每个元素均在 $0 \\sim 255$ 之间。", "outputFormat": "$m$ 行，每行 $n$ 个整数，为顺时针旋转 $90$ 度后的图像。相邻两个整数之间用单个空格隔开。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "图像旋转", "background": "", "description": "输入一个 $n$ 行 $m$ 列的黑白图像，将它顺时针旋转 $90$ 度后输出。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$，表示图像包含像素点的行数和列数。$1 \\le n \\le 100$，$1 \\le m \\le 100$。\n\n接下来 $n$ 行，每行 $m$ 个整数，表示图像的每个像素点灰度。相邻两个整数之间用单个空格隔开，每个元素均在 $0 \\sim 255$ 之间。", "outputFormat": "$m$ 行，每行 $n$ 个整数，为顺时针旋转 $90$ 度后的图像。相邻两个整数之间用单个空格隔开。", "hint": "", "locale": "zh-CN"}}}
{"pid": "B2108", "type": "B", "difficulty": 1, "samples": [["4 5\n100 0 100 0 50\n50 100 200 0 0\n50 50 100 100 200\n100 100 50 50 100", "100 0 100 0 50\n50 80 100 60 0\n50 80 100 90 200\n100 100 50 50 100"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数组"], "title": "图像模糊处理", "background": "", "description": "给定 $n$ 行 $m$ 列的图像各像素点的灰度值，要求用如下方法对其进行模糊化处理：\n\n$1.$ 四周最外侧的像素点灰度值不变；\n\n$2.$ 中间各像素点新灰度值为该像素点及其上下左右相邻四个像素点原灰度值的平均（舍入到最接近的整数）。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$，表示图像包含像素点的行数和列数。$1 \\le n \\le 100$，$1 \\le m \\le 100$。\n\n接下来 $n$ 行，每行 $m$ 个整数，表示图像的每个像素点灰度。相邻两个整数之间用单个空格隔开，每个元素均在 $0$ ∼ $255$ 之间。", "outputFormat": "$n$ 行，每行 $m$ 个整数，为模糊处理后的图像。相邻两个整数之间用单个空格隔开。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "图像模糊处理", "background": "", "description": "给定 $n$ 行 $m$ 列的图像各像素点的灰度值，要求用如下方法对其进行模糊化处理：\n\n$1.$ 四周最外侧的像素点灰度值不变；\n\n$2.$ 中间各像素点新灰度值为该像素点及其上下左右相邻四个像素点原灰度值的平均（舍入到最接近的整数）。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$，表示图像包含像素点的行数和列数。$1 \\le n \\le 100$，$1 \\le m \\le 100$。\n\n接下来 $n$ 行，每行 $m$ 个整数，表示图像的每个像素点灰度。相邻两个整数之间用单个空格隔开，每个元素均在 $0$ ∼ $255$ 之间。", "outputFormat": "$n$ 行，每行 $m$ 个整数，为模糊处理后的图像。相邻两个整数之间用单个空格隔开。", "hint": "", "locale": "zh-CN"}}}
{"pid": "B2109", "type": "B", "difficulty": 1, "samples": [["Today is 2021-03-27", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串（入门）"], "title": "统计数字字符个数", "background": "", "description": "输入一行字符，统计出其中数字字符的个数。", "inputFormat": "一行字符串，总长度不超过 $255$。", "outputFormat": "输出为 $1$ 行，输出字符串里面数字字符的个数。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "统计数字字符个数", "background": "", "description": "输入一行字符，统计出其中数字字符的个数。", "inputFormat": "一行字符串，总长度不超过 $255$。", "outputFormat": "输出为 $1$ 行，输出字符串里面数字字符的个数。", "hint": "", "locale": "zh-CN"}}}
{"pid": "B2110", "type": "B", "difficulty": 1, "samples": [["abcabd", "c"], ["aabbcc", "no"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串（入门）"], "title": "找第一个只出现一次的字符", "background": "", "description": "给定一个只包含小写字母的字符串，请你找到第一个仅出现一次的字符。如果没有，输出 `no`。", "inputFormat": "一个字符串，长度小于 $1100$。", "outputFormat": "输出第一个仅出现一次的字符，若没有则输出 `no`。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "找第一个只出现一次的字符", "background": "", "description": "给定一个只包含小写字母的字符串，请你找到第一个仅出现一次的字符。如果没有，输出 `no`。", "inputFormat": "一个字符串，长度小于 $1100$。", "outputFormat": "输出第一个仅出现一次的字符，若没有则输出 `no`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "B2111", "type": "B", "difficulty": 1, "samples": [["0.85\nATCGCCGTAAGTAACGGTTTTAAATAGGCC\nATCGCCGGAAGTAACGGTCTTAAATAGGCC", "yes"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串"], "title": "基因相关性", "background": "", "description": "为了获知基因序列在功能和结构上的相似性，经常需要将几条不同序列的 DNA 进行比对，以判断该比对的 DNA 是否具有相关性。\n\n现比对两条长度相同的 DNA 序列。首先定义两条 DNA 序列相同位置的碱基为一个碱基对，如果一个碱基对中的两个碱基相同的话，则称为相同碱基对。接着计算相同碱基对占总碱基对数量的比例，如果该比例大于等于给定阈值时则判定该两条 DNA 序列是相关的，否则不相关。", "inputFormat": "有三行，第一行是用来判定出两条 DNA 序列是否相关的阈值，随后 $2$ 行是两条 DNA 序列（长度不大于 $500$）。", "outputFormat": "若两条 DNA 序列相关，则输出 `yes`，否则输出`no`。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "基因相关性", "background": "", "description": "为了获知基因序列在功能和结构上的相似性，经常需要将几条不同序列的 DNA 进行比对，以判断该比对的 DNA 是否具有相关性。\n\n现比对两条长度相同的 DNA 序列。首先定义两条 DNA 序列相同位置的碱基为一个碱基对，如果一个碱基对中的两个碱基相同的话，则称为相同碱基对。接着计算相同碱基对占总碱基对数量的比例，如果该比例大于等于给定阈值时则判定该两条 DNA 序列是相关的，否则不相关。", "inputFormat": "有三行，第一行是用来判定出两条 DNA 序列是否相关的阈值，随后 $2$ 行是两条 DNA 序列（长度不大于 $500$）。", "outputFormat": "若两条 DNA 序列相关，则输出 `yes`，否则输出`no`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "B2112", "type": "B", "difficulty": 1, "samples": [["3\nRock Scissors\nPaper Paper\nRock Paper", "Player1\nTie\nPlayer2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串（入门）"], "title": "石头剪子布", "background": "", "description": "石头剪子布，是一种猜拳游戏。起源于中国，然后传到日本、朝鲜等地，随着亚欧贸易的不断发展它传到了欧洲，到了近现代逐渐风靡世界。简单明了的规则，使得石头剪子布没有任何规则漏洞可钻，单次玩法比拼运气，多回合玩法比拼心理博弈，使得石头剪子布这个古老的游戏同时用于“意外”与“技术”两种特性，深受世界人民喜爱。\n\n游戏规则：石头打剪刀，布包石头，剪刀剪布。\n\n现在，需要你写一个程序来判断石头剪子布游戏的结果。", "inputFormat": "第一行是一个整数 $N$，表示一共进行了 $N$ 次游戏。$1 \\le N \\le 100$。\n\n接下来 $N$ 行的每一行包括两个字符串，表示游戏参与者 Player1，Player2 的选择（石头、剪子或者是布）：\nS1,S2   \n\n字符串之间以空格隔开 S1 S2 只可能取值在 `Rock`,`Scissors`,`Paper` (大小写敏感）中。", "outputFormat": "输出包括 $N$ 行，每一行对应一个胜利者（Player1 或者 Player2），或者游戏出现平局，则输出 `Tie`。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "石头剪子布", "background": "", "description": "石头剪子布，是一种猜拳游戏。起源于中国，然后传到日本、朝鲜等地，随着亚欧贸易的不断发展它传到了欧洲，到了近现代逐渐风靡世界。简单明了的规则，使得石头剪子布没有任何规则漏洞可钻，单次玩法比拼运气，多回合玩法比拼心理博弈，使得石头剪子布这个古老的游戏同时用于“意外”与“技术”两种特性，深受世界人民喜爱。\n\n游戏规则：石头打剪刀，布包石头，剪刀剪布。\n\n现在，需要你写一个程序来判断石头剪子布游戏的结果。", "inputFormat": "第一行是一个整数 $N$，表示一共进行了 $N$ 次游戏。$1 \\le N \\le 100$。\n\n接下来 $N$ 行的每一行包括两个字符串，表示游戏参与者 Player1，Player2 的选择（石头、剪子或者是布）：\nS1,S2   \n\n字符串之间以空格隔开 S1 S2 只可能取值在 `Rock`,`Scissors`,`Paper` (大小写敏感）中。", "outputFormat": "输出包括 $N$ 行，每一行对应一个胜利者（Player1 或者 Player2），或者游戏出现平局，则输出 `Tie`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "B2113", "type": "B", "difficulty": 1, "samples": [["1234", "cege"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串（入门）"], "title": "输出亲朋字符串", "background": "", "description": "亲朋字符串定义如下：给定字符串 $s$ 的第一个字符的 ASCII 值加第二个字符的 ASCII 值，得到第一个亲朋字符；$s$ 的第二个字符加第三个字符得到第二个亲朋字符；依此类推。注意：亲朋字符串的最后一个字符由 $s$ 的最后一个字符 ASCII 值加 $s$ 的第一个字符的 ASCII 值。", "inputFormat": "输入一行，一个长度大于等于 $2$，小于等于 $100$ 的字符串。", "outputFormat": "输出一行，为变换后的亲朋字符串。输入保证变换后的字符串只有一行。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "输出亲朋字符串", "background": "", "description": "亲朋字符串定义如下：给定字符串 $s$ 的第一个字符的 ASCII 值加第二个字符的 ASCII 值，得到第一个亲朋字符；$s$ 的第二个字符加第三个字符得到第二个亲朋字符；依此类推。注意：亲朋字符串的最后一个字符由 $s$ 的最后一个字符 ASCII 值加 $s$ 的第一个字符的 ASCII 值。", "inputFormat": "输入一行，一个长度大于等于 $2$，小于等于 $100$ 的字符串。", "outputFormat": "输出一行，为变换后的亲朋字符串。输入保证变换后的字符串只有一行。", "hint": "", "locale": "zh-CN"}}}
{"pid": "B2114", "type": "B", "difficulty": 1, "samples": [["ATATGGATGGTGTTTGGCTCTG\n", "TATACCTACCACAAACCGAGAC\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串（入门）"], "title": "配对碱基链", "background": "", "description": "脱氧核糖核酸（DNA）由两条互补的碱基链以双螺旋的方式结合而成。\n\n而构成 DNA 的碱基共有 $4$ 种：\n\n- 分别为腺嘌呤（$A$）\n\n- 鸟嘌呤（$G$）\n\n- 胸腺嘧啶（$T$）\n\n- 胞嘧啶（$C$）\n\n我们知道，在两条互补碱基链的对应位置上，腺嘌呤总是和胸腺嘧啶配对，鸟嘌呤总是和胞嘧啶配对。\n\n你的任务就是根据一条单链上的碱基序列，给出对应的互补链上的碱基序列。", "inputFormat": "一个字符串，表示一条碱基链。\n\n这个字符串只含有大写字母 $A$ 、 $T$ 、 $G$ 、 $C$，分别表示腺嘌呤、胸腺嘧啶、鸟嘌呤和胞嘧啶。\n\n字符串长度不超过 $255$。", "outputFormat": "一个只含有大写字母 $A$ 、 $T$ 、 $G$ 、 $C$ 的字符串，为与输入的碱基链互补的碱基链。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "配对碱基链", "background": "", "description": "脱氧核糖核酸（DNA）由两条互补的碱基链以双螺旋的方式结合而成。\n\n而构成 DNA 的碱基共有 $4$ 种：\n\n- 分别为腺嘌呤（$A$）\n\n- 鸟嘌呤（$G$）\n\n- 胸腺嘧啶（$T$）\n\n- 胞嘧啶（$C$）\n\n我们知道，在两条互补碱基链的对应位置上，腺嘌呤总是和胸腺嘧啶配对，鸟嘌呤总是和胞嘧啶配对。\n\n你的任务就是根据一条单链上的碱基序列，给出对应的互补链上的碱基序列。", "inputFormat": "一个字符串，表示一条碱基链。\n\n这个字符串只含有大写字母 $A$ 、 $T$ 、 $G$ 、 $C$，分别表示腺嘌呤、胸腺嘧啶、鸟嘌呤和胞嘧啶。\n\n字符串长度不超过 $255$。", "outputFormat": "一个只含有大写字母 $A$ 、 $T$ 、 $G$ 、 $C$ 的字符串，为与输入的碱基链互补的碱基链。", "hint": "", "locale": "zh-CN"}}}
{"pid": "B2115", "type": "B", "difficulty": 1, "samples": [["Ifmmp !  Ipx  bsf  zpv!", "Hello !  How  are  you!"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串（入门）"], "title": "密码翻译", "background": "$\\text{Update on 2023.01.21 11:33:00}$：目前数据已经修复，对于题解中提到的 `@` 应视作 `A` 的问题经调查发现为一个错误，现在已经修复。", "description": "在情报传递过程中，为了防止情报被截获，往往需要对情报用一定的方式加密。我们给出一种最简单的加密方法，对给定的一个字符串，把其中从 $\\texttt{a} \\sim \\texttt{y}$，$\\texttt{A} \\sim \\texttt{Y}$ 的字母用其后继字母替代，把 $\\texttt{z}$ 和 $\\texttt{Z}$ 用 $\\texttt{a}$ 和 $\\texttt{A}$ 替代，其他非字母字符不变。请根据该加密规则将输入的密码进行解密。\n\n提示：这里需要进行**解密**操作，而不是**加密**。", "inputFormat": "一行，加密后的字符串，长度不多于 $10000$ 个字符。", "outputFormat": "一行，将密码解密后的字符串。", "hint": "感谢 @[Hughpig](https://www.luogu.com.cn/user/646208) 提供本题数据。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "密码翻译", "background": "$\\text{Update on 2023.01.21 11:33:00}$：目前数据已经修复，对于题解中提到的 `@` 应视作 `A` 的问题经调查发现为一个错误，现在已经修复。", "description": "在情报传递过程中，为了防止情报被截获，往往需要对情报用一定的方式加密。我们给出一种最简单的加密方法，对给定的一个字符串，把其中从 $\\texttt{a} \\sim \\texttt{y}$，$\\texttt{A} \\sim \\texttt{Y}$ 的字母用其后继字母替代，把 $\\texttt{z}$ 和 $\\texttt{Z}$ 用 $\\texttt{a}$ 和 $\\texttt{A}$ 替代，其他非字母字符不变。请根据该加密规则将输入的密码进行解密。\n\n提示：这里需要进行**解密**操作，而不是**加密**。", "inputFormat": "一行，加密后的字符串，长度不多于 $10000$ 个字符。", "outputFormat": "一行，将密码解密后的字符串。", "hint": "感谢 @[Hughpig](https://www.luogu.com.cn/user/646208) 提供本题数据。", "locale": "zh-CN"}}}
{"pid": "B2116", "type": "B", "difficulty": 1, "samples": [["GSOOWFASOq", "Trvdizrrvj"]], "limits": {"time": [1000, 1000, 1000], "memory": [131072, 131072, 131072]}, "tags": ["字符串（入门）"], "title": "加密的病历单", "background": "", "description": "小英是药学专业大三的学生，暑假期间获得了去医院药房实习的机会。\n\n在药房实习期间，小英扎实的专业基础获得了医生的一致好评，得知小英在计算概论中取得过好成绩后，主任又额外交给她一项任务，解密抗战时期被加密过的一些伤员的名单。\n\n经过研究，小英发现了如下加密规律（括号中是一个“**原文 → 密文**”的例子）\n\n1. 原文中所有的字符都在字母表中被循环左移了三个位置（$\\text{bcd} \\to \\text{yza}$）\n\n2. 逆序存储（$\\text{abcd} \\to \\text{dcba}$）\n\n3. 大小写反转（$\\text{abXY} \\to \\text{ABxy}$）\n\n现在给出一个**加密**的字符串，请你将其**解密**。", "inputFormat": "一个加密的字符串。（长度小于 $50$ 且只包含大小写字母）", "outputFormat": "输出解密后的字符串。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "加密的病历单", "background": "", "description": "小英是药学专业大三的学生，暑假期间获得了去医院药房实习的机会。\n\n在药房实习期间，小英扎实的专业基础获得了医生的一致好评，得知小英在计算概论中取得过好成绩后，主任又额外交给她一项任务，解密抗战时期被加密过的一些伤员的名单。\n\n经过研究，小英发现了如下加密规律（括号中是一个“**原文 → 密文**”的例子）\n\n1. 原文中所有的字符都在字母表中被循环左移了三个位置（$\\text{bcd} \\to \\text{yza}$）\n\n2. 逆序存储（$\\text{abcd} \\to \\text{dcba}$）\n\n3. 大小写反转（$\\text{abXY} \\to \\text{ABxy}$）\n\n现在给出一个**加密**的字符串，请你将其**解密**。", "inputFormat": "一个加密的字符串。（长度小于 $50$ 且只包含大小写字母）", "outputFormat": "输出解密后的字符串。", "hint": "", "locale": "zh-CN"}}}
{"pid": "B2117", "type": "B", "difficulty": 1, "samples": [["4\nAspiRin\ncisapride\n2-PENICILLIN\nCefradine-6", "Aspirin\nCisapride\n2-penicillin\nCefradine-6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串（入门）"], "title": "整理药名", "background": "", "description": "医生在书写药品名的时候经常不注意大小写，格式比较混乱。现要求你写一个程序将医生书写混乱的药品名整理成统一规范的格式，即药品名的第一个字符如果是字母要大写，其他字母小写。\n\n如将 ASPIRIN 、 aspirin 整理成 Aspirin。", "inputFormat": "第一行一个数字 $n$，表示有 $n$ 个药品名要整理，$n$ 不超过 $100$。\n\n接下来 $n$ 行，每行一个单词，长度不超过 $20$，表示医生手书的药品名。\n\n药品名由字母、数字和 - 组成。", "outputFormat": "$n$ 行，每行一个单词，对应输入的药品名的规范写法。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "整理药名", "background": "", "description": "医生在书写药品名的时候经常不注意大小写，格式比较混乱。现要求你写一个程序将医生书写混乱的药品名整理成统一规范的格式，即药品名的第一个字符如果是字母要大写，其他字母小写。\n\n如将 ASPIRIN 、 aspirin 整理成 Aspirin。", "inputFormat": "第一行一个数字 $n$，表示有 $n$ 个药品名要整理，$n$ 不超过 $100$。\n\n接下来 $n$ 行，每行一个单词，长度不超过 $20$，表示医生手书的药品名。\n\n药品名由字母、数字和 - 组成。", "outputFormat": "$n$ 行，每行一个单词，对应输入的药品名的规范写法。", "hint": "", "locale": "zh-CN"}}}
{"pid": "B2118", "type": "B", "difficulty": 1, "samples": [["abc\ndddncabca", "abc is substring of dddncabca"], ["aaa\nbbb", "No substring"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串（入门）"], "title": "验证子串", "background": "", "description": "输入两个字符串，验证其中一个串是否为另一个串的子串。", "inputFormat": "两行，每行一个字符串。", "outputFormat": "若第一个串 $s_1$ 是第二个串 $s_2$ 的子串，则输出`(s1) is substring of (s2)`；\n\n否则，若第二个串 $s_2$ 是第一个串 $s_1$ 的子串，输出`(s2) is substring of (s1)`；\n\n否则，输出 `No substring`。", "hint": "对于 $100 \\%$ 的数据，字符串长度在 $30$ 以内。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "验证子串", "background": "", "description": "输入两个字符串，验证其中一个串是否为另一个串的子串。", "inputFormat": "两行，每行一个字符串。", "outputFormat": "若第一个串 $s_1$ 是第二个串 $s_2$ 的子串，则输出`(s1) is substring of (s2)`；\n\n否则，若第二个串 $s_2$ 是第一个串 $s_1$ 的子串，输出`(s2) is substring of (s1)`；\n\n否则，输出 `No substring`。", "hint": "对于 $100 \\%$ 的数据，字符串长度在 $30$ 以内。", "locale": "zh-CN"}}}
{"pid": "B2119", "type": "B", "difficulty": 1, "samples": [["referer\n", "refer\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串（入门）"], "title": "删除单词后缀", "background": "", "description": "给定一个单词，如果该单词以 `er` 、 `ly` 或者 `ing` 后缀结尾，则删除该后缀（题目保证删除后缀后的单词长度不为 $0$），否则不进行任何操作。", "inputFormat": "输入一行，包含一个单词（单词中间没有空格，每个单词最大长度为 $32$）。", "outputFormat": "输出按照题目要求处理后的单词。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "删除单词后缀", "background": "", "description": "给定一个单词，如果该单词以 `er` 、 `ly` 或者 `ing` 后缀结尾，则删除该后缀（题目保证删除后缀后的单词长度不为 $0$），否则不进行任何操作。", "inputFormat": "输入一行，包含一个单词（单词中间没有空格，每个单词最大长度为 $32$）。", "outputFormat": "输出按照题目要求处理后的单词。", "hint": "", "locale": "zh-CN"}}}
{"pid": "B2120", "type": "B", "difficulty": 1, "samples": [["She was born in 1990-01-02  and  from Beijing city.", "3,3,4,2,10,3,4,7,5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串（入门）"], "title": "单词的长度", "background": "", "description": "输入一行单词序列，相邻单词之间由 $1$ 个或多个空格间隔，请对应地计算各个单词的长度。\n\n注意：如果有标点符号（如连字符，逗号），标点符号算作与之相连的词的一部分。没有被空格间开的符号串，都算作单词。", "inputFormat": "一行单词序列，最少 $1$ 个单词，最多 $300$ 个单词，单词之间用至少 $1$ 个空格间隔。单词序列总长度不超过 $1000$。", "outputFormat": "依次输出对应单词的长度，之间以逗号间隔。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "单词的长度", "background": "", "description": "输入一行单词序列，相邻单词之间由 $1$ 个或多个空格间隔，请对应地计算各个单词的长度。\n\n注意：如果有标点符号（如连字符，逗号），标点符号算作与之相连的词的一部分。没有被空格间开的符号串，都算作单词。", "inputFormat": "一行单词序列，最少 $1$ 个单词，最多 $300$ 个单词，单词之间用至少 $1$ 个空格间隔。单词序列总长度不超过 $1000$。", "outputFormat": "依次输出对应单词的长度，之间以逗号间隔。", "hint": "", "locale": "zh-CN"}}}
