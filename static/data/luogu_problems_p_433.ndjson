{"pid": "P9780", "type": "P", "difficulty": 3, "samples": [["3 3\n2 3 1\n", "-1 4 6 "], ["8 4\n3 2 4 2 1 2 3 2\n", "-1 -1 -1 21 22 25 29 36 "]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "O2优化", "高校校赛"], "title": "[HUSTFC 2023] Azur Lane", "background": "", "description": "你是港区的一位指挥官，你可以通过培养指挥喵来增强舰队的实力，指挥喵由对应的喵箱培育。喵箱有 $k$ 个等级，等级越高稀有度越高。你每天会获得若干个喵箱（至少一个），然后再使用 ''一键放入'' 将这些喵箱放到喵窝里进行培育。''一键放入'' 会优先放入稀有度更高的喵箱（即按照稀有度从高到低排序后依次放入），放入的喵箱会排在已放入喵箱的后面，在**每天结束时**系统会自动扣除与喵窝中喵箱数量相等的钱。最开始时你的喵窝里没有喵箱。\n\n因为你非常懒，所以你会等 $n$ 天后才把喵箱一起打开。在你 $n$ 天后进入喵窝时，你看到了 $m$ 个喵箱，用一个长度为 $m$ 的序列 $a$ 表示喵窝里按放入先后顺序排列的喵箱的等级。但是你已经忘了这 $n$ 天里你每天获得了多少喵箱了，你甚至忘了 $n$ 的值是多少，显然这有许多情况。你想知道，对于满足 $1 \\leq n \\leq m$ 的所有整数 $n$，在所有情况中，这 $n$ 天总共扣除的钱数至少为多少？", "inputFormat": "第一行包含两个整数 $m\\ (1 \\leq m \\leq 10^6)$，$k\\ (1 \\leq k \\leq 10^6)$，分别表示喵窝中喵箱的数量和喵箱的最高等级。\n\n第二行包含 $m$ 个整数 $a_{1}, a_{2}, \\ldots, a_{m}\\ (1 \\leq a_i \\leq k)$，表示喵窝中排列着的喵箱的等级。\n\n", "outputFormat": "输出一行用空格间隔的 $m$ 个整数，其中第 $i$ 个整数表示当 $n=i$ 时在所有可能的情况下至少会扣除的钱数。如果没有合法的情况，请输出 $-1$。\n\n", "hint": "样例一解释：\n\n当 $n=1$ 时，无法在一天内获得这 $3$ 个喵箱（第二个喵箱的等级大于第一个喵箱的等级，不符合 ``一键放入'' 从高到低放入的原则），因此输出 $-1$。\n\n当 $n=2$ 时，第一天获得第一个喵箱，此时喵窝内有 $1$ 个喵箱，当天花费为 $1$；第二天获得后两个喵箱，此时喵窝内有 $3$ 个喵箱，当天花费为 $3$。因此总钱数为 $4$。\n\n当 $n=3$ 时，每天依次获得一个喵箱，总钱数为 $1+2+3=6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[HUSTFC 2023] Azur Lane", "background": "", "description": "你是港区的一位指挥官，你可以通过培养指挥喵来增强舰队的实力，指挥喵由对应的喵箱培育。喵箱有 $k$ 个等级，等级越高稀有度越高。你每天会获得若干个喵箱（至少一个），然后再使用 ''一键放入'' 将这些喵箱放到喵窝里进行培育。''一键放入'' 会优先放入稀有度更高的喵箱（即按照稀有度从高到低排序后依次放入），放入的喵箱会排在已放入喵箱的后面，在**每天结束时**系统会自动扣除与喵窝中喵箱数量相等的钱。最开始时你的喵窝里没有喵箱。\n\n因为你非常懒，所以你会等 $n$ 天后才把喵箱一起打开。在你 $n$ 天后进入喵窝时，你看到了 $m$ 个喵箱，用一个长度为 $m$ 的序列 $a$ 表示喵窝里按放入先后顺序排列的喵箱的等级。但是你已经忘了这 $n$ 天里你每天获得了多少喵箱了，你甚至忘了 $n$ 的值是多少，显然这有许多情况。你想知道，对于满足 $1 \\leq n \\leq m$ 的所有整数 $n$，在所有情况中，这 $n$ 天总共扣除的钱数至少为多少？", "inputFormat": "第一行包含两个整数 $m\\ (1 \\leq m \\leq 10^6)$，$k\\ (1 \\leq k \\leq 10^6)$，分别表示喵窝中喵箱的数量和喵箱的最高等级。\n\n第二行包含 $m$ 个整数 $a_{1}, a_{2}, \\ldots, a_{m}\\ (1 \\leq a_i \\leq k)$，表示喵窝中排列着的喵箱的等级。\n\n", "outputFormat": "输出一行用空格间隔的 $m$ 个整数，其中第 $i$ 个整数表示当 $n=i$ 时在所有可能的情况下至少会扣除的钱数。如果没有合法的情况，请输出 $-1$。\n\n", "hint": "样例一解释：\n\n当 $n=1$ 时，无法在一天内获得这 $3$ 个喵箱（第二个喵箱的等级大于第一个喵箱的等级，不符合 ``一键放入'' 从高到低放入的原则），因此输出 $-1$。\n\n当 $n=2$ 时，第一天获得第一个喵箱，此时喵窝内有 $1$ 个喵箱，当天花费为 $1$；第二天获得后两个喵箱，此时喵窝内有 $3$ 个喵箱，当天花费为 $3$。因此总钱数为 $4$。\n\n当 $n=3$ 时，每天依次获得一个喵箱，总钱数为 $1+2+3=6$。", "locale": "zh-CN"}}}
{"pid": "P9781", "type": "P", "difficulty": 6, "samples": [["2", "7\n"], ["5", "26\n"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "O2优化", "高校校赛"], "title": "[HUSTFC 2023] 近似递增序列", "background": "", "description": "对于一个长度为 $m\\ (m\\ge 1)$ 的整数序列 $a_1,a_2,\\cdots,a_m\\ (a_i>0)$，如果**最多**只存在一个整数 $p\\ (1\\le p<m)$ 满足 $a_p\\ge a_{p+1}$，则可以称这样的序列为近似递增序列，同时我们定义这个近似递增序列的权值为 $\\prod_{i=1}^m a_i$。\n\n设 $f(i)$ 表示权值为 $i$ 的近似递增序列的数量，duoluoluo 想知道 $\\sum_{i=1}^n f(i)$ 的值，但是他连 $f(2)$ 都不会计算，你可以帮帮他吗？由于答案可能会非常大，你只需要求出其对 $998\\,244\\,353$ 取模后的值。", "inputFormat": "一行包含一个整数 $n\\ (1\\le n\\le 10^8)$，其含义如题目所述。", "outputFormat": "输出一个整数，表示 $\\sum_{i=1}^n f(i)$ 对 $998\\,244\\,353$ 取模后的值。", "hint": "样例一中 $7$ 个近似递增序列为：$\\{1\\}$，$\\{1,1\\}$，$\\{1,1,2\\}$，$\\{1,2\\}$，$\\{1,2,1\\}$，$\\{2\\}$，$\\{2,1\\}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[HUSTFC 2023] 近似递增序列", "background": "", "description": "对于一个长度为 $m\\ (m\\ge 1)$ 的整数序列 $a_1,a_2,\\cdots,a_m\\ (a_i>0)$，如果**最多**只存在一个整数 $p\\ (1\\le p<m)$ 满足 $a_p\\ge a_{p+1}$，则可以称这样的序列为近似递增序列，同时我们定义这个近似递增序列的权值为 $\\prod_{i=1}^m a_i$。\n\n设 $f(i)$ 表示权值为 $i$ 的近似递增序列的数量，duoluoluo 想知道 $\\sum_{i=1}^n f(i)$ 的值，但是他连 $f(2)$ 都不会计算，你可以帮帮他吗？由于答案可能会非常大，你只需要求出其对 $998\\,244\\,353$ 取模后的值。", "inputFormat": "一行包含一个整数 $n\\ (1\\le n\\le 10^8)$，其含义如题目所述。", "outputFormat": "输出一个整数，表示 $\\sum_{i=1}^n f(i)$ 对 $998\\,244\\,353$ 取模后的值。", "hint": "样例一中 $7$ 个近似递增序列为：$\\{1\\}$，$\\{1,1\\}$，$\\{1,1,2\\}$，$\\{1,2\\}$，$\\{1,2,1\\}$，$\\{2\\}$，$\\{2,1\\}$。", "locale": "zh-CN"}}}
{"pid": "P9782", "type": "P", "difficulty": 1, "samples": [["A A\n", "A\n"], ["B C\n", "D\n"], ["Z B\n", "BA\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2023", "O2优化", "高校校赛"], "title": "[HUSTFC 2023] A+B problem", "background": "", "description": "Walk Alone 是一个字符串大师，在他的眼中每个字符串都表示一个 $26$ 进制的数，具体地说，按照字母表顺序从 $A$ 到 $Z$ 分别对应着十进制下 $0$ 到 $25$，那么 $BA$ 对应十进制下 $26\\ (1\\times 26+0)$，$BB$ 对应十进制下 $27\\ (1\\times 26+1)$，以此类推。\n\nWalk Alone 想考考已经习惯了十进制加法的你，给你两个字符串 $s$ 和 $t$，请你计算出他们所表示的 $26$ 进制数的和，即 $s+t$，并同样以字符串形式告诉他，例如 $A+A=A$，$B+C=D$。为了简化问题，$s$ 和 $t$ 分别只包含一个大写字母，但请注意，答案不一定只包含一个大写字母。", "inputFormat": "一行用空格分隔的两个大写字母，分别表示 $s$ 和 $t$。", "outputFormat": "输出一行只包含大写字母的字符串，表示 $s+t$。输出的答案不包含前导 $0$，即类似 $AA$、$AB$ 的输出都是不合法的。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[HUSTFC 2023] A+B problem", "background": "", "description": "Walk Alone 是一个字符串大师，在他的眼中每个字符串都表示一个 $26$ 进制的数，具体地说，按照字母表顺序从 $A$ 到 $Z$ 分别对应着十进制下 $0$ 到 $25$，那么 $BA$ 对应十进制下 $26\\ (1\\times 26+0)$，$BB$ 对应十进制下 $27\\ (1\\times 26+1)$，以此类推。\n\nWalk Alone 想考考已经习惯了十进制加法的你，给你两个字符串 $s$ 和 $t$，请你计算出他们所表示的 $26$ 进制数的和，即 $s+t$，并同样以字符串形式告诉他，例如 $A+A=A$，$B+C=D$。为了简化问题，$s$ 和 $t$ 分别只包含一个大写字母，但请注意，答案不一定只包含一个大写字母。", "inputFormat": "一行用空格分隔的两个大写字母，分别表示 $s$ 和 $t$。", "outputFormat": "输出一行只包含大写字母的字符串，表示 $s+t$。输出的答案不包含前导 $0$，即类似 $AA$、$AB$ 的输出都是不合法的。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9783", "type": "P", "difficulty": 2, "samples": [["3", "Yes\n2 1"], ["2", "No"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2020", "Special Judge", "ROIR（俄罗斯）"], "title": "[ROIR 2020] 平方 (Day1)", "background": "", "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day1 T1.** ***[Разность квадратов](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day1.pdf)，译者 ShineEternal***\n\n你参与了字符计算系统软件模块的开发，将用于求解一类特殊的丢番图方程，具体内容如下：\n\n给定一个非负整数 $n$，正在开发的模块需要找到两个正整数 $x$ 和 $y$，使得 $x^2-y^2=n$，其中 $x,y$ 不超过 $2^{62}-1$。\n\n你需要编写一个程序，对于给定的非负整数 $n$，求出两个自然数 $x$ 和 $y$，使得它们都不超过 $2^{62}-1$ 且其平方差为 $n$。", "inputFormat": "一行一个整数 $n$。", "outputFormat": "如果存在可能的 $x,y$，则打印两行，第一行为一个单独的字符串 `Yes`，第二行打印任意一组 $x,y$。\n\n如果不存在则输出 `No`。", "hint": "对于 $100\\%$ 的数据，$0\\le n\\le 2^{60}$。\n\n| 任务编号 |          $n$           | 分值 |\n| :------: | :--------------------: | :--: |\n|   $1$    | $0 \\leq n \\leq 2^{10}$ | $10$ |\n|   $2$    | $0 \\leq n \\leq 2^{20}$ | $20$ |\n|   $3$    | $0 \\leq n \\leq 2^{30}$ | $30$ |\n|   $4$    | $0 \\leq n \\leq 2^{60}$ | $40$ |\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2020] 平方 (Day1)", "background": "", "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day1 T1.** ***[Разность квадратов](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day1.pdf)，译者 ShineEternal***\n\n你参与了字符计算系统软件模块的开发，将用于求解一类特殊的丢番图方程，具体内容如下：\n\n给定一个非负整数 $n$，正在开发的模块需要找到两个正整数 $x$ 和 $y$，使得 $x^2-y^2=n$，其中 $x,y$ 不超过 $2^{62}-1$。\n\n你需要编写一个程序，对于给定的非负整数 $n$，求出两个自然数 $x$ 和 $y$，使得它们都不超过 $2^{62}-1$ 且其平方差为 $n$。", "inputFormat": "一行一个整数 $n$。", "outputFormat": "如果存在可能的 $x,y$，则打印两行，第一行为一个单独的字符串 `Yes`，第二行打印任意一组 $x,y$。\n\n如果不存在则输出 `No`。", "hint": "对于 $100\\%$ 的数据，$0\\le n\\le 2^{60}$。\n\n| 任务编号 |          $n$           | 分值 |\n| :------: | :--------------------: | :--: |\n|   $1$    | $0 \\leq n \\leq 2^{10}$ | $10$ |\n|   $2$    | $0 \\leq n \\leq 2^{20}$ | $20$ |\n|   $3$    | $0 \\leq n \\leq 2^{30}$ | $30$ |\n|   $4$    | $0 \\leq n \\leq 2^{60}$ | $40$ |\n\n", "locale": "zh-CN"}}}
{"pid": "P9784", "type": "P", "difficulty": 3, "samples": [["3\n10 20 30\n400 500 600\n6\n1 5 10 12 16\n100 300 600 800 1000 1500\n3\n10 100\n20 70\n45 100", "0\n800\n600"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2020", "二分", "ROIR（俄罗斯）"], "title": "[ROIR 2020] 超速 (Day1)", "background": "", "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day1 T2.** ***[Превышение скорости](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day1.pdf)*** ，译者 ShineEternal\n\n超速行驶是一种危险的犯法行为，大大增加了交通事故导致悲惨后果的可能性。不幸的是使用使用雷达和相机控制速度并不能完全解决问题。为了防止这种行为的出现，根据汽车在一段道路上的行驶时间来罚款，可以对超速行为进行限制。\n\n现在有 $n$ 段从 $1\\sim n$ 编号的公路。第 $i$ 段公路长 $l_i$ 米，其限速为 $v_i$ 米每秒。超速就要罚款，但是为了体现按劳分配，还要对不同程度的超速设置不同的罚款金额。\n\n具体来说，如果不超速则不收罚款；否则，用 $e$ 表示汽车在这段公路上的**最大速度减去限速**的值：\n\n- 如果 $0<e\\leq a_1$，则惩罚为 $f_1$ 个货币单位。\n\n- 如果 $a_1<e\\leq a_2$，则惩罚为 $f_2$ 个货币单位。\n\n- ...\n\n- 如果 $a_{m-2}<e\\leq a_{m-1}$，则惩罚为 $f_{m-1}$ 个货币单位。\n\n- 如果 $a_{m-1}<e$，则惩罚为 $f_m$ 个货币单位。\n\n目前，有 $q$ 辆车要经过这 $n$ 段道路，每辆车在 $s_i$ 时间到达 $1$ 号路段，在 $t_i$ 时间离开 $n$ 号路段。\n\n你需要计算每辆车在**所有路段中最高**被罚款的金额**至少**是多少。\n\n时间从道路开放起计算，即从 $0$ 开始计算。", "inputFormat": "第一行一个正整数 $n$，表示道路段数。\n\n接下来的两行，每行 $n$ 个数，第一行为 $v_i$，第二行为 $l_i$。\n\n第四行为一个正整数 $m$，表示罚款的 $m$ 种不同范围。\n\n接下来的两行，第一行 $m-1$ 个数，为 $a_i$；第二行 $m$ 个数，为 $f_i$。\n\n第七行为一个正整数 $q$，表示共有 $q$ 辆车。\n\n接下来的 $q$ 行，每行两个整数 $s_i,t_i$。", "outputFormat": "输出共 $q$ 行。\n\n对于每辆车，输出它最少被罚款的金额。", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 10$，$1\\leq v_i,l_i,a_i,f_i\\leq 10^9$，$1\\leq m\\leq 10^5$，$1\\le q\\le 10^5$，$1\\leq s_i<t_i\\leq 10^9$。\n\n|任务编号|特殊限制|分值|\n|:-:|:-:|:-:|\n|$1$|$n=1,m=1$|$5$|\n|$2$|$m=1$|$10$|\n|$3$|$n=1,m\\leq 10$|$9$|\n|$4$|$n=1$|$12$|\n|$5$|$m\\leq 10,a_i\\leq 10$|$13$|\n|$6$|$m\\leq 10$|$14$|\n|$7$|无特殊限制|$37$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2020] 超速 (Day1)", "background": "", "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day1 T2.** ***[Превышение скорости](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day1.pdf)*** ，译者 ShineEternal\n\n超速行驶是一种危险的犯法行为，大大增加了交通事故导致悲惨后果的可能性。不幸的是使用使用雷达和相机控制速度并不能完全解决问题。为了防止这种行为的出现，根据汽车在一段道路上的行驶时间来罚款，可以对超速行为进行限制。\n\n现在有 $n$ 段从 $1\\sim n$ 编号的公路。第 $i$ 段公路长 $l_i$ 米，其限速为 $v_i$ 米每秒。超速就要罚款，但是为了体现按劳分配，还要对不同程度的超速设置不同的罚款金额。\n\n具体来说，如果不超速则不收罚款；否则，用 $e$ 表示汽车在这段公路上的**最大速度减去限速**的值：\n\n- 如果 $0<e\\leq a_1$，则惩罚为 $f_1$ 个货币单位。\n\n- 如果 $a_1<e\\leq a_2$，则惩罚为 $f_2$ 个货币单位。\n\n- ...\n\n- 如果 $a_{m-2}<e\\leq a_{m-1}$，则惩罚为 $f_{m-1}$ 个货币单位。\n\n- 如果 $a_{m-1}<e$，则惩罚为 $f_m$ 个货币单位。\n\n目前，有 $q$ 辆车要经过这 $n$ 段道路，每辆车在 $s_i$ 时间到达 $1$ 号路段，在 $t_i$ 时间离开 $n$ 号路段。\n\n你需要计算每辆车在**所有路段中最高**被罚款的金额**至少**是多少。\n\n时间从道路开放起计算，即从 $0$ 开始计算。", "inputFormat": "第一行一个正整数 $n$，表示道路段数。\n\n接下来的两行，每行 $n$ 个数，第一行为 $v_i$，第二行为 $l_i$。\n\n第四行为一个正整数 $m$，表示罚款的 $m$ 种不同范围。\n\n接下来的两行，第一行 $m-1$ 个数，为 $a_i$；第二行 $m$ 个数，为 $f_i$。\n\n第七行为一个正整数 $q$，表示共有 $q$ 辆车。\n\n接下来的 $q$ 行，每行两个整数 $s_i,t_i$。", "outputFormat": "输出共 $q$ 行。\n\n对于每辆车，输出它最少被罚款的金额。", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 10$，$1\\leq v_i,l_i,a_i,f_i\\leq 10^9$，$1\\leq m\\leq 10^5$，$1\\le q\\le 10^5$，$1\\leq s_i<t_i\\leq 10^9$。\n\n|任务编号|特殊限制|分值|\n|:-:|:-:|:-:|\n|$1$|$n=1,m=1$|$5$|\n|$2$|$m=1$|$10$|\n|$3$|$n=1,m\\leq 10$|$9$|\n|$4$|$n=1$|$12$|\n|$5$|$m\\leq 10,a_i\\leq 10$|$13$|\n|$6$|$m\\leq 10$|$14$|\n|$7$|无特殊限制|$37$|", "locale": "zh-CN"}}}
{"pid": "P9785", "type": "P", "difficulty": 4, "samples": [["5\n1 3 2 1 2", "5 8 8 6 3"], ["3\n10 10 10", "3 2 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2020", "组合数学", "前缀和", "ROIR（俄罗斯）"], "title": "[ROIR 2020] 对常规的斗争 (Day1)", "background": "", "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day1 T3.** ***[Борьба с рутиной\n](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day1.pdf)，译者ShineEternal***\n\n判断员工业绩的一个重要因素就是处理日常事务的能力。\n\n我们考虑员工连续 $n$ 天的工作情况，第 $i$ 天执行的工作为 $a_i$。\n\n为了评估员工的工作业绩，使用以下方法：\n\n选定一个整数 $d$，考虑所有 连续 $d$ 天的日期段，对于每一段这样的日子，我们统计员工完成的不同工作的种类数。\n\n记 $S_d$ 表示每一段这样连续 $d$ 天的日期段完成的不同种类工作数之和。\n\n现在需要你来统计出 $S_{1\\sim n}$ 的值。", "inputFormat": "输入共两行:\n\n第一行为一个整数 $n$，表示工作的总天数。\n\n第二行 $n$ 个整数，表示每天所做的工作种类编号。", "outputFormat": "输出共 $n$ 个数，为 $S_{1\\sim n}$。", "hint": "#### 【样例 1 解释】\n- $S_1$:\n\n| 日期段 | 所有工种 | 不同的工种的数量 |\n| :----: | :------: | :--------------: |\n| $1-1$  |   $1$    |       $1$        |\n| $2-2$  |   $3$    |       $1$        |\n| $3-3$  |   $2$    |       $1$        |\n| $4-4$  |   $1$    |       $1$        |\n| $5-5$  |   $2$    |       $1$        |\n\n\n\n所以 $S_1=1+1+1+1+1=5$。\n\n- $S_2$:\n\n|日期段|所有工种|不同的工种的数量|\n|:-:|:-:|:-:|\n|$1-2$|$1,3$|$2$|\n|$2-3$|$3,2$|$2$|\n|$3-4$|$2,1$|$2$|\n|$4-5$|$1,2$|$2$|\n\n所以 $S_2=2+2+2+2=8$。\n\n- $S_3$:\n\n|日期段|所有工种|不同的工种的数量|\n|:-:|:-:|:-:|\n|$1-3$|$1,3,2$|$3$|\n|$2-4$|$3,2,1$|$3$|\n|$3-5$|$2,1,2$|$2$|\n\n所以 $S_3=3+3+2=8$。\n\n- $S_4$:\n\n|日期段|所有工种|不同的工种的数量|\n|:-:|:-:|:-:|\n|$1-4$|$1,3,2,1$|$3$|\n|$2-5$|$3,2,1,2$|$3$|\n\n所以 $S_4=3+3=6$。\n\n- $S_5$:\n\n|日期段|所有工种|不同的工种的数量|\n|:-:|:-:|:-:|\n|$1-5$|$1,3,2,1,2$|$3$|\n\n所以 $S_5=3$。\n\n#### 【数据范围】\n对于 $100\\%$ 的数据， $1\\leq n\\leq 2\\times 10^5$，$1\\leq a_i\\leq 10^9$。\n\n|任务编号|特殊限制|分值|\n|:-:|:-:|:-:|\n|$1$|$1\\leq n \\leq 50, 1 \\leq a_i \\leq 50$|$12$|\n|$2$|$1\\leq n \\leq 50, 1 \\leq a_i \\leq 10^9$|$10$|\n|$3$|$1\\leq n \\leq 500, 1 \\leq a_i \\leq 10^9$|$10$|\n|$4$|$1\\leq n \\leq 5000, 1 \\leq a_i \\leq 5000$|$12$|\n|$5$|$1\\leq n \\leq 5000, 1 \\leq a_i \\leq 10^9$|$10$|\n|$6$|$1\\leq n \\leq 2\\times 10^5, 1 \\leq a_i \\leq 50$|$16$|\n|$7$|无特殊限制|$30$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2020] 对常规的斗争 (Day1)", "background": "", "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day1 T3.** ***[Борьба с рутиной\n](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day1.pdf)，译者ShineEternal***\n\n判断员工业绩的一个重要因素就是处理日常事务的能力。\n\n我们考虑员工连续 $n$ 天的工作情况，第 $i$ 天执行的工作为 $a_i$。\n\n为了评估员工的工作业绩，使用以下方法：\n\n选定一个整数 $d$，考虑所有 连续 $d$ 天的日期段，对于每一段这样的日子，我们统计员工完成的不同工作的种类数。\n\n记 $S_d$ 表示每一段这样连续 $d$ 天的日期段完成的不同种类工作数之和。\n\n现在需要你来统计出 $S_{1\\sim n}$ 的值。", "inputFormat": "输入共两行:\n\n第一行为一个整数 $n$，表示工作的总天数。\n\n第二行 $n$ 个整数，表示每天所做的工作种类编号。", "outputFormat": "输出共 $n$ 个数，为 $S_{1\\sim n}$。", "hint": "#### 【样例 1 解释】\n- $S_1$:\n\n| 日期段 | 所有工种 | 不同的工种的数量 |\n| :----: | :------: | :--------------: |\n| $1-1$  |   $1$    |       $1$        |\n| $2-2$  |   $3$    |       $1$        |\n| $3-3$  |   $2$    |       $1$        |\n| $4-4$  |   $1$    |       $1$        |\n| $5-5$  |   $2$    |       $1$        |\n\n\n\n所以 $S_1=1+1+1+1+1=5$。\n\n- $S_2$:\n\n|日期段|所有工种|不同的工种的数量|\n|:-:|:-:|:-:|\n|$1-2$|$1,3$|$2$|\n|$2-3$|$3,2$|$2$|\n|$3-4$|$2,1$|$2$|\n|$4-5$|$1,2$|$2$|\n\n所以 $S_2=2+2+2+2=8$。\n\n- $S_3$:\n\n|日期段|所有工种|不同的工种的数量|\n|:-:|:-:|:-:|\n|$1-3$|$1,3,2$|$3$|\n|$2-4$|$3,2,1$|$3$|\n|$3-5$|$2,1,2$|$2$|\n\n所以 $S_3=3+3+2=8$。\n\n- $S_4$:\n\n|日期段|所有工种|不同的工种的数量|\n|:-:|:-:|:-:|\n|$1-4$|$1,3,2,1$|$3$|\n|$2-5$|$3,2,1,2$|$3$|\n\n所以 $S_4=3+3=6$。\n\n- $S_5$:\n\n|日期段|所有工种|不同的工种的数量|\n|:-:|:-:|:-:|\n|$1-5$|$1,3,2,1,2$|$3$|\n\n所以 $S_5=3$。\n\n#### 【数据范围】\n对于 $100\\%$ 的数据， $1\\leq n\\leq 2\\times 10^5$，$1\\leq a_i\\leq 10^9$。\n\n|任务编号|特殊限制|分值|\n|:-:|:-:|:-:|\n|$1$|$1\\leq n \\leq 50, 1 \\leq a_i \\leq 50$|$12$|\n|$2$|$1\\leq n \\leq 50, 1 \\leq a_i \\leq 10^9$|$10$|\n|$3$|$1\\leq n \\leq 500, 1 \\leq a_i \\leq 10^9$|$10$|\n|$4$|$1\\leq n \\leq 5000, 1 \\leq a_i \\leq 5000$|$12$|\n|$5$|$1\\leq n \\leq 5000, 1 \\leq a_i \\leq 10^9$|$10$|\n|$6$|$1\\leq n \\leq 2\\times 10^5, 1 \\leq a_i \\leq 50$|$16$|\n|$7$|无特殊限制|$30$|", "locale": "zh-CN"}}}
{"pid": "P9786", "type": "P", "difficulty": 0, "samples": [["4 3 2\n1 2 1\n3 4 1\n5 6 2\n1 2 2\n3 5 1\n4 6 2\n1 4 1\n2 3 1\n5 6 2\n0 1 2 2\n2 2 1 0\n1 0 0 1", "0 1 2 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2020", "Special Judge", "ROIR（俄罗斯）"], "title": "[ROIR 2020] 机器人锦标赛 (Day1)", "background": "", "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day1 T4.** ***[Олимпиада для роботов\n](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day1.pdf)，译者 alpha1022***\n\n机器人高速布尔函数计算锦标赛的任务由评委会准备。\n\n机器人的一个任务是一张 $m$ 行 $n$ 列的表格，其中每个格子有一个整数权值，且记第 $i$ 行 $j$ 列的格子的权值为 $x_{i,j}$。  \n对于每一列，该列中所有格子的权值组成了一个 $0\\ldots m-1$ 的排列。换句话说，每列中所有格子的权值互不相同：  \n若 $i \\ne k$，则对于所有的 $j$ 有 $x_{i,j} \\ne x_{k,j}$，且有 $0 \\le x_{i,j} < m$。\n\n对于每一列，评委会设置了一个阈值 —— 一个在 $[0,m]$ 内的非负整数 $z_j$。你需要以所有形如 $x_{i,j} < z_j$ 的逻辑表达式的值为参数计算布尔函数的值。一个逻辑表达式的值为 $1$ 当且仅当这个表达式成立，否则为 $0$。\n\n在比赛中，选手们需要计算 $m$ 个布尔函数的值 —— 对每一行计算一次。每个布尔函数以一个**非重复单调线性规划**（NMLP）定义。\n\n考虑第 $i$ 行的 NMLP。  \n这是由 $n-1$ 条以 $1 \\ldots n-1$ 编号的指令组成的一个序列，第 $p$ 条指令给定三个数：$a_p, b_p, op_p$。$op_p$ 只有两种取值：$1$ 表示与运算，$2$ 表示或运算。  \n而 $a_p,b_p$ 则是第 $p$ 个指令的参数，满足 $1 \\le a_p,b_p < n+p$。\n\n考虑一个仅包含 $0$ 和 $1$ 的数组 $val[1\\ldots 2n-1]$。对于 $1 \\le j \\le n$，$val[j] = [x_{i,j} < z_j]$，其中 $[P]$ 表示表达式 $P$ 的值。  \n而 $val[n+p]$ 的值通过第 $p$ 条指令计算。\n - 对于 $op_p = 1$，$val[n+p] = (val[a_p]\\ \\texttt{and}\\ val[b_p])$。\n - 对于 $op_p = 2$，$val[n+p] = (val[a_p]\\ \\texttt{or}\\ val[b_p])$。\n\n该规划是非重复的，也就是说，对于 $p = 1\\ldots n-1$，所有 $2n-2$ 个 $a_p,b_p$ 的值互不相同。\n\n程序执行的结果即为 $val[2n-1]$。\n\n目前评委会已经准备好了所有的 $x_{i,j}$，需要由你来确定每一列的阈值才能完整地准备这个任务。  \n评委会认为一个任务是平衡的，当且仅当所有 $m$ 行中恰有 $s$ 行的布尔函数最后得到的结果为 $1$，其余 $m-s$ 行得到 $0$。  \n你的任务即为替评委会找到合适的阈值。\n\n对于此题，可以证明一定存在至少一种选择阈值的方案满足上述条件。", "inputFormat": "第一行，三个整数 $n,m,s$。  \n以下 $m(n-1)$ 行，第 $i \\cdot (n-1) + p\\;(1 \\le p \\le n-1)$ 行包含三个整数 $a_p,b_p,op_p$，表示第 $i$ 行的第 $p$ 个操作。  \n以下 $m$ 行，每行 $n$ 个整数，表示所有的 $x_{i,j}$。", "outputFormat": "输出 $n$ 个整数 $z_1, z_2, \\ldots, z_n\\;(0 \\le z_j \\le m)$。  \n如有多解，任意输出一个即可。", "hint": "#### 【样例解释】\n在此样例中共有 $3$ 行，你需要令其中恰好两行的函数值为 $1$，另一行的函数值为 $0$。\n让我们看看第一行的 $val$ 数组是什么样的。\n前四个值通过格子中的权值和阈值计算：\n- $val[1] = [x_{1,1} < z_1] = [0 < 0] = 0$；\n- $val[2] = [x_{1,2} < z_2] = [1 < 1] = 0$；\n- $val[3] = [x_{1,3} < z_3] = [2 < 2] = 0$；\n- $val[4] = [x_{1,4} < z_4] = [2 < 3] = 1$。\n\n接下来，对第一行执行线性规划：\n- $val[5] = (val[1]\\ \\texttt{and}\\ val[2]) = (0\\ \\texttt{and}\\ 0) = 0$；\n- $val[6] = (val[3]\\ \\texttt{and}\\ val[4]) = (0\\ \\texttt{and}\\ 1) = 0$；\n- $val[7] = (val[5]\\ \\texttt{or}\\ val[6]) = (0\\ \\texttt{or}\\ 0) = 0$。\n\n因此，第一行的函数值为 $0$。\n顺带一提，若我们整理一下这些式子，可得：\n$$\n[((x_{1,1} < z_1)\\ \\texttt{and}\\ (x_{1,2} < z_2))\\ \\texttt{or}\\ ((x_{1,3} < z_3)\\ \\texttt{and}\\ (x_{1,4} < z_4))]\n$$\n\n类似地，第二行和第三行的函数值分别为\n$$\n[(((x_{2,1} < z_1)\\ \\texttt{or}\\ (x_{2,2} < z_2))\\ \\texttt{and}\\ (x_{2,3} < z_3))\\ \\texttt{or}\\ (x_{2,4} < z_4)]\n$$\n\n和\n$$\n[((x_{3,1} < z_1)\\ \\texttt{and}\\ (x_{3,4} < z_4))\\ \\texttt{or}\\ ((x_{3,2} < z_2)\\ \\texttt{and}\\ (x_{3,3} < z_3))]\n$$\n\n当我们令 $z_1 = 0,z_2 = 1,z_3 = 2,z_4 = 3$ 时，我们可以得到以下表达式：\n第二行：\n$$\n[(((2 < 0)\\ \\texttt{or}\\ (2 < 1))\\ \\texttt{and}\\ (1 < 2))\\ \\texttt{or}\\ (0 < 3)] = 1\n$$\n\n第三行：\n$$\n[((1 < 0)\\ \\texttt{and}\\ (1 < 3))\\ \\texttt{or}\\ ((0 < 1)\\ \\texttt{and}\\ (0 < 2))] = 1\n$$\n\n请注意这不是唯一的解，可行的解还包括 $z_1 = 0, z_2 = 0, z_3 = 3, z_4 = 3$。\n\n\n#### 【数据范围】\n对于 $100\\%$ 的数据，$1 \\le n,m \\le 3 \\cdot 10^5,n \\cdot m \\le 3 \\cdot 10^5,0 \\le s \\le m,1 \\le a_p, b_p \\le n+p,0 \\le x_{i,j} < m$。  \n具体数据限制如下表：\n\n|子任务编号|限制|分值|\n|:-:|:-:|:-:|\n|$1$|$n \\le 2,m \\le 10^3$|$10$|\n|$2$|$n \\le 2,m \\le 10^5$|$10$|\n|$3$|$n \\le 10,m \\le 2$|$10$|\n|$4$|$x_{i,j} = i-1$|$5$|\n|$5$|$op_p=1$|$5$|\n|$6$|$n \\le 100$|$20$|\n|$7$|每一行的 NMLP 相同|$10$|\n|$8$|-|$30$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2020] 机器人锦标赛 (Day1)", "background": "", "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day1 T4.** ***[Олимпиада для роботов\n](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day1.pdf)，译者 alpha1022***\n\n机器人高速布尔函数计算锦标赛的任务由评委会准备。\n\n机器人的一个任务是一张 $m$ 行 $n$ 列的表格，其中每个格子有一个整数权值，且记第 $i$ 行 $j$ 列的格子的权值为 $x_{i,j}$。  \n对于每一列，该列中所有格子的权值组成了一个 $0\\ldots m-1$ 的排列。换句话说，每列中所有格子的权值互不相同：  \n若 $i \\ne k$，则对于所有的 $j$ 有 $x_{i,j} \\ne x_{k,j}$，且有 $0 \\le x_{i,j} < m$。\n\n对于每一列，评委会设置了一个阈值 —— 一个在 $[0,m]$ 内的非负整数 $z_j$。你需要以所有形如 $x_{i,j} < z_j$ 的逻辑表达式的值为参数计算布尔函数的值。一个逻辑表达式的值为 $1$ 当且仅当这个表达式成立，否则为 $0$。\n\n在比赛中，选手们需要计算 $m$ 个布尔函数的值 —— 对每一行计算一次。每个布尔函数以一个**非重复单调线性规划**（NMLP）定义。\n\n考虑第 $i$ 行的 NMLP。  \n这是由 $n-1$ 条以 $1 \\ldots n-1$ 编号的指令组成的一个序列，第 $p$ 条指令给定三个数：$a_p, b_p, op_p$。$op_p$ 只有两种取值：$1$ 表示与运算，$2$ 表示或运算。  \n而 $a_p,b_p$ 则是第 $p$ 个指令的参数，满足 $1 \\le a_p,b_p < n+p$。\n\n考虑一个仅包含 $0$ 和 $1$ 的数组 $val[1\\ldots 2n-1]$。对于 $1 \\le j \\le n$，$val[j] = [x_{i,j} < z_j]$，其中 $[P]$ 表示表达式 $P$ 的值。  \n而 $val[n+p]$ 的值通过第 $p$ 条指令计算。\n - 对于 $op_p = 1$，$val[n+p] = (val[a_p]\\ \\texttt{and}\\ val[b_p])$。\n - 对于 $op_p = 2$，$val[n+p] = (val[a_p]\\ \\texttt{or}\\ val[b_p])$。\n\n该规划是非重复的，也就是说，对于 $p = 1\\ldots n-1$，所有 $2n-2$ 个 $a_p,b_p$ 的值互不相同。\n\n程序执行的结果即为 $val[2n-1]$。\n\n目前评委会已经准备好了所有的 $x_{i,j}$，需要由你来确定每一列的阈值才能完整地准备这个任务。  \n评委会认为一个任务是平衡的，当且仅当所有 $m$ 行中恰有 $s$ 行的布尔函数最后得到的结果为 $1$，其余 $m-s$ 行得到 $0$。  \n你的任务即为替评委会找到合适的阈值。\n\n对于此题，可以证明一定存在至少一种选择阈值的方案满足上述条件。", "inputFormat": "第一行，三个整数 $n,m,s$。  \n以下 $m(n-1)$ 行，第 $i \\cdot (n-1) + p\\;(1 \\le p \\le n-1)$ 行包含三个整数 $a_p,b_p,op_p$，表示第 $i$ 行的第 $p$ 个操作。  \n以下 $m$ 行，每行 $n$ 个整数，表示所有的 $x_{i,j}$。", "outputFormat": "输出 $n$ 个整数 $z_1, z_2, \\ldots, z_n\\;(0 \\le z_j \\le m)$。  \n如有多解，任意输出一个即可。", "hint": "#### 【样例解释】\n在此样例中共有 $3$ 行，你需要令其中恰好两行的函数值为 $1$，另一行的函数值为 $0$。\n让我们看看第一行的 $val$ 数组是什么样的。\n前四个值通过格子中的权值和阈值计算：\n- $val[1] = [x_{1,1} < z_1] = [0 < 0] = 0$；\n- $val[2] = [x_{1,2} < z_2] = [1 < 1] = 0$；\n- $val[3] = [x_{1,3} < z_3] = [2 < 2] = 0$；\n- $val[4] = [x_{1,4} < z_4] = [2 < 3] = 1$。\n\n接下来，对第一行执行线性规划：\n- $val[5] = (val[1]\\ \\texttt{and}\\ val[2]) = (0\\ \\texttt{and}\\ 0) = 0$；\n- $val[6] = (val[3]\\ \\texttt{and}\\ val[4]) = (0\\ \\texttt{and}\\ 1) = 0$；\n- $val[7] = (val[5]\\ \\texttt{or}\\ val[6]) = (0\\ \\texttt{or}\\ 0) = 0$。\n\n因此，第一行的函数值为 $0$。\n顺带一提，若我们整理一下这些式子，可得：\n$$\n[((x_{1,1} < z_1)\\ \\texttt{and}\\ (x_{1,2} < z_2))\\ \\texttt{or}\\ ((x_{1,3} < z_3)\\ \\texttt{and}\\ (x_{1,4} < z_4))]\n$$\n\n类似地，第二行和第三行的函数值分别为\n$$\n[(((x_{2,1} < z_1)\\ \\texttt{or}\\ (x_{2,2} < z_2))\\ \\texttt{and}\\ (x_{2,3} < z_3))\\ \\texttt{or}\\ (x_{2,4} < z_4)]\n$$\n\n和\n$$\n[((x_{3,1} < z_1)\\ \\texttt{and}\\ (x_{3,4} < z_4))\\ \\texttt{or}\\ ((x_{3,2} < z_2)\\ \\texttt{and}\\ (x_{3,3} < z_3))]\n$$\n\n当我们令 $z_1 = 0,z_2 = 1,z_3 = 2,z_4 = 3$ 时，我们可以得到以下表达式：\n第二行：\n$$\n[(((2 < 0)\\ \\texttt{or}\\ (2 < 1))\\ \\texttt{and}\\ (1 < 2))\\ \\texttt{or}\\ (0 < 3)] = 1\n$$\n\n第三行：\n$$\n[((1 < 0)\\ \\texttt{and}\\ (1 < 3))\\ \\texttt{or}\\ ((0 < 1)\\ \\texttt{and}\\ (0 < 2))] = 1\n$$\n\n请注意这不是唯一的解，可行的解还包括 $z_1 = 0, z_2 = 0, z_3 = 3, z_4 = 3$。\n\n\n#### 【数据范围】\n对于 $100\\%$ 的数据，$1 \\le n,m \\le 3 \\cdot 10^5,n \\cdot m \\le 3 \\cdot 10^5,0 \\le s \\le m,1 \\le a_p, b_p \\le n+p,0 \\le x_{i,j} < m$。  \n具体数据限制如下表：\n\n|子任务编号|限制|分值|\n|:-:|:-:|:-:|\n|$1$|$n \\le 2,m \\le 10^3$|$10$|\n|$2$|$n \\le 2,m \\le 10^5$|$10$|\n|$3$|$n \\le 10,m \\le 2$|$10$|\n|$4$|$x_{i,j} = i-1$|$5$|\n|$5$|$op_p=1$|$5$|\n|$6$|$n \\le 100$|$20$|\n|$7$|每一行的 NMLP 相同|$10$|\n|$8$|-|$30$|", "locale": "zh-CN"}}}
{"pid": "P9787", "type": "P", "difficulty": 2, "samples": [["3\n1 2 3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2020", "Special Judge", "ROIR（俄罗斯）"], "title": "[ROIR 2020] 最大乘积 (Day2)", "background": "", "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day2 T1.** ***[Максимальное произведение](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day2.pdf)***，译者ShineEternal\n\n给定一个自然数组成的数组 $[a_1,a_2,\\ldots,a_n]$。  \n定义一个数组的权值为这个数组中所有数的和。\n\n请把这个数组划分为两个非空数组 $[a_1,a_2,\\ldots,a_i]$ 和 $[a_{i+1},a_{i+2},\\ldots,a_n]$，使得它们的权值之积尽量大。  \n你需要确定能够使得两个数组权值之积最大的 $i$。", "inputFormat": "第一行，一个整数 $n$，表示元素的个数。  \n第二行，$n$ 个整数 $a_1,a_2,\\ldots,a_n$，表示数组中的元素。", "outputFormat": "输出能使得 $[a_1,a_2,\\ldots,a_i]$ 和 $[a_{i+1},a_{i+2},\\ldots,a_n]$ 权值之积最大的 $i$。  \n若有多解，随意输出一解即可。", "hint": "#### 【样例 1 解释】\n如果你选择 $i=1$，则权值之积为 $1 \\cdot (2+3) = 5$。\n如果你选择 $i=2$，则权值之积为 $(1+2) \\cdot 3 = 9$。\n\n#### 【数据范围】\n对于 $100\\%$ 的数据，$2 \\le n \\le 2\\cdot 10^5, 1 \\le a_i \\le 10^9$。  \n具体数据限制如下表：\n\n|子任务编号|分值|限制|附加限制|\n|:-:|:-:|:-:|:-:|\n|$1$|$10$|$2 \\le n \\le 5000$|$\\sum a_i \\le 10^9$|\n|$2$|$10$|$2 \\le n \\le 5000$|$a_1 = a_2 = \\ldots = a_n$|\n|$3$|$20$|$2 \\le n \\le 5000$|$a_i \\le 10^9$|\n|$4$|$20$|$2 \\le n \\le 200000$|$\\sum a_i \\le 10^9$|\n|$5$|$20$|$2 \\le n \\le 200000$|$a_1 = a_2 = \\ldots = a_n$|\n|$6$|$20$|$2 \\le n \\le 200000$|$a_i \\le 10^9$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2020] 最大乘积 (Day2)", "background": "", "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day2 T1.** ***[Максимальное произведение](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day2.pdf)***，译者ShineEternal\n\n给定一个自然数组成的数组 $[a_1,a_2,\\ldots,a_n]$。  \n定义一个数组的权值为这个数组中所有数的和。\n\n请把这个数组划分为两个非空数组 $[a_1,a_2,\\ldots,a_i]$ 和 $[a_{i+1},a_{i+2},\\ldots,a_n]$，使得它们的权值之积尽量大。  \n你需要确定能够使得两个数组权值之积最大的 $i$。", "inputFormat": "第一行，一个整数 $n$，表示元素的个数。  \n第二行，$n$ 个整数 $a_1,a_2,\\ldots,a_n$，表示数组中的元素。", "outputFormat": "输出能使得 $[a_1,a_2,\\ldots,a_i]$ 和 $[a_{i+1},a_{i+2},\\ldots,a_n]$ 权值之积最大的 $i$。  \n若有多解，随意输出一解即可。", "hint": "#### 【样例 1 解释】\n如果你选择 $i=1$，则权值之积为 $1 \\cdot (2+3) = 5$。\n如果你选择 $i=2$，则权值之积为 $(1+2) \\cdot 3 = 9$。\n\n#### 【数据范围】\n对于 $100\\%$ 的数据，$2 \\le n \\le 2\\cdot 10^5, 1 \\le a_i \\le 10^9$。  \n具体数据限制如下表：\n\n|子任务编号|分值|限制|附加限制|\n|:-:|:-:|:-:|:-:|\n|$1$|$10$|$2 \\le n \\le 5000$|$\\sum a_i \\le 10^9$|\n|$2$|$10$|$2 \\le n \\le 5000$|$a_1 = a_2 = \\ldots = a_n$|\n|$3$|$20$|$2 \\le n \\le 5000$|$a_i \\le 10^9$|\n|$4$|$20$|$2 \\le n \\le 200000$|$\\sum a_i \\le 10^9$|\n|$5$|$20$|$2 \\le n \\le 200000$|$a_1 = a_2 = \\ldots = a_n$|\n|$6$|$20$|$2 \\le n \\le 200000$|$a_i \\le 10^9$|", "locale": "zh-CN"}}}
{"pid": "P9788", "type": "P", "difficulty": 3, "samples": [["3 0", "1"], ["5 0", "5"], ["5 3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2020", "剪枝", "扩展欧几里德算法", "ROIR（俄罗斯）"], "title": "[ROIR 2020] 区域规划 (Day2)", "background": "", "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day2 T2.** ***[Планировка участка](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day2.pdf)***，译者Alpha1022\n\n*译者注：由于原题面有点令译者难以理解，所以此处直接抽象题意。*\n\n你有四个变量 $a,b,c,d$ 须满足：\n - $a,b,c,d \\in \\mathbb N^*$。\n - $a \\ne x, b \\ne x$。\n - $a > c, b > d$。\n - $a \\cdot b - c \\cdot d = n$。\n\n对于给定的 $x,n$，请求出 $a,b,c,d$ 有多少种取值方案。", "inputFormat": "第一行，两个整数 $n,x$。  \n若 $x=0$，则表示忽略第二个条件。", "outputFormat": "一行，表示 $a,b,c,d$ 的取值方案数。", "hint": "#### 【样例 1 解释】\n此时只有 $a=2,b=2,c=1,d=1$ 是合法的。\n\n#### 【样例 2 解释】\n此时有以下方案是合法的：\n- $a=2,b=3,c=1,d=1$；\n- $a=2,b=4,c=1,d=3$；\n- $a=3,b=2,c=1,d=1$；\n- $a=3,b=3,c=2,d=2$；\n- $a=4,b=2,c=3,d=1$。\n\n#### 【样例 3 解释】\n此时有以下方案是合法的：\n- $a=2,b=4,c=1,d=3$；\n- $a=4,b=2,c=3,d=1$。\n\n#### 【数据范围】\n对于 $100\\%$ 的数据，$1 \\le n \\le 3000, 0 \\le x \\le 3000$。  \n具体数据限制如下表：\n\n|子任务编号|分值|限制|\n|:-:|:-:|:-:|\n|$1$|$11$|$1 \\le n \\le 50, x=0$|\n|$2$|$10$|$1 \\le n \\le 50$|\n|$3$|$20$|$1 \\le n \\le 500, x=0$|\n|$4$|$22$|$1 \\le n \\le 500$|\n|$5$|$17$|$1 \\le n \\le 3000, x=0$|\n|$6$|$20$|$1 \\le n \\le 3000$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2020] 区域规划 (Day2)", "background": "", "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day2 T2.** ***[Планировка участка](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day2.pdf)***，译者Alpha1022\n\n*译者注：由于原题面有点令译者难以理解，所以此处直接抽象题意。*\n\n你有四个变量 $a,b,c,d$ 须满足：\n - $a,b,c,d \\in \\mathbb N^*$。\n - $a \\ne x, b \\ne x$。\n - $a > c, b > d$。\n - $a \\cdot b - c \\cdot d = n$。\n\n对于给定的 $x,n$，请求出 $a,b,c,d$ 有多少种取值方案。", "inputFormat": "第一行，两个整数 $n,x$。  \n若 $x=0$，则表示忽略第二个条件。", "outputFormat": "一行，表示 $a,b,c,d$ 的取值方案数。", "hint": "#### 【样例 1 解释】\n此时只有 $a=2,b=2,c=1,d=1$ 是合法的。\n\n#### 【样例 2 解释】\n此时有以下方案是合法的：\n- $a=2,b=3,c=1,d=1$；\n- $a=2,b=4,c=1,d=3$；\n- $a=3,b=2,c=1,d=1$；\n- $a=3,b=3,c=2,d=2$；\n- $a=4,b=2,c=3,d=1$。\n\n#### 【样例 3 解释】\n此时有以下方案是合法的：\n- $a=2,b=4,c=1,d=3$；\n- $a=4,b=2,c=3,d=1$。\n\n#### 【数据范围】\n对于 $100\\%$ 的数据，$1 \\le n \\le 3000, 0 \\le x \\le 3000$。  \n具体数据限制如下表：\n\n|子任务编号|分值|限制|\n|:-:|:-:|:-:|\n|$1$|$11$|$1 \\le n \\le 50, x=0$|\n|$2$|$10$|$1 \\le n \\le 50$|\n|$3$|$20$|$1 \\le n \\le 500, x=0$|\n|$4$|$22$|$1 \\le n \\le 500$|\n|$5$|$17$|$1 \\le n \\le 3000, x=0$|\n|$6$|$20$|$1 \\le n \\le 3000$|", "locale": "zh-CN"}}}
{"pid": "P9789", "type": "P", "difficulty": 5, "samples": [["4\n1 5 10 50\n3\n2\n8\n50", "2 2\n8 4\n49 9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2020", "Special Judge", "ROIR（俄罗斯）"], "title": "[ROIR 2020] ATM (Day 2)", "background": null, "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day2 T3.** ***[Банкомат](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day2.pdf)***,译者ksyx\n\n你正在开发一个多面额 ATM，称为 Universal ATM。具体地说，现在有 $n$ 种升序排序的面额分别为 $a_1,~a_2,~\\ldots,~a_n$ 的纸币，即对于 $i>2$，有 $a_{i-1}<a_i$。除此之外，还保证 $a_1=1$。\n\n假设客户要取总额为 $c$ 的纸币，你开发的 ATM 将使用如下算法进行纸币的分配：每次选取一个选取后发给用户的总金额不超过 $c$ 最大面额，直至总金额达到 $c$。因为存在面额为 $1$ 的纸币，我们可以发现这个算法总是能够结束。\n\n为了评估这个算法的效率，你想知道对于总额不超过 $b$ 的请求最大需要多少张纸币。因为业务场景不同，你总共需要回答 $q$ 个场景下的询问 $b_1,~b_2,~\\ldots,~b_q$。\n\n你的任务是编写一个程序，根据给出的面额列表确定在不同业务场景下最大需要多少张纸币。", "inputFormat": "第一行一个整数 $n$，表示面额的数量。\n\n接下来一行 $n$ 个整数 $a_i$。\n\n第三行一个整数 $q$，表示询问的数量。\n\n接下来 $q$ 行每行一个整数 $b_i$。", "outputFormat": "对于每一个询问，输出两个整数，分别表示取出纸币数量最多的情况下客户取出的总额和取出纸币的数量。如果多个不超过输入中最大总额的取款请求都对应这个纸币数量，输出任意一个。", "hint": "#### 【样例 1 解释】\n各个询问的一种可行解如下：\n\n$2=1+1$，$8=5+1+1+1$，$49=10+10+10+10+5+1+1+1+1$。\n\n#### 【数据范围】\n对于 $100\\%$ 的数据，有 $1\\le n\\le 2\\times 10^5$，$1=a_1<a_2<\\ldots<a_n\\le10^{18}$，$1\\le q\\le 2\\times 10^5$，$1\\le b_i\\le 10^{18}$。\n\n各子任务详情如下：\n\n|子任务编号|分值|限制|\n|:-:|:-:|:-:|\n|$1$|$13$|$1 \\le n \\le 500,~q\\le 5,~1\\le a_i,b_i\\le500$|\n|$2$|$18$|$n=60,~q\\le 5,~a_i=2^{i-1}$|\n|$3$|$20$|$q\\le 5,~b_i\\le 2\\times 10^5$|\n|$4$|$21$|$q\\le 5$|\n|$5$|$28$||", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2020] ATM (Day 2)", "background": null, "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day2 T3.** ***[Банкомат](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day2.pdf)***,译者ksyx\n\n你正在开发一个多面额 ATM，称为 Universal ATM。具体地说，现在有 $n$ 种升序排序的面额分别为 $a_1,~a_2,~\\ldots,~a_n$ 的纸币，即对于 $i>2$，有 $a_{i-1}<a_i$。除此之外，还保证 $a_1=1$。\n\n假设客户要取总额为 $c$ 的纸币，你开发的 ATM 将使用如下算法进行纸币的分配：每次选取一个选取后发给用户的总金额不超过 $c$ 最大面额，直至总金额达到 $c$。因为存在面额为 $1$ 的纸币，我们可以发现这个算法总是能够结束。\n\n为了评估这个算法的效率，你想知道对于总额不超过 $b$ 的请求最大需要多少张纸币。因为业务场景不同，你总共需要回答 $q$ 个场景下的询问 $b_1,~b_2,~\\ldots,~b_q$。\n\n你的任务是编写一个程序，根据给出的面额列表确定在不同业务场景下最大需要多少张纸币。", "inputFormat": "第一行一个整数 $n$，表示面额的数量。\n\n接下来一行 $n$ 个整数 $a_i$。\n\n第三行一个整数 $q$，表示询问的数量。\n\n接下来 $q$ 行每行一个整数 $b_i$。", "outputFormat": "对于每一个询问，输出两个整数，分别表示取出纸币数量最多的情况下客户取出的总额和取出纸币的数量。如果多个不超过输入中最大总额的取款请求都对应这个纸币数量，输出任意一个。", "hint": "#### 【样例 1 解释】\n各个询问的一种可行解如下：\n\n$2=1+1$，$8=5+1+1+1$，$49=10+10+10+10+5+1+1+1+1$。\n\n#### 【数据范围】\n对于 $100\\%$ 的数据，有 $1\\le n\\le 2\\times 10^5$，$1=a_1<a_2<\\ldots<a_n\\le10^{18}$，$1\\le q\\le 2\\times 10^5$，$1\\le b_i\\le 10^{18}$。\n\n各子任务详情如下：\n\n|子任务编号|分值|限制|\n|:-:|:-:|:-:|\n|$1$|$13$|$1 \\le n \\le 500,~q\\le 5,~1\\le a_i,b_i\\le500$|\n|$2$|$18$|$n=60,~q\\le 5,~a_i=2^{i-1}$|\n|$3$|$20$|$q\\le 5,~b_i\\le 2\\times 10^5$|\n|$4$|$21$|$q\\le 5$|\n|$5$|$28$||", "locale": "zh-CN"}}}
{"pid": "P9790", "type": "P", "difficulty": 6, "samples": [["6\n1 2 3 4 5 6\n2\n6 0\n2 5", "17\n13\n15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2020", "O2优化", "ROIR（俄罗斯）"], "title": "[ROIR 2020] 海报 (Day 2)", "background": null, "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day2 T4.** ***[Плакаты](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day2.pdf)***,译者ksyx\n\n你的朋友们为了会见 IOI 回来的国家队选手准备了很多漂亮的海报，现在就还差要考虑些细节了。\n\n为了欢迎这些选手，你的 $n$ 个朋友会拿着海报站成一个圈。为了方便描述，我们把他们编号为朋友 $1\\ldots n$，其中对于 $i\\in [1,n-1]$，朋友 $i$ 和朋友 $i+1$ 站在一起，且朋友 $n$ 和朋友 $1$ 站在一起。\n\n每张海报都有一个美观度，其中朋友 $i$ 拿着的海报的美观度为 $a_i$。当开始庆祝时，一些朋友会举起他们的海报。为了美观，不能有 $4$ 个或以上排在一起的朋友同时举起他们的海报。\n\n为了能够丰富节目效果，你的朋友们还打算在庆祝过程中更换 $q$ 次海报。每次更换后，海报 $p_i$ 的美观度将变为 $v_i$。你的朋友想知道每次更换后在符合上述条件下的最大美观度之和。\n\n你的任务是给出初始的美观度，求出初始以及各次更换后的最大美观度之和。\n\n*译者注：题面省略了部分难以理解的不必要细节。*", "inputFormat": "第一行一个整数 $n$，朋友总数。\n\n接下来一行 $n$ 个整数 $a_i$，表示初始美观度。\n\n第三行 $q$ 个整数表示海报更换次数。\n\n接下来 $q$ 行每行两个整数 $p_i,~v_i$，描述一次更换。", "outputFormat": "输出 $q+1$ 行，表示初始时及各次更换后最大的美观度之和。", "hint": "#### 【样例 1 解释】\n初始状态下最佳方案为让朋友 $2,~4,~5,~6$ 举起海报，此时美观度之和为 $17$。\n\n第一次改变后朋友 $6$ 的海报美观度变为 $0$，在此情况下最佳方案为让朋友 $1,~3,~4,~5$ 举起海报，美观度之和为 $13$。\n\n第二次改变后朋友 $2$ 的海报美观度变为 $5$，在此情况下最佳方案为让朋友 $1,~2,~4,~5$ 举起海报，美观度之和为 $15$。\n\n#### 【数据范围】\n对于 $100\\%$ 的数据，有 $4\\le n\\le 40000,~0\\le a_i,~v_i\\le 10^9,~1\\le p_i\\le n,~0\\le q\\le 40000$。\n\n\n各子任务如下：\n\n|子任务编号|分值|限制|\n|:-:|:-:|:-:|\n|$1$|$11$|$4 \\le n \\le 10,~q=0$|\n|$2$|$12$|$4 \\le n \\le 10,~0\\le q\\le 10$|\n|$3$|$13$|$4 \\le n \\le 1000,~0\\le q\\le 1000$|\n|$4$|$17$|$4 \\le n \\le 40000,~q=0$|\n|$5$|$47$|$4 \\le n \\le 40000, 0\\le q\\le 40000$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2020] 海报 (Day 2)", "background": null, "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day2 T4.** ***[Плакаты](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day2.pdf)***,译者ksyx\n\n你的朋友们为了会见 IOI 回来的国家队选手准备了很多漂亮的海报，现在就还差要考虑些细节了。\n\n为了欢迎这些选手，你的 $n$ 个朋友会拿着海报站成一个圈。为了方便描述，我们把他们编号为朋友 $1\\ldots n$，其中对于 $i\\in [1,n-1]$，朋友 $i$ 和朋友 $i+1$ 站在一起，且朋友 $n$ 和朋友 $1$ 站在一起。\n\n每张海报都有一个美观度，其中朋友 $i$ 拿着的海报的美观度为 $a_i$。当开始庆祝时，一些朋友会举起他们的海报。为了美观，不能有 $4$ 个或以上排在一起的朋友同时举起他们的海报。\n\n为了能够丰富节目效果，你的朋友们还打算在庆祝过程中更换 $q$ 次海报。每次更换后，海报 $p_i$ 的美观度将变为 $v_i$。你的朋友想知道每次更换后在符合上述条件下的最大美观度之和。\n\n你的任务是给出初始的美观度，求出初始以及各次更换后的最大美观度之和。\n\n*译者注：题面省略了部分难以理解的不必要细节。*", "inputFormat": "第一行一个整数 $n$，朋友总数。\n\n接下来一行 $n$ 个整数 $a_i$，表示初始美观度。\n\n第三行 $q$ 个整数表示海报更换次数。\n\n接下来 $q$ 行每行两个整数 $p_i,~v_i$，描述一次更换。", "outputFormat": "输出 $q+1$ 行，表示初始时及各次更换后最大的美观度之和。", "hint": "#### 【样例 1 解释】\n初始状态下最佳方案为让朋友 $2,~4,~5,~6$ 举起海报，此时美观度之和为 $17$。\n\n第一次改变后朋友 $6$ 的海报美观度变为 $0$，在此情况下最佳方案为让朋友 $1,~3,~4,~5$ 举起海报，美观度之和为 $13$。\n\n第二次改变后朋友 $2$ 的海报美观度变为 $5$，在此情况下最佳方案为让朋友 $1,~2,~4,~5$ 举起海报，美观度之和为 $15$。\n\n#### 【数据范围】\n对于 $100\\%$ 的数据，有 $4\\le n\\le 40000,~0\\le a_i,~v_i\\le 10^9,~1\\le p_i\\le n,~0\\le q\\le 40000$。\n\n\n各子任务如下：\n\n|子任务编号|分值|限制|\n|:-:|:-:|:-:|\n|$1$|$11$|$4 \\le n \\le 10,~q=0$|\n|$2$|$12$|$4 \\le n \\le 10,~0\\le q\\le 10$|\n|$3$|$13$|$4 \\le n \\le 1000,~0\\le q\\le 1000$|\n|$4$|$17$|$4 \\le n \\le 40000,~q=0$|\n|$5$|$47$|$4 \\le n \\le 40000, 0\\le q\\le 40000$|", "locale": "zh-CN"}}}
{"pid": "P9791", "type": "P", "difficulty": 6, "samples": [["6\n75 0\n90 90\n20 0\n0 75\n78 50\n80 100", "3:0\n25:0 25:0 25:0\n3:1\n25:22 25:22 15:25 25:21\nImpossible\n0:3\n0:25 0:25 0:25\n3:0\n25:11 28:26 25:13\n3:2\n25:17 0:25 25:22 15:25 15:11"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2018] Alice the Fan", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) A 题。", "description": "Alice 喜欢看排球比赛，她尤其喜欢看 A 队打球，排球比赛的规则如下：\n\n- 一场比赛最多有 $5$ 局。\n\n- 前面 $4$ 均需获得至少 $25$ 分方可获胜，第 $5$ 局仅需获得 $15$ 分。\n\n- 如果单局内其中一方满足获胜条件**但是**双方比分之差不满 $2$，不算获胜。\n\n- 有一方比分达到 $3$ 即为获胜，此时立刻结束比赛。\n\n现在分别给你 A 队和 B 队赢球的个数，请你帮忙确定 A 队最好的比分是多少，或者确定这场球赛还没有结束。\n\n（注：本题定义最好的比分为，如果 A 队可以赢，要使得它们两队的比分差尽可能大，反之尽可能小。）", "inputFormat": "第一行一个整数 $m(1 \\leq m \\leq 50000)$，表示 A 队打过 $m$ 场不同的比赛。\n\n接下来 $m$ 行，每行两个整数 $a(1 \\leq a \\leq 200)$ 和 $b(1 \\leq b \\leq 200)$，分别表示该场比赛 A 队和 B 队的得分。", "outputFormat": "对于每场比赛，输出 A 队最好的比分情况和一种符合条件的**每场**的比分，或者确定这是不可能的，输出 `Impossible`。", "hint": "测试数据保证 $1 \\leq m \\leq 50000$，$1 \\leq a,b \\leq 200$。\n\n注：由于技术原因，SPJ 在评测时出现 UKE 是因为您的代码存在谬误，造成了 SPJ 读取字符时多/少读取到了，后面便无法正常评测。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NERC 2018] Alice the Fan", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) A 题。", "description": "Alice 喜欢看排球比赛，她尤其喜欢看 A 队打球，排球比赛的规则如下：\n\n- 一场比赛最多有 $5$ 局。\n\n- 前面 $4$ 均需获得至少 $25$ 分方可获胜，第 $5$ 局仅需获得 $15$ 分。\n\n- 如果单局内其中一方满足获胜条件**但是**双方比分之差不满 $2$，不算获胜。\n\n- 有一方比分达到 $3$ 即为获胜，此时立刻结束比赛。\n\n现在分别给你 A 队和 B 队赢球的个数，请你帮忙确定 A 队最好的比分是多少，或者确定这场球赛还没有结束。\n\n（注：本题定义最好的比分为，如果 A 队可以赢，要使得它们两队的比分差尽可能大，反之尽可能小。）", "inputFormat": "第一行一个整数 $m(1 \\leq m \\leq 50000)$，表示 A 队打过 $m$ 场不同的比赛。\n\n接下来 $m$ 行，每行两个整数 $a(1 \\leq a \\leq 200)$ 和 $b(1 \\leq b \\leq 200)$，分别表示该场比赛 A 队和 B 队的得分。", "outputFormat": "对于每场比赛，输出 A 队最好的比分情况和一种符合条件的**每场**的比分，或者确定这是不可能的，输出 `Impossible`。", "hint": "测试数据保证 $1 \\leq m \\leq 50000$，$1 \\leq a,b \\leq 200$。\n\n注：由于技术原因，SPJ 在评测时出现 UKE 是因为您的代码存在谬误，造成了 SPJ 读取字符时多/少读取到了，后面便无法正常评测。", "locale": "zh-CN"}}}
{"pid": "P9792", "type": "P", "difficulty": 6, "samples": [["2\n2 3\n111\n111\n3 4\n0110\n1100\n0011", "1\n2"], ["1\n3 6\n001100\n111111\n001100", "2"]], "limits": {"time": [1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "ICPC", "NERC/NEERC"], "title": "[NERC 2018]  Bimatching", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) B 题。", "description": "你与一些好友一起举办了一个舞会！\n\n在这个舞会上，有 $n$ 位男性和 $m$ 位女性，本来舞蹈的形式是一男一女跳的，但是由于男性紧缺，你并不能让所有女性都有一个男性舞伴，于是你发明了一种新的舞蹈形式：一个男性，搭配两个女舞伴。\n\n当然，每个女性在挑选舞伴时，都会对那些男性舞伴做出评价，如果评价是 $1$，说明这位女性愿意和这位男性一起跳舞，只有当两位女性都愿意和那位男性跳舞时，才能成为一对舞伴。\n\n你作为一个组织者，自然要为大家着想，你需要求出能凑出的最多的舞伴对数，**每个舞伴不能重叠**。", "inputFormat": "第一行一个数 $t (1 \\leq t \\leq 20)$，表示数据组数。\n\n接下来 $t$ 组数据，每组第一行两个整数 $n$ 和 $m$，此处我们保证 $1 \\leq n,m$ 且 $n + m \\leq 150$。\n\n然后一个 $n \\times m$ 的矩阵，$a_{i,j}$ 表示 $j$ 号女士是否愿意和 $i$ 号男士一起跳舞。", "outputFormat": "对于每组测试数据，输出一行，表示最多能凑出的舞伴对数。", "hint": "数据保证 $1 \\leq t \\leq 20$，$1 \\leq n, m$ 且 $n + m \\leq 150$。\n\n下图是对样例一和样例二的解释，其中加粗部分表示其中的一种可行方案。\n\n样例一：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9dfwv4dr.png)\n\n样例二：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/woscpjcn.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NERC 2018]  Bimatching", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) B 题。", "description": "你与一些好友一起举办了一个舞会！\n\n在这个舞会上，有 $n$ 位男性和 $m$ 位女性，本来舞蹈的形式是一男一女跳的，但是由于男性紧缺，你并不能让所有女性都有一个男性舞伴，于是你发明了一种新的舞蹈形式：一个男性，搭配两个女舞伴。\n\n当然，每个女性在挑选舞伴时，都会对那些男性舞伴做出评价，如果评价是 $1$，说明这位女性愿意和这位男性一起跳舞，只有当两位女性都愿意和那位男性跳舞时，才能成为一对舞伴。\n\n你作为一个组织者，自然要为大家着想，你需要求出能凑出的最多的舞伴对数，**每个舞伴不能重叠**。", "inputFormat": "第一行一个数 $t (1 \\leq t \\leq 20)$，表示数据组数。\n\n接下来 $t$ 组数据，每组第一行两个整数 $n$ 和 $m$，此处我们保证 $1 \\leq n,m$ 且 $n + m \\leq 150$。\n\n然后一个 $n \\times m$ 的矩阵，$a_{i,j}$ 表示 $j$ 号女士是否愿意和 $i$ 号男士一起跳舞。", "outputFormat": "对于每组测试数据，输出一行，表示最多能凑出的舞伴对数。", "hint": "数据保证 $1 \\leq t \\leq 20$，$1 \\leq n, m$ 且 $n + m \\leq 150$。\n\n下图是对样例一和样例二的解释，其中加粗部分表示其中的一种可行方案。\n\n样例一：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9dfwv4dr.png)\n\n样例二：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/woscpjcn.png)", "locale": "zh-CN"}}}
{"pid": "P9793", "type": "P", "difficulty": 5, "samples": [["5 2\n5 1 2 3 4 5\n2 1 3\n\nFOUND\nGO 4\nFOUND\nGO 2\nFOUND\nGO 1\nFOUND\nGO 4\nGO 5\nFOUND", "\n\n\n\n3\n3\n4\n3\n2\n3\n1\n3\n4\n5"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "交互题", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2018] Cactus Search", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) C 题。\n\n如果你想让数组问题更难解决，可以在树上解决；如果你想让树的问题更难解决，可以在仙人掌上解决。", "description": "在前几年，就有过人提出了许多关于仙人掌——连通无向图的问题，其中每条边最多属于一个简单的循环。更加直观地说，仙人掌是一棵树的概括，在这棵树上允许有一些环。下面的图片给出了仙人掌的一个例子。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/a44vr6aa.png)\n\n你和 Chloe 在一个仙人掌上玩游戏，你有一株仙人掌，但是淘气的 Chloe 偷偷拿走了一个顶点 $v$，你需要在 $10$ 次以内猜出 $v$，如果你猜到了 $v$，那你就赢了，如果你猜测的是另一个点 $u$，Chloe 会告诉你一个点 $w$，其中 $w$ 到 $v$ 经过的边数严格小于 $u$ 到 $v$。", "inputFormat": "首先，第一行给你两个整数 $n$ 和 $m$，其中 $n$ 表示一共有 $n$ 个顶点，图的边由一组边不同的路径表示，$m$ 表示它们的数量。\n\n接下来一行，$m$ 个整数 $k_i$，表示该条路径经过了 $k_i$ 个顶点，然后接下来 $k_i$ 个整数，表示一次经过的路径（不会重复经过点）。输入中的图形是一个仙人掌。每次猜测，程序会返回你一些返回值，如果是 `FOUND`，说明你猜对了，否则是 `GO w`，表示 $w$ 到 $v$ 经过的边数严格小于你猜测的点到 $v$ 的边数。你的程序每次询问要猜测不超过 $10$ 次，如果你猜测的次数 $> 10$ 次，那么你就不通过该测试点。\n\n此外为了避免你是蒙对的，需要进行 $n$ 次询问，每次猜测成功后，你直接进行下一轮询问，询问 $n$ 次完直接退出。", "outputFormat": "每次询问，你需要向**标准输出**输出一个整数 $u$，代表你猜测的结果，**然后清空缓冲区**。\n\n你可以使用如下语句来清空缓冲区：\n\n- 对于 C/C++：`fflush(stdout)`；\n- 对于 C++：`std::cout << std::flush`；\n- 对于 Java：`System.out.flush()`；\n- 对于 Python：`stdout.flush()`；\n- 对于 Pascal：`flush(output)`；\n- 对于其他语言，请自行查阅对应语言的帮助文档。", "hint": "数据保证 $1 \\leq n \\leq 500$，$0 \\leq m \\leq 500$，$1 \\leq k_i \\leq 500$。\n\n注：为了方便比对，在样例输入输出上加入了一些空行进行对齐，实际输入输出中没有这些空行。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NERC 2018] Cactus Search", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) C 题。\n\n如果你想让数组问题更难解决，可以在树上解决；如果你想让树的问题更难解决，可以在仙人掌上解决。", "description": "在前几年，就有过人提出了许多关于仙人掌——连通无向图的问题，其中每条边最多属于一个简单的循环。更加直观地说，仙人掌是一棵树的概括，在这棵树上允许有一些环。下面的图片给出了仙人掌的一个例子。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/a44vr6aa.png)\n\n你和 Chloe 在一个仙人掌上玩游戏，你有一株仙人掌，但是淘气的 Chloe 偷偷拿走了一个顶点 $v$，你需要在 $10$ 次以内猜出 $v$，如果你猜到了 $v$，那你就赢了，如果你猜测的是另一个点 $u$，Chloe 会告诉你一个点 $w$，其中 $w$ 到 $v$ 经过的边数严格小于 $u$ 到 $v$。", "inputFormat": "首先，第一行给你两个整数 $n$ 和 $m$，其中 $n$ 表示一共有 $n$ 个顶点，图的边由一组边不同的路径表示，$m$ 表示它们的数量。\n\n接下来一行，$m$ 个整数 $k_i$，表示该条路径经过了 $k_i$ 个顶点，然后接下来 $k_i$ 个整数，表示一次经过的路径（不会重复经过点）。输入中的图形是一个仙人掌。每次猜测，程序会返回你一些返回值，如果是 `FOUND`，说明你猜对了，否则是 `GO w`，表示 $w$ 到 $v$ 经过的边数严格小于你猜测的点到 $v$ 的边数。你的程序每次询问要猜测不超过 $10$ 次，如果你猜测的次数 $> 10$ 次，那么你就不通过该测试点。\n\n此外为了避免你是蒙对的，需要进行 $n$ 次询问，每次猜测成功后，你直接进行下一轮询问，询问 $n$ 次完直接退出。", "outputFormat": "每次询问，你需要向**标准输出**输出一个整数 $u$，代表你猜测的结果，**然后清空缓冲区**。\n\n你可以使用如下语句来清空缓冲区：\n\n- 对于 C/C++：`fflush(stdout)`；\n- 对于 C++：`std::cout << std::flush`；\n- 对于 Java：`System.out.flush()`；\n- 对于 Python：`stdout.flush()`；\n- 对于 Pascal：`flush(output)`；\n- 对于其他语言，请自行查阅对应语言的帮助文档。", "hint": "数据保证 $1 \\leq n \\leq 500$，$0 \\leq m \\leq 500$，$1 \\leq k_i \\leq 500$。\n\n注：为了方便比对，在样例输入输出上加入了一些空行进行对齐，实际输入输出中没有这些空行。", "locale": "zh-CN"}}}
{"pid": "P9794", "type": "P", "difficulty": 6, "samples": [["4 4\n1 2\n2 3\n3 1\n3 4", "8"], ["7 10\n1 2\n2 6\n5 3\n5 4\n5 7\n3 6\n1 7\n5 1\n7 4\n4 1", "34"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2018", "ICPC", "NERC/NEERC"], "title": "[NERC 2018]  Distance Sum", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) D 题。", "description": "给你一个 $n$ 个顶点 $m$ 条边的连通无向图，定义 $u$ 与 $v$ 的距离 $d(u, v)$ 为从 $u$ 到 $v$ 最短路径上经过的边数。\n\n现在请你求出 $\\sum_{u=1}^n \\sum_{v=u+1}^n d(u,v)$。", "inputFormat": "第一行给定两个整数 $n(1 \\leq n \\leq 10^5)$，$m(n - 1 \\leq m \\leq n + 42)$，分别表示点数和边数。\n\n接下来 $m$ 行，每行 $2$ 个整数 $x_i$ 和 $y_i(1 \\leq x_i,y_i \\leq n, x_i \\neq y_i)$，表示 $x_i$ 和 $y_i$ 之间有一条边。\n\n保证没有重边和自环。", "outputFormat": "输出 $\\sum_{u=1}^n \\sum_{v=u+1}^n d(u,v)$。", "hint": "对于所有数据保证 $1 \\leq n \\leq 10^5$，$n-1 \\leq m \\leq n + 42$，$1 \\leq x_i, y_i \\leq n$ 且 $x_i \\neq y_i$。\n\n样例一的图是：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/39wue8qr.png)\n\n其中 $d(1,2) = 1$，$d(1,3) = 1$，$d(1,4) = 2$，$d(2,3) = 1$，$d(2,3) = 2$，$d(3,4) = 1$，总和为 $1 + 1 + 2 + 1 + 2 + 1 = 8$。\n\n样例二为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/89k279bd.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NERC 2018]  Distance Sum", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) D 题。", "description": "给你一个 $n$ 个顶点 $m$ 条边的连通无向图，定义 $u$ 与 $v$ 的距离 $d(u, v)$ 为从 $u$ 到 $v$ 最短路径上经过的边数。\n\n现在请你求出 $\\sum_{u=1}^n \\sum_{v=u+1}^n d(u,v)$。", "inputFormat": "第一行给定两个整数 $n(1 \\leq n \\leq 10^5)$，$m(n - 1 \\leq m \\leq n + 42)$，分别表示点数和边数。\n\n接下来 $m$ 行，每行 $2$ 个整数 $x_i$ 和 $y_i(1 \\leq x_i,y_i \\leq n, x_i \\neq y_i)$，表示 $x_i$ 和 $y_i$ 之间有一条边。\n\n保证没有重边和自环。", "outputFormat": "输出 $\\sum_{u=1}^n \\sum_{v=u+1}^n d(u,v)$。", "hint": "对于所有数据保证 $1 \\leq n \\leq 10^5$，$n-1 \\leq m \\leq n + 42$，$1 \\leq x_i, y_i \\leq n$ 且 $x_i \\neq y_i$。\n\n样例一的图是：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/39wue8qr.png)\n\n其中 $d(1,2) = 1$，$d(1,3) = 1$，$d(1,4) = 2$，$d(2,3) = 1$，$d(2,3) = 2$，$d(3,4) = 1$，总和为 $1 + 1 + 2 + 1 + 2 + 1 = 8$。\n\n样例二为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/89k279bd.png)", "locale": "zh-CN"}}}
{"pid": "P9795", "type": "P", "difficulty": 4, "samples": [["4", "a1 f1 c1 c8 h8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2018", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2018] Easy Chess", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) E 题。", "description": "Elma 正在学习象棋。\n\nElma 是个新手，她还不特别了解象棋是如何下的，所以，为了更好地让她了解象棋，她的奶奶让她从一个棋盘（如下图）中进行 $n$ 次移动，每次移动只能是水平或垂直地移动若干个格子的，且每个点只能到达一次，使得从 a1 到 h8 处。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zlooykdb.png)", "inputFormat": "输入一个数 $n(2 \\leq n \\leq 63)$，表示你一共需要走的步数。", "outputFormat": "给出一种可行方案且保证停留过的点不重复。", "hint": "对于所有数据保证 $2 \\leq n \\leq 63$ 且保证存在至少一种合法方案。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NERC 2018] Easy Chess", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) E 题。", "description": "Elma 正在学习象棋。\n\nElma 是个新手，她还不特别了解象棋是如何下的，所以，为了更好地让她了解象棋，她的奶奶让她从一个棋盘（如下图）中进行 $n$ 次移动，每次移动只能是水平或垂直地移动若干个格子的，且每个点只能到达一次，使得从 a1 到 h8 处。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zlooykdb.png)", "inputFormat": "输入一个数 $n(2 \\leq n \\leq 63)$，表示你一共需要走的步数。", "outputFormat": "给出一种可行方案且保证停留过的点不重复。", "hint": "对于所有数据保证 $2 \\leq n \\leq 63$ 且保证存在至少一种合法方案。", "locale": "zh-CN"}}}
{"pid": "P9796", "type": "P", "difficulty": 5, "samples": [["2", "NO"], ["6", "YES\n2\n1 2\n1 3"]], "limits": {"time": [1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2018] Fractions", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) F 题。", "description": "给你一个整数 $n$，你需要构造出若干个形如 $\\dfrac{a_i}{b_i}$ 的真分数，使得 $\\sum^k_{i=1} \\frac{a_i}{b_i} = 1 - \\frac{1}{n}$，且 $b_i$ 可以整除 $n$。", "inputFormat": "一个正整数 $n (2 \\leq n \\leq 10^9)$。", "outputFormat": "如果不能构造，输出一行 `NO`。\n\n否则的话就构造出其中一种的合法方案，输出 `YES`，然后让 $\\sum^k_{i=1} \\frac{a_i}{b_i} = 1 - \\frac{1}{n}$，按第二行第一个整数 $k$，接下来 $k$ 行一行两个整数 $a_i$ 和 $b_i(b_i \\neq n)$。\n\n注意你输出的 $k$ 的范围是 $2 \\leq k \\leq 10^5$。", "hint": "对于所有的数据，保证 $2 \\leq n \\leq 10^9$。\n\n对于第一个样例，不存在一种方案使得答案总和为 $\\frac{1}{2}$。\n\n对于第二个样例，$\\frac{1}{2} + \\frac{1}{3} = \\frac{5}{6}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NERC 2018] Fractions", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) F 题。", "description": "给你一个整数 $n$，你需要构造出若干个形如 $\\dfrac{a_i}{b_i}$ 的真分数，使得 $\\sum^k_{i=1} \\frac{a_i}{b_i} = 1 - \\frac{1}{n}$，且 $b_i$ 可以整除 $n$。", "inputFormat": "一个正整数 $n (2 \\leq n \\leq 10^9)$。", "outputFormat": "如果不能构造，输出一行 `NO`。\n\n否则的话就构造出其中一种的合法方案，输出 `YES`，然后让 $\\sum^k_{i=1} \\frac{a_i}{b_i} = 1 - \\frac{1}{n}$，按第二行第一个整数 $k$，接下来 $k$ 行一行两个整数 $a_i$ 和 $b_i(b_i \\neq n)$。\n\n注意你输出的 $k$ 的范围是 $2 \\leq k \\leq 10^5$。", "hint": "对于所有的数据，保证 $2 \\leq n \\leq 10^9$。\n\n对于第一个样例，不存在一种方案使得答案总和为 $\\frac{1}{2}$。\n\n对于第二个样例，$\\frac{1}{2} + \\frac{1}{3} = \\frac{5}{6}$。", "locale": "zh-CN"}}}
{"pid": "P9797", "type": "P", "difficulty": 2, "samples": [["3\n2\n0 1 0 0 0 0 0\n100000000\n1 0 0 0 1 0 1\n1\n1 0 0 0 0 0 0", "8\n233333332\n1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "ICPC", "NERC/NEERC"], "title": "[NERC 2018]  Guest Student", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) G 题。", "description": "你作为某知名大学的客座学生，你想要在那里学习 $k$ 节课，但同时很遗憾，对于每周，你只有特定的时间才能有空去听课，如果 $a_i = 1$，说明周 $i$ 你有空，反之则没空。\n\n你需要安排一个合理的日程，使得你去听第一节课到最后一节课中间经过的时间最短，当然第一节课听什么的顺序由你决定。", "inputFormat": "第一行一个整数 $t (1 \\leq t \\leq 10000)$，表示数据组数。\n\n接下来每组数据第一行一个整数 $k (1 \\leq k \\leq 10^8)$。\n\n然后 $7$ 个整数 $a_1 \\sim a_7$，$a_i = 1$ 表示有空，$a_i = 0$ 表示没空。", "outputFormat": "对于每组数据，输出一个整数，表示最短的从第一节课到最后一节课所经过的时间。", "hint": "对于所有数据，保证 $1 \\leq t \\leq 10000$，$1 \\leq k \\leq 10^8$ 且 $a_i \\in \\{0,1\\}$。\n\n对于样例一，从周二开始听课听到下周二，经过 $8$ 天。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NERC 2018]  Guest Student", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) G 题。", "description": "你作为某知名大学的客座学生，你想要在那里学习 $k$ 节课，但同时很遗憾，对于每周，你只有特定的时间才能有空去听课，如果 $a_i = 1$，说明周 $i$ 你有空，反之则没空。\n\n你需要安排一个合理的日程，使得你去听第一节课到最后一节课中间经过的时间最短，当然第一节课听什么的顺序由你决定。", "inputFormat": "第一行一个整数 $t (1 \\leq t \\leq 10000)$，表示数据组数。\n\n接下来每组数据第一行一个整数 $k (1 \\leq k \\leq 10^8)$。\n\n然后 $7$ 个整数 $a_1 \\sim a_7$，$a_i = 1$ 表示有空，$a_i = 0$ 表示没空。", "outputFormat": "对于每组数据，输出一个整数，表示最短的从第一节课到最后一节课所经过的时间。", "hint": "对于所有数据，保证 $1 \\leq t \\leq 10000$，$1 \\leq k \\leq 10^8$ 且 $a_i \\in \\{0,1\\}$。\n\n对于样例一，从周二开始听课听到下周二，经过 $8$ 天。", "locale": "zh-CN"}}}
{"pid": "P9798", "type": "P", "difficulty": 7, "samples": [["3\n2 2\nAE\n1 -2\n-1 2\n2 2\nEA\n1 -2\n-1 2\n3 2\nAEA\n1 -2\n-1 -3\n", "TRUE\nFALSE\nFALSE\n"]], "limits": {"time": [1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "ICPC", "NERC/NEERC"], "title": "[NERC 2018] Harder Satisfiability", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) H 题。", "description": "我们定义一个“完全量化的布尔类型的 2-CNF 公式”（下简称 2-CNF）是以 $Q_1 x_1 \\ldots Q_n x_n F(x_1,\\ldots x_n)$ 构成的，$Q_i$ 只有两种，一种是“通用量词” $\\forall$，另一种是“存在量词” $\\exists$。然后 $F$ 是一个 $m$ 子句的 $s \\lor t$（$\\mathtt{OR}$ 运算） 的连词（$\\mathtt{AND}$ 运算），其中 $s$ 和 $t$ 不一定不同且不一定是否定（为 $\\texttt{false}$）。由于 2-CNF 公式是给定的，所以并没有自由变量（即答案固定为 $\\texttt{true}$ 或 $\\texttt{false}$）。\n\n至于计算 2-CNF 公式的值，我们可以使用一个简单的递归算法来求：\n\n- 如果没有量词（即 $\\forall$ 或 $\\exists$ ），则返回剩余表达式的返回值。\n\n- 否则，我们使用递归计算公式：$F_z = Q_2x_2 \\ldots Q_nx_n F(z,x_2,\\ldots,x_n)$，此处 $z = 0,1$。\n\n- 如果当前符号为 $\\exists$，则返回 $F_0 \\lor F_1$（$\\mathtt{OR}$ 运算）。否则符号为 $\\forall$ 返回 $F_0 \\land F_1$。\n", "inputFormat": "第一行是一个整数 $t (1 \\leq t \\leq 10^5)$，表示数据组数。\n\n接下来 $t$ 组数据，每组数据第一行两个整数 $n(1 \\leq n \\leq 10^5)$ 和 $m (1 \\leq m \\leq 10^5)$，$n$ 表示量词的长度，$m$ 表示在 $F$ 中的元素个数。\n\n然后一行，一串长度为 $n$ 的字符串 $s$，如果 $s_i = $ `A`，则 $Q_i = \\forall$，否则若 $s_i = $ `E`，则 $Q_i = \\exists$。\n\n接下来 $m$ 行，一行两个整数 $u_i,v_i(-n \\leq u_i,v_i \\leq n)$，如果 $u_i \\geq 1$ 则第 $i$ 个变量是 $x_{u_i}$，如果 $u_i \\leq -1$ 则第 $i$ 个变量是 $-(x_{-u_i})$，$v_i$ 同理。", "outputFormat": "对于每组数据，如果 2-CNF 公式为真输出 `TRUE`，否则输出 `FALSE`。", "hint": "数据保证 $1 \\leq t \\leq 10^5$，$1 \\leq n,m \\leq 10^5$，$-n \\leq u_i,v_i \\leq n$。\n\n第一个 2-CNF 公式可以化简为 $\\forall x_1 \\exists x_2(x_1 \\lor \\overline{x_2}) \\land (\\overline{x_1} \\lor x_2) = \\forall x_1 \\exists x_2 x_1 \\oplus x_2$，对于任意的 $x_1$ 都存在 $x_2 = \\overline{x_1}$ 使得答案为真。\n\n第二个 2-CNF 改变了公式的顺序，对于任意的 $x_1$，都可以选择 $x_2 = x_1$，使得表达式为 `FALSE`。\n\n第三个表达式是 $\\forall x_1 \\exists x_2 \\forall x_3 (x_1 \\lor \\overline{x_2}) \\land (\\overline{x_1} \\lor \\overline{x_3})$，如果令 $x_1 = 1$，$x_3 = 1$，则没有 $x_2$ 的值可以使得句子赋值为真，所以公式为假。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NERC 2018] Harder Satisfiability", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) H 题。", "description": "我们定义一个“完全量化的布尔类型的 2-CNF 公式”（下简称 2-CNF）是以 $Q_1 x_1 \\ldots Q_n x_n F(x_1,\\ldots x_n)$ 构成的，$Q_i$ 只有两种，一种是“通用量词” $\\forall$，另一种是“存在量词” $\\exists$。然后 $F$ 是一个 $m$ 子句的 $s \\lor t$（$\\mathtt{OR}$ 运算） 的连词（$\\mathtt{AND}$ 运算），其中 $s$ 和 $t$ 不一定不同且不一定是否定（为 $\\texttt{false}$）。由于 2-CNF 公式是给定的，所以并没有自由变量（即答案固定为 $\\texttt{true}$ 或 $\\texttt{false}$）。\n\n至于计算 2-CNF 公式的值，我们可以使用一个简单的递归算法来求：\n\n- 如果没有量词（即 $\\forall$ 或 $\\exists$ ），则返回剩余表达式的返回值。\n\n- 否则，我们使用递归计算公式：$F_z = Q_2x_2 \\ldots Q_nx_n F(z,x_2,\\ldots,x_n)$，此处 $z = 0,1$。\n\n- 如果当前符号为 $\\exists$，则返回 $F_0 \\lor F_1$（$\\mathtt{OR}$ 运算）。否则符号为 $\\forall$ 返回 $F_0 \\land F_1$。\n", "inputFormat": "第一行是一个整数 $t (1 \\leq t \\leq 10^5)$，表示数据组数。\n\n接下来 $t$ 组数据，每组数据第一行两个整数 $n(1 \\leq n \\leq 10^5)$ 和 $m (1 \\leq m \\leq 10^5)$，$n$ 表示量词的长度，$m$ 表示在 $F$ 中的元素个数。\n\n然后一行，一串长度为 $n$ 的字符串 $s$，如果 $s_i = $ `A`，则 $Q_i = \\forall$，否则若 $s_i = $ `E`，则 $Q_i = \\exists$。\n\n接下来 $m$ 行，一行两个整数 $u_i,v_i(-n \\leq u_i,v_i \\leq n)$，如果 $u_i \\geq 1$ 则第 $i$ 个变量是 $x_{u_i}$，如果 $u_i \\leq -1$ 则第 $i$ 个变量是 $-(x_{-u_i})$，$v_i$ 同理。", "outputFormat": "对于每组数据，如果 2-CNF 公式为真输出 `TRUE`，否则输出 `FALSE`。", "hint": "数据保证 $1 \\leq t \\leq 10^5$，$1 \\leq n,m \\leq 10^5$，$-n \\leq u_i,v_i \\leq n$。\n\n第一个 2-CNF 公式可以化简为 $\\forall x_1 \\exists x_2(x_1 \\lor \\overline{x_2}) \\land (\\overline{x_1} \\lor x_2) = \\forall x_1 \\exists x_2 x_1 \\oplus x_2$，对于任意的 $x_1$ 都存在 $x_2 = \\overline{x_1}$ 使得答案为真。\n\n第二个 2-CNF 改变了公式的顺序，对于任意的 $x_1$，都可以选择 $x_2 = x_1$，使得表达式为 `FALSE`。\n\n第三个表达式是 $\\forall x_1 \\exists x_2 \\forall x_3 (x_1 \\lor \\overline{x_2}) \\land (\\overline{x_1} \\lor \\overline{x_3})$，如果令 $x_1 = 1$，$x_3 = 1$，则没有 $x_2$ 的值可以使得句子赋值为真，所以公式为假。", "locale": "zh-CN"}}}
{"pid": "P9799", "type": "P", "difficulty": 6, "samples": [["4 998244353\n1\n4\n5\n9", "1\n2\n6\n28146"], ["1 437122297\n20", "67777575"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "ICPC", "NERC/NEERC"], "title": "[NERC 2018]  Interval-Free Permutations", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) I 题。", "description": "我们定义一个从 $1 \\sim n$ 的排列是“间隔排列”的情况是，在这个排列中存在连续的一段长度为 $2 \\sim n-1$ 的子区间使得这段子区间在排序后是一串连续的自然数。比如，$\\{6,7,1,8,5,3,2,4\\}$ 是一个“间隔排列”，因为 $\\{6,7\\}$，$\\{5,3,2,4\\}$，$\\{3,2\\}$ 经过排序后都是一段连续的自然数。\n\n现在已知 $n$，请你输出**不是**“间隔排列”的排列总数，由于输出可能很大，请对 $p$ 取模。", "inputFormat": "第一行两个整数 $t (1 \\leq t \\leq 400)$ 和 $p (10^8 \\leq p \\leq 10^9)$，分别表示数据组数和模数。\n\n接下来 $t$ 行，一行一个整数 $n (1 \\leq n \\leq 400)$。", "outputFormat": "对于每组数据输出 $1 \\sim n$ 的所有排列中**不是**“间隔排列”的排列总数对 $p$ 取模的值。", "hint": "数据保证 $1 \\leq t \\leq 400$，$10^8 \\leq p \\leq 10^9$，$1 \\leq n \\leq 400$。\n\n对于样例一的解释：\n\n第二组数据存在 $\\{2,4,1,3\\}$ 和 $\\{3,1,4,2\\}$ 符合要求。\n\n第三组数据存在 $\\{2,4,1,5,3\\}$，$\\{2,5,3,1,4\\}$，$\\{3,1,5,2,4\\}$，$\\{3,5,1,4,2\\}$，$\\{4,1,3,5,2\\}$ 和 $\\{4,2,5,1,3\\}$ 满足要求。\n\n对于样例二，一共有 $264111424634864638$ 种可能。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NERC 2018]  Interval-Free Permutations", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) I 题。", "description": "我们定义一个从 $1 \\sim n$ 的排列是“间隔排列”的情况是，在这个排列中存在连续的一段长度为 $2 \\sim n-1$ 的子区间使得这段子区间在排序后是一串连续的自然数。比如，$\\{6,7,1,8,5,3,2,4\\}$ 是一个“间隔排列”，因为 $\\{6,7\\}$，$\\{5,3,2,4\\}$，$\\{3,2\\}$ 经过排序后都是一段连续的自然数。\n\n现在已知 $n$，请你输出**不是**“间隔排列”的排列总数，由于输出可能很大，请对 $p$ 取模。", "inputFormat": "第一行两个整数 $t (1 \\leq t \\leq 400)$ 和 $p (10^8 \\leq p \\leq 10^9)$，分别表示数据组数和模数。\n\n接下来 $t$ 行，一行一个整数 $n (1 \\leq n \\leq 400)$。", "outputFormat": "对于每组数据输出 $1 \\sim n$ 的所有排列中**不是**“间隔排列”的排列总数对 $p$ 取模的值。", "hint": "数据保证 $1 \\leq t \\leq 400$，$10^8 \\leq p \\leq 10^9$，$1 \\leq n \\leq 400$。\n\n对于样例一的解释：\n\n第二组数据存在 $\\{2,4,1,3\\}$ 和 $\\{3,1,4,2\\}$ 符合要求。\n\n第三组数据存在 $\\{2,4,1,5,3\\}$，$\\{2,5,3,1,4\\}$，$\\{3,1,5,2,4\\}$，$\\{3,5,1,4,2\\}$，$\\{4,1,3,5,2\\}$ 和 $\\{4,2,5,1,3\\}$ 满足要求。\n\n对于样例二，一共有 $264111424634864638$ 种可能。", "locale": "zh-CN"}}}
