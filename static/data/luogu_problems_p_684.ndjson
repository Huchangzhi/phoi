{"pid": "P14866", "type": "P", "difficulty": 5, "samples": [["2 2\n.S\nG#", "2\nFORWARD\nLEFT"], ["5 2\nS.\n..\n..\n..\n.G", "3\nIF-OPEN 3\nLEFT\nFORWARD"], ["2 6\n..S...\n..#.G#", "4\nRIGHT\nRIGHT\nFORWARD\nGOTO 2"], ["10 10\n.##S...##.\n..#...#...\n..#...#...\n.###...##.\n..........\n..........\n.##....##.\n.#.#..#...\n.##...#...\n.#.....G#.", "5\nLEFT\nFORWARD\nRIGHT\nFORWARD\nIF-OPEN 4"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "Special Judge", "ICPC", "横浜"], "title": "[ICPC 2020 Yokohama R] Short Coding", "background": "", "description": "You participate in a project to explore an asteroid called *Yokohama 2020*. A maze-like space in its underground was found by a survey a couple of years ago. The project is to investigate the maze more in detail using an exploration robot.\n\nThe shape of the maze was fully grasped by a survey with ground penetrating radars. For planning the exploration, the maze is represented as a grid of cells, where the first cell of the first row is the upper left corner of the grid, and the last cell of the last row is the lower right corner.\n\nEach of the grid cell is either vacant, allowing robot’s moves to it from an adjacent vacant cell, or filled with rocks, obstructing such moves. The entrance of the maze is located in a cell in the uppermost row and the exit is in a cell in the lowermost row.\n\nThe exploration robot is controlled by a program stored in it, which consists of sequentially numbered lines, each containing one of the five kinds of commands described below. The register **pc** specifies the line number of the program to be executed. Each command specifies an action of the robot and a value to be set to **pc**.\n\nThe robot starts at the entrance of the maze facing downwards, and the value of **pc** is set to 1. The program commands on the lines specified by **pc** are executed repetitively, one by one, until the robot reaches the exit of the maze.\n\nWhen the value of **pc** exceeds the number of lines of the program by its increment, it is reset to 1. The robot stops on reaching the exit cell, which is the goal of the project.\n\nAs the capacity of the program store for the robot is quite limited, the number of lines of the program should be minimal. Your job is to develop a program with the fewest possible number of lines among those which eventually lead the robot to the exit.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$n \\ m$$\n\n$$s_1$$\n\n$$\\vdots$$\n\n$$s_n$$\n\nThe first line contains two integers $n$ ($2 \\le n \\le 10$) and $m$ ($2 \\le m \\le 10$). The maze is represented as a grid with $n$ rows and $m$ columns. The next $n$ lines describe the grid. Each of the lines contains a string of length $m$ corresponding to one grid row. The $i$-th character of the $j$-th string, either `.` , `#`, `S` or `G`, describes the $i$-th cell of the $j$-th row. `.` means that the cell is vacant and the robot in one of the four adjacent cells can move to it. `#` means that the cell is filled obstructing the robot’s moves to it. `S` means that the cell is the entrance, and `G` means that the cell is the exit. These cells are vacant, of course.\n\nIt is known that a program exists that leads the robot to the exit.\n\n| command      | description                                                                                                                               |\n|:------------:|:-----------------------------------------------------------------------------------------------------------------------------------------:|\n| GOTO $l$    | Set $l$ to **pc**. The command parameter $l$ is a positive integer less than or equal to the number of lines of the program.             |\n| IF-OPEN $l$ | If there is a vacant adjacent cell in its current direction, set $l$ to **pc**; otherwise, that is, facing a filled cell or a border of the grid, increment **pc** by one. The command parameter $l$ is a positive integer less than or equal to the number of lines of the program. |\n| FORWARD     | If there is a vacant adjacent cell in its current direction, move there; otherwise, stay in the current cell. In either case, increment **pc** by one. |\n| LEFT        | Turn 90 degrees to the left without changing the position, and increment **pc** by one.                                                   |\n| RIGHT       | Turn 90 degrees to the right without changing the position, and increment **pc** by one.                                                  |\n", "outputFormat": "The first line of the output should have the number of lines of the program. The commands in the program lines should follow, one per each line, in the order of their line numbers. When the command has a parameter, output only one space between the command name and the parameter.\n\nIf more than one appropriate program has the fewest lines, whichever is acceptable.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Yokohama R] Short Coding", "background": "", "description": "You participate in a project to explore an asteroid called *Yokohama 2020*. A maze-like space in its underground was found by a survey a couple of years ago. The project is to investigate the maze more in detail using an exploration robot.\n\nThe shape of the maze was fully grasped by a survey with ground penetrating radars. For planning the exploration, the maze is represented as a grid of cells, where the first cell of the first row is the upper left corner of the grid, and the last cell of the last row is the lower right corner.\n\nEach of the grid cell is either vacant, allowing robot’s moves to it from an adjacent vacant cell, or filled with rocks, obstructing such moves. The entrance of the maze is located in a cell in the uppermost row and the exit is in a cell in the lowermost row.\n\nThe exploration robot is controlled by a program stored in it, which consists of sequentially numbered lines, each containing one of the five kinds of commands described below. The register **pc** specifies the line number of the program to be executed. Each command specifies an action of the robot and a value to be set to **pc**.\n\nThe robot starts at the entrance of the maze facing downwards, and the value of **pc** is set to 1. The program commands on the lines specified by **pc** are executed repetitively, one by one, until the robot reaches the exit of the maze.\n\nWhen the value of **pc** exceeds the number of lines of the program by its increment, it is reset to 1. The robot stops on reaching the exit cell, which is the goal of the project.\n\nAs the capacity of the program store for the robot is quite limited, the number of lines of the program should be minimal. Your job is to develop a program with the fewest possible number of lines among those which eventually lead the robot to the exit.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$n \\ m$$\n\n$$s_1$$\n\n$$\\vdots$$\n\n$$s_n$$\n\nThe first line contains two integers $n$ ($2 \\le n \\le 10$) and $m$ ($2 \\le m \\le 10$). The maze is represented as a grid with $n$ rows and $m$ columns. The next $n$ lines describe the grid. Each of the lines contains a string of length $m$ corresponding to one grid row. The $i$-th character of the $j$-th string, either `.` , `#`, `S` or `G`, describes the $i$-th cell of the $j$-th row. `.` means that the cell is vacant and the robot in one of the four adjacent cells can move to it. `#` means that the cell is filled obstructing the robot’s moves to it. `S` means that the cell is the entrance, and `G` means that the cell is the exit. These cells are vacant, of course.\n\nIt is known that a program exists that leads the robot to the exit.\n\n| command      | description                                                                                                                               |\n|:------------:|:-----------------------------------------------------------------------------------------------------------------------------------------:|\n| GOTO $l$    | Set $l$ to **pc**. The command parameter $l$ is a positive integer less than or equal to the number of lines of the program.             |\n| IF-OPEN $l$ | If there is a vacant adjacent cell in its current direction, set $l$ to **pc**; otherwise, that is, facing a filled cell or a border of the grid, increment **pc** by one. The command parameter $l$ is a positive integer less than or equal to the number of lines of the program. |\n| FORWARD     | If there is a vacant adjacent cell in its current direction, move there; otherwise, stay in the current cell. In either case, increment **pc** by one. |\n| LEFT        | Turn 90 degrees to the left without changing the position, and increment **pc** by one.                                                   |\n| RIGHT       | Turn 90 degrees to the right without changing the position, and increment **pc** by one.                                                  |\n", "outputFormat": "The first line of the output should have the number of lines of the program. The commands in the program lines should follow, one per each line, in the order of their line numbers. When the command has a parameter, output only one space between the command name and the parameter.\n\nIf more than one appropriate program has the fewest lines, whichever is acceptable.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Yokohama R] Short Coding", "background": "", "description": "你参与了一个探索名为 **Yokohama 2020** 的小行星的项目。几年前的一次勘测发现其地下存在一个迷宫般的空间。该项目的目标是使用一个探索机器人对这个迷宫进行更详细的调查。\n\n迷宫的形态已通过地质穿透雷达的勘测完全掌握。为了规划探索任务，迷宫被表示为一个单元格网格，其中第一行的第一个单元格位于网格的左上角，最后一行的最后一个单元格位于网格的右下角。\n\n网格中的每个单元格要么是空的（允许机器人从相邻的空单元格移动到该单元格），要么充满岩石（阻碍此类移动）。迷宫的入口位于最顶行的某个单元格，出口位于最底行的某个单元格。\n\n探索机器人由其内部存储的程序控制，该程序由按顺序编号的行组成，每行包含下述五种命令之一。寄存器 **pc** 指定要执行的程序行号。每条命令都规定了机器人的一个动作以及要设置给 **pc** 的值。\n\n机器人从迷宫入口处开始，面朝下方，**pc** 的值被设置为 $1$。程序将重复地执行 **pc** 指定的行上的命令，一条接一条，直到机器人到达迷宫出口。\n\n当 **pc** 的值因其递增而超过程序的行数时，它将被重置为 $1$。机器人一旦到达出口单元格即停止，这即是项目的目标。\n\n由于机器人程序存储器的容量非常有限，程序的行数应尽可能少。你的任务是开发一个行数尽可能少的程序，且该程序最终能将机器人引导至出口。", "inputFormat": "输入包含单个测试用例，格式如下。\n\n$$n \\ m$$\n\n$$s_1$$\n\n$$\\vdots$$\n\n$$s_n$$\n\n第一行包含两个整数 $n$ （$2 \\le n \\le 10$）和 $m$ （$2 \\le m \\le 10$）。迷宫表示为一个 $n$ 行 $m$ 列的网格。接下来 $n$ 行描述该网格。每行包含一个长度为 $m$ 的字符串，对应网格的一行。第 $j$ 个字符串的第 $i$ 个字符（可能是 `.` 、 `#`、 `S` 或 `G`）描述了第 $j$ 行第 $i$ 列的单元格。`.` 表示该单元格是空的，机器人可以从四个相邻单元格之一移动到该位置。`#` 表示该单元格被填充，阻碍机器人移动到该位置。`S` 表示该单元格是入口，`G` 表示该单元格是出口。这些单元格当然也是空的。\n\n已知存在一个能将机器人引导至出口的程序。\n\n| 命令 | 描述 |\n|:---:|:---:|\n| **GOTO $l$** | 将 **pc** 设置为 $l$。命令参数 $l$ 是一个正整数，且小于或等于程序的行数。 |\n| **IF-OPEN $l$** | 如果当前朝向存在一个空的相邻单元格，则将 **pc** 设置为 $l$；否则（即面对一个被填充的单元格或网格边界），将 **pc** 增加 $1$。命令参数 $l$ 是一个正整数，且小于或等于程序的行数。 |\n| **FORWARD** | 如果当前朝向存在一个空的相邻单元格，则移动到该单元格；否则，停留在当前单元格。无论哪种情况，都将 **pc** 增加 $1$。 |\n| **LEFT** | 向左转 $90$ 度，不改变位置，并将 **pc** 增加 $1$。 |\n| **RIGHT** | 向右转 $90$ 度，不改变位置，并将 **pc** 增加 $1$。 |\n", "outputFormat": "输出的第一行应包含程序的行数。接下来，应按其行号顺序，每行输出一个程序命令。当命令有参数时，命令名称和参数之间仅输出一个空格。\n\n如果有多个具有最少行数的合适程序，输出其中任意一个均可。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14867", "type": "P", "difficulty": 7, "samples": [["4\n0 2 0\n1 0 0\n1 3 1\n2 4 2", "8"], ["4\n0 0 0\n0 1 1\n0 2 2\n1 2 0", "4"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "ICPC", "横浜"], "title": "[ICPC 2020 Yokohama R] Colorful Rectangle", "background": "", "description": "You are given a set of points on a plane. Each point is colored either red, blue, or green. A rectangle is called **colorful** if it contains one or more points of every color inside or on its edges. Your task is to find an axis-parallel colorful rectangle with the shortest perimeter. An axis-parallel line segment is considered as a degenerated rectangle and its perimeter is twice the length of the line segment.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n& n\\\\\n& x_1 \\ y_1 \\ c_1\\\\\n& \\vdots\\\\\n& x_n \\ y_n \\ c_n\\\\ \n\\end{aligned}\n$$\n\nThe first line contains an integer $n$ ($3 \\le n \\le 10^5$) representing the number of points on the plane. Each of the following $n$ lines contains three integers $x_i$, $y_i$, and $c_i$ satisfying $0 \\le x_i \\le 10^8$, $0 \\le y_i \\le 10^8$, and $0 \\le c_i \\le 2$. Each line represents that there is a point of color $c_i$ (0: red, 1: blue, 2: green) at coordinates $(x_i, y_i)$. It is guaranteed that there is at least one point of every color and no two points have the same coordinates.\n", "outputFormat": "Output a single integer in a line which is the shortest perimeter of an axis-parallel colorful rectangle.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Yokohama R] Colorful Rectangle", "background": "", "description": "You are given a set of points on a plane. Each point is colored either red, blue, or green. A rectangle is called **colorful** if it contains one or more points of every color inside or on its edges. Your task is to find an axis-parallel colorful rectangle with the shortest perimeter. An axis-parallel line segment is considered as a degenerated rectangle and its perimeter is twice the length of the line segment.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n& n\\\\\n& x_1 \\ y_1 \\ c_1\\\\\n& \\vdots\\\\\n& x_n \\ y_n \\ c_n\\\\ \n\\end{aligned}\n$$\n\nThe first line contains an integer $n$ ($3 \\le n \\le 10^5$) representing the number of points on the plane. Each of the following $n$ lines contains three integers $x_i$, $y_i$, and $c_i$ satisfying $0 \\le x_i \\le 10^8$, $0 \\le y_i \\le 10^8$, and $0 \\le c_i \\le 2$. Each line represents that there is a point of color $c_i$ (0: red, 1: blue, 2: green) at coordinates $(x_i, y_i)$. It is guaranteed that there is at least one point of every color and no two points have the same coordinates.\n", "outputFormat": "Output a single integer in a line which is the shortest perimeter of an axis-parallel colorful rectangle.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Yokohama R] Colorful Rectangle", "background": "", "description": "给定平面上的一组点。每个点被染成红色、蓝色或绿色中的一种。如果一个矩形在其内部或边缘上包含至少一个**每种颜色**的点，则称该矩形为**彩色**矩形。你的任务是找到一个与坐标轴平行的彩色矩形，使其周长最短。与坐标轴平行的线段被视为退化的矩形，其周长为该线段长度的两倍。", "inputFormat": "输入包含单个测试用例，格式如下。\n\n$$\n\\begin{aligned}\n& n\\\\\n& x_1 \\ y_1 \\ c_1\\\\\n& \\vdots\\\\\n& x_n \\ y_n \\ c_n\\\\ \n\\end{aligned}\n$$\n\n第一行包含一个整数 $n$ （$3 \\le n \\le 10^5$），表示平面上点的数量。接下来的 $n$ 行中，每行包含三个整数 $x_i$、$y_i$ 和 $c_i$，满足 $0 \\le x_i \\le 10^8$，$0 \\le y_i \\le 10^8$，且 $0 \\le c_i \\le 2$。每行表示在坐标 $(x_i, y_i)$ 处有一个颜色为 $c_i$ 的点（$0$：红色，$1$：蓝色，$2$：绿色）。保证至少存在每种颜色的一个点，并且没有两个点的坐标完全相同。", "outputFormat": "在一行中输出一个整数，表示与坐标轴平行的彩色矩形的最短周长。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14868", "type": "P", "difficulty": 4, "samples": [["5\n3 1 6 1 7", "3.54440435"], ["3\n500 300 400", "250.0"], ["6\n2000 3000 4000 2000 3000 4000", "3037.33679126"], ["10\n602 67 67 67 67 67 67 67 67 67", "3003.13981697"], ["3\n6000 6000 1", "3000.00001042"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "2020", "二分", "Special Judge", "ICPC", "横浜"], "title": "[ICPC 2020 Yokohama R] Jewelry Size", "background": "", "description": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/1fbre3dl.png)\n:::\n\nShe came up with a new jewelry design. The design uses two parts: a hollow circlet and a convex polygonal component. The design can be customized by specifying the edge lengths of the polygon, which should be multiples of a unit length, so that customers can embed memorial numbers in the jewelry. Note that there can be many different polygons with edges of the specified lengths. Among them, one with a circumscribed circle, that is, a circle that passes through all of its vertices, is chosen so that the polygonal component can be firmly anchored to the circlet.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/3odnjiqx.png)\n\nFigure E.2. (a) A pentagon with a circumscribed circle; (b) A pentagon with no circumscribed circle; (c) Another pentagon with no circumscribed circle\n:::\n\nFor example, Figure E.2(a) has a pentagon with its edge lengths of 3, 1, 6, 1, and 7 units, meaning March 16th and 17th. The radius of the circle is approximately 3.544 units. Figures E.2(b) and E.2(c) show pentagons with the same edge lengths but neither of them has a circumscribed circle.\n\nTo commercialize the jewelry, she needs to be able to compute the radius of the circumscribed circle from specified edge lengths. Can you help her by writing a program for this task?", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n&n\\\\\n&x_1 \\cdots x_n\\\\\n\\end{aligned}\n$$\n\n$n$ is an integer that indicates the number of edges ($3 \\le n \\le 1000$). $x_k$ ($k = 1, \\dots, n$) is an integer that indicates the length of the $k$-th edge ($1 \\le x_k \\le 6000$).\n\nYou may assume the existence of one or more polygons with the specified edge lengths. You can prove that one of such polygons has a circumscribed circle.\n", "outputFormat": "Output the minimum radius of a circumscribed circle of a polygon with the specified edge lengths. Absolute/relative error of the output should be within $10^{-7}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Yokohama R] Jewelry Size", "background": "", "description": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/1fbre3dl.png)\n:::\n\nShe came up with a new jewelry design. The design uses two parts: a hollow circlet and a convex polygonal component. The design can be customized by specifying the edge lengths of the polygon, which should be multiples of a unit length, so that customers can embed memorial numbers in the jewelry. Note that there can be many different polygons with edges of the specified lengths. Among them, one with a circumscribed circle, that is, a circle that passes through all of its vertices, is chosen so that the polygonal component can be firmly anchored to the circlet.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/3odnjiqx.png)\n\nFigure E.2. (a) A pentagon with a circumscribed circle; (b) A pentagon with no circumscribed circle; (c) Another pentagon with no circumscribed circle\n:::\n\nFor example, Figure E.2(a) has a pentagon with its edge lengths of 3, 1, 6, 1, and 7 units, meaning March 16th and 17th. The radius of the circle is approximately 3.544 units. Figures E.2(b) and E.2(c) show pentagons with the same edge lengths but neither of them has a circumscribed circle.\n\nTo commercialize the jewelry, she needs to be able to compute the radius of the circumscribed circle from specified edge lengths. Can you help her by writing a program for this task?", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n&n\\\\\n&x_1 \\cdots x_n\\\\\n\\end{aligned}\n$$\n\n$n$ is an integer that indicates the number of edges ($3 \\le n \\le 1000$). $x_k$ ($k = 1, \\dots, n$) is an integer that indicates the length of the $k$-th edge ($1 \\le x_k \\le 6000$).\n\nYou may assume the existence of one or more polygons with the specified edge lengths. You can prove that one of such polygons has a circumscribed circle.\n", "outputFormat": "Output the minimum radius of a circumscribed circle of a polygon with the specified edge lengths. Absolute/relative error of the output should be within $10^{-7}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Yokohama R] Jewelry Size", "background": "", "description": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/1fbre3dl.png)\n:::\n\n她想出了一种新的珠宝设计。该设计使用两个部分：一个空心的圆环和一个凸多边形部件。设计可以通过指定多边形的边长来定制，这些边长应该是单位长度的倍数，这样客户就可以在珠宝中嵌入纪念数字。请注意，可能存在许多具有指定边长的不同多边形。在这些多边形中，会选择那些有外接圆（即一个通过其所有顶点的圆）的多边形，以便多边形部件可以牢固地固定在圆环上。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/3odnjiqx.png)\n\n图 E.2. （a）一个有外接圆的五边形；（b）一个没有外接圆的五边形；（c）另一个没有外接圆的五边形\n:::\n\n例如，图 E.2(a) 展示了一个五边形，其边长分别为 $3$、$1$、$6$、$1$ 和 $7$ 个单位，代表 $3$ 月 $16$ 日和 $17$ 日。该圆的半径约为 $3.544$ 个单位。图 E.2(b) 和图 E.2(c) 展示了具有相同边长的五边形，但它们都没有外接圆。\n\n为了将珠宝商业化，她需要能够根据指定的边长计算出外接圆的半径。你能通过编写一个程序来完成这个任务来帮助她吗？\n", "inputFormat": "输入包含单个测试用例，格式如下。\n\n$$\n\\begin{aligned}\n&n\\\\\n&x_1 \\cdots x_n\\\\\n\\end{aligned}\n$$\n\n$n$ 是一个整数，表示边的数量（$3 \\le n \\le 1000$）。$x_k$ （$k = 1, \\dots, n$）是一个整数，表示第 $k$ 条边的长度（$1 \\le x_k \\le 6000$）。\n\n你可以假设存在一个或多个具有指定边长的多边形。你可以证明，这样的多边形中至少有一个拥有外接圆。", "outputFormat": "输出一个具有指定边长的多边形的最小外接圆半径。输出的绝对误差或相对误差应在 $10^{-7}$ 以内。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14869", "type": "P", "difficulty": 6, "samples": [["5\n7 0\n3 3\n0 7\n-3 3\n-7 0\n6\n1 1 3 3\n3 3 4 4\n1 1 5 5\n5 5 2 2\n2 2 4 4\n1 5 1 5", "24.000000000000\n20.440306508911\n20.000000000000\n19.000000000000\n15.440306508911\n21.606571644990"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "Special Judge", "ICPC", "横浜"], "title": "[ICPC 2020 Yokohama R] Solar Car", "background": "", "description": "Alice and Bob are playing a game of baggage delivery using a toy solar car. A number of poles are placed here and there in the game field.\n\nAt the start of a game, the solar car is placed right next to a pole, and the same or another pole is marked as the destination. Bob chooses one of the poles and places the baggage there. Then, Alice plans a route of the car to pick up the baggage and deliver it to the marked destination. Alice chooses the shortest possible route and Bob should choose a pole to maximize the route length.\n\nThe solar car can drive arbitrary routes but, as it has no battery cells, it would stop as soon as it gets into shadows. In this game, a point light source is located on the surface of the field, and thus the poles cast infinitely long shadows in the directions opposite to the light source location. The drive route should avoid any of these shadows.\n\nWhen the initial positions of the solar car and the destination are given, assuming that both players make the best choices, the length of the drive route is uniquely determined.\n\nLet us think of all the possible game configurations with given two sets of poles, one for the start positions of the solar car and the other for the destinations. When both the initial car position and the destination are to be chosen uniformly at random from the corresponding sets, what is the expected route length?\n\nYour task is to compute the expected value of the route length, given the set of the initial positions of the car and that of the destinations.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n&n \\\\\n&x_1 \\ y_1 \\\\\n&\\vdots \\\\\n&x_n \\ y_n \\\\\n&p \\\\\n&a_1 \\ b_1 \\ c_1 \\ d_1 \\\\\n&\\vdots \\\\\n&a_p \\ b_p \\ c_p \\ d_p\n\\end{aligned}\n$$\n\nHere, $n$ is the number of poles ($3 \\le n \\le 2000$). The poles are numbered 1 through $n$ and the $i$-th pole is placed at integer coordinates $(x_i, y_i)$ ($-1000 \\le x_i \\le 1000$, $-1000 \\le y_i \\le 1000$). The point light is at $(0,0)$. Poles are not placed at $(0,0)$ nor in a shadow of another pole, and no two poles are placed at the same coordinates.\n\n$p$ is the number of pairs of sets ($1 \\le p \\le 10^5$). The $i$-th pair of sets is specified by four integers $(a_i, b_i, c_i, d_i)$ ($1 \\le a_i \\le b_i \\le n$, $1 \\le c_i \\le d_i \\le n$). Specifically, the solar car is initially placed at the $j$-th pole, with $j$ chosen uniformly at random from $\\{a_i, \\dots, b_i\\}$, and the destination pole is also chosen uniformly at random from $\\{c_i, \\dots, d_i\\}$.\n", "outputFormat": "Output the answer for each pair of sets. Absolute or relative errors less than $10^{-7}$ are permissible.", "hint": "For the first set pair of this test case, the solar car is placed at $(7,0)$ and the flag is placed at $(0,7)$. Then, Bob places the baggage at $(-7,0)$. The length of the shortest route from $(-7,0)$ to $(0,7)$ is 10, because the straight path from $(-7,0)$ to $(0,7)$ crosses the shadow of pole 4. The length of the shortest route from $(7,0)$ to $(-7,0)$ is 14, so the total length is 24.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/dqw5527c.png)\n\nFigure F.1. Shortest routes for the first five set pairs of Sample Input 1. Black dots are the positions of the poles and gray lines are their shadows. The yellowish brown dots are the positions of the point lights. For each figure, the red lines indicate the shortest route from the initial car position to the destination.\n:::\n", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Yokohama R] Solar Car", "background": "", "description": "Alice and Bob are playing a game of baggage delivery using a toy solar car. A number of poles are placed here and there in the game field.\n\nAt the start of a game, the solar car is placed right next to a pole, and the same or another pole is marked as the destination. Bob chooses one of the poles and places the baggage there. Then, Alice plans a route of the car to pick up the baggage and deliver it to the marked destination. Alice chooses the shortest possible route and Bob should choose a pole to maximize the route length.\n\nThe solar car can drive arbitrary routes but, as it has no battery cells, it would stop as soon as it gets into shadows. In this game, a point light source is located on the surface of the field, and thus the poles cast infinitely long shadows in the directions opposite to the light source location. The drive route should avoid any of these shadows.\n\nWhen the initial positions of the solar car and the destination are given, assuming that both players make the best choices, the length of the drive route is uniquely determined.\n\nLet us think of all the possible game configurations with given two sets of poles, one for the start positions of the solar car and the other for the destinations. When both the initial car position and the destination are to be chosen uniformly at random from the corresponding sets, what is the expected route length?\n\nYour task is to compute the expected value of the route length, given the set of the initial positions of the car and that of the destinations.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n&n \\\\\n&x_1 \\ y_1 \\\\\n&\\vdots \\\\\n&x_n \\ y_n \\\\\n&p \\\\\n&a_1 \\ b_1 \\ c_1 \\ d_1 \\\\\n&\\vdots \\\\\n&a_p \\ b_p \\ c_p \\ d_p\n\\end{aligned}\n$$\n\nHere, $n$ is the number of poles ($3 \\le n \\le 2000$). The poles are numbered 1 through $n$ and the $i$-th pole is placed at integer coordinates $(x_i, y_i)$ ($-1000 \\le x_i \\le 1000$, $-1000 \\le y_i \\le 1000$). The point light is at $(0,0)$. Poles are not placed at $(0,0)$ nor in a shadow of another pole, and no two poles are placed at the same coordinates.\n\n$p$ is the number of pairs of sets ($1 \\le p \\le 10^5$). The $i$-th pair of sets is specified by four integers $(a_i, b_i, c_i, d_i)$ ($1 \\le a_i \\le b_i \\le n$, $1 \\le c_i \\le d_i \\le n$). Specifically, the solar car is initially placed at the $j$-th pole, with $j$ chosen uniformly at random from $\\{a_i, \\dots, b_i\\}$, and the destination pole is also chosen uniformly at random from $\\{c_i, \\dots, d_i\\}$.\n", "outputFormat": "Output the answer for each pair of sets. Absolute or relative errors less than $10^{-7}$ are permissible.", "hint": "For the first set pair of this test case, the solar car is placed at $(7,0)$ and the flag is placed at $(0,7)$. Then, Bob places the baggage at $(-7,0)$. The length of the shortest route from $(-7,0)$ to $(0,7)$ is 10, because the straight path from $(-7,0)$ to $(0,7)$ crosses the shadow of pole 4. The length of the shortest route from $(7,0)$ to $(-7,0)$ is 14, so the total length is 24.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/dqw5527c.png)\n\nFigure F.1. Shortest routes for the first five set pairs of Sample Input 1. Black dots are the positions of the poles and gray lines are their shadows. The yellowish brown dots are the positions of the point lights. For each figure, the red lines indicate the shortest route from the initial car position to the destination.\n:::\n", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Yokohama R] Solar Car", "background": "", "description": "Alice 和 Bob 正在使用一辆玩具太阳能车玩一个行李运送游戏。游戏场地中到处都放置了一些杆子。\n\n在游戏开始时，太阳能车被放置在紧邻某个杆子的位置，并且同一个或另一个杆子被标记为目的地。Bob 选择其中一个杆子并将行李放在那里。然后，Alice 规划一条路线让小车去拾取行李并将其运送到标记的目的地。Alice 会选择最短的可能路线，而 Bob 应该选择一个杆子以使路线长度最大化。\n\n太阳能车可以沿任意路线行驶，但由于它没有电池，一旦进入阴影就会停止。在这个游戏中，点光源位于场地的表面上，因此杆子会朝着与光源位置相反的方向投下无限长的阴影。行驶路线应避开所有这些阴影。\n\n当给定太阳能车的初始位置和目的地位置时，假设两位玩家都做出最佳选择，行驶路线的长度是唯一确定的。\n\n让我们考虑所有可能的游戏配置，给定两组杆子，一组用于太阳能车的起始位置，另一组用于目的地。当初始小车位置和目的地都从相应的集合中均匀随机选择时，期望的路线长度是多少？\n\n你的任务是在给定小车的初始位置集合和目的地集合的情况下，计算路线长度的期望值。", "inputFormat": "输入包含单个测试用例，格式如下。\n\n$$\n\\begin{aligned}\n&n \\\\\n&x_1 \\ y_1 \\\\\n&\\vdots \\\\\n&x_n \\ y_n \\\\\n&p \\\\\n&a_1 \\ b_1 \\ c_1 \\ d_1 \\\\\n&\\vdots \\\\\n&a_p \\ b_p \\ c_p \\ d_p\n\\end{aligned}\n$$\n\n其中，$n$ 是杆子的数量（$3 \\le n \\le 2000$）。杆子编号为 $1$ 到 $n$，第 $i$ 个杆子放置在整数坐标 $(x_i, y_i)$ 处（$-1000 \\le x_i \\le 1000$，$-1000 \\le y_i \\le 1000$）。点光源位于 $(0,0)$。杆子不会放置在 $(0,0)$，也不会放置在另一个杆子的阴影中，且没有两个杆子放置在同一坐标。\n\n$p$ 是集合对的数量（$1 \\le p \\le 10^5$）。第 $i$ 对集合由四个整数 $(a_i, b_i, c_i, d_i)$ 指定（$1 \\le a_i \\le b_i \\le n$，$1 \\le c_i \\le d_i \\le n$）。具体来说，太阳能车初始放置在第 $j$ 个杆子处，其中 $j$ 是从 $\\{a_i, \\dots, b_i\\}$ 中均匀随机选择的，目的地杆子也是从 $\\{c_i, \\dots, d_i\\}$ 中均匀随机选择的。", "outputFormat": "为每一对集合输出答案。允许的绝对误差或相对误差小于 $10^{-7}$。", "hint": "对于此测试用例的第一对集合，太阳能车放置在 $(7,0)$，旗帜放置在 $(0,7)$。然后，Bob 将行李放置在 $(-7,0)$。从 $(-7,0)$ 到 $(0,7)$ 的最短路线长度为 $10$，因为从 $(-7,0)$ 到 $(0,7)$ 的直线路径穿过了 $4$ 号杆子的阴影。从 $(7,0)$ 到 $(-7,0)$ 的最短路线长度为 $14$，因此总长度为 $24$。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/dqw5527c.png)\n\n图 F.1. 样例输入 1 中前五对集合的最短路线。黑点是杆子的位置，灰线是它们的阴影。黄棕色的点是点光源的位置。对于每个图，红线表示从初始小车位置到目的地的最短路线。\n:::\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14870", "type": "P", "difficulty": 4, "samples": [["4 2\n10 20 30 40\n1 2\n3 4", "20"], ["2 1\n3 5\n1 2", "3"], ["3 0\n9 2 8", "-1"], ["4 6\n5 5 5 5\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4", "-1"], ["7 6\n3 1 4 1 5 9 2\n2 3\n3 5\n5 6\n1 4\n1 7\n4 7", "2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "并查集", "连通块", "ICPC", "横浜"], "title": "[ICPC 2020 Yokohama R] To be Connected, or not to be, that is the Question", "background": "", "description": "An undirected graph is given, each of its nodes associated with a positive integer value. Given a **threshold**, nodes of the graph are divided into two groups: one consisting of the nodes with values less than or equal to the threshold, and the other consisting of the rest of the nodes. Now, consider a subgraph of the original graph obtained by removing all the edges connecting two nodes belonging to different groups. When both of the node groups are non-empty, the resultant subgraph is disconnected, whether or not the given graph is connected.\n\nThen a number of new edges are added to the subgraph to make it connected, but these edges must connect nodes in different groups, and each node can be incident with at most one new edge. The threshold is called **feasible** if neither of the groups is empty and the subgraph can be made connected by adding some new edges.\n\nYour task is to find the minimum feasible threshold.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n&n \\ m \\\\\n&l_1 \\ldots l_n \\\\ \n&x_1 \\ y_1 \\\\ \n&\\vdots \\\\\n&x_m \\ y_m \\\\\n\\end{aligned}\n$$\n\nThe first line contains two integers $n$ ($2 \\le n \\le 10^5$) and $m$ ($0 \\le m \\le \\min(10^5, \\frac{n(n-1)}{2})$), the numbers of the nodes and the edges, respectively, of the graph. Nodes are numbered 1 through $n$. The second line contains $n$ integers $l_i$ ($1 \\le l_i \\le 10^9$), meaning that the value associated with the node $i$ is $l_i$. Each of the following $m$ lines contains two integers $x_j$ and $y_j$ ($1 \\le x_j < y_j \\le n$), meaning that an edge connects the nodes $x_j$ and $y_j$. At most one edge exists between any two nodes.\n", "outputFormat": "Output the minimum feasible threshold value. Output $-1$ if no threshold values are feasible.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Yokohama R] To be Connected, or not to be, that is the Question", "background": "", "description": "An undirected graph is given, each of its nodes associated with a positive integer value. Given a **threshold**, nodes of the graph are divided into two groups: one consisting of the nodes with values less than or equal to the threshold, and the other consisting of the rest of the nodes. Now, consider a subgraph of the original graph obtained by removing all the edges connecting two nodes belonging to different groups. When both of the node groups are non-empty, the resultant subgraph is disconnected, whether or not the given graph is connected.\n\nThen a number of new edges are added to the subgraph to make it connected, but these edges must connect nodes in different groups, and each node can be incident with at most one new edge. The threshold is called **feasible** if neither of the groups is empty and the subgraph can be made connected by adding some new edges.\n\nYour task is to find the minimum feasible threshold.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n&n \\ m \\\\\n&l_1 \\ldots l_n \\\\ \n&x_1 \\ y_1 \\\\ \n&\\vdots \\\\\n&x_m \\ y_m \\\\\n\\end{aligned}\n$$\n\nThe first line contains two integers $n$ ($2 \\le n \\le 10^5$) and $m$ ($0 \\le m \\le \\min(10^5, \\frac{n(n-1)}{2})$), the numbers of the nodes and the edges, respectively, of the graph. Nodes are numbered 1 through $n$. The second line contains $n$ integers $l_i$ ($1 \\le l_i \\le 10^9$), meaning that the value associated with the node $i$ is $l_i$. Each of the following $m$ lines contains two integers $x_j$ and $y_j$ ($1 \\le x_j < y_j \\le n$), meaning that an edge connects the nodes $x_j$ and $y_j$. At most one edge exists between any two nodes.\n", "outputFormat": "Output the minimum feasible threshold value. Output $-1$ if no threshold values are feasible.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Yokohama R] To be Connected, or not to be, that is the Question", "background": "", "description": "给定一个无向图，其中每个节点都关联一个正整数。给定一个**阈值**，图的节点被分成两组：一组由值小于或等于该阈值的节点组成，另一组由其余节点组成。现在，考虑原图的一个子图，该子图是通过移除所有连接两个属于不同组的节点的边而得到的。当两个节点组都非空时，无论原图是否连通，得到的子图都是不连通的。\n\n然后，向该子图中添加若干新边以使其连通，但这些新边必须连接不同组中的节点，并且每个节点最多只能与新边中的一条边关联。如果一个阈值满足以下条件，则称其为**可行**的：两个组均非空，并且可以通过添加一些新边使得子图连通。\n\n你的任务是找出最小的可行阈值。", "inputFormat": "输入包含单个测试用例，格式如下。\n\n$$\n\\begin{aligned}\n&n \\ m \\\\\n&l_1 \\ldots l_n \\\\ \n&x_1 \\ y_1 \\\\ \n&\\vdots \\\\\n&x_m \\ y_m \\\\\n\\end{aligned}\n$$\n\n第一行包含两个整数 $n$ （$2 \\le n \\le 10^5$）和 $m$ （$0 \\le m \\le \\min(10^5, \\frac{n(n-1)}{2})$），分别表示图的节点数和边数。节点编号为 $1$ 到 $n$。第二行包含 $n$ 个整数 $l_i$ （$1 \\le l_i \\le 10^9$），表示节点 $i$ 关联的值为 $l_i$。接下来的 $m$ 行中，每行包含两个整数 $x_j$ 和 $y_j$ （$1 \\le x_j < y_j \\le n$），表示节点 $x_j$ 和 $y_j$ 之间有一条边。任意两个节点之间最多存在一条边。", "outputFormat": "输出最小的可行阈值。如果没有可行的阈值，则输出 $-1$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14871", "type": "P", "difficulty": 5, "samples": [["5 10\n12 10 16 28 15\nQ 1 3 1\nQ 3 4 0\nQ 2 2 0\nQ 2 5 2\nU 3 21\nQ 1 3 1\nQ 2 4 1\nQ 3 5 1\nQ 4 4 0\nQ 2 5 2", "4\n4\n10\n20\n6\n14\n21\n28\n210"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "线段树", "ICPC", "横浜"], "title": "[ICPC 2020 Yokohama R] LCM of GCDs", "background": "TL: 10s -> 2s", "description": "You are given a sequence of positive integers, followed by a number of instructions specifying updates to be made and queries to be answered on the sequence. Updates and queries are given in an arbitrary order.\n\nEach of the updates replaces a single item in the sequence with a given value. Updates are accumulated: all the following instructions are on the sequence after the specified replacement.\n\nEach of the queries specifies a subsequence of the (possibly updated) sequence and the number of items to exclude from that subsequence. One or more sets of integers will result depending on which of the items are excluded. Each of such sets has the greatest common divisor (GCD) of its members. The answer to the query is the least common multiple (LCM) of the GCDs of all these sets.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/l4cgvocn.png)\n\nFigure H.1. Answering the last query “Q 2 5 2” of the Sample Input 1\n:::", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n&n \\ m \\\\\n&a_1 \\ldots a_n \\\\\n&c_1 \\\\\n&\\vdots \\\\\n&c_m\n\\end{aligned}\n$$\n\nThe first line has two integers, $n$ and $m$. $n$ ($1 \\le n \\le 10^5$) is the length of the integer sequence, and $m$ ($1 \\le m \\le 10^5$) is the number of instructions. The original integer sequence $a_1, \\ldots, a_n$ is given in the second line.\n\nis given in the second line. $1 \\le a_i \\le 10^6$ holds for $i = 1, \\ldots, n$. Each of the following $m$ lines has either an update instruction starting with a letter U, or a query instruction starting with a letter Q.\n\nAn update instruction has the following format.\n\n$$\n\\begin{aligned}\n&\\text{U } j \\ x\n\\end{aligned}\n$$\n\nThe instruction tells to replace the $j$-th item of the sequence with an integer $x$. $1 \\le j \\le n$ and $1 \\le x \\le 10^6$ hold. Updates are accumulated: all the instructions below are on the sequence after the updates.\n\nA query instruction has the following format.\n\n$$\n\\begin{aligned}\n&\\text{Q } l \\ r \\ k\n\\end{aligned}\n$$\n\nHere, $l$ and $r$ specify the start and the end positions of a subsequence, and $k$ is the number of items to exclude from that subsequence, $b_l, \\ldots, b_r$, where $b_1, \\ldots, b_n$ is the sequence after applying all the updates that come before the query. $1 \\le l$, $0 \\le k \\le 2$, and $l + k \\le r \\le n$ hold.\n", "outputFormat": "No output is required for update instructions. For each of the query instructions, output a line with the LCM of the GCDs of the sets of the items in all the subsequences made by excluding $k$ items from the sequence $b_l, \\ldots, b_r$.", "hint": "For the first query of this test case, “Q 1 3 1”, the subsequence is $12\\ 10\\ 16$. Eliminating a single item results in three item sets, $\\{12, 10\\}$, $\\{12, 16\\}$, and $\\{10, 16\\}$. Their GCDs are $2$, $4$, and $2$, respectively, and thus the output should be their LCM, $4$.\n\nNote that, the update given as the fifth instruction, “U 3 21”, changes the answer to the same query, “Q 1 3 1”, given as the sixth instruction. The update makes the subsequence to $12\\ 10\\ 21$. Thus the item sets after eliminating a single item are $\\{12, 10\\}$, $\\{12, 21\\}$, and $\\{10, 21\\}$. Their GCDs are $2$, $3$, and $1$, respectively, and thus the output for this query should be their LCM, $6$.\n", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Yokohama R] LCM of GCDs", "background": "TL: 10s -> 2s", "description": "You are given a sequence of positive integers, followed by a number of instructions specifying updates to be made and queries to be answered on the sequence. Updates and queries are given in an arbitrary order.\n\nEach of the updates replaces a single item in the sequence with a given value. Updates are accumulated: all the following instructions are on the sequence after the specified replacement.\n\nEach of the queries specifies a subsequence of the (possibly updated) sequence and the number of items to exclude from that subsequence. One or more sets of integers will result depending on which of the items are excluded. Each of such sets has the greatest common divisor (GCD) of its members. The answer to the query is the least common multiple (LCM) of the GCDs of all these sets.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/l4cgvocn.png)\n\nFigure H.1. Answering the last query “Q 2 5 2” of the Sample Input 1\n:::", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n&n \\ m \\\\\n&a_1 \\ldots a_n \\\\\n&c_1 \\\\\n&\\vdots \\\\\n&c_m\n\\end{aligned}\n$$\n\nThe first line has two integers, $n$ and $m$. $n$ ($1 \\le n \\le 10^5$) is the length of the integer sequence, and $m$ ($1 \\le m \\le 10^5$) is the number of instructions. The original integer sequence $a_1, \\ldots, a_n$ is given in the second line.\n\nis given in the second line. $1 \\le a_i \\le 10^6$ holds for $i = 1, \\ldots, n$. Each of the following $m$ lines has either an update instruction starting with a letter U, or a query instruction starting with a letter Q.\n\nAn update instruction has the following format.\n\n$$\n\\begin{aligned}\n&\\text{U } j \\ x\n\\end{aligned}\n$$\n\nThe instruction tells to replace the $j$-th item of the sequence with an integer $x$. $1 \\le j \\le n$ and $1 \\le x \\le 10^6$ hold. Updates are accumulated: all the instructions below are on the sequence after the updates.\n\nA query instruction has the following format.\n\n$$\n\\begin{aligned}\n&\\text{Q } l \\ r \\ k\n\\end{aligned}\n$$\n\nHere, $l$ and $r$ specify the start and the end positions of a subsequence, and $k$ is the number of items to exclude from that subsequence, $b_l, \\ldots, b_r$, where $b_1, \\ldots, b_n$ is the sequence after applying all the updates that come before the query. $1 \\le l$, $0 \\le k \\le 2$, and $l + k \\le r \\le n$ hold.\n", "outputFormat": "No output is required for update instructions. For each of the query instructions, output a line with the LCM of the GCDs of the sets of the items in all the subsequences made by excluding $k$ items from the sequence $b_l, \\ldots, b_r$.", "hint": "For the first query of this test case, “Q 1 3 1”, the subsequence is $12\\ 10\\ 16$. Eliminating a single item results in three item sets, $\\{12, 10\\}$, $\\{12, 16\\}$, and $\\{10, 16\\}$. Their GCDs are $2$, $4$, and $2$, respectively, and thus the output should be their LCM, $4$.\n\nNote that, the update given as the fifth instruction, “U 3 21”, changes the answer to the same query, “Q 1 3 1”, given as the sixth instruction. The update makes the subsequence to $12\\ 10\\ 21$. Thus the item sets after eliminating a single item are $\\{12, 10\\}$, $\\{12, 21\\}$, and $\\{10, 21\\}$. Their GCDs are $2$, $3$, and $1$, respectively, and thus the output for this query should be their LCM, $6$.\n", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Yokohama R] LCM of GCDs", "background": "时间限制：10s -> 2s", "description": "给定一个正整数序列，随后是一系列指令，这些指令指定了对序列的更新以及需要回答的查询。更新和查询以任意顺序给出。\n\n每个更新操作将序列中的一个元素替换为给定值。更新是累积的：后续所有指令都基于指定替换后的序列。\n\n每个查询指定一个（可能更新后的）序列的子序列，以及要从该子序列中排除的元素数量。根据排除哪些元素，将产生一个或多个整数集合。每个这样的集合有其成员的最大公约数（GCD）。查询的答案就是所有这些集合的 GCD 的最小公倍数（LCM）。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/l4cgvocn.png)\n\n图 H.1. 解答样例输入 1 中最后一个查询 “Q 2 5 2”\n:::", "inputFormat": "输入包含单个测试用例，格式如下。\n\n$$\n\\begin{aligned}\n&n \\ m \\\\\n&a_1 \\ldots a_n \\\\\n&c_1 \\\\\n&\\vdots \\\\\n&c_m\n\\end{aligned}\n$$\n\n第一行有两个整数 $n$ 和 $m$。$n$ （$1 \\le n \\le 10^5$）是整数序列的长度，$m$ （$1 \\le m \\le 10^5$）是指令的数量。第二行给出了原始的整数序列 $a_1, \\ldots, a_n$。对于 $i = 1, \\ldots, n$，有 $1 \\le a_i \\le 10^6$。接下来的 $m$ 行中，每行要么是一个以字母 U 开头的更新指令，要么是一个以字母 Q 开头的查询指令。\n\n更新指令的格式如下。\n\n$$\n\\begin{aligned}\n&\\text{U } j \\ x\n\\end{aligned}\n$$\n\n该指令表示将序列的第 $j$ 个元素替换为整数 $x$。满足 $1 \\le j \\le n$ 且 $1 \\le x \\le 10^6$。更新是累积的：以下所有指令都基于更新后的序列。\n\n查询指令的格式如下。\n\n$$\n\\begin{aligned}\n&\\text{Q } l \\ r \\ k\n\\end{aligned}\n$$\n\n其中，$l$ 和 $r$ 指定了一个子序列的起始和结束位置，$k$ 是要从该子序列中排除的元素数量。子序列为 $b_l, \\ldots, b_r$，这里 $b_1, \\ldots, b_n$ 是在应用该查询之前的所有更新后得到的序列。满足 $1 \\le l$，$0 \\le k \\le 2$，且 $l + k \\le r \\le n$。", "outputFormat": "对于更新指令，不需要输出。对于每个查询指令，输出一行，该行内容是：从序列 $b_l, \\ldots, b_r$ 中排除 $k$ 个元素形成的所有子序列对应的整数集合，计算每个集合的 GCD，再计算这些 GCD 的 LCM。", "hint": "对于此测试用例的第一个查询 “Q 1 3 1”，子序列是 $12\\ 10\\ 16$。排除一个元素会产生三个元素集合：$\\{12, 10\\}$、$\\{12, 16\\}$ 和 $\\{10, 16\\}$。它们的 GCD 分别是 $2$、$4$ 和 $2$，因此输出应该是它们的 LCM，即 $4$。\n\n注意，第五个指令给出的更新 “U 3 21” 改变了后续相同查询 “Q 1 3 1”（即第六个指令）的答案。该更新使子序列变为 $12\\ 10\\ 21$。因此，排除一个元素后得到的集合是 $\\{12, 10\\}$、$\\{12, 21\\}$ 和 $\\{10, 21\\}$。它们的 GCD 分别是 $2$、$3$ 和 $1$，所以这个查询的输出应该是它们的 LCM，即 $6$。", "locale": "zh-CN"}}}
{"pid": "P14872", "type": "P", "difficulty": 5, "samples": [["4\nI 1\nI 0\nO 0\nI 0\nO 2\nI 4\nO 0\nO 4", "3"], ["3\nI 0\nI 0\nI 0\nO 0\nO 0\nO 0", "36"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2020", "组合数学", "ICPC", "横浜"], "title": "[ICPC 2020 Yokohama R] High-Tech Detective", "background": "", "description": "The problem set document for the Yokohama Chinatown Gluttony Contest was kept in a safe at the headquarters of the Kanagawa Gourmendies Foundation. It was considered to be quite secure, but, in the morning of the very day of the contest, the executive director of the foundation found that the document was missing!\n\nThe director checked that the document was in the safe when she left the headquarters in the evening of the day before. To open the door of the headquarters office, a valid ID card has to be touched on the reader inside or outside of the door. As the door and its lock are not broken, the thief should have used a valid ID card.\n\nNormally, all the entries and exits through the door are recorded with the ID. The system, however, has been compromised somehow, and some of the recorded ID’s are lost.\n\nIt is sure that nobody was in the office when the director left, but, many persons visited the office since then to prepare the contest materials. It is sure that the same ID card was used only once for entry and then once for exit.\n\nThe director is planning inquiries to grasp all the visits during the night. You are asked to write a program that calculates the number of possible combinations of ID’s to fill the lost parts of the records.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n&n\\\\\n&c_1 \\ x_1\\\\\n&\\vdots\\\\\n&c_{2n} \\ x_{2n}\\\\\n\\end{aligned}\n$$\n\nThe first line contains an integer $n$ ($1 \\le n \\le 5000$), representing the number of visitors during the night. Each visitor has a unique ID numbered from $1$ to $n$. The following $2n$ lines provide (incomplete) entry and exit records in chronological order. The $i$-th line ($1 \\le i \\le 2n$) contains a character $c_i$ and an integer $x_i$ ($0 \\le x_i \\le n$). Here, $c_i = \\text{I}$ and $\\text{O}$ indicate some visitor entered and exited the office, respectively. $x_i$ denotes the visitor ID, where $x_i \\ge 1$ indicates the ID of the visitor is $x_i$, and $x_i = 0$ indicates the ID is lost. At least one of them is $0$. It is guaranteed that there is at least one consistent way to fill the lost ID(s) in the records.\n", "outputFormat": "Output a single integer in a line which is the number of the consistent ways to fill the lost ID(s) modulo $10^9 + 7$.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Yokohama R] High-Tech Detective", "background": "", "description": "The problem set document for the Yokohama Chinatown Gluttony Contest was kept in a safe at the headquarters of the Kanagawa Gourmendies Foundation. It was considered to be quite secure, but, in the morning of the very day of the contest, the executive director of the foundation found that the document was missing!\n\nThe director checked that the document was in the safe when she left the headquarters in the evening of the day before. To open the door of the headquarters office, a valid ID card has to be touched on the reader inside or outside of the door. As the door and its lock are not broken, the thief should have used a valid ID card.\n\nNormally, all the entries and exits through the door are recorded with the ID. The system, however, has been compromised somehow, and some of the recorded ID’s are lost.\n\nIt is sure that nobody was in the office when the director left, but, many persons visited the office since then to prepare the contest materials. It is sure that the same ID card was used only once for entry and then once for exit.\n\nThe director is planning inquiries to grasp all the visits during the night. You are asked to write a program that calculates the number of possible combinations of ID’s to fill the lost parts of the records.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n&n\\\\\n&c_1 \\ x_1\\\\\n&\\vdots\\\\\n&c_{2n} \\ x_{2n}\\\\\n\\end{aligned}\n$$\n\nThe first line contains an integer $n$ ($1 \\le n \\le 5000$), representing the number of visitors during the night. Each visitor has a unique ID numbered from $1$ to $n$. The following $2n$ lines provide (incomplete) entry and exit records in chronological order. The $i$-th line ($1 \\le i \\le 2n$) contains a character $c_i$ and an integer $x_i$ ($0 \\le x_i \\le n$). Here, $c_i = \\text{I}$ and $\\text{O}$ indicate some visitor entered and exited the office, respectively. $x_i$ denotes the visitor ID, where $x_i \\ge 1$ indicates the ID of the visitor is $x_i$, and $x_i = 0$ indicates the ID is lost. At least one of them is $0$. It is guaranteed that there is at least one consistent way to fill the lost ID(s) in the records.\n", "outputFormat": "Output a single integer in a line which is the number of the consistent ways to fill the lost ID(s) modulo $10^9 + 7$.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Yokohama R] High-Tech Detective", "background": "", "description": "横滨中华街暴食大赛的题目文件被保存在神奈川美食基金会总部的保险箱中。它本被认为相当安全，但在比赛当天的早晨，基金会的执行主任发现文件不翼而飞！\n\n主任确认她在前一天晚上离开总部时文件还在保险箱里。要打开总部办公室的门，必须在门内或门外的读卡器上刷一张有效的 ID 卡。由于门和锁都没有损坏，窃贼应该使用了有效的 ID 卡。\n\n正常情况下，所有通过这扇门的进出记录都会与 ID 一起被记录下来。然而，系统不知何故出现了故障，导致部分记录的 ID 丢失了。\n\n可以确定主任离开时办公室里没有人，但之后有许多人为了准备比赛材料而访问了办公室。可以确定的是，同一张 ID 卡只被用于一次进入和随后的一次离开。\n\n主任正计划进行调查，以了解夜间的所有访问情况。你被要求编写一个程序，计算填充记录中丢失部分 ID 的可能组合数量。\n", "inputFormat": "输入包含单个测试用例，格式如下。\n\n$$\n\\begin{aligned}\n&n\\\\\n&c_1 \\ x_1\\\\\n&\\vdots\\\\\n&c_{2n} \\ x_{2n}\\\\\n\\end{aligned}\n$$\n\n第一行包含一个整数 $n$ （$1 \\le n \\le 5000$），表示夜间的访客数量。每位访客都有一个唯一的 ID，编号从 $1$ 到 $n$。接下来的 $2n$ 行按时间顺序提供了（不完整的）进入和离开记录。第 $i$ 行（$1 \\le i \\le 2n$）包含一个字符 $c_i$ 和一个整数 $x_i$ （$0 \\le x_i \\le n$）。这里，$c_i = \\text{I}$ 和 $\\text{O}$ 分别表示有访客进入和离开办公室。$x_i$ 表示访客 ID，其中 $x_i \\ge 1$ 表示访客的 ID 是 $x_i$，$x_i = 0$ 表示 ID 丢失。至少有一个 $x_i$ 为 $0$。保证至少存在一种一致的方式来填充记录中丢失的 ID。", "outputFormat": "输出一行一个整数，表示填充丢失 ID 的一致方式的数量对 $10^9 + 7$ 取模后的结果。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14873", "type": "P", "difficulty": 4, "samples": [["7 2\n1 2\n2 3\n3 4\n4 5\n5 6\n5 7\n2\n4", "2"], ["8 2\n1 2\n2 3\n3 4\n2 5\n5 6\n6 7\n2 8\n2\n6", "7"], ["7 3\n1 2\n2 3\n3 4\n3 5\n4 6\n5 7\n2\n4\n5", "2"], ["11 3\n1 2\n2 3\n3 4\n2 5\n5 6\n6 7\n7 8\n6 9\n9 10\n6 11\n2\n3\n7\n", "9"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "2020", "广度优先搜索 BFS", "ICPC", "横浜"], "title": "[ICPC 2020 Yokohama R] Formica Sokobanica", "background": "", "description": "A new species of ant, named *Formica sokobanica*, was discovered recently. It attracted entomologists’ attention due to its unique habit. These ants do not form colonies. Rather, individuals make up their private nests and keep their food, nuts, in the nests. A nest comprises a lot of small rooms connected with tunnels. They build the rooms only a little bigger than a nut leaving just enough space for air flow; they cannot enter a room with a nut in it. To save the labor, tunnels are so narrow that it exactly fits the size of a nut, and thus nuts should not be left in the tunnels to allow air flow through.\n\nTo enter a room with a nut in it, the nut has to be pushed away to any of the vacant rooms adjacent to that room through the tunnel connecting them. When no adjacent rooms are vacant except the room which the ant came from, the nut cannot be pushed away, and thus the ant cannot enter the room.\n\nDr. Myrmink, one of the entomologists enthused about the ants, has drawn a diagram of a typical nest. The diagram also shows which rooms store nuts in them, and which room the ant is initially in. Your job is to write a program that counts up how many rooms the ant can reach and enter. Pushing a nut into one of the vacant adjacent rooms may make some of the rooms unreachable, while choosing another room to push into may keep the rooms reachable. There can be many combinations of such choices. In such cases, all the rooms should be counted that are possibly reached by one or more choice combinations.\n\nYou may assume that there is no nut in the room the ant is initially in, and that there is no cyclic path in the nest.", "inputFormat": "The input consists of a single test case of the following format, representing the diagram of a nest.\n\n$$\n\\begin{aligned}\n&n \\ m \\\\\n&x_1 \\ y_1 \\\\\n&\\vdots \\\\\n&x_{n-1} \\ y_{n-1} \\\\\n&a_1 \\\\\n&\\vdots \\\\\n&a_m\n\\end{aligned}\n$$\n\nHere, $n$ and $m$ are the numbers of rooms and nuts. They satisfy $1 \\le n \\le 2 \\times 10^5$ and $0 \\le m < n$. Rooms are numbered from $1$ to $n$. The ant is initially in the room $1$.\n\nEach of the following $n - 1$ lines has two integers $x_i$ and $y_i$ ($1 \\le i \\le n - 1$) indicating that a tunnel connects rooms numbered $x_i$ and $y_i$. $1 \\le x_i \\le n$, $1 \\le y_i \\le n$, and $x_i \\ne y_i$ hold. No two tunnels connect the same pair of rooms.\n\nEach of the remaining $m$ lines has an integer $a_k$ ($1 \\le k \\le m$, $2 \\le a_k \\le n$) which indicates that the room numbered $a_k$ has a nut in it. The numbers $a_k$'s are all distinct.\n", "outputFormat": "The output should be a single line containing a single integer, the number of rooms that the ant can reach and enter.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Yokohama R] Formica Sokobanica", "background": "", "description": "A new species of ant, named *Formica sokobanica*, was discovered recently. It attracted entomologists’ attention due to its unique habit. These ants do not form colonies. Rather, individuals make up their private nests and keep their food, nuts, in the nests. A nest comprises a lot of small rooms connected with tunnels. They build the rooms only a little bigger than a nut leaving just enough space for air flow; they cannot enter a room with a nut in it. To save the labor, tunnels are so narrow that it exactly fits the size of a nut, and thus nuts should not be left in the tunnels to allow air flow through.\n\nTo enter a room with a nut in it, the nut has to be pushed away to any of the vacant rooms adjacent to that room through the tunnel connecting them. When no adjacent rooms are vacant except the room which the ant came from, the nut cannot be pushed away, and thus the ant cannot enter the room.\n\nDr. Myrmink, one of the entomologists enthused about the ants, has drawn a diagram of a typical nest. The diagram also shows which rooms store nuts in them, and which room the ant is initially in. Your job is to write a program that counts up how many rooms the ant can reach and enter. Pushing a nut into one of the vacant adjacent rooms may make some of the rooms unreachable, while choosing another room to push into may keep the rooms reachable. There can be many combinations of such choices. In such cases, all the rooms should be counted that are possibly reached by one or more choice combinations.\n\nYou may assume that there is no nut in the room the ant is initially in, and that there is no cyclic path in the nest.", "inputFormat": "The input consists of a single test case of the following format, representing the diagram of a nest.\n\n$$\n\\begin{aligned}\n&n \\ m \\\\\n&x_1 \\ y_1 \\\\\n&\\vdots \\\\\n&x_{n-1} \\ y_{n-1} \\\\\n&a_1 \\\\\n&\\vdots \\\\\n&a_m\n\\end{aligned}\n$$\n\nHere, $n$ and $m$ are the numbers of rooms and nuts. They satisfy $1 \\le n \\le 2 \\times 10^5$ and $0 \\le m < n$. Rooms are numbered from $1$ to $n$. The ant is initially in the room $1$.\n\nEach of the following $n - 1$ lines has two integers $x_i$ and $y_i$ ($1 \\le i \\le n - 1$) indicating that a tunnel connects rooms numbered $x_i$ and $y_i$. $1 \\le x_i \\le n$, $1 \\le y_i \\le n$, and $x_i \\ne y_i$ hold. No two tunnels connect the same pair of rooms.\n\nEach of the remaining $m$ lines has an integer $a_k$ ($1 \\le k \\le m$, $2 \\le a_k \\le n$) which indicates that the room numbered $a_k$ has a nut in it. The numbers $a_k$'s are all distinct.\n", "outputFormat": "The output should be a single line containing a single integer, the number of rooms that the ant can reach and enter.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Yokohama R] Formica Sokobanica", "background": "", "description": "最近发现了一种名为 **推箱子蚁** 的新蚂蚁物种。它们因其独特习性而引起了昆虫学家的注意。这些蚂蚁不形成蚁群。相反，个体建造自己的私人巢穴，并将食物（坚果）储存在巢穴中。一个巢穴包含许多由隧道连接的小房间。它们只将房间建造得比坚果稍大一点，仅留下足够空气流通的空间；它们无法进入有坚果的房间。为了节省劳力，隧道非常狭窄，其大小恰好能容纳一颗坚果，因此坚果不能留在隧道中，以便空气流通。\n\n要进入一个有坚果的房间，必须将坚果通过连接它们的隧道推到该房间的任意一个相邻空房间中。如果除了蚂蚁进来的房间外没有其他相邻的空房间，坚果就无法被推开，因此蚂蚁无法进入该房间。\n\n热衷于研究这种蚂蚁的昆虫学家 Myrmink 博士绘制了一个典型巢穴的示意图。该图还显示了哪些房间储存了坚果，以及蚂蚁最初在哪个房间。你的任务是编写一个程序，计算蚂蚁能够到达并进入的房间数量。将一颗坚果推入某个相邻的空房间可能会使一些房间变得无法到达，而选择另一个房间来推入则可能保持这些房间的可达性。可能存在许多这样的选择组合。在这种情况下，应该将所有可能通过一种或多种选择组合到达的房间都计算在内。\n\n你可以假设蚂蚁最初所在的房间没有坚果，并且巢穴中没有循环路径。", "inputFormat": "输入包含单个测试用例，格式如下，代表一个巢穴的示意图。\n\n$$\n\\begin{aligned}\n&n \\ m \\\\\n&x_1 \\ y_1 \\\\\n&\\vdots \\\\\n&x_{n-1} \\ y_{n-1} \\\\\n&a_1 \\\\\n&\\vdots \\\\\n&a_m\n\\end{aligned}\n$$\n\n其中，$n$ 和 $m$ 分别是房间和坚果的数量。它们满足 $1 \\le n \\le 2 \\times 10^5$ 且 $0 \\le m < n$。房间编号从 $1$ 到 $n$。蚂蚁初始在房间 $1$。\n\n接下来的 $n - 1$ 行中，每行有两个整数 $x_i$ 和 $y_i$ （$1 \\le i \\le n - 1$），表示一条隧道连接编号为 $x_i$ 和 $y_i$ 的房间。满足 $1 \\le x_i \\le n$，$1 \\le y_i \\le n$，且 $x_i \\ne y_i$。没有两条隧道连接同一对房间。\n\n剩下的 $m$ 行中，每行有一个整数 $a_k$ （$1 \\le k \\le m$，$2 \\le a_k \\le n$），表示编号为 $a_k$ 的房间中有一颗坚果。所有 $a_k$ 的值互不相同。\n", "outputFormat": "输出应包含一行，一个整数，表示蚂蚁能够到达并进入的房间数量。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14874", "type": "P", "difficulty": 5, "samples": [["ababc\n6", "10"], ["aabaacaabaa\n102", "251"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2020", "KMP 算法", "有限状态自动机", "ICPC", "横浜"], "title": "[ICPC 2020 Yokohama R] Suffixes may Contain Prefixes", "background": "", "description": "You are playing a game on character strings. At the start of a game, a string of lowercase letters, called the *target string*, is given. Each of the players submits one string of lowercase letters, called a *bullet string*, of the specified length. The winner is the one whose bullet string marks the highest score.\n\nThe score of a bullet string is the sum of the points of all of its suffixes. When the bullet string is “$b_1 b_2 \\dots b_n$”, the point of its suffix $s_k$ starting with the $k$-th character ($1 \\le k \\le n$), “$b_k b_{k+1} \\dots b_n$”, is the length of its longest common prefix with the target string. That is, with the target string “$t_1 t_2 \\dots t_m$”, the point of $s_k$ is $p$ when $t_j = b_{k+j-1}$ for $1 \\le j \\le p$ and either $p = m$, $k + p - 1 = n$, or $t_{p+1} \\ne b_{k+p}$ holds.\n\nYou have to win the game today by any means, as Alyssa promises to have a date with the winner! The game is starting soon. Write a program in a hurry that finds the highest achievable score for the given target string and the bullet length.\n", "inputFormat": "The input consists of a single test case with two lines. The first line contains the non-empty target string of at most 2000 lowercase letters. The second line contains the length of the bullet string, a positive integer not exceeding 2000.\n", "outputFormat": "Output the highest achievable score for the given target string and the given bullet length.", "hint": "For the first sample, “ababab” is the best bullet string. Three among its six suffixes, “ababab”, “abab”, and “ab” obtain $4$, $4$, and $2$ points, respectively, achieving the score $10$. A bullet string “ababca” may look promising, but its suffixes “ababca”, “abca”, and “a” get $5$, $2$, and $1$, summing up only to $8$.\n", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Yokohama R] Suffixes may Contain Prefixes", "background": "", "description": "You are playing a game on character strings. At the start of a game, a string of lowercase letters, called the *target string*, is given. Each of the players submits one string of lowercase letters, called a *bullet string*, of the specified length. The winner is the one whose bullet string marks the highest score.\n\nThe score of a bullet string is the sum of the points of all of its suffixes. When the bullet string is “$b_1 b_2 \\dots b_n$”, the point of its suffix $s_k$ starting with the $k$-th character ($1 \\le k \\le n$), “$b_k b_{k+1} \\dots b_n$”, is the length of its longest common prefix with the target string. That is, with the target string “$t_1 t_2 \\dots t_m$”, the point of $s_k$ is $p$ when $t_j = b_{k+j-1}$ for $1 \\le j \\le p$ and either $p = m$, $k + p - 1 = n$, or $t_{p+1} \\ne b_{k+p}$ holds.\n\nYou have to win the game today by any means, as Alyssa promises to have a date with the winner! The game is starting soon. Write a program in a hurry that finds the highest achievable score for the given target string and the bullet length.\n", "inputFormat": "The input consists of a single test case with two lines. The first line contains the non-empty target string of at most 2000 lowercase letters. The second line contains the length of the bullet string, a positive integer not exceeding 2000.\n", "outputFormat": "Output the highest achievable score for the given target string and the given bullet length.", "hint": "For the first sample, “ababab” is the best bullet string. Three among its six suffixes, “ababab”, “abab”, and “ab” obtain $4$, $4$, and $2$ points, respectively, achieving the score $10$. A bullet string “ababca” may look promising, but its suffixes “ababca”, “abca”, and “a” get $5$, $2$, and $1$, summing up only to $8$.\n", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Yokohama R] Suffixes may Contain Prefixes", "background": "", "description": "你正在玩一个关于字符串的游戏。游戏开始时，会给出一个小写字母字符串，称为**目标字符串**。每位玩家提交一个指定长度的小写字母字符串，称为**子弹字符串**。得分最高的玩家获胜。\n\n子弹字符串的分数是其所有后缀的分值之和。当子弹字符串为 “$b_1 b_2 \\dots b_n$” 时，从其第 $k$ 个字符开始的后缀 $s_k$ （$1 \\le k \\le n$），即 “$b_k b_{k+1} \\dots b_n$”，其分值是该后缀与目标字符串的最长公共前缀的长度。也就是说，如果目标字符串是 “$t_1 t_2 \\dots t_m$”，那么当 $t_j = b_{k+j-1}$ 对于 $1 \\le j \\le p$ 成立，并且满足 $p = m$、$k + p - 1 = n$ 或 $t_{p+1} \\ne b_{k+p}$ 时，$s_k$ 的分值就是 $p$。\n\n你今天必须不惜一切代价赢得比赛，因为 Alyssa 承诺要和获胜者约会！比赛即将开始。赶快编写一个程序，对于给定的目标字符串和子弹长度，找出可达到的最高分数。", "inputFormat": "输入包含两行，为一个测试用例。第一行包含一个非空的目标字符串，由最多 $2000$ 个小写字母组成。第二行包含子弹字符串的长度，是一个不超过 $2000$ 的正整数。", "outputFormat": "输出对于给定的目标字符串和子弹长度，可达到的最高分数。", "hint": "对于第一个样例，“ababab” 是最优的子弹字符串。它的六个后缀中，有三个后缀 “ababab”、“abab” 和 “ab” 分别获得了 $4$、$4$ 和 $2$ 分，总分为 $10$。子弹字符串 “ababca” 可能看起来不错，但其后缀 “ababca”、“abca” 和 “a” 分别得到 $5$、$2$ 和 $1$ 分，总和仅为 $8$。", "locale": "zh-CN"}}}
{"pid": "P14875", "type": "P", "difficulty": 2, "samples": [["19", "5"], ["13", "5"], ["123456789098765", "85"], ["51", "11"], ["0", "0"], ["3", "3"], ["4", "2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "ICPC", "横浜"], "title": "[ICPC 2019 Yokohama R] Fast Forwarding", "background": "", "description": "Mr. Anderson frequently rents video tapes of his favorite classic films. Watching the films so many times, he has learned the precise start times of his favorite scenes in all such films. He now wants to find how to wind the tape to watch his favorite scene as quickly as possible on his video player.\n\nWhen the [play] button is pressed, the film starts at the normal playback speed. The video player has two buttons to control the playback speed: The [3x] button triples the speed, while the [1/3x] button reduces the speed to one third. These speed control buttons, however, do not take effect on the instance they are pressed. Exactly one second after playback starts and every second thereafter, the states of these speed control buttons are checked. If the [3x] button is pressed on the timing of the check, the playback speed becomes three times the current speed. If the [1/3x] button is pressed, the playback speed becomes one third of the current speed, unless it is already the normal speed.\n\nFor instance, assume that his favorite scene starts at $19$ seconds from the start of the film. When the [3x] button is on at one second and at two seconds after the playback starts, and the [1/3x] button is on at three seconds and at five seconds after the start, the desired scene can be watched in the normal speed five seconds after starting the playback, as depicted in the following chart.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/1ba7i53k.png)\n:::\n\nYour task is to compute the shortest possible time period after the playback starts until the desired scene starts. The playback of the scene, of course, should be in the normal speed.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$t$$\n\nThe given single integer $t$ ($0 \\le t < 2^{50}$) is the start time of the target scene.\n", "outputFormat": "Print an integer that is the minimum possible time in seconds before he can start watching the target scene in the normal speed.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2019 Yokohama R] Fast Forwarding", "background": "", "description": "Mr. Anderson frequently rents video tapes of his favorite classic films. Watching the films so many times, he has learned the precise start times of his favorite scenes in all such films. He now wants to find how to wind the tape to watch his favorite scene as quickly as possible on his video player.\n\nWhen the [play] button is pressed, the film starts at the normal playback speed. The video player has two buttons to control the playback speed: The [3x] button triples the speed, while the [1/3x] button reduces the speed to one third. These speed control buttons, however, do not take effect on the instance they are pressed. Exactly one second after playback starts and every second thereafter, the states of these speed control buttons are checked. If the [3x] button is pressed on the timing of the check, the playback speed becomes three times the current speed. If the [1/3x] button is pressed, the playback speed becomes one third of the current speed, unless it is already the normal speed.\n\nFor instance, assume that his favorite scene starts at $19$ seconds from the start of the film. When the [3x] button is on at one second and at two seconds after the playback starts, and the [1/3x] button is on at three seconds and at five seconds after the start, the desired scene can be watched in the normal speed five seconds after starting the playback, as depicted in the following chart.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/1ba7i53k.png)\n:::\n\nYour task is to compute the shortest possible time period after the playback starts until the desired scene starts. The playback of the scene, of course, should be in the normal speed.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$t$$\n\nThe given single integer $t$ ($0 \\le t < 2^{50}$) is the start time of the target scene.\n", "outputFormat": "Print an integer that is the minimum possible time in seconds before he can start watching the target scene in the normal speed.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2019 Yokohama R] Fast Forwarding", "background": "", "description": "Anderson 先生经常租借他最喜欢的经典电影录像带。由于观看了这些电影很多次，他已经学会了所有这些电影中他最喜欢场景的精确开始时间。现在，他想找出如何在他录像机上快速倒带到他想观看的场景。\n\n当按下 [播放] 按钮时，电影以正常播放速度开始播放。录像机有两个按钮可以控制播放速度：[3x] 按钮使速度变为三倍，而 [1/3x] 按钮将速度降低到三分之一。然而，这些速度控制按钮在按下时并不会立即生效。从播放开始后恰好一秒起，以及之后的每一秒，都会检查这些速度控制按钮的状态。如果在检查的时刻 [3x] 按钮被按下，播放速度将变为当前速度的三倍。如果 [1/3x] 按钮被按下，播放速度将变为当前速度的三分之一，除非它已经是正常速度。\n\n例如，假设他最喜欢的场景从电影开始后 $19$ 秒处开始。如果在播放开始后一秒和两秒时 [3x] 按钮被按下，在三秒和五秒时 [1/3x] 按钮被按下，那么他可以在播放开始五秒后以正常速度观看想要的场景，如下图所示。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/1ba7i53k.png)\n:::\n\n你的任务是计算从播放开始到目标场景开始之间可能的最短时间周期。当然，场景的播放必须以正常速度进行。", "inputFormat": "输入包含单个测试用例，格式如下。\n\n$$t$$\n\n给定的单个整数 $t$ （$0 \\le t < 2^{50}$）是目标场景的开始时间。", "outputFormat": "输出一个整数，表示他能以正常速度开始观看目标场景之前的最小可能时间（以秒为单位）。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14876", "type": "P", "difficulty": 2, "samples": [["5 4 2\n1 1 10\n5 4 3", "130"], ["5 4 3\n2 2 0\n4 3 0\n5 1 2", "-14"], ["3 3 2\n1 1 8\n3 3 3", "No"], ["2 2 1\n1 1 -100", "-404"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "ICPC", "横浜"], "title": "[ICPC 2019 Yokohama R] Estimating the Flood Risk", "background": "", "description": "Mr. Boat is the owner of a vast extent of land. As many typhoons have struck Japan this year, he became concerned of flood risk of his estate and he wants to know the average altitude of his land. The land is too vast to measure the altitude at many spots. As no steep slopes are in the estate, he thought that it would be enough to measure the altitudes at only a limited number of sites and then approximate the altitudes of the rest based on them.\n\nMultiple approximations might be possible based on the same measurement results, in which case he wants to know the worst case, that is, one giving the lowest average altitude.\n\nMr. Boat’s estate, which has a rectangular shape, is divided into grid-aligned rectangular areas of the same size. Altitude measurements have been carried out in some of these areas, and the measurement results are now at hand. The altitudes of the remaining areas are to be approximated on the assumption that altitudes of two adjoining areas sharing an edge differ at most 1.\n\nIn the first sample given below, the land is divided into $5 \\times 4$ areas. The altitudes of the areas at $(1,1)$ and $(5,4)$ are measured 10 and 3, respectively. In this case, the altitudes of all the areas are uniquely determined on the assumption that altitudes of adjoining areas differ at most 1.\n\nIn the second sample, there are multiple possibilities, among which one that gives the lowest average altitude should be considered.\n\nIn the third sample, no altitude assignments satisfy the assumption on altitude differences.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/fnsbqvka.png)\n:::\n\nYour job is to write a program that approximates the average altitude of his estate. To be precise, the program should compute the total of approximated and measured altitudes of all the mesh-divided areas. If two or more different approximations are possible, the program should compute the total with the severest approximation, that is, one giving the lowest total of the altitudes.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n&w\\ d\\ n \\\\\n&x_1\\ y_1\\ z_1 \\\\\n&\\vdots \\\\\n&x_n\\ y_n\\ z_n\n\\end{aligned}\n$$\n\nHere, $w$, $d$, and $n$ are integers between 1 and 50, inclusive. $w$ and $d$ are the numbers of areas in the two sides of the land. $n$ is the number of areas where altitudes are measured. The $i$-th line of the following $n$ lines contains three integers, $x_i$, $y_i$, and $z_i$ satisfying $1 \\le x_i \\le w$, $1 \\le y_i \\le d$, and $-100 \\le z_i \\le 100$. They mean that the altitude of the area at $(x_i, y_i)$ was measured to be $z_i$. At most one measurement result is given for the same area, i.e., for $i \\ne j$, $(x_i, y_i) \\ne (x_j, y_j)$.", "outputFormat": "If all the unmeasured areas can be assigned their altitudes without any conflicts with the measured altitudes assuming that two adjoining areas have the altitude difference of at most 1, output an integer that is the **total** of the measured or approximated altitudes of all the areas. If more than one such altitude assignment is possible, output the minimum altitude total among the possible assignments.\n\nIf no altitude assignments satisfy the altitude difference assumption, output **No**.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2019 Yokohama R] Estimating the Flood Risk", "background": "", "description": "Mr. Boat is the owner of a vast extent of land. As many typhoons have struck Japan this year, he became concerned of flood risk of his estate and he wants to know the average altitude of his land. The land is too vast to measure the altitude at many spots. As no steep slopes are in the estate, he thought that it would be enough to measure the altitudes at only a limited number of sites and then approximate the altitudes of the rest based on them.\n\nMultiple approximations might be possible based on the same measurement results, in which case he wants to know the worst case, that is, one giving the lowest average altitude.\n\nMr. Boat’s estate, which has a rectangular shape, is divided into grid-aligned rectangular areas of the same size. Altitude measurements have been carried out in some of these areas, and the measurement results are now at hand. The altitudes of the remaining areas are to be approximated on the assumption that altitudes of two adjoining areas sharing an edge differ at most 1.\n\nIn the first sample given below, the land is divided into $5 \\times 4$ areas. The altitudes of the areas at $(1,1)$ and $(5,4)$ are measured 10 and 3, respectively. In this case, the altitudes of all the areas are uniquely determined on the assumption that altitudes of adjoining areas differ at most 1.\n\nIn the second sample, there are multiple possibilities, among which one that gives the lowest average altitude should be considered.\n\nIn the third sample, no altitude assignments satisfy the assumption on altitude differences.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/fnsbqvka.png)\n:::\n\nYour job is to write a program that approximates the average altitude of his estate. To be precise, the program should compute the total of approximated and measured altitudes of all the mesh-divided areas. If two or more different approximations are possible, the program should compute the total with the severest approximation, that is, one giving the lowest total of the altitudes.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n&w\\ d\\ n \\\\\n&x_1\\ y_1\\ z_1 \\\\\n&\\vdots \\\\\n&x_n\\ y_n\\ z_n\n\\end{aligned}\n$$\n\nHere, $w$, $d$, and $n$ are integers between 1 and 50, inclusive. $w$ and $d$ are the numbers of areas in the two sides of the land. $n$ is the number of areas where altitudes are measured. The $i$-th line of the following $n$ lines contains three integers, $x_i$, $y_i$, and $z_i$ satisfying $1 \\le x_i \\le w$, $1 \\le y_i \\le d$, and $-100 \\le z_i \\le 100$. They mean that the altitude of the area at $(x_i, y_i)$ was measured to be $z_i$. At most one measurement result is given for the same area, i.e., for $i \\ne j$, $(x_i, y_i) \\ne (x_j, y_j)$.", "outputFormat": "If all the unmeasured areas can be assigned their altitudes without any conflicts with the measured altitudes assuming that two adjoining areas have the altitude difference of at most 1, output an integer that is the **total** of the measured or approximated altitudes of all the areas. If more than one such altitude assignment is possible, output the minimum altitude total among the possible assignments.\n\nIf no altitude assignments satisfy the altitude difference assumption, output **No**.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2019 Yokohama R] Estimating the Flood Risk", "background": "", "description": "Boat 先生拥有大片土地。由于今年日本遭受了许多台风袭击，他开始担心自己地产的洪水风险，并想知道其土地的平均海拔。土地面积太大，无法在许多地点测量海拔。由于地产中没有陡坡，他认为只需要在有限数量的地点测量海拔，然后基于这些测量结果来估算其余地点的海拔就足够了。\n\n基于相同的测量结果，可能存在多种估算方式。在这种情况下，他想知道最坏的情况，即给出最低平均海拔的情况。\n\nBoat 先生的地产呈矩形，被划分为网格对齐、大小相同的矩形区域。其中一些区域已经进行了海拔测量，现在手头有测量结果。其余区域的海拔将基于以下假设进行估算：共享一条边的两个相邻区域的海拔差最多为 $1$。\n\n在下面给出的第一个样例中，土地被划分为 $5 \\times 4$ 个区域。位置 $(1,1)$ 和 $(5,4)$ 的区域测量海拔分别为 $10$ 和 $3$。在这种情况下，假设相邻区域的海拔差最多为 $1$，所有区域的海拔被唯一确定。\n\n在第二个样例中，存在多种可能性，应考虑其中给出最低平均海拔的那种。\n\n在第三个样例中，没有海拔分配能满足关于海拔差的假设。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/fnsbqvka.png)\n:::\n\n你的任务是编写一个程序来估算他地产的平均海拔。准确地说，程序应计算所有网格划分区域的估算海拔和测量海拔的**总和**。如果存在两种或多种不同的估算方式，程序应计算最严苛的估算方式下的总和，即给出最低海拔总和的那种方式。", "inputFormat": "输入包含单个测试用例，格式如下。\n\n$$\n\\begin{aligned}\n&w\\ d\\ n \\\\\n&x_1\\ y_1\\ z_1 \\\\\n&\\vdots \\\\\n&x_n\\ y_n\\ z_n\n\\end{aligned}\n$$\n\n其中，$w$、$d$ 和 $n$ 是介于 $1$ 到 $50$ 之间（含）的整数。$w$ 和 $d$ 是土地两个方向上的区域数量。$n$ 是进行了海拔测量的区域数量。接下来的 $n$ 行中，第 $i$ 行包含三个整数 $x_i$、$y_i$ 和 $z_i$，满足 $1 \\le x_i \\le w$，$1 \\le y_i \\le d$，且 $-100 \\le z_i \\le 100$。它们表示位于 $(x_i, y_i)$ 的区域的测量海拔为 $z_i$。同一区域最多给出一个测量结果，即对于 $i \\ne j$，有 $(x_i, y_i) \\ne (x_j, y_j)$。", "outputFormat": "如果所有未测量的区域都能在不与测量海拔冲突的情况下分配海拔，且假设两个相邻区域的海拔差最多为 $1$，则输出一个整数，即所有区域的测量或估算海拔的**总和**。如果存在多种这样的海拔分配方式，则输出可能分配方式中的最小海拔总和。\n\n如果没有海拔分配能满足海拔差假设，则输出 **No**。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14877", "type": "P", "difficulty": 6, "samples": [["8 5 10 5\n1 1 7\n3 1 2\n1 5 6\n3 1 4\n3 6 8", "70"], ["26 3 9 7\n1 11 13\n3 1 11\n3 18 26", "182"], ["21 10 10 5\n1 10 21\n3 4 16\n1 1 7\n3 11 21\n3 1 16\n3 3 3\n2 1 17\n3 5 18\n1 7 11\n2 3 14", "210"], ["21 15 8 7\n2 12 21\n2 1 2\n3 6 13\n2 13 17\n1 11 19\n3 3 5\n1 12 13\n3 2 2\n1 12 15\n1 5 17\n1 2 3\n1 1 9\n1 8 12\n3 8 9\n3 2 9", "153"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "ICPC", "横浜"], "title": "[ICPC 2019 Yokohama R] Wall Painting", "background": "TL: 6s -> 3s", "description": "Here stands a wall made of a number of vertical panels. The panels are not painted yet.\n\nYou have a number of robots each of which can paint panels in a single color, either red, green, or blue. Each of the robots, when activated, paints panels between a certain position and another certain position in a certain color. The panels painted and the color to paint them are fixed for each of the robots, but which of them are to be activated and the order of their activation can be arbitrarily decided.\n\nYou’d like to have the wall painted to have a high *aesthetic value*. Here, the aesthetic value of the wall is defined simply as the sum of aesthetic values of the panels of the wall, and the aesthetic value of a panel is defined to be:\n\n- $0$, if the panel is left unpainted.\n- The bonus value specified, if it is painted only in a single color, no matter how many times it is painted.\n- The penalty value specified, if it is once painted in a color and then overpainted in one or more different colors.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n&n\\ m\\ x\\ y \\\\\n&c_1\\ l_1\\ r_1 \\\\\n&\\vdots \\\\\n&c_m\\ l_m\\ r_m\n\\end{aligned}\n$$\n\nHere, $n$ is the number of the panels ($1 \\le n \\le 10^9$) and $m$ is the number of robots ($1 \\le m \\le 2 \\times 10^5$). $x$ and $y$ are integers between 1 and $10^5$, inclusive. $x$ is the bonus value and $-y$ is the penalty value. The panels of the wall are consecutively numbered 1 through $n$. The $i$-th robot, when activated, paints all the panels of numbers $l_i$ through $r_i$ ($1 \\le l_i \\le r_i \\le n$) in color with color number $c_i$ ($c_i \\in \\{1,2,3\\}$). Color numbers 1, 2, and 3 correspond to red, green, and blue, respectively.", "outputFormat": "Output a single integer in a line which is the maximum achievable aesthetic value of the wall.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2019 Yokohama R] Wall Painting", "background": "TL: 6s -> 3s", "description": "Here stands a wall made of a number of vertical panels. The panels are not painted yet.\n\nYou have a number of robots each of which can paint panels in a single color, either red, green, or blue. Each of the robots, when activated, paints panels between a certain position and another certain position in a certain color. The panels painted and the color to paint them are fixed for each of the robots, but which of them are to be activated and the order of their activation can be arbitrarily decided.\n\nYou’d like to have the wall painted to have a high *aesthetic value*. Here, the aesthetic value of the wall is defined simply as the sum of aesthetic values of the panels of the wall, and the aesthetic value of a panel is defined to be:\n\n- $0$, if the panel is left unpainted.\n- The bonus value specified, if it is painted only in a single color, no matter how many times it is painted.\n- The penalty value specified, if it is once painted in a color and then overpainted in one or more different colors.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n&n\\ m\\ x\\ y \\\\\n&c_1\\ l_1\\ r_1 \\\\\n&\\vdots \\\\\n&c_m\\ l_m\\ r_m\n\\end{aligned}\n$$\n\nHere, $n$ is the number of the panels ($1 \\le n \\le 10^9$) and $m$ is the number of robots ($1 \\le m \\le 2 \\times 10^5$). $x$ and $y$ are integers between 1 and $10^5$, inclusive. $x$ is the bonus value and $-y$ is the penalty value. The panels of the wall are consecutively numbered 1 through $n$. The $i$-th robot, when activated, paints all the panels of numbers $l_i$ through $r_i$ ($1 \\le l_i \\le r_i \\le n$) in color with color number $c_i$ ($c_i \\in \\{1,2,3\\}$). Color numbers 1, 2, and 3 correspond to red, green, and blue, respectively.", "outputFormat": "Output a single integer in a line which is the maximum achievable aesthetic value of the wall.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2019 Yokohama R] Wall Painting", "background": "时间限制：6s -> 3s", "description": "这里有一面由若干垂直面板构成的墙。这些面板尚未涂色。\n\n你拥有若干个机器人，每个机器人可以用单一颜色（红色、绿色或蓝色）为面板涂色。每个机器人被激活时，会在特定位置到另一个特定位置之间的面板上涂上特定颜色。每个机器人要涂色的面板和涂色颜色是固定的，但哪些机器人被激活以及它们的激活顺序可以任意决定。\n\n你希望墙面被涂色后具有较高的**美学价值**。这里，墙面的美学价值简单地定义为墙面上所有面板的美学价值之和，而单个面板的美学价值定义如下：\n\n- $0$，如果面板未被涂色。\n- 指定的奖励值，如果面板只被涂上一种颜色，无论被涂了多少次。\n- 指定的惩罚值（负值），如果面板先被涂上一种颜色，然后又被一种或多种不同的颜色覆盖涂色。", "inputFormat": "输入包含单个测试用例，格式如下。\n\n$$\n\\begin{aligned}\n&n\\ m\\ x\\ y \\\\\n&c_1\\ l_1\\ r_1 \\\\\n&\\vdots \\\\\n&c_m\\ l_m\\ r_m\n\\end{aligned}\n$$\n\n其中，$n$ 是面板的数量（$1 \\le n \\le 10^9$），$m$ 是机器人的数量（$1 \\le m \\le 2 \\times 10^5$）。$x$ 和 $y$ 是 $1$ 到 $10^5$ 之间（含）的整数。$x$ 是奖励值，$-y$ 是惩罚值。墙的面板按顺序编号为 $1$ 到 $n$。第 $i$ 个机器人被激活时，会将编号从 $l_i$ 到 $r_i$ 的所有面板（$1 \\le l_i \\le r_i \\le n$）涂上颜色编号为 $c_i$ 的颜色（$c_i \\in \\{1,2,3\\}$）。颜色编号 $1$、$2$ 和 $3$ 分别对应红色、绿色和蓝色。", "outputFormat": "输出一行一个整数，表示墙面可达到的最大美学价值。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14878", "type": "P", "difficulty": 7, "samples": [["3\n0 0 0\n1 0 0\n3 0 0\n1 2\n2 3\n0 0 0\n0 2 2\n0 3 3\n4 5\n5 6", "1"], ["4\n1 0 0\n2 0 0\n2 1 0\n2 -1 0\n1 2\n2 3\n2 4\n0 1 1\n0 0 0\n0 2 0\n0 0 2\n5 6\n5 7\n5 8", "2"], ["4\n1 0 0\n2 0 0\n2 1 0\n2 -1 0\n1 2\n1 3\n2 4\n0 1 1\n0 0 0\n0 2 0\n0 0 2\n5 6\n5 7\n5 8", "0"], ["4\n1 0 0\n2 0 0\n2 2 0\n2 -1 0\n1 2\n2 3\n2 4\n0 1 1\n0 0 0\n0 2 0\n0 0 2\n5 6\n5 7\n5 8", "0"], ["3\n0 0 0\n0 0 1\n0 0 2\n1 2\n1 3\n10 4 6\n0 0 0\n5 2 3\n4 5\n5 6", "1"], ["4\n0 0 0\n1 3 3\n-1 5 5\n-10 2 2\n1 2\n1 3\n1 4\n1 1 6\n0 0 0\n-1 -1 10\n-10 -10 4\n5 6\n6 7\n6 8", "1"], ["7\n0 0 0\n1 0 0\n-1 0 0\n0 1 0\n0 -1 0\n0 0 1\n0 0 -1\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n0 0 0\n2 0 0\n-2 0 0\n0 2 0\n0 -2 0\n0 0 2\n0 0 -2\n8 9\n8 10\n8 11\n8 12\n8 13\n8 14", "24"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "线性代数", "ICPC", "横浜"], "title": "[ICPC 2019 Yokohama R] Twin Trees Bros.", "background": "", "description": "To meet the demand of ICPC (International Cacao Plantation Consortium), you have to check\nwhether two given trees are twins or not.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/xuyjp3ku.png)\n\nExample of two trees in the three-dimensional space.\n:::\n\nThe term *tree* in the graph theory means a connected graph where the number of edges is one less than the number of nodes. ICPC, in addition, gives three-dimensional grid points as the locations of the tree nodes. Their definition of two trees being *twins* is that, there exists a geometric transformation function which gives a one-to-one mapping of all the nodes of one tree to the nodes of the other such that for each edge of one tree, there exists an edge in the other tree connecting the corresponding nodes. The geometric transformation should be a combination of the following transformations:\n\n- translations, in which coordinate values are added with some constants,\n- uniform scaling with positive scale factors, in which all three coordinate values are multiplied by the same positive constant, and\n- rotations of any amounts around either $x$-, $y$-, and $z$-axes.\n\nNote that two trees can be twins in more than one way, that is, with different correspondences of nodes.\n\nWrite a program that decides whether two trees are twins or not and outputs the number of different node correspondences.\n\nHereinafter, transformations will be described in the right-handed $xyz$-coordinate system.\n\nTrees in the sample inputs 1 through 4 are shown in the following figures. The numbers in the figures are the node numbers defined below.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/3ziqe2c6.png)\n:::\n\nFor the sample input 1, each node of the red tree is mapped to the corresponding node of the blue tree by the transformation that translates $(-3,0,0)$, rotates $-\\pi/2$ around the $z$-axis, rotates $\\pi/4$ around the $x$-axis, and finally scales by $\\sqrt{2}$. By this mapping, nodes $\\#1$, $\\#2$, and $\\#3$ of the red tree at $(0,0,0)$, $(1,0,0)$, and $(3,0,0)$ correspond to nodes $\\#6$, $\\#5$, and $\\#4$ of the blue tree at $(0,3,3)$, $(0,2,2)$, and $(0,0,0)$, respectively. This is the only possible correspondence of the twin trees.\n\nFor the sample input 2, red nodes $\\#1$, $\\#2$, $\\#3$, and $\\#4$ can be mapped to blue nodes $\\#6$, $\\#5$, $\\#7$, and $\\#8$. Another node correspondence exists that maps nodes $\\#1$, $\\#2$, $\\#3$, and $\\#4$ to $\\#6$, $\\#5$, $\\#8$, and $\\#7$.\n\nFor the sample input 3, the two trees are *not* twins. There exist transformations that map nodes of one tree to distinct nodes of the other, but the edge connections do not agree.\n\nFor the sample input 4, there is no transformation that maps nodes of one tree to those of the other.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n&n \\\\\n&x_1\\ y_1\\ z_1 \\\\\n&\\vdots \\\\\n&x_n\\ y_n\\ z_n \\\\\n&u_1\\ v_1 \\\\\n&\\vdots \\\\\n&u_{n-1}\\ v_{n-1} \\\\\n&x_{n+1}\\ y_{n+1}\\ z_{n+1} \\\\\n&\\vdots \\\\\n&x_{2n}\\ y_{2n}\\ z_{2n} \\\\\n&u_n\\ v_n \\\\\n&\\vdots \\\\\n&u_{2n-2}\\ v_{2n-2}\n\\end{aligned}\n$$\n\nThe input describes two trees. The first line contains an integer $n$ representing the number of nodes of each tree ($3 \\le n \\le 200$). Descriptions of two trees follow.\n\nDescription of a tree consists of $n$ lines that give the vertex positions and $n-1$ lines that show the connection relation of the vertices.\n\nNodes are numbered 1 through $n$ for the first tree, and $n+1$ through $2n$ for the second tree.\n\nThe triplet $(x_i, y_i, z_i)$ gives the coordinates of the node numbered $i$. $x_i$, $y_i$, and $z_i$ are integers in the range between $-1000$ and $1000$, inclusive. Nodes of a single tree have distinct coordinates.\n\nThe pair of integers $(u_j, v_j)$ means that an edge exists between nodes numbered $u_j$ and $v_j$ ($u_j \\ne v_j$). $1 \\le u_j \\le n$ and $1 \\le v_j \\le n$ hold for $1 \\le j \\le n-1$, and $n+1 \\le u_j \\le 2n$ and $n+1 \\le v_j \\le 2n$ hold for $n \\le j \\le 2n-2$.", "outputFormat": "Output the number of different node correspondences if two trees are twins. Output a zero, otherwise.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2019 Yokohama R] Twin Trees Bros.", "background": "", "description": "To meet the demand of ICPC (International Cacao Plantation Consortium), you have to check\nwhether two given trees are twins or not.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/xuyjp3ku.png)\n\nExample of two trees in the three-dimensional space.\n:::\n\nThe term *tree* in the graph theory means a connected graph where the number of edges is one less than the number of nodes. ICPC, in addition, gives three-dimensional grid points as the locations of the tree nodes. Their definition of two trees being *twins* is that, there exists a geometric transformation function which gives a one-to-one mapping of all the nodes of one tree to the nodes of the other such that for each edge of one tree, there exists an edge in the other tree connecting the corresponding nodes. The geometric transformation should be a combination of the following transformations:\n\n- translations, in which coordinate values are added with some constants,\n- uniform scaling with positive scale factors, in which all three coordinate values are multiplied by the same positive constant, and\n- rotations of any amounts around either $x$-, $y$-, and $z$-axes.\n\nNote that two trees can be twins in more than one way, that is, with different correspondences of nodes.\n\nWrite a program that decides whether two trees are twins or not and outputs the number of different node correspondences.\n\nHereinafter, transformations will be described in the right-handed $xyz$-coordinate system.\n\nTrees in the sample inputs 1 through 4 are shown in the following figures. The numbers in the figures are the node numbers defined below.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/3ziqe2c6.png)\n:::\n\nFor the sample input 1, each node of the red tree is mapped to the corresponding node of the blue tree by the transformation that translates $(-3,0,0)$, rotates $-\\pi/2$ around the $z$-axis, rotates $\\pi/4$ around the $x$-axis, and finally scales by $\\sqrt{2}$. By this mapping, nodes $\\#1$, $\\#2$, and $\\#3$ of the red tree at $(0,0,0)$, $(1,0,0)$, and $(3,0,0)$ correspond to nodes $\\#6$, $\\#5$, and $\\#4$ of the blue tree at $(0,3,3)$, $(0,2,2)$, and $(0,0,0)$, respectively. This is the only possible correspondence of the twin trees.\n\nFor the sample input 2, red nodes $\\#1$, $\\#2$, $\\#3$, and $\\#4$ can be mapped to blue nodes $\\#6$, $\\#5$, $\\#7$, and $\\#8$. Another node correspondence exists that maps nodes $\\#1$, $\\#2$, $\\#3$, and $\\#4$ to $\\#6$, $\\#5$, $\\#8$, and $\\#7$.\n\nFor the sample input 3, the two trees are *not* twins. There exist transformations that map nodes of one tree to distinct nodes of the other, but the edge connections do not agree.\n\nFor the sample input 4, there is no transformation that maps nodes of one tree to those of the other.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n&n \\\\\n&x_1\\ y_1\\ z_1 \\\\\n&\\vdots \\\\\n&x_n\\ y_n\\ z_n \\\\\n&u_1\\ v_1 \\\\\n&\\vdots \\\\\n&u_{n-1}\\ v_{n-1} \\\\\n&x_{n+1}\\ y_{n+1}\\ z_{n+1} \\\\\n&\\vdots \\\\\n&x_{2n}\\ y_{2n}\\ z_{2n} \\\\\n&u_n\\ v_n \\\\\n&\\vdots \\\\\n&u_{2n-2}\\ v_{2n-2}\n\\end{aligned}\n$$\n\nThe input describes two trees. The first line contains an integer $n$ representing the number of nodes of each tree ($3 \\le n \\le 200$). Descriptions of two trees follow.\n\nDescription of a tree consists of $n$ lines that give the vertex positions and $n-1$ lines that show the connection relation of the vertices.\n\nNodes are numbered 1 through $n$ for the first tree, and $n+1$ through $2n$ for the second tree.\n\nThe triplet $(x_i, y_i, z_i)$ gives the coordinates of the node numbered $i$. $x_i$, $y_i$, and $z_i$ are integers in the range between $-1000$ and $1000$, inclusive. Nodes of a single tree have distinct coordinates.\n\nThe pair of integers $(u_j, v_j)$ means that an edge exists between nodes numbered $u_j$ and $v_j$ ($u_j \\ne v_j$). $1 \\le u_j \\le n$ and $1 \\le v_j \\le n$ hold for $1 \\le j \\le n-1$, and $n+1 \\le u_j \\le 2n$ and $n+1 \\le v_j \\le 2n$ hold for $n \\le j \\le 2n-2$.", "outputFormat": "Output the number of different node correspondences if two trees are twins. Output a zero, otherwise.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2019 Yokohama R] Twin Trees Bros.", "background": "", "description": "为了满足 ICPC（国际可可种植联盟）的需求，你必须检查两棵给定的树是否是双胞胎。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/xuyjp3ku.png)\n\n三维空间中两棵树的示例。\n:::\n\n图论中的术语**树**指的是一个连通图，其中边的数量比节点的数量少 $1$。此外，ICPC 将三维网格点作为树节点的位置。他们对于两棵树是**双胞胎**的定义是：存在一个几何变换函数，能将一棵树的所有节点一一映射到另一棵树的节点上，使得对于一棵树的每条边，另一棵树中都存在一条边连接相应的节点。该几何变换应为以下变换的组合：\n\n- 平移：坐标值加上某些常数。\n- 具有正比例系数的均匀缩放：所有三个坐标值乘以相同的正常数。\n- 围绕 $x$ 轴、$y$ 轴和 $z$ 轴进行任意角度的旋转。\n\n注意，两棵树可能以不止一种方式成为双胞胎，即具有不同的节点对应关系。\n\n编写一个程序，判断两棵树是否是双胞胎，并输出不同节点对应关系的数量。\n\n在下文中，变换将在右手 $xyz$ 坐标系中描述。\n\n样例输入 $1$ 到 $4$ 中的树如下图所示。图中的数字是下面定义的节点编号。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/3ziqe2c6.png)\n:::\n\n对于样例输入 $1$，红色树的每个节点通过以下变换映射到蓝色树的对应节点：平移 $(-3,0,0)$，绕 $z$ 轴旋转 $-\\pi/2$，绕 $x$ 轴旋转 $\\pi/4$，最后缩放 $\\sqrt{2}$ 倍。通过此映射，红色树中位于 $(0,0,0)$、$(1,0,0)$ 和 $(3,0,0)$ 的节点 $\\#1$、$\\#2$ 和 $\\#3$ 分别对应蓝色树中位于 $(0,3,3)$、$(0,2,2)$ 和 $(0,0,0)$ 的节点 $\\#6$、$\\#5$ 和 $\\#4$。这是这对双胞胎树唯一可能的对应关系。\n\n对于样例输入 $2$，红色节点 $\\#1$、$\\#2$、$\\#3$ 和 $\\#4$ 可以映射到蓝色节点 $\\#6$、$\\#5$、$\\#7$ 和 $\\#8$。还存在另一种节点对应关系，将节点 $\\#1$、$\\#2$、$\\#3$ 和 $\\#4$ 映射到 $\\#6$、$\\#5$、$\\#8$ 和 $\\#7$。\n\n对于样例输入 $3$，这两棵树**不是**双胞胎。存在将一棵树的节点映射到另一棵树不同节点的变换，但边的连接关系不匹配。\n\n对于样例输入 $4$，不存在将一棵树的节点映射到另一棵树节点的变换。", "inputFormat": "输入包含单个测试用例，格式如下。\n\n$$\n\\begin{aligned}\n&n \\\\\n&x_1\\ y_1\\ z_1 \\\\\n&\\vdots \\\\\n&x_n\\ y_n\\ z_n \\\\\n&u_1\\ v_1 \\\\\n&\\vdots \\\\\n&u_{n-1}\\ v_{n-1} \\\\\n&x_{n+1}\\ y_{n+1}\\ z_{n+1} \\\\\n&\\vdots \\\\\n&x_{2n}\\ y_{2n}\\ z_{2n} \\\\\n&u_n\\ v_n \\\\\n&\\vdots \\\\\n&u_{2n-2}\\ v_{2n-2}\n\\end{aligned}\n$$\n\n输入描述了两棵树。第一行包含一个整数 $n$，表示每棵树的节点数量（$3 \\le n \\le 200$）。接下来是两棵树的描述。\n\n一棵树的描述由 $n$ 行给出顶点位置，以及 $n-1$ 行显示顶点的连接关系。\n\n第一棵树的节点编号为 $1$ 到 $n$，第二棵树的节点编号为 $n+1$ 到 $2n$。\n\n三元组 $(x_i, y_i, z_i)$ 给出了编号为 $i$ 的节点的坐标。$x_i$、$y_i$ 和 $z_i$ 是介于 $-1000$ 和 $1000$ 之间（含）的整数。单棵树的节点坐标互不相同。\n\n整数对 $(u_j, v_j)$ 表示编号为 $u_j$ 和 $v_j$ 的节点之间存在一条边（$u_j \\ne v_j$）。对于 $1 \\le j \\le n-1$，满足 $1 \\le u_j \\le n$ 和 $1 \\le v_j \\le n$；对于 $n \\le j \\le 2n-2$，满足 $n+1 \\le u_j \\le 2n$ 和 $n+1 \\le v_j \\le 2n$。", "outputFormat": "如果两棵树是双胞胎，则输出不同节点对应关系的数量。否则，输出 $0$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14879", "type": "P", "difficulty": 5, "samples": [["6 3\n1 3 4 2 6 5", "4"], ["6 6\n1 3 4 2 6 5", "8"], ["4 4\n4 3 1 2", "0"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2019", "二分图", "ICPC", "横浜"], "title": "[ICPC 2019 Yokohama R] Reordering the Documents", "background": "", "description": "Susan is good at arranging her dining table for convenience, but not her office desk.\n\nSusan has just finished the paperwork on a set of documents, which are still piled on her desk. They have serial numbers and *were* stacked in order when her boss brought them in. The ordering, however, is not perfect now, as she has been too lazy to put the documents slid out of the pile back to their proper positions. Hearing that she has finished, the boss wants her to return the documents immediately in the document box he is sending her. The documents should be stowed in the box, of course, in the order of their serial numbers.\n\nThe desk has room just enough for two more document piles where Susan plans to make two temporary piles. All the documents in the current pile are to be moved one by one from the top to either of the two temporary piles. As making these piles too tall in haste would make them tumble, not too many documents should be placed on them. After moving *all* the documents to the temporary piles and receiving the document box, documents in the two piles will be moved from their tops, one by one, into the box. Documents should be in reverse order of their serial numbers in the two piles to allow moving them to the box in order.\n\nFor example, assume that the pile has six documents $\\#1$, $\\#3$, $\\#4$, $\\#2$, $\\#6$, and $\\#5$, in this order from the top, and that the temporary piles can have no more than three documents. Then, she can form two temporary piles, one with documents $\\#6$, $\\#4$, and $\\#3$, from the top, and the other with $\\#5$, $\\#2$, and $\\#1$ (Figure E.1). Both of the temporary piles are reversely ordered. Then, comparing the serial numbers of documents on top of the two temporary piles, one with the larger number ($\\#6$, in this case) is to be removed and stowed into the document box first. Repeating this, all the documents will be perfectly ordered in the document box.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/z58fkr39.png)\n\nFigure E.1. Making two temporary piles\n:::\n\nSusan is wondering whether the plan is actually feasible with the documents in the current pile and, if so, how many different ways of stacking them to two temporary piles would do. You are asked to help Susan by writing a program to compute the number of different ways, which should be zero if the plan is not feasible.\n\nAs each of the documents in the pile can be moved to either of the two temporary piles, for $n$ documents, there are $2^n$ different choice combinations in total, but some of them may disturb the reverse order of the temporary piles and are thus inappropriate.\n\nThe example described above corresponds to the first case of the sample input. In this case, the last two documents, $\\#5$ and $\\#6$, can be swapped their destinations. Also, exchanging the roles of two temporary piles totally will be OK. As any other move sequences would make one of the piles higher than three and/or make them out of order, the total number of different ways of stacking documents to temporary piles in this example is $2 \\times 2 = 4$.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n&n\\ m\\\\\n&s_1 \\dots s_n\\\\\n\\end{aligned}\n$$\n\nHere, $n$ is the number of documents in the pile ($1 \\le n \\le 5000$), and $m$ is the number of documents that can be stacked in one temporary pile without committing risks of making it tumble down ($n/2 \\le m \\le n$). Numbers $s_1$ through $s_n$ are the serial numbers of the documents in the document pile, from its top to its bottom. It is guaranteed that all the numbers 1 through $n$ appear exactly once.\n", "outputFormat": "Output a single integer in a line which is the number of ways to form two temporary piles suited for the objective. When no choice will do, the number of ways is 0, of course.\n\nIf the number of possible ways is greater than or equal to $10^9 + 7$, output the number of ways modulo $10^9 + 7$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2019 Yokohama R] Reordering the Documents", "background": "", "description": "Susan is good at arranging her dining table for convenience, but not her office desk.\n\nSusan has just finished the paperwork on a set of documents, which are still piled on her desk. They have serial numbers and *were* stacked in order when her boss brought them in. The ordering, however, is not perfect now, as she has been too lazy to put the documents slid out of the pile back to their proper positions. Hearing that she has finished, the boss wants her to return the documents immediately in the document box he is sending her. The documents should be stowed in the box, of course, in the order of their serial numbers.\n\nThe desk has room just enough for two more document piles where Susan plans to make two temporary piles. All the documents in the current pile are to be moved one by one from the top to either of the two temporary piles. As making these piles too tall in haste would make them tumble, not too many documents should be placed on them. After moving *all* the documents to the temporary piles and receiving the document box, documents in the two piles will be moved from their tops, one by one, into the box. Documents should be in reverse order of their serial numbers in the two piles to allow moving them to the box in order.\n\nFor example, assume that the pile has six documents $\\#1$, $\\#3$, $\\#4$, $\\#2$, $\\#6$, and $\\#5$, in this order from the top, and that the temporary piles can have no more than three documents. Then, she can form two temporary piles, one with documents $\\#6$, $\\#4$, and $\\#3$, from the top, and the other with $\\#5$, $\\#2$, and $\\#1$ (Figure E.1). Both of the temporary piles are reversely ordered. Then, comparing the serial numbers of documents on top of the two temporary piles, one with the larger number ($\\#6$, in this case) is to be removed and stowed into the document box first. Repeating this, all the documents will be perfectly ordered in the document box.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/z58fkr39.png)\n\nFigure E.1. Making two temporary piles\n:::\n\nSusan is wondering whether the plan is actually feasible with the documents in the current pile and, if so, how many different ways of stacking them to two temporary piles would do. You are asked to help Susan by writing a program to compute the number of different ways, which should be zero if the plan is not feasible.\n\nAs each of the documents in the pile can be moved to either of the two temporary piles, for $n$ documents, there are $2^n$ different choice combinations in total, but some of them may disturb the reverse order of the temporary piles and are thus inappropriate.\n\nThe example described above corresponds to the first case of the sample input. In this case, the last two documents, $\\#5$ and $\\#6$, can be swapped their destinations. Also, exchanging the roles of two temporary piles totally will be OK. As any other move sequences would make one of the piles higher than three and/or make them out of order, the total number of different ways of stacking documents to temporary piles in this example is $2 \\times 2 = 4$.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n&n\\ m\\\\\n&s_1 \\dots s_n\\\\\n\\end{aligned}\n$$\n\nHere, $n$ is the number of documents in the pile ($1 \\le n \\le 5000$), and $m$ is the number of documents that can be stacked in one temporary pile without committing risks of making it tumble down ($n/2 \\le m \\le n$). Numbers $s_1$ through $s_n$ are the serial numbers of the documents in the document pile, from its top to its bottom. It is guaranteed that all the numbers 1 through $n$ appear exactly once.\n", "outputFormat": "Output a single integer in a line which is the number of ways to form two temporary piles suited for the objective. When no choice will do, the number of ways is 0, of course.\n\nIf the number of possible ways is greater than or equal to $10^9 + 7$, output the number of ways modulo $10^9 + 7$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2019 Yokohama R] Reordering the Documents", "background": "", "description": "Susan 擅长为了便利而布置餐桌，但不擅长整理办公桌。\n\nSusan 刚完成了一组文件的文书工作，这些文件仍然堆在她的桌子上。它们有序列号，并且当她的老板拿进来时**原本**是按顺序堆叠的。然而，由于她太懒而没有将滑出文件堆的文件放回正确位置，现在的顺序并不完美。听到她已完成工作，老板希望她立即将他送来的文件盒中的文件归还。当然，文件应按其序列号的顺序存放在盒子中。\n\n桌子上的空间刚好够再放两堆文件，Susan 计划在这两个位置制作两个临时文件堆。当前文件堆中的所有文件都将逐个从顶部移动到两个临时文件堆之一。由于匆忙将文件堆得太高会导致它们倒塌，所以不应在临时堆上放置太多文件。在将**所有**文件移动到临时堆并收到文件盒后，两个堆中的文件将从顶部逐个移入盒子。为了使它们能按顺序移入盒子，两个堆中的文件应与其序列号相反的顺序排列。\n\n例如，假设文件堆中有六份文件 $\\#1$、$\\#3$、$\\#4$、$\\#2$、$\\#6$ 和 $\\#5$，从上到下按此顺序排列，并且临时文件堆不能超过三份文件。那么，她可以形成两个临时文件堆，一个从上到下是 $\\#6$、$\\#4$ 和 $\\#3$，另一个是 $\\#5$、$\\#2$ 和 $\\#1$（图 E.1）。两个临时文件堆都是逆序排列的。然后，比较两个临时文件堆顶部的文件序列号，数字较大者（本例中是 $\\#6$）将首先被取出并存放到文件盒中。重复此过程，所有文件将在文件盒中完美排序。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/z58fkr39.png)\n\n图 E.1. 制作两个临时文件堆\n:::\n\nSusan 想知道，对于当前文件堆中的文件，该计划是否实际可行，如果可行，有多少种不同的方式将它们堆叠到两个临时文件堆中。你被要求通过编写一个程序来计算不同方式的数量来帮助 Susan，如果计划不可行，则该数量应为零。\n\n由于文件堆中的每个文件都可以移动到两个临时文件堆中的任意一个，对于 $n$ 份文件，总共有 $2^n$ 种不同的选择组合，但其中一些可能会破坏临时文件堆的逆序，因此是不合适的。\n\n上述示例对应于样例输入的第一个案例。在这种情况下，最后两份文件 $\\#5$ 和 $\\#6$ 可以交换它们的目的堆。此外，完全交换两个临时文件堆的角色也是可行的。由于任何其他移动序列都会使其中一个堆高于三份文件和/或使它们顺序混乱，因此在此示例中，将文件堆叠到临时堆的不同方式总数为 $2 \\times 2 = 4$。", "inputFormat": "输入包含单个测试用例，格式如下。\n\n$$\n\\begin{aligned}\n&n\\ m\\\\\n&s_1 \\dots s_n\\\\\n\\end{aligned}\n$$\n\n其中，$n$ 是文件堆中的文件数量（$1 \\le n \\le 5000$），$m$ 是一个临时文件堆在不冒倒塌风险的情况下可以堆叠的文件数量（$n/2 \\le m \\le n$）。数字 $s_1$ 到 $s_n$ 是文件堆中文件的序列号，从顶部到底部。保证所有数字 $1$ 到 $n$ 都恰好出现一次。", "outputFormat": "输出一行一个整数，表示形成两个适合目标的临时文件堆的方式数量。当然，如果没有可行的选择，方式数量为 $0$。\n\n如果可能的方式数量大于或等于 $10^9 + 7$，则输出方式数量对 $10^9 + 7$ 取模的结果。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14880", "type": "P", "difficulty": 7, "samples": [["2 0\n5 1 2 1 1\n10 1 3 2 2", "9"], ["3 1\n0 1 4 2 3\n1 0 1 1 3\n3 -2 2 1 4", "-1"], ["3 3\n1 -1 2 2 2\n1 1 1 -1 3\n1 1 4 -2 1", "-1"], ["13 3\n15 -10 4 4 2\n19 0 4 4 3\n23 -20 4 4 1\n6 1 2 1 5\n6 17 3 -1 6\n3 2 9 4 7\n7 0 9 4 8\n11 -5 9 4 6\n6 1 7 1 10\n6 5 8 -8 11\n1 2 11 1 12\n6 1 14 2 13\n6 -4 11 1 12", "26"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "ICPC", "横浜"], "title": "[ICPC 2019 Yokohama R] Halting Problem", "background": "", "description": "A unique law is enforced in the Republic of Finite Loop. Under the law, programs that never halt are regarded as viruses. Releasing such a program is a cybercrime. So, you want to make sure that your software products always halt under their normal use.\n\nIt is widely known that there exists no algorithm that can determine whether an arbitrary given program halts or not for a given arbitrary input. Fortunately, your products are based on a simple computation model given below. So, you can write a program that can tell whether a given program based on the model will eventually halt for a given input.\n\nThe computation model for the products has only one variable $x$ and $N + 1$ states, numbered 1 through $N + 1$. The variable $x$ can store any integer value. The state $N + 1$ means that the program has terminated. For each integer $i$ ($1 \\le i \\le N$), the behavior of the program in the state $i$ is described by five integers $a_i$, $b_i$, $c_i$, $d_i$ and $e_i$ ($c_i$ and $e_i$ are indices of states).\n\nOn start of a program, its state is initialized to 1, and the value of $x$ is initialized by $x_0$, the input to the program. When the program is in the state $i$ ($1 \\le i \\le N$), either of the following takes place in one execution step:\n\n- if $x$ is equal to $a_i$, the value of $x$ changes to $x + b_i$ and the program state becomes $c_i$;\n- otherwise, the value of $x$ changes to $x + d_i$ and the program state becomes $e_i$.\n\nThe program terminates when the program state becomes $N + 1$.\n\nYour task is to write a program to determine whether a given program eventually halts or not for a given input, and, if it halts, to compute how many steps are executed. The initialization is not counted as a step.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n&N\\ x_0 \\\\\n&a_1\\ b_1\\ c_1\\ d_1\\ e_1 \\\\\n&\\vdots \\\\\n&a_N\\ b_N\\ c_N\\ d_N\\ e_N\n\\end{aligned}\n$$\n\nThe first line contains two integers $N$ ($1 \\le N \\le 10^5$) and $x_0$ ($-10^{13} \\le x_0 \\le 10^{13}$). The number of the states of the program is $N + 1$. $x_0$ is the initial value of the variable $x$. Each of the next $N$ lines contains five integers $a_i, b_i, c_i, d_i$ and $e_i$ that determine the behavior of the program when it is in the state $i$. $a_i, b_i$ and $d_i$ are integers between $-10^{13}$ and $10^{13}$, inclusive. $c_i$ and $e_i$ are integers between 1 and $N + 1$, inclusive.\n", "outputFormat": "If the given program eventually halts with the given input, output a single integer in a line which is the number of steps executed until the program terminates. Since the number may be very large, output the number modulo $10^9 + 7$.\n\nOutput $-1$ if the program will never halt.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2019 Yokohama R] Halting Problem", "background": "", "description": "A unique law is enforced in the Republic of Finite Loop. Under the law, programs that never halt are regarded as viruses. Releasing such a program is a cybercrime. So, you want to make sure that your software products always halt under their normal use.\n\nIt is widely known that there exists no algorithm that can determine whether an arbitrary given program halts or not for a given arbitrary input. Fortunately, your products are based on a simple computation model given below. So, you can write a program that can tell whether a given program based on the model will eventually halt for a given input.\n\nThe computation model for the products has only one variable $x$ and $N + 1$ states, numbered 1 through $N + 1$. The variable $x$ can store any integer value. The state $N + 1$ means that the program has terminated. For each integer $i$ ($1 \\le i \\le N$), the behavior of the program in the state $i$ is described by five integers $a_i$, $b_i$, $c_i$, $d_i$ and $e_i$ ($c_i$ and $e_i$ are indices of states).\n\nOn start of a program, its state is initialized to 1, and the value of $x$ is initialized by $x_0$, the input to the program. When the program is in the state $i$ ($1 \\le i \\le N$), either of the following takes place in one execution step:\n\n- if $x$ is equal to $a_i$, the value of $x$ changes to $x + b_i$ and the program state becomes $c_i$;\n- otherwise, the value of $x$ changes to $x + d_i$ and the program state becomes $e_i$.\n\nThe program terminates when the program state becomes $N + 1$.\n\nYour task is to write a program to determine whether a given program eventually halts or not for a given input, and, if it halts, to compute how many steps are executed. The initialization is not counted as a step.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n&N\\ x_0 \\\\\n&a_1\\ b_1\\ c_1\\ d_1\\ e_1 \\\\\n&\\vdots \\\\\n&a_N\\ b_N\\ c_N\\ d_N\\ e_N\n\\end{aligned}\n$$\n\nThe first line contains two integers $N$ ($1 \\le N \\le 10^5$) and $x_0$ ($-10^{13} \\le x_0 \\le 10^{13}$). The number of the states of the program is $N + 1$. $x_0$ is the initial value of the variable $x$. Each of the next $N$ lines contains five integers $a_i, b_i, c_i, d_i$ and $e_i$ that determine the behavior of the program when it is in the state $i$. $a_i, b_i$ and $d_i$ are integers between $-10^{13}$ and $10^{13}$, inclusive. $c_i$ and $e_i$ are integers between 1 and $N + 1$, inclusive.\n", "outputFormat": "If the given program eventually halts with the given input, output a single integer in a line which is the number of steps executed until the program terminates. Since the number may be very large, output the number modulo $10^9 + 7$.\n\nOutput $-1$ if the program will never halt.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2019 Yokohama R] Halting Problem", "background": "", "description": "有限循环共和国实施了一项独特的法律。根据该法律，永不停机的程序被视为病毒。发布此类程序属于网络犯罪。因此，你希望确保你的软件产品在正常使用下总是会停机。\n\n众所周知，不存在一种算法能够判断任意给定程序在任意给定输入下是否会停机。幸运的是，你的产品基于下面给出的简单计算模型。因此，你可以编写一个程序来判断基于该模型的给定程序在给定输入下最终是否会停机。\n\n产品的计算模型只有一个变量 $x$ 和 $N + 1$ 个状态，编号从 $1$ 到 $N + 1$。变量 $x$ 可以存储任何整数值。状态 $N + 1$ 表示程序已终止。对于每个整数 $i$ （$1 \\le i \\le N$），程序在状态 $i$ 下的行为由五个整数 $a_i$、$b_i$、$c_i$、$d_i$ 和 $e_i$ 描述（$c_i$ 和 $e_i$ 是状态的索引）。\n\n程序启动时，其状态初始化为 $1$，变量 $x$ 的值初始化为 $x_0$，即程序的输入。当程序处于状态 $i$ （$1 \\le i \\le N$）时，每一步执行会发生以下情况之一：\n\n- 如果 $x$ 等于 $a_i$，则 $x$ 的值变为 $x + b_i$，程序状态变为 $c_i$；\n- 否则，$x$ 的值变为 $x + d_i$，程序状态变为 $e_i$。\n\n当程序状态变为 $N + 1$ 时，程序终止。\n\n你的任务是编写一个程序来判断给定程序在给定输入下最终是否会停机，并且如果停机，计算执行了多少步。初始化不计为一步。", "inputFormat": "输入包含单个测试用例，格式如下。\n\n$$\n\\begin{aligned}\n&N\\ x_0 \\\\\n&a_1\\ b_1\\ c_1\\ d_1\\ e_1 \\\\\n&\\vdots \\\\\n&a_N\\ b_N\\ c_N\\ d_N\\ e_N\n\\end{aligned}\n$$\n\n第一行包含两个整数 $N$ （$1 \\le N \\le 10^5$）和 $x_0$ （$-10^{13} \\le x_0 \\le 10^{13}$）。程序的状态数量为 $N + 1$。$x_0$ 是变量 $x$ 的初始值。接下来的 $N$ 行中，每行包含五个整数 $a_i, b_i, c_i, d_i$ 和 $e_i$，用于确定程序处于状态 $i$ 时的行为。$a_i$、$b_i$ 和 $d_i$ 是介于 $-10^{13}$ 和 $10^{13}$ 之间（含）的整数。$c_i$ 和 $e_i$ 是介于 $1$ 和 $N + 1$ 之间（含）的整数。", "outputFormat": "如果给定程序在给定输入下最终停机，则输出一行一个整数，表示程序终止前执行的步数。由于该数字可能非常大，请输出该数字对 $10^9 + 7$ 取模的结果。\n\n如果程序永不停机，则输出 $-1$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14881", "type": "P", "difficulty": 5, "samples": [["3\n0\n01\n10", "3"], ["3\n00\n01\n1", "0"], ["3\n00\n10\n1", "0"], ["10\n1001\n1011\n01000\n00011\n01011\n1010\n00100\n10011\n11110\n0110", "13"], ["3\n1101\n1\n10", "4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "ICPC", "横浜"], "title": "[ICPC 2019 Yokohama R] Ambiguous Encoding", "background": "", "description": "A friend of yours is designing an encoding scheme of a set of characters into a set of variable length bit sequences. You are asked to check whether the encoding is ambiguous or not. In an encoding scheme, characters are given distinct bit sequences of possibly different lengths as their codes. A character sequence is encoded into a bit sequence which is the concatenation of the codes of the characters in the string in the order of their appearances. An encoding scheme is said to be ambiguous if there exist two different character sequences encoded into exactly the same bit sequence. Such a bit sequence is called an “ambiguous binary sequence”.\n\nFor example, encoding characters “A”, “B”, and “C” to 0, 01 and 10, respectively, is ambiguous. This scheme encodes two different character strings “AC” and “BA” into the same bit sequence 010.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$n$$\n\n$$w_1$$\n\n$$\\vdots$$\n\n$$w_n$$\n\nHere, $n$ is the size of the set of characters to encode ($1 \\le n \\le 1000$). The $i$-th line of the following $n$ lines, $w_i$, gives the bit sequence for the $i$-th character as a non-empty sequence of at most 16 binary digits, 0 or 1. Note that different characters are given different codes, that is, $w_i \\ne w_j$ for $i \\ne j$.\n", "outputFormat": "If the given encoding is ambiguous, print in a line the number of bits in the shortest ambiguous binary sequence. Output zero, otherwise.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2019 Yokohama R] Ambiguous Encoding", "background": "", "description": "A friend of yours is designing an encoding scheme of a set of characters into a set of variable length bit sequences. You are asked to check whether the encoding is ambiguous or not. In an encoding scheme, characters are given distinct bit sequences of possibly different lengths as their codes. A character sequence is encoded into a bit sequence which is the concatenation of the codes of the characters in the string in the order of their appearances. An encoding scheme is said to be ambiguous if there exist two different character sequences encoded into exactly the same bit sequence. Such a bit sequence is called an “ambiguous binary sequence”.\n\nFor example, encoding characters “A”, “B”, and “C” to 0, 01 and 10, respectively, is ambiguous. This scheme encodes two different character strings “AC” and “BA” into the same bit sequence 010.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$n$$\n\n$$w_1$$\n\n$$\\vdots$$\n\n$$w_n$$\n\nHere, $n$ is the size of the set of characters to encode ($1 \\le n \\le 1000$). The $i$-th line of the following $n$ lines, $w_i$, gives the bit sequence for the $i$-th character as a non-empty sequence of at most 16 binary digits, 0 or 1. Note that different characters are given different codes, that is, $w_i \\ne w_j$ for $i \\ne j$.\n", "outputFormat": "If the given encoding is ambiguous, print in a line the number of bits in the shortest ambiguous binary sequence. Output zero, otherwise.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2019 Yokohama R] Ambiguous Encoding", "background": "", "description": "你的一位朋友正在设计一个字符集到一组变长比特序列的编码方案。你被要求检查该编码是否具有歧义。在一个编码方案中，每个字符被赋予一个可能长度不同的唯一比特序列作为其编码。一个字符序列被编码为一个比特序列，该序列是字符串中字符的编码按其出现顺序拼接而成。如果一个编码方案存在两个不同的字符序列被编码为完全相同的比特序列，则称该编码方案具有歧义。这样的比特序列被称为“歧义二进制序列”。\n\n例如，将字符 “A”、“B” 和 “C” 分别编码为 0、01 和 10 是具有歧义的。该方案将两个不同的字符串 “AC” 和 “BA” 编码为相同的比特序列 010。", "inputFormat": "输入包含单个测试用例，格式如下。\n\n$$n$$\n\n$$w_1$$\n\n$$\\vdots$$\n\n$$w_n$$\n\n其中，$n$ 是要编码的字符集大小（$1 \\le n \\le 1000$）。接下来的 $n$ 行中，第 $i$ 行的 $w_i$ 给出了第 $i$ 个字符的比特序列，是一个非空的、长度不超过 $16$ 的二进制数字序列（由 0 或 1 组成）。注意，不同的字符被赋予不同的编码，即对于 $i \\ne j$，有 $w_i \\ne w_j$。", "outputFormat": "如果给定的编码具有歧义，则在一行中输出最短歧义二进制序列的比特数。否则，输出 $0$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14882", "type": "P", "difficulty": 4, "samples": [["(()())---)", "0\n0\n1\n1\n3\n4\n3\n1\n1\n2"], ["()--()()----)(()()))", "0\n1\n0\n0\n0\n1\n1\n3\n1\n1\n0\n0\n0\n0\n0\n1\n1\n3\n4\n4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["模拟", "2019", "栈", "ICPC", "横浜"], "title": "[ICPC 2019 Yokohama R] Parentheses Editor", "background": "", "description": "You are working with a strange text editor for texts consisting only of open and close parentheses. The editor accepts the following three keys as editing commands to modify the text kept in it.\n\n- `(` appends an open parenthesis `(` to the end of the text.\n- `)` appends a close parenthesis `)` to the end of the text.\n- `-` removes the last character of the text.\n\nA balanced string is one of the following.\n\n- `()`\n- `(X)` where $X$ is a balanced string\n- `XY` where both $X$ and $Y$ are balanced strings\n\nInitially, the editor keeps an empty text. You are interested in the number of balanced substrings in the text kept in the editor after each of your key command inputs. Note that, for the same balanced substring occurring twice or more, their occurrences should be counted separately. Also note that, when some balanced substrings are inside a balanced substring, both the inner and outer balanced substrings should be counted.\n", "inputFormat": "The input consists of a single test case given in a line containing a number of characters, each of which is a command key to the editor, that is, either `(`, `)`, or `-`. The number of characters does not exceed $200000$. They represent a key input sequence to the editor.\n\nIt is guaranteed that no `-` command comes when the text is empty.", "outputFormat": "Print the numbers of balanced substrings in the text kept in the editor after each of the key command inputs are applied, each in one line. Thus, the number of output lines should be the same as the number of characters in the input line.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2019 Yokohama R] Parentheses Editor", "background": "", "description": "You are working with a strange text editor for texts consisting only of open and close parentheses. The editor accepts the following three keys as editing commands to modify the text kept in it.\n\n- `(` appends an open parenthesis `(` to the end of the text.\n- `)` appends a close parenthesis `)` to the end of the text.\n- `-` removes the last character of the text.\n\nA balanced string is one of the following.\n\n- `()`\n- `(X)` where $X$ is a balanced string\n- `XY` where both $X$ and $Y$ are balanced strings\n\nInitially, the editor keeps an empty text. You are interested in the number of balanced substrings in the text kept in the editor after each of your key command inputs. Note that, for the same balanced substring occurring twice or more, their occurrences should be counted separately. Also note that, when some balanced substrings are inside a balanced substring, both the inner and outer balanced substrings should be counted.\n", "inputFormat": "The input consists of a single test case given in a line containing a number of characters, each of which is a command key to the editor, that is, either `(`, `)`, or `-`. The number of characters does not exceed $200000$. They represent a key input sequence to the editor.\n\nIt is guaranteed that no `-` command comes when the text is empty.", "outputFormat": "Print the numbers of balanced substrings in the text kept in the editor after each of the key command inputs are applied, each in one line. Thus, the number of output lines should be the same as the number of characters in the input line.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2019 Yokohama R] Parentheses Editor", "background": "", "description": "你正在使用一个奇怪的文本编辑器，该编辑器仅处理由开括号和闭括号组成的文本。编辑器接受以下三个键作为编辑命令来修改其中保存的文本。\n\n- `(` 将一个开括号 `(` 追加到文本末尾。\n- `)` 将一个闭括号 `)` 追加到文本末尾。\n- `-` 删除文本的最后一个字符。\n\n一个**平衡字符串**是以下之一。\n\n- `()`\n- `(X)`，其中 $X$ 是一个平衡字符串\n- `XY`，其中 $X$ 和 $Y$ 都是平衡字符串\n\n最初，编辑器保存一个空文本。你关心的是，在你的每个按键命令输入后，编辑器保存的文本中平衡子串的数量。请注意，对于出现两次或多次的相同平衡子串，它们的出现应分别计数。另外请注意，当一些平衡子串位于另一个平衡子串内部时，内部和外部的平衡子串都应被计数。", "inputFormat": "输入包含单行的一个测试用例，该行包含若干个字符，每个字符都是编辑器的命令键，即 `(`、`)` 或 `-` 中的一个。字符数量不超过 $200000$。它们表示输入到编辑器的一个按键序列。\n\n保证在文本为空时不会有 `-` 命令。", "outputFormat": "在每个按键命令输入被应用后，输出编辑器保存的文本中平衡子串的数量，每个结果占一行。因此，输出行数应与输入行中的字符数相同。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14883", "type": "P", "difficulty": 6, "samples": [["3 2\n1 2\n2 3\n3\n1 2\n1 3\n2 3", "Yes\n1 2\n2 3"], ["3 2\n1 2\n2 3\n3\n1 2\n1 3\n3 2", "No"], ["4 4\n1 2\n1 3\n1 4\n2 3\n7\n1 2\n1 3\n1 4\n2 1\n2 3\n3 1\n3 2", "Yes\n1 2\n2 3\n3 1\n1 4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "Special Judge", "ICPC", "横浜"], "title": "[ICPC 2019 Yokohama R] One-Way Conveyors", "background": "", "description": "You are working at a factory manufacturing many different products. Products have to be processed on a number of different machine tools. Machine shops with these machines are connected with conveyor lines to exchange unfinished products. Each unfinished product is transferred from a machine shop to another through one or more of these conveyors.\n\nAs the orders of the processes required are not the same for different types of products, the conveyor lines are currently operated in two-way. This may induce inefficiency as conveyors have to be completely emptied before switching their directions. **Kaizen** (efficiency improvements) may be found here!\n\nAdding more conveyors is too costly. If all the required transfers are possible with currently installed conveyors operating in fixed directions, no additional costs are required. All the required transfers, from which machine shop to which, are listed at hand. You want to know whether all the required transfers can be enabled with all the conveyors operated in one-way, and if yes, directions of the conveyor lines enabling it.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n&n \\ m \\\\\n&x_1 \\ y_1 \\\\\n&\\vdots \\\\\n&x_m \\ y_m \\\\\n&k \\\\\n&a_1 \\ b_1 \\\\\n&\\vdots \\\\\n&a_k \\ b_k\n\\end{aligned}\n$$\n\nThe first line contains two integers $n$ ($2 \\le n \\le 10000$) and $m$ ($1 \\le m \\le 100000$), the number of machine shops and the number of conveyors, respectively. Machine shops are numbered 1 through $n$. Each of the following $m$ lines contains two integers $x_i$ and $y_i$ ($1 \\le x_i < y_i \\le n$), meaning that the $i$-th conveyor connects machine shops $x_i$ and $y_i$. At most one conveyor is installed between any two machine shops. It is guaranteed that any two machine shops are connected through one or more conveyors. The next line contains an integer $k$ ($1 \\le k \\le 100000$), which indicates the number of required transfers from a machine shop to another. Each of the following $k$ lines contains two integers $a_i$ and $b_i$ ($1 \\le a_i \\le n$, $1 \\le b_i \\le n$, $a_i \\ne b_i$), meaning that transfer from the machine shop $a_i$ to the machine shop $b_i$ is required. Either $a_i \\ne a_j$ or $b_i \\ne b_j$ holds for $i \\ne j$.", "outputFormat": "Output “No” if it is impossible to enable all the required transfers when all the conveyors are operated in one-way. Otherwise, output “Yes” in a line first, followed by $m$ lines each of which describes the directions of the conveyors. All the required transfers should be possible with the conveyor lines operated in these directions. Each direction should be described as a pair of the machine shop numbers separated by a space, with the start shop number on the left and the end shop number on the right. The order of these $m$ lines do not matter as far as all the conveyors are specified without duplicates or omissions. If there are multiple feasible direction assignments, whichever is fine.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2019 Yokohama R] One-Way Conveyors", "background": "", "description": "You are working at a factory manufacturing many different products. Products have to be processed on a number of different machine tools. Machine shops with these machines are connected with conveyor lines to exchange unfinished products. Each unfinished product is transferred from a machine shop to another through one or more of these conveyors.\n\nAs the orders of the processes required are not the same for different types of products, the conveyor lines are currently operated in two-way. This may induce inefficiency as conveyors have to be completely emptied before switching their directions. **Kaizen** (efficiency improvements) may be found here!\n\nAdding more conveyors is too costly. If all the required transfers are possible with currently installed conveyors operating in fixed directions, no additional costs are required. All the required transfers, from which machine shop to which, are listed at hand. You want to know whether all the required transfers can be enabled with all the conveyors operated in one-way, and if yes, directions of the conveyor lines enabling it.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n&n \\ m \\\\\n&x_1 \\ y_1 \\\\\n&\\vdots \\\\\n&x_m \\ y_m \\\\\n&k \\\\\n&a_1 \\ b_1 \\\\\n&\\vdots \\\\\n&a_k \\ b_k\n\\end{aligned}\n$$\n\nThe first line contains two integers $n$ ($2 \\le n \\le 10000$) and $m$ ($1 \\le m \\le 100000$), the number of machine shops and the number of conveyors, respectively. Machine shops are numbered 1 through $n$. Each of the following $m$ lines contains two integers $x_i$ and $y_i$ ($1 \\le x_i < y_i \\le n$), meaning that the $i$-th conveyor connects machine shops $x_i$ and $y_i$. At most one conveyor is installed between any two machine shops. It is guaranteed that any two machine shops are connected through one or more conveyors. The next line contains an integer $k$ ($1 \\le k \\le 100000$), which indicates the number of required transfers from a machine shop to another. Each of the following $k$ lines contains two integers $a_i$ and $b_i$ ($1 \\le a_i \\le n$, $1 \\le b_i \\le n$, $a_i \\ne b_i$), meaning that transfer from the machine shop $a_i$ to the machine shop $b_i$ is required. Either $a_i \\ne a_j$ or $b_i \\ne b_j$ holds for $i \\ne j$.", "outputFormat": "Output “No” if it is impossible to enable all the required transfers when all the conveyors are operated in one-way. Otherwise, output “Yes” in a line first, followed by $m$ lines each of which describes the directions of the conveyors. All the required transfers should be possible with the conveyor lines operated in these directions. Each direction should be described as a pair of the machine shop numbers separated by a space, with the start shop number on the left and the end shop number on the right. The order of these $m$ lines do not matter as far as all the conveyors are specified without duplicates or omissions. If there are multiple feasible direction assignments, whichever is fine.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2019 Yokohama R] One-Way Conveyors", "background": "", "description": "你在一家生产许多不同产品的工厂工作。产品需要在若干不同的机床上进行加工。这些机床所在的车间通过传送带连接，以交换未完成的产品。每个未完成的产品通过一条或多条这样的传送带从一个车间转移到另一个车间。\n\n由于不同类型的产品所需的加工顺序不同，目前传送带是双向运行的。这可能导致效率低下，因为传送带在切换方向前必须完全清空。这里可能存在**改善**（效率提升）的空间！\n\n增加更多传送带的成本太高。如果所有必需的转移都能在当前安装的传送带以固定方向运行时实现，则不需要额外成本。所有必需的转移（从哪个车间到哪个车间）都已列出在手。你想知道是否所有必需的转移都能在所有传送带单向运行时实现，如果可以，请给出实现该目标的传送带方向。", "inputFormat": "输入包含单个测试用例，格式如下。\n\n$$\n\\begin{aligned}\n&n \\ m \\\\\n&x_1 \\ y_1 \\\\\n&\\vdots \\\\\n&x_m \\ y_m \\\\\n&k \\\\\n&a_1 \\ b_1 \\\\\n&\\vdots \\\\\n&a_k \\ b_k\n\\end{aligned}\n$$\n\n第一行包含两个整数 $n$ （$2 \\le n \\le 10000$）和 $m$ （$1 \\le m \\le 100000$），分别表示车间的数量和传送带的数量。车间编号为 $1$ 到 $n$。接下来的 $m$ 行中，每行包含两个整数 $x_i$ 和 $y_i$ （$1 \\le x_i < y_i \\le n$），表示第 $i$ 条传送带连接车间 $x_i$ 和 $y_i$。任意两个车间之间最多安装一条传送带。保证任意两个车间通过一条或多条传送带相连。下一行包含一个整数 $k$ （$1 \\le k \\le 100000$），表示从一个车间到另一个车间所需的转移数量。接下来的 $k$ 行中，每行包含两个整数 $a_i$ 和 $b_i$ （$1 \\le a_i \\le n$，$1 \\le b_i \\le n$，$a_i \\ne b_i$），表示需要从车间 $a_i$ 到车间 $b_i$ 的转移。对于 $i \\ne j$，满足 $a_i \\ne a_j$ 或 $b_i \\ne b_j$。", "outputFormat": "如果当所有传送带单向运行时，不可能实现所有必需的转移，则输出 “No”。否则，先在一行输出 “Yes”，随后是 $m$ 行，每行描述一条传送带的方向。所有必需的转移必须能在传送带按这些方向运行时实现。每条方向应描述为两个车间编号，中间用一个空格分隔，起点车间编号在左，终点车间编号在右。只要所有传送带都被指定且没有重复或遗漏，这 $m$ 行的顺序无关紧要。如果有多个可行的方向分配方案，输出任意一个均可。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14884", "type": "P", "difficulty": 7, "samples": [["4\n10 0\n20 10\n10 30\n0 10", "300.00"], ["10\n145 269\n299 271\n343 193\n183 139\n408 181\n356 324\n176 327\n147 404\n334 434\n102 424", "12658.3130191"], ["6\n144 401\n297 322\n114 282\n372 178\n197 271\n368 305", "0.0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "Special Judge", "ICPC", "横浜"], "title": "[ICPC 2019 Yokohama R] Fun Region", "background": "", "description": "Dr. Ciel lives in a planar island with a polygonal coastline. She loves strolling on the island along spiral paths. Here, a path is called *spiral* if both of the following are satisfied.\n\n- The path is a simple planar polyline with no self-intersections.\n- At all of its vertices, the line segment directions turn clockwise.\n\nFour paths are depicted below. Circle markers represent the departure points, and arrow heads represent the destinations of paths. Among the paths, only the leftmost is spiral.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/dnxj7lkv.png)\n:::\n\nDr. Ciel finds a point *fun* if, for all of the vertices of the island’s coastline, there exists a spiral path that starts from the point, ends at the vertex, and does not cross the coastline. Here, the spiral path may touch or overlap the coastline.\n\nIn the following figure, the outer polygon represents a coastline. The point $\\star$ is fun, while the point $\\times$ is not fun. Dotted polylines starting from $\\star$ are valid spiral paths that end at coastline vertices.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/3428zay4.png)\n:::\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/i3j775ri.png)\n:::\n\nWe can prove that the set of all the fun points forms a (possibly empty) connected region, which we call the *fun region*. Given the coastline, your task is to write a program that computes the area size of the fun region.\n\nFigure J.1 visualizes the three samples given below. The outer polygons correspond to the island’s coastlines. The fun regions are shown as the gray areas.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n&n \\\\\n&x_1 \\ y_1 \\\\\n&\\vdots \\\\\n&x_n \\ y_n\n\\end{aligned}\n$$\n\n$n$ is the number of vertices of the polygon that represents the coastline ($3 \\le n \\le 2000$). Each of the following $n$ lines has two integers $x_i$ and $y_i$, which give the coordinates $(x_i, y_i)$ of the $i$-th vertex of the polygon, in counterclockwise order. $x_i$ and $y_i$ are between 0 and 10000, inclusive. Here, the $x$-axis of the coordinate system directs right and the $y$-axis directs up. The polygon is simple, that is, it does not intersect nor touch itself. Note that the polygon may be non-convex. It is guaranteed that the inner angle of each vertex is not exactly 180 degrees.", "outputFormat": "Output the area of the fun region in one line. Absolute or relative errors less than $10^{-7}$ are permissible.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2019 Yokohama R] Fun Region", "background": "", "description": "Dr. Ciel lives in a planar island with a polygonal coastline. She loves strolling on the island along spiral paths. Here, a path is called *spiral* if both of the following are satisfied.\n\n- The path is a simple planar polyline with no self-intersections.\n- At all of its vertices, the line segment directions turn clockwise.\n\nFour paths are depicted below. Circle markers represent the departure points, and arrow heads represent the destinations of paths. Among the paths, only the leftmost is spiral.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/dnxj7lkv.png)\n:::\n\nDr. Ciel finds a point *fun* if, for all of the vertices of the island’s coastline, there exists a spiral path that starts from the point, ends at the vertex, and does not cross the coastline. Here, the spiral path may touch or overlap the coastline.\n\nIn the following figure, the outer polygon represents a coastline. The point $\\star$ is fun, while the point $\\times$ is not fun. Dotted polylines starting from $\\star$ are valid spiral paths that end at coastline vertices.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/3428zay4.png)\n:::\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/i3j775ri.png)\n:::\n\nWe can prove that the set of all the fun points forms a (possibly empty) connected region, which we call the *fun region*. Given the coastline, your task is to write a program that computes the area size of the fun region.\n\nFigure J.1 visualizes the three samples given below. The outer polygons correspond to the island’s coastlines. The fun regions are shown as the gray areas.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n&n \\\\\n&x_1 \\ y_1 \\\\\n&\\vdots \\\\\n&x_n \\ y_n\n\\end{aligned}\n$$\n\n$n$ is the number of vertices of the polygon that represents the coastline ($3 \\le n \\le 2000$). Each of the following $n$ lines has two integers $x_i$ and $y_i$, which give the coordinates $(x_i, y_i)$ of the $i$-th vertex of the polygon, in counterclockwise order. $x_i$ and $y_i$ are between 0 and 10000, inclusive. Here, the $x$-axis of the coordinate system directs right and the $y$-axis directs up. The polygon is simple, that is, it does not intersect nor touch itself. Note that the polygon may be non-convex. It is guaranteed that the inner angle of each vertex is not exactly 180 degrees.", "outputFormat": "Output the area of the fun region in one line. Absolute or relative errors less than $10^{-7}$ are permissible.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2019 Yokohama R] Fun Region", "background": "", "description": "Ciel 博士居住在一个海岸线为多边形的平面岛屿上。她喜欢沿着螺旋路径在岛上散步。这里，一条路径被称为**螺旋**路径，如果它满足以下两个条件。\n\n- 该路径是一条简单的平面折线，没有自相交。\n- 在其所有顶点处，线段方向均为顺时针转向。\n\n下图描绘了四条路径。圆圈标记表示起点，箭头表示路径的终点。在这些路径中，只有最左边的是螺旋路径。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/dnxj7lkv.png)\n:::\n\nCiel 博士认为一个点具有**乐趣**，如果对于岛屿海岸线的所有顶点，都存在一条螺旋路径从该点出发，到达该顶点，且不穿越海岸线。这里，螺旋路径可以接触或重叠于海岸线。\n\n在下图中，外多边形代表海岸线。点 $\\star$ 具有乐趣，而点 $\\times$ 不具有乐趣。从 $\\star$ 出发的虚线折线是有效的螺旋路径，终点为海岸线顶点。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/3428zay4.png)\n:::\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/i3j775ri.png)\n:::\n\n我们可以证明，所有具有乐趣的点构成一个（可能为空的）连通区域，我们称之为**乐趣区域**。给定海岸线，你的任务是编写一个程序来计算乐趣区域的面积大小。\n\n图 J.1 可视化了下文给出的三个样例。外多边形对应于岛屿的海岸线。乐趣区域显示为灰色区域。", "inputFormat": "输入包含单个测试用例，格式如下。\n\n$$\n\\begin{aligned}\n&n \\\\\n&x_1 \\ y_1 \\\\\n&\\vdots \\\\\n&x_n \\ y_n\n\\end{aligned}\n$$\n\n$n$ 是表示海岸线的多边形的顶点数（$3 \\le n \\le 2000$）。接下来的 $n$ 行中，每行有两个整数 $x_i$ 和 $y_i$，它们给出了多边形第 $i$ 个顶点的坐标 $(x_i, y_i)$，按逆时针顺序排列。$x_i$ 和 $y_i$ 介于 $0$ 到 $10000$ 之间（含）。这里，坐标系的 $x$ 轴指向右，$y$ 轴指向上。多边形是简单的，即它不自交也不自触。注意，多边形可能是非凸的。保证每个顶点的内角不等于 $180$ 度。\n", "outputFormat": "在一行中输出乐趣区域的面积。允许的绝对误差或相对误差小于 $10^{-7}$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14885", "type": "P", "difficulty": 7, "samples": [["3 3 1 2 3\n.#.\n###\n.#.", "10"], ["2 7 0 1 1\n###.###\n###.###", "3"], ["5 5 1 4 4\n..#..\n..#..\n##.##\n..#..\n..#..", "24"], ["7 24 1 10 10\n###...###..#####....###.\n.#...#...#.#....#..#...#\n.#..#......#....#.#.....\n.#..#......#####..#.....\n.#..#......#......#.....\n.#...#...#.#.......#...#\n###...###..#........###.", "256"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "网络流", "ICPC", "横浜"], "title": "[ICPC 2019 Yokohama R] Draw in Straight Lines", "background": "", "description": "You plan to draw a black-and-white painting on a rectangular canvas. The painting will be a grid array of pixels, either black or white. You can paint black or white lines or dots on the initially white canvas.\n\nYou can apply a sequence of the following two operations in any order.\n\n- Painting pixels on a horizontal or vertical line segment, single pixel wide and two or more pixel long, either black or white. This operation has a cost proportional to the length (the number of pixels) of the line segment multiplied by a specified coefficient in addition to a specified constant cost.\n- Painting a single pixel, either black or white. This operation has a specified constant cost.\n\nYou can overpaint already painted pixels as long as the following conditions are satisfied.\n\n- The pixel has been painted at most once before. Overpainting a pixel too many times results in too thick layers of inks, making the picture look ugly. Note that painting a pixel with the same color is also counted as overpainting. For instance, if you have painted a pixel with black twice, you can paint it neither black nor white anymore.\n- The pixel once painted white should not be overpainted with the black ink. As the white ink takes very long to dry, overpainting the same pixel black would make the pixel gray, rather than black. The reverse, that is, painting white over a pixel already painted black, has no problem.\n\nYour task is to compute the minimum total cost to draw the specified image.", "inputFormat": "The input consists of a single test case. The first line contains five integers $n$, $m$, $a$, $b$, and $c$, where $n$ ($1 \\le n \\le 40$) and $m$ ($1 \\le m \\le 40$) are the height and the width of the canvas in the number of pixels, and $a$ ($0 \\le a \\le 40$), $b$ ($0 \\le b \\le 40$), and $c$ ($0 \\le c \\le 40$) are constants defining painting costs as follows. Painting a line segment of length $\\ell$ costs $a\\ell + b$ and painting a single pixel costs $c$. These three constants satisfy $c \\le a + b$.\n\nThe next $n$ lines show the black-and-white image you want to draw. Each of the lines contains a string of length $m$. The $j$-th character of the $i$-th string is `#` if the color of the pixel in the $i$-th row and the $j$-th column is to be black, and it is `.` if the color is to be white.\n", "outputFormat": "Output the minimum cost.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2019 Yokohama R] Draw in Straight Lines", "background": "", "description": "You plan to draw a black-and-white painting on a rectangular canvas. The painting will be a grid array of pixels, either black or white. You can paint black or white lines or dots on the initially white canvas.\n\nYou can apply a sequence of the following two operations in any order.\n\n- Painting pixels on a horizontal or vertical line segment, single pixel wide and two or more pixel long, either black or white. This operation has a cost proportional to the length (the number of pixels) of the line segment multiplied by a specified coefficient in addition to a specified constant cost.\n- Painting a single pixel, either black or white. This operation has a specified constant cost.\n\nYou can overpaint already painted pixels as long as the following conditions are satisfied.\n\n- The pixel has been painted at most once before. Overpainting a pixel too many times results in too thick layers of inks, making the picture look ugly. Note that painting a pixel with the same color is also counted as overpainting. For instance, if you have painted a pixel with black twice, you can paint it neither black nor white anymore.\n- The pixel once painted white should not be overpainted with the black ink. As the white ink takes very long to dry, overpainting the same pixel black would make the pixel gray, rather than black. The reverse, that is, painting white over a pixel already painted black, has no problem.\n\nYour task is to compute the minimum total cost to draw the specified image.", "inputFormat": "The input consists of a single test case. The first line contains five integers $n$, $m$, $a$, $b$, and $c$, where $n$ ($1 \\le n \\le 40$) and $m$ ($1 \\le m \\le 40$) are the height and the width of the canvas in the number of pixels, and $a$ ($0 \\le a \\le 40$), $b$ ($0 \\le b \\le 40$), and $c$ ($0 \\le c \\le 40$) are constants defining painting costs as follows. Painting a line segment of length $\\ell$ costs $a\\ell + b$ and painting a single pixel costs $c$. These three constants satisfy $c \\le a + b$.\n\nThe next $n$ lines show the black-and-white image you want to draw. Each of the lines contains a string of length $m$. The $j$-th character of the $i$-th string is `#` if the color of the pixel in the $i$-th row and the $j$-th column is to be black, and it is `.` if the color is to be white.\n", "outputFormat": "Output the minimum cost.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2019 Yokohama R] Draw in Straight Lines", "background": "", "description": "你计划在一块矩形画布上绘制一幅黑白画。这幅画将是一个由黑色或白色像素组成的网格阵列。你可以在初始为白色的画布上绘制黑色或白色的线条或点。\n\n你可以按任意顺序应用以下两种操作的序列。\n\n- 在水平或垂直的线段上绘制像素，线段宽度为单个像素，长度大于等于两个像素，可以是黑色或白色。此操作的成本与线段长度（像素数）乘以指定的系数成正比，再加上指定的固定成本。\n- 绘制单个像素，可以是黑色或白色。此操作具有指定的固定成本。\n\n只要满足以下条件，你可以覆盖绘制已绘制过的像素。\n\n- 该像素之前最多被绘制过一次。覆盖绘制像素太多次会导致墨水层过厚，使画面看起来不美观。请注意，用相同颜色绘制像素也算作覆盖绘制。例如，如果你用黑色绘制了一个像素两次，那么你不能再将其绘制为黑色或白色。\n- 一旦被绘制为白色的像素不应被黑色墨水覆盖绘制。因为白色墨水需要很长时间才能干透，覆盖绘制黑色会使像素变成灰色，而不是黑色。反之，即在已绘制为黑色的像素上绘制白色，则没有问题。\n\n你的任务是计算绘制指定图像的最小总成本。", "inputFormat": "输入包含单个测试用例。第一行包含五个整数 $n$、$m$、$a$、$b$ 和 $c$，其中 $n$ （$1 \\le n \\le 40$）和 $m$ （$1 \\le m \\le 40$）分别是画布的高度和宽度（以像素数计），$a$ （$0 \\le a \\le 40$）、$b$ （$0 \\le b \\le 40$）和 $c$ （$0 \\le c \\le 40$）是定义绘制成本的常数，如下所述。绘制长度为 $\\ell$ 的线段成本为 $a\\ell + b$，绘制单个像素的成本为 $c$。这三个常数满足 $c \\le a + b$。\n\n接下来的 $n$ 行显示你想要绘制的黑白图像。每行包含一个长度为 $m$ 的字符串。第 $i$ 行字符串的第 $j$ 个字符如果是 `#`，则表示第 $i$ 行第 $j$ 列的像素颜色应为黑色；如果是 `.`，则表示颜色应为白色。", "outputFormat": "输出最小成本。", "hint": "", "locale": "zh-CN"}}}
