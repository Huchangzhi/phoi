{"pid": "P3451", "type": "P", "difficulty": 6, "samples": [["8 15 4\n1 2 3\n1 3 4\n1 4 4\n1 6 2\n1 7 3\n2 3 6\n2 4 2\n2 5 2\n3 4 3\n3 6 3\n3 8 6\n4 5 2\n4 8 6\n5 7 4\n5 8 6\n3\n2 3\n3 4\n3 5", "19"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2007", "POI（波兰）", "O2优化", "最短路", "状压 DP"], "title": "[POI 2007] ATR-Tourist Attractions", "background": "[English Edition](/paste/gu4ksinh)", "description": "给出一张有 $n$ 个点 $m$ 条边的无向图，每条边有边权。  \n\n你需要找一条从 $1$ 到 $n$ 的最短路径，并且这条路径在满足给出的 $g$ 个限制的情况下可以在所有编号从 $2$ 到 $k+1$ 的点上停留过。\n\n每个限制条件形如 $r_i, s_i$，表示停留在 $s_i$ 之前必须先在 $r_i$ 停留过。\n\n**注意，这里的停留不是指经过**。", "inputFormat": "第一行三个整数 $n,m,k$。\n\n之后 $m$ 行，每行三个整数 $p_i, q_i, l_i$，表示在 $p_i$ 和 $q_i$ 之间有一条权为 $l_i$ 的边。\n\n之后一行一个整数 $g$。\n\n之后 $g$ 行，每行两个整数 $r_i, s_i$，表示一个限制条件。", "outputFormat": "输出一行一个整数，表示最短路径的长度。", "hint": "对于 $100\\%$ 的数据， 满足：\n- $2\\le n\\le2\\times10^4$\n- $1\\le m\\le2\\times10^5$\n- $0\\le k\\le\\min(20, n-2)$\n- $1\\le p_i<q_i\\le n$\n- $1\\le l_i\\le 10^3$\n- $r_i, s_i \\in [2,k+1], r_i\\not=s_i$\n- $0\\le g\\le \\frac{k\\cdot (k-1)}{2}$.  \n- 保证不存在重边且一定有解。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2007] ATR-Tourist Attractions", "background": "[English Edition](/paste/gu4ksinh)", "description": "You are given an undirected graph with $n$ vertices and $m$ edges, where each edge has a weight.\n\nYou need to find a shortest path from $1$ to $n$ that, while satisfying the given $g$ constraints, can stop at every vertex numbered from $2$ to $k+1$.\n\nEach constraint is of the form $r_i, s_i$, meaning that you must have stopped at $r_i$ before stopping at $s_i$.\n\nNote that “stop” here does not mean merely passing through.", "inputFormat": "The first line contains three integers $n, m, k$.\n\nEach of the next $m$ lines contains three integers $p_i, q_i, l_i$, meaning there is an edge of weight $l_i$ between $p_i$ and $q_i$.\n\nThe next line contains an integer $g$.\n\nEach of the next $g$ lines contains two integers $r_i, s_i$, representing one constraint.", "outputFormat": "Output a single integer on one line — the length of the shortest path.", "hint": "Constraints:\n- For $100\\%$ of the testdata, the following hold:\n- $2 \\le n \\le 2 \\times 10^4$.\n- $1 \\le m \\le 2 \\times 10^5$.\n- $0 \\le k \\le \\min(20, n-2)$.\n- $1 \\le p_i < q_i \\le n$.\n- $1 \\le l_i \\le 10^3$.\n- $r_i, s_i \\in [2, k+1],\\ r_i \\ne s_i$.\n- There are no multiple edges, and a solution always exists.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2007] ATR-Tourist Attractions", "background": "[English Edition](/paste/gu4ksinh)", "description": "给出一张有 $n$ 个点 $m$ 条边的无向图，每条边有边权。  \n\n你需要找一条从 $1$ 到 $n$ 的最短路径，并且这条路径在满足给出的 $g$ 个限制的情况下可以在所有编号从 $2$ 到 $k+1$ 的点上停留过。\n\n每个限制条件形如 $r_i, s_i$，表示停留在 $s_i$ 之前必须先在 $r_i$ 停留过。\n\n**注意，这里的停留不是指经过**。", "inputFormat": "第一行三个整数 $n,m,k$。\n\n之后 $m$ 行，每行三个整数 $p_i, q_i, l_i$，表示在 $p_i$ 和 $q_i$ 之间有一条权为 $l_i$ 的边。\n\n之后一行一个整数 $g$。\n\n之后 $g$ 行，每行两个整数 $r_i, s_i$，表示一个限制条件。", "outputFormat": "输出一行一个整数，表示最短路径的长度。", "hint": "对于 $100\\%$ 的数据， 满足：\n- $2\\le n\\le2\\times10^4$\n- $1\\le m\\le2\\times10^5$\n- $0\\le k\\le\\min(20, n-2)$\n- $1\\le p_i<q_i\\le n$\n- $1\\le l_i\\le 10^3$\n- $r_i, s_i \\in [2,k+1], r_i\\not=s_i$\n- $0\\le g\\le \\frac{k\\cdot (k-1)}{2}$.  \n- 保证不存在重边且一定有解。", "locale": "zh-CN"}}}
{"pid": "P3452", "type": "P", "difficulty": 5, "samples": [["7 16\n1 3\n1 4\n1 5\n2 3\n3 4\n4 5\n4 7\n4 6\n5 6\n6 7\n2 4\n2 7\n2 5\n3 5\n3 7\n1 7", "3\n1 2 4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "线性数据结构", "POI（波兰）", "深度优先搜索 DFS"], "title": "[POI 2007] BIU-Offices", "background": "", "description": "Bytel is a mobile telephony potentate. Each employee has been issued a company phone, the memory ofwhich holds the numbers of some of his co-workers (all of them have his number in their phones as well).\n\nDue to dynamic growth of their operations the board of directors intends to move company headquaters tonew office buildings. It has been decided - in order to boost work efficiency - that every pair of employeesworking in different buildings should know (reciprocally) each others phone number i.e. the memory of theircompany phone ought to hold necessary phone numbers.\n\nSimultaneously, the board have decided to rent as many office buildings as possible to ensure good workingconditions. Help the board of Bytel to plan the number of office buildings and their size in accordancewith the aforementioned requirements.\n\n## Task\n\nWrite a programme which:\n\nreads the description of employees' phone number lists from the standard input        calculates the maximal number of office buildings and their sizes, satisfying board's conditions        writes the outcome to the standard output.", "inputFormat": "The first line of the standard input consists of two integers: $n$ and $m$ ($2 \\le n \\le 100\\ 000$, $1 \\le m \\le 2\\ 000\\ 000$),separated by single spaces, denoting the number of Bytel employees and the number of pairs of employeeswho have their numbers in company phones, respectively. The employees are numbered from $1$ to $n$.\n\nEach of the following $m$ lines contains a single pair of integers $a_i$ and $b_i$ ($1 \\le a_i < b_i \\le n$ for $1 \\le i \\le m$), separated by a single space, denoting that employees $a_i$ and $b_i$ have their numbers (reciprocally) in company phones' memory. Each pair of integers denoting a pair of employees shall occur once at the most in the standard input.\n", "outputFormat": "The first line of the standard output should contain a single integer: the maximal number of office buildingsthat Bytel should rent. The second should contain a non-decreasing sequence of positive integers, separatedby singe spaces, denoting the sizes of the office buildings (i.e. the numbers of employees working there).\n\nShould there exist more than one correct answer - write out any one of them.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2007] BIU-Offices", "background": "", "description": "Bytel is a mobile telephony potentate. Each employee has been issued a company phone, the memory ofwhich holds the numbers of some of his co-workers (all of them have his number in their phones as well).\n\nDue to dynamic growth of their operations the board of directors intends to move company headquaters tonew office buildings. It has been decided - in order to boost work efficiency - that every pair of employeesworking in different buildings should know (reciprocally) each others phone number i.e. the memory of theircompany phone ought to hold necessary phone numbers.\n\nSimultaneously, the board have decided to rent as many office buildings as possible to ensure good workingconditions. Help the board of Bytel to plan the number of office buildings and their size in accordancewith the aforementioned requirements.\n\n## Task\n\nWrite a programme which:\n\nreads the description of employees' phone number lists from the standard input        calculates the maximal number of office buildings and their sizes, satisfying board's conditions        writes the outcome to the standard output.", "inputFormat": "The first line of the standard input consists of two integers: $n$ and $m$ ($2 \\le n \\le 100\\ 000$, $1 \\le m \\le 2\\ 000\\ 000$),separated by single spaces, denoting the number of Bytel employees and the number of pairs of employeeswho have their numbers in company phones, respectively. The employees are numbered from $1$ to $n$.\n\nEach of the following $m$ lines contains a single pair of integers $a_i$ and $b_i$ ($1 \\le a_i < b_i \\le n$ for $1 \\le i \\le m$), separated by a single space, denoting that employees $a_i$ and $b_i$ have their numbers (reciprocally) in company phones' memory. Each pair of integers denoting a pair of employees shall occur once at the most in the standard input.\n", "outputFormat": "The first line of the standard output should contain a single integer: the maximal number of office buildingsthat Bytel should rent. The second should contain a non-decreasing sequence of positive integers, separatedby singe spaces, denoting the sizes of the office buildings (i.e. the numbers of employees working there).\n\nShould there exist more than one correct answer - write out any one of them.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2007] BIU-Offices", "background": "", "description": "Bytel 是一家移动通信公司。该公司的每位员工都收到了一部公司生产的电话，电话的通讯录中存储着一些同事的电话号码（每部手机中也都有该手机本身的电话号码）。\n\n由于业务扩张，公司总部需要迁移至新的办公区。为了提高工作效率，董事会决定在不同栋楼工作的每一对员工需要**相互**知道对方的电话号码。即如果 $u$ 和 $v$ 在不同的楼工作，则 $u$ 的通讯录里需要存储 $v$ 的电话号，$v$ 的通讯录里也要存储 $u$ 的电话号码。\n\n同时，董事会决定租用尽可能多的楼，以确保良好的工作条件。现在你需要帮助 Bytel 公司计算出他们需要租用多少栋楼。", "inputFormat": "输入第一行包含两个整数 $n,m$，分别代表公司的员工数和通讯录的信息数，员工从 $1$ 到 $n$ 编号。\n\n接下来 $m$ 行，每行两个整数 $a_i,b_i$，表示 $a_i$ 和 $b_i$ **相互**知道对方的电话号码，保证任意两条信息不重复。", "outputFormat": "输出第一行包含一个整数 $t$：董事会需要租用多少栋办公楼。\n\n第二行包含 $t$ 个整数，第 $i$ 个整数 $c_i$ 表示在第 $i$ 栋建筑工作的员工数量。你的输出需要保证 $c_i$ 是单调不下降的。\n\n如果有多种合法方案，你可以输出任意一种。", "hint": "$2 \\leq n \\leq 10^5$，$1 \\leq m \\leq 2 \\times 10^6$，$1 \\leq a_i \\lt b_i \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P3453", "type": "P", "difficulty": 6, "samples": [["5\n7 4 5 2 5", "7\n7\n8\n7\n7"], ["5\n1 2 3 4 5", "4\n4\n4\n4\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "线段树", "POI（波兰）"], "title": "[POI 2007] DRZ-Trees", "background": "", "description": "Byteasar has a cottage. Lately, he has bought $n$ trees and had them planted all in one row. Byteasar does not,  however, like the order which the trees have been planted in. It particularly annoys him that tall and short  ones have been mixed up, and the composition does not meet his aesthetic criteria.\n\nByteasar has invented a disorder coefficient so as to allow the gardener to comprehend his intentions: thelower the value of the coefficient the prettier the row of trees. It is defined in the following way:\n\n$|h_1-h_2|+|h_2-h_3|+\\cdots+|h_{n-1}-h_n|$, where $h_1,h_2,\\cdots,h_n$ are the heights of consecutive trees in a row.\nReplanting is a very toilsome and cumbersome task, therefore Byteasar has ordered the gardener to replanttwo trees at the most (i.e. interchange their positions). The task of the gardener is to choose the pair to replantin a way that makes the disorder coefficient the smallest.\n\nThe gardener is not sure if he has chosen the correct pair of trees and he fears he may lose his job ifhe is mistaken. Help him: for each tree calculate the minimal disorder coefficient that may be attained byswitching places with any other tree.\n\nTaskWrite a programme which:\n\nreads the height of the consecutive trees in a row from the standard input,        for each tree calculates the minimal disorder coefficient that may be attained should it switch places    with some other tree (or should there be no change at all),        writes the outcome to the standard output.\n\n定义一排树的不整齐程度为相邻两树的高度差的和。设树高分别为 $h _ 1, h _ 2, \\cdots, h _ n$，那么不整齐程度定义为：$|h_1-h_2|+|h_2-h_3|+\\cdots+|h_{n-1}-h_n|$。\n\n请对于每个 $i$ 求出，如果只把 $i$ 和另一棵树交换高度（可以不交换），那么不整齐度最小是多少。\n", "inputFormat": "The first line of the standard input contains one integer $n$ ($2\\le n\\le 50\\ 000$).\n\nThe other contains $n$ integers $h_i$ ($1\\le h_i\\le 100\\ 000\\ 000$)separated by single spaces, denoting the height of the consecutive trees in the row.\n", "outputFormat": "The output should consist of precisely $n$ lines. The $i$'th line should contain a single integer - the smallestdisorder coefficient attainable when considering replanting of the $i$'th tree.\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2007] DRZ-Trees", "background": "", "description": "Byteasar has a cottage. He has bought $n$ trees and had them planted in a single row. He dislikes the current order: tall and short ones are mixed, and the arrangement does not meet his aesthetic criteria.\n\nHe defines the disorder coefficient of a row as the sum of absolute differences of heights of adjacent trees:\n$|h_1 - h_2| + |h_2 - h_3| + \\cdots + |h_{n-1} - h_n|$, where $h_1, h_2, \\cdots, h_n$ are the heights of the trees in order.\n\nReplanting is laborious, so at most two trees may be replanted, i.e., their positions may be swapped. For each position $i$, determine the minimal disorder coefficient that can be achieved by swapping the tree at position $i$ with any other single tree (or by not swapping at all).", "inputFormat": "The first line contains one integer $n$ ($2 \\le n \\le 50\\ 000$).\n\nThe second line contains $n$ integers $h_i$ ($1 \\le h_i \\le 100\\ 000\\ 000$), separated by single spaces, denoting the heights of the trees in order.", "outputFormat": "Output exactly $n$ lines. The $i$-th line should contain a single integer: the minimal disorder coefficient attainable when considering swapping the $i$-th tree with some other tree (or making no change).", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2007] DRZ-Trees", "background": "", "description": "Byteasar has a cottage. Lately, he has bought $n$ trees and had them planted all in one row. Byteasar does not,  however, like the order which the trees have been planted in. It particularly annoys him that tall and short  ones have been mixed up, and the composition does not meet his aesthetic criteria.\n\nByteasar has invented a disorder coefficient so as to allow the gardener to comprehend his intentions: thelower the value of the coefficient the prettier the row of trees. It is defined in the following way:\n\n$|h_1-h_2|+|h_2-h_3|+\\cdots+|h_{n-1}-h_n|$, where $h_1,h_2,\\cdots,h_n$ are the heights of consecutive trees in a row.\nReplanting is a very toilsome and cumbersome task, therefore Byteasar has ordered the gardener to replanttwo trees at the most (i.e. interchange their positions). The task of the gardener is to choose the pair to replantin a way that makes the disorder coefficient the smallest.\n\nThe gardener is not sure if he has chosen the correct pair of trees and he fears he may lose his job ifhe is mistaken. Help him: for each tree calculate the minimal disorder coefficient that may be attained byswitching places with any other tree.\n\nTaskWrite a programme which:\n\nreads the height of the consecutive trees in a row from the standard input,        for each tree calculates the minimal disorder coefficient that may be attained should it switch places    with some other tree (or should there be no change at all),        writes the outcome to the standard output.\n\n定义一排树的不整齐程度为相邻两树的高度差的和。设树高分别为 $h _ 1, h _ 2, \\cdots, h _ n$，那么不整齐程度定义为：$|h_1-h_2|+|h_2-h_3|+\\cdots+|h_{n-1}-h_n|$。\n\n请对于每个 $i$ 求出，如果只把 $i$ 和另一棵树交换高度（可以不交换），那么不整齐度最小是多少。\n", "inputFormat": "The first line of the standard input contains one integer $n$ ($2\\le n\\le 50\\ 000$).\n\nThe other contains $n$ integers $h_i$ ($1\\le h_i\\le 100\\ 000\\ 000$)separated by single spaces, denoting the height of the consecutive trees in the row.\n", "outputFormat": "The output should consist of precisely $n$ lines. The $i$'th line should contain a single integer - the smallestdisorder coefficient attainable when considering replanting of the $i$'th tree.\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3454", "type": "P", "difficulty": 6, "samples": [["2\n12\n1 -1\n2 -1\n2 1\n1 1\n1 2\n-1 2\n-1 1\n-2 1\n-2 -1\n-1 -1\n-1 -2\n1 -2\n6\n-1 1\n-2 0\n-1 -1\n1 -1\n2 0\n1 1", "4\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "计算几何", "2007", "POI（波兰）", "KMP 算法"], "title": "[POI 2007] OSI-Axes of Symmetry", "background": "", "description": "Little Johnny - a well-respected young mathematician - has a younger sister, Justina. Johnny likes hissister very much and he gladly helps her with her homework, but, like most scientific minds, he does mindsolving the same problems again. Unfortunately, Justina is a very diligent pupil, and so she asks Johnny toreview her assignments many times, for sake of certainty. One sunny Friday, just before the famous LongMay Weekend1 the math teacher gave many exercises consisting in finding the axes of symmetry of variousgeometric figures. Justina is most likely to spend considerable amount of time solving these tasks. LittleJohnny had arranged himself a trip to the seaside long time before, nevertheless he feels obliged to help hislittle sister. Soon, he has found a solution - it would be best to write a programme that wouldease checking Justina's solutions. Since Johnny is a mathematician, not a computer scientist, and you are hisbest friend, it falls to you to write it.\n\n## Task\n\nWrite a programme that:\n\n- reads the descriptions of the polygons from the standard input,\n\n- determines the number of axes of symmetry for each one of them,\n\n- writes the result to the standard output.\n\n\n给定一个多边形，求对称轴数量。\n", "inputFormat": "In the first line of the input there is one integer $t$ ($1 \\le t \\le 10$) - it is the number of polygons, for which the number of axes of symmetry is to be determined. Next, $t$ descriptions of the polygons follow. The first line of each description contains one integer $n$ ($3 \\le n \\le 100\\ 000$) denoting the number of vertices of the polygon. In each of the following $n$ lines there are two integers $x$ and $y$ ($-100\\ 000\\ 000 \\le x, y \\le 100\\ 000\\ 000$) representing the coordinates of subsequent vertices of the polygon. The polygons need not be convex, but they have no self-intersections - any two sides have at most one common point - their common endpoint, if they actually share it. Furthermore, no pair of consecutive sides is parallel.\n", "outputFormat": "Your programme should output exactly $t$ lines, with the $k$'th line containing a sole integer $n_k$ - the number of axes of symmetry of the $k$'th polygon.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2007] OSI-Axes of Symmetry", "background": "", "description": "Little Johnny - a well-respected young mathematician - has a younger sister, Justina. Johnny likes hissister very much and he gladly helps her with her homework, but, like most scientific minds, he does mindsolving the same problems again. Unfortunately, Justina is a very diligent pupil, and so she asks Johnny toreview her assignments many times, for sake of certainty. One sunny Friday, just before the famous LongMay Weekend1 the math teacher gave many exercises consisting in finding the axes of symmetry of variousgeometric figures. Justina is most likely to spend considerable amount of time solving these tasks. LittleJohnny had arranged himself a trip to the seaside long time before, nevertheless he feels obliged to help hislittle sister. Soon, he has found a solution - it would be best to write a programme that wouldease checking Justina's solutions. Since Johnny is a mathematician, not a computer scientist, and you are hisbest friend, it falls to you to write it.\n\n## Task\n\nWrite a programme that:\n\n- reads the descriptions of the polygons from the standard input,\n\n- determines the number of axes of symmetry for each one of them,\n\n- writes the result to the standard output.\n\n\n给定一个多边形，求对称轴数量。\n", "inputFormat": "In the first line of the input there is one integer $t$ ($1 \\le t \\le 10$) - it is the number of polygons, for which the number of axes of symmetry is to be determined. Next, $t$ descriptions of the polygons follow. The first line of each description contains one integer $n$ ($3 \\le n \\le 100\\ 000$) denoting the number of vertices of the polygon. In each of the following $n$ lines there are two integers $x$ and $y$ ($-100\\ 000\\ 000 \\le x, y \\le 100\\ 000\\ 000$) representing the coordinates of subsequent vertices of the polygon. The polygons need not be convex, but they have no self-intersections - any two sides have at most one common point - their common endpoint, if they actually share it. Furthermore, no pair of consecutive sides is parallel.\n", "outputFormat": "Your programme should output exactly $t$ lines, with the $k$'th line containing a sole integer $n_k$ - the number of axes of symmetry of the $k$'th polygon.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2007] OSI-Axes of Symmetry", "background": "", "description": "Johnny 是一位非常年轻的数学家，但他此刻正在为他妹妹的数学作业烦恼。\n\n这个周末，他的妹妹需要完成一项作业，计算各种几何图形的对称轴数量。因为 Johnny 这个周末想要去海边旅行，所以他希望他的妹妹能尽快完成这项作业。\n\n于是他找到了擅长编程的你，你一定能帮助他完成这项任务的！", "inputFormat": "输入包含多组数据。\n\n第一行包含一个整数 $t$，代表数据的组数。\n\n对于每组数据，第一行一个整数 $n$，代表多边形的顶点数。\n\n接下来 $n$ 行，每行两个整数 $x_i,y_i$，代表每个顶点的坐标。\n\n输入中的第 $i$ 个顶点会与第 $i+1$ 个顶点连一条边。特别地，输入中的第 $n$ 个顶点会与第一个顶点连一条边。\n\n输入给出的多边形**不保证**是凸多边形，但是保证任意两条边只会在端点处相交，且任意两条相邻的边不共线。", "outputFormat": "对于每组数据，输出一行一个整数，即多边形对称轴的数量。", "hint": "$1 \\leq t \\leq 10$，$3 \\leq n \\leq 10^5$，$-10^8 \\leq x_i,y_i \\leq 10^8$。", "locale": "zh-CN"}}}
{"pid": "P3455", "type": "P", "difficulty": 5, "samples": [["2\n4 5 2\n6 4 3", "3\n2"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2007", "POI（波兰）", "最大公约数 gcd", "莫比乌斯反演", "整除分块"], "title": "[POI 2007] ZAP-Queries", "background": "", "description": "密码学家正在尝试破解一种叫 BSA 的密码。\n\n他发现，在破解一条消息的同时，他还需要回答这样一种问题：\n\n给出 $a,b,d$，求满足 $1 \\leq x \\leq a$，$1 \\leq y \\leq b$，且 $\\gcd(x,y)=d$ 的二元组 $(x,y)$ 的数量。\n\n因为要解决的问题实在太多了，他便过来寻求你的帮助。", "inputFormat": "输入第一行一个整数 $n$，代表要回答的问题个数。\n\n接下来 $n$ 行，每行三个整数 $a,b,d$。", "outputFormat": "对于每组询问，输出一个整数代表答案。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n \\leq 5 \\times 10^4$，$1 \\leq d \\leq a,b \\leq 5 \\times 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2007] ZAP-Queries", "background": "", "description": "A cryptographer is trying to break a cipher called BSA.\n\nHe found that while breaking a message, he also needs to answer the following question:\n\nGiven $a,b,d$, count the number of pairs $(x,y)$ such that $1 \\leq x \\leq a$, $1 \\leq y \\leq b$, and $\\gcd(x,y)=d$.\n\nBecause there are so many problems to solve, he asks for your help.", "inputFormat": "The first line contains an integer $n$, the number of queries.\n\nEach of the next $n$ lines contains three integers $a,b,d$.", "outputFormat": "For each query, output a single integer representing the answer.", "hint": "Constraints\n\nFor all testdata, it is guaranteed that $1 \\leq n \\leq 5 \\times 10^4$, $1 \\leq d \\leq a,b \\leq 5 \\times 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2007] ZAP-Queries", "background": "", "description": "密码学家正在尝试破解一种叫 BSA 的密码。\n\n他发现，在破解一条消息的同时，他还需要回答这样一种问题：\n\n给出 $a,b,d$，求满足 $1 \\leq x \\leq a$，$1 \\leq y \\leq b$，且 $\\gcd(x,y)=d$ 的二元组 $(x,y)$ 的数量。\n\n因为要解决的问题实在太多了，他便过来寻求你的帮助。", "inputFormat": "输入第一行一个整数 $n$，代表要回答的问题个数。\n\n接下来 $n$ 行，每行三个整数 $a,b,d$。", "outputFormat": "对于每组询问，输出一个整数代表答案。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n \\leq 5 \\times 10^4$，$1 \\leq d \\leq a,b \\leq 5 \\times 10^4$。", "locale": "zh-CN"}}}
{"pid": "P3456", "type": "P", "difficulty": 4, "samples": [["5\n8 8 8 7 7\n7 7 8 8 7\n7 7 7 7 7\n7 8 8 7 8\n7 8 8 8 8", "2 1"], ["5\n5 7 8 3 1\n5 5 7 6 6\n6 6 6 2 8\n5 7 2 5 8\n7 1 0 1 7", "3 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "POI（波兰）", "广度优先搜索 BFS", "深度优先搜索 DFS"], "title": "[POI 2007] GRZ-Ridges and Valleys", "background": "", "description": "Byteasar loves trekking in the hills. During the hikes he explores all the ridges and valleys in vicinity.\n\nTherefore, in order to plan the journey and know how long it will last, he must know the number of ridgesand valleys in the area he is going to visit. And you are to help Byteasar.\n\nByteasar has provided you with a map of the area of his very next expedition. The map is in the shape ofa $n\\times n$ square. For each field $(i,j)$ belonging to the square(for $i,j\\in \\{1,\\cdots,n\\}$), its height $w_{(i,j)}$ is given.\n\nWe say two fields are adjacent if they have a common side or a common vertex (i.e. the field $(i,j)$ is adjacent to the fields $(i-1,j-1)$,$(i-1,j)$,$(i-1,j+1)$,$(i,j-1)$,$(i,j+1)$,$(i+1,j-1)$,$(i+1,j)$,$(i+1,j+1)$, provided that these fields are on the map).\n\nWe say a set of fields $S$ forms a ridge (valley) if:\n\nall the fields in $S$ have the same height,the set $S$ forms a connected part of the map (i.e. from any field in $S$ it is possible to reach any other    field in $S$ while moving only between adjacent fields and without leaving the set $S$),if $s\\in S$ and the field $s'\\notin S$ is adjacent to $s$, then $w_s>w_{s'}$(for a ridge) or $w_s<w_{s'}$ (for a valley).\n\nIn particular, if all the fields on the map have the same height, they form both a ridge and a valley.\n\nYour task is to determine the number of ridges and valleys for the landscape described by the map.\n\nTaskWrite a programme that:\n\nreads from the standard input the description of the map,        determines the number of ridges and valleys for the landscape described by this map,        writes out the outcome to the standard output.\n\n给定一张地势图，求山峰和山谷的数量\n", "inputFormat": "In the first line of the standard input there is one integer $n$ ($2\\le n\\le 1\\ 000$)denoting the size of the map. Ineach of the following $n$ lines there is the description of the successive row of the map. In $(i+1)$'th line(for $i\\in \\{1,\\cdots,n\\}$) there are $n$ integers $w_{(i,1)},\\cdots,w_{(i,n)}$($0\\le w_i\\le 1\\ 000\\ 000\\ 000$), separated by single spaces. Thesedenote the heights of the successive fields of the $i$'th row of the map.\n", "outputFormat": "The first and only line of the standard output should contain two integers separated by a single space -thenumber of ridges followed by the number of valleys for the landscape described by the map.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2007] GRZ-Ridges and Valleys", "background": "", "description": "Byteasar loves trekking in the hills. During the hikes he explores all the ridges and valleys in vicinity.\n\nTherefore, in order to plan the journey and know how long it will last, he must know the number of ridgesand valleys in the area he is going to visit. And you are to help Byteasar.\n\nByteasar has provided you with a map of the area of his very next expedition. The map is in the shape ofa $n\\times n$ square. For each field $(i,j)$ belonging to the square(for $i,j\\in \\{1,\\cdots,n\\}$), its height $w_{(i,j)}$ is given.\n\nWe say two fields are adjacent if they have a common side or a common vertex (i.e. the field $(i,j)$ is adjacent to the fields $(i-1,j-1)$,$(i-1,j)$,$(i-1,j+1)$,$(i,j-1)$,$(i,j+1)$,$(i+1,j-1)$,$(i+1,j)$,$(i+1,j+1)$, provided that these fields are on the map).\n\nWe say a set of fields $S$ forms a ridge (valley) if:\n\nall the fields in $S$ have the same height,the set $S$ forms a connected part of the map (i.e. from any field in $S$ it is possible to reach any other    field in $S$ while moving only between adjacent fields and without leaving the set $S$),if $s\\in S$ and the field $s'\\notin S$ is adjacent to $s$, then $w_s>w_{s'}$(for a ridge) or $w_s<w_{s'}$ (for a valley).\n\nIn particular, if all the fields on the map have the same height, they form both a ridge and a valley.\n\nYour task is to determine the number of ridges and valleys for the landscape described by the map.\n\nTaskWrite a programme that:\n\nreads from the standard input the description of the map,        determines the number of ridges and valleys for the landscape described by this map,        writes out the outcome to the standard output.\n\n给定一张地势图，求山峰和山谷的数量\n", "inputFormat": "In the first line of the standard input there is one integer $n$ ($2\\le n\\le 1\\ 000$)denoting the size of the map. Ineach of the following $n$ lines there is the description of the successive row of the map. In $(i+1)$'th line(for $i\\in \\{1,\\cdots,n\\}$) there are $n$ integers $w_{(i,1)},\\cdots,w_{(i,n)}$($0\\le w_i\\le 1\\ 000\\ 000\\ 000$), separated by single spaces. Thesedenote the heights of the successive fields of the $i$'th row of the map.\n", "outputFormat": "The first and only line of the standard output should contain two integers separated by a single space -thenumber of ridges followed by the number of valleys for the landscape described by the map.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2007] GRZ-Ridges and Valleys", "background": "", "description": "**译自 POI 2007 Stage 2. Day 0「[Ridges and Valleys](https://szkopul.edu.pl/problemset/problem/rd6H05Dm8ME79sO3U9_f_ga_/site/?key=statement)」**\n\n给定一个 $n \\times n$ 的网格状地图，每个方格 $(i,j)$ 有一个高度 $w_{ij}$。如果两个方格有公共顶点，则它们是相邻的。\n\n定义山峰和山谷如下：\n* 均由地图上的一个连通块组成；\n* 所有方格高度都相同；\n* 周围的方格（即不属于山峰或山谷但与山峰或山谷相邻的格子）高度均大于山谷的高度，或小于山峰的高度。\n\n求地图内山峰和山谷的数量。特别地，如果整个地图方格的高度均相同，则整个地图既是一个山谷，也是一个山峰。", "inputFormat": "第一行一个整数 $n$ （$2 \\le n \\le 1000$），表示地图的大小。\n\n接下来 $n$ 行每行 $n$ 个整数表示地图。第 $i$ 行有 $n$ 个整数 $w_{i1}, w_{i2}, \\ldots, w_{in} (0 \\le w_{ij} \\le 1\\ 000\\ 000\\ 000)$，表示地图第 $i$ 行格子的高度。", "outputFormat": "输出一行两个整数，分别表示山峰和山谷的数量。\n\n### 样例解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yubj6du3.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7ct18655.png)\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2653)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3457", "type": "P", "difficulty": 5, "samples": [["6 9\n-2 -2 -1 -1 -2 -2 -2 -12 -3\n-2 1 -1 2 -8 -12 2 -12 -12\n-5 3 1 1 -12 4 -6 2 -2\n-5 -2 -2 2 -12 -3 4 -3 -1\n-5 -6 -2 2 -12 5 6 2 -1\n-4 -8 -8 -10 -12 -8 -6 -6 -4", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2007", "并查集", "POI（波兰）"], "title": "[POI 2007] POW-The Flood", "background": "", "description": "Byteburg, the capital of Byteotia, is a picturesque city situated in a valley in the midst of mountains. Unfortunately,  recent heavy rainfall has caused a flood - all the Byteburg is now completely under water. Byteasar,  the king of Byteotia, has summoned his most enlightened advisors, including you, to a council. After long  deliberations the council agreed to bring a few pumps, set them up in the flooded area and drain Byteburg.\n\nThe king has asked you to determine the minimum number of pumps sufficing to drain the city.\n\nYou are provided with a map of the city and the valley it is situated in. The map is in the shape of a $m\\times n$ rectangle, divided into unitary squares. For each such square the map tells its height above sea level and alsowhether it is a part of Byteburg or not. The whole area depicted in the map is under water. Furthermore, it issurrounded by much higher mountains, making the outflow of water impossible. Obviously, there is no needto drain the area that does not belong to Byteburg.\n\nEach pump can be placed in any unitary square depicted in the map. The pump will be drawing thewater until its square is completely drained. Of course, the communicating tubes principle makes its work,      so draining one square results in lowering the water level or complete draining of those squares from which      the water can flow down to the one with the pump. Water can flow only between squares with a common side      (or, more exact, squares whose projections onto horizontal plane have a common side, since the squares may       be at different level). Apart from that, the water obviously only flows down.\n\n## Task\n\nWrite a programme that:\n\n- reads description of the map from the standard input,\n\n- determines the minimum number of pumps needed to drain whole Byteburg,\n\n- writes out the outcome to the standard output.", "inputFormat": "In the first line of the standard input there are two integers $m$ and $n$, separated by a single space, $1 \\le n, m \\le 1\\ 000$. The following $m$ lines contain the description of the map. The $(i+1)$'th line describes the $i$'th row of unitary squares in the map. It contains $n$ integers $x_{i,1}, x_{i,2}, ..., x_{i_n}$, separated by single spaces,$-1\\ 000 \\le x_{i,j} \\le 1\\ 000$ ,$x_{i,j} \\ne 1000$ . The number $x_{i,j}$ describes the $j$'th square of the $i$'th line. The ground level in this square is $|x_{i,j}|$ above sea level. If $x_{i,j} > 0$, then the square is part of Byteburg, otherwise it is outside the city. Notice, that the area of Byteburg need not be connected. In fact the city may have several separate parts.\n", "outputFormat": "Your programme should write out one integer to the standard output - the minimum number of pumpsneeded to drain Byteburg.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2007] POW-The Flood", "background": "", "description": "Byteburg, the capital of Byteotia, is a picturesque city situated in a valley in the midst of mountains. Unfortunately,  recent heavy rainfall has caused a flood - all the Byteburg is now completely under water. Byteasar,  the king of Byteotia, has summoned his most enlightened advisors, including you, to a council. After long  deliberations the council agreed to bring a few pumps, set them up in the flooded area and drain Byteburg.\n\nThe king has asked you to determine the minimum number of pumps sufficing to drain the city.\n\nYou are provided with a map of the city and the valley it is situated in. The map is in the shape of a $m\\times n$ rectangle, divided into unitary squares. For each such square the map tells its height above sea level and alsowhether it is a part of Byteburg or not. The whole area depicted in the map is under water. Furthermore, it issurrounded by much higher mountains, making the outflow of water impossible. Obviously, there is no needto drain the area that does not belong to Byteburg.\n\nEach pump can be placed in any unitary square depicted in the map. The pump will be drawing thewater until its square is completely drained. Of course, the communicating tubes principle makes its work,      so draining one square results in lowering the water level or complete draining of those squares from which      the water can flow down to the one with the pump. Water can flow only between squares with a common side      (or, more exact, squares whose projections onto horizontal plane have a common side, since the squares may       be at different level). Apart from that, the water obviously only flows down.\n\n## Task\n\nWrite a programme that:\n\n- reads description of the map from the standard input,\n\n- determines the minimum number of pumps needed to drain whole Byteburg,\n\n- writes out the outcome to the standard output.", "inputFormat": "In the first line of the standard input there are two integers $m$ and $n$, separated by a single space, $1 \\le n, m \\le 1\\ 000$. The following $m$ lines contain the description of the map. The $(i+1)$'th line describes the $i$'th row of unitary squares in the map. It contains $n$ integers $x_{i,1}, x_{i,2}, ..., x_{i_n}$, separated by single spaces,$-1\\ 000 \\le x_{i,j} \\le 1\\ 000$ ,$x_{i,j} \\ne 1000$ . The number $x_{i,j}$ describes the $j$'th square of the $i$'th line. The ground level in this square is $|x_{i,j}|$ above sea level. If $x_{i,j} > 0$, then the square is part of Byteburg, otherwise it is outside the city. Notice, that the area of Byteburg need not be connected. In fact the city may have several separate parts.\n", "outputFormat": "Your programme should write out one integer to the standard output - the minimum number of pumpsneeded to drain Byteburg.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2007] POW-The Flood", "background": "", "description": "**译自 POI 2007 Stage 2. Day 1「[The Flood](https://szkopul.edu.pl/problemset/problem/VutzcR1iPvGuYRGZgvNksmV1/site/?key=statement)」**\n\n你有一张 $m \\times n$ 的地图，地图上所有点都被洪水淹没了。你知道地图上每个网格的海拔高度，其中一部分点属于 Byteburg 城。你需要放置尽可能少的巨型抽水机，将 Byteburg 城从洪水中解救出来。巨型抽水机会抽干该格子的所有水，直到该格子不被洪水淹没为止。\n\n水会在有公共边的格子间从高向低流动。", "inputFormat": "第一行两个整数 $m,n$（$1 \\le m,n \\le 1000$）。\n\n接下来 $m$ 行每行 $n$ 个整数 $x_{i1}, x_{i2}, \\ldots, x_{in} (-1000 \\le x_{ij} \\lt 1000)$，表示地图。第 $i$ 行第 $j$ 列格子的海拔高度为 $\\lvert x_{ij} \\rvert$，且如果 $x_{ij} \\gt 0$，则这个格子在 Byteburg 城内，否则在城外。不保证 Byteburg 城形成一个连通块。", "outputFormat": "输出一行一个整数，表示最少需要的抽水机的数量。\n\n### 样例解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6cal4wth.png)\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2654)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3458", "type": "P", "difficulty": 6, "samples": [["5\n2 3 400\n1 4 100\n2 2 655\n3 4 100\n5 3 277", "10 200\n01010"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "POI（波兰）", "Special Judge", "枚举"], "title": "[POI 2007] SKA-Rock Garden", "background": "", "description": "Vicomte de Bajteaux is the owner of a renowned collection of boulders. Up to now, he has kept it in thecellars of his palace, but recently, he has decided to display the collection in his vast gardens.\n\nThe gardens have a shape of rectangle, whose sides are $1\\ 000\\ 000\\ 000$ units long and are parallel to east-westand north-south geographical directions. For each boulder, vicomte has determined coordinates ofthe point, which he would like it to be placed in (the coordinates are simply distances to the southern and    western side of the garden), and gave them to his servants. Unfortunately he has forgot to tell them the orderof the coordinates (i.e. for some of the boulders the first coordinate of a point is the so called \"$y$ coordinate\",i.e. the ordinate, while for others the so called \"$x$ coordinate\", i.e. the abscissa).\n\nThe servants, unaware of thisfact, have placed the boulders assuming customary coordinate ordering (as in standard Cartesian coordinates:\n\nthe abscissa, commonly known as \"$x$ coordinate\", first).\n\nTo protect his collection, vicomte has decided to surround it with a fence. For aesthetic reasons thefence has to be a rectangle, with sides parallel to the sides of the garden. The garden layout has been planned,      so that the total length of the fence be minimal (i.e. in the space of all coordinate orderings, the original          ordering of vicomte requires the minimal length of the fence - we assume that the rectangle may have sides of zero length).\n\nThe servants have to move the boulders so that the length of the fence required is minimal lest their mistake become obvious. Each boulder may only be moved in a way that preserves the coordinate set: by      interchanging its coordinates. As the boulders are heavy, the servants would like to minimize their effort, by      minimizing the weight of the boulders to be moved.\n\n## Task\n\nWrite a programme which:\n\nreads the present positions of the boulders in the gardens and their respective weights, determines a sequence of moves, which minimizes the length of the fence required to protect the    boulders and also minimizes the weight of the boulders to be moved, writes the outcome to the standard output.", "inputFormat": "The first line of the standard input contains a single integer $n$ ($2 \\le n \\le 1\\ 000\\ 000$), denoting the number of boulders in the collection. The following $n$  lines contain three integers $x_i$, $y_i$ and $m_i$ each ($0 \\le x_i, y_i \\le 1\\ 000\\ 000\\ 000$, $1 \\le m \\le 2000$), separated by single spaces, denoting the present coordinates and the weight of $i$'th boulder. No unordered pair of coordinates will appear in the input more than once.\n", "outputFormat": "The first line of the standard output should contain two integers, separated by a single space - the minimal length of fence possible and the minimal weight of the boulders to be moved in order to obtain such a length.\n\n\nThe second line should contain a sequence of $n$ zeros and/or ones - $i$'th element of the sequence should be a one if in the optimal solution the $i$'th boulder is to be moved and zero otherwise. Should more than one correct solutions exist, your programme is to write out any one of them.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2007] SKA-Rock Garden", "background": "", "description": "Vicomte de Bajteaux is the owner of a renowned collection of boulders. Up to now, he has kept it in thecellars of his palace, but recently, he has decided to display the collection in his vast gardens.\n\nThe gardens have a shape of rectangle, whose sides are $1\\ 000\\ 000\\ 000$ units long and are parallel to east-westand north-south geographical directions. For each boulder, vicomte has determined coordinates ofthe point, which he would like it to be placed in (the coordinates are simply distances to the southern and    western side of the garden), and gave them to his servants. Unfortunately he has forgot to tell them the orderof the coordinates (i.e. for some of the boulders the first coordinate of a point is the so called \"$y$ coordinate\",i.e. the ordinate, while for others the so called \"$x$ coordinate\", i.e. the abscissa).\n\nThe servants, unaware of thisfact, have placed the boulders assuming customary coordinate ordering (as in standard Cartesian coordinates:\n\nthe abscissa, commonly known as \"$x$ coordinate\", first).\n\nTo protect his collection, vicomte has decided to surround it with a fence. For aesthetic reasons thefence has to be a rectangle, with sides parallel to the sides of the garden. The garden layout has been planned,      so that the total length of the fence be minimal (i.e. in the space of all coordinate orderings, the original          ordering of vicomte requires the minimal length of the fence - we assume that the rectangle may have sides of zero length).\n\nThe servants have to move the boulders so that the length of the fence required is minimal lest their mistake become obvious. Each boulder may only be moved in a way that preserves the coordinate set: by      interchanging its coordinates. As the boulders are heavy, the servants would like to minimize their effort, by      minimizing the weight of the boulders to be moved.\n\n## Task\n\nWrite a programme which:\n\nreads the present positions of the boulders in the gardens and their respective weights, determines a sequence of moves, which minimizes the length of the fence required to protect the    boulders and also minimizes the weight of the boulders to be moved, writes the outcome to the standard output.", "inputFormat": "The first line of the standard input contains a single integer $n$ ($2 \\le n \\le 1\\ 000\\ 000$), denoting the number of boulders in the collection. The following $n$  lines contain three integers $x_i$, $y_i$ and $m_i$ each ($0 \\le x_i, y_i \\le 1\\ 000\\ 000\\ 000$, $1 \\le m \\le 2000$), separated by single spaces, denoting the present coordinates and the weight of $i$'th boulder. No unordered pair of coordinates will appear in the input more than once.\n", "outputFormat": "The first line of the standard output should contain two integers, separated by a single space - the minimal length of fence possible and the minimal weight of the boulders to be moved in order to obtain such a length.\n\n\nThe second line should contain a sequence of $n$ zeros and/or ones - $i$'th element of the sequence should be a one if in the optimal solution the $i$'th boulder is to be moved and zero otherwise. Should more than one correct solutions exist, your programme is to write out any one of them.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2007] SKA-Rock Garden", "background": "", "description": "**译自 POI 2007 Stage 2. Day 1「[Skalniak](https://szkopul.edu.pl/problemset/problem/s5ECsFKlMHti0g29uVkdKlQw/site/?key=statement)」**\n\nVicomte de Bajteaux 收藏了许多石头并准备把它们放到花园里。\n\n花园是一个正方形，边长为 $1\\ 000\\ 000\\ 000$。Vicomte de Bajteaux 让他的仆人为他用石头布置花园。但他忘记告诉仆人坐标的顺序，以至于一些点的坐标以 $(x,y)$ 的形式给出，一些点的坐标以 $(y,x)$ 的形式给出，并且石头已经按这样的顺序放好了。\n\n为了保护石头，Vicomte de Bajteaux 按照实际的坐标规划了一排栅栏来围住这些石头，使得栅栏的总长最小。为了美观，栅栏必须是平行于坐标轴的矩形。为了让错误不那么明显，你需要帮助仆人选择一部分石头并将它们从 $(x,y)$ 移动到 $(y,x)$，在最小化栅栏的长度的基础上最小化需要移动的石头的总重。", "inputFormat": "第一行一个整数 $n (1 \\le n \\le 1\\ 000\\ 000)$，表示石头的个数。\n\n接下来 $n$ 行每行三个整数 $x_i, y_i, m_i$（$0 \\le x_i,y_i \\le 1\\ 000\\ 000\\ 000, 1 \\le m_i \\le 2\\ 000$），表示石头当前所在的坐标和重量。\n\n不会有 $x$ 和 $y$ 组成的无序数对出现超过一次。", "outputFormat": "第一行输出两个整数，分别表示栅栏的最小长度和需要移动的石头总重量的最小值。\n\n第二行输出一个长度为 $n$ 的 01 串，表示取到石头总重量最小值的一种移动方案。第 $i$ 个字符为 $1$ 表示需要将第 $i$ 个石头从 $(x_i, y_i)$ 移动到 $(y_i, x_i)$，为 $0$ 则表示不需要。若有多解，输出任意一种解法均可以。\n\n### 样例解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gjo0jemf.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/09zdeg0c.png)\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2655)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3459", "type": "P", "difficulty": 5, "samples": [["5\n1 2\n1 3\n1 4\n4 5\n4\nW 5\nA 1 4\nW 5\nA 4 5\nW 5\nW 2\nA 1 2\nA 1 3", "2\n1\n0\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "线段树", "树状数组", "POI（波兰）", "深度优先搜索 DFS", "树链剖分", "栈"], "title": "", "background": "", "description": "Byteotia has been eventually touched by globalisation, and so has Byteasar the Postman, who once roamedthe country lanes amidst sleepy hamlets and who now dashes down the motorways. But it is those strolls inthe days of yore that he reminisces about with a touch of tenderness.\n\nIn the olden days $n$ Byteotian villages (numbered from $1$ to $n$) were connected by bidirectional dirt roadsin such a way, that one could reach the village number $1$ (called Bitburg) from any other village in exactlyone way. This unique route passed only through villages with number less or equal to that of the startingvillage. Furthermore, each road connected exactly two distinct villages without passing through any othervillage. The roads did not intersect outside the villages, but tunnels and viaducts were not unheard of.\n\nTime passing by, successive roads were being transformed into motorways. Byteasar remembers distinctly,  when each of the country roads so disappeared. Nowadays, there is not a single country lane left  in Byteotia - all of them have been replaced with motorways, which connect the villages into Byteotian  Megalopolis.\n\nByteasar recalls his trips with post to those villages. Each time he was beginning his journey with letters  to some distinct village in Bitburg. He asks you to calculate, for each such journey (which took place in a      specific moment of time and led from Bitburg to a specified village), how many country roads it led through.\n\nTaskWrite a programme which:\n\nreads from the standard input:\n\ndescriptions of roads that once connected Byteotian villages,    sequence of events: Byteasar's trips and the moments when respective roads were transformed    into motorways,            for each trip, calculates how many country roads Byteasar has had to walk,        writes the outcome to the standard output.", "inputFormat": "In the first line of the standard input there is a single integer $n$ ($1\\le n\\le 250\\ 000$),denoting the number of villages in Byteotia. The following $n-1$ lines contain descriptions of the roads, in the form of two integers $a$,$b$ ($1\\le a<b\\le n$)separated by a single space, denoting the numbers of villages connected with a road. Inthe next line there is a single integer $m$($1\\le m\\le 250\\ 000$),denoting the number of trips Byteasar has made.\n\nThe following $n+m-1$ lines contain descriptions of the events, in chronological order:\n\nA description of the form \"A $a$ $b$\"(for $a<b$) denotes a country road between villages $a$ and $b$ beingtransformed into a motorway in that particular moment.\n\nA description of the from \"W $a$\" denotes Byteasar's trip from Bitburg to village $a$.", "outputFormat": "Your programme should write out exactly $m$ integers to the standard output, one a line, denoting the numberof country roads Byteasar has travelled during his successive trips.", "hint": "", "locale": "en", "translations": {"en": {"title": "", "background": "", "description": "Byteotia has been eventually touched by globalisation, and so has Byteasar the Postman, who once roamedthe country lanes amidst sleepy hamlets and who now dashes down the motorways. But it is those strolls inthe days of yore that he reminisces about with a touch of tenderness.\n\nIn the olden days $n$ Byteotian villages (numbered from $1$ to $n$) were connected by bidirectional dirt roadsin such a way, that one could reach the village number $1$ (called Bitburg) from any other village in exactlyone way. This unique route passed only through villages with number less or equal to that of the startingvillage. Furthermore, each road connected exactly two distinct villages without passing through any othervillage. The roads did not intersect outside the villages, but tunnels and viaducts were not unheard of.\n\nTime passing by, successive roads were being transformed into motorways. Byteasar remembers distinctly,  when each of the country roads so disappeared. Nowadays, there is not a single country lane left  in Byteotia - all of them have been replaced with motorways, which connect the villages into Byteotian  Megalopolis.\n\nByteasar recalls his trips with post to those villages. Each time he was beginning his journey with letters  to some distinct village in Bitburg. He asks you to calculate, for each such journey (which took place in a      specific moment of time and led from Bitburg to a specified village), how many country roads it led through.\n\nTaskWrite a programme which:\n\nreads from the standard input:\n\ndescriptions of roads that once connected Byteotian villages,    sequence of events: Byteasar's trips and the moments when respective roads were transformed    into motorways,            for each trip, calculates how many country roads Byteasar has had to walk,        writes the outcome to the standard output.", "inputFormat": "In the first line of the standard input there is a single integer $n$ ($1\\le n\\le 250\\ 000$),denoting the number of villages in Byteotia. The following $n-1$ lines contain descriptions of the roads, in the form of two integers $a$,$b$ ($1\\le a<b\\le n$)separated by a single space, denoting the numbers of villages connected with a road. Inthe next line there is a single integer $m$($1\\le m\\le 250\\ 000$),denoting the number of trips Byteasar has made.\n\nThe following $n+m-1$ lines contain descriptions of the events, in chronological order:\n\nA description of the form \"A $a$ $b$\"(for $a<b$) denotes a country road between villages $a$ and $b$ beingtransformed into a motorway in that particular moment.\n\nA description of the from \"W $a$\" denotes Byteasar's trip from Bitburg to village $a$.", "outputFormat": "Your programme should write out exactly $m$ integers to the standard output, one a line, denoting the numberof country roads Byteasar has travelled during his successive trips.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2007] MEG-Megalopolis", "background": null, "description": "Byteotia 最终也被全球化浪潮席卷，邮递员 Byteasar 也不例外。他曾经漫步在宁静的乡间小村中，如今却飞驰在高速公路上。但往昔那些悠闲的漫步，仍让他带着一丝温柔怀念。\n\n过去，$n$ 个 Byteotia 村庄（编号 $1$ 至 $n$）通过双向泥土路相连，其结构满足：\n\n从任意村庄出发到村庄 $1$（称为 Bitburg）存在唯一路径。\n\n该路径仅经过编号小于等于起点村庄的村庄。\n\n每条路直接连接两个不同村庄且不经过其他村庄。\n\n道路不在村庄外交叉（但可能存在隧道或高架桥）。\n\n岁月流转，乡间道路相继被改造成高速公路。Byteasar 清晰地记得每条路消失的时刻。如今，Byteotia 已无乡间小路——它们全被高速公路取代，将村庄连成了 Byteotia 大都市。\n\nByteasar 回想起他去各村送信的旅程。每次他从 Bitburg 出发，前往某个特定村庄。请你计算：对于每次发生在特定时刻、从 Bitburg 到指定村庄的旅程，他途经了多少条乡间道路。\n\n### 任务\n\n编写程序实现：\n\n1. 输入：\n\n- 初始道路连接描述\n\n- 按时间顺序的事件序列（Byteasar 的旅程和道路改造事件）\n\n2. 输出：\n\n- 对每次旅程，计算 Byteasar 经过的乡间道路数量", "inputFormat": "第一行：整数 $n$（$1 \\le n \\le 250,000$），表示村庄数。\n\n接下来 $n-1$ 行：每行两个整数 $a, b$（$1 \\le a < b \\le n$），表示一条连接村庄 $a$ 和 $b$ 的初始道路。\n\n下一行：整数 $m$（$1 \\le m \\le 250,000$），表示旅程次数。\n\n接下来 $n+m-1$ 行：按时间顺序描述事件：\n\n- `A a b`（$a < b$）：村庄 $a$ 和 $b$ 间的道路被改造为高速公路。\n\n- `W a`：Byteasar 从 Bitburg 出发到村庄 $a$ 的旅程查询。", "outputFormat": "输出 $m$ 行，每行一个整数，表示每次旅程中经过的乡间道路数量。", "hint": "翻译：DeepSeek-R1", "locale": "zh-CN"}}}
{"pid": "P3460", "type": "P", "difficulty": 6, "samples": [["5\n5\n2\n3\n1\n4\n1\n4\n3\n5\n2", "2\n5\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2007", "树状数组", "POI（波兰）", "Special Judge", "栈"], "title": "[POI 2007] TET-Tetris Attack", "background": "", "description": "一种名为 *Tetris Attack* 的猜谜游戏风靡 Byteotia。游戏本身非常复杂，因此我们只介绍它的简化规则：\n\n玩家拥有一个有 $2n$ 个元素的栈，一个元素放置在另一个元素上，这样一个组合有 $n$ 个不同的符号标记。对于每个符号，栈中恰好有两个元素用一个符号标记。\n\n玩家可以交换两个相邻元素，即互换他们的位置。交换后，如果有两个相邻的元素标有相同的符号，则将他们都从栈中删除。然后，位于其上方的所有元素都会掉落下来，并且可以造成再次删除。\n\n玩家的目标是以最少的移动次数清空堆栈。请你编写一个程序，找出最少的移动次数及方案。", "inputFormat": "第一行一个整数 $n$。\n\n接下来的 $2n$ 行里给出了栈的初始内容，第 $i+1$ 行包含一个整数 $a_i$（$1 \\leq a_i \\leq n $），表示从底部数起第 $i$ 个元素所标记的符号（每个符号都在栈中出现正好两次）。\n\n最初不存在相邻的两个元素符号相同的情况，保证有不超过 $10^6$ 次操作的方案。", "outputFormat": "第一行一个整数 $m$ ，表示最小的移动次数。\n\n接下来 $m$ 行，每行输出一个数。\n\n第 $i + 1$ 行输出 $p_i$，即表示玩家在第 $i$ 步时选择交换 $p_i$ 与 $p_{i+1}$。\n\n如果存在多个方案，则输出其中任何一个。", "hint": "$1 \\le n \\le 50000$", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2007] TET-Tetris Attack", "background": "", "description": "A puzzle game named Tetris Attack is popular in Byteotia. The game itself is very complex, so we only describe its simplified rules:\n\nThe player has a stack with $2n$ elements, one placed atop another. There are $n$ distinct symbols in total. For each symbol, exactly two elements in the stack are labeled with that symbol.\n\nThe player may swap two adjacent elements, i.e., exchange their positions. After a swap, if two adjacent elements bear the same symbol, remove both from the stack. Then all elements above them fall down, which may trigger further removals.\n\nThe goal is to empty the stack with the fewest moves. Write a program to find the minimum number of moves and one corresponding sequence of swaps.", "inputFormat": "The first line contains an integer $n$.\n\nThe next $2n$ lines give the initial contents of the stack. The $(i+1)$-th line contains an integer $a_i$ ($1 \\leq a_i \\leq n$), indicating that the $i$-th element from the bottom is labeled with symbol $a_i$ (each symbol appears in the stack exactly twice).\n\nInitially, there are no two adjacent elements with the same symbol. It is guaranteed that there exists a solution with at most $10^6$ moves.", "outputFormat": "The first line contains an integer $m$, the minimum number of moves.\n\nThe next $m$ lines each contain one number.\n\nOn the $(i+1)$-th line, output $p_i$, meaning that on the $i$-th step the player swaps positions $p_i$ and $p_{i+1}$.\n\nIf there are multiple valid solutions, output any of them.", "hint": "$1 \\le n \\le 50000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2007] TET-Tetris Attack", "background": "", "description": "一种名为 *Tetris Attack* 的猜谜游戏风靡 Byteotia。游戏本身非常复杂，因此我们只介绍它的简化规则：\n\n玩家拥有一个有 $2n$ 个元素的栈，一个元素放置在另一个元素上，这样一个组合有 $n$ 个不同的符号标记。对于每个符号，栈中恰好有两个元素用一个符号标记。\n\n玩家可以交换两个相邻元素，即互换他们的位置。交换后，如果有两个相邻的元素标有相同的符号，则将他们都从栈中删除。然后，位于其上方的所有元素都会掉落下来，并且可以造成再次删除。\n\n玩家的目标是以最少的移动次数清空堆栈。请你编写一个程序，找出最少的移动次数及方案。", "inputFormat": "第一行一个整数 $n$。\n\n接下来的 $2n$ 行里给出了栈的初始内容，第 $i+1$ 行包含一个整数 $a_i$（$1 \\leq a_i \\leq n $），表示从底部数起第 $i$ 个元素所标记的符号（每个符号都在栈中出现正好两次）。\n\n最初不存在相邻的两个元素符号相同的情况，保证有不超过 $10^6$ 次操作的方案。", "outputFormat": "第一行一个整数 $m$ ，表示最小的移动次数。\n\n接下来 $m$ 行，每行输出一个数。\n\n第 $i + 1$ 行输出 $p_i$，即表示玩家在第 $i$ 步时选择交换 $p_i$ 与 $p_{i+1}$。\n\n如果存在多个方案，则输出其中任何一个。", "hint": "$1 \\le n \\le 50000$", "locale": "zh-CN"}}}
{"pid": "P3461", "type": "P", "difficulty": 0, "samples": [["8 11\n1 2 6\n3 1 5\n2 3 8\n3 4 9\n3 5 10\n5 4 3\n5 6 9\n6 4 8\n6 8 8\n6 7 7\n8 7 10\n4 2 5 7 8", "42 5\n2 3\n3 5\n5 6\n6 7\n6 8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "POI（波兰）", "Special Judge"], "title": "[POI 2007] KOL-Railway", "background": "", "description": "Byteland Railways encountered a necessity of restructuring and    reduction of the rail network.\n\nAfter a deep analysis of of the rail network it has been decided    which railway stations will be removed and which ones will stay.\n\nIt has been also decided that the rail network should be reduced as far    as possible.\n\nIt remains to choose which railway lines should be removed and which    ones should stay.\n\nThe rail network is composed of rail segments connecting railway    stations.\n\nIt is known that from each station one can travel to every other    station (potentially visiting some intermediate stations).\n\nRail segments are bidirectional.\n\nThere can be at most one rail segment connecting each pair of stations.\n\nEach segment can be assigned a cost of maintenance, which is    a positive integer.\n\nThe rail segments that will remain should be chosen in such    way that:\n\nit is possible to travel between every pair of stations        that are not going to be removed,                  their total cost of maintenance is low (it can be at most two times        greater than the lowest cost that can be achieved, assuming that the        previous condition is satisfied).\n\nAll remaining rail segments will be removed.\n\nRailway lines that will remain can run through stations that will be    removed.\n\nTaskWrite a programme which:\n\nreads a description of the rail network and the stations          that will not be removed from the standard input,                      determines which rail segments should remain and which should          be removed,                      writes out the rail segments that should remain together with the          total cost of their maintenance to the standard output.\n", "inputFormat": "The first line of input contains two positive integers $n$ and $m$, $2\\le n\\le 5\\ 000$, $1\\le m\\le 500\\ 000$($m\\le \\frac{n(n-1)}{2}$),      separated by a single space.\n\n$n$ denotes the number of railway stations and $m$ is the number of rail segments.\n\nRailway stations are numbered from $1$ to $n$.\n\nThe following $m$ lines contain descriptions of the rail      segments, one per line.\n\nEach of these lines contains three positive integers $a$,$b$ and $u$,$1\\le a,b\\le n$,$a\\ne b$,$1\\le u\\le 100\\ 000$.\n\n$a$ and $b$ are the numbers of stations that are connected      by the segment and $u$ is its cost of maintenance.\n\nThe $(m+2)$'th line contains a sequence of integers separated by      single spaces.\n\nThe first one of them is $p$ - the number of stations that should remain      ($1\\le p\\le n$, $p\\cdot m\\le 15\\ 000\\ 000$).\n\nIt is followed by the numbers of these stations in increasing order.\n", "outputFormat": "The first line of output should contain two integers $c$ and $k$ separated by a single space, where $c$ is the total cost of maintenance of the segments that      should remain and $k$ is the number of these segments.\n\nEach of the following $k$ lines should contain two integers $a_i$ and $b_i$, separated by a single space -      the numbers of stations that are connected by the segment.\n\nThe total cost of maintenance of the segments can be at most      two times greater than the lowest achievable total cost.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2007] KOL-Railway", "background": "", "description": "Byteland Railways encountered a necessity of restructuring and    reduction of the rail network.\n\nAfter a deep analysis of of the rail network it has been decided    which railway stations will be removed and which ones will stay.\n\nIt has been also decided that the rail network should be reduced as far    as possible.\n\nIt remains to choose which railway lines should be removed and which    ones should stay.\n\nThe rail network is composed of rail segments connecting railway    stations.\n\nIt is known that from each station one can travel to every other    station (potentially visiting some intermediate stations).\n\nRail segments are bidirectional.\n\nThere can be at most one rail segment connecting each pair of stations.\n\nEach segment can be assigned a cost of maintenance, which is    a positive integer.\n\nThe rail segments that will remain should be chosen in such    way that:\n\nit is possible to travel between every pair of stations        that are not going to be removed,                  their total cost of maintenance is low (it can be at most two times        greater than the lowest cost that can be achieved, assuming that the        previous condition is satisfied).\n\nAll remaining rail segments will be removed.\n\nRailway lines that will remain can run through stations that will be    removed.\n\nTaskWrite a programme which:\n\nreads a description of the rail network and the stations          that will not be removed from the standard input,                      determines which rail segments should remain and which should          be removed,                      writes out the rail segments that should remain together with the          total cost of their maintenance to the standard output.\n", "inputFormat": "The first line of input contains two positive integers $n$ and $m$, $2\\le n\\le 5\\ 000$, $1\\le m\\le 500\\ 000$($m\\le \\frac{n(n-1)}{2}$),      separated by a single space.\n\n$n$ denotes the number of railway stations and $m$ is the number of rail segments.\n\nRailway stations are numbered from $1$ to $n$.\n\nThe following $m$ lines contain descriptions of the rail      segments, one per line.\n\nEach of these lines contains three positive integers $a$,$b$ and $u$,$1\\le a,b\\le n$,$a\\ne b$,$1\\le u\\le 100\\ 000$.\n\n$a$ and $b$ are the numbers of stations that are connected      by the segment and $u$ is its cost of maintenance.\n\nThe $(m+2)$'th line contains a sequence of integers separated by      single spaces.\n\nThe first one of them is $p$ - the number of stations that should remain      ($1\\le p\\le n$, $p\\cdot m\\le 15\\ 000\\ 000$).\n\nIt is followed by the numbers of these stations in increasing order.\n", "outputFormat": "The first line of output should contain two integers $c$ and $k$ separated by a single space, where $c$ is the total cost of maintenance of the segments that      should remain and $k$ is the number of these segments.\n\nEach of the following $k$ lines should contain two integers $a_i$ and $b_i$, separated by a single space -      the numbers of stations that are connected by the segment.\n\nThe total cost of maintenance of the segments can be at most      two times greater than the lowest achievable total cost.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2007] KOL-Railway", "background": "", "description": "出言不逊铁路系统需要重新布置。通过对铁路网络深入的分析，有一些站点需要被移除，有一些道路也需要被移除。 整个铁路网络可以看做一张由 $n$ 个点，$m$ 条道路组成的无向图。从每一个点出发都可以通过直接或间接的道路到达其它所有点。两个站点之间最多只有一条道路。每一条道路都有一个正整数费用。你的任务是决定哪些点和道路需要被保留。 要求：\n\n1.从每一个没被移除的点出发都能通过直接或间接的没被移除的道路到达其他所有没被移除的点。\n\n2.剩下的道路的费用总和要比较小，即不能超过最优解的两倍。", "inputFormat": "第一行包含两个正整数 $n$、$m$（$2\\leq n\\leq 5\\times 10^3$，$1\\leq m\\leq 5\\times 10^5$），表示点数和边数。 接下来 $m$ 行，每行包含三个正整数 $a$、$b$、$u$（$1\\leq a$、$b\\leq n$，$a\\neq b$，$1\\leq u\\leq 1 \\times 10^5$），表示 $a$ 和 $b$ 之间有一条费用为 $u$ 的道路。 最后一行的开头为一个正整数 $p$（$2\\leq p\\leq n$，$p\\times m\\leq 1.5\\times 10^7$），表示必须要保留的点数。 接下来包含 $p$ 个正整数，按递增顺序依次给出必须保留的点的编号。", "outputFormat": "第一行包含两个正整数 $c$、$k$，其中 $c$ 表示剩余道路的费用总和，$k$ 表示剩余道路的条数。 接下来 $k$ 行，每行包含两个正整数 $a$、$b$，表示一条道路的两个端点。 如有多组解，输出任意一组。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3462", "type": "P", "difficulty": 6, "samples": [["2 4\n13 9\n4 12 2 4", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "贪心", "2007", "POI（波兰）", "进制"], "title": "[POI 2007] ODW-Weights", "background": "", "description": "While moving to a new compound the Byteotian Institute of Experimental Physics has encountered a logisticalproblem - the transfer of its vast collection of precision weights turned out to be non-trivial.\n\nThe Institute has a certain number of containers of limited strength at its disposal. As many weightsas possible are to be put into the containers, the remaining ones will be discarded. There is no limit onthe number of weights to be put in a container apart from the requirement of not exceeding its strength. Acontainer may also be empty.\n\nAny two weights in the Institute have a peculiar property: the mass of one of them is an integer multipleof the mass of the other. Particularly, they may have the same mass.\n\nTaskWrite a programme which:\n\nreads the durabilities of the containers and masses of the weights from the standard input,        determines the maximal number of weights that can be put in the containers,        writes the outcome to the standard output.\n", "inputFormat": "The first line of the standard input contains two integers $n$ and $m$($1\\le n,m\\le 100\\ 000$), separated by a singlespace, denoting respectively: the number of containers and the number of weights. The second line of thestandard input consists of $n$ integers $w_i$ ($1\\le w_i\\le 1\\ 000\\ 000\\ 000$ for $1\\le i\\le n$), separated by single spaces,denoting the strengths of containers in milligrammes. In the third line there are $m$ integers $m_j$($1\\le m_j\\le 1\\ 000\\ 000\\ 000$) for $1\\le j\\le m$), separated by single spaces, denoting masses of the weights in milligrammes.\n", "outputFormat": "The first and only line of the standard output should contain a single integer -the maximal number ofweights that can be placed in the containers without exceeding their durability.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2007] ODW-Weights", "background": "", "description": "While moving to a new compound the Byteotian Institute of Experimental Physics has encountered a logisticalproblem - the transfer of its vast collection of precision weights turned out to be non-trivial.\n\nThe Institute has a certain number of containers of limited strength at its disposal. As many weightsas possible are to be put into the containers, the remaining ones will be discarded. There is no limit onthe number of weights to be put in a container apart from the requirement of not exceeding its strength. Acontainer may also be empty.\n\nAny two weights in the Institute have a peculiar property: the mass of one of them is an integer multipleof the mass of the other. Particularly, they may have the same mass.\n\nTaskWrite a programme which:\n\nreads the durabilities of the containers and masses of the weights from the standard input,        determines the maximal number of weights that can be put in the containers,        writes the outcome to the standard output.\n", "inputFormat": "The first line of the standard input contains two integers $n$ and $m$($1\\le n,m\\le 100\\ 000$), separated by a singlespace, denoting respectively: the number of containers and the number of weights. The second line of thestandard input consists of $n$ integers $w_i$ ($1\\le w_i\\le 1\\ 000\\ 000\\ 000$ for $1\\le i\\le n$), separated by single spaces,denoting the strengths of containers in milligrammes. In the third line there are $m$ integers $m_j$($1\\le m_j\\le 1\\ 000\\ 000\\ 000$) for $1\\le j\\le m$), separated by single spaces, denoting masses of the weights in milligrammes.\n", "outputFormat": "The first and only line of the standard output should contain a single integer -the maximal number ofweights that can be placed in the containers without exceeding their durability.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2007] ODW-Weights", "background": "", "description": "在搬迁到一个新的园区时，Byteotian 实验物理研究所遇到了一个后勤问题——转移其庞大的精密砝码收藏变得不那么简单。\n\n研究所有若干个强度有限的容器可供使用。需要尽可能多地将砝码放入容器中，剩下的将被丢弃。除了不超过容器的强度外，放入容器中的砝码数量没有限制。一个容器也可以是空的。\n\n研究所的任意两个砝码有一个特殊的性质：其中一个的质量是另一个质量的整数倍。特别地，它们可能具有相同的质量。\n\n任务编写一个程序：\n\n从标准输入中读取容器的强度和砝码的质量，确定可以放入容器中的最大砝码数量，将结果写入标准输出。\n", "inputFormat": "标准输入的第一行包含两个整数 $n$ 和 $m$（$1\\le n,m\\le 100\\ 000$），用单个空格分隔，分别表示容器的数量和砝码的数量。标准输入的第二行由 $n$ 个整数 $w_i$（$1\\le w_i\\le 1\\ 000\\ 000\\ 000$，$1\\le i\\le n$）组成，用单个空格分隔，表示容器的强度（单位：毫克）。第三行有 $m$ 个整数 $m_j$（$1\\le m_j\\le 1\\ 000\\ 000\\ 000$，$1\\le j\\le m$），用单个空格分隔，表示砝码的质量（单位：毫克）。\n", "outputFormat": "标准输出的第一行应包含一个整数——可以放入容器中的最大砝码数量，而不超过其强度。\n", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P3463", "type": "P", "difficulty": 5, "samples": [["4 3 5 2\n2 0 0\n2 2 1\n3 3 1\n1 1 1\n3 3 0", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2007", "POI（波兰）"], "title": "[POI 2007] EGZ-Driving Exam", "background": "", "description": "The Byteotian driving licence exam takes place in an area in which there are $n$ straight, parallel, unidirectional, north-oriented streets (that is the allowed driving direction is south to north). Each of the streets is exactly $m$ meters long, all of them begin and end on the same level. These streets are numbered from $1$ to $n$ starting the westernmost. There are also $p$ unidirectional, east or west-oriented streets perpendicular to the abovementioned, each one of them connecting a pair of adjacent north-oriented streets. It is also possible that an east-oriented and a west-oriented street overlap, thus forming a bidirectional one.\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/6981.png) \n\nAn exemplary testing area ($n=4, m=3, p=5$).\n\nThe examiner chooses a north-oriented street, at the beginnig of which the examination starts and anothernorth-oriented street, where it is to come to an end. The task of the applicant is to drive from the starting tothe final point, observing the allowed directions.The examiner always chooses as starting point a street, from which it is possible to drive to the endpointof any other north-oriented street.The work of the examiners is a very tedious one, because they always have to start at the beginning ofone of the few suitable streets. The board of directors have decided to build a new testing area on the basis ofpre-existent plans. It has been calculated, that available funds allow for no more than $k$ east or west-orientedstreets to be built. Those new streets are to be constructed in such a way, so as to add the largest possiblenumber of potential starting points (there may or may not exist starting points on the pre-existent plan). Newstreets have to connect pairs of adjacent north-oriented streets.\n\n## Task\n\nWrite a programme which:\n\n- reads a description of the testing area and the number $k$ from the standard input,\n\n- calculates the greatest number of potential new starting points for the examination, generated by adding no more than $k$ east or west-oriented streets,\n\n- writes the outcome to the standard output.\n", "inputFormat": "In the first line of the standard input there are four integers $n$, $m$, $p$ and $k$ ($2 \\le n \\le 100\\ 000$, $1 \\le m, k, \\le 100\\ 000$, $0 \\le p \\le 100\\ 000$), separated by single spaces, denoting respectively: the number of north-oriented streets, the length of each one of them, the number of pre-existent east or west-oriented streets, the maximal number of new streets to be built. The north-oriented streets are numbered from $1$ to $n$, starting with the westernmost.\n\n\nThe following $p$ lines contain three integers each: $n_i$, $m_i$ and $d_i$ ($1 \\le n_i \\le n$, $0 \\le m_i \\le m$, $d_i \\in \\{0, 1\\}$), separated by single spaces, denoting the 'th east-oriented (for $d_i=0$) or west-oriented (for $d_i=1$) street. This street connects north-oriented streets $n$ and $n+1$, intersecting them in points $m_i$ meters distant from their beginning.\n", "outputFormat": "The first and only line of the standard output should contain a single integer, denoting the maximal numberof new examination starting points generated by building no more than $k$ east or west-oriented streets. Thenewly built streets **do not have to** intersect the north-oriented streets in points, whose distance from thebeginning of the street is an integer. The newly built east or west-oriented streets may overlap, thus formingbidirectional streets.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2007] EGZ-Driving Exam", "background": "", "description": "The Byteotian driving licence exam takes place in an area in which there are $n$ straight, parallel, unidirectional, north-oriented streets (that is the allowed driving direction is south to north). Each of the streets is exactly $m$ meters long, all of them begin and end on the same level. These streets are numbered from $1$ to $n$ starting the westernmost. There are also $p$ unidirectional, east or west-oriented streets perpendicular to the abovementioned, each one of them connecting a pair of adjacent north-oriented streets. It is also possible that an east-oriented and a west-oriented street overlap, thus forming a bidirectional one.\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/6981.png) \n\nAn exemplary testing area ($n=4, m=3, p=5$).\n\nThe examiner chooses a north-oriented street, at the beginnig of which the examination starts and anothernorth-oriented street, where it is to come to an end. The task of the applicant is to drive from the starting tothe final point, observing the allowed directions.The examiner always chooses as starting point a street, from which it is possible to drive to the endpointof any other north-oriented street.The work of the examiners is a very tedious one, because they always have to start at the beginning ofone of the few suitable streets. The board of directors have decided to build a new testing area on the basis ofpre-existent plans. It has been calculated, that available funds allow for no more than $k$ east or west-orientedstreets to be built. Those new streets are to be constructed in such a way, so as to add the largest possiblenumber of potential starting points (there may or may not exist starting points on the pre-existent plan). Newstreets have to connect pairs of adjacent north-oriented streets.\n\n## Task\n\nWrite a programme which:\n\n- reads a description of the testing area and the number $k$ from the standard input,\n\n- calculates the greatest number of potential new starting points for the examination, generated by adding no more than $k$ east or west-oriented streets,\n\n- writes the outcome to the standard output.\n", "inputFormat": "In the first line of the standard input there are four integers $n$, $m$, $p$ and $k$ ($2 \\le n \\le 100\\ 000$, $1 \\le m, k, \\le 100\\ 000$, $0 \\le p \\le 100\\ 000$), separated by single spaces, denoting respectively: the number of north-oriented streets, the length of each one of them, the number of pre-existent east or west-oriented streets, the maximal number of new streets to be built. The north-oriented streets are numbered from $1$ to $n$, starting with the westernmost.\n\n\nThe following $p$ lines contain three integers each: $n_i$, $m_i$ and $d_i$ ($1 \\le n_i \\le n$, $0 \\le m_i \\le m$, $d_i \\in \\{0, 1\\}$), separated by single spaces, denoting the 'th east-oriented (for $d_i=0$) or west-oriented (for $d_i=1$) street. This street connects north-oriented streets $n$ and $n+1$, intersecting them in points $m_i$ meters distant from their beginning.\n", "outputFormat": "The first and only line of the standard output should contain a single integer, denoting the maximal numberof new examination starting points generated by building no more than $k$ east or west-oriented streets. Thenewly built streets **do not have to** intersect the north-oriented streets in points, whose distance from thebeginning of the street is an integer. The newly built east or west-oriented streets may overlap, thus formingbidirectional streets.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2007] EGZ-Driving Exam", "background": null, "description": "**译自 POI 2007 Stage 3. Day 2「[Egzamin na prawo jazdy](https://szkopul.edu.pl/problemset/problem/nLSrpyeJ1JnFGbBORYVVavIQ/site/?key=statement)」**\n\nByteotian 驾驶考试所在的区域有 $n$ 条互相平行的自南向北的道路，每条道路长为 $m$ 米，且在同一条水平线上开始、结束。另有 $p$ 条自东向西或自西向东的道路，连接两条相邻的自南向北的道路。注意可能有两条自东向西的道路和自西向东的道路重合，相当于一条双向道路。\n\n![](https://cdn.luogu.com.cn/upload/pic/6981.png)\n\n上图为 $n=4,m=3,p=5$ 的例子。\n\n考生可以选择一条自南向北的道路作为起始点，且从该道路开始必须能到达其它所有**自南向北**的道路。\n\n你需要添加至多 $k$ 条东西向的道路，使得满足条件的起始点最多。", "inputFormat": "第一行四个整数 $n,m,p,k$（$2 \\le n \\le 100\\ 000,1 \\le m,k \\le 100\\ 000,0 \\le p \\le 100\\ 000$），分别表示自南向北的道路数量、这些道路的长度、初始时已有的自东向西或自西向东的道路数量、可以添加的道路的数量。自南向北的道路从西向东编号为 $1 \\ldots n$。\n\n接下来 $p$ 行每行三个整数 $n_i, m_i, d_i (1 \\le n_i \\lt n,0 \\le m_i \\lt m,d_i \\in \\{0,1\\})$，表示一条连接第 $n_i$ 和 $n_i+1$ 条自南向北的道路、且距离起点 $m_i$ 米的东西向道路。$d_i = 0$ 时为向东的道路，$d_i = 1$ 时为向西的道路。", "outputFormat": "输出一行，表示**新产生**的起始点的最大数量。添加的东西向道路**不一定**要在整点和南北向道路相交。自东向西的道路和自西向东的可以重叠，相当于双向道路。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2661)。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3464", "type": "P", "difficulty": 6, "samples": [["166", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2007", "POI（波兰）", "进制"], "title": "[POI 2007] WAG-Quaternary Balance", "background": "", "description": "Byteasar the dragon intends to throw a party, to which he would like to invite many guests. Byteasar wouldalso like to present each guest with an amount of gold to honour the party. Each should receive the sameamount, so that no one's pride is hurt. The dragon is going to weigh out gold for subsequent guests with abeam balance. He has different types of standard masses at his disposal, each type weighing a certain powerof four. Conveniently, Byteasar has lots of the standard masses, hence he may use any number of masses ofany type (power of four) he finds appropriate. Byteasar will always lay the gold on the left weighing basinand the masses on the right or both weighing basins. The dragon wishes to use the least number of massespossible for each weighing. Furthermore, to entertain his guests, Byteasar would like to measure out the goldin unique manner for each person (ie. using different masses or distributing them among the weighing basinsin a different way).\n\nSince dragons' lack of arithmetic skills is legendary, Byteasar has aksed you to write a programme thatwill determine how many guests he may invite, that is, finds the maximum number of ways in which $n$ grammes of gold can be weighed out using the minimum number of masses possible. Should you fare well,you will also get your share!\n\nTaskWrite a programme that:\n\nreads from the standard input the amount of gold (in grammes) which Byteasar intends to present each    guest with,        calculates the number of ways in which this amount of gold can be weighed out using the minimum    number of masses possible,        writes out the remainder of dividing the result by $10^9$ to the standard output.\n\n给定一个数 $n$，要求将 $n$ 表示成一些 $4^k$ 的数之和/差的形式，要求用的数最少，求方案数模 $10^9$ 的结果。\n", "inputFormat": "In the first and only line of the standard input there is one positive integer $n$($1\\le n<10^{1000}$).\n\nIt is the amountof gold (in grammes) which Byteasar intends to present each guest with.\n", "outputFormat": "One integer should be written out to the standard output -the remainder of dividing by $10^9$ the maximumnumber of guests Byteasar can invite (that is, the maximum number of ways in which $n$ grammes of gold canbe weighed out using the minimum number of masses possible).\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2007] WAG-Quaternary Balance", "background": "", "description": "Byteasar the dragon plans to throw a party and give each guest the same amount of gold so that no one feels slighted. He will weigh the gold for each guest using a beam balance. He has standard masses whose weights are powers of four. Conveniently, he has an unlimited supply of each type of mass (each power of four). Byteasar will always place the gold on the left pan, and he may place masses on the right pan or on both pans. He wants to use the fewest masses possible for each weighing. Moreover, to entertain his guests, he would like to measure the gold in a unique way for each person (i.e., using different masses or distributing them between the pans differently).\n\nSince dragons are not known for arithmetic, Byteasar asks you to write a program to determine how many guests he can invite, i.e., the maximum number of ways to weigh out $n$ grams of gold using the minimum number of masses possible. You should output the result modulo $10^9$.\n\nIn other words, given a number $n$, express $n$ as a sum and/or difference of numbers of the form $4^k$, using the fewest terms, and count the number of such representations, modulo $10^9$.", "inputFormat": "The first and only line contains one positive integer $n$ ($1 \\le n < 10^{1000}$), the amount of gold in grams Byteasar intends to give each guest.", "outputFormat": "Print one integer: the remainder modulo $10^9$ of the maximum number of ways to weigh out $n$ grams using the minimum number of masses possible.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2007] WAG-Quaternary Balance", "background": "", "description": "Byteasar the dragon intends to throw a party, to which he would like to invite many guests. Byteasar wouldalso like to present each guest with an amount of gold to honour the party. Each should receive the sameamount, so that no one's pride is hurt. The dragon is going to weigh out gold for subsequent guests with abeam balance. He has different types of standard masses at his disposal, each type weighing a certain powerof four. Conveniently, Byteasar has lots of the standard masses, hence he may use any number of masses ofany type (power of four) he finds appropriate. Byteasar will always lay the gold on the left weighing basinand the masses on the right or both weighing basins. The dragon wishes to use the least number of massespossible for each weighing. Furthermore, to entertain his guests, Byteasar would like to measure out the goldin unique manner for each person (ie. using different masses or distributing them among the weighing basinsin a different way).\n\nSince dragons' lack of arithmetic skills is legendary, Byteasar has aksed you to write a programme thatwill determine how many guests he may invite, that is, finds the maximum number of ways in which $n$ grammes of gold can be weighed out using the minimum number of masses possible. Should you fare well,you will also get your share!\n\nTaskWrite a programme that:\n\nreads from the standard input the amount of gold (in grammes) which Byteasar intends to present each    guest with,        calculates the number of ways in which this amount of gold can be weighed out using the minimum    number of masses possible,        writes out the remainder of dividing the result by $10^9$ to the standard output.\n\n给定一个数 $n$，要求将 $n$ 表示成一些 $4^k$ 的数之和/差的形式，要求用的数最少，求方案数模 $10^9$ 的结果。\n", "inputFormat": "In the first and only line of the standard input there is one positive integer $n$($1\\le n<10^{1000}$).\n\nIt is the amountof gold (in grammes) which Byteasar intends to present each guest with.\n", "outputFormat": "One integer should be written out to the standard output -the remainder of dividing by $10^9$ the maximumnumber of guests Byteasar can invite (that is, the maximum number of ways in which $n$ grammes of gold canbe weighed out using the minimum number of masses possible).\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3465", "type": "P", "difficulty": 5, "samples": [["4 5\n1 2\n2 3\n1 3\n3 4\n1 4", "TAK\n3\n3\n4\n1"], ["4 3\n1 3\n3 4\n2 3", "NIE"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "并查集", "POI（波兰）", "Special Judge"], "title": "[POI 2008] CLO-Toll", "background": "", "description": "King Byteasar has yielded under pressure of Byteotian merchants and  hence decided to settle the issue of toll paid by them.\n\nByteotia consists of $n$ towns connected with $m$ bidirectional roads.\n\nEach road connects directly two different towns and no two towns are  connected by more than one direct road.\n\nNote that the roads may lead through tunnels or flyovers.\n\nUntil now each town in Byteotia imposed duty on everyone who  either entered or left the town.\n\nThe merchants, discontented with such situation, lodged a protest  against multiple taxation.\n\nKing Byteasar ruled that the town privileges are now restricted.\n\nAccording to the new royal edict, each town can only charge toll on  merchants travelling by exact one road leading into the town,  regardless of the direction they are travelling in.\n\nFurthermore, for each road, those who travel it cannot be made to pay  the duty to both towns the road connects.\n\nIt remains to determine which town should collect toll from which road.\n\nSolving this problem His Highness has commissioned to you.\n\n## Task\n\nWrite a programme that:\n\n- reads the Byteotian road system's description from the standard input,\n\n- for each town determines on which road it should impose toll, or claims it is impossible,\n\n- writes out the result to the standard output.\n", "inputFormat": "There are two integers in the first line of the standard input: $n$ and $m$ ($1 \\le n \\le 100\\ 000$, $1 \\le n \\le 200\\ 000$), denoting the number of towns and roads in Byteotia, respectively. The towns are numbered from $1$ to $n$. In next $m$ lines descriptions of the roads follow. In line No. $i$ there are two integers $a_i$ and $b_i$ () meaning that towns $a_i$ and $b_i$ are directly connected by a road.\n", "outputFormat": "If collecting the toll in accordance with the royal edict is impossible, your programme should write the word NIE ('no' in Polish) in the first and only line of the standard output. Otherwise, it should write the word TAK ('yes' in Polish) in the first line, while in the following $n$ lines should tell which city collects toll from which road. Line no. $(i+1)$ should tell on which road the town no. $i$ imposes toll. Since town no. $i$ is obviously one endpoint of this road, it is enough to tell what is the other endpoint. Thus if the town no. $i$ imposes toll on the road connecting it with the town no.$j$ , the line no. $(i+1)$ should contain the number $j$. If more than one solution exists, write out one chosen arbitrarily.\n", "hint": "样例1：\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/6984.png) \n\n样例2：\n\n![](https://cdn.luogu.com.cn/upload/pic/6985.png)\n", "locale": "en", "translations": {"en": {"title": "[POI 2008] CLO-Toll", "background": "", "description": "King Byteasar has yielded under pressure of Byteotian merchants and  hence decided to settle the issue of toll paid by them.\n\nByteotia consists of $n$ towns connected with $m$ bidirectional roads.\n\nEach road connects directly two different towns and no two towns are  connected by more than one direct road.\n\nNote that the roads may lead through tunnels or flyovers.\n\nUntil now each town in Byteotia imposed duty on everyone who  either entered or left the town.\n\nThe merchants, discontented with such situation, lodged a protest  against multiple taxation.\n\nKing Byteasar ruled that the town privileges are now restricted.\n\nAccording to the new royal edict, each town can only charge toll on  merchants travelling by exact one road leading into the town,  regardless of the direction they are travelling in.\n\nFurthermore, for each road, those who travel it cannot be made to pay  the duty to both towns the road connects.\n\nIt remains to determine which town should collect toll from which road.\n\nSolving this problem His Highness has commissioned to you.\n\n## Task\n\nWrite a programme that:\n\n- reads the Byteotian road system's description from the standard input,\n\n- for each town determines on which road it should impose toll, or claims it is impossible,\n\n- writes out the result to the standard output.\n", "inputFormat": "There are two integers in the first line of the standard input: $n$ and $m$ ($1 \\le n \\le 100\\ 000$, $1 \\le n \\le 200\\ 000$), denoting the number of towns and roads in Byteotia, respectively. The towns are numbered from $1$ to $n$. In next $m$ lines descriptions of the roads follow. In line No. $i$ there are two integers $a_i$ and $b_i$ () meaning that towns $a_i$ and $b_i$ are directly connected by a road.\n", "outputFormat": "If collecting the toll in accordance with the royal edict is impossible, your programme should write the word NIE ('no' in Polish) in the first and only line of the standard output. Otherwise, it should write the word TAK ('yes' in Polish) in the first line, while in the following $n$ lines should tell which city collects toll from which road. Line no. $(i+1)$ should tell on which road the town no. $i$ imposes toll. Since town no. $i$ is obviously one endpoint of this road, it is enough to tell what is the other endpoint. Thus if the town no. $i$ imposes toll on the road connecting it with the town no.$j$ , the line no. $(i+1)$ should contain the number $j$. If more than one solution exists, write out one chosen arbitrarily.\n", "hint": "样例1：\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/6984.png) \n\n样例2：\n\n![](https://cdn.luogu.com.cn/upload/pic/6985.png)\n", "locale": "en"}, "zh-CN": {"title": "[POI 2008] CLO-Toll", "background": "", "description": "给你 $n$ 个点和 $m$ 条双向边，问能否将其中的一些边改成有向边，使得只考虑有向边的情况下每个点的入度都为 $1$ 。", "inputFormat": "第一行输入 $n,m(1≤n≤100000,1≤m≤200000)$ ，接下来 $m$ 行每行两个数 $a,b$ 表示点 $a$ 和点 $b$ 之间有一条双向边。输入保证没有重边与自环。", "outputFormat": "若没有合法方案，输出 $\\verb!NIE!$，否则先在第一行输出 $\\verb!TAK!$，然后在第 $i+1$ 行输出点 $i$ 的入度是由哪个点出发的边所得到的。\n\n感谢@hdxrie 提供的翻译。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3466", "type": "P", "difficulty": 5, "samples": [["5 3\n3\n9\n2\n3\n1", "2\n3\n9\n2\n2\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "平衡树", "POI（波兰）", "Special Judge"], "title": "[POI 2008] KLO-Building blocks", "background": "", "description": "Byteasar loved to play with building blocks as a child.\n\nHe used to arrange the blocks into $n$ columns of random height  and then organize them in the following manner:\n\nByteasar would choose a number $k$ and try to arrange the blocks in such a way that  some $k$ consecutive columns would be of equal height. Furthermore he always tried to  achieve this goal in a minimum number of moves possible, where a single move consists in:\n\nlaying one block on top of any column      (Byteasar had a huge box with spare blocks, ensuring this move could always be performed),      or              removing the uppermost block from the top of any column.\n\nHowever, Byteasar was never quite sure if his sequence of moves was indeed optimal,  therefore he has asked you to write a programme that will help him solve the problem.\n\nTask    Write a programme that:\n\nreads the number $k$ along with the initial setup of the blocks from the standard input,determines the optimal solution (shortest possible sequence of moves),writes out the solution to the standard output.", "inputFormat": "In the first line of the standard input there are two integers, $n$ and $k$ ($1\\le k\\le n\\le 100\\ 000$), separated by a single space.\n\nEach of the following $n$ lines contains the height of some column;    the line no. $i+1$ contains the integer    $0\\le h_i\\le 1\\ 000\\ 000$ - the height of the $i^{th}$ column,    ie. the number of blocks it consists of.", "outputFormat": "The optimal solution should be written out to the standard output, ie. such arrangement    of blocks that:\n\ncontains $k$ consecutive columns of equal height,                  can be obtained from the initial setup in a minimum possible number of moves.\n\nThe output should consist of $n+1$ lines, each one containing a single integer.\n\nThe number in the first line should be the minimum number of moves needed to get    the desired arrangement.\n\nThe line no. $i+1$ (for $1\\le i\\le n$) should contain the number $h'_i$ -    the final height of the $i^{th}$ column.\n\nIf more than one optimal solution exists, write out one chosen arbitrarily.\n\n", "hint": "$1\\le k\\le n\\le 100\\ 000$，$0\\le h_i\\le 1\\ 000\\ 000$。", "locale": "en", "translations": {"en": {"title": "[POI 2008] KLO-Building blocks", "background": "", "description": "Byteasar loved to play with building blocks as a child.\n\nHe used to arrange the blocks into $n$ columns of random height  and then organize them in the following manner:\n\nByteasar would choose a number $k$ and try to arrange the blocks in such a way that  some $k$ consecutive columns would be of equal height. Furthermore he always tried to  achieve this goal in a minimum number of moves possible, where a single move consists in:\n\nlaying one block on top of any column      (Byteasar had a huge box with spare blocks, ensuring this move could always be performed),      or              removing the uppermost block from the top of any column.\n\nHowever, Byteasar was never quite sure if his sequence of moves was indeed optimal,  therefore he has asked you to write a programme that will help him solve the problem.\n\nTask    Write a programme that:\n\nreads the number $k$ along with the initial setup of the blocks from the standard input,determines the optimal solution (shortest possible sequence of moves),writes out the solution to the standard output.", "inputFormat": "In the first line of the standard input there are two integers, $n$ and $k$ ($1\\le k\\le n\\le 100\\ 000$), separated by a single space.\n\nEach of the following $n$ lines contains the height of some column;    the line no. $i+1$ contains the integer    $0\\le h_i\\le 1\\ 000\\ 000$ - the height of the $i^{th}$ column,    ie. the number of blocks it consists of.", "outputFormat": "The optimal solution should be written out to the standard output, ie. such arrangement    of blocks that:\n\ncontains $k$ consecutive columns of equal height,                  can be obtained from the initial setup in a minimum possible number of moves.\n\nThe output should consist of $n+1$ lines, each one containing a single integer.\n\nThe number in the first line should be the minimum number of moves needed to get    the desired arrangement.\n\nThe line no. $i+1$ (for $1\\le i\\le n$) should contain the number $h'_i$ -    the final height of the $i^{th}$ column.\n\nIf more than one optimal solution exists, write out one chosen arbitrarily.\n\n", "hint": "$1\\le k\\le n\\le 100\\ 000$，$0\\le h_i\\le 1\\ 000\\ 000$。", "locale": "en"}, "zh-CN": {"title": "[POI 2008] KLO-Building blocks", "background": null, "description": "有 $n$ 柱砖，每柱砖有一个高度，我们现在希望有连续 $k$ 柱的高度是一样的。\n\n你可以选择以下两个动作：\n\n1. 从某柱砖的顶端拿一块砖出来,丢掉不要了。\n2. 从仓库中拿出一块砖，放到某一柱，仓库是无限大的。\n\n现在希望用最小次数的动作完成任务，除此之外你还要求输出结束状态时，每柱砖的高度。", "inputFormat": "第一行两个用空格隔开的数表示 $n,k$。\n\n之后 $n$ 行，第 $i+1$ 行一个数表示第 $i$ 柱砖的高度 $h_i$。", "outputFormat": "输出 $n+1$ 行。\n\n第一行一个数表示最小化的答案。\n\n之后 $n$ 行，每行一个数表示结束后每柱砖的高度。", "hint": "本题 SPJ 的提示说明（按照 SPJ 判断顺序给出）：\n\n`Out of Range`：输出的数字不在答案可能的范围内。\n\n`Wrong Solution`：输出方案中不包含连续 $k$ 个相同高度的柱。\n\n`Wrong Result`：提交的程序的步数和输出方案的步数不相等。\n\n`Expected cost = a,found cost = b`：期望步数为 $a$，程序的步数为 $b$。\n\n`OK!Correct Answer!`：答案正确。\n\n$1 \\le k \\le n \\le 10^5$，$0 \\le h_i \\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P3467", "type": "P", "difficulty": 3, "samples": [["5\n1 2\n1 3\n2 2\n2 5\n1 4", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2008", "POI（波兰）", "单调栈"], "title": "[POI 2008] PLA-Postering", "background": "", "description": "All the buildings in the east district of Byteburg were built in accordance with the old arbitecture: they stand next to each other with no spacing inbetween. Together they form a very long chain of buildings of diverse    height, extending from east to west.\n\nThe mayor of Byteburg, Byteasar, has decided to have the north face of the chain covered with posters. Byteasar ponders over the minimum number of posters sufficient to    cover the whole north face. The posters have rectangular shape with vertical and horizontal sides. They cannot overlap, but may touch each other, i.e. have common points on the sides. Every poster has to entirely adjoin the walls of certain buildings and the whole surface of the north face has to be covered.\n\nTask Write a programme that:\n\n- reads the description of buildings from the standard input, \n- determines the minimum number of posters needed to entirely cover their north faces, \n- writes out the outcome to the standard output.\n", "inputFormat": "The first line of the standard input contains one integer $n$ ($1\\le n\\le 250\\ 000$), denoting the number of buildings the chain      comprises of.\n\nEach of the following $n$ lines contains two integers $d_i$ and $w_i$ ($1\\le d_i,w_i\\le 1\\ 000\\ 000\\ 000$),      separated by a single space, denoting respectively the length and height      of the $i^{th}$ building in the row.", "outputFormat": "The first and only line of the standard output should contain one integer,      the minimum number of rectangular posters that suffice to cover the north faces      of the buildings.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2008] PLA-Postering", "background": "", "description": "All the buildings in the east district of Byteburg were built in accordance with the old arbitecture: they stand next to each other with no spacing inbetween. Together they form a very long chain of buildings of diverse    height, extending from east to west.\n\nThe mayor of Byteburg, Byteasar, has decided to have the north face of the chain covered with posters. Byteasar ponders over the minimum number of posters sufficient to    cover the whole north face. The posters have rectangular shape with vertical and horizontal sides. They cannot overlap, but may touch each other, i.e. have common points on the sides. Every poster has to entirely adjoin the walls of certain buildings and the whole surface of the north face has to be covered.\n\nTask Write a programme that:\n\n- reads the description of buildings from the standard input, \n- determines the minimum number of posters needed to entirely cover their north faces, \n- writes out the outcome to the standard output.\n", "inputFormat": "The first line of the standard input contains one integer $n$ ($1\\le n\\le 250\\ 000$), denoting the number of buildings the chain      comprises of.\n\nEach of the following $n$ lines contains two integers $d_i$ and $w_i$ ($1\\le d_i,w_i\\le 1\\ 000\\ 000\\ 000$),      separated by a single space, denoting respectively the length and height      of the $i^{th}$ building in the row.", "outputFormat": "The first and only line of the standard output should contain one integer,      the minimum number of rectangular posters that suffice to cover the north faces      of the buildings.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2008] PLA-Postering", "background": null, "description": "Byteburg 城市的东区所有建筑都是按照旧式建筑风格建造的：它们一个接一个地紧挨在一起，中间没有任何间隔。它们从东到西排列，形成了一排高度各异的建筑长廊。\n\nByteburg 的市长 Byteasar 决定在这排建筑的北立面上张贴海报。他正在思考，要完全覆盖整个北立面，最少需要多少张矩形海报。这些海报的边是垂直或水平的矩形，不能重叠，但可以相接（即边缘可以重合）。每一张海报必须完全贴合某些建筑的墙面，且所有北立面必须被完全覆盖。\n\n你的任务是写一个程序，完成以下功能：\n\n- 从标准输入中读取建筑的描述，\n- 计算出最少需要多少张海报，才能完全覆盖建筑的北立面，\n- 将结果输出到标准输出。", "inputFormat": "标准输入的第一行包含一个整数 $n$（$1 \\le n \\le 2.5\\times10^5$），表示这一排建筑的数量。\n\n接下来的 $n$ 行中，每行包含两个整数 $d_i$ 和 $w_i$（$1 \\le d_i, w_i \\le 10^9$），分别表示第 $i$ 栋建筑的宽度和高度。", "outputFormat": "标准输出中输出一个整数，表示最少需要多少张矩形海报，才能完全覆盖建筑的北立面。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3468", "type": "P", "difficulty": 6, "samples": [["10\n..........\n..........\n..r.......\n.rrrX.....\nrrrrr.....\n.rrr......\nX.r.......\n.Xr.......\n..........\n..........", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "POI（波兰）"], "title": "[POI 2008] ROB-Robinson", "background": "", "description": "Tossed by the storm on a deserted island, Robinson built himself a boat    so that he could go out to the sea and seek out human domicile.\n\nHe is an experienced sailor, therefore he built the boat with accordance to the rules    of craftsmanship: it has a longitudinal axis of symmetry and an appropriate    shape. The boat's prow is thin, and it widens gradually towards the boat's centre,    only to gradually narrow once again towards the stern.\n\nIn particular, at some point in the middle the boat is wider than both at the    prow and stern.\n\nUnfortunately, Robinson has launched his boat in a most improper space: there    is extremely thick reed all around. It is, moreover, so stiff that the boat    cannot break through. Perhaps Robinson can get to the high seas by carefully    manoeuvring between the reed.\n\nDue to lack of manoeuvrability, the boat can move forward and backward and    even sidewards (leftward or rightward), but it cannot turn.\n\nIt is thus allowed, and may be in fact necessary, that the boat moves with    its stern or broadside to the front.\n\nYou are to judge if Robinson can get to the high seas.\n\nTo make your task easier the island and its surroundings will be    represented by a square map divided into square unit fields, each    occupied by either water, part of Robinson's boat or an obstacle, eg.\n\nland or reed. Initially the boat is set parallel to one of the cardinal    directions, ie. its longitudinal axis of symmetry is parallel to this    direction and the axis bisects the unit fields it is covered with.\n\nWe assume that the high seas starts where the map ends.\n\nHence Robinson may get to the high seas if his boat can leave    the area depicted in the map.\n\nA single move consists in moving the boat to a side-adjacent    field in a chosen direction (north, south, east or west).\n\nThe move is permissible if both before and after it the boat    remains entirely in water (it does not occupy a field with an    obstacle).\n\nTask      You are to write a programme that                        reads the map's description from the standard input,                      calculates the minimum possible number of boat's moves that          suffice to completely leave the area depicted in the map,                      writes out this number to the standard output.\n\n被风暴抛弃在荒岛上的鲁滨逊（又译鲁滨孙）自己造了一条船，这样他就可以出海去寻找有人类居住的地方。\n\n他是一位经验丰富的水手，因此他根据技术规程建造了它。它有一条纵向的对称轴，以及适于航行的外形：船头较尖，向船中逐渐扩宽，到船尾又逐渐收窄。\n\n特别的是，船中的一些点比船头和船尾都宽。\n\n可是很不幸，鲁滨逊在最不合适的位置让他的船下了水：周围有极其厚的芦苇。此外，这条船太僵硬以至于它无法突破芦苇。不过或许鲁滨逊可以通过在芦苇中小心翼翼地操纵船去往公海。\n\n由于船太不灵活，船可以前进、后退甚至横着（向左或向右）移动，但它不能掉头。\n\n允许船的船尾或者船舷在前进行移动，事实上这可能是必要的。\n\n你需要判断鲁滨逊是否可以到达公海。\n\n为了简化你的工作，岛屿和周围的环境将由一张划分成方格的正方形地图表示，每格只可能是水、鲁滨逊船的一部分或障碍物（比如说岛屿和芦苇）。最初船平行于一个主要方向（换句话说，即其纵向对称轴平行于此方向且其平分其覆盖的方格）\n\n我们假定地图之外就是公海。\n\n因此，如果他的船可以离开地图描绘的区域，鲁滨逊也许就能到达公海了。\n\n一步表现为船往选定的方向（北，南，东或西）移动一格。\n\n如果移动前后的船保持整个在水中（不占据任何有障碍物的格子），那么这个移动是合法的。\n\n你的任务是编写一个程序，从标准输入中读取地图的描述，计算船离开地图描述的区域的最少步数，并输出至标准输出。\n", "inputFormat": "The first line contains one integer $3\\le n\\le 2000$, denoting the length of the map's side.\n\nIn each of the following $n$ lines there are $n$ characters      describing successive fields of the map:\n\n$i^{th}$ character in the $(j+1)^{th}$ line tells the contents      of the field $(i,j)$.\n\nThe following characters may appear there:\n\n\".\" - (dot) denotes a field filled with water,             \"X\" - denotes an obstacle (land or reed),             \"r\" - denotes a part of Robinson's boat.\n第一行一个正整数 $$3\\le_n\\le_2000$,$ 表示地图的边长。\n\n接下来 $n$ 行每行 $n$ 个字符表示地图：（此处省略两张图片）第 $(j+1)$ 行的的第 $i$ 个字符表示方格 $(i,j)$。以下的字符可能会在输入中出现：`.`表示一格水，`X` 表示一格障碍物（岛屿或芦苇），`R` 表示鲁滨孙的船的一部分。\n", "outputFormat": "Your programme should write out (in the first and only line of      the standard output) a single positive integer, equal to      the minimum number of boat's moves that suffice to completely      leave the area depicted in the map.\n\nShould getting to the high seas be impossible, write out the word      'NIE' ('no' in Polish).\n\n你的程序应当输出（在标准输出的第一行且仅有一行）一格正整数表示鲁滨逊的船完全离开地图标示的区域需要的最小步数。\n\n如果鲁宾逊无法到达公海，输出一行 `NIE`（波兰语中否定的意思）\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2008] ROB-Robinson", "background": "", "description": "Tossed by a storm onto a deserted island, Robinson built himself a boat so that he could go out to sea and look for human habitation.\n\nHe is an experienced sailor, so he built the boat according to the rules of craftsmanship: it has a longitudinal axis of symmetry and an appropriate shape. The prow is thin, the hull widens gradually toward the middle, and then it narrows again toward the stern. In particular, at some point in the middle the boat is wider than both at the prow and at the stern.\n\nUnfortunately, Robinson launched his boat in the worst possible place: there is extremely thick reed all around. Moreover, it is so stiff that the boat cannot break through. Perhaps Robinson can reach the high seas by carefully maneuvering between the reeds.\n\nBecause the boat is not very maneuverable, it can move forward, backward, and even sideways (left or right), but it cannot turn. It is therefore allowed—and may even be necessary—for the boat to move with its stern or with its broadside leading.\n\nYou are to determine whether Robinson can reach the high seas.\n\nTo make the task precise, the island and its surroundings are represented by a square map divided into unit square cells. Each cell is either water, a part of Robinson’s boat, or an obstacle (e.g., land or reed). Initially, the boat is aligned with one of the cardinal directions, that is, its longitudinal symmetry axis is parallel to that direction and bisects the unit cells it covers.\n\nWe assume that the high seas begin beyond the edge of the map. Hence, Robinson can reach the high seas if his boat can completely leave the area depicted on the map.\n\nA single move consists of shifting the boat by one cell in one of the four directions: north, south, east, or west. A move is permissible if both before and after the move the boat is entirely on water (i.e., it does not occupy any cell with an obstacle).\n\nTask: Write a program that reads the map from standard input, computes the minimum number of moves needed for the boat to completely leave the map, and writes this number to standard output.", "inputFormat": "- The first line contains a single integer $n$ with $3 \\le n \\le 2000$, denoting the side length of the map.\n\n- Each of the following $n$ lines contains $n$ characters describing the map. The $i^{\\text{th}}$ character in the $(j+1)^{\\text{th}}$ line describes cell $(i, j)$. The characters are:\n  - \".\" a cell of water,\n  - \"X\" an obstacle (land or reed),\n  - \"r\" a part of Robinson’s boat.", "outputFormat": "Output a single positive integer: the minimum number of moves needed for the boat to completely leave the map. If it is impossible to reach the high seas, output NIE.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2008] ROB-Robinson", "background": "", "description": "Tossed by the storm on a deserted island, Robinson built himself a boat    so that he could go out to the sea and seek out human domicile.\n\nHe is an experienced sailor, therefore he built the boat with accordance to the rules    of craftsmanship: it has a longitudinal axis of symmetry and an appropriate    shape. The boat's prow is thin, and it widens gradually towards the boat's centre,    only to gradually narrow once again towards the stern.\n\nIn particular, at some point in the middle the boat is wider than both at the    prow and stern.\n\nUnfortunately, Robinson has launched his boat in a most improper space: there    is extremely thick reed all around. It is, moreover, so stiff that the boat    cannot break through. Perhaps Robinson can get to the high seas by carefully    manoeuvring between the reed.\n\nDue to lack of manoeuvrability, the boat can move forward and backward and    even sidewards (leftward or rightward), but it cannot turn.\n\nIt is thus allowed, and may be in fact necessary, that the boat moves with    its stern or broadside to the front.\n\nYou are to judge if Robinson can get to the high seas.\n\nTo make your task easier the island and its surroundings will be    represented by a square map divided into square unit fields, each    occupied by either water, part of Robinson's boat or an obstacle, eg.\n\nland or reed. Initially the boat is set parallel to one of the cardinal    directions, ie. its longitudinal axis of symmetry is parallel to this    direction and the axis bisects the unit fields it is covered with.\n\nWe assume that the high seas starts where the map ends.\n\nHence Robinson may get to the high seas if his boat can leave    the area depicted in the map.\n\nA single move consists in moving the boat to a side-adjacent    field in a chosen direction (north, south, east or west).\n\nThe move is permissible if both before and after it the boat    remains entirely in water (it does not occupy a field with an    obstacle).\n\nTask      You are to write a programme that                        reads the map's description from the standard input,                      calculates the minimum possible number of boat's moves that          suffice to completely leave the area depicted in the map,                      writes out this number to the standard output.\n\n被风暴抛弃在荒岛上的鲁滨逊（又译鲁滨孙）自己造了一条船，这样他就可以出海去寻找有人类居住的地方。\n\n他是一位经验丰富的水手，因此他根据技术规程建造了它。它有一条纵向的对称轴，以及适于航行的外形：船头较尖，向船中逐渐扩宽，到船尾又逐渐收窄。\n\n特别的是，船中的一些点比船头和船尾都宽。\n\n可是很不幸，鲁滨逊在最不合适的位置让他的船下了水：周围有极其厚的芦苇。此外，这条船太僵硬以至于它无法突破芦苇。不过或许鲁滨逊可以通过在芦苇中小心翼翼地操纵船去往公海。\n\n由于船太不灵活，船可以前进、后退甚至横着（向左或向右）移动，但它不能掉头。\n\n允许船的船尾或者船舷在前进行移动，事实上这可能是必要的。\n\n你需要判断鲁滨逊是否可以到达公海。\n\n为了简化你的工作，岛屿和周围的环境将由一张划分成方格的正方形地图表示，每格只可能是水、鲁滨逊船的一部分或障碍物（比如说岛屿和芦苇）。最初船平行于一个主要方向（换句话说，即其纵向对称轴平行于此方向且其平分其覆盖的方格）\n\n我们假定地图之外就是公海。\n\n因此，如果他的船可以离开地图描绘的区域，鲁滨逊也许就能到达公海了。\n\n一步表现为船往选定的方向（北，南，东或西）移动一格。\n\n如果移动前后的船保持整个在水中（不占据任何有障碍物的格子），那么这个移动是合法的。\n\n你的任务是编写一个程序，从标准输入中读取地图的描述，计算船离开地图描述的区域的最少步数，并输出至标准输出。\n", "inputFormat": "The first line contains one integer $3\\le n\\le 2000$, denoting the length of the map's side.\n\nIn each of the following $n$ lines there are $n$ characters      describing successive fields of the map:\n\n$i^{th}$ character in the $(j+1)^{th}$ line tells the contents      of the field $(i,j)$.\n\nThe following characters may appear there:\n\n\".\" - (dot) denotes a field filled with water,             \"X\" - denotes an obstacle (land or reed),             \"r\" - denotes a part of Robinson's boat.\n第一行一个正整数 $$3\\le_n\\le_2000$,$ 表示地图的边长。\n\n接下来 $n$ 行每行 $n$ 个字符表示地图：（此处省略两张图片）第 $(j+1)$ 行的的第 $i$ 个字符表示方格 $(i,j)$。以下的字符可能会在输入中出现：`.`表示一格水，`X` 表示一格障碍物（岛屿或芦苇），`R` 表示鲁滨孙的船的一部分。\n", "outputFormat": "Your programme should write out (in the first and only line of      the standard output) a single positive integer, equal to      the minimum number of boat's moves that suffice to completely      leave the area depicted in the map.\n\nShould getting to the high seas be impossible, write out the word      'NIE' ('no' in Polish).\n\n你的程序应当输出（在标准输出的第一行且仅有一行）一格正整数表示鲁滨逊的船完全离开地图标示的区域需要的最小步数。\n\n如果鲁宾逊无法到达公海，输出一行 `NIE`（波兰语中否定的意思）\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3469", "type": "P", "difficulty": 5, "samples": [["5 5\n1 2\n2 3\n1 3\n3 4\n4 5\n", "8\n8\n16\n14\n8\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "POI（波兰）", "Tarjan", "双连通分量"], "title": "[POI 2008] BLO-Blockade", "background": "", "description": "There are exactly $n$ towns in Byteotia.\n\nSome towns are connected by bidirectional roads.\n\nThere are no crossroads outside towns, though there may be bridges,    tunnels and flyovers. Each pair of towns may be connected by at most    one direct road. One can get from any town to any other-directly    or indirectly.\n\nEach town has exactly one citizen.\n\nFor that reason the citizens suffer from loneliness.\n\nIt turns out that each citizen would like to pay a visit to    every other citizen (in his host's hometown), and do it    exactly once. So exactly $n\\cdot (n-1)$ visits should take place.\n\nThat's right, should.\n\nUnfortunately, a general strike of programmers, who    demand an emergency purchase of software, is under way.\n\nAs an act of protest, the programmers plan to block one town of    Byteotia, preventing entering it, leaving it, and even passing through.\n\nAs we speak, they are debating which town to choose so that    the consequences are most severe.\n\nTask    Write a programme that:\n\nreads the Byteotian road system's description from the            standard input,           for each town determines, how many visits could take place            if this town were not blocked by programmers,           writes out the outcome to the standard output.\n\n", "inputFormat": "In the first line of the standard input there are two positive    integers: $n$ and $m$ ($1\\le n\\le 100\\ 000$, $1\\le m\\le 500\\ 000$) denoting the number of towns and roads, respectively.\n\nThe towns are numbered from 1 to $n$.\n\nThe following $m$ lines contain descriptions of the roads.\n\nEach line contains two integers $a$ and $b$ ($1\\le a<b\\le n$) and    denotes a direct road between towns numbered $a$ and $b$.\n", "outputFormat": "Your programme should write out exactly $n$ integers to the standard    output, one number per line. The $i^{th}$ line should contain the number    of visits that could not take place if the programmers blocked the town    no. $i$.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2008] BLO-Blockade", "background": "", "description": "There are exactly $n$ towns in Byteotia.\n\nSome towns are connected by bidirectional roads.\n\nThere are no crossroads outside towns, though there may be bridges,    tunnels and flyovers. Each pair of towns may be connected by at most    one direct road. One can get from any town to any other-directly    or indirectly.\n\nEach town has exactly one citizen.\n\nFor that reason the citizens suffer from loneliness.\n\nIt turns out that each citizen would like to pay a visit to    every other citizen (in his host's hometown), and do it    exactly once. So exactly $n\\cdot (n-1)$ visits should take place.\n\nThat's right, should.\n\nUnfortunately, a general strike of programmers, who    demand an emergency purchase of software, is under way.\n\nAs an act of protest, the programmers plan to block one town of    Byteotia, preventing entering it, leaving it, and even passing through.\n\nAs we speak, they are debating which town to choose so that    the consequences are most severe.\n\nTask    Write a programme that:\n\nreads the Byteotian road system's description from the            standard input,           for each town determines, how many visits could take place            if this town were not blocked by programmers,           writes out the outcome to the standard output.\n\n", "inputFormat": "In the first line of the standard input there are two positive    integers: $n$ and $m$ ($1\\le n\\le 100\\ 000$, $1\\le m\\le 500\\ 000$) denoting the number of towns and roads, respectively.\n\nThe towns are numbered from 1 to $n$.\n\nThe following $m$ lines contain descriptions of the roads.\n\nEach line contains two integers $a$ and $b$ ($1\\le a<b\\le n$) and    denotes a direct road between towns numbered $a$ and $b$.\n", "outputFormat": "Your programme should write out exactly $n$ integers to the standard    output, one number per line. The $i^{th}$ line should contain the number    of visits that could not take place if the programmers blocked the town    no. $i$.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2008] BLO-Blockade", "background": null, "description": "B 城有 $n$ 个城镇（从 $1$ 到 $n$ 标号）和 $m$ 条双向道路。\n\n每条道路连结两个不同的城镇，没有重复的道路，所有城镇连通。\n\n\n把城镇看作节点，把道路看作边，容易发现，整个城市构成了一个无向图。\n\n请你对于每个节点 $i$ 求出，把与节点 $i$ 关联的所有边去掉以后（不去掉节点 $i$ 本身），无向图有多少个有序点对 $(x,y)$，满足 $x$ 和 $y$ 不连通。\n\n注：这里的“有序点对”可以理解为 $(x,y)$ 和 $(y,x)$ 不相同 $(x\\neq y)$。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$。\n\n接下来 $m$ 行，每行包含两个整数 $a$ 和 $b$，表示城镇 $a$ 和 $b$ 之间存在一条道路。", "outputFormat": "输出共 $n$ 行，每行输出一个整数。\n\n第 $i$ 行输出的整数表示把与节点 $i$ 关联的所有边去掉以后（不去掉节点 $i$ 本身），无向图有多少个有序点对 $(x,y)$，满足 $x$ 和 $y$ 不连通。", "hint": "$n\\le 10^5$，$m\\le5\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P3470", "type": "P", "difficulty": 5, "samples": [["9 2 3 2 1\n---++++++\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "单调队列", "POI（波兰）"], "title": "[POI 2008] BBB-BBB", "background": "", "description": "Byteasar has an account at The Byteotian Bit Bank (BBB in short).\n\nAt the beginning there were $p$ and at the end $q$ bythalers in the account.\n\nEach transaction was either a deposit or a withdrawal of one bythaler.\n\nThe account's balance was never negative.\n\nA bank teller has prepared a bank statement: a strip of paper with a sequence of pluses and minuses in it   (a plus denotes a deposit while minus a withdrawal of one bythaler).\n\nSoon it turned out, that some transactions were not entered correctly.\n\nThe bank teller cannot print another statement, but has to correct the   one already printed instead.\n\nThe statement needs not be consistent with the truth, it will suffice if the sequence of transactions satisfies the following two conditions:\n\nthe final balance is consistent with the initial balance and the sequence of transactions in the statement, according to the sequence of transactions in the statement, the account's balance was never negative.\n\nYou are to calculate the minimum amount of time the bank teller needs to   correct the bank statement.\n\nThe bank teller can:\n\n- in $x$ seconds turn an arbitrarily chosen transaction to its opposite, or \n- in $y$ seconds remove the last transaction and put it at the beginning of the statement.\n\nIf, for example, $p=2,q=3$, then `--++-+-++-+-+` is a correct   statement.\n\nOn the other hand the statement `---++++++` is incorrect, because the account's balance would become negative after the third transaction, and furthermore the final balance should be 3, not 5.\n\nIt can be, however, corrected by turning the second to last symbol to its opposite and placing the last transaction at the beginning of the statement.\n\n### Task\n\nWrite a programme that:\n\n- reads the current bank statement for Byteasar's account (a sequence of pluses and minuses) as well as the numbers $p,q,x$ and $y$ from the standard input.\n- writes out to the standard output the minimum number of seconds needed to correct the statement in a way such that the initial and final balance are consistent and that the balance is never negative.\n", "inputFormat": "The first line contains 5 integers $n,p,q,x$ and $y\\ (1\\le n\\le 1\\ 000\\ 000$, $0\\le p,q\\le 1\\ 000\\ 000$, $1\\le x,y\\le 1000$), separated by single spaces and denoting respectively:\n\nthe number of transactions done by Byteasar, initial and final account     balance and the number of seconds needed to perform a single turn     (change of sign) and move of transaction to the beginning.\n\nThe second line contains a sequence of ![](http://main.edu.pl/images/OI15/bbb-en-tex.18.png) signs (each a plus     or a minus), with no spaces in-between.\n", "outputFormat": "The first and last output line should contain one integer,     the minimum number of seconds needed to correct the statement. If no     corrections are necessary, the number is zero.\n\nYou may assume that a proper sequence of modifications exists for each     test data.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2008] BBB-BBB", "background": "", "description": "Byteasar has an account at The Byteotian Bit Bank (BBB in short).\n\nAt the beginning there were $p$ and at the end $q$ bythalers in the account.\n\nEach transaction was either a deposit or a withdrawal of one bythaler.\n\nThe account's balance was never negative.\n\nA bank teller has prepared a bank statement: a strip of paper with a sequence of pluses and minuses in it   (a plus denotes a deposit while minus a withdrawal of one bythaler).\n\nSoon it turned out, that some transactions were not entered correctly.\n\nThe bank teller cannot print another statement, but has to correct the   one already printed instead.\n\nThe statement needs not be consistent with the truth, it will suffice if the sequence of transactions satisfies the following two conditions:\n\nthe final balance is consistent with the initial balance and the sequence of transactions in the statement, according to the sequence of transactions in the statement, the account's balance was never negative.\n\nYou are to calculate the minimum amount of time the bank teller needs to   correct the bank statement.\n\nThe bank teller can:\n\n- in $x$ seconds turn an arbitrarily chosen transaction to its opposite, or \n- in $y$ seconds remove the last transaction and put it at the beginning of the statement.\n\nIf, for example, $p=2,q=3$, then `--++-+-++-+-+` is a correct   statement.\n\nOn the other hand the statement `---++++++` is incorrect, because the account's balance would become negative after the third transaction, and furthermore the final balance should be 3, not 5.\n\nIt can be, however, corrected by turning the second to last symbol to its opposite and placing the last transaction at the beginning of the statement.\n\n### Task\n\nWrite a programme that:\n\n- reads the current bank statement for Byteasar's account (a sequence of pluses and minuses) as well as the numbers $p,q,x$ and $y$ from the standard input.\n- writes out to the standard output the minimum number of seconds needed to correct the statement in a way such that the initial and final balance are consistent and that the balance is never negative.\n", "inputFormat": "The first line contains 5 integers $n,p,q,x$ and $y\\ (1\\le n\\le 1\\ 000\\ 000$, $0\\le p,q\\le 1\\ 000\\ 000$, $1\\le x,y\\le 1000$), separated by single spaces and denoting respectively:\n\nthe number of transactions done by Byteasar, initial and final account     balance and the number of seconds needed to perform a single turn     (change of sign) and move of transaction to the beginning.\n\nThe second line contains a sequence of ![](http://main.edu.pl/images/OI15/bbb-en-tex.18.png) signs (each a plus     or a minus), with no spaces in-between.\n", "outputFormat": "The first and last output line should contain one integer,     the minimum number of seconds needed to correct the statement. If no     corrections are necessary, the number is zero.\n\nYou may assume that a proper sequence of modifications exists for each     test data.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2008] BBB-BBB", "background": "", "description": "Byteasar 在 Byteotian Bit Bank（简称 BBB）有一个账户。  一开始账户里有 $p$ 个 bythaler，最后有 $q$ 个 bythaler。  每笔交易要么是存入一个 bythaler，要么是取出一个 bythaler。  账户余额从未为负。  一位银行柜员准备了一份银行对账单：一条纸带，上面有一系列的加号和减号（加号表示存入一个 bythaler，减号表示取出一个 bythaler）。  很快发现，有些交易记录不正确。  银行柜员不能打印另一份对账单，但必须修改已经打印的那一份。  对账单不必与事实一致，只要交易序列满足以下两个条件即可：  最终余额与初始余额和对账单中的交易序列一致，根据对账单中的交易序列，账户余额从未为负。  你需要计算银行柜员需要多少最少时间来修正对账单。  银行柜员可以：  - 在 $x$ 秒内将任意选择的交易变为其相反的交易，或者 - 在 $y$ 秒内将最后一笔交易移到对账单的开头。  例如，如果 $p=2,q=3$，那么 `--++-+-++-+-+` 是一个正确的对账单。  另一方面，对账单 `---++++++` 是不正确的，因为账户余额在第三笔交易后会变为负数，而且最终余额应该是 3，而不是 5。  然而，可以通过将倒数第二个符号变为其相反的符号，并将最后一笔交易移到对账单的开头来修正。  ### 任务  编写一个程序：  - 从标准输入中读取 Byteasar 账户的当前对账单（一个加号和减号的序列）以及数字 $p,q,x$ 和 $y$。 - 输出修正对账单所需的最少秒数，使得初始和最终余额一致，并且余额从未为负。 ", "inputFormat": "第一行包含 5 个整数 $n,p,q,x$ 和 $y\\ (1\\le n\\le 1\\ 000\\ 000$, $0\\le p,q\\le 1\\ 000\\ 000$, $1\\le x,y\\le 1000$)，用单个空格分隔，分别表示：  Byteasar 进行的交易数量、初始和最终账户余额、执行一次符号变更和将交易移到开头所需的秒数。  第二行包含一系列符号（每个是加号或减号），中间没有空格。 ", "outputFormat": "输出的第一行和最后一行应包含一个整数，即修正对账单所需的最少秒数。如果不需要修正，则为零。  你可以假设每个测试数据都有一个适当的修改序列。 ", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
