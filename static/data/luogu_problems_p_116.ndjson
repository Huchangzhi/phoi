{"pid": "P3349", "type": "P", "difficulty": 6, "samples": [["4 3\n1 2\n1 3\n1 4\n4 1\n4 2\n4 3", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2016", "各省省选", "浙江", "枚举", "树形 DP", "容斥原理", "状压 DP"], "title": "[ZJOI2016] 小星星", "background": "", "description": "小 Y 是一个心灵手巧的女孩子，她喜欢手工制作一些小饰品。她有 $n$ 颗小星星，用 $m$ 条彩色的细线串了起来，每条细线连着两颗小星星。\n\n有一天她发现，她的饰品被破坏了，很多细线都被拆掉了。这个饰品只剩下了 $n-1$ 条细线，但通过这些细线，这颗小星星还是被串在一起，也就是这些小星星通过这些细线形成了树。小 Y 找到了这个饰品的设计图纸，她想知道现在饰品中的小星星对应着原来图纸上的哪些小星星。如果现在饰品中两颗小星星有细线相连，那么要求对应的小星星原来的图纸上也有细线相连。小 Y 想知道有多少种可能的对应方式。\n\n只有你告诉了她正确的答案，她才会把小饰品做为礼物送给你呢。\n", "inputFormat": "第一行包含 $2$ 个正整数 $n,m$，表示原来的饰品中小星星的个数和细线的条数。\n\n接下来 $m$ 行，每行包含 $2$ 个正整数 $u,v$，表示原来的饰品中小星星 $u$ 和 $v$ 通过细线连了起来。这里的小星星从 $1$ 开始标号。保证 $u\\neq v$，且每对小星星之间最多只有一条细线相连。\n\n接下来 $n-1$ 行，每行包含 $2$ 个正整数 $u,v$，表示现在的饰品中小星星 $u$ 和 $v$ 通过细线连了起来。保证这些小星星通过细线可以串在一起。", "outputFormat": "输出共 $1$ 行，包含一个整数表示可能的对应方式的数量。\n\n如果不存在可行的对应方式则输出 `0`。", "hint": "对于 $100\\%$ 的数据，$n\\leq 17$，$m\\leq \\frac 12n(n-1)$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2016] Little Stars", "background": "", "description": "Xiao Y is a skillful girl who likes making small handmade accessories. She has $n$ little stars, strung together by $m$ colored thin threads, and each thread connects two stars.\n\nOne day she found that her accessory had been damaged, and many threads were removed. The accessory now has only $n-1$ threads, but through these threads, the stars are still strung together; that is, these stars form a tree through these threads. Xiao Y found the design blueprint and wants to know which original stars on the blueprint correspond to the current stars in the accessory. If two stars are connected by a thread in the current accessory, then the corresponding stars must also be connected by a thread on the original blueprint. Xiao Y wants to know how many possible correspondences there are.\n\nOnly if you tell her the correct answer will she give you the accessory as a gift.", "inputFormat": "The first line contains $2$ positive integers $n, m$, representing the number of stars and the number of threads in the original accessory.\n\nThe next $m$ lines each contain $2$ positive integers $u, v$, indicating that in the original accessory, stars $u$ and $v$ are connected by a thread. The stars are numbered starting from $1$. It is guaranteed that $u\\neq v$, and there is at most one thread between each pair of stars.\n\nThe next $n-1$ lines each contain $2$ positive integers $u, v$, indicating that in the current accessory, stars $u$ and $v$ are connected by a thread. It is guaranteed that these stars are connected through the threads.", "outputFormat": "Output a single line containing one integer, the number of possible correspondences.\n\nIf no feasible correspondence exists, output `0`.", "hint": "For $100\\%$ of the testdata, $n\\leq 17$, $m\\leq \\frac 12n(n-1)$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2016] 小星星", "background": "", "description": "小 Y 是一个心灵手巧的女孩子，她喜欢手工制作一些小饰品。她有 $n$ 颗小星星，用 $m$ 条彩色的细线串了起来，每条细线连着两颗小星星。\n\n有一天她发现，她的饰品被破坏了，很多细线都被拆掉了。这个饰品只剩下了 $n-1$ 条细线，但通过这些细线，这颗小星星还是被串在一起，也就是这些小星星通过这些细线形成了树。小 Y 找到了这个饰品的设计图纸，她想知道现在饰品中的小星星对应着原来图纸上的哪些小星星。如果现在饰品中两颗小星星有细线相连，那么要求对应的小星星原来的图纸上也有细线相连。小 Y 想知道有多少种可能的对应方式。\n\n只有你告诉了她正确的答案，她才会把小饰品做为礼物送给你呢。\n", "inputFormat": "第一行包含 $2$ 个正整数 $n,m$，表示原来的饰品中小星星的个数和细线的条数。\n\n接下来 $m$ 行，每行包含 $2$ 个正整数 $u,v$，表示原来的饰品中小星星 $u$ 和 $v$ 通过细线连了起来。这里的小星星从 $1$ 开始标号。保证 $u\\neq v$，且每对小星星之间最多只有一条细线相连。\n\n接下来 $n-1$ 行，每行包含 $2$ 个正整数 $u,v$，表示现在的饰品中小星星 $u$ 和 $v$ 通过细线连了起来。保证这些小星星通过细线可以串在一起。", "outputFormat": "输出共 $1$ 行，包含一个整数表示可能的对应方式的数量。\n\n如果不存在可行的对应方式则输出 `0`。", "hint": "对于 $100\\%$ 的数据，$n\\leq 17$，$m\\leq \\frac 12n(n-1)$。", "locale": "zh-CN"}}}
{"pid": "P3350", "type": "P", "difficulty": 6, "samples": [["2 2\n2\n3\n6 4\n2\n1 1 2 2\n1 2 2 1", "6\r\n7"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "各省省选", "递归", "浙江", "分治", "最短路"], "title": "[ZJOI2016] 旅行者", "background": "", "description": "小 Y 来到了一个新的城市旅行。她发现了这个城市的布局是网格状的，也就是有  $n$ 条从东到西的道路和  $m$ 条从南到北的道路，这些道路两两相交形成  $n\\times m$ 个路口  $(i,j)$，  $(1\\leq i\\leq n,1\\leq j\\leq m)$  \n\n她发现不同的道路路况不同，所以通过不同的路口需要不同的时间。通过调查发现，从路口  $(i,j)$ 到路口  $(i,j+1)$ 需要时间  $r(i,j)$ ，从路口  $(i,j)$ 到路口  $(i+1,j)$ 需要时间  $c(i,j)$ 。注意这里的道路是双向的。小 Y 有  $q$ 个询问，她想知道从路口  $(x1,y1)$ 到路口  $(x2,y2)$ 最少需要花多少时间。", "inputFormat": "第一行包含 2 个正整数  $n,m$ 表示城市的大小。\n\n接下来  $n$ 行，每行包含  $m-1$ 个整数，第  $i$ 行第  $j$ 个正整数表示从一个路口到另一个路口的时间  $r(i,j)$ 。\n\n接下来  $n-1$ 行，每行包含  $m$ 个整数，第  $i$ 行第  $j$ 个正整数表示从一个路口到另一个路口的时间  $c(i,j)$。\n\n接下来一行，包含一个正整数  $q$，表示小 Y 的询问个数。\n\n接下来  $q$ 行，每行包含  $4$ 个正整数  $x1,y1,x2,y2$，表示两个路口的位置。", "outputFormat": "输出共  $q$ 行，每行包含一个整数表示从一个路口到另一个路口最少需要花的时间。\n", "hint": "### 数据规模与约定\n- $n\\times m \\le 2\\times 10^4$。\n- $q \\le 10^5$。\n- $1 \\le r(i,j),c(i,j) \\le 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2016] Traveler", "background": "", "description": "Xiao Y came to a new city to travel. She found that the city layout is a grid: there are $n$ roads running from east to west and $m$ roads running from south to north. These roads intersect pairwise to form $n \\times m$ intersections $(i,j)$, where $1 \\le i \\le n, 1 \\le j \\le m$.\n\nShe found that the conditions of different roads vary, so passing through different intersections takes different amounts of time. After investigation, she learned that going from intersection $(i,j)$ to $(i,j+1)$ takes time $r(i,j)$, and going from $(i,j)$ to $(i+1,j)$ takes time $c(i,j)$. Note that the roads are bidirectional. Xiao Y has $q$ queries and wants to know the minimum time needed to travel from intersection $(x_1,y_1)$ to intersection $(x_2,y_2)$.", "inputFormat": "The first line contains 2 positive integers $n, m$, representing the size of the city.\n\nThe next $n$ lines each contain $m-1$ integers. In the $i$-th line, the $j$-th positive integer represents the time $r(i,j)$ to move between adjacent intersections.\n\nThe next $n-1$ lines each contain $m$ integers. In the $i$-th line, the $j$-th positive integer represents the time $c(i,j)$ to move between adjacent intersections.\n\nThe next line contains a single positive integer $q$, the number of Xiao Y’s queries.\n\nThe following $q$ lines each contain 4 positive integers $x_1, y_1, x_2, y_2$, representing the positions of two intersections.", "outputFormat": "Output $q$ lines. Each line contains a single integer, the minimum time required to travel from one intersection to the other.", "hint": "Constraints\n- $n \\times m \\le 2 \\times 10^4$.\n- $q \\le 10^5$.\n- $1 \\le r(i,j), c(i,j) \\le 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2016] 旅行者", "background": "", "description": "小 Y 来到了一个新的城市旅行。她发现了这个城市的布局是网格状的，也就是有  $n$ 条从东到西的道路和  $m$ 条从南到北的道路，这些道路两两相交形成  $n\\times m$ 个路口  $(i,j)$，  $(1\\leq i\\leq n,1\\leq j\\leq m)$  \n\n她发现不同的道路路况不同，所以通过不同的路口需要不同的时间。通过调查发现，从路口  $(i,j)$ 到路口  $(i,j+1)$ 需要时间  $r(i,j)$ ，从路口  $(i,j)$ 到路口  $(i+1,j)$ 需要时间  $c(i,j)$ 。注意这里的道路是双向的。小 Y 有  $q$ 个询问，她想知道从路口  $(x1,y1)$ 到路口  $(x2,y2)$ 最少需要花多少时间。", "inputFormat": "第一行包含 2 个正整数  $n,m$ 表示城市的大小。\n\n接下来  $n$ 行，每行包含  $m-1$ 个整数，第  $i$ 行第  $j$ 个正整数表示从一个路口到另一个路口的时间  $r(i,j)$ 。\n\n接下来  $n-1$ 行，每行包含  $m$ 个整数，第  $i$ 行第  $j$ 个正整数表示从一个路口到另一个路口的时间  $c(i,j)$。\n\n接下来一行，包含一个正整数  $q$，表示小 Y 的询问个数。\n\n接下来  $q$ 行，每行包含  $4$ 个正整数  $x1,y1,x2,y2$，表示两个路口的位置。", "outputFormat": "输出共  $q$ 行，每行包含一个整数表示从一个路口到另一个路口最少需要花的时间。\n", "hint": "### 数据规模与约定\n- $n\\times m \\le 2\\times 10^4$。\n- $q \\le 10^5$。\n- $1 \\le r(i,j),c(i,j) \\le 10^4$。", "locale": "zh-CN"}}}
{"pid": "P3351", "type": "P", "difficulty": 7, "samples": [["6 6\n1 2\n1 3\n1 4\n2 3\n2 4\n5 6\n", "6\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "搜索", "2016", "各省省选", "浙江"], "title": "[ZJOI2016] 电阻网络", "background": "", "description": "小 Y 是一个充满智慧的女孩子，但是她只会使用串并联的方法计算两个节点之间的电阻。现在小 Y 有一个电阻网络问有多少点对 $u, v$（$u \\ne v$）之间的电阻可以用串并联的方法计算出来。\n\n我们来形式化地定义一下点对 $u, v$（$u \\ne v$）之间的电阻能否用串并联的方法计算出来。首先我们把电阻网络看成一个 $n$ 个点 $m$ 条边的图（每个电阻对应一条边）。\n\n令 $S$ 表示从 $u$ 到 $v$ 的所有简单路径（不经过重复的点的路径）上点的并集，也就是对于一个点 $x$，如果存在一条从 $u$ 到 $v$ 的简单路径经过这个点，那么它就在集合 $S$ 中。\n\n如果 $S$ 非空且 $S$ 的导出子图是 $u, v$ 为端点的二端串并联图，那么 $u, v$ 之间的电阻就能用串并联方法计算。\n\n一个有两个不同端点 $s, t$ 的图被称为二端图，其中一个称为源点，另一个称为汇点。两个二端图 $X, Y$ 并联（parallel composition）是指建一个新图，把 $X$ 和 $Y$ 的源点和汇点分别合并起来。两个二端图 $X, Y$ 串联（series composition）是指建一个新图，把 $X$ 的汇点和 $Y$ 的源点合并起来。由若干个两个点一条边的二端图经过一系列串并联变化之后形成的图称为二端串并联图。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9xagyluf.png)\n\n集合 $S$ 的导出子图点集为 $S$，边集由原图中两个端点都在 $S$ 中的边构成。", "inputFormat": "第一行包含两个正整数 $n, m$，表示电阻网络中的节点数和电阻数。  \n接下来 $m$ 行，每行包含两个正整数 $u, v$（$1 \\le u, v \\le n$，$u \\ne v$），表示有一个电阻在节点 $u$ 和 $v$ 之间。", "outputFormat": "输出共一行，表示答案，即有多少点对之间的电阻可以使用串并联的方法计算出来。", "hint": "**【样例解释 #1】**\n\n可行的点对有 $(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (5, 6)$。\n\n**【数据范围】**\n\n对于 $10 \\%$ 的数据，$n, m \\le 10$，保证原图连通，并且不存在一个点删去之后使得原图不连通。  \n对于另外 $10 \\%$ 的数据，$n, m \\le 100$，保证原图连通，并且不存在一个点删去之后使得原图不连通。  \n对于 $30 \\%$ 的数据，$n, m \\le 100$。  \n对于 $40 \\%$ 的数据，$n, m \\le 1000$。  \n对于另外 $30 \\%$ 的数据，保证原图连通，并且不存在一个点删去之后使得原图不连通。  \n对于 $100 \\%$ 的数据，$1 \\le n, m \\le {10}^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2016] Resistor Network", "background": "", "description": "Xiao Y is a very smart girl, but she can only compute the resistance between two nodes using series and parallel reductions. Now, given a resistor network, she wants to know how many pairs of vertices $u, v$ ($u \\ne v$) have their resistance computable by series-parallel methods.\n\nWe formalize when the resistance between a pair $u, v$ ($u \\ne v$) can be computed using series-parallel methods. First, regard the resistor network as a graph with $n$ vertices and $m$ edges (each resistor corresponds to an edge).\n\nLet $S$ be the union of the vertices on all simple paths (paths that do not visit a vertex more than once) from $u$ to $v$. In other words, for a vertex $x$, if there exists a simple path from $u$ to $v$ that passes through $x$, then $x \\in S$.\n\nIf $S$ is nonempty and the induced subgraph of $S$ is a two-terminal series-parallel graph with terminals $u$ and $v$, then the resistance between $u$ and $v$ can be computed using series-parallel methods.\n\nA graph with two distinct terminals $s, t$ is called a two-terminal graph, where one is the source and the other is the sink. The parallel composition of two two-terminal graphs $X, Y$ builds a new graph by identifying their sources and their sinks, respectively. The series composition of two two-terminal graphs $X, Y$ builds a new graph by identifying the sink of $X$ with the source of $Y$. A graph formed from several two-terminal graphs consisting of two vertices and one edge, by a sequence of series and parallel compositions, is called a two-terminal series-parallel graph.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9xagyluf.png)\n\nThe induced subgraph of the set $S$ has vertex set $S$, and its edge set consists of edges in the original graph whose both endpoints lie in $S$.", "inputFormat": "The first line contains two positive integers $n, m$, the number of nodes and the number of resistors in the network.  \nEach of the next $m$ lines contains two positive integers $u, v$ ($1 \\le u, v \\le n$, $u \\ne v$), indicating there is a resistor between nodes $u$ and $v$.", "outputFormat": "Output a single line containing the answer: the number of vertex pairs whose resistance can be computed using series-parallel methods.", "hint": "【Sample Explanation #1】\n\nThe feasible pairs are $(1, 2)$, $(1, 3)$, $(1, 4)$, $(2, 3)$, $(2, 4)$, $(5, 6)$.\n\n【Constraints】\n\nFor 10% of the testdata, $n, m \\le 10$, the original graph is connected and has no articulation point.  \nFor another 10% of the testdata, $n, m \\le 100$, the original graph is connected and has no articulation point.  \nFor 30% of the testdata, $n, m \\le 100$.  \nFor 40% of the testdata, $n, m \\le 1000$.  \nFor another 30% of the testdata, the original graph is connected and has no articulation point.  \nFor 100% of the testdata, $1 \\le n, m \\le {10}^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2016] 电阻网络", "background": "", "description": "小 Y 是一个充满智慧的女孩子，但是她只会使用串并联的方法计算两个节点之间的电阻。现在小 Y 有一个电阻网络问有多少点对 $u, v$（$u \\ne v$）之间的电阻可以用串并联的方法计算出来。\n\n我们来形式化地定义一下点对 $u, v$（$u \\ne v$）之间的电阻能否用串并联的方法计算出来。首先我们把电阻网络看成一个 $n$ 个点 $m$ 条边的图（每个电阻对应一条边）。\n\n令 $S$ 表示从 $u$ 到 $v$ 的所有简单路径（不经过重复的点的路径）上点的并集，也就是对于一个点 $x$，如果存在一条从 $u$ 到 $v$ 的简单路径经过这个点，那么它就在集合 $S$ 中。\n\n如果 $S$ 非空且 $S$ 的导出子图是 $u, v$ 为端点的二端串并联图，那么 $u, v$ 之间的电阻就能用串并联方法计算。\n\n一个有两个不同端点 $s, t$ 的图被称为二端图，其中一个称为源点，另一个称为汇点。两个二端图 $X, Y$ 并联（parallel composition）是指建一个新图，把 $X$ 和 $Y$ 的源点和汇点分别合并起来。两个二端图 $X, Y$ 串联（series composition）是指建一个新图，把 $X$ 的汇点和 $Y$ 的源点合并起来。由若干个两个点一条边的二端图经过一系列串并联变化之后形成的图称为二端串并联图。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9xagyluf.png)\n\n集合 $S$ 的导出子图点集为 $S$，边集由原图中两个端点都在 $S$ 中的边构成。", "inputFormat": "第一行包含两个正整数 $n, m$，表示电阻网络中的节点数和电阻数。  \n接下来 $m$ 行，每行包含两个正整数 $u, v$（$1 \\le u, v \\le n$，$u \\ne v$），表示有一个电阻在节点 $u$ 和 $v$ 之间。", "outputFormat": "输出共一行，表示答案，即有多少点对之间的电阻可以使用串并联的方法计算出来。", "hint": "**【样例解释 #1】**\n\n可行的点对有 $(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (5, 6)$。\n\n**【数据范围】**\n\n对于 $10 \\%$ 的数据，$n, m \\le 10$，保证原图连通，并且不存在一个点删去之后使得原图不连通。  \n对于另外 $10 \\%$ 的数据，$n, m \\le 100$，保证原图连通，并且不存在一个点删去之后使得原图不连通。  \n对于 $30 \\%$ 的数据，$n, m \\le 100$。  \n对于 $40 \\%$ 的数据，$n, m \\le 1000$。  \n对于另外 $30 \\%$ 的数据，保证原图连通，并且不存在一个点删去之后使得原图不连通。  \n对于 $100 \\%$ 的数据，$1 \\le n, m \\le {10}^5$。", "locale": "zh-CN"}}}
{"pid": "P3352", "type": "P", "difficulty": 6, "samples": [["5 5\n1 5 2 3 4\n", "3152671 3796875 3692207 3623487 3515626\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2016", "各省省选", "浙江"], "title": "[ZJOI2016] 线段树", "background": "", "description": "小 Yuuka 遇到了一个题目：有一个序列 $a_1,a_2,\\ldots,a_n$，$q$ 次操作。每次操作把一个区间内的数改成区间内的最大值，问最后每个数是多少。小 Yuuka 很快地就使用了线段树解决了这个问题。\n\n于是充满智慧的小 Yuuka 想，如果操作是随机的，即在这 $q$ 次操作中每次等概率随机地选择一个区间 $[l,r]$（$1 \\leq l \\leq r \\leq n$），然后将这个区间内的数改成区间内最大值（注意这样的区间共有 $\\frac{n(n+1)}{2}$ 个），最后每个数的期望大小是多少呢？\n\n小 Yuuka 非常热爱随机，所以她给出的输入序列也是随机的（随机方式见数据规模和约定）。\n\n对于每个数，输出它的期望乘 $\\left(\\frac{n(n+1)}{2} \\right)^q$ 再对 $10^9+7$ 取模的值。\n", "inputFormat": "第一行包含两个正整数 $n,q$，表示序列里数的个数和操作的个数。\n\n接下来一行，包含 $n$ 个非负整数 $a_1,a_2,\\ldots,a_n$。\n", "outputFormat": "输出共一行，包含 $n$ 个整数，表示每个数的答案。\n", "hint": "对于所有的测试数据，保证序列中数的大小不超过 $10^9$，并且每个数是 $0$ 到 $10^9$ 之间的随机整数。\n\n|测试点编号|$n$|$q$|\n|:-:|:-:|:-:|\n|1|$\\leq 5$|$\\leq 5$|\n|2|$\\leq 8$|$\\leq 400$|\n|3|$\\leq 12$|$\\leq 400$|\n|4|$\\leq 30$|$\\leq 400$|\n|5|$\\leq 50$|$\\leq 400$|\n|6|$\\leq 100$|$\\leq 400$|\n|7|$\\leq 100$|$\\leq 400$|\n|8|$\\leq 400$|$\\leq 400$|\n|9|$\\leq 400$|$\\leq 400$|\n|10|$\\leq 400$|$\\leq 400$|\n", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2016] Segment Tree", "background": "", "description": "Little Yuuka encountered a problem: given a sequence $a_1, a_2, \\ldots, a_n$ and $q$ operations. In each operation, choose an interval $[l, r]$ and set all numbers in that interval to the maximum value within the interval. After all operations, what is the final value of each number? Little Yuuka quickly solved this using a segment tree.\n\nThen the wise Little Yuuka wondered: what if the operations are random? That is, in each of the $q$ operations, we choose an interval $[l, r]$ uniformly at random among all intervals with $1 \\leq l \\leq r \\leq n$, and then set all numbers in that interval to the interval maximum (note that there are $\\frac{n(n+1)}{2}$ such intervals). What is the expected final value of each number?\n\nLittle Yuuka loves randomness, so the input sequence is also random (see Constraints and conventions in the Hint).\n\nFor each position, output its expectation multiplied by $\\left(\\frac{n(n+1)}{2} \\right)^q$, then taken modulo $10^9+7$.", "inputFormat": "The first line contains two positive integers $n, q$, the number of elements in the sequence and the number of operations.\n\nThe second line contains $n$ non-negative integers $a_1, a_2, \\ldots, a_n$.", "outputFormat": "Output a single line containing $n$ integers, the answer for each position.", "hint": "For all testdata, the values in the sequence are at most $10^9$, and each number is a random integer between $0$ and $10^9$.\n\n| Test point ID | $n$ | $q$ |\n|:-:|:-:|:-:|\n| 1 | $\\leq 5$ | $\\leq 5$ |\n| 2 | $\\leq 8$ | $\\leq 400$ |\n| 3 | $\\leq 12$ | $\\leq 400$ |\n| 4 | $\\leq 30$ | $\\leq 400$ |\n| 5 | $\\leq 50$ | $\\leq 400$ |\n| 6 | $\\leq 100$ | $\\leq 400$ |\n| 7 | $\\leq 100$ | $\\leq 400$ |\n| 8 | $\\leq 400$ | $\\leq 400$ |\n| 9 | $\\leq 400$ | $\\leq 400$ |\n| 10 | $\\leq 400$ | $\\leq 400$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2016] 线段树", "background": "", "description": "小 Yuuka 遇到了一个题目：有一个序列 $a_1,a_2,\\ldots,a_n$，$q$ 次操作。每次操作把一个区间内的数改成区间内的最大值，问最后每个数是多少。小 Yuuka 很快地就使用了线段树解决了这个问题。\n\n于是充满智慧的小 Yuuka 想，如果操作是随机的，即在这 $q$ 次操作中每次等概率随机地选择一个区间 $[l,r]$（$1 \\leq l \\leq r \\leq n$），然后将这个区间内的数改成区间内最大值（注意这样的区间共有 $\\frac{n(n+1)}{2}$ 个），最后每个数的期望大小是多少呢？\n\n小 Yuuka 非常热爱随机，所以她给出的输入序列也是随机的（随机方式见数据规模和约定）。\n\n对于每个数，输出它的期望乘 $\\left(\\frac{n(n+1)}{2} \\right)^q$ 再对 $10^9+7$ 取模的值。\n", "inputFormat": "第一行包含两个正整数 $n,q$，表示序列里数的个数和操作的个数。\n\n接下来一行，包含 $n$ 个非负整数 $a_1,a_2,\\ldots,a_n$。\n", "outputFormat": "输出共一行，包含 $n$ 个整数，表示每个数的答案。\n", "hint": "对于所有的测试数据，保证序列中数的大小不超过 $10^9$，并且每个数是 $0$ 到 $10^9$ 之间的随机整数。\n\n|测试点编号|$n$|$q$|\n|:-:|:-:|:-:|\n|1|$\\leq 5$|$\\leq 5$|\n|2|$\\leq 8$|$\\leq 400$|\n|3|$\\leq 12$|$\\leq 400$|\n|4|$\\leq 30$|$\\leq 400$|\n|5|$\\leq 50$|$\\leq 400$|\n|6|$\\leq 100$|$\\leq 400$|\n|7|$\\leq 100$|$\\leq 400$|\n|8|$\\leq 400$|$\\leq 400$|\n|9|$\\leq 400$|$\\leq 400$|\n|10|$\\leq 400$|$\\leq 400$|\n", "locale": "zh-CN"}}}
{"pid": "P3353", "type": "P", "difficulty": 2, "samples": [["6 3\n1 2\n2 4\n3 8\n4 4\n5 2\n1000 1", "16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "线段树", "排序", "前缀和", "双指针 two-pointer"], "title": "在你窗外闪耀的星星", "background": "飞逝的的时光不会模糊我对你的记忆。难以相信从我第一次见到你以来已经过去了 3 年。我仍然还生动地记得，3 年前，在美丽的集美中学，从我看到你微笑着走出教室，你将头向后仰，柔和的晚霞照耀着你玫瑰色的脸颊。我明白，我已经沉醉于你了。之后，经过几个月的观察和窥探，你的优雅与智慧，你对待生活的态度和你对未来的愿望深切地在我心中留下了印象。你是迷人的阳光女孩，我总是梦想着与你分享余生。唉，实际上你远远超过了我最疯狂的梦想。我不知道如何桥起我与你之间的鸿沟。所以我没有任何计划，仅仅只是等待，等待一个适当的机会到来。直到现在，毕业的到来，我意识到我是个傻瓜，我应该创造机会并且抓住它而不只是等待。\n\n\n这些日子里，我和我的朋友、室友、同学一个接一个地分开。我仍无法相信，在挥手之后，这些熟悉的面孔很快就会从我们的生活中消失，仅仅留下回忆。我明天就将离开学校。你已经计划远走高飞，追求你的未来，实现你的梦想。如果没有命运，也许我们不会再次相遇。所以今晚，我正在你的宿舍楼下徘徊，希望能偶然遇见你。但矛盾的是，你的美貌一定会使我心跳加速，我笨拙的舌头也许无法吐出一个字。我不记得我曾多少次经过你的宿舍楼，每次都希望看到你出现在阳台上或是窗台上。我不记得这个想法曾多少次在我的脑海中涌出：打电话叫她一起吃晚饭或是聊聊天。但每次，考虑到你的优秀和我的平凡，胆怯的优势超越勇气驱使我静静地离开。\n\n\n毕业，意味着中学生活的终结。这些光荣与浪漫的时代结束。你可爱的微笑是我原来努力学习的动力，这单相思的爱情会被密封，作为一个我心灵深处的记忆。毕业，也意味着新生活的开始，一个到达光明未来的足迹。我真希望你在国外天天开心，一切顺利。同时，我将努力从幼稚中走出来，变得更加成熟。我的理想将是在现实中追求我的爱与幸福，我永远不会放弃。\n\n\n再见了，我的公主！\n\n\n如果有一天，在某个天涯海角，我们有机会相聚，即使是白发苍苍的男人和女人，在那个时候，我希望我们可以成为好朋友来自豪地分享这个记忆，重温年轻快乐的激情。如果这个机会永远没有到来，我希望我是天空中的星星，在你的窗外闪烁。远远地保佑着你，就像一个朋友，每天晚上陪伴在你左右，一同分享甜美的梦亦或是一同经历可怕的梦。", "description": "现在问题来了：天空可以理解为一条数轴，在这条数轴上分布着许多颗星星，对于每颗星星都有它的位置 $X_i$ 和自身的亮度 $B_i$。**一个位置可能有多颗星星**。而窗户所能看到的范围是一个给出的参数 $W$，我们看到的星星也包括窗户边缘的星星。现在，要你求出调整窗户位置后能看到星星的亮度之和最大值。\n", "inputFormat": "一行 $N,W$，分别代表星星的数量和窗户的宽度。\n\n余下 $N$ 行，输入 $X_i$ 和 $B_i$，代表星星的坐标和亮度。", "outputFormat": "一个数字，代表能看到星星的最大亮度和。\n", "hint": "样例说明：\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/3818.png) \n\n对于 $10\\%$ 的数据，$W=0$（没有边缘）；\n\n对于 $40\\%$ 的数据，$W\\leq 1000$；\n\n对于 $100\\%$ 的数据，$1 \\leq N\\leq 10 ^ 5$，$0 \\leq W\\leq 10 ^ 5$，$1 \\leq X_i\\leq 10 ^ 5$，$1\\leq B_i\\leq 100$。\n\n除 $W=0$ 的情况外，$W$ 均为 $\\geq 3$ 的奇数。\n", "locale": "zh-CN", "translations": {"en": {"title": "The Stars Shining Outside Your Window", "background": "The fleeting passage of time will not blur my memory of you. It is hard to believe that 3 years have passed since I first saw you. I still vividly remember, 3 years ago, at the beautiful Jimei Middle School, when I saw you walk out of the classroom with a smile, tilt your head back, and the soft evening glow lit up your rosy cheeks. I knew I was already enchanted by you. Later, after months of watching and peeking, your grace and wisdom, your attitude toward life, and your hopes for the future left a deep impression on me. You are a charming sunshine girl, and I always dream of spending the rest of my life with you. Alas, in fact you far exceed my wildest dreams. I do not know how to bridge the gap between you and me. So I had no plan, only waiting, waiting for a proper chance to come. Until now, with graduation approaching, I realize I am a fool; I should create chances and seize them, not just wait.\n\nThese days, my friends, roommates, and classmates are parting one by one. I still cannot believe that after we wave goodbye, those familiar faces will soon disappear from our lives, leaving only memories. I will leave school tomorrow. You have planned to go far away, pursue your future, and realize your dreams. Without fate, perhaps we will never meet again. So tonight, I am wandering downstairs by your dormitory, hoping to run into you by chance. But paradoxically, your beauty will certainly make my heart pound, and my clumsy tongue may not utter a word. I do not remember how many times I have passed by your dormitory, each time hoping to see you appear on the balcony or by the window. I do not remember how many times the thought has surged in my mind: call you to have dinner together or just chat. But each time, thinking of your excellence and my ordinariness, timidity outweighs courage and drives me to leave quietly.\n\nGraduation means the end of middle school life. Those glorious and romantic days are over. Your lovely smile was the motivation behind my hard study, and this unrequited love will be sealed as a memory deep in my heart. Graduation also means the start of a new life, a step toward a bright future. I truly wish you happiness every day abroad and all the best. At the same time, I will try to grow out of childishness and become more mature. My ideal is to pursue love and happiness in reality, and I will never give up.\n\nFarewell, my princess.\n\nIf one day, somewhere at the ends of the earth, we have the chance to meet again, even as a gray‑haired man and woman, then I hope we can be good friends, proudly share this memory, and relive the passion of our youthful joy. If that chance never comes, I wish I were a star in the sky, twinkling outside your window. Blessing you from afar, like a friend, by your side every night, sharing sweet dreams with you or going through terrible dreams together.", "description": "Now here is the problem: Think of the sky as a number line. On this number line there are many stars, each with a position $X_i$ and a brightness $B_i$. **Multiple stars may share the same position.** The range a window can see is given by a parameter $W$, and the stars we see also include those on the window’s boundaries. Find the maximum possible sum of brightness of the stars visible after adjusting the position of the window.", "inputFormat": "One line with $N, W$, the number of stars and the width of the window.\n\nEach of the next $N$ lines contains $X_i$ and $B_i$, the coordinate and brightness of a star.", "outputFormat": "One number, the maximum total brightness of the visible stars.", "hint": "Sample explanation:\n\n![](https://cdn.luogu.com.cn/upload/pic/3818.png)\n\nConstraints:\n- For $10\\%$ of the testdata, $W = 0$ (no boundary).\n- For $40\\%$ of the testdata, $W \\leq 1000$.\n- For $100\\%$ of the testdata, $1 \\leq N \\leq 10^5$, $0 \\leq W \\leq 10^5$, $1 \\leq X_i \\leq 10^5$, $1 \\leq B_i \\leq 100$.\n- Except for the case $W = 0$, $W$ is an odd integer $\\geq 3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "在你窗外闪耀的星星", "background": "飞逝的的时光不会模糊我对你的记忆。难以相信从我第一次见到你以来已经过去了 3 年。我仍然还生动地记得，3 年前，在美丽的集美中学，从我看到你微笑着走出教室，你将头向后仰，柔和的晚霞照耀着你玫瑰色的脸颊。我明白，我已经沉醉于你了。之后，经过几个月的观察和窥探，你的优雅与智慧，你对待生活的态度和你对未来的愿望深切地在我心中留下了印象。你是迷人的阳光女孩，我总是梦想着与你分享余生。唉，实际上你远远超过了我最疯狂的梦想。我不知道如何桥起我与你之间的鸿沟。所以我没有任何计划，仅仅只是等待，等待一个适当的机会到来。直到现在，毕业的到来，我意识到我是个傻瓜，我应该创造机会并且抓住它而不只是等待。\n\n\n这些日子里，我和我的朋友、室友、同学一个接一个地分开。我仍无法相信，在挥手之后，这些熟悉的面孔很快就会从我们的生活中消失，仅仅留下回忆。我明天就将离开学校。你已经计划远走高飞，追求你的未来，实现你的梦想。如果没有命运，也许我们不会再次相遇。所以今晚，我正在你的宿舍楼下徘徊，希望能偶然遇见你。但矛盾的是，你的美貌一定会使我心跳加速，我笨拙的舌头也许无法吐出一个字。我不记得我曾多少次经过你的宿舍楼，每次都希望看到你出现在阳台上或是窗台上。我不记得这个想法曾多少次在我的脑海中涌出：打电话叫她一起吃晚饭或是聊聊天。但每次，考虑到你的优秀和我的平凡，胆怯的优势超越勇气驱使我静静地离开。\n\n\n毕业，意味着中学生活的终结。这些光荣与浪漫的时代结束。你可爱的微笑是我原来努力学习的动力，这单相思的爱情会被密封，作为一个我心灵深处的记忆。毕业，也意味着新生活的开始，一个到达光明未来的足迹。我真希望你在国外天天开心，一切顺利。同时，我将努力从幼稚中走出来，变得更加成熟。我的理想将是在现实中追求我的爱与幸福，我永远不会放弃。\n\n\n再见了，我的公主！\n\n\n如果有一天，在某个天涯海角，我们有机会相聚，即使是白发苍苍的男人和女人，在那个时候，我希望我们可以成为好朋友来自豪地分享这个记忆，重温年轻快乐的激情。如果这个机会永远没有到来，我希望我是天空中的星星，在你的窗外闪烁。远远地保佑着你，就像一个朋友，每天晚上陪伴在你左右，一同分享甜美的梦亦或是一同经历可怕的梦。", "description": "现在问题来了：天空可以理解为一条数轴，在这条数轴上分布着许多颗星星，对于每颗星星都有它的位置 $X_i$ 和自身的亮度 $B_i$。**一个位置可能有多颗星星**。而窗户所能看到的范围是一个给出的参数 $W$，我们看到的星星也包括窗户边缘的星星。现在，要你求出调整窗户位置后能看到星星的亮度之和最大值。\n", "inputFormat": "一行 $N,W$，分别代表星星的数量和窗户的宽度。\n\n余下 $N$ 行，输入 $X_i$ 和 $B_i$，代表星星的坐标和亮度。", "outputFormat": "一个数字，代表能看到星星的最大亮度和。\n", "hint": "样例说明：\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/3818.png) \n\n对于 $10\\%$ 的数据，$W=0$（没有边缘）；\n\n对于 $40\\%$ 的数据，$W\\leq 1000$；\n\n对于 $100\\%$ 的数据，$1 \\leq N\\leq 10 ^ 5$，$0 \\leq W\\leq 10 ^ 5$，$1 \\leq X_i\\leq 10 ^ 5$，$1\\leq B_i\\leq 100$。\n\n除 $W=0$ 的情况外，$W$ 均为 $\\geq 3$ 的奇数。\n", "locale": "zh-CN"}}}
{"pid": "P3354", "type": "P", "difficulty": 6, "samples": [["4 2\n1 0 1\n1 1 10\n10 2 5\n1 2 3", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2005", "IOI"], "title": "[IOI 2005] Riv 河流", "background": "", "description": "几乎整个 Byteland 王国都被森林和河流所覆盖。小点的河汇聚到一起，形成了稍大点的河。就这样，所有的河水都汇聚并流进了一条大河，最后这条大河流进了大海。这条大河的入海口处有一个村庄——名叫 Bytetown。\n\n在 Byteland 国，有 $n$ 个伐木的村庄，这些村庄都座落在河边。目前在 Bytetown，有一个巨大的伐木场，它处理着全国砍下的所有木料。木料被砍下后，顺着河流而被运到 Bytetown 的伐木场。Byteland 的国王决定，为了减少运输木料的费用，再额外地建造 $k$ 个伐木场。这 $k$ 个伐木场将被建在其他村庄里。这些伐木场建造后，木料就不用都被送到 Bytetown 了，它们可以在运输过程中第一个碰到的新伐木场被处理。显然，如果伐木场座落的那个村子就不用再付运送木料的费用了。它们可以直接被本村的伐木场处理。\n\n注：所有的河流都不会分叉，形成一棵树，根结点是 Bytetown。\n\n国王的大臣计算出了每个村子每年要产多少木料，你的任务是决定在哪些村子建设伐木场能获得最小的运费。其中运费的计算方法为：每一吨木料每千米 $1$ 分钱。", "inputFormat": "第一行包括两个整数 $n,k$。$n$ 为村庄数，$k$ 为要建的伐木场的数目。除了 Bytetown 外，每个村子依次被命名为 $1,2,3\\ldots n$，Bytetown 被命名为 $0$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行 $3$ 个整数，第 $(i + 1)$ 行的整数分别代表，分别表示每年 $i$ 村子产的木料的块数 $w_i$，离 $i$ 村子下游最近的村子 $v_i$（即 $i$ 村子的父结点），$v_i$ 到 $i$ 的距离 $d_i$（千米）。", "outputFormat": "输出最小花费，单位为分。\n", "hint": "#### 数据规模与约定\n\n- 对于 $50\\%$ 的数据，保证 $n\\le 20$。\n- 对于 $100\\%$ 的数据，保证 $2\\le n\\le 100$，$1\\le k\\le \\min(n,50)$，$0\\le v_i\\le n$，$0\\le w_i\\le 10^4$，$1\\le d_i\\le 10^4$。\n- 保证每年所有的木料流到 bytetown 的运费不超过 $2\\times 10^9$ 分。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2005] Riv River", "background": "", "description": "Almost the entire kingdom of Byteland is covered with forests and rivers. Small rivers merge into slightly larger ones. In this way, all river water converges into a single large river, which eventually flows into the sea. At the mouth of this large river lies a village called Bytetown.\n\nIn Byteland, there are $n$ logging villages located along the rivers. There is currently a large sawmill in Bytetown that processes all the timber cut nationwide. Timber is cut and transported downstream along the rivers to the sawmill in Bytetown. The King of Byteland has decided to reduce transportation costs by building $k$ additional sawmills in other villages. After these sawmills are built, timber no longer needs to be sent all the way to Bytetown; it can be processed at the first new sawmill encountered during transport. Clearly, if a sawmill is located in a village, that village pays no transportation cost for its own timber; it can be processed locally.\n\nNote: The rivers never split; they form a tree whose root is Bytetown.\n\nThe ministers have calculated the annual timber production of each village. Your task is to decide in which villages to build the sawmills to minimize the transportation cost. The cost is calculated as 1 cent per kilometer per ton of timber.", "inputFormat": "The first line contains two integers $n, k$. Here $n$ is the number of villages, and $k$ is the number of sawmills to build. All villages other than Bytetown are named $1, 2, 3, \\ldots, n$, and Bytetown is named $0$.\n\nLines $2$ through $(n + 1)$ each contain three integers. On the $(i + 1)$-th line, the integers are:\n- $w_i$: the amount of timber produced annually by village $i$ (in tons),\n- $v_i$: the nearest downstream village from $i$ (i.e., the parent of village $i$),\n- $d_i$: the distance from $v_i$ to $i$ (in kilometers).", "outputFormat": "Output the minimum total cost, in cents.", "hint": "- Constraints:\n  - For $50\\%$ of the testdata, $n \\le 20$.\n  - For $100\\%$ of the testdata, $2 \\le n \\le 100$, $1 \\le k \\le \\min(n, 50)$, $0 \\le v_i \\le n$, $0 \\le w_i \\le 10^4$, $1 \\le d_i \\le 10^4$.\n  - It is guaranteed that the annual cost of sending all timber to Bytetown does not exceed $2 \\times 10^9$ cents.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2005] Riv 河流", "background": "", "description": "几乎整个 Byteland 王国都被森林和河流所覆盖。小点的河汇聚到一起，形成了稍大点的河。就这样，所有的河水都汇聚并流进了一条大河，最后这条大河流进了大海。这条大河的入海口处有一个村庄——名叫 Bytetown。\n\n在 Byteland 国，有 $n$ 个伐木的村庄，这些村庄都座落在河边。目前在 Bytetown，有一个巨大的伐木场，它处理着全国砍下的所有木料。木料被砍下后，顺着河流而被运到 Bytetown 的伐木场。Byteland 的国王决定，为了减少运输木料的费用，再额外地建造 $k$ 个伐木场。这 $k$ 个伐木场将被建在其他村庄里。这些伐木场建造后，木料就不用都被送到 Bytetown 了，它们可以在运输过程中第一个碰到的新伐木场被处理。显然，如果伐木场座落的那个村子就不用再付运送木料的费用了。它们可以直接被本村的伐木场处理。\n\n注：所有的河流都不会分叉，形成一棵树，根结点是 Bytetown。\n\n国王的大臣计算出了每个村子每年要产多少木料，你的任务是决定在哪些村子建设伐木场能获得最小的运费。其中运费的计算方法为：每一吨木料每千米 $1$ 分钱。", "inputFormat": "第一行包括两个整数 $n,k$。$n$ 为村庄数，$k$ 为要建的伐木场的数目。除了 Bytetown 外，每个村子依次被命名为 $1,2,3\\ldots n$，Bytetown 被命名为 $0$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行 $3$ 个整数，第 $(i + 1)$ 行的整数分别代表，分别表示每年 $i$ 村子产的木料的块数 $w_i$，离 $i$ 村子下游最近的村子 $v_i$（即 $i$ 村子的父结点），$v_i$ 到 $i$ 的距离 $d_i$（千米）。", "outputFormat": "输出最小花费，单位为分。\n", "hint": "#### 数据规模与约定\n\n- 对于 $50\\%$ 的数据，保证 $n\\le 20$。\n- 对于 $100\\%$ 的数据，保证 $2\\le n\\le 100$，$1\\le k\\le \\min(n,50)$，$0\\le v_i\\le n$，$0\\le w_i\\le 10^4$，$1\\le d_i\\le 10^4$。\n- 保证每年所有的木料流到 bytetown 的运费不超过 $2\\times 10^9$ 分。", "locale": "zh-CN"}}}
{"pid": "P3355", "type": "P", "difficulty": 5, "samples": [["3 2\n1 1\n3 3", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["网络流", "O2优化", "二分图", "最小割", "网络流与线性规划 24 题"], "title": "骑士共存问题", "background": null, "description": "在一个 $n \\times n$ 个方格的国际象棋棋盘上，马（骑士）可以攻击的棋盘方格如图所示。棋盘上某些方格设置了障碍，骑士不得进入。\n\n![](https://cdn.luogu.com.cn/upload/pic/2669.png)\n\n对于给定的 $n \\times n$ 个方格的国际象棋棋盘和障碍标志，计算棋盘上最多可以放置多少个骑士，使得它们彼此互不攻击。", "inputFormat": "第一行有 $2$ 个正整数 $n$ 和 $m$ ，分别表示棋盘的大小和障碍数。接下来的 $m$ 行给出障碍的位置。每行 $2$ 个正整数，表示障碍的方格坐标。", "outputFormat": "将计算出的共存骑士数输出。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n \\leq 200$，$0 \\leq m \\lt n^2$。", "locale": "zh-CN", "translations": {"en": {"title": "Knights Coexistence Problem", "background": "", "description": "On an $n \\times n$ chessboard, a knight can attack the squares shown in the figure. Some squares on the board are marked as obstacles, and knights are not allowed to enter them.\n\n![](https://cdn.luogu.com.cn/upload/pic/2669.png)\n\nGiven an $n \\times n$ chessboard and the obstacle marks, compute the maximum number of knights that can be placed on the board so that no two knights attack each other.", "inputFormat": "The first line contains $2$ positive integers $n$ and $m$, representing the size of the board and the number of obstacles, respectively. The following $m$ lines give the positions of the obstacles. Each line contains $2$ positive integers, representing the coordinates of an obstructed square.", "outputFormat": "Output the maximum number of knights that can coexist.", "hint": "#### Constraints\n\nFor all test points, it is guaranteed that $1 \\leq n \\leq 200$, $0 \\leq m \\lt n^2$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "骑士共存问题", "background": null, "description": "在一个 $n \\times n$ 个方格的国际象棋棋盘上，马（骑士）可以攻击的棋盘方格如图所示。棋盘上某些方格设置了障碍，骑士不得进入。\n\n![](https://cdn.luogu.com.cn/upload/pic/2669.png)\n\n对于给定的 $n \\times n$ 个方格的国际象棋棋盘和障碍标志，计算棋盘上最多可以放置多少个骑士，使得它们彼此互不攻击。", "inputFormat": "第一行有 $2$ 个正整数 $n$ 和 $m$ ，分别表示棋盘的大小和障碍数。接下来的 $m$ 行给出障碍的位置。每行 $2$ 个正整数，表示障碍的方格坐标。", "outputFormat": "将计算出的共存骑士数输出。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n \\leq 200$，$0 \\leq m \\lt n^2$。", "locale": "zh-CN"}}}
{"pid": "P3356", "type": "P", "difficulty": 6, "samples": [["2\n10\n8\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 1 1 0 0 0\n0 0 0 1 0 2 0 0 0 0\n1 1 0 1 2 0 0 0 0 1\n0 1 0 0 2 0 1 1 0 0\n0 1 0 1 0 0 1 1 0 0\n0 1 2 0 0 0 0 1 0 0\n0 0 0 0 0 0 0 0 0 0", "1 1\n1 1\n1 1\n1 1\n1 0\n1 0\n1 1\n1 1\n1 1\n1 1\n1 0\n1 0\n1 1\n1 0\n1 0\n1 0\n2 1\n2 1\n2 1\n2 1\n2 0\n2 0\n2 0\n2 0\n2 1\n2 0\n2 0\n2 1\n2 0\n2 1\n2 1\n2 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["Special Judge", "O2优化", "图论建模", "费用流", "网络流与线性规划 24 题"], "title": "火星探险问题 ", "background": "", "description": "火星探险队的登陆舱将在火星表面着陆，登陆舱内有多部障碍物探测车。登陆舱着陆后，探测车将离开登陆舱向先期到达的传送器方向移动。  \n\n探测车在移动中还必须采集岩石标本。每一块岩石标本由最先遇到它的探测车完成采集。每块岩石标本只能被采集一次。岩石标本被采集后，其他探测车可以从原来岩石标本所在处通过。探测车不能通过有障碍的地面。  \n\n本题限定探测车只能从登陆处沿着向南或向东的方向朝传送器移动，而且多个探测车可以在同一时间占据同一位置。如果某个探测车在到达传送器以前不能继续前进，则该车所采集的岩石标本将全部损失。\n\n\n用一个 $p \\times q$ 网格表示登陆舱与传送器之间的位置。登陆舱的位置在 \n$(x_1,y_1)$ 处，传送器的位置在 $(x_py_q)$ 处。\n\n$$\\begin{bmatrix} (x_1,y_1) & (x_2,y_1) & \\dots & (x_{p-1},y_1) & (x_p,y_1) \\\\ (x_1,y_2) & (x_2,y_2) & \\dots & (x_{p-1},y_2) & (x_p,y_2) \\\\ \\dots & \\dots & \\dots & \\dots & \\dots \\\\ (x_1,y_{q-1}) & (x_2,y_{q-1}) & \\dots & (x_{p-1},y_{q-1}) & (x_p,y_{q-1}) \\\\ (x_1,y_q) & (x_2,y_q) & \\dots & (x_{p-1},y_q) & (x_p,y_q) \\end{bmatrix}$$\n\n给定每个位置的状态，计算探测车的最优移动方案，使到达传送器的探测车的数量最多，而且探测车采集到的岩石标本的数量最多。\n", "inputFormat": "第一行为探测车数 $n$，接下来两行分别为 $p,q$。  \n\n接下来的 $q$ 行是表示登陆舱与传送器之间的位置状态的 $p \\times q$ 网格。  \n用三种数表示火星表面位置的状态：$0$ 表示平坦无障碍，$1$ 表示障碍，$2$ 表示石块。\n", "outputFormat": "每行包含探测车号和一个移动方向，$0$ 表示向南移动，$1$ 表示向东移动。\n", "hint": "【数据范围】\n对于 $100\\%$ 的数据，$1 \\le n,p,q \\le 35$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Mars Exploration Problem", "background": "", "description": "The lander of the Mars exploration team will touch down on the Martian surface. Inside the lander, there are multiple obstacle-detecting rovers. After landing, the rovers will leave the lander and move toward the transmitter that arrived earlier.\n\nWhile moving, the rovers must also collect rock samples. Each rock sample is collected by the first rover that encounters it. Each rock sample can be collected only once. After a rock sample is collected, other rovers may pass through its former location. Rovers cannot pass through obstructed terrain.\n\nIn this problem, rovers are limited to moving from the landing position toward the transmitter only in the south or east direction, and multiple rovers may occupy the same position at the same time. If any rover cannot proceed before reaching the transmitter, all rock samples it collected will be lost.\n\nUse a $p \\times q$ grid to represent the positions between the lander and the transmitter. The lander is at $(x_1,y_1)$, and the transmitter is at $(x_p,y_q)$.\n\n$$\\begin{bmatrix} (x_1,y_1) & (x_2,y_1) & \\dots & (x_{p-1},y_1) & (x_p,y_1) \\\\ (x_1,y_2) & (x_2,y_2) & \\dots & (x_{p-1},y_2) & (x_p,y_2) \\\\ \\dots & \\dots & \\dots & \\dots & \\dots \\\\ (x_1,y_{q-1}) & (x_2,y_{q-1}) & \\dots & (x_{p-1},y_{q-1}) & (x_p,y_{q-1}) \\\\ (x_1,y_q) & (x_2,y_q) & \\dots & (x_{p-1},y_q) & (x_p,y_q) \\end{bmatrix}$$\n\nGiven the state of each position, compute the optimal movement plan so that the number of rovers reaching the transmitter is maximized, and the number of rock samples collected by the rovers is also maximized.", "inputFormat": "The first line contains the number of rovers $n$. The next two lines contain $p$ and $q$, respectively.\n\nThe next $q$ lines describe the $p \\times q$ grid of positions between the lander and the transmitter. Three numbers are used to represent the state of a position: $0$ means flat and unobstructed, $1$ means an obstacle, and $2$ means a rock.", "outputFormat": "Each line contains a rover ID and one movement direction, where $0$ means moving south and $1$ means moving east.", "hint": "Constraints\nFor $100\\%$ of the testdata, $1 \\le n, p, q \\le 35$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "火星探险问题 ", "background": "", "description": "火星探险队的登陆舱将在火星表面着陆，登陆舱内有多部障碍物探测车。登陆舱着陆后，探测车将离开登陆舱向先期到达的传送器方向移动。  \n\n探测车在移动中还必须采集岩石标本。每一块岩石标本由最先遇到它的探测车完成采集。每块岩石标本只能被采集一次。岩石标本被采集后，其他探测车可以从原来岩石标本所在处通过。探测车不能通过有障碍的地面。  \n\n本题限定探测车只能从登陆处沿着向南或向东的方向朝传送器移动，而且多个探测车可以在同一时间占据同一位置。如果某个探测车在到达传送器以前不能继续前进，则该车所采集的岩石标本将全部损失。\n\n\n用一个 $p \\times q$ 网格表示登陆舱与传送器之间的位置。登陆舱的位置在 \n$(x_1,y_1)$ 处，传送器的位置在 $(x_py_q)$ 处。\n\n$$\\begin{bmatrix} (x_1,y_1) & (x_2,y_1) & \\dots & (x_{p-1},y_1) & (x_p,y_1) \\\\ (x_1,y_2) & (x_2,y_2) & \\dots & (x_{p-1},y_2) & (x_p,y_2) \\\\ \\dots & \\dots & \\dots & \\dots & \\dots \\\\ (x_1,y_{q-1}) & (x_2,y_{q-1}) & \\dots & (x_{p-1},y_{q-1}) & (x_p,y_{q-1}) \\\\ (x_1,y_q) & (x_2,y_q) & \\dots & (x_{p-1},y_q) & (x_p,y_q) \\end{bmatrix}$$\n\n给定每个位置的状态，计算探测车的最优移动方案，使到达传送器的探测车的数量最多，而且探测车采集到的岩石标本的数量最多。\n", "inputFormat": "第一行为探测车数 $n$，接下来两行分别为 $p,q$。  \n\n接下来的 $q$ 行是表示登陆舱与传送器之间的位置状态的 $p \\times q$ 网格。  \n用三种数表示火星表面位置的状态：$0$ 表示平坦无障碍，$1$ 表示障碍，$2$ 表示石块。\n", "outputFormat": "每行包含探测车号和一个移动方向，$0$ 表示向南移动，$1$ 表示向东移动。\n", "hint": "【数据范围】\n对于 $100\\%$ 的数据，$1 \\le n,p,q \\le 35$。\n", "locale": "zh-CN"}}}
{"pid": "P3357", "type": "P", "difficulty": 6, "samples": [["4 2\n1 2 7 3\n6 5 8 3\n7 8 10 5\n9 6 13 9 ", "17"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "网络流与线性规划 24 题"], "title": "最长k可重线段集问题", "background": "", "description": "给定平面 $x-O-y$ 上 $n$ 个开线段组成的集合 $I$，和一个正整数 $k$ 。试设计一个算法，从开线段集合 $I$ 中选取出开线段集合 $S\\subseteq I$ ,使得在 $x$ 轴上的任何一点 $p$，$S$ 中与直线 $x=p$ 相交的开线段个数不超过 $k$，且$\\sum\\limits_{z\\in S}|z|$达到最大。这样的集合 $S$ 称为开线段集合 $I$ 的最长  $k$ 可重线段集。$\\sum\\limits_{z\\in S}|z|$ 称为最长  $k$ 可重线段集的长度。\n\n对于任何开线段 $z$，设其断点坐标为 $(x_0,y_0)$ 和 $(x_1,y_1)$，则开线段 $z$ 的长度 $|z|$ 定义为：\n$$|z|=\\lfloor\\sqrt{(x_1-x_0)^2+(y_1-y_0)^2}\\rfloor$$\n\n对于给定的开线段集合 $I$ 和正整数 $k$，计算开线段集合 $I$ 的最长 $k$ 可重线段集的长度。\n", "inputFormat": "文件的第一 行有 $2$ 个正整数 $n$ 和 $k$，分别表示开线段的个数和开线段的可重叠数。\n\n接下来的 $n$ 行，每行有 $4$ 个整数，表示开线段的 $2$ 个端点坐标。\n", "outputFormat": "程序运行结束时，输出计算出的最长 $k$ 可重线段集的长度。\n", "hint": "$1\\leq n\\leq 500$，$1 \\leq k \\leq 13$，坐标值在 `int` 范围内。\n", "locale": "zh-CN", "translations": {"en": {"title": "Longest k-Overlap Segment Set Problem", "background": "", "description": "Given a set $I$ of $n$ open line segments in the plane $x-O-y$, and a positive integer $k$. Design an algorithm to select a subset $S \\subseteq I$ such that, for any point $p$ on the $x$-axis, the number of open line segments in $S$ that intersect the line $x = p$ does not exceed $k$, and $\\sum\\limits_{z\\in S} |z|$ is maximized. Such a subset $S$ is called the longest $k$-overlap set of open line segments of $I$. The value $\\sum\\limits_{z\\in S} |z|$ is called the length of the longest $k$-overlap segment set.\n\nFor any open line segment $z$ with endpoints $(x_0, y_0)$ and $(x_1, y_1)$, its length $|z|$ is defined as:\n$$|z|=\\lfloor\\sqrt{(x_1-x_0)^2+(y_1-y_0)^2}\\rfloor$$\n\nGiven the open line segment set $I$ and the positive integer $k$, compute the length of the longest $k$-overlap open segment set of $I$.", "inputFormat": "The first line contains $2$ positive integers $n$ and $k$, denoting the number of open line segments and the allowed overlap count.\n\nThe next $n$ lines each contain $4$ integers, giving the coordinates of the $2$ endpoints of an open line segment.", "outputFormat": "Output the computed length of the longest $k$-overlap segment set.", "hint": "Constraints: $1 \\leq n \\leq 500$, $1 \\leq k \\leq 13$, and all coordinates are within the `int` range.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最长k可重线段集问题", "background": "", "description": "给定平面 $x-O-y$ 上 $n$ 个开线段组成的集合 $I$，和一个正整数 $k$ 。试设计一个算法，从开线段集合 $I$ 中选取出开线段集合 $S\\subseteq I$ ,使得在 $x$ 轴上的任何一点 $p$，$S$ 中与直线 $x=p$ 相交的开线段个数不超过 $k$，且$\\sum\\limits_{z\\in S}|z|$达到最大。这样的集合 $S$ 称为开线段集合 $I$ 的最长  $k$ 可重线段集。$\\sum\\limits_{z\\in S}|z|$ 称为最长  $k$ 可重线段集的长度。\n\n对于任何开线段 $z$，设其断点坐标为 $(x_0,y_0)$ 和 $(x_1,y_1)$，则开线段 $z$ 的长度 $|z|$ 定义为：\n$$|z|=\\lfloor\\sqrt{(x_1-x_0)^2+(y_1-y_0)^2}\\rfloor$$\n\n对于给定的开线段集合 $I$ 和正整数 $k$，计算开线段集合 $I$ 的最长 $k$ 可重线段集的长度。\n", "inputFormat": "文件的第一 行有 $2$ 个正整数 $n$ 和 $k$，分别表示开线段的个数和开线段的可重叠数。\n\n接下来的 $n$ 行，每行有 $4$ 个整数，表示开线段的 $2$ 个端点坐标。\n", "outputFormat": "程序运行结束时，输出计算出的最长 $k$ 可重线段集的长度。\n", "hint": "$1\\leq n\\leq 500$，$1 \\leq k \\leq 13$，坐标值在 `int` 范围内。\n", "locale": "zh-CN"}}}
{"pid": "P3358", "type": "P", "difficulty": 6, "samples": [["4 2\n1 7\n6 8\n7 10\n9 13 ", "15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["网络流", "O2优化", "网络流与线性规划 24 题"], "title": "最长k可重区间集问题", "background": "", "description": "给定实直线 $\\text{L}$ 上 $n$ 个开区间组成的集合 $\\mathbf{I}$，和一个正整数 $k$，试设计一个算法，从开区间集合 $\\mathbf{I}$ 中选取出开区间集合 $\\mathbf{S}\\subseteq\\mathbf{I}$，使得在实直线 $\\text{L}$ 上的任意一点 $x$，$\\text{S}$ 中包含 $x$ 的开区间个数不超过 $k$，且 $\\sum_{z\\in\\text{S}}\\lvert z\\rvert$ 达到最大（$\\lvert z\\rvert$ 表示开区间 $z$ 的长度）。\n\n这样的集合 $\\mathbf{S}$ 称为开区间集合 $\\mathbf{I}$ 的最长 $k$ 可重区间集。$\\sum_{z\\in\\text{S}}\\lvert z\\rvert$ 称为最长 $k$ 可重区间集的长度。\n\n对于给定的开区间集合 $\\mathbf{I}$ 和正整数 $k$，计算开区间集合 $\\mathbf{I}$ 的最长 $k$ 可重区间集的长度。", "inputFormat": "输入的第一行有 $2$ 个正整数 $n$ 和 $k$，分别表示开区间的个数和开区间的可重叠数。接下来的 $n$ 行，每行有 $2$ 个整数，表示开区间的左右端点坐标 $l,r$，数据保证 $l<r$。", "outputFormat": "输出最长 $k$ 可重区间集的长度。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 500$，$1\\le k\\le 3$，$1 \\le l < r \\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Longest k-Overlap Interval Set Problem", "background": "", "description": "Given a set $\\mathbf{I}$ of $n$ open intervals on the real line $\\text{L}$ and a positive integer $k$, design an algorithm to select a set of open intervals $\\mathbf{S} \\subseteq \\mathbf{I}$ such that at any point $x$ on $\\text{L}$, the number of intervals in $\\mathbf{S}$ that contain $x$ is at most $k$, and $\\sum_{z \\in \\text{S}} \\lvert z \\rvert$ is maximized ($\\lvert z \\rvert$ denotes the length of the open interval $z$).\n\nSuch a set $\\mathbf{S}$ is called a longest $k$-overlap interval set of $\\mathbf{I}$. The value $\\sum_{z \\in \\text{S}} \\lvert z \\rvert$ is called the length of a longest $k$-overlap interval set.\n\nGiven the set of open intervals $\\mathbf{I}$ and the positive integer $k$, compute the length of a longest $k$-overlap interval set of $\\mathbf{I}$.", "inputFormat": "The first line contains two positive integers $n$ and $k$, denoting the number of open intervals and the allowed maximum number of overlaps. Each of the next $n$ lines contains two integers, the left and right endpoints $l, r$ of an open interval. It is guaranteed that $l < r$.", "outputFormat": "Output the length of a longest $k$-overlap interval set.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le 500$, $1 \\le k \\le 3$, $1 \\le l < r \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最长k可重区间集问题", "background": "", "description": "给定实直线 $\\text{L}$ 上 $n$ 个开区间组成的集合 $\\mathbf{I}$，和一个正整数 $k$，试设计一个算法，从开区间集合 $\\mathbf{I}$ 中选取出开区间集合 $\\mathbf{S}\\subseteq\\mathbf{I}$，使得在实直线 $\\text{L}$ 上的任意一点 $x$，$\\text{S}$ 中包含 $x$ 的开区间个数不超过 $k$，且 $\\sum_{z\\in\\text{S}}\\lvert z\\rvert$ 达到最大（$\\lvert z\\rvert$ 表示开区间 $z$ 的长度）。\n\n这样的集合 $\\mathbf{S}$ 称为开区间集合 $\\mathbf{I}$ 的最长 $k$ 可重区间集。$\\sum_{z\\in\\text{S}}\\lvert z\\rvert$ 称为最长 $k$ 可重区间集的长度。\n\n对于给定的开区间集合 $\\mathbf{I}$ 和正整数 $k$，计算开区间集合 $\\mathbf{I}$ 的最长 $k$ 可重区间集的长度。", "inputFormat": "输入的第一行有 $2$ 个正整数 $n$ 和 $k$，分别表示开区间的个数和开区间的可重叠数。接下来的 $n$ 行，每行有 $2$ 个整数，表示开区间的左右端点坐标 $l,r$，数据保证 $l<r$。", "outputFormat": "输出最长 $k$ 可重区间集的长度。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 500$，$1\\le k\\le 3$，$1 \\le l < r \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P3359", "type": "P", "difficulty": 6, "samples": [["4\n1 2 0\n2 3 0\n2 4 0\n3 1 2", "6\n3\n1\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "洛谷原创", "洛谷月赛"], "title": "改造异或树", "background": null, "description": "给定一棵 $n$ 个点的树，每条边上都有一个权值。现在按顺序删掉所有的 $n-1$ 条边，每删掉一条边询问当前有多少条路径满足路径上所有边权值异或和为 $0$。", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n-1$ 行，每行三个整数 $a_i,b_i,z_i$，满足 $1\\le ai,bi\\le n$，表示树上编号为 $a_i$ 的点和编号为$b_i$ 的点中间连有一条权值为 $z_i$ 的边。\n\n接下来一行 $n-1$ 个整数，两两之间有一个空格隔开，表示一个 $1\\sim n- 1$ 的排列，表示 $n - 1$ 条边的删边顺序。", "outputFormat": "输出 $n$ 行，每行一个整数，依次表示删掉第 $0\\sim  n - 1$ 条边之后的边权异或和为零的路径数。", "hint": "对于 $20\\%$ 数据，满足 $n\\le 1000$。\n\n对于另外 $30\\%$ 数据，满足所有的 $z_i = 0$。\n\n对于全部数据，满足 $n\\le 10^5,0\\le z_i\\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "Transform the XOR Tree", "background": "", "description": "You are given a tree with $n$ nodes, and each edge has a weight. Now we delete all $n - 1$ edges one by one in a given order. After deleting each edge, query how many paths currently have the XOR sum of edge weights equal to $0$.", "inputFormat": "The first line contains an integer $n$.\n\nThe next $n - 1$ lines each contain three integers $a_i, b_i, z_i$, with $1 \\le a_i, b_i \\le n$, indicating that there is an edge with weight $z_i$ between nodes numbered $a_i$ and $b_i$.\n\nThe next line contains $n - 1$ integers separated by single spaces, which form a permutation of $1 \\sim n - 1$, representing the deletion order of the $n - 1$ edges.", "outputFormat": "Output $n$ lines, each containing one integer. The $k$-th line (where $k = 0, 1, \\dots, n - 1$) is the number of paths whose XOR sum of edge weights is $0$ after deleting the first $k$ edges in the given order.", "hint": "For $20\\%$ of the testdata, $n \\le 1000$.\n\nFor another $30\\%$ of the testdata, all $z_i = 0$.\n\nFor all testdata, $n \\le 10^5$, $0 \\le z_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "改造异或树", "background": null, "description": "给定一棵 $n$ 个点的树，每条边上都有一个权值。现在按顺序删掉所有的 $n-1$ 条边，每删掉一条边询问当前有多少条路径满足路径上所有边权值异或和为 $0$。", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n-1$ 行，每行三个整数 $a_i,b_i,z_i$，满足 $1\\le ai,bi\\le n$，表示树上编号为 $a_i$ 的点和编号为$b_i$ 的点中间连有一条权值为 $z_i$ 的边。\n\n接下来一行 $n-1$ 个整数，两两之间有一个空格隔开，表示一个 $1\\sim n- 1$ 的排列，表示 $n - 1$ 条边的删边顺序。", "outputFormat": "输出 $n$ 行，每行一个整数，依次表示删掉第 $0\\sim  n - 1$ 条边之后的边权异或和为零的路径数。", "hint": "对于 $20\\%$ 数据，满足 $n\\le 1000$。\n\n对于另外 $30\\%$ 数据，满足所有的 $z_i = 0$。\n\n对于全部数据，满足 $n\\le 10^5,0\\le z_i\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P3360", "type": "P", "difficulty": 5, "samples": [["50 \n5 0 10 1 10 1 5 0 10 2 500 1 1000 2 18 1 1000000 4 ", "1500"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["树形 DP"], "title": "偷天换日", "background": "神偷对艺术馆内的名画垂涎欲滴准备大捞一把。", "description": "艺术馆由若干个展览厅和若干条走廊组成。每一条走廊的尽头不是通向一个展览厅，就是分为两个走廊。\n\n每个展览厅内都有若干幅画，每副画都有一个价值。经过走廊和偷画都是要耗费时间的。\n\n警察会在 $n$ 秒时到达进口，如果你此时仍未离开将会遭到逮捕，所以你要计算出在此之前你最多能得到的画的价值。\n\n![](https://cdn.luogu.com.cn/upload/pic/2730.png)", "inputFormat": "第一行一个整数 $n (n \\leq 600)$。\n\n第二行若干组整数 $(t,x)(t \\leq 5,x \\leq 30)$，对于每组整数 ，$t$ 表示进入这个展览厅或经过走廊要耗费 $t$ 秒的时间，若 $x>0$ 表示走廊通向的展览厅内有 $x$ 幅画，否则若 $x=0$ 表示走廊一分为二，接下来 $x$ 对整数 $(w,c)(w \\leq 10^6,c \\leq 5)$ 表示偷一幅价值为 $w$ 的画需要 $c$ 秒的时间。\n\n输入是按深度优先给出的。房间和走廊数不超过 $300$ 个。", "outputFormat": "仅一个整数，表示能获得的最大价值。", "hint": "来源：改编", "locale": "zh-CN", "translations": {"en": {"title": "Steal the Sky, Swap the Sun", "background": "A master thief covets the masterpieces in the art museum and is ready for a big haul.", "description": "The art museum consists of several exhibition rooms and several corridors. Each corridor either ends at an exhibition room, or splits into two corridors.\n\nEach exhibition room contains several paintings, and each painting has a value. Traversing a corridor and stealing a painting both take time.\n\nThe police will arrive at the entrance in $n$ seconds. Find the maximum total value you can obtain without being caught.\n\n![](https://cdn.luogu.com.cn/upload/pic/2730.png)", "inputFormat": "- The first line contains an integer $n$ ($n \\leq 600$).\n- Starting from the second line, a sequence is given in depth-first order. For each entry, read a pair $(t, x)$:\n  - $t$ is the time in seconds to either enter an exhibition room or traverse a corridor.\n  - If $x > 0$, the corridor leads to an exhibition room containing $x$ paintings, followed by $x$ pairs $(w, c)$, where stealing one painting of value $w$ takes $c$ seconds.\n  - If $x = 0$, the corridor splits into two sub-corridors; the descriptions of these two sub-corridors follow immediately in depth-first order.\n  - Constraints: $t, c \\leq 5; x \\leq 30$.\n- The numbers of rooms and corridors do not exceed $300$.\n- The input is given in depth-first order.", "outputFormat": "Output a single integer, the maximum total value that can be obtained.", "hint": "Source: adapted.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "偷天换日", "background": "神偷对艺术馆内的名画垂涎欲滴准备大捞一把。", "description": "艺术馆由若干个展览厅和若干条走廊组成。每一条走廊的尽头不是通向一个展览厅，就是分为两个走廊。\n\n每个展览厅内都有若干幅画，每副画都有一个价值。经过走廊和偷画都是要耗费时间的。\n\n警察会在 $n$ 秒时到达进口，如果你此时仍未离开将会遭到逮捕，所以你要计算出在此之前你最多能得到的画的价值。\n\n![](https://cdn.luogu.com.cn/upload/pic/2730.png)", "inputFormat": "第一行一个整数 $n (n \\leq 600)$。\n\n第二行若干组整数 $(t,x)(t \\leq 5,x \\leq 30)$，对于每组整数 ，$t$ 表示进入这个展览厅或经过走廊要耗费 $t$ 秒的时间，若 $x>0$ 表示走廊通向的展览厅内有 $x$ 幅画，否则若 $x=0$ 表示走廊一分为二，接下来 $x$ 对整数 $(w,c)(w \\leq 10^6,c \\leq 5)$ 表示偷一幅价值为 $w$ 的画需要 $c$ 秒的时间。\n\n输入是按深度优先给出的。房间和走廊数不超过 $300$ 个。", "outputFormat": "仅一个整数，表示能获得的最大价值。", "hint": "来源：改编", "locale": "zh-CN"}}}
{"pid": "P3361", "type": "P", "difficulty": 4, "samples": [["6\n3 5 7 11 13 17", "17.52167"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "洛谷原创", "洛谷月赛"], "title": "Cool loves maids", "background": "Cool 非常喜欢妹子，以至于 Cool 在百度上有一个非常神奇的 ID 【雾】。", "description": "Cool 现在搞清楚了女生宿舍的地形。女生宿舍是由很多栋楼构成的，它们可以被抽象成 $20\\times 20$ 的方格。\n\nCool 的妹子们所处的地方可以被表示为实数类型的坐标。当一个妹子 $(x,y)$ 在楼 $(i,j)$ 中，当且仅当 $i \\le x<i+1$，$j \\le y<j+1$，$i,j\\in \\Z$。两个妹子之间有距离，当且仅当一个妹子所在的楼的横纵坐标均小于另一个妹子所在的楼，此时她们之间的距离为她们自身坐标的曼哈顿距离。\n\n现在 Cool 要搞一个大统计：求 $n$ 个妹子之间所有距离之和。", "inputFormat": "为了避免输入文件过大无法上传在读入方面消耗过多时间，本题采取数据生成方案。\n\n输入包含两行：\n\n- 第一行，一个整数 $n$；\n- 第二行，包含 $6$ 个整数 $\\mathrm{rxa},\\mathrm{rxc},\\mathrm{rya},\\mathrm{ryc},\\mathrm{rza},\\mathrm{rzc}$。\n\n所有的实数都采用如下方式生成：\n\n1. 初始化 $x=y=z=0$；\n2. 重复以下过程：  \n   - $x=(y\\times \\mathrm{rxa}+\\mathrm{rxc})\\bmod \\mathrm{rp}$；\n   - $y=(z\\times \\mathrm{rya}+\\mathrm{ryc})\\bmod \\mathrm{rp}$；\n   - $z=(x\\times \\mathrm{rza}+\\mathrm{rzc})\\bmod \\mathrm{rp}$。\n\n每次得到的实数即为 $(x\\bmod 20)+(y\\bmod 10)\\div 10+(z\\bmod 10)\\div 100$。$\\mathrm{rp}=2333333$。\n\n第 $i$ 个妹子将以第 $2i-1$ 个生成实数为横坐标，第 $2i$ 个生成实数为纵坐标。", "outputFormat": "输出包含一行一个实数，表示 $n$ 个妹子之间所有距离之和的平均值，保留 $5$ 位小数。\n", "hint": "### 数据范围及约定\n\n对于全部数据，保证 $1\\le n\\le 5\\times 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "Cool loves maids", "background": "Cool likes girls very much, to the extent that Cool has a rather mysterious ID on Baidu [fog].", "description": "Cool has now figured out the layout of the women’s dormitory. The dormitory consists of many buildings, which can be abstracted as a $20\\times 20$ grid.\n\nThe places where Cool’s maids are located can be represented by real-valued coordinates. A maid $(x, y)$ is in building $(i, j)$ if and only if $i \\le x < i + 1$, $j \\le y < j + 1$, $i, j \\in \\Z$. The distance between two maids is defined if and only if both the row and column indices of one maid’s building are strictly less than those of the other maid’s building; in that case, their distance is the Manhattan distance between their own coordinates.\n\nNow Cool wants to compile a big statistic: compute the sum of all distances among $n$ maids.", "inputFormat": "To avoid spending too much time on reading due to large input files that cannot be uploaded, this problem uses a data generation scheme.\n\nThe input contains two lines:\n\n- The first line contains an integer $n$.\n- The second line contains $6$ integers $\\mathrm{rxa}, \\mathrm{rxc}, \\mathrm{rya}, \\mathrm{ryc}, \\mathrm{rza}, \\mathrm{rzc}$.\n\nAll real numbers are generated as follows:\n\n1. Initialize $x = y = z = 0$.\n2. Repeat the following process:\n   - $x = (y \\times \\mathrm{rxa} + \\mathrm{rxc}) \\bmod \\mathrm{rp}$;\n   - $y = (z \\times \\mathrm{rya} + \\mathrm{ryc}) \\bmod \\mathrm{rp}$;\n   - $z = (x \\times \\mathrm{rza} + \\mathrm{rzc}) \\bmod \\mathrm{rp}$.\n\nEach time, the real number obtained is $(x \\bmod 20) + (y \\bmod 10) \\div 10 + (z \\bmod 10) \\div 100$. $\\mathrm{rp} = 2333333$.\n\nThe $i$-th maid uses the $(2i - 1)$-th generated real number as the $x$-coordinate, and the $2i$-th generated real number as the $y$-coordinate.", "outputFormat": "Output a single real number on one line, representing the average of all distances among the $n$ maids, with $5$ decimal places.", "hint": "Constraints\n\nFor all testdata, it is guaranteed that $1 \\le n \\le 5 \\times 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Cool loves maids", "background": "Cool 非常喜欢妹子，以至于 Cool 在百度上有一个非常神奇的 ID 【雾】。", "description": "Cool 现在搞清楚了女生宿舍的地形。女生宿舍是由很多栋楼构成的，它们可以被抽象成 $20\\times 20$ 的方格。\n\nCool 的妹子们所处的地方可以被表示为实数类型的坐标。当一个妹子 $(x,y)$ 在楼 $(i,j)$ 中，当且仅当 $i \\le x<i+1$，$j \\le y<j+1$，$i,j\\in \\Z$。两个妹子之间有距离，当且仅当一个妹子所在的楼的横纵坐标均小于另一个妹子所在的楼，此时她们之间的距离为她们自身坐标的曼哈顿距离。\n\n现在 Cool 要搞一个大统计：求 $n$ 个妹子之间所有距离之和。", "inputFormat": "为了避免输入文件过大无法上传在读入方面消耗过多时间，本题采取数据生成方案。\n\n输入包含两行：\n\n- 第一行，一个整数 $n$；\n- 第二行，包含 $6$ 个整数 $\\mathrm{rxa},\\mathrm{rxc},\\mathrm{rya},\\mathrm{ryc},\\mathrm{rza},\\mathrm{rzc}$。\n\n所有的实数都采用如下方式生成：\n\n1. 初始化 $x=y=z=0$；\n2. 重复以下过程：  \n   - $x=(y\\times \\mathrm{rxa}+\\mathrm{rxc})\\bmod \\mathrm{rp}$；\n   - $y=(z\\times \\mathrm{rya}+\\mathrm{ryc})\\bmod \\mathrm{rp}$；\n   - $z=(x\\times \\mathrm{rza}+\\mathrm{rzc})\\bmod \\mathrm{rp}$。\n\n每次得到的实数即为 $(x\\bmod 20)+(y\\bmod 10)\\div 10+(z\\bmod 10)\\div 100$。$\\mathrm{rp}=2333333$。\n\n第 $i$ 个妹子将以第 $2i-1$ 个生成实数为横坐标，第 $2i$ 个生成实数为纵坐标。", "outputFormat": "输出包含一行一个实数，表示 $n$ 个妹子之间所有距离之和的平均值，保留 $5$ 位小数。\n", "hint": "### 数据范围及约定\n\n对于全部数据，保证 $1\\le n\\le 5\\times 10^6$。", "locale": "zh-CN"}}}
{"pid": "P3362", "type": "P", "difficulty": 5, "samples": [["10 2 2\n4 5\n8 10", "47\n306"], ["1000 0 1\n720 720", "30"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["数学", "2016", "洛谷原创", "洛谷月赛"], "title": "Cool loves shaxian", "background": "Cool 非常非常喜欢吃沙县,确切地说,他非常非常把各种无辜群众拉到沙县去吃饭(╯‵□′)╯(┻━┻。大家都非常非常想知道沙县到底给了 Cool 多少钱带盐沙县小吃,以便未来威逼利诱 Cool 来请客吃隔壁的 KFC。经过多方追踪,大家发现了带盐费发放的某一些规律ヾ(o◕∀◕)ノヾ。\n", "description": "沙县发放带盐费以壕著称。这家沙县发放带盐费时有个指数 $d$。他会发放 $n$ 轮带盐费，在第 $i$ 轮中，都会发放 $f(i) = \\sum_{k|i} k^d (i \\leq n)$ 这么多的钱。\n\n现在大家有了 $Q$ 个问题，每个问题都形如 Cool 参加从第 $L_i$ 轮到第 $R_i$ 轮的带盐活动，将能获得多少钱。（保证 $1 \\leq L_i \\leq R_i \\leq n$）\n\n由于开在南大街的沙县小吃不是一般的有钱啊，所以呢，我们要计算的是 Cool 收到的钱对 $10^ 9 + 7$ 取模得到的答案。\n", "inputFormat": "输入包含若干行。\n\n第一行，三个整数，$n, d, Q$。（$n\\leq 10^7$，$d\\leq 10^{18}$，$q\\leq 5\\times 10^4$。\n\n接下来的 $Q$ 行,每行两个整数 $L_i, R_i$。\n", "outputFormat": "输出包含 $Q$ 行。\n\n每行一个整数，表示 Cool 得到的带盐费。\n", "hint": "样例 $1$：\n\n$f(4) = 1^2 + 2^2 + 4^2 = 21$\n\n$f(5) =1^2+5^2= 26$\n\n$f(8) + f(9) + f (10) = 85 + 91 + 130= 306$\n\n样例 $2$：\n\n就相当于在数 $720$ 的因数个数呢~\n", "locale": "zh-CN", "translations": {"en": {"title": "Cool loves shaxian", "background": "Cool really, really loves eating at Shaxian. To be precise, he really, really likes dragging all kinds of unsuspecting folks to Shaxian for meals (╯‵□′)╯(┻━┻. Everyone is dying to know how much money Shaxian has paid Cool to \"endorse\" (dàiyán) Shaxian Snacks, so that in the future they can threaten and cajole Cool into treating them to the KFC next door. After much tracking, people discovered some patterns in how the endorsement fees are paid out ヾ(o◕∀◕)ノヾ。", "description": "Shaxian is famous for being lavish when paying endorsement (dàiyán) fees. When this Shaxian pays endorsement fees, it uses an exponent $d$. It will pay fees for $n$ rounds. In the $i$-th round, it pays $f(i) = \\sum_{k|i} k^d (i \\leq n)$ money.\n\nNow there are $Q$ queries. Each query asks: if Cool participates from round $L_i$ to round $R_i$, how much money will he receive? (It is guaranteed that $1 \\leq L_i \\leq R_i \\leq n$.)\n\nSince the Shaxian Snacks on South Street is insanely rich, we need to compute the answer modulo $10^ 9 + 7$.", "inputFormat": "The input contains multiple lines.\n\nThe first line contains three integers, $n, d, Q$ ($n\\leq 10^7$, $d\\leq 10^{18}$, $Q\\leq 5\\times 10^4$).\n\nThe next $Q$ lines each contain two integers $L_i, R_i$.", "outputFormat": "The output contains $Q$ lines.\n\nEach line contains one integer, the amount of endorsement fee Cool receives.", "hint": "Sample 1:\n\n$f(4) = 1^2 + 2^2 + 4^2 = 21$.\n\n$f(5) =1^2+5^2= 26$.\n\n$f(8) + f(9) + f (10) = 85 + 91 + 130= 306$.\n\nSample 2:\n\nThis is essentially the number of divisors of the number $720$~.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Cool loves shaxian", "background": "Cool 非常非常喜欢吃沙县,确切地说,他非常非常把各种无辜群众拉到沙县去吃饭(╯‵□′)╯(┻━┻。大家都非常非常想知道沙县到底给了 Cool 多少钱带盐沙县小吃,以便未来威逼利诱 Cool 来请客吃隔壁的 KFC。经过多方追踪,大家发现了带盐费发放的某一些规律ヾ(o◕∀◕)ノヾ。\n", "description": "沙县发放带盐费以壕著称。这家沙县发放带盐费时有个指数 $d$。他会发放 $n$ 轮带盐费，在第 $i$ 轮中，都会发放 $f(i) = \\sum_{k|i} k^d (i \\leq n)$ 这么多的钱。\n\n现在大家有了 $Q$ 个问题，每个问题都形如 Cool 参加从第 $L_i$ 轮到第 $R_i$ 轮的带盐活动，将能获得多少钱。（保证 $1 \\leq L_i \\leq R_i \\leq n$）\n\n由于开在南大街的沙县小吃不是一般的有钱啊，所以呢，我们要计算的是 Cool 收到的钱对 $10^ 9 + 7$ 取模得到的答案。\n", "inputFormat": "输入包含若干行。\n\n第一行，三个整数，$n, d, Q$。（$n\\leq 10^7$，$d\\leq 10^{18}$，$q\\leq 5\\times 10^4$。\n\n接下来的 $Q$ 行,每行两个整数 $L_i, R_i$。\n", "outputFormat": "输出包含 $Q$ 行。\n\n每行一个整数，表示 Cool 得到的带盐费。\n", "hint": "样例 $1$：\n\n$f(4) = 1^2 + 2^2 + 4^2 = 21$\n\n$f(5) =1^2+5^2= 26$\n\n$f(8) + f(9) + f (10) = 85 + 91 + 130= 306$\n\n样例 $2$：\n\n就相当于在数 $720$ 的因数个数呢~\n", "locale": "zh-CN"}}}
{"pid": "P3363", "type": "P", "difficulty": 6, "samples": [["5 4 3\n1 2\n1 3\n1 4\n4 5\n2 3\n3 5\n2 5\n4 5", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "洛谷原创", "洛谷月赛"], "title": "Cool loves jiaoyi", "background": "Cool 交易得十分熟练。现在 Cool 即将参加一场 NOIP 普及组模拟赛。Cool 什么都不会，他将通过交易来获得每一题的题解 / 标程。", "description": "Cool 的交易对象构成了一个树形结构。\n\n对于每一场轰轰烈烈的交易，都会有一个交易起点和交易终点。在树上从交易起点到交易终点的路径称作交易链，交易链上的所有交易对象都将加入这场交易，交易的代价即为交易对象数。\n\n现在 Cool 面临着 $m$ 场交易，现在 Cool 要钦点 $k$ 场交易，使得存在某个神秘交易对象参与了所有 $k$ 场交易，并且最小化这 $k$ 场交易中代价之差的最大值。", "inputFormat": "输入包含若干行。\n\n第一行三个整数 $n,m,k$，代表交易对象数、交易场数和 Cool 钦定的 $k$。接下来的 $n-1$ 行，每行两个整数 $u,v$ 代表交易对象 $u,v$ 在交易树上相连。\n\n接下来的 $m$ 行，每行两个整数 $s,t$，表示每场交易的交易起点和交易终点（起点终点可以重合）。", "outputFormat": "输出包含一个整数，表示 Cool 钦点的最小的最大代价之差，若不存在这样的 $k$ 场交易，输出 $-1$。", "hint": "### 数据范围\n\n$1\\leq n\\leq 5\\times 10^4,1\\leq k\\leq m\\leq 10^4.$\n\n### 样例解释\n\n选择第 $1,2,3$ 三场交易，则交易对象 $1$ 被同时交易了 $3$ 次，且三场交易的代价分别为 $3,4,4$。他们交易代价之差最大为 $4-3$。此时最优。", "locale": "zh-CN", "translations": {"en": {"title": "Cool loves jiaoyi", "background": "Cool is very skilled at trading. Now Cool is about to take part in a NOIP Junior mock contest. Cool knows nothing, so he will obtain each problem’s editorial / standard solution through trading.", "description": "Cool’s trading partners form a tree.\n\nFor each trade, there is a start and an end. The path from the start to the end on the tree is called the trade chain. All trading partners (nodes) on the trade chain join this trade, and the cost of the trade equals the number of trading partners on the chain.\n\nNow there are $m$ trades. Cool will designate $k$ trades such that there exists a mysterious trading partner who participates in all these $k$ trades, and he wants to minimize the maximum difference of costs among these $k$ trades (i.e., minimize max cost $-$ min cost).", "inputFormat": "The input consists of several lines.\n\n- The first line contains three integers $n, m, k$, representing the number of trading partners, the number of trades, and the designated $k$.\n- Each of the next $n-1$ lines contains two integers $u, v$, indicating that trading partners $u$ and $v$ are connected in the trading tree.\n- Each of the next $m$ lines contains two integers $s, t$, representing the start and end of a trade (the start and end may coincide).", "outputFormat": "Output a single integer, the minimal possible value of the maximum cost difference among the designated trades. If no such set of $k$ trades exists, output $-1$.", "hint": "Constraints\n\n$1\\leq n\\leq 5\\times 10^4, 1\\leq k\\leq m\\leq 10^4.$\n\nSample Explanation\n\nChoose trades $1, 2, 3$. Trading partner $1$ participates in all three trades, and the three costs are $3, 4, 4$. Their maximum cost difference is $4-3$. This is optimal.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Cool loves jiaoyi", "background": "Cool 交易得十分熟练。现在 Cool 即将参加一场 NOIP 普及组模拟赛。Cool 什么都不会，他将通过交易来获得每一题的题解 / 标程。", "description": "Cool 的交易对象构成了一个树形结构。\n\n对于每一场轰轰烈烈的交易，都会有一个交易起点和交易终点。在树上从交易起点到交易终点的路径称作交易链，交易链上的所有交易对象都将加入这场交易，交易的代价即为交易对象数。\n\n现在 Cool 面临着 $m$ 场交易，现在 Cool 要钦点 $k$ 场交易，使得存在某个神秘交易对象参与了所有 $k$ 场交易，并且最小化这 $k$ 场交易中代价之差的最大值。", "inputFormat": "输入包含若干行。\n\n第一行三个整数 $n,m,k$，代表交易对象数、交易场数和 Cool 钦定的 $k$。接下来的 $n-1$ 行，每行两个整数 $u,v$ 代表交易对象 $u,v$ 在交易树上相连。\n\n接下来的 $m$ 行，每行两个整数 $s,t$，表示每场交易的交易起点和交易终点（起点终点可以重合）。", "outputFormat": "输出包含一个整数，表示 Cool 钦点的最小的最大代价之差，若不存在这样的 $k$ 场交易，输出 $-1$。", "hint": "### 数据范围\n\n$1\\leq n\\leq 5\\times 10^4,1\\leq k\\leq m\\leq 10^4.$\n\n### 样例解释\n\n选择第 $1,2,3$ 三场交易，则交易对象 $1$ 被同时交易了 $3$ 次，且三场交易的代价分别为 $3,4,4$。他们交易代价之差最大为 $4-3$。此时最优。", "locale": "zh-CN"}}}
{"pid": "P3364", "type": "P", "difficulty": 6, "samples": [["3\n1 2 3 1\n2 1 2 2\n3 1 3 3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2016", "洛谷原创", "cdq 分治", "O2优化", "洛谷月赛"], "title": "Cool loves touli", "background": "Cool 一直都很崇拜 touli。\n", "description": "有一天 Cool 和 touli 在打多校，突然开始讨论怎么样的阵容比较厉害。Cool 觉得一个阵容，将他们的等级从低到高排序后，攻击力应该是递增的。Cool 就问 touli 这个阵容最多有几个人。\n\n不过 touli 觉得这个问题实在太 SB，就改变了条件，他认为等级从低到高排序后，对于任意两个排序后相邻的英雄，等级低的英雄的攻击力应该不大于等级高的英雄的力量，等级高的英雄的攻击力应当不小于等级低的英雄的智力。\n\n现在 Cool 想知道若干个英雄中，最多能选出多少个英雄加入阵容。", "inputFormat": "第一行 $n$ 表示有 $n$ 个英雄。\n\n接下来 $n$ 行，每行 $4$ 个整数 $l,s,w,a$，分别表示该英雄的等级、力量、智力、攻击力。", "outputFormat": "一个数,表示最多能选出的英雄个数。\n", "hint": "选择第 $1$ 个和第 $3$ 个英雄，符合条件。对于第 $1$ 个和第 $2$ 个英雄，第 $2$ 个英雄的攻击力小于第 $1$ 个英雄的智力，所以不能同时存在。\n\n$n\\leq 10^5$，$l,s,w,a\\le10^8$，$l$ 互不相同。", "locale": "zh-CN", "translations": {"en": {"title": "Cool loves touli", "background": "Cool has always admired touli.", "description": "One day, while Cool and touli were participating in a multi-school contest, they started discussing what kind of lineup would be strong. Cool thought that in a lineup, after sorting heroes by level from low to high, their attack values should be increasing. Cool then asked touli what the maximum possible size of such a lineup would be.\n\nHowever, touli felt this question was too trivial, so he changed the condition: after sorting by level from low to high, for any two adjacent heroes in this order, the lower-level hero’s attack must be no greater than the higher-level hero’s strength, and the higher-level hero’s attack must be no less than the lower-level hero’s intelligence.\n\nNow Cool wants to know, among several heroes, what is the maximum number of heroes that can be selected to form such a lineup.", "inputFormat": "The first line $n$ indicates there are $n$ heroes.\n\nThe next $n$ lines each contain $4$ integers $l, s, w, a$, representing that hero’s level, strength, intelligence, and attack, respectively.", "outputFormat": "A single integer, the maximum number of heroes that can be selected.", "hint": "Selecting the $1$st and $3$rd heroes satisfies the condition. For the $1$st and $2$nd heroes, the $2$nd hero’s attack is less than the $1$st hero’s intelligence, so they cannot both be in the lineup.\n\nConstraints: $n \\leq 10^5$, $l, s, w, a \\le 10^8$, and the $l$ values are pairwise distinct.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Cool loves touli", "background": "Cool 一直都很崇拜 touli。\n", "description": "有一天 Cool 和 touli 在打多校，突然开始讨论怎么样的阵容比较厉害。Cool 觉得一个阵容，将他们的等级从低到高排序后，攻击力应该是递增的。Cool 就问 touli 这个阵容最多有几个人。\n\n不过 touli 觉得这个问题实在太 SB，就改变了条件，他认为等级从低到高排序后，对于任意两个排序后相邻的英雄，等级低的英雄的攻击力应该不大于等级高的英雄的力量，等级高的英雄的攻击力应当不小于等级低的英雄的智力。\n\n现在 Cool 想知道若干个英雄中，最多能选出多少个英雄加入阵容。", "inputFormat": "第一行 $n$ 表示有 $n$ 个英雄。\n\n接下来 $n$ 行，每行 $4$ 个整数 $l,s,w,a$，分别表示该英雄的等级、力量、智力、攻击力。", "outputFormat": "一个数,表示最多能选出的英雄个数。\n", "hint": "选择第 $1$ 个和第 $3$ 个英雄，符合条件。对于第 $1$ 个和第 $2$ 个英雄，第 $2$ 个英雄的攻击力小于第 $1$ 个英雄的智力，所以不能同时存在。\n\n$n\\leq 10^5$，$l,s,w,a\\le10^8$，$l$ 互不相同。", "locale": "zh-CN"}}}
{"pid": "P3365", "type": "P", "difficulty": 5, "samples": [["3\n2 2 2\n1 0\n1 1", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2016", "洛谷原创", "洛谷月赛"], "title": "改造二叉树", "background": "勤奋又善于思考的小 L 接触了信息学竞赛，开始的学习十分顺利。但是，小 L 对数据结构的掌握实在十分渣渣。\n\n所以，小 L 当时卡在了二叉树。", "description": "在计算机科学中，二叉树是每个结点最多有两个子结点的有序树。通常子结点被称作“左孩子”和“右孩子”。二叉树被用作二叉搜索树和二叉堆。随后他又和他人讨论起了二叉搜索树。什么是二叉搜索树呢？二叉搜索树首先是一棵二叉树。设 $key_p$ 表示结点 $p$ 上的数值。对于其中的每个结点 $p$，若其存在左孩子 $lch$，则 $key_p>key_{lch}$；若其存在右孩子 $rch$，则 $key_p<key_{rch}$；注意，本题中的二叉搜索树应满足对于所有结点，其左子树中的 $key$ 小于当前结点的 $key$，其右子树中的 $key$ 大于当前结点的 $key$。（因为小 L 十分喜欢装 xx，所以这里他十分装 xx 的给大家介绍了什么是二叉树和二叉搜索树）。\n\n可是善于思考的小 L 不甘于只学习这些基础的东西。他思考了这样一个问题：现在给定一棵二叉树，可以任意修改结点的数值。修改一个结点的数值算作一次修改，且这个结点不能再被修改。若要将其变成一棵二叉搜索树，且任意时刻结点的数值必须是整数（可以是负整数或 $0$），所要的最少修改次数。\n\n这一定难不倒聪明的你吧！如果你能帮小 L 解决这个问题，也许他会把最后的资产分给你 $\\dfrac{1}{16}$ 哦！", "inputFormat": "第一行一个正整数 $n$ 表示二叉树节点数。\n\n第二行 $n$ 个正整数用空格分隔开，第 $i$ 个数 $a_i$ 表示结点 $i$ 的原始数值。\n\n此后 $n-1$ 行每行两个非负整数 $fa$，$ch$，第 $i+2$ 行描述结点 $i+1$ 的父亲编号 $fa$，以及父子关系 $ch$，（$ch = 0$ 表示 $i+1$ 为左儿子，$ch = 1$ 表示 $i + 1$ 为右儿子）。\n\n为了让你稍微减轻些负担，小 L 规定：结点 $1$ 一定是二叉树的根哦！", "outputFormat": "仅一行包含一个整数，表示最少的修改次数。", "hint": "对于 $20\\%$ 的数据：$n \\leq 10$，$a_i \\leq 100$。\n\n对于 $40\\%$ 的数据：$n \\leq 100$，$a_i \\leq 200$。\n\n对于 $60\\%$ 的数据：$n \\leq 2000$。\n\n对于 $100\\%$ 的数据：$n \\leq 10^5$，$a_i < 2^{31}$。", "locale": "zh-CN", "translations": {"en": {"title": "Transforming a Binary Tree", "background": "Diligent and thoughtful Xiao L started learning for the informatics competition, and the beginning went very well. However, Xiao L’s grasp of data structures was really weak.\n\nSo, Xiao L got stuck on binary trees.", "description": "In computer science, a binary tree is an ordered tree in which each node has at most two children. The children are usually called the “left child” and the “right child.” Binary trees are used as binary search trees and binary heaps. Then he discussed binary search trees with others. What is a binary search tree? A binary search tree is first a binary tree. Let $key_p$ denote the value stored at node $p$. For each node $p$, if it has a left child $lch$, then $key_p > key_{lch}$; if it has a right child $rch$, then $key_p < key_{rch}$. Note that in this problem, the binary search tree must satisfy: for every node, all keys in its left subtree are less than the node’s key, and all keys in its right subtree are greater than the node’s key.\n\nBut thoughtful Xiao L is not satisfied with only learning the basics. He considered this problem: given a binary tree, you can arbitrarily change the values of nodes. Changing the value of a node counts as one modification, and that node cannot be modified again. You want to transform it into a binary search tree, and at any time the value of every node must be an integer (it can be negative or $0$). What is the minimum number of modifications required?\n\nThis surely won’t stump you! If you help Xiao L solve this problem, maybe he will give you $\\dfrac{1}{16}$ of his final assets.", "inputFormat": "The first line contains a positive integer $n$, the number of nodes in the binary tree.\n\nThe second line contains $n$ positive integers separated by spaces. The $i$-th number $a_i$ is the original value of node $i$.\n\nThen follow $n - 1$ lines, each containing two non-negative integers $fa$ and $ch$. The $(i + 2)$-th line describes the parent index $fa$ of node $i + 1$ and the parent-child relation $ch$ ($ch = 0$ means $i + 1$ is the left child, $ch = 1$ means $i + 1$ is the right child).\n\nTo make it a bit easier for you, Xiao L guarantees that node $1$ is the root of the binary tree.", "outputFormat": "Output a single line containing one integer, the minimum number of modifications.", "hint": "Constraints\n\n- For $20\\%$ of the testdata: $n \\leq 10$, $a_i \\leq 100$.\n- For $40\\%$ of the testdata: $n \\leq 100$, $a_i \\leq 200$.\n- For $60\\%$ of the testdata: $n \\leq 2000$.\n- For $100\\%$ of the testdata: $n \\leq 10^5$, $a_i < 2^{31}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "改造二叉树", "background": "勤奋又善于思考的小 L 接触了信息学竞赛，开始的学习十分顺利。但是，小 L 对数据结构的掌握实在十分渣渣。\n\n所以，小 L 当时卡在了二叉树。", "description": "在计算机科学中，二叉树是每个结点最多有两个子结点的有序树。通常子结点被称作“左孩子”和“右孩子”。二叉树被用作二叉搜索树和二叉堆。随后他又和他人讨论起了二叉搜索树。什么是二叉搜索树呢？二叉搜索树首先是一棵二叉树。设 $key_p$ 表示结点 $p$ 上的数值。对于其中的每个结点 $p$，若其存在左孩子 $lch$，则 $key_p>key_{lch}$；若其存在右孩子 $rch$，则 $key_p<key_{rch}$；注意，本题中的二叉搜索树应满足对于所有结点，其左子树中的 $key$ 小于当前结点的 $key$，其右子树中的 $key$ 大于当前结点的 $key$。（因为小 L 十分喜欢装 xx，所以这里他十分装 xx 的给大家介绍了什么是二叉树和二叉搜索树）。\n\n可是善于思考的小 L 不甘于只学习这些基础的东西。他思考了这样一个问题：现在给定一棵二叉树，可以任意修改结点的数值。修改一个结点的数值算作一次修改，且这个结点不能再被修改。若要将其变成一棵二叉搜索树，且任意时刻结点的数值必须是整数（可以是负整数或 $0$），所要的最少修改次数。\n\n这一定难不倒聪明的你吧！如果你能帮小 L 解决这个问题，也许他会把最后的资产分给你 $\\dfrac{1}{16}$ 哦！", "inputFormat": "第一行一个正整数 $n$ 表示二叉树节点数。\n\n第二行 $n$ 个正整数用空格分隔开，第 $i$ 个数 $a_i$ 表示结点 $i$ 的原始数值。\n\n此后 $n-1$ 行每行两个非负整数 $fa$，$ch$，第 $i+2$ 行描述结点 $i+1$ 的父亲编号 $fa$，以及父子关系 $ch$，（$ch = 0$ 表示 $i+1$ 为左儿子，$ch = 1$ 表示 $i + 1$ 为右儿子）。\n\n为了让你稍微减轻些负担，小 L 规定：结点 $1$ 一定是二叉树的根哦！", "outputFormat": "仅一行包含一个整数，表示最少的修改次数。", "hint": "对于 $20\\%$ 的数据：$n \\leq 10$，$a_i \\leq 100$。\n\n对于 $40\\%$ 的数据：$n \\leq 100$，$a_i \\leq 200$。\n\n对于 $60\\%$ 的数据：$n \\leq 2000$。\n\n对于 $100\\%$ 的数据：$n \\leq 10^5$，$a_i < 2^{31}$。", "locale": "zh-CN"}}}
{"pid": "P3366", "type": "P", "difficulty": 3, "samples": [["4 5\n1 2 2\n1 3 2\n1 4 3\n2 3 4\n3 4 3", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["图论", "并查集", "生成树", "模板题"], "title": "【模板】最小生成树", "background": null, "description": "如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出 `orz`。", "inputFormat": "第一行包含两个整数 $N,M$，表示该图共有 $N$ 个结点和 $M$ 条无向边。\n\n接下来 $M$ 行每行包含三个整数 $X_i,Y_i,Z_i$，表示有一条长度为 $Z_i$ 的无向边连接结点 $X_i,Y_i$。", "outputFormat": "如果该图连通，则输出一个整数表示最小生成树的各边的长度之和。如果该图不连通则输出 `orz`。", "hint": "数据规模：\n\n对于 $20\\%$ 的数据，$N\\le 5$，$M\\le 20$。\n\n对于 $40\\%$ 的数据，$N\\le 50$，$M\\le 2500$。\n\n对于 $70\\%$ 的数据，$N\\le 500$，$M\\le 10^4$。\n\n对于 $100\\%$ 的数据：$1\\le N\\le 5000$，$1\\le M\\le 2\\times 10^5$，$1\\le Z_i \\le 10^4$，$1\\le X_i,Y_i\\le N$。\n\n\n样例解释：\n\n ![](https://cdn.luogu.com.cn/upload/pic/2259.png) \n\n所以最小生成树的总边权为 $2+2+3=7$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Minimum Spanning Tree", "background": "", "description": "As stated, given an undirected graph, compute a minimum spanning tree. If the graph is disconnected, output `orz`.", "inputFormat": "The first line contains two integers $N,M$, representing that the graph has $N$ nodes and $M$ undirected edges.\nThen each of the next $M$ lines contains three integers $X_i,Y_i,Z_i$, indicating there is an undirected edge of length $Z_i$ connecting nodes $X_i$ and $Y_i$.", "outputFormat": "If the graph is connected, output a single integer equal to the sum of the edge lengths in the minimum spanning tree. If the graph is disconnected, output `orz`.", "hint": "Constraints:\n- For 20% of the testdata, $N\\le 5$, $M\\le 20$.\n- For 40% of the testdata, $N\\le 50$, $M\\le 2500$.\n- For 70% of the testdata, $N\\le 500$, $M\\le 10^4$.\n- For 100% of the testdata, $1\\le N\\le 5000$, $1\\le M\\le 2\\times 10^5$, $1\\le Z_i \\le 10^4$, $1\\le X_i,Y_i\\le N$.\n\nSample explanation:\n\n![](https://cdn.luogu.com.cn/upload/pic/2259.png)\n\nTherefore, the total edge weight of the minimum spanning tree is $2+2+3=7$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】最小生成树", "background": null, "description": "如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出 `orz`。", "inputFormat": "第一行包含两个整数 $N,M$，表示该图共有 $N$ 个结点和 $M$ 条无向边。\n\n接下来 $M$ 行每行包含三个整数 $X_i,Y_i,Z_i$，表示有一条长度为 $Z_i$ 的无向边连接结点 $X_i,Y_i$。", "outputFormat": "如果该图连通，则输出一个整数表示最小生成树的各边的长度之和。如果该图不连通则输出 `orz`。", "hint": "数据规模：\n\n对于 $20\\%$ 的数据，$N\\le 5$，$M\\le 20$。\n\n对于 $40\\%$ 的数据，$N\\le 50$，$M\\le 2500$。\n\n对于 $70\\%$ 的数据，$N\\le 500$，$M\\le 10^4$。\n\n对于 $100\\%$ 的数据：$1\\le N\\le 5000$，$1\\le M\\le 2\\times 10^5$，$1\\le Z_i \\le 10^4$，$1\\le X_i,Y_i\\le N$。\n\n\n样例解释：\n\n ![](https://cdn.luogu.com.cn/upload/pic/2259.png) \n\n所以最小生成树的总边权为 $2+2+3=7$。", "locale": "zh-CN"}}}
{"pid": "P3367", "type": "P", "difficulty": 3, "samples": [["4 7\n2 1 2\n1 1 2\n2 1 2\n1 3 4\n2 1 4\n1 2 3\n2 1 4", "N\nY\nN\nY\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["并查集", "O2优化", "模板题"], "title": "【模板】并查集", "background": "**本题数据范围已经更新到 $1\\le N\\le 2\\times 10^5$，$1\\le M\\le 10^6$。**", "description": "如题，现在有一个并查集，你需要完成合并和查询操作。\n", "inputFormat": "第一行包含两个整数 $N,M$ ,表示共有 $N$ 个元素和 $M$ 个操作。\n\n接下来 $M$ 行，每行包含三个整数 $Z_i,X_i,Y_i$ 。\n\n当 $Z_i=1$ 时，将 $X_i$ 与 $Y_i$ 所在的集合合并。\n\n当 $Z_i=2$ 时，输出 $X_i$ 与 $Y_i$ 是否在同一集合内，是的输出 \n `Y` ；否则输出 `N` 。", "outputFormat": "对于每一个 $Z_i=2$ 的操作，都有一行输出，每行包含一个大写字母，为 `Y` 或者 `N` 。 ", "hint": "对于 $15\\%$ 的数据，$N \\le 10$，$M \\le 20$。\n\n对于 $35\\%$ 的数据，$N \\le 100$，$M \\le 10^3$。\n\n对于 $50\\%$ 的数据，$1\\le N \\le 10^4$，$1\\le M \\le 2\\times 10^5$。\n\n对于 $100\\%$ 的数据，$1\\le N\\le 2\\times 10^5$，$1\\le M\\le 10^6$，$1 \\le X_i, Y_i \\le N$，$Z_i \\in \\{ 1, 2 \\}$。", "locale": "zh-CN", "translations": {"en": {"title": "【Template】Disjoint Set Union", "background": "**The constraints for this problem have been updated to $1 \\le N \\le 2 \\times 10^5$, $1 \\le M \\le 10^6$.**", "description": "As stated, there is a disjoint set union (union-find). You need to perform union and query operations.", "inputFormat": "The first line contains two integers $N, M$, representing $N$ elements and $M$ operations.\n\nThe next $M$ lines each contain three integers $Z_i, X_i, Y_i$.\n\nWhen $Z_i = 1$, union the sets containing $X_i$ and $Y_i$.\n\nWhen $Z_i = 2$, output whether $X_i$ and $Y_i$ are in the same set. Output `Y` if yes; otherwise output `N`.", "outputFormat": "For each operation with $Z_i = 2$, output one line containing a single uppercase letter, either `Y` or `N`.", "hint": "For $15\\%$ of the testdata, $N \\le 10$, $M \\le 20$.\n\nFor $35\\%$ of the testdata, $N \\le 100$, $M \\le 10^3$.\n\nFor $50\\%$ of the testdata, $1 \\le N \\le 10^4$, $1 \\le M \\le 2 \\times 10^5$.\n\nFor $100\\%$ of the testdata, $1 \\le N \\le 2 \\times 10^5$, $1 \\le M \\le 10^6$, $1 \\le X_i, Y_i \\le N$, $Z_i \\in \\{ 1, 2 \\}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】并查集", "background": "**本题数据范围已经更新到 $1\\le N\\le 2\\times 10^5$，$1\\le M\\le 10^6$。**", "description": "如题，现在有一个并查集，你需要完成合并和查询操作。\n", "inputFormat": "第一行包含两个整数 $N,M$ ,表示共有 $N$ 个元素和 $M$ 个操作。\n\n接下来 $M$ 行，每行包含三个整数 $Z_i,X_i,Y_i$ 。\n\n当 $Z_i=1$ 时，将 $X_i$ 与 $Y_i$ 所在的集合合并。\n\n当 $Z_i=2$ 时，输出 $X_i$ 与 $Y_i$ 是否在同一集合内，是的输出 \n `Y` ；否则输出 `N` 。", "outputFormat": "对于每一个 $Z_i=2$ 的操作，都有一行输出，每行包含一个大写字母，为 `Y` 或者 `N` 。 ", "hint": "对于 $15\\%$ 的数据，$N \\le 10$，$M \\le 20$。\n\n对于 $35\\%$ 的数据，$N \\le 100$，$M \\le 10^3$。\n\n对于 $50\\%$ 的数据，$1\\le N \\le 10^4$，$1\\le M \\le 2\\times 10^5$。\n\n对于 $100\\%$ 的数据，$1\\le N\\le 2\\times 10^5$，$1\\le M\\le 10^6$，$1 \\le X_i, Y_i \\le N$，$Z_i \\in \\{ 1, 2 \\}$。", "locale": "zh-CN"}}}
{"pid": "P3368", "type": "P", "difficulty": 4, "samples": [["5 5\n1 5 4 2 3\n1 2 4 2\n2 3\n1 1 5 -1\n1 3 5 7\n2 4", "6\n10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["树状数组", "差分", "模板题"], "title": "【模板】树状数组 2", "background": null, "description": "如题，已知一个数列，你需要进行下面两种操作：\n\n1. 将某区间每一个数加上 $x$；\n\n2. 求出某一个数的值。", "inputFormat": "第一行包含两个整数 $N$、$M$，分别表示该数列数字的个数和操作的总个数。\n\n第二行包含 $N$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i $ 项的初始值。\n\n接下来 $M$ 行每行包含 $2$ 或 $4$ 个整数，表示一个操作，具体如下：\n\n操作 $1$： 格式：`1 x y k` 含义：将区间 $[x,y]$ 内每个数加上 $k$；\n\n操作 $2$： 格式：`2 x` 含义：输出第 $x$ 个数的值。", "outputFormat": "输出包含若干行整数，即为所有操作 $2$ 的结果。", "hint": "#### 样例 1 解释：\n\n ![](https://cdn.luogu.com.cn/upload/pic/2258.png) \n\n故输出结果为 $6$ 和 $10$。\n\n---\n\n#### 数据规模与约定\n\n对于 $30\\%$ 的数据：$N\\le8$，$M\\le10$；\n\n对于 $70\\%$ 的数据：$N\\le 10^4$，$M\\le10^4$；\n\n对于 $100\\%$ 的数据：$1 \\leq N, M\\le 5\\times10^5$，$1 \\leq x, y \\leq n$，保证任意时刻序列中任意元素的绝对值都不大于 $2^{30}$。", "locale": "zh-CN", "translations": {"en": {"title": "【Template】Fenwick Tree 2", "background": "", "description": "As stated, given a sequence, you need to perform the following two operations:\n1. Add $x$ to every number in a given interval.\n2. Query the value of a specific element.", "inputFormat": "The first line contains two integers $N$ and $M$, representing the number of elements in the sequence and the total number of operations.\n\nThe second line contains $N$ space-separated integers, where the $i$-th number is the initial value of the $i$-th element of the sequence.\n\nEach of the next $M$ lines contains $2$ or $4$ integers describing an operation, as follows:\n\nOperation 1: Format: `1 x y k` Meaning: add $k$ to every number in the interval $[x,y]$.\n\nOperation 2: Format: `2 x` Meaning: output the value of the $x$-th number.", "outputFormat": "Output several lines of integers, which are the results of all type 2 operations.", "hint": "Explanation for Sample 1:\n\n![](https://cdn.luogu.com.cn/upload/pic/2258.png)\n\nTherefore, the outputs are $6$ and $10$.\n\n---\n\nConstraints\n\nFor $30\\%$ of the testdata: $N\\le8$, $M\\le10$.\n\nFor $70\\%$ of the testdata: $N\\le 10^4$, $M\\le10^4$.\n\nFor $100\\%$ of the testdata: $1 \\leq N, M\\le 5\\times10^5$, $1 \\leq x, y \\leq n$. It is guaranteed that at any time, the absolute value of any element in the sequence does not exceed $2^{30}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】树状数组 2", "background": null, "description": "如题，已知一个数列，你需要进行下面两种操作：\n\n1. 将某区间每一个数加上 $x$；\n\n2. 求出某一个数的值。", "inputFormat": "第一行包含两个整数 $N$、$M$，分别表示该数列数字的个数和操作的总个数。\n\n第二行包含 $N$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i $ 项的初始值。\n\n接下来 $M$ 行每行包含 $2$ 或 $4$ 个整数，表示一个操作，具体如下：\n\n操作 $1$： 格式：`1 x y k` 含义：将区间 $[x,y]$ 内每个数加上 $k$；\n\n操作 $2$： 格式：`2 x` 含义：输出第 $x$ 个数的值。", "outputFormat": "输出包含若干行整数，即为所有操作 $2$ 的结果。", "hint": "#### 样例 1 解释：\n\n ![](https://cdn.luogu.com.cn/upload/pic/2258.png) \n\n故输出结果为 $6$ 和 $10$。\n\n---\n\n#### 数据规模与约定\n\n对于 $30\\%$ 的数据：$N\\le8$，$M\\le10$；\n\n对于 $70\\%$ 的数据：$N\\le 10^4$，$M\\le10^4$；\n\n对于 $100\\%$ 的数据：$1 \\leq N, M\\le 5\\times10^5$，$1 \\leq x, y \\leq n$，保证任意时刻序列中任意元素的绝对值都不大于 $2^{30}$。", "locale": "zh-CN"}}}
