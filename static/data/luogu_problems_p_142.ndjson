{"pid": "P3878", "type": "P", "difficulty": 5, "samples": [["2\n3\n2 2 4\n4\n1 2 3 6\n", "0\n2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "各省省选", "O2优化", "模拟退火", "进制", "天津", "折半搜索 meet in the middle"], "title": "[TJOI2010] 分金币", "background": "", "description": "现在有 $n$ 枚金币，它们可能会有不同的价值，第 $i$ 枚金币的价值为 $v_i$。\n\n现在要把它们分成两部分，要求这两部分金币数目之差不超过 $1$，问这样分成的两部分金币的价值之差最小是多少？\n\n", "inputFormat": "**本题单个测试点内有多组测试数据**。\n\n输入的第一行是一个正整数 $T$，表示该测试点内数据组数。\n\n对于每组测试数据的格式为：\n\n每组测试数据占两行。\n\n第一行是一个整数 $n$，表示金币的个数。\n\n第二行有 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个金币的价值 $v_i$。", "outputFormat": "对于每组数据输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n- 对 $30\\%$ 的数据，保证 $1 \\leq v_i \\leq 1000$\n- 对于 $100\\%$ 的数据，保证 $1 \\leq T \\leq 20$，$1 \\leq n \\leq 30$，$1 \\leq v_i \\leq 2^{30}$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2010] Dividing Coins", "background": "", "description": "There are $n$ coins, which may have different values. The value of the $i$-th coin is $v_i$.\n\nNow we need to split them into two parts such that the difference in the numbers of coins does not exceed $1$. What is the minimum possible difference between the total values of the two parts?", "inputFormat": "This problem contains multiple sets of testdata within a single test point.\n\nThe first line contains a positive integer $T$, denoting the number of test cases in this test point.\n\nFor each test case:\n\nEach test case consists of two lines.\n\nThe first line contains an integer $n$, denoting the number of coins.\n\nThe second line contains $n$ integers. The $i$-th integer denotes the value $v_i$ of the $i$-th coin.", "outputFormat": "For each test case, output one line with a single integer denoting the answer.", "hint": "Constraints\n\n- For $30\\%$ of the data, it is guaranteed that $1 \\leq v_i \\leq 1000$.\n- For $100\\%$ of the testdata, it is guaranteed that $1 \\leq T \\leq 20$, $1 \\leq n \\leq 30$, $1 \\leq v_i \\leq 2^{30}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2010] 分金币", "background": "", "description": "现在有 $n$ 枚金币，它们可能会有不同的价值，第 $i$ 枚金币的价值为 $v_i$。\n\n现在要把它们分成两部分，要求这两部分金币数目之差不超过 $1$，问这样分成的两部分金币的价值之差最小是多少？\n\n", "inputFormat": "**本题单个测试点内有多组测试数据**。\n\n输入的第一行是一个正整数 $T$，表示该测试点内数据组数。\n\n对于每组测试数据的格式为：\n\n每组测试数据占两行。\n\n第一行是一个整数 $n$，表示金币的个数。\n\n第二行有 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个金币的价值 $v_i$。", "outputFormat": "对于每组数据输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n- 对 $30\\%$ 的数据，保证 $1 \\leq v_i \\leq 1000$\n- 对于 $100\\%$ 的数据，保证 $1 \\leq T \\leq 20$，$1 \\leq n \\leq 30$，$1 \\leq v_i \\leq 2^{30}$。", "locale": "zh-CN"}}}
{"pid": "P3879", "type": "P", "difficulty": 2, "samples": [["3\n9 you are a good boy ha ha o yeah\n13 o my god you like bleach naruto one piece and so do i\n11 but i do not think you will get all the points\n5\nyou\ni\no\nall\nnaruto\n", "1 2 3\n2 3\n1 2\n3\n2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "2010", "各省省选", "哈希 hashing", "字典树 Trie", "天津", "STL"], "title": "[TJOI2010] 阅读理解", "background": "", "description": "英语老师留了 $N$ 篇阅读理解作业，但是每篇英文短文都有很多生词需要查字典，为了节约时间，现在要做个统计，算一算某些生词都在哪几篇短文中出现过。", "inputFormat": "第一行为整数 $N$ ，表示短文篇数，其中每篇短文只含空格和小写字母。\n\n按下来的 $N$ 行，每行描述一篇短文。每行的开头是一个整数 $L$ ，表示这篇短文由 $L$ 个单词组成。接下来是 $L$ 个单词，单词之间用一个空格分隔。\n\n然后为一个整数 $M$ ，表示要做几次询问。后面有 $M$ 行，每行表示一个要统计的生词。\n", "outputFormat": "对于每个生词输出一行，统计其在哪几篇短文中出现过，并按从小到大输出短文的序号，序号不应有重复，序号之间用一个空格隔开（注意第一个序号的前面和最后一个序号的后面不应有空格）。如果该单词一直没出现过，则输出一个空行。\n", "hint": "对于 $30\\%$ 的数据， $1\\le M\\le 10^3$ 。\n\n对于 $100\\%$ 的数据，$1\\le M\\le 10^4$，$1\\le N\\le 10^3$ 。\n\n每篇短文长度（含相邻单词之间的空格）$\\le 5\\times 10^3$ 字符，每个单词长度 $\\le 20$ 字符。\n\n感谢@钟梓俊添加的一组数据。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2010] Reading Comprehension", "background": "", "description": "The English teacher assigned $N$ reading-comprehension passages. Each passage contains many unfamiliar words that would require checking a dictionary. To save time, we want to collect statistics to determine in which passages certain words appear.", "inputFormat": "The first line contains an integer $N$, the number of passages. Each passage contains only spaces and lowercase letters.\n\nThe next $N$ lines each describe one passage. Each line begins with an integer $L$, the number of words in that passage. Then follow $L$ words, separated by a single space.\n\nThen an integer $M$ follows, the number of queries. After that, there are $M$ lines, each containing one word to query.", "outputFormat": "For each query word, output one line listing the indices of the passages in which it appears, in ascending order, without duplicates. Indices are separated by a single space (note that there should be no space before the first index or after the last index). If the word never appears, output an empty line.", "hint": "For $30\\%$ of the testdata, $1\\le M\\le 10^3$.\n\nFor $100\\%$ of the testdata, $1\\le M\\le 10^4$, $1\\le N\\le 10^3$.\n\nEach passage length (including spaces between adjacent words) $\\le 5\\times 10^3$ characters, and each word length $\\le 20$ characters.\n\nThanks to @钟梓俊 for adding a set of testdata.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2010] 阅读理解", "background": "", "description": "英语老师留了 $N$ 篇阅读理解作业，但是每篇英文短文都有很多生词需要查字典，为了节约时间，现在要做个统计，算一算某些生词都在哪几篇短文中出现过。", "inputFormat": "第一行为整数 $N$ ，表示短文篇数，其中每篇短文只含空格和小写字母。\n\n按下来的 $N$ 行，每行描述一篇短文。每行的开头是一个整数 $L$ ，表示这篇短文由 $L$ 个单词组成。接下来是 $L$ 个单词，单词之间用一个空格分隔。\n\n然后为一个整数 $M$ ，表示要做几次询问。后面有 $M$ 行，每行表示一个要统计的生词。\n", "outputFormat": "对于每个生词输出一行，统计其在哪几篇短文中出现过，并按从小到大输出短文的序号，序号不应有重复，序号之间用一个空格隔开（注意第一个序号的前面和最后一个序号的后面不应有空格）。如果该单词一直没出现过，则输出一个空行。\n", "hint": "对于 $30\\%$ 的数据， $1\\le M\\le 10^3$ 。\n\n对于 $100\\%$ 的数据，$1\\le M\\le 10^4$，$1\\le N\\le 10^3$ 。\n\n每篇短文长度（含相邻单词之间的空格）$\\le 5\\times 10^3$ 字符，每个单词长度 $\\le 20$ 字符。\n\n感谢@钟梓俊添加的一组数据。", "locale": "zh-CN"}}}
{"pid": "P3880", "type": "P", "difficulty": 3, "samples": [["Upomoc! Lpv s nm pkrl sv smglsnk.", "......! ... . .. .... .. ........ \nUpomoc! Lp. . .. .... .. ........ \nUpomoc! Lpv s nm pkrl s. ........\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串", "2008", "各省省选", "吉林"], "title": "[JLOI2008] 提示问题", "background": "", "description": "最近在 JLOI 网上的一个流行游戏中，选手要回答很难的问题。假如在规定时间内不能回答，系统将给出 $1$ 个提示，之后再依次给出第 $2,3$ 个提示。出现在答案中的是字母和下列字符：\n\n$\\verb|. , : ; ! ? - |$ 和空格（空格不会在开头和结尾出现）。\n\n字母是指：小写字母 $\\verb!a! \\cdots \\verb!z!$ 大写字母 $\\verb!A! \\cdots \\verb!Z!$，其中 a e i o u A E I O U 是元音字母。\n\n生成提示的规则：\n\n- 第 $1$ 个提示：简单的将所有字母换成 $\\verb!.!$ 即可；\n- 第 $2$ 个提示：从第 $1$ 个提示而来，将所有字母的个数求出，再将总个数除以三，得到的最接近商的自然数 $N$，将第 $1$ 个提示中的前 $N$ 个字母显示；\n- 第 $3$ 个提示：从第 $2$ 个提示而来，将剩下的元音字母显示。假如没有可显示的元音字母，则从第 $1$ 个提示而来，即我们将前 $2/3$ 的字母显示（同样如不能被 $3$ 整除则取最接近的整数）。", "inputFormat": "仅一行，给出问题，问题字符数最多不超过 $50$。\n", "outputFormat": "三行：按规则输出的三行提示。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[JLOI2008] Hint Problem", "background": "", "description": "In a popular game on the JLOI website, players must answer difficult questions. If they cannot answer within the time limit, the system provides $1$ hint, followed by the $2$nd and $3$rd hints in order. The answer consists of letters and the following characters:\n\n$\\verb|. , : ; ! ? - |$ and spaces (spaces do not appear at the beginning or the end).\n\nLetters are: lowercase letters $\\verb!a! \\cdots \\verb!z!$ and uppercase letters $\\verb!A! \\cdots \\verb!Z!$, where a e i o u A E I O U are vowels.\n\nRules for generating hints:\n- 1st hint: simply replace all letters with $\\verb!.!$.\n- 2nd hint: derived from the 1st hint. Count all letters, divide the total by three, take the natural number $N$ closest to the quotient, and reveal the first $N$ letters.\n- 3rd hint: derived from the 2nd hint, reveal the remaining vowels. If there are no vowels to reveal, derive it from the 1st hint instead, i.e., reveal the first $2/3$ of the letters (if it is not divisible by $3$, round to the nearest integer as well).", "inputFormat": "One line containing the question, with at most $50$ characters.", "outputFormat": "Three lines: the three hints produced according to the rules.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JLOI2008] 提示问题", "background": "", "description": "最近在 JLOI 网上的一个流行游戏中，选手要回答很难的问题。假如在规定时间内不能回答，系统将给出 $1$ 个提示，之后再依次给出第 $2,3$ 个提示。出现在答案中的是字母和下列字符：\n\n$\\verb|. , : ; ! ? - |$ 和空格（空格不会在开头和结尾出现）。\n\n字母是指：小写字母 $\\verb!a! \\cdots \\verb!z!$ 大写字母 $\\verb!A! \\cdots \\verb!Z!$，其中 a e i o u A E I O U 是元音字母。\n\n生成提示的规则：\n\n- 第 $1$ 个提示：简单的将所有字母换成 $\\verb!.!$ 即可；\n- 第 $2$ 个提示：从第 $1$ 个提示而来，将所有字母的个数求出，再将总个数除以三，得到的最接近商的自然数 $N$，将第 $1$ 个提示中的前 $N$ 个字母显示；\n- 第 $3$ 个提示：从第 $2$ 个提示而来，将剩下的元音字母显示。假如没有可显示的元音字母，则从第 $1$ 个提示而来，即我们将前 $2/3$ 的字母显示（同样如不能被 $3$ 整除则取最接近的整数）。", "inputFormat": "仅一行，给出问题，问题字符数最多不超过 $50$。\n", "outputFormat": "三行：按规则输出的三行提示。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3881", "type": "P", "difficulty": 7, "samples": [["5\n0110\n00\n111\n001100\n110\n", "9\n001100110\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "动态规划 DP", "搜索", "2008", "各省省选", "吉林", "图论建模", "最短路"], "title": "[JLOI2008] CODES", "background": null, "description": "给定 $n$ 个 $\\texttt{01}$ 编码串 $S_1,S_2,\\dots,S_n$，你的任务是寻找一个编码串 $T$，使得它至少可以被分解为两种不同的 $S_i$ 的排列。\n\n例如：\n\n给定 $5$ 个 $\\texttt{01}$ 编码串：$S_1=\\texttt{0110},S_2=\\texttt{00},S_3=\\texttt{111},S_4=\\texttt{001100},S_5=\\texttt{110}$。那么一个符合要求的编码串 $T$ 是：$\\texttt{001100110}$，它有以下两种分解方法：\n\n$\\texttt{00}+\\texttt{110}+\\texttt{0110} (S_2+S_5+S_1)$ 或 $\\texttt{001100}+\\texttt{110} (S_4+S_5)$\n\n而 $0110110$ 就不符合要求，它只有一种分解方法 $\\texttt{0110}+\\texttt{110} (S_1+S_5)$。\n\n你要寻找长度最短的符合要求的编码串 $T$。若有多个符合要求的最短编码串 $T$，则输出字典顺序最小的。", "inputFormat": "输入文件第一行包含一个整数 $n$，表示 $\\texttt{01}$ 编码串总数。接下来的 $n$ 行每行给出一个长度不超过 $20$ 的 $\\texttt{01}$ 编码串。", "outputFormat": "输出文件共有两行，第一行为要求的编码串 $T$ 的长度，第二行输出编码串 $T$。对所有的测试数据，问题总有解。", "hint": "- $n\\le 20$", "locale": "zh-CN", "translations": {"en": {"title": "[JLOI2008] CODES", "background": "", "description": "Given $n$ $\\texttt{01}$ code strings $S_1, S_2, \\dots, S_n$, your task is to find a code string $T$ such that it can be decomposed in at least two different ways as a concatenation of the $S_i$.\n\nFor example:\n\nGiven $5$ $\\texttt{01}$ code strings: $S_1=\\texttt{0110}, S_2=\\texttt{00}, S_3=\\texttt{111}, S_4=\\texttt{001100}, S_5=\\texttt{110}$. Then one valid code string $T$ is: \\texttt{001100110}, which has the following two decompositions:\n\n\\texttt{00}+\\texttt{110}+\\texttt{0110} $(S_2+S_5+S_1)$ or \\texttt{001100}+\\texttt{110} $(S_4+S_5)$.\n\nBut 0110110 does not meet the requirement; it has only one decomposition \\texttt{0110}+\\texttt{110} $(S_1+S_5)$.\n\nYou must find the shortest valid code string $T$. If there are multiple shortest valid code strings $T$, output the lexicographically smallest one.", "inputFormat": "The first line contains an integer $n$, the number of $\\texttt{01}$ code strings. Each of the next $n$ lines contains one $\\texttt{01}$ code string of length at most $20$.", "outputFormat": "Output two lines. The first line is the length of the required code string $T$. The second line is the code string $T$. For all the testdata, a solution always exists.", "hint": "- $n \\le 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JLOI2008] CODES", "background": null, "description": "给定 $n$ 个 $\\texttt{01}$ 编码串 $S_1,S_2,\\dots,S_n$，你的任务是寻找一个编码串 $T$，使得它至少可以被分解为两种不同的 $S_i$ 的排列。\n\n例如：\n\n给定 $5$ 个 $\\texttt{01}$ 编码串：$S_1=\\texttt{0110},S_2=\\texttt{00},S_3=\\texttt{111},S_4=\\texttt{001100},S_5=\\texttt{110}$。那么一个符合要求的编码串 $T$ 是：$\\texttt{001100110}$，它有以下两种分解方法：\n\n$\\texttt{00}+\\texttt{110}+\\texttt{0110} (S_2+S_5+S_1)$ 或 $\\texttt{001100}+\\texttt{110} (S_4+S_5)$\n\n而 $0110110$ 就不符合要求，它只有一种分解方法 $\\texttt{0110}+\\texttt{110} (S_1+S_5)$。\n\n你要寻找长度最短的符合要求的编码串 $T$。若有多个符合要求的最短编码串 $T$，则输出字典顺序最小的。", "inputFormat": "输入文件第一行包含一个整数 $n$，表示 $\\texttt{01}$ 编码串总数。接下来的 $n$ 行每行给出一个长度不超过 $20$ 的 $\\texttt{01}$ 编码串。", "outputFormat": "输出文件共有两行，第一行为要求的编码串 $T$ 的长度，第二行输出编码串 $T$。对所有的测试数据，问题总有解。", "hint": "- $n\\le 20$", "locale": "zh-CN"}}}
{"pid": "P3882", "type": "P", "difficulty": 6, "samples": [["3 3\n..N\n...\n...\n", "2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "各省省选", "吉林", "图论建模", "二分图"], "title": "[JLOI2008] 将军", "background": "", "description": "刘先生最近在学习国际象棋，使用一个叫 jloi-08 的游戏软件。在这个游戏里，不但可以和电脑普通地对弈，还可以学习著名的棋局，还有针对初学者的规则指导等丰富功能。但是…大小却要 1.4G T\\_T。\n\n言归正传，在这个软件里，为了让玩家更好地理解和运用各个棋子，有很多趣味的游戏，比如以下就是一个：\n\n给出一个棋盘和一些棋子，让你把这些棋子摆放在棋盘上，使得两两不互相攻击。你的得分由你摆放上去的棋子的个数与种类有关。\n\n这个游戏很复杂，刘先生老是玩不到高分。于是电脑便降低了难度，替刘先生摆上了一些棋子，最后只给你任意多个 bishop（教主）。\n\n现在刘先生便要考一考你，在电脑给出的这张棋盘上，最多能放几个 bishop。\n\n国际象棋中一共有 6 种棋子：\n\n- king（国王）；\n- queen（皇后）；\n- bishop（教主）；\n- knight（骑士）；\n- rook（车）；\n- pawn（步兵）。\n\n各棋子的攻击范围如下：\n\n- queen 可以攻击与它在同一行，同一列，同一条对角线的棋子；\n- knight 的攻击范围如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/pic/2669.png)\n\n- rook 攻击水平和垂直两条线上的所有格子；\n- pawn 攻击前方两条斜线方向各一格(“前方”指 $x$ 递增的方向，$x$ 行 $y$ 列）；\n- king 攻击周围 8 个方向各 1 格；\n- bishop 攻击两条对角线上的所有格子。\n\n除 knight 以外，所有棋子的攻击范围均会被别的棋子所阻挡。\n\n可惜的是这个软件也不是顶优秀，给出的棋盘上的棋子可能互相会攻击，不过你不用理会这些，你只要保证你摆放的 bishop 不与它们以及不互相攻击就可以了。", "inputFormat": "第一行是两个整数 $x,y$（$1 \\leq x,y \\leq 1024$）。\n\n下面的 $x$ 行每行 $y$ 个字符表示棋盘。\n\n其中：`K` – king，`Q` – queen，`B` – bishop，`N` – knight，`R` – rook，`P` – pawn，`.` – blank.", "outputFormat": "仅一行一个数，表示最多能够摆放的 bishop 的个数。\n", "hint": "```plain\nBBN\n...\n...\n```\n\n```plain\nBBN\n...\nB..\n```\n\n虽然看上去下面的方法比上面的优秀，但是 N 被第三行的 B 攻击了。也就是说，你需要避免的有 2 种情况： 你摆放的 bishop 之间的互相攻击以及你摆放的 bishop 与预先摆放好的棋子之间的互相攻击；但不用考虑预先摆放好的棋子之间的互相攻击。\n", "locale": "zh-CN", "translations": {"en": {"title": "[JLOI2008] General", "background": "# Description\n\nMr. Liu has recently been learning chess, using a game software called jloi-08. In this game, you can not only play against the computer in the usual way, but also study famous games, and there are rich features such as rule guidance for beginners. However, its size is 1.4G T\\_T.\n\nBack to the point. In this software, to help players better understand and use each piece, there are many interesting mini-games, such as the following:\n\nGiven a board and some pieces, you are asked to place these pieces on the board so that no two attack each other. Your score depends on the number and types of pieces you place.\n\nThis game is complex, and Mr. Liu often fails to get a high score. So the computer lowered the difficulty by pre-placing some pieces for Mr. Liu, and finally only giving you any number of bishops.\n\nNow Mr. Liu wants to test you: on the board provided by the computer, what is the maximum number of bishops you can place?\n\nThere are 6 types of pieces in chess:\n- king (国王).\n- queen (皇后).\n- bishop (教主, jiaozhu).\n- knight (骑士).\n- rook (车).\n- pawn (步兵).\n\nThe attack ranges of the pieces are as follows:\n- The queen can attack pieces in the same row, the same column, and the same diagonal.\n- The knight’s attack range is shown in the figure below:\n\n![](https://cdn.luogu.com.cn/upload/pic/2669.png)\n\n- The rook attacks all squares along the horizontal and vertical lines.\n- The pawn attacks one square diagonally forward on each side (\"forward\" means the direction of increasing $x$, with $x$ rows and $y$ columns).\n- The king attacks one square in each of the 8 surrounding directions.\n- The bishop attacks all squares along the two diagonals.\n\nExcept for the knight, the attack ranges of all pieces are blocked by other pieces.\n\nUnfortunately, this software is not perfect, and the pieces on the given board may attack each other. However, you can ignore that. You only need to ensure that the bishops you place do not attack the pre-placed pieces and do not attack each other.", "description": "Mr. Liu has recently been learning chess, using a game software called jloi-08. In this game, you can not only play against the computer in the usual way, but also study famous games, and there are rich features such as rule guidance for beginners. However, its size is 1.4G T\\_T.\n\nBack to the point. In this software, to help players better understand and use each piece, there are many interesting mini-games, such as the following:\n\nGiven a board and some pieces, you are asked to place these pieces on the board so that no two attack each other. Your score depends on the number and types of pieces you place.\n\nThis game is complex, and Mr. Liu often fails to get a high score. So the computer lowered the difficulty by pre-placing some pieces for Mr. Liu, and finally only giving you any number of bishops.\n\nNow Mr. Liu wants to test you: on the board provided by the computer, what is the maximum number of bishops you can place?\n\nThere are 6 types of pieces in chess:\n- king (国王).\n- queen (皇后).\n- bishop (教主, jiaozhu).\n- knight (骑士).\n- rook (车).\n- pawn (步兵).\n\nThe attack ranges of the pieces are as follows:\n- The queen can attack pieces in the same row, the same column, and the same diagonal.\n- The knight’s attack range is shown in the figure below:\n\n![](https://cdn.luogu.com.cn/upload/pic/2669.png)\n\n- The rook attacks all squares along the horizontal and vertical lines.\n- The pawn attacks one square diagonally forward on each side (\"forward\" means the direction of increasing $x$, with $x$ rows and $y$ columns).\n- The king attacks one square in each of the 8 surrounding directions.\n- The bishop attacks all squares along the two diagonals.\n\nExcept for the knight, the attack ranges of all pieces are blocked by other pieces.\n\nUnfortunately, this software is not perfect, and the pieces on the given board may attack each other. However, you can ignore that. You only need to ensure that the bishops you place do not attack the pre-placed pieces and do not attack each other.\n\n# Description", "inputFormat": "The first line contains two integers $x,y$ ($1 \\leq x,y \\leq 1024$).\n\nThe next $x$ lines each contain $y$ characters describing the board.\n\nHere: `K` – king, `Q` – queen, `B` – bishop, `N` – knight, `R` – rook, `P` – pawn, `.` – blank.", "outputFormat": "Output a single number on one line, indicating the maximum number of bishops that can be placed.", "hint": "```plain\nBBN\n...\n...\n```\n\n```plain\nBBN\n...\nB..\n```\n\nAlthough the method below looks better than the one above, the N is attacked by the B in the third row. That is, there are two situations you must avoid: mutual attacks among the bishops you place, and attacks between the bishops you place and the pre-placed pieces. You do not need to consider attacks among the pre-placed pieces.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JLOI2008] 将军", "background": "", "description": "刘先生最近在学习国际象棋，使用一个叫 jloi-08 的游戏软件。在这个游戏里，不但可以和电脑普通地对弈，还可以学习著名的棋局，还有针对初学者的规则指导等丰富功能。但是…大小却要 1.4G T\\_T。\n\n言归正传，在这个软件里，为了让玩家更好地理解和运用各个棋子，有很多趣味的游戏，比如以下就是一个：\n\n给出一个棋盘和一些棋子，让你把这些棋子摆放在棋盘上，使得两两不互相攻击。你的得分由你摆放上去的棋子的个数与种类有关。\n\n这个游戏很复杂，刘先生老是玩不到高分。于是电脑便降低了难度，替刘先生摆上了一些棋子，最后只给你任意多个 bishop（教主）。\n\n现在刘先生便要考一考你，在电脑给出的这张棋盘上，最多能放几个 bishop。\n\n国际象棋中一共有 6 种棋子：\n\n- king（国王）；\n- queen（皇后）；\n- bishop（教主）；\n- knight（骑士）；\n- rook（车）；\n- pawn（步兵）。\n\n各棋子的攻击范围如下：\n\n- queen 可以攻击与它在同一行，同一列，同一条对角线的棋子；\n- knight 的攻击范围如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/pic/2669.png)\n\n- rook 攻击水平和垂直两条线上的所有格子；\n- pawn 攻击前方两条斜线方向各一格(“前方”指 $x$ 递增的方向，$x$ 行 $y$ 列）；\n- king 攻击周围 8 个方向各 1 格；\n- bishop 攻击两条对角线上的所有格子。\n\n除 knight 以外，所有棋子的攻击范围均会被别的棋子所阻挡。\n\n可惜的是这个软件也不是顶优秀，给出的棋盘上的棋子可能互相会攻击，不过你不用理会这些，你只要保证你摆放的 bishop 不与它们以及不互相攻击就可以了。", "inputFormat": "第一行是两个整数 $x,y$（$1 \\leq x,y \\leq 1024$）。\n\n下面的 $x$ 行每行 $y$ 个字符表示棋盘。\n\n其中：`K` – king，`Q` – queen，`B` – bishop，`N` – knight，`R` – rook，`P` – pawn，`.` – blank.", "outputFormat": "仅一行一个数，表示最多能够摆放的 bishop 的个数。\n", "hint": "```plain\nBBN\n...\n...\n```\n\n```plain\nBBN\n...\nB..\n```\n\n虽然看上去下面的方法比上面的优秀，但是 N 被第三行的 B 攻击了。也就是说，你需要避免的有 2 种情况： 你摆放的 bishop 之间的互相攻击以及你摆放的 bishop 与预先摆放好的棋子之间的互相攻击；但不用考虑预先摆放好的棋子之间的互相攻击。\n", "locale": "zh-CN"}}}
{"pid": "P3883", "type": "P", "difficulty": 6, "samples": [["2 5\n3\nKing's Knight Opening\nPe4\nPe5\nNf3\n3\nNimzowitsch Variation\nPc4\nPe5\nNf3\nPe4\nPe5\nNf3\nNc6\nBb5\n", "King's Knight Opening"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "各省省选", "吉林"], "title": "[JLOI2008] 棋局定式", "background": "", "description": "在“jloi-08”游戏中，还存有非常非常多的棋局定式，也就是常会用到的下棋的组合。有时在学习一个著名棋局时，电脑会考一考刘先生：在这局棋里面，有多少个定式啊？分别是什么啊？\n\n\n对于30~40步的普通棋局，刘先生还能回答出来，可是有时候2个实力相当的大牛下的棋局，2000000步都有可能。如果电脑对这样的棋局提上面的问题时，刘先生就必须写一个程序来帮助自己了。可是，刘先生在这方面却…，怎么写也写不对。你能帮助刘先生吗？\n\n\n棋局是由很多step组成的，而step是由一个字符串组成的，比如Kh2或者是Nxb7。\n\n前者表示K(king)移动至h2格，后者表示N(knight)移动至b7格并吃掉原有的棋子。\n\n\n第一个字符可能有6种：K Q B N R P，而后面可能是一个坐标或者是字符x后跟一个坐标。\n\n\n坐标是由一个小写英文字母(a~h)和一个数字(1~8)组成的。\n\n\n如果一个棋局中完整地并连续地包含一个定式中所有的step，那么这个棋局便包含这个定式。\n", "inputFormat": "第一行2个整数n, m，表示定式的个数(1<=n<=2000)以及这个棋局所包含的步数\n\n\n下面的n个块(block)，每块包含：\n\n第一行一个整数k表示定式包含的步数(1<=k<=100000, ∑k<=200000)\n\n第二行一个字符串表示该定式的名称(长度不超过50)\n\n下面的k行每行一个字符串表示定式中的一步\n\n\n最后的m行每行一个字符串，表示棋局中的一步\n", "outputFormat": "按照输入文件包含的定式的顺序，输出棋局包含的所有定式的名称，一个一行。\n", "hint": "不保证给出的棋局和定式符合国际象棋的规则。\n", "locale": "zh-CN", "translations": {"en": {"title": "[JLOI2008] Standard Sequences in a Chess Game", "background": "", "description": "In the \"jloi-08\" game, there are a large number of standard sequences, that is, commonly used combinations of moves. Sometimes, when studying a famous game, the computer will quiz Mr. Liu: How many standard sequences are in this game? What are they?\n\nFor ordinary games with $30$ to $40$ moves, Mr. Liu can still answer. But sometimes, in a game between two equally strong players, there may be as many as $2000000$ moves. If the computer asks the above questions about such a game, Mr. Liu must write a program to help himself. However, Mr. Liu is not good at this... He keeps getting it wrong. Can you help him?\n\nA game consists of many steps, and a step is represented by a string, such as Kh2 or Nxb7.\n\nThe former means K (king) moves to h2, and the latter means N (knight) moves to b7 and captures the piece there.\n\nThe first character can be one of 6 types: K Q B N R P, and the rest is either a coordinate or the character x followed by a coordinate.\n\nA coordinate consists of a lowercase letter from a to h and a digit from 1 to 8.\n\nIf a game contains all the steps of a standard sequence completely and consecutively, then the game contains that standard sequence.", "inputFormat": "The first line contains two integers $n, m$, representing the number of standard sequences ($1 \\le n \\le 2000$) and the number of steps in the game.\n\nThen follow $n$ blocks; each block contains:\n- The first line contains an integer $k$, the number of steps in the standard sequence ($1 \\le k \\le 100000$, $\\sum k \\le 200000$).\n- The second line contains a string, the name of the standard sequence (length no more than $50$).\n- Each of the next $k$ lines contains one string, representing one step in the standard sequence.\n\nEach of the last $m$ lines contains one string, representing one step in the game.", "outputFormat": "In the order of the input, output the names of all standard sequences contained in the game, one per line.", "hint": "It is not guaranteed that the given game and standard sequences comply with the rules of chess.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JLOI2008] 棋局定式", "background": "", "description": "在“jloi-08”游戏中，还存有非常非常多的棋局定式，也就是常会用到的下棋的组合。有时在学习一个著名棋局时，电脑会考一考刘先生：在这局棋里面，有多少个定式啊？分别是什么啊？\n\n\n对于30~40步的普通棋局，刘先生还能回答出来，可是有时候2个实力相当的大牛下的棋局，2000000步都有可能。如果电脑对这样的棋局提上面的问题时，刘先生就必须写一个程序来帮助自己了。可是，刘先生在这方面却…，怎么写也写不对。你能帮助刘先生吗？\n\n\n棋局是由很多step组成的，而step是由一个字符串组成的，比如Kh2或者是Nxb7。\n\n前者表示K(king)移动至h2格，后者表示N(knight)移动至b7格并吃掉原有的棋子。\n\n\n第一个字符可能有6种：K Q B N R P，而后面可能是一个坐标或者是字符x后跟一个坐标。\n\n\n坐标是由一个小写英文字母(a~h)和一个数字(1~8)组成的。\n\n\n如果一个棋局中完整地并连续地包含一个定式中所有的step，那么这个棋局便包含这个定式。\n", "inputFormat": "第一行2个整数n, m，表示定式的个数(1<=n<=2000)以及这个棋局所包含的步数\n\n\n下面的n个块(block)，每块包含：\n\n第一行一个整数k表示定式包含的步数(1<=k<=100000, ∑k<=200000)\n\n第二行一个字符串表示该定式的名称(长度不超过50)\n\n下面的k行每行一个字符串表示定式中的一步\n\n\n最后的m行每行一个字符串，表示棋局中的一步\n", "outputFormat": "按照输入文件包含的定式的顺序，输出棋局包含的所有定式的名称，一个一行。\n", "hint": "不保证给出的棋局和定式符合国际象棋的规则。\n", "locale": "zh-CN"}}}
{"pid": "P3884", "type": "P", "difficulty": 3, "samples": [["10                                \n1 2                            \n1 3                            \n2 4\n2 5\n3 6\n3 7\n5 8\n5 9\n6 10\n8 6\n", "4\n4\n8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2009", "各省省选", "吉林", "深度优先搜索 DFS", "最近公共祖先 LCA"], "title": "[JLOI2009] 二叉树问题", "background": "", "description": "如下图所示的一棵二叉树的深度、宽度及结点间距离分别为：\n\n- 深度：$4$\n- 宽度：$4$\n- 结点 8 和 6 之间的距离：$8$\n- 结点 7 和 6 之间的距离：$3$\n\n其中宽度表示二叉树上同一层最多的结点个数，节点 $u, v$ 之间的距离表示从 $u$ 到 $v$ 的最短有向路径上向根节点的边数的两倍加上向叶节点的边数。\n\n![](https://cdn.luogu.com.cn/upload/pic/6843.png)\n\n给定一颗以 1 号结点为根的二叉树，请求出其深度、宽度和两个指定节点 $x, y$ 之间的距离。\n", "inputFormat": "第一行是一个整数，表示树的结点个数 $n$。  \n接下来 $n - 1$ 行，每行两个整数 $u, v$，表示树上存在一条连接 $u, v$ 的边。  \n最后一行有两个整数 $x, y$，表示求 $x, y$ 之间的距离。", "outputFormat": "输出三行，每行一个整数，依次表示二叉树的深度、宽度和 $x, y$ 之间的距离。", "hint": "对于全部的测试点，保证 $1 \\leq u, v, x, y \\leq n \\leq 100$，且给出的是一棵树。保证 $u$ 是 $v$ 的父结点。", "locale": "zh-CN", "translations": {"en": {"title": "[JLOI2009] Binary Tree Problem", "background": "", "description": "For the binary tree shown below, its depth, width, and distances between nodes are as follows:\n- Depth: $4$.\n- Width: $4$.\n- The distance between nodes 8 and 6: $8$.\n- The distance between nodes 7 and 6: $3$.\n\nHere, the width is the maximum number of nodes on the same level of the binary tree. The distance between nodes $u$ and $v$ is defined as twice the number of edges directed toward the root plus the number of edges directed toward the leaves, along the shortest directed path from $u$ to $v$.\n\n![](https://cdn.luogu.com.cn/upload/pic/6843.png)\n\nGiven a binary tree rooted at node 1, compute its depth, width, and the distance between two specified nodes $x, y$.", "inputFormat": "The first line contains an integer $n$, the number of nodes in the tree.  \nThe next $n - 1$ lines each contain two integers $u, v$, indicating that there is an edge connecting $u$ and $v$ in the tree.  \nThe last line contains two integers $x, y$, asking for the distance between $x$ and $y$.", "outputFormat": "Output three lines, each containing one integer, representing the depth, the width, and the distance between $x$ and $y$, in this order.", "hint": "For all test points, $1 \\leq u, v, x, y \\leq n \\leq 100$, and the input describes a tree. It is guaranteed that $u$ is the parent of $v$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JLOI2009] 二叉树问题", "background": "", "description": "如下图所示的一棵二叉树的深度、宽度及结点间距离分别为：\n\n- 深度：$4$\n- 宽度：$4$\n- 结点 8 和 6 之间的距离：$8$\n- 结点 7 和 6 之间的距离：$3$\n\n其中宽度表示二叉树上同一层最多的结点个数，节点 $u, v$ 之间的距离表示从 $u$ 到 $v$ 的最短有向路径上向根节点的边数的两倍加上向叶节点的边数。\n\n![](https://cdn.luogu.com.cn/upload/pic/6843.png)\n\n给定一颗以 1 号结点为根的二叉树，请求出其深度、宽度和两个指定节点 $x, y$ 之间的距离。\n", "inputFormat": "第一行是一个整数，表示树的结点个数 $n$。  \n接下来 $n - 1$ 行，每行两个整数 $u, v$，表示树上存在一条连接 $u, v$ 的边。  \n最后一行有两个整数 $x, y$，表示求 $x, y$ 之间的距离。", "outputFormat": "输出三行，每行一个整数，依次表示二叉树的深度、宽度和 $x, y$ 之间的距离。", "hint": "对于全部的测试点，保证 $1 \\leq u, v, x, y \\leq n \\leq 100$，且给出的是一棵树。保证 $u$ 是 $v$ 的父结点。", "locale": "zh-CN"}}}
{"pid": "P3885", "type": "P", "difficulty": 5, "samples": [["3  100  0  10  0  20  0", "300.000  30.000  0"], ["3  100  2  10  0.1  20  1", "422.469  23.457  1\n2  11.111\n"], ["3  100  4  10  0  20  1", "480.000  10.000  2\n1  10.000\n2  10.000\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "贪心", "2009", "各省省选", "吉林"], "title": "[JLOI2009] F1一级方程式大赛", "background": "众所周知，迈克尔·舒马赫 (Michael  Schumacher) 是当今车坛最伟大的王者，从 1991 年至 2006 年他一共参加了 260 多场比赛，获得近 100 次分站冠军，9 次年度冠军。舒马赫取得如此辉煌的战绩得益于他有一个非常优秀的智囊团。每次比赛之前他的智囊团将根据场地、气候、路况以及赛车状态，来为舒马赫制定比赛中的策略。", "description": "我们知道，在 F1 大赛中，如果赛车的其他参数都相同，赛车的速度主要取决于其载油量。载油太多就会降低赛车的速度，也会增加汽油的消耗速度；但载油太少就需要在比赛中增加进站加油的次数。因此智囊团的一个关键任务就是在每次比赛前确定舒马赫的初始载油量以及进站加油的方案，使得舒马赫完成所有赛程的总时间尽量短。\n\n\n作为智囊团的首席程序员刘博士，交给他的团队的任务是编写一个程序，为舒马赫确定比赛开始前的载油量以及比赛中进站加油的方案。", "inputFormat": "输入数据包括以下 $7$ 个数：\n\n- 比赛的总圈数 $n$（一个正整数）\n\n- 理论上，没有油的空车跑一圈所需的时间（浮点数，单位为秒）\n\n- 每增加 $1$ 公升汽油，赛车跑一圈所增加的时间（浮点数，单位为秒）\n\n- 理论上，没有油的空车跑一圈所消耗的油量（浮点数，单位为公升）\n\n- 每增加 $1$ 公升汽油，赛车跑一圈所增加的油量损耗（浮点数，单位为公升，且这个数严格小于 $1$）\n\n- 每次进站所需花费的时间（浮点数，单位为秒，这个时间不包括加油所需花费的时间，加油所花费的时间由下一个输入参数决定）\n\n- 每次进站后，每加 $1$ 公升汽油，所需花费的时间（浮点数，单位为秒）\n\n我们总是把一整圈看作一个单位。赛车在跑一圈的过程中，汽油的变化量不做考虑。加油总是在一整圈跑完以后才可以进行。", "outputFormat": "- 第一行包括三个数：\n\n 1. 舒马赫的赛车跑完所有赛程所需的最短时间（浮点数，保留小数点后三位）；\n 2. 舒马赫的赛车在比赛开始前的载油量（浮点数，保留小数点后三位）；\n 3. 舒马赫在比赛过程中进站加油的次数 $m$（整数）；\n\n\n- 接下来是 $m$ 行，每行包括两个数：\n\n 1. 第 $i$ 次进站加油时已经完成的圈数（整数）；\n 2. 第 $i$ 次进站加油所加的油量（浮点数，保留小数点后三位）；", "hint": "对于所有数据，满足 $1 \\le n \\le 100$，其余输入数据均在 $[0,100]$ 范围内。", "locale": "zh-CN", "translations": {"en": {"title": "{{[JLOI2009] F1 Grand Prix}}", "background": "{{As is well known, Michael Schumacher is the greatest champion in today’s motorsport. From 1991 to 2006, he took part in more than 260 races, won nearly 100 Grands Prix, and claimed 9 season titles. Schumacher’s remarkable record owes much to an excellent think tank. Before each race, his team sets the strategy based on the circuit, weather, track conditions, and the car’s state.}}", "description": "{{We know that in F1, if all other parameters are the same, a car’s speed mainly depends on its fuel load. Carrying too much fuel will slow the car down and increase fuel consumption per lap; carrying too little fuel requires more pit stops to refuel. Therefore, a key task for the think tank is to determine the initial fuel load and the pit-refueling plan before each race so that the total time to complete all laps is as short as possible.\n\nAs the chief programmer Dr. Liu, the team’s task is to write a program to determine Schumacher’s initial fuel load before the race and the pit-refueling plan during the race.}}", "inputFormat": "{{The input consists of the following $7$ numbers:\n- The total number of laps $n$ (a positive integer).\n- The time for a theoretically empty car with no fuel to complete one lap (floating-point, in seconds).\n- For each additional $1$ liter of fuel, the extra time per lap (floating-point, in seconds).\n- The fuel consumed per lap for a theoretically empty car with no fuel (floating-point, in liters).\n- For each additional $1$ liter of fuel, the additional fuel consumption per lap (floating-point, in liters, and this number is strictly less than $1$).\n- The time spent for each pit stop (floating-point, in seconds; this does not include the time spent refueling, which is determined by the next input parameter).\n- After each pit stop, the time spent per additional $1$ liter of fuel added (floating-point, in seconds).\n\nWe always treat one whole lap as a unit. Changes in fuel during a lap are not considered. Refueling is allowed only after completing a whole lap.}}", "outputFormat": "{{- The first line contains three numbers:\n  1. The minimum total time needed for Schumacher’s car to finish all laps (floating-point, rounded to three decimals).\n  2. The initial fuel load before the race (floating-point, rounded to three decimals).\n  3. The number of pit stops for refueling during the race $m$ (integer).\n- Then follow $m$ lines, each containing two numbers:\n  1. The number of laps completed at the time of the $i$-th pit stop for refueling (integer).\n  2. The amount of fuel added at the $i$-th pit stop (floating-point, rounded to three decimals).}}", "hint": "{{For all testdata, $1 \\le n \\le 100$, and all other input numbers lie in the range $[0, 100]$.}}\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JLOI2009] F1一级方程式大赛", "background": "众所周知，迈克尔·舒马赫 (Michael  Schumacher) 是当今车坛最伟大的王者，从 1991 年至 2006 年他一共参加了 260 多场比赛，获得近 100 次分站冠军，9 次年度冠军。舒马赫取得如此辉煌的战绩得益于他有一个非常优秀的智囊团。每次比赛之前他的智囊团将根据场地、气候、路况以及赛车状态，来为舒马赫制定比赛中的策略。", "description": "我们知道，在 F1 大赛中，如果赛车的其他参数都相同，赛车的速度主要取决于其载油量。载油太多就会降低赛车的速度，也会增加汽油的消耗速度；但载油太少就需要在比赛中增加进站加油的次数。因此智囊团的一个关键任务就是在每次比赛前确定舒马赫的初始载油量以及进站加油的方案，使得舒马赫完成所有赛程的总时间尽量短。\n\n\n作为智囊团的首席程序员刘博士，交给他的团队的任务是编写一个程序，为舒马赫确定比赛开始前的载油量以及比赛中进站加油的方案。", "inputFormat": "输入数据包括以下 $7$ 个数：\n\n- 比赛的总圈数 $n$（一个正整数）\n\n- 理论上，没有油的空车跑一圈所需的时间（浮点数，单位为秒）\n\n- 每增加 $1$ 公升汽油，赛车跑一圈所增加的时间（浮点数，单位为秒）\n\n- 理论上，没有油的空车跑一圈所消耗的油量（浮点数，单位为公升）\n\n- 每增加 $1$ 公升汽油，赛车跑一圈所增加的油量损耗（浮点数，单位为公升，且这个数严格小于 $1$）\n\n- 每次进站所需花费的时间（浮点数，单位为秒，这个时间不包括加油所需花费的时间，加油所花费的时间由下一个输入参数决定）\n\n- 每次进站后，每加 $1$ 公升汽油，所需花费的时间（浮点数，单位为秒）\n\n我们总是把一整圈看作一个单位。赛车在跑一圈的过程中，汽油的变化量不做考虑。加油总是在一整圈跑完以后才可以进行。", "outputFormat": "- 第一行包括三个数：\n\n 1. 舒马赫的赛车跑完所有赛程所需的最短时间（浮点数，保留小数点后三位）；\n 2. 舒马赫的赛车在比赛开始前的载油量（浮点数，保留小数点后三位）；\n 3. 舒马赫在比赛过程中进站加油的次数 $m$（整数）；\n\n\n- 接下来是 $m$ 行，每行包括两个数：\n\n 1. 第 $i$ 次进站加油时已经完成的圈数（整数）；\n 2. 第 $i$ 次进站加油所加的油量（浮点数，保留小数点后三位）；", "hint": "对于所有数据，满足 $1 \\le n \\le 100$，其余输入数据均在 $[0,100]$ 范围内。", "locale": "zh-CN"}}}
{"pid": "P3886", "type": "P", "difficulty": 6, "samples": [["4\n2 -1 -1 -1\n5 -5 -1 -5\n3  2 -1  3\n2 -2 -3  2\n", "18"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2009", "各省省选", "吉林", "进制", "轮廓线 DP"], "title": "[JLOI2009] 神秘的生物", "background": null, "description": "3206 年 5 月，正在钻研 ET 专业的刘博士所在的 OI 团队发现：地球受到了来自外星球的生物人的侵袭。这些生物人采取了极秘的乘法加密电文，控制了具有大量武器的军火库，攻占了大量的城市，甚至出现了 K 弹计划……\n\n刘博士所在的 OI 团队决定要发挥他们的科研机构作用（由于吉林省所在的地理位置具有特殊的优势，此科研机构全球只有吉林一处），以制伏这些外星球的生物人。他们想方设法捕获了几个外星球的生物人，经研究后发现，这些外星球的生物人在地球上的生存，取决于一个参数：生存度。他们要做的就是：找到这个参数的最大值！于是，他们开始了对这些外星球的生物人生长的研究。\n\n每次实验前，他们把一个外星球生物人的细胞随机地放在一个 $N\\times N$ 的方形培养容器的一格中，并给容器的每个格子都标了一个数值，是生物在此单元的生存度（可正可负，数值越大表示越危险）。整个生物的生存度是生物所有占据格子的生存度之和。每次实验开始后，让生物自然生长。这个生物每一单位时间都选择其身体的一部分（某个格子），随机地向与之有公共边的空格生长，例如某次实验，一开始生物只占据一个格子，然后开始了生长：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6844.png) \n\n刘博士所在的 OI 团队做了大量的实验，并且对数据进行了记录和统计。假设进行的实验次数足够多，问在实验进行的某一时刻，该生物达到的最大生存度是多少？\n\n3206 年 9 月，妄图破坏地球的外星球生物人终于被刘博士所在的 OI 团队制伏了……", "inputFormat": "输入文件第一行包括一个正整数 $N$，代表实验容器的边长。\n\n接下来 $N$ 行，每行 $N$ 个用空格隔开的整数，代表外星球生物人在每一格的生存度。", "outputFormat": "输出一行，代表实验过程中，生物达到的最大生存度。", "hint": "对于 $40\\%$ 的数据有 $N\\le 6$。\n\n对于 $100\\%$ 的数据有 $N\\le 9$。\n\n所有数据每个格子生存度的绝对值不超过 $32767$。", "locale": "zh-CN", "translations": {"en": {"title": "[JLOI2009] Mysterious Creature", "background": "", "description": "In May 3206, Dr. Liu, who was studying the ET major, and his OI team discovered that Earth had been invaded by alien “bio-people.” These bio-people used a top-secret multiplicative encrypted telegraph, seized armories with a vast number of weapons, captured many cities, and even launched the K-bomb plan.\n\nDr. Liu’s OI team decided to leverage their research institute (due to the unique geographical advantages of Jilin, this institute exists only in Jilin worldwide) to subdue these alien bio-people. They managed to capture several alien bio-people, and after research, they found that their survival on Earth depends on one parameter: the survival value. What they aimed to do was to find the maximum value of this parameter. Thus, they began studying the growth of these alien bio-people.\n\nBefore each experiment, they randomly place the cell of an alien bio-person into a cell of an $N\\times N$ square culture container, and label each cell of the container with a value, which is the survival value of the organism in that cell (can be positive or negative, and a larger value indicates greater danger). The survival value of the entire organism is the sum of the survival values of all the cells it occupies. After the experiment begins, the organism grows naturally. At each unit of time, it chooses a part of its body (some cell) and randomly grows into an empty cell that shares a common edge with it. For example, in one experiment, the organism initially occupies only one cell, and then starts growing:\n\n ![](https://cdn.luogu.com.cn/upload/pic/6844.png) \n\nDr. Liu’s OI team conducted a large number of experiments and recorded and analyzed the testdata. Assuming the number of experiments is sufficient, ask: at some moment during the experiment, what is the maximum survival value the organism can achieve?\n\nIn September 3206, the alien bio-people who attempted to destroy Earth were finally subdued by Dr. Liu’s OI team.", "inputFormat": "The first line contains a positive integer $N$, representing the side length of the experimental container.\n\nThe next $N$ lines each contain $N$ space-separated integers, representing the survival value of the alien bio-person in each cell.", "outputFormat": "Output one line, the maximum survival value achieved by the organism during the experiment.", "hint": "For 40% of the testdata, $N \\le 6$.\n\nFor 100% of the testdata, $N \\le 9$.\n\nFor all testdata, the absolute value of the survival value in each cell does not exceed $32767$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JLOI2009] 神秘的生物", "background": null, "description": "3206 年 5 月，正在钻研 ET 专业的刘博士所在的 OI 团队发现：地球受到了来自外星球的生物人的侵袭。这些生物人采取了极秘的乘法加密电文，控制了具有大量武器的军火库，攻占了大量的城市，甚至出现了 K 弹计划……\n\n刘博士所在的 OI 团队决定要发挥他们的科研机构作用（由于吉林省所在的地理位置具有特殊的优势，此科研机构全球只有吉林一处），以制伏这些外星球的生物人。他们想方设法捕获了几个外星球的生物人，经研究后发现，这些外星球的生物人在地球上的生存，取决于一个参数：生存度。他们要做的就是：找到这个参数的最大值！于是，他们开始了对这些外星球的生物人生长的研究。\n\n每次实验前，他们把一个外星球生物人的细胞随机地放在一个 $N\\times N$ 的方形培养容器的一格中，并给容器的每个格子都标了一个数值，是生物在此单元的生存度（可正可负，数值越大表示越危险）。整个生物的生存度是生物所有占据格子的生存度之和。每次实验开始后，让生物自然生长。这个生物每一单位时间都选择其身体的一部分（某个格子），随机地向与之有公共边的空格生长，例如某次实验，一开始生物只占据一个格子，然后开始了生长：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6844.png) \n\n刘博士所在的 OI 团队做了大量的实验，并且对数据进行了记录和统计。假设进行的实验次数足够多，问在实验进行的某一时刻，该生物达到的最大生存度是多少？\n\n3206 年 9 月，妄图破坏地球的外星球生物人终于被刘博士所在的 OI 团队制伏了……", "inputFormat": "输入文件第一行包括一个正整数 $N$，代表实验容器的边长。\n\n接下来 $N$ 行，每行 $N$ 个用空格隔开的整数，代表外星球生物人在每一格的生存度。", "outputFormat": "输出一行，代表实验过程中，生物达到的最大生存度。", "hint": "对于 $40\\%$ 的数据有 $N\\le 6$。\n\n对于 $100\\%$ 的数据有 $N\\le 9$。\n\n所有数据每个格子生存度的绝对值不超过 $32767$。", "locale": "zh-CN"}}}
{"pid": "P3887", "type": "P", "difficulty": 2, "samples": [["3 10 12 4\n76 60 87\n78 84 84 84 81 82 72 51 77 57\n85 84 62 87 88 64 81 90 80 66 88 85\n65 83 63 79\n2\n4 5 1\n4 4 2", "85.64\n78.00\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2014", "各省省选", "广东", "排序", "优先队列", "队列"], "title": "[GDOI2014] 世界杯", "background": "", "description": "3014 年世界杯足球赛就要开始了！作为卫冕冠军中国足球队的教练，手下每位球员都是猛将，如何摆出最强的 11 人阵容也是一件幸福的烦恼事啊。\n\n众所周知，足球阵容里的11个球员都会被分配到场上某一个特别的位置，而这些位置主要分为守门员、后卫、中场和前锋四种，其中守门员有且只有一个，后卫、中场和前锋的人数取决于你安排的足球阵型。形容足球阵型的方法由后卫开始计算至前锋，但不把守门员计算在内。例如，3-5-2 阵型是指有三个后卫、五个中场及两名前锋。由于竞争激烈，每位球员只会培养其中一种位置所需要的技能，所以他们每个人都只能胜任四个位置中的其中一种。\n\n作为一个对球员能力了如指掌的教练，你给每个球员的综合水平进行量化。为了将阵型安排得更好，你的教练团队决定使用以下策略安排球员：首先按照顺序提出 $Q$ 个阵型，分别代表第一阵型、第二阵型、……、第 $Q$ 阵型。然后对于每个阵型，从仍未选择的球员中选择最好的对应数量的守门员、后卫、中场和前锋。比如说，对于第一阵型，在所有球员中选择；对于第二阵型，在除了第一阵型外的所有球员中选择；对于第三阵型，在除了第一阵型和第二阵型外的所有球员中选择；以此类推。\n\n现在 $Q$ 个阵型都已经确定，而你需要知道的，是每个阵型的平均综合水平分别是多少。\n", "inputFormat": "第一行有四个整数 $K, D, M, F$，分别表示守门员、后卫、中场和前锋供挑选的球员人数。\n\n第二行有 $K$ 个整数 $k_i$，分别表示每个守门员的综合水平值。\n\n第三行有 $D$ 个整数 $d_i$，分别表示每个后卫的综合水平值。\n\n第四行有 $M$ 个整数 $m_i$，分别表示每个中场的综合水平值。\n\n第五行有 $F$ 个整数 $f_i$，分别表示每个前锋的综合水平值。\n\n第六行有一个整数 $Q$，表示教练团队提出的阵型个数。\n\n以下 $Q$ 行，第 $i$ 行三个整数 $A_i, B_i, C_i$，由空格间隔，表示第 $i$ 阵型是 $A_i - B_i - C_i$ 阵型。", "outputFormat": "输出 $Q$ 行。对于第 $i$ 种阵型，输出一个实数，表示该阵型平均综合水平的最大值，并四舍五入到小数点后 $2$ 位。", "hint": "对于 $30\\%$ 数据，$K, D, M, F≤1000$，$Q≤10$；\n\n对于 $100\\%$ 数据，$1≤K, D, M, F≤10^5$，$0≤k_i, d_i, m_i, f_i≤10^8$，$1≤Q≤K$，$0≤A_i, B_i, C_i≤10$，$A_i+B_i+C_i=10$，$∑A_i≤D$，$∑B_i≤M$，$∑C_i≤F$", "locale": "zh-CN", "translations": {"en": {"title": "[GDOI2014] World Cup", "background": "", "description": "The 3014 World Cup is about to begin! As the coach of the defending champion, the Chinese national football team, every player under your command is a powerhouse. Figuring out the strongest 11-player lineup is a happy kind of trouble.\n\nAs is well known, the 11 players in a football lineup are each assigned to a particular position, which are mainly divided into four types: goalkeeper, defender, midfielder, and forward. There is exactly one goalkeeper, and the number of defenders, midfielders, and forwards depends on the formation you set. A formation is expressed as $A$-$B$-$C$ from defenders to forwards, not counting the goalkeeper. For example, a 3-5-2 formation means there are three defenders, five midfielders, and two forwards. Due to fierce competition, each player is trained only for one position, so each person can play only one of the four positions.\n\nAs a coach who knows the players’ abilities inside out, you have quantified each player’s overall rating. To better arrange the formations, your coaching team decides to use the following strategy to assign players: first, propose $Q$ formations in order, representing the first formation, the second formation, …, the $Q$-th formation. Then, for each formation, choose from the players not yet selected the best available numbers of goalkeeper(s), defenders, midfielders, and forwards. For example, for the first formation, select from all players; for the second formation, select from all players except those chosen for the first formation; for the third formation, select from all players except those chosen for the first and second formations; and so on.\n\nNow that the $Q$ formations are fixed, what you need to know is the average overall rating for each formation.", "inputFormat": "The first line contains four integers $K, D, M, F$, representing the number of available goalkeepers, defenders, midfielders, and forwards.\n\nThe second line contains $K$ integers $k_i$, representing the overall rating of each goalkeeper.\n\nThe third line contains $D$ integers $d_i$, representing the overall rating of each defender.\n\nThe fourth line contains $M$ integers $m_i$, representing the overall rating of each midfielder.\n\nThe fifth line contains $F$ integers $f_i$, representing the overall rating of each forward.\n\nThe sixth line contains an integer $Q$, representing the number of formations proposed by the coaching team.\n\nEach of the following $Q$ lines contains three integers $A_i, B_i, C_i$ separated by spaces, indicating that the $i$-th formation is the $A_i$-$B_i$-$C_i$ formation.", "outputFormat": "Output $Q$ lines. For the $i$-th formation, output a real number representing the maximum possible average overall rating for that formation, rounded to $2$ decimal places.", "hint": "For $30\\%$ testdata, $K, D, M, F \\le 1000$, $Q \\le 10$.\n\nFor $100\\%$ testdata, $1 \\le K, D, M, F \\le 10^5$, $0 \\le k_i, d_i, m_i, f_i \\le 10^8$, $1 \\le Q \\le K$, $0 \\le A_i, B_i, C_i \\le 10$, $A_i + B_i + C_i = 10$, $\\sum A_i \\le D$, $\\sum B_i \\le M$, $\\sum C_i \\le F$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[GDOI2014] 世界杯", "background": "", "description": "3014 年世界杯足球赛就要开始了！作为卫冕冠军中国足球队的教练，手下每位球员都是猛将，如何摆出最强的 11 人阵容也是一件幸福的烦恼事啊。\n\n众所周知，足球阵容里的11个球员都会被分配到场上某一个特别的位置，而这些位置主要分为守门员、后卫、中场和前锋四种，其中守门员有且只有一个，后卫、中场和前锋的人数取决于你安排的足球阵型。形容足球阵型的方法由后卫开始计算至前锋，但不把守门员计算在内。例如，3-5-2 阵型是指有三个后卫、五个中场及两名前锋。由于竞争激烈，每位球员只会培养其中一种位置所需要的技能，所以他们每个人都只能胜任四个位置中的其中一种。\n\n作为一个对球员能力了如指掌的教练，你给每个球员的综合水平进行量化。为了将阵型安排得更好，你的教练团队决定使用以下策略安排球员：首先按照顺序提出 $Q$ 个阵型，分别代表第一阵型、第二阵型、……、第 $Q$ 阵型。然后对于每个阵型，从仍未选择的球员中选择最好的对应数量的守门员、后卫、中场和前锋。比如说，对于第一阵型，在所有球员中选择；对于第二阵型，在除了第一阵型外的所有球员中选择；对于第三阵型，在除了第一阵型和第二阵型外的所有球员中选择；以此类推。\n\n现在 $Q$ 个阵型都已经确定，而你需要知道的，是每个阵型的平均综合水平分别是多少。\n", "inputFormat": "第一行有四个整数 $K, D, M, F$，分别表示守门员、后卫、中场和前锋供挑选的球员人数。\n\n第二行有 $K$ 个整数 $k_i$，分别表示每个守门员的综合水平值。\n\n第三行有 $D$ 个整数 $d_i$，分别表示每个后卫的综合水平值。\n\n第四行有 $M$ 个整数 $m_i$，分别表示每个中场的综合水平值。\n\n第五行有 $F$ 个整数 $f_i$，分别表示每个前锋的综合水平值。\n\n第六行有一个整数 $Q$，表示教练团队提出的阵型个数。\n\n以下 $Q$ 行，第 $i$ 行三个整数 $A_i, B_i, C_i$，由空格间隔，表示第 $i$ 阵型是 $A_i - B_i - C_i$ 阵型。", "outputFormat": "输出 $Q$ 行。对于第 $i$ 种阵型，输出一个实数，表示该阵型平均综合水平的最大值，并四舍五入到小数点后 $2$ 位。", "hint": "对于 $30\\%$ 数据，$K, D, M, F≤1000$，$Q≤10$；\n\n对于 $100\\%$ 数据，$1≤K, D, M, F≤10^5$，$0≤k_i, d_i, m_i, f_i≤10^8$，$1≤Q≤K$，$0≤A_i, B_i, C_i≤10$，$A_i+B_i+C_i=10$，$∑A_i≤D$，$∑B_i≤M$，$∑C_i≤F$", "locale": "zh-CN"}}}
{"pid": "P3888", "type": "P", "difficulty": 5, "samples": [["3 3\n6 5 4\n1 2 3\n7 8 9", "3 6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2014", "各省省选", "广东", "枚举", "进制", "状压 DP"], "title": "[GDOI2014] 拯救莫莉斯", "background": "", "description": "莫莉斯·乔是圣域里一个叱咤风云的人物，他凭借着自身超强的经济头脑，牢牢控制了圣域的石油市场。\n\n圣域的地图可以看成是一个 $n\\times m$ 的矩阵。每个整数坐标点 $(x, y)$ 表示一座城市（$1\\le x\\le n,1\\le y\\le m$）。两座城市间相邻的定义为：对于城市 $(A_x, A_y)$ 和城市 $(B_x, B_y)$，满足 $(A_x - B_x)^2 + (A_y - B_y)^2 = 1$。\n\n由于圣域的石油贸易总量很大，莫莉斯意识到不能让每笔石油订购单都从同一个油库里发货。为了提高效率，莫莉斯·乔决定在其中一些城市里建造油库，最终使得每一个城市 $X$ 都满足下列条件之一：\n\n1. 该城市 $X$ 内建有油库.\n2. 某城市 $Y$ 内建有油库，且城市 $X$ 与城市 $Y$ 相邻。\n\n与地球类似，圣域里不同城市间的地价可能也会有所不同，所以莫莉斯想让完成目标的总花费尽可能少。如果存在多组方案，为了方便管理，莫莉斯会选择建造较少的油库个数。\n", "inputFormat": "第一行两个正整数 $n,m$（$n \\times m \\le 50$ 且 $m\\le n$），表示矩阵的大小。\n\n接下来一个 $n$ 行 $m$ 列的矩阵 $F$，$F_{i, j}$表示在城市 $(i,j)$ 建造油库的代价。\n", "outputFormat": "输出两个数，建造方案的油库个数和方案的总代价。\n", "hint": "对于 $30\\%$ 数据满足 $n \\times m \\le 25$;   \n对于 $100\\%$ 数据满足 $n \\times m \\le 50,0 \\le F_{i, j} \\le 10 ^ 5$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[GDOI2014] Save Morris", "background": "", "description": "Morris Qiao is a formidable figure in the Sanctuary. With his outstanding economic acumen, he firmly controls the oil market there.\n\nThe map of the Sanctuary can be seen as an $n \\times m$ grid. Each integer coordinate $(x, y)$ represents a city ($1 \\le x \\le n, 1 \\le y \\le m$). The definition of adjacency between two cities is: for cities $(A_x, A_y)$ and $(B_x, B_y)$, they are adjacent if $(A_x - B_x)^2 + (A_y - B_y)^2 = 1$.\n\nBecause the total volume of oil trade in the Sanctuary is large, Morris realizes that he cannot dispatch every oil order from the same depot. To improve efficiency, Morris Qiao decides to build depots in some cities, so that every city $X$ satisfies one of the following:\n\n1. City $X$ has a depot itself.\n2. There exists a city $Y$ with a depot, and city $X$ is adjacent to city $Y$.\n\nAs on Earth, land prices may differ between cities in the Sanctuary, so Morris wants to minimize the total cost of achieving the goal. If multiple plans have the same minimum total cost, to facilitate management, Morris will choose the one with fewer depots.", "inputFormat": "The first line contains two positive integers $n, m$ (with $n \\times m \\le 50$ and $m \\le n$), representing the size of the grid.\n\nThen follows an $n$-by-$m$ matrix $F$, where $F_{i, j}$ denotes the cost to build a depot in city $(i, j)$.", "outputFormat": "Output two numbers: the number of depots and the minimum total cost.", "hint": "For $30\\%$ of the testdata, $n \\times m \\le 25$.  \nFor $100\\%$ of the testdata, $n \\times m \\le 50$, $0 \\le F_{i, j} \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[GDOI2014] 拯救莫莉斯", "background": "", "description": "莫莉斯·乔是圣域里一个叱咤风云的人物，他凭借着自身超强的经济头脑，牢牢控制了圣域的石油市场。\n\n圣域的地图可以看成是一个 $n\\times m$ 的矩阵。每个整数坐标点 $(x, y)$ 表示一座城市（$1\\le x\\le n,1\\le y\\le m$）。两座城市间相邻的定义为：对于城市 $(A_x, A_y)$ 和城市 $(B_x, B_y)$，满足 $(A_x - B_x)^2 + (A_y - B_y)^2 = 1$。\n\n由于圣域的石油贸易总量很大，莫莉斯意识到不能让每笔石油订购单都从同一个油库里发货。为了提高效率，莫莉斯·乔决定在其中一些城市里建造油库，最终使得每一个城市 $X$ 都满足下列条件之一：\n\n1. 该城市 $X$ 内建有油库.\n2. 某城市 $Y$ 内建有油库，且城市 $X$ 与城市 $Y$ 相邻。\n\n与地球类似，圣域里不同城市间的地价可能也会有所不同，所以莫莉斯想让完成目标的总花费尽可能少。如果存在多组方案，为了方便管理，莫莉斯会选择建造较少的油库个数。\n", "inputFormat": "第一行两个正整数 $n,m$（$n \\times m \\le 50$ 且 $m\\le n$），表示矩阵的大小。\n\n接下来一个 $n$ 行 $m$ 列的矩阵 $F$，$F_{i, j}$表示在城市 $(i,j)$ 建造油库的代价。\n", "outputFormat": "输出两个数，建造方案的油库个数和方案的总代价。\n", "hint": "对于 $30\\%$ 数据满足 $n \\times m \\le 25$;   \n对于 $100\\%$ 数据满足 $n \\times m \\le 50,0 \\le F_{i, j} \\le 10 ^ 5$。\n", "locale": "zh-CN"}}}
{"pid": "P3889", "type": "P", "difficulty": 6, "samples": [["5\n1 2 3 4 5\n2\n2 3\n2 4", "2\n1"], ["5\n2 4 8 16 32\n2\n3 4\n2 3", "16\n8\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2014", "各省省选", "广东"], "title": "[GDOI2014] 吃", "background": "感谢 @FFjet 提醒，第 8 个数据点损坏暂时删除。", "description": "W师兄计划了很久，终于成功的在BG开了一家寿司店。\n\n正当W师兄还在兴奋的时候，这时一个噩耗传来，吃货L师姐居然知道了这件事，而且正赶过来，W师兄瞬间心就冷了下去，但是机智的W师兄也瞬间想到了应付L师姐的策略.......\n\n这时，L师姐到了寿司店，先四处望了望风景，发现现在只有L师姐一个顾客，下面是L师姐的选餐说明：\n\n1.寿司店内的寿司被排在一行共N个盘子里，按从左到右编号为1~N。\n\n2.每个位置上寿司的数量是确定的并且有玻璃窗保护。\n\n3.每隔一段时间就会有一个选餐时间，L师姐可以在一个连续的区间[l, r]中选择其中一盘，然后在该区间之外选择另一盘（如果区间外有盘子）。\n\nL师姐发现这家寿司店厨师的制作速度很快，总能在下一次选餐时间前将寿司数量恢复原样。\n\n作为有尊严有追求的吃货，L师姐也有自己的规则，L师姐在选完两盘寿司后，会决定每口恰好吃D个寿司，且使得两盘寿司刚好可以分别吃完，不剩余任何寿司。比如两盘寿司数量为2和4,那么D=1或者D=2都可以恰好将两盘寿司分别吃干净，而两盘寿司数量为3和5时，那么只能D=1才行。\n\n作为有特殊追求的L师姐才不在乎吃的数量，L师姐在乎的是一口吃多个寿司的感觉。于是，如果L师姐可以一口吃D个寿司，那么L师姐的愉悦值为D，但是L师姐没有选到两盘寿司，那么她的愉悦值为0。\n\n现在L师姐知道每个盘子所放着的寿司数量，L师姐想知道每次选择时间过后她可以获得的最大愉悦值是多少？\n", "inputFormat": "第一行输入一个整数N，表示寿司的盘子数量。\n\n第二行输入N个整数a1,a2,…,aN，ai表示第i个盘子内的寿司数量。\n\n第三行输入一个整数M，表示有多少个选餐时间。\n\n接下来M行，每行两个整数li, ri (1 <= li <= ri <= N)，含义如题面所示。\n", "outputFormat": "输出M行，第i行表示第i个选择时间师姐可能达到的最大愉悦值D。\n", "hint": "###样例解释\n\n样例1里的第一个选餐时间，可以选择2和4，这样L师姐就可以每次吃两个寿司，使得两个盘子都可以吃干净，第二个选餐时间，师姐不管选哪两个盘子，都只能每次吃一个。\n\n样例2 里的第一个选餐时间，可以选择16和32,而第二个选餐时间，L师姐可以选择8和16或者8和32。\n\n对于20%的数据，N <= 100, M <= 100, max(a1,a2,…,aN) <= 100。\n\n对于50%的数据，N <= 10000, M <= 10000, max(a1,a2,…,aN) <= 10000。\n\n对于100%的数据，N <= 100000, M <= 100000, max(a1,a2,…,aN) <= 100000。\n", "locale": "zh-CN", "translations": {"en": {"title": "[GDOI2014] Eating", "background": "Thanks to @FFjet for the reminder, the 8th test point is corrupted and has been temporarily removed.", "description": "Senior Brother W had planned for a long time and finally succeeded in opening a sushi restaurant in BG.\n\nJust as he was still excited, bad news came: foodie Senior Sister L actually learned about this and was on her way. Senior Brother W instantly felt a chill, but being clever, he immediately came up with a strategy to deal with Senior Sister L.\n\nWhen Senior Sister L arrived at the sushi restaurant, she first looked around and found that she was the only customer. Below are her selection rules:\n\n1. The sushi in the restaurant is arranged in a single row of $N$ plates, numbered from $1$ to $N$ from left to right.\n2. The number of sushi on each plate is fixed and protected by a glass cover.\n3. At each selection time, Senior Sister L may choose one plate from a continuous interval $[l, r]$, and then choose another plate outside that interval (if there are plates outside the interval).\n\nSenior Sister L finds that the chefs here work very fast and can always restore the sushi counts to their original numbers before the next selection time.\n\nAs a foodie with standards, after selecting two plates, Senior Sister L will decide to eat exactly $D$ pieces of sushi per bite, such that both plates can be finished exactly with no leftovers. For example, if the two plates contain $2$ and $4$ pieces, then $D = 1$ or $D = 2$ will finish both plates exactly. If the two plates contain $3$ and $5$ pieces, then only $D = 1$ works.\n\nSenior Sister L does not care about the total amount of food; she cares about the feeling of eating multiple pieces in one bite. Thus, if she can eat $D$ pieces per bite, her joy value is $D$. If she cannot select two plates, her joy value is $0$.\n\nGiven the number of sushi on each plate, Senior Sister L wants to know, after each selection time, what is the maximum joy value she can obtain.", "inputFormat": "- The first line contains an integer $N$, the number of sushi plates.\n- The second line contains $N$ integers $a_1, a_2, \\dots, a_N$, where $a_i$ is the number of sushi on the $i$-th plate.\n- The third line contains an integer $M$, the number of selection times.\n- The next $M$ lines each contain two integers $l_i, r_i$ with $1 \\le l_i \\le r_i \\le N$, as described above.", "outputFormat": "Output $M$ lines. The $i$-th line contains the maximum possible joy value $D$ for the $i$-th selection time.", "hint": "Sample explanation:\n- In sample 1, for the first selection time, you can choose $2$ and $4$, so Senior Sister L can eat $2$ pieces per bite and finish both plates exactly. For the second selection time, no matter which two plates she chooses, she can only eat $1$ piece per bite.\n- In sample 2, for the first selection time, she can choose $16$ and $32$. For the second selection time, she can choose $8$ and $16$ or $8$ and $32$.\n\nConstraints:\n- For 20% of the testdata, $N \\le 100$, $M \\le 100$, $\\max(a_1, a_2, \\dots, a_N) \\le 100$.\n- For 50% of the testdata, $N \\le 10000$, $M \\le 10000$, $\\max(a_1, a_2, \\dots, a_N) \\le 10000$.\n- For 100% of the testdata, $N \\le 100000$, $M \\le 100000$, $\\max(a_1, a_2, \\dots, a_N) \\le 100000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[GDOI2014] 吃", "background": "感谢 @FFjet 提醒，第 8 个数据点损坏暂时删除。", "description": "W师兄计划了很久，终于成功的在BG开了一家寿司店。\n\n正当W师兄还在兴奋的时候，这时一个噩耗传来，吃货L师姐居然知道了这件事，而且正赶过来，W师兄瞬间心就冷了下去，但是机智的W师兄也瞬间想到了应付L师姐的策略.......\n\n这时，L师姐到了寿司店，先四处望了望风景，发现现在只有L师姐一个顾客，下面是L师姐的选餐说明：\n\n1.寿司店内的寿司被排在一行共N个盘子里，按从左到右编号为1~N。\n\n2.每个位置上寿司的数量是确定的并且有玻璃窗保护。\n\n3.每隔一段时间就会有一个选餐时间，L师姐可以在一个连续的区间[l, r]中选择其中一盘，然后在该区间之外选择另一盘（如果区间外有盘子）。\n\nL师姐发现这家寿司店厨师的制作速度很快，总能在下一次选餐时间前将寿司数量恢复原样。\n\n作为有尊严有追求的吃货，L师姐也有自己的规则，L师姐在选完两盘寿司后，会决定每口恰好吃D个寿司，且使得两盘寿司刚好可以分别吃完，不剩余任何寿司。比如两盘寿司数量为2和4,那么D=1或者D=2都可以恰好将两盘寿司分别吃干净，而两盘寿司数量为3和5时，那么只能D=1才行。\n\n作为有特殊追求的L师姐才不在乎吃的数量，L师姐在乎的是一口吃多个寿司的感觉。于是，如果L师姐可以一口吃D个寿司，那么L师姐的愉悦值为D，但是L师姐没有选到两盘寿司，那么她的愉悦值为0。\n\n现在L师姐知道每个盘子所放着的寿司数量，L师姐想知道每次选择时间过后她可以获得的最大愉悦值是多少？\n", "inputFormat": "第一行输入一个整数N，表示寿司的盘子数量。\n\n第二行输入N个整数a1,a2,…,aN，ai表示第i个盘子内的寿司数量。\n\n第三行输入一个整数M，表示有多少个选餐时间。\n\n接下来M行，每行两个整数li, ri (1 <= li <= ri <= N)，含义如题面所示。\n", "outputFormat": "输出M行，第i行表示第i个选择时间师姐可能达到的最大愉悦值D。\n", "hint": "###样例解释\n\n样例1里的第一个选餐时间，可以选择2和4，这样L师姐就可以每次吃两个寿司，使得两个盘子都可以吃干净，第二个选餐时间，师姐不管选哪两个盘子，都只能每次吃一个。\n\n样例2 里的第一个选餐时间，可以选择16和32,而第二个选餐时间，L师姐可以选择8和16或者8和32。\n\n对于20%的数据，N <= 100, M <= 100, max(a1,a2,…,aN) <= 100。\n\n对于50%的数据，N <= 10000, M <= 10000, max(a1,a2,…,aN) <= 10000。\n\n对于100%的数据，N <= 100000, M <= 100000, max(a1,a2,…,aN) <= 100000。\n", "locale": "zh-CN"}}}
{"pid": "P3890", "type": "P", "difficulty": 6, "samples": [["2 4\n10 5\n5 10\n", "0 15\n15 0\n"], ["3 16\n6 5 7\n5 6 7\n7 7 6\n", "0 3 3\n3 0 3\n3 3 0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "各省省选", "广东"], "title": "[GDOI2014] 比特矩阵", "background": "你知道矩阵乘法吗？\n\n对于两个 $n\\times n$ 的矩阵 A 和 B， 假设 $a_{i, j}$ 表示位于矩阵 A 的第 $i$ 行第 $j$ 列的元素， 同样对于B可以定义类似的 $b_{i,j}$。 那么如果 $C = A \\times B$，则有 $c_{i, j}=\\sum_{k=1}^{n} a_{ik} \\times b_{kj}$。 其中 $ \\sum$ 是序列求和符号，例如 $\\sum_{i=1}^{n} i$ 表示 $1 + 2 + \\cdots + n$。\n", "description": "由于霍比特人的大热， L 的室友 X 最近热衷于研究它们所使用的货币。为了进行研究，X 需要了解一种叫比特矩阵的东西。 虽然比特矩阵也是矩阵，但是它的乘法和一般的矩阵有点不一样。\n\n对于比特矩阵 $C = A \\times B$， 意味着 $c_{i,j} = V_{k=1}^{n}a_{ik} \\bigoplus b_{kj}$。其中 $V$ 是序列求按位或的符号，例如 $V_{i=1}^{n} i$ 表示 $1 \\mid 2 \\mid \\cdots \\mid n$。 $\\mid$ 就是按位或的意思。 按位或是指从二进制的角度看两个数， 如果第 $i$ 位上两个数至少一个是1的话那结果的第 $i$ 位就是1， 否则第 $i$ 位就是 $0$。 $\\bigoplus$ 表示按位异或运算， 即如果两个二进制数的第$i$位是不相同的话那么结果的第 $i$ 位就是 $1$，否则就是 $0$。\n\n举个比特矩阵相乘的例子:\n\n$$\\begin{bmatrix}1&6\\\\3&5\\end{bmatrix}\\times\\begin{bmatrix}3&6\\\\5&7\\end{bmatrix}=\\begin{bmatrix}3&7\\\\0&7\\end{bmatrix}$$\n\n现在 X 想要拜托你帮他算 $A^{m}$，其中 $A$ 是一个 $n\\times n$ 的比特矩阵， 而 $A^{m}$ 表示 $m$ 个 $ A$ 相乘的结果。严谨地说:\n\n- $A^{1}=A$；\n- $A^{m}=A^{m-1}\\times A,\\ m>1$。\n", "inputFormat": "输入第一行包含两个正整数 $n,m$。\n\n接下来 $n$ 行，每行包含 $n$ 个非负整数，这 $n$ 行中第 $i$ 行的第 $j$ 个数表示比特矩阵 $a_{i,j}$ 的元素 。\n", "outputFormat": "根据输入，输出一个比特矩阵 $A^{m}$。即按照输入给出 $A$ 的方式输出一个比特矩阵。 具体参看样例输出。\n", "hint": "### 数据范围及约定\n\n- 对于 $10\\%$ 的数据 $n\\le 4$，$ m\\le 10000$。\n- 对于 $30\\%$ 的数据 $n\\le 10$，$ m\\le 10^9$。\n- 对于 $100\\%$ 的数据 $n\\le 500$，$ m\\le 10^9$, 所有输入的整数不超过$10^9$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[GDOI2014] Bit Matrix", "background": "Do you know matrix multiplication?\n\nFor two $n \\times n$ matrices $A$ and $B$, suppose $a_{i, j}$ denotes the element in row $i$ and column $j$ of matrix $A$; similarly define $b_{i, j}$ for $B$. If $C = A \\times B$, then $c_{i, j} = \\sum_{k=1}^{n} a_{i k} \\times b_{k j}$. Here $\\sum$ is the summation symbol; for example, $\\sum_{i=1}^{n} i$ means $1 + 2 + \\cdots + n$.", "description": "Due to the popularity of The Hobbit, L’s roommate X has recently become interested in the currency they use. For this study, X needs to understand something called a bit matrix. Although a bit matrix is still a matrix, its multiplication is a little different from ordinary matrix multiplication.\n\nFor bit matrices, $C = A \\times B$ means $c_{i, j} = V_{k=1}^{n} a_{i k} \\bigoplus b_{k j}$. Here $V$ denotes taking bitwise OR over a sequence; for example, $V_{i=1}^{n} i$ means $1 \\mid 2 \\mid \\cdots \\mid n$. The symbol $\\mid$ means bitwise OR. Bitwise OR views two numbers in binary: if at bit $i$ at least one of the two numbers is $1$, then the $i$-th bit of the result is $1$; otherwise that bit is $0$. The symbol $\\bigoplus$ denotes bitwise XOR: if the $i$-th bits of two binary numbers are different, then the $i$-th bit of the result is $1$; otherwise it is $0$.\n\nHere is an example of bit-matrix multiplication.\n$$\\begin{bmatrix}1&6\\\\3&5\\end{bmatrix}\\times\\begin{bmatrix}3&6\\\\5&7\\end{bmatrix}=\\begin{bmatrix}3&7\\\\0&7\\end{bmatrix}$$\n\nNow X would like you to compute $A^{m}$, where $A$ is an $n \\times n$ bit matrix, and $A^{m}$ is the result of multiplying $m$ copies of $A$. Precisely:\n- $A^{1} = A$.\n- $A^{m} = A^{m-1} \\times A$, for $m > 1$.", "inputFormat": "The first line contains two positive integers $n, m$.\nThe next $n$ lines each contain $n$ non-negative integers; in these $n$ lines, the $j$-th number of the $i$-th line is the element $a_{i, j}$ of the bit matrix.", "outputFormat": "Output the bit matrix $A^{m}$. That is, print a bit matrix in the same format as the input matrix $A$. See the sample output for details.", "hint": "Constraints\n- For $10\\%$ of the testdata, $n \\le 4$, $m \\le 10000$.\n- For $30\\%$ of the testdata, $n \\le 10$, $m \\le 10^9$.\n- For $100\\%$ of the testdata, $n \\le 500$, $m \\le 10^9$, and all input integers do not exceed $10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[GDOI2014] 比特矩阵", "background": "你知道矩阵乘法吗？\n\n对于两个 $n\\times n$ 的矩阵 A 和 B， 假设 $a_{i, j}$ 表示位于矩阵 A 的第 $i$ 行第 $j$ 列的元素， 同样对于B可以定义类似的 $b_{i,j}$。 那么如果 $C = A \\times B$，则有 $c_{i, j}=\\sum_{k=1}^{n} a_{ik} \\times b_{kj}$。 其中 $ \\sum$ 是序列求和符号，例如 $\\sum_{i=1}^{n} i$ 表示 $1 + 2 + \\cdots + n$。\n", "description": "由于霍比特人的大热， L 的室友 X 最近热衷于研究它们所使用的货币。为了进行研究，X 需要了解一种叫比特矩阵的东西。 虽然比特矩阵也是矩阵，但是它的乘法和一般的矩阵有点不一样。\n\n对于比特矩阵 $C = A \\times B$， 意味着 $c_{i,j} = V_{k=1}^{n}a_{ik} \\bigoplus b_{kj}$。其中 $V$ 是序列求按位或的符号，例如 $V_{i=1}^{n} i$ 表示 $1 \\mid 2 \\mid \\cdots \\mid n$。 $\\mid$ 就是按位或的意思。 按位或是指从二进制的角度看两个数， 如果第 $i$ 位上两个数至少一个是1的话那结果的第 $i$ 位就是1， 否则第 $i$ 位就是 $0$。 $\\bigoplus$ 表示按位异或运算， 即如果两个二进制数的第$i$位是不相同的话那么结果的第 $i$ 位就是 $1$，否则就是 $0$。\n\n举个比特矩阵相乘的例子:\n\n$$\\begin{bmatrix}1&6\\\\3&5\\end{bmatrix}\\times\\begin{bmatrix}3&6\\\\5&7\\end{bmatrix}=\\begin{bmatrix}3&7\\\\0&7\\end{bmatrix}$$\n\n现在 X 想要拜托你帮他算 $A^{m}$，其中 $A$ 是一个 $n\\times n$ 的比特矩阵， 而 $A^{m}$ 表示 $m$ 个 $ A$ 相乘的结果。严谨地说:\n\n- $A^{1}=A$；\n- $A^{m}=A^{m-1}\\times A,\\ m>1$。\n", "inputFormat": "输入第一行包含两个正整数 $n,m$。\n\n接下来 $n$ 行，每行包含 $n$ 个非负整数，这 $n$ 行中第 $i$ 行的第 $j$ 个数表示比特矩阵 $a_{i,j}$ 的元素 。\n", "outputFormat": "根据输入，输出一个比特矩阵 $A^{m}$。即按照输入给出 $A$ 的方式输出一个比特矩阵。 具体参看样例输出。\n", "hint": "### 数据范围及约定\n\n- 对于 $10\\%$ 的数据 $n\\le 4$，$ m\\le 10000$。\n- 对于 $30\\%$ 的数据 $n\\le 10$，$ m\\le 10^9$。\n- 对于 $100\\%$ 的数据 $n\\le 500$，$ m\\le 10^9$, 所有输入的整数不超过$10^9$。\n", "locale": "zh-CN"}}}
{"pid": "P3891", "type": "P", "difficulty": 5, "samples": [["1 1 8\n1 1\n", "4"], ["2 1 8\n1 1\n2 8\n", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "递推", "2014", "各省省选", "广东", "背包 DP"], "title": "[GDOI2014] 采集资源", "background": null, "description": "魔兽争霸 3 中，战略资源的采集通过使用农民、苦工、小精灵以及寺僧来进行。\n\n在魔兽争霸 4 的开发中，玻璃渣觉得这种模式太过单一，于是他们想添加更多的单位来使采集的模式更加丰富。\n\n在新的模式中，玩家可以建造更多种类的“苦工”，不同的“苦工”的工作效率不同，同时，建造不同的“苦工”所需要的资源也是不一样的。\n\n玻璃渣出品的游戏以追求平衡著称，所以为了测试这种新的模式的平衡性，他们设计了一套检测的方法：在各种族的起始资源相同时，测量达到某一资源数量的时间，如果相同则可以认为设计是平衡的。\n\n他们将数据给你，希望你能测试出设计是否平衡。", "inputFormat": "第一行三个数，$N,M,T$，表示苦工的种类、开始时拥有的资源数量以及需要达到的资源的数量。\n\n接下来 $N$ 行，每行2个数 $A,B$，表示生产这种苦工所需要的资源，以及这个苦工的效率，效率即为单位时间内产生的资源的数量。", "outputFormat": "一个数字，表示资源数量达到 $T$ 时的最少时间。\n\n\n注意：与魔兽争霸 3 不同，魔兽争霸 4 中，生产苦工不需要时间。并且资源的采集并不连续，亦即如果一个苦工的效率为 $2$，他会在时间为 $1$ 的时候收获 $2$ 点资源，而并不会在时间为 $0.5$ 的时候收获 $1$ 点资源。", "hint": "对于 $30\\%$ 的数据，$N\\le 10$，$M,T \\le  300$；\n\n对于 $100\\%$ 的数据，$N\\le 100$，$M,T \\le1000$，$A,B\\le 2^{31}$。\n\n数据保证有解。", "locale": "zh-CN", "translations": {"en": {"title": "[GDOI2014] Resource Gathering", "background": "# Description\n\nIn Warcraft III, strategic resources are collected by using Peasants, Peons, Wisps, and Acolytes.\n\nDuring the development of Warcraft IV, Blizzard thought this model was too single-pattern, so they wanted to add more units to make gathering more diverse.\n\nIn the new mode, players can build more types of \"workers\". Different \"workers\" have different efficiencies, and the resources required to build different \"workers\" are also different.\n\nBlizzard’s games are known for pursuing balance, so to test the balance of this new mode, they designed a method: when all races have the same starting resources, measure the time to reach a certain amount of resources. If the times are the same, the design is considered balanced.\n\nThey gave you the data and hope you can test whether the design is balanced.", "description": "", "inputFormat": "", "outputFormat": "Print a single number: the minimum time when the amount of resources reaches $T$.\n\nNote: Unlike in Warcraft III, in Warcraft IV producing workers takes no time. Also, resource collection is not continuous. That is, if a worker’s efficiency is $2$, they will harvest $2$ resources at time $1$, and will not harvest $1$ resource at time $0.5$.", "hint": "- For $30\\%$ of the testdata, $N \\le 10$, $M, T \\le 300$.\n- For $100\\%$ of the testdata, $N \\le 100$, $M, T \\le 1000$, $A, B \\le 2^{31}$.\n- The testdata guarantees that a solution exists.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[GDOI2014] 采集资源", "background": null, "description": "魔兽争霸 3 中，战略资源的采集通过使用农民、苦工、小精灵以及寺僧来进行。\n\n在魔兽争霸 4 的开发中，玻璃渣觉得这种模式太过单一，于是他们想添加更多的单位来使采集的模式更加丰富。\n\n在新的模式中，玩家可以建造更多种类的“苦工”，不同的“苦工”的工作效率不同，同时，建造不同的“苦工”所需要的资源也是不一样的。\n\n玻璃渣出品的游戏以追求平衡著称，所以为了测试这种新的模式的平衡性，他们设计了一套检测的方法：在各种族的起始资源相同时，测量达到某一资源数量的时间，如果相同则可以认为设计是平衡的。\n\n他们将数据给你，希望你能测试出设计是否平衡。", "inputFormat": "第一行三个数，$N,M,T$，表示苦工的种类、开始时拥有的资源数量以及需要达到的资源的数量。\n\n接下来 $N$ 行，每行2个数 $A,B$，表示生产这种苦工所需要的资源，以及这个苦工的效率，效率即为单位时间内产生的资源的数量。", "outputFormat": "一个数字，表示资源数量达到 $T$ 时的最少时间。\n\n\n注意：与魔兽争霸 3 不同，魔兽争霸 4 中，生产苦工不需要时间。并且资源的采集并不连续，亦即如果一个苦工的效率为 $2$，他会在时间为 $1$ 的时候收获 $2$ 点资源，而并不会在时间为 $0.5$ 的时候收获 $1$ 点资源。", "hint": "对于 $30\\%$ 的数据，$N\\le 10$，$M,T \\le  300$；\n\n对于 $100\\%$ 的数据，$N\\le 100$，$M,T \\le1000$，$A,B\\le 2^{31}$。\n\n数据保证有解。", "locale": "zh-CN"}}}
{"pid": "P3892", "type": "P", "difficulty": 4, "samples": [["7 5 17\ncreateContest 1 5 1001 1004 1002 1005 1006\nsubmission 1 1 1001 1 AC\nsubmission 2 1 1001 1 AC\nsubmission 3 1 1001 2 UNAC\nsubmission 4 1 1003 3 UNAC\ngetRank 1 1\ngetRank 1 2\ngetRank 1 3\nrejudge 3\nsubmission 3 1 1001 2 AC\ngetRank 1 2\nsubmission 5 1 1006 2 AC\ngetRank 1 1\nsubmission 6 1 1006 2 UNAC\ngetRank 1 2\nrejudge 5\ngetRank 1 2\n", "1 1 1 1\n2 0 2 3\n3 0 2 3\n2 1 1 2\n1 1 2 2\n2 2 1 1\n2 1 1 2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2014", "各省省选", "广东"], "title": "[GDOI2014] OJ", "background": "", "description": "小 M 是一个勤奋的 ACMer，他利用课余时间刷了很多题目。但他是个很健忘的孩子，经常会忘记自己刷过一些什么题目，所以他想写一个 OJ 来管理自己做过的题目。\n\n经过一个星期的努力，小 M 的 OJ 基本成型，只是还差一个 Contest 的模块没有实现。小 M 觉得这个模块很难实现，所以他希望找你来帮忙。\n\n小 M 告诉你，一个 OJ 的基础元素包括：\n\n1. 题目，可以用 pid 唯一标识，pid 为正整数；\n2. 比赛，可以用 cid 唯一标识，cid 为正整数；\n3. 用户，可以用 uid 唯一标识，uid 为正整数；\n4. 提交状态，可以由 sid 唯一标识，sid 为正整数。\n\n一个提交状态是由 sid、cid、pid、uid 和 result 组成的，分别表示本条状态的提交 ID，所属比赛 ID，题目 ID，用户 ID 以及评测结果。\n\n简单起见，这里的 result 只有 AC、UNAC 和 WAIT 三种状态，分别表示通过、不通过和等待评测。\n\n同时小 M 提出一个比赛模块需要实现以下请求：\n\n1. `createContest cid t pid_1 pid_2 … pid_t`\n\n表示要创建一个比赛，cid 是一个正整数，是这场比赛的唯一标识。\n\n$t$ 表示这场比赛有 $t$（($1\\le t\\le1000$)）道题目，接下来 $t$ 个不同的整数，表示这场比赛的题目编号。\n\n2. `submission sid cid pid uid result`\n\n该条状态的 sid 要么之前没出现过，要么以前出现过，但是被 rejudge 了。\n\nresult 为 AC 或者 UNAC。\n\n3. `getRank cid uid`\n\n在一场比赛中，所有有提交的用户都应该算在排名内（包括被 rejudge 的提交），用户的排名按照通过的题目数从大到小排序，如果题目数相同，则按随机顺序排序。\n\n该指令需要统计用户 uid 在 cid 这场比赛中的通过目数，最高排名以及最低排名。\n\n值得注意的是，用户 uid 在 cid 这场比赛中同一道题目的多个通过记录只算一次。\n\n输出格式为：`uid solved highest lowest`。\n\n分别代表用户 ID，通过题目数量，最高排名以及最低排名，其中 $\\mathit{highest}\\le\\mathit{lowest}$。\n\n4. `rejudge sid`\n\n重测以 sid 标识的提交记录，即将该记录的 result 改成 WAIT。\n", "inputFormat": "第一行三个整数 $\\mathit{pcnt}$、$\\mathit{ucnt}$、$m$（$1\\le\\mathit{pcnt}\\le5000,1\\le\\mathit{ucnt}\\le5000,1\\le m\\le3\\times10^5$），分别表示 OJ 有 pcnt 道题目，ucnt 个用户以及 m 条请求。\n\npid 的范围是 $1000\\sim1000+\\mathit{pcnt}-1$，uid 的范围是 $1\\sim\\mathit{ucnt}$，cid 的范围为 $1\\sim50$，$1\\le\\mathit{sid}\\le m$。\n\n接下来有 $m$ 行，每行一个请求，请求为题述四种请求之一，请求需要按输入顺序执行。\n\n你需要注意以下几点：\n\n1. 对于 `createContest` 请求，保证 cid 不会与之前的 createContest 的 cid 重复。\n2. 对于 `submission` 请求，在此请求前，保证比赛 cid 已经创建，题目 pid 是该场比赛的题目之一。\n3. 对于 `getRank` 指令，在此请求前，保证比赛 cid 已经创建，用户 uid 至少在该比赛中有一个提交记录。\n4. 对于 `rejudge` 指令，在此请求前，保证存在以 sid 标识的提交。\n", "outputFormat": "对于每一个 `getRank` 请求，根据要求输出用户 ID，通过题目数量，最高排名以及最低排名，整数之间用一个空格隔开。\n", "hint": "对于 $20\\%$ 的数据，$1\\le\\mathit{pcnt},\\mathit{ucnt},m\\le100$；\n\n对于 $50\\%$ 的数据，$1\\le\\mathit{pcnt},\\mathit{ucnt}\\le2000,1\\le m\\le50000$；\n\n对于 $100\\%$ 的数据，$1\\le\\mathit{pcnt},\\mathit{ucnt}\\le5000,1\\le m\\le3\\times10^5,1\\le\\mathit{cid}\\le50$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[GDOI2014] OJ", "background": "", "description": "Xiao M is a diligent ACMer. He has solved many problems in his spare time. But he is very forgetful and often forgets which problems he has solved, so he wants to write an OJ to manage the problems he has done.\n\nAfter a week of effort, Xiao M’s OJ is basically finished, except for a Contest module that has not been implemented. Xiao M thinks this module is hard to implement, so he wants you to help.\n\nXiao M tells you that the basic elements of an OJ include:\n1. Problem, uniquely identified by pid, where pid is a positive integer.\n2. Contest, uniquely identified by cid, where cid is a positive integer.\n3. User, uniquely identified by uid, where uid is a positive integer.\n4. Submission status, uniquely identified by sid, where sid is a positive integer.\n\nA submission status consists of sid, cid, pid, uid, and result, representing the submission ID of this entry, the contest ID it belongs to, the problem ID, the user ID, and the judging result.\n\nFor simplicity, result has only three states: AC, UNAC, and WAIT, meaning accepted, not accepted, and waiting for judge, respectively.\n\nMeanwhile, the contest module needs to support the following requests:\n1. `createContest cid t pid_1 pid_2 … pid_t`\n\nThis creates a contest. The cid is a positive integer and is the unique identifier of this contest.\n\nHere $t$ indicates there are $t$ problems ($1 \\le t \\le 1000$) in this contest, followed by $t$ distinct integers denoting the problem IDs of this contest.\n\n2. `submission sid cid pid uid result`\n\nThe sid of this status either has not appeared before, or it has appeared before but was rejudged.\n\nThe result is AC or UNAC.\n\n3. `getRank cid uid`\n\nIn a contest, all users who have any submission should be included in the ranking (including submissions that have been rejudged). Users are ranked by the number of solved problems in descending order; if the solved count is the same, the tie-breaking is random.\n\nThis command needs to report the number of problems solved by user uid in contest cid, their best possible rank and worst possible rank.\n\nNote that multiple accepted records on the same problem by user uid in contest cid count only once.\n\nThe output format is: `uid solved highest lowest`.\n\nThese represent the user ID, solved problem count, highest rank, and lowest rank, with $\\mathit{highest} \\le \\mathit{lowest}$.\n\n4. `rejudge sid`\n\nRejudge the submission identified by sid, i.e., set its result to WAIT.", "inputFormat": "The first line contains three integers $\\mathit{pcnt}$, $\\mathit{ucnt}$, and $m$ ($1 \\le \\mathit{pcnt} \\le 5000, 1 \\le \\mathit{ucnt} \\le 5000, 1 \\le m \\le 3 \\times 10^5$), indicating that the OJ has $\\mathit{pcnt}$ problems, $\\mathit{ucnt}$ users, and $m$ requests.\n\nThe range of pid is $1000 \\sim 1000+\\mathit{pcnt}-1$, the range of uid is $1 \\sim \\mathit{ucnt}$, the range of cid is $1 \\sim 50$, and $1 \\le \\mathit{sid} \\le m$.\n\nThen there are $m$ lines, each containing one request, which is one of the four types described above. Requests should be executed in the input order.\n\nYou should note the following:\n1. For a `createContest` request, cid will not duplicate any previous createContest’s cid.\n2. For a `submission` request, before this request, the contest cid has already been created, and pid is one of the problems in that contest.\n3. For a `getRank` request, before this request, the contest cid has already been created, and user uid has at least one submission record in that contest.\n4. For a `rejudge` request, before this request, a submission identified by sid exists.", "outputFormat": "For each `getRank` request, output the user ID, solved problem count, highest rank, and lowest rank, separated by single spaces.", "hint": "For $20\\%$ of the testdata, $1 \\le \\mathit{pcnt}, \\mathit{ucnt}, m \\le 100$.\n\nFor $50\\%$ of the testdata, $1 \\le \\mathit{pcnt}, \\mathit{ucnt} \\le 2000, 1 \\le m \\le 50000$.\n\nFor $100\\%$ of the testdata, $1 \\le \\mathit{pcnt}, \\mathit{ucnt} \\le 5000, 1 \\le m \\le 3 \\times 10^5, 1 \\le \\mathit{cid} \\le 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[GDOI2014] OJ", "background": "", "description": "小 M 是一个勤奋的 ACMer，他利用课余时间刷了很多题目。但他是个很健忘的孩子，经常会忘记自己刷过一些什么题目，所以他想写一个 OJ 来管理自己做过的题目。\n\n经过一个星期的努力，小 M 的 OJ 基本成型，只是还差一个 Contest 的模块没有实现。小 M 觉得这个模块很难实现，所以他希望找你来帮忙。\n\n小 M 告诉你，一个 OJ 的基础元素包括：\n\n1. 题目，可以用 pid 唯一标识，pid 为正整数；\n2. 比赛，可以用 cid 唯一标识，cid 为正整数；\n3. 用户，可以用 uid 唯一标识，uid 为正整数；\n4. 提交状态，可以由 sid 唯一标识，sid 为正整数。\n\n一个提交状态是由 sid、cid、pid、uid 和 result 组成的，分别表示本条状态的提交 ID，所属比赛 ID，题目 ID，用户 ID 以及评测结果。\n\n简单起见，这里的 result 只有 AC、UNAC 和 WAIT 三种状态，分别表示通过、不通过和等待评测。\n\n同时小 M 提出一个比赛模块需要实现以下请求：\n\n1. `createContest cid t pid_1 pid_2 … pid_t`\n\n表示要创建一个比赛，cid 是一个正整数，是这场比赛的唯一标识。\n\n$t$ 表示这场比赛有 $t$（($1\\le t\\le1000$)）道题目，接下来 $t$ 个不同的整数，表示这场比赛的题目编号。\n\n2. `submission sid cid pid uid result`\n\n该条状态的 sid 要么之前没出现过，要么以前出现过，但是被 rejudge 了。\n\nresult 为 AC 或者 UNAC。\n\n3. `getRank cid uid`\n\n在一场比赛中，所有有提交的用户都应该算在排名内（包括被 rejudge 的提交），用户的排名按照通过的题目数从大到小排序，如果题目数相同，则按随机顺序排序。\n\n该指令需要统计用户 uid 在 cid 这场比赛中的通过目数，最高排名以及最低排名。\n\n值得注意的是，用户 uid 在 cid 这场比赛中同一道题目的多个通过记录只算一次。\n\n输出格式为：`uid solved highest lowest`。\n\n分别代表用户 ID，通过题目数量，最高排名以及最低排名，其中 $\\mathit{highest}\\le\\mathit{lowest}$。\n\n4. `rejudge sid`\n\n重测以 sid 标识的提交记录，即将该记录的 result 改成 WAIT。\n", "inputFormat": "第一行三个整数 $\\mathit{pcnt}$、$\\mathit{ucnt}$、$m$（$1\\le\\mathit{pcnt}\\le5000,1\\le\\mathit{ucnt}\\le5000,1\\le m\\le3\\times10^5$），分别表示 OJ 有 pcnt 道题目，ucnt 个用户以及 m 条请求。\n\npid 的范围是 $1000\\sim1000+\\mathit{pcnt}-1$，uid 的范围是 $1\\sim\\mathit{ucnt}$，cid 的范围为 $1\\sim50$，$1\\le\\mathit{sid}\\le m$。\n\n接下来有 $m$ 行，每行一个请求，请求为题述四种请求之一，请求需要按输入顺序执行。\n\n你需要注意以下几点：\n\n1. 对于 `createContest` 请求，保证 cid 不会与之前的 createContest 的 cid 重复。\n2. 对于 `submission` 请求，在此请求前，保证比赛 cid 已经创建，题目 pid 是该场比赛的题目之一。\n3. 对于 `getRank` 指令，在此请求前，保证比赛 cid 已经创建，用户 uid 至少在该比赛中有一个提交记录。\n4. 对于 `rejudge` 指令，在此请求前，保证存在以 sid 标识的提交。\n", "outputFormat": "对于每一个 `getRank` 请求，根据要求输出用户 ID，通过题目数量，最高排名以及最低排名，整数之间用一个空格隔开。\n", "hint": "对于 $20\\%$ 的数据，$1\\le\\mathit{pcnt},\\mathit{ucnt},m\\le100$；\n\n对于 $50\\%$ 的数据，$1\\le\\mathit{pcnt},\\mathit{ucnt}\\le2000,1\\le m\\le50000$；\n\n对于 $100\\%$ 的数据，$1\\le\\mathit{pcnt},\\mathit{ucnt}\\le5000,1\\le m\\le3\\times10^5,1\\le\\mathit{cid}\\le50$。\n", "locale": "zh-CN"}}}
{"pid": "P3893", "type": "P", "difficulty": 7, "samples": [["5\nabcdx\ncdabz\n", "4"], ["4\nabcd\ncdab\n", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "各省省选", "广东"], "title": "[GDOI2014] Beyond", "background": "", "description": "Jodie 慢慢地步入实验室，跟随在她身旁的灵体 Aiden 似乎有点不高兴，但还是形影不离地跟随着 Jodie。\n\n今天 Jodie 要进行的实验在一个很大很大的圆环上面，圆环上有 $L$ 个格子，每个格子上都显示着一个小写英文字母，Jodie 从任意格子开始当她离开一个格子的时候那个格子的字母就会改变，这个改变是随机的，没有人知道会变成什么。Jodie 在这个环上不回头顺时针地走，每进入一个格子就会在本子上写下这个格子当前显示的字母。由于 Jodie 不能回头而且不知道这个圆环上有多少个格子，她并不知道自己什么时候会走到重复的点，所以她让 Aiden 在她下一步走进重复格子的时候提醒一下。但可能他们闹了矛盾，Aiden 发了脾气，决定在 Jodie 走了 $K$（$K \\geq 0$）步重复的格子之后才告诉她。Jodie 进行了两次实验，记录了两次走的路径。第二次实验再进去之前，每个格子所显示的字母会被重设为第一次实验开始前的样子。Jodie 发现了 Aiden 的恶作剧，她只能把可能的最大的 $L$ 告诉实验人员。\n\n为了帮助你更好的理解题目，请仔细分析一下例子：\n\n假设 $L = 4$，$K = 1$\n\n第一次实验开始前每个格子显示的字母如下图：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6849.png) \n\nJodie 从显示字母为 `a` 的格子开始走，Aiden 在她走了 $K$ 步重复的格子之后告诉她停止，所以 Jodie 一共走了 $5$ 步，每走一步，格子的变化如下（箭头指着 Jodie 所在的格子）：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6850.png) \n\nJodie 的第二次实验从显示字母为 `c` 的格子开始走，每走一步格子的变化如下（箭头指着 Jodie 所在的格子）：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6851.png) \n\nJodie 两次实验记录的路径分别为：\n\n`abcdx`\n\n`cdabz`\n\n现在给出 Jodie 记录的两次路径的长度 $N$，以及 Jodie 所写的内容，但是并不知道 $K$ 是多少，希望你能帮忙求出一个最大的可能的 $L$。\n", "inputFormat": "第一行：包含一个整数 $N$。\n\n第二行：包含一个长度为 $N$ 的字符串，字符串中只包含小写字母。\n\n第三行：包含一个长度为 $N$ 的字符串，字符串中只包含小写字母。\n", "outputFormat": "输出答案只包含一个数字 $L$，表示圆环最大可能有的格子数。\n", "hint": "对于 $20\\%$ 的数据，$1 \\leq N \\leq 5,000$\n\n对于 $50\\%$ 的数据，$1 \\leq N \\leq 600,000$\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 2,000,000$\n", "locale": "zh-CN", "translations": {"en": {"title": "[GDOI2014] Beyond", "background": "", "description": "Jodie slowly walks into the laboratory. The spirit Aiden, who follows by her side, seems a bit upset, but still sticks closely to Jodie.\n\nToday’s experiment takes place on a very large circular ring with $L$ cells. Each cell displays a lowercase English letter. Jodie starts from any cell. Whenever she leaves a cell, the letter in that cell changes randomly; no one knows what it will become. Jodie walks clockwise around the ring without ever turning back. Each time she enters a cell, she writes down the letter currently displayed in that cell.\n\nSince Jodie cannot turn back and does not know how many cells the ring has, she does not know when she will reach a cell she has already visited. So she asks Aiden to remind her when her next step would enter a previously visited cell. However, after a quarrel, Aiden gets angry and decides to tell her only after Jodie has already stepped into $K$ repeated cells (with $K \\geq 0$). Jodie performs two experiments and records the two paths. Before the second experiment begins, the letter in each cell is reset to the state it had before the first experiment started. Jodie discovers Aiden’s prank, so she can only report the largest possible $L$ to the experimenters.\n\nTo help you better understand the problem, please analyze the example:\n\nSuppose $L = 4$, $K = 1$.\n\nBefore the first experiment starts, the letters displayed by each cell are as shown below:\n\n![](https://cdn.luogu.com.cn/upload/pic/6849.png)\n\nJodie starts walking from the cell showing the letter `a`. Aiden tells her to stop after she has stepped into $K$ repeated cells, so Jodie takes a total of $5$ steps. After each step, the cells change as follows (the arrow points to the cell where Jodie is):\n\n![](https://cdn.luogu.com.cn/upload/pic/6850.png)\n\nJodie’s second experiment starts from the cell showing the letter `c`. After each step, the cells change as follows (the arrow points to the cell where Jodie is):\n\n![](https://cdn.luogu.com.cn/upload/pic/6851.png)\n\nThe two paths recorded by Jodie are:\n\n`abcdx`\n\n`cdabz`\n\nNow you are given the length $N$ of each of Jodie’s two recorded paths, and the two strings she wrote down, but $K$ is unknown. Please find the maximum possible value of $L$.", "inputFormat": "The first line contains an integer $N$.\n\nThe second line contains a string of length $N$, consisting only of lowercase letters.\n\nThe third line contains a string of length $N$, consisting only of lowercase letters.", "outputFormat": "Output a single number $L$, the maximum possible number of cells on the ring.", "hint": "Constraints:\n\n- For $20\\%$ of the testdata, $1 \\leq N \\leq 5{,}000$.\n- For $50\\%$ of the testdata, $1 \\leq N \\leq 600{,}000$.\n- For $100\\%$ of the testdata, $1 \\leq N \\leq 2{,}000{,}000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[GDOI2014] Beyond", "background": "", "description": "Jodie 慢慢地步入实验室，跟随在她身旁的灵体 Aiden 似乎有点不高兴，但还是形影不离地跟随着 Jodie。\n\n今天 Jodie 要进行的实验在一个很大很大的圆环上面，圆环上有 $L$ 个格子，每个格子上都显示着一个小写英文字母，Jodie 从任意格子开始当她离开一个格子的时候那个格子的字母就会改变，这个改变是随机的，没有人知道会变成什么。Jodie 在这个环上不回头顺时针地走，每进入一个格子就会在本子上写下这个格子当前显示的字母。由于 Jodie 不能回头而且不知道这个圆环上有多少个格子，她并不知道自己什么时候会走到重复的点，所以她让 Aiden 在她下一步走进重复格子的时候提醒一下。但可能他们闹了矛盾，Aiden 发了脾气，决定在 Jodie 走了 $K$（$K \\geq 0$）步重复的格子之后才告诉她。Jodie 进行了两次实验，记录了两次走的路径。第二次实验再进去之前，每个格子所显示的字母会被重设为第一次实验开始前的样子。Jodie 发现了 Aiden 的恶作剧，她只能把可能的最大的 $L$ 告诉实验人员。\n\n为了帮助你更好的理解题目，请仔细分析一下例子：\n\n假设 $L = 4$，$K = 1$\n\n第一次实验开始前每个格子显示的字母如下图：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6849.png) \n\nJodie 从显示字母为 `a` 的格子开始走，Aiden 在她走了 $K$ 步重复的格子之后告诉她停止，所以 Jodie 一共走了 $5$ 步，每走一步，格子的变化如下（箭头指着 Jodie 所在的格子）：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6850.png) \n\nJodie 的第二次实验从显示字母为 `c` 的格子开始走，每走一步格子的变化如下（箭头指着 Jodie 所在的格子）：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6851.png) \n\nJodie 两次实验记录的路径分别为：\n\n`abcdx`\n\n`cdabz`\n\n现在给出 Jodie 记录的两次路径的长度 $N$，以及 Jodie 所写的内容，但是并不知道 $K$ 是多少，希望你能帮忙求出一个最大的可能的 $L$。\n", "inputFormat": "第一行：包含一个整数 $N$。\n\n第二行：包含一个长度为 $N$ 的字符串，字符串中只包含小写字母。\n\n第三行：包含一个长度为 $N$ 的字符串，字符串中只包含小写字母。\n", "outputFormat": "输出答案只包含一个数字 $L$，表示圆环最大可能有的格子数。\n", "hint": "对于 $20\\%$ 的数据，$1 \\leq N \\leq 5,000$\n\n对于 $50\\%$ 的数据，$1 \\leq N \\leq 600,000$\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 2,000,000$\n", "locale": "zh-CN"}}}
{"pid": "P3894", "type": "P", "difficulty": 6, "samples": [["5\n3\n0 1 1\n0 2 1\n3\n0 1 2\n2 0 1\n3\n0 1 1\n0 2 1\n2\n0 1 2\n3\n0 1 1\n0 2 1\n3\n0 2 2 1\n0 0 2 1\n2 2 4 1\n", "5\n6\n-1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "各省省选", "广东"], "title": "[GDOI2014] 传送", "background": "", "description": "有 $n$ 个国家，编号分别为 $0$ 到 $n-1$。第 $i$ 个国家包含 $m_i$ 个城市，编号分别为 $0$ 到 $m_{i}-1$，其中编号为 $0$ 的城市是该国家的首都。为了表示的方便，我们用 $(i,j)$ 来表示第 $i$ 个国家的第 $j$ 个城市。同一个国家的城市之间有通路，这些通路构成一棵树，首都则是这棵树的根。而不同国家的城市之间没有通路，只能通过传送门。每个国家只有处于叶子节点的城市具有传送门，传送门的目的地可以是编号相邻的国家的任意一个处于叶子节点的城市，每次传送需要花费 $1$ 个单位时间，并且每个传送门只能使用一次。如下图所示，如果出发地是 $(0,2)$，目的地是 $(2,1)$，则 $(0,2)\\rightarrow(1,1)\\rightarrow(1,0)\\rightarrow(1,2)\\rightarrow(2,1)$ 是一条可行路径，而 $(0,2)\\rightarrow(1,1)\\rightarrow(2,1)$ 则是非法的，因为 $(1,1)$ 的传送门在 $(0,2)\\rightarrow(1,1)$ 的时候被使用了一次，在 $(1,1)\\rightarrow(2,1)$ 的时候又被使用了一次。\n\n ![](https://cdn.luogu.com.cn/upload/pic/6852.png) \n\n给定出发地和目的地，问最少需要多少时间。", "inputFormat": "输入第一行有一个正整数 $n$。\n\n接下来有 $n$ 个模块，每块描述一个国家的情况。每个模块的第一行是一个正整数 $m_i$，表示编号为 $i$ 的国家包含的城市个数，接下来 $m_{i}-1$ 行，每行包含三个整数 $u,v,t$，表示从城市 $u$ 到城市 $v$ 有通路，需要花费的时间为 $t (1 \\leq t \\leq 10^{3})$。\n\n接下来一行有一个正整数 $q$，表示查询的个数。接下来 $q$ 行，每一行包含四个整数，$s_0,s_1,e_0,e_1$，其中，$(s_0,s_1)$ 为出发地，$(e_0,e_1)$ 为目的地。", "outputFormat": "输出有 $q$ 行，每行只包含一个整数。如果能从出发地到达目的地，输出最少时间，否则，输出 $-1$。", "hint": "对于 $40\\%$ 的数据，$n \\leq 10,\\sum m_i \\leq 10^{3},q \\leq 10$。\n\n对于 $60\\%$ 的数据，$n \\leq 10^{3},\\sum m_i \\leq 10^{6}$。\n\n对于 $100\\%$ 的数据，$n \\leq 3.5 \\times 10^{5},\\sum m_i \\leq 10^{6},1 \\leq t \\leq 10^{3},q \\leq 10^{5}$。", "locale": "zh-CN", "translations": {"en": {"title": "[GDOI2014] Teleportation", "background": "", "description": "There are $n$ countries, numbered from $0$ to $n-1$. The $i$-th country contains $m_i$ cities, numbered from $0$ to $m_{i}-1$, where the city numbered $0$ is the capital. For convenience, we use $(i,j)$ to denote the $j$-th city of the $i$-th country. The cities within the same country are connected by roads that form a tree, with the capital as the root. There are no roads between cities of different countries; you can only travel via teleportation portals. In each country, only cities that are leaf nodes have teleportation portals, and the destination can be any leaf city in a country with an adjacent index. Each teleport takes $1$ unit of time, and each teleportation portal can be used only once. As shown in the figure below, if the starting point is $(0,2)$ and the destination is $(2,1)$, then $(0,2)\\rightarrow(1,1)\\rightarrow(1,0)\\rightarrow(1,2)\\rightarrow(2,1)$ is a feasible path, while $(0,2)\\rightarrow(1,1)\\rightarrow(2,1)$ is invalid, because the portal of $(1,1)$ was used once in $(0,2)\\rightarrow(1,1)$ and again in $(1,1)\\rightarrow(2,1)$.\n\n ![](https://cdn.luogu.com.cn/upload/pic/6852.png) \n\nGiven the starting point and the destination, find the minimum time required.", "inputFormat": "The first line contains a positive integer $n$.\n\nThen there are $n$ blocks, each describing one country. The first line of each block is a positive integer $m_i$, indicating that the country with index $i$ contains $m_i$ cities. Then follow $m_{i}-1$ lines, each containing three integers $u, v, t$, meaning there is a road between city $u$ and city $v$, and the time cost is $t$ ($1 \\leq t \\leq 10^{3}$).\n\nThe next line contains a positive integer $q$, the number of queries. Each of the next $q$ lines contains four integers $s_0, s_1, e_0, e_1$, where $(s_0, s_1)$ is the starting point and $(e_0, e_1)$ is the destination.", "outputFormat": "Output $q$ lines, each containing a single integer. If the destination is reachable from the starting point, output the minimum time; otherwise, output $-1$.", "hint": "For $40\\%$ of the testdata, $n \\leq 10, \\sum m_i \\leq 10^{3}, q \\leq 10$.\n\nFor $60\\%$ of the testdata, $n \\leq 10^{3}, \\sum m_i \\leq 10^{6}$.\n\nFor $100\\%$ of the testdata, $n \\leq 3.5 \\times 10^{5}, \\sum m_i \\leq 10^{6}, 1 \\leq t \\leq 10^{3}, q \\leq 10^{5}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[GDOI2014] 传送", "background": "", "description": "有 $n$ 个国家，编号分别为 $0$ 到 $n-1$。第 $i$ 个国家包含 $m_i$ 个城市，编号分别为 $0$ 到 $m_{i}-1$，其中编号为 $0$ 的城市是该国家的首都。为了表示的方便，我们用 $(i,j)$ 来表示第 $i$ 个国家的第 $j$ 个城市。同一个国家的城市之间有通路，这些通路构成一棵树，首都则是这棵树的根。而不同国家的城市之间没有通路，只能通过传送门。每个国家只有处于叶子节点的城市具有传送门，传送门的目的地可以是编号相邻的国家的任意一个处于叶子节点的城市，每次传送需要花费 $1$ 个单位时间，并且每个传送门只能使用一次。如下图所示，如果出发地是 $(0,2)$，目的地是 $(2,1)$，则 $(0,2)\\rightarrow(1,1)\\rightarrow(1,0)\\rightarrow(1,2)\\rightarrow(2,1)$ 是一条可行路径，而 $(0,2)\\rightarrow(1,1)\\rightarrow(2,1)$ 则是非法的，因为 $(1,1)$ 的传送门在 $(0,2)\\rightarrow(1,1)$ 的时候被使用了一次，在 $(1,1)\\rightarrow(2,1)$ 的时候又被使用了一次。\n\n ![](https://cdn.luogu.com.cn/upload/pic/6852.png) \n\n给定出发地和目的地，问最少需要多少时间。", "inputFormat": "输入第一行有一个正整数 $n$。\n\n接下来有 $n$ 个模块，每块描述一个国家的情况。每个模块的第一行是一个正整数 $m_i$，表示编号为 $i$ 的国家包含的城市个数，接下来 $m_{i}-1$ 行，每行包含三个整数 $u,v,t$，表示从城市 $u$ 到城市 $v$ 有通路，需要花费的时间为 $t (1 \\leq t \\leq 10^{3})$。\n\n接下来一行有一个正整数 $q$，表示查询的个数。接下来 $q$ 行，每一行包含四个整数，$s_0,s_1,e_0,e_1$，其中，$(s_0,s_1)$ 为出发地，$(e_0,e_1)$ 为目的地。", "outputFormat": "输出有 $q$ 行，每行只包含一个整数。如果能从出发地到达目的地，输出最少时间，否则，输出 $-1$。", "hint": "对于 $40\\%$ 的数据，$n \\leq 10,\\sum m_i \\leq 10^{3},q \\leq 10$。\n\n对于 $60\\%$ 的数据，$n \\leq 10^{3},\\sum m_i \\leq 10^{6}$。\n\n对于 $100\\%$ 的数据，$n \\leq 3.5 \\times 10^{5},\\sum m_i \\leq 10^{6},1 \\leq t \\leq 10^{3},q \\leq 10^{5}$。", "locale": "zh-CN"}}}
{"pid": "P3895", "type": "P", "difficulty": 6, "samples": [["5 4 3 1\n1001\n1101\n1111\n1110\n0111", "2 3 4\n2 3 4\n3 4 5\n2 3 5"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["贪心", "湖南", "Special Judge", "排序"], "title": "[湖南集训] Hungry Rabbit", "background": "", "description": "可怕的洪水在夏天不期而至，兔子王国遭遇了前所未有的饥荒，它们不得不去外面的森林里寻找食物。\n\n为了简化起见，我们假设兔子王国中有 $n$ 只兔子，编号为 $1$ 到 $n$。在救济粮到来之前的 $m$ 天中，每天恰好有 $k$ 只兔子需要去森林里寻找粮食。森林里居住着可怕的大灰狼，所幸兔子已经摸清了大灰狼捕食习惯，即狼们在每一天只会捕食特定编号的兔子。为了安全起见，兔子们需要保证每次出去觅食的 $k$ 只兔子都不会被狼捕食。\n\n由于每天出去捕食的兔子都不尽相同，它们为每一天定义了一个生疏度 $p_i$ ，即第 $i$ 天出来寻找食物，但是第 $i−1$ 天却没有出来觅食的兔子个数。规定第 $1$ 天的生疏度为 $0$。\n\n现在兔子们希望在保证安全的前提下，每天的生疏度不能超过 $l$，请为兔子们构造一个合法的方案。", "inputFormat": "\n第一行包括四个整数 $n, m, k, l$。\n\n接下来 $n$ 行，每行一个长度为 $m$ 的 $01$ 串。其中第 $i$ 行第 $j$ 个字符若为 $0$，则表示狼在第 $j$ 天会捕食编号为 $i$ 的兔子，为 $1$ 则表示不捕食。", "outputFormat": "共 $m$ 行，每行 $k$ 个 $1$ 到 $n$ 之间互不相同的整数，代表这一天出去寻找食物的兔子编号。\n\n如果没有合法方案，则输出一行 `−1` 即可。", "hint": "#### 样例 1 解释\n\n对于样例，在这 $4$ 天中，出去觅食的兔子集合分别为 $\\{2, 3, 4\\}; \\{2, 3, 4\\}; \\{3, 4, 5\\}; \\{2, 3, 5\\}$。\n\n---\n\n#### 数据规模与约定\n\n- 对于 $20\\%$ 的测试数据，保证 $1\\leq n,m\\leq 10$；\n- 对于 $100\\%$ 的测试数据，保证 $1\\leq n,m\\leq 800,$，$1\\leq k\\leq n$，$1\\leq l\\leq k$。", "locale": "zh-CN", "translations": {"en": {"title": "[Hunan Training Camp] Hungry Rabbit", "background": "", "description": "A terrible flood struck unexpectedly in the summer, and the Rabbit Kingdom suffered an unprecedented famine. They have to go to the forest to look for food.\n\nFor simplicity, suppose there are $n$ rabbits in the kingdom, numbered $1$ to $n$. During the $m$ days before relief arrives, exactly $k$ rabbits must go to the forest each day to gather food. Ferocious wolves live in the forest, but fortunately the rabbits have figured out the wolves’ hunting pattern: on each day, the wolves only hunt rabbits with certain indices. For safety, the $k$ rabbits sent out each day must all be ones that will not be hunted that day.\n\nBecause the rabbits going out differ from day to day, they define for each day a newcomer count $p_i$: the number of rabbits that go out on day $i$ but did not go out on day $i - 1$. By convention, $p_1 = 0$.\n\nNow the rabbits want, under the safety requirement, that the newcomer count each day does not exceed $l$. Please construct a valid plan.", "inputFormat": "The first line contains four integers $n, m, k, l$.\n\nThe next $n$ lines each contain a binary string of length $m$. In the $i$-th line, if the $j$-th character is $0$, then on day $j$ rabbit $i$ will be hunted; if it is $1$, then rabbit $i$ will not be hunted on that day.", "outputFormat": "Output $m$ lines. Each line should contain $k$ distinct integers between $1$ and $n$, representing the indices of the rabbits that go out to gather food on that day.\n\nIf there is no valid plan, output a single line with -1.", "hint": "Sample 1 Explanation\n\nFor the sample, over the $4$ days, the sets of rabbits going out are respectively {2, 3, 4}; {2, 3, 4}; {3, 4, 5}; {2, 3, 5}.\n\nConstraints\n\n- For $20\\%$ of the testdata, $1 \\le n, m \\le 10$.\n- For $100\\%$ of the testdata, $1 \\le n, m \\le 800$, $1 \\le k \\le n$, $1 \\le l \\le k$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[湖南集训] Hungry Rabbit", "background": "", "description": "可怕的洪水在夏天不期而至，兔子王国遭遇了前所未有的饥荒，它们不得不去外面的森林里寻找食物。\n\n为了简化起见，我们假设兔子王国中有 $n$ 只兔子，编号为 $1$ 到 $n$。在救济粮到来之前的 $m$ 天中，每天恰好有 $k$ 只兔子需要去森林里寻找粮食。森林里居住着可怕的大灰狼，所幸兔子已经摸清了大灰狼捕食习惯，即狼们在每一天只会捕食特定编号的兔子。为了安全起见，兔子们需要保证每次出去觅食的 $k$ 只兔子都不会被狼捕食。\n\n由于每天出去捕食的兔子都不尽相同，它们为每一天定义了一个生疏度 $p_i$ ，即第 $i$ 天出来寻找食物，但是第 $i−1$ 天却没有出来觅食的兔子个数。规定第 $1$ 天的生疏度为 $0$。\n\n现在兔子们希望在保证安全的前提下，每天的生疏度不能超过 $l$，请为兔子们构造一个合法的方案。", "inputFormat": "\n第一行包括四个整数 $n, m, k, l$。\n\n接下来 $n$ 行，每行一个长度为 $m$ 的 $01$ 串。其中第 $i$ 行第 $j$ 个字符若为 $0$，则表示狼在第 $j$ 天会捕食编号为 $i$ 的兔子，为 $1$ 则表示不捕食。", "outputFormat": "共 $m$ 行，每行 $k$ 个 $1$ 到 $n$ 之间互不相同的整数，代表这一天出去寻找食物的兔子编号。\n\n如果没有合法方案，则输出一行 `−1` 即可。", "hint": "#### 样例 1 解释\n\n对于样例，在这 $4$ 天中，出去觅食的兔子集合分别为 $\\{2, 3, 4\\}; \\{2, 3, 4\\}; \\{3, 4, 5\\}; \\{2, 3, 5\\}$。\n\n---\n\n#### 数据规模与约定\n\n- 对于 $20\\%$ 的测试数据，保证 $1\\leq n,m\\leq 10$；\n- 对于 $100\\%$ 的测试数据，保证 $1\\leq n,m\\leq 800,$，$1\\leq k\\leq n$，$1\\leq l\\leq k$。", "locale": "zh-CN"}}}
{"pid": "P3896", "type": "P", "difficulty": 6, "samples": [["4 10000\n", "8276"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["湖南"], "title": "[湖南集训] Clever Rabbit", "background": "", "description": "聪明的兔子定义了三个函数:\n\n- $g(x)$ 表示将 $x$ 十进制表示中各位数字从高位到低位降序排列组成的数字。\n\n- $l(x)$ 表示将 $x$ 十进制表示中各位数字从高位到低位升序排列组成的数字。\n\n- $f(x)=g(x)-l(x)$。\n\n如果一个数 $x$ 与 $f(x)$ 相等，兔子们称它为幸运数。现在兔子们希望计算在所有的 $n$ 位数字中，所有幸运数的平方的和。结果对 $p$ 取模后输出，注意这里数字可以包含前导 $0$。", "inputFormat": "一行两个整数 $n,p$。", "outputFormat": "一行一个整数，表示所求的结果。", "hint": "#### 数据规模与约定\n- 对于 $20\\%$ 的测试数据，保证 $1\\leq n\\leq 10$。\n- 对于 $100\\%$ 的测试数据，保证 $1\\leq n\\leq 30$，$1\\leq p\\leq 2\\times 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[Hunan Training Camp] Clever Rabbit", "background": "", "description": "The clever rabbit defines three functions:\n\n- $g(x)$ denotes the number formed by arranging the digits of the decimal representation of $x$ in descending order.\n- $l(x)$ denotes the number formed by arranging the digits of the decimal representation of $x$ in ascending order.\n- $f(x)=g(x)-l(x)$.\n\nIf a number $x$ equals $f(x)$, the rabbits call it a lucky number. Now the rabbits want to compute the sum of squares of all lucky numbers among all $n$-digit numbers. Output the result modulo $p$. Note that numbers may contain leading $0$s.", "inputFormat": "One line with two integers $n,p$.", "outputFormat": "One line with one integer, the required result.", "hint": "#### Constraints\n- For $20\\%$ of the testdata, it is guaranteed that $1 \\leq n \\leq 10$.\n- For $100\\%$ of the testdata, it is guaranteed that $1 \\leq n \\leq 30$, $1 \\leq p \\leq 2 \\times 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[湖南集训] Clever Rabbit", "background": "", "description": "聪明的兔子定义了三个函数:\n\n- $g(x)$ 表示将 $x$ 十进制表示中各位数字从高位到低位降序排列组成的数字。\n\n- $l(x)$ 表示将 $x$ 十进制表示中各位数字从高位到低位升序排列组成的数字。\n\n- $f(x)=g(x)-l(x)$。\n\n如果一个数 $x$ 与 $f(x)$ 相等，兔子们称它为幸运数。现在兔子们希望计算在所有的 $n$ 位数字中，所有幸运数的平方的和。结果对 $p$ 取模后输出，注意这里数字可以包含前导 $0$。", "inputFormat": "一行两个整数 $n,p$。", "outputFormat": "一行一个整数，表示所求的结果。", "hint": "#### 数据规模与约定\n- 对于 $20\\%$ 的测试数据，保证 $1\\leq n\\leq 10$。\n- 对于 $100\\%$ 的测试数据，保证 $1\\leq n\\leq 30$，$1\\leq p\\leq 2\\times 10^9$。", "locale": "zh-CN"}}}
{"pid": "P3897", "type": "P", "difficulty": 6, "samples": [["6 3\n0 6\n-7 -4\n-3 -2\n7 -5\n-2 3\n8 -3", "4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["湖南", "枚举", "排序"], "title": "[湖南集训] Crazy Rabbit", "background": "", "description": "兔子们决定在自己的城堡里安排一些士兵进行防守。\n\n给出 $n$ 个点的坐标，和城堡里一个圆心在原点的圆形的障碍，兔子们希望从中选出 $k$ 个兔子，使得它们两两**所在的直线**都不与圆相交。\n\n兔子们希望知道最多能选出多少兔子。", "inputFormat": "第一行两个整数 $n$ 和 $r$，表示兔子的个数和圆的半径。\n\n接下来 $n$ 行，每行两个整数 $x_i$ 和 $y_i$，表示第 $i$ 只兔子的坐标\n\n保证每只兔子都严格在障碍外部，且两两所在的直线不与圆相切。", "outputFormat": "输出一行一个整数, 表示最多能选出多少兔子", "hint": "#### 样例 1 解释\n\n ![](https://cdn.luogu.com.cn/upload/pic/6853.png) \n\n选择第 $1, 2, 6, 4$ 只兔子即可。\n\n---\n\n#### 数据规模与约定\n\n- 对于 $10\\%$ 的数据，保证 $1\\leq n\\leq 20$。\n- 对于 $30\\%$ 的数据，保证 $1\\leq n\\leq 100$。\n- 对于 $100\\%$ 的数据，保证 $1\\leq n\\leq 2000$，$1\\leq r,x_i,y_i \\leq 5000$。", "locale": "zh-CN", "translations": {"en": {"title": "[Hunan Training Camp] Crazy Rabbit", "background": "", "description": "The rabbits decide to station some soldiers in their castle.\n\nGiven the coordinates of $n$ points and a circular obstacle in the castle whose center is at the origin, the rabbits want to choose $k$ rabbits such that, for every pair of chosen rabbits, the line determined by them does not intersect the circle.\n\nThe rabbits want to know the maximum number of rabbits they can choose.", "inputFormat": "The first line contains two integers $n$ and $r$, denoting the number of rabbits and the radius of the circle.\n\nThen $n$ lines follow. Each line contains two integers $x_i$ and $y_i$, representing the coordinates of the $i$-th rabbit.\n\nIt is guaranteed that every rabbit lies strictly outside the obstacle, and that for any two rabbits, the line through them is not tangent to the circle.", "outputFormat": "Output a single integer on one line, representing the maximum number of rabbits that can be chosen.", "hint": "#### Sample 1 Explanation\n\n![](https://cdn.luogu.com.cn/upload/pic/6853.png)\n\nChoosing rabbits $1, 2, 6, 4$ works.\n\n---\n\n#### Constraints\n\n- For $10\\%$ of the testdata, $1\\leq n\\leq 20$.\n- For $30\\%$ of the testdata, $1\\leq n\\leq 100$.\n- For $100\\%$ of the testdata, $1\\leq n\\leq 2000$ and $1\\leq r,x_i,y_i \\leq 5000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[湖南集训] Crazy Rabbit", "background": "", "description": "兔子们决定在自己的城堡里安排一些士兵进行防守。\n\n给出 $n$ 个点的坐标，和城堡里一个圆心在原点的圆形的障碍，兔子们希望从中选出 $k$ 个兔子，使得它们两两**所在的直线**都不与圆相交。\n\n兔子们希望知道最多能选出多少兔子。", "inputFormat": "第一行两个整数 $n$ 和 $r$，表示兔子的个数和圆的半径。\n\n接下来 $n$ 行，每行两个整数 $x_i$ 和 $y_i$，表示第 $i$ 只兔子的坐标\n\n保证每只兔子都严格在障碍外部，且两两所在的直线不与圆相切。", "outputFormat": "输出一行一个整数, 表示最多能选出多少兔子", "hint": "#### 样例 1 解释\n\n ![](https://cdn.luogu.com.cn/upload/pic/6853.png) \n\n选择第 $1, 2, 6, 4$ 只兔子即可。\n\n---\n\n#### 数据规模与约定\n\n- 对于 $10\\%$ 的数据，保证 $1\\leq n\\leq 20$。\n- 对于 $30\\%$ 的数据，保证 $1\\leq n\\leq 100$。\n- 对于 $100\\%$ 的数据，保证 $1\\leq n\\leq 2000$，$1\\leq r,x_i,y_i \\leq 5000$。", "locale": "zh-CN"}}}
