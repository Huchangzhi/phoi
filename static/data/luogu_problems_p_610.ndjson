{"pid": "P13375", "type": "P", "difficulty": 4, "samples": [["2\n6 7 2\n1111111\n1122271\n1211521\n1329131\n1242121\n1122211\n3 3 7\n123\n234\n345", "Case #1: 5\nCase #2: IMPOSSIBLE"]], "limits": {"time": [3000, 6000], "memory": [1048576, 1048576]}, "tags": ["2011", "前缀和", "Google Code Jam"], "title": "[GCJ 2011 #2] Spinning Blade", "background": "", "description": "Being bored with the traps in your secret hideout design, you decided to go for something classical, but always enjoyable - the *spinning blade*. You ordered a really heavy metal sheet out of which you will cut the blade; a uniform square $C$-by-$R$ grid will be painted on the sheet. You have determined the best shape for the blade -- you will first cut a large square consisting of $K$-by-$K$ grid cells, where $K \\geq 3$. Then, you will cut out the four 1-by-1 corner cells out of the square to end up with a *blade*. After determining all this, you started waiting for the sheet to arrive.\n\nWhen the sheet arrived, you were shocked to find out that the sheet had imperfections in it! You expected each cell to have mass $D$, but it turned out that the mass can vary a bit because of differences in thickness. This is bad because you want to insert a shaft exactly in the center of the blade and spin it very fast, so the center of mass of the blade must be exactly in its center as well. The definition of the center of mass of a flat body can be found below.\n\nGiven the grid and the mass of each cell, what is the largest possible size of the blade you can make so that the center of mass is exactly in its center?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each one starts with a line containing 3 integers: $R$, $C$ and $D$ — the dimensions of the grid and the mass you expected each cell to have. The next $R$ lines each contain $C$ digits $w_{ij}$ each, giving the differences between the actual and the expected mass of the grid cells. Each cell has a uniform density, but could have an integer mass between $D+0$ and $D+9$, inclusive.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $K$\", where $x$ is the case number (starting from $1$) and $K$ is the largest possible size of the blade you can cut out. If no acceptable blade of size at least $3$ can be found, print \"IMPOSSIBLE\" instead.", "hint": "**Sample Explanation**\n\nThe center of mass of a 2D object is formally defined as a point $c$. If you compute the sum of $(p - c) \\times \\text{mass}(p)$ for all points $p$ in the object, you must get $0$. Here, $p$, $c$ and $0$ are two-dimensional vectors. This definition also works if you treat each grid cell as a \"point\", with all of its mass at its center.\n\nIn real life, you could place your finger under a flat object's center of mass, and balance that object on your finger. It would not fall.\n\nTo illustrate with an example, the only blade that is possible to cut out in the second sample test case, the $3\\times 3$ blade created by cutting away the corners, has its center of mass at the point $(1.54, 1.46)$, where we assume the bottom-left corner of the sheet has coordinates $(0, 0)$, and the coordinates grow right and up, respectively. This is verified by checking the following equality: $(-1.04, 0.04) \\times 9 + (-0.04, 1.04) \\times 9 + (-0.04, 0.04) \\times 10 + (-0.04, -0.96) \\times 11 + (0.96, 0.04) \\times 11 = (0, 0)$.\n\n**Limits**\n\n- $1 \\leq T \\leq 20$.\n- $0 \\leq w_{ij} \\leq 9$.\n- The size of the input file will not exceed 625KB.\n\n**Small dataset (8 Pts, Test set 1 - Visible)**\n\n- $3 \\leq R \\leq 10$.\n-$3 \\leq C \\leq 10$.\n- $1 \\leq D \\leq 100$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (12 Pts, Test set 2 - Hidden)**\n\n- $3 \\leq R \\leq 500$.\n- $3 \\leq C \\leq 500$.\n- $1 \\leq D \\leq 10^6$.\n- Time limit: ~~60~~ 6 seconds.", "locale": "en", "translations": {"en": {"title": "[GCJ 2011 #2] Spinning Blade", "background": "", "description": "Being bored with the traps in your secret hideout design, you decided to go for something classical, but always enjoyable - the *spinning blade*. You ordered a really heavy metal sheet out of which you will cut the blade; a uniform square $C$-by-$R$ grid will be painted on the sheet. You have determined the best shape for the blade -- you will first cut a large square consisting of $K$-by-$K$ grid cells, where $K \\geq 3$. Then, you will cut out the four 1-by-1 corner cells out of the square to end up with a *blade*. After determining all this, you started waiting for the sheet to arrive.\n\nWhen the sheet arrived, you were shocked to find out that the sheet had imperfections in it! You expected each cell to have mass $D$, but it turned out that the mass can vary a bit because of differences in thickness. This is bad because you want to insert a shaft exactly in the center of the blade and spin it very fast, so the center of mass of the blade must be exactly in its center as well. The definition of the center of mass of a flat body can be found below.\n\nGiven the grid and the mass of each cell, what is the largest possible size of the blade you can make so that the center of mass is exactly in its center?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each one starts with a line containing 3 integers: $R$, $C$ and $D$ — the dimensions of the grid and the mass you expected each cell to have. The next $R$ lines each contain $C$ digits $w_{ij}$ each, giving the differences between the actual and the expected mass of the grid cells. Each cell has a uniform density, but could have an integer mass between $D+0$ and $D+9$, inclusive.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $K$\", where $x$ is the case number (starting from $1$) and $K$ is the largest possible size of the blade you can cut out. If no acceptable blade of size at least $3$ can be found, print \"IMPOSSIBLE\" instead.", "hint": "**Sample Explanation**\n\nThe center of mass of a 2D object is formally defined as a point $c$. If you compute the sum of $(p - c) \\times \\text{mass}(p)$ for all points $p$ in the object, you must get $0$. Here, $p$, $c$ and $0$ are two-dimensional vectors. This definition also works if you treat each grid cell as a \"point\", with all of its mass at its center.\n\nIn real life, you could place your finger under a flat object's center of mass, and balance that object on your finger. It would not fall.\n\nTo illustrate with an example, the only blade that is possible to cut out in the second sample test case, the $3\\times 3$ blade created by cutting away the corners, has its center of mass at the point $(1.54, 1.46)$, where we assume the bottom-left corner of the sheet has coordinates $(0, 0)$, and the coordinates grow right and up, respectively. This is verified by checking the following equality: $(-1.04, 0.04) \\times 9 + (-0.04, 1.04) \\times 9 + (-0.04, 0.04) \\times 10 + (-0.04, -0.96) \\times 11 + (0.96, 0.04) \\times 11 = (0, 0)$.\n\n**Limits**\n\n- $1 \\leq T \\leq 20$.\n- $0 \\leq w_{ij} \\leq 9$.\n- The size of the input file will not exceed 625KB.\n\n**Small dataset (8 Pts, Test set 1 - Visible)**\n\n- $3 \\leq R \\leq 10$.\n-$3 \\leq C \\leq 10$.\n- $1 \\leq D \\leq 100$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (12 Pts, Test set 2 - Hidden)**\n\n- $3 \\leq R \\leq 500$.\n- $3 \\leq C \\leq 500$.\n- $1 \\leq D \\leq 10^6$.\n- Time limit: ~~60~~ 6 seconds.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2011 #2] Spinning Blade", "background": null, "description": "你对自己秘密基地设计中的陷阱感到厌倦，决定采用一种经典但总是令人愉快的装置——“旋转刀片”。你订购了一块非常重的金属板，准备从中切割出刀片；在金属板上会绘制一个均匀的 $C$ 行 $R$ 列的方格。你已经确定了刀片的最佳形状——你将首先切割出一个 $K \\times K$ 的大正方形方格，其中 $K \\geq 3$。然后，你会将该正方形的四个 $1 \\times 1$ 的角格切掉，最终得到一个“刀片”。确定好这些后，你就开始等待金属板的到来。\n\n当金属板到达时，你震惊地发现板材有瑕疵！你原本期望每个格子的质量都是 $D$，但实际上由于厚度的差异，每个格子的质量会有些许变化。这很糟糕，因为你想要在刀片的正中心插入一个轴并让其高速旋转，因此刀片的质心必须恰好位于其中心。二维物体的质心定义见下文。\n\n给定方格和每个格子的质量，求你能切割出的最大尺寸的刀片，使得其质心恰好位于中心。", "inputFormat": "输入的第一行是测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据第一行为三个整数：$R$、$C$ 和 $D$——方格的行数、列数以及你期望每个格子的质量。接下来的 $R$ 行每行包含 $C$ 个数字 $w_{ij}$，表示实际质量与期望质量的差值。每个格子的实际质量为 $D + w_{ij}$，其中 $0 \\leq w_{ij} \\leq 9$。", "outputFormat": "对于每个测试用例，输出一行，格式为 “Case #$x$: $K$”，其中 $x$ 是测试用例编号（从 $1$ 开始），$K$ 是你能切割出的最大刀片尺寸。如果不存在尺寸至少为 $3$ 且满足条件的刀片，输出 “IMPOSSIBLE”。", "hint": "**样例说明**\n\n二维物体的质心正式定义为一个点 $c$。如果你对物体中的所有点 $p$ 计算 $(p - c) \\times \\text{mass}(p)$ 的和，结果必须为 $0$。其中 $p$、$c$ 和 $0$ 都是二维向量。这个定义同样适用于将每个格子视为一个“点”，其全部质量集中在中心。\n\n在现实生活中，你可以把手指放在一个平面物体的质心下方，并让物体平衡在手指上，它不会倾倒。\n\n举例来说，在第二个样例测试中，唯一可行的刀片是 $3 \\times 3$ 的刀片（去掉四个角），其质心位于点 $(1.54, 1.46)$，假设金属板左下角坐标为 $(0, 0)$，坐标分别向右和向上递增。可以通过以下等式验证：$(-1.04, 0.04) \\times 9 + (-0.04, 1.04) \\times 9 + (-0.04, 0.04) \\times 10 + (-0.04, -0.96) \\times 11 + (0.96, 0.04) \\times 11 = (0, 0)$。\n\n**数据范围**\n\n- $1 \\leq T \\leq 20$。\n- $0 \\leq w_{ij} \\leq 9$。\n- 输入文件大小不超过 625KB。\n\n**小数据范围（8 分，测试点 1 - 可见）**\n\n- $3 \\leq R \\leq 10$。\n- $3 \\leq C \\leq 10$。\n- $1 \\leq D \\leq 100$。\n- 时间限制：3 秒。\n\n**大数据范围（12 分，测试点 2 - 隐藏）**\n\n- $3 \\leq R \\leq 500$。\n- $3 \\leq C \\leq 500$。\n- $1 \\leq D \\leq 10^6$。\n- 时间限制：6 秒。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13376", "type": "P", "difficulty": 4, "samples": [["4\n1\n3\n6\n16", "Case #1: 0\nCase #2: 1\nCase #3: 2\nCase #4: 5"]], "limits": {"time": [3000, 6000], "memory": [1048576, 1048576]}, "tags": ["数学", "2011", "二分", "数论", "素数判断,质数,筛法", "Google Code Jam"], "title": "[GCJ 2011 #2] Expensive Dinner", "background": "", "description": "Your friends are all going to a restaurant for dinner tonight. They're all very good at math, but they're all very strange: your $a^{\\text{th}}$ friend (starting from 1) will be unhappy unless the total cost of the meal is a positive integer, and is divisible by $a$.\n\nYour friends enter the restaurant one at a time. As soon as someone enters the restaurant, if that person is unhappy then the group will call a waiter immediately.\n\nAs long as there is at least one unhappy person in the restaurant, one of those unhappy people will buy the lowest-cost item that will make him or her happy. This will continue until nobody in the restaurant is unhappy, and then the waiter will leave. Fortunately, the restaurant sells food at every integer price. See the explanation of the first test case for an example.\n\nYour friends could choose to enter the restaurant in any order. After the waiter has been called, if there is more than one unhappy person in the restaurant, any one of those unhappy people could choose to buy something first. The way in which all of those choices are made could have an effect on how many times the group calls a waiter.\n\nAs the owner of the restaurant, you employ some very tired waiters. You want to calculate the spread of your friends: the difference between the maximum number of times they might call a waiter and the minimum number of times they might call a waiter.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow, each on its own line. Each test case will contain one integer $N$, the number of friends you have.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the spread for that test case.", "hint": "**Sample Explanation**\n\nIn Case #2, suppose your friends arrive in the order $[1, 2, 3]$. Then #1 arrives; is unhappy; calls a waiter; and buys something costing $1$. Now nobody is unhappy. #2 arrives next; is unhappy; calls a waiter; and buys something costing $1$ (for a total of $2$). Now nobody is unhappy. #3 arrives next; is unhappy; calls a waiter; and buys something costing $1$ (for a total of $3$). Now #2 is unhappy, and buys something costing $1$ (for a total of $4$). Now #3 is unhappy, and buys something costing $2$ (for a total of $6$). Finally nobody is unhappy, and a waiter was called three times.\n\nSuppose instead that your friends arrived in the order $[3, 1, 2]$. Then #3 arrives; is unhappy; calls a waiter; and buys something costing $3$. Now nobody is unhappy. #1 arrives next; nobody is unhappy. #2 arrives next; is unhappy; calls a waiter; and buys something costing $1$ (for a total of $4$). Now #3 is unhappy, and buys something costing $2$ (for a total of $6$). Now nobody is unhappy, and a waiter was called two times. The spread is $1$.\n\n**Limits**\n\n**Small dataset (13 Pts, Test set 1 - Visible)**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq N \\leq 1000$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (17 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq T \\leq 1000$.\n- $1 \\leq N \\leq 10^{12}$.\n- Time limit: ~~60~~ 6 seconds.", "locale": "en", "translations": {"en": {"title": "[GCJ 2011 #2] Expensive Dinner", "background": "", "description": "Your friends are all going to a restaurant for dinner tonight. They're all very good at math, but they're all very strange: your $a^{\\text{th}}$ friend (starting from 1) will be unhappy unless the total cost of the meal is a positive integer, and is divisible by $a$.\n\nYour friends enter the restaurant one at a time. As soon as someone enters the restaurant, if that person is unhappy then the group will call a waiter immediately.\n\nAs long as there is at least one unhappy person in the restaurant, one of those unhappy people will buy the lowest-cost item that will make him or her happy. This will continue until nobody in the restaurant is unhappy, and then the waiter will leave. Fortunately, the restaurant sells food at every integer price. See the explanation of the first test case for an example.\n\nYour friends could choose to enter the restaurant in any order. After the waiter has been called, if there is more than one unhappy person in the restaurant, any one of those unhappy people could choose to buy something first. The way in which all of those choices are made could have an effect on how many times the group calls a waiter.\n\nAs the owner of the restaurant, you employ some very tired waiters. You want to calculate the spread of your friends: the difference between the maximum number of times they might call a waiter and the minimum number of times they might call a waiter.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow, each on its own line. Each test case will contain one integer $N$, the number of friends you have.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the spread for that test case.", "hint": "**Sample Explanation**\n\nIn Case #2, suppose your friends arrive in the order $[1, 2, 3]$. Then #1 arrives; is unhappy; calls a waiter; and buys something costing $1$. Now nobody is unhappy. #2 arrives next; is unhappy; calls a waiter; and buys something costing $1$ (for a total of $2$). Now nobody is unhappy. #3 arrives next; is unhappy; calls a waiter; and buys something costing $1$ (for a total of $3$). Now #2 is unhappy, and buys something costing $1$ (for a total of $4$). Now #3 is unhappy, and buys something costing $2$ (for a total of $6$). Finally nobody is unhappy, and a waiter was called three times.\n\nSuppose instead that your friends arrived in the order $[3, 1, 2]$. Then #3 arrives; is unhappy; calls a waiter; and buys something costing $3$. Now nobody is unhappy. #1 arrives next; nobody is unhappy. #2 arrives next; is unhappy; calls a waiter; and buys something costing $1$ (for a total of $4$). Now #3 is unhappy, and buys something costing $2$ (for a total of $6$). Now nobody is unhappy, and a waiter was called two times. The spread is $1$.\n\n**Limits**\n\n**Small dataset (13 Pts, Test set 1 - Visible)**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq N \\leq 1000$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (17 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq T \\leq 1000$.\n- $1 \\leq N \\leq 10^{12}$.\n- Time limit: ~~60~~ 6 seconds.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2011 #2] Expensive Dinner", "background": null, "description": "你的朋友们今晚都要去一家餐厅吃饭。他们都非常擅长数学，但也都很奇怪：你的第 $a$ 个朋友（从 1 开始编号）只有当餐费总额是一个正整数且能被 $a$ 整除时才会感到满意。\n\n你的朋友们会依次进入餐厅。每当有一个人进入餐厅时，如果那个人不满意，那么这群人会立刻叫来一位服务员。\n\n只要餐厅里至少有一个不满意的人，这些不满意的人中就会有一个人购买一份最低价格的食物，使自己变得满意。这个过程会一直持续，直到餐厅里没有人不满意为止，然后服务员才会离开。幸运的是，餐厅出售每一个整数价格的食物。具体例子见第一个样例的解释。\n\n你的朋友们可以以任意顺序进入餐厅。在叫来服务员之后，如果餐厅里有多个人不满意，可以由其中任意一个人先购买食物。所有这些选择的方式可能会影响这群人叫服务员的次数。\n\n作为餐厅老板，你雇佣了一些非常疲惫的服务员。你想要计算你朋友们的“分布值”：他们可能叫服务员的最大次数与最小次数之差。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。接下来的 $T$ 行，每行包含一个整数 $N$，表示你有多少个朋友。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #$x$: $y$\"，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是该测试用例的分布值。", "hint": "**样例解释**\n\n在第 2 个样例中，假设你的朋友们按顺序 $[1, 2, 3]$ 进入。第 1 号朋友进入，不满意，叫来服务员，买了一份价格为 $1$ 的食物。现在没人不满意。接着第 2 号朋友进入，不满意，叫来服务员，买了一份价格为 $1$ 的食物（总价为 $2$）。现在没人不满意。第 3 号朋友进入，不满意，叫来服务员，买了一份价格为 $1$ 的食物（总价为 $3$）。现在第 2 号朋友不满意，买了一份价格为 $1$ 的食物（总价为 $4$）。现在第 3 号朋友不满意，买了一份价格为 $2$ 的食物（总价为 $6$）。最终没人不满意，总共叫了三次服务员。\n\n如果朋友们的进入顺序是 $[3, 1, 2]$。第 3 号朋友进入，不满意，叫来服务员，买了一份价格为 $3$ 的食物。现在没人不满意。接着第 1 号朋友进入，没有人不满意。第 2 号朋友进入，不满意，叫来服务员，买了一份价格为 $1$ 的食物（总价为 $4$）。现在第 3 号朋友不满意，买了一份价格为 $2$ 的食物（总价为 $6$）。现在没人不满意，总共叫了两次服务员。分布值为 $1$。\n\n**数据范围**\n\n**小数据集（13 分，测试点 1 - 可见）**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq N \\leq 1000$。\n- 时间限制：3 秒。\n\n**大数据集（17 分，测试点 2 - 隐藏）**\n\n- $1 \\leq T \\leq 1000$。\n- $1 \\leq N \\leq 10^{12}$。\n- 时间限制：6 秒。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13377", "type": "P", "difficulty": 5, "samples": [["4\n2 1\n0,1\n3 3\n0,1 1,2 0,2\n5 5\n0,4 0,2 2,4 1,2 1,4\n7 9\n0,6 0,2 0,4 2,4 3,4 2,3 3,5 4,5 1,5", "Case #1: 0 1\nCase #2: 0 2\nCase #3: 1 2\nCase #4: 2 4"]], "limits": {"time": [3000, 6000], "memory": [1048576, 1048576]}, "tags": ["图论", "2011", "广度优先搜索 BFS", "bitset", "Google Code Jam"], "title": "[GCJ 2011 #2] A.I. War", "background": "A.I. War is a real-time strategy game developed by Arcen Games. This problem was inspired by the game, but does not assume you have played it.\n\nArcen Games is the creator of A.I. War. Arcen Games does not endorse and has no involvement with Google Code Jam.", "description": "You're facing an artificial intelligence in a deadly war for the future of the galaxy. In order to defeat the A.I., you will need to threaten its $home\\ planet$. Some planets are connected to each other by wormholes; any planet may be connected to any number of other planets using the wormholes.\n\nYou begin by owning only your home planet. Each turn, you may conquer any planet you $threaten$. You threaten a planet if you don't own it, and it is connected by a wormhole to any of the planets you own. Once you have conquered a planet, you own it. As soon as you threaten the A.I.'s home planet, you may not conquer any more planets.\n\nWhile attending the most important day in tactical school, you discovered two things about the A.I.:\n\n* For each planet you conquer, the A.I. will become more powerful, because it will see you as a threat and produce more ships to defend itself.\n* The A.I. will defend every planet you're currently threatening.\n\nYou have combined those two facts to create a strategy:\n\n1. You will conquer planets until you threaten the A.I.'s home base.\n2. If there are multiple ways of completing step 1, do it while conquering the $smallest$ possible number of planets.\n3. If there are multiple ways of completing step 2, do it so that at the end you will threaten the $largest$ possible number of planets.\n\nGiven the planets and the wormholes, how many planets will you conquer and threaten on your way to the A.I.'s home base if you follow the strategy described above?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case starts with a single line containing two space-separated integers: $P$, the number of planets, and $W$, the number of wormholes. Your home planet is planet $0$, and the A.I.'s home planet is planet $1$.\n\nThe second line of each test case will contain $W$ space-separated pairs of comma-separated integers $x_{i}, y_{i}$. Each of these indicates that there is a two-way wormhole connecting planets $x_{i}$ and $y_{i}$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $c\\ t$\", where $x$ is the case number (starting from $1$), $c$ is the number of planets you conquer if you follow the above strategy, and $t$ is the number of planets you threaten at the end (including the A.I.'s home planet).", "hint": "**Sample Explanation**\n\nIn the first case, you don't have to conquer anything, and you're already threatening the A.I.'s home planet.\n\nIn the third case, you can threaten the A.I.'s home planet after conquering only one planet. You end up threatening two planets, and there's an extra planet that isn't connected to anything.\n\nIn the fourth case, you can threaten the A.I.'s home planet by conquering planets $4$ and $5$. You end up threatening planets $6$, $2$, $3$ and $1$ (the A.I.'s home planet).\n\n**Limits**\n\n- $1 \\leq T \\leq 50$.\n- $0 \\leq x_{i} < y_{i} < P$.\n- Each wormhole is unique: If $i \\neq j$, then $(x_{i}, y_{i}) \\neq (x_{j}, y_{j})$.\n- There will be at least one way to reach the A.I.'s home planet from your home planet using a series of wormholes.\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $2 \\leq P \\leq 36$.\n- $1 \\leq W \\leq 630$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (22 Pts, Test set 2 - Hidden)**\n\n- $2 \\leq P \\leq 400$.\n- $1 \\leq W \\leq 2000$.\n- Time limit: ~~60~~ 6 seconds.", "locale": "en", "translations": {"en": {"title": "[GCJ 2011 #2] A.I. War", "background": "A.I. War is a real-time strategy game developed by Arcen Games. This problem was inspired by the game, but does not assume you have played it.\n\nArcen Games is the creator of A.I. War. Arcen Games does not endorse and has no involvement with Google Code Jam.", "description": "You're facing an artificial intelligence in a deadly war for the future of the galaxy. In order to defeat the A.I., you will need to threaten its $home\\ planet$. Some planets are connected to each other by wormholes; any planet may be connected to any number of other planets using the wormholes.\n\nYou begin by owning only your home planet. Each turn, you may conquer any planet you $threaten$. You threaten a planet if you don't own it, and it is connected by a wormhole to any of the planets you own. Once you have conquered a planet, you own it. As soon as you threaten the A.I.'s home planet, you may not conquer any more planets.\n\nWhile attending the most important day in tactical school, you discovered two things about the A.I.:\n\n* For each planet you conquer, the A.I. will become more powerful, because it will see you as a threat and produce more ships to defend itself.\n* The A.I. will defend every planet you're currently threatening.\n\nYou have combined those two facts to create a strategy:\n\n1. You will conquer planets until you threaten the A.I.'s home base.\n2. If there are multiple ways of completing step 1, do it while conquering the $smallest$ possible number of planets.\n3. If there are multiple ways of completing step 2, do it so that at the end you will threaten the $largest$ possible number of planets.\n\nGiven the planets and the wormholes, how many planets will you conquer and threaten on your way to the A.I.'s home base if you follow the strategy described above?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case starts with a single line containing two space-separated integers: $P$, the number of planets, and $W$, the number of wormholes. Your home planet is planet $0$, and the A.I.'s home planet is planet $1$.\n\nThe second line of each test case will contain $W$ space-separated pairs of comma-separated integers $x_{i}, y_{i}$. Each of these indicates that there is a two-way wormhole connecting planets $x_{i}$ and $y_{i}$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $c\\ t$\", where $x$ is the case number (starting from $1$), $c$ is the number of planets you conquer if you follow the above strategy, and $t$ is the number of planets you threaten at the end (including the A.I.'s home planet).", "hint": "**Sample Explanation**\n\nIn the first case, you don't have to conquer anything, and you're already threatening the A.I.'s home planet.\n\nIn the third case, you can threaten the A.I.'s home planet after conquering only one planet. You end up threatening two planets, and there's an extra planet that isn't connected to anything.\n\nIn the fourth case, you can threaten the A.I.'s home planet by conquering planets $4$ and $5$. You end up threatening planets $6$, $2$, $3$ and $1$ (the A.I.'s home planet).\n\n**Limits**\n\n- $1 \\leq T \\leq 50$.\n- $0 \\leq x_{i} < y_{i} < P$.\n- Each wormhole is unique: If $i \\neq j$, then $(x_{i}, y_{i}) \\neq (x_{j}, y_{j})$.\n- There will be at least one way to reach the A.I.'s home planet from your home planet using a series of wormholes.\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $2 \\leq P \\leq 36$.\n- $1 \\leq W \\leq 630$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (22 Pts, Test set 2 - Hidden)**\n\n- $2 \\leq P \\leq 400$.\n- $1 \\leq W \\leq 2000$.\n- Time limit: ~~60~~ 6 seconds.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2011 #2] A.I. War", "background": null, "description": "你正与一个人工智能在一场关乎银河未来的致命战争中对抗。为了击败这个人工智能，你需要威胁它的 $home\\ planet$（母星）。一些行星之间通过虫洞相连；任何行星都可以通过虫洞与任意数量的其他行星相连。\n\n你一开始只拥有你的母星。每一回合，你可以征服任何你$威胁$的行星。如果你还未拥有某个行星，并且它通过虫洞与任何你已拥有的行星相连，那么你就威胁着这个行星。一旦你征服了某个行星，你就拥有了它。一旦你威胁到了人工智能的母星，你就不能再征服其他行星。\n\n在参加战术学校最重要的一天时，你发现了关于人工智能的两件事：\n\n- 每当你征服一个行星，人工智能就会变得更强大，因为它会把你视为威胁，并制造更多的战舰来防御自己。\n- 人工智能会防御你当前威胁的每一个行星。\n\n你将这两点结合起来，制定了如下策略：\n\n1. 你将不断征服行星，直到你威胁到人工智能的母星为止。\n2. 如果有多种完成第 1 步的方法，选择征服行星数量$最少$的方法。\n3. 如果有多种完成第 2 步的方法，选择最终威胁行星数量$最多$的方法。\n\n给定所有行星和虫洞的信息，按照上述策略，你在威胁到人工智能母星的过程中，会征服和威胁多少个行星？", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试用例。每组测试用例的第一行为两个用空格分隔的整数：$P$ 表示行星数，$W$ 表示虫洞数。你的母星编号为 $0$，人工智能的母星编号为 $1$。\n\n每组测试用例的第二行为 $W$ 个用空格分隔的逗号分隔整数对 $x_{i}, y_{i}$。每对表示存在一条双向虫洞连接行星 $x_{i}$ 和 $y_{i}$。", "outputFormat": "对于每组测试用例，输出一行，格式为 \"Case #$x$: $c\\ t$\"，其中 $x$ 为测试用例编号（从 $1$ 开始），$c$ 为按照上述策略你征服的行星数，$t$ 为最后你威胁的行星数（包括人工智能的母星）。", "hint": "**样例解释**\n\n在第一个样例中，你无需征服任何行星，就已经威胁到了人工智能的母星。\n\n在第三个样例中，你只需征服一个行星就能威胁到人工智能的母星。你最终威胁了两个行星，还有一个行星没有与任何行星相连。\n\n在第四个样例中，你可以通过征服行星 $4$ 和 $5$ 来威胁人工智能的母星。你最终威胁了行星 $6$、$2$、$3$ 和 $1$（人工智能的母星）。\n\n**数据范围**\n\n- $1 \\leq T \\leq 50$。\n- $0 \\leq x_{i} < y_{i} < P$。\n- 每条虫洞唯一：如果 $i \\neq j$，则 $(x_{i}, y_{i}) \\neq (x_{j}, y_{j})$。\n- 保证至少存在一条路径可以通过虫洞从你的母星到达人工智能的母星。\n\n**小数据集（10 分，测试点 1 - 可见）**\n\n- $2 \\leq P \\leq 36$。\n- $1 \\leq W \\leq 630$。\n- 时间限制：3 秒。\n\n**大数据集（22 分，测试点 2 - 隐藏）**\n\n- $2 \\leq P \\leq 400$。\n- $1 \\leq W \\leq 2000$。\n- 时间限制：6 秒。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13378", "type": "P", "difficulty": 4, "samples": [["2\n15 3 3 3\n0 6\n10 8\n15 9\n0 10\n5 11\n15 13\n8 3 4 2\n0 2\n5 4\n8 3\n0 5\n3 4\n4 7\n8 5", "Case #1:\n5.000000\n10.000000\nCase #2:\n4.290588"]], "limits": {"time": [3000, 6000], "memory": [1048576, 1048576]}, "tags": ["数学", "计算几何", "2011", "二分", "Special Judge", "Google Code Jam"], "title": "[GCJ 2011 #3] Irregular Cakes", "background": "", "description": "Mary the Mathematician has a bakery that she founded some years ago, but after all this time she has become bored with always baking the same rectangular and circular cakes. For her next birthday, she wants to bake an $irregular$ cake, which is defined as the area between two \"polylines\" between $x=0$ and $x=W$. These polylines will be called the lower boundary and the upper boundary.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/khhniam4.png)\n\nFormally, a polyline is defined by a sequence of points $(P_0, P_1, \\ldots, P_n)$ going from left to right. Consecutive points are connected to form a sequence of line segments, which together make up the polyline.\n\nToday is Mary's birthday and she has baked an irregular cake bounded by two polylines with $L$ points and $U$ points respectively. After singing \"Happy Birthday,\" she wants to make $G-1$ vertical cuts to split the cake into $G$ slices with equal area. She can then share these cake slices with all her guests. However, the irregular cake shape makes this task pretty tricky. Can you help her decide where to make the cuts?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with a line containing four integers: $W$ (the cake's width), $L$ (the number of points on the lower boundary), $U$ (the number of points on the upper boundary) and $G$ (the number of guests at the party).\n\nThis is followed by $L$ lines specifying the lower boundary. The $i$-th line contains two integers $x_i$ and $y_i$, representing the coordinates of the $i$-th point on the lower boundary. This is followed by $U$ more lines specifying the upper boundary. The $j$-th line here contains two integers $x_j$ and $y_j$, representing the coordinates of the $j$-th point on the upper boundary.\n", "outputFormat": "For each test case, output $G$ lines. The first line should be \"Case #$x$: \" where $x$ is the case number (starting from 1). The next $G-1$ lines should contain the $x$-coordinates at which cuts must be made, ordered from the leftmost cut to the rightmost cut.\n\nAnswers with a relative or absolute error of at most $10^{-6}$ will be considered correct.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq W \\leq 1000$.\n- $2 \\leq L \\leq 100$.\n- $2 \\leq U \\leq 100$.\n- All coordinates will be integers between -1000 and 1000, inclusive.\n- The x-coordinate of the leftmost point of both boundaries will be 0.\n- The x-coordinate of the rightmost point of both boundaries will be $W$.\n- Points in the same boundary will be sorted increasingly by x-coordinate.\n- Points in the same boundary will have different x-coordinates.\n- The lower boundary will always be strictly below the upper boundary for all $x$ between 0 and $W$, inclusive. (In other words, the lower boundary will have a smaller y-coordinate than the upper boundary at every $x$ position.)\n\n**Small dataset (Test set 1 - Visible)**\n\n- $2 \\leq G \\leq 3$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (Test set 2 - Hidden)**\n\n- $2 \\leq G \\leq 101$.\n- Time limit: ~~60~~ 6 seconds.", "locale": "en", "translations": {"en": {"title": "[GCJ 2011 #3] Irregular Cakes", "background": "", "description": "Mary the Mathematician has a bakery that she founded some years ago, but after all this time she has become bored with always baking the same rectangular and circular cakes. For her next birthday, she wants to bake an $irregular$ cake, which is defined as the area between two \"polylines\" between $x=0$ and $x=W$. These polylines will be called the lower boundary and the upper boundary.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/khhniam4.png)\n\nFormally, a polyline is defined by a sequence of points $(P_0, P_1, \\ldots, P_n)$ going from left to right. Consecutive points are connected to form a sequence of line segments, which together make up the polyline.\n\nToday is Mary's birthday and she has baked an irregular cake bounded by two polylines with $L$ points and $U$ points respectively. After singing \"Happy Birthday,\" she wants to make $G-1$ vertical cuts to split the cake into $G$ slices with equal area. She can then share these cake slices with all her guests. However, the irregular cake shape makes this task pretty tricky. Can you help her decide where to make the cuts?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with a line containing four integers: $W$ (the cake's width), $L$ (the number of points on the lower boundary), $U$ (the number of points on the upper boundary) and $G$ (the number of guests at the party).\n\nThis is followed by $L$ lines specifying the lower boundary. The $i$-th line contains two integers $x_i$ and $y_i$, representing the coordinates of the $i$-th point on the lower boundary. This is followed by $U$ more lines specifying the upper boundary. The $j$-th line here contains two integers $x_j$ and $y_j$, representing the coordinates of the $j$-th point on the upper boundary.\n", "outputFormat": "For each test case, output $G$ lines. The first line should be \"Case #$x$: \" where $x$ is the case number (starting from 1). The next $G-1$ lines should contain the $x$-coordinates at which cuts must be made, ordered from the leftmost cut to the rightmost cut.\n\nAnswers with a relative or absolute error of at most $10^{-6}$ will be considered correct.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq W \\leq 1000$.\n- $2 \\leq L \\leq 100$.\n- $2 \\leq U \\leq 100$.\n- All coordinates will be integers between -1000 and 1000, inclusive.\n- The x-coordinate of the leftmost point of both boundaries will be 0.\n- The x-coordinate of the rightmost point of both boundaries will be $W$.\n- Points in the same boundary will be sorted increasingly by x-coordinate.\n- Points in the same boundary will have different x-coordinates.\n- The lower boundary will always be strictly below the upper boundary for all $x$ between 0 and $W$, inclusive. (In other words, the lower boundary will have a smaller y-coordinate than the upper boundary at every $x$ position.)\n\n**Small dataset (Test set 1 - Visible)**\n\n- $2 \\leq G \\leq 3$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (Test set 2 - Hidden)**\n\n- $2 \\leq G \\leq 101$.\n- Time limit: ~~60~~ 6 seconds.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2011 #3] Irregular Cakes", "background": null, "description": "数学家 Mary 多年前创办了一家面包店，但经过这么长时间后，她已经厌倦了总是烘焙相同的矩形和圆形蛋糕。为了庆祝她的下一个生日，她想烤一个“不规则”蛋糕，这种蛋糕定义为 $x=0$ 到 $x=W$ 之间两条“折线”之间的区域。这两条折线分别称为下边界和上边界。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/khhniam4.png)\n\n形式上，一条折线由一系列从左到右的点 $(P_0, P_1, \\ldots, P_n)$ 定义。相邻的点通过线段连接，所有这些线段共同构成折线。\n\n今天是 Mary 的生日，她已经烤好了一个由两条分别有 $L$ 个点和 $U$ 个点的折线围成的不规则蛋糕。在唱完“生日快乐”后，她想要做 $G-1$ 条竖直切割，将蛋糕分成 $G$ 份面积相等的蛋糕片，这样她就可以把蛋糕分给所有的客人。然而，不规则的蛋糕形状让这项任务变得相当棘手。你能帮她决定应该在哪里切割吗？", "inputFormat": "输入的第一行给出测试用例的数量 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行包含四个整数：$W$（蛋糕的宽度）、$L$（下边界的点数）、$U$（上边界的点数）以及 $G$（参加聚会的客人数）。\n\n接下来 $L$ 行描述下边界。第 $i$ 行包含两个整数 $x_i$ 和 $y_i$，表示下边界第 $i$ 个点的坐标。再接下来 $U$ 行描述上边界。第 $j$ 行包含两个整数 $x_j$ 和 $y_j$，表示上边界第 $j$ 个点的坐标。", "outputFormat": "对于每个测试用例，输出 $G$ 行。第一行输出 “Case #$x$: ”，其中 $x$ 是测试用例编号（从 1 开始）。接下来的 $G-1$ 行，按从左到右的顺序输出每一刀的 $x$ 坐标。\n\n只要答案的相对或绝对误差不超过 $10^{-6}$，就视为正确。", "hint": "**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq W \\leq 1000$。\n- $2 \\leq L \\leq 100$。\n- $2 \\leq U \\leq 100$。\n- 所有坐标均为 $-1000$ 到 $1000$ 之间的整数。\n- 两条边界的最左端点的 $x$ 坐标均为 $0$。\n- 两条边界的最右端点的 $x$ 坐标均为 $W$。\n- 同一条边界上的点按 $x$ 坐标递增排序。\n- 同一条边界上的点的 $x$ 坐标互不相同。\n- 对于所有 $x$，下边界始终严格在上边界之下（即下边界的 $y$ 坐标始终小于上边界的 $y$ 坐标）。\n\n**小数据集（测试集 1 - 可见）**\n\n- $2 \\leq G \\leq 3$。\n- 时间限制：3 秒。\n\n**大数据集（测试集 2 - 隐藏）**\n\n- $2 \\leq G \\leq 101$。\n- 时间限制：6 秒。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13379", "type": "P", "difficulty": 4, "samples": [["4\n10 1 2 3 4 5 10 9 8 7 6\n8 101 102 103 104 105 106 103 104\n0\n5 1 2 3 4 9", "Case #1: 10\nCase #2: 4\nCase #3: 0\nCase #4: 1"]], "limits": {"time": [3000, 6000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2011", "Google Code Jam"], "title": "[GCJ 2011 #3] Dire Straights", "background": "", "description": "You are playing a card game, where each card has an integer number written on it.\n\nTo play the game, you are given some cards — your $hand$. Then you arrange the cards in your hand into $straights$. A straight is a set of cards with consecutive values; e.g. the three cards $\\{3, 4, 5\\}$, or the single card $\\{7\\}$. You then receive a number of dollars equal to the length of the shortest straight. If you have no cards, you can form no straights, so you get zero dollars.\n\nYou will be given a series of test cases, each of which describes the cards you will have in your hand. Find the maximum number of dollars you can receive for each test case.", "inputFormat": "The first line of the input contains the number of test cases, $T$. Each test case consists of one line. Each line contains $N$, the number of cards in your hand, followed by $N$ integers giving the numbers on those cards. These numbers are all space-separated.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the maximum number of dollars you can receive.", "hint": "**Sample Explanation**\n\nIn case 1, you have ten cards numbered $1$ to $10$, so you make one straight of length $10$, and get $10$ dollars.\n\nIn case 2, you could make two straights $\\{101, 102, 103, 104, 105, 106\\}$ and $\\{103, 104\\}$ and get $2$ dollars. But it would be better to make $\\{101, 102, 103, 104\\}$ and $\\{103, 104, 105, 106\\}$ and get $4$ dollars.\n\nIn case 4, the card with the number $9$ must be in a straight containing only that card. So you get $1$ dollar.\n\nIn case 3, you have zero cards, so you get zero dollars. You don't get money for nothing.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$\n- The numbers on the cards are between $1$ and $10000$.\n\n**Small dataset (4 Pts, Test set 1 - Visible)**\n\n- $0 \\leq N \\leq 10$\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (12 Pts, Test set 2 - Hidden)**\n\n- $0 \\leq N \\leq 1000$\n- Time limit: ~~60~~ 6 seconds.", "locale": "en", "translations": {"en": {"title": "[GCJ 2011 #3] Dire Straights", "background": "", "description": "You are playing a card game, where each card has an integer number written on it.\n\nTo play the game, you are given some cards — your $hand$. Then you arrange the cards in your hand into $straights$. A straight is a set of cards with consecutive values; e.g. the three cards $\\{3, 4, 5\\}$, or the single card $\\{7\\}$. You then receive a number of dollars equal to the length of the shortest straight. If you have no cards, you can form no straights, so you get zero dollars.\n\nYou will be given a series of test cases, each of which describes the cards you will have in your hand. Find the maximum number of dollars you can receive for each test case.", "inputFormat": "The first line of the input contains the number of test cases, $T$. Each test case consists of one line. Each line contains $N$, the number of cards in your hand, followed by $N$ integers giving the numbers on those cards. These numbers are all space-separated.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the maximum number of dollars you can receive.", "hint": "**Sample Explanation**\n\nIn case 1, you have ten cards numbered $1$ to $10$, so you make one straight of length $10$, and get $10$ dollars.\n\nIn case 2, you could make two straights $\\{101, 102, 103, 104, 105, 106\\}$ and $\\{103, 104\\}$ and get $2$ dollars. But it would be better to make $\\{101, 102, 103, 104\\}$ and $\\{103, 104, 105, 106\\}$ and get $4$ dollars.\n\nIn case 4, the card with the number $9$ must be in a straight containing only that card. So you get $1$ dollar.\n\nIn case 3, you have zero cards, so you get zero dollars. You don't get money for nothing.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$\n- The numbers on the cards are between $1$ and $10000$.\n\n**Small dataset (4 Pts, Test set 1 - Visible)**\n\n- $0 \\leq N \\leq 10$\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (12 Pts, Test set 2 - Hidden)**\n\n- $0 \\leq N \\leq 1000$\n- Time limit: ~~60~~ 6 seconds.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2011 #3] Dire Straights", "background": null, "description": "你正在玩一款纸牌游戏，每张牌上都写有一个整数。\n\n在游戏中，你会得到一些牌——你的手牌。然后你需要将手牌中的牌分组成“顺子”。顺子是一组牌，这组牌上的数字是连续的；例如三张牌 $\\{3, 4, 5\\}$，或者单独一张牌 $\\{7\\}$。你获得的奖金等于最短顺子的长度。如果你没有任何牌，则无法组成顺子，因此你获得 $0$ 元。\n\n你将会得到若干组测试数据，每组数据描述了你手中的牌。请你计算每组测试数据中你最多能获得多少奖金。", "inputFormat": "输入的第一行包含测试数据组数 $T$。每组测试数据占一行。每行包含一个整数 $N$，表示你手中的牌数，接下来有 $N$ 个整数，表示这些牌上的数字。所有数字以空格分隔。", "outputFormat": "对于每组测试数据，输出一行，格式为 \"Case #$x$: $y$\"，其中 $x$ 为测试数据编号（从 $1$ 开始），$y$ 为你能获得的最大奖金。", "hint": "**样例解释**\n\n第 1 组，你有 $1$ 到 $10$ 共 $10$ 张牌，可以组成一个长度为 $10$ 的顺子，获得 $10$ 元。\n\n第 2 组，你可以组成两个顺子 $\\{101, 102, 103, 104, 105, 106\\}$ 和 $\\{103, 104\\}$，获得 $2$ 元。但更优的做法是组成 $\\{101, 102, 103, 104\\}$ 和 $\\{103, 104, 105, 106\\}$，获得 $4$ 元。\n\n第 4 组，数字为 $9$ 的牌只能单独成顺子，因此只能获得 $1$ 元。\n\n第 3 组，你没有任何牌，因此获得 $0$ 元。你不能无中生有获得奖金。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$\n- 牌上的数字范围为 $1$ 到 $10000$\n\n**小数据范围（4 分，测试点 1 - 可见）**\n\n- $0 \\leq N \\leq 10$\n- 时间限制：3 秒\n\n**大数据范围（12 分，测试点 2 - 隐藏）**\n\n- $0 \\leq N \\leq 1000$\n- 时间限制：6 秒\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13380", "type": "P", "difficulty": 5, "samples": [["3\n3 3\n|-/\n|||\n--|\n3 4\n----\n||||\n\\\\//\n4 4\n|---\n\\-\\|\n\\|||\n|--\\", "Case #1: 2\nCase #2: 0\nCase #3: 16"]], "limits": {"time": [3000, 6000], "memory": [1048576, 1048576]}, "tags": ["图论", "2011", "二分图", "组合数学", "Google Code Jam"], "title": "[GCJ 2011 #3] Perpetual Motion", "background": "", "description": "Have you ever been to the Google Lemming Factory? It is a very unusual place. The floor is arranged into an $R \\times C$ grid. Within each grid square, there is a conveyor belt oriented up-down, left-right, or along one of the two diagonals. The conveyor belts move either forwards or backwards along their orientations, and you can independently choose which of the two possible directions each conveyor belt should move in.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/h69uk07b.png)\n\nCurrently, there is a single lemming standing at the center of each square. When you start the conveyor belts, each lemming will move in the direction of the conveyor belt he is on until he reaches the center of a new square. All these movements happen simultaneously and take exactly one second to complete. Afterwards, the lemmings will all be on new squares, and the process will repeat from their new positions. This continues forever, or at least until you turn off the conveyor belts.\n\n- When a lemming enters a new square, he continues going in the direction he was already going until he reaches the center of that square. He will not be affected by the new conveyor belt until the next second starts.\n- If a lemming moves off the edge of the grid, he comes back at the same position on the opposite side. For example, if he were to move diagonally up and left from the top-left square, he would arrive at the bottom-right square. By the miracle of science, this whole process still only takes 1 second.\n- Lemmings never collide and can always move past each other without difficulty.\n\nThe trick is to choose directions for each conveyor belt so that the lemmings will keep moving forever without ever having two of them end up in the center of the same square at the same time. If that happened, they would be stuck together from then on, and that is not as fun for them.\n\nHere are two ways of assigning directions to each conveyor belt from the earlier example:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8e7eapk7.png)\n\nIn both cases, we avoid ever sending two lemmings to the center of the same square at the same time.\n\nGiven an arbitrary floor layout, calculate $N$, the number of ways to choose directions for each conveyor belt so that no two lemmings will ever end up in the center of the same square at the same time. The answer might be quite large, so please output it modulo $1000003$.", "inputFormat": "The first line of input gives the number of test cases, $T$. $T$ test cases follow. Each begins with a line containing positive integers $R$ and $C$.\n\nThis is followed by $R$ lines, each containing a string of $C$ characters chosen from \"|-/\\\\\". Each character represents the orientation of the conveyor belt in a single square:\n\n* '|' represents a conveyor belt that can move up or down.\n* '-' represents a conveyor belt that can move left or right.\n* '/' represents a conveyor belt that can move up-right or down-left.\n* '\\\\' represents a conveyor belt that can move up-left or down-right.", "outputFormat": "For each test case, output one line containing \"Case #$x$: $M$\", where $x$ is the case number (starting from 1), and $M$ is the remainder when dividing $N$ by $1000003$.", "hint": "**Limits**\n\n- $ 1 \\leq T \\leq 25. $\n\n**Small dataset (5 Pts, Test set 1 - Visible)**\n\n- $ 3 \\leq R \\leq 4. $\n- $ 3 \\leq C \\leq 4. $\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (21 Pts, Test set 2 - Hidden)**\n\n- $ 3 \\leq R \\leq 100. $\n- $ 3 \\leq C \\leq 100. $\n- Time limit: ~~60~~ 6 seconds.", "locale": "en", "translations": {"en": {"title": "[GCJ 2011 #3] Perpetual Motion", "background": "", "description": "Have you ever been to the Google Lemming Factory? It is a very unusual place. The floor is arranged into an $R \\times C$ grid. Within each grid square, there is a conveyor belt oriented up-down, left-right, or along one of the two diagonals. The conveyor belts move either forwards or backwards along their orientations, and you can independently choose which of the two possible directions each conveyor belt should move in.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/h69uk07b.png)\n\nCurrently, there is a single lemming standing at the center of each square. When you start the conveyor belts, each lemming will move in the direction of the conveyor belt he is on until he reaches the center of a new square. All these movements happen simultaneously and take exactly one second to complete. Afterwards, the lemmings will all be on new squares, and the process will repeat from their new positions. This continues forever, or at least until you turn off the conveyor belts.\n\n- When a lemming enters a new square, he continues going in the direction he was already going until he reaches the center of that square. He will not be affected by the new conveyor belt until the next second starts.\n- If a lemming moves off the edge of the grid, he comes back at the same position on the opposite side. For example, if he were to move diagonally up and left from the top-left square, he would arrive at the bottom-right square. By the miracle of science, this whole process still only takes 1 second.\n- Lemmings never collide and can always move past each other without difficulty.\n\nThe trick is to choose directions for each conveyor belt so that the lemmings will keep moving forever without ever having two of them end up in the center of the same square at the same time. If that happened, they would be stuck together from then on, and that is not as fun for them.\n\nHere are two ways of assigning directions to each conveyor belt from the earlier example:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8e7eapk7.png)\n\nIn both cases, we avoid ever sending two lemmings to the center of the same square at the same time.\n\nGiven an arbitrary floor layout, calculate $N$, the number of ways to choose directions for each conveyor belt so that no two lemmings will ever end up in the center of the same square at the same time. The answer might be quite large, so please output it modulo $1000003$.", "inputFormat": "The first line of input gives the number of test cases, $T$. $T$ test cases follow. Each begins with a line containing positive integers $R$ and $C$.\n\nThis is followed by $R$ lines, each containing a string of $C$ characters chosen from \"|-/\\\\\". Each character represents the orientation of the conveyor belt in a single square:\n\n* '|' represents a conveyor belt that can move up or down.\n* '-' represents a conveyor belt that can move left or right.\n* '/' represents a conveyor belt that can move up-right or down-left.\n* '\\\\' represents a conveyor belt that can move up-left or down-right.", "outputFormat": "For each test case, output one line containing \"Case #$x$: $M$\", where $x$ is the case number (starting from 1), and $M$ is the remainder when dividing $N$ by $1000003$.", "hint": "**Limits**\n\n- $ 1 \\leq T \\leq 25. $\n\n**Small dataset (5 Pts, Test set 1 - Visible)**\n\n- $ 3 \\leq R \\leq 4. $\n- $ 3 \\leq C \\leq 4. $\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (21 Pts, Test set 2 - Hidden)**\n\n- $ 3 \\leq R \\leq 100. $\n- $ 3 \\leq C \\leq 100. $\n- Time limit: ~~60~~ 6 seconds.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2011 #3] Perpetual Motion", "background": null, "description": "你去过 Google Lemming 工厂吗？那是一个非常特别的地方。地板被划分成 $R \\times C$ 的网格。在每个网格单元内，都有一条传送带，方向可能是上下、左右，或者沿着两条对角线之一。每条传送带可以沿其方向前进或后退，你可以独立地为每条传送带选择这两种可能的移动方向之一。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/h69uk07b.png)\n\n现在，每个格子的中心都有一只旅鼠。当你启动传送带时，每只旅鼠会按照所在传送带的方向移动，直到到达新格子的中心。所有旅鼠会同时移动，这一过程恰好耗时 1 秒。之后，所有旅鼠都到达了新的格子中心，接下来会从新位置重复这一过程。这个过程会一直持续下去，除非你关闭传送带。\n\n- 当一只旅鼠进入一个新格子时，它会继续沿原来的方向前进，直到到达该格子的中心。在下一秒开始前，它不会受到新传送带的影响。\n- 如果一只旅鼠从网格边缘移动出去，它会从对面相同的位置回到网格。例如，如果它从左上角格子沿对角线向上左移动，它会到达右下角格子。科学的奇迹让这一切依然只需 1 秒完成。\n- 旅鼠们永远不会相撞，也总能顺利穿过彼此。\n\n关键在于为每条传送带选择方向，使得旅鼠们能够永远移动下去，且不会有两只旅鼠在同一时刻到达同一个格子中心。如果发生这种情况，它们就会粘在一起，从此无法分开，这对它们来说可不有趣。\n\n下面是之前示例中为每条传送带分配方向的两种方式：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8e7eapk7.png)\n\n在这两种情况下，都避免了两只旅鼠同时到达同一个格子中心。\n\n给定任意的地板布局，请计算 $N$，即为每条传送带选择方向，使得不会有两只旅鼠同时到达同一个格子中心的方案数。由于答案可能很大，请输出 $N$ 对 $1000003$ 取模的结果。", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行为两个正整数 $R$ 和 $C$。\n\n接下来有 $R$ 行，每行包含一个长度为 $C$ 的字符串，字符串中的每个字符为 \"|-/\\\\\" 之一，表示该格子的传送带方向：\n\n- '|' 表示传送带可以向上或向下移动。\n- '-' 表示传送带可以向左或向右移动。\n- '/' 表示传送带可以向右上或左下移动。\n- '\\\\' 表示传送带可以向左上或右下移动。", "outputFormat": "对于每组测试数据，输出一行，格式为 \"Case #$x$: $M$\"，其中 $x$ 为测试编号（从 1 开始），$M$ 为 $N$ 对 $1000003$ 取模的结果。", "hint": "**数据范围**\n\n- $1 \\leq T \\leq 25$。\n\n**小数据集（5 分，测试点 1 - 可见）**\n\n- $3 \\leq R \\leq 4$。\n- $3 \\leq C \\leq 4$。\n- 时间限制：3 秒。\n\n**大数据集（21 分，测试点 2 - 隐藏）**\n\n- $3 \\leq R \\leq 100$。\n- $3 \\leq C \\leq 100$。\n- 时间限制：6 秒。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13381", "type": "P", "difficulty": 6, "samples": [["3\n1???\n1\n10??110??00??1000??", "Case #1: 1001\nCase #2: 1\nCase #3: 1011110110000100001"]], "limits": {"time": [6000, 20000], "memory": [1048576, 1048576]}, "tags": ["数学", "2011", "数论", "Google Code Jam"], "title": "[GCJ 2011 #3] Mystery Square", "background": "", "description": "I have written down a large perfect square in binary, and then replaced some of the digits with question marks. Can you figure out what my original number was?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow, one per line. Each line contains $S$: a perfect square written in binary, but with some of the digits replaced by question marks.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $N$\", where $x$ is the case number (starting from 1) and $N$ is a perfect square written in binary, obtained by replacing each '?' character in $S$ with either a '0' character or a '1' character.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 25$.\n- $S$ begins with '1'.\n- $S$ contains only the characters '0', '1', and '?'.\n- In every test case, there is exactly one possible choice for $N$.\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $S$ is at most $60$ characters long.\n- $S$ contains at most $20$ '?' characters.\n- Time limit: ~~30~~ 6 seconds.\n\n**Large dataset (31 Pts, Test set 2 - Hidden)**\n\n- $S$ is at most $125$ characters long.\n- $S$ contains at most $40$ '?' characters.\n- Time limit: ~~60~~ 20 seconds.", "locale": "en", "translations": {"en": {"title": "[GCJ 2011 #3] Mystery Square", "background": "", "description": "I have written down a large perfect square in binary, and then replaced some of the digits with question marks. Can you figure out what my original number was?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow, one per line. Each line contains $S$: a perfect square written in binary, but with some of the digits replaced by question marks.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $N$\", where $x$ is the case number (starting from 1) and $N$ is a perfect square written in binary, obtained by replacing each '?' character in $S$ with either a '0' character or a '1' character.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 25$.\n- $S$ begins with '1'.\n- $S$ contains only the characters '0', '1', and '?'.\n- In every test case, there is exactly one possible choice for $N$.\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $S$ is at most $60$ characters long.\n- $S$ contains at most $20$ '?' characters.\n- Time limit: ~~30~~ 6 seconds.\n\n**Large dataset (31 Pts, Test set 2 - Hidden)**\n\n- $S$ is at most $125$ characters long.\n- $S$ contains at most $40$ '?' characters.\n- Time limit: ~~60~~ 20 seconds.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2011 #3] Mystery Square", "background": null, "description": "我写下了一个很大的完全平方数的二进制表示，然后把其中一些数字替换成了问号。你能找出我原来的数字是什么吗？", "inputFormat": "输入的第一行是测试用例的数量 $T$。接下来的 $T$ 行，每行包含一个字符串 $S$，表示一个完全平方数的二进制表示，但其中一些数字被问号替换了。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #$x$: $N$\"，其中 $x$ 是测试用例编号（从 1 开始），$N$ 是将 $S$ 中每个 '?' 替换为 '0' 或 '1' 后得到的完全平方数的二进制表示。", "hint": "**限制条件**\n\n- $1 \\leq T \\leq 25$。\n- $S$ 以 '1' 开头。\n- $S$ 只包含字符 '0'、'1' 和 '?'。\n- 每个测试用例都恰好有一种可能的 $N$。\n\n**小数据集（10 分，测试集 1 - 可见）**\n\n- $S$ 最多 $60$ 个字符。\n- $S$ 中最多有 $20$ 个 '?' 字符。\n- 时间限制：6 秒。\n\n**大数据集（31 分，测试集 2 - 隐藏）**\n\n- $S$ 最多 $125$ 个字符。\n- $S$ 中最多有 $40$ 个 '?' 字符。\n- 时间限制：20 秒。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13382", "type": "P", "difficulty": 5, "samples": [["2\naabcd\nbookkeeper", "Case #1: 24\nCase #2: 7200"]], "limits": {"time": [3000, 6000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2011", "组合数学", "Google Code Jam"], "title": "[GCJ 2011 Finals] Runs", "background": "", "description": "I have a string $S$ consisting of lower-case alphabetic characters, 'a' - 'z'. Each maximal sequence of contiguous characters that are the same is called a \"run\". For example, \"bookkeeper\" has 7 runs. How many different permutations of $S$ have exactly the same number of runs as $S$?\n\nTwo permutations $a$ and $b$ are considered different if there exists some index $i$ at which they have a different character: $a[i] \\neq b[i]$.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each contains a single non-empty string of lower-case alphabetic characters, $S$, the string of interest.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the number of different permutations of $S$ that have exactly the same number of runs as $S$, modulo $1000003$.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $S$ is at least $1$ character long.\n\n**Small dataset (Test set 1 - Visible)**\n\n- $S$ is at most $100$ characters long.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (Test set 2 - Hidden)**\n\n- $S$ is at most $450000$ characters long.\n- $S$ has at most $100$ runs.\n- The input file will not exceed $1$ megabyte in size.\n- Time limit: ~~60~~ 6 seconds.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2011 Finals] Runs", "background": "", "description": "I have a string $S$ consisting of lower-case alphabetic characters, 'a' - 'z'. Each maximal sequence of contiguous characters that are the same is called a \"run\". For example, \"bookkeeper\" has 7 runs. How many different permutations of $S$ have exactly the same number of runs as $S$?\n\nTwo permutations $a$ and $b$ are considered different if there exists some index $i$ at which they have a different character: $a[i] \\neq b[i]$.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each contains a single non-empty string of lower-case alphabetic characters, $S$, the string of interest.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the number of different permutations of $S$ that have exactly the same number of runs as $S$, modulo $1000003$.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $S$ is at least $1$ character long.\n\n**Small dataset (Test set 1 - Visible)**\n\n- $S$ is at most $100$ characters long.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (Test set 2 - Hidden)**\n\n- $S$ is at most $450000$ characters long.\n- $S$ has at most $100$ runs.\n- The input file will not exceed $1$ megabyte in size.\n- Time limit: ~~60~~ 6 seconds.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2011 Finals] Runs", "background": null, "description": "给定一个只包含小写字母 $a$ 到 $z$ 的字符串 $S$。每一段连续且相同的字符序列被称为一个“段”（run）。例如，字符串 \"bookkeeper\" 有 7 个段。请问有多少种不同的 $S$ 的排列方式，恰好拥有与 $S$ 相同数量的段？\n\n如果存在某个下标 $i$，使得排列 $a$ 和排列 $b$ 在该位置的字符不同（即 $a[i] \\neq b[i]$），则认为这两个排列是不同的。", "inputFormat": "第一行输入一个整数 $T$，表示测试用例的数量。接下来的 $T$ 行，每行包含一个非空的小写字母字符串 $S$，即待处理的字符串。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #$x$: $y$\"，其中 $x$ 表示测试用例编号（从 1 开始），$y$ 表示恰好有与 $S$ 相同数量段的不同排列数，对 $1000003$ 取模。", "hint": "**限制条件**\n\n- $1 \\leq T \\leq 100$。\n- $S$ 至少包含 $1$ 个字符。\n\n**小数据范围（测试集 1 - 可见）**\n\n- $S$ 最多包含 $100$ 个字符。\n- 时间限制：3 秒。\n\n**大数据范围（测试集 2 - 隐藏）**\n\n- $S$ 最多包含 $450000$ 个字符。\n- $S$ 最多包含 $100$ 个段。\n- 输入文件大小不超过 1 MB。\n- 时间限制：6 秒。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13383", "type": "P", "difficulty": 6, "samples": [["2\n3 6 5\n5 9 9 9 9 9\n0 8 9 0 2 5\n3 9 9 9 9 9\n3 6 3\n3 8 10 11 10 8\n7 5 2 12 8 8\n6 9 11 9 8 4", "Case #1: 3\nCase #2: 5"]], "limits": {"time": [3000, 6000], "memory": [1048576, 1048576]}, "tags": ["模拟", "2011", "最短路", "均摊分析", "Google Code Jam"], "title": "[GCJ 2011 Finals] Rains Over Atlantis", "background": "", "description": "Rains fall on the isle of Atlantis, and will erode all the land to nothingness. What you want to know, so that you can organize the evacuation, is how soon it will happen.\n\nYou have a map of Atlantis. The map is a square grid, and each square contains the height of the land in that square, in metres, above sea level. All squares outside the map have height 0; all squares with height 0 are water, and all squares with larger heights are land. There are no squares with lower height.\n\nWater can flow from a source square to a target square if the source square and target square share an edge, and if the height of the water in the target square is lower than or equal to the height of water in the source square.\n\nIt's raining very quickly, which means that if there is nowhere for the rain water in a square to flow, water in that square will accumulate until there is a square to which the rain water can flow. Squares that are not on the map can accept any amount of flow. For example, the following map:\n\n```\n5 9 9 9 9 9\n0 8 9 0 2 5\n3 9 9 9 9 9\n```\n\nWill quickly fill up with water. We'll call the height of water in each square, plus the height of the land, the water level. It will be:\n\n```\n5 9 9 9 9 9\n0 8 9 5 5 5\n3 9 9 9 9 9\n```\n\nNote that the 0 in the middle of the land, although it's water, is not connected to the outside of the map and so just accumulates water. The 0 on the border of the land, however, is connected to the outside of the map, and so the water from the 8 can flow through it to the outside.\n\nThe direction in which water flows is determined by the water level. If there are multiple possible squares where water could flow from one particular source square, the water from that source will flow to the square with the lowest water level (ties don't matter, as you will see).\n\nNow the erosion begins. Each day, a square is eroded—its height decreases—depending on how water is flowing from it. If water is flowing from $S$ to $T$, then $S$'s height decreases by $\\min(\\text{WaterLevel}(S) - \\text{WaterLevel}(T), M)$. All erosion happens at exactly the same time, at the end of the day. For example, with $M=5$, the map above will erode to:\n```\n0 4 4 4 4 4\n0 3 5 0 2 0\n0 4 4 4 4 4\n```\nAfter a day's erosion, excess water will flow away: squares with water level higher than a neighbour's water level will lose water until they are of the same height. Water will also accumulate in the same way that it did on the first day. After the first day, this map's water level will become:\n```\n0 4 4 4 4 4\n0 3 5 2 2 0\n0 4 4 4 4 4\n```\nAfter another day of erosion, the map will look like:\n```\n0 0 0 0 0 0\n0 0 2 0 0 0\n0 0 0 0 0 0\n```\n...and the Atlanteans will need to escape in a big hurry. Your task is to determine how many days it will take for all the heights to erode to $0$.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with a line containing three space-separated integers: $H$, $W$ and $M$. The first two denote the size of the map, while the third is the maximum amount a square can erode in one day, as described above. $H$ lines follow, each of which contains $W$ space-separated integers. The $i^{th}$ integer on the $j^{th}$ line denotes the height of the square at $(i, j)$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the number of days it takes to erode all the island.", "hint": "In the second case, the water height looks like:\n```\n3 8 10 11 10 8\n7 7 7 12 8 8\n6 9 11 9 8 4\n```\n\nAfter one day the island looks as follows:\n```\n0 5 7 8 7 5\n4 5 2 9 8 5\n3 6 8 6 5 1\n```\n\nAnd after the second day:\n```\n0 2 4 5 4 2\n1 4 2 6 5 2\n0 3 5 3 2 0\n```\n\nAnd the third day:\n```\n0 0 1 2 1 0\n0 1 2 3 2 0\n0 0 2 0 0 0\n```\n\nAfter the fourth day, things are looking desperate for the Atlanteans:\n```\n0 0 0 0 0 0\n0 0 1 0 0 0\n0 0 0 0 0 0\n```\n\nFinally, on the fifth day the last square erodes away. Atlantis lasted for five days; they probably shouldn't have built their city out of brown sugar.\n\n**Limits**\n\n- $1 \\leq T \\leq 40$.\n\n**Small dataset (7 Pts, Test set 1 - Visible)**\n\n- $1 \\leq H, W \\leq 10$.\n- $1 \\leq M \\leq 100$.\n- $0 \\leq \\text{all heights} \\leq 100$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (23 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq H, W \\leq 20$.\n- $1 \\leq M \\leq 10^{15}$.\n- $0 \\leq \\text{all heights} \\leq 10^{15}$.\n- Time limit: ~~60~~ 6 seconds.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2011 Finals] Rains Over Atlantis", "background": "", "description": "Rains fall on the isle of Atlantis, and will erode all the land to nothingness. What you want to know, so that you can organize the evacuation, is how soon it will happen.\n\nYou have a map of Atlantis. The map is a square grid, and each square contains the height of the land in that square, in metres, above sea level. All squares outside the map have height 0; all squares with height 0 are water, and all squares with larger heights are land. There are no squares with lower height.\n\nWater can flow from a source square to a target square if the source square and target square share an edge, and if the height of the water in the target square is lower than or equal to the height of water in the source square.\n\nIt's raining very quickly, which means that if there is nowhere for the rain water in a square to flow, water in that square will accumulate until there is a square to which the rain water can flow. Squares that are not on the map can accept any amount of flow. For example, the following map:\n\n```\n5 9 9 9 9 9\n0 8 9 0 2 5\n3 9 9 9 9 9\n```\n\nWill quickly fill up with water. We'll call the height of water in each square, plus the height of the land, the water level. It will be:\n\n```\n5 9 9 9 9 9\n0 8 9 5 5 5\n3 9 9 9 9 9\n```\n\nNote that the 0 in the middle of the land, although it's water, is not connected to the outside of the map and so just accumulates water. The 0 on the border of the land, however, is connected to the outside of the map, and so the water from the 8 can flow through it to the outside.\n\nThe direction in which water flows is determined by the water level. If there are multiple possible squares where water could flow from one particular source square, the water from that source will flow to the square with the lowest water level (ties don't matter, as you will see).\n\nNow the erosion begins. Each day, a square is eroded—its height decreases—depending on how water is flowing from it. If water is flowing from $S$ to $T$, then $S$'s height decreases by $\\min(\\text{WaterLevel}(S) - \\text{WaterLevel}(T), M)$. All erosion happens at exactly the same time, at the end of the day. For example, with $M=5$, the map above will erode to:\n```\n0 4 4 4 4 4\n0 3 5 0 2 0\n0 4 4 4 4 4\n```\nAfter a day's erosion, excess water will flow away: squares with water level higher than a neighbour's water level will lose water until they are of the same height. Water will also accumulate in the same way that it did on the first day. After the first day, this map's water level will become:\n```\n0 4 4 4 4 4\n0 3 5 2 2 0\n0 4 4 4 4 4\n```\nAfter another day of erosion, the map will look like:\n```\n0 0 0 0 0 0\n0 0 2 0 0 0\n0 0 0 0 0 0\n```\n...and the Atlanteans will need to escape in a big hurry. Your task is to determine how many days it will take for all the heights to erode to $0$.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with a line containing three space-separated integers: $H$, $W$ and $M$. The first two denote the size of the map, while the third is the maximum amount a square can erode in one day, as described above. $H$ lines follow, each of which contains $W$ space-separated integers. The $i^{th}$ integer on the $j^{th}$ line denotes the height of the square at $(i, j)$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the number of days it takes to erode all the island.", "hint": "In the second case, the water height looks like:\n```\n3 8 10 11 10 8\n7 7 7 12 8 8\n6 9 11 9 8 4\n```\n\nAfter one day the island looks as follows:\n```\n0 5 7 8 7 5\n4 5 2 9 8 5\n3 6 8 6 5 1\n```\n\nAnd after the second day:\n```\n0 2 4 5 4 2\n1 4 2 6 5 2\n0 3 5 3 2 0\n```\n\nAnd the third day:\n```\n0 0 1 2 1 0\n0 1 2 3 2 0\n0 0 2 0 0 0\n```\n\nAfter the fourth day, things are looking desperate for the Atlanteans:\n```\n0 0 0 0 0 0\n0 0 1 0 0 0\n0 0 0 0 0 0\n```\n\nFinally, on the fifth day the last square erodes away. Atlantis lasted for five days; they probably shouldn't have built their city out of brown sugar.\n\n**Limits**\n\n- $1 \\leq T \\leq 40$.\n\n**Small dataset (7 Pts, Test set 1 - Visible)**\n\n- $1 \\leq H, W \\leq 10$.\n- $1 \\leq M \\leq 100$.\n- $0 \\leq \\text{all heights} \\leq 100$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (23 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq H, W \\leq 20$.\n- $1 \\leq M \\leq 10^{15}$.\n- $0 \\leq \\text{all heights} \\leq 10^{15}$.\n- Time limit: ~~60~~ 6 seconds.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2011 Finals] Rains Over Atlantis", "background": null, "description": "亚特兰蒂斯岛上正下着大雨，雨水将会把所有的陆地侵蚀殆尽。为了组织撤离，你需要知道这一切将在多久之后发生。\n\n你有一张亚特兰蒂斯的地图。地图是一个正方形网格，每个格子包含该格子高于海平面的高度（单位为米）。地图外的所有格子的高度都为 $0$；所有高度为 $0$ 的格子为水域，高度大于 $0$ 的格子为陆地。不存在高度小于 $0$ 的格子。\n\n水可以从一个源格子流向一个目标格子，当且仅当这两个格子有公共边，并且目标格子的水位高度小于等于源格子的水位高度。\n\n由于降雨非常迅速，如果某个格子的雨水无法流向其它地方，则该格子的水会不断积累，直到有地方可以流出。地图外的格子可以接受任意量的水流。例如，下面这张地图：\n\n```\n5 9 9 9 9 9\n0 8 9 0 2 5\n3 9 9 9 9 9\n```\n\n会很快被水填满。我们将每个格子的水位高度定义为该格子的地面高度加上水的高度。最终水位如下：\n\n```\n5 9 9 9 9 9\n0 8 9 5 5 5\n3 9 9 9 9 9\n```\n\n注意，中间的 $0$ 虽然是水域，但它与地图外部不连通，因此水会在此处积累。而边界上的 $0$ 与地图外部相连，因此 $8$ 处的水可以通过它流向外部。\n\n水的流动方向由水位高度决定。如果某个源格子有多个可能的目标格子可流向，则水会流向水位最低的那个格子（如果有多个最低的格子，选择哪个都无所谓）。\n\n接下来开始侵蚀。每天，每个格子的高度会根据水的流动情况减少。如果水从 $S$ 流向 $T$，则 $S$ 的高度减少 $\\min(\\text{WaterLevel}(S) - \\text{WaterLevel}(T), M)$。所有侵蚀在一天结束时同时发生。例如，若 $M=5$，上述地图经过一天侵蚀后变为：\n\n```\n0 4 4 4 4 4\n0 3 5 0 2 0\n0 4 4 4 4 4\n```\n\n一天侵蚀后，多余的水会流走：水位高于相邻格子的格子会失去水，直到水位与相邻格子相同。水也会像第一天那样继续积累。一天后，该地图的水位变为：\n\n```\n0 4 4 4 4 4\n0 3 5 2 2 0\n0 4 4 4 4 4\n```\n\n再经过一天侵蚀，地图变为：\n\n```\n0 0 0 0 0 0\n0 0 2 0 0 0\n0 0 0 0 0 0\n```\n\n……亚特兰蒂斯人需要赶紧逃离了。你的任务是计算所有格子的高度全部被侵蚀到 $0$ 需要多少天。", "inputFormat": "输入的第一行是测试用例数 $T$。接下来有 $T$ 个测试用例。每个测试用例第一行为三个用空格分隔的整数：$H$、$W$ 和 $M$。前两个数表示地图的尺寸，第三个数表示每个格子一天最多被侵蚀的高度。接下来有 $H$ 行，每行包含 $W$ 个用空格分隔的整数，第 $j$ 行第 $i$ 个整数表示 $(i, j)$ 位置的格子的高度。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #$x$: $y$\"，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是岛屿全部被侵蚀为 $0$ 所需的天数。", "hint": "在第二个样例中，水位如下：\n\n```\n3 8 10 11 10 8\n7 7 7 12 8 8\n6 9 11 9 8 4\n```\n\n一天后，岛屿变为：\n\n```\n0 5 7 8 7 5\n4 5 2 9 8 5\n3 6 8 6 5 1\n```\n\n再过一天：\n\n```\n0 2 4 5 4 2\n1 4 2 6 5 2\n0 3 5 3 2 0\n```\n\n第三天：\n\n```\n0 0 1 2 1 0\n0 1 2 3 2 0\n0 0 2 0 0 0\n```\n\n第四天后，亚特兰蒂斯岌岌可危：\n\n```\n0 0 0 0 0 0\n0 0 1 0 0 0\n0 0 0 0 0 0\n```\n\n第五天最后一个格子被侵蚀殆尽。亚特兰蒂斯坚持了五天；他们大概不该用红糖建城。\n\n**数据范围**\n\n- $1 \\leq T \\leq 40$。\n\n**小数据集（7 分，测试点 1 - 可见）**\n\n- $1 \\leq H, W \\leq 10$。\n- $1 \\leq M \\leq 100$。\n- $0 \\leq \\text{所有高度} \\leq 100$。\n- 时间限制：~~30~~ 3 秒。\n\n**大数据集（23 分，测试点 2 - 隐藏）**\n\n- $1 \\leq H, W \\leq 20$。\n- $1 \\leq M \\leq 10^{15}$。\n- $0 \\leq \\text{所有高度} \\leq 10^{15}$。\n- 时间限制：~~60~~ 6 秒。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13384", "type": "P", "difficulty": 7, "samples": [["3\n0\n4\n0", "Case #1: 1\n0 0 -> R\nCase #2: 5\n0 0 -> E 1 1\n1 0 -> E 2 1\n2 0 -> E 3 1\n3 0 -> E -1 1\n-1 0 -> R\nCase #3: 3\n0 0 -> E 1 1\n0 1 -> R\n1 0 -> W 0 1"]], "limits": {"time": [30000, 60000], "memory": [1048576, 1048576]}, "tags": ["2011", "Special Judge", "构造", "Google Code Jam"], "title": "[GCJ 2011 Finals] Program within a Program", "background": "", "description": "You have a robot on an infinite east-west highway, and it has a cake to deliver. Every mile along the highway, in both directions, there is a lamppost. You want to program the robot to move exactly N lampposts to the east, and release the cake there. The route does not have to be direct, as long as the robot eventually releases the cake in the right place.\n\nUnfortunately, the robot comes equipped with only very little memory, and it is capable of no advanced logic. To control the robot you will have to give it a very simple program at the start that will get it to release the cake at the proper location. This program must be composed of one or more statements, each of which tells the robot what to do under certain conditions. These statements must be in the following format:\n\n```\n<S> <M> -> <action>\n```\n\nwhich means that if all of the following conditions are met:\n\n1. The robot is in state $s$.\n2. The robot is at a lightpost marked with number $M$.\n\nthen it will perform exactly one of the following actions:\n\n1. Mark the current post with a new number, change state and move. To do this `<action>` must be formatted as \"`<D> <NS> <NM>`\", where `D` is the direction to move (use 'W' for west and 'E' for east), `NS` is the robot's new state and `NM` is the new mark for the current lightpost.\n2. Release the cake at the current position and self-destruct. To do this `<action>`\n\nIf you output two or more statements with the same values of $s$ and $M$, the robot will misbehave and destroy the cake.\n\nIf at any time the robot is in a state $X$ at a lamppost marked with $Y$ such that there is no statement with $s=X$ and $M=Y$, then the robot will get confused and eat the cake.\n\nAll states and marks must be integers with absolute value no greater than one million ($10^6$). Assume that initially the robot is in state zero and all lampposts are marked with zero.\n\nGiven $N$, write a program so the robot releases the cake in the appropriate place. Your program must use at most $30$ statements, and it must terminate within $X$ steps.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case consists of a single line containing an integer $N$, which indicates the lamppost where the robot must release the cake.\n", "outputFormat": "For each test case, first output \"Case #$x$: $y$\", where $x$ is the number of the test case (starting with 1) and $y$ is the number of statements you will use. Next output $y$ lines, each of which represents a statement for the robot in the format described previously.\n\nWARNING: Judge's response might take up to 5 seconds longer than usual to appear, because your output is run as part of the validation.", "hint": "**Sample Explanation**\n\nIn the first case, the robot is initially in state zero, and there is a zero on the lamppost. So it executes its only statement, which is to release the cake.\n\nIn the second case, the robot has five states: $0$, $1$, $2$, $3$, and $-1$. The robot performs the following actions:\n\n* Mark the current lamppost with a $1$, move east, and go to state $1$.\n* Mark the current lamppost with a $1$, move east, and go to state $2$.\n* Mark the current lamppost with a $1$, move east, and go to state $3$.\n* Mark the current lamppost with a $1$, move east, and go to state $-1$.\n* Release the cake.\n\nIn the third case, the robot has two states, and performs the following actions:\n\n* Mark the current lamppost with a $1$, move east, and go to state $1$.\n* Mark the current lamppost with a $1$, move west, and go to state $0$.\n* Release the cake.\n\nNote that the robot takes different actions at the two times it is in state $0$, because it sees a different mark each time.\n\n**Limits**\n\n- $1 \\leq T \\leq 15$.\n\n**Small dataset (15 Pts, Test set 1 - Visible)**\n\n- $0 \\leq N \\leq 500$.\n- $X = 250,000 (2.5 \\times 10^5)$.\n- Time limit: 30 seconds.\n\n**Large dataset (23 Pts, Test set 2 - Hidden)**\n\n- $0 \\leq N \\leq 5000$.\n- $X = 150,000 (1.5 \\times 10^5)$\n- Time limit: 60 seconds.", "locale": "en", "translations": {"en": {"title": "[GCJ 2011 Finals] Program within a Program", "background": "", "description": "You have a robot on an infinite east-west highway, and it has a cake to deliver. Every mile along the highway, in both directions, there is a lamppost. You want to program the robot to move exactly N lampposts to the east, and release the cake there. The route does not have to be direct, as long as the robot eventually releases the cake in the right place.\n\nUnfortunately, the robot comes equipped with only very little memory, and it is capable of no advanced logic. To control the robot you will have to give it a very simple program at the start that will get it to release the cake at the proper location. This program must be composed of one or more statements, each of which tells the robot what to do under certain conditions. These statements must be in the following format:\n\n```\n<S> <M> -> <action>\n```\n\nwhich means that if all of the following conditions are met:\n\n1. The robot is in state $s$.\n2. The robot is at a lightpost marked with number $M$.\n\nthen it will perform exactly one of the following actions:\n\n1. Mark the current post with a new number, change state and move. To do this `<action>` must be formatted as \"`<D> <NS> <NM>`\", where `D` is the direction to move (use 'W' for west and 'E' for east), `NS` is the robot's new state and `NM` is the new mark for the current lightpost.\n2. Release the cake at the current position and self-destruct. To do this `<action>`\n\nIf you output two or more statements with the same values of $s$ and $M$, the robot will misbehave and destroy the cake.\n\nIf at any time the robot is in a state $X$ at a lamppost marked with $Y$ such that there is no statement with $s=X$ and $M=Y$, then the robot will get confused and eat the cake.\n\nAll states and marks must be integers with absolute value no greater than one million ($10^6$). Assume that initially the robot is in state zero and all lampposts are marked with zero.\n\nGiven $N$, write a program so the robot releases the cake in the appropriate place. Your program must use at most $30$ statements, and it must terminate within $X$ steps.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case consists of a single line containing an integer $N$, which indicates the lamppost where the robot must release the cake.\n", "outputFormat": "For each test case, first output \"Case #$x$: $y$\", where $x$ is the number of the test case (starting with 1) and $y$ is the number of statements you will use. Next output $y$ lines, each of which represents a statement for the robot in the format described previously.\n\nWARNING: Judge's response might take up to 5 seconds longer than usual to appear, because your output is run as part of the validation.", "hint": "**Sample Explanation**\n\nIn the first case, the robot is initially in state zero, and there is a zero on the lamppost. So it executes its only statement, which is to release the cake.\n\nIn the second case, the robot has five states: $0$, $1$, $2$, $3$, and $-1$. The robot performs the following actions:\n\n* Mark the current lamppost with a $1$, move east, and go to state $1$.\n* Mark the current lamppost with a $1$, move east, and go to state $2$.\n* Mark the current lamppost with a $1$, move east, and go to state $3$.\n* Mark the current lamppost with a $1$, move east, and go to state $-1$.\n* Release the cake.\n\nIn the third case, the robot has two states, and performs the following actions:\n\n* Mark the current lamppost with a $1$, move east, and go to state $1$.\n* Mark the current lamppost with a $1$, move west, and go to state $0$.\n* Release the cake.\n\nNote that the robot takes different actions at the two times it is in state $0$, because it sees a different mark each time.\n\n**Limits**\n\n- $1 \\leq T \\leq 15$.\n\n**Small dataset (15 Pts, Test set 1 - Visible)**\n\n- $0 \\leq N \\leq 500$.\n- $X = 250,000 (2.5 \\times 10^5)$.\n- Time limit: 30 seconds.\n\n**Large dataset (23 Pts, Test set 2 - Hidden)**\n\n- $0 \\leq N \\leq 5000$.\n- $X = 150,000 (1.5 \\times 10^5)$\n- Time limit: 60 seconds.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2011 Finals] Program within a Program", "background": "不保证本题的 Special Judge 一定正确。", "description": "你有一个机器人，位于一条无限延伸的东西向公路上，并且它需要递送一个蛋糕。公路上每隔一英里（无论东西方向）就有一根路灯柱。你需要编程让机器人恰好向东移动 $N$ 根路灯柱，并在那里释放蛋糕。路线不必直线，只要最终机器人能在正确的位置释放蛋糕即可。\n\n不幸的是，这个机器人只有极少的内存，并且无法进行复杂的逻辑运算。你只能在开始时给它一个非常简单的程序，这个程序必须能让它在正确的位置释放蛋糕。该程序由一条或多条语句组成，每条语句都指示机器人在特定条件下该做什么。语句格式如下：\n\n```\n<S> <M> -> <action>\n```\n\n这表示当且仅当以下所有条件满足时：\n\n1. 机器人处于状态 $s$。\n2. 机器人当前所在的路灯柱标记为 $M$。\n\n它将执行以下动作之一：\n\n1. 给当前路灯柱打上新标记，改变状态并移动。此时 `<action>` 格式为 \"`<D> <NS> <NM>`\"，其中 `D` 表示移动方向（'W' 表示向西，'E' 表示向东），`NS` 表示机器人的新状态，`NM` 表示当前路灯柱的新标记。\n2. 在当前位置释放蛋糕并自毁。此时 `<action>` 只需写 `release`。\n\n如果你输出了两条或更多具有相同 $s$ 和 $M$ 的语句，机器人会出错并摧毁蛋糕。\n\n如果机器人在某时刻处于状态 $X$，且站在标记为 $Y$ 的路灯柱上，但没有语句满足 $s=X$ 且 $M=Y$，那么机器人会困惑并吃掉蛋糕。\n\n所有状态和标记都必须是绝对值不超过一百万（$10^6$）的整数。假设机器人初始状态为 $0$，所有路灯柱初始标记为 $0$。\n\n给定 $N$，请编写一个程序，使机器人能在正确的位置释放蛋糕。你的程序最多只能使用 $30$ 条语句，并且必须在 $X$ 步内终止。", "inputFormat": "输入的第一行是测试用例数 $T$。接下来有 $T$ 个测试用例，每个测试用例占一行，包含一个整数 $N$，表示机器人需要释放蛋糕的路灯柱编号。", "outputFormat": "对于每个测试用例，首先输出一行 \"Case #$x$: $y$\"，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是你使用的语句条数。接下来输出 $y$ 行，每行是一条机器人程序语句，格式如上所述。\n\n警告：评测机的响应可能比平时慢最多 5 秒，因为你的输出会作为验证的一部分运行。", "hint": "**样例解释**\n\n在第一个样例中，机器人初始状态为 $0$，路灯柱标记为 $0$。它执行唯一的语句，即释放蛋糕。\n\n在第二个样例中，机器人有五种状态：$0$、$1$、$2$、$3$ 和 $-1$。机器人按如下方式行动：\n\n- 将当前路灯柱标记为 $1$，向东移动，进入状态 $1$。\n- 将当前路灯柱标记为 $1$，向东移动，进入状态 $2$。\n- 将当前路灯柱标记为 $1$，向东移动，进入状态 $3$。\n- 将当前路灯柱标记为 $1$，向东移动，进入状态 $-1$。\n- 释放蛋糕。\n\n在第三个样例中，机器人有两种状态，执行如下操作：\n\n- 将当前路灯柱标记为 $1$，向东移动，进入状态 $1$。\n- 将当前路灯柱标记为 $1$，向西移动，进入状态 $0$。\n- 释放蛋糕。\n\n注意，机器人两次处于状态 $0$ 时采取了不同的动作，因为它看到的标记不同。\n\n**数据范围**\n\n- $1 \\leq T \\leq 15$。\n\n**小数据集（15 分，测试点 1 - 可见）**\n\n- $0 \\leq N \\leq 500$。\n- $X = 250,000$。\n- 时间限制：30 秒。\n\n**大数据集（23 分，测试点 2 - 隐藏）**\n\n- $0 \\leq N \\leq 5000$。\n- $X = 150,000$。\n- 时间限制：60 秒。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13385", "type": "P", "difficulty": 7, "samples": [["3\n3\n2 1 3\n1\n1\n3\n3 2 1", "Case #1: 2 3 1\nCase #2: 1\nCase #3: 1 3 2"]], "limits": {"time": [3000, 6000], "memory": [1048576, 1048576]}, "tags": ["贪心", "博弈论", "2011", "Google Code Jam"], "title": "[GCJ 2011 Finals] Ace in the Hole", "background": "", "description": "Amy has a deck of $N$ cards with values $1$ through $N$. She arranges the deck so that the values of the cards have no decreasing subsequence of length $3$. For example, $1, 5, 4, 6, 3, 2$ would be an illegal ordering because $5, 3, 2$ is decreasing.\n\nAmy now gives the deck of cards to Ben. Ben knows that the deck has no decreasing subsequence of length $3$, but he does not know the exact ordering. He wants to find the card with value $1$. He does this by choosing an arbitrary card, picking it up to observe its value, and then repeating until he has found the card with value $1$. At each step, Ben chooses a card that will minimize the worst-case number of cards he has to examine.\n\nBen later tells you that he got unlucky and had to examine all $N$ cards before finding the card with value $1$. Given the order in which he examined the cards of the deck, what value did each card have? If there are multiple possibilities, choose the lexicographically greatest one.\n\nA deck $A$ is lexicographically greater than a deck $B$ if and only if, at the first index at which they differ, the card in $A$ has a value greater than the value of the card in $B$.\n\nExample: $N = 3$, and Ben tried the cards in order $2, 1, 3$ (the indices are 1-based). The values of the cards must have been: $2, 3, 1$.\n\nExplanation: If card #2 had value $1$, then Ben would have stopped immediately. If card #2 had value $2$, then Ben would have known the first card must have been the $1$, because the ordering $(3, 2, 1)$ is a decreasing subsequence of length $3$, and thus could not have been the ordering. In either case, Ben would not have needed $3$ guesses. Therefore, we can deduce card #2 have had value $3$. Similarly, card #1 could not have had value $1$, or Ben could have stopped early. Therefore, the card values must have been $2, 3, 1$.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with a line containing one integer $N$, the number of cards in the deck. The next line will contain $N$ integers separated by single spaces, describing the order in which Ben examined the deck: the first integer denotes the 1-based position of the first card he examined, the second integer denotes the 1-based position of the second card he examined, and so on.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from $1$) and $y$ is the sequence of cards' values, separated by spaces.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$\n- For the provided sequence of guesses, there will be at least one deck that meets all the constraints of the problem, including the constraint that Ben's strategy required him to look at $N$ cards.\n\n**Small dataset (20 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 8$\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (22 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq N \\leq 300$\n- Time limit: ~~60~~ 6 seconds.", "locale": "en", "translations": {"en": {"title": "[GCJ 2011 Finals] Ace in the Hole", "background": "", "description": "Amy has a deck of $N$ cards with values $1$ through $N$. She arranges the deck so that the values of the cards have no decreasing subsequence of length $3$. For example, $1, 5, 4, 6, 3, 2$ would be an illegal ordering because $5, 3, 2$ is decreasing.\n\nAmy now gives the deck of cards to Ben. Ben knows that the deck has no decreasing subsequence of length $3$, but he does not know the exact ordering. He wants to find the card with value $1$. He does this by choosing an arbitrary card, picking it up to observe its value, and then repeating until he has found the card with value $1$. At each step, Ben chooses a card that will minimize the worst-case number of cards he has to examine.\n\nBen later tells you that he got unlucky and had to examine all $N$ cards before finding the card with value $1$. Given the order in which he examined the cards of the deck, what value did each card have? If there are multiple possibilities, choose the lexicographically greatest one.\n\nA deck $A$ is lexicographically greater than a deck $B$ if and only if, at the first index at which they differ, the card in $A$ has a value greater than the value of the card in $B$.\n\nExample: $N = 3$, and Ben tried the cards in order $2, 1, 3$ (the indices are 1-based). The values of the cards must have been: $2, 3, 1$.\n\nExplanation: If card #2 had value $1$, then Ben would have stopped immediately. If card #2 had value $2$, then Ben would have known the first card must have been the $1$, because the ordering $(3, 2, 1)$ is a decreasing subsequence of length $3$, and thus could not have been the ordering. In either case, Ben would not have needed $3$ guesses. Therefore, we can deduce card #2 have had value $3$. Similarly, card #1 could not have had value $1$, or Ben could have stopped early. Therefore, the card values must have been $2, 3, 1$.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with a line containing one integer $N$, the number of cards in the deck. The next line will contain $N$ integers separated by single spaces, describing the order in which Ben examined the deck: the first integer denotes the 1-based position of the first card he examined, the second integer denotes the 1-based position of the second card he examined, and so on.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from $1$) and $y$ is the sequence of cards' values, separated by spaces.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$\n- For the provided sequence of guesses, there will be at least one deck that meets all the constraints of the problem, including the constraint that Ben's strategy required him to look at $N$ cards.\n\n**Small dataset (20 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 8$\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (22 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq N \\leq 300$\n- Time limit: ~~60~~ 6 seconds.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2011 Finals] Ace in the Hole", "background": null, "description": "Amy 有一副包含 $N$ 张牌的牌堆，牌面数值为 $1$ 到 $N$。她将牌堆排列，使得任意长度为 $3$ 的递减子序列都不存在。例如，$1, 5, 4, 6, 3, 2$ 是非法排列，因为 $5, 3, 2$ 构成了长度为 $3$ 的递减子序列。\n\nAmy 把这副牌交给了 Ben。Ben 知道这副牌没有长度为 $3$ 的递减子序列，但他不知道具体的排列顺序。他想找到数值为 $1$ 的那张牌。他的方法是每次任意选择一张牌，翻开查看其数值，然后重复此过程，直到找到数值为 $1$ 的牌。每一步，Ben 都会选择能使他在最坏情况下需要查看的牌数最少的那张牌。\n\n后来 Ben 告诉你，他运气很差，在找到数值为 $1$ 的牌之前，不得不把 $N$ 张牌全部都看了一遍。给定 Ben 检查牌的顺序，请你推断每张牌的数值分别是多少。如果有多种可能，请输出字典序最大的那一种。\n\n如果牌堆 $A$ 在第一个不同的位置上牌面数值大于牌堆 $B$，则称 $A$ 的字典序大于 $B$。\n\n例如：$N = 3$，Ben 检查牌的顺序为 $2, 1, 3$（下标从 $1$ 开始）。那么牌的数值排列应为：$2, 3, 1$。\n\n解释：如果第 $2$ 张牌是 $1$，Ben 会立刻停止。如果第 $2$ 张牌是 $2$，Ben 会知道第 $1$ 张牌一定是 $1$，因为排列 $(3, 2, 1)$ 存在长度为 $3$ 的递减子序列，因此不可能。因此，第 $2$ 张牌只能是 $3$。同理，第 $1$ 张牌也不能是 $1$，否则 Ben 会提前停止。因此，牌面数值应为 $2, 3, 1$。", "inputFormat": "第一行输入一个整数 $T$，表示测试用例的数量。接下来有 $T$ 组测试数据。每组测试数据第一行包含一个整数 $N$，表示牌的数量。第二行包含 $N$ 个用空格分隔的整数，表示 Ben 检查牌的顺序：第一个整数表示他首先检查的牌的位置（下标从 $1$ 开始），第二个整数表示他第二次检查的牌的位置，依此类推。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #$x$: $y$\"，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是牌面数值的排列，用空格分隔。", "hint": "**数据范围**\n\n- $1 \\leq T \\leq 100$\n- 对于给定的 Ben 的检查顺序，至少存在一种满足所有条件（包括 Ben 必须检查 $N$ 张牌）的牌堆排列。\n\n**小数据（20 分，测试点 1 - 可见）**\n\n- $1 \\leq N \\leq 8$\n- 时间限制：3 秒。\n\n**大数据（22 分，测试点 2 - 隐藏）**\n\n- $1 \\leq N \\leq 300$\n- 时间限制：6 秒。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13386", "type": "P", "difficulty": 7, "samples": [["4\n1 1 3\n3 6 12\n4 20 15\n13 6 20", "Case #1: 0.333333333 1\nCase #2: 0.500000000 3\nCase #3: 0.755555555 3\nCase #4: 0.730769231 6"]], "limits": {"time": [6000, 12000], "memory": [1048576, 1048576]}, "tags": ["2011", "Special Judge", "概率论", "期望", "Google Code Jam"], "title": "[GCJ 2011 Finals] Google Royale", "background": "", "description": "While visiting the planet Theta VIII, your team of space explorers is forced to participate in the plot of a badly-written book, which takes place in a hotel/casino called the Google Royale. In order to escape the Royale, you will have to make enough money from gambling that you can buy the hotel for $V$ dollars and leave.\n\nYou start with $A$ dollars, and you will participate in betting rounds until one of two conditions is met. If you finish any betting round with $\\leq 0$ dollars, you will lose; if you finish a betting round with $\\geq V$ dollars, you will buy the hotel and leave. Otherwise you'll keep starting new betting rounds.\n\nEach betting round consists of one or more coin flips. If you have $X$ dollars at the start of the round, you can choose any integer $B$ between $1$ and $\\min(X, M)$ to bet on the first coin flip.\n\nWith probability $50\\%$, you win the coin flip, and the Royale immediately pays you $B$ dollars. You now have $X + B$ dollars, and the betting round ends.\n\nWith probability $50\\%$, you lose the coin flip and owe the Royale $B$ dollars. You can now pay the $B$ dollars you owe and end the round. Or if $2B \\leq M$, you can instead delay the payment and do a second coin flip with twice the bet: $2B$ dollars. If you lose again, then you owe the Royale $B + 2B = 3B$ dollars. You can continue doubling your bet in this way to $4B$, $8B$, etc., until either you win a coin flip, you choose to stop, or your next bet would exceed $M$. You can even continue if the total of all your bets in the current betting round exceeds $X$.\n\nOnce the round is over, you must pay the Royale for each coin flip you lost, and if you won a coin flip, the Royale pays you for that. For example, if you start with a bet of $1$ dollar, lose three coin flips, and then win one, you would gain $8 - 4 - 2 - 1 = 1$ dollar. If you lose three coin flips and then stopped, you would lose $4 + 2 + 1 = 7$ dollars. If you are left with $0$ or less after paying, then you are broke, and you have just lost the game.\n\nLuckily you have brought an android with you, and he is able to compute the probability that you will win if you follow an optimal strategy. What is that probability, and what is the largest possible first bet you could make to have that probability? Remember that you are not allowed to bet more than $M$!\n\n### Example\n\nSuppose that you decide to use the following (sub-optimal) strategy. You have $A=5$ dollars; $M=20$ and $V=40$. The following sequence of events is possible:\n\n*   Round 1: You can start by betting $1$, $2$, $3$, $4$ or $5$ dollars. You decide to begin a betting round by betting $2$ dollars.\n    *   Step 1 ($B=2$): You win the first coin flip. You gain $2$ dollars, and the betting round ends. Now you have $7$ dollars.\n*   Round 2: You begin a betting round by betting $5$ dollars.\n    *   Step 1 ($B=5$): You lose the first coin flip. Now you owe the Royale $5$ dollars. Since $5\\times 2 \\leq 20$, you may do another coin flip with a bet of $5\\times 2=10$ dollars. You choose not to. You lose $5$ dollars, and the betting round ends. Now you have $2$ dollars.\n*   Round 3: You begin a betting round by betting $2$ dollars.\n    *   Step 1 ($B=2$): You lose. Now you owe the Royale $2$ dollars. You choose to flip another coin with a bet of $4$ dollars.\n    *   Step 2 ($B=4$): You lose. Now you owe the Royale a total of $6$ dollars. That's more than you have, which is okay. You choose to flip another coin with a bet of $8$ dollars.\n    *   Step 3 ($B=8$): You win. You gain $8$ dollars, pay the $2+4=6$ dollars you owe, and the betting round ends. Now you have $4$ dollars.\n*   Round 4: You begin a betting round by betting $2$ dollars.\n    *   Step 1 ($B=2$): You lose. Now you owe the Royale $2$ dollars. You choose to flip another coin with a bet of $4$ dollars.\n    *   Step 2 ($B=4$): You lose. Now you owe the Royale a total of $6$ dollars. You choose to flip another coin with a bet of $8$ dollars.\n    *   Step 3 ($B=8$): You lose. Now you owe the Royale a total of $14$ dollars. You choose to flip another coin with a bet of $16$ dollars.\n    *   Step 4 ($B=16$): You lose. Now you owe the Royale a total of $30$ dollars. Since $2\\times 16>M$, you cannot flip another coin and you must pay what you owe. Now you have $-26$ dollars; you have lost.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each line contains three integers separated by single spaces: $A$, $M$ and $V$, in that order.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$ $z$\", where $x$ is the case number (starting from $1$); $y$ is the probability of winning if you follow an optimal strategy; and $z$ is the maximum first bet you can make without reducing your probability of winning. $y$ must be correct to within an absolute or relative error of $10^{-6}$.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n\n**Small dataset (20 Pts, Test set 1 - Visible)**\n\n- $1 \\leq M \\leq 20$.\n- $1 \\leq A < V \\leq 20$.\n- Time limit: ~~30~~ 6 seconds.\n\n**Large dataset (40 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq M \\leq 10^{16}$.\n- $1 \\leq A < V \\leq 10^{16}$.\n- Time limit: ~~60~~ 12 seconds.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2011 Finals] Google Royale", "background": "", "description": "While visiting the planet Theta VIII, your team of space explorers is forced to participate in the plot of a badly-written book, which takes place in a hotel/casino called the Google Royale. In order to escape the Royale, you will have to make enough money from gambling that you can buy the hotel for $V$ dollars and leave.\n\nYou start with $A$ dollars, and you will participate in betting rounds until one of two conditions is met. If you finish any betting round with $\\leq 0$ dollars, you will lose; if you finish a betting round with $\\geq V$ dollars, you will buy the hotel and leave. Otherwise you'll keep starting new betting rounds.\n\nEach betting round consists of one or more coin flips. If you have $X$ dollars at the start of the round, you can choose any integer $B$ between $1$ and $\\min(X, M)$ to bet on the first coin flip.\n\nWith probability $50\\%$, you win the coin flip, and the Royale immediately pays you $B$ dollars. You now have $X + B$ dollars, and the betting round ends.\n\nWith probability $50\\%$, you lose the coin flip and owe the Royale $B$ dollars. You can now pay the $B$ dollars you owe and end the round. Or if $2B \\leq M$, you can instead delay the payment and do a second coin flip with twice the bet: $2B$ dollars. If you lose again, then you owe the Royale $B + 2B = 3B$ dollars. You can continue doubling your bet in this way to $4B$, $8B$, etc., until either you win a coin flip, you choose to stop, or your next bet would exceed $M$. You can even continue if the total of all your bets in the current betting round exceeds $X$.\n\nOnce the round is over, you must pay the Royale for each coin flip you lost, and if you won a coin flip, the Royale pays you for that. For example, if you start with a bet of $1$ dollar, lose three coin flips, and then win one, you would gain $8 - 4 - 2 - 1 = 1$ dollar. If you lose three coin flips and then stopped, you would lose $4 + 2 + 1 = 7$ dollars. If you are left with $0$ or less after paying, then you are broke, and you have just lost the game.\n\nLuckily you have brought an android with you, and he is able to compute the probability that you will win if you follow an optimal strategy. What is that probability, and what is the largest possible first bet you could make to have that probability? Remember that you are not allowed to bet more than $M$!\n\n### Example\n\nSuppose that you decide to use the following (sub-optimal) strategy. You have $A=5$ dollars; $M=20$ and $V=40$. The following sequence of events is possible:\n\n*   Round 1: You can start by betting $1$, $2$, $3$, $4$ or $5$ dollars. You decide to begin a betting round by betting $2$ dollars.\n    *   Step 1 ($B=2$): You win the first coin flip. You gain $2$ dollars, and the betting round ends. Now you have $7$ dollars.\n*   Round 2: You begin a betting round by betting $5$ dollars.\n    *   Step 1 ($B=5$): You lose the first coin flip. Now you owe the Royale $5$ dollars. Since $5\\times 2 \\leq 20$, you may do another coin flip with a bet of $5\\times 2=10$ dollars. You choose not to. You lose $5$ dollars, and the betting round ends. Now you have $2$ dollars.\n*   Round 3: You begin a betting round by betting $2$ dollars.\n    *   Step 1 ($B=2$): You lose. Now you owe the Royale $2$ dollars. You choose to flip another coin with a bet of $4$ dollars.\n    *   Step 2 ($B=4$): You lose. Now you owe the Royale a total of $6$ dollars. That's more than you have, which is okay. You choose to flip another coin with a bet of $8$ dollars.\n    *   Step 3 ($B=8$): You win. You gain $8$ dollars, pay the $2+4=6$ dollars you owe, and the betting round ends. Now you have $4$ dollars.\n*   Round 4: You begin a betting round by betting $2$ dollars.\n    *   Step 1 ($B=2$): You lose. Now you owe the Royale $2$ dollars. You choose to flip another coin with a bet of $4$ dollars.\n    *   Step 2 ($B=4$): You lose. Now you owe the Royale a total of $6$ dollars. You choose to flip another coin with a bet of $8$ dollars.\n    *   Step 3 ($B=8$): You lose. Now you owe the Royale a total of $14$ dollars. You choose to flip another coin with a bet of $16$ dollars.\n    *   Step 4 ($B=16$): You lose. Now you owe the Royale a total of $30$ dollars. Since $2\\times 16>M$, you cannot flip another coin and you must pay what you owe. Now you have $-26$ dollars; you have lost.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each line contains three integers separated by single spaces: $A$, $M$ and $V$, in that order.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$ $z$\", where $x$ is the case number (starting from $1$); $y$ is the probability of winning if you follow an optimal strategy; and $z$ is the maximum first bet you can make without reducing your probability of winning. $y$ must be correct to within an absolute or relative error of $10^{-6}$.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n\n**Small dataset (20 Pts, Test set 1 - Visible)**\n\n- $1 \\leq M \\leq 20$.\n- $1 \\leq A < V \\leq 20$.\n- Time limit: ~~30~~ 6 seconds.\n\n**Large dataset (40 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq M \\leq 10^{16}$.\n- $1 \\leq A < V \\leq 10^{16}$.\n- Time limit: ~~60~~ 12 seconds.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2011 Finals] Google Royale", "background": null, "description": "在访问 Theta VIII 星球时，你们的太空探险队被迫卷入了一本写得很烂的小说情节中，故事发生在一家名为 Google Royale 的游戏厅。为了逃离 Royale，你必须通过游戏赚到足够的钱，以 $V$ 美元买下这家酒店并离开。\n\n你起始拥有 $A$ 美元，并将参与一轮又一轮的游戏，直到满足以下两个条件之一。如果你在任何一轮游戏结束后剩余的钱 $\\leq 0$，你就输了；如果你在某一轮结束后拥有的钱 $\\geq V$，你就可以买下酒店并离开。否则，你将继续开始新的一轮游戏。\n\n每一轮游戏由一次或多次抛硬币组成。如果你在本轮开始时有 $X$ 美元，你可以选择在第一次抛硬币时下注任意整数 $B$，其中 $1 \\leq B \\leq \\min(X, M)$。\n\n以 $50\\%$ 的概率，你赢得这次抛硬币，Royale 立即支付你 $B$ 美元。此时你拥有 $X+B$ 美元，本轮结束。\n\n以 $50\\%$ 的概率，你输掉这次抛硬币，欠 Royale $B$ 美元。你可以选择支付这 $B$ 美元并结束本轮。或者，如果 $2B \\leq M$，你也可以选择暂缓支付，继续以 $2B$ 美元进行第二次抛硬币。如果你再次输掉，那么你欠 Royale $B+2B=3B$ 美元。你可以继续以此方式将下注翻倍为 $4B$、$8B$ 等，直到你赢得一次抛硬币、选择停止，或下一次下注将超过 $M$。即使本轮累计下注总额超过你当前拥有的钱 $X$，你也可以继续。\n\n本轮结束后，你必须向 Royale 支付所有输掉抛硬币的下注金额，如果你赢了一次抛硬币，Royale 会支付你那次的金额。例如，如果你以 $1$ 美元开始下注，连续输掉三次抛硬币后第四次赢了，你将获得 $8-4-2-1=1$ 美元。如果你连续输掉三次后选择停止，你将损失 $4+2+1=7$ 美元。如果你支付后剩余的钱 $\\leq 0$，你就破产了，输掉了游戏。\n\n幸运的是，你带来了一个机器人助手，他能够计算出如果你采取最优策略，获胜的概率是多少。请你计算这个概率，以及在不降低获胜概率的前提下，你可以选择的最大初始下注金额。注意，你的下注金额不能超过 $M$！", "inputFormat": "第一行输入一个整数 $T$，表示测试用例的数量。接下来的 $T$ 行，每行包含三个用空格分隔的整数：$A$、$M$ 和 $V$，含义如上所述。", "outputFormat": "对于每个测试用例，输出一行，格式为 “Case #$x$: $y$ $z$”，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是在采取最优策略时获胜的概率，$z$ 是在不降低获胜概率的前提下你可以选择的最大初始下注金额。$y$ 需要保证绝对误差或相对误差不超过 $10^{-6}$。", "hint": "**数据范围**\n\n- $1 \\leq T \\leq 100$。\n\n**小数据集（20 分，测试点 1 - 可见）**\n\n- $1 \\leq M \\leq 20$。\n- $1 \\leq A < V \\leq 20$。\n- 时间限制：6 秒。\n\n**大数据集（40 分，测试点 2 - 隐藏）**\n\n- $1 \\leq M \\leq 10^{16}$。\n- $1 \\leq A < V \\leq 10^{16}$。\n- 时间限制：12 秒。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13387", "type": "P", "difficulty": 2, "samples": [["4\n1 0\n1 1\n4 0\n4 47", "Case #1: OFF\nCase #2: ON\nCase #3: OFF\nCase #4: ON"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["数学", "2010", "位运算", "Google Code Jam"], "title": "[GCJ 2010 Qualification] Snapper Chain", "background": "", "description": "The Snapper is a clever little device that, on one side, plugs its input plug into an output socket, and, on the other side, exposes an output socket for plugging in a light or other device.\n\nWhen a Snapper is in the ON state and is receiving power from its input plug, then the device connected to its output socket is receiving power as well. When you snap your fingers -- making a clicking sound -- any Snapper receiving power at the time of the snap toggles between the ON and OFF states.\n\nIn hopes of destroying the universe by means of a singularity, I have purchased $N$ Snapper devices and chained them together by plugging the first one into a power socket, the second one into the first one, and so on. The light is plugged into the $N$th Snapper.\n\nInitially, all the Snappers are in the OFF state, so only the first one is receiving power from the socket, and the light is off. I snap my fingers once, which toggles the first Snapper into the ON state and gives power to the second one. I snap my fingers again, which toggles both Snappers and then promptly cuts power off from the second one, leaving it in the ON state, but with no power. I snap my fingers the third time, which toggles the first Snapper again and gives power to the second one. Now both Snappers are in the ON state, and if my light is plugged into the second Snapper it will be on.\n\nI keep doing this for hours. Will the light be on or off after I have snapped my fingers $K$ times? The light is on if and only if it's receiving power from the Snapper it's plugged into.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each one contains two integers, $N$ and $K$.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $x$ is the case number (starting from 1) and $y$ is either \"ON\" or \"OFF\", indicating the state of the light bulb.", "hint": "**Limits**\n\n- $1 \\leqslant T \\leqslant 10,000$.\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $1 \\leqslant N \\leqslant 10$; \n- $0 \\leqslant K \\leqslant 100$;\n\n**Large dataset (23 Pts, Test set 2 - Hidden)**\n\n- $1 \\leqslant N \\leqslant 30$;\n- $0 \\leqslant K \\leqslant 10^{8}$;", "locale": "en", "translations": {"en": {"title": "[GCJ 2010 Qualification] Snapper Chain", "background": "", "description": "The Snapper is a clever little device that, on one side, plugs its input plug into an output socket, and, on the other side, exposes an output socket for plugging in a light or other device.\n\nWhen a Snapper is in the ON state and is receiving power from its input plug, then the device connected to its output socket is receiving power as well. When you snap your fingers -- making a clicking sound -- any Snapper receiving power at the time of the snap toggles between the ON and OFF states.\n\nIn hopes of destroying the universe by means of a singularity, I have purchased $N$ Snapper devices and chained them together by plugging the first one into a power socket, the second one into the first one, and so on. The light is plugged into the $N$th Snapper.\n\nInitially, all the Snappers are in the OFF state, so only the first one is receiving power from the socket, and the light is off. I snap my fingers once, which toggles the first Snapper into the ON state and gives power to the second one. I snap my fingers again, which toggles both Snappers and then promptly cuts power off from the second one, leaving it in the ON state, but with no power. I snap my fingers the third time, which toggles the first Snapper again and gives power to the second one. Now both Snappers are in the ON state, and if my light is plugged into the second Snapper it will be on.\n\nI keep doing this for hours. Will the light be on or off after I have snapped my fingers $K$ times? The light is on if and only if it's receiving power from the Snapper it's plugged into.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each one contains two integers, $N$ and $K$.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $x$ is the case number (starting from 1) and $y$ is either \"ON\" or \"OFF\", indicating the state of the light bulb.", "hint": "**Limits**\n\n- $1 \\leqslant T \\leqslant 10,000$.\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $1 \\leqslant N \\leqslant 10$; \n- $0 \\leqslant K \\leqslant 100$;\n\n**Large dataset (23 Pts, Test set 2 - Hidden)**\n\n- $1 \\leqslant N \\leqslant 30$;\n- $0 \\leqslant K \\leqslant 10^{8}$;", "locale": "en"}, "zh-CN": {"title": "[GCJ 2010 Qualification] Snapper Chain", "background": null, "description": "Snapper 是一种巧妙的小装置，一端将其输入插头插入输出插座，另一端则暴露一个输出插座，可以插入灯泡或其他设备。\n\n当 Snapper 处于 ON 状态且其输入插头正在接收电源时，连接到其输出插座的设备也会获得电源。当你打响指——发出咔哒声时，任何正在接收电源的 Snapper 都会在 ON 和 OFF 状态之间切换。\n\n为了通过奇点摧毁宇宙，我购买了 $N$ 个 Snapper，并将它们串联起来，第一个插入电源插座，第二个插入第一个，依此类推。灯泡插在第 $N$ 个 Snapper 上。\n\n最初，所有 Snapper 都处于 OFF 状态，因此只有第一个 Snapper 从插座接收电源，灯泡是熄灭的。我打响指一次，第一个 Snapper 切换到 ON 状态，并为第二个 Snapper 供电。我再次打响指，两个 Snapper 都切换状态，随后第二个 Snapper 断电，保持在 ON 状态但没有电源。我第三次打响指，第一个 Snapper 再次切换状态，并为第二个 Snapper 供电。现在两个 Snapper 都处于 ON 状态，如果我的灯泡插在第二个 Snapper 上，它就会亮。\n\n我这样持续打响指数小时。打响指 $K$ 次后，灯泡是亮着还是灭着？只有当灯泡从其插入的 Snapper 获得电源时才会亮。", "inputFormat": "输入的第一行包含测试用例数 $T$。接下来的 $T$ 行，每行包含两个整数 $N$ 和 $K$。", "outputFormat": "对于每个测试用例，输出一行，格式为 “Case #x: y”，其中 $x$ 是测试用例编号（从 1 开始），$y$ 为 \"ON\" 或 \"OFF\"，表示灯泡的状态。", "hint": "**数据范围**\n\n- $1 \\leqslant T \\leqslant 10\\,000$。\n\n**小数据集（10 分，测试集 1 - 可见）**\n\n- $1 \\leqslant N \\leqslant 10$；\n- $0 \\leqslant K \\leqslant 100$；\n\n**大数据集（23 分，测试集 2 - 隐藏）**\n\n- $1 \\leqslant N \\leqslant 30$；\n- $0 \\leqslant K \\leqslant 10^{8}$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13388", "type": "P", "difficulty": 4, "samples": [["3\n3 26000000 11000000 6000000\n3 1 10 11\n2 800000000000000000001 900000000000000000001", "Case #1: 4000000\nCase #2: 0\nCase #3: 99999999999999999999"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["数学", "高精度", "2010", "数论", "Google Code Jam"], "title": "[GCJ 2010 Qualification] Fair Warning", "background": "Fortunately for the peoples of the Jamcode system, \"the apocalypse\" turned out to be a mistranslation of \"the giant party.\" Nobody from Jamcode IX bothered to pass this along, because they were having so much fun.", "description": "On our planet, Jamcode IX, three Great Events occurred. They happened $26000$, $11000$ and $6000$ slarboseconds ago. In $4000$ slarboseconds, the amount of time since all of those events will be multiples of $5000$ slarboseconds, the largest possible amount... and the apocalypse will come.\n\nLuckily for you, you live on Jamcode X! The apocalypse came on Jamcode IX less than a year ago. But Jamcode X has a worrying prophecy: \"After the moment of reckoning, on the first optimum anniversary of the N Great Events, the apocalypse will come. 64 bits will not save you. You have been warned.\"\n\nThe people of Jamcode X are very concerned by this prophecy. All of the Great Events have already happened, and their times have been measured to the nearest slarbosecond; but nobody knows when their optimum anniversary will occur. After studying the diary of a scientist from Jamcode IX, scientists working on the problem have come up with a theory:\n\nThe moment of reckoning is now, the moment you solve this problem. At some time $y \\geqslant 0$ slarboseconds from now, the number of slarboseconds since each of the Great Events will be divisible by some maximum number $T$. If you can find the smallest value of $y$ that gives this largest possible $T$, that will give you the optimum anniversary when the apocalypse will come.\n\nOn Jamcode IX, for example, there were 3 Great Events and they happened $26000$, $11000$ and $6000$ slarboseconds before the moment of reckoning. $4000$ slarboseconds later, the amount of time since each event was a multiple of $T=5000$ slarboseconds, and the apocalypse came.\n\nYour job is to compute the amount of time until the apocalypse comes. But remember the prophecy: even though the people of Jamcode X have been solving problems for two years, and 64-bit integers have always been enough, they might not always be enough now or in the future.\n", "inputFormat": "The first line of the input gives the number of test cases, $C$. $C$ lines follow. Each starts with a single integer $N$, which is followed by a space and then $N$ space-separated integers $t_i$, the number of slarboseconds since Great Event i occurred.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $x$ is the case number (starting from 1) and $y$ is the minimum number of slarboseconds until $t_i + y$ is a multiple of the largest possible integer factor $T$ for all $i$.", "hint": "**Limits**\n\n- $1 \\leqslant C \\leqslant 100.$\n- $t_{i} \\neq t_{j}$ for some $i, j$.\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $2 \\leqslant N \\leqslant 3.$\n- $1 \\leqslant t_{i} \\leqslant 10^{8}.$\n\n**Large dataset (23 Pts, Test set 2 - Hidden)**\n\n- $2 \\leqslant N \\leqslant 1000.$\n- $1 \\leqslant t_{i} \\leqslant 10^{50}.$", "locale": "en", "translations": {"en": {"title": "[GCJ 2010 Qualification] Fair Warning", "background": "Fortunately for the peoples of the Jamcode system, \"the apocalypse\" turned out to be a mistranslation of \"the giant party.\" Nobody from Jamcode IX bothered to pass this along, because they were having so much fun.", "description": "On our planet, Jamcode IX, three Great Events occurred. They happened $26000$, $11000$ and $6000$ slarboseconds ago. In $4000$ slarboseconds, the amount of time since all of those events will be multiples of $5000$ slarboseconds, the largest possible amount... and the apocalypse will come.\n\nLuckily for you, you live on Jamcode X! The apocalypse came on Jamcode IX less than a year ago. But Jamcode X has a worrying prophecy: \"After the moment of reckoning, on the first optimum anniversary of the N Great Events, the apocalypse will come. 64 bits will not save you. You have been warned.\"\n\nThe people of Jamcode X are very concerned by this prophecy. All of the Great Events have already happened, and their times have been measured to the nearest slarbosecond; but nobody knows when their optimum anniversary will occur. After studying the diary of a scientist from Jamcode IX, scientists working on the problem have come up with a theory:\n\nThe moment of reckoning is now, the moment you solve this problem. At some time $y \\geqslant 0$ slarboseconds from now, the number of slarboseconds since each of the Great Events will be divisible by some maximum number $T$. If you can find the smallest value of $y$ that gives this largest possible $T$, that will give you the optimum anniversary when the apocalypse will come.\n\nOn Jamcode IX, for example, there were 3 Great Events and they happened $26000$, $11000$ and $6000$ slarboseconds before the moment of reckoning. $4000$ slarboseconds later, the amount of time since each event was a multiple of $T=5000$ slarboseconds, and the apocalypse came.\n\nYour job is to compute the amount of time until the apocalypse comes. But remember the prophecy: even though the people of Jamcode X have been solving problems for two years, and 64-bit integers have always been enough, they might not always be enough now or in the future.\n", "inputFormat": "The first line of the input gives the number of test cases, $C$. $C$ lines follow. Each starts with a single integer $N$, which is followed by a space and then $N$ space-separated integers $t_i$, the number of slarboseconds since Great Event i occurred.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $x$ is the case number (starting from 1) and $y$ is the minimum number of slarboseconds until $t_i + y$ is a multiple of the largest possible integer factor $T$ for all $i$.", "hint": "**Limits**\n\n- $1 \\leqslant C \\leqslant 100.$\n- $t_{i} \\neq t_{j}$ for some $i, j$.\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $2 \\leqslant N \\leqslant 3.$\n- $1 \\leqslant t_{i} \\leqslant 10^{8}.$\n\n**Large dataset (23 Pts, Test set 2 - Hidden)**\n\n- $2 \\leqslant N \\leqslant 1000.$\n- $1 \\leqslant t_{i} \\leqslant 10^{50}.$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2010 Qualification] Fair Warning", "background": null, "description": "在我们的星球 Jamcode IX 上，曾经发生过三次伟大的事件。它们分别发生在 $26000$、$11000$ 和 $6000$ 个 slarbosecond 之前。再过 $4000$ 个 slarbosecond，从这些事件到那时的时间都将是 $5000$ 的倍数，这是可能的最大倍数……而世界末日也将在那时到来。\n\n幸运的是，你现在生活在 Jamcode X！Jamcode IX 的世界末日发生在不到一年前。但 Jamcode X 有一个令人担忧的预言：“在清算时刻之后，在 $N$ 个伟大事件的第一个最优周年纪念日，世界末日将会到来。64 位整数也无法拯救你。你已被警告。”\n\nJamcode X 的人们非常担心这个预言。所有伟大事件都已经发生，并且它们的时间都被精确测量到了最近的 slarbosecond；但没有人知道它们的最优周年纪念日会在什么时候。科学家们在研究了 Jamcode IX 一位科学家的日记后，提出了一个理论：\n\n清算时刻就是现在，也就是你正在解决这个问题的时刻。在某个距离现在 $y \\geqslant 0$ 个 slarbosecond 的时刻，从每个伟大事件到那时的时间都将能被某个最大整数 $T$ 整除。如果你能找到使这个最大 $T$ 成立的最小 $y$，那么这个 $y$ 就是世界末日到来的最优周年纪念日。\n\n例如，在 Jamcode IX 上，有 3 个伟大事件，分别发生在 $26000$、$11000$ 和 $6000$ 个 slarbosecond 之前。再过 $4000$ 个 slarbosecond，每个事件到那时的时间都是 $T=5000$ 的倍数，于是世界末日到来了。\n\n你的任务是计算距离世界末日还有多少时间。但请记住预言：尽管 Jamcode X 的人们已经解决问题两年了，并且 64 位整数一直都足够，但现在或将来可能就不够用了。", "inputFormat": "输入的第一行是测试用例数 $C$。接下来的 $C$ 行，每行以一个整数 $N$ 开头，后跟一个空格，然后是 $N$ 个用空格分隔的整数 $t_i$，表示第 $i$ 个伟大事件发生至今的 slarbosecond 数。", "outputFormat": "对于每个测试用例，输出一行，格式为 “Case #x: y”，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是距离每个 $t_i + y$ 都能被最大可能的整数因子 $T$ 整除的最小 slarbosecond 数。", "hint": "**数据范围**\n\n- $1 \\leqslant C \\leqslant 100$。\n- 存在某些 $i, j$ 使得 $t_{i} \\neq t_{j}$。\n\n**小数据集（10 分，测试集 1 - 可见）**\n\n- $2 \\leqslant N \\leqslant 3$。\n- $1 \\leqslant t_{i} \\leqslant 10^{8}$。\n\n**大数据集（23 分，测试集 2 - 隐藏）**\n\n- $2 \\leqslant N \\leqslant 1000$。\n- $1 \\leqslant t_{i} \\leqslant 10^{50}$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13389", "type": "P", "difficulty": 3, "samples": [["3\n4 6 4\n1 4 2 1\n100 10 1\n1\n5 5 10\n2 4 2 3 4 2 1 2 1 3", "Case #1: 21\nCase #2: 100\nCase #3: 20"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["模拟", "数学", "2010", "Google Code Jam"], "title": "[GCJ 2010 Qualification] Theme Park", "background": "", "description": "Roller coasters are so much fun! It seems like everybody who visits the theme park wants to ride the roller coaster. Some people go alone; other people go in groups, and don't want to board the roller coaster unless they can all go together. And everyone who rides the roller coaster wants to ride again. A ride costs 1 Euro per person; your job is to figure out how much money the roller coaster will make today.\n\nThe roller coaster can hold $k$ people at once. People queue for it in groups. Groups board the roller coaster, one at a time, until there are no more groups left or there is no room for the next group; then the roller coaster goes, whether it's full or not. Once the ride is over, all of its passengers re-queue in the same order. The roller coaster will run $R$ times in a day.\n\nFor example, suppose $R=4$, $k=6$, and there are four groups of people with sizes: $1$, $4$, $2$, $1$. The first time the roller coaster goes, the first two groups $[1, 4]$ will ride, leaving an empty seat (the group of $2$ won't fit, and the group of $1$ can't go ahead of them). Then they'll go to the back of the queue, which now looks like $2$, $1$, $1$, $4$. The second time, the coaster will hold $4$ people: $[2, 1, 1]$. Now the queue looks like $4$, $2$, $1$, $1$. The third time, it will hold $6$ people: $[4, 2]$. Now the queue looks like $[1, 1, 4, 2]$. Finally, it will hold $6$ people: $[1, 1, 4]$. The roller coaster has made a total of $21$ Euros!", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow, with each test case consisting of two lines. The first line contains three space-separated integers: $R$, $k$ and $N$. The second line contains $N$ space-separated integers $g_{i}$, each of which is the size of a group that wants to ride. $g_{0}$ is the size of the first group, $g_{1}$ is the size of the second group, etc.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $x$ is the case number (starting from $1$) and $y$ is the number of Euros made by the roller coaster.", "hint": "**Sample Explanation**\n\n- $1 \\leqslant T \\leqslant 50.$\n- $g_{i} \\leqslant k.$\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $1 \\leqslant R \\leqslant 1000.$\n- $1 \\leqslant k \\leqslant 100.$\n- $1 \\leqslant N \\leqslant 10.$\n- $1 \\leqslant g_{i} \\leqslant 10.$\n\n**Large dataset (23 Pts, Test set 2 - Hidden)**\n\n- $1 \\leqslant R \\leqslant 10^{8}.$\n- $1 \\leqslant k \\leqslant 10^{9}.$\n- $1 \\leqslant N \\leqslant 1000.$\n- $1 \\leqslant g_{i} \\leqslant 10^{7}.$", "locale": "en", "translations": {"en": {"title": "[GCJ 2010 Qualification] Theme Park", "background": "", "description": "Roller coasters are so much fun! It seems like everybody who visits the theme park wants to ride the roller coaster. Some people go alone; other people go in groups, and don't want to board the roller coaster unless they can all go together. And everyone who rides the roller coaster wants to ride again. A ride costs 1 Euro per person; your job is to figure out how much money the roller coaster will make today.\n\nThe roller coaster can hold $k$ people at once. People queue for it in groups. Groups board the roller coaster, one at a time, until there are no more groups left or there is no room for the next group; then the roller coaster goes, whether it's full or not. Once the ride is over, all of its passengers re-queue in the same order. The roller coaster will run $R$ times in a day.\n\nFor example, suppose $R=4$, $k=6$, and there are four groups of people with sizes: $1$, $4$, $2$, $1$. The first time the roller coaster goes, the first two groups $[1, 4]$ will ride, leaving an empty seat (the group of $2$ won't fit, and the group of $1$ can't go ahead of them). Then they'll go to the back of the queue, which now looks like $2$, $1$, $1$, $4$. The second time, the coaster will hold $4$ people: $[2, 1, 1]$. Now the queue looks like $4$, $2$, $1$, $1$. The third time, it will hold $6$ people: $[4, 2]$. Now the queue looks like $[1, 1, 4, 2]$. Finally, it will hold $6$ people: $[1, 1, 4]$. The roller coaster has made a total of $21$ Euros!", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow, with each test case consisting of two lines. The first line contains three space-separated integers: $R$, $k$ and $N$. The second line contains $N$ space-separated integers $g_{i}$, each of which is the size of a group that wants to ride. $g_{0}$ is the size of the first group, $g_{1}$ is the size of the second group, etc.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $x$ is the case number (starting from $1$) and $y$ is the number of Euros made by the roller coaster.", "hint": "**Sample Explanation**\n\n- $1 \\leqslant T \\leqslant 50.$\n- $g_{i} \\leqslant k.$\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $1 \\leqslant R \\leqslant 1000.$\n- $1 \\leqslant k \\leqslant 100.$\n- $1 \\leqslant N \\leqslant 10.$\n- $1 \\leqslant g_{i} \\leqslant 10.$\n\n**Large dataset (23 Pts, Test set 2 - Hidden)**\n\n- $1 \\leqslant R \\leqslant 10^{8}.$\n- $1 \\leqslant k \\leqslant 10^{9}.$\n- $1 \\leqslant N \\leqslant 1000.$\n- $1 \\leqslant g_{i} \\leqslant 10^{7}.$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2010 Qualification] Theme Park", "background": null, "description": "过山车真有趣！似乎每个来到主题公园的人都想乘坐过山车。有些人单独前来；有些人则结伴而来，并且他们不愿意分开，必须一起上车。每个乘坐过山车的人都想再玩一次。每人每次乘坐需要支付 $1$ 欧元；你的任务是计算今天过山车能赚多少钱。\n\n过山车每次最多可容纳 $k$ 人。人们按组排队等候。每次上车时，按顺序让一个个小组上车，直到没有剩余小组或下一个小组无法全部上车为止；然后过山车就会出发，无论是否坐满。每次游玩结束后，所有乘客会按照原顺序重新排到队伍末尾。过山车一天会运行 $R$ 次。\n\n例如，假设 $R=4$，$k=6$，有四个小组，人数分别为：$1$、$4$、$2$、$1$。第一次运行时，前两个小组 $[1, 4]$ 上车，还剩一个空位（$2$ 人的小组无法全部上车，$1$ 人的小组不能插队）。然后这两个小组排到队尾，队伍变为 $2$、$1$、$1$、$4$。第二次运行时，$[2, 1, 1]$ 共 $4$ 人上车。此时队伍变为 $4$、$2$、$1$、$1$。第三次运行时，$[4, 2]$ 共 $6$ 人上车。此时队伍变为 $[1, 1, 4, 2]$。最后一次运行时，$[1, 1, 4]$ 共 $6$ 人上车。最终，过山车一共赚了 $21$ 欧元。", "inputFormat": "输入的第一行包含测试用例数 $T$。接下来有 $T$ 组测试数据，每组测试数据包含两行。第一行包含三个用空格分隔的整数：$R$、$k$ 和 $N$。第二行包含 $N$ 个用空格分隔的整数 $g_{i}$，每个 $g_{i}$ 表示一个小组的人数。$g_{0}$ 是第一个小组的人数，$g_{1}$ 是第二个小组的人数，依此类推。", "outputFormat": "对于每组测试数据，输出一行，格式为 \"Case #x: y\"，其中 $x$ 表示测试用例编号（从 $1$ 开始），$y$ 表示过山车赚到的欧元数。", "hint": "**样例说明**\n\n- $1 \\leqslant T \\leqslant 50$。\n- $g_{i} \\leqslant k$。\n\n**小数据范围（10 分，测试点 1 - 可见）**\n\n- $1 \\leqslant R \\leqslant 1000$。\n- $1 \\leqslant k \\leqslant 100$。\n- $1 \\leqslant N \\leqslant 10$。\n- $1 \\leqslant g_{i} \\leqslant 10$。\n\n**大数据范围（23 分，测试点 2 - 隐藏）**\n\n- $1 \\leqslant R \\leqslant 10^{8}$。\n- $1 \\leqslant k \\leqslant 10^{9}$。\n- $1 \\leqslant N \\leqslant 1000$。\n- $1 \\leqslant g_{i} \\leqslant 10^{7}$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13390", "type": "P", "difficulty": 2, "samples": [["4\n7 3\n.......\n.......\n.......\n...R...\n...BB..\n..BRB..\n.RRBR..\n6 4\n......\n......\n.R...R\n.R..BB\n.R.RBR\nRB.BBB\n4 4\nR...\nBR..\nBR..\nBR..\n3 3\nB..\nRB.\nRB.", "Case #1: Neither\nCase #2: Both\nCase #3: Red\nCase #4: Blue"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["模拟", "2010", "Google Code Jam"], "title": "[GCJ 2010 #1A] Rotate", "background": "", "description": "In the exciting game of Join-$K$, red and blue pieces are dropped into an $N$-by-$N$ table. The table stands up vertically so that pieces drop down to the bottom-most empty slots in their column. For example, consider the following two configurations:\n\n```\n    - Legal Position -\n\n          .......\n          .......\n          .......\n          ....R..\n          ...RB..\n          ..BRB..\n          .RBBR..\n   - Illegal Position -\n\n          .......\n          .......\n          .......\n          .......\n   Bad -> ..BR...\n          ...R...\n          .RBBR..\n```\n\nIn these pictures, each '.' represents an empty slot, each 'R' represents a slot filled with a red piece, and each 'B' represents a slot filled with a blue piece. The left configuration is legal, but the right one is not. This is because one of the pieces in the third column (marked with the arrow) has not fallen down to the empty slot below it.\n\nA player wins if they can place at least $K$ pieces of their color in a row, either horizontally, vertically, or diagonally. The four possible orientations are shown below:\n\n```\n      - Four in a row -\n\n     R   RRRR    R   R\n     R          R     R\n     R         R       R\n     R        R         R\n```\n\nIn the \"Legal Position\" diagram at the beginning of the problem statement, both players had lined up two pieces in a row, but not three.\n\nAs it turns out, you are right now playing a very exciting game of Join-$K$, and you have a tricky plan to ensure victory! When your opponent is not looking, you are going to rotate the board 90 degrees clockwise onto its side. Gravity will then cause the pieces to fall down into a new position as shown below:\n\n```\n    - Start -\n\n     .......\n     .......\n     .......\n     ...R...\n     ...RB..\n     ..BRB..\n     .RBBR..\n   - Rotate -\n\n     .......\n     R......\n     BB.....\n     BRRR...\n     RBB....\n     .......\n     .......\n   - Gravity -\n\n     .......\n     .......\n     .......\n     R......\n     BB.....\n     BRR....\n     RBBR...\n```\n\nUnfortunately, you only have time to rotate once before your opponent will notice.\n\nAll that remains is picking the right time to make your move. Given a board position, you should determine which player (or players!) will have $K$ pieces in a row after you rotate the board clockwise and gravity takes effect in the new direction.\n\n### Notes\n- You can rotate the board only once.\n- Assume that gravity only takes effect after the board has been rotated completely.\n- Only check for winners after gravity has finished taking effect.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow, each beginning with a line containing the integers $N$ and $K$. The next $N$ lines will each be exactly $N$ characters long, showing the initial position of the board, using the same format as the diagrams above.\n\nThe initial position in each test case will be a legal position that can occur during a game of Join-$K$. In particular, neither player will have already formed $K$ pieces in a row.", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $x$ is the case number (starting from 1), and $y$ is one of \"Red\", \"Blue\", \"Neither\", or \"Both\". Here, $y$ indicates which player or players will have $K$ pieces in a row after you rotate the board.", "hint": "**Limits**\n\n- $1 \\leqslant T \\leqslant 100$.\n- $3 \\leqslant K \\leqslant N$.\n\n**Small dataset (11 Pts, Test set 1 - Visible)**\n\n- $3 \\leqslant N \\leqslant 7$.\n\n**Large dataset (12 Pts, Test set 2 - Hidden)**\n\n- $3 \\leqslant N \\leqslant 50$.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2010 #1A] Rotate", "background": "", "description": "In the exciting game of Join-$K$, red and blue pieces are dropped into an $N$-by-$N$ table. The table stands up vertically so that pieces drop down to the bottom-most empty slots in their column. For example, consider the following two configurations:\n\n```\n    - Legal Position -\n\n          .......\n          .......\n          .......\n          ....R..\n          ...RB..\n          ..BRB..\n          .RBBR..\n   - Illegal Position -\n\n          .......\n          .......\n          .......\n          .......\n   Bad -> ..BR...\n          ...R...\n          .RBBR..\n```\n\nIn these pictures, each '.' represents an empty slot, each 'R' represents a slot filled with a red piece, and each 'B' represents a slot filled with a blue piece. The left configuration is legal, but the right one is not. This is because one of the pieces in the third column (marked with the arrow) has not fallen down to the empty slot below it.\n\nA player wins if they can place at least $K$ pieces of their color in a row, either horizontally, vertically, or diagonally. The four possible orientations are shown below:\n\n```\n      - Four in a row -\n\n     R   RRRR    R   R\n     R          R     R\n     R         R       R\n     R        R         R\n```\n\nIn the \"Legal Position\" diagram at the beginning of the problem statement, both players had lined up two pieces in a row, but not three.\n\nAs it turns out, you are right now playing a very exciting game of Join-$K$, and you have a tricky plan to ensure victory! When your opponent is not looking, you are going to rotate the board 90 degrees clockwise onto its side. Gravity will then cause the pieces to fall down into a new position as shown below:\n\n```\n    - Start -\n\n     .......\n     .......\n     .......\n     ...R...\n     ...RB..\n     ..BRB..\n     .RBBR..\n   - Rotate -\n\n     .......\n     R......\n     BB.....\n     BRRR...\n     RBB....\n     .......\n     .......\n   - Gravity -\n\n     .......\n     .......\n     .......\n     R......\n     BB.....\n     BRR....\n     RBBR...\n```\n\nUnfortunately, you only have time to rotate once before your opponent will notice.\n\nAll that remains is picking the right time to make your move. Given a board position, you should determine which player (or players!) will have $K$ pieces in a row after you rotate the board clockwise and gravity takes effect in the new direction.\n\n### Notes\n- You can rotate the board only once.\n- Assume that gravity only takes effect after the board has been rotated completely.\n- Only check for winners after gravity has finished taking effect.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow, each beginning with a line containing the integers $N$ and $K$. The next $N$ lines will each be exactly $N$ characters long, showing the initial position of the board, using the same format as the diagrams above.\n\nThe initial position in each test case will be a legal position that can occur during a game of Join-$K$. In particular, neither player will have already formed $K$ pieces in a row.", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $x$ is the case number (starting from 1), and $y$ is one of \"Red\", \"Blue\", \"Neither\", or \"Both\". Here, $y$ indicates which player or players will have $K$ pieces in a row after you rotate the board.", "hint": "**Limits**\n\n- $1 \\leqslant T \\leqslant 100$.\n- $3 \\leqslant K \\leqslant N$.\n\n**Small dataset (11 Pts, Test set 1 - Visible)**\n\n- $3 \\leqslant N \\leqslant 7$.\n\n**Large dataset (12 Pts, Test set 2 - Hidden)**\n\n- $3 \\leqslant N \\leqslant 50$.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2010 #1A] Rotate", "background": null, "description": "在激动人心的 Join-$K$ 游戏中，红色和蓝色棋子被投入一个 $N \\times N$ 的棋盘。棋盘是竖直放置的，因此棋子会下落到该列最底部的空位。例如，考虑以下两种棋盘状态：\n\n```\n    - 合法状态 -\n\n          .......\n          .......\n          .......\n          ....R..\n          ...RB..\n          ..BRB..\n          .RBBR..\n   - 非法状态 -\n\n          .......\n          .......\n          .......\n          .......\n   错误 -> ..BR...\n          ...R...\n          .RBBR..\n```\n\n在这些图中，每个 '.' 表示一个空位，每个 'R' 表示一个红色棋子，每个 'B' 表示一个蓝色棋子。左边的状态是合法的，而右边的状态不是。原因是第三列中有一个棋子（箭头所指）没有落到其下方的空位上。\n\n如果某个玩家能够将至少 $K$ 个同色棋子连成一行（可以是横向、纵向或对角线），则该玩家获胜。四种可能的连线方向如下所示：\n\n```\n      - 四连子 -\n\n     R   RRRR    R   R\n     R          R     R\n     R         R       R\n     R        R         R\n```\n\n在题目开头的“合法状态”示意图中，两个玩家都已经连成了两个棋子，但都没有连成三个。\n\n现在，你正处于一场激烈的 Join-$K$ 游戏中，并且你有一个巧妙的计划确保获胜！当你的对手不注意时，你准备将棋盘顺时针旋转 $90$ 度。然后，重力会让棋子在新方向上再次下落，形成如下状态：\n\n```\n    - 初始 -\n\n     .......\n     .......\n     .......\n     ...R...\n     ...RB..\n     ..BRB..\n     .RBBR..\n   - 旋转 -\n\n     .......\n     R......\n     BB.....\n     BRRR...\n     RBB....\n     .......\n     .......\n   - 重力作用 -\n\n     .......\n     .......\n     .......\n     R......\n     BB.....\n     BRR....\n     RBBR...\n```\n\n不幸的是，你只有一次旋转的机会，在对手发现之前。\n\n现在只剩下选择合适的时机出手了。给定一个棋盘状态，请你判断在顺时针旋转棋盘并让重力生效后，哪一方（或双方！）会在棋盘上连成 $K$ 个棋子。\n\n### 注意\n- 你只能旋转棋盘一次。\n- 假设重力只在棋盘完全旋转后才会生效。\n- 只有在重力作用结束后才检查是否有玩家获胜。", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据，每组测试数据的第一行为两个整数 $N$ 和 $K$。接下来的 $N$ 行，每行恰好 $N$ 个字符，表示棋盘的初始状态，格式与上文示意图一致。\n\n每组测试数据中的初始状态都是 Join-$K$ 游戏中可能出现的合法状态。特别地，初始状态下不会有玩家已经连成 $K$ 个棋子。", "outputFormat": "对于每组测试数据，输出一行，格式为 \"Case #x: y\"，其中 $x$ 是测试用例编号（从 1 开始），$y$ 为 \"Red\"、\"Blue\"、\"Neither\" 或 \"Both\" 之一，表示在旋转棋盘并让重力生效后，哪一方（或双方）会连成 $K$ 个棋子。", "hint": "**数据范围**\n\n- $1 \\leqslant T \\leqslant 100$。\n- $3 \\leqslant K \\leqslant N$。\n\n**小数据范围（11 分，测试点 1 - 可见）**\n\n- $3 \\leqslant N \\leqslant 7$。\n\n**大数据范围（12 分，测试点 2 - 隐藏）**\n\n- $3 \\leqslant N \\leqslant 50$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13391", "type": "P", "difficulty": 4, "samples": [["2\n6 6 2 3\n1 7 5\n100 1 5 3\n1 50 7", "Case #1: 4\nCase #2: 17"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2010", "单调队列", "Google Code Jam"], "title": "[GCJ 2010 #1A] Make it Smooth", "background": "", "description": "You have a one-dimensional array of $N$ pixels. Each pixel has a value, represented by a number between 0 and 255, inclusive. The distance between two pixels is the absolute difference of their numbers.\n\nYou can perform each of the following operations zero or more times:\n\n1. With cost $D$, delete any pixel, so its original neighbors become neighboring pixels.\n2. With cost $I$, insert one pixel of any value into any position -- either between two existing pixels, or before the first pixel, or after the last pixel.\n3. You can change the value of any pixel. The cost is the absolute difference of the old value of the pixel and the new value of the pixel.\n\nThe array is smooth if any neighboring pixels have distance at most $M$. Find the minimum possible cost of a sequence of operations that makes the array smooth.\n\nNote: The empty array -- the array containing no pixels -- is considered to be smooth.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow, each with two lines. The first line is in the form \"D I M N\", the next line contains $N$ numbers $a_i$: the values of the pixels from left to the right.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $x$ is the case number (starting from 1), and $y$ is the minimum cost to make the input array smooth.", "hint": "**Sample Explanation**\n\nIn Case #1, decreasing the $7$ to $3$ costs $4$ and is the cheapest solution. In Case #2, deleting is extremely expensive; it's cheaper to insert elements so your final array looks like $[1, 6, 11, 16, 21, 26, 31, 36, 41, 46, 50, 45, 40, 35, 30, 25, 20, 15, 10, 7]$.\n\n**Limits**\n\n- All the numbers in the input are integers.\n- $1 \\leqslant T \\leqslant 100$\n- $0 \\leqslant D, I, M, a_i \\leqslant 255$\n\n**Small dataset (12 Pts, Test set 1 - Visible)**\n\n- $1 \\leqslant N \\leqslant 3$.\n\n**Large dataset (24 Pts, Test set 2 - Hidden)**\n\n- $1 \\leqslant N \\leqslant 100$.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2010 #1A] Make it Smooth", "background": "", "description": "You have a one-dimensional array of $N$ pixels. Each pixel has a value, represented by a number between 0 and 255, inclusive. The distance between two pixels is the absolute difference of their numbers.\n\nYou can perform each of the following operations zero or more times:\n\n1. With cost $D$, delete any pixel, so its original neighbors become neighboring pixels.\n2. With cost $I$, insert one pixel of any value into any position -- either between two existing pixels, or before the first pixel, or after the last pixel.\n3. You can change the value of any pixel. The cost is the absolute difference of the old value of the pixel and the new value of the pixel.\n\nThe array is smooth if any neighboring pixels have distance at most $M$. Find the minimum possible cost of a sequence of operations that makes the array smooth.\n\nNote: The empty array -- the array containing no pixels -- is considered to be smooth.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow, each with two lines. The first line is in the form \"D I M N\", the next line contains $N$ numbers $a_i$: the values of the pixels from left to the right.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $x$ is the case number (starting from 1), and $y$ is the minimum cost to make the input array smooth.", "hint": "**Sample Explanation**\n\nIn Case #1, decreasing the $7$ to $3$ costs $4$ and is the cheapest solution. In Case #2, deleting is extremely expensive; it's cheaper to insert elements so your final array looks like $[1, 6, 11, 16, 21, 26, 31, 36, 41, 46, 50, 45, 40, 35, 30, 25, 20, 15, 10, 7]$.\n\n**Limits**\n\n- All the numbers in the input are integers.\n- $1 \\leqslant T \\leqslant 100$\n- $0 \\leqslant D, I, M, a_i \\leqslant 255$\n\n**Small dataset (12 Pts, Test set 1 - Visible)**\n\n- $1 \\leqslant N \\leqslant 3$.\n\n**Large dataset (24 Pts, Test set 2 - Hidden)**\n\n- $1 \\leqslant N \\leqslant 100$.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2010 #1A] Make it Smooth", "background": null, "description": "你有一个长度为 $N$ 的一维像素数组。每个像素都有一个取值，表示为 $0$ 到 $255$ 之间的一个数字（包含 $0$ 和 $255$）。两个像素之间的距离定义为它们数值的绝对差。\n\n你可以进行以下任意次数的操作：\n\n1. 以代价 $D$，删除任意一个像素，此时它原本的相邻像素会变为新的相邻像素。\n2. 以代价 $I$，在任意位置插入一个任意值的像素——可以插在任意两个像素之间，也可以插在第一个像素之前或最后一个像素之后。\n3. 你可以修改任意一个像素的值，代价为该像素的新旧值的绝对差。\n\n如果数组中任意相邻像素的距离都不超过 $M$，则称该数组是“平滑”的。请你求出将输入数组变为平滑数组所需的最小总代价。\n\n注意：空数组（即不包含任何像素的数组）也被认为是平滑的。", "inputFormat": "输入的第一行是测试用例数 $T$。接下来有 $T$ 组测试数据，每组包含两行。第一行为 \"D I M N\"，下一行为 $N$ 个数字 $a_i$，表示从左到右的像素值。", "outputFormat": "对于每组测试数据，输出一行，格式为 \"Case #x: y\"，其中 $x$ 为测试编号（从 1 开始），$y$ 为使输入数组变为平滑数组的最小总代价。", "hint": "**样例解释**\n\n在第 1 组中，将 $7$ 降为 $3$ 的代价为 $4$，这是最便宜的方案。在第 2 组中，删除操作非常昂贵；插入元素使最终数组变为 $[1, 6, 11, 16, 21, 26, 31, 36, 41, 46, 50, 45, 40, 35, 30, 25, 20, 15, 10, 7]$ 更便宜。\n\n**数据范围**\n\n- 输入中的所有数字均为整数。\n- $1 \\leqslant T \\leqslant 100$\n- $0 \\leqslant D, I, M, a_i \\leqslant 255$\n\n**小数据范围（12 分，测试点 1 - 可见）**\n\n- $1 \\leqslant N \\leqslant 3$。\n\n**大数据范围（24 分，测试点 2 - 隐藏）**\n\n- $1 \\leqslant N \\leqslant 100$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13392", "type": "P", "difficulty": 6, "samples": [["3\n5 5 8 8\n11 11 2 2\n1 6 1 6", "Case #1: 0\nCase #2: 1\nCase #3: 20"]], "limits": {"time": [3000, 9000], "memory": [1048576, 1048576]}, "tags": ["博弈论", "2010", "Google Code Jam"], "title": "[GCJ 2010 #1A] Number Game", "background": "", "description": "Arya and Bran are playing a game. Initially, two positive integers $A$ and $B$ are written on a blackboard. The players take turns, starting with Arya. On his or her turn, a player can replace $A$ with $A - k \\times B$ for any positive integer $k$, or replace $B$ with $B - k \\times A$ for any positive integer $k$. The first person to make one of the numbers drop to zero or below loses.\n\nFor example, if the numbers are initially $(12, 51)$, the game might progress as follows:\n\n- Arya replaces $51$ with $51 - 3 \\times 12 = 15$, leaving $(12, 15)$ on the blackboard.\n- Bran replaces $15$ with $15 - 1 \\times 12 = 3$, leaving $(12, 3)$ on the blackboard.\n- Arya replaces $12$ with $12 - 3 \\times 3 = 3$, leaving $(3, 3)$ on the blackboard.\n- Bran replaces one $3$ with $3 - 1 \\times 3 = 0$, and loses.\n\nWe will say $(A, B)$ is a winning position if Arya can always win a game that starts with $(A, B)$ on the blackboard, no matter what Bran does.\n\nGiven four integers $A_1$, $A_2$, $B_1$, $B_2$, count how many winning positions $(A, B)$ there are with $A_1 \\leq A \\leq A_2$ and $B_1 \\leq B \\leq B_2$.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow, one per line. Each line contains the four integers $A_1$, $A_2$, $B_1$, $B_2$, separated by spaces.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $x$ is the case number (starting from 1), and $y$ is the number of winning positions $(A, B)$ with $A_1 \\leq A \\leq A_2$ and $B_1 \\leq B \\leq B_2$.", "hint": "**Limits**\n\n- $1 \\leqslant T \\leqslant 100.$\n- $1 \\leqslant A_1 \\leqslant A_2 \\leqslant 1,000,000.$\n- $1 \\leqslant B_1 \\leqslant B_2 \\leqslant 1,000,000.$\n\n**Small dataset (16 Pts, Test set 1 - Visible)**\n\n- Time limit: ~~30~~ 3 seconds.\n- $A_2 - A_1 \\leqslant 30.$\n- $B_2 - B_1 \\leqslant 30.$\n\n**Large dataset (25 Pts, Test set 2 - Hidden)**\n\n- Time limit: ~~90~~ 9 seconds.\n- $A_2 - A_1 \\leqslant 999,999.$\n- $B_2 - B_1 \\leqslant 999,999.$\n- No additional constraints.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2010 #1A] Number Game", "background": "", "description": "Arya and Bran are playing a game. Initially, two positive integers $A$ and $B$ are written on a blackboard. The players take turns, starting with Arya. On his or her turn, a player can replace $A$ with $A - k \\times B$ for any positive integer $k$, or replace $B$ with $B - k \\times A$ for any positive integer $k$. The first person to make one of the numbers drop to zero or below loses.\n\nFor example, if the numbers are initially $(12, 51)$, the game might progress as follows:\n\n- Arya replaces $51$ with $51 - 3 \\times 12 = 15$, leaving $(12, 15)$ on the blackboard.\n- Bran replaces $15$ with $15 - 1 \\times 12 = 3$, leaving $(12, 3)$ on the blackboard.\n- Arya replaces $12$ with $12 - 3 \\times 3 = 3$, leaving $(3, 3)$ on the blackboard.\n- Bran replaces one $3$ with $3 - 1 \\times 3 = 0$, and loses.\n\nWe will say $(A, B)$ is a winning position if Arya can always win a game that starts with $(A, B)$ on the blackboard, no matter what Bran does.\n\nGiven four integers $A_1$, $A_2$, $B_1$, $B_2$, count how many winning positions $(A, B)$ there are with $A_1 \\leq A \\leq A_2$ and $B_1 \\leq B \\leq B_2$.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow, one per line. Each line contains the four integers $A_1$, $A_2$, $B_1$, $B_2$, separated by spaces.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $x$ is the case number (starting from 1), and $y$ is the number of winning positions $(A, B)$ with $A_1 \\leq A \\leq A_2$ and $B_1 \\leq B \\leq B_2$.", "hint": "**Limits**\n\n- $1 \\leqslant T \\leqslant 100.$\n- $1 \\leqslant A_1 \\leqslant A_2 \\leqslant 1,000,000.$\n- $1 \\leqslant B_1 \\leqslant B_2 \\leqslant 1,000,000.$\n\n**Small dataset (16 Pts, Test set 1 - Visible)**\n\n- Time limit: ~~30~~ 3 seconds.\n- $A_2 - A_1 \\leqslant 30.$\n- $B_2 - B_1 \\leqslant 30.$\n\n**Large dataset (25 Pts, Test set 2 - Hidden)**\n\n- Time limit: ~~90~~ 9 seconds.\n- $A_2 - A_1 \\leqslant 999,999.$\n- $B_2 - B_1 \\leqslant 999,999.$\n- No additional constraints.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2010 #1A] Number Game", "background": null, "description": "Arya 和 Bran 正在玩一个游戏。最初，黑板上写着两个正整数 $A$ 和 $B$。两位玩家轮流行动，Arya 先手。在每一回合，玩家可以将 $A$ 替换为 $A - k \\times B$（$k$ 为任意正整数），或者将 $B$ 替换为 $B - k \\times A$（$k$ 为任意正整数）。第一个使得其中一个数变为零或负数的人输掉游戏。\n\n例如，如果初始数字为 $(12, 51)$，游戏过程可能如下：\n\n- Arya 将 $51$ 替换为 $51 - 3 \\times 12 = 15$，黑板上变为 $(12, 15)$。\n- Bran 将 $15$ 替换为 $15 - 1 \\times 12 = 3$，黑板上变为 $(12, 3)$。\n- Arya 将 $12$ 替换为 $12 - 3 \\times 3 = 3$，黑板上变为 $(3, 3)$。\n- Bran 将其中一个 $3$ 替换为 $3 - 1 \\times 3 = 0$，Bran 输掉游戏。\n\n我们称 $(A, B)$ 为“必胜态”，如果 Arya 无论 Bran 如何应对，都能保证获胜。\n\n给定四个整数 $A_1$、$A_2$、$B_1$、$B_2$，请统计有多少个 $(A, B)$ 是必胜态，且满足 $A_1 \\leq A \\leq A_2$ 且 $B_1 \\leq B \\leq B_2$。", "inputFormat": "输入的第一行包含一个整数 $T$，表示测试用例的数量。接下来 $T$ 行，每行包含四个整数 $A_1$、$A_2$、$B_1$、$B_2$，用空格分隔。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #x: y\"，其中 $x$ 表示测试用例编号（从 1 开始），$y$ 表示满足条件的必胜态 $(A, B)$ 的数量。", "hint": "**数据范围**\n\n- $1 \\leqslant T \\leqslant 100$。\n- $1 \\leqslant A_1 \\leqslant A_2 \\leqslant 1,000,000$。\n- $1 \\leqslant B_1 \\leqslant B_2 \\leqslant 1,000,000$。\n\n**小数据（16 分，测试点 1 - 可见）**\n\n- 时间限制：3 秒。\n- $A_2 - A_1 \\leqslant 30$。\n- $B_2 - B_1 \\leqslant 30$。\n\n**大数据（25 分，测试点 2 - 隐藏）**\n\n- 时间限制：9 秒。\n- $A_2 - A_1 \\leqslant 999,999$。\n- $B_2 - B_1 \\leqslant 999,999$。\n- 无其他限制。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13393", "type": "P", "difficulty": 2, "samples": [["3\n0 2\n/home/gcj/finals\n/home/gcj/quals\n2 1\n/chicken\n/chicken/egg\n/chicken\n1 3\n/a\n/a/b\n/a/c\n/b/b", "Case #1: 4\nCase #2: 0\nCase #3: 4"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["模拟", "字符串", "树形数据结构", "2010", "Google Code Jam"], "title": "[GCJ 2010 #1B] File Fix-it", "background": "", "description": "On Unix computers, data is stored in directories. There is one root directory, and this might have several directories contained inside of it, each with different names. These directories might have even more directories contained inside of them, and so on.\n\nA directory is uniquely identified by its name and its parent directory (the directory it is directly contained in). This is usually encoded in a path, which consists of several parts each preceded by a forward slash ('/'). The final part is the name of the directory, and everything else gives the path of its parent directory. For example, consider the path:\n```\n/home/gcj/finals\n```\nThis refers to the directory with name \"finals\" in the directory described by \"/home/gcj\", which in turn refers to the directory with name \"gcj\" in the directory described by the path \"/home\". In this path, there is only one part, which means it refers to the directory with the name \"home\" in the root directory.\n\nTo create a directory, you can use the mkdir command. You specify a path, and then mkdir will create the directory described by that path, but only if the parent directory already exists. For example, if you wanted to create the \"/home/gcj/finals\" and \"/home/gcj/quals\" directories from scratch, you would need four commands:\n```\nmkdir /home\nmkdir /home/gcj\nmkdir /home/gcj/finals\nmkdir /home/gcj/quals\n```\nGiven the full set of directories already existing on your computer, and a set of new directories you want to create if they do not already exist, how many mkdir commands do you need to use?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each case begins with a line containing two integers $N$ and $M$, separated by a space.\n\nThe next $N$ lines each give the path of one directory that already exists on your computer. This list will include every directory already on your computer other than the root directory. (The root directory is on every computer, so there is no need to list it explicitly.)\n\nThe next $M$ lines each give the path of one directory that you want to create.\n\nEach of the paths in the input is formatted as in the problem statement above. Specifically, a path consists of one or more lower-case alpha-numeric strings (i.e., strings containing only the symbols 'a'-'z' and '0'-'9'), each preceded by a single forward slash. These alpha-numeric strings are never empty.", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the number of $mkdir$ you need.", "hint": "**Limits**\n\n- $1 \\leqslant T \\leqslant 100.$\n- No path will have more than 100 characters in it.\n- No path will appear twice in the list of directories already on your computer, or in the list of directories you wish to create. A path may appear once in both lists however. (See example case #2 below).\n- If a directory is listed as being on your computer, then its parent directory will also be listed, unless the parent is the root directory.\n- The input file will be no longer than 100,000 bytes in total.\n\n**Small dataset (12 Pts, Test set 1 - Visible)**\n\n- $0 \\leqslant N \\leqslant 10.$\n- $1 \\leqslant M \\leqslant 10.$\n\n**Large dataset (14 Pts, Test set 2 - Hidden)**\n\n- $0 \\leqslant N \\leqslant 100.$\n- $1 \\leqslant M \\leqslant 100.$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2010 #1B] File Fix-it", "background": "", "description": "On Unix computers, data is stored in directories. There is one root directory, and this might have several directories contained inside of it, each with different names. These directories might have even more directories contained inside of them, and so on.\n\nA directory is uniquely identified by its name and its parent directory (the directory it is directly contained in). This is usually encoded in a path, which consists of several parts each preceded by a forward slash ('/'). The final part is the name of the directory, and everything else gives the path of its parent directory. For example, consider the path:\n```\n/home/gcj/finals\n```\nThis refers to the directory with name \"finals\" in the directory described by \"/home/gcj\", which in turn refers to the directory with name \"gcj\" in the directory described by the path \"/home\". In this path, there is only one part, which means it refers to the directory with the name \"home\" in the root directory.\n\nTo create a directory, you can use the mkdir command. You specify a path, and then mkdir will create the directory described by that path, but only if the parent directory already exists. For example, if you wanted to create the \"/home/gcj/finals\" and \"/home/gcj/quals\" directories from scratch, you would need four commands:\n```\nmkdir /home\nmkdir /home/gcj\nmkdir /home/gcj/finals\nmkdir /home/gcj/quals\n```\nGiven the full set of directories already existing on your computer, and a set of new directories you want to create if they do not already exist, how many mkdir commands do you need to use?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each case begins with a line containing two integers $N$ and $M$, separated by a space.\n\nThe next $N$ lines each give the path of one directory that already exists on your computer. This list will include every directory already on your computer other than the root directory. (The root directory is on every computer, so there is no need to list it explicitly.)\n\nThe next $M$ lines each give the path of one directory that you want to create.\n\nEach of the paths in the input is formatted as in the problem statement above. Specifically, a path consists of one or more lower-case alpha-numeric strings (i.e., strings containing only the symbols 'a'-'z' and '0'-'9'), each preceded by a single forward slash. These alpha-numeric strings are never empty.", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the number of $mkdir$ you need.", "hint": "**Limits**\n\n- $1 \\leqslant T \\leqslant 100.$\n- No path will have more than 100 characters in it.\n- No path will appear twice in the list of directories already on your computer, or in the list of directories you wish to create. A path may appear once in both lists however. (See example case #2 below).\n- If a directory is listed as being on your computer, then its parent directory will also be listed, unless the parent is the root directory.\n- The input file will be no longer than 100,000 bytes in total.\n\n**Small dataset (12 Pts, Test set 1 - Visible)**\n\n- $0 \\leqslant N \\leqslant 10.$\n- $1 \\leqslant M \\leqslant 10.$\n\n**Large dataset (14 Pts, Test set 2 - Hidden)**\n\n- $0 \\leqslant N \\leqslant 100.$\n- $1 \\leqslant M \\leqslant 100.$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2010 #1B] File Fix-it", "background": null, "description": "在 Unix 计算机中，数据存储在目录中。存在一个根目录，根目录下可以包含若干名称不同的目录。这些目录下还可以包含更多的目录，依此类推。\n\n一个目录可以通过其名称和父目录（即直接包含它的目录）唯一确定。这通常通过路径来编码，路径由若干部分组成，每一部分前面都有一个正斜杠（'/'）。最后一部分是该目录的名称，其余部分描述其父目录的路径。例如，考虑如下路径：\n```\n/home/gcj/finals\n```\n该路径指的是名为 \"finals\" 的目录，它位于 \"/home/gcj\" 所描述的目录下，而 \"/home/gcj\" 又指的是名为 \"gcj\" 的目录，位于 \"/home\" 所描述的目录下。在这个路径中，只有一部分，意味着它指的是根目录下名为 \"home\" 的目录。\n\n要创建一个目录，可以使用 mkdir 命令。你需要指定一个路径，mkdir 会创建该路径描述的目录，但前提是其父目录已经存在。例如，如果你想从零开始创建 \"/home/gcj/finals\" 和 \"/home/gcj/quals\" 这两个目录，你需要四条命令：\n```\nmkdir /home\nmkdir /home/gcj\nmkdir /home/gcj/finals\nmkdir /home/gcj/quals\n```\n给定你计算机上已经存在的所有目录，以及你想要新建（如果尚未存在）的目录集合，你需要用多少条 mkdir 命令？", "inputFormat": "输入的第一行包含测试用例数 $T$。接下来有 $T$ 组测试用例。每组用例的第一行包含两个整数 $N$ 和 $M$，用空格分隔。\n\n接下来的 $N$ 行，每行给出你计算机上已经存在的一个目录的路径。该列表将包含你计算机上除根目录以外的所有已存在目录（根目录在每台计算机上都存在，因此无需显式列出）。\n\n接下来的 $M$ 行，每行给出你想要创建的一个目录的路径。\n\n输入中的每个路径格式如题目描述所述。具体来说，路径由一个或多个小写字母或数字组成的字符串（即仅包含 'a'-'z' 和 '0'-'9'），每个字符串前都有一个正斜杠。这些字符串不会为空。", "outputFormat": "对于每组测试用例，输出一行，格式为 \"Case #$x$: $y$\"，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是你需要使用的 mkdir 命令数量。", "hint": "**限制条件**\n\n- $1 \\leqslant T \\leqslant 100$。\n- 任意路径长度不超过 100 个字符。\n- 已存在目录列表和待创建目录列表中不会有重复路径，但同一个路径可能在两者中各出现一次（见下方示例 case #2）。\n- 如果某个目录已在你计算机上存在，则其父目录也必然在列表中，除非父目录是根目录。\n- 输入文件总长度不超过 100,000 字节。\n\n**小数据范围（12 分，测试集 1 - 可见）**\n\n- $0 \\leqslant N \\leqslant 10$。\n- $1 \\leqslant M \\leqslant 10$。\n\n**大数据范围（14 分，测试集 2 - 隐藏）**\n\n- $0 \\leqslant N \\leqslant 100$。\n- $1 \\leqslant M \\leqslant 100$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13394", "type": "P", "difficulty": 3, "samples": [["3\n5 3 10 5\n0 2 5 6 7\n1 1 1 1 4\n5 3 10 5\n0 2 3 5 7\n2 1 1 1 4\n5 3 10 5\n0 2 3 4 7\n2 1 1 1 4", "Case #1: 0\nCase #2: 2\nCase #3: IMPOSSIBLE"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2010", "Google Code Jam"], "title": "[GCJ 2010 #1B] Picking Up Chicks", "background": "", "description": "A flock of chickens are running east along a straight, narrow road. Each one is running with its own constant speed. Whenever a chick catches up to the one in front of it, it has to slow down and follow at the speed of the other chick. You are in a mobile crane behind the flock, chasing the chicks towards the barn at the end of the road. The arm of the crane allows you to pick up any chick momentarily, let the chick behind it pass underneath and place the picked up chick back down. This operation takes no time and can only be performed on a pair of chicks that are immediately next to each other, even if 3 or more chicks are in a row, one after the other.\n\nGiven the initial locations ($X_i$) at time 0 and natural speeds ($V_i$) of the chicks, as well as the location of the barn ($B$), what is the minimum number of swaps you need to perform with your crane in order to have at least $K$ of the $N$ chicks arrive at the barn no later than time $T$?\n\nYou may think of the chicks as points moving along a line. Even if 3 or more chicks are at the same location, next to each other, picking up one of them will only let one of the other two pass through. Any swap is instantaneous, which means that you may perform multiple swaps at the same time, but each one will count as a separate swap.", "inputFormat": "The first line of the input gives the number of test cases, $C$. $C$ test cases follow. Each test case starts with 4 integers on a line -- $N$, $K$, $B$ and $T$. The next line contains the $N$ different integers $X_i$, in increasing order. The line after that contains the $N$ integers $V_i$. All distances are in meters; all speeds are in meters per second; all times are in seconds.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $S$\", where $x$ is the case number (starting from 1) and $S$ is the smallest number of required swaps, or the word \"IMPOSSIBLE\".", "hint": "**Limits**\n\n- $1 \\leqslant C \\leqslant 100;$\n- $1 \\leqslant B \\leqslant 1,000,000,000;$\n- $1 \\leqslant T \\leqslant 1,000;$\n- $0 \\leqslant X_i < B;$\n- $1 \\leqslant V_i \\leqslant 100;$\n- All the $X_i$'s will be distinct and in increasing order.\n\n**Small dataset (13 Pts, Test set 1 - Visible)**\n\n- $1 \\leqslant N \\leqslant 10;$\n- $0 \\leqslant K \\leqslant \\min(3, N);$\n\n**Large dataset (17 Pts, Test set 2 - Hidden)**\n\n- $1 \\leqslant N \\leqslant 50;$\n- $0 \\leqslant K \\leqslant N;$", "locale": "en", "translations": {"en": {"title": "[GCJ 2010 #1B] Picking Up Chicks", "background": "", "description": "A flock of chickens are running east along a straight, narrow road. Each one is running with its own constant speed. Whenever a chick catches up to the one in front of it, it has to slow down and follow at the speed of the other chick. You are in a mobile crane behind the flock, chasing the chicks towards the barn at the end of the road. The arm of the crane allows you to pick up any chick momentarily, let the chick behind it pass underneath and place the picked up chick back down. This operation takes no time and can only be performed on a pair of chicks that are immediately next to each other, even if 3 or more chicks are in a row, one after the other.\n\nGiven the initial locations ($X_i$) at time 0 and natural speeds ($V_i$) of the chicks, as well as the location of the barn ($B$), what is the minimum number of swaps you need to perform with your crane in order to have at least $K$ of the $N$ chicks arrive at the barn no later than time $T$?\n\nYou may think of the chicks as points moving along a line. Even if 3 or more chicks are at the same location, next to each other, picking up one of them will only let one of the other two pass through. Any swap is instantaneous, which means that you may perform multiple swaps at the same time, but each one will count as a separate swap.", "inputFormat": "The first line of the input gives the number of test cases, $C$. $C$ test cases follow. Each test case starts with 4 integers on a line -- $N$, $K$, $B$ and $T$. The next line contains the $N$ different integers $X_i$, in increasing order. The line after that contains the $N$ integers $V_i$. All distances are in meters; all speeds are in meters per second; all times are in seconds.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $S$\", where $x$ is the case number (starting from 1) and $S$ is the smallest number of required swaps, or the word \"IMPOSSIBLE\".", "hint": "**Limits**\n\n- $1 \\leqslant C \\leqslant 100;$\n- $1 \\leqslant B \\leqslant 1,000,000,000;$\n- $1 \\leqslant T \\leqslant 1,000;$\n- $0 \\leqslant X_i < B;$\n- $1 \\leqslant V_i \\leqslant 100;$\n- All the $X_i$'s will be distinct and in increasing order.\n\n**Small dataset (13 Pts, Test set 1 - Visible)**\n\n- $1 \\leqslant N \\leqslant 10;$\n- $0 \\leqslant K \\leqslant \\min(3, N);$\n\n**Large dataset (17 Pts, Test set 2 - Hidden)**\n\n- $1 \\leqslant N \\leqslant 50;$\n- $0 \\leqslant K \\leqslant N;$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2010 #1B] Picking Up Chicks", "background": null, "description": "一群小鸡沿着一条笔直狭窄的道路向东奔跑。每只小鸡都以自己的恒定速度奔跑。当一只小鸡追上前面的小鸡时，它必须减速并以前面小鸡的速度跟随。你驾驶着一辆移动起重机在小鸡群后面，驱赶小鸡们朝着道路尽头的谷仓前进。起重机的机械臂可以瞬间将任意一只小鸡提起，让紧跟在它后面的小鸡从下面穿过，然后再把被提起的小鸡放回原位。这个操作是瞬时完成的，并且只能对相邻的两只小鸡进行，即使有三只或更多小鸡连续排成一排，也只能让其中一只通过。每次交换都计为一次操作。\n\n给定每只小鸡在时间 $0$ 时的位置（$X_i$）和自然速度（$V_i$），以及谷仓的位置（$B$），请你计算，至少有 $K$ 只小鸡能在不晚于时间 $T$ 到达谷仓，所需的最少交换次数。如果无法实现，输出 \"IMPOSSIBLE\"。\n\n你可以将小鸡视为在一条直线上移动的点。即使有三只或更多小鸡在同一位置且相邻，提起其中一只也只能让另外一只通过。每次交换是瞬时的，这意味着你可以同时进行多次交换，但每次都单独计数。", "inputFormat": "输入的第一行是测试用例数 $C$。接下来有 $C$ 组测试数据。每组测试数据的第一行为四个整数 $N$、$K$、$B$ 和 $T$。下一行包含 $N$ 个递增的整数 $X_i$。再下一行包含 $N$ 个整数 $V_i$。所有距离单位为米，速度单位为米每秒，时间单位为秒。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #$x$: $S$\"，其中 $x$ 是测试用例编号（从 1 开始），$S$ 是所需的最小交换次数，或者是单词 \"IMPOSSIBLE\"。", "hint": "**限制条件**\n\n- $1 \\leqslant C \\leqslant 100$；\n- $1 \\leqslant B \\leqslant 1,000,000,000$；\n- $1 \\leqslant T \\leqslant 1,000$；\n- $0 \\leqslant X_i < B$；\n- $1 \\leqslant V_i \\leqslant 100$；\n- 所有 $X_i$ 均不同且递增。\n\n**小数据范围（13 分，测试集 1 - 可见）**\n\n- $1 \\leqslant N \\leqslant 10$；\n- $0 \\leqslant K \\leqslant \\min(3, N)$；\n\n**大数据范围（17 分，测试集 2 - 隐藏）**\n\n- $1 \\leqslant N \\leqslant 50$；\n- $0 \\leqslant K \\leqslant N$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
