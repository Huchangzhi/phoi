{"pid": "P1581", "type": "P", "difficulty": 2, "samples": [["1,0+2,1", "1,0,1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串", "高精度", "素数判断,质数,筛法"], "title": "A+B Problem（升级版）", "background": "小明这在写作业，其中有一道 A+B Problem，他想啊想啊想，就是想不出来，于是就找到了会编程的你......", "description": "这里的 $A+B$ 是很奇特的。它是按质数的顺序来进位的。例如：$1,0+2,1$ ＝ $1,0,1$（用 $\\verb!,!$ 来分隔每一位）。个位是 $2$ 进制，十位是 $3$ 进制，百位是 $5$ 进制，千位是 $7$ 进制，万位是 $11$ 进制……两个加数的最高位是万位（万位可能有两位）。", "inputFormat": "输入一个形如 $1,0+2,1$ 字符串 $s$。", "outputFormat": "输出相加后的结果。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "A+B Problem (Upgraded Version)", "background": "Xiao Ming is doing his homework. There is an A+B Problem he cannot figure out, so he turns to you, a programmer, for help.", "description": "Here, $A+B$ works in a peculiar way. Carries follow the sequence of prime bases. For example: $1,0+2,1$ = $1,0,1$ (using $\\verb!,!$ to separate each digit). The units place uses base 2, the tens place uses base 3, the hundreds place uses base 5, the thousands place uses base 7, the ten-thousands place uses base 11, and so on. The highest place of the two addends is the ten-thousands place (the digit at this place may have two decimal digits, e.g., 10).", "inputFormat": "Input a string $s$ of the form $1,0+2,1$.", "outputFormat": "Output the result of the addition.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "A+B Problem（升级版）", "background": "小明这在写作业，其中有一道 A+B Problem，他想啊想啊想，就是想不出来，于是就找到了会编程的你......", "description": "这里的 $A+B$ 是很奇特的。它是按质数的顺序来进位的。例如：$1,0+2,1$ ＝ $1,0,1$（用 $\\verb!,!$ 来分隔每一位）。个位是 $2$ 进制，十位是 $3$ 进制，百位是 $5$ 进制，千位是 $7$ 进制，万位是 $11$ 进制……两个加数的最高位是万位（万位可能有两位）。", "inputFormat": "输入一个形如 $1,0+2,1$ 字符串 $s$。", "outputFormat": "输出相加后的结果。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P1582", "type": "P", "difficulty": 3, "samples": [["3 1\n", "1\n"], ["13 2", "3"], ["1000000 5", "15808"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["枚举", "进制"], "title": "倒水", "background": "", "description": "一天，CC 买了 $N$ 个容量可以认为是无限大的瓶子，开始时每个瓶子里有 $1$ 升水。接着 CC 发现瓶子实在太多了，于是他决定保留不超过 $K$ 个瓶子。每次他选择两个当前含水量相同的瓶子，把一个瓶子的水全部倒进另一个里，然后把空瓶丢弃。（不能丢弃有水的瓶子）\n\n显然在某些情况下 CC 无法达到目标，比如 $N = 3$、$K = 1$。此时 CC 会重新买一些新的瓶子（新瓶子容量无限，开始时有 $1$ 升水），以达到目标。\n\n现在 CC 想知道，最少需要买多少新瓶子才能达到目标呢？\n", "inputFormat": "一行两个正整数 $N, K$（$1 \\le N \\le 2 \\times 10^9$，$K \\le 1000$）。", "outputFormat": "一个非负整数，表示最少需要买多少新瓶子。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Pouring Water", "background": "", "description": "One day, CC bought $N$ bottles with effectively infinite capacity, each initially containing $1$ liter of water. Then CC found there were too many bottles, so he decided to keep at most $K$ bottles. Each time, he chooses two bottles that currently contain the same amount of water, pours all the water from one into the other, and then discards the empty bottle. (He cannot discard a bottle that still contains water.)\n\nObviously, in some cases CC cannot achieve the goal, for example, $N = 3$, $K = 1$. In this case, CC will buy some new bottles (the new bottles have infinite capacity and initially contain $1$ liter of water) to achieve the goal.\n\nNow CC wants to know the minimum number of new bottles he needs to buy to achieve the goal.", "inputFormat": "One line containing two positive integers $N, K$ ($1 \\le N \\le 2 \\times 10^9$, $K \\le 1000$).", "outputFormat": "A non-negative integer indicating the minimum number of new bottles required.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "倒水", "background": "", "description": "一天，CC 买了 $N$ 个容量可以认为是无限大的瓶子，开始时每个瓶子里有 $1$ 升水。接着 CC 发现瓶子实在太多了，于是他决定保留不超过 $K$ 个瓶子。每次他选择两个当前含水量相同的瓶子，把一个瓶子的水全部倒进另一个里，然后把空瓶丢弃。（不能丢弃有水的瓶子）\n\n显然在某些情况下 CC 无法达到目标，比如 $N = 3$、$K = 1$。此时 CC 会重新买一些新的瓶子（新瓶子容量无限，开始时有 $1$ 升水），以达到目标。\n\n现在 CC 想知道，最少需要买多少新瓶子才能达到目标呢？\n", "inputFormat": "一行两个正整数 $N, K$（$1 \\le N \\le 2 \\times 10^9$，$K \\le 1000$）。", "outputFormat": "一个非负整数，表示最少需要买多少新瓶子。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1583", "type": "P", "difficulty": 2, "samples": [["10 10\n1 2 3 4 5 6 7 8 9 10\n2 4 6 8 10 12 14 16 18 20\n", "10 9 8 7 6 5 4 3 2 1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "排序"], "title": "魔法照片", "background": "", "description": "一共有 $n$ 个人（以 $1\\sim n$ 编号）向佳佳要照片，而佳佳只能把照片给其中的 $k$ 个人。佳佳按照与他们的关系好坏的程度给每个人赋予了一个初始权值 $W_i$。然后将初始权值从大到小进行排序，每人就有了一个序号 $D_i$（取值同样是 $1\\sim n$）。按照这个序号对 $10$ 取模的值将这些人分为 $10$ 类。也就是说定义每个人的类别序号 $C_i$ 的值为 $(D_i-1)\\bmod 10 +1$，显然类别序号的取值为 $1 \\sim 10$。第 $i$ 类的人将会额外得到 $E_i$ 的权值。你需要做的就是求出加上额外权值以后，最终的权值最大的 $k$ 个人，并输出他们的编号。**在排序中，如果两人的 $E_i$ 相同，编号小的优先。**", "inputFormat": "第一行输入用空格隔开的两个整数，分别是 $n$ 和 $k$。\n\n第二行给出了 $10$ 个正整数，分别是 $E_1\\sim E_{10}$。\n\n第三行给出了 $n$ 个正整数，第 $i$ 个数表示编号为  $i$ 的人的权值 $W_i$。", "outputFormat": "只需输出一行用空格隔开的 $k$ 个整数，分别表示最终的 $W_i$ 从高到低的人的编号。", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 20000$，$1\\leq k\\leq n$，保证所有数据均在 `int` 范围之内。", "locale": "zh-CN", "translations": {"en": {"title": "Magic Photos", "background": "", "description": "There are $n$ people (numbered $1 \\sim n$) asking Jiajia for photos, but Jiajia can only give photos to $k$ of them. Jiajia assigns each person an initial weight $W_i$ based on how close they are. Then she sorts the initial weights in descending order, and each person gets a rank $D_i$ (also taking values $1 \\sim n$). When determining $D_i$, if two people have the same $W_i$, the one with the smaller index comes first.\n\nAccording to the rank modulo $10$, these people are divided into $10$ categories. Specifically, define each person’s category index $C_i$ as $(D_i-1)\\bmod 10 + 1$, so $C_i$ takes values $1 \\sim 10$. People in category $i$ receive an extra weight $E_i$.\n\nLet the final weight be $F_i = W_i + E_{C_i}$. Your task is to find the $k$ people with the largest final weights and output their indices. In the final sorting, if two people have the same $F_i$, the one with the smaller index comes first.", "inputFormat": "- The first line contains two integers separated by a space: $n$ and $k$.\n- The second line contains $10$ positive integers: $E_1 \\sim E_{10}$.\n- The third line contains $n$ positive integers, where the $i$-th number is the weight $W_i$ of the person with index $i$.", "outputFormat": "Output one line with $k$ integers separated by spaces: the indices of the people with the highest to lowest final weights $F_i$.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\leq n \\leq 20000$, $1 \\leq k \\leq n$. All values are guaranteed to fit in the range of `int`.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "魔法照片", "background": "", "description": "一共有 $n$ 个人（以 $1\\sim n$ 编号）向佳佳要照片，而佳佳只能把照片给其中的 $k$ 个人。佳佳按照与他们的关系好坏的程度给每个人赋予了一个初始权值 $W_i$。然后将初始权值从大到小进行排序，每人就有了一个序号 $D_i$（取值同样是 $1\\sim n$）。按照这个序号对 $10$ 取模的值将这些人分为 $10$ 类。也就是说定义每个人的类别序号 $C_i$ 的值为 $(D_i-1)\\bmod 10 +1$，显然类别序号的取值为 $1 \\sim 10$。第 $i$ 类的人将会额外得到 $E_i$ 的权值。你需要做的就是求出加上额外权值以后，最终的权值最大的 $k$ 个人，并输出他们的编号。**在排序中，如果两人的 $E_i$ 相同，编号小的优先。**", "inputFormat": "第一行输入用空格隔开的两个整数，分别是 $n$ 和 $k$。\n\n第二行给出了 $10$ 个正整数，分别是 $E_1\\sim E_{10}$。\n\n第三行给出了 $n$ 个正整数，第 $i$ 个数表示编号为  $i$ 的人的权值 $W_i$。", "outputFormat": "只需输出一行用空格隔开的 $k$ 个整数，分别表示最终的 $W_i$ 从高到低的人的编号。", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 20000$，$1\\leq k\\leq n$，保证所有数据均在 `int` 范围之内。", "locale": "zh-CN"}}}
{"pid": "P1584", "type": "P", "difficulty": 5, "samples": [["6 4 5\n1 3 3 2 2 1\n2 3 1 4 5 2", "21"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索"], "title": "魔杖", "background": "", "description": "Smart 在春游时意外地得到了一种好东西——一种非常珍贵的树枝。这些树枝可以用来做优质的魔杖！\n\n选择怎样的切割方式来制作魔杖非常重要，关键问题是——一把魔杖既不能太长、又不能太短，且制作出来的魔杖不能有冲突……\n\nSmart 得到的这些树枝在属性上完全相同。每一根树枝都有 $n$ 段（用 $1$~ $n$ 编号），给定了每段的长度 $l$ 和每段的魔力值 $m$ 。你可以做的就是选择一段或连续的几段，把它们作为一个整体切下来，再用来制作魔杖。但是一根魔杖的长度不能太长，不能大于给定的值 $h$；也不能太短，不能小于给定的值 $low$ 。\n\n魔杖有一个奇怪的要求：如果某一根魔杖的制作材料是另一根魔杖的一部分，则这两根魔杖之间将发生冲突。比如说树枝有三段，从左到右的长度分别为 $4$ 、 $1$ 、 $3$ ，Smart需要长度为 $4$ 到 $5$ 之间的魔杖。他可以用一根树枝的前两段做出一个长度为 $5$ 的魔杖，用一根树枝的后两段做出长度为 $4$ 的魔杖；但他决不能用一根树枝的前两段做了魔杖后再单独使用另一根树枝的第一段做成魔杖，因为前者包含了后者的所有成分，这会导致冲突。\n\n我们假设 Smart 可以得到任意多这样的树枝。 Smart 需要制作出若干个互不冲突的魔杖，使所有魔杖的魔力值之和最大。（魔杖的长度就是组成它的那些段的长度的总和，魔力值亦然）。", "inputFormat": "第一行有三个用空格隔开的整数，分别表示 $n$、$low$、$h$。\n\n第二行有 $n$ 个用空格隔开的整数，第 $i$ 个整数代表 $l_i$ 。\n\n第三行有 $n$ 个用空格隔开的整数，第 $i$ 个整数代表 $m_i$。", "outputFormat": "输出一行一个整数，表示能够获得的魔力值的最大值。", "hint": "#### 样例输入输出 1 解释\n\n取 $[1$  $3]$ $[3$ $2]$ $[2$ $2$ $1]$ 做成魔杖，得到最大权值 $2+3+1+4+4+5+2=21$ 。\n\n---\n\n#### 数据规模与约定\n\n对于$100\\%$的数据，保证：\n- $1\\le n\\le 1000$，$1\\le low\\le h < 2^{31}$。\n- $1 \\leq l_i, m_i \\le 10^5$", "locale": "zh-CN", "translations": {"en": {"title": "Wand", "background": "", "description": "On a spring outing, Smart accidentally obtained something good — some very precious branches. These branches can be used to make high-quality wands.\n\nChoosing how to cut to make the wands is crucial. The key is: a wand can be neither too long nor too short, and the wands produced must not conflict.\n\nThe branches Smart obtained are identical in their properties. Each branch has $n$ segments (numbered from $1$ to $n$). The length $l$ and the magic value $m$ of each segment are given. You may choose one segment or a consecutive block of segments, cut them off as a whole, and use that as a wand. However, the length of a wand must not be too long — it must not exceed $h$; and it must not be too short — it must not be less than $low$. In other words, the length must be between $low$ and $h$ inclusive.\n\nThere is a strange rule for wands: if the material used for one wand is a part of the material used for another wand, then these two wands conflict. For example, suppose a branch has three segments, and from left to right their lengths are $4$, $1$, $3$. Smart needs wands with lengths between $4$ and $5$. He can use the first two segments of a branch to make a wand of length $5$, and use the last two segments to make a wand of length $4$; but he must never use the first two segments to make a wand and then separately use only the first segment of another branch to make a wand, because the former contains all the components of the latter, which would cause a conflict.\n\nAssume Smart has access to an unlimited number of such branches. Smart needs to produce several pairwise non-conflicting wands so that the sum of the magic values of all wands is maximized. (The length of a wand is the sum of the lengths of the segments that form it, and its magic value is the sum of the magic values likewise.)", "inputFormat": "The first line contains three integers separated by spaces, representing $n$, $low$, and $h$.\n\nThe second line contains $n$ integers separated by spaces; the $i$-th integer is $l_i$.\n\nThe third line contains $n$ integers separated by spaces; the $i$-th integer is $m_i$.", "outputFormat": "Output a single integer on one line, the maximum total magic value that can be obtained.", "hint": "#### Explanation for Sample Input/Output 1\n\nChoose $[1\\ 3]$ $[3\\ 2]$ $[2\\ 2\\ 1]$ to make wands, obtaining the maximum total weight $2+3+1+4+4+5+2=21$。\n\n---\n\n#### Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that:\n- $1 \\le n \\le 1000$, $1 \\le low \\le h < 2^{31}$.\n- $1 \\le l_i, m_i \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "魔杖", "background": "", "description": "Smart 在春游时意外地得到了一种好东西——一种非常珍贵的树枝。这些树枝可以用来做优质的魔杖！\n\n选择怎样的切割方式来制作魔杖非常重要，关键问题是——一把魔杖既不能太长、又不能太短，且制作出来的魔杖不能有冲突……\n\nSmart 得到的这些树枝在属性上完全相同。每一根树枝都有 $n$ 段（用 $1$~ $n$ 编号），给定了每段的长度 $l$ 和每段的魔力值 $m$ 。你可以做的就是选择一段或连续的几段，把它们作为一个整体切下来，再用来制作魔杖。但是一根魔杖的长度不能太长，不能大于给定的值 $h$；也不能太短，不能小于给定的值 $low$ 。\n\n魔杖有一个奇怪的要求：如果某一根魔杖的制作材料是另一根魔杖的一部分，则这两根魔杖之间将发生冲突。比如说树枝有三段，从左到右的长度分别为 $4$ 、 $1$ 、 $3$ ，Smart需要长度为 $4$ 到 $5$ 之间的魔杖。他可以用一根树枝的前两段做出一个长度为 $5$ 的魔杖，用一根树枝的后两段做出长度为 $4$ 的魔杖；但他决不能用一根树枝的前两段做了魔杖后再单独使用另一根树枝的第一段做成魔杖，因为前者包含了后者的所有成分，这会导致冲突。\n\n我们假设 Smart 可以得到任意多这样的树枝。 Smart 需要制作出若干个互不冲突的魔杖，使所有魔杖的魔力值之和最大。（魔杖的长度就是组成它的那些段的长度的总和，魔力值亦然）。", "inputFormat": "第一行有三个用空格隔开的整数，分别表示 $n$、$low$、$h$。\n\n第二行有 $n$ 个用空格隔开的整数，第 $i$ 个整数代表 $l_i$ 。\n\n第三行有 $n$ 个用空格隔开的整数，第 $i$ 个整数代表 $m_i$。", "outputFormat": "输出一行一个整数，表示能够获得的魔力值的最大值。", "hint": "#### 样例输入输出 1 解释\n\n取 $[1$  $3]$ $[3$ $2]$ $[2$ $2$ $1]$ 做成魔杖，得到最大权值 $2+3+1+4+4+5+2=21$ 。\n\n---\n\n#### 数据规模与约定\n\n对于$100\\%$的数据，保证：\n- $1\\le n\\le 1000$，$1\\le low\\le h < 2^{31}$。\n- $1 \\leq l_i, m_i \\le 10^5$", "locale": "zh-CN"}}}
{"pid": "P1585", "type": "P", "difficulty": 5, "samples": [["2 2 2 2\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "剪枝"], "title": "魔法阵", "background": "", "description": "魔法阵是一个 $n \\times m$ 的格子（高 $n$，宽 $m$），$n \\times m$ 为偶数。Smart 手中有 $n \\times m$ 个宝石（以 $1 \\sim n \\times m$ 编号）。Smart 从最右上角的格子开始走，从一个格子可以走到上、下、左、右 $4$ 个相邻的格子，但不能走出边界。每个格子必须且仅能到过 $1$ 次，这样 Smart 一共走了 $n \\times m$ 个格子停止（随便停哪里）。Smart 每进入一个格子，就在该格子里放入一颗宝石。他是按顺序放的，也就是说——第 $i$ 个进入的格子放入 $i$ 号宝石。\n\n如果两颗宝石的编号对 $\\frac{n \\times m}{2}$ 取模的值相同，则认为这两颗宝石相互之间有微妙的影响。也就是说，我们按照宝石的编号对 $\\frac{n \\times m}{2}$ 取模的值，将宝石分成 $\\frac{n \\times m}{2}$ 对，其中每对都恰有两颗宝石。对于每一对宝石，设第一颗宝石在第 $a$ 行第 $b$ 列，另一颗宝石在第 $c$ 行第 $d$ 列，那么定义这 $2$ 个宝石的魔力影响值为 $k_1 \\times \\lvert a - c \\rvert + k_2 \\times \\lvert b - d \\rvert$。\n\n需要你求出的是，在所有合乎题意的宝石摆放方案中，所有成对的宝石间的最大魔力影响值的最小值为多少。换句话说，如果我们定义对 $\\frac{n \\times m}{2}$ 取模的值为 $i$ 的一对宝石的魔力影响值为 $a_i$。你需要求出的就是 $\\max \\{ a_i : i=0,1,2,\\ldots \\}$ 的最小值。\n", "inputFormat": "只有一行用空格隔开的四个整数，分别是 $n, m, k_1, k_2$。\n", "outputFormat": "只需输出一个整数，即题目所要求的“所有成对的宝石间的最大魔力影响值的最小值”。\n", "hint": "对于 $100\\%$ 的数据，$n \\times m \\le 50$，$1 \\le k_1, k_2 \\le 32767$。", "locale": "zh-CN", "translations": {"en": {"title": "Magic Grid", "background": "", "description": "A magic grid is an $n \\times m$ grid (height $n$, width $m$), where $n \\times m$ is even. Smart has $n \\times m$ gems (numbered $1 \\sim n \\times m$). Smart starts from the top-right cell. From a cell, he can move to the $4$ adjacent cells up, down, left, and right, but he cannot go out of bounds. Each cell must be visited exactly once, so Smart visits $n \\times m$ cells in total and stops anywhere. Every time Smart enters a cell, he places one gem in that cell. He places them in order; that is, the $i$-th visited cell receives gem $i$.\n\nIf two gems have the same value when their indices are taken modulo $\\frac{n \\times m}{2}$, then these two gems have a subtle influence on each other. In other words, by taking gem indices modulo $\\frac{n \\times m}{2}$, we partition the gems into $\\frac{n \\times m}{2}$ pairs, each containing exactly two gems. For each pair of gems, suppose the first gem is at row $a$, column $b$, and the other is at row $c$, column $d$. Then the influence value of these two gems is defined as $k_1 \\times \\lvert a - c \\rvert + k_2 \\times \\lvert b - d \\rvert$.\n\nYou need to find, among all valid placement schemes, the minimum possible value of the maximum influence among all paired gems. In other words, if we define the influence value of the pair with remainder $i$ modulo $\\frac{n \\times m}{2}$ as $a_i$, you need to find the minimum possible value of $\\max \\{ a_i : i=0,1,2,\\ldots \\}$.", "inputFormat": "One line containing four integers separated by spaces: n, m, k1, k2.", "outputFormat": "Output a single integer: the required minimum possible value of the maximum influence among all paired gems.", "hint": "For $100\\%$ of the testdata, $n \\times m \\le 50$, $1 \\le k_1, k_2 \\le 32767$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "魔法阵", "background": "", "description": "魔法阵是一个 $n \\times m$ 的格子（高 $n$，宽 $m$），$n \\times m$ 为偶数。Smart 手中有 $n \\times m$ 个宝石（以 $1 \\sim n \\times m$ 编号）。Smart 从最右上角的格子开始走，从一个格子可以走到上、下、左、右 $4$ 个相邻的格子，但不能走出边界。每个格子必须且仅能到过 $1$ 次，这样 Smart 一共走了 $n \\times m$ 个格子停止（随便停哪里）。Smart 每进入一个格子，就在该格子里放入一颗宝石。他是按顺序放的，也就是说——第 $i$ 个进入的格子放入 $i$ 号宝石。\n\n如果两颗宝石的编号对 $\\frac{n \\times m}{2}$ 取模的值相同，则认为这两颗宝石相互之间有微妙的影响。也就是说，我们按照宝石的编号对 $\\frac{n \\times m}{2}$ 取模的值，将宝石分成 $\\frac{n \\times m}{2}$ 对，其中每对都恰有两颗宝石。对于每一对宝石，设第一颗宝石在第 $a$ 行第 $b$ 列，另一颗宝石在第 $c$ 行第 $d$ 列，那么定义这 $2$ 个宝石的魔力影响值为 $k_1 \\times \\lvert a - c \\rvert + k_2 \\times \\lvert b - d \\rvert$。\n\n需要你求出的是，在所有合乎题意的宝石摆放方案中，所有成对的宝石间的最大魔力影响值的最小值为多少。换句话说，如果我们定义对 $\\frac{n \\times m}{2}$ 取模的值为 $i$ 的一对宝石的魔力影响值为 $a_i$。你需要求出的就是 $\\max \\{ a_i : i=0,1,2,\\ldots \\}$ 的最小值。\n", "inputFormat": "只有一行用空格隔开的四个整数，分别是 $n, m, k_1, k_2$。\n", "outputFormat": "只需输出一个整数，即题目所要求的“所有成对的宝石间的最大魔力影响值的最小值”。\n", "hint": "对于 $100\\%$ 的数据，$n \\times m \\le 50$，$1 \\le k_1, k_2 \\le 32767$。", "locale": "zh-CN"}}}
{"pid": "P1586", "type": "P", "difficulty": 3, "samples": [["1\n2003", "48"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "数学", "枚举"], "title": "四方定理", "background": null, "description": "四方定理是众所周知的：任意一个正整数 $n$，可以分解为不超过四个整数的平方和。例如：$25=1^{2}+2^{2}+2^{2}+4^{2}$，当然还有其他的分解方案，$25=4^{2}+3^{2}$ 和 $25=5^{2}$。给定的正整数 $n$，编程统计它能分解的方案总数。注意：$25=4^{2}+3^{2}$ 和 $25=3^{2}+4^{2}$ 视为一种方案。", "inputFormat": "第一行为正整数 $t(1 \\le t \\le 100)$，接下来 $t$ 行，每行一个正整数 $n(1 \\le n \\le 32768)$。", "outputFormat": "对于每个正整数 $n$，输出方案总数。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "Four-Square Theorem", "background": "", "description": "The four-square theorem is well known: any positive integer $n$ can be written as a sum of at most four squares of integers. For example: $25=1^{2}+2^{2}+2^{2}+4^{2}$, and there are other representations as well, $25=4^{2}+3^{2}$ and $25=5^{2}$. Given a positive integer $n$, write a program to count the total number of its representations. Note: $25=4^{2}+3^{2}$ and $25=3^{2}+4^{2}$ are considered the same representation.", "inputFormat": "The first line contains a positive integer $t(1 \\le t \\le 100)$, followed by $t$ lines, each containing a positive integer $n(1 \\le n \\le 32768)$.", "outputFormat": "For each positive integer $n$, output the total number of representations.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "四方定理", "background": null, "description": "四方定理是众所周知的：任意一个正整数 $n$，可以分解为不超过四个整数的平方和。例如：$25=1^{2}+2^{2}+2^{2}+4^{2}$，当然还有其他的分解方案，$25=4^{2}+3^{2}$ 和 $25=5^{2}$。给定的正整数 $n$，编程统计它能分解的方案总数。注意：$25=4^{2}+3^{2}$ 和 $25=3^{2}+4^{2}$ 视为一种方案。", "inputFormat": "第一行为正整数 $t(1 \\le t \\le 100)$，接下来 $t$ 行，每行一个正整数 $n(1 \\le n \\le 32768)$。", "outputFormat": "对于每个正整数 $n$，输出方案总数。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P1587", "type": "P", "difficulty": 7, "samples": [["2 6 10", "4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "2016", "NOI", "O2优化", "莫比乌斯反演"], "title": "[NOI2016] 循环之美", "background": "", "description": "牛牛是一个热爱算法设计的高中生。在他设计的算法中，常常会使用带小数的数进行计算。牛牛认为，如果在 $k$ 进制下，一个数的小数部分是纯循环的，那么它就是美的。现在，牛牛想知道：对于已知的十进制数 $n$ 和 $m$，在 $k$ 进制下，有多少个数值上互不相等的纯循环小数，可以用分数 $\\frac xy$ 表示,其中 $1≤x≤n,1≤y≤m$，且 $x,y$ 是整数。一个数是纯循环的，当且仅当其可以写成以下形式：\n\n$$a.\\dot{c_1} c_2 c_3 \\dots c_{p - 1} \\dot{c_p}$$\n\n其中，$a$ 是一个整数，$p≥1$；对于 $1≤i≤p$，$c_i$ 是 $k$ 进制下的一位数字。\n\n例如，在十进制下，$0.45454545……=0.\\dot {4} \\dot {5}$ 是纯循环的，它可以用 $\\frac {5}{11}$、$\\frac{10}{22}$ 等分数表示；在十进制下，$0.1666666……=0.1\\dot6$ 则不是纯循环的，它可以用 $\\frac 16$ 等分数表示。需要特别注意的是，我们认为一个整数是纯循环的，因为它的小数部分可以表示成 $0$ 的循环或是 $k-1$ 的循环；而一个小数部分非 $0$ 的有限小数不是纯循环的。", "inputFormat": "只有一行，包含三个十进制数 $N,M,K$ 意义如题所述。\n\n\n", "outputFormat": "一行一个整数，表示满足条件的美的数的个数。\n", "hint": "### 样例解释\n\n满足条件的数分别是：\n\n$\\frac 11=1.0000\\ldots$\n\n$\\frac 13=0.3333\\ldots$\n\n$\\frac 21=2.0000\\ldots$\n\n$\\frac 23=0.6666\\ldots$\n\n$\\frac 11$ 和 $\\frac 22$ 虽然都是纯循环小数，但因为它们相等，因此只计数一次；同样，$\\frac 13$ 和 $\\frac 26$ 也只计数一次。\n\n### 数据范围\n\n对于所有的测试点，保证 $1\\leq n\\leq 10^9$，$1\\leq m \\leq 10^9$，$2\\leq k \\leq 2\\times 10^3 $。\n\n对于每个测试点，有以下约束（其中留空的表示没有特殊的约束）：\n\n::cute-table{tuack}\n\n| 测试点编号 |         $n$         |     $m$     |     $k$     |\n| :--------: | :-----------------: | :---------: | :---------: |\n|    $1$     |      $\\leq 10$      |  $\\leq 20$  |    $=2$     |\n|    $2$     |     $\\leq 100$      | $\\leq 10^4$ |    ^     |\n|    $3$     |     $\\leq 10^3$     |             |    ^     |\n|    $4$     |     $\\leq 10^4$     |             |    ^     |\n|    $5$     |      $\\leq 10$      |  $\\leq 20$  |    $=3$     |\n|    $6$     |     $\\leq 100$      | $\\leq 10^4$ |    ^     |\n|    $7$     |     $\\leq 10^3$     |             |    ^     |\n|    $8$     |     $\\leq 10^4$     |             |    ^     |\n|    $9$     |      $\\leq 10$      |  $\\leq 20$  | $\\leq 100$  |\n|    $10$    |     $\\leq 100$      | $\\leq 10^4$ | ^  |\n|    $11$    |     $\\leq 10^3$     |             | $\\leq 10^3$ |\n|    $12$    |     $\\leq 10^4$     |             |             |\n|    $13$    |     $\\leq 10^5$     | $\\leq 10^8$ | $\\leq 100$  |\n|    $14$    | $\\leq 2\\times 10^5$ |             | $\\leq 10^3$ |\n|    $15$    | $\\leq 5\\times10^5$  |             |             |\n|    $16$    |     $\\leq 10^6$     | $\\leq 10^8$ | $\\leq 100$  |\n|    $17$    | $\\leq 2\\times 10^6$ |             | $\\leq 10^3$ |\n|    $18$    | $\\leq 5\\times 10^6$ |             |             |\n|    $19$    |     $\\leq 10^7$     | $\\leq 10^8$ |    $100$    |\n|    $20$    | $\\leq 2\\times10^7$  |             | $\\leq 10^3$ |\n|    $21$    | ^  |             |             |\n|    $22$    |     $\\leq 10^8$     | $\\leq 10^8$ |             |\n|    $23$    |     ^     | ^ |             |\n|  $24,25$   |                     |             |             |\n\n \n### 提示\n\n这部分将提供一个将分数化为对应的小数的方法，如果你已经熟悉这个方法，你不必阅读本提示。\n\n分数可以通过除法，用分子除以分母化为对应的小数。有些分数在除法过程中无法除尽,这样的分数在不断进行的除法过程中余数一定会重复出现。从商数的个位所对应的余数起，设第一次重复出现的余数前两次出现的位置所对应的商数位分别是小数点后第 $a$ 位和小数点后第 $b$ 位（特殊地：如果其中一个对应的商数位是个位，则认为 $a=0$；不妨设 $a<b$），则其循环部分可以用小数点后第 $a+1$ 位到小数点后第 $b$ 位的循环来表示。\n\n例如：在十进制下，将 $\\frac 5{11}$ 转化为小数时，个位开始的商数依次为 $4,5,4,\\ldots$，对应的余数分别为 $6,5,6,\\ldots$。余数第一次重复出现的位置是个位和小数点后第 $2$ 位,那么 $a=0,b=2$。\n\n$a=0,b=2$ 即其循环部分可以用小数点第 $1$ 位到第 $3$ 位来表示。表示为：$\\frac 5{11}=0.45454545\\ldots=0.\\dot4\\dot5$。\n\n在十进制下，将 $\\frac 16$ 转化为小数时,个位开始的商数依次为 $1,6,6,\\ldots$，对应的余数分别为 $4,4,4,\\ldots$。余数第一次重复出现的位置是小数点后第 $1$ 位和小数点后第 $2$ 位,即其循环部分可以用小数点后第 $2$ 位来表示。表示为：$\\frac 16=0.1666……=0.1\\dot6$。\n\n需要注意的是：商数重复出现并不代表进入了循环节。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2016] The Beauty of Cycles", "background": "", "description": "Niuniu (Niúniú) is a high school student who loves algorithm design. In his algorithms, he often performs computations with numbers that have fractional parts. Niuniu considers a number beautiful if, in base $k$, its fractional part is purely repeating. Now, given decimal numbers $n$ and $m$, he wants to know: in base $k$, how many numerically distinct purely repeating fractions can be written as a fraction $\\frac x y$, where $1 \\leq x \\leq n$, $1 \\leq y \\leq m$, and $x, y$ are integers. A number is purely repeating if and only if it can be written in the following form:\n\n$$a.\\dot{c_1} c_2 c_3 \\dots c_{p - 1} \\dot{c_p}$$\n\nHere, $a$ is an integer, $p \\geq 1$; for $1 \\leq i \\leq p$, $c_i$ is a single digit in base $k$.\n\nFor example, in base 10, $0.45454545... = 0.\\dot {4} \\dot {5}$ is purely repeating; it can be represented by fractions such as $\\frac {5}{11}$ or $\\frac{10}{22}$. In base 10, $0.1666666... = 0.1\\dot6$ is not purely repeating; it can be represented by $\\frac 1 6$. Note that we consider an integer to be purely repeating, because its fractional part can be represented as a repeating $0$ or a repeating $k - 1$; however, a finite fraction with a nonzero fractional part is not purely repeating.", "inputFormat": "One line containing three decimal integers $N, M, K$ as described.", "outputFormat": "Output a single integer on one line, the number of beautiful numbers that satisfy the conditions.", "hint": "### Sample Explanation\n\nThe numbers that satisfy the conditions are:\n\n$\\frac 1 1 = 1.0000...$\n\n$\\frac 1 3 = 0.3333...$\n\n$\\frac 2 1 = 2.0000...$\n\n$\\frac 2 3 = 0.6666...$\n\nAlthough $\\frac 1 1$ and $\\frac 2 2$ are both purely repeating decimals, they are equal, so they are counted only once; similarly, $\\frac 1 3$ and $\\frac 2 6$ are counted only once.\n\n### Constraints\n\nFor all test points, it is guaranteed that $1 \\leq n \\leq 10^9$, $1 \\leq m \\leq 10^9$, $2 \\leq k \\leq 2 \\times 10^3$.\n\nFor each test point, the following constraints hold (a blank entry means no special constraint):\n\n::cute-table{tuack}\n\n| Test point ID |         $n$         |     $m$     |     $k$     |\n| :-----------: | :-----------------: | :---------: | :---------: |\n|      $1$      |      $\\leq 10$      |  $\\leq 20$  |    $=2$     |\n|      $2$      |     $\\leq 100$      | $\\leq 10^4$ |    ^     |\n|      $3$      |     $\\leq 10^3$     |             |    ^     |\n|      $4$      |     $\\leq 10^4$     |             |    ^     |\n|      $5$      |      $\\leq 10$      |  $\\leq 20$  |    $=3$     |\n|      $6$      |     $\\leq 100$      | $\\leq 10^4$ |    ^     |\n|      $7$      |     $\\leq 10^3$     |             |    ^     |\n|      $8$      |     $\\leq 10^4$     |             |    ^     |\n|      $9$      |      $\\leq 10$      |  $\\leq 20$  | $\\leq 100$  |\n|     $10$      |     $\\leq 100$      | $\\leq 10^4$ | ^  |\n|     $11$      |     $\\leq 10^3$     |             | $\\leq 10^3$ |\n|     $12$      |     $\\leq 10^4$     |             |             |\n|     $13$      |     $\\leq 10^5$     | $\\leq 10^8$ | $\\leq 100$  |\n|     $14$      | $\\leq 2\\times 10^5$ |             | $\\leq 10^3$ |\n|     $15$      | $\\leq 5\\times10^5$  |             |             |\n|     $16$      |     $\\leq 10^6$     | $\\leq 10^8$ | $\\leq 100$  |\n|     $17$      | $\\leq 2\\times 10^6$ |             | $\\leq 10^3$ |\n|     $18$      | $\\leq 5\\times 10^6$ |             |             |\n|     $19$      |     $\\leq 10^7$     | $\\leq 10^8$ |    $100$    |\n|     $20$      | $\\leq 2\\times10^7$  |             | $\\leq 10^3$ |\n|     $21$      | ^  |             |             |\n|     $22$      |     $\\leq 10^8$     | $\\leq 10^8$ |             |\n|     $23$      |     ^     | ^ |             |\n|   $24,25$     |                     |             |             |\n\n### Hint\n\nThis section provides a method to convert a fraction into its corresponding decimal expansion. If you are already familiar with this method, you do not need to read this part.\n\nA fraction can be converted to its corresponding decimal by division, dividing the numerator by the denominator. For some fractions, the division does not terminate; in such cases, during the ongoing division the remainder must eventually repeat. Starting from the remainder corresponding to the ones place of the quotient, suppose that for the first remainder to repeat, the positions of its two occurrences correspond to the $a$-th and $b$-th digits after the decimal point in the quotient (special case: if one of them corresponds to the ones place, take $a = 0$; assume $a < b$). Then its repeating part can be represented by the cycle from the $(a + 1)$-th digit to the $b$-th digit after the decimal point.\n\nFor example: in base 10, when converting $\\frac 5 {11}$ to a decimal, the quotient digits starting from the ones place are $4, 5, 4, \\ldots$, and the corresponding remainders are $6, 5, 6, \\ldots$. The positions of the first repeated remainder are the ones place and the $2$-nd digit after the decimal point, so $a = 0, b = 2$.\n\n$a = 0, b = 2$ means its repeating part can be represented by the cycle from the $1$-st to the $3$-rd digits after the decimal point. Thus: $\\frac 5 {11} = 0.45454545... = 0.\\dot4\\dot5$.\n\nIn base 10, when converting $\\frac 1 6$ to a decimal, the quotient digits starting from the ones place are $1, 6, 6, \\ldots$, and the corresponding remainders are $4, 4, 4, \\ldots$. The positions of the first repeated remainder are the $1$-st and $2$-nd digits after the decimal point, which means its repeating part can be represented by the $2$-nd digit after the decimal point. Thus: $\\frac 1 6 = 0.1666... = 0.1\\dot6$.\n\nNote: a repeated quotient digit does not necessarily indicate that the repeating cycle has begun.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2016] 循环之美", "background": "", "description": "牛牛是一个热爱算法设计的高中生。在他设计的算法中，常常会使用带小数的数进行计算。牛牛认为，如果在 $k$ 进制下，一个数的小数部分是纯循环的，那么它就是美的。现在，牛牛想知道：对于已知的十进制数 $n$ 和 $m$，在 $k$ 进制下，有多少个数值上互不相等的纯循环小数，可以用分数 $\\frac xy$ 表示,其中 $1≤x≤n,1≤y≤m$，且 $x,y$ 是整数。一个数是纯循环的，当且仅当其可以写成以下形式：\n\n$$a.\\dot{c_1} c_2 c_3 \\dots c_{p - 1} \\dot{c_p}$$\n\n其中，$a$ 是一个整数，$p≥1$；对于 $1≤i≤p$，$c_i$ 是 $k$ 进制下的一位数字。\n\n例如，在十进制下，$0.45454545……=0.\\dot {4} \\dot {5}$ 是纯循环的，它可以用 $\\frac {5}{11}$、$\\frac{10}{22}$ 等分数表示；在十进制下，$0.1666666……=0.1\\dot6$ 则不是纯循环的，它可以用 $\\frac 16$ 等分数表示。需要特别注意的是，我们认为一个整数是纯循环的，因为它的小数部分可以表示成 $0$ 的循环或是 $k-1$ 的循环；而一个小数部分非 $0$ 的有限小数不是纯循环的。", "inputFormat": "只有一行，包含三个十进制数 $N,M,K$ 意义如题所述。\n\n\n", "outputFormat": "一行一个整数，表示满足条件的美的数的个数。\n", "hint": "### 样例解释\n\n满足条件的数分别是：\n\n$\\frac 11=1.0000\\ldots$\n\n$\\frac 13=0.3333\\ldots$\n\n$\\frac 21=2.0000\\ldots$\n\n$\\frac 23=0.6666\\ldots$\n\n$\\frac 11$ 和 $\\frac 22$ 虽然都是纯循环小数，但因为它们相等，因此只计数一次；同样，$\\frac 13$ 和 $\\frac 26$ 也只计数一次。\n\n### 数据范围\n\n对于所有的测试点，保证 $1\\leq n\\leq 10^9$，$1\\leq m \\leq 10^9$，$2\\leq k \\leq 2\\times 10^3 $。\n\n对于每个测试点，有以下约束（其中留空的表示没有特殊的约束）：\n\n::cute-table{tuack}\n\n| 测试点编号 |         $n$         |     $m$     |     $k$     |\n| :--------: | :-----------------: | :---------: | :---------: |\n|    $1$     |      $\\leq 10$      |  $\\leq 20$  |    $=2$     |\n|    $2$     |     $\\leq 100$      | $\\leq 10^4$ |    ^     |\n|    $3$     |     $\\leq 10^3$     |             |    ^     |\n|    $4$     |     $\\leq 10^4$     |             |    ^     |\n|    $5$     |      $\\leq 10$      |  $\\leq 20$  |    $=3$     |\n|    $6$     |     $\\leq 100$      | $\\leq 10^4$ |    ^     |\n|    $7$     |     $\\leq 10^3$     |             |    ^     |\n|    $8$     |     $\\leq 10^4$     |             |    ^     |\n|    $9$     |      $\\leq 10$      |  $\\leq 20$  | $\\leq 100$  |\n|    $10$    |     $\\leq 100$      | $\\leq 10^4$ | ^  |\n|    $11$    |     $\\leq 10^3$     |             | $\\leq 10^3$ |\n|    $12$    |     $\\leq 10^4$     |             |             |\n|    $13$    |     $\\leq 10^5$     | $\\leq 10^8$ | $\\leq 100$  |\n|    $14$    | $\\leq 2\\times 10^5$ |             | $\\leq 10^3$ |\n|    $15$    | $\\leq 5\\times10^5$  |             |             |\n|    $16$    |     $\\leq 10^6$     | $\\leq 10^8$ | $\\leq 100$  |\n|    $17$    | $\\leq 2\\times 10^6$ |             | $\\leq 10^3$ |\n|    $18$    | $\\leq 5\\times 10^6$ |             |             |\n|    $19$    |     $\\leq 10^7$     | $\\leq 10^8$ |    $100$    |\n|    $20$    | $\\leq 2\\times10^7$  |             | $\\leq 10^3$ |\n|    $21$    | ^  |             |             |\n|    $22$    |     $\\leq 10^8$     | $\\leq 10^8$ |             |\n|    $23$    |     ^     | ^ |             |\n|  $24,25$   |                     |             |             |\n\n \n### 提示\n\n这部分将提供一个将分数化为对应的小数的方法，如果你已经熟悉这个方法，你不必阅读本提示。\n\n分数可以通过除法，用分子除以分母化为对应的小数。有些分数在除法过程中无法除尽,这样的分数在不断进行的除法过程中余数一定会重复出现。从商数的个位所对应的余数起，设第一次重复出现的余数前两次出现的位置所对应的商数位分别是小数点后第 $a$ 位和小数点后第 $b$ 位（特殊地：如果其中一个对应的商数位是个位，则认为 $a=0$；不妨设 $a<b$），则其循环部分可以用小数点后第 $a+1$ 位到小数点后第 $b$ 位的循环来表示。\n\n例如：在十进制下，将 $\\frac 5{11}$ 转化为小数时，个位开始的商数依次为 $4,5,4,\\ldots$，对应的余数分别为 $6,5,6,\\ldots$。余数第一次重复出现的位置是个位和小数点后第 $2$ 位,那么 $a=0,b=2$。\n\n$a=0,b=2$ 即其循环部分可以用小数点第 $1$ 位到第 $3$ 位来表示。表示为：$\\frac 5{11}=0.45454545\\ldots=0.\\dot4\\dot5$。\n\n在十进制下，将 $\\frac 16$ 转化为小数时,个位开始的商数依次为 $1,6,6,\\ldots$，对应的余数分别为 $4,4,4,\\ldots$。余数第一次重复出现的位置是小数点后第 $1$ 位和小数点后第 $2$ 位,即其循环部分可以用小数点后第 $2$ 位来表示。表示为：$\\frac 16=0.1666……=0.1\\dot6$。\n\n需要注意的是：商数重复出现并不代表进入了循环节。", "locale": "zh-CN"}}}
{"pid": "P1588", "type": "P", "difficulty": 2, "samples": [["1 \n5 17", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2007", "USACO", "广度优先搜索 BFS", "队列"], "title": "[USACO07OPEN] Catch That Cow S", "background": null, "description": "FJ 丢了一头牛，决定将其找回。FJ 和牛位于数轴上，初始位置分别为 $x$ 和 $y$，牛保持不动。每次移动时，若 FJ 处于位置 $p$，他可移动至 $p + 1$、$p - 1$ 或 $2 \\times p$。计算 FJ 抓住牛所需的最少移动次数。", "inputFormat": "第一行为一个整数 $t\\ ( 1\\le t\\le 10)$，表示数据组数；\n\n接下来每行包含一个两个正整数 $x,y\\ (0<x,y \\le 10^5)$，分别表示 FJ 和牛的坐标。", "outputFormat": "对于每组数据，输出最少步数，每组数据间用换行隔开。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[USACO07OPEN] Catch That Cow S", "background": "", "description": "FJ lost one of his cows and decided to get it back. FJ and the cow are on a number line with initial positions $x$ and $y$, and the cow stays put. In each move, if FJ is at position $p$, he can move to $p + 1$, $p - 1$, or $2 \\times p$. Compute the minimum number of moves needed for FJ to catch the cow.", "inputFormat": "The first line contains an integer $t$ ( $1 \\le t \\le 10$ ), the number of test cases.\n\nEach of the next $t$ lines contains two positive integers $x, y$ ( $0 < x, y \\le 10^5$ ), representing the coordinates of FJ and the cow, respectively.", "outputFormat": "For each test case, output the minimum number of moves.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO07OPEN] Catch That Cow S", "background": null, "description": "FJ 丢了一头牛，决定将其找回。FJ 和牛位于数轴上，初始位置分别为 $x$ 和 $y$，牛保持不动。每次移动时，若 FJ 处于位置 $p$，他可移动至 $p + 1$、$p - 1$ 或 $2 \\times p$。计算 FJ 抓住牛所需的最少移动次数。", "inputFormat": "第一行为一个整数 $t\\ ( 1\\le t\\le 10)$，表示数据组数；\n\n接下来每行包含一个两个正整数 $x,y\\ (0<x,y \\le 10^5)$，分别表示 FJ 和牛的坐标。", "outputFormat": "对于每组数据，输出最少步数，每组数据间用换行隔开。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P1589", "type": "P", "difficulty": 2, "samples": [["3 3\n1 6\n13 17\n8 12", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "贪心"], "title": "泥泞路", "background": "", "description": "暴雨过后，FJ 的农场到镇上的公路上有一些泥泞路，他有若干块长度为 $L$ 的木板可以铺在这些泥泞路上，问他至少需要多少块木板，才能把所有的泥泞路覆盖住。", "inputFormat": "第一行为正整数 $n$ 和 $L$，分别表示有多少段泥泞路和木板的长度；\n\n接下来 $n$ 行，每一行两个整数 $s$ 和 $e$，表示每一段泥泞路的起点和终点。", "outputFormat": "仅一个正整数，表示木板数。\n", "hint": "对于 $100 \\%$ 的数据，$n,L \\leq 10000$，$s \\leq e \\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "Muddy Road", "background": "", "description": "After a heavy rain, there are some muddy segments on the road from FJ's farm to the town. He has several planks, each of length $L$, that can be laid over these muddy segments. Find the minimum number of planks required to cover all the muddy segments.", "inputFormat": "The first line contains positive integers $n$ and $L$, representing the number of muddy segments and the length of a plank.\n\nThe next $n$ lines each contain two integers $s$ and $e$, representing the start and end of a muddy segment.", "outputFormat": "A single positive integer, the number of planks.", "hint": "For $100\\%$ of the testdata, $n,L \\leq 10000$, $s \\leq e \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "泥泞路", "background": "", "description": "暴雨过后，FJ 的农场到镇上的公路上有一些泥泞路，他有若干块长度为 $L$ 的木板可以铺在这些泥泞路上，问他至少需要多少块木板，才能把所有的泥泞路覆盖住。", "inputFormat": "第一行为正整数 $n$ 和 $L$，分别表示有多少段泥泞路和木板的长度；\n\n接下来 $n$ 行，每一行两个整数 $s$ 和 $e$，表示每一段泥泞路的起点和终点。", "outputFormat": "仅一个正整数，表示木板数。\n", "hint": "对于 $100 \\%$ 的数据，$n,L \\leq 10000$，$s \\leq e \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P1590", "type": "P", "difficulty": 3, "samples": [["2\n10\n20", "9\n18"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串", "数学", "进制"], "title": "失踪的7", "background": null, "description": "远古的 Pascal 人也使用阿拉伯数字来进行计数，但是他们又不喜欢使用 $7$ ，因为他们认为 $7$ 是一个不吉祥的数字，所以 Pascal 数字 $8$ 其实表示的是自然数中的 $7$，$18$ 表示的是自然数中的 $16$ 。请计算，在正整数 $n$ 范围以内包含有多少个 Pascal 数字。", "inputFormat": "第一行为正整数 $t$，接下来 $t$ 行，每行一个正整数 $n$，且保证输入的 $n$ 是 Pascal 数字", "outputFormat": "对于每个正整数 $n$，输出 $n$ 以内的 Pascal 数的个数。", "hint": "对于所有数据，$1 \\leq t \\leq 10000$，$1 \\leq n \\leq 2^{32}-1$。", "locale": "zh-CN", "translations": {"en": {"title": "The Missing 7", "background": "", "description": "The ancient Pascal people also used Arabic numerals to count, but they disliked using $7$ because they considered $7$ an unlucky number. Therefore, Pascal number $8$ actually represents $7$ in the natural numbers, and $18$ represents $16$. Please compute how many Pascal numbers are contained within the range of positive integers up to $n$.", "inputFormat": "The first line contains a positive integer $t$. Then follow $t$ lines, each containing a positive integer $n$, and it is guaranteed that the input $n$ is a Pascal number.", "outputFormat": "For each positive integer $n$, output the number of Pascal numbers not exceeding $n$.", "hint": "For all testdata, $1 \\leq t \\leq 10000$, $1 \\leq n \\leq 2^{32} - 1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "失踪的7", "background": null, "description": "远古的 Pascal 人也使用阿拉伯数字来进行计数，但是他们又不喜欢使用 $7$ ，因为他们认为 $7$ 是一个不吉祥的数字，所以 Pascal 数字 $8$ 其实表示的是自然数中的 $7$，$18$ 表示的是自然数中的 $16$ 。请计算，在正整数 $n$ 范围以内包含有多少个 Pascal 数字。", "inputFormat": "第一行为正整数 $t$，接下来 $t$ 行，每行一个正整数 $n$，且保证输入的 $n$ 是 Pascal 数字", "outputFormat": "对于每个正整数 $n$，输出 $n$ 以内的 Pascal 数的个数。", "hint": "对于所有数据，$1 \\leq t \\leq 10000$，$1 \\leq n \\leq 2^{32}-1$。", "locale": "zh-CN"}}}
{"pid": "P1591", "type": "P", "difficulty": 2, "samples": [["2\n5 2\n7 0", "1\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "高精度"], "title": "阶乘数码", "background": "", "description": "求 $n!$ 中某个数码出现的次数。\n", "inputFormat": "第一行为 $t(t \\leq 10)$，表示数据组数。接下来 $t$ 行，每行一个正整数 $n(n \\leq 1000)$ 和数码 $a$。\n", "outputFormat": "对于每组数据，输出一个整数，表示 $n!$ 中 $a$ 出现的次数。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Digit Count in Factorial", "background": "", "description": "Find how many times a certain digit appears in $n!$.", "inputFormat": "The first line contains $t$ ($t \\leq 10$), indicating the number of test cases.  \nEach of the next $t$ lines contains a positive integer $n$ ($n \\leq 1000$) and a digit $a$.", "outputFormat": "For each test case, output a single integer, the number of times $a$ appears in $n!$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "阶乘数码", "background": "", "description": "求 $n!$ 中某个数码出现的次数。\n", "inputFormat": "第一行为 $t(t \\leq 10)$，表示数据组数。接下来 $t$ 行，每行一个正整数 $n(n \\leq 1000)$ 和数码 $a$。\n", "outputFormat": "对于每组数据，输出一个整数，表示 $n!$ 中 $a$ 出现的次数。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1592", "type": "P", "difficulty": 3, "samples": [["10 5", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学"], "title": "互质", "background": "", "description": "输入两个正整数 $n$ 和 $k$，求与 $n$ 互质的第 $k$ 个正整数。", "inputFormat": "仅一行，为两个正整数 $n$ 和 $k$。", "outputFormat": "一个正整数，表示与 $n$ 互质的第 $k$ 个正整数。", "hint": "#### 数据规模与约定\n\n对于所有的数据，保证 $1 \\leq n \\le 10^6$，$1 \\leq k\\le 10^8$。", "locale": "zh-CN", "translations": {"en": {"title": "Coprime", "background": "", "description": "Given two positive integers $n$ and $k$, find the $k$-th positive integer that is coprime to $n$.", "inputFormat": "A single line containing two positive integers $n$ and $k$.", "outputFormat": "A single positive integer, which is the $k$-th positive integer that is coprime to $n$.", "hint": "Constraints\n\nFor all testdata, it is guaranteed that $1 \\leq n \\leq 10^6$, $1 \\leq k \\leq 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "互质", "background": "", "description": "输入两个正整数 $n$ 和 $k$，求与 $n$ 互质的第 $k$ 个正整数。", "inputFormat": "仅一行，为两个正整数 $n$ 和 $k$。", "outputFormat": "一个正整数，表示与 $n$ 互质的第 $k$ 个正整数。", "hint": "#### 数据规模与约定\n\n对于所有的数据，保证 $1 \\leq n \\le 10^6$，$1 \\leq k\\le 10^8$。", "locale": "zh-CN"}}}
{"pid": "P1593", "type": "P", "difficulty": 4, "samples": [["2 3", "15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学"], "title": "因子和", "background": "", "description": "输入两个整数 $a$ 和 $b$，求 $a^b$ 的因子和。\n\n由于结果太大，只要输出它对 $9901$ 取模的结果。", "inputFormat": "仅一行，为两个整数 $a$ 和 $b$。\n", "outputFormat": "输出一行一个整数表示答案对 $9901$ 取模的结果。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq a \\leq 5 \\times 10^7$，$0 \\leq b \\leq 5 \\times 10^7$。", "locale": "zh-CN", "translations": {"en": {"title": "Sum of Divisors", "background": "", "description": "Given two integers $a$ and $b$, compute the sum of divisors of $a^b$.\n\nSince the result can be very large, output it modulo $9901$.", "inputFormat": "A single line containing two integers $a$ and $b$.", "outputFormat": "Output a single line with one integer, the answer modulo $9901$.", "hint": "#### Constraints\n\nFor all testdata, it is guaranteed that $1 \\leq a \\leq 5 \\times 10^7$, $0 \\leq b \\leq 5 \\times 10^7$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "因子和", "background": "", "description": "输入两个整数 $a$ 和 $b$，求 $a^b$ 的因子和。\n\n由于结果太大，只要输出它对 $9901$ 取模的结果。", "inputFormat": "仅一行，为两个整数 $a$ 和 $b$。\n", "outputFormat": "输出一行一个整数表示答案对 $9901$ 取模的结果。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq a \\leq 5 \\times 10^7$，$0 \\leq b \\leq 5 \\times 10^7$。", "locale": "zh-CN"}}}
{"pid": "P1594", "type": "P", "difficulty": 3, "samples": [["100 5 10\n40 25\n50 20\n50 20\n70 10\n12 50\n9 70\n49 30\n38 25\n27 50\n19 70", "75.0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP"], "title": "护卫队", "background": null, "description": "护卫车队在一条单行的街道前排成一队，前面河上是一座单行的桥。因为街道是一条单行道，所以任何车辆都不能超车。桥能承受一个给定的最大承载量。为了控制桥上的交通，桥两边各站一个指挥员。护卫车队被分成几个组，每组中的车辆都能同时通过该桥。当一组车队达到了桥的另一端，该端的指挥员就用电话通知另一端的指挥员，这样下一组车队才能开始通过该桥。每辆车的重量是已知的。任何一组车队的重量之和不能超过桥的最大承重量。被分在同一组的每一辆车都以其最快的速度通过该桥。一组车队通过该桥的时间是用该车队中速度最慢的车通过该桥所需的时间来表示的。问题要求计算出全部护卫车队通过该桥所需的最短时间值。", "inputFormat": "第一行包含三个整数，第一个整数表示该桥所能承受的最大载重量（用吨表示）；第二个整数表示该桥长度（用千米表示）；第三个整数表示该护卫队中车辆的总数（$n\\lt 1000$）。接下来的几行中，每行包含两个正整数 $W$ 和 $S$（用空格隔开），$W$ 表示该车的重量（用吨表示），$S$ 表示该车过桥能达到的最快速度（用千米/小时表示）。车子的重量和速度是按车子排队等候时的顺序给出的。", "outputFormat": "输出文件应该是一个实数，四舍五入精确到小数点后1位，表示整个护卫车队通过该桥所需的最短时间（用分钟表示）。", "hint": "数据保证题目中所有输入的数都在 $[1,10^{10}]$ 以内。", "locale": "zh-CN", "translations": {"en": {"title": "Escort Convoy", "background": "", "description": "An escort convoy lines up on a one-way street approaching a one-lane bridge over a river. Because the street is one-way, no vehicle can overtake another. The bridge can bear a given maximum load. To control traffic on the bridge, there is a dispatcher at each end. The convoy is divided into several groups, and all vehicles in the same group can enter the bridge at the same time. When a group reaches the other end of the bridge, the dispatcher at that end phones the dispatcher at the starting end so that the next group may begin to cross. Each vehicle’s weight is known. The total weight of any group must not exceed the bridge’s maximum load. Every vehicle in the same group crosses at its own top speed. The time for a group to cross the bridge is determined by the time needed for the slowest vehicle in that group to cross. The task is to compute the minimum total time for the entire convoy to cross the bridge.", "inputFormat": "The first line contains three integers: the bridge’s maximum load (in tons), the bridge length (in kilometers), and the total number of vehicles in the convoy (with $n \\lt 1000$). The following lines each contain two positive integers $W$ and $S$ (separated by a space), where $W$ is the vehicle’s weight (in tons) and $S$ is its top speed for crossing the bridge (in kilometers per hour). The weights and speeds are given in the order the vehicles are queued.", "outputFormat": "Output a real number, rounded to 1 decimal place, representing the minimum total time for the entire convoy to cross the bridge (in minutes).", "hint": "The testdata guarantees that all input numbers are within $[1, 10^{10}]$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "护卫队", "background": null, "description": "护卫车队在一条单行的街道前排成一队，前面河上是一座单行的桥。因为街道是一条单行道，所以任何车辆都不能超车。桥能承受一个给定的最大承载量。为了控制桥上的交通，桥两边各站一个指挥员。护卫车队被分成几个组，每组中的车辆都能同时通过该桥。当一组车队达到了桥的另一端，该端的指挥员就用电话通知另一端的指挥员，这样下一组车队才能开始通过该桥。每辆车的重量是已知的。任何一组车队的重量之和不能超过桥的最大承重量。被分在同一组的每一辆车都以其最快的速度通过该桥。一组车队通过该桥的时间是用该车队中速度最慢的车通过该桥所需的时间来表示的。问题要求计算出全部护卫车队通过该桥所需的最短时间值。", "inputFormat": "第一行包含三个整数，第一个整数表示该桥所能承受的最大载重量（用吨表示）；第二个整数表示该桥长度（用千米表示）；第三个整数表示该护卫队中车辆的总数（$n\\lt 1000$）。接下来的几行中，每行包含两个正整数 $W$ 和 $S$（用空格隔开），$W$ 表示该车的重量（用吨表示），$S$ 表示该车过桥能达到的最快速度（用千米/小时表示）。车子的重量和速度是按车子排队等候时的顺序给出的。", "outputFormat": "输出文件应该是一个实数，四舍五入精确到小数点后1位，表示整个护卫车队通过该桥所需的最短时间（用分钟表示）。", "hint": "数据保证题目中所有输入的数都在 $[1,10^{10}]$ 以内。", "locale": "zh-CN"}}}
{"pid": "P1595", "type": "P", "difficulty": 2, "samples": [["2", "1"], ["3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "递推", "枚举", "容斥原理"], "title": "信封问题", "background": "", "description": "某人写了 $n$ 封信和 $n$ 个信封，如果所有的信都装错了信封。求所有信都装错信封共有多少种不同情况。", "inputFormat": "一个信封数 $n$，保证 $n \\le 20$。", "outputFormat": "一个整数，代表有多少种情况。", "hint": "对于 $100 \\%$ 的数据，$1 \\le n \\le 20$。", "locale": "zh-CN", "translations": {"en": {"title": "Envelope Problem", "background": "", "description": "Someone writes $n$ letters and has $n$ envelopes. If all letters are put into the wrong envelopes, how many different ways are there in total?", "inputFormat": "A single integer $n$, the number of envelopes, with $n \\le 20$.", "outputFormat": "A single integer representing the number of ways.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "信封问题", "background": "", "description": "某人写了 $n$ 封信和 $n$ 个信封，如果所有的信都装错了信封。求所有信都装错信封共有多少种不同情况。", "inputFormat": "一个信封数 $n$，保证 $n \\le 20$。", "outputFormat": "一个整数，代表有多少种情况。", "hint": "对于 $100 \\%$ 的数据，$1 \\le n \\le 20$。", "locale": "zh-CN"}}}
{"pid": "P1596", "type": "P", "difficulty": 2, "samples": [["10 12\nW........WW.\n.WWW.....WWW\n....WW...WW.\n.........WW.\n.........W..\n..W......W..\n.W.W.....WW.\nW.W.W.....W.\n.W.W......W.\n..W.......W.\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "图论", "2010", "USACO", "深度优先搜索 DFS", "连通块"], "title": "[USACO10OCT] Lake Counting S", "background": "", "description": "Due to recent rains, water has pooled in various places in Farmer John's field, which is represented by a rectangle of N x M (1 <= N <= 100; 1 <= M <= 100) squares. Each square contains either water ('W') or dry land ('.'). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors. Given a diagram of Farmer John's field, determine how many ponds he has.\n\n\n\n\n", "inputFormat": "Line 1: Two space-separated integers: N and M \\* Lines 2..N+1: M characters per line representing one row of Farmer John's field. Each character is either 'W' or '.'. The characters do not have spaces between them.\n\n\n", "outputFormat": "Line 1: The number of ponds in Farmer John's field.\n\n", "hint": "OUTPUT DETAILS: There are three ponds: one in the upper left, one in the lower left, and one along the right side.\n", "locale": "en", "translations": {"en": {"title": "[USACO10OCT] Lake Counting S", "background": "", "description": "Due to recent rains, water has pooled in various places in Farmer John's field, which is represented by a rectangle of N x M (1 <= N <= 100; 1 <= M <= 100) squares. Each square contains either water ('W') or dry land ('.'). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors. Given a diagram of Farmer John's field, determine how many ponds he has.\n\n\n\n\n", "inputFormat": "Line 1: Two space-separated integers: N and M \\* Lines 2..N+1: M characters per line representing one row of Farmer John's field. Each character is either 'W' or '.'. The characters do not have spaces between them.\n\n\n", "outputFormat": "Line 1: The number of ponds in Farmer John's field.\n\n", "hint": "OUTPUT DETAILS: There are three ponds: one in the upper left, one in the lower left, and one along the right side.\n", "locale": "en"}, "zh-CN": {"title": "[USACO10OCT] Lake Counting S", "background": null, "description": "由于最近的降雨，水在农夫约翰的田地里积聚了。田地可以表示为一个 $N \\times M$ 的矩形（$1 \\leq N \\leq 100$；$1 \\leq M \\leq 100$）。每个方格中要么是水（`W`），要么是干地（`.`）。农夫约翰想要弄清楚他的田地里形成了多少个水塘。一个水塘是由连通的水方格组成的，其中一个方格被认为与它的八个邻居相邻。给定农夫约翰田地的示意图，确定他有多少个水塘。", "inputFormat": "第 $1$ 行：两个用空格分隔的整数：$N$ 和 $M$。\n\n第 $2$ 行到第 $N+1$ 行：每行 $M$ 个字符，表示农夫约翰田地的一行。\n\n每个字符要么是 `W`，要么是 `.`。\n\n字符之间没有空格。", "outputFormat": "第 $1$ 行：农夫约翰田地中的水塘数量。", "hint": "输出详情：共有三个水塘：一个在左上角，一个在左下角，还有一个沿着右侧。\n\n（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P1597", "type": "P", "difficulty": 1, "samples": [["a:=3;b:=4;c:=5;", "3 4 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串"], "title": "语句解析", "background": "木有背景……\n", "description": "一串长度不超过 $255$ 的 PASCAL 语言代码，只有 $a,b,c$ 三个变量，而且只有赋值语句，赋值只能是一个一位的数字或一个变量，每条赋值语句的格式是 `[变量]:=[变量或一位整数];`。未赋值的变量值为 $0$ 输出 $a,b,c$ 的值。", "inputFormat": "一串符合语法的 PASCAL 语言，只有 $a,b,c$ 三个变量，而且只有赋值语句，赋值只能是一个一位的数字或一个变量，未赋值的变量值为 $0$。\n", "outputFormat": "输出 $a,b,c$ 最终的值。\n", "hint": "输入的 PASCAL 语言长度不超过 $255$。", "locale": "zh-CN", "translations": {"en": {"title": "Statement Parsing", "background": "No background.", "description": "A PASCAL code string of length not exceeding $255$, containing only the three variables a, b, c and only assignment statements. The right-hand side of an assignment can only be a single-digit number or a variable. Each assignment statement has the format \"[variable] := [variable or single-digit integer];\". Unassigned variables have value $0$. Output the values of a, b, c.", "inputFormat": "A string of PASCAL code that conforms to the above constraints, using only variables a, b, c and only assignment statements, where the right-hand side is either a single-digit integer or a variable. Unassigned variables have value $0$.", "outputFormat": "Output the final values of a, b, c.", "hint": "The length of the input PASCAL code does not exceed $255$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "语句解析", "background": "木有背景……\n", "description": "一串长度不超过 $255$ 的 PASCAL 语言代码，只有 $a,b,c$ 三个变量，而且只有赋值语句，赋值只能是一个一位的数字或一个变量，每条赋值语句的格式是 `[变量]:=[变量或一位整数];`。未赋值的变量值为 $0$ 输出 $a,b,c$ 的值。", "inputFormat": "一串符合语法的 PASCAL 语言，只有 $a,b,c$ 三个变量，而且只有赋值语句，赋值只能是一个一位的数字或一个变量，未赋值的变量值为 $0$。\n", "outputFormat": "输出 $a,b,c$ 最终的值。\n", "hint": "输入的 PASCAL 语言长度不超过 $255$。", "locale": "zh-CN"}}}
{"pid": "P1598", "type": "P", "difficulty": 2, "samples": [["THE QUICK BROWN FOX JUMPED OVER THE LAZY DOG.\nTHIS IS AN EXAMPLE TO TEST FOR YOUR\nHISTOGRAM PROGRAM.\nHELLO!\n", "                            *\n                            *\n        *                   *\n        *                   *     *   *\n        *                   *     *   *\n*       *     *             *     *   *\n*       *     * *     * *   *     * * *\n*       *   * * *     * *   * *   * * * *\n*     * * * * * *     * * * * *   * * * *     * *\n* * * * * * * * * * * * * * * * * * * * * * * * * *\nA B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串", "2003", "USACO"], "title": "[USACO03FEB] 垂直柱状图 Vertical Histogram", "background": null, "description": "写一个程序从输入文件中去读取四行大写字母（全都是大写的，每行不超过 $100$ 个字符），然后用柱状图输出每个字符在输入文件中出现的次数。严格地按照输出样例来安排你的输出格式。", "inputFormat": "四行字符，由大写字母组成，每行不超过 $100$ 个字符。", "outputFormat": "由若干行组成，前几行由空格和星号组成，最后一行则是由空格和字母组成的。在任何一行末尾不要打印不需要的多余空格。不要打印任何空行。", "hint": "每行输出后面不允许出现多余的空格。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO03FEB] Vertical Histogram", "background": "", "description": "Write a program that reads four lines of uppercase letters from the input (all uppercase, each line has at most $100$ characters), and then outputs a histogram showing how many times each character appears in the input. Format your output exactly as in the sample output.", "inputFormat": "Four lines of characters consisting of uppercase letters, each line has at most $100$ characters.", "outputFormat": "Consists of several lines. The first lines are made up of spaces and asterisks, and the last line is made up of spaces and letters. Do not print any unnecessary trailing spaces at the end of any line. Do not print any blank lines.", "hint": "No trailing spaces are allowed at the end of each output line.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO03FEB] 垂直柱状图 Vertical Histogram", "background": null, "description": "写一个程序从输入文件中去读取四行大写字母（全都是大写的，每行不超过 $100$ 个字符），然后用柱状图输出每个字符在输入文件中出现的次数。严格地按照输出样例来安排你的输出格式。", "inputFormat": "四行字符，由大写字母组成，每行不超过 $100$ 个字符。", "outputFormat": "由若干行组成，前几行由空格和星号组成，最后一行则是由空格和字母组成的。在任何一行末尾不要打印不需要的多余空格。不要打印任何空行。", "hint": "每行输出后面不允许出现多余的空格。", "locale": "zh-CN"}}}
{"pid": "P1599", "type": "P", "difficulty": 2, "samples": [["5\n100\n-200\n250\n-200\n200", "9\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "2009", "USACO"], "title": "[USACO09MAR] 结算日 Payback B", "background": null, "description": "“不放债不借债”，贝西多么希望自己可以遵循这个忠告。她已经和她的 $N(1 \\leq N \\leq 100,000)$ 个朋友有了债务关系，或者借债了，或者放债了。她的 $N$ 个朋友依次标号为 $1\\dots N$。\n\n结算日终于来临了。她知道，朋友欠她的钱比她欠朋友的钱多。她的朋友们分布在一条直线上，第 $i$ 头奶牛站的位置距离谷仓 $i$ 米。贝西打算沿着这条直线行走，从欠她钱的奶牛手里收钱回来，并且还钱给她欠钱的奶牛。\n\n当她沿直线移动的时候，她可以要求任何欠她钱的奶牛还全部的钱。当她有足够的钱可以还清她的某个债，就可以把钱给对应的奶牛还清她的债。奶牛 $i$ 欠贝西 $D_i$ 元 $(-1,000 \\leq D_i \\leq 1,000,D_i \\neq 0)$，负数表示贝西欠奶牛 $i$ 钱。\n\n贝西从谷仓出发，位置为 $0$，初始贝西没有钱。贝西收回她的所有借债，并且还清她的欠债所需行走的最短距离是多少？\n\n注意：她必须在最后一头奶牛所在的位置，完成她的行走。", "inputFormat": "第一行，一个整数 $N$。\n\n接下来第 $2 \\dots N+1$ 行，第 $i+1$ 行包含一个整数 $D_i$。", "outputFormat": "一个整数，贝西收回借债并且还清欠债，所需要行走的最短距离（单位为米）。", "hint": "输入解释：\n\n$3$ 头奶牛欠贝西钱；她欠 $2$ 头奶牛钱。当她完成结算，她将有 $150$ 元。\n\n输出解释：\n\n```plain\n谷仓  100  -200  250 -200  200\n |     |     |    |    |    |\n ***>**+**>*****>**+\n                   *            < 贝西有 350 元\n             -**<***\n             *                  < 贝西有 150 元\n             ***>****>****>**+\n                             *  < 贝西有 350 元\n                       -**<***\n                       *     \n                       ***>***  < 贝西结束她的行走，有 150 元\n```", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09MAR] Payback B (Settlement Day)", "background": "", "description": "“Neither a lender nor a borrower be”—how Bessie wishes she could follow this advice. She already has debt relationships with her $N (1 \\leq N \\leq 100,000)$ friends: she has either borrowed from them or lent to them. Her $N$ friends are labeled $1 \\dots N$ in order.\n\nSettlement day has finally arrived. She knows that the total money her friends owe her is greater than the total money she owes them. Her friends are positioned on a straight line: the $i$-th cow stands at distance $i$ meters from the barn. Bessie plans to walk along this line, collecting money from cows who owe her and repaying cows she owes.\n\nAs she moves along the line, she may demand that any cow who owes her repay in full. Whenever she has enough money to fully settle a particular debt she owes, she may pay that cow in full. Cow $i$ owes Bessie $D_i$ yuan $(-1,000 \\leq D_i \\leq 1,000,D_i \\neq 0)$; a negative value means Bessie owes cow $i$ money.\n\nBessie starts from the barn at position $0$ with no money. What is the minimum distance she must walk to collect all debts owed to her and pay off all debts she owes?\n\nNote: She must finish her walk at the position of the last cow.", "inputFormat": "The first line contains an integer $N$.\n\nLines $2 \\dots N+1$: the $(i+1)$-th line contains an integer $D_i$.", "outputFormat": "A single integer: the minimum distance (in meters) Bessie needs to walk to collect and settle all debts.", "hint": "Input explanation:\n\n$3$ cows owe Bessie money; she owes $2$ cows money. When she finishes settling, she will have $150$ yuan.\n\nOutput explanation:\n\n```plain\n谷仓  100  -200  250 -200  200\n |     |     |    |    |    |\n ***>**+**>*****>**+\n                   *            < 贝西有 350 元\n             -**<***\n             *                  < 贝西有 150 元\n             ***>****>****>**+\n                             *  < 贝西有 350 元\n                       -**<***\n                       *     \n                       ***>***  < 贝西结束她的行走，有 150 元\n```\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09MAR] 结算日 Payback B", "background": null, "description": "“不放债不借债”，贝西多么希望自己可以遵循这个忠告。她已经和她的 $N(1 \\leq N \\leq 100,000)$ 个朋友有了债务关系，或者借债了，或者放债了。她的 $N$ 个朋友依次标号为 $1\\dots N$。\n\n结算日终于来临了。她知道，朋友欠她的钱比她欠朋友的钱多。她的朋友们分布在一条直线上，第 $i$ 头奶牛站的位置距离谷仓 $i$ 米。贝西打算沿着这条直线行走，从欠她钱的奶牛手里收钱回来，并且还钱给她欠钱的奶牛。\n\n当她沿直线移动的时候，她可以要求任何欠她钱的奶牛还全部的钱。当她有足够的钱可以还清她的某个债，就可以把钱给对应的奶牛还清她的债。奶牛 $i$ 欠贝西 $D_i$ 元 $(-1,000 \\leq D_i \\leq 1,000,D_i \\neq 0)$，负数表示贝西欠奶牛 $i$ 钱。\n\n贝西从谷仓出发，位置为 $0$，初始贝西没有钱。贝西收回她的所有借债，并且还清她的欠债所需行走的最短距离是多少？\n\n注意：她必须在最后一头奶牛所在的位置，完成她的行走。", "inputFormat": "第一行，一个整数 $N$。\n\n接下来第 $2 \\dots N+1$ 行，第 $i+1$ 行包含一个整数 $D_i$。", "outputFormat": "一个整数，贝西收回借债并且还清欠债，所需要行走的最短距离（单位为米）。", "hint": "输入解释：\n\n$3$ 头奶牛欠贝西钱；她欠 $2$ 头奶牛钱。当她完成结算，她将有 $150$ 元。\n\n输出解释：\n\n```plain\n谷仓  100  -200  250 -200  200\n |     |     |    |    |    |\n ***>**+**>*****>**+\n                   *            < 贝西有 350 元\n             -**<***\n             *                  < 贝西有 150 元\n             ***>****>****>**+\n                             *  < 贝西有 350 元\n                       -**<***\n                       *     \n                       ***>***  < 贝西结束她的行走，有 150 元\n```", "locale": "zh-CN"}}}
{"pid": "P1600", "type": "P", "difficulty": 6, "samples": [["6 3\n2 3\n1 2 \n1 4 \n4 5 \n4 6 \n0 2 5 1 2 3 \n1 5 \n1 3 \n2 6 ", "2 0 0 1 1 1 "], ["5 3 \n1 2 \n2 3 \n2 4 \n1 5 \n0 1 0 3 0 \n3 1 \n1 4\n5 5 ", "1 2 1 0 1 "]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "线段树", "树上启发式合并", "NOIP 提高组", "最近公共祖先 LCA", "树链剖分", "动态树 LCT", "ST 表", "差分", "线段树合并"], "title": "[NOIP 2016 提高组] 天天爱跑步", "background": "NOIP2016 提高组 D1T2", "description": "小 C 同学认为跑步非常有趣，于是决定制作一款叫做《天天爱跑步》的游戏。《天天爱跑步》是一个养成类游戏，需要玩家每天按时上线，完成打卡任务。\n\n这个游戏的地图可以看作一棵包含 $n$ 个结点和 $n-1$ 条边的树，每条边连接两个结点，且任意两个结点存在一条路径互相可达。树上结点编号为从 $1$ 到 $n$ 的连续正整数。\n\n现在有 $m$ 个玩家，第 $i$ 个玩家的起点为 $s_i$，终点为 $t_i$。每天打卡任务开始时，所有玩家在第 $0$ 秒同时从自己的起点出发，以每秒跑一条边的速度，不间断地沿着最短路径向着自己的终点跑去，跑到终点后该玩家就算完成了打卡任务。（由于地图是一棵树，所以每个人的路径是唯一的）\n\n小 C 想知道游戏的活跃度，所以在每个结点上都放置了一个观察员。在结点 $j$ 的观察员会选择在第 $w_j$ 秒观察玩家，一个玩家能被这个观察员观察到当且仅当该玩家在第 $w_j$ 秒也正好到达了结点 $j$。小 C 想知道每个观察员会观察到多少人?\n\n注意：我们认为一个玩家到达自己的终点后该玩家就会结束游戏，他不能等待一段时间后再被观察员观察到。即对于把结点 $j$ 作为终点的玩家：若他在第 $w_j$ 秒前到达终点，则在结点 $j$ 的观察员不能观察到该玩家；若他正好在第 $w_j$ 秒到达终点，则在结点 $j$ 的观察员可以观察到这个玩家。", "inputFormat": "第一行有两个整数 $n$ 和 $m$。其中 $n$ 代表树的结点数量，同时也是观察员的数量，$m$ 代表玩家的数量。\n\n接下来 $n-1$ 行每行两个整数 $u$ 和 $v$，表示结点 $u$ 到结点 $v$ 有一条边。\n\n接下来一行 $n$ 个整数，其中第 $j$ 个整数为 $w_j$，表示结点 $j$ 出现观察员的时间。\n\n接下来 $m$ 行，每行两个整数 $s_i$，和 $t_i$，表示一个玩家的起点和终点。\n\n对于所有的数据，保证 $1\\leq s_i,t_i\\leq n, 0\\leq w_j\\leq n$。", "outputFormat": "输出 $1$ 行 $n$ 个整数，第 $j$ 个整数表示结点 $j$ 的观察员可以观察到多少人。", "hint": "**样例 1 说明**\n\n对于 $1$ 号点，$w_i=0$，故只有起点为 $1$ 号点的玩家才会被观察到，所以玩家 $1$ 和玩家 $2$ 被观察到，共有 $2$ 人被观察到。\n\n对于 $2$ 号点，没有玩家在第 $2$ 秒时在此结点，共 $0$ 人被观察到。\n\n对于 $3$ 号点，没有玩家在第 $5$ 秒时在此结点，共 $0$ 人被观察到。\n\n对于 $4$ 号点，玩家 $1$ 被观察到，共 $1$ 人被观察到。\n\n对于 $5$ 号点，玩家 $1$ 被观察到，共 $1$ 人被观察到。\n\n对于 $6$ 号点，玩家 $3$ 被观察到，共 $1$ 人被观察到。\n\n**子任务**\n\n每个测试点的数据规模及特点如下表所示。\n\n提示：数据范围的个位上的数字可以帮助判断是哪一种数据类型。\n\n| 测试点编号 | $n=$ | $m=$ | 约定 |\n| :--------: | :----: | :----: | :----: |\n|     $1\\sim 2$      |  $991$   |  $991$   | 所有人的起点等于自己的终点，即 $\\forall i,\\ s_i=t_i$  |\n|     $3\\sim 4$      |  $992$   |  $992$   | 所有 $w_j=0$  |\n|     $5$      |  $993$   |  $993$   | 无  |\n|     $6\\sim 8$      |  $99994$   |  $99994$   | $\\forall i\\in[1,n-1]$，$i$ 与 $i+1$ 有边。即树退化成 $1,2,\\dots,n$ 按顺序连接的链  |\n|     $9\\sim 12$      |  $99995$   |  $99995$   | 所有 $s_i=1$  |\n|     $13\\sim 16$      |  $99996$   |  $99996$   | 所有 $t_i=1$  |\n|     $17\\sim 19$      |  $99997$   |  $99997$   | 无  |\n|     $20$      |  $299998$   |  $299998$   | 无  |\n\n\n\n**提示**\n\n（提示：由于原提示年代久远，不一定能完全反映现在的情况，现在已经对该提示做出了一定的修改，提示的原文可以在[该剪贴板](https://www.luogu.com.cn/paste/3fneb8m6)查看）\n\n在最终评测时，调用栈占用的空间大小不会有单独的限制，但在我们的工作环境中默认会有 $1 \\text{MiB}$ 的限制。 这可能会引起**函数调用层数较多时，程序发生栈溢出崩溃**，程序中**较深层数的递归**往往会导致这个问题。如果你的程序需要用到较大的栈空间，请务必注意该问题。\n\n我们可以使用一些方法修改调用栈的大小限制。\n\n- Linux\n\n我们可以在终端中输入下列命令：`ulimit -s 1048576`。此命令的意义是，将调用栈的大小限制修改为 $1048576\\text{KiB}=1 \\text{GiB}$。\n\n例如，对于如下程序 `sample.cpp`：\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint f[1000005];\nvoid dfs(int a){\n\tif(a == 0){\n\t\tf[a] = 0;\n\t\treturn;\n\t}\n\tdfs(a - 1);\n\tf[a] = f[a - 1] + 1;\n}\nint main(){\n\tdfs(1000000);\n\treturn 0;\n}\n```\n\n将上述源代码用命令 `g++ sample.cpp -o sample` 编译为可执行文件 `sample` 后，使用 `./sample` 执行程序。\n\n如果在没有使用命令 `ulimit -s 1048576` 的情况下运行该程序，`sample` 会因为栈溢出而崩溃；如果使用了上述命令后运行该程序，该程序则不会崩溃。\n\n特别地，当你打开多个终端时，它们并不会共享该命令，你需要分别对它们运行该命令。\n\n请注意，调用栈占用的空间会计入总空间占用中，和程序其他部分占用的内存共同受到内存限制。\n\n- Windows\n\n如果你使用 Windows 下的 Dev-C++，请选择 `工具-编译选项` 并在如下区域填入以下命令 `-Wl,--stack=1073741824`，填入后注意确认“编译时加入以下命令的”的框是**已勾选**状态。\n\n此处 `1073741824` 的单位是 $\\text{B/Bytes}$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/z6mbzfqo.png)  ![](https://cdn.luogu.com.cn/upload/image_hosting/zvrzkyq5.png)", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2016 Senior] Love Running Everyday", "background": "NOIP 2016 Senior D1T2.", "description": "Student Xiao C thinks running is very interesting, so he decides to make a game called \"Love Running Everyday.\" \"Love Running Everyday\" is a nurturing-style game that requires players to log in on time every day to complete a check-in task.\n\nThe map in this game can be viewed as a tree with $n$ nodes and $n-1$ edges. Each edge connects two nodes, and there exists exactly one path between any two nodes. The nodes on the tree are numbered with consecutive positive integers from $1$ to $n$.\n\nThere are $m$ players. The $i$-th player starts at $s_i$ and ends at $t_i$. When the daily check-in task starts, all players simultaneously depart from their starting points at second $0$, moving at a speed of one edge per second, continuously along the shortest path toward their destination. Once a player reaches the destination, that player is considered to have completed the check-in task. (Since the map is a tree, each person's path is unique.)\n\nXiao C wants to know the game's activity level, so an observer is placed at every node. The observer at node $j$ chooses to observe players at second $w_j$. A player can be observed by this observer if and only if the player also arrives at node $j$ exactly at second $w_j$. Xiao C wants to know how many players each observer will observe.\n\nNote: We assume that once a player reaches the destination, the player finishes the game and cannot wait to be observed later. That is, for a player whose destination is node $j$: if the player reaches the destination before second $w_j$, then the observer at node $j$ cannot observe that player; if the player arrives at the destination exactly at second $w_j$, then the observer at node $j$ can observe that player.", "inputFormat": "The first line contains two integers $n$ and $m$. Here $n$ is the number of nodes in the tree and also the number of observers, and $m$ is the number of players.\n\nEach of the next $n-1$ lines contains two integers $u$ and $v$, indicating that there is an edge between node $u$ and node $v$.\n\nThe next line contains $n$ integers, where the $j$-th integer is $w_j$, meaning the observation time at node $j$.\n\nEach of the next $m$ lines contains two integers $s_i$ and $t_i$, representing a player's starting point and destination.\n\nFor all testdata, it is guaranteed that $1 \\leq s_i, t_i \\leq n$, $0 \\leq w_j \\leq n$.", "outputFormat": "Output one line with $n$ integers. The $j$-th integer indicates how many players can be observed by the observer at node $j$.", "hint": "Sample 1 Explanation.\n\n- For node $1$, $w_1 = 0$. Therefore, only players whose starting point is node $1$ will be observed. Players $1$ and $2$ are observed, for a total of $2$ players.\n- For node $2$, no player is at this node at second $2$, so $0$ players are observed.\n- For node $3$, no player is at this node at second $5$, so $0$ players are observed.\n- For node $4$, player $1$ is observed, so $1$ player is observed.\n- For node $5$, player $1$ is observed, so $1$ player is observed.\n- For node $6$, player $3$ is observed, so $1$ player is observed.\n\nSubtasks.\n\nThe size and characteristics of each testpoint are as follows. \n\nTip: The one's digit of the numbers in the constraints can help determine which type of data it is.\n\n| Testpoint ID | $n=$ | $m=$ | Convention |\n| :----------: | :--: | :--: | :--------: |\n| $1 \\sim 2$ | $991$ | $991$ | All players' starting points equal their own destinations, i.e., $\\forall i,\\ s_i=t_i$. |\n| $3 \\sim 4$ | $992$ | $992$ | All $w_j=0$. |\n| $5$ | $993$ | $993$ | None. |\n| $6 \\sim 8$ | $99994$ | $99994$ | $\\forall i \\in [1,n-1]$, there is an edge between $i$ and $i+1$. That is, the tree degenerates into a chain $1,2,\\dots,n$ connected in order. |\n| $9 \\sim 12$ | $99995$ | $99995$ | All $s_i=1$. |\n| $13 \\sim 16$ | $99996$ | $99996$ | All $t_i=1$. |\n| $17 \\sim 19$ | $99997$ | $99997$ | None. |\n| $20$ | $299998$ | $299998$ | None. |\n\nNotes.\n\n(Tip: Because the original note is old, it may not fully reflect the current situation. We have made some updates to this note. The original text can be viewed on [this clipboard](https://www.luogu.com.cn/paste/3fneb8m6).)\n\nIn the final evaluation, the stack size usage will not have a separate limit, but in our working environment there is a default limit of $1 \\text{MiB}$. This may cause a stack overflow crash when the number of function calls is large. Deep recursion in your program often leads to this problem. If your program needs a large stack, please pay close attention to this issue.\n\nWe can use some methods to change the stack size limit.\n\n- Linux\n\nWe can enter the following command in the terminal: `ulimit -s 1048576`. This command changes the stack size limit to $1048576\\text{KiB}=1 \\text{GiB}$.\n\nFor example, for the following program `sample.cpp`:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint f[1000005];\nvoid dfs(int a){\n\tif(a == 0){\n\t\tf[a] = 0;\n\t\treturn;\n\t}\n\tdfs(a - 1);\n\tf[a] = f[a - 1] + 1;\n}\nint main(){\n\tdfs(1000000);\n\treturn 0;\n}\n```\n\nCompile the above source code with `g++ sample.cpp -o sample` into the executable `sample`, and run it using `./sample`.\n\nIf you run this program without using the command `ulimit -s 1048576`, `sample` will crash due to stack overflow; if you run it after using the above command, the program will not crash.\n\nIn particular, when you open multiple terminals, they do not share this setting. You need to run the command in each of them.\n\nPlease note that the stack usage is counted toward the total memory usage and is subject to the memory limit together with other parts of the program.\n\n- Windows\n\nIf you are using Dev-C++ on Windows, select `Tools - Compiler Options` and fill in the following command in the area as shown: `-Wl,--stack=1073741824`. After filling it in, make sure the box “Add the following commands when compiling” is checked.\n\nHere, `1073741824` is in units of $\\text{B/Bytes}$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/z6mbzfqo.png)  ![](https://cdn.luogu.com.cn/upload/image_hosting/zvrzkyq5.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2016 提高组] 天天爱跑步", "background": "NOIP2016 提高组 D1T2", "description": "小 C 同学认为跑步非常有趣，于是决定制作一款叫做《天天爱跑步》的游戏。《天天爱跑步》是一个养成类游戏，需要玩家每天按时上线，完成打卡任务。\n\n这个游戏的地图可以看作一棵包含 $n$ 个结点和 $n-1$ 条边的树，每条边连接两个结点，且任意两个结点存在一条路径互相可达。树上结点编号为从 $1$ 到 $n$ 的连续正整数。\n\n现在有 $m$ 个玩家，第 $i$ 个玩家的起点为 $s_i$，终点为 $t_i$。每天打卡任务开始时，所有玩家在第 $0$ 秒同时从自己的起点出发，以每秒跑一条边的速度，不间断地沿着最短路径向着自己的终点跑去，跑到终点后该玩家就算完成了打卡任务。（由于地图是一棵树，所以每个人的路径是唯一的）\n\n小 C 想知道游戏的活跃度，所以在每个结点上都放置了一个观察员。在结点 $j$ 的观察员会选择在第 $w_j$ 秒观察玩家，一个玩家能被这个观察员观察到当且仅当该玩家在第 $w_j$ 秒也正好到达了结点 $j$。小 C 想知道每个观察员会观察到多少人?\n\n注意：我们认为一个玩家到达自己的终点后该玩家就会结束游戏，他不能等待一段时间后再被观察员观察到。即对于把结点 $j$ 作为终点的玩家：若他在第 $w_j$ 秒前到达终点，则在结点 $j$ 的观察员不能观察到该玩家；若他正好在第 $w_j$ 秒到达终点，则在结点 $j$ 的观察员可以观察到这个玩家。", "inputFormat": "第一行有两个整数 $n$ 和 $m$。其中 $n$ 代表树的结点数量，同时也是观察员的数量，$m$ 代表玩家的数量。\n\n接下来 $n-1$ 行每行两个整数 $u$ 和 $v$，表示结点 $u$ 到结点 $v$ 有一条边。\n\n接下来一行 $n$ 个整数，其中第 $j$ 个整数为 $w_j$，表示结点 $j$ 出现观察员的时间。\n\n接下来 $m$ 行，每行两个整数 $s_i$，和 $t_i$，表示一个玩家的起点和终点。\n\n对于所有的数据，保证 $1\\leq s_i,t_i\\leq n, 0\\leq w_j\\leq n$。", "outputFormat": "输出 $1$ 行 $n$ 个整数，第 $j$ 个整数表示结点 $j$ 的观察员可以观察到多少人。", "hint": "**样例 1 说明**\n\n对于 $1$ 号点，$w_i=0$，故只有起点为 $1$ 号点的玩家才会被观察到，所以玩家 $1$ 和玩家 $2$ 被观察到，共有 $2$ 人被观察到。\n\n对于 $2$ 号点，没有玩家在第 $2$ 秒时在此结点，共 $0$ 人被观察到。\n\n对于 $3$ 号点，没有玩家在第 $5$ 秒时在此结点，共 $0$ 人被观察到。\n\n对于 $4$ 号点，玩家 $1$ 被观察到，共 $1$ 人被观察到。\n\n对于 $5$ 号点，玩家 $1$ 被观察到，共 $1$ 人被观察到。\n\n对于 $6$ 号点，玩家 $3$ 被观察到，共 $1$ 人被观察到。\n\n**子任务**\n\n每个测试点的数据规模及特点如下表所示。\n\n提示：数据范围的个位上的数字可以帮助判断是哪一种数据类型。\n\n| 测试点编号 | $n=$ | $m=$ | 约定 |\n| :--------: | :----: | :----: | :----: |\n|     $1\\sim 2$      |  $991$   |  $991$   | 所有人的起点等于自己的终点，即 $\\forall i,\\ s_i=t_i$  |\n|     $3\\sim 4$      |  $992$   |  $992$   | 所有 $w_j=0$  |\n|     $5$      |  $993$   |  $993$   | 无  |\n|     $6\\sim 8$      |  $99994$   |  $99994$   | $\\forall i\\in[1,n-1]$，$i$ 与 $i+1$ 有边。即树退化成 $1,2,\\dots,n$ 按顺序连接的链  |\n|     $9\\sim 12$      |  $99995$   |  $99995$   | 所有 $s_i=1$  |\n|     $13\\sim 16$      |  $99996$   |  $99996$   | 所有 $t_i=1$  |\n|     $17\\sim 19$      |  $99997$   |  $99997$   | 无  |\n|     $20$      |  $299998$   |  $299998$   | 无  |\n\n\n\n**提示**\n\n（提示：由于原提示年代久远，不一定能完全反映现在的情况，现在已经对该提示做出了一定的修改，提示的原文可以在[该剪贴板](https://www.luogu.com.cn/paste/3fneb8m6)查看）\n\n在最终评测时，调用栈占用的空间大小不会有单独的限制，但在我们的工作环境中默认会有 $1 \\text{MiB}$ 的限制。 这可能会引起**函数调用层数较多时，程序发生栈溢出崩溃**，程序中**较深层数的递归**往往会导致这个问题。如果你的程序需要用到较大的栈空间，请务必注意该问题。\n\n我们可以使用一些方法修改调用栈的大小限制。\n\n- Linux\n\n我们可以在终端中输入下列命令：`ulimit -s 1048576`。此命令的意义是，将调用栈的大小限制修改为 $1048576\\text{KiB}=1 \\text{GiB}$。\n\n例如，对于如下程序 `sample.cpp`：\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint f[1000005];\nvoid dfs(int a){\n\tif(a == 0){\n\t\tf[a] = 0;\n\t\treturn;\n\t}\n\tdfs(a - 1);\n\tf[a] = f[a - 1] + 1;\n}\nint main(){\n\tdfs(1000000);\n\treturn 0;\n}\n```\n\n将上述源代码用命令 `g++ sample.cpp -o sample` 编译为可执行文件 `sample` 后，使用 `./sample` 执行程序。\n\n如果在没有使用命令 `ulimit -s 1048576` 的情况下运行该程序，`sample` 会因为栈溢出而崩溃；如果使用了上述命令后运行该程序，该程序则不会崩溃。\n\n特别地，当你打开多个终端时，它们并不会共享该命令，你需要分别对它们运行该命令。\n\n请注意，调用栈占用的空间会计入总空间占用中，和程序其他部分占用的内存共同受到内存限制。\n\n- Windows\n\n如果你使用 Windows 下的 Dev-C++，请选择 `工具-编译选项` 并在如下区域填入以下命令 `-Wl,--stack=1073741824`，填入后注意确认“编译时加入以下命令的”的框是**已勾选**状态。\n\n此处 `1073741824` 的单位是 $\\text{B/Bytes}$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/z6mbzfqo.png)  ![](https://cdn.luogu.com.cn/upload/image_hosting/zvrzkyq5.png)", "locale": "zh-CN"}}}
