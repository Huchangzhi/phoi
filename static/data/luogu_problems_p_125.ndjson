{"pid": "P3532", "type": "P", "difficulty": 6, "samples": [["6\n1\n2\n3\n4\n5\n6", "2\n1\n1\n2\n1\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2012", "POI（波兰）", "枚举"], "title": "[POI 2012] ODL-Distance", "background": "", "description": "We consider the distance between positive integers in this problem, defined as follows.\n\nA single operation consists in either multiplying a given number by a prime number1    or dividing it by a prime number (if it does divide without a remainder).\n\nThe distance between the numbers ![](http://main.edu.pl/images/OI19/odl-en-tex.1.png) and ![](http://main.edu.pl/images/OI19/odl-en-tex.2.png), denoted ![](http://main.edu.pl/images/OI19/odl-en-tex.3.png), is the minimum number of operations    it takes to transform the number ![](http://main.edu.pl/images/OI19/odl-en-tex.4.png) into the number ![](http://main.edu.pl/images/OI19/odl-en-tex.5.png).\n\nFor example, ![](http://main.edu.pl/images/OI19/odl-en-tex.6.png).\n\nObserve that the function ![](http://main.edu.pl/images/OI19/odl-en-tex.7.png) is indeed a distance function - for any positive integers ![](http://main.edu.pl/images/OI19/odl-en-tex.8.png), ![](http://main.edu.pl/images/OI19/odl-en-tex.9.png) and ![](http://main.edu.pl/images/OI19/odl-en-tex.10.png) the following hold:\n\nthe distance between a number and itself is 0: ![](http://main.edu.pl/images/OI19/odl-en-tex.11.png),                  the distance from ![](http://main.edu.pl/images/OI19/odl-en-tex.12.png) to ![](http://main.edu.pl/images/OI19/odl-en-tex.13.png) is the same as from ![](http://main.edu.pl/images/OI19/odl-en-tex.14.png) to ![](http://main.edu.pl/images/OI19/odl-en-tex.15.png): ![](http://main.edu.pl/images/OI19/odl-en-tex.16.png), and                  the triangle inequality holds: ![](http://main.edu.pl/images/OI19/odl-en-tex.17.png).\n\nA sequence of ![](http://main.edu.pl/images/OI19/odl-en-tex.18.png) positive integers, ![](http://main.edu.pl/images/OI19/odl-en-tex.19.png), is given.\n\nFor each number ![](http://main.edu.pl/images/OI19/odl-en-tex.20.png) we have to determine ![](http://main.edu.pl/images/OI19/odl-en-tex.21.png) such that ![](http://main.edu.pl/images/OI19/odl-en-tex.22.png) and ![](http://main.edu.pl/images/OI19/odl-en-tex.23.png) is minimal.", "inputFormat": "In the first line of standard input there is a single integer ![](http://main.edu.pl/images/OI19/odl-en-tex.24.png) (![](http://main.edu.pl/images/OI19/odl-en-tex.25.png)).\n\nIn the following ![](http://main.edu.pl/images/OI19/odl-en-tex.26.png) lines the numbers ![](http://main.edu.pl/images/OI19/odl-en-tex.27.png) (![](http://main.edu.pl/images/OI19/odl-en-tex.28.png)) are given,      one per line.\n\nIn tests worth 30% of total point it additionally holds that ![](http://main.edu.pl/images/OI19/odl-en-tex.29.png).\n", "outputFormat": "Your program should print exactly ![](http://main.edu.pl/images/OI19/odl-en-tex.30.png) lines to the standard output, a single integer in each line.\n\nThe ![](http://main.edu.pl/images/OI19/odl-en-tex.31.png)-th line should give the minimum ![](http://main.edu.pl/images/OI19/odl-en-tex.32.png) such that: ![](http://main.edu.pl/images/OI19/odl-en-tex.33.png), ![](http://main.edu.pl/images/OI19/odl-en-tex.34.png) and ![](http://main.edu.pl/images/OI19/odl-en-tex.35.png) is minimal.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2012] ODL-Distance", "background": "", "description": "We consider the distance between positive integers in this problem, defined as follows.\n\nA single operation consists in either multiplying a given number by a prime number1    or dividing it by a prime number (if it does divide without a remainder).\n\nThe distance between the numbers ![](http://main.edu.pl/images/OI19/odl-en-tex.1.png) and ![](http://main.edu.pl/images/OI19/odl-en-tex.2.png), denoted ![](http://main.edu.pl/images/OI19/odl-en-tex.3.png), is the minimum number of operations    it takes to transform the number ![](http://main.edu.pl/images/OI19/odl-en-tex.4.png) into the number ![](http://main.edu.pl/images/OI19/odl-en-tex.5.png).\n\nFor example, ![](http://main.edu.pl/images/OI19/odl-en-tex.6.png).\n\nObserve that the function ![](http://main.edu.pl/images/OI19/odl-en-tex.7.png) is indeed a distance function - for any positive integers ![](http://main.edu.pl/images/OI19/odl-en-tex.8.png), ![](http://main.edu.pl/images/OI19/odl-en-tex.9.png) and ![](http://main.edu.pl/images/OI19/odl-en-tex.10.png) the following hold:\n\nthe distance between a number and itself is 0: ![](http://main.edu.pl/images/OI19/odl-en-tex.11.png),                  the distance from ![](http://main.edu.pl/images/OI19/odl-en-tex.12.png) to ![](http://main.edu.pl/images/OI19/odl-en-tex.13.png) is the same as from ![](http://main.edu.pl/images/OI19/odl-en-tex.14.png) to ![](http://main.edu.pl/images/OI19/odl-en-tex.15.png): ![](http://main.edu.pl/images/OI19/odl-en-tex.16.png), and                  the triangle inequality holds: ![](http://main.edu.pl/images/OI19/odl-en-tex.17.png).\n\nA sequence of ![](http://main.edu.pl/images/OI19/odl-en-tex.18.png) positive integers, ![](http://main.edu.pl/images/OI19/odl-en-tex.19.png), is given.\n\nFor each number ![](http://main.edu.pl/images/OI19/odl-en-tex.20.png) we have to determine ![](http://main.edu.pl/images/OI19/odl-en-tex.21.png) such that ![](http://main.edu.pl/images/OI19/odl-en-tex.22.png) and ![](http://main.edu.pl/images/OI19/odl-en-tex.23.png) is minimal.", "inputFormat": "In the first line of standard input there is a single integer ![](http://main.edu.pl/images/OI19/odl-en-tex.24.png) (![](http://main.edu.pl/images/OI19/odl-en-tex.25.png)).\n\nIn the following ![](http://main.edu.pl/images/OI19/odl-en-tex.26.png) lines the numbers ![](http://main.edu.pl/images/OI19/odl-en-tex.27.png) (![](http://main.edu.pl/images/OI19/odl-en-tex.28.png)) are given,      one per line.\n\nIn tests worth 30% of total point it additionally holds that ![](http://main.edu.pl/images/OI19/odl-en-tex.29.png).\n", "outputFormat": "Your program should print exactly ![](http://main.edu.pl/images/OI19/odl-en-tex.30.png) lines to the standard output, a single integer in each line.\n\nThe ![](http://main.edu.pl/images/OI19/odl-en-tex.31.png)-th line should give the minimum ![](http://main.edu.pl/images/OI19/odl-en-tex.32.png) such that: ![](http://main.edu.pl/images/OI19/odl-en-tex.33.png), ![](http://main.edu.pl/images/OI19/odl-en-tex.34.png) and ![](http://main.edu.pl/images/OI19/odl-en-tex.35.png) is minimal.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2012] ODL-Distance", "background": "", "description": "**译自 POI 2012 Stage 1. 「[Distance](https://szkopul.edu.pl/problemset/problem/Phel_x2Ny30OUh7z1RhCtzEG/site/?key=statement)」**\n\n定义一次「操作」为将一个正整数除以或乘以一个质数。定义函数 $d(a,b)$ 表示将 $a$ 进行若干次“操作”变成 $b$ 所需要的最小操作次数。例如，$d(69,42)=3$.\n\n$d$ 显然是一个距离函数，满足以下性质：\n* $d(a,a) = 0$\n* $d(a,b) = d(b,a)$\n* $d(a,b) + d(b,c) \\ge d(a,c)$\n\n给定 $n$ 个正整数 $a_1, a_2, \\ldots, a_n$，对每个 $a_i (1 \\le i \\le n)$，求 $j$ 使得 $j \\neq i$ 且 $d(a_i,a_j)$ 最小。如果有多个满足条件的 $j$，应输出最小的那个。", "inputFormat": "第一行一个正整数 $n (2 \\le n \\le 100,000)$.\n\n第二行 $n$ 个正整数 $a_1, a_2, \\ldots, a_n (1 \\le a_i \\le 1\\ 000\\ 000)$.", "outputFormat": "输出 $n$ 行，每行一个整数，表示使 $j \\neq i$ 且 $d(a_i,a_j)$ 最小的 $j$.", "hint": "对于 $30\\%$ 的数据有 $n \\le 1000$.\n\n对于所有数据有 $2 \\le n \\le 10^5,1 \\le a_i \\le 10^6$.\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2690)。", "locale": "zh-CN"}}}
{"pid": "P3533", "type": "P", "difficulty": 5, "samples": [["12 5\n4 3 5 5 1 1 12 12 9 9 7 1\n7 2\n8 11\n1 2\n9 10\n10 5", "2 3\n1 2\n2 2\n0 1\n-1 -1"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2012", "倍增", "并查集", "POI（波兰）", "最近公共祖先 LCA", "基环树"], "title": "[POI 2012] RAN-Rendezvous", "background": "", "description": "Byteasar is a ranger who works in the Arrow Cave - a famous rendezvous destination among lovers.\n\nThe cave consists of $n$ chambers connected with one-way corridors.\n\nIn each chamber exactly one outgoing corridor is marked with an arrow.\n\nEvery corridor leads directly to some (not necessarily different) chamber.\n\nThe enamoured couples that agree to meet in the Arrow Cave are notorious for forgetting to agree upon    specific chamber, and consequently often cannot find their dates.\n\nIn the past this led to many mix-ups and misunderstandings\\dots    But ever since each chamber is equipped with an emergency telephone line to the ranger on duty,    helping the enamoured find their dates has become the rangers' main occupation.\n\nThe rangers came up with the following method.\n\nKnowing where the enamoured are, they tell each of them how many times they should follow the corridor marked with an arrow in order to meet their date.\n\nThe lovers obviously want to meet as soon as possible - after all, they came to the cave to spend time together, not to wander around alone!\n\nMost rangers are happy to oblige: they do their best to give each couple a valid pair of numbers such that their maximum is minimal.\n\nBut some rangers, among their numbers Byteasar, grew tired of this extracurricular activity and ensuing puzzles.  Byteasar has asked you to write a program    that will ease the process.  The program, given a description of the cave and the current location of $k$ couples,    should determine $k$ pairs of numbers $x_i$ and $y_i$ such that if the $i$-th couple follows respectively: he $x_i$ and she $y_i$ corridors marked with arrows,then they will meet in a single chamber of the cave $max(x_i,y_i)$ is minimal,subject to above $min(x_i,y_i)$ is minimal,if above conditions do not determine a unique solution, then the woman should cover smaller distance ($x_i\\ge y_i$).\n\nIt may happen that such numbers $x_i$ and $y_i$ do not exist - then let $x_i=y_i=-1$.  Note that it is fine for several couples    to meet in a single chamber.  Once the lovers have found their dates, they will be happy to lose themselves in the cave again...", "inputFormat": "In the first line of the standard input there are two positive integers $n$ and $k$($1\\le n,k\\le 500\\ 000$), separated by a single space, that denote   the number of chambers in the Arrow Cave and the number of couples who want to find their dates, respectively.\n\nThe chambers are numbered from 1 to $n$, while the enamoured couples are numbered from 1 to $k$.\n\nThe second line of input contains $n$ positive integers separated by single spaces:\n\nthe $i$-th such integer determines the number of chamber to which the corridor marked with an arrow going out of chamber $i$ leads.\n\nThe following $k$ lines specify the queries by the separated couples. Each such query consists of two positive integers separated by a single space - these denote the numbers of chambers where the lovers are - first him, then her.\n\nIn the tests worth 40% of the total points it additionally holds that $n,k\\le 2\\ 000$.\n", "outputFormat": "Your program should print exactly $k$ lines to the standard output,   one line per each couple specified in the input:\n\nthe $i$-th line of the output should give the instructions for the $i$-th couple on the input.\n\nI.e., the $i$-th line of output should contain the integers $x_i,y_i$, separated by a single space.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2012] RAN-Rendezvous", "background": "", "description": "Byteasar is a ranger who works in the Arrow Cave - a famous rendezvous destination among lovers.\n\nThe cave consists of $n$ chambers connected with one-way corridors.\n\nIn each chamber exactly one outgoing corridor is marked with an arrow.\n\nEvery corridor leads directly to some (not necessarily different) chamber.\n\nThe enamoured couples that agree to meet in the Arrow Cave are notorious for forgetting to agree upon    specific chamber, and consequently often cannot find their dates.\n\nIn the past this led to many mix-ups and misunderstandings\\dots    But ever since each chamber is equipped with an emergency telephone line to the ranger on duty,    helping the enamoured find their dates has become the rangers' main occupation.\n\nThe rangers came up with the following method.\n\nKnowing where the enamoured are, they tell each of them how many times they should follow the corridor marked with an arrow in order to meet their date.\n\nThe lovers obviously want to meet as soon as possible - after all, they came to the cave to spend time together, not to wander around alone!\n\nMost rangers are happy to oblige: they do their best to give each couple a valid pair of numbers such that their maximum is minimal.\n\nBut some rangers, among their numbers Byteasar, grew tired of this extracurricular activity and ensuing puzzles.  Byteasar has asked you to write a program    that will ease the process.  The program, given a description of the cave and the current location of $k$ couples,    should determine $k$ pairs of numbers $x_i$ and $y_i$ such that if the $i$-th couple follows respectively: he $x_i$ and she $y_i$ corridors marked with arrows,then they will meet in a single chamber of the cave $max(x_i,y_i)$ is minimal,subject to above $min(x_i,y_i)$ is minimal,if above conditions do not determine a unique solution, then the woman should cover smaller distance ($x_i\\ge y_i$).\n\nIt may happen that such numbers $x_i$ and $y_i$ do not exist - then let $x_i=y_i=-1$.  Note that it is fine for several couples    to meet in a single chamber.  Once the lovers have found their dates, they will be happy to lose themselves in the cave again...", "inputFormat": "In the first line of the standard input there are two positive integers $n$ and $k$($1\\le n,k\\le 500\\ 000$), separated by a single space, that denote   the number of chambers in the Arrow Cave and the number of couples who want to find their dates, respectively.\n\nThe chambers are numbered from 1 to $n$, while the enamoured couples are numbered from 1 to $k$.\n\nThe second line of input contains $n$ positive integers separated by single spaces:\n\nthe $i$-th such integer determines the number of chamber to which the corridor marked with an arrow going out of chamber $i$ leads.\n\nThe following $k$ lines specify the queries by the separated couples. Each such query consists of two positive integers separated by a single space - these denote the numbers of chambers where the lovers are - first him, then her.\n\nIn the tests worth 40% of the total points it additionally holds that $n,k\\le 2\\ 000$.\n", "outputFormat": "Your program should print exactly $k$ lines to the standard output,   one line per each couple specified in the input:\n\nthe $i$-th line of the output should give the instructions for the $i$-th couple on the input.\n\nI.e., the $i$-th line of output should contain the integers $x_i,y_i$, separated by a single space.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2012] RAN-Rendezvous", "background": "", "description": "**译自 POI 2012 Stage 1. 「[Rendezvous](https://szkopul.edu.pl/problemset/problem/MZTXfOVnJmac175TTH5Lr9Q3/site/?key=statement)」**\n\n给定一个有 $n$ 个顶点的有向图，每个顶点有且仅有一条出边。每次询问给出两个顶点 $a_i$ 和 $b_i$，求满足以下条件的 $x_i$ 和 $y_i$：\n* 从顶点 $a_i$ 沿出边走 $x_i$ 步与从顶点 $b_i$ 沿出边走 $y_i$ 步到达的顶点相同。\n* $\\max(x_i, y_i)$ 最小。\n* 满足以上条件的情况下 $\\min(x_i, y_i)$ 最小。\n* 如果以上条件没有给出一个唯一的解，则还需要满足 $x_i \\ge y_i$。\n\n如果不存在这样的 $x_i$ 和 $y_i$，则 $x_i = y_i = -1$。", "inputFormat": "第一行两个正整数 $n$ 和 $k$（$1 \\le n \\le 500\\ 000,1 \\le k \\le 500\\ 000$），表示顶点数和询问个数。\n\n接下来一行 $n$ 个正整数，第 $i$ 个数表示 $i$ 号顶点出边指向的顶点。\n\n接下来 $k$ 行表示询问，每行两个整数 $a_i$ 和 $b_i$。", "outputFormat": "对每组询问输出两个整数 $x_i$ 和 $y_i$.", "hint": "对于 $40\\%$ 的数据，$n \\le 2000,k \\le 2000$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 500\\ 000,1 \\le k \\le 500\\ 000$。", "locale": "zh-CN"}}}
{"pid": "P3534", "type": "P", "difficulty": 6, "samples": [["16 15\n8 7 6 5 5 5 5 5 6 6 7 8 9 7 5 5", "1 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "二分", "POI（波兰）", "Special Judge"], "title": "[POI 2012] STU-Well", "background": "", "description": "Byteasar has set off on a journey along the Dry River, which crosses the Byteotian Desert.\n\nUnfortunately, the Dry River has dried out, and Byteasar has run out of water.\n\nHis only hope is to dig a deep enough well in the dried river bed.\n\nRealising the graveness of his situation, Byteasar decides to plan everything carefully before he actually starts digging.\n\nThe danger is that he drains his strength before he reaches the water level - in such case he is unlikely to survive.\n\nHe managed to determine the depth of the water level.  He also knows how much he can dig before losing strength.\n\nHis only worry is a possible landslide, which might bury him alive.\n\nHe sends you (via a satellite telephone) a topographic map of the river bed.\n\nAnd, of course, he asks you to help him determine where he should dig so that he reaches water before draining his strength    while keeping the slope of his excavation as gentle as possible.\n\nHe is waiting for your advice!\n\n", "inputFormat": "In the first line of the standard input two positive integers are given, $n$ and $m$ ($1\\le n\\le 1\\ 000\\ 000$, $1\\le m\\le 10^{18}$), separated by a single space.\n\nThe second line holds $n$ positive integers $x_1,x_2,\\cdots,x_n$ ($1\\le x_i\\le 10^9$), also separated by single spaces.\n\nByteasar has enough energy to perform $m$ swings of the shovel.\n\nThe numbers $x_1,x_2,\\cdots,x_n$ describe the topography of the Dry River's bed.\n\nThey represent the depth of the sand layer above the ground water level in successive one meter spaced spots along the river bed.\n\nWith a single swing of the shovel Byteasar can extract an amount of the sand that decreases any of the numbers $x_i$ by 1.If any of these numbers, say $x_k$, drops to 0, this means that Byteasar has dug down to the water. But Byteasar has a secondary goal as well. He wants the following number $z$, characterising the slope of the sand hill, minimised:\n\n$z=max_{i=1,2,\\cdots,n-1}|x_i-x_{i+1}|$\nIf there are multiple correct values of the number $k$,representing the spot where Byteasar is to dig down to reach the water, your program can pick one arbitrarily. The spots $1,2,\\cdots,n$ are the only ones suitable for digging - elsewhere there is rock rather than sand. You may assume that Byteasar has enough energy to reach water at one of the spots.\n", "outputFormat": "Your program should print two integers to the standard output, separated by a single space:\n\nthe spot $k$, where Byteasar should dig for water, and the minimum value of the number $z$.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2012] STU-Well", "background": "", "description": "Byteasar has set off on a journey along the Dry River, which crosses the Byteotian Desert.\n\nUnfortunately, the Dry River has dried out, and Byteasar has run out of water.\n\nHis only hope is to dig a deep enough well in the dried river bed.\n\nRealising the graveness of his situation, Byteasar decides to plan everything carefully before he actually starts digging.\n\nThe danger is that he drains his strength before he reaches the water level - in such case he is unlikely to survive.\n\nHe managed to determine the depth of the water level.  He also knows how much he can dig before losing strength.\n\nHis only worry is a possible landslide, which might bury him alive.\n\nHe sends you (via a satellite telephone) a topographic map of the river bed.\n\nAnd, of course, he asks you to help him determine where he should dig so that he reaches water before draining his strength    while keeping the slope of his excavation as gentle as possible.\n\nHe is waiting for your advice!\n\n", "inputFormat": "In the first line of the standard input two positive integers are given, $n$ and $m$ ($1\\le n\\le 1\\ 000\\ 000$, $1\\le m\\le 10^{18}$), separated by a single space.\n\nThe second line holds $n$ positive integers $x_1,x_2,\\cdots,x_n$ ($1\\le x_i\\le 10^9$), also separated by single spaces.\n\nByteasar has enough energy to perform $m$ swings of the shovel.\n\nThe numbers $x_1,x_2,\\cdots,x_n$ describe the topography of the Dry River's bed.\n\nThey represent the depth of the sand layer above the ground water level in successive one meter spaced spots along the river bed.\n\nWith a single swing of the shovel Byteasar can extract an amount of the sand that decreases any of the numbers $x_i$ by 1.If any of these numbers, say $x_k$, drops to 0, this means that Byteasar has dug down to the water. But Byteasar has a secondary goal as well. He wants the following number $z$, characterising the slope of the sand hill, minimised:\n\n$z=max_{i=1,2,\\cdots,n-1}|x_i-x_{i+1}|$\nIf there are multiple correct values of the number $k$,representing the spot where Byteasar is to dig down to reach the water, your program can pick one arbitrarily. The spots $1,2,\\cdots,n$ are the only ones suitable for digging - elsewhere there is rock rather than sand. You may assume that Byteasar has enough energy to reach water at one of the spots.\n", "outputFormat": "Your program should print two integers to the standard output, separated by a single space:\n\nthe spot $k$, where Byteasar should dig for water, and the minimum value of the number $z$.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2012] STU-Well", "background": "**译自 POI 2012 Stage 1. 「[Well](https://szkopul.edu.pl/problemset/problem/S-cyTRH8ScRh-XfLPAsXCQ0e/site/?key=statement)」**\n\n翻译来自 [LOJ](https://loj.ac/p/2692)。", "description": "\n给定 $n$ 个正整数 $x_1, x_2, \\ldots, x_n$，可以进行不超过 $m$ 次操作，每次操作时选择一个正整数 $x_i$ 并将其减一。\n\n在存在 $k$ 使得 $x_k=0$ 的情况下，最小化\n$$ z = \\max_{i=1,2,\\ldots,n-1}{\\lvert x_i - x_{i+1} \\rvert} $$\n\n求最小的 $z$ 和对应的 $k$。如果有多组解，可以输出任意一组。", "inputFormat": "第一行两个正整数 $n, m (1 \\le n \\le 1\\ 000\\ 000, 1 \\le m \\le 10^{18})$，表示正整数的个数和操作的次数。\n\n第二行 $n$ 个正整数 $x_1, x_2, \\ldots, x_n (1 \\le x_i \\le 10^9)$。", "outputFormat": "输出两个正整数，分别表示 $k$ 和 $z$。", "hint": "\n\n![](https://szkopul.edu.pl/problemset/problem/3oC6jWN7HZAUhEGLlHdF_ci2/site/images/OI19/stu0.gif)\n\n\n对于 $35\\%$ 的数据，$n \\le 10\\ 000$；\n\n对于所有数据，$1 \\le n \\le 1\\ 000\\ 000, 1 \\le m \\le 10^{18},1 \\le x_i \\le 10^9$。\n", "locale": "zh-CN"}}}
{"pid": "P3535", "type": "P", "difficulty": 4, "samples": [["11 13 5\n1 2\n1 3\n1 5\n3 5\n2 8\n4 11\n7 11\n6 10\n6 9\n2 3\n8 9\n5 9\n9 10", "3\n2 3\n5 9\n3 5"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "2012", "并查集", "POI（波兰）", "Special Judge"], "title": "[POI 2012] TOU-Tour de Byteotia", "background": null, "description": "**译自 POI 2012 Stage 2. Day 0「[Tour de Byteotia](https://szkopul.edu.pl/problemset/problem/mormqC6WwjeIiBpSNMhVbHni/site/?key=statement)」**\n\n给定一个 $n$ 个点、$m$ 条边的**无向图**，问最少删掉多少条边能使得编号小于等于 $k$ 的点都不在任何一条简单环上。", "inputFormat": "第一行包含三个整数 $n$、$m$、$k$，分别表示 $n$ 个节点， $m$ 条边，$k$ 意义见题面。\n\n接下来 $m$ 行，每行两个整数 $u$、$v$，表示一条由 $u$ 到 $v$ 的**双向边**。数据保证**没有重边**。", "outputFormat": "第一行一个整数 $cnt$，表示最少的删边数量；\n\n接下来 $cnt$ 行，每行输出两个正整数 $a,b$，表示删除 $a,b$ 之间的一条边。先输出编号小的点，再输出编号大的点。", "hint": "样例配图如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gs7p4m5e.png)\n\n对于 $40\\%$ 的数据，$n \\le 1000$，$m \\le 5000$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10^6$，$0 \\le m \\le 2\\times10^6$，$1 \\le k \\le n$，$1 \\le u \\lt v \\le n$。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2693)。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2012] TOU-Tour de Byteotia", "background": "", "description": "**Translated from POI 2012 Stage 2. Day 0 「[Tour de Byteotia](https://szkopul.edu.pl/problemset/problem/mormqC6WwjeIiBpSNMhVbHni/site/?key=statement)」.**\n\nGiven an undirected graph with $n$ vertices and $m$ edges, find the minimum number of edges to delete so that all vertices with indices less than or equal to $k$ are not on any simple cycle.", "inputFormat": "The first line contains three integers $n$, $m$, and $k$, denoting $n$ vertices, $m$ edges, and $k$ as defined above.\n\nThen follow $m$ lines, each containing two integers $u$ and $v$, representing an undirected edge between $u$ and $v$. It is guaranteed that there are no multiple edges.", "outputFormat": "The first line contains an integer $cnt$, the minimum number of edges to delete.\n\nThen output $cnt$ lines, each containing two positive integers $a$ and $b$, indicating that the edge between $a$ and $b$ is deleted. Output the smaller vertex first, then the larger one.", "hint": "The sample illustration is as follows.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gs7p4m5e.png)\n\nFor $40\\%$ of the testdata, $n \\le 1000$, $m \\le 5000$.\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 10^6$, $0 \\le m \\le 2\\times10^6$, $1 \\le k \\le n$, $1 \\le u \\lt v \\le n$.\n\nTranslated from [LibreOJ](https://loj.ac/p/2693).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2012] TOU-Tour de Byteotia", "background": null, "description": "**译自 POI 2012 Stage 2. Day 0「[Tour de Byteotia](https://szkopul.edu.pl/problemset/problem/mormqC6WwjeIiBpSNMhVbHni/site/?key=statement)」**\n\n给定一个 $n$ 个点、$m$ 条边的**无向图**，问最少删掉多少条边能使得编号小于等于 $k$ 的点都不在任何一条简单环上。", "inputFormat": "第一行包含三个整数 $n$、$m$、$k$，分别表示 $n$ 个节点， $m$ 条边，$k$ 意义见题面。\n\n接下来 $m$ 行，每行两个整数 $u$、$v$，表示一条由 $u$ 到 $v$ 的**双向边**。数据保证**没有重边**。", "outputFormat": "第一行一个整数 $cnt$，表示最少的删边数量；\n\n接下来 $cnt$ 行，每行输出两个正整数 $a,b$，表示删除 $a,b$ 之间的一条边。先输出编号小的点，再输出编号大的点。", "hint": "样例配图如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gs7p4m5e.png)\n\n对于 $40\\%$ 的数据，$n \\le 1000$，$m \\le 5000$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10^6$，$0 \\le m \\le 2\\times10^6$，$1 \\le k \\le n$，$1 \\le u \\lt v \\le n$。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2693)。", "locale": "zh-CN"}}}
{"pid": "P3536", "type": "P", "difficulty": 5, "samples": [["4\n1\n6\n8\n16\n3\n4\n2\n4", "3\n2\n4\n6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2012", "POI（波兰）"], "title": "[POI 2012] BON-Vouchers", "background": "", "description": "The candy shop owned by Byteasar sells delicious caramel candy.\n\nFor every positive integer $c$ there is exactly one package that contains $c$ candies; currently no new deliveries are expected.\n\nTo encourage customers to buy the sweets, Byteasar has planted $m$ vouchers for an annual supply of chocolate into some packages,  making sure to put at most one voucher in each package.\n\nThe carnival starts next week in Byteburg, and it will last $n$ days;  on the $k$-th day of the carnival a party with $a_k$ guests will be held.\n\nByteasar is confident that on the $k$-th day's morning each of those guests is going to buy, in his own store, the smallest package  of candy available whose content can be equally distributed between the party guests.  For example, if $n=2$, $a_1=4$, $a_2=2$,  then on the first day of the carnival he expects to sell the packages containing four, eight, twelve, and sixteen candies, selling  those with two and six candies on the second day.\n\nNow he is wondering which customers will end up with the packages holding the vouchers.\n\nHe has asked you to write a program that will determine this for him.\n\n定义n个数为幸运数字，一共有n批人，设第i批人有x个，则它们会依次取走余下的x的倍数中最小的x个，问哪些人去走了幸运数字\n", "inputFormat": "On the first line of the standard input there is a single integer $m$ ($1\\le m\\le 1\\ 000\\ 000$) that denotes the number of vouchers.\n\nThe $k$-th of the $m$ lines that follow holds an integer $b_k$ ($1\\le b_k\\le 1\\ 000\\ 000$)denoting the size (i.e., the number of candies inside) of a package in which Byteasar has placed the $k$-th voucher.\n\nThese numbers are given in an increasing order.\n\nThen the next line contains a single integer $n$ ($1\\le n\\le 1\\ 000\\ 000$) that denotes the number of carnival days.\n\nThe $k$-th of the $n$ lines that follow holds an integer $a_k$($1\\le a_k\\le 1\\ 000\\ 000$)denoting the number of guests attending the $k$-th party.\n\nYou may assume that in tests worth at least 50% of the total points none of the numbers given on the input exceeds $5\\ 000$.\n", "outputFormat": "In the first line of the standard output your program should print an integer $z$ - the number of packages with vouchers sold.\n\nThe following $z$ lines should specify the numbers of those customers who bought a package with a voucher, in an increasing order.\n\nThe customers are numbered from $1$ in the order of their purchases.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2012] BON-Vouchers", "background": "", "description": "The candy shop owned by Byteasar sells delicious caramel candy.\n\nFor every positive integer $c$ there is exactly one package that contains $c$ candies; currently no new deliveries are expected.\n\nTo encourage customers to buy the sweets, Byteasar has planted $m$ vouchers for an annual supply of chocolate into some packages,  making sure to put at most one voucher in each package.\n\nThe carnival starts next week in Byteburg, and it will last $n$ days;  on the $k$-th day of the carnival a party with $a_k$ guests will be held.\n\nByteasar is confident that on the $k$-th day's morning each of those guests is going to buy, in his own store, the smallest package  of candy available whose content can be equally distributed between the party guests.  For example, if $n=2$, $a_1=4$, $a_2=2$,  then on the first day of the carnival he expects to sell the packages containing four, eight, twelve, and sixteen candies, selling  those with two and six candies on the second day.\n\nNow he is wondering which customers will end up with the packages holding the vouchers.\n\nHe has asked you to write a program that will determine this for him.\n\n定义n个数为幸运数字，一共有n批人，设第i批人有x个，则它们会依次取走余下的x的倍数中最小的x个，问哪些人去走了幸运数字\n", "inputFormat": "On the first line of the standard input there is a single integer $m$ ($1\\le m\\le 1\\ 000\\ 000$) that denotes the number of vouchers.\n\nThe $k$-th of the $m$ lines that follow holds an integer $b_k$ ($1\\le b_k\\le 1\\ 000\\ 000$)denoting the size (i.e., the number of candies inside) of a package in which Byteasar has placed the $k$-th voucher.\n\nThese numbers are given in an increasing order.\n\nThen the next line contains a single integer $n$ ($1\\le n\\le 1\\ 000\\ 000$) that denotes the number of carnival days.\n\nThe $k$-th of the $n$ lines that follow holds an integer $a_k$($1\\le a_k\\le 1\\ 000\\ 000$)denoting the number of guests attending the $k$-th party.\n\nYou may assume that in tests worth at least 50% of the total points none of the numbers given on the input exceeds $5\\ 000$.\n", "outputFormat": "In the first line of the standard output your program should print an integer $z$ - the number of packages with vouchers sold.\n\nThe following $z$ lines should specify the numbers of those customers who bought a package with a voucher, in an increasing order.\n\nThe customers are numbered from $1$ in the order of their purchases.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2012] BON-Vouchers", "background": null, "description": "Byteasar 经营着一家焦糖店。\n\n对于所有正整数 $c$，Byteasar 都有且仅有一个装有 $c$ 个糖果的包裹。\n\nByteasar 准备了 $m$ 张代金券，并在装有 $b_i$ 个糖果的包裹里分别放入一张。\n\n现在共有 $n$ 批顾客，第 $i$ 批客人有 $a_i$ 人，且每名顾客会买走装有最少糖果的包裹，满足这些糖果可平均分给这一批的 $a_i$ 个人。例如，若 $n = 2, a_1 = 4, a_2 = 2$，则第一批顾客买走的糖果数量分别为  $4, 8, 12, 16$，第二批顾客买走的糖果数量分别为 $2, 6$。\n\n将所有顾客按顺序从 $1$ 开始编号，Byteasar 想知道取走代金券的顾客数量和各自的编号。", "inputFormat": "第一行输入一个整数 $m$ ($1 \\le m \\le 1\\ 000\\ 000$)，表示代金券总数。\n\n接下来 $m$ 行，输入 $m$ 个整数 $b_1,b_2,\\cdots, b_m$ ($1 \\le b_i \\le 1\\ 000\\ 000$)，分别代表放入代金券的包裹装有的糖果数量，保证 $b_i$ 单调递增。\n\n接下来输入一个整数 $n$ ($1 \\le n \\le 1\\ 000\\ 000$)，表示共有 $n$ 批顾客。\n\n接下来 $n$ 行，输入 $n$ 个整数 $a_1,a_2,\\cdots, a_n$ ($1 \\le a_i \\le 1\\ 000\\ 000$)，分别代表每批顾客的人数。\n\n对于不少于 $50\\%$ 的数据，保证输入的所有数字不超过 $5\\ 000$。", "outputFormat": "第一行一个整数 $z$，代表获得代金券的顾客数量。\n\n接下来 $z$ 行每行一个整数，从小到大输出获得代金券的顾客编号。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3537", "type": "P", "difficulty": 5, "samples": [["5\n6 2 7\n5 4 9\n1 2 4\n2 5 8\n1 3 9\n5\n2 7 1\n2 7 2\n3 2 0\n5 7 2\n4 1 5", "TAK\nNIE\nTAK\nTAK\nNIE"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "2012", "POI（波兰）"], "title": "[POI 2012] SZA-Cloakroom", "background": "", "description": "The annual rich citizen's reunion is taking place in Byteotia.\n\nThey meet to boast about their incomes, Lebytene's shoes and other luxuries.\n\nNaturally, not all these objects of pride are carried into the banquet - coats,  jackets, umbrellas and such are left in the cloakroom, and picked up upon leave.\n\nUnfortunately for the well off, a gang of Byteotian thieves plans to break into  the cloakroom and steal part of the items stored therein.\n\nAt this very moment the gang's leader is examining the plans of the robbery put  forward by other gang members (they are a democratic lot!).\n\nA plan typically looks as follows: the thieves break into the cloakroom at time $m_j$,  take items worth exactly $k_j$ and escape, where the whole heist takes them $s_j$ time.\n\nThe gang leader would first of all like to know which of these plans are feasible and which are not.\n\nA plan is feasible if at time $m_j$ it is possible to collect items of total value $k_j$ in such a way  that up to the very $m_j+s_j$ moment no one shows up to retrieve any of the stolen goods  (in such event, they would notify security, and the robbery would fail).\n\nIn particular, if at time $m_j$ it is impossible to select items of exact total worth $k_j$,  then the plan is infeasible and consequently rejected.\n\nKnowing the drop off and retrieval times for each item, determine which plans are feasible and which are not.\n\nWe assume that an item left in the cloakroom the moment a robbery starts can already be stolen (see the example).\n", "inputFormat": "In the first line of the standard input there is a single integer $n$($1\\le n\\le 1\\ 000$) denoting the number of items that will be left in the cloakroom.\n\nThose items are described in the $n$ lines that follow.\n\nEach of those lines consists of three integers $c_i$, $a_i$, and $b_i$ ($1\\le c_i\\le 1\\ 000$, $1\\le a_i<b_i\\le 10^9$),  separated by single spaces, that denote respectively: the item's value, the moment it is left in the cloakroom,  and the moment it will be retrieved by the owner.\n\nThe next line holds an integer $p$ ($1\\le p\\le 1\\ 000\\ 000$),the number of plans the gang came up with. Each is specified in a separate line by three integers,$m_j$,$k_j$ and $s_j$($1\\le m_j\\le 10^9$,$1\\le k_j\\le 100\\ 000$,$0\\le s_j\\le 10^9$), separated by single spaces, that denote respectively: the moment the thieves would enter the cloakroom, the value of goods they would like to steal, and the time the robbery would take them.\n\nIn test worth 16% of the total points $p\\le 10$ holds in addition.\n\nn some other tests, also worth 16% of the points, all the items have the same $a_i$ values.\n\nIn yet other tests, worth 24% of the points, all the queries share the same $s_j$ value.\n", "outputFormat": "For each plan put forward by the gang determine if it is feasible, i.e., whether it is possible  to steal items of total worth exactly $k_j$ and escape before anyone asks for their belongings.\n\nIf the plan is feasible, your program should print the word TAK (Polish for yes) on the  standard output, otherwise it should print NIE (Polish for no).\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2012] SZA-Cloakroom", "background": "", "description": "The annual rich citizen's reunion is taking place in Byteotia.\n\nThey meet to boast about their incomes, Lebytene's shoes and other luxuries.\n\nNaturally, not all these objects of pride are carried into the banquet - coats,  jackets, umbrellas and such are left in the cloakroom, and picked up upon leave.\n\nUnfortunately for the well off, a gang of Byteotian thieves plans to break into  the cloakroom and steal part of the items stored therein.\n\nAt this very moment the gang's leader is examining the plans of the robbery put  forward by other gang members (they are a democratic lot!).\n\nA plan typically looks as follows: the thieves break into the cloakroom at time $m_j$,  take items worth exactly $k_j$ and escape, where the whole heist takes them $s_j$ time.\n\nThe gang leader would first of all like to know which of these plans are feasible and which are not.\n\nA plan is feasible if at time $m_j$ it is possible to collect items of total value $k_j$ in such a way  that up to the very $m_j+s_j$ moment no one shows up to retrieve any of the stolen goods  (in such event, they would notify security, and the robbery would fail).\n\nIn particular, if at time $m_j$ it is impossible to select items of exact total worth $k_j$,  then the plan is infeasible and consequently rejected.\n\nKnowing the drop off and retrieval times for each item, determine which plans are feasible and which are not.\n\nWe assume that an item left in the cloakroom the moment a robbery starts can already be stolen (see the example).\n", "inputFormat": "In the first line of the standard input there is a single integer $n$($1\\le n\\le 1\\ 000$) denoting the number of items that will be left in the cloakroom.\n\nThose items are described in the $n$ lines that follow.\n\nEach of those lines consists of three integers $c_i$, $a_i$, and $b_i$ ($1\\le c_i\\le 1\\ 000$, $1\\le a_i<b_i\\le 10^9$),  separated by single spaces, that denote respectively: the item's value, the moment it is left in the cloakroom,  and the moment it will be retrieved by the owner.\n\nThe next line holds an integer $p$ ($1\\le p\\le 1\\ 000\\ 000$),the number of plans the gang came up with. Each is specified in a separate line by three integers,$m_j$,$k_j$ and $s_j$($1\\le m_j\\le 10^9$,$1\\le k_j\\le 100\\ 000$,$0\\le s_j\\le 10^9$), separated by single spaces, that denote respectively: the moment the thieves would enter the cloakroom, the value of goods they would like to steal, and the time the robbery would take them.\n\nIn test worth 16% of the total points $p\\le 10$ holds in addition.\n\nn some other tests, also worth 16% of the points, all the items have the same $a_i$ values.\n\nIn yet other tests, worth 24% of the points, all the queries share the same $s_j$ value.\n", "outputFormat": "For each plan put forward by the gang determine if it is feasible, i.e., whether it is possible  to steal items of total worth exactly $k_j$ and escape before anyone asks for their belongings.\n\nIf the plan is feasible, your program should print the word TAK (Polish for yes) on the  standard output, otherwise it should print NIE (Polish for no).\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2012] SZA-Cloakroom", "background": null, "description": "每年，Byteotia 举行富人聚会。\n\n他们聚在一起炫耀他们的收入、Lebytene 的鞋子和其他奢侈品。\n\n当然，并不是所有这些物品都会被带入宴会——大衣、夹克、雨伞等会被留在衣帽间，离开时再取走。\n\n不幸的是，一伙 Byteotia 小偷计划闯入衣帽间，偷走其中的一部分物品。\n\n此时此刻，团伙的头目正在审查其他团伙成员提出的抢劫计划（他们是民主的！）。\n\n计划通常如下：小偷在时间 $m_j$ 闯入衣帽间，拿走价值正好为 $k_j$ 的物品并逃跑，整个抢劫过程耗时 $s_j$。\n\n团伙头目首先想知道这些计划中哪些是可行的，哪些不可行。\n\n一个计划是可行的，当且仅当在时间 $m_j$ 可以收集总价值为 $k_j$ 的物品，并且直到 $m_j+s_j$ 时刻没有人出现取回任何被盗物品（在这种情况下，他们会通知保安，抢劫就会失败）。\n\n特别地，如果在时间 $m_j$ 不可能选择总价值正好为 $k_j$ 的物品，那么计划不可行，因此被拒绝。\n\n已知每件物品的存放和取回时间，确定哪些计划是可行的，哪些不可行。\n\n我们假设在抢劫开始的那一刻留在衣帽间的物品已经可以被偷走（见例子）。", "inputFormat": "输入的第一行有一个整数 $n$（$1\\le n\\le 1000$），表示将留在衣帽间的物品数量。\n\n接下来的 $n$ 行描述这些物品。\n\n每行由三个整数 $c_i$，$a_i$ 和 $b_i$（$1\\le c_i\\le 1\\ 000$, $1\\le a_i<b_i\\le 10^9$）组成，分别表示：物品的价值、存放在衣帽间的时刻以及将被主人取回的时刻。\n\n下一行包含一个整数 $p$（$1\\le p\\le 10^6$），表示团伙提出的计划数量。每行三个整数 $m_j$、$k_j$ 和 $s_j$（$1\\le m_j\\le 10^9$, $1\\le k_j\\le 10^5$, $0\\le s_j\\le 10^9$），分别表示一个计划中：小偷进入衣帽间的时刻、他们想要偷走的物品的价值以及抢劫所需的时间。\n\n对于 $16\\%$ 的数据，$p\\le 10$。\n\n对于另外 $16\\%$ 的数据，所有物品的 $a_i$ 相同。\n\n对于另外 $24\\%$ 的数据，所有查询的 $s_j$ 相同。", "outputFormat": "对于团伙提出的每个计划，确定它是否可行，即是否可以在不被任何人要求归还物品之前偷走总价值正好为 $k_j$ 的物品并逃跑。\n\n如果计划可行，程序需标准输出中打印单词 `TAK`（波兰语中的“是”），否则打印 `NIE`（波兰语中的“否”）。", "hint": "题面翻译由 ChatGPT-4o 提供，fixed by @tallnut。", "locale": "zh-CN"}}}
{"pid": "P3538", "type": "P", "difficulty": 6, "samples": [["8\naaabcabc\n3\n1 3\n3 8\n4 8", "1\n3\n5"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2012", "POI（波兰）", "哈希 hashing"], "title": "[POI 2012] OKR-A Horrible Poem", "background": "", "description": "Byteie boy has to learn a fragment of a certain poem by heart. The poem, following the best lines of modern art, is a long string consisting of lowercase English alphabet letters only. Obviously, it sounds horrible, but that is the least of Byteie's worries. First and foremost, he completely forgot which fragment is he supposed to learn. And they all look quite difficult to memorize...\n\nThere is hope, however: some parts of the poem exhibit certain regularity. In particular, every now and then a fragment, say $A$, is but a multiple repetition of another fragment, say $B$ (in other words, $A = BB\\cdots B$, i.e., $A = B^k$, where $k\\geq1$ is an integer). In such case we say that $B$ is a full period of $A$ (in particular, every string is its own full period). If a given fragment has a short full period, Byteie's task will be easy. The question remains... which fragment was that?\n\nMake a gift for Byteie - write a program that will read the whole poem as well as a list of fragments that Byteie suspects might be the one he is supposed to memorize, and for each of them determines its shortest full period.", "inputFormat": "In the first line of the standard input there is a single integer $n$ ($1\\leq n\\leq500,000$). In the second line there is a string of length $n$ consisting of lowercase English alphabet letters - the poem. We number the positions of its successive characters from $1$ to $n$.\n\nThe next line holds a single integer $q$ ($1\\leq q\\leq2,000,000$) denoting the number of fragments. Then the following $q$ lines give queries, one per line. Each query is a pair of integers $a_i$ and $b_i$ ($1\\leq a_i\\leq b_i\\leq n$), separated by a single space, such that the answer to the query should be the length of the shortest full period of the poem's fragment that begins at position $a_i$ and ends at position $b_i$.\n\nIn tests worth in total 42% of the points $n\\leq10,000$ holds in addition. In some of those, worth 30% of points in total, $q\\leq10,000$ holds as well.", "outputFormat": "Your program should print $q$ lines on the standard output. The $i$ - th of these lines should hold a single integer - the answer to the $i$ - th query. ", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2012] OKR-A Horrible Poem", "background": "", "description": "Byteie boy has to learn a fragment of a certain poem by heart. The poem, following the best lines of modern art, is a long string consisting of lowercase English alphabet letters only. Obviously, it sounds horrible, but that is the least of Byteie's worries. First and foremost, he completely forgot which fragment is he supposed to learn. And they all look quite difficult to memorize...\n\nThere is hope, however: some parts of the poem exhibit certain regularity. In particular, every now and then a fragment, say $A$, is but a multiple repetition of another fragment, say $B$ (in other words, $A = BB\\cdots B$, i.e., $A = B^k$, where $k\\geq1$ is an integer). In such case we say that $B$ is a full period of $A$ (in particular, every string is its own full period). If a given fragment has a short full period, Byteie's task will be easy. The question remains... which fragment was that?\n\nMake a gift for Byteie - write a program that will read the whole poem as well as a list of fragments that Byteie suspects might be the one he is supposed to memorize, and for each of them determines its shortest full period.", "inputFormat": "In the first line of the standard input there is a single integer $n$ ($1\\leq n\\leq500,000$). In the second line there is a string of length $n$ consisting of lowercase English alphabet letters - the poem. We number the positions of its successive characters from $1$ to $n$.\n\nThe next line holds a single integer $q$ ($1\\leq q\\leq2,000,000$) denoting the number of fragments. Then the following $q$ lines give queries, one per line. Each query is a pair of integers $a_i$ and $b_i$ ($1\\leq a_i\\leq b_i\\leq n$), separated by a single space, such that the answer to the query should be the length of the shortest full period of the poem's fragment that begins at position $a_i$ and ends at position $b_i$.\n\nIn tests worth in total 42% of the points $n\\leq10,000$ holds in addition. In some of those, worth 30% of points in total, $q\\leq10,000$ holds as well.", "outputFormat": "Your program should print $q$ lines on the standard output. The $i$ - th of these lines should hold a single integer - the answer to the $i$ - th query. ", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2012] OKR-A Horrible Poem", "background": null, "description": "Byteie 男孩需要背诵一首诗的某个片段。这首诗遵循现代艺术的最高标准，是一个仅由小写英文字母组成的长字符串。显然，它听起来很糟糕，但这还不是 Byteie 最担心的。首先，他完全忘记了自己该背诵哪个片段。而且所有片段看起来都很难记……\n\n不过仍有希望：诗中某些部分呈现出特定的规律性。特别是，时常会出现某个片段（记作 $A$）仅是另一个片段（记作 $B$）的多次重复（即 $A = BB\\cdots B$，可表示为 $A = B^k$，其中 $k\\geq1$ 为整数）。这种情况下，我们称 $B$ 是 $A$ 的一个**完整周期**（特别地，每个字符串都是其自身的完整周期）。如果一个片段存在很短的完整周期，Byteie 的任务就会变得简单。问题在于……到底是哪个片段呢？\n\n送给 Byteie 一份礼物吧——编写一个程序，它会读入整首诗以及 Byteie 怀疑可能需要背诵的片段列表，并针对每个片段找出其**最短的完整周期**", "inputFormat": "第一行：一个整数 $n$ ($1\\leq n\\leq500,000$)，表示诗的长度。\n\n第二行：一个长度为 $n$ 的字符串，表示诗的内容。字符串中字符的位置依次编号为 $1$ 到 $n$。\n\n第三行：一个整数 $q$ ($1\\leq q\\leq2,000,000$)，表示查询的片段数量。\n\n接下来的 $q$ 行：每行包含两个整数 $a_i$ 和 $b_i$ ($1\\leq a_i\\leq b_i\\leq n$)，用空格分隔。表示查询从位置 $a_i$ 开始到位置 $b_i$ 结束的诗的片段的最短完整周期的长度。\n\n在总计占比 $42\\%$ 分数的测试点中，额外满足 $n\\leq10,000$。其中占比 $30\\%$ 分数的测试点还满足 $q\\leq10,000$。", "outputFormat": "输出 $q$ 行到标准输出。第 $i$ 行输出一个整数，表示第 $i$ 个查询的答案。", "hint": "题面翻译由 deepseek-R1 提供。", "locale": "zh-CN"}}}
{"pid": "P3539", "type": "P", "difficulty": 6, "samples": [["1\n1070", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2012", "POI（波兰）"], "title": "[POI 2012] ROZ-Fibonacci Representation", "background": "", "description": "The Fibonacci sequence is a sequence of integers, called Fibonacci numbers, defined as follows:\n\n$Fib_{0}=0,Fib_{1}=1,Fib_{n}=Fib_{n-2}+Fib_{n-1}\\ for\\ n>1$\n\nIts initial elements are: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...\n\nByteasar investigates representations of numbers as sums or differences of Fibonacci numbers. Currently he is wondering what is the minimum representation, i.e., one with the minimum number of (not necessarily different) Fibonacci numbers, for a given positive integer $k$ . For example, the numbers 10, 19, 17, and 1070 can be minimally represented using, respectively, 2, 2, 3, and 4 Fibonacci numbers as follows:\n\n$10=5+5$\n\n$19=21-2$\n\n$17=13+5-1$\n\n$1070=987+89-5-1$\n\nHelp Byteasar! Write a program that, for a given positive integer $k$ determines the minimum number of Fibonacci numbers required to represent $k$ as their sum or difference.", "inputFormat": "In the first line of the standard input a single positive integer $p$ is given ($1\\le p\\le 10$) that denotes the number of queries. The following $p$ lines hold a single positive integer $k$ each ($1\\le k\\le 1\\times 10^{17}$).\n", "outputFormat": "For each query your program should print on the standard output the minimum number of Fibonacci numbers needed to represent the number $k$ as their sum or difference.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2012] ROZ-Fibonacci Representation", "background": "", "description": "The Fibonacci sequence is a sequence of integers, called Fibonacci numbers, defined as follows:\n\n$Fib_{0}=0,Fib_{1}=1,Fib_{n}=Fib_{n-2}+Fib_{n-1}\\ for\\ n>1$\n\nIts initial elements are: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...\n\nByteasar investigates representations of numbers as sums or differences of Fibonacci numbers. Currently he is wondering what is the minimum representation, i.e., one with the minimum number of (not necessarily different) Fibonacci numbers, for a given positive integer $k$ . For example, the numbers 10, 19, 17, and 1070 can be minimally represented using, respectively, 2, 2, 3, and 4 Fibonacci numbers as follows:\n\n$10=5+5$\n\n$19=21-2$\n\n$17=13+5-1$\n\n$1070=987+89-5-1$\n\nHelp Byteasar! Write a program that, for a given positive integer $k$ determines the minimum number of Fibonacci numbers required to represent $k$ as their sum or difference.", "inputFormat": "In the first line of the standard input a single positive integer $p$ is given ($1\\le p\\le 10$) that denotes the number of queries. The following $p$ lines hold a single positive integer $k$ each ($1\\le k\\le 1\\times 10^{17}$).\n", "outputFormat": "For each query your program should print on the standard output the minimum number of Fibonacci numbers needed to represent the number $k$ as their sum or difference.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2012] ROZ-Fibonacci Representation", "background": "", "description": "**译自 POI 2012 Stage 2. Day 2「[Rozkład Fibonacciego](https://szkopul.edu.pl/problemset/problem/w1QbhPufazp-sH6X-u4pTnNu/site/?key=statement)」**\n\n给定正整数 $k$，求用斐波那契数的和或差表示 $k$ 所需要的斐波那契数数量最小值，例如：\n- $10=5+5$\n- $19=21-2$\n- $17=13+5-1$\n- $1070=987+89-5-1$", "inputFormat": "第一行一个整数 $p (1 \\le p \\le 10)$ 表示询问的数量。\n\n接下来 $p$ 行每行一个整数 $k (1 \\le k \\le 4 \\cdot 10^{17})$。", "outputFormat": "对每个询问输出一个整数，表示最少需要的斐波那契数数量。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2697)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3540", "type": "P", "difficulty": 6, "samples": [["4\n3 5 4 7 6 5", "1\n1 2 3 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2012", "POI（波兰）", "Special Judge"], "title": "[POI 2012] SQU-Squarks", "background": "", "description": "A famous Byteotian physicist Byteasar is studying a new constituent of matter - squarks.\n\nThese are quite exotic particles that never exist alone but always in pairs.\n\nMoreover, squarks of a particular kind form pairs only with squarks of different kinds.\n\nAfter years of studies Byteasar has established that there are ![](http://main.edu.pl/images/OI19/squ-en-tex.1.png) different kinds of squarks.\n\nSquarks of each kind have a unique mass, which is a positive integer multiple of (an appropriate) unit.\n\nByteasar has also measured the total mass of each of the ![](http://main.edu.pl/images/OI19/squ-en-tex.2.png) possible pairs of squarks.\n\nAccording to standard Byteotian model of physics, the mass of a pair of squarks equals the sum of the masses    of the two squarks forming it.\n\nNow Byteasar desires to determine the individual masses of squarks of every kind.\n\nHe has asked your help in writing a program that will determine all solutions to this puzzle,    i.e., will reconstruct all configurations of squark masses that are consistent with his previous measurements.", "inputFormat": "In the first line of the standard input there is a single integer ![](http://main.edu.pl/images/OI19/squ-en-tex.3.png) (![](http://main.edu.pl/images/OI19/squ-en-tex.4.png))      that denotes the number of different kinds of squarks.\n\nIn the second line there are ![](http://main.edu.pl/images/OI19/squ-en-tex.5.png) positive integers, separated by single spaces,      that denote the total masses of all possible pairs of squarks.\n\nThe mass of every pair does not exceed ![](http://main.edu.pl/images/OI19/squ-en-tex.6.png).\n\nFor each two different kinds of squarks, the mass of the pair they form is given on the input exactly once.\n\n      The masses on the input are given in a random order.\n\nIn tests worth 32% of the points the following conditions hold in addition:\n\n![](http://main.edu.pl/images/OI19/squ-en-tex.7.png) and the mass of every pair of squarks does not exceed ![](http://main.edu.pl/images/OI19/squ-en-tex.8.png).\n", "outputFormat": "In the first line of the standard output your program should print the number ![](http://main.edu.pl/images/OI19/squ-en-tex.9.png) of possible solutions to the problem.\n\nIn the ![](http://main.edu.pl/images/OI19/squ-en-tex.10.png) lines that follow it should report successive solutions, one per line.\n\nEach solution should consist of ![](http://main.edu.pl/images/OI19/squ-en-tex.11.png) different positive integers, namely the masses of squarks of all kinds.\n\nIn every solution these should be given in increasing order and separated by single spaces.\n\nSolutions can be reported in arbitrary order, but they cannot be repeated.\n\nYou may assume that for each test data there exists at least one solution, i.e., ![](http://main.edu.pl/images/OI19/squ-en-tex.12.png).\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2012] SQU-Squarks", "background": "", "description": "A famous Byteotian physicist Byteasar is studying a new constituent of matter - squarks.\n\nThese are quite exotic particles that never exist alone but always in pairs.\n\nMoreover, squarks of a particular kind form pairs only with squarks of different kinds.\n\nAfter years of studies Byteasar has established that there are ![](http://main.edu.pl/images/OI19/squ-en-tex.1.png) different kinds of squarks.\n\nSquarks of each kind have a unique mass, which is a positive integer multiple of (an appropriate) unit.\n\nByteasar has also measured the total mass of each of the ![](http://main.edu.pl/images/OI19/squ-en-tex.2.png) possible pairs of squarks.\n\nAccording to standard Byteotian model of physics, the mass of a pair of squarks equals the sum of the masses    of the two squarks forming it.\n\nNow Byteasar desires to determine the individual masses of squarks of every kind.\n\nHe has asked your help in writing a program that will determine all solutions to this puzzle,    i.e., will reconstruct all configurations of squark masses that are consistent with his previous measurements.", "inputFormat": "In the first line of the standard input there is a single integer ![](http://main.edu.pl/images/OI19/squ-en-tex.3.png) (![](http://main.edu.pl/images/OI19/squ-en-tex.4.png))      that denotes the number of different kinds of squarks.\n\nIn the second line there are ![](http://main.edu.pl/images/OI19/squ-en-tex.5.png) positive integers, separated by single spaces,      that denote the total masses of all possible pairs of squarks.\n\nThe mass of every pair does not exceed ![](http://main.edu.pl/images/OI19/squ-en-tex.6.png).\n\nFor each two different kinds of squarks, the mass of the pair they form is given on the input exactly once.\n\n      The masses on the input are given in a random order.\n\nIn tests worth 32% of the points the following conditions hold in addition:\n\n![](http://main.edu.pl/images/OI19/squ-en-tex.7.png) and the mass of every pair of squarks does not exceed ![](http://main.edu.pl/images/OI19/squ-en-tex.8.png).\n", "outputFormat": "In the first line of the standard output your program should print the number ![](http://main.edu.pl/images/OI19/squ-en-tex.9.png) of possible solutions to the problem.\n\nIn the ![](http://main.edu.pl/images/OI19/squ-en-tex.10.png) lines that follow it should report successive solutions, one per line.\n\nEach solution should consist of ![](http://main.edu.pl/images/OI19/squ-en-tex.11.png) different positive integers, namely the masses of squarks of all kinds.\n\nIn every solution these should be given in increasing order and separated by single spaces.\n\nSolutions can be reported in arbitrary order, but they cannot be repeated.\n\nYou may assume that for each test data there exists at least one solution, i.e., ![](http://main.edu.pl/images/OI19/squ-en-tex.12.png).\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2012] SQU-Squarks", "background": "", "description": "**译自 POI 2012 Stage 3. Day 0「[Squarks](https://szkopul.edu.pl/problemset/problem/lo_jOsVfQ4ajCSHxFGZS27W-/site/?key=statement)」**\n\n给定 $n$ 个不同的正整数两两的和，求这 $n$ 个正整数的所有可能。", "inputFormat": "第一行一个正整数 $n (1 \\le n \\le 300)$，表示正整数的数量。\n\n接下来一行有 $\\frac{n(n-1)}2$ 个正整数，表示两两正整数的和，不超过 $10^8$，顺序随机。", "outputFormat": "第一行输出一个正整数 $k$，表示解的个数。\n\n接下来 $k$ 行每行按递增顺序输出 $n$ 个正整数，表示一组可能的解。\n\n可以以任意顺序输出解。保证存在一组解。", "hint": "对于 $32\\%$ 的数据保证 $n \\le 20$ 且任何两个正整数的和不超过 $2000$.\n\n对于所有数据保证 $n \\le 300$ 且任何两个正整数的和不超过 $10^8$.\n\n翻译与 checker 来自于 [LibreOJ](https://loj.ac/p/2698)。", "locale": "zh-CN"}}}
{"pid": "P3541", "type": "P", "difficulty": 6, "samples": [["7 3\n2 4 3 1 3 5 3\n< > =", "6\n2 4 3 3 5 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2010", "POI（波兰）", "Special Judge", "O2优化"], "title": "[POI 2010] Monotonicity", "background": "", "description": "**译自 POI 2010 Stage 3. Day 0「[Monotonicity](https://szkopul.edu.pl/problemset/problem/HVVwfLd9uyYNOW6hUZ_Zcnqe/site/?key=statement)」**\n\n对于一个整数序列 $a_1, a_2, \\cdots, a_n$，我们定义其“单调序列\"为一个由 $<$，$>$ 和 $=$ 组成的符号序列 $s_1, s_2, \\cdots,s_{n-1}$，其中符号 $s_i$ 表示 $a_i$ 和 $a_{i+1}$ 之间的关系。例如，数列 $2, 4, 3, 3, 5, 3$ 的单调序列为 $<, >, =, <, >$。\n\n对于整数序列 $b_1, b_2, \\cdots, b_{n+1}$ 以及其单调序列 $s_1, s_2, \\cdots, s_n$，如果符号序列 $s_1', s_2', \\cdots, s_k'$ 满足对所有 $1 \\le i \\le n$ 有 $s_i = s_{((i - 1) \\bmod n) + 1}'$，我们就说序列 $s_1, s_2, \\cdots, s_n$ 「实现」了序列 $s_1', s_2', \\cdots, s_k'$。也就是说，序列 $s_1, s_2, \\cdots, s_n$ 可以通过重复多次 $s_1', s_2', \\cdots, s_k'$ 序列并删除一个后缀得到。例如，整数数列 $2, 4, 3, 3, 5, 3$ 至少实现了以下符号序列：\n\n* $<, >, =$\n* $<, >, =, <, >$\n* $<, >, =, <, >, <, <, =$\n* $<, >, =, <, >, =, >, >$\n\n给定一个整数序列 $a_1, a_2, \\cdots, a_n$ 以及一个单调序列 $s_1, s_2, \\cdots, s_k$，求出原整数序列最长的子序列 $a_{i_1}, a_{i_2}, \\cdots, a_{i_m} (1 \\le i_1 \\lt i_2 \\lt \\cdots \\lt i_m \\le n)$ 使得前者的单调序列实现后者的符号序列。", "inputFormat": "第一行包含用空格分隔的两个整数 $n,k$，分别表示整数序列 $a_i$ 的长度和单调序列 $s_j$ 的长度。\n\n第二行包含用空格分隔的 $n$ 个整数，表示序列 $a_i$。\n\n第三行包含用空格分隔的 $k$ 个符号，表示符号序列 $s_j$。", "outputFormat": "第一行输出一个整数 $m$，表示序列 $a_1, a_2, \\cdots, a_n$ 的最长的「实现」了单调序列 $s_1, s_2, \\cdots, s_n$ 的子序列。\n\n第二行输出任意一个这样的子序列 $a_{i_1}, a_{i_2}, \\cdots, a_{i_n}$，元素之间用空格分隔。", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 20000$，$1 \\le k \\le 100$，$1 \\le a_i \\le 1000000$，$s_j \\in \\{<, >, =\\}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2010] Monotonicity", "background": "", "description": "**译自 POI 2010 Stage 3. Day 0「[Monotonicity](https://szkopul.edu.pl/problemset/problem/HVVwfLd9uyYNOW6hUZ_Zcnqe/site/?key=statement)」**\n\n对于一个整数序列 $a_1, a_2, \\cdots, a_n$，我们定义其“单调序列\"为一个由 $<$，$>$ 和 $=$ 组成的符号序列 $s_1, s_2, \\cdots,s_{n-1}$，其中符号 $s_i$ 表示 $a_i$ 和 $a_{i+1}$ 之间的关系。例如，数列 $2, 4, 3, 3, 5, 3$ 的单调序列为 $<, >, =, <, >$。\n\n对于整数序列 $b_1, b_2, \\cdots, b_{n+1}$ 以及其单调序列 $s_1, s_2, \\cdots, s_n$，如果符号序列 $s_1', s_2', \\cdots, s_k'$ 满足对所有 $1 \\le i \\le n$ 有 $s_i = s_{((i - 1) \\bmod n) + 1}'$，我们就说序列 $s_1, s_2, \\cdots, s_n$ 「实现」了序列 $s_1', s_2', \\cdots, s_k'$。也就是说，序列 $s_1, s_2, \\cdots, s_n$ 可以通过重复多次 $s_1', s_2', \\cdots, s_k'$ 序列并删除一个后缀得到。例如，整数数列 $2, 4, 3, 3, 5, 3$ 至少实现了以下符号序列：\n\n* $<, >, =$\n* $<, >, =, <, >$\n* $<, >, =, <, >, <, <, =$\n* $<, >, =, <, >, =, >, >$\n\n给定一个整数序列 $a_1, a_2, \\cdots, a_n$ 以及一个单调序列 $s_1, s_2, \\cdots, s_k$，求出原整数序列最长的子序列 $a_{i_1}, a_{i_2}, \\cdots, a_{i_m} (1 \\le i_1 \\lt i_2 \\lt \\cdots \\lt i_m \\le n)$ 使得前者的单调序列实现后者的符号序列。", "inputFormat": "第一行包含用空格分隔的两个整数 $n,k$，分别表示整数序列 $a_i$ 的长度和单调序列 $s_j$ 的长度。\n\n第二行包含用空格分隔的 $n$ 个整数，表示序列 $a_i$。\n\n第三行包含用空格分隔的 $k$ 个符号，表示符号序列 $s_j$。", "outputFormat": "第一行输出一个整数 $m$，表示序列 $a_1, a_2, \\cdots, a_n$ 的最长的「实现」了单调序列 $s_1, s_2, \\cdots, s_n$ 的子序列。\n\n第二行输出任意一个这样的子序列 $a_{i_1}, a_{i_2}, \\cdots, a_{i_n}$，元素之间用空格分隔。", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 20000$，$1 \\le k \\le 100$，$1 \\le a_i \\le 1000000$，$s_j \\in \\{<, >, =\\}$。", "locale": "zh-CN"}}}
{"pid": "P3542", "type": "P", "difficulty": 6, "samples": [["10\n2 2\n2 10\n1 0\n2 9\n2 5\n4 0\n6 0\n6 0\n5 0\n5 0", "2\n10\n1\n9\n5\n8\n0\n0\n0\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2012", "POI（波兰）", "深度优先搜索 DFS"], "title": "[POI 2012] PEN-Salaries", "background": "", "description": "The Byteotian Software Corporation (BSC) has $n$ employees.\n\nIn BSC's strict hierarchy, each employee has a direct supervisor, except the CEO, to whom all other BSC employees answer, directly or not.\n\nEach employee has a unique monthly salary, and all their salaries range from 1 to $n$ bythalers.\n\nEach supervisor earns more than each of their subordinates.\n\nAccording to Byteotian law, the salaries of employees on certain posts may be publicly disclosed.\n\nFurthermore, if the salary of an employee is disclosed, then the salary of their supervisor is also disclosed.\n\nThe Byteotian Internal Revenue Anti-Corruption Service (BIRAS) has decided to investigate BSC.\n\nBefore BIRAS enters BSC with a warrant, they intend to learn the salaries of all BSC employees    that are not disclosed but can be determined from those that are disclosed.", "inputFormat": "In the first line of the standard input a single integer $n$ ($1\\le n\\le 1\\ 000\\ 000$) is given that denotes the number of BSC employees.\n\nThe employees have id's that range from 1 to $n$.\n\nThe $n$ lines that follow provide information on these employees.\n\nThe line no. $i+1$ describes the employee no. $i$ by two integers $p_i$ and $z_i$ ($1\\le p_i\\le n$, $0\\le z_i\\le n$), separated by a single space.\n\nThe number $p_i$ is the id of the direct supervisor of the employee $i$.If $p_i=i$, then $i$ is the CEO of BSC. If $z_i>0$,then that is the salary of the employee $i$.If, on the other hand,$z_i=0$, then the salary of employee $i$ is not disclosed.Those $z_i$'s that are positive are also pairwise different.\n\nThe input data will always be such that there is at least one assignment of salaries to employees consistent with them, i.e., with the hierarchy and the partial assignment that they provide.\n\nIn tests worth 54% of the total points the condition $n\\le 10\\ 000$  holds in addition.\n", "outputFormat": "Your program should print $n$ lines to the standard output, each line holding a single integer.\n\nIf the employee $i$'s salary is disclosed or can be inferred from disclosed salaries, then the $i$-th line should hold employee $i$'s salary.\n\nOtherwise the $i$-th line should contain $0$.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2012] PEN-Salaries", "background": "", "description": "The Byteotian Software Corporation (BSC) has $n$ employees.\n\nIn BSC's strict hierarchy, each employee has a direct supervisor, except the CEO, to whom all other BSC employees answer, directly or not.\n\nEach employee has a unique monthly salary, and all their salaries range from 1 to $n$ bythalers.\n\nEach supervisor earns more than each of their subordinates.\n\nAccording to Byteotian law, the salaries of employees on certain posts may be publicly disclosed.\n\nFurthermore, if the salary of an employee is disclosed, then the salary of their supervisor is also disclosed.\n\nThe Byteotian Internal Revenue Anti-Corruption Service (BIRAS) has decided to investigate BSC.\n\nBefore BIRAS enters BSC with a warrant, they intend to learn the salaries of all BSC employees    that are not disclosed but can be determined from those that are disclosed.", "inputFormat": "In the first line of the standard input a single integer $n$ ($1\\le n\\le 1\\ 000\\ 000$) is given that denotes the number of BSC employees.\n\nThe employees have id's that range from 1 to $n$.\n\nThe $n$ lines that follow provide information on these employees.\n\nThe line no. $i+1$ describes the employee no. $i$ by two integers $p_i$ and $z_i$ ($1\\le p_i\\le n$, $0\\le z_i\\le n$), separated by a single space.\n\nThe number $p_i$ is the id of the direct supervisor of the employee $i$.If $p_i=i$, then $i$ is the CEO of BSC. If $z_i>0$,then that is the salary of the employee $i$.If, on the other hand,$z_i=0$, then the salary of employee $i$ is not disclosed.Those $z_i$'s that are positive are also pairwise different.\n\nThe input data will always be such that there is at least one assignment of salaries to employees consistent with them, i.e., with the hierarchy and the partial assignment that they provide.\n\nIn tests worth 54% of the total points the condition $n\\le 10\\ 000$  holds in addition.\n", "outputFormat": "Your program should print $n$ lines to the standard output, each line holding a single integer.\n\nIf the employee $i$'s salary is disclosed or can be inferred from disclosed salaries, then the $i$-th line should hold employee $i$'s salary.\n\nOtherwise the $i$-th line should contain $0$.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2012] PEN-Salaries", "background": "", "description": "**译自 POI 2012 Stage 3. Day 1「[Salaries](https://szkopul.edu.pl/problemset/problem/_qn633f6DVAHRkv0OX3LQaph/site/?key=statement)」**\n\n有一个 $n$ 个点的有根树，每个点的权值分别为 $1 \\ldots n$，且大于其儿子的权值。其中一部分点的权值是公开的，且每个权值已知的点的父亲权值也一定已知。求能够根据已知信息推算出来的权值未知的点的权值。", "inputFormat": "第一行一个整数 $n$，表示点的个数。\n\n接下来 $n$ 行每行两个整数 $p_i, z_i (1 \\le p_i \\le n,0 \\le z_i \\le n)$，其中 $p_i$ 表示结点 $i$ 的父亲，$z_i$ 表示结点 $i$ 的权值。如果 $z_i = 0$，则该点权值未知，否则该点权值为 $z_i$。", "outputFormat": "输出 $n$ 行，每行一个整数，表示 $i$ 点的权值。如果该点权值已知或可以推算出来，输出该点权值，否则输出 $0$。\n\n### 样例解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bjf4memv.png)", "hint": "对于 $54\\%$ 的数据有 $n \\le 10^4$.\n\n对于所有数据有 $1 \\le n \\le 10^6$。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2700)。", "locale": "zh-CN"}}}
{"pid": "P3543", "type": "P", "difficulty": 7, "samples": [["5 2 3\n1 2 1 1 -1", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2012", "POI（波兰）"], "title": "[POI 2012] WYR-Leveling Ground", "background": "", "description": "Byteasar has decided to build a house.\n\nHe has chosen a very narrow valley as its location.\n\nBefore Byteasar starts the actual construction work, he has to level the ground first.\n\nHe has two excavators at his disposal: the first one can either increase or decrease the  ground level of any connected area in the valley by exactly ![](http://main.edu.pl/images/OI19/wyr-en-tex.1.png) meters;  the other can do the same, i.e., either increase or decrease the  ground level of any connected area in the valley, but by exactly ![](http://main.edu.pl/images/OI19/wyr-en-tex.2.png) meters.\n\nNotice that neither before such an operation nor after it needs the ground in the affected  area be actually leveled.\n\nGiven a map of the area, determine the minimum number of operations required to  level the ground in the whole valley, i.e., to make the ground level everywhere  equal 0.  While the operations are performed, the ground level at any point in  the valley can have arbitrary value; in particular, it may be negative.", "inputFormat": "In the first line of the standard input there are three integers, ![](http://main.edu.pl/images/OI19/wyr-en-tex.3.png), ![](http://main.edu.pl/images/OI19/wyr-en-tex.4.png), ![](http://main.edu.pl/images/OI19/wyr-en-tex.5.png)    (![](http://main.edu.pl/images/OI19/wyr-en-tex.6.png), ![](http://main.edu.pl/images/OI19/wyr-en-tex.7.png)), separated by single spaces.\n\nThe number ![](http://main.edu.pl/images/OI19/wyr-en-tex.8.png) denotes the valley's length in meters.\n\nThe second line contains ![](http://main.edu.pl/images/OI19/wyr-en-tex.9.png) integers, ![](http://main.edu.pl/images/OI19/wyr-en-tex.10.png), separated by single spaces.\n\nThese numbers, all with absolute value no larger than ![](http://main.edu.pl/images/OI19/wyr-en-tex.11.png), represent the initial ground level in meters    of successive one meter long slices of the valley.\n\nIn tests worth 30% of the points the following conditions hold in addition: ![](http://main.edu.pl/images/OI19/wyr-en-tex.12.png) and   ![](http://main.edu.pl/images/OI19/wyr-en-tex.13.png).\n\nIn tests worth 60% of the points the following conditions hold in addition: ![](http://main.edu.pl/images/OI19/wyr-en-tex.14.png) and   ![](http://main.edu.pl/images/OI19/wyr-en-tex.15.png).\n\nIn tests worth 90% of the points the condition ![](http://main.edu.pl/images/OI19/wyr-en-tex.16.png) holds in addition.\n", "outputFormat": "In the first and only line of the standard output your program should print a single    integer: the minimum number of operations required to level the ground in the whole valley,    or ![](http://main.edu.pl/images/OI19/wyr-en-tex.17.png) if leveling the whole valley with given excavators is impossible.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2012] WYR-Leveling Ground", "background": "", "description": "Byteasar has decided to build a house.\n\nHe has chosen a very narrow valley as its location.\n\nBefore Byteasar starts the actual construction work, he has to level the ground first.\n\nHe has two excavators at his disposal: the first one can either increase or decrease the  ground level of any connected area in the valley by exactly ![](http://main.edu.pl/images/OI19/wyr-en-tex.1.png) meters;  the other can do the same, i.e., either increase or decrease the  ground level of any connected area in the valley, but by exactly ![](http://main.edu.pl/images/OI19/wyr-en-tex.2.png) meters.\n\nNotice that neither before such an operation nor after it needs the ground in the affected  area be actually leveled.\n\nGiven a map of the area, determine the minimum number of operations required to  level the ground in the whole valley, i.e., to make the ground level everywhere  equal 0.  While the operations are performed, the ground level at any point in  the valley can have arbitrary value; in particular, it may be negative.", "inputFormat": "In the first line of the standard input there are three integers, ![](http://main.edu.pl/images/OI19/wyr-en-tex.3.png), ![](http://main.edu.pl/images/OI19/wyr-en-tex.4.png), ![](http://main.edu.pl/images/OI19/wyr-en-tex.5.png)    (![](http://main.edu.pl/images/OI19/wyr-en-tex.6.png), ![](http://main.edu.pl/images/OI19/wyr-en-tex.7.png)), separated by single spaces.\n\nThe number ![](http://main.edu.pl/images/OI19/wyr-en-tex.8.png) denotes the valley's length in meters.\n\nThe second line contains ![](http://main.edu.pl/images/OI19/wyr-en-tex.9.png) integers, ![](http://main.edu.pl/images/OI19/wyr-en-tex.10.png), separated by single spaces.\n\nThese numbers, all with absolute value no larger than ![](http://main.edu.pl/images/OI19/wyr-en-tex.11.png), represent the initial ground level in meters    of successive one meter long slices of the valley.\n\nIn tests worth 30% of the points the following conditions hold in addition: ![](http://main.edu.pl/images/OI19/wyr-en-tex.12.png) and   ![](http://main.edu.pl/images/OI19/wyr-en-tex.13.png).\n\nIn tests worth 60% of the points the following conditions hold in addition: ![](http://main.edu.pl/images/OI19/wyr-en-tex.14.png) and   ![](http://main.edu.pl/images/OI19/wyr-en-tex.15.png).\n\nIn tests worth 90% of the points the condition ![](http://main.edu.pl/images/OI19/wyr-en-tex.16.png) holds in addition.\n", "outputFormat": "In the first and only line of the standard output your program should print a single    integer: the minimum number of operations required to level the ground in the whole valley,    or ![](http://main.edu.pl/images/OI19/wyr-en-tex.17.png) if leveling the whole valley with given excavators is impossible.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2012] WYR-Leveling Ground", "background": "", "description": "**译自 POI 2012 Stage 3. Day 1「[Leveling Ground](https://szkopul.edu.pl/problemset/problem/W54iZIwStF1TYWRxa1bdVPQo/site/?key=statement)」**\n\n给定一个长度为 $n$ 的数组，每次操作可以将一个区间的数增加或减少 $a$，或将一个区间的数增加或减少 $b$。求使整个数组变为 $0$ 的最小操作次数。若无解请输出 $-1$。", "inputFormat": "第一行三个整数 $n, a, b (1 \\le n \\le 100\\ 000, 1 \\le a,b \\le 10^9)$。\n\n接下来一行 $n$ 个整数 $h_1, h_2, \\ldots, h_n$，绝对值均不超过 $10^9$。", "outputFormat": "输出一行一个整数，表示最小操作次数。\n\n### 样例解释\n\n一种操作方案是：\n* 将前两个数加 $2$；\n* 将前两个数减 $3$；\n* 将后四个数加 $2$；\n* 将最后一个数加 $2$；\n* 将后四个数减 $3$。", "hint": "对于 $30\\%$ 的数据，$n,a,b \\le 200,-200 \\le h_1,h_2,\\ldots,h_n \\le 200$.\n\n对于 $60\\%$ 的数据，$n,a,b \\le 2000,-2000 \\le h_1,h_2,\\ldots,h_n \\le 2000$.\n\n对于 $90\\%$ 的数据，$a,b \\le 10^6$.\n\n对于所有数据，$1 \\le n \\le 100\\ 000, 1 \\le a,b \\le 10^9$.\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2701)。", "locale": "zh-CN"}}}
{"pid": "P3544", "type": "P", "difficulty": 6, "samples": [["3 2\n5 10 5\n1 2 5\n2 3 3", "12 15"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2012", "POI（波兰）", "广度优先搜索 BFS"], "title": "[POI 2012] BEZ-Minimalist Security", "background": "", "description": "A map of Mafiatown's road network is given.\n\nThe network consists of intersections and bidirectional streets that connect them.\n\nThe streets cross only at the intersections, but they may lead through tunnels or flyovers.\n\nEach pair of intersections is linked by at most one street.\n\nAt every intersection $v$ there is a police station manned by $p(v)$ policemen.\n\nA street linking the intersections $u$ and $v$ is considered safe if there are at least $b(u,v)$ policemen in total in the two stations at the streets ends. Initially    $p(u)+p(v)\\ge b(u,v)$ holds for every street.\n\nHowever, due to an ongoing crisis the mayor Byteasar has ordained the Minimalist Security Act (MSA), which states that:\n\na certain number (which may be zero) of policemen is to be laid off from each police station        (we denote the number of policemen laid off from the station at the intersection $v$ by $z(v)$),                  after the layoff, the total number of the policemen at both ends of every street connecting some two intersections,        say $u$ and $v$, should equal $b(u,v)$ exactly, i.e.:\n\n$p(u)-z(u)+p(v)-z(v)=b(u,v)$ These rules do not determine uniquely how many policemen are to be laid off.\n\nByteasar wonders what is the minimum and the maximum number of laid off policemen    (the sum of $z$ values over all intersections) that complies with aforementioned rules.", "inputFormat": "In the first line of the standard input there are two integers, $n$ and $m$ ($1\\le n\\le 500\\ 000$, $0\\le m\\le 3\\ 000\\ 000$), separated by a single space, that denote    the number of intersections and the number of streets in Mafiatown, respectively.\n\nThe intersections are numbered from 1 to $n$.\n\nIn the second line $n$ nonnegative integers separated by single spaces are given.\n\nThese are the numbers of policemen currently employed at successive stations, i.e., the values $p(1),p(2),\\cdots,p(n)$($0\\le p(i)\\le 10^6$).\n\nEach of the following $m$ lines describes a single bidirectional street. Such description consists of three integers,$u_i,v_i,b(u_i,v_i)$($1\\le u_i,v_i\\le n$,$u_i\\ne v_i$,$0\\le b(u_i,v_i)\\le 10^6$), separated by single spaces, that denote respectively: the numbers of the intersections at the ends of the street and the minimum total number of policemen that have to man the stations at those intersections.\n", "outputFormat": "If Byteasar's ordinance can be carried out, your program should print, on the standard output,    exactly one line with two integers separated by a single space.\n\nThe numbers should be the minimum and the maximum number of policemen that should be laid off    in order to carry out the ordinance.\n\nIf carrying out the ordinance is impossible, your program should print a single line containing    the word NIE (Polish for no).\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2012] BEZ-Minimalist Security", "background": "", "description": "A map of Mafiatown's road network is given.\n\nThe network consists of intersections and bidirectional streets that connect them.\n\nThe streets cross only at the intersections, but they may lead through tunnels or flyovers.\n\nEach pair of intersections is linked by at most one street.\n\nAt every intersection $v$ there is a police station manned by $p(v)$ policemen.\n\nA street linking the intersections $u$ and $v$ is considered safe if there are at least $b(u,v)$ policemen in total in the two stations at the streets ends. Initially    $p(u)+p(v)\\ge b(u,v)$ holds for every street.\n\nHowever, due to an ongoing crisis the mayor Byteasar has ordained the Minimalist Security Act (MSA), which states that:\n\na certain number (which may be zero) of policemen is to be laid off from each police station        (we denote the number of policemen laid off from the station at the intersection $v$ by $z(v)$),                  after the layoff, the total number of the policemen at both ends of every street connecting some two intersections,        say $u$ and $v$, should equal $b(u,v)$ exactly, i.e.:\n\n$p(u)-z(u)+p(v)-z(v)=b(u,v)$ These rules do not determine uniquely how many policemen are to be laid off.\n\nByteasar wonders what is the minimum and the maximum number of laid off policemen    (the sum of $z$ values over all intersections) that complies with aforementioned rules.", "inputFormat": "In the first line of the standard input there are two integers, $n$ and $m$ ($1\\le n\\le 500\\ 000$, $0\\le m\\le 3\\ 000\\ 000$), separated by a single space, that denote    the number of intersections and the number of streets in Mafiatown, respectively.\n\nThe intersections are numbered from 1 to $n$.\n\nIn the second line $n$ nonnegative integers separated by single spaces are given.\n\nThese are the numbers of policemen currently employed at successive stations, i.e., the values $p(1),p(2),\\cdots,p(n)$($0\\le p(i)\\le 10^6$).\n\nEach of the following $m$ lines describes a single bidirectional street. Such description consists of three integers,$u_i,v_i,b(u_i,v_i)$($1\\le u_i,v_i\\le n$,$u_i\\ne v_i$,$0\\le b(u_i,v_i)\\le 10^6$), separated by single spaces, that denote respectively: the numbers of the intersections at the ends of the street and the minimum total number of policemen that have to man the stations at those intersections.\n", "outputFormat": "If Byteasar's ordinance can be carried out, your program should print, on the standard output,    exactly one line with two integers separated by a single space.\n\nThe numbers should be the minimum and the maximum number of policemen that should be laid off    in order to carry out the ordinance.\n\nIf carrying out the ordinance is impossible, your program should print a single line containing    the word NIE (Polish for no).\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2012] BEZ-Minimalist Security", "background": "", "description": "**译自 POI 2012 Stage 3. Day 2「[Bezpieczeństwo minimalistyczne](https://szkopul.edu.pl/problemset/problem/aSbIC_LB4H-CGMYPEVue5jFw/site/?key=statement)」**\n\n给定一张无向图，点有点权 $p(v)$，边有边权 $b(u,v)$，初始时保证对每条边有 $p(u) + p(v) \\ge b(u,v)$。\n\n现在需要减少一部分点的点权（减少后必须是非负整数），使得对每条边都恰有 $p(u) + p(v) = b(u,v)$.\n\n求整张图减少的点权和的最小值和最大值。", "inputFormat": "第一行两个整数 $n$ 和 $m$（$1 \\le n \\le 500\\ 000,0 \\le m \\le 3\\ 000\\ 000$），表示图的点数和边数。\n\n接下来一行 $n$ 个非负整数 $p(1),p(2),\\ldots,p(n) (0 \\le p(i) \\le 10^6)$，表示点权。\n\n接下来 $m$ 行每行三个整数 $u_i, v_i, b(u_i, v_i)$（$1 \\le u_i,v_i \\le n,u_i \\neq v_i,0 \\le b(u_i,v_i) \\le 10^6$），表示边和边权。", "outputFormat": "如果存在符合条件的方案，输出一行两个整数，表示整张图减少的点权和的最小值和最大值。\n\n如果不存在，输出 `NIE`.", "hint": "对于 $56\\%$ 的数据有 $n \\le 2000,m \\le 8000$.\n\n对于所有数据有 $1 \\le n \\le 500\\ 000,0 \\le m \\le 3\\ 000\\ 000$.\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2702)。", "locale": "zh-CN"}}}
{"pid": "P3545", "type": "P", "difficulty": 5, "samples": [["6\n2 2 1 2 1 0\n1 2 2 3 4 4", "3\n1 2 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2012", "POI（波兰）", "Special Judge", "反悔贪心"], "title": "[POI 2012] HUR-Warehouse Store", "background": null, "description": "现在有 $n$ 天。第 $i$ 天上午会进货 $A_i$ 件商品，中午的时候会有顾客需要购买 $B_i$ 件商品，可以选择满足顾客的要求，或是无视掉他。\n\n如果要满足顾客的需求，就必须要有足够的库存。问最多能够满足多少个顾客的需求。", "inputFormat": "第一行包含一个整数 $n$，表示有 $n$ 天。\n\n第二行有 $n$ 个整数 $a_i$，表示第 $i$ 天上午进货 $a$ 件商品。\n\n第三行包含 $n$ 个整数 $b_i$，表示在第 $i$ 天中午有顾客来买 $b$ 件商品。", "outputFormat": "第一行一个整数，表示最多能满足几天中顾客的需求。\n\n\n第二行输出最多能够满足哪些天顾客的需求。如果有多种方案，输出任意一种即可。", "hint": "对于 $100\\%$ 的数据，$1\\leqslant n\\leqslant 2.5\\times 10^5$，$0\\leqslant a_i,b_i \\leqslant 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2012] HUR-Warehouse Store", "background": "", "description": "There are $n$ days. On the morning of day $i$, $A_i$ items arrive. At noon of day $i$, a customer wants to buy $B_i$ items; you may either fulfill the customer's request or ignore it.\n\nTo fulfill the customer's request, you must have enough inventory. What is the maximum number of days whose customer requests can be fulfilled?", "inputFormat": "The first line contains an integer $n$, the number of days.\n\nThe second line contains $n$ integers $a_i$, where $a_i$ is the number of items arriving on the morning of day $i$.\n\nThe third line contains $n$ integers $b_i$, where $b_i$ is the number of items a customer wants to buy at noon of day $i$.", "outputFormat": "The first line contains a single integer: the maximum number of days whose customer requests can be fulfilled.\n\nThe second line outputs one such set of days that achieves the maximum. If there are multiple solutions, output any one of them.", "hint": "For $100\\%$ of the testdata, $1 \\leqslant n \\leqslant 2.5 \\times 10^5$, $0 \\leqslant a_i, b_i \\leqslant 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2012] HUR-Warehouse Store", "background": null, "description": "现在有 $n$ 天。第 $i$ 天上午会进货 $A_i$ 件商品，中午的时候会有顾客需要购买 $B_i$ 件商品，可以选择满足顾客的要求，或是无视掉他。\n\n如果要满足顾客的需求，就必须要有足够的库存。问最多能够满足多少个顾客的需求。", "inputFormat": "第一行包含一个整数 $n$，表示有 $n$ 天。\n\n第二行有 $n$ 个整数 $a_i$，表示第 $i$ 天上午进货 $a$ 件商品。\n\n第三行包含 $n$ 个整数 $b_i$，表示在第 $i$ 天中午有顾客来买 $b$ 件商品。", "outputFormat": "第一行一个整数，表示最多能满足几天中顾客的需求。\n\n\n第二行输出最多能够满足哪些天顾客的需求。如果有多种方案，输出任意一种即可。", "hint": "对于 $100\\%$ 的数据，$1\\leqslant n\\leqslant 2.5\\times 10^5$，$0\\leqslant a_i,b_i \\leqslant 10^9$。", "locale": "zh-CN"}}}
{"pid": "P3546", "type": "P", "difficulty": 6, "samples": [["15\nababbabababbaab", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["字符串", "2012", "POI（波兰）", "哈希 hashing", "线性递推", "KMP 算法"], "title": "[POI 2012] PRE-Prefixuffix", "background": null, "description": "对于两个串 $S_1, S_2$，如果能够将 $S_1$ 的一个后缀移动到开头后变成 $S_2$，就称 $S_1$ 和 $S_2$ 循环相同。例如串 $\\tt ababba$ 和串 $\\tt abbaab$ 是循环相同的。\n\n给出一个长度为 $n$ 的串 $S$，求满足下面条件的最大的 $L(L\\leq \\frac n 2)$：$S$ 的 $L$ 前缀和 $S$ 的 $L$ 后缀是循环相同的。", "inputFormat": "第一行包含一个正整数 $n$，表示字符串 $t$ 的长度。\n\n第二行包含一个由 $n$ 个小写字母构成的字符串 $t$。", "outputFormat": "一行一个整数，表示最大的 $L$。", "hint": "数据范围：\n\n- 对于 $30\\%$ 的数据，保证 $n\\le 500$；\n- 对于 $50\\%$ 的数据，保证 $n\\le 5000$；\n- 对于 $100\\%$ 数据，保证 $1\\le n\\le 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2012] PRE-Prefixuffix", "background": null, "description": "We consider strings consisting of lowercase letters of the English alphabet in this problem. An initial fragment of a given string is called its prefix. A final (terminal) fragment of a given string is called its suffix. In particular, the empty string is both a prefix and a suffix of any string. Two strings are cyclically equivalent if one of them can be obtained from another by moving its certain suffix from the end of the string to its beginning. For example, the strings ababba and abbaab are cyclically equivalent, whereas the strings ababba and ababab are not. In particular, every string is cyclically equivalent to itself.\n\nA string $t$ consisting of $n$ letters is given. We are looking for its prefix $p$ and suffix $s$ of equal length such that:\n\n- $p$ and $s$ are cyclically equivalent,\n- the common length of $p$ and $s$ does not exceed (i.e., the prefix $p$ and the suffix $s$ do not overlap in $t$), and\n- the common length of $p$ and $s$ is maximized.", "inputFormat": "The first line of the standard input contains a single integer $n$ ($1 \\le n \\le 10^6$) denoting the length of the string $t$.\n\nThe second line of input contains the string $t$ itself, consisting of $n$ lowercase letters of the English alphabet.", "outputFormat": "Your program should print a single integer in the first and only line of the standard output, namely the common length of the prefix $p$ and the suffix $s$ that we are looking for.", "hint": "In tests worth $30\\%$ of the points the condition $n \\le 500$ holds in addition.\n\nIn tests worth $50\\%$ of the points the condition $n \\le 5000$ holds in addition.", "locale": "en"}, "zh-CN": {"title": "[POI 2012] PRE-Prefixuffix", "background": null, "description": "对于两个串 $S_1, S_2$，如果能够将 $S_1$ 的一个后缀移动到开头后变成 $S_2$，就称 $S_1$ 和 $S_2$ 循环相同。例如串 $\\tt ababba$ 和串 $\\tt abbaab$ 是循环相同的。\n\n给出一个长度为 $n$ 的串 $S$，求满足下面条件的最大的 $L(L\\leq \\frac n 2)$：$S$ 的 $L$ 前缀和 $S$ 的 $L$ 后缀是循环相同的。", "inputFormat": "第一行包含一个正整数 $n$，表示字符串 $t$ 的长度。\n\n第二行包含一个由 $n$ 个小写字母构成的字符串 $t$。", "outputFormat": "一行一个整数，表示最大的 $L$。", "hint": "数据范围：\n\n- 对于 $30\\%$ 的数据，保证 $n\\le 500$；\n- 对于 $50\\%$ 的数据，保证 $n\\le 5000$；\n- 对于 $100\\%$ 数据，保证 $1\\le n\\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P3547", "type": "P", "difficulty": 7, "samples": [["5 5 1 3 2\n1 2\n2 3\n3 4\n4 5\n3 1\n", "0\n3\n3\n2\n5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2013", "POI（波兰）", "广度优先搜索 BFS"], "title": "[POI 2013] CEN-Price List", "background": "", "description": "Railway has always been the most popular mean of transport in Byteotia.\n\nOut of $n$ towns in the land, $m$ pairs are connected by track segments    belonging to Byteotian State Railways (BSR).\n\nThe tracks do not cross outside of towns, and may lead through picturesque    bridges and somewhat less picturesque tunnels.\n\nThe ticket for travelling between any two towns    directly connected by rail costs $a$ bythalers.\n\nCurrently the transportation market in Byteotia is changing.\n\nAs of now, BSR faces a new competitor: Byteotian Airlines (BA).\n\nBA plans to operate flights between some pairs of towns.\n\nSince Byteotian railways are quite comfortable, the BA board has decided to    operate flights only between pairs of towns that are not directly    connected by rail.  Due to economy, BA will fly only between towns    for which the cheapest railway connection requires exactly one change.\n\nThe ticket for each such flight is going to cost $b$ bythalers.\n\nTo help Byteotian citizens in planning their trips, the Byteotian    Ministry for Transport (BMT) has decided to issue leaflets specifying the    cheapest routes between all possible towns.  A sequence of an    arbitrary number of direct railway or airplane connections is    called a route.  A BMT officer by the name of Byteasar has been    commissioned with the task of preparing the price list for the leaflets.\n\nCould you help him in writing a program that will determine the right    prices?\n\nLet us clarify that all the connections in Byteotia, both by railway and    airplane, are bidirectional.\n", "inputFormat": "The first line of the standard input contains five integers,$n$,$m$,$k$,$a$ and $b$ ($2\\le n\\le 100\\ 000$, $\\le m\\le 100\\ 000$, $1\\le k\\le n$, $1\\le a,b\\le 1\\ 000$),      separated by single spaces.\n\nThe numbers $n$ and $m$ denote the number of towns and the number of      direct railway connections in Byteotia, respectively.\n\nFor simplicity, we number the towns in Byteotia from $1$ to $n$. The other numbers denote:$k$ - the number of the source town for which the connection prices are to be determined;$a$ - the price of a direct railway connection;$b$ - the price of a direct airplane connection.\n\nEach of the following $m$ lines contains a pair of integers $u_i$ and $v_i$($1\\le u_i,v_i\\le n$,$u_i\\ne v_i$ for $i=1,2,\\cdots,m$), separated by a single space, specifying the number of towns directly connected by tracks.\n\n\nYou may assume that all towns are reachable by railway from the town no. $k$.\n", "outputFormat": "Your program should print $n$ lines to the standard output.\n\nThe line no. $i$ (for $i=1,2,\\cdots,n$) should contain a single integer:\n\nthe cost of the cheapest route from town no. $k$ to town no. $i$.\n\nAmong those, the line no. $k$ should contain the number $0$.\n", "hint": "\n\n------------\n\n2024/2/4 添加了一部分来自 bzoj 的数据。", "locale": "en", "translations": {"en": {"title": "[POI 2013] CEN-Price List", "background": "", "description": "Railway has always been the most popular mean of transport in Byteotia.\n\nOut of $n$ towns in the land, $m$ pairs are connected by track segments    belonging to Byteotian State Railways (BSR).\n\nThe tracks do not cross outside of towns, and may lead through picturesque    bridges and somewhat less picturesque tunnels.\n\nThe ticket for travelling between any two towns    directly connected by rail costs $a$ bythalers.\n\nCurrently the transportation market in Byteotia is changing.\n\nAs of now, BSR faces a new competitor: Byteotian Airlines (BA).\n\nBA plans to operate flights between some pairs of towns.\n\nSince Byteotian railways are quite comfortable, the BA board has decided to    operate flights only between pairs of towns that are not directly    connected by rail.  Due to economy, BA will fly only between towns    for which the cheapest railway connection requires exactly one change.\n\nThe ticket for each such flight is going to cost $b$ bythalers.\n\nTo help Byteotian citizens in planning their trips, the Byteotian    Ministry for Transport (BMT) has decided to issue leaflets specifying the    cheapest routes between all possible towns.  A sequence of an    arbitrary number of direct railway or airplane connections is    called a route.  A BMT officer by the name of Byteasar has been    commissioned with the task of preparing the price list for the leaflets.\n\nCould you help him in writing a program that will determine the right    prices?\n\nLet us clarify that all the connections in Byteotia, both by railway and    airplane, are bidirectional.\n", "inputFormat": "The first line of the standard input contains five integers,$n$,$m$,$k$,$a$ and $b$ ($2\\le n\\le 100\\ 000$, $\\le m\\le 100\\ 000$, $1\\le k\\le n$, $1\\le a,b\\le 1\\ 000$),      separated by single spaces.\n\nThe numbers $n$ and $m$ denote the number of towns and the number of      direct railway connections in Byteotia, respectively.\n\nFor simplicity, we number the towns in Byteotia from $1$ to $n$. The other numbers denote:$k$ - the number of the source town for which the connection prices are to be determined;$a$ - the price of a direct railway connection;$b$ - the price of a direct airplane connection.\n\nEach of the following $m$ lines contains a pair of integers $u_i$ and $v_i$($1\\le u_i,v_i\\le n$,$u_i\\ne v_i$ for $i=1,2,\\cdots,m$), separated by a single space, specifying the number of towns directly connected by tracks.\n\n\nYou may assume that all towns are reachable by railway from the town no. $k$.\n", "outputFormat": "Your program should print $n$ lines to the standard output.\n\nThe line no. $i$ (for $i=1,2,\\cdots,n$) should contain a single integer:\n\nthe cost of the cheapest route from town no. $k$ to town no. $i$.\n\nAmong those, the line no. $k$ should contain the number $0$.\n", "hint": "\n\n------------\n\n2024/2/4 添加了一部分来自 bzoj 的数据。", "locale": "en"}, "zh-CN": {"title": "[POI 2013] CEN-Price List", "background": "", "description": "铁路一直是 Byteotia 最受欢迎的交通方式。\n\n在这个国家的 $n$ 个城镇中，有 $m$ 对城镇由 Byteotian State Railways (BSR) 的轨道段连接。\n\n这些轨道不会在城镇外交叉，可能会经过风景如画的桥梁和不太风景如画的隧道。\n\n直接通过铁路连接的任意两个城镇之间的票价为 $a$ 比特勒。\n\n目前，Byteotia 的交通市场正在发生变化。\n\n截至目前，BSR 面临着一个新的竞争对手：Byteotian Airlines (BA)。\n\nBA 计划在一些城镇对之间运营航班。\n\n由于 Byteotian 铁路相当舒适，BA 董事会决定只在那些没有直接铁路连接的城镇对之间运营航班。出于经济原因，BA 只会在那些需要恰好一次换乘的城镇之间飞行。\n\n每张此类航班的票价为 $b$ 比特勒。\n\n为了帮助 Byteotia 的市民规划他们的旅行，Byteotian 交通部 (BMT) 决定发行传单，说明所有可能城镇之间的最便宜路线。任意数量的直接铁路或飞机连接的序列被称为路线。名叫 Byteasar 的 BMT 官员被委派准备传单的价格表。\n\n你能帮他写一个程序来确定正确的价格吗？\n\n让我们明确一下，Byteotia 的所有连接，无论是铁路还是飞机，都是双向的。", "inputFormat": "标准输入的第一行包含五个整数，$n$，$m$，$k$，$a$ 和 $b$ ($2\\le n\\le 100\\ 000$, $0\\le m\\le 100\\ 000$, $1\\le k\\le n$, $1\\le a,b\\le 1\\ 000$)，以单个空格分隔。\n\n数字 $n$ 和 $m$ 分别表示 Byteotia 中的城镇数量和直接铁路连接的数量。\n\n为简化起见，我们将 Byteotia 的城镇编号为 $1$ 到 $n$。其他数字表示：$k$ - 需要确定连接价格的源城镇的编号；$a$ - 直接铁路连接的价格；$b$ - 直接飞机连接的价格。\n\n接下来的 $m$ 行中的每一行包含一对整数 $u_i$ 和 $v_i$ ($1\\le u_i,v_i\\le n$，$u_i\ne v_i$ 对于 $i=1,2,\\cdots,m$)，以单个空格分隔，指定由轨道直接连接的城镇对的编号。\n\n你可以假设所有城镇都可以通过铁路从编号为 $k$ 的城镇到达。", "outputFormat": "你的程序应输出 $n$ 行到标准输出。\n\n第 $i$ 行（对于 $i=1,2,\\cdots,n$）应包含一个整数：\n\n从编号为 $k$ 的城镇到编号为 $i$ 的城镇的最便宜路线的费用。\n\n其中，第 $k$ 行应包含数字 $0$。", "hint": "------------\n\n2024/2/4 添加了一部分来自 bzoj 的数据。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3548", "type": "P", "difficulty": 0, "samples": [["1\n16\n5 -3\n4 -4\n3 -7\n0 -5\n-3 -7\n-4 -4\n-5 -3\n-1 -1\n-4 3\n-2 4\n-1 2\n0 7\n1 2\n2 4\n4 3\n1 -1\nC\nS\nS\nS\nS\nC\nC\nS\nS\nC\nS\nS\nC\nS\nS\nC\n        \n\n", "TAK\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2013", "POI（波兰）"], "title": "[POI 2013] GOB-Tapestries", "background": "", "description": "An exhibition of tapestries is opening in Byteotian Museum of Fine Arts.\n\nThe main exhibition room, viewed from top, is a polygon (not necessarily    convex).  A tapestry is hanged on each wall of the room, each tapestry    taking all the area of its wall.\n\nA lamp has been installed in the room in order to illuminate the exhibition.\n\n    The lamp is glowing uniformly in all directions.\n\nHowever, while some of the tapestries have to be flooded with light,    others cannot be exposed to strong light.\n\nByteasar, the curator, has been moving the lamp around the room, but so far    he is not satisfied with the results.\n\nNow he is terrified by the prospect of moving the tapestries around    instead - this would require much effort, and the exhibition is to open soon.\n\nPerhaps you will be able to tell him if his attempts are doomed or not?\n\nYour task is to determine if there is such a spot that placing the lamp    in it satisfies the following:\n\neach wall is to be either completely illuminated or completely shaded, as required by the tapestry hanging on it;        there can be no wall that is partly illuminated and partly shaded;                  if the lamp is located exactly on the wall or its extension, this wall is not illuminated;                the lamp can neither be switched off nor taken away from the room; it has      to be on while located (strictly) inside the room (i.e., it cannot be      placed in a corner or on any wall).", "inputFormat": "There is a single integer ![](http://main.edu.pl/images/OI20/gob-en-tex.1.png) (![](http://main.edu.pl/images/OI20/gob-en-tex.2.png)) in the first line of      the standard input, denoting the number of data sets.\n\nThe following lines describe these data sets.\n\nThe first line of a single description holds a single integer ![](http://main.edu.pl/images/OI20/gob-en-tex.3.png) (![](http://main.edu.pl/images/OI20/gob-en-tex.4.png)), denoting the number of walls in the main exhibition room.\n\nThen the following ![](http://main.edu.pl/images/OI20/gob-en-tex.5.png) lines specify the room's shape.\n\nEach of those lines contains a pair of integers ![](http://main.edu.pl/images/OI20/gob-en-tex.6.png) and ![](http://main.edu.pl/images/OI20/gob-en-tex.7.png)      (![](http://main.edu.pl/images/OI20/gob-en-tex.8.png) for ![](http://main.edu.pl/images/OI20/gob-en-tex.9.png)), separated by      a single space, denoting the coordinates of the room's corner or, in      other words, the vertex of corresponding polygon.  The vertices are given      clockwise.\n\nThe next ![](http://main.edu.pl/images/OI20/gob-en-tex.10.png) lines specify the tapestries' requirements.\n\nEach of those lines contains a single letter, S or      C, denoting that the wall has to be illuminated or shaded,      respectively.\n\nThe letter in the ![](http://main.edu.pl/images/OI20/gob-en-tex.11.png)-th of these lines (for ![](http://main.edu.pl/images/OI20/gob-en-tex.12.png))      regards the wall between the ![](http://main.edu.pl/images/OI20/gob-en-tex.13.png)-th and the ![](http://main.edu.pl/images/OI20/gob-en-tex.14.png)-th vertex.\n\nThe letter in the last of these lines regards the wall between the last      and the first vertex.\n\nThe polygon depicting the room's shape has no self-crossings, i.e.,      with the exception of successive sides, which share a common vertex,      no two sides of the polygon share a common point.  Furthermore, no three      vertices …\n", "outputFormat": "For each data set your program should print to the standard output      a single line containing a single word:\n\nTAK (Polish for yes) if the lamp can be placed so as   to satisfy all aforementioned requirements, or                      NIE (Polish for no) otherwise.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2013] GOB-Tapestries", "background": "", "description": "An exhibition of tapestries is opening in Byteotian Museum of Fine Arts.\n\nThe main exhibition room, viewed from top, is a polygon (not necessarily    convex).  A tapestry is hanged on each wall of the room, each tapestry    taking all the area of its wall.\n\nA lamp has been installed in the room in order to illuminate the exhibition.\n\n    The lamp is glowing uniformly in all directions.\n\nHowever, while some of the tapestries have to be flooded with light,    others cannot be exposed to strong light.\n\nByteasar, the curator, has been moving the lamp around the room, but so far    he is not satisfied with the results.\n\nNow he is terrified by the prospect of moving the tapestries around    instead - this would require much effort, and the exhibition is to open soon.\n\nPerhaps you will be able to tell him if his attempts are doomed or not?\n\nYour task is to determine if there is such a spot that placing the lamp    in it satisfies the following:\n\neach wall is to be either completely illuminated or completely shaded, as required by the tapestry hanging on it;        there can be no wall that is partly illuminated and partly shaded;                  if the lamp is located exactly on the wall or its extension, this wall is not illuminated;                the lamp can neither be switched off nor taken away from the room; it has      to be on while located (strictly) inside the room (i.e., it cannot be      placed in a corner or on any wall).", "inputFormat": "There is a single integer ![](http://main.edu.pl/images/OI20/gob-en-tex.1.png) (![](http://main.edu.pl/images/OI20/gob-en-tex.2.png)) in the first line of      the standard input, denoting the number of data sets.\n\nThe following lines describe these data sets.\n\nThe first line of a single description holds a single integer ![](http://main.edu.pl/images/OI20/gob-en-tex.3.png) (![](http://main.edu.pl/images/OI20/gob-en-tex.4.png)), denoting the number of walls in the main exhibition room.\n\nThen the following ![](http://main.edu.pl/images/OI20/gob-en-tex.5.png) lines specify the room's shape.\n\nEach of those lines contains a pair of integers ![](http://main.edu.pl/images/OI20/gob-en-tex.6.png) and ![](http://main.edu.pl/images/OI20/gob-en-tex.7.png)      (![](http://main.edu.pl/images/OI20/gob-en-tex.8.png) for ![](http://main.edu.pl/images/OI20/gob-en-tex.9.png)), separated by      a single space, denoting the coordinates of the room's corner or, in      other words, the vertex of corresponding polygon.  The vertices are given      clockwise.\n\nThe next ![](http://main.edu.pl/images/OI20/gob-en-tex.10.png) lines specify the tapestries' requirements.\n\nEach of those lines contains a single letter, S or      C, denoting that the wall has to be illuminated or shaded,      respectively.\n\nThe letter in the ![](http://main.edu.pl/images/OI20/gob-en-tex.11.png)-th of these lines (for ![](http://main.edu.pl/images/OI20/gob-en-tex.12.png))      regards the wall between the ![](http://main.edu.pl/images/OI20/gob-en-tex.13.png)-th and the ![](http://main.edu.pl/images/OI20/gob-en-tex.14.png)-th vertex.\n\nThe letter in the last of these lines regards the wall between the last      and the first vertex.\n\nThe polygon depicting the room's shape has no self-crossings, i.e.,      with the exception of successive sides, which share a common vertex,      no two sides of the polygon share a common point.  Furthermore, no three      vertices …\n", "outputFormat": "For each data set your program should print to the standard output      a single line containing a single word:\n\nTAK (Polish for yes) if the lamp can be placed so as   to satisfy all aforementioned requirements, or                      NIE (Polish for no) otherwise.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2013] GOB-Tapestries", "background": null, "description": "Byteotian 美术馆正在举办一场挂毯展览。\n\n从顶部看，主展厅是一个多边形（不一定是凸形）。房间的每一面墙上都挂着一幅挂毯，每幅挂毯都占据了墙壁的全部面积。\n\n为了照亮展览，房间里安装了一盏灯，这盏灯向各个方向均匀发光。然而，有些挂毯必须充满光线，但另一些挂毯不能暴露在强光下。\n\n策展人 Byteasar 一直在房间里移动灯，但到目前为止，他对结果并不满意。\n\n现在，他对移动挂毯的前景感到恐惧——这需要付出很多努力，展览很快就会开幕。\n\n也许你能告诉他，他的尝试是否注定要失败？\n\n**你的任务**是确定是否有这样一个点，将灯放在其中满足以下条件：\n\n1. 根据挂在墙上的挂毯的要求，每面墙要么完全照亮，要么完全遮阳；\n2. 不可能有一面墙是部分照明和部分遮阳的；如果灯正好位于墙上或其延伸部分，则这面墙不会被照亮；\n3. 灯既不能关闭，也不能从房间里拿走；它必须严格位于房间内（即它不能放置在角落或任何墙上）。", "inputFormat": "标准输入的第一行中有一个整数 $T$，表示数据集的数量。\n\n对于每个数据集，第一行有一个整数 $N$，表示主展厅的墙的数量。\n\n接下来 $N$ 行，每行 $2$ 个用空格隔开的整数 $x_i$ 和 $y_i$，表示房间角落的坐标。换句话说，就是相应多边形的顶点。顶点按顺时针方向给出。\n\n然后的的 $N$ 行指定了挂毯的要求。每一行都包含一个字母 $S$ 或 $C$，分别表示墙壁必须被照亮或遮蔽。\n\n第 $i$（$1\\le i\\le N$）行中的字母表示第 $i$ 个顶点和第 $i+1$ 个顶点之间的墙，最后一行中的字母表示最后一个顶点和第一个顶点之间的墙。\n\n描绘房间形状的多边形没有自交，即除了连续的边共享一个共同的顶点外，多边形的任何两条边都不共享一个顶点。而且没有三个顶点在一条线上。", "outputFormat": "对于每个数据集，你的程序应该在标准输出中打印一行包含一个单词：如果灯可以满足以上要求则输出 `TAK`（波兰语中“是”的意思）,否则输出 `NIE`（波兰语中表示“否”的意思）。", "hint": "- 对于 $40\\%$ 的数据点，$n\\le20$。\n- 对于另外 $10\\%$ 的数据点，所有地毯都需要被照亮。\n- 对于 $100\\%$ 的数据点，满足 $1\\le T\\le 20$，$3\\le N\\le 1000$，$-30000\\le xi,yi\\le30000$。", "locale": "zh-CN"}}}
{"pid": "P3549", "type": "P", "difficulty": 7, "samples": [["12\n1 7\n7 8\n7 11\n7 2\n2 4\n4 10\n2 5\n5 9\n2 6\n3 6\n3 12\n", "1\n11\n8\n7\n4\n10\n2\n9\n5\n6\n3\n12\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["图论", "2013", "POI（波兰）", "Special Judge", "构造"], "title": "[POI 2013] MUL-Multidrink", "background": "**本题翻译为 AI 生成。**", "description": "Byteasar 住在 Byteburg，一座以每个街角都有牛奶吧而闻名的城市。某天，Byteasar 想出了一个“牛奶多饮计划”：他希望每个牛奶吧只去喝一次。理想情况下，他希望设计一条路线，使得每次前往下一个牛奶吧时，其距离上一个牛奶吧不会超过两个街区（即：路口）。\n\nByteburg 的路口从 $1$ 到 $N$ 编号，所有街道都是双向通行的。在每对路口之间，存在唯一的一条直接路径，即不会重复经过任何路口的路径。Byteasar 将从编号为 $1$ 的路口出发，并在编号为 $N$ 的路口结束。你的任务是找出一条满足 Byteasar 要求的任意路线（如果存在的话）。", "inputFormat": "标准输入的第一行包含一个整数 $N$（$2 \\leq N \\leq 500000$），表示 Byteburg 中的路口数量。接下来的 $N - 1$ 行中，每行包含一对用一个空格分隔的不同整数 $A_i$ 和 $B_i$（$1 \\leq A_i, B_i \\leq N$），表示连接路口 $A_i$ 和 $B_i$ 的街道。", "outputFormat": "如果不存在满足要求的路线，你的程序应在标准输出中输出一个单词“**BRAK**”（波兰语，意为“无”），不带引号。否则，你的程序应在标准输出中输出 $N$ 行，第 $i$ 行输出满足条件的第 $i$ 个路口的编号。显然，在这种情况下，第一行应为数字 $1$，第 $N$ 行应为数字 $N$。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2013] MUL-Multidrink", "background": "**This translation is AI-generated.**", "description": "Byteasar lives in Byteburg, a city famous for having a milk bar on every street corner. One day, he came up with a “multidrink plan”: he wants to visit each milk bar exactly once. Ideally, he wants to design a route such that the distance from the previous milk bar to the next one is at most 2 edges each time.\n\nThe intersections of Byteburg are numbered from $1$ to $N$, and all streets are bidirectional. Between every pair of intersections, there is a unique simple path (i.e., a path that does not visit any intersection more than once). Byteasar will start at intersection $1$ and finish at intersection $N$. Your task is to find any route that satisfies his requirement, if it exists.", "inputFormat": "The first line contains an integer $N$ ($2 \\leq N \\leq 500000$), the number of intersections in Byteburg. Each of the next $N - 1$ lines contains a pair of distinct integers $A_i$ and $B_i$ ($1 \\leq A_i, B_i \\leq N$), describing a street connecting intersections $A_i$ and $B_i$.", "outputFormat": "If no such route exists, output a single word “BRAK” (Polish for “none”) without quotes. Otherwise, output $N$ lines; the $i$-th line should contain the index of the $i$-th intersection on the route. In this case, the first line must be $1$, and the last line must be $N$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2013] MUL-Multidrink", "background": "**本题翻译为 AI 生成。**", "description": "Byteasar 住在 Byteburg，一座以每个街角都有牛奶吧而闻名的城市。某天，Byteasar 想出了一个“牛奶多饮计划”：他希望每个牛奶吧只去喝一次。理想情况下，他希望设计一条路线，使得每次前往下一个牛奶吧时，其距离上一个牛奶吧不会超过两个街区（即：路口）。\n\nByteburg 的路口从 $1$ 到 $N$ 编号，所有街道都是双向通行的。在每对路口之间，存在唯一的一条直接路径，即不会重复经过任何路口的路径。Byteasar 将从编号为 $1$ 的路口出发，并在编号为 $N$ 的路口结束。你的任务是找出一条满足 Byteasar 要求的任意路线（如果存在的话）。", "inputFormat": "标准输入的第一行包含一个整数 $N$（$2 \\leq N \\leq 500000$），表示 Byteburg 中的路口数量。接下来的 $N - 1$ 行中，每行包含一对用一个空格分隔的不同整数 $A_i$ 和 $B_i$（$1 \\leq A_i, B_i \\leq N$），表示连接路口 $A_i$ 和 $B_i$ 的街道。", "outputFormat": "如果不存在满足要求的路线，你的程序应在标准输出中输出一个单词“**BRAK**”（波兰语，意为“无”），不带引号。否则，你的程序应在标准输出中输出 $N$ 行，第 $i$ 行输出满足条件的第 $i$ 个路口的编号。显然，在这种情况下，第一行应为数字 $1$，第 $N$ 行应为数字 $N$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3550", "type": "P", "difficulty": 4, "samples": [["42 23 6\n20 25 14 27 30 7\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2013", "POI（波兰）"], "title": "[POI 2013] TAK-Taxis", "background": null, "description": "Byteasar 想从 Bytehole 镇乘坐出租车前往 Bytepit 镇，两镇之间的距离为 $m$ 公里。\n\n在从 Bytehole 镇前往 Bytepit 镇的途中，距离 Bytehole 镇恰好 $d$ 公里处，有一个停有 $n$ 辆出租车的基地，这些出租车编号为 1 到 $n$。\n\n其中，第 $i$ 辆出租车的燃油量足够行驶恰好 $x_i$ 公里。\n\nByteasar 可以在任意地点换乘出租车。\n\n所有出租车均从基地出发，且无需返回基地。\n\n你的任务是判断 Byteasar 能否从 Bytehole 镇抵达 Bytepit 镇；若能抵达，求出完成这段行程所需的最少出租车数量。", "inputFormat": "标准输入的第一行包含三个整数 $m$、$d$、$n$（$1 \\le d \\le m \\le 10^{18}$，$1 \\le n \\le 500000$），整数之间用单个空格分隔。\n\n它们分别表示：Bytehole 镇到 Bytepit 镇的距离、Bytehole 镇到出租车基地的距离、基地内出租车的数量。\n\n输入的第二行包含 $n$ 个整数 $x_1, x_2, \\cdots, x_n$（$1 \\le x_i \\le 10^{18}$），整数之间用单个空格分隔。\n\n其中 $x_i$ 表示第 $i$ 辆出租车最多能行驶的距离（单位：公里）。", "outputFormat": "你的程序应向标准输出打印一个整数：\n\n即 Byteasar 从 Bytehole 镇到 Bytepit 镇所需的最少出租车数量。若无法抵达，则输出 $0$。", "hint": "提示：此题需开 long long", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2013] TAK-Taxis", "background": null, "description": "Byteasar wants to take a taxi from the town Bytehole to the town Bytepit, which is $m$ kilometres away from Bytehole.\n\nExactly $d$ kilometres along the way from Bytehole to Bytepit, there is a base of $n$ taxis, numbered from $1$ to $n$.\n\nThe taxi no. $i$ has enough fuel to drive exactly $x_i$ kilometres.\n\nByteasar can change taxis at any point.\n\nAll the taxis start at their base but need not return there.\n\nYour task is to determine whether Byteasar can be driven from Bytehole to Bytepit, and if so, what it the minimum number of taxis required for such a journey.", "inputFormat": "The first line of the standard input holds three integers, $m$, $d$, and $n$ ($1\\le d\\le m\\le 10^{18}$, $1\\le n\\le 500\\ 000$), separated by single spaces.\n\nThose denote, respectively: the distance from Bytehole to Bytepit,the distance from Bytehole to the taxi base, and the number of taxis at the base.\n\nThe second line of input contains $n$ integers, $x_1,x_2,\\cdots,x_n$ ($1\\le x_i\\le 10^{18}$), separated by single spaces.\n\nThe number $x_i$ denotes the maximum distance (in kilometres) that the i-th taxi can travel.", "outputFormat": "Your program should print a single integer to the standard output:\n\nthe minimum number of taxis Byteasar has to take to get from Bytehole to Bytepit. If getting there is impossible, your program should print the number $0$.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[POI 2013] TAK-Taxis", "background": null, "description": "Byteasar 想从 Bytehole 镇乘坐出租车前往 Bytepit 镇，两镇之间的距离为 $m$ 公里。\n\n在从 Bytehole 镇前往 Bytepit 镇的途中，距离 Bytehole 镇恰好 $d$ 公里处，有一个停有 $n$ 辆出租车的基地，这些出租车编号为 1 到 $n$。\n\n其中，第 $i$ 辆出租车的燃油量足够行驶恰好 $x_i$ 公里。\n\nByteasar 可以在任意地点换乘出租车。\n\n所有出租车均从基地出发，且无需返回基地。\n\n你的任务是判断 Byteasar 能否从 Bytehole 镇抵达 Bytepit 镇；若能抵达，求出完成这段行程所需的最少出租车数量。", "inputFormat": "标准输入的第一行包含三个整数 $m$、$d$、$n$（$1 \\le d \\le m \\le 10^{18}$，$1 \\le n \\le 500000$），整数之间用单个空格分隔。\n\n它们分别表示：Bytehole 镇到 Bytepit 镇的距离、Bytehole 镇到出租车基地的距离、基地内出租车的数量。\n\n输入的第二行包含 $n$ 个整数 $x_1, x_2, \\cdots, x_n$（$1 \\le x_i \\le 10^{18}$），整数之间用单个空格分隔。\n\n其中 $x_i$ 表示第 $i$ 辆出租车最多能行驶的距离（单位：公里）。", "outputFormat": "你的程序应向标准输出打印一个整数：\n\n即 Byteasar 从 Bytehole 镇到 Bytepit 镇所需的最少出租车数量。若无法抵达，则输出 $0$。", "hint": "提示：此题需开 long long", "locale": "zh-CN"}}}
{"pid": "P3551", "type": "P", "difficulty": 4, "samples": [["12 2\nccbcbbbbbbcb\n", "1 8 12\n2 6 7\n3 4 5\n9 10 11\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "POI（波兰）", "Special Judge", "栈"], "title": "[POI 2013] USU-Take-out", "background": "", "description": "Little Edna has received the take-out game as a present.\n\nTake-out is a single player game, in which the player is given a sequence of $n$ adjacent blocks, numbered from $1$ to $n$.\n\nEach block is either black or white, and there are $k$ times as many white    blocks as there are black ones.\n\nThe player's goal is to remove all the blocks by certain permissible moves.\n\nA single move consists in removing exactly $k$ white blocks and a single    black block without changing the positions of other blocks.\n\nThe move is permissible if there is no \"gap\" (a space left by    a previously taken out block) between any two blocks being removed.\n\nHelp poor little Edna in finding any sequence of permissible moves that    remove all the blocks.\n\n有n块砖，其中白色是黑色的k倍，求一个消除序列，满足以下条件：\n\n每次消除k+1个砖，其中k块白色，1块黑色，并且这k+1块砖从开始到结束，中间不能路过已经消除过的砖\n\n数据保证有解\n", "inputFormat": "In the first line of the standard input there are two integers, $n$ and $k$ ($2\\le n\\le 1\\ 000\\ 000$, $1\\le k\\le n-1$), separated by a single space, that denote the total number of blocks used in the gameand the number of white blocks per black node (to be removed in every move).  In all the tests the condition $k+1|n$ holds.\n\nIn the second line there is a string of $n$ letters b      or c.  These tell the colours of successive blocks (in Polish):\n\nb (for biały) - white, c (for czarny)      - black.  You may assume that in all the tests there exists a sequence      of permissible moves that takes out all the blocks.\n", "outputFormat": "Your program should print $\\frac{n}{k+1}$ lines to the standard output.\n\nSuccessive lines should describe successive moves.\n\nEach line should contain $k+1$ integers, in increasing order,separated by single spaces, that denote the numbers of blocks to be removed in the move.\n", "hint": "有n块砖，其中白色是黑色的k倍，求一个消除序列，满足以下条件：\n\n每次消除k+1个砖，其中k块白色，1块黑色，并且这k+1块砖从开始到结束，中间不能路过已经消除过的砖\n\n数据保证有解\n\n\n返回`TAT1`：同一个位置输出$2$次\n\n返回`TAT2`：输出的$k+1$个位置不满足白色是黑色$k$倍\n\n返回`TAT3`：未按照升序输出或者中间路过已经消除的砖\n\nSPJ provided by @colazcy", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2013] USU-Take-out", "background": "", "description": "Little Edna has received the game Take-out as a present.\n\nTake-out is a single-player game played on a sequence of $n$ adjacent blocks, numbered from $1$ to $n$. Each block is either white or black, and there are $k$ times as many white blocks as black blocks. The goal is to remove all blocks using permissible moves.\n\nIn a single move, you remove exactly $k$ white blocks and $1$ black block, without changing the positions of the other blocks. A move is permissible if there is no “gap” (a position of a previously removed block) between any two blocks removed in that move.\n\nFind any sequence of permissible moves that removes all the blocks. It is guaranteed that a solution exists.", "inputFormat": "In the first line of the standard input there are two integers, $n$ and $k$ ($2\\le n\\le 1\\ 000\\ 000$, $1\\le k\\le n-1$), separated by a single space, that denote the total number of blocks used in the game and the number of white blocks per black block (to be removed in every move). In all the tests the condition $k+1|n$ holds.\n\nIn the second line there is a string of $n$ letters 'b' or 'c'. These tell the colours of successive blocks (in Polish): 'b' (for biały) — white, 'c' (for czarny) — black. You may assume that in all the tests there exists a sequence of permissible moves that takes out all the blocks.", "outputFormat": "Your program should print $\\frac{n}{k+1}$ lines to the standard output. Successive lines should describe successive moves. Each line should contain $k+1$ integers, in increasing order, separated by single spaces, that denote the numbers of blocks to be removed in the move.", "hint": "Return `TAT1`: the same position is output $2$ times.\n\nReturn `TAT2`: among the $k+1$ output positions, the number of white blocks is not $k$ times the number of black blocks.\n\nReturn `TAT3`: the positions are not in increasing order, or the segment passes through a block that has already been removed.\n\nSPJ provided by @colazcy.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2013] USU-Take-out", "background": "", "description": "Little Edna has received the take-out game as a present.\n\nTake-out is a single player game, in which the player is given a sequence of $n$ adjacent blocks, numbered from $1$ to $n$.\n\nEach block is either black or white, and there are $k$ times as many white    blocks as there are black ones.\n\nThe player's goal is to remove all the blocks by certain permissible moves.\n\nA single move consists in removing exactly $k$ white blocks and a single    black block without changing the positions of other blocks.\n\nThe move is permissible if there is no \"gap\" (a space left by    a previously taken out block) between any two blocks being removed.\n\nHelp poor little Edna in finding any sequence of permissible moves that    remove all the blocks.\n\n有n块砖，其中白色是黑色的k倍，求一个消除序列，满足以下条件：\n\n每次消除k+1个砖，其中k块白色，1块黑色，并且这k+1块砖从开始到结束，中间不能路过已经消除过的砖\n\n数据保证有解\n", "inputFormat": "In the first line of the standard input there are two integers, $n$ and $k$ ($2\\le n\\le 1\\ 000\\ 000$, $1\\le k\\le n-1$), separated by a single space, that denote the total number of blocks used in the gameand the number of white blocks per black node (to be removed in every move).  In all the tests the condition $k+1|n$ holds.\n\nIn the second line there is a string of $n$ letters b      or c.  These tell the colours of successive blocks (in Polish):\n\nb (for biały) - white, c (for czarny)      - black.  You may assume that in all the tests there exists a sequence      of permissible moves that takes out all the blocks.\n", "outputFormat": "Your program should print $\\frac{n}{k+1}$ lines to the standard output.\n\nSuccessive lines should describe successive moves.\n\nEach line should contain $k+1$ integers, in increasing order,separated by single spaces, that denote the numbers of blocks to be removed in the move.\n", "hint": "有n块砖，其中白色是黑色的k倍，求一个消除序列，满足以下条件：\n\n每次消除k+1个砖，其中k块白色，1块黑色，并且这k+1块砖从开始到结束，中间不能路过已经消除过的砖\n\n数据保证有解\n\n\n返回`TAT1`：同一个位置输出$2$次\n\n返回`TAT2`：输出的$k+1$个位置不满足白色是黑色$k$倍\n\n返回`TAT3`：未按照升序输出或者中间路过已经消除的砖\n\nSPJ provided by @colazcy", "locale": "zh-CN"}}}
