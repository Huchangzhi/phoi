{"pid": "P7581", "type": "P", "difficulty": 6, "samples": [["5 3 \n1 2 2\n1 3 1\n2 4 1\n2 5 2\n1 1\n1 2\n2 1", "3\n3\n3"], ["10 5\n1 2 1\n1 3 3\n2 4 2\n2 5 2\n3 6 3\n3 7 1\n5 8 2\n6 9 1\n6 10 3\n1 2\n3 2\n6 1\n1 3\n2 2", "40\n4\n4\n30\n0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2021", "树形 DP", "树链剖分", "线段树合并", "离线处理"], "title": "「RdOI R2」路径权值(distance)", "background": "此题读入量较大，请选择合适的读入方式。", "description": "给你一棵 $n$ 个点的边带权有根树，根节点为编号为 $1$ 的节点。定义 $u$ 的 $k-son$ 为 $u$ 子树中深度（指经过边数）比 $u$ **恰好**大 $k$ 的所有点。  \n$m$ 次询问求一个点 $u$ 的 $k-son$ 两两之间距离的和。你需要输出这个值 $\\bmod\\left(10^9+7\\right)$ 的结果。", "inputFormat": "第一行两个数 $n,m$。  \n接下来 $n-1$ 行每行三个数 $u,v,w$，代表 $u,v$ 之间有一条边权为 $w$ 的边。  \n接下来 $m$ 行每行两个数 $u,k$，代表一个询问。", "outputFormat": "对于每个询问输出一行答案。", "hint": "**样例 $1$ 解释**\n\n以下是样例中的树。  \n![](https://cdn.luogu.com.cn/upload/image_hosting/lz4oy8ao.png)\n\n---\n\n**样例 $2$ 解释**\n\n以下是样例中的树。  \n![](https://cdn.luogu.com.cn/upload/image_hosting/hb45pofr.png)\n\n---\n\n**数据范围**\n\n对于 $20\\%$ 的数据，$n,m,k\\le100$。  \n对于 $50\\%$ 的数据，$n,m,k\\le10^3$。  \n对于 $80\\%$ 的数据，$n,m,k\\le10^5$。  \n对于 $100\\%$ 的数据，$1\\le n,m,k\\le10^6,1\\le k\\le n,1\\le w\\le10^5,1\\le u,v\\le n$，保证给出的是一棵树。  ", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「RdOI R2」路径权值(distance)", "background": "此题读入量较大，请选择合适的读入方式。", "description": "给你一棵 $n$ 个点的边带权有根树，根节点为编号为 $1$ 的节点。定义 $u$ 的 $k-son$ 为 $u$ 子树中深度（指经过边数）比 $u$ **恰好**大 $k$ 的所有点。  \n$m$ 次询问求一个点 $u$ 的 $k-son$ 两两之间距离的和。你需要输出这个值 $\\bmod\\left(10^9+7\\right)$ 的结果。", "inputFormat": "第一行两个数 $n,m$。  \n接下来 $n-1$ 行每行三个数 $u,v,w$，代表 $u,v$ 之间有一条边权为 $w$ 的边。  \n接下来 $m$ 行每行两个数 $u,k$，代表一个询问。", "outputFormat": "对于每个询问输出一行答案。", "hint": "**样例 $1$ 解释**\n\n以下是样例中的树。  \n![](https://cdn.luogu.com.cn/upload/image_hosting/lz4oy8ao.png)\n\n---\n\n**样例 $2$ 解释**\n\n以下是样例中的树。  \n![](https://cdn.luogu.com.cn/upload/image_hosting/hb45pofr.png)\n\n---\n\n**数据范围**\n\n对于 $20\\%$ 的数据，$n,m,k\\le100$。  \n对于 $50\\%$ 的数据，$n,m,k\\le10^3$。  \n对于 $80\\%$ 的数据，$n,m,k\\le10^5$。  \n对于 $100\\%$ 的数据，$1\\le n,m,k\\le10^6,1\\le k\\le n,1\\le w\\le10^5,1\\le u,v\\le n$，保证给出的是一棵树。  ", "locale": "zh-CN"}}}
{"pid": "P7582", "type": "P", "difficulty": 7, "samples": [["3 4\nab 1\nba 2\na 1\n3 1 3 aba\n1 1 2 1\n2 2 3 2\n3 1 2 abab", "5\n6"], ["6 6\naba 3\nba 2\naa 2\nc 1\nabac 4\nab 2\n3 2 5 abac\n2 3 5 3\n3 4 6 abc\n1 2 3 1\n3 1 3 aabaa\n3 2 5 aabac", "7\n5\n14\n13"], ["6 3\nb 1\naa 8\ncc 9\ncac 8\nab 10\na 7\n2 1 3 2\n3 1 4 acac\n3 1 6 ccaba", "8\n28"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["树状数组", "2021", "O2优化", "分块", "AC 自动机", "KMP 算法"], "title": "「RdOI R2」风雨(rain)", "background": "经历过风雨的洗礼，小 Soup 才更懂得珍惜。他认为所有的一切对他来说都有重要的意义。为了能让这一切被自己牢牢铭记，小 Soup 决定用一些手段将它们记录下来。  \n\n[$\\text\\color{white}{真正的题目背景}$](https://z3.ax1x.com/2021/03/29/c9xbLj.gif)\n", "description": "小 Soup 在这段时间中记录了 $n$ 个有意义的东西，他把它们用字符串表示了出来，第 $i$ 个东西被表示成 $s_i$，并定义了它的价值 $a_i$。下面，小 Soup 会进行 $m$ 次操作。  \n操作 $1$：小 Soup 将区间 $l,r$ 里的 $a_i$ 都加上一个常数 $k$。  \n操作 $2$：小 Soup 将区间 $l,r$ 里的 $a_i$ 都赋值成一个常数 $k$。  \n操作 $3$：小 Soup 给出了一段回忆，这段回忆形成了一个字符串 $S$，他想求 $S$ 在区间 $l,r$ 中的意义有多大。定义 $cnt_i$ 为 $s_i$ 在 $S$ 中的出现次数，则 $S$ 在区间 $l,r$ 中的意义为 $\\sum\\limits_{i=l}^r cnt_i\\times a_i$。", "inputFormat": "第一行两个数，$n,m$。  \n接下来 $n$ 行第 $i$ 行一个字符串 $s_i$ 和一个数 $a_i$。  \n接下来 $m$ 行每行一个操作，先有三个数，$op,l,r$。其中 $op$ 代表操作类型。$op=3$ 时，多输入一个字符串 $S$，否则多输入一个数 $k$。", "outputFormat": "对于每个 $3$ 操作输出一个数，代表总价值。", "hint": "**样例 $1$ 解释**\n\n对于第一次询问，$s_1$ 出现了 $1$ 次，对价值贡献为 $1$；$s_2$ 出现了 $1$ 次，对价值贡献为 $2$；$s_3$ 出现了 $2$ 次，对价值贡献为 $2$，总价值为 $5$。  \n对于第二次询问，$s_1$ 出现了 $2$ 次，对价值贡献为 $4$；$s_2$ 出现了 $1$ 次，对价值贡献为 $2$，总价值为 $6$。 \n\n---\n\n**数据范围**\n\n|数据编号|$\\sum s,\\sum S$|$n,m$|特殊性质|\n|:---:|:---:|:---:|:---:|\n|$1\\sim 2$|$\\le5\\times10^3$|$10^3$|$\\diagdown$|\n|$3\\sim 4$|$\\le2\\times 10^5$|$3\\times10^4$|没有 $1$ 操作|\n|$5\\sim 8$|$\\le2\\times 10^5$|$3\\times10^4$|没有 $1,2$ 操作|\n|$9\\sim 13$|$\\le2\\times 10^5$|$3\\times10^4$| $\\diagdown$|\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le3\\times10^4,k\\ge 1,\\sum |S|,\\sum |s|\\le2\\times10^5$，任何时刻 $1\\le a_i\\le2\\times10^4$，保证只会出现 $a,b,c$ 三种字符。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「RdOI R2」风雨(rain)", "background": "经历过风雨的洗礼，小 Soup 才更懂得珍惜。他认为所有的一切对他来说都有重要的意义。为了能让这一切被自己牢牢铭记，小 Soup 决定用一些手段将它们记录下来。  \n\n[$\\text\\color{white}{真正的题目背景}$](https://z3.ax1x.com/2021/03/29/c9xbLj.gif)\n", "description": "小 Soup 在这段时间中记录了 $n$ 个有意义的东西，他把它们用字符串表示了出来，第 $i$ 个东西被表示成 $s_i$，并定义了它的价值 $a_i$。下面，小 Soup 会进行 $m$ 次操作。  \n操作 $1$：小 Soup 将区间 $l,r$ 里的 $a_i$ 都加上一个常数 $k$。  \n操作 $2$：小 Soup 将区间 $l,r$ 里的 $a_i$ 都赋值成一个常数 $k$。  \n操作 $3$：小 Soup 给出了一段回忆，这段回忆形成了一个字符串 $S$，他想求 $S$ 在区间 $l,r$ 中的意义有多大。定义 $cnt_i$ 为 $s_i$ 在 $S$ 中的出现次数，则 $S$ 在区间 $l,r$ 中的意义为 $\\sum\\limits_{i=l}^r cnt_i\\times a_i$。", "inputFormat": "第一行两个数，$n,m$。  \n接下来 $n$ 行第 $i$ 行一个字符串 $s_i$ 和一个数 $a_i$。  \n接下来 $m$ 行每行一个操作，先有三个数，$op,l,r$。其中 $op$ 代表操作类型。$op=3$ 时，多输入一个字符串 $S$，否则多输入一个数 $k$。", "outputFormat": "对于每个 $3$ 操作输出一个数，代表总价值。", "hint": "**样例 $1$ 解释**\n\n对于第一次询问，$s_1$ 出现了 $1$ 次，对价值贡献为 $1$；$s_2$ 出现了 $1$ 次，对价值贡献为 $2$；$s_3$ 出现了 $2$ 次，对价值贡献为 $2$，总价值为 $5$。  \n对于第二次询问，$s_1$ 出现了 $2$ 次，对价值贡献为 $4$；$s_2$ 出现了 $1$ 次，对价值贡献为 $2$，总价值为 $6$。 \n\n---\n\n**数据范围**\n\n|数据编号|$\\sum s,\\sum S$|$n,m$|特殊性质|\n|:---:|:---:|:---:|:---:|\n|$1\\sim 2$|$\\le5\\times10^3$|$10^3$|$\\diagdown$|\n|$3\\sim 4$|$\\le2\\times 10^5$|$3\\times10^4$|没有 $1$ 操作|\n|$5\\sim 8$|$\\le2\\times 10^5$|$3\\times10^4$|没有 $1,2$ 操作|\n|$9\\sim 13$|$\\le2\\times 10^5$|$3\\times10^4$| $\\diagdown$|\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le3\\times10^4,k\\ge 1,\\sum |S|,\\sum |s|\\le2\\times10^5$，任何时刻 $1\\le a_i\\le2\\times10^4$，保证只会出现 $a,b,c$ 三种字符。", "locale": "zh-CN"}}}
{"pid": "P7583", "type": "P", "difficulty": 1, "samples": [["LOVA", "LOV"], ["KARIJERA", "KJ"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768]}, "tags": ["模拟", "字符串", "2012", "COCI（克罗地亚）"], "title": "[COCI 2012/2013 #1] DOM", "background": "", "description": "给定一个仅包含大写字母的单词，删除该单词中的以下九个字母：$\\texttt{C,A,M,B,R,I,D,G,E}$。", "inputFormat": "一行一个字符串，表示给定的单词。", "outputFormat": "一行一个字符串，表示删除字母后的字符串。", "hint": "#### 【数据范围】\n\n对于 $100\\%$ 的数据，保证 $3 \\le$ 单词长度 $\\le 100$。\n\n#### 【说明】\n\n本题分值按 COCI 原题设置，满分 $50$。\n\n题目译自 **[COCI2012-2013 CONTEST #1](https://hsin.hr/coci/archive/2012_2013/contest1_tasks.pdf)  _T1 DOM_**。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2012/2013 #1] DOM", "background": "", "description": "给定一个仅包含大写字母的单词，删除该单词中的以下九个字母：$\\texttt{C,A,M,B,R,I,D,G,E}$。", "inputFormat": "一行一个字符串，表示给定的单词。", "outputFormat": "一行一个字符串，表示删除字母后的字符串。", "hint": "#### 【数据范围】\n\n对于 $100\\%$ 的数据，保证 $3 \\le$ 单词长度 $\\le 100$。\n\n#### 【说明】\n\n本题分值按 COCI 原题设置，满分 $50$。\n\n题目译自 **[COCI2012-2013 CONTEST #1](https://hsin.hr/coci/archive/2012_2013/contest1_tasks.pdf)  _T1 DOM_**。", "locale": "zh-CN"}}}
{"pid": "P7584", "type": "P", "difficulty": 2, "samples": [["3\n8\n10\n9", "3"], ["5\n15\n14\n15\n12\n14", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768]}, "tags": ["贪心", "2012", "排序", "COCI（克罗地亚）"], "title": "[COCI 2012/2013 #1] F7", "background": "", "description": "有 $N$ 位选手参加一个比赛。每个回合，第一名会得到 $N$ 分，第二名会得到 $N - 1$ 分，以此类推，最后一名会得到 $1$ 分。\n\n现在第 $i$ 位选手初始有 $B_i$ 分。求多少选手经过一个回合，分数有机会变成所有选手中最高的。", "inputFormat": "输入共 $N+1$ 行。\n\n第一行包含一个正整数 $N$，表示选手总数。\n\n接下来 $N$ 行，每行包含一个整数 $B_i$，表示第 $i$ 位选手的初始分数。", "outputFormat": "输出一行一个整数，表示多少选手的分数有机会变成所有选手中最高的。", "hint": "#### 【数据范围】\n\n对于 $100\\%$ 的数据，$3 \\le N \\le 3 \\times 10^5$，$1 \\le B_i \\le 2 \\cdot 10^6$。\n\n#### 【说明】\n\n本题分值按 COCI 原题设置，满分 $80$。\n\n题目译自 **[COCI2012-2013](https://hsin.hr/coci/archive/2012_2013) [CONTEST #1](https://hsin.hr/coci/archive/2012_2013/contest1_tasks.pdf) _T2 F7_**。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2012/2013 #1] F7", "background": "", "description": "有 $N$ 位选手参加一个比赛。每个回合，第一名会得到 $N$ 分，第二名会得到 $N - 1$ 分，以此类推，最后一名会得到 $1$ 分。\n\n现在第 $i$ 位选手初始有 $B_i$ 分。求多少选手经过一个回合，分数有机会变成所有选手中最高的。", "inputFormat": "输入共 $N+1$ 行。\n\n第一行包含一个正整数 $N$，表示选手总数。\n\n接下来 $N$ 行，每行包含一个整数 $B_i$，表示第 $i$ 位选手的初始分数。", "outputFormat": "输出一行一个整数，表示多少选手的分数有机会变成所有选手中最高的。", "hint": "#### 【数据范围】\n\n对于 $100\\%$ 的数据，$3 \\le N \\le 3 \\times 10^5$，$1 \\le B_i \\le 2 \\cdot 10^6$。\n\n#### 【说明】\n\n本题分值按 COCI 原题设置，满分 $80$。\n\n题目译自 **[COCI2012-2013](https://hsin.hr/coci/archive/2012_2013) [CONTEST #1](https://hsin.hr/coci/archive/2012_2013/contest1_tasks.pdf) _T2 F7_**。", "locale": "zh-CN"}}}
{"pid": "P7585", "type": "P", "difficulty": 2, "samples": [["5 2\n7\n4", "3"], ["7 5\n7\n1\n7\n4\n4", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["2012", "二分", "COCI（克罗地亚）"], "title": "[COCI 2012/2013 #1] LJUBOMORA", "background": "", "description": "一家弹珠厂向一所幼儿园捐赠了一些弹珠，弹珠一共有 $M$ 种颜色，每颗弹珠都有一种颜色。老师需要把所有的弹珠分给 $N$ 个孩子。每个孩子得到的所有弹珠都必须是**相同的颜色**，而且可以有一些孩子一颗弹珠也没得到。\n\n我们把**嫉妒值**定义为分给一个孩子最多的弹珠数量。请你帮助老师分弹珠，使得嫉妒值**最小**。\n\n例如，如果有 $4$ 个红色的弹珠（$\\texttt{RRRR}$）和 $7$ 个蓝色的弹珠（$\\texttt{BBBBBBB}$），要分给 $5$ 个孩子，那么我们可以这样划分：$\\texttt{RR}$，$\\texttt{RR}$，$\\texttt{BB}$，$\\texttt{BB}$，$\\texttt{BBB}$。这样分的嫉妒值为 $3$，是最小的。", "inputFormat": "输入共 $M+1$ 行。\n\n第一行包含两个正整数 $N,M$，分别表示孩子数和弹珠的颜色总数。\n\n接下来 $M$ 行的第 $i$ 行包含一个正整数 $x$（$x \\in [1,10^9]$），表示有 $x$ 个颜色为 $i$ 的弹珠。", "outputFormat": "输出一行一个整数，表示最小的嫉妒值。", "hint": "#### 【数据范围】\n\n对于 $100\\%$ 的数据，保证 $1 \\le M \\le 3 \\times 10^5$，$1 \\le N \\le 10^9$，$M \\le N$。\n\n#### 【说明】\n\n本题分值按 COCI 原题设置，满分 $120$。\n\n题目译自 **[COCI2012-2013](https://hsin.hr/coci/archive/2012_2013/) [CONTEST #1](https://hsin.hr/coci/archive/2012_2013/contest1_tasks.pdf)** ___T4 LJUBOMORA___。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2012/2013 #1] LJUBOMORA", "background": "", "description": "一家弹珠厂向一所幼儿园捐赠了一些弹珠，弹珠一共有 $M$ 种颜色，每颗弹珠都有一种颜色。老师需要把所有的弹珠分给 $N$ 个孩子。每个孩子得到的所有弹珠都必须是**相同的颜色**，而且可以有一些孩子一颗弹珠也没得到。\n\n我们把**嫉妒值**定义为分给一个孩子最多的弹珠数量。请你帮助老师分弹珠，使得嫉妒值**最小**。\n\n例如，如果有 $4$ 个红色的弹珠（$\\texttt{RRRR}$）和 $7$ 个蓝色的弹珠（$\\texttt{BBBBBBB}$），要分给 $5$ 个孩子，那么我们可以这样划分：$\\texttt{RR}$，$\\texttt{RR}$，$\\texttt{BB}$，$\\texttt{BB}$，$\\texttt{BBB}$。这样分的嫉妒值为 $3$，是最小的。", "inputFormat": "输入共 $M+1$ 行。\n\n第一行包含两个正整数 $N,M$，分别表示孩子数和弹珠的颜色总数。\n\n接下来 $M$ 行的第 $i$ 行包含一个正整数 $x$（$x \\in [1,10^9]$），表示有 $x$ 个颜色为 $i$ 的弹珠。", "outputFormat": "输出一行一个整数，表示最小的嫉妒值。", "hint": "#### 【数据范围】\n\n对于 $100\\%$ 的数据，保证 $1 \\le M \\le 3 \\times 10^5$，$1 \\le N \\le 10^9$，$M \\le N$。\n\n#### 【说明】\n\n本题分值按 COCI 原题设置，满分 $120$。\n\n题目译自 **[COCI2012-2013](https://hsin.hr/coci/archive/2012_2013/) [CONTEST #1](https://hsin.hr/coci/archive/2012_2013/contest1_tasks.pdf)** ___T4 LJUBOMORA___。", "locale": "zh-CN"}}}
{"pid": "P7586", "type": "P", "difficulty": 4, "samples": [["3 6", "11"], ["100 200", "262"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["数学", "2012", "COCI（克罗地亚）"], "title": "[COCI 2012/2013 #1] SNAGA", "background": "", "description": "从一个正整数 $N$ 开始，找到不能被 $N$ 整除的最小正整数。如果我们用得到的正整数重复这个过程，我们最终会得到 $2$。\n\n定义 $\\operatorname{strength}(N)$ 为结果序列的长度。例如 $N = 6$，可以得到由 $4$ 个数字组成的结果序列 $6,4,3,2$，包含 $4$ 个整数，所以 $\\operatorname{strength}(6) = 4$。\n\n给定两个正整数 $A,B$，请计算：\n\n$$ \\sum\\limits_{i=A}^B \\operatorname{strength}(i)$$", "inputFormat": "输入共一行，包含两个用空格分隔的整数 $A,B$。", "outputFormat": "输出一行一个整数，表示结果。", "hint": "#### 【数据范围】\n\n对于 $100\\%$ 的数据，保证 $3 \\le A < B \\le 10^{17}$。\n\n#### 【说明】\n\n本题分值按 COCI 原题设置，满分 $140$。\n\n题目译自 **[COCI2012-2013](https://hsin.hr/coci/archive/2012_2013/) [CONTEST #1](https://hsin.hr/coci/archive/2012_2013/contest1_tasks.pdf)** ___T5 SNAGA___。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2012/2013 #1] SNAGA", "background": "", "description": "从一个正整数 $N$ 开始，找到不能被 $N$ 整除的最小正整数。如果我们用得到的正整数重复这个过程，我们最终会得到 $2$。\n\n定义 $\\operatorname{strength}(N)$ 为结果序列的长度。例如 $N = 6$，可以得到由 $4$ 个数字组成的结果序列 $6,4,3,2$，包含 $4$ 个整数，所以 $\\operatorname{strength}(6) = 4$。\n\n给定两个正整数 $A,B$，请计算：\n\n$$ \\sum\\limits_{i=A}^B \\operatorname{strength}(i)$$", "inputFormat": "输入共一行，包含两个用空格分隔的整数 $A,B$。", "outputFormat": "输出一行一个整数，表示结果。", "hint": "#### 【数据范围】\n\n对于 $100\\%$ 的数据，保证 $3 \\le A < B \\le 10^{17}$。\n\n#### 【说明】\n\n本题分值按 COCI 原题设置，满分 $140$。\n\n题目译自 **[COCI2012-2013](https://hsin.hr/coci/archive/2012_2013/) [CONTEST #1](https://hsin.hr/coci/archive/2012_2013/contest1_tasks.pdf)** ___T5 SNAGA___。", "locale": "zh-CN"}}}
{"pid": "P7587", "type": "P", "difficulty": 5, "samples": [["2\n0 7 2 1\n7 0 4 3\n2 4 0 5\n1 3 5 0", "13"], ["3\n0 2 6 3 4 7 1 3\n2 0 7 10 9 1 3 6\n6 7 0 3 5 6 5 5\n3 10 3 0 9 8 9 7\n4 9 5 9 0 9 8 4\n7 1 6 8 9 0 8 7\n1 3 5 9 8 8 0 10\n3 6 5 7 4 7 10 0", "32"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["动态规划 DP", "2012", "区间 DP", "COCI（克罗地亚）"], "title": "[COCI 2012/2013 #1] MARS", "background": "", "description": "科学家在火星上发现了一些奇怪的细菌，正在研究它们。他们注意到细菌的数量是 $2$ 的次方，因为每一种细菌都会分裂成两种新的细菌，而初始有一种细菌。因此，在第一代中只有一种细菌，第二代中有两种细菌，第三代中有四种细菌，以此类推，直到第 $K + 1$ 代中有 $2^K$ 种细菌。\n\n科学家们用 $1$ 至 $2^K$ 之间的整数给细菌进行了编号，方法如下：\n\n- 第 $K$ 代细菌的后代按顺序分别为：$\\{1,2\\},\\{3,4\\},\\{5,6\\},\\cdots,\\{2^K-1,2^K\\}$\n- 第 $K - 1$ 代细菌的后代按顺序分别为：$\\{1,2,3,4\\},\\{5,6,7,8\\},\\cdots,\\{2^K-3,2^K-2,2^K-1,2^K\\}$\n- 第 $K - 2$ 代细菌的后代按顺序分别为：$\\{1,2,3,4,5,6,7,8\\},\\cdots,\\{2^K-7,2^K-6,2^K-5,2^K-4,2^K-3,2^K-2,2^K-1,2^K\\}$\n- $\\cdots$\n- 第 $1$ 代细菌的后代按顺序分别为：$\\{1,2,\\cdots,2^{K-1}\\},\\{2^{K-1}+1,2^{K-1}+2,\\cdots,2^K\\}$\n\n其中花括号表示一个细菌的一组后代。\n\n也就是说，对当前这一代的 $2^K$ 个细菌进行编号，使得任何较老细菌的后代都有连续的编号。**注意这些细菌存在许多种不同的 仍然满足任何较老细菌的后代都有连续编号的条件 的排列。**\n\n科学家想把细菌排列成一个**长度尽可能短**的序列。细菌序列的长度是**所有相邻的细菌对之间的距离的总和**。\n\n确切地说，每两个细菌之间都有一定的**排斥值**。如果它们在序列中相邻，这个排斥值就是它们之间的最小距离（序列中不相邻的细菌之间的排斥值不起作用）。给定所有细菌对的排斥值，找出满足上述后代规则的细菌序列（排列）的最小长度。", "inputFormat": "输入的第一行包含一个正整数 $K$，意义见题目描述。\n\n接下来的 $2^K$ 行，每行包含在 $[0,10^6]$ 范围内的 $2^K$ 个整数。这 $2^K \\times 2^K$ 个整数表示细菌对之间的排斥值：第 $m$ 行第 $n$ 列中的整数是细菌 $m$ 和细菌 $n$ 之间的排斥值。当然这个整数等于第 $n$ 行第 $m$ 列的整数。如果 $m=n$，这个整数将会是 $0$。", "outputFormat": "输出一行一个整数，表示满足条件的细菌序列的最小长度。", "hint": "#### 【数据范围】\n\n对于 $100\\%$ 的数据，保证 $1 \\le K \\le 9$。\n\n#### 【说明】\n\n本题分值按 COCI 原题设置，满分 $160$。\n\n题目译自 **[COCI2012-2013](https://hsin.hr/coci/archive/2012_2013/) [CONTEST #1](https://hsin.hr/coci/archive/2012_2013/contest1_tasks.pdf)** ___T6 MARS___。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2012/2013 #1] MARS", "background": "", "description": "科学家在火星上发现了一些奇怪的细菌，正在研究它们。他们注意到细菌的数量是 $2$ 的次方，因为每一种细菌都会分裂成两种新的细菌，而初始有一种细菌。因此，在第一代中只有一种细菌，第二代中有两种细菌，第三代中有四种细菌，以此类推，直到第 $K + 1$ 代中有 $2^K$ 种细菌。\n\n科学家们用 $1$ 至 $2^K$ 之间的整数给细菌进行了编号，方法如下：\n\n- 第 $K$ 代细菌的后代按顺序分别为：$\\{1,2\\},\\{3,4\\},\\{5,6\\},\\cdots,\\{2^K-1,2^K\\}$\n- 第 $K - 1$ 代细菌的后代按顺序分别为：$\\{1,2,3,4\\},\\{5,6,7,8\\},\\cdots,\\{2^K-3,2^K-2,2^K-1,2^K\\}$\n- 第 $K - 2$ 代细菌的后代按顺序分别为：$\\{1,2,3,4,5,6,7,8\\},\\cdots,\\{2^K-7,2^K-6,2^K-5,2^K-4,2^K-3,2^K-2,2^K-1,2^K\\}$\n- $\\cdots$\n- 第 $1$ 代细菌的后代按顺序分别为：$\\{1,2,\\cdots,2^{K-1}\\},\\{2^{K-1}+1,2^{K-1}+2,\\cdots,2^K\\}$\n\n其中花括号表示一个细菌的一组后代。\n\n也就是说，对当前这一代的 $2^K$ 个细菌进行编号，使得任何较老细菌的后代都有连续的编号。**注意这些细菌存在许多种不同的 仍然满足任何较老细菌的后代都有连续编号的条件 的排列。**\n\n科学家想把细菌排列成一个**长度尽可能短**的序列。细菌序列的长度是**所有相邻的细菌对之间的距离的总和**。\n\n确切地说，每两个细菌之间都有一定的**排斥值**。如果它们在序列中相邻，这个排斥值就是它们之间的最小距离（序列中不相邻的细菌之间的排斥值不起作用）。给定所有细菌对的排斥值，找出满足上述后代规则的细菌序列（排列）的最小长度。", "inputFormat": "输入的第一行包含一个正整数 $K$，意义见题目描述。\n\n接下来的 $2^K$ 行，每行包含在 $[0,10^6]$ 范围内的 $2^K$ 个整数。这 $2^K \\times 2^K$ 个整数表示细菌对之间的排斥值：第 $m$ 行第 $n$ 列中的整数是细菌 $m$ 和细菌 $n$ 之间的排斥值。当然这个整数等于第 $n$ 行第 $m$ 列的整数。如果 $m=n$，这个整数将会是 $0$。", "outputFormat": "输出一行一个整数，表示满足条件的细菌序列的最小长度。", "hint": "#### 【数据范围】\n\n对于 $100\\%$ 的数据，保证 $1 \\le K \\le 9$。\n\n#### 【说明】\n\n本题分值按 COCI 原题设置，满分 $160$。\n\n题目译自 **[COCI2012-2013](https://hsin.hr/coci/archive/2012_2013/) [CONTEST #1](https://hsin.hr/coci/archive/2012_2013/contest1_tasks.pdf)** ___T6 MARS___。", "locale": "zh-CN"}}}
{"pid": "P7588", "type": "P", "difficulty": 3, "samples": [["4\n3 3\n4 4\n1 5\n1 15", "1\n0\n3\n5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 98304]}, "tags": ["数学", "二分", "2021", "O2优化", "素数判断,质数,筛法"], "title": "双重素数（2021 CoE-II A）", "background": "", "description": "素数（质数）是指在大于 $1$ 的自然数中，除了 $1$ 和它本身以外不再有其他因数的自然数。定义**双重素数**为这样的素数：它的各位数字之和也是一个素数。给定一个闭区间，试确定在该区间内双重素数的个数。", "inputFormat": "**输入包含多组测试数据。**\n\n输入第一行包含一个整数 $T$，表示测试数据的组数。接下来每行一组测试数据，每组测试数据包含以空格分隔的两个整数 $L$ 和 $R$。", "outputFormat": "每组测试数据输出一行，包含一个整数，表示在闭区间 $[L,\\ R]$ 内双重素数的个数。", "hint": "**样例说明**\n\n从 $1$ 到 $15$ 共有 $6$ 个素数：$2$，$3$，$5$，$7$，$11$，$13$。前五个素数各自的数字之和也是素数，因此都是双重素数。素数 $13$ 的各位数字之和为 $4$，不是素数，故 $13$ 不是双重素数。\n\n------------\n\n\n**数据范围**\n\n- Subtask $1$ ：$1 \\le L \\le R \\le 10^2$，$10$ 分。\n- Subtask $2$ ：$1 \\le L \\le R \\le 10^4$，$20$ 分。\n- Subtask $3$ ：$1 \\le L \\le R \\le 10^6$，$60$ 分。\n- Subtask $4$ ：$1 \\le L \\le R \\le 10^8$，$10$ 分。\n\n对于 $100\\%$ 的数据，$1 \\le T \\le 100$。\n\n\n------------\n\n**提示（数据已经加强）**\n\n最后一个子任务要求你的程序必须具有较高的空间使用效率和时间效率，否则容易超出内存限制或时间限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "双重素数（2021 CoE-II A）", "background": "", "description": "素数（质数）是指在大于 $1$ 的自然数中，除了 $1$ 和它本身以外不再有其他因数的自然数。定义**双重素数**为这样的素数：它的各位数字之和也是一个素数。给定一个闭区间，试确定在该区间内双重素数的个数。", "inputFormat": "**输入包含多组测试数据。**\n\n输入第一行包含一个整数 $T$，表示测试数据的组数。接下来每行一组测试数据，每组测试数据包含以空格分隔的两个整数 $L$ 和 $R$。", "outputFormat": "每组测试数据输出一行，包含一个整数，表示在闭区间 $[L,\\ R]$ 内双重素数的个数。", "hint": "**样例说明**\n\n从 $1$ 到 $15$ 共有 $6$ 个素数：$2$，$3$，$5$，$7$，$11$，$13$。前五个素数各自的数字之和也是素数，因此都是双重素数。素数 $13$ 的各位数字之和为 $4$，不是素数，故 $13$ 不是双重素数。\n\n------------\n\n\n**数据范围**\n\n- Subtask $1$ ：$1 \\le L \\le R \\le 10^2$，$10$ 分。\n- Subtask $2$ ：$1 \\le L \\le R \\le 10^4$，$20$ 分。\n- Subtask $3$ ：$1 \\le L \\le R \\le 10^6$，$60$ 分。\n- Subtask $4$ ：$1 \\le L \\le R \\le 10^8$，$10$ 分。\n\n对于 $100\\%$ 的数据，$1 \\le T \\le 100$。\n\n\n------------\n\n**提示（数据已经加强）**\n\n最后一个子任务要求你的程序必须具有较高的空间使用效率和时间效率，否则容易超出内存限制或时间限制。", "locale": "zh-CN"}}}
{"pid": "P7589", "type": "P", "difficulty": 4, "samples": [["2\n\n2 0 10\n3 4 8\n7 7 5\n\n3 5 15\n-3 -9 -19\n-7 10 21\n12 12 16", "Yes\nNo"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["博弈论", "2021", "O2优化", "SG 函数"], "title": "黑白棋（2021 CoE-II B）", "background": "", "description": "$\\text{Alice}$ 和 $\\text{Bob}$ 正在玩一种称为“黑白棋”的游戏。该游戏的规则如下：\n\n- 游戏在直角坐标系中进行。\n\n- $\\text{Alice}$ 执黑棋，$\\text{Bob}$ 执白棋。\n\n- 初始时，在直角坐标系中任选 $n$ 条与 $X$ 轴平行的直线，直线在 $Y$ 轴上的截距均为整数，且互不相同。$\\text{Alice}$ 在每条直线上都会放置一枚黑棋，$\\text{Bob}$ 在每条直线上都会放置一枚白棋，棋子位置的 $X$ 坐标值均为整数。在同一条直线上的两枚棋子位置不会相同。\n\n- $\\text{Alice}$ 和 $\\text{Bob}$ 轮流走棋，$\\text{Alice}$ 总是先走棋。每名玩家在走棋时，先选择一条直线，然后沿着直线移动该条直线上己方颜色的棋子。\n\n- 每个玩家可以将自己的棋子向着靠近对方棋子的方向一次性移动若干整数单位距离，称之为**前进**。每个玩家也可以向着远离对方棋子的方向一次性移动若干整数单位距离，称之为**后退**。只要在前进时不跨过对方的棋子，也不使黑棋和白棋的位置发生重叠，前进的最远距离不限，但是前进的距离至少为 $1$，如果无法满足前述条件，则玩家不能执行前进操作。为了避免玩家反复后退导致游戏无法结束，在一局游戏中，某个玩家执行后退操作的总次数不能超过 $k$ 次。与此同时，为了防止游戏区域太大以致在显示游戏状态上造成不便，每次后退的距离至少为 $1$，但不能超过 $d$。如果无法满足前述条件，玩家不能执行后退操作。\n\n- 玩家在轮到自己走棋时，如果能够执行操作就必须执行一次操作，此操作可以是前进操作，也可以是后退操作（如果未超出后退次数的限制）。\n\n- 如果某个玩家无法执行任何操作来移动自己的棋子，将输掉游戏，游戏结束。\n\n给定游戏的初始状态，假设 $\\text{Alice}$ 和 $\\text{Bob}$ 在游戏时均采用最佳策略，试确定 $\\text{Alice}$ 能否获胜。", "inputFormat": "**输入包含多组测试数据。**\n\n输入第一行包含一个整数 $T$，表示测试数据的组数。接着是一个空行。接下来是 $T$ 组表示游戏初始状态的数据。\n\n每组数据的第一行包含三个整数 $n$，$k$，$d$，表示直线的数量，允许后退的总次数，每次后退的最大距离。接下来是 $n$ 行数据，每行包含三个整数 $y_i$，$b_i$，$w_i$，分别表示第 $i$ 条直线的 $Y$ 轴截距以及在该条直线上的黑棋的 $X$ 坐标值和白棋的 $X$ 坐标值（$b_i \\ne w_i$）。\n\n每两组测试数据之间有一个空行。", "outputFormat": "如果 $\\text{Alice}$ 能够获胜，输出 `Yes`，否则输出 `No`。", "hint": "**样例说明**\n\n下图对应输入 \\#1 的第一组数据，如果 $\\text{Alice}$ 采用最优策略，无论 $\\text{Bob}$ 如何走棋，$\\text{Alice}$ 都能够获胜。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3y151p4f.png)\n\n以下是 $\\text{Alice}$ 的必胜策略。首先，$\\text{Alice}$ 选择将 $y=3$ 的直线上的黑棋从 `4` 移动到 `6`，使得两条直线上黑棋和白棋之间的间距均为 $2$，由于 $k$ 为 $0$，相当于不允许执行后退操作，如果 $\\text{Bob}$ 选择移动 $y=3$ 直线上的白棋，将使得该直线上的两颗棋子相邻，后续无法再移动。同样的，如果 $\\text{Bob}$ 选择移动 $y=7$ 直线上的白棋，也将使得该直线上的两颗棋子相邻，后续无法再移动。因此无论 $\\text{Bob}$ 如何操作，总会使得一条直线上的两颗棋子相邻，无法再继续移动，而另外一条直线上的棋子间距为 $2$，还可以再移动一次，$\\text{Alice}$ 将剩下可以移动的黑棋再移动一步后，后续 $\\text{Bob}$ 无法移动白棋，因此 $\\text{Alice}$ 会获胜。\n\n对于输入 \\#1 的第二组数据，无论 $\\text{Alice}$ 如何走棋，$\\text{Bob}$ 总能够获胜。\n\n------------\n\n**数据范围**\n\n对于 $100\\%$ 的数据，$1 \\le T \\le 100$，$1 \\le n \\le 100$，$0 \\le k \\le 100$，$1 \\le d \\le 20$，$-100 \\le y_i \\le 100$，$-10^3 \\le b_i \\le 10^3$，$-10^3 \\le w_i \\le 10^3$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "黑白棋（2021 CoE-II B）", "background": "", "description": "$\\text{Alice}$ 和 $\\text{Bob}$ 正在玩一种称为“黑白棋”的游戏。该游戏的规则如下：\n\n- 游戏在直角坐标系中进行。\n\n- $\\text{Alice}$ 执黑棋，$\\text{Bob}$ 执白棋。\n\n- 初始时，在直角坐标系中任选 $n$ 条与 $X$ 轴平行的直线，直线在 $Y$ 轴上的截距均为整数，且互不相同。$\\text{Alice}$ 在每条直线上都会放置一枚黑棋，$\\text{Bob}$ 在每条直线上都会放置一枚白棋，棋子位置的 $X$ 坐标值均为整数。在同一条直线上的两枚棋子位置不会相同。\n\n- $\\text{Alice}$ 和 $\\text{Bob}$ 轮流走棋，$\\text{Alice}$ 总是先走棋。每名玩家在走棋时，先选择一条直线，然后沿着直线移动该条直线上己方颜色的棋子。\n\n- 每个玩家可以将自己的棋子向着靠近对方棋子的方向一次性移动若干整数单位距离，称之为**前进**。每个玩家也可以向着远离对方棋子的方向一次性移动若干整数单位距离，称之为**后退**。只要在前进时不跨过对方的棋子，也不使黑棋和白棋的位置发生重叠，前进的最远距离不限，但是前进的距离至少为 $1$，如果无法满足前述条件，则玩家不能执行前进操作。为了避免玩家反复后退导致游戏无法结束，在一局游戏中，某个玩家执行后退操作的总次数不能超过 $k$ 次。与此同时，为了防止游戏区域太大以致在显示游戏状态上造成不便，每次后退的距离至少为 $1$，但不能超过 $d$。如果无法满足前述条件，玩家不能执行后退操作。\n\n- 玩家在轮到自己走棋时，如果能够执行操作就必须执行一次操作，此操作可以是前进操作，也可以是后退操作（如果未超出后退次数的限制）。\n\n- 如果某个玩家无法执行任何操作来移动自己的棋子，将输掉游戏，游戏结束。\n\n给定游戏的初始状态，假设 $\\text{Alice}$ 和 $\\text{Bob}$ 在游戏时均采用最佳策略，试确定 $\\text{Alice}$ 能否获胜。", "inputFormat": "**输入包含多组测试数据。**\n\n输入第一行包含一个整数 $T$，表示测试数据的组数。接着是一个空行。接下来是 $T$ 组表示游戏初始状态的数据。\n\n每组数据的第一行包含三个整数 $n$，$k$，$d$，表示直线的数量，允许后退的总次数，每次后退的最大距离。接下来是 $n$ 行数据，每行包含三个整数 $y_i$，$b_i$，$w_i$，分别表示第 $i$ 条直线的 $Y$ 轴截距以及在该条直线上的黑棋的 $X$ 坐标值和白棋的 $X$ 坐标值（$b_i \\ne w_i$）。\n\n每两组测试数据之间有一个空行。", "outputFormat": "如果 $\\text{Alice}$ 能够获胜，输出 `Yes`，否则输出 `No`。", "hint": "**样例说明**\n\n下图对应输入 \\#1 的第一组数据，如果 $\\text{Alice}$ 采用最优策略，无论 $\\text{Bob}$ 如何走棋，$\\text{Alice}$ 都能够获胜。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3y151p4f.png)\n\n以下是 $\\text{Alice}$ 的必胜策略。首先，$\\text{Alice}$ 选择将 $y=3$ 的直线上的黑棋从 `4` 移动到 `6`，使得两条直线上黑棋和白棋之间的间距均为 $2$，由于 $k$ 为 $0$，相当于不允许执行后退操作，如果 $\\text{Bob}$ 选择移动 $y=3$ 直线上的白棋，将使得该直线上的两颗棋子相邻，后续无法再移动。同样的，如果 $\\text{Bob}$ 选择移动 $y=7$ 直线上的白棋，也将使得该直线上的两颗棋子相邻，后续无法再移动。因此无论 $\\text{Bob}$ 如何操作，总会使得一条直线上的两颗棋子相邻，无法再继续移动，而另外一条直线上的棋子间距为 $2$，还可以再移动一次，$\\text{Alice}$ 将剩下可以移动的黑棋再移动一步后，后续 $\\text{Bob}$ 无法移动白棋，因此 $\\text{Alice}$ 会获胜。\n\n对于输入 \\#1 的第二组数据，无论 $\\text{Alice}$ 如何走棋，$\\text{Bob}$ 总能够获胜。\n\n------------\n\n**数据范围**\n\n对于 $100\\%$ 的数据，$1 \\le T \\le 100$，$1 \\le n \\le 100$，$0 \\le k \\le 100$，$1 \\le d \\le 20$，$-100 \\le y_i \\le 100$，$-10^3 \\le b_i \\le 10^3$，$-10^3 \\le w_i \\le 10^3$。", "locale": "zh-CN"}}}
{"pid": "P7590", "type": "P", "difficulty": 4, "samples": [["1\n\n3\n1 2 3\n2 3 4", "Failed!"], ["1\n\n10\n1 2 3 4 5 6 7 8 9 10\n3 2 1 2 3 4 5 6 7 8", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["单调队列", "2021", "其它技巧"], "title": "回旋加速器（2021 CoE-II C）", "background": "", "description": "回旋加速器（$\\text{Cyclotron}$）是利用磁场和电场使带电粒子作回旋运动并经高频电场反复加速的装置，是高能物理中的重要仪器。\n\n我们来研究回旋加速器的一个简化模型。将回旋加速器视为一个环形的轨道，轨道上设置了 $n$ 个加速腔，依次编号为 $1$ 至 $n$。将一束质子从某个加速腔导入，在导入时，质子束的动能为零。第 $i$ 个加速腔能够为质子束提供 $e_i$ 的动能 ，质子束从第 $i$ 个加速腔运行到第 $i + 1$ 个加速腔会损失 $d_i$ 的动能（由于是环形轨道，编号为 $n$ 的加速腔后面是编号为 $1$ 的加速腔）。\n\n给定每个加速腔能够提供的动能值以及质子束在各个加速腔之间运行所损失的动能值，试确定质子束能否绕环形轨道运行一周。如果能够成功，应该选择从哪个加速腔导入质子束。质子束在两个加速腔之间运行时，动能不能为零，但质子束刚到达加速腔时，动能可以为零，因为可以立即获得加速腔所提供的动能。", "inputFormat": "**输入包含多组测试数据。**\n\n输入第一行包含一个整数 $T$，表示测试数据的组数。接着是一个空行。\n\n接下来是 $T$ 组数据，每组数据由三行构成。两组数据之间有一个空行。\n\n每组数据的第一行是一个整数 $n$，表示加速腔的个数。第二行一共 $n$ 个整数，依次表示编号为 $i$ 的加速腔能够提供的动能 $e_i$。第三行一共 $n$ 个整数，依次表示质子束从第 $i$ 个加速腔运行到第 $i + 1$ 个加速腔所损失的动能 $d_i$。由于是环形轨道，第三行的第 $n$ 个整数表示的是从第 $n$ 个加速腔运行到第 $1$ 个加速腔时损失的动能。", "outputFormat": "每组数据输出一行。如果质子束无法环绕加速器运行一周，输出 `Failed!`，否则输出导入质子束的加速腔编号，如果有多个加速腔可供选择，选择具有最小编号的加速腔。", "hint": "**样例说明**\n\n输入 #1\n\n该组输入共有 $3$ 个加速腔，依次能够提供的动能为 $1$、$2$、$3$。从第 $1$ 个加速腔运行到第 $2$ 个加速腔损失 $2$ 动能，从第 $2$ 个加速腔运行到第 $3$ 个加速腔损失 $3$ 动能，从第 $3$ 个加速腔运行到第 $1$ 个加速腔损失 $4$ 动能。不管从哪个加速腔导入质子束，都会使得质子束在两个加速腔运行过程中动能变为零，无法环绕轨道一周。\n\n输入 #2\n\n该组输入共有 $10$ 个加速腔，如果从第 $1$ 个加速腔导入质子束，将获得动能 $1$，但是在从第 $1$ 个加速腔运行到第 $2$ 个加速腔的过程中会损失 $3$ 动能，因此会使得质子束无法环绕轨道一周。而从第 $2$ 个到第 $10$ 个加速腔中的任意一个导入质子束，均能保证质子束在加速腔之间运行时动能不为零，因此都可作为导入质子束的加速腔，但编号为 $2$ 的加速腔具有最小的编号。需要注意，从第 $2$ 个加速腔导入质子束，当运行到第 $3$ 个加速腔时，动能恰为零，根据题意，这种情形是允许的。\n\n------------\n\n\n**数据范围**\n\n- Subtask $1$：$2 \\le n \\le 10$，$10$ 分。\n- Subtask $2$：$2 \\le n \\le 10^3$，$30$ 分。\n- Subtask $3$：$2 \\le n \\le 10^5$，$30$ 分。\n- Subtask $4$：$2 \\le n \\le 10^6$，$30$ 分。\n\n对于 $100\\%$ 的数据，$1 \\le T \\le 20$，$0 \\lt e_i \\le 100$，$0 \\lt d_i \\le 100$。\n\n\n\n------------\n\n**约定**\n\n质子束的运行方向规定为：从第 $1$ 个加速腔到第 $2$ 个加速腔，从第 $2$ 个加速腔到第 $3$ 个加速腔$\\cdots$从第 $n$ 个加速腔到第 $1$ 个加速腔。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "回旋加速器（2021 CoE-II C）", "background": "", "description": "回旋加速器（$\\text{Cyclotron}$）是利用磁场和电场使带电粒子作回旋运动并经高频电场反复加速的装置，是高能物理中的重要仪器。\n\n我们来研究回旋加速器的一个简化模型。将回旋加速器视为一个环形的轨道，轨道上设置了 $n$ 个加速腔，依次编号为 $1$ 至 $n$。将一束质子从某个加速腔导入，在导入时，质子束的动能为零。第 $i$ 个加速腔能够为质子束提供 $e_i$ 的动能 ，质子束从第 $i$ 个加速腔运行到第 $i + 1$ 个加速腔会损失 $d_i$ 的动能（由于是环形轨道，编号为 $n$ 的加速腔后面是编号为 $1$ 的加速腔）。\n\n给定每个加速腔能够提供的动能值以及质子束在各个加速腔之间运行所损失的动能值，试确定质子束能否绕环形轨道运行一周。如果能够成功，应该选择从哪个加速腔导入质子束。质子束在两个加速腔之间运行时，动能不能为零，但质子束刚到达加速腔时，动能可以为零，因为可以立即获得加速腔所提供的动能。", "inputFormat": "**输入包含多组测试数据。**\n\n输入第一行包含一个整数 $T$，表示测试数据的组数。接着是一个空行。\n\n接下来是 $T$ 组数据，每组数据由三行构成。两组数据之间有一个空行。\n\n每组数据的第一行是一个整数 $n$，表示加速腔的个数。第二行一共 $n$ 个整数，依次表示编号为 $i$ 的加速腔能够提供的动能 $e_i$。第三行一共 $n$ 个整数，依次表示质子束从第 $i$ 个加速腔运行到第 $i + 1$ 个加速腔所损失的动能 $d_i$。由于是环形轨道，第三行的第 $n$ 个整数表示的是从第 $n$ 个加速腔运行到第 $1$ 个加速腔时损失的动能。", "outputFormat": "每组数据输出一行。如果质子束无法环绕加速器运行一周，输出 `Failed!`，否则输出导入质子束的加速腔编号，如果有多个加速腔可供选择，选择具有最小编号的加速腔。", "hint": "**样例说明**\n\n输入 #1\n\n该组输入共有 $3$ 个加速腔，依次能够提供的动能为 $1$、$2$、$3$。从第 $1$ 个加速腔运行到第 $2$ 个加速腔损失 $2$ 动能，从第 $2$ 个加速腔运行到第 $3$ 个加速腔损失 $3$ 动能，从第 $3$ 个加速腔运行到第 $1$ 个加速腔损失 $4$ 动能。不管从哪个加速腔导入质子束，都会使得质子束在两个加速腔运行过程中动能变为零，无法环绕轨道一周。\n\n输入 #2\n\n该组输入共有 $10$ 个加速腔，如果从第 $1$ 个加速腔导入质子束，将获得动能 $1$，但是在从第 $1$ 个加速腔运行到第 $2$ 个加速腔的过程中会损失 $3$ 动能，因此会使得质子束无法环绕轨道一周。而从第 $2$ 个到第 $10$ 个加速腔中的任意一个导入质子束，均能保证质子束在加速腔之间运行时动能不为零，因此都可作为导入质子束的加速腔，但编号为 $2$ 的加速腔具有最小的编号。需要注意，从第 $2$ 个加速腔导入质子束，当运行到第 $3$ 个加速腔时，动能恰为零，根据题意，这种情形是允许的。\n\n------------\n\n\n**数据范围**\n\n- Subtask $1$：$2 \\le n \\le 10$，$10$ 分。\n- Subtask $2$：$2 \\le n \\le 10^3$，$30$ 分。\n- Subtask $3$：$2 \\le n \\le 10^5$，$30$ 分。\n- Subtask $4$：$2 \\le n \\le 10^6$，$30$ 分。\n\n对于 $100\\%$ 的数据，$1 \\le T \\le 20$，$0 \\lt e_i \\le 100$，$0 \\lt d_i \\le 100$。\n\n\n\n------------\n\n**约定**\n\n质子束的运行方向规定为：从第 $1$ 个加速腔到第 $2$ 个加速腔，从第 $2$ 个加速腔到第 $3$ 个加速腔$\\cdots$从第 $n$ 个加速腔到第 $1$ 个加速腔。", "locale": "zh-CN"}}}
{"pid": "P7591", "type": "P", "difficulty": 6, "samples": [["1\n1 2 1.00\n1\n0 1 2 3\n10 20", "5.0 8.0"], ["3\n1 2 1.00\n2 3 0.50\n3 4 0.70\n2\n0 1 2 3\n0 2 4 5\n10 20", "7.5 10.5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2021", "Special Judge", "O2优化", "期望"], "title": "狩猎（2021 CoE-II D）", "background": "", "description": "母狮 $\\text{Dina}$ 的领地里有固定的 $n$ 个狩猎点，第 $i$ 个狩猎点有 $p_i$ 的概率可以捕捉到猎物，$\\text{Dina}$ 的巢穴和 $n$ 个狩猎点相互之间存在若干条直接连接的双向道路。\n\n每天早晨，$\\text{Dina}$ 从她的巢穴出发，随机选择一个与巢穴相邻的狩猎点 $u$ 进行一次捕猎，如果她未捕捉到猎物，她会随机选择一个与当前狩猎点 $u$ 相邻的其他狩猎点 $v$ 继续进行一次捕猎，如果在狩猎点 $v$ 仍未捕捉到猎物，$\\text{Dina}$ 会按照前述过程继续捕猎。如果在某个狩猎点捕捉到了猎物，$\\text{Dina}$ 会立即返回巢穴，结束捕猎。若当前狩猎点 $u$ 与巢穴相邻，而与其他狩猎点不相邻，$\\text{Dina}$ 也会选择立即返回巢穴，然后从与巢穴相邻的狩猎点中，随机选择一个狩猎点继续上述捕猎过程。$\\text{Dina}$ 在每个狩猎点只进行一次捕猎，然后离开，但后续可能还会回到该狩猎点再次进行捕猎。在本题环境下，如果地点 $u$ 和地点 $v$ 之间有一条直接连接的双向道路，称地点 $u$ 和地点 $v$ **相邻**，否则称地点 $u$ 和地点 $v$ **不相邻**。\n\n令巢穴的编号为 $0$，$n$ 个狩猎点的编号从 $1$ 到 $n$，$\\text{Dina}$ 从编号为 $u$ 的地点到达另外一个编号为 $v$ 的地点需要消耗 $h_{u,v}$ 体力和 $t_{u,v}$ 时间。在第 $i$ 个狩猎点每进行一次捕猎，$\\text{Dina}$ 会消耗 $h_i$ 体力和 $t_i$ 时间。每当 $\\text{Dina}$ 到达某个狩猎点并进行一次捕猎后，她会评估自己的体力消耗和时间花费，如果体力消耗已经达到（或超过）限值 $H$，她就选择立即返回巢穴结束捕猎。如果时间花费已经达到（或超过）限值 $T$，她也会选择立即返回巢穴结束捕猎。$\\text{Dina}$ 只有在到达狩猎点并进行一次捕猎后才进行评估，在任何其他时刻均不会进行评估。如果当前位于巢穴，她会在到达巢穴时就进行评估，因为巢穴并无猎物可供捕捉。\n\n需要注意，$\\text{Dina}$ 在沿着两个地点间的双向道路移动的过程中并不会评估，因此可能会出现以下情形：到达某个狩猎点且尚未进行捕猎时，$\\text{Dina}$ 已消耗的体力或者已花费的时间已经超过限值。在这种情形下，$\\text{Dina}$ 仍然会进行一次捕猎，之后再进行评估。\n\n当 $\\text{Dina}$ 因为捕猎成功、体力消耗或时间花费达到（或超过）相应限值、当前狩猎点与其他狩猎点不相邻而返回巢穴时，她总会选择一条具有最少时间花费的路径。如果存在多条具有最少时间花费的路径返回巢穴，她会选择其中体力消耗最少的路径。$\\text{Dina}$ 在返回巢穴的过程中不会进行捕猎。\n\n将 $\\text{Dina}$ 从巢穴出发，因满足以下三个条件之一：\n\n- 捕猎成功\n- 体力消耗达到（或超过）限值 $H$\n- 时间花费达到（或超过）限值 $T$\n\n返回到达巢穴并结束捕猎的过程称为一次狩猎。给出巢穴和狩猎点之间的道路、每条道路所需要消耗的体力和花费的时间、每个狩猎点进行一次捕猎能够捕获猎物的概率以及所需消耗的体力、花费的时间，试确定 $\\text{Dina}$ 完成一次狩猎所消耗体力和花费时间的平均值。", "inputFormat": "输入的第一行包含一个整数 $n$，表示狩猎点的数量。\n\n接下来 $n$ 行，每行包含三个数值：整数 $h_i$，整数 $t_i$，实数 $p_i$，分别表示在第 $i$ 个狩猎点进行一次捕猎所消耗的体力、花费的时间、能够捕获猎物的概率。\n\n接下来是一个整数 $m$，表示连接各个地点的双向道路的数量。接着 $m$ 行，每行包含四个整数 $u$，$v$，$h_{u,v}$，$t_{u,v}$，表示从编号为 $u$（$0 \\le i \\le n$）的地点到另外一个编号为 $v$（$0 \\le i \\le n$，$u \\ne v$）的地点之间存在一条直接连通的道路，需要消耗 $h_{u,v}$ 体力和花费 $t_{u,v}$ 时间。由于是双向道路，从地点 $u$ 到达地点 $v$ 与从地点 $v$ 到达地点 $u$ 所消耗体力和花费时间相同。\n\n最后是两个整数 $H$ 和 $T$，表示体力和时间的限值。", "outputFormat": "输出一行，包含两个实数，精确到小数点后一位，分别表示 $\\text{Dina}$ 完成一次狩猎所消耗体力和花费时间的平均值。如果你的输出和参考输出绝对误差小于$10^{-1}$，均认为正确。", "hint": "**子任务测试采用捆绑方式计分。**\n\n**样例说明**\n\n输入 #1\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/62vbngdn.png)\n\n该输入只包含一个狩猎点，从巢穴到狩猎点 $1$ 之间的道路需要消耗 $2$ 体力和 $3$ 时间，体力的限值为 $10$，时间的限值为 $20$，在狩猎点 $1$ 进行一次捕猎需要消耗 $1$ 体力和 $2$ 时间，在狩猎点 $1$ 捕获猎物的概率为 $1.00$，即一定会捕捉到猎物。容易知道，进行一次狩猎所消耗的体力和花费时间的平均值分别为 $5.0=(2+1+2) \\times 100\\%$ 和 $8.0=(3+2+3) \\times 100\\%$。\n\n输入 #2\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/k4q1qkwr.png)\n\n相较于第一组输入，新增了两个狩猎点，但只有狩猎点 $1$ 和狩猎点 $2$ 与巢穴有直接道路相连。三个狩猎点之间无直接道路相连，但狩猎点 $1$ 可以间接通过巢穴与狩猎点 $2$ 连通。从巢穴到狩猎点 $2$ 的道路需要消耗 $4$ 体力和 $5$ 时间，在狩猎点 $2$ 进行一次捕猎需要消耗 $2$ 体力和 $3$ 时间。在狩猎点 $1$ 捕获猎物的概率为 $1.00$，即一定会捕捉到猎物，因此 $\\text{Dina}$ 会立即返回巢穴并结束狩猎。在狩猎点 $2$ 捕获猎物的概率为 $0.50$，即有 $50\\%$ 的概率会捕捉到猎物，但由于狩猎点 $2$ 没有其他狩猎点与之直接连通，因此不管在狩猎点 $2$ 是否捕获到猎物，$\\text{Dina}$ 都会选择立即返回巢穴，在返回巢穴时，已经消耗 $10$ 体力，根据题意，不管 $\\text{Dina}$ 是否已经捕捉到了猎物，她都会结束狩猎。由于是随机选择，故在巢穴时选择狩猎点 $1$ 和 $2$ 进行狩猎的概率均为 $50\\%$，根据计算可知，进行一次狩猎所消耗的体力和花费时间的平均值分别为 $7.5=(2+1+2) \\times 50\\%+(4+2+4) \\times 50\\%$ 和 $10.5=(3+2+3) \\times 50\\%+(5+3+5) \\times 50\\%$。\n\n------------\n\n**数据范围**\n\n- Subtask $1$：$n=1$，$10$ 分。\n- Subtask $2$：$1 \\le n \\le 20$，每个狩猎点和其他狩猎点均无直接道路相连，$20$ 分。\n- Subtask $3$：无特殊限制，$70$ 分。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 200$，$1 \\le h_i \\le 10$，$1 \\le t_i \\le 10$，$0 \\le p_i \\le 1$，$1 \\le m \\le \\text{min}(n (n+1) / 2$，$2000$)，$1 \\le h_{u,v} \\le 20$，$1 \\le t_{u,v} \\le 20$，$1 \\le H \\le 200$，$1 \\le T \\le 200$。\n\n------------\n\n**约定**\n\n- 地点 $u$ 和地点 $v$ 之间至多有一条直接连接的双向道路，两个地点之间的直连双向道路不会重复给出。\n- 忽略 $\\text{Dina}$ 进行评估所需要的时间。\n- 在输入中，表示概率 $p_i$ 的数值是一个具有两位小数的实数。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "狩猎（2021 CoE-II D）", "background": "", "description": "母狮 $\\text{Dina}$ 的领地里有固定的 $n$ 个狩猎点，第 $i$ 个狩猎点有 $p_i$ 的概率可以捕捉到猎物，$\\text{Dina}$ 的巢穴和 $n$ 个狩猎点相互之间存在若干条直接连接的双向道路。\n\n每天早晨，$\\text{Dina}$ 从她的巢穴出发，随机选择一个与巢穴相邻的狩猎点 $u$ 进行一次捕猎，如果她未捕捉到猎物，她会随机选择一个与当前狩猎点 $u$ 相邻的其他狩猎点 $v$ 继续进行一次捕猎，如果在狩猎点 $v$ 仍未捕捉到猎物，$\\text{Dina}$ 会按照前述过程继续捕猎。如果在某个狩猎点捕捉到了猎物，$\\text{Dina}$ 会立即返回巢穴，结束捕猎。若当前狩猎点 $u$ 与巢穴相邻，而与其他狩猎点不相邻，$\\text{Dina}$ 也会选择立即返回巢穴，然后从与巢穴相邻的狩猎点中，随机选择一个狩猎点继续上述捕猎过程。$\\text{Dina}$ 在每个狩猎点只进行一次捕猎，然后离开，但后续可能还会回到该狩猎点再次进行捕猎。在本题环境下，如果地点 $u$ 和地点 $v$ 之间有一条直接连接的双向道路，称地点 $u$ 和地点 $v$ **相邻**，否则称地点 $u$ 和地点 $v$ **不相邻**。\n\n令巢穴的编号为 $0$，$n$ 个狩猎点的编号从 $1$ 到 $n$，$\\text{Dina}$ 从编号为 $u$ 的地点到达另外一个编号为 $v$ 的地点需要消耗 $h_{u,v}$ 体力和 $t_{u,v}$ 时间。在第 $i$ 个狩猎点每进行一次捕猎，$\\text{Dina}$ 会消耗 $h_i$ 体力和 $t_i$ 时间。每当 $\\text{Dina}$ 到达某个狩猎点并进行一次捕猎后，她会评估自己的体力消耗和时间花费，如果体力消耗已经达到（或超过）限值 $H$，她就选择立即返回巢穴结束捕猎。如果时间花费已经达到（或超过）限值 $T$，她也会选择立即返回巢穴结束捕猎。$\\text{Dina}$ 只有在到达狩猎点并进行一次捕猎后才进行评估，在任何其他时刻均不会进行评估。如果当前位于巢穴，她会在到达巢穴时就进行评估，因为巢穴并无猎物可供捕捉。\n\n需要注意，$\\text{Dina}$ 在沿着两个地点间的双向道路移动的过程中并不会评估，因此可能会出现以下情形：到达某个狩猎点且尚未进行捕猎时，$\\text{Dina}$ 已消耗的体力或者已花费的时间已经超过限值。在这种情形下，$\\text{Dina}$ 仍然会进行一次捕猎，之后再进行评估。\n\n当 $\\text{Dina}$ 因为捕猎成功、体力消耗或时间花费达到（或超过）相应限值、当前狩猎点与其他狩猎点不相邻而返回巢穴时，她总会选择一条具有最少时间花费的路径。如果存在多条具有最少时间花费的路径返回巢穴，她会选择其中体力消耗最少的路径。$\\text{Dina}$ 在返回巢穴的过程中不会进行捕猎。\n\n将 $\\text{Dina}$ 从巢穴出发，因满足以下三个条件之一：\n\n- 捕猎成功\n- 体力消耗达到（或超过）限值 $H$\n- 时间花费达到（或超过）限值 $T$\n\n返回到达巢穴并结束捕猎的过程称为一次狩猎。给出巢穴和狩猎点之间的道路、每条道路所需要消耗的体力和花费的时间、每个狩猎点进行一次捕猎能够捕获猎物的概率以及所需消耗的体力、花费的时间，试确定 $\\text{Dina}$ 完成一次狩猎所消耗体力和花费时间的平均值。", "inputFormat": "输入的第一行包含一个整数 $n$，表示狩猎点的数量。\n\n接下来 $n$ 行，每行包含三个数值：整数 $h_i$，整数 $t_i$，实数 $p_i$，分别表示在第 $i$ 个狩猎点进行一次捕猎所消耗的体力、花费的时间、能够捕获猎物的概率。\n\n接下来是一个整数 $m$，表示连接各个地点的双向道路的数量。接着 $m$ 行，每行包含四个整数 $u$，$v$，$h_{u,v}$，$t_{u,v}$，表示从编号为 $u$（$0 \\le i \\le n$）的地点到另外一个编号为 $v$（$0 \\le i \\le n$，$u \\ne v$）的地点之间存在一条直接连通的道路，需要消耗 $h_{u,v}$ 体力和花费 $t_{u,v}$ 时间。由于是双向道路，从地点 $u$ 到达地点 $v$ 与从地点 $v$ 到达地点 $u$ 所消耗体力和花费时间相同。\n\n最后是两个整数 $H$ 和 $T$，表示体力和时间的限值。", "outputFormat": "输出一行，包含两个实数，精确到小数点后一位，分别表示 $\\text{Dina}$ 完成一次狩猎所消耗体力和花费时间的平均值。如果你的输出和参考输出绝对误差小于$10^{-1}$，均认为正确。", "hint": "**子任务测试采用捆绑方式计分。**\n\n**样例说明**\n\n输入 #1\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/62vbngdn.png)\n\n该输入只包含一个狩猎点，从巢穴到狩猎点 $1$ 之间的道路需要消耗 $2$ 体力和 $3$ 时间，体力的限值为 $10$，时间的限值为 $20$，在狩猎点 $1$ 进行一次捕猎需要消耗 $1$ 体力和 $2$ 时间，在狩猎点 $1$ 捕获猎物的概率为 $1.00$，即一定会捕捉到猎物。容易知道，进行一次狩猎所消耗的体力和花费时间的平均值分别为 $5.0=(2+1+2) \\times 100\\%$ 和 $8.0=(3+2+3) \\times 100\\%$。\n\n输入 #2\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/k4q1qkwr.png)\n\n相较于第一组输入，新增了两个狩猎点，但只有狩猎点 $1$ 和狩猎点 $2$ 与巢穴有直接道路相连。三个狩猎点之间无直接道路相连，但狩猎点 $1$ 可以间接通过巢穴与狩猎点 $2$ 连通。从巢穴到狩猎点 $2$ 的道路需要消耗 $4$ 体力和 $5$ 时间，在狩猎点 $2$ 进行一次捕猎需要消耗 $2$ 体力和 $3$ 时间。在狩猎点 $1$ 捕获猎物的概率为 $1.00$，即一定会捕捉到猎物，因此 $\\text{Dina}$ 会立即返回巢穴并结束狩猎。在狩猎点 $2$ 捕获猎物的概率为 $0.50$，即有 $50\\%$ 的概率会捕捉到猎物，但由于狩猎点 $2$ 没有其他狩猎点与之直接连通，因此不管在狩猎点 $2$ 是否捕获到猎物，$\\text{Dina}$ 都会选择立即返回巢穴，在返回巢穴时，已经消耗 $10$ 体力，根据题意，不管 $\\text{Dina}$ 是否已经捕捉到了猎物，她都会结束狩猎。由于是随机选择，故在巢穴时选择狩猎点 $1$ 和 $2$ 进行狩猎的概率均为 $50\\%$，根据计算可知，进行一次狩猎所消耗的体力和花费时间的平均值分别为 $7.5=(2+1+2) \\times 50\\%+(4+2+4) \\times 50\\%$ 和 $10.5=(3+2+3) \\times 50\\%+(5+3+5) \\times 50\\%$。\n\n------------\n\n**数据范围**\n\n- Subtask $1$：$n=1$，$10$ 分。\n- Subtask $2$：$1 \\le n \\le 20$，每个狩猎点和其他狩猎点均无直接道路相连，$20$ 分。\n- Subtask $3$：无特殊限制，$70$ 分。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 200$，$1 \\le h_i \\le 10$，$1 \\le t_i \\le 10$，$0 \\le p_i \\le 1$，$1 \\le m \\le \\text{min}(n (n+1) / 2$，$2000$)，$1 \\le h_{u,v} \\le 20$，$1 \\le t_{u,v} \\le 20$，$1 \\le H \\le 200$，$1 \\le T \\le 200$。\n\n------------\n\n**约定**\n\n- 地点 $u$ 和地点 $v$ 之间至多有一条直接连接的双向道路，两个地点之间的直连双向道路不会重复给出。\n- 忽略 $\\text{Dina}$ 进行评估所需要的时间。\n- 在输入中，表示概率 $p_i$ 的数值是一个具有两位小数的实数。", "locale": "zh-CN"}}}
{"pid": "P7592", "type": "P", "difficulty": 7, "samples": [["2 3 6 1 2", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "2021", "O2优化", "生成函数"], "title": "数树（2021 CoE-II E）", "background": "", "description": "定义一棵树 $\\mathcal T$ 为 $k_1-k_2$ 叉树，当且仅当每个节点 $p\\in \\mathcal T$ 有儿子，要么有 $k_1$ 个儿子，要么有 $k_2$ 个儿子，$k_1 \\ne k_2$。我们定义两棵 $k_1-k_2$ 树同构，当且仅当以下伪代码返回的字符串相同：\n$$\n\\begin{array}{ll}\n1 &  \\textbf{Input. } \\text{The edges of the tree } \\mathcal T  \\\\\n2 &  \\textbf{Output. } \\text{The eigenvalue of tree } \\mathcal T.\\\\\n3 &  \\textbf{Algorithm. }  \\text{dfs}(u)\\\\\n4 &  \\qquad result \\gets \\texttt{'('} \\\\\n5 &  \\qquad \\textbf{for} \\text{ each } (u, v) \\text{ in the  } \\mathcal T \\\\\n6 &  \\qquad \\qquad \\textbf{if }  v \\text{ is not the father of  } u \\\\\n7 &  \\qquad \\qquad\\qquad  result \\gets result\\  +\\ \\mathrm{dfs}(v) \\\\\n8 &  \\qquad result\\gets result\\ +\\ \\texttt{')'} \\\\\n9 & \\qquad \\textbf{return }  result \\\\\n10 & \\textbf{Method. } \\text{check}(\\mathcal T) \\\\\n11 & \\qquad \\textbf{return } \\text{dfs(the root of the tree } \\mathcal T\\text{)}\n\\end{array}\n$$\n\n形式化地，$k_1-k_2$ 叉树有**确定的根节点**，每个节点的若干儿子之间**有顺序**，但是节点**没有标号**。\n\n若 $k_1-k_2$ 叉树 $\\mathcal T$ 有一个 $k_1$ 叉节点，则得分 $a$，若有一个 $k_2$ 叉节点，则得分 $b$，叶节点无得分。定义一棵树的得分为其所有节点的得分之和，记为 $v(\\mathcal T)$。\n\n现在我们在所有互不同构的 $n$ 个节点的 $k_1-k_2$ 叉树中等概率随机生成一棵 $\\mathcal T$，记 $v(\\mathcal T)$ 的期望值为 $\\mathbb{E}(v(\\mathcal T))$。\n\n可以证明 $\\mathbb{E}(v(\\mathcal T))$ 为有理数。当 $\\mathbb{E}(v(\\mathcal T))$ 不为零时，令答案 $\\mathbb{E}(v(\\mathcal T)) = p/q$，其中 $p$ 与 $q$ 互质。你需要输出最小的自然数 $x$ 使得 $p\\equiv qx\\pmod P$，其中 $P=998244353$，可以证明这样的自然数 $x$ 必定存在。", "inputFormat": "输入包含五个整数 $k_1,\\ k_2,\\ n,\\ a,\\ b$，其含义如题目描述所示。", "outputFormat": "输出一个整数 $x$，表示方程 $p\\equiv qx\\pmod P$ 的最小自然数解，其中 $P=998244353$。", "hint": "**样例说明**\n\n具有 $6$ 个结点的不同构 $2-3$ 叉树共有 $5$ 棵，每棵得分均为 $3$ 分，则 $\\mathbb{E}(v(\\mathcal T))=15/5=3$，故 $p=3$ 且 $q=1$，则 $x=3$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nqywy0df.png)\n\n------------\n\n**数据范围**\n\n共 $10$ 个测试点。\n\n对于测试点 $1$，满足 $1 \\le k_1,\\ k_2<n\\leq 10$。\n\n对于测试点 $2$，满足 $1 \\le k_1,\\ k_2<n\\leq 15$。\n\n对于测试点 $3\\sim 4$，满足 $1 \\le k_1,\\ k_2<n\\leq 5 \\times 10^3$。\n\n对于测试点 $5\\sim 6$，满足 $a=b=1,\\ 1 \\le k_1,\\ k_2<n\\leq 10^5$。\n\n对于 $100\\%$ 的数据，满足 $1 \\le k_1,\\ k_2<n\\leq 10^7,\\ k_1 \\ne k_2, \\ k_1+k_2 \\le n, \\  \\ 1 \\le \\ a,\\ b\\leq 10^7$。\n\n\n------------\n\n**约定**\n\n- 测试数据保证 $\\mathbb{E}(v(\\mathcal T))$ 不为零。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "数树（2021 CoE-II E）", "background": "", "description": "定义一棵树 $\\mathcal T$ 为 $k_1-k_2$ 叉树，当且仅当每个节点 $p\\in \\mathcal T$ 有儿子，要么有 $k_1$ 个儿子，要么有 $k_2$ 个儿子，$k_1 \\ne k_2$。我们定义两棵 $k_1-k_2$ 树同构，当且仅当以下伪代码返回的字符串相同：\n$$\n\\begin{array}{ll}\n1 &  \\textbf{Input. } \\text{The edges of the tree } \\mathcal T  \\\\\n2 &  \\textbf{Output. } \\text{The eigenvalue of tree } \\mathcal T.\\\\\n3 &  \\textbf{Algorithm. }  \\text{dfs}(u)\\\\\n4 &  \\qquad result \\gets \\texttt{'('} \\\\\n5 &  \\qquad \\textbf{for} \\text{ each } (u, v) \\text{ in the  } \\mathcal T \\\\\n6 &  \\qquad \\qquad \\textbf{if }  v \\text{ is not the father of  } u \\\\\n7 &  \\qquad \\qquad\\qquad  result \\gets result\\  +\\ \\mathrm{dfs}(v) \\\\\n8 &  \\qquad result\\gets result\\ +\\ \\texttt{')'} \\\\\n9 & \\qquad \\textbf{return }  result \\\\\n10 & \\textbf{Method. } \\text{check}(\\mathcal T) \\\\\n11 & \\qquad \\textbf{return } \\text{dfs(the root of the tree } \\mathcal T\\text{)}\n\\end{array}\n$$\n\n形式化地，$k_1-k_2$ 叉树有**确定的根节点**，每个节点的若干儿子之间**有顺序**，但是节点**没有标号**。\n\n若 $k_1-k_2$ 叉树 $\\mathcal T$ 有一个 $k_1$ 叉节点，则得分 $a$，若有一个 $k_2$ 叉节点，则得分 $b$，叶节点无得分。定义一棵树的得分为其所有节点的得分之和，记为 $v(\\mathcal T)$。\n\n现在我们在所有互不同构的 $n$ 个节点的 $k_1-k_2$ 叉树中等概率随机生成一棵 $\\mathcal T$，记 $v(\\mathcal T)$ 的期望值为 $\\mathbb{E}(v(\\mathcal T))$。\n\n可以证明 $\\mathbb{E}(v(\\mathcal T))$ 为有理数。当 $\\mathbb{E}(v(\\mathcal T))$ 不为零时，令答案 $\\mathbb{E}(v(\\mathcal T)) = p/q$，其中 $p$ 与 $q$ 互质。你需要输出最小的自然数 $x$ 使得 $p\\equiv qx\\pmod P$，其中 $P=998244353$，可以证明这样的自然数 $x$ 必定存在。", "inputFormat": "输入包含五个整数 $k_1,\\ k_2,\\ n,\\ a,\\ b$，其含义如题目描述所示。", "outputFormat": "输出一个整数 $x$，表示方程 $p\\equiv qx\\pmod P$ 的最小自然数解，其中 $P=998244353$。", "hint": "**样例说明**\n\n具有 $6$ 个结点的不同构 $2-3$ 叉树共有 $5$ 棵，每棵得分均为 $3$ 分，则 $\\mathbb{E}(v(\\mathcal T))=15/5=3$，故 $p=3$ 且 $q=1$，则 $x=3$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nqywy0df.png)\n\n------------\n\n**数据范围**\n\n共 $10$ 个测试点。\n\n对于测试点 $1$，满足 $1 \\le k_1,\\ k_2<n\\leq 10$。\n\n对于测试点 $2$，满足 $1 \\le k_1,\\ k_2<n\\leq 15$。\n\n对于测试点 $3\\sim 4$，满足 $1 \\le k_1,\\ k_2<n\\leq 5 \\times 10^3$。\n\n对于测试点 $5\\sim 6$，满足 $a=b=1,\\ 1 \\le k_1,\\ k_2<n\\leq 10^5$。\n\n对于 $100\\%$ 的数据，满足 $1 \\le k_1,\\ k_2<n\\leq 10^7,\\ k_1 \\ne k_2, \\ k_1+k_2 \\le n, \\  \\ 1 \\le \\ a,\\ b\\leq 10^7$。\n\n\n------------\n\n**约定**\n\n- 测试数据保证 $\\mathbb{E}(v(\\mathcal T))$ 不为零。\n", "locale": "zh-CN"}}}
{"pid": "P7593", "type": "P", "difficulty": 1, "samples": [["3\n5 2 10\n5 2 5\n5 2 2", "No\nYes\nNo"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["O2优化"], "title": "「EZEC-8」凑数", "background": "", "description": "给定 $1$ 到 $n$ 这 $n$ 个正整数，请问能否恰好选择 $k$ 个数，使选中的数之和为 $s$（每个数只能用 $1$ 次）。", "inputFormat": "**本题有多组数据**。\n\n第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据，一行 $3$ 个正整数 $n,k,s$。", "outputFormat": "对于每组数据：\n\n输出一行，一个字符串，`Yes` 或 `No`，表示是否可以恰好选择 $k$ 个数，使选中的数之和为 $s$。", "hint": "**本题采用捆绑测试。**\n\n-  Subtask 1（15 points）：$n\\le5$。\n-  Subtask 2（15 points）：$n\\le15$。\n-  Subtask 3（20 points）：$n\\le100$。\n-  Subtask 4（15 points）：$k=1$。\n-  Subtask 5（15 points）：$s\\le15$。\n-  Subtask 6（20 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1\\le T\\le10^3$，$1\\le k\\le n\\le10^9$，$1\\le s\\le10^{18}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「EZEC-8」凑数", "background": "", "description": "给定 $1$ 到 $n$ 这 $n$ 个正整数，请问能否恰好选择 $k$ 个数，使选中的数之和为 $s$（每个数只能用 $1$ 次）。", "inputFormat": "**本题有多组数据**。\n\n第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据，一行 $3$ 个正整数 $n,k,s$。", "outputFormat": "对于每组数据：\n\n输出一行，一个字符串，`Yes` 或 `No`，表示是否可以恰好选择 $k$ 个数，使选中的数之和为 $s$。", "hint": "**本题采用捆绑测试。**\n\n-  Subtask 1（15 points）：$n\\le5$。\n-  Subtask 2（15 points）：$n\\le15$。\n-  Subtask 3（20 points）：$n\\le100$。\n-  Subtask 4（15 points）：$k=1$。\n-  Subtask 5（15 points）：$s\\le15$。\n-  Subtask 6（20 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1\\le T\\le10^3$，$1\\le k\\le n\\le10^9$，$1\\le s\\le10^{18}$。", "locale": "zh-CN"}}}
{"pid": "P7594", "type": "P", "difficulty": 5, "samples": [["5\n1 4 3 4 1\n", "5\n"], ["8\n1 2 1 0 0 1 2 1\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": [], "title": "「EZEC-8」Clean Up", "background": "", "description": "有一个宽度为 $n$ 的区间，第 $i$ 个位置上如俄罗斯方块一样堆着 $a_i$ 个方块。\n\n你可以选择任何一个位置，花费 $k$ 点能量清除这个位置上的至多 $k$ 个方块，同时在与选定位置相距为 $d$ 的位置清除至多 $\\max(k-d,0)$ 个方块，相邻两个位置的距离为 $1$。请注意，**$k$ 必须是正整数。**\n\n请问最少要多少能量才能清空整个区间的所有方块。", "inputFormat": "输入共两行。\n\n第一行，输入一个整数 $n$。\n\n第二行，输入 $n$ 个整数，第 $i$ 个数为 $a_i$。", "outputFormat": "输出一行，一个数，表示所需的能量最小值。", "hint": "**样例解释**\n\n对于第一组样例，一种最佳方案是选择位置 $3$ 花费 $5$ 点能量。\n\n对于第二组样例，一种最佳方案是选择位置 $2$ 花费 $2$ 点能量，再选择位置 $7$ 花费 $2$ 点能量。\n\n-------\n\n**本题采用捆绑测试。**\n\n- Subtask 1（5 points）：$n \\leq 2$。\n- Subtask 2（20 points）：$n \\leq 10^3$，$a_i \\neq 0$。\n- Subtask 3（20 points）：$a_i \\neq 0$。\n- Subtask 4（20 points）：$n \\leq 10^3$。\n- Subtask 5（35 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1\\le n \\leq 10^6$，$0 \\leq a_i \\leq 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「EZEC-8」Clean Up", "background": "", "description": "有一个宽度为 $n$ 的区间，第 $i$ 个位置上如俄罗斯方块一样堆着 $a_i$ 个方块。\n\n你可以选择任何一个位置，花费 $k$ 点能量清除这个位置上的至多 $k$ 个方块，同时在与选定位置相距为 $d$ 的位置清除至多 $\\max(k-d,0)$ 个方块，相邻两个位置的距离为 $1$。请注意，**$k$ 必须是正整数。**\n\n请问最少要多少能量才能清空整个区间的所有方块。", "inputFormat": "输入共两行。\n\n第一行，输入一个整数 $n$。\n\n第二行，输入 $n$ 个整数，第 $i$ 个数为 $a_i$。", "outputFormat": "输出一行，一个数，表示所需的能量最小值。", "hint": "**样例解释**\n\n对于第一组样例，一种最佳方案是选择位置 $3$ 花费 $5$ 点能量。\n\n对于第二组样例，一种最佳方案是选择位置 $2$ 花费 $2$ 点能量，再选择位置 $7$ 花费 $2$ 点能量。\n\n-------\n\n**本题采用捆绑测试。**\n\n- Subtask 1（5 points）：$n \\leq 2$。\n- Subtask 2（20 points）：$n \\leq 10^3$，$a_i \\neq 0$。\n- Subtask 3（20 points）：$a_i \\neq 0$。\n- Subtask 4（20 points）：$n \\leq 10^3$。\n- Subtask 5（35 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1\\le n \\leq 10^6$，$0 \\leq a_i \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P7595", "type": "P", "difficulty": 5, "samples": [["5\n\n1\n\n5 1 5 2 4 3\n\n3 4 2 5\n\n1 3", "\n? 1 1 2\n\n? 2 1\n\n? 2 2\n\n? 2 3\n\n! 1 1 2 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["交互题", "Special Judge", "O2优化"], "title": "「EZEC-8」猜树", "background": "这是一道交互题。", "description": "有一棵以 $1$ 为根的 $n$ 个点的有根树，您需要通过若干次询问得到这棵树的结构。\n\n您可以使用两种询问：\n\n1. `? 1 u v` 通过这种询问，您可以获得 $u$ 和 $v$ 之间的距离。\n2. `? 2 u` 通过这种询问，您可以获得 $u$ 子树的大小和 $u$ 子树中的所有节点。\n\n请通过使交互库输出不超过 $10^5$ 个数，得到这棵树的结构。\n\n### 交互方式\n\n输入树的大小 $n$ 以开始交互。\n\n交互过程中，您可以进行题目描述中的两种询问。\n\n对于第一种询问，交互库将会返回一个非负整数，表示 $u$ 节点和 $v$ 节点间的距离。\n\n对于第二种询问，交互库将会先返回一个正整数 $num$，表示 $u$ 子树的大小。接下来会在同一行中返回 $num$ 个正整数，表示 $u$ 子树中的所有节点（节点顺序会被打乱）。\n\n在您确定答案后，请以 `! fa[2] fa[3] ... fa[n]` 的形式输出一行，停止交互。其中 $fa[i]$ 表示这棵树中 $i$ 号节点的父节点。\n\n在您输出一行后，请清空缓冲区：\n\n- 在 C++ 中，使用 `fflush(stdout)` 或 `cout.flush()`。\n- 在 Pascal 中，使用 `flush(output)`。\n- 在 Python 中，使用 `stdout.flush()`。\n- 其它语言请自行查阅文档。", "inputFormat": "见「交互方式」。", "outputFormat": "见「交互方式」。", "hint": "**本题采用捆绑测试。**\n\n-  Subtask 1（5 points）：$n \\leq 5$。\n-  Subtask 2（15 points）：$n \\leq 100$。\n-  Subtask 3（20 points）：$n \\leq 500$。\n-  Subtask 4（15 points）：树是一条链。\n-  Subtask 5（15 points）：树是一棵完全二叉树。\n-  Subtask 6（30 points）：无特殊限制。\n\n对于 $100\\%$ 的数据：$2 \\leq n \\leq 2000$，$1\\le u,v \\le n$。\n\n**注意：询问不合法或交互库输出数超过 $10^5$ 后继续询问可能导致 TLE。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「EZEC-8」猜树", "background": "这是一道交互题。", "description": "有一棵以 $1$ 为根的 $n$ 个点的有根树，您需要通过若干次询问得到这棵树的结构。\n\n您可以使用两种询问：\n\n1. `? 1 u v` 通过这种询问，您可以获得 $u$ 和 $v$ 之间的距离。\n2. `? 2 u` 通过这种询问，您可以获得 $u$ 子树的大小和 $u$ 子树中的所有节点。\n\n请通过使交互库输出不超过 $10^5$ 个数，得到这棵树的结构。\n\n### 交互方式\n\n输入树的大小 $n$ 以开始交互。\n\n交互过程中，您可以进行题目描述中的两种询问。\n\n对于第一种询问，交互库将会返回一个非负整数，表示 $u$ 节点和 $v$ 节点间的距离。\n\n对于第二种询问，交互库将会先返回一个正整数 $num$，表示 $u$ 子树的大小。接下来会在同一行中返回 $num$ 个正整数，表示 $u$ 子树中的所有节点（节点顺序会被打乱）。\n\n在您确定答案后，请以 `! fa[2] fa[3] ... fa[n]` 的形式输出一行，停止交互。其中 $fa[i]$ 表示这棵树中 $i$ 号节点的父节点。\n\n在您输出一行后，请清空缓冲区：\n\n- 在 C++ 中，使用 `fflush(stdout)` 或 `cout.flush()`。\n- 在 Pascal 中，使用 `flush(output)`。\n- 在 Python 中，使用 `stdout.flush()`。\n- 其它语言请自行查阅文档。", "inputFormat": "见「交互方式」。", "outputFormat": "见「交互方式」。", "hint": "**本题采用捆绑测试。**\n\n-  Subtask 1（5 points）：$n \\leq 5$。\n-  Subtask 2（15 points）：$n \\leq 100$。\n-  Subtask 3（20 points）：$n \\leq 500$。\n-  Subtask 4（15 points）：树是一条链。\n-  Subtask 5（15 points）：树是一棵完全二叉树。\n-  Subtask 6（30 points）：无特殊限制。\n\n对于 $100\\%$ 的数据：$2 \\leq n \\leq 2000$，$1\\le u,v \\le n$。\n\n**注意：询问不合法或交互库输出数超过 $10^5$ 后继续询问可能导致 TLE。**", "locale": "zh-CN"}}}
{"pid": "P7596", "type": "P", "difficulty": 6, "samples": [["10 10\n1 10 6 2 2 5 10 8 9 5\n1 3 5 7\n2 3 5 6\n3 6 9 10\n1 4 5 10\n1 2 4 7\n1 2 4 9\n3 5 7 8\n4 7 8 9\n2 3 4 8\n1 5 6 7", "A\nA\nA\nB\nA\nA\nB\nA\nA\nB"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["O2优化"], "title": "「EZEC-8」游戏蛇", "background": "", "description": "小 A 和小 B 是两条蛇，他们正在一棵特殊的树上做游戏。\n\n这棵树的结构如下：首先有一条长度为 $n$ 的链，称为“主链”。主链由 $1$ 至 $n$ 这 $n$ 个节点构成。在主链上，编号相邻的点有边相连，否则则没有。\n\n主链上的每一个点都挂着一条链，称为“副链”。主链上的第 $i$ 个点挂的副链长度（链上的点数）为 $x_i$。\n\n小 A 和小 B 初始时都在主链上，具体而言，小 A 的**蛇尾**在点 $a$，**蛇头**在点 $b$，小 B 的**蛇头**在点 $c$，**蛇尾**在点 $d$。满足 $1\\le a<b<c<d\\le n$。\n\n他们的游戏规则如下：\n- 小 A 和小 B 轮流移动，小 A 先手。\n- 每条蛇移动时，他会尝试整体向某一方向移动一个节点，**但不能向原来蛇尾方向移动，也就是蛇不能倒退**。需满足移动后蛇头不得与另外一条蛇的任意部分重合。\n- 当一条蛇无法移动时，游戏结束，对手获胜。\n\n现在有 $q$ 次询问，每次询问给定 $a,b,c,d$，请求出当两条蛇都采取最优策略时，哪一条蛇会获胜。", "inputFormat": "第一行两个正整数 $n,q$。\n\n第二行 $n$ 个正整数，表示 $x_i$。\n\n接下来 $q$ 行，每行四个正整数表示此次询问的 $a,b,c,d$。", "outputFormat": "输出共 $q$ 行。\n\n对于每组询问，输出 `A` 或 `B`，表示最终能获胜的蛇。", "hint": "**本题采用捆绑测试。**\n\n-  Subtask 1（10 points）：$n,q \\le500$。\n-  Subtask 2（10 points）：$n\\le10^5$，$q\\le500$。\n-  Subtask 3（5 points）：所有 $x_i$ 都相等。\n-  Subtask 4（10 points）：所有询问中小 A 和小 B 的长度总和不超过 $5\\times10^7$。\n-  Subtask 5（15 points）：$x_i$ 在 $[1,10^9]$ 内随机生成。\n-  Subtask 6（20 points）：$n\\le5\\times10^3$。\n-  Subtask 7（30 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1\\le n,q\\le5\\times10^5$，$1\\le x_i\\le10^9$，$1\\le a<b<c<d\\le n$。\n\n小 A 的长度定义为 $b-a+1$，小 B 的长度定义为 $d-c+1$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「EZEC-8」游戏蛇", "background": "", "description": "小 A 和小 B 是两条蛇，他们正在一棵特殊的树上做游戏。\n\n这棵树的结构如下：首先有一条长度为 $n$ 的链，称为“主链”。主链由 $1$ 至 $n$ 这 $n$ 个节点构成。在主链上，编号相邻的点有边相连，否则则没有。\n\n主链上的每一个点都挂着一条链，称为“副链”。主链上的第 $i$ 个点挂的副链长度（链上的点数）为 $x_i$。\n\n小 A 和小 B 初始时都在主链上，具体而言，小 A 的**蛇尾**在点 $a$，**蛇头**在点 $b$，小 B 的**蛇头**在点 $c$，**蛇尾**在点 $d$。满足 $1\\le a<b<c<d\\le n$。\n\n他们的游戏规则如下：\n- 小 A 和小 B 轮流移动，小 A 先手。\n- 每条蛇移动时，他会尝试整体向某一方向移动一个节点，**但不能向原来蛇尾方向移动，也就是蛇不能倒退**。需满足移动后蛇头不得与另外一条蛇的任意部分重合。\n- 当一条蛇无法移动时，游戏结束，对手获胜。\n\n现在有 $q$ 次询问，每次询问给定 $a,b,c,d$，请求出当两条蛇都采取最优策略时，哪一条蛇会获胜。", "inputFormat": "第一行两个正整数 $n,q$。\n\n第二行 $n$ 个正整数，表示 $x_i$。\n\n接下来 $q$ 行，每行四个正整数表示此次询问的 $a,b,c,d$。", "outputFormat": "输出共 $q$ 行。\n\n对于每组询问，输出 `A` 或 `B`，表示最终能获胜的蛇。", "hint": "**本题采用捆绑测试。**\n\n-  Subtask 1（10 points）：$n,q \\le500$。\n-  Subtask 2（10 points）：$n\\le10^5$，$q\\le500$。\n-  Subtask 3（5 points）：所有 $x_i$ 都相等。\n-  Subtask 4（10 points）：所有询问中小 A 和小 B 的长度总和不超过 $5\\times10^7$。\n-  Subtask 5（15 points）：$x_i$ 在 $[1,10^9]$ 内随机生成。\n-  Subtask 6（20 points）：$n\\le5\\times10^3$。\n-  Subtask 7（30 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1\\le n,q\\le5\\times10^5$，$1\\le x_i\\le10^9$，$1\\le a<b<c<d\\le n$。\n\n小 A 的长度定义为 $b-a+1$，小 B 的长度定义为 $d-c+1$。", "locale": "zh-CN"}}}
{"pid": "P7597", "type": "P", "difficulty": 6, "samples": [["5\n\n1\n\n5 1 5 2 4 3\n\n3 4 2 5\n\n1 3", "\n? 1 1 2\n\n? 2 1\n\n? 2 2\n\n? 2 3\n\n! 1 1 2 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["交互题", "Special Judge", "O2优化"], "title": "「EZEC-8」猜树 加强版", "background": "这是一道交互题。", "description": "有一棵以 $1$ 为根的 $n$ 个点的有根树，您需要通过若干次询问得到这棵树的结构。\n\n您可以使用两种询问：\n\n1. `? 1 u v` 通过这种询问，您可以获得 $u$ 和 $v$ 之间的距离。\n2. `? 2 u` 通过这种询问，您可以获得 $u$ 子树的大小和 $u$ 子树中的所有节点。\n\n请通过使交互库输出不超过 $40000$ 个数，得到这棵树的结构。\n\n### 交互方式\n\n输入树的大小 $n$ 以开始交互。\n\n交互过程中，您可以进行题目描述中的两种询问。\n\n对于第一种询问，交互库将会返回一个非负整数，表示 $u$ 节点和 $v$ 节点间的距离。\n\n对于第二种询问，交互库将会先返回一个正整数 $num$，表示 $u$ 子树的大小。接下来会在同一行中返回 $num$ 个正整数，表示 $u$ 子树中的所有节点（节点顺序会被打乱）。\n\n在您确定答案后，请以 `! fa[2] fa[3] ... fa[n]` 的形式输出一行，停止交互。其中 $fa[i]$ 表示这棵树中 $i$ 号节点的父节点。\n\n在您输出一行后，请清空缓冲区：\n\n- 在 C++ 中，使用 `fflush(stdout)` 或 `cout.flush()`。\n- 在 Pascal 中，使用 `flush(output)`。\n- 在 Python 中，使用 `stdout.flush()`。\n- 其它语言请自行查阅文档。", "inputFormat": "见「交互方式」。", "outputFormat": "见「交互方式」。", "hint": "对于 $100\\%$ 的数据：$2 \\leq n \\leq 5000$，$1\\le u,v\\le n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「EZEC-8」猜树 加强版", "background": "这是一道交互题。", "description": "有一棵以 $1$ 为根的 $n$ 个点的有根树，您需要通过若干次询问得到这棵树的结构。\n\n您可以使用两种询问：\n\n1. `? 1 u v` 通过这种询问，您可以获得 $u$ 和 $v$ 之间的距离。\n2. `? 2 u` 通过这种询问，您可以获得 $u$ 子树的大小和 $u$ 子树中的所有节点。\n\n请通过使交互库输出不超过 $40000$ 个数，得到这棵树的结构。\n\n### 交互方式\n\n输入树的大小 $n$ 以开始交互。\n\n交互过程中，您可以进行题目描述中的两种询问。\n\n对于第一种询问，交互库将会返回一个非负整数，表示 $u$ 节点和 $v$ 节点间的距离。\n\n对于第二种询问，交互库将会先返回一个正整数 $num$，表示 $u$ 子树的大小。接下来会在同一行中返回 $num$ 个正整数，表示 $u$ 子树中的所有节点（节点顺序会被打乱）。\n\n在您确定答案后，请以 `! fa[2] fa[3] ... fa[n]` 的形式输出一行，停止交互。其中 $fa[i]$ 表示这棵树中 $i$ 号节点的父节点。\n\n在您输出一行后，请清空缓冲区：\n\n- 在 C++ 中，使用 `fflush(stdout)` 或 `cout.flush()`。\n- 在 Pascal 中，使用 `flush(output)`。\n- 在 Python 中，使用 `stdout.flush()`。\n- 其它语言请自行查阅文档。", "inputFormat": "见「交互方式」。", "outputFormat": "见「交互方式」。", "hint": "对于 $100\\%$ 的数据：$2 \\leq n \\leq 5000$，$1\\le u,v\\le n$。", "locale": "zh-CN"}}}
{"pid": "P7598", "type": "P", "difficulty": 7, "samples": [["17 2 3\n1 1\n2 2\n3 2\n4 1\n5 1\n4 1\n3 1\n2 2\n1 3\n6 2\n2 3\n3 1\n4 6\n5 3\n6 3\n6 2\n1 1", "1003"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2021", "APIO", "交互题", "Special Judge", "O2优化"], "title": "[APIO2021] 六边形领域", "background": "本题只支持 C++ 提交，提交时不需要包含 `hexagon.h` 头文件，只需要将附件中的 `hexagon.h` 中的内容粘贴到代码的开头即可。", "description": "对于一个用六边形无限平铺的平面，Pak Dengklek 站在其中一个格子上，并称该格子为初始格子。如果六边形平铺中的两个格子有公共边，则称它们是相邻的格子。对于一步移动，Pak Dengklek 可以从一个格子向六个可能的方向（从 $1$ 到 $6$ 编号，如下图所示）移动到与其相邻的格子上。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cojdvvvr.png)\n\n对于某个由 $N$ 次行动构成的行动序列，Pak Dengklek 可以用其产生的路径（对应一个按序访问的格子序\n列）构造一个领域。其中第 $i$ 次行动由移动方向 $D[i]$ 和在该方向上的移动步数 $L[i]$ 组成，并且该路径应有如下性质：\n\n- 路径是 _封闭_ 的，这意味着在格子序列中，起点格子与终点格子（即初始格子）相同。\n- 路径是 _简单_ 的，这意味着在格子序列中，除了初始格子访问过恰好两次（起点和终点分别访问一\n次），其他格子只能被访问至多一次。\n- 路径是 _暴露_ 的，这意味着在格子序列中，每个格子与至少一个不在序列中出现过的非 _内部格子_ 相邻。\n    - 如果一个格子不在格子序列中出现过，并且从它出发，在不经过格子序列中任何格子的情况下，（通过若干步移动） 只能访问到有限个格子，我们就称该格子是 _内部格子_ 。\n\n下图是一个符合上述条件的路径例子。其中：\n\n- $1$ 号格子（粉色）是初始格子。\n- 被编号的格子（淡蓝色）组成格子序列，编号代表它被访问的顺序。\n- 被标上叉号的格子（深蓝色）是 _内部格子_。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/znccjlim.png)\n\n构造出的领域只包含所有路径上的格子和内部格子。领域中格子 $c$ 的距离定义为：在只经过领域中包含格子的情况下，从初始格子出发到达 $c$ 所需要的最少移动步数。领域中一个格子的分数定义为 $A+d \\times B$，其中 $A$ 和 $B$ 是 Pak Dengklek 给定的常数，$d$ 是该格子在领域中的距离。下图给出了用上示路径构成的领域中每个格子的距离。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/u9gjh0n6.png)\n\n请帮助 Pak Dengklek 计算，用给出的行动序列构成的领域中，所有格子的分数之和。由于总分数值可能很大，最终结果对 ${10}^9+7$ 取模。\n\n你需要实现下列函数：\n\n`int draw_territory(int N, int A, int B, int[] D, int[] L)`\n\n- $N$：行动序列中行动的次数。\n- $A,B$：分数计算中的常数。\n- $D$：大小为 $N$ 的数组，其中 $D[i]$ 表示第 $i$ 次行动的方向。\n- $L$：大小为 $N$ 的数组，其中 $L[i]$ 表示第 $i$ 次行动的移动步数。\n- 函数应该返回用给出的行动序列所构成的领域中，所有格子的分数总和对 ${10}^9+7$ 取模后的值。\n- 该函数将被调用恰好一次。", "inputFormat": "示例测试程序按如下格式读取输入数据：\n\n- 第 $1$ 行：$N$ $A$ $B$\n- 第 $2+i$（$0 \\le i \\le N-1$）行：$D[i]$ $L[i]$", "outputFormat": "示例测试程序按如下格式输出你的答案：\n\n- 第 $1$ 行：`draw_territory` 的返回值。", "hint": "**【样例解释】**\n\n考虑下列调用：\n\n```plain\ndraw_territory(17, 2, 3,\n\t\t\t   [1, 2, 3, 4, 5, 4, 3, 2, 1, 6, 2, 3, 4, 5, 6, 6, 1],\n\t\t\t   [1, 2, 2, 1, 1, 1, 1, 2, 3, 2, 3, 1, 6, 3, 3, 2, 1])\n```\n\n该行动序列和上述题面中给出的例子相同。下表列出了该领域中所有可能的距离值所对应的分数。\n\n| 距离值 | 格子数 | 每个格子分数 | 总分数 |\n|:-:|:-:|:-:|:-:|\n|$0$|$1$|$2+0 \\times 3=2$|$1 \\times 2=2$|\n|$1$|$4$|$2+1 \\times 3=5$|$4 \\times 5=20$|\n|$2$|$5$|$2+2 \\times 3=8$|$5 \\times 8=40$|\n|$3$|$6$|$2+3 \\times 3=11$|$6 \\times 11=66$|\n|$4$|$4$|$2+4 \\times 3=14$|$4 \\times 14=56$|\n|$5$|$3$|$2+5 \\times 3=17$|$3 \\times 17=51$|\n|$6$|$4$|$2+6 \\times 3=20$|$4 \\times 20=80$|\n|$7$|$4$|$2+7 \\times 3=23$|$4 \\times 23=92$|\n|$8$|$5$|$2+8 \\times 3=26$|$5 \\times 26=130$|\n|$9$|$3$|$2+9 \\times 3=29$|$3 \\times 29=87$|\n|$10$|$4$|$2+10 \\times 3=32$|$4 \\times 32=128$|\n|$11$|$5$|$2+11 \\times 3=35$|$5 \\times 35=175$|\n|$12$|$2$|$2+12 \\times 3=38$|$2 \\times 38=76$|\n\n总分数值为 $2+20+40+66+56+51+80+92+130+87+128+175+76=1003$。\n\n因此，`draw_territory` 应该返回 $1003$。\n\n**【数据范围】**\n\n- $3 \\le N \\le 2\\times {10}^5$。\n- $0 \\le A,B \\le {10}^9$。\n- $1 \\le D[i] \\le 6$（$0 \\le i \\le N-1$）。\n- $1 \\le L[i]$（$0 \\le i \\le N-1$）。\n- $L$ 中的元素之和不超过 ${10}^9$。\n- 给出的行动序列所对应的路径一定是 _封闭_、_简单_ 和 _暴露_ 的。\n\n**【子任务】**\n\n1. （3 分）：$N=3$，$B=0$。\n2. （6 分）：$N=3$。\n3. （11 分）：$L$ 中的元素之和不超过 $2000$。\n4. （12 分）：$B=0$，$L$ 中的元素之和不超过 $2\\times {10}^5$。\n5. （15 分）：$B=0$。\n6. （19 分）：$L$ 中的元素之和不超过 $2\\times {10}^5$。\n7. （18 分）：$L[i]=L[i+1]$（$0 \\le i \\le N-2$）。\n8. （16 分）：无附加限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[APIO2021] 六边形领域", "background": "本题只支持 C++ 提交，提交时不需要包含 `hexagon.h` 头文件，只需要将附件中的 `hexagon.h` 中的内容粘贴到代码的开头即可。", "description": "对于一个用六边形无限平铺的平面，Pak Dengklek 站在其中一个格子上，并称该格子为初始格子。如果六边形平铺中的两个格子有公共边，则称它们是相邻的格子。对于一步移动，Pak Dengklek 可以从一个格子向六个可能的方向（从 $1$ 到 $6$ 编号，如下图所示）移动到与其相邻的格子上。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cojdvvvr.png)\n\n对于某个由 $N$ 次行动构成的行动序列，Pak Dengklek 可以用其产生的路径（对应一个按序访问的格子序\n列）构造一个领域。其中第 $i$ 次行动由移动方向 $D[i]$ 和在该方向上的移动步数 $L[i]$ 组成，并且该路径应有如下性质：\n\n- 路径是 _封闭_ 的，这意味着在格子序列中，起点格子与终点格子（即初始格子）相同。\n- 路径是 _简单_ 的，这意味着在格子序列中，除了初始格子访问过恰好两次（起点和终点分别访问一\n次），其他格子只能被访问至多一次。\n- 路径是 _暴露_ 的，这意味着在格子序列中，每个格子与至少一个不在序列中出现过的非 _内部格子_ 相邻。\n    - 如果一个格子不在格子序列中出现过，并且从它出发，在不经过格子序列中任何格子的情况下，（通过若干步移动） 只能访问到有限个格子，我们就称该格子是 _内部格子_ 。\n\n下图是一个符合上述条件的路径例子。其中：\n\n- $1$ 号格子（粉色）是初始格子。\n- 被编号的格子（淡蓝色）组成格子序列，编号代表它被访问的顺序。\n- 被标上叉号的格子（深蓝色）是 _内部格子_。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/znccjlim.png)\n\n构造出的领域只包含所有路径上的格子和内部格子。领域中格子 $c$ 的距离定义为：在只经过领域中包含格子的情况下，从初始格子出发到达 $c$ 所需要的最少移动步数。领域中一个格子的分数定义为 $A+d \\times B$，其中 $A$ 和 $B$ 是 Pak Dengklek 给定的常数，$d$ 是该格子在领域中的距离。下图给出了用上示路径构成的领域中每个格子的距离。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/u9gjh0n6.png)\n\n请帮助 Pak Dengklek 计算，用给出的行动序列构成的领域中，所有格子的分数之和。由于总分数值可能很大，最终结果对 ${10}^9+7$ 取模。\n\n你需要实现下列函数：\n\n`int draw_territory(int N, int A, int B, int[] D, int[] L)`\n\n- $N$：行动序列中行动的次数。\n- $A,B$：分数计算中的常数。\n- $D$：大小为 $N$ 的数组，其中 $D[i]$ 表示第 $i$ 次行动的方向。\n- $L$：大小为 $N$ 的数组，其中 $L[i]$ 表示第 $i$ 次行动的移动步数。\n- 函数应该返回用给出的行动序列所构成的领域中，所有格子的分数总和对 ${10}^9+7$ 取模后的值。\n- 该函数将被调用恰好一次。", "inputFormat": "示例测试程序按如下格式读取输入数据：\n\n- 第 $1$ 行：$N$ $A$ $B$\n- 第 $2+i$（$0 \\le i \\le N-1$）行：$D[i]$ $L[i]$", "outputFormat": "示例测试程序按如下格式输出你的答案：\n\n- 第 $1$ 行：`draw_territory` 的返回值。", "hint": "**【样例解释】**\n\n考虑下列调用：\n\n```plain\ndraw_territory(17, 2, 3,\n\t\t\t   [1, 2, 3, 4, 5, 4, 3, 2, 1, 6, 2, 3, 4, 5, 6, 6, 1],\n\t\t\t   [1, 2, 2, 1, 1, 1, 1, 2, 3, 2, 3, 1, 6, 3, 3, 2, 1])\n```\n\n该行动序列和上述题面中给出的例子相同。下表列出了该领域中所有可能的距离值所对应的分数。\n\n| 距离值 | 格子数 | 每个格子分数 | 总分数 |\n|:-:|:-:|:-:|:-:|\n|$0$|$1$|$2+0 \\times 3=2$|$1 \\times 2=2$|\n|$1$|$4$|$2+1 \\times 3=5$|$4 \\times 5=20$|\n|$2$|$5$|$2+2 \\times 3=8$|$5 \\times 8=40$|\n|$3$|$6$|$2+3 \\times 3=11$|$6 \\times 11=66$|\n|$4$|$4$|$2+4 \\times 3=14$|$4 \\times 14=56$|\n|$5$|$3$|$2+5 \\times 3=17$|$3 \\times 17=51$|\n|$6$|$4$|$2+6 \\times 3=20$|$4 \\times 20=80$|\n|$7$|$4$|$2+7 \\times 3=23$|$4 \\times 23=92$|\n|$8$|$5$|$2+8 \\times 3=26$|$5 \\times 26=130$|\n|$9$|$3$|$2+9 \\times 3=29$|$3 \\times 29=87$|\n|$10$|$4$|$2+10 \\times 3=32$|$4 \\times 32=128$|\n|$11$|$5$|$2+11 \\times 3=35$|$5 \\times 35=175$|\n|$12$|$2$|$2+12 \\times 3=38$|$2 \\times 38=76$|\n\n总分数值为 $2+20+40+66+56+51+80+92+130+87+128+175+76=1003$。\n\n因此，`draw_territory` 应该返回 $1003$。\n\n**【数据范围】**\n\n- $3 \\le N \\le 2\\times {10}^5$。\n- $0 \\le A,B \\le {10}^9$。\n- $1 \\le D[i] \\le 6$（$0 \\le i \\le N-1$）。\n- $1 \\le L[i]$（$0 \\le i \\le N-1$）。\n- $L$ 中的元素之和不超过 ${10}^9$。\n- 给出的行动序列所对应的路径一定是 _封闭_、_简单_ 和 _暴露_ 的。\n\n**【子任务】**\n\n1. （3 分）：$N=3$，$B=0$。\n2. （6 分）：$N=3$。\n3. （11 分）：$L$ 中的元素之和不超过 $2000$。\n4. （12 分）：$B=0$，$L$ 中的元素之和不超过 $2\\times {10}^5$。\n5. （15 分）：$B=0$。\n6. （19 分）：$L$ 中的元素之和不超过 $2\\times {10}^5$。\n7. （18 分）：$L[i]=L[i+1]$（$0 \\le i \\le N-2$）。\n8. （16 分）：无附加限制。", "locale": "zh-CN"}}}
{"pid": "P7599", "type": "P", "difficulty": 6, "samples": [["7 3\n3 2 1 6 4 5 7\n4 4 6 6\n1 3 5 6\n0 1 2 2\n", "2\n1\n-1\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2021", "APIO", "交互题", "Special Judge", "O2优化"], "title": "[APIO2021] 雨林跳跃", "background": "本题只支持 C++ 提交，不支持 C++14 (GCC 9)，提交时不需要包含 jumps.h 头文件，只需要将附件中的 jumps.h 中的内容粘贴到代码的开头即可。", "description": "在苏门答腊岛的热带雨林中，有 $N$ 棵树排成一排，从左到右依次用 $0$ 到 $N-1$ 进行编号，其中 $i$ 号树的高度为 $H[i]$，且所有树的高度**互不相同**。\n\nPak Dengklek 正在训练一只猩猩，让她能够从一棵树上跳到另一棵树上。对于一次跳跃，猩猩可以从一棵树，向左或向右跳到比当前这棵树高的第一棵树上。形式化地，如果猩猩当前在 $x$ 号树，那么当且仅当满足下列条件之一时，她能够跳到 $y$ 号树上：\n\n- $y$ 是满足 $H[z]>H[x]$ 的所有 $z$ 中比 $x$ 小的最大非负整数；或者：\n- $y$ 是满足 $H[z]>H[x]$ 的所有 $z$ 中比 $x$ 大的最小非负整数。\n\nPak Dengklek 有 $Q$ 个跳跃计划，每个计划用四个整数 $A$，$B$，$C$ 和 $D$（$A \\le B<C \\le D$）来描述。对于每个计划，Pak Dengklek 想知道猩猩是否能够从某棵树 $s$（$A \\le s \\le B$）出发，经过若干次跳跃，到达某棵树 $e$（$C \\le e \\le D$）。若该计划可行，Pak Dengklek 还想知道可行方案中猩猩需要的最少跳跃次数。\n\n你需要实现下列函数：\n\n`void init(int N, int[] H)`\n\n- $N$：树的数量。\n- $H$：大小为 $N$ 的数组，$H[i]$ 表示 $i$ 号树的高度。\n- 该函数在第一次 `minimum_jumps` 的调用前，将会被调用恰好一次。\n\n`int minimum_jumps(int A, int B, int C, int D)`\n\n- $A,B$：可以用作起点的树的编号范围。\n- $C,D$：可以用作终点的树的编号范围。\n- 该函数需要返回可行方案中猩猩需要的最少跳跃次数，或者返回 $-1$ 表示该计划不可行。\n- 该函数将被调用恰好 $Q$ 次。", "inputFormat": "示例测试程序按如下格式读取输入数据：\n\n- 第 $1$ 行：$N$ $Q$\n- 第 $2$ 行：$H[0]$ $H[1]$ $\\cdots$ $H[N-1]$\n- 第 $3+i$（$0 \\le i \\le Q-1$）行：$A$ $B$ $C$ $D$，表示第 $i$ 次 `minimum_jumps` 调用的参数。", "outputFormat": "示例测试程序按如下格式输出你的答案：\n\n- 第 $1+i$（$0 \\le i \\le Q-1$）行：第 $i$ 次 `minimum_jumps` 调用的返回值。", "hint": "**【样例解释】**\n\n考虑如下调用： \n\n`init(7, [3, 2, 1, 6, 4, 5, 7])`\n\n在初始化完成后，考虑如下调用：\n\n`minimum_jumps(4, 4, 6, 6)`\n\n该计划意味着猩猩必须从 $4$ 号树（高度为 $4$）出发，并到达 $6$ 号树（高度为 $7$）。\n\n一种跳跃次数最少的可行方案为：先跳到 $3$ 号树（高度为 $6$），再跳到 $6$ 号树。\n\n另一种方案为：先跳到 $5$ 号树（高度为 $5$），再跳到 $6$ 号树。\n\n因此，`minimum_jumps` 应该返回 $2$。\n\n考虑另一个调用：\n\n`minimum_jumps(1, 3, 5, 6)`\n\n该计划意味着猩猩必须从 $1$ 号树（高度为 $2$），$2$ 号树（高度为 $1$），或 $3$ 号树（高度为 $6$）之一出发，并最终到达 $5$ 号树（高度为 $5$）或者 $6$ 号树（高度为 $7$）。\n\n唯一一种跳跃次数最少的可行方案为：从 $3$ 号树出发，直接跳到 $6$ 号树。\n\n因此，`minimum_jumps` 应该返回 $1$。\n\n考虑另一个调用：\n\n`minimum jumps(0, 1, 2, 2)`\n\n该计划意味着猩猩必须从 $0$ 号树（高度为 $3$）或者 $1$ 号树（高度为 $2$）出发，并最终到达 $2$ 号树（高度为 $1$）。\n\n由于 $2$ 号树是高度最低的树，所以无法从其他树上跳到 $2$ 号树。\n\n因此，`minimum_jumps` 应该返回 $-1$。\n\n**【数据范围】**\n\n- $2 \\le N \\le 2 \\times {10}^5$。\n- $1 \\le Q \\le {10}^5$。\n- $1 \\le H[i] \\le N$（$0 \\le i \\le N - 1$）。\n- $H[i]\\ne H[j]$（$0 \\le i<j \\le N - 1$）。\n- $0 \\le A \\le B<C \\le D \\le N - 1$。\n\n**【子任务】**\n\n1. （4 分）：$H[i]=i+1$（$0 \\le i \\le N-1$）。\n2. （8 分）：$N,Q \\le 200$。\n3. （13 分）：$N,Q \\le 2000$。\n4. （12 分）：$Q \\le 5$。\n5. （23 分）：$A=B$，$C=D$。\n6. （21 分）：$C=D$。\n7. （19 分）：无附加限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[APIO2021] 雨林跳跃", "background": "本题只支持 C++ 提交，不支持 C++14 (GCC 9)，提交时不需要包含 jumps.h 头文件，只需要将附件中的 jumps.h 中的内容粘贴到代码的开头即可。", "description": "在苏门答腊岛的热带雨林中，有 $N$ 棵树排成一排，从左到右依次用 $0$ 到 $N-1$ 进行编号，其中 $i$ 号树的高度为 $H[i]$，且所有树的高度**互不相同**。\n\nPak Dengklek 正在训练一只猩猩，让她能够从一棵树上跳到另一棵树上。对于一次跳跃，猩猩可以从一棵树，向左或向右跳到比当前这棵树高的第一棵树上。形式化地，如果猩猩当前在 $x$ 号树，那么当且仅当满足下列条件之一时，她能够跳到 $y$ 号树上：\n\n- $y$ 是满足 $H[z]>H[x]$ 的所有 $z$ 中比 $x$ 小的最大非负整数；或者：\n- $y$ 是满足 $H[z]>H[x]$ 的所有 $z$ 中比 $x$ 大的最小非负整数。\n\nPak Dengklek 有 $Q$ 个跳跃计划，每个计划用四个整数 $A$，$B$，$C$ 和 $D$（$A \\le B<C \\le D$）来描述。对于每个计划，Pak Dengklek 想知道猩猩是否能够从某棵树 $s$（$A \\le s \\le B$）出发，经过若干次跳跃，到达某棵树 $e$（$C \\le e \\le D$）。若该计划可行，Pak Dengklek 还想知道可行方案中猩猩需要的最少跳跃次数。\n\n你需要实现下列函数：\n\n`void init(int N, int[] H)`\n\n- $N$：树的数量。\n- $H$：大小为 $N$ 的数组，$H[i]$ 表示 $i$ 号树的高度。\n- 该函数在第一次 `minimum_jumps` 的调用前，将会被调用恰好一次。\n\n`int minimum_jumps(int A, int B, int C, int D)`\n\n- $A,B$：可以用作起点的树的编号范围。\n- $C,D$：可以用作终点的树的编号范围。\n- 该函数需要返回可行方案中猩猩需要的最少跳跃次数，或者返回 $-1$ 表示该计划不可行。\n- 该函数将被调用恰好 $Q$ 次。", "inputFormat": "示例测试程序按如下格式读取输入数据：\n\n- 第 $1$ 行：$N$ $Q$\n- 第 $2$ 行：$H[0]$ $H[1]$ $\\cdots$ $H[N-1]$\n- 第 $3+i$（$0 \\le i \\le Q-1$）行：$A$ $B$ $C$ $D$，表示第 $i$ 次 `minimum_jumps` 调用的参数。", "outputFormat": "示例测试程序按如下格式输出你的答案：\n\n- 第 $1+i$（$0 \\le i \\le Q-1$）行：第 $i$ 次 `minimum_jumps` 调用的返回值。", "hint": "**【样例解释】**\n\n考虑如下调用： \n\n`init(7, [3, 2, 1, 6, 4, 5, 7])`\n\n在初始化完成后，考虑如下调用：\n\n`minimum_jumps(4, 4, 6, 6)`\n\n该计划意味着猩猩必须从 $4$ 号树（高度为 $4$）出发，并到达 $6$ 号树（高度为 $7$）。\n\n一种跳跃次数最少的可行方案为：先跳到 $3$ 号树（高度为 $6$），再跳到 $6$ 号树。\n\n另一种方案为：先跳到 $5$ 号树（高度为 $5$），再跳到 $6$ 号树。\n\n因此，`minimum_jumps` 应该返回 $2$。\n\n考虑另一个调用：\n\n`minimum_jumps(1, 3, 5, 6)`\n\n该计划意味着猩猩必须从 $1$ 号树（高度为 $2$），$2$ 号树（高度为 $1$），或 $3$ 号树（高度为 $6$）之一出发，并最终到达 $5$ 号树（高度为 $5$）或者 $6$ 号树（高度为 $7$）。\n\n唯一一种跳跃次数最少的可行方案为：从 $3$ 号树出发，直接跳到 $6$ 号树。\n\n因此，`minimum_jumps` 应该返回 $1$。\n\n考虑另一个调用：\n\n`minimum jumps(0, 1, 2, 2)`\n\n该计划意味着猩猩必须从 $0$ 号树（高度为 $3$）或者 $1$ 号树（高度为 $2$）出发，并最终到达 $2$ 号树（高度为 $1$）。\n\n由于 $2$ 号树是高度最低的树，所以无法从其他树上跳到 $2$ 号树。\n\n因此，`minimum_jumps` 应该返回 $-1$。\n\n**【数据范围】**\n\n- $2 \\le N \\le 2 \\times {10}^5$。\n- $1 \\le Q \\le {10}^5$。\n- $1 \\le H[i] \\le N$（$0 \\le i \\le N - 1$）。\n- $H[i]\\ne H[j]$（$0 \\le i<j \\le N - 1$）。\n- $0 \\le A \\le B<C \\le D \\le N - 1$。\n\n**【子任务】**\n\n1. （4 分）：$H[i]=i+1$（$0 \\le i \\le N-1$）。\n2. （8 分）：$N,Q \\le 200$。\n3. （13 分）：$N,Q \\le 2000$。\n4. （12 分）：$Q \\le 5$。\n5. （23 分）：$A=B$，$C=D$。\n6. （21 分）：$C=D$。\n7. （19 分）：无附加限制。", "locale": "zh-CN"}}}
{"pid": "P7600", "type": "P", "difficulty": 6, "samples": [["5\n0 1 1\n0 2 4\n0 3 3\n2 4 2\n", "10 5 1 0 0\n"], ["4\n0 1 5\n2 0 10\n0 3 5\n", "20 10 5 0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2021", "APIO", "交互题", "Special Judge", "O2优化"], "title": "[APIO2021] 封闭道路", "background": "本题只支持 C++ 提交，提交时不需要包含 `roads.h` 头文件，只需要将附件中的 `roads.h` 中的内容粘贴到代码的开头即可。\n\n", "description": "在泗水市，有 $N$ 个路口（编号从 $0$ 到 $N-1$）。这些路口由 $N-1$ 条双向道路连接（编号从 $0$ 到 $N-2$），因此通过这些道路，任意一对路口之间都有一条唯一的路径。$i$ 号道路（$0 \\le i \\le N-2$）连接着 $U[i]$ 号和 $V[i]$ 号路口。\n\n为了提高环保意识，泗水市长 Pak Dengklek 计划举办无车日。为了鼓励该活动，Pak Dengklek 将组织封路。Pak Dengklek 将首先选择一个非负整数 $k$，然后封闭一些道路，以使每个路口只能直接连接至多 $k$ 条未封闭的道路。封闭 $i$ 号道路的成本为 $W[i]$。\n\n请你帮助 Pak Dengklek 对每个可能的非负整数 $k$（$0 \\le k \\le N-1$）计算封闭道路的最低总成本。\n\n你需要实现下列函数：\n\n`int64[] minimum_closure_costs(int N, int[] U, int[] V, int[] W)`\n\n- $N$：泗水市的路口数量。\n\n- $U$ 和 $V$：大小为 $N-1$ 的数组，其中 $U[i]$ 号路口和 $V[i]$ 路口通过 $i$ 号道路直接连接。\n\n- $W$：大小为 $N-1$ 的数组，其中封闭 $i$ 号道路的成本为 $W[i]$。\n\n- 该函数需要返回一个大小为 $N$ 的数组。对每个 $k$（$0 \\le k \\le N-1$），$k$ 号元素是使得每个路口与至多 $k$ 条未封闭道路直接连接的最低总成本。\n\n该函数将被调用恰好一次。", "inputFormat": "示例测试程序按如下格式读取输入数据:\n\n- 第 $1$ 行：$N$\n- 第 $2+i$（$0 \\le i \\le N-2$）行：$U[i]$ $V[i]$ $W[i]$\n", "outputFormat": "示例测试程序输出仅一行，包含一个数组，表示 `minimum_closure_costs` 的返回值。", "hint": "## 例子\n\n### 例子 $1$\n\n考虑如下调用:\n\n`minimum_closure_costs(5, [0, 0, 0, 2], [1, 2, 3, 4], [1, 4, 3, 2])`\n\n这个例子中共有 $5$ 个路口和 $4$ 条道路，分别连接着路口 $(0,1),(0,2),(0,3)$ 和 $(2,4)$，封闭它们的成本依次为 $1,4,3$ 和 $2$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/k3z9vmxl.png)\n\n为了得到最低的总成本：\n\n- 如果 Pak_Dengklek 选择 $k=0$，那么所有道路都需要封闭，总成本为 $1+4+3+2=10$；\n- 如果 Pak_Dengklek 选择 $k=1$，那么需要封闭 $0$ 号道路和 $1$ 号道路，总成本为 $1+4=5$；\n- 如果 Pak_Dengklek 选择 $k=2$，那么需要封闭 $0$ 号道路，总成本为 $1$；\n- 如果 Pak_Dengklek 选择 $k=3$ 或 $k=4$，那么没有道路需要封闭。\n\n因此，`minimum_closure_costs` 应该返回数组 $[10,5,1,0,0]$。\n\n### 例子 $2$\n\n考虑如下调用：\n\n`minimum_closure_costs(4, [0, 2, 0], [1, 0, 3], [5, 10, 5])\n`\n\n这个例子中共有 $4$ 个路口和 $3$ 条道路，分别连接着路口 $(0,1),(2,0)$ 和 $(0,3)$，封闭它们的成本依次为 $5,10$ 和 $5$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9fdtl4aj.png)\n\n为了得到最低的总成本:\n\n- 如果 PakDengklek 选择 $k=0$，那么所有道路都需要封闭，总成本为 $5+10+5=20$；\n- 如果 PakDengklek 选择 $k=1$，那么需要封闭 $0$ 号道路和 $2$ 号道路，总成本为 $5+5=10$；\n- 如果 PakDengklek 选择 $k=2$，那么需要封闭 $0$ 号道路或 $2$ 号道路，总成本为 $5$；\n- 如果 PakDengklek 选择 $k=3$，那么没有道路需要封闭。\n\n因此，minimum_closure_costs 应该返回数组 $[20,10,5,0]$。\n\n## 约束\n\n- $2 \\le N \\le 10^5$\n- $0 \\le U[i],V[i] \\le N-1$ $(0 \\le i \\le N-2)$\n- 任意一对路口可以通过道路互相到达。\n- $1 \\le W[i] \\le 10^9$ $(0 \\le i \\le N-2)$。\n\n## 子任务\n1. (5 分) $U[i]=0$ $(0 \\le i \\le N-2)$\n2. (7 分) $U[i]=i$，$V[i]=i+1$ $(0 \\le i \\le N-2)$\n3. (14 分) $N \\le 200$\n4. (10 分) $N \\le 2000$\n5. (17 分) $W[i]=1$ $(0 \\le i \\le N-2)$\n6. (25 分) $W[i] \\le 10$ $(0 \\le i \\le N-2)$\n7. (22 分) 无附加限制", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[APIO2021] 封闭道路", "background": "本题只支持 C++ 提交，提交时不需要包含 `roads.h` 头文件，只需要将附件中的 `roads.h` 中的内容粘贴到代码的开头即可。\n\n", "description": "在泗水市，有 $N$ 个路口（编号从 $0$ 到 $N-1$）。这些路口由 $N-1$ 条双向道路连接（编号从 $0$ 到 $N-2$），因此通过这些道路，任意一对路口之间都有一条唯一的路径。$i$ 号道路（$0 \\le i \\le N-2$）连接着 $U[i]$ 号和 $V[i]$ 号路口。\n\n为了提高环保意识，泗水市长 Pak Dengklek 计划举办无车日。为了鼓励该活动，Pak Dengklek 将组织封路。Pak Dengklek 将首先选择一个非负整数 $k$，然后封闭一些道路，以使每个路口只能直接连接至多 $k$ 条未封闭的道路。封闭 $i$ 号道路的成本为 $W[i]$。\n\n请你帮助 Pak Dengklek 对每个可能的非负整数 $k$（$0 \\le k \\le N-1$）计算封闭道路的最低总成本。\n\n你需要实现下列函数：\n\n`int64[] minimum_closure_costs(int N, int[] U, int[] V, int[] W)`\n\n- $N$：泗水市的路口数量。\n\n- $U$ 和 $V$：大小为 $N-1$ 的数组，其中 $U[i]$ 号路口和 $V[i]$ 路口通过 $i$ 号道路直接连接。\n\n- $W$：大小为 $N-1$ 的数组，其中封闭 $i$ 号道路的成本为 $W[i]$。\n\n- 该函数需要返回一个大小为 $N$ 的数组。对每个 $k$（$0 \\le k \\le N-1$），$k$ 号元素是使得每个路口与至多 $k$ 条未封闭道路直接连接的最低总成本。\n\n该函数将被调用恰好一次。", "inputFormat": "示例测试程序按如下格式读取输入数据:\n\n- 第 $1$ 行：$N$\n- 第 $2+i$（$0 \\le i \\le N-2$）行：$U[i]$ $V[i]$ $W[i]$\n", "outputFormat": "示例测试程序输出仅一行，包含一个数组，表示 `minimum_closure_costs` 的返回值。", "hint": "## 例子\n\n### 例子 $1$\n\n考虑如下调用:\n\n`minimum_closure_costs(5, [0, 0, 0, 2], [1, 2, 3, 4], [1, 4, 3, 2])`\n\n这个例子中共有 $5$ 个路口和 $4$ 条道路，分别连接着路口 $(0,1),(0,2),(0,3)$ 和 $(2,4)$，封闭它们的成本依次为 $1,4,3$ 和 $2$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/k3z9vmxl.png)\n\n为了得到最低的总成本：\n\n- 如果 Pak_Dengklek 选择 $k=0$，那么所有道路都需要封闭，总成本为 $1+4+3+2=10$；\n- 如果 Pak_Dengklek 选择 $k=1$，那么需要封闭 $0$ 号道路和 $1$ 号道路，总成本为 $1+4=5$；\n- 如果 Pak_Dengklek 选择 $k=2$，那么需要封闭 $0$ 号道路，总成本为 $1$；\n- 如果 Pak_Dengklek 选择 $k=3$ 或 $k=4$，那么没有道路需要封闭。\n\n因此，`minimum_closure_costs` 应该返回数组 $[10,5,1,0,0]$。\n\n### 例子 $2$\n\n考虑如下调用：\n\n`minimum_closure_costs(4, [0, 2, 0], [1, 0, 3], [5, 10, 5])\n`\n\n这个例子中共有 $4$ 个路口和 $3$ 条道路，分别连接着路口 $(0,1),(2,0)$ 和 $(0,3)$，封闭它们的成本依次为 $5,10$ 和 $5$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9fdtl4aj.png)\n\n为了得到最低的总成本:\n\n- 如果 PakDengklek 选择 $k=0$，那么所有道路都需要封闭，总成本为 $5+10+5=20$；\n- 如果 PakDengklek 选择 $k=1$，那么需要封闭 $0$ 号道路和 $2$ 号道路，总成本为 $5+5=10$；\n- 如果 PakDengklek 选择 $k=2$，那么需要封闭 $0$ 号道路或 $2$ 号道路，总成本为 $5$；\n- 如果 PakDengklek 选择 $k=3$，那么没有道路需要封闭。\n\n因此，minimum_closure_costs 应该返回数组 $[20,10,5,0]$。\n\n## 约束\n\n- $2 \\le N \\le 10^5$\n- $0 \\le U[i],V[i] \\le N-1$ $(0 \\le i \\le N-2)$\n- 任意一对路口可以通过道路互相到达。\n- $1 \\le W[i] \\le 10^9$ $(0 \\le i \\le N-2)$。\n\n## 子任务\n1. (5 分) $U[i]=0$ $(0 \\le i \\le N-2)$\n2. (7 分) $U[i]=i$，$V[i]=i+1$ $(0 \\le i \\le N-2)$\n3. (14 分) $N \\le 200$\n4. (10 分) $N \\le 2000$\n5. (17 分) $W[i]=1$ $(0 \\le i \\le N-2)$\n6. (25 分) $W[i] \\le 10$ $(0 \\le i \\le N-2)$\n7. (22 分) 无附加限制", "locale": "zh-CN"}}}
