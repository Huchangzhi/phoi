{"pid": "P2618", "type": "P", "difficulty": 3, "samples": [["1\n4", "0\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "数学"], "title": "数字工程", "background": "", "description": "ACM 实验室开启了一个数字工程项目，希望把正整数 $n$ 通过一些特殊方法变成 $1$。\n\n可采用的方法有：\n\n1. 减去 $1$\n2. 除以它的任意一个素因子。 \n\n每操作一次消耗一个单位的能量。\n\n请问把 $n$ 变成 $1$ 最少需要消耗多少能量？\n", "inputFormat": "**本题有多组数据。**\n\n对于每组测试，一行一个整数 $n$。", "outputFormat": "一行一个整数，表示最少消耗的能量。", "hint": "$1 \\le n \\le 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "Number Engineering", "background": "", "description": "The ACM Laboratory has launched a number engineering project, aiming to transform a positive integer $n$ into $1$ using some special methods.\n\nAvailable methods are:\n1. Subtract $1$.\n2. Divide by any one of its prime factors.\n\nEach operation consumes one unit of energy.\n\nWhat is the minimum energy required to turn $n$ into $1$?", "inputFormat": "This problem contains multiple test cases.\n\nFor each test case, there is one line with an integer $n$.", "outputFormat": "Output one line with a single integer, the minimum energy consumed.", "hint": "Constraints: $1 \\le n \\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "数字工程", "background": "", "description": "ACM 实验室开启了一个数字工程项目，希望把正整数 $n$ 通过一些特殊方法变成 $1$。\n\n可采用的方法有：\n\n1. 减去 $1$\n2. 除以它的任意一个素因子。 \n\n每操作一次消耗一个单位的能量。\n\n请问把 $n$ 变成 $1$ 最少需要消耗多少能量？\n", "inputFormat": "**本题有多组数据。**\n\n对于每组测试，一行一个整数 $n$。", "outputFormat": "一行一个整数，表示最少消耗的能量。", "hint": "$1 \\le n \\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P2619", "type": "P", "difficulty": 5, "samples": [["2 2 1\n0 1 1 1\n0 1 2 0", "2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["二分", "集训队互测", "凸完全单调性（wqs 二分）", "生成树"], "title": "[国家集训队] Tree I", "background": "", "description": "给你一个无向带权连通图，每条边是黑色或白色。让你求一棵最小权的恰好有 $need$ 条白色边的生成树。\n\n题目保证有解。\n", "inputFormat": "第一行 $V,E,need$ 分别表示点数，边数和需要的白色边数。\n\n接下来 $E$ 行，每行 $s,t,c,col$ 表示这边的端点（点从 $0$ 开始标号），边权，颜色（$0$ 白色 $1$ 黑色）。\n", "outputFormat": "一行，表示所求生成树的边权和。\n", "hint": "对于 $5\\%$ 的数据，$V\\leq 10$。\n\n对于另 $15\\%$ 的数据，$V\\leq 15$。\n\n对于 $100\\%$ 的数据，$V\\leq 5\\times10^4,E\\leq 10^5$。\n\n所有数据边权为 $[1,100]$ 中的正整数。\n\n\nBy WJMZBMR\n", "locale": "zh-CN", "translations": {"en": {"title": "[CTT] Tree I", "background": "", "description": "You are given an undirected, weighted, connected graph. Each edge is colored black or white. Find a minimum-total-weight spanning tree that contains exactly $need$ white edges.\n\nIt is guaranteed that a solution exists.", "inputFormat": "The first line contains $V, E, need$, the numbers of vertices, edges, and the required number of white edges.\n\nThen follow $E$ lines. Each line contains $s, t, c, col$, denoting the endpoints (vertices are numbered from $0$), the edge weight, and the color ($0$ for white, $1$ for black).", "outputFormat": "Output one line: the total weight of the required spanning tree.", "hint": "Constraints:\n\n- For $5\\%$ of the testdata, $V \\le 10$.\n- For another $15\\%$ of the testdata, $V \\le 15$.\n- For $100\\%$ of the testdata, $V \\le 5 \\times 10^4, E \\le 10^5$.\n- All edge weights are positive integers in $[1, 100]$.\n\nBy WJMZBMR.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[国家集训队] Tree I", "background": "", "description": "给你一个无向带权连通图，每条边是黑色或白色。让你求一棵最小权的恰好有 $need$ 条白色边的生成树。\n\n题目保证有解。\n", "inputFormat": "第一行 $V,E,need$ 分别表示点数，边数和需要的白色边数。\n\n接下来 $E$ 行，每行 $s,t,c,col$ 表示这边的端点（点从 $0$ 开始标号），边权，颜色（$0$ 白色 $1$ 黑色）。\n", "outputFormat": "一行，表示所求生成树的边权和。\n", "hint": "对于 $5\\%$ 的数据，$V\\leq 10$。\n\n对于另 $15\\%$ 的数据，$V\\leq 15$。\n\n对于 $100\\%$ 的数据，$V\\leq 5\\times10^4,E\\leq 10^5$。\n\n所有数据边权为 $[1,100]$ 中的正整数。\n\n\nBy WJMZBMR\n", "locale": "zh-CN"}}}
{"pid": "P2620", "type": "P", "difficulty": 4, "samples": [["28 3 5\n2 18\n5 13\n12 6\n17 25\n20 15\n50 6 1\n9 45\n0\n", "４\n３\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "图论"], "title": "虫洞", "background": "applepi 想进行宇宙旅行。当然，applepi 知道这是有可能的，因为 applepi 的特殊能力能使他观测到宇宙中的虫洞。所谓虫洞就是一个在三维之外的维度打开的快捷通道，通过虫洞能够从一个地方瞬间移动到另外一个地方。\n", "description": "为了简化问题，我们建立一个一维坐标系，地球的位置为 $0$，而applepi 的目的地的位置是一个正整数 $W$。\n\n在每一个单位时间里，applepi 可以向正方向移动不超过 $S$ 的一个整数。虫洞可以被表示为二元组 $(B, E)$，即如果在某次移动之后 applepi 在位置 $B$，那么 applepi 就会被立刻传送到位置 $E$。\n\n注意，applepi 在移动过程中如果经过位置 $B$，由于applepi 的速度极快是不会被传送的。而且，applepi 不能够向负方向移动，但是虫洞引起的除外。\n\n现在applepi 想请你帮助他计算一下他至少需要多少个单位时间才能够到达目的地。\n", "inputFormat": "输入包含多组测试数据。\n\n每组测试数据的第一行是三个正整数 $W,S,P$，表示目的地位置，移动限制和虫洞的数目。之后 $P$ 行，每行两个整数 $B$ 和 $E$，表示一个虫洞。\n\n输入文件的最后一行是一个整数 $0$，表示输入的结束。\n", "outputFormat": "对于每组测试数据，在单独的一行内输出结果。\n", "hint": "对于 $30\\%$ 的数据，$W≤1000$。\n\n对于 $100\\%$ 的数据，$W≤10^9$，$2≤S≤6$，$1≤P≤40$，没有 $B = 0$ 或者 $B = W$ 的虫洞，输入数据保证目的地可达。\n", "locale": "zh-CN", "translations": {"en": {"title": "Wormholes", "background": "applepi wants to travel through the universe. Of course, applepi knows this is possible because his special ability lets him observe wormholes in the universe. A wormhole is a shortcut opened in a dimension beyond three dimensions, allowing instantaneous movement from one place to another.", "description": "To simplify the problem, we set up a one-dimensional coordinate system, with Earth at position $0$, and applepi’s destination at a positive integer position $W$.\n\nIn each unit time, applepi can move an integer no greater than $S$ toward the positive direction. A wormhole is represented as a pair $(B, E)$, meaning that if after a move applepi is at position $B$, he is immediately transported to position $E$.\n\nNote that if applepi passes through position $B$ during a move, he will not be transported because he moves extremely fast. Also, applepi cannot move in the negative direction, except when caused by a wormhole.\n\nNow applepi asks you to compute the minimum number of unit times needed to reach the destination.", "inputFormat": "The input contains multiple test cases.\n\nFor each test case, the first line contains three positive integers $W, S, P$, representing the destination position, the movement limit, and the number of wormholes. The next $P$ lines each contain two integers $B$ and $E$, representing a wormhole.\n\nThe last line of the input file is an integer $0$, indicating the end of input.", "outputFormat": "For each test case, output the result on a single line.", "hint": "- For $30\\%$ of the testdata, $W \\le 1000$.\n- For $100\\%$ of the testdata, $W \\le 10^9$, $2 \\le S \\le 6$, $1 \\le P \\le 40$, there is no wormhole with $B = 0$ or $B = W$, and the input guarantees the destination is reachable.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "虫洞", "background": "applepi 想进行宇宙旅行。当然，applepi 知道这是有可能的，因为 applepi 的特殊能力能使他观测到宇宙中的虫洞。所谓虫洞就是一个在三维之外的维度打开的快捷通道，通过虫洞能够从一个地方瞬间移动到另外一个地方。\n", "description": "为了简化问题，我们建立一个一维坐标系，地球的位置为 $0$，而applepi 的目的地的位置是一个正整数 $W$。\n\n在每一个单位时间里，applepi 可以向正方向移动不超过 $S$ 的一个整数。虫洞可以被表示为二元组 $(B, E)$，即如果在某次移动之后 applepi 在位置 $B$，那么 applepi 就会被立刻传送到位置 $E$。\n\n注意，applepi 在移动过程中如果经过位置 $B$，由于applepi 的速度极快是不会被传送的。而且，applepi 不能够向负方向移动，但是虫洞引起的除外。\n\n现在applepi 想请你帮助他计算一下他至少需要多少个单位时间才能够到达目的地。\n", "inputFormat": "输入包含多组测试数据。\n\n每组测试数据的第一行是三个正整数 $W,S,P$，表示目的地位置，移动限制和虫洞的数目。之后 $P$ 行，每行两个整数 $B$ 和 $E$，表示一个虫洞。\n\n输入文件的最后一行是一个整数 $0$，表示输入的结束。\n", "outputFormat": "对于每组测试数据，在单独的一行内输出结果。\n", "hint": "对于 $30\\%$ 的数据，$W≤1000$。\n\n对于 $100\\%$ 的数据，$W≤10^9$，$2≤S≤6$，$1≤P≤40$，没有 $B = 0$ 或者 $B = W$ 的虫洞，输入数据保证目的地可达。\n", "locale": "zh-CN"}}}
{"pid": "P2622", "type": "P", "difficulty": 3, "samples": [["3\n2\n1 0 1\n-1 1 0", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2015", "洛谷原创", "最短路", "洛谷月赛", "状压 DP"], "title": "关灯问题 II", "background": "", "description": "现有 $n$ 盏灯，以及 $m$ 个按钮。每个按钮可以同时控制这 $n$ 盏灯——按下了第 $i$ 个按钮，对于所有的灯都有一个效果。按下 $i$ 按钮对于第 $j$ 盏灯，是下面 $3$ 种效果之一：\n\n- 如果 $a_{i,j}$ 为 $1$，那么当这盏灯开了的时候，把它关上，否则不管；\n- 如果 $a_{i,j}$ 为 $-1$，如果这盏灯是关的，那么把它打开，否则也不管；\n- 如果 $a_{i,j}$ 为 $0$，无论这灯是否开，都不管。\n\n现在这些灯都是开的，给出所有开关对所有灯的控制效果，求问最少要按几下按钮才能全部关掉。", "inputFormat": "前两行两个整数，分别是 $n$ 和 $m$。\n\n接下来 $m$ 行，每行 $n$ 个整数，第 $(i+2)$ 行的第 $j$ 个整数为 $a_{i,j}$，表示第 $i$ 个开关对第 $j$ 个灯的效果。", "outputFormat": "一个整数，表示最少的按按钮的次数。如果没有任何办法使其全部关闭，输出 $-1$。", "hint": "### 数据范围及约定\n\n- 存在 $20\\%$ 的数据，输出无解可以得分。\n- 存在 $20\\%$ 的数据，$n \\le 5$。\n- 存在 $20\\%$ 的数据，$m \\le 20$。\n\n上面的数据点可能会重叠。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10, 1 \\le m \\le 100$。", "locale": "zh-CN", "translations": {"en": {"title": "Lights Out Problem II", "background": "", "description": "There are $n$ lamps and $m$ buttons. Each button can control all $n$ lamps simultaneously — pressing the $i$-th button affects every lamp. For lamp $j$, pressing button $i$ has one of the following three effects:\n\n- If $a_{i,j} = 1$, then if this lamp is on, turn it off; otherwise do nothing.\n- If $a_{i,j} = -1$, then if this lamp is off, turn it on; otherwise do nothing.\n- If $a_{i,j} = 0$, do nothing regardless of the lamp’s state.\n\nAll lamps are initially on. Given the effects of every button on every lamp, find the minimum number of button presses needed to turn all lamps off.", "inputFormat": "The first line contains the integer $n$.  \nThe second line contains the integer $m$.\n\nThe next $m$ lines each contain $n$ integers. On line $i + 2$, the $j$-th integer is $a_{i,j}$, representing the effect of button $i$ on lamp $j$.", "outputFormat": "Output a single integer — the minimum number of button presses. If it is impossible to turn all lamps off, output $-1$.", "hint": "### Constraints\n\n- For $20\\%$ of the testdata, printing “no solution” can score points.\n- For $20\\%$ of the testdata, $n \\le 5$.\n- For $20\\%$ of the testdata, $m \\le 20$.\n\nThe above test points may overlap.\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 10$, $1 \\le m \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "关灯问题 II", "background": "", "description": "现有 $n$ 盏灯，以及 $m$ 个按钮。每个按钮可以同时控制这 $n$ 盏灯——按下了第 $i$ 个按钮，对于所有的灯都有一个效果。按下 $i$ 按钮对于第 $j$ 盏灯，是下面 $3$ 种效果之一：\n\n- 如果 $a_{i,j}$ 为 $1$，那么当这盏灯开了的时候，把它关上，否则不管；\n- 如果 $a_{i,j}$ 为 $-1$，如果这盏灯是关的，那么把它打开，否则也不管；\n- 如果 $a_{i,j}$ 为 $0$，无论这灯是否开，都不管。\n\n现在这些灯都是开的，给出所有开关对所有灯的控制效果，求问最少要按几下按钮才能全部关掉。", "inputFormat": "前两行两个整数，分别是 $n$ 和 $m$。\n\n接下来 $m$ 行，每行 $n$ 个整数，第 $(i+2)$ 行的第 $j$ 个整数为 $a_{i,j}$，表示第 $i$ 个开关对第 $j$ 个灯的效果。", "outputFormat": "一个整数，表示最少的按按钮的次数。如果没有任何办法使其全部关闭，输出 $-1$。", "hint": "### 数据范围及约定\n\n- 存在 $20\\%$ 的数据，输出无解可以得分。\n- 存在 $20\\%$ 的数据，$n \\le 5$。\n- 存在 $20\\%$ 的数据，$m \\le 20$。\n\n上面的数据点可能会重叠。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10, 1 \\le m \\le 100$。", "locale": "zh-CN"}}}
{"pid": "P2623", "type": "P", "difficulty": 3, "samples": [["1 0\n1 1 1", "0"], ["4 10\n2 1 2 1\n1 1 2\n3 5 2\n2 200 2 3", "610"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP"], "title": "物品选取", "background": "小X确信所有问题都有个多项式时间算法，为了证明，他决定自己去当一次旅行商，在上路之前，小X需要挑选一些在路上使用的物品，但他只有一个能装体积为 $m$ 的背包。显然，背包问题对小X来说过于简单了，所以他希望你来帮他解决这个问题。", "description": "小X可以选择的物品有 $n$ 样，一共分为甲乙丙三类：\n\n 1．甲类物品的价值随着你分配给他的背包体积变化，它的价值与分配给它的体积满足函数关系式，$v(x) = Ax^2-Bx$，$A$，$B$ 是每个甲类物品的两个参数。注意每个体积的甲类物品只有一个。\n\n 2．乙类物品的价值 $A$ 和体积 $B$ 都是固定的，但是每个乙类物品都有个参数 $C$，表示这个物品可供选择的个数。\n\n 3．丙类物品的价值 $A$ 和体积 $B$ 也是固定的，但是每个丙类物品可供选择的个数都是无限多个。\n\n你最终的任务是确定小X的背包最多能装有多大的价值上路。", "inputFormat": "第一行两个整数 $n$，$m$，表示背包物品的个数和背包的体积；\n\n 接下来 $n$ 行，每行描述一个物品的信息。第一个整数 $x$ ，表示物品的种类：\n\n若 $x$ 为 $1$ 表示甲类物品，接下来两个整数 $A$, $B$，为 $A$ 类物品的两个参数；\n\n若 $x$ 为 $2$ 表示乙类物品，接下来三个整数 $A$，$B$，$C$。$A$ 表示物品的价值，$B$ 表示它的体积，$C$ 表示它的个数；\n\n若 $x$ 为 $3$ 表示丙类物品，接下来两个整数 $A$，$B$。$A$ 表示它的价值，$B$ 表示它的体积。", "outputFormat": "输出文件仅一行为一个整数，表示小X的背包能装的最大价值。", "hint": "对于 $50\\%$ 的数据，只有乙和丙两类物品；\n\n对于 $70\\%$ 的数据，$1 \\le n \\le 100$, $1 \\le m \\le 500$，$0 \\le A,B,C \\le 200$；\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 100$, $1 \\le m \\le 2000$，$0 \\le A,B,C \\le 200$；", "locale": "zh-CN", "translations": {"en": {"title": "Item Selection", "background": "Xiao X believes that every problem has a polynomial-time algorithm. To prove it, he decides to be a traveling salesman once. Before setting off, Xiao X needs to choose some items to use on the road, but he only has a backpack with capacity $m$. Obviously, the knapsack problem is too easy for Xiao X, so he wants you to solve this problem for him.", "description": "Xiao X can choose from $n$ items, divided into three categories: A, B, and C.\n\n1. Type A items have values that change with the volume you allocate to them. Their value follows the function $v(x) = A x^2 - B x$, where $A$ and $B$ are two parameters for each type A item. Note: for type A items, there is only one item for each volume amount.\n\n2. Type B items have fixed value $A$ and volume $B$, and each has a parameter $C$, which is the number of copies available.\n\n3. Type C items also have fixed value $A$ and volume $B$, but the number of copies available is unlimited.\n\nYour task is to determine the maximum total value Xiao X can carry in his backpack.", "inputFormat": "The first line contains two integers $n$ and $m$, the number of items and the backpack capacity.\n\nThen follow $n$ lines, each describing one item. The first integer $x$ indicates the item category:\n\n- If $x = 1$, it is a type A item. The next two integers $A$, $B$ are this item's two parameters.\n- If $x = 2$, it is a type B item. The next three integers $A$, $B$, $C$ denote the item's value, its volume, and the number of copies available, respectively.\n- If $x = 3$, it is a type C item. The next two integers $A$, $B$ denote the item's value and its volume.", "outputFormat": "Output a single line containing one integer: the maximum total value that can be carried in the backpack.", "hint": "- For $50\\%$ of the testdata, only types B and C appear.\n- For $70\\%$ of the testdata, $1 \\le n \\le 100$, $1 \\le m \\le 500$, $0 \\le A, B, C \\le 200$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 100$, $1 \\le m \\le 2000$, $0 \\le A, B, C \\le 200$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "物品选取", "background": "小X确信所有问题都有个多项式时间算法，为了证明，他决定自己去当一次旅行商，在上路之前，小X需要挑选一些在路上使用的物品，但他只有一个能装体积为 $m$ 的背包。显然，背包问题对小X来说过于简单了，所以他希望你来帮他解决这个问题。", "description": "小X可以选择的物品有 $n$ 样，一共分为甲乙丙三类：\n\n 1．甲类物品的价值随着你分配给他的背包体积变化，它的价值与分配给它的体积满足函数关系式，$v(x) = Ax^2-Bx$，$A$，$B$ 是每个甲类物品的两个参数。注意每个体积的甲类物品只有一个。\n\n 2．乙类物品的价值 $A$ 和体积 $B$ 都是固定的，但是每个乙类物品都有个参数 $C$，表示这个物品可供选择的个数。\n\n 3．丙类物品的价值 $A$ 和体积 $B$ 也是固定的，但是每个丙类物品可供选择的个数都是无限多个。\n\n你最终的任务是确定小X的背包最多能装有多大的价值上路。", "inputFormat": "第一行两个整数 $n$，$m$，表示背包物品的个数和背包的体积；\n\n 接下来 $n$ 行，每行描述一个物品的信息。第一个整数 $x$ ，表示物品的种类：\n\n若 $x$ 为 $1$ 表示甲类物品，接下来两个整数 $A$, $B$，为 $A$ 类物品的两个参数；\n\n若 $x$ 为 $2$ 表示乙类物品，接下来三个整数 $A$，$B$，$C$。$A$ 表示物品的价值，$B$ 表示它的体积，$C$ 表示它的个数；\n\n若 $x$ 为 $3$ 表示丙类物品，接下来两个整数 $A$，$B$。$A$ 表示它的价值，$B$ 表示它的体积。", "outputFormat": "输出文件仅一行为一个整数，表示小X的背包能装的最大价值。", "hint": "对于 $50\\%$ 的数据，只有乙和丙两类物品；\n\n对于 $70\\%$ 的数据，$1 \\le n \\le 100$, $1 \\le m \\le 500$，$0 \\le A,B,C \\le 200$；\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 100$, $1 \\le m \\le 2000$，$0 \\le A,B,C \\le 200$；", "locale": "zh-CN"}}}
{"pid": "P2624", "type": "P", "difficulty": 6, "samples": [["3\n1\n-1\n-1", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "各省省选", "湖南"], "title": "[HNOI2008] 明明的烦恼", "background": "原 编译优化 参见P1792", "description": "自从明明学了树的结构，就对奇怪的树产生了兴趣……\n\n给出标号为 $1$ 到 $N$ 的点，以及某些点最终的度数，允许在任意两点间连边，可产生多少棵度数满足要求的树?", "inputFormat": "第一行一个正整数 $N(0< N\\le 1000)$。\n\n接下来 $N$ 行，第 $i+1$ 一个正整数表示第 $i$ 个节点的度数 $D_i$。如果对度数不要求，则输入 `-1`。", "outputFormat": "一行一个正整数，表示不同的满足要求的树的个数，无解则输出 $0$。", "hint": "两棵树分别为 `1-2-3` 与 `1-3-2`。", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2008] Mingming's Worries", "background": "Original: \"Compilation Optimization\". See P1792.", "description": "Ever since Mingming learned about tree structures, he has become interested in unusual trees.\n\nGiven nodes labeled $1$ to $N$, and the final degrees of some nodes, you may add edges between any pair of nodes. How many trees can be formed whose degrees meet the given requirements?", "inputFormat": "The first line contains a positive integer $N$ ($0 < N \\le 1000$).\n\nThe next $N$ lines: the $(i+1)$-th line contains a positive integer representing the degree $D_i$ of the $i$-th node. If the degree is unconstrained, input `-1`.", "outputFormat": "Output a single positive integer on one line, the number of different trees that satisfy the requirements. If there is no solution, output $0$.", "hint": "The two trees are `1-2-3` and `1-3-2`.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2008] 明明的烦恼", "background": "原 编译优化 参见P1792", "description": "自从明明学了树的结构，就对奇怪的树产生了兴趣……\n\n给出标号为 $1$ 到 $N$ 的点，以及某些点最终的度数，允许在任意两点间连边，可产生多少棵度数满足要求的树?", "inputFormat": "第一行一个正整数 $N(0< N\\le 1000)$。\n\n接下来 $N$ 行，第 $i+1$ 一个正整数表示第 $i$ 个节点的度数 $D_i$。如果对度数不要求，则输入 `-1`。", "outputFormat": "一行一个正整数，表示不同的满足要求的树的个数，无解则输出 $0$。", "hint": "两棵树分别为 `1-2-3` 与 `1-3-2`。", "locale": "zh-CN"}}}
{"pid": "P2625", "type": "P", "difficulty": 4, "samples": [["3\nforward 100\nbackward 100\nleft 90", "141.421356"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "数学", "贪心", "背包 DP"], "title": "豪华游轮", "background": "", "description": "有一条豪华游轮（其实就是条小木船），这种船可以执行 $4$ 种指令：\n\n`right X`：其中 $X$ 是一个 $1$ 到 $719$ 的整数，这个命令使得船顺时针转动 $X$ 度。\n\n`left X`：其中 $X$ 是一个 $1$ 到 $719$ 的整数，这个命令使得船逆时针转动 $X$ 度。\n\n`forward X`：其中 $X$ 是一个整数（$1$ 到 $1000$），使得船向正前方前进 $X$ 的距离。\n\n`backward X`：其中 $X$ 是一个整数（$1$ 到 $1000$），使得船向正后方前进 $X$ 的距离。\n\n随意的写出了 $n$ 个命令，找出一个种排列命令的方法，使得船最终到达的位置距离起点尽可能的远。\n", "inputFormat": "第一行一个整数 $n (1 \\leq n \\leq 50)$，表示给出的命令数。\n\n接下来 $n$ 行，每行表示一个命令。", "outputFormat": "一个浮点数，能够走的最远的距离，四舍五入到 $6$ 位小数。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Luxury Cruise Ship", "background": "", "description": "There is a luxury cruise ship (actually just a small wooden boat). This ship can execute $4$ types of commands:\n\n`right X`: where $X$ is an integer from $1$ to $719$. This command rotates the ship clockwise by $X$ degrees.\n\n`left X`: where $X$ is an integer from $1$ to $719$. This command rotates the ship counterclockwise by $X$ degrees.\n\n`forward X`: where $X$ is an integer ($1$ to $1000$). This command moves the ship $X$ units straight ahead along its current heading.\n\n`backward X`: where $X$ is an integer ($1$ to $1000$). This command moves the ship $X$ units straight backward along its current heading.\n\nYou are given $n$ commands written in arbitrary order. Find a way to arrange these commands so that the ship’s final position is as far from the starting point as possible.", "inputFormat": "The first line contains an integer $n (1 \\leq n \\leq 50)$, representing the number of given commands.\n\nThe next $n$ lines each contain one command.", "outputFormat": "Output a floating-point number: the maximum achievable distance, rounded to $6$ decimal places.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "豪华游轮", "background": "", "description": "有一条豪华游轮（其实就是条小木船），这种船可以执行 $4$ 种指令：\n\n`right X`：其中 $X$ 是一个 $1$ 到 $719$ 的整数，这个命令使得船顺时针转动 $X$ 度。\n\n`left X`：其中 $X$ 是一个 $1$ 到 $719$ 的整数，这个命令使得船逆时针转动 $X$ 度。\n\n`forward X`：其中 $X$ 是一个整数（$1$ 到 $1000$），使得船向正前方前进 $X$ 的距离。\n\n`backward X`：其中 $X$ 是一个整数（$1$ 到 $1000$），使得船向正后方前进 $X$ 的距离。\n\n随意的写出了 $n$ 个命令，找出一个种排列命令的方法，使得船最终到达的位置距离起点尽可能的远。\n", "inputFormat": "第一行一个整数 $n (1 \\leq n \\leq 50)$，表示给出的命令数。\n\n接下来 $n$ 行，每行表示一个命令。", "outputFormat": "一个浮点数，能够走的最远的距离，四舍五入到 $6$ 位小数。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2626", "type": "P", "difficulty": 2, "samples": [["5", "5=5"], ["6", "8=2*2*2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "递推", "素数判断,质数,筛法"], "title": "斐波那契数列（升级版）", "background": "大家都知道，斐波那契数列是满足如下性质的一个数列： \n\n- $f(1) = 1$\n- $f(2) = 1$ \n- $f(n) = f(n-1) + f(n-2)$（$n > 2$ 且 $n$ 为整数）。\n", "description": "请你求出第 $n$ 个斐波那契数列的数 $\\bmod\\,2^{31}$ 之后的值，并把它分解质因数。\n", "inputFormat": "输入一个正整数 $n$。", "outputFormat": "把第 $n$ 个斐波那契数列的数分解质因数。\n", "hint": "$n \\le 48$", "locale": "zh-CN", "translations": {"en": {"title": "Fibonacci Sequence (Upgraded Version)", "background": "Everyone knows that the Fibonacci sequence satisfies the following properties:\n- $f(1) = 1$.\n- $f(2) = 1$.\n- $f(n) = f(n-1) + f(n-2)$ (where $n > 2$ and $n$ is an integer).", "description": "Please compute the $n$-th Fibonacci number, take it $\\bmod\\,2^{31}$, and factor the result into prime factors.", "inputFormat": "Input a positive integer $n$.", "outputFormat": "Output the prime factorization of the $n$-th Fibonacci number after applying $\\bmod\\,2^{31}$.", "hint": "$n \\le 48$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "斐波那契数列（升级版）", "background": "大家都知道，斐波那契数列是满足如下性质的一个数列： \n\n- $f(1) = 1$\n- $f(2) = 1$ \n- $f(n) = f(n-1) + f(n-2)$（$n > 2$ 且 $n$ 为整数）。\n", "description": "请你求出第 $n$ 个斐波那契数列的数 $\\bmod\\,2^{31}$ 之后的值，并把它分解质因数。\n", "inputFormat": "输入一个正整数 $n$。", "outputFormat": "把第 $n$ 个斐波那契数列的数分解质因数。\n", "hint": "$n \\le 48$", "locale": "zh-CN"}}}
{"pid": "P2627", "type": "P", "difficulty": 4, "samples": [["5 2\n1\n2\n3\n4\n5\n", "12\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2011", "线段树", "USACO", "单调队列"], "title": "[USACO11OPEN] Mowing the Lawn G", "background": "", "description": "在一年前赢得了小镇的最佳草坪比赛后，Farmer John 变得很懒，再也没有修剪过草坪。现在，新一轮的最佳草坪比赛又开始了，Farmer John 希望能够再次夺冠。\n\n然而，Farmer John 的草坪非常脏乱，因此，Farmer John 只能够让他的奶牛来完成这项工作。Farmer John 有 $N$（$1\\le N\\le 10^5$）只排成一排的奶牛，编号为 $1\\ldots N$。每只奶牛的效率是不同的，奶牛 $i$ 的效率为 $E_i$（$0\\le E_i\\le 10^9$）。\n\n靠近的奶牛们很熟悉，因此，如果 Farmer John安排超过 $K$（$1\\le K\\le N$）只连续的奶牛，那么，这些奶牛就会罢工去开派对 :)。因此，现在 Farmer John 需要你的帮助，计算 FJ 可以得到的最大效率，并且该方案中没有连续的超过 $K$ 只奶牛。", "inputFormat": "第一行：空格隔开的两个整数 $N$ 和 $K$。\n\n第二到 $N+1$ 行：第 $i+1$ 行有一个整数 $E_i$。", "outputFormat": "第一行：一个值，表示 Farmer John 可以得到的最大的效率值。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[USACO11OPEN] Mowing the Lawn G", "background": "", "description": "After winning the town’s Best Lawn contest a year ago, Farmer John became lazy and hasn’t mowed the lawn since. Now, a new Best Lawn contest is starting, and Farmer John hopes to win again.\n\nHowever, Farmer John’s lawn is a mess, so he can only rely on his cows to do the job. Farmer John has $N$ ($1\\le N\\le 10^5$) cows in a row, numbered $1\\ldots N$. Each cow has a different efficiency; cow $i$ has efficiency $E_i$ ($0\\le E_i\\le 10^9$).\n\nNeighboring cows are very familiar with each other, so if Farmer John schedules more than $K$ ($1\\le K\\le N$) consecutive cows, they will go on strike to throw a party :). Therefore, Farmer John needs your help to compute the maximum total efficiency he can obtain, with no stretch of more than $K$ consecutive cows.", "inputFormat": "The first line contains two integers $N$ and $K$ separated by a space.\n\nThe second to $(N+1)$-th lines: the $(i+1)$-th line contains an integer $E_i$.", "outputFormat": "Output a single value: the maximum total efficiency that Farmer John can obtain.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO11OPEN] Mowing the Lawn G", "background": "", "description": "在一年前赢得了小镇的最佳草坪比赛后，Farmer John 变得很懒，再也没有修剪过草坪。现在，新一轮的最佳草坪比赛又开始了，Farmer John 希望能够再次夺冠。\n\n然而，Farmer John 的草坪非常脏乱，因此，Farmer John 只能够让他的奶牛来完成这项工作。Farmer John 有 $N$（$1\\le N\\le 10^5$）只排成一排的奶牛，编号为 $1\\ldots N$。每只奶牛的效率是不同的，奶牛 $i$ 的效率为 $E_i$（$0\\le E_i\\le 10^9$）。\n\n靠近的奶牛们很熟悉，因此，如果 Farmer John安排超过 $K$（$1\\le K\\le N$）只连续的奶牛，那么，这些奶牛就会罢工去开派对 :)。因此，现在 Farmer John 需要你的帮助，计算 FJ 可以得到的最大效率，并且该方案中没有连续的超过 $K$ 只奶牛。", "inputFormat": "第一行：空格隔开的两个整数 $N$ 和 $K$。\n\n第二到 $N+1$ 行：第 $i+1$ 行有一个整数 $E_i$。", "outputFormat": "第一行：一个值，表示 Farmer John 可以得到的最大的效率值。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2628", "type": "P", "difficulty": 2, "samples": [["yhfA>>>fhsdfa***>>>foaoad\r\n3\r\n5 6 6", "20 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟"], "title": "冒险岛", "background": "冒险岛是费老师新开发的一种情景模拟电脑的游戏，通过掷骰子（1~6个数字之间），让一种人物（棋子）在棋纸上从左至右的行走，从而模拟冒险的故事……\n", "description": "棋纸上有一条从左至右的很长的路，整条路是一连串符号组成，表明路的状况，棋子必须在符号组成的路上行走。每掷一下骰子得到的数字，棋子就可以走掷得的数字所对应的步数，比如掷3，就可以走3步。\n\n路上有两种特殊符号可以改变棋子的行走。\n\n一种是“>”符号，一旦棋子走完了掷骰子的步数，最终停留在这个符号上，后面有紧跟着2个以上“>”，那么棋子就可以获得前进奖励，可以沿着“>”一直一步步前进，直到遇到一个不是“>”的符号位置停下来。\n\n还有一种是“\\*”符号，一旦棋子走完了掷骰子的步数，最终停留在这个符号上，后面又紧跟着两个以上“\\*”，就要受到后退惩罚，需要退后k步，这个k步就是从当前“\\*”开始的连续的“\\*”的数量。\n\n每次掷数后，奖励或惩罚至多一次，如果奖励或惩罚后棋子又落在第二种特殊符号上，则不能再受到奖励或惩罚。\n\n如果走的棋子超出棋纸右边界最后一个符号，则停在最后一个符号上；如果超出左边界，则停在第一个符号上。\n\n若干次掷骰子后，请问游戏中的人物（棋子）走到了哪步？离终点还差几步？\n", "inputFormat": "第一行为一个字符串s，字符串中的每个字符表示棋纸的路的状况。\n\n第二行是一个n，表示掷了n次骰子。\n\n第三行是n个整数（1~6的范围），表明掷了n次骰子得到的数字，数字之间有一个空格。\n", "outputFormat": "只有两个数字，表明目前所在符号的序号和离终点符号的步数，数子中间有一个空格。注意输出末尾有换行。\n", "hint": "【样例说明】\n\n在游戏中，第一次掷的是5，则走到第一个>的位置，获得奖励前进至左起第二个f处。第二次掷的是6，则走到\\*的位置，受惩罚退3步，至d处。第三次掷的是6，则走至左起第四个>号处，获奖励前进至f。最终棋子停留的符号是第20个（从左至右的数），离终点符号d（含）相差5步数。\n\n【数据范围】\n\n对于50%的数据，1<=s的长度<=255,0<=n<=1000。\n\n对于100%的数据，256<=s的长度<=1000000,0<=n<=100000。\n", "locale": "zh-CN", "translations": {"en": {"title": "Adventure Island", "background": "Adventure Island is a scenario-simulation computer game newly developed by Teacher Fei. By rolling a die (numbers 1 to 6), a character (the piece) walks from left to right on a board, thereby simulating an adventure story.", "description": "On the board, there is a long road from left to right. The entire road is a sequence of symbols that describe the road’s state, and the piece must walk along this symbolic road. Each time you roll the die and obtain a number, the piece moves exactly that many steps. For example, if you roll a 3, it moves 3 steps.\n\nThere are two special symbols on the road that can change the piece’s movement:\n\n- The “>” symbol: If, after finishing the steps from the die roll, the piece lands on this symbol and there are at least 2 consecutive “>” immediately following it, then the piece receives a forward bonus. It moves forward along the consecutive “>” one step at a time until it reaches a position whose symbol is not “>”, and stops there.\n\n- The “\\*” symbol: If, after finishing the steps from the die roll, the piece lands on this symbol and there are at least 2 consecutive “\\*” immediately following it, then it suffers a backward penalty. It must move back by k steps, where k is the length of the consecutive “\\*” run starting from the current “\\*”.\n\nAfter each roll, at most one bonus or penalty is applied. If, after applying a bonus or penalty, the piece lands on another special symbol, no further bonus or penalty is applied.\n\nIf the piece moves past the right boundary (beyond the last symbol), it stops at the last symbol. If it moves past the left boundary, it stops at the first symbol.\n\nAfter several die rolls, determine which position the piece ends on, and how many steps remain to the end.", "inputFormat": "- The first line is a string s, where each character describes the state of one position on the board.\n- The second line is an integer n, the number of die rolls.\n- The third line contains n integers (each in the range 1 to 6), the numbers obtained from the n rolls, separated by single spaces.", "outputFormat": "Output exactly two numbers: the 1-based index of the current symbol and the number of steps remaining to the last symbol (inclusive). Separate them with a single space. Note: end the output with a newline.", "hint": "[Sample Explanation]\n\nIn the game, the first roll is 5, so the piece moves to the first “>” and gains a forward bonus to the second “f” from the left. The second roll is 6, so it lands on “\\*”, suffers a penalty of 3 steps backward, and moves to “d”. The third roll is 6, so it reaches the fourth “>” from the left and gains a bonus to “f”. The piece finally stops at the 20th symbol (counting from left to right), and is 5 steps away from the last symbol “d” (inclusive).\n\nConstraints\n\n- For 50% of the testdata: 1 <= |s| <= 255, 0 <= n <= 1000.\n- For 100% of the testdata: 256 <= |s| <= 1,000,000, 0 <= n <= 100,000.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "冒险岛", "background": "冒险岛是费老师新开发的一种情景模拟电脑的游戏，通过掷骰子（1~6个数字之间），让一种人物（棋子）在棋纸上从左至右的行走，从而模拟冒险的故事……\n", "description": "棋纸上有一条从左至右的很长的路，整条路是一连串符号组成，表明路的状况，棋子必须在符号组成的路上行走。每掷一下骰子得到的数字，棋子就可以走掷得的数字所对应的步数，比如掷3，就可以走3步。\n\n路上有两种特殊符号可以改变棋子的行走。\n\n一种是“>”符号，一旦棋子走完了掷骰子的步数，最终停留在这个符号上，后面有紧跟着2个以上“>”，那么棋子就可以获得前进奖励，可以沿着“>”一直一步步前进，直到遇到一个不是“>”的符号位置停下来。\n\n还有一种是“\\*”符号，一旦棋子走完了掷骰子的步数，最终停留在这个符号上，后面又紧跟着两个以上“\\*”，就要受到后退惩罚，需要退后k步，这个k步就是从当前“\\*”开始的连续的“\\*”的数量。\n\n每次掷数后，奖励或惩罚至多一次，如果奖励或惩罚后棋子又落在第二种特殊符号上，则不能再受到奖励或惩罚。\n\n如果走的棋子超出棋纸右边界最后一个符号，则停在最后一个符号上；如果超出左边界，则停在第一个符号上。\n\n若干次掷骰子后，请问游戏中的人物（棋子）走到了哪步？离终点还差几步？\n", "inputFormat": "第一行为一个字符串s，字符串中的每个字符表示棋纸的路的状况。\n\n第二行是一个n，表示掷了n次骰子。\n\n第三行是n个整数（1~6的范围），表明掷了n次骰子得到的数字，数字之间有一个空格。\n", "outputFormat": "只有两个数字，表明目前所在符号的序号和离终点符号的步数，数子中间有一个空格。注意输出末尾有换行。\n", "hint": "【样例说明】\n\n在游戏中，第一次掷的是5，则走到第一个>的位置，获得奖励前进至左起第二个f处。第二次掷的是6，则走到\\*的位置，受惩罚退3步，至d处。第三次掷的是6，则走至左起第四个>号处，获奖励前进至f。最终棋子停留的符号是第20个（从左至右的数），离终点符号d（含）相差5步数。\n\n【数据范围】\n\n对于50%的数据，1<=s的长度<=255,0<=n<=1000。\n\n对于100%的数据，256<=s的长度<=1000000,0<=n<=100000。\n", "locale": "zh-CN"}}}
{"pid": "P2629", "type": "P", "difficulty": 3, "samples": [["4\n-3 5 1 2\n", "2\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "线性数据结构", "单调队列", "洛谷原创", "前缀和", "队列", "洛谷月赛"], "title": "好消息，坏消息", "background": null, "description": "Uim 在公司里面当秘书，现在有 $n$ 条消息要告知老板。每条消息有一个好坏度，这会影响老板的心情。告知完一条消息后，老板的心情等于老板之前的心情加上这条消息的好坏度。最开始老板的心情是 $0$，一旦老板心情到了 $0$ 以下就会勃然大怒，炒了 Uim 的鱿鱼。\n\nUim 为了不被炒，提前知道了这些消息（已经按时间的发生顺序进行了排列）的好坏度，希望知道如何才能不让老板发怒。\n\nUim 可以使用一种叫 “倒叙” 的手法，例如有 $n$ 条消息，Uim 可以任取一个整数 $k$（$1 \\leq k \\leq n$），先从 $k$ 事件通报到 $n$ 事件，再从 $1$ 事件通报到 $k-1$ 事件。特别的，当 $k=1$ 时按照原顺序通报。\n\n他希望知道，有多少个这样的 $k$ 可以让老板不发怒。", "inputFormat": "第一行一个整数 $n$（$1 \\le n \\le10^6$），表示有 $n$ 个消息。\n\n第二行 $n$ 个整数，按时间顺序给出第 $i$ 条消息的好坏度 $A_i$（$-10^3\\le A_i \\le 10^3$）。", "outputFormat": "一行一个整数，表示可行的方案个数。", "hint": "**【样例解释】**\n\n通报事件的可行顺序（用编号表示）为 $2\\rightarrow3\\rightarrow4\\rightarrow1$ 或 $3\\rightarrow4\\rightarrow1\\rightarrow2$（分别对应 $k=2$ 和 $k=3$）\n\n通报事件的可行顺序（用好坏度表示）为 $5\\rightarrow1\\rightarrow2\\rightarrow(-3)$ 或 $1\\rightarrow2\\rightarrow(-3)\\rightarrow5$\n\n**【数据范围】**\n\n对于 $25\\%$ 的数据，$n\\le10^3$；  \n对于 $75\\%$ 的数据，$n\\le10^4$；  \n对于 $100\\%$ 的数据，$1 \\le n\\le 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "Good News, Bad News", "background": "", "description": "Uim works as a secretary at a company. There are $n$ messages to inform the boss. Each message has a \"goodness\" value, which affects the boss’s mood. After a message is delivered, the boss’s mood becomes his previous mood plus this message’s goodness. Initially, the boss’s mood is $0$. Once the boss’s mood falls below $0$, he will fly into a rage and fire Uim.\n\nTo avoid being fired, Uim already knows the goodness values of these messages (which are arranged in chronological order) and wants to know how to prevent the boss from getting angry.\n\nUim can use a technique called \"daoxu\" (\"倒叙\"). For example, given $n$ messages, Uim can choose any integer $k$ ($1 \\leq k \\leq n$), first report events $k$ to $n$, and then report events $1$ to $k-1$. In particular, when $k=1$, the messages are reported in the original order.\n\nHe wants to know how many such values of $k$ can keep the boss from getting angry.", "inputFormat": "The first line contains an integer $n$ ($1 \\le n \\le 10^6$), the number of messages.\n\nThe second line contains $n$ integers. In chronological order, the $i$-th message has goodness $A_i$ ($-10^3 \\le A_i \\le 10^3$).", "outputFormat": "One line with a single integer, the number of feasible choices of $k$.", "hint": "Sample Explanation:\n\nFeasible reporting orders (by indices) are $2\\rightarrow3\\rightarrow4\\rightarrow1$ or $3\\rightarrow4\\rightarrow1\\rightarrow2$ (corresponding to $k=2$ and $k=3$, respectively).\n\nFeasible reporting orders (by goodness values) are $5\\rightarrow1\\rightarrow2\\rightarrow(-3)$ or $1\\rightarrow2\\rightarrow(-3)\\rightarrow5$.\n\nConstraints:\n\nFor $25\\%$ of the testdata, $n \\le 10^3$.\nFor $75\\%$ of the testdata, $n \\le 10^4$.\nFor $100\\%$ of the testdata, $1 \\le n \\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "好消息，坏消息", "background": null, "description": "Uim 在公司里面当秘书，现在有 $n$ 条消息要告知老板。每条消息有一个好坏度，这会影响老板的心情。告知完一条消息后，老板的心情等于老板之前的心情加上这条消息的好坏度。最开始老板的心情是 $0$，一旦老板心情到了 $0$ 以下就会勃然大怒，炒了 Uim 的鱿鱼。\n\nUim 为了不被炒，提前知道了这些消息（已经按时间的发生顺序进行了排列）的好坏度，希望知道如何才能不让老板发怒。\n\nUim 可以使用一种叫 “倒叙” 的手法，例如有 $n$ 条消息，Uim 可以任取一个整数 $k$（$1 \\leq k \\leq n$），先从 $k$ 事件通报到 $n$ 事件，再从 $1$ 事件通报到 $k-1$ 事件。特别的，当 $k=1$ 时按照原顺序通报。\n\n他希望知道，有多少个这样的 $k$ 可以让老板不发怒。", "inputFormat": "第一行一个整数 $n$（$1 \\le n \\le10^6$），表示有 $n$ 个消息。\n\n第二行 $n$ 个整数，按时间顺序给出第 $i$ 条消息的好坏度 $A_i$（$-10^3\\le A_i \\le 10^3$）。", "outputFormat": "一行一个整数，表示可行的方案个数。", "hint": "**【样例解释】**\n\n通报事件的可行顺序（用编号表示）为 $2\\rightarrow3\\rightarrow4\\rightarrow1$ 或 $3\\rightarrow4\\rightarrow1\\rightarrow2$（分别对应 $k=2$ 和 $k=3$）\n\n通报事件的可行顺序（用好坏度表示）为 $5\\rightarrow1\\rightarrow2\\rightarrow(-3)$ 或 $1\\rightarrow2\\rightarrow(-3)\\rightarrow5$\n\n**【数据范围】**\n\n对于 $25\\%$ 的数据，$n\\le10^3$；  \n对于 $75\\%$ 的数据，$n\\le10^4$；  \n对于 $100\\%$ 的数据，$1 \\le n\\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P2630", "type": "P", "difficulty": 3, "samples": [["3 4 5\n6 7 8\n1 2 3\n1 2 3\n6 7 8\n3 4 5", "D"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "贪心"], "title": "图像变换", "background": null, "description": "给定 $3$ 行 $3$ 列的图像各像素点灰度值，给定最终图像，求最短、字典序最小的**非空**操作序列。\n\n其中，可能的操作及对应字符有如下四种：\n\n`A`：顺时针旋转 $90$ 度；\n\n`B`：逆时针旋转 $90$ 度；\n\n`C`：左右翻转；\n\n`D`：上下翻转。", "inputFormat": "一个矩阵，表示初始的图像。\n\n一个矩阵，表示最终的图像。", "outputFormat": "最短、字典序最小的**非空**操作序列，保证长度不超过 $10^8$，不保证有解。\n\n若长度超过 $10^8$ 无解则输出 `Poland cannot into space!!!` 。", "hint": "字符串长度不超过 $10^8$。", "locale": "zh-CN", "translations": {"en": {"title": "Image Transformation", "background": "", "description": "Given the grayscale values of every pixel in a $ 3 \\times 3 $ image and a target image, find the shortest and, among those, lexicographically smallest **non-empty** sequence of operations.\n\nThe possible operations and their corresponding characters are:\n`A`: rotate $ 90 $ degrees clockwise;\n`B`: rotate $ 90 $ degrees counterclockwise;\n`C`: flip left–right;\n`D`: flip up–down.", "inputFormat": "- Three lines, each containing $ 3 $ integers, representing the initial image matrix.\n- Three lines, each containing $ 3 $ integers, representing the target image matrix.", "outputFormat": "Output the shortest, lexicographically smallest **non-empty** operation sequence. If there is no solution, or if the shortest sequence would have length greater than $ 10^8 $, output `Poland cannot into space!!!`.", "hint": "The string length does not exceed $ 10^8 $.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "图像变换", "background": null, "description": "给定 $3$ 行 $3$ 列的图像各像素点灰度值，给定最终图像，求最短、字典序最小的**非空**操作序列。\n\n其中，可能的操作及对应字符有如下四种：\n\n`A`：顺时针旋转 $90$ 度；\n\n`B`：逆时针旋转 $90$ 度；\n\n`C`：左右翻转；\n\n`D`：上下翻转。", "inputFormat": "一个矩阵，表示初始的图像。\n\n一个矩阵，表示最终的图像。", "outputFormat": "最短、字典序最小的**非空**操作序列，保证长度不超过 $10^8$，不保证有解。\n\n若长度超过 $10^8$ 无解则输出 `Poland cannot into space!!!` 。", "hint": "字符串长度不超过 $10^8$。", "locale": "zh-CN"}}}
{"pid": "P2632", "type": "P", "difficulty": 5, "samples": [["4 4 \n0 0 10 10 \n0 10 10 0 \n0.1 0.3 0.6 0.8 \n0.1 0.3 0.6 0.8", "19.638"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "生成树"], "title": "Explorer", "background": "提示：本题数据较水，通过本题不代表程序/做法完全正确。", "description": "给出两条直线，上面分别有 $n,m$ 个点，求这 $n+m$ 个点组成的最小生成树。", "inputFormat": "输入包括 $5$ 行。 \n\n第一行为 $n$ 和 $m$。\n\n第二行为四个整数 $x_a,y_a,x_b,y_b$。\n\n第三行为四个整数 $x_c,y_c,x_d,y_d$。 \n\n第四行为 $n$ 个实数，代表在第一条直线上的 $n$ 个点。对于某个点，用一个实数 $t$ 来表示该点的坐标为 $(t x_a + (1 - t)x_b, t y_a + (1 - t) y_b)$。 \n\n第五行为 $m$ 个实数，代表第二条直线上的 $m$ 个点，表示方法同上。", "outputFormat": "一行一个实数，为其最小生成树长度，四舍五入至三位小数。", "hint": "$1 \\le n,m \\le 100000$，$x_a,y_a,x_b,y_b,x_c,y_c,x_d,y_d$ 的绝对值均小于等于 $10^5$，$0 \\le t \\le 1$。\n\n\n------------\n2024/2/8 添加一组 hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "Explorer", "background": "Hint: The testdata for this problem is relatively weak; passing this problem does not guarantee that your program or approach is entirely correct.", "description": "Given two straight lines with $n, m$ points on them respectively, find the minimum spanning tree formed by these $n + m$ points.", "inputFormat": "The input consists of $5$ lines.\n\n- The first line contains $n$ and $m$.\n- The second line contains four integers $x_a,y_a,x_b,y_b$.\n- The third line contains four integers $x_c,y_c,x_d,y_d$.\n- The fourth line contains $n$ real numbers, representing $n$ points on the first line. For a point, a real number $t$ indicates that the coordinates of the point are $(t x_a + (1 - t) x_b, t y_a + (1 - t) y_b)$.\n- The fifth line contains $m$ real numbers, representing $m$ points on the second line, in the same manner as above.", "outputFormat": "Output a single real number on one line: the length of the minimum spanning tree, rounded to three decimal places.", "hint": "Constraints: $1 \\le n,m \\le 100000$, and the absolute values of $x_a,y_a,x_b,y_b,x_c,y_c,x_d,y_d$ are all less than or equal to $10^5$. $0 \\le t \\le 1$.\n\n2024/2/8: Added one hack testdata.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Explorer", "background": "提示：本题数据较水，通过本题不代表程序/做法完全正确。", "description": "给出两条直线，上面分别有 $n,m$ 个点，求这 $n+m$ 个点组成的最小生成树。", "inputFormat": "输入包括 $5$ 行。 \n\n第一行为 $n$ 和 $m$。\n\n第二行为四个整数 $x_a,y_a,x_b,y_b$。\n\n第三行为四个整数 $x_c,y_c,x_d,y_d$。 \n\n第四行为 $n$ 个实数，代表在第一条直线上的 $n$ 个点。对于某个点，用一个实数 $t$ 来表示该点的坐标为 $(t x_a + (1 - t)x_b, t y_a + (1 - t) y_b)$。 \n\n第五行为 $m$ 个实数，代表第二条直线上的 $m$ 个点，表示方法同上。", "outputFormat": "一行一个实数，为其最小生成树长度，四舍五入至三位小数。", "hint": "$1 \\le n,m \\le 100000$，$x_a,y_a,x_b,y_b,x_c,y_c,x_d,y_d$ 的绝对值均小于等于 $10^5$，$0 \\le t \\le 1$。\n\n\n------------\n2024/2/8 添加一组 hack 数据。", "locale": "zh-CN"}}}
{"pid": "P2633", "type": "P", "difficulty": 6, "samples": [["8 5\n105 2 9 3 8 5 7 7\n1 2\n1 3\n1 4\n3 5\n3 6\n3 7\n4 8\n2 5 1\n0 5 2\n10 5 3\n11 5 4\n110 8 2", "2\n8\n9\n105\n7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2015", "线段树", "最近公共祖先 LCA", "可持久化线段树", "可持久化", "洛谷月赛"], "title": "Count on a tree", "background": "", "description": "给定一棵 $n$ 个节点的树，每个点有一个权值。有 $m$ 个询问，每次给你 $u,v,k$，你需要回答 $u \\text{ xor last}$ 和 $v$ 这两个节点间第 $k$ 小的点权。  \n\n其中 $\\text{last}$ 是上一个询问的答案，定义其初始为 $0$，即第一个询问的 $u$ 是明文。\n", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行有 $n$ 个整数，其中第 $i$ 个整数表示点 $i$ 的权值。\n\n后面 $n-1$ 行每行两个整数 $x,y$，表示点 $x$ 到点 $y$ 有一条边。\n\n最后 $m$ 行每行三个整数 $u,v,k$，表示一组询问。\n", "outputFormat": "$m$ 行，每行一个正整数表示每个询问的答案。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n,m \\le 10^5$，点权在 $[1, 2 ^ {31} - 1]$ 之间。\n\n暴力自重。。。\n\n来源：bzoj2588 Spoj10628.\n\n本题数据为洛谷自造数据，使用 [CYaRon](https://github.com/luogu-dev/cyaron) 耗时 5 分钟完成数据制作。\n", "locale": "zh-CN", "translations": {"en": {"title": "Count on a tree", "background": "", "description": "Given a tree with $n$ nodes, each node has a weight. There are $m$ queries. For each query, you are given $u, v, k$, and you need to answer the $k$-th smallest node weight on the path between $u \\text{ xor last}$ and $v$.\n\nHere, $\\text{last}$ is the answer to the previous query, initially defined as $0$, i.e., in the first query, $u$ is not xored.", "inputFormat": "The first line contains two integers $n, m$.\n\nThe second line contains $n$ integers, where the $i$-th integer denotes the weight of node $i$.\n\nEach of the next $n - 1$ lines contains two integers $x, y$, indicating that there is an edge between node $x$ and node $y$.\n\nEach of the last $m$ lines contains three integers $u, v, k$, representing one query.", "outputFormat": "Output $m$ lines, each containing a positive integer, which is the answer to each query.", "hint": "Constraints:  \nFor $100\\%$ of the testdata, $1 \\le n, m \\le 10^5$, and node weights are in $[1, 2 ^ {31} - 1]$.\n\nPlease refrain from brute force...\n\nSource: bzoj2588 Spoj10628.\n\nThe testdata for this problem is self-made by Luogu, generated using [CYaRon](https://github.com/luogu-dev/cyaron) in 5 minutes.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Count on a tree", "background": "", "description": "给定一棵 $n$ 个节点的树，每个点有一个权值。有 $m$ 个询问，每次给你 $u,v,k$，你需要回答 $u \\text{ xor last}$ 和 $v$ 这两个节点间第 $k$ 小的点权。  \n\n其中 $\\text{last}$ 是上一个询问的答案，定义其初始为 $0$，即第一个询问的 $u$ 是明文。\n", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行有 $n$ 个整数，其中第 $i$ 个整数表示点 $i$ 的权值。\n\n后面 $n-1$ 行每行两个整数 $x,y$，表示点 $x$ 到点 $y$ 有一条边。\n\n最后 $m$ 行每行三个整数 $u,v,k$，表示一组询问。\n", "outputFormat": "$m$ 行，每行一个正整数表示每个询问的答案。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n,m \\le 10^5$，点权在 $[1, 2 ^ {31} - 1]$ 之间。\n\n暴力自重。。。\n\n来源：bzoj2588 Spoj10628.\n\n本题数据为洛谷自造数据，使用 [CYaRon](https://github.com/luogu-dev/cyaron) 耗时 5 分钟完成数据制作。\n", "locale": "zh-CN"}}}
{"pid": "P2634", "type": "P", "difficulty": 4, "samples": [["5\n1 2 1\n1 3 2\n1 4 1\n2 5 3", "13/25"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "点分治", "集训队互测"], "title": "[国家集训队] 聪聪可可", "background": "", "description": "聪聪和可可是兄弟俩，他们俩经常为了一些琐事打起来，例如家中只剩下最后一根冰棍而两人都想吃、两个人都想玩儿电脑（可是他们家只有一台电脑）……遇到这种问题，一般情况下石头剪刀布就好了，可是他们已经玩儿腻了这种低智商的游戏。\n\n他们的爸爸快被他们的争吵烦死了，所以他发明了一个新游戏：由爸爸在纸上画 $n$ 个“点”，并用 $n-1$ 条“边”把这 $n$ 个“点”恰好连通（其实这就是一棵树）。并且每条“边”上都有一个数。接下来由聪聪和可可分别随机选一个点（当然他们选点时是看不到这棵树的），如果两个点之间所有边上数的和加起来恰好是 $3$ 的倍数，则判聪聪赢，否则可可赢。\n\n聪聪非常爱思考问题，在每次游戏后都会仔细研究这棵树，希望知道对于这张图自己的获胜概率是多少。现请你帮忙求出这个值以验证聪聪的答案是否正确。\n", "inputFormat": "输入的第 $1$ 行包含 $1$ 个正整数 $n$。后面 $n-1$ 行，每行 $3$ 个整数 $x,y,w$，表示 $x$ 号点和 $y$ 号点之间有一条边，上面的数是 $w$。\n", "outputFormat": "以即约分数形式输出这个概率（即 `a/b` 的形式，其中 $a$ 和 $b$ 必须互质。如果概率为 $1$，输出 `1/1`）。\n", "hint": "【样例说明】\n\n$13$ 组点对分别是 $(1,1)$，$(2,2)$，$(2,3)$，$(2,5)$，$(3,2)$，$(3,3)$，$(3,4)$，$(3,5)$，$(4,3)$，$(4,4)$，$(5,2)$，$(5,3)$，$(5,5)$。\n\n【数据规模】\n\n对于 $100\\%$ 的数据，$n\\leq 2 \\times 10^4$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[CTT] Congcong and Keke", "background": "", "description": "Congcong and Keke are brothers who often fight over trivial things, such as when only one ice pop is left at home and they both want it, or they both want to use the computer (but there is only one). Normally they would resolve it with rock-paper-scissors, but they are bored of that simple game.\n\nTheir father, annoyed by their arguments, invented a new game: he draws $n$ “points” on paper and uses $n - 1$ “edges” to connect them so that the $n$ “points” are connected (this is a tree). Each “edge” has a number on it. Then Congcong and Keke each randomly choose one point (they cannot see the tree when choosing). If the sum of the numbers on all edges along the path between the two chosen points is a multiple of $3$, Congcong wins; otherwise, Keke wins.\n\nCongcong likes thinking about problems. After each game, he carefully studies the tree and wants to know his winning probability for this graph. Please help compute this value to verify Congcong’s answer.", "inputFormat": "The first line contains a positive integer $n$. The next $n - 1$ lines each contain $3$ integers $x, y, w$, indicating there is an edge between node $x$ and node $y$ with number $w$.", "outputFormat": "Output the probability as an irreducible fraction in the form `a/b`, where $a$ and $b$ are coprime. If the probability is $1$, output `1/1`.", "hint": "Sample Explanation:\n\nThere are $13$ ordered pairs: $(1, 1)$, $(2, 2)$, $(2, 3)$, $(2, 5)$, $(3, 2)$, $(3, 3)$, $(3, 4)$, $(3, 5)$, $(4, 3)$, $(4, 4)$, $(5, 2)$, $(5, 3)$, $(5, 5)$.\n\nConstraints:\n\nFor $100\\%$ of the testdata, $n \\leq 2 \\times 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[国家集训队] 聪聪可可", "background": "", "description": "聪聪和可可是兄弟俩，他们俩经常为了一些琐事打起来，例如家中只剩下最后一根冰棍而两人都想吃、两个人都想玩儿电脑（可是他们家只有一台电脑）……遇到这种问题，一般情况下石头剪刀布就好了，可是他们已经玩儿腻了这种低智商的游戏。\n\n他们的爸爸快被他们的争吵烦死了，所以他发明了一个新游戏：由爸爸在纸上画 $n$ 个“点”，并用 $n-1$ 条“边”把这 $n$ 个“点”恰好连通（其实这就是一棵树）。并且每条“边”上都有一个数。接下来由聪聪和可可分别随机选一个点（当然他们选点时是看不到这棵树的），如果两个点之间所有边上数的和加起来恰好是 $3$ 的倍数，则判聪聪赢，否则可可赢。\n\n聪聪非常爱思考问题，在每次游戏后都会仔细研究这棵树，希望知道对于这张图自己的获胜概率是多少。现请你帮忙求出这个值以验证聪聪的答案是否正确。\n", "inputFormat": "输入的第 $1$ 行包含 $1$ 个正整数 $n$。后面 $n-1$ 行，每行 $3$ 个整数 $x,y,w$，表示 $x$ 号点和 $y$ 号点之间有一条边，上面的数是 $w$。\n", "outputFormat": "以即约分数形式输出这个概率（即 `a/b` 的形式，其中 $a$ 和 $b$ 必须互质。如果概率为 $1$，输出 `1/1`）。\n", "hint": "【样例说明】\n\n$13$ 组点对分别是 $(1,1)$，$(2,2)$，$(2,3)$，$(2,5)$，$(3,2)$，$(3,3)$，$(3,4)$，$(3,5)$，$(4,3)$，$(4,4)$，$(5,2)$，$(5,3)$，$(5,5)$。\n\n【数据规模】\n\n对于 $100\\%$ 的数据，$n\\leq 2 \\times 10^4$。\n", "locale": "zh-CN"}}}
{"pid": "P2635", "type": "P", "difficulty": 5, "samples": [["1*456??\n111111145678", "matched\n4"], ["1*456\n1111111452", "not matched"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "数学"], "title": "带通配符的字符串匹配", "background": "通配符是一类键盘字符，当我们不知道真正字符或者不想键入完整名字时，常常使用通配符代替一个或多个真正字符。通配符有问号(?)和星号(\\*)等，其中，“?”可以代替一个字符，而“\\*”可以代替零个或多个字符。\n\n现又定义一个通配符“@”，规定在一个字符串中，“@”代替的字符个数是固定的。\n", "description": "用户在使用“@”时，当然希望输入的“@”越少越好。现在给出一个带有“?”“\\*”通配符的字符串和一个原字符串，要求首先判断通配符字符串与原字符串是否匹配，若匹配则求出将原通配符字符串中的“?”“\\*”字符替换为“@”且保证修改后的通配符字符串与原字符串匹配，最少需要多少个通配符“@”。\n", "inputFormat": "输入文件第一行为一个字符串，描述通配符字符串；\n\n第二行也为一个字符串，描述原字符串。\n", "outputFormat": "输出文件第一行为一个字符串，若通配符字符串与原字符串能够匹配则输出“matched”，并在接下来的一行输出一个整数，描述最少需要的通配符“@”的数量；若不匹配则输出“not matched”。\n", "hint": "【样例说明1】\n\n两字符串显然可以匹配，通配符字符串1\\*456??可以替换为1@@@456@，最少需要4个“@”，其中每个“@”代替两个字符，可以证明，此为最优情况。\n\n通配符字符串1\\*456??也可以替换为1@@@@@@456@@，此时每个“@”代替一个字符，需要8个“@”，没有上面的情况优。\n\n\n【样例说明2】\n\n两字符串不可以匹配。\n\n\n【数据范围】\n\n对于100%的数据，字符串的长度均小于3000。\n\n保证原字符串中仅出现字母和数字，通配符字符串中仅出现字母、数字和通配符“?”“\\*”，且保证匹配方式唯一。\n", "locale": "zh-CN", "translations": {"en": {"title": "String Matching with Wildcards", "background": "Wildcards are keyboard characters used to stand in for one or more real characters when we do not know the exact characters or do not want to type the full name. Common wildcards include the question mark (?) and the asterisk (*), where \"?\" stands for exactly one character and \"*\" stands for zero or more characters.\n\nWe further define a wildcard \"@\", with the rule that within a single string, each \"@\" stands for the same fixed number of characters.", "description": "Users naturally want to use as few \"@\" as possible. You are given a wildcard pattern that may contain \"?\" and \"*\" and a target string. First, determine whether the pattern matches the target string. If it matches, replace every \"?\" and \"*\" in the original pattern with \"@\" so that the modified pattern still matches the target string, and find the minimum number of \"@\" required. All \"@\" in the modified pattern must represent the same fixed number of characters.", "inputFormat": "The first line contains a string, the wildcard pattern.\n\nThe second line contains a string, the original target string.", "outputFormat": "Output a single string on the first line: if the pattern matches the target, output \"matched\", and on the next line output an integer giving the minimum number of \"@\" required. If the pattern does not match the target, output \"not matched\".", "hint": "Sample Explanation 1:\nThe two strings clearly match. The wildcard pattern 1*456?? can be replaced by 1@@@456@, requiring 4 \"@\" in total, where each \"@\" replaces two characters. This can be proven optimal.\n\nThe wildcard pattern 1*456?? can also be replaced by 1@@@@@@456@@, where each \"@\" replaces one character, requiring 8 \"@\", which is not better than the previous case.\n\nSample Explanation 2:\nThe two strings do not match.\n\nConstraints:\n- For 100% of the testdata, the length of each string is less than 3000.\n- The original string contains only letters and digits. The wildcard pattern contains only letters, digits, and the wildcards \"?\" and \"*\". The matching, if it exists, is unique.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "带通配符的字符串匹配", "background": "通配符是一类键盘字符，当我们不知道真正字符或者不想键入完整名字时，常常使用通配符代替一个或多个真正字符。通配符有问号(?)和星号(\\*)等，其中，“?”可以代替一个字符，而“\\*”可以代替零个或多个字符。\n\n现又定义一个通配符“@”，规定在一个字符串中，“@”代替的字符个数是固定的。\n", "description": "用户在使用“@”时，当然希望输入的“@”越少越好。现在给出一个带有“?”“\\*”通配符的字符串和一个原字符串，要求首先判断通配符字符串与原字符串是否匹配，若匹配则求出将原通配符字符串中的“?”“\\*”字符替换为“@”且保证修改后的通配符字符串与原字符串匹配，最少需要多少个通配符“@”。\n", "inputFormat": "输入文件第一行为一个字符串，描述通配符字符串；\n\n第二行也为一个字符串，描述原字符串。\n", "outputFormat": "输出文件第一行为一个字符串，若通配符字符串与原字符串能够匹配则输出“matched”，并在接下来的一行输出一个整数，描述最少需要的通配符“@”的数量；若不匹配则输出“not matched”。\n", "hint": "【样例说明1】\n\n两字符串显然可以匹配，通配符字符串1\\*456??可以替换为1@@@456@，最少需要4个“@”，其中每个“@”代替两个字符，可以证明，此为最优情况。\n\n通配符字符串1\\*456??也可以替换为1@@@@@@456@@，此时每个“@”代替一个字符，需要8个“@”，没有上面的情况优。\n\n\n【样例说明2】\n\n两字符串不可以匹配。\n\n\n【数据范围】\n\n对于100%的数据，字符串的长度均小于3000。\n\n保证原字符串中仅出现字母和数字，通配符字符串中仅出现字母、数字和通配符“?”“\\*”，且保证匹配方式唯一。\n", "locale": "zh-CN"}}}
{"pid": "P2636", "type": "P", "difficulty": 3, "samples": [["2\nYSLTRIQXSHTQTR\n1 2\n3", "FULLSPEEDAHEAD"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串"], "title": "密码破解者", "background": "1941 年 12 月 7 日凌晨，珍珠港驻守美军通信员截获了一份日军电报。早上 8 时日军的正式进攻就会展开，为了减少太平洋战场伤亡，你被指派去协助破解密文。情报部门已得知了密文加密的层数和每层加密的方法。由于时间紧急，你只剩 1 秒的时间来破解日军的密文。\n", "description": "据情报得知日军共有 $3$ 种加密方式：\n\n一、栅栏密码：\n\n所谓栅栏密码，就是把要加密的明文分成 $L$ 个一组，然后把每组的第 $1$ 个字连起来，形成一段无规律的话。一般比较常见的是 $2$ 栏的棚栏密码。 \n\n比如明文：`THERE IS A CIPHER`  \n去掉空格后变为：`THEREISACIPHER`  \n两个一组，得到：`TH ER EI SA CI PH ER`  \n先取出第一个字母：`TEESCPE`  \n再取出第二个字母：`HRIAIHR`  \n连在一起就是：`TEESCPEHRIAIHR`  \n\n这样就得到我们需要的密码了。  \n\n但也可能有更多的栏数。\n\n注：若明文长度不能整除栏数，则分组后剩下的单独为一组，如：\n\n`THERE IS A CIPHER`，$3$ 栏加密分组为：`THE REI SAC IPH ER`\n\n先后取出第一二三个字母(最后一组只能取前两个)，加密后为: `TRSIE HEAPR EICH`（去掉空格）。\n\n二、维吉尼亚(Vigenère)密码：\n\n维吉尼亚密码首先应用了“密钥”的思想，其在密码届具有十分重要的意义。\n\n在密码学中，我们称需要加密的信息为明文，用 $M$ 表示；称加密后的信息为密文，用 $C$ 表示；而密钥是一种参数，是将明文转换为密文或将密文转换为明文的算法中输入的数据，记为 $k$。在 Vigenère 密码中，密钥 $k$ 是一个字母串，$k=k_1k_2\\cdots k_n$。当明文 $M=m_1m_2\\cdots m_n$ 时，得到的密文 $C=c_1c_2\\cdots c_n$，其中 $c_i=m_i\\oplus k_i$，运算 $\\oplus$ 的规则如下表所示：\n\nA B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n\nA -A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n\nB -B C D E F G H I J K L M N O P Q R S T U V W X Y Z A\n\nC -C D E F G H I J K L M N O P Q R S T U V W X Y Z A B\n\nD -D E F G H I J K L M N O P Q R S T U V W X Y Z A B C\n\nE -E F G H I J K L M N O P Q R S T U V W X Y Z A B C D\n\nF -F G H I J K L M N O P Q R S T U V W X Y Z A B C D E\n\nG -G H I J K L M N O P Q R S T U V W X Y Z A B C D E F\n\nH -H I J K L M N O P Q R S T U V W X Y Z A B C D E F G\n\nI -I J K L M N O P Q R S T U V W X Y Z A B C D E F G H\n\nJ -J K L M N O P Q R S T U V W X Y Z A B C D E F G H I\n\nK -K L M N O P Q R S T U V W X Y Z A B C D E F G H I J\n\nL -L M N O P Q R S T U V W X Y Z A B C D E F G H I J K\n\nM -M N O P Q R S T U V W X Y Z A B C D E F G H I J K L\n\nN -N O P Q R S T U V W X Y Z A B C D E F G H I J K L M\n\nO -O P Q R S T U V W X Y Z A B C D E F G H I J K L M N\n\nP -P Q R S T U V W X Y Z A B C D E F G H I J K L M N O\n\nQ -Q R S T U V W X Y Z A B C D E F G H I J K L M N O P\n\nR -R S T U V W X Y Z A B C D E F G H I J K L M N O P Q\n\nS -S T U V W X Y Z A B C D E F G H I J K L M N O P Q R\n\nT -T U V W X Y Z A B C D E F G H I J K L M N O P Q R S\n\nU -U V W X Y Z A B C D E F G H I J K L M N O P Q R S T\n\nV -V W X Y Z A B C D E F G H I J K L M N O P Q R S T U\n\nW -W X Y Z A B C D E F G H I J K L M N O P Q R S T U V\n\nX -X Y Z A B C D E F G H I J K L M N O P Q R S T U V W\n\nY -Y Z A B C D E F G H I J K L M N O P Q R S T U V W X\n\nZ -Z A B C D E F G H I J K L M N O P Q R S T U V W X Y\n\n\nVigenère 加密在操作时需要注意： \n\n当明文 M 的长度大于密钥 k 的长度时，将密钥 k 重复使用。 \n\n例如，明文 M=Helloworld，密钥 k=abc 时，密文 C=Hfnlpyosnd。 \n\n\n三、QWE键盘码：\n\n随着键盘普及，也出现了相应的键盘码。\n\n\n这是一个常见的键盘,在左边字母区有三行字母分别为：\n\nQWERTYUIOP\n\nASDFGHJKL\n\nZXCVBNM\n\n从第一排第一列开始分别用Q替代A，W替代B……M替代Z以此类推。\n\n如 CODING 加密后即为 EGROFU.\n\n这对于现在来说算是简单的加密方法，但对于键盘不普及的二战时期却是一大难题。\n", "inputFormat": "输入第一行为一个正整数N 表示截获的密文共用了N重密码加密。\n\n第二行为一个字符串S表示加密后的密文。\n\n以下3-N+2行共N行每行开头一个正整数K(1<=K<=3)表示对应的加密方式。\n\n给出的加密方式按顺序给出，即给出的第I重加密为实际加密过程的第I重(1<=I<=N)。\n\n若K=1则表示用栅栏密码加密，之后一个正整数L表示加密所用栏数。\n\n若K=2则表示用维吉尼亚码加密，之后一个字符串T表示密钥。\n\n若K=3则表示用QWE键盘码加密。\n", "outputFormat": "共一行。一个字符串，表示破解N重加密后的明文。\n", "hint": "n<=1000\n", "locale": "zh-CN", "translations": {"en": {"title": "Codebreaker", "background": "In the early morning of December 7, 1941, a U.S. Army signalman stationed at Pearl Harbor intercepted a Japanese telegram. The formal attack would begin at 8 a.m. To reduce casualties in the Pacific theater, you have been assigned to help break the ciphertext. The intelligence department already knows the number of encryption layers and the method used in each layer. Due to the urgency, you have only 1 second to crack the Japanese ciphertext.", "description": "According to intelligence, the Japanese use $3$ kinds of encryption methods:\n\n1. Rail Fence Cipher:\n\nThe so‑called rail fence cipher divides the plaintext into groups of $L$ characters, then concatenates the first character of each group, followed by the second character of each group, and so on, forming a seemingly irregular string. The most common case is the $2$‑rail rail fence cipher.\n\nFor example, plaintext: `THERE IS A CIPHER`  \nAfter removing spaces: `THEREISACIPHER`  \nGroup by two: `TH ER EI SA CI PH ER`  \nTake the first character of each group: `TEESCPE`  \nThen the second character of each group: `HRIAIHR`  \nConcatenate them: `TEESCPEHRIAIHR`.\n\nThis yields the ciphertext we need.\n\nThere may also be more rails.\n\nNote: If the plaintext length is not divisible by the number of rails, the leftover characters form a shorter group on their own. For example:\n\nFor `THERE IS A CIPHER`, the $3$‑rail grouping is: `THE REI SAC IPH ER`.\n\nTake the first, second, and third characters in order (the last group only has the first two). The encrypted text is: `TRSIE HEAPR EICH` (remove spaces).\n\n2. Vigenère Cipher:\n\nThe Vigenère cipher first introduced the idea of a “key,” which is of great significance in cryptography.\n\nIn cryptography, the information to be encrypted is called the plaintext, denoted by $M$; the encrypted information is called the ciphertext, denoted by $C$; and the key is a parameter, i.e., the data input to the algorithm that transforms plaintext into ciphertext or ciphertext into plaintext, denoted by $k$. In the Vigenère cipher, the key $k$ is a string of letters, $k = k_1 k_2 \\cdots k_n$. When the plaintext is $M = m_1 m_2 \\cdots m_n$, the resulting ciphertext is $C = c_1 c_2 \\cdots c_n$, where $c_i = m_i \\oplus k_i$. The operation $\\oplus$ follows the table below:\n\nA B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n\nA -A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n\nB -B C D E F G H I J K L M N O P Q R S T U V W X Y Z A\n\nC -C D E F G H I J K L M N O P Q R S T U V W X Y Z A B\n\nD -D E F G H I J K L M N O P Q R S T U V W X Y Z A B C\n\nE -E F G H I J K L M N O P Q R S T U V W X Y Z A B C D\n\nF -F G H I J K L M N O P Q R S T U V W X Y Z A B C D E\n\nG -G H I J K L M N O P Q R S T U V W X Y Z A B C D E F\n\nH -H I J K L M N O P Q R S T U V W X Y Z A B C D E F G\n\nI -I J K L M N O P Q R S T U V W X Y Z A B C D E F G H\n\nJ -J K L M N O P Q R S T U V W X Y Z A B C D E F G H I\n\nK -K L M N O P Q R S T U V W X Y Z A B C D E F G H I J\n\nL -L M N O P Q R S T U V W X Y Z A B C D E F G H I J K\n\nM -M N O P Q R S T U V W X Y Z A B C D E F G H I J K L\n\nN -N O P Q R S T U V W X Y Z A B C D E F G H I J K L M\n\nO -O P Q R S T U V W X Y Z A B C D E F G H I J K L M N\n\nP -P Q R S T U V W X Y Z A B C D E F G H I J K L M N O\n\nQ -Q R S T U V W X Y Z A B C D E F G H I J K L M N O P\n\nR -R S T U V W X Y Z A B C D E F G H I J K L M N O P Q\n\nS -S T U V W X Y Z A B C D E F G H I J K L M N O P Q R\n\nT -T U V W X Y Z A B C D E F G H I J K L M N O P Q R S\n\nU -U V W X Y Z A B C D E F G H I J K L M N O P Q R S T\n\nV -V W X Y Z A B C D E F G H I J K L M N O P Q R S T U\n\nW -W X Y Z A B C D E F G H I J K L M N O P Q R S T U V\n\nX -X Y Z A B C D E F G H I J K L M N O P Q R S T U V W\n\nY -Y Z A B C D E F G H I J K L M N O P Q R S T U V W X\n\nZ -Z A B C D E F G H I J K L M N O P Q R S T U V W X Y\n\nNotes for operating Vigenère encryption:\n\nWhen the length of plaintext $M$ is greater than the length of key $k$, repeat the key $k$ cyclically.\n\nFor example, plaintext $M = Helloworld$, key $k = abc$, ciphertext $C = Hfnlpyosnd$.\n\n3. QWE Keyboard Code:\n\nWith the popularization of keyboards, corresponding keyboard codes also appeared.\n\nThis is a common keyboard. On the left letter area, there are three rows of letters:\n\nQWERTYUIOP\n\nASDFGHJKL\n\nZXCVBNM\n\nStarting from the first row and the first column, replace A with Q, B with W, …, Z with M, and so on.\n\nFor example, CODING is encrypted as EGROFU.\n\nThis is a simple encryption method today, but during World War II, when keyboards were not widespread, it was a big challenge.", "inputFormat": "- The first line contains a positive integer $N$, the number of encryption layers applied to the intercepted ciphertext.\n- The second line contains a string $S$, the ciphertext after encryption.\n- The next $N$ lines (i.e., lines $3$ to $N+2$) each begin with a positive integer $K$ with $1 \\le K \\le 3$, indicating the encryption method used for that layer.\n- The methods are listed in order: the $I$‑th given method is the actual $I$‑th encryption layer in the process, where $1 \\le I \\le N$.\n- If $K = 1$, the rail fence cipher was used; an integer $L$ follows, the number of rails used for encryption.\n- If $K = 2$, the Vigenère cipher was used; a string $T$ follows, which is the key.\n- If $K = 3$, the QWE keyboard code was used.", "outputFormat": "Output one line: a string representing the plaintext after decrypting all $N$ layers of encryption.", "hint": "$N \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "密码破解者", "background": "1941 年 12 月 7 日凌晨，珍珠港驻守美军通信员截获了一份日军电报。早上 8 时日军的正式进攻就会展开，为了减少太平洋战场伤亡，你被指派去协助破解密文。情报部门已得知了密文加密的层数和每层加密的方法。由于时间紧急，你只剩 1 秒的时间来破解日军的密文。\n", "description": "据情报得知日军共有 $3$ 种加密方式：\n\n一、栅栏密码：\n\n所谓栅栏密码，就是把要加密的明文分成 $L$ 个一组，然后把每组的第 $1$ 个字连起来，形成一段无规律的话。一般比较常见的是 $2$ 栏的棚栏密码。 \n\n比如明文：`THERE IS A CIPHER`  \n去掉空格后变为：`THEREISACIPHER`  \n两个一组，得到：`TH ER EI SA CI PH ER`  \n先取出第一个字母：`TEESCPE`  \n再取出第二个字母：`HRIAIHR`  \n连在一起就是：`TEESCPEHRIAIHR`  \n\n这样就得到我们需要的密码了。  \n\n但也可能有更多的栏数。\n\n注：若明文长度不能整除栏数，则分组后剩下的单独为一组，如：\n\n`THERE IS A CIPHER`，$3$ 栏加密分组为：`THE REI SAC IPH ER`\n\n先后取出第一二三个字母(最后一组只能取前两个)，加密后为: `TRSIE HEAPR EICH`（去掉空格）。\n\n二、维吉尼亚(Vigenère)密码：\n\n维吉尼亚密码首先应用了“密钥”的思想，其在密码届具有十分重要的意义。\n\n在密码学中，我们称需要加密的信息为明文，用 $M$ 表示；称加密后的信息为密文，用 $C$ 表示；而密钥是一种参数，是将明文转换为密文或将密文转换为明文的算法中输入的数据，记为 $k$。在 Vigenère 密码中，密钥 $k$ 是一个字母串，$k=k_1k_2\\cdots k_n$。当明文 $M=m_1m_2\\cdots m_n$ 时，得到的密文 $C=c_1c_2\\cdots c_n$，其中 $c_i=m_i\\oplus k_i$，运算 $\\oplus$ 的规则如下表所示：\n\nA B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n\nA -A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n\nB -B C D E F G H I J K L M N O P Q R S T U V W X Y Z A\n\nC -C D E F G H I J K L M N O P Q R S T U V W X Y Z A B\n\nD -D E F G H I J K L M N O P Q R S T U V W X Y Z A B C\n\nE -E F G H I J K L M N O P Q R S T U V W X Y Z A B C D\n\nF -F G H I J K L M N O P Q R S T U V W X Y Z A B C D E\n\nG -G H I J K L M N O P Q R S T U V W X Y Z A B C D E F\n\nH -H I J K L M N O P Q R S T U V W X Y Z A B C D E F G\n\nI -I J K L M N O P Q R S T U V W X Y Z A B C D E F G H\n\nJ -J K L M N O P Q R S T U V W X Y Z A B C D E F G H I\n\nK -K L M N O P Q R S T U V W X Y Z A B C D E F G H I J\n\nL -L M N O P Q R S T U V W X Y Z A B C D E F G H I J K\n\nM -M N O P Q R S T U V W X Y Z A B C D E F G H I J K L\n\nN -N O P Q R S T U V W X Y Z A B C D E F G H I J K L M\n\nO -O P Q R S T U V W X Y Z A B C D E F G H I J K L M N\n\nP -P Q R S T U V W X Y Z A B C D E F G H I J K L M N O\n\nQ -Q R S T U V W X Y Z A B C D E F G H I J K L M N O P\n\nR -R S T U V W X Y Z A B C D E F G H I J K L M N O P Q\n\nS -S T U V W X Y Z A B C D E F G H I J K L M N O P Q R\n\nT -T U V W X Y Z A B C D E F G H I J K L M N O P Q R S\n\nU -U V W X Y Z A B C D E F G H I J K L M N O P Q R S T\n\nV -V W X Y Z A B C D E F G H I J K L M N O P Q R S T U\n\nW -W X Y Z A B C D E F G H I J K L M N O P Q R S T U V\n\nX -X Y Z A B C D E F G H I J K L M N O P Q R S T U V W\n\nY -Y Z A B C D E F G H I J K L M N O P Q R S T U V W X\n\nZ -Z A B C D E F G H I J K L M N O P Q R S T U V W X Y\n\n\nVigenère 加密在操作时需要注意： \n\n当明文 M 的长度大于密钥 k 的长度时，将密钥 k 重复使用。 \n\n例如，明文 M=Helloworld，密钥 k=abc 时，密文 C=Hfnlpyosnd。 \n\n\n三、QWE键盘码：\n\n随着键盘普及，也出现了相应的键盘码。\n\n\n这是一个常见的键盘,在左边字母区有三行字母分别为：\n\nQWERTYUIOP\n\nASDFGHJKL\n\nZXCVBNM\n\n从第一排第一列开始分别用Q替代A，W替代B……M替代Z以此类推。\n\n如 CODING 加密后即为 EGROFU.\n\n这对于现在来说算是简单的加密方法，但对于键盘不普及的二战时期却是一大难题。\n", "inputFormat": "输入第一行为一个正整数N 表示截获的密文共用了N重密码加密。\n\n第二行为一个字符串S表示加密后的密文。\n\n以下3-N+2行共N行每行开头一个正整数K(1<=K<=3)表示对应的加密方式。\n\n给出的加密方式按顺序给出，即给出的第I重加密为实际加密过程的第I重(1<=I<=N)。\n\n若K=1则表示用栅栏密码加密，之后一个正整数L表示加密所用栏数。\n\n若K=2则表示用维吉尼亚码加密，之后一个字符串T表示密钥。\n\n若K=3则表示用QWE键盘码加密。\n", "outputFormat": "共一行。一个字符串，表示破解N重加密后的明文。\n", "hint": "n<=1000\n", "locale": "zh-CN"}}}
{"pid": "P2637", "type": "P", "difficulty": 1, "samples": [["5 4\n2\n8\n10\n7", "7 21"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "2008", "USACO", "枚举"], "title": "[USACO08NOV] 第一次，第二次，成交！Going Once, Going Twice, Gone! B", "background": null, "description": "因为奶牛们的节食运动给 FJ 余下了一大批干草无法处理，所以他准备要开一个拍卖会去出售他的干草。\n\n他有 $n$ 批干草。他的客户有 $m$ 个，都是和他一样的农夫。第 $i$ 名农夫会告诉 FJ 他会为 FJ 的每批干草付 $p_i$ 的钱。每个农夫都想买（也只想买）FJ 的一批草料。\n\n为了确保农夫们不会互相嫉妒，所以 FJ 决定要以一个固定的价格出售他的草料。每一个出价大于等于 FJ 的要价的农夫将会买到草料。\n\n请你帮助 FJ 找出能让他卖出最多的钱的最低的单批草料的售价。", "inputFormat": "第一行：两个被空格隔开的整数 $n$ 和 $m$。\n\n第二行到第 $m+1$ 行：第 $i+1$ 行只包含一个整数 $p_i$。", "outputFormat": "共一行，包含由空格隔开的两个整数：FJ 能出的每批草料的最低价格，以及他能赚到的最多的钱。", "hint": "### 样例解释\nFJ 有 $5$ 批草料，$4$ 个农夫想要购买。他们出价分别为：每批草料为 $2$，$8$，$10$ 和 $7$。\n\nFJ 应该把价格设定为 $7$，这样会有 $3$ 个农夫会付钱买草料，FJ 自己会挣到 $21$ 的钱。\n\n### 数据规模与约定\n对于 $100\\%$ 的数据，$1\\leq m, n\\leq 1000$，$1\\leq p_i\\leq 1,000,000$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO08NOV] Going Once, Going Twice, Gone! B", "background": "", "description": "Because of the cows’ dieting campaign, FJ has a large amount of leftover hay he cannot use, so he plans to hold an auction to sell it.\n\nHe has $n$ batches of hay. He has $m$ customers, all of whom are farmers like him. Farmer $i$ says he will pay $p_i$ for each batch of FJ’s hay. Every farmer wants to buy exactly one batch (and only one).\n\nTo make sure the farmers do not envy each other, FJ decides to sell at a single fixed price. Every farmer whose bid is greater than or equal to FJ’s asking price will buy a batch.\n\nPlease help FJ find the lowest per-batch price that earns him the maximum total revenue.", "inputFormat": "- The first line contains two integers $n$ and $m$ separated by a space.\n- Lines $2$ through $m+1$: line $i+1$ contains a single integer $p_i$.", "outputFormat": "Output one line with two space-separated integers: the lowest per-batch price FJ should set, and the maximum total revenue he can earn.", "hint": "Sample Explanation  \nFJ has $5$ batches of hay, and $4$ farmers want to buy. Their bids per batch are $2$, $8$, $10$, and $7$.  \nFJ should set the price to $7$. Then $3$ farmers will buy, and FJ will earn $21$.\n\nConstraints  \nFor $100\\%$ of the testdata, $1 \\leq m, n \\leq 1000$, $1 \\leq p_i \\leq 1,000,000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO08NOV] 第一次，第二次，成交！Going Once, Going Twice, Gone! B", "background": null, "description": "因为奶牛们的节食运动给 FJ 余下了一大批干草无法处理，所以他准备要开一个拍卖会去出售他的干草。\n\n他有 $n$ 批干草。他的客户有 $m$ 个，都是和他一样的农夫。第 $i$ 名农夫会告诉 FJ 他会为 FJ 的每批干草付 $p_i$ 的钱。每个农夫都想买（也只想买）FJ 的一批草料。\n\n为了确保农夫们不会互相嫉妒，所以 FJ 决定要以一个固定的价格出售他的草料。每一个出价大于等于 FJ 的要价的农夫将会买到草料。\n\n请你帮助 FJ 找出能让他卖出最多的钱的最低的单批草料的售价。", "inputFormat": "第一行：两个被空格隔开的整数 $n$ 和 $m$。\n\n第二行到第 $m+1$ 行：第 $i+1$ 行只包含一个整数 $p_i$。", "outputFormat": "共一行，包含由空格隔开的两个整数：FJ 能出的每批草料的最低价格，以及他能赚到的最多的钱。", "hint": "### 样例解释\nFJ 有 $5$ 批草料，$4$ 个农夫想要购买。他们出价分别为：每批草料为 $2$，$8$，$10$ 和 $7$。\n\nFJ 应该把价格设定为 $7$，这样会有 $3$ 个农夫会付钱买草料，FJ 自己会挣到 $21$ 的钱。\n\n### 数据规模与约定\n对于 $100\\%$ 的数据，$1\\leq m, n\\leq 1000$，$1\\leq p_i\\leq 1,000,000$。", "locale": "zh-CN"}}}
{"pid": "P2638", "type": "P", "difficulty": 4, "samples": [["2 1 1", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "数学"], "title": "安全系统", "background": null, "description": "特斯拉公司的六位密码被轻松破解后，引发了人们对电动车的安全性能的怀疑。李华听闻后，自己设计了一套密码：\n\n- 假设安全系统中有 $n$ 个储存区，每个储存区最多能存储存 $2$ 种种类不同的信号（可以不储存任何信号）。有 $0$ 和 $1$ 这两种信号，其中 $0$ 有 $a$ 个，$1$ 有 $b$ 个，单独一个 $0$ 或 $1$ 算一个信号。现要将这些信号储存在储存区中，$0$ 和 $1$ **可以不用全部储存**，一个储存区可以存放任意多个 $0$ 和任意多个 $1$。一种不同的储存方案经过李华处理后就将是一串不同的密码。\n\n现在给出 $n,a,b$，求可能的不同储存方案的个数。", "inputFormat": "第一行：共 $3$ 个整数，$n,a,b$。", "outputFormat": "第一行：一个整数，表示方案个数。", "hint": "所有 $9$ 种方案如下：\n\n| 储存区 $1$ | 储存区 $2$ |\n| :----------: | :----------: |\n| $\\verb!NULL!$ | $\\verb!NULL!$ |\n| $0$ | $\\verb!NULL!$ |\n| $1$ | $\\verb!NULL!$ |\n| $\\verb!NULL!$ | $0$ |\n| $\\verb!NULL!$ | $1$ |\n| $0,1$ | $\\verb!NULL!$ |\n| $\\verb!NULL!$ | $0,1$ |\n| $1$ | $0$ |\n| $0$ | $1$ |\n\n对于全部数据，$0 \\le a,b \\le 50$，$1 \\le n \\le 50$ 且 $n+a\\le 50$，$n+b\\le 50$。\n\n---\n\n$\\text{upd 2022.10.22}$：新增加一组 Hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "Security System", "background": "", "description": "After Tesla’s six-digit passcode was easily cracked, people began to doubt the security of electric vehicles. Upon hearing this, Li Hua designed his own passcode system:\n\n- Suppose the security system has $n$ storage units. Each storage unit can hold up to 2 different types of signals (it may also hold none). There are two types of signals, $0$ and $1$, with $a$ copies of $0$ and $b$ copies of $1$ available. A single $0$ or $1$ counts as one signal. We need to store these signals in the storage units. The $0$ and $1$ signals do not have to be all stored; a storage unit may contain any number of $0$’s and any number of $1$’s. Every distinct storage plan, after Li Hua’s processing, will correspond to a distinct passcode.\n\nGiven $n,a,b$, find the number of possible distinct storage plans.", "inputFormat": "The first line contains 3 integers, $n,a,b$.", "outputFormat": "The first line contains an integer, the number of plans.", "hint": "All 9 plans are as follows:\n\n| Storage unit $1$ | Storage unit $2$ |\n| :----------: | :----------: |\n| $\\verb!NULL!$ | $\\verb!NULL!$ |\n| $0$ | $\\verb!NULL!$ |\n| $1$ | $\\verb!NULL!$ |\n| $\\verb!NULL!$ | $0$ |\n| $\\verb!NULL!$ | $1$ |\n| $0,1$ | $\\verb!NULL!$ |\n| $\\verb!NULL!$ | $0,1$ |\n| $1$ | $0$ |\n| $0$ | $1$ |\n\nConstraints: For all testdata, $a,b \\le 50$, $n+a \\le 50$, $n+b \\le 50$.\n\n---\n\n$\\text{upd 2022.10.22}$: A new set of Hack testdata was added.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "安全系统", "background": null, "description": "特斯拉公司的六位密码被轻松破解后，引发了人们对电动车的安全性能的怀疑。李华听闻后，自己设计了一套密码：\n\n- 假设安全系统中有 $n$ 个储存区，每个储存区最多能存储存 $2$ 种种类不同的信号（可以不储存任何信号）。有 $0$ 和 $1$ 这两种信号，其中 $0$ 有 $a$ 个，$1$ 有 $b$ 个，单独一个 $0$ 或 $1$ 算一个信号。现要将这些信号储存在储存区中，$0$ 和 $1$ **可以不用全部储存**，一个储存区可以存放任意多个 $0$ 和任意多个 $1$。一种不同的储存方案经过李华处理后就将是一串不同的密码。\n\n现在给出 $n,a,b$，求可能的不同储存方案的个数。", "inputFormat": "第一行：共 $3$ 个整数，$n,a,b$。", "outputFormat": "第一行：一个整数，表示方案个数。", "hint": "所有 $9$ 种方案如下：\n\n| 储存区 $1$ | 储存区 $2$ |\n| :----------: | :----------: |\n| $\\verb!NULL!$ | $\\verb!NULL!$ |\n| $0$ | $\\verb!NULL!$ |\n| $1$ | $\\verb!NULL!$ |\n| $\\verb!NULL!$ | $0$ |\n| $\\verb!NULL!$ | $1$ |\n| $0,1$ | $\\verb!NULL!$ |\n| $\\verb!NULL!$ | $0,1$ |\n| $1$ | $0$ |\n| $0$ | $1$ |\n\n对于全部数据，$0 \\le a,b \\le 50$，$1 \\le n \\le 50$ 且 $n+a\\le 50$，$n+b\\le 50$。\n\n---\n\n$\\text{upd 2022.10.22}$：新增加一组 Hack 数据。", "locale": "zh-CN"}}}
{"pid": "P2639", "type": "P", "difficulty": 2, "samples": [["56 4\n15\n19\n20\n21", "56"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2009", "USACO", "背包 DP"], "title": "[USACO09OCT] Bessie's Weight Problem G", "background": null, "description": "Bessie 像她的诸多姊妹一样，因为从 Farmer John 的草地吃了太多美味的草而长出了太多的赘肉。所以 FJ 将她置于一个及其严格的节食计划之中。她每天不能吃多过 $H (5 \\le H \\le 45,000)$ 公斤的干草。 Bessie 只能吃一整捆干草；当她开始吃一捆干草的之后就再也停不下来了。她有一个完整的$N (1 \\le N \\le 500)$ 捆可以给她当作晚餐的干草的清单。她自然想要尽量吃到更多的干草。很自然地，每捆干草只能被吃一次（即使在列表中相同的重量可能出现 $2$ 次，但是这表示的是两捆干草，其中每捆干草最多只能被吃掉一次）。 给定一个列表表示每捆干草的重量 $S_i (1 \\le S_i \\le H)$ , 求 Bessie 不超过节食的限制的前提下可以吃掉多少干草（注意一旦她开始吃一捆干草就会把那一捆干草全部吃完）。", "inputFormat": "第一行有两个由空格隔开的整数 $H$ 和 $N$。\n\n第 $2$ 到第 $N+1$ 行，第 $i+1$ 行是一个单独的整数，表示第 $i$ 捆干草的重量 $S_i$。", "outputFormat": "第一行一个单独的整数表示 Bessie 在限制范围内最多可以吃多少公斤的干草。", "hint": "#### 输入说明\n\n有四捆草，重量分别是 $15,19,20$ 和 $21$。Bessie 在 $56$ 公斤的限制范围内想要吃多少就可以吃多少。\n\n\n#### 输出说明\n\nBessie 可以吃 $3$ 捆干草（重量分别为 $15, 20, 21$）。恰好达到她的 $56$ 公斤的限制。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09OCT] Bessie's Weight Problem G", "background": "", "description": "Like many of her sisters, Bessie has put on too much weight from eating too much delicious grass from Farmer John’s pasture. So Farmer John has put her on a very strict diet. Each day, she may eat no more than $H (5 \\le H \\le 45,000)$ kilograms of hay. Bessie can eat only whole hay bales; once she starts a bale, she cannot stop until she finishes it. She has a complete list of $N (1 \\le N \\le 500)$ bales that can be served to her for dinner. Naturally, she wants to eat as much hay as possible. Of course, each bale can be eaten at most once (even if the same weight appears $2$ times in the list, that refers to two distinct bales, and each bale can be eaten at most once). Given a list of bale weights $S_i (1 \\le S_i \\le H)$, determine the maximum total amount of hay Bessie can eat without exceeding the diet limit (note that once she starts a bale, she must finish that entire bale).", "inputFormat": "The first line contains two space-separated integers $H$ and $N$.\n\nLines $2$ through $N+1$, where line $i+1$ contains a single integer, give the weight $S_i$ of the $i$-th bale.", "outputFormat": "Output a single integer, the maximum total kilograms of hay Bessie can eat without exceeding the limit.", "hint": "#### Input Explanation\n\nThere are four bales with weights $15, 19, 20$, and $21$. Bessie wants to eat as much as she can within the $56$ kilogram limit.\n\n#### Output Explanation\n\nBessie can eat $3$ bales (with weights $15, 20, 21$), reaching exactly her $56$ kilogram limit.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09OCT] Bessie's Weight Problem G", "background": null, "description": "Bessie 像她的诸多姊妹一样，因为从 Farmer John 的草地吃了太多美味的草而长出了太多的赘肉。所以 FJ 将她置于一个及其严格的节食计划之中。她每天不能吃多过 $H (5 \\le H \\le 45,000)$ 公斤的干草。 Bessie 只能吃一整捆干草；当她开始吃一捆干草的之后就再也停不下来了。她有一个完整的$N (1 \\le N \\le 500)$ 捆可以给她当作晚餐的干草的清单。她自然想要尽量吃到更多的干草。很自然地，每捆干草只能被吃一次（即使在列表中相同的重量可能出现 $2$ 次，但是这表示的是两捆干草，其中每捆干草最多只能被吃掉一次）。 给定一个列表表示每捆干草的重量 $S_i (1 \\le S_i \\le H)$ , 求 Bessie 不超过节食的限制的前提下可以吃掉多少干草（注意一旦她开始吃一捆干草就会把那一捆干草全部吃完）。", "inputFormat": "第一行有两个由空格隔开的整数 $H$ 和 $N$。\n\n第 $2$ 到第 $N+1$ 行，第 $i+1$ 行是一个单独的整数，表示第 $i$ 捆干草的重量 $S_i$。", "outputFormat": "第一行一个单独的整数表示 Bessie 在限制范围内最多可以吃多少公斤的干草。", "hint": "#### 输入说明\n\n有四捆草，重量分别是 $15,19,20$ 和 $21$。Bessie 在 $56$ 公斤的限制范围内想要吃多少就可以吃多少。\n\n\n#### 输出说明\n\nBessie 可以吃 $3$ 捆干草（重量分别为 $15, 20, 21$）。恰好达到她的 $56$ 公斤的限制。", "locale": "zh-CN"}}}
