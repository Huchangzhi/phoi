{"pid": "P5146", "type": "P", "difficulty": 2, "samples": [["10\n1\n3\n4\n6\n7\n9\n10\n1\n2\n9", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["枚举"], "title": "最大差值", "background": "", "description": "HKE 最近热衷于研究序列，有一次他发现了一个有趣的问题：\n\n对于一个序列 $A_1,A_2,\\cdots,A_n$，找出两个数 $i,j$（$1\\le i<j\\le n$），使得 $A_j-A_i$ 最大。\n\n现在给出这个序列，请找出 $A_j-A_i$ 的最大值。", "inputFormat": "第一行为一个正整数 $n$。  \n\n接下来 $n$ 行，每行一个整数，第 $(i + 1)$ 行的整数为 $A_i$。", "outputFormat": "一行，为 $A_j-A_i$ 的最大值。\n", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，$n\\le1000$；\n- 对于 $70\\%$ 的数据，$n\\le10^5$；\n- 对于 $100\\%$ 的数据：$2\\le n\\le 10^6$，$A_i$ 在 int 范围内。", "locale": "zh-CN", "translations": {"en": {"title": "Maximum Difference", "background": "", "description": "HKE has recently been keen on studying sequences, and once he discovered an interesting problem:\n\nFor a sequence $A_1,A_2,\\cdots,A_n$, find two indices $i, j$ ($1\\le i<j\\le n$) such that $A_j-A_i$ is maximized.\n\nGiven this sequence, please find the maximum value of $A_j-A_i$.", "inputFormat": "The first line contains a positive integer $n$.\nThe next $n$ lines each contain one integer. The integer on the $(i + 1)$-th line is $A_i$.", "outputFormat": "One line, the maximum value of $A_j-A_i$.", "hint": "#### Constraints\n\n- For $30\\%$ of the testdata, $n\\le1000$.\n- For $70\\%$ of the testdata, $n\\le10^5$.\n- For $100\\%$ of the testdata: $2\\le n\\le 10^6$, and $A_i$ is within the int range.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最大差值", "background": "", "description": "HKE 最近热衷于研究序列，有一次他发现了一个有趣的问题：\n\n对于一个序列 $A_1,A_2,\\cdots,A_n$，找出两个数 $i,j$（$1\\le i<j\\le n$），使得 $A_j-A_i$ 最大。\n\n现在给出这个序列，请找出 $A_j-A_i$ 的最大值。", "inputFormat": "第一行为一个正整数 $n$。  \n\n接下来 $n$ 行，每行一个整数，第 $(i + 1)$ 行的整数为 $A_i$。", "outputFormat": "一行，为 $A_j-A_i$ 的最大值。\n", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，$n\\le1000$；\n- 对于 $70\\%$ 的数据，$n\\le10^5$；\n- 对于 $100\\%$ 的数据：$2\\le n\\le 10^6$，$A_i$ 在 int 范围内。", "locale": "zh-CN"}}}
{"pid": "P5147", "type": "P", "difficulty": 5, "samples": [["2", "2.00000"], ["3", "2.50000"], ["100000", "13.09014"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "递推"], "title": "随机数生成器", "background": "", "description": "HKE最近编写了一个函数 $\\text{rand}(l,r)$，其中 $l,r$ 为正整数且 $l \\le r$。这个函数会等概率返回区间 $[l,r]$ 中任意一个正整数。然后，他又编写了一个函数：\n\n```cpp\nint work(int x){\n    if(x==1) return 0;\n    else return work(rand(1,x))+1;\n}\n```\n这段代码用pascal写起来就是：\n```pascal\nfunction work(x:integer):integer;\nbegin\n    if x=1 then exit(0);\n    else exit(work(rand(1,x))+1);\nend;\n```\n现在给定一个正整数 $n$，请问 $\\text{work}(n)$ 的返回值的期望值是多少？\n\n期望的定义：假设 $\\text{work}(n)$ 返回的所有可能的值为 $x_1,x_2,\\dots ,x_k$，它们出现的概率分别为 $p_1,p_2,\\dots,p_k$，则期望为：\n\n$$\\mathbb{E}=\\sum_{i=1}^{k}x_i p_i$$\n", "inputFormat": "一个正整数 $n$\n", "outputFormat": "一个实数，表示 $\\text{work}(n)$ 的期望值。保留 $5$ 位小数。\n", "hint": "【样例 $1$ 解释】  \n$\\text{work}(2)$ 有 $1/2$ 的概率返回 $1$，有 $1/4$ 的概率返回 $2$，有 $1/8$ 的概率返回 $3$ ……  \n则期望为 $1/2+2/4+3/8+ \\dots =2$\n\n【数据范围】  \n对于 $30\\%$ 的数据，$n \\le 9$；  \n对于 $50\\%$ 的数据，$n \\le 1000$；  \n对于 $70\\%$ 的数据，$n \\le 1000000$；  \n对于 $100\\%$ 的数据，$1\\le n < 2^{31}$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Random Number Generator", "background": "", "description": "HKE recently wrote a function $\\text{rand}(l,r)$, where $l,r$ are positive integers and $l \\le r$. This function returns, with equal probability, any positive integer in the interval $[l, r]$. Then he wrote another function:\n\n```cpp\nint work(int x){\n    if(x==1) return 0;\n    else return work(rand(1,x))+1;\n}\n```\nIn Pascal, this code is:\n```pascal\nfunction work(x:integer):integer;\nbegin\n    if x=1 then exit(0);\n    else exit(work(rand(1,x))+1);\nend;\n```\nGiven a positive integer $n$, what is the expected value of the return value of $\\text{work}(n)$?\n\nDefinition of expectation: Suppose all possible return values of $\\text{work}(n)$ are $x_1, x_2, \\dots , x_k$ with probabilities $p_1, p_2, \\dots, p_k$, then the expectation is:\n$$\\mathbb{E}=\\sum_{i=1}^{k}x_i p_i.$$", "inputFormat": "A positive integer $n$.", "outputFormat": "A real number representing the expected value of $\\text{work}(n)$. Keep $5$ decimal places.", "hint": "[Sample 1 Explanation]  \n$\\text{work}(2)$ returns $1$ with probability $1/2$, returns $2$ with probability $1/4$, returns $3$ with probability $1/8$, and so on.  \nTherefore, the expectation is $1/2+2/4+3/8+\\dots=2$.\n\nConstraints  \nFor $30\\%$ of the testdata, $n \\le 9$;  \nFor $50\\%$ of the testdata, $n \\le 1000$;  \nFor $70\\%$ of the testdata, $n \\le 1000000$;  \nFor $100\\%$ of the testdata, $1 \\le n < 2^{31}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "随机数生成器", "background": "", "description": "HKE最近编写了一个函数 $\\text{rand}(l,r)$，其中 $l,r$ 为正整数且 $l \\le r$。这个函数会等概率返回区间 $[l,r]$ 中任意一个正整数。然后，他又编写了一个函数：\n\n```cpp\nint work(int x){\n    if(x==1) return 0;\n    else return work(rand(1,x))+1;\n}\n```\n这段代码用pascal写起来就是：\n```pascal\nfunction work(x:integer):integer;\nbegin\n    if x=1 then exit(0);\n    else exit(work(rand(1,x))+1);\nend;\n```\n现在给定一个正整数 $n$，请问 $\\text{work}(n)$ 的返回值的期望值是多少？\n\n期望的定义：假设 $\\text{work}(n)$ 返回的所有可能的值为 $x_1,x_2,\\dots ,x_k$，它们出现的概率分别为 $p_1,p_2,\\dots,p_k$，则期望为：\n\n$$\\mathbb{E}=\\sum_{i=1}^{k}x_i p_i$$\n", "inputFormat": "一个正整数 $n$\n", "outputFormat": "一个实数，表示 $\\text{work}(n)$ 的期望值。保留 $5$ 位小数。\n", "hint": "【样例 $1$ 解释】  \n$\\text{work}(2)$ 有 $1/2$ 的概率返回 $1$，有 $1/4$ 的概率返回 $2$，有 $1/8$ 的概率返回 $3$ ……  \n则期望为 $1/2+2/4+3/8+ \\dots =2$\n\n【数据范围】  \n对于 $30\\%$ 的数据，$n \\le 9$；  \n对于 $50\\%$ 的数据，$n \\le 1000$；  \n对于 $70\\%$ 的数据，$n \\le 1000000$；  \n对于 $100\\%$ 的数据，$1\\le n < 2^{31}$。\n", "locale": "zh-CN"}}}
{"pid": "P5148", "type": "P", "difficulty": 4, "samples": [["10 3 3 2\n1 3 3 1", "3240"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "组合数学", "逆元"], "title": "大循环", "background": "", "description": "hke 有一天学会了循环语句，感到很神奇。回到家，他用 C++ 写下这段代码：\n\n```cpp\nvoid work()\n{\n  ans=0;\n    for(a[1]=1;a[1]<=n;++a[1])\n      for(a[2]=1;a[2]<a[1];++a[2])\n        for(a[3]=1;a[3]<a[2];++a[3])\n          //......\n            for(a[k]=1;a[k]<a[k-1];++a[k])\n              ans+=f(q);\n  cout<<ans;\n}\n```\n其中，$q$ 是给定的常数，$f(x)$ 是一个关于 $x$ 的 $m$ 次多项式，它的表达式为：\n\n$$f(x) = a _ m x ^ m + a _ {m - 1} x ^ {m - 1} + \\cdots + a _ 1 x + a _ 0$$\n\nhke 迫不及待地开始运行这个程序，但程序运行得实在太慢了。于是他找到了你，想知道这段程序输出的结果是？答案可能很大，你只需输出其对 $10^9+7$ 取模的结果即可。假设运算过程中不存在溢出。\n", "inputFormat": "第一行 $4$ 个正整数，分别为 $n,m,k,q$；\n\n第二行 $m+1$ 个正整数，分别为 $a_0,a_1,a_2\\cdots a_m$；\n", "outputFormat": "一个数，表示程序运行结果对 $10^9+7$ 取模的结果。\n", "hint": "对于 $10\\%$ 的数据有 $n \\le 10$；\n\n对于 $30\\%$ 的数据有 $n \\le 1000,m \\le 1000$；\n\n对于 $100\\%$ 的数据保证 $n \\le 500000, m \\le 500000, 1≤k≤n,q≤10^{18},1≤a _ i≤10000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Big Loop", "background": "", "description": "hke learned loop statements one day and found them amazing. Back home, he wrote the following code in C++:\n\n```cpp\nvoid work()\n{\n  ans=0;\n    for(a[1]=1;a[1]<=n;++a[1])\n      for(a[2]=1;a[2]<a[1];++a[2])\n        for(a[3]=1;a[3]<a[2];++a[3])\n          //......\n            for(a[k]=1;a[k]<a[k-1];++a[k])\n              ans+=f(q);\n  cout<<ans;\n}\n```\nHere, $q$ is a given constant, and $f(x)$ is a degree $m$ polynomial in $x$, whose expression is:\n\n$$f(x) = a _ m x ^ m + a _ {m - 1} x ^ {m - 1} + \\cdots + a _ 1 x + a _ 0$$\n\nhke could not wait to run this program, but it was far too slow. So he came to you and wanted to know what the program outputs. The answer can be very large; you only need to output it modulo $10^9+7$. Assume there is no overflow during the computation.", "inputFormat": "The first line contains 4 positive integers $n, m, k, q$.\n\nThe second line contains $m + 1$ positive integers, namely $a_0, a_1, a_2 \\cdots a_m$.", "outputFormat": "A single integer, representing the program’s result modulo $10^9+7$.", "hint": "- For $10\\%$ of the testdata, $n \\le 10$.\n- For $30\\%$ of the testdata, $n \\le 1000, m \\le 1000$.\n- For $100\\%$ of the testdata, it is guaranteed that $n \\le 500000, m \\le 500000, 1 \\le k \\le n, q \\le 10^{18}, 1 \\le a_i \\le 10000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "大循环", "background": "", "description": "hke 有一天学会了循环语句，感到很神奇。回到家，他用 C++ 写下这段代码：\n\n```cpp\nvoid work()\n{\n  ans=0;\n    for(a[1]=1;a[1]<=n;++a[1])\n      for(a[2]=1;a[2]<a[1];++a[2])\n        for(a[3]=1;a[3]<a[2];++a[3])\n          //......\n            for(a[k]=1;a[k]<a[k-1];++a[k])\n              ans+=f(q);\n  cout<<ans;\n}\n```\n其中，$q$ 是给定的常数，$f(x)$ 是一个关于 $x$ 的 $m$ 次多项式，它的表达式为：\n\n$$f(x) = a _ m x ^ m + a _ {m - 1} x ^ {m - 1} + \\cdots + a _ 1 x + a _ 0$$\n\nhke 迫不及待地开始运行这个程序，但程序运行得实在太慢了。于是他找到了你，想知道这段程序输出的结果是？答案可能很大，你只需输出其对 $10^9+7$ 取模的结果即可。假设运算过程中不存在溢出。\n", "inputFormat": "第一行 $4$ 个正整数，分别为 $n,m,k,q$；\n\n第二行 $m+1$ 个正整数，分别为 $a_0,a_1,a_2\\cdots a_m$；\n", "outputFormat": "一个数，表示程序运行结果对 $10^9+7$ 取模的结果。\n", "hint": "对于 $10\\%$ 的数据有 $n \\le 10$；\n\n对于 $30\\%$ 的数据有 $n \\le 1000,m \\le 1000$；\n\n对于 $100\\%$ 的数据保证 $n \\le 500000, m \\le 500000, 1≤k≤n,q≤10^{18},1≤a _ i≤10000$。\n", "locale": "zh-CN"}}}
{"pid": "P5149", "type": "P", "difficulty": 3, "samples": [["3\nStan Kyle Kenny\nKyle Stan Kenny", "1"], ["5\nA B C D E\nB A D E C", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["树状数组", "排序", "哈希 hashing", "字典树 Trie"], "title": "会议座位", "background": "话说校长最近很喜欢召开全校教职工大会，让老师们强行听他装逼\n", "description": "现在校长在校园网上公布了一份座位表，$n$ 位老师从左到右依次排成一行。老师们都对这个座位很满意。\n\n然而到了开会时，校长不小心把座位表打乱了，老师们很不满。老师们并不在意自己的位置变了多少，但如果有一对老师 $a$ 和 $b$，他们原来的座位是 $a$ 在 $b$ 左边，现在变成了 $a$ 在 $b$ 右边，那么这一对老师便会贡献一单位不满值。\n\n校长想知道这些老师的总不满值是多少。", "inputFormat": "第一行一个正整数 $n$，为 $n$ 位老师。\n\n第二行有 $n$ 个字符串，每个字符串代表老师的名字（大小写敏感）。这一行代表原来的座位表。\n\n第三行有 $n$ 个字符串，代表打乱后的座位表。", "outputFormat": "一行，一个正整数，表示老师们的总不满值。", "hint": "对于 $30\\%$ 的数据，$1\\le n \\le 10^3$。\n\n对于 $100\\%$ 的数据，$1\\le n \\le 10^5$，每位老师名字长度不超过 $5$，只有大小写字母并且互不相同。注意名字对大小写敏感。", "locale": "zh-CN", "translations": {"en": {"title": "Meeting Seats", "background": "It is said that the principal has recently been fond of holding all-staff meetings, asking the teachers to attend and listen to his speeches.", "description": "The principal posted a seating chart on the campus network: $n$ teachers are arranged in a single row from left to right. The teachers were satisfied with this seating.\n\nHowever, when the meeting started, the principal accidentally shuffled the seating chart, and the teachers became unhappy. The teachers do not care how much their own positions changed, but if there is a pair of teachers $a$ and $b$ such that in the original seating $a$ was to the left of $b$, and now $a$ is to the right of $b$, then this pair contributes one unit of dissatisfaction.\n\nThe principal wants to know the total dissatisfaction value of these teachers.", "inputFormat": "The first line contains a positive integer $n$, the number of teachers.\n\nThe second line contains $n$ strings, each being a teacher’s name (case-sensitive). This line represents the original seating chart.\n\nThe third line contains $n$ strings, representing the shuffled seating chart.", "outputFormat": "One line containing a non-negative integer, the total dissatisfaction value.", "hint": "- For $30\\%$ of the testdata, $1 \\le n \\le 10^3$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 10^5$, each teacher’s name has length at most $5$, consists only of uppercase and lowercase letters, and all names are distinct. Names are case-sensitive.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "会议座位", "background": "话说校长最近很喜欢召开全校教职工大会，让老师们强行听他装逼\n", "description": "现在校长在校园网上公布了一份座位表，$n$ 位老师从左到右依次排成一行。老师们都对这个座位很满意。\n\n然而到了开会时，校长不小心把座位表打乱了，老师们很不满。老师们并不在意自己的位置变了多少，但如果有一对老师 $a$ 和 $b$，他们原来的座位是 $a$ 在 $b$ 左边，现在变成了 $a$ 在 $b$ 右边，那么这一对老师便会贡献一单位不满值。\n\n校长想知道这些老师的总不满值是多少。", "inputFormat": "第一行一个正整数 $n$，为 $n$ 位老师。\n\n第二行有 $n$ 个字符串，每个字符串代表老师的名字（大小写敏感）。这一行代表原来的座位表。\n\n第三行有 $n$ 个字符串，代表打乱后的座位表。", "outputFormat": "一行，一个正整数，表示老师们的总不满值。", "hint": "对于 $30\\%$ 的数据，$1\\le n \\le 10^3$。\n\n对于 $100\\%$ 的数据，$1\\le n \\le 10^5$，每位老师名字长度不超过 $5$，只有大小写字母并且互不相同。注意名字对大小写敏感。", "locale": "zh-CN"}}}
{"pid": "P5150", "type": "P", "difficulty": 3, "samples": [["6", "9\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学"], "title": "生日礼物", "background": "wyh 快过生日了，hke 和 ljc 打算送他生日礼物。\n", "description": "wyh 有一个幸运数字 $n$。现在 hke 打算送他用心度为 $a$ 的礼物，ljc 打算送他用心度为 $b$ 的礼物。两个人的礼物合在一起，用心度为 $\\operatorname{lcm}(a,b)$，其中 $\\operatorname{lcm}$ 代表最小公倍数。wyh 收到的是这份合在一起的礼物。\n\n如果 wyh 收到礼物的用心度恰好为 $n$，他就会很高兴。现在请问有多少种送礼物的方案使得 wyh 高兴？\n", "inputFormat": "一个正整数 $n$。\n", "outputFormat": "一个整数表示答案。\n", "hint": "### 样例解释\n\n这 $9$ 种方案为：$(1,6),(2,6),(3,6),(6,6),(2,3),(3,2),(6,1),(6,2),(6,3)$。\n\n### 数据范围\n\n对于 $30\\%$ 的数据，$n \\leq 1000$；\n\n对于 $100\\%$ 的数据，$n \\leq 10^{16}$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Birthday Gift", "background": "wyh is about to have a birthday, and hke and ljc plan to give him a birthday present.", "description": "wyh has a lucky number $n$. Now hke plans to give him a gift with thoughtfulness value $a$, and ljc plans to give him a gift with thoughtfulness value $b$. Together, their gifts have thoughtfulness value $\\operatorname{lcm}(a,b)$, where $\\operatorname{lcm}$ denotes the least common multiple. wyh receives this combined gift.\n\nIf the thoughtfulness value of the gift wyh receives is exactly $n$, he will be happy. How many ways are there to give gifts that make wyh happy?", "inputFormat": "A positive integer $n$.", "outputFormat": "An integer representing the answer.", "hint": "### Sample Explanation\n\nThese $9$ ways are: $(1,6),(2,6),(3,6),(6,6),(2,3),(3,2),(6,1),(6,2),(6,3)$.\n\n### Constraints\n\nFor $30\\%$ of the testdata, $n \\leq 1000$.\n\nFor $100\\%$ of the testdata, $n \\leq 10^{16}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "生日礼物", "background": "wyh 快过生日了，hke 和 ljc 打算送他生日礼物。\n", "description": "wyh 有一个幸运数字 $n$。现在 hke 打算送他用心度为 $a$ 的礼物，ljc 打算送他用心度为 $b$ 的礼物。两个人的礼物合在一起，用心度为 $\\operatorname{lcm}(a,b)$，其中 $\\operatorname{lcm}$ 代表最小公倍数。wyh 收到的是这份合在一起的礼物。\n\n如果 wyh 收到礼物的用心度恰好为 $n$，他就会很高兴。现在请问有多少种送礼物的方案使得 wyh 高兴？\n", "inputFormat": "一个正整数 $n$。\n", "outputFormat": "一个整数表示答案。\n", "hint": "### 样例解释\n\n这 $9$ 种方案为：$(1,6),(2,6),(3,6),(6,6),(2,3),(3,2),(6,1),(6,2),(6,3)$。\n\n### 数据范围\n\n对于 $30\\%$ 的数据，$n \\leq 1000$；\n\n对于 $100\\%$ 的数据，$n \\leq 10^{16}$。\n", "locale": "zh-CN"}}}
{"pid": "P5151", "type": "P", "difficulty": 3, "samples": [["5 5\n2 3 1 5 4", "2 3 1 5 4"], ["5 4\n2 3 1 5 4", "3 1 2 4 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": [], "title": "HKE与他的小朋友", "background": "HKE 带着 $n$ 个小朋友做游戏。\n", "description": "现在有 $n$ 个座位编号为 $1$ 至 $n$，这些小朋友也编号 $1$ 至 $n$。一开始所有小朋友都坐在相应的座位上。HKE 的游戏可用一个 $n$ 的排列 $A(A_1,A_2, \\cdots, A_n)$ 表示。一轮游戏时，对于所有的 $1\\leq i\\leq n$，坐在位置 $i$ 上的小朋友坐到位置 $A_i$ 上。\n\n现在游戏进行了 $k$ 轮，HKE 想知道游戏结束后，位置 $1,2,\\cdots, n$ 分别坐了几号小朋友？\n", "inputFormat": "第一行两个整数 $n,k$。\n\n第二行一个排列 $A_1,A_2, \\cdots, A_n$。\n", "outputFormat": "一行 $n$ 个数表示位置 $1,2, \\cdots, n$ 上的小朋友的编号。\n", "hint": "- 对于 $30\\%$ 的数据，$n\\leq1000$，$k\\leq1000$；\n- 对于 $100\\%$ 的数据，$n\\leq100000$，$k\\leq2^{31}-1$。\n", "locale": "zh-CN", "translations": {"en": {"title": "HKE and His Little Friends", "background": "HKE is playing a game with $n$ children.", "description": "There are $n$ seats numbered $1$ to $n$, and the children are also numbered $1$ to $n$. Initially, every child sits in the seat with the same number. The game of HKE can be described by an $n$-permutation $A(A_1, A_2, \\cdots, A_n)$. In one round, for every $1\\leq i\\leq n$, the child sitting at position $i$ moves to position $A_i$.\n\nAfter $k$ rounds, HKE wants to know which child ends up at positions $1, 2, \\cdots, n$.", "inputFormat": "The first line contains two integers $n, k$.\nThe second line contains a permutation $A_1, A_2, \\cdots, A_n$.", "outputFormat": "Output one line with $n$ numbers denoting the child at positions $1, 2, \\cdots, n$.", "hint": "- For $30\\%$ of the testdata, $n\\leq1000$, $k\\leq1000$.\n- For $100\\%$ of the testdata, $n\\leq100000$, $k\\leq2^{31}-1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "HKE与他的小朋友", "background": "HKE 带着 $n$ 个小朋友做游戏。\n", "description": "现在有 $n$ 个座位编号为 $1$ 至 $n$，这些小朋友也编号 $1$ 至 $n$。一开始所有小朋友都坐在相应的座位上。HKE 的游戏可用一个 $n$ 的排列 $A(A_1,A_2, \\cdots, A_n)$ 表示。一轮游戏时，对于所有的 $1\\leq i\\leq n$，坐在位置 $i$ 上的小朋友坐到位置 $A_i$ 上。\n\n现在游戏进行了 $k$ 轮，HKE 想知道游戏结束后，位置 $1,2,\\cdots, n$ 分别坐了几号小朋友？\n", "inputFormat": "第一行两个整数 $n,k$。\n\n第二行一个排列 $A_1,A_2, \\cdots, A_n$。\n", "outputFormat": "一行 $n$ 个数表示位置 $1,2, \\cdots, n$ 上的小朋友的编号。\n", "hint": "- 对于 $30\\%$ 的数据，$n\\leq1000$，$k\\leq1000$；\n- 对于 $100\\%$ 的数据，$n\\leq100000$，$k\\leq2^{31}-1$。\n", "locale": "zh-CN"}}}
{"pid": "P5152", "type": "P", "difficulty": 5, "samples": [["5 5\nP 1 1 5 5 3 1 1 2 1 3 1\nQ 1 1 5 5\nQ 1 1 4 3\nP 1 1 5 5 3 1 2 2 1 3 2\nQ 1 2 3 4", "222111111111111111111111111111\n111111111111111111111111111111\n212111111111111111111111111111"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["树状数组"], "title": "宝藏", "background": "此题为改编题，特别鸣谢倪星宇同学。\n\n一群海盗抢到了许多宝藏，准备埋在自己的山洞里。", "description": "海盗的山洞是一个 $n \\times n$ 的方格，每个方格都可以储存很多宝藏。所有方格初始时是空的。\n\n海盗头头决定把这些宝藏藏在某些矩形区域里，同时了解某些矩阵区域里宝藏数量的奇偶性。但是宝藏实在太多了，他整理得眼花缭乱，所以他找到了你来帮忙。", "inputFormat": "第一行两个正整数 $n, m$，表示方格的大小与操作的数量。\n\n下面 $m$ 行有两种操作：\n\n1. P 操作，依次输入 $x_1,y_1,x_2,y_2,k,a_1,b_1,a_2,b_2 \\dots a_k,b_k$：表示在以 $(x_1, y_1)$ 为左上角，$(x_2, y_2)$ 为右下角的矩形区域中，加入 $b_1$ 种 $a_1$ 物品，$b_2$ 种 $a_2$ 物品 $\\dots$ $b_k$ 种 $a_k$ 物品。\n2. Q 操作，依次输入 $x_1,y_1,x_2,y_2$：表示询问以 $(x_1, y_1)$ 为左上角，$(x_2, y_2)$ 为右下角的矩形区域中所有物品数量的奇偶性。", "outputFormat": "对于每次 Q 操作，输出一行字符串。\n\n该字符串长度为 $30$，由 `1` 与 `2` 组成。若第 $k$ 种物品数量为**偶数**，则该字符串从左到右第 $k$ 位为 `1`，否则为 `2`。字符之间没有空格。（注意是**偶 1 奇 2**）", "hint": "对于 $30\\%$ 的数据，保证 $n\\le 300,m \\le 300$；\n\n对于 $100\\%$ 的数据，保证 $n\\le 2500，m\\le 50000，1\\le x_1\\le x_2\\le n，1\\le y_1\\le y_2\\le n，1\\le a_k\\le 30，1≤b_k≤100$。", "locale": "zh-CN", "translations": {"en": {"title": "Treasure", "background": "This is an adapted problem. Special thanks to classmate Ni Xingyu.\n\nA group of pirates seized a lot of treasure and plan to bury it in their cave.", "description": "The pirates’ cave is an $n \\times n$ grid, and each cell can store a lot of treasure. All cells are initially empty. The pirate leader decides to hide these treasures in some rectangular regions, and also to learn the parity of the number of treasures in some rectangular regions. However, there is so much treasure that he gets dizzy organizing it, so he asks you for help.", "inputFormat": "The first line contains two positive integers n and m, representing the grid size and the number of operations.\n\nEach of the following m lines is one of two operations:\n\n1) P x1 y1 x2 y2 k a1 b1 a2 b2 … ak bk: add b1 items of type a1, b2 items of type a2, …, bk items of type ak to every cell in the rectangular region from (x1, y1) to (x2, y2) inclusive. Here, k is the number of (ai, bi) pairs listed.\n\n2) Q x1 y1 x2 y2: query the parity of the total number of items of each type within the rectangular region from (x1, y1) to (x2, y2) inclusive.", "outputFormat": "For each Q operation, output one line containing a string of length 30 composed of ‘1’ and ‘2’. If the count of the k-th item type is even, then the k-th character from left to right is ‘1’; otherwise it is ‘2’. There are no spaces between characters.\n\n(Note: even -> 1, odd -> 2.)", "hint": "- 30% of the testdata: $n \\le 300$, $m \\le 300$.\n- Constraints for 100% of the testdata: $n \\le 2500$, $m \\le 50000$, $1 \\le x1 \\le x2 \\le n$, $1 \\le y1 \\le y2 \\le n$, $1 \\le a_i \\le 30$, $1 \\le b_i \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "宝藏", "background": "此题为改编题，特别鸣谢倪星宇同学。\n\n一群海盗抢到了许多宝藏，准备埋在自己的山洞里。", "description": "海盗的山洞是一个 $n \\times n$ 的方格，每个方格都可以储存很多宝藏。所有方格初始时是空的。\n\n海盗头头决定把这些宝藏藏在某些矩形区域里，同时了解某些矩阵区域里宝藏数量的奇偶性。但是宝藏实在太多了，他整理得眼花缭乱，所以他找到了你来帮忙。", "inputFormat": "第一行两个正整数 $n, m$，表示方格的大小与操作的数量。\n\n下面 $m$ 行有两种操作：\n\n1. P 操作，依次输入 $x_1,y_1,x_2,y_2,k,a_1,b_1,a_2,b_2 \\dots a_k,b_k$：表示在以 $(x_1, y_1)$ 为左上角，$(x_2, y_2)$ 为右下角的矩形区域中，加入 $b_1$ 种 $a_1$ 物品，$b_2$ 种 $a_2$ 物品 $\\dots$ $b_k$ 种 $a_k$ 物品。\n2. Q 操作，依次输入 $x_1,y_1,x_2,y_2$：表示询问以 $(x_1, y_1)$ 为左上角，$(x_2, y_2)$ 为右下角的矩形区域中所有物品数量的奇偶性。", "outputFormat": "对于每次 Q 操作，输出一行字符串。\n\n该字符串长度为 $30$，由 `1` 与 `2` 组成。若第 $k$ 种物品数量为**偶数**，则该字符串从左到右第 $k$ 位为 `1`，否则为 `2`。字符之间没有空格。（注意是**偶 1 奇 2**）", "hint": "对于 $30\\%$ 的数据，保证 $n\\le 300,m \\le 300$；\n\n对于 $100\\%$ 的数据，保证 $n\\le 2500，m\\le 50000，1\\le x_1\\le x_2\\le n，1\\le y_1\\le y_2\\le n，1\\le a_k\\le 30，1≤b_k≤100$。", "locale": "zh-CN"}}}
{"pid": "P5153", "type": "P", "difficulty": 4, "samples": [["4", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学"], "title": "简单的函数", "background": "此题为改编题，特别鸣谢吴作凡同学。\n", "description": "HKE 有一次发现了一个很有趣的函数。\n\n定义 $f(2)=1$。对于 $n\\geq3$，设 $t$ 为最小的使得 $n$ 不能被 $t$ 整除的正整数，则 $f(n)=f(t)+1$。\n\n举个栗子。比如 $n=6$，此时 $t=4$，$f(6)=f(4)+1=f(3)+2=f(2)+3=4$。\n\n现在，HKE 想知道 $f(2)\\times f(3)\\times\\cdots\\times f(n)$ 是多少？答案可能很大，请对 $10^9+7$ 取模。\n", "inputFormat": "一行一个正整数 $n$。\n", "outputFormat": "一行为所求的结果。\n", "hint": "对于 $30\\%$ 的数据，$n\\leq1000$；\n\n对于 $50\\%$ 的数据，$n\\leq1000000$；\n\n对于 $100\\%$ 的数据，$n\\leq10^{18}$。\n", "locale": "zh-CN", "translations": {"en": {"title": "A Simple Function", "background": "This problem is an adaptation; special thanks to classmate Wu Zuofan.", "description": "HKE once discovered a very interesting function.\n\nDefine $f(2) = 1$. For $n \\geq 3$, let $t$ be the smallest positive integer such that $n$ is not divisible by $t$, then $f(n) = f(t) + 1$.\n\nFor example, when $n = 6$, we have $t = 4$, and $f(6) = f(4) + 1 = f(3) + 2 = f(2) + 3 = 4$.\n\nNow, HKE wants to know the value of $f(2) \\times f(3) \\times \\cdots \\times f(n)$. The answer can be large; please take it modulo $10^9 + 7$.", "inputFormat": "A single line containing a positive integer $n$.", "outputFormat": "A single line with the required result.", "hint": "- For $30\\%$ of the testdata, $n \\leq 1000$.\n- For $50\\%$ of the testdata, $n \\leq 1{,}000{,}000$.\n- For $100\\%$ of the testdata, $n \\leq 10^{18}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "简单的函数", "background": "此题为改编题，特别鸣谢吴作凡同学。\n", "description": "HKE 有一次发现了一个很有趣的函数。\n\n定义 $f(2)=1$。对于 $n\\geq3$，设 $t$ 为最小的使得 $n$ 不能被 $t$ 整除的正整数，则 $f(n)=f(t)+1$。\n\n举个栗子。比如 $n=6$，此时 $t=4$，$f(6)=f(4)+1=f(3)+2=f(2)+3=4$。\n\n现在，HKE 想知道 $f(2)\\times f(3)\\times\\cdots\\times f(n)$ 是多少？答案可能很大，请对 $10^9+7$ 取模。\n", "inputFormat": "一行一个正整数 $n$。\n", "outputFormat": "一行为所求的结果。\n", "hint": "对于 $30\\%$ 的数据，$n\\leq1000$；\n\n对于 $50\\%$ 的数据，$n\\leq1000000$；\n\n对于 $100\\%$ 的数据，$n\\leq10^{18}$。\n", "locale": "zh-CN"}}}
{"pid": "P5154", "type": "P", "difficulty": 5, "samples": [["6\n9 8 6 5 6 3\n11 19 12 17 18 15", "64\n//解释：擦去A[2],A[3]与A[5],A[6]，得分为64"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP"], "title": "数列游戏", "background": "本题改编自真实事件，特别鸣谢倪星宇同学提供创意支持。\n\n有一次，HKE 和 LJC 在玩一个有趣的数列游戏。\n", "description": "游戏规则如下：\n\nLJC 写下两个长度均为 $N$ 的正整数数列 $A$ 和 $B$。两个数列一一对应，即对于每个 $i$ 都有一对 $(A_i, B_i)$。\n\nHKE 每次可以选择一对 **相邻的**数 $A[i]$ 和 $A[i+1]$，**如果它们不互质（即 $\\gcd(A[i], A[i+1]) > 1$**，他可以将这一对消除，并获得 $B[i] + B[i+1]$ 分数。\n\n被消除的一对数从两个数列中同时移除，并使两个数列重新紧密排列（即剩余元素自动左移）。\n\n当数列中**所有相邻的数对都互质时**，游戏结束。HKE 想知道他最多可以获得多少分数。\n", "inputFormat": "* 第 1 行：一个整数 $N$（表示数列的长度）\n* 第 2 行：$N$ 个整数，表示数列 $A_1, A_2, \\ldots, A_N$\n* 第 3 行：$N$ 个整数，表示数列 $B_1, B_2, \\ldots, B_N$", "outputFormat": "* 输出一个整数，表示 HKE 可以获得的最大总得分。\n", "hint": "### 样例解释\n\n一种最优的策略如下：\n\n* 第一次消去 $A[2]=8$ 和 $A[3]=6$，获得 $B[2]+B[3]=19+12=31$ 分；\n* 更新数列后为：$9, 5, 6, 3$，$11, 17, 18, 15$；\n* 第二次消去 $A[3]=6$ 和 $A[4]=3$，获得 $B[3]+B[4]=18+15=33$ 分；\n* 总得分为 $31+33=64$。\n\n### 数据范围与限制\n\n* 对于 30% 的数据，$N \\leq 20$；\n* 对于 60% 的数据，$N \\leq 100$；\n* 对于 80% 的数据，$N \\leq 500$；\n* 对于 100% 的数据，$N \\leq 800$；\n* 保证 $1 \\leq A_i, B_i \\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "{{Sequence Game}}", "background": "{{This problem is adapted from a real event. Special thanks to classmate Ni Xingyu (Ni Xingyu) for creative support. One time, HKE and LJC were playing an interesting sequence game.}}", "description": "{{The rules are as follows:\n\nLJC writes down two sequences of positive integers $A$ and $B$, both of length $N$. The two sequences are paired one-to-one, that is, for each $i$ there is a pair $(A_i, B_i)$.\n\nEach time, HKE may choose an adjacent pair $A[i]$ and $A[i+1]$. If they are not coprime (i.e., $\\gcd(A[i], A[i+1]) > 1$), he may remove this pair and gain $B[i] + B[i+1]$ points.\n\nThe removed pair is simultaneously deleted from both sequences, and the sequences are compacted (the remaining elements shift left).\n\nWhen all adjacent pairs in the sequence are coprime, the game ends. HKE wants to know the maximum total score he can obtain.}}", "inputFormat": "{{- Line 1: an integer $N$ (the length of the sequences).\n- Line 2: $N$ integers, representing $A_1, $ $A_2, \\ldots, A_N$.\n- Line 3: $N$ integers, representing $B_1, $ $B_2, \\ldots, B_N$.}}", "outputFormat": "{{- Output one integer, the maximum total score HKE can obtain.}}", "hint": "{{Sample Explanation:\n\n- First remove $A[2]=8$ and $A[3]=6$, gaining $B[2]+B[3]=19+12=31$ points.\n- After the update, they become $9, 5, 6, 3$ and $11, 17, 18, 15$.\n- Then remove $A[3]=6$ and $A[4]=3$, gaining $B[3]+B[4]=18+15=33$ points.\n- The total score is $31+33=64$.\n\nConstraints:\n\n- For 30% of the testdata, $N \\leq 20$.\n- For 60% of the testdata, $N \\leq 100$.\n- For 80% of the testdata, $N \\leq 500$.\n- For 100% of the testdata, $N \\leq 800$.\n- It is guaranteed that $1 \\leq A_i, B_i \\leq 10^9$.}}\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "数列游戏", "background": "本题改编自真实事件，特别鸣谢倪星宇同学提供创意支持。\n\n有一次，HKE 和 LJC 在玩一个有趣的数列游戏。\n", "description": "游戏规则如下：\n\nLJC 写下两个长度均为 $N$ 的正整数数列 $A$ 和 $B$。两个数列一一对应，即对于每个 $i$ 都有一对 $(A_i, B_i)$。\n\nHKE 每次可以选择一对 **相邻的**数 $A[i]$ 和 $A[i+1]$，**如果它们不互质（即 $\\gcd(A[i], A[i+1]) > 1$**，他可以将这一对消除，并获得 $B[i] + B[i+1]$ 分数。\n\n被消除的一对数从两个数列中同时移除，并使两个数列重新紧密排列（即剩余元素自动左移）。\n\n当数列中**所有相邻的数对都互质时**，游戏结束。HKE 想知道他最多可以获得多少分数。\n", "inputFormat": "* 第 1 行：一个整数 $N$（表示数列的长度）\n* 第 2 行：$N$ 个整数，表示数列 $A_1, A_2, \\ldots, A_N$\n* 第 3 行：$N$ 个整数，表示数列 $B_1, B_2, \\ldots, B_N$", "outputFormat": "* 输出一个整数，表示 HKE 可以获得的最大总得分。\n", "hint": "### 样例解释\n\n一种最优的策略如下：\n\n* 第一次消去 $A[2]=8$ 和 $A[3]=6$，获得 $B[2]+B[3]=19+12=31$ 分；\n* 更新数列后为：$9, 5, 6, 3$，$11, 17, 18, 15$；\n* 第二次消去 $A[3]=6$ 和 $A[4]=3$，获得 $B[3]+B[4]=18+15=33$ 分；\n* 总得分为 $31+33=64$。\n\n### 数据范围与限制\n\n* 对于 30% 的数据，$N \\leq 20$；\n* 对于 60% 的数据，$N \\leq 100$；\n* 对于 80% 的数据，$N \\leq 500$；\n* 对于 100% 的数据，$N \\leq 800$；\n* 保证 $1 \\leq A_i, B_i \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P5155", "type": "P", "difficulty": 6, "samples": [["2\n1\n3", "150000\n300000\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2018", "USACO", "期望", "凸包"], "title": "[USACO18DEC] Balance Beam P", "background": "", "description": "Bessie为了存钱给她的牛棚新建一间隔间，开始在当地的马戏团里表演，通过在平衡木上小心地来回走动来展示她卓越的平衡能力。\n\nBessie能够通过表演赚到的钱取决于她最终成功跳下平衡木的位置。平衡木上从左向右的位置记为 $ 0,1,\\ldots,N+1 $ 。如果Bessie到达了位置 $ 0 $ 或是 $ N+1 $ ，她就会从平衡木的一端掉下去，遗憾地得不到报酬。\n\n如果Bessie处在一个给定的位置 $ k $ ，她可以进行下面两项中的任意一项：\n\n1. 投掷一枚硬币。如果背面朝上，她前往位置 $ k-1 $ ，如果正面朝上，她前往位置 $ k+1 $ （也就是说，每种可能性 $ 1/2 $ 的概率）。\n\n2. 跳下平衡木，获得 $ f(k) $ 的报酬（ $ 0 \\leq f(k) \\leq 10^9 $ ）。\n\nBessie意识到她并不能保证结果能够得到某一特定数量的报酬，这是由于她的移动是由随机的掷硬币结果控制。然而，基于她的起始位置，她想要求出当她进行一系列最优的决定之后，她能够得到的期望报酬（“最优”指的是这些决定能够带来最高可能的期望报酬）。\n\n例如，如果她的策略能够使她以 $ 1/2 $ 的概率获得 $ 10 $ 的报酬，$ 1/4 $ 的概率获得 $ 8 $ 的报酬，$ 1/4 $ 的概率获得 $ 0 $ 的报酬，那么她的期望报酬为加权平均值 $ 10 \\times (1/2)+8 \\times (1/4)+0 \\times (1/4)=7 $ 。", "inputFormat": "输入的第一行包含 $ N $ （ $ 2 \\leq N \\leq 10^5 $ ）。以下 $ N $ 行包含 $ f(1) \\ldots f(N) $ 。", "outputFormat": "输出 $ N $ 行。第 $ i $ 行输出 $ 10^5 $ 乘以Bessie从位置 $ i $ 开始使用最优策略能够获得的报酬的期望值，向下取整。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18DEC] Balance Beam P", "background": "", "description": "To save money to build a new stall in her barn, Bessie starts performing at a local circus, showing off her excellent balance by carefully walking back and forth on a balance beam.\n\nHow much money Bessie can earn depends on the position where she finally jumps off the beam successfully. Positions on the beam from left to right are labeled $0,1,\\ldots,N+1$. If Bessie reaches position $0$ or $N+1$, she will fall off the end of the beam and unfortunately receive no reward.\n\nIf Bessie is at a given position $k$, she may do either of the following:\n\n1. Toss a coin. If it lands tails up, she moves to position $k-1$; if it lands heads up, she moves to position $k+1$ (that is, each happens with probability $1/2$).\n\n2. Jump off the beam and receive a reward of $f(k)$ ($0 \\leq f(k) \\leq 10^9$).\n\nBessie realizes she cannot guarantee getting any particular reward, since her movement is controlled by the random coin tosses. However, based on her starting position, she wants to compute the expected reward she can obtain after making a sequence of optimal decisions (where “optimal” means the decisions that yield the highest possible expected reward).\n\nFor example, if her strategy gives her a reward of $10$ with probability $1/2$, a reward of $8$ with probability $1/4$, and a reward of $0$ with probability $1/4$, then her expected reward is the weighted average $10 \\times (1/2)+8 \\times (1/4)+0 \\times (1/4)=7$.", "inputFormat": "The first line of input contains $N$ ($2 \\leq N \\leq 10^5$). The next $N$ lines contain $f(1) \\ldots f(N)$.", "outputFormat": "Output $N$ lines. On the $i$-th line, output $10^5$ times the expected reward Bessie can obtain when starting from position $i$ and using an optimal strategy, rounded down.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18DEC] Balance Beam P", "background": "", "description": "Bessie为了存钱给她的牛棚新建一间隔间，开始在当地的马戏团里表演，通过在平衡木上小心地来回走动来展示她卓越的平衡能力。\n\nBessie能够通过表演赚到的钱取决于她最终成功跳下平衡木的位置。平衡木上从左向右的位置记为 $ 0,1,\\ldots,N+1 $ 。如果Bessie到达了位置 $ 0 $ 或是 $ N+1 $ ，她就会从平衡木的一端掉下去，遗憾地得不到报酬。\n\n如果Bessie处在一个给定的位置 $ k $ ，她可以进行下面两项中的任意一项：\n\n1. 投掷一枚硬币。如果背面朝上，她前往位置 $ k-1 $ ，如果正面朝上，她前往位置 $ k+1 $ （也就是说，每种可能性 $ 1/2 $ 的概率）。\n\n2. 跳下平衡木，获得 $ f(k) $ 的报酬（ $ 0 \\leq f(k) \\leq 10^9 $ ）。\n\nBessie意识到她并不能保证结果能够得到某一特定数量的报酬，这是由于她的移动是由随机的掷硬币结果控制。然而，基于她的起始位置，她想要求出当她进行一系列最优的决定之后，她能够得到的期望报酬（“最优”指的是这些决定能够带来最高可能的期望报酬）。\n\n例如，如果她的策略能够使她以 $ 1/2 $ 的概率获得 $ 10 $ 的报酬，$ 1/4 $ 的概率获得 $ 8 $ 的报酬，$ 1/4 $ 的概率获得 $ 0 $ 的报酬，那么她的期望报酬为加权平均值 $ 10 \\times (1/2)+8 \\times (1/4)+0 \\times (1/4)=7 $ 。", "inputFormat": "输入的第一行包含 $ N $ （ $ 2 \\leq N \\leq 10^5 $ ）。以下 $ N $ 行包含 $ f(1) \\ldots f(N) $ 。", "outputFormat": "输出 $ N $ 行。第 $ i $ 行输出 $ 10^5 $ 乘以Bessie从位置 $ i $ 开始使用最优策略能够获得的报酬的期望值，向下取整。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P5156", "type": "P", "difficulty": 6, "samples": [["4 1\n4 2 1 3\n", "2\n1\n4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "USACO", "树状数组"], "title": "[USACO18DEC] Sort It Out P", "background": "", "description": "FJ 有 $N$（$1 \\leq N \\leq 10^5$）头奶牛（分别用 $1 \\ldots N$ 编号）排成一行。FJ 喜欢他的奶牛以升序排列，不幸的是现在她们的顺序被打乱了。在过去，FJ 曾经使用一些诸如“冒泡排序”的开创性算法来使他的奶牛排好序，但今天他想偷个懒。取而代之，他会每次对着一头奶牛叫道“按顺序排好”。当一头奶牛被叫到的时候，她会确保自己在队伍中的顺序是正确的（从她的角度看来）。当有一头紧接在她右边的奶牛的编号比她小，她们就交换位置。然后，当有一头紧接在她左边的奶牛的编号比她大，她们就交换位置。这样这头奶牛就完成了“按顺序排好”，在这头奶牛看来左边的奶牛编号比她小，右边的奶牛编号比她大。\n\nFJ 想要选出这些奶牛的一个子集，然后遍历这个子集，依次对着每一头奶牛发号施令（按编号递增的顺序），重复这样直到所有 $N$ 头奶牛排好顺序。例如，如果他选出了编号为 $\\{2,4,5\\}$ 的奶牛的子集，那么他会喊叫奶牛 $2$，然后是奶牛 $4$，然后是奶牛 $5$。如果 $N$ 头奶牛此时仍未排好顺序，他会再次对着这几头奶牛喊叫，如果有必要的话继续重复。\n\n由于 FJ 不确定哪些奶牛比较专心，他想要使得这个子集最小。此外，他认为 $K$ 是个幸运数字。请帮他求出满足重复喊叫可以使得所有奶牛排好顺序的最小子集之中字典序第 $K$ 小的子集。\n\n我们称 $\\{1, \\ldots ,N\\}$ 的一个子集 $S$ 在字典序下小于子集 $T$，当 $S$ 的所有元素组成的序列（按升序排列）在字典序下小于 $T$ 的所有元素组成的序列（按升序排列）。例如，$\\{1,3,6\\}$ 在字典序下小于 $\\{1,4,5\\}$。", "inputFormat": "输入的第一行包含一个整数 $ N $ 。第二行包含一个整数 $ K $ （ $ 1 \\leq K \\leq 10^{18} $ ）。第三行包含 $ N $ 个空格分隔的整数，表示从左到右奶牛的编号。\n\n保证存在至少 $ K $ 个符合要求的子集。", "outputFormat": "第一行输出最小子集的大小。接下来输出字典序第 $ K $ 小的最小子集中奶牛的编号，每行一个数，升序排列。", "hint": "开始的时候序列为 $ \\mathtt{\\:4\\:\\; 2\\:\\; 1\\:\\; 3\\:} $ 。在FJ喊叫编号为 $ 1 $ 的奶牛之后，序列变为 $ \\mathtt{\\:1\\:\\; 4\\:\\; 2\\:\\; 3\\:} $ 。在FJ喊叫编号为 $ 4 $ 的奶牛之后，序列变为 $ \\mathtt{\\:1\\:\\; 2\\:\\; 3\\:\\; 4\\:} $ 。在这个时候，序列已经完成了排序。\n\n## 子任务\n\n对于占总分 $ 3/16 $ 的测试数据， $ N \\leq 6 $ ，并且 $ K=1 $ 。\n\n对于另外的占总分 $ 5/16 $ 的测试数据， $ K=1 $ 。\n\n对于另外的占总分 $ 8/16 $ 的测试数据，没有其他限制。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18DEC] Sort It Out P", "background": "", "description": "FJ has $N$ cows ($1 \\leq N \\leq 10^5$), labeled $1 \\ldots N$, standing in a line. FJ likes his cows to be in increasing order, but unfortunately their order is currently scrambled. In the past, FJ used some groundbreaking algorithms such as \"bubble sort\" to sort his cows, but today he wants to be lazy. Instead, each time he will shout at one cow, \"Get in order.\" When a cow is shouted at, she will make sure her position in the line is correct (from her point of view). If the cow immediately to her right has a smaller label than hers, they swap positions. Then, if the cow immediately to her left has a larger label than hers, they swap positions. In this way, the cow finishes \"getting in order\": from her point of view, cows to her left have smaller labels than hers, and cows to her right have larger labels than hers.\n\nFJ wants to choose a subset of the cows, then repeatedly go through this subset and shout at each selected cow in increasing order of label, repeating until all $N$ cows are sorted. For example, if he chooses the subset of cows with labels $\\{2,4,5\\}$, then he will shout at cow $2$, then cow $4$, then cow $5$. If the $N$ cows are still not sorted at that point, he will shout at these cows again, and continue repeating if necessary.\n\nSince FJ is not sure which cows are attentive, he wants this subset to be as small as possible. Also, he believes $K$ is a lucky number. Please help him find, among all minimum-size subsets that can sort all cows by repeated shouting, the $K$-th smallest subset in lexicographic order.\n\nWe say that a subset $S$ of $\\{1, \\ldots, N\\}$ is smaller than a subset $T$ in lexicographic order if the sequence of elements of $S$ (sorted in increasing order) is lexicographically smaller than the sequence of elements of $T$ (sorted in increasing order). For example, $\\{1,3,6\\}$ is lexicographically smaller than $\\{1,4,5\\}$.", "inputFormat": "The first line contains an integer $N$.  \nThe second line contains an integer $K$ ($1 \\leq K \\leq 10^{18}$).  \nThe third line contains $N$ space-separated integers, giving the cow labels from left to right.\n\nIt is guaranteed that there are at least $K$ valid subsets.", "outputFormat": "Print the size of a minimum subset on the first line.  \nThen output the cow labels in the $K$-th lexicographically smallest minimum subset, one per line, in increasing order.", "hint": "At the beginning, the sequence is $ \\mathtt{\\:4\\:\\; 2\\:\\; 1\\:\\; 3\\:} $. After FJ shouts at cow $1$, the sequence becomes $ \\mathtt{\\:1\\:\\; 4\\:\\; 2\\:\\; 3\\:} $. After FJ shouts at cow $4$, the sequence becomes $ \\mathtt{\\:1\\:\\; 2\\:\\; 3\\:\\; 4\\:} $. At this time, the sequence is fully sorted.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18DEC] Sort It Out P", "background": "", "description": "FJ 有 $N$（$1 \\leq N \\leq 10^5$）头奶牛（分别用 $1 \\ldots N$ 编号）排成一行。FJ 喜欢他的奶牛以升序排列，不幸的是现在她们的顺序被打乱了。在过去，FJ 曾经使用一些诸如“冒泡排序”的开创性算法来使他的奶牛排好序，但今天他想偷个懒。取而代之，他会每次对着一头奶牛叫道“按顺序排好”。当一头奶牛被叫到的时候，她会确保自己在队伍中的顺序是正确的（从她的角度看来）。当有一头紧接在她右边的奶牛的编号比她小，她们就交换位置。然后，当有一头紧接在她左边的奶牛的编号比她大，她们就交换位置。这样这头奶牛就完成了“按顺序排好”，在这头奶牛看来左边的奶牛编号比她小，右边的奶牛编号比她大。\n\nFJ 想要选出这些奶牛的一个子集，然后遍历这个子集，依次对着每一头奶牛发号施令（按编号递增的顺序），重复这样直到所有 $N$ 头奶牛排好顺序。例如，如果他选出了编号为 $\\{2,4,5\\}$ 的奶牛的子集，那么他会喊叫奶牛 $2$，然后是奶牛 $4$，然后是奶牛 $5$。如果 $N$ 头奶牛此时仍未排好顺序，他会再次对着这几头奶牛喊叫，如果有必要的话继续重复。\n\n由于 FJ 不确定哪些奶牛比较专心，他想要使得这个子集最小。此外，他认为 $K$ 是个幸运数字。请帮他求出满足重复喊叫可以使得所有奶牛排好顺序的最小子集之中字典序第 $K$ 小的子集。\n\n我们称 $\\{1, \\ldots ,N\\}$ 的一个子集 $S$ 在字典序下小于子集 $T$，当 $S$ 的所有元素组成的序列（按升序排列）在字典序下小于 $T$ 的所有元素组成的序列（按升序排列）。例如，$\\{1,3,6\\}$ 在字典序下小于 $\\{1,4,5\\}$。", "inputFormat": "输入的第一行包含一个整数 $ N $ 。第二行包含一个整数 $ K $ （ $ 1 \\leq K \\leq 10^{18} $ ）。第三行包含 $ N $ 个空格分隔的整数，表示从左到右奶牛的编号。\n\n保证存在至少 $ K $ 个符合要求的子集。", "outputFormat": "第一行输出最小子集的大小。接下来输出字典序第 $ K $ 小的最小子集中奶牛的编号，每行一个数，升序排列。", "hint": "开始的时候序列为 $ \\mathtt{\\:4\\:\\; 2\\:\\; 1\\:\\; 3\\:} $ 。在FJ喊叫编号为 $ 1 $ 的奶牛之后，序列变为 $ \\mathtt{\\:1\\:\\; 4\\:\\; 2\\:\\; 3\\:} $ 。在FJ喊叫编号为 $ 4 $ 的奶牛之后，序列变为 $ \\mathtt{\\:1\\:\\; 2\\:\\; 3\\:\\; 4\\:} $ 。在这个时候，序列已经完成了排序。\n\n## 子任务\n\n对于占总分 $ 3/16 $ 的测试数据， $ N \\leq 6 $ ，并且 $ K=1 $ 。\n\n对于另外的占总分 $ 5/16 $ 的测试数据， $ K=1 $ 。\n\n对于另外的占总分 $ 8/16 $ 的测试数据，没有其他限制。", "locale": "zh-CN"}}}
{"pid": "P5157", "type": "P", "difficulty": 6, "samples": [["5 1\n1 2\n2 3\n3 4\n4 5\n2 4\n", "0\n0\n1\n1\n1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "2018", "USACO", "图论建模", "拓扑排序"], "title": "[USACO18DEC] The Cow Gathering P", "background": "", "description": "奶牛们从世界各地聚集起来参加一场大型聚会。总共有 $ N $ 头奶牛， $ N-1 $ 对奶牛互为朋友。每头奶牛都可以通过一些朋友关系认识其他每头奶牛。\n\n她们玩得很开心，但是现在到了她们应当离开的时间了，她们会一个接一个地离开。她们想要以某种顺序离开，使得只要至少还有两头奶牛尚未离开，所有尚未离开的奶牛都还有没有离开的朋友。此外，由于行李寄存的因素，有 $ M $ 对奶牛 $ (a_i,b_i) $ 必须满足奶牛 $ a_i $ 要比奶牛 $ b_i $ 先离开。注意奶牛 $ a_i $ 和奶牛 $ b_i $ 可能是朋友，也可能不是朋友。\n\n帮助奶牛们求出，对于每一头奶牛，她是否可以成为最后一头离开的奶牛。可能会发生不存在满足上述要求的奶牛离开顺序的情况。", "inputFormat": "输入的第 $ 1 $ 行包含两个空格分隔的整数 $ N $ 和 $ M $ 。\n\n输入的第 $ 2 \\leq i \\leq N $ 行，每行包含两个整数 $ x_i $ 和 $ y_i $ ，满足 $ 1 \\leq x_i $ ， $ y_i \\leq N,xi \\neq yi $ ，表示奶牛 $ x_i $ 和奶牛 $ y_i $ 是朋友关系。\n\n输入的第 $ N+1 \\leq i \\leq N+M $ 行，每行包含两个整数 $ a_i $ 和 $ b_i $ ，满足 $ 1 \\leq a_i,b_i \\leq N $ ， $ a_i \\neq b_i $ ，表示奶牛 $ a_i $ 必须比奶牛 $ b_i $ 先离开聚会。\n\n输入保证 $ 1 \\leq N,M \\leq 10^5 $ 。对于占总分 $ 20\\% $ 的测试数据，保证 $ N,M \\leq 3000 $ 。", "outputFormat": "输出 $ N $ 行，每行包含一个整数 $ d_i $ ，如果奶牛 $ i $ 可以成为最后一头离开的奶牛，则 $ d_i=1 $ ，否则 $ d_i=0 $ 。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18DEC] The Cow Gathering P", "background": "", "description": "Cows from all over the world have gathered for a big party. There are a total of $N$ cows, and $N-1$ pairs of cows are friends. Each cow can get to know every other cow through some chain of friendships.\n\nThey have had a great time, but now it is time for them to leave, one by one. They want to leave in some order such that, as long as at least two cows have not left yet, every remaining cow still has at least one friend who has not left. In addition, due to baggage storage constraints, there are $M$ pairs of cows $(a_i,b_i)$ that must satisfy that cow $a_i$ leaves before cow $b_i$. Note that cows $a_i$ and $b_i$ may or may not be friends.\n\nHelp the cows determine, for each cow, whether she can be the last cow to leave. It is possible that there is no leaving order that satisfies the above requirements.", "inputFormat": "The first line of input contains two space-separated integers $N$ and $M$.\n\nThe following $N-1$ lines (for $2 \\leq i \\leq N$) each contain two integers $x_i$ and $y_i$, satisfying $1 \\leq x_i$, $y_i \\leq N, xi \\neq yi$, indicating that cows $x_i$ and $y_i$ are friends.\n\nThe following $M$ lines (for $N+1 \\leq i \\leq N+M$) each contain two integers $a_i$ and $b_i$, satisfying $1 \\leq a_i,b_i \\leq N$ and $a_i \\neq b_i$, indicating that cow $a_i$ must leave the party before cow $b_i$.\n\nThe input guarantees $1 \\leq N,M \\leq 10^5$. For the testdata worth $20\\%$ of the total score, it is guaranteed that $N,M \\leq 3000$.", "outputFormat": "Output $N$ lines. Each line contains an integer $d_i$. If cow $i$ can be the last cow to leave, then $d_i=1$; otherwise, $d_i=0$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18DEC] The Cow Gathering P", "background": "", "description": "奶牛们从世界各地聚集起来参加一场大型聚会。总共有 $ N $ 头奶牛， $ N-1 $ 对奶牛互为朋友。每头奶牛都可以通过一些朋友关系认识其他每头奶牛。\n\n她们玩得很开心，但是现在到了她们应当离开的时间了，她们会一个接一个地离开。她们想要以某种顺序离开，使得只要至少还有两头奶牛尚未离开，所有尚未离开的奶牛都还有没有离开的朋友。此外，由于行李寄存的因素，有 $ M $ 对奶牛 $ (a_i,b_i) $ 必须满足奶牛 $ a_i $ 要比奶牛 $ b_i $ 先离开。注意奶牛 $ a_i $ 和奶牛 $ b_i $ 可能是朋友，也可能不是朋友。\n\n帮助奶牛们求出，对于每一头奶牛，她是否可以成为最后一头离开的奶牛。可能会发生不存在满足上述要求的奶牛离开顺序的情况。", "inputFormat": "输入的第 $ 1 $ 行包含两个空格分隔的整数 $ N $ 和 $ M $ 。\n\n输入的第 $ 2 \\leq i \\leq N $ 行，每行包含两个整数 $ x_i $ 和 $ y_i $ ，满足 $ 1 \\leq x_i $ ， $ y_i \\leq N,xi \\neq yi $ ，表示奶牛 $ x_i $ 和奶牛 $ y_i $ 是朋友关系。\n\n输入的第 $ N+1 \\leq i \\leq N+M $ 行，每行包含两个整数 $ a_i $ 和 $ b_i $ ，满足 $ 1 \\leq a_i,b_i \\leq N $ ， $ a_i \\neq b_i $ ，表示奶牛 $ a_i $ 必须比奶牛 $ b_i $ 先离开聚会。\n\n输入保证 $ 1 \\leq N,M \\leq 10^5 $ 。对于占总分 $ 20\\% $ 的测试数据，保证 $ N,M \\leq 3000 $ 。", "outputFormat": "输出 $ N $ 行，每行包含一个整数 $ d_i $ ，如果奶牛 $ i $ 可以成为最后一头离开的奶牛，则 $ d_i=1 $ ，否则 $ d_i=0 $ 。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P5158", "type": "P", "difficulty": 7, "samples": [["4\n1 1\n2 4\n3 9\n4 16", "0 0 1 0"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "O2优化", "快速傅里叶变换 FFT", "快速数论变换 NTT", "模板题"], "title": "【模板】多项式快速插值", "background": "模板题，无背景", "description": "给出 $n$ 个点 $(x_i, y_i)$\n\n求一个 $n-1$ 次的多项式 $f(x)$，使得 $f(x_i)\\equiv y_i\\pmod{998244353}$", "inputFormat": "第一行输入一个正整数 $n$\n\n接下来 $n$ 行每行两个整数 $x_i, y_i$", "outputFormat": "共一行，从低到高输出 $f(x)$ 每一项的系数\n\n若次数不够 $n-1$ 次，用 $0$ 补足", "hint": "$1 \\leqslant n \\leqslant 100000$\n\n$0 \\leqslant x_i, y_i \\lt 998244353$\n\n保证 $x_i$ 互不相同\n\n对于 $30\\%$ 的数据，$n \\leqslant 5000$\n\n注意，你输出的数必须是 $[0, 998244353)$ 范围内的整数\n\n数据使用 CYaRon 在五分钟之内生成。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Fast Polynomial Interpolation", "background": "This is a template problem, with no background.", "description": "You are given $n$ points $(x_i, y_i)$.\n\nFind a polynomial $f(x)$ of degree $n - 1$ such that $f(x_i)\\equiv y_i\\pmod{998244353}$.", "inputFormat": "The first line contains a positive integer $n$.\n\nThe next $n$ lines each contain two integers $x_i, y_i$.", "outputFormat": "Output one line: the coefficients of $f(x)$ from low degree to high degree.\n\nIf the degree is less than $n - 1$, pad with $0$ until there are $n$ coefficients.", "hint": "Constraints:\n\n$1 \\leqslant n \\leqslant 100000$.\n\n$0 \\leqslant x_i, y_i \\lt 998244353$.\n\nIt is guaranteed that all $x_i$ are pairwise distinct.\n\nFor $30\\%$ of the testdata, $n \\leqslant 5000$.\n\nNote that the numbers you output must be integers in the range $[0, 998244353)$.\n\nThe testdata was generated using CYaRon within five minutes.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】多项式快速插值", "background": "模板题，无背景", "description": "给出 $n$ 个点 $(x_i, y_i)$\n\n求一个 $n-1$ 次的多项式 $f(x)$，使得 $f(x_i)\\equiv y_i\\pmod{998244353}$", "inputFormat": "第一行输入一个正整数 $n$\n\n接下来 $n$ 行每行两个整数 $x_i, y_i$", "outputFormat": "共一行，从低到高输出 $f(x)$ 每一项的系数\n\n若次数不够 $n-1$ 次，用 $0$ 补足", "hint": "$1 \\leqslant n \\leqslant 100000$\n\n$0 \\leqslant x_i, y_i \\lt 998244353$\n\n保证 $x_i$ 互不相同\n\n对于 $30\\%$ 的数据，$n \\leqslant 5000$\n\n注意，你输出的数必须是 $[0, 998244353)$ 范围内的整数\n\n数据使用 CYaRon 在五分钟之内生成。", "locale": "zh-CN"}}}
{"pid": "P5159", "type": "P", "difficulty": 3, "samples": [["2\n2 2\n2 2018", "2\n851481696"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["O2优化"], "title": "WD与矩阵", "background": "WD整日沉浸在矩阵中，无法自拔……", "description": "WD 特别喜欢矩阵，尤其是 01 矩阵。\n\n一天，CX 给了 WD 一个巨大的 $n$ 行 $m$ 列的 01 矩阵，WD 发现这个矩阵每行、每列的异或值都是 0。\n\nCX 随后就问道：“WD，你知道有多少 01 矩阵每行每列异或值都是 0 吗！？”WD 当然不会这个问题，于是他来请教你。\n\n由于答案可能很大，输出结果模 $998\\,244\\,353$ 的值即可。", "inputFormat": "第一行一个数 $T$，表示数据组数。\n\n接下来 $T$ 行每行两个数 $n,m$，分别表示询问的行数和列数。", "outputFormat": "共 $T$ 行，每行一个数，表示答案对 $998\\,244\\,353$ 取模的结果。", "hint": "- subtask1（11pts）：$1\\le T\\le 10,~1\\le n,m\\le 4$\n- subtask2（43pts）：$1\\le T\\le 5,~1\\le n\\le 5,~1\\le m\\le 1,000$\n- subtask3（46pts）：$1\\le T\\le 10^5,~1\\le n,m\\le 10^9$", "locale": "zh-CN", "translations": {"en": {"title": "WD and Matrices", "background": "WD spends all day immersed in matrices and cannot get out of it.", "description": "WD likes matrices very much, especially 01 matrices.\n\nOne day, CX gave WD a huge $n$-row, $m$-column 01 matrix. WD found that the XOR value of every row and every column of this matrix is $0$.\n\nCX then asked, “WD, do you know how many 01 matrices have XOR value $0$ in every row and every column!?” WD of course does not know this, so he came to ask you.\n\nSince the answer may be very large, you only need to output the result modulo $998\\,244\\,353$.", "inputFormat": "The first line contains an integer $T$, which represents the number of test cases.\n\nIn the next $T$ lines, each line contains two integers $n, m$, representing the number of rows and columns in the query.", "outputFormat": "Output $T$ lines. Each line contains one integer, the answer modulo $998\\,244\\,353$.", "hint": "- Subtask 1 (11 pts): $1\\le T\\le 10,~1\\le n,m\\le 4$.\n- Subtask 2 (43 pts): $1\\le T\\le 5,~1\\le n\\le 5,~1\\le m\\le 1,000$.\n- Subtask 3 (46 pts): $1\\le T\\le 10^5,~1\\le n,m\\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "WD与矩阵", "background": "WD整日沉浸在矩阵中，无法自拔……", "description": "WD 特别喜欢矩阵，尤其是 01 矩阵。\n\n一天，CX 给了 WD 一个巨大的 $n$ 行 $m$ 列的 01 矩阵，WD 发现这个矩阵每行、每列的异或值都是 0。\n\nCX 随后就问道：“WD，你知道有多少 01 矩阵每行每列异或值都是 0 吗！？”WD 当然不会这个问题，于是他来请教你。\n\n由于答案可能很大，输出结果模 $998\\,244\\,353$ 的值即可。", "inputFormat": "第一行一个数 $T$，表示数据组数。\n\n接下来 $T$ 行每行两个数 $n,m$，分别表示询问的行数和列数。", "outputFormat": "共 $T$ 行，每行一个数，表示答案对 $998\\,244\\,353$ 取模的结果。", "hint": "- subtask1（11pts）：$1\\le T\\le 10,~1\\le n,m\\le 4$\n- subtask2（43pts）：$1\\le T\\le 5,~1\\le n\\le 5,~1\\le m\\le 1,000$\n- subtask3（46pts）：$1\\le T\\le 10^5,~1\\le n,m\\le 10^9$", "locale": "zh-CN"}}}
{"pid": "P5160", "type": "P", "difficulty": 5, "samples": [["2\n2 9\n10 14", "55\n1961256"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["O2优化", "Lucas 定理"], "title": "WD与循环", "background": "WD 整日沉浸在循环中，无法自拔……", "description": "这天，WD 蒟蒻为了解决一个小问题写了个很长很长的 for 循环：\n```cpp\nint cnt = 0;\nfor (int a_1 = 0; a_1 <= m; a_1++) {\n    for (int a_2 = 0; a_1 + a_2 <= m; a_2++) {\n    ...\n        for (int a_n = 0; a_1 + a_2 + ... + a_n <= m; a_n++) {\n            cnt = (cnt + 1) % 19491001;\n        }\n    }\n}\nprintf(\"%d\\n\", cnt);\n```\nCX 过来看了一眼，说：**WD 你个笨蛋，这道题不是 SB 题吗？** WD 一脸懵逼，只好请你来教教他啦……", "inputFormat": "第一行一个数 $T$，表示数据组数。接下来每行两个数 $n,m$，分别表示循环重数和每层循环的上界。", "outputFormat": "共 $T$ 行，每行一个数表示答案。", "hint": "$\\text{subtask1}(23pts):~n,m\\le 1,000,~1\\le T\\le 10,000$\n\n$\\text{subtask2}(35pts):~n,m\\le 10^7,~1\\le T\\le 5$\n\n$\\text{subtask3}(42pts):~n,m\\le 10^{18},~1\\le T\\le 100,000$\n\n对于样例 1，写个代码就知道答案是 55 了（大雾）。", "locale": "zh-CN", "translations": {"en": {"title": "WD and Loops", "background": "WD is immersed in loops all day long and cannot break free.", "description": "One day, WD (a “juruo”, i.e., a newbie) wrote a very, very long `for` loop to solve a small problem:\n```cpp\nint cnt = 0;\nfor (int a_1 = 0; a_1 <= m; a_1++) {\n    for (int a_2 = 0; a_1 + a_2 <= m; a_2++) {\n    ...\n        for (int a_n = 0; a_1 + a_2 + ... + a_n <= m; a_n++) {\n            cnt = (cnt + 1) % 19491001;\n        }\n    }\n}\nprintf(\"%d\\n\", cnt);\n```\nCX took a look and said: **WD, you idiot, isn’t this an easy problem?** WD was completely confused, so he had to ask you to teach him.", "inputFormat": "The first line contains an integer $T$, the number of test cases. Each of the following lines contains two integers $n, m$, representing the number of nested loops and the upper bound of each loop level, respectively.", "outputFormat": "Output $T$ lines. Each line contains one integer, the answer.", "hint": "$\\text{subtask1}(23pts):~n,m\\le 1,000,~1\\le T\\le 10,000$\n\n$\\text{subtask2}(35pts):~n,m\\le 10^7,~1\\le T\\le 5$\n\n$\\text{subtask3}(42pts):~n,m\\le 10^{18},~1\\le T\\le 100,000$\n\nFor Sample 1, you can just write some code and you will know the answer is 55 (just kidding).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "WD与循环", "background": "WD 整日沉浸在循环中，无法自拔……", "description": "这天，WD 蒟蒻为了解决一个小问题写了个很长很长的 for 循环：\n```cpp\nint cnt = 0;\nfor (int a_1 = 0; a_1 <= m; a_1++) {\n    for (int a_2 = 0; a_1 + a_2 <= m; a_2++) {\n    ...\n        for (int a_n = 0; a_1 + a_2 + ... + a_n <= m; a_n++) {\n            cnt = (cnt + 1) % 19491001;\n        }\n    }\n}\nprintf(\"%d\\n\", cnt);\n```\nCX 过来看了一眼，说：**WD 你个笨蛋，这道题不是 SB 题吗？** WD 一脸懵逼，只好请你来教教他啦……", "inputFormat": "第一行一个数 $T$，表示数据组数。接下来每行两个数 $n,m$，分别表示循环重数和每层循环的上界。", "outputFormat": "共 $T$ 行，每行一个数表示答案。", "hint": "$\\text{subtask1}(23pts):~n,m\\le 1,000,~1\\le T\\le 10,000$\n\n$\\text{subtask2}(35pts):~n,m\\le 10^7,~1\\le T\\le 5$\n\n$\\text{subtask3}(42pts):~n,m\\le 10^{18},~1\\le T\\le 100,000$\n\n对于样例 1，写个代码就知道答案是 55 了（大雾）。", "locale": "zh-CN"}}}
{"pid": "P5161", "type": "P", "difficulty": 7, "samples": [["5\n1 2 3 4 5", "13"], ["10\n1 0 -1 -1 -2 -2 -3 -3 -4 -5", "65"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["O2优化"], "title": "WD与数列", "background": "WD整日沉浸在数列中，无法自拔……", "description": "WD很喜欢数列。他认为两个序列$A,B$是匹配的，当且仅当$|A|=|B|$且对于$1\\le i,j\\le |A|,A_i-B_i=A_j-B_j$.即长度相同且一个数列同时加上一个数可以和另一个数列完全一样。\n\n现在CX给了他一个长度为$n$的大数列，WD希望知道，数列中有多少对不相交的子串使得他们是匹配的。", "inputFormat": "第一行一个数$n$，表示数列长度。第二行$n$个数，表示序列中的数字。", "outputFormat": "共一行一个数，为匹配的子串个数。", "hint": "对于样例，任意两个不相交且长度相等的子串都是匹配的，长度为1时有10种，长度为2时有3种，因此总共有13种。\n\n$subtask1(11pts):~1\\le n\\le 100$\n\n$subtask2(34pts):~1\\le n\\le 1,000$\n\n$subtask3(55pts):~1\\le n\\le 300,000$\n\n对于所有数据，数列中数字的**绝对值**$\\le 10^9$。$subtask3$的时限为3s，其它为1s.", "locale": "zh-CN", "translations": {"en": {"title": "WD and Sequences", "background": "WD spends all day immersed in sequences and cannot stop.", "description": "WD really likes sequences. He thinks two sequences $A, B$ match if and only if $|A| = |B|$ and for $1 \\le i, j \\le |A|$, $A_i - B_i = A_j - B_j$. That is, they have the same length, and by adding the same number to every element of one sequence, it can become exactly the other sequence.\n\nNow CX gives him a large sequence of length $n$. WD wants to know how many pairs of non-overlapping subarrays in the sequence are matching.", "inputFormat": "The first line contains an integer $n$, representing the length of the sequence. The second line contains $n$ integers, representing the numbers in the sequence.", "outputFormat": "Output one integer in a single line, the number of matching subarrays.", "hint": "For the sample, any two non-overlapping subarrays with the same length are matching. For length $1$ there are $10$ pairs, and for length $2$ there are $3$ pairs, so there are $13$ pairs in total.\n\n$subtask1(11pts):~1\\le n\\le 100$\n\n$subtask2(34pts):~1\\le n\\le 1,000$\n\n$subtask3(55pts):~1\\le n\\le 300,000$\n\nFor all data, the **absolute value** of each number in the sequence is $\\le 10^9$. The time limit for $subtask3$ is $3\\text{s}$, and for the others it is $1\\text{s}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "WD与数列", "background": "WD整日沉浸在数列中，无法自拔……", "description": "WD很喜欢数列。他认为两个序列$A,B$是匹配的，当且仅当$|A|=|B|$且对于$1\\le i,j\\le |A|,A_i-B_i=A_j-B_j$.即长度相同且一个数列同时加上一个数可以和另一个数列完全一样。\n\n现在CX给了他一个长度为$n$的大数列，WD希望知道，数列中有多少对不相交的子串使得他们是匹配的。", "inputFormat": "第一行一个数$n$，表示数列长度。第二行$n$个数，表示序列中的数字。", "outputFormat": "共一行一个数，为匹配的子串个数。", "hint": "对于样例，任意两个不相交且长度相等的子串都是匹配的，长度为1时有10种，长度为2时有3种，因此总共有13种。\n\n$subtask1(11pts):~1\\le n\\le 100$\n\n$subtask2(34pts):~1\\le n\\le 1,000$\n\n$subtask3(55pts):~1\\le n\\le 300,000$\n\n对于所有数据，数列中数字的**绝对值**$\\le 10^9$。$subtask3$的时限为3s，其它为1s.", "locale": "zh-CN"}}}
{"pid": "P5162", "type": "P", "difficulty": 7, "samples": [["4\n1\n2\n3\n4", "1\n665496237\n307152111\n186338949"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "O2优化", "生成函数", "快速傅里叶变换 FFT", "快速数论变换 NTT"], "title": "WD与积木", "background": "WD整日沉浸在积木中，无法自拔……", "description": "WD想买 $n$ 块积木，商场中每块积木的高度都是 $1$，俯视图为正方形（边长不一定相同）。由于一些特殊原因，商家会给每个积木随机一个大小并标号，发给 WD。\n\n接下来 WD 会把相同大小的积木放在一层，并把所有层从大到小堆起来。WD 希望知道所有不同的堆法中层数的期望。**两种堆法不同当且仅当某个积木在两种堆法中处于不同的层中，由于WD只关心积木的相对大小，因此所有堆法等概率出现，而不是随机的大小等概率（可以看样例理解）。**   \n输出结果 $\\bmod \\space 998244353$ 即可。\n\n（如果还是不能够理解题意，请看样例）", "inputFormat": "第一行一个数$T$，表示询问个数。\n\n接下来 $T$ 行每行一个数 $n$，表示 WD 希望使用 $n$ 块积木。", "outputFormat": "共 $T$ 行，每行一个数表示答案 $\\bmod \\space 998244353$。", "hint": "接下来用大括号表示分在一层。\n\n对于$n=1$，合法的分法只有$\\{1\\}$；\n\n对于$n=2$，合法的序列有$\\{1,2\\}$，$\\{1\\}\\{2\\}$，$\\{2\\}\\{1\\}$，期望层数为$\\frac{1+2+2}{3}=665496237(mod~998244353)$；\n\n对于$n=3$，合法的序列有$\\{1\\}\\{2\\}\\{3\\}$，$\\{1\\}\\{3\\}\\{2\\}$，$\\{2\\}\\{1\\}\\{3\\}$，$\\{2\\}\\{3\\}\\{1\\}$，$\\{3\\}\\{1\\}\\{2\\}$，$\\{3\\}\\{2\\}\\{1\\}$\n\n$\\{1,2\\}\\{3\\}$，$\\{1,3\\}\\{2\\}$，$\\{2,3\\}\\{1\\}$，$\\{1\\}\\{2,3\\}$，$\\{2\\}\\{1,3\\}$，$\\{3\\}\\{1,2\\}$，$\\{1,2,3\\}$共13种。因此期望就是$\\frac{6\\times3+6\\times2+1}{13}=307152111(mod~998244353)$\n\n~~对于$n=4$，我想到了一个绝妙的解释，可惜这里写不下。~~\n\n$subtask1(21pts):~1\\le T\\le 1,000,~1\\le n\\le 1,000$\n\n$subtask2(37pts):~1\\le T\\le 10,~1\\le n\\le 100,000$\n\n$subtask3(42pts):~1\\le T\\le 100,000,~1\\le n\\le 100,000$", "locale": "zh-CN", "translations": {"en": {"title": "WD and Building Blocks", "background": "WD is immersed in building blocks all day and cannot stop...", "description": "WD wants to buy $n$ building blocks. In the store, each block has height $1$, and its top view is a square (the side length is not necessarily the same). For some special reasons, the seller will randomly assign each block a size and a label, and give them to WD.\n\nNext, WD will put blocks of the same size into one layer, and stack all layers from large to small. WD wants to know the expected number of layers among all different stacking methods. **Two stacking methods are different if and only if some block is in a different layer in the two methods. Since WD only cares about the relative sizes of the blocks, all stacking methods are equally likely, rather than all random size assignments being equally likely (you can understand this from the samples).**  \nOutput the result $\\bmod \\space 998244353$.\n\n(If you still cannot understand the statement, please look at the samples.)", "inputFormat": "The first line contains an integer $T$, the number of queries.\n\nThen follow $T$ lines, each containing an integer $n$, meaning WD wants to use $n$ building blocks.", "outputFormat": "Output $T$ lines. Each line contains one integer, the answer $\\bmod \\space 998244353$.", "hint": "In the following, curly braces denote blocks placed in the same layer.\n\nFor $n=1$, the only valid arrangement is $\\{1\\}$.\n\nFor $n=2$, the valid sequences are $\\{1,2\\}$, $\\{1\\}\\{2\\}$, $\\{2\\}\\{1\\}$. The expected number of layers is $\\frac{1+2+2}{3}=665496237(mod~998244353)$.\n\nFor $n=3$, the valid sequences are $\\{1\\}\\{2\\}\\{3\\}$, $\\{1\\}\\{3\\}\\{2\\}$, $\\{2\\}\\{1\\}\\{3\\}$, $\\{2\\}\\{3\\}\\{1\\}$, $\\{3\\}\\{1\\}\\{2\\}$, $\\{3\\}\\{2\\}\\{1\\}$,\n\n$\\{1,2\\}\\{3\\}$, $\\{1,3\\}\\{2\\}$, $\\{2,3\\}\\{1\\}$, $\\{1\\}\\{2,3\\}$, $\\{2\\}\\{1,3\\}$, $\\{3\\}\\{1,2\\}$, $\\{1,2,3\\}$, for a total of 13 types. Therefore, the expectation is $\\frac{6\\times3+6\\times2+1}{13}=307152111(mod~998244353)$.\n\n~~For $n=4$, I have a wonderful explanation, but unfortunately there is not enough space to write it here.~~\n\n$subtask1(21pts):~1\\le T\\le 1,000,~1\\le n\\le 1,000$\n\n$subtask2(37pts):~1\\le T\\le 10,~1\\le n\\le 100,000$\n\n$subtask3(42pts):~1\\le T\\le 100,000,~1\\le n\\le 100,000$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "WD与积木", "background": "WD整日沉浸在积木中，无法自拔……", "description": "WD想买 $n$ 块积木，商场中每块积木的高度都是 $1$，俯视图为正方形（边长不一定相同）。由于一些特殊原因，商家会给每个积木随机一个大小并标号，发给 WD。\n\n接下来 WD 会把相同大小的积木放在一层，并把所有层从大到小堆起来。WD 希望知道所有不同的堆法中层数的期望。**两种堆法不同当且仅当某个积木在两种堆法中处于不同的层中，由于WD只关心积木的相对大小，因此所有堆法等概率出现，而不是随机的大小等概率（可以看样例理解）。**   \n输出结果 $\\bmod \\space 998244353$ 即可。\n\n（如果还是不能够理解题意，请看样例）", "inputFormat": "第一行一个数$T$，表示询问个数。\n\n接下来 $T$ 行每行一个数 $n$，表示 WD 希望使用 $n$ 块积木。", "outputFormat": "共 $T$ 行，每行一个数表示答案 $\\bmod \\space 998244353$。", "hint": "接下来用大括号表示分在一层。\n\n对于$n=1$，合法的分法只有$\\{1\\}$；\n\n对于$n=2$，合法的序列有$\\{1,2\\}$，$\\{1\\}\\{2\\}$，$\\{2\\}\\{1\\}$，期望层数为$\\frac{1+2+2}{3}=665496237(mod~998244353)$；\n\n对于$n=3$，合法的序列有$\\{1\\}\\{2\\}\\{3\\}$，$\\{1\\}\\{3\\}\\{2\\}$，$\\{2\\}\\{1\\}\\{3\\}$，$\\{2\\}\\{3\\}\\{1\\}$，$\\{3\\}\\{1\\}\\{2\\}$，$\\{3\\}\\{2\\}\\{1\\}$\n\n$\\{1,2\\}\\{3\\}$，$\\{1,3\\}\\{2\\}$，$\\{2,3\\}\\{1\\}$，$\\{1\\}\\{2,3\\}$，$\\{2\\}\\{1,3\\}$，$\\{3\\}\\{1,2\\}$，$\\{1,2,3\\}$共13种。因此期望就是$\\frac{6\\times3+6\\times2+1}{13}=307152111(mod~998244353)$\n\n~~对于$n=4$，我想到了一个绝妙的解释，可惜这里写不下。~~\n\n$subtask1(21pts):~1\\le T\\le 1,000,~1\\le n\\le 1,000$\n\n$subtask2(37pts):~1\\le T\\le 10,~1\\le n\\le 100,000$\n\n$subtask3(42pts):~1\\le T\\le 100,000,~1\\le n\\le 100,000$", "locale": "zh-CN"}}}
{"pid": "P5163", "type": "P", "difficulty": 7, "samples": [["5 8 8\n4 2 1 1 3\n2 5\n4 2\n5 3\n1 3\n4 5\n5 1\n1 5\n1 4\n3 3 1\n1 4 5\n3 3 3\n3 4 1\n3 1 5\n3 2 4\n1 5 3\n2 3 4", "1\n1\n4\n10\n10"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["线段树", "O2优化", "强连通分量", "Tarjan", "整体二分", "线段树合并"], "title": "WD与地图", "background": "WD 整日沉浸在地图中，无法自拔……", "description": "CX 让 WD 研究的地图可以看做是 $n$ 个点，$m$ 条边的有向图，由于政府正在尝试优化人民生活，他们会废弃一些无用的道路来把省下的钱用于经济建设。\n\n城市都有各自的发达程度 $s_i$。为了方便管理，政府将整个地图划分为一些地区，两个点 $u,v$ 在一个地区当且仅当 $u,v$ 可以互相到达。政府希望知道一些时刻某个地区的前 $k$ 发达城市的发达程度总和，以此推断建设的情况。\n\n也就是说，共有三个操作：\n\n`1 a b` 表示政府废弃了从 $a$ 连向 $b$ 的边，保证这条边存在。\n\n`2 a b` 表示政府把钱用于建设城市 $a$，使其发达程度增加 $b$。\n\n`3 a b` 表示政府希望知道 $a$ 城市所在地区发达程度前 $b$ 大城市的发达程度之和。如果地区中的城市不足 $b$ 个输出该地区所有城市的发达程度总和。", "inputFormat": "第一行两个数 $n,m,q$，表示共 $n$ 个点，$m$ 条边，$q$ 次询问。\n\n第二行 $n$ 个正整数，表示 $s_i$，即每个城市的发达程度。\n\n接下来 $m$ 行每行两个数 $u,v$，表示初始时有一条从 $u$ 连向 $v$ 的边。\n\n接下来 $q$ 行，表示 $q$ 组询问，格式如题目描述。", "outputFormat": "对于每个询问操作，输出一个数，表示发达程度之和。", "hint": "$subtask1(19pts):~n\\le 100,000,~m\\le 200,000,~q\\le 200,000$，删除操作个数$\\times m\\le 1,000,000$\n\n$subtask2(39pts):~n\\le 5,000,~m\\le 8,000,~q\\le 200,000$\n\n$subtask3(42pts):~n\\le 100,000,~m\\le 200,000,~q\\le 200,000$\n\n保证任何时刻发达程度$\\le 10^9$，无重边（反向边不算重边）无自环。", "locale": "zh-CN", "translations": {"en": {"title": "WD and the Map.", "background": "WD spends all day immersed in maps and cannot pull himself out.", "description": "The map that CX asks WD to study can be seen as a directed graph with $n$ nodes and $m$ edges. Since the government is trying to improve people's lives, they will remove some useless roads and use the saved money for economic development.\n\nEach city has its own development level $s_i$. For easier management, the government divides the whole map into some regions. Two nodes $u, v$ are in the same region if and only if $u, v$ can reach each other. The government wants to know, at certain times, the sum of the development levels of the top $k$ most developed cities in a region, in order to judge the construction situation.\n\nThat is, there are three operations in total:\n\n`1 a b` means the government removes the edge from $a$ to $b$, and it is guaranteed that this edge exists.\n\n`2 a b` means the government invests money to build city $a$, increasing its development level by $b$.\n\n`3 a b` means the government wants to know the sum of the development levels of the top $b$ cities (by development level) in the region where city $a$ is located. If there are fewer than $b$ cities in the region, output the sum of the development levels of all cities in that region.", "inputFormat": "The first line contains three integers $n, m, q$, meaning there are $n$ nodes, $m$ edges, and $q$ queries.\n\nThe second line contains $n$ positive integers, representing $s_i$, i.e., the development level of each city.\n\nThe next $m$ lines each contain two integers $u, v$, indicating that initially there is an edge from $u$ to $v$.\n\nThe next $q$ lines describe the $q$ queries, in the format given in the description.", "outputFormat": "For each query operation, output one integer, representing the sum of development levels.", "hint": "$subtask1(19pts):~n\\le 100,000,~m\\le 200,000,~q\\le 200,000$, number of delete operations $\\times m\\le 1,000,000$.\n\n$subtask2(39pts):~n\\le 5,000,~m\\le 8,000,~q\\le 200,000$.\n\n$subtask3(42pts):~n\\le 100,000,~m\\le 200,000,~q\\le 200,000$.\n\nIt is guaranteed that at any time the development level $\\le 10^9$. There are no multiple edges (reverse edges are not considered multiple edges) and no self-loops.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "WD与地图", "background": "WD 整日沉浸在地图中，无法自拔……", "description": "CX 让 WD 研究的地图可以看做是 $n$ 个点，$m$ 条边的有向图，由于政府正在尝试优化人民生活，他们会废弃一些无用的道路来把省下的钱用于经济建设。\n\n城市都有各自的发达程度 $s_i$。为了方便管理，政府将整个地图划分为一些地区，两个点 $u,v$ 在一个地区当且仅当 $u,v$ 可以互相到达。政府希望知道一些时刻某个地区的前 $k$ 发达城市的发达程度总和，以此推断建设的情况。\n\n也就是说，共有三个操作：\n\n`1 a b` 表示政府废弃了从 $a$ 连向 $b$ 的边，保证这条边存在。\n\n`2 a b` 表示政府把钱用于建设城市 $a$，使其发达程度增加 $b$。\n\n`3 a b` 表示政府希望知道 $a$ 城市所在地区发达程度前 $b$ 大城市的发达程度之和。如果地区中的城市不足 $b$ 个输出该地区所有城市的发达程度总和。", "inputFormat": "第一行两个数 $n,m,q$，表示共 $n$ 个点，$m$ 条边，$q$ 次询问。\n\n第二行 $n$ 个正整数，表示 $s_i$，即每个城市的发达程度。\n\n接下来 $m$ 行每行两个数 $u,v$，表示初始时有一条从 $u$ 连向 $v$ 的边。\n\n接下来 $q$ 行，表示 $q$ 组询问，格式如题目描述。", "outputFormat": "对于每个询问操作，输出一个数，表示发达程度之和。", "hint": "$subtask1(19pts):~n\\le 100,000,~m\\le 200,000,~q\\le 200,000$，删除操作个数$\\times m\\le 1,000,000$\n\n$subtask2(39pts):~n\\le 5,000,~m\\le 8,000,~q\\le 200,000$\n\n$subtask3(42pts):~n\\le 100,000,~m\\le 200,000,~q\\le 200,000$\n\n保证任何时刻发达程度$\\le 10^9$，无重边（反向边不算重边）无自环。", "locale": "zh-CN"}}}
{"pid": "P5164", "type": "P", "difficulty": 5, "samples": [["3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": [], "title": "xtq的定向越野", "background": "xtq在定向越野方面有异于常人的天赋，小学一年级时就获得了“题刷杯”的第一名和“蝈蝈杯”的“蝈蝈”。有一天，他正在研究一个问题。", "description": "xtq希望设计一个圆形地图，这可以视作一个圆，圆周上有任意多个互不重叠的打卡点，打卡点上有一些任务。\n\n设所有可能的任务为一个$k$元集合，则这个集合有$2^k$个互不相同子集，设为$A_1,A_2......A_{2^k}$，那么每一个打卡点上都有且仅有$A_1,A_2......A_{2^k}$中的一个任务子集。注意：不同的点可以有相同的任务子集。\n\nxtq想要满足以下条件：\n\n$1$:对于满足$||Ai|-|Aj||=1$的任意子集$Ai$，$Aj$，都有且仅有一对相邻打卡点的任务子集为$Ai$、$Aj$\n\n$2$:对于任意相邻的点上的子集$Ai$，$Aj$，均满足$||Ai|-|Aj||=1$\n\n现在xtq给了你一个$n$，希望让你求出所有可能的$2\\le k\\le n$，使得至少存在一种放置打卡点和任务的方案。\n\n在以上的描述中，$|Ai|$表示$|Ai|$的元素个数，$|a+b|$表示$a+b$的绝对值", "inputFormat": "一个正整数$n$。", "outputFormat": "若干行，每行一个正整数，表示一个可能的$k$，按大小升序排列。", "hint": "[样例解释]\n\n当$k=2$时，设所有可能的任务是$\\{1,2\\}$，则任务的4个子集是$\\emptyset$,$\\{1\\}$,$\\{2\\}$,$\\{1,2\\}$。下图是一种符合条件的方案：\n\n![](https://cdn.luogu.com.cn/upload/pic/45633.png)\n\n图中$\\{\\emptyset\\}$应当为$\\emptyset$(typo)\n\n[数据范围]\n\n对于$50\\%$的数据，$n\\le 5000$。\n\n对于$100\\%$的数据，属于$long long$范围内，并且$2\\le n$。", "locale": "zh-CN", "translations": {"en": {"title": "xtq's Orienteering", "background": "xtq has an unusual talent for orienteering. In first grade, he won first place in the \"Problem-Solving Cup\" and also won the \"Cricket Cup\" \"cricket\". One day, he was studying a problem.", "description": "xtq wants to design a circular map, which can be seen as a circle. On the circumference, there are any number of non-overlapping checkpoints, and each checkpoint has some tasks.\n\nLet all possible tasks form a $k$-element set. Then this set has $2^k$ distinct subsets, denoted as $A_1,A_2......A_{2^k}$. Each checkpoint has exactly one task subset among $A_1,A_2......A_{2^k}$. Note that different checkpoints may have the same task subset.\n\nxtq wants to satisfy the following conditions:\n\n$1$: For any subsets $Ai$, $Aj$ satisfying $||Ai|-|Aj||=1$, there exists exactly one pair of adjacent checkpoints whose task subsets are $Ai$ and $Aj$.\n\n$2$: For any adjacent checkpoints with subsets $Ai$, $Aj$, it always holds that $||Ai|-|Aj||=1$.\n\nNow xtq gives you an $n$, and he wants you to find all possible $2\\le k\\le n$ such that there exists at least one way to place checkpoints and assign tasks.\n\nIn the above description, $|Ai|$ denotes the number of elements in $|Ai|$, and $|a+b|$ denotes the absolute value of $a+b$.", "inputFormat": "One positive integer $n$.", "outputFormat": "Output several lines. Each line contains one positive integer, representing a possible $k$, in increasing order.", "hint": "[Sample Explanation]\n\nWhen $k=2$, suppose all possible tasks are $\\{1,2\\}$. Then the 4 subsets of tasks are $\\emptyset$, $\\{1\\}$, $\\{2\\}$, $\\{1,2\\}$. The following figure shows one valid arrangement:\n\n![](https://cdn.luogu.com.cn/upload/pic/45633.png)\n\nIn the figure, $\\{\\emptyset\\}$ should be $\\emptyset$ (typo).\n\n[Constraints]\n\nFor $50\\%$ of the testdata, $n\\le 5000$.\n\nFor $100\\%$ of the testdata, $n$ fits in the range of $long long$, and $2\\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "xtq的定向越野", "background": "xtq在定向越野方面有异于常人的天赋，小学一年级时就获得了“题刷杯”的第一名和“蝈蝈杯”的“蝈蝈”。有一天，他正在研究一个问题。", "description": "xtq希望设计一个圆形地图，这可以视作一个圆，圆周上有任意多个互不重叠的打卡点，打卡点上有一些任务。\n\n设所有可能的任务为一个$k$元集合，则这个集合有$2^k$个互不相同子集，设为$A_1,A_2......A_{2^k}$，那么每一个打卡点上都有且仅有$A_1,A_2......A_{2^k}$中的一个任务子集。注意：不同的点可以有相同的任务子集。\n\nxtq想要满足以下条件：\n\n$1$:对于满足$||Ai|-|Aj||=1$的任意子集$Ai$，$Aj$，都有且仅有一对相邻打卡点的任务子集为$Ai$、$Aj$\n\n$2$:对于任意相邻的点上的子集$Ai$，$Aj$，均满足$||Ai|-|Aj||=1$\n\n现在xtq给了你一个$n$，希望让你求出所有可能的$2\\le k\\le n$，使得至少存在一种放置打卡点和任务的方案。\n\n在以上的描述中，$|Ai|$表示$|Ai|$的元素个数，$|a+b|$表示$a+b$的绝对值", "inputFormat": "一个正整数$n$。", "outputFormat": "若干行，每行一个正整数，表示一个可能的$k$，按大小升序排列。", "hint": "[样例解释]\n\n当$k=2$时，设所有可能的任务是$\\{1,2\\}$，则任务的4个子集是$\\emptyset$,$\\{1\\}$,$\\{2\\}$,$\\{1,2\\}$。下图是一种符合条件的方案：\n\n![](https://cdn.luogu.com.cn/upload/pic/45633.png)\n\n图中$\\{\\emptyset\\}$应当为$\\emptyset$(typo)\n\n[数据范围]\n\n对于$50\\%$的数据，$n\\le 5000$。\n\n对于$100\\%$的数据，属于$long long$范围内，并且$2\\le n$。", "locale": "zh-CN"}}}
{"pid": "P5165", "type": "P", "difficulty": 6, "samples": [["3 1 1 3", "13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "矩阵加速"], "title": "xtq的棋盘", "background": "自从二年级起，xtq就热爱棋类游戏。", "description": "xtq有一个$1$行，$n+1$列的棋盘，从左到右编号为$0$到$n$。初始时刻，在$m$位置有一颗棋子。\n\nxtq会在接下来的时间里随机操作。具体地说，如果某一秒棋子不位于$n$，那么他将有$prb$的概率将棋子向左移动一格，$1-prb$的概率向右移动一格；否则，他必然将棋子向左移动一格。\n\n现在xtq想问你，期望多少秒之后棋子能够到达$0$。由于答案可能很大，并且为了避免不必要的精度误差，你只需要给出答案对于$10^9+7$取模的结果即可（可以证明，答案必然是一个有理数）。", "inputFormat": "一行四个正整数$n,m,p,q$。\n\n其中，$p,q$表示$prb = \\frac{p}{q}$。", "outputFormat": "一行，一个正整数，表示期望移动次数对$10^9+7$取模的结果。", "hint": "对于$20\\%$的数据，$n\\le 4, 1\\le p\\le q\\le 4$而且保证答案在取模前是一个整数。\n\n对于$40\\%$的数据，$n\\le 300$。\n\n对于$70\\%$的数据，$n\\le 1000000$。\n\n对于$100\\%$的数据，$1\\le m\\le n\\le 10^9, 1\\le p\\le q\\le 10^9$并且$p,q$互质。\n\n此外，在全部的数据点中，有$30\\%$的数据是满足$prb = \\frac{1}{2}$的。\n\n有理数对质数$p$取模定义如下：\n\n设$\\frac{a}{b}$对$p$取模的结果为$x$，那么需要满足$0\\le x<p$且$a \\equiv bx (mod p)$。\n\n保证对于$100\\%$的数据，一定存在满足要求的$x$。", "locale": "zh-CN", "translations": {"en": {"title": "xtq's Chessboard", "background": "Since second grade, xtq has loved board games.", "description": "xtq has a chessboard with $1$ row and $n+1$ columns, numbered from $0$ to $n$ from left to right. At the initial moment, there is a piece at position $m$.\n\nxtq will perform random operations over time. Specifically, if in a given second the piece is not at $n$, then with probability $prb$ he moves the piece one cell to the left, and with probability $1-prb$ he moves it one cell to the right; otherwise (when the piece is at $n$), he will definitely move the piece one cell to the left.\n\nNow xtq wants to ask you: what is the expected number of seconds until the piece can reach $0$? Since the answer may be very large, and to avoid unnecessary precision errors, you only need to output the answer modulo $10^9+7$ (it can be proven that the answer must be a rational number).", "inputFormat": "One line with four positive integers $n, m, p, q$.\n\nHere, $p, q$ mean $prb = \\frac{p}{q}$.", "outputFormat": "One line with one positive integer, representing the expected number of moves modulo $10^9+7$.", "hint": "For $20\\%$ of the testdata, $n\\le 4$, $1\\le p\\le q\\le 4$, and it is guaranteed that the answer is an integer before taking modulo.\n\nFor $40\\%$ of the testdata, $n\\le 300$.\n\nFor $70\\%$ of the testdata, $n\\le 1000000$.\n\nFor $100\\%$ of the testdata, $1\\le m\\le n\\le 10^9$, $1\\le p\\le q\\le 10^9$, and $p, q$ are coprime.\n\nIn addition, among all testdata points, $30\\%$ of the testdata satisfies $prb = \\frac{1}{2}$.\n\nThe modulo of a rational number with respect to a prime $p$ is defined as follows:\n\nLet the result of $\\frac{a}{b}$ modulo $p$ be $x$. Then it must satisfy $0\\le x<p$ and $a \\equiv bx (mod p)$.\n\nIt is guaranteed that for $100\\%$ of the testdata, such an $x$ satisfying the requirements always exists.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "xtq的棋盘", "background": "自从二年级起，xtq就热爱棋类游戏。", "description": "xtq有一个$1$行，$n+1$列的棋盘，从左到右编号为$0$到$n$。初始时刻，在$m$位置有一颗棋子。\n\nxtq会在接下来的时间里随机操作。具体地说，如果某一秒棋子不位于$n$，那么他将有$prb$的概率将棋子向左移动一格，$1-prb$的概率向右移动一格；否则，他必然将棋子向左移动一格。\n\n现在xtq想问你，期望多少秒之后棋子能够到达$0$。由于答案可能很大，并且为了避免不必要的精度误差，你只需要给出答案对于$10^9+7$取模的结果即可（可以证明，答案必然是一个有理数）。", "inputFormat": "一行四个正整数$n,m,p,q$。\n\n其中，$p,q$表示$prb = \\frac{p}{q}$。", "outputFormat": "一行，一个正整数，表示期望移动次数对$10^9+7$取模的结果。", "hint": "对于$20\\%$的数据，$n\\le 4, 1\\le p\\le q\\le 4$而且保证答案在取模前是一个整数。\n\n对于$40\\%$的数据，$n\\le 300$。\n\n对于$70\\%$的数据，$n\\le 1000000$。\n\n对于$100\\%$的数据，$1\\le m\\le n\\le 10^9, 1\\le p\\le q\\le 10^9$并且$p,q$互质。\n\n此外，在全部的数据点中，有$30\\%$的数据是满足$prb = \\frac{1}{2}$的。\n\n有理数对质数$p$取模定义如下：\n\n设$\\frac{a}{b}$对$p$取模的结果为$x$，那么需要满足$0\\le x<p$且$a \\equiv bx (mod p)$。\n\n保证对于$100\\%$的数据，一定存在满足要求的$x$。", "locale": "zh-CN"}}}
