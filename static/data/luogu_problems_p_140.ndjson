{"pid": "P3836", "type": "P", "difficulty": 7, "samples": [["4 5 5\n....#\n.#..#\n...#.\n....#", ".X.X#\n.#..#\n...#X\nXX..#\n\n//这是其中一个有效的输出\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["搜索", "贪心", "2017", "IOI", "提交答案", "Special Judge", "深度优先搜索 DFS"], "title": "[IOI 2017] Nowruz", "background": "**[数据以及 checker ](http://pan.baidu.com/s/1o8jwPmy)【已搬运至附件】**", "description": "再过几天就是诺鲁孜节了（波斯人的新年），爷爷邀请他的全家人到他的花园来聚会。在众多的宾客中有 $k$ 个小孩。为了让这些孩子们在聚会中更开心，爷爷打算让他们玩一个捉迷藏的游戏。\n\n整个花园可以看成一个有 $m\\times n$ 个方格的网格。其中有一些（或许没有）方格被岩石堵住了，而剩下的方格就称为**空格**。如果两个格子共享同一条边，我们就称这两个格子是**邻居**。因此，每一个方格最多有 $4$ 个邻居：两个水平方向的和两个垂直方向的。爷爷想把花园变成一个迷宫。为达此目的，他会在花园中的一些**空格**上种植灌木来堵住他们。而这些被灌木丛堵住的方格就不再是**空格**了。\n\n一个迷宫必须具有下面所述的性质。在迷宫中的任意一对空格 $a$ 和 $b$ 之间都只会恰有唯一的一条简单路径相连。而这条由 $a$ 到 $b$ 的简单路径就是一个从空格 $a$ 开始并以空格 $b$ 结束的序列，序列中所有的方格必须是不同的，而且每个相连的方格都是邻居。\n\n一个小孩能够躲藏的方格当且仅当这个方格是**空格**，而且它恰有唯一一个邻居是空格。同一个空格内只能躲藏一个小孩。\n\n题目会给出整个花园的地图作为输入文件。你的任务就是帮助爷爷构造一个能够躲藏尽量多小孩的迷宫。\n\n\n## 评分\n\n一个**有效**的输出文件必须符合下列所有的条件：\n\n- 除了把输入文件中的任意多个字母 `.` 修改成字母 `X`（即被灌木堵塞）外，输出的地图必须和输入地图完全一样。\n\n- 输出的地图必须符合在上文中提及的迷宫的所有性质。\n\n\n对于某一个测试数据，如果你的输出不是**有效**的，你的这个测试数据的得分将会是 $0$。反之，你的得分是 $\\min(10, 10\\cdot l/k)$，向下取值至小数后二位，这里的 $l$ 是指你输出的迷宫中能够最多藏着的小孩，而 $k$ 则表示在输入文件中题目要求你躲藏的小孩数目。对于一个测试数据，你能够得到 $10$ 分，当且仅当你的输入是一个能够躲藏 $k$ 个或更多个小孩的迷宫。\n\n对于每组测试数据都存在一个能得到 $10$ 分的答案。\n\n请注意如果你答案是有效的，但根据上述公式你的得分仍然是 $0$ 分，则在评分系统中，现实的结果将会是 'Wrong Answer'。", "inputFormat": "这是一个提交答案型的题目，而且它有部份分。题目会给出 $10$ 个描述爷爷花园的输入文件。对于每个输入文件你应该提交一个含有迷宫的地图作为输出文件我们会根据你提交的每个输入文件中的迷宫能够躲藏的小孩数目来给出你的分数。\n\n这道题目你不需要提交任何源代码。\n\n每个输入文件都描述了一个表示整个花园的网格，我们也会给出爷爷邀请的小孩数目 $k$。格式如下：\n\n第 $1$ 行：$m \\ n \\ k$。\n\n第 $1+i\\ (1 \\leqslant i \\leqslant m)$ 行：网格中的第 $i$ 行，它是一个长度为 $n$ 的字符串，包含以下的字符（中间没有空格）：\n\n- `.`： 一个空格，\n\n- `#`： 一块岩石。", "outputFormat": "第 $i\\ (1 \\leqslant i \\leqslant m)$ 行：迷宫中的第 $i$ 行（种植了树木的花园）。它是一个长度为 $n$ 的字符串，包含以下字母（中间没有空格）：\n\n\\* `.` ： 一个空格，\n\n\\* `#`： 一块岩石，\n\n\\* `X`： 一个灌木（注意字母X必须为大写字母）。", "hint": "样例输出是其中一个有效的输出。\n\n对于这个输出，因为 $l=4$ 个小孩能够这个迷宫中，所以这个解答能够得到 $10 \\cdot 4 / 5 = 8$ 分。小孩能够躲藏的方格如下以 `O` 所示：\n\n```plain\nOXOX#\n.#.O#\n...#X\nXX.O#\n```\n以下的三个输出都不是有效的输出：\n\n```plain\n.XXX#    ...X#    XXXX#\n.#XX#    .#.X#    X#XX#\n...#.    ...#X    ..X#X\nXX..#    XXXX#    ..XX#\n```\n在最左边的输出中，左上角的空格和最右列（位于右下方）的空格之间并没有一条简单路径。\n\n在其他的两个输出中，对于任意两个空格之间都恰有两条简单路径相连。\n\n\n## 限制条件\n\n$1 \\leqslant m,n \\leqslant 1024$。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2017] Nowruz", "background": "[Data and checker](http://pan.baidu.com/s/1o8jwPmy) [moved to attachments].", "description": "Nowruz (the Persian New Year) is in a few days. Grandfather has invited his whole family to gather in his garden. Among the many guests, there are $k$ children. To make the party more fun for them, Grandfather plans to let them play hide-and-seek.\n\nThe entire garden can be seen as an $m \\times n$ grid of cells. Some cells (possibly none) are blocked by rocks; the remaining cells are called empty cells. If two cells share a side, they are called neighbors. Therefore, each cell has at most $4$ neighbors: two horizontal and two vertical. Grandfather wants to turn the garden into a maze. To do this, he will plant bushes on some empty cells to block them; those cells then cease to be empty.\n\nA maze must satisfy the following property: for any pair of empty cells $a$ and $b$, there is exactly one simple path between them. A simple path from $a$ to $b$ is a sequence of distinct cells starting at empty cell $a$ and ending at empty cell $b$, where every two consecutive cells are neighbors.\n\nA child can hide in a cell if and only if the cell is empty and it has exactly one empty neighbor. At most one child can hide in a single empty cell.\n\nYou are given a map of the entire garden. Your task is to help Grandfather construct a maze that allows as many children as possible to hide.\n\n# Scoring\n\nA valid output file must satisfy all of the following:\n\n- Apart from changing any number of `.` characters in the input to `X` (i.e., planting bushes), the output map must be identical to the input map.\n- The output map must satisfy all the maze properties stated above.\n\nFor a given testdata, if your output is not valid, your score for this testdata is $0$. Otherwise, your score is $\\min(10, 10 \\cdot l / k)$, rounded down to two decimal places, where $l$ is the maximum number of children that can hide in your output maze, and $k$ is the number of children specified in the input file. You receive $10$ points for a testdata if and only if your output maze can hide at least $k$ children.\n\nFor every testdata there exists a solution worth $10$ points.\n\nNote: If your output is valid but the above formula still yields a score of $0$, the judging system will display “Wrong Answer”.", "inputFormat": "This is an output-only problem with partial scoring. There are $10$ input files describing Grandfather’s garden. For each input file, you should submit an output file containing a maze map. Your score is based on the number of children that can hide in the maze you submit for each input file.\n\nYou do not need to submit any source code.\n\nEach input file describes the garden grid and gives the number of invited children $k$, in the following format:\n\nLine $1$: $m \\ n \\ k$.\n\nLine $1 + i$ ($1 \\leqslant i \\leqslant m$): the $i$-th row of the grid, a string of length $n$ with no spaces, consisting of:\n- `.`: an empty cell,\n- `#`: a rock.", "outputFormat": "Line $i$ ($1 \\leqslant i \\leqslant m$): the $i$-th row of the maze (the garden after planting bushes). It is a string of length $n$ with no spaces, consisting of:\n- `.`: an empty cell,\n- `#`: a rock,\n- `X`: a bush (note that the letter X must be uppercase).", "hint": "The sample output is one valid output.\n\nFor this output, since $l = 4$ children can hide in the maze, the score is $10 \\cdot 4 / 5 = 8$. The cells where children can hide are marked with `O` below:\n\n```plain\nOXOX#\n.#.O#\n...#X\nXX.O#\n```\n\nThe following three outputs are invalid:\n\n```plain\n.XXX#    ...X#    XXXX#\n.#XX#    .#.X#    X#XX#\n...#.    ...#X    ..X#X\nXX..#    XXXX#    ..XX#\n```\n\nIn the leftmost output, there is no simple path between the empty cell in the top-left corner and the empty cell in the rightmost column near the bottom-right.\n\nIn each of the other two outputs, there are two simple paths between some pair of empty cells.\n\n# Constraints\n\n$1 \\leqslant m, n \\leqslant 1024$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2017] Nowruz", "background": "**[数据以及 checker ](http://pan.baidu.com/s/1o8jwPmy)【已搬运至附件】**", "description": "再过几天就是诺鲁孜节了（波斯人的新年），爷爷邀请他的全家人到他的花园来聚会。在众多的宾客中有 $k$ 个小孩。为了让这些孩子们在聚会中更开心，爷爷打算让他们玩一个捉迷藏的游戏。\n\n整个花园可以看成一个有 $m\\times n$ 个方格的网格。其中有一些（或许没有）方格被岩石堵住了，而剩下的方格就称为**空格**。如果两个格子共享同一条边，我们就称这两个格子是**邻居**。因此，每一个方格最多有 $4$ 个邻居：两个水平方向的和两个垂直方向的。爷爷想把花园变成一个迷宫。为达此目的，他会在花园中的一些**空格**上种植灌木来堵住他们。而这些被灌木丛堵住的方格就不再是**空格**了。\n\n一个迷宫必须具有下面所述的性质。在迷宫中的任意一对空格 $a$ 和 $b$ 之间都只会恰有唯一的一条简单路径相连。而这条由 $a$ 到 $b$ 的简单路径就是一个从空格 $a$ 开始并以空格 $b$ 结束的序列，序列中所有的方格必须是不同的，而且每个相连的方格都是邻居。\n\n一个小孩能够躲藏的方格当且仅当这个方格是**空格**，而且它恰有唯一一个邻居是空格。同一个空格内只能躲藏一个小孩。\n\n题目会给出整个花园的地图作为输入文件。你的任务就是帮助爷爷构造一个能够躲藏尽量多小孩的迷宫。\n\n\n## 评分\n\n一个**有效**的输出文件必须符合下列所有的条件：\n\n- 除了把输入文件中的任意多个字母 `.` 修改成字母 `X`（即被灌木堵塞）外，输出的地图必须和输入地图完全一样。\n\n- 输出的地图必须符合在上文中提及的迷宫的所有性质。\n\n\n对于某一个测试数据，如果你的输出不是**有效**的，你的这个测试数据的得分将会是 $0$。反之，你的得分是 $\\min(10, 10\\cdot l/k)$，向下取值至小数后二位，这里的 $l$ 是指你输出的迷宫中能够最多藏着的小孩，而 $k$ 则表示在输入文件中题目要求你躲藏的小孩数目。对于一个测试数据，你能够得到 $10$ 分，当且仅当你的输入是一个能够躲藏 $k$ 个或更多个小孩的迷宫。\n\n对于每组测试数据都存在一个能得到 $10$ 分的答案。\n\n请注意如果你答案是有效的，但根据上述公式你的得分仍然是 $0$ 分，则在评分系统中，现实的结果将会是 'Wrong Answer'。", "inputFormat": "这是一个提交答案型的题目，而且它有部份分。题目会给出 $10$ 个描述爷爷花园的输入文件。对于每个输入文件你应该提交一个含有迷宫的地图作为输出文件我们会根据你提交的每个输入文件中的迷宫能够躲藏的小孩数目来给出你的分数。\n\n这道题目你不需要提交任何源代码。\n\n每个输入文件都描述了一个表示整个花园的网格，我们也会给出爷爷邀请的小孩数目 $k$。格式如下：\n\n第 $1$ 行：$m \\ n \\ k$。\n\n第 $1+i\\ (1 \\leqslant i \\leqslant m)$ 行：网格中的第 $i$ 行，它是一个长度为 $n$ 的字符串，包含以下的字符（中间没有空格）：\n\n- `.`： 一个空格，\n\n- `#`： 一块岩石。", "outputFormat": "第 $i\\ (1 \\leqslant i \\leqslant m)$ 行：迷宫中的第 $i$ 行（种植了树木的花园）。它是一个长度为 $n$ 的字符串，包含以下字母（中间没有空格）：\n\n\\* `.` ： 一个空格，\n\n\\* `#`： 一块岩石，\n\n\\* `X`： 一个灌木（注意字母X必须为大写字母）。", "hint": "样例输出是其中一个有效的输出。\n\n对于这个输出，因为 $l=4$ 个小孩能够这个迷宫中，所以这个解答能够得到 $10 \\cdot 4 / 5 = 8$ 分。小孩能够躲藏的方格如下以 `O` 所示：\n\n```plain\nOXOX#\n.#.O#\n...#X\nXX.O#\n```\n以下的三个输出都不是有效的输出：\n\n```plain\n.XXX#    ...X#    XXXX#\n.#XX#    .#.X#    X#XX#\n...#.    ...#X    ..X#X\nXX..#    XXXX#    ..XX#\n```\n在最左边的输出中，左上角的空格和最右列（位于右下方）的空格之间并没有一条简单路径。\n\n在其他的两个输出中，对于任意两个空格之间都恰有两条简单路径相连。\n\n\n## 限制条件\n\n$1 \\leqslant m,n \\leqslant 1024$。", "locale": "zh-CN"}}}
{"pid": "P3837", "type": "P", "difficulty": 6, "samples": [["r = [1, 2, 3, 7]\nb = [0, 4, 5, 9, 10]", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "贪心", "2017", "IOI", "交互题", "模拟费用流"], "title": "[IOI 2017] Wiring", "background": "这是一道交互题。\n\n本题仅支持 C++ 系列语言，提交时不需要包含 `wiring.h` 头文件，但需要在程序开头包含 `vector` 头文件以及声明函数 `long long min_total_length(std::vector<int> r, std::vector<int> b)`。\n\n**由于不可名状的 BUG，使用 C++14 (GCC9) 提交会导致 CE，请不要使用其提交。**", "description": "Maryam 是一位电机工程师。她正在为一座通讯塔设计接线方案。在这个塔上有一些分布在不同高度的连接点。一条电线可以用来将任何两个连接点连接起来。每一个连接点都可以接上任意数目的电线。而连接点共有两种：分别为红色连接点及蓝色连接点。\n\n为了表述方便起见，通讯塔会被视为一条直线，而那些红色及蓝色连接点会被视为在这条直线上的一些非负整数坐标。一条电线的长度是该电线所连接的两个连接点间的距离。\n\n你要做的是帮 Maryam 找出一个接线的方案，使得满足以下条件：\n\n1. 每个连接点上最少有一条电线连接到一个不同颜色的连接点上\n\n2. 所用的电线的总长为最短。\n\n\n## 实现细节\n\n你需要实现以下的子程序：\n\n`long long min_total_length(std::vector<int> r, std::vector<int> b)`\n\n- $r$：一个长度为 $n$ 的数组，其内以升序排列着所有红色连接点的位置。\n\n- $b$：一个长度为 $m$ 的数组，其内以升序排列着所有蓝色连接点的位置。\n\n- 这个子程序需返回在所有可能的连接方案中，最短电线总长度的那个方案的电线作为其返回值。\n\n- 请注意这个子程序的返回值的类型为 `long long` 。\n", "inputFormat": "你需要实现上面所述的子程序。\n", "outputFormat": "返回一个 `long long` 值。\n", "hint": "样例中函数传递参数：\n\n`min_total_length([1, 2, 3, 7], [0, 4, 5, 9, 10])`\n\n以下的图表表述了样例中的数据。\n\n ![](https://cdn.luogu.com.cn/upload/pic/6724.png) \n\n- 图中以水平的方式表示出相关的通讯塔。\n\n- 因题目打印是黑白色的，所以红色接点以较深色来表示，而蓝色接点则以较浅色来表示。\n\n- 图中有 $4$ 个红色的连接点，其位置分别为 $1,2,3$ 及 $7$ 。\n\n- 图中有 $5$ 个蓝色的连接点，其位置分别为 $0,4,5,9$ 及 $10$ 。\n\n- 该例的最优解的电线总长度为 $1+2+2+2+3=10$ ，所以子程序的返回值为 $10$ 。\n\n- 请注意共有两条电线连接在位置为 $7$ 的连接点上。\n\n\n## 限制条件\n\n- $1 \\leqslant n,m \\leqslant 100000$\n\n- $0 \\leqslant r[i] \\leqslant 10^9 $（对于所有$0 \\leqslant i \\leqslant n-1$）\n\n- $0 \\leqslant b[i] \\leqslant 10^9$（对于所有$0 \\leqslant i \\leqslant m-1$）\n\n- 数组$r$及数组$b$都已经按升序排好序。\n\n- 在数组$r$及$b$内的所有$n+m$个值均是不同的。\n\n\n## 子任务\n\n1. ($7$ 分)  $n,m\\leqslant 200$。\n\n2. ($13$ 分)  所有红色接点的位置坐标小于任何蓝色接点的坐标。\n\n3. ($10$ 分)  在每$7$个连续的（接续）的连接点内必有最少一个红色接点及蓝色接点。\n\n4. ($25$ 分)  所有接点在$[1,n+m]$范围内有不同的位置坐标。\n\n5. ($45$ 分)  没有任何附加的限制。\n", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2017] Wiring", "background": "This is a library problem.\n\nThis problem supports only C++ languages. You do not need to include the header file `wiring.h` when submitting, but you must include the `vector` header and declare the function `long long min_total_length(std::vector<int> r, std::vector<int> b)` at the beginning of your program.\n\nDue to an indescribable bug, submitting with C++14 (GCC9) will cause CE. Please do not use it.", "description": "Maryam is an electrical engineer. She is designing a wiring plan for a communication tower. There are connectors placed at various heights on this tower. A wire can be used to connect any two connectors. Each connector may be connected to any number of wires. There are two types of connectors: red connectors and blue connectors.\n\nFor convenience, the tower is regarded as a straight line, and the red and blue connectors are located at some non-negative integer coordinates on this line. The length of a wire is the distance between the two connectors it connects.\n\nYour task is to help Maryam find a wiring plan that satisfies the following:\n\n1. Each connector has at least one wire connected to a connector of the opposite color.\n2. The total length of the wires is minimized.\n\nImplementation details:\n\nYou need to implement the following subroutine:\n\n`long long min_total_length(std::vector<int> r, std::vector<int> b)`\n\n- $r$: an array of length $n$, containing the positions of all red connectors in ascending order.\n- $b$: an array of length $m$, containing the positions of all blue connectors in ascending order.\n- This subroutine should return the minimal total length of wires among all valid wirings.\n- Note that the return type of this subroutine is `long long`.\n\nConstraints:\n\n- $1 \\leqslant n,m \\leqslant 100000$.\n- $0 \\leqslant r[i] \\leqslant 10^9$ (for all $0 \\leqslant i \\leqslant n-1$).\n- $0 \\leqslant b[i] \\leqslant 10^9$ (for all $0 \\leqslant i \\leqslant m-1$).\n- The arrays $r$ and $b$ are already sorted in ascending order.\n- All $n+m$ values in $r$ and $b$ are distinct.\n\nSubtasks:\n\n1. ($7$ points) $n,m\\leqslant 200$.\n2. ($13$ points) All red connector positions are smaller than any blue connector position.\n3. ($10$ points) In every $7$ consecutive connectors, there is at least one red connector and one blue connector.\n4. ($25$ points) All connectors have distinct positions in the range $[1,n+m]$.\n5. ($45$ points) No additional constraints.", "inputFormat": "You need to implement the subroutine described above.", "outputFormat": "Return a `long long` value.", "hint": "Sample function call:\n\n`min_total_length([1, 2, 3, 7], [0, 4, 5, 9, 10])`\n\nThe following figure illustrates the sample data.\n\n![](https://cdn.luogu.com.cn/upload/pic/6724.png)\n\n- The tower is drawn horizontally.\n- Because the statement is printed in black and white, red connectors are drawn darker, and blue connectors lighter.\n- There are $4$ red connectors at positions $1, 2, 3$, and $7$.\n- There are $5$ blue connectors at positions $0, 4, 5, 9$, and $10$.\n- The optimal total wire length is $1+2+2+2+3=10$, so the subroutine should return $10$.\n- Note that there are two wires incident to the connector at position $7$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2017] Wiring", "background": "这是一道交互题。\n\n本题仅支持 C++ 系列语言，提交时不需要包含 `wiring.h` 头文件，但需要在程序开头包含 `vector` 头文件以及声明函数 `long long min_total_length(std::vector<int> r, std::vector<int> b)`。\n\n**由于不可名状的 BUG，使用 C++14 (GCC9) 提交会导致 CE，请不要使用其提交。**", "description": "Maryam 是一位电机工程师。她正在为一座通讯塔设计接线方案。在这个塔上有一些分布在不同高度的连接点。一条电线可以用来将任何两个连接点连接起来。每一个连接点都可以接上任意数目的电线。而连接点共有两种：分别为红色连接点及蓝色连接点。\n\n为了表述方便起见，通讯塔会被视为一条直线，而那些红色及蓝色连接点会被视为在这条直线上的一些非负整数坐标。一条电线的长度是该电线所连接的两个连接点间的距离。\n\n你要做的是帮 Maryam 找出一个接线的方案，使得满足以下条件：\n\n1. 每个连接点上最少有一条电线连接到一个不同颜色的连接点上\n\n2. 所用的电线的总长为最短。\n\n\n## 实现细节\n\n你需要实现以下的子程序：\n\n`long long min_total_length(std::vector<int> r, std::vector<int> b)`\n\n- $r$：一个长度为 $n$ 的数组，其内以升序排列着所有红色连接点的位置。\n\n- $b$：一个长度为 $m$ 的数组，其内以升序排列着所有蓝色连接点的位置。\n\n- 这个子程序需返回在所有可能的连接方案中，最短电线总长度的那个方案的电线作为其返回值。\n\n- 请注意这个子程序的返回值的类型为 `long long` 。\n", "inputFormat": "你需要实现上面所述的子程序。\n", "outputFormat": "返回一个 `long long` 值。\n", "hint": "样例中函数传递参数：\n\n`min_total_length([1, 2, 3, 7], [0, 4, 5, 9, 10])`\n\n以下的图表表述了样例中的数据。\n\n ![](https://cdn.luogu.com.cn/upload/pic/6724.png) \n\n- 图中以水平的方式表示出相关的通讯塔。\n\n- 因题目打印是黑白色的，所以红色接点以较深色来表示，而蓝色接点则以较浅色来表示。\n\n- 图中有 $4$ 个红色的连接点，其位置分别为 $1,2,3$ 及 $7$ 。\n\n- 图中有 $5$ 个蓝色的连接点，其位置分别为 $0,4,5,9$ 及 $10$ 。\n\n- 该例的最优解的电线总长度为 $1+2+2+2+3=10$ ，所以子程序的返回值为 $10$ 。\n\n- 请注意共有两条电线连接在位置为 $7$ 的连接点上。\n\n\n## 限制条件\n\n- $1 \\leqslant n,m \\leqslant 100000$\n\n- $0 \\leqslant r[i] \\leqslant 10^9 $（对于所有$0 \\leqslant i \\leqslant n-1$）\n\n- $0 \\leqslant b[i] \\leqslant 10^9$（对于所有$0 \\leqslant i \\leqslant m-1$）\n\n- 数组$r$及数组$b$都已经按升序排好序。\n\n- 在数组$r$及$b$内的所有$n+m$个值均是不同的。\n\n\n## 子任务\n\n1. ($7$ 分)  $n,m\\leqslant 200$。\n\n2. ($13$ 分)  所有红色接点的位置坐标小于任何蓝色接点的坐标。\n\n3. ($10$ 分)  在每$7$个连续的（接续）的连接点内必有最少一个红色接点及蓝色接点。\n\n4. ($25$ 分)  所有接点在$[1,n+m]$范围内有不同的位置坐标。\n\n5. ($45$ 分)  没有任何附加的限制。\n", "locale": "zh-CN"}}}
{"pid": "P3838", "type": "P", "difficulty": 7, "samples": [["a = [0, 1]\nr = [1, 0]\nu = [0, 0, 1, 1]\nv = [0, 1, 0, 1]", "who_wins = [1, 1]"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2017", "IOI", "交互题"], "title": "[IOI 2017] Toy Train", "background": "### 由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。\n\n这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。", "description": "Arezou 和她的兄弟 Borzou 是双胞胎。他们收到的生日礼物是一套好玩的玩具火车。他们用它建了一下 $n$ 个车站和 $m$ 段单向轨道的铁路系统。这些车站的编号是从 $0$ 到 $n-1$。每段轨道都始于某一车站，然后终于同一车站或其他车站。每个车站至少会有一段轨道以它为起点。\n\n其中有些车站是充电车站。无论何时，如果火车抵达某个充电车站。无论何时，如果火车抵达某个充电车站，它都会被充到满电。满电火车拥有足够的动力连续地试过 $n$ 段轨道，但是如果不再充电的话，在即将进入第 $n+1$ 段轨道时它就会因电已用光而停车。\n\n每个车站都有一个轨道开关，可以扳向任一以该车站为起点的轨道。火车从某个车站驶出时，驶向的正是该车站的开关所扳向的轨道。\n\n这对双胞胎打算用他们的火车玩个游戏。他们已经分完了所有的车站：每个车站要么归 Arezou，要么归 Borzou。游戏里面只有一列火车。游戏开始时，这列火车停在车站 $s$ ，并且充满了电。为启动游戏，车站 $s$ 的拥有者把车站 $s$ 的开关扳向某个以 $s$ 为起点的轨道。随后他们启动火车，火车也就开始沿着轨道行驶。无论何时，在火车首次进入某一车站时，该车站的拥有者都要扳定车站开关。开关一旦扳定，它就会保持状态不变直到游戏结束。因此，火车如果开到了一个曾经进过的车站，就会沿着与之前相同的轨道开出该车站。\n\n由于车站数量是有限的，火车的行驶最终都会落入某个环路。环路是指一系列**不同**的车站 $c_0,c_1,\\cdots ,c_{k-1}$，其中火车在离开车站 $c_i\\ \\ (0\\leqslant i < k-1)$ 后驶上连向车站 $c_{i+1}$ 的轨道，在离开车站 $c_{k-1}$ 后驶上连向车站 $c_0$ 的轨道。一个环路可能只包括一个车站（此时 $k=1$），即火车从车站 $c_0$ 驶出后又驶上了连向车站 $c_0$ 的轨道。\n\n如果火车能够连续行驶跑完，Arezou 就赢了。否则火车最后会把电用光而停车，这样 Borzou 就赢了。换句话说，如果 $c_0,c_1,\\cdots ,c_{k-1}$中至少有一个充电车站，且使得火车能够不断地充电而沿着环路跑个没完，Arezou 赢。否则，它就会最终把电用光（有可能是在沿着环路跑好几圈后），Borzou 赢。\n\n现在给你一个这样的铁路系统。Arezou 和 Borzou将会玩 $n$ 轮游戏。其中在第 $s$ 轮游戏中（$0\\leqslant s \\leqslant n-1$），火车最初停在车站 $s$ 上。你的任务是，对每一轮游戏，判断是否无论 Borzou 怎么玩，Arezou 都必胜。\n\n## 实现细节\n\n你需要实现下面的函数\n\n(C++) `std::vector who_wins(std::vector<int> a, std::vector<int> r, std::vector<int> u, std::vector<int> v)`\n\n(Java) `int[] who_wins(int[] a, int[] r, int[] u, int[] v)`\n\n- $a$：长度为 $n$ 的数组。如果 Arezou 拥有车站 $i$，则 $a_i=1$；否则 Borzou 拥有车站 $i$，且 $a_i=0$。\n\n- $r$：长度为$n$的数组。如果车站$i$是充电车站，则$r[i]=1$。否则$r[i]=0$。\n\n- $u$ 和 $v$：长度为 $m$ 的数组。对于所有 $0\\leqslant i \\leqslant m-1$，存在某一单向轨道，其起点为 $u_i$，终点为 $v_i$。\n\n- 该函数需要返回一个长度为 $n$ 的数组  $w$。对于每个 $0\\leqslant i \\leqslant n-1$，如果在火车最初停在车站 $i$ 的游戏中，不管 Borzou 怎么玩，Arezou 都能赢，则 $w_i$ 的值应为 $1$。否则 $w_i$ 的值应为 $0$。\n", "inputFormat": "你需要实现上述子程序。\n", "outputFormat": "你的子程序需要返回一个合法的结果。\n", "hint": " ![](https://cdn.luogu.com.cn/upload/pic/6727.png) \n\n- 这里有 $2$ 个车站。Borzou 拥有充电车站 $1$。Arezou拥有充电车站 $1$，但是它不是充电车站。\n\n- 这里有 $4$ 段轨道 $(0,0),(0,1),(1,0)$ 和 $(1,1)$，其中 $(i,j)$ 表示一个以车站 $i$ 为起点、车站$j$为终点的单向轨道。\n\n- 考虑火车最初停在车站 $0$ 的游戏。如果 Borzou 将车站 $0$ 的开关扳向轨道 $(0,0)$，那么火车就会沿着这个环形轨道绕个没完（注意，车站 $0$ 是一个充电车站）。在这种情况下，Arezou 赢。否则，如果 Borzou 把车站 $0$ 的开关扳向轨道 $(0,1)$，Arezou 可以把车站 $1$ 的开关扳向轨道 $(1,0)$。这样的话，火车将会在两个车站之间绕个不停。Arezou 还是会赢，因为车站$0$是充电车站，火车将跑个没完。因此，无论 Borzou 怎么玩，Arezou 都会赢。\n\n- 根据类似的逻辑，在火车最初停在车站 $1$ 的游戏中，无论 Borzou 怎么玩，Arezou 也都会赢。因此，函数应当返回 $[1,1]$。\n\n\n## 数据范围和限制\n\n- $1\\leqslant n \\leqslant 5000$\n- $n \\leqslant m \\leqslant 20000$\n- 至少会有一个充电车站。\n- 每个车站至少会有一段轨道以它为起点。\n- 可能会有某个轨道的起点和终点是相同的（即 $u_i=v_i$）。\n- 所有轨道两两不同。也就是说，不存在这样的两个下标 $i$ 和 $j$（$0\\leqslant i < j \\leqslant m-1$），使得 $u_i=u_j$ 且 $v_i=v_j$。\n- 对于所有 $0\\leqslant i \\leqslant m-1$，都有 $0\\leqslant u_i,v_i \\leqslant n-1$。\n\n## 子任务\n\n1. ($5$ 分) 对于所有 $0 \\leqslant i \\leqslant m-1$，都有 $v_i=u_i$ 或者 $v_i=u_i+1$。\n2. ($10$ 分) $n\\leqslant 15$。\n3. ($11$ 分) Arezou 拥有所有车站。\n4. ($11$ 分) Borzou 拥有所有车站。\n5. ($12$ 分) 充电车站的数量为 $1$。\n6. ($51$ 分) 无任何限制。\n", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2017] Toy Train", "background": "Due to technical limitations, please do not submit this problem using C++ 14 (GCC 9).\n\nThis is an interactive-style problem; you only need to implement the function required in the statement.\n\nYour code does not need to include any additional headers, nor implement the main function.", "description": "Arezou and her brother Borzou are twins. Their birthday present is a fun toy train set. They built a railway system with $n$ stations and $m$ directed tracks. The stations are numbered from $0$ to $n - 1$. Each track starts at some station and ends at the same station or another station. Every station has at least one outgoing track.\n\nSome stations are charging stations. Whenever the train arrives at a charging station, it is fully recharged. A fully charged train has enough power to traverse $n$ tracks in a row; without recharging, it will stop right before entering the $(n + 1)$-st track.\n\nEach station has a track switch that can be set to any one of its outgoing tracks. When the train departs a station, it follows the track currently selected by that station’s switch.\n\nThe twins plan to play a game with their train. They have divided the stations between them: each station belongs either to Arezou or to Borzou. There is only one train in the game. At the start, the train is at station $s$ and fully charged. To start the game, the owner of station $s$ sets its switch to one of its outgoing tracks. Then they start the train, and it begins moving along the tracks. Whenever the train enters a station for the first time, the owner of that station must set its switch. Once a switch is set, it remains fixed until the game ends. Therefore, if the train visits a station again, it will leave along the same track as before.\n\nSince the number of stations is finite, the train’s movement will eventually enter a cycle. A cycle is a sequence of distinct stations $c_0, c_1, \\dots, c_{k - 1}$ such that after leaving station $c_i$ for $0 \\leqslant i < k - 1$ the train takes the track to $c_{i + 1}$, and after leaving $c_{k - 1}$ it takes the track to $c_0$. A cycle may consist of a single station ($k = 1$), i.e., the train leaves station $c_0$ and immediately takes the track back to $c_0$.\n\nIf the train can keep running forever, Arezou wins. Otherwise, the train will eventually run out of power and stop, so Borzou wins. In other words, if there is at least one charging station among $c_0, c_1, \\dots, c_{k - 1}$ so that the train can keep getting recharged and run around the cycle forever, then Arezou wins. Otherwise, even if the train loops several times, it will eventually run out of power, and Borzou wins.\n\nYou are given such a railway system. Arezou and Borzou will play $n$ rounds. In round $s$ ($0 \\leqslant s \\leqslant n - 1$), the train initially starts at station $s$. Your task is to determine, for each round, whether Arezou wins no matter how Borzou plays.\n\nImplementation details:\n\nYou need to implement the following function:\n\n(C++) `std::vector<int> who_wins(std::vector<int> a, std::vector<int> r, std::vector<int> u, std::vector<int> v)`\n\n(Java) `int[] who_wins(int[] a, int[] r, int[] u, int[] v)`\n\n- $a$: an array of length $n$. If Arezou owns station $i$, then $a[i] = 1$; otherwise Borzou owns station $i$, and $a[i] = 0$.\n- $r$: an array of length $n$. If station $i$ is a charging station, then $r[i] = 1$; otherwise $r[i] = 0$.\n- $u$ and $v$: arrays of length $m$. For every $0 \\leqslant i \\leqslant m - 1$, there is a directed track that starts at $u[i]$ and ends at $v[i]$.\n- The function should return an array $w$ of length $n$. For every $0 \\leqslant i \\leqslant n - 1$, if in the game starting at station $i$ Arezou can win regardless of how Borzou plays, then $w[i] = 1$. Otherwise, $w[i] = 0$.", "inputFormat": "You need to implement the subroutine described above.", "outputFormat": "Your subroutine must return a valid result.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/6727.png)\n\n- There are 2 stations. Station 0 is a charging station owned by Borzou. Station 1 is owned by Arezou and is not a charging station.\n- There are 4 directed tracks: (0, 0), (0, 1), (1, 0), and (1, 1), where (i, j) denotes a track from station i to station j.\n- Consider the game starting at station 0. If Borzou sets station 0’s switch to (0, 0), the train will loop there forever (note that station 0 is a charging station). In this case, Arezou wins. Otherwise, if Borzou sets station 0’s switch to (0, 1), then Arezou can set station 1’s switch to (1, 0). The train will then loop between the two stations. Arezou still wins because station 0 is a charging station, so the train runs forever. Therefore, regardless of how Borzou plays, Arezou wins.\n- By a similar argument, in the game starting at station 1, Arezou also wins no matter how Borzou plays. Therefore, the function should return [1, 1].\n\n# Constraints\n\n- $1 \\leqslant n \\leqslant 5000$.\n- $n \\leqslant m \\leqslant 20000$.\n- There is at least one charging station.\n- Every station has at least one outgoing track.\n- It is possible that a track starts and ends at the same station (i.e., $u[i] = v[i]$).\n- All tracks are pairwise distinct. That is, there do not exist indices $i$ and $j$ ($0 \\leqslant i < j \\leqslant m - 1$) such that $u[i] = u[j]$ and $v[i] = v[j]$.\n- For all $0 \\leqslant i \\leqslant m - 1$, $0 \\leqslant u[i], v[i] \\leqslant n - 1$.\n\n# Subtasks\n\n1. (5 points) For all $0 \\leqslant i \\leqslant m - 1$, $v[i] = u[i]$ or $v[i] = u[i] + 1$.\n2. (10 points) $n \\leqslant 15$.\n3. (11 points) Arezou owns all stations.\n4. (11 points) Borzou owns all stations.\n5. (12 points) The number of charging stations is $1$.\n6. (51 points) No additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2017] Toy Train", "background": "### 由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。\n\n这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。", "description": "Arezou 和她的兄弟 Borzou 是双胞胎。他们收到的生日礼物是一套好玩的玩具火车。他们用它建了一下 $n$ 个车站和 $m$ 段单向轨道的铁路系统。这些车站的编号是从 $0$ 到 $n-1$。每段轨道都始于某一车站，然后终于同一车站或其他车站。每个车站至少会有一段轨道以它为起点。\n\n其中有些车站是充电车站。无论何时，如果火车抵达某个充电车站。无论何时，如果火车抵达某个充电车站，它都会被充到满电。满电火车拥有足够的动力连续地试过 $n$ 段轨道，但是如果不再充电的话，在即将进入第 $n+1$ 段轨道时它就会因电已用光而停车。\n\n每个车站都有一个轨道开关，可以扳向任一以该车站为起点的轨道。火车从某个车站驶出时，驶向的正是该车站的开关所扳向的轨道。\n\n这对双胞胎打算用他们的火车玩个游戏。他们已经分完了所有的车站：每个车站要么归 Arezou，要么归 Borzou。游戏里面只有一列火车。游戏开始时，这列火车停在车站 $s$ ，并且充满了电。为启动游戏，车站 $s$ 的拥有者把车站 $s$ 的开关扳向某个以 $s$ 为起点的轨道。随后他们启动火车，火车也就开始沿着轨道行驶。无论何时，在火车首次进入某一车站时，该车站的拥有者都要扳定车站开关。开关一旦扳定，它就会保持状态不变直到游戏结束。因此，火车如果开到了一个曾经进过的车站，就会沿着与之前相同的轨道开出该车站。\n\n由于车站数量是有限的，火车的行驶最终都会落入某个环路。环路是指一系列**不同**的车站 $c_0,c_1,\\cdots ,c_{k-1}$，其中火车在离开车站 $c_i\\ \\ (0\\leqslant i < k-1)$ 后驶上连向车站 $c_{i+1}$ 的轨道，在离开车站 $c_{k-1}$ 后驶上连向车站 $c_0$ 的轨道。一个环路可能只包括一个车站（此时 $k=1$），即火车从车站 $c_0$ 驶出后又驶上了连向车站 $c_0$ 的轨道。\n\n如果火车能够连续行驶跑完，Arezou 就赢了。否则火车最后会把电用光而停车，这样 Borzou 就赢了。换句话说，如果 $c_0,c_1,\\cdots ,c_{k-1}$中至少有一个充电车站，且使得火车能够不断地充电而沿着环路跑个没完，Arezou 赢。否则，它就会最终把电用光（有可能是在沿着环路跑好几圈后），Borzou 赢。\n\n现在给你一个这样的铁路系统。Arezou 和 Borzou将会玩 $n$ 轮游戏。其中在第 $s$ 轮游戏中（$0\\leqslant s \\leqslant n-1$），火车最初停在车站 $s$ 上。你的任务是，对每一轮游戏，判断是否无论 Borzou 怎么玩，Arezou 都必胜。\n\n## 实现细节\n\n你需要实现下面的函数\n\n(C++) `std::vector who_wins(std::vector<int> a, std::vector<int> r, std::vector<int> u, std::vector<int> v)`\n\n(Java) `int[] who_wins(int[] a, int[] r, int[] u, int[] v)`\n\n- $a$：长度为 $n$ 的数组。如果 Arezou 拥有车站 $i$，则 $a_i=1$；否则 Borzou 拥有车站 $i$，且 $a_i=0$。\n\n- $r$：长度为$n$的数组。如果车站$i$是充电车站，则$r[i]=1$。否则$r[i]=0$。\n\n- $u$ 和 $v$：长度为 $m$ 的数组。对于所有 $0\\leqslant i \\leqslant m-1$，存在某一单向轨道，其起点为 $u_i$，终点为 $v_i$。\n\n- 该函数需要返回一个长度为 $n$ 的数组  $w$。对于每个 $0\\leqslant i \\leqslant n-1$，如果在火车最初停在车站 $i$ 的游戏中，不管 Borzou 怎么玩，Arezou 都能赢，则 $w_i$ 的值应为 $1$。否则 $w_i$ 的值应为 $0$。\n", "inputFormat": "你需要实现上述子程序。\n", "outputFormat": "你的子程序需要返回一个合法的结果。\n", "hint": " ![](https://cdn.luogu.com.cn/upload/pic/6727.png) \n\n- 这里有 $2$ 个车站。Borzou 拥有充电车站 $1$。Arezou拥有充电车站 $1$，但是它不是充电车站。\n\n- 这里有 $4$ 段轨道 $(0,0),(0,1),(1,0)$ 和 $(1,1)$，其中 $(i,j)$ 表示一个以车站 $i$ 为起点、车站$j$为终点的单向轨道。\n\n- 考虑火车最初停在车站 $0$ 的游戏。如果 Borzou 将车站 $0$ 的开关扳向轨道 $(0,0)$，那么火车就会沿着这个环形轨道绕个没完（注意，车站 $0$ 是一个充电车站）。在这种情况下，Arezou 赢。否则，如果 Borzou 把车站 $0$ 的开关扳向轨道 $(0,1)$，Arezou 可以把车站 $1$ 的开关扳向轨道 $(1,0)$。这样的话，火车将会在两个车站之间绕个不停。Arezou 还是会赢，因为车站$0$是充电车站，火车将跑个没完。因此，无论 Borzou 怎么玩，Arezou 都会赢。\n\n- 根据类似的逻辑，在火车最初停在车站 $1$ 的游戏中，无论 Borzou 怎么玩，Arezou 也都会赢。因此，函数应当返回 $[1,1]$。\n\n\n## 数据范围和限制\n\n- $1\\leqslant n \\leqslant 5000$\n- $n \\leqslant m \\leqslant 20000$\n- 至少会有一个充电车站。\n- 每个车站至少会有一段轨道以它为起点。\n- 可能会有某个轨道的起点和终点是相同的（即 $u_i=v_i$）。\n- 所有轨道两两不同。也就是说，不存在这样的两个下标 $i$ 和 $j$（$0\\leqslant i < j \\leqslant m-1$），使得 $u_i=u_j$ 且 $v_i=v_j$。\n- 对于所有 $0\\leqslant i \\leqslant m-1$，都有 $0\\leqslant u_i,v_i \\leqslant n-1$。\n\n## 子任务\n\n1. ($5$ 分) 对于所有 $0 \\leqslant i \\leqslant m-1$，都有 $v_i=u_i$ 或者 $v_i=u_i+1$。\n2. ($10$ 分) $n\\leqslant 15$。\n3. ($11$ 分) Arezou 拥有所有车站。\n4. ($11$ 分) Borzou 拥有所有车站。\n5. ($12$ 分) 充电车站的数量为 $1$。\n6. ($51$ 分) 无任何限制。\n", "locale": "zh-CN"}}}
{"pid": "P3839", "type": "P", "difficulty": 6, "samples": [["8\n\n0 3\n\n0 1\n\n1 2\n\n0 0\n\n2 1\n\n2 1\n\n1 0\n\n3 0", "\n? 0\n\n? 1\n\n? 2\n\n? 3\n\n? 4\n\n? 5\n\n? 6\n\n? 7\n\n! 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2017", "线段树", "二分", "IOI", "交互题", "Special Judge", "分块"], "title": "[IOI 2017] The Big Prize", "background": "如果你习惯于写函数式交互，以下内容可能对你有帮助：\n\n```cpp\nvector<int>ask(int i)\n{\n\tprintf(\"? %d\\n\",i);fflush(stdout);\n\tvector<int>ret(2);\n\tscanf(\"%d%d\",&ret[0],&ret[1]);\n\treturn ret;\n}\nint find_best(int n)\n{\n\t//\n}\nmain()\n{\n\tint n;scanf(\"%d\",&n);\n\tprintf(\"! %d\\n\",find_best(n));\n}\n```\n\n无论如何，你都不应引入额外的头文件。", "description": "“大奖”是一个家喻户晓的 TV 游戏节目。这次你很幸运地进入到最后一轮。已知编号从 $0$ 到 $n-1$ 的 $n$ 个盒子从左到右排成一行，你就站在这排盒子的前面。每个盒子里面放有一个奖品，必须打开盒子才能看到是什么奖品。已知有 $v\\leq5$ 种不同类型的奖品。这 $v$ 种类型按照奖品价值的降序从 $1$ 到 $v$ 排列。\n\n类型 $1$ 的奖品是一块钻石，价值最高。所有盒子加起来刚好只有一块钻石。类型 $v$ 的奖品是一块棒棒糖，价值最低。为使得游戏更加激动人心，相对便宜的奖品数量远比价值昂贵的奖品数量要多。更具体一点，对于满足 $2\\leq t \\leq v$ 的所有 $t$，我们有： 如果类型 $t-1$ 的奖品有 $k$ 个，那么类型 $t$ 的奖品将严格多于 $k^2$ 个。\n\n你的目标是赢得那块钻石。在游戏结束时，你必须打开一个盒子并收取盒子内的奖品。在选择要打开的盒子之前，你可以向节目主持人 Rambod 提一些问题。在每一个问题中，你选择就某个 $i$ 号盒子进行提问。Rambod 将给你一个包含两个整数的数组 $a$ 作为回答。这两个整数的意义如下：\n\n- 在 $i$ 号盒子左面的盒子中，刚好有 $a[0]$ 个盒子中的奖品，价值比 $i$ 号盒子中的奖品价值要高。\n- 在 $i$ 号盒子右面的盒子中，刚好有 $a[1]$ 个盒子中的奖品，价值比 $i$ 号盒子中的奖品价值要高。\n\n例如，假设 $n=8$，在你的问题中，你选择就 $i=2$ 号盒子进行提问。Rambod 的回答是 $a=[1,2]$。这个回答的意义是：\n\n- $0$ 号盒子和 $1$ 号盒子中恰好有一个盒子中的奖品比 $i$ 号盒子中的奖品更贵。\n- 在 $3,4,\\cdots,7$ 号盒子中恰好有 $2$ 个盒子中的奖品比 $2$ 号盒子中的奖品更贵。\n\n你的任务就是通过问少量的问题找出包含钻石的盒子。", "inputFormat": "你的程序开始运行时，应当读入一个正整数 $n$。\n\n你可以按以下格式发起询问：\n\n- `? i`  \n\t意为你选择就 $i$ 号盒子进行提问。你需要保证 $0\\leq i<n$。  \n\t随后你应当读入两个整数 `a[0] a[1]`，是交互库对你的回答。\n\n你可以按以下格式报告答案：\n\n- `! i`  \n\t意为你确定 $i$ 号盒子内有钻石。  \n    随后你应当立刻结束你的程序。", "outputFormat": "在发起询问后，不要忘记刷新缓冲区。你可以使用：\n\n- `fflush(stdout)` or `cout.flush()` in C++;\n- `stdout.flush()` in Python;  \n- 对于其他语言，参阅其文档。", "hint": "### 样例解释\n\n```plain\n8\n3 2 3 1 3 3 2 3\n```\n\n![](https://cdn.luogu.com.cn/upload/pic/6728.png)\n\n上图阐释了这个例子。图中上半部分给出了每个盒子中奖品的类型。图中的下半部分阐释了询问 `? 2`。\n\n### 限制\n\n- $3\\leq n \\leq200000$.\n- 每个盒子中奖品的类型介于 $1$ 和 $v$ 之间（含）。\n- 类型 $1$ 的奖品恰有一个。\n- 对于所有 $2\\leq t \\leq v$，如果类型 $t-1$ 的奖品有 $k$ 个，那么类型 $t$ 的奖品将严格多于 $k^2$ 个。\n\n\n### 子任务与评分\n\n1.  （$20$ 分）恰好有 $1$ 个钻石和 $n-1$ 个棒棒糖 （所以，$v=2$）。你可以询问最多 $10000$ 次。\n2.  （$80$ 分）没有附加限制。\n\n\n在子任务 2 中你可以获得部分分。令 $q$ 是在这个子任务的所有测试数据上发起询问的最大次数，那么你在这个子任务上的得分将按照下表计算：\n\n|询问次数      |得分        |\n|:--------:|:--------:|\n|$q>10000$ |$0$（在 CMS 中报告为 `Wrong Answer`）|\n|$6000<q\\le10000$|$70$      |\n|$5000<q\\le6000$|$80-\\dfrac{q-5000}{100}$|\n|$q\\le5000$|$80$      |", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2017] The Big Prize", "background": "If you are used to writing functional-style interaction, the following may help you:\n\n```cpp\nvector<int>ask(int i)\n{\n\tprintf(\"? %d\\n\",i);fflush(stdout);\n\tvector<int>ret(2);\n\tscanf(\"%d%d\",&ret[0],&ret[1]);\n\treturn ret;\n}\nint find_best(int n)\n{\n\t//\n}\nmain()\n{\n\tint n;scanf(\"%d\",&n);\n\tprintf(\"! %d\\n\",find_best(n));\n}\n```\n\nIn any case, you must not include any extra header files.", "description": "“The Big Prize” is a well-known TV game show. This time you are lucky to reach the final round. There are $n$ boxes in a row from left to right, numbered from $0$ to $n-1$, and you are standing in front of them. Each box contains exactly one prize, and you must open a box to see which prize it holds. There are $v\\leq5$ distinct types of prizes. These $v$ types are ordered from $1$ to $v$ in decreasing order of value.\n\nThe type $1$ prize is a diamond, the most valuable. Across all boxes there is exactly one diamond. The type $v$ prize is a lollipop, the least valuable. To make the game more exciting, cheaper prizes are far more numerous than expensive prizes. More specifically, for every $t$ with $2\\leq t \\leq v$, if there are $k$ prizes of type $t-1$, then there are strictly more than $k^2$ prizes of type $t$.\n\nYour goal is to win the diamond. At the end of the game, you must open one box and take the prize inside. Before choosing which box to open, you may ask the host, Rambod, some questions. In each question, you choose a box index $i$. Rambod answers with an array $a$ of two integers. They mean:\n\n- Among the boxes to the left of box $i$, there are exactly $a[0]$ boxes whose prizes are more valuable than the prize in box $i$.\n- Among the boxes to the right of box $i$, there are exactly $a[1]$ boxes whose prizes are more valuable than the prize in box $i$.\n\nFor example, suppose $n=8$, and in your query you choose $i=2$. Rambod’s answer is $a=[1,2]$. This means:\n\n- Among boxes $0$ and $1$, exactly one box has a prize more valuable than the prize in box $2$.\n- Among boxes $3,4,\\cdots,7$, exactly $2$ boxes have prizes more valuable than the prize in box $2$.\n\nYour task is to find the box containing the diamond by asking as few questions as possible.", "inputFormat": "When your program starts, it should read a positive integer $n$.\n\nYou may issue queries in the following format:\n\n- `? i`  \n  Meaning you choose to ask about box $i$. You must ensure $0\\leq i<n$.  \n  Then you should read two integers `a[0] a[1]`, which is the interactor’s response.\n\nYou may report your answer in the following format:\n\n- `! i`  \n  Meaning you are certain that the diamond is in box $i$.  \n  Then you must terminate your program immediately.", "outputFormat": "After issuing a query, do not forget to flush the output buffer. You may use:\n\n- `fflush(stdout)` or `cout.flush()` in C++.\n- `stdout.flush()` in Python.\n- For other languages, refer to their documentation.", "hint": "### Sample explanation\n\n```plain\n8\n3 2 3 1 3 3 2 3\n```\n\n![](https://cdn.luogu.com.cn/upload/pic/6728.png)\n\nThe figure illustrates this example. The upper part shows the prize type in each box. The lower part illustrates the query `? 2`.\n\n### Constraints\n\n- $3\\leq n \\leq200000$.\n- The prize type in each box is between $1$ and $v$ (inclusive).\n- There is exactly one type $1$ prize.\n- For all $2\\leq t \\leq v$, if there are $k$ prizes of type $t-1$, then there are strictly more than $k^2$ prizes of type $t$.\n\n### Subtasks and Scoring\n\n1. (20 points) There is exactly $1$ diamond and $n-1$ lollipops (so $v=2$). You may ask at most $10000$ queries.\n2. (80 points) No additional constraints.\n\nIn subtask 2 you can receive partial credit. Let $q$ be the maximum number of queries you use over all testdata in this subtask; then your score for this subtask is computed as follows:\n\n| Queries      | Score        |\n|:------------:|:------------:|\n| $q>10000$    | $0$ (reported as `Wrong Answer` in CMS) |\n| $6000<q\\le10000$ | $70$      |\n| $5000<q\\le6000$  | $80-\\dfrac{q-5000}{100}$ |\n| $q\\le5000$       | $80$      |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2017] The Big Prize", "background": "如果你习惯于写函数式交互，以下内容可能对你有帮助：\n\n```cpp\nvector<int>ask(int i)\n{\n\tprintf(\"? %d\\n\",i);fflush(stdout);\n\tvector<int>ret(2);\n\tscanf(\"%d%d\",&ret[0],&ret[1]);\n\treturn ret;\n}\nint find_best(int n)\n{\n\t//\n}\nmain()\n{\n\tint n;scanf(\"%d\",&n);\n\tprintf(\"! %d\\n\",find_best(n));\n}\n```\n\n无论如何，你都不应引入额外的头文件。", "description": "“大奖”是一个家喻户晓的 TV 游戏节目。这次你很幸运地进入到最后一轮。已知编号从 $0$ 到 $n-1$ 的 $n$ 个盒子从左到右排成一行，你就站在这排盒子的前面。每个盒子里面放有一个奖品，必须打开盒子才能看到是什么奖品。已知有 $v\\leq5$ 种不同类型的奖品。这 $v$ 种类型按照奖品价值的降序从 $1$ 到 $v$ 排列。\n\n类型 $1$ 的奖品是一块钻石，价值最高。所有盒子加起来刚好只有一块钻石。类型 $v$ 的奖品是一块棒棒糖，价值最低。为使得游戏更加激动人心，相对便宜的奖品数量远比价值昂贵的奖品数量要多。更具体一点，对于满足 $2\\leq t \\leq v$ 的所有 $t$，我们有： 如果类型 $t-1$ 的奖品有 $k$ 个，那么类型 $t$ 的奖品将严格多于 $k^2$ 个。\n\n你的目标是赢得那块钻石。在游戏结束时，你必须打开一个盒子并收取盒子内的奖品。在选择要打开的盒子之前，你可以向节目主持人 Rambod 提一些问题。在每一个问题中，你选择就某个 $i$ 号盒子进行提问。Rambod 将给你一个包含两个整数的数组 $a$ 作为回答。这两个整数的意义如下：\n\n- 在 $i$ 号盒子左面的盒子中，刚好有 $a[0]$ 个盒子中的奖品，价值比 $i$ 号盒子中的奖品价值要高。\n- 在 $i$ 号盒子右面的盒子中，刚好有 $a[1]$ 个盒子中的奖品，价值比 $i$ 号盒子中的奖品价值要高。\n\n例如，假设 $n=8$，在你的问题中，你选择就 $i=2$ 号盒子进行提问。Rambod 的回答是 $a=[1,2]$。这个回答的意义是：\n\n- $0$ 号盒子和 $1$ 号盒子中恰好有一个盒子中的奖品比 $i$ 号盒子中的奖品更贵。\n- 在 $3,4,\\cdots,7$ 号盒子中恰好有 $2$ 个盒子中的奖品比 $2$ 号盒子中的奖品更贵。\n\n你的任务就是通过问少量的问题找出包含钻石的盒子。", "inputFormat": "你的程序开始运行时，应当读入一个正整数 $n$。\n\n你可以按以下格式发起询问：\n\n- `? i`  \n\t意为你选择就 $i$ 号盒子进行提问。你需要保证 $0\\leq i<n$。  \n\t随后你应当读入两个整数 `a[0] a[1]`，是交互库对你的回答。\n\n你可以按以下格式报告答案：\n\n- `! i`  \n\t意为你确定 $i$ 号盒子内有钻石。  \n    随后你应当立刻结束你的程序。", "outputFormat": "在发起询问后，不要忘记刷新缓冲区。你可以使用：\n\n- `fflush(stdout)` or `cout.flush()` in C++;\n- `stdout.flush()` in Python;  \n- 对于其他语言，参阅其文档。", "hint": "### 样例解释\n\n```plain\n8\n3 2 3 1 3 3 2 3\n```\n\n![](https://cdn.luogu.com.cn/upload/pic/6728.png)\n\n上图阐释了这个例子。图中上半部分给出了每个盒子中奖品的类型。图中的下半部分阐释了询问 `? 2`。\n\n### 限制\n\n- $3\\leq n \\leq200000$.\n- 每个盒子中奖品的类型介于 $1$ 和 $v$ 之间（含）。\n- 类型 $1$ 的奖品恰有一个。\n- 对于所有 $2\\leq t \\leq v$，如果类型 $t-1$ 的奖品有 $k$ 个，那么类型 $t$ 的奖品将严格多于 $k^2$ 个。\n\n\n### 子任务与评分\n\n1.  （$20$ 分）恰好有 $1$ 个钻石和 $n-1$ 个棒棒糖 （所以，$v=2$）。你可以询问最多 $10000$ 次。\n2.  （$80$ 分）没有附加限制。\n\n\n在子任务 2 中你可以获得部分分。令 $q$ 是在这个子任务的所有测试数据上发起询问的最大次数，那么你在这个子任务上的得分将按照下表计算：\n\n|询问次数      |得分        |\n|:--------:|:--------:|\n|$q>10000$ |$0$（在 CMS 中报告为 `Wrong Answer`）|\n|$6000<q\\le10000$|$70$      |\n|$5000<q\\le6000$|$80-\\dfrac{q-5000}{100}$|\n|$q\\le5000$|$80$      |", "locale": "zh-CN"}}}
{"pid": "P3842", "type": "P", "difficulty": 3, "samples": [["6\n2 6\n3 4\n1 3\n1 2\n3 6\n4 5", "24"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2007", "各省省选", "天津"], "title": "[TJOI2007] 线段", "background": null, "description": "在一个 $n \\times n$ 的平面上，在每一行中有一条线段，第 $i$ 行的线段的左端点是 $(i, L_{i})$，右端点是 $(i, R_{i})$。\n\n你从 $(1,1)$ 点出发，要求沿途走过所有的线段，最终到达 $(n,n)$ 点，且所走的路程长度要尽量短。\n\n更具体一些说，你在任何时候只能选择向下走一步（行数增加 $1$）、向左走一步（列数减少 $1$）或是向右走一步（列数增加 $1$）。当然，由于你不能向上行走，因此在从任何一行向下走到另一行的时候，你必须保证已经走完本行的那条线段。", "inputFormat": "第一行有一个整数 $n$。\n\n以下 $n$ 行，在第 $i$ 行（总第 $(i+1)$ 行）的两个整数表示 $L_i$ 和 $R_i$。", "outputFormat": "仅包含一个整数，你选择的最短路程的长度。", "hint": "我们选择的路线是\n\n```\n (1, 1) (1, 6)\n (2, 6) (2, 3)\n (3, 3) (3, 1)\n (4, 1) (4, 2)\n (5, 2) (5, 6)\n (6, 6) (6, 4) (6, 6)\n```\n不难计算得到，路程的总长度是 $24$。 \n\n对于 $100\\%$ 的数据，$1\\le n \\le 2 \\times 10^4$，$1 \\le L_i \\le R_i \\le n$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2007] Line Segments", "background": "", "description": "On an $n \\times n$ grid, there is a line segment in each row. In row $i$, the segment’s left endpoint is $(i, L_i)$ and its right endpoint is $(i, R_i)$.\n\nYou start from $(1, 1)$, must traverse all the segments along the way, and finally reach $(n, n)$, with the total distance traveled as short as possible.\n\nMore specifically, at any time you may only move one step down (row index increases by $1$), one step left (column index decreases by $1$), or one step right (column index increases by $1$). Since you cannot move up, when moving down from any row to the next, you must ensure you have already completely traversed the segment in the current row.", "inputFormat": "The first line contains an integer $n$.\n\nEach of the next $n$ lines contains two integers. In the $i$-th of these lines (the overall $(i+1)$-th line), the integers denote $L_i$ and $R_i$.", "outputFormat": "Output a single integer: the length of the shortest route.", "hint": "One chosen route is:\n```\n (1, 1) (1, 6)\n (2, 6) (2, 3)\n (3, 3) (3, 1)\n (4, 1) (4, 2)\n (5, 2) (5, 6)\n (6, 6) (6, 4) (6, 6)\n```\nIt is not hard to compute that the total length is $24$.\n\nConstraints: For $100\\%$ of the testdata, $1 \\le n \\le 2 \\times 10^4$, $1 \\le L_i \\le R_i \\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2007] 线段", "background": null, "description": "在一个 $n \\times n$ 的平面上，在每一行中有一条线段，第 $i$ 行的线段的左端点是 $(i, L_{i})$，右端点是 $(i, R_{i})$。\n\n你从 $(1,1)$ 点出发，要求沿途走过所有的线段，最终到达 $(n,n)$ 点，且所走的路程长度要尽量短。\n\n更具体一些说，你在任何时候只能选择向下走一步（行数增加 $1$）、向左走一步（列数减少 $1$）或是向右走一步（列数增加 $1$）。当然，由于你不能向上行走，因此在从任何一行向下走到另一行的时候，你必须保证已经走完本行的那条线段。", "inputFormat": "第一行有一个整数 $n$。\n\n以下 $n$ 行，在第 $i$ 行（总第 $(i+1)$ 行）的两个整数表示 $L_i$ 和 $R_i$。", "outputFormat": "仅包含一个整数，你选择的最短路程的长度。", "hint": "我们选择的路线是\n\n```\n (1, 1) (1, 6)\n (2, 6) (2, 3)\n (3, 3) (3, 1)\n (4, 1) (4, 2)\n (5, 2) (5, 6)\n (6, 6) (6, 4) (6, 6)\n```\n不难计算得到，路程的总长度是 $24$。 \n\n对于 $100\\%$ 的数据，$1\\le n \\le 2 \\times 10^4$，$1 \\le L_i \\le R_i \\le n$。", "locale": "zh-CN"}}}
{"pid": "P3843", "type": "P", "difficulty": 3, "samples": [["0 0 4\n-1 Y\n-1 X\n1 Y\n1 X\n1 0 4\n-1 X\n1 Y\n1 X\n-1 Y", "1.00"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "各省省选", "天津"], "title": "[TJOI2007] 迷路", "background": "小 A 和小 B 在一个二维空间中迷路了，每个人在这个空间中都按照自己特定的路线行\n\n走，由于他们的路线都是周期性的，因此你可以把这种路线理解为一种“轨道”：即一条封\n\n闭的路线，路线的终点和起点重合，这样才能“周期”的行走。\n", "description": "两个人行走的速度都是每秒一个单位距离，而且他们的路线都是平行于坐标轴的。基于\n\n此，如果两个人无限的走下去，我们想知道他们每一秒相离最近的距离。（我们只考虑两人\n\n在每秒行走后相离的距离，不考虑他们在这 1 秒内某个时刻的距离）\n", "inputFormat": "输入文件中有两个相似的部分，分别描述小 A 和小 B 的行走轨道。在每一个部分中的\n\n第一行有三个整数，sx、sy 和 m，前两个整数表示其初始位置，第三个整数表示轨道中折线\n\n的数目，以下 m 行，每行有一个整数 d 和一个非空格字符 c，d 和 c 之间用一个空格隔开。\n\nd 表示小 A 或小 B 沿坐标的正方向行走的距离，而 c 为’X’或’Y’，表示是 X 坐标轴还是 Y\n\n坐标轴。输入数据保证在每一个部分中，我们从起点(sx, sy)开始，执行 m 次行走步骤后，一定能\n\n回到起点，即这个轨道是封闭的。\n", "outputFormat": "输出文件中只包含一个实数，精确到小数点后两位。表示能观测到的两个人的最近距离，\n\n如果可能在某个时间两个人到达同一个点，则输出 0.00。\n", "hint": "100%的数据中，对于任何 m 和 d，有 1 ≤ m, d ≤ 100，轨道的初始坐标的绝对值不超\n\n过 2 000。\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2007] Lost", "background": "Xiao A and Xiao B are lost in a two-dimensional space. Each person walks along a specific route. Since their routes are periodic, you can regard each route as an “orbit”: a closed path whose endpoint coincides with its starting point, so that it can be traversed periodically.", "description": "Both people walk at a speed of 1 unit per second, and all their route segments are parallel to the coordinate axes. Based on this, if the two keep walking indefinitely, we want to know the smallest distance between them measured at the end of each second. We only consider the distance after each whole second of walking, not the distance at any moment within a second.", "inputFormat": "The input consists of two similar parts, describing the orbits of Xiao A and Xiao B respectively.\n\nFor each part:\n- The first line contains three integers: sx, sy, and m. The first two integers are the initial position, and the third is the number of polyline segments in the orbit.\n- The next m lines each contain an integer d and a non-space character c, separated by one space. Here d is the distance walked in the positive direction of the specified coordinate axis, and c is 'X' or 'Y', indicating whether the movement is parallel to the X-axis or the Y-axis.\n\nIt is guaranteed that, for each part, starting from (sx, sy) and performing these m walking steps, you will return to the starting point; that is, the orbit is closed.", "outputFormat": "Output a single real number with exactly two digits after the decimal point, representing the smallest observable distance between the two people. If it is possible for them to arrive at the same point at some integer time, output 0.00.", "hint": "For 100% of the testdata, $1 \\le m, d \\le 100$, and the absolute value of the initial coordinates does not exceed $2\\,000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2007] 迷路", "background": "小 A 和小 B 在一个二维空间中迷路了，每个人在这个空间中都按照自己特定的路线行\n\n走，由于他们的路线都是周期性的，因此你可以把这种路线理解为一种“轨道”：即一条封\n\n闭的路线，路线的终点和起点重合，这样才能“周期”的行走。\n", "description": "两个人行走的速度都是每秒一个单位距离，而且他们的路线都是平行于坐标轴的。基于\n\n此，如果两个人无限的走下去，我们想知道他们每一秒相离最近的距离。（我们只考虑两人\n\n在每秒行走后相离的距离，不考虑他们在这 1 秒内某个时刻的距离）\n", "inputFormat": "输入文件中有两个相似的部分，分别描述小 A 和小 B 的行走轨道。在每一个部分中的\n\n第一行有三个整数，sx、sy 和 m，前两个整数表示其初始位置，第三个整数表示轨道中折线\n\n的数目，以下 m 行，每行有一个整数 d 和一个非空格字符 c，d 和 c 之间用一个空格隔开。\n\nd 表示小 A 或小 B 沿坐标的正方向行走的距离，而 c 为’X’或’Y’，表示是 X 坐标轴还是 Y\n\n坐标轴。输入数据保证在每一个部分中，我们从起点(sx, sy)开始，执行 m 次行走步骤后，一定能\n\n回到起点，即这个轨道是封闭的。\n", "outputFormat": "输出文件中只包含一个实数，精确到小数点后两位。表示能观测到的两个人的最近距离，\n\n如果可能在某个时间两个人到达同一个点，则输出 0.00。\n", "hint": "100%的数据中，对于任何 m 和 d，有 1 ≤ m, d ≤ 100，轨道的初始坐标的绝对值不超\n\n过 2 000。\n", "locale": "zh-CN"}}}
{"pid": "P3844", "type": "P", "difficulty": 4, "samples": [["3\n0 0 5\n0 1 2\n10 10 1", "69.12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "各省省选", "天津"], "title": "[TJOI2007] 圆", "background": null, "description": "平面上有 $n$ 个圆，任意两个不同的圆之间只有相离（可以外切）和包含（可以内切）两种关系。\n\n初始时整个平面是黑色的，我们按照输入给定的顺序在平面上画出这些圆。我们画一个圆的时候，把这个圆覆盖的区域全部反色，即如果区域中的一个点原来是黑色，则将它涂为白色；如果这个点原来是白色，则将它涂成黑色。\n\n按照这个步骤把所有的圆都画出来后，请输出平面上的所有白色区域的面积之和。", "inputFormat": "输入文件的第一行有一个整数 $n$，表示圆的个数。\n\n以下 $n$ 行，每行用三个整数 $x,y,r$ 描述一个圆，表示该圆的圆心坐标为 $(x, y)$，半径为 $r$。在平面上画圆的顺序和输入给定的顺序相同。", "outputFormat": "你只需要向输出文件输出一个实数，精确到小数点后两位，表示平面上白色区域面积之和。", "hint": "对于 $100\\%$ 的数据，$0\\le n\\le 100$，对于所有的圆，均有 $|x|, |y|, r \\le 1 000$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2007] Circle", "background": "", "description": "There are $n$ circles on the plane. Any two distinct circles are either disjoint (they may be externally tangent) or one contains the other (they may be internally tangent).\n\nInitially, the entire plane is black. We draw these circles on the plane in the given input order. When we draw a circle, we invert the color of every point covered by that circle: if a point was black, paint it white; if it was white, paint it black.\n\nAfter all circles are drawn following this procedure, output the total area of all white regions on the plane.", "inputFormat": "The first line contains an integer $n$, the number of circles.\n\nEach of the following $n$ lines contains three integers $x, y, r$ describing a circle whose center is at $(x, y)$ and whose radius is $r$. The drawing order is the same as the input order.", "outputFormat": "Output a single real number rounded to two decimal places: the total area of all white regions on the plane.", "hint": "For $100\\%$ of the testdata, $0 \\le n \\le 100$. For all circles, $|x|, |y|, r \\le 1 000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2007] 圆", "background": null, "description": "平面上有 $n$ 个圆，任意两个不同的圆之间只有相离（可以外切）和包含（可以内切）两种关系。\n\n初始时整个平面是黑色的，我们按照输入给定的顺序在平面上画出这些圆。我们画一个圆的时候，把这个圆覆盖的区域全部反色，即如果区域中的一个点原来是黑色，则将它涂为白色；如果这个点原来是白色，则将它涂成黑色。\n\n按照这个步骤把所有的圆都画出来后，请输出平面上的所有白色区域的面积之和。", "inputFormat": "输入文件的第一行有一个整数 $n$，表示圆的个数。\n\n以下 $n$ 行，每行用三个整数 $x,y,r$ 描述一个圆，表示该圆的圆心坐标为 $(x, y)$，半径为 $r$。在平面上画圆的顺序和输入给定的顺序相同。", "outputFormat": "你只需要向输出文件输出一个实数，精确到小数点后两位，表示平面上白色区域面积之和。", "hint": "对于 $100\\%$ 的数据，$0\\le n\\le 100$，对于所有的圆，均有 $|x|, |y|, r \\le 1 000$。", "locale": "zh-CN"}}}
{"pid": "P3845", "type": "P", "difficulty": 5, "samples": [["2\n4\n1-0\n2-0\n0-3\n2-1\n4\n5-0\n1-3\n2-2\n0-0", "2\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2007", "各省省选", "天津"], "title": "[TJOI2007] 球赛", "background": null, "description": "超级球迷 H 每周六晚上都会坐在电视前看球，从不错过一场比赛。\n\n但是上周末，H 突然有一个重要的约会，于是他只能教他三岁的弟弟小 H 记录所有比赛的比分。但是当他约会回来时，他发现小 H 不仅认真的记录了每一场比赛的最终比分，还把一些比赛的中间比分也记录下来，而更糟糕的是，小 H 并没有区分比赛的两个队，同一场比赛的比分可能被记录成 `1-2`，也可能是 `2-1`。因此，若是有一场比赛的最终得分是 5-3，可能实际上被小 H 记录的分数有：\n\n`1-0 3-2 2-3 3-4 5-3`\n\n现在 H 已经拿到了小 H 记录的所有比分，他想知道，在这个周末他由于约会至少错过了多少场比赛。注意小 H 记录的比分是没有先后顺序的。", "inputFormat": "输入文件中可能包含多组测试数据，文件中第一行是一个整数 $n$，表明以下一共有 $n$ 组测试数据。\n\n对于每一组数据，第一行有一个整数 $s$，表示小 H 记录的比分数目，以下每行用 `x-y` 的格式描述一条比分，$x$ 和 $y$ 都是非负整数。", "outputFormat": "对于输入数据中的每一个测试数据，你需要输出一个整数 $m$，表示在这个测试数据中，H 至少错过了 $m$ 场比赛。", "hint": "在第一组输入数据中，两场比赛对应的比分可能是 `1-0 2-0 0-3` 和 `2-1`。\n\n在第二组输入数据中，三场比赛对应的比分可能是 `0-0 5-0、3-1` 和 `2-2`。\n\n$100\\%$ 的数据中 $n \\leq 5，s \\leq 1000$，每一场比赛的比分都在 `longint(Pascal)` / `long(C++)`（$2147483647$）范围内。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2007] Football Match", "background": "# Description\n\nSuper fan H watches football on TV every Saturday night and never misses a match.\n\nBut last weekend, H suddenly had an important date, so he taught his three-year-old brother, little H, to write down the scores of all matches. When he came back, he found that little H not only recorded the final score of each match, but also some intermediate scores. Worse, little H did not distinguish between the two teams; the same match could be recorded as `1-2` or `2-1`. Therefore, if the final score of a match was 5-3, little H might actually have written down the following scores:\n\n`1-0 3-2 2-3 3-4 5-3`\n\nNow H has all the scores recorded by little H. He wants to know the minimum number of matches he must have missed this weekend due to the date. Note that the recorded scores are in no particular order.", "description": "", "inputFormat": "", "outputFormat": "For each testdata, output a single integer $m$, the minimum number of matches that H must have missed.", "hint": "In the first testdata, two matches may correspond to `1-0 2-0 0-3` and `2-1`.\n\nIn the second testdata, three matches may correspond to `0-0`, `5-0 3-1`, and `2-2`.\n\nConstraints: For 100% of the testdata, $n \\leq 5$, $s \\leq 1000$, and every score fits in `longint(Pascal)` / `long(C++)` ($2147483647$).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2007] 球赛", "background": null, "description": "超级球迷 H 每周六晚上都会坐在电视前看球，从不错过一场比赛。\n\n但是上周末，H 突然有一个重要的约会，于是他只能教他三岁的弟弟小 H 记录所有比赛的比分。但是当他约会回来时，他发现小 H 不仅认真的记录了每一场比赛的最终比分，还把一些比赛的中间比分也记录下来，而更糟糕的是，小 H 并没有区分比赛的两个队，同一场比赛的比分可能被记录成 `1-2`，也可能是 `2-1`。因此，若是有一场比赛的最终得分是 5-3，可能实际上被小 H 记录的分数有：\n\n`1-0 3-2 2-3 3-4 5-3`\n\n现在 H 已经拿到了小 H 记录的所有比分，他想知道，在这个周末他由于约会至少错过了多少场比赛。注意小 H 记录的比分是没有先后顺序的。", "inputFormat": "输入文件中可能包含多组测试数据，文件中第一行是一个整数 $n$，表明以下一共有 $n$ 组测试数据。\n\n对于每一组数据，第一行有一个整数 $s$，表示小 H 记录的比分数目，以下每行用 `x-y` 的格式描述一条比分，$x$ 和 $y$ 都是非负整数。", "outputFormat": "对于输入数据中的每一个测试数据，你需要输出一个整数 $m$，表示在这个测试数据中，H 至少错过了 $m$ 场比赛。", "hint": "在第一组输入数据中，两场比赛对应的比分可能是 `1-0 2-0 0-3` 和 `2-1`。\n\n在第二组输入数据中，三场比赛对应的比分可能是 `0-0 5-0、3-1` 和 `2-2`。\n\n$100\\%$ 的数据中 $n \\leq 5，s \\leq 1000$，每一场比赛的比分都在 `longint(Pascal)` / `long(C++)`（$2147483647$）范围内。", "locale": "zh-CN"}}}
{"pid": "P3846", "type": "P", "difficulty": 5, "samples": [["5 2 3\n", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2007", "各省省选", "O2优化", "素数判断,质数,筛法", "天津", "大步小步算法 BSGS", "模板题"], "title": "【模板】BSGS / [TJOI2007] 可爱的质数", "background": "", "description": "给定一个质数 $p$，以及一个整数 $b$，一个整数 $n$，现在要求你计算一个最小的非负整数 $l$，满足 $b^l \\equiv n \\pmod p$。", "inputFormat": "仅一行，有 $3$ 个整数，依次代表 $p, b, n$。", "outputFormat": "仅一行，如果有 $l$ 满足该要求，输出最小的 $l$，否则输出 `no solution`。", "hint": "#### 数据规模与约定\n\n- 对于所有的测试点，保证 $2\\le b < p<2^{31}$，$1\\leq n<p$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] BSGS / [TJOI2007] Lovely Prime", "background": "", "description": "Given a prime $p$, an integer $b$, and an integer $n$, compute the smallest non-negative integer $l$ such that $b^l \\equiv n \\pmod p$.", "inputFormat": "A single line contains $3$ integers, representing $p, b, n$ in order.", "outputFormat": "A single line. If there exists an $l$ satisfying the requirement, output the smallest $l$; otherwise output `no solution`.", "hint": "#### Constraints\n\n- For all testdata, it is guaranteed that $2 \\le b < p < 2^{31}$, $1 \\le n < p$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】BSGS / [TJOI2007] 可爱的质数", "background": "", "description": "给定一个质数 $p$，以及一个整数 $b$，一个整数 $n$，现在要求你计算一个最小的非负整数 $l$，满足 $b^l \\equiv n \\pmod p$。", "inputFormat": "仅一行，有 $3$ 个整数，依次代表 $p, b, n$。", "outputFormat": "仅一行，如果有 $l$ 满足该要求，输出最小的 $l$，否则输出 `no solution`。", "hint": "#### 数据规模与约定\n\n- 对于所有的测试点，保证 $2\\le b < p<2^{31}$，$1\\leq n<p$。", "locale": "zh-CN"}}}
{"pid": "P3847", "type": "P", "difficulty": 4, "samples": [["5\n1 2 2 4 3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2007", "各省省选", "枚举", "区间 DP", "天津"], "title": "[TJOI2007] 调整队形", "background": "学校艺术节上，规定合唱队要参加比赛，各个队员的衣服颜色不能很混乱：合唱队员应排成一横排，且衣服颜色必须是左右对称的。\n\n例如：“红蓝绿蓝红”或“红蓝绿绿蓝红”都是符合的，而“红蓝绿红”或“蓝绿蓝红”就不符合要求。\n\n合唱队人数自然很多，仅现有的同学就可能会有 $3000$ 个。老师希望将合唱队调整得符合要求，但想要调整尽量少，减少麻烦。以下任一动作认为是一次调整：", "description": "1、在队伍左或右边加一个人（衣服颜色依要求而定）；\n\n2、在队伍中任两个人中间插入一个人（衣服颜色依要求而定）；\n\n3、剔掉一个人；\n\n4、让一个人换衣服颜色；\n\n老师想知道就目前的队形最少的调整次数是多少，请你编一个程序来回答他。\n\n因为加入合唱队很热门，你可以认为人数是无限的，即随时想加一个人都能找到人。同时衣服颜色也是任意的。", "inputFormat": "第一行是一个整数 $n$（$1 \\le n \\le 3000$）。\n\n第二行是 $n$ 个整数，从左到右分别表示现有的每个队员衣服的颜色号，都是 $1$ 到 $3000$ 的整数。", "outputFormat": "一个数，即对于输入队列，要调整得符合要求，最少的调整次数。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2007] Adjust the Lineup", "background": "At the school's arts festival, the chorus is required to compete, and the colors of the members' clothes must not be chaotic: the chorus members should stand in a single row, and the clothing colors must be left-right symmetric.\n\nFor example: \"red blue green blue red\" or \"red blue green green blue red\" are acceptable, while \"red blue green red\" or \"blue green blue red\" are not.\n\nThe chorus can be quite large, with up to $3000$ students. The teacher wants to adjust the lineup to meet the requirement with as few adjustments as possible. Each of the following actions counts as one adjustment:", "description": "1. Add one person to the left or right end (their clothing color can be chosen as needed).\n2. Insert one person between any two adjacent people (their clothing color can be chosen as needed).\n3. Remove one person.\n4. Change one person's clothing color.\n\nThe teacher wants to know, for the current lineup, the minimum number of adjustments needed. Please write a program to answer this.\n\nBecause joining the chorus is very popular, you may assume there is an unlimited number of people available, i.e., you can always add someone when needed. Clothing colors can be chosen arbitrarily as well.", "inputFormat": "The first line contains an integer $n$ ($1 \\le n \\le 3000$).\n\nThe second line contains $n$ integers, from left to right, representing the current clothing color ID of each member, all integers from $1$ to $3000$.", "outputFormat": "Output a single number: the minimum number of adjustments needed to make the lineup meet the requirement.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2007] 调整队形", "background": "学校艺术节上，规定合唱队要参加比赛，各个队员的衣服颜色不能很混乱：合唱队员应排成一横排，且衣服颜色必须是左右对称的。\n\n例如：“红蓝绿蓝红”或“红蓝绿绿蓝红”都是符合的，而“红蓝绿红”或“蓝绿蓝红”就不符合要求。\n\n合唱队人数自然很多，仅现有的同学就可能会有 $3000$ 个。老师希望将合唱队调整得符合要求，但想要调整尽量少，减少麻烦。以下任一动作认为是一次调整：", "description": "1、在队伍左或右边加一个人（衣服颜色依要求而定）；\n\n2、在队伍中任两个人中间插入一个人（衣服颜色依要求而定）；\n\n3、剔掉一个人；\n\n4、让一个人换衣服颜色；\n\n老师想知道就目前的队形最少的调整次数是多少，请你编一个程序来回答他。\n\n因为加入合唱队很热门，你可以认为人数是无限的，即随时想加一个人都能找到人。同时衣服颜色也是任意的。", "inputFormat": "第一行是一个整数 $n$（$1 \\le n \\le 3000$）。\n\n第二行是 $n$ 个整数，从左到右分别表示现有的每个队员衣服的颜色号，都是 $1$ 到 $3000$ 的整数。", "outputFormat": "一个数，即对于输入队列，要调整得符合要求，最少的调整次数。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3848", "type": "P", "difficulty": 3, "samples": [["4  3  2\n1  0  1  0 \n1  1  1  1\n0  0  1  0\n1  1  0  1", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索", "2007", "各省省选", "递归", "深度优先搜索 DFS", "天津"], "title": "[TJOI2007] 跳棋", "background": "### 本题可能为错题，目前数据只是随机生成的 $n\\leq 20$ 的情况，测试数据和题解仅供参考。\n\n在一个n×n的棋盘上，布满了0和1，如图（a）所示（n=7），为叙述方便，将0用字母表示，如图（b）。\n\n![](https://cdn.luogu.com.cn/upload/pic/6077.png)\n", "description": "跳棋规则：\n\n（1）从某个0格出发，可以向上，下，左，右4个方向连续越过若干个（至少1个）\n\n1格而跳入下一个0格。如图（b）中从A出发，可跳到B，或者到E，但不能直接到K。在跳到B之后还可以继续跳到F;在跳到E之后可继续跳到F或K。直到不能再跳为止。\n\n（2）每个0格只能到达一次，给出的起始点不能再到达，也不能越过。\n\n跳过的距离为跳过1格个数加1，如从A到B，跳过距离为3，从B到F，跳过距离为2。\n\n问   题： 当棋盘和起始点给出之后，问最远能跳的距离是多少？\n\n如上图（b）中，从A出发，可跳过的路线不止一条，其中一条为：\n\nA － B － F － L － K － E  （可能不唯一）\n\n3    2    3    3     3\n\n它的距离为14。\n", "inputFormat": "第一行三个整数  n（1≤n≤100），x，y（起点坐标，上图（b）中A处坐标为1，3）\n\n接下来n行，每行n个数（0或1），数与数之间用一个空格分隔。\n", "outputFormat": "一个整数，即最大可跳距离（若不能跳，输出0）。\n", "hint": "$\\text{upd 2022.7.27}$：新增加一组 Hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2007] Checkers", "background": "This problem may be flawed. The current testdata are randomly generated for $n\\leq 20$, and both the testdata and the editorials are for reference only.\n\nOn an $n \\times n$ board filled with 0s and 1s, as shown in Figure (a) (with $n=7$), for convenience, the 0s are labeled with letters, as shown in Figure (b).\n\n![](https://cdn.luogu.com.cn/upload/pic/6077.png)", "description": "Rules of the game:\n\n(1) Starting from some 0-cell, you can jump in one of the four directions (up, down, left, right), consecutively over several (at least one) 1-cells, and land on the next 0-cell. In Figure (b), starting from A, you can jump to B or to E, but not directly to K. After jumping to B, you can continue to F; after jumping to E, you can continue to F or K. Continue until no further jump is possible.\n\n(2) Each 0-cell can be visited at most once. The given starting cell cannot be visited again, nor can it be jumped over.\n\nThe jump distance equals the number of 1-cells jumped over plus 1. For example, from A to B the distance is 3; from B to F the distance is 2.\n\nProblem: Given the board and the starting point, what is the maximum total jump distance?\n\nIn Figure (b), starting from A, there are multiple possible routes. One of them is:\nA - B - F - L - K - E (possibly not unique)\n3 2 3 3 3\nIts total distance is 14.", "inputFormat": "The first line contains three integers: $n$ (1 ≤ $n$ ≤ 100), $x$, $y$ (coordinates of the starting point; in Figure (b), the coordinates of A are 1, 3).\n\nThen follow $n$ lines, each containing $n$ numbers (0 or 1), separated by a single space.", "outputFormat": "Output a single integer: the maximum total jump distance (output 0 if no jump is possible).", "hint": "$\\text{upd 2022.7.27}$：A new hack testdata has been added.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2007] 跳棋", "background": "### 本题可能为错题，目前数据只是随机生成的 $n\\leq 20$ 的情况，测试数据和题解仅供参考。\n\n在一个n×n的棋盘上，布满了0和1，如图（a）所示（n=7），为叙述方便，将0用字母表示，如图（b）。\n\n![](https://cdn.luogu.com.cn/upload/pic/6077.png)\n", "description": "跳棋规则：\n\n（1）从某个0格出发，可以向上，下，左，右4个方向连续越过若干个（至少1个）\n\n1格而跳入下一个0格。如图（b）中从A出发，可跳到B，或者到E，但不能直接到K。在跳到B之后还可以继续跳到F;在跳到E之后可继续跳到F或K。直到不能再跳为止。\n\n（2）每个0格只能到达一次，给出的起始点不能再到达，也不能越过。\n\n跳过的距离为跳过1格个数加1，如从A到B，跳过距离为3，从B到F，跳过距离为2。\n\n问   题： 当棋盘和起始点给出之后，问最远能跳的距离是多少？\n\n如上图（b）中，从A出发，可跳过的路线不止一条，其中一条为：\n\nA － B － F － L － K － E  （可能不唯一）\n\n3    2    3    3     3\n\n它的距离为14。\n", "inputFormat": "第一行三个整数  n（1≤n≤100），x，y（起点坐标，上图（b）中A处坐标为1，3）\n\n接下来n行，每行n个数（0或1），数与数之间用一个空格分隔。\n", "outputFormat": "一个整数，即最大可跳距离（若不能跳，输出0）。\n", "hint": "$\\text{upd 2022.7.27}$：新增加一组 Hack 数据。", "locale": "zh-CN"}}}
{"pid": "P3849", "type": "P", "difficulty": 6, "samples": [["1 10 10 1\n0.3 0.2 0.5 0.7 0.2 0.1", "1.609"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "各省省选", "天津"], "title": "[TJOI2007] 足彩投注", "background": "了解足球彩票的人可能知道，足球彩票中有一种游戏叫做“胜负彩”，意为猜比赛的胜负。下面是一些与胜负彩有关的术语：\n\n注：**每一**组有效组合数据。\n\n投注：彩民以现金购买足球彩票的行为。\n\n单式投注：彩民对于所有球队的比赛成绩均只选择一种预测结果的投注方式。投注的数量（注数）为1。\n\n复式投注：彩民对于某些场次的比赛成绩选择两种以上的预测结果的投注方式。投注的数量为复式投注的组合数。例如，某彩民对一场比赛预测了两个结果（例如胜平），另一场比赛预测了三个结果（胜负平），其他比赛都只预测了一种结果，那么注数就是 $2\\times 3=6$。**这样的一个复式投注，可以看成一个包含六种单式投注的集合。**\n\n\n胜负彩的玩法一般是这样的。彩票机构指定一轮比赛中的若干场，让彩民去猜每场比赛的结果（胜负平）。根据彩民猜中比赛的场次，来确定中奖的额度", "description": "我们现在考虑一个简化的模型。对于一轮比赛，彩民需要竞猜其中 $n$ 场比赛的结果，每场比赛的胜负平都有一个概率 $p(i, r)$ 。其中，$i$ 表示第 $i$ 场比赛。$r\\in \\{0,1,2\\}$，分别表示主队比赛结果的负、平、胜。$p(i, r)$ 则表示第i场比赛、结果为r的概率。此外，还有一个概率 $q(i, r)$，表示第 $i$ 场比赛，投注购买结果为 $r$ 的概率，**即总注数中购买该场次某一比赛结果的概率**。\n\n\n例如，如果 $q(1,0) = 0.5$，我们可以知道第一场比赛有 $50\\%$ 的投注会买主队输球。我们假设这 $n$ 场比赛互不相关，即 $p(i, r)$ 的结果不会受 $p(j, r’)$ 的影响，$q(i, r)$ 的结果也不会受 $q(j, r’)$ 的影响（$r \\ne r’$）。\n\n\n在这个模型里，我们规定，必须猜中全部 $n$ 场比赛的结果才能获奖。总奖金为 $M$，由所有获奖的投注平分。因此，对于一个单式投注 $R_i = \\{r_{i1}, r_{i2}, \\ldots ,r_{in}\\}$，$r_{ij}$ 表示投注 $R_i$对第j场比赛的预测结果，它的中奖概率为：\n\n$$\nP(R_i)=\\prod\\limits_{j=1}^np(j,r_{ij})\n$$\n设投注总数为 $N$，那么中奖的投注总数为：\n\n$$\nN\\cdot Q(R_i)=N\\cdot\\prod\\limits_{j=1}^nq(j,r_{ij})\n$$\n于是，投注 $R_i$ 所能得到的奖金的期望（平均意义下能够获得的奖金数）就是：\n\n$$\n\\dfrac{M}{N\\cdot Q(R_i)} \\cdot P(R_i)\n$$\n以上考虑的仅仅是单式投注的情况，即仅考虑单注 $R_i$ 的中奖情况。对于复式投注，情况要复杂一些。采用复式投注时，投注的是一个集合 $R = \\{R1, R2, …, Rk\\}$，其中k是投注的数量。例如，三场比赛，第一场猜“胜负”，第二场猜“平”，第三场猜“负平”，则 $k = 4$，$R$ 集合所包含的四个元素如下如下：\n\n|       | $r_{i1}$ | $r_{i2}$ | $r_{i3}$ |\n| ----- | -------- | -------- | -------- |\n| $R_1$ | 0        | 1        | 0        |\n| $R_2$ | 0        | 1        | 1        |\n| $R_3$ | 2        | 1        | 0        |\n| $R_4$ | 2        | 1        | 1        |\n\n复式投注R中，只要有一个 $Ri$ 猜对所有比赛结果，即可中奖。因此，复式投注R所能获得的奖金的期望就是：\n\n$$\n\\sum_{R_i\\in R}\\dfrac{M}{N\\cdot Q(R_i)} \\cdot P(R_i)\n$$\n\n我们的问题是，给定 $n$ 场比赛的信息（胜负平的概率和彩民购买三种结果的概率），以及复式投注中可以购买的最大注数 $U$，要求设计一种复式投注的方案，在不超过最大注数（复式投注的注数 $k \\le U$）的前提下，使得获得奖金的期望最大。", "inputFormat": "第一行四个正整数 $n, N, M, U$，其中 $n, U \\le 10^4, N, M \\le 10^9$。\n\n以下 $n$ 行，每行六个实数。第 $i + 1$ 行的六个实数为 $p(i, 0), p(i, 1), p(i, 2), q(i, 0),q(i, 1),q(i, 2)$，用来描述第 $i$ 场比赛的相关信息。其中，$p(i, 0) + p(i, 1) + p(i, 2) = 1$,，$q(i, 0) + q(i, 1) + q(i, 2) = 1$，$ q(i, j) ≠ 0$。", "outputFormat": "一个实数，表示最大的奖金期望的自然对数。\n\n$$\n\\ln \\left( \\operatorname{max}_{\\lvert R \\rvert \\le U}\\left\\{\\sum_{R_i\\in R}\\dfrac{M}{N\\cdot Q(R_i)} \\cdot P(R_i)\\right\\}\\right)\n$$\n\n输出保留 $3$ 位小数（四舍五入）。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2007] Football Lottery Betting", "background": "People who know football lotteries may be familiar with a game called “Win-Draw-Loss,” which means predicting the outcome of each match. Below are some terms related to Win-Draw-Loss.\n\nNote: each group is one valid combination of bets.\n\nBetting: the act of buying football lottery tickets with cash.\n\nSingle bet: the bettor selects exactly one predicted result for every match. The number of bets (tickets) is 1.\n\nMultiple bet: the bettor selects two or more predicted results for some matches. The number of bets equals the number of combinations in the multiple bet. For example, if a bettor predicts two outcomes (e.g., win or draw) for one match, three outcomes (win, draw, loss) for another match, and exactly one outcome for all other matches, then the number of bets is $2 \\times 3 = 6$. Such a multiple bet can be regarded as a set containing six single bets.\n\nIn a typical Win-Draw-Loss game, the lottery operator specifies several matches within a round and asks bettors to predict each match’s result (win, draw, loss). The prize amount depends on how many matches the bettor predicts correctly.", "description": "We now consider a simplified model. In one round, the bettor needs to predict the results of $n$ matches. Each match’s win-draw-loss outcomes have probabilities $p(i, r)$. Here, $i$ denotes the $i$-th match and $r \\in \\{0, 1, 2\\}$ denotes the home team’s loss, draw, and win, respectively. The value $p(i, r)$ is the probability that match $i$ ends with result $r$. In addition, $q(i, r)$ denotes the probability that, among all purchased bets, result $r$ is chosen for match $i$, i.e., the fraction of the total number of bets that select that outcome for that match.\n\nFor example, if $q(1, 0) = 0.5$, then we know that $50\\%$ of the bets choose the home team to lose in the first match. We assume these $n$ matches are independent, i.e., the outcomes $p(i, r)$ are independent across matches, and the selections $q(i, r)$ are also independent across matches (with $r \\ne r'$).\n\nIn this model, a ticket wins only if it correctly predicts all $n$ matches. The total prize pool is $M$ and is shared equally among all winning bets. Therefore, for a single bet $R_i = \\{r_{i1}, r_{i2}, \\ldots, r_{in}\\}$, where $r_{ij}$ is the predicted result of bet $R_i$ for match $j$, its winning probability is:\n$$\nP(R_i)=\\prod\\limits_{j=1}^n p(j, r_{ij}).\n$$\nLet the total number of bets be $N$. Then the total number of winning bets is:\n$$\nN \\cdot Q(R_i)=N\\cdot\\prod\\limits_{j=1}^n q(j, r_{ij}).\n$$\nHence, the expected prize (the average prize) received by bet $R_i$ is:\n$$\n\\dfrac{M}{N\\cdot Q(R_i)} \\cdot P(R_i).\n$$\nThe above only considers single bets, i.e., the winning of a single $R_i$. For multiple bets, the situation is more complicated. A multiple bet is a set $R = \\{R_1, R_2, \\ldots, R_k\\}$, where $k$ is the number of bets. For example, with three matches, if the first match is “win or loss,” the second is “draw,” and the third is “loss or draw,” then $k = 4$, and the set $R$ contains the following four elements:\n\n|       | $r_{i1}$ | $r_{i2}$ | $r_{i3}$ |\n| ----- | -------- | -------- | -------- |\n| $R_1$ | 0        | 1        | 0        |\n| $R_2$ | 0        | 1        | 1        |\n| $R_3$ | 2        | 1        | 0        |\n| $R_4$ | 2        | 1        | 1        |\n\nIn a multiple bet $R$, you win if at least one $R_i$ predicts all results correctly. Therefore, the expected prize of $R$ is:\n$$\n\\sum_{R_i\\in R}\\dfrac{M}{N\\cdot Q(R_i)} \\cdot P(R_i).\n$$\n\nThe problem: given the information for $n$ matches (the probabilities of outcomes and the probabilities that bettors buy those outcomes), and the maximum number of bets $U$ allowed in a multiple bet, design a multiple betting scheme that does not exceed the maximum number of bets ($k \\le U$) and maximizes the expected prize.", "inputFormat": "The first line contains four positive integers $n, N, M, U$, where $n, U \\le 10^4$ and $N, M \\le 10^9$.\n\nEach of the next $n$ lines contains six real numbers. The six real numbers on line $i + 1$ are $p(i, 0), p(i, 1), p(i, 2), q(i, 0), q(i, 1), q(i, 2)$, describing match $i$. Here, $p(i, 0) + p(i, 1) + p(i, 2) = 1$, $q(i, 0) + q(i, 1) + q(i, 2) = 1$, and $q(i, j) \\ne 0$.", "outputFormat": "Output a real number, the natural logarithm of the maximum expected prize:\n$$\n\\ln \\left( \\operatorname{max}_{\\lvert R \\rvert \\le U}\\left\\{\\sum_{R_i\\in R}\\dfrac{M}{N\\cdot Q(R_i)} \\cdot P(R_i)\\right\\}\\right).\n$$\nPrint the answer with $3$ decimal places (rounded half up).", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2007] 足彩投注", "background": "了解足球彩票的人可能知道，足球彩票中有一种游戏叫做“胜负彩”，意为猜比赛的胜负。下面是一些与胜负彩有关的术语：\n\n注：**每一**组有效组合数据。\n\n投注：彩民以现金购买足球彩票的行为。\n\n单式投注：彩民对于所有球队的比赛成绩均只选择一种预测结果的投注方式。投注的数量（注数）为1。\n\n复式投注：彩民对于某些场次的比赛成绩选择两种以上的预测结果的投注方式。投注的数量为复式投注的组合数。例如，某彩民对一场比赛预测了两个结果（例如胜平），另一场比赛预测了三个结果（胜负平），其他比赛都只预测了一种结果，那么注数就是 $2\\times 3=6$。**这样的一个复式投注，可以看成一个包含六种单式投注的集合。**\n\n\n胜负彩的玩法一般是这样的。彩票机构指定一轮比赛中的若干场，让彩民去猜每场比赛的结果（胜负平）。根据彩民猜中比赛的场次，来确定中奖的额度", "description": "我们现在考虑一个简化的模型。对于一轮比赛，彩民需要竞猜其中 $n$ 场比赛的结果，每场比赛的胜负平都有一个概率 $p(i, r)$ 。其中，$i$ 表示第 $i$ 场比赛。$r\\in \\{0,1,2\\}$，分别表示主队比赛结果的负、平、胜。$p(i, r)$ 则表示第i场比赛、结果为r的概率。此外，还有一个概率 $q(i, r)$，表示第 $i$ 场比赛，投注购买结果为 $r$ 的概率，**即总注数中购买该场次某一比赛结果的概率**。\n\n\n例如，如果 $q(1,0) = 0.5$，我们可以知道第一场比赛有 $50\\%$ 的投注会买主队输球。我们假设这 $n$ 场比赛互不相关，即 $p(i, r)$ 的结果不会受 $p(j, r’)$ 的影响，$q(i, r)$ 的结果也不会受 $q(j, r’)$ 的影响（$r \\ne r’$）。\n\n\n在这个模型里，我们规定，必须猜中全部 $n$ 场比赛的结果才能获奖。总奖金为 $M$，由所有获奖的投注平分。因此，对于一个单式投注 $R_i = \\{r_{i1}, r_{i2}, \\ldots ,r_{in}\\}$，$r_{ij}$ 表示投注 $R_i$对第j场比赛的预测结果，它的中奖概率为：\n\n$$\nP(R_i)=\\prod\\limits_{j=1}^np(j,r_{ij})\n$$\n设投注总数为 $N$，那么中奖的投注总数为：\n\n$$\nN\\cdot Q(R_i)=N\\cdot\\prod\\limits_{j=1}^nq(j,r_{ij})\n$$\n于是，投注 $R_i$ 所能得到的奖金的期望（平均意义下能够获得的奖金数）就是：\n\n$$\n\\dfrac{M}{N\\cdot Q(R_i)} \\cdot P(R_i)\n$$\n以上考虑的仅仅是单式投注的情况，即仅考虑单注 $R_i$ 的中奖情况。对于复式投注，情况要复杂一些。采用复式投注时，投注的是一个集合 $R = \\{R1, R2, …, Rk\\}$，其中k是投注的数量。例如，三场比赛，第一场猜“胜负”，第二场猜“平”，第三场猜“负平”，则 $k = 4$，$R$ 集合所包含的四个元素如下如下：\n\n|       | $r_{i1}$ | $r_{i2}$ | $r_{i3}$ |\n| ----- | -------- | -------- | -------- |\n| $R_1$ | 0        | 1        | 0        |\n| $R_2$ | 0        | 1        | 1        |\n| $R_3$ | 2        | 1        | 0        |\n| $R_4$ | 2        | 1        | 1        |\n\n复式投注R中，只要有一个 $Ri$ 猜对所有比赛结果，即可中奖。因此，复式投注R所能获得的奖金的期望就是：\n\n$$\n\\sum_{R_i\\in R}\\dfrac{M}{N\\cdot Q(R_i)} \\cdot P(R_i)\n$$\n\n我们的问题是，给定 $n$ 场比赛的信息（胜负平的概率和彩民购买三种结果的概率），以及复式投注中可以购买的最大注数 $U$，要求设计一种复式投注的方案，在不超过最大注数（复式投注的注数 $k \\le U$）的前提下，使得获得奖金的期望最大。", "inputFormat": "第一行四个正整数 $n, N, M, U$，其中 $n, U \\le 10^4, N, M \\le 10^9$。\n\n以下 $n$ 行，每行六个实数。第 $i + 1$ 行的六个实数为 $p(i, 0), p(i, 1), p(i, 2), q(i, 0),q(i, 1),q(i, 2)$，用来描述第 $i$ 场比赛的相关信息。其中，$p(i, 0) + p(i, 1) + p(i, 2) = 1$,，$q(i, 0) + q(i, 1) + q(i, 2) = 1$，$ q(i, j) ≠ 0$。", "outputFormat": "一个实数，表示最大的奖金期望的自然对数。\n\n$$\n\\ln \\left( \\operatorname{max}_{\\lvert R \\rvert \\le U}\\left\\{\\sum_{R_i\\in R}\\dfrac{M}{N\\cdot Q(R_i)} \\cdot P(R_i)\\right\\}\\right)\n$$\n\n输出保留 $3$ 位小数（四舍五入）。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3850", "type": "P", "difficulty": 5, "samples": [["3\nMath\nAlgorithm\nProgram\n2\nPicture 2\nSystem 1\n3\n0\n1\n3", "Math\nSystem\nPicture"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "各省省选", "平衡树", "枚举", "天津"], "title": "[TJOI2007] 书架", "background": null, "description": "Knuth 先生家里有个精致的书架，书架上有 $N$ 本书，如今他想学到更多的知识，于是又买来了 $M$ 本不同的新书。现在他要把新买的书依次插入到书架中，他已经把每本书要插入的位置标记好了，并且相应的将它们放好。由于 Knuth 年龄已大，过几天他已经记不清某些位置上放的到底是什么书了，请问你能帮助他吗？", "inputFormat": "输入文件的第一行为整数 $N$，接下来 $N$ 行分别是书架上依次放着的 $N$ 本书的书名（书名由不含空格的字符串构成，长度不超过 $10$）。下一行将要输入一个整数 $M$，接下来的 $M$ 行分别为这本书的书名和要插入的位置。下一行将要输入一个整数 $Q$，接下来共有 $Q$ 次询问，每行都是一个整数表示询问的位置。（书架上位置的编号从 $0$ 开始）", "outputFormat": "输出 $Q$ 行，每行对应着相应查询位置的书名。", "hint": "原来有三本书 Math、Algorithm、Program，后来又买了两本书，分别插入到 $2$ 和 $1$ 的位置，每次插入时其他书都要向后挪一个位置，最后书架上书的序列为：\n\n```plain\n0  Math\n1  System\n2  Algorithm\n3  Picture\n4  Program\n```\n$Q$ 次询问依次为 $0$, $1$, $3$ 位置的书，所以答案为：Math、System、Picture\n\n\n对于 $30\\%$ 的数据，$1 \\leqslant N \\leqslant 100$, $1 \\leqslant M \\leqslant 10^3$, $1 \\leqslant Q \\leqslant 10^3$\n\n对于 $100\\%$ 的数据，$1 \\leqslant N \\leqslant 200$, $1 \\leqslant M \\leqslant 10^5$, $1 \\leqslant Q \\leqslant 10^4$\n\n对于 $100\\%$ 的数据都符合题目中所描述的限制关系，数据保证每次插入的位置均不超过当时书架上书的数量，而且保证 $Q$ 次查询中的每个位置上一定有书。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2007] Bookshelf", "background": "", "description": "Mr. Knuth has a delicate bookshelf with $N$ books on it. He has bought $M$ different new books to learn more. He will insert the new books into the shelf one by one; he has already marked the position for each book and placed them accordingly. As Knuth is elderly, after a few days he can no longer remember which book is at certain positions. Can you help him?", "inputFormat": "The first line contains the integer $N$. The next $N$ lines are the titles of the $N$ books currently on the shelf in order (each title is a string without spaces, with length at most $10$).  \nThe next line contains the integer $M$. The following $M$ lines each contain the title of a book and the position where it should be inserted.  \nThe next line contains the integer $Q$. Then there are $Q$ queries; each line contains an integer denoting a position to query. (Positions on the shelf are numbered from $0$.)", "outputFormat": "Output $Q$ lines. Each line contains the title of the book at the corresponding queried position.", "hint": "Originally there are three books: Math, Algorithm, Program. Later he buys two more books and inserts them at positions $2$ and $1$. Each time a book is inserted, other books shift one position to the right. The final sequence on the shelf is:\n\n```plain\n0  Math\n1  System\n2  Algorithm\n3  Picture\n4  Program\n```\n\nThe $Q$ queries ask for positions $0$, $1$, $3$, so the answers are: Math, System, Picture.\n\nConstraints:\n- For $30\\%$ of the testdata, $1 \\leqslant N \\leqslant 100$, $1 \\leqslant M \\leqslant 10^3$, $1 \\leqslant Q \\leqslant 10^3$.\n- For $100\\%$ of the testdata, $1 \\leqslant N \\leqslant 200$, $1 \\leqslant M \\leqslant 10^5$, $1 \\leqslant Q \\leqslant 10^4$.\n- For $100\\%$ of the testdata, all constraints described in the statement hold: each insertion position never exceeds the current number of books on the shelf, and every queried position always has a book.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2007] 书架", "background": null, "description": "Knuth 先生家里有个精致的书架，书架上有 $N$ 本书，如今他想学到更多的知识，于是又买来了 $M$ 本不同的新书。现在他要把新买的书依次插入到书架中，他已经把每本书要插入的位置标记好了，并且相应的将它们放好。由于 Knuth 年龄已大，过几天他已经记不清某些位置上放的到底是什么书了，请问你能帮助他吗？", "inputFormat": "输入文件的第一行为整数 $N$，接下来 $N$ 行分别是书架上依次放着的 $N$ 本书的书名（书名由不含空格的字符串构成，长度不超过 $10$）。下一行将要输入一个整数 $M$，接下来的 $M$ 行分别为这本书的书名和要插入的位置。下一行将要输入一个整数 $Q$，接下来共有 $Q$ 次询问，每行都是一个整数表示询问的位置。（书架上位置的编号从 $0$ 开始）", "outputFormat": "输出 $Q$ 行，每行对应着相应查询位置的书名。", "hint": "原来有三本书 Math、Algorithm、Program，后来又买了两本书，分别插入到 $2$ 和 $1$ 的位置，每次插入时其他书都要向后挪一个位置，最后书架上书的序列为：\n\n```plain\n0  Math\n1  System\n2  Algorithm\n3  Picture\n4  Program\n```\n$Q$ 次询问依次为 $0$, $1$, $3$ 位置的书，所以答案为：Math、System、Picture\n\n\n对于 $30\\%$ 的数据，$1 \\leqslant N \\leqslant 100$, $1 \\leqslant M \\leqslant 10^3$, $1 \\leqslant Q \\leqslant 10^3$\n\n对于 $100\\%$ 的数据，$1 \\leqslant N \\leqslant 200$, $1 \\leqslant M \\leqslant 10^5$, $1 \\leqslant Q \\leqslant 10^4$\n\n对于 $100\\%$ 的数据都符合题目中所描述的限制关系，数据保证每次插入的位置均不超过当时书架上书的数量，而且保证 $Q$ 次查询中的每个位置上一定有书。", "locale": "zh-CN"}}}
{"pid": "P3851", "type": "P", "difficulty": 6, "samples": [["5 5\n4\n*****\n*P..*\nO**.O\n*P..*\n*****", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "各省省选", "网络流", "天津"], "title": "[TJOI2007] 脱险", "background": "一批探险队员正在一个迷宫一样的山洞里摸索，突然他们得到了一个糟糕的消息，由于附近发生地震，这个山洞将有可能在 $T$ 个单位时间后坍塌。现在他们要用最快的速度找出一个方案，使得在 $T$ 个单位时间内逃出的队员最多。已知探险队员在一个单位时间内可以向前后左右任一方向移动一格，也可以停留在原地不动。有一个糟糕的情况是，虽然山洞的内部比较宽敞，但山洞的出口都非常狭窄，一个单位时间只能允许一名队员通过。\n", "description": "山洞的地图用一个 $R \\times C$ 的字符矩阵表示：\n\n- `.` 表示在开始的时候没有探险队员的空地，空地可以容纳任意多的探险队员；\n- `P`表示在开始的时候有探险队员的空地，我们假设在开始的时候所有的队员都在不同的位置上，且没有队员恰好位于出口所在的方格；\n- `*` 表示障碍物，探险队员不能经过被障碍物占据的方格；\n- `O`（大写字母 `O`）表示出口，输入数据保证出口一定位于地图的边界上，即只有第 $1$ 行，第 $R$ 行，第 $1$ 列，第 $C$ 列有可能出现 `O`。\n\n另外，输入数据保证整个地图被边界和出口围住，即第 $1$ 行，第 $R$ 行，第 $1$ 列，第 $C$ 列只能是 `*` 或 `O`。\n", "inputFormat": "输入文件的第一行是用空格隔开的两个整数 $R$ 和 $C$，表示地图的大小。第二行是整数 $T$，即山洞将要坍塌的时间。接下来 $R$ 行，每行包含 $C$ 个字符，表示一幅山洞地图。\n", "outputFormat": "输出一行，包含一个整数，即 $T$ 个单位时间内最多能逃出的人数。\n", "hint": "山洞有两个出口，但只有右边的出口是可以到达的。虽然在 $3$ 个单位时间内两人都可以到达出口左侧的方格处，但由于在出口处一个单位时间只能允许一人通过，故 $4$ 个单位时间内只能逃出一人。两人都逃出需要 $5$ 个单位时间。\n\n- 对于 $30\\%$ 的数据，队员数和出口数均不超过 $10$；\n- 对于 $100\\%$ 的数据，$3 \\le R, C \\le 12，0 < T \\le 50$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2007] Escape", "background": "A group of explorers are groping their way through a maze-like cave when they suddenly receive bad news: due to an earthquake nearby, this cave may collapse after $T$ time units. Now they must quickly find a plan that maximizes the number of explorers who can escape within $T$ time units. In one time unit, an explorer can move one cell up, down, left, or right, or stay in place. Unfortunately, although the inside of the cave is spacious, the exits are very narrow: at most one explorer can pass through an exit per time unit.", "description": "The cave map is represented by an $R \\times C$ character matrix:\n\n- `.` means an empty cell with no explorer at the beginning; an empty cell can hold any number of explorers.\n- `P` means an empty cell with an explorer at the beginning. We assume that initially all explorers are in distinct cells, and no explorer is initially on an exit cell.\n- `*` means an obstacle; explorers cannot pass through cells occupied by obstacles.\n- `O` (capital letter O) means an exit. The input guarantees that every exit lies on the boundary of the map, i.e., `O` can appear only in row $1$, row $R$, column $1$, or column $C$.\n\nAdditionally, the input guarantees that the entire map is enclosed by boundary and exits, i.e., in row $1$, row $R$, column $1$, and column $C$, only `*` or `O` may appear.", "inputFormat": "The first line contains two integers $R$ and $C$ separated by a space, denoting the size of the map. The second line contains the integer $T$, the time until the cave collapses. The next $R$ lines each contain $C$ characters, describing a cave map.", "outputFormat": "Output one line containing a single integer, the maximum number of explorers that can escape within $T$ time units.", "hint": "The cave has two exits, but only the right exit is reachable. Although in $3$ time units both people can reach the cell to the left of the exit, because at most one person can pass through the exit per time unit, only one person can escape within $4$ time units. Both can escape in $5$ time units.\n\n- For $30\\%$ of the testdata, the numbers of explorers and exits are both at most $10$.\n- For $100\\%$ of the testdata, $3 \\le R, C \\le 12$, $0 < T \\le 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2007] 脱险", "background": "一批探险队员正在一个迷宫一样的山洞里摸索，突然他们得到了一个糟糕的消息，由于附近发生地震，这个山洞将有可能在 $T$ 个单位时间后坍塌。现在他们要用最快的速度找出一个方案，使得在 $T$ 个单位时间内逃出的队员最多。已知探险队员在一个单位时间内可以向前后左右任一方向移动一格，也可以停留在原地不动。有一个糟糕的情况是，虽然山洞的内部比较宽敞，但山洞的出口都非常狭窄，一个单位时间只能允许一名队员通过。\n", "description": "山洞的地图用一个 $R \\times C$ 的字符矩阵表示：\n\n- `.` 表示在开始的时候没有探险队员的空地，空地可以容纳任意多的探险队员；\n- `P`表示在开始的时候有探险队员的空地，我们假设在开始的时候所有的队员都在不同的位置上，且没有队员恰好位于出口所在的方格；\n- `*` 表示障碍物，探险队员不能经过被障碍物占据的方格；\n- `O`（大写字母 `O`）表示出口，输入数据保证出口一定位于地图的边界上，即只有第 $1$ 行，第 $R$ 行，第 $1$ 列，第 $C$ 列有可能出现 `O`。\n\n另外，输入数据保证整个地图被边界和出口围住，即第 $1$ 行，第 $R$ 行，第 $1$ 列，第 $C$ 列只能是 `*` 或 `O`。\n", "inputFormat": "输入文件的第一行是用空格隔开的两个整数 $R$ 和 $C$，表示地图的大小。第二行是整数 $T$，即山洞将要坍塌的时间。接下来 $R$ 行，每行包含 $C$ 个字符，表示一幅山洞地图。\n", "outputFormat": "输出一行，包含一个整数，即 $T$ 个单位时间内最多能逃出的人数。\n", "hint": "山洞有两个出口，但只有右边的出口是可以到达的。虽然在 $3$ 个单位时间内两人都可以到达出口左侧的方格处，但由于在出口处一个单位时间只能允许一人通过，故 $4$ 个单位时间内只能逃出一人。两人都逃出需要 $5$ 个单位时间。\n\n- 对于 $30\\%$ 的数据，队员数和出口数均不超过 $10$；\n- 对于 $100\\%$ 的数据，$3 \\le R, C \\le 12，0 < T \\le 50$。\n", "locale": "zh-CN"}}}
{"pid": "P3852", "type": "P", "difficulty": 6, "samples": [["5 6\n1 2\n3 2\n1 3\n3 5\n3 4\n4 5", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "各省省选", "天津", "弦图"], "title": "[TJOI2007] 小朋友", "background": "幼儿园里有N个小朋友，老师要从中选出来一部分做丢手绢的游戏，可是老师没有想到这么小的孩子里面有些人之间还有矛盾。老师想找出尽量多的小朋友去玩游戏，但是又很头疼，他不想看到找出来玩游戏的小朋友里面还有任何两个人之间存在着矛盾。如果告诉你小朋友之间存在的M对矛盾关系，你能否帮助幼儿园老师计算出他最多可以选出多少个小朋友来做这个丢手绢的游戏？\n", "description": "关于矛盾限制的说明：\n\n如果我们把存在着矛盾的两个小朋友看作是无向图中相连的两个点，那么题目中的数据保证M对矛盾所构成的图中不会有超过3个点的环。（图1符合要求，图2则不符合）\n\n![](https://cdn.luogu.com.cn/upload/pic/6098.png)\n", "inputFormat": "输入文件的第一行是用空格隔开的两个整数N和M，表示一共有N个小朋友，这些小朋友之间有M对矛盾关系。接下来的M行，每行将有一对整数a和b（用空格隔开），表示小朋友a与小朋友b有矛盾。（小朋友的编号都是从1开始的）\n", "outputFormat": "输出一行，包含一个整数，即幼儿园老师最多可以选出来做游戏的人数。\n", "hint": "幼儿园有6个小朋友，矛盾关系中1 - 2 - 3组成一个环，3 - 4 - 5组成一个环，因此只能在这两个环中分别选一个小朋友，并且不能选择3号小朋友。\n\n    \n对于20%的数据，1 ≤ N ≤ 20\n\n对于40%的数据，1 ≤ N ≤ 50\n\n对于100%的数据，1 ≤ N ≤ 200\n\n对于100%的数据都符合题目中所描述的矛盾限制关系。\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2007] Children", "background": "There are $N$ children in a kindergarten. The teacher wants to select some of them to play a \"drop the handkerchief\" game. However, the teacher did not expect that even among such young children, some pairs have conflicts. The teacher wants to include as many children as possible in the game, but he is troubled because he does not want any two selected children to have a conflict. Given $M$ pairs of conflicts among the children, can you help the teacher compute the maximum number of children he can select for this game?", "description": "Explanation of the conflict constraint:\n\nIf we regard any two conflicting children as two adjacent vertices in an undirected graph, the testdata guarantees that the graph formed by the $M$ conflicting pairs contains no cycle with more than 3 vertices. (Figure 1 satisfies the requirement, while Figure 2 does not.)\n\n![](https://cdn.luogu.com.cn/upload/pic/6098.png)", "inputFormat": "The first line contains two integers $N$ and $M$ separated by a space, indicating there are $N$ children and $M$ pairs of conflicts. Each of the next $M$ lines contains two integers $a$ and $b$ (separated by a space), meaning that child $a$ and child $b$ have a conflict. (Children are numbered starting from $1$.)", "outputFormat": "Output one line containing a single integer — the maximum number of children the teacher can select to play the game.", "hint": "There are 6 children. The conflicts contain a cycle $1 - 2 - 3$ and another cycle $3 - 4 - 5$. Therefore, you can select exactly one child from each of these two cycles, and child $3$ cannot be selected.\n\nConstraints:\n- For $20\\%$ of the testdata, $1 \\le N \\le 20$.\n- For $40\\%$ of the testdata, $1 \\le N \\le 50$.\n- For $100\\%$ of the testdata, $1 \\le N \\le 200$.\n- All $100\\%$ of the testdata satisfy the conflict constraint described in the problem.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2007] 小朋友", "background": "幼儿园里有N个小朋友，老师要从中选出来一部分做丢手绢的游戏，可是老师没有想到这么小的孩子里面有些人之间还有矛盾。老师想找出尽量多的小朋友去玩游戏，但是又很头疼，他不想看到找出来玩游戏的小朋友里面还有任何两个人之间存在着矛盾。如果告诉你小朋友之间存在的M对矛盾关系，你能否帮助幼儿园老师计算出他最多可以选出多少个小朋友来做这个丢手绢的游戏？\n", "description": "关于矛盾限制的说明：\n\n如果我们把存在着矛盾的两个小朋友看作是无向图中相连的两个点，那么题目中的数据保证M对矛盾所构成的图中不会有超过3个点的环。（图1符合要求，图2则不符合）\n\n![](https://cdn.luogu.com.cn/upload/pic/6098.png)\n", "inputFormat": "输入文件的第一行是用空格隔开的两个整数N和M，表示一共有N个小朋友，这些小朋友之间有M对矛盾关系。接下来的M行，每行将有一对整数a和b（用空格隔开），表示小朋友a与小朋友b有矛盾。（小朋友的编号都是从1开始的）\n", "outputFormat": "输出一行，包含一个整数，即幼儿园老师最多可以选出来做游戏的人数。\n", "hint": "幼儿园有6个小朋友，矛盾关系中1 - 2 - 3组成一个环，3 - 4 - 5组成一个环，因此只能在这两个环中分别选一个小朋友，并且不能选择3号小朋友。\n\n    \n对于20%的数据，1 ≤ N ≤ 20\n\n对于40%的数据，1 ≤ N ≤ 50\n\n对于100%的数据，1 ≤ N ≤ 200\n\n对于100%的数据都符合题目中所描述的矛盾限制关系。\n", "locale": "zh-CN"}}}
{"pid": "P3853", "type": "P", "difficulty": 3, "samples": [["101 2 1\n0 101", "51"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "搜索", "2007", "二分", "各省省选", "天津"], "title": "[TJOI2007] 路标设置", "background": "B 市和 T 市之间有一条长长的高速公路，这条公路的某些地方设有路标，但是大家都感觉路标设得太少了，相邻两个路标之间往往隔着相当长的一段距离。为了便于研究这个问题，我们把公路上相邻路标的最大距离定义为该公路的“空旷指数”。\n", "description": "现在政府决定在公路上增设一些路标，使得公路的“空旷指数”最小。他们请求你设计一个程序计算能达到的最小值是多少。请注意，公路的起点和终点保证已设有路标，公路的长度为整数，并且原有路标和新设路标都必须距起点整数个单位距离。\n", "inputFormat": "第 $1$ 行包括三个数 $L,N,K$，分别表示公路的长度，原有路标的数量，以及最多可增设的路标数量。\n\n\n第 $2$ 行包括递增排列的 $N$ 个整数，分别表示原有的 $N$ 个路标的位置。路标的位置用距起点的距离表示，且一定位于区间 $[0,L]$ 内。\n", "outputFormat": "输出 $1$ 行，包含一个整数，表示增设路标后能达到的最小“空旷指数”值。\n", "hint": "公路原来只在起点和终点处有两个路标，现在允许新增一个路标，应该把新路标设在距起点 $50$ 或 $51$ 个单位距离处，这样能达到最小的空旷指数 $51$。\n\n$50\\%$ 的数据中，$2 \\leq N \\leq 100$，$0 \\leq K \\leq 100$。\n\n$100\\%$ 的数据中，$2 \\leq N \\leq 100000$, $0 \\leq K \\leq100000$。\n\n$100\\%$ 的数据中，$0 < L \\leq 10000000$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2007] Road Sign Placement", "background": "There is a long highway between city B and city T. Some places along this highway have signposts, but everyone feels there are too few; adjacent signposts are often separated by a rather long distance. To study this problem, we define the maximum distance between adjacent signposts on the highway as the highway’s \"emptiness index\".", "description": "Now the government plans to add some signposts on the highway to minimize the highway’s \"emptiness index\". They ask you to design a program to compute the minimum achievable value. Note that the start and the end of the highway are guaranteed to already have signposts, the highway length is an integer, and both existing and newly added signposts must be at integer distances from the start.", "inputFormat": "The first line contains three integers $L,N,K$, representing the highway length, the number of existing signposts, and the maximum number of signposts that can be added, respectively.\n\nThe second line contains $N$ integers in increasing order, representing the positions of the existing $N$ signposts. Each position is the distance from the start and lies within the interval $[0,L]$.", "outputFormat": "Output one line containing a single integer, the minimum \"emptiness index\" achievable after adding signposts.", "hint": "Originally, the highway had only two signposts at the start and the end. Now you are allowed to add one signpost. You should place the new signpost at a distance of $50$ or $51$ from the start, which yields the minimum emptiness index of $51$.\n\nConstraints:\n- In $50\\%$ of the testdata, $2 \\leq N \\leq 100$, $0 \\leq K \\leq 100$.\n- In $100\\%$ of the testdata, $2 \\leq N \\leq 100000$, $0 \\leq K \\leq 100000$.\n- In $100\\%$ of the testdata, $0 < L \\leq 10000000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2007] 路标设置", "background": "B 市和 T 市之间有一条长长的高速公路，这条公路的某些地方设有路标，但是大家都感觉路标设得太少了，相邻两个路标之间往往隔着相当长的一段距离。为了便于研究这个问题，我们把公路上相邻路标的最大距离定义为该公路的“空旷指数”。\n", "description": "现在政府决定在公路上增设一些路标，使得公路的“空旷指数”最小。他们请求你设计一个程序计算能达到的最小值是多少。请注意，公路的起点和终点保证已设有路标，公路的长度为整数，并且原有路标和新设路标都必须距起点整数个单位距离。\n", "inputFormat": "第 $1$ 行包括三个数 $L,N,K$，分别表示公路的长度，原有路标的数量，以及最多可增设的路标数量。\n\n\n第 $2$ 行包括递增排列的 $N$ 个整数，分别表示原有的 $N$ 个路标的位置。路标的位置用距起点的距离表示，且一定位于区间 $[0,L]$ 内。\n", "outputFormat": "输出 $1$ 行，包含一个整数，表示增设路标后能达到的最小“空旷指数”值。\n", "hint": "公路原来只在起点和终点处有两个路标，现在允许新增一个路标，应该把新路标设在距起点 $50$ 或 $51$ 个单位距离处，这样能达到最小的空旷指数 $51$。\n\n$50\\%$ 的数据中，$2 \\leq N \\leq 100$，$0 \\leq K \\leq 100$。\n\n$100\\%$ 的数据中，$2 \\leq N \\leq 100000$, $0 \\leq K \\leq100000$。\n\n$100\\%$ 的数据中，$0 < L \\leq 10000000$。", "locale": "zh-CN"}}}
{"pid": "P3854", "type": "P", "difficulty": 5, "samples": [["5 6\n1 2\n1 3\n2 3\n3 4\n3 5\n4 5\n3\n1 5 3\n1 5 4\n4 5 3\n", "yes\nno\nno\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "各省省选", "分治", "Tarjan", "最近公共祖先 LCA", "天津", "圆方树", "线段树分治"], "title": "[TJOI2008] 通讯网破坏", "background": "由于争夺资源引起的矛盾冲突，$A$ 国和 $B$ 国进入了战争一触即发的状态。现在 $A$ 国的间谍机构设法得到了 $B$ 国的通讯网络布置情况，其中每个城市可以看作一个点，在某些点之间有无向边，表示这些城市之间可以进行双向的直接通讯。$A$ 国打算先发制人，通过核武器毁灭某个中间城市 $M$，一举切断B国某两个重要城市 $S$ , $T$ 之间的联系，即从图中删除掉 $M$ 点之后，$S$ 和 $T$ 变得不连通。但是由于 $B$ 国的防御力量也很强大，这样的核打击只能成功进行一次且只能毁灭一个城市。\n", "description": "现在 $A$ 国的首脑提出了很多种作战策略，作为 $A$ 国的首席计算机科学家，你的任务是编写一个程序决定这些策略可行与否。\n", "inputFormat": "输入文件的第一行为两个整数 $N$ 和 $M$，表示 $B$ 国的城市数和可以直接通讯的城市对数目。接下来的 $M$ 行，每行包括两个整数 $C_i$ 和 $D_i$，$1\\leq C_i,D_i \\leq N$ 且 $C_i \\neq D_i$，表示城市 $C_i$ 和 $D_i$ 之间可以直接通讯。输入数据保证每对 $(C_i,D_i)$ 最多出现一次。\n\n接下来一行是一个整数 $Q$，表示 $A$ 国首脑作出的策略数。接下来的 $Q$ 行，每行包括三个整数 $S_i,T_i,M_i$（$1 \\leq S_i,T_i,M_i\\leq N$，且 $M_i,S_i,T_i$ 三个数互不相等）表示这个策略的内容是通过毁灭 $M_i$ 来切断 $S_i$ 和 $T_i$ 之间的联系。\n", "outputFormat": "输出 $Q$ 行，表示对应的策略可行与否。如果毁灭 $M_i$ 以后，$S_i$ 和 $T_i$ 之间不能通讯，说明此策略可行，则应在第 $i$ 行输出 $\\mathtt{yes}$，否则输出 $\\mathtt{no}$。\n", "hint": "对于 $30\\%$ 的数据，$1 \\leq N \\leq 100,1 \\leq Q \\leq 100$。\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 20000,1\\leq M\\leq 100000,1 \\leq Q \\leq 100000$。\n\n输入数据保证原图的任意两点是连通的。\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2008] Communication Network Destruction", "background": "Due to conflicts over resources, countries $A$ and $B$ are on the verge of war. Country $A$'s intelligence agency has obtained the layout of country $B$'s communication network, where each city is a vertex, and some pairs of vertices are connected by undirected edges, indicating direct bidirectional communication between those cities. Country $A$ plans to strike first by destroying an intermediate city $M$ with nuclear weapons to sever the connection between two important cities $S$ and $T$ in country $B$. That is, after removing vertex $M$ from the graph, $S$ and $T$ become disconnected. However, since country $B$'s defenses are strong, such a nuclear strike can succeed only once and can destroy only one city.", "description": "The leaders of country $A$ have proposed many strategies. As the chief computer scientist of country $A$, your task is to write a program to determine whether each strategy is feasible.", "inputFormat": "The first line contains two integers $N$ and $M$, representing the number of cities in country $B$ and the number of pairs of cities that can communicate directly. The next $M$ lines each contain two integers $C_i$ and $D_i$, $1\\leq C_i,D_i \\leq N$ and $C_i \\neq D_i$, indicating that cities $C_i$ and $D_i$ can communicate directly. It is guaranteed that each pair $(C_i,D_i)$ appears at most once.\n\nThe next line contains an integer $Q$, representing the number of strategies proposed by the leaders of country $A$. The next $Q$ lines each contain three integers $S_i, T_i, M_i$ ($1 \\leq S_i,T_i,M_i\\leq N$, and $M_i, S_i, T_i$ are pairwise distinct), indicating that this strategy attempts to sever communication between $S_i$ and $T_i$ by destroying $M_i$.", "outputFormat": "Output $Q$ lines, each indicating whether the corresponding strategy is feasible. If, after destroying $M_i$, $S_i$ and $T_i$ cannot communicate, then the strategy is feasible and you should output $\\mathtt{yes}$ on the $i$-th line; otherwise, output $\\mathtt{no}$.", "hint": "For $30\\%$ of the testdata, $1 \\leq N \\leq 100,1 \\leq Q \\leq 100$.\n\nFor $100\\%$ of the testdata, $1 \\leq N \\leq 20000,1\\leq M\\leq 100000,1 \\leq Q \\leq 100000$.\n\nIt is guaranteed that the original graph is connected.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2008] 通讯网破坏", "background": "由于争夺资源引起的矛盾冲突，$A$ 国和 $B$ 国进入了战争一触即发的状态。现在 $A$ 国的间谍机构设法得到了 $B$ 国的通讯网络布置情况，其中每个城市可以看作一个点，在某些点之间有无向边，表示这些城市之间可以进行双向的直接通讯。$A$ 国打算先发制人，通过核武器毁灭某个中间城市 $M$，一举切断B国某两个重要城市 $S$ , $T$ 之间的联系，即从图中删除掉 $M$ 点之后，$S$ 和 $T$ 变得不连通。但是由于 $B$ 国的防御力量也很强大，这样的核打击只能成功进行一次且只能毁灭一个城市。\n", "description": "现在 $A$ 国的首脑提出了很多种作战策略，作为 $A$ 国的首席计算机科学家，你的任务是编写一个程序决定这些策略可行与否。\n", "inputFormat": "输入文件的第一行为两个整数 $N$ 和 $M$，表示 $B$ 国的城市数和可以直接通讯的城市对数目。接下来的 $M$ 行，每行包括两个整数 $C_i$ 和 $D_i$，$1\\leq C_i,D_i \\leq N$ 且 $C_i \\neq D_i$，表示城市 $C_i$ 和 $D_i$ 之间可以直接通讯。输入数据保证每对 $(C_i,D_i)$ 最多出现一次。\n\n接下来一行是一个整数 $Q$，表示 $A$ 国首脑作出的策略数。接下来的 $Q$ 行，每行包括三个整数 $S_i,T_i,M_i$（$1 \\leq S_i,T_i,M_i\\leq N$，且 $M_i,S_i,T_i$ 三个数互不相等）表示这个策略的内容是通过毁灭 $M_i$ 来切断 $S_i$ 和 $T_i$ 之间的联系。\n", "outputFormat": "输出 $Q$ 行，表示对应的策略可行与否。如果毁灭 $M_i$ 以后，$S_i$ 和 $T_i$ 之间不能通讯，说明此策略可行，则应在第 $i$ 行输出 $\\mathtt{yes}$，否则输出 $\\mathtt{no}$。\n", "hint": "对于 $30\\%$ 的数据，$1 \\leq N \\leq 100,1 \\leq Q \\leq 100$。\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 20000,1\\leq M\\leq 100000,1 \\leq Q \\leq 100000$。\n\n输入数据保证原图的任意两点是连通的。\n", "locale": "zh-CN"}}}
{"pid": "P3855", "type": "P", "difficulty": 4, "samples": [["4 7\n#######\n#..T..#\n#G##M##\n#######\n", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2008", "各省省选", "广度优先搜索 BFS", "天津"], "title": "[TJOI2008] Binary Land", "background": "Binary Land是一款任天堂红白机上的经典游戏，讲述的是两只相爱的企鹅Gurin和Malon的故事。两只企鹅在一个封闭的迷宫中，你可以控制他们向上下左右四个方向移动。但是他们的移动有一个奇怪的规则，即如果你按“上”或“下”方向键，两只企鹅会同时向上移动或向下移动1格；如果你按“左”方向键，则Malon向左移动1格，同时Gurin向右移动1格；如果你按“右”方向键，则Malon向右移动1格，Gurin向左移动1格。当然，如果某只企鹅被障碍挡住，它就不会移动了。另外，在迷宫的某些格子处有蜘蛛网，如果任何一只企鹅进入这种格子，则游戏失败。两只企鹅不会相互阻挡，即在相向运动时他们可以“穿过”彼此，也可以同时处于同一格子里。迷宫的某个格子上有一颗红心，游戏的任务就是使两只企鹅同时到达这个格子。\n\n![](https://cdn.luogu.com.cn/upload/pic/6099.png)\n", "description": "请编写程序找出完成任务所需的最少的操作步数。如果无法完成目标，输出“no”。\n", "inputFormat": "第一行包含两个整数R, C 表示迷宫的长和宽。\n\n按下来有R行，每行包含C个字符，描述了一个迷宫。其中’#’表示企鹅不能通过的障碍物，’X’表示蜘蛛网，’.’表示空地，’G’表示Gurin的初始位置，’M’表示Malon的初始位置，’T’表示终点位置。\n\n输入数据保证标有’G’,’M’,’T’的格子分别只有一个，保证企鹅不可能走到迷宫以外。\n", "outputFormat": "输出只有一行，为最少的操作步数。如果不能完成任务，输出“no”。\n", "hint": "满足要求的一个操作序列为：上－右－左－左\n\n3 ≤ R, C ≤ 30\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2008] Binary Land", "background": "Binary Land is a classic game on the Nintendo Famicom. It tells the story of two penguins in love, Gurin and Malon. The two penguins are in a closed maze, and you can move them in the four directions: up, down, left, and right. However, there is a strange rule for their movement: if you press \"Up\" or \"Down\", both penguins move up or down by 1 cell at the same time; if you press \"Left\", then Malon moves left by 1 cell while Gurin moves right by 1 cell; if you press \"Right\", then Malon moves right by 1 cell while Gurin moves left by 1 cell. Of course, if a penguin is blocked by an obstacle, it will not move. In addition, some cells in the maze contain spider webs; if either penguin enters such a cell, the game fails. The two penguins do not block each other: when moving toward each other they can \"pass through\" one another and may also occupy the same cell at the same time. One cell of the maze has a heart; the goal is to make both penguins reach this cell simultaneously.\n\n![](https://cdn.luogu.com.cn/upload/pic/6099.png)", "description": "Write a program to find the minimum number of moves required to complete the task. If it is impossible, output \"no\".", "inputFormat": "The first line contains two integers R, C, the number of rows and columns of the maze.\n\nThen follow R lines, each containing C characters that describe the maze. '#' denotes an obstacle the penguins cannot pass, 'X' denotes a spider web, '.' denotes empty ground, 'G' denotes Gurin's initial position, 'M' denotes Malon's initial position, and 'T' denotes the target position.\n\nIt is guaranteed that there is exactly one cell labeled 'G', 'M', and 'T', respectively, and that the penguins can never move outside the maze.", "outputFormat": "Output a single line with the minimum number of moves. If the goal cannot be achieved, output \"no\".", "hint": "One valid sequence of moves is: Up-Right-Left-Left.\n\n3 ≤ R, C ≤ 30.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2008] Binary Land", "background": "Binary Land是一款任天堂红白机上的经典游戏，讲述的是两只相爱的企鹅Gurin和Malon的故事。两只企鹅在一个封闭的迷宫中，你可以控制他们向上下左右四个方向移动。但是他们的移动有一个奇怪的规则，即如果你按“上”或“下”方向键，两只企鹅会同时向上移动或向下移动1格；如果你按“左”方向键，则Malon向左移动1格，同时Gurin向右移动1格；如果你按“右”方向键，则Malon向右移动1格，Gurin向左移动1格。当然，如果某只企鹅被障碍挡住，它就不会移动了。另外，在迷宫的某些格子处有蜘蛛网，如果任何一只企鹅进入这种格子，则游戏失败。两只企鹅不会相互阻挡，即在相向运动时他们可以“穿过”彼此，也可以同时处于同一格子里。迷宫的某个格子上有一颗红心，游戏的任务就是使两只企鹅同时到达这个格子。\n\n![](https://cdn.luogu.com.cn/upload/pic/6099.png)\n", "description": "请编写程序找出完成任务所需的最少的操作步数。如果无法完成目标，输出“no”。\n", "inputFormat": "第一行包含两个整数R, C 表示迷宫的长和宽。\n\n按下来有R行，每行包含C个字符，描述了一个迷宫。其中’#’表示企鹅不能通过的障碍物，’X’表示蜘蛛网，’.’表示空地，’G’表示Gurin的初始位置，’M’表示Malon的初始位置，’T’表示终点位置。\n\n输入数据保证标有’G’,’M’,’T’的格子分别只有一个，保证企鹅不可能走到迷宫以外。\n", "outputFormat": "输出只有一行，为最少的操作步数。如果不能完成任务，输出“no”。\n", "hint": "满足要求的一个操作序列为：上－右－左－左\n\n3 ≤ R, C ≤ 30\n", "locale": "zh-CN"}}}
{"pid": "P3856", "type": "P", "difficulty": 6, "samples": [["apartment\napache\napproach\n", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2008", "各省省选", "枚举", "天津"], "title": "[TJOI2008] 公共子串", "background": "", "description": "一个字符串的子串是在这个串基础上去掉0个或者若干个字符所形成的，例如abc, aa和abbc都是字符串aabbcc的子串，而aba不是。 现给你三个字符串，请问他们三个共同含有多少种子串（不算空串）?\n\n注意： 有些相同的公共子串尽管出现在不同的位置，但仍算1种，详见样例。\n", "inputFormat": "每组测试数据只有3行，每行都是一个只包含有小写字母的字符串。\n", "outputFormat": "输出3个字符串共有的公共子串种类数。\n", "hint": "3个字符串共有的公共子串有： “a”, “p”, “ap”, “pa”, “aa”, “apa”。 其中子串 “a” 有多个，但由于统计的是公共子串种类，所以 “a” 只算1种子串。\n\n\n100%的数据中，字符串的长度不超过100。字符串中只含有小写字母。\n\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2008] Common Substrings", "background": "", "description": "A substring of a string is a contiguous block of characters. For example, for the string aabbcc, aa and abbc are substrings, while abc and aba are not. Now, given three strings, how many distinct substrings do all three of them contain in common (excluding the empty string)?\n\nNote: Even if the same common substring appears at different positions, it still counts as 1 kind only. See the example.", "inputFormat": "Each test case consists of 3 lines. Each line is a string containing only lowercase letters.", "outputFormat": "Output the number of distinct substrings common to the 3 strings.", "hint": "The substrings common to the 3 strings are: \"a\", \"p\", \"ap\", \"pa\", \"aa\", \"apa\". Among them, the substring \"a\" occurs multiple times, but since we count kinds of common substrings, \"a\" counts as only 1 kind.\n\nIn 100% of the testdata, the length of each string does not exceed 100. Each string contains only lowercase letters.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2008] 公共子串", "background": "", "description": "一个字符串的子串是在这个串基础上去掉0个或者若干个字符所形成的，例如abc, aa和abbc都是字符串aabbcc的子串，而aba不是。 现给你三个字符串，请问他们三个共同含有多少种子串（不算空串）?\n\n注意： 有些相同的公共子串尽管出现在不同的位置，但仍算1种，详见样例。\n", "inputFormat": "每组测试数据只有3行，每行都是一个只包含有小写字母的字符串。\n", "outputFormat": "输出3个字符串共有的公共子串种类数。\n", "hint": "3个字符串共有的公共子串有： “a”, “p”, “ap”, “pa”, “aa”, “apa”。 其中子串 “a” 有多个，但由于统计的是公共子串种类，所以 “a” 只算1种子串。\n\n\n100%的数据中，字符串的长度不超过100。字符串中只含有小写字母。\n\n\n", "locale": "zh-CN"}}}
{"pid": "P3857", "type": "P", "difficulty": 5, "samples": [["2 3\nOO\nXO\nOX\n", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "各省省选", "进制", "线性基", "构造", "天津"], "title": "[TJOI2008] 彩灯", "background": "", "description": "Peter 女朋友的生日快到了，他亲自设计了一组彩灯，想给女朋友一个惊喜。已知一组彩灯是由一排 $N$ 个独立的灯泡构成的，并且有 $M$ 个开关控制它们。从数学的角度看，这一排彩灯的任何一个彩灯只有亮与不亮两个状态，所以共有 $2^N$ 个样式。由于技术上的问题，Peter 设计的每个开关控制的彩灯没有什么规律，当一个开关被按下的时候，它会把所有它控制的彩灯改变状态（即亮变成不亮，不亮变成亮）。假如告诉你他设计的每个开关所控制的彩灯范围，你能否帮他计算出这些彩灯有多少种样式可以展示给他的女朋友？\n\n注： 开始时所有彩灯都是不亮的状态。", "inputFormat": "每组测试数据第一行为两个整数 $N$ 和 $M$，用空格隔开。紧接着是有 $M$ 行，每行都是一个长度为 $N$ 的字符串，表示一个开关控制彩灯的范围（$N$ 盏灯），如果第 $i$ 个字母是大写字母 `O`，则表示这个开关控制第 $i$ 盏灯，如果第 $i$ 个字母是大写字母 `X`，则表示这个开关不控制此灯。", "outputFormat": "输出这些开关和彩灯可以变换出来的样式数目。由于这个值可能会很大，请求出它对于整数 $2008$ 的余数。", "hint": "可见样例中第一个开关控制了所有的彩灯，而后两个开关分别控制了第一个和第二个彩灯，这样我们可以只用后两个开关控制彩灯，可以变换出来所有的 $2^2$ 个状态。\n\n对于 $30\\%$ 的数据，$N$ 和 $M$ 不超过 $15$。\n\n另外有 $40\\%$ 的数据，$N$ 和 $M$ 有一个为 $50$。\n\n对于 $100\\%$ 的数据，$N$ 和 $M$ 不超过 $50$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2008] Colored Lights", "background": "Peter’s girlfriend’s birthday is coming, and he designed a set of colored lights as a surprise. A set consists of a row of $N$ independent bulbs, controlled by $M$ switches. Mathematically, each bulb has exactly two states, on or off, so there are $2^N$ possible patterns. Due to technical reasons, the bulbs controlled by each switch have no particular pattern: when a switch is pressed, it toggles the state of every bulb it controls (on becomes off, off becomes on). Given the set of bulbs each switch controls, can you compute how many distinct lighting patterns can be displayed?\n\nNote: Initially, all bulbs are off.", "description": "", "inputFormat": "", "outputFormat": "Output the number of distinct patterns obtainable by these switches and bulbs. Since this number can be large, output it modulo the integer $2008$.", "hint": "As seen in the sample, the first switch controls all bulbs, while the next two switches control the first and second bulbs respectively. In this case, using only the latter two switches suffices to obtain all $2^2$ states.\n\nConstraints:\n- For $30\\%$ of the testdata, $N$ and $M$ do not exceed $15$.\n- Additionally, for $40\\%$ of the testdata, one of $N$ and $M$ equals $50$.\n- For $100\\%$ of the testdata, $N$ and $M$ do not exceed $50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2008] 彩灯", "background": "", "description": "Peter 女朋友的生日快到了，他亲自设计了一组彩灯，想给女朋友一个惊喜。已知一组彩灯是由一排 $N$ 个独立的灯泡构成的，并且有 $M$ 个开关控制它们。从数学的角度看，这一排彩灯的任何一个彩灯只有亮与不亮两个状态，所以共有 $2^N$ 个样式。由于技术上的问题，Peter 设计的每个开关控制的彩灯没有什么规律，当一个开关被按下的时候，它会把所有它控制的彩灯改变状态（即亮变成不亮，不亮变成亮）。假如告诉你他设计的每个开关所控制的彩灯范围，你能否帮他计算出这些彩灯有多少种样式可以展示给他的女朋友？\n\n注： 开始时所有彩灯都是不亮的状态。", "inputFormat": "每组测试数据第一行为两个整数 $N$ 和 $M$，用空格隔开。紧接着是有 $M$ 行，每行都是一个长度为 $N$ 的字符串，表示一个开关控制彩灯的范围（$N$ 盏灯），如果第 $i$ 个字母是大写字母 `O`，则表示这个开关控制第 $i$ 盏灯，如果第 $i$ 个字母是大写字母 `X`，则表示这个开关不控制此灯。", "outputFormat": "输出这些开关和彩灯可以变换出来的样式数目。由于这个值可能会很大，请求出它对于整数 $2008$ 的余数。", "hint": "可见样例中第一个开关控制了所有的彩灯，而后两个开关分别控制了第一个和第二个彩灯，这样我们可以只用后两个开关控制彩灯，可以变换出来所有的 $2^2$ 个状态。\n\n对于 $30\\%$ 的数据，$N$ 和 $M$ 不超过 $15$。\n\n另外有 $40\\%$ 的数据，$N$ 和 $M$ 有一个为 $50$。\n\n对于 $100\\%$ 的数据，$N$ 和 $M$ 不超过 $50$。", "locale": "zh-CN"}}}
