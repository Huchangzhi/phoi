{"pid": "P13796", "type": "P", "difficulty": 3, "samples": [["7\n0 5 3 1 4 8 2", "13/4"], ["5\n3 5 8 7 1", "0"]], "limits": {"time": [250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250], "memory": [16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384]}, "tags": ["2023", "ICPC", "单调栈"], "title": "[SWERC 2023] Nicest view", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/93613cfd23ca0223b6f9aa573bf5381a7646cd95.png)\n\n:::\n\nParis is so crowded with tourists during the Olympic games! You want to escape the city and go on a hike on a linear trail path, going from left to right. Every kilometre on that trail, including at start and end, is a milestone, on which is written the stone's altitude. The slope between two consecutive stones is constant, and no two stones have the same altitude.\n\n\nPlanning to come back with your friends, you try to identify the point of the hike at which you had the nicest view. The beauty of a point of view is defined as the distance (measured in kilometres) between your position and the leftmost position that you can see on your hike and that is at the same altitude as you are. If such a previous position fails to exist, it means that you can see the city and its smog, and the beauty of that view is zero.\n\n\nYou have listed the altitudes of the milestones. What is the maximal beauty on your hike?", "inputFormat": "The input consists of two lines. The first line contains a single integer $N$, which is the number of milestones on the trail path. The second line contains $N$ space-separated integers $H_1, H_2, \\dots, H_N$; each integer $H_k$ is the altitude (measured in metres) of the $k^\\text{th}$ milestone on the path.\n\n\n**Limits**\n\n- $1 \\leq N \\leq 100~000$;\n- $0 \\leq H_k \\leq 1~000~000$ for all $k \\leq N$;\n- the integers $H_k$ are pairwise distinct.\n", "outputFormat": "The output should contain a single line, consisting of a single number $S$: the best beauty score on your hike. This number is written either as an integer or as an irreducible fraction $N/D$ for which $D \\geq 2$; we recall that a fraction $N/D$ is irreducible when the greatest common divisor of $N$ and $D$ is $1$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[SWERC 2023] Nicest view", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/93613cfd23ca0223b6f9aa573bf5381a7646cd95.png)\n\n:::\n\nParis is so crowded with tourists during the Olympic games! You want to escape the city and go on a hike on a linear trail path, going from left to right. Every kilometre on that trail, including at start and end, is a milestone, on which is written the stone's altitude. The slope between two consecutive stones is constant, and no two stones have the same altitude.\n\n\nPlanning to come back with your friends, you try to identify the point of the hike at which you had the nicest view. The beauty of a point of view is defined as the distance (measured in kilometres) between your position and the leftmost position that you can see on your hike and that is at the same altitude as you are. If such a previous position fails to exist, it means that you can see the city and its smog, and the beauty of that view is zero.\n\n\nYou have listed the altitudes of the milestones. What is the maximal beauty on your hike?", "inputFormat": "The input consists of two lines. The first line contains a single integer $N$, which is the number of milestones on the trail path. The second line contains $N$ space-separated integers $H_1, H_2, \\dots, H_N$; each integer $H_k$ is the altitude (measured in metres) of the $k^\\text{th}$ milestone on the path.\n\n\n**Limits**\n\n- $1 \\leq N \\leq 100~000$;\n- $0 \\leq H_k \\leq 1~000~000$ for all $k \\leq N$;\n- the integers $H_k$ are pairwise distinct.\n", "outputFormat": "The output should contain a single line, consisting of a single number $S$: the best beauty score on your hike. This number is written either as an integer or as an irreducible fraction $N/D$ for which $D \\geq 2$; we recall that a fraction $N/D$ is irreducible when the greatest common divisor of $N$ and $D$ is $1$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[SWERC 2023] Nicest view", "background": null, "description": ":::align{center}\n\n![](https://espresso.codeforces.com/93613cfd23ca0223b6f9aa573bf5381a7646cd95.png)\n\n:::\n\n巴黎在奥运会期间被游客挤得水泄不通！你想逃离城市，沿着一条线性步道从左到右徒步旅行。步道上的每一公里处（包括起点和终点）都有一个里程碑，里程碑上写着该处的海拔高度。任意两个相邻里程碑之间的坡度是恒定的，并且没有两个里程碑的海拔高度相同。\n\n你计划以后和朋友们一起来，所以你想找出徒步过程中风景最美的那个点。某个点的“美丽值”定义为：你当前位置与你能看到的、在你左侧且海拔高度与你相同的最左侧位置之间的距离（以公里为单位）。如果不存在这样的前一个位置，说明你可以看到城市和它的雾霾，此时该点的美丽值为 $0$。\n\n你已经记录下了所有里程碑的海拔高度。请问你这次徒步过程中最大的美丽值是多少？", "inputFormat": "输入包含两行。第一行包含一个整数 $N$，表示步道上的里程碑数量。第二行包含 $N$ 个用空格分隔的整数 $H_1, H_2, \\dots, H_N$，其中 $H_k$ 表示第 $k$ 个里程碑的海拔高度（单位为米）。\n\n**数据范围**\n\n- $1 \\leq N \\leq 100\\,000$；\n- 对于所有 $k \\leq N$，$0 \\leq H_k \\leq 1\\,000\\,000$；\n- 所有 $H_k$ 两两不同。", "outputFormat": "输出仅一行，包含一个数 $S$，表示你这次徒步过程中最大的美丽值。该数可以是一个整数，也可以是一个不可约分数 $N/D$（其中 $D \\geq 2$）；不可约分数指 $N$ 和 $D$ 的最大公约数为 $1$。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13797", "type": "P", "difficulty": 2, "samples": [["5\nEMAIL 3 5 6 7 8 9 10\nCRASH 2 7 1 8 2 8 1\nMOUSE 4 0 9 3 9 1 7\nSWERC 6 3 1 4 1 5 9\nPAINT 6 0 0 0 0 0 10", "SWERC 73\nEMAIL 60\nMOUSE 60\nPAINT 60"], ["4\nCRAZY 4 0 2 4 6 8 10\nJAZZY 2 9 9 9 9 9 9\nJUICY 3 2 9 10 9 10 1\nFUZZY 5 0 1 1 2 3 5", "CRAZY 60\nJUICY 60\nFUZZY 57"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["模拟", "2023", "排序", "ICPC"], "title": "[SWERC 2023] Programming-trampoline-athlon!", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/a75009f1d00a17654c89251bd019d39f1ee01d81.png)\n\n![](https://espresso.codeforces.com/ed274bb41d6938a7fe78ee1e6b6f4ec73754aad8.png)\n\n:::\n\n\n\nProgramming competitions are fun and exciting. Programming should be an Olympic sport! At least, this is what we believe. However, when we suggested this to some of our friends, they did not seem to share our excitement. So, we decided to suggest a combined sport that will be more interesting to watch. Programming-trampoline-athlon! (we are still working on the name.)\n\n\nThe idea is as follows. This is a team sport, where each team comprises of $3$ members. The team has at its disposal $1$ hour, $1$ computer, and $1$ trampoline. At all times, there must be at most one team member using the computer and at least one team member jumping the trampoline. At the beginning of the competition, the team is given $6$ programming problems, and $6$ trampoline elements (exercises). The team decides how to partition the trampoline elements between its members, such that each team member has to perform $2$ of the given elements on the trampoline. The programming tasks are solved cooperatively by the team members, but no one member can spend more than $25$ minutes on the computer in total. The scoring is comprised of two parts, which are added together:\n\n- The programming score ranges between $0$ and $60$. The team receives $10$ points for every correctly solved problem.\n- The trampoline score ranges between $0$ and $40$. Each of the $6$ trampoline elements receives a score from the judges that ranges between $0$ and $10$. The final trampoline execution score is determined by dropping the highest and lowest of the $6$ scores, and then adding up the remaining $4$ scores.\n\nBefore we pitch this new sport to the International Olympic Committee, we want everything to be ready in order to show them just how serious we are. Thus, each team should receive a medal when no more than two other teams obtained a strictly higher score. However, in order to cope with a recent shortage of medals, the jury was instructed to make sure that there would be no more than $1~000$ teams deserving a medal. We ask you to write a program that determines the medallists, given the performance of the different teams.", "inputFormat": "The first line contains the number $N$ of competing teams. Then follow $N$ lines. Each of these lines describes a team and contains space-separated values $C, P, E_1, E_2, E_3, E_4, E_5, E_6$; $C$ is a five-letter code used to identify the team, $P$ is an integer specifying the number of problems the team solved, and $E_i$ is an integer specifying the execution score of trampoline element number $i$.\n\n**Limits**\n\t\n- $3 \\leq N \\leq 100~000$;\n- $3 \\leq M \\leq 1~000$;\n- $C$ consists of five uppercase English letters;\n- $0 \\leq P \\leq 6$;\n- $0 \\leq E_i \\leq 10$ for all $1 \\leq i \\leq 6$;\n- different teams always have different team codes.", "outputFormat": "The output should contain $M$ lines, where $M$ is the number of medallists. Each line should represent a medallist team, by containing two space-separated values $C$ and $S$, where $C$ is the team code and $S$ is the total score of the team. Medallist teams should be listed by decreasing total score and, in case of ties, by input order.", "hint": "", "locale": "en", "translations": {"en": {"title": "[SWERC 2023] Programming-trampoline-athlon!", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/a75009f1d00a17654c89251bd019d39f1ee01d81.png)\n\n![](https://espresso.codeforces.com/ed274bb41d6938a7fe78ee1e6b6f4ec73754aad8.png)\n\n:::\n\n\n\nProgramming competitions are fun and exciting. Programming should be an Olympic sport! At least, this is what we believe. However, when we suggested this to some of our friends, they did not seem to share our excitement. So, we decided to suggest a combined sport that will be more interesting to watch. Programming-trampoline-athlon! (we are still working on the name.)\n\n\nThe idea is as follows. This is a team sport, where each team comprises of $3$ members. The team has at its disposal $1$ hour, $1$ computer, and $1$ trampoline. At all times, there must be at most one team member using the computer and at least one team member jumping the trampoline. At the beginning of the competition, the team is given $6$ programming problems, and $6$ trampoline elements (exercises). The team decides how to partition the trampoline elements between its members, such that each team member has to perform $2$ of the given elements on the trampoline. The programming tasks are solved cooperatively by the team members, but no one member can spend more than $25$ minutes on the computer in total. The scoring is comprised of two parts, which are added together:\n\n- The programming score ranges between $0$ and $60$. The team receives $10$ points for every correctly solved problem.\n- The trampoline score ranges between $0$ and $40$. Each of the $6$ trampoline elements receives a score from the judges that ranges between $0$ and $10$. The final trampoline execution score is determined by dropping the highest and lowest of the $6$ scores, and then adding up the remaining $4$ scores.\n\nBefore we pitch this new sport to the International Olympic Committee, we want everything to be ready in order to show them just how serious we are. Thus, each team should receive a medal when no more than two other teams obtained a strictly higher score. However, in order to cope with a recent shortage of medals, the jury was instructed to make sure that there would be no more than $1~000$ teams deserving a medal. We ask you to write a program that determines the medallists, given the performance of the different teams.", "inputFormat": "The first line contains the number $N$ of competing teams. Then follow $N$ lines. Each of these lines describes a team and contains space-separated values $C, P, E_1, E_2, E_3, E_4, E_5, E_6$; $C$ is a five-letter code used to identify the team, $P$ is an integer specifying the number of problems the team solved, and $E_i$ is an integer specifying the execution score of trampoline element number $i$.\n\n**Limits**\n\t\n- $3 \\leq N \\leq 100~000$;\n- $3 \\leq M \\leq 1~000$;\n- $C$ consists of five uppercase English letters;\n- $0 \\leq P \\leq 6$;\n- $0 \\leq E_i \\leq 10$ for all $1 \\leq i \\leq 6$;\n- different teams always have different team codes.", "outputFormat": "The output should contain $M$ lines, where $M$ is the number of medallists. Each line should represent a medallist team, by containing two space-separated values $C$ and $S$, where $C$ is the team code and $S$ is the total score of the team. Medallist teams should be listed by decreasing total score and, in case of ties, by input order.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[SWERC 2023] Programming-trampoline-athlon!", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/a75009f1d00a17654c89251bd019d39f1ee01d81.png)\n\n![](https://espresso.codeforces.com/ed274bb41d6938a7fe78ee1e6b6f4ec73754aad8.png)\n\n:::\n\n编程竞赛既有趣又激动人心。我们认为编程应该成为奥运项目！然而，当我们向一些朋友提出这个想法时，他们似乎并不认同我们的热情。因此，我们决定提出一项更有观赏性的综合运动——编程蹦床三项赛！（我们还在想名字。）\n\n比赛规则如下：这是一项团队运动，每支队伍由 $3$ 名成员组成。每队拥有 $1$ 小时、$1$ 台电脑和 $1$ 个蹦床。任何时刻，最多只能有一名队员使用电脑，且至少有一名队员在蹦床上跳跃。比赛开始时，每队会获得 $6$ 道编程题和 $6$ 个蹦床动作（练习）。队伍需要决定如何将蹦床动作分配给队员，使得每名队员都要完成 $2$ 个指定的蹦床动作。编程任务由队员协作完成，但每名队员在电脑上总共花费的时间不得超过 $25$ 分钟。得分由两部分组成，最终得分为两部分之和：\n\n- 编程得分范围为 $0$ 到 $60$。每解出一道题，队伍可获得 $10$ 分。\n- 蹦床得分范围为 $0$ 到 $40$。每个蹦床动作由裁判打分，分数范围为 $0$ 到 $10$。最终蹦床得分为去掉 $6$ 个分数中的最高分和最低分后，将剩余 $4$ 个分数相加。\n\n在我们向国际奥委会推荐这项新运动之前，我们希望一切准备就绪，以向他们展示我们的认真。因此，每支队伍应当获得奖牌，当且仅当没有超过两支其他队伍获得了严格更高的总分。然而，由于最近奖牌短缺，评审团被要求确保获得奖牌的队伍不超过 $1\\,000$ 支。请你编写一个程序，根据各队的表现确定获奖队伍。", "inputFormat": "第一行包含参赛队伍数 $N$。接下来有 $N$ 行，每行描述一支队伍，包含以空格分隔的 $C, P, E_1, E_2, E_3, E_4, E_5, E_6$；$C$ 是用于标识队伍的五位字母代码，$P$ 是队伍解出的题目数，$E_i$ 是第 $i$ 个蹦床动作的得分。\n\n**数据范围**\n\t\n- $3 \\leq N \\leq 100~000$;\n- $3 \\leq M \\leq 1~000$;\n- $C$ 由五个大写英文字母组成。\n- $0 \\leq P \\leq 6$;\n- $0 \\leq E_i \\leq 10$ 对于所有的 $1 \\leq i \\leq 6$;\n- 保证不同的队伍有不同的字母代码。", "outputFormat": "输出应包含 $M$ 行，其中 $M$ 是获奖队伍的数量。每行包含两个以空格分隔的值 $C$ 和 $S$，其中 $C$ 是队伍代码，$S$ 是队伍的总分。获奖队伍应按总分从高到低排序，若总分相同则按输入顺序排列。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13798", "type": "P", "difficulty": 6, "samples": [["4 3\n2 5\n3 4\n4 2\n1 6\n6 4\n2 8\n5 5", "2\n4\n1"], ["3 4\n1 0\n0 2\n0 1\n1 1\n2 2\n2 1\n1 0", "2\n2\n1\n1"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["计算几何", "2023", "凸包", "ICPC", "李超线段树"], "title": "[SWERC 2023] Favourite dish", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/f4e13fe8cb3692d86fceaeba9e38456b9c240bed.png)\n\n:::\n\nFrance is a country of gastronomy. For a dish, both the taste and plating are important. Nevertheless, when different people evaluate a dish, some focus more on taste and some focus more on plating. At the Olympic Village dining hall, there are $N$ dishes, numbered from 1 to $N$; each dish has a score on its taste and a score on its plating. There are also $M$ persons, numbered from 1 to $M$; each person has a weight on taste and a weight on plating. One person's final score of a dish is the weighted average of the dish's scores on taste and plating.\n\n\nThe chefs at the Olympics want to provide everyone with their favourite dish on the evening of the closing ceremony. Your task is to calculate everyone's favourite dish. If multiple dishes tie for the highest score as a person's favourite, choose the one with the smallest number.\n\n", "inputFormat": "Each line contains two space-separated integers. The first line contains the numbers $N$ and $M$. Then follow $N$ lines; the $k^\\text{th}$ such line contains two integers $t_k$ and $p_k$, which are the scores of the dish $k$ on taste and on plating. Then come $M$ more lines; the $l^\\text{th}$ such line contains two integers $T_l$ and $P_l$, which are the weights of person $l$ on taste and on plating.\n\n**Limits**\n\n- $1 \\leq N \\leq 500~000$;\n- $1 \\leq M \\leq 500~000$;\n- $0 \\leq t_k \\leq 1~000~000, 0 \\leq p_k \\leq 1~000~000$, and $(t_k, p_k) \\neq (0, 0)$ for all $k \\leq N$;\n- $0 \\leq T_l \\leq 1~000~000, 0 \\leq P_l \\leq 1~000~000$, and $(T_l, P_l) \\neq (0, 0)$ for all $l \\leq M$;\n- the $N$ pairs $(t_k, p_k)$ are pairwise distinct;\n- the $M$ pairs $(T_l, T_l)$ are pairwise distinct.", "outputFormat": "The output should contain $M$ lines. The $l^\\text{th}$ such line should contain one number: the number of the favourite dish of person $l$.", "hint": "**Sample Explanation 1**\n\nHere is the score table for each person on each dish. Each person's favourite dish is indicated with a $^\\ast$; person 3 has three tied favourite dishes, so we chose the first one.\n\n|   | Dish | < | < | < |\n|:-:|:-:|:-:|:-:|:-:|\n| Person | 1 | 2 | 3 | 4 |\n| 1 | $3.2$ | $3.4^\\ast$ | $3.2$ | $3$ |\n| 2 | $4.4$ | $3.8$ | $2.4$ | $5^\\ast$ |\n| 3 | $3.5^\\ast$ | $3.5$ | $3$ | $3.5$ |\n\n**Sample Explanation 2**\n\n\nHere is the score table for each person on each dish. Each person's favourite dish is indicated with a $^\\ast$.\n\n|   | Dish | < | < |\n|:-:|:-:|:-:|:-:|\n| Person | 1 | 2 | 3 |\n| 1 | $0.5$ | $1^\\ast$ | $0.5$ |\n| 2 | $0.5$ | $1^\\ast$ | $0.5$ |\n| 3 | $2/3^\\ast$ | $2/3$ | $1/3$ |\n| 4 | $1^\\ast$ | $0$ | $0$ |\n", "locale": "en", "translations": {"en": {"title": "[SWERC 2023] Favourite dish", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/f4e13fe8cb3692d86fceaeba9e38456b9c240bed.png)\n\n:::\n\nFrance is a country of gastronomy. For a dish, both the taste and plating are important. Nevertheless, when different people evaluate a dish, some focus more on taste and some focus more on plating. At the Olympic Village dining hall, there are $N$ dishes, numbered from 1 to $N$; each dish has a score on its taste and a score on its plating. There are also $M$ persons, numbered from 1 to $M$; each person has a weight on taste and a weight on plating. One person's final score of a dish is the weighted average of the dish's scores on taste and plating.\n\n\nThe chefs at the Olympics want to provide everyone with their favourite dish on the evening of the closing ceremony. Your task is to calculate everyone's favourite dish. If multiple dishes tie for the highest score as a person's favourite, choose the one with the smallest number.\n\n", "inputFormat": "Each line contains two space-separated integers. The first line contains the numbers $N$ and $M$. Then follow $N$ lines; the $k^\\text{th}$ such line contains two integers $t_k$ and $p_k$, which are the scores of the dish $k$ on taste and on plating. Then come $M$ more lines; the $l^\\text{th}$ such line contains two integers $T_l$ and $P_l$, which are the weights of person $l$ on taste and on plating.\n\n**Limits**\n\n- $1 \\leq N \\leq 500~000$;\n- $1 \\leq M \\leq 500~000$;\n- $0 \\leq t_k \\leq 1~000~000, 0 \\leq p_k \\leq 1~000~000$, and $(t_k, p_k) \\neq (0, 0)$ for all $k \\leq N$;\n- $0 \\leq T_l \\leq 1~000~000, 0 \\leq P_l \\leq 1~000~000$, and $(T_l, P_l) \\neq (0, 0)$ for all $l \\leq M$;\n- the $N$ pairs $(t_k, p_k)$ are pairwise distinct;\n- the $M$ pairs $(T_l, T_l)$ are pairwise distinct.", "outputFormat": "The output should contain $M$ lines. The $l^\\text{th}$ such line should contain one number: the number of the favourite dish of person $l$.", "hint": "**Sample Explanation 1**\n\nHere is the score table for each person on each dish. Each person's favourite dish is indicated with a $^\\ast$; person 3 has three tied favourite dishes, so we chose the first one.\n\n|   | Dish | < | < | < |\n|:-:|:-:|:-:|:-:|:-:|\n| Person | 1 | 2 | 3 | 4 |\n| 1 | $3.2$ | $3.4^\\ast$ | $3.2$ | $3$ |\n| 2 | $4.4$ | $3.8$ | $2.4$ | $5^\\ast$ |\n| 3 | $3.5^\\ast$ | $3.5$ | $3$ | $3.5$ |\n\n**Sample Explanation 2**\n\n\nHere is the score table for each person on each dish. Each person's favourite dish is indicated with a $^\\ast$.\n\n|   | Dish | < | < |\n|:-:|:-:|:-:|:-:|\n| Person | 1 | 2 | 3 |\n| 1 | $0.5$ | $1^\\ast$ | $0.5$ |\n| 2 | $0.5$ | $1^\\ast$ | $0.5$ |\n| 3 | $2/3^\\ast$ | $2/3$ | $1/3$ |\n| 4 | $1^\\ast$ | $0$ | $0$ |\n", "locale": "en"}, "zh-CN": {"title": "[SWERC 2023] Favourite dish", "background": null, "description": ":::align{center}\n\n![](https://espresso.codeforces.com/f4e13fe8cb3692d86fceaeba9e38456b9c240bed.png)\n\n:::\n\n法国是一个美食之国。对于一道菜来说，味道和摆盘都很重要。然而，不同的人在评价一道菜时，有的人更注重味道，有的人更注重摆盘。在奥运村的餐厅里，有 $N$ 道菜，编号从 $1$ 到 $N$；每道菜都有一个味道分数和一个摆盘分数。同时有 $M$ 个人，编号从 $1$ 到 $M$；每个人都有一个味道权重和一个摆盘权重。某个人对一道菜的最终评分是该菜的味道分数和摆盘分数的加权平均值。\n\n奥运会的厨师们希望在闭幕式晚宴上为每个人提供他们最喜欢的菜。你的任务是计算出每个人最喜欢的菜。如果有多道菜在某个人心中的评分并列最高，则选择编号最小的那一道。", "inputFormat": "每行包含两个用空格分隔的整数。第一行包含两个整数 $N$ 和 $M$。接下来有 $N$ 行，第 $k$ 行包含两个整数 $t_k$ 和 $p_k$，分别表示第 $k$ 道菜的味道分数和摆盘分数。之后还有 $M$ 行，第 $l$ 行包含两个整数 $T_l$ 和 $P_l$，分别表示第 $l$ 个人的味道权重和摆盘权重。\n\n**数据范围**\n\n- $1 \\leq N \\leq 500\\,000$；\n- $1 \\leq M \\leq 500\\,000$；\n- $0 \\leq t_k \\leq 1\\,000\\,000, 0 \\leq p_k \\leq 1\\,000\\,000$，且对所有 $k \\leq N$，$(t_k, p_k) \\neq (0, 0)$；\n- $0 \\leq T_l \\leq 1\\,000\\,000, 0 \\leq P_l \\leq 1\\,000\\,000$，且对所有 $l \\leq M$，$(T_l, P_l) \\neq (0, 0)$；\n- $N$ 个 $(t_k, p_k)$ 两两不同；\n- $M$ 个 $(T_l, P_l)$ 两两不同。", "outputFormat": "输出应包含 $M$ 行。第 $l$ 行输出一个数字，表示第 $l$ 个人最喜欢的菜的编号。", "hint": "**样例解释 1**\n\n下表为每个人对每道菜的评分。每个人最喜欢的菜用 $^\\ast$ 标出；第 3 个人有三道菜评分并列最高，因此选择编号最小的那一道。\n\n|   | 菜品 | < | < | < |\n|:-:|:-:|:-:|:-:|:-:|\n| 个人 | 1 | 2 | 3 | 4 |\n| 1 | $3.2$ | $3.4^\\ast$ | $3.2$ | $3$ |\n| 2 | $4.4$ | $3.8$ | $2.4$ | $5^\\ast$ |\n| 3 | $3.5^\\ast$ | $3.5$ | $3$ | $3.5$ |\n\n**样例解释 2**\n\n下表为每个人对每道菜的评分。每个人最喜欢的菜用 $^\\ast$ 标出。\n\n|   | 菜品 | < | < |\n|:-:|:-:|:-:|:-:|\n| 个人 | 1 | 2 | 3 |\n| 1 | $0.5$ | $1^\\ast$ | $0.5$ |\n| 2 | $0.5$ | $1^\\ast$ | $0.5$ |\n| 3 | $2/3^\\ast$ | $2/3$ | $1/3$ |\n| 4 | $1^\\ast$ | $0$ | $0$ |\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13799", "type": "P", "difficulty": 5, "samples": [["4\n0 0\n1 0\n1 1\n0 1", "0"], ["4\n0 0\n5 0\n6 6\n0 5", "1"], ["5\n0 0\n2 0\n2 20\n1 1\n0 20", "5"]], "limits": {"time": [750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["计算几何", "2023", "ICPC", "双指针 two-pointer"], "title": "[SWERC 2023] Break a leg!", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/a2628cf785edc53f8245d1203533bdfe5a5f491a.png)\n\n:::\n\nFor the first time, breakdance will be featured in the Olympics. And you get to participate! Well, you get to participate to the jury... More precisely, you get to build the table in front of which the jury will be seated: still, that is an impressive feat, congratulations!\n\n\nActually, the top of the table is already built: it is plane, has constant width and constant density, and its shape consists in the interior of an $N$-sided non-crossing polygon $P_1 P_2 \\dots P_N$ in which no three vertices are collinear (i.e., no line goes through three vertices or more). You have three table legs of same length and negligible width. Your task is to place them at distinct corners of the table so that the table remains stable when standing on these legs. In other words, you must choose three vertices $P_i$, $P_j$ and $P_k$ of the polygon such that the centre of gravity of the polygon lies in the interior of the triangle $P_i P_j P_k$ (and not on its boundary).\n\n\nIn how many different ways can you do this? If two ways of placing legs differ only by a permutation\nof the legs, they are not counted as different ways.", "inputFormat": "The first line contains the number $N$. Then follow $N$ lines: the $i^\\text{th}$ of these lines contains two space-separated integers $x_i$ and $y_i$, which are the $x$-coordinate and the $y$-coordinate of the vertex $P_i$.\n\n**Limits**\n\t\n- $3 \\leq N \\leq 100~000$;\n- $-1~000~000 \\leq x_i \\leq 1~000~000$ and $-1~000~000 \\leq y_i \\leq 1~000~000$ for all $i \\leq N$;\n- whenever $1 \\leq i < j < k \\leq N$, the vertices $P_i$, $P_j$ and $P_k$ are not collinear;\n- the polygonal shape $P_1 P_2 \\dots P_N$ is non-crossing.\n\n", "outputFormat": "The output should contain a single line, consisting of a single integer: the number of ways of placing legs such that the table remains stable.", "hint": "", "locale": "en", "translations": {"en": {"title": "[SWERC 2023] Break a leg!", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/a2628cf785edc53f8245d1203533bdfe5a5f491a.png)\n\n:::\n\nFor the first time, breakdance will be featured in the Olympics. And you get to participate! Well, you get to participate to the jury... More precisely, you get to build the table in front of which the jury will be seated: still, that is an impressive feat, congratulations!\n\n\nActually, the top of the table is already built: it is plane, has constant width and constant density, and its shape consists in the interior of an $N$-sided non-crossing polygon $P_1 P_2 \\dots P_N$ in which no three vertices are collinear (i.e., no line goes through three vertices or more). You have three table legs of same length and negligible width. Your task is to place them at distinct corners of the table so that the table remains stable when standing on these legs. In other words, you must choose three vertices $P_i$, $P_j$ and $P_k$ of the polygon such that the centre of gravity of the polygon lies in the interior of the triangle $P_i P_j P_k$ (and not on its boundary).\n\n\nIn how many different ways can you do this? If two ways of placing legs differ only by a permutation\nof the legs, they are not counted as different ways.", "inputFormat": "The first line contains the number $N$. Then follow $N$ lines: the $i^\\text{th}$ of these lines contains two space-separated integers $x_i$ and $y_i$, which are the $x$-coordinate and the $y$-coordinate of the vertex $P_i$.\n\n**Limits**\n\t\n- $3 \\leq N \\leq 100~000$;\n- $-1~000~000 \\leq x_i \\leq 1~000~000$ and $-1~000~000 \\leq y_i \\leq 1~000~000$ for all $i \\leq N$;\n- whenever $1 \\leq i < j < k \\leq N$, the vertices $P_i$, $P_j$ and $P_k$ are not collinear;\n- the polygonal shape $P_1 P_2 \\dots P_N$ is non-crossing.\n\n", "outputFormat": "The output should contain a single line, consisting of a single integer: the number of ways of placing legs such that the table remains stable.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[SWERC 2023] Break a leg!", "background": null, "description": ":::align{center}\n\n![](https://espresso.codeforces.com/a2628cf785edc53f8245d1203533bdfe5a5f491a.png)\n\n:::\n\n霹雳舞首次成为奥运会项目。而你有机会参与其中！不过，你参与的是评审团……更准确地说，你需要搭建评审团前面的桌子：即便如此，这也是一项了不起的成就，祝贺你！\n\n实际上，桌面的顶板已经搭建完成：它是平面的，宽度和密度均匀，其形状为一个 $N$ 边的非自交多边形 $P_1 P_2 \\dots P_N$ 的内部，且没有三点共线（即不存在一条直线经过三个或以上的顶点）。你有三根长度相同且宽度可以忽略不计的桌腿。你的任务是将它们分别放在桌子的三个不同顶点上，使得桌子在这三根桌腿上能够保持稳定。换句话说，你需要选择多边形的三个顶点 $P_i$、$P_j$ 和 $P_k$，使得多边形的重心位于三角形 $P_i P_j P_k$ 的内部（不在其边界上）。\n\n你有多少种不同的放置桌腿的方法？如果两种放置方式仅仅是桌腿的排列不同，则不计为不同的方式。", "inputFormat": "第一行包含一个整数 $N$。接下来有 $N$ 行，第 $i$ 行包含两个用空格分隔的整数 $x_i$ 和 $y_i$，表示顶点 $P_i$ 的 $x$ 坐标和 $y$ 坐标。\n\n**数据范围**\n\n- $3 \\leq N \\leq 100\\,000$；\n- $-1\\,000\\,000 \\leq x_i \\leq 1\\,000\\,000$ 且 $-1\\,000\\,000 \\leq y_i \\leq 1\\,000\\,000$，对所有 $i \\leq N$；\n- 对于任意 $1 \\leq i < j < k \\leq N$，顶点 $P_i$、$P_j$ 和 $P_k$ 不共线；\n- 多边形 $P_1 P_2 \\dots P_N$ 是非自交的。", "outputFormat": "输出一行一个整数，表示能够使桌子保持稳定的桌腿放置方法数。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13800", "type": "P", "difficulty": 3, "samples": [["8 1\n4 4 4 4 4 4 4 4\n6", "ALICE"], ["2 2\n6 4\n4 6", "TIED"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384]}, "tags": ["2023", "期望", "ICPC"], "title": "[SWERC 2023] Throwing dice", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/a11e720cc14242ff598268192fbaaa26b9332c02.png)\n\n:::\n\nAlice and Bob are discussing penalty shoot-outs and their randomness: \"We might as well be throwing dice to determine the winner!\", Alice said. And so they started simulating penalty shoot-outs by each throwing dice, summing the points indicated on their dice, and comparing these sums. The player with the largest sum wins; in case both sums are equal, there is a tie.\n\n\nBut even in such situations, some player might have an edge over their opponent, depending on which dice they throw. Thus, just by looking at the dice they are about to throw, Alice and Bob want to determine who has the better edge.\n\n\nAlice has $M$ fair dice, with $A_1, A_2, \\dots, A_M$ sides. For all integers $k$ and $l$ such that $1 \\leq k \\leq M$ and $1 \\leq l \\leq A_k$, the $k^\\text{th}$ die of Alice has a probability $1/A_k$ of showing its face numbered $l$. Then, Alice's score is the sum of the numbers displayed by her $M$ dice. Similarly, Bob has $N$ fair dice, with $B_1, B_2, \\dots, B_N$ sides.\n\n\nGiven these dice, Alice has a probability $\\mathbb{P}_A$ of having a strictly larger score than Bob, and Bob has a probability $\\mathbb{P}_B$ of having a strictly larger score than Alice. Which probability is the largest one?\n", "inputFormat": "The input consists of three lines, each one containing space-separated integers. The first line contains the numbers $M$ and $N$. The second line contains the numbers $A_1, A_2, \\dots, A_M$. The third line contains the numbers $B_1, B_2, \\dots, B_N$.\n\n**Limits**\n\t\n- $1 \\leq M \\leq 100~000$;\n- $1 \\leq N \\leq 100~000$;\n- $4 \\leq A_k \\leq 1~000~000~000$ for all $k \\leq M$;\n- $4 \\leq B_k \\leq 1~000~000~000$ for all $k \\leq N$;\n", "outputFormat": "The output should contain a single line, consisting of a single uppercase word: $\\texttt{ALICE}$ if $\\mathbb{P}_A > \\mathbb{P}_B$, $\\texttt{TIED}$ if $\\mathbb{P}_A = \\mathbb{P}_B$, and $\\texttt{BOB}$ if $\\mathbb{P}_A < \\mathbb{P}_B$.", "hint": "**Sample Explanation 1**\n\nSince Alice has 8 dice, her score is always 8 or more; Bob's score is always 6 or less. Hence, Alice has a probability $\\mathbb{P}_A = 100\\%$ of beating Bob, and he has a probability $\\mathbb{P}_B = 0\\%$ of beating her. Consequently, $\\mathbb{P}_A > \\mathbb{P}_B$.\n\n**Sample Explanation 2**\n\nAlice has a probability $\\mathbb{P}_A = 125/288$ of beating Bob; he also has a probability $\\mathbb{P}_B = 125/288$ of beating her.", "locale": "en", "translations": {"en": {"title": "[SWERC 2023] Throwing dice", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/a11e720cc14242ff598268192fbaaa26b9332c02.png)\n\n:::\n\nAlice and Bob are discussing penalty shoot-outs and their randomness: \"We might as well be throwing dice to determine the winner!\", Alice said. And so they started simulating penalty shoot-outs by each throwing dice, summing the points indicated on their dice, and comparing these sums. The player with the largest sum wins; in case both sums are equal, there is a tie.\n\n\nBut even in such situations, some player might have an edge over their opponent, depending on which dice they throw. Thus, just by looking at the dice they are about to throw, Alice and Bob want to determine who has the better edge.\n\n\nAlice has $M$ fair dice, with $A_1, A_2, \\dots, A_M$ sides. For all integers $k$ and $l$ such that $1 \\leq k \\leq M$ and $1 \\leq l \\leq A_k$, the $k^\\text{th}$ die of Alice has a probability $1/A_k$ of showing its face numbered $l$. Then, Alice's score is the sum of the numbers displayed by her $M$ dice. Similarly, Bob has $N$ fair dice, with $B_1, B_2, \\dots, B_N$ sides.\n\n\nGiven these dice, Alice has a probability $\\mathbb{P}_A$ of having a strictly larger score than Bob, and Bob has a probability $\\mathbb{P}_B$ of having a strictly larger score than Alice. Which probability is the largest one?\n", "inputFormat": "The input consists of three lines, each one containing space-separated integers. The first line contains the numbers $M$ and $N$. The second line contains the numbers $A_1, A_2, \\dots, A_M$. The third line contains the numbers $B_1, B_2, \\dots, B_N$.\n\n**Limits**\n\t\n- $1 \\leq M \\leq 100~000$;\n- $1 \\leq N \\leq 100~000$;\n- $4 \\leq A_k \\leq 1~000~000~000$ for all $k \\leq M$;\n- $4 \\leq B_k \\leq 1~000~000~000$ for all $k \\leq N$;\n", "outputFormat": "The output should contain a single line, consisting of a single uppercase word: $\\texttt{ALICE}$ if $\\mathbb{P}_A > \\mathbb{P}_B$, $\\texttt{TIED}$ if $\\mathbb{P}_A = \\mathbb{P}_B$, and $\\texttt{BOB}$ if $\\mathbb{P}_A < \\mathbb{P}_B$.", "hint": "**Sample Explanation 1**\n\nSince Alice has 8 dice, her score is always 8 or more; Bob's score is always 6 or less. Hence, Alice has a probability $\\mathbb{P}_A = 100\\%$ of beating Bob, and he has a probability $\\mathbb{P}_B = 0\\%$ of beating her. Consequently, $\\mathbb{P}_A > \\mathbb{P}_B$.\n\n**Sample Explanation 2**\n\nAlice has a probability $\\mathbb{P}_A = 125/288$ of beating Bob; he also has a probability $\\mathbb{P}_B = 125/288$ of beating her.", "locale": "en"}, "zh-CN": {"title": "[SWERC 2023] Throwing dice", "background": null, "description": ":::align{center}\n\n![](https://espresso.codeforces.com/a11e720cc14242ff598268192fbaaa26b9332c02.png)\n\n:::\n\nAlice 和 Bob 正在讨论点球大战的随机性：“我们还不如掷骰子来决定胜负呢！”，Alice 说道。于是他们开始通过各自掷骰子来模拟点球大战，将各自骰子上显示的点数相加，然后比较总和。点数总和较大的一方获胜；如果两人的总和相等，则为平局。\n\n但即使在这种情况下，某一方也可能因为所用骰子的不同而占有优势。因此，仅仅通过观察即将掷出的骰子，Alice 和 Bob 想要判断谁更有优势。\n\nAlice 有 $M$ 个公平骰子，每个骰子的面数分别为 $A_1, A_2, \\dots, A_M$。对于所有满足 $1 \\leq k \\leq M$ 且 $1 \\leq l \\leq A_k$ 的整数，Alice 的第 $k$ 个骰子掷出编号为 $l$ 的点数的概率为 $1/A_k$。于是，Alice 的得分为她的 $M$ 个骰子显示的点数之和。同理，Bob 有 $N$ 个公平骰子，每个骰子的面数分别为 $B_1, B_2, \\dots, B_N$。\n\n给定这些骰子，Alice 以严格大于 Bob 得分的概率为 $\\mathbb{P}_A$，Bob 以严格大于 Alice 得分的概率为 $\\mathbb{P}_B$。请判断哪一个概率更大？", "inputFormat": "输入包含三行，每行由若干用空格分隔的整数构成。第一行包含整数 $M$ 和 $N$。第二行包含 $A_1, A_2, \\dots, A_M$。第三行包含 $B_1, B_2, \\dots, B_N$。\n\n**数据范围**\n\n- $1 \\leq M \\leq 100\\,000$；\n- $1 \\leq N \\leq 100\\,000$；\n- 对于所有 $k \\leq M$，$4 \\leq A_k \\leq 1\\,000\\,000\\,000$；\n- 对于所有 $k \\leq N$，$4 \\leq B_k \\leq 1\\,000\\,000\\,000$；", "outputFormat": "输出仅一行，仅包含一个大写单词：如果 $\\mathbb{P}_A > \\mathbb{P}_B$，输出 $\\texttt{ALICE}$；如果 $\\mathbb{P}_A = \\mathbb{P}_B$，输出 $\\texttt{TIED}$；如果 $\\mathbb{P}_A < \\mathbb{P}_B$，输出 $\\texttt{BOB}$。", "hint": "**样例解释 1**\n\n由于 Alice 有 8 个骰子，她的得分总是至少为 8；而 Bob 的得分总是至多为 6。因此，Alice 以概率 $\\mathbb{P}_A = 100\\%$ 战胜 Bob，而 Bob 战胜她的概率 $\\mathbb{P}_B = 0\\%$。因此，$\\mathbb{P}_A > \\mathbb{P}_B$。\n\n**样例解释 2**\n\nAlice 以概率 $\\mathbb{P}_A = 125/288$ 战胜 Bob；Bob 也以概率 $\\mathbb{P}_B = 125/288$ 战胜 Alice。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13801", "type": "P", "difficulty": 4, "samples": [["5 5\n0 1\n0 2\n2 3\n2 4", "4"]], "limits": {"time": [250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250], "memory": [16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384]}, "tags": ["贪心", "2023", "构造", "ICPC"], "title": "[SWERC 2023] Olympic goodies", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/5b58e27029703e37247b24c6c8ebbc352e62449b.png)\n\n:::\n\n\nFreshly arrived on the market, retailer YAOGS (Yet Another Olympic Goodies Seller) sells very expensive Olympics-themed items. To make themselves better known to the public, they half-heartedly decide to give away some of these items via a contest: the first person to answer correctly the question \"How many circles are there in the Olympic Games logo?\" can thus gain up to $P$ very expensive but equally valued items.\n\n\nTo spice things up (and spend less), YAOGS however opts for an additional challenge, as follows. The $P$ available items are positioned along some, but possibly not all of the alleys of YAOGS's headquarters; each alley can thus contain 0, 1, or more items. For reasons unknown, these alleys form a connected, undirected, acyclic graph (i.e., a tree) with $N$ nodes, numbered from 0 to $N-1$.\n\n\nThe winner knows $N$ but has no idea about either the tree structure or the items' placement. Once goodies are placed, her task is to choose a start node $m$ and an end node $n$. She can then collect all the items on the (unique) path from $m$ to $n$ in the tree.\n\n\nYAOGS decides to cleverly place the goodies so that they minimise the maximum number of items that can possibly be collected. Assuming they properly carry out this task, what is the maximum number of items the winner can collect?", "inputFormat": "Each line contains two space-separated integers. The fist line contains the numbers $N$ and $P$. Then follow $N-1$ lines; the $k\\text{th}$ such line contains two integers $a_k$ and $b_k$, meaning that there is an edge between the nodes $a_k$ and $b_k$ of the tree.\n\n**Limits**\n\t\n- $1 \\leq M \\leq 100000$;\n- $1 \\leq P \\leq 100000$;\n- $0 \\leq a_k \\leq N-1$ and $0 \\leq b_k \\leq N-1$ for all $k \\leq N-1$;\n- the set of edges in the input file describes a valid tree structure.", "outputFormat": "The output should contain a single line, consisting of a single integer: the maximum number of items\nthat can be collected by the winner.", "hint": "**Sample Explanation**\n\nFor the tree in the sample input, depicted below, an optimal item placement by YAOGS guarantees\nthat the winner cannot collect more than four items.\n\n\nThe figures below show two possible item placements to achieve this optimality. In the first one, the\nfour items may be collected by choosing, for instance, nodes $1$ and $3$. In the second one, the four items\nmay be collected by choosing, for instance, nodes $0$ and $4$.\n\n![](https://espresso.codeforces.com/8ebb2ecdb22b673ba1f401eeeee819480e846618.png)\n\n", "locale": "en", "translations": {"en": {"title": "[SWERC 2023] Olympic goodies", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/5b58e27029703e37247b24c6c8ebbc352e62449b.png)\n\n:::\n\n\nFreshly arrived on the market, retailer YAOGS (Yet Another Olympic Goodies Seller) sells very expensive Olympics-themed items. To make themselves better known to the public, they half-heartedly decide to give away some of these items via a contest: the first person to answer correctly the question \"How many circles are there in the Olympic Games logo?\" can thus gain up to $P$ very expensive but equally valued items.\n\n\nTo spice things up (and spend less), YAOGS however opts for an additional challenge, as follows. The $P$ available items are positioned along some, but possibly not all of the alleys of YAOGS's headquarters; each alley can thus contain 0, 1, or more items. For reasons unknown, these alleys form a connected, undirected, acyclic graph (i.e., a tree) with $N$ nodes, numbered from 0 to $N-1$.\n\n\nThe winner knows $N$ but has no idea about either the tree structure or the items' placement. Once goodies are placed, her task is to choose a start node $m$ and an end node $n$. She can then collect all the items on the (unique) path from $m$ to $n$ in the tree.\n\n\nYAOGS decides to cleverly place the goodies so that they minimise the maximum number of items that can possibly be collected. Assuming they properly carry out this task, what is the maximum number of items the winner can collect?", "inputFormat": "Each line contains two space-separated integers. The fist line contains the numbers $N$ and $P$. Then follow $N-1$ lines; the $k\\text{th}$ such line contains two integers $a_k$ and $b_k$, meaning that there is an edge between the nodes $a_k$ and $b_k$ of the tree.\n\n**Limits**\n\t\n- $1 \\leq M \\leq 100000$;\n- $1 \\leq P \\leq 100000$;\n- $0 \\leq a_k \\leq N-1$ and $0 \\leq b_k \\leq N-1$ for all $k \\leq N-1$;\n- the set of edges in the input file describes a valid tree structure.", "outputFormat": "The output should contain a single line, consisting of a single integer: the maximum number of items\nthat can be collected by the winner.", "hint": "**Sample Explanation**\n\nFor the tree in the sample input, depicted below, an optimal item placement by YAOGS guarantees\nthat the winner cannot collect more than four items.\n\n\nThe figures below show two possible item placements to achieve this optimality. In the first one, the\nfour items may be collected by choosing, for instance, nodes $1$ and $3$. In the second one, the four items\nmay be collected by choosing, for instance, nodes $0$ and $4$.\n\n![](https://espresso.codeforces.com/8ebb2ecdb22b673ba1f401eeeee819480e846618.png)\n\n", "locale": "en"}, "zh-CN": {"title": "[SWERC 2023] Olympic goodies", "background": null, "description": ":::align{center}\n\n![](https://espresso.codeforces.com/5b58e27029703e37247b24c6c8ebbc352e62449b.png)\n\n:::\n\n新晋市场的零售商 YAOGS（Yet Another Olympic Goodies Seller）正在销售非常昂贵的奥运主题商品。为了提升知名度，他们决定半心半意地通过一场竞赛赠送部分商品：第一个正确回答“奥运会标志中有多少个圆环？”的人，可以获得最多 $P$ 件价值相等且非常昂贵的商品。\n\n为了增加趣味性（以及减少开支），YAOGS 还设置了额外的挑战。$P$ 件商品被放置在 YAOGS 总部的一些（但不一定全部）走廊上；每条走廊可以放置 0 件、1 件或多件商品。出于未知原因，这些走廊构成了一棵连通、无向、无环的图（即一棵树），共有 $N$ 个节点，编号从 $0$ 到 $N-1$。\n\n获胜者知道 $N$，但对树的结构和商品的具体分布一无所知。商品放置完毕后，她需要选择一个起点节点 $m$ 和一个终点节点 $n$。然后，她可以收集从 $m$ 到 $n$ 的树上（唯一）路径上的所有商品。\n\nYAOGS 会巧妙地放置商品，使得获胜者无论如何都无法收集到太多商品。假设 YAOGS 做到了最优放置，请问获胜者最多能收集到多少件商品？", "inputFormat": "每行包含两个用空格分隔的整数。第一行包含两个整数 $N$ 和 $P$。接下来的 $N-1$ 行，每行包含两个整数 $a_k$ 和 $b_k$，表示在树中节点 $a_k$ 和 $b_k$ 之间有一条边。\n\n**数据范围**\n\n- $1 \\leq N \\leq 100000$；\n- $1 \\leq P \\leq 100000$；\n- 对于所有 $k \\leq N-1$，$0 \\leq a_k \\leq N-1$ 且 $0 \\leq b_k \\leq N-1$；\n- 输入中的边集描述的是一棵合法的树结构。", "outputFormat": "输出一行，包含一个整数：获胜者最多能收集到的商品数。", "hint": "**样例解释**\n\n对于样例输入中的树结构，如下图所示，YAOGS 最优放置商品后，保证获胜者最多只能收集到 4 件商品。\n\n下图展示了两种实现最优放置的方案。在第一种方案中，选择节点 $1$ 和 $3$ 可以收集到 4 件商品。在第二种方案中，选择节点 $0$ 和 $4$ 也可以收集到 4 件商品。\n\n![](https://espresso.codeforces.com/8ebb2ecdb22b673ba1f401eeeee819480e846618.png)\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13802", "type": "P", "difficulty": 5, "samples": [["4\n1 1\n2 1", "1 2\n3 4"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["二分", "2023", "ICPC"], "title": "[SWERC 2023] Team selection", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/f3377480e15684bf0ebb3d7761cfa23137b681ff.png)\n\n:::\n\n\nTwo team leaders get to assemble their teams by choosing team members among a set of players that are numbered from 1 to $N$. The leaders take turns, each picking the $k^\\text{th}$ player among the remaining ones, according to their ideas of which one of the remaining players would be the best addition to their teams.\n\nGiven the choices of the two leaders (the first team leader starts first), please compute the list of players in each team.", "inputFormat": "The input consists of three lines. The first line contains the single integer $N$. The second line contains $N/2$ space-separated integers $a_1, a_2, \\dots, a_{N/2}$ representing the choices of the first team leader: during the $(2k-1)^\\text{th}$ turn, the first leader chose the $a_k^\\text{th}$ remaining player. The third line contains $N/2$ space-separated integers $b_1, b_2, \\dots, b_{N/2}$ representing the choices of the second team leader: during the $2k^\\text{th}$ turn, the second leader chose the $b_k^\\text{th}$ remaining player.\n\n**Limits**\n\t\n- $2 \\leq M \\leq 4~000~000$;\n- $N$ is multiple of 2;\n- the choices of the team leaders are valid: at each step, they are between 1 and the number of remaining players (inclusive).", "outputFormat": "The output should contain two lines, each containing $N/2$ space-separated integers. The first line should contain the list $x_1, x_2, \\dots, x_{N/2}$ of the players chosen to become members of the first team, in the order they were chosen: the player $x_k$ was chosen during the $(2k-1)^\\text{th}$ turn. The second line should contain the list $y_1, y_2, \\dots, y_{N/2}$ of the players chosen to become members of the second team, in the order they were chosen: the player $y_k$ was chosen during the $2k^\\text{th}$ turn.", "hint": "", "locale": "en", "translations": {"en": {"title": "[SWERC 2023] Team selection", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/f3377480e15684bf0ebb3d7761cfa23137b681ff.png)\n\n:::\n\n\nTwo team leaders get to assemble their teams by choosing team members among a set of players that are numbered from 1 to $N$. The leaders take turns, each picking the $k^\\text{th}$ player among the remaining ones, according to their ideas of which one of the remaining players would be the best addition to their teams.\n\nGiven the choices of the two leaders (the first team leader starts first), please compute the list of players in each team.", "inputFormat": "The input consists of three lines. The first line contains the single integer $N$. The second line contains $N/2$ space-separated integers $a_1, a_2, \\dots, a_{N/2}$ representing the choices of the first team leader: during the $(2k-1)^\\text{th}$ turn, the first leader chose the $a_k^\\text{th}$ remaining player. The third line contains $N/2$ space-separated integers $b_1, b_2, \\dots, b_{N/2}$ representing the choices of the second team leader: during the $2k^\\text{th}$ turn, the second leader chose the $b_k^\\text{th}$ remaining player.\n\n**Limits**\n\t\n- $2 \\leq M \\leq 4~000~000$;\n- $N$ is multiple of 2;\n- the choices of the team leaders are valid: at each step, they are between 1 and the number of remaining players (inclusive).", "outputFormat": "The output should contain two lines, each containing $N/2$ space-separated integers. The first line should contain the list $x_1, x_2, \\dots, x_{N/2}$ of the players chosen to become members of the first team, in the order they were chosen: the player $x_k$ was chosen during the $(2k-1)^\\text{th}$ turn. The second line should contain the list $y_1, y_2, \\dots, y_{N/2}$ of the players chosen to become members of the second team, in the order they were chosen: the player $y_k$ was chosen during the $2k^\\text{th}$ turn.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[SWERC 2023] Team selection", "background": null, "description": ":::align{center}\n\n![](https://espresso.codeforces.com/f3377480e15684bf0ebb3d7761cfa23137b681ff.png)\n\n:::\n\n两位队长需要从编号为 $1$ 到 $N$ 的一组球员中轮流挑选队员组建各自的队伍。两位队长轮流选择，每次从剩余球员中挑选第 $k$ 个球员，具体选择顺序由他们各自认为最适合加入自己队伍的球员决定。\n\n给定两位队长的选择顺序（第一位队长先选），请计算每支队伍中球员的编号列表。", "inputFormat": "输入包含三行。\n\n第一行包含一个整数 $N$。\n\n第二行包含 $N/2$ 个用空格分隔的整数 $a_1, a_2, \\dots, a_{N/2}$，表示第一位队长的选择：在第 $(2k-1)$ 轮时，第一位队长选择了剩余球员中的第 $a_k$ 个。\n\n第三行包含 $N/2$ 个用空格分隔的整数 $b_1, b_2, \\dots, b_{N/2}$，表示第二位队长的选择：在第 $2k$ 轮时，第二位队长选择了剩余球员中的第 $b_k$ 个。\n\n**数据范围**\n\n- $2 \\leq N \\leq 4\\,000\\,000$；\n- $N$ 是 $2$ 的倍数；\n- 队长的每次选择都是有效的：每一步选择的编号在 $1$ 到当前剩余球员数之间（包含两端）。", "outputFormat": "输出两行，每行包含 $N/2$ 个用空格分隔的整数。\n\n第一行输出 $x_1, x_2, \\dots, x_{N/2}$，表示第一支队伍中球员的编号，按照被选中的顺序排列：第 $x_k$ 个球员是在第 $(2k-1)$ 轮被选中的。\n\n第二行输出 $y_1, y_2, \\dots, y_{N/2}$，表示第二支队伍中球员的编号，按照被选中的顺序排列：第 $y_k$ 个球员是在第 $2k$ 轮被选中的。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13803", "type": "P", "difficulty": 5, "samples": [["16 17\n1 2 1 1 2 1 2 1 1 1 1 1 2 2 1 1\n3 3 1 3 2 3 3 1 1 2 2 3 3 3 1 3", "1 2 2 2 12 6 4 13 13 16 16 16 9 10 10 7 7\n1 2 2 2 12 6 4 13 13 5 5 14 14 14 11 7 7\n1 3 15 8 12 6 4 13 13 5 5 14 14 14 11 7 7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384]}, "tags": ["2023", "Special Judge", "ICPC"], "title": "[SWERC 2023] Broken trophy ", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/5a9ceba0bef33460fb6104cd612fce7a771f3f73.png)\n\n:::\n\nComing back home after triumphally winning your long-coveted trophy, you discover that it was shattered to pieces in your trunk. It just remains to repair it.\n\n\nYour trophy had the shape of a rectangle of size $3 \\times N$, for some integer $N \\geq 1$, thereby consisting of 3 lines and $N$ columns, containing a total of $3N$ unit squares. It was broken into $K$ pieces, the $k^\\text{th}$ piece being a rectangle of size $A_k \\times B_k$ for some integers $A_k$ and $B_k$ such that $1 \\leq A_k \\leq B_k \\leq 3$. Such pieces may have been rotated, or even flipped, in the havoc that is your trunk.\n\n\nAs the first step towards repairing your trophy, you should reassemble them in the form of a rectangle of size $3 \\times N$. More precisely, you have drawn, on a sheet of paper, a $3 \\times N$ rectangle on which you will place your $K$ pieces, and you need to know, for all integers $i \\leq 3$ and $j \\leq N$, which piece will cover the unit square on the $i^\\text{th}$ line and $j^\\text{th}$ column of your rectangle.\n", "inputFormat": "The input consists of three lines, each one containing space-separated integers. The first line contains the numbers $K$ and $N$. The second line contains the numbers $A_1, A_2, \\dots, A_K$. The third line contains the numbers $B_1, B_2, \\dots, B_K$.\n\n**Limits**\n\t\n- $1 \\leq K \\leq 300~000$;\n- $1 \\leq N \\leq 100~000$;\n- $1 \\leq A_k \\leq B_k \\leq 3$ for all $k \\leq K$;\n- the pieces described in the input can be reassembled in the form of a rectangle of size $3 \\times N$.", "outputFormat": "The output should contain three lines, each one consisting of $N$ space-separated integers. If you plan to cover the unit square on the $i^\\text{th}$ line and $j^\\text{th}$ column with the $k^\\text{th}$ piece, the $j^\\text{th}$ number on the $i^\\text{th}$ output line should be the integer $k$.\n\n\nIn case there are several ways to reassemble your pieces in the form of a rectangle of size $3 \\times N$, every output representing one of these ways is considered correct.", "hint": "**Sample Explanation 1**\n\nThis output represents the following reassembling:\n\n:::align{center}\n\n![](https://espresso.codeforces.com/ebe5fa074a7004f06adef36774082b3ef1655782.png)\n\n:::\n\nAnother valid reassembling could be: \n\n:::align{center}\n\n![](https://espresso.codeforces.com/109dea523bad83462aeee9eb8b60ee35eff479d2.png)\n\n:::", "locale": "en", "translations": {"en": {"title": "[SWERC 2023] Broken trophy ", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/5a9ceba0bef33460fb6104cd612fce7a771f3f73.png)\n\n:::\n\nComing back home after triumphally winning your long-coveted trophy, you discover that it was shattered to pieces in your trunk. It just remains to repair it.\n\n\nYour trophy had the shape of a rectangle of size $3 \\times N$, for some integer $N \\geq 1$, thereby consisting of 3 lines and $N$ columns, containing a total of $3N$ unit squares. It was broken into $K$ pieces, the $k^\\text{th}$ piece being a rectangle of size $A_k \\times B_k$ for some integers $A_k$ and $B_k$ such that $1 \\leq A_k \\leq B_k \\leq 3$. Such pieces may have been rotated, or even flipped, in the havoc that is your trunk.\n\n\nAs the first step towards repairing your trophy, you should reassemble them in the form of a rectangle of size $3 \\times N$. More precisely, you have drawn, on a sheet of paper, a $3 \\times N$ rectangle on which you will place your $K$ pieces, and you need to know, for all integers $i \\leq 3$ and $j \\leq N$, which piece will cover the unit square on the $i^\\text{th}$ line and $j^\\text{th}$ column of your rectangle.\n", "inputFormat": "The input consists of three lines, each one containing space-separated integers. The first line contains the numbers $K$ and $N$. The second line contains the numbers $A_1, A_2, \\dots, A_K$. The third line contains the numbers $B_1, B_2, \\dots, B_K$.\n\n**Limits**\n\t\n- $1 \\leq K \\leq 300~000$;\n- $1 \\leq N \\leq 100~000$;\n- $1 \\leq A_k \\leq B_k \\leq 3$ for all $k \\leq K$;\n- the pieces described in the input can be reassembled in the form of a rectangle of size $3 \\times N$.", "outputFormat": "The output should contain three lines, each one consisting of $N$ space-separated integers. If you plan to cover the unit square on the $i^\\text{th}$ line and $j^\\text{th}$ column with the $k^\\text{th}$ piece, the $j^\\text{th}$ number on the $i^\\text{th}$ output line should be the integer $k$.\n\n\nIn case there are several ways to reassemble your pieces in the form of a rectangle of size $3 \\times N$, every output representing one of these ways is considered correct.", "hint": "**Sample Explanation 1**\n\nThis output represents the following reassembling:\n\n:::align{center}\n\n![](https://espresso.codeforces.com/ebe5fa074a7004f06adef36774082b3ef1655782.png)\n\n:::\n\nAnother valid reassembling could be: \n\n:::align{center}\n\n![](https://espresso.codeforces.com/109dea523bad83462aeee9eb8b60ee35eff479d2.png)\n\n:::", "locale": "en"}, "zh-CN": {"title": "[SWERC 2023] Broken trophy ", "background": null, "description": ":::align{center}\n\n![](https://espresso.codeforces.com/5a9ceba0bef33460fb6104cd612fce7a771f3f73.png)\n\n:::\n\n在你凯旋而归、赢得梦寐以求的奖杯后，你发现奖杯在行李箱中已经碎成了若干块。现在你只能修复它了。\n\n你的奖杯原本是一个 $3 \\times N$ 的矩形，其中 $N \\geq 1$，也就是说它由 3 行 $N$ 列组成，共有 $3N$ 个单位方格。奖杯被分成了 $K$ 块，第 $k$ 块是一个 $A_k \\times B_k$ 的矩形，其中 $1 \\leq A_k \\leq B_k \\leq 3$。这些碎片在行李箱中可能被旋转或翻转过。\n\n修复奖杯的第一步，是将这些碎片重新拼成一个 $3 \\times N$ 的矩形。更具体地说，你在纸上画好了一个 $3 \\times N$ 的矩形，你需要将 $K$ 块碎片放在上面。你需要知道，对于所有 $i \\leq 3$ 和 $j \\leq N$，第 $i$ 行第 $j$ 列的单位方格被哪一块碎片覆盖。", "inputFormat": "输入包含三行，每行由空格分隔的整数组成。第一行包含 $K$ 和 $N$。第二行包含 $A_1, A_2, \\dots, A_K$。第三行包含 $B_1, B_2, \\dots, B_K$。\n\n**数据范围**\n\n- $1 \\leq K \\leq 300\\,000$；\n- $1 \\leq N \\leq 100\\,000$；\n- 对于所有 $k \\leq K$，$1 \\leq A_k \\leq B_k \\leq 3$；\n- 输入中描述的碎片可以被重新拼成一个 $3 \\times N$ 的矩形。", "outputFormat": "输出应包含三行，每行包含 $N$ 个用空格分隔的整数。如果你计划用第 $k$ 块碎片覆盖第 $i$ 行第 $j$ 列的单位方格，那么输出的第 $i$ 行第 $j$ 个数应为整数 $k$。\n\n如果存在多种拼接方式，只要输出其中一种即可。", "hint": "**样例解释 1**\n\n这个输出表示如下的拼接方式：\n\n:::align{center}\n\n![](https://espresso.codeforces.com/ebe5fa074a7004f06adef36774082b3ef1655782.png)\n\n:::\n\n另一种合法的拼接方式为：\n\n:::align{center}\n\n![](https://espresso.codeforces.com/109dea523bad83462aeee9eb8b60ee35eff479d2.png)\n\n:::\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13804", "type": "P", "difficulty": 7, "samples": [["8\n1 2 3 5 6 4 7 8\n5 6 3 8 7 4 2 1\n0 0 6 2 4 0 0 0", "2"], ["3\n1 2 3\n3 2 1\n0 0 0", "4"], ["4\n1 2 3 4\n4 3 2 1\n0 4 0 0", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2023", "树的遍历", "组合数学", "ICPC", "分类讨论"], "title": "[SWERC 2023] In-order", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/a6499cce0b5fa60dce8239f242f6db022df44e14.png)\n\n:::\n\n\nThe opening ceremony for the Olympic Games will take place on the river with teams on boats. The layout of the athletes on top of the boat has been designed in a very specific way: for each team, the $N$ athletes (conveniently numbered from 1 to $N$) are arranged as a binary tree.\n\n\nThe organiser has also designed the pre-order traversal, post-order traversal, and a (possibly empty) consecutive part of the in-order traversal of the binary tree that each team must follow.\n\n\nNow, to make sure there are enough tree layouts so that each team can have a distinct one, you are asked to calculate the quantity of different possible in-order traversals, say $T$, modulo the prime number $999~999~937$.", "inputFormat": "The input consists of four lines. The first line contains the number $N$. Each subsequent line contains a list of $N$ space-separated integers. The second line contains a list $A_1, A_2, \\dots, A_N$, where $A_k$ is the number of the $k^\\text{th}$ athlete found in pre-order traversal. The third line contains a list $B_1, B_2, \\dots, B_N$, where $B_k$ is the number of the $k^\\text{th}$ athlete found in post-order traversal. The fourth line contains a list $C_1, C_2, \\dots, C_N$, where $C_k$ is either the number of the $k^\\text{th}$ athlete found in in-order traversal, or 0 if the organiser did not say who that $k^\\text{th}$ athlete should be.\n\n**Limits**\n\t\n- $1 \\leq N \\leq 500~000$;\n- there exists at least one binary tree with such pre-order, post-order and in-order traversals;\n- the integers k for which $C_k \\geq 1$ form a (possibly empty) sub-interval of the set $\\{1, 2, \\dots, N\\}$; in other words, whenever $k \\leq l$ and both $C_k$ and $C_l$ are positive, all the integers $C_k, C_{k+1}, \\dots, C_l$ are positive.", "outputFormat": "The output should contain a single line, consisting of a single integer $S$: this is the only integer such that $0\\leq S < 999~999~937$ and for which $T-S$ is divisible by $999~999~937$.", "hint": "**Sample Explanation 1**\n\nThe graphs given above the problem statement are the two possible binary trees. Their in-order traversals are:\n- $5\\ 3\\ 6\\ 2\\ 4\\ 8\\ 7\\ 1$\n- $5\\ 3\\ 6\\ 2\\ 4\\ 7\\ 8\\ 1$\n\n**Sample Explanation 2**\n\nThe four possible in-order traversals are:\n- $3\\ 2\\ 1$\n- $2\\ 3\\ 1$\n- $1\\ 3\\ 2$\n- $1\\ 2\\ 3$\n\n**Sample Explanation 3**\n\nThe three possible in-order traversals are:\n- $2\\ 4\\ 3\\ 1$\n- $1\\ 4\\ 3\\ 2$\n- $3\\ 4\\ 2\\ 1$", "locale": "en", "translations": {"en": {"title": "[SWERC 2023] In-order", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/a6499cce0b5fa60dce8239f242f6db022df44e14.png)\n\n:::\n\n\nThe opening ceremony for the Olympic Games will take place on the river with teams on boats. The layout of the athletes on top of the boat has been designed in a very specific way: for each team, the $N$ athletes (conveniently numbered from 1 to $N$) are arranged as a binary tree.\n\n\nThe organiser has also designed the pre-order traversal, post-order traversal, and a (possibly empty) consecutive part of the in-order traversal of the binary tree that each team must follow.\n\n\nNow, to make sure there are enough tree layouts so that each team can have a distinct one, you are asked to calculate the quantity of different possible in-order traversals, say $T$, modulo the prime number $999~999~937$.", "inputFormat": "The input consists of four lines. The first line contains the number $N$. Each subsequent line contains a list of $N$ space-separated integers. The second line contains a list $A_1, A_2, \\dots, A_N$, where $A_k$ is the number of the $k^\\text{th}$ athlete found in pre-order traversal. The third line contains a list $B_1, B_2, \\dots, B_N$, where $B_k$ is the number of the $k^\\text{th}$ athlete found in post-order traversal. The fourth line contains a list $C_1, C_2, \\dots, C_N$, where $C_k$ is either the number of the $k^\\text{th}$ athlete found in in-order traversal, or 0 if the organiser did not say who that $k^\\text{th}$ athlete should be.\n\n**Limits**\n\t\n- $1 \\leq N \\leq 500~000$;\n- there exists at least one binary tree with such pre-order, post-order and in-order traversals;\n- the integers k for which $C_k \\geq 1$ form a (possibly empty) sub-interval of the set $\\{1, 2, \\dots, N\\}$; in other words, whenever $k \\leq l$ and both $C_k$ and $C_l$ are positive, all the integers $C_k, C_{k+1}, \\dots, C_l$ are positive.", "outputFormat": "The output should contain a single line, consisting of a single integer $S$: this is the only integer such that $0\\leq S < 999~999~937$ and for which $T-S$ is divisible by $999~999~937$.", "hint": "**Sample Explanation 1**\n\nThe graphs given above the problem statement are the two possible binary trees. Their in-order traversals are:\n- $5\\ 3\\ 6\\ 2\\ 4\\ 8\\ 7\\ 1$\n- $5\\ 3\\ 6\\ 2\\ 4\\ 7\\ 8\\ 1$\n\n**Sample Explanation 2**\n\nThe four possible in-order traversals are:\n- $3\\ 2\\ 1$\n- $2\\ 3\\ 1$\n- $1\\ 3\\ 2$\n- $1\\ 2\\ 3$\n\n**Sample Explanation 3**\n\nThe three possible in-order traversals are:\n- $2\\ 4\\ 3\\ 1$\n- $1\\ 4\\ 3\\ 2$\n- $3\\ 4\\ 2\\ 1$", "locale": "en"}, "zh-CN": {"title": "[SWERC 2023] In-order", "background": null, "description": ":::align{center}\n\n![](https://espresso.codeforces.com/a6499cce0b5fa60dce8239f242f6db022df44e14.png)\n\n:::\n\n奥运会的开幕式将在河上举行，运动员们将乘船出场。每支队伍的运动员在船上的排列方式被设计成一棵二叉树，每支队伍有 $N$ 名运动员（编号为 $1$ 到 $N$）。\n\n组委会还为每支队伍指定了二叉树的先序遍历、后序遍历，以及中序遍历中的一个（可能为空）连续区间。\n\n现在，为了确保有足够多的树形排列，使得每支队伍都能拥有独特的排列方式，你需要计算不同可能的中序遍历的数量 $T$，并对质数 $999\\,999\\,937$ 取模。", "inputFormat": "输入包含四行。第一行包含一个整数 $N$。接下来的三行每行包含 $N$ 个用空格分隔的整数。第二行为 $A_1, A_2, \\dots, A_N$，其中 $A_k$ 表示先序遍历中第 $k$ 个运动员的编号。第三行为 $B_1, B_2, \\dots, B_N$，其中 $B_k$ 表示后序遍历中第 $k$ 个运动员的编号。第四行为 $C_1, C_2, \\dots, C_N$，其中 $C_k$ 要么是中序遍历中第 $k$ 个运动员的编号，要么为 $0$，表示组委会未指定第 $k$ 个运动员。\n\n**数据范围**\n\n- $1 \\leq N \\leq 500\\,000$；\n- 至少存在一棵二叉树，其先序、后序和中序遍历分别为所给序列；\n- 对于所有 $C_k \\geq 1$ 的 $k$，这些 $k$ 构成集合 $\\{1, 2, \\dots, N\\}$ 的一个（可能为空）连续子区间。换句话说，若 $k \\leq l$ 且 $C_k, C_l$ 都大于 $0$，则 $C_k, C_{k+1}, \\dots, C_l$ 都大于 $0$。", "outputFormat": "输出一行，包含一个整数 $S$，满足 $0 \\leq S < 999\\,999\\,937$，且 $T-S$ 能被 $999\\,999\\,937$ 整除。", "hint": "**样例解释 1**\n\n题目上方给出的两棵二叉树的中序遍历分别为：\n- $5\\ 3\\ 6\\ 2\\ 4\\ 8\\ 7\\ 1$\n- $5\\ 3\\ 6\\ 2\\ 4\\ 7\\ 8\\ 1$\n\n**样例解释 2**\n\n四种可能的中序遍历为：\n- $3\\ 2\\ 1$\n- $2\\ 3\\ 1$\n- $1\\ 3\\ 2$\n- $1\\ 2\\ 3$\n\n**样例解释 3**\n\n三种可能的中序遍历为：\n- $2\\ 4\\ 3\\ 1$\n- $1\\ 4\\ 3\\ 2$\n- $3\\ 4\\ 2\\ 1$\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13805", "type": "P", "difficulty": 6, "samples": [["7\n1 2 4\n4 2 7\n5 1 3\n3 6 4\n1 6 9\n2 7 1\n7\n+ 2 6\n? 3\n? 1\n+ 6 14\n? 1\n? 2\n? 3", "0\n1\n2\n0\n1"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["点分治", "2022", "ICPC", "CERC"], "title": "[CERC 2022] Bandits", "background": "", "description": "There is a kingdom with $N$ villages and $N - 1$ bidirectional roads that allow the citizens to travel between any pair of villages following a path consisting of one or more roads. The $i$-th road connects villages $A_i$ and $B_i$ and has length $C_i$.\n\nThe king has noticed an increasing number of complaints about bandits attacking the merchants travelling along the roads in the kingdom. He has tasked his advisor with solving this problem by hiring loyal groups of thugs that will act as security agencies. Each such security contract guarantees security of all roads in a radius of $R_j$ from the village $X_j$ with the group’s headquarters. A road is protected by the contract if it is part of a path of length at most $R_j$ from $X_j$ to some other village. Some roads may be protected by several contracts and are therefore more secure.\n\nWrite a program that will process queries about new contracts and answer queries about the security of individual roads, that is the number of contracts currently securing that road.", "inputFormat": "The first line contains the number of villages $N$. The roads connecting these villages are described in the following $N - 1$ lines. The description of each road consists of space-separated integers $A_i$, $B_i$ and $C_i$, which represent a road of length $C_i$ between villages $A_i$ and $B_i$. The villages are numbered from 1 to $N$.\n\nNext line contains the number of queries $Q$. The following $Q$ lines describe the queries. The query that represents a new security contract starts with character '+' and is followed by the headquarters village $X_j$ and security radius $R_j$. The query about the security of some road starts with character '?' and is followed by the number $Y_j$ of that road. The roads are numbered from 1 to $N - 1$ in order in which they are given in the input.", "outputFormat": "Process the queries in the given order and for every query of type '?' output one line with the current number of contracts securing the road $Y_j$.", "hint": "### Input limits\n\n* $1 \\leq N, Q \\leq 10^5$\n* $0 \\leq C_i, R_j \\leq 10^9$", "locale": "en", "translations": {"en": {"title": "[CERC 2022] Bandits", "background": "", "description": "There is a kingdom with $N$ villages and $N - 1$ bidirectional roads that allow the citizens to travel between any pair of villages following a path consisting of one or more roads. The $i$-th road connects villages $A_i$ and $B_i$ and has length $C_i$.\n\nThe king has noticed an increasing number of complaints about bandits attacking the merchants travelling along the roads in the kingdom. He has tasked his advisor with solving this problem by hiring loyal groups of thugs that will act as security agencies. Each such security contract guarantees security of all roads in a radius of $R_j$ from the village $X_j$ with the group’s headquarters. A road is protected by the contract if it is part of a path of length at most $R_j$ from $X_j$ to some other village. Some roads may be protected by several contracts and are therefore more secure.\n\nWrite a program that will process queries about new contracts and answer queries about the security of individual roads, that is the number of contracts currently securing that road.", "inputFormat": "The first line contains the number of villages $N$. The roads connecting these villages are described in the following $N - 1$ lines. The description of each road consists of space-separated integers $A_i$, $B_i$ and $C_i$, which represent a road of length $C_i$ between villages $A_i$ and $B_i$. The villages are numbered from 1 to $N$.\n\nNext line contains the number of queries $Q$. The following $Q$ lines describe the queries. The query that represents a new security contract starts with character '+' and is followed by the headquarters village $X_j$ and security radius $R_j$. The query about the security of some road starts with character '?' and is followed by the number $Y_j$ of that road. The roads are numbered from 1 to $N - 1$ in order in which they are given in the input.", "outputFormat": "Process the queries in the given order and for every query of type '?' output one line with the current number of contracts securing the road $Y_j$.", "hint": "### Input limits\n\n* $1 \\leq N, Q \\leq 10^5$\n* $0 \\leq C_i, R_j \\leq 10^9$", "locale": "en"}, "zh-CN": {"title": "[CERC 2022] Bandits", "background": "", "description": "有一个王国，包含 $N$ 个村庄和 $N - 1$ 条双向道路。公民可以通过这些道路沿路径（由一条或多条道路组成）在任意两个村庄之间往来。第 $i$ 条道路连接村庄 $A_i$ 与 $B_i$，长度为 $C_i$。\n\n国王注意到，关于土匪袭击在道路上行商的商人的投诉越来越多。他命令顾问解决这一问题，方法是雇佣忠诚的打手团伙，充当安保机构。每一份安保合同保证从总部所在村庄 $X_j$ 出发，半径 $R_j$ 内的所有道路得到保护。一条道路会被视为受该合同保护，当且仅当它属于从 $X_j$ 出发、长度不超过 $R_j$ 的某条路径的一部分。某些道路可能被多份合同保护，因此会更加安全。\n\n请编写程序，处理关于新合同的查询，并回答针对特定道路的安全性查询，即输出当前保护该道路的合同数量。", "inputFormat": "第一行包含一个整数 $N$，表示村庄的数量。接下来的 $N - 1$ 行描述这些道路。每行包含三个整数 $A_i, B_i, C_i$，表示一条连接村庄 $A_i$ 与 $B_i$ 的道路，其长度为 $C_i$。村庄编号为 $1 \\sim N$。\n\n下一行包含一个整数 $Q$，表示查询数量。接下来的 $Q$ 行依次描述这些查询。\n\n- 表示新安保合同的查询以字符 `'+'` 开头，随后给出总部村庄 $X_j$ 与安全半径 $R_j$。\n- 表示道路安全性的查询以字符 `'?'` 开头，随后给出道路编号 $Y_j$。道路编号为 $1 \\sim N - 1$，编号顺序即为输入时的顺序。\n", "outputFormat": "按照给定顺序处理查询。对于每一个 `'?'` 类型的查询，输出一行，包含当前保护道路 $Y_j$ 的合同数量。\n", "hint": "### 输入限制\n\n* $1 \\leq N, Q \\leq 10^5$\n* $0 \\leq C_i, R_j \\leq 10^9$\n\n---\n\n翻译由 ChatGPT-5 完成", "locale": "zh-CN"}}}
{"pid": "P13806", "type": "P", "difficulty": 6, "samples": [["3\n2 2\n12\n89\n=.\n==\n3 1\n204\n101\n.==\n3 2\n000\n000\n...\n==.", "Alice\nBob\nBob"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["博弈论", "2022", "二分图", "ICPC", "CERC"], "title": "[CERC 2022] Combination Locks", "background": "", "description": "Alice and Bob are playing with combination locks. Each of them has a combination lock that consists of $N$ rotating discs with digits 0 to 9 engraved on them. Their friend Charlie doesn’t have a lock and has devised a game to keep them occupied. He will keep track of whether the corresponding digits of their locks match and will describe the current situation with a difference pattern string $S$. The $j$-th character of $S$ is either '=' or '.' and indicates whether the $j$-th digits in Alice's and Bob's locks match or not, respectively.\n\nCharlie will officiate the game, while Alice and Bob take turns with Alice starting first. On each move, a player has to change one digit of their combination lock. As Charlie only keeps track of the difference patterns, this pattern has to change for a move to be valid. He is also rather superstitious and has brought a list of patterns $P_i$ that must not appear during the game. Charlie's main task is to enforce the rule that no difference pattern repeats during the course of the game. The player who can't make a move loses the game.\n\nWrite a program that will determine the winner of the game if both players play optimally.", "inputFormat": "The first line contains the number of test cases $T$. Each test case starts with a line containing two space-separated integers $N$ and $C$. This is followed by two lines that describe the starting configuration of Alice's and Bob's combination lock. A lock configuration is a string of $N$ digits. The following $C$ lines describe Charlie's superstitious patterns $P_i$. The superstitious list doesn't contain duplicates and it is guaranteed that the difference pattern of the starting lock configurations is not on the superstitious list.", "outputFormat": "For every test case output one line with the name of the winner.", "hint": "### Comment\n\nIn the first example, the only move for Alice is to change the second digit from 2 to 9. Any other move is invalid because it doesn't change the difference pattern or because it would result in a superstitious pattern. Bob doesn't have a valid move, therefore Alice wins.\n\n### Input limits\n\n* $1 \\leq T \\leq 20$\n* $1 \\leq N \\leq 10$\n* $0 \\leq C \\leq 1000$", "locale": "en", "translations": {"en": {"title": "[CERC 2022] Combination Locks", "background": "", "description": "Alice and Bob are playing with combination locks. Each of them has a combination lock that consists of $N$ rotating discs with digits 0 to 9 engraved on them. Their friend Charlie doesn’t have a lock and has devised a game to keep them occupied. He will keep track of whether the corresponding digits of their locks match and will describe the current situation with a difference pattern string $S$. The $j$-th character of $S$ is either '=' or '.' and indicates whether the $j$-th digits in Alice's and Bob's locks match or not, respectively.\n\nCharlie will officiate the game, while Alice and Bob take turns with Alice starting first. On each move, a player has to change one digit of their combination lock. As Charlie only keeps track of the difference patterns, this pattern has to change for a move to be valid. He is also rather superstitious and has brought a list of patterns $P_i$ that must not appear during the game. Charlie's main task is to enforce the rule that no difference pattern repeats during the course of the game. The player who can't make a move loses the game.\n\nWrite a program that will determine the winner of the game if both players play optimally.", "inputFormat": "The first line contains the number of test cases $T$. Each test case starts with a line containing two space-separated integers $N$ and $C$. This is followed by two lines that describe the starting configuration of Alice's and Bob's combination lock. A lock configuration is a string of $N$ digits. The following $C$ lines describe Charlie's superstitious patterns $P_i$. The superstitious list doesn't contain duplicates and it is guaranteed that the difference pattern of the starting lock configurations is not on the superstitious list.", "outputFormat": "For every test case output one line with the name of the winner.", "hint": "### Comment\n\nIn the first example, the only move for Alice is to change the second digit from 2 to 9. Any other move is invalid because it doesn't change the difference pattern or because it would result in a superstitious pattern. Bob doesn't have a valid move, therefore Alice wins.\n\n### Input limits\n\n* $1 \\leq T \\leq 20$\n* $1 \\leq N \\leq 10$\n* $0 \\leq C \\leq 1000$", "locale": "en"}, "zh-CN": {"title": "[CERC 2022] Combination Locks", "background": null, "description": "Alice 和 Bob 正在玩组合锁。每个人都有一个由 $N$ 个可旋转数字盘组成的组合锁，每个数字盘上刻有 $0$ 到 $9$ 的数字。他们的朋友 Charlie 没有锁，于是设计了一个游戏让他们消遣。他会记录他们锁上对应数字是否相同，并用一个差异模式字符串 $S$ 来描述当前情况。$S$ 的第 $j$ 个字符要么是 '='，要么是 '.'，分别表示 Alice 和 Bob 的锁的第 $j$ 个数字是否相同。\n\nCharlie 负责裁判，Alice 和 Bob 轮流操作，Alice 先手。每次操作时，玩家必须改变自己组合锁上的一个数字。由于 Charlie 只记录差异模式，因此一次有效的操作必须使差异模式发生变化。他还非常迷信，带来了一份不能在游戏过程中出现的模式列表 $P_i$。Charlie 的主要任务是确保在游戏过程中没有差异模式重复出现。无法进行有效操作的玩家判负。\n\n请编写程序判断如果双方都采取最优策略，谁将获胜。", "inputFormat": "第一行包含测试用例数 $T$。每个测试用例第一行包含两个用空格分隔的整数 $N$ 和 $C$。接下来两行分别描述 Alice 和 Bob 的组合锁初始状态，每个锁的状态是一个长度为 $N$ 的数字字符串。接下来的 $C$ 行，每行给出一个 Charlie 迷信的模式 $P_i$。迷信模式列表中没有重复，且保证初始锁状态对应的差异模式不在迷信模式列表中。", "outputFormat": "对于每个测试用例，输出一行，表示获胜者的名字。", "hint": "### 说明\n\n在第一个样例中，Alice 唯一的操作是将第二位数字从 2 改为 9。其他操作要么不会改变差异模式，要么会导致出现迷信模式。Bob 无法进行有效操作，因此 Alice 获胜。\n\n### 输入范围\n\n- $1 \\leq T \\leq 20$\n- $1 \\leq N \\leq 10$\n- $0 \\leq C \\leq 1000$\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13807", "type": "P", "difficulty": 4, "samples": [["3\n0 0\n-1 0\n10 10", "2\n3"], ["4\n0 0\n0 -1\n0 1\n0 2", "2\n2\n4"], ["4\n0 0\n0 1\n0 -1\n0 2", "2\n3\n4"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "ICPC", "CERC"], "title": "[CERC 2022] Constellations", "background": "", "description": "Astrologists took a hard scientific look at their zodiac horoscope predictions and realised that their methodology doesn't provide future insight better than chance. Instead of looking inwards they blame the stars and historical construction of constellations for their inability to predict the future. They're testing out a new way of constructing constellations that will renew their powers of future-sight.\n\nThey need your help to implement their iterative constellation creation system. Initially every star represents its own constellation. In every step you should merge two constellations into one, by picking the constellations that are closest to each other. The distance between two constellations $A$ and $B$ is defined as the average squared Euclidean distance of pairs of stars from each constellation:\n\n$$d(A, B) = \\frac{1}{|A||B|} \\sum_{a \\in A} \\sum_{b \\in B} ||a - b||^2$$\n\nIf multiple pairs have the same distance you should merge older constellations first. When comparing two pairs of constellations that could be merged, first compare the distances between constellations. If both pairs are at exactly the same distance, compare them by the age of the older constellation in a pair. If there is still a tie, compare them by the age of the newer constellation in a pair. A constellation's age is defined by the time when it was formed with the last merge, or in case of single-star constellations by the age of the star. The stars in the input are listed from oldest to youngest.", "inputFormat": "The first line contains $N$, the number of stars. The next $N$ lines contain coordinates of stars with two space-separated integers $X_i$ and $Y_i$.", "outputFormat": "After every step of the described constellation creation system, print out the size of the newly created constellation. You should output $N - 1$ lines.", "hint": "### Input limits\n\n* $2 \\leq N \\leq 2000$\n* $-1000 \\leq X_i, Y_i \\leq 1000$ for all $1 \\leq i \\leq N$\n* All pairs $X_i, Y_i$ are unique since it’s physically impossible for two stars to lie on the same point.", "locale": "en", "translations": {"en": {"title": "[CERC 2022] Constellations", "background": "", "description": "Astrologists took a hard scientific look at their zodiac horoscope predictions and realised that their methodology doesn't provide future insight better than chance. Instead of looking inwards they blame the stars and historical construction of constellations for their inability to predict the future. They're testing out a new way of constructing constellations that will renew their powers of future-sight.\n\nThey need your help to implement their iterative constellation creation system. Initially every star represents its own constellation. In every step you should merge two constellations into one, by picking the constellations that are closest to each other. The distance between two constellations $A$ and $B$ is defined as the average squared Euclidean distance of pairs of stars from each constellation:\n\n$$d(A, B) = \\frac{1}{|A||B|} \\sum_{a \\in A} \\sum_{b \\in B} ||a - b||^2$$\n\nIf multiple pairs have the same distance you should merge older constellations first. When comparing two pairs of constellations that could be merged, first compare the distances between constellations. If both pairs are at exactly the same distance, compare them by the age of the older constellation in a pair. If there is still a tie, compare them by the age of the newer constellation in a pair. A constellation's age is defined by the time when it was formed with the last merge, or in case of single-star constellations by the age of the star. The stars in the input are listed from oldest to youngest.", "inputFormat": "The first line contains $N$, the number of stars. The next $N$ lines contain coordinates of stars with two space-separated integers $X_i$ and $Y_i$.", "outputFormat": "After every step of the described constellation creation system, print out the size of the newly created constellation. You should output $N - 1$ lines.", "hint": "### Input limits\n\n* $2 \\leq N \\leq 2000$\n* $-1000 \\leq X_i, Y_i \\leq 1000$ for all $1 \\leq i \\leq N$\n* All pairs $X_i, Y_i$ are unique since it’s physically impossible for two stars to lie on the same point.", "locale": "en"}, "zh-CN": {"title": "[CERC 2022] Constellations", "background": null, "description": "占星家们对他们的星座运势预测进行了严谨的科学研究，发现他们的方法论并不能比随机更好地预测未来。他们没有反思自身，而是将责任归咎于星星和历史上星座的构造，认为这些导致了他们无法预测未来。现在他们正在尝试一种新的星座构造方式，希望借此恢复他们的预知能力。\n\n他们需要你的帮助来实现他们的迭代星座创建系统。最初，每颗星星都代表一个独立的星座。在每一步中，你需要将距离最近的两个星座合并为一个。两个星座 $A$ 和 $B$ 之间的距离定义为它们各自所有星星两两之间的平方欧几里得距离的平均值：\n\n$$d(A, B) = \\frac{1}{|A||B|} \\sum_{a \\in A} \\sum_{b \\in B} ||a - b||^2$$\n\n如果有多对星座之间的距离相同，则应优先合并较老的星座。当比较可以合并的两对星座时，首先比较它们之间的距离。如果距离相同，则比较这两对中较老星座的年龄。如果仍然相同，则比较较新星座的年龄。星座的年龄定义为其最后一次合并时的时间，对于单星星座则为该星星的年龄。输入中的星星按从最老到最年轻的顺序给出。", "inputFormat": "第一行包含一个整数 $N$，表示星星的数量。接下来的 $N$ 行，每行包含两个用空格分隔的整数 $X_i$ 和 $Y_i$，表示第 $i$ 颗星星的坐标。", "outputFormat": "每当按照描述的星座创建系统完成一次合并后，输出新创建星座的大小。共需输出 $N-1$ 行。", "hint": "### 输入范围\n\n- $2 \\leq N \\leq 2000$\n- 对于所有 $1 \\leq i \\leq N$，$-1000 \\leq X_i, Y_i \\leq 1000$\n- 所有 $(X_i, Y_i)$ 坐标都是唯一的，因为物理上不可能有两颗星星在同一个点。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13808", "type": "P", "difficulty": 3, "samples": [["1\n10 0", "10"], ["7\n5 2\n7 0\n2 0", "2"], ["5\n2 3\n2 2\n1 0\n1 0\n6 0\n4 2\n3 0\n2 0", "5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2022", "ICPC", "CERC"], "title": "[CERC 2022] Deforestation", "background": "", "description": "You want to remove a big tree from your property, but it's too big for you to carry all at once. How many pieces do you have to cut it into if the maximum weight you can carry is $W$?\n\nThe tree has a single trunk connected to the ground and can split out into multiple branches. All of those branches can branch out further etc. So each segment of the tree is a continuous mass of wood, which may or may not split out into multiple branches.\n\nYou can make cuts at any point on the tree; start, end, or anywhere in the middle of any segment. You can consider branching as an arbitrarily small part of the tree, i.e. you can cut immediately before or after a branch splits off without increasing the weight of the base branch, but it will affect whether the child branches are cut off as a single piece or just one branch is cut off separately.", "inputFormat": "The first line of the input will contain $W$, your carrying capacity. The next line will continue with the description of the first tree segment; its trunk.\n\nA tree segment description is defined recursively. The first line contains two numbers $M$, weight of the segment, and $N$, number of branches coming out of the segment at its end. This is followed by $N$ tree segment descriptions, describing each one of the branches.", "outputFormat": "Output one number, the number of pieces you have to cut the tree into.", "hint": "### Comment\n\nImage shows some possible solutions of sample test cases.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/ovr7c4zx.png)\n:::\n\n### Input limits\n\n* $1 \\leq W, M \\leq 10^9$\n* $0 \\leq N \\leq 10^5$\n* Total weight of all tree segments will not exceed $10^9$.\n* Total number of segments will not exceed $10^5$.", "locale": "en", "translations": {"en": {"title": "[CERC 2022] Deforestation", "background": "", "description": "You want to remove a big tree from your property, but it's too big for you to carry all at once. How many pieces do you have to cut it into if the maximum weight you can carry is $W$?\n\nThe tree has a single trunk connected to the ground and can split out into multiple branches. All of those branches can branch out further etc. So each segment of the tree is a continuous mass of wood, which may or may not split out into multiple branches.\n\nYou can make cuts at any point on the tree; start, end, or anywhere in the middle of any segment. You can consider branching as an arbitrarily small part of the tree, i.e. you can cut immediately before or after a branch splits off without increasing the weight of the base branch, but it will affect whether the child branches are cut off as a single piece or just one branch is cut off separately.", "inputFormat": "The first line of the input will contain $W$, your carrying capacity. The next line will continue with the description of the first tree segment; its trunk.\n\nA tree segment description is defined recursively. The first line contains two numbers $M$, weight of the segment, and $N$, number of branches coming out of the segment at its end. This is followed by $N$ tree segment descriptions, describing each one of the branches.", "outputFormat": "Output one number, the number of pieces you have to cut the tree into.", "hint": "### Comment\n\nImage shows some possible solutions of sample test cases.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/ovr7c4zx.png)\n:::\n\n### Input limits\n\n* $1 \\leq W, M \\leq 10^9$\n* $0 \\leq N \\leq 10^5$\n* Total weight of all tree segments will not exceed $10^9$.\n* Total number of segments will not exceed $10^5$.", "locale": "en"}, "zh-CN": {"title": "[CERC 2022] Deforestation", "background": null, "description": "你想要从你的土地上移除一棵大树，但它太大了，你无法一次性搬走。若你一次最多能搬运 $W$ 重量，你需要把这棵树切成多少段才能搬走？\n\n这棵树有一根主干与地面相连，并且可以分出多根分支。所有这些分支还可以继续分叉，依此类推。因此，树的每一段都是一段连续的木头，可能会分出多个分支，也可能没有。\n\n你可以在树的任意位置切割：起点、终点或任何一段的中间。你可以把分叉点看作树上的一个极小的部分，也就是说，你可以在分叉前后立即切割，而不会增加主干的重量，但这会影响子分支是作为一个整体被切下，还是只切下其中一根分支。", "inputFormat": "输入的第一行包含一个整数 $W$，表示你一次能搬运的最大重量。下一行开始描述树的第一段，也就是主干。\n\n一段树的描述是递归定义的。第一行包含两个整数 $M$（该段的重量）和 $N$（该段末端分出的分支数）。接下来是 $N$ 段树的描述，分别描述每一根分支。", "outputFormat": "输出一个整数，表示你需要把树切成多少段才能搬走。", "hint": "### 说明\n\n下图展示了样例测试用例的一些可能的切割方案。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/ovr7c4zx.png)\n:::\n\n### 输入范围\n\n- $1 \\leq W, M \\leq 10^9$\n- $0 \\leq N \\leq 10^5$\n- 所有树段的总重量不超过 $10^9$。\n- 树段总数不超过 $10^5$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13809", "type": "P", "difficulty": 3, "samples": [["6\n0.137516331034\n0.165019597241\n0.275032662068\n0.412548993102\n0.825097986204\n0.165019597241", "5\n6\n10\n15\n30\n6"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2022", "Special Judge", "ICPC", "CERC"], "title": "[CERC 2022] Denormalization", "background": "", "description": "Dr. Brodnik prepared a list $A = [a_1, a_2, \\ldots, a_N]$ that contained $N$ integers. No one knows what exactly these numbers represented, but it is well known that:\n\n* $1 \\leq a_i \\leq 10\\,000$ for all $1 \\leq i \\leq N$ and\n* their greatest common divisor was 1.\n\nDr. Hočevar decided to do his colleague a favor and normalized the list, as he thought that it represents a vector in the $n$-dimensional real vector space. Namely, he calculated the number\n\n$$d = \\sqrt{\\sum_{i=1}^{N} a_i^2} = \\sqrt{a_1^2 + a_2^2 + \\cdots + a_N^2}$$\n\nand replaced Dr. Brodnik's list by $[a_1/d, a_2/d, \\ldots, a_N/d]$. The numbers in this normalized list were also rounded to 12 decimal places for storage. We will refer to the elements of the stored normalized list as $X = [x_1, x_2, \\ldots, x_N]$. After some time, he realized that it was a mistake and he now wishes to recover the original list $A$. Of course, no backup of the original has been made. Since Dr. Hočevar is too busy at the moment doing more important tasks, your help will be much appreciated.\n\nAs some data was lost due to rounding, he will be happy with any reconstructed list $R = [r_1, r_2, \\ldots, r_N]$, such that after normalization it would differ from $X$ by at most $10^{-6}$ in each corresponding element.", "inputFormat": "The first line of the input contains an integer $N$, i.e. the length of the list $X$. The $i$-th of the following $N$ lines contains a floating-point number $x_i$ with exactly 12 decimal places. It is guaranteed that the input is valid, i.e. it was really obtained in the described manner from a list of integers with the properties described above.", "outputFormat": "The output should contain $N$ lines containing the reconstructed integers $r_1, r_2, \\ldots, r_N$ in this order. You can output any acceptable solution as described above.\n", "hint": "### Input limits\n\n* $2 \\leq N \\leq 10\\,000$\n* $0 < x_i < 1$ for all $1 \\leq i \\leq N$\n\n### Output limits\n\n* $1 \\leq r_i \\leq 10\\,000$ for all $1 \\leq i \\leq N$\n* $\\gcd(r_1, \\ldots, r_N) = 1$", "locale": "en", "translations": {"en": {"title": "[CERC 2022] Denormalization", "background": "", "description": "Dr. Brodnik prepared a list $A = [a_1, a_2, \\ldots, a_N]$ that contained $N$ integers. No one knows what exactly these numbers represented, but it is well known that:\n\n* $1 \\leq a_i \\leq 10\\,000$ for all $1 \\leq i \\leq N$ and\n* their greatest common divisor was 1.\n\nDr. Hočevar decided to do his colleague a favor and normalized the list, as he thought that it represents a vector in the $n$-dimensional real vector space. Namely, he calculated the number\n\n$$d = \\sqrt{\\sum_{i=1}^{N} a_i^2} = \\sqrt{a_1^2 + a_2^2 + \\cdots + a_N^2}$$\n\nand replaced Dr. Brodnik's list by $[a_1/d, a_2/d, \\ldots, a_N/d]$. The numbers in this normalized list were also rounded to 12 decimal places for storage. We will refer to the elements of the stored normalized list as $X = [x_1, x_2, \\ldots, x_N]$. After some time, he realized that it was a mistake and he now wishes to recover the original list $A$. Of course, no backup of the original has been made. Since Dr. Hočevar is too busy at the moment doing more important tasks, your help will be much appreciated.\n\nAs some data was lost due to rounding, he will be happy with any reconstructed list $R = [r_1, r_2, \\ldots, r_N]$, such that after normalization it would differ from $X$ by at most $10^{-6}$ in each corresponding element.", "inputFormat": "The first line of the input contains an integer $N$, i.e. the length of the list $X$. The $i$-th of the following $N$ lines contains a floating-point number $x_i$ with exactly 12 decimal places. It is guaranteed that the input is valid, i.e. it was really obtained in the described manner from a list of integers with the properties described above.", "outputFormat": "The output should contain $N$ lines containing the reconstructed integers $r_1, r_2, \\ldots, r_N$ in this order. You can output any acceptable solution as described above.\n", "hint": "### Input limits\n\n* $2 \\leq N \\leq 10\\,000$\n* $0 < x_i < 1$ for all $1 \\leq i \\leq N$\n\n### Output limits\n\n* $1 \\leq r_i \\leq 10\\,000$ for all $1 \\leq i \\leq N$\n* $\\gcd(r_1, \\ldots, r_N) = 1$", "locale": "en"}, "zh-CN": {"title": "[CERC 2022] Denormalization", "background": null, "description": "Brodnik 博士准备了一个包含 $N$ 个整数的列表 $A = [a_1, a_2, \\ldots, a_N]$。没有人确切知道这些数字代表什么，但众所周知：\n\n- 对于所有 $1 \\leq i \\leq N$，都有 $1 \\leq a_i \\leq 10\\,000$；\n- 这些数的最大公约数为 $1$。\n\nHočevar 博士决定帮同事一个忙，将该列表归一化，因为他认为这代表 $n$ 维实向量空间中的一个向量。具体来说，他计算了\n\n$$d = \\sqrt{\\sum_{i=1}^{N} a_i^2} = \\sqrt{a_1^2 + a_2^2 + \\cdots + a_N^2}$$\n\n并将 Brodnik 博士的列表替换为 $[a_1/d, a_2/d, \\ldots, a_N/d]$。归一化后的每个数都被保留到小数点后 12 位用于存储。我们将存储的归一化列表记为 $X = [x_1, x_2, \\ldots, x_N]$。过了一段时间后，他意识到这是个错误，现在希望恢复原始列表 $A$。当然，原始数据没有备份。由于 Hočevar 博士现在正忙于更重要的任务，非常希望你能帮忙。\n\n由于四舍五入导致部分数据丢失，他只需要你构造出任意一个列表 $R = [r_1, r_2, \\ldots, r_N]$，使得归一化后与 $X$ 中对应元素的差值不超过 $10^{-6}$ 即可。", "inputFormat": "输入的第一行包含一个整数 $N$，即列表 $X$ 的长度。接下来的 $N$ 行中，第 $i$ 行包含一个浮点数 $x_i$，精确到小数点后 12 位。保证输入是有效的，即确实是按照题目描述的方法由满足条件的整数列表得到的。", "outputFormat": "输出应包含 $N$ 行，依次输出重构得到的整数 $r_1, r_2, \\ldots, r_N$。你可以输出任意一个满足要求的解。", "hint": "### 输入范围\n\n- $2 \\leq N \\leq 10\\,000$\n- 对于所有 $1 \\leq i \\leq N$，都有 $0 < x_i < 1$\n\n### 输出范围\n\n- 对于所有 $1 \\leq i \\leq N$，都有 $1 \\leq r_i \\leq 10\\,000$\n- $\\gcd(r_1, \\ldots, r_N) = 1$\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13810", "type": "P", "difficulty": 4, "samples": [["5 10 2\nDCDDDCCADA\nACADDCCADA\nDBADDCCBDC\nDBADDCCADA\nABADDCCADC", "4"], ["4 6 5\nAABAAA\nBAABBB\nABAAAA\nABBAAB", "2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2022", "随机化", "ICPC", "CERC"], "title": "[CERC 2022] Differences", "background": "", "description": "We have a list of $N$ strings $S_i$. All strings have length $M$ and consist only of characters A, B, C and D. Let us define the distance between two strings $X$ and $Y$ as the number of indices $j$, where the strings have different characters ($X_j \\neq Y_j$). We know that the list of strings $S_i$ contains precisely one special string that has distance $K$ to all other strings. Note that there might be other pairs of strings with a distance of $K$. We are experiencing problems finding this special string, so please write a program to help us out.", "inputFormat": "The first line contains space-separated integers $N$, $M$ and $K$. Strings $S_i$ are given in the following $N$ lines.\n", "outputFormat": "Output the index $i$ of the special string. Strings are numbered from 1 to $N$ as given in the input.", "hint": "### Input limits\n\n* $2 \\leq N, M \\leq 10^5$\n* $1 \\leq K \\leq M$\n* $NM \\leq 2 \\cdot 10^7$", "locale": "en", "translations": {"en": {"title": "[CERC 2022] Differences", "background": "", "description": "We have a list of $N$ strings $S_i$. All strings have length $M$ and consist only of characters A, B, C and D. Let us define the distance between two strings $X$ and $Y$ as the number of indices $j$, where the strings have different characters ($X_j \\neq Y_j$). We know that the list of strings $S_i$ contains precisely one special string that has distance $K$ to all other strings. Note that there might be other pairs of strings with a distance of $K$. We are experiencing problems finding this special string, so please write a program to help us out.", "inputFormat": "The first line contains space-separated integers $N$, $M$ and $K$. Strings $S_i$ are given in the following $N$ lines.\n", "outputFormat": "Output the index $i$ of the special string. Strings are numbered from 1 to $N$ as given in the input.", "hint": "### Input limits\n\n* $2 \\leq N, M \\leq 10^5$\n* $1 \\leq K \\leq M$\n* $NM \\leq 2 \\cdot 10^7$", "locale": "en"}, "zh-CN": {"title": "[CERC 2022] Differences", "background": null, "description": "我们有一个包含 $N$ 个字符串 $S_i$ 的列表。所有字符串长度均为 $M$，且只包含字符 A、B、C 和 D。我们定义两个字符串 $X$ 和 $Y$ 之间的距离为它们在所有下标 $j$ 处字符不同的个数（即 $X_j \\neq Y_j$ 的下标数量）。已知在这些字符串中，恰好有一个特殊字符串，它与其他所有字符串的距离均为 $K$。注意，可能存在其他字符串对之间的距离也为 $K$。我们在寻找这个特殊字符串时遇到了困难，请你编写程序帮助我们找到它。", "inputFormat": "第一行包含用空格分隔的三个整数 $N$、$M$ 和 $K$。接下来的 $N$ 行，每行一个字符串 $S_i$。", "outputFormat": "输出特殊字符串的编号 $i$。字符串按输入顺序从 1 到 $N$ 编号。", "hint": "### 输入限制\n\n- $2 \\leq N, M \\leq 10^5$\n- $1 \\leq K \\leq M$\n- $NM \\leq 2 \\cdot 10^7$\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13811", "type": "P", "difficulty": 4, "samples": [["1", "4 3\n\n2 6"], ["3", "4 4\n3 5\n6 1\n\n2 7\n5 4\n5 5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2022", "Special Judge", "ICPC", "CERC"], "title": "[CERC 2022] Greedy Drawers", "background": "", "description": "Janko has $N$ rectangular notebooks on the table. The $i$-th notebook has sides of length $A_i$ and $B_i$. Next to the table is a chest of drawers that consists of $N$ drawers, which have a rectangular shape but can be of different sizes. The $j$-th drawer has width $X_j$ and depth $Y_j$. Janko wants to store each notebook in its own drawer. He can rotate the notebooks but will place them in a drawer so that the sides of the notebook are aligned with the sides of the drawer. A notebook fits into the drawer if the length of each side does not exceed the length of the corresponding aligned side of the drawer.\n\nJanko has decided on a procedure to assign notebooks to drawers. For every notebook he will determine the number of drawers that he can fit the notebook into. Similarly, he will determine for every drawer the number of notebooks that would fit into this drawer. Then he will select the object (notebook or drawer) with the smallest number of options. If this object has no options, the procedure stops with a failure. If there are several objects with the same smallest number of options, he will select one uniformly at random. He will assign one of the options to the selected object uniformly at random. If the selected object was a notebook, he will assign it to a random drawer that can fit the notebook. If the selected object was a drawer, he will assign it to a random notebook that fits into the drawer. He will remove the assigned pair (notebook and drawer) and repeat the procedure until all notebooks are assigned to drawers.\n\nMetka has overheard Janko's idea about placing notebooks into drawers. She is convinced that his procedure is flawed and might not succeed. Help her by writing a program that will read the number of notebooks and drawers $N$ and output a list of notebooks and a list of drawers where Janko's random greedy method doesn't necessarily find an assignment of all notebooks to drawers although such an assignment exists.\n", "inputFormat": "The first and only line contains integer the number of notebooks and drawers $N$.", "outputFormat": "First, output $N$ lines with space-separated notebook side lengths $A_i$ and $B_i$. Next, output an empty line followed by another $N$ lines with space-separated drawer dimensions $X_j$ and $Y_j$. All dimensions should be integers between 1 and 1000, inclusive.\n", "hint": "### Comment\n\nNote that the provided sample inputs and outputs are incorrect. The inputs don't respect the constraint $150 \\leq N$.\n\nIn the first sample, there is a single notebook which doesn't fit into the single drawer, therefore a valid assignment doesn't exist.\n\nIn the second sample, Janko's method would successfully assign all notebooks to drawers. First, it would select the last notebook ($6 \\times 1$) or the first drawer ($2 \\times 7$) and assign it to the other one because both have a single option. Now both remaining notebooks fit into both remaining drawers, therefore any assignment will do.\n\n### Evaluation\n\nTo evaluate the output of your program, we will run Janko's random greedy method on your data (notebook and drawer dimensions). Note that there must exist an assignment of all notebooks to drawers, otherwise your output will be considered as incorrect. Your solution will be evaluated on 20 test cases and Janko's method has to fail on all of them. For every test case we will run Janko's method once with a fixed random seed.\n\n### Input limits\n\n- $150 \\leq N \\leq 250$", "locale": "en", "translations": {"en": {"title": "[CERC 2022] Greedy Drawers", "background": "", "description": "Janko has $N$ rectangular notebooks on the table. The $i$-th notebook has sides of length $A_i$ and $B_i$. Next to the table is a chest of drawers that consists of $N$ drawers, which have a rectangular shape but can be of different sizes. The $j$-th drawer has width $X_j$ and depth $Y_j$. Janko wants to store each notebook in its own drawer. He can rotate the notebooks but will place them in a drawer so that the sides of the notebook are aligned with the sides of the drawer. A notebook fits into the drawer if the length of each side does not exceed the length of the corresponding aligned side of the drawer.\n\nJanko has decided on a procedure to assign notebooks to drawers. For every notebook he will determine the number of drawers that he can fit the notebook into. Similarly, he will determine for every drawer the number of notebooks that would fit into this drawer. Then he will select the object (notebook or drawer) with the smallest number of options. If this object has no options, the procedure stops with a failure. If there are several objects with the same smallest number of options, he will select one uniformly at random. He will assign one of the options to the selected object uniformly at random. If the selected object was a notebook, he will assign it to a random drawer that can fit the notebook. If the selected object was a drawer, he will assign it to a random notebook that fits into the drawer. He will remove the assigned pair (notebook and drawer) and repeat the procedure until all notebooks are assigned to drawers.\n\nMetka has overheard Janko's idea about placing notebooks into drawers. She is convinced that his procedure is flawed and might not succeed. Help her by writing a program that will read the number of notebooks and drawers $N$ and output a list of notebooks and a list of drawers where Janko's random greedy method doesn't necessarily find an assignment of all notebooks to drawers although such an assignment exists.\n", "inputFormat": "The first and only line contains integer the number of notebooks and drawers $N$.", "outputFormat": "First, output $N$ lines with space-separated notebook side lengths $A_i$ and $B_i$. Next, output an empty line followed by another $N$ lines with space-separated drawer dimensions $X_j$ and $Y_j$. All dimensions should be integers between 1 and 1000, inclusive.\n", "hint": "### Comment\n\nNote that the provided sample inputs and outputs are incorrect. The inputs don't respect the constraint $150 \\leq N$.\n\nIn the first sample, there is a single notebook which doesn't fit into the single drawer, therefore a valid assignment doesn't exist.\n\nIn the second sample, Janko's method would successfully assign all notebooks to drawers. First, it would select the last notebook ($6 \\times 1$) or the first drawer ($2 \\times 7$) and assign it to the other one because both have a single option. Now both remaining notebooks fit into both remaining drawers, therefore any assignment will do.\n\n### Evaluation\n\nTo evaluate the output of your program, we will run Janko's random greedy method on your data (notebook and drawer dimensions). Note that there must exist an assignment of all notebooks to drawers, otherwise your output will be considered as incorrect. Your solution will be evaluated on 20 test cases and Janko's method has to fail on all of them. For every test case we will run Janko's method once with a fixed random seed.\n\n### Input limits\n\n- $150 \\leq N \\leq 250$", "locale": "en"}, "zh-CN": {"title": "[CERC 2022] Greedy Drawers", "background": null, "description": "Janko 桌子上有 $N$ 本矩形笔记本。第 $i$ 本笔记本的边长为 $A_i$ 和 $B_i$。桌子旁边有一个由 $N$ 个抽屉组成的柜子，每个抽屉也是矩形，但尺寸可能不同。第 $j$ 个抽屉的宽为 $X_j$，深为 $Y_j$。Janko 想把每本笔记本放进一个抽屉。他可以旋转笔记本，但必须让笔记本的边与抽屉的边平行。只有当笔记本的每条边都不超过抽屉对应边的长度时，笔记本才能放进抽屉。\n\nJanko 决定采用如下分配笔记本到抽屉的流程：对于每本笔记本，他会计算它可以放进多少个抽屉。同样地，他会计算每个抽屉可以放进多少本笔记本。然后，他会选择“可选项最少”的对象（笔记本或抽屉）。如果该对象没有可选项，流程失败。如果有多个对象的可选项数量相同且最少，则随机选择一个。他会将该对象随机分配给一个可选项。如果选中的是笔记本，则将其随机分配到一个能放下它的抽屉；如果选中的是抽屉，则将其随机分配给一个能放进它的笔记本。分配后，移除这对笔记本和抽屉，重复该流程直到所有笔记本都被分配到抽屉。\n\nMetka 听说了 Janko 的分配方法，认为这种方法有缺陷，可能无法成功完成分配。请你编写一个程序，读入笔记本和抽屉的数量 $N$，输出一组笔记本和抽屉的尺寸，使得 Janko 的随机贪心方法不一定能找到全部笔记本到抽屉的分配方案，尽管实际上存在一种可行的分配方式。", "inputFormat": "第一行包含一个整数 $N$，表示笔记本和抽屉的数量。", "outputFormat": "首先输出 $N$ 行，每行两个用空格分隔的整数 $A_i$ 和 $B_i$，表示第 $i$ 本笔记本的边长。\n\n接下来输出一个空行，然后输出 $N$ 行，每行两个用空格分隔的整数 $X_j$ 和 $Y_j$，表示第 $j$ 个抽屉的尺寸。\n\n所有尺寸均为 $1$ 到 $1000$ 之间的整数。", "hint": "### 说明\n\n注意，所给的样例输入输出是错误的。输入不满足 $150 \\leq N$ 的约束。\n\n在第一个样例中，只有一本笔记本且无法放进唯一的抽屉，因此不存在可行分配。\n\n在第二个样例中，Janko 的方法可以成功分配所有笔记本到抽屉。首先会选择最后一本笔记本（$6 \\times 1$）或第一个抽屉（$2 \\times 7$），并将其分配给另一个，因为它们都只有一个可选项。此后剩下的笔记本都能放进剩下的抽屉，因此任意分配都可以。\n\n### 评测\n\n评测时，我们会对你的数据运行 Janko 的随机贪心方法。注意，必须存在一种将所有笔记本分配到抽屉的方案，否则你的输出会被判为错误。你的方案将在 20 个测试用例上评测，Janko 的方法在每个用例上都必须失败。对于每个测试用例，我们会用固定的随机种子运行 Janko 的方法一次。\n\n### 输入范围\n\n- $150 \\leq N \\leq 250$\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13812", "type": "P", "difficulty": 6, "samples": [["ab\naba\naba", "2 1 2 2"], ["abaab\naba\nababa", "1 3 1 5"], ["eeoeo\neoe\neeo", "2 3 1 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["树状数组", "2022", "KMP 算法", "ICPC", "CERC"], "title": "[CERC 2022] Insertions", "background": "", "description": "We are given three strings, $s$, $t$ and $p$. We will denote the length of a string by vertical bars, thus $|s|$ is the length of $s$ and so on. If we insert $t$ into $s$ at position $k$, where $0 \\leq k \\leq |s|$, the result is a new string consisting of the first $k$ characters of $s$, followed by the entirety of $t$, and finally followed by the remaining $|s| - k$ characters of $s$. We would like to select $k$ so that the resulting new string will contain the largest possible number of occurrences of $p$ as a substring.\n\nThus, for example, inserting $t = \\text{aba}$ into $s = \\text{ab}$ at position $k = 0$ results in the string $\\text{abaab}$; at $k = 1$, in the string $\\text{aabab}$; and at $k = 2$, in the string $\\text{ababa}$. If we are interested in occurrences of $p = \\text{aba}$, then the best position to insert $t$ into $s$ is $k = 2$, where we get two occurrences: $\\text{ababa}$ and $\\text{ababa}$ (as this example shows, occurrences of $p$ are allowed to overlap). If, on the other hand, we were interested in occurrences of $p = \\text{aa}$, then the best choices of $k$ would be $k = 0$ and $k = 1$, which result in one occurrence of $p$, whereas $k = 2$ results in 0 occurrences of $p$.\n", "inputFormat": "The first line contains the string $s$, the second line the string $t$, and the third line the string $p$.", "outputFormat": "Output one line containing the following four integers, separated by spaces:\n\n1. The maximum number of occurrences of $p$ we can get after inserting $t$ into $s$ at position $k$, if we choose the position $k$ wisely.\n2. The number of different $k$'s (from the range $0, 1, \\ldots, |s|$) where this maximum number of occurrences of $p$ is attained.\n3. The minimum value of $k$ where the maximum number of occurrences of $p$ is attained.\n4. The maximum value of $k$ where the maximum number of occurrences of $p$ is attained.", "hint": "### Comment\n\nThe first of these three examples is the one discussed earlier in the problem statement\n\n### Input limits\n\n- $1 \\leq |s| \\leq 10^5$\n- $1 \\leq |t| \\leq 10^5$\n- $1 \\leq |p| \\leq 10^5$\n- All the strings consist only of lowercase letters of the English alphabet.", "locale": "en", "translations": {"en": {"title": "[CERC 2022] Insertions", "background": "", "description": "We are given three strings, $s$, $t$ and $p$. We will denote the length of a string by vertical bars, thus $|s|$ is the length of $s$ and so on. If we insert $t$ into $s$ at position $k$, where $0 \\leq k \\leq |s|$, the result is a new string consisting of the first $k$ characters of $s$, followed by the entirety of $t$, and finally followed by the remaining $|s| - k$ characters of $s$. We would like to select $k$ so that the resulting new string will contain the largest possible number of occurrences of $p$ as a substring.\n\nThus, for example, inserting $t = \\text{aba}$ into $s = \\text{ab}$ at position $k = 0$ results in the string $\\text{abaab}$; at $k = 1$, in the string $\\text{aabab}$; and at $k = 2$, in the string $\\text{ababa}$. If we are interested in occurrences of $p = \\text{aba}$, then the best position to insert $t$ into $s$ is $k = 2$, where we get two occurrences: $\\text{ababa}$ and $\\text{ababa}$ (as this example shows, occurrences of $p$ are allowed to overlap). If, on the other hand, we were interested in occurrences of $p = \\text{aa}$, then the best choices of $k$ would be $k = 0$ and $k = 1$, which result in one occurrence of $p$, whereas $k = 2$ results in 0 occurrences of $p$.\n", "inputFormat": "The first line contains the string $s$, the second line the string $t$, and the third line the string $p$.", "outputFormat": "Output one line containing the following four integers, separated by spaces:\n\n1. The maximum number of occurrences of $p$ we can get after inserting $t$ into $s$ at position $k$, if we choose the position $k$ wisely.\n2. The number of different $k$'s (from the range $0, 1, \\ldots, |s|$) where this maximum number of occurrences of $p$ is attained.\n3. The minimum value of $k$ where the maximum number of occurrences of $p$ is attained.\n4. The maximum value of $k$ where the maximum number of occurrences of $p$ is attained.", "hint": "### Comment\n\nThe first of these three examples is the one discussed earlier in the problem statement\n\n### Input limits\n\n- $1 \\leq |s| \\leq 10^5$\n- $1 \\leq |t| \\leq 10^5$\n- $1 \\leq |p| \\leq 10^5$\n- All the strings consist only of lowercase letters of the English alphabet.", "locale": "en"}, "zh-CN": {"title": "[CERC 2022] Insertions", "background": null, "description": "给定三个字符串 $s$、$t$ 和 $p$。我们用竖线表示字符串的长度，例如 $|s|$ 表示 $s$ 的长度，依此类推。如果我们将 $t$ 插入到 $s$ 的第 $k$ 个位置（$0 \\leq k \\leq |s|$），则结果是一个新字符串：它由 $s$ 的前 $k$ 个字符、接着整个 $t$，最后是 $s$ 剩下的 $|s| - k$ 个字符组成。我们希望选择一个 $k$，使得新字符串中作为子串的 $p$ 出现次数尽可能多。\n\n例如，将 $t = \\text{aba}$ 插入 $s = \\text{ab}$ 的位置 $k = 0$，得到字符串 $\\text{abaab}$；插入位置 $k = 1$，得到字符串 $\\text{aabab}$；插入位置 $k = 2$，得到字符串 $\\text{ababa}$。如果我们关注 $p = \\text{aba}$ 的出现次数，最佳插入位置是 $k = 2$，此时有两次出现：$\\text{ababa}$ 和 $\\text{ababa}$（如本例所示，$p$ 的出现可以重叠）。如果我们关注 $p = \\text{aa}$，则最佳插入位置是 $k = 0$ 或 $k = 1$，此时 $p$ 出现一次，而 $k = 2$ 时 $p$ 出现 $0$ 次。", "inputFormat": "第一行输入字符串 $s$，第二行输入字符串 $t$，第三行输入字符串 $p$。", "outputFormat": "输出一行，包含四个用空格分隔的整数：\n\n1. 经过合理选择 $k$ 后，插入 $t$ 到 $s$ 中能得到的 $p$ 作为子串的最大出现次数。\n2. 能达到最大出现次数的不同 $k$ 的个数（$k$ 的取值范围为 $0, 1, \\ldots, |s|$）。\n3. 能达到最大出现次数的最小 $k$。\n4. 能达到最大出现次数的最大 $k$。", "hint": "### 说明\n\n前三个例子与题目描述中的示例一致。\n\n### 输入范围\n\n- $1 \\leq |s| \\leq 10^5$\n- $1 \\leq |t| \\leq 10^5$\n- $1 \\leq |p| \\leq 10^5$\n- 所有字符串均由小写英文字母组成。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13813", "type": "P", "difficulty": 6, "samples": [["2 2\n2 P1:50.1 P2:49.9\n2 P1:23.4 P2:76.6", "0.501000 0.499000\n0.234000 0.766000"], ["2 2\n2 P1:50.0 P2:50.0\n3 P1:20.0 P2:30.0 C1:50.0", "0.500000 0.500000\n0.450000 0.550000"], ["2 2\n4 P1:1.0 P2:2.0 C2:49.0 C1:48.0\n4 C2:70.0 C1:25.0 P1:3.0 P2:2.0", "0.528358 0.471642\n0.540299 0.459701"], ["3 2\n5 P1:1.0 P2:2.0 C2:49.0 C1:38.0 C3:10.0\n4 C2:70.0 C1:25.0 P1:3.0 P2:2.0\n2 P1:20.0 P2:80.0", "0.373228 0.626772\n0.411024 0.588976\n0.2 0.8"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2022", "Special Judge", "Tarjan", "高斯消元", "ICPC", "CERC"], "title": "[CERC 2022] Money Laundering", "background": "", "description": "Consider a company $A$ that made a $100 \\, \\text{€}$ of profit this year. The company's owners are Ivan with $52.8\\%$ ownership share and Robi with a $47.2\\%$ ownership share. Naturally, the profits are shared proportionally to the shares with Ivan receiving $52.8 \\, \\text{€}$ and Robi $47.2 \\, \\text{€}$.\n\nThey will have to pay tax on the received profits, but would like to avoid doing so, if at all possible. Sadly, the ownership structure of their company is too simple and it's easily discoverable how much profits each of them received.\n\nFor the next year, they prepare a plan. They make a shell company $B$ and change the ownership shares. Ivan now only owns $1\\%$ of company $A$, Robi only $2\\%$, the company $B$ owns a $49\\%$ share of $A$ and $A$ owns $48\\%$ of itself. Company $B$ has a similar ownership structure: $70\\%$ ownership share belongs to $B$ itself, $25\\%$ to $A$, $3\\%$ to Ivan and $2\\%$ to Robi.\n\nLooking naively, Ivan and Robi have very small ownership shares. However, we are interested in the ownership shares of ultimate beneficial owners, the persons who will ultimately profit, which are Ivan and Robi in our case. We wish to determine their ultimate ownership shares, which turn out to be approximately equal to what they were before the introduction of $B$.\n\nUltimate ownership shares can be determined as follows: let the company $A$ have $100 \\, \\text{€}$ of profit and $B$ have $0 \\, \\text{€}$. The profits are paid out to all direct owners in proportion to their ownership share. However, since $A$ and $B$ are partial owners of themselves, they receive a part of the profit. To determine the ultimate share of the ultimate beneficial owners, we repeat the procedure – any profits that $A$ and $B$ receive are paid out again, with Ivan and Robi getting a share, as well as $A$ and $B$. This is repeated ad infinitum until (theoretically, after an infinite number of steps) all money is paid out to the ultimate beneficial owners, and the ratio of the final sums received by Ivan and Robi is by definition equal to their ultimate share of $A$.\n\nFor a given structure of companies, determine the shares of the ultimate beneficial owners. However, the companies do not form a random network of ownership, but are structured in industrial sectors. Companies within sectors may form arbitrary ownership structures, but this is not true for companies in different sectors. If companies $P$ and $Q$ belong to different sectors, it cannot happen that\n\n- $P$ would own a (potentially indirect) share of $Q$ and\n- $Q$ would own a (potentially indirect) share of $P$.\n\nOne or none of these statements could be true, but not both.", "inputFormat": "The first line contains two space-separated integers $c$ and $p$, representing the number of companies and number of persons, respectively. Then $c$ lines follow, and $i$-th of them contains the description of $i$-th company. The line contains an integer $k_i$, the number of owners, and then $k_i$ entries of the form $o_{i,j} : p_{i,j}$, where $o_{i,j}$ is the designation of the $j$-th owner (person or company) and $p_{i,j}$ is their share in percentages. The share will have exactly one decimal place.", "outputFormat": "Output the ultimate ownership shares of all persons in all companies. The $i$-th line should include shares of all persons in the $i$-th company, including persons with no share. The share is between 0 and 1. Shares in a line should be separated by a space. The answer will be considered correct if its absolute or relative error is less than $10^{-4}$.", "hint": "### Input limits\n\n- $1 \\leq c, p \\leq 10^3$\n- $1 \\leq \\sum_{i=1}^{n} k_i \\leq 10^4$\n- $o_{i,j}$ can have two forms: $\\text{Px}$ or $\\text{Cy}$, indicating that the owner is the $x$-th person or $y$-th company, respectively. It is guaranteed that $1 \\leq x \\leq p$, and $1 \\leq y \\leq c$ holds.\n- $k_i \\geq 1$\n- $0 < p_{i,j} \\leq 100$\n- $\\sum_{j=1}^{k_i} p_{i,j} = 100$\n- The identifiers $\\{o_{i,j}\\}_{j=1}^{k_i}$ are unique, i.e. each owner is listed at most once.\n- The number of companies belonging to each sector is less than 10.\n- Each company has at least one ultimate beneficial owner. For example, a scheme where $A$ would own a $100\\%$ of $B$ and $B$ a $100\\%$ of $A$ is forbidden.\n", "locale": "en", "translations": {"en": {"title": "[CERC 2022] Money Laundering", "background": "", "description": "Consider a company $A$ that made a $100 \\, \\text{€}$ of profit this year. The company's owners are Ivan with $52.8\\%$ ownership share and Robi with a $47.2\\%$ ownership share. Naturally, the profits are shared proportionally to the shares with Ivan receiving $52.8 \\, \\text{€}$ and Robi $47.2 \\, \\text{€}$.\n\nThey will have to pay tax on the received profits, but would like to avoid doing so, if at all possible. Sadly, the ownership structure of their company is too simple and it's easily discoverable how much profits each of them received.\n\nFor the next year, they prepare a plan. They make a shell company $B$ and change the ownership shares. Ivan now only owns $1\\%$ of company $A$, Robi only $2\\%$, the company $B$ owns a $49\\%$ share of $A$ and $A$ owns $48\\%$ of itself. Company $B$ has a similar ownership structure: $70\\%$ ownership share belongs to $B$ itself, $25\\%$ to $A$, $3\\%$ to Ivan and $2\\%$ to Robi.\n\nLooking naively, Ivan and Robi have very small ownership shares. However, we are interested in the ownership shares of ultimate beneficial owners, the persons who will ultimately profit, which are Ivan and Robi in our case. We wish to determine their ultimate ownership shares, which turn out to be approximately equal to what they were before the introduction of $B$.\n\nUltimate ownership shares can be determined as follows: let the company $A$ have $100 \\, \\text{€}$ of profit and $B$ have $0 \\, \\text{€}$. The profits are paid out to all direct owners in proportion to their ownership share. However, since $A$ and $B$ are partial owners of themselves, they receive a part of the profit. To determine the ultimate share of the ultimate beneficial owners, we repeat the procedure – any profits that $A$ and $B$ receive are paid out again, with Ivan and Robi getting a share, as well as $A$ and $B$. This is repeated ad infinitum until (theoretically, after an infinite number of steps) all money is paid out to the ultimate beneficial owners, and the ratio of the final sums received by Ivan and Robi is by definition equal to their ultimate share of $A$.\n\nFor a given structure of companies, determine the shares of the ultimate beneficial owners. However, the companies do not form a random network of ownership, but are structured in industrial sectors. Companies within sectors may form arbitrary ownership structures, but this is not true for companies in different sectors. If companies $P$ and $Q$ belong to different sectors, it cannot happen that\n\n- $P$ would own a (potentially indirect) share of $Q$ and\n- $Q$ would own a (potentially indirect) share of $P$.\n\nOne or none of these statements could be true, but not both.", "inputFormat": "The first line contains two space-separated integers $c$ and $p$, representing the number of companies and number of persons, respectively. Then $c$ lines follow, and $i$-th of them contains the description of $i$-th company. The line contains an integer $k_i$, the number of owners, and then $k_i$ entries of the form $o_{i,j} : p_{i,j}$, where $o_{i,j}$ is the designation of the $j$-th owner (person or company) and $p_{i,j}$ is their share in percentages. The share will have exactly one decimal place.", "outputFormat": "Output the ultimate ownership shares of all persons in all companies. The $i$-th line should include shares of all persons in the $i$-th company, including persons with no share. The share is between 0 and 1. Shares in a line should be separated by a space. The answer will be considered correct if its absolute or relative error is less than $10^{-4}$.", "hint": "### Input limits\n\n- $1 \\leq c, p \\leq 10^3$\n- $1 \\leq \\sum_{i=1}^{n} k_i \\leq 10^4$\n- $o_{i,j}$ can have two forms: $\\text{Px}$ or $\\text{Cy}$, indicating that the owner is the $x$-th person or $y$-th company, respectively. It is guaranteed that $1 \\leq x \\leq p$, and $1 \\leq y \\leq c$ holds.\n- $k_i \\geq 1$\n- $0 < p_{i,j} \\leq 100$\n- $\\sum_{j=1}^{k_i} p_{i,j} = 100$\n- The identifiers $\\{o_{i,j}\\}_{j=1}^{k_i}$ are unique, i.e. each owner is listed at most once.\n- The number of companies belonging to each sector is less than 10.\n- Each company has at least one ultimate beneficial owner. For example, a scheme where $A$ would own a $100\\%$ of $B$ and $B$ a $100\\%$ of $A$ is forbidden.\n", "locale": "en"}, "zh-CN": {"title": "[CERC 2022] Money Laundering", "background": null, "description": "考虑一家公司 $A$，今年获得了 $100\\,\\text{€}$ 的利润。公司的所有者为 Ivan（持股 $52.8\\%$）和 Robi（持股 $47.2\\%$）。自然地，利润将按持股比例分配，Ivan 获得 $52.8\\,\\text{€}$，Robi 获得 $47.2\\,\\text{€}$。\n\n他们需要为获得的利润缴纳税款，但如果可能的话，他们希望避免缴税。可惜的是，他们公司的股权结构过于简单，很容易查明每个人获得了多少利润。\n\n第二年，他们制定了一个计划。他们成立了一家空壳公司 $B$，并更改了股权结构。Ivan 现在只持有公司 $A$ 的 $1\\%$，Robi 持有 $2\\%$，公司 $B$ 持有 $A$ 的 $49\\%$，而 $A$ 自己持有 $48\\%$。公司 $B$ 的股权结构类似：$70\\%$ 属于 $B$ 自己，$25\\%$ 属于 $A$，$3\\%$ 属于 Ivan，$2\\%$ 属于 Robi。\n\n乍一看，Ivan 和 Robi 的持股比例很小。然而，我们关注的是最终受益所有人的持股比例，即最终能获益的人，在本题中是 Ivan 和 Robi。我们希望确定他们的最终持股比例，结果发现这与引入 $B$ 之前几乎相同。\n\n最终持股比例的确定方法如下：假设公司 $A$ 有 $100\\,\\text{€}$ 的利润，公司 $B$ 有 $0\\,\\text{€}$。利润按持股比例分配给所有直接股东。然而，由于 $A$ 和 $B$ 部分持有自己，它们也会获得一部分利润。为了确定最终受益所有人的最终持股比例，我们重复这一过程——$A$ 和 $B$ 获得的利润再次分配，Ivan 和 Robi 也会获得一部分，同时 $A$ 和 $B$ 也会获得一部分。如此无限循环下去，直到（理论上经过无限次分配）所有资金都分配给最终受益所有人，最终 Ivan 和 Robi 获得的总金额之比就定义为他们的最终持股比例。\n\n对于给定的公司结构，计算所有最终受益所有人的持股比例。然而，公司之间并不是任意形成股权网络，而是按照行业分组。行业内的公司可以形成任意股权结构，但不同行业的公司之间不能这样。如果公司 $P$ 和 $Q$ 属于不同的行业，则不可能出现以下两种情况同时成立：\n\n- $P$ 持有 $Q$ 的（可能是间接的）股份，并且\n- $Q$ 持有 $P$ 的（可能是间接的）股份。\n\n这两种情况中至多有一种成立，也可以都不成立。", "inputFormat": "第一行包含两个用空格分隔的整数 $c$ 和 $p$，分别表示公司数和个人数。接下来有 $c$ 行，第 $i$ 行描述第 $i$ 个公司。每行包含一个整数 $k_i$，表示股东数量，接下来有 $k_i$ 个形如 $o_{i,j} : p_{i,j}$ 的条目，其中 $o_{i,j}$ 表示第 $j$ 个股东（个人或公司），$p_{i,j}$ 表示其持股比例（百分数，精确到一位小数）。", "outputFormat": "输出所有公司中所有个人的最终持股比例。第 $i$ 行输出第 $i$ 个公司中所有个人的持股比例，包括持股为零的个人。持股比例为 $0$ 到 $1$ 之间。每行的持股比例用空格分隔。如果答案的绝对误差或相对误差小于 $10^{-4}$，则视为正确。", "hint": "### 输入范围\n\n- $1 \\leq c, p \\leq 10^3$\n- $1 \\leq \\sum_{i=1}^{n} k_i \\leq 10^4$\n- $o_{i,j}$ 有两种形式：$\\text{Px}$ 或 $\\text{Cy}$，分别表示第 $x$ 个个人或第 $y$ 个公司。保证 $1 \\leq x \\leq p$，$1 \\leq y \\leq c$。\n- $k_i \\geq 1$\n- $0 < p_{i,j} \\leq 100$\n- $\\sum_{j=1}^{k_i} p_{i,j} = 100$\n- 每个股东在同一公司中至多出现一次。\n- 每个行业的公司数量小于 $10$。\n- 每个公司至少有一个最终受益所有人。例如，$A$ 持有 $B$ 的 $100\\%$，$B$ 持有 $A$ 的 $100\\%$ 这种结构是被禁止的。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13814", "type": "P", "difficulty": 6, "samples": [["9 5\n6 1 10 9 5 -2 3 1 -1\n3 6\n1 4\n3 3\n6 1\n8 2", "4\n3\n8\nstay with parents\n0"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "2022", "凸包", "ICPC", "CERC"], "title": "[CERC 2022] Mortgage", "background": "", "description": "Andrej is a typical modern student, dreaming to buy a house one day. Since buying real property is no piece of cake, he is planning out his life and trying to figure out exactly how and when he will be able to afford one. To buy a house, he aims to take a mortgage loan that will then need to be paid back in multiple payments over the course of several months. For each of the next $n$ months of his life, he will earn the income $a_i$ that can be spent on the mortgage (other costs have already been accounted for, hence $a_i$ can be negative). He is now looking at a list of various properties and mortgage loans and is trying to figure out which of them he can afford.\n\nSuppose that he takes a mortgage that involves paying $x$ units of money over the course of $k$ months, starting in month $i$, and ending in month $i + k - 1$. Each of these months, he needs to be able to pay $x$ units of money. If he has any leftover income in month $i$, i.e. $a_i > x$, he can save the rest and use it towards some of the future payments (same for any leftover money in months $i + 1$ to $i + k - 1$). However, he cannot count on saving any money prior to month $i$, regardless of the income in those months. He will spend it all on his current rent and avocado toast.\n\nYou are given the list of Andrej's income for the next $n$ months and a list of $m$ different time intervals. The $i$-th time interval is defined by two numbers, $s_i$, and $k_i$. The mortgage loan starts on the month $s_i$ and lasts for $k_i$ months, i.e. the last payment is done on the month $s_i + k_i - 1$. For each of the time intervals, determine what the largest monthly payment that Andrej can afford is.", "inputFormat": "The first line contains two integers, $n$ and $m$, the number of months, and the number of different time intervals, respectively. The second line contains $n$ space-separated integers, $a_1, \\ldots, a_n$, Andrej's income over the next $n$ months. This is followed by $m$ lines describing different time intervals, each line containing two space-separated integers $s_i$ and $k_i$.", "outputFormat": "Print out $m$ lines, one for each time interval. Print out the largest integer amount of monthly payment that Andrej can afford to pay for the $i$-th mortgage. If the number is strictly smaller than 0, print \"stay with parents\" (without quotation marks).", "hint": "### Comment\n\nFor the first interval, a monthly payment of $4$ units is the largest Andrej can afford. For a monthly payment of $5$, he would run out of money for his final payment. Negative income on month $6$ means that Andrej cannot afford any mortgage for interval $4$, regardless of its size.\n\n### Input limits\n\n- $1 \\leq n, m \\leq 2 \\cdot 10^5$\n- $-10^9 \\leq a_i \\leq 10^9$\n- $1 \\leq s_i \\leq n; \\forall i$\n- $1 \\leq k_i$ and $s_i + k_i - 1 \\leq n; \\forall i$", "locale": "en", "translations": {"en": {"title": "[CERC 2022] Mortgage", "background": "", "description": "Andrej is a typical modern student, dreaming to buy a house one day. Since buying real property is no piece of cake, he is planning out his life and trying to figure out exactly how and when he will be able to afford one. To buy a house, he aims to take a mortgage loan that will then need to be paid back in multiple payments over the course of several months. For each of the next $n$ months of his life, he will earn the income $a_i$ that can be spent on the mortgage (other costs have already been accounted for, hence $a_i$ can be negative). He is now looking at a list of various properties and mortgage loans and is trying to figure out which of them he can afford.\n\nSuppose that he takes a mortgage that involves paying $x$ units of money over the course of $k$ months, starting in month $i$, and ending in month $i + k - 1$. Each of these months, he needs to be able to pay $x$ units of money. If he has any leftover income in month $i$, i.e. $a_i > x$, he can save the rest and use it towards some of the future payments (same for any leftover money in months $i + 1$ to $i + k - 1$). However, he cannot count on saving any money prior to month $i$, regardless of the income in those months. He will spend it all on his current rent and avocado toast.\n\nYou are given the list of Andrej's income for the next $n$ months and a list of $m$ different time intervals. The $i$-th time interval is defined by two numbers, $s_i$, and $k_i$. The mortgage loan starts on the month $s_i$ and lasts for $k_i$ months, i.e. the last payment is done on the month $s_i + k_i - 1$. For each of the time intervals, determine what the largest monthly payment that Andrej can afford is.", "inputFormat": "The first line contains two integers, $n$ and $m$, the number of months, and the number of different time intervals, respectively. The second line contains $n$ space-separated integers, $a_1, \\ldots, a_n$, Andrej's income over the next $n$ months. This is followed by $m$ lines describing different time intervals, each line containing two space-separated integers $s_i$ and $k_i$.", "outputFormat": "Print out $m$ lines, one for each time interval. Print out the largest integer amount of monthly payment that Andrej can afford to pay for the $i$-th mortgage. If the number is strictly smaller than 0, print \"stay with parents\" (without quotation marks).", "hint": "### Comment\n\nFor the first interval, a monthly payment of $4$ units is the largest Andrej can afford. For a monthly payment of $5$, he would run out of money for his final payment. Negative income on month $6$ means that Andrej cannot afford any mortgage for interval $4$, regardless of its size.\n\n### Input limits\n\n- $1 \\leq n, m \\leq 2 \\cdot 10^5$\n- $-10^9 \\leq a_i \\leq 10^9$\n- $1 \\leq s_i \\leq n; \\forall i$\n- $1 \\leq k_i$ and $s_i + k_i - 1 \\leq n; \\forall i$", "locale": "en"}, "zh-CN": {"title": "[CERC 2022] Mortgage", "background": null, "description": "Andrej 是一名典型的现代学生，梦想着有一天能买上一套房子。由于买房并非易事，他正在规划自己的人生，试图弄清楚自己究竟如何以及何时能够负担得起一套房子。为了买房，他打算申请一笔按揭贷款，然后在接下来的几个月内分期偿还。对于未来的 $n$ 个月，他每个月的可用于还贷的收入为 $a_i$（其他开销已计入，因此 $a_i$ 可能为负数）。现在，他正在查看各种房产和按揭贷款，想要弄清楚自己究竟能负担得起哪些。\n\n假设他选择了一笔按揭贷款，需要在连续的 $k$ 个月内，每个月支付 $x$ 单位的钱款，贷款从第 $i$ 个月开始，到第 $i + k - 1$ 个月结束。在这 $k$ 个月中的每一个月，他都必须能够支付 $x$ 单位的钱。如果在第 $i$ 个月他的收入有剩余，即 $a_i > x$，他可以将剩余的钱存起来，用于未来几个月的还款（第 $i + 1$ 到 $i + k - 1$ 个月同理）。然而，他不能指望在第 $i$ 个月之前存下任何钱，无论那些月份的收入是多少，他都会全部花在当前的房租和牛油果吐司上。\n\n你将获得 Andrej 未来 $n$ 个月的收入列表，以及 $m$ 个不同的时间区间。第 $i$ 个时间区间由两个数字 $s_i$ 和 $k_i$ 定义。按揭贷款从第 $s_i$ 个月开始，持续 $k_i$ 个月，即最后一次还款在第 $s_i + k_i - 1$ 个月。对于每个时间区间，求出 Andrej 能够负担的最大每月还款额。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$，分别表示月份数和时间区间数。第二行包含 $n$ 个用空格分隔的整数 $a_1, \\ldots, a_n$，表示 Andrej 未来 $n$ 个月的收入。接下来 $m$ 行，每行包含两个用空格分隔的整数 $s_i$ 和 $k_i$，描述一个时间区间。", "outputFormat": "输出 $m$ 行，每行对应一个时间区间。对于第 $i$ 个按揭，输出 Andrej 能够负担的最大整数每月还款额。如果该数严格小于 $0$，则输出 “stay with parents”（不带引号）。", "hint": "### 说明\n\n对于第一个区间，Andrej 能够负担的最大每月还款额为 $4$。如果每月还款为 $5$，他将在最后一次还款时资金不足。第 $6$ 个月的负收入意味着无论贷款额度如何，Andrej 都无法负担第 $4$ 个区间的任何按揭。\n\n### 输入范围\n\n- $1 \\leq n, m \\leq 2 \\times 10^5$\n- $-10^9 \\leq a_i \\leq 10^9$\n- $1 \\leq s_i \\leq n; \\forall i$\n- $1 \\leq k_i$ 且 $s_i + k_i - 1 \\leq n; \\forall i$\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13815", "type": "P", "difficulty": 4, "samples": [["2 3 8", "6"], ["2 3 11", "9"], ["3 7 100", "48"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "2022", "ICPC", "CERC"], "title": "[CERC 2022] Skills in Pills", "background": "", "description": "An unnamed protagonist of this task received amazing e-mail offers for wondrous pills that will enhance their cognitive and all other sorts of abilities. After carefully analysing all offers and side effects, he has decided that he will order 2 types of pills, let's call them $A$ and $B$. He needs to take pill $A$ every $k$ days and pill $B$ every $j$ days. He will follow this meticulously over the next $n$ days.\n\nMore formally, in the next $n$ days, there should be no $k$ consecutive days where he does not take pill $A$ and no $j$ consecutive days where pill $B$ is not taken. However, there is a twist – the two pills are highly potent and must not be taken on the same day, lest horrible side effects should happen. Given this constraint, what is the smallest number of pills that he needs to take to meet these requirements?", "inputFormat": "You are given three space-separated integers, $k$, $j$, and $n$.", "outputFormat": "Print one number – the minimum number of pills that need to be taken. It is easy to prove that a solution always exists for the given constraints.", "hint": "### Comment\n\nIn the first case, we can take pill $A$ on days $2$, $4$, $5$, and $7$, and pill $B$ on days $3$ and $6$, giving the sequence $\\text{.ABAABA}$. In the second case, the best approach is to take pills in sequence $\\text{.ABAABAABA}$, which requires taking $9$ pills.\n\n### Input limits\n\n- $2 \\leq n \\leq 10^6$\n- $2 \\leq k, j \\leq n$", "locale": "en", "translations": {"en": {"title": "[CERC 2022] Skills in Pills", "background": "", "description": "An unnamed protagonist of this task received amazing e-mail offers for wondrous pills that will enhance their cognitive and all other sorts of abilities. After carefully analysing all offers and side effects, he has decided that he will order 2 types of pills, let's call them $A$ and $B$. He needs to take pill $A$ every $k$ days and pill $B$ every $j$ days. He will follow this meticulously over the next $n$ days.\n\nMore formally, in the next $n$ days, there should be no $k$ consecutive days where he does not take pill $A$ and no $j$ consecutive days where pill $B$ is not taken. However, there is a twist – the two pills are highly potent and must not be taken on the same day, lest horrible side effects should happen. Given this constraint, what is the smallest number of pills that he needs to take to meet these requirements?", "inputFormat": "You are given three space-separated integers, $k$, $j$, and $n$.", "outputFormat": "Print one number – the minimum number of pills that need to be taken. It is easy to prove that a solution always exists for the given constraints.", "hint": "### Comment\n\nIn the first case, we can take pill $A$ on days $2$, $4$, $5$, and $7$, and pill $B$ on days $3$ and $6$, giving the sequence $\\text{.ABAABA}$. In the second case, the best approach is to take pills in sequence $\\text{.ABAABAABA}$, which requires taking $9$ pills.\n\n### Input limits\n\n- $2 \\leq n \\leq 10^6$\n- $2 \\leq k, j \\leq n$", "locale": "en"}, "zh-CN": {"title": "[CERC 2022] Skills in Pills", "background": null, "description": "本题的主角收到了神奇药丸的邮件推销，这些药丸据说能极大提升他的认知和各种能力。在仔细分析了所有的优惠和副作用后，他决定只订购两种药丸，分别称为 $A$ 和 $B$。他需要每隔 $k$ 天服用一次药丸 $A$，每隔 $j$ 天服用一次药丸 $B$。在接下来的 $n$ 天里，他会严格遵守这个计划。\n\n更正式地说，在接下来的 $n$ 天中，不能有连续 $k$ 天没有服用药丸 $A$，也不能有连续 $j$ 天没有服用药丸 $B$。然而，还有一个限制——这两种药丸药效极强，绝不能在同一天服用，否则会产生严重的副作用。给定这些限制，问他最少需要服用多少颗药丸才能满足要求？", "inputFormat": "输入包含三个用空格分隔的整数，$k$、$j$ 和 $n$。", "outputFormat": "输出一个整数，表示满足要求所需服用的最少药丸数。可以证明，对于给定的限制条件，总是存在解。", "hint": "### 说明\n\n在第一个样例中，可以在第 $2$、$4$、$5$ 和 $7$ 天服用药丸 $A$，在第 $3$ 和 $6$ 天服用药丸 $B$，得到的序列为 $\\text{.ABAABA}$。在第二个样例中，最优方案是序列 $\\text{.ABAABAABA}$，共需要服用 $9$ 颗药丸。\n\n### 输入范围\n\n- $2 \\leq n \\leq 10^6$\n- $2 \\leq k, j \\leq n$\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
