{"pid": "P1521", "type": "P", "difficulty": 3, "samples": [["5 3", "15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索"], "title": "求逆序对", "background": "", "description": "我们说$(i,j)$ 是 $a_1,a_2,\\cdots,a_N$ 的一个逆序对，当且仅当 $i<j$ 且 $a_i>a_j$。例如 $[2,4,1,3,5]$ 的逆序对有 $3$ 个，分别为 $(1,3),(2, 3), (2, 4)$。现在已知 $N$ 和 $K$，求 $1,2,3,\\cdots,N$ 的所有特定排列，使得这些排列的逆序对的数量恰好为 $K$。输出这些特定排列的数量。\n\n例如 $N=5$，$K=3$ 的时候，满足条件的排列有 $15$ 个，它们是：\n\n\n- $[1, 2, 5, 4, 3]$；    \n- $[1, 3, 4, 5, 2]$；   \n- $[1, 3, 5, 2, 4]$；   \n- $[1, 4, 2, 5, 3]$；   \n- $[1, 4, 3, 2, 5]$；   \n- $[1, 5, 2, 3, 4]$；   \n- $[2, 1, 4, 5, 3]$；   \n- $[2, 1, 5, 3, 4]$；   \n- $[2, 3, 1, 5, 4]$；   \n- $[2, 3, 4, 1, 5]$；\n- $[2, 4, 1, 3, 5]$；    \n- $[3, 1, 2, 5, 4]$；   \n- $[3, 1, 4, 2, 5]$；   \n- $[3, 2, 1, 4, 5]$；   \n- $[4, 1, 2, 3, 5]$。\n", "inputFormat": "输入共第一行，两个整数 $N$ 和 $K$。", "outputFormat": "将 $1\\cdots N$ 的逆序对数量为 $K$ 的特定排列的数量输出。为了避免高精度计算，请将结果对 $10000$ 取模后再输出。", "hint": "### 数据范围及约定\n\n对于全部数据，保证 $N \\le 100$，$K \\le N\\times (N-1)/2$。", "locale": "zh-CN", "translations": {"en": {"title": "Count Inversions", "background": "", "description": "We call $(i, j)$ an inversion of $a_1, a_2, \\cdots, a_N$ if and only if $i < j$ and $a_i > a_j$. For example, $[2, 4, 1, 3, 5]$ has 3 inversions: $(1, 3), (2, 3), (2, 4)$. Now given $N$ and $K$, find the number of permutations of $1, 2, 3, \\cdots, N$ whose number of inversions is exactly $K$. Output that count.\n\nFor example, when $N = 5$, $K = 3$, there are 15 valid permutations. They are:\n\n- [1, 2, 5, 4, 3].\n- [1, 3, 4, 5, 2].\n- [1, 3, 5, 2, 4].\n- [1, 4, 2, 5, 3].\n- [1, 4, 3, 2, 5].\n- [1, 5, 2, 3, 4].\n- [2, 1, 4, 5, 3].\n- [2, 1, 5, 3, 4].\n- [2, 3, 1, 5, 4].\n- [2, 3, 4, 1, 5].\n- [2, 4, 1, 3, 5].\n- [3, 1, 2, 5, 4].\n- [3, 1, 4, 2, 5].\n- [3, 2, 1, 4, 5].\n- [4, 1, 2, 3, 5].", "inputFormat": "The first line contains two integers $N$ and $K$.", "outputFormat": "Output the number of permutations of $1 \\cdots N$ whose number of inversions is $K$. To avoid big integer arithmetic, output the result modulo $10000$.", "hint": "Constraints\n\nFor all testdata, it is guaranteed that $N \\le 100$, $K \\le N \\times (N - 1) / 2$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "求逆序对", "background": "", "description": "我们说$(i,j)$ 是 $a_1,a_2,\\cdots,a_N$ 的一个逆序对，当且仅当 $i<j$ 且 $a_i>a_j$。例如 $[2,4,1,3,5]$ 的逆序对有 $3$ 个，分别为 $(1,3),(2, 3), (2, 4)$。现在已知 $N$ 和 $K$，求 $1,2,3,\\cdots,N$ 的所有特定排列，使得这些排列的逆序对的数量恰好为 $K$。输出这些特定排列的数量。\n\n例如 $N=5$，$K=3$ 的时候，满足条件的排列有 $15$ 个，它们是：\n\n\n- $[1, 2, 5, 4, 3]$；    \n- $[1, 3, 4, 5, 2]$；   \n- $[1, 3, 5, 2, 4]$；   \n- $[1, 4, 2, 5, 3]$；   \n- $[1, 4, 3, 2, 5]$；   \n- $[1, 5, 2, 3, 4]$；   \n- $[2, 1, 4, 5, 3]$；   \n- $[2, 1, 5, 3, 4]$；   \n- $[2, 3, 1, 5, 4]$；   \n- $[2, 3, 4, 1, 5]$；\n- $[2, 4, 1, 3, 5]$；    \n- $[3, 1, 2, 5, 4]$；   \n- $[3, 1, 4, 2, 5]$；   \n- $[3, 2, 1, 4, 5]$；   \n- $[4, 1, 2, 3, 5]$。\n", "inputFormat": "输入共第一行，两个整数 $N$ 和 $K$。", "outputFormat": "将 $1\\cdots N$ 的逆序对数量为 $K$ 的特定排列的数量输出。为了避免高精度计算，请将结果对 $10000$ 取模后再输出。", "hint": "### 数据范围及约定\n\n对于全部数据，保证 $N \\le 100$，$K \\le N\\times (N-1)/2$。", "locale": "zh-CN"}}}
{"pid": "P1522", "type": "P", "difficulty": 4, "samples": [["8\n10 10\n15 10\n20 10\n15 15\n20 15\n30 15\n25 10\n30 10\n01000000\n10111000\n01001000\n01001000\n01110000\n00000010\n00000101\n00000010", "22.071068\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["图论", "USACO", "枚举", "最短路"], "title": "[USACO2.4] 牛的旅行 Cow Tours", "background": "", "description": "Farmer John 的农场里有很多 **牧区**。有的路径连接一些特定的牧区。**一片所有连通的牧区** 称为一个 **牧场**。但是就目前而言，你能看到至少有两个牧区通过任何路径都不连通。这样，Farmer John 就有 **多个** 牧场了。\n\nJohn 想在牧场里添加 **恰好** 一条路径。对这条路径有以下限制：\n\n一个牧场的 **直径** 就是牧场中 **最远** 的两个牧区的距离（本题中所提到的所有距离指的都是 **最短的距离**）。考虑如下的有 5 个牧区的牧场，牧区用 `*` 表示，路径用直线表示。每一个牧区都有自己的坐标：\n\n```plain\n                (15,15) (20,15)\n                 D       E\n                 *-------*\n                 |     _/|\n                 |   _/  |\n                 | _/    |\n                 |/      |\n        *--------*-------*\n        A        B       C\n     (10,10)  (15,10) (20,10)\n```\n这个牧场的直径大约是 $12.07106$，最远的两个牧区是 A 和 E，它们之间的最短路径是 $A \\to B \\to E$。\n\n这里是 John 的另一个牧场：\n\n```plain\n                         *F(30,15)\n                        / \n                      _/  \n                    _/    \n                   /      \n                  *------* \n                  G      H\n                  (25,10)   (30,10)\n```\n\n在这个例子中，他刚好有这两个牧场。John 将会在这两个牧场中各选一个牧区（即从 $\\{A,B,C,D,E\\}$ 中选择一个牧区，从 $\\{F,G,H\\}$ 中选择一个牧区），然后用一条路径将它们连起来，使得连通后这个新的更大的牧场的直径尽可能小。\n\n注意，如果两条路径中途相交，我们不认为它们是连通的。只有两条路径在同一个牧区相交，我们才认为它们是连通的。\n\n输入文件包括牧区、它们各自的坐标，还有一个如下的对称邻接矩阵：\n\n```plain\n　 A  B  C  D  E  F  G  H \nA  0  1  0  0  0  0  0  0\nB  1  0  1  1  1  0  0  0\nC  0  1  0  0  1  0  0  0\nD  0  1  0  0  1  0  0  0\nE  0  1  1  1  0  0  0  0\nF  0  0  0  0  0  0  1  0\nG  0  0  0  0  0  1  0  1\nH  0  0  0  0  0  0  1  0\n```\n\n其他邻接表中可能直接使用行列而不使用字母来表示每一个牧区。输入数据中不包括牧区的名字。\n\n输入文件 **至少** 包括两个不连通的牧区。\n\n请编程找出一条连接属于两个 **不同牧场** 的牧区的路径，使得连上这条路径后，这个更大的新牧场的直径尽可能小。输出在所有合法的连接方案中，新牧场直径的最小值。", "inputFormat": "第一行一个整数 $N$（$1 \\leq N \\leq 150$），表示牧区数。\n\n接下来 $N$ 行，每行两个整数 $X,Y$（$0 \\leq X ,Y \\leq 10^5$），表示 $N$ 个牧区的坐标。注意每个牧区的坐标都是不一样的。\n\n接下来 $N$ 行，每行 $N$ 个数字，代表邻接矩阵 $M$。第 $i$ 行第 $j$ 列的数字为 $1$，表示 $i$ 号牧区和 $j$ 号牧区之间存在一条道路直接相连；第 $i$ 行第 $j$ 列的数字为 $0$，表示 $i$ 号牧区和 $j$ 号牧区之间不存在直接相连的道路。\n\n保证 $M_{i,j} = M_{j,i}$。", "outputFormat": "只有一行，包括一个实数，表示所求直径。数字保留六位小数。\n\n只需要打到小数点后六位即可，不要做任何特别的四舍五入处理。\n", "hint": "样例对应题目描述中的情况。\n\n最优解是连接 C 牧区和 G 牧区，连接后图上只有一个牧场。这个牧场的直径为 $A \\to B \\to C \\to G \\to F$，长度约为 $22.071068$。可以证明不存在更优的方案。\n\nUSACO 2.4\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO2.4] Cow Tours", "background": "", "description": "There are many pastures on Farmer John's farm. Some paths connect certain pairs of pastures. A set of all mutually connected pastures is called a field. However, at present you can see that at least two pastures are not connected by any path. Thus, Farmer John has multiple fields.\n\nJohn wants to add exactly one path. The path is subject to the following:\n\nThe diameter of a field is the distance between the two farthest pastures in the field (all distances in this problem refer to shortest-path distances). Consider the following field with 5 pastures, where pastures are marked by `*` and paths are straight segments. Each pasture has its own coordinates:\n\n```plain\n                (15,15) (20,15)\n                 D       E\n                 *-------*\n                 |     _/|\n                 |   _/  |\n                 | _/    |\n                 |/      |\n        *--------*-------*\n        A        B       C\n     (10,10)  (15,10) (20,10)\n```\nThe diameter of this field is approximately $12.07106$, and the farthest two pastures are A and E, whose shortest path is $A \\to B \\to E$.\n\nHere is John's other field:\n\n```plain\n                         *F(30,15)\n                        / \n                      _/  \n                    _/    \n                   /      \n                  *------* \n                  G      H\n                  (25,10)   (30,10)\n```\n\nIn this example, he has exactly these two fields. John will choose one pasture from $\\{A,B,C,D,E\\}$ and one pasture from $\\{F,G,H\\}$, and then connect them with a path so that the diameter of the new, larger field is as small as possible.\n\nNote that if two paths cross in the middle, we do not consider them connected. They are considered connected only if two paths meet at the same pasture.\n\nThe input file includes the pastures, their coordinates, and a symmetric adjacency matrix like the following:\n\n```plain\n　 A  B  C  D  E  F  G  H \nA  0  1  0  0  0  0  0  0\nB  1  0  1  1  1  0  0  0\nC  0  1  0  0  1  0  0  0\nD  0  1  0  0  1  0  0  0\nE  0  1  1  1  0  0  0  0\nF  0  0  0  0  0  0  1  0\nG  0  0  0  0  0  1  0  1\nH  0  0  0  0  0  0  1  0\n```\n\nOther adjacency matrices may use row and column indices instead of letters to denote each pasture. The input data does not include pasture names.\n\nThe input file contains at least two pastures that are not connected.\n\nWrite a program to add a single path connecting two pastures from two different fields so that, after adding this path, the diameter of the resulting field is minimized. Output the minimal possible diameter among all valid ways to connect the fields.", "inputFormat": "The first line contains an integer $N$ ($1 \\leq N \\leq 150$), the number of pastures.\n\nThe next $N$ lines each contain two integers $X,Y$ ($0 \\leq X ,Y \\leq 10^5$), the coordinates of the $N$ pastures. Note that each pasture has distinct coordinates.\n\nThe next $N$ lines each contain $N$ numbers representing the adjacency matrix $M$. The number in row $i$, column $j$ is $1$ if pasture $i$ and pasture $j$ are directly connected by a path, and $0$ otherwise.\n\nIt is guaranteed that $M_{i,j} = M_{j,i}$.", "outputFormat": "Output a single line containing a real number, which is the required diameter. Keep six digits after the decimal point.\n\nJust print to six decimal places; do not perform any special rounding.", "hint": "The sample corresponds to the situation described in the statement.\n\nThe optimal solution is to connect pasture C and pasture G. After connecting, there is only one field in the graph. The diameter of this field is $A \\to B \\to C \\to G \\to F$, with length approximately $22.071068$. It can be proven that there is no better plan.\n\nUSACO 2.4\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO2.4] 牛的旅行 Cow Tours", "background": "", "description": "Farmer John 的农场里有很多 **牧区**。有的路径连接一些特定的牧区。**一片所有连通的牧区** 称为一个 **牧场**。但是就目前而言，你能看到至少有两个牧区通过任何路径都不连通。这样，Farmer John 就有 **多个** 牧场了。\n\nJohn 想在牧场里添加 **恰好** 一条路径。对这条路径有以下限制：\n\n一个牧场的 **直径** 就是牧场中 **最远** 的两个牧区的距离（本题中所提到的所有距离指的都是 **最短的距离**）。考虑如下的有 5 个牧区的牧场，牧区用 `*` 表示，路径用直线表示。每一个牧区都有自己的坐标：\n\n```plain\n                (15,15) (20,15)\n                 D       E\n                 *-------*\n                 |     _/|\n                 |   _/  |\n                 | _/    |\n                 |/      |\n        *--------*-------*\n        A        B       C\n     (10,10)  (15,10) (20,10)\n```\n这个牧场的直径大约是 $12.07106$，最远的两个牧区是 A 和 E，它们之间的最短路径是 $A \\to B \\to E$。\n\n这里是 John 的另一个牧场：\n\n```plain\n                         *F(30,15)\n                        / \n                      _/  \n                    _/    \n                   /      \n                  *------* \n                  G      H\n                  (25,10)   (30,10)\n```\n\n在这个例子中，他刚好有这两个牧场。John 将会在这两个牧场中各选一个牧区（即从 $\\{A,B,C,D,E\\}$ 中选择一个牧区，从 $\\{F,G,H\\}$ 中选择一个牧区），然后用一条路径将它们连起来，使得连通后这个新的更大的牧场的直径尽可能小。\n\n注意，如果两条路径中途相交，我们不认为它们是连通的。只有两条路径在同一个牧区相交，我们才认为它们是连通的。\n\n输入文件包括牧区、它们各自的坐标，还有一个如下的对称邻接矩阵：\n\n```plain\n　 A  B  C  D  E  F  G  H \nA  0  1  0  0  0  0  0  0\nB  1  0  1  1  1  0  0  0\nC  0  1  0  0  1  0  0  0\nD  0  1  0  0  1  0  0  0\nE  0  1  1  1  0  0  0  0\nF  0  0  0  0  0  0  1  0\nG  0  0  0  0  0  1  0  1\nH  0  0  0  0  0  0  1  0\n```\n\n其他邻接表中可能直接使用行列而不使用字母来表示每一个牧区。输入数据中不包括牧区的名字。\n\n输入文件 **至少** 包括两个不连通的牧区。\n\n请编程找出一条连接属于两个 **不同牧场** 的牧区的路径，使得连上这条路径后，这个更大的新牧场的直径尽可能小。输出在所有合法的连接方案中，新牧场直径的最小值。", "inputFormat": "第一行一个整数 $N$（$1 \\leq N \\leq 150$），表示牧区数。\n\n接下来 $N$ 行，每行两个整数 $X,Y$（$0 \\leq X ,Y \\leq 10^5$），表示 $N$ 个牧区的坐标。注意每个牧区的坐标都是不一样的。\n\n接下来 $N$ 行，每行 $N$ 个数字，代表邻接矩阵 $M$。第 $i$ 行第 $j$ 列的数字为 $1$，表示 $i$ 号牧区和 $j$ 号牧区之间存在一条道路直接相连；第 $i$ 行第 $j$ 列的数字为 $0$，表示 $i$ 号牧区和 $j$ 号牧区之间不存在直接相连的道路。\n\n保证 $M_{i,j} = M_{j,i}$。", "outputFormat": "只有一行，包括一个实数，表示所求直径。数字保留六位小数。\n\n只需要打到小数点后六位即可，不要做任何特别的四舍五入处理。\n", "hint": "样例对应题目描述中的情况。\n\n最优解是连接 C 牧区和 G 牧区，连接后图上只有一个牧场。这个牧场的直径为 $A \\to B \\to C \\to G \\to F$，长度约为 $22.071068$。可以证明不存在更优的方案。\n\nUSACO 2.4\n", "locale": "zh-CN"}}}
{"pid": "P1523", "type": "P", "difficulty": 4, "samples": [["7\r\n0 6\r\n1 0\r\n2 3\r\n5 4\r\n6 1\r\n7 5\r\n8 2\r\n", "25.58\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP"], "title": "旅行商简化版", "background": "欧几里德旅行商(Euclidean Traveling Salesman)问题也就是货郎担问题一直是困扰全世界数学家、计算机学家的著名问题。现有的算法都没有办法在确定型机器上在多项式时间内求出最优解，但是有办法在多项式时间内求出一个较优解。\n\n\n为了简化问题，而且保证能在多项式时间内求出最优解，J.L.Bentley 提出了一种叫做 bitonic tour 的哈密尔顿环游。它的要求是任意两点 $(a,b)$ 之间的相互到达的代价 $\\mathrm{dist}(a,b)=\\mathrm{dist}(b, a)$ 且任意两点之间可以相互到达，并且环游的路线只能是从最西端单向到最东端，再单项返回最西端，并且是一个哈密尔顿回路。\n", "description": "本题为著名的 NPC 难题的简化版本。\n\n现在笛卡尔平面上有 $n\\ (n \\le 1000)$ 个点，每个点的坐标为 $(x,y)$，（$-2^{31}<x,y<2^{31}$，且为整数），任意两点之间相互到达的代价为这两点的欧几里德距离，现要你编程求出最短 bitonic tour。\n", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n$ 行，每行两个整数 $x,y$，表示某个点的坐标。\n\n输入中保证没有重复的两点，保证最西端和最东端都只有一个点。", "outputFormat": "一行，即最短回路的长度，保留 $2$ 位小数。\n", "hint": "### 题目来源\n\n《算法导论（第二版）》 15-1", "locale": "zh-CN", "translations": {"en": {"title": "Traveling Salesman, Simplified", "background": "The Euclidean Traveling Salesman problem, also known as the \"货郎担\" problem, has long challenged mathematicians and computer scientists around the world. No existing algorithm can compute an optimal solution in polynomial time on a deterministic machine, but there are algorithms that can compute a near-optimal solution in polynomial time.\n\nTo simplify the problem while ensuring that an optimal solution can be found in polynomial time, J. L. Bentley proposed a Hamiltonian tour called the bitonic tour. Its requirements are: for any two points $(a, b)$, the travel cost is symmetric, i.e., $\\mathrm{dist}(a, b) = \\mathrm{dist}(b, a)$, and every pair of points is mutually reachable. The tour must go monotonically from the westernmost point to the easternmost point, then monotonically return to the westernmost point, forming a Hamiltonian cycle.", "description": "This problem is a simplified version of the famous NP-complete problem.\n\nThere are $n\\ (n \\le 1000)$ points on the Cartesian plane. Each point has coordinates $(x, y)$, where $-2^{31} < x, y < 2^{31}$ and both are integers. The cost to travel between any two points is the Euclidean distance between them. Your task is to compute the shortest bitonic tour.", "inputFormat": "The first line contains an integer $n$.\n\nEach of the next $n$ lines contains two integers $x, y$, representing the coordinates of a point.\n\nIt is guaranteed that there are no duplicate points, and that both the westernmost point and the easternmost point are unique.", "outputFormat": "Output one line: the length of the shortest tour, with $2$ decimal places.", "hint": "Source: Introduction to Algorithms (Second Edition), 15-1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "旅行商简化版", "background": "欧几里德旅行商(Euclidean Traveling Salesman)问题也就是货郎担问题一直是困扰全世界数学家、计算机学家的著名问题。现有的算法都没有办法在确定型机器上在多项式时间内求出最优解，但是有办法在多项式时间内求出一个较优解。\n\n\n为了简化问题，而且保证能在多项式时间内求出最优解，J.L.Bentley 提出了一种叫做 bitonic tour 的哈密尔顿环游。它的要求是任意两点 $(a,b)$ 之间的相互到达的代价 $\\mathrm{dist}(a,b)=\\mathrm{dist}(b, a)$ 且任意两点之间可以相互到达，并且环游的路线只能是从最西端单向到最东端，再单项返回最西端，并且是一个哈密尔顿回路。\n", "description": "本题为著名的 NPC 难题的简化版本。\n\n现在笛卡尔平面上有 $n\\ (n \\le 1000)$ 个点，每个点的坐标为 $(x,y)$，（$-2^{31}<x,y<2^{31}$，且为整数），任意两点之间相互到达的代价为这两点的欧几里德距离，现要你编程求出最短 bitonic tour。\n", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n$ 行，每行两个整数 $x,y$，表示某个点的坐标。\n\n输入中保证没有重复的两点，保证最西端和最东端都只有一个点。", "outputFormat": "一行，即最短回路的长度，保留 $2$ 位小数。\n", "hint": "### 题目来源\n\n《算法导论（第二版）》 15-1", "locale": "zh-CN"}}}
{"pid": "P1524", "type": "P", "difficulty": 5, "samples": [["4 5\r\n.....\r\n.\\...\r\n..\\..\r\n.....\r\n.....\r\n....\\ \r\n.\\X..\r\n.....\r\n", "4\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论"], "title": "十字绣", "background": "考古学家发现了一块布，布上做有针线活，叫做“十字绣”，即交替地在布的两面穿线。\n", "description": "布是一个 $n\\times m$ 的网格，线只能在网格的顶点处才能从布的一面穿到另一面。每一段线都覆盖一个单位网格的两条对角线之一，而在绣的过程中，一针中连续的两段线必须分处布的两面。给出布两面的图案（实线代表该处有线，虚线代表背面有线），问最少需要几针才能绣出来？一针是指针不离开布的一次绣花过程。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vftfilbf.png)\n", "inputFormat": "第一行两个数 $N$ 和 $M(1 \\le N,M \\le 200)$。\n\n接下来 $N$ 行每行 $M$ 个数描述正面。\n\n再接下来 $N$ 行每行 $M$ 个数描述反面。\n\n每个格子的表示如下：\n\n- $\\verb!.!$ 表示空格；\n- $\\verb!/!$ 表示从右上角连到左下角的线；\n- $\\verb!\\!$ 表示从左上角连到右下角的线；\n- $\\verb!X!$ 表示两条对角线交叉。", "outputFormat": "一个数，最少要用的针数。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Cross-Stitch", "background": "Archaeologists discovered a piece of cloth with needlework called \"cross-stitch,\" where the thread alternates between the two sides of the cloth.", "description": "The cloth is an $n \\times m$ grid. The thread can pass from one side of the cloth to the other only at the grid vertices. Each segment of thread covers one of the two diagonals of a unit cell, and during stitching, two consecutive segments within a single stitch must lie on opposite sides of the cloth. Given the patterns on both sides of the cloth (solid lines indicate a thread on this side, dashed lines indicate a thread on the opposite side), determine the minimum number of stitches needed to complete the embroidery. A stitch is a single embroidery process during which the needle does not leave the fabric.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vftfilbf.png)", "inputFormat": "The first line contains two numbers $N$ and $M$ ($1 \\le N, M \\le 200$).\n\nThe next $N$ lines each contain $M$ characters describing the front side.\n\nThe following $N$ lines each contain $M$ characters describing the back side.\n\nEach cell is represented as follows:\n- $\\verb!.!$ means empty.\n- $\\verb!/!$ means a thread from the top-right corner to the bottom-left corner.\n- $\\verb!\\!$ means a thread from the top-left corner to the bottom-right corner.\n- $\\verb!X!$ means the two diagonals cross.", "outputFormat": "Output a single integer, the minimum number of stitches required.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "十字绣", "background": "考古学家发现了一块布，布上做有针线活，叫做“十字绣”，即交替地在布的两面穿线。\n", "description": "布是一个 $n\\times m$ 的网格，线只能在网格的顶点处才能从布的一面穿到另一面。每一段线都覆盖一个单位网格的两条对角线之一，而在绣的过程中，一针中连续的两段线必须分处布的两面。给出布两面的图案（实线代表该处有线，虚线代表背面有线），问最少需要几针才能绣出来？一针是指针不离开布的一次绣花过程。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vftfilbf.png)\n", "inputFormat": "第一行两个数 $N$ 和 $M(1 \\le N,M \\le 200)$。\n\n接下来 $N$ 行每行 $M$ 个数描述正面。\n\n再接下来 $N$ 行每行 $M$ 个数描述反面。\n\n每个格子的表示如下：\n\n- $\\verb!.!$ 表示空格；\n- $\\verb!/!$ 表示从右上角连到左下角的线；\n- $\\verb!\\!$ 表示从左上角连到右下角的线；\n- $\\verb!X!$ 表示两条对角线交叉。", "outputFormat": "一个数，最少要用的针数。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1525", "type": "P", "difficulty": 4, "samples": [["4 6\n1 4 2534\n2 3 3512\n1 2 28351\n1 3 6618\n2 4 1805\n3 4 12884", "3512"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "贪心", "2010", "二分", "并查集", "NOIP 提高组", "排序", "二分图"], "title": "[NOIP 2010 提高组] 关押罪犯", "background": "NOIP2010 提高组 T3", "description": "S 城现有两座监狱，一共关押着 $N$ 名罪犯，编号分别为 $1\\sim N$。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为 $c$ 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为 $c$ 的冲突事件。\n\n每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到 S 城 Z 市长那里。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。\n\n在详细考察了 $N$ 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。\n\n那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？", "inputFormat": "每行中两个数之间用一个空格隔开。第一行为两个正整数 $N,M$，分别表示罪犯的数目以及存在仇恨的罪犯对数。接下来的 $M$ 行每行为三个正整数 $a_j,b_j,c_j$，表示 $a_j$ 号和 $b_j$ 号罪犯之间存在仇恨，其怨气值为 $c_j$。数据保证 $1\\le a_j< b_j\\leq N, 0 < c_j\\leq 10^9$，且每对罪犯组合只出现一次。", "outputFormat": "共一行，为 Z 市长看到的那个冲突事件的影响力。如果本年内监狱中未发生任何冲突事件，请输出 `0`。", "hint": "**输入输出样例说明**\n\n罪犯之间的怨气值如下面左图所示，右图所示为罪犯的分配方法，市长看到的冲突事件影响力是 $3512$（由 $2$ 号和 $3$ 号罪犯引发）。其他任何分法都不会比这个分法更优。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uia11zcq.png)\n\n**数据范围**  \n\n对于 $30\\%$ 的数据有 $N\\leq 15$。\n\n对于 $70\\%$ 的数据有 $N\\leq 2000,M\\leq 50000$。  \n\n对于 $100\\%$ 的数据有 $N\\leq 20000,M\\leq 100000$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2010 Senior] Imprisoning Criminals", "background": "NOIP 2010 Senior T3.", "description": "City S currently has two prisons, holding $N$ criminals numbered from $1$ to $N$. Their relationships are highly discordant. Many pairs of criminals have long-standing grudges and may break into conflict whenever conditions allow. We use the “resentment value” (a positive integer) to represent the hatred between two criminals; the larger the resentment value, the deeper their grudge. If two criminals with resentment value $c$ are held in the same prison, they will clash and cause a conflict event with impact $c$.\n\nAt the end of each year, the police department sorts all conflict events in the prisons by impact from large to small, and submits the list to Mayor Z of City S. The busy Mayor Z will only look at the impact of the first event in the list. If the impact is severe, he may consider replacing the police chief.\n\nAfter carefully reviewing the conflicts among the $N$ criminals, the police chief feels great pressure. He plans to reassign the criminals between the two prisons to keep the impact of conflict events low, thereby protecting his position. Assume that if two criminals held in the same prison have a grudge, they will certainly clash at some point during the year.\n\nHow should the criminals be assigned to minimize the impact of the conflict event that Mayor Z sees? What is this minimum value?", "inputFormat": "A single space separates two numbers in a line. The first line contains two positive integers $N, M$, representing the number of criminals and the number of pairs with grudges, respectively. Each of the next $M$ lines contains three positive integers $a_j, b_j, c_j$, indicating that criminals $a_j$ and $b_j$ have a grudge with resentment value $c_j$. It is guaranteed that $1 \\le a_j < b_j \\leq N$, $0 < c_j \\leq 10^9$, and each pair of criminals appears at most once.", "outputFormat": "Output a single line: the impact of the conflict event that Mayor Z sees. If no conflict occurs in the prisons this year, output `0`.", "hint": "Input-output sample explanation:\n\nThe resentment values between criminals are shown in the left figure below. The right figure shows an assignment of criminals; the impact of the conflict event that the mayor sees is $3512$ (caused by criminals $2$ and $3$). No other assignment is better than this one.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uia11zcq.png)\n\nConstraints\n\n- For $30\\%$ of the testdata, $N \\leq 15$.\n- For $70\\%$ of the testdata, $N \\leq 2000$, $M \\leq 50000$.\n- For $100\\%$ of the testdata, $N \\leq 20000$, $M \\leq 100000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2010 提高组] 关押罪犯", "background": "NOIP2010 提高组 T3", "description": "S 城现有两座监狱，一共关押着 $N$ 名罪犯，编号分别为 $1\\sim N$。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为 $c$ 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为 $c$ 的冲突事件。\n\n每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到 S 城 Z 市长那里。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。\n\n在详细考察了 $N$ 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。\n\n那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？", "inputFormat": "每行中两个数之间用一个空格隔开。第一行为两个正整数 $N,M$，分别表示罪犯的数目以及存在仇恨的罪犯对数。接下来的 $M$ 行每行为三个正整数 $a_j,b_j,c_j$，表示 $a_j$ 号和 $b_j$ 号罪犯之间存在仇恨，其怨气值为 $c_j$。数据保证 $1\\le a_j< b_j\\leq N, 0 < c_j\\leq 10^9$，且每对罪犯组合只出现一次。", "outputFormat": "共一行，为 Z 市长看到的那个冲突事件的影响力。如果本年内监狱中未发生任何冲突事件，请输出 `0`。", "hint": "**输入输出样例说明**\n\n罪犯之间的怨气值如下面左图所示，右图所示为罪犯的分配方法，市长看到的冲突事件影响力是 $3512$（由 $2$ 号和 $3$ 号罪犯引发）。其他任何分法都不会比这个分法更优。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uia11zcq.png)\n\n**数据范围**  \n\n对于 $30\\%$ 的数据有 $N\\leq 15$。\n\n对于 $70\\%$ 的数据有 $N\\leq 2000,M\\leq 50000$。  \n\n对于 $100\\%$ 的数据有 $N\\leq 20000,M\\leq 100000$。", "locale": "zh-CN"}}}
{"pid": "P1526", "type": "P", "difficulty": 7, "samples": [["4 3 6\n0 6\n6 6\n6 0\n0 0\n1 5\n0 3\n1 1\n", "2\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2003", "NOI", "剪枝"], "title": "[NOI2003] 智破连环阵", "background": null, "description": "B 国在耗资百亿元之后终于研究出了新式武器——连环阵（Zenith Protected Linked Hybrid Zone）。传说中，连环阵是一种永不停滞的自发性智能武器。但经过 A 国间谍的侦察发现，连环阵其实是由 $M$ 个编号为 $1, 2,\\ldots, M$ 的独立武器组成的。最初，$1$ 号武器发挥着攻击作用，其他武器都处在无敌自卫状态。以后，一旦第 $i$（$1\\leq i< M$）号武器被消灭，$1$ 秒种以后第 $i+1$ 号武器就自动从无敌自卫状态变成攻击状态。当第 $M$ 号武器被消灭以后，这个造价昂贵的连环阵就被摧毁了。\n\n为了彻底打击 B 国科学家，A 国军事部长打算用最廉价的武器——炸弹来消灭连环阵。经过长时间的精密探测，A 国科学家们掌握了连环阵中 $M$ 个武器的平面坐标，然后确定了 $n$ 个炸弹的平面坐标并且安放了炸弹。每个炸弹持续爆炸时间为 $5$ 分钟。在引爆时间内，每枚炸弹都可以在瞬间消灭离它平面距离不超过 $k$ 的、处在攻击状态的 B 国武器。和连环阵类似，最初 $a_1$ 号炸弹持续引爆 $5$ 分钟时间，然后 $a_2$ 号炸弹持续引爆 $5$ 分钟时间，接着 $a_3$ 号炸弹引爆 $\\ldots$ 以此类推，直到连环阵被摧毁。\n\n显然，不同的序列 $a_1, a_2, a_3\\ldots$ 消灭连环阵的效果也不同。好的序列可以在仅使用较少炸弹的情况下就将连环阵摧毁；坏的序列可能在使用完所有炸弹后仍无法将连环阵摧毁。现在，请你决定一个最优序列 $a_1, a_2, a_3\\ldots$ 使得在第 $a_x$ 号炸弹引爆的时间内连环阵被摧毁。这里的 $x$ 应当尽量小。", "inputFormat": "第一行包含三个整数：$M$、$n$ 和 $k$，分别表示 B 国连环阵由 $M$ 个武器组成，A 国有 $n$ 个炸弹可以使用，炸弹攻击范围为 $k$。以下 $M$ 行，每行由一对整数 $x_i,y_i$ 组成，表示第 $i$ 号武器的平面坐标。再接下来 $n$ 行，每行由一对整数 $u_i,v_i$ 组成，表示第 $i$ 号炸弹的平面坐标。输入数据保证随机、无误、并且必然有解。", "outputFormat": "一行包含一个整数 $x$，表示实际使用的炸弹数。", "hint": "对于 $100\\%$ 的数据，$1\\leq M, n\\leq 100$，$1\\leq k\\leq 1000$，$0\\leq x_i, y_i\\leq 10000$，$0\\leq u_i, v_i\\leq 10000$。\n\n各个测试点 $2$ 秒。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2003] Breaking the Linked Formation", "background": "", "description": "After spending tens of billions, Country B finally developed a new weapon — the Linked Formation (Zenith Protected Linked Hybrid Zone). Legend says the Linked Formation is a self-sustaining intelligent weapon that never stalls. However, reconnaissance by Country A’s spies revealed that the Linked Formation actually consists of $M$ independent weapons numbered $1, 2, \\ldots, M$. Initially, weapon $1$ is in the attack state, while all other weapons are in invincible defense. Thereafter, once weapon $i$ ($1 \\leq i < M$) is destroyed, weapon $i+1$ automatically switches from invincible defense to the attack state $1$ second later. When weapon $M$ is destroyed, this expensive Linked Formation is destroyed.\n\nTo thoroughly defeat Country B’s scientists, the defense minister of Country A plans to use the cheapest weapon — bombs — to destroy the Linked Formation. After long and precise probing, Country A’s scientists obtained the planar coordinates of the $M$ weapons in the Linked Formation, then determined the planar coordinates of $n$ bombs and planted them. Each bomb has a continuous detonation duration of $5$ minutes. During its activation window, each bomb can instantly eliminate any Country B weapon that is in the attack state and whose planar distance to it does not exceed $k$. Similar to the Linked Formation, bomb $a_1$ detonates continuously for $5$ minutes at first, then bomb $a_2$ detonates for $5$ minutes, then bomb $a_3$, and so on, until the Linked Formation is destroyed.\n\nClearly, different sequences $a_1, a_2, a_3, \\ldots$ have different effects. A good sequence may destroy the Linked Formation using only a small number of bombs; a bad sequence may fail even after using all bombs. Now, please determine an optimal sequence $a_1, a_2, a_3, \\ldots$ such that the Linked Formation is destroyed during the detonation time of bomb $a_x$. Here, $x$ should be as small as possible.", "inputFormat": "The first line contains three integers: $M$, $n$, and $k$, denoting that the Linked Formation of Country B consists of $M$ weapons, Country A has $n$ bombs available, and the bomb attack radius is $k$. The next $M$ lines each contain a pair of integers $x_i, y_i$, representing the planar coordinates of weapon $i$. Then the next $n$ lines each contain a pair of integers $u_i, v_i$, representing the planar coordinates of bomb $i$. The input testdata is guaranteed to be random, correct, and to have a solution.", "outputFormat": "One line containing an integer $x$, the actual number of bombs used.", "hint": "For $100\\%$ of the testdata, $1 \\leq M, n \\leq 100$, $1 \\leq k \\leq 1000$, $0 \\leq x_i, y_i \\leq 10000$, $0 \\leq u_i, v_i \\leq 10000$.\n\nEach test point has a time limit of $2$ seconds.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2003] 智破连环阵", "background": null, "description": "B 国在耗资百亿元之后终于研究出了新式武器——连环阵（Zenith Protected Linked Hybrid Zone）。传说中，连环阵是一种永不停滞的自发性智能武器。但经过 A 国间谍的侦察发现，连环阵其实是由 $M$ 个编号为 $1, 2,\\ldots, M$ 的独立武器组成的。最初，$1$ 号武器发挥着攻击作用，其他武器都处在无敌自卫状态。以后，一旦第 $i$（$1\\leq i< M$）号武器被消灭，$1$ 秒种以后第 $i+1$ 号武器就自动从无敌自卫状态变成攻击状态。当第 $M$ 号武器被消灭以后，这个造价昂贵的连环阵就被摧毁了。\n\n为了彻底打击 B 国科学家，A 国军事部长打算用最廉价的武器——炸弹来消灭连环阵。经过长时间的精密探测，A 国科学家们掌握了连环阵中 $M$ 个武器的平面坐标，然后确定了 $n$ 个炸弹的平面坐标并且安放了炸弹。每个炸弹持续爆炸时间为 $5$ 分钟。在引爆时间内，每枚炸弹都可以在瞬间消灭离它平面距离不超过 $k$ 的、处在攻击状态的 B 国武器。和连环阵类似，最初 $a_1$ 号炸弹持续引爆 $5$ 分钟时间，然后 $a_2$ 号炸弹持续引爆 $5$ 分钟时间，接着 $a_3$ 号炸弹引爆 $\\ldots$ 以此类推，直到连环阵被摧毁。\n\n显然，不同的序列 $a_1, a_2, a_3\\ldots$ 消灭连环阵的效果也不同。好的序列可以在仅使用较少炸弹的情况下就将连环阵摧毁；坏的序列可能在使用完所有炸弹后仍无法将连环阵摧毁。现在，请你决定一个最优序列 $a_1, a_2, a_3\\ldots$ 使得在第 $a_x$ 号炸弹引爆的时间内连环阵被摧毁。这里的 $x$ 应当尽量小。", "inputFormat": "第一行包含三个整数：$M$、$n$ 和 $k$，分别表示 B 国连环阵由 $M$ 个武器组成，A 国有 $n$ 个炸弹可以使用，炸弹攻击范围为 $k$。以下 $M$ 行，每行由一对整数 $x_i,y_i$ 组成，表示第 $i$ 号武器的平面坐标。再接下来 $n$ 行，每行由一对整数 $u_i,v_i$ 组成，表示第 $i$ 号炸弹的平面坐标。输入数据保证随机、无误、并且必然有解。", "outputFormat": "一行包含一个整数 $x$，表示实际使用的炸弹数。", "hint": "对于 $100\\%$ 的数据，$1\\leq M, n\\leq 100$，$1\\leq k\\leq 1000$，$0\\leq x_i, y_i\\leq 10000$，$0\\leq u_i, v_i\\leq 10000$。\n\n各个测试点 $2$ 秒。", "locale": "zh-CN"}}}
{"pid": "P1527", "type": "P", "difficulty": 6, "samples": [["2 2\n2 1\n3 4\n1 2 1 2 1\n1 1 2 2 3\n", "1\n3"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["集训队互测", "O2优化", "整体二分"], "title": "[国家集训队] 矩阵乘法", "background": "", "description": "给你一个 $n \\times n$ 的矩阵，不用算矩阵乘法，但是每次询问一个子矩形的第 $k$ 小数。\n", "inputFormat": "第一行有两个整数，分别表示矩阵大小 $n$ 和询问组数 $q$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行 $n$ 个整数，表示这个矩阵。第 $(i + 1)$ 行的第 $j$ 个数表示矩阵第 $i$ 行第 $j$ 列的数 $a_{i, j}$。\n\n接下来 $q$ 行，每行五个整数 $x_1, y_1, x_2, y_2, k$，表示一组询问，要求找到以 $(x_1, y_1)$ 为左上角，$(x_2, y_2)$ 为右下角的子矩形中的第 $k$ 小数。", "outputFormat": "对于每组询问，输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，保证 $n \\leq 100$，$q \\leq 10^3$。\n- 对于 $40\\%$ 的数据，保证 $n \\leq 300$，$q \\leq 10^4$。\n- 对于 $60\\%$ 的数据，保证 $n \\leq 400$，$q \\leq 3 \\times 10^4$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 500$，$1 \\leq q \\leq 6 \\times 10^4$，$0 \\leq a_{i, j} \\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTT] Matrix Multiplication", "background": "", "description": "Given an $n \\times n$ matrix, you do not need to perform matrix multiplication. Instead, for each query, find the $k$-th smallest number in a subrectangle.", "inputFormat": "The first line contains two integers, representing the matrix size $n$ and the number of queries $q$.\n\nLines $2$ through $(n + 1)$ each contain $n$ integers, representing the matrix. The $j$-th number on line $(i + 1)$ is the number in row $i$ and column $j$ of the matrix, denoted $a_{i, j}$.\n\nThen $q$ lines follow, each containing five integers $x_1, y_1, x_2, y_2, k$, representing one query. For each query, find the $k$-th smallest number in the subrectangle with top-left corner $(x_1, y_1)$ and bottom-right corner $(x_2, y_2)$.", "outputFormat": "For each query, output a single integer on its own line representing the answer.", "hint": "#### Constraints and Conventions\n\n- For $20\\%$ of the testdata, it is guaranteed that $n \\leq 100$, $q \\leq 10^3$.\n- For $40\\%$ of the testdata, it is guaranteed that $n \\leq 300$, $q \\leq 10^4$.\n- For $60\\%$ of the testdata, it is guaranteed that $n \\leq 400$, $q \\leq 3 \\times 10^4$.\n- For $100\\%$ of the testdata, it is guaranteed that $1 \\leq n \\leq 500$, $1 \\leq q \\leq 6 \\times 10^4$, $0 \\leq a_{i, j} \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[国家集训队] 矩阵乘法", "background": "", "description": "给你一个 $n \\times n$ 的矩阵，不用算矩阵乘法，但是每次询问一个子矩形的第 $k$ 小数。\n", "inputFormat": "第一行有两个整数，分别表示矩阵大小 $n$ 和询问组数 $q$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行 $n$ 个整数，表示这个矩阵。第 $(i + 1)$ 行的第 $j$ 个数表示矩阵第 $i$ 行第 $j$ 列的数 $a_{i, j}$。\n\n接下来 $q$ 行，每行五个整数 $x_1, y_1, x_2, y_2, k$，表示一组询问，要求找到以 $(x_1, y_1)$ 为左上角，$(x_2, y_2)$ 为右下角的子矩形中的第 $k$ 小数。", "outputFormat": "对于每组询问，输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，保证 $n \\leq 100$，$q \\leq 10^3$。\n- 对于 $40\\%$ 的数据，保证 $n \\leq 300$，$q \\leq 10^4$。\n- 对于 $60\\%$ 的数据，保证 $n \\leq 400$，$q \\leq 3 \\times 10^4$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 500$，$1 \\leq q \\leq 6 \\times 10^4$，$0 \\leq a_{i, j} \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P1528", "type": "P", "difficulty": 5, "samples": [["4\r\n30\r\n40\r\n50\r\n25\r\n10\r\n15\r\n16\r\n17\r\n18\r\n19\r\n20\r\n21\r\n25\r\n24\r\n30\r\n\r\n \r\n", "7\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索", "贪心", "二分", "深度优先搜索 DFS", "剪枝"], "title": "切蛋糕", "background": "", "description": "Facer今天买了 $n$ 块蛋糕，不料被信息组中球球等好吃懒做的家伙发现了，没办法，只好浪费一点来填他们的嘴巴。他答应给每个人留一口，然后量了量每个人口的大小。Facer 有把刀，可以切蛋糕，但他不能把两块蛋糕拼起来，但是他又不会给任何人两块蛋糕。现在问你，facer 怎样切蛋糕，才能满足最多的人。（facer 的刀很强，切的时候不会浪费蛋糕）。\n\n \n ", "inputFormat": "第一行 $n$，facer 有 $n$ 个蛋糕。接下来 $n$ 行，每行表示一个蛋糕的大小。再一行一个数 $m$，为信息组的人数，然后 $m$ 行，每行一个数，为一个人嘴的大小。$(1\\le n\\le 50$，$ 1\\le m\\le 1024)$\n\n", "outputFormat": "一行，facer最多可以填多少张嘴巴。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Cutting Cakes", "background": "", "description": "Facer bought $n$ cakes today. Unfortunately, the lazy gluttons in the Information Group, including Qiuqiu, found out. He had no choice but to spare some to feed them. He promised to leave one bite for everyone and measured the size of each person's mouth. Facer has a knife and can cut cakes, but he cannot combine two cakes into one serving, and he will not give anyone two cakes. Now, how should Facer cut the cakes to satisfy the maximum number of people? (Facer's knife is perfect; cutting does not waste any cake.)", "inputFormat": "The first line contains $n$, the number of cakes Facer has.  \nEach of the next $n$ lines contains the size of a cake.  \nThe next line contains $m$, the number of people in the Information Group.  \nEach of the next $m$ lines contains one number, the size of a person's mouth.  \nConstraints: $1 \\le n \\le 50$, $1 \\le m \\le 1024$.", "outputFormat": "One line: the maximum number of mouths Facer can fill.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "切蛋糕", "background": "", "description": "Facer今天买了 $n$ 块蛋糕，不料被信息组中球球等好吃懒做的家伙发现了，没办法，只好浪费一点来填他们的嘴巴。他答应给每个人留一口，然后量了量每个人口的大小。Facer 有把刀，可以切蛋糕，但他不能把两块蛋糕拼起来，但是他又不会给任何人两块蛋糕。现在问你，facer 怎样切蛋糕，才能满足最多的人。（facer 的刀很强，切的时候不会浪费蛋糕）。\n\n \n ", "inputFormat": "第一行 $n$，facer 有 $n$ 个蛋糕。接下来 $n$ 行，每行表示一个蛋糕的大小。再一行一个数 $m$，为信息组的人数，然后 $m$ 行，每行一个数，为一个人嘴的大小。$(1\\le n\\le 50$，$ 1\\le m\\le 1024)$\n\n", "outputFormat": "一行，facer最多可以填多少张嘴巴。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1529", "type": "P", "difficulty": 3, "samples": [["5\nA d 6\nB d 3\nC e 9\nd Z 8\ne Z 3", "B 11\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "USACO", "最短路", "Floyd 算法"], "title": "[USACO2.4] 回家 Bessie Come Home", "background": "", "description": "现在是晚餐时间，而母牛们在外面分散的牧场中。 \n\nFarmer John 按响了电铃，所以她们开始向谷仓走去。 你的工作是要指出哪只母牛会最先到达谷仓（在给出的测试数据中，总会**有且只有**一只最快的母牛）。在挤奶的时候（晚餐前），每只母牛都在她自己的牧场上，一些牧场上可能没有母牛。\n\n每个牧场由一条条道路和一个或多个牧场连接（可能包括自己）。有时，两个牧场（可能是字母相同的）之间会有超过一条道路相连。至少有一个牧场和谷仓之间有道路连接。因此，所有的母牛最后都能到达谷仓，并且母牛总是走最短的路径。当然，母牛能向着任意一方向前进，并且她们以相同的速度前进。牧场被标记为 $\\texttt{a} \\ldots \\texttt{z}$ 和 $\\texttt{A} \\ldots \\texttt{Y}$，在用大写字母表示的牧场中有一只母牛，小写字母中则没有。 谷仓的标记是 $\\texttt{Z}$，注意没有母牛在谷仓中。\n\n**注意 $\\texttt{m}$ 和 $\\texttt{M}$ 不是同一个牧场**。", "inputFormat": "第一行一个整数 $P$（$1\\leq P \\leq 10^4$），表示连接牧场（谷仓）的道路的数目。\n\n接下来 $P$ 行，每行用空格分开的两个字母和一个正整数：被道路连接牧场的标号和道路的长度（道路长度均不超过 $10^3$）。\n", "outputFormat": "单独的一行包含二个项目：最先到达谷仓的母牛所在的牧场的标号，和这只母牛走过的路径的长度。", "hint": "翻译来自 NOCOW\n\nUSACO 2.4\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO2.4] Bessie Come Home", "background": "", "description": "It is dinnertime, and the cows are out in scattered pastures. Farmer John rings the electric bell, so they start heading to the barn. Your job is to determine which cow will reach the barn first (in the given testdata, there is always exactly one fastest cow). At milking time (before dinner), each cow is in her own pasture; some pastures may have no cows.\n\nEach road connects a pair of pastures (possibly the same pasture). Sometimes, more than one road connects the same pair of pastures. At least one pasture is connected to the barn by a road. Therefore, all cows can eventually reach the barn, and cows always take the shortest paths. Of course, cows can travel in either direction, and they all travel at the same speed. Pastures are labeled $\\texttt{a} \\ldots \\texttt{z}$ and $\\texttt{A} \\ldots \\texttt{Y}$. Each uppercase-labeled pasture contains one cow, while lowercase-labeled pastures contain no cows. The barn is labeled $\\texttt{Z}$; note that there is no cow in the barn.\n\n**Note that $\\texttt{m}$ and $\\texttt{M}$ are not the same pasture.**", "inputFormat": "The first line contains an integer $P$ ($1 \\leq P \\leq 10^4$), the number of roads connecting pastures and the barn.\n\nEach of the next $P$ lines contains two letters and a positive integer, separated by spaces: the labels of the two pastures connected by the road, and the length of that road (each road length is at most $10^3$).", "outputFormat": "A single line containing two items: the label of the pasture where the cow that reaches the barn first starts, and the length of that cow’s path.", "hint": "Translated from NOCOW.\n\nUSACO 2.4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO2.4] 回家 Bessie Come Home", "background": "", "description": "现在是晚餐时间，而母牛们在外面分散的牧场中。 \n\nFarmer John 按响了电铃，所以她们开始向谷仓走去。 你的工作是要指出哪只母牛会最先到达谷仓（在给出的测试数据中，总会**有且只有**一只最快的母牛）。在挤奶的时候（晚餐前），每只母牛都在她自己的牧场上，一些牧场上可能没有母牛。\n\n每个牧场由一条条道路和一个或多个牧场连接（可能包括自己）。有时，两个牧场（可能是字母相同的）之间会有超过一条道路相连。至少有一个牧场和谷仓之间有道路连接。因此，所有的母牛最后都能到达谷仓，并且母牛总是走最短的路径。当然，母牛能向着任意一方向前进，并且她们以相同的速度前进。牧场被标记为 $\\texttt{a} \\ldots \\texttt{z}$ 和 $\\texttt{A} \\ldots \\texttt{Y}$，在用大写字母表示的牧场中有一只母牛，小写字母中则没有。 谷仓的标记是 $\\texttt{Z}$，注意没有母牛在谷仓中。\n\n**注意 $\\texttt{m}$ 和 $\\texttt{M}$ 不是同一个牧场**。", "inputFormat": "第一行一个整数 $P$（$1\\leq P \\leq 10^4$），表示连接牧场（谷仓）的道路的数目。\n\n接下来 $P$ 行，每行用空格分开的两个字母和一个正整数：被道路连接牧场的标号和道路的长度（道路长度均不超过 $10^3$）。\n", "outputFormat": "单独的一行包含二个项目：最先到达谷仓的母牛所在的牧场的标号，和这只母牛走过的路径的长度。", "hint": "翻译来自 NOCOW\n\nUSACO 2.4\n", "locale": "zh-CN"}}}
{"pid": "P1530", "type": "P", "difficulty": 3, "samples": [["45 56", "0.803(571428)"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "数学", "USACO"], "title": "[USACO2.4] 分数化小数 Fractions to Decimals", "background": "", "description": "写一个程序，输入一个形如 $\\dfrac{N}{D}$ 的分数，输出它的小数形式。如果小数有循环节的话，把循环节放在一对圆括号中。\n\n例如，$\\dfrac{1}{3}=0.33333333\\ldots$ 写成 $0.(3)$，$\\dfrac{41}{333}= 0.123123123\\ldots$ 写成 $0.(123)$，整数 $x$ 写成 $x.0$。", "inputFormat": "输入包含两个整数 $N$ 和 $D$（$1 \\leq N,D \\leq 10^5$）。", "outputFormat": "输出按照上面规则计算出的小数表达式。如果结果长度大于 $76$，每行输出 $76$ 个字符。", "hint": "翻译来自NOCOW\n\nUSACO 2.4\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO2.4] Fractions to Decimals", "background": "", "description": "Write a program that, given a fraction of the form $\\dfrac{N}{D}$, outputs its decimal representation. If the decimal has a repeating cycle, enclose the cycle in a pair of parentheses.\n\nFor example, $\\dfrac{1}{3}=0.33333333\\ldots$ is written as $0.(3)$, $\\dfrac{41}{333}= 0.123123123\\ldots$ is written as $0.(123)$, and an integer $x$ is written as $x.0$.", "inputFormat": "The input contains two integers $N$ and $D$ ($1 \\leq N, D \\leq 10^5$).", "outputFormat": "Output the decimal representation computed according to the rules above. If the length of the result exceeds $76$, print $76$ characters per line.", "hint": "Translated from NOCOW.\nUSACO 2.4\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO2.4] 分数化小数 Fractions to Decimals", "background": "", "description": "写一个程序，输入一个形如 $\\dfrac{N}{D}$ 的分数，输出它的小数形式。如果小数有循环节的话，把循环节放在一对圆括号中。\n\n例如，$\\dfrac{1}{3}=0.33333333\\ldots$ 写成 $0.(3)$，$\\dfrac{41}{333}= 0.123123123\\ldots$ 写成 $0.(123)$，整数 $x$ 写成 $x.0$。", "inputFormat": "输入包含两个整数 $N$ 和 $D$（$1 \\leq N,D \\leq 10^5$）。", "outputFormat": "输出按照上面规则计算出的小数表达式。如果结果长度大于 $76$，每行输出 $76$ 个字符。", "hint": "翻译来自NOCOW\n\nUSACO 2.4\n", "locale": "zh-CN"}}}
{"pid": "P1531", "type": "P", "difficulty": 4, "samples": [["5 6\n1 2 3 4 5\nQ 1 5\nU 3 6\nQ 3 4\nQ 4 5\nU 2 9\nQ 1 5", "5\n6\n5\n9\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "分块"], "title": "I Hate It", "background": "很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。这让很多学生很反感。\n", "description": "不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。\n", "inputFormat": "第一行，有两个正整数 $n$ 和 $m$（$0<n \\le 2\\times 10^5,0<m\\le2 \\times 10^5$），分别代表学生的数目和操作的数目。学生 ID 编号分别从 $1$ 编到 $n$。\n\n第二行包含 $n$ 个整数，代表这 $n$ 个学生的初始成绩，其中第 $i$ 个数代表 ID 为 $i$ 的学生的成绩，保证学生的成绩为 $1 \\sim 10^9$ 之间的正整数。\n\n接下来有 $m$ 行。每一行有一个字符 $c$（只取 `Q` 或 `U`），和两个正整数 $a$，$b$。\n\n- 当 $c$ 为 `Q` 的时候，表示这是一条询问操作，它询问 ID 从 $a$ 到 $b$（包括 $a,b$） 的学生当中，成绩最高的是多少；\n- 当 $c$ 为 `U` 的时候，表示这是一条更新操作，如果当前 $a$ 学生的成绩低于 $b$，则把 ID 为 $a$ 的学生的成绩更改为 $b$，否则不改动。", "outputFormat": "对于每一次询问操作输出一行一个整数，表示最高成绩。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "I Hate It", "background": "Many schools have a habit of making comparisons. Teachers often ask, among students from some ID to another, what the highest score is. This annoys many students.", "description": "Whether you like it or not, your task is to write a program that simulates the teacher’s queries as required. Of course, the teacher sometimes needs to update a student’s score.", "inputFormat": "The first line contains two positive integers $n$ and $m$ ($0 < n \\le 2 \\times 10^5, 0 < m \\le 2 \\times 10^5$), representing the number of students and the number of operations. Student IDs are numbered from $1$ to $n$.\n\nThe second line contains $n$ integers, representing the initial scores of these $n$ students. The $i$-th number is the score of the student with ID $i$, and scores are guaranteed to be positive integers in $1 \\sim 10^9$.\n\nThe next $m$ lines each contain a character $c$ (only `Q` or `U`) and two positive integers $a$ and $b$.\n- When $c$ is `Q`, it is a query operation asking for the maximum score among students whose IDs are from $a$ to $b$ (inclusive).\n- When $c$ is `U`, it is an update operation: if the current score of student $a$ is less than $b$, then set the score of the student with ID $a$ to $b$; otherwise, leave it unchanged.", "outputFormat": "For each query operation, output one line with a single integer representing the maximum score.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "I Hate It", "background": "很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。这让很多学生很反感。\n", "description": "不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。\n", "inputFormat": "第一行，有两个正整数 $n$ 和 $m$（$0<n \\le 2\\times 10^5,0<m\\le2 \\times 10^5$），分别代表学生的数目和操作的数目。学生 ID 编号分别从 $1$ 编到 $n$。\n\n第二行包含 $n$ 个整数，代表这 $n$ 个学生的初始成绩，其中第 $i$ 个数代表 ID 为 $i$ 的学生的成绩，保证学生的成绩为 $1 \\sim 10^9$ 之间的正整数。\n\n接下来有 $m$ 行。每一行有一个字符 $c$（只取 `Q` 或 `U`），和两个正整数 $a$，$b$。\n\n- 当 $c$ 为 `Q` 的时候，表示这是一条询问操作，它询问 ID 从 $a$ 到 $b$（包括 $a,b$） 的学生当中，成绩最高的是多少；\n- 当 $c$ 为 `U` 的时候，表示这是一条更新操作，如果当前 $a$ 学生的成绩低于 $b$，则把 ID 为 $a$ 的学生的成绩更改为 $b$，否则不改动。", "outputFormat": "对于每一次询问操作输出一行一个整数，表示最高成绩。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1532", "type": "P", "difficulty": 3, "samples": [["4321\n54321\n", "6174\n82962 75933 63954 61974\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟"], "title": "卡布列克圆舞曲", "background": "", "description": "卡布列克是一位数学家，他在研究数字时发现：任意一个不是用完全相同数字组成的四位数，如果对它们的每位数字重新排序，组成一个较大的数和一个较小的数，然后用较大数减去较小数，差不够四位数时补零，类推下去，最后将变成一个固定的数：$6174$，这就是卡布列克常数，例如：\n\n$4321-1234=3087$。\n\n$8730-378=8352$。\n\n$8532-2358=6174$。\n\n$7641-1467=6174$。\n\n如果 $K$ 位数也照此办理，它们不是变成一个数，而是在几个数字之间形成循环，称作卡布列克圆舞曲。例如对于五位数 $54321$：\n\n$54321-12345=41976$。\n\n$97641-14679=82962$。\n\n$98622-22689=75933$。\n\n$97533-33579=63954$。\n\n$96543-34569=61974$。\n\n$97641-14679=82962$。\n\n我们把 $82962,75933,63954,61974$ 称作循环节，即卡布列克圆舞曲。", "inputFormat": "若干行，每行为一个待求“卡布列克圆舞曲”的起始整数 $n$。（$n<2^{31}$）\n", "outputFormat": "每行为对应整数的循环节，数据之间用空格隔开。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Kaprekar Waltz", "background": "", "description": "Kaprekar was a mathematician. He discovered that for any four-digit number not composed of completely identical digits: if you reorder its digits to form the largest number and the smallest number, then subtract the smaller from the larger; if the difference has fewer than four digits, pad with leading zeros; and repeat this process, it will eventually become a fixed number $6174$, which is the Kaprekar constant. For example:\n\n$4321-1234=3087$.\n\n$8730-378=8352$.\n\n$8532-2358=6174$.\n\n$7641-1467=6174$.\n\nIf a K-digit number is processed in the same way, it does not become a single number but forms a cycle among several numbers, called the Kaprekar Waltz. For example, for the five-digit number $54321$:\n\n$54321-12345=41976$.\n\n$97641-14679=82962$.\n\n$98622-22689=75933$.\n\n$97533-33579=63954$.\n\n$96543-34569=61974$.\n\n$97641-14679=82962$.\n\nWe call 82962, 75933, 63954, 61974 the repeating cycle, i.e., the Kaprekar Waltz.", "inputFormat": "Multiple lines. Each line contains a starting integer $n$ for which to find the \"Kaprekar Waltz\" ($n<2^{31}$).", "outputFormat": "For each input integer, output the corresponding cycle terms on one line, separated by spaces.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "卡布列克圆舞曲", "background": "", "description": "卡布列克是一位数学家，他在研究数字时发现：任意一个不是用完全相同数字组成的四位数，如果对它们的每位数字重新排序，组成一个较大的数和一个较小的数，然后用较大数减去较小数，差不够四位数时补零，类推下去，最后将变成一个固定的数：$6174$，这就是卡布列克常数，例如：\n\n$4321-1234=3087$。\n\n$8730-378=8352$。\n\n$8532-2358=6174$。\n\n$7641-1467=6174$。\n\n如果 $K$ 位数也照此办理，它们不是变成一个数，而是在几个数字之间形成循环，称作卡布列克圆舞曲。例如对于五位数 $54321$：\n\n$54321-12345=41976$。\n\n$97641-14679=82962$。\n\n$98622-22689=75933$。\n\n$97533-33579=63954$。\n\n$96543-34569=61974$。\n\n$97641-14679=82962$。\n\n我们把 $82962,75933,63954,61974$ 称作循环节，即卡布列克圆舞曲。", "inputFormat": "若干行，每行为一个待求“卡布列克圆舞曲”的起始整数 $n$。（$n<2^{31}$）\n", "outputFormat": "每行为对应整数的循环节，数据之间用空格隔开。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1533", "type": "P", "difficulty": 5, "samples": [["7 2\n1 5 2 6 3 7 4\n1 5 3\n2 7 1\n", "3\n2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["线段树", "二分", "平衡树", "树状数组", "洛谷原创", "排序", "可持久化线段树"], "title": "可怜的狗狗", "background": "", "description": "小卡家有  $n$ 只狗，由于品种、年龄不同，每一只狗都有一个不同的漂亮值。漂亮值与漂亮的程度成反比（漂亮值越低越漂亮），吃饭时，狗狗们会按顺序站成一排等着主人给食物。\n\n可是嘉嘉真的很懒，他才不肯喂这么多狗呢，这多浪费时间啊，于是他每次就只给第  $i$ 只到第  $j$ 只狗中第  $k$ 漂亮的狗狗喂食（好狠心的人啊）。而且为了保证某一只狗狗不会被喂太多次，他喂的每个区间  $[i,j]$ 不互相包含。", "inputFormat": "第一行输入两个数  $n,m$， $m$ 表示嘉嘉喂食的次数\n\n第二行  $n$ 个整数，表示第  $i$ 只狗的漂亮值为  $a_i$。\n\n接下来  $m$ 行，每行  $3$ 个整数  $i,j,k$，表示询问这次喂食喂第  $i$ 到第  $j$ 只狗中第  $k$ 漂亮的狗的漂亮值。", "outputFormat": "$m$ 行，每行一个整数，表示每一次喂的那只狗漂亮值为多少。", "hint": "$1\\le n \\le 3\\times 10^5 ,1\\le m \\le5\\times10^4,0\\le a_i<2^{31}$，且 $a_i$ 互不相同。", "locale": "zh-CN", "translations": {"en": {"title": "Poor Dogs", "background": "", "description": "Xiao Ka has $n$ dogs. Because of different breeds and ages, each dog has a different beauty value. The beauty value is inversely related to how pretty a dog is (the lower the beauty value, the prettier). At mealtime, the dogs stand in a line in order, waiting for their owner to give them food.\n\nBut Jiajia is really lazy; he refuses to feed so many dogs. Each time, he only feeds the dog that is the $k$-th most beautiful among the $i$-th to the $j$-th dogs (how heartless!). Moreover, to ensure that no single dog is fed too many times, none of the intervals $[i, j]$ contains another.", "inputFormat": "The first line contains two integers $n,m$, where $m$ is the number of times Jiajia feeds the dogs.\n\nThe second line contains $n$ integers, where the $i$-th dog's beauty value is $a_i$.\n\nThe next $m$ lines each contain $3$ integers $i,j,k$, asking for the beauty value of the dog that is the $k$-th most beautiful among the dogs from $i$ to $j$.", "outputFormat": "$m$ lines, each containing one integer, which is the beauty value of the dog fed each time.", "hint": "Constraints: $1\\le n \\le 3\\times 10^5 ,1\\le m \\le5\\times10^4,0\\le a_i<2^{31}$，且 $a_i$ 互不相同。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "可怜的狗狗", "background": "", "description": "小卡家有  $n$ 只狗，由于品种、年龄不同，每一只狗都有一个不同的漂亮值。漂亮值与漂亮的程度成反比（漂亮值越低越漂亮），吃饭时，狗狗们会按顺序站成一排等着主人给食物。\n\n可是嘉嘉真的很懒，他才不肯喂这么多狗呢，这多浪费时间啊，于是他每次就只给第  $i$ 只到第  $j$ 只狗中第  $k$ 漂亮的狗狗喂食（好狠心的人啊）。而且为了保证某一只狗狗不会被喂太多次，他喂的每个区间  $[i,j]$ 不互相包含。", "inputFormat": "第一行输入两个数  $n,m$， $m$ 表示嘉嘉喂食的次数\n\n第二行  $n$ 个整数，表示第  $i$ 只狗的漂亮值为  $a_i$。\n\n接下来  $m$ 行，每行  $3$ 个整数  $i,j,k$，表示询问这次喂食喂第  $i$ 到第  $j$ 只狗中第  $k$ 漂亮的狗的漂亮值。", "outputFormat": "$m$ 行，每行一个整数，表示每一次喂的那只狗漂亮值为多少。", "hint": "$1\\le n \\le 3\\times 10^5 ,1\\le m \\le5\\times10^4,0\\le a_i<2^{31}$，且 $a_i$ 互不相同。", "locale": "zh-CN"}}}
{"pid": "P1534", "type": "P", "difficulty": 1, "samples": [["7\n5 3\n6 2\n7 2\n5 3\n5 4\n0 4\n0 6", "-2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "洛谷原创"], "title": "不高兴的津津（升级版）", "background": "", "description": "津津上初中了。妈妈认为津津应该更加用功学习，所以津津除了上学之外，还要参加妈妈为她报名的各科复习班。另外每天妈妈还会送她去学习朗诵、舞蹈和钢琴。但是津津如果一天上课超过八个小时就会不高兴，而且上得越久就会越不高兴。\n\n这次与 NOIp2004 普及组第一题不同的是：假设津津不会因为其它事不高兴，但是她的不高兴会（当然高兴也会）持续到第二天。请你帮忙检查一下津津以后 $n$ 天的日程安排，看看以后 $n$ 天她会不会不高兴（计算方法：用昨天不高兴程度加上今天上课总时间减去 $8$ 后得到的数作为今天不高兴程度）；输出以后 $n$ 天结束后不高兴程度和是多少。", "inputFormat": "第一行共一个数 $n$。\n\n第二行至第 $n+1$ 行，每行两个数，表示这天上学时间和课外补习班时间。", "outputFormat": "一个数，这 $n$ 天过后的不高兴程度和。", "hint": "### 数据范围及约定\n\n对于全部数据，上学时间和上课时间各不超过 $8$，和不超过 $16$，$n \\le 3000$。", "locale": "zh-CN", "translations": {"en": {"title": "Unhappy Jinjin (Upgraded Version)", "background": "", "description": "Jinjin has entered middle school. Her mom thinks she should study harder, so besides attending school, Jinjin also has to go to the review classes her mom enrolled her in. In addition, every day her mom takes her to learn recitation, dance, and piano. However, if Jinjin studies for more than eight hours in a day, she becomes unhappy, and the longer she studies, the more unhappy she becomes.\n\nDifferent from the first problem of NOIp2004 Junior: assume Jinjin will not be unhappy because of other things, but her unhappiness (and of course her happiness) will carry over to the next day. Please check Jinjin’s schedule for the next $n$ days and determine whether she will be unhappy during these $n$ days (calculation method: use yesterday’s unhappiness degree plus today’s total class time minus $8$ to obtain today’s unhappiness degree); output the sum of the unhappiness degrees after these $n$ days.", "inputFormat": "The first line contains a single integer $n$.\n\nFrom line $2$ to line $n+1$, each line contains two integers, representing the school time and the extracurricular tutoring time for that day.", "outputFormat": "A single integer: the sum of the unhappiness degrees after these $n$ days.", "hint": "Constraints\n\nFor all testdata, the school time and the class time each do not exceed $8$, and their sum does not exceed $16$, and $n \\le 3000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "不高兴的津津（升级版）", "background": "", "description": "津津上初中了。妈妈认为津津应该更加用功学习，所以津津除了上学之外，还要参加妈妈为她报名的各科复习班。另外每天妈妈还会送她去学习朗诵、舞蹈和钢琴。但是津津如果一天上课超过八个小时就会不高兴，而且上得越久就会越不高兴。\n\n这次与 NOIp2004 普及组第一题不同的是：假设津津不会因为其它事不高兴，但是她的不高兴会（当然高兴也会）持续到第二天。请你帮忙检查一下津津以后 $n$ 天的日程安排，看看以后 $n$ 天她会不会不高兴（计算方法：用昨天不高兴程度加上今天上课总时间减去 $8$ 后得到的数作为今天不高兴程度）；输出以后 $n$ 天结束后不高兴程度和是多少。", "inputFormat": "第一行共一个数 $n$。\n\n第二行至第 $n+1$ 行，每行两个数，表示这天上学时间和课外补习班时间。", "outputFormat": "一个数，这 $n$ 天过后的不高兴程度和。", "hint": "### 数据范围及约定\n\n对于全部数据，上学时间和上课时间各不超过 $8$，和不超过 $16$，$n \\le 3000$。", "locale": "zh-CN"}}}
{"pid": "P1535", "type": "P", "difficulty": 3, "samples": [["4 5 6\n...*.\n...*.\n.....\n.....\n1 3 1 5", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "搜索", "2008", "USACO", "剪枝"], "title": "[USACO08MAR] Cow Travelling S", "background": "", "description": "奶牛们在被划分成 $N$ 行 $M$ 列（$2 \\leq N,M \\leq 100$）的草地上游走， 试图找到整块草地中最美味的牧草。\n\nFarmer John 在某个时刻看见贝茜在位置 $(R_1, C_1)$，恰好 $T$（$0 \\lt T \\leq 15$）秒后，FJ 又在位置 $(R_2, C_2)$ 与贝茜撞了正着。FJ 并不知道在这 $T$ 秒内贝茜是否曾经到过 $(R_2, C_2)$，他能确定的只是，现在贝茜在那里。\n\n设 $S$ 为奶牛在 $T$ 秒内从 $(R_1, C_1)$ 走到 $(R_2, C_2)$ 所能选择的路径总数，FJ 希望有一个程序来帮他计算这个值。每一秒内，奶牛会水平或垂直地移动 $1$ 单位距离（奶牛总是在移动，不会在某秒内停在它上一秒所在的点）。草地上的某些地方有树，自然，奶牛不能走到树所在的位置，也不会走出草地。\n\n现在你拿到了一张整块草地的地形图，其中 `.` 表示平坦的草地，`*` 表示挡路的树。你的任务是计算出，一头在 $T$ 秒内从 $(R_1, C_1)$ 移动到 $(R_2, C_2)$ 的奶牛可能经过的路径有哪些。", "inputFormat": "第一行包含 $3$ 个用空格隔开的整数：$N,M,T$。\n\n接下来 $N$ 行：第 $i$ 行为 $M$ 个连续的字符，描述了草地第 $i$ 行各点的情况，保证字符是 `.` 和 `*` 中的一个。\n\n最后一行 $4$ 个整数 $R_1,C_1,R_2,C_2$。", "outputFormat": "输出从 $(R_1, C_1)$ 移动到 $(R_2, C_2)$ 的方案数。", "hint": "奶牛在 $6$ 秒内从 $(1,3)$ 走到 $(1,5)$ 的方法只有一种，绕过她面前的树。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO08MAR] Cow Travelling S", "background": "", "description": "Cows wander on a pasture divided into $N$ rows and $M$ columns ($2 \\leq N, M \\leq 100$), trying to find the tastiest grass.\n\nAt some moment, Farmer John sees Bessie at position $(R_1, C_1)$. Exactly $T$ ($0 < T \\leq 15$) seconds later, FJ runs into Bessie at position $(R_2, C_2)$. FJ does not know whether Bessie visited $(R_2, C_2)$ at any time during those $T$ seconds; he only knows that she is there now.\n\nLet $S$ be the number of paths the cow can take to go from $(R_1, C_1)$ to $(R_2, C_2)$ in $T$ seconds. FJ wants a program to compute this value. Each second, the cow moves horizontally or vertically by a distance of $1$ (the cow is always moving and will not stay at the same point in any second). Some places on the pasture have trees. Of course, the cow cannot step on a tree, and she will not leave the pasture.\n\nYou are given a map of the whole pasture, where `.` means open grass and `*` means a blocking tree. Your task is to compute how many different paths a cow can take to move from $(R_1, C_1)$ to $(R_2, C_2)$ in $T$ seconds.", "inputFormat": "The first line contains $3$ space-separated integers: $N, M, T$.\n\nThen $N$ lines follow: the $i$-th line has $M$ consecutive characters describing row $i$ of the pasture. Each character is guaranteed to be either `.` or `*`.\n\nThe last line contains $4$ integers $R_1, C_1, R_2, C_2$.", "outputFormat": "Output the number of ways to move from $(R_1, C_1)$ to $(R_2, C_2)$.", "hint": "There is only one way for the cow to go from $(1, 3)$ to $(1, 5)$ in $6$ seconds, by going around the tree in front of her.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO08MAR] Cow Travelling S", "background": "", "description": "奶牛们在被划分成 $N$ 行 $M$ 列（$2 \\leq N,M \\leq 100$）的草地上游走， 试图找到整块草地中最美味的牧草。\n\nFarmer John 在某个时刻看见贝茜在位置 $(R_1, C_1)$，恰好 $T$（$0 \\lt T \\leq 15$）秒后，FJ 又在位置 $(R_2, C_2)$ 与贝茜撞了正着。FJ 并不知道在这 $T$ 秒内贝茜是否曾经到过 $(R_2, C_2)$，他能确定的只是，现在贝茜在那里。\n\n设 $S$ 为奶牛在 $T$ 秒内从 $(R_1, C_1)$ 走到 $(R_2, C_2)$ 所能选择的路径总数，FJ 希望有一个程序来帮他计算这个值。每一秒内，奶牛会水平或垂直地移动 $1$ 单位距离（奶牛总是在移动，不会在某秒内停在它上一秒所在的点）。草地上的某些地方有树，自然，奶牛不能走到树所在的位置，也不会走出草地。\n\n现在你拿到了一张整块草地的地形图，其中 `.` 表示平坦的草地，`*` 表示挡路的树。你的任务是计算出，一头在 $T$ 秒内从 $(R_1, C_1)$ 移动到 $(R_2, C_2)$ 的奶牛可能经过的路径有哪些。", "inputFormat": "第一行包含 $3$ 个用空格隔开的整数：$N,M,T$。\n\n接下来 $N$ 行：第 $i$ 行为 $M$ 个连续的字符，描述了草地第 $i$ 行各点的情况，保证字符是 `.` 和 `*` 中的一个。\n\n最后一行 $4$ 个整数 $R_1,C_1,R_2,C_2$。", "outputFormat": "输出从 $(R_1, C_1)$ 移动到 $(R_2, C_2)$ 的方案数。", "hint": "奶牛在 $6$ 秒内从 $(1,3)$ 走到 $(1,5)$ 的方法只有一种，绕过她面前的树。", "locale": "zh-CN"}}}
{"pid": "P1536", "type": "P", "difficulty": 2, "samples": [["4 2\n1 3\n4 3\n3 3\n1 2\n1 3\n2 3\n5 2\n1 2\n3 5\n999 0\n0\n", "1\n0\n2\n998\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["并查集", "连通块"], "title": "村村通", "background": "", "description": "某市调查城镇交通状况，得到现有城镇道路统计表。表中列出了每条道路直接连通的城镇。市政府 \"村村通工程\" 的目标是使全市任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要相互之间可达即可）。请你计算出最少还需要建设多少条道路？", "inputFormat": "输入包含若干组测试数据，每组测试数据的第一行给出两个用空格隔开的正整数，分别是城镇数目 $n$ 和道路数目 $m$ ；随后的 $m$ 行对应 $m$ 条道路，每行给出一对用空格隔开的正整数，分别是该条道路直接相连的两个城镇的编号。简单起见，城镇从 $1$ 到 $n$ 编号。\n\n注意：两个城市间可以有多条道路相通。\n\n**在输入数据的最后，为一行一个整数 $0$，代表测试数据的结尾。**", "outputFormat": "对于每组数据，对应一行一个整数。表示最少还需要建设的道路数目。\n", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\le n < 1000$ 。", "locale": "zh-CN", "translations": {"en": {"title": "Village-to-Village Connectivity", "background": "", "description": "A city surveyed its urban transportation and obtained a current list of roads between towns. The list enumerates which pairs of towns are directly connected by a road. The goal of the city’s \"Village-to-Village Connectivity\" project is to ensure that any two towns in the city can reach each other (there does not have to be a direct road between them, as long as they are mutually reachable). Please compute the minimum number of additional roads that still need to be built.", "inputFormat": "The input contains multiple test cases. For each test case, the first line gives two positive integers separated by a space, the number of towns $n$ and the number of roads $m$. The following $m$ lines describe the $m$ roads; each line gives a pair of positive integers separated by a space, which are the labels of the two towns directly connected by that road. For simplicity, towns are labeled from $1$ to $n$.\n\nNote: multiple roads may exist between the same pair of towns.\n\nAt the end of the input, there is a line containing a single integer $0$, which marks the end of the testdata.", "outputFormat": "For each test case, output a single integer on its own line: the minimum number of additional roads required.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, $1 \\le n < 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "村村通", "background": "", "description": "某市调查城镇交通状况，得到现有城镇道路统计表。表中列出了每条道路直接连通的城镇。市政府 \"村村通工程\" 的目标是使全市任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要相互之间可达即可）。请你计算出最少还需要建设多少条道路？", "inputFormat": "输入包含若干组测试数据，每组测试数据的第一行给出两个用空格隔开的正整数，分别是城镇数目 $n$ 和道路数目 $m$ ；随后的 $m$ 行对应 $m$ 条道路，每行给出一对用空格隔开的正整数，分别是该条道路直接相连的两个城镇的编号。简单起见，城镇从 $1$ 到 $n$ 编号。\n\n注意：两个城市间可以有多条道路相通。\n\n**在输入数据的最后，为一行一个整数 $0$，代表测试数据的结尾。**", "outputFormat": "对于每组数据，对应一行一个整数。表示最少还需要建设的道路数目。\n", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\le n < 1000$ 。", "locale": "zh-CN"}}}
{"pid": "P1537", "type": "P", "difficulty": 4, "samples": [["1 0 1 2 0 0 \r\n1 0 0 0 1 1 \r\n0 0 0 0 0 0 \r\n", "Collection #1:\r\nCan't be divided.\r\n\r\nCollection #2:\r\nCan be divided.\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP"], "title": "弹珠", "background": "", "description": "玛莎和比尔各自有自己的弹珠收藏。他们想重新分配收藏品，使两人能平等拥有弹珠。如果所有的弹珠的价值相同，那么他们就可以平分。但不幸的是，有一些弹珠更大，或者更美丽，所以，玛莎和比尔给每个弹珠一个 $1$ 到 $6$ 的价值。现在他们想平分这些弹珠，使每个人得到的总价值相同。不幸的是，他们发现，他们可能无法以这种方式分弹珠（即使弹珠的总价值为偶数）。例如，如果有一个价值为 $1$、一个价值为 $3$ 和两个价值为 $4$ 的弹珠，这样他们就不能把弹珠分为价值相等的两部分。因此，他们想要你写一个程序，告诉他们是否能将所有弹珠分成价值相等的两部分。\n", "inputFormat": "输入文件有若干行，行中包含六个非负整数 $N_1,\\cdots,N_6$，其中 $N_i$ 是价值为 $i$ 的弹珠的个数。最大弹珠总数将达到 $2\\times 10^4$。\n\n输入文件的最后一行是 `0 0 0 0 0 0`。不要处理这一行。", "outputFormat": "对于每一组数据，输出 `Collection #k:`，$k$ 为输出的是第几组，接着是 `Can be divided.` 或 `Can't be divided.`。\n\n每一组输出后多打一个空行。可以参考样例。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Marbles", "background": "", "description": "Masha and Bill each have their own marble collections. They want to redistribute the collections so that both of them have the same number of marbles. If all marbles had the same value, they could split them evenly. Unfortunately, some marbles are larger or more beautiful, so Masha and Bill assign each marble a value from $1$ to $6$. Now they want to divide the marbles so that each person receives the same total value. Unfortunately, they find that they may not be able to split the marbles this way (even if the total value of all marbles is even). For example, if there is one marble of value $1$, one of value $3$, and two of value $4$, then they cannot divide the marbles into two parts with equal value. Therefore, they want you to write a program to tell them whether it is possible to split all the marbles into two parts with equal total value.", "inputFormat": "The input contains several lines, each with six non-negative integers $N_1,\\cdots,N_6$, where $N_i$ is the number of marbles with value $i$. The maximum total number of marbles is up to $2\\times 10^4$.\n\nThe last line of the input is `0 0 0 0 0 0`. Do not process this line.", "outputFormat": "For each dataset, output `Collection #k:`, where $k$ is the dataset number starting from $1$, followed by `Can be divided.` or `Can't be divided.`.\n\nPrint an extra blank line after each dataset. You may refer to the sample.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "弹珠", "background": "", "description": "玛莎和比尔各自有自己的弹珠收藏。他们想重新分配收藏品，使两人能平等拥有弹珠。如果所有的弹珠的价值相同，那么他们就可以平分。但不幸的是，有一些弹珠更大，或者更美丽，所以，玛莎和比尔给每个弹珠一个 $1$ 到 $6$ 的价值。现在他们想平分这些弹珠，使每个人得到的总价值相同。不幸的是，他们发现，他们可能无法以这种方式分弹珠（即使弹珠的总价值为偶数）。例如，如果有一个价值为 $1$、一个价值为 $3$ 和两个价值为 $4$ 的弹珠，这样他们就不能把弹珠分为价值相等的两部分。因此，他们想要你写一个程序，告诉他们是否能将所有弹珠分成价值相等的两部分。\n", "inputFormat": "输入文件有若干行，行中包含六个非负整数 $N_1,\\cdots,N_6$，其中 $N_i$ 是价值为 $i$ 的弹珠的个数。最大弹珠总数将达到 $2\\times 10^4$。\n\n输入文件的最后一行是 `0 0 0 0 0 0`。不要处理这一行。", "outputFormat": "对于每一组数据，输出 `Collection #k:`，$k$ 为输出的是第几组，接着是 `Can be divided.` 或 `Can't be divided.`。\n\n每一组输出后多打一个空行。可以参考样例。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1538", "type": "P", "difficulty": 3, "samples": [["2\n1234567890\n", "      --   --        --   --   --   --   --   -- \n   |    |    | |  | |    |       | |  | |  | |  |\n   |    |    | |  | |    |       | |  | |  | |  |\n      --   --   --   --   --        --   --      \n   | |       |    |    | |  |    | |  |    | |  |\n   | |       |    |    | |  |    | |  |    | |  |\n      --   --        --   --        --   --   -- \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串"], "title": "迎春舞会之数字舞蹈", "background": "HNSDFZ 的同学们为了庆祝春节，准备排练一场舞会。", "description": "在越来越讲究合作的时代，人们注意的更多的不是个人物的舞姿，而是集体的排列。  \n\n为了配合每年的倒计时，同学们决定排出——“数字舞蹈”。顾名思义就是所有人一起排成若干个数字 -\\_\\_\\_-||||  更为创新的是，每个人都是趴在地上，保证横竖。  \n\n现在给出数字及其要求摆出的大小，请你编程，模拟同学们的优美姿态。\n", "inputFormat": "第一行为 $k$。$k$ 表示要摆出数字的大小。\n\n第二行为全部由数字组成的字符串，即要摆出的几个数字。", "outputFormat": "按题目要求输出。详见样例。\n", "hint": "### 数据范围及约定\n\n对于全部数据，$k \\le 30$，$ 0<|s|\\le 255$。除了第一个数字之外，每个数字之前有 $1$ 个空格，所有数字全部对齐。\n\n建议大家直接输出，不要保存。\n\n如果对于大小和 $k$ 有疑问，请自行理解。", "locale": "zh-CN", "translations": {"en": {"title": "Welcoming Spring Ball: Number Dance", "background": "The students of HNSDFZ are preparing a ball to celebrate the Spring Festival.", "description": "In an era that emphasizes cooperation, people pay more attention to collective formations than to individual dance moves.\n\nTo match the annual countdown, the students decide to form a “Number Dance.” As the name suggests, everyone lines up together to form several digits -___-||||. Even more creatively, everyone lies on the ground to ensure everything stays strictly horizontal and vertical.\n\nNow, given the digits and the required display size, please write a program to simulate the students’ elegant formations.", "inputFormat": "The first line contains $k$. The value $k$ indicates the size of the digits to be displayed.\n\nThe second line is a string consisting entirely of digits, i.e., the digits to be displayed.", "outputFormat": "Output as required. See the sample.", "hint": "Constraints\n\n- For all testdata, $k \\le 30$, $0 < |s| \\le 255$.\n- Except for the first digit, there is 1 space before each subsequent digit, and all digits must be aligned.\n\nIt is recommended to print directly and not store the output.\n\nIf you have questions about the size and $k$, please use your own understanding.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "迎春舞会之数字舞蹈", "background": "HNSDFZ 的同学们为了庆祝春节，准备排练一场舞会。", "description": "在越来越讲究合作的时代，人们注意的更多的不是个人物的舞姿，而是集体的排列。  \n\n为了配合每年的倒计时，同学们决定排出——“数字舞蹈”。顾名思义就是所有人一起排成若干个数字 -\\_\\_\\_-||||  更为创新的是，每个人都是趴在地上，保证横竖。  \n\n现在给出数字及其要求摆出的大小，请你编程，模拟同学们的优美姿态。\n", "inputFormat": "第一行为 $k$。$k$ 表示要摆出数字的大小。\n\n第二行为全部由数字组成的字符串，即要摆出的几个数字。", "outputFormat": "按题目要求输出。详见样例。\n", "hint": "### 数据范围及约定\n\n对于全部数据，$k \\le 30$，$ 0<|s|\\le 255$。除了第一个数字之外，每个数字之前有 $1$ 个空格，所有数字全部对齐。\n\n建议大家直接输出，不要保存。\n\n如果对于大小和 $k$ 有疑问，请自行理解。", "locale": "zh-CN"}}}
{"pid": "P1539", "type": "P", "difficulty": 5, "samples": [["2 3\n10.\n...\n", "5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2011", "各省省选", "快速沃尔什变换 FWT", "天津", "状压 DP"], "title": "[TJOI2011] 01矩阵", "background": "", "description": "$n\\times m$ 的 $01$ 矩阵，其中某些位置已经确定，为 '.' 的位置可以填 $0$ 或 $1$，求相邻两个位置不同为 $1$ 的矩阵方案数，答案模 $10007$。", "inputFormat": "第一行输入两个数 $n,m$。\n\n接下来输入一个 $n\\times m$ 的矩阵，由 $\\verb!0!,\\verb!1!,\\verb!.!$ 组成。", "outputFormat": "输出一个整数，为相邻两个位置不同为 $1$ 的矩阵个数。", "hint": "### 数据范围及约定\n\n对于 $100\\%$ 的数据，$n\\times m \\le 225$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2011] 01 Matrix", "background": "", "description": "An $n \\times m$ $01$ matrix, in which some positions are already fixed. Positions marked '.' can be filled with $0$ or $1$. Count the number of matrices for which the difference between any two adjacent positions is $1$ (i.e., adjacent cells sharing a side have different values), and output the answer modulo $10007$.", "inputFormat": "The first line contains two integers $n, m$.\n\nThen follows an $n \\times m$ matrix consisting of $\\verb!0!,\\verb!1!,\\verb!.!$.", "outputFormat": "Output a single integer: the number of matrices satisfying the condition, modulo $10007$.", "hint": "### Constraints and Conventions\n\nFor $100\\%$ of the testdata, $n \\times m \\le 225$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2011] 01矩阵", "background": "", "description": "$n\\times m$ 的 $01$ 矩阵，其中某些位置已经确定，为 '.' 的位置可以填 $0$ 或 $1$，求相邻两个位置不同为 $1$ 的矩阵方案数，答案模 $10007$。", "inputFormat": "第一行输入两个数 $n,m$。\n\n接下来输入一个 $n\\times m$ 的矩阵，由 $\\verb!0!,\\verb!1!,\\verb!.!$ 组成。", "outputFormat": "输出一个整数，为相邻两个位置不同为 $1$ 的矩阵个数。", "hint": "### 数据范围及约定\n\n对于 $100\\%$ 的数据，$n\\times m \\le 225$。", "locale": "zh-CN"}}}
{"pid": "P1540", "type": "P", "difficulty": 2, "samples": [["3 7\n1 2 1 5 4 4 1\n", "5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2010", "NOIP 提高组", "队列"], "title": "[NOIP 2010 提高组] 机器翻译", "background": "NOIP2010 提高组 T1", "description": "小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。\n\n这个翻译软件的原理很简单，它只是从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的中文含义，如果内存中有，软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。\n\n假设内存中有 $M$ 个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过 $M-1$，软件会将新单词存入一个未使用的内存单元；若内存中已存入 $M$ 个单词，软件会清空最早进入内存的那个单词，腾出单元来，存放新单词。\n\n假设一篇英语文章的长度为 $N$ 个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词典？假设在翻译开始前，内存中没有任何单词。", "inputFormat": "共 $2$ 行。每行中两个数之间用一个空格隔开。\n\n第一行为两个正整数 $M,N$，代表内存容量和文章的长度。\n\n第二行为 $N$ 个非负整数，按照文章的顺序，每个数（大小不超过 $1000$）代表一个英文单词。文章中两个单词是同一个单词，当且仅当它们对应的非负整数相同。", "outputFormat": "一个整数，为软件需要查词典的次数。\n", "hint": "### 样例解释\n\n整个查字典过程如下：每行表示一个单词的翻译，冒号前为本次翻译后的内存状况：\n\n1. `1`：查找单词 1 并调入内存。\n2. `1 2`：查找单词 2 并调入内存。\n3. `1 2`：在内存中找到单词 1。\n4. `1 2 5`：查找单词 5 并调入内存。\n5. `2 5 4`：查找单词 4 并调入内存替代单词 1。\n6. `2 5 4`：在内存中找到单词 4。\n7. `5 4 1`：查找单词 1 并调入内存替代单词 2。\n\n共计查了 $5$ 次词典。\n\n### 数据范围\n\n- 对于 $10\\%$ 的数据有 $M=1$，$N \\leq 5$；\n- 对于 $100\\%$ 的数据有 $1 \\leq M \\leq 100$，$1 \\leq N \\leq 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2010 Senior] Machine Translation", "background": "NOIP 2010 Senior T1.", "description": "Xiao Chen’s computer has a machine translation program, which he often uses to translate English articles.\n\nThe principle of this program is simple: it processes the article from start to finish and replaces each English word with its corresponding Chinese meaning. For each English word, the program first looks up the word in memory. If it is found in memory, the program uses it to translate; if it is not found, the program looks it up in a dictionary on external storage, obtains the Chinese meaning, performs the translation, and then inserts the word and its meaning into memory for future lookups.\n\nAssume the memory has $M$ slots, and each slot can store one word and its meaning. Before inserting a new word, if the number of words currently stored is at most $M-1$, the program stores the new word in an unused slot; if $M$ words are already stored, the program clears the word that entered memory the earliest to free a slot, and stores the new word.\n\nAssume an English article has length $N$ words. Given this article, how many times does the program need to consult the dictionary on external storage? At the start of translation, the memory is empty.", "inputFormat": "There are $2$ lines.\n\nThe first line contains two positive integers $M, N$, representing the memory capacity and the length of the article.\n\nThe second line contains $N$ non-negative integers in the order of the article; each integer (no greater than $1000$) represents an English word. Two words in the article are the same if and only if their corresponding non-negative integers are equal.\n\nNumbers on the same line are separated by a single space.", "outputFormat": "Output a single integer: the number of times the program needs to consult the dictionary.", "hint": "### Sample Explanation\n\nThe whole lookup process is as follows. Each line shows the memory state before the colon, for each word translation:\n\n1. `1`: look up word 1 and load it into memory.\n2. `1 2`: look up word 2 and load it into memory.\n3. `1 2`: find word 1 in memory.\n4. `1 2 5`: look up word 5 and load it into memory.\n5. `2 5 4`: look up word 4 and load it into memory, replacing word 1.\n6. `2 5 4`: find word 4 in memory.\n7. `5 4 1`: look up word 1 and load it into memory, replacing word 2.\n\nA total of $5$ dictionary lookups.\n\n### Constraints\n\n- For $10\\%$ of the testdata, $M=1$, $N \\leq 5$.\n- For $100\\%$ of the testdata, $1 \\leq M \\leq 100$, $1 \\leq N \\leq 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2010 提高组] 机器翻译", "background": "NOIP2010 提高组 T1", "description": "小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。\n\n这个翻译软件的原理很简单，它只是从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的中文含义，如果内存中有，软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。\n\n假设内存中有 $M$ 个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过 $M-1$，软件会将新单词存入一个未使用的内存单元；若内存中已存入 $M$ 个单词，软件会清空最早进入内存的那个单词，腾出单元来，存放新单词。\n\n假设一篇英语文章的长度为 $N$ 个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词典？假设在翻译开始前，内存中没有任何单词。", "inputFormat": "共 $2$ 行。每行中两个数之间用一个空格隔开。\n\n第一行为两个正整数 $M,N$，代表内存容量和文章的长度。\n\n第二行为 $N$ 个非负整数，按照文章的顺序，每个数（大小不超过 $1000$）代表一个英文单词。文章中两个单词是同一个单词，当且仅当它们对应的非负整数相同。", "outputFormat": "一个整数，为软件需要查词典的次数。\n", "hint": "### 样例解释\n\n整个查字典过程如下：每行表示一个单词的翻译，冒号前为本次翻译后的内存状况：\n\n1. `1`：查找单词 1 并调入内存。\n2. `1 2`：查找单词 2 并调入内存。\n3. `1 2`：在内存中找到单词 1。\n4. `1 2 5`：查找单词 5 并调入内存。\n5. `2 5 4`：查找单词 4 并调入内存替代单词 1。\n6. `2 5 4`：在内存中找到单词 4。\n7. `5 4 1`：查找单词 1 并调入内存替代单词 2。\n\n共计查了 $5$ 次词典。\n\n### 数据范围\n\n- 对于 $10\\%$ 的数据有 $M=1$，$N \\leq 5$；\n- 对于 $100\\%$ 的数据有 $1 \\leq M \\leq 100$，$1 \\leq N \\leq 1000$。", "locale": "zh-CN"}}}
