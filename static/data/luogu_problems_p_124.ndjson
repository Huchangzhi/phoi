{"pid": "P3512", "type": "P", "difficulty": 3, "samples": [["3 9\n5 1 3 5 8 6 6 9 10", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "单调队列", "POI（波兰）", "队列", "双指针 two-pointer"], "title": "[POI 2010] PIL-Pilots", "background": "POI 2010 Round III - day 2 [Pilots](https://szkopul.edu.pl/problemset/problem/lcU5m2RAICwNHsdzydb8JTQw/site/).\n\n", "description": "\n给定 $n, k$ 和一个长度为 $n$ 的序列，求最长的最大值最小值相差不超过 $k$ 的子段。", "inputFormat": "\n第一行两个由空格隔开的整数 $k, n$（$0\\leq k\\leq 2\\times 10 ^ 9$，$1\\leq n\\leq 3\\times 10 ^ 6$），$k$ 表示设定的极差的最大值，$n$ 表示序列的长度。\n\n第二行 $n$ 个由空格隔开的整数 $a_i$（$1\\leq a_i\\leq 2\\times 10^ 9$）表示序列。\n", "outputFormat": "\n一个整数表示符合条件的子段的长度最大值。\n", "hint": "样例解释：$5, 8, 6, 6$ 和 $8, 6, 6, 9$ 都是满足条件长度为 $4$ 的子段。\n\n---\n\n作者：Piotr Chrząstowski", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2010] Pilots", "background": "Source: POI 2010 Round III - day 2 [Pilots](https://szkopul.edu.pl/problemset/problem/lcU5m2RAICwNHsdzydb8JTQw/site/).\n\n", "description": "In the Byteotian Training Centre, the pilots prepare for missions requiring extraordinary precision and control. One measure of a pilot's capability is the duration he is able to fly along a desired route without deviating too much - simply put, whether he can fly steadily. This is not an easy task, as the simulator is so sensitive that it registers even a slightest move of the yoke¹. At each moment the simulator stores a single parameter describing the yoke's position. Before each training session a certain tolerance level $t$ is set. The pilots' task then is to fly as long as they can in such a way that all the yoke's position measured during the flight differ by at most $t$. In other words, a fragment of the flight starting at time $i$ and ending at time $j$ is within tolerance level $t$ if the position measurements, starting with $i$-th and ending with $j$-th, form such a sequence $a_i, \\dots, a_j$ that for all elements $a_k, a_l$ of this sequence, the inequality $|a_k - a_l| \\le t$ holds.\n\nYour task is to write a program that, given a number $t$ and the sequence of yoke's position measurements, determines the length of the longest fragment of the flight that is within the tolerance level $t$.\n\n1. Flight control device ", "inputFormat": "\nIn the first line of the standard input two integers are given, $t$ and $n$ ($0 \\le t \\le 2\\,000\\,000\\,000$, $1 \\le n \\le 3\\,000\\,000$), separated by a single space, denoting the tolerance level and the number of yoke's position measurements taken. The second line gives those measurements, separated by single spaces. Each measurement is an integer from the interval from $1$ to $2\\,000\\,000\\,000$.\n", "outputFormat": "\nYour program should print a single integer to the standard output: the maximum length of a fragment of the flight that is within the given tolerance level.", "hint": "\n### Explanation of the example:\nThere are two longest fragments, both of length 4: $5, 8, 6, 6$ and $8, 6, 6, 9$.\n\nTask Author: Piotr Chrząstowski.", "locale": "en"}, "zh-CN": {"title": "[POI 2010] PIL-Pilots", "background": "POI 2010 Round III - day 2 [Pilots](https://szkopul.edu.pl/problemset/problem/lcU5m2RAICwNHsdzydb8JTQw/site/).\n\n", "description": "\n给定 $n, k$ 和一个长度为 $n$ 的序列，求最长的最大值最小值相差不超过 $k$ 的子段。", "inputFormat": "\n第一行两个由空格隔开的整数 $k, n$（$0\\leq k\\leq 2\\times 10 ^ 9$，$1\\leq n\\leq 3\\times 10 ^ 6$），$k$ 表示设定的极差的最大值，$n$ 表示序列的长度。\n\n第二行 $n$ 个由空格隔开的整数 $a_i$（$1\\leq a_i\\leq 2\\times 10^ 9$）表示序列。\n", "outputFormat": "\n一个整数表示符合条件的子段的长度最大值。\n", "hint": "样例解释：$5, 8, 6, 6$ 和 $8, 6, 6, 9$ 都是满足条件长度为 $4$ 的子段。\n\n---\n\n作者：Piotr Chrząstowski", "locale": "zh-CN"}}}
{"pid": "P3513", "type": "P", "difficulty": 6, "samples": [["4\n2 2 3\n2 1 3\n3 1 2 4\n1 3", "3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2011", "POI（波兰）", "2-SAT", "构造"], "title": "[POI 2011] KON-Conspiracy", "background": "", "description": "Hostile Bitotia launched a sneak attack on Byteotia and occupied a significant part of its territory.\n\nThe King of Byteotia, Byteasar, intends to organise resistance movement in the occupied area.\n\nByteasar naturally started with selecting the people who will form the skeleton of the movement.\n\nThey are to be partitioned into two groups:\n\nthe conspirators who will operate directly in the occupied territory, and    the support group that will operate inside free Byteotia.\n\nThere is however one issue - the partition has to satisfy the following conditions:\n\nEvery pair of people from the support group have to know each other - this        will make the whole group cooperative and efficient.\n\nThe conspirators must not know each other.\n\nNone of the groups may be empty, i.e., there has to be at least one conspirator        and at least one person in the support group.\n\nByteasar wonders how many ways there are of partitioning selected people into    the two groups.\n\nAnd most of all, whether such partition is possible at all.\n\nAs he has absolutely no idea how to approach this problem, he asks you for help.\n\n\n", "inputFormat": "The first line of the standard input holds one integer $n$ ($2\\le n\\le 5000$),      denoting the number of people engaged in forming the resistance movement.\n\nThese people are numbered from 1 to $n$ (for the sake of conspiracy!).\n\nThe $n$ lines that follow describe who knows who in the group.\n\nThe $i$-th of these lines describes the acquaintances of the person $i$ with a sequence of integers separated by single spaces.\n\nThe first of those numbers, $k_i$ ($0\\le k_i\\le n-1$), denotes the number of acquaintances of the person $i$.\n\nNext in the line there are $k_i$ integers $a_{i,1},a_{i,2},\\cdots,a_{i,k_i}$ - the numbers of $i$'s acquaintances.The numbers $a_{i,j}$ are given in increasing order and satisfy $1\\le a_{i,j}\\le n$,$a_{i,j}\\ne i$. You may assume that if $x$ occurs in the sequence $a_i$ (i.e., among $i$'s acquaintances), then also $i$ occurs in the sequence $a_x$(i.e., among $x$'s acquaintances).\n", "outputFormat": "In the first and only line of the standard output your program should print out one integer:\n\nthe number of ways to partition selected people into the conspirators and the support group.\n\nIf there is no partition satisfying aforementioned conditions, then 0 is obviously the right answer.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2011] KON-Conspiracy", "background": "", "description": "Hostile Bitotia launched a sneak attack on Byteotia and occupied a significant part of its territory.\n\nThe King of Byteotia, Byteasar, intends to organise resistance movement in the occupied area.\n\nByteasar naturally started with selecting the people who will form the skeleton of the movement.\n\nThey are to be partitioned into two groups:\n\nthe conspirators who will operate directly in the occupied territory, and    the support group that will operate inside free Byteotia.\n\nThere is however one issue - the partition has to satisfy the following conditions:\n\nEvery pair of people from the support group have to know each other - this        will make the whole group cooperative and efficient.\n\nThe conspirators must not know each other.\n\nNone of the groups may be empty, i.e., there has to be at least one conspirator        and at least one person in the support group.\n\nByteasar wonders how many ways there are of partitioning selected people into    the two groups.\n\nAnd most of all, whether such partition is possible at all.\n\nAs he has absolutely no idea how to approach this problem, he asks you for help.\n\n\n", "inputFormat": "The first line of the standard input holds one integer $n$ ($2\\le n\\le 5000$),      denoting the number of people engaged in forming the resistance movement.\n\nThese people are numbered from 1 to $n$ (for the sake of conspiracy!).\n\nThe $n$ lines that follow describe who knows who in the group.\n\nThe $i$-th of these lines describes the acquaintances of the person $i$ with a sequence of integers separated by single spaces.\n\nThe first of those numbers, $k_i$ ($0\\le k_i\\le n-1$), denotes the number of acquaintances of the person $i$.\n\nNext in the line there are $k_i$ integers $a_{i,1},a_{i,2},\\cdots,a_{i,k_i}$ - the numbers of $i$'s acquaintances.The numbers $a_{i,j}$ are given in increasing order and satisfy $1\\le a_{i,j}\\le n$,$a_{i,j}\\ne i$. You may assume that if $x$ occurs in the sequence $a_i$ (i.e., among $i$'s acquaintances), then also $i$ occurs in the sequence $a_x$(i.e., among $x$'s acquaintances).\n", "outputFormat": "In the first and only line of the standard output your program should print out one integer:\n\nthe number of ways to partition selected people into the conspirators and the support group.\n\nIf there is no partition satisfying aforementioned conditions, then 0 is obviously the right answer.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2011] KON-Conspiracy", "background": null, "description": "敌对的 Bitotia 发动了一次对 Byteotia 的突袭，并占领了其大部分领土。\n\nByteotia 的国王 Byteasar 打算在被占领地区组织抵抗运动。\n\nByteasar 自然地从选择将组成运动骨干的人开始。\n\n他们将被分为两组：\n\n阴谋者将在被占领的领土上直接行动，而支援小组将在自由的 Byteotia 内部运作。\n\n然而，有一个问题——分组必须满足以下条件：\n\n支援小组中的每一对人必须彼此认识——这将使整个小组合作高效。\n\n阴谋者之间不能相互认识。\n\n没有一个小组可以为空，即必须至少有一个阴谋者和至少一个支援小组成员。\n\nByteasar 想知道有多少种方法可以将选定的人分成这两组。\n\n最重要的是，这样的分组是否可能。\n\n由于他完全不知道如何解决这个问题，他向你求助。", "inputFormat": "标准输入的第一行包含一个整数 $n$（$2 \\le n \\le 5000$），表示参与抵抗运动的人数。\n\n这些人被编号为 1 到 $n$（为了保密！）。\n\n接下来的 $n$ 行描述了小组中谁认识谁。\n\n第 $i$ 行描述了第 $i$ 个人的熟人，以用空格分隔的整数序列表示。\n\n这些数字中的第一个，$k_i$（$0 \\le k_i \\le n-1$），表示第 $i$ 个人的熟人数。\n\n接下来是 $k_i$ 个整数 $a_{i,1},a_{i,2},\\cdots,a_{i,k_i}$——$i$ 的熟人的编号。数字 $a_{i,j}$ 按递增顺序给出，并满足 $1 \\le a_{i,j} \\le n$，$a_{i,j} \\neq i$。可以假设如果 $x$ 出现在序列 $a_i$ 中（即在 $i$ 的熟人中），那么 $i$ 也出现在序列 $a_x$ 中（即在 $x$ 的熟人中）。", "outputFormat": "在标准输出的第一行，你的程序应输出一个整数：\n\n将选定的人分为阴谋者和支援小组的方法数。\n\n如果没有满足上述条件的分组，那么显然 $0$ 是正确答案。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3514", "type": "P", "difficulty": 5, "samples": [["5 3\nTWTWT\n5\n1\n7", "1 3\n2 2\nNIE"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "POI（波兰）", "Special Judge", "前缀和"], "title": "[POI 2011] LIZ-Lollipop", "background": "", "description": "Byteasar runs a confectionery in Byteburg.\n\nStrawberry-vanilla flavoured lollipops are the favourite of local children.\n\nThese lollipops are composed of multiple segments of the same length, each    segment of either strawberry or vanilla flavour.\n\nThe price of the lollipop is the sum of the values of its segments, where    a vanilla segment costs one bythaler, while a strawberry segments costs two.\n\nFig. 1: An exemplary lollipop of five segments,      three strawberry flavoured and two vanilla, alternately.\n\nThe price of this lollipop is $8$ bythalers.\n\nCurrently Byteasar is left with only one lollipop, though possibly very long.\n\nAs a salesman, he knows only too well that probably no one will want to buy    the whole lollipop. For this reason he thinks of breaking the lollipop at the    joints of the segments in order to get a shorter lollipop. Each fragment for    sale, of course, must stay in one piece.\n\nByteasar vast experience of a salesman, as well as his understanding of children    psychology, tell him that his young customers will most likely want to spend    all their money on a single lollipop. With this in mind, he wonders for which    values of $k$ the lollipop he has can be broken down in such a way that as a    result one would get, among other pieces, a lollipop worth exactly $k$  bythalers.\n\nNaturally, he is interested in the way of breaking the lollipop as well.\n\nAs this task overwhelms him, he asks you for help.\n\n", "inputFormat": "In the first line of the standard input there are two integers $n$ and $m$      ($1\\le n,m \\le 1\\ 000\\ 000$), separated by a single space.\n\nThese denote, respectively, the number of segments of the last lollipop left      in store, and the number of values of $k$ to consider.\n\nThe lollipop's segments are numbered from 1 to $n$.\n\nThe second line gives an $n$-letter description of the lollipop, consisting      of letters T and W, where T denotes a strawberry flavoured segment, while W - vanilla flavoured;the $i$-th of these letters specifies the flavour of the $i$-th segment.\n\nIn the following $m$ lines successive values of $k$($1\\le k\\le 2\\ 000\\ 000$) to consider are given, one per line.\n", "outputFormat": "Your program should print out exactly $m$ lines, giving, one per line,      the results for successive values of $k$, to the standard output.\n\nIf for a given value of $k$ it is impossible to break the lollipop in such a way that there is a contiguous fragment worth exactly $k$ bythalers, then the word      NIE (no in Polish) should be printed. Otherwise, two integers $l$ and $r$ ($1\\le l\\le r\\le n$), separated by single spaces, should      be printed, such that the fragment of the lollipop composed of the segments      numbered from $l$ to $r$ inclusively is worth exactly $k$ bythalers. If there are multiple such pairs, your program is free to choose one arbitrarily.\n", "hint": "\nSPJ 对于格式的要求较为严格。对于每个询问后，应紧跟一个换行符。在最后一次输出你的答案以及一个换行符后不应有任何输出。\n\n\n由 zhouyonglong 提供 SPJ。\n", "locale": "en", "translations": {"en": {"title": "[POI 2011] LIZ-Lollipop", "background": "", "description": "Byteasar runs a confectionery in Byteburg.\n\nStrawberry-vanilla flavoured lollipops are the favourite of local children.\n\nThese lollipops are composed of multiple segments of the same length, each    segment of either strawberry or vanilla flavour.\n\nThe price of the lollipop is the sum of the values of its segments, where    a vanilla segment costs one bythaler, while a strawberry segments costs two.\n\nFig. 1: An exemplary lollipop of five segments,      three strawberry flavoured and two vanilla, alternately.\n\nThe price of this lollipop is $8$ bythalers.\n\nCurrently Byteasar is left with only one lollipop, though possibly very long.\n\nAs a salesman, he knows only too well that probably no one will want to buy    the whole lollipop. For this reason he thinks of breaking the lollipop at the    joints of the segments in order to get a shorter lollipop. Each fragment for    sale, of course, must stay in one piece.\n\nByteasar vast experience of a salesman, as well as his understanding of children    psychology, tell him that his young customers will most likely want to spend    all their money on a single lollipop. With this in mind, he wonders for which    values of $k$ the lollipop he has can be broken down in such a way that as a    result one would get, among other pieces, a lollipop worth exactly $k$  bythalers.\n\nNaturally, he is interested in the way of breaking the lollipop as well.\n\nAs this task overwhelms him, he asks you for help.\n\n", "inputFormat": "In the first line of the standard input there are two integers $n$ and $m$      ($1\\le n,m \\le 1\\ 000\\ 000$), separated by a single space.\n\nThese denote, respectively, the number of segments of the last lollipop left      in store, and the number of values of $k$ to consider.\n\nThe lollipop's segments are numbered from 1 to $n$.\n\nThe second line gives an $n$-letter description of the lollipop, consisting      of letters T and W, where T denotes a strawberry flavoured segment, while W - vanilla flavoured;the $i$-th of these letters specifies the flavour of the $i$-th segment.\n\nIn the following $m$ lines successive values of $k$($1\\le k\\le 2\\ 000\\ 000$) to consider are given, one per line.\n", "outputFormat": "Your program should print out exactly $m$ lines, giving, one per line,      the results for successive values of $k$, to the standard output.\n\nIf for a given value of $k$ it is impossible to break the lollipop in such a way that there is a contiguous fragment worth exactly $k$ bythalers, then the word      NIE (no in Polish) should be printed. Otherwise, two integers $l$ and $r$ ($1\\le l\\le r\\le n$), separated by single spaces, should      be printed, such that the fragment of the lollipop composed of the segments      numbered from $l$ to $r$ inclusively is worth exactly $k$ bythalers. If there are multiple such pairs, your program is free to choose one arbitrarily.\n", "hint": "\nSPJ 对于格式的要求较为严格。对于每个询问后，应紧跟一个换行符。在最后一次输出你的答案以及一个换行符后不应有任何输出。\n\n\n由 zhouyonglong 提供 SPJ。\n", "locale": "en"}, "zh-CN": {"title": "[POI 2011] LIZ-Lollipop", "background": "", "description": "给一个只有 $1$ 和 $2$ 的序列，每次询问有没有一个子串的和为 $x$。", "inputFormat": "第一行两个整数 $n, m$（$1 \\le n, m \\le 10 ^ 6$）。\n\n第二行一个长为 $n$ 的只含 $\\texttt T$ 和 $\\texttt W$ 的字符串，$\\texttt T$ 代表 $2$，$\\texttt W$ 代表 $1$。\n\n接下来 $m$ 行，每行一个整数 $x$（$1 \\le x \\le 2\\times 10 ^ 6$）表示一次询问。", "outputFormat": "$m$ 行，如果有解则输出两个整数 $l, r$ 表示区间 $[l, r]$ 的和是 $x$，如果无解则输出字符串 `NIE`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3515", "type": "P", "difficulty": 6, "samples": [["6\n5\n3\n2\n4\n2\n4", "2\n3\n5\n3\n5\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2011", "POI（波兰）", "凸完全单调性（wqs 二分）", "四边形不等式", "栈", "决策单调性"], "title": "[POI 2011] Lightning Conductor", "background": "", "description": "Progressive climate change has forced the Byteburg authorities to build a huge lightning conductor that would protect all the buildings within the city. These buildings form a row along a single street, and are numbered from 1 to $n$.\n\nThe heights of the buildings and the lightning conductor are non - negative integers. Byteburg's limited funds allow construction of only a single lightning conductor. Moreover, as you would expect, the higher it will be, the more expensive.\n\nThe lightning conductor of height $p$ located on the roof of the building $i$ (of height $h_i$) protects the building $j$ (of height $h_j$) if the following inequality holds:\n\n$$h_j \\leq h_i + p-\\sqrt{|i - j|}$$\n\nwhere $|i - j|$ denotes the absolute value of the difference between $i$ and $j$.\n\nByteasar, the mayor of Byteburg, asks your help. Write a program that, for every building $i$, determines the minimum height of a lightning conductor that would protect all the buildings if it were put on top of the building $i$.", "inputFormat": "In the first line of the standard input there is a single integer $n$ ($1\\leq n\\leq500,000$) that denotes the number of buildings in Byteburg. Each of the following $n$ lines holds a single integer $h_i$ ($0\\leq h_i\\leq1,000,000,000$) that denotes the height of the $i$ - th building.", "outputFormat": "Your program should print out exactly $n$ lines to the standard output. The $i$ - th line should give a non - negative integer $p_i$ denoting the minimum height of the lightning conductor on the $i$ - th building. ", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2011] Lightning Conductor", "background": "", "description": "Progressive climate change has forced the Byteburg authorities to build a huge lightning conductor that would protect all the buildings within the city. These buildings form a row along a single street, and are numbered from 1 to $n$.\n\nThe heights of the buildings and the lightning conductor are non - negative integers. Byteburg's limited funds allow construction of only a single lightning conductor. Moreover, as you would expect, the higher it will be, the more expensive.\n\nThe lightning conductor of height $p$ located on the roof of the building $i$ (of height $h_i$) protects the building $j$ (of height $h_j$) if the following inequality holds:\n\n$$h_j \\leq h_i + p-\\sqrt{|i - j|}$$\n\nwhere $|i - j|$ denotes the absolute value of the difference between $i$ and $j$.\n\nByteasar, the mayor of Byteburg, asks your help. Write a program that, for every building $i$, determines the minimum height of a lightning conductor that would protect all the buildings if it were put on top of the building $i$.", "inputFormat": "In the first line of the standard input there is a single integer $n$ ($1\\leq n\\leq500,000$) that denotes the number of buildings in Byteburg. Each of the following $n$ lines holds a single integer $h_i$ ($0\\leq h_i\\leq1,000,000,000$) that denotes the height of the $i$ - th building.", "outputFormat": "Your program should print out exactly $n$ lines to the standard output. The $i$ - th line should give a non - negative integer $p_i$ denoting the minimum height of the lightning conductor on the $i$ - th building. ", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2011] Lightning Conductor", "background": "", "description": "逐渐变化的气候迫使 Byteburg 当局建造一个巨大的避雷针，以保护城市内的所有建筑物。\n\n这些建筑物沿着一条街道排成一行，编号从 $1$ 到 $n$。\n\n建筑物和避雷针的高度是非负整数。\n\nByteburg 的资金有限，只能建造一个避雷针。\n\n而且，正如你所料，避雷针越高，成本越高。\n\n位于建筑物 $i$（高度为 $h_i$）屋顶上的高度为 $k$ 的避雷针可以保护建筑物 $j$（高度为 $h_j$），如果满足以下不等式：\n\n$$k + h_i \\geq h_j + \\sqrt{|i-j|}$$\n\n其中 $|i - j|$ 表示 $i$ 和 $j$ 之间的绝对差值。\n\nByteburg 的市长 Byteasar 请求你的帮助。\n\n编写一个程序，对于每个建筑物 $i$，确定如果将避雷针放在建筑物 $i$ 上，能够保护所有建筑物的避雷针的最小高度。", "inputFormat": "标准输入的第一行有一个整数 $n$ ($1 \\leq n \\leq 500,000$)，表示 Byteburg 中的建筑物数量。\n\n接下来的 $n$ 行中的每一行包含一个整数 $h_i$ ($0 \\leq h_i \\leq 1,000,000,000$)，表示第 $i$ 个建筑物的高度。", "outputFormat": "你的程序应输出恰好 $n$ 行到标准输出。\n\n第 $i$ 行应给出一个非负整数 $k_i$，表示第 $i$ 个建筑物上避雷针的最小高度。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3516", "type": "P", "difficulty": 5, "samples": [["4\n1 3 2 4", "4\n3a 2b 2a 2b"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2011", "POI（波兰）", "Special Judge", "O2优化", "排序", "构造", "Ad-hoc"], "title": "[POI 2011] PRZ-Shift", "background": "", "description": "Byteasar bought his son Bytie a set of blocks numbered from $1$ to $n$ and arranged them in a row in a certain order.\n\nBytie's goal is to rearrange the blocks so that they are ordered naturally, from the smallest number to the largest.\n\nHowever, the only moves Bytie is allowed to make are:\n\nputting the last block at the very beginning (move a), and                  putting the third block at the very beginning (move b).\n\nHelp Bytie by writing a program that tells whether a given arrangement of    blocks can be properly reordered, and tells the right sequence of moves if it is.\n", "inputFormat": "In the first line of the standard input there is a single integer $n$, $1\\le n\\le 2\\ 000$.\n\nIn the second line there are $n$ integers from the range $1$ to $n$, separated by single spaces.\n\nNo number appears twice, and thus they represent the initial arrangement of the blocks.\n", "outputFormat": "If there is no sequence of moves leading to an arrangement with increasing blocks' numbers, your program should print out \"NIE DA SIE\" (there is no way in Polish), without the quotation marks.\n\nOtherwise there should be a single integer $m$ ($m\\le n^2$), denoting the number of operations, in the first line.\n\nAn operation is a $k$-fold execution of either a or b move.\n\nIf $m>0$, then there should be a sequence of $m$ integers with either a or b appended in the second line.\n\nThus $k$a (for $0<k<n$) denotes the $k$-fold execution of the move a.\n\nAnalogously, $k$b (for $0<k<n$) denotes the $k$-fold execution of the move b.\n\nFurthermore, the characters appended to the numbers in the second line have to alternate.\n\nShould there be more than one solution, your program is free to pick one arbitrarily.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2011] PRZ-Shift", "background": "", "description": "Byteasar bought his son Bytie a set of blocks numbered from $1$ to $n$ and arranged them in a row in a certain order.\n\nBytie's goal is to rearrange the blocks so that they are ordered naturally, from the smallest number to the largest.\n\nHowever, the only moves Bytie is allowed to make are:\n\nputting the last block at the very beginning (move a), and                  putting the third block at the very beginning (move b).\n\nHelp Bytie by writing a program that tells whether a given arrangement of    blocks can be properly reordered, and tells the right sequence of moves if it is.\n", "inputFormat": "In the first line of the standard input there is a single integer $n$, $1\\le n\\le 2\\ 000$.\n\nIn the second line there are $n$ integers from the range $1$ to $n$, separated by single spaces.\n\nNo number appears twice, and thus they represent the initial arrangement of the blocks.\n", "outputFormat": "If there is no sequence of moves leading to an arrangement with increasing blocks' numbers, your program should print out \"NIE DA SIE\" (there is no way in Polish), without the quotation marks.\n\nOtherwise there should be a single integer $m$ ($m\\le n^2$), denoting the number of operations, in the first line.\n\nAn operation is a $k$-fold execution of either a or b move.\n\nIf $m>0$, then there should be a sequence of $m$ integers with either a or b appended in the second line.\n\nThus $k$a (for $0<k<n$) denotes the $k$-fold execution of the move a.\n\nAnalogously, $k$b (for $0<k<n$) denotes the $k$-fold execution of the move b.\n\nFurthermore, the characters appended to the numbers in the second line have to alternate.\n\nShould there be more than one solution, your program is free to pick one arbitrarily.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2011] PRZ-Shift", "background": "", "description": "**译自 POI 2011 Round 1. D「[Shift](https://szkopul.edu.pl/problemset/problem/n6S4y9QrbGqYUz64e2O-OV7D/site/?key=statement)」**\n\nByteasar 给他的儿子 Bytie 买了一盒共 $ n $ 块积木，他将这些积木从 $ 1 $ 到 $ n $ 编号，并按照一定的顺序摆成一排。Bytie 要将这些积木按照编号从小到大的顺序重新排列，但他只能做下面两种操作：\n\n* 操作 a：将最后一个积木移到最前面。\n* 操作 b：把第三个积木移到最前面。\n\n我们将连续进行 $ k $ 次同一个操作称为「一块操作」，表示为 $ k a $ 或 $ k b $。  \n你需要帮助 Bytie 写一个程序，告诉他有没有一个操作序列能够使积木按照编号从小到大的顺序重新排列，并告诉他操作序列。", "inputFormat": "输入的第一行包含一个整数 $ n $，表示积木的个数。\n第二行包含 $ n $ 个整数，表示积木初始的排列顺序，没有重复的数字。", "outputFormat": "如果没有一种方案能将积木按照编号从小到大的顺序重新排列，你应当输出 `NIE DA SIE`（波兰语中的 `There is no way`）。\n\n否则，第一行你应当输出一个整数 $ m $，表示操作的**块数**，$ m $ 必须满足 $ m \\le n^2 $。  \n第二行表示这 $ m $ 块操作，每块操作之间用空格隔开。  \n每一块包含操作数 $ k $ 和操作方式，中间**没有**空格，如 `3a`（$ 3 $ 次 a 操作）。  \n需要满足相邻两块操作的种类不同，每块操作中进行的次数 $ 0 \\lt k \\lt n $。", "hint": "对于 $ 100\\% $ 的数据，$ 1 \\le n \\le 2000 $。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2158)，checker 来自于 [帖子](https://www.luogu.com.cn/discuss/70755)。", "locale": "zh-CN"}}}
{"pid": "P3517", "type": "P", "difficulty": 7, "samples": [["7 2\n2 0\n0 4\n4 4\n4 2\n8 2\n11 3\n14 2", "3.00000000\n2\n2.00000000 1.76393202\n11.00000000 1.99998199"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "倍增", "二分", "POI（波兰）", "Special Judge"], "title": "[POI 2011] WYK-Plot", "background": "", "description": "We call any sequence of points in the plane a plot.\n\nWe intend to replace a given plot $(P_1,\\cdots,P_n)$ with another that will    have at most $m$ points ($m\\le n$) in such a way that it \"resembles\" the    original plot best.\n\nThe new plot is created as follows. The sequence of points $P_1,\\cdots,P_n$ can be partitioned into $s$ ($s\\le m$) contiguous subsequences:\n\n$(P_{k_0+1},\\cdots,P_{k_1}),(P_{k_1+1},\\cdots,P_{k_2}),\\cdots,(P_{k_{s-1}+1},\\cdots,P_{k_s})$ where $0=k_0<k_1<k_2<\\cdots<k_s=n$,and afterwards each subsequence $(P_{k_{i-1}+1},\\cdots,P_{k_i})$, for $i=1,\\cdots,s$,is replaced by a new point $Q_i$.\n\nIn that case we say that each of the points $P_{k_{i-1}+1},\\cdots,P_{k_i}$ has been contracted to the point $Q_i$.\n\nAs a result a new plot, represented by the points $Q_1,\\cdots,Q_s$, is created.\n\nThe measure of such plot's resemblance to the original is the maximum distance of all the points $P_1,\\cdots,P_n$ to the point it has been contracted to:\n\n$max_{i=1,\\cdots,s}(max_{j=k_{i-1}+1,\\cdots,k_i}(d(P_j,Q_i)))$    where $d(P_j,Q_i)$ denotes the distance between $P_j$ and $Q_i$, given by the well-known formula:\n\n$d((x_1,y_1),(x_2,y_2))=\\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}$\n\n ![](https://cdn.luogu.com.cn/upload/pic/6975.png) \n\nAn exemplary plot $P_1,\\cdots,P_7$ and the new plot $(Q_1,Q_2)$, where $(P_1,\\cdots,P_4)$ are contracted to $Q_1$, whereas $(P_5,P_6,P_7)$ to $Q_2$.\n\nFor a given plot consisting of $n$ points, you are to find the plot that    resembles it most while having at most $m$ points,    where the partitioning into contiguous subsequences is arbitrary.\n\nDue to limited precision of floating point operations, a result is deemed    correct if its resemblance to the given plot is larger than the optimum    resemblance by at most $0.000001$.", "inputFormat": "In the first line of the standard input there are two integers $n$ and $m$,      $1\\le m\\le n\\le 100\\ 000$, separated by a single space.\n\nEach of the following $n$ lines holds two integers, separated by a single space.\n\nThe $(i+1)$-th line gives $x_i$,$y_i$,$-1\\ 000\\ 000\\le x_i,y_i\\le 1\\ 000\\ 000$ denoting the coordinates $(x_i,y_i)$ of the point $P_i$.\n", "outputFormat": "In the first line of the standard output one real number $d$ should be printed out,      the resemblance measure of the plot found to the original one.\n\nIn the second line of the standard output there should be another integer $s$, $1\\le s\\le m$.\n\nNext, the following $s$ lines should specify the coordinates of the points $Q_1,\\cdots,Q_s$,one point per line.\n\nThus the $(i+2)$-th line should give two real numbers $u_i$ and $v_i$,      separated by a single space, that denote the coordinates $(u_i,v_i)$ of the point $Q_i$.All the real numbers should be printed with at most 15 digits after the decimal point.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2011] WYK-Plot", "background": "", "description": "We call any sequence of points in the plane a plot.\n\nWe intend to replace a given plot $(P_1,\\cdots,P_n)$ with another that will    have at most $m$ points ($m\\le n$) in such a way that it \"resembles\" the    original plot best.\n\nThe new plot is created as follows. The sequence of points $P_1,\\cdots,P_n$ can be partitioned into $s$ ($s\\le m$) contiguous subsequences:\n\n$(P_{k_0+1},\\cdots,P_{k_1}),(P_{k_1+1},\\cdots,P_{k_2}),\\cdots,(P_{k_{s-1}+1},\\cdots,P_{k_s})$ where $0=k_0<k_1<k_2<\\cdots<k_s=n$,and afterwards each subsequence $(P_{k_{i-1}+1},\\cdots,P_{k_i})$, for $i=1,\\cdots,s$,is replaced by a new point $Q_i$.\n\nIn that case we say that each of the points $P_{k_{i-1}+1},\\cdots,P_{k_i}$ has been contracted to the point $Q_i$.\n\nAs a result a new plot, represented by the points $Q_1,\\cdots,Q_s$, is created.\n\nThe measure of such plot's resemblance to the original is the maximum distance of all the points $P_1,\\cdots,P_n$ to the point it has been contracted to:\n\n$max_{i=1,\\cdots,s}(max_{j=k_{i-1}+1,\\cdots,k_i}(d(P_j,Q_i)))$    where $d(P_j,Q_i)$ denotes the distance between $P_j$ and $Q_i$, given by the well-known formula:\n\n$d((x_1,y_1),(x_2,y_2))=\\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}$\n\n ![](https://cdn.luogu.com.cn/upload/pic/6975.png) \n\nAn exemplary plot $P_1,\\cdots,P_7$ and the new plot $(Q_1,Q_2)$, where $(P_1,\\cdots,P_4)$ are contracted to $Q_1$, whereas $(P_5,P_6,P_7)$ to $Q_2$.\n\nFor a given plot consisting of $n$ points, you are to find the plot that    resembles it most while having at most $m$ points,    where the partitioning into contiguous subsequences is arbitrary.\n\nDue to limited precision of floating point operations, a result is deemed    correct if its resemblance to the given plot is larger than the optimum    resemblance by at most $0.000001$.", "inputFormat": "In the first line of the standard input there are two integers $n$ and $m$,      $1\\le m\\le n\\le 100\\ 000$, separated by a single space.\n\nEach of the following $n$ lines holds two integers, separated by a single space.\n\nThe $(i+1)$-th line gives $x_i$,$y_i$,$-1\\ 000\\ 000\\le x_i,y_i\\le 1\\ 000\\ 000$ denoting the coordinates $(x_i,y_i)$ of the point $P_i$.\n", "outputFormat": "In the first line of the standard output one real number $d$ should be printed out,      the resemblance measure of the plot found to the original one.\n\nIn the second line of the standard output there should be another integer $s$, $1\\le s\\le m$.\n\nNext, the following $s$ lines should specify the coordinates of the points $Q_1,\\cdots,Q_s$,one point per line.\n\nThus the $(i+2)$-th line should give two real numbers $u_i$ and $v_i$,      separated by a single space, that denote the coordinates $(u_i,v_i)$ of the point $Q_i$.All the real numbers should be printed with at most 15 digits after the decimal point.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2011] WYK-Plot", "background": "", "description": "**译自 POI 2011 Round 1. E「[Plot](https://szkopul.edu.pl/problemset/problem/mzrTn1kzVBOAwVYn55LUeAai/site/?key=statement)」**\n\n给定 $n$ 个点 $ \\left( P_1, \\ldots, P_n \\right) $，将其分成不多于 $m$ 个连续的段：\n\n$$ \\left( P_{k_0 + 1}, \\ldots, P_{k_1} \\right), \\left( P_{k_1 + 1}, \\ldots, P_{k_2} \\right), \\ldots, \\left( P_{k_{s - 1}+ 1}, \\ldots, P_{k_s} \\right), $$\n\n其中 $ 0 = k_0 \\lt k_1 \\lt k_2 \\lt \\ldots \\lt k_s = n $，且对于 $ i = 1, \\ldots, s $，子序列 $ \\left( P_{k_{i - 1}+ 1}, \\ldots, P_{k_i} \\right) $ 用一个新点 $Q_i$ 替代。这时我们说 $ P_{k_i - 1}, \\ldots, P_{k_i} $ 这些点被「收缩」到了点 $Q_i$，从而产生一个新的点集 $ Q_1, \\ldots, Q_s $。两个点集的相似度定义为 $ P_1, \\ldots, P_n $ 这些点与其对应的「收缩」后的点距离的最大值：\n\n$$ \\max_{i = 1, \\ldots, s} \\left( \\max_{j = k_{i-1}+1, \\ldots, k_i}\\left( d\\left( P_j, Q_i \\right) \\right) \\right) ,$$\n\n其中 $ d\\left( P_j, Q_i \\right) $ 表示 $P_j$ 和 $Q_i$ 之间的距离，公式为：\n\n$$ d \\left( \\left(x_1, y_1 \\right), \\left( x_2, y_2 \\right) \\right) = \\sqrt{ \\left( x_2 - x_1 \\right)^2 + \\left( y_2 - y_1 \\right)^2 } $$\n\n ![](https://cdn.luogu.com.cn/upload/pic/6975.png) \n\n上图为一个将 $ (P_1, \\ldots, P_7) $ 收缩为 $ ( Q_1, Q_2 ) $ 的例子，其中 $ (P_1, \\ldots, P_4) $ 被收缩为 $ Q_1 $，$ (P_5, P_6, P_7) $ 被收缩为 $Q_2$.\n\n给定 $n$ 个点组成的序列，你需要将其「收缩」为最多 $m$ 个点，使得相似度最小。原序列可以任意切割。受限于浮点数的精度限制，只要答案比最优解多出不超过 $ 0.000001$ 即算正确。", "inputFormat": "第一行两个整数 $n$ 和 $m$，$ 1 \\le m \\le n \\le 100000 $，用一个空格分开。\n\n接下来 $n$ 行每行两个整数，用一个空格分开。第 $i+1$ 行两个整数 $x_i, y_i$（$ -1000000 \\le x_i,y_i \\le 1000000$），表示 $P_i$ 的坐标为 $(x_i, y_i)$.", "outputFormat": "第一行一个实数 $d$，表示与原序列的相似度。\n\n接下来一个整数 $s$，表示收缩后点集的大小。\n\n接下来 $s$ 行表示 $Q_i, \\ldots, Q_s$ 的坐标。每行两个整数 $u_i$ 和 $v_i$ 表示 $Q_i$ 的坐标 $ (u_i, v_i) $。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2159)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3518", "type": "P", "difficulty": 5, "samples": [["42 5\n28 31 10 38 24", "14"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "2011", "POI（波兰）", "最大公约数 gcd"], "title": "[POI 2011] SEJ-Strongbox", "background": "", "description": "Byteasar is a famous safe-cracker, who renounced his criminal activity and    got into testing and certifying anti-burglary devices.\n\nHe has just received a new kind of strongbox for tests: a combinatorial safe.\n\nA combinatorial safe is something different from a combination safe,    even though it is opened with a rotary dial.\n\nThe dial can be set in $n$ different positions, numbered from 0 to $n-1$.\n\nSetting the dial in some of these positions opens the safe, while in others it does not.\n\nAnd here is the combinatorial property, from which the name comes from:\n\nif $x$ and $y$ are opening positions, then so is $(x+y)\\ mod\\ n$ too;    note that is holds for $x=y$ as well.\n\nByteasar tried $k$ different positions of the dial: $m_1,m_2,\\cdots,m_k$.\n\nThe positions $m_1,m_2,\\cdots,m_{k-1}$ did not open the safe,only the last position $m_k$ did.\n\nByteasar is already tired from checking these $k$ positions and has thus    absolutely no intention of trying the remaining ones.\n\nHe would like to know however, based on what he already knows about the    positions he tried, what is the maximum possible number of positions that    open the safe.\n\nHelp him by writing an appropriate program!", "inputFormat": "The first line of the standard input gives two integers $n$ and $k$,      separated by a single space, $1\\le k\\le 250\\ 000$, $k\\le n\\le 10^{14}$.\n\nThe second line holds $k$ different integers, also separated by single      spaces, $m_1,m_2,\\cdots,m_k$, $0\\le m_i<n$.\n\nYou can assume that the input data correspond to a certain combinatorial      safe that complies with the description above.\n\nIn tests worth approximately 70% of the points it holds that $k\\le 1\\ 000$.\n\nIn some of those tests, worth approximately 20% of the points,      the following conditions hold in addition: $n\\le 10^8$ and $k\\le 100$.\n", "outputFormat": "Your program should print out to the first and only line of the standard output a single integer: the maximum number of the dial's positions that can open the safe.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2011] SEJ-Strongbox", "background": "", "description": "Byteasar is a famous safe-cracker, who renounced his criminal activity and    got into testing and certifying anti-burglary devices.\n\nHe has just received a new kind of strongbox for tests: a combinatorial safe.\n\nA combinatorial safe is something different from a combination safe,    even though it is opened with a rotary dial.\n\nThe dial can be set in $n$ different positions, numbered from 0 to $n-1$.\n\nSetting the dial in some of these positions opens the safe, while in others it does not.\n\nAnd here is the combinatorial property, from which the name comes from:\n\nif $x$ and $y$ are opening positions, then so is $(x+y)\\ mod\\ n$ too;    note that is holds for $x=y$ as well.\n\nByteasar tried $k$ different positions of the dial: $m_1,m_2,\\cdots,m_k$.\n\nThe positions $m_1,m_2,\\cdots,m_{k-1}$ did not open the safe,only the last position $m_k$ did.\n\nByteasar is already tired from checking these $k$ positions and has thus    absolutely no intention of trying the remaining ones.\n\nHe would like to know however, based on what he already knows about the    positions he tried, what is the maximum possible number of positions that    open the safe.\n\nHelp him by writing an appropriate program!", "inputFormat": "The first line of the standard input gives two integers $n$ and $k$,      separated by a single space, $1\\le k\\le 250\\ 000$, $k\\le n\\le 10^{14}$.\n\nThe second line holds $k$ different integers, also separated by single      spaces, $m_1,m_2,\\cdots,m_k$, $0\\le m_i<n$.\n\nYou can assume that the input data correspond to a certain combinatorial      safe that complies with the description above.\n\nIn tests worth approximately 70% of the points it holds that $k\\le 1\\ 000$.\n\nIn some of those tests, worth approximately 20% of the points,      the following conditions hold in addition: $n\\le 10^8$ and $k\\le 100$.\n", "outputFormat": "Your program should print out to the first and only line of the standard output a single integer: the maximum number of the dial's positions that can open the safe.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2011] SEJ-Strongbox", "background": null, "description": "有一个密码箱，$0$ 到 $n-1$ 中的某些整数是它的密码。且满足：若 $a$ 和 $b$ 是它的密码，则 $(a+b)\\bmod n$ 也是它的密码（$a$，$b$ 可以相等）。某人试了 $k$ 次密码，前 $k-1$ 次都失败了，最后一次成功了。\n\n问，该密码箱最多有多少种不同的密码。", "inputFormat": "第一行两个整数 $n$，$k$。\n\n第二行为 $k$ 个非负整数 $m_i$，表示每次试的密码。", "outputFormat": "一行一个整数，表示答案。", "hint": "### 数据规模与约定\n\n对于约 $20\\%$ 的数据，满足 $1\\le k\\le 100,n\\le 10^{8}$。\n\n对于约 $70\\%$ 的数据，满足 $1\\le k\\le 1000$。\n\n对于 $100\\%$ 的数据，满足 $1\\le k\\le2.5\\times10^5,k\\le n\\le 10^{14},0\\le m<n$。", "locale": "zh-CN"}}}
{"pid": "P3519", "type": "P", "difficulty": 5, "samples": [["10\naabbaaabab", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "POI（波兰）", "枚举"], "title": "[POI 2011] ROZ-Difference", "background": "", "description": "A word consisting of $n$ lower-case letters of the English alphabet ('a'-'z') is given.\n\nWe would like to choose a non-empty contiguous (i.e. one-piece) fragment    of the word so as to maximise the difference in the number of occurrences    of the most and the least frequent letter in the fragment.\n\nWe are assuming that the least frequent letter has to occur at least once in    the resulting fragment.\n\nIn particular, should the fragment contain occurrences of only one letter,    then the most and the least frequent letter in it coincide.\n\n", "inputFormat": "The first line of the standard input holds one integer $n(1\\le n \\le 1,000,000)$ that denotes the length of the word.\n\nThe second line holds a word consisting of $n$ lower-case letters      of the English alphabet.\n\nIn tests worth at least 30% of the points it additionally holds that $n\\le 100$.\n", "outputFormat": "The first and only line of the standard output is to hold a single integer,      equal to the maximum difference in the number of occurrences of the most      and the least frequent letter that is attained in some non-empty contiguous      fragment of the input word.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2011] ROZ-Difference", "background": "", "description": "A word consisting of $n$ lower-case letters of the English alphabet ('a'-'z') is given.\n\nWe would like to choose a non-empty contiguous (i.e. one-piece) fragment    of the word so as to maximise the difference in the number of occurrences    of the most and the least frequent letter in the fragment.\n\nWe are assuming that the least frequent letter has to occur at least once in    the resulting fragment.\n\nIn particular, should the fragment contain occurrences of only one letter,    then the most and the least frequent letter in it coincide.\n\n", "inputFormat": "The first line of the standard input holds one integer $n(1\\le n \\le 1,000,000)$ that denotes the length of the word.\n\nThe second line holds a word consisting of $n$ lower-case letters      of the English alphabet.\n\nIn tests worth at least 30% of the points it additionally holds that $n\\le 100$.\n", "outputFormat": "The first and only line of the standard output is to hold a single integer,      equal to the maximum difference in the number of occurrences of the most      and the least frequent letter that is attained in some non-empty contiguous      fragment of the input word.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2011] ROZ-Difference", "background": "", "description": "给定一个由 $n$ 个小写英文字母（'a'-'z'）组成的单词。\n\n我们希望选择该单词的一个非空连续（即一段）片段，以最大化该片段中出现次数最多的字母与出现次数最少的字母之间的差异。\n\n我们假设出现次数最少的字母在结果片段中至少出现一次。\n\n特别地，如果片段中只包含一种字母的出现，那么其中出现次数最多和最少的字母是相同的。", "inputFormat": "标准输入的第一行包含一个整数 $n(1\\le n \\le 1,000,000)$，表示单词的长度。\n\n第二行包含一个由 $n$ 个小写英文字母组成的单词。\n\n在至少占 30% 分数的测试中，额外保证 $n\\le 100$。", "outputFormat": "标准输出的第一行应包含一个整数，表示在输入单词的某个非空连续片段中，出现次数最多和最少的字母的最大差异。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3520", "type": "P", "difficulty": 5, "samples": [["6 8\n1 2 0 1\n2 3 1 0\n1 3 0 1\n2 4 0 0\n3 5 1 1\n4 5 0 1\n5 6 0 1\n4 6 0 1", "2\n3 1 3 2 1\n3 4 6 5 4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["图论", "2011", "POI（波兰）", "Special Judge", "欧拉回路"], "title": "[POI 2011] SMI-Garbage", "background": "", "description": "有一个可以看成无向图的城市，上面有 $n$ 个点和 $m$ 条边。\n\n每一天，有若干辆垃圾车按照**环形**来跑一圈。并且，**对于一辆垃圾车，** 除了起点以外不能跑两次。\n\n一条路有 $2$ 种状态：清洁的（用 `0` 表示）或不清洁的（用 `1` 表示）。每次垃圾车经过，都会改变这条路的状态。\n\n因为有些路上的人不交垃圾清理费，所以市长想要那些路变得不清洁；除此之外的路要清洁。那么，如何安排垃圾车，才能使得市长目的达到呢？\n\nBy @[dengziyue](/user/387840)\n\n感谢 @cn：苏卿念 提供SPJ", "inputFormat": "输入的第一行包含两个空格分隔的正整数 $n$ 和 $m$ $（ 1 \\leqslant n \\leqslant 100000，1 \\leqslant m \\leqslant 1000000）$，表示图的点数和边数。\n\n接下来 $m$ 行，每行包含四个空格分隔的正整数 $a,b,s,t $（ $1 \\leqslant a \\leqslant b \\leqslant n $ , $s，t \\in \\lbrace0,1\\rbrace$  ） ，表示一条联结结点 $a$ 与 $b$ 的边，初始颜色和目标颜色分别为 $s$ 与 $t$ 。\n\n你可以认为若存在合法方案，则存在一个卡车经过总边数不超过 $5m$ 的方案。\n\n对于 $60\\%$ 分数的数据，有 $ m \\leqslant 10000$。", "outputFormat": "如果不存在合法方案，输出一行 `NIE`（波兰语「否」）；\n\n否则按下列格式输出任意一种方案：\n\n- 第一行包含一个整数 $k$，表示卡车行驶环路的总数；\n- 接下来 $k$ 行，每行描述一条环路：\n   - 首先是一个正整数 $k_i$ 表示环路经过的边数，后接一个空格；\n  - 接下来 $ k_i + 1 $ 个空格分隔的整数，依次表示环路上结点的编号。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2011] SMI-Garbage", "background": "# Description\n\nThere is a city that can be regarded as an undirected graph with $n$ vertices and $m$ edges.\n\nEvery day, several garbage trucks each travel one loop along a cycle. Moreover, for any one garbage truck, it cannot visit any vertex twice except returning to its starting vertex at the end.\n\nEach road has 2 states: clean (denoted by `0`) or dirty (denoted by `1`). Every time a garbage truck passes an edge, the state of that edge toggles.\n\nBecause some people on certain roads do not pay the garbage collection fee, the mayor wants those roads to become dirty; all other roads should be clean. How should we schedule the garbage trucks to achieve the mayor’s goal?\n\nBy @[dengziyue](/user/387840)\n\nThanks to @cn: 苏卿念 for providing the SPJ.", "description": "There is a city that can be regarded as an undirected graph with $n$ vertices and $m$ edges.\n\nEvery day, several garbage trucks each travel one loop along a cycle. Moreover, for any one garbage truck, it cannot visit any vertex twice except returning to its starting vertex at the end.\n\nEach road has 2 states: clean (denoted by `0`) or dirty (denoted by `1`). Every time a garbage truck passes an edge, the state of that edge toggles.\n\nBecause some people on certain roads do not pay the garbage collection fee, the mayor wants those roads to become dirty; all other roads should be clean. How should we schedule the garbage trucks to achieve the mayor’s goal?\n\nBy @[dengziyue](/user/387840)\n\nThanks to @cn: 苏卿念 for providing the SPJ.\n\n# Description", "inputFormat": "The first line contains two positive integers $n$ and $m$ $（ 1 \\leqslant n \\leqslant 100000，1 \\leqslant m \\leqslant 1000000）$, the number of vertices and edges of the graph.\n\nThe next $m$ lines each contain four space-separated integers $a, b, s, t$ （ $1 \\leqslant a \\leqslant b \\leqslant n $ , $s，t \\in \\lbrace0,1\\rbrace$ ）, describing an edge connecting vertices $a$ and $b$, whose initial state and target state are $s$ and $t$, respectively.\n\nYou may assume that if a valid plan exists, then there is a plan in which the total number of edges traversed by all trucks does not exceed $5m$.\n\nFor $60\\%$ of the testdata, $ m \\leqslant 10000$.", "outputFormat": "If no valid plan exists, output a single line `NIE` (Polish for \"no\").\n\nOtherwise, output any valid plan in the following format:\n- The first line contains an integer $k$, the total number of cycles (routes) traveled by the trucks.\n- Then output $k$ lines, each describing one cycle:\n  - First, a positive integer $k_i$ indicating the number of edges on the cycle, followed by a space;\n  - Then $ k_i + 1 $ integers separated by spaces, giving the vertex indices along the cycle in order.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2011] SMI-Garbage", "background": "", "description": "有一个可以看成无向图的城市，上面有 $n$ 个点和 $m$ 条边。\n\n每一天，有若干辆垃圾车按照**环形**来跑一圈。并且，**对于一辆垃圾车，** 除了起点以外不能跑两次。\n\n一条路有 $2$ 种状态：清洁的（用 `0` 表示）或不清洁的（用 `1` 表示）。每次垃圾车经过，都会改变这条路的状态。\n\n因为有些路上的人不交垃圾清理费，所以市长想要那些路变得不清洁；除此之外的路要清洁。那么，如何安排垃圾车，才能使得市长目的达到呢？\n\nBy @[dengziyue](/user/387840)\n\n感谢 @cn：苏卿念 提供SPJ", "inputFormat": "输入的第一行包含两个空格分隔的正整数 $n$ 和 $m$ $（ 1 \\leqslant n \\leqslant 100000，1 \\leqslant m \\leqslant 1000000）$，表示图的点数和边数。\n\n接下来 $m$ 行，每行包含四个空格分隔的正整数 $a,b,s,t $（ $1 \\leqslant a \\leqslant b \\leqslant n $ , $s，t \\in \\lbrace0,1\\rbrace$  ） ，表示一条联结结点 $a$ 与 $b$ 的边，初始颜色和目标颜色分别为 $s$ 与 $t$ 。\n\n你可以认为若存在合法方案，则存在一个卡车经过总边数不超过 $5m$ 的方案。\n\n对于 $60\\%$ 分数的数据，有 $ m \\leqslant 10000$。", "outputFormat": "如果不存在合法方案，输出一行 `NIE`（波兰语「否」）；\n\n否则按下列格式输出任意一种方案：\n\n- 第一行包含一个整数 $k$，表示卡车行驶环路的总数；\n- 接下来 $k$ 行，每行描述一条环路：\n   - 首先是一个正整数 $k_i$ 表示环路经过的边数，后接一个空格；\n  - 接下来 $ k_i + 1 $ 个空格分隔的整数，依次表示环路上结点的编号。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3521", "type": "P", "difficulty": 6, "samples": [["3\n0\n0\n3\n1\n2\n", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2011", "线段树", "POI（波兰）", "O2优化", "线段树合并"], "title": "[POI 2011] ROT-Tree Rotations", "background": "", "description": "给定一颗有 $n$ 个**叶节点**的二叉树。每个叶节点都有一个权值 $p_i$（注意，根不是叶节点），所有叶节点的权值构成了一个 $1 \\sim n$ 的排列。  \n对于这棵二叉树的任何一个结点，保证其要么是叶节点，要么左右两个孩子都存在。  \n现在你可以任选一些节点，交换这些节点的左右子树。  \n在最终的树上，按照先序遍历遍历整棵树并依次写下遇到的叶结点的权值构成一个长度为 $n$ 的排列，你需要最小化这个排列的逆序对数。", "inputFormat": "第一行是一个整数 $n$，表示树的叶节点个数。  \n接下来若干行，使用递归的形式来读入这棵树，读入任意一个子树的信息时，初始时读入其根节点。对于一个结点 $u$，首先有一行一个整数 $x$。\n- 若 $x \\neq 0$，则表示 $u$ 是一个叶节点，其权值为 $x$。\n- 若 $x = 0$，则表示 $u$ 不是叶节点，则接下来若干行读入其左子树信息，左子树读入结束后接下来若干行读入其右子树信息。", "outputFormat": "输出一行一个整数表示最小的逆序对数。", "hint": "### 样例 1 解释\n\n下图中，左图是初始读入的树，右图是操作后的树。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/r84e2l05.png)\n\n### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n \\leq 5 \\times 10^3$。\n- 对于 $100\\%$ 的数据，保证 $2 \\leq n \\leq 2 \\times 10^5$， $0 \\leq x \\leq n$，所有叶节点的权值是一个 $1 \\sim n$ 的排列。\n\n### 提示\n\n请注意，$n$ **不是**树的结点个数。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2011] ROT-Tree Rotations", "background": "", "description": "You are given a binary tree with $n$ leaves. Each leaf has a weight $p_i$ (note: the root is not a leaf), and the weights of all leaves form a permutation of $1 \\sim n$.  \nFor any node in this binary tree, it is guaranteed that it is either a leaf, or it has both left and right children.  \nYou may choose any set of nodes and swap their left and right subtrees.  \nOn the final tree, perform a preorder traversal of the whole tree and record the weights of the encountered leaves to form a permutation of length $n$. You need to minimize the number of inversions of this permutation.", "inputFormat": "The first line contains an integer $n$, the number of leaves.  \nIn the following lines, the tree is read recursively. When reading any subtree, start with its root. For a node $u$, first read an integer $x$ on a separate line.\n- If $x \\neq 0$, then $u$ is a leaf and its weight is $x$.\n- If $x = 0$, then $u$ is an internal node; next read the information of its left subtree, and then the information of its right subtree.", "outputFormat": "Output a single integer, the minimal number of inversions.", "hint": "Explanation for Sample 1:\n\nIn the figure below, the left is the initial tree, and the right is the tree after the operations.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/r84e2l05.png)\n\nConstraints:\n- For $30\\%$ of the testdata, $n \\leq 5 \\times 10^3$.\n- For $100\\%$ of the testdata, $2 \\leq n \\leq 2 \\times 10^5$, $0 \\leq x \\leq n$, and the weights of all leaves form a permutation of $1 \\sim n$.\n\nNote:\nPlease note that $n$ is not the number of nodes in the tree.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2011] ROT-Tree Rotations", "background": "", "description": "给定一颗有 $n$ 个**叶节点**的二叉树。每个叶节点都有一个权值 $p_i$（注意，根不是叶节点），所有叶节点的权值构成了一个 $1 \\sim n$ 的排列。  \n对于这棵二叉树的任何一个结点，保证其要么是叶节点，要么左右两个孩子都存在。  \n现在你可以任选一些节点，交换这些节点的左右子树。  \n在最终的树上，按照先序遍历遍历整棵树并依次写下遇到的叶结点的权值构成一个长度为 $n$ 的排列，你需要最小化这个排列的逆序对数。", "inputFormat": "第一行是一个整数 $n$，表示树的叶节点个数。  \n接下来若干行，使用递归的形式来读入这棵树，读入任意一个子树的信息时，初始时读入其根节点。对于一个结点 $u$，首先有一行一个整数 $x$。\n- 若 $x \\neq 0$，则表示 $u$ 是一个叶节点，其权值为 $x$。\n- 若 $x = 0$，则表示 $u$ 不是叶节点，则接下来若干行读入其左子树信息，左子树读入结束后接下来若干行读入其右子树信息。", "outputFormat": "输出一行一个整数表示最小的逆序对数。", "hint": "### 样例 1 解释\n\n下图中，左图是初始读入的树，右图是操作后的树。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/r84e2l05.png)\n\n### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n \\leq 5 \\times 10^3$。\n- 对于 $100\\%$ 的数据，保证 $2 \\leq n \\leq 2 \\times 10^5$， $0 \\leq x \\leq n$，所有叶节点的权值是一个 $1 \\sim n$ 的排列。\n\n### 提示\n\n请注意，$n$ **不是**树的结点个数。", "locale": "zh-CN"}}}
{"pid": "P3522", "type": "P", "difficulty": 5, "samples": [["6\n6 10\n1 5\n4 8\n2 5\n6 8\n3 5", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2011", "单调队列", "POI（波兰）", "队列"], "title": "[POI 2011] TEM-Temperature", "background": null, "description": "Byteotian 气象研究所（BIM）每天测量气温。\n\n测量是自动完成的，其结果会立即打印出来。\n\n不幸的是，打印机里的墨水早就干了...\n\n然而，BIM的员工直到最近才意识到这一事实，当时Byteotian气象组织（BOM）要求访问这些数据。\n\n一位名叫 Byteasar 的实习生挽救了局面，他系统地记录了 BIM 大楼南北外墙上放置的两个家用酒精温度计报告的温度。\n\n几十年前，多位 BIM 员工就已经确立，建筑南墙上的温度计报告的温度永远不会低于实际温度，而建筑北墙上的温度计则永远不会高于实际温度。\n\n因此，尽管每天的确切温度仍然有些神秘，但它们所处的范围至少是已知的。\n\n幸运的是，对于所有参与者（也许除了 Byteasar 和你）来说，BOM 不需要精确的温度。他们只想知道温度没有下降的最长时间（即连续每天的温度都不低于前一天）。\n\n事实上，BIM 的资深负责人非常清楚，BOM希望这段时间尽可能长。\n\n为了粉饰这一疏忽，他坚持要求拜塔萨尔根据他珍贵的笔记，确定气温可能没有下降的最长时间。\n\n现在，这是 Byteasar 在 BIM 实习期间没有预料到的任务，老实说，他不知道如何解决这个问题。\n\n他请求你帮助编写一个程序，以确定最长的此类时间。", "inputFormat": "在标准输入的第一行中，有一个整数 $n(1\\le n\\le 10^6)$，表示 Byteasar 记录温度的天数。\n\n第 $i+1$ 行给出了当天的测量值。每行包含两个整数，$x$ 和 $y(-10^9\\le x\\le y\\le 10^9)$。这些分别表示两个温度计报告的特定日期的最低和最高可能温度。\n\n在某些总计 $50$ 分的测试中，温度从未降至 $-50$（摄氏度，如果你想知道的话！），也从未超过 $50$。", "outputFormat": null, "hint": "对于 $50\\%$ 的数据，保证 $-50 \\le x,y \\le 50$。\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 10^6$，$-10^9\\le x\\le y\\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": null, "background": null, "description": "The Byteotian Institute of Meteorology (BIM) measures the air temperature  daily.\n\nThe measurement is done automatically, and its result immediately printed.\n\nUnfortunately, the ink in the printer has long dried out...\n\nThe employees of BIM however realised the fact only recently, when the    Byteotian Organisation for Meteorology (BOM) requested access to that data.\n\nAn eager intern by the name of Byteasar saved the day, as he systematically    noted down the temperatures reported by two domestic alcohol thermometers    placed on the north and south outside wall of the BIM building.\n\nIt was established decades ago by various BIM employees that the temperature    reported by the thermometer on the south wall of the building is never lower    than the actual temperature, while that reported by the thermometer on the    north wall of the building is never higher than the actual temperature.\n\nThus even though the exact temperatures for each day remain somewhat of    a mystery, the range they were in is known at least.\n\nFortunately for everyone involved (except Byteasar and you, perhaps),    BOM does not require exact temperatures. They only want to know the longest    period in which the temperature was not dropping (i.e. on each successive    day it was no smaller than on the day before).\n\nIn fact, the veteran head of BIM knows very well that BOM would like this    period as long as possible.\n\nTo whitewash the negligence he insists that Byteasar determines, based on    his valuable notes, the longest period in which the temperature    could have been not dropping.\n\nNow this is a task that Byteasar did not quite expect on his BIM internship,    and he honestly has no idea how to tackle it.\n\nHe asks you for help in writing a program that determines the longest such    period.", "inputFormat": "In the first line of the standard input there is one integer  $ n $ ( $ 1 \\le n \\le 1,000,000 $) that denotes the number of days for which Byteasar took notes on the temperature. The measurements from day are given in the  $ {(i + 1)}$-th line . Each of those lines holds two integers,  $ x $ and  $ y $ ( $ -10^9 \\le x \\le y \\le 10^9 $). These denote, respectively, the minimum and maximum possible temperature on that particular day, as reported by the two thermometers.\n\nIn some of the tests, worth 50 points in total, the temperatures never drop below  $ -50 $ degrees (Celsius, in case you wonder!) and never exceeds  $ 50 $ degrees ( $ -50 \\le x \\le y \\le 50 $).", "outputFormat": "In the first and only line of the standard output your program should print a single integer, namely the maximum number of days for which the temperature in Byteotia could have been not dropping.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[POI 2011] TEM-Temperature", "background": null, "description": "Byteotian 气象研究所（BIM）每天测量气温。\n\n测量是自动完成的，其结果会立即打印出来。\n\n不幸的是，打印机里的墨水早就干了...\n\n然而，BIM的员工直到最近才意识到这一事实，当时Byteotian气象组织（BOM）要求访问这些数据。\n\n一位名叫 Byteasar 的实习生挽救了局面，他系统地记录了 BIM 大楼南北外墙上放置的两个家用酒精温度计报告的温度。\n\n几十年前，多位 BIM 员工就已经确立，建筑南墙上的温度计报告的温度永远不会低于实际温度，而建筑北墙上的温度计则永远不会高于实际温度。\n\n因此，尽管每天的确切温度仍然有些神秘，但它们所处的范围至少是已知的。\n\n幸运的是，对于所有参与者（也许除了 Byteasar 和你）来说，BOM 不需要精确的温度。他们只想知道温度没有下降的最长时间（即连续每天的温度都不低于前一天）。\n\n事实上，BIM 的资深负责人非常清楚，BOM希望这段时间尽可能长。\n\n为了粉饰这一疏忽，他坚持要求拜塔萨尔根据他珍贵的笔记，确定气温可能没有下降的最长时间。\n\n现在，这是 Byteasar 在 BIM 实习期间没有预料到的任务，老实说，他不知道如何解决这个问题。\n\n他请求你帮助编写一个程序，以确定最长的此类时间。", "inputFormat": "在标准输入的第一行中，有一个整数 $n(1\\le n\\le 10^6)$，表示 Byteasar 记录温度的天数。\n\n第 $i+1$ 行给出了当天的测量值。每行包含两个整数，$x$ 和 $y(-10^9\\le x\\le y\\le 10^9)$。这些分别表示两个温度计报告的特定日期的最低和最高可能温度。\n\n在某些总计 $50$ 分的测试中，温度从未降至 $-50$（摄氏度，如果你想知道的话！），也从未超过 $50$。", "outputFormat": null, "hint": "对于 $50\\%$ 的数据，保证 $-50 \\le x,y \\le 50$。\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 10^6$，$-10^9\\le x\\le y\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P3523", "type": "P", "difficulty": 6, "samples": [["7 2\n1 0 1 1 0 1 1\n1 3\n2 3\n3 4\n4 5\n5 6\n5 7", "1\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "贪心", "2011", "二分", "POI（波兰）", "树形 DP"], "title": "[POI 2011] DYN-Dynamite", "background": "", "description": "The Byteotian Cave is composed of $n$ chambers and $n-1$ corridors that       connect them.  For every pair of chambers there is unique way to move       from one of them to another without leaving the cave.\n\nDynamite charges are set up in certain chambers.\n\nA fuse is laid along every corridor.\n\nIn every chamber the fuses from the adjacent corridors meet at one point,       and are further connected to the dynamite charge if there is one in the       chamber.  It takes exactly one unit of time for the fuse between two       neighbouring chambers to burn, and the dynamite charge explodes in the       instant that fire reaches the chamber it is inside.\n\nWe would like to light the fuses in some $m$ chambers (at the joints of       fuses) in such a way that all the dynamite charges explode in the shortest       time possible since the fuses are lit.  Write a program that will determine       the minimum such time possible.\n", "inputFormat": "The first line of the standard input holds two integers $n$ and $m$($1\\le m\\le n\\le 300\\ 000$), separated by a single space, that denote, respectively, the number of chambers in the cave and the number of chambers in which fire can be set to the fuses.\n\nThe chambers are numbered from 1 to $n$.\n\nThe next line contains $n$ integers $d_1,d_2,\\cdots,d_n$ ($d_i\\in \\{0,1\\}$), separated by single spaces.\n\nIf $d_i=1$, then there is dynamite in the $i$-th chamber, and if $d_i=0$, there is none.The following $n-1$ lines specify the corridors of the cave. Each of them holds two integers $a,b$($1\\le a<b\\le n$), separated by a single space, denoting that there is a corridor connecting the chambers $a$ and $b$. Every corridor appears exactly once in the description.\n\nYou may assume that in tests worth 10% of the points it holds additionally that $n\\le 10$ , while in tests worth 40% of the points it holds that $n\\le 1\\ 000$\n", "outputFormat": "The first and only line of the standard output should hold a single         integer, equal to the minimum time it takes from lighting the fuses         to the explosion of all the charges.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2011] DYN-Dynamite", "background": "", "description": "The Byteotian Cave is composed of $n$ chambers and $n-1$ corridors that       connect them.  For every pair of chambers there is unique way to move       from one of them to another without leaving the cave.\n\nDynamite charges are set up in certain chambers.\n\nA fuse is laid along every corridor.\n\nIn every chamber the fuses from the adjacent corridors meet at one point,       and are further connected to the dynamite charge if there is one in the       chamber.  It takes exactly one unit of time for the fuse between two       neighbouring chambers to burn, and the dynamite charge explodes in the       instant that fire reaches the chamber it is inside.\n\nWe would like to light the fuses in some $m$ chambers (at the joints of       fuses) in such a way that all the dynamite charges explode in the shortest       time possible since the fuses are lit.  Write a program that will determine       the minimum such time possible.\n", "inputFormat": "The first line of the standard input holds two integers $n$ and $m$($1\\le m\\le n\\le 300\\ 000$), separated by a single space, that denote, respectively, the number of chambers in the cave and the number of chambers in which fire can be set to the fuses.\n\nThe chambers are numbered from 1 to $n$.\n\nThe next line contains $n$ integers $d_1,d_2,\\cdots,d_n$ ($d_i\\in \\{0,1\\}$), separated by single spaces.\n\nIf $d_i=1$, then there is dynamite in the $i$-th chamber, and if $d_i=0$, there is none.The following $n-1$ lines specify the corridors of the cave. Each of them holds two integers $a,b$($1\\le a<b\\le n$), separated by a single space, denoting that there is a corridor connecting the chambers $a$ and $b$. Every corridor appears exactly once in the description.\n\nYou may assume that in tests worth 10% of the points it holds additionally that $n\\le 10$ , while in tests worth 40% of the points it holds that $n\\le 1\\ 000$\n", "outputFormat": "The first and only line of the standard output should hold a single         integer, equal to the minimum time it takes from lighting the fuses         to the explosion of all the charges.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2011] DYN-Dynamite", "background": null, "description": "Byteotian 洞穴由 $n$ 个房间和连接它们的 $n-1$ 条走廊组成。对于每一对房间，有一条唯一的路径可以在不离开洞穴的情况下从一个房间移动到另一个房间。\n\n某些房间中设置了炸药。\n\n每条走廊上都铺设了导火索。\n\n在每个房间中，相邻走廊的导火索在一个点相遇，并进一步连接到房间内的炸药（如果房间内有炸药）。导火索在两个相邻房间之间燃烧需要恰好一个时间单位，当火焰到达房间时，房间内的炸药立即爆炸。\n\n我们希望在 $m$ 个房间（导火索的连接点）点燃导火索，使得所有炸药在点燃导火索后以最短的时间爆炸。编写一个程序来确定可能的最短时间。", "inputFormat": "标准输入的第一行包含两个整数 $n$ 和 $m$（$1 \\le m \\le n \\le 300\\ 000$），用一个空格分隔，分别表示洞穴中的房间数量和可以点燃导火索的房间数量。\n\n房间从 $1$ 到 $n$ 编号。\n\n下一行包含 $n$ 个整数 $d_1,d_2,\\cdots,d_n$（$d_i \\in \\{0,1\\}$），用空格分隔。\n\n如果 $d_i=1$，则第 $i$ 个房间中有炸药，如果 $d_i=0$，则没有。接下来的 $n-1$ 行指定了洞穴的走廊。每行包含两个整数 $a,b$（$1 \\le a < b \\le n$），用空格分隔，表示有一条走廊连接房间 $a$ 和 $b$。每条走廊在描述中恰好出现一次。", "outputFormat": "标准输出的第一行应包含一个整数，表示从点燃导火索到所有炸药爆炸所需的最短时间。", "hint": "对于 $10\\%$ 的数据，$1 \\le n \\le 10$。\n\n对于 $40\\%$ 的数据，$1 \\le n \\le 10^3$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3524", "type": "P", "difficulty": 4, "samples": [["6 10\n2 5\n1 4\n1 5\n2 4\n1 3\n4 5\n4 6\n3 5\n3 4\n3 6", "2 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "POI（波兰）", "Special Judge", "构造"], "title": "[POI 2011] IMP-Party", "background": "本题数据极大，评测时可能需要较长时间等待。", "description": "```plain\nByteasar intends to throw up a party.\n```\nNaturally, he would like it to be a success.  Furthermore, Byteasar is quite certain that to make it so it suffices if all invited guests  know each other.  He is currently trying to come up with a list of his friends he would like to invite.\n\nByteasar has $n$ friends, where $n$ is divisible by 3.\n\n```plain\nFortunately, most of Byteasar's friends know one another.\n```\nFurthermore, Byteasar recalls that he once attended a party where there were $\\frac{2}{3}n$ of his friends, and where everyone knew everyone else.\n\nUnfortunately, Byteasar does not quite remember anything else from that    party.\n\n\nIn particular, he has no idea which of his friends attended it.\n\nByteasar does not feel obliged to throw a huge party, but he would like to    invite at least \\frac{n}{3} of his friends.\n\n\n\nHe has no idea how to choose them, so he asks you for help.", "inputFormat": "In the first line of the standard input two integers, $n$ and $m$ ($3\\le n\\le 3\\ 000$, $\\frac{\\frac{2}{3}n(\\frac{2}{3}n-1)}{2}\\leq m\\leq \\frac{n(n-1)}{2}$), are given,separated by a single space.  These denote the number of Byteasar's friends and the number of pairs of his friends who know each other, respectively.\n\nByteasar's friends are numbered from 1 to $n$.\n\nEach of the following $m$ lines holds two integers separated by a single      space.\n\nThe numbers in line no. $i+1$ (for $i=1,2,...,m$) are $a_i$ and $b_i$($1\\le a_i<b_i\\le n$), separated by a single space, which denote that the persons $a_i$ and $b_i$ know each other. Every pair of numbers appears at most once on the input.\n", "outputFormat": "In the first and only line of the standard output your program should      print $\\frac{n}{3}$ numbers, separated by single spaces, in increasing      order.  These number should specify the numbers of Byteasar's friends whom      he should invite to the party.  As there are multiple solutions, pick one      arbitrarily.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2011] IMP-Party", "background": "本题数据极大，评测时可能需要较长时间等待。", "description": "```plain\nByteasar intends to throw up a party.\n```\nNaturally, he would like it to be a success.  Furthermore, Byteasar is quite certain that to make it so it suffices if all invited guests  know each other.  He is currently trying to come up with a list of his friends he would like to invite.\n\nByteasar has $n$ friends, where $n$ is divisible by 3.\n\n```plain\nFortunately, most of Byteasar's friends know one another.\n```\nFurthermore, Byteasar recalls that he once attended a party where there were $\\frac{2}{3}n$ of his friends, and where everyone knew everyone else.\n\nUnfortunately, Byteasar does not quite remember anything else from that    party.\n\n\nIn particular, he has no idea which of his friends attended it.\n\nByteasar does not feel obliged to throw a huge party, but he would like to    invite at least \\frac{n}{3} of his friends.\n\n\n\nHe has no idea how to choose them, so he asks you for help.", "inputFormat": "In the first line of the standard input two integers, $n$ and $m$ ($3\\le n\\le 3\\ 000$, $\\frac{\\frac{2}{3}n(\\frac{2}{3}n-1)}{2}\\leq m\\leq \\frac{n(n-1)}{2}$), are given,separated by a single space.  These denote the number of Byteasar's friends and the number of pairs of his friends who know each other, respectively.\n\nByteasar's friends are numbered from 1 to $n$.\n\nEach of the following $m$ lines holds two integers separated by a single      space.\n\nThe numbers in line no. $i+1$ (for $i=1,2,...,m$) are $a_i$ and $b_i$($1\\le a_i<b_i\\le n$), separated by a single space, which denote that the persons $a_i$ and $b_i$ know each other. Every pair of numbers appears at most once on the input.\n", "outputFormat": "In the first and only line of the standard output your program should      print $\\frac{n}{3}$ numbers, separated by single spaces, in increasing      order.  These number should specify the numbers of Byteasar's friends whom      he should invite to the party.  As there are multiple solutions, pick one      arbitrarily.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2011] IMP-Party", "background": null, "description": "**译自 POI 2011 Round 3. Day 1. A「[Party](https://szkopul.edu.pl/problemset/problem/PCtteC6gKwc2ZikW8nUZzfyh/site/?key=statement)」**\n\nByteasar 打算举行一次聚会。他自然想要这次聚会成功进行。此外，Byteasar 确信只要邀请的嘉宾都互相认识就可以了。他目前在试着写一份邀请名单。\n\nByteasar 有 $n$ 个朋友，这里 $n$ 可以被 $3$ 整除。幸运的是，Byteasar 的朋友大部分都互相认识。并且 Byteasar 想起了一次他参加的聚会，那次聚会有 $ \\frac{2}{3}n $ 个他的朋友参加，并且他们都互相认识。不幸的是，关于那次聚会的具体细节他不记得了……总的来说，他忘了是他的哪些朋友参加了。\n\nByteasar 认为他没有义务举办一个大型聚会，但他想邀请 $ \\frac{n}{3} $ 个他的朋友。他不知道邀请谁，所以请你帮他。", "inputFormat": "输入的第一行包含两个整数 $n,m$，表示 Byteasar 的朋友数和互相认识的朋友对数；\n\n接下来 $m$ 行，每行两个整数 $a_i,b_i$， 表示朋友 $a_i,b_i$ 互相认识。每一对数最多在输入中出现一次。", "outputFormat": "按编号升序，输出一行 $ \\frac{n}{3} $ 个数，表示 Byteasar 要邀请的朋友编号。如果有多组解，输出任意一组均可。\n\n### 样例解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yjpf686v.png)\n\n编号为 $1,3,4,5$ 的朋友互相认识。然而对于任意一对互相认识的朋友，如 $2,4$，都可以作为正确答案。即，这一对朋友并不一定来自于之前提到的那个四元组。", "hint": "对于全部数据，$ 3 \\le n \\le 3000 , \\frac{\\frac{2}{3}n(\\frac{2}{3}n-1)}{2} \\le m \\le \\frac{n(n-1)}{2}, 1 \\le a_i \\lt b_i \\le n $。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2166)。", "locale": "zh-CN"}}}
{"pid": "P3525", "type": "P", "difficulty": 5, "samples": [["9\n3 6\n2 4\n2 6\n2 5\n1 7\n2 7\n8 9\n7 8", "-1\n23\n-1\n-1\n-1\n-1\n-1\n-1\n-1"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "树形数据结构", "2011", "POI（波兰）"], "title": "[POI 2011] INS-Inspection", "background": "", "description": "The railway network of the Byteotian Railways (BR) consists of bidirectional    tracks connecting certain pairs of stations.\n\nEach pair of stations is connected by at most one segment of tracks.\n\nFurthermore, there is a unique route from every station to every other station.\n\n(The route may consist of several segments of tracks, but it may not pass through any station more than once.) Byteasar is an undercover inspector of the BR.\n\nHis job is to pick one of the stations (denote it by $S$) for centre of his operations and to travel to all other stations.\n\nHis journey should be as follows:\n\nByteasar starts in station $S$.\n\nNext, he picks one of the stations he did not yet control and goes to it along the shortest path (by train, of course), inspects the station, and        then goes back to $S$.\n\nThe crooked employees of BR warn one another of Byteasar's comings.\n\nTo deceive them, Byteasar picks the next station for control in such a way that he sets off from the station $S$ in different direction than the last time, i.e., along a different segment of tracks leaving from $S$.\n\nEach station (except $S$) is inspected exactly once.\n\nAfter inspecting the last station Byteasar does not come back        to $S$.\n\nThe travel time along every segment of tracks takes the same amount of time:\n\none hour.\n\nByteasar intends to consider all the stations as the initial station $S$.\n\nFor each of them he wants to know the order of inspecting the remaining stations that minimises the total travel time, provided that it is possible at all for that particular $S$.\n\n", "inputFormat": "The first line of the standard input contains a single integer $n$($1\\le n\\le 1\\ 000\\ 000$) that denotes the number of stations.\n\nThese are numbered from 1 to $n$.\n\nThe following $n-1$ lines specify the track segments, one per line.\n\nEach of them holds two integers $a,b$ ($1\\le a,b\\le n$, $a\\ne b$),      separated by a single space, indicating that there is a track segment      connecting the stations $a$ and $b$.\n\nEach track segments appears exactly once in the description.\n\nIn tests worth at least 30% of the points it holds additionally that $n\\le 2\\ 000$.\n", "outputFormat": "Your program should print $n$ lines on the standard output,each holding a single integer.\n\nThe one in the $i$-th line should be the minimum number of hours Byteasar has to spend travelling to inspect the stations when $S=i$ - if inspecting them all is possible for $S=i$;if it is not, the $i$-th line should hold the number $-1$.\n", "hint": "\n", "locale": "en", "translations": {"en": {"title": "[POI 2011] INS-Inspection", "background": "", "description": "The railway network of the Byteotian Railways (BR) consists of bidirectional    tracks connecting certain pairs of stations.\n\nEach pair of stations is connected by at most one segment of tracks.\n\nFurthermore, there is a unique route from every station to every other station.\n\n(The route may consist of several segments of tracks, but it may not pass through any station more than once.) Byteasar is an undercover inspector of the BR.\n\nHis job is to pick one of the stations (denote it by $S$) for centre of his operations and to travel to all other stations.\n\nHis journey should be as follows:\n\nByteasar starts in station $S$.\n\nNext, he picks one of the stations he did not yet control and goes to it along the shortest path (by train, of course), inspects the station, and        then goes back to $S$.\n\nThe crooked employees of BR warn one another of Byteasar's comings.\n\nTo deceive them, Byteasar picks the next station for control in such a way that he sets off from the station $S$ in different direction than the last time, i.e., along a different segment of tracks leaving from $S$.\n\nEach station (except $S$) is inspected exactly once.\n\nAfter inspecting the last station Byteasar does not come back        to $S$.\n\nThe travel time along every segment of tracks takes the same amount of time:\n\none hour.\n\nByteasar intends to consider all the stations as the initial station $S$.\n\nFor each of them he wants to know the order of inspecting the remaining stations that minimises the total travel time, provided that it is possible at all for that particular $S$.\n\n", "inputFormat": "The first line of the standard input contains a single integer $n$($1\\le n\\le 1\\ 000\\ 000$) that denotes the number of stations.\n\nThese are numbered from 1 to $n$.\n\nThe following $n-1$ lines specify the track segments, one per line.\n\nEach of them holds two integers $a,b$ ($1\\le a,b\\le n$, $a\\ne b$),      separated by a single space, indicating that there is a track segment      connecting the stations $a$ and $b$.\n\nEach track segments appears exactly once in the description.\n\nIn tests worth at least 30% of the points it holds additionally that $n\\le 2\\ 000$.\n", "outputFormat": "Your program should print $n$ lines on the standard output,each holding a single integer.\n\nThe one in the $i$-th line should be the minimum number of hours Byteasar has to spend travelling to inspect the stations when $S=i$ - if inspecting them all is possible for $S=i$;if it is not, the $i$-th line should hold the number $-1$.\n", "hint": "\n", "locale": "en"}, "zh-CN": {"title": "[POI 2011] INS-Inspection", "background": "", "description": "Byteotian Railways（BR）的铁路网络由双向轨道组成，这些轨道连接某些车站对。每对车站最多由一段轨道连接。此外，从每个车站到每个其他车站都有唯一的路线。（该路线可能由几段轨道组成，但不能经过任何车站多于一次。）Byteasar 是 BR 的一名卧底检查员。他的任务是选择一个车站（记为 $S$）作为他的行动中心，并前往所有其他车站。他的旅程应如下进行：Byteasar 从车站 $S$ 出发。接下来，他选择一个尚未检查的车站，沿最短路径（当然是乘火车）前往该车站，检查车站，然后返回 $S$。BR 的腐败员工互相警告 Byteasar 的到来。为了欺骗他们，Byteasar 选择下一个要检查的车站，使得他从车站 $S$ 出发的方向与上次不同，即沿着从 $S$ 出发的不同轨道段。每个车站（除了 $S$）恰好被检查一次。在检查完最后一个车站后，Byteasar 不返回 $S$。沿每段轨道的旅行时间相同：一小时。Byteasar 打算将所有车站都考虑为初始车站 $S$。对于每个车站，他想知道检查剩余车站的顺序，以最小化总旅行时间，前提是对于该特定 $S$ 这是可能的。", "inputFormat": "标准输入的第一行包含一个整数 $n$（$1 \\le n \\le 1\\ 000\\ 000$），表示车站的数量。这些车站从 1 到 $n$ 编号。接下来的 $n-1$ 行指定轨道段，每行一个。每行包含两个整数 $a,b$（$1 \\le a,b \\le n$, $a \ne b$），用一个空格分隔，表示有一段轨道连接车站 $a$ 和 $b$。每段轨道在描述中恰好出现一次。在至少价值 30% 的测试中，额外条件是 $n \\le 2\\ 000$。", "outputFormat": "你的程序应在标准输出上打印 $n$ 行，每行包含一个整数。第 $i$ 行的整数应为 Byteasar 在 $S=i$ 时检查车站所需的最少小时数——如果对于 $S=i$ 检查所有车站是可能的；如果不可能，第 $i$ 行应为数字 $-1$。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3526", "type": "P", "difficulty": 7, "samples": [["3\nABIABUABIAB\nBABBAB\nBABURBAB", "01001101001\n010010\n01000010"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2011", "POI（波兰）", "构造"], "title": "[POI 2011] OKR-Periodicity", "background": "", "description": "Byteasar, the king of Bitotia, has ordained a reform of his subjects' names. The names of Bitotians often contain repeating phrases, e.g., the name Abiabuab has two occurrences of the phrase abia. Byteasar intends to change the names of his subjects to sequences of bits matching the lengths of their original names. Also, he would very much like to reflect the original repetitions in the new names.\n\nIn the following, for simplicity, we will identify the upper- and lower-case letters in the names. For any sequence of characters (letters or bits) $w = w_1w_2\\cdots w_k$ we say that the integer $p$ ($1\\leq p < k$) is a period of $w$ if $w_i = w_{i + p}$ for all $i = 1,\\cdots,k - p$. We denote the set of all periods of $w$ by $Per(w)$. For example, $Per(\\texttt{ABIABUABIAB})=\\{6,9\\}$, $Per(\\texttt{01001010010})=\\{5,8,10\\}$, and $Per(\\texttt{0000})=\\{1,2,3\\}$.\n\nByteasar has decided that every name is to be changed to a sequence of bits that:\n- has length matching that of the original name,\n- has the same set of periods as the original name,\n- is the smallest (lexicographically. The sequence of bits $x_1x_2\\cdots x_k$ is lexicographically smaller than the sequence of bits $y_1y_2\\cdots y_k$ if for some $i$, $1\\leq i\\leq k$, we have $x_i < y_i$ and for all $j = 1,\\cdots,i - 1$ we have $x_j = y_j$.  ) sequence of bits satisfying the previous conditions.\n\nFor example, the name ABIABUABIAB should be changed to 01001101001, BABBAB to 010010, and BABURBAB to 01000010.\nByteasar has asked you to write a program that would facilitate the translation of his subjects' current names into new ones. If you succeed, you may keep your current name as a reward!", "inputFormat": "In the first line of the standard input there is a single integer $k$ - the number of names to be translated ($1\\leq k\\leq20$). The names are given in the following lines, one in each line. Each name consists of no less than and no more than 200,000 upper-case (capital) letters (of the English alphabet).\n\nIn the test worth 30% of the points each name consists of at most 20 letters.", "outputFormat": "Your program should print $k$ lines to the standard output. Each successive line should hold a sequence of zeroes and ones (without spaces in between) corresponding to the names given on the input. If an appropriate sequence of bits does not exists for some names, then \"XXX\" (without quotation marks) should be printed for that name. ", "hint": "\n", "locale": "en", "translations": {"en": {"title": "[POI 2011] OKR-Periodicity", "background": "", "description": "Byteasar, the king of Bitotia, has ordained a reform of his subjects' names. The names of Bitotians often contain repeating phrases, e.g., the name Abiabuab has two occurrences of the phrase abia. Byteasar intends to change the names of his subjects to sequences of bits matching the lengths of their original names. Also, he would very much like to reflect the original repetitions in the new names.\n\nIn the following, for simplicity, we will identify the upper- and lower-case letters in the names. For any sequence of characters (letters or bits) $w = w_1w_2\\cdots w_k$ we say that the integer $p$ ($1\\leq p < k$) is a period of $w$ if $w_i = w_{i + p}$ for all $i = 1,\\cdots,k - p$. We denote the set of all periods of $w$ by $Per(w)$. For example, $Per(\\texttt{ABIABUABIAB})=\\{6,9\\}$, $Per(\\texttt{01001010010})=\\{5,8,10\\}$, and $Per(\\texttt{0000})=\\{1,2,3\\}$.\n\nByteasar has decided that every name is to be changed to a sequence of bits that:\n- has length matching that of the original name,\n- has the same set of periods as the original name,\n- is the smallest (lexicographically. The sequence of bits $x_1x_2\\cdots x_k$ is lexicographically smaller than the sequence of bits $y_1y_2\\cdots y_k$ if for some $i$, $1\\leq i\\leq k$, we have $x_i < y_i$ and for all $j = 1,\\cdots,i - 1$ we have $x_j = y_j$.  ) sequence of bits satisfying the previous conditions.\n\nFor example, the name ABIABUABIAB should be changed to 01001101001, BABBAB to 010010, and BABURBAB to 01000010.\nByteasar has asked you to write a program that would facilitate the translation of his subjects' current names into new ones. If you succeed, you may keep your current name as a reward!", "inputFormat": "In the first line of the standard input there is a single integer $k$ - the number of names to be translated ($1\\leq k\\leq20$). The names are given in the following lines, one in each line. Each name consists of no less than and no more than 200,000 upper-case (capital) letters (of the English alphabet).\n\nIn the test worth 30% of the points each name consists of at most 20 letters.", "outputFormat": "Your program should print $k$ lines to the standard output. Each successive line should hold a sequence of zeroes and ones (without spaces in between) corresponding to the names given on the input. If an appropriate sequence of bits does not exists for some names, then \"XXX\" (without quotation marks) should be printed for that name. ", "hint": "\n", "locale": "en"}, "zh-CN": {"title": "[POI 2011] OKR-Periodicity", "background": null, "description": "比托蒂亚的国王 Byteasar 下令对他的臣民的名字进行改革。\n\n比托蒂亚人的名字通常包含重复的短语，例如，名字 Abiabuabiab 包含两次出现的短语 abiab。Byteasar 打算将他的臣民的名字改为与原名长度相匹配的 01 串。\n\n此外，他非常希望在新名字中反映原始的周期。\n\n对于任何字符序列（字母或 01 串）$w = w_1w_2\\cdots w_k$，我们说整数 $p\\ (1\\leq p < k)$ 是 $w$ 的周期，如果 $w_i = w_{i + p}$ 对于所有 $i = 1,\\cdots,k - p$ 都成立。\n\n我们用 $Per(w)$ 表示 $w$ 的所有周期的集合。\n\n例如，$Per(\\texttt{ABIABUABIAB})=\\{6,9\\},Per(\\texttt{01001010010})=\\{5,8,10\\},Per(\\texttt{0000})=\\{1,2,3\\}$。\n\nByteasar 决定将每个名字串 $S$ 改为一个 01 串 $T$，该串是满足 $|S|=|T|$ 且 $Per(S)=Per(T)$ 条件的字典序最小的 01 串。\n\n例如，名字 `ABIABUABIAB` 应该改为 `01001101001`，`BABBAB` 改为 `010010`，`BABURBAB` 改为 `01000010`。\n\nByteasar 要求你编写一个程序，帮助将他的臣民的当前名字翻译成新名字。\n\n如果你成功了，你可以作为奖励保留你现在的名字！", "inputFormat": "第一行一个整数 $k$ 表示需要翻译的名字数量 ($1\\leq k\\leq20$)。\n\n名字在接下来的行中给出，每行一个。\n\n每个名字由不多于 $200000$ 个英文大写字母组成。\n\n在 $30\\%$ 的数据中，每个名字最多由 $20$ 个字母组成。", "outputFormat": "你的程序应该向标准输出打印 $k$ 行。\n\n每个连续的行应包含与输入中给出的名字对应的零和一的序列（中间没有空格）。\n\n如果某些名字不存在合适的比特序列，则应为该名字打印 \"XXX\"（不带引号）。", "hint": "对于 $100\\%$ 的数据，$1\\leq k\\leq20$，单个名字长度不超过 $200000$。", "locale": "zh-CN"}}}
{"pid": "P3527", "type": "P", "difficulty": 6, "samples": [["3 5\n1 3 2 1 3\n10 5 7\n3\n4 2 4\n1 3 1\n3 5 2", "3\nNIE\n1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2011", "二分", "树状数组", "POI（波兰）", "O2优化", "整体二分", "离线处理"], "title": "[POI 2011] MET-Meteors", "background": "", "description": "Byteotian Interstellar Union (BIU) has recently discovered a new planet in a nearby galaxy.  The planet is unsuitable for colonisation due to strange  meteor showers, which on the other hand make it an exceptionally interesting  object of study.\n\nThe member states of BIU have already placed space stations close to the  planet's orbit.  The stations' goal is to take samples of the rocks flying by.\n\nThe BIU Commission has partitioned the orbit into $m$ sectors, numbered  from $1$ to $m$, where the sectors $1$ and $m$ are adjacent.  In each sector  there is a single space station, belonging to one of the $n$ member states.\n\nEach state has declared a number of meteor samples it intends to gather before  the mission ends.  Your task is to determine, for each state, when it can  stop taking samples, based on the meter shower predictions for the years to  come.\n\n\n", "inputFormat": "The first line of the standard input gives two integers, $n$ and $m$ ($1\\le n,m\\le 300\\ 000$), separated by a single space, that denote,respectively, the number of BIU member states and the number of sectors    the orbit has been partitioned into.\n\nIn the second line there are $m$ integers $o_i$ ($1\\le o_i\\le n$),separated by single spaces, that denote the states owning stations in    successive sectors.\n\nIn the third line there are $n$ integers $p_i$ ($1\\le p_i\\le 10^9$),separated by single spaces, that denote the numbers of meteor samples that the successive states intend to gather.\n\nIn the fourth line there is a single integer $k$ ($1\\le k\\le 300\\ 000$) that denotes the number of meteor showers predictions. The following $k$ lines specify the (predicted) meteor showers chronologically. The $i$-th of these lines holds three integers $l_i,r_i,a_i$ (separated by single spaces), which denote that a meteor shower is expected in sectors $l_i,l_{i+1},...,r_i$(if $l_i\\le r_i$) or sectors $l_i,l_{i+1},...,m,1,...,r_i$ (if $l_i>r_i$) , which should provide each station in those sectors with $a_i$ meteor samples ($1\\le a_i\\le 10^9$).\n", "outputFormat": "Your program should print $n$ lines on the standard output.\n\nThe $i$-th of them should contain a single integer $w_i$, denoting the number of shower after which the stations belonging to the $i$-th state are    expected to gather at least $p_i$ samples, or the word NIE (Polish for no) if that state is not expected to gather enough samples in the foreseeable future.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2011] MET-Meteors", "background": "", "description": "Byteotian Interstellar Union (BIU) has recently discovered a new planet in a nearby galaxy.  The planet is unsuitable for colonisation due to strange  meteor showers, which on the other hand make it an exceptionally interesting  object of study.\n\nThe member states of BIU have already placed space stations close to the  planet's orbit.  The stations' goal is to take samples of the rocks flying by.\n\nThe BIU Commission has partitioned the orbit into $m$ sectors, numbered  from $1$ to $m$, where the sectors $1$ and $m$ are adjacent.  In each sector  there is a single space station, belonging to one of the $n$ member states.\n\nEach state has declared a number of meteor samples it intends to gather before  the mission ends.  Your task is to determine, for each state, when it can  stop taking samples, based on the meter shower predictions for the years to  come.\n\n\n", "inputFormat": "The first line of the standard input gives two integers, $n$ and $m$ ($1\\le n,m\\le 300\\ 000$), separated by a single space, that denote,respectively, the number of BIU member states and the number of sectors    the orbit has been partitioned into.\n\nIn the second line there are $m$ integers $o_i$ ($1\\le o_i\\le n$),separated by single spaces, that denote the states owning stations in    successive sectors.\n\nIn the third line there are $n$ integers $p_i$ ($1\\le p_i\\le 10^9$),separated by single spaces, that denote the numbers of meteor samples that the successive states intend to gather.\n\nIn the fourth line there is a single integer $k$ ($1\\le k\\le 300\\ 000$) that denotes the number of meteor showers predictions. The following $k$ lines specify the (predicted) meteor showers chronologically. The $i$-th of these lines holds three integers $l_i,r_i,a_i$ (separated by single spaces), which denote that a meteor shower is expected in sectors $l_i,l_{i+1},...,r_i$(if $l_i\\le r_i$) or sectors $l_i,l_{i+1},...,m,1,...,r_i$ (if $l_i>r_i$) , which should provide each station in those sectors with $a_i$ meteor samples ($1\\le a_i\\le 10^9$).\n", "outputFormat": "Your program should print $n$ lines on the standard output.\n\nThe $i$-th of them should contain a single integer $w_i$, denoting the number of shower after which the stations belonging to the $i$-th state are    expected to gather at least $p_i$ samples, or the word NIE (Polish for no) if that state is not expected to gather enough samples in the foreseeable future.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2011] MET-Meteors", "background": null, "description": "Byteotian Interstellar Union \n\n有 $n$ 个成员国。现在它发现了一颗新的星球，这颗星球的轨道被分为 $m$ 份（第 $m$ 份和第 $1$ 份相邻），第 $i$ 份上有第 $o_i$ 个国家的太空站。\n\n这个星球经常会下陨石雨。BIU 已经预测了接下来 $k$ 场陨石雨的情况。\n\nBIU 的第 $i$ 个成员国希望能够收集 $p_i$ 单位的陨石样本。你的任务是判断对于每个国家，它需要在第几次陨石雨之后，才能收集足够的陨石。", "inputFormat": "第一行是两个数 $n,m$。\n\n第二行有 $m$ 个数，第 $i$ 个数 $o_i$ 表示第 $i$ 段轨道上有第 $o_i$ 个国家的太空站。\n\n第三行有 $n$ 个数，第 $i$ 个数 $p_i$ 表示第 $i$ 个国家希望收集的陨石数量。\n\n第四行有一个数 $k$，表示 BIU 预测了接下来的 $k$ 场陨石雨。 接下来 $k$ 行，每行有三个数 $l_i,r_i,a_i$ ，表示第 $k$ 场陨石雨的发生地点在从 $l_i$ 顺时针到 $r_i$ 的区间中（如果 $l_i \\leq r_i$，则是 $l_i, l_i + 1 \n\\cdots, r_i$，否则就是 $l_i, l_i + 1, \n\\cdots m - 1, m, 1, 2, \\cdots r_i$），向区间中的每个太空站提供 $a_i$ 单位的陨石样本。", "outputFormat": "输出 $n$ 行。第 $i$ 行的数 $w_i$ 表示第 $i$ 个国家在第 $w_i$ 波陨石雨之后能够收集到足够的陨石样本。如果到第 $k$ 波结束后仍然收集不到，输出 `NIE`。", "hint": "$1\\le n,m,k\\le 3\\cdot10^5$；\n\n$1\\le p_i,a_i\\le 10^9$；", "locale": "zh-CN"}}}
{"pid": "P3528", "type": "P", "difficulty": 5, "samples": [["4\n1 42\n2 6 9\n3 8 4 8\n1 12", "3 8 4 12 2 9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2011", "POI（波兰）", "Special Judge", "枚举"], "title": "[POI 2011] PAT-Sticks", "background": "", "description": "Little Johnny was given a birthday present by his grandparents.\n\nThis present is a box of sticks of various lengths and colours.\n\nJohnny wonders if there are three sticks in the set he has been given    that would form a triangle with different-coloured sides.\n\nLet us note that Johnny is interested in non-degenerate triangles only, i.e.,    those with positive area.\n", "inputFormat": "In the first line of the standard input an integer $k$ ($3\\le k\\le 50$) is given, which is the number of different colours of sticks.\n\nThe colours themselves are numbered from $1$ to $k$.\n\nThe following $k$ lines contain descriptions of the sticks of particular      colours.\n\nThe line no. $i+1$ holds integers that describe the sticks of colour $i$,separated by single spaces.\n\nThe first of these numbers, $n_i$ ($1\\le n_i\\le 1\\ 000\\ 000$), denotes the number of sticks of colour $i$.\n\nIt is followed, in the same line, by $n_i$ integers denoting the lengths of the sticks of colour $i$.All lengths are positive and do not exceed $1\\ 000\\ 000\\ 000$.Furthermore, the total number of all sticks does not exceed $1\\ 000\\ 000$.\n", "outputFormat": "Your program should print (on the first and only line of the standard output) either:\n\nsix integers, separated by single spaces, that describe the construction          of a triangle with different-coloured sides as follows:\n\nthe colour and the length of the first stick, the colour and the length          of the second stick, and the colour and the length of the third stick,                      or the word NIE (Polish for no) if no such triple of          sticks exists.\n\nIf there are multiple triples of different-coloured sticks that give rise      to a triangle, your program may pick one such triple arbitrarily.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2011] PAT-Sticks", "background": "", "description": "Little Johnny was given a birthday present by his grandparents.\n\nThis present is a box of sticks of various lengths and colours.\n\nJohnny wonders if there are three sticks in the set he has been given    that would form a triangle with different-coloured sides.\n\nLet us note that Johnny is interested in non-degenerate triangles only, i.e.,    those with positive area.\n", "inputFormat": "In the first line of the standard input an integer $k$ ($3\\le k\\le 50$) is given, which is the number of different colours of sticks.\n\nThe colours themselves are numbered from $1$ to $k$.\n\nThe following $k$ lines contain descriptions of the sticks of particular      colours.\n\nThe line no. $i+1$ holds integers that describe the sticks of colour $i$,separated by single spaces.\n\nThe first of these numbers, $n_i$ ($1\\le n_i\\le 1\\ 000\\ 000$), denotes the number of sticks of colour $i$.\n\nIt is followed, in the same line, by $n_i$ integers denoting the lengths of the sticks of colour $i$.All lengths are positive and do not exceed $1\\ 000\\ 000\\ 000$.Furthermore, the total number of all sticks does not exceed $1\\ 000\\ 000$.\n", "outputFormat": "Your program should print (on the first and only line of the standard output) either:\n\nsix integers, separated by single spaces, that describe the construction          of a triangle with different-coloured sides as follows:\n\nthe colour and the length of the first stick, the colour and the length          of the second stick, and the colour and the length of the third stick,                      or the word NIE (Polish for no) if no such triple of          sticks exists.\n\nIf there are multiple triples of different-coloured sticks that give rise      to a triangle, your program may pick one such triple arbitrarily.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2011] PAT-Sticks", "background": "", "description": "小 Johnny 收到了祖父母送的生日礼物。\n\n这个礼物是一盒各种长度和颜色的木棍。\n\nJohnny 想知道，他收到的这些木棍中是否存在三根木棍，能够组成一个边长颜色各不相同的三角形。\n\n需要注意的是，Johnny 只对非退化三角形感兴趣，即面积为正的三角形。", "inputFormat": "输入的第一行包含一个整数 $k$（$3 \\leq k \\leq 50$），表示木棍的不同颜色数量。颜色本身编号为 $1$ 到 $k$。\n\n接下来的 $k$ 行描述了每种颜色的木棍。第 $i+1$ 行描述了颜色为 $i$ 的木棍，包含若干个用空格分隔的整数。第一个整数 $n_i$（$1 \\leq n_i \\leq 1\\,000\\,000$）表示颜色为 $i$ 的木棍数量。随后是 $n_i$ 个整数，表示这些木棍的长度。所有长度均为正整数且不超过 $1\\,000\\,000\\,000$。此外，所有木棍的总数不超过 $1\\,000\\,000$。", "outputFormat": "你的程序应在标准输出的第一行（也是唯一一行）输出以下内容之一：\n\n- 六个整数，用空格分隔，描述一个边长颜色各不相同的三角形的构造方式，依次为：第一根木棍的颜色和长度，第二根木棍的颜色和长度，以及第三根木棍的颜色和长度；  \n- 或者输出单词 `NIE`（波兰语中的“无”），表示不存在这样的三根木棍。\n\n如果存在多个满足条件的三根木棍，你的程序可以任意选择其中一个输出。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3529", "type": "P", "difficulty": 6, "samples": [["2 4 3 15 4\n1 1\n2 3\n1 4\n1 3", "3 12\n1 4 0\n2 3 0\n1 1 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "POI（波兰）", "Special Judge", "费用流"], "title": "[POI 2011] PRO-Programming Contest", "background": "", "description": "Bartie and his friends compete in the Team Programming Contest.\n\nThere are $n$ contestants on each team, and each team has access to $n$ computers.\n\nThe contest lasts $t$ minutes, during which the contestants are to solve $m$ programming problems.\n\nFurthermore, penalties are imposed on the teams: solving a problem $s$ minutes since the beginning of the contest amounts to $s$ penal points.\n\nThe team that solved the most problems wins the contest, with ties broken in    favour of the team with smaller penalty.\n\nOn the contest day Bartie quickly glances over the problem statements and    distributes them among his teammates.\n\nHe knows his team so well that he can exactly assess who is able to solve    which problem.\n\nSolving any problem takes any contestant that is able to solve it exactly $r$ minutes of using the computer.\n\nBartie's team did not fare well in this year's contest.\n\nBartie is obsessed with the thought that it might be his fault, due to wrong    decisions regarding the distribution of problems.\n\nHe asks you to write a program that, given what Bartie knew at the beginning    of the contest, determines the best possible result of Bytie's team, together    with the assignment of problems to team members that attains the result.\n", "inputFormat": "Five integers $n$, $m$, $r$, $t$, and $k$ ($1\\le n,m\\le 500$, $1\\le r,t\\le 1\\ 000\\ 000$) are given in the first line of the standard input, separated by single spaces.\n\nThese denote, respectively:\n\nthe number of contestants on a team, the number of problems, the time it      takes a contestant to solve a problem, the duration of the contest,and the number of contestant-problem pairs given on the input.\n\nEach of the following $k$ lines holds two integers $a$ and $b$($1\\le a\\le n$,$1\\le b\\le m$), separated by a single space, denoting that the contestant $a$ is able to solve the problem $b$.Each such pair appears at most once in the input.\n\nIn tests worth at least 30% of the points it additionally holds that $n,m\\le 100$.\n", "outputFormat": "In the first line of the standard output the best possible result of Bytie's      team should be printed as two numbers separated by a single space:\n\nthe number of solved problems $z$ and the total penal points.\n\nAn exemplary assignment of problems that attains this result should be given in the following $z$ lines.\n\nEach of those should hold three integers $a$, $b$ and $c$ ($1\\le a\\le n$,$1\\le b\\le m$, $0\\le c\\le t-r$),separated by single spaces, signifying that the contestant $a$ should start solving the problem $b$ at time $c$(the contest starts at time $0$).No contestant should be assigned a problem that they cannot solve. If more that one optimal assignment exists, your program can output any of them.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2011] PRO-Programming Contest", "background": "", "description": "Bartie and his friends compete in the Team Programming Contest.\n\nThere are $n$ contestants on each team, and each team has access to $n$ computers.\n\nThe contest lasts $t$ minutes, during which the contestants are to solve $m$ programming problems.\n\nFurthermore, penalties are imposed on the teams: solving a problem $s$ minutes since the beginning of the contest amounts to $s$ penal points.\n\nThe team that solved the most problems wins the contest, with ties broken in    favour of the team with smaller penalty.\n\nOn the contest day Bartie quickly glances over the problem statements and    distributes them among his teammates.\n\nHe knows his team so well that he can exactly assess who is able to solve    which problem.\n\nSolving any problem takes any contestant that is able to solve it exactly $r$ minutes of using the computer.\n\nBartie's team did not fare well in this year's contest.\n\nBartie is obsessed with the thought that it might be his fault, due to wrong    decisions regarding the distribution of problems.\n\nHe asks you to write a program that, given what Bartie knew at the beginning    of the contest, determines the best possible result of Bytie's team, together    with the assignment of problems to team members that attains the result.\n", "inputFormat": "Five integers $n$, $m$, $r$, $t$, and $k$ ($1\\le n,m\\le 500$, $1\\le r,t\\le 1\\ 000\\ 000$) are given in the first line of the standard input, separated by single spaces.\n\nThese denote, respectively:\n\nthe number of contestants on a team, the number of problems, the time it      takes a contestant to solve a problem, the duration of the contest,and the number of contestant-problem pairs given on the input.\n\nEach of the following $k$ lines holds two integers $a$ and $b$($1\\le a\\le n$,$1\\le b\\le m$), separated by a single space, denoting that the contestant $a$ is able to solve the problem $b$.Each such pair appears at most once in the input.\n\nIn tests worth at least 30% of the points it additionally holds that $n,m\\le 100$.\n", "outputFormat": "In the first line of the standard output the best possible result of Bytie's      team should be printed as two numbers separated by a single space:\n\nthe number of solved problems $z$ and the total penal points.\n\nAn exemplary assignment of problems that attains this result should be given in the following $z$ lines.\n\nEach of those should hold three integers $a$, $b$ and $c$ ($1\\le a\\le n$,$1\\le b\\le m$, $0\\le c\\le t-r$),separated by single spaces, signifying that the contestant $a$ should start solving the problem $b$ at time $c$(the contest starts at time $0$).No contestant should be assigned a problem that they cannot solve. If more that one optimal assignment exists, your program can output any of them.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2011] PRO-Programming Contest", "background": "", "description": "**译自 POI 2011 Round 3. Day 2. C「[Programming Contest](https://szkopul.edu.pl/problemset/problem/VwDLJhYqi1z_sZrb2NyfvQ5e/site/?key=statement)」**\n\nBartie 和他的朋友们都在打团体程序设计竞赛。每个队有 $n$ 名队员，每个队可以用 $n$ 台电脑。比赛持续 $t$ 分钟，比赛中选手们要解决 $m$ 道程序设计题目。此外，比赛会按如下规则记罚时：比赛开始 $s$ 分钟通过了一道题，则罚时加 $s$ 分。解题数目最多的队伍获胜，如果解题数目相同，罚时最少的队伍获胜。\n\n在一次比赛中，Bartie 迅速浏览了全部题目并且把题目分配给了队友。他十分了解队友，并可以把题目分配给能解决这道题的人。对于每个选手，解决一道题的时间都恰好是 $r$ 分钟。\n\nBartie 的队伍在今年的比赛中表现不佳。Bartie 确信这是他的问题，是由于他分配问题失误造成的。他想让你写个程序，给出 Bartie 在比赛前知道的信息，请求出 Bartie 的队伍可能的最好成绩和分配题目的方式。", "inputFormat": "第一行五个整数 $n,m,r,t,k$，分别表示一个队中的队员数，题目数，队员解决一道题的用时，比赛的时间长度和队员-题目对数；\n\n接下来 $k$ 行，每行两个数 $a,b$，表示队员 $a$ 可以解决问题 $b$。每一个有序对在输入中最多出现一次。", "outputFormat": "第一行输出两个整数，用一个空格隔开，分别表示解出的题目总数 $z$ 和最少总罚时。\n\n接下来 $z$ 行，每行输出三个整数 $a,b,c\\ (1 \\le a \\le n , 1 \\le b \\le m , 0 \\le c \\le t-r)$，表示队员 $a$ 在时刻 $c$ 时开始解决题目 $b$（比赛开始于时刻 $0$）。你不能把一道题分配给不会解决它的人。如果有多种分配方案，输出任意一组均可。", "hint": "对于全部数据，$ 1 \\le n, m \\le 500 , 1 \\le r, t \\le 1000000, 1 \\le a \\le n , 1 \\le b \\le m $\n\n对于 $30\\%$ 的分数，$n,m\\le 100$。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2171)。", "locale": "zh-CN"}}}
{"pid": "P3530", "type": "P", "difficulty": 5, "samples": [["4 2 2\n1 2\n3 4\n1 4\n3 1\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2012", "POI（波兰）", "负权环", "Tarjan", "差分约束", "Floyd 算法"], "title": "[POI 2012] FES-Festival", "background": "在 Byteburg 举办了一场慈善活动，你是其中一个筹款人。不幸的是，你错过了一些有趣的活动，包括一场越野赛。\n\n谜题爱好者 Byteasar 承诺：如果你能解开他的谜题，他会捐一大笔钱。", "description": "你不知道越野赛的结果，但 Byteasar 会告诉你部分信息。现在，他要你答出：所有参赛者最多能达到多少种不同的成绩，而不违背他给的条件。（他们中的一些人可能平局，也就是同时到达终点，这种情况只算有一种成绩）。\n\nByteasar 告诉你，所有参赛者的成绩都是整数秒。他还会为你提供了一些参赛者成绩的关系。具体是：他会给你一些数对 $(A, B)$，表示 $A$ 的成绩正好比 $B$ 快 $1$ 秒；他还会给你一些数对 $(C, D)$，表示 $C$ 的成绩不比 $D$ 慢。而你要回答的是：所有参赛者最多能达到多少种不同的成绩，而不违背他给的条件。\n\n请你编程解决这个谜题。", "inputFormat": "第一行有三个整数 $n, m_{1}, m_{2}$，分别表示选手人数、数对 $(A, B)$ 的数目、数对 $(C, D)$ 的数目。\n\n接下来 $m_1$ 行，每行两个整数 $a_{i}, b_{i}$（$a_{i} \\ne b_{i}$）。这表示选手 $a_{i}$ 的成绩恰比 $b_{i}$ 小 $1$ 秒。\n\n接下来 $m_{2}$ 行，每行两个整数 $c_{i}, d_{i}$（$c_{i} \\ne d_{i}$）。这表示选手 $c_{i}$ 的成绩不比 $d_{i}$ 的成绩差（也就是花的时间不会更多）。", "outputFormat": "如果有解，输出一行一个整数，表示所有选手最多能拿到的成绩的种数。  \n如果无解，输出 `NIE`。", "hint": "答案为 $3$，情况为：$t_3=1, t_1=t_4=2, t_2=3$。  \n（$t_i$ 表示参赛者 $i$ 花的时间）\n\n**【数据范围】**\n\n对于 $15\\%$ 的数据，$n \\le 10$。  \n对于 $100\\%$ 的数据，$2 \\le n \\le 600$，$1 \\le m_{1} + m_{2} \\le {10}^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2012] FES-Festival", "background": "A charity event was held in Byteburg, and you are one of the fundraisers. Unfortunately, you missed some interesting activities, including a cross-country race.\n\nPuzzle enthusiast Byteasar promises: if you can solve his puzzle, he will donate a large sum of money.", "description": "You do not know the results of the race, but Byteasar will tell you partial information. Now, you are asked to answer: what is the maximum number of distinct finishing times that all participants can have without violating his conditions? Some of them may tie (i.e., finish at the same time), and such ties count as one distinct time.\n\nByteasar tells you that all finishing times are integer seconds. He will also provide some relations between the participants’ times. Specifically, he will give you some pairs $(A, B)$, meaning that $A$’s time is exactly $1$ second less than $B$’s; and some pairs $(C, D)$, meaning that $C$’s time is not greater than $D$’s. Your task is to compute the maximum possible number of distinct finishing times for all participants that satisfies these conditions.\n\nPlease write a program to solve this puzzle.", "inputFormat": "The first line contains three integers $n, m_{1}, m_{2}$, denoting the number of participants, the number of pairs $(A, B)$, and the number of pairs $(C, D)$, respectively.\n\nThe next $m_{1}$ lines each contain two integers $a_{i}, b_{i}$ ($a_{i} \\ne b_{i}$). This means participant $a_{i}$’s time is exactly $1$ second less than participant $b_{i}$’s.\n\nThe next $m_{2}$ lines each contain two integers $c_{i}, d_{i}$ ($c_{i} \\ne d_{i}$). This means participant $c_{i}$’s time is not greater than participant $d_{i}$’s.", "outputFormat": "If there is a solution, output a single integer on one line, representing the maximum number of distinct finishing times among all participants.  \nIf there is no solution, output `NIE`.", "hint": "The answer is $3$, with $t_3 = 1$, $t_1 = t_4 = 2$, $t_2 = 3$.  \n($t_i$ denotes the time spent by participant $i$.)\n\nConstraints\n\n- For $15\\%$ of the testdata, $n \\le 10$.\n- For $100\\%$ of the testdata, $2 \\le n \\le 600$, $1 \\le m_{1} + m_{2} \\le 10^{5}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2012] FES-Festival", "background": "在 Byteburg 举办了一场慈善活动，你是其中一个筹款人。不幸的是，你错过了一些有趣的活动，包括一场越野赛。\n\n谜题爱好者 Byteasar 承诺：如果你能解开他的谜题，他会捐一大笔钱。", "description": "你不知道越野赛的结果，但 Byteasar 会告诉你部分信息。现在，他要你答出：所有参赛者最多能达到多少种不同的成绩，而不违背他给的条件。（他们中的一些人可能平局，也就是同时到达终点，这种情况只算有一种成绩）。\n\nByteasar 告诉你，所有参赛者的成绩都是整数秒。他还会为你提供了一些参赛者成绩的关系。具体是：他会给你一些数对 $(A, B)$，表示 $A$ 的成绩正好比 $B$ 快 $1$ 秒；他还会给你一些数对 $(C, D)$，表示 $C$ 的成绩不比 $D$ 慢。而你要回答的是：所有参赛者最多能达到多少种不同的成绩，而不违背他给的条件。\n\n请你编程解决这个谜题。", "inputFormat": "第一行有三个整数 $n, m_{1}, m_{2}$，分别表示选手人数、数对 $(A, B)$ 的数目、数对 $(C, D)$ 的数目。\n\n接下来 $m_1$ 行，每行两个整数 $a_{i}, b_{i}$（$a_{i} \\ne b_{i}$）。这表示选手 $a_{i}$ 的成绩恰比 $b_{i}$ 小 $1$ 秒。\n\n接下来 $m_{2}$ 行，每行两个整数 $c_{i}, d_{i}$（$c_{i} \\ne d_{i}$）。这表示选手 $c_{i}$ 的成绩不比 $d_{i}$ 的成绩差（也就是花的时间不会更多）。", "outputFormat": "如果有解，输出一行一个整数，表示所有选手最多能拿到的成绩的种数。  \n如果无解，输出 `NIE`。", "hint": "答案为 $3$，情况为：$t_3=1, t_1=t_4=2, t_2=3$。  \n（$t_i$ 表示参赛者 $i$ 花的时间）\n\n**【数据范围】**\n\n对于 $15\\%$ 的数据，$n \\le 10$。  \n对于 $100\\%$ 的数据，$2 \\le n \\le 600$，$1 \\le m_{1} + m_{2} \\le {10}^5$。", "locale": "zh-CN"}}}
{"pid": "P3531", "type": "P", "difficulty": 3, "samples": [["3\nABC\nBCA\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "树状数组", "POI（波兰）", "O2优化"], "title": "[POI 2012] LIT-Letters", "background": "", "description": "给出两个长度相同的的只含大写字母的字符串 $a, b$，每次可以交换 $a$ 中相邻两个字符，求最少的交换次数，使得 $a$ 交换后的得到的字符串与 $b$ 相同。", "inputFormat": "输入的第一行是一个整数，代表字符串的长度 $n$。\n\n第二行是一个长度为 $n$ 的字符串，代表 $a$。\n\n第三行是一个长度为 $n$ 的字符串，代表 $b$。", "outputFormat": "输出一行一个整数，代表最少的交换次数。", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n \\leq 10^3$。\n- 对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^6$，$a, b$ 中只含大写字母，且数据保证 $a$ 可以变成 $b$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2012] LIT-Letters", "background": "", "description": "Given two strings $a$, $b$ of equal length, each consisting only of uppercase letters, you may swap two adjacent characters in $a$ at a time. Find the minimum number of swaps needed so that the string obtained from $a$ becomes identical to $b$.", "inputFormat": "The first line contains an integer $n$, the length of the strings.\n\nThe second line contains a string of length $n$, denoting $a$.\n\nThe third line contains a string of length $n$, denoting $b$.", "outputFormat": "Output a single integer on one line, the minimum number of swaps.", "hint": "#### Constraints\n\n- For 30% of the testdata, it is guaranteed that $n \\leq 10^3$.\n- For 100% of the testdata, $1 \\leq n \\leq 10^6$, $a$, $b$ contain only uppercase letters, and the testdata guarantees that $a$ can be transformed into $b$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2012] LIT-Letters", "background": "", "description": "给出两个长度相同的的只含大写字母的字符串 $a, b$，每次可以交换 $a$ 中相邻两个字符，求最少的交换次数，使得 $a$ 交换后的得到的字符串与 $b$ 相同。", "inputFormat": "输入的第一行是一个整数，代表字符串的长度 $n$。\n\n第二行是一个长度为 $n$ 的字符串，代表 $a$。\n\n第三行是一个长度为 $n$ 的字符串，代表 $b$。", "outputFormat": "输出一行一个整数，代表最少的交换次数。", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n \\leq 10^3$。\n- 对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^6$，$a, b$ 中只含大写字母，且数据保证 $a$ 可以变成 $b$。", "locale": "zh-CN"}}}
