{"pid": "P6890", "type": "P", "difficulty": 5, "samples": [["8 3\n1 2\n2 3\n3 5\n4 5\n5 6\n6 7\n7 8\n8 5", "2"], ["14 4\n1 2\n2 3\n3 4\n4 5\n7 5\n5 6\n6 3\n8 10\n10 9\n9 8\n14 13\n13 12\n12 11\n11 14", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2006", "CEOI（中欧）"], "title": "[CEOI 2006] Link", "background": "", "description": "Webmaster Kirk is reorganizing his school's website. There are a number of pages on the website and the\ncontent is fine, but he noticed that the pages are not properly linked. In fact, every page contains exactly one link, pointing to some other page in the website. This is a poor design – starting from the homepage, a visitor will usually have to follow many links before reaching the page of his interest, and some pages might not be reachable from the homepage at all. As a first step, he wants to add a few links so that every page can be quickly accessed from the homepage. New links can be added anywhere in the website.\n\nThe website contains N pages marked with integers 1 to N and the homepage is marked with the number 1.\n\nThere are also N links; **each page contains exactly one link** pointing to some **different** page. For an integer\nK, a website is said to be **K-reachable** if every page on the website other than the homepage can be reached from the homepage by following **at most K** links.\n\nWrite a program that, given the description of the website and an integer K, finds the **minimum number of links that need to be added** in order to make the website K-reachable.", "inputFormat": "The first line of input contains two integers $N$ and $K$ ($2\\leq N\\leq500000$, $1\\leq K\\leq20000$) – the number of pages and the target maximum number of links to be followed.\n\nEach of the following $N$ lines contains two different integers $A$ and $B$ ($1\\leq A, B\\leq N$) meaning that the link on page $A$ points to page $B$.", "outputFormat": "The first and only line of output should contain a single integer, the minimum number of additional links required to make the website $K$ - reachable. ", "hint": "在第二组样例中，一个合法的路径集合 $\\{1\\to 7,1\\to 14,14\\to 10\\}$。\n\n$2 ≤ N ≤ 500 000$, $1 ≤ K ≤ 20 000$。", "locale": "en", "translations": {"en": {"title": "[CEOI 2006] Link", "background": "", "description": "Webmaster Kirk is reorganizing his school's website. There are a number of pages on the website and the\ncontent is fine, but he noticed that the pages are not properly linked. In fact, every page contains exactly one link, pointing to some other page in the website. This is a poor design – starting from the homepage, a visitor will usually have to follow many links before reaching the page of his interest, and some pages might not be reachable from the homepage at all. As a first step, he wants to add a few links so that every page can be quickly accessed from the homepage. New links can be added anywhere in the website.\n\nThe website contains N pages marked with integers 1 to N and the homepage is marked with the number 1.\n\nThere are also N links; **each page contains exactly one link** pointing to some **different** page. For an integer\nK, a website is said to be **K-reachable** if every page on the website other than the homepage can be reached from the homepage by following **at most K** links.\n\nWrite a program that, given the description of the website and an integer K, finds the **minimum number of links that need to be added** in order to make the website K-reachable.", "inputFormat": "The first line of input contains two integers $N$ and $K$ ($2\\leq N\\leq500000$, $1\\leq K\\leq20000$) – the number of pages and the target maximum number of links to be followed.\n\nEach of the following $N$ lines contains two different integers $A$ and $B$ ($1\\leq A, B\\leq N$) meaning that the link on page $A$ points to page $B$.", "outputFormat": "The first and only line of output should contain a single integer, the minimum number of additional links required to make the website $K$ - reachable. ", "hint": "在第二组样例中，一个合法的路径集合 $\\{1\\to 7,1\\to 14,14\\to 10\\}$。\n\n$2 ≤ N ≤ 500 000$, $1 ≤ K ≤ 20 000$。", "locale": "en"}, "zh-CN": {"title": "[CEOI 2006] Link", "background": "", "description": "网站管理员 Kirk 正在重新组织他学校的网站。网站上有许多页面，内容很好，但他注意到页面之间的链接不够合理。事实上，每个页面都只包含一个链接，指向网站中的其他页面。这是一个糟糕的设计——从主页开始，访问者通常需要点击许多链接才能到达他感兴趣的页面，而且有些页面可能根本无法从主页访问。作为第一步，他想添加一些链接，以便每个页面都可以从主页快速访问。新链接可以添加在网站的任何地方。\n\n网站包含 $N$ 个页面，用整数 1 到 $N$ 标记，主页标记为数字 1。\n\n每个页面也有 $N$ 个链接；**每个页面都包含一个指向其他页面的链接**。对于整数 $K$，如果网站上的每个页面（除了主页）都可以通过**最多 $K$ 个链接**从主页访问，则称该网站是 **K-可达的**。\n\n编写一个程序，给定网站的描述和整数 $K$，找出为了使网站 K-可达所需添加的**最少链接数**。", "inputFormat": "第一行是两个整数用空格隔开 $N$ 和 $K$。\n\n接下来 $N$ 行：\n\n其中第 $i+1$ 行 $(1\\leqslant i\\leqslant N)$ 输入两个整数 $x$ 和 $y$，表示存在一条从 $x$ 到 $y$ 的单向边。", "outputFormat": "输出仅一个整数：表示最少需要添加的边数。", "hint": "在第二组样例中，一个合法的路径集合 $\\{1\\to 7,1\\to 14,14\\to 10\\}$。\n\n$2 \\leq N \\leq 500 000$, $1 \\leq K \\leq 20 000$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6891", "type": "P", "difficulty": 6, "samples": [["3\n2 5 4 9 15 11\n6 7 6 8 12 14", "AABABB"], ["2\n1 4 10 20\n3 5 8 13", "BBAA"], ["2\n3 4 5 6\n10 9 8 7", "-1"], ["6\n25 18 40 37 29 95 41 53 39 69 61 90\n14 18 22 28 18 30 32 32 63 58 71 78", "BABBABAABABA"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "Special Judge", "JOISC/JOIST（日本）"], "title": "[JOISC 2020] ビルの飾り付け 4", "background": "JOISC2020 Day 1 T1", "description": "给定两个长度为 $2n$ 的序列 $A,B$，构造一个长度为 $2n$ 的序列 $C$ 满足以下条件：\n\n- 对于 $1\\leq i\\leq 2n$，$C_i$ 只能从 $A_i$ 和 $B_i$ 中选取\n\n- $C_i$ 从 $A_i$ 中选取的次数和从 $B_i$ 中选取的次数都恰好为 $n$。\n\n- $C$ 为单调不降的序列。\n\n如果满足条件的 $C$ 有多个，只需要输出一个。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $2n$ 个数字，第 $i$ 个为 $A_i$。\n\n第三行 $2n$ 个数字，第 $i$ 个为 $B_i$。", "outputFormat": "如果无解则输出 $-1$，否则按照以下方式输出一个字符串 $s$：\n\n对于 $1\\leq i\\leq 2n$，如果 $C_i$ 是从 $A_i$ 选取的则 $s_i=\\texttt{A}$，否则 $s_i=\\texttt{B}$。", "hint": "#### 样例 1 解释\n\n构造的 $C=[2,5,6,9,12,14]$，可以自行这是满足条件的方案。\n\n#### 样例 2 解释\n\n另外有 $\\texttt{AABB},\\texttt{ABAB},\\texttt{BABA},\\texttt{BAAB},\\texttt{ABBA}$ 这 $5$ 组解，输出任何一组均可。\n\n#### 样例 3 解释\n\n没有满足条件的方案。\n\n#### 子任务\n\n| 子任务 | 特殊性质 | 分数 |\n| :----------: | :----------: | :----------: |\n| $1$ | $1\\leq n\\leq 2\\times 10^3$ | $11$ |\n| $2$ | 无 | $89$ |\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 5\\times 10^5,1\\leq A_i,B_i\\leq 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2020] ビルの飾り付け 4", "background": "JOISC2020 Day 1 T1", "description": "给定两个长度为 $2n$ 的序列 $A,B$，构造一个长度为 $2n$ 的序列 $C$ 满足以下条件：\n\n- 对于 $1\\leq i\\leq 2n$，$C_i$ 只能从 $A_i$ 和 $B_i$ 中选取\n\n- $C_i$ 从 $A_i$ 中选取的次数和从 $B_i$ 中选取的次数都恰好为 $n$。\n\n- $C$ 为单调不降的序列。\n\n如果满足条件的 $C$ 有多个，只需要输出一个。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $2n$ 个数字，第 $i$ 个为 $A_i$。\n\n第三行 $2n$ 个数字，第 $i$ 个为 $B_i$。", "outputFormat": "如果无解则输出 $-1$，否则按照以下方式输出一个字符串 $s$：\n\n对于 $1\\leq i\\leq 2n$，如果 $C_i$ 是从 $A_i$ 选取的则 $s_i=\\texttt{A}$，否则 $s_i=\\texttt{B}$。", "hint": "#### 样例 1 解释\n\n构造的 $C=[2,5,6,9,12,14]$，可以自行这是满足条件的方案。\n\n#### 样例 2 解释\n\n另外有 $\\texttt{AABB},\\texttt{ABAB},\\texttt{BABA},\\texttt{BAAB},\\texttt{ABBA}$ 这 $5$ 组解，输出任何一组均可。\n\n#### 样例 3 解释\n\n没有满足条件的方案。\n\n#### 子任务\n\n| 子任务 | 特殊性质 | 分数 |\n| :----------: | :----------: | :----------: |\n| $1$ | $1\\leq n\\leq 2\\times 10^3$ | $11$ |\n| $2$ | 无 | $89$ |\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 5\\times 10^5,1\\leq A_i,B_i\\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P6892", "type": "P", "difficulty": 7, "samples": [["5\n", "8 to -1\n3 to 8\n6 to 3\n0 to 6\n9 to 0\n"], ["8\n", "10 to -1\n3 to 10\n14 to 3\n7 to 14\n0 to 7\n11 to 0\n4 to 11\n15 to 4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2014", "Special Judge", "构造", "ICPC", "WF"], "title": "[ICPC 2014 WF] Baggage", "background": "", "description": "An airline has two flights leaving at about the same time from ICPCity, one to city B and one to city A. The airline also has $n$ counters where passengers check their baggage. At each counter there is a pair of identical baggage bins, one for city B and one for city A.\n\nJust before the flights depart, each pair of baggage bins is moved by a motorized cart to a sorting area. The cart always moves two bins at a time, one for city B and one for city A. After all the bins have been moved, they line up in the sorting area like this:\n\n  B A B A B A ... B A \n\nThat is, there are $2n$ baggage bins in a row, starting with a bin for city B, then one for city A, and so forth. The task now is to reorder them so all the baggage bins for city A precede the baggage bins for city B. Then the bins can be loaded on the appropriate aircraft.\n\nThe reordering is done by moving pairs of adjacent baggage bins (not necessarily B then A), again via the motorized cart. For proper balance, the cart must always carry two bins, never just one. A pair of bins must always be moved to an empty space that is at least two bins wide. On the left of the first bin are some empty spaces that can be used as needed during the reordering.\n\nWhen the reordering process begins, the bin locations are numbered from $1$ (initially containing the leftmost B baggage bin) to $2n$ (initially containing the rightmost A baggage bin). There are $2n$ initially empty spaces to the left of the bins, numbered from $0$ to $-2n+1$, as shown in Figure 1 for the case $n=4$.\n![](https://cdn.luogu.com.cn/upload/image_hosting/fwkcv2gq.png)\n\n   Figure 1: Initial configuration of bins and empty spaces for $n = 4$ \n\nGiven $n$, find a shortest sequence of moves that will reorder the bins so that all the A bins are to the left of all the B bins. At the end of the process, it is possible that the leftmost A bin is at some location other than $1$, but the bins must be adjacent in a sequence of $2n$ locations.", "inputFormat": "The input consists of a single test case, which consists of the integer $n$ $(3 \\leq n \\leq 100)$.", "outputFormat": "Display a shortest sequence of moves that will correctly reorder the bins. Each move is of the form “$f$ to $t$”, where $f$ and $t$ are integers representing the movement of the bins in locations $f$ and $f + 1$ to locations $t$ and $t + 1$. If multiple solutions are possible, display any one of them.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en", "translations": {"en": {"title": "[ICPC 2014 WF] Baggage", "background": "", "description": "An airline has two flights leaving at about the same time from ICPCity, one to city B and one to city A. The airline also has $n$ counters where passengers check their baggage. At each counter there is a pair of identical baggage bins, one for city B and one for city A.\n\nJust before the flights depart, each pair of baggage bins is moved by a motorized cart to a sorting area. The cart always moves two bins at a time, one for city B and one for city A. After all the bins have been moved, they line up in the sorting area like this:\n\n  B A B A B A ... B A \n\nThat is, there are $2n$ baggage bins in a row, starting with a bin for city B, then one for city A, and so forth. The task now is to reorder them so all the baggage bins for city A precede the baggage bins for city B. Then the bins can be loaded on the appropriate aircraft.\n\nThe reordering is done by moving pairs of adjacent baggage bins (not necessarily B then A), again via the motorized cart. For proper balance, the cart must always carry two bins, never just one. A pair of bins must always be moved to an empty space that is at least two bins wide. On the left of the first bin are some empty spaces that can be used as needed during the reordering.\n\nWhen the reordering process begins, the bin locations are numbered from $1$ (initially containing the leftmost B baggage bin) to $2n$ (initially containing the rightmost A baggage bin). There are $2n$ initially empty spaces to the left of the bins, numbered from $0$ to $-2n+1$, as shown in Figure 1 for the case $n=4$.\n![](https://cdn.luogu.com.cn/upload/image_hosting/fwkcv2gq.png)\n\n   Figure 1: Initial configuration of bins and empty spaces for $n = 4$ \n\nGiven $n$, find a shortest sequence of moves that will reorder the bins so that all the A bins are to the left of all the B bins. At the end of the process, it is possible that the leftmost A bin is at some location other than $1$, but the bins must be adjacent in a sequence of $2n$ locations.", "inputFormat": "The input consists of a single test case, which consists of the integer $n$ $(3 \\leq n \\leq 100)$.", "outputFormat": "Display a shortest sequence of moves that will correctly reorder the bins. Each move is of the form “$f$ to $t$”, where $f$ and $t$ are integers representing the movement of the bins in locations $f$ and $f + 1$ to locations $t$ and $t + 1$. If multiple solutions are possible, display any one of them.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en"}, "zh-CN": {"title": "[ICPC 2014 WF] Baggage", "background": null, "description": "一家航空公司有两趟航班几乎同时从 ICPCity 出发，一趟飞往城市 B，另一趟飞往城市 A。航空公司有 $n$ 个柜台供乘客托运行李。每个柜台都有一对相同的行李箱，一个用于城市 B，一个用于城市 A。\n\n就在航班起飞前，每对行李箱会被一辆电动推车移动到一个分拣区。推车总是一次移动两个箱子，一个用于城市 B，一个用于城市 A。所有箱子移动完后，它们在分拣区排成如下的顺序：\n\nB A B A B A ... B A\n\n也就是说，有 $2n$ 个行李箱排成一行，从一个城市 B 的箱子开始，然后是一个城市 A 的箱子，如此交替。现在的任务是重新排列它们，使得所有城市 A 的行李箱都排在城市 B 的行李箱之前。然后这些箱子可以被装载到相应的飞机上。\n\n重新排列是通过移动相邻的一对行李箱（不一定是 B 然后是 A），同样通过电动推车进行。为了保持平衡，推车必须总是携带两个箱子，不能只携带一个。每对箱子必须移动到至少有两个箱子宽度的空位上。在第一个箱子的左边有一些空位，在重新排列过程中可以根据需要使用。\n\n当重新排列过程开始时，箱子的位置从 $1$ 开始编号（最初包含最左边的 B 行李箱）到 $2n$（最初包含最右边的 A 行李箱）。在箱子的左边有 $2n$ 个初始空位，编号从 $0$ 到 $-2n+1$，如图 1 所示，$n=4$ 的情况。\n\n![图 1](https://cdn.luogu.com.cn/upload/image_hosting/fwkcv2gq.png)\n\n图 1：$n = 4$ 时箱子和空位的初始配置\n\n给定 $n$，找出一个最短的移动序列，以便重新排列箱子，使得所有 A 箱子都在所有 B 箱子的左边。在过程结束时，最左边的 A 箱子可能在位置 $1$ 之外的某个位置，但箱子必须在 $2n$ 个位置的序列中相邻。", "inputFormat": "输入由一个单一的测试用例组成，包含一个整数 $n$ $(3 \\leq n \\leq 100)$。", "outputFormat": "显示一个最短的移动序列，该序列可以正确地重新排列箱子。每个移动的形式为“$f$ to $t$”，其中 $f$ 和 $t$ 是整数，表示位置 $f$ 和 $f + 1$ 的箱子移动到位置 $t$ 和 $t + 1$。如果有多个解决方案，显示其中任意一个。", "hint": "时间限制：1000 毫秒，内存限制：1048576 KB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2014。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6893", "type": "P", "difficulty": 6, "samples": [["2 15\nD 4 10 1\nC 6 1\n", "40.500000000\n"], ["3 15\nD 4 10 1\nC 6 1\nC 9 3\n", "49.000000000\n"], ["2 19\nD 4 5 1\nD 6 3 2\n", "impossible\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2014", "Special Judge", "背包 DP", "ICPC", "WF"], "title": "[ICPC 2014 WF] Buffed Buffet", "background": "", "description": "You are buying lunch at a buffet. A number of different dishes are available, and you can mix and match them to your heart’s desire. Some of the dishes, such as dumplings and roasted potatoes, consist of pieces of roughly equal size, and you can pick an integral number of such pieces (no splitting is allowed). Refer to these as “discrete dishes.” Other dishes, such as tzatziki or mashed potatoes, are fluid and you can pick an arbitrary real-valued amount of them. Refer to this second type as “continuous dishes.”\n\nOf course, you like some of the dishes more than others, but how much you like a dish also depends on how much of it you have already eaten. For instance, even if you generally prefer dumplings to potatoes, you might prefer a potato over a dumpling if you have already eaten ten dumplings. To model this, each dish $i$ has an initial tastiness $t_ i$, and a rate of decay of the tastiness $\\Delta t_ i$. For discrete dishes, the tastiness you experience when eating the $n^{th}$ item of the dish is $t_ i - (n-1)\\Delta t_ i$. For continuous dishes, the tastiness you experience when eating an infinitesimal amount $d x$ grams of the dish after already having eaten $x$ grams is $(t_ i - x \\Delta t_ i) d x$. In other words, the respective total amounts of tastiness you experience when eating $N$ items of a discrete dish or $X$ grams of a continuous dish are as follows:\n\n$$\\begin{aligned} \\sum _{n=1}^{N} (t_ i - (n-1)\\Delta t_ i) & &  \\text {and} & & \\int _{0}^ X (t_ i - x\\Delta t_ i) dx  \\end{aligned} $$\n\nFor simplicity, do not take into account that different dishes may or may not go well together, so define the total tastiness that you experience from a meal as the sum of the total tastinesses of the individual dishes in the meal (and the same goes for the weight of a meal – there are no food antiparticles in the buffet!).\n\nYou have spent days of painstaking research determining the numbers $t_ i$ and $\\Delta t_ i$ for each of the dishes in the buffet. All that remains is to compute the maximum possible total tastiness that can be achieved in a meal of weight $w$. Better hurry up, lunch is going to be served soon!", "inputFormat": "The input consists of a single test case. The first line of input consists of two integers $d$ and $w$ ($1 \\le d \\le {250}$ and $1 \\le w \\le {10\\, 000}$), where $d$ is the number of different dishes at the buffet and $w$ is the desired total weight of your meal in grams.\n\nThen follow $d$ lines, the $i^{th}$ of which describes the $i^{th}$ dish. Each dish description is in one of the following two forms:\n\nA description of the form “D $w_ i$ $t_ i$ $\\Delta t_ i$” indicates that this is a discrete dish where each item weighs $w_ i$ grams, with initial tastiness $t_ i$ and decay of tastiness $\\Delta t_ i$.\n\nA description of the form “C $t_ i$ $\\Delta t_ i$” indicates that this is a continuous dish with initial tastiness $t_ i$ and decay of tastiness $\\Delta t_ i$.\n\nThe numbers $w_ i$, $t_ i$, and $\\Delta t_ i$ are integers satisfying $1 \\le w_ i \\le {10\\, 000}$ and $0 \\le t_ i, \\Delta t_ i \\le {10\\, 000}$.", "outputFormat": "Display the maximum possible total tastiness of a meal of weight $w$ based on the available dishes. Give the answer with a relative or absolute error of at most $10^{-6}$. If it is impossible to make a meal of total weight exactly $w$ based on the available dishes, display impossible.", "hint": "Time limit: 3000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en", "translations": {"en": {"title": "[ICPC 2014 WF] Buffed Buffet", "background": "", "description": "You are buying lunch at a buffet. A number of different dishes are available, and you can mix and match them to your heart’s desire. Some of the dishes, such as dumplings and roasted potatoes, consist of pieces of roughly equal size, and you can pick an integral number of such pieces (no splitting is allowed). Refer to these as “discrete dishes.” Other dishes, such as tzatziki or mashed potatoes, are fluid and you can pick an arbitrary real-valued amount of them. Refer to this second type as “continuous dishes.”\n\nOf course, you like some of the dishes more than others, but how much you like a dish also depends on how much of it you have already eaten. For instance, even if you generally prefer dumplings to potatoes, you might prefer a potato over a dumpling if you have already eaten ten dumplings. To model this, each dish $i$ has an initial tastiness $t_ i$, and a rate of decay of the tastiness $\\Delta t_ i$. For discrete dishes, the tastiness you experience when eating the $n^{th}$ item of the dish is $t_ i - (n-1)\\Delta t_ i$. For continuous dishes, the tastiness you experience when eating an infinitesimal amount $d x$ grams of the dish after already having eaten $x$ grams is $(t_ i - x \\Delta t_ i) d x$. In other words, the respective total amounts of tastiness you experience when eating $N$ items of a discrete dish or $X$ grams of a continuous dish are as follows:\n\n$$\\begin{aligned} \\sum _{n=1}^{N} (t_ i - (n-1)\\Delta t_ i) & &  \\text {and} & & \\int _{0}^ X (t_ i - x\\Delta t_ i) dx  \\end{aligned} $$\n\nFor simplicity, do not take into account that different dishes may or may not go well together, so define the total tastiness that you experience from a meal as the sum of the total tastinesses of the individual dishes in the meal (and the same goes for the weight of a meal – there are no food antiparticles in the buffet!).\n\nYou have spent days of painstaking research determining the numbers $t_ i$ and $\\Delta t_ i$ for each of the dishes in the buffet. All that remains is to compute the maximum possible total tastiness that can be achieved in a meal of weight $w$. Better hurry up, lunch is going to be served soon!", "inputFormat": "The input consists of a single test case. The first line of input consists of two integers $d$ and $w$ ($1 \\le d \\le {250}$ and $1 \\le w \\le {10\\, 000}$), where $d$ is the number of different dishes at the buffet and $w$ is the desired total weight of your meal in grams.\n\nThen follow $d$ lines, the $i^{th}$ of which describes the $i^{th}$ dish. Each dish description is in one of the following two forms:\n\nA description of the form “D $w_ i$ $t_ i$ $\\Delta t_ i$” indicates that this is a discrete dish where each item weighs $w_ i$ grams, with initial tastiness $t_ i$ and decay of tastiness $\\Delta t_ i$.\n\nA description of the form “C $t_ i$ $\\Delta t_ i$” indicates that this is a continuous dish with initial tastiness $t_ i$ and decay of tastiness $\\Delta t_ i$.\n\nThe numbers $w_ i$, $t_ i$, and $\\Delta t_ i$ are integers satisfying $1 \\le w_ i \\le {10\\, 000}$ and $0 \\le t_ i, \\Delta t_ i \\le {10\\, 000}$.", "outputFormat": "Display the maximum possible total tastiness of a meal of weight $w$ based on the available dishes. Give the answer with a relative or absolute error of at most $10^{-6}$. If it is impossible to make a meal of total weight exactly $w$ based on the available dishes, display impossible.", "hint": "Time limit: 3000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en"}, "zh-CN": {"title": "[ICPC 2014 WF] Buffed Buffet", "background": null, "description": "自助餐厅里有 $n$ 种食物，分为两大类，为 “离散食物”和“连续食物”。你可以通过吃食物来获得收益。\n\n离散食物用 $(w,t_0,\\Delta t)$ 描述。对于这种食物，你只能吃整数个，每个重为 $w$。吃的第一个收益为 $t_0$，后面每吃一个收益减少 $\\Delta t$。具体的，吃的第 $i$ 个这种食物 （从 $1$ 开始标号），收益为 $t_0-(i-1)\\Delta t$。\n\n连续食物用 $(t_0,\\Delta t)$ 描述。对于这种食物，你可以吃任意食物的重量。如果你吃的重量为 $w$，获得的收益是 $t_0w-\\dfrac{1}{2}\\Delta t w^2$。\n\n你现在要吃重量和 **恰好** 为 $W$ 的食物。最大化你的收益。", "inputFormat": "第一行是两个整数 $n,W$，接下来每行先来一个字母，如果是 C 表示连续食物，后面跟两个整数表示 $t_0,\\Delta t$；如果是 D 表示离散食物，后面跟三个整数，表示 $w,t_0,\\Delta t$。", "outputFormat": "一行一个数表示答案。相对或绝对误差不超过 $1e-6$。\n\n如果没有一种方案使重量和恰好为 $W$ 输出 `impossible`。", "hint": "$n\\le 250,W\\le 10000$。\n\n对于离散食物，满足 $1\\le w\\le 10000$。\n\n对于所有食物，满足 $0\\le t_0,t\\le 10000$。", "locale": "zh-CN"}}}
{"pid": "P6894", "type": "P", "difficulty": 5, "samples": [["7\n50 50\n0 50\n0 0\n30 0\n30 30\n40 40\n50 40\n", "0 .. 1017\n"], ["7\n50 50\n0 50\n0 0\n10 0\n10 30\n20 40\n50 40\n", "unstable\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "计算几何", "2014", "ICPC", "WF"], "title": "[ICPC 2014 WF] Crane Balancing", "background": "", "description": "Wherever there is large-scale construction, you will find cranes that do the lifting. One hardly ever thinks about what marvelous examples of engineering cranes are: a structure of (relatively) little weight that can lift much heavier loads. But even the best-built cranes may have a limit on how much weight they can lift.\n\nThe Association of Crane Manufacturers (ACM) needs a program to compute the range of weights that a crane can lift. Since cranes are symmetric, ACM engineers have decided to consider only a cross section of each crane, which can be viewed as a polygon resting on the $x$-axis.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2lyejm47.png)\n\n   Figure 1: Crane cross section \n\nFigure 1 shows a cross section of the crane in the first sample input. Assume that every $1 \\times 1$ unit of crane cross section weighs 1 kilogram and that the weight to be lifted will be attached at one of the polygon vertices (indicated by the arrow in Figure 1). Write a program that determines the weight range for which the crane will not topple to the left or to the right.", "inputFormat": "The input consists of a single test case. The test case starts with a single integer $n$ ($3 \\le n \\le 100$), the number of points of the polygon used to describe the crane’s shape. The following $n$ pairs of integers $x_ i, y_ i$ ($-2\\, 000 \\le x_ i \\le 2\\, 000, 0 \\le y_ i \\le 2\\, 000$) are the coordinates of the polygon points in order. The weight is attached at the first polygon point and at least two polygon points are lying on the $x$-axis.", "outputFormat": "Display the weight range (in kilograms) that can be attached to the crane without the crane toppling over. If the range is $[a,b]$, display $\\lfloor a \\rfloor $ .. $\\lceil b \\rceil $. For example, if the range is $[1.5,13.3]$, display 1 .. 14. If the range is $[a,\\infty )$, display $\\lfloor a \\rfloor $ .. inf. If the crane cannot carry any weight, display unstable instead.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en", "translations": {"en": {"title": "[ICPC 2014 WF] Crane Balancing", "background": "", "description": "Wherever there is large-scale construction, you will find cranes that do the lifting. One hardly ever thinks about what marvelous examples of engineering cranes are: a structure of (relatively) little weight that can lift much heavier loads. But even the best-built cranes may have a limit on how much weight they can lift.\n\nThe Association of Crane Manufacturers (ACM) needs a program to compute the range of weights that a crane can lift. Since cranes are symmetric, ACM engineers have decided to consider only a cross section of each crane, which can be viewed as a polygon resting on the $x$-axis.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2lyejm47.png)\n\n   Figure 1: Crane cross section \n\nFigure 1 shows a cross section of the crane in the first sample input. Assume that every $1 \\times 1$ unit of crane cross section weighs 1 kilogram and that the weight to be lifted will be attached at one of the polygon vertices (indicated by the arrow in Figure 1). Write a program that determines the weight range for which the crane will not topple to the left or to the right.", "inputFormat": "The input consists of a single test case. The test case starts with a single integer $n$ ($3 \\le n \\le 100$), the number of points of the polygon used to describe the crane’s shape. The following $n$ pairs of integers $x_ i, y_ i$ ($-2\\, 000 \\le x_ i \\le 2\\, 000, 0 \\le y_ i \\le 2\\, 000$) are the coordinates of the polygon points in order. The weight is attached at the first polygon point and at least two polygon points are lying on the $x$-axis.", "outputFormat": "Display the weight range (in kilograms) that can be attached to the crane without the crane toppling over. If the range is $[a,b]$, display $\\lfloor a \\rfloor $ .. $\\lceil b \\rceil $. For example, if the range is $[1.5,13.3]$, display 1 .. 14. If the range is $[a,\\infty )$, display $\\lfloor a \\rfloor $ .. inf. If the crane cannot carry any weight, display unstable instead.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en"}, "zh-CN": {"title": "[ICPC 2014 WF] Crane Balancing", "background": null, "description": "无论在哪里进行大规模的建筑施工，你都会看到起重机在进行吊装。人们很少会想到起重机是多么奇妙的工程范例：一个（相对）重量较轻的结构可以举起更重的负载。但即使是建造得最好的起重机也可能对它们能举起的重量有一个限制。\n\n起重机制造商协会（ACM）需要一个程序来计算起重机可以举起的重量范围。由于起重机是对称的，ACM 工程师决定只考虑每个起重机的截面，可以视为一个位于 $x$ 轴上的多边形。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2lyejm47.png)\n\n图 1：起重机截面\n\n图 1 显示了第一个样例输入中起重机的截面。假设每 $1 \\times 1$ 单位的起重机截面重 1 千克，所要举起的重量将附着在多边形的一个顶点（图 1 中箭头所示）。编写一个程序来确定起重机不会向左或向右倾覆的重量范围。", "inputFormat": "输入由一个单一的测试用例组成。测试用例以一个整数 $n$ 开始（$3 \\le n \\le 100$），表示用于描述起重机形状的多边形的顶点数。接下来的 $n$ 对整数 $x_i, y_i$ ($-2,000 \\le x_i \\le 2,000, 0 \\le y_i \\le 2,000$) 是多边形顶点的坐标，按顺序给出。重量附着在第一个多边形顶点上，且至少有两个多边形顶点位于 $x$ 轴上。", "outputFormat": "显示可以附加到起重机而不会使其倾覆的重量范围（以千克为单位）。如果范围是 $[a,b]$，则显示 $\\lfloor a \\rfloor\\texttt{ .. }\\lceil b \\rceil$。例如，如果范围是 $[1.5,13.3]$，则显示 $\\texttt{1 .. 14}$。如果范围是 $[a,\\infty)$，则显示 $\\lfloor a \\rfloor\\texttt{ .. inf}$。如果起重机无法承载任何重量，则显示 `unstable`。", "hint": "时间限制：1000 毫秒，内存限制：1048576 KB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2014。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6895", "type": "P", "difficulty": 5, "samples": [["2\n2 ab b\n1 b\n", "0 1 \n-1 0\n"], ["3\n1 b\n2 b a\n2 ab ac\n", "0 1 -1 \n1 0 -1 \n2 2 0\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2014", "ICPC", "WF"], "title": "[ICPC 2014 WF] Game Strategy", "background": "", "description": "Alice and Bob are playing a board game. The board is divided into positions labeled $a, b, c, d, \\dots $ and the players use a gamepiece to mark the current position. Each round of the game consists of two steps:\n\nAlice makes a choice. Depending on the current position, she has different options, where each option is a set of positions. Alice chooses one set $S$ among the available sets of positions.\n\nBob makes a choice. His choice is one position $p$ from the set $S$ that Alice chose in step 1. Bob moves the gamepiece to position $p$, which is the position for the start of the next round.\n\nPrior to the first round, each player independently selects one of the positions and reveals it at the start of the game. Bob’s position is where the game starts. Alice wins the game if she can force Bob to move the gamepiece to the position she has chosen. To make things interesting, they have decided that Bob will pay Alice a certain amount if he loses, but Alice must pay Bob a certain amount after every round. The game now ends if Alice’s position is reached or when Alice runs out of cash.\n\nBoth Alice and Bob play optimally: Alice will always choose an option that will lead to her winning the game, if this is possible, and Bob will always try to prevent Alice from winning.\n\nFor all possible start and end positions, Alice would like you to determine whether she can win the game and if so, how many rounds it will take.", "inputFormat": "The input consists of a single test case. The first line contains the number of positions $n$ ($1 \\leq n \\leq 25$). The $n$ positions are labeled using the first $n$ letters of the English alphabet in lowercase. The rest of the test case consists of $n$ lines, one for each position $p$, in alphabetical order. The line for position $p$ contains the options available to Alice in position $p$. It starts with the number of options $m$ ($1 \\leq m < 2^ n$), which is followed by $m$ distinct strings, one for each option. Each string contains the positions available to Bob if Alice chooses that option. The string has at least $1$ character, the characters (which correspond to valid board positions) are in alphabetical order, and no characters are duplicated. The total number of options for the test case is at most $10^6$.", "outputFormat": "For each position $p$ in alphabetical order, display one line. In that line, for each position $q$ in alphabetical order display the minimal number of rounds in which Alice can be guaranteed to arrive at position $q$ when starting the game in position $p$, or $-1$ if Alice cannot be guaranteed to reach $q$ from $p$.", "hint": "Time limit: 5000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en", "translations": {"en": {"title": "[ICPC 2014 WF] Game Strategy", "background": "", "description": "Alice and Bob are playing a board game. The board is divided into positions labeled $a, b, c, d, \\dots $ and the players use a gamepiece to mark the current position. Each round of the game consists of two steps:\n\nAlice makes a choice. Depending on the current position, she has different options, where each option is a set of positions. Alice chooses one set $S$ among the available sets of positions.\n\nBob makes a choice. His choice is one position $p$ from the set $S$ that Alice chose in step 1. Bob moves the gamepiece to position $p$, which is the position for the start of the next round.\n\nPrior to the first round, each player independently selects one of the positions and reveals it at the start of the game. Bob’s position is where the game starts. Alice wins the game if she can force Bob to move the gamepiece to the position she has chosen. To make things interesting, they have decided that Bob will pay Alice a certain amount if he loses, but Alice must pay Bob a certain amount after every round. The game now ends if Alice’s position is reached or when Alice runs out of cash.\n\nBoth Alice and Bob play optimally: Alice will always choose an option that will lead to her winning the game, if this is possible, and Bob will always try to prevent Alice from winning.\n\nFor all possible start and end positions, Alice would like you to determine whether she can win the game and if so, how many rounds it will take.", "inputFormat": "The input consists of a single test case. The first line contains the number of positions $n$ ($1 \\leq n \\leq 25$). The $n$ positions are labeled using the first $n$ letters of the English alphabet in lowercase. The rest of the test case consists of $n$ lines, one for each position $p$, in alphabetical order. The line for position $p$ contains the options available to Alice in position $p$. It starts with the number of options $m$ ($1 \\leq m < 2^ n$), which is followed by $m$ distinct strings, one for each option. Each string contains the positions available to Bob if Alice chooses that option. The string has at least $1$ character, the characters (which correspond to valid board positions) are in alphabetical order, and no characters are duplicated. The total number of options for the test case is at most $10^6$.", "outputFormat": "For each position $p$ in alphabetical order, display one line. In that line, for each position $q$ in alphabetical order display the minimal number of rounds in which Alice can be guaranteed to arrive at position $q$ when starting the game in position $p$, or $-1$ if Alice cannot be guaranteed to reach $q$ from $p$.", "hint": "Time limit: 5000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en"}, "zh-CN": {"title": "[ICPC 2014 WF] Game Strategy", "background": "", "description": "Alice 和 Bob 正在玩一款棋盘游戏。棋盘被分成了标有 $a,b,c,d,...$ 的位置，玩家们使用游戏棋子来标记当前位置。游戏的每一轮包括两个步骤：\n\nAlice 行动。根据当前位置，她有不同的选择，每个选择都是一组位置。Alice 将从可用的位置集合中选择一个集合 $S$。\n\nBob 行动。他的选择是集合 $S$ 中的一个位置 $p$。Bob 将游戏棋子移动到位置 $p$，这会是下一轮游戏的起始位置。\n\n在第一轮之前，每个玩家独立选择一个位置并在游戏开始时公开位置。Bob 的位置是游戏开始的地方。如果 Alice 能够迫使 Bob 将游戏棋子移动到她选择的位置，Alice 就赢得了比赛。为了使事情更有趣，他们决定如果 Bob 输了，他将支付给 Alice 一定金额，但 Alice 必须在每轮之后向 Bob 支付一定金额。如果 Bob 到达 Alice 的位置或者 Alice 没钱了，游戏就结束了。Alice 和 Bob 都采取最佳策略：如果可能的话，Alice 总是选择会能让她赢得比赛的方案，而 Bob 总是试图阻止 Alice 获胜。对于所有可能的起始和结束位置，Alice 希望你确定她是否能够赢得比赛，如果可以，需要多少轮才能赢得比赛。", "inputFormat": "输入由单组数据组成。第一行包含位置数 $n$ $(1\\le n\\le 25)$，这些位置用英文小写字母的前 $n$ 个字母标记。接下来 $n$ 行，每行表示位置 $p$，按字母顺序排列。位置 $p$ 这一行包含 $Alice$ 在该位置的可选项。每行首先输入一个数 $m$ $(1 \\le m < 2^n)$，后跟 $m$ 个不同字符串，每个字符串表示 Alice 选择该方案时 Bob 可移动到的位置。字符串至少包含 $1$ 个字符，这些字符（对应有效的棋盘位置）按字母顺序排列，没有重复字符。数据的方案总数最多为 $10^6$。", "outputFormat": "对于每一个 $p$ 单独输出一行。在该行中，按字母顺序输出每个位置 $q$ 表示 Alice 开始游戏时可以保证到达的最小轮次，或者如果 Alice 不能保证从 $p$ 到达 $q$，则显示 $-1$。\n\n### **说明/提示**\n\n时间限制： $5000$ ms，空间限制：$1048576$ kB。\n\n来源：International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6896", "type": "P", "difficulty": 6, "samples": [["13\n2 2 4\n3 1 3 5\n2 2 4\n3 1 3 6\n2 2 6\n2 4 5\n2 8 9\n2 7 9\n2 7 8\n2 11 13\n2 10 12\n2 11 13\n2 10 12\n", "2 4\n5 6\n7 8 9 10 11 12 13\n"], ["6\n3 3 4 5\n0\n1 1\n1 1\n2 1 6\n1 5\n", "none\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2014", "哈希 hashing", "ICPC", "WF"], "title": "[ICPC 2014 WF] Maze Reduction", "background": "", "description": "Jay runs a small carnival that has various rides and attractions. Unfortunately, times are tough. A recent roller coaster accident, flooding in the restrooms, and an unfortunate clown incident have given Jay’s carnival a bad reputation with the public. With fewer paying customers and reduced revenue, he will need to cut some costs to stay in business.\n\nOne of the biggest carnival attractions is a large, confusing maze. It consists of a variety of circular rooms connected by narrow, twisting corridors. Visitors love getting lost in it and trying to map it out. It has come to Jay’s attention that some of the rooms might be effectively identical to each other. If that’s the case, he will be able to reduce its size without anyone noticing.\n\nTwo rooms $A$ and $B$ are effectively identical if, when you are dropped into either room $A$ or $B$ (and you know the map of the maze), you cannot tell whether you began in $A$ or $B$ just by exploring the maze. The corridor exits are evenly spaced around each room, and you cannot mark or leave anything in a room (in particular, you cannot tell whether you have previously visited it). The only identifying feature that rooms have is their number of exits. Corridors are also twisty enough to be indistinguishable from each other, but when you enter a room you know which corridor you came from, so you can navigate a little by using the order they appear around the room.\n\nJay has appealed to the Association for Carnival Mazery for help. That’s you! Write a program to determine all the sets of effectively identical rooms in the maze.", "inputFormat": "The input consists of a single test case. The first line contains an integer $n$, the number of rooms in the maze ($1 \\leq n \\leq 100$). Rooms are numbered from 1 to $n$. Following this are $n$ lines, describing each room in order. Each line consists of an integer $k$, indicating that this room has $k$ corridors ($0 \\leq k < 100$), and then $k$ distinct integers listing the rooms each corridor connects to (in clockwise order, from an arbitrary starting point). Rooms do not connect to themselves.", "outputFormat": "Display one line for each maximal set of effectively identical rooms (ignoring sets of size 1) containing the room numbers in the set in increasing order. Order the sets by their smallest room numbers. If there are no such sets, display none instead.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en", "translations": {"en": {"title": "[ICPC 2014 WF] Maze Reduction", "background": "", "description": "Jay runs a small carnival that has various rides and attractions. Unfortunately, times are tough. A recent roller coaster accident, flooding in the restrooms, and an unfortunate clown incident have given Jay’s carnival a bad reputation with the public. With fewer paying customers and reduced revenue, he will need to cut some costs to stay in business.\n\nOne of the biggest carnival attractions is a large, confusing maze. It consists of a variety of circular rooms connected by narrow, twisting corridors. Visitors love getting lost in it and trying to map it out. It has come to Jay’s attention that some of the rooms might be effectively identical to each other. If that’s the case, he will be able to reduce its size without anyone noticing.\n\nTwo rooms $A$ and $B$ are effectively identical if, when you are dropped into either room $A$ or $B$ (and you know the map of the maze), you cannot tell whether you began in $A$ or $B$ just by exploring the maze. The corridor exits are evenly spaced around each room, and you cannot mark or leave anything in a room (in particular, you cannot tell whether you have previously visited it). The only identifying feature that rooms have is their number of exits. Corridors are also twisty enough to be indistinguishable from each other, but when you enter a room you know which corridor you came from, so you can navigate a little by using the order they appear around the room.\n\nJay has appealed to the Association for Carnival Mazery for help. That’s you! Write a program to determine all the sets of effectively identical rooms in the maze.", "inputFormat": "The input consists of a single test case. The first line contains an integer $n$, the number of rooms in the maze ($1 \\leq n \\leq 100$). Rooms are numbered from 1 to $n$. Following this are $n$ lines, describing each room in order. Each line consists of an integer $k$, indicating that this room has $k$ corridors ($0 \\leq k < 100$), and then $k$ distinct integers listing the rooms each corridor connects to (in clockwise order, from an arbitrary starting point). Rooms do not connect to themselves.", "outputFormat": "Display one line for each maximal set of effectively identical rooms (ignoring sets of size 1) containing the room numbers in the set in increasing order. Order the sets by their smallest room numbers. If there are no such sets, display none instead.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en"}, "zh-CN": {"title": "[ICPC 2014 WF] Maze Reduction", "background": "", "description": "Jay 经营着一个小型嘉年华，里面有各种游乐设施。不幸的是，最近发生的过山车事故、厕所的水灾以及小丑事件使得 Jay 的嘉年华在公众中声誉不佳。由于付费顾客减少和收入下降，他需要削减一些成本以维持经营。\n\n嘉年华中最大的吸引点之一是一个大型且复杂的迷宫。它由各种圆形房间组成，这些房间通过狭窄、曲折的走廊连接。游客们喜欢在其中迷路并尝试绘制地图。Jay 注意到，有些房间可能实际上是相同的。如果是这样，他可以在不被人注意的情况下缩小迷宫的规模。\n\n如果你被放置在房间 $A$ 或 $B$ 中（并且你知道迷宫的地图），仅通过探索迷宫无法判断你是从 $A$ 还是 $B$ 开始的，那么两个房间 $A$ 和 $B$ 就是实际上相同的。每个房间的走廊出口均匀分布，你不能在房间中做标记或留下任何东西（特别是，你无法判断你是否曾经访问过它）。房间的唯一识别特征是它们的出口数量。走廊也足够曲折，以至于彼此无法区分，但当你进入一个房间时，你知道你是从哪个走廊来的，因此可以通过它们在房间周围出现的顺序进行一些导航。\n\nJay 向嘉年华迷宫协会求助。那就是你！编写一个程序来确定迷宫中所有实际上相同的房间集合。", "inputFormat": "输入由一个单一的测试用例组成。第一行包含一个整数 $n$，表示迷宫中的房间数量（$1 \\leq n \\leq 100$）。房间从 1 到 $n$ 编号。接下来的 $n$ 行按顺序描述每个房间。每行由一个整数 $k$ 组成，表示该房间有 $k$ 个走廊（$0 \\leq k < 100$），然后是 $k$ 个不同的整数，按顺时针顺序列出每个走廊连接到的房间（从任意起点开始）。房间不与自身连接。", "outputFormat": "对于每个最大化的实际上相同的房间集合（忽略大小为 1 的集合），显示一行，其中包含集合中房间编号的递增顺序。按最小房间编号对集合进行排序。如果没有这样的集合，则显示 none。", "hint": "时间限制：2000 毫秒，内存限制：1048576 kB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2014。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6897", "type": "P", "difficulty": 7, "samples": [["2\n0 0\n0 10\n2\n4 10\n4 0\n", "4.00000\n"], ["2\n0 0\n1 0\n3\n2 0\n3 0\n3 10\n", "5.00000\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["计算几何", "2014", "二分", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2014 WF] Messenger", "background": "", "description": "Misha needs to send packages to his friend Nadia. Both of them often travel across Russia, which is very large. So they decide to hire a messenger. Since the cost of the messenger service depends on the time it takes to deliver the package, they need your help to optimize a little bit.\n\nAssume Misha and Nadia move on a two-dimensional plane, each visiting a sequence of places and moving along straight line segments from place to place. Your task is to find the shortest possible delivery time given their two paths.\n\nMisha hands the package to the messenger at some point along his path. The messenger moves without delay along a straight line from the pick-up to intercept Nadia, who is traveling along her path. Misha, Nadia and the messenger move with a constant speed of $1$ distance unit per time unit. The delivery time is the time between Misha handing over the package and Nadia receiving it.", "inputFormat": "The input consists of a single test case. The test case contains two path descriptions, the first for Misha and the second for Nadia. Each path description starts with a line containing an integer $n$, the number of places visited ($2 \\leq n \\leq 50\\, 000$). This is followed by $n$ lines, each with two integers $x_ i$ and $y_ i$ specifying the coordinates of a place ($0 \\leq x_ i, y_ i \\leq 30\\, 000$). Coordinates of the places are listed in the order in which they are to be visited, and successive places do not have the same coordinates.\n\nMisha and Nadia start their journeys at the same time, visiting the places along their paths without stopping. The length of each path is at most $10^6$. The package must be picked up at the latest when Misha reaches his final place and it must be delivered at the latest when Nadia reaches her final place.", "outputFormat": "Display the minimal time needed for delivery. Give the answer with an absolute error of at most $10^{-3}$ or a relative error of at most $10^{-5}$. If the package cannot be delivered, display impossible instead.", "hint": "Time limit: 3000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en", "translations": {"en": {"title": "[ICPC 2014 WF] Messenger", "background": "", "description": "Misha needs to send packages to his friend Nadia. Both of them often travel across Russia, which is very large. So they decide to hire a messenger. Since the cost of the messenger service depends on the time it takes to deliver the package, they need your help to optimize a little bit.\n\nAssume Misha and Nadia move on a two-dimensional plane, each visiting a sequence of places and moving along straight line segments from place to place. Your task is to find the shortest possible delivery time given their two paths.\n\nMisha hands the package to the messenger at some point along his path. The messenger moves without delay along a straight line from the pick-up to intercept Nadia, who is traveling along her path. Misha, Nadia and the messenger move with a constant speed of $1$ distance unit per time unit. The delivery time is the time between Misha handing over the package and Nadia receiving it.", "inputFormat": "The input consists of a single test case. The test case contains two path descriptions, the first for Misha and the second for Nadia. Each path description starts with a line containing an integer $n$, the number of places visited ($2 \\leq n \\leq 50\\, 000$). This is followed by $n$ lines, each with two integers $x_ i$ and $y_ i$ specifying the coordinates of a place ($0 \\leq x_ i, y_ i \\leq 30\\, 000$). Coordinates of the places are listed in the order in which they are to be visited, and successive places do not have the same coordinates.\n\nMisha and Nadia start their journeys at the same time, visiting the places along their paths without stopping. The length of each path is at most $10^6$. The package must be picked up at the latest when Misha reaches his final place and it must be delivered at the latest when Nadia reaches her final place.", "outputFormat": "Display the minimal time needed for delivery. Give the answer with an absolute error of at most $10^{-3}$ or a relative error of at most $10^{-5}$. If the package cannot be delivered, display impossible instead.", "hint": "Time limit: 3000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en"}, "zh-CN": {"title": "[ICPC 2014 WF] Messenger", "background": "", "description": "平面上有两个移动的点 A,B，其中 A 想要向 B 发送一条信息。两个点会同时出发，各自沿着一个折线移动到终点为止。A 会在移动的途中发送一条信息，这条信息可以视作一个点 C，它会沿一条射线匀速运动，当 C 与 B 重合时，B 即可收到该信息。\n\nA,B,C 的移动速度都是 1 单位长度每秒，A 最晚在它到达终点时发出信息，B 最晚需要在它到达终点时收到信息。令 $t_A$ 代表发送信息的时间，$t_B$ 代表接收信息的时间，那么你需要最小化 $t_B-t_A$ 的值。特别地，如果 B 无论如何都无法收到信息，你需要输出 `impossible`。", "inputFormat": "第一行包含一个整数 $n$，代表 A 经过折线的点数；  \n下面 $n$ 行，每行输入两个整数 $x_i,y_i$，依次描述 A 所走折线的点。  \n下面一行包含一个整数 $m$，B 过折线的点数；  \n下面 $m$ 行，每行输入两个整数 $u_i,v_i$，描述 B 所走折线。", "outputFormat": "一行，输出一个实数，代表答案。若无法满足，则输出`impossible`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6898", "type": "P", "difficulty": 7, "samples": [["5\n4 5 0 2\n1 3 7\n2 0\n4\n", "4\n"], ["7\n1 10 5 5 5 5\n5 10 5 5 5\n100 100 5 5\n10 5 5\n98 99\n3\n", "15\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2014", "2-SAT", "ICPC", "WF"], "title": "[ICPC 2014 WF] Metal Processing Plant", "background": "", "description": "Yulia works for a metal processing plant in Ekaterinburg. This plant processes ores mined in the Ural mountains, extracting precious metals such as chalcopyrite, platinum and gold from the ores. Every month the plant receives $n$ shipments of unprocessed ore. Yulia needs to partition these shipments into two groups based on their similarity. Then, each group is sent to one of two ore processing buildings of the plant.\n\nTo perform this partitioning, Yulia first calculates a numeric distance $d(i, j)$ for each pair of shipments $1 \\le i \\le n$ and $1 \\le j \\le n$, where the smaller the distance, the more similar the shipments $i$ and $j$ are. For a subset $S \\subseteq \\{ 1, \\ldots , n\\} $ of shipments, she then defines the disparity $D$ of $S$ as the maximum distance between a pair of shipments in the subset, that is,\n\n$$ D(S) = \\max _{i, j \\in S} d(i, j). $$\n\nYulia then partitions the shipments into two subsets $A$ and $B$ in such a way that the sum of their disparities $D(A) + D(B)$ is minimized. Your task is to help her find this partitioning.", "inputFormat": "The input consists of a single test case. The first line contains an integer $n$ ($1 \\le n \\le 200$) indicating the number of shipments. The following $n - 1$ lines contain the distances $d(i,j)$. The $i^{th}$ of these lines contains $n - i$ integers and the $j^{th}$ integer of that line gives the value of $d(i, i+j)$. The distances are symmetric, so $d(j, i) = d(i, j)$, and the distance of a shipment to itself is $0$. All distances are integers between $0$ and $10^9$ (inclusive).", "outputFormat": "Display the minimum possible sum of disparities for partitioning the shipments into two groups.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en", "translations": {"en": {"title": "[ICPC 2014 WF] Metal Processing Plant", "background": "", "description": "Yulia works for a metal processing plant in Ekaterinburg. This plant processes ores mined in the Ural mountains, extracting precious metals such as chalcopyrite, platinum and gold from the ores. Every month the plant receives $n$ shipments of unprocessed ore. Yulia needs to partition these shipments into two groups based on their similarity. Then, each group is sent to one of two ore processing buildings of the plant.\n\nTo perform this partitioning, Yulia first calculates a numeric distance $d(i, j)$ for each pair of shipments $1 \\le i \\le n$ and $1 \\le j \\le n$, where the smaller the distance, the more similar the shipments $i$ and $j$ are. For a subset $S \\subseteq \\{ 1, \\ldots , n\\} $ of shipments, she then defines the disparity $D$ of $S$ as the maximum distance between a pair of shipments in the subset, that is,\n\n$$ D(S) = \\max _{i, j \\in S} d(i, j). $$\n\nYulia then partitions the shipments into two subsets $A$ and $B$ in such a way that the sum of their disparities $D(A) + D(B)$ is minimized. Your task is to help her find this partitioning.", "inputFormat": "The input consists of a single test case. The first line contains an integer $n$ ($1 \\le n \\le 200$) indicating the number of shipments. The following $n - 1$ lines contain the distances $d(i,j)$. The $i^{th}$ of these lines contains $n - i$ integers and the $j^{th}$ integer of that line gives the value of $d(i, i+j)$. The distances are symmetric, so $d(j, i) = d(i, j)$, and the distance of a shipment to itself is $0$. All distances are integers between $0$ and $10^9$ (inclusive).", "outputFormat": "Display the minimum possible sum of disparities for partitioning the shipments into two groups.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en"}, "zh-CN": {"title": "[ICPC 2014 WF] Metal Processing Plant", "background": "", "description": "Yulia 在叶卡捷琳堡的一家金属加工厂工作。该工厂处理从乌拉尔山脉开采的矿石，从中提取黄铜矿、铂金和黄金等贵金属。每个月，工厂会收到 $n$ 批未加工的矿石。Yulia 需要根据相似性将这些矿石分成两组。然后，每组被送往工厂的两个矿石加工建筑之一。\n\n为了进行这种划分，Yulia 首先为每对矿石 $1 \\le i \\le n$ 和 $1 \\le j \\le n$ 计算一个数值距离 $d(i, j)$，距离越小，矿石 $i$ 和 $j$ 越相似。对于矿石的一个子集 $S \\subseteq \\{ 1, \\ldots , n\\} $，她定义 $S$ 的差异度 $D$ 为子集中一对矿石之间的最大距离，即，\n\n$$ D(S) = \\max _{i, j \\in S} d(i, j). $$\n\n然后，Yulia 将矿石划分为两个子集 $A$ 和 $B$，使得它们的差异度之和 $D(A) + D(B)$ 最小。你的任务是帮助她找到这种划分。", "inputFormat": "输入由一个单一的测试用例组成。第一行包含一个整数 $n$ ($1 \\le n \\le 200$)，表示矿石的数量。接下来的 $n - 1$ 行包含距离 $d(i,j)$。这些行的第 $i$ 行包含 $n - i$ 个整数，该行的第 $j$ 个整数给出 $d(i, i+j)$ 的值。距离是对称的，因此 $d(j, i) = d(i, j)$，且矿石自身的距离为 $0$。所有距离都是 $0$ 到 $10^9$（含）之间的整数。", "outputFormat": "输出将矿石划分为两组的差异度之和的最小可能值。", "hint": "时间限制：2000 毫秒，内存限制：1048576 kB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2014。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6899", "type": "P", "difficulty": 6, "samples": [["3 2\n20 20 20 40\nX.X\nT.T\n", "0.333333333\n0.666666667\n"], ["4 5\n12 33 28 27\n....\n.XX.\n....\nT..T\nXTTX\n", "0.435853889\n0.403753221\n0.081202502\n0.079190387\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "2014", "Special Judge", "期望", "ICPC", "WF"], "title": "[ICPC 2014 WF] Pachinko", "background": "", "description": "You have been hired by Addictive Coin Machines to help design the next hit in their line of eye-catching, coin-guzzling, just-one-more-try Pachinko machines for casinos around the world.\n\nPlaying a Pachinko machine involves launching balls into a rectangular grid filled with pegs, obstacles, and targets. The ball bounces around the grid until it eventually hits one of the targets. The player earns a certain number of points depending on which target is hit.\n\nThe grid pattern for the next Pachinko machine has already been designed, but point values for the targets have not been assigned. These must be set so that like all casino machines, the machine is profitable but not too profitable. Thus it is important to figure out the probability of a ball hitting any particular target. That’s your job!\n\nFor simplicity, the grid is modeled as a tall rectangle filled with mostly-open spaces (each represented by ‘.’), impassable obstacles (each represented by ‘X’), and targets (each represented by ‘T’).\n\nA ball is launched randomly with uniform probability into one of the mostly-open spaces on the top row of the grid. From that point on, collisions with pegs cause the ball to randomly bounce up, down, left, or right, with various given probabilities. For simplicity, assume these probabilities are the same for every space in the grid. If the ball bounces into an obstacle or attempts to move off the grid, it won’t actually move from its current space. When the ball moves into a target it is removed from play.\n\nYou can safely assume that the average number of spaces visited by a ball before hitting a target will not exceed $10^{9}$. It would not make for a very enjoyable game if the ball just bounces forever!\n\nFor each target, calculate the probability that it is the one hit by a launched ball.", "inputFormat": "The input consists of a single test case. The first line contains integers $w$ and $h$, which are the width and height of the Pachinko grid ($1 \\leq w \\leq 20$ and $2 \\leq h \\leq 10\\, 000$). The next line contains four non-negative integers $u$, $d$, $l$, and $r$, which sum to 100 and are the percentage probabilities of the ball bouncing up, down, left, or right from any open space.\n\nEach of the next $h$ lines contains $w$ characters, each of which is ‘.’, ‘X’, or ‘T’. These lines describe the Pachinko grid. The first line, which describes the top row of the grid, contains at least one ‘.’ and no ‘T’s.", "outputFormat": "Display one line for each ‘T’ in the grid, in order from top to bottom, breaking ties left to right. For each target, display the probability that a launched ball will hit it. Give the answer with an absolute error of at most $10^{-6}$.", "hint": "Time limit: 5000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en", "translations": {"en": {"title": "[ICPC 2014 WF] Pachinko", "background": "", "description": "You have been hired by Addictive Coin Machines to help design the next hit in their line of eye-catching, coin-guzzling, just-one-more-try Pachinko machines for casinos around the world.\n\nPlaying a Pachinko machine involves launching balls into a rectangular grid filled with pegs, obstacles, and targets. The ball bounces around the grid until it eventually hits one of the targets. The player earns a certain number of points depending on which target is hit.\n\nThe grid pattern for the next Pachinko machine has already been designed, but point values for the targets have not been assigned. These must be set so that like all casino machines, the machine is profitable but not too profitable. Thus it is important to figure out the probability of a ball hitting any particular target. That’s your job!\n\nFor simplicity, the grid is modeled as a tall rectangle filled with mostly-open spaces (each represented by ‘.’), impassable obstacles (each represented by ‘X’), and targets (each represented by ‘T’).\n\nA ball is launched randomly with uniform probability into one of the mostly-open spaces on the top row of the grid. From that point on, collisions with pegs cause the ball to randomly bounce up, down, left, or right, with various given probabilities. For simplicity, assume these probabilities are the same for every space in the grid. If the ball bounces into an obstacle or attempts to move off the grid, it won’t actually move from its current space. When the ball moves into a target it is removed from play.\n\nYou can safely assume that the average number of spaces visited by a ball before hitting a target will not exceed $10^{9}$. It would not make for a very enjoyable game if the ball just bounces forever!\n\nFor each target, calculate the probability that it is the one hit by a launched ball.", "inputFormat": "The input consists of a single test case. The first line contains integers $w$ and $h$, which are the width and height of the Pachinko grid ($1 \\leq w \\leq 20$ and $2 \\leq h \\leq 10\\, 000$). The next line contains four non-negative integers $u$, $d$, $l$, and $r$, which sum to 100 and are the percentage probabilities of the ball bouncing up, down, left, or right from any open space.\n\nEach of the next $h$ lines contains $w$ characters, each of which is ‘.’, ‘X’, or ‘T’. These lines describe the Pachinko grid. The first line, which describes the top row of the grid, contains at least one ‘.’ and no ‘T’s.", "outputFormat": "Display one line for each ‘T’ in the grid, in order from top to bottom, breaking ties left to right. For each target, display the probability that a launched ball will hit it. Give the answer with an absolute error of at most $10^{-6}$.", "hint": "Time limit: 5000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en"}, "zh-CN": {"title": "[ICPC 2014 WF] Pachinko", "background": "", "description": "有一个宽度为 $w$ 高度为 $h$ 的方格纸， $ w \\times h$ 的格子中，有一些是空的，有一些是洞，有一些是障碍物。从第一行的空的格子中随机选一个放置一个球，向上下左右移动的概率比为 $p_u : p_d : p_l : p_r$（满足 $p_u + p_d + p_l + p_r = 100$），不能移动到有障碍物的格子上。对于每个洞，输出落入该洞的概率。$w \\le 20, h \\le 10000$。保证第一行没有洞。", "inputFormat": "第一行两个整数表示 $w, h$ 。\n\n第二行四个整数表示 $p_u, p_d, p_l, p_r$ 。\n\n接下来有一个 $h$ 行 $w$ 的字符矩阵，其中 `.` 表示空，`X` 表示障碍物，`T` 表示洞。", "outputFormat": "若干行，每一行一个整数，按照矩阵从上到下，从左到右的顺序，输出每个洞的答案。绝对误差不超过 $10^{-6}$ 即为正确。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6900", "type": "P", "difficulty": 6, "samples": [["4 1\n0 0\n0 1\n1 0\n1 1\n", "2\n1 2\n"], ["5 20\n0 0\n0 2\n100 100\n100 110\n100 120\n", "3\n4 3 5\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2014", "Special Judge", "二分图", "随机化", "ICPC", "WF"], "title": "[ICPC 2014 WF] Sensor Network", "background": "", "description": "\nA wireless sensor network consists of autonomous sensors scattered in an environment where they monitor conditions such as temperature, sound, and pressure. \n\nSamantha is a researcher working on the Amazon Carbon-dioxide Measurement (ACM) project. In this project, a wireless sensor network in the Amazon rainforest gathers environmental information. The Amazon rainforest stores an amount of carbon equivalent to a decade of global fossil fuel emissions, and it plays a crucial role in the world’s oxygen-transfer processes. Because of the huge size of this forest, changes in the forest affect not only the local environment but also global climate by altering wind and ocean current patterns. The goal of the ACM project is to help scientists better understand earth’s complex ecosystems and the impact of human activities.\n\nSamantha has an important hypothesis and to test her hypothesis, she needs to find a subset of sensors in which each pair of sensors can communicate directly with each other. A sensor can communicate directly with any other sensor having distance at most $d$ from it. In order for her experiments to be as accurate as possible, Samantha wants to choose as many sensors as possible.\n\nAs one does not simply walk into the Amazon, Samantha cannot add new sensors or move those that are currently in place. So given the current locations of the sensors, she needs your help to find the largest subset satisfying her criteria. For simplicity, represent the location of each sensor as a point in a two-dimensional plane with the distance between two points being the usual Euclidean distance.", "inputFormat": "The input consists of a single test case. The first line contains two integers $n$ and $d$ ($1 \\le n \\le 100$ and $1 \\le d \\le 10\\, 000$), where $n$ is the number of sensors available and $d$ is the maximum distance between sensors that can communicate directly. Sensors are numbered $1$ to $n$. Each of the next $n$ lines contains two integers $x$ and $y$ ($-10\\, 000\\le x, y \\le 10\\, 000$) indicating the sensor coordinates, starting with the first sensor.", "outputFormat": "Display a maximum subset of sensors in which each pair of sensors can communicate directly. The first line of output should be the size of the subset. The second line of output should be the (one-based) indices of the sensors in the subset. If there are multiple such subsets, any one of them will be accepted.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en", "translations": {"en": {"title": "[ICPC 2014 WF] Sensor Network", "background": "", "description": "\nA wireless sensor network consists of autonomous sensors scattered in an environment where they monitor conditions such as temperature, sound, and pressure. \n\nSamantha is a researcher working on the Amazon Carbon-dioxide Measurement (ACM) project. In this project, a wireless sensor network in the Amazon rainforest gathers environmental information. The Amazon rainforest stores an amount of carbon equivalent to a decade of global fossil fuel emissions, and it plays a crucial role in the world’s oxygen-transfer processes. Because of the huge size of this forest, changes in the forest affect not only the local environment but also global climate by altering wind and ocean current patterns. The goal of the ACM project is to help scientists better understand earth’s complex ecosystems and the impact of human activities.\n\nSamantha has an important hypothesis and to test her hypothesis, she needs to find a subset of sensors in which each pair of sensors can communicate directly with each other. A sensor can communicate directly with any other sensor having distance at most $d$ from it. In order for her experiments to be as accurate as possible, Samantha wants to choose as many sensors as possible.\n\nAs one does not simply walk into the Amazon, Samantha cannot add new sensors or move those that are currently in place. So given the current locations of the sensors, she needs your help to find the largest subset satisfying her criteria. For simplicity, represent the location of each sensor as a point in a two-dimensional plane with the distance between two points being the usual Euclidean distance.", "inputFormat": "The input consists of a single test case. The first line contains two integers $n$ and $d$ ($1 \\le n \\le 100$ and $1 \\le d \\le 10\\, 000$), where $n$ is the number of sensors available and $d$ is the maximum distance between sensors that can communicate directly. Sensors are numbered $1$ to $n$. Each of the next $n$ lines contains two integers $x$ and $y$ ($-10\\, 000\\le x, y \\le 10\\, 000$) indicating the sensor coordinates, starting with the first sensor.", "outputFormat": "Display a maximum subset of sensors in which each pair of sensors can communicate directly. The first line of output should be the size of the subset. The second line of output should be the (one-based) indices of the sensors in the subset. If there are multiple such subsets, any one of them will be accepted.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en"}, "zh-CN": {"title": "[ICPC 2014 WF] Sensor Network", "background": "", "description": "一个无线传感器网络由分散在环境中的自主传感器组成，它们监测温度、声音和压力等条件。\n\nSamantha 是一名研究人员，正在从事亚马逊二氧化碳测量（ACM）项目。在该项目中，亚马逊雨林中的无线传感器网络收集环境信息。亚马逊雨林储存的碳量相当于全球化石燃料排放量的十年，并在全球氧气传输过程中发挥着关键作用。由于这片森林的巨大规模，森林的变化不仅影响当地环境，还通过改变风和洋流模式影响全球气候。ACM 项目的目标是帮助科学家更好地理解地球复杂的生态系统以及人类活动的影响。\n\nSamantha 有一个重要的假设，为了验证她的假设，她需要找到一个传感器子集，其中每对传感器可以直接相互通信。一个传感器可以与距离不超过 $d$ 的任何其他传感器直接通信。为了使她的实验尽可能准确，Samantha 希望选择尽可能多的传感器。\n\n由于不能简单地进入亚马逊，Samantha 不能添加新的传感器或移动当前的位置。因此，给定传感器的当前位置，她需要你的帮助来找到满足她标准的最大子集。为简单起见，将每个传感器的位置表示为二维平面上的一个点，两个点之间的距离为通常的欧几里得距离。", "inputFormat": "输入由一个测试用例组成。第一行包含两个整数 $n$ 和 $d$（$1 \\le n \\le 100$ 且 $1 \\le d \\le 10\\, 000$），其中 $n$ 是可用传感器的数量，$d$ 是可以直接通信的传感器之间的最大距离。传感器编号为 $1$ 到 $n$。接下来的 $n$ 行中的每一行包含两个整数 $x$ 和 $y$（$-10\\, 000\\le x, y \\le 10\\, 000$），表示传感器的坐标，从第一个传感器开始。", "outputFormat": "输出一个最大传感器子集，其中每对传感器可以直接通信。输出的第一行应为子集的大小。第二行应为子集中传感器的（从 1 开始的）索引。如果有多个这样的子集，任何一个都将被接受。", "hint": "时间限制：2000 毫秒，内存限制：1048576 kB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2014。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6901", "type": "P", "difficulty": 7, "samples": [["4 100 400\n-100 100\n50 200\n-100 300\n150 300\n", "1 2 4\n"], ["1 100 100\n1000 10\n", "Cannot visit any targets\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2014", "ICPC", "WF"], "title": "[ICPC 2014 WF] skiing", "background": "", "description": "As you know, the ACM ICPC is not the only major sporting event taking place in Russia this year. Several months ago, the 2014 Winter Olympics were held in Sochi, which is about 3 000 km from Ekaterinburg.\n\nIn an increasing number of sports, it is not only the ability of the athletes that determines who wins a competition but also their equipment. For example in downhill skiing, having the latest ski technology enables athletes to increase their speeds and improve their turning ability.\n\nYou have been hired to determine the effect of the latest ski technology on the ability of skiers to navigate a downhill course. The course contains several target locations, and the skier wants to pass over as many of them as possible. Naturally, the better the ski technology, the easier it will be to do this.\n\nFor simplicity, use a two-dimensional coordinate system where the skier starts at position (0,0) and where “downhill” corresponds to the direction of the positive $y$-axis.\n\nAssume the $y$-component of the athlete’s velocity is a constant $v_ y$. The athlete can change speed laterally (in the $x$-direction), but the skiing equipment limits this to a maximal lateral acceleration $a_{max}$. The skier starts with a lateral velocity of 0.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/us59dhj8.png)\n\n   Figure 1: Downhill ski path passing over three targets \n\nIn Figure 1 (which corresponds to the first sample input), the optimal path passes over three out of four possible targets. If $a_{max}$ were smaller, then the skier might be able to pass over only two or fewer of the targets.", "inputFormat": "The input contains a single test case. The first line contains three integers $n$, $v_ y$, and $a_{max}$ ($0 \\leq n \\leq 250$, $0 < v_ y \\leq 10^5$ and $0 \\leq a_{max} \\leq 10^7$), where $n$ is the number of targets, $v_ y$ is the $y$-component of the skier’s velocity, and $a_{max}$ is the maximum lateral acceleration. Here $v_ y$ is given in meters per hour and $a_{max}$ in meters per hour squared.\n\nFollowing this are $n$ lines, each containing two integers $x_ i$ and $y_ i$ ($-10^5 \\leq x_ i, y_ i \\leq 10^5$). These give the coordinates of each target to be visited on the course. All coordinates are given in meters. Targets are numbered 1, 2, ..., $n$ in the order they are given.", "outputFormat": "Display the maximal-length sequence of targets that the athlete could pass over on the course in a single run. Display the targets in the order they are visited. If there are multiple maximal-length sequences, display only the lexicographically first one. (So the sequence 2 15 would come before the sequence 10 15.) If the athlete cannot pass over any targets, print Cannot visit any targets instead.\n\nTo ensure floating-point stability, you may assume the answer will not change if $a_{max}$ is perturbed by up to 0.1.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en", "translations": {"en": {"title": "[ICPC 2014 WF] skiing", "background": "", "description": "As you know, the ACM ICPC is not the only major sporting event taking place in Russia this year. Several months ago, the 2014 Winter Olympics were held in Sochi, which is about 3 000 km from Ekaterinburg.\n\nIn an increasing number of sports, it is not only the ability of the athletes that determines who wins a competition but also their equipment. For example in downhill skiing, having the latest ski technology enables athletes to increase their speeds and improve their turning ability.\n\nYou have been hired to determine the effect of the latest ski technology on the ability of skiers to navigate a downhill course. The course contains several target locations, and the skier wants to pass over as many of them as possible. Naturally, the better the ski technology, the easier it will be to do this.\n\nFor simplicity, use a two-dimensional coordinate system where the skier starts at position (0,0) and where “downhill” corresponds to the direction of the positive $y$-axis.\n\nAssume the $y$-component of the athlete’s velocity is a constant $v_ y$. The athlete can change speed laterally (in the $x$-direction), but the skiing equipment limits this to a maximal lateral acceleration $a_{max}$. The skier starts with a lateral velocity of 0.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/us59dhj8.png)\n\n   Figure 1: Downhill ski path passing over three targets \n\nIn Figure 1 (which corresponds to the first sample input), the optimal path passes over three out of four possible targets. If $a_{max}$ were smaller, then the skier might be able to pass over only two or fewer of the targets.", "inputFormat": "The input contains a single test case. The first line contains three integers $n$, $v_ y$, and $a_{max}$ ($0 \\leq n \\leq 250$, $0 < v_ y \\leq 10^5$ and $0 \\leq a_{max} \\leq 10^7$), where $n$ is the number of targets, $v_ y$ is the $y$-component of the skier’s velocity, and $a_{max}$ is the maximum lateral acceleration. Here $v_ y$ is given in meters per hour and $a_{max}$ in meters per hour squared.\n\nFollowing this are $n$ lines, each containing two integers $x_ i$ and $y_ i$ ($-10^5 \\leq x_ i, y_ i \\leq 10^5$). These give the coordinates of each target to be visited on the course. All coordinates are given in meters. Targets are numbered 1, 2, ..., $n$ in the order they are given.", "outputFormat": "Display the maximal-length sequence of targets that the athlete could pass over on the course in a single run. Display the targets in the order they are visited. If there are multiple maximal-length sequences, display only the lexicographically first one. (So the sequence 2 15 would come before the sequence 10 15.) If the athlete cannot pass over any targets, print Cannot visit any targets instead.\n\nTo ensure floating-point stability, you may assume the answer will not change if $a_{max}$ is perturbed by up to 0.1.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en"}, "zh-CN": {"title": "[ICPC 2014 WF] skiing", "background": null, "description": "滑雪运动员进行的一次训练可以看作平面上一条从 $(0, 0)$ 出发的曲线，这条曲线在 $y$ 轴正方向上的**速度**是 $v_y$，由于装备限制，在 $x$ 轴上的**加速度**不得超过 $a_{max}$。滑雪运动员在 $x$ 轴上的速度从 $0$ 开始。\n\n在这一次训练中，滑雪运动员需要经过所有 $n$ 个目标点 $(x_i, y_i)$ 中尽可能多的目标点，现在他希望你通过控制他每一时刻的加速度，实现这个目标。", "inputFormat": "第一行三个整数 $n, v_y, a_{max}$ 分别表示目标点数，$y$ 轴速度（米每秒）以及 $x$ 轴加速度上限（米每二次方秒）。\n\n接下来 $n$ 行每行两个整数 $x, y$ 表示目标点的横坐标（米）以及纵坐标（米）。", "outputFormat": "按照目标点被经过的顺序输出最长的目标点序列。若有多个可能的答案，输出字典序最小的。若运动员不能经过任意一个目标点，输出 `Cannot visit any targets`。\n\n为了避免浮点误差，你可以假设对 $a_{max}$ 进行不超过 $0.1$ 的扰动的情况下，答案不变。", "hint": "$0\\le n\\le 250, 0\\le v_y\\le 10^5\n, 0\\le a_{max}\\le 10^7\n, −10^5\\le x, y\\le 10^5$\n, 目标点编号从 1 开始。\n\n~~一句话の题意：输入一些数，输出一些数（或字符串），使输出符合要求。~~", "locale": "zh-CN"}}}
{"pid": "P6902", "type": "P", "difficulty": 5, "samples": [["100 7\n1 50\n50 70\n70 90\n90 40\n20 60\n60 80\n80 20\n", "3\n"], ["8 2\n8 3\n5 7\n", "impossible\n"], ["8 2\n8 4\n5 7\n", "2\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "2014", "倍增", "ICPC", "WF"], "title": "[ICPC 2014 WF] Surveillance", "background": "", "description": "The International Corporation for Protection and Control (ICPC) develops efficient technology for, well, protection and control. Naturally, they are keen to have their own headquarters protected and controlled. Viewed from above, the headquarters building has the shape of a convex polygon. There are several suitable places around it where cameras can be installed to monitor the building. Each camera covers a certain range of the polygon sides (building walls), depending on its position. ICPC wants to minimize the number of cameras needed to cover the whole building.", "inputFormat": "The input consists of a single test case. Its first line contains two integers $n$ and $k$ ($3 \\le n \\le 10^6$ and $1 \\le k \\le 10^6$), where $n$ is the number of walls and $k$ is the number of possible places for installing cameras. Each of the remaining $k$ lines contains two integers $a_ i$ and $b_ i$ ($1 \\le a_ i, b_ i \\le n$). These integers specify which walls a camera at the $i^{th}$ place would cover. If $a_ i \\le b_ i$ then the camera covers each wall $j$ such that $a_ i \\le j \\le b_ i$. If $a_ i > b_ i$ then the camera covers each wall $j$ such that $a_ i \\le j \\le n$ or $1 \\le j \\le b_ i$.", "outputFormat": "Display the minimal number of cameras that suffice to cover each wall of the building. The ranges covered by two cameras may overlap. If the building cannot be covered, display impossible instead.", "hint": "Time limit: 4000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en", "translations": {"en": {"title": "[ICPC 2014 WF] Surveillance", "background": "", "description": "The International Corporation for Protection and Control (ICPC) develops efficient technology for, well, protection and control. Naturally, they are keen to have their own headquarters protected and controlled. Viewed from above, the headquarters building has the shape of a convex polygon. There are several suitable places around it where cameras can be installed to monitor the building. Each camera covers a certain range of the polygon sides (building walls), depending on its position. ICPC wants to minimize the number of cameras needed to cover the whole building.", "inputFormat": "The input consists of a single test case. Its first line contains two integers $n$ and $k$ ($3 \\le n \\le 10^6$ and $1 \\le k \\le 10^6$), where $n$ is the number of walls and $k$ is the number of possible places for installing cameras. Each of the remaining $k$ lines contains two integers $a_ i$ and $b_ i$ ($1 \\le a_ i, b_ i \\le n$). These integers specify which walls a camera at the $i^{th}$ place would cover. If $a_ i \\le b_ i$ then the camera covers each wall $j$ such that $a_ i \\le j \\le b_ i$. If $a_ i > b_ i$ then the camera covers each wall $j$ such that $a_ i \\le j \\le n$ or $1 \\le j \\le b_ i$.", "outputFormat": "Display the minimal number of cameras that suffice to cover each wall of the building. The ranges covered by two cameras may overlap. If the building cannot be covered, display impossible instead.", "hint": "Time limit: 4000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en"}, "zh-CN": {"title": "[ICPC 2014 WF] Surveillance", "background": null, "description": "给定一个长度为 $n$ 的环，有 $k$ 个区域被覆盖，求最小的满足环被完全覆盖的区域数量。", "inputFormat": "第一行两个整数 $n,k$。\n接下来 $k$ 行，每行两个整数表示一个区域。", "outputFormat": "若环不可能被完全覆盖，输出 `impossible`；否则输出一个整数，表示最少的区域数量。", "hint": "$3\\leq n\\leq 10^6,1\\leq k\\leq 10^6.$", "locale": "zh-CN"}}}
{"pid": "P6903", "type": "P", "difficulty": 7, "samples": [["8 3 3 19 3\n0 1 22 1\n0 5 22 5\n1 0 1 6\n5 0 5 6\n9 0 9 6\n13 0 13 6\n17 0 17 6\n21 0 21 6\n", "2\n"], ["1 0 5 10 5\n0 0 10 10\n", "0\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["计算几何", "2014", "平面图", "ICPC", "WF"], "title": "[ICPC 2014 WF] Wire Crossing", "background": "", "description": "Moore’s Law states that the number of transistors on a chip will double every two years. Amazingly, this law has held true for over half a century. Whenever current technology no longer allowed more growth, researchers have come up with new manufacturing technologies to pack circuits even denser. In the near future, this might mean that chips are constructed in three dimensions instead two. But for this problem, two dimensions will be enough.\n\nA problem common to all two-dimensional hardware design (for example chips, graphics cards, motherboards, and so on) is wire placement. Whenever wires are routed on the hardware, it is problematic if they have to cross each other. When a crossing occurs special gadgets have to be used to allow two electrical wires to pass over each other, and this makes manufacturing more expensive.\n\nOur problem is the following: you are given a hardware design with several wires already in place (all of them straight line segments). You are also given the start and end points for a new wire connection to be added. You will have to determine the minimum number of existing wires that have to be crossed in order to connect the start and end points. This connection need not be a straight line. The only requirement is that it cannot cross at a point where two or more wires already meet or intersect.\n\n  ![](https://vj.z180.cn/df2653f5a1b23d354dbe2e33d6438ea6?v=1602904232) \n\n   Figure 1: First sample input \n\nFigure 1 shows the first sample input. Eight existing wires form five squares. The start and end points of the new connection are in the leftmost and rightmost squares, respectively. The black dashed line shows that a direct connection would cross four wires, whereas the optimal solution crosses only two wires (the curved blue line).", "inputFormat": "The input consists of a single test case. The first line contains five integers $m, x_0, y_0, x_1, y_1$, which are the number of pre-existing wires ($m \\le 100$) and the start and end points that need to be connected. This is followed by $m$ lines, each containing four integers $x_ a, y_ a, x_ b, y_ b$ describing an existing wire of non-zero length from $(x_ a, y_ a)$ to $(x_ b,y_ b)$. The absolute value of each input coordinate is less than $10^5$. Each pair of wires has at most one point in common, that is, wires do not overlap. The start and end points for the new wire do not lie on a pre-existing wire.", "outputFormat": "Display the minimum number of wires that have to be crossed to connect the start and end points.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en", "translations": {"en": {"title": "[ICPC 2014 WF] Wire Crossing", "background": "", "description": "Moore’s Law states that the number of transistors on a chip will double every two years. Amazingly, this law has held true for over half a century. Whenever current technology no longer allowed more growth, researchers have come up with new manufacturing technologies to pack circuits even denser. In the near future, this might mean that chips are constructed in three dimensions instead two. But for this problem, two dimensions will be enough.\n\nA problem common to all two-dimensional hardware design (for example chips, graphics cards, motherboards, and so on) is wire placement. Whenever wires are routed on the hardware, it is problematic if they have to cross each other. When a crossing occurs special gadgets have to be used to allow two electrical wires to pass over each other, and this makes manufacturing more expensive.\n\nOur problem is the following: you are given a hardware design with several wires already in place (all of them straight line segments). You are also given the start and end points for a new wire connection to be added. You will have to determine the minimum number of existing wires that have to be crossed in order to connect the start and end points. This connection need not be a straight line. The only requirement is that it cannot cross at a point where two or more wires already meet or intersect.\n\n  ![](https://vj.z180.cn/df2653f5a1b23d354dbe2e33d6438ea6?v=1602904232) \n\n   Figure 1: First sample input \n\nFigure 1 shows the first sample input. Eight existing wires form five squares. The start and end points of the new connection are in the leftmost and rightmost squares, respectively. The black dashed line shows that a direct connection would cross four wires, whereas the optimal solution crosses only two wires (the curved blue line).", "inputFormat": "The input consists of a single test case. The first line contains five integers $m, x_0, y_0, x_1, y_1$, which are the number of pre-existing wires ($m \\le 100$) and the start and end points that need to be connected. This is followed by $m$ lines, each containing four integers $x_ a, y_ a, x_ b, y_ b$ describing an existing wire of non-zero length from $(x_ a, y_ a)$ to $(x_ b,y_ b)$. The absolute value of each input coordinate is less than $10^5$. Each pair of wires has at most one point in common, that is, wires do not overlap. The start and end points for the new wire do not lie on a pre-existing wire.", "outputFormat": "Display the minimum number of wires that have to be crossed to connect the start and end points.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2014", "locale": "en"}, "zh-CN": {"title": "[ICPC 2014 WF] Wire Crossing", "background": "", "description": "摩尔定律指出，芯片上的晶体管数量每两年会翻一番。令人惊讶的是，这一定律在过去半个世纪中一直成立。每当当前技术无法再支持更多增长时，研究人员就会提出新的制造技术，以便将电路打包得更密集。在不久的将来，这可能意味着芯片将以三维而非二维构建。但对于这个问题，二维已经足够了。\n\n所有二维硬件设计（例如芯片、显卡、主板等）中常见的问题是布线。当导线在硬件上布线时，如果它们必须相互交叉，就会出现问题。当发生交叉时，必须使用特殊装置以允许两根电线相互通过，这使得制造成本更高。\n\n我们的问题如下：给定一个已经布置了几根导线的硬件设计（所有导线都是直线段）。还给定一个新的导线连接的起点和终点。你需要确定为了连接起点和终点，必须交叉的现有导线的最小数量。这个连接不需要是直线。唯一的要求是它不能在两个或多个导线已经相交或相遇的点上交叉。\n\n   ![](https://vj.z180.cn/df2653f5a1b23d354dbe2e33d6438ea6?v=1602904232)\n\n   图 1：第一个样例输入\n\n图 1 显示了第一个样例输入。八根现有导线形成了五个正方形。新连接的起点和终点分别位于最左边和最右边的正方形中。黑色虚线表明直接连接将交叉四根导线，而最优解仅交叉两根导线（蓝色曲线）。", "inputFormat": "输入由一个测试用例组成。第一行包含五个整数 $m, x_0, y_0, x_1, y_1$，分别表示已有导线的数量（$m \\le 100$）以及需要连接的起点和终点。接下来是 $m$ 行，每行包含四个整数 $x_ a, y_ a, x_ b, y_ b$，描述了一根从 $(x_ a, y_ a)$ 到 $(x_ b, y_ b)$ 的非零长度的现有导线。每个输入坐标的绝对值小于 $10^5$。每对导线最多有一个公共点，即导线不重叠。新导线的起点和终点不位于已有导线上。", "outputFormat": "输出连接起点和终点所需交叉的最小导线数量。", "hint": "时间限制：2000 毫秒，内存限制：1048576 kB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2014。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6904", "type": "P", "difficulty": 2, "samples": [["42 1 23 4 8 10\n", "104.855110477\n"], ["100 7 615 998 801 3\n", "0.00\n"], ["100 432 406 867 60 1000\n", "399.303813\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2015", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2015 WF] Amalgamated Artichokes", "background": "", "description": " ![](https://vj.z180.cn/751a8fdd9863b69e86176e87e1fd5b20?v=1600415919)  \n\nFatima Cynara is an analyst at Amalgamated Artichokes (AA). As with any company, AA has had some very good times as well as some bad ones. Fatima does trending analysis of the stock prices for AA, and she wants to determine the largest decline in stock prices over various time spans. For example, if over a span of time the stock prices were $19$, $12$, $13$, $11$, $20$ and $14$, then the largest decline would be $8$ between the first and fourth price. If the last price had been $10$ instead of $14$, then the largest decline would have been $10$ between the last two prices. \n\nFatima has done some previous analyses and has found that the stock price over any period of time can be modelled reasonably accurately with the following equation:\n\n$$ \\operatorname {price}(k) = p \\cdot (\\sin (a \\cdot k+b) + \\cos (c \\cdot k+d) + 2) $$\n\nwhere $p$, $a$, $b$, $c$ and $d$ are constants. Fatima would like you to write a program to determine the largest price decline over a given sequence of prices. Figure 1 illustrates the price function for Sample Input 1. You have to consider the prices only for integer values of $k$.\n\n  ![](https://vj.z180.cn/800605356b7337600d5163d2e5d7aab4?v=1600415919) \n\n   Figure 1: Sample Input 1. The largest decline occurs from the fourth to the seventh price. ", "inputFormat": "The input consists of a single line containing $6$ integers $p$ ($1 \\le p \\le 1\\, 000$), $a$, $b$, $c$, $d$ ($0 \\le a, b, c, d \\le 1\\, 000$) and $n$ ($1 \\le n \\le 10^6$). The first $5$ integers are described above. The sequence of stock prices to consider is $\\operatorname {price(1)}, \\operatorname {price(2)}, \\ldots , \\operatorname {price}(n)$.", "outputFormat": "Display the maximum decline in the stock prices. If there is no decline, display the number $0$. Your output should have an absolute or relative error of at most $10^{-6}$.", "hint": "Time limit: 5000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en", "translations": {"en": {"title": "[ICPC 2015 WF] Amalgamated Artichokes", "background": "", "description": " ![](https://vj.z180.cn/751a8fdd9863b69e86176e87e1fd5b20?v=1600415919)  \n\nFatima Cynara is an analyst at Amalgamated Artichokes (AA). As with any company, AA has had some very good times as well as some bad ones. Fatima does trending analysis of the stock prices for AA, and she wants to determine the largest decline in stock prices over various time spans. For example, if over a span of time the stock prices were $19$, $12$, $13$, $11$, $20$ and $14$, then the largest decline would be $8$ between the first and fourth price. If the last price had been $10$ instead of $14$, then the largest decline would have been $10$ between the last two prices. \n\nFatima has done some previous analyses and has found that the stock price over any period of time can be modelled reasonably accurately with the following equation:\n\n$$ \\operatorname {price}(k) = p \\cdot (\\sin (a \\cdot k+b) + \\cos (c \\cdot k+d) + 2) $$\n\nwhere $p$, $a$, $b$, $c$ and $d$ are constants. Fatima would like you to write a program to determine the largest price decline over a given sequence of prices. Figure 1 illustrates the price function for Sample Input 1. You have to consider the prices only for integer values of $k$.\n\n  ![](https://vj.z180.cn/800605356b7337600d5163d2e5d7aab4?v=1600415919) \n\n   Figure 1: Sample Input 1. The largest decline occurs from the fourth to the seventh price. ", "inputFormat": "The input consists of a single line containing $6$ integers $p$ ($1 \\le p \\le 1\\, 000$), $a$, $b$, $c$, $d$ ($0 \\le a, b, c, d \\le 1\\, 000$) and $n$ ($1 \\le n \\le 10^6$). The first $5$ integers are described above. The sequence of stock prices to consider is $\\operatorname {price(1)}, \\operatorname {price(2)}, \\ldots , \\operatorname {price}(n)$.", "outputFormat": "Display the maximum decline in the stock prices. If there is no decline, display the number $0$. Your output should have an absolute or relative error of at most $10^{-6}$.", "hint": "Time limit: 5000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en"}, "zh-CN": {"title": "[ICPC 2015 WF] Amalgamated Artichokes", "background": "", "description": "**题目背景**\n\n法蒂玛是针对联合洋蓟果业公司 (Amalgamated Artichokes , AA) 的股票分析员。和其他的公司一样，联合洋蓟果业公司有的时候行情较好，有的时候不太行。法蒂玛对联合洋蓟果业公司的股票价格做了跟踪分析，她想确定不同时间段内股价最大跌幅是多少。比如如果一段时间内股价分别为19元，12元，13元，11元，20元，14元，则最大的跌幅为第一天和第四天之间的8。如果最后一天的价格不是14元而是10元，则最大跌幅为最后两天股价之间的10元。\n\n法蒂玛做了些前期的分析，发现一段时间的股价可以建模精确合理地表示为以下方程式：\n$$\nprice⁡(k)=p⋅(sin⁡(a⋅k+b)+cos⁡(c⋅k+d)+2)\n$$\n其中$p,a,b,c,d$均为常数。法蒂玛想要你写个程序确定给定价格序列上的最大股价跌幅。\n\n图1说明了第一组样例的价格函数，你只能考虑时间为整数$k$时的价格。\n\n对于第一组样例，最大股价跌幅出现在第四天和第七天之间。\n\n**一句话题意**\n\n对于给定序列，求差值最大的逆序对", "inputFormat": "输入共一行，包含六个整数$p (1 \\le p \\le 1000), a, b, c, d ( 0 \\le a, b, c, d \\le 1\\, 000)$ 和$ n (1 \\le n \\le 10^6).$\n\n前五个整数意义如题目所述，给定序列长度为n。", "outputFormat": "输出股价最大跌幅，如果没有股价下跌则输出0。\n\n输出最多和标准答案有$10^{-6}$的相对或绝对误差。", "hint": "时间限制: 5000 ms \n\n空间限制: 1048576 kB.\n\nInternational Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "zh-CN"}}}
{"pid": "P6905", "type": "P", "difficulty": 7, "samples": [["6 3 2 2 4 3 6 6 6 7 4 6 2 2 2\n4 18 5 22 9 26 5 22 1 -2 1\n", "4.193518\n"], ["4 0 0 0 2 2 2 2 0 -1 1\n4 10 0 10 2 12 2 12 0 1 1\n", "never\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2015", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2015 WF] Asteroids", "background": "", "description": "The year is 2115. The asteroid communication relay system was set up a decade ago by the Asteroid Communication Ministry. It is running fine except for one small problem – there are too many asteroids! The smaller ones not only keep interfering with the signals from the relay stations but they are also a danger to all the maintenance aircrafts that fly between the stations. These small asteroids must be destroyed! The Interplanetary Coalition to Prevent Catastrophes (ICPC) has been charged with removing these dangerous asteroids and has hired an elite team of hot-shot pilots for the job. Han Duo is the captain of this team of asteroid destroyers. Armed with his missiles, Han flies through the asteroid belt blowing up any asteroid that the ICPC deems a nuisance.\n\nThe ICPC is having some unfortunate budgetary problems. One result of this is that Han and his team do not have as many missiles as they would like, so they cannot blow up all the troublesome asteroids. But the asteroids are small and the missiles are powerful. So if two asteroids are near each other and line up properly, it is possible to take out both with a single missile.\n\nHan’s screen displays asteroids as non-rotating two-dimensional simple convex polygons, each of which moves at a fixed velocity. He has decided that the best time to hit two asteroids is when the overlap of the two polygons is at a maximum. For example, Figure 1, which illustrates Sample Input 1, shows two asteroids and snapshots of their subsequent positions at 1-second intervals. The two asteroids start touching after $3$ seconds and the maximum overlap area occurs between $4$ and $5$ seconds.\n\n  ![](https://vj.z180.cn/c0ee84911e97a539823bc119cb23e0d7?v=1603764626) \n\n   Figure 1: Sample Input 1. Two asteroids with crossing paths. \n\nCalculating when the maximum overlap occurs for two asteroids requires a bit of programming, but unfortunately Han slept through most of his coding classes at the flight academy. This is where you come in.", "inputFormat": "The input consists of two asteroid specifications. Each has the form $n\\; x_{1}\\; y_{1}\\; x_{2}\\; y_{2}\\; \\ldots \\; x_{n}\\; y_{n}\\; v_{x}\\; v_{y}$ where $n$ $(3 \\le n \\le 10)$ is the number of vertices, each $x_{i}, y_{i}$ ($-10\\, 000 \\le x_{i}, y_{i} \\le 10\\, 000$) are the coordinates of a vertex of the asteroid on Han’s screen given in clockwise order, and $v_{x}, v_{y}$ ($-100 \\le v_{x}, v_{y} \\le 100$) are the $x$ and $y$ velocities (in units/second) of the asteroid. The $x_{i}$, $y_{i}$ values specify the location of each asteroid at time $t=0$, and the polygons do not intersect or touch at this time. The maximum length of any side of an asteroid is $500$. All numbers in the input are integers.", "outputFormat": "Display the time in seconds when the two polygons have maximum intersection, using the earliest such time if there is more than one. If the two polygons never overlap but touch each other, treat it as an intersection where the common area is zero and display the earliest such time. If the polygons never overlap or touch, display never instead. You should consider positive times only. Your output should have an absolute or relative error of at most $10^{-3}$.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015\n \nspj provider:@[shenyouran](/user/137367).", "locale": "en", "translations": {"en": {"title": "[ICPC 2015 WF] Asteroids", "background": "", "description": "The year is 2115. The asteroid communication relay system was set up a decade ago by the Asteroid Communication Ministry. It is running fine except for one small problem – there are too many asteroids! The smaller ones not only keep interfering with the signals from the relay stations but they are also a danger to all the maintenance aircrafts that fly between the stations. These small asteroids must be destroyed! The Interplanetary Coalition to Prevent Catastrophes (ICPC) has been charged with removing these dangerous asteroids and has hired an elite team of hot-shot pilots for the job. Han Duo is the captain of this team of asteroid destroyers. Armed with his missiles, Han flies through the asteroid belt blowing up any asteroid that the ICPC deems a nuisance.\n\nThe ICPC is having some unfortunate budgetary problems. One result of this is that Han and his team do not have as many missiles as they would like, so they cannot blow up all the troublesome asteroids. But the asteroids are small and the missiles are powerful. So if two asteroids are near each other and line up properly, it is possible to take out both with a single missile.\n\nHan’s screen displays asteroids as non-rotating two-dimensional simple convex polygons, each of which moves at a fixed velocity. He has decided that the best time to hit two asteroids is when the overlap of the two polygons is at a maximum. For example, Figure 1, which illustrates Sample Input 1, shows two asteroids and snapshots of their subsequent positions at 1-second intervals. The two asteroids start touching after $3$ seconds and the maximum overlap area occurs between $4$ and $5$ seconds.\n\n  ![](https://vj.z180.cn/c0ee84911e97a539823bc119cb23e0d7?v=1603764626) \n\n   Figure 1: Sample Input 1. Two asteroids with crossing paths. \n\nCalculating when the maximum overlap occurs for two asteroids requires a bit of programming, but unfortunately Han slept through most of his coding classes at the flight academy. This is where you come in.", "inputFormat": "The input consists of two asteroid specifications. Each has the form $n\\; x_{1}\\; y_{1}\\; x_{2}\\; y_{2}\\; \\ldots \\; x_{n}\\; y_{n}\\; v_{x}\\; v_{y}$ where $n$ $(3 \\le n \\le 10)$ is the number of vertices, each $x_{i}, y_{i}$ ($-10\\, 000 \\le x_{i}, y_{i} \\le 10\\, 000$) are the coordinates of a vertex of the asteroid on Han’s screen given in clockwise order, and $v_{x}, v_{y}$ ($-100 \\le v_{x}, v_{y} \\le 100$) are the $x$ and $y$ velocities (in units/second) of the asteroid. The $x_{i}$, $y_{i}$ values specify the location of each asteroid at time $t=0$, and the polygons do not intersect or touch at this time. The maximum length of any side of an asteroid is $500$. All numbers in the input are integers.", "outputFormat": "Display the time in seconds when the two polygons have maximum intersection, using the earliest such time if there is more than one. If the two polygons never overlap but touch each other, treat it as an intersection where the common area is zero and display the earliest such time. If the polygons never overlap or touch, display never instead. You should consider positive times only. Your output should have an absolute or relative error of at most $10^{-3}$.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015\n \nspj provider:@[shenyouran](/user/137367).", "locale": "en"}, "zh-CN": {"title": "[ICPC 2015 WF] Asteroids", "background": "今年是 $2115$ 年。小行星通信中继系统是十年前由小行星通信部建立的。有一个小问题——小行星太多，它们很危险！比较小的小行星不仅不断干扰中继站的信号，而且对在中继站之间飞行的所有维修飞机也是一种危险。这些小行星必须被摧毁！防止危险的星际联盟（ICPC）已被下达移除这些危险的小行星的指令，并请了一支精英团队来完成这项工作。Han Duo 是这个小行星驱逐舰小组的队长。Han Duo 带着他的导弹飞过小行星带，炸毁了 ICPC 认为的令人讨厌的任何小行星。", "description": "ICPC 没那么多钱。后果是 Han Duo 和他的团队没有他们想要的那么多导弹，因此他们无法炸毁所有麻烦的小行星。但是小行星很小，导弹也很强大。因此，如果两颗小行星彼此靠近并正确排列，就有可能用一枚导弹将两者都摧毁。\n\nHan Duo 的屏幕将小行星显示为非旋转的二维简单凸多边形，每个多边形都以固定速度移动。他认为撞击两颗小行星的最佳时间是两个多边形的重叠达到最大值时。例如，图 $1$ 演示了样例输入 $1$，显示了两颗小行星及其后续的位置，间隔 $1$ 秒。两颗小行星在 $33$ 秒后开始接触，最大重叠区域出现在 $44$ 到 $55$ 秒之间。\n\n图 $1$：样例输入 $1$。两颗有交叉路径的小行星。\n\n计算两颗小行星的最大重叠时间需要计算机来完成，但不幸的是，Han Duo 在飞行学院的大部分程序设计课中都在睡大觉。现在把这个任务交由你。", "inputFormat": "输入包括两个小行星规格。每个形式为 $n, x_1, y_1 ,x_2,y_2 \\cdots x_n ,y_n ,v_x, v_y$，其中 $n$（$3 \\le n \\le10$）是顶点的数量，每个 $x_i,y_i$（$-10000 \\leq x_i,y_i \\leq 10000$）在屏幕上按顺时针顺序给出的小行星顶点的坐标，$v_x,v_y$（$-100 \\le v_x,v_y \\le 100$）是小行星的 $x$ 和 $y$ 速度（单位/秒），$x,y$ 值代表 $t=0$ 时每个小行星的位置，此时多边形不相交或接触。小行星任意一侧的最大长度为 $500$。输入中的所有数字都是整数。", "outputFormat": "以秒为单位输出两个多边形具有最大相交的时间，如果存在多个多边形，则使用最早的时间。如果两个多边形从不重叠，而是彼此接触，则将其视为公共面积为零的交点，并输出最早的时间。如果多边形从不重叠或接触，则输出 `never`。你应该只考虑确定的时候。输出的绝对或相对的误差应不超过 $10^{-3}$。", "hint": "时间限制：$2000$ 毫秒，内存限制：$1048576$ kB。\n\n2015年国际大学生编程大赛（ACM-ICPC）世界总决赛。", "locale": "zh-CN"}}}
{"pid": "P6906", "type": "P", "difficulty": 6, "samples": [["3 2\n40 30 40\n50 10\n50\n", "80\n"], ["3 2\n10 10 10\n20 21\n21\n", "40\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2015", "ICPC", "WF"], "title": "[ICPC 2015 WF] Catering", "background": "", "description": "Paul owns a catering company and business is booming. The company has $k$ catering teams, each in charge of one set of catering equipment. Every week, the company accepts $n$ catering requests for various events. For every request, they send a catering team with their equipment to the event location. The team delivers the food, sets up the equipment, and instructs the host on how to use the equipment and serve the food. After the event, the host is responsible for returning the equipment back to Paul’s company. \n\nUnfortunately, in some weeks the number of catering teams is less than the number of requests, so some teams may have to be used for more than one event. In these cases, the company cannot wait for the host to return the equipment and must keep the team on-site to move the equipment to another location. The company has an accurate estimate of the cost to move a set of equipment from any location to any other location. Given these costs, Paul wants to prepare an Advance Catering Map to service the requests while minimizing the total moving cost of equipment (including the cost of the first move), even if that means not using all the available teams. Paul needs your help to write a program to accomplish this task. The requests are sorted in ascending order of their event times and they are chosen in such a way that for any $i < j$, there is enough time to transport the equipment used in the $i^{th}$ request to the location of the $j^{th}$ request.", "inputFormat": "The first line of input contains two integers $n$ ($1 \\le n \\le 100$) and $k$ ($1 \\le k \\le 100$) which are the number of requests and the number of catering teams, respectively. Following that are $n$ lines, where the $i^{th}$ line contains $n-i+1$ integers between $0$ and $1\\, 000\\, 000$ inclusive. The $j^{th}$ number in the $i^{th}$ line is the cost of moving a set of equipment from location $i$ to location $i+j$. The company is at location $1$ and the $n$ requests are at locations $2$ to $n+1$.", "outputFormat": "Display the minimum moving cost to service all requests. (This amount does not include the cost of moving the equipment back to the catering company.)", "hint": "Time limit: 4000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en", "translations": {"en": {"title": "[ICPC 2015 WF] Catering", "background": "", "description": "Paul owns a catering company and business is booming. The company has $k$ catering teams, each in charge of one set of catering equipment. Every week, the company accepts $n$ catering requests for various events. For every request, they send a catering team with their equipment to the event location. The team delivers the food, sets up the equipment, and instructs the host on how to use the equipment and serve the food. After the event, the host is responsible for returning the equipment back to Paul’s company. \n\nUnfortunately, in some weeks the number of catering teams is less than the number of requests, so some teams may have to be used for more than one event. In these cases, the company cannot wait for the host to return the equipment and must keep the team on-site to move the equipment to another location. The company has an accurate estimate of the cost to move a set of equipment from any location to any other location. Given these costs, Paul wants to prepare an Advance Catering Map to service the requests while minimizing the total moving cost of equipment (including the cost of the first move), even if that means not using all the available teams. Paul needs your help to write a program to accomplish this task. The requests are sorted in ascending order of their event times and they are chosen in such a way that for any $i < j$, there is enough time to transport the equipment used in the $i^{th}$ request to the location of the $j^{th}$ request.", "inputFormat": "The first line of input contains two integers $n$ ($1 \\le n \\le 100$) and $k$ ($1 \\le k \\le 100$) which are the number of requests and the number of catering teams, respectively. Following that are $n$ lines, where the $i^{th}$ line contains $n-i+1$ integers between $0$ and $1\\, 000\\, 000$ inclusive. The $j^{th}$ number in the $i^{th}$ line is the cost of moving a set of equipment from location $i$ to location $i+j$. The company is at location $1$ and the $n$ requests are at locations $2$ to $n+1$.", "outputFormat": "Display the minimum moving cost to service all requests. (This amount does not include the cost of moving the equipment back to the catering company.)", "hint": "Time limit: 4000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en"}, "zh-CN": {"title": "[ICPC 2015 WF] Catering", "background": "", "description": "Paul 拥有一家餐饮公司，生意兴隆。公司有 $k$ 个餐饮团队，每个团队负责一套餐饮设备。每周，公司会接受 $n$ 个不同活动的餐饮请求。对于每个请求，他们会派遣一个餐饮团队及其设备到活动地点。团队负责送餐、安装设备，并指导主办方如何使用设备和提供餐饮。活动结束后，主办方负责将设备归还给 Paul 的公司。\n\n不幸的是，有些周的餐饮团队数量少于请求数量，因此一些团队可能需要用于多个活动。在这种情况下，公司不能等待主办方归还设备，必须让团队留在现场以便将设备转移到另一个地点。公司可以准确估算从任何地点到任何其他地点移动一套设备的成本。鉴于这些成本，Paul 希望准备一份“高级餐饮地图”以满足请求，同时最小化设备的总移动成本（包括首次移动的成本），即使这意味着不使用所有可用的团队。Paul 需要你的帮助来编写一个程序来完成这个任务。请求按活动时间的升序排序，并且选择这些请求的方式是，对于任何 $i < j$，都有足够的时间将用于第 $i$ 个请求的设备运输到第 $j$ 个请求的地点。", "inputFormat": "输入的第一行包含两个整数 $n$ ($1 \\le n \\le 100$) 和 $k$ ($1 \\le k \\le 100$)，分别表示请求的数量和餐饮团队的数量。接下来的 $n$ 行中，第 $i$ 行包含 $n-i+1$ 个整数，范围在 $0$ 到 $1,000,000$ 之间（包含）。第 $i$ 行的第 $j$ 个数字表示将一套设备从位置 $i$ 移动到位置 $i+j$ 的成本。公司位于位置 $1$，$n$ 个请求位于位置 $2$ 到 $n+1$。", "outputFormat": "显示服务所有请求的最小移动成本。（此金额不包括将设备移回餐饮公司的成本。）", "hint": "时间限制：4000 毫秒，内存限制：1048576 kB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2015。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6907", "type": "P", "difficulty": 5, "samples": [["0 4\n", "25.000000000\n25.000000000\n25.000000000\n25.000000000\n"], ["2 5\n10000 10000 20000 20000\n40000 40000 50000 60000\n", "14.611103142\n16.269801734\n24.092457788\n27.002992272\n18.023645064\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2015", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2015 WF] Cutting Cheese", "background": "", "description": " ![](https://vj.z180.cn/5f637f1053193ffad543787cd8bc5b2a?v=1601501213)  \n\nOf course you have all heard of the International Cheese Processing Company. Their machine for cutting a piece of cheese into slices of exactly the same thickness is a classic. Recently they produced a machine able to cut a spherical cheese (such as Edam) into slices – no, not all of the same thickness, but all of the same weight! But new challenges lie ahead: cutting Swiss cheese. \n\nSwiss cheese such as Emmentaler has holes in it, and the holes may have different sizes. A slice with holes contains less cheese and has a lower weight than a slice without holes. So here is the challenge: cut a cheese with holes in it into slices of equal weight.\n\nBy smart sonar techniques (the same techniques used to scan unborn babies and oil fields), it is possible to locate the holes in the cheese up to micrometer precision. For the present problem you may assume that the holes are perfect spheres.\n\nEach uncut block has size $100 \\times 100 \\times 100$ where each dimension is measured in millimeters. Your task is to cut it into $s$ slices of equal weight. The slices will be $100$ mm wide and $100$ mm high, and your job is to determine the thickness of each slice.", "inputFormat": "The first line of the input contains two integers $n$ and $s$, where $0 \\leq n \\leq 10\\, 000$ is the number of holes in the cheese, and $1 \\le s \\le 100$ is the number of slices to cut. The next $n$ lines each contain four positive integers $r$, $x$, $y$, and $z$ that describe a hole, where $r$ is the radius and $x$, $y$, and $z$ are the coordinates of the center, all in micrometers.\n\nThe cheese block occupies the points $(x,y,z)$ where $0 \\le x,y,z \\le 100\\, 000$, except for the points that are part of some hole. The cuts are made perpendicular to the $z$ axis.\n\nYou may assume that holes do not overlap but may touch, and that the holes are fully contained in the cheese but may touch its boundary.", "outputFormat": "Display the $s$ slice thicknesses in millimeters, starting from the end of the cheese with $z=0$. Your output should have an absolute or relative error of at most $10^{-6}$.", "hint": "Time limit: 3000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en", "translations": {"en": {"title": "[ICPC 2015 WF] Cutting Cheese", "background": "", "description": " ![](https://vj.z180.cn/5f637f1053193ffad543787cd8bc5b2a?v=1601501213)  \n\nOf course you have all heard of the International Cheese Processing Company. Their machine for cutting a piece of cheese into slices of exactly the same thickness is a classic. Recently they produced a machine able to cut a spherical cheese (such as Edam) into slices – no, not all of the same thickness, but all of the same weight! But new challenges lie ahead: cutting Swiss cheese. \n\nSwiss cheese such as Emmentaler has holes in it, and the holes may have different sizes. A slice with holes contains less cheese and has a lower weight than a slice without holes. So here is the challenge: cut a cheese with holes in it into slices of equal weight.\n\nBy smart sonar techniques (the same techniques used to scan unborn babies and oil fields), it is possible to locate the holes in the cheese up to micrometer precision. For the present problem you may assume that the holes are perfect spheres.\n\nEach uncut block has size $100 \\times 100 \\times 100$ where each dimension is measured in millimeters. Your task is to cut it into $s$ slices of equal weight. The slices will be $100$ mm wide and $100$ mm high, and your job is to determine the thickness of each slice.", "inputFormat": "The first line of the input contains two integers $n$ and $s$, where $0 \\leq n \\leq 10\\, 000$ is the number of holes in the cheese, and $1 \\le s \\le 100$ is the number of slices to cut. The next $n$ lines each contain four positive integers $r$, $x$, $y$, and $z$ that describe a hole, where $r$ is the radius and $x$, $y$, and $z$ are the coordinates of the center, all in micrometers.\n\nThe cheese block occupies the points $(x,y,z)$ where $0 \\le x,y,z \\le 100\\, 000$, except for the points that are part of some hole. The cuts are made perpendicular to the $z$ axis.\n\nYou may assume that holes do not overlap but may touch, and that the holes are fully contained in the cheese but may touch its boundary.", "outputFormat": "Display the $s$ slice thicknesses in millimeters, starting from the end of the cheese with $z=0$. Your output should have an absolute or relative error of at most $10^{-6}$.", "hint": "Time limit: 3000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en"}, "zh-CN": {"title": "[ICPC 2015 WF] Cutting Cheese", "background": "", "description": "# 题目背景\n\n当然，你们都已经听说过国际奶酪加工公司。他们将一块奶酪切成完全相同厚度的薄片的机器是一个经典。最近，他们生产了一种能将球形奶酪（比如荷兰球形干酪）切成薄片的机器——不，不是所有的厚度都一样，而是所有的质量都一样！但是新的挑战摆在面前：切瑞士奶酪。\n\n瑞士奶酪，比如瑞士多孔奶酪，在其中有很多洞，并且这些洞大小可能不同。一片有空洞的奶酪比一片没有洞的奶酪含量更少，质量更轻。所以这是一个挑战：将一块有空洞的奶酪切成质量相同的薄片。\n\n通过智能声呐技术（与过去常常探测未出生的婴儿和油田的技术一样），可以将空洞定位精确到微米级别。对于目前的问题，你可以认为这些洞是完美球体。\n\n每一个未切割的奶酪块尺寸为 $100\\times100\\times100$，其中单位为毫米。你的任务是把它切成 $s$ 个质量相等的薄片。这些薄片宽度和高度都应当是 $100\\operatorname{mm}$，然后你的工作是求出每个薄片的厚度。\n\n## 简化题意\n\n有一个 $100 \\text{mm} \\times 100 \\text{mm} \\times 100 \\text{mm}$ 的质地均匀的正方体，垂直于 $z$ 轴的切成 $s$ 个薄片，使得每一片质量相等。每一薄片宽度和高度都是 $100 \\text{mm}$，请从奶酪底端 $z=0$ 开始依次输出每一片的厚度。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $s$，其中 $0 \\leq n \\leq 10000$ 表示奶酪中洞的个数，然后 $1 \\le s \\le 100$ 表示要切割的薄片数。接下来的 $n$ 行分别包含四个描述空洞的正整数 $r,x,y,z$，其中 $r$ 表示半径，$x$、$y$ 和 $z$ 表示空洞中心坐标，都以微米为单位。\n\n奶酪的圆心 $(x,y,z)$ 中 $0 \\le x,y,z \\le 100000$，除了某个孔的部分点（即某个孔的部分点可能超出该范围，但是圆心一定在这之内）。刀切的方向垂直于 $z$ 轴。\n\n你可以认为这些洞没有重叠但是可能接触，并且这些孔完全包含在奶酪里，但可能接触奶酪的边界。", "outputFormat": "输出保留 $9$ 位小数。从奶酪底端 $z=0$ 开始，以毫米为单位输出 $s$ 个薄片厚度。相对误差或绝对误差不能超过 $10^{-6}$。", "hint": "时间限制：$3000 \\text{ms}$，空间限制：$1048576\\text{kB}$。\n\n2015年国际大学生编程大赛（ACM-ICPC）世界总决赛", "locale": "zh-CN"}}}
{"pid": "P6908", "type": "P", "difficulty": 5, "samples": [["5\nAACCMMAA\nACA\nMM\nACMAA\nAA\nA\n", "1 4\nMM\nA\nAA\nACA\nACMAA\n"], ["3\nACMA\nACM\nACA\nAMA\n", "impossible\n"], ["1\nAM\nMA\n", "impossible\n"], ["4\nAAAAAA\nAA\nAAA\nA\nAAAAA\n", "0 4\nA\nAA\nAAA\nAAAAA\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2015", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2015 WF] Evolution in Parallel", "background": "", "description": "It is 2178, and alien life has been discovered on a distant planet. There seems to be only one species on the planet and they do not reproduce as animals on Earth do. Even more amazing, the genetic makeup of every single organism is identical!\n\nThe genetic makeup of each organism is a single sequence of nucleotides. The nucleotides come in three types, denoted by ‘A’ (Adenine), ‘C’ (Cytosine), and ‘M’ (Muamine). According to one hypothesis, evolution on this planet occurs when a new nucleotide is inserted somewhere into the genetic sequence of an existing organism. If this change is evolutionarily advantageous, then organisms with the new sequence quickly replace ones with the old sequence.\n\nIt was originally thought that the current species evolved this way from a single, very simple organism with a single-nucleotide genetic sequence, by way of mutations as described above. However, fossil evidence suggests that this might not have been the case. Right now, the research team you are working with is trying to validate the concept of “parallel evolution” – that there might actually have been two evolutionary paths evolving in the fashion described above, and eventually both paths evolved to the single species present on the planet today. Your task is to verify whether the parallel evolution hypothesis is consistent with the genetic material found in the fossil samples gathered by your team.", "inputFormat": "The input begins with a number $n$ ($1\\le n\\le 4\\, 000$) denoting the number of nucleotide sequences found in the fossils. The second line describes the nucleotide sequence of the species currently living on the planet. Each of the next $n$ lines describes one nucleotide sequence found in the fossils.\n\nEach nucleotide sequence consists of a string of at least one but no more than $4\\, 000$ letters. The strings contain only upper-case letters A, C, and M. All the nucleotide sequences, including that of the currently live species, are distinct.", "outputFormat": "Display an example of how the nucleotide sequences in the fossil record participate in two evolutionary paths. The example should begin with one line containing two integers $s_1$ and $s_2$, the number of nucleotide sequences in the fossil record that participate in the first path and second path, respectively. This should be followed by $s_1$ lines containing the sequences attributed to the first path, in chronological order (from the earliest), and then $s_2$ lines containing the sequences attributed to the second path, also in chronological order. If there are multiple examples, display any one of them. If it is possible that a sequence could appear in the genetic history of both species, your example should assign it to exactly one of the evolutionary paths.\n\nIf it is impossible for all the fossil material to come from two evolutionary paths, display the word impossible.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en", "translations": {"en": {"title": "[ICPC 2015 WF] Evolution in Parallel", "background": "", "description": "It is 2178, and alien life has been discovered on a distant planet. There seems to be only one species on the planet and they do not reproduce as animals on Earth do. Even more amazing, the genetic makeup of every single organism is identical!\n\nThe genetic makeup of each organism is a single sequence of nucleotides. The nucleotides come in three types, denoted by ‘A’ (Adenine), ‘C’ (Cytosine), and ‘M’ (Muamine). According to one hypothesis, evolution on this planet occurs when a new nucleotide is inserted somewhere into the genetic sequence of an existing organism. If this change is evolutionarily advantageous, then organisms with the new sequence quickly replace ones with the old sequence.\n\nIt was originally thought that the current species evolved this way from a single, very simple organism with a single-nucleotide genetic sequence, by way of mutations as described above. However, fossil evidence suggests that this might not have been the case. Right now, the research team you are working with is trying to validate the concept of “parallel evolution” – that there might actually have been two evolutionary paths evolving in the fashion described above, and eventually both paths evolved to the single species present on the planet today. Your task is to verify whether the parallel evolution hypothesis is consistent with the genetic material found in the fossil samples gathered by your team.", "inputFormat": "The input begins with a number $n$ ($1\\le n\\le 4\\, 000$) denoting the number of nucleotide sequences found in the fossils. The second line describes the nucleotide sequence of the species currently living on the planet. Each of the next $n$ lines describes one nucleotide sequence found in the fossils.\n\nEach nucleotide sequence consists of a string of at least one but no more than $4\\, 000$ letters. The strings contain only upper-case letters A, C, and M. All the nucleotide sequences, including that of the currently live species, are distinct.", "outputFormat": "Display an example of how the nucleotide sequences in the fossil record participate in two evolutionary paths. The example should begin with one line containing two integers $s_1$ and $s_2$, the number of nucleotide sequences in the fossil record that participate in the first path and second path, respectively. This should be followed by $s_1$ lines containing the sequences attributed to the first path, in chronological order (from the earliest), and then $s_2$ lines containing the sequences attributed to the second path, also in chronological order. If there are multiple examples, display any one of them. If it is possible that a sequence could appear in the genetic history of both species, your example should assign it to exactly one of the evolutionary paths.\n\nIf it is impossible for all the fossil material to come from two evolutionary paths, display the word impossible.", "hint": "Time limit: 2000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en"}, "zh-CN": {"title": "[ICPC 2015 WF] Evolution in Parallel", "background": null, "description": "### 题目背景\n\n公元2178年，人类在一颗遥远的行星上发现了外星生命。但是似乎这颗行星上只有单一物种而且它们并不像地球上的动物一样繁殖。更神奇的是，每个生物的基因构成是完全相同的！\n\n每个生物的基因构成是单一核苷酸序列。在它们基因中有三种核苷酸，表示为‘A’  (腺嘌呤，Adenine), ‘C’ (胞嘧啶，Cytosine), and ‘M’ (膜嘌呤，Muamine)。根据某种假说，在这颗星球上只有某个新的核苷酸插入现存的生物基因序列某处时才会出现进化。如果这个改变是对进化有利的，这个带有新基因序列的生物会迅速取代没有变异的旧生物。\n\n我们起初认为这种生物是从基因序列只含有单一核苷酸的生物经过多次上述的变异进化而来。然而化石证据表明可能并不是一直是这种情况。目前，与你协作的科研团队正在尝试证实“平行进化”的概念。“平行进化”指可能事实上有两条如同上述的进化路径，最终他们都进化成了这颗行星如今的物种。你的任务是证实平行进化假说是否与你的团队在化石中发现的遗传物质样本一致。 \n\n( TRANSLATED by  [@MolotovM](https://www.luogu.com.cn/user/99461))\n\n### 题目含义\n\n给定一个字符串和 $n$ 个字符串，求不多于两个的字符串的子串包含其他所有字符串，且这不多于两个的字符串都是给定字符串的子串。", "inputFormat": "第一行输入为一个整数 $n (1\\le n\\le 4000)$，表示化石中发现的遗传物质样本数量\n\n第二行输入为给定字符串表示当前生物的基因序列\n\n接下来 $n$ 行，每行输入一个字符串，表示化石中发现的遗传物质样本\n\n每个遗传物质样本由不超过 4000 个字母构成，且只包含大写字母A,C和M。\n\n包括当前生物基因序列的所有基因序列都是独特的。", "outputFormat": "输出每个化石中的遗传物质样本是怎样参与两条进化路径的。\n\n第一行包含两个整数 $s_1,s_2$ 为两条进化路径的化石数量。\n\n接下来 $s_1$ 行每行包含一个字符串表示第一条进化路径中的遗传物质样本\n\n接下来 $s_2$ 行每行包含一个字符串表示第二条进化路径中的遗传物质样本\n\n样本按年代顺序输出(从最早的开始)，如果一个样本可以同时出现在两条进化路径中，你需要表明它具体参与了哪种进化。\n\n如果不可能满足有不多于两条进化路径，输出 \"impossible\"。\n\n### 时空限制\n\n时间限制: 2000 ms\n\n空间限制: 1048576 kB", "hint": null, "locale": "zh-CN"}}}
{"pid": "P6909", "type": "P", "difficulty": 4, "samples": [["4 7\nABCDEFG\nHIJKLMN\nOPQRSTU\nVWXYZ**\nCONTEST\n", "30\n"], ["5 20\n12233445566778899000\nQQWWEERRTTYYUUIIOOPP\n-AASSDDFFGGHHJJKKLL*\n--ZZXXCCVVBBNNMM--**\n--------------------\nACM-ICPC-WORLD-FINALS-2015\n", "160\n"], ["2 19\nABCDEFGHIJKLMNOPQZY\nX*****************Y\nAZAZ\n", "19\n"], ["6 4\nAXYB\nBBBB\nKLMB\nOPQB\nDEFB\nGHI*\nAB\n", "7\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2015", "ICPC", "WF"], "title": "[ICPC 2015 WF] Keyboarding", "background": "", "description": "How many keystrokes are necessary to type a text message? You may think that it is equal to the number of characters in the text, but this is correct only if one keystroke generates one character. With pocket-size devices, the possibilities for typing text are often limited. Some devices provide only a few buttons, significantly fewer than the number of letters in the alphabet. For such devices, several strokes may be needed to type a single character. One mechanism to deal with these limitations is a virtual keyboard displayed on a screen, with a cursor that can be moved from key to key to select characters. Four arrow buttons control the movement of the cursor, and when the cursor is positioned over an appropriate key, pressing the fifth button selects the corresponding character and appends it to the end of the text. To terminate the text, the user must navigate to and select the Enter key. This provides users with an arbitrary set of characters and enables them to type text of any length with only five hardware buttons.\n\nIn this problem, you are given a virtual keyboard layout and your task is to determine the minimal number of strokes needed to type a given text, where pressing any of the five hardware buttons constitutes a stroke. The keys are arranged in a rectangular grid, such that each virtual key occupies one or more connected unit squares of the grid. The cursor starts in the upper left corner of the keyboard and moves in the four cardinal directions, in such a way that it always skips to the next unit square in that direction that belongs to a different key. If there is no such unit square, the cursor does not move.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3cxjl2y4.png)\n\n   Figure 1: Sample Input 1. An example virtual keyboard and hardware buttons. \n\nFigure 1, illustrating Sample Input 1, shows a possible way to type CONTEST using 30 strokes on an example virtual keyboard. The red dots represent the virtual keys where the select button was pressed.", "inputFormat": "The first line of the input contains two integers $r$ and $c$ ($1 \\leq r, c \\leq 50$), giving the number of rows and columns of the virtual keyboard grid. The virtual keyboard is specified in the next $r$ lines, each of which contains $c$ characters. The possible values of these characters are uppercase letters, digits, a dash, and an asterisk (representing Enter). There is only one key corresponding to any given character. Each key is made up of one or more grid squares, which will always form a connected region. The last line of the input contains the text to be typed. This text is a non-empty string of at most $10\\, 000$ of the available characters other than the asterisk.", "outputFormat": "Display the minimal number of strokes necessary to type the whole text, including the Enter key at the end. It is guaranteed that the text can be typed.", "hint": "Time limit: 3000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en", "translations": {"en": {"title": "[ICPC 2015 WF] Keyboarding", "background": "", "description": "How many keystrokes are necessary to type a text message? You may think that it is equal to the number of characters in the text, but this is correct only if one keystroke generates one character. With pocket-size devices, the possibilities for typing text are often limited. Some devices provide only a few buttons, significantly fewer than the number of letters in the alphabet. For such devices, several strokes may be needed to type a single character. One mechanism to deal with these limitations is a virtual keyboard displayed on a screen, with a cursor that can be moved from key to key to select characters. Four arrow buttons control the movement of the cursor, and when the cursor is positioned over an appropriate key, pressing the fifth button selects the corresponding character and appends it to the end of the text. To terminate the text, the user must navigate to and select the Enter key. This provides users with an arbitrary set of characters and enables them to type text of any length with only five hardware buttons.\n\nIn this problem, you are given a virtual keyboard layout and your task is to determine the minimal number of strokes needed to type a given text, where pressing any of the five hardware buttons constitutes a stroke. The keys are arranged in a rectangular grid, such that each virtual key occupies one or more connected unit squares of the grid. The cursor starts in the upper left corner of the keyboard and moves in the four cardinal directions, in such a way that it always skips to the next unit square in that direction that belongs to a different key. If there is no such unit square, the cursor does not move.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3cxjl2y4.png)\n\n   Figure 1: Sample Input 1. An example virtual keyboard and hardware buttons. \n\nFigure 1, illustrating Sample Input 1, shows a possible way to type CONTEST using 30 strokes on an example virtual keyboard. The red dots represent the virtual keys where the select button was pressed.", "inputFormat": "The first line of the input contains two integers $r$ and $c$ ($1 \\leq r, c \\leq 50$), giving the number of rows and columns of the virtual keyboard grid. The virtual keyboard is specified in the next $r$ lines, each of which contains $c$ characters. The possible values of these characters are uppercase letters, digits, a dash, and an asterisk (representing Enter). There is only one key corresponding to any given character. Each key is made up of one or more grid squares, which will always form a connected region. The last line of the input contains the text to be typed. This text is a non-empty string of at most $10\\, 000$ of the available characters other than the asterisk.", "outputFormat": "Display the minimal number of strokes necessary to type the whole text, including the Enter key at the end. It is guaranteed that the text can be typed.", "hint": "Time limit: 3000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "locale": "en"}, "zh-CN": {"title": "[ICPC 2015 WF] Keyboarding", "background": "", "description": "输入一个文本消息需要多少次按键？你可能认为这等同于文本中的字符数，但这仅在一次按键生成一个字符时才正确。对于口袋大小的设备，输入文本的可能性通常受到限制。有些设备仅提供少量按钮，远少于字母表中的字母数量。对于这样的设备，输入一个字符可能需要多次按键。为了解决这些限制，一种机制是在屏幕上显示虚拟键盘，并提供一个可以从一个键移动到另一个键的光标来选择字符。四个方向键控制光标的移动，当光标位于适当的键上时，按下第五个按钮选择相应的字符并将其附加到文本末尾。要终止文本，用户必须导航到并选择 Enter 键。这使用户可以使用任意字符集并仅用五个硬件按钮输入任意长度的文本。\n\n在这个问题中，给定一个虚拟键盘布局，你的任务是确定输入给定文本所需的最少按键次数，其中按下任何一个五个硬件按钮都算作一次按键。键以矩形网格排列，每个虚拟键占据网格的一个或多个连接单元格。光标从键盘的左上角开始，并在四个基本方向上移动，以便它总是跳到该方向上属于不同键的下一个单元格。如果没有这样的单元格，光标不会移动。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3cxjl2y4.png)\n\n图 1：样例输入 1。一个示例虚拟键盘和硬件按钮。\n\n图 1，说明了样例输入 1，展示了一种在示例虚拟键盘上使用 30 次按键输入 CONTEST 的可能方式。红点表示按下选择按钮的虚拟键。", "inputFormat": "输入的第一行包含两个整数 $r$ 和 $c$ ($1 \\leq r, c \\leq 50$)，表示虚拟键盘网格的行数和列数。虚拟键盘在接下来的 $r$ 行中指定，每行包含 $c$ 个字符。这些字符的可能值是大写字母、数字、一个破折号和一个星号（表示 Enter）。每个字符仅对应一个键。每个键由一个或多个网格单元组成，这些单元将始终形成一个连接区域。输入的最后一行包含要输入的文本。此文本是一个最多包含 $10\\, 000$ 个可用字符（不包括星号）的非空字符串。", "outputFormat": "显示输入整个文本所需的最少按键次数，包括最后的 Enter 键。保证文本可以被输入。", "hint": "时间限制：3000 毫秒，内存限制：1048576 KB。\n\n国际大学生程序设计竞赛（ACM-ICPC）世界总决赛 2015。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
