{"pid": "P2354", "type": "P", "difficulty": 5, "samples": [["1 3 5 1 71 \n3 4 3 \n1 7 \n9 9 \n4 9 ", "1 2 6 8 9 12 "], ["654321 209 111 23 70000001 \n10 10 0 ", "1 3 7 10 14 15 16 21 23 30 44 52 55 70 72 88 94 95 97"], ["123456 137 701 101 10000007 \n20 20 0 ", "1 10 12 14 16 26 32 38 44 46 61 81 84 101 126 128 135 140 152 156 201 206 237 242 243 253 259 269 278 279 291 298 338 345 347 352 354 383 395 \n"]], "limits": {"time": [1000, 1000, 1000, 2000, 2000, 2000, 5000, 5000, 5000, 5000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["模拟", "贪心", "2014", "NOI"], "title": "[NOI2014] 随机数生成器", "background": null, "description": "小 H 最近在研究随机算法。随机算法往往需要通过调用随机数生成函数（例如 Pascal 中的 random 和 C/C++ 中的 rand）来获得随机性。事实上，随机数生成函数也并不是真正的“随机”，其一般都是利用某个算法计算得来的。\n\n比如，下面这个二次多项式递推算法就是一个常用算法：\n\n算法选定非负整数 $x_0,a,b,c,d$ 作为随机种子，并采用如下递推公式进行计算。\n\n对于任意 $i ≥ 1,x_i=(a \\times x_{i-1}^2+b \\times x_{i-1}+c)\\mod d$ 这样可以得到一个任意长度的非负整数数列 $\\{x_i\\},i \\ge 1$，一般来说，我们认为这个数列是随机的。\n\n利用随机序列 $\\{x_i\\},i\\ge1$，我们还可以采用如下算法来产生一个 $1$ 到 $K$ 的随机排列 $\\{ T_i \\},\\;i=1,\\dots,K$：\n\n1. 初始设 $T$ 为 $1$ 到 $K$ 的递增序列；\n2. 对 $T$ 进行 $K$ 次交换，第 $i$ 次交换，交换 $T_i$ 和 $T_{(x_i \\bmod i) + 1}$ 的值。\n\n此外，小 H 在这 $K$ 次交换的基础上，又额外进行了 $Q$ 次交换操作，对于第 $i$ 次额外交换，小 H 会选定两个下标 $u_i$ 和 $v_i$，并交换 $T_{u_i}$ 和 $T_{v_i}$ 的值。\n\n为了检验这个随机排列生成算法的实用性，小 H 设计了如下问题：\n\n小 H 有一个 $N$ 行 $M$ 列的棋盘，她首先按照上述过程，通过 $N \\times M + Q$ 次交换操作，生成了一个 $1\\sim N \\times M$ 的随机排列 $\\{T_i\\},\\;i=1,\\dots,N \\times M$，然后将这 $N \\times M$ 个数逐行逐列依次填入这个棋盘：也就是第 $i$ 行第 $j$ 列的格子上所填入的数应为 $ T_{(i-1) \\times M+j} $。\n\n接着小 H 希望从棋盘的左上角，也就是第一行第一列的格子出发，每次向右走或者向下走，在不走出棋盘的前提下，走到棋盘的右下角，也就是第 $N$ 行第 $M$ 列的格子。\n\n小 H 把所经过格子上的数字都记录了下来，并从小到大排序，这样，对于任何一条合法的移动路径，小 H 都可以得到一个长度为 $N + M - 1$ 的升序序列，我们称之为路径序列。\n\n小 H 想知道，她可能得到的字典序最小的路径序列应该是怎样的呢？", "inputFormat": "第 1 行包含 $5$ 个整数，依次为 $x_0,a,b,c,d$ ，描述小H采用的随机数生成算法所需的随机种子。\n\n第 2 行包含三个整数 $N,M,Q$ ，表示小H希望生成一个 $1$ 到 $N \\times M$ 的排列来填入她 $N$ 行 $M$ 列的棋盘，并且小H在初始的 $N \\times M$ 次交换操作后，又进行了 $Q$ 次额外的交换操作。\n\n接下来 $Q$ 行，第 $i$ 行包含两个整数 $u_i,v_i$，表示第 $i$ 次额外交换操作将交换 $T_{u_i}$和 $T_{v_i}$ 的值。", "outputFormat": "输出一行，包含 $N+M-1$ 个由空格隔开的正整数，表示可以得到的字典序最小的路径序列。", "hint": "对于样例 1，根据输入的随机种子，小 H 所得到的前 $12$ 个随机数 $x_i$ 为：\n\n$$\n\\begin{array}{rrrr}\n9&5&30&11\\\\\n64&42&36&22\\\\\n1&9&5&30\n\\end{array}\n$$\n\n根据这 $12$ 个随机数，小 H 在进行初始的 $12$ 次交换操作后得到的排列为：\n\n$$\n\\begin{array}{rrrr}\n6&9&1&4\\\\\n5&11&12&2\\\\\n7&10&3&8\n\\end{array}\n$$\n\n在进行额外的 $3$ 次交换操作之后，小 H 得到的最终的随机排列为：\n\n\n\n$$\\begin{array}{rrrr}\n12&9&1&7\\\\\n5&11&6&2\\\\\n4&10&3&8\n\\end{array}\n$$\n\n最优路径依次经过的数字为 ：$12-9-1-6-2-8$。\n\n所有测试数据的范围和特点如下表所示\n::cute-table{tuack}\n|测试点编号|$N,M$ 的规模|$Q$ 的规模|约定|\n|:-:|:-:|:-:|:-:|\n|$1$|$2\\le N,M\\le8$|$Q=0$|$0\\le a\\le300\\\\0\\le b,c\\le10^8\\\\0\\le x_0<d\\le10^8\\\\1\\le u_i,v_i\\le N\\times M$|\n|$2$|$2\\le N,M\\le200$|^|^|\n|$3$|^|^|^|\n|$4$|$2\\le N,M\\le2000$|$0\\le Q\\le50000$|^|\n|$5$|^|^|^|\n|$6$|^|^|^|\n|$7$|$2\\le N,M\\le5000$|^|^|\n|$8$|^|^|^|\n|$9$|^|^|^|\n|$10$|^|^|^|", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2014] Random Number Generator", "background": "", "description": "Little H is studying randomized algorithms. Randomized algorithms often obtain randomness by calling random number generator functions (for example, random in Pascal and rand in C/C++). In fact, such functions are not truly “random”; they are usually computed by some algorithm.\n\nFor example, the following quadratic polynomial recurrence is a common algorithm:\n\nChoose non-negative integers $x_0, a, b, c, d$ as the random seed, and compute using the following recurrence.\n\nFor any $i \\ge 1$, $x_i = (a \\times x_{i-1}^2 + b \\times x_{i-1} + c) \\mod d$. In this way we can obtain a non-negative integer sequence of arbitrary length $\\{ x_i \\}, i \\ge 1$, and generally we regard this sequence as random.\n\nUsing the random sequence $\\{ x_i \\}, i \\ge 1$, we can generate a random permutation of $1$ to $K$, denoted $\\{ T_i \\}, i = 1 \\ldots K$, by the following algorithm:\n\n1. Initialize $T$ as the increasing sequence $1$ to $K$.\n2. Perform $K$ swaps. At the $i$-th swap, exchange the values of $T_i$ and $T_{(x_i \\bmod i) + 1}$.\n\nIn addition, on top of these $K$ swaps, Little H performs $Q$ extra swap operations. For the $i$-th extra swap, Little H chooses two indices $u_i$ and $v_i$, and swaps the values of $T_{u_i}$ and $T_{v_i}$.\n\nTo test the practicality of this random permutation generation algorithm, Little H designs the following problem:\n\nLittle H has a board with $N$ rows and $M$ columns. First, following the above process, after $N \\times M + Q$ swap operations, she generates a random permutation of $1 \\sim N \\times M$, denoted $\\{ T_i \\}, i = 1 \\ldots N \\times M$. Then she fills these $N \\times M$ numbers into the board row by row and column by column in order: that is, the number filled in the cell at row $i$, column $j$ is $T_{(i - 1) \\times M + j}$.\n\nNext, Little H wants to start from the top-left corner of the board, i.e., the cell at row $1$, column $1$. Each move goes either right or down, and without leaving the board, she reaches the bottom-right corner, i.e., the cell at row $N$, column $M$.\n\nLittle H records the numbers on all visited cells, and sorts them in ascending order. Thus, for any valid path, Little H can obtain an increasing sequence of length $N + M - 1$, which we call the path sequence.\n\nLittle H wants to know what the lexicographically smallest path sequence she can obtain is.", "inputFormat": "The first line contains $5$ integers $x_0, a, b, c, d$, describing the random seed required by Little H’s random number generation algorithm.\n\nThe second line contains three integers $N, M, Q$, indicating that Little H wants to generate a permutation of $1$ to $N \\times M$ to fill her $N$-row $M$-column board, and that after the initial $N \\times M$ swap operations, she performs $Q$ extra swap operations.\n\nThe next $Q$ lines each contain two integers $u_i, v_i$, indicating that at the $i$-th extra swap operation, the values of $T_{u_i}$ and $T_{v_i}$ are swapped.", "outputFormat": "Output one line containing $N + M - 1$ positive integers separated by spaces, representing the lexicographically smallest path sequence that can be obtained.", "hint": "For Sample 1, according to the input seeds, the first $12$ random numbers $x_i$ that Little H obtains are:\n\n9 5 30 11 64 42 36 22 1 9 5 30\n\nBased on these $12$ random numbers, after the initial $12$ swap operations, Little H obtains the permutation:\n\n6 9 1 4 5 11 12 2 7 10 3 8\n\nAfter the additional $3$ swap operations, Little H obtains the final random permutation:\n\n12 9 1 7 5 11 6 2 4 10 3 8\n\n\n```cpp\n12 9 1 7 \n5 11 6 2 \n4 10 3 8\n```\n\nThe optimal path passes through the numbers: 12-9-1-6-2-8.\n\n![](https://cdn.luogu.com.cn/upload/pic/2590.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2014] 随机数生成器", "background": null, "description": "小 H 最近在研究随机算法。随机算法往往需要通过调用随机数生成函数（例如 Pascal 中的 random 和 C/C++ 中的 rand）来获得随机性。事实上，随机数生成函数也并不是真正的“随机”，其一般都是利用某个算法计算得来的。\n\n比如，下面这个二次多项式递推算法就是一个常用算法：\n\n算法选定非负整数 $x_0,a,b,c,d$ 作为随机种子，并采用如下递推公式进行计算。\n\n对于任意 $i ≥ 1,x_i=(a \\times x_{i-1}^2+b \\times x_{i-1}+c)\\mod d$ 这样可以得到一个任意长度的非负整数数列 $\\{x_i\\},i \\ge 1$，一般来说，我们认为这个数列是随机的。\n\n利用随机序列 $\\{x_i\\},i\\ge1$，我们还可以采用如下算法来产生一个 $1$ 到 $K$ 的随机排列 $\\{ T_i \\},\\;i=1,\\dots,K$：\n\n1. 初始设 $T$ 为 $1$ 到 $K$ 的递增序列；\n2. 对 $T$ 进行 $K$ 次交换，第 $i$ 次交换，交换 $T_i$ 和 $T_{(x_i \\bmod i) + 1}$ 的值。\n\n此外，小 H 在这 $K$ 次交换的基础上，又额外进行了 $Q$ 次交换操作，对于第 $i$ 次额外交换，小 H 会选定两个下标 $u_i$ 和 $v_i$，并交换 $T_{u_i}$ 和 $T_{v_i}$ 的值。\n\n为了检验这个随机排列生成算法的实用性，小 H 设计了如下问题：\n\n小 H 有一个 $N$ 行 $M$ 列的棋盘，她首先按照上述过程，通过 $N \\times M + Q$ 次交换操作，生成了一个 $1\\sim N \\times M$ 的随机排列 $\\{T_i\\},\\;i=1,\\dots,N \\times M$，然后将这 $N \\times M$ 个数逐行逐列依次填入这个棋盘：也就是第 $i$ 行第 $j$ 列的格子上所填入的数应为 $ T_{(i-1) \\times M+j} $。\n\n接着小 H 希望从棋盘的左上角，也就是第一行第一列的格子出发，每次向右走或者向下走，在不走出棋盘的前提下，走到棋盘的右下角，也就是第 $N$ 行第 $M$ 列的格子。\n\n小 H 把所经过格子上的数字都记录了下来，并从小到大排序，这样，对于任何一条合法的移动路径，小 H 都可以得到一个长度为 $N + M - 1$ 的升序序列，我们称之为路径序列。\n\n小 H 想知道，她可能得到的字典序最小的路径序列应该是怎样的呢？", "inputFormat": "第 1 行包含 $5$ 个整数，依次为 $x_0,a,b,c,d$ ，描述小H采用的随机数生成算法所需的随机种子。\n\n第 2 行包含三个整数 $N,M,Q$ ，表示小H希望生成一个 $1$ 到 $N \\times M$ 的排列来填入她 $N$ 行 $M$ 列的棋盘，并且小H在初始的 $N \\times M$ 次交换操作后，又进行了 $Q$ 次额外的交换操作。\n\n接下来 $Q$ 行，第 $i$ 行包含两个整数 $u_i,v_i$，表示第 $i$ 次额外交换操作将交换 $T_{u_i}$和 $T_{v_i}$ 的值。", "outputFormat": "输出一行，包含 $N+M-1$ 个由空格隔开的正整数，表示可以得到的字典序最小的路径序列。", "hint": "对于样例 1，根据输入的随机种子，小 H 所得到的前 $12$ 个随机数 $x_i$ 为：\n\n$$\n\\begin{array}{rrrr}\n9&5&30&11\\\\\n64&42&36&22\\\\\n1&9&5&30\n\\end{array}\n$$\n\n根据这 $12$ 个随机数，小 H 在进行初始的 $12$ 次交换操作后得到的排列为：\n\n$$\n\\begin{array}{rrrr}\n6&9&1&4\\\\\n5&11&12&2\\\\\n7&10&3&8\n\\end{array}\n$$\n\n在进行额外的 $3$ 次交换操作之后，小 H 得到的最终的随机排列为：\n\n\n\n$$\\begin{array}{rrrr}\n12&9&1&7\\\\\n5&11&6&2\\\\\n4&10&3&8\n\\end{array}\n$$\n\n最优路径依次经过的数字为 ：$12-9-1-6-2-8$。\n\n所有测试数据的范围和特点如下表所示\n::cute-table{tuack}\n|测试点编号|$N,M$ 的规模|$Q$ 的规模|约定|\n|:-:|:-:|:-:|:-:|\n|$1$|$2\\le N,M\\le8$|$Q=0$|$0\\le a\\le300\\\\0\\le b,c\\le10^8\\\\0\\le x_0<d\\le10^8\\\\1\\le u_i,v_i\\le N\\times M$|\n|$2$|$2\\le N,M\\le200$|^|^|\n|$3$|^|^|^|\n|$4$|$2\\le N,M\\le2000$|$0\\le Q\\le50000$|^|\n|$5$|^|^|^|\n|$6$|^|^|^|\n|$7$|$2\\le N,M\\le5000$|^|^|\n|$8$|^|^|^|\n|$9$|^|^|^|\n|$10$|^|^|^|", "locale": "zh-CN"}}}
{"pid": "P2356", "type": "P", "difficulty": 2, "samples": [["4\n1 1 1 0\n1 1 1 1\n1 1 1 1\n0 1 1 1", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "洛谷原创", "枚举"], "title": "弹珠游戏", "background": null, "description": "MedalPluS 和他的小伙伴 NOIRP 发掘了一个骨灰级别的游戏——超级弹珠。\n\n游戏的内容是：在一个 $n \\times n$ 的矩阵里，有若干个敌人，你的弹珠可以摧毁敌人，但只能攻击你所在的行、列里的所有敌人，然后你就可以获得他们的分数之和，现在请你选择一个你的位置，使得能击杀的敌人最多，注意，你不能和敌人在一个地方。", "inputFormat": "输入有两行，第一行一个正整数 $n$，接下来 $n$ 行，每行 $n$ 列，如果有敌人则为一个正整数，否则为 $0$。", "outputFormat": "输出共一行，最多分数，如果连你的容身之地都没有，请输出“Bad Game!”", "hint": "【数据范围】\n\n对于 $30\\%$ 的数据，$1\\leq n\\leq 10$；\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 1000$，保证容身之地的数量小于 $10000$，保证每个位置敌人的数量不超过 $1000$。", "locale": "zh-CN", "translations": {"en": {"title": "Marble Game", "background": "", "description": "MedalPluS and his friend NOIRP discovered a veteran game called \"Super Marble\".\n\nThe game is as follows: In an $n \\times n$ matrix, there are several enemies. Your marble can destroy enemies, but it can only attack all enemies in your current row and column. You then obtain the sum of their scores. Please choose a position for yourself so that the total score you can obtain is maximized. Note that you cannot stand on a cell occupied by an enemy.", "inputFormat": "The first line contains a positive integer $n$. Then follow $n$ lines, each containing $n$ integers. A positive integer indicates there is an enemy on that cell with that score; $0$ indicates an empty cell.", "outputFormat": "Output a single line containing the maximum score. If there is no place for you to stand (i.e., there is no cell with value $0$), output \"Bad Game!\".", "hint": "Constraints\n\n- For $30\\%$ of the testdata, $1 \\leq n \\leq 10$.\n- For $100\\%$ of the testdata, $1 \\leq n \\leq 1000$. It is guaranteed that the number of safe cells is less than $10000$, and the value at each cell does not exceed $1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "弹珠游戏", "background": null, "description": "MedalPluS 和他的小伙伴 NOIRP 发掘了一个骨灰级别的游戏——超级弹珠。\n\n游戏的内容是：在一个 $n \\times n$ 的矩阵里，有若干个敌人，你的弹珠可以摧毁敌人，但只能攻击你所在的行、列里的所有敌人，然后你就可以获得他们的分数之和，现在请你选择一个你的位置，使得能击杀的敌人最多，注意，你不能和敌人在一个地方。", "inputFormat": "输入有两行，第一行一个正整数 $n$，接下来 $n$ 行，每行 $n$ 列，如果有敌人则为一个正整数，否则为 $0$。", "outputFormat": "输出共一行，最多分数，如果连你的容身之地都没有，请输出“Bad Game!”", "hint": "【数据范围】\n\n对于 $30\\%$ 的数据，$1\\leq n\\leq 10$；\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 1000$，保证容身之地的数量小于 $10000$，保证每个位置敌人的数量不超过 $1000$。", "locale": "zh-CN"}}}
{"pid": "P2357", "type": "P", "difficulty": 4, "samples": [["5 7\n0 0 0 0 0\n1 1 5 1\n1 1 3 3\n2 3\n3 1\n4 1 5\n2 1\n5", "16\n7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["线段树", "树状数组", "分块"], "title": "守墓人", "background": "![](https://cdn.luogu.com.cn/upload/pic/1406.png) \n\n在一个荒凉的墓地上，有一个令人尊敬的守墓人，他看守的墓地从来没有被盗过， 所以人们很放心的把自己的先人的墓安顿在他那。\n\n守墓人能看好这片墓地是必然而不是偶然……\n\n因为……守墓人懂风水 0.0", "description": "他把墓地分为主要墓碑和次要墓碑， 主要墓碑只能有 $1$ 个， 守墓人把他记为 $1$ 号， 而次要墓碑有 $n-1$ 个，守墓人将之编号为 $2,3\\dots n$，所以构成了一个有 $n$ 个墓碑的墓地。\n\n而每个墓碑有一个初始的风水值，这些风水值决定了墓地的风水的好坏，所以守墓人需要经常来查询这些墓碑。\n\n善于运用风水的守墓人，通过一次次逆天改命，使得自己拥有了无限寿命，没人知道他活了多久。这天，你幸运的拜访到了他，他要求你和他共同见证接下来几年他的战果，但不过他每次统计风水值之和都需要你来帮他计算，算错了他会要你命 QAQ\n\n风水也不是不可变，除非遭遇特殊情况，已知在接下来的 $2147483647$ 年里，会有 $f$ 次灾难，守墓人会有几个操作：\n\n1. 将 $[l,r]$ 这个区间所有的墓碑的风水值增加 $k$。\n\n2. 将主墓碑的风水值增加 $k$。\n\n3. 将主墓碑的风水值减少 $k$。\n\n4. 统计 $[l,r]$ 这个区间所有的墓碑的风水值之和。\n\n5. 求主墓碑的风水值。\n\n上面也说了，很多人会把先人的墓安居在这里，而且守墓人活了很多世纪→\\_→，墓碑的数量会多的你不敢相信= =\n\n守墓人和善的邀请你帮他完成这些操作，要不然哪天你的旅馆爆炸了，天上下刀子……\n\n为了活命，还是帮他吧。", "inputFormat": "第一行，两个正整数 $n,f$ 表示共有 $n$ 块墓碑，并且在接下来的 $2147483647 $年里，会有 $f$ 次世界末日。\n\n第二行，$n$ 个正整数，表示第 $i$ 块墓碑的风水值。\n\n接下来 $f$ 行，每行都会有一个针对世界末日的解决方案，如题所述，标记同题。", "outputFormat": "输出会有若干行，对 $4$ 和 $5$ 的提问做出回答，每个回答输出一行。", "hint": "$20\\%$ 的数据满足：$1\\leq n\\leq 100$。\n\n$50\\%$ 的数据满足：$1\\leq n\\leq 6000$。\n\n$100\\%$ 的数据满足：$1\\leq n,f\\leq 2 \\times 10^5$，答案不超过 64 位整数。", "locale": "zh-CN", "translations": {"en": {"title": "The Gravekeeper", "background": "![](https://cdn.luogu.com.cn/upload/pic/1406.png)\n\nIn a desolate cemetery, there is a respected gravekeeper. The cemetery he watches over has never been robbed, so people feel at ease placing their ancestors’ graves there.\n\nIt is inevitable, not accidental, that the gravekeeper can protect this cemetery...\n\nBecause... the gravekeeper understands feng shui 0.0", "description": "He divides the cemetery into a main tombstone and secondary tombstones. There can be only $1$ main tombstone, which he numbers as $1$. There are $n-1$ secondary tombstones, numbered $2,3\\dots n$, forming a cemetery with $n$ tombstones.\n\nEach tombstone has an initial feng shui value. These values determine the overall feng shui of the cemetery, so the gravekeeper needs to query them often.\n\nSkilled at using feng shui, the gravekeeper has defied fate again and again and gained infinite life. No one knows how long he has lived. Today, you are lucky to visit him. He asks you to witness his achievements in the coming years. However, every time he sums up feng shui values, he needs you to compute the result for him. If you get it wrong, he will take your life QAQ.\n\nFeng shui is not unchangeable. Unless something special happens, it stays the same. It is known that in the next $2147483647$ years, there will be $f$ disasters. The gravekeeper will perform several operations:\n\n1. Increase the feng shui value of all tombstones in interval $[l,r]$ by $k$.\n2. Increase the feng shui value of the main tombstone by $k$.\n3. Decrease the feng shui value of the main tombstone by $k$.\n4. Query the sum of feng shui values of all tombstones in interval $[l,r]$.\n5. Query the feng shui value of the main tombstone.\n\nAs mentioned above, many people settle their ancestors’ graves here, and the gravekeeper has lived for many centuries →_→, so the number of tombstones will be more than you can believe = =.\n\nThe gravekeeper kindly invites you to help him perform these operations; otherwise one day your inn might explode, and knives may fall from the sky...\n\nTo stay alive, please help him.", "inputFormat": "- The first line contains two positive integers $n, f$, meaning there are $n$ tombstones, and in the next $2147483647$ years there will be $f$ apocalypses.\n- The second line contains $n$ positive integers, where the $i$-th number is the initial feng shui value of the $i$-th tombstone.\n- The next $f$ lines each describe one operation, identified by the same indices as in the statement:\n  - Type $1$: `1 l r k` — increase all tombstones in $[l,r]$ by $k$.\n  - Type $2$: `2 k` — increase the main tombstone by $k$.\n  - Type $3$: `3 k` — decrease the main tombstone by $k$.\n  - Type $4$: `4 l r` — query the sum over $[l,r]$.\n  - Type $5$: `5` — query the main tombstone’s value.\n- Indices are $1$-based.", "outputFormat": "Print several lines. For each query of type $4$ or $5$, output the answer on a separate line.", "hint": "Constraints\n\n$20\\%$ of the testdata satisfies: $1\\leq n\\leq 100$.\n\n$50\\%$ of the testdata satisfies: $1\\leq n\\leq 6000$.\n\n$100\\%$ of the testdata satisfies: $1\\leq n,f\\leq 2 \\times 10^5$, and the answers do not exceed 64-bit integers.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "守墓人", "background": "![](https://cdn.luogu.com.cn/upload/pic/1406.png) \n\n在一个荒凉的墓地上，有一个令人尊敬的守墓人，他看守的墓地从来没有被盗过， 所以人们很放心的把自己的先人的墓安顿在他那。\n\n守墓人能看好这片墓地是必然而不是偶然……\n\n因为……守墓人懂风水 0.0", "description": "他把墓地分为主要墓碑和次要墓碑， 主要墓碑只能有 $1$ 个， 守墓人把他记为 $1$ 号， 而次要墓碑有 $n-1$ 个，守墓人将之编号为 $2,3\\dots n$，所以构成了一个有 $n$ 个墓碑的墓地。\n\n而每个墓碑有一个初始的风水值，这些风水值决定了墓地的风水的好坏，所以守墓人需要经常来查询这些墓碑。\n\n善于运用风水的守墓人，通过一次次逆天改命，使得自己拥有了无限寿命，没人知道他活了多久。这天，你幸运的拜访到了他，他要求你和他共同见证接下来几年他的战果，但不过他每次统计风水值之和都需要你来帮他计算，算错了他会要你命 QAQ\n\n风水也不是不可变，除非遭遇特殊情况，已知在接下来的 $2147483647$ 年里，会有 $f$ 次灾难，守墓人会有几个操作：\n\n1. 将 $[l,r]$ 这个区间所有的墓碑的风水值增加 $k$。\n\n2. 将主墓碑的风水值增加 $k$。\n\n3. 将主墓碑的风水值减少 $k$。\n\n4. 统计 $[l,r]$ 这个区间所有的墓碑的风水值之和。\n\n5. 求主墓碑的风水值。\n\n上面也说了，很多人会把先人的墓安居在这里，而且守墓人活了很多世纪→\\_→，墓碑的数量会多的你不敢相信= =\n\n守墓人和善的邀请你帮他完成这些操作，要不然哪天你的旅馆爆炸了，天上下刀子……\n\n为了活命，还是帮他吧。", "inputFormat": "第一行，两个正整数 $n,f$ 表示共有 $n$ 块墓碑，并且在接下来的 $2147483647 $年里，会有 $f$ 次世界末日。\n\n第二行，$n$ 个正整数，表示第 $i$ 块墓碑的风水值。\n\n接下来 $f$ 行，每行都会有一个针对世界末日的解决方案，如题所述，标记同题。", "outputFormat": "输出会有若干行，对 $4$ 和 $5$ 的提问做出回答，每个回答输出一行。", "hint": "$20\\%$ 的数据满足：$1\\leq n\\leq 100$。\n\n$50\\%$ 的数据满足：$1\\leq n\\leq 6000$。\n\n$100\\%$ 的数据满足：$1\\leq n,f\\leq 2 \\times 10^5$，答案不超过 64 位整数。", "locale": "zh-CN"}}}
{"pid": "P2358", "type": "P", "difficulty": 3, "samples": [["0.26 0.50 0.50 0.18", "1.146"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何"], "title": "蚂蚁搬家", "background": "", "description": "边长为 $1$ 的正方体（自行脑补），有一只蚂蚁要从上表面上的一点出发爬往下表面的某一点，规定蚂蚁只能沿正方体表面爬行，要求编程求出一条从起点到终点的最短距离。\n\n起点和终点坐标从键盘输入，设定上下两个表面的坐标原点均为正方形的中心，且两个表面的坐标系的 $X$ 轴和 $Y$ 轴方向一致，输出时保留三位小数。", "inputFormat": "$4$ 个实数（$-0.5$ 到 $0.5$ 之间），分别表示出发点和目的点的坐标。", "outputFormat": "最短距离\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Ant Moving", "background": "", "description": "Consider a cube with edge length $1$. An ant starts from a point on the top face and crawls to a point on the bottom face. The ant can only move along the surface of the cube. Write a program to compute a shortest distance from the start to the end along the surface.\n\nThe coordinates of the start and end points are read from the keyboard. The coordinate origins on both the top and bottom faces are at the centers of their squares, and the $X$-axis and $Y$-axis directions of the two face coordinate systems are aligned. Output the answer rounded to three decimal places.", "inputFormat": "$4$ real numbers (each in $[-0.5, 0.5]$), representing the coordinates of the starting point and the destination point.", "outputFormat": "The shortest distance.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "蚂蚁搬家", "background": "", "description": "边长为 $1$ 的正方体（自行脑补），有一只蚂蚁要从上表面上的一点出发爬往下表面的某一点，规定蚂蚁只能沿正方体表面爬行，要求编程求出一条从起点到终点的最短距离。\n\n起点和终点坐标从键盘输入，设定上下两个表面的坐标原点均为正方形的中心，且两个表面的坐标系的 $X$ 轴和 $Y$ 轴方向一致，输出时保留三位小数。", "inputFormat": "$4$ 个实数（$-0.5$ 到 $0.5$ 之间），分别表示出发点和目的点的坐标。", "outputFormat": "最短距离\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2359", "type": "P", "difficulty": 4, "samples": [["4", "204"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "洛谷原创", "素数判断,质数,筛法"], "title": "三素数数", "background": "蛟川书院的一道练习题", "description": "如果一个数的所有连续三位数字都是大于 $100$ 的素数，则该数称为三素数数。比如 $113797$ 是一个 $6$ 位的三素数数，因为 $113$、$137$、$379$、$797$ 都是素数。", "inputFormat": "一个整数 $n$（$3 \\le n \\le {10}^4$），表示三素数数的位数。", "outputFormat": "一个整数，表示 $n$ 位三素数的个数。\n\n由于这个数可能很大，你需要输出答案除以 ${10}^9+9$ 的余数。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Three-Prime Number", "background": "A practice problem from Jiaochuan Shuyuan.", "description": "If every consecutive three-digit segment of a number is a prime greater than $100$, then the number is called a three-prime number. For example, $113797$ is a $6$-digit three-prime number, because $113$, $137$, $379$, $797$ are all prime.", "inputFormat": "An integer $n$ ($3 \\le n \\le {10}^4$), denoting the number of digits of a three-prime number.", "outputFormat": "A single integer, the number of $n$-digit three-prime numbers.\n\nBecause this number can be large, output the remainder of the answer modulo ${10}^9+9$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "三素数数", "background": "蛟川书院的一道练习题", "description": "如果一个数的所有连续三位数字都是大于 $100$ 的素数，则该数称为三素数数。比如 $113797$ 是一个 $6$ 位的三素数数，因为 $113$、$137$、$379$、$797$ 都是素数。", "inputFormat": "一个整数 $n$（$3 \\le n \\le {10}^4$），表示三素数数的位数。", "outputFormat": "一个整数，表示 $n$ 位三素数的个数。\n\n由于这个数可能很大，你需要输出答案除以 ${10}^9+9$ 的余数。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2360", "type": "P", "difficulty": 2, "samples": [["3 4 5\nS....\n.###.\n.##..\n###.#\n\n#####\n#####\n##.##\n##...\n\n#####\n#####\n#.###\n####E", "Escaped in 11 minute(s)."]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2015", "洛谷原创", "洛谷月赛"], "title": "地下城主", "background": "", "description": "你参加了一项秘密任务，在任务过程中你被困在了一个 3D 的地下监狱里面，任务是计时的，你现在需要在最短的时间里面从地牢里面逃出来继续你的任务。地牢由若干层组成，每一层的形状都是长宽一样的矩形，地牢被分成了若干小格，当小格没有被岩石所占据时，你可以前往所在小格的前方，后方，左方，右方，上层，下层的小格。每走一小格花费一分钟时间。\n\n你能不能顺利的从地牢里面逃出来呢？如果可以，那所需要的最短时间又是多少呢？\n\n\n~~据说出口藏有神器。~~", "inputFormat": "\n第一行输入 $L,R,C$ （$L$ 为地牢的层数，$R$ 为每层小格的行数，$C$ 为每层小格的列数，其中 $1 \\leq L,R,C \\leq 30$）。\n\n第二行开始输入 $L$ 层地牢的格局，每一层有 $R$ 行，每行有 $C$ 个小格，两层地牢中间有空行隔开。\n\n输入的文件中，`S` 代表你的起始点，`E` 代表你所要到达的出口，`#` 为小格被岩石占据，`.` 表示没有被岩石占据。\n", "outputFormat": "输出包含一行，当你可以顺利到达出口时请输出：`Escaped in x minute(s).`\n\n其中，$x$ 代表你所花费的最短时间，否则请输出 `Trapped!`", "hint": "来源：POJ 2251\n", "locale": "zh-CN", "translations": {"en": {"title": "Dungeon Master", "background": "", "description": "You are on a secret mission, but you get trapped in a 3D underground prison. The mission is timed, and you need to escape from the dungeon in the shortest possible time to continue your task. The dungeon has several levels. Each level is an $R$ by $C$ rectangular grid. When a cell is not occupied by rock, you may move from your current cell to one of the six adjacent cells: front, back, left, right, the cell on the level above, or the cell on the level below. Each move to an adjacent cell takes 1 minute.\n\nCan you escape from the dungeon? If so, what is the minimal time required?\n\n~~It is said that an artifact is hidden at the exit.~~", "inputFormat": "The first line contains $L,R,C$ ($L$ is the number of levels, $R$ is the number of rows per level, and $C$ is the number of columns per level, where $1 \\leq L,R,C \\leq 30$).\n\nStarting from the second line, the layouts of the $L$ levels are given. Each level has $R$ lines, and each line has $C$ cells. There is a blank line between two consecutive levels.\n\nIn the input, `S` marks your starting position, `E` marks the exit, `#` means the cell is blocked by rock, and `.` means the cell is empty.", "outputFormat": "Output exactly one line. If you can reach the exit, print: `Escaped in x minute(s).`\n\nHere, $x$ is the minimal time you spend. Otherwise, print `Trapped!`.", "hint": "Source: POJ 2251.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "地下城主", "background": "", "description": "你参加了一项秘密任务，在任务过程中你被困在了一个 3D 的地下监狱里面，任务是计时的，你现在需要在最短的时间里面从地牢里面逃出来继续你的任务。地牢由若干层组成，每一层的形状都是长宽一样的矩形，地牢被分成了若干小格，当小格没有被岩石所占据时，你可以前往所在小格的前方，后方，左方，右方，上层，下层的小格。每走一小格花费一分钟时间。\n\n你能不能顺利的从地牢里面逃出来呢？如果可以，那所需要的最短时间又是多少呢？\n\n\n~~据说出口藏有神器。~~", "inputFormat": "\n第一行输入 $L,R,C$ （$L$ 为地牢的层数，$R$ 为每层小格的行数，$C$ 为每层小格的列数，其中 $1 \\leq L,R,C \\leq 30$）。\n\n第二行开始输入 $L$ 层地牢的格局，每一层有 $R$ 行，每行有 $C$ 个小格，两层地牢中间有空行隔开。\n\n输入的文件中，`S` 代表你的起始点，`E` 代表你所要到达的出口，`#` 为小格被岩石占据，`.` 表示没有被岩石占据。\n", "outputFormat": "输出包含一行，当你可以顺利到达出口时请输出：`Escaped in x minute(s).`\n\n其中，$x$ 代表你所花费的最短时间，否则请输出 `Trapped!`", "hint": "来源：POJ 2251\n", "locale": "zh-CN"}}}
{"pid": "P2361", "type": "P", "difficulty": 4, "samples": [["2 2\r\n1 2 1\r\n1 1 1", "Second\r\n2 1 0\r\nBuwanle"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2015", "洛谷原创", "洛谷月赛"], "title": "yyy 棋", "background": "", "description": "uim 最近在研究一种游戏，叫做“ yyy 棋”。\n\n这种游戏的规则很简单，就是有一个 $A \\times B$ 的棋盘和黑白两色的棋子，两个人轮流在下在格子里面。你可以下黑棋或者白棋，中途可以更换颜色，可以下在任何你喜欢的地方，但是要符合以下条件：\n\n1. 这个位置不能已经被别的棋子占用。\n\n2. 你准备下的地方，上下左右一格范围中不能有和你准备下的颜色一样的棋子。\n\n3. 第一个下的人必须出黑子。\n\n\n当谁没有地方可以放子，谁就输了。\n\n\nuim 把你拉了出来，希望你好好地陪他玩。\n\n由于你很忙不太情愿，uim 就让步了，允许你选择先手或者后手。\n\n\n你突然灵光一现，想到了你小学奥数做到的一个问题：两个人坐在一张桌子的两边，轮流往桌子上放硬币，硬币不能重叠，谁放不下谁就输了。感觉有点类似，所以，你打算借鉴这个办法。\n\n你知道，通过某种策略，你一定是 $100\\%$ 赢的。\n\n既然如此，就让 uim 输个痛快吧。", "inputFormat": "第一行，$A, B$，两个整数，表示棋盘大小\n\n接下来若干行为 uim 依次下的顺序，每行三个整数 $x_i, y_i, c_i$，分别表示位置和颜色，颜色 $1$ 为黑，$0$ 为白。位置 $1 \\le x_i \\le A$，$  1 \\le y _ i \\le B$。\n\n如果 uim 发现没地方可走，就可能会耍赖，将棋子下在了不合法的地方。遇到这种情况，你也要指出。当然 uim 也有可能知道自己输了后就不下了。不存在游戏胜负还没定 uim 就投降的情况。\n", "outputFormat": "第一行，选择先手还是后手，先手请输出 `First`，后手输出 `Second`。\n\n接下来几行，如果你是第一个下子的，请输出你的第一步下法。然后对 uim 的下的每一个子做出回应。输出 $x _ i \\ y _ i \\ c _ i$，意思和上面相同。\n\n**你必须输出必胜的下法，否则你将 `WA` 这个点。**\n\n如果多个下法都是必胜点，请输出个能够尽早结束游戏的下法。\n\n**在你下完这个子之前，请假装你不知道uim的下一步走法。**\n\n如果 uim 耍赖，那么这一行输出 `Buwanle` 并结束程序，多余的输入就不管它了。", "hint": "$40\\%$ 数据，$2 \\le A, B \\le 3$。\n\n$100\\%$ 数据，$2 \\le A, B \\le 9$。\n\n然而作为月赛的第一题，自然是简单的。因为标程的核心代码只有 $6$ 行。并不需要使用什么复杂算法就可以得到答案。\n", "locale": "zh-CN", "translations": {"en": {"title": "yyy Chess", "background": "", "description": "uim has been studying a game called “yyy Chess.”\n\nThe rules are simple: there is an $A \\times B$ board and black/white pieces. Two players take turns placing a piece on a cell. You may play either black or white and may switch colors during the game. You may place a piece anywhere you like, as long as the following conditions are satisfied:\n1. The cell is not already occupied by another piece.\n2. In the four orthogonal neighboring cells (up, down, left, right) of the target cell, there must not be a piece of the same color as the one you are about to place.\n3. The first player must place a black piece.\n\nWhoever has no legal move loses.\n\nuim drags you in, hoping you will play with him.\n\nSince you are busy and reluctant, uim makes a concession and allows you to choose to play first or second.\n\nYou suddenly recall an elementary math puzzle: two people sit on opposite sides of a table and alternately place coins on the table; coins cannot overlap; whoever cannot place a coin loses. This feels similar, so you plan to borrow that idea.\n\nYou know that, with a certain strategy, you are guaranteed to win with $100\\%$ certainty.\n\nSince that is the case, let uim lose quickly.", "inputFormat": "The first line contains $A, B$, two integers representing the board size.\n\nThe following lines describe uim’s moves in order. Each line contains three integers $x_i, y_i, c_i$, representing the position and the color. Color $1$ is black, and color $0$ is white. Positions satisfy $1 \\le x_i \\le A$, $1 \\le y_i \\le B$.\n\nIf uim finds no legal move, he might cheat by placing a piece in an illegal position. In that case, you should also point it out. Of course, uim might also stop moving once he knows he has lost. It will not happen that uim resigns while the outcome of the game is still undecided.", "outputFormat": "On the first line, choose whether to play first or second. Output `First` for first, or `Second` for second.\n\nOn the following lines, if you are the first to move, output your first move. Then respond to each of uim’s moves. Output $x_i\\ y_i\\ c_i$, with the same meaning as above.\n\nYou must output a forced-winning strategy; otherwise you will get `WA` on this test.\n\nIf multiple strategies are winning, output one that finishes the game as early as possible.\n\nBefore you place your move, pretend you do not know uim’s next move.\n\nIf uim cheats, output `Buwanle` on that line and terminate the program, ignoring any remaining input.", "hint": "For $40\\%$ testdata, $2 \\le A, B \\le 3$.\n\nFor $100\\%$ testdata, $2 \\le A, B \\le 9$.\n\nAs the first problem in the monthly contest, it is naturally simple. The core of the reference solution has only 6 lines of code. No complex algorithms are needed to obtain the answer.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "yyy 棋", "background": "", "description": "uim 最近在研究一种游戏，叫做“ yyy 棋”。\n\n这种游戏的规则很简单，就是有一个 $A \\times B$ 的棋盘和黑白两色的棋子，两个人轮流在下在格子里面。你可以下黑棋或者白棋，中途可以更换颜色，可以下在任何你喜欢的地方，但是要符合以下条件：\n\n1. 这个位置不能已经被别的棋子占用。\n\n2. 你准备下的地方，上下左右一格范围中不能有和你准备下的颜色一样的棋子。\n\n3. 第一个下的人必须出黑子。\n\n\n当谁没有地方可以放子，谁就输了。\n\n\nuim 把你拉了出来，希望你好好地陪他玩。\n\n由于你很忙不太情愿，uim 就让步了，允许你选择先手或者后手。\n\n\n你突然灵光一现，想到了你小学奥数做到的一个问题：两个人坐在一张桌子的两边，轮流往桌子上放硬币，硬币不能重叠，谁放不下谁就输了。感觉有点类似，所以，你打算借鉴这个办法。\n\n你知道，通过某种策略，你一定是 $100\\%$ 赢的。\n\n既然如此，就让 uim 输个痛快吧。", "inputFormat": "第一行，$A, B$，两个整数，表示棋盘大小\n\n接下来若干行为 uim 依次下的顺序，每行三个整数 $x_i, y_i, c_i$，分别表示位置和颜色，颜色 $1$ 为黑，$0$ 为白。位置 $1 \\le x_i \\le A$，$  1 \\le y _ i \\le B$。\n\n如果 uim 发现没地方可走，就可能会耍赖，将棋子下在了不合法的地方。遇到这种情况，你也要指出。当然 uim 也有可能知道自己输了后就不下了。不存在游戏胜负还没定 uim 就投降的情况。\n", "outputFormat": "第一行，选择先手还是后手，先手请输出 `First`，后手输出 `Second`。\n\n接下来几行，如果你是第一个下子的，请输出你的第一步下法。然后对 uim 的下的每一个子做出回应。输出 $x _ i \\ y _ i \\ c _ i$，意思和上面相同。\n\n**你必须输出必胜的下法，否则你将 `WA` 这个点。**\n\n如果多个下法都是必胜点，请输出个能够尽早结束游戏的下法。\n\n**在你下完这个子之前，请假装你不知道uim的下一步走法。**\n\n如果 uim 耍赖，那么这一行输出 `Buwanle` 并结束程序，多余的输入就不管它了。", "hint": "$40\\%$ 数据，$2 \\le A, B \\le 3$。\n\n$100\\%$ 数据，$2 \\le A, B \\le 9$。\n\n然而作为月赛的第一题，自然是简单的。因为标程的核心代码只有 $6$ 行。并不需要使用什么复杂算法就可以得到答案。\n", "locale": "zh-CN"}}}
{"pid": "P2362", "type": "P", "difficulty": 2, "samples": [["3\n9 10 1 9 8 7 6 3 4 6\n3 100 70 102\n6 40 37 23 89 91 12", "4 1\n2 2\n3 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "洛谷原创"], "title": "围栏木桩", "background": "", "description": "某农场有一个由按编号排列的 $n$ 根木桩构成的首尾不相连的围栏。现要在这个围栏中选取一些木桩，按照原有的编号次序排列之后，这些木桩高度成一个升序序列。所谓的升序序列就是序列中的任何一个数都不小于它之前的任何一个数。试编写程序从这个围栏中选取合适的木桩使得选出的木桩个数 $t$ 最大，并求出选取出 $t$ 根木桩的方案总数 $c$。\n", "inputFormat": "文件中的第一行只有一个数 $m$，表明随后有 $m$ 个问题的描述信息。每个问题的描述信息格式为 $n,h_1,h_2,h_3,…,h_n$（其中 $h_i(i=1,2,3,…,n)$ 表示第 $i$ 根木桩的高度）。\n", "outputFormat": "依次输出每个问题中 $t$ 和 $c$ 的解。每行输出一个问题的解。\n", "hint": "$m \\leq 5$，$n \\leq 20$，$h_i \\leq 150$。", "locale": "zh-CN", "translations": {"en": {"title": "Fence Posts", "background": "", "description": "A farm has a non-circular fence consisting of $n$ posts arranged in order by their indices. We want to select some posts such that, when kept in their original index order, the selected posts' heights form a non-decreasing sequence. A non-decreasing sequence means every number in the sequence is not less than any number before it. Write a program to select posts so that the number of selected posts $t$ is maximized, and compute the total number of selection schemes $c$ that achieve $t$ posts.", "inputFormat": "The first line contains a single integer $m$, indicating that there are $m$ test cases.  \nEach test case is given on one line as $n$ followed by $n$ integers $h_1, h_2, h_3, \\dots, h_n$ (where $h_i$ denotes the height of the $i$-th post), all separated by spaces.", "outputFormat": "For each test case, output $t$ and $c$. Print one test case per line, with $t$ and $c$ separated by a space.", "hint": "$m \\leq 5$，$n \\leq 20$，$h_i \\leq 150$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "围栏木桩", "background": "", "description": "某农场有一个由按编号排列的 $n$ 根木桩构成的首尾不相连的围栏。现要在这个围栏中选取一些木桩，按照原有的编号次序排列之后，这些木桩高度成一个升序序列。所谓的升序序列就是序列中的任何一个数都不小于它之前的任何一个数。试编写程序从这个围栏中选取合适的木桩使得选出的木桩个数 $t$ 最大，并求出选取出 $t$ 根木桩的方案总数 $c$。\n", "inputFormat": "文件中的第一行只有一个数 $m$，表明随后有 $m$ 个问题的描述信息。每个问题的描述信息格式为 $n,h_1,h_2,h_3,…,h_n$（其中 $h_i(i=1,2,3,…,n)$ 表示第 $i$ 根木桩的高度）。\n", "outputFormat": "依次输出每个问题中 $t$ 和 $c$ 的解。每行输出一个问题的解。\n", "hint": "$m \\leq 5$，$n \\leq 20$，$h_i \\leq 150$。", "locale": "zh-CN"}}}
{"pid": "P2363", "type": "P", "difficulty": 4, "samples": [["3\n1 2 3\n4 5 6\n7 8 9", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["哈希 hashing", "前缀和"], "title": "马农", "background": null, "description": "在观看完战马检阅之后，来自大草原的两兄弟决心成为超级“马农”，专门饲养战马。\n\n兄弟两回到草原，将可以养马的区域分为 $N \\times N$ 的单位面积的正方形，并实地进行考察，归纳出了每个单位面积可以养马所获得的收益。接下来就要开始规划他们各自的马场了。首先，两人的马场都必须是矩形区域。同时，为了方便两人互相照应，也为了防止马匹互相走散，规定两个马场的矩形区域相邻，且只有一个交点。最后，互不认输的两人希望两个马场的收益相当，这样才不会影响他们兄弟的感情。现在，兄弟俩找到你这位设计师，希望你给他们设计马场，问共有多少种设计方案。", "inputFormat": "第一行一个整数 $N$，表示整个草原的大小为 $N \\times N$。接下来 $N$ 行，每行 $N$ 个整数 $A_{i,j}$，表示第 $i$ 行第 $j$ 列的单位草地的收成。（注意：收益可能是负数，养马也不是包赚的，马匹也可能出现生病死亡等意外。）", "outputFormat": "输出符合两人要求的草原分配方案数。", "hint": "对于所有数据，$1 \\leq n \\leq 50$，$-999 \\le A_{i,j} \\le 999$。", "locale": "zh-CN", "translations": {"en": {"title": "Ma Nong", "background": "", "description": "After watching a warhorse review, two brothers from the grasslands decide to become super \"ma nong\" (horse ranchers), specializing in raising warhorses.\n\nThey return to the grassland and divide the area suitable for horse ranching into $N \\times N$ unit square cells, then conduct a field survey to summarize the profit obtainable from raising horses on each unit area. Next, they will plan their respective ranches. First, both ranches must each be a rectangular region. Also, to facilitate mutual care and prevent horses from straying, the two rectangular ranches must be adjacent and have exactly one common point (i.e., they touch at a single point). Finally, the two competitive brothers want the total profits of the two ranches to be equal, so as not to hurt their relationship. Now, they ask you, the designer, to design their ranches: how many valid design plans are there?", "inputFormat": "The first line contains an integer $N$, indicating that the entire grassland is of size $N \\times N$. The next $N$ lines each contain $N$ integers $A_{i,j}$, representing the profit of the unit grassland at row $i$, column $j$. (Note: profits may be negative; raising horses is not guaranteed to be profitable, and accidents such as illness or death may occur.)", "outputFormat": "Output the number of grassland allocation plans that meet the brothers’ requirements.", "hint": "For all testdata, $1 \\leq N \\leq 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "马农", "background": null, "description": "在观看完战马检阅之后，来自大草原的两兄弟决心成为超级“马农”，专门饲养战马。\n\n兄弟两回到草原，将可以养马的区域分为 $N \\times N$ 的单位面积的正方形，并实地进行考察，归纳出了每个单位面积可以养马所获得的收益。接下来就要开始规划他们各自的马场了。首先，两人的马场都必须是矩形区域。同时，为了方便两人互相照应，也为了防止马匹互相走散，规定两个马场的矩形区域相邻，且只有一个交点。最后，互不认输的两人希望两个马场的收益相当，这样才不会影响他们兄弟的感情。现在，兄弟俩找到你这位设计师，希望你给他们设计马场，问共有多少种设计方案。", "inputFormat": "第一行一个整数 $N$，表示整个草原的大小为 $N \\times N$。接下来 $N$ 行，每行 $N$ 个整数 $A_{i,j}$，表示第 $i$ 行第 $j$ 列的单位草地的收成。（注意：收益可能是负数，养马也不是包赚的，马匹也可能出现生病死亡等意外。）", "outputFormat": "输出符合两人要求的草原分配方案数。", "hint": "对于所有数据，$1 \\leq n \\leq 50$，$-999 \\le A_{i,j} \\le 999$。", "locale": "zh-CN"}}}
{"pid": "P2364", "type": "P", "difficulty": 3, "samples": [["cecqbhvaiaedpibaluk\ncabegviapcihlaaugck\nadceevfdadaepcialaukd", "cevapiluk"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "Special Judge"], "title": "胖男孩", "background": "", "description": "麦克正如我们所知的已快乐地结婚，在上个月他胖了 $70$ 磅。因为手指上的脂肪过多，使他连给他最亲密的朋友斯拉夫克写一个电子邮件都很困难。\n\n每晚麦克都详细地描述那一天他所吃的所有东西，但有时当他只想按一次某键时往往会按了不止一次，并且他的胖手指还会碰到他不想要按的键，麦克也知道自己的手指有问题，因此他在打字的时候很小心，以确保每打一个想要的字符时误打的字符不超过 $3$ 个，误打的字符可能在正确字符之前也可能在其之后。\n\n当斯拉夫克多次收到读不懂的电子邮件后，他总是要求麦克将电子邮件发 $3$ 遍，使他容易读懂一点。\n\n编写程序，帮助斯拉夫克根据他所收到的三封电子邮件求出麦克可能写出的最长的信。\n", "inputFormat": "输入文件包含了三行文本。每一行文本包括麦克信件的一种版本。其中所有的字符都由英文字母表中的小写字母组成并且不超过 $100$ 个。\n", "outputFormat": "输出文件中第一行即唯一的一行数据应该包含斯拉夫克根据所收到的电子邮件推测出的最长信件。你可以相信问题一定有解，但解不一定是唯一的。\n", "hint": "由 @zhouyonglong 提供 SPJ\n", "locale": "zh-CN", "translations": {"en": {"title": "Fat Boy", "background": "", "description": "As we know, Mike has happily gotten married, and last month he gained $70$ pounds. Because of too much fat on his fingers, even writing an email to his closest friend Slavko is difficult for him.\n\nEvery night Mike carefully describes everything he ate that day, but sometimes when he wants to press a key once, he presses it more than once, and his fat fingers may also hit keys he does not intend to press. Mike knows his fingers are a problem, so he types very carefully: for each intended character, the number of mistakenly typed characters does not exceed $3$. The mistaken characters may appear either before or after the correct character.\n\nAfter receiving several unreadable emails, Slavko asked Mike to send each email $3$ times to make it easier to read.\n\nWrite a program to help Slavko determine the longest letter Mike could have intended, based on the three emails he received.", "inputFormat": "The input consists of three lines of text. Each line is one version of Mike’s letter. All characters are lowercase English letters, and the length of each line does not exceed $100$.", "outputFormat": "Output a single line containing the longest letter that Slavko can infer from the received emails. You may assume that a solution exists, but it is not necessarily unique.", "hint": "SPJ provided by @zhouyonglong.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "胖男孩", "background": "", "description": "麦克正如我们所知的已快乐地结婚，在上个月他胖了 $70$ 磅。因为手指上的脂肪过多，使他连给他最亲密的朋友斯拉夫克写一个电子邮件都很困难。\n\n每晚麦克都详细地描述那一天他所吃的所有东西，但有时当他只想按一次某键时往往会按了不止一次，并且他的胖手指还会碰到他不想要按的键，麦克也知道自己的手指有问题，因此他在打字的时候很小心，以确保每打一个想要的字符时误打的字符不超过 $3$ 个，误打的字符可能在正确字符之前也可能在其之后。\n\n当斯拉夫克多次收到读不懂的电子邮件后，他总是要求麦克将电子邮件发 $3$ 遍，使他容易读懂一点。\n\n编写程序，帮助斯拉夫克根据他所收到的三封电子邮件求出麦克可能写出的最长的信。\n", "inputFormat": "输入文件包含了三行文本。每一行文本包括麦克信件的一种版本。其中所有的字符都由英文字母表中的小写字母组成并且不超过 $100$ 个。\n", "outputFormat": "输出文件中第一行即唯一的一行数据应该包含斯拉夫克根据所收到的电子邮件推测出的最长信件。你可以相信问题一定有解，但解不一定是唯一的。\n", "hint": "由 @zhouyonglong 提供 SPJ\n", "locale": "zh-CN"}}}
{"pid": "P2365", "type": "P", "difficulty": 4, "samples": [["5\n1\n1 3\n3 2\n4 3\n2 3\n1 4", "153"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "cdq 分治", "斜率优化"], "title": "任务安排", "background": "", "description": "$n$ 个任务排成一个序列在一台机器上等待完成（顺序不得改变），这 $n$ 个任务被分成若干批，每批包含相邻的若干任务。  \n\n从零时刻开始，这些任务被分批加工，第 $i$ 个任务单独完成所需的时间为 $t_i$。在每批任务开始前，机器需要启动时间 $s$，而完成这批任务所需的时间是各个任务需要时间的总和（同一批任务将在同一时刻完成）。  \n\n每个任务的费用是它的完成时刻乘以一个费用系数 $f_i$。请确定一个分组方案，使得总费用最小。\n", "inputFormat": "第一行一个正整数 $n$。  \n第二行是一个整数 $s$。\n\n下面 $n$ 行每行有一对数，分别为 $t_i$ 和 $f_i$，表示第 $i$ 个任务单独完成所需的时间是 $t_i$ 及其费用系数 $f_i$。\n", "outputFormat": "一个数，最小的总费用。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 5000$，$0 \\le s \\le 50$，$1\\le t_i,f_i \\le 100$。\n\n【样例解释】   \n如果分组方案是 $\\{1,2\\},\\{3\\},\\{4,5\\}$，则完成时间分别为 $\\{5,5,10,14,14\\}$，费用 $C=15+10+30+42+56$，总费用就是 $153$。", "locale": "zh-CN", "translations": {"en": {"title": "Task Arrangement", "background": "", "description": "There are $n$ tasks arranged in a sequence waiting to be completed on a single machine (the order cannot be changed). These $n$ tasks are divided into several batches, each batch containing consecutive tasks.\n\nStarting from time $0$, the tasks are processed batch by batch. The time required to complete task $i$ alone is $t_i$. Before each batch starts, the machine needs a startup time $s$, and the time required to process that batch is the sum of the required times of its tasks (all tasks in the same batch finish at the same time).\n\nThe cost of each task is its completion time multiplied by a cost coefficient $f_i$. Determine a batching scheme that minimizes the total cost.", "inputFormat": "The first line contains a positive integer $n$.  \nThe second line contains an integer $s$.  \nEach of the next $n$ lines contains a pair of numbers, $t_i$ and $f_i$, indicating that the time required to complete task $i$ alone is $t_i$ and its cost coefficient is $f_i$.", "outputFormat": "Output a single number, the minimal total cost.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le n \\le 5000$, $0 \\le s \\le 50$, $1 \\le t_i, f_i \\le 100$.\n\nSample explanation  \nIf the batching scheme is $\\{1,2\\}, \\{3\\}, \\{4,5\\}$, then the completion times are $\\{5, 5, 10, 14, 14\\}$, the cost is $C=15+10+30+42+56$, so the total cost is $153$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "任务安排", "background": "", "description": "$n$ 个任务排成一个序列在一台机器上等待完成（顺序不得改变），这 $n$ 个任务被分成若干批，每批包含相邻的若干任务。  \n\n从零时刻开始，这些任务被分批加工，第 $i$ 个任务单独完成所需的时间为 $t_i$。在每批任务开始前，机器需要启动时间 $s$，而完成这批任务所需的时间是各个任务需要时间的总和（同一批任务将在同一时刻完成）。  \n\n每个任务的费用是它的完成时刻乘以一个费用系数 $f_i$。请确定一个分组方案，使得总费用最小。\n", "inputFormat": "第一行一个正整数 $n$。  \n第二行是一个整数 $s$。\n\n下面 $n$ 行每行有一对数，分别为 $t_i$ 和 $f_i$，表示第 $i$ 个任务单独完成所需的时间是 $t_i$ 及其费用系数 $f_i$。\n", "outputFormat": "一个数，最小的总费用。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 5000$，$0 \\le s \\le 50$，$1\\le t_i,f_i \\le 100$。\n\n【样例解释】   \n如果分组方案是 $\\{1,2\\},\\{3\\},\\{4,5\\}$，则完成时间分别为 $\\{5,5,10,14,14\\}$，费用 $C=15+10+30+42+56$，总费用就是 $153$。", "locale": "zh-CN"}}}
{"pid": "P2366", "type": "P", "difficulty": 3, "samples": [["3\na=233;\nb=a;\nc=a+b;", "a 233\nb 233\nc 466"], ["3\na=233;\nb=1+1;\na=b;", "a 2\nb 2"]], "limits": {"time": [1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串", "洛谷原创", "洛谷月赛"], "title": "yyy2015c01 的 IDE 之 Watches", "background": "在 2020 年的某一天，我们的 yyy2015c01 同学想要开发一套 IDE。", "description": "作为他开发团队中的一员，你不幸地被选入了 Debugger 的开发组。\n\nyyy2015c01 设想的 Debugger 由几部分组成，其中的一个小组件就是 Watches——中文称之为“变量观察器”。\n\n由于 IDE 目前还是内测版，开发组需要先编一个能观察 int 类型变量值的 Watches 来看看效果如何。这个任务交由你来完成。\n\n开发组假想的 Watches 能实现如下 3 种语句运行后监测相应变量值的功能：\n- `n=1;` 将常量赋给变量，保证这个常量的位数不大于 $9$。\n- `a=b;` 变量之间赋值：若原变量（在本例中是 $b$）未被赋值则认为其初始值为 $0$。\n- `m=1+2;` $A+B$ 表达式赋值，只有 `+` 且只有两个数或者变量，$A$ 和 $B$ 都介于 $1$ 至 $10^6$ 之间。\n\n请你编写一个 Watches，并在所有语句运行完后对所有被赋值过的变量按标识符的字典序输出它们的值（保证不会有变量的值大于 int 的最大值）。\n", "inputFormat": "输入共 $n+1$ 行。\n\n第一行是一个正整数 $n$，表示共有 $n$ 条赋值语句；\n\n第二行到第 $n+1$ 行，每行是一条赋值语句（格式为“变量名=赋值式子;”），保证不会有多余的其他字符。", "outputFormat": "输出共 $n$ 行：每行是一个被赋值过的变量标识符及它的值。", "hint": "数据很弱，直接模拟过哟~\n\n（别想着变量标识符只有一位哟！）\n\n另：向本题主人公 yyy2015c01 同学致敬！", "locale": "zh-CN", "translations": {"en": {"title": "yyy2015c01's IDE: Watches", "background": "On a day in 2020, our classmate yyy2015c01 wanted to develop an IDE.", "description": "As a member of his development team, you were unfortunately assigned to the Debugger group.\n\nThe Debugger envisioned by yyy2015c01 consists of several parts, and one small component is Watches — in Chinese, “变量观察器” (variable watcher).\n\nSince the IDE is still in internal testing, the team needs a Watches that can monitor int-type variable values first to see how it works. This task is assigned to you.\n\nThe envisioned Watches can monitor the corresponding variable values after executing the following three types of statements:\n- `n=1;` Assign a literal constant to a variable; the number of digits of this constant is at most $9$.\n- `a=b;` Assignment between variables: if the source variable (in this example, $b$) has never been assigned, treat its initial value as $0$.\n- `m=1+2;` Assignment with an $A+B$ expression. Only the `+` operator is allowed, and there are exactly two operands (either literals or variables). Both $A$ and $B$ are in the range $1$ to $10^6$.\n\nPlease implement a Watches that, after all statements are executed, outputs all variables that have been assigned at least once, in lexicographical order by identifier, along with their values (it is guaranteed that no variable’s value exceeds the maximum value of int).", "inputFormat": "The input contains $n+1$ lines.\n\n- The first line is a positive integer $n$, the number of assignment statements.\n- Lines $2$ through $n+1$ each contain one assignment statement (in the format 'variable=expression;'). No extra characters will appear.", "outputFormat": "Output one line for each variable that has been assigned at least once. Each line contains the variable identifier and its value. The variables must be sorted in lexicographical order by their identifiers.", "hint": "The testdata is very weak; direct simulation will pass.\n\n(Don’t assume variable identifiers are single-character!)\n\nAlso, salute to the protagonist, classmate yyy2015c01!\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "yyy2015c01 的 IDE 之 Watches", "background": "在 2020 年的某一天，我们的 yyy2015c01 同学想要开发一套 IDE。", "description": "作为他开发团队中的一员，你不幸地被选入了 Debugger 的开发组。\n\nyyy2015c01 设想的 Debugger 由几部分组成，其中的一个小组件就是 Watches——中文称之为“变量观察器”。\n\n由于 IDE 目前还是内测版，开发组需要先编一个能观察 int 类型变量值的 Watches 来看看效果如何。这个任务交由你来完成。\n\n开发组假想的 Watches 能实现如下 3 种语句运行后监测相应变量值的功能：\n- `n=1;` 将常量赋给变量，保证这个常量的位数不大于 $9$。\n- `a=b;` 变量之间赋值：若原变量（在本例中是 $b$）未被赋值则认为其初始值为 $0$。\n- `m=1+2;` $A+B$ 表达式赋值，只有 `+` 且只有两个数或者变量，$A$ 和 $B$ 都介于 $1$ 至 $10^6$ 之间。\n\n请你编写一个 Watches，并在所有语句运行完后对所有被赋值过的变量按标识符的字典序输出它们的值（保证不会有变量的值大于 int 的最大值）。\n", "inputFormat": "输入共 $n+1$ 行。\n\n第一行是一个正整数 $n$，表示共有 $n$ 条赋值语句；\n\n第二行到第 $n+1$ 行，每行是一条赋值语句（格式为“变量名=赋值式子;”），保证不会有多余的其他字符。", "outputFormat": "输出共 $n$ 行：每行是一个被赋值过的变量标识符及它的值。", "hint": "数据很弱，直接模拟过哟~\n\n（别想着变量标识符只有一位哟！）\n\n另：向本题主人公 yyy2015c01 同学致敬！", "locale": "zh-CN"}}}
{"pid": "P2367", "type": "P", "difficulty": 2, "samples": [["3 2\n1 1 1\n1 2 1\n2 3 1", "2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "洛谷原创", "差分", "洛谷月赛"], "title": "语文成绩", "background": "语文考试结束了，成绩还是一如既往地有问题。\n", "description": "语文老师总是写错成绩，所以当她修改成绩的时候，总是累得不行。她总是要一遍遍地给某些同学增加分数，又要注意最低分是多少。你能帮帮她吗？\n", "inputFormat": "第一行有两个整数 $n$，$p$，代表学生数与增加分数的次数。\n\n第二行有 $n$ 个数，$a_1 \\sim a_n$，代表各个学生的初始成绩。\n\n接下来 $p$ 行，每行有三个数，$x$，$y$，$z$，代表给第 $x$ 个到第 $y$ 个学生每人增加 $z$ 分。", "outputFormat": "输出仅一行，代表更改分数后，全班的最低分。\n", "hint": "对于 $40\\%$ 的数据，有 $n \\le 10^3$。\n\n对于 $60\\%$ 的数据，有 $n \\le 10^4$。\n\n对于 $80\\%$ 的数据，有 $n \\le 10^5$。\n\n对于 $100\\%$ 的数据，有 $n \\le 5\\times 10^6$，$p \\le n$，学生初始成绩 $ \\le 100$，$z \\le 100$。", "locale": "zh-CN", "translations": {"en": {"title": "Chinese Scores", "background": "The Chinese exam has ended, and the scores are, as always, problematic.", "description": "The Chinese teacher always writes scores wrong, so when she corrects them, she gets exhausted. She keeps adding points again and again to certain students, and she also needs to keep track of the minimum score. Can you help her?", "inputFormat": "The first line has two integers $n$, $p$, representing the number of students and the number of additions.\n\nThe second line has $n$ numbers, $a_1 \\sim a_n$, representing each student's initial score.\n\nThe next $p$ lines each have three numbers, $x$, $y$, $z$, representing adding $z$ points to each student from the $x$-th to the $y$-th, inclusive.", "outputFormat": "Output only one line, representing the class minimum score after the changes.", "hint": "For $40\\%$ of the testdata, $n \\le 10^3$.\n\nFor $60\\%$ of the testdata, $n \\le 10^4$.\n\nFor $80\\%$ of the testdata, $n \\le 10^5$.\n\nFor $100\\%$ of the testdata, $n \\le 5\\times 10^6$, $p \\le n$, initial scores $\\le 100$, $z \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "语文成绩", "background": "语文考试结束了，成绩还是一如既往地有问题。\n", "description": "语文老师总是写错成绩，所以当她修改成绩的时候，总是累得不行。她总是要一遍遍地给某些同学增加分数，又要注意最低分是多少。你能帮帮她吗？\n", "inputFormat": "第一行有两个整数 $n$，$p$，代表学生数与增加分数的次数。\n\n第二行有 $n$ 个数，$a_1 \\sim a_n$，代表各个学生的初始成绩。\n\n接下来 $p$ 行，每行有三个数，$x$，$y$，$z$，代表给第 $x$ 个到第 $y$ 个学生每人增加 $z$ 分。", "outputFormat": "输出仅一行，代表更改分数后，全班的最低分。\n", "hint": "对于 $40\\%$ 的数据，有 $n \\le 10^3$。\n\n对于 $60\\%$ 的数据，有 $n \\le 10^4$。\n\n对于 $80\\%$ 的数据，有 $n \\le 10^5$。\n\n对于 $100\\%$ 的数据，有 $n \\le 5\\times 10^6$，$p \\le n$，学生初始成绩 $ \\le 100$，$z \\le 100$。", "locale": "zh-CN"}}}
{"pid": "P2368", "type": "P", "difficulty": 2, "samples": [["8", "0"]], "limits": {"time": [869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "枚举"], "title": "EXCEEDED WARNING B", "background": "SGU 107\n", "description": "求有多少个平方后末尾为 $987654321$ 的 $n$ 位数。", "inputFormat": "一个整数 $n$。", "outputFormat": "答案，即 **“平方后末尾为 $\\bm{987654321}$ 的 $\\bm{n}$ 位数”** 的个数", "hint": "$1\\le n\\le 1 0^6$。\n\n不要问我暴力能过几个点，我只想说呵呵。", "locale": "zh-CN", "translations": {"en": {"title": "EXCEEDED WARNING B", "background": "SGU 107.", "description": "Find how many $n$-digit integers have squares ending with $987654321$.", "inputFormat": "A single integer $n$.", "outputFormat": "The answer, i.e., the number of **“$\\bm{n}$-digit integers whose squares end with $\\bm{987654321}$”**.", "hint": "$1 \\le n \\le 10^6$.\n\nDon't ask how many test points brute force can pass; I can only say hehe.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "EXCEEDED WARNING B", "background": "SGU 107\n", "description": "求有多少个平方后末尾为 $987654321$ 的 $n$ 位数。", "inputFormat": "一个整数 $n$。", "outputFormat": "答案，即 **“平方后末尾为 $\\bm{987654321}$ 的 $\\bm{n}$ 位数”** 的个数", "hint": "$1\\le n\\le 1 0^6$。\n\n不要问我暴力能过几个点，我只想说呵呵。", "locale": "zh-CN"}}}
{"pid": "P2369", "type": "P", "difficulty": 2, "samples": [["10 5\n2\n4\n6\n8\n10\n1\n3\n5\n7\n9", "1\n2\n3\n4\n5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [4096, 4096, 4096, 4096, 4096, 4096, 4096, 4096, 4096]}, "tags": ["堆"], "title": "EXCEEDED WARNING A", "background": "", "description": "有这样一些数据，它们均为小于 $10^9$ 的非负整数，且个数为 $n$，现在请你输出其中最小的 $m$ 个数。\n\n小心溢出，注意 Memory Limit = 4000KiB。\n", "inputFormat": "第一行以半角空格间隔开的两个非负整数： $n, m$\n\n接下来的 $n$ 行，随机产生的 $n$ 个数，保证 $32$ 位整型变量可以存下。\n", "outputFormat": "共 $m$ 行，即题目描述中的 $m$ 个数，从小到大依次输出。\n", "hint": "数据范围：$m<10^5, n<10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "EXCEEDED WARNING A", "background": "", "description": "There are some numbers, all non-negative integers less than $10^9$, with a total count of $n$. Please output the smallest $m$ numbers among them.\n\nBeware of overflow, and note that Memory Limit = 4000 KiB.", "inputFormat": "The first line contains two non-negative integers separated by a space: $n, m$.\n\nThe next $n$ lines contain the $n$ randomly generated numbers, guaranteed to fit in a 32-bit integer.", "outputFormat": "Output $m$ lines: the $m$ numbers described above, in ascending order from smallest to largest.", "hint": "Constraints: $m < 10^5$, $n < 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "EXCEEDED WARNING A", "background": "", "description": "有这样一些数据，它们均为小于 $10^9$ 的非负整数，且个数为 $n$，现在请你输出其中最小的 $m$ 个数。\n\n小心溢出，注意 Memory Limit = 4000KiB。\n", "inputFormat": "第一行以半角空格间隔开的两个非负整数： $n, m$\n\n接下来的 $n$ 行，随机产生的 $n$ 个数，保证 $32$ 位整型变量可以存下。\n", "outputFormat": "共 $m$ 行，即题目描述中的 $m$ 个数，从小到大依次输出。\n", "hint": "数据范围：$m<10^5, n<10^6$。", "locale": "zh-CN"}}}
{"pid": "P2370", "type": "P", "difficulty": 3, "samples": [["3 3 5\n2 2\n1 2\n3 2", "2"], ["2 3 505\n1 2\n500 1", "500"], ["3 3 2\n2 2\n1 2\n3 2", "No Solution!"], ["4 5 6\n5 1\n5 2\n5 3\n1 1", "No Solution!"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "贪心", "2015", "二分", "洛谷原创", "排序", "背包 DP", "洛谷月赛"], "title": "yyy2015c01 的 U 盘", "background": "在 2020 年的某一天，我们的 yyy2015c01 买了个高端 U 盘。\n", "description": "你找 yyy2015c01 借到了这个高端的 U 盘，拷贝一些重要资料，但是你发现这个 U 盘有一些问题：\n\n1. 这个 U 盘的传输接口很小，只能传输大小不超过 $L$ 的文件。\n2. 这个 U 盘容量很小，一共只能装不超过 $S$ 的文件。\n\n但是你要备份的资料却有很多，你只能备份其中的一部分。\n\n为了选择要备份哪些文件，你给所有文件设置了一个价值 $V_i$，你希望备份的文件总价值不小于 $p$。\n\n但是很快你发现这是不可能的，因为 yyy2015c01 的传输接口太小了，你只有花钱买一个更大的接口（更大的接口意味着可以传输更大的文件，但是购买它会花费更多的钱）。\n\n注意：你的文件不能被分割（你只能把一个文件整个的传输进去，并储存在U盘中）,\n\n你放在 U 盘中文件的总大小不能超过 U 盘容量。\n\n现在问题来了：你想知道，在满足 U 盘中文件价值之和**不小于** $p$ 时，最小需要多大的接口。", "inputFormat": "第 $1$ 行，三个正整数 $n,p,S$ 分别表示文件总数，希望最小价值 $p$ ，U 盘大小。\n\n接下来 $n$ 行，每行两个正整数 $W_{i},V_{i}$，表示第 $i$ 个文件的大小和价值。", "outputFormat": "输出一个正整数表示最小需要的接口大小。\n\n如果无解输出 `No Solution!`。", "hint": "$1 \\le n, W_i, S \\le 10^3$，$1 \\leq V_i \\leq 10^6$，$1 \\leq p \\leq 10^9$。\n\n数据较小，请勿乱搞。\n\n样例解释 $1$：买一个大小为 $2$ 接口，把物品 $1$ 、$2$ 放进$\\text{U}$盘。\n\n样例解释 $2$：买一个大小为 $500$ 的接口。\n\n样例解释 $3$：本来可以买大小为 $2$ 的接口，可是 U 盘容量放不下足够的文件。\n\n如果数据出现疏漏，请联系出题人 [a710128](https://www.luogu.com.cn/user/2573)\n\n向本题主人公 yyy2015c01 同学致敬！", "locale": "zh-CN", "translations": {"en": {"title": "yyy2015c01's USB Drive", "background": "On a day in 2020, our yyy2015c01 bought a high-end USB drive.", "description": "You borrowed this high-end USB drive from yyy2015c01 to copy some important files, but you found some issues:\n\n1. The USB drive's transfer interface is small; it can only transfer files whose size does not exceed $L$.\n2. The USB drive's capacity is small; it can hold a total size of at most $S$.\n\nHowever, you have many files to back up, so you can only back up some of them.\n\nTo decide which files to back up, you assign each file a value $V_i$, and you want the total value of the backed-up files to be at least $p$.\n\nSoon you realize this is impossible with the current interface, because yyy2015c01's transfer interface is too small. You have to spend money to buy a larger interface (a larger interface allows transferring larger files, but it costs more).\n\nNote: Your files cannot be split (you can only transfer an entire file and store it in the USB drive).\nThe total size of the files you put in the USB drive cannot exceed the drive's capacity.\n\nNow the question: When the total value of the files in the USB drive is not less than $p$, what is the minimum required interface size?", "inputFormat": "The first line contains three positive integers $n, p, S$, representing the number of files, the desired minimum total value $p$, and the USB drive capacity $S$.\n\nThe next $n$ lines each contain two positive integers $W_i, V_i$, representing the size and value of the $i$-th file.", "outputFormat": "Output a single positive integer representing the minimum required interface size.\n\nIf there is no solution, output `No Solution!`.", "hint": "Constraints: $1 \\le n, W_i, S \\le 10^3$, $1 \\leq V_i \\leq 10^6$, $1 \\leq p \\leq 10^9$.\n\nThe testdata is small; please do not overcomplicate.\n\nSample explanation 1: Buy an interface of size $2$, and put items $1$ and $2$ into the $\\text{U}$ drive.\n\nSample explanation 2: Buy an interface of size $500$.\n\nSample explanation 3: You could have bought an interface of size $2$, but the USB drive capacity cannot hold enough files.\n\nIf there is any oversight in the testdata, please contact the problem setter [a710128](https://www.luogu.com.cn/user/2573).\n\nSalute to the protagonist of this problem, classmate yyy2015c01!\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "yyy2015c01 的 U 盘", "background": "在 2020 年的某一天，我们的 yyy2015c01 买了个高端 U 盘。\n", "description": "你找 yyy2015c01 借到了这个高端的 U 盘，拷贝一些重要资料，但是你发现这个 U 盘有一些问题：\n\n1. 这个 U 盘的传输接口很小，只能传输大小不超过 $L$ 的文件。\n2. 这个 U 盘容量很小，一共只能装不超过 $S$ 的文件。\n\n但是你要备份的资料却有很多，你只能备份其中的一部分。\n\n为了选择要备份哪些文件，你给所有文件设置了一个价值 $V_i$，你希望备份的文件总价值不小于 $p$。\n\n但是很快你发现这是不可能的，因为 yyy2015c01 的传输接口太小了，你只有花钱买一个更大的接口（更大的接口意味着可以传输更大的文件，但是购买它会花费更多的钱）。\n\n注意：你的文件不能被分割（你只能把一个文件整个的传输进去，并储存在U盘中）,\n\n你放在 U 盘中文件的总大小不能超过 U 盘容量。\n\n现在问题来了：你想知道，在满足 U 盘中文件价值之和**不小于** $p$ 时，最小需要多大的接口。", "inputFormat": "第 $1$ 行，三个正整数 $n,p,S$ 分别表示文件总数，希望最小价值 $p$ ，U 盘大小。\n\n接下来 $n$ 行，每行两个正整数 $W_{i},V_{i}$，表示第 $i$ 个文件的大小和价值。", "outputFormat": "输出一个正整数表示最小需要的接口大小。\n\n如果无解输出 `No Solution!`。", "hint": "$1 \\le n, W_i, S \\le 10^3$，$1 \\leq V_i \\leq 10^6$，$1 \\leq p \\leq 10^9$。\n\n数据较小，请勿乱搞。\n\n样例解释 $1$：买一个大小为 $2$ 接口，把物品 $1$ 、$2$ 放进$\\text{U}$盘。\n\n样例解释 $2$：买一个大小为 $500$ 的接口。\n\n样例解释 $3$：本来可以买大小为 $2$ 的接口，可是 U 盘容量放不下足够的文件。\n\n如果数据出现疏漏，请联系出题人 [a710128](https://www.luogu.com.cn/user/2573)\n\n向本题主人公 yyy2015c01 同学致敬！", "locale": "zh-CN"}}}
{"pid": "P2371", "type": "P", "difficulty": 5, "samples": [["2 5 10\n3 5\n", "5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "集训队互测", "最短路"], "title": "[国家集训队] 墨墨的等式", "background": "", "description": "墨墨突然对等式很感兴趣，他正在研究 $\\sum_{i=1}^n a_ix_i=b$ 存在非负整数解的条件，他要求你编写一个程序，给定 $n, a_{1\\dots n}, l, r$，求出有多少 $b\\in[l,r]$ 可以使等式存在非负整数解。", "inputFormat": "第一行三个整数 $n,l,r$。\n\n第二行 $n$ 个整数 $a_{1\\dots n}$。\n", "outputFormat": "一行一个整数，表示有多少 $b\\in[l,r]$ 可以使等式存在非负整数解。\n", "hint": "对于 $20\\%$ 的数据，$n \\le 5$，$r \\le 10$。\n\n对于 $40\\%$ 的数据，$n \\le 10$，$r \\le 10^6$。\n\n对于 $100\\%$ 的数据，$n \\le 12$，$0 \\le a_i \\le 5\\times 10^5$，$1 \\le l \\le r \\le 10^{12}$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[CTT] Momo's Equation", "background": "", "description": "Momo has suddenly become interested in equations. He is studying the condition under which $\\sum_{i=1}^n a_ix_i=b$ has a non-negative integer solution. He asks you to write a program: given $n, a_{1\\dots n}, l, r$, find how many $b \\in [l, r]$ make the equation have a non-negative integer solution.", "inputFormat": "The first line contains three integers $n,l,r$.\nThe second line contains $n$ integers $a_{1\\dots n}$.", "outputFormat": "Output one integer on a single line, indicating how many $b \\in [l, r]$ make the equation have a non-negative integer solution.", "hint": "For $20\\%$ of the testdata, $n \\le 5$, $r \\le 10$.\nFor $40\\%$ of the testdata, $n \\le 10$, $r \\le 10^6$.\nFor $100\\%$ of the testdata, $n \\le 12$, $0 \\le a_i \\le 5\\times 10^5$, $1 \\le l \\le r \\le 10^{12}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[国家集训队] 墨墨的等式", "background": "", "description": "墨墨突然对等式很感兴趣，他正在研究 $\\sum_{i=1}^n a_ix_i=b$ 存在非负整数解的条件，他要求你编写一个程序，给定 $n, a_{1\\dots n}, l, r$，求出有多少 $b\\in[l,r]$ 可以使等式存在非负整数解。", "inputFormat": "第一行三个整数 $n,l,r$。\n\n第二行 $n$ 个整数 $a_{1\\dots n}$。\n", "outputFormat": "一行一个整数，表示有多少 $b\\in[l,r]$ 可以使等式存在非负整数解。\n", "hint": "对于 $20\\%$ 的数据，$n \\le 5$，$r \\le 10$。\n\n对于 $40\\%$ 的数据，$n \\le 10$，$r \\le 10^6$。\n\n对于 $100\\%$ 的数据，$n \\le 12$，$0 \\le a_i \\le 5\\times 10^5$，$1 \\le l \\le r \\le 10^{12}$。\n", "locale": "zh-CN"}}}
{"pid": "P2372", "type": "P", "difficulty": 2, "samples": [["2 2 2 2 \nXX\nXX", "8"], ["6 4 2 3 \n.XXX\n.XXX\n.XXX\n...X\n..X.\nX...", "18"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2015", "洛谷原创", "洛谷月赛"], "title": "yyy2015c01挑战算周长", "background": "yyy2015c01 快速的解决了问题，受到邻居们的赞许，高兴的回到家，把糖给了妈妈，吃了香喷喷的午饭，又睡了一个甜甜的午觉，感觉人生真美好。下午爸爸回到家，听说了 yyy2015c01 帮老师及邻居们解决了难题，准备带她去游乐场玩她平日最喜欢玩的跳舞机作为奖励，yyy2015c01 听了，兴奋的一蹦三尺高。", "description": "游乐场里人头攒动，每台跳舞机前都围满了人，怎么办呢？人这么多，想玩上估计要等好久了，yyy2015c01 左顾右盼，突然发现一台跳舞机前面没人， “哈哈，被我发现一台没人的，赶快去……”，结果到了面前才发现这台新机器的玩法与众不同，脚下的格子随机位置显示出很多的 `X`，踩到一个格子，就要根据规则先算出它对应的周长，然后把正确周长输入机器，最后的胜利者还可以获得游乐城的免费游戏券一张，yyy2015c01 心动了，小朋友们，你们可以帮助 yyy2015c01 顺利拿到游戏券么？\n\n游戏规则如下：\n\n新跳舞机踏板上有许多要分析的目标，由脚踩确定一个目标。目标边界的周长是一个有用的测量参数。编程任务：确定选中目标的周长。新跳舞机的踏板是一个矩形的网格，里面点 `.`，表示空的地方；有大写字母 `X`，表示目标的一部分。\n\n方格中的一个 `X` 是指一个完整的网格方形区域，包括其边界和目标本身。网格中心的 `X` 与其边界上 $8$ 个方向的 `X` 都是相邻的。任何两个相邻的 `X`，其网格方形区域在边界或拐角处是重叠的，所以它们的网格方形区域是相邻的。一个目标是由一系列相邻 `X` 的网格方形区域连接起来构成的。在网格 $1$ 中，一个目标填充了全部网格；在网格 $2$ 中有两个目标，其中一个目标只占左下角的一个网格方形区域，其余的 `X` 属于另一个目标。\n\nyyy2015c01 总是能踩到一个 `X`，以选中包含该 `X` 的目标，记录脚踩时的坐标。行列号是从左上角开始，从 $1$ 开始编号的。一个有用的统计参数是目标的周长。 假定每个 `X` 的每条边上有一个方形的单元。\n\n目标中不会包含任何完全封闭的孔。\n", "inputFormat": "共 $M+1$ 行，第一行为四个正整数 $M,N,X,Y$（中间用空格隔开），表示网格的大小为 $M$ 行，$N$ 列，且踩中网格的第 $X$ 行第 $Y$ 列方格。后面就是 $M$ 行，由字符 `.` 和 `X` 构成。", "outputFormat": "共一行，表示选中目标的周长。\n", "hint": "$1\\leq M\\leq 20$，$1\\leq N\\leq 20$，$1\\leq X\\leq M$，$1\\leq Y\\leq N$。\n", "locale": "zh-CN", "translations": {"en": {"title": "yyy2015c01 Challenge: Compute the Perimeter", "background": "yyy2015c01 quickly solved the problem and was praised by the neighbors. She happily went home, gave the candy to her mother, ate a delicious lunch, and took a sweet nap, feeling that life was wonderful. In the afternoon, her father came home and, upon hearing that yyy2015c01 had helped the teacher and neighbors with difficult problems, planned to take her to the amusement park to play her favorite dance machine as a reward. Hearing this, yyy2015c01 jumped for joy.", "description": "The amusement park was crowded, and every dance machine was surrounded by people. What to do? With so many people, it would take a long time to play. yyy2015c01 looked around and suddenly found a dance machine with no one in front of it. “Haha, I found one with no queue, hurry up...”. But when she got there, she realized this new machine played differently: many `X` marks appeared at random positions on the floor grid. When you step on a cell, you must first compute the perimeter of the target it belongs to according to the rules, then input the correct perimeter into the machine. The final winner can receive a free game coupon from the amusement park. yyy2015c01 was tempted. Kids, can you help yyy2015c01 win the coupon?\n\nGame rules:\n\nThere are many targets on the new dance machine’s rectangular grid. A dot `.` means an empty place; an uppercase `X` means part of a target.\n\nEach `X` stands for one full grid-square region, including its boundary and the target itself. An `X` is adjacent to any `X` in any of the 8 directions (sharing an edge or a corner). Any two adjacent `X` squares have overlapping boundaries or corners, so their square regions are considered adjacent. A target is a connected component formed by a chain of adjacent `X` squares under 8-direction adjacency.\n\nyyy2015c01 always steps on an `X`, selecting the target that contains that `X`. Record the coordinates where she steps. Row and column indices start from the top-left corner, numbered from $ 1 $. A useful statistic is the target’s perimeter. Assume each `X` square has side length $ 1 $.\n\nThe target will not contain any completely enclosed holes.\n\n# Description", "inputFormat": "There are $ M+1 $ lines in total. The first line contains four positive integers $ M, N, X, Y $ (separated by spaces), meaning the grid has $ M $ rows and $ N $ columns, and the stepped-on cell is at row $ X $, column $ Y $. The next $ M $ lines consist of characters `.` and `X`.", "outputFormat": "Output a single line with the perimeter of the selected target.", "hint": "$ 1 \\leq M \\leq 20 $, $ 1 \\leq N \\leq 20 $, $ 1 \\leq X \\leq M $, $ 1 \\leq Y \\leq N $.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "yyy2015c01挑战算周长", "background": "yyy2015c01 快速的解决了问题，受到邻居们的赞许，高兴的回到家，把糖给了妈妈，吃了香喷喷的午饭，又睡了一个甜甜的午觉，感觉人生真美好。下午爸爸回到家，听说了 yyy2015c01 帮老师及邻居们解决了难题，准备带她去游乐场玩她平日最喜欢玩的跳舞机作为奖励，yyy2015c01 听了，兴奋的一蹦三尺高。", "description": "游乐场里人头攒动，每台跳舞机前都围满了人，怎么办呢？人这么多，想玩上估计要等好久了，yyy2015c01 左顾右盼，突然发现一台跳舞机前面没人， “哈哈，被我发现一台没人的，赶快去……”，结果到了面前才发现这台新机器的玩法与众不同，脚下的格子随机位置显示出很多的 `X`，踩到一个格子，就要根据规则先算出它对应的周长，然后把正确周长输入机器，最后的胜利者还可以获得游乐城的免费游戏券一张，yyy2015c01 心动了，小朋友们，你们可以帮助 yyy2015c01 顺利拿到游戏券么？\n\n游戏规则如下：\n\n新跳舞机踏板上有许多要分析的目标，由脚踩确定一个目标。目标边界的周长是一个有用的测量参数。编程任务：确定选中目标的周长。新跳舞机的踏板是一个矩形的网格，里面点 `.`，表示空的地方；有大写字母 `X`，表示目标的一部分。\n\n方格中的一个 `X` 是指一个完整的网格方形区域，包括其边界和目标本身。网格中心的 `X` 与其边界上 $8$ 个方向的 `X` 都是相邻的。任何两个相邻的 `X`，其网格方形区域在边界或拐角处是重叠的，所以它们的网格方形区域是相邻的。一个目标是由一系列相邻 `X` 的网格方形区域连接起来构成的。在网格 $1$ 中，一个目标填充了全部网格；在网格 $2$ 中有两个目标，其中一个目标只占左下角的一个网格方形区域，其余的 `X` 属于另一个目标。\n\nyyy2015c01 总是能踩到一个 `X`，以选中包含该 `X` 的目标，记录脚踩时的坐标。行列号是从左上角开始，从 $1$ 开始编号的。一个有用的统计参数是目标的周长。 假定每个 `X` 的每条边上有一个方形的单元。\n\n目标中不会包含任何完全封闭的孔。\n", "inputFormat": "共 $M+1$ 行，第一行为四个正整数 $M,N,X,Y$（中间用空格隔开），表示网格的大小为 $M$ 行，$N$ 列，且踩中网格的第 $X$ 行第 $Y$ 列方格。后面就是 $M$ 行，由字符 `.` 和 `X` 构成。", "outputFormat": "共一行，表示选中目标的周长。\n", "hint": "$1\\leq M\\leq 20$，$1\\leq N\\leq 20$，$1\\leq X\\leq M$，$1\\leq Y\\leq N$。\n", "locale": "zh-CN"}}}
{"pid": "P2373", "type": "P", "difficulty": 2, "samples": [["2\nFAC1 (N=233, M=65 'A', A=0)\nmain ()\n", "1\n"], ["2\nfac1 (N=250)\nFAC1 (a=987)\n", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串", "搜索", "2015", "洛谷原创", "洛谷月赛"], "title": "yyy2015c01 的 IDE 之 Call Stack", "background": "在 2020 年的某一天，我们的 yyy2015c01 同学想要开发一套 IDE。\n", "description": "作为他开发团队中的一员，你不幸地 yyy2015c01 被选入了 Debugger 的开发组。\n\nyyy2015c01 设想的 Debugger 由几部分组成，其中的一个小组件就是 Call Stack——中文称之为 “调用栈”。\n\n由于 IDE 目前还是内测版，开发组需要先编一个能识别参数表的 Call Stack 来看看效果如何。这个任务交由你来完成。\n\n开发组假想的 Call Stack 能实现识别 `int` 和 `char` 参数表，以辨别出不同的函数，规则是：\n\n```\nint fac1(int n);\n```\n\n和\n\n```\nint fac1(char n);\n```\n\n是两个不同的函数；但\n\n```\nint Fac1(int n,int m);\n```\n\n和\n\n```\nint FAC1(int x,int y);\n```\n\n被认为是相同的函数。也就是说，这个 Call Stack 认的不是参数名，而是其类型和忽略大小写的函数名。\n\n注意：`int main()` 可能会出现，也可能不出现；无论它有没有出现，都不能将其算入函数中。\n\n请你编写一个 Call Stack，并在所有函数调用完后输出这个程序一共有多少个不完全相同的函数（保证程序中的每个函数至少调用一次）。\n", "inputFormat": "输入共 $n + 1$ 行：第一行是一个正整数 $n$，表示共有 $n$ 次调用操作；第 $2 \\sim n+1$ 行每行是一条函数调用信息（严格按照样例输入的格式），保证不会有多余的其他字符。\n", "outputFormat": "输出共一行：一个正整数 $m$，表示在上述调用中共有多少个参数表不完全相同的函数。\n", "hint": "每个函数的参数最多有 $10$ 个，每行的输入数据长度均不超过 $255$。\n\n向本题主人公 yyy2015c01 同学致敬！\n", "locale": "zh-CN", "translations": {"en": {"title": "yyy2015c01's IDE: Call Stack", "background": "On a day in 2020, our classmate yyy2015c01 wanted to develop an IDE.", "description": "As a member of his development team, you were unfortunately selected by yyy2015c01 to join the Debugger group.\n\nThe Debugger envisioned by yyy2015c01 consists of several parts, and one small component is the Call Stack—called “调用栈” in Chinese.\n\nSince the IDE is still in internal testing, the team first needs a Call Stack that can recognize parameter lists to see how it performs. This task is assigned to you.\n\nThe imagined Call Stack can distinguish functions by recognizing parameter lists of `int` and `char`. The rules are:\n\n```\nint fac1(int n);\n```\n\nand\n\n```\nint fac1(char n);\n```\n\nare two different functions; but\n\n```\nint Fac1(int n,int m);\n```\n\nand\n\n```\nint FAC1(int x,int y);\n```\n\nare considered the same function. In other words, this Call Stack does not care about parameter names; it distinguishes by parameter types and a case-insensitive function name.\n\nNote: `int main()` may appear or may not appear; regardless of whether it appears, it must not be counted as a function.\n\nPlease implement a Call Stack and, after all function calls complete, output how many distinct functions the program has (it is guaranteed that every function in the program is called at least once).", "inputFormat": "The input has $n + 1$ lines: the first line is a positive integer $n$, indicating there are $n$ call operations; lines $2 \\sim n+1$ each contain one function call (strictly following the sample input format), and there will be no extra characters.", "outputFormat": "Output one line: a positive integer $m$, indicating how many functions with distinct parameter lists appear in the above calls.", "hint": "Each function has at most $10$ parameters, and the length of each input line does not exceed $255$.\n\nSalute to our protagonist, classmate yyy2015c01!\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "yyy2015c01 的 IDE 之 Call Stack", "background": "在 2020 年的某一天，我们的 yyy2015c01 同学想要开发一套 IDE。\n", "description": "作为他开发团队中的一员，你不幸地 yyy2015c01 被选入了 Debugger 的开发组。\n\nyyy2015c01 设想的 Debugger 由几部分组成，其中的一个小组件就是 Call Stack——中文称之为 “调用栈”。\n\n由于 IDE 目前还是内测版，开发组需要先编一个能识别参数表的 Call Stack 来看看效果如何。这个任务交由你来完成。\n\n开发组假想的 Call Stack 能实现识别 `int` 和 `char` 参数表，以辨别出不同的函数，规则是：\n\n```\nint fac1(int n);\n```\n\n和\n\n```\nint fac1(char n);\n```\n\n是两个不同的函数；但\n\n```\nint Fac1(int n,int m);\n```\n\n和\n\n```\nint FAC1(int x,int y);\n```\n\n被认为是相同的函数。也就是说，这个 Call Stack 认的不是参数名，而是其类型和忽略大小写的函数名。\n\n注意：`int main()` 可能会出现，也可能不出现；无论它有没有出现，都不能将其算入函数中。\n\n请你编写一个 Call Stack，并在所有函数调用完后输出这个程序一共有多少个不完全相同的函数（保证程序中的每个函数至少调用一次）。\n", "inputFormat": "输入共 $n + 1$ 行：第一行是一个正整数 $n$，表示共有 $n$ 次调用操作；第 $2 \\sim n+1$ 行每行是一条函数调用信息（严格按照样例输入的格式），保证不会有多余的其他字符。\n", "outputFormat": "输出共一行：一个正整数 $m$，表示在上述调用中共有多少个参数表不完全相同的函数。\n", "hint": "每个函数的参数最多有 $10$ 个，每行的输入数据长度均不超过 $255$。\n\n向本题主人公 yyy2015c01 同学致敬！\n", "locale": "zh-CN"}}}
{"pid": "P2374", "type": "P", "difficulty": 2, "samples": [["3 2 4\n2 3 2\n1 5\n9 8 7 4\n", "257"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": [], "title": "搬运工", "background": "陈老师喜欢网购书籍，经常一次购它个百八十本，然后拿来倒卖牟取暴利。", "description": "前些天，高一的新同学来了，他便像往常一样兜售他的书，经过一番口舌，同学们决定买他的书，但是陈老师桌上的书有三堆，每一堆都有厚厚的一叠，他要想个办法用最轻松的方式把书拿下来给同学们。但是你想逗一下陈老师，于是你设计一个最累的方式给他。若告诉你这三堆分别有 $i$，$j$，$k$ 本书，以及每堆从下到上书的质量，每次取书只能从任一堆的最上面取，那么请你设计一个方案，让他花最大的力气取下所有的书。\n\n显然，每次取书陈老师的体力消耗都会加大，这里用体力系数代表，取下第一本书时，体力系数为 $1$，第二本书时体力系数为 $2$，依次类推，而每次体力消耗值则为体力系数与书的重量之积。", "inputFormat": "第一行有三个整数，分别为三堆书的数量 $i$，$j$，$k$。\n\n第二行至第四行分别为每堆由下至上的书本重量。", "outputFormat": "输出最累方式的体力消耗总值。\n", "hint": "#### 数据规模与约定\n\n+ 对于 $50\\%$ 的数据有 $0\\le i,j,k\\lt10$。\n+ 对于 $100\\%$ 的数据有 $0\\le i,j,k\\lt100$。\n\n最后输出的体力消耗总值在 C++ int 范围内。", "locale": "zh-CN", "translations": {"en": {"title": "Porter", "background": "Mr. Chen likes buying books online. He often purchases a hundred or so at a time and then resells them for profit.", "description": "A few days ago, the new Grade 10 students arrived. As usual, he tried to sell his books to them. After some persuasion, the students decided to buy his books. However, there are three stacks of books on Mr. Chen’s desk, each forming a thick pile. He wants to find the easiest way to hand the books to the students, but you want to tease him by designing the most exhausting way. You are given that the three stacks have $i$，$j$，$k$ books, respectively, as well as the weight of each book in each stack from bottom to top. Each time he takes a book, he can only take the top book from any one stack. Please design an order that makes him expend the maximum effort to take down all the books.\n\nObviously, his effort increases with each book he takes. We define an effort coefficient: when taking the first book, the coefficient is $1$; for the second book, it is $2$; and so on. The effort cost for each operation equals the product of the current effort coefficient and the book’s weight.", "inputFormat": "The first line contains three integers, the numbers of books in the three stacks $i$，$j$，$k$.\n\nThe second to fourth lines give the weights of the books in each stack, listed from bottom to top.", "outputFormat": "Output the total effort cost under the most exhausting order.", "hint": "#### Constraints\n\n- For $50\\%$ of the testdata, $0\\le i,j,k\\lt10$。\n- For $100\\%$ of the testdata, $0\\le i,j,k\\lt100$。\n\nThe final total effort cost fits in the C++ int range.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "搬运工", "background": "陈老师喜欢网购书籍，经常一次购它个百八十本，然后拿来倒卖牟取暴利。", "description": "前些天，高一的新同学来了，他便像往常一样兜售他的书，经过一番口舌，同学们决定买他的书，但是陈老师桌上的书有三堆，每一堆都有厚厚的一叠，他要想个办法用最轻松的方式把书拿下来给同学们。但是你想逗一下陈老师，于是你设计一个最累的方式给他。若告诉你这三堆分别有 $i$，$j$，$k$ 本书，以及每堆从下到上书的质量，每次取书只能从任一堆的最上面取，那么请你设计一个方案，让他花最大的力气取下所有的书。\n\n显然，每次取书陈老师的体力消耗都会加大，这里用体力系数代表，取下第一本书时，体力系数为 $1$，第二本书时体力系数为 $2$，依次类推，而每次体力消耗值则为体力系数与书的重量之积。", "inputFormat": "第一行有三个整数，分别为三堆书的数量 $i$，$j$，$k$。\n\n第二行至第四行分别为每堆由下至上的书本重量。", "outputFormat": "输出最累方式的体力消耗总值。\n", "hint": "#### 数据规模与约定\n\n+ 对于 $50\\%$ 的数据有 $0\\le i,j,k\\lt10$。\n+ 对于 $100\\%$ 的数据有 $0\\le i,j,k\\lt100$。\n\n最后输出的体力消耗总值在 C++ int 范围内。", "locale": "zh-CN"}}}
