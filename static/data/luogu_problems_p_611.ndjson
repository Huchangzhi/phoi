{"pid": "P13395", "type": "P", "difficulty": 4, "samples": [["2\n5\n6", "Case #1: 5\nCase #2: 8"]], "limits": {"time": [3000, 6000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2010", "Google Code Jam"], "title": "[GCJ 2010 #1B] Your Rank is Pure", "background": "", "description": "> Pontius: You know, I like this number 127, I don't know why.    \n> Woland: Well, that is an object so pure. You know the prime numbers.    \n> Pontius: Surely I do. Those are the objects possessed by our ancient masters hundreds of years ago. Oh, yes, why then? 127 is indeed a prime number as I was told.     \n> Woland: Not... only... that. 127 is the 31st prime number; then, 31 is itself a prime, it is the 11th; and 11 is the 5th; 5 is the 3rd; 3, you know, is the second; and finally 2 is the 1st.    \n> Pontius: Heh, that is indeed... purely prime.\n\nThe game can be played on any subset $s$ of positive integers. A number in $s$ is considered pure with respect to $s$ if, starting from it, you can continue taking its rank in $s$, and get a number that is also in $s$, until in finite steps you hit the number 1, which is not in $s$.\n\nWhen $n$ is given, in how many ways you can pick $s$, a subset of $\\{2, 3, ..., n\\}$, so that $n$ is pure, with respect to $s$? The answer might be a big number, you need to output it modulo 100003.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each contains a single integer $n$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the answer as described above.", "hint": "**Limits**\n\n- $T \\leqslant 100.$\n\n**Small dataset (14 Pts, Test set 1 - Visible)**\n\n- Time limit: ~~30~~ 3 seconds.\n- $2 \\leqslant n \\leqslant 25.$\n\n**Large dataset (30 Pts, Test set 2 - Hidden)**\n\n- Time limit: ~~60~~ 6 seconds.\n- $2 \\leqslant n \\leqslant 500.$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2010 #1B] Your Rank is Pure", "background": "", "description": "> Pontius: You know, I like this number 127, I don't know why.    \n> Woland: Well, that is an object so pure. You know the prime numbers.    \n> Pontius: Surely I do. Those are the objects possessed by our ancient masters hundreds of years ago. Oh, yes, why then? 127 is indeed a prime number as I was told.     \n> Woland: Not... only... that. 127 is the 31st prime number; then, 31 is itself a prime, it is the 11th; and 11 is the 5th; 5 is the 3rd; 3, you know, is the second; and finally 2 is the 1st.    \n> Pontius: Heh, that is indeed... purely prime.\n\nThe game can be played on any subset $s$ of positive integers. A number in $s$ is considered pure with respect to $s$ if, starting from it, you can continue taking its rank in $s$, and get a number that is also in $s$, until in finite steps you hit the number 1, which is not in $s$.\n\nWhen $n$ is given, in how many ways you can pick $s$, a subset of $\\{2, 3, ..., n\\}$, so that $n$ is pure, with respect to $s$? The answer might be a big number, you need to output it modulo 100003.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each contains a single integer $n$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the answer as described above.", "hint": "**Limits**\n\n- $T \\leqslant 100.$\n\n**Small dataset (14 Pts, Test set 1 - Visible)**\n\n- Time limit: ~~30~~ 3 seconds.\n- $2 \\leqslant n \\leqslant 25.$\n\n**Large dataset (30 Pts, Test set 2 - Hidden)**\n\n- Time limit: ~~60~~ 6 seconds.\n- $2 \\leqslant n \\leqslant 500.$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2010 #1B] Your Rank is Pure", "background": null, "description": "> Pontius：你知道吗，我喜欢这个数字 127，我也不知道为什么。  \n> Woland：嗯，那是一个非常纯粹的对象。你知道质数吧。  \n> Pontius：当然知道。那些是我们古代大师几百年前拥有的对象。哦，是的，为什么呢？127 的确是个质数，就像我被告知的那样。  \n> Woland：不仅如此。127 是第 31 个质数；然后，31 本身也是质数，它是第 11 个；11 是第 5 个；5 是第 3 个；3，你知道，是第二个；最后 2 是第一个。  \n> Pontius：呵，这确实……纯粹的质数。\n\n这个游戏可以在任意正整数子集 $s$ 上进行。对于集合 $s$，如果一个数在 $s$ 中，从它开始，不断取它在 $s$ 中的排名，并且得到的数也在 $s$ 中，直到有限步后得到数字 1（1 不在 $s$ 中），那么这个数被称为相对于 $s$ 是纯粹的。\n\n给定 $n$，有多少种方式可以选择 $s$，$s$ 是 $\\{2, 3, ..., n\\}$ 的一个子集，使得 $n$ 相对于 $s$ 是纯粹的？答案可能很大，你需要输出答案对 100003 取模的结果。", "inputFormat": "输入的第一行是测试用例数 $T$。接下来有 $T$ 行，每行包含一个整数 $n$。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #$x$: $y$\"，其中 $x$ 是测试编号（从 1 开始），$y$ 是如上所述的答案。", "hint": "**数据范围**\n\n- $T \\leqslant 100$。\n\n**小数据集（14 分，测试点 1 - 可见）**\n\n- 时间限制：3 秒。\n- $2 \\leqslant n \\leqslant 25$。\n\n**大数据集（30 分，测试点 2 - 隐藏）**\n\n- 时间限制：6 秒。\n- $2 \\leqslant n \\leqslant 500$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13396", "type": "P", "difficulty": 2, "samples": [["2\n3\n1 10\n5 5\n7 7\n2\n1 1\n2 2", "Case #1: 2\nCase #2: 0"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["模拟", "2010", "Google Code Jam"], "title": "[GCJ 2010 #1C] Rope Intranet", "background": "", "description": "A company is located in two very tall buildings. The company intranet connecting the buildings consists of many wires, each connecting a window on the first building to a window on the second building.\n\nYou are looking at those buildings from the side, so that one of the buildings is to the left and one is to the right. The windows on the left building are seen as points on its right wall, and the windows on the right building are seen as points on its left wall. Wires are straight segments connecting a window on the left building to a window on the right building.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/c9k75j11.png)\n\nYou've noticed that no two wires share an endpoint (in other words, there's at most one wire going out of each window). However, from your viewpoint, some of the wires intersect midway. You've also noticed that exactly two wires meet at each intersection point.\n\nOn the above picture, the intersection points are the black circles, while the windows are the white circles.\n\nHow many intersection points do you see?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each case begins with a line containing an integer $N$, denoting the number of wires you see.\n\nThe next $N$ lines each describe one wire with two integers $A_i$ and $B_i$. These describe the windows that this wire connects: $A_i$ is the height of the window on the left building, and $B_i$ is the height of the window on the right building.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the number of intersection points you see.", "hint": "**Limits**\n\n- $1 \\leqslant T \\leqslant 15.$\n- $1 \\leqslant A_i \\leqslant 10^4.$\n- $1 \\leqslant B_i \\leqslant 10^4.$\n- Within each test case, all $A_i$ are different.\n- Within each test case, all $B_i$ are different.\n- No three wires intersect at the same point.\n\n**Small dataset (9 Pts, Test set 1 - Visible)**\n\n- $1 \\leqslant N \\leqslant 2.$\n\n**Large dataset (13 Pts, Test set 2 - Hidden)**\n\n- $1 \\leqslant N \\leqslant 1000.$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2010 #1C] Rope Intranet", "background": "", "description": "A company is located in two very tall buildings. The company intranet connecting the buildings consists of many wires, each connecting a window on the first building to a window on the second building.\n\nYou are looking at those buildings from the side, so that one of the buildings is to the left and one is to the right. The windows on the left building are seen as points on its right wall, and the windows on the right building are seen as points on its left wall. Wires are straight segments connecting a window on the left building to a window on the right building.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/c9k75j11.png)\n\nYou've noticed that no two wires share an endpoint (in other words, there's at most one wire going out of each window). However, from your viewpoint, some of the wires intersect midway. You've also noticed that exactly two wires meet at each intersection point.\n\nOn the above picture, the intersection points are the black circles, while the windows are the white circles.\n\nHow many intersection points do you see?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each case begins with a line containing an integer $N$, denoting the number of wires you see.\n\nThe next $N$ lines each describe one wire with two integers $A_i$ and $B_i$. These describe the windows that this wire connects: $A_i$ is the height of the window on the left building, and $B_i$ is the height of the window on the right building.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the number of intersection points you see.", "hint": "**Limits**\n\n- $1 \\leqslant T \\leqslant 15.$\n- $1 \\leqslant A_i \\leqslant 10^4.$\n- $1 \\leqslant B_i \\leqslant 10^4.$\n- Within each test case, all $A_i$ are different.\n- Within each test case, all $B_i$ are different.\n- No three wires intersect at the same point.\n\n**Small dataset (9 Pts, Test set 1 - Visible)**\n\n- $1 \\leqslant N \\leqslant 2.$\n\n**Large dataset (13 Pts, Test set 2 - Hidden)**\n\n- $1 \\leqslant N \\leqslant 1000.$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2010 #1C] Rope Intranet", "background": null, "description": "一家公司位于两座非常高的建筑物中。连接这两座建筑的公司内部网由许多电线组成，每根电线连接左侧建筑的一扇窗户和右侧建筑的一扇窗户。\n\n你正从侧面观察这些建筑，因此一座建筑在左边，另一座在右边。左侧建筑的窗户在其右墙上显示为一些点，右侧建筑的窗户在其左墙上显示为一些点。电线是连接左侧建筑窗户和右侧建筑窗户的直线段。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/c9k75j11.png)\n\n你注意到没有两根电线共用一个端点（换句话说，每个窗户最多只连接一根电线）。然而，从你的视角来看，有些电线在中途相交。你还注意到，每个交点恰好有两根电线相交。\n\n在上图中，交点是黑色圆点，窗户是白色圆点。\n\n你能看到多少个交点？", "inputFormat": "输入的第一行是测试用例的数量 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行为一个整数 $N$，表示你看到的电线数量。\n\n接下来的 $N$ 行，每行包含两个整数 $A_i$ 和 $B_i$，表示一根电线连接的窗户：$A_i$ 是左侧建筑上窗户的高度，$B_i$ 是右侧建筑上窗户的高度。", "outputFormat": "对于每组测试数据，输出一行，格式为 “Case #$x$: $y$”，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是你看到的交点数量。", "hint": "**数据范围**\n\n- $1 \\leqslant T \\leqslant 15$。\n- $1 \\leqslant A_i \\leqslant 10^4$。\n- $1 \\leqslant B_i \\leqslant 10^4$。\n- 每组测试数据中，所有 $A_i$ 互不相同。\n- 每组测试数据中，所有 $B_i$ 互不相同。\n- 不存在三根电线在同一点相交。\n\n**小数据范围（9 分，测试点 1 - 可见）**\n\n- $1 \\leqslant N \\leqslant 2$。\n\n**大数据范围（13 分，测试点 2 - 隐藏）**\n\n- $1 \\leqslant N \\leqslant 1000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13397", "type": "P", "difficulty": 3, "samples": [["4\n50 700 2\n19 57 3\n1 1000 2\n24 97 2", "Case #1: 2\nCase #2: 0\nCase #3: 4\nCase #4: 2"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["数学", "2010", "倍增", "Google Code Jam"], "title": "[GCJ 2010 #1C] Load Testing", "background": "", "description": "Now that you have won Code Jam and been hired by Google as a software engineer, you have been assigned to work on their wildly popular programming contest website.\n\nGoogle is expecting a lot of participants ($P$) in Code Jam next year, and they want to make sure that the site can support that many people at the same time. During Code Jam 2010 you learned that the site could support at least $L$ people at a time without any errors, but you also know that the site can't yet support $P$ people.\n\nTo determine how many more machines you'll need, you want to know within a factor of $C$ how many people the site can support. This means that there is an integer $a$ such that you know the site can support $a$ people, but you know the site can't support $a \\times C$ people.\n\nYou can run a series of *load tests*, each of which will determine whether the site can support at least $X$ people for some integer value of $X$ that you choose. If you pick an optimal strategy, choosing what tests to run based on the results of previous tests, how many load tests do you need in the worst case?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow, each of which contains space-separated integers $L$, $P$ and $C$ in that order.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the number of load tests you need to run in the worst case before knowing within a factor of $C$ how many people the site can support.", "hint": "**Sample Explanation**\n\nIn Case #2, we already know that the site can support between $19$ and $57$ people. Since those are a factor of $3$ apart, we don't need to do any testing.\n\nIn Case #4, we can test $48$; but if the site can support $48$ people, we need more testing, because $48 \\times 2 < 97$. We could test $49$; but if the site can't support $49$ people, we need more testing, because $24 \\times 2 < 49$. So we need two tests.\n\n**Limits**\n\n- $1 \\leqslant T \\leqslant 1000.$\n- $2 \\leqslant C \\leqslant 10.$\n- $L$, $P$ and $C$ are all integers.\n\n**Small dataset (14 Pts, Test set 1 - Visible)**\n\n- $1 \\leqslant L < P \\leqslant 10^3.$\n\n**Large dataset (22 Pts, Test set 2 - Hidden)**\n\n- $1 \\leqslant L < P \\leqslant 10^9.$\n\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2010 #1C] Load Testing", "background": "", "description": "Now that you have won Code Jam and been hired by Google as a software engineer, you have been assigned to work on their wildly popular programming contest website.\n\nGoogle is expecting a lot of participants ($P$) in Code Jam next year, and they want to make sure that the site can support that many people at the same time. During Code Jam 2010 you learned that the site could support at least $L$ people at a time without any errors, but you also know that the site can't yet support $P$ people.\n\nTo determine how many more machines you'll need, you want to know within a factor of $C$ how many people the site can support. This means that there is an integer $a$ such that you know the site can support $a$ people, but you know the site can't support $a \\times C$ people.\n\nYou can run a series of *load tests*, each of which will determine whether the site can support at least $X$ people for some integer value of $X$ that you choose. If you pick an optimal strategy, choosing what tests to run based on the results of previous tests, how many load tests do you need in the worst case?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow, each of which contains space-separated integers $L$, $P$ and $C$ in that order.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the number of load tests you need to run in the worst case before knowing within a factor of $C$ how many people the site can support.", "hint": "**Sample Explanation**\n\nIn Case #2, we already know that the site can support between $19$ and $57$ people. Since those are a factor of $3$ apart, we don't need to do any testing.\n\nIn Case #4, we can test $48$; but if the site can support $48$ people, we need more testing, because $48 \\times 2 < 97$. We could test $49$; but if the site can't support $49$ people, we need more testing, because $24 \\times 2 < 49$. So we need two tests.\n\n**Limits**\n\n- $1 \\leqslant T \\leqslant 1000.$\n- $2 \\leqslant C \\leqslant 10.$\n- $L$, $P$ and $C$ are all integers.\n\n**Small dataset (14 Pts, Test set 1 - Visible)**\n\n- $1 \\leqslant L < P \\leqslant 10^3.$\n\n**Large dataset (22 Pts, Test set 2 - Hidden)**\n\n- $1 \\leqslant L < P \\leqslant 10^9.$\n\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2010 #1C] Load Testing", "background": null, "description": "现在你已经赢得了 Code Jam 并被 Google 雇佣为软件工程师，你被分配到他们极受欢迎的编程竞赛网站工作。\n\nGoogle 预计明年会有很多参赛者（$P$）参加 Code Jam，他们希望确保网站能够同时支持这么多人。在 2010 年的 Code Jam 期间，你了解到该网站至少可以同时支持 $L$ 个人而不会出错，但你也知道目前网站还无法支持 $P$ 个人。\n\n为了确定还需要增加多少台机器，你希望知道网站最多能支持多少人，误差在 $C$ 倍以内。也就是说，存在一个整数 $a$，你知道网站可以支持 $a$ 个人，但不能支持 $a \\times C$ 个人。\n\n你可以进行一系列的“负载测试”，每次测试可以确定网站是否能支持至少 $X$ 个人（$X$ 是你选择的整数）。如果你采用最优策略，根据前面测试的结果选择后续的测试，那么在最坏情况下，你需要进行多少次负载测试，才能确定网站最多能支持多少人，误差在 $C$ 倍以内？", "inputFormat": "输入的第一行包含测试用例的数量 $T$。接下来的 $T$ 行，每行包含用空格分隔的三个整数 $L$、$P$ 和 $C$。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #$x$: $y$\"，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是在最坏情况下你需要进行的负载测试次数，才能确定网站最多能支持多少人，误差在 $C$ 倍以内。", "hint": "**样例解释**\n\n在第 2 个测试用例中，我们已经知道网站可以支持 $19$ 到 $57$ 个人。由于这两个数相差 $3$ 倍，因此我们不需要进行任何测试。\n\n在第 4 个测试用例中，我们可以测试 $48$；但如果网站能支持 $48$ 个人，还需要继续测试，因为 $48 \\times 2 < 97$。我们可以测试 $49$；但如果网站不能支持 $49$ 个人，还需要继续测试，因为 $24 \\times 2 < 49$。所以我们需要进行两次测试。\n\n**数据范围**\n\n- $1 \\leqslant T \\leqslant 1000$。\n- $2 \\leqslant C \\leqslant 10$。\n- $L$、$P$ 和 $C$ 均为整数。\n\n**小数据集（14 分，测试集 1 - 可见）**\n\n- $1 \\leqslant L < P \\leqslant 10^3$。\n\n**大数据集（22 分，测试集 2 - 隐藏）**\n\n- $1 \\leqslant L < P \\leqslant 10^9$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13398", "type": "P", "difficulty": 5, "samples": [["4\n15 20\n55555\nFFAAA\n2AAD5\nD552A\n2AAD5\nD542A\n4AD4D\nB52B2\n52AAD\nAD552\nAA52D\nAAAAA\n5AA55\nA55AA\n5AA55\n4 4\n0\n0\n0\n0\n4 4\n3\n3\nC\nC\n4 4\n6\n9\n9\n6", "Case #1: 5\n6 2\n4 3\n3 7\n2 15\n1 57\nCase #2: 1\n1 16\nCase #3: 2\n2 1\n1 12\nCase #4: 1\n2 4"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2010", "堆", "Google Code Jam"], "title": "[GCJ 2010 #1C] Making Chess Boards", "background": "", "description": "The chess board industry has fallen on hard times and needs your help. It is a little-known fact that chess boards are made from the bark of the extremely rare Croatian Chess Board tree, (Biggus Mobydiccus). The bark of that tree is stripped and unwrapped into a huge rectangular sheet of chess board material. The rectangle is a grid of black and white squares.\n\nYour task is to make as many large square chess boards as possible. A chess board is a piece of the bark that is a square, with sides parallel to the sides of the bark rectangle, with cells colored in the pattern of a chess board (no two cells of the same color can share an edge).\n\nEach time you cut out a chess board, you must choose the largest possible chess board left in the sheet. If there are several such boards, pick the topmost one. If there is still a tie, pick the leftmost one. Continue cutting out chess boards until there is no bark left. You may need to go as far as cutting out 1-by-1 mini chess boards.\n\nHere is an example showing the bark of a Chess Board tree and the first few chess boards that will be cut out of it.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9yfw8ou6.png)\n\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each one starts with a line containing the dimensions of the bark grid, $M$ and $N$. $N$ will always be a multiple of $4$. The next $M$ lines will each contain an $(N/4)$-character hexadecimal integer, representing a row of the bark grid. The binary representation of these integers will give you a strings of $N$ bits, one for each row. Zeros represent black squares; ones represent white squares of the grid. The rows are given in the input from top to bottom. In each row, the most-significant bit of the hexadecimal integer corresponds to the leftmost cell in that row.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $K$\", where $x$ is the case number (starting from $1$) and $K$ is the number of different chess board sizes that you can cut out by following the procedure described above. The next $K$ lines should contain two integers each -- the size of the chess board (from largest to smallest) and the number of chess boards of that size that you can cut out.", "hint": "**Sample Explanation**\n\nThe first example test case represents the image above.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$;\n- $N$ will be divisible by 4;\n- Each hexadecimal integer will contain exactly $N/4$ characters.\n- Only the characters 0-9 and A-F will be used.\n\n**Small dataset (18 Pts, Test set 1 - Visible)**\n\n- $1 \\leq M \\leq 32$;\n- $1 \\leq N \\leq 32$.\n\n**Large dataset (24 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq M \\leq 512$;\n- $1 \\leq N \\leq 512$;\n- The input file will be at most 200kB in size.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2010 #1C] Making Chess Boards", "background": "", "description": "The chess board industry has fallen on hard times and needs your help. It is a little-known fact that chess boards are made from the bark of the extremely rare Croatian Chess Board tree, (Biggus Mobydiccus). The bark of that tree is stripped and unwrapped into a huge rectangular sheet of chess board material. The rectangle is a grid of black and white squares.\n\nYour task is to make as many large square chess boards as possible. A chess board is a piece of the bark that is a square, with sides parallel to the sides of the bark rectangle, with cells colored in the pattern of a chess board (no two cells of the same color can share an edge).\n\nEach time you cut out a chess board, you must choose the largest possible chess board left in the sheet. If there are several such boards, pick the topmost one. If there is still a tie, pick the leftmost one. Continue cutting out chess boards until there is no bark left. You may need to go as far as cutting out 1-by-1 mini chess boards.\n\nHere is an example showing the bark of a Chess Board tree and the first few chess boards that will be cut out of it.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9yfw8ou6.png)\n\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each one starts with a line containing the dimensions of the bark grid, $M$ and $N$. $N$ will always be a multiple of $4$. The next $M$ lines will each contain an $(N/4)$-character hexadecimal integer, representing a row of the bark grid. The binary representation of these integers will give you a strings of $N$ bits, one for each row. Zeros represent black squares; ones represent white squares of the grid. The rows are given in the input from top to bottom. In each row, the most-significant bit of the hexadecimal integer corresponds to the leftmost cell in that row.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $K$\", where $x$ is the case number (starting from $1$) and $K$ is the number of different chess board sizes that you can cut out by following the procedure described above. The next $K$ lines should contain two integers each -- the size of the chess board (from largest to smallest) and the number of chess boards of that size that you can cut out.", "hint": "**Sample Explanation**\n\nThe first example test case represents the image above.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$;\n- $N$ will be divisible by 4;\n- Each hexadecimal integer will contain exactly $N/4$ characters.\n- Only the characters 0-9 and A-F will be used.\n\n**Small dataset (18 Pts, Test set 1 - Visible)**\n\n- $1 \\leq M \\leq 32$;\n- $1 \\leq N \\leq 32$.\n\n**Large dataset (24 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq M \\leq 512$;\n- $1 \\leq N \\leq 512$;\n- The input file will be at most 200kB in size.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2010 #1C] Making Chess Boards", "background": null, "description": "国际象棋棋盘产业陷入了困境，需要你的帮助。鲜为人知的是，国际象棋棋盘是用极为稀有的克罗地亚棋盘树（Biggus Mobydiccus）的树皮制成的。这种树的树皮被剥下并展开成一个巨大的矩形棋盘材料。这个矩形是一个由黑白方格组成的网格。\n\n你的任务是尽可能多地制作大型正方形棋盘。一个棋盘是树皮上的一个正方形区域，边与树皮矩形的边平行，且格子的颜色必须呈现棋盘的交错模式（即没有两个相同颜色的格子共边）。\n\n每次你切割棋盘时，必须选择当前树皮上能切出的最大的棋盘。如果有多个同样大小的棋盘，选择最上面的那个。如果仍有多个，选择最左边的那个。不断切割，直到树皮上没有可以切出的棋盘为止。你可能需要切割出 $1 \\times 1$ 的迷你棋盘。\n\n下面是一个展示棋盘树树皮以及前几个被切割出的棋盘的例子。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9yfw8ou6.png)", "inputFormat": "输入的第一行是测试用例的数量 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行为树皮网格的尺寸 $M$ 和 $N$。$N$ 总是 $4$ 的倍数。接下来的 $M$ 行，每行包含一个长度为 $N/4$ 的十六进制整数，表示树皮网格的一行。将这些整数转为二进制后即可得到每一行的 $N$ 位，$0$ 表示黑格，$1$ 表示白格。输入中的行从上到下排列。在每一行中，十六进制整数的最高有效位对应该行最左侧的格子。", "outputFormat": "对于每个测试用例，输出一行，格式为 “Case #$x$: $K$”，其中 $x$ 是测试用例编号（从 $1$ 开始），$K$ 是按照题目描述的切割过程可以切出的不同棋盘尺寸的数量。接下来的 $K$ 行，每行包含两个整数，分别表示棋盘的尺寸（从大到小排列）以及可以切出的该尺寸棋盘的数量。", "hint": "**样例解释**\n\n第一个样例测试用例对应上图。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$；\n- $N$ 一定是 $4$ 的倍数；\n- 每个十六进制整数正好有 $N/4$ 个字符；\n- 只会使用字符 $0$-$9$ 和 $A$-$F$。\n\n**小数据范围（18 分，测试点 1 - 可见）**\n\n- $1 \\leq M \\leq 32$；\n- $1 \\leq N \\leq 32$。\n\n**大数据范围（24 分，测试点 2 - 隐藏）**\n\n- $1 \\leq M \\leq 512$；\n- $1 \\leq N \\leq 512$；\n- 输入文件大小不超过 200kB。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13399", "type": "P", "difficulty": 3, "samples": [["4\n1\n0\n2\n 1\n2 2\n 1\n2\n 1\n1 2\n 1\n3\n  1\n 6 3\n9 5 5\n 6 3\n  1", "Case #1: 0\nCase #2: 0\nCase #3: 5\nCase #4: 7"]], "limits": {"time": [3000, 6000], "memory": [1048576, 1048576]}, "tags": ["模拟", "2010", "枚举", "Google Code Jam"], "title": "[GCJ 2010 #2] Elegant Diamond", "background": "", "description": "The king has hired you to make him an elegant diamond. An elegant diamond is a two-dimensional object made out of digits that's symmetric about a horizontal and a vertical axis. For example, the following four shapes are elegant diamonds:\n\n```\n   2       8      3     7\n  3 3     8 8    2 2\n 4 1 4     8      3\n  3 3 \n   2\n```\n\nThese three shapes are diamonds, but are not elegant:\n\n```\n  2       1        3\n 1 1     1 2      1 1\n  1     1 1 1    3 1 3\n         2 1      1 1\n          1        2\n```\n\nThese three shapes are not diamonds:\n\n```\n  1     2     8   8\n 1 1   222      0\n        2     00000\n```\n\nThe king will start by giving you a diamond, which may not be elegant. Your job is to make it elegant by enhancing it, adding digits on to make a bigger diamond. Because you don't want to spend too much money, you want to do it with as little cost as possible.\n\n### Definitions\n\nA diamond of size $k$ is $2k-1$ lines of digits, 0-9, separated by single spaces, organized in the following way:\n\n* Line $i$ ($1 \\leq i \\leq k$) contains $k-i$ spaces, then $i$ digits separated by single spaces.\n* Line $i$ ($k < i < 2k$) contains $i-k$ spaces, then $2k-i$ digits separated by single spaces.\n\nAn elegant diamond of size $k$ is a diamond of size $k$ with the following two symmetry properties:\n\n* Horizontal symmetry: Let $c_i$ be the number of digits on line $i$. The $j^{\\text{th}}$ digit on line $i$ (where $j=1$ for the first digit) must be the same as the $c_i+1-j^{\\text{th}}$ digit.\n* Vertical symmetry: The $j^{\\text{th}}$ digit on line $i$ (where $i=1$ for the first line) must be the same as the $j^{\\text{th}}$ digit on line $2k-i$.\n\nA diamond of size $k$ can be enhanced by adding digits to it. The result of enhancing a diamond of size $k$ has the following properties:\n\n* The result is a diamond of size $\\geq k$.\n* The original diamond is part of the result. In other words, there exist some $X$ and some $Y$ such that, for all values of $i$ and $j$ such that the $j^{\\text{th}}$ character of the $i^{\\text{th}}$ line of the original is a digit (as opposed to a space), the $j+X^{\\text{th}}$ character on the $i+Y^{\\text{th}}$ line of the result is also a digit and it's the same as the $j^{\\text{th}}$ character on the $i^{\\text{th}}$ line of the original.\n\nThe cost of enhancing a diamond is equal to the number of digits in the result of the enhancement, minus the number of digits in the original diamond.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case consists of a single integer $k$ in a line on its own, followed by a diamond of size $k$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the minimum cost required to enhance the given diamond into an elegant diamond. If the diamond is already elegant, $y=0$.", "hint": "**Sample Explanation**\n\nThere are four cases. The first two cases start as elegant diamonds of size 1 and 2, respectively, and don't need to be enhanced; so the cost is 0. The third case can be enhanced to look like:\n```\n  3\n 1 1\n1 2 1\n 1 1\n  3\n```\nThere are several possible enhancements, but this is one with the lowest possible cost, which is 5. In the fourth case we can enhance the diamond into the following elegant diamond:\n```\n   9\n  1 1\n 6 3 6\n9 5 5 9\n 6 3 6\n  1 1\n   9\n```\n...for a cost of 7.\n\n**Limits**\n\n- $1 \\leq T \\leq 100.$\n\n**Small dataset (4 Pts, Test set 1 - Visible)**\n\n- Time limit: ~~30~~ 3 seconds.\n- $1 \\leq k \\leq 10.$\n\n**Large dataset (8 Pts, Test set 2 - Hidden)**\n\n- Time limit: ~~60~~ 6 seconds.\n- $1 \\leq k \\leq 51.$", "locale": "en", "translations": {"en": {"title": "[GCJ 2010 #2] Elegant Diamond", "background": "", "description": "The king has hired you to make him an elegant diamond. An elegant diamond is a two-dimensional object made out of digits that's symmetric about a horizontal and a vertical axis. For example, the following four shapes are elegant diamonds:\n\n```\n   2       8      3     7\n  3 3     8 8    2 2\n 4 1 4     8      3\n  3 3 \n   2\n```\n\nThese three shapes are diamonds, but are not elegant:\n\n```\n  2       1        3\n 1 1     1 2      1 1\n  1     1 1 1    3 1 3\n         2 1      1 1\n          1        2\n```\n\nThese three shapes are not diamonds:\n\n```\n  1     2     8   8\n 1 1   222      0\n        2     00000\n```\n\nThe king will start by giving you a diamond, which may not be elegant. Your job is to make it elegant by enhancing it, adding digits on to make a bigger diamond. Because you don't want to spend too much money, you want to do it with as little cost as possible.\n\n### Definitions\n\nA diamond of size $k$ is $2k-1$ lines of digits, 0-9, separated by single spaces, organized in the following way:\n\n* Line $i$ ($1 \\leq i \\leq k$) contains $k-i$ spaces, then $i$ digits separated by single spaces.\n* Line $i$ ($k < i < 2k$) contains $i-k$ spaces, then $2k-i$ digits separated by single spaces.\n\nAn elegant diamond of size $k$ is a diamond of size $k$ with the following two symmetry properties:\n\n* Horizontal symmetry: Let $c_i$ be the number of digits on line $i$. The $j^{\\text{th}}$ digit on line $i$ (where $j=1$ for the first digit) must be the same as the $c_i+1-j^{\\text{th}}$ digit.\n* Vertical symmetry: The $j^{\\text{th}}$ digit on line $i$ (where $i=1$ for the first line) must be the same as the $j^{\\text{th}}$ digit on line $2k-i$.\n\nA diamond of size $k$ can be enhanced by adding digits to it. The result of enhancing a diamond of size $k$ has the following properties:\n\n* The result is a diamond of size $\\geq k$.\n* The original diamond is part of the result. In other words, there exist some $X$ and some $Y$ such that, for all values of $i$ and $j$ such that the $j^{\\text{th}}$ character of the $i^{\\text{th}}$ line of the original is a digit (as opposed to a space), the $j+X^{\\text{th}}$ character on the $i+Y^{\\text{th}}$ line of the result is also a digit and it's the same as the $j^{\\text{th}}$ character on the $i^{\\text{th}}$ line of the original.\n\nThe cost of enhancing a diamond is equal to the number of digits in the result of the enhancement, minus the number of digits in the original diamond.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case consists of a single integer $k$ in a line on its own, followed by a diamond of size $k$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the minimum cost required to enhance the given diamond into an elegant diamond. If the diamond is already elegant, $y=0$.", "hint": "**Sample Explanation**\n\nThere are four cases. The first two cases start as elegant diamonds of size 1 and 2, respectively, and don't need to be enhanced; so the cost is 0. The third case can be enhanced to look like:\n```\n  3\n 1 1\n1 2 1\n 1 1\n  3\n```\nThere are several possible enhancements, but this is one with the lowest possible cost, which is 5. In the fourth case we can enhance the diamond into the following elegant diamond:\n```\n   9\n  1 1\n 6 3 6\n9 5 5 9\n 6 3 6\n  1 1\n   9\n```\n...for a cost of 7.\n\n**Limits**\n\n- $1 \\leq T \\leq 100.$\n\n**Small dataset (4 Pts, Test set 1 - Visible)**\n\n- Time limit: ~~30~~ 3 seconds.\n- $1 \\leq k \\leq 10.$\n\n**Large dataset (8 Pts, Test set 2 - Hidden)**\n\n- Time limit: ~~60~~ 6 seconds.\n- $1 \\leq k \\leq 51.$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2010 #2] Elegant Diamond", "background": null, "description": "国王雇佣你为他制作一个优雅的菱形。优雅的菱形是由数字组成的二维图形，关于水平轴和垂直轴对称。例如，以下四个图形是优雅的菱形：\n\n```\n   2       8      3     7\n  3 3     8 8    2 2\n 4 1 4     8      3\n  3 3 \n   2\n```\n\n下面这三个图形是菱形，但不是优雅的：\n\n```\n  2       1        3\n 1 1     1 2      1 1\n  1     1 1 1    3 1 3\n         2 1      1 1\n          1        2\n```\n\n下面这三个图形不是菱形：\n\n```\n  1     2     8   8\n 1 1   222      0\n        2     00000\n```\n\n国王会先给你一个菱形，这个菱形可能不是优雅的。你的任务是通过扩展它、添加数字，使其变成优雅的菱形。由于你不想花太多钱，你希望以尽可能小的代价完成这项工作。\n\n### 定义\n\n大小为 $k$ 的菱形由 $2k-1$ 行数字（0-9）组成，数字之间用单个空格分隔，排列方式如下：\n\n- 第 $i$ 行（$1 \\leq i \\leq k$）前有 $k-i$ 个空格，接着是 $i$ 个数字，数字之间用单个空格分隔。\n- 第 $i$ 行（$k < i < 2k$）前有 $i-k$ 个空格，接着是 $2k-i$ 个数字，数字之间用单个空格分隔。\n\n大小为 $k$ 的优雅菱形是满足以下两个对称性质的菱形：\n\n- 水平对称：设第 $i$ 行有 $c_i$ 个数字，第 $i$ 行第 $j$ 个数字（$j=1$ 表示第一个数字）必须等于第 $c_i+1-j$ 个数字。\n- 垂直对称：第 $i$ 行第 $j$ 个数字（$i=1$ 表示第一行）必须等于第 $2k-i$ 行第 $j$ 个数字。\n\n可以通过添加数字来扩展一个大小为 $k$ 的菱形。扩展后的菱形需满足以下条件：\n\n- 扩展结果是一个大小 $\\geq k$ 的菱形。\n- 原始菱形是扩展结果的一部分。也就是说，存在某个 $X$ 和某个 $Y$，使得对于原始菱形中所有第 $i$ 行第 $j$ 个为数字（非空格）的字符，扩展结果中第 $i+Y$ 行第 $j+X$ 个字符也是数字，且与原始菱形对应位置的数字相同。\n\n扩展菱形的代价等于扩展后菱形中的数字总数减去原始菱形中的数字总数。", "inputFormat": "第一行输入测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据第一行为一个整数 $k$，接下来为一个大小为 $k$ 的菱形。", "outputFormat": "对于每组测试数据，输出一行，格式为 \"Case #$x$: $y$\"，其中 $x$ 为测试编号（从 1 开始），$y$ 为将给定菱形扩展为优雅菱形所需的最小代价。如果菱形已经是优雅的，则 $y=0$。", "hint": "**样例解释**\n\n共有四组数据。前两组数据本身就是大小为 1 和 2 的优雅菱形，无需扩展，代价为 0。第三组可以扩展为如下优雅菱形：\n```\n  3\n 1 1\n1 2 1\n 1 1\n  3\n```\n有多种扩展方式，但这是代价最小的一种，代价为 5。第四组可以扩展为如下优雅菱形：\n```\n   9\n  1 1\n 6 3 6\n9 5 5 9\n 6 3 6\n  1 1\n   9\n```\n……代价为 7。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n\n**小数据范围（4 分，测试点 1 - 可见）**\n\n- 时间限制：3 秒。\n- $1 \\leq k \\leq 10$。\n\n**大数据范围（8 分，测试点 2 - 隐藏）**\n\n- 时间限制：6 秒。\n- $1 \\leq k \\leq 51$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13400", "type": "P", "difficulty": 4, "samples": [["2\n2\n1 1 0 1\n1 1\n1\n3\n1 2 3 2 1 0 1 3\n100 150 50 90\n500 400\n800", "Case #1: 2\nCase #2: 1350"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["2010", "树形 DP", "Google Code Jam"], "title": "[GCJ 2010 #2] World Cup 2010", "background": "", "description": "After four years, it is the World Cup time again and Varva is on his way to South Africa, just in time to catch the second stage of the tournament.\n\nIn the second stage (also called the knockout stage), each match always has a winner; the winning team proceeds to the next round while the losing team is eliminated from the tournament. There are $2^P$ teams competing in this stage, identified with integers from 0 to $2^P - 1$. The knockout stage consists of P rounds. In each round, each remaining team plays exactly one match. The exact pairs and the order of matches are determined by successively choosing two remaining teams with lowest identifiers and pairing them in a match. After all matches in one round are finished, the next round starts.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rvv11b9u.png)\n\nIn order to help him decide which matches to see, Varva has compiled a list of constraints based on how much he likes a particular team. Specifically, for each team $i$ he is willing to miss at most $M[i]$ matches the team plays in the tournament.\n\nVarva needs to buy a set of tickets that will guarantee that his preferences are satisfied, regardless of how the matches turn out. Other than that, he just wants to spend as little money as possible. Your goal is to find the minimal amount of money he needs to spend on the tickets.\n\nTickets for the matches need to be purchased in advance (before the tournament starts) and the ticket price for each match is known. Note that, in the small input, ticket prices for all matches will be equal, while in the large input, they may be different.\n\n### Example\n\nA sample tournament schedule along with the ticket prices is given in the figure above. Suppose that the constraints are given by the array $M = \\{1, 2, 3, 2, 1, 0, 1, 2, 3\\}$, the optimal strategy is as follows: Since we can't miss any games of team $5$, we'll need to spend $50, 400$, and $800$ to buy tickets to all the matches team $5$ may play in. Now, the constraints for the other teams are also satisfied by these tickets, except for team $0$. The best option to fix this is to buy the ticket for team $0$'s first round match, spending another $100$, bringing the total to $1350$.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each case starts with a line containing a single integer $P$. The next line contains $2^P$ integers -- the constraints $M[0], ..., M[2^P-1]$.\n\nThe following block of $P$ lines contains the ticket prices for all matches: the first line of the block contains $2^{P-1}$ integers -- ticket prices for first round matches, the second line of the block contains $2^{P-2}$ integers -- ticket prices for second round matches, etc. The last of the $P$ lines contains a single integer -- ticket price for the final match of the World Cup. The prices are listed in the order the matches are played.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $x$ is the case number (starting from 1) and $y$ is the minimal amount of money Varva needs to spend on tickets as described above.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 50$\n- $1 \\leq P \\leq 10$\n- Each element of $M$ is an integer between 0 and $P$, inclusive.\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- All the prices are equal to 1.\n\n**Large dataset (15 Pts,Test set 2 - Hidden)**\n\n- All the prices are integers between 0 and 100000, inclusive.", "locale": "en", "translations": {"en": {"title": "[GCJ 2010 #2] World Cup 2010", "background": "", "description": "After four years, it is the World Cup time again and Varva is on his way to South Africa, just in time to catch the second stage of the tournament.\n\nIn the second stage (also called the knockout stage), each match always has a winner; the winning team proceeds to the next round while the losing team is eliminated from the tournament. There are $2^P$ teams competing in this stage, identified with integers from 0 to $2^P - 1$. The knockout stage consists of P rounds. In each round, each remaining team plays exactly one match. The exact pairs and the order of matches are determined by successively choosing two remaining teams with lowest identifiers and pairing them in a match. After all matches in one round are finished, the next round starts.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rvv11b9u.png)\n\nIn order to help him decide which matches to see, Varva has compiled a list of constraints based on how much he likes a particular team. Specifically, for each team $i$ he is willing to miss at most $M[i]$ matches the team plays in the tournament.\n\nVarva needs to buy a set of tickets that will guarantee that his preferences are satisfied, regardless of how the matches turn out. Other than that, he just wants to spend as little money as possible. Your goal is to find the minimal amount of money he needs to spend on the tickets.\n\nTickets for the matches need to be purchased in advance (before the tournament starts) and the ticket price for each match is known. Note that, in the small input, ticket prices for all matches will be equal, while in the large input, they may be different.\n\n### Example\n\nA sample tournament schedule along with the ticket prices is given in the figure above. Suppose that the constraints are given by the array $M = \\{1, 2, 3, 2, 1, 0, 1, 2, 3\\}$, the optimal strategy is as follows: Since we can't miss any games of team $5$, we'll need to spend $50, 400$, and $800$ to buy tickets to all the matches team $5$ may play in. Now, the constraints for the other teams are also satisfied by these tickets, except for team $0$. The best option to fix this is to buy the ticket for team $0$'s first round match, spending another $100$, bringing the total to $1350$.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each case starts with a line containing a single integer $P$. The next line contains $2^P$ integers -- the constraints $M[0], ..., M[2^P-1]$.\n\nThe following block of $P$ lines contains the ticket prices for all matches: the first line of the block contains $2^{P-1}$ integers -- ticket prices for first round matches, the second line of the block contains $2^{P-2}$ integers -- ticket prices for second round matches, etc. The last of the $P$ lines contains a single integer -- ticket price for the final match of the World Cup. The prices are listed in the order the matches are played.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $x$ is the case number (starting from 1) and $y$ is the minimal amount of money Varva needs to spend on tickets as described above.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 50$\n- $1 \\leq P \\leq 10$\n- Each element of $M$ is an integer between 0 and $P$, inclusive.\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- All the prices are equal to 1.\n\n**Large dataset (15 Pts,Test set 2 - Hidden)**\n\n- All the prices are integers between 0 and 100000, inclusive.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2010 #2] World Cup 2010", "background": null, "description": "四年一度的世界杯又来了，Varva 正赶往南非，正好赶上淘汰赛阶段。\n\n在淘汰赛阶段，每场比赛必定有一个胜者；获胜的队伍晋级下一轮，失败的队伍则被淘汰。共有 $2^P$ 支队伍参加本阶段比赛，编号为 $0$ 到 $2^P - 1$。淘汰赛共进行 $P$ 轮。每一轮中，每支剩余的队伍都恰好参加一场比赛。每轮的对阵顺序是：依次选择剩余队伍中编号最小的两支队伍，将它们配对进行比赛。每一轮所有比赛结束后，下一轮开始。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rvv11b9u.png)\n\n为了决定看哪些比赛，Varva 根据自己对各支队伍的喜好，列出了一些限制条件。具体来说，对于每支队伍 $i$，他最多愿意错过 $M[i]$ 场该队参加的比赛。\n\nVarva 需要提前购买一组门票，以确保无论比赛结果如何，他的偏好都能被满足。同时，他希望花的钱尽可能少。你的目标是计算他至少需要花多少钱买门票。\n\n门票需要在比赛开始前提前购买，每场比赛的门票价格已知。注意，在小数据中，所有比赛的门票价格相同；而在大数据中，价格可能不同。\n\n### 示例\n\n上图给出了一个比赛日程及门票价格。假设限制条件为 $M = \\{1, 2, 3, 2, 1, 0, 1, 2, 3\\}$，最优策略如下：由于不能错过队伍 $5$ 的任何比赛，需要花 $50, 400, 800$ 买下队伍 $5$ 可能参加的所有比赛门票。此时，其他队伍的限制也都被满足，除了队伍 $0$。为满足队伍 $0$ 的限制，最好的办法是再买下队伍 $0$ 第一轮比赛的门票，需再花 $100$，总共花费 $1350$。", "inputFormat": "输入的第一行为测试用例数 $T$。接下来是 $T$ 组测试数据。每组测试数据第一行为一个整数 $P$。下一行为 $2^P$ 个整数，分别为 $M[0], ..., M[2^P-1]$。\n\n接下来的 $P$ 行给出了所有比赛的门票价格：第一行为第一轮的 $2^{P-1}$ 个比赛门票价格，第二行为第二轮的 $2^{P-2}$ 个比赛门票价格，依此类推。最后一行为决赛的门票价格。门票价格按照比赛进行的顺序给出。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #x: y\"，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为 Varva 至少需要花费的门票总金额。", "hint": "**数据范围**\n\n- $1 \\leq T \\leq 50$\n- $1 \\leq P \\leq 10$\n- $M$ 中每个元素为 $0$ 到 $P$ 之间的整数（包含 $0$ 和 $P$）\n\n**小数据（10 分，测试点 1 - 可见）**\n\n- 所有门票价格均为 1。\n\n**大数据（15 分，测试点 2 - 隐藏）**\n\n- 所有门票价格为 $0$ 到 $100000$ 之间的整数（包含 $0$ 和 $100000$）。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13401", "type": "P", "difficulty": 5, "samples": [["1\n3\n5 1 5 1\n2 2 4 2\n2 3 2 4", "Case #1: 6"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["图论", "2010", "广度优先搜索 BFS", "连通块", "Google Code Jam"], "title": "[GCJ 2010 #2] Bacteria", "background": "", "description": "A number of bacteria lie on an infinite grid of cells, each bacterium in its own cell.\n\nEach second, the following transformations occur (all simultaneously):\n\n1. If a bacterium has no neighbor to its north and no neighbor to its west, then it will die.\n2. If a cell has no bacterium in it, but there are bacteria in the neighboring cells to the north and to the west, then a new bacterium will be born in that cell.\n\nUpon examining the grid, you note that there are a positive, finite number of bacteria in one or more rectangular regions of cells.\n\nDetermine how many seconds will pass before all the bacteria die.\n\nHere is an example of a grid that starts with 6 cells containing bacteria, and takes 6 seconds for all the bacteria to die. '1's represent cells with bacteria, and '0's represent cells without bacteria.\n\n```\n000010\n011100\n010000\n010000\n000000\n\n000000\n001110\n011000\n010000\n000000\n\n000000\n000110\n001100\n011000\n000000\n\n000000\n000010\n000110\n001100\n000000\n\n000000\n000000\n000010\n000110\n000000\n\n000000\n000000\n000000\n000010\n000000\n\n000000\n000000\n000000\n000000\n000000\n```", "inputFormat": "The input consists of:\n\n- One line containing $C$, the number of test cases.\n\nThen for each test case:\n\n- One line containing $R$, the number of rectangles of cells that initially contain bacteria.\n- $R$ lines containing four space-separated integers $X_1$ $Y_1$ $X_2$ $Y_2$. This indicates that all the cells with X coordinate between $X_1$ and $X_2$, inclusive, and Y coordinate between $Y_1$ and $Y_2$, inclusive, contain bacteria.\n\nThe rectangles may overlap.\n\nNorth is in the direction of decreasing Y coordinate.\n\nWest is in the direction of decreasing X coordinate.", "outputFormat": "For each test case, output one line containing \"Case #$N$: $T$\", where $N$ is the case number (starting from 1), and $T$ is the number of seconds until the bacteria all die.", "hint": "**Limits**\n\n- $1 \\leq C \\leq 100.$\n\n**Small dataset (6 Pts, Test set 1 - Visible)**\n\n- $1 \\leq R \\leq 10$\n- $1 \\leq X_1 \\leq X_2 \\leq 100$\n- $1 \\leq Y_1 \\leq Y_2 \\leq 100$\n\n**Large dataset (25 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq R \\leq 1000$\n- $1 \\leq X_1 \\leq X_2 \\leq 1000000$\n- $1 \\leq Y_1 \\leq Y_2 \\leq 1000000$\n- The number of cells initially containing bacteria will be at most $1000000$.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2010 #2] Bacteria", "background": "", "description": "A number of bacteria lie on an infinite grid of cells, each bacterium in its own cell.\n\nEach second, the following transformations occur (all simultaneously):\n\n1. If a bacterium has no neighbor to its north and no neighbor to its west, then it will die.\n2. If a cell has no bacterium in it, but there are bacteria in the neighboring cells to the north and to the west, then a new bacterium will be born in that cell.\n\nUpon examining the grid, you note that there are a positive, finite number of bacteria in one or more rectangular regions of cells.\n\nDetermine how many seconds will pass before all the bacteria die.\n\nHere is an example of a grid that starts with 6 cells containing bacteria, and takes 6 seconds for all the bacteria to die. '1's represent cells with bacteria, and '0's represent cells without bacteria.\n\n```\n000010\n011100\n010000\n010000\n000000\n\n000000\n001110\n011000\n010000\n000000\n\n000000\n000110\n001100\n011000\n000000\n\n000000\n000010\n000110\n001100\n000000\n\n000000\n000000\n000010\n000110\n000000\n\n000000\n000000\n000000\n000010\n000000\n\n000000\n000000\n000000\n000000\n000000\n```", "inputFormat": "The input consists of:\n\n- One line containing $C$, the number of test cases.\n\nThen for each test case:\n\n- One line containing $R$, the number of rectangles of cells that initially contain bacteria.\n- $R$ lines containing four space-separated integers $X_1$ $Y_1$ $X_2$ $Y_2$. This indicates that all the cells with X coordinate between $X_1$ and $X_2$, inclusive, and Y coordinate between $Y_1$ and $Y_2$, inclusive, contain bacteria.\n\nThe rectangles may overlap.\n\nNorth is in the direction of decreasing Y coordinate.\n\nWest is in the direction of decreasing X coordinate.", "outputFormat": "For each test case, output one line containing \"Case #$N$: $T$\", where $N$ is the case number (starting from 1), and $T$ is the number of seconds until the bacteria all die.", "hint": "**Limits**\n\n- $1 \\leq C \\leq 100.$\n\n**Small dataset (6 Pts, Test set 1 - Visible)**\n\n- $1 \\leq R \\leq 10$\n- $1 \\leq X_1 \\leq X_2 \\leq 100$\n- $1 \\leq Y_1 \\leq Y_2 \\leq 100$\n\n**Large dataset (25 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq R \\leq 1000$\n- $1 \\leq X_1 \\leq X_2 \\leq 1000000$\n- $1 \\leq Y_1 \\leq Y_2 \\leq 1000000$\n- The number of cells initially containing bacteria will be at most $1000000$.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2010 #2] Bacteria", "background": null, "description": "有若干细菌分布在一个无限大的网格上，每个细菌占据一个单独的格子。\n\n每一秒，所有细菌会同时发生如下变化：\n\n1. 如果某个细菌的北侧和西侧都没有邻居细菌，则该细菌会死亡。\n2. 如果某个格子没有细菌，但其北侧和西侧的格子都有细菌，则该格子会诞生一个新的细菌。\n\n你观察到，网格上有若干个矩形区域，每个区域内有若干个细菌，且细菌的总数为正且有限。\n\n请你计算，经过多少秒后，所有细菌都会死亡。\n\n下面是一个初始有 6 个细菌的网格示例，全部细菌死亡共需 6 秒。'1' 表示有细菌的格子，'0' 表示无细菌的格子。\n\n```\n000010\n011100\n010000\n010000\n000000\n\n000000\n001110\n011000\n010000\n000000\n\n000000\n000110\n001100\n011000\n000000\n\n000000\n000010\n000110\n001100\n000000\n\n000000\n000000\n000010\n000110\n000000\n\n000000\n000000\n000000\n000010\n000000\n\n000000\n000000\n000000\n000000\n000000\n```", "inputFormat": "输入包含：\n\n- 第一行一个整数 $C$，表示测试用例的数量。\n\n接下来每个测试用例包含：\n\n- 一行一个整数 $R$，表示初始含有细菌的矩形区域数量。\n- 接下来 $R$ 行，每行四个用空格分隔的整数 $X_1$ $Y_1$ $X_2$ $Y_2$，表示 $X_1 \\leq X \\leq X_2$ 且 $Y_1 \\leq Y \\leq Y_2$ 的所有格子内都有细菌。\n\n这些矩形区域可能重叠。\n\n北侧指 $Y$ 坐标减小的方向，西侧指 $X$ 坐标减小的方向。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #$N$: $T$\"，其中 $N$ 表示测试用例编号（从 1 开始），$T$ 表示所有细菌全部死亡所需的秒数。", "hint": "**数据范围**\n\n- $1 \\leq C \\leq 100$\n\n**小数据（6 分，测试点 1 - 可见）**\n\n- $1 \\leq R \\leq 10$\n- $1 \\leq X_1 \\leq X_2 \\leq 100$\n- $1 \\leq Y_1 \\leq Y_2 \\leq 100$\n\n**大数据（25 分，测试点 2 - 隐藏）**\n\n- $1 \\leq R \\leq 1000$\n- $1 \\leq X_1 \\leq X_2 \\leq 1000000$\n- $1 \\leq Y_1 \\leq Y_2 \\leq 1000000$\n- 初始含有细菌的格子总数不超过 $1000000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13402", "type": "P", "difficulty": 6, "samples": [["3\n2 3\n0 20\n20 0\n-20 10\n40 20\n0 19\n4 2\n0 0\n100 100\n300 0\n380 90\n400 100\n1000 5\n3 1\n0 0\n10 10\n20 0\n10 5", "Case #1: 1264.9865911 1713.2741229 0.2939440\nCase #2: 1518.9063729 1193932.9692206\nCase #3: 0.0"]], "limits": {"time": [3000, 12000], "memory": [1048576, 1048576]}, "tags": ["计算几何", "2010", "Special Judge", "凸包", "Google Code Jam"], "title": "[GCJ 2010 #2] Grazing Google Goats", "background": "", "description": "Farmer John has recently acquired a nice herd of $N$ goats for his field. Each goat $i$ will be tied to a pole at some position $P_i$ using a rope of length $L_i$. This means that the goat will be able to travel anywhere in the field that is within distance $L_i$ of the point $P_i$, but nowhere else. (The field is large and flat, so you can think of it as an infinite two-dimensional plane.)\n\nFarmer John already has the pole positions picked out from his last herd of goats, but he has to choose the rope lengths. There are two factors that make this decision tricky:\n\n- The goats all need to be able to reach a single water bucket. Farmer John has not yet decided where to place this bucket. He has reduced the choice to a set of positions $\\{Q_1, Q_2, \\ldots, Q_M\\}$, but he is not sure which one to use.\n- The goats are ill-tempered, and when they get together, they sometimes get in noisy fights. For everyone's peace of mind, Farmer John wants to minimize the area $A$ that can be reached by all the goats.\n\nUnfortunately, Farmer John is not very good at geometry, and he needs your help for this part!\n\nFor each bucket position $Q_j$, you should choose rope lengths so as to minimize the area $A_j$ that can be reached by every goat when the bucket is located at position $Q_j$. You should then calculate each of these areas $A_j$.\n\n### Example\n\nIn the picture below, there are four blue points, corresponding to the pole positions: $P_1$, $P_2$, $P_3$, and $P_4$. There are also two red points, corresponding to the potential bucket positions: $Q_1$ and $Q_2$. You need to calculate $A_1$ and $A_2$, the areas of the two shaded regions.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mnv6gfis.png)", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with a line containing the integers $N$ and $M$.\n\nThe next $N$ lines contain the positions $P_1, P_2, \\ldots, P_N$, one per line. This is followed by $M$ lines, containing the positions $Q_1, Q_2, \\ldots, Q_M$, one per line.\n\nEach of these $N + M$ lines contains the corresponding position's $x$ and $y$ coordinates, separated by a single space.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $A_1$ $A_2$ ... $A_M$\", where $x$ is the case number (starting from 1), and $A_1$ $A_2$ ... $A_M$ are the values defined above. Answers with a relative or absolute error of at most $10^{-6}$ will be considered correct.", "hint": "**Limits**\n\n- All coordinates are integers between $-10,000$ and $10,000$.\n- The positions $P_1, P_2, \\ldots, P_N, Q_1, Q_2, \\ldots, Q_M$ are all distinct and no three are collinear.\n\n**Small dataset (7 Pts, Test set 1 - Visible)**\n\n- Time limit: ~~30~~ 3 seconds.\n- $1 \\leq T \\leq 100$.\n- $N = 2$.\n- $1 \\leq M \\leq 10$.\n\n**Large dataset (25 Pts, Test set 2 - Hidden)**\n\n- Time limit: ~~120~~ 12 seconds.\n- $1 \\leq T \\leq 10$.\n- $2 \\leq N \\leq 5,000$.\n- $1 \\leq M \\leq 1,000$.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2010 #2] Grazing Google Goats", "background": "", "description": "Farmer John has recently acquired a nice herd of $N$ goats for his field. Each goat $i$ will be tied to a pole at some position $P_i$ using a rope of length $L_i$. This means that the goat will be able to travel anywhere in the field that is within distance $L_i$ of the point $P_i$, but nowhere else. (The field is large and flat, so you can think of it as an infinite two-dimensional plane.)\n\nFarmer John already has the pole positions picked out from his last herd of goats, but he has to choose the rope lengths. There are two factors that make this decision tricky:\n\n- The goats all need to be able to reach a single water bucket. Farmer John has not yet decided where to place this bucket. He has reduced the choice to a set of positions $\\{Q_1, Q_2, \\ldots, Q_M\\}$, but he is not sure which one to use.\n- The goats are ill-tempered, and when they get together, they sometimes get in noisy fights. For everyone's peace of mind, Farmer John wants to minimize the area $A$ that can be reached by all the goats.\n\nUnfortunately, Farmer John is not very good at geometry, and he needs your help for this part!\n\nFor each bucket position $Q_j$, you should choose rope lengths so as to minimize the area $A_j$ that can be reached by every goat when the bucket is located at position $Q_j$. You should then calculate each of these areas $A_j$.\n\n### Example\n\nIn the picture below, there are four blue points, corresponding to the pole positions: $P_1$, $P_2$, $P_3$, and $P_4$. There are also two red points, corresponding to the potential bucket positions: $Q_1$ and $Q_2$. You need to calculate $A_1$ and $A_2$, the areas of the two shaded regions.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mnv6gfis.png)", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with a line containing the integers $N$ and $M$.\n\nThe next $N$ lines contain the positions $P_1, P_2, \\ldots, P_N$, one per line. This is followed by $M$ lines, containing the positions $Q_1, Q_2, \\ldots, Q_M$, one per line.\n\nEach of these $N + M$ lines contains the corresponding position's $x$ and $y$ coordinates, separated by a single space.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $A_1$ $A_2$ ... $A_M$\", where $x$ is the case number (starting from 1), and $A_1$ $A_2$ ... $A_M$ are the values defined above. Answers with a relative or absolute error of at most $10^{-6}$ will be considered correct.", "hint": "**Limits**\n\n- All coordinates are integers between $-10,000$ and $10,000$.\n- The positions $P_1, P_2, \\ldots, P_N, Q_1, Q_2, \\ldots, Q_M$ are all distinct and no three are collinear.\n\n**Small dataset (7 Pts, Test set 1 - Visible)**\n\n- Time limit: ~~30~~ 3 seconds.\n- $1 \\leq T \\leq 100$.\n- $N = 2$.\n- $1 \\leq M \\leq 10$.\n\n**Large dataset (25 Pts, Test set 2 - Hidden)**\n\n- Time limit: ~~120~~ 12 seconds.\n- $1 \\leq T \\leq 10$.\n- $2 \\leq N \\leq 5,000$.\n- $1 \\leq M \\leq 1,000$.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2010 #2] Grazing Google Goats", "background": null, "description": "约翰农夫最近为他的牧场添置了一群 $N$ 只山羊。每只山羊 $i$ 将被用一根长度为 $L_i$ 的绳子拴在某个位置 $P_i$ 的木桩上。这意味着山羊可以在距离 $P_i$ 不超过 $L_i$ 的范围内自由活动，但不能到达其他地方。（牧场很大且平坦，可以看作是一个无限的二维平面。）\n\n约翰农夫已经选好了木桩的位置，这些位置是他上一次养山羊时留下的，但他还需要决定每根绳子的长度。这个决定有两个难点：\n\n- 所有山羊都必须能够到达同一个水桶。约翰农夫还没有决定水桶的具体位置。他已经将选择范围缩小到一组位置 $\\{Q_1, Q_2, \\ldots, Q_M\\}$，但还不确定最终选哪个。\n- 山羊们脾气暴躁，聚在一起时有时会吵闹打架。为了大家的安宁，约翰农夫希望最小化所有山羊都能到达的区域面积 $A$。\n\n不幸的是，约翰农夫不擅长几何学，他需要你来帮忙解决这个问题！\n\n对于每个水桶位置 $Q_j$，你需要选择合适的绳子长度，使得当水桶放在 $Q_j$ 时，所有山羊都能到达水桶，并且所有山羊都能到达的区域面积 $A_j$ 最小。你需要计算出每个 $A_j$。\n\n### 示例\n\n下图中有四个蓝点，分别对应木桩位置 $P_1$、$P_2$、$P_3$ 和 $P_4$。还有两个红点，分别对应可能的水桶位置 $Q_1$ 和 $Q_2$。你需要计算 $A_1$ 和 $A_2$，即两块阴影区域的面积。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mnv6gfis.png)", "inputFormat": "第一行输入测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据第一行包含两个整数 $N$ 和 $M$。\n\n接下来的 $N$ 行，每行给出一个木桩位置 $P_1, P_2, \\ldots, P_N$。之后的 $M$ 行，每行给出一个水桶位置 $Q_1, Q_2, \\ldots, Q_M$。\n\n每个位置的坐标均为一行，包含该点的 $x$ 和 $y$ 坐标，用一个空格分隔。", "outputFormat": "对于每组测试数据，输出一行，格式为 “Case #$x$: $A_1$ $A_2$ ... $A_M$”，其中 $x$ 为测试用例编号（从 1 开始），$A_1$ $A_2$ ... $A_M$ 分别为上述定义的面积。只要答案的相对或绝对误差不超过 $10^{-6}$，即视为正确。", "hint": "**数据范围**\n\n- 所有坐标均为 $-10,000$ 到 $10,000$ 之间的整数。\n- 所有 $P_1, P_2, \\ldots, P_N, Q_1, Q_2, \\ldots, Q_M$ 位置均互不相同，且任意三点不共线。\n\n**小数据（7 分，测试点 1 - 可见）**\n\n- 时间限制：~~30~~ 3 秒。\n- $1 \\leq T \\leq 100$。\n- $N = 2$。\n- $1 \\leq M \\leq 10$。\n\n**大数据（25 分，测试点 2 - 隐藏）**\n\n- 时间限制：~~120~~ 12 秒。\n- $1 \\leq T \\leq 10$。\n- $2 \\leq N \\leq 5,000$。\n- $1 \\leq M \\leq 1,000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13403", "type": "P", "difficulty": 4, "samples": [["3\n2 10\n0 1 2 3 4 5 6 7 8 9\n3 1\n13\n1 5\n6 6 6 6 6", "Case #1: 10\nCase #2: I don't know.\nCase #3: 6"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["2010", "数论", "扩展欧几里德算法", "分类讨论", "Google Code Jam"], "title": "[GCJ 2010 #3] De-RNG-ed", "background": "", "description": "I want to make an online poker website. A very important component of such a system is the random number generator. It needs to be fast and random enough. Here is a compromise I came up with. I need a way to generate random numbers of length at most $D$. My plan is to select a prime number $P \\leq 10^D$. I am also going to pick non-negative integers $A$ and $B$. Finally, I'm going to pick an integer seed $S$ between $0$ and $P-1$, inclusive.\n\nTo output my sequence of pseudo-random numbers, I'm going to first output $S$ and then compute the new value of $S$ like this:\n\n$$S := (A\\times S + B) \\bmod P$$\n\nThen I will output the new value of $S$ as the next number in the sequence and update $S$ again by using the same formula. I can repeat this as many times as I want.\n\nDo you think that this is a good random number generator? Can you write a program that takes $K$ consecutive elements of a sequence that was generated by my random number generator, and prints the next element of the sequence?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each one starts with a line containing $D$ and $K$. The next line contains $K$ consecutive elements generated by a random number generator of the kind described above.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is either the next number in the sequence, or the string \"I don't know.\" if the answer is ambiguous.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq K \\leq 10$.\n- The $K$ integers will be consecutive elements of a sequence generated by a random number generator of the type described above.\n\n**Small dataset (4 Pts, Test set 1 - Visible)**\n\n- $1 \\leq D \\leq 4$.\n\n**Large dataset (10 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq D \\leq 6$.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2010 #3] De-RNG-ed", "background": "", "description": "I want to make an online poker website. A very important component of such a system is the random number generator. It needs to be fast and random enough. Here is a compromise I came up with. I need a way to generate random numbers of length at most $D$. My plan is to select a prime number $P \\leq 10^D$. I am also going to pick non-negative integers $A$ and $B$. Finally, I'm going to pick an integer seed $S$ between $0$ and $P-1$, inclusive.\n\nTo output my sequence of pseudo-random numbers, I'm going to first output $S$ and then compute the new value of $S$ like this:\n\n$$S := (A\\times S + B) \\bmod P$$\n\nThen I will output the new value of $S$ as the next number in the sequence and update $S$ again by using the same formula. I can repeat this as many times as I want.\n\nDo you think that this is a good random number generator? Can you write a program that takes $K$ consecutive elements of a sequence that was generated by my random number generator, and prints the next element of the sequence?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each one starts with a line containing $D$ and $K$. The next line contains $K$ consecutive elements generated by a random number generator of the kind described above.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is either the next number in the sequence, or the string \"I don't know.\" if the answer is ambiguous.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq K \\leq 10$.\n- The $K$ integers will be consecutive elements of a sequence generated by a random number generator of the type described above.\n\n**Small dataset (4 Pts, Test set 1 - Visible)**\n\n- $1 \\leq D \\leq 4$.\n\n**Large dataset (10 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq D \\leq 6$.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2010 #3] De-RNG-ed", "background": null, "description": "我想制作一个在线扑克网站。这样一个系统中非常重要的组件就是随机数生成器。它需要足够快且足够随机。以下是我想出的一个折中方案。我需要生成长度最多为 $D$ 的随机数。我的计划是选择一个素数 $P \\leq 10^D$。我还会选择非负整数 $A$ 和 $B$。最后，我会选择一个整数种子 $S$，满足 $0 \\leq S \\leq P-1$。\n\n为了输出我的伪随机数序列，我会首先输出 $S$，然后用如下公式计算 $S$ 的新值：\n\n$$S := (A\\times S + B) \\bmod P$$\n\n然后我会输出新的 $S$ 作为序列中的下一个数，并用同样的公式继续更新 $S$。我可以重复这个过程任意多次。\n\n你认为这是一个好的随机数生成器吗？你能写一个程序，给定由我的随机数生成器生成的连续 $K$ 个元素，输出该序列的下一个元素吗？", "inputFormat": "输入的第一行包含测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行包含 $D$ 和 $K$。下一行包含由上述随机数生成器生成的连续 $K$ 个元素。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #$x$: $y$\"，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是序列的下一个数。如果答案不唯一，则输出字符串 \"I don't know.\"。", "hint": "**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq K \\leq 10$。\n- 这 $K$ 个整数是由上述类型的随机数生成器生成的连续元素。\n\n**小数据范围（4 分，测试点 1 - 可见）**\n\n- $1 \\leq D \\leq 4$。\n\n**大数据范围（10 分，测试点 2 - 隐藏）**\n\n- $1 \\leq D \\leq 6$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13404", "type": "P", "difficulty": 5, "samples": [["2\n10000000001 3\n23 51 100\n10000000001 3\n100 52 22", "Case #1: 100000004\nCase #2: IMPOSSIBLE"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["2010", "广度优先搜索 BFS", "图论建模", "最短路", "Google Code Jam"], "title": "[GCJ 2010 #3] Fence", "background": "", "description": "We are looking into building a very long fence. We have already found a nice place to build it, and all that remains is to collect the materials.\n\nFrom local hardware stores, we can buy unlimited numbers of wooden boards, each of which can come in a variety of different lengths. To avoid waste, we want to make sure that the total length of these boards is exactly equal to the length of the fence we are trying to build.\n\nGiven the length of the fence, and the possible board lengths that we can use, what is the minimum number of boards that we need to purchase in order to get exactly the right length?\n\nBeware: the fence is going to be very long!", "inputFormat": "The first line of the input file contains the number of cases, $T$. $T$ test cases follow.\n\nEach test case consists of two lines. The first line contains space-separated integers $L$ and $N$. These represent the total length of the fence, and the number of different board lengths that can be purchased. The second line contains $N$ space-separated integers $B_1$, $B_2$, ..., $B_N$, representing all the possible board lengths.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $M$\", where $x$ is the case number (starting from 1) and $M$ is as follows:\n\n- If it is possible to purchase one or more boards so that their total length is exactly equal to $L$, then $M$ should be the minimum number of boards required to do this.\n- Otherwise, $M$ should be the string \"IMPOSSIBLE\".", "hint": "**Sample Explanation**\n\nIn the first example, the optimal strategy is to use $2$ boards of length $23$, $5$ boards of length $51$, and $99999997$ boards of length $100$. Of course, you could use just $100000001$ boards of length $100$ to get a total greater than $L$, but that is not allowed.\n\nIn the second example, it is only possible to get even lengths.\n\n**Limits**\n\n- $1 \\leq T \\leq 50$.\n- $10^{10} \\leq L \\leq 10^{18}$.\n- $1 \\leq N \\leq 100$.\n\n**Small dataset (7 Pts, Test set 1 - Visible)**\n\n- $1 \\leq B_i \\leq 100$.\n\n**Large dataset (22 Pts, Test set 2 - Hidden)**\n\n$1 \\leq B_i \\leq 100000$.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2010 #3] Fence", "background": "", "description": "We are looking into building a very long fence. We have already found a nice place to build it, and all that remains is to collect the materials.\n\nFrom local hardware stores, we can buy unlimited numbers of wooden boards, each of which can come in a variety of different lengths. To avoid waste, we want to make sure that the total length of these boards is exactly equal to the length of the fence we are trying to build.\n\nGiven the length of the fence, and the possible board lengths that we can use, what is the minimum number of boards that we need to purchase in order to get exactly the right length?\n\nBeware: the fence is going to be very long!", "inputFormat": "The first line of the input file contains the number of cases, $T$. $T$ test cases follow.\n\nEach test case consists of two lines. The first line contains space-separated integers $L$ and $N$. These represent the total length of the fence, and the number of different board lengths that can be purchased. The second line contains $N$ space-separated integers $B_1$, $B_2$, ..., $B_N$, representing all the possible board lengths.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $M$\", where $x$ is the case number (starting from 1) and $M$ is as follows:\n\n- If it is possible to purchase one or more boards so that their total length is exactly equal to $L$, then $M$ should be the minimum number of boards required to do this.\n- Otherwise, $M$ should be the string \"IMPOSSIBLE\".", "hint": "**Sample Explanation**\n\nIn the first example, the optimal strategy is to use $2$ boards of length $23$, $5$ boards of length $51$, and $99999997$ boards of length $100$. Of course, you could use just $100000001$ boards of length $100$ to get a total greater than $L$, but that is not allowed.\n\nIn the second example, it is only possible to get even lengths.\n\n**Limits**\n\n- $1 \\leq T \\leq 50$.\n- $10^{10} \\leq L \\leq 10^{18}$.\n- $1 \\leq N \\leq 100$.\n\n**Small dataset (7 Pts, Test set 1 - Visible)**\n\n- $1 \\leq B_i \\leq 100$.\n\n**Large dataset (22 Pts, Test set 2 - Hidden)**\n\n$1 \\leq B_i \\leq 100000$.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2010 #3] Fence", "background": null, "description": "我们计划建造一段非常长的围栏。我们已经找到了一个合适的地点，现在只需要收集材料。\n\n在本地的五金店，我们可以无限量地购买木板，每块木板有多种不同的长度可选。为了避免浪费，我们希望这些木板的总长度恰好等于我们要建造的围栏长度。\n\n给定围栏的长度以及可用的木板长度，请你计算，为了恰好拼出所需长度，最少需要购买多少块木板？\n\n注意：围栏会非常长！", "inputFormat": "输入文件的第一行包含一个整数 $T$，表示测试用例的数量。接下来有 $T$ 组测试数据。\n\n每组测试数据包含两行。第一行包含用空格分隔的两个整数 $L$ 和 $N$，分别表示围栏的总长度和可购买的不同木板长度的数量。第二行包含 $N$ 个用空格分隔的整数 $B_1, B_2, \\ldots, B_N$，表示所有可用的木板长度。", "outputFormat": "对于每组测试数据，输出一行，格式为 \"Case #$x$: $M$\"，其中 $x$ 是测试用例编号（从 1 开始），$M$ 的含义如下：\n\n- 如果可以购买一块或多块木板，使得它们的总长度恰好等于 $L$，则 $M$ 为所需木板的最小数量。\n- 否则，$M$ 应为字符串 \"IMPOSSIBLE\"。", "hint": "**样例解释**\n\n在第一个样例中，最优策略是使用 $2$ 块长度为 $23$ 的木板，$5$ 块长度为 $51$ 的木板，以及 $99999997$ 块长度为 $100$ 的木板。当然，你也可以只用 $100000001$ 块长度为 $100$ 的木板来获得大于 $L$ 的总长度，但这是不允许的。\n\n在第二个样例中，只能拼出偶数长度。\n\n**数据范围**\n\n- $1 \\leq T \\leq 50$。\n- $10^{10} \\leq L \\leq 10^{18}$。\n- $1 \\leq N \\leq 100$。\n\n**小数据集（7 分，测试点 1 - 可见）**\n\n- $1 \\leq B_i \\leq 100$。\n\n**大数据集（22 分，测试点 2 - 隐藏）**\n\n- $1 \\leq B_i \\leq 100000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13405", "type": "P", "difficulty": 5, "samples": [["2\n3\n-1 2\n0 1\n1 2\n2\n-1000 1\n2000 1", "Case #1: 3\nCase #2: 0"]], "limits": {"time": [3000, 3000], "memory": [524288, 524288]}, "tags": ["数学", "2010", "Google Code Jam"], "title": "[GCJ 2010 #3] Hot Dog Proliferation", "background": "", "description": "A number of hot dog vendors have started selling hot dogs at corners (intersections) along a very long east-west street. The problem is that multiple vendors might be selling at the same corner, and then they will take each other's business. All is not lost though! The hot dog vendors have a plan.\n\nIf there are ever two or more vendors at the same corner, then exactly two of the vendors can perform a move, which means:\n\n- One vendor moves one corner further to the east along the street.\n- The other vendor moves one corner further to the west along the street.\n\nRemember that the street is really long, so there is no danger of running out of corners. Given the starting positions of all hot dog vendors, you should find the minimum number of moves they need to perform before the vendors are all separated (meaning they are all on different corners).\n\nFor example, suppose the street begins with the following number of hot dog vendors on each corner, listed in order from west to east:\n\n```\n... 0 0 2 1 2 0 0 ...\n```\n\nThen the vendors can be separated in three moves, as shown below:\n\n```\n... 0 0 2 1 2 0 0 ...\n        |\n        +--- Do a move here\n\n... 0 1 0 2 2 0 0 ...\n          |\n          +--- Do a move here\n\n... 0 1 1 0 3 0 0 ...\n            |\n            +--- Do a move here\n\n... 0 1 1 1 1 1 0 ...\n```", "inputFormat": "Each street corner is labeled with an integer, positive or negative. For each $i$, corner $i+1$ refers to the next corner to the east from corner $i$. We will use this labeling system to describe corners in the input file.\n\nThe first line of the input file contains the number of cases, $T$. $T$ test cases follow. Each case begins with the number of corners $C$ that have at least one hot dog vendor in the starting configuration. The next $C$ lines each contain a pair of space-separated integers $P$, $V$, indicating that there are $V$ vendors at corner $P$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $M$\", where $x$ is the case number (starting from 1) and $M$ is the minimum number of moves that need to be performed before the vendors all end up at different corners from each other.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 50$.\n- $1 \\leq C \\leq 200$.\n- All $P$ values are in the range $[-1000000, 1000000]$.\n- Within each test case, all $P$ values are distinct and listed in increasing order.\n- All $V$ values are positive integers. The limit on the sum of all $V$ values is listed below.\n- It will always be possible to separate the hot dog vendors in a finite number of moves.\n\n**Small dataset (6 Pts, Test set 1 - Visible)**\n\n- The total number of hot dog vendors in each test case is at most 200.\n\n**Large dataset (22 Pts, Test set 2 - Hidden)**\n\n- The total number of hot dog vendors in each test case is at most 100000.", "locale": "en", "translations": {"en": {"title": "[GCJ 2010 #3] Hot Dog Proliferation", "background": "", "description": "A number of hot dog vendors have started selling hot dogs at corners (intersections) along a very long east-west street. The problem is that multiple vendors might be selling at the same corner, and then they will take each other's business. All is not lost though! The hot dog vendors have a plan.\n\nIf there are ever two or more vendors at the same corner, then exactly two of the vendors can perform a move, which means:\n\n- One vendor moves one corner further to the east along the street.\n- The other vendor moves one corner further to the west along the street.\n\nRemember that the street is really long, so there is no danger of running out of corners. Given the starting positions of all hot dog vendors, you should find the minimum number of moves they need to perform before the vendors are all separated (meaning they are all on different corners).\n\nFor example, suppose the street begins with the following number of hot dog vendors on each corner, listed in order from west to east:\n\n```\n... 0 0 2 1 2 0 0 ...\n```\n\nThen the vendors can be separated in three moves, as shown below:\n\n```\n... 0 0 2 1 2 0 0 ...\n        |\n        +--- Do a move here\n\n... 0 1 0 2 2 0 0 ...\n          |\n          +--- Do a move here\n\n... 0 1 1 0 3 0 0 ...\n            |\n            +--- Do a move here\n\n... 0 1 1 1 1 1 0 ...\n```", "inputFormat": "Each street corner is labeled with an integer, positive or negative. For each $i$, corner $i+1$ refers to the next corner to the east from corner $i$. We will use this labeling system to describe corners in the input file.\n\nThe first line of the input file contains the number of cases, $T$. $T$ test cases follow. Each case begins with the number of corners $C$ that have at least one hot dog vendor in the starting configuration. The next $C$ lines each contain a pair of space-separated integers $P$, $V$, indicating that there are $V$ vendors at corner $P$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $M$\", where $x$ is the case number (starting from 1) and $M$ is the minimum number of moves that need to be performed before the vendors all end up at different corners from each other.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 50$.\n- $1 \\leq C \\leq 200$.\n- All $P$ values are in the range $[-1000000, 1000000]$.\n- Within each test case, all $P$ values are distinct and listed in increasing order.\n- All $V$ values are positive integers. The limit on the sum of all $V$ values is listed below.\n- It will always be possible to separate the hot dog vendors in a finite number of moves.\n\n**Small dataset (6 Pts, Test set 1 - Visible)**\n\n- The total number of hot dog vendors in each test case is at most 200.\n\n**Large dataset (22 Pts, Test set 2 - Hidden)**\n\n- The total number of hot dog vendors in each test case is at most 100000.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2010 #3] Hot Dog Proliferation", "background": null, "description": "有若干热狗摊贩在一条很长的东西向街道的各个路口（交叉口）上卖热狗。问题在于，可能有多个摊贩在同一个路口，这样他们就会互相抢生意。不过事情还有转机！热狗摊贩们有一个计划。\n\n如果某个路口上有两个或更多摊贩，那么恰好有两位摊贩可以进行一次移动，具体如下：\n\n- 一位摊贩向东移动到下一个路口。\n- 另一位摊贩向西移动到下一个路口。\n\n请注意，这条街道非常长，所以不用担心会没有路口可去。给定所有热狗摊贩的初始位置，请你计算，最少需要多少次移动，才能让所有摊贩都分开（即每个摊贩都在不同的路口）。\n\n例如，假设街道上各个路口的热狗摊贩数量从西到东依次如下：\n\n```\n... 0 0 2 1 2 0 0 ...\n```\n\n那么摊贩们可以通过三次移动分开，如下所示：\n\n```\n... 0 0 2 1 2 0 0 ...\n        |\n        +--- 在这里进行一次移动\n\n... 0 1 0 2 2 0 0 ...\n          |\n          +--- 在这里进行一次移动\n\n... 0 1 1 0 3 0 0 ...\n            |\n            +--- 在这里进行一次移动\n\n... 0 1 1 1 1 1 0 ...\n```", "inputFormat": "每个路口用一个整数标号，可以为正也可以为负。对于每个 $i$，路口 $i+1$ 表示比路口 $i$ 更靠东的下一个路口。我们将使用这种标号方式来描述输入文件中的路口。\n\n输入文件的第一行包含测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行包含一个整数 $C$，表示初始状态下至少有一个热狗摊贩的路口数量。接下来的 $C$ 行，每行包含两个用空格分隔的整数 $P$ 和 $V$，表示在路口 $P$ 上有 $V$ 个摊贩。", "outputFormat": "对于每组测试数据，输出一行，格式为 \"Case #$x$: $M$\"，其中 $x$ 是测试用例编号（从 1 开始），$M$ 是将所有摊贩分开所需的最小移动次数。", "hint": "**数据范围**\n\n- $1 \\leq T \\leq 50$。\n- $1 \\leq C \\leq 200$。\n- 所有 $P$ 的取值范围为 $[-1000000, 1000000]$。\n- 每组测试数据中，所有 $P$ 互不相同，并且按递增顺序给出。\n- 所有 $V$ 都为正整数。所有 $V$ 的和的限制见下文。\n- 总是可以在有限步内将所有摊贩分开。\n\n**小数据范围（6 分，测试集 1 - 可见）**\n\n- 每组测试数据中热狗摊贩总数不超过 200。\n\n**大数据范围（22 分，测试集 2 - 隐藏）**\n\n- 每组测试数据中热狗摊贩总数不超过 100000。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13406", "type": "P", "difficulty": 6, "samples": [["2\n6 10\n8 4", "Case #1: 4\nCase #2: 4"]], "limits": {"time": [3000, 20000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2010", "数位 DP", "Google Code Jam"], "title": "[GCJ 2010 #3] Different Sum", "background": "", "description": "We have come up with a wonderful problem for Google Code Jam 2010 that involves contestants solving a cryptarithm. But we need your help in creating testcases for the problem; more precisely, we're concerned with addition equations that are good enough (in the sense defined below) for conversion into cryptarithms.\n\nYou don't need to know what a cryptarithm is to solve this problem, as we'll provide all required definitions. We define a cryptarithm equation to be an addition equation written in such a way that all summands (numbers being added) and the sum are aligned to the same right border like this:\n\n```\n124\n 31\n 25\n---\n180\n```\n\nAdditionally, for each column of a cryptarithm equation, all digits of the summands in that column must be different. Note that we don't include the sum in this constraint. So for example in the above equation the first column contains only digit $1$, the second column contains digits $2,3$ and $2$, and the third column contains digits $4, 1$ and $5$. This equation is not a cryptarithm equation since the second column contains two $2$'s. However, it would be a cryptarithm equation if we replaced the last summand with $15$ (and the sum with $170$).\n\nNote that summands in a cryptarithm equation are always positive and written without leading zeros. The order of summands is not important (in other words, two equations which differ only in the order of the summands are considered the same).\n\nThe example above was in base $10$, but we're also interested in cryptarithm equations in other bases. Note that a \"digit\" in base $b$ could mean any integer between $0$ and $b-1$. Here is a cryptarithm equation in base $23$:\n\n```\n I7B\n JJJ\n----\n1F47\n```\n\nIn this example, \"I\" stands for digit $18$, \"B\" stands for digit $11$, \"J\" stands for digit $19$, and \"F\" stands for digit $15$. In decimal notation, the two summands are $18\\times 23^2 + 7\\times 23 + 11 = 9694$ and $19\\times 23^2 + 19\\times 23 + 19 = 10507$, and the sum is $1\\times 23^3 + 15\\times 23^2 + 4\\times 23 + 7 = 20201$. Please note that denoting digits of $10$ and more with letters was done purely for the clarity of the example; it doesn't really matter in this problem how exactly we denote such digits in writing.\n\nHow many cryptarithm equations are there with the given sum $N$ in the given base $B$?\n\nSince the answer might be very large, please output it modulo $1000000007$.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each contains two positive integers $N$ and $B$. All input numbers are given in base $10$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from $1$) and $y$ is the number of different cryptarithm equations with the given sum. Since this number can be very big, please output it modulo $1000000007$. Of course, the output itself should be in base $10$.", "hint": "**Sample Explanation**\n\nHere are the $4$ cryptarithm equations with sum $6$:\n\n```\n6   1   2   1\n-   5   4   2\n6   -   -   3\n    6   6   -\n            6\n```\n\nAnd here are the $4$ cryptarithm equations in base $4$ with sum $8=(20)_4$:\n\n```\n20   11   13   10\n--    3    1    3\n20   --   --    1\n     20   20   --\n               20\n```\n\n**Limits**\n\n- $1 \\leq T \\leq 20$.\n\n**Small dataset (7 Pts, Test set 1 - Visible)**\n\n- Time limit: ~~30~~ 3 seconds.\n- $1 \\leq N \\leq 100$.\n- $2 \\leq B \\leq 10$.\n\n**Large dataset (22 Pts, Test set 2 - Hidden)**\n\n- Time limit: ~~120~~ 20 seconds.\n- $1 \\leq N \\leq 10^{18}$.\n- $2 \\leq B \\leq 70$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2010 #3] Different Sum", "background": "", "description": "We have come up with a wonderful problem for Google Code Jam 2010 that involves contestants solving a cryptarithm. But we need your help in creating testcases for the problem; more precisely, we're concerned with addition equations that are good enough (in the sense defined below) for conversion into cryptarithms.\n\nYou don't need to know what a cryptarithm is to solve this problem, as we'll provide all required definitions. We define a cryptarithm equation to be an addition equation written in such a way that all summands (numbers being added) and the sum are aligned to the same right border like this:\n\n```\n124\n 31\n 25\n---\n180\n```\n\nAdditionally, for each column of a cryptarithm equation, all digits of the summands in that column must be different. Note that we don't include the sum in this constraint. So for example in the above equation the first column contains only digit $1$, the second column contains digits $2,3$ and $2$, and the third column contains digits $4, 1$ and $5$. This equation is not a cryptarithm equation since the second column contains two $2$'s. However, it would be a cryptarithm equation if we replaced the last summand with $15$ (and the sum with $170$).\n\nNote that summands in a cryptarithm equation are always positive and written without leading zeros. The order of summands is not important (in other words, two equations which differ only in the order of the summands are considered the same).\n\nThe example above was in base $10$, but we're also interested in cryptarithm equations in other bases. Note that a \"digit\" in base $b$ could mean any integer between $0$ and $b-1$. Here is a cryptarithm equation in base $23$:\n\n```\n I7B\n JJJ\n----\n1F47\n```\n\nIn this example, \"I\" stands for digit $18$, \"B\" stands for digit $11$, \"J\" stands for digit $19$, and \"F\" stands for digit $15$. In decimal notation, the two summands are $18\\times 23^2 + 7\\times 23 + 11 = 9694$ and $19\\times 23^2 + 19\\times 23 + 19 = 10507$, and the sum is $1\\times 23^3 + 15\\times 23^2 + 4\\times 23 + 7 = 20201$. Please note that denoting digits of $10$ and more with letters was done purely for the clarity of the example; it doesn't really matter in this problem how exactly we denote such digits in writing.\n\nHow many cryptarithm equations are there with the given sum $N$ in the given base $B$?\n\nSince the answer might be very large, please output it modulo $1000000007$.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each contains two positive integers $N$ and $B$. All input numbers are given in base $10$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from $1$) and $y$ is the number of different cryptarithm equations with the given sum. Since this number can be very big, please output it modulo $1000000007$. Of course, the output itself should be in base $10$.", "hint": "**Sample Explanation**\n\nHere are the $4$ cryptarithm equations with sum $6$:\n\n```\n6   1   2   1\n-   5   4   2\n6   -   -   3\n    6   6   -\n            6\n```\n\nAnd here are the $4$ cryptarithm equations in base $4$ with sum $8=(20)_4$:\n\n```\n20   11   13   10\n--    3    1    3\n20   --   --    1\n     20   20   --\n               20\n```\n\n**Limits**\n\n- $1 \\leq T \\leq 20$.\n\n**Small dataset (7 Pts, Test set 1 - Visible)**\n\n- Time limit: ~~30~~ 3 seconds.\n- $1 \\leq N \\leq 100$.\n- $2 \\leq B \\leq 10$.\n\n**Large dataset (22 Pts, Test set 2 - Hidden)**\n\n- Time limit: ~~120~~ 20 seconds.\n- $1 \\leq N \\leq 10^{18}$.\n- $2 \\leq B \\leq 70$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2010 #3] Different Sum", "background": null, "description": "我们为 Google Code Jam 2010 设计了一个很棒的问题，涉及选手们解决一个“字谜算式”（cryptarithm）。但我们需要你帮助生成该问题的测试用例；更准确地说，我们关心的是那些足够“好”（具体定义见下文）以便转换为字谜算式的加法等式。\n\n你不需要了解什么是字谜算式来解决本题，因为我们会提供所有必要的定义。我们将字谜算式定义为如下格式的加法等式：所有被加数（加数）和结果（和）都右对齐，如下所示：\n\n```\n124\n 31\n 25\n---\n180\n```\n\n此外，对于字谜算式的每一列，所有加数在该列上的数字都必须互不相同。注意，这个约束不包括结果（和）。例如，上述等式的第一列只有数字 $1$，第二列有数字 $2,3$ 和 $2$，第三列有数字 $4, 1$ 和 $5$。这个等式不是一个字谜算式，因为第二列出现了两个 $2$。但如果我们将最后一个加数替换为 $15$（和替换为 $170$），那么它就是一个字谜算式。\n\n注意，字谜算式中的加数都为正数，且不允许有前导零。加数的顺序不重要（换句话说，仅加数顺序不同的两个等式被视为相同的等式）。\n\n上面的例子是在 $10$ 进制下的，但我们也对其他进制下的字谜算式感兴趣。注意，在 $b$ 进制下，“数字”可以是 $0$ 到 $b-1$ 之间的任意整数。下面是一个 $23$ 进制下的字谜算式：\n\n```\n I7B\n JJJ\n----\n1F47\n```\n\n在这个例子中，\"I\" 代表数字 $18$，\"B\" 代表数字 $11$，\"J\" 代表数字 $19$，\"F\" 代表数字 $15$。用十进制表示，这两个加数分别为 $18\\times 23^2 + 7\\times 23 + 11 = 9694$ 和 $19\\times 23^2 + 19\\times 23 + 19 = 10507$，和为 $1\\times 23^3 + 15\\times 23^2 + 4\\times 23 + 7 = 20201$。请注意，用字母表示 $10$ 及以上的数字只是为了例子更清晰；在本题中如何表示这些数字并不重要。\n\n给定和 $N$ 以及进制 $B$，有多少个不同的字谜算式？\n\n由于答案可能非常大，请输出对 $1000000007$ 取模的结果。", "inputFormat": "输入的第一行是测试用例数 $T$。接下来的 $T$ 行，每行包含两个正整数 $N$ 和 $B$。所有输入数字均为十进制。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #$x$: $y$\"，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是满足条件的字谜算式数量。由于答案可能很大，请输出对 $1000000007$ 取模的结果。输出本身应为十进制。", "hint": "**样例解释**\n\n以下是和为 $6$ 的 $4$ 个字谜算式：\n\n```\n6   1   2   1\n-   5   4   2\n6   -   -   3\n    6   6   -\n            6\n```\n\n以下是在 $4$ 进制下和为 $8=(20)_4$ 的 $4$ 个字谜算式：\n\n```\n20   11   13   10\n--    3    1    3\n20   --   --    1\n     20   20   --\n               20\n```\n\n**数据范围**\n\n- $1 \\leq T \\leq 20$。\n\n**小数据范围（7 分，测试点 1 - 可见）**\n\n- 时间限制：~~30~~ 3 秒。\n- $1 \\leq N \\leq 100$。\n- $2 \\leq B \\leq 10$。\n\n**大数据范围（22 分，测试点 2 - 隐藏）**\n\n- 时间限制：~~120~~ 20 秒。\n- $1 \\leq N \\leq 10^{18}$。\n- $2 \\leq B \\leq 70$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13407", "type": "P", "difficulty": 6, "samples": [["2\nABCCBA\nAAABAAB", "Case #1: 12\nCase #2: 13"]], "limits": {"time": [6000, 6000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2010", "Google Code Jam"], "title": "[GCJ 2010 Finals] Letter Stamper", "background": "", "description": "Roland is a high-school math teacher. Every day, he gets hundreds of papers from his students. For each paper, he carefully chooses a letter grade: 'A', 'B' or 'C'. (Roland's students are too smart to get lower grades like a 'D' or an 'F'). Once the grades are all decided, Roland passes the papers onto his assistant - you. Your job is to stamp the correct grade onto each paper.\n\nYou have a low-tech but functional letter stamp that you use for this. To print out a letter, you attach a special plate to the front of the stamp corresponding to that letter, dip it in ink, and then apply it to the paper.\n\nThe interesting thing is that instead of removing the plate when you want to switch letters, you can just put a new plate on top of the old one. In fact, you can think of the plates on the letter stamp as being a stack, supporting the following operations:\n\nPush a letter on to the top of the stack. (This corresponds to attaching a new plate to the front of the stamp.)\nPop a letter from the top of the stack. (This corresponds to removing the plate from the front of the stamp.)\nPrint the letter on the top of the stack. (This corresponds to actually using the stamp.) Of course, the stack must actually have a letter on it for this to work.\nGiven a sequence of letter grades ('A', 'B', and 'C'), how many operations do you need to print the whole sequence in order? The stack begins empty, and you must empty it when you are done. However, you have unlimited supplies of each kind of plate that you can use in the meantime.\n\nFor example, if you wanted to print the sequence \"ABCCBA\", then you could do it in 12 operations, as shown below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/pu50nvw6.png)", "inputFormat": "The first line of the input file contains the number of cases, $T$. $T$ test cases follow, one per line. Each of these lines contains a single string $S$, representing the sequence of characters that you want to print out in order.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $N$\", where $x$ is the case number (starting from $1$) and $N$ is the minimum number of stack operations required to print out $S$.", "hint": "**Limits**\n\n- $S$ is a non-empty string containing only the letters 'A', 'B', and 'C'.\n\n**Small dataset (8 Pts, Test set 1 - Visible)**\n\n- $1 \\leq T \\leq 100$.\n- $S$ has at most $100$ characters.\n\n**Large dataset (19 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq T \\leq 20$.\n- $S$ has at most $7000$ characters.", "locale": "en", "translations": {"en": {"title": "[GCJ 2010 Finals] Letter Stamper", "background": "", "description": "Roland is a high-school math teacher. Every day, he gets hundreds of papers from his students. For each paper, he carefully chooses a letter grade: 'A', 'B' or 'C'. (Roland's students are too smart to get lower grades like a 'D' or an 'F'). Once the grades are all decided, Roland passes the papers onto his assistant - you. Your job is to stamp the correct grade onto each paper.\n\nYou have a low-tech but functional letter stamp that you use for this. To print out a letter, you attach a special plate to the front of the stamp corresponding to that letter, dip it in ink, and then apply it to the paper.\n\nThe interesting thing is that instead of removing the plate when you want to switch letters, you can just put a new plate on top of the old one. In fact, you can think of the plates on the letter stamp as being a stack, supporting the following operations:\n\nPush a letter on to the top of the stack. (This corresponds to attaching a new plate to the front of the stamp.)\nPop a letter from the top of the stack. (This corresponds to removing the plate from the front of the stamp.)\nPrint the letter on the top of the stack. (This corresponds to actually using the stamp.) Of course, the stack must actually have a letter on it for this to work.\nGiven a sequence of letter grades ('A', 'B', and 'C'), how many operations do you need to print the whole sequence in order? The stack begins empty, and you must empty it when you are done. However, you have unlimited supplies of each kind of plate that you can use in the meantime.\n\nFor example, if you wanted to print the sequence \"ABCCBA\", then you could do it in 12 operations, as shown below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/pu50nvw6.png)", "inputFormat": "The first line of the input file contains the number of cases, $T$. $T$ test cases follow, one per line. Each of these lines contains a single string $S$, representing the sequence of characters that you want to print out in order.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $N$\", where $x$ is the case number (starting from $1$) and $N$ is the minimum number of stack operations required to print out $S$.", "hint": "**Limits**\n\n- $S$ is a non-empty string containing only the letters 'A', 'B', and 'C'.\n\n**Small dataset (8 Pts, Test set 1 - Visible)**\n\n- $1 \\leq T \\leq 100$.\n- $S$ has at most $100$ characters.\n\n**Large dataset (19 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq T \\leq 20$.\n- $S$ has at most $7000$ characters.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2010 Finals] Letter Stamper", "background": null, "description": "Roland 是一名高中数学老师。每天，他都会收到学生们交上来的上百份试卷。对于每份试卷，他都会仔细地选择一个字母成绩：'A'、'B' 或 'C'。（Roland 的学生都很聪明，不会拿到 'D' 或 'F' 这样的低分。）一旦所有成绩都确定后，Roland 会把试卷交给他的助理——你。你的任务是把正确的成绩盖在每份试卷上。\n\n你有一个低科技但实用的字母印章。要打印一个字母，你需要将对应字母的专用印版装到印章前端，蘸上墨水，然后盖在试卷上。\n\n有趣的是，当你想要切换字母时，无需取下原来的印版，你只需把新的印版直接叠加在旧的印版上。实际上，你可以把印章上的印版看作一个栈，支持以下操作：\n\n- 将一个字母压入栈顶（即把新的印版装到印章前端）。\n- 从栈顶弹出一个字母（即把印章前端的印版取下）。\n- 打印栈顶的字母（即实际盖章）。当然，栈中必须有印版才能进行此操作。\n\n给定一个字母成绩序列（只包含 'A'、'B' 和 'C'），你需要用最少的操作数按顺序打印出整个序列。初始时栈为空，结束时你也必须将栈清空。在操作过程中，你有无限数量的每种印版可用。\n\n例如，如果你要打印序列 \"ABCCBA\"，你可以用 12 次操作完成，如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/pu50nvw6.png)", "inputFormat": "输入文件的第一行包含测试用例数 $T$。接下来的 $T$ 行，每行包含一个字符串 $S$，表示你要按顺序打印的字母序列。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #$x$: $N$\"，其中 $x$ 是测试用例编号（从 1 开始），$N$ 是打印出 $S$ 所需的最少栈操作数。", "hint": "**限制条件**\n\n- $S$ 是一个非空字符串，只包含字母 'A'、'B' 和 'C'。\n\n**小数据集（8 分，测试集 1 - 可见）**\n\n- $1 \\leq T \\leq 100$。\n- $S$ 最多包含 $100$ 个字符。\n\n**大数据集（19 分，测试集 2 - 隐藏）**\n\n- $1 \\leq T \\leq 20$。\n- $S$ 最多包含 $7000$ 个字符。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13408", "type": "P", "difficulty": 5, "samples": [["2\n5\n1 2\n2 1\n6\n1 2\n1 4\n4 5", "Case #1: 4\nCase #2: 6"]], "limits": {"time": [3000, 3000, 3000], "memory": [1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2010", "记忆化搜索", "Google Code Jam"], "title": "[GCJ 2010 Finals] City Tour", "background": "", "description": "During summer time, old cities in Europe are swarming with tourists who roam the streets and visit points of interest.\n\nMany old cities were built organically and not according to some architecture plan, but, strangely, their growth exhibits a similar pattern: the cities started from three points of interest, with each pair being connected by a bidirectional street; then, gradually, new points of interest were added. Any new point of interest was connected by two new bidirectional streets to two different previous points of interest which were already directly connected by a street.\n\nA tourist visiting such a city would like to do a tour visiting as many points of interest as possible. The tour can start at any point of interest and must end at the same point of interest. The tour may visit each street at most once and each point of interest at most once (with the exception of the first point of interest which is visited exactly twice).\n\nYou are given the description of how the city grew. Find the largest number of different points of interest a single tour can visit in this city.", "inputFormat": "The first line of the input file contains the number of cases, $T$. $T$ test cases follow.\n\nEach case begins with the integer $N$ - the total number of points of interest in the city. Points are denoted with numbers from $1$ to $N$; numbers $1$, $2$, and $3$ denote the three original points when the city started, while numbers $4$, ..., $N$ denote the other points in the order they were added to the city.\n\nThe next $N-3$ lines each contain a pair of space-separated integers $A$, $B$, indicating that the corresponding point of interest was connected by streets to points $A$ and $B$. First of these lines corresponds to point number $4$, second to point number $5$, etc.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from $1$) and $y$ is the largest number of points of interest a tour can visit in this city.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 50$.\n\n**Small dataset (4 Pts, Test set 1 - Visible)**\n\n- $4 \\leq N \\leq 15$.\n\n**Large dataset (23 Pts, Test set 2 - Hidden)**\n\n- $4 \\leq N \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2010 Finals] City Tour", "background": "", "description": "During summer time, old cities in Europe are swarming with tourists who roam the streets and visit points of interest.\n\nMany old cities were built organically and not according to some architecture plan, but, strangely, their growth exhibits a similar pattern: the cities started from three points of interest, with each pair being connected by a bidirectional street; then, gradually, new points of interest were added. Any new point of interest was connected by two new bidirectional streets to two different previous points of interest which were already directly connected by a street.\n\nA tourist visiting such a city would like to do a tour visiting as many points of interest as possible. The tour can start at any point of interest and must end at the same point of interest. The tour may visit each street at most once and each point of interest at most once (with the exception of the first point of interest which is visited exactly twice).\n\nYou are given the description of how the city grew. Find the largest number of different points of interest a single tour can visit in this city.", "inputFormat": "The first line of the input file contains the number of cases, $T$. $T$ test cases follow.\n\nEach case begins with the integer $N$ - the total number of points of interest in the city. Points are denoted with numbers from $1$ to $N$; numbers $1$, $2$, and $3$ denote the three original points when the city started, while numbers $4$, ..., $N$ denote the other points in the order they were added to the city.\n\nThe next $N-3$ lines each contain a pair of space-separated integers $A$, $B$, indicating that the corresponding point of interest was connected by streets to points $A$ and $B$. First of these lines corresponds to point number $4$, second to point number $5$, etc.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from $1$) and $y$ is the largest number of points of interest a tour can visit in this city.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 50$.\n\n**Small dataset (4 Pts, Test set 1 - Visible)**\n\n- $4 \\leq N \\leq 15$.\n\n**Large dataset (23 Pts, Test set 2 - Hidden)**\n\n- $4 \\leq N \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2010 Finals] City Tour", "background": null, "description": "在夏季，欧洲的老城市里到处都是游客，他们在街道上漫步，参观各种景点。\n\n许多老城市并不是按照某种建筑规划而建造的，而是自然生长的，但奇怪的是，它们的扩展却表现出类似的模式：城市最初有三个景点，每一对景点之间都有一条双向街道相连；随后，新的景点逐渐被添加。每添加一个新的景点时，它会通过两条新的双向街道与已经直接相连的两个不同的旧景点相连。\n\n一位游客想要在这样的城市中进行一次游览，尽可能多地参观不同的景点。游览可以从任意一个景点开始，并且必须在同一个景点结束。每条街道最多只能经过一次，每个景点最多只能访问一次（起点景点除外，必须恰好访问两次）。\n\n你将获得该城市扩展的描述。请找出在该城市中一次游览最多可以参观多少个不同的景点。", "inputFormat": "输入文件的第一行包含测试用例数 $T$。接下来有 $T$ 组测试数据。\n\n每组测试数据以一个整数 $N$ 开头，表示城市中的景点总数。景点编号为 $1$ 到 $N$；编号 $1$、$2$ 和 $3$ 表示城市最初的三个景点，编号 $4$ 到 $N$ 表示后续依次添加的景点。\n\n接下来的 $N-3$ 行，每行包含两个用空格分隔的整数 $A$ 和 $B$，表示相应的景点通过街道与景点 $A$ 和 $B$ 相连。这些行的第 $i$ 行对应编号为 $i+3$ 的景点。", "outputFormat": "对于每个测试用例，输出一行，格式为 “Case #$x$: $y$”，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是一次游览最多可以参观的不同景点数。", "hint": "**数据范围**\n\n- $1 \\leq T \\leq 50$。\n\n**小数据范围（4 分，测试点 1 - 可见）**\n\n- $4 \\leq N \\leq 15$。\n\n**大数据范围（23 分，测试点 2 - 隐藏）**\n\n- $4 \\leq N \\leq 1000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13409", "type": "P", "difficulty": 5, "samples": [["4\n1 5\n2 2\n10 3\n2 50", "Case #1: 3\nCase #2: 3\nCase #3: 19\nCase #4: 11"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["数学", "贪心", "2010", "Google Code Jam"], "title": "[GCJ 2010 Finals] Candy Store", "background": "", "description": "Owning a candy store is tough! You have to optimize all kinds of things. Lately you've been selling a very popular kind of candy called Whizboppers. These candies become rotten very quickly, which gives them the following properties:\n\n- You must buy new Whizboppers from your supplier every morning.\n- You must sell Whizboppers in the boxes you bought from your supplier that morning.\n\nYou can order Whizboppers from your supplier in boxes that contain any integer number of grams.\n\nEvery day up to $k$ people visit your store, and, starting from the first person, they will choose an integer number of cents to spend on Whizboppers: between $1$ and $C$ cents inclusive. You're going to sell Whizboppers for $1$ cent per gram; so if a person wants to spend $4$ cents, you will give that person exactly $4$ grams of candy. You might do this by giving the person a $4$-gram box, or perhaps a $2$-gram box and two $1$-gram boxes.\n\nWhat is the minimum number of boxes you need to order so that, no matter what amount each person orders, you can always give all of the people the mass of Whizboppers they want?\n\nNote: When a person chooses how much candy to buy, you know what other people have already bought, but you don't know what future people will buy.\n\nFor example, if up to $2$ people visit your store every day, and they spend up to $2$ cents each ($k=2$, $C=2$), you could buy four $1$-gram boxes from your supplier. But you can do better: if you buy two $1$-gram boxes and one $2$-gram box, you can satisfy your customers. Here's how:\n\n```\nFirst Person   Boxes given   Second Person   Boxes given\n--------------------------------------------------------\n  2 cents      1 x 2-gram      2 cents       2 x 1-gram\n                               1 cent        1 x 1-gram\n  -----------------------------------------------------\n  1 cent       1 x 1-gram      2 cents       1 x 2-gram\n                               1 cent        1 x 1-gram\n```\n\nRegardless of what the first person orders, you can give out boxes so that the second person can still get the right amount of candy. So for $k=2, C=2$, you can serve any sequence of orders with $3$ boxes.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow, each of which contains two integers: $k$ and $C$, the maximum number of people and the maximum number of cents each person may spend.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from $1$) and $y$ is the minimum number of boxes you need to order every day.", "hint": "**Sample Explanation**\n\nIn the first case, you can buy one $1$-gram box and two $2$-gram boxes. In the second case, you can buy two $1$-gram boxes and one $2$-gram box.\n\n**Limits**\n\n- $1 \\leq T \\leq 100.$\n\n**Small dataset (7 Pts, Test set 1 - Visible)**\n\n- $1 \\leq k \\leq 20.$\n- $1 \\leq C \\leq 3.$\n\n**Large dataset (20 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq k \\leq 1000.$\n- $1 \\leq C \\leq 10^{12}.$", "locale": "en", "translations": {"en": {"title": "[GCJ 2010 Finals] Candy Store", "background": "", "description": "Owning a candy store is tough! You have to optimize all kinds of things. Lately you've been selling a very popular kind of candy called Whizboppers. These candies become rotten very quickly, which gives them the following properties:\n\n- You must buy new Whizboppers from your supplier every morning.\n- You must sell Whizboppers in the boxes you bought from your supplier that morning.\n\nYou can order Whizboppers from your supplier in boxes that contain any integer number of grams.\n\nEvery day up to $k$ people visit your store, and, starting from the first person, they will choose an integer number of cents to spend on Whizboppers: between $1$ and $C$ cents inclusive. You're going to sell Whizboppers for $1$ cent per gram; so if a person wants to spend $4$ cents, you will give that person exactly $4$ grams of candy. You might do this by giving the person a $4$-gram box, or perhaps a $2$-gram box and two $1$-gram boxes.\n\nWhat is the minimum number of boxes you need to order so that, no matter what amount each person orders, you can always give all of the people the mass of Whizboppers they want?\n\nNote: When a person chooses how much candy to buy, you know what other people have already bought, but you don't know what future people will buy.\n\nFor example, if up to $2$ people visit your store every day, and they spend up to $2$ cents each ($k=2$, $C=2$), you could buy four $1$-gram boxes from your supplier. But you can do better: if you buy two $1$-gram boxes and one $2$-gram box, you can satisfy your customers. Here's how:\n\n```\nFirst Person   Boxes given   Second Person   Boxes given\n--------------------------------------------------------\n  2 cents      1 x 2-gram      2 cents       2 x 1-gram\n                               1 cent        1 x 1-gram\n  -----------------------------------------------------\n  1 cent       1 x 1-gram      2 cents       1 x 2-gram\n                               1 cent        1 x 1-gram\n```\n\nRegardless of what the first person orders, you can give out boxes so that the second person can still get the right amount of candy. So for $k=2, C=2$, you can serve any sequence of orders with $3$ boxes.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow, each of which contains two integers: $k$ and $C$, the maximum number of people and the maximum number of cents each person may spend.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from $1$) and $y$ is the minimum number of boxes you need to order every day.", "hint": "**Sample Explanation**\n\nIn the first case, you can buy one $1$-gram box and two $2$-gram boxes. In the second case, you can buy two $1$-gram boxes and one $2$-gram box.\n\n**Limits**\n\n- $1 \\leq T \\leq 100.$\n\n**Small dataset (7 Pts, Test set 1 - Visible)**\n\n- $1 \\leq k \\leq 20.$\n- $1 \\leq C \\leq 3.$\n\n**Large dataset (20 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq k \\leq 1000.$\n- $1 \\leq C \\leq 10^{12}.$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2010 Finals] Candy Store", "background": null, "description": "经营一家糖果店可不容易！你需要优化各种各样的事情。最近你在销售一种非常受欢迎的糖果，名叫 Whizboppers。这种糖果很快就会变质，因此有如下特性：\n\n- 你必须每天早上从供应商那里购买新的 Whizboppers。\n- 你必须用当天早上从供应商那里买来的盒子出售 Whizboppers。\n\n你可以从供应商那里订购任意整数克数的 Whizboppers 盒子。\n\n每天最多有 $k$ 位顾客光临你的商店，并且从第一个顾客开始，他们会选择一个整数数量的美分来购买 Whizboppers：在 $1$ 到 $C$ 美分之间（包含 $1$ 和 $C$）。你将以每克 $1$ 美分的价格出售 Whizboppers；因此，如果某人想花 $4$ 美分，你就会给他正好 $4$ 克的糖果。你可以通过给他一个 $4$ 克的盒子，或者两个 $2$ 克的盒子和两个 $1$ 克的盒子来实现。\n\n你需要订购最少数量的盒子，以保证无论每个人点多少克，你都能满足所有顾客的需求。\n\n注意：当某个人选择购买多少糖果时，你已经知道之前的人买了多少，但你不知道后面的人会买多少。\n\n例如，如果每天最多有 $2$ 位顾客，每人最多花 $2$ 美分（$k=2$，$C=2$），你可以从供应商那里购买四个 $1$ 克的盒子。但你可以做得更好：如果你买两个 $1$ 克的盒子和一个 $2$ 克的盒子，你也能满足所有顾客。如下所示：\n\n```\n第一位顾客   发出的盒子     第二位顾客   发出的盒子\n------------------------------------------------\n  2 美分      1 个 2 克盒子    2 美分       2 个 1 克盒子\n                                 1 美分        1 个 1 克盒子\n  -------------------------------------------------------\n  1 美分      1 个 1 克盒子    2 美分       1 个 2 克盒子\n                                 1 美分        1 个 1 克盒子\n```\n\n无论第一位顾客点多少，你都能分配盒子，使得第二位顾客仍然能得到正确数量的糖果。因此对于 $k=2, C=2$，你每天只需准备 $3$ 个盒子即可满足任意顺序的订单。", "inputFormat": "输入的第一行是测试用例数 $T$。接下来的 $T$ 行，每行包含两个整数 $k$ 和 $C$，分别表示每天最多的顾客数和每位顾客最多花费的美分数。", "outputFormat": "对于每个测试用例，输出一行，格式为 “Case #$x$: $y$”，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是你每天需要订购的最少盒子数。", "hint": "**样例解释**\n\n在第一个样例中，你可以购买一个 $1$ 克盒子和两个 $2$ 克盒子。在第二个样例中，你可以购买两个 $1$ 克盒子和一个 $2$ 克盒子。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n\n**小数据集（7 分，测试集 1 - 可见）**\n\n- $1 \\leq k \\leq 20$。\n- $1 \\leq C \\leq 3$。\n\n**大数据集（20 分，测试集 2 - 隐藏）**\n\n- $1 \\leq k \\leq 1000$。\n- $1 \\leq C \\leq 10^{12}$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13410", "type": "P", "difficulty": 5, "samples": [["3\n3\n0 10 -10\n40\n5\n0 1 2 3 4\n13\n5\n0 1 2 3 4\n7", "Case #1: 40\nCase #2: 12\nCase #3: NO SOLUTION"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2010", "双指针 two-pointer", "折半搜索 meet in the middle", "Google Code Jam"], "title": "[GCJ 2010 Finals] Travel Plan", "background": "", "description": "In a yet-to-be-announced and rechecked discovery by Antarctic astronomers, it is written that there are $N$ inhabited planets in space, all lying along the same straight line, with the $i$-th planet lying at coordinate $X_i$ along the line ($i = 1, 2, ..., N$). Earth is the first planet, lying at coordinate zero, so $X_1$ will always be equal to $0$.\n\nBeing very excited about this fact, you start planning a trip to visit all the planets. Since unknown planets can be dangerous, you want to visit each planet exactly once before returning to Earth. You have $F$ units of fuel, and you want to spend as much of it on this trip as possible so that your final landing on Earth is safer. Your spaceship is pretty basic and can only fly along a straight line from any planet $i$ to any other planet $j$, consuming $|X_i - X_j|$ units of fuel along the way. It can't turn without landing.\n\nSo you need to create a travel plan that requires at most $F$ units of fuel, starts from Earth, visits each of the other planets exactly once, and then returns to Earth. If there are several such plans, you should find the one that consumes most fuel. Output the amount of fuel consumed.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case description starts with a line containing the number of planets $N$. The next line contains $N$ numbers $X_i$, the coordinates of the planets. The next line contains the amount of fuel $F$ that you have.\n", "outputFormat": "For each test case, output one line containing either \"Case #$x$: NO SOLUTION\", when there's no such travel plan, or \"Case #$x$: $y$\", where $x$ is the case number (starting from $1$) and $y$ is the maximum amount of fuel consumed.", "hint": "**Limits**\n\n- $1 \\leq F \\leq 10^{17}.$\n- $-10^{15} \\leq X_i \\leq 10^{15}.$\n- $X_1 = 0.$\n- All $X_i$ are different.\n\n**Small dataset (3 Pts, Test set 1 - Visible)**\n\n- $1 \\leq T \\leq 100.$\n- $2 \\leq N \\leq 10.$\n\n**Large dataset (30 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq T \\leq 20.$\n- $2 \\leq N \\leq 30.$", "locale": "en", "translations": {"en": {"title": "[GCJ 2010 Finals] Travel Plan", "background": "", "description": "In a yet-to-be-announced and rechecked discovery by Antarctic astronomers, it is written that there are $N$ inhabited planets in space, all lying along the same straight line, with the $i$-th planet lying at coordinate $X_i$ along the line ($i = 1, 2, ..., N$). Earth is the first planet, lying at coordinate zero, so $X_1$ will always be equal to $0$.\n\nBeing very excited about this fact, you start planning a trip to visit all the planets. Since unknown planets can be dangerous, you want to visit each planet exactly once before returning to Earth. You have $F$ units of fuel, and you want to spend as much of it on this trip as possible so that your final landing on Earth is safer. Your spaceship is pretty basic and can only fly along a straight line from any planet $i$ to any other planet $j$, consuming $|X_i - X_j|$ units of fuel along the way. It can't turn without landing.\n\nSo you need to create a travel plan that requires at most $F$ units of fuel, starts from Earth, visits each of the other planets exactly once, and then returns to Earth. If there are several such plans, you should find the one that consumes most fuel. Output the amount of fuel consumed.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case description starts with a line containing the number of planets $N$. The next line contains $N$ numbers $X_i$, the coordinates of the planets. The next line contains the amount of fuel $F$ that you have.\n", "outputFormat": "For each test case, output one line containing either \"Case #$x$: NO SOLUTION\", when there's no such travel plan, or \"Case #$x$: $y$\", where $x$ is the case number (starting from $1$) and $y$ is the maximum amount of fuel consumed.", "hint": "**Limits**\n\n- $1 \\leq F \\leq 10^{17}.$\n- $-10^{15} \\leq X_i \\leq 10^{15}.$\n- $X_1 = 0.$\n- All $X_i$ are different.\n\n**Small dataset (3 Pts, Test set 1 - Visible)**\n\n- $1 \\leq T \\leq 100.$\n- $2 \\leq N \\leq 10.$\n\n**Large dataset (30 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq T \\leq 20.$\n- $2 \\leq N \\leq 30.$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2010 Finals] Travel Plan", "background": null, "description": "在南极天文学家尚未公布且正在复查的一项发现中，据说在太空中有 $N$ 个有人居住的行星，这些行星都位于同一直线上，第 $i$ 个行星位于该直线上的坐标 $X_i$ 处（$i = 1, 2, ..., N$）。地球是第一个行星，位于坐标零处，因此 $X_1$ 总是等于 $0$。\n\n你对此感到非常兴奋，开始计划一次访问所有行星的旅行。由于未知的行星可能很危险，你希望每个行星只访问一次，然后返回地球。你有 $F$ 单位的燃料，并希望在这次旅行中尽可能多地消耗燃料，以便最终返回地球时更加安全。你的宇宙飞船非常基础，只能沿直线从任意行星 $i$ 飞到任意行星 $j$，途中会消耗 $|X_i - X_j|$ 单位的燃料。飞船不能在空中转向，必须降落后才能改变方向。\n\n因此，你需要制定一个旅行计划，要求消耗的燃料不超过 $F$ 单位，从地球出发，恰好访问每个其他行星一次，然后返回地球。如果存在多种这样的旅行方案，你应当找到消耗燃料最多的那一种。输出消耗的燃料量。", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行为行星数量 $N$。下一行为 $N$ 个数 $X_i$，表示各行星的坐标。下一行为你拥有的燃料量 $F$。", "outputFormat": "对于每个测试用例，输出一行。如果不存在这样的旅行方案，输出 \"Case #$x$: NO SOLUTION\"；否则输出 \"Case #$x$: $y$\"，其中 $x$ 表示测试用例编号（从 $1$ 开始），$y$ 表示最大消耗的燃料量。", "hint": "**数据范围**\n\n- $1 \\leq F \\leq 10^{17}$。\n- $-10^{15} \\leq X_i \\leq 10^{15}$。\n- $X_1 = 0$。\n- 所有 $X_i$ 坐标互不相同。\n\n**小数据范围（3 分，测试点 1 - 可见）**\n\n- $1 \\leq T \\leq 100$。\n- $2 \\leq N \\leq 10$。\n\n**大数据范围（30 分，测试点 2 - 隐藏）**\n\n- $1 \\leq T \\leq 20$。\n- $2 \\leq N \\leq 30$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13411", "type": "P", "difficulty": 7, "samples": [["6\n6 24\n0 0\n3 1\n12 4\n14 5\n13 7\n7 10\n2 1\n0 0\n2 0\n2 1\n0 0\n1 0\n2 10\n0 0\n4 0\n3 50\n0 0\n9 0\n10 0\n3 12\n0 0\n3 0\n3 4", "Case #1: 5\nCase #2: 0\nCase #3: 0\nCase #4: 2\nCase #5: 12\nCase #6: 3"]], "limits": {"time": [15000, 15000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "计算几何", "2010", "Google Code Jam"], "title": "[GCJ 2010 Finals] Ninjutsu", "background": "", "description": "Ninjutsu is the martial art of the mysterious Japanese assassins, ninja. As a beginner in the practice of ninjutsu, your first task is to master the use of the grappling hook.\n\nA grappling hook is a technologically-advanced device consisting of a hook tied to some (very strong and very thin) rope. Proper use of a grappling hook involves throwing the hook at a target and hoping that it catches.\n\nThis time, it did! You are now hooked onto a target that is located at $(0, 0)$. Your rope extends to the left, and you're at the end of it; when you jump, you will start swinging counter-clockwise around the target. There are other targets located to the right and above $(0, 0)$, at $(x_i, y_i)$ with $x_i \\geq 0$ and $y_i \\geq 0$. When an interior point of the rope (not either end) contacts one or more targets, the rope will bend around the target closest to its moving end. Ignore your starting velocity; because you are a ninja, it is fast enough that you will continue bending around targets until you are spinning around a single one.\n\nYour rope currently has length $R$, but you may choose to cut it down to any shorter length $r$ (including non-integers) before you start swinging. As such, you will start at $(-r, 0)$ and swing down (counter-clockwise) toward $(0, -r)$.\n\nWhat is the maximum number of bends you can put into the rope with one swing? A bend happens when your rope touches a target and then rotates some non-zero number of degrees around that target. The rope will always remain perfectly straight (again, this is possible because you are a ninja), except at bends.\n\n### Example\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vz7mq0hg.png)\n\nIn the example above, there are 6 points:\n\n* $(0, 0)$,\n* $(3, 1)$,\n* $(12, 4)$,\n* $(14, 5)$,\n* $(13, 7)$, and\n* $(7, 10)$.\n\nYou have a rope of length $24$. If you do not cut the rope, then you will bend around point $(12, 4)$, then around point $(14, 5)$, then around point $(13, 7)$, and finally, you will be stuck orbiting point $(7, 10)$ with about $0.1705$ units of rope remaining. This amounts to a total of $4$ bends. Although you touch point $(3, 1)$, it does not contribute a bend because it is collinear with the points $(0, 0)$ and $(12, 4)$.\n\nIf, however, you cut the rope by $0.18$ units, you will not have enough length to reach point $(7, 10)$ and will instead follow the path\n\n$(0, 0)$--$(12, 4)$--$(14, 5)$--$(13, 7)$--$(12, 4)$--$(14, 5)$\n\nand will end up orbiting point $(14, 5)$ with about $1.3004$ units of rope remaining. This path amounts to $5$ bends, in total, and is an optimal solution.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yp5e2kds.png)\n\nCase #1 in the sample input below represents this example.", "inputFormat": "The input will start with a line containing $T$, the number of test cases to follow. Each test case will start with two integers together on a line: $N$ and $R$. The next $N$ lines will each contain a pair of integers -- $x_i$ and $y_i$ -- the coordinates of the targets, starting with the target at $(0, 0)$.\n", "outputFormat": "For each test case, output a line of the form \"Case #$C$: $k$\", where $C$ is the 1-based case number, and $k$ is the maximum number of bends that can be made in the rope in one swing.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$\n- All target coordinates are integers.\n- All targets will be at different locations.\n- The first target listed will be located at $(0, 0)$.\n- There will be at least one value of $r$ that gives an optimal solution and has the property that a rope of length $r - 0.999999$ also gives the same solution (the same sequence of bends).\n\n**Small dataset (11 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 10$\n- $1 \\leq R \\leq 1,000$\n- $0 \\leq x_i \\leq 1,000$\n- $0 \\leq y_i \\leq 1,000$\n\n**Large dataset (23 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq N \\leq 1,000$\n- $1 \\leq R \\leq 10^9$\n- $0 \\leq x_i \\leq 10^9$\n- $0 \\leq y_i \\leq 10^9$", "locale": "en", "translations": {"en": {"title": "[GCJ 2010 Finals] Ninjutsu", "background": "", "description": "Ninjutsu is the martial art of the mysterious Japanese assassins, ninja. As a beginner in the practice of ninjutsu, your first task is to master the use of the grappling hook.\n\nA grappling hook is a technologically-advanced device consisting of a hook tied to some (very strong and very thin) rope. Proper use of a grappling hook involves throwing the hook at a target and hoping that it catches.\n\nThis time, it did! You are now hooked onto a target that is located at $(0, 0)$. Your rope extends to the left, and you're at the end of it; when you jump, you will start swinging counter-clockwise around the target. There are other targets located to the right and above $(0, 0)$, at $(x_i, y_i)$ with $x_i \\geq 0$ and $y_i \\geq 0$. When an interior point of the rope (not either end) contacts one or more targets, the rope will bend around the target closest to its moving end. Ignore your starting velocity; because you are a ninja, it is fast enough that you will continue bending around targets until you are spinning around a single one.\n\nYour rope currently has length $R$, but you may choose to cut it down to any shorter length $r$ (including non-integers) before you start swinging. As such, you will start at $(-r, 0)$ and swing down (counter-clockwise) toward $(0, -r)$.\n\nWhat is the maximum number of bends you can put into the rope with one swing? A bend happens when your rope touches a target and then rotates some non-zero number of degrees around that target. The rope will always remain perfectly straight (again, this is possible because you are a ninja), except at bends.\n\n### Example\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vz7mq0hg.png)\n\nIn the example above, there are 6 points:\n\n* $(0, 0)$,\n* $(3, 1)$,\n* $(12, 4)$,\n* $(14, 5)$,\n* $(13, 7)$, and\n* $(7, 10)$.\n\nYou have a rope of length $24$. If you do not cut the rope, then you will bend around point $(12, 4)$, then around point $(14, 5)$, then around point $(13, 7)$, and finally, you will be stuck orbiting point $(7, 10)$ with about $0.1705$ units of rope remaining. This amounts to a total of $4$ bends. Although you touch point $(3, 1)$, it does not contribute a bend because it is collinear with the points $(0, 0)$ and $(12, 4)$.\n\nIf, however, you cut the rope by $0.18$ units, you will not have enough length to reach point $(7, 10)$ and will instead follow the path\n\n$(0, 0)$--$(12, 4)$--$(14, 5)$--$(13, 7)$--$(12, 4)$--$(14, 5)$\n\nand will end up orbiting point $(14, 5)$ with about $1.3004$ units of rope remaining. This path amounts to $5$ bends, in total, and is an optimal solution.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yp5e2kds.png)\n\nCase #1 in the sample input below represents this example.", "inputFormat": "The input will start with a line containing $T$, the number of test cases to follow. Each test case will start with two integers together on a line: $N$ and $R$. The next $N$ lines will each contain a pair of integers -- $x_i$ and $y_i$ -- the coordinates of the targets, starting with the target at $(0, 0)$.\n", "outputFormat": "For each test case, output a line of the form \"Case #$C$: $k$\", where $C$ is the 1-based case number, and $k$ is the maximum number of bends that can be made in the rope in one swing.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$\n- All target coordinates are integers.\n- All targets will be at different locations.\n- The first target listed will be located at $(0, 0)$.\n- There will be at least one value of $r$ that gives an optimal solution and has the property that a rope of length $r - 0.999999$ also gives the same solution (the same sequence of bends).\n\n**Small dataset (11 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 10$\n- $1 \\leq R \\leq 1,000$\n- $0 \\leq x_i \\leq 1,000$\n- $0 \\leq y_i \\leq 1,000$\n\n**Large dataset (23 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq N \\leq 1,000$\n- $1 \\leq R \\leq 10^9$\n- $0 \\leq x_i \\leq 10^9$\n- $0 \\leq y_i \\leq 10^9$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2010 Finals] Ninjutsu", "background": null, "description": "忍术是神秘的日本刺客——忍者——的武术。作为忍术初学者，你的第一个任务是掌握抓钩的使用。\n\n抓钩是一种技术先进的装置，由一根（非常坚固且非常细的）绳子系着一个钩子组成。正确使用抓钩的方法是将钩子投向目标，并希望它能够勾住目标。\n\n这一次，你成功了！你现在已经勾住了位于 $(0, 0)$ 的目标。你的绳子向左延伸，你正处于绳子的末端；当你跳起时，你会开始围绕目标逆时针摆动。还有其他目标位于 $(0, 0)$ 的右侧和上方，坐标为 $(x_i, y_i)$，其中 $x_i \\geq 0$ 且 $y_i \\geq 0$。当绳子的内部某一点（不是两端）接触到一个或多个目标时，绳子会围绕距离其运动端最近的目标弯折。忽略你的初始速度；因为你是忍者，你的速度足够快，你会不断围绕目标弯折，直到你只围绕一个目标旋转。\n\n你当前的绳子长度为 $R$，但你可以选择在开始摆动前将其剪短为任意更短的长度 $r$（包括非整数长度）。因此，你将从 $(-r, 0)$ 出发，向下（逆时针）摆动至 $(0, -r)$。\n\n你能在一次摆动中让绳子最多弯折多少次？每当你的绳子触碰到一个目标，并且随后围绕该目标旋转了非零角度时，就算作一次弯折。绳子始终保持完全笔直（这同样是因为你是忍者），除了在弯折处。\n\n### 示例\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vz7mq0hg.png)\n\n在上面的例子中，有 6 个点：\n\n- $(0, 0)$，\n- $(3, 1)$，\n- $(12, 4)$，\n- $(14, 5)$，\n- $(13, 7)$，\n- $(7, 10)$。\n\n你有一根长度为 $24$ 的绳子。如果你不剪短绳子，那么你会依次围绕点 $(12, 4)$、$(14, 5)$、$(13, 7)$ 弯折，最后会被困在点 $(7, 10)$ 附近旋转，剩余绳长约为 $0.1705$。这样总共发生了 $4$ 次弯折。虽然你会触碰到点 $(3, 1)$，但由于它与点 $(0, 0)$ 和 $(12, 4)$ 共线，因此不算作一次弯折。\n\n然而，如果你将绳子剪短 $0.18$ 个单位长度，你将无法到达点 $(7, 10)$，而是会按照以下路径移动：\n\n$(0, 0)$--$(12, 4)$--$(14, 5)$--$(13, 7)$--$(12, 4)$--$(14, 5)$\n\n最终会在点 $(14, 5)$ 附近旋转，剩余绳长约为 $1.3004$。这个路径总共发生了 $5$ 次弯折，是最优解。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yp5e2kds.png)\n\n下面的样例输入中的第 1 组数据对应上述例子。", "inputFormat": "输入的第一行为一个整数 $T$，表示接下来的测试用例数量。每组测试用例的第一行为两个整数 $N$ 和 $R$。接下来的 $N$ 行，每行包含一对整数 $x_i$ 和 $y_i$，表示目标的坐标，第一组坐标为 $(0, 0)$。", "outputFormat": "对于每组测试用例，输出一行，格式为 \"Case #$C$: $k$\"，其中 $C$ 为测试用例编号（从 1 开始），$k$ 为一次摆动中最多能发生的弯折次数。", "hint": "**数据范围**\n\n- $1 \\leq T \\leq 100$\n- 所有目标坐标均为整数。\n- 所有目标位置均不相同。\n- 第一组目标坐标为 $(0, 0)$。\n- 至少存在一个 $r$，使得以长度 $r - 0.999999$ 的绳子也能得到最优解（即弯折序列相同）。\n\n**小数据（11 分，测试点 1 - 可见）**\n\n- $1 \\leq N \\leq 10$\n- $1 \\leq R \\leq 1,000$\n- $0 \\leq x_i \\leq 1,000$\n- $0 \\leq y_i \\leq 1,000$\n\n**大数据（23 分，测试点 2 - 隐藏）**\n\n- $1 \\leq N \\leq 1,000$\n- $1 \\leq R \\leq 10^9$\n- $0 \\leq x_i \\leq 10^9$\n- $0 \\leq y_i \\leq 10^9$\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13412", "type": "P", "difficulty": 7, "samples": [["3\n4 4\n4 6\n5 5", "Case #1: 24\nCase #2: 44\nCase #3: 48"]], "limits": {"time": [15000, 60000], "memory": [1048576, 1048576]}, "tags": ["2010", "Ad-hoc", "Google Code Jam"], "title": "[GCJ 2010 Finals] The Paths of Yin Yang", "background": "> So, If and Else grow out of each other;    \n> Hardness and Tractability complete each other;    \n> Long int and Short int shape each other;    \n> High bits and Low bits determine each other;    \n> Music and Voice give harmony to each other;    \n> Push_front and Push_back give sequence to each other.    \n-- Tao Te Ching, Laozi, Zhou dynasty, ancient China.    \n    Translated (loosely) by yours truly.", "description": "Given an rectangular grid of $N$ rows and $M$ columns, each cell can be labeled black (Yin) or white (Yang). Two cells are neighbors if they share a common unit-length edge segment. The grid is valid if all the black cells form a path, and all the white cells form a path. A path is a set $s$ of cells defined as follows:\n\n* The cells form a connected piece. From each cell in $s$, you can reach any other cell in $s$ by moving between neighbors within $s$.\n* Exactly two cells in $s$ have exactly one neighbor in $s$ each. These are the \"ends\" of the path.\n* Every other cell in $s$ has exactly two neighbors in $s$.\n\nFor example, in the picture below, the first grid is valid, while the second grid is not -- although the black cells form a path, the white cells do not.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2sonlyt9.png)\n\nGiven $N$ and $M$, compute the number of valid grids. Note that symmetry doesn't matter -- as long as two valid grids differ in one position they are considered different, even if one can be rotated or flipped to the other.", "inputFormat": "The first line of the input will be a single integer $T$, the number of test cases. $T$ lines follow, each of which contains two integers separated by a space: \"$N$ $M$\", as defined above.\n", "outputFormat": "For each test case, output a line in the form \"Case #$x$: $A$\", where $x$ is the case number, starting from 1, and $A$ is the number of valid grids of the specified size.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 50$\n\n**Small dataset (Test set 1 - Visible)**\n\n- Time limit: ~~30~~ 15 seconds per test set.\n- $4 \\leq N, M \\leq 10$\n\n**Large dataset (Test set 2 - Hidden)**\n\n- Time limit: ~~120~~ 60 seconds per test set.\n- For 80% of the test cases, $4 \\leq N, M \\leq 50$\n- For 90% of the test cases, $4 \\leq N, M \\leq 70$\n- For all test cases, $4 \\leq N, M \\leq 100$", "locale": "en", "translations": {"en": {"title": "[GCJ 2010 Finals] The Paths of Yin Yang", "background": "> So, If and Else grow out of each other;    \n> Hardness and Tractability complete each other;    \n> Long int and Short int shape each other;    \n> High bits and Low bits determine each other;    \n> Music and Voice give harmony to each other;    \n> Push_front and Push_back give sequence to each other.    \n-- Tao Te Ching, Laozi, Zhou dynasty, ancient China.    \n    Translated (loosely) by yours truly.", "description": "Given an rectangular grid of $N$ rows and $M$ columns, each cell can be labeled black (Yin) or white (Yang). Two cells are neighbors if they share a common unit-length edge segment. The grid is valid if all the black cells form a path, and all the white cells form a path. A path is a set $s$ of cells defined as follows:\n\n* The cells form a connected piece. From each cell in $s$, you can reach any other cell in $s$ by moving between neighbors within $s$.\n* Exactly two cells in $s$ have exactly one neighbor in $s$ each. These are the \"ends\" of the path.\n* Every other cell in $s$ has exactly two neighbors in $s$.\n\nFor example, in the picture below, the first grid is valid, while the second grid is not -- although the black cells form a path, the white cells do not.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2sonlyt9.png)\n\nGiven $N$ and $M$, compute the number of valid grids. Note that symmetry doesn't matter -- as long as two valid grids differ in one position they are considered different, even if one can be rotated or flipped to the other.", "inputFormat": "The first line of the input will be a single integer $T$, the number of test cases. $T$ lines follow, each of which contains two integers separated by a space: \"$N$ $M$\", as defined above.\n", "outputFormat": "For each test case, output a line in the form \"Case #$x$: $A$\", where $x$ is the case number, starting from 1, and $A$ is the number of valid grids of the specified size.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 50$\n\n**Small dataset (Test set 1 - Visible)**\n\n- Time limit: ~~30~~ 15 seconds per test set.\n- $4 \\leq N, M \\leq 10$\n\n**Large dataset (Test set 2 - Hidden)**\n\n- Time limit: ~~120~~ 60 seconds per test set.\n- For 80% of the test cases, $4 \\leq N, M \\leq 50$\n- For 90% of the test cases, $4 \\leq N, M \\leq 70$\n- For all test cases, $4 \\leq N, M \\leq 100$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2010 Finals] The Paths of Yin Yang", "background": "> 故有无相生，    \n> 难易相成，    \n> 长短相形，    \n> 高下相倾，    \n> 音声相和，    \n> 前后相随。    \n> ——《道德经》老子，周朝，中国古代    ", "description": "给定一个 $N$ 行 $M$ 列的矩形网格，每个格子可以标记为黑色（阴）或白色（阳）。如果两个格子共享一条单位长度的边，则它们是相邻的。如果所有黑色格子构成一条路径，且所有白色格子也构成一条路径，则称该网格是合法的。路径是指满足以下条件的格子集合 $s$：\n\n- 这些格子连成一块。从 $s$ 中的任意一个格子出发，只通过 $s$ 内的相邻格子可以到达 $s$ 中的任意一个格子。\n- 恰好有两个格子在 $s$ 中只有一个相邻格子（即“端点”）。\n- $s$ 中的其他每个格子都有恰好两个相邻格子。\n\n例如，下图中，第一个网格是合法的，而第二个网格不是——虽然黑色格子构成了一条路径，但白色格子没有。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2sonlyt9.png)\n\n给定 $N$ 和 $M$，计算合法网格的数量。注意，对称性不影响结果——只要两个合法网格在某个位置不同，即使一个可以通过旋转或翻转变为另一个，也认为它们是不同的。", "inputFormat": "输入的第一行为一个整数 $T$，表示测试用例的数量。接下来的 $T$ 行，每行包含两个用空格分隔的整数：“$N$ $M$”，如上所述。", "outputFormat": "对于每个测试用例，输出一行，格式为 “Case #$x$: $A$”，其中 $x$ 是测试用例编号（从 1 开始），$A$ 是指定大小网格的合法方案数。", "hint": "**数据范围**\n\n- $1 \\leq T \\leq 50$\n\n**小数据集（测试集 1 - 可见）**\n\n- 时间限制：~~30~~ 15 秒每组数据。\n- $4 \\leq N, M \\leq 10$\n\n**大数据集（测试集 2 - 隐藏）**\n\n- 时间限制：~~120~~ 60 秒每组数据。\n- 对于 80% 的测试用例，$4 \\leq N, M \\leq 50$\n- 对于 90% 的测试用例，$4 \\leq N, M \\leq 70$\n- 对于所有测试用例，$4 \\leq N, M \\leq 100$\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13413", "type": "P", "difficulty": 2, "samples": [["10\n3\n2 4\n7 8\n6 9", "3\n1"], ["10\n3\n1 3\n5 7\n8 9", "1\n1"], ["10\n5\n1 1\n1 2\n1 3\n1 4\n7 8", "4\n5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["模拟", "2012", "Special Judge", "COCI（克罗地亚）"], "title": "[COCI 2012/2013 #4] OREHNJACA", "background": "", "description": "These days, the TV studio has started shooting another new season of Jamie Oliver's cooking show. This season, Jamie plans to introduce the delights of Croatian cuisine to the world. In the first episode, the master chef has baked a walnut roll $L$ meters long, the longest ever baked in this part of the world. After hours of sweating and toiling in the kitchen, he has decided to reward each one of his $N$ faithful spectators in the studio.\n\nHe has chopped the walnut roll into one meter long chops and marked them with numbers from $1$ do $L$, from left to right. Each spectator has received a unique number ID (a positive integer from $1$ to $N$), as well as a paper with two integers, $P$ and $K$. Each spectator was then allowed to take all chops from the $P$-th to the $K$-th, inclusive. Spectators were allowed to take their share in order of their ID numbers (spectator $1$ first, followed by spectator $2$, etc.). This order resulted in some spectators receiving fewer chops than they initially thought they would get. The following image corresponds to the first example test case:\n\n| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |\n|---|---|---|---|---|---|---|---|---|----|\n|   | 1 | 1 | 1 |   | 3 | 2 | 2 | 3 |    |\n\nWrite a program to determine which spectator expected to get the most walnut roll chops, and which spectator actually got the most.\n", "inputFormat": "The first line of input contains the positive integer $L$ ($1 \\leq L \\leq 1000$), the length of the walnut roll.\n\nThe second line of input contains the positive integer $N$ ($1 \\leq N \\leq 1000$), the number of spectators.\n\nEach of the following $N$ lines contains two positive integers $P_i$ and $K_i$ ($1 \\leq P_i \\leq K_i \\leq L$, $i = 1..N$), the values $P$ and $K$ as described in the problem statement for spectator number $i$.\n", "outputFormat": "The first line of output must contain the ID number of the spectator who was expecting to receive the most walnut roll chops.\n\nThe second line of output must contain the ID number of the spectator who actually received the most walnut roll chops in the end.\n\nIn both cases, if there is more than one spectator satisfying the condition, output the one with the smallest ID.\n", "hint": "If the first number is correct, the solution is awarded 60% of points for that test case, and if the second number is correct, the solution is awarded 40% of points for that test case.", "locale": "en", "translations": {"en": {"title": "[COCI 2012/2013 #4] OREHNJACA", "background": "", "description": "These days, the TV studio has started shooting another new season of Jamie Oliver's cooking show. This season, Jamie plans to introduce the delights of Croatian cuisine to the world. In the first episode, the master chef has baked a walnut roll $L$ meters long, the longest ever baked in this part of the world. After hours of sweating and toiling in the kitchen, he has decided to reward each one of his $N$ faithful spectators in the studio.\n\nHe has chopped the walnut roll into one meter long chops and marked them with numbers from $1$ do $L$, from left to right. Each spectator has received a unique number ID (a positive integer from $1$ to $N$), as well as a paper with two integers, $P$ and $K$. Each spectator was then allowed to take all chops from the $P$-th to the $K$-th, inclusive. Spectators were allowed to take their share in order of their ID numbers (spectator $1$ first, followed by spectator $2$, etc.). This order resulted in some spectators receiving fewer chops than they initially thought they would get. The following image corresponds to the first example test case:\n\n| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |\n|---|---|---|---|---|---|---|---|---|----|\n|   | 1 | 1 | 1 |   | 3 | 2 | 2 | 3 |    |\n\nWrite a program to determine which spectator expected to get the most walnut roll chops, and which spectator actually got the most.\n", "inputFormat": "The first line of input contains the positive integer $L$ ($1 \\leq L \\leq 1000$), the length of the walnut roll.\n\nThe second line of input contains the positive integer $N$ ($1 \\leq N \\leq 1000$), the number of spectators.\n\nEach of the following $N$ lines contains two positive integers $P_i$ and $K_i$ ($1 \\leq P_i \\leq K_i \\leq L$, $i = 1..N$), the values $P$ and $K$ as described in the problem statement for spectator number $i$.\n", "outputFormat": "The first line of output must contain the ID number of the spectator who was expecting to receive the most walnut roll chops.\n\nThe second line of output must contain the ID number of the spectator who actually received the most walnut roll chops in the end.\n\nIn both cases, if there is more than one spectator satisfying the condition, output the one with the smallest ID.\n", "hint": "If the first number is correct, the solution is awarded 60% of points for that test case, and if the second number is correct, the solution is awarded 40% of points for that test case.", "locale": "en"}, "zh-CN": {"title": "[COCI 2012/2013 #4] OREHNJACA", "background": "", "description": "最近，电视台开始录制新一季的 **Jamie Oliver** 烹饪节目。本季中，Jamie 计划向全世界展示克罗地亚美食的魅力。在第一期节目中，这位大厨烘焙了一条长达 $L$ 米的核桃卷，这是该地区有史以来最长的核桃卷。经过长时间的辛勤烹饪，他决定奖励在场的 $N$ 位忠实观众。\n\n他将核桃卷切成每段 $1$ 米的小段，并从左到右依次编号为 $1$ 到 $L$。每位观众都获得了一个唯一的编号 ID（从 $1$ 到 $N$ 的正整数），以及一张写有两个整数 $P$ 和 $K$ 的纸条。每位观众随后可以领取从第 $P$ 段到第 $K$ 段（包含两端）的所有核桃卷。观众按照 ID 编号的顺序依次领取（编号为 $1$ 的观众先领，然后是编号为 $2$ 的观众，依此类推）。由于领取顺序的影响，有些观众实际拿到的核桃卷段数比他们原本预计的要少。下表对应于第一个样例测试：\n\n| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |\n|---|---|---|---|---|---|---|---|---|----|\n|   | 1 | 1 | 1 |   | 3 | 2 | 2 | 3 |    |\n\n请编写程序，确定哪位观众**期望**获得最多的核桃卷段，以及哪位观众**实际**获得的核桃卷段最多。", "inputFormat": "输入的第一行包含一个正整数 $L$（$1 \\leq L \\leq 1000$），表示核桃卷的长度。\n\n第二行包含一个正整数 $N$（$1 \\leq N \\leq 1000$），表示观众人数。\n\n接下来 $N$ 行，每行包含两个正整数 $P_i$ 和 $K_i$（$1 \\leq P_i \\leq K_i \\leq L$，$i = 1..N$），分别表示第 $i$ 位观众纸条上的 $P$ 和 $K$。\n", "outputFormat": "输出两行。\n\n第一行输出**期望**获得核桃卷段数最多的观众编号。\n\n第二行输出**实际**获得核桃卷段数最多的观众编号。\n\n如有多名观众满足条件，输出编号最小的那一位。", "hint": "如果第一行输出正确，则该测试点可获得 60% 分数；如果第二行输出正确，则该测试点可获得 40% 分数。\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13414", "type": "P", "difficulty": 2, "samples": [["3\nABAB\nAABB\nABBA", "2"], ["3\nAAA\nAA\nAB", "1"], ["1\nABBABB", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["2012", "栈", "COCI（克罗地亚）"], "title": "[COCI 2012/2013 #4] ESEJ", "background": "", "description": "Mirko's latest homework assignment is writing an essay. However, he finds writing essays so boring that, after working for two hours, he realized that all he has written are $N$ long words consisting entirely of letters $A$ and $B$. Having accepted that he will never finish the essay in time, poor Mirko has decided to at least have some fun with it by counting nice words.\n\nMirko is connecting pairs of identical letters ($A$ with $A$, $B$ with $B$) by drawing arches above the word. A given word is nice if each letter can be connected to exactly one other letter in such a way that no two arches intersect. Help Mirko count how many words are nice.\n", "inputFormat": "The first line of input contains the positive integer $N$ ($1 \\leq N \\leq 100$), the number of words written down by Mirko.\n\nEach of the following $N$ lines contains a single word consisting of letters $A$ and $B$, with length between $2$ and $100\\,000$, inclusive. The sum of lengths of all words doesn't exceed $1\\,000\\,000$.\n", "outputFormat": "The first and only line of output must contain the number of nice words.", "hint": "", "locale": "en", "translations": {"en": {"title": "[COCI 2012/2013 #4] ESEJ", "background": "", "description": "Mirko's latest homework assignment is writing an essay. However, he finds writing essays so boring that, after working for two hours, he realized that all he has written are $N$ long words consisting entirely of letters $A$ and $B$. Having accepted that he will never finish the essay in time, poor Mirko has decided to at least have some fun with it by counting nice words.\n\nMirko is connecting pairs of identical letters ($A$ with $A$, $B$ with $B$) by drawing arches above the word. A given word is nice if each letter can be connected to exactly one other letter in such a way that no two arches intersect. Help Mirko count how many words are nice.\n", "inputFormat": "The first line of input contains the positive integer $N$ ($1 \\leq N \\leq 100$), the number of words written down by Mirko.\n\nEach of the following $N$ lines contains a single word consisting of letters $A$ and $B$, with length between $2$ and $100\\,000$, inclusive. The sum of lengths of all words doesn't exceed $1\\,000\\,000$.\n", "outputFormat": "The first and only line of output must contain the number of nice words.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[COCI 2012/2013 #4] ESEJ", "background": "", "description": "Mirko 最近的家庭作业是写一篇作文。然而，他觉得写作文太无聊了，于是在写了两个小时后，他发现自己只写了 $N$ 个只由字母 $A$ 和 $B$ 组成的长单词。Mirko 已经接受了自己无法按时完成作文的事实，于是他决定至少让自己在作文里找点乐趣，比如统计“好单词”的数量。\n\nMirko 会通过在单词上方画弧，将成对的相同字母（$A$ 对 $A$，$B$ 对 $B$）连接起来。如果一个单词满足：可以将每个字母与恰好一个相同字母配对，并且所有的弧都不会相交，那么这个单词就是“好单词”。请帮助 Mirko 统计有多少个“好单词”。\n", "inputFormat": "第一行输入一个正整数 $N$（$1 \\leq N \\leq 100$），表示 Mirko 写下的单词数。\n\n接下来的 $N$ 行，每行输入一个只包含字母 $A$ 和 $B$ 的单词，长度在 $2$ 到 $100\\,000$ 之间。所有单词的总长度不超过 $1\\,000\\,000$。\n", "outputFormat": "输出一行，表示“好单词”的数量。", "hint": "翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
