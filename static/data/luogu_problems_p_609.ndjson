{"pid": "P13355", "type": "P", "difficulty": 5, "samples": [["5\n2 1\n3 1\n3 2\n4 1\n4 3", "2\n1\n3\n2\n4"], ["6\n7 1\n7 2\n7 3\n7 4\n7 5\n7 6", "1\n7\n7\n7\n5\n3"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["数学", "递推", "2024", "广东", "分类讨论", "省赛/邀请赛"], "title": "[GDCPC 2024] 循环赛", "background": "数据、标程、题解等资源的获取：<https://gitlink.org.cn/thusaa/gdcpc2024>", "description": "`T` 协会的主席大 `G` 决定选出一位小 `g` 继任 `T` 协会的主席之位。为了保证公平性，他任命小 `c` 担任监督。\n\n考虑到 `T` 协会的小 `g` 们不是很多，小 `c` 决定通过最简单的方式决出胜者：让这 $n$ 个小 `g` 两两进行一场没有平局的对决，胜者获得一分，败者则不获得的分数。\n\n在比赛结束、统计分数的时候，小 `c` 发现了关于本次 $\\frac{n(n-1)}{2}$ 场对决的 “$z$-`gg` 定律”，即在任意 $z+1$ 个小 `g` 中，总存在一个小 `g` 能打败其余 $z$ 个小 `g`，**同时**存在另一个小 `g` 被其余 $z$ 个小 `g` 打败。\n\n由于某些来自 `T` 协会的神秘因素，小 `c` 突然想知道在所有符合上述 “$z$-`gg` 定律” 的对决中，$n$ 个小 `g` **最少**有多少种不同的得分？由于小 `c` 忙(bu)于(shi)统(te)计(bie)数(cong)据(ming)，所以她决定将这个问题交给你来回答。", "inputFormat": "本题有多组数据。\n\n第一行包含一个整数 $T(1\\le T\\le 3\\times 10^5)$ 表示数据组数。\n\n接下来 $T$ 行，每行两个正整数 $n,z(1\\le z<n\\le 10^{18})$ 如题面所述。", "outputFormat": "$T$ 行，每行一个正整数表示答案。", "hint": "### 样例 1 解释\n\n对 $n=2, z=1$，显然此时两个小 `g` 得分必然一个是 $1$，另一个是 $0$，故答案为 $2$。\n\n对 $n=3, z=1$，`1=>2, 2=>3, 3=>1` （`a=>b` 表示 “a 打败 b”，下同）满足定律，且每个人得分均为 $1$ 分；\n\n对 $n=3, z=2$，由对称性以及题设定律，不妨设 `1` 和 `3` 是 $3$ 个小 `g` 中的全胜和全败者，那么这场比赛必定为 `1=>2, 1=>3, 2=>3`，此时三人得分依次为 $2, 1, 0$，故答案为 $3$。\n\n对 $n=4, z=1$，`1=>3, 1=>4, 2=>1, 2=>3, 3=>4, 4=>2` 中四人得分依次为 $2, 2, 1, 1$，并且由于四人得分之和 $\\frac{4\\times 3}{2}=6$ 不是 $4$ 的倍数，故四人得分不可能完全一致，故答案为 $2$。\n\n对 $n=4, z=3$，仍设四人中全胜和全败者为 `1` 和 `4`，则此时 `2`、`3` 两人得分之和为 $6 - 3 - 0 = 3$，因此二者得分只能为 $2, 1$ 或者 $3, 0$；又显然不可能同时有两个得分为 $3$ 分者，故此时 `2` 和 `3` 的得分必为 $2, 1$，故答案为 $4$。\n\n### 提示\n\n本题并不难。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GDCPC 2024] 循环赛", "background": "数据、标程、题解等资源的获取：<https://gitlink.org.cn/thusaa/gdcpc2024>", "description": "`T` 协会的主席大 `G` 决定选出一位小 `g` 继任 `T` 协会的主席之位。为了保证公平性，他任命小 `c` 担任监督。\n\n考虑到 `T` 协会的小 `g` 们不是很多，小 `c` 决定通过最简单的方式决出胜者：让这 $n$ 个小 `g` 两两进行一场没有平局的对决，胜者获得一分，败者则不获得的分数。\n\n在比赛结束、统计分数的时候，小 `c` 发现了关于本次 $\\frac{n(n-1)}{2}$ 场对决的 “$z$-`gg` 定律”，即在任意 $z+1$ 个小 `g` 中，总存在一个小 `g` 能打败其余 $z$ 个小 `g`，**同时**存在另一个小 `g` 被其余 $z$ 个小 `g` 打败。\n\n由于某些来自 `T` 协会的神秘因素，小 `c` 突然想知道在所有符合上述 “$z$-`gg` 定律” 的对决中，$n$ 个小 `g` **最少**有多少种不同的得分？由于小 `c` 忙(bu)于(shi)统(te)计(bie)数(cong)据(ming)，所以她决定将这个问题交给你来回答。", "inputFormat": "本题有多组数据。\n\n第一行包含一个整数 $T(1\\le T\\le 3\\times 10^5)$ 表示数据组数。\n\n接下来 $T$ 行，每行两个正整数 $n,z(1\\le z<n\\le 10^{18})$ 如题面所述。", "outputFormat": "$T$ 行，每行一个正整数表示答案。", "hint": "### 样例 1 解释\n\n对 $n=2, z=1$，显然此时两个小 `g` 得分必然一个是 $1$，另一个是 $0$，故答案为 $2$。\n\n对 $n=3, z=1$，`1=>2, 2=>3, 3=>1` （`a=>b` 表示 “a 打败 b”，下同）满足定律，且每个人得分均为 $1$ 分；\n\n对 $n=3, z=2$，由对称性以及题设定律，不妨设 `1` 和 `3` 是 $3$ 个小 `g` 中的全胜和全败者，那么这场比赛必定为 `1=>2, 1=>3, 2=>3`，此时三人得分依次为 $2, 1, 0$，故答案为 $3$。\n\n对 $n=4, z=1$，`1=>3, 1=>4, 2=>1, 2=>3, 3=>4, 4=>2` 中四人得分依次为 $2, 2, 1, 1$，并且由于四人得分之和 $\\frac{4\\times 3}{2}=6$ 不是 $4$ 的倍数，故四人得分不可能完全一致，故答案为 $2$。\n\n对 $n=4, z=3$，仍设四人中全胜和全败者为 `1` 和 `4`，则此时 `2`、`3` 两人得分之和为 $6 - 3 - 0 = 3$，因此二者得分只能为 $2, 1$ 或者 $3, 0$；又显然不可能同时有两个得分为 $3$ 分者，故此时 `2` 和 `3` 的得分必为 $2, 1$，故答案为 $4$。\n\n### 提示\n\n本题并不难。", "locale": "zh-CN"}}}
{"pid": "P13356", "type": "P", "difficulty": 6, "samples": [["3\n3 1\n1 3\n4 7\n1 2\n2 3\n3 4\n4 1\n1 3\n2 4\n1 4\n5 5\n1 2\n2 3\n3 4\n4 5\n3 5", "1 3\n2 1 3\n1 4\n4 1 2 3 4\n2 1 4\n2 1 4\n3 5\n3 3 4 5\n2 3 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "二分", "2024", "广东", "Special Judge", "生成树", "省赛/邀请赛"], "title": "[GDCPC 2024] 图", "background": "数据、标程、题解等资源的获取：<https://gitlink.org.cn/thusaa/gdcpc2024>", "description": "给定一张 $n$ 个点 $m$ 条边的无向图，令 $k=\\lceil\\frac{m}{n-1}\\rceil$，你需要判断能否找到两个不同的点 $u,v$，满足它们之间存在 $k$ 条**边不相交**路径，如果可以找到这样的 $u,v$，你需要输出这些路径，如果存在多种构造方案，输出任意一种即可。\n\n额外需要注意的是输入**可能存在重边**，也就是对于同一个无序对 $(u,v)$，它们之间可能存在多条边，如果它们之间存在 $s$ 条边那么你可以理解为这条边可以经过 $s$ 次。\n\n不过我们保证输入**不存在自环**。", "inputFormat": "**本题包含多组输入数据。**\n\n输入第一行一个正整数 $T(1\\le T\\le 10^4)$ 表示数据组数。\n\n对于每组输入数据，第一行输入两个正整数 $n,m(2\\le n\\le 10^5,1\\le m\\le 2\\times 10^5)$ 表示点数和边数，接下来 $m$ 行每行两个正整数 $u,v(1\\le u,v\\le n,u\\not=v)$ 描述 $u,v$​ 间存在的一条边。\n\n保证 $\\sum n\\le 10^5$，$\\sum m\\le 2\\times 10^5$。其中 $\\sum n,\\sum m$ 分别表示同一个测试点内所有输入数据的 $n,m$ 之和。", "outputFormat": "对于每组输入数据，如果不存在这样的 $u,v$，那么输出一行一个整数 `-1`，否则先输出一行两个正整数 $u,v$ 表示你找到的两个点，接下来输出 $k=\\lceil\\frac{m}{n-1}\\rceil$ 行，每行第一个正整数 $t$ 描述你选出来的路径长度，接下来 $t$ 个正整数 $x_1,x_2,\\dots,x_t$，表示你选择了 $x_1\\to x_2\\to\\cdots\\to x_t$ 这条路径，你需要保证 $x_1=u$ 且 $x_t=v$。且你需要保证输出的 $k$ 条路径满足边不相交的条件。", "hint": "第一组输入数据，存在 $\\lceil\\frac{m}{n-1}\\rceil=\\lceil\\frac{1}{3-1}\\rceil=1$ 条 $1$ 到 $3$ 的边不相交路径 $1\\to 3$。\n\n第二组输入数据，存在 $\\lceil\\frac{m}{n-1}\\rceil=\\lceil\\frac{7}{4-1}\\rceil=3$ 条 $1$ 到 $4$ 的边不相交路径 $1\\to 2\\to 3\\to 4,1\\to 4,1\\to 4$，注意到 $1\\to 4$ 这条边虽然经过了两次，但是在原输入中这条边也输入了两次，所以认为它们还是不同的边。\n\n第三组输入数据，存在 $\\lceil\\frac{m}{n-1}\\rceil=\\lceil\\frac{5}{5-1}\\rceil=2$ 条 $3$ 到 $5$ 的边不相交路径 $3\\to 4\\to 5,3\\to 5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GDCPC 2024] 图", "background": "数据、标程、题解等资源的获取：<https://gitlink.org.cn/thusaa/gdcpc2024>", "description": "给定一张 $n$ 个点 $m$ 条边的无向图，令 $k=\\lceil\\frac{m}{n-1}\\rceil$，你需要判断能否找到两个不同的点 $u,v$，满足它们之间存在 $k$ 条**边不相交**路径，如果可以找到这样的 $u,v$，你需要输出这些路径，如果存在多种构造方案，输出任意一种即可。\n\n额外需要注意的是输入**可能存在重边**，也就是对于同一个无序对 $(u,v)$，它们之间可能存在多条边，如果它们之间存在 $s$ 条边那么你可以理解为这条边可以经过 $s$ 次。\n\n不过我们保证输入**不存在自环**。", "inputFormat": "**本题包含多组输入数据。**\n\n输入第一行一个正整数 $T(1\\le T\\le 10^4)$ 表示数据组数。\n\n对于每组输入数据，第一行输入两个正整数 $n,m(2\\le n\\le 10^5,1\\le m\\le 2\\times 10^5)$ 表示点数和边数，接下来 $m$ 行每行两个正整数 $u,v(1\\le u,v\\le n,u\\not=v)$ 描述 $u,v$​ 间存在的一条边。\n\n保证 $\\sum n\\le 10^5$，$\\sum m\\le 2\\times 10^5$。其中 $\\sum n,\\sum m$ 分别表示同一个测试点内所有输入数据的 $n,m$ 之和。", "outputFormat": "对于每组输入数据，如果不存在这样的 $u,v$，那么输出一行一个整数 `-1`，否则先输出一行两个正整数 $u,v$ 表示你找到的两个点，接下来输出 $k=\\lceil\\frac{m}{n-1}\\rceil$ 行，每行第一个正整数 $t$ 描述你选出来的路径长度，接下来 $t$ 个正整数 $x_1,x_2,\\dots,x_t$，表示你选择了 $x_1\\to x_2\\to\\cdots\\to x_t$ 这条路径，你需要保证 $x_1=u$ 且 $x_t=v$。且你需要保证输出的 $k$ 条路径满足边不相交的条件。", "hint": "第一组输入数据，存在 $\\lceil\\frac{m}{n-1}\\rceil=\\lceil\\frac{1}{3-1}\\rceil=1$ 条 $1$ 到 $3$ 的边不相交路径 $1\\to 3$。\n\n第二组输入数据，存在 $\\lceil\\frac{m}{n-1}\\rceil=\\lceil\\frac{7}{4-1}\\rceil=3$ 条 $1$ 到 $4$ 的边不相交路径 $1\\to 2\\to 3\\to 4,1\\to 4,1\\to 4$，注意到 $1\\to 4$ 这条边虽然经过了两次，但是在原输入中这条边也输入了两次，所以认为它们还是不同的边。\n\n第三组输入数据，存在 $\\lceil\\frac{m}{n-1}\\rceil=\\lceil\\frac{5}{5-1}\\rceil=2$ 条 $3$ 到 $5$ 的边不相交路径 $3\\to 4\\to 5,3\\to 5$。", "locale": "zh-CN"}}}
{"pid": "P13357", "type": "P", "difficulty": 4, "samples": [["10\n1 2\n2 4\n6 10\n11 21\n147 154\n1470 1540\n2890 3028\n998244353 1000000007\n34827364537 41029384775\n147147147147 154154154154", "1\n2\n3\n7\n7\n70\n126\n1754385\n5861340682\n7007007007"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "广东", "省赛/邀请赛", "整除分块"], "title": "[GDCPC 2024] Menji 和 gcd", "background": "数据、标程、题解等资源的获取：<https://gitlink.org.cn/thusaa/gdcpc2024>", "description": "Menji 喜欢最大公约数，特别是最大公约数大的正整数对。\n\n令 $\\gcd(x,y)$ 表示 $x,y$ 的最大公约数，多次给定 $L,R$，保证 $L<R$，求 $\\max\\limits_{L\\leq x<y\\leq R}\\gcd(x,y)$。", "inputFormat": "第一行一个正整数 $T(1\\leq T\\leq 10)$，表示数据组数。\n\n之后 $T$ 行，每行两个正整数 $L,R(1\\leq L<R\\leq 10^{12})$，表示一组询问。", "outputFormat": "对于每个询问 $L,R$，输出一行一个正整数 $\\max\\limits_{L\\leq x<y\\leq R}\\gcd(x,y)$。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GDCPC 2024] Menji 和 gcd", "background": "数据、标程、题解等资源的获取：<https://gitlink.org.cn/thusaa/gdcpc2024>", "description": "Menji 喜欢最大公约数，特别是最大公约数大的正整数对。\n\n令 $\\gcd(x,y)$ 表示 $x,y$ 的最大公约数，多次给定 $L,R$，保证 $L<R$，求 $\\max\\limits_{L\\leq x<y\\leq R}\\gcd(x,y)$。", "inputFormat": "第一行一个正整数 $T(1\\leq T\\leq 10)$，表示数据组数。\n\n之后 $T$ 行，每行两个正整数 $L,R(1\\leq L<R\\leq 10^{12})$，表示一组询问。", "outputFormat": "对于每个询问 $L,R$，输出一行一个正整数 $\\max\\limits_{L\\leq x<y\\leq R}\\gcd(x,y)$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P13358", "type": "P", "difficulty": 6, "samples": [["3\n5 5\n1 1 1 1 1\n4 1 3 2 4\n1 5\n4 3 4 2 1\n2 3 5\n1 1\n5 3\n1 2 2\n2 1 2\n2 1 2\n2 1 3\n2 1 3\n2 1 3\n5 5\n1 1 1 1 1\n2 1 2\n2 5 4\n2 3 2\n2 4 3\n2 5 1", "5\n2 4 5 1 3\n5\n5 1 2 3 4\n5\n1 5 2 4 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "广东", "Special Judge", "二分图", "省赛/邀请赛"], "title": "[GDCPC 2024] 小班课", "background": "数据、标程、题解等资源的获取：<https://gitlink.org.cn/thusaa/gdcpc2024>", "description": "在 P 大学中，很多课程设立了小班课，学生可以自由根据需求选择小班课。当然，小班课的容量并不是无限的，并不是每个学生都能选上心仪的小班课。\n\n本学期，共有 $n$ 名同学报名了 A 课程，该课程共设立了 $m$ 门小班课，第 $i$ 门小班课有容量 $b_i$。第 $i$ 名学生对小班课有一个意向度序列 $a_{i,1}\\sim a_{i,k_i}$，其中 $a_{i,1}$ 表示意向度最高的课程，$a_{i,k_i}$ 表示意向度最低的课程。如果一门小班课 $j$ 不在这个序列里，那么说明学生 $i$ 无法参加第 $j$ 门小班课。\n\n学生们按照 $1\\sim n$ 的顺序进行选课，每次会选择优先度最高且未满的小班课，如果所有 $a_{i,1}\\sim a_{i,k_i}$ 都已满，那么该学生不会选择任何小班课。\n\n现在给出每个学生的意向度序列，请重排学生的顺序，使得选上小班课的学生最多。并构造方案。", "inputFormat": "第一行一个正整数 $T(1\\leq T\\leq 500)$，表示数据组数。\n\n对于每组数据，第一行两个正整数 $n,m(1\\leq n,m\\leq 500)$，即学生数量和小班课数量。\n\n之后一行 $m$ 个非负整数 $b_i(0\\leq b_i\\leq 500)$，即每一门小班课的容量。\n\n之后 $n$ 行，每行首先是一个非负整数 $k_i(0\\leq k_i\\leq m)$，之后是 $k_i$ 个两两不同的正整数 $a_{i,1}\\sim a_{i,k_i}(1\\leq a_{i,j}\\leq m)$，表示意向度序列。\n", "outputFormat": "对于每组数据，输出两行，第一行为一个整数 $ans$ 表示答案，之后一行 $n$ 个数，为一个 $1\\sim n$ 的排列，表示构造的方案。如果有多种方案，输出任意一种即可。\n", "hint": "对于第一组数据，按照给定的方案，学生 $2$ 首先选择 $5$，然后学生 $4$ 选择 $3$，学生 $5$ 选择 $1$，学生 $1$ 尝试选择 $1,5$ 但都已满员，所以最终选择 $2$，学生 $3$ 尝试选择 $3$ 但已满员，所以最终选择 $4$。该组数据的方案不唯一，例如，$\\{2,5,4,3,1\\}$ 也是一个可行解。\n\n对于第二组数据，$\\{1,2,3,4,5\\}$ **不**是一个可行解，如果这样构造，那么学生 $1,2,3,4$ 会分别选择 $1,2,3,3$，这时对于学生 $5$，$1,3$ 都已满员，因此无法选择任何课程。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GDCPC 2024] 小班课", "background": "数据、标程、题解等资源的获取：<https://gitlink.org.cn/thusaa/gdcpc2024>", "description": "在 P 大学中，很多课程设立了小班课，学生可以自由根据需求选择小班课。当然，小班课的容量并不是无限的，并不是每个学生都能选上心仪的小班课。\n\n本学期，共有 $n$ 名同学报名了 A 课程，该课程共设立了 $m$ 门小班课，第 $i$ 门小班课有容量 $b_i$。第 $i$ 名学生对小班课有一个意向度序列 $a_{i,1}\\sim a_{i,k_i}$，其中 $a_{i,1}$ 表示意向度最高的课程，$a_{i,k_i}$ 表示意向度最低的课程。如果一门小班课 $j$ 不在这个序列里，那么说明学生 $i$ 无法参加第 $j$ 门小班课。\n\n学生们按照 $1\\sim n$ 的顺序进行选课，每次会选择优先度最高且未满的小班课，如果所有 $a_{i,1}\\sim a_{i,k_i}$ 都已满，那么该学生不会选择任何小班课。\n\n现在给出每个学生的意向度序列，请重排学生的顺序，使得选上小班课的学生最多。并构造方案。", "inputFormat": "第一行一个正整数 $T(1\\leq T\\leq 500)$，表示数据组数。\n\n对于每组数据，第一行两个正整数 $n,m(1\\leq n,m\\leq 500)$，即学生数量和小班课数量。\n\n之后一行 $m$ 个非负整数 $b_i(0\\leq b_i\\leq 500)$，即每一门小班课的容量。\n\n之后 $n$ 行，每行首先是一个非负整数 $k_i(0\\leq k_i\\leq m)$，之后是 $k_i$ 个两两不同的正整数 $a_{i,1}\\sim a_{i,k_i}(1\\leq a_{i,j}\\leq m)$，表示意向度序列。\n", "outputFormat": "对于每组数据，输出两行，第一行为一个整数 $ans$ 表示答案，之后一行 $n$ 个数，为一个 $1\\sim n$ 的排列，表示构造的方案。如果有多种方案，输出任意一种即可。\n", "hint": "对于第一组数据，按照给定的方案，学生 $2$ 首先选择 $5$，然后学生 $4$ 选择 $3$，学生 $5$ 选择 $1$，学生 $1$ 尝试选择 $1,5$ 但都已满员，所以最终选择 $2$，学生 $3$ 尝试选择 $3$ 但已满员，所以最终选择 $4$。该组数据的方案不唯一，例如，$\\{2,5,4,3,1\\}$ 也是一个可行解。\n\n对于第二组数据，$\\{1,2,3,4,5\\}$ **不**是一个可行解，如果这样构造，那么学生 $1,2,3,4$ 会分别选择 $1,2,3,3$，这时对于学生 $5$，$1,3$ 都已满员，因此无法选择任何课程。", "locale": "zh-CN"}}}
{"pid": "P13359", "type": "P", "difficulty": 4, "samples": [["5 2\n1 2 3\n3 4 5", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2024", "广东", "拓扑排序", "省赛/邀请赛"], "title": "[GDCPC 2024] 不等式", "background": "数据、标程、题解等资源的获取：<https://gitlink.org.cn/thusaa/gdcpc2024>", "description": "给定 $n,m$，以及 $m$ 个形如 $a_{x_i}\\ge a_{y_i}+a_{z_i}(1 \\le i \\le m)$ 的条件。问是否有一组**正整数** $(a_1,a_2,\\cdots,a_n)$ 满足所有条件，并且 $a_1+a_2+\\cdots+a_n \\le 10^{9}$。如果有，输出 $a_1+a_2+\\cdots+a_n$ 的最小值；如果无解，输出 $-1$。", "inputFormat": "第一行两个整数 $n,m(1 \\le n,m \\le 2\\times 10^5)$。\n\n之后 $m$ 行，第 $i$ 行三个整数 $x_i,y_i,z_i$，表示一个限制 $a_{x_i}\\ge a_{y_i}+a_{z_i}(1\\le x_i,y_i,z_i \\le n)$。", "outputFormat": "输出一行一个整数，表示答案。", "hint": "和最小的解为 $(3,1,2,1,1)$，和为 $8$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GDCPC 2024] 不等式", "background": "数据、标程、题解等资源的获取：<https://gitlink.org.cn/thusaa/gdcpc2024>", "description": "给定 $n,m$，以及 $m$ 个形如 $a_{x_i}\\ge a_{y_i}+a_{z_i}(1 \\le i \\le m)$ 的条件。问是否有一组**正整数** $(a_1,a_2,\\cdots,a_n)$ 满足所有条件，并且 $a_1+a_2+\\cdots+a_n \\le 10^{9}$。如果有，输出 $a_1+a_2+\\cdots+a_n$ 的最小值；如果无解，输出 $-1$。", "inputFormat": "第一行两个整数 $n,m(1 \\le n,m \\le 2\\times 10^5)$。\n\n之后 $m$ 行，第 $i$ 行三个整数 $x_i,y_i,z_i$，表示一个限制 $a_{x_i}\\ge a_{y_i}+a_{z_i}(1\\le x_i,y_i,z_i \\le n)$。", "outputFormat": "输出一行一个整数，表示答案。", "hint": "和最小的解为 $(3,1,2,1,1)$，和为 $8$。", "locale": "zh-CN"}}}
{"pid": "P13360", "type": "P", "difficulty": 6, "samples": [["4", "8"], ["6", "80"], ["127", "23573971"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "广东", "省赛/邀请赛", "筛法"], "title": "[GDCPC 2024] 另一个计数问题", "background": "数据、标程、题解等资源的获取：<https://gitlink.org.cn/thusaa/gdcpc2024>", "description": "给定一个 $n - 1$ 个点的无向图，点的编号为 $2 \\sim n$。对于所有的 $2 \\le u < v \\le n$，边 $(u, v)$ 存在当且仅当 $v$ 是 $u$ 的正整数倍。定义 $f(u, v)$ 表示 $u$ 与 $v$ 是否连通：当 $u, v$ 连通时 $f(u, v) = 1$，否则 $f(u, v) = 0$。求：\n\n$$\\left(\\sum_{u = 2} ^ {n - 1} \\sum_{v = u + 1} ^ n f(u, v) \\cdot u \\cdot v\\right) \\bmod {998244353}$$", "inputFormat": "输入一行一个正整数 $n$。保证 $4 \\le n \\le 10 ^ {11}$。", "outputFormat": "输出一行一个非负整数表示答案。", "hint": "### 样例 1 解释\n\n$f(u, v) = 1$ 当且仅当 $u = 2, v = 4$，故答案为 $2 \\times 4 = 8$。\n\n### 样例 2 解释\n\n所有满足 $f(u, v) = 1$ 的 $(u, v)$ 为：$(2, 3), (2, 4), (2, 6), (3, 4), (3, 6), (4, 6)$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GDCPC 2024] 另一个计数问题", "background": "数据、标程、题解等资源的获取：<https://gitlink.org.cn/thusaa/gdcpc2024>", "description": "给定一个 $n - 1$ 个点的无向图，点的编号为 $2 \\sim n$。对于所有的 $2 \\le u < v \\le n$，边 $(u, v)$ 存在当且仅当 $v$ 是 $u$ 的正整数倍。定义 $f(u, v)$ 表示 $u$ 与 $v$ 是否连通：当 $u, v$ 连通时 $f(u, v) = 1$，否则 $f(u, v) = 0$。求：\n\n$$\\left(\\sum_{u = 2} ^ {n - 1} \\sum_{v = u + 1} ^ n f(u, v) \\cdot u \\cdot v\\right) \\bmod {998244353}$$", "inputFormat": "输入一行一个正整数 $n$。保证 $4 \\le n \\le 10 ^ {11}$。", "outputFormat": "输出一行一个非负整数表示答案。", "hint": "### 样例 1 解释\n\n$f(u, v) = 1$ 当且仅当 $u = 2, v = 4$，故答案为 $2 \\times 4 = 8$。\n\n### 样例 2 解释\n\n所有满足 $f(u, v) = 1$ 的 $(u, v)$ 为：$(2, 3), (2, 4), (2, 6), (3, 4), (3, 6), (4, 6)$。", "locale": "zh-CN"}}}
{"pid": "P13361", "type": "P", "difficulty": 2, "samples": [["3\n4 O 2 B 1 B 2 O 4\n3 O 5 O 8 B 100\n2 B 2 B 1", "Case #1: 6\nCase #2: 100\nCase #3: 4"]], "limits": {"time": [3000, 6000], "memory": [1048576, 1048576]}, "tags": ["模拟", "2011", "Google Code Jam"], "title": "[GCJ 2011 Qualification] Bot Trust", "background": "", "description": "Blue and Orange are friendly robots. An evil computer mastermind has locked them up in separate hallways to test them, and then possibly give them cake.\n\nEach hallway contains $100$ buttons labeled with the positive integers $\\{1, 2, \\ldots, 100\\}$. Button $k$ is always $k$ meters from the start of the hallway, and the robots both begin at button $1$. Over the period of one second, a robot can walk one meter in either direction, or it can press the button at its position once, or it can stay at its position and not press the button. To complete the test, the robots need to push a certain sequence of buttons in a certain order. Both robots know the full sequence in advance. How fast can they complete it?\n\nFor example, let's consider the following button sequence:\n\nO $2$, B $1$, B $2$, O $4$\n\nHere, O $2$ means button $2$ in Orange's hallway, B $1$ means button $1$ in Blue's hallway, and so on. The robots can push this sequence of buttons in $6$ seconds using the strategy shown below:\n\n| Time | Orange | Blue |\n| --- | --- | --- |\n| $1$ | Move to button $2$ | Stay at button $1$ |\n| $2$ | Push button $2$ | Stay at button $1$ |\n| $3$ | Move to button $3$ | Push button $1$ |\n| $4$ | Move to button $4$ | Move to button $2$ |\n| $5$ | Stay at button $4$ | Push button $2$ |\n| $6$ | Push button $4$ | Stay at button $2$ |\n\nNote that Blue has to wait until Orange has completely finished pushing O $2$ before it can start pushing B $1$.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow.\n\nEach test case consists of a single line beginning with a positive integer $N$, representing the number of buttons that need to be pressed. This is followed by $N$ terms of the form \"$R_i P_i$\" where $R_i$ is a robot color (always 'O' or 'B'), and $P_i$ is a button position.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $x$ is the case number (starting from 1) and $y$ is the minimum number of seconds required for the robots to push the given buttons, in order.", "hint": "**Limits**\n\n- $1 \\leq P_i \\leq 100$ for all $i$.\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $1 \\leq T \\leq 20$.\n- $1 \\leq N \\leq 10$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (10 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq N \\leq 100$.\n- Time limit: ~~60~~ 6 seconds.", "locale": "en", "translations": {"en": {"title": "[GCJ 2011 Qualification] Bot Trust", "background": "", "description": "Blue and Orange are friendly robots. An evil computer mastermind has locked them up in separate hallways to test them, and then possibly give them cake.\n\nEach hallway contains $100$ buttons labeled with the positive integers $\\{1, 2, \\ldots, 100\\}$. Button $k$ is always $k$ meters from the start of the hallway, and the robots both begin at button $1$. Over the period of one second, a robot can walk one meter in either direction, or it can press the button at its position once, or it can stay at its position and not press the button. To complete the test, the robots need to push a certain sequence of buttons in a certain order. Both robots know the full sequence in advance. How fast can they complete it?\n\nFor example, let's consider the following button sequence:\n\nO $2$, B $1$, B $2$, O $4$\n\nHere, O $2$ means button $2$ in Orange's hallway, B $1$ means button $1$ in Blue's hallway, and so on. The robots can push this sequence of buttons in $6$ seconds using the strategy shown below:\n\n| Time | Orange | Blue |\n| --- | --- | --- |\n| $1$ | Move to button $2$ | Stay at button $1$ |\n| $2$ | Push button $2$ | Stay at button $1$ |\n| $3$ | Move to button $3$ | Push button $1$ |\n| $4$ | Move to button $4$ | Move to button $2$ |\n| $5$ | Stay at button $4$ | Push button $2$ |\n| $6$ | Push button $4$ | Stay at button $2$ |\n\nNote that Blue has to wait until Orange has completely finished pushing O $2$ before it can start pushing B $1$.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow.\n\nEach test case consists of a single line beginning with a positive integer $N$, representing the number of buttons that need to be pressed. This is followed by $N$ terms of the form \"$R_i P_i$\" where $R_i$ is a robot color (always 'O' or 'B'), and $P_i$ is a button position.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $x$ is the case number (starting from 1) and $y$ is the minimum number of seconds required for the robots to push the given buttons, in order.", "hint": "**Limits**\n\n- $1 \\leq P_i \\leq 100$ for all $i$.\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $1 \\leq T \\leq 20$.\n- $1 \\leq N \\leq 10$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (10 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq N \\leq 100$.\n- Time limit: ~~60~~ 6 seconds.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2011 Qualification] Bot Trust", "background": null, "description": "Blue 和 Orange 是两台友好的机器人。一个邪恶的电脑主谋把它们分别关在不同的走廊里进行测试，之后可能会给它们蛋糕。\n\n每条走廊里都有 $100$ 个按钮，编号为正整数 $\\{1, 2, \\ldots, 100\\}$。按钮 $k$ 总是在距离走廊起点 $k$ 米的位置，两个机器人都从按钮 $1$ 开始。在一秒钟内，机器人可以向任意方向走一米，或者按下当前位置的按钮一次，或者停在当前位置不按按钮。为了完成测试，机器人需要按照给定顺序依次按下某些按钮。两个机器人都提前知道完整的按钮序列。请问它们最少需要多少秒才能完成任务？\n\n例如，考虑如下按钮序列：\n\nO $2$, B $1$, B $2$, O $4$\n\n这里，O $2$ 表示 Orange 走廊上的按钮 $2$，B $1$ 表示 Blue 走廊上的按钮 $1$，以此类推。机器人可以用如下策略在 $6$ 秒内完成按钮序列：\n\n| 时间 | Orange | Blue |\n| --- | --- | --- |\n| $1$ | 移动到按钮 $2$ | 停在按钮 $1$ |\n| $2$ | 按下按钮 $2$ | 停在按钮 $1$ |\n| $3$ | 移动到按钮 $3$ | 按下按钮 $1$ |\n| $4$ | 移动到按钮 $4$ | 移动到按钮 $2$ |\n| $5$ | 停在按钮 $4$ | 按下按钮 $2$ |\n| $6$ | 按下按钮 $4$ | 停在按钮 $2$ |\n\n注意，Blue 必须等到 Orange 完全按完 O $2$ 之后，才能开始按 B $1$。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。接下来有 $T$ 组测试数据。\n\n每组测试数据为一行，首先是一个正整数 $N$，表示需要按下的按钮数量。接下来有 $N$ 个形如 \"$R_i P_i$\" 的项，其中 $R_i$ 表示机器人颜色（始终为 'O' 或 'B'），$P_i$ 表示按钮的位置。", "outputFormat": "对于每组测试数据，输出一行，格式为 \"Case #x: y\"，其中 $x$ 是测试编号（从 1 开始），$y$ 是机器人按顺序按下所有按钮所需的最少秒数。", "hint": "**限制条件**\n\n- 对所有 $i$，$1 \\leq P_i \\leq 100$。\n\n**小数据集（10 分，测试集 1 - 可见）**\n\n- $1 \\leq T \\leq 20$。\n- $1 \\leq N \\leq 10$。\n- 时间限制：3 秒。\n\n**大数据集（10 分，测试集 2 - 隐藏）**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq N \\leq 100$。\n- 时间限制：6 秒。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13362", "type": "P", "difficulty": 3, "samples": [["5\n0 0 2 EA\n1 QRI 0 4 RRQR\n1 QFT 1 QF 7 FAQFDFQ\n1 EEZ 1 QE 7 QEEEERA\n0 1 QW 2 QW", "Case #1: [E, A]\nCase #2: [R, I, R]\nCase #3: [F, D, T]\nCase #4: [Z, E, R, A]\nCase #5: []"]], "limits": {"time": [3000, 6000], "memory": [1048576, 1048576]}, "tags": ["模拟", "2011", "Google Code Jam"], "title": "[GCJ 2011 Qualification] Magicka", "background": "Magicka™ is an action-adventure game developed by Arrowhead Game Studios. In Magicka you play a wizard, invoking and combining elements to create Magicks. This problem has a similar idea, but it does not assume that you have played Magicka.\n\nNote: \"invoke\" means \"call on.\" For this problem, it is a technical term and you don't need to know its normal English meaning.\n\nMagicka™ is a trademark of Paradox Interactive AB. Paradox Interactive AB does not endorse and has no involvement with Google Code Jam.", "description": "As a wizard, you can invoke eight elements, which are the \"base\" elements. Each base element is a single character from $\\{Q, W, E, R, A, S, D, F\\}$. When you invoke an element, it gets appended to your element list. For example: if you invoke $W$ and then invoke $A$, (we'll call that \"invoking $WA$\" for short) then your element list will be $[W, A]$.\n\nWe will specify pairs of base elements that combine to form non-base elements (the other 18 capital letters). For example, $Q$ and $F$ might combine to form $T$. If the two elements from a pair appear at the end of the element list, then both elements of the pair will be immediately removed, and they will be replaced by the element they form. In the example above, if the element list looks like $[A, Q, F]$ or $[A, F, Q]$ at any point, it will become $[A, T]$.\n\nWe will specify pairs of base elements that are opposed to each other. After you invoke an element, if it isn't immediately combined to form another element, and it is opposed to something in your element list, then your whole element list will be cleared.\n\nFor example, suppose $Q$ and $F$ combine to make $T$. $R$ and $F$ are opposed to each other. Then invoking the following things (in order, from left to right) will have the following results:\n\n- $QF \\rightarrow [T]$ ($Q$ and $F$ combine to form $T$)\n- $QEF \\rightarrow [Q, E, F]$ ($Q$ and $F$ can't combine because they were never at the end of the element list together)\n- $RFE \\rightarrow [E]$ ($F$ and $R$ are opposed, so the list is cleared; then $E$ is invoked)\n- $REF \\rightarrow []$ ($F$ and $R$ are opposed, so the list is cleared)\n- $RQF \\rightarrow [R, T]$ ($QF$ combine to make $T$, so the list is not cleared)\n- $RFQ \\rightarrow [Q]$ ($F$ and $R$ are opposed, so the list is cleared)\n\nGiven a list of elements to invoke, what will be in the element list when you're done?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case consists of a single line, containing the following space-separated elements in order:\n\nFirst an integer $C$, followed by $C$ strings, each containing three characters: two base elements followed by a non-base element. This indicates that the two base elements combine to form the non-base element. Next will come an integer $D$, followed by $D$ strings, each containing two characters: two base elements that are opposed to each other. Finally there will be an integer $N$, followed by a single string containing $N$ characters: the series of base elements you are to invoke. You will invoke them in the order they appear in the string (leftmost character first, and so on), one at a time.", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is a list in the format \"$[e_0, e_1, \\dots]$\" where $e_i$ is the $i^{th}$ element of the final element list. Please see the sample output for examples.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n- Each pair of base elements may only appear together in one combination, though they may appear in a combination and also be opposed to each other.\n- No base element may be opposed to itself.\n- Unlike in the computer game Magicka, there is no limit to the length of the element list.\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $0 \\leq C \\leq 1$.\n- $0 \\leq D \\leq 1$.\n- $1 \\leq N \\leq 10$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (15 Pts, Test set 2 - Hidden)**\n\n- $0 \\leq C \\leq 36$.\n- $0 \\leq D \\leq 28$.\n- $1 \\leq N \\leq 100$.\n- Time limit: ~~60~~ 6 seconds.", "locale": "en", "translations": {"en": {"title": "[GCJ 2011 Qualification] Magicka", "background": "Magicka™ is an action-adventure game developed by Arrowhead Game Studios. In Magicka you play a wizard, invoking and combining elements to create Magicks. This problem has a similar idea, but it does not assume that you have played Magicka.\n\nNote: \"invoke\" means \"call on.\" For this problem, it is a technical term and you don't need to know its normal English meaning.\n\nMagicka™ is a trademark of Paradox Interactive AB. Paradox Interactive AB does not endorse and has no involvement with Google Code Jam.", "description": "As a wizard, you can invoke eight elements, which are the \"base\" elements. Each base element is a single character from $\\{Q, W, E, R, A, S, D, F\\}$. When you invoke an element, it gets appended to your element list. For example: if you invoke $W$ and then invoke $A$, (we'll call that \"invoking $WA$\" for short) then your element list will be $[W, A]$.\n\nWe will specify pairs of base elements that combine to form non-base elements (the other 18 capital letters). For example, $Q$ and $F$ might combine to form $T$. If the two elements from a pair appear at the end of the element list, then both elements of the pair will be immediately removed, and they will be replaced by the element they form. In the example above, if the element list looks like $[A, Q, F]$ or $[A, F, Q]$ at any point, it will become $[A, T]$.\n\nWe will specify pairs of base elements that are opposed to each other. After you invoke an element, if it isn't immediately combined to form another element, and it is opposed to something in your element list, then your whole element list will be cleared.\n\nFor example, suppose $Q$ and $F$ combine to make $T$. $R$ and $F$ are opposed to each other. Then invoking the following things (in order, from left to right) will have the following results:\n\n- $QF \\rightarrow [T]$ ($Q$ and $F$ combine to form $T$)\n- $QEF \\rightarrow [Q, E, F]$ ($Q$ and $F$ can't combine because they were never at the end of the element list together)\n- $RFE \\rightarrow [E]$ ($F$ and $R$ are opposed, so the list is cleared; then $E$ is invoked)\n- $REF \\rightarrow []$ ($F$ and $R$ are opposed, so the list is cleared)\n- $RQF \\rightarrow [R, T]$ ($QF$ combine to make $T$, so the list is not cleared)\n- $RFQ \\rightarrow [Q]$ ($F$ and $R$ are opposed, so the list is cleared)\n\nGiven a list of elements to invoke, what will be in the element list when you're done?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case consists of a single line, containing the following space-separated elements in order:\n\nFirst an integer $C$, followed by $C$ strings, each containing three characters: two base elements followed by a non-base element. This indicates that the two base elements combine to form the non-base element. Next will come an integer $D$, followed by $D$ strings, each containing two characters: two base elements that are opposed to each other. Finally there will be an integer $N$, followed by a single string containing $N$ characters: the series of base elements you are to invoke. You will invoke them in the order they appear in the string (leftmost character first, and so on), one at a time.", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is a list in the format \"$[e_0, e_1, \\dots]$\" where $e_i$ is the $i^{th}$ element of the final element list. Please see the sample output for examples.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n- Each pair of base elements may only appear together in one combination, though they may appear in a combination and also be opposed to each other.\n- No base element may be opposed to itself.\n- Unlike in the computer game Magicka, there is no limit to the length of the element list.\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $0 \\leq C \\leq 1$.\n- $0 \\leq D \\leq 1$.\n- $1 \\leq N \\leq 10$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (15 Pts, Test set 2 - Hidden)**\n\n- $0 \\leq C \\leq 36$.\n- $0 \\leq D \\leq 28$.\n- $1 \\leq N \\leq 100$.\n- Time limit: ~~60~~ 6 seconds.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2011 Qualification] Magicka", "background": null, "description": "作为一名法师，你可以召唤八种元素，这些是“基础”元素。每个基础元素是 $\\{Q, W, E, R, A, S, D, F\\}$ 中的一个字符。当你召唤一个元素时，它会被添加到你的元素列表的末尾。例如：如果你先召唤 $W$，再召唤 $A$（我们简称为“召唤 $WA$”），那么你的元素列表将变为 $[W, A]$。\n\n我们会指定一些基础元素对，这些元素对可以组合成非基础元素（其余 18 个大写字母）。例如，$Q$ 和 $F$ 可以组合成 $T$。如果某一时刻，这对元素出现在元素列表的末尾，那么这两个元素会被立即移除，并用它们组合成的新元素替换。例如，如果元素列表为 $[A, Q, F]$ 或 $[A, F, Q]$，那么它会变为 $[A, T]$。\n\n我们还会指定一些基础元素对，它们彼此“对立”。当你召唤一个元素后，如果它没有立即与其他元素组合成新元素，并且它与元素列表中的某个元素是对立的，那么你的整个元素列表会被清空。\n\n例如，假设 $Q$ 和 $F$ 组合成 $T$，$R$ 和 $F$ 是对立的。那么依次召唤以下元素（从左到右）会有如下结果：\n\n- $QF \\rightarrow [T]$（$Q$ 和 $F$ 组合成 $T$）\n- $QEF \\rightarrow [Q, E, F]$（$Q$ 和 $F$ 没有同时出现在末尾，无法组合）\n- $RFE \\rightarrow [E]$（$F$ 和 $R$ 对立，列表被清空，然后召唤 $E$）\n- $REF \\rightarrow []$（$F$ 和 $R$ 对立，列表被清空）\n- $RQF \\rightarrow [R, T]$（$QF$ 组合成 $T$，列表不会被清空）\n- $RFQ \\rightarrow [Q]$（$F$ 和 $R$ 对立，列表被清空）\n\n给定一系列要召唤的元素，最终你的元素列表中会有哪些元素？", "inputFormat": "输入的第一行是测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据由一行组成，内容如下，元素之间用空格分隔：\n\n首先是一个整数 $C$，接着是 $C$ 个字符串，每个字符串有三个字符：前两个是基础元素，第三个是它们组合成的非基础元素。接下来是一个整数 $D$，然后是 $D$ 个字符串，每个字符串有两个字符，表示这两个基础元素是对立的。最后是一个整数 $N$，接着是一个长度为 $N$ 的字符串，表示你要依次召唤的基础元素（从左到右依次召唤）。", "outputFormat": "对于每个测试用例，输出一行，格式为“Case #$x$: $y$”，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是最终元素列表，格式为“$[e_0, e_1, \\dots]$”，其中 $e_i$ 是最终元素列表中的第 $i$ 个元素。具体格式请参考样例输出。", "hint": "**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- 每对基础元素最多只会出现在一个组合中，但它们既可以组合也可以对立。\n- 没有基础元素会与自身对立。\n- 与游戏 Magicka 不同，元素列表长度没有限制。\n\n**小数据集（10 分，测试点 1 - 可见）**\n\n- $0 \\leq C \\leq 1$。\n- $0 \\leq D \\leq 1$。\n- $1 \\leq N \\leq 10$。\n- 时间限制：3 秒。\n\n**大数据集（15 分，测试点 2 - 隐藏）**\n\n- $0 \\leq C \\leq 36$。\n- $0 \\leq D \\leq 28$。\n- $1 \\leq N \\leq 100$。\n- 时间限制：6 秒。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13363", "type": "P", "difficulty": 3, "samples": [["2\n5\n1 2 3 4 5\n3\n3 5 6", "Case #1: NO\nCase #2: 11"]], "limits": {"time": [3000, 6000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2011", "进制", "位运算", "Google Code Jam"], "title": "[GCJ 2011 Qualification] Candy Splitting", "background": "", "description": "Sean and Patrick are brothers who just got a nice bag of candy from their parents. Each piece of candy has some positive integer value, and the children want to divide the candy between them. First, Sean will split the candy into two piles, and choose one to give to Patrick. Then Patrick will try to calculate the value of each pile, where the value of a pile is the sum of the values of all pieces of candy in that pile; if he decides the piles don't have equal value, he will start crying.\n\nUnfortunately, Patrick is very young and doesn't know how to add properly. He *almost* knows how to add numbers in binary; but when he adds two 1s together, he always forgets to carry the remainder to the next bit. For example, if he wants to sum 12 (1100 in binary) and 5 (101 in binary), he will add the two rightmost bits correctly, but in the third bit he will forget to carry the remainder to the next bit:\n\n```\n  1100\n+ 0101\n------\n  1001\n```\n\nSo after adding the last bit without the carry from the third bit, the final result is 9 (1001 in binary). Here are some other examples of Patrick's math skills:\n\n```\n5 + 4 = 1\n7 + 9 = 14\n50 + 10 = 56\n```\n\nSean is very good at adding, and he wants to take as much value as he can without causing his little brother to cry. If it's possible, he will split the bag of candy into two non-empty piles such that Patrick thinks that both have the same value. Given the values of all pieces of candy in the bag, we would like to know if this is possible; and, if it's possible, determine the maximum possible value of Sean's pile.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case is described in two lines. The first line contains a single integer $N$, denoting the number of candies in the bag. The next line contains the $N$ integers $C_i$ separated by single spaces, which denote the value of each piece of candy in the bag.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $x$ is the case number (starting from 1). If it is impossible for Sean to keep Patrick from crying, $y$ should be the word \"NO\". Otherwise, $y$ should be the value of the pile of candies that Sean will keep.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq C_i \\leq 10^6$.\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $2 \\leq N \\leq 15$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (15 Pts, Test set 2 - Hidden)**\n\n- $2 \\leq N \\leq 1000$.\n- Time limit: ~~60~~ 6 seconds.", "locale": "en", "translations": {"en": {"title": "[GCJ 2011 Qualification] Candy Splitting", "background": "", "description": "Sean and Patrick are brothers who just got a nice bag of candy from their parents. Each piece of candy has some positive integer value, and the children want to divide the candy between them. First, Sean will split the candy into two piles, and choose one to give to Patrick. Then Patrick will try to calculate the value of each pile, where the value of a pile is the sum of the values of all pieces of candy in that pile; if he decides the piles don't have equal value, he will start crying.\n\nUnfortunately, Patrick is very young and doesn't know how to add properly. He *almost* knows how to add numbers in binary; but when he adds two 1s together, he always forgets to carry the remainder to the next bit. For example, if he wants to sum 12 (1100 in binary) and 5 (101 in binary), he will add the two rightmost bits correctly, but in the third bit he will forget to carry the remainder to the next bit:\n\n```\n  1100\n+ 0101\n------\n  1001\n```\n\nSo after adding the last bit without the carry from the third bit, the final result is 9 (1001 in binary). Here are some other examples of Patrick's math skills:\n\n```\n5 + 4 = 1\n7 + 9 = 14\n50 + 10 = 56\n```\n\nSean is very good at adding, and he wants to take as much value as he can without causing his little brother to cry. If it's possible, he will split the bag of candy into two non-empty piles such that Patrick thinks that both have the same value. Given the values of all pieces of candy in the bag, we would like to know if this is possible; and, if it's possible, determine the maximum possible value of Sean's pile.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case is described in two lines. The first line contains a single integer $N$, denoting the number of candies in the bag. The next line contains the $N$ integers $C_i$ separated by single spaces, which denote the value of each piece of candy in the bag.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $x$ is the case number (starting from 1). If it is impossible for Sean to keep Patrick from crying, $y$ should be the word \"NO\". Otherwise, $y$ should be the value of the pile of candies that Sean will keep.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq C_i \\leq 10^6$.\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $2 \\leq N \\leq 15$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (15 Pts, Test set 2 - Hidden)**\n\n- $2 \\leq N \\leq 1000$.\n- Time limit: ~~60~~ 6 seconds.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2011 Qualification] Candy Splitting", "background": null, "description": "Sean 和 Patrick 是一对兄弟，他们刚刚从父母那里得到了一袋美味的糖果。每颗糖果都有一个正整数的价值，兄弟俩想要把糖果分成两份。首先，Sean 会把糖果分成两堆，并选择其中一堆送给 Patrick。然后 Patrick 会尝试计算每堆的价值，其中一堆的价值是该堆所有糖果价值的总和；如果他发现两堆的价值不相等，他就会开始哭泣。\n\n不幸的是，Patrick 还很小，不太会加法。他“几乎”会用二进制加法；但每当他遇到两个 $1$ 相加时，总是忘记向下一位进位。例如，如果他想把 $12$（二进制 $1100$）和 $5$（二进制 $101$）相加，他会正确地加上最右边的两位，但在第三位时会忘记进位：\n\n```\n  1100\n+ 0101\n------\n  1001\n```\n\n所以在加完最后一位且没有从第三位进位后，最终结果是 $9$（二进制 $1001$）。以下是 Patrick 算数能力的其他例子：\n\n```\n5 + 4 = 1\n7 + 9 = 14\n50 + 10 = 56\n```\n\nSean 很擅长加法，他想在不让弟弟哭泣的前提下，尽可能多地拿到糖果。如果可能的话，他会把糖果分成两堆且都不为空，使得 Patrick 认为两堆的价值相等。给定糖果袋中所有糖果的价值，请你判断是否有可能做到；如果可能，请计算 Sean 能拿到的最大糖果价值。", "inputFormat": "输入的第一行包含一个整数 $T$，表示测试用例的数量。接下来的 $T$ 个测试用例，每个测试用例包含两行。第一行是一个整数 $N$，表示糖果的数量。第二行包含 $N$ 个用空格分隔的整数 $C_i$，表示每颗糖果的价值。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #x: y\"，其中 $x$ 是测试用例编号（从 $1$ 开始）。如果 Sean 无法让 Patrick 不哭泣，则 $y$ 为 \"NO\"。否则，$y$ 为 Sean 能拿到的糖果堆的最大价值。", "hint": "**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq C_i \\leq 10^6$。\n\n**小数据范围（10 分，测试点 1 - 可见）**\n\n- $2 \\leq N \\leq 15$。\n- 时间限制：3 秒。\n\n**大数据范围（15 分，测试点 2 - 隐藏）**\n\n- $2 \\leq N \\leq 1000$。\n- 时间限制：6 秒。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13364", "type": "P", "difficulty": 5, "samples": [["3\n2\n2 1\n3\n1 3 2\n4\n2 1 4 3", "Case #1: 2.000000\nCase #2: 2.000000\nCase #3: 4.000000"]], "limits": {"time": [3000, 6000], "memory": [1048576, 1048576]}, "tags": ["数学", "2011", "Special Judge", "期望", "Google Code Jam"], "title": "[GCJ 2011 Qualification] GoroSort", "background": "", "description": "Goro has 4 arms. Goro is very strong. You don't mess with Goro. Goro needs to sort an array of $N$ different integers. Algorithms are not Goro's strength; strength is Goro's strength. Goro's plan is to use the fingers on two of his hands to hold down several elements of the array and hit the table with his third and fourth fists as hard as possible. This will make the unsecured elements of the array fly up into the air, get shuffled randomly, and fall back down into the empty array locations.\n\nGoro wants to sort the array as quickly as possible. How many hits will it take Goro to sort the given array, on average, if he acts intelligently when choosing which elements of the array to hold down before each hit of the table? Goro has an infinite number of fingers on the two hands he uses to hold down the array.\n\nMore precisely, before each hit, Goro may choose any subset of the elements of the array to freeze in place. He may choose differently depending on the outcomes of previous hits. Each hit permutes the unfrozen elements uniformly at random. Each permutation is equally likely.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each one will consist of two lines. The first line will give the number $N$. The second line will list the $N$ elements of the array in their initial order.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the expected number of hit-the-table operations when following the best hold-down strategy. Answers with an absolute or relative error of at most $10^{-6}$ will be considered correct.", "hint": "**Sample Explanation**\n\nIn test case #3, one possible strategy is to hold down the two leftmost elements first. Elements 3 and 4 will be free to move. After a table hit, they will land in the correct order $[3, 4]$ with probability $1/2$ and in the wrong order $[4, 3]$ with probability $1/2$. Therefore, on average it will take 2 hits to arrange them in the correct order. After that, Goro can hold down elements 3 and 4 and hit the table until 1 and 2 land in the correct order, which will take another 2 hits, on average. The total is then $2 + 2 = 4$ hits.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$;\n- The second line of each test case will contain a permutation of the $N$ smallest positive integers.\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 10$;\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (20 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq N \\leq 1000$;\n- Time limit: ~~60~~ 6 seconds.", "locale": "en", "translations": {"en": {"title": "[GCJ 2011 Qualification] GoroSort", "background": "", "description": "Goro has 4 arms. Goro is very strong. You don't mess with Goro. Goro needs to sort an array of $N$ different integers. Algorithms are not Goro's strength; strength is Goro's strength. Goro's plan is to use the fingers on two of his hands to hold down several elements of the array and hit the table with his third and fourth fists as hard as possible. This will make the unsecured elements of the array fly up into the air, get shuffled randomly, and fall back down into the empty array locations.\n\nGoro wants to sort the array as quickly as possible. How many hits will it take Goro to sort the given array, on average, if he acts intelligently when choosing which elements of the array to hold down before each hit of the table? Goro has an infinite number of fingers on the two hands he uses to hold down the array.\n\nMore precisely, before each hit, Goro may choose any subset of the elements of the array to freeze in place. He may choose differently depending on the outcomes of previous hits. Each hit permutes the unfrozen elements uniformly at random. Each permutation is equally likely.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each one will consist of two lines. The first line will give the number $N$. The second line will list the $N$ elements of the array in their initial order.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the expected number of hit-the-table operations when following the best hold-down strategy. Answers with an absolute or relative error of at most $10^{-6}$ will be considered correct.", "hint": "**Sample Explanation**\n\nIn test case #3, one possible strategy is to hold down the two leftmost elements first. Elements 3 and 4 will be free to move. After a table hit, they will land in the correct order $[3, 4]$ with probability $1/2$ and in the wrong order $[4, 3]$ with probability $1/2$. Therefore, on average it will take 2 hits to arrange them in the correct order. After that, Goro can hold down elements 3 and 4 and hit the table until 1 and 2 land in the correct order, which will take another 2 hits, on average. The total is then $2 + 2 = 4$ hits.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$;\n- The second line of each test case will contain a permutation of the $N$ smallest positive integers.\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 10$;\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (20 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq N \\leq 1000$;\n- Time limit: ~~60~~ 6 seconds.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2011 Qualification] GoroSort", "background": "", "description": "Goro 有 4 只手臂。Goro 非常强壮。你可别惹 Goro。Goro 需要对一个包含 $N$ 个不同整数的数组进行排序。算法不是 Goro 的强项，力量才是 Goro 的强项。Goro 的计划是用两只手的手指按住数组中的若干元素，然后用另外两只手狠狠地敲桌子。这样，未被固定的元素会飞到空中，被随机打乱后再落回原来的空位。\n\nGoro 想要尽快将数组排序。如果 Goro 每次都聪明地选择要固定哪些元素，平均需要敲多少次桌子才能将给定的数组排序？Goro 用来固定数组的两只手有无限多的手指。\n\n更具体地说，在每次敲桌子之前，Goro 可以选择数组中的任意子集元素将其固定在原位。每次可以根据之前敲桌子的结果选择不同的固定方式。每次敲桌子会将未固定的元素等概率地随机排列。每种排列出现的概率相同。", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据包含两行。第一行为整数 $N$。第二行为数组初始顺序下的 $N$ 个元素。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #$x$: $y$\"，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为在采用最佳固定策略时，期望的敲桌子次数。只要答案的绝对误差或相对误差不超过 $10^{-6}$ 即视为正确。", "hint": "**样例解释**\n\n在第 3 个测试用例中，一种可行的策略是先固定最左边的两个元素。元素 3 和 4 没有被固定。敲桌子后，它们有 $1/2$ 的概率变为正确顺序 $[3, 4]$，有 $1/2$ 的概率变为错误顺序 $[4, 3]$。因此，平均需要 2 次敲桌子才能将它们排好。之后，Goro 可以固定元素 3 和 4，再敲桌子直到 1 和 2 排好，平均也需要 2 次。总共期望敲桌子次数为 $2 + 2 = 4$。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$；\n- 每组测试数据的第二行为 $N$ 个最小正整数的一个排列。\n\n**小数据范围（10 分，测试点 1 - 可见）**\n\n- $1 \\leq N \\leq 10$；\n- 时间限制：~~30~~ 3 秒。\n\n**大数据范围（20 分，测试点 2 - 隐藏）**\n\n- $1 \\leq N \\leq 1000$；\n- 时间限制：~~60~~ 6 秒。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13365", "type": "P", "difficulty": 3, "samples": [["3\n1 100 50\n10 10 100\n9 80 56", "Case #1: Possible\nCase #2: Broken\nCase #3: Possible"]], "limits": {"time": [3000, 6000], "memory": [1048576, 1048576]}, "tags": ["数学", "2011", "数论", "Google Code Jam"], "title": "[GCJ 2011 #1A] FreeCell Statistics", "background": "", "description": "I played $D$ ($D > 0$) games of FreeCell today. Each game of FreeCell ends in one of two ways -- I either win, or I lose. I've been playing for many years, and have so far played $G$ games in total (obviously, $G \\geq D$).\n\nAt the end of the day, I look at the game statistics to see how well I have played. It turns out that I have won exactly $P_D$ percent of the $D$ games today, and exactly $P_G$ percent of $G$ total games I had ever played. Miraculously, there is no rounding necessary -- both percentages are exact! Unfortunately, I don't remember the exact number of games that I have played today ($D$), or the exact number of games that I have played in total ($G$). I do know that I could not have played more than $N$ games today ($D \\leq N$).\n\nAre the percentages displayed possible, or is the game statistics calculator broken?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each line contains 3 integers -- $N$, $P_D$ and $P_G$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is either \"Possible\" or \"Broken\".", "hint": "**Sample Explanation**\n\nIn Case #3, I could have played $5$ games today ($D = 5$) and $25$ games in total ($G = 25$), and won $4$ games today ($80\\%$ of $5$) and $14$ games in total ($56\\%$ of $25$).\n\n**Limits**\n\n- $0 \\leq P_D \\leq 100$;\n- $0 \\leq P_G \\leq 100$.\n\n**Small dataset (6 Pts, Test set 1 - Visible)**\n\n- $1 \\leq T \\leq 100$;\n- $1 \\leq N \\leq 10$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (14 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq T \\leq 2000$;\n- $1 \\leq N \\leq 10^{15}$.\n- Time limit: ~~60~~ 6 seconds.", "locale": "en", "translations": {"en": {"title": "[GCJ 2011 #1A] FreeCell Statistics", "background": "", "description": "I played $D$ ($D > 0$) games of FreeCell today. Each game of FreeCell ends in one of two ways -- I either win, or I lose. I've been playing for many years, and have so far played $G$ games in total (obviously, $G \\geq D$).\n\nAt the end of the day, I look at the game statistics to see how well I have played. It turns out that I have won exactly $P_D$ percent of the $D$ games today, and exactly $P_G$ percent of $G$ total games I had ever played. Miraculously, there is no rounding necessary -- both percentages are exact! Unfortunately, I don't remember the exact number of games that I have played today ($D$), or the exact number of games that I have played in total ($G$). I do know that I could not have played more than $N$ games today ($D \\leq N$).\n\nAre the percentages displayed possible, or is the game statistics calculator broken?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each line contains 3 integers -- $N$, $P_D$ and $P_G$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is either \"Possible\" or \"Broken\".", "hint": "**Sample Explanation**\n\nIn Case #3, I could have played $5$ games today ($D = 5$) and $25$ games in total ($G = 25$), and won $4$ games today ($80\\%$ of $5$) and $14$ games in total ($56\\%$ of $25$).\n\n**Limits**\n\n- $0 \\leq P_D \\leq 100$;\n- $0 \\leq P_G \\leq 100$.\n\n**Small dataset (6 Pts, Test set 1 - Visible)**\n\n- $1 \\leq T \\leq 100$;\n- $1 \\leq N \\leq 10$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (14 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq T \\leq 2000$;\n- $1 \\leq N \\leq 10^{15}$.\n- Time limit: ~~60~~ 6 seconds.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2011 #1A] FreeCell Statistics", "background": null, "description": "我今天玩了 $D$（$D > 0$）局 FreeCell。每局 FreeCell 的结果只有两种——要么我赢了，要么我输了。我已经玩了很多年，到目前为止总共玩了 $G$ 局（显然 $G \\geq D$）。\n\n一天结束时，我查看游戏统计数据，看看自己表现如何。结果发现，今天的 $D$ 局中，我赢了恰好 $P_D$ 百分比的局数，而在我玩过的所有 $G$ 局中，我赢了恰好 $P_G$ 百分比的局数。令人惊奇的是，这两个百分比都是精确的，没有任何四舍五入！不幸的是，我不记得今天具体玩了多少局（$D$），也不记得总共玩了多少局（$G$）。我只知道今天玩的局数不会超过 $N$（即 $D \\leq N$）。\n\n请判断，这两个百分比是否可能出现，还是游戏统计计算器出错了？", "inputFormat": "输入的第一行包含一个整数 $T$，表示测试用例的数量。接下来的 $T$ 行，每行包含三个整数——$N$、$P_D$ 和 $P_G$。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #$x$: $y$\"，其中 $x$ 是测试用例编号（从 1 开始），$y$ 为 \"Possible\" 或 \"Broken\"。", "hint": "**样例解释**\n\n在第 3 个样例中，我今天可能玩了 $5$ 局（$D = 5$），总共玩了 $25$ 局（$G = 25$），今天赢了 $4$ 局（$5$ 的 $80\\%$），总共赢了 $14$ 局（$25$ 的 $56\\%$）。\n\n**限制条件**\n\n- $0 \\leq P_D \\leq 100$；\n- $0 \\leq P_G \\leq 100$。\n\n**小数据集（6 分，测试集 1 - 可见）**\n\n- $1 \\leq T \\leq 100$；\n- $1 \\leq N \\leq 10$。\n- 时间限制：3 秒。\n\n**大数据集（14 分，测试集 2 - 隐藏）**\n\n- $1 \\leq T \\leq 2000$；\n- $1 \\leq N \\leq 10^{15}$。\n- 时间限制：6 秒。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13366", "type": "P", "difficulty": 4, "samples": [["2\n3 2\nbanana\ncaravan\npajamas\nabcdefghijklmnopqrstuvwxyz\netaoisnhrdlcumwfgypbvkjxqz\n4 1\npotato\ntomato\ngarlic\npepper\nzyxwvutsrqponmlkjihgfedcba", "Case #1: pajamas caravan\nCase #2: garlic"]], "limits": {"time": [3000, 6000], "memory": [1048576, 1048576]}, "tags": ["模拟", "2011", "递归", "记忆化搜索", "Google Code Jam"], "title": "[GCJ 2011 #1A] The Killer Word", "background": "", "description": "You are playing Hangman with your friend Sean. And while you have heard that Sean is very good at taking candy from a baby, he is not as good at this game. Can you take advantage of Sean's imperfect strategy, and make him lose as badly as possible?\n\n```\n +--+\n |  O\n | /|\\       Mystery word: _ a _ a _ a _\n | / \\\n |\n+-+---+\n```\n\nHangman is played as follows:\n\n* There is a dictionary $D$ of all valid words, which both you and Sean know. A word consists only of the characters a - z. In particular, there are no spaces.\n* You begin by choosing any word from $D$, and writing it down on a blackboard with each letter replaced by a blank: _.\n* On his turn, Sean can choose any letter and ask you if it is in the word. If it is, you reveal all locations of that letter. Otherwise, Sean loses a point.\n* Once all letters in the word have been revealed, the round ends.\n* The round never ends early, no matter how many points Sean loses.\n\nSean uses a very simple strategy. He makes a list $L$ of the 26 letters in some order, and goes through the list one letter at a time. If there is at least one word in $D$ that (a) has the letter he is thinking of, and (b) is consistent with what you have written down so far and the result of all of Sean's previous guesses, then Sean guesses that letter. Otherwise, he skips it. No matter what, Sean then moves on to the next letter in his list.\n\nGiven Sean's list, what word should you choose to make Sean lose as many as points as possible? If several choices are equally good, you should choose the one that appears first in $D$.\n\n**Example**\n\nSuppose Sean decides to guess the letters in alphabetical order (i.e., $L = $ \"abcdefghijklmnopqrstuvwxyz\"), and $D$ contains the words banana, caravan, and pajamas. If you choose pajamas, the game would play out as follows:\n\n* You begin by writing 7 blanks _ _ _ _ _ _ _ on the blackboard. Based on the number of blanks, Sean knows immediately that the word is either caravan or pajamas.\n* Sean begins by guessing a since it is first in $L$, and you reveal all locations of the letter a on the blackboard: _ a _ a _ a _.\n* Sean skips b even though it is used in banana. Sean already knows that is not your word.\n* He then guesses c because it appears in caravan. It does not appear in the word you actually chose though, so Sean loses a point and nothing more is revealed.\n* By process of elimination, Sean now knows your word has to be pajamas, so he proceeds to guess j, m, p, and s in order, without losing any more points.\n\nSo Sean loses one point if you choose pajamas. He would have gotten either of the other words without losing any points.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with a line containing integers $N$ and $M$, representing the number of words in the dictionary and the number of lists to consider.\n\nThe next $N$ lines contain the words in the dictionary, one per line: $D_1$, $D_2$, ..., $D_N$. Each word is an arbitrary sequence of characters a - z.\n\nThe final $M$ lines contain all of the lists Sean will use, one per line: $L_1$, $L_2$, ..., $L_M$. Each list is exactly 26 letters long, containing each letter exactly once. Sean will use these lists to guess letters as described above.\n", "outputFormat": "For each test case, output one line containing \"Case #x: $w_1$ $w_2$ ... $w_M$\", where $x$ is the case number (starting from 1) and $w_i$ is the word you should choose if Sean guesses the letters in order $L_i$. If multiple words cause Sean to lose the same number of points, you should choose the option that appears first in the dictionary.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 10$.\n- Each word in $D$ will have between $1$ and $10$ characters inclusive.\n- No two words in $D$ will be the same within a single test case.\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 100$.\n- $1 \\leq M \\leq 10$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (20 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq N \\leq 10000$.\n- $1 \\leq M \\leq 100$.\n- Time limit: ~~60~~ 6 seconds.", "locale": "en", "translations": {"en": {"title": "[GCJ 2011 #1A] The Killer Word", "background": "", "description": "You are playing Hangman with your friend Sean. And while you have heard that Sean is very good at taking candy from a baby, he is not as good at this game. Can you take advantage of Sean's imperfect strategy, and make him lose as badly as possible?\n\n```\n +--+\n |  O\n | /|\\       Mystery word: _ a _ a _ a _\n | / \\\n |\n+-+---+\n```\n\nHangman is played as follows:\n\n* There is a dictionary $D$ of all valid words, which both you and Sean know. A word consists only of the characters a - z. In particular, there are no spaces.\n* You begin by choosing any word from $D$, and writing it down on a blackboard with each letter replaced by a blank: _.\n* On his turn, Sean can choose any letter and ask you if it is in the word. If it is, you reveal all locations of that letter. Otherwise, Sean loses a point.\n* Once all letters in the word have been revealed, the round ends.\n* The round never ends early, no matter how many points Sean loses.\n\nSean uses a very simple strategy. He makes a list $L$ of the 26 letters in some order, and goes through the list one letter at a time. If there is at least one word in $D$ that (a) has the letter he is thinking of, and (b) is consistent with what you have written down so far and the result of all of Sean's previous guesses, then Sean guesses that letter. Otherwise, he skips it. No matter what, Sean then moves on to the next letter in his list.\n\nGiven Sean's list, what word should you choose to make Sean lose as many as points as possible? If several choices are equally good, you should choose the one that appears first in $D$.\n\n**Example**\n\nSuppose Sean decides to guess the letters in alphabetical order (i.e., $L = $ \"abcdefghijklmnopqrstuvwxyz\"), and $D$ contains the words banana, caravan, and pajamas. If you choose pajamas, the game would play out as follows:\n\n* You begin by writing 7 blanks _ _ _ _ _ _ _ on the blackboard. Based on the number of blanks, Sean knows immediately that the word is either caravan or pajamas.\n* Sean begins by guessing a since it is first in $L$, and you reveal all locations of the letter a on the blackboard: _ a _ a _ a _.\n* Sean skips b even though it is used in banana. Sean already knows that is not your word.\n* He then guesses c because it appears in caravan. It does not appear in the word you actually chose though, so Sean loses a point and nothing more is revealed.\n* By process of elimination, Sean now knows your word has to be pajamas, so he proceeds to guess j, m, p, and s in order, without losing any more points.\n\nSo Sean loses one point if you choose pajamas. He would have gotten either of the other words without losing any points.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with a line containing integers $N$ and $M$, representing the number of words in the dictionary and the number of lists to consider.\n\nThe next $N$ lines contain the words in the dictionary, one per line: $D_1$, $D_2$, ..., $D_N$. Each word is an arbitrary sequence of characters a - z.\n\nThe final $M$ lines contain all of the lists Sean will use, one per line: $L_1$, $L_2$, ..., $L_M$. Each list is exactly 26 letters long, containing each letter exactly once. Sean will use these lists to guess letters as described above.\n", "outputFormat": "For each test case, output one line containing \"Case #x: $w_1$ $w_2$ ... $w_M$\", where $x$ is the case number (starting from 1) and $w_i$ is the word you should choose if Sean guesses the letters in order $L_i$. If multiple words cause Sean to lose the same number of points, you should choose the option that appears first in the dictionary.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 10$.\n- Each word in $D$ will have between $1$ and $10$ characters inclusive.\n- No two words in $D$ will be the same within a single test case.\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 100$.\n- $1 \\leq M \\leq 10$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (20 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq N \\leq 10000$.\n- $1 \\leq M \\leq 100$.\n- Time limit: ~~60~~ 6 seconds.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2011 #1A] The Killer Word", "background": null, "description": "你正在和你的朋友 Sean 玩“Hangman”（猜单词）游戏。虽然你听说 Sean 很擅长“从婴儿手里夺糖”，但他在这个游戏上并不那么厉害。你能否利用 Sean 不完美的策略，让他输得尽可能惨？\n\n```\n +--+\n |  O\n | /|\\       Mystery word: _ a _ a _ a _\n | / \\\n |\n+-+---+\n```\n\n游戏规则如下：\n\n- 有一个所有有效单词组成的字典 $D$，你和 Sean 都知道。每个单词只包含小写字母 a-z，且没有空格。\n- 你先从 $D$ 中任选一个单词，并把它写在黑板上，每个字母用下划线 _ 替代。\n- Sean 每回合可以选择一个字母，问你这个字母是否在单词中。如果在，你需要揭示所有该字母出现的位置；否则，Sean 失去 1 分。\n- 当单词的所有字母都被揭示后，本轮结束。\n- 无论 Sean 输掉多少分，本轮都不会提前结束。\n\nSean 使用一种非常简单的策略。他会列出 26 个字母，按某种顺序组成列表 $L$，然后依次尝试每个字母。如果在 $D$ 中至少有一个单词（a）包含他当前考虑的字母，且（b）与黑板上已揭示的信息和他之前所有猜测的结果一致，那么 Sean 就会猜这个字母。否则，他会跳过这个字母。不管怎样，Sean 都会继续按顺序尝试下一个字母。\n\n给定 Sean 的字母列表，你应该选择哪个单词，才能让 Sean 输掉尽可能多的分数？如果有多个选择让 Sean 输掉同样多的分数，你应选择字典中最靠前的那个单词。\n\n**示例**\n\n假设 Sean 按字母表顺序猜字母（即 $L = $ \"abcdefghijklmnopqrstuvwxyz\"），且 $D$ 包含 banana、caravan 和 pajamas。如果你选择 pajamas，游戏过程如下：\n\n- 你先在黑板上写下 7 个下划线 _ _ _ _ _ _ _。根据下划线数量，Sean 立刻知道单词只能是 caravan 或 pajamas。\n- Sean 首先猜 a，因为它在 $L$ 的首位，你需要揭示所有 a 的位置：_ a _ a _ a _。\n- Sean 跳过 b，尽管 banana 里有 b，但他已经知道这不是你的单词。\n- 接着他猜 c，因为 caravan 里有 c。但你选的单词没有 c，所以 Sean 失去 1 分，且没有新信息被揭示。\n- 通过排除法，Sean 现在知道你的单词只能是 pajamas，于是他依次猜 j、m、p、s，且不再失分。\n\n所以，如果你选择 pajamas，Sean 会失去 1 分。选其他单词他不会失分。", "inputFormat": "第一行输入测试用例数 $T$。接下来有 $T$ 组测试数据。每组数据第一行包含两个整数 $N$ 和 $M$，分别表示字典中单词数和要考虑的字母列表数。\n\n接下来的 $N$ 行，每行一个单词，依次为 $D_1, D_2, ..., D_N$。每个单词只包含小写字母。\n\n最后 $M$ 行，每行一个 Sean 的字母列表，依次为 $L_1, L_2, ..., L_M$。每个列表恰好包含 26 个字母且每个字母只出现一次。Sean 会按照这些列表的顺序猜字母。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #x: $w_1$ $w_2$ ... $w_M$\"，其中 $x$ 是测试用例编号（从 1 开始），$w_i$ 是当 Sean 按 $L_i$ 顺序猜字母时，你应该选择的单词。如果有多个单词让 Sean 输掉同样多的分数，选择字典中最靠前的那个。", "hint": "**数据范围**\n\n- $1 \\leq T \\leq 10$。\n- 每个单词长度为 $1$ 到 $10$ 个字符。\n- 每组测试数据中不会有重复单词。\n\n**小数据范围（10 分，测试点 1 - 可见）**\n\n- $1 \\leq N \\leq 100$。\n- $1 \\leq M \\leq 10$。\n- 时间限制：3 秒。\n\n**大数据范围（20 分，测试点 2 - 隐藏）**\n\n- $1 \\leq N \\leq 10000$。\n- $1 \\leq M \\leq 100$。\n- 时间限制：6 秒。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13367", "type": "P", "difficulty": 6, "samples": [["2\n4\n1 0 0\n1 1 1\n0 5 0\n1 2 0\n0\n2\n1 1 1\n0 6 0\n1\n0 1 3", "Case #1: 6\nCase #2: 8"]], "limits": {"time": [6000, 12000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2011", "Google Code Jam"], "title": "[GCJ 2011 #1A] Pseudominion", "background": "", "description": "You are playing a game with a fancy deck of cards. Each card has three bonus numbers: a card bonus $c$, a score bonus $s$, and a turn bonus $t$. Some of the cards start in your hand, while the rest are in a deck on the table. You start with one turn.\n\nOn each turn, you can choose any card from your hand and play it. If it has bonus numbers $c$, $s$, $t$, then the following happens:\n\n* The card is discarded from your hand, and it can never be used again.\n* You draw the first $c$ cards from the deck into your hand. If the deck has fewer than $c$ cards in it, you draw all of them.\n* Your total score increases by $s$.\n* Your number of remaining turns increases by $t$.\n\nIf you do not have any cards in your hand at the start of a turn, then nothing happens on that turn. Your goal is to get as high a score as possible before running out of turns.\n\nFor example, suppose your hand and deck contain the following cards:\n\n```\n         +---+---+---+            +---+---+---+\n   HAND: | c | s | t |      DECK: | c | s | t |\n         +---+---+---+            +---+---+---+\nCard #1: | 0 | 0 | 2 |   Card #4: | 1 | 1 | 0 |\nCard #2: | 0 | 5 | 0 |   Card #5: | 0 | 1 | 1 |\nCard #3: | 2 | 1 | 1 |   Card #6: | 2 | 2 | 0 |\n         +---+---+---+            +---+---+---+\n```\n\nThe following table shows how you can get a score of 8 from these cards. The first three columns show your hand, the number of turns left, and your score before playing each card, and the final column shows which card to play.\n\n```\n+---------+------------+-------+------+\n| Hand    | Turns left | Score | Play |\n+---------+------------+-------+------+\n| 1, 2, 3 |      1     |   0   |   1  |\n| 2, 3    |      2     |   0   |   3  |\n| 2, 4, 5 |      2     |   1   |   2  |\n| 4, 5    |      1     |   6   |   5  |\n| 4       |      1     |   7   |   4  |\n| 6       |      0     |   8   |   -  |\n+---------+------------+-------+------+\n```\n\nAs you can see, the card bonuses and turn bonuses allow you to chain together a long sequence of cards before you have to stop.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow.\n\nEach test case begins with a single line containing $N$, the number of cards in your hand. The next $N$ lines each contain three integers, $c$, $s$, and $t$, representing the bonus numbers for a single card in your hand.\n\nThis is followed by a single line containing $M$, the number of cards in the deck. The next $M$ lines each contain three integers, $c$, $s$, and $t$, representing the bonus numbers for a single card in the deck. These cards are listed in the same order in which you draw them.\n", "outputFormat": "For each test case, output one line containing \"Case #x: $S$\", where $S$ is the largest score you can obtain before running out of turns.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq N$.\n- $0 \\leq M$.\n- $N + M \\leq 80$.\n\n**Small dataset (15 Pts, Test set 1 - Visible)**\n\n- $0 \\leq c \\leq 1$.\n- $0 \\leq s \\leq 20$.\n- $0 \\leq t \\leq 20$.\n- Time limit: ~~30~~ 6 seconds.\n\n**Large dataset (35 Pts, Test set 2 - Hidden)**\n\n- $0 \\leq c \\leq 2$.\n- $0 \\leq s \\leq 50$.\n- $0 \\leq t \\leq 50$.\n- Time limit: ~~60~~ 12 seconds.", "locale": "en", "translations": {"en": {"title": "[GCJ 2011 #1A] Pseudominion", "background": "", "description": "You are playing a game with a fancy deck of cards. Each card has three bonus numbers: a card bonus $c$, a score bonus $s$, and a turn bonus $t$. Some of the cards start in your hand, while the rest are in a deck on the table. You start with one turn.\n\nOn each turn, you can choose any card from your hand and play it. If it has bonus numbers $c$, $s$, $t$, then the following happens:\n\n* The card is discarded from your hand, and it can never be used again.\n* You draw the first $c$ cards from the deck into your hand. If the deck has fewer than $c$ cards in it, you draw all of them.\n* Your total score increases by $s$.\n* Your number of remaining turns increases by $t$.\n\nIf you do not have any cards in your hand at the start of a turn, then nothing happens on that turn. Your goal is to get as high a score as possible before running out of turns.\n\nFor example, suppose your hand and deck contain the following cards:\n\n```\n         +---+---+---+            +---+---+---+\n   HAND: | c | s | t |      DECK: | c | s | t |\n         +---+---+---+            +---+---+---+\nCard #1: | 0 | 0 | 2 |   Card #4: | 1 | 1 | 0 |\nCard #2: | 0 | 5 | 0 |   Card #5: | 0 | 1 | 1 |\nCard #3: | 2 | 1 | 1 |   Card #6: | 2 | 2 | 0 |\n         +---+---+---+            +---+---+---+\n```\n\nThe following table shows how you can get a score of 8 from these cards. The first three columns show your hand, the number of turns left, and your score before playing each card, and the final column shows which card to play.\n\n```\n+---------+------------+-------+------+\n| Hand    | Turns left | Score | Play |\n+---------+------------+-------+------+\n| 1, 2, 3 |      1     |   0   |   1  |\n| 2, 3    |      2     |   0   |   3  |\n| 2, 4, 5 |      2     |   1   |   2  |\n| 4, 5    |      1     |   6   |   5  |\n| 4       |      1     |   7   |   4  |\n| 6       |      0     |   8   |   -  |\n+---------+------------+-------+------+\n```\n\nAs you can see, the card bonuses and turn bonuses allow you to chain together a long sequence of cards before you have to stop.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow.\n\nEach test case begins with a single line containing $N$, the number of cards in your hand. The next $N$ lines each contain three integers, $c$, $s$, and $t$, representing the bonus numbers for a single card in your hand.\n\nThis is followed by a single line containing $M$, the number of cards in the deck. The next $M$ lines each contain three integers, $c$, $s$, and $t$, representing the bonus numbers for a single card in the deck. These cards are listed in the same order in which you draw them.\n", "outputFormat": "For each test case, output one line containing \"Case #x: $S$\", where $S$ is the largest score you can obtain before running out of turns.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq N$.\n- $0 \\leq M$.\n- $N + M \\leq 80$.\n\n**Small dataset (15 Pts, Test set 1 - Visible)**\n\n- $0 \\leq c \\leq 1$.\n- $0 \\leq s \\leq 20$.\n- $0 \\leq t \\leq 20$.\n- Time limit: ~~30~~ 6 seconds.\n\n**Large dataset (35 Pts, Test set 2 - Hidden)**\n\n- $0 \\leq c \\leq 2$.\n- $0 \\leq s \\leq 50$.\n- $0 \\leq t \\leq 50$.\n- Time limit: ~~60~~ 12 seconds.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2011 #1A] Pseudominion", "background": null, "description": "你正在玩一款使用特殊卡牌的游戏。每张卡牌都有三个奖励数值：卡牌奖励 $c$，得分奖励 $s$，回合奖励 $t$。有些卡牌一开始就在你手中，其余的卡牌则在桌上的牌堆中。你从 $1$ 个回合开始。\n\n在每个回合中，你可以从手牌中选择任意一张卡牌并打出。如果这张卡牌的奖励数值为 $c$，$s$，$t$，则会发生以下事件：\n\n- 这张卡牌会从你的手牌中移除，且之后不能再使用。\n- 你从牌堆顶依次抽取 $c$ 张卡牌加入手牌。如果牌堆中剩余的卡牌数少于 $c$，则全部抽取。\n- 你的总得分增加 $s$。\n- 你的剩余回合数增加 $t$。\n\n如果在某个回合开始时你手中没有任何卡牌，则该回合不会发生任何事情。你的目标是在回合数耗尽之前获得尽可能高的分数。\n\n例如，假设你的手牌和牌堆包含如下卡牌：\n\n```\n         +---+---+---+            +---+---+---+\n   HAND: | c | s | t |      DECK: | c | s | t |\n         +---+---+---+            +---+---+---+\nCard #1: | 0 | 0 | 2 |   Card #4: | 1 | 1 | 0 |\nCard #2: | 0 | 5 | 0 |   Card #5: | 0 | 1 | 1 |\nCard #3: | 2 | 1 | 1 |   Card #6: | 2 | 2 | 0 |\n         +---+---+---+            +---+---+---+\n```\n\n下表展示了你如何通过这些卡牌获得 $8$ 分的得分。前三列分别表示你打牌前的手牌、剩余回合数和得分，最后一列表示你选择打出的卡牌编号。\n\n```\n+---------+------------+-------+------+\n| Hand    | Turns left | Score | Play |\n+---------+------------+-------+------+\n| 1, 2, 3 |      1     |   0   |   1  |\n| 2, 3    |      2     |   0   |   3  |\n| 2, 4, 5 |      2     |   1   |   2  |\n| 4, 5    |      1     |   6   |   5  |\n| 4       |      1     |   7   |   4  |\n| 6       |      0     |   8   |   -  |\n+---------+------------+-------+------+\n```\n\n可以看到，卡牌奖励和回合奖励可以让你连续打出多张卡牌，直到无法继续为止。", "inputFormat": "第一行输入一个整数 $T$，表示测试用例的数量。接下来有 $T$ 组测试用例。\n\n每组测试用例的第一行包含一个整数 $N$，表示你手中的卡牌数量。接下来的 $N$ 行，每行包含三个整数 $c$、$s$、$t$，分别表示一张手牌的奖励数值。\n\n然后输入一行，包含一个整数 $M$，表示牌堆中的卡牌数量。接下来的 $M$ 行，每行包含三个整数 $c$、$s$、$t$，分别表示一张牌堆卡牌的奖励数值。这些卡牌的顺序即为你抽取它们的顺序。", "outputFormat": "对于每个测试用例，输出一行，格式为 “Case #x: $S$”，其中 $x$ 表示测试用例编号（从 $1$ 开始），$S$ 表示在回合数耗尽前你能获得的最大得分。", "hint": "**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq N$。\n- $0 \\leq M$。\n- $N + M \\leq 80$。\n\n**小数据（15 分，测试点 1 - 可见）**\n\n- $0 \\leq c \\leq 1$。\n- $0 \\leq s \\leq 20$。\n- $0 \\leq t \\leq 20$。\n- 时间限制：~~30~~ 6 秒。\n\n**大数据（35 分，测试点 2 - 隐藏）**\n\n- $0 \\leq c \\leq 2$。\n- $0 \\leq s \\leq 50$。\n- $0 \\leq t \\leq 50$。\n- 时间限制：~~60~~ 12 秒。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13368", "type": "P", "difficulty": 2, "samples": [["2\n3\n.10\n0.1\n10.\n4\n.11.\n0.00\n01.1\n.10.", "Case #1:\n0.5\n0.5\n0.5\nCase #2:\n0.645833333333\n0.368055555556\n0.604166666667\n0.395833333333"]], "limits": {"time": [3000, 6000], "memory": [1048576, 1048576]}, "tags": ["模拟", "2011", "Special Judge", "Google Code Jam"], "title": "[GCJ 2011 #1B] RPI", "background": "", "description": "In the United States, 350 schools compete every year for an invitation to the NCAA College Basketball Tournament. With so many schools, how do you decide who should be invited? Most teams never play each other, and some teams have a much more difficult schedule than others.\n\nHere is an example schedule for $4$ teams named $A, B, C, D$:\n\n```\n   |ABCD\n  -+----\n  A|.11.\n  B|0.00\n  C|01.1\n  D|.10.\n```\n\nEach 1 in a team's row represents a win, and each 0 represents a loss. So team C has wins against B and D, and a loss against A. Team A has wins against B and C, but has not played D.\n\nThe NCAA tournament committee uses a formula called the RPI (Ratings Percentage Index) to help rank teams. Traditionally, it has been defined as follows:\n\n$$\\text{RPI} = 0.25 \\times \\text{WP} + 0.50 \\times \\text{OWP} + 0.25 \\times \\text{OOWP}$$\n\nWP, OWP, and OOWP are defined for each team as follows:\n\n* WP (Winning Percentage) is the fraction of your games that you have won.\n    * In the example schedule, team A has WP = 1, team B has WP = 0, team C has WP = 2/3, and team D has WP = 0.5.\n* OWP (Opponents' Winning Percentage) is the average WP of all your opponents, after first throwing out the games they played against you.\n    * For example, if you throw out games played against team D, then team B has WP = 0 and team C has WP = 0.5. Therefore team D has $\\text{OWP} = 0.5 \\times (0 + 0.5) = 0.25$. Similarly, team A has OWP = 0.5, team B has OWP = 0.5, and team C has OWP = 2/3.\n* OOWP (Opponents' Opponents' Winning Percentage) is the average OWP of all your opponents. OWP is exactly the number computed in the previous step.\n    * For example, team A has $\\text{OOWP} = 0.5 \\times (0.5 + 2/3) = 7/12$.\n\nPutting it all together, we see team A has $\\text{RPI} = (0.25 \\times 1) + (0.5 \\times 0.5) + (0.25 \\times 7 / 12) = 0.6458333\\dots $\n\nThere are some pretty interesting questions you can ask about the RPI. Is it a reasonable measure of team's ability? Is it more important for teams to win games, or to schedule strong opponents?\n\nThese are all good questions, but for this problem, your task is more straightforward: given a schedule of games, can you calculate every team's RPI?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with a single line containing the number of teams $N$.\n\nThe next $N$ lines each contain exactly $N$ characters (either '0', '1', or '.') representing a schedule in the same format as the example schedule above. A '1' in row $i$, column $j$ indicates team $i$ beat team $j$, a '0' in row $i$, column $j$ indicates team $i$ lost to team $j$, and a '.' in row $i$, column $j$ indicates team $i$ never played against team $j$.\n", "outputFormat": "For each test case, output $N + 1$ lines. The first line should be \"Case #x:\" where $x$ is the case number (starting from 1). The next $N$ lines should contain the RPI of each team, one per line, in the same order as the schedule.\n\nAnswers with a relative or absolute error of at most $10^{-6}$ will be considered correct.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 20$.\n- If the schedule contains a '1' in row $i$, column $j$, then it contains a '0' in row $j$, column $i$.\n- If the schedule contains a '0' in row $i$, column $j$, then it contains a '1' in row $j$, column $i$.\n- If the schedule contains a '.' in row $i$, column $j$, then it contains a '.' in row $j$, column $i$.\n- Every team plays at least two other teams.\n- No two teams play each other twice.\n- No team plays itself.\n\n**Small dataset (8 Pts, Test set 1 - Visible)**\n\n- $3 \\leq N \\leq 10$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (12 Pts, Test set 2 - Hidden)**\n\n- $3 \\leq N \\leq 100$.\n- Time limit: ~~60~~ 6 seconds.", "locale": "en", "translations": {"en": {"title": "[GCJ 2011 #1B] RPI", "background": "", "description": "In the United States, 350 schools compete every year for an invitation to the NCAA College Basketball Tournament. With so many schools, how do you decide who should be invited? Most teams never play each other, and some teams have a much more difficult schedule than others.\n\nHere is an example schedule for $4$ teams named $A, B, C, D$:\n\n```\n   |ABCD\n  -+----\n  A|.11.\n  B|0.00\n  C|01.1\n  D|.10.\n```\n\nEach 1 in a team's row represents a win, and each 0 represents a loss. So team C has wins against B and D, and a loss against A. Team A has wins against B and C, but has not played D.\n\nThe NCAA tournament committee uses a formula called the RPI (Ratings Percentage Index) to help rank teams. Traditionally, it has been defined as follows:\n\n$$\\text{RPI} = 0.25 \\times \\text{WP} + 0.50 \\times \\text{OWP} + 0.25 \\times \\text{OOWP}$$\n\nWP, OWP, and OOWP are defined for each team as follows:\n\n* WP (Winning Percentage) is the fraction of your games that you have won.\n    * In the example schedule, team A has WP = 1, team B has WP = 0, team C has WP = 2/3, and team D has WP = 0.5.\n* OWP (Opponents' Winning Percentage) is the average WP of all your opponents, after first throwing out the games they played against you.\n    * For example, if you throw out games played against team D, then team B has WP = 0 and team C has WP = 0.5. Therefore team D has $\\text{OWP} = 0.5 \\times (0 + 0.5) = 0.25$. Similarly, team A has OWP = 0.5, team B has OWP = 0.5, and team C has OWP = 2/3.\n* OOWP (Opponents' Opponents' Winning Percentage) is the average OWP of all your opponents. OWP is exactly the number computed in the previous step.\n    * For example, team A has $\\text{OOWP} = 0.5 \\times (0.5 + 2/3) = 7/12$.\n\nPutting it all together, we see team A has $\\text{RPI} = (0.25 \\times 1) + (0.5 \\times 0.5) + (0.25 \\times 7 / 12) = 0.6458333\\dots $\n\nThere are some pretty interesting questions you can ask about the RPI. Is it a reasonable measure of team's ability? Is it more important for teams to win games, or to schedule strong opponents?\n\nThese are all good questions, but for this problem, your task is more straightforward: given a schedule of games, can you calculate every team's RPI?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with a single line containing the number of teams $N$.\n\nThe next $N$ lines each contain exactly $N$ characters (either '0', '1', or '.') representing a schedule in the same format as the example schedule above. A '1' in row $i$, column $j$ indicates team $i$ beat team $j$, a '0' in row $i$, column $j$ indicates team $i$ lost to team $j$, and a '.' in row $i$, column $j$ indicates team $i$ never played against team $j$.\n", "outputFormat": "For each test case, output $N + 1$ lines. The first line should be \"Case #x:\" where $x$ is the case number (starting from 1). The next $N$ lines should contain the RPI of each team, one per line, in the same order as the schedule.\n\nAnswers with a relative or absolute error of at most $10^{-6}$ will be considered correct.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 20$.\n- If the schedule contains a '1' in row $i$, column $j$, then it contains a '0' in row $j$, column $i$.\n- If the schedule contains a '0' in row $i$, column $j$, then it contains a '1' in row $j$, column $i$.\n- If the schedule contains a '.' in row $i$, column $j$, then it contains a '.' in row $j$, column $i$.\n- Every team plays at least two other teams.\n- No two teams play each other twice.\n- No team plays itself.\n\n**Small dataset (8 Pts, Test set 1 - Visible)**\n\n- $3 \\leq N \\leq 10$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (12 Pts, Test set 2 - Hidden)**\n\n- $3 \\leq N \\leq 100$.\n- Time limit: ~~60~~ 6 seconds.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2011 #1B] RPI", "background": null, "description": "在美国，每年有 350 所学校争夺 NCAA 大学篮球锦标赛的邀请资格。由于学校众多，如何决定哪些学校应该被邀请呢？大多数队伍之间从未交手，而且有些队伍的赛程比其他队伍要艰难得多。\n\n下面是 $4$ 支队伍 $A, B, C, D$ 的一个赛程示例：\n\n```\n   |ABCD\n  -+----\n  A|.11.\n  B|0.00\n  C|01.1\n  D|.10.\n```\n\n每一行中的 $1$ 表示该队获胜，$0$ 表示该队失利。因此，队伍 $C$ 战胜了 $B$ 和 $D$，输给了 $A$。队伍 $A$ 战胜了 $B$ 和 $C$，但没有与 $D$ 交手。\n\nNCAA 锦标赛委员会使用一个叫做 RPI（Ratings Percentage Index，评级百分指数）的公式来帮助排名队伍。传统上，它被定义为：\n\n$$\\text{RPI} = 0.25 \\times \\text{WP} + 0.50 \\times \\text{OWP} + 0.25 \\times \\text{OOWP}$$\n\nWP、OWP 和 OOWP 对每支队伍的定义如下：\n\n- WP（胜率）是你赢得的比赛场次占总比赛场次的比例。\n    - 在示例赛程中，队伍 $A$ 的 WP = 1，队伍 $B$ 的 WP = 0，队伍 $C$ 的 WP = 2/3，队伍 $D$ 的 WP = 0.5。\n- OWP（对手胜率）是你所有对手的 WP 的平均值，但首先要去掉他们与自己的比赛。\n    - 例如，如果去掉与 $D$ 队的比赛，$B$ 队的 WP = 0，$C$ 队的 WP = 0.5。因此，$D$ 队的 $\\text{OWP} = 0.5 \\times (0 + 0.5) = 0.25$。类似地，$A$ 队的 OWP = 0.5，$B$ 队的 OWP = 0.5，$C$ 队的 OWP = 2/3。\n- OOWP（对手的对手胜率）是你所有对手的 OWP 的平均值。OWP 就是上一步计算的数值。\n    - 例如，$A$ 队的 $\\text{OOWP} = 0.5 \\times (0.5 + 2/3) = 7/12$。\n\n综合计算，$A$ 队的 $\\text{RPI} = (0.25 \\times 1) + (0.5 \\times 0.5) + (0.25 \\times 7 / 12) = 0.6458333\\dots $\n\n关于 RPI，你可以提出一些有趣的问题。RPI 是否合理地衡量了队伍的实力？对队伍来说，赢得比赛更重要，还是安排强劲的对手更重要？\n\n这些都是很好的问题，但对于本题，你的任务更为直接：给定一份比赛赛程，你能否计算出每支队伍的 RPI？", "inputFormat": "输入的第一行是测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行为队伍数 $N$。\n\n接下来的 $N$ 行，每行包含恰好 $N$ 个字符（'0'、'1' 或 '.'），表示赛程，格式与上面的示例相同。第 $i$ 行第 $j$ 列的 '1' 表示队伍 $i$ 战胜了队伍 $j$，'0' 表示队伍 $i$ 输给了队伍 $j$，'.' 表示队伍 $i$ 没有与队伍 $j$ 交手。", "outputFormat": "对于每组测试数据，输出 $N+1$ 行。第一行为 \"Case #x:\"，其中 $x$ 是测试编号（从 1 开始）。接下来的 $N$ 行，每行输出一支队伍的 RPI，顺序与输入赛程一致。\n\n只要相对或绝对误差不超过 $10^{-6}$ 的答案都将被判为正确。", "hint": "**数据范围**\n\n- $1 \\leq T \\leq 20$。\n- 如果赛程中第 $i$ 行第 $j$ 列为 '1'，则第 $j$ 行第 $i$ 列为 '0'。\n- 如果赛程中第 $i$ 行第 $j$ 列为 '0'，则第 $j$ 行第 $i$ 列为 '1'。\n- 如果赛程中第 $i$ 行第 $j$ 列为 '.'，则第 $j$ 行第 $i$ 列也为 '.'。\n- 每支队伍至少与另外两支队伍比赛过。\n- 没有两支队伍之间会比赛两次。\n- 没有队伍与自己比赛。\n\n**小数据范围（8 分，测试点 1 - 可见）**\n\n- $3 \\leq N \\leq 10$。\n- 时间限制：3 秒。\n\n**大数据范围（12 分，测试点 2 - 隐藏）**\n\n- $3 \\leq N \\leq 100$。\n- 时间限制：6 秒。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13369", "type": "P", "difficulty": 4, "samples": [["2\n3 2\n0 1\n3 2\n6 1\n2 2\n0 3\n1 1", ""]], "limits": {"time": [3000, 6000], "memory": [1048576, 1048576]}, "tags": ["数学", "贪心", "2011", "二分", "Special Judge", "Google Code Jam"], "title": "[GCJ 2011 #1B] Revenge of the Hot Dogs", "background": "", "description": "Last year, several hot dog vendors were lined up along a street, and they had a tricky algorithm to spread themselves out. Unfortunately, the algorithm was very slow and they are still going. All is not lost though! The hot dog vendors have a plan: time to try a new algorithm!\n\nThe problem is that multiple vendors might be selling too close to each other, and then they will take each other's business. The vendors can move along the street at 1 meter/second. To avoid interfering with each other, they want to stand so that every pair of them is separated by a distance of at least $D$ meters.\n\nRemember that the street is really long, so there is no danger of running out of space to move in either direction. Given the starting positions of all hot dog vendors, you should find the minimum time they need before all the vendors are separated (each two vendors are at least $D$ meters apart from each other).", "inputFormat": "Each point of the street is labeled with a number, positive, negative or zero. A point labeled $p$ is $|p|$ meters east of the point labeled $0$ if $p$ is positive, and $|p|$ meters west of the point labeled $0$ if $p$ is negative. We will use this labeling system to describe the positions of the vendors in the input file.\n\nThe first line of the input file contains the number of cases, $T$. $T$ test cases follow. Each case begins with a line containing the number of points $C$ that have at least one hot dog vendor in the starting configuration and an integer $D$ -- the minimum distance they want to spread out to. The next $C$ lines each contain a pair of space-separated integers $P$, $V$, indicating that there are $V$ vendors at the point labeled $P$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the minimum amount of time it will take for the vendors to spread out apart on the street. Answers with relative or absolute error of at most $10^{-6}$ will be accepted.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 50$.\n- All the values $P$ are integers in the range $[-10^5, 10^5]$.\n- Within each test case all $P$ values are distinct and given in an increasing order. The limit on the sum of $V$ values is listed below. All the $V$ values are positive integers.\n\n**Small dataset (15 Pts, Test set 1 - Visible)**\n\n- $1 \\leq D \\leq 5$\n- $1 \\leq C \\leq 20$.\n- The sum of all the $V$ values in one test case does not exceed $100$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (20 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq D \\leq 10^6$\n- $1 \\leq C \\leq 200$.\n- The sum of all $V$ values does not exceed $10^6$.\n- Time limit: ~~60~~ 6 seconds.", "locale": "en", "translations": {"en": {"title": "[GCJ 2011 #1B] Revenge of the Hot Dogs", "background": "", "description": "Last year, several hot dog vendors were lined up along a street, and they had a tricky algorithm to spread themselves out. Unfortunately, the algorithm was very slow and they are still going. All is not lost though! The hot dog vendors have a plan: time to try a new algorithm!\n\nThe problem is that multiple vendors might be selling too close to each other, and then they will take each other's business. The vendors can move along the street at 1 meter/second. To avoid interfering with each other, they want to stand so that every pair of them is separated by a distance of at least $D$ meters.\n\nRemember that the street is really long, so there is no danger of running out of space to move in either direction. Given the starting positions of all hot dog vendors, you should find the minimum time they need before all the vendors are separated (each two vendors are at least $D$ meters apart from each other).", "inputFormat": "Each point of the street is labeled with a number, positive, negative or zero. A point labeled $p$ is $|p|$ meters east of the point labeled $0$ if $p$ is positive, and $|p|$ meters west of the point labeled $0$ if $p$ is negative. We will use this labeling system to describe the positions of the vendors in the input file.\n\nThe first line of the input file contains the number of cases, $T$. $T$ test cases follow. Each case begins with a line containing the number of points $C$ that have at least one hot dog vendor in the starting configuration and an integer $D$ -- the minimum distance they want to spread out to. The next $C$ lines each contain a pair of space-separated integers $P$, $V$, indicating that there are $V$ vendors at the point labeled $P$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the minimum amount of time it will take for the vendors to spread out apart on the street. Answers with relative or absolute error of at most $10^{-6}$ will be accepted.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 50$.\n- All the values $P$ are integers in the range $[-10^5, 10^5]$.\n- Within each test case all $P$ values are distinct and given in an increasing order. The limit on the sum of $V$ values is listed below. All the $V$ values are positive integers.\n\n**Small dataset (15 Pts, Test set 1 - Visible)**\n\n- $1 \\leq D \\leq 5$\n- $1 \\leq C \\leq 20$.\n- The sum of all the $V$ values in one test case does not exceed $100$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (20 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq D \\leq 10^6$\n- $1 \\leq C \\leq 200$.\n- The sum of all $V$ values does not exceed $10^6$.\n- Time limit: ~~60~~ 6 seconds.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2011 #1B] Revenge of the Hot Dogs", "background": null, "description": "去年，有几位热狗摊贩沿着一条街道排成一列，他们采用了一种复杂的算法来分散自己。不幸的是，这个算法非常慢，他们至今还没有分散好。不过，一切还没有结束！热狗摊贩们有了一个新计划：是时候尝试一种新算法了！\n\n问题在于，多个摊贩可能站得太近，这样他们就会互相抢生意。摊贩们可以以每秒 $1$ 米的速度沿街道移动。为了避免互相干扰，他们希望每对摊贩之间的距离至少为 $D$ 米。\n\n请注意，这条街道非常长，所以无论往哪个方向移动都不会遇到空间不足的问题。给定所有热狗摊贩的初始位置，请你计算出所有摊贩分散开（任意两名摊贩之间的距离至少为 $D$ 米）所需的最短时间。", "inputFormat": "街道上的每个点都用一个数字标记，可能为正、负或零。标记为 $p$ 的点，若 $p$ 为正，则在标记为 $0$ 的点以东 $|p|$ 米处；若 $p$ 为负，则在标记为 $0$ 的点以西 $|p|$ 米处。我们将使用这种标记方式来描述输入文件中摊贩的位置。\n\n输入文件的第一行包含测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行包含两个整数 $C$ 和 $D$，分别表示初始时有摊贩的点的数量，以及他们希望分散到的最小距离。接下来的 $C$ 行，每行包含两个用空格分隔的整数 $P$ 和 $V$，表示在标记为 $P$ 的点上有 $V$ 个摊贩。", "outputFormat": "对于每组测试数据，输出一行，格式为 “Case #$x$: $y$”，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是所有摊贩分散开所需的最短时间。只要你的答案的相对或绝对误差不超过 $10^{-6}$，即可被接受。", "hint": "**数据范围**\n\n- $1 \\leq T \\leq 50$。\n- 所有 $P$ 的取值范围为 $[-10^5, 10^5]$。\n- 每组测试数据中所有 $P$ 互不相同，且按递增顺序给出。每组测试数据中所有 $V$ 的和见下文。所有 $V$ 都是正整数。\n\n**小数据集（15 分，测试集 1 - 可见）**\n\n- $1 \\leq D \\leq 5$\n- $1 \\leq C \\leq 20$\n- 每组测试数据中所有 $V$ 的和不超过 $100$\n- 时间限制：3 秒\n\n**大数据集（20 分，测试集 2 - 隐藏）**\n\n- $1 \\leq D \\leq 10^6$\n- $1 \\leq C \\leq 200$\n- 每组测试数据中所有 $V$ 的和不超过 $10^6$\n- 时间限制：6 秒\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13370", "type": "P", "difficulty": 6, "samples": [["2\n4 1\n2\n4\n8 3\n1 1 4\n3 7 7", "Case #1: 3\n1 2 1 3\nCase #2: 3\n1 2 3 1 1 3 2 3"]], "limits": {"time": [6000, 12000], "memory": [1048576, 1048576]}, "tags": ["2011", "Special Judge", "平面图", "Google Code Jam"], "title": "[GCJ 2011 #1B] House of Kittens", "background": "", "description": "You have recently adopted some kittens, and now you want to make a house for them. On the outside, the house will be shaped like a convex polygon with $N$ vertices. On the inside, it will be divided into several rooms by $M$ interior walls connecting vertices along straight lines. No two walls will ever cross, but there might be multiple walls touching a single vertex.\n\nSo why is your house of kittens going to be so special? At every vertex, you are going to build a pillar entirely out of catnip! Kittens will be able to play with any pillar that touches the room they are in, giving them a true luxury home.\n\nTo make the house even more exciting, you want to use different flavors of catnip. A single pillar can only use one flavor, but different pillars can use different flavors. There is only one problem. If some room does not have access to all the catnip flavors in the house, then the kittens in that room will feel left out and be sad.\n\nYour task is to choose what flavor of catnip to use for each vertex in such a way that (a) every flavor is accessible from every room, and (b) as many flavors as possible are used.\n\nIn the following example, three different flavors (represented by red, green, and blue dots) are distributed across an 8-sided house while keeping the kittens in every room happy:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xd93gzb7.png)\n\nIn the image above, starting at the left corner of the top wall and going clockwise, the colors here are: green, blue, red, red, blue, green, blue, red.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow.\n\nEach test case consists of three lines. The first line gives $N$ and $M$, the number of vertices and interior walls in your cat house. The second lines gives space-separated integers $U_1$, $U_2$, ..., $U_M$ describing where each interior wall begins. The third lines gives space-separated integers $V_1$, $V_2$, ..., $V_M$ describing where each interior wall ends.\n\nMore precisely, if the vertices of your cat house are labeled $1$, $2$, ..., $N$ in clockwise order, then the interior walls are between vertices $U_1$ and $V_1$, $U_2$ and $V_2$, etc.", "outputFormat": "For each test case, output two lines. The first should be \"Case #$x$: $C$\", where $x$ is the case number, and $C$ is the maximum number of catnip flavors that can be used. The second line should contain $N$ space-separated integers: \"$y_1$ $y_2$ ... $y_N$\", where $y_i$ is an integer between $1$ and $C$ indicating which catnip flavor you assigned to vertex $i$.\n\nIf there are multiple assignments with $C$ flavors, you may output any of them.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq M \\leq N - 3$.\n- $1 \\leq U_i < V_i \\leq N$ for all $i$.\n- Interior walls do not touch each other except at the $N$ vertices.\n- Interior walls do not touch the outside of the house except at the $N$ vertices.\n\n**Small dataset (20 Pts, Test set 1 - Visible)**\n\n- $4 \\leq N \\leq 8$.\n- Time limit: ~~30~~ 6 seconds.\n\n**Large dataset (25 Pts, Test set 2 - Hidden)**\n\n- $4 \\leq N \\leq 2000$.\n- Time limit: ~~60~~ 12 seconds.", "locale": "en", "translations": {"en": {"title": "[GCJ 2011 #1B] House of Kittens", "background": "", "description": "You have recently adopted some kittens, and now you want to make a house for them. On the outside, the house will be shaped like a convex polygon with $N$ vertices. On the inside, it will be divided into several rooms by $M$ interior walls connecting vertices along straight lines. No two walls will ever cross, but there might be multiple walls touching a single vertex.\n\nSo why is your house of kittens going to be so special? At every vertex, you are going to build a pillar entirely out of catnip! Kittens will be able to play with any pillar that touches the room they are in, giving them a true luxury home.\n\nTo make the house even more exciting, you want to use different flavors of catnip. A single pillar can only use one flavor, but different pillars can use different flavors. There is only one problem. If some room does not have access to all the catnip flavors in the house, then the kittens in that room will feel left out and be sad.\n\nYour task is to choose what flavor of catnip to use for each vertex in such a way that (a) every flavor is accessible from every room, and (b) as many flavors as possible are used.\n\nIn the following example, three different flavors (represented by red, green, and blue dots) are distributed across an 8-sided house while keeping the kittens in every room happy:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xd93gzb7.png)\n\nIn the image above, starting at the left corner of the top wall and going clockwise, the colors here are: green, blue, red, red, blue, green, blue, red.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow.\n\nEach test case consists of three lines. The first line gives $N$ and $M$, the number of vertices and interior walls in your cat house. The second lines gives space-separated integers $U_1$, $U_2$, ..., $U_M$ describing where each interior wall begins. The third lines gives space-separated integers $V_1$, $V_2$, ..., $V_M$ describing where each interior wall ends.\n\nMore precisely, if the vertices of your cat house are labeled $1$, $2$, ..., $N$ in clockwise order, then the interior walls are between vertices $U_1$ and $V_1$, $U_2$ and $V_2$, etc.", "outputFormat": "For each test case, output two lines. The first should be \"Case #$x$: $C$\", where $x$ is the case number, and $C$ is the maximum number of catnip flavors that can be used. The second line should contain $N$ space-separated integers: \"$y_1$ $y_2$ ... $y_N$\", where $y_i$ is an integer between $1$ and $C$ indicating which catnip flavor you assigned to vertex $i$.\n\nIf there are multiple assignments with $C$ flavors, you may output any of them.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq M \\leq N - 3$.\n- $1 \\leq U_i < V_i \\leq N$ for all $i$.\n- Interior walls do not touch each other except at the $N$ vertices.\n- Interior walls do not touch the outside of the house except at the $N$ vertices.\n\n**Small dataset (20 Pts, Test set 1 - Visible)**\n\n- $4 \\leq N \\leq 8$.\n- Time limit: ~~30~~ 6 seconds.\n\n**Large dataset (25 Pts, Test set 2 - Hidden)**\n\n- $4 \\leq N \\leq 2000$.\n- Time limit: ~~60~~ 12 seconds.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2011 #1B] House of Kittens", "background": null, "description": "你最近收养了一些小猫，现在你想为它们建造一个房子。这个房子的外形是一个有 $N$ 个顶点的凸多边形。在房子的内部，会有 $M$ 条内部墙壁，沿直线连接顶点进行分隔。任意两条墙壁不会相交，但可能有多条墙壁连接到同一个顶点。\n\n那么，为什么你的小猫房子如此特别呢？因为你将在每个顶点建造一个完全由猫薄荷制成的柱子！小猫们可以在它们所在房间内玩耍任何接触到该房间的柱子，这将给它们带来真正的豪华体验。\n\n为了让房子更加有趣，你想使用不同口味的猫薄荷。每根柱子只能使用一种口味，但不同的柱子可以使用不同的口味。唯一的问题是：如果某个房间无法接触到所有在房子中使用的猫薄荷口味，那么在那个房间里的小猫就会感到被冷落而伤心。\n\n你的任务是为每个顶点选择一种猫薄荷口味，使得（a）每个房间都能接触到所有的口味，（b）尽可能多地使用不同的口味。\n\n在下面的例子中，三种不同口味（用红色、绿色和蓝色点表示）被分布在一个八边形的房子上，同时保证每个房间里的小猫都能开心：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xd93gzb7.png)\n\n在上图中，从顶部墙的左角开始顺时针，颜色依次为：绿色、蓝色、红色、红色、蓝色、绿色、蓝色、红色。", "inputFormat": "第一行输入测试用例数 $T$。接下来有 $T$ 组测试数据。\n\n每组测试数据包含三行。第一行包含两个整数 $N$ 和 $M$，分别表示顶点数和内部墙壁数。第二行包含 $M$ 个用空格分隔的整数 $U_1, U_2, \\ldots, U_M$，表示每条内部墙壁的起点。第三行包含 $M$ 个用空格分隔的整数 $V_1, V_2, \\ldots, V_M$，表示每条内部墙壁的终点。\n\n更具体地说，如果房子的顶点按顺时针顺序编号为 $1, 2, \\ldots, N$，则第 $i$ 条内部墙壁连接顶点 $U_i$ 和 $V_i$。", "outputFormat": "对于每组测试数据，输出两行。第一行输出 \"Case #$x$: $C$\"，其中 $x$ 是测试编号，$C$ 是可以使用的最大猫薄荷口味数。第二行输出 $N$ 个用空格分隔的整数 \"$y_1$ $y_2$ ... $y_N$\"，其中 $y_i$ 是分配给第 $i$ 个顶点的猫薄荷口味编号（$1$ 到 $C$ 之间的整数）。\n\n如果存在多种分配方式都能达到 $C$ 种口味，可以输出任意一种。", "hint": "**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq M \\leq N - 3$。\n- 对所有 $i$，$1 \\leq U_i < V_i \\leq N$。\n- 内部墙壁之间不会相交，除非在 $N$ 个顶点处相交。\n- 内部墙壁不会接触房子的外部，除非在 $N$ 个顶点处。\n\n**小数据（20 分，测试点 1 - 可见）**\n\n- $4 \\leq N \\leq 8$。\n- 时间限制：6 秒。\n\n**大数据（25 分，测试点 2 - 隐藏）**\n\n- $4 \\leq N \\leq 2000$。\n- 时间限制：12 秒。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13371", "type": "P", "difficulty": 2, "samples": [["3\n2 3\n###\n###\n1 1\n.\n4 5\n.##..\n.####\n.####\n.##..", "Case #1:\nImpossible\nCase #2:\n.\nCase #3:\n./\\..\n.\\//\\\n./\\\\/\n.\\/.."]], "limits": {"time": [3000, 6000], "memory": [1048576, 1048576]}, "tags": ["模拟", "贪心", "2011", "Special Judge", "Google Code Jam"], "title": "[GCJ 2011 #1C] Square Tiles", "background": "", "description": "You are selling beautiful geometric pictures. Each one consists of $1\\times 1$ square tiles arranged into a non-overlapping grid. For example:\n\n```\n    .##..\n    .####\n    .####\n    .##..\n```\n\nBlue tiles are represented by '#' characters, and white tiles are represented by '.' characters. You do not use other colors.\n\nNot everybody likes blue though, and some customers want you to replace all the blue tiles in your picture with red tiles. Unfortunately, red tiles only come in the larger $2\\times 2$ size, which makes this tricky.\n\nYou can cover any $2\\times 2$ square of blue tiles with a single red tile, and then repeat until finished. A red tile cannot overlap another red tile, it cannot cover white tiles, and it cannot go outside the picture. For example, you could add red tiles to the previous picture as follows:\n\n```\n    ./\\..\n    .\\//\\\n    ./\\\\/\n    .\\/..\n```\n\nEach red tile is represented here by a pair of '/' characters in the top-left and bottom-right corners, and a pair of '\\\\' characters in the other two corners.\n\nGiven a blue and white picture, can you transform it into a red and white picture in this way?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow.\n\nEach test case begins with a line containing $R$ and $C$, the number of rows and columns in a picture. The next $R$ lines each contain exactly $C$ characters, describing the picture. As above, '#' characters represent blue tiles, and '.' characters represent white tiles.\n", "outputFormat": "For each test case, first output one line containing \"Case #$x$: \" where $x$ is the case number (starting from 1).\n\nIf it is possible to cover the blue tiles with non-overlapping red tiles, output $R$ lines each containing $C$ characters, describing the resulting red and white picture. As above, red tiles should be represented by '/' and '\\\\' characters, while white tiles are represented by '.' characters. If multiple solutions are possible, you may output any of them.\n\nIf the task is impossible, output a single line containing the text \"Impossible\" instead.", "hint": "**Limits**\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $1 \\leq T \\leq 20$.\n- $1 \\leq R \\leq 6$.\n- $1 \\leq C \\leq 6$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (10 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq T \\leq 50$.\n- $1 \\leq R \\leq 50$.\n- $1 \\leq C \\leq 50$.\n- Time limit: ~~60~~ 6 seconds.", "locale": "en", "translations": {"en": {"title": "[GCJ 2011 #1C] Square Tiles", "background": "", "description": "You are selling beautiful geometric pictures. Each one consists of $1\\times 1$ square tiles arranged into a non-overlapping grid. For example:\n\n```\n    .##..\n    .####\n    .####\n    .##..\n```\n\nBlue tiles are represented by '#' characters, and white tiles are represented by '.' characters. You do not use other colors.\n\nNot everybody likes blue though, and some customers want you to replace all the blue tiles in your picture with red tiles. Unfortunately, red tiles only come in the larger $2\\times 2$ size, which makes this tricky.\n\nYou can cover any $2\\times 2$ square of blue tiles with a single red tile, and then repeat until finished. A red tile cannot overlap another red tile, it cannot cover white tiles, and it cannot go outside the picture. For example, you could add red tiles to the previous picture as follows:\n\n```\n    ./\\..\n    .\\//\\\n    ./\\\\/\n    .\\/..\n```\n\nEach red tile is represented here by a pair of '/' characters in the top-left and bottom-right corners, and a pair of '\\\\' characters in the other two corners.\n\nGiven a blue and white picture, can you transform it into a red and white picture in this way?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow.\n\nEach test case begins with a line containing $R$ and $C$, the number of rows and columns in a picture. The next $R$ lines each contain exactly $C$ characters, describing the picture. As above, '#' characters represent blue tiles, and '.' characters represent white tiles.\n", "outputFormat": "For each test case, first output one line containing \"Case #$x$: \" where $x$ is the case number (starting from 1).\n\nIf it is possible to cover the blue tiles with non-overlapping red tiles, output $R$ lines each containing $C$ characters, describing the resulting red and white picture. As above, red tiles should be represented by '/' and '\\\\' characters, while white tiles are represented by '.' characters. If multiple solutions are possible, you may output any of them.\n\nIf the task is impossible, output a single line containing the text \"Impossible\" instead.", "hint": "**Limits**\n\n**Small dataset (10 Pts, Test set 1 - Visible)**\n\n- $1 \\leq T \\leq 20$.\n- $1 \\leq R \\leq 6$.\n- $1 \\leq C \\leq 6$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (10 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq T \\leq 50$.\n- $1 \\leq R \\leq 50$.\n- $1 \\leq C \\leq 50$.\n- Time limit: ~~60~~ 6 seconds.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2011 #1C] Square Tiles", "background": null, "description": "你正在出售美丽的几何画作。每幅画由 $1\\times 1$ 的方块瓷砖组成，排列成不重叠的网格。例如：\n\n```\n    .##..\n    .####\n    .####\n    .##..\n```\n\n蓝色瓷砖用字符 '#' 表示，白色瓷砖用字符 '.' 表示。你不会使用其他颜色。\n\n但并不是每个人都喜欢蓝色，有些顾客希望你把画中的所有蓝色瓷砖都换成红色瓷砖。不幸的是，红色瓷砖只能是更大的 $2\\times 2$ 尺寸，这让事情变得棘手。\n\n你可以用一块红色瓷砖覆盖任意一个 $2\\times 2$ 的蓝色瓷砖区域，然后重复此操作直到完成。红色瓷砖不能重叠，不能覆盖白色瓷砖，也不能超出画作边界。例如，你可以如下方式在上面的画作中添加红色瓷砖：\n\n```\n    ./\\..\n    .\\//\\\n    ./\\\\/\n    .\\/..\n```\n\n每块红色瓷砖用左上和右下角的 '/' 字符，以及另外两个角的 '\\\\' 字符表示。\n\n给定一幅蓝白画作，你能否用这种方式将其转换为红白画作？", "inputFormat": "输入的第一行给出测试用例数 $T$。接下来有 $T$ 组测试用例。\n\n每组测试用例的第一行包含两个整数 $R$ 和 $C$，表示画作的行数和列数。接下来的 $R$ 行，每行包含恰好 $C$ 个字符，描述画作。'#' 表示蓝色瓷砖，'.' 表示白色瓷砖。", "outputFormat": "对于每组测试用例，首先输出一行 \"Case #$x$: \"，其中 $x$ 是测试用例编号（从 1 开始）。\n\n如果可以用不重叠的红色瓷砖覆盖所有蓝色瓷砖，输出 $R$ 行，每行 $C$ 个字符，描述最终的红白画作。红色瓷砖用 '/' 和 '\\\\' 字符表示，白色瓷砖用 '.' 表示。如果有多种方案，可以输出任意一种。\n\n如果无法完成任务，输出一行 \"Impossible\"。", "hint": "**数据范围**\n\n**小数据集（10 分，测试集 1 - 可见）**\n\n- $1 \\leq T \\leq 20$。\n- $1 \\leq R \\leq 6$。\n- $1 \\leq C \\leq 6$。\n- 时间限制：~~30~~ 3 秒。\n\n**大数据集（10 分，测试集 2 - 隐藏）**\n\n- $1 \\leq T \\leq 50$。\n- $1 \\leq R \\leq 50$。\n- $1 \\leq C \\leq 50$。\n- 时间限制：~~60~~ 6 秒。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13372", "type": "P", "difficulty": 3, "samples": [["2\n2 20 8 2 3 5\n1 4 2 2 10 4", "Case #1: 54\nCase #2: 20"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2011", "排序", "Google Code Jam"], "title": "[GCJ 2011 #1C] Space Emergency", "background": "", "description": "There's an emergency—in space! You need to send your fleet's flagship as quickly as possible from star $0$ to star $N$, traveling through the other stars in increasing numerical order along the way ($0 \\rightarrow 1 \\rightarrow \\ldots \\rightarrow N$). Your flagship normally travels at a speed of $0.5$ parsecs per hour.\n\nIn addition to sending your flagship, you can order your engineers to build up to $L$ speed boosters at different stars. Building a speed booster takes $t$ hours, and all $L$ speed boosters can be built in parallel. While your flagship travels from a star with a completed speed booster to the next star, its speed is $1$ parsec per hour.\n\nIf a speed booster is completed at a star while your flagship is traveling from that star to the next one, your flagship will start moving faster as soon as the speed booster is completed.\n\nHow many hours does it take your flagship to get to star $N$ if you build speed boosters to make it arrive as soon as possible?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each contains integers, $L$, $t$, $N$ and $C$, followed by $C$ integers $a_i$, all separated by spaces. $a_i$ is the number of parsecs between star $k\\times C+i$ and star $k\\times C+i+1$, for all integer values of $k$.\n\nFor example, with $N=8$, $C=3$, $a_0=3$, $a_1=5$ and $a_2=4$, the distances between stars are $[3, 5, 4, 3, 5, 4, 3, 5]$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from $1$) and $y$ is a single integer: the number of hours it takes to reach star $N$. The answer is guaranteed to always be an integer.", "hint": "**Explanation**\n\nIn the second case, we can build one speed booster. The distances between stars are $[10, 4]$. We build the speed booster on the first star. After $4$ hours, our flagship has gone $2$ parsecs and the speed booster is complete. It takes our flagship another $8$ hours to get to star $1$, then $8$ more hours to get to star $2$, our destination.\n\nNote: This problem takes place in a universe where the speed of light is much higher than $1$ parsec per hour, so we don't have to worry about special relativistic effects.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq C \\leq 1000$.\n- $C \\leq N$.\n- $1 \\leq a_i \\leq 10^4$.\n- $0 \\leq t \\leq 10^{11}$.\n- $t$ is even.\n\n**Small dataset (12 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 1000$.\n- $0 \\leq L \\leq 2$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (25 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq N \\leq 10^6$.\n- $0 \\leq L \\leq N$.\n- Time limit: ~~60~~ 6 seconds.", "locale": "en", "translations": {"en": {"title": "[GCJ 2011 #1C] Space Emergency", "background": "", "description": "There's an emergency—in space! You need to send your fleet's flagship as quickly as possible from star $0$ to star $N$, traveling through the other stars in increasing numerical order along the way ($0 \\rightarrow 1 \\rightarrow \\ldots \\rightarrow N$). Your flagship normally travels at a speed of $0.5$ parsecs per hour.\n\nIn addition to sending your flagship, you can order your engineers to build up to $L$ speed boosters at different stars. Building a speed booster takes $t$ hours, and all $L$ speed boosters can be built in parallel. While your flagship travels from a star with a completed speed booster to the next star, its speed is $1$ parsec per hour.\n\nIf a speed booster is completed at a star while your flagship is traveling from that star to the next one, your flagship will start moving faster as soon as the speed booster is completed.\n\nHow many hours does it take your flagship to get to star $N$ if you build speed boosters to make it arrive as soon as possible?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each contains integers, $L$, $t$, $N$ and $C$, followed by $C$ integers $a_i$, all separated by spaces. $a_i$ is the number of parsecs between star $k\\times C+i$ and star $k\\times C+i+1$, for all integer values of $k$.\n\nFor example, with $N=8$, $C=3$, $a_0=3$, $a_1=5$ and $a_2=4$, the distances between stars are $[3, 5, 4, 3, 5, 4, 3, 5]$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from $1$) and $y$ is a single integer: the number of hours it takes to reach star $N$. The answer is guaranteed to always be an integer.", "hint": "**Explanation**\n\nIn the second case, we can build one speed booster. The distances between stars are $[10, 4]$. We build the speed booster on the first star. After $4$ hours, our flagship has gone $2$ parsecs and the speed booster is complete. It takes our flagship another $8$ hours to get to star $1$, then $8$ more hours to get to star $2$, our destination.\n\nNote: This problem takes place in a universe where the speed of light is much higher than $1$ parsec per hour, so we don't have to worry about special relativistic effects.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq C \\leq 1000$.\n- $C \\leq N$.\n- $1 \\leq a_i \\leq 10^4$.\n- $0 \\leq t \\leq 10^{11}$.\n- $t$ is even.\n\n**Small dataset (12 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 1000$.\n- $0 \\leq L \\leq 2$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (25 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq N \\leq 10^6$.\n- $0 \\leq L \\leq N$.\n- Time limit: ~~60~~ 6 seconds.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2011 #1C] Space Emergency", "background": null, "description": "太空中发生了紧急情况！你需要尽快将你的舰队旗舰从恒星 $0$ 送到恒星 $N$，途中必须按编号递增顺序依次经过所有恒星（$0 \\rightarrow 1 \\rightarrow \\ldots \\rightarrow N$）。你的旗舰通常以 $0.5$ 秒差距每小时的速度航行。\n\n除了派出旗舰外，你还可以命令工程师在不同的恒星上建造最多 $L$ 个加速器。建造一个加速器需要 $t$ 小时，所有 $L$ 个加速器可以并行建造。当你的旗舰从一个已完成加速器的恒星出发前往下一个恒星时，它的速度将提升为 $1$ 秒差距每小时。\n\n如果旗舰在从某个恒星前往下一个恒星的途中，该恒星上的加速器建造完成，那么旗舰会在加速器完成的瞬间开始以更快的速度前进。\n\n如果你合理建造加速器，使旗舰尽快到达恒星 $N$，那么旗舰需要多少小时才能到达？", "inputFormat": "输入的第一行为测试用例数 $T$。接下来的 $T$ 行，每行包含整数 $L$、$t$、$N$ 和 $C$，后跟 $C$ 个整数 $a_i$，所有数值以空格分隔。$a_i$ 表示对于所有整数 $k$，从恒星 $k\\times C+i$ 到恒星 $k\\times C+i+1$ 之间的距离（单位为秒差距）。\n\n例如，若 $N=8$，$C=3$，$a_0=3$，$a_1=5$，$a_2=4$，则各段距离为 $[3, 5, 4, 3, 5, 4, 3, 5]$。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #$x$: $y$\"，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是旗舰到达恒星 $N$ 所需的总小时数。保证答案总是整数。", "hint": "**说明**\n\n在第二个测试用例中，我们可以建造一个加速器。两段距离分别为 $[10, 4]$。我们在第一个恒星建造加速器。经过 $4$ 小时，旗舰已前进 $2$ 秒差距，此时加速器建造完成。旗舰再用 $8$ 小时到达恒星 $1$，然后再用 $8$ 小时到达目的地恒星 $2$。\n\n注意：本题设定的宇宙中，光速远大于 $1$ 秒差距每小时，因此无需考虑相对论效应。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq C \\leq 1000$。\n- $C \\leq N$。\n- $1 \\leq a_i \\leq 10^4$。\n- $0 \\leq t \\leq 10^{11}$。\n- $t$ 为偶数。\n\n**小数据范围（12 分，测试集 1 - 可见）**\n\n- $1 \\leq N \\leq 1000$。\n- $0 \\leq L \\leq 2$。\n- 时间限制：3 秒。\n\n**大数据范围（25 分，测试集 2 - 隐藏）**\n\n- $1 \\leq N \\leq 10^6$。\n- $0 \\leq L \\leq N$。\n- 时间限制：6 秒。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13373", "type": "P", "difficulty": 5, "samples": [["2\n3 2 100\n3 5 7\n4 8 16\n1 20 5 2", "Case #1: NO\nCase #2: 10"]], "limits": {"time": [3000, 6000], "memory": [1048576, 1048576]}, "tags": ["数学", "2011", "数论", "Google Code Jam"], "title": "[GCJ 2011 #1C] Perfect Harmony", "background": "", "description": "Jeff is a part of the great Atlantean orchestra. Each player of the orchestra has already decided what sound will he play (for the sake of simplicity we assume each player plays only one sound). We say two sounds are in harmony if the frequency of any one of them divides the frequency of the other (that's a pretty restrictive idea of harmony, but the Atlanteans are known to be very conservative in music). Jeff knows that the notes played by other players are not necessarily in harmony with each other. He wants his own note to improve the symphony, so he wants to choose his note so that it is in harmony with the notes all the other players play.\n\nNow, this sounds simple (as all the frequencies are positive integers, it would be enough for Jeff to play the note with frequency $1$, or, from the other side, the Least Common Multiple of all the other notes), but unfortunately Jeff's instrument has only a limited range of notes available. Help Jeff find out if playing a note harmonious with all others is possible.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case is described by two lines. The first contains three numbers: $N$, $L$ and $H$, denoting the number of other players, the lowest and the highest note Jeff's instrument can play. The second line contains $N$ integers denoting the frequencies of notes played by the other players.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from $1$) and $y$ is either the string \"NO\" (if Jeff cannot play an appropriate note), or a possible frequency. If there are multiple frequencies Jeff could play, output the lowest one.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 40$.\n\n**Small dataset (8 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 100$.\n- $1 \\leq L \\leq H \\leq 10000$.\n- All the frequencies are no larger than $10000$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (35 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq N \\leq 10^4$.\n- $1 \\leq L \\leq H \\leq 10^{16}$\n- All the frequencies are no larger than $10^{16}$\n- Time limit: ~~60~~ 6 seconds.", "locale": "en", "translations": {"en": {"title": "[GCJ 2011 #1C] Perfect Harmony", "background": "", "description": "Jeff is a part of the great Atlantean orchestra. Each player of the orchestra has already decided what sound will he play (for the sake of simplicity we assume each player plays only one sound). We say two sounds are in harmony if the frequency of any one of them divides the frequency of the other (that's a pretty restrictive idea of harmony, but the Atlanteans are known to be very conservative in music). Jeff knows that the notes played by other players are not necessarily in harmony with each other. He wants his own note to improve the symphony, so he wants to choose his note so that it is in harmony with the notes all the other players play.\n\nNow, this sounds simple (as all the frequencies are positive integers, it would be enough for Jeff to play the note with frequency $1$, or, from the other side, the Least Common Multiple of all the other notes), but unfortunately Jeff's instrument has only a limited range of notes available. Help Jeff find out if playing a note harmonious with all others is possible.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case is described by two lines. The first contains three numbers: $N$, $L$ and $H$, denoting the number of other players, the lowest and the highest note Jeff's instrument can play. The second line contains $N$ integers denoting the frequencies of notes played by the other players.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from $1$) and $y$ is either the string \"NO\" (if Jeff cannot play an appropriate note), or a possible frequency. If there are multiple frequencies Jeff could play, output the lowest one.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 40$.\n\n**Small dataset (8 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 100$.\n- $1 \\leq L \\leq H \\leq 10000$.\n- All the frequencies are no larger than $10000$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (35 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq N \\leq 10^4$.\n- $1 \\leq L \\leq H \\leq 10^{16}$\n- All the frequencies are no larger than $10^{16}$\n- Time limit: ~~60~~ 6 seconds.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2011 #1C] Perfect Harmony", "background": null, "description": "Jeff 是伟大的亚特兰蒂斯乐团的一员。乐团中的每位演奏者都已经决定了自己将要演奏的音符（为简化问题，我们假设每位演奏者只演奏一个音符）。我们称两个音符是和谐的，当且仅当其中任意一个音符的频率可以整除另一个音符的频率（这种和谐的定义非常严格，但亚特兰蒂斯人以音乐上的保守著称）。Jeff 知道其他演奏者所演奏的音符之间不一定是和谐的。他希望自己选择的音符能够提升整个交响乐的和谐度，因此他希望选择一个与所有其他演奏者所演奏音符都和谐的音符。\n\n现在，这听起来很简单（因为所有频率都是正整数，Jeff 只需演奏频率为 $1$ 的音符，或者反过来，演奏所有其他音符频率的最小公倍数即可），但不幸的是，Jeff 的乐器只能演奏有限范围内的音符。请帮助 Jeff 判断，是否存在一个音符的频率，使得它与其他所有音符都和谐，并且该频率在 Jeff 乐器可演奏的范围内。", "inputFormat": "输入的第一行是测试用例的数量 $T$。接下来有 $T$ 组测试用例。每组测试用例包含两行。第一行包含三个整数 $N$、$L$ 和 $H$，分别表示其他演奏者的数量、Jeff 乐器可演奏的最低和最高音符频率。第二行包含 $N$ 个整数，表示其他演奏者所演奏音符的频率。", "outputFormat": "对于每个测试用例，输出一行，格式为 “Case #$x$: $y$”，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是 Jeff 可以选择的频率（如果有多个可选频率，输出最小的一个），如果不存在这样的频率，则输出 “NO”。", "hint": "**数据范围**\n\n- $1 \\leq T \\leq 40$。\n\n**小数据范围（8 分，测试集 1 - 可见）**\n\n- $1 \\leq N \\leq 100$。\n- $1 \\leq L \\leq H \\leq 10000$。\n- 所有频率不超过 $10000$。\n- 时间限制：~~30~~ 3 秒。\n\n**大数据范围（35 分，测试集 2 - 隐藏）**\n\n- $1 \\leq N \\leq 10^4$。\n- $1 \\leq L \\leq H \\leq 10^{16}$。\n- 所有频率不超过 $10^{16}$。\n- 时间限制：~~60~~ 6 秒。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13374", "type": "P", "difficulty": 3, "samples": [["3\n10 1 4 1 2\n4 6 1\n6 9 2\n12 1 2 4 1\n6 12 1\n20 1 3 20 5\n0 4 5\n4 8 4\n8 12 3\n12 16 2\n16 20 1", "Case #1: 4.000000\nCase #2: 5.500000\nCase #3: 3.538095238"]], "limits": {"time": [3000, 6000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2011", "Special Judge", "Google Code Jam"], "title": "[GCJ 2011 #2] Airport Walkways", "background": "", "description": "You're in an airport, standing at point $0$. A corridor of length $X$ leads to the gate, where your plane is about to leave. There are moving walkways in the corridor, each moving with some speed $w_i$. When you walk or run on one of those, you move with speed (your speed + $w_i$). The walkways do not change their position; they just make you move faster. The walkways do not overlap: at any given point of the corridor there is at most one walkway, but one walkway can begin at the point where another ends.\n\nYour normal walking speed is $S$. You are worried that you might not catch your plane, though, so you can run a bit - you can run with speed $R$ for at most $t$ seconds in total. You do not have to run for $t$ consecutive seconds: you can split these $t$ seconds into any number of intervals, or even not use some part of them.\n\nHow long does it take you to get to the gate, assuming you choose when to walk and when to run in order to reach it as soon as possible?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with a line containing five integers: $X$ (the length of the corridor, in meters), $S$ (your walking speed, in meters per second), $R$ (your running speed, in meters per second), $t$ (the maximum time you can run, in seconds) and $N$ (the number of walkways).\n\nEach of the next $N$ lines contains three integers: $B_i$, $E_i$ and $w_i$ - the beginning and end of the walkway (in meters from your starting point) and the speed of the walkway (in meters per second).\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from $1$) and $y$ is the time (in seconds) you need to reach point $X$ if you walk and run optimally. Answers with relative or absolute error of at most $10^{-6}$ will be accepted.", "hint": "**Sample Explanation**\n\nThe best solution in the first case is to start running immediately and run for one second.\n\n**Limits**\n\n- $1 \\leq T \\leq 40$.\n- $1 \\leq S < R \\leq 100$.\n- $1 \\leq w_i \\leq 100$.\n- $0 \\leq B_i < E_i \\leq X$.\n- $E_i \\leq B_{i+1}$.\n\n**Small dataset (8 Pts, Test set 1 - Visible)**\n\n- $1 \\leq t \\leq 100$.\n- $1 \\leq X \\leq 100$.\n- $1 \\leq N \\leq 20$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (10 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq t \\leq 10^6$.\n- $1 \\leq X \\leq 10^6$.\n- $1 \\leq N \\leq 1000$.\n- Time limit: ~~60~~ 6 seconds.", "locale": "en", "translations": {"en": {"title": "[GCJ 2011 #2] Airport Walkways", "background": "", "description": "You're in an airport, standing at point $0$. A corridor of length $X$ leads to the gate, where your plane is about to leave. There are moving walkways in the corridor, each moving with some speed $w_i$. When you walk or run on one of those, you move with speed (your speed + $w_i$). The walkways do not change their position; they just make you move faster. The walkways do not overlap: at any given point of the corridor there is at most one walkway, but one walkway can begin at the point where another ends.\n\nYour normal walking speed is $S$. You are worried that you might not catch your plane, though, so you can run a bit - you can run with speed $R$ for at most $t$ seconds in total. You do not have to run for $t$ consecutive seconds: you can split these $t$ seconds into any number of intervals, or even not use some part of them.\n\nHow long does it take you to get to the gate, assuming you choose when to walk and when to run in order to reach it as soon as possible?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with a line containing five integers: $X$ (the length of the corridor, in meters), $S$ (your walking speed, in meters per second), $R$ (your running speed, in meters per second), $t$ (the maximum time you can run, in seconds) and $N$ (the number of walkways).\n\nEach of the next $N$ lines contains three integers: $B_i$, $E_i$ and $w_i$ - the beginning and end of the walkway (in meters from your starting point) and the speed of the walkway (in meters per second).\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from $1$) and $y$ is the time (in seconds) you need to reach point $X$ if you walk and run optimally. Answers with relative or absolute error of at most $10^{-6}$ will be accepted.", "hint": "**Sample Explanation**\n\nThe best solution in the first case is to start running immediately and run for one second.\n\n**Limits**\n\n- $1 \\leq T \\leq 40$.\n- $1 \\leq S < R \\leq 100$.\n- $1 \\leq w_i \\leq 100$.\n- $0 \\leq B_i < E_i \\leq X$.\n- $E_i \\leq B_{i+1}$.\n\n**Small dataset (8 Pts, Test set 1 - Visible)**\n\n- $1 \\leq t \\leq 100$.\n- $1 \\leq X \\leq 100$.\n- $1 \\leq N \\leq 20$.\n- Time limit: ~~30~~ 3 seconds.\n\n**Large dataset (10 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq t \\leq 10^6$.\n- $1 \\leq X \\leq 10^6$.\n- $1 \\leq N \\leq 1000$.\n- Time limit: ~~60~~ 6 seconds.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2011 #2] Airport Walkways", "background": null, "description": "你现在在机场，站在 $0$ 点。通往登机口的走廊长度为 $X$ 米，你的飞机即将起飞。走廊上有若干条自动步道，每条步道的速度为 $w_i$。当你在步道上行走或奔跑时，你的速度为（你的速度 $+$ $w_i$）。步道不会移动它们的位置，只是让你移动得更快。步道之间不会重叠：在走廊的任意一点，至多只有一条步道，但一条步道可以在另一条步道结束的地方开始。\n\n你的正常步行速度为 $S$。你担心可能赶不上飞机，因此你可以选择奔跑一段时间——你最多可以以速度 $R$ 奔跑 $t$ 秒。你不需要连续奔跑 $t$ 秒：你可以将这 $t$ 秒分成任意多个时间段，甚至可以不用完全部时间。\n\n请问，在你合理安排步行和奔跑的情况下，最短需要多少时间才能到达登机口 $X$ 点？", "inputFormat": "输入的第一行是测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行为五个整数：$X$（走廊长度，单位为米）、$S$（步行速度，单位为米/秒）、$R$（奔跑速度，单位为米/秒）、$t$（最大奔跑时间，单位为秒）、$N$（步道数量）。\n\n接下来的 $N$ 行，每行包含三个整数：$B_i$、$E_i$ 和 $w_i$，分别表示第 $i$ 条步道的起点、终点（距离起点的米数）以及步道的速度（单位为米/秒）。", "outputFormat": "对于每组测试数据，输出一行，格式为 \"Case #$x$: $y$\"，其中 $x$ 是测试编号（从 $1$ 开始），$y$ 是你到达 $X$ 点所需的最短时间（单位为秒）。当且仅当你的答案的相对或绝对误差不超过 $10^{-6}$ 时，才会被判为正确。", "hint": "**样例解释**\n\n在第一个样例中，最优的做法是立即开始奔跑，并奔跑 1 秒。\n\n**数据范围**\n\n- $1 \\leq T \\leq 40$。\n- $1 \\leq S < R \\leq 100$。\n- $1 \\leq w_i \\leq 100$。\n- $0 \\leq B_i < E_i \\leq X$。\n- $E_i \\leq B_{i+1}$。\n\n**小数据集（8 分，测试集 1 - 可见）**\n\n- $1 \\leq t \\leq 100$。\n- $1 \\leq X \\leq 100$。\n- $1 \\leq N \\leq 20$。\n- 时间限制：3 秒。\n\n**大数据集（10 分，测试集 2 - 隐藏）**\n\n- $1 \\leq t \\leq 10^6$。\n- $1 \\leq X \\leq 10^6$。\n- $1 \\leq N \\leq 1000$。\n- 时间限制：6 秒。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
