{"pid": "P8112", "type": "P", "difficulty": 5, "samples": [["3 5\naba\nabaab", "2"], ["3 5\naba\nababa", "2"], ["3 5\naba\nabbaa", "Fake"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["字符串", "动态规划 DP", "贪心", "2021", "O2优化", "KMP 算法"], "title": "[Cnoi2021] 符文破译", "background": "Cirno 想要解读一本古老的魔法书。", "description": "为了保护魔法书中记载的禁忌的魔法，撰写者将符咒的魔法词缀不加空格地连接在一起，形成一个符文串，记作 $\\texttt{S}$。\n\n而构成符文串的所有魔法词缀都被记载在更远古的先知所编写的魔法辞典中，记作 $\\texttt{T}$。具体地，$\\texttt{T}$ 的所有非空前缀均是一个合法的魔法词缀。\n\n简洁是魔法书撰写的第一要务，所以使用的魔法词缀应该尽可能少。所以在破译魔法书时，将 $\\texttt{S}$ 分解成的魔法词缀数越少，破译正确的可能性就越高。\n\nCirno 想知道，这本魔法书最少的魔法词缀划分段数是多少。\n\n特别地，如果不存在一种合法的划分方案，则表明这本魔法书是假的。Cirno 将得到一个字符串 `Fake`。", "inputFormat": "第一行，两个整数，表示 $|\\texttt{T}|$，$|\\texttt{S}|$。\n\n第二行，一个字符串 $\\texttt{T}$。\n\n第三行，一个字符串 $\\texttt{S}$。", "outputFormat": "一行，一个整数或一个字符串 `Fake`，表示答案。", "hint": "**数据范围与约定**\n\n对于 $100\\%$ 的数据，保证 $1\\le |\\texttt{S}|,|\\texttt{T}|\\le 10^7$，$\\texttt{S}_x,\\texttt{T}_x \\in [\\texttt{a},\\texttt{z}]$。\n\n**子任务**\n\nSubtask1（$10$ points）：$\\texttt{T}_x=\\texttt{a}$。\n\nSubtask2（$20$ points）：$|\\texttt{S}|\\le1000$。\n\nSubtask3（$30$ points）：$|\\texttt{S}|\\le 10^6$。\n\nSubtask4（$40$ points）：无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Cnoi2021] 符文破译", "background": "Cirno 想要解读一本古老的魔法书。", "description": "为了保护魔法书中记载的禁忌的魔法，撰写者将符咒的魔法词缀不加空格地连接在一起，形成一个符文串，记作 $\\texttt{S}$。\n\n而构成符文串的所有魔法词缀都被记载在更远古的先知所编写的魔法辞典中，记作 $\\texttt{T}$。具体地，$\\texttt{T}$ 的所有非空前缀均是一个合法的魔法词缀。\n\n简洁是魔法书撰写的第一要务，所以使用的魔法词缀应该尽可能少。所以在破译魔法书时，将 $\\texttt{S}$ 分解成的魔法词缀数越少，破译正确的可能性就越高。\n\nCirno 想知道，这本魔法书最少的魔法词缀划分段数是多少。\n\n特别地，如果不存在一种合法的划分方案，则表明这本魔法书是假的。Cirno 将得到一个字符串 `Fake`。", "inputFormat": "第一行，两个整数，表示 $|\\texttt{T}|$，$|\\texttt{S}|$。\n\n第二行，一个字符串 $\\texttt{T}$。\n\n第三行，一个字符串 $\\texttt{S}$。", "outputFormat": "一行，一个整数或一个字符串 `Fake`，表示答案。", "hint": "**数据范围与约定**\n\n对于 $100\\%$ 的数据，保证 $1\\le |\\texttt{S}|,|\\texttt{T}|\\le 10^7$，$\\texttt{S}_x,\\texttt{T}_x \\in [\\texttt{a},\\texttt{z}]$。\n\n**子任务**\n\nSubtask1（$10$ points）：$\\texttt{T}_x=\\texttt{a}$。\n\nSubtask2（$20$ points）：$|\\texttt{S}|\\le1000$。\n\nSubtask3（$30$ points）：$|\\texttt{S}|\\le 10^6$。\n\nSubtask4（$40$ points）：无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P8113", "type": "P", "difficulty": 5, "samples": [["5 5\n1 2 3 4 5", "4.00 2.00"], ["7 114\n23 75 35 17 101 55 73", "81.43 32.57"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["贪心", "二分", "2021", "O2优化"], "title": "[Cnoi2021] 自我主义的平衡者", "background": "「流浪月球 ~ The Wandering Moon」在幻想乡上映了。\n\n正如一千个人心中有一千个哈姆雷特，关于它的争议也在悄然蔓延。\n\n不知何时起，一个叫做「花瓣」的平台出现，慢慢取代了市井之中的讨论声，成为了争议的主战场——因为它具有评分功能。平台上旁征博引、各抒己见的评分帖成为了幻想乡的居民们日常，一切看起来岁月静好。\n\n直到平衡者的出现。\n\n起初没有人在意在意这缕杂音，这只不过是一种无心的叛逆，一点无奈的情感，一次无聊的宣泄。直到平衡的思想深入人心，自我主义的狂潮达到顶峰，评分系统的秩序几近崩溃。\n\nCirno 觉得自己该做些什么了。", "description": "Cirno 决定通过计算来说服与拯救被自我主义裹挟的众人。\n\n参与评分的共有 $n$ 位居民，平台限制的最高分为 $m$。\n\n每个居民在评分前都有一个心理预期分数 $a_i(a_i\\in[0,m]\\cap\\mathbb{Z})$。\n\n但人们并不会按照心理预期分数直接评分，而是当当前平台上的平均分严格高于自己的心理预期分数时，便评分道「分数太高了，打个 $0$ 分平衡一下」，反之则说「分数太低了，打个满分（$m$分）平衡一下」。\n\n初始时平台上的平均分为 $0$。\n\n为了证明这种评分方式对公平的破坏性，Cirno 希望你计算出这 $n$ 位居民在不同的排列顺序下评分，平台上最终平均分可能的最大值与最小值。", "inputFormat": "第一行，两个整数，用空格隔开，表示 $n$，$m$。\n\n第二行，$n$ 个整数，用空格隔开，表示 $\\{a_n\\}$。", "outputFormat": "一行，两个实数，保留两位小数，分别表示平均分最大值和最小值。", "hint": "**数据范围与约定**\n\n对于 $100\\%$ 的数据保证，$1 < n,m\\le 10^5$，$a_i \\in [0,m]$。\n\n**子任务**\n\nSubtask1（10 points）：$n \\le 8$。\n\nSubtask2（10 points）：$n \\le 20$。\n\nSubtask3（30 points）：$n \\le 10^3$。\n\nSubtask4（50 points）：无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Cnoi2021] 自我主义的平衡者", "background": "「流浪月球 ~ The Wandering Moon」在幻想乡上映了。\n\n正如一千个人心中有一千个哈姆雷特，关于它的争议也在悄然蔓延。\n\n不知何时起，一个叫做「花瓣」的平台出现，慢慢取代了市井之中的讨论声，成为了争议的主战场——因为它具有评分功能。平台上旁征博引、各抒己见的评分帖成为了幻想乡的居民们日常，一切看起来岁月静好。\n\n直到平衡者的出现。\n\n起初没有人在意在意这缕杂音，这只不过是一种无心的叛逆，一点无奈的情感，一次无聊的宣泄。直到平衡的思想深入人心，自我主义的狂潮达到顶峰，评分系统的秩序几近崩溃。\n\nCirno 觉得自己该做些什么了。", "description": "Cirno 决定通过计算来说服与拯救被自我主义裹挟的众人。\n\n参与评分的共有 $n$ 位居民，平台限制的最高分为 $m$。\n\n每个居民在评分前都有一个心理预期分数 $a_i(a_i\\in[0,m]\\cap\\mathbb{Z})$。\n\n但人们并不会按照心理预期分数直接评分，而是当当前平台上的平均分严格高于自己的心理预期分数时，便评分道「分数太高了，打个 $0$ 分平衡一下」，反之则说「分数太低了，打个满分（$m$分）平衡一下」。\n\n初始时平台上的平均分为 $0$。\n\n为了证明这种评分方式对公平的破坏性，Cirno 希望你计算出这 $n$ 位居民在不同的排列顺序下评分，平台上最终平均分可能的最大值与最小值。", "inputFormat": "第一行，两个整数，用空格隔开，表示 $n$，$m$。\n\n第二行，$n$ 个整数，用空格隔开，表示 $\\{a_n\\}$。", "outputFormat": "一行，两个实数，保留两位小数，分别表示平均分最大值和最小值。", "hint": "**数据范围与约定**\n\n对于 $100\\%$ 的数据保证，$1 < n,m\\le 10^5$，$a_i \\in [0,m]$。\n\n**子任务**\n\nSubtask1（10 points）：$n \\le 8$。\n\nSubtask2（10 points）：$n \\le 20$。\n\nSubtask3（30 points）：$n \\le 10^3$。\n\nSubtask4（50 points）：无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P8114", "type": "P", "difficulty": 7, "samples": [["1 1 1", "2"], ["3 4 3", "4116"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2021", "LGV 引理", "O2优化", "组合数学", "线性代数", "行列式"], "title": "[Cnoi2021] 六边形战士", "background": "在 Cirno 的精心照料下，六边形成长为一只可爱的平行六边形。\n\n现在，Cirno 很想知道它的战斗力是多少。", "description": "可爱的平行六边形所有边的夹角均为 $\\frac{2\\pi}{3}$，三组对边的长度分别为 $a$，$b$，$c$ 个单位。如图。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/aa8i6soa.png)\n\n在战斗力鉴定时，鉴定师会以六边形的每一条边所在的直线，间隔 $\\frac{\\sqrt{3}}{2}$ 个单位建立平行直线系。这样六边形战士会被划分成若干个正三角形。如图。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mbkn807n.png)\n\n鉴定师会将所有有公共边的正三角形连边。由于没有奇环，很容易知道这是一个二分图。然后鉴定师会试图构造该二分图的完美匹配。如图。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/in7c6cf7.png)\n\n该六边形战士的战斗力为上述**二分图的完美匹配**可能的种类数。作为见习鉴定师，你需要帮 Cirno 求出该六边形的战斗力。\n\n由于答案可能过大，仅需输出它对 $998244353$ 取模的结果即可。", "inputFormat": "一行，三个整数，用空格隔开，表示 $a$，$b$，$c$。", "outputFormat": "一行，一个整数，表示六边形战士的战斗力对 $998244353$ 取模后的结果。", "hint": "**数据范围与约定**\n\n对于 $100\\%$ 的数据，保证 $1\\le a,b,c\\le 10^6$。\n\n**子任务**\n\nSubtask1（$10$ points）：$a,b,c\\le 3$。\n\nSubtask2（$10$ points）：$a,b,c\\le 8$。\n\nSubtask3（$70$ points）：$a,b,c\\le 100$。\n\nSubtask4（$10$ points）：无特殊限制。\n\n**提示**\n\n - **Krattenthaler’s formula**  \n $\\displaystyle\\det\\left(\\prod\\limits_{k=2}^j(x_i+a_k)\\prod\\limits_{k=j+1}^n(x_i+b_k)\\right)_{i,j=1}^{n}=\\prod\\limits_{1\\le i<j\\le n}{(x_i-x_j)}\\prod\\limits_{2<i\\le j\\le n}(a_i-b_j)$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Cnoi2021] 六边形战士", "background": "在 Cirno 的精心照料下，六边形成长为一只可爱的平行六边形。\n\n现在，Cirno 很想知道它的战斗力是多少。", "description": "可爱的平行六边形所有边的夹角均为 $\\frac{2\\pi}{3}$，三组对边的长度分别为 $a$，$b$，$c$ 个单位。如图。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/aa8i6soa.png)\n\n在战斗力鉴定时，鉴定师会以六边形的每一条边所在的直线，间隔 $\\frac{\\sqrt{3}}{2}$ 个单位建立平行直线系。这样六边形战士会被划分成若干个正三角形。如图。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mbkn807n.png)\n\n鉴定师会将所有有公共边的正三角形连边。由于没有奇环，很容易知道这是一个二分图。然后鉴定师会试图构造该二分图的完美匹配。如图。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/in7c6cf7.png)\n\n该六边形战士的战斗力为上述**二分图的完美匹配**可能的种类数。作为见习鉴定师，你需要帮 Cirno 求出该六边形的战斗力。\n\n由于答案可能过大，仅需输出它对 $998244353$ 取模的结果即可。", "inputFormat": "一行，三个整数，用空格隔开，表示 $a$，$b$，$c$。", "outputFormat": "一行，一个整数，表示六边形战士的战斗力对 $998244353$ 取模后的结果。", "hint": "**数据范围与约定**\n\n对于 $100\\%$ 的数据，保证 $1\\le a,b,c\\le 10^6$。\n\n**子任务**\n\nSubtask1（$10$ points）：$a,b,c\\le 3$。\n\nSubtask2（$10$ points）：$a,b,c\\le 8$。\n\nSubtask3（$70$ points）：$a,b,c\\le 100$。\n\nSubtask4（$10$ points）：无特殊限制。\n\n**提示**\n\n - **Krattenthaler’s formula**  \n $\\displaystyle\\det\\left(\\prod\\limits_{k=2}^j(x_i+a_k)\\prod\\limits_{k=j+1}^n(x_i+b_k)\\right)_{i,j=1}^{n}=\\prod\\limits_{1\\le i<j\\le n}{(x_i-x_j)}\\prod\\limits_{2<i\\le j\\le n}(a_i-b_j)$。", "locale": "zh-CN"}}}
{"pid": "P8115", "type": "P", "difficulty": 2, "samples": [["{1,314159,3141592653589793}", "{1,314159,0xB29430A256D21}\n"], ["{}", "{}"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "洛谷原创", "O2优化", "进制", "洛谷月赛"], "title": "「RdOI R3.5」Table", "background": "小 A 想要打表过题，但是代码长度过长。他想到了把数字用十六进制表示有时比用十进制表示更短，决定把答案表用十六进制进行改写。", "description": "我们定义下文中的「十六进制」均用数字 $0\\sim 9$ 和大写英文字母 $\\tt A\\sim F$ 表示，且每个十六进制数字都包含前缀 $\\colorbox{#ddd}{\\tt 0x}$。\n\n给出若干个用大括号包裹，用逗号分隔的十进制整数，代表小 A 的答案表。你需要对答案表内的每个数字进行改写：\n\n- 若该整数使用十六进制表示所占字符数小于或等于十进制表示，则将该数改写为十六进制。\n- 否则，该数保留十进制不变。\n\n输出改写后的答案表。\n", "inputFormat": "- 输入一行一个字符串，字符串中仅包含大括号、逗号和数字，不包含空格和其他字符等。具体格式可以参考 C++ 语言的数组定义格式。代表小 A 的答案表，保证答案表格式正确。", "outputFormat": "- 输出一行一个字符串，表示改写后的答案表。\n", "hint": "### 样例解释\n\n#### 样例 \\#1\n\n- $1$ 用十六进制表示为 $\\tt 0x1$，共 $3$ 个字符，长度大于十进制的 $1$ 个字符。\n- $314159$ 用十六进制表示为 $\\tt 0x4CB2F$，共 $7$ 个字符，长度大于十进制的 $6$ 个字符。\n- $3141592653589793$ 用十六进制表示为 $\\tt 0xB29430A256D21$，共 $15$ 个字符，长度小于十进制的 $16$ 个字符。\n\n#### 样例 \\#2\n\n输入为空数组，所以输出也应为空数组。\n\n### 数据范围及约定\n\n本题共五个测试点，每个测试点 20 分，总分数为各测试点分数之和。\n\n记答案表中共有 $n$ 个整数，这些整数分别为 $a_1,a_2,\\cdots,a_n$。则对于 $100\\%$ 的数据，$0\\le n\\le10^3$，$0\\le a_i < 2^{64}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「RdOI R3.5」Table", "background": "小 A 想要打表过题，但是代码长度过长。他想到了把数字用十六进制表示有时比用十进制表示更短，决定把答案表用十六进制进行改写。", "description": "我们定义下文中的「十六进制」均用数字 $0\\sim 9$ 和大写英文字母 $\\tt A\\sim F$ 表示，且每个十六进制数字都包含前缀 $\\colorbox{#ddd}{\\tt 0x}$。\n\n给出若干个用大括号包裹，用逗号分隔的十进制整数，代表小 A 的答案表。你需要对答案表内的每个数字进行改写：\n\n- 若该整数使用十六进制表示所占字符数小于或等于十进制表示，则将该数改写为十六进制。\n- 否则，该数保留十进制不变。\n\n输出改写后的答案表。\n", "inputFormat": "- 输入一行一个字符串，字符串中仅包含大括号、逗号和数字，不包含空格和其他字符等。具体格式可以参考 C++ 语言的数组定义格式。代表小 A 的答案表，保证答案表格式正确。", "outputFormat": "- 输出一行一个字符串，表示改写后的答案表。\n", "hint": "### 样例解释\n\n#### 样例 \\#1\n\n- $1$ 用十六进制表示为 $\\tt 0x1$，共 $3$ 个字符，长度大于十进制的 $1$ 个字符。\n- $314159$ 用十六进制表示为 $\\tt 0x4CB2F$，共 $7$ 个字符，长度大于十进制的 $6$ 个字符。\n- $3141592653589793$ 用十六进制表示为 $\\tt 0xB29430A256D21$，共 $15$ 个字符，长度小于十进制的 $16$ 个字符。\n\n#### 样例 \\#2\n\n输入为空数组，所以输出也应为空数组。\n\n### 数据范围及约定\n\n本题共五个测试点，每个测试点 20 分，总分数为各测试点分数之和。\n\n记答案表中共有 $n$ 个整数，这些整数分别为 $a_1,a_2,\\cdots,a_n$。则对于 $100\\%$ 的数据，$0\\le n\\le10^3$，$0\\le a_i < 2^{64}$。", "locale": "zh-CN"}}}
{"pid": "P8116", "type": "P", "difficulty": 4, "samples": [["3\n4 2\n5 3\n12 99", "3\n3\n19503"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["数论", "洛谷原创", "O2优化", "洛谷月赛"], "title": "「Wdoi-1.5」魔理沙的计算器", "background": "魔理沙是普通而平凡的魔法使。在解决了大大小小的异变后，她终于攒足了足够多的钱在香霖堂里购置了一台 $\\verb!Carno!$ 计算器，用来计算魔女之汤各种配料的含量之比。\n\n魔理沙早就听闻灵梦通过河童重工网络[入手了一部 $\\verb!Casio!$ 计算器](https://www.luogu.com.cn/problem/P5515)，来计算神社的香火钱，却买到了假货，最多只能显示整数部分（下取整）。而魔理沙的这部可以精确到小数点后面若干位（下取整）的计算器。更高级的是，这部计算器还可以支持其他的进制，其强大的功能高出了灵梦一大截。因此作为灵梦真挚的朋友，魔理沙希望向灵梦表达真挚的遗憾之情。\n\n正当魔理沙打算出发之时，她发现虽然 $\\verb!Carno!$ 计算器不会导致一些特别大的误差，但是在计算除法时仍然会出现一定的问题。考虑将计算器的进制调整为 $10$ 进制，而计算器屏幕上最多可以显示 $5$ 位数字（小数点不计入显示位数）。比如，魔理沙希望计算 $1\\div 3$ 的值，那么真正显示在屏幕上的则是：\n\n$$\n0.3333\n$$\n\n按照道理上来讲，$1\\div(1\\div 3)$ 结果应当等于 $3$。但出乎意料的是，当魔理沙输入 $1\\div 0.3333$ 后，得到的结果却是：\n\n$$\n3.0003\n$$\n\n这当然只是一个个例。当魔理沙计算 $1\\div(1\\div 4)$ 时，屏幕上显示出了正确的数字。\n\n为了防止在表达遗憾之情的时候自己的计算器也出了漏子，魔理沙希望找到有多少个数字使得计算出的结果是正确的，因此她向你求助了。", "description": "魔理沙的计算器可以进行 $b$ 进制的运算，屏幕上可以显示 $k$ 个数字（不包含小数点）。进行计算后，若某个数字超出了屏幕，就会被**直接舍去**（例如 $b=10$ 时 $1\\div 7=0.142857\\cdots$，若屏幕大小为 $4$，那么最终显示为 $0.142$）。\n\n魔理沙用计算器计算了 $1\\div n=n'$，再计算 $1\\div n'=n''$（$n'$ 和 $n''$ 均为显示在屏幕上的结果）。魔理沙希望知道，有多少个正整数 $n$ 使得 $n=n''$。你只需要输出这个答案对 $998,244,353$ 取模后的结果即可。", "inputFormat": "- 第一行有一个正整数 $T$，表示数据组数。\n- 接下来 $T$ 行，每行有两个正整数 $b,k$，分别表示计算器的进制、屏幕上能显示的数字个数。", "outputFormat": "- 输出共 $T$ 行。\n- 每行输出一个整数。第 $i$ 行的整数表示第 $i$ 组数据中合法的 $n$ 的总数对 $998,244,353$ 取模后的结果。", "hint": "### 样例解释\n\n- 对于第一组询问，符合条件的数（转换成十进制）为 $1,2,4$。\n- 对于第二组询问，符合条件的数（转换成十进制）为 $1,5,25$。\n\n### 数据范围及约定\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|}\\hline\n\\textbf{subtask}&\\textbf{分值} & \\bm{b\\le} & \\bm {k\\le } & \\textbf{特殊性质} & \\textbf{subtask 依赖} \\cr\\hline\n1 & 20 & 10 & 7 & - &-\\cr\\hline\n2 & 20 & 10^5 & 2 & k=2&-\\cr\\hline\n3 & 10 & 10^5 & 3 & k=3&- \\cr\\hline\n4 & 50& 10^5 & 500 & -&1,2,3\\cr\\hline\n\\end{array}\n$$\n\n对于 $100\\%$ 的数据，满足 $1\\le T\\le 10$，$2\\le b\\le 10^5$，$1\\le k\\le 500$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「Wdoi-1.5」魔理沙的计算器", "background": "魔理沙是普通而平凡的魔法使。在解决了大大小小的异变后，她终于攒足了足够多的钱在香霖堂里购置了一台 $\\verb!Carno!$ 计算器，用来计算魔女之汤各种配料的含量之比。\n\n魔理沙早就听闻灵梦通过河童重工网络[入手了一部 $\\verb!Casio!$ 计算器](https://www.luogu.com.cn/problem/P5515)，来计算神社的香火钱，却买到了假货，最多只能显示整数部分（下取整）。而魔理沙的这部可以精确到小数点后面若干位（下取整）的计算器。更高级的是，这部计算器还可以支持其他的进制，其强大的功能高出了灵梦一大截。因此作为灵梦真挚的朋友，魔理沙希望向灵梦表达真挚的遗憾之情。\n\n正当魔理沙打算出发之时，她发现虽然 $\\verb!Carno!$ 计算器不会导致一些特别大的误差，但是在计算除法时仍然会出现一定的问题。考虑将计算器的进制调整为 $10$ 进制，而计算器屏幕上最多可以显示 $5$ 位数字（小数点不计入显示位数）。比如，魔理沙希望计算 $1\\div 3$ 的值，那么真正显示在屏幕上的则是：\n\n$$\n0.3333\n$$\n\n按照道理上来讲，$1\\div(1\\div 3)$ 结果应当等于 $3$。但出乎意料的是，当魔理沙输入 $1\\div 0.3333$ 后，得到的结果却是：\n\n$$\n3.0003\n$$\n\n这当然只是一个个例。当魔理沙计算 $1\\div(1\\div 4)$ 时，屏幕上显示出了正确的数字。\n\n为了防止在表达遗憾之情的时候自己的计算器也出了漏子，魔理沙希望找到有多少个数字使得计算出的结果是正确的，因此她向你求助了。", "description": "魔理沙的计算器可以进行 $b$ 进制的运算，屏幕上可以显示 $k$ 个数字（不包含小数点）。进行计算后，若某个数字超出了屏幕，就会被**直接舍去**（例如 $b=10$ 时 $1\\div 7=0.142857\\cdots$，若屏幕大小为 $4$，那么最终显示为 $0.142$）。\n\n魔理沙用计算器计算了 $1\\div n=n'$，再计算 $1\\div n'=n''$（$n'$ 和 $n''$ 均为显示在屏幕上的结果）。魔理沙希望知道，有多少个正整数 $n$ 使得 $n=n''$。你只需要输出这个答案对 $998,244,353$ 取模后的结果即可。", "inputFormat": "- 第一行有一个正整数 $T$，表示数据组数。\n- 接下来 $T$ 行，每行有两个正整数 $b,k$，分别表示计算器的进制、屏幕上能显示的数字个数。", "outputFormat": "- 输出共 $T$ 行。\n- 每行输出一个整数。第 $i$ 行的整数表示第 $i$ 组数据中合法的 $n$ 的总数对 $998,244,353$ 取模后的结果。", "hint": "### 样例解释\n\n- 对于第一组询问，符合条件的数（转换成十进制）为 $1,2,4$。\n- 对于第二组询问，符合条件的数（转换成十进制）为 $1,5,25$。\n\n### 数据范围及约定\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|}\\hline\n\\textbf{subtask}&\\textbf{分值} & \\bm{b\\le} & \\bm {k\\le } & \\textbf{特殊性质} & \\textbf{subtask 依赖} \\cr\\hline\n1 & 20 & 10 & 7 & - &-\\cr\\hline\n2 & 20 & 10^5 & 2 & k=2&-\\cr\\hline\n3 & 10 & 10^5 & 3 & k=3&- \\cr\\hline\n4 & 50& 10^5 & 500 & -&1,2,3\\cr\\hline\n\\end{array}\n$$\n\n对于 $100\\%$ 的数据，满足 $1\\le T\\le 10$，$2\\le b\\le 10^5$，$1\\le k\\le 500$。", "locale": "zh-CN"}}}
{"pid": "P8117", "type": "P", "difficulty": 7, "samples": [["4 4 5 1 4\n1 2 1 2 2\n1 3 4 5 1\n2 4 2 3 1\n3 4 3 5 2", "5"], ["10 19 5 6 1\n2 1 1 3 592\n6 8 3 5 488\n10 9 4 4 548\n10 4 1 4 442\n6 5 1 3 422\n9 7 1 4 529\n5 8 1 1 559\n5 9 1 5 560\n5 8 2 3 434\n5 9 3 3 592\n4 7 2 2 594\n7 9 5 5 595\n4 1 4 4 501\n3 9 1 2 410\n10 6 2 4 509\n6 10 4 5 455\n2 4 2 5 444\n4 3 4 5 541\n8 7 1 1 463\n", "2295\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "O2优化", "最短路", "洛谷月赛", "状压 DP"], "title": "「Wdoi-1.5」旅人 1977", "background": "深邃的星空中划出了一道灿烂的弧线，而后又同这广袤境界溶为一体，二十世纪的旅行者，承载着期待与不安向着外太空飞去。这是一份来自一个遥远的小小世界的礼物。上面记载着我们的声音、我们的科学、我们的影像、我们的音乐、我们的思想和感情。我们正努力生活过我们的时代，进入你们的时代。或许人类将失去对它的联系，它也将像一个漂流瓶一样，向着宇宙深处孤独的走下去，直到被「另一个人」所捡起。而它为我们留下的最后一张「自拍」，也只是一个 $0.12$ 像素大的、淡蓝色的光点 —— 这是我们迄今所知的唯一家园。\n\n$\\kern{80pt}$![](https://cdn.luogu.com.cn/upload/image_hosting/qbelj85l.png)  \n$$\\scriptscriptstyle\\text{暗淡蓝点，旅行者 1 号，1990年 2 月 14 日}$$\n「已经分不清现实与梦境了呢。」  \n「或许，梦与现之间的境界，本就没有那么明晰。」\n\n……\n\n「真是的，莲子你不是自称亲近星光与月亮的嘛，怎么也不抬头看看。」\n\n正欲向笔记本上添加几行，借以目视的月光陡然暗淡。眼前垂落的金色长发挡住了我的视线。轻咳了一声，抬起手在面前挥舞，把他们从视野中赶走，我转头看着后背。\n眼前戴着白色帽子的少女便是我的同伴梅莉。我常常打趣她有着奇异的眼睛，可以看到我们所看不到的「境界」。尽管我自己的眼睛也十分特殊——我有着通过星光与月亮就知道我们现处何时何地的能力。忘了说了，我们是学生秘密社团『秘封俱乐部』，专门探寻科学世纪下的隐藏结界。  \n在这个夏夜，我本着履行对她承诺的想法，来到野外，观察天体的运行。\n\n「在想什么呢？」  \n这个问题不好回答呢。不过，既然今天和梅莉约好出来观赏星空，那么，思路被引向人们曾经的探索和求知，便是十分自然的了。  \n「唔，我在想，我们现今，科学世纪的起源。」  \n「嗯？莲子你不是研究物理的吗，怎么突然思考其这种问题了？」  \n梅莉把头朝右侧一歪，我指指天空，她随即坐在了一旁，把目光投向灿烂的星海。  \n「唔，我在想，我们现今，科学世纪的起源。还记得我和你说过的那两位旅人吗？」  \n「旅行者一号与旅行者二号？」  \n「没错。直到如今都没有人为任何深空计划取名为旅行者。带着如此诗意而感性名称的它们代表的是人们对未来的期许与对真理的渴望。面对未知与迷茫，义无反顾冲向了星海。」 \n\n梅莉站了起来，举起了双筒望远镜。她的身影在暗淡而幽静的夜色中来回移动，皎白得似有彩色光晕的月光从穹顶透过树叶与树枝的缝隙在她身上落下光斑，看着让人心醉。  \n\n超新星爆发是恒星生命的终点，也是新生恒星生命的起点。谁能说科学已经到了尽头，无法解释的事物不存在呢？科学的核心在于那些被视为空花阳焰，藏在迷雾中的东西，而绝非那些狂妄自大的老头们所说，科学是我们掌握的一切已知。  \n对我们而言，这是不言而喻的。我们追随那位初代社长的脚步，探寻遍布四处的结界，寻求隐藏在未知背后真理的一角，正是出于这样的信念。\n\n晷刻渐移，点点星尘围绕着北极星作着圆周运动。仔细看的话，北极星也在微微运动。在我的视线前方，梅莉兴奋地对着从英仙座辐射而出，偶尔划过天穹的流星发出惊叹。我不禁思索起来，现在勾陈一作为最接近北天极的恒星行使着为旅人指点方向的责任，但在永恒的运动中，永远会有新的谜题，新的未知，新的探索等着我们去发现。  \n\n物如此，事犹是，人亦然。前路永远有着未知的事物等着我们去探索。如果解明了所有的秘密，之后就会什么都不剩。知晓万物什么的，只不过是空空如也的虚无罢了。未知，才是驱动人类的原动力 $\\scriptscriptstyle{}^{[{\\color{grey}{1}}]}$。我们希冀着如同那两位先行者一般，作为开拓者，唤起根植于人们心中对未知的好奇与探索精神，并将它薪火相传。  \n身虽位于苍穹一粟，心亦向往若尘繁星。  \n身旁的梅莉靠在一棵树下，已经发出规律的鼾声，身体规律地微微起伏着。我伸手拨开她的手掌，撩开她垂下的头发，拿出她的笔记本。\n>从夜晚走向清晨。  \n从清晨走向夜晚。  \n从现实走向梦境。  \n从梦境走向现实。  \n终有一天，我们会在梦中，邂逅那片未经观测的星空。$\\scriptscriptstyle{}^{[{\\color{grey}{2}}]}$\n\n$\\scriptscriptstyle{[1],[2]}\\text{：引用自 }$ [here](https://bbs.nyasama.com/forum.php?mod=viewthread&tid=308054&page=2)", "description": "深邃的星空可以被视作一张有向图，图上的节点就是点点恒星。点无点权，边有边权。图的点数为 $n$，边数为 $m$，图可能有重边自环。但保证至少有一条路径可以从 $s$ 走到 $t$（$s$、$t$ 在输入中给定）。第 $i$ 条有向边起点为 $u_i$，终点为 $v_i$，它的权值用一个有序三元组 $(l_i,r_i,w_i)$ 表示。\n\n莲子要从点 $s$ 出发，经过了若干条边到达点 $t$。她带有一个初始值均为 $0$ 的长度为 $k$ 的数组 $a$，每次经过编号为 $i$ 的边，就会执行将 $a$ 数组的区间 $[l_i,r_i]$ 加 $w_i$ 的操作。她使用了一棵**带懒标记**的线段树来维护这一操作。线段树的写法会在接下来给出。\n\n你需要构造一条从 $s$ 到 $t$ 的路径，满足达到结点 $t$ 时，其线段树上所有标记的和的最小。输出这个最小值。\n\n以下是线段树的伪代码：（为了方便选手阅读，题目附件中给出了线段树的 C++ 源代码）\n\n$$\n\\begin{array}{l}\\hline\\hline\\\\[-0.8em]\n\\textbf{Algorithm: }\\text{SegTree}\\\\\\hline\\\\[-0.5em]\n\\begin{array}{rl}\n1& \\mathbf{Input.} \\text{ 长度为 $k$ 的 $a$ 数组，初始全为 $0$}\\\\\n2& \\mathbf{Output.} \\text{ $a$ 数组进行若干次区间加操作后得到的结果}\\\\\n3& \\mathbf{Method.}\\\\\n4& \\mathrm{Add}(L,R,x)\\\\\n5& \\quad\\mathrm{Add0}(L,R,x,root,1,k)\\\\\n6& \\mathrm{Add0}(L,R,x,u,l,r)\\\\\n7& \\quad\\mathbf{if}\\ L \\le l\\ \\mathbf{and}\\ r\\le R\\\\\n8& \\quad\\quad \\mathrm{tag}(u) \\gets \\mathrm{tag}(u) + x\\\\\n9& \\quad\\quad \\mathbf{return}\\\\\n10& \\quad mid \\gets \\lfloor\\frac{l+r} 2\\rfloor\\\\\n11& \\quad \\mathrm{tag}(\\mathrm{lson}(u)) \\gets \\mathrm{tag}(\\mathrm{lson}(u))+\\mathrm{tag}(u)\\\\\n12& \\quad \\mathrm{tag}(\\mathrm{rson}(u)) \\gets \\mathrm{tag}(\\mathrm{rson}(u))+\\mathrm{tag}(u)\\\\\n13& \\quad \\mathrm{tag}(u) \\gets 0\\\\\n14& \\quad\\mathbf{if}\\ L \\le mid\\\\\n15& \\quad\\quad\\mathrm{Add0}(L,R,x,\\mathrm{lson}(u),l,mid)\\\\\n16& \\quad\\mathbf{if}\\ mid < R\\\\\n17& \\quad\\quad\\mathrm{Add0}(L,R,x,\\mathrm{rson}(u),mid+1,r)\\\\\n\\end{array}\\\\\\hline\\hline\n\\end{array}\n$$", "inputFormat": "- 第一行五个整数 $n,m,k,s,t$。\n- 接下来 $m$ 行，每行五个整数 $u_i,v_i,l_i,r_i,w_i$。", "outputFormat": "- 共一行一个整数，表示沿着你构造的路径从 $s$ 到达 $t$ 后线段树上所有懒标记的权值之和。", "hint": "### 样例解释\n\n#### 样例 \\#1\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/npzajpom.png)\n\n容易发现，样例 $1$ 中有且仅有两条可能的路径：$1\\to 2\\to 4$ 与 $1\\to 3\\to 4$。下面分别计算这两条路径最终 $\\text{tag}$ 的权值和。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2fq7okad.png)\n\n考虑画出这棵 $k=5$ 的线段树。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ys42i046.png)\n\n走了边 $1\\to 2$ 后，$[1,2]$ 节点被打上了权值为 $2$ 的 $\\text{tag}$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/02sqysh5.png)\n\n走了 $2\\to 4$ 后，$[2,2]$ 节点和 $[3,3]$ 节点被打上了值为 $1$ 的 $\\text{tag}$；但是 $[1,2]$ 节点的标记进行了下推（因为使 $[2,3]$ 区间 $+1$ 的时候会访问到 $[1,2]$ 节点，而 $[1,2]\\nsubseteq[2,3]$，故而发生标记下推），因此 $[1,1]$ 节点和 $[2,2]$ 节点的 $\\text{tag}$ 分别加上了 $2$，最终成了如图所示的模样。\n\n因此走到 $4$ 之后所有结点的 $\\text{tag}$ 之和为 $2+3+1=6$。\n\n---\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3va7fa03.png)\n\n对于另外一条路径，首先对 $[4,5]$ 加上 $1$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/o1cw3s03.png)\n\n接着对 $[3,5]$ 加上 $2$。未发生带有 $\\text{tag}$ 的节点的标记下推，因此最终的权值为 $2+3=5$。\n\n由于 $6>5$，因而最终的答案为 $5$。\n\n### 数据范围及约定\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|c|}\\hline\n\\textbf{subtask}& \\textbf{分值}& {\\bm n\\le} & {\\bm m\\le} & {\\bm k\\le} & \\textbf{特殊性质} & \\textbf{subtask 依赖}\\cr\\hline\n1 & 10& 10 & 30 & 5 & - & -\\cr\\hline\n2 & 5&30 & 30 & 12 & \\textbf{AB} &-\\cr\\hline\n3 & 20&30 & 500 & 12 & \\textbf{B} &2 \\cr\\hline\n4 & 15&200 & 3\\times 10^3 & 25 & \\textbf{B}&3\\cr\\hline\n5 & 50&200 & 3\\times 10^3 & 25 & - &4\\cr\\hline\n\\end{array}\n$$\n\n- **特殊性质** $\\textbf{A}$：保证有且仅有一条从 $s$ 到 $t$ 的路径。\n- **特殊性质** $\\textbf{B}$：保证图中不存在环。\n\n对于 $100\\%$ 的数据，有 $1 \\le s,t,u_i,v_i \\leq n \\leq 200$，$1 \\leq m \\leq 3\\times 10^3$，$1 \\leq l_i\\le r_i \\leq k \\leq 25$，$1 \\leq w_i \\leq 10^3$。\n\n### 提示\n\n在附件中有两个版本的线段树。$\\text{Lite}$ 版本**仅**包含了在本题中你会用到的下推标记的操作，而标准版则较为完整地支持区间加、区间求和。选手可根据自己的喜好使用。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「Wdoi-1.5」旅人 1977", "background": "深邃的星空中划出了一道灿烂的弧线，而后又同这广袤境界溶为一体，二十世纪的旅行者，承载着期待与不安向着外太空飞去。这是一份来自一个遥远的小小世界的礼物。上面记载着我们的声音、我们的科学、我们的影像、我们的音乐、我们的思想和感情。我们正努力生活过我们的时代，进入你们的时代。或许人类将失去对它的联系，它也将像一个漂流瓶一样，向着宇宙深处孤独的走下去，直到被「另一个人」所捡起。而它为我们留下的最后一张「自拍」，也只是一个 $0.12$ 像素大的、淡蓝色的光点 —— 这是我们迄今所知的唯一家园。\n\n$\\kern{80pt}$![](https://cdn.luogu.com.cn/upload/image_hosting/qbelj85l.png)  \n$$\\scriptscriptstyle\\text{暗淡蓝点，旅行者 1 号，1990年 2 月 14 日}$$\n「已经分不清现实与梦境了呢。」  \n「或许，梦与现之间的境界，本就没有那么明晰。」\n\n……\n\n「真是的，莲子你不是自称亲近星光与月亮的嘛，怎么也不抬头看看。」\n\n正欲向笔记本上添加几行，借以目视的月光陡然暗淡。眼前垂落的金色长发挡住了我的视线。轻咳了一声，抬起手在面前挥舞，把他们从视野中赶走，我转头看着后背。\n眼前戴着白色帽子的少女便是我的同伴梅莉。我常常打趣她有着奇异的眼睛，可以看到我们所看不到的「境界」。尽管我自己的眼睛也十分特殊——我有着通过星光与月亮就知道我们现处何时何地的能力。忘了说了，我们是学生秘密社团『秘封俱乐部』，专门探寻科学世纪下的隐藏结界。  \n在这个夏夜，我本着履行对她承诺的想法，来到野外，观察天体的运行。\n\n「在想什么呢？」  \n这个问题不好回答呢。不过，既然今天和梅莉约好出来观赏星空，那么，思路被引向人们曾经的探索和求知，便是十分自然的了。  \n「唔，我在想，我们现今，科学世纪的起源。」  \n「嗯？莲子你不是研究物理的吗，怎么突然思考其这种问题了？」  \n梅莉把头朝右侧一歪，我指指天空，她随即坐在了一旁，把目光投向灿烂的星海。  \n「唔，我在想，我们现今，科学世纪的起源。还记得我和你说过的那两位旅人吗？」  \n「旅行者一号与旅行者二号？」  \n「没错。直到如今都没有人为任何深空计划取名为旅行者。带着如此诗意而感性名称的它们代表的是人们对未来的期许与对真理的渴望。面对未知与迷茫，义无反顾冲向了星海。」 \n\n梅莉站了起来，举起了双筒望远镜。她的身影在暗淡而幽静的夜色中来回移动，皎白得似有彩色光晕的月光从穹顶透过树叶与树枝的缝隙在她身上落下光斑，看着让人心醉。  \n\n超新星爆发是恒星生命的终点，也是新生恒星生命的起点。谁能说科学已经到了尽头，无法解释的事物不存在呢？科学的核心在于那些被视为空花阳焰，藏在迷雾中的东西，而绝非那些狂妄自大的老头们所说，科学是我们掌握的一切已知。  \n对我们而言，这是不言而喻的。我们追随那位初代社长的脚步，探寻遍布四处的结界，寻求隐藏在未知背后真理的一角，正是出于这样的信念。\n\n晷刻渐移，点点星尘围绕着北极星作着圆周运动。仔细看的话，北极星也在微微运动。在我的视线前方，梅莉兴奋地对着从英仙座辐射而出，偶尔划过天穹的流星发出惊叹。我不禁思索起来，现在勾陈一作为最接近北天极的恒星行使着为旅人指点方向的责任，但在永恒的运动中，永远会有新的谜题，新的未知，新的探索等着我们去发现。  \n\n物如此，事犹是，人亦然。前路永远有着未知的事物等着我们去探索。如果解明了所有的秘密，之后就会什么都不剩。知晓万物什么的，只不过是空空如也的虚无罢了。未知，才是驱动人类的原动力 $\\scriptscriptstyle{}^{[{\\color{grey}{1}}]}$。我们希冀着如同那两位先行者一般，作为开拓者，唤起根植于人们心中对未知的好奇与探索精神，并将它薪火相传。  \n身虽位于苍穹一粟，心亦向往若尘繁星。  \n身旁的梅莉靠在一棵树下，已经发出规律的鼾声，身体规律地微微起伏着。我伸手拨开她的手掌，撩开她垂下的头发，拿出她的笔记本。\n>从夜晚走向清晨。  \n从清晨走向夜晚。  \n从现实走向梦境。  \n从梦境走向现实。  \n终有一天，我们会在梦中，邂逅那片未经观测的星空。$\\scriptscriptstyle{}^{[{\\color{grey}{2}}]}$\n\n$\\scriptscriptstyle{[1],[2]}\\text{：引用自 }$ [here](https://bbs.nyasama.com/forum.php?mod=viewthread&tid=308054&page=2)", "description": "深邃的星空可以被视作一张有向图，图上的节点就是点点恒星。点无点权，边有边权。图的点数为 $n$，边数为 $m$，图可能有重边自环。但保证至少有一条路径可以从 $s$ 走到 $t$（$s$、$t$ 在输入中给定）。第 $i$ 条有向边起点为 $u_i$，终点为 $v_i$，它的权值用一个有序三元组 $(l_i,r_i,w_i)$ 表示。\n\n莲子要从点 $s$ 出发，经过了若干条边到达点 $t$。她带有一个初始值均为 $0$ 的长度为 $k$ 的数组 $a$，每次经过编号为 $i$ 的边，就会执行将 $a$ 数组的区间 $[l_i,r_i]$ 加 $w_i$ 的操作。她使用了一棵**带懒标记**的线段树来维护这一操作。线段树的写法会在接下来给出。\n\n你需要构造一条从 $s$ 到 $t$ 的路径，满足达到结点 $t$ 时，其线段树上所有标记的和的最小。输出这个最小值。\n\n以下是线段树的伪代码：（为了方便选手阅读，题目附件中给出了线段树的 C++ 源代码）\n\n$$\n\\begin{array}{l}\\hline\\hline\\\\[-0.8em]\n\\textbf{Algorithm: }\\text{SegTree}\\\\\\hline\\\\[-0.5em]\n\\begin{array}{rl}\n1& \\mathbf{Input.} \\text{ 长度为 $k$ 的 $a$ 数组，初始全为 $0$}\\\\\n2& \\mathbf{Output.} \\text{ $a$ 数组进行若干次区间加操作后得到的结果}\\\\\n3& \\mathbf{Method.}\\\\\n4& \\mathrm{Add}(L,R,x)\\\\\n5& \\quad\\mathrm{Add0}(L,R,x,root,1,k)\\\\\n6& \\mathrm{Add0}(L,R,x,u,l,r)\\\\\n7& \\quad\\mathbf{if}\\ L \\le l\\ \\mathbf{and}\\ r\\le R\\\\\n8& \\quad\\quad \\mathrm{tag}(u) \\gets \\mathrm{tag}(u) + x\\\\\n9& \\quad\\quad \\mathbf{return}\\\\\n10& \\quad mid \\gets \\lfloor\\frac{l+r} 2\\rfloor\\\\\n11& \\quad \\mathrm{tag}(\\mathrm{lson}(u)) \\gets \\mathrm{tag}(\\mathrm{lson}(u))+\\mathrm{tag}(u)\\\\\n12& \\quad \\mathrm{tag}(\\mathrm{rson}(u)) \\gets \\mathrm{tag}(\\mathrm{rson}(u))+\\mathrm{tag}(u)\\\\\n13& \\quad \\mathrm{tag}(u) \\gets 0\\\\\n14& \\quad\\mathbf{if}\\ L \\le mid\\\\\n15& \\quad\\quad\\mathrm{Add0}(L,R,x,\\mathrm{lson}(u),l,mid)\\\\\n16& \\quad\\mathbf{if}\\ mid < R\\\\\n17& \\quad\\quad\\mathrm{Add0}(L,R,x,\\mathrm{rson}(u),mid+1,r)\\\\\n\\end{array}\\\\\\hline\\hline\n\\end{array}\n$$", "inputFormat": "- 第一行五个整数 $n,m,k,s,t$。\n- 接下来 $m$ 行，每行五个整数 $u_i,v_i,l_i,r_i,w_i$。", "outputFormat": "- 共一行一个整数，表示沿着你构造的路径从 $s$ 到达 $t$ 后线段树上所有懒标记的权值之和。", "hint": "### 样例解释\n\n#### 样例 \\#1\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/npzajpom.png)\n\n容易发现，样例 $1$ 中有且仅有两条可能的路径：$1\\to 2\\to 4$ 与 $1\\to 3\\to 4$。下面分别计算这两条路径最终 $\\text{tag}$ 的权值和。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2fq7okad.png)\n\n考虑画出这棵 $k=5$ 的线段树。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ys42i046.png)\n\n走了边 $1\\to 2$ 后，$[1,2]$ 节点被打上了权值为 $2$ 的 $\\text{tag}$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/02sqysh5.png)\n\n走了 $2\\to 4$ 后，$[2,2]$ 节点和 $[3,3]$ 节点被打上了值为 $1$ 的 $\\text{tag}$；但是 $[1,2]$ 节点的标记进行了下推（因为使 $[2,3]$ 区间 $+1$ 的时候会访问到 $[1,2]$ 节点，而 $[1,2]\\nsubseteq[2,3]$，故而发生标记下推），因此 $[1,1]$ 节点和 $[2,2]$ 节点的 $\\text{tag}$ 分别加上了 $2$，最终成了如图所示的模样。\n\n因此走到 $4$ 之后所有结点的 $\\text{tag}$ 之和为 $2+3+1=6$。\n\n---\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3va7fa03.png)\n\n对于另外一条路径，首先对 $[4,5]$ 加上 $1$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/o1cw3s03.png)\n\n接着对 $[3,5]$ 加上 $2$。未发生带有 $\\text{tag}$ 的节点的标记下推，因此最终的权值为 $2+3=5$。\n\n由于 $6>5$，因而最终的答案为 $5$。\n\n### 数据范围及约定\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|c|}\\hline\n\\textbf{subtask}& \\textbf{分值}& {\\bm n\\le} & {\\bm m\\le} & {\\bm k\\le} & \\textbf{特殊性质} & \\textbf{subtask 依赖}\\cr\\hline\n1 & 10& 10 & 30 & 5 & - & -\\cr\\hline\n2 & 5&30 & 30 & 12 & \\textbf{AB} &-\\cr\\hline\n3 & 20&30 & 500 & 12 & \\textbf{B} &2 \\cr\\hline\n4 & 15&200 & 3\\times 10^3 & 25 & \\textbf{B}&3\\cr\\hline\n5 & 50&200 & 3\\times 10^3 & 25 & - &4\\cr\\hline\n\\end{array}\n$$\n\n- **特殊性质** $\\textbf{A}$：保证有且仅有一条从 $s$ 到 $t$ 的路径。\n- **特殊性质** $\\textbf{B}$：保证图中不存在环。\n\n对于 $100\\%$ 的数据，有 $1 \\le s,t,u_i,v_i \\leq n \\leq 200$，$1 \\leq m \\leq 3\\times 10^3$，$1 \\leq l_i\\le r_i \\leq k \\leq 25$，$1 \\leq w_i \\leq 10^3$。\n\n### 提示\n\n在附件中有两个版本的线段树。$\\text{Lite}$ 版本**仅**包含了在本题中你会用到的下推标记的操作，而标准版则较为完整地支持区间加、区间求和。选手可根据自己的喜好使用。", "locale": "zh-CN"}}}
{"pid": "P8118", "type": "P", "difficulty": 6, "samples": [["5 2\n2 3 4 5 6\n0", "0\n1\n2\n4\n6"], ["6 2\n1 1 4 5 6 8\n0", "0\n2\n2\n3\n4\n5\n"], ["6 2\n1 1 4 5 6 8\n1", "5"], ["20 4\n4 6 7 9 19 21 30 32 33 35 49 50 58 67 75 77 78 89 91 91\n0", "0\n2\n5\n10\n10\n12\n12\n14\n17\n22\n22\n25\n25\n25\n25\n27\n30\n30\n32\n36"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "线段树", "堆", "O2优化", "优先队列", "洛谷月赛"], "title": "「RdOI R3.5」Mystery", "background": "", "description": "给出一个长度为 $n$ 的单调不降整数数列 $\\{a_i\\}$ 和一个整数 $k$。\n\n我们定义两个长度均为 $p$ 的序列 $\\{x_i\\},\\{y_i\\}$ 的「差异度」$F(x,y,p)=\\sum_{i=1}^p |x_i-y_i|$。\n\n现在对于每个整数 $l \\in [1,n]$，你都需要构造一个长度为 $l$ 的序列 $\\{b_{l,i}\\}$。满足对于任意 $1\\le i <l$，$b_{l,i+1}\\ge b_{l,i}+k$；且 $F(a_{[1\\cdots l]},b_l,l)$ 最小。其中 $a_{[1\\cdots l]}$ 表示 $\\{a_i\\}$ 的长度为 $l$ 的前缀，即 $\\{a_1,a_2,\\cdots,a_l\\}$。注意，$b_{l,i}$ 没必要是整数。\n", "inputFormat": "第一行输入两个整数 $n,k$。  \n第二行输入 $n$ 个整数，代表 $\\{a_i\\}$。  \n第三行输入一个整数 $T$，代表答案输出方式。具体解释请参考「输出格式」。", "outputFormat": "- 若 $T=0$，则输出 $n$ 个整数，每个整数单独占一行。第 $l$ 行的整数代表 $F(a_{[1\\cdots l]},b_l,l)$。\n- 若 $T=1$，则你仅需输出一行一个整数，表示 $F(a,b_n,n)$。", "hint": "### 样例解释\n\n#### 样例 \\#1\n\n如下是一种可能的构造方案：\n\n$$\n\\begin{aligned}\nb_1&=\\{2\\}\\\\\nb_2&=\\{2,4\\}\\\\\nb_3&=\\{1,3,5\\}\\\\\nb_4&=\\{1,3,5,7\\}\\\\\nb_5&=\\{0,2,4,6,8\\}\\\\\n\\end{aligned}\n$$\n\n#### 样例 \\#2\n\n如下是一种可能的构造方案：\n\n$$\n\\begin{aligned}\nb_1&=\\{1\\}\\\\\nb_2&=\\{0,2\\}\\\\\nb_3&=\\{0,2,4\\}\\\\\nb_4&=\\{0,2,4,6\\}\\\\\nb_5&=\\{-1,1,3,5,7\\}\\\\\nb_6&=\\{-1,1,3,5,7,9\\}\\\\\n\\end{aligned}\n$$\n\n#### 样例 \\#3\n\n同样例 \\#2，只不过 $T=1$，你只需要输出 $F(a,b_6,6)=5$ 即可。\n\n### 数据范围及约定\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|} \\hline\n\\textbf{subtask} & \\textbf{分值} & \\bm{{n\\le}} & \\bm{{T=}} & \\bm{{k,a_i\\le}} & \\textbf{subtask 依赖}\\cr\\hline\n1 & 30 & 100 & 0 & 100 & -\\cr\\hline\n2 & 30 & 10^5 & 0 & 10^6 & 1\\cr\\hline\n3 & 40 & 10^6 & 1 & 10^6 & -\\cr\\hline\n\\end{array}\n$$\n\n对于 $100\\%$ 的数据，$1\\le n \\le 10^6$，$1\\le k,a_i\\le 10^6$，$T\\in\\{0,1\\}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「RdOI R3.5」Mystery", "background": "", "description": "给出一个长度为 $n$ 的单调不降整数数列 $\\{a_i\\}$ 和一个整数 $k$。\n\n我们定义两个长度均为 $p$ 的序列 $\\{x_i\\},\\{y_i\\}$ 的「差异度」$F(x,y,p)=\\sum_{i=1}^p |x_i-y_i|$。\n\n现在对于每个整数 $l \\in [1,n]$，你都需要构造一个长度为 $l$ 的序列 $\\{b_{l,i}\\}$。满足对于任意 $1\\le i <l$，$b_{l,i+1}\\ge b_{l,i}+k$；且 $F(a_{[1\\cdots l]},b_l,l)$ 最小。其中 $a_{[1\\cdots l]}$ 表示 $\\{a_i\\}$ 的长度为 $l$ 的前缀，即 $\\{a_1,a_2,\\cdots,a_l\\}$。注意，$b_{l,i}$ 没必要是整数。\n", "inputFormat": "第一行输入两个整数 $n,k$。  \n第二行输入 $n$ 个整数，代表 $\\{a_i\\}$。  \n第三行输入一个整数 $T$，代表答案输出方式。具体解释请参考「输出格式」。", "outputFormat": "- 若 $T=0$，则输出 $n$ 个整数，每个整数单独占一行。第 $l$ 行的整数代表 $F(a_{[1\\cdots l]},b_l,l)$。\n- 若 $T=1$，则你仅需输出一行一个整数，表示 $F(a,b_n,n)$。", "hint": "### 样例解释\n\n#### 样例 \\#1\n\n如下是一种可能的构造方案：\n\n$$\n\\begin{aligned}\nb_1&=\\{2\\}\\\\\nb_2&=\\{2,4\\}\\\\\nb_3&=\\{1,3,5\\}\\\\\nb_4&=\\{1,3,5,7\\}\\\\\nb_5&=\\{0,2,4,6,8\\}\\\\\n\\end{aligned}\n$$\n\n#### 样例 \\#2\n\n如下是一种可能的构造方案：\n\n$$\n\\begin{aligned}\nb_1&=\\{1\\}\\\\\nb_2&=\\{0,2\\}\\\\\nb_3&=\\{0,2,4\\}\\\\\nb_4&=\\{0,2,4,6\\}\\\\\nb_5&=\\{-1,1,3,5,7\\}\\\\\nb_6&=\\{-1,1,3,5,7,9\\}\\\\\n\\end{aligned}\n$$\n\n#### 样例 \\#3\n\n同样例 \\#2，只不过 $T=1$，你只需要输出 $F(a,b_6,6)=5$ 即可。\n\n### 数据范围及约定\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|} \\hline\n\\textbf{subtask} & \\textbf{分值} & \\bm{{n\\le}} & \\bm{{T=}} & \\bm{{k,a_i\\le}} & \\textbf{subtask 依赖}\\cr\\hline\n1 & 30 & 100 & 0 & 100 & -\\cr\\hline\n2 & 30 & 10^5 & 0 & 10^6 & 1\\cr\\hline\n3 & 40 & 10^6 & 1 & 10^6 & -\\cr\\hline\n\\end{array}\n$$\n\n对于 $100\\%$ 的数据，$1\\le n \\le 10^6$，$1\\le k,a_i\\le 10^6$，$T\\in\\{0,1\\}$。", "locale": "zh-CN"}}}
{"pid": "P8119", "type": "P", "difficulty": 6, "samples": [["3 3\n1 2\n2 3\n1 3", "1 5\nRan 2\nChen 3\nSwap\nRan 1\nChen 1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "Special Judge", "O2优化", "构造", "洛谷月赛"], "title": "「Wdoi-1.5」幻想乡游览计划", "background": "（此为背景，可以跳过）\n\n自从姬虫百百世开挖了妖怪之山山顶的虹龙洞后，一成不变的幻想乡又多了可以探索的地方。充满心机的、监视着幻想乡一切动静的八云紫自然需要对其内部了如指掌，以此来掌握对幻想乡的绝对控制权。作为八云紫的式神的八云蓝，则奉命探索这块区域。随行的还有八云蓝的式神，橙。\n\n虹龙洞开采的目的是为了获取其中的龙珠，而龙珠分布在虹龙洞内的各个角落。为了能够滴水不漏地得到更多的龙珠，百百世挖出了纵横交错的矿道，连接着各处的龙珠采集点。矿道之间相互交错，构成了一张层层叠叠的网。八云蓝和橙的任务则是分别到达过虹龙洞内所有的龙珠采集点，采集足够多的信息，以完成八云紫对虹龙洞彻底的监控目标。\n\n然而，身处于黑暗的洞穴内，诺大的虹龙洞的环境十分险恶。极度缺氧的环境使得探索虹龙洞并不是一件容易的事情，因此八云蓝与橙不可能在虹龙洞内探索过长的时间。所幸的是，八云蓝可以联系到八云紫；而拥有操控境界能力的紫，则可以利用隙间交换蓝和橙的位置。\n\n八云紫已经私通菅牧典从大天狗那里得到了虹龙洞的内部结构图。为了尽量减少在虹龙洞内滞留的时间，八云一家需要设计出一套可行的方案。", "description": "虹龙洞内可以抽象成一张有 $n$ 个点和 $m$ 条的无向连通图，图可能有自环和重边。\n\n紫会用隙间的能力，将蓝和橙传送到虹龙洞的某一结点上。此处使用隙间所花费的时间忽略不计。输出格式中的 $S$ 即代表初始传送到的结点。\n\n接下来橙和蓝将会分别进行移动。每单位时间，蓝或者橙可以移动到与她们所在结点**直接相连**的结点上，或者紫使用隙间能力交换蓝和橙的位置。请注意：在这一单位时间内**只有一个人（蓝或者橙或者紫）可以行动**，并且此处的交换操作也是花费时间的。\n\n现在，八云蓝请你构造出一个方案，使得橙和蓝**各自都**能经过虹龙洞的每个结点至少 $1$ 次，并且最后**都**回到一开始所在的结点 $S$ 以结束此次游览。在「输出格式」中蓝说明了构造方案的格式，你只要按格式输出构造方案告诉蓝就行了。", "inputFormat": "第一行两个整数 $n,m$，表示该图有 $n$ 个节点，$m$ 条边。\n\n接下来 $m$ 行，每行两个整数 $u,v$，表示有一条连接 $u,v$ 的无向边。", "outputFormat": "第一行输出两个整数 $S$ 和 $k$。其中 $S$ 的含义见题目描述，$k$ 表示你的方案的操作次数。\n\n接下来 $k$ 行，你可以输出三种操作中的一种指导八云一家行动：\n- 输出 `Ran u`，表示让蓝移动到结点 $u$；\n- 输出 `Chen u`，表示让橙移动到结点 $u$；\n- 输出 `Swap` 表示让紫交换橙和蓝的位置。\n\n你需要保证你的构造方案合法。\n\n容易发现，你的操作次数 $k$ 等于进行所有操作所花费的单位时间数。", "hint": "### 样例解释\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|}\\hline\n\\textbf{操作次数} & \\textbf{蓝的位置} &\\textbf{橙的位置} \\cr\\hline\n0 & 1 & 1 \\cr\\hline\n1 & 2 & 1 \\cr\\hline\n2 & 2 & 3 \\cr\\hline\n3 & 3 & 2 \\cr\\hline\n4 & 1 & 2 \\cr\\hline\n5 & 1 & 1 \\cr\\hline\n\\end{array}\n$$\n\n### 判分方式\n\n**本题使用 Special Judge。**\n\n对于每组数据，若你输出的方案不合法（含不合法的移动操作，或者蓝或橙没有经过每个结点至少 $1$ 次，或者最后蓝和橙没有在 $S$ 点），你的分数为零分。否则你的分数将这样计算：\n\n- 当 $k \\leq 4\\cdot n$ 时，你将获得该测试点 $20\\%$ 的分数；\n- 当 $k \\leq 3\\cdot n$ 时，你将获得该测试点 $40\\%$ 的分数；\n- 当 $k \\le \\lfloor\\frac{11}{4} \\cdot n\\rfloor$ 时，你将获得该测试点 $70\\%$ 的分数；\n- 当 $k \\le \\lfloor\\frac{8}{3} \\cdot n\\rfloor$ 时，你将获得该测试点所有的分数。\n\n### 数据范围\n\n**本题采用捆绑测试，且仅有一个 subtask，总成绩取各测试点最低分。**\n\n对于 $100\\%$ 的数据，$3\\leq n,m \\leq 5\\times 10^5$。\n\n### 校验器\n\n为了方便选手测试，在附件中我们下发了 `checker.cpp` 文件，选手可以编译该程序，并使用它校验自己的输出文件。但请注意它与最终评测时所使用的校验器并不完全一致。你也不需要关心其代码的具体内容。\n\n编译命令为：`g++ checker.cpp −o checker -std=c++14`。\n\nchecker 的使用方式为：`./checker <inputfile> <outputfile>`，参数依次表示输入文件与你的输出文件。\n\n若你输出的数字大小范围不合法，则校验器会给出相应提示。若你的输出数字大小范围正确，但方案错误，则校验器会给出简要的错误信息：\n\n1. `A x`，表示进行到第 $x$ 个操作时不合法。\n2. `B x`，表示操作执行完毕后蓝/橙没有经过每个节点至少一次，其中 $x=0$ 表示蓝，$x=1$ 表示橙。\n3. `C x`，表示操作执行完毕后蓝/橙没有回到 $S$ 点。其中 $x=0$ 表示蓝，$x=1$ 表示橙。\n4. `Illeagl Output`，表示你输出了错误的操作。\n\n若你的方案正确，校验器会给出 `OK`。\n\n保证在输入正确、方案合法的情况下 checker 的运行时间小于 1s。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「Wdoi-1.5」幻想乡游览计划", "background": "（此为背景，可以跳过）\n\n自从姬虫百百世开挖了妖怪之山山顶的虹龙洞后，一成不变的幻想乡又多了可以探索的地方。充满心机的、监视着幻想乡一切动静的八云紫自然需要对其内部了如指掌，以此来掌握对幻想乡的绝对控制权。作为八云紫的式神的八云蓝，则奉命探索这块区域。随行的还有八云蓝的式神，橙。\n\n虹龙洞开采的目的是为了获取其中的龙珠，而龙珠分布在虹龙洞内的各个角落。为了能够滴水不漏地得到更多的龙珠，百百世挖出了纵横交错的矿道，连接着各处的龙珠采集点。矿道之间相互交错，构成了一张层层叠叠的网。八云蓝和橙的任务则是分别到达过虹龙洞内所有的龙珠采集点，采集足够多的信息，以完成八云紫对虹龙洞彻底的监控目标。\n\n然而，身处于黑暗的洞穴内，诺大的虹龙洞的环境十分险恶。极度缺氧的环境使得探索虹龙洞并不是一件容易的事情，因此八云蓝与橙不可能在虹龙洞内探索过长的时间。所幸的是，八云蓝可以联系到八云紫；而拥有操控境界能力的紫，则可以利用隙间交换蓝和橙的位置。\n\n八云紫已经私通菅牧典从大天狗那里得到了虹龙洞的内部结构图。为了尽量减少在虹龙洞内滞留的时间，八云一家需要设计出一套可行的方案。", "description": "虹龙洞内可以抽象成一张有 $n$ 个点和 $m$ 条的无向连通图，图可能有自环和重边。\n\n紫会用隙间的能力，将蓝和橙传送到虹龙洞的某一结点上。此处使用隙间所花费的时间忽略不计。输出格式中的 $S$ 即代表初始传送到的结点。\n\n接下来橙和蓝将会分别进行移动。每单位时间，蓝或者橙可以移动到与她们所在结点**直接相连**的结点上，或者紫使用隙间能力交换蓝和橙的位置。请注意：在这一单位时间内**只有一个人（蓝或者橙或者紫）可以行动**，并且此处的交换操作也是花费时间的。\n\n现在，八云蓝请你构造出一个方案，使得橙和蓝**各自都**能经过虹龙洞的每个结点至少 $1$ 次，并且最后**都**回到一开始所在的结点 $S$ 以结束此次游览。在「输出格式」中蓝说明了构造方案的格式，你只要按格式输出构造方案告诉蓝就行了。", "inputFormat": "第一行两个整数 $n,m$，表示该图有 $n$ 个节点，$m$ 条边。\n\n接下来 $m$ 行，每行两个整数 $u,v$，表示有一条连接 $u,v$ 的无向边。", "outputFormat": "第一行输出两个整数 $S$ 和 $k$。其中 $S$ 的含义见题目描述，$k$ 表示你的方案的操作次数。\n\n接下来 $k$ 行，你可以输出三种操作中的一种指导八云一家行动：\n- 输出 `Ran u`，表示让蓝移动到结点 $u$；\n- 输出 `Chen u`，表示让橙移动到结点 $u$；\n- 输出 `Swap` 表示让紫交换橙和蓝的位置。\n\n你需要保证你的构造方案合法。\n\n容易发现，你的操作次数 $k$ 等于进行所有操作所花费的单位时间数。", "hint": "### 样例解释\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|}\\hline\n\\textbf{操作次数} & \\textbf{蓝的位置} &\\textbf{橙的位置} \\cr\\hline\n0 & 1 & 1 \\cr\\hline\n1 & 2 & 1 \\cr\\hline\n2 & 2 & 3 \\cr\\hline\n3 & 3 & 2 \\cr\\hline\n4 & 1 & 2 \\cr\\hline\n5 & 1 & 1 \\cr\\hline\n\\end{array}\n$$\n\n### 判分方式\n\n**本题使用 Special Judge。**\n\n对于每组数据，若你输出的方案不合法（含不合法的移动操作，或者蓝或橙没有经过每个结点至少 $1$ 次，或者最后蓝和橙没有在 $S$ 点），你的分数为零分。否则你的分数将这样计算：\n\n- 当 $k \\leq 4\\cdot n$ 时，你将获得该测试点 $20\\%$ 的分数；\n- 当 $k \\leq 3\\cdot n$ 时，你将获得该测试点 $40\\%$ 的分数；\n- 当 $k \\le \\lfloor\\frac{11}{4} \\cdot n\\rfloor$ 时，你将获得该测试点 $70\\%$ 的分数；\n- 当 $k \\le \\lfloor\\frac{8}{3} \\cdot n\\rfloor$ 时，你将获得该测试点所有的分数。\n\n### 数据范围\n\n**本题采用捆绑测试，且仅有一个 subtask，总成绩取各测试点最低分。**\n\n对于 $100\\%$ 的数据，$3\\leq n,m \\leq 5\\times 10^5$。\n\n### 校验器\n\n为了方便选手测试，在附件中我们下发了 `checker.cpp` 文件，选手可以编译该程序，并使用它校验自己的输出文件。但请注意它与最终评测时所使用的校验器并不完全一致。你也不需要关心其代码的具体内容。\n\n编译命令为：`g++ checker.cpp −o checker -std=c++14`。\n\nchecker 的使用方式为：`./checker <inputfile> <outputfile>`，参数依次表示输入文件与你的输出文件。\n\n若你输出的数字大小范围不合法，则校验器会给出相应提示。若你的输出数字大小范围正确，但方案错误，则校验器会给出简要的错误信息：\n\n1. `A x`，表示进行到第 $x$ 个操作时不合法。\n2. `B x`，表示操作执行完毕后蓝/橙没有经过每个节点至少一次，其中 $x=0$ 表示蓝，$x=1$ 表示橙。\n3. `C x`，表示操作执行完毕后蓝/橙没有回到 $S$ 点。其中 $x=0$ 表示蓝，$x=1$ 表示橙。\n4. `Illeagl Output`，表示你输出了错误的操作。\n\n若你的方案正确，校验器会给出 `OK`。\n\n保证在输入正确、方案合法的情况下 checker 的运行时间小于 1s。", "locale": "zh-CN"}}}
{"pid": "P8120", "type": "P", "difficulty": 7, "samples": [["4 6 6 1\n1 2 3 4\n1 2 3 2 3 4\n1 3\n2 7\n1 7\n0 7\n0 4\n2 5", "3\n3\n2\n2\n3\n4"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720]}, "tags": ["洛谷原创", "O2优化", "分块", "洛谷月赛"], "title": "「RdOI R3.5」RMSQ", "background": "", "description": "给出一个长度为 $m$ 的**排列** $b$ 和一个长度为 $n$ 的**序列** $a$。\n\n如果一个序列 $S$，满足其按位置从左到右依次匹配 $b$ 的一个区间从左到右的位置，那么我们说 $S$ 是一个「优美序列」。\n\n给出 $q$ 次询问。每次询问给出两个整数 $l$ 和 $r$。你需要找到一个 $a$ 的 $[l,r]$ 子区间中的一个最长的满足「优美序列」条件的子序列长度。注意子序列可以不连续。", "inputFormat": "- 第一行输入四个整数 $m,n,q,T$，其中 $n,m,q$ 的含义见「题目描述」，$T$ 表示是否强制在线。\n- 第二行输入 $m$ 个整数 $b_1,b_2,\\cdots,b_m$。\n- 第三行输入 $n$ 个整数 $a_1,a_2,\\cdots,a_n$。\n- 接下来 $q$ 行每行输入两个整数 $l',r'$。若 $T=1$，则你需要将 $l'$ 和 $r'$ 按位异或 $\\mathit{lastans}$ 来得到真正的 $l,r$。其定义为上一次询问操作得到的答案，若之前没有询问操作，则为 $0$。否则若 $T=0$，则 $l=l',r=r'$。", "outputFormat": "- 输出共 $q$ 行。\n- 第 $i$ 行输出一个整数，表示第 $i$ 次询问的答案。", "hint": "### 样例解释\n\n$\\mathit{lastans}$ 解密后的询问为：\n\n```plain\n1 3\n1 4\n2 4\n2 5\n2 6\n1 6\n```\n\n### 数据范围\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|c|} \\hline\n\\textbf{Subtask} & \\textbf{分值} & \\bm{{n,m\\le}} &\\bm{{q\\le}} & \\bm{{T=}} & \\textbf{特殊性质} & \\textbf{Subtask 依赖}\\cr\\hline\n1 & 10 & 100 & 10^4 & 1 & \\textbf{A} & -\\cr\\hline\n2 & 15 & 10^5 & 10^5 & 1 & \\textbf{A} & 1\\cr\\hline\n3 & 30 & 3\\times 10^5 & 10^6 & 0 & - & -\\cr\\hline\n4 & 45 & 3\\times 10^5 & 10^6 & 1 & - & 2,3\\cr\\hline\n\\end{array}\n$$\n\n- 特殊性质 $\\textbf{A}$：保证 $a_i,b_i,l,r$ 在数据范围内均匀随机。\n\n对于 $100\\%$ 的数据，$1\\le l\\le r\\le n\\le 3\\times 10^5$，$1\\le a_i\\le m\\le 3\\times 10^5$，$1\\le q \\le 1\\times 10^6$，$T \\in \\{0,1\\}$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「RdOI R3.5」RMSQ", "background": "", "description": "给出一个长度为 $m$ 的**排列** $b$ 和一个长度为 $n$ 的**序列** $a$。\n\n如果一个序列 $S$，满足其按位置从左到右依次匹配 $b$ 的一个区间从左到右的位置，那么我们说 $S$ 是一个「优美序列」。\n\n给出 $q$ 次询问。每次询问给出两个整数 $l$ 和 $r$。你需要找到一个 $a$ 的 $[l,r]$ 子区间中的一个最长的满足「优美序列」条件的子序列长度。注意子序列可以不连续。", "inputFormat": "- 第一行输入四个整数 $m,n,q,T$，其中 $n,m,q$ 的含义见「题目描述」，$T$ 表示是否强制在线。\n- 第二行输入 $m$ 个整数 $b_1,b_2,\\cdots,b_m$。\n- 第三行输入 $n$ 个整数 $a_1,a_2,\\cdots,a_n$。\n- 接下来 $q$ 行每行输入两个整数 $l',r'$。若 $T=1$，则你需要将 $l'$ 和 $r'$ 按位异或 $\\mathit{lastans}$ 来得到真正的 $l,r$。其定义为上一次询问操作得到的答案，若之前没有询问操作，则为 $0$。否则若 $T=0$，则 $l=l',r=r'$。", "outputFormat": "- 输出共 $q$ 行。\n- 第 $i$ 行输出一个整数，表示第 $i$ 次询问的答案。", "hint": "### 样例解释\n\n$\\mathit{lastans}$ 解密后的询问为：\n\n```plain\n1 3\n1 4\n2 4\n2 5\n2 6\n1 6\n```\n\n### 数据范围\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|c|} \\hline\n\\textbf{Subtask} & \\textbf{分值} & \\bm{{n,m\\le}} &\\bm{{q\\le}} & \\bm{{T=}} & \\textbf{特殊性质} & \\textbf{Subtask 依赖}\\cr\\hline\n1 & 10 & 100 & 10^4 & 1 & \\textbf{A} & -\\cr\\hline\n2 & 15 & 10^5 & 10^5 & 1 & \\textbf{A} & 1\\cr\\hline\n3 & 30 & 3\\times 10^5 & 10^6 & 0 & - & -\\cr\\hline\n4 & 45 & 3\\times 10^5 & 10^6 & 1 & - & 2,3\\cr\\hline\n\\end{array}\n$$\n\n- 特殊性质 $\\textbf{A}$：保证 $a_i,b_i,l,r$ 在数据范围内均匀随机。\n\n对于 $100\\%$ 的数据，$1\\le l\\le r\\le n\\le 3\\times 10^5$，$1\\le a_i\\le m\\le 3\\times 10^5$，$1\\le q \\le 1\\times 10^6$，$T \\in \\{0,1\\}$。\n", "locale": "zh-CN"}}}
{"pid": "P8121", "type": "P", "difficulty": 0, "samples": [["1 1 3 100 1 5\n1 1 1 2 3\n1 100 0 0 1 0\n1 100 1 0 0 0\n2 3 0 1 0 0\n", "34\n"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "动态规划 DP", "搜索", "贪心", "高精度", "2022", "洛谷原创", "Special Judge", "O2优化", "枚举", "最短路", "高斯消元", "位运算", "洛谷月赛"], "title": "「RdOI R3.5 附加」ACP-II", "background": "在 1951 年，第 -32 届全国青少年信息学奥林匹克冬令营结束后，打了一上午比赛的小 A 疲惫不堪，想放松一下。于是他又借助时空传输接口（**T**ime **T**ransport **I**nterface）连接了一台 2015 年的计算机，获取到了最新的游戏「**AC** **P**roject 15 / Legacy of DWT AKing IOI」来游玩。\n", "description": "**这是一道传统题。**\n\n你需要控制机器人玩躲避子弹的游戏。游戏的画面是一个在第一象限，坐标范围从 $(0,0)$ 至 $(n,m)$ 的矩形。机器人初始生成在坐标 $(0,0)$。你可以通过以下几种指令来控制这个机器人：\n\n$$\n\\begin{array}{|c|l|}\\hline\n\\textsf{\\textbf{指令}} & \\textsf{\\textbf{描述}} \\cr\\hline\n\\bm 0 & \\textsf{机器人静止不动} \\cr\\hline\n\\bm 1 & \\textsf{机器人向左移动 $1$ 单位长度，即从 $(x,y)$ 移动到 $(x-1,y)$} \\cr\\hline\n\\bm 2 & \\textsf{机器人向下移动 $1$ 单位长度，即从 $(x,y)$ 移动到 $(x,y-1)$} \\cr\\hline\n\\bm 3 & \\textsf{机器人向上移动 $1$ 单位长度，即从 $(x,y)$ 移动到 $(x,y+1)$} \\cr\\hline\n\\bm 4 & \\textsf{机器人向右移动 $1$ 单位长度，即从 $(x,y)$ 移动到 $(x+1,y)$} \\cr\\hline\n\\end{array}\n$$\n\n你构造的指令用一个数字串 $C'$ 表示。每种指令都会耗费一定的费用。具体来讲，你构造的**原始指令** $C'$ 中每包含一个 $i$ 号命令，就会耗费 $P_i$ 的费用。\n\n你的指令会被重复 $k$ 遍，作为机器人的移动指令 $C$。例如当 $C'=1123$，$k=3$ 时，机器人收到的指令 $C= 112311231123$。\n\n游戏中会生成 $b$ 个子弹，每个子弹用一个有序六元组 $(l_i,r_i,x_i,y_i,p_i,q_i)$ 表示。它的意思是这颗子弹在 $l_i$ 秒生成，第 $r_i$ 秒销毁。生成时的坐标为 $(x_i,y_i)$。每秒沿着 $x$ 轴正方向移动 $p_i$ 单位长度，沿着 $y$ 轴正方向移动 $q_i$ 单位长度。\n\n游戏共进行 $d$ 秒，若 $d$ 秒内机器人碰撞到子弹或者移动到画面以外，机器人就会爆炸，游戏失败。如果在第 $d$ 秒结束时机器人没有爆炸，则游戏胜利。\n\n游戏中的每一秒分为五个阶段，每个阶段结束后才会执行下一个阶段：\n\n1. 机器人移动阶段。机器人会在第 $i$ 秒执行 $C_i$ 指令。若 $C$ 的长度 $< i$，也就是说所有指令都执行完了，则静止不动。\n1. 子弹移动阶段，所有已经生成且还未销毁的子弹会进行一次移动。具体来讲，设当前是第 $c$ 秒，对于满足 $l_i<c\\le r_i$ 的每个子弹 $(l_i,r_i,x_i,y_i,p_i,q_i)$，它的坐标会变为 $(x_i+(c-l_i)p_i,y_i+(c-l_i)q_i)$。\n1. 子弹生成阶段。设当前是第 $c$ 秒，对于所有 $l_i=c$ 的子弹，将它们生成进画面，放置各自的初始位置 $(x_i,y_i)$ 上。\n1. 判定阶段。若此时机器人的位置超出了画面，或者碰撞到了任意一颗已经被生成且尚未销毁的子弹，则机器人就会受击爆炸。具体来说，对于每一颗在画面上的子弹，设这颗子弹在这一秒初的位置为 $P=(x',y')$，当前的位置为 $Q=(x'',y'')$。若子弹是在这一秒内刚生成的则 $P=Q$。连接线段 $PQ$，若当前机器人的坐标在这条线段上（包括在线段的端点上），则视为机器人碰撞到了子弹。\n1. 子弹销毁阶段。设当前是第 $c$ 秒，对于所有 $r_i=c$ 的子弹，将它们销毁。\n", "inputFormat": "- 第一行输入六个整数 $n,m,b,d,k,maxc$。\n- 第二行输入五个整数 $P_0,P_1,P_2,P_3,P_4$。\n- 第三行至第 $b+2$ 行，每行输入六个整数。其中第 $i+2$ 行输入的整数分别代表 $l_i,r_i,x_i,y_i,p_i,q_i$。\n", "outputFormat": "- 若 $maxc\\ge 0$，则你需要输出一行一个字符串，表示你构造的指令，你需要保证指令费用 $\\le maxc$。\n- 否则，你需要输出一行一个整数，表示在所有可以成功完成游戏的指令中费用最少的指令的费用是多少。\n", "hint": "### 样例解释\n\n示意图里用 `0` 表示子弹，`1` 表示机器人，`.` 表示空位。\n\n第 $1$ 秒钟：机器人移动到了 $(0,1)$；在 $(0,0)$ 和 $(1,0)$ 分别生成了一颗子弹。\n\n```\n1.\n00\n```\n\n第 $2$ 秒钟：机器人移动到了 $(1,1)$；在 $(0,0)$ 处的子弹移动到了 $(0,1)$；在 $(0,1)$ 生成了一颗子弹。所以现在在 $(0,1)$ 处有两颗子弹（在下图中因为子弹重合只标出了一颗）。\n\n```\n01\n.0\n```\n\n第 $3$ 秒钟：机器人位置不变；其中一颗位于 $(0,1)$ 的子弹飞出了画面；另外一颗位于 $(0,1)$ 的子弹被销毁。\n\n```\n.1\n.0\n```\n\n第 $4$ 秒至第 $100$ 秒：机器人没有移动；位于画面外的子弹移动后仍然在画面之外，在画面内的那颗子弹没有移动，画面情况同第三秒的情况。\n\n综上所述，这个指令可以成功完成游戏，费用为 $1\\times 3+ 1 \\times2=5$。\n\n---\n\n### 数据范围及限制\n\n**本题采用捆绑测试。**\n\n$$\n\\begin{array}{|c|c|c|c|c|c|c|c|c|}\\hline\n\\textbf{subtask} & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8\\cr\\hline\n\\textbf{分值} & 10 & 10 & 10 & 10 & 15 & 15 & 15 & 15\\cr\\hline\n\\end{array}\n$$\n\n对于 $100\\%$ 的数据，保证 $n,m,b,d,P_i\\ge0$，$k\\ge 1$，$1\\le l \\le r$，$maxc\\ge-1$。\n\n你可能会想，这算什么数据范围？怎么没有上界？而且表格里怎么没有 subtask 的特殊限制？实际上，出题人也不知道数据的上界和特殊限制。\n\n由于出题人的误操作，数据生成器源代码意外丢失，只剩下可执行程序。下发文件中提供了在 Windows / Linux / Mac 下编译的可执行程序。不同操作系统下编译的文件名如下：\n\n- 对于 Windows 系统（文件名 genX-w32）：`g++ genX.cpp -o genX -O3 -std=c++14`，在 Windows10，Dev-C++ 5.50，TDM-GCC 4.9.2 32bit 下编译。\n- 对于 Linux/Mac 系统（32 位，文件名 genX-l32）：`g++ genX.cpp -o genX -O3 -std=c++14 -m32`，在 NOI Linux 2.0，GCC 9.3.0 下编译。\n- 对于 Linux/Mac 系统（64 位，文件名 genX-l64）：`g++ genX.cpp -o genX -O3 -std=c++14 -m64`，在 NOI Linux 2.0，GCC 9.3.0 下编译。\n\n数据生成器需要在运行后输入一个 $[1,2^{30})$ 范围内的整数作为随机数种子，它会生成一份输入至 `0.in` 中。出题人无法保证生成的数据范围，但是可以保证：\n\n- 同一个生成器所生成出的数据拥有同一个特殊限制。\n- 所有生成器在 NOI Linux 2.0，处理器 i5-4200m 下运行，所用时间不超过 3s，内存占用不超过 2G。\n- 生成出来的数据只与你输入的种子有关，与当前时间、操作系统等其它可变因素无关。\n- 部分数据生成器会有极小概率生成一个无解数据，但保证 OJ 上的所有数据均有解。\n- 你输入的种子只会当作随机数的种子使用，生成器不会出现特判种子生成干扰数据等行为。\n\n数据中的每个 subtask 分别对应一个数据生成器所生成的数据。编号为 $X$ 的 subtask 对应的生成器是 `genX`。\n\n**注意：由于输入格式中没有要求输入「subtask 编号」，你需要自己判断当前数据所对应的 subtask。且本题的 subtask 为乱序排布，你需要自己判断每个 subtask 的难易程度。**\n\n同时，在下发文件分发有 `checker.cpp`。使用 `g++ checker.cpp -o checker -std=c++14` 将 `checker.cpp` 编译为可执行文件后运行 `./checker <inputfile> <outputfile>`，`checker` 就会给出游戏的输赢情况。其中 `<inputfile>` 为数据生成器生成的 `.in` 文件；`<outputfile>` 中存放你的输出。**本 checker 仅供理解游戏规则使用，和实际使用的 checker 有所不同，且不保证 checker 的时间复杂度正确。**\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「RdOI R3.5 附加」ACP-II", "background": "在 1951 年，第 -32 届全国青少年信息学奥林匹克冬令营结束后，打了一上午比赛的小 A 疲惫不堪，想放松一下。于是他又借助时空传输接口（**T**ime **T**ransport **I**nterface）连接了一台 2015 年的计算机，获取到了最新的游戏「**AC** **P**roject 15 / Legacy of DWT AKing IOI」来游玩。\n", "description": "**这是一道传统题。**\n\n你需要控制机器人玩躲避子弹的游戏。游戏的画面是一个在第一象限，坐标范围从 $(0,0)$ 至 $(n,m)$ 的矩形。机器人初始生成在坐标 $(0,0)$。你可以通过以下几种指令来控制这个机器人：\n\n$$\n\\begin{array}{|c|l|}\\hline\n\\textsf{\\textbf{指令}} & \\textsf{\\textbf{描述}} \\cr\\hline\n\\bm 0 & \\textsf{机器人静止不动} \\cr\\hline\n\\bm 1 & \\textsf{机器人向左移动 $1$ 单位长度，即从 $(x,y)$ 移动到 $(x-1,y)$} \\cr\\hline\n\\bm 2 & \\textsf{机器人向下移动 $1$ 单位长度，即从 $(x,y)$ 移动到 $(x,y-1)$} \\cr\\hline\n\\bm 3 & \\textsf{机器人向上移动 $1$ 单位长度，即从 $(x,y)$ 移动到 $(x,y+1)$} \\cr\\hline\n\\bm 4 & \\textsf{机器人向右移动 $1$ 单位长度，即从 $(x,y)$ 移动到 $(x+1,y)$} \\cr\\hline\n\\end{array}\n$$\n\n你构造的指令用一个数字串 $C'$ 表示。每种指令都会耗费一定的费用。具体来讲，你构造的**原始指令** $C'$ 中每包含一个 $i$ 号命令，就会耗费 $P_i$ 的费用。\n\n你的指令会被重复 $k$ 遍，作为机器人的移动指令 $C$。例如当 $C'=1123$，$k=3$ 时，机器人收到的指令 $C= 112311231123$。\n\n游戏中会生成 $b$ 个子弹，每个子弹用一个有序六元组 $(l_i,r_i,x_i,y_i,p_i,q_i)$ 表示。它的意思是这颗子弹在 $l_i$ 秒生成，第 $r_i$ 秒销毁。生成时的坐标为 $(x_i,y_i)$。每秒沿着 $x$ 轴正方向移动 $p_i$ 单位长度，沿着 $y$ 轴正方向移动 $q_i$ 单位长度。\n\n游戏共进行 $d$ 秒，若 $d$ 秒内机器人碰撞到子弹或者移动到画面以外，机器人就会爆炸，游戏失败。如果在第 $d$ 秒结束时机器人没有爆炸，则游戏胜利。\n\n游戏中的每一秒分为五个阶段，每个阶段结束后才会执行下一个阶段：\n\n1. 机器人移动阶段。机器人会在第 $i$ 秒执行 $C_i$ 指令。若 $C$ 的长度 $< i$，也就是说所有指令都执行完了，则静止不动。\n1. 子弹移动阶段，所有已经生成且还未销毁的子弹会进行一次移动。具体来讲，设当前是第 $c$ 秒，对于满足 $l_i<c\\le r_i$ 的每个子弹 $(l_i,r_i,x_i,y_i,p_i,q_i)$，它的坐标会变为 $(x_i+(c-l_i)p_i,y_i+(c-l_i)q_i)$。\n1. 子弹生成阶段。设当前是第 $c$ 秒，对于所有 $l_i=c$ 的子弹，将它们生成进画面，放置各自的初始位置 $(x_i,y_i)$ 上。\n1. 判定阶段。若此时机器人的位置超出了画面，或者碰撞到了任意一颗已经被生成且尚未销毁的子弹，则机器人就会受击爆炸。具体来说，对于每一颗在画面上的子弹，设这颗子弹在这一秒初的位置为 $P=(x',y')$，当前的位置为 $Q=(x'',y'')$。若子弹是在这一秒内刚生成的则 $P=Q$。连接线段 $PQ$，若当前机器人的坐标在这条线段上（包括在线段的端点上），则视为机器人碰撞到了子弹。\n1. 子弹销毁阶段。设当前是第 $c$ 秒，对于所有 $r_i=c$ 的子弹，将它们销毁。\n", "inputFormat": "- 第一行输入六个整数 $n,m,b,d,k,maxc$。\n- 第二行输入五个整数 $P_0,P_1,P_2,P_3,P_4$。\n- 第三行至第 $b+2$ 行，每行输入六个整数。其中第 $i+2$ 行输入的整数分别代表 $l_i,r_i,x_i,y_i,p_i,q_i$。\n", "outputFormat": "- 若 $maxc\\ge 0$，则你需要输出一行一个字符串，表示你构造的指令，你需要保证指令费用 $\\le maxc$。\n- 否则，你需要输出一行一个整数，表示在所有可以成功完成游戏的指令中费用最少的指令的费用是多少。\n", "hint": "### 样例解释\n\n示意图里用 `0` 表示子弹，`1` 表示机器人，`.` 表示空位。\n\n第 $1$ 秒钟：机器人移动到了 $(0,1)$；在 $(0,0)$ 和 $(1,0)$ 分别生成了一颗子弹。\n\n```\n1.\n00\n```\n\n第 $2$ 秒钟：机器人移动到了 $(1,1)$；在 $(0,0)$ 处的子弹移动到了 $(0,1)$；在 $(0,1)$ 生成了一颗子弹。所以现在在 $(0,1)$ 处有两颗子弹（在下图中因为子弹重合只标出了一颗）。\n\n```\n01\n.0\n```\n\n第 $3$ 秒钟：机器人位置不变；其中一颗位于 $(0,1)$ 的子弹飞出了画面；另外一颗位于 $(0,1)$ 的子弹被销毁。\n\n```\n.1\n.0\n```\n\n第 $4$ 秒至第 $100$ 秒：机器人没有移动；位于画面外的子弹移动后仍然在画面之外，在画面内的那颗子弹没有移动，画面情况同第三秒的情况。\n\n综上所述，这个指令可以成功完成游戏，费用为 $1\\times 3+ 1 \\times2=5$。\n\n---\n\n### 数据范围及限制\n\n**本题采用捆绑测试。**\n\n$$\n\\begin{array}{|c|c|c|c|c|c|c|c|c|}\\hline\n\\textbf{subtask} & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8\\cr\\hline\n\\textbf{分值} & 10 & 10 & 10 & 10 & 15 & 15 & 15 & 15\\cr\\hline\n\\end{array}\n$$\n\n对于 $100\\%$ 的数据，保证 $n,m,b,d,P_i\\ge0$，$k\\ge 1$，$1\\le l \\le r$，$maxc\\ge-1$。\n\n你可能会想，这算什么数据范围？怎么没有上界？而且表格里怎么没有 subtask 的特殊限制？实际上，出题人也不知道数据的上界和特殊限制。\n\n由于出题人的误操作，数据生成器源代码意外丢失，只剩下可执行程序。下发文件中提供了在 Windows / Linux / Mac 下编译的可执行程序。不同操作系统下编译的文件名如下：\n\n- 对于 Windows 系统（文件名 genX-w32）：`g++ genX.cpp -o genX -O3 -std=c++14`，在 Windows10，Dev-C++ 5.50，TDM-GCC 4.9.2 32bit 下编译。\n- 对于 Linux/Mac 系统（32 位，文件名 genX-l32）：`g++ genX.cpp -o genX -O3 -std=c++14 -m32`，在 NOI Linux 2.0，GCC 9.3.0 下编译。\n- 对于 Linux/Mac 系统（64 位，文件名 genX-l64）：`g++ genX.cpp -o genX -O3 -std=c++14 -m64`，在 NOI Linux 2.0，GCC 9.3.0 下编译。\n\n数据生成器需要在运行后输入一个 $[1,2^{30})$ 范围内的整数作为随机数种子，它会生成一份输入至 `0.in` 中。出题人无法保证生成的数据范围，但是可以保证：\n\n- 同一个生成器所生成出的数据拥有同一个特殊限制。\n- 所有生成器在 NOI Linux 2.0，处理器 i5-4200m 下运行，所用时间不超过 3s，内存占用不超过 2G。\n- 生成出来的数据只与你输入的种子有关，与当前时间、操作系统等其它可变因素无关。\n- 部分数据生成器会有极小概率生成一个无解数据，但保证 OJ 上的所有数据均有解。\n- 你输入的种子只会当作随机数的种子使用，生成器不会出现特判种子生成干扰数据等行为。\n\n数据中的每个 subtask 分别对应一个数据生成器所生成的数据。编号为 $X$ 的 subtask 对应的生成器是 `genX`。\n\n**注意：由于输入格式中没有要求输入「subtask 编号」，你需要自己判断当前数据所对应的 subtask。且本题的 subtask 为乱序排布，你需要自己判断每个 subtask 的难易程度。**\n\n同时，在下发文件分发有 `checker.cpp`。使用 `g++ checker.cpp -o checker -std=c++14` 将 `checker.cpp` 编译为可执行文件后运行 `./checker <inputfile> <outputfile>`，`checker` 就会给出游戏的输赢情况。其中 `<inputfile>` 为数据生成器生成的 `.in` 文件；`<outputfile>` 中存放你的输出。**本 checker 仅供理解游戏规则使用，和实际使用的 checker 有所不同，且不保证 checker 的时间复杂度正确。**\n", "locale": "zh-CN"}}}
{"pid": "P8122", "type": "P", "difficulty": 5, "samples": [["15 3 42 8", ""]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2021", "交互题", "Special Judge", "BalticOI（波罗的海）"], "title": "[BalticOI 2021] A Difficulty Choice (Day1)", "background": "**本题为交互题。**\n\n感谢交互库与 checker 的提供者 [Hi_chocolate](https://www.luogu.com.cn/user/193198) 为本题做出的巨大贡献。\n\n### 特别提示\n\n**在洛谷提交本题时的一些注意事项（与原题面不同之处请以此处为准）：**\n\n1. 提交时请在程序里加入以下函数声明语句：\n\n```cpp\nextern \"C\" long long skim (int i);\nextern \"C\" void answer (std::vector<int> v);\nextern \"C\" void impossible ();\n```\n\n你实现的 `solve` 函数应为：\n\n```cpp\nextern \"C\" void solve (int N, int K, long long A, int S);\n```\n\n2. 程序开头不用，也不应该包含 `books.h` 头文件。\n3. 仅支持 `C++`（含 `C++`，`C++11`，`C++14`，`C++17`）提交。", "description": "您致力于 AK BalticOI，而 AK BalticOI 的方式就是学习。您走进了一家书店，架子上有 $N$ 本书，编号为 $1$ 到 $N$，第 $i$ 本的难度为 $x_i$。您要从这 $N$ 本书中挑选出 $K$ 本书用来学习，您不希望学到太简单或太难的东西，所以您想要保证这 $K$ 本书的难度之和位于 $[A,2A]$ 的区间内。\n\n可惜的是，您并不知道 $x_i$ 的具体数值，所以您要浏览这些书籍以得知他们的难度。书店老板有洁癖，他不希望您浏览太多的书籍，所以他规定您最多只能浏览 $S$ 本书，然后确定这些书的难度。幸运的是，您被告知这 $N$ 本书按照编号的增加，难度呈单调递增。\n\n请编写一个程序，通过浏览书籍，购买您需要的书籍，或者指出无解。\n\n### 交互格式\n\n本题为交互题，您需要编写 `void solve (int N, int K, long long A, int S)` 函数，$N,K,A,S$ 在上面已经定义，并且保证 $x_1<x_2<\\cdots<x_n$，该函数只被调用一次。\n\n您还可以调用如下的函数：\n\n- `long long skim (int i)` 浏览第 $i$ 本书以获取他的难度 $x_i$。\n- `void answer (vector<int> v)` 买您所需要的书。其中 $v=\\{i_1,i_2,\\cdots,i_K\\}$，并且需要满足：\n$$A \\le \\sum\\limits_{j=1}^K x_{i_j} \\le 2A$$\n- `void impossible ()` 指出不可能按照要求买下 $K$ 本书。\n\n如果存在满足要求的 $K$ 本书，您必须准确地调用 `answer` 函数一次；否则您需要准确地调用 `impossible` 函数一次。调用过后，程序会自动停止。\n\n如果您的函数调用不符合上面的格式，或者调用了超过 $S$ 次 `skim` 函数，程序会自动停止，这个测试点会判为 **Not correct**；你不能在标准输出中输出任何东西，否则会被判为 **Security violation**。\n\n如果您使用 C++ 编码，请调用 `books.h` 头文件，如果您想检验您的程序的正确性，可以在下方附件中下载 `sample_grader.cpp` 与 `books_sample.cpp`，分别为您提供检验正确性和示例说明的作用。\n\n如果您使用 Python 编码，可以在下方附件中下载 `books_sample.py` 检验。\n\n交互库希望标准输入里有两行：\n\n- 第一行四个整数，$N,K,A,S$。\n- 第二行 $N$ 个整数，$x_1,x_2,\\cdots,x_N$。\n\n随后，交互库会调用您的程序，最后，交互库会在标准输出中返回信息：\n\n|信息|意义|\n|:-:|:-:|\n|**Invalid input.**|标准输入的格式错误|\n|**Invalid skim.**|`skim` 函数调用无效|\n|**Out of books to skim.**|`skim` 函数调用超过 $S$ 次|\n|**Invalid answer.**|`answer` 函数调用无效|\n|**Wrong answer.**|`answer` 函数调用的 $v$ 不满足要求|\n|**No answer.**|`solve` 函数没有调用 `answer` 函数和 `impossible` 函数中的任意一个|\n|**Impossible (not checked): s book(s) skimmed.**|上述事件都没有发生，调用了 $S$ 次 `skim` 函数，并在有答案的时候调用了 `impossible` 函数|\n|**Correct: s book(s) skimmed.**|上述事件都没有发生，调用了 $S$ 次 `skim` 函数|\n\n针对上面若干个错误的情况，交互库仅会返回 **Not correct**，或者正确的时候返回 **Correct**。每当出现上面的若干个错误，或者您的程序调用了 `answer` 或 `impossible` 函数时，程序会被自动停止。", "inputFormat": "见「交互格式」。", "outputFormat": "见「交互格式」。", "hint": "#### 样例 1 解释\n\n$N=15$，$K=3$，$A=42$，$S=8$，下面是可能的两种会被判为通过的调用结果：\n\n示例 1：\n\n|你的程序|返回值|\n|:-:|:-:|\n|`skim(1)`|$1337$|\n|`impossible`|-|\n\n示例 2：\n\n|你的程序|返回值|\n|:-:|:-:|\n|`skim(1)`|$7$|\n|`skim(15)`|$21$|\n|`answer({11,15,7})`|-|\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 1（5 pts）：$S=N$，$170 \\le N \\le 1000$，$K=3$。\n- Subtask 2（15 pts）：$S=N$，$N \\ge 170$。\n- Subtask 3（10 pts）：$S \\ge 170$，$x_{i+1}-x_i \\le \\frac A K$。\n- Subtask 4（15 pts）：$S \\ge 170$，$x_{i+1}-x_i \\le A$。\n- Subtask 5（15 pts）：$S \\ge 170$。\n- Subtask 6（20 pts）：$S \\ge 40$，$x_{i+1}-x_i \\le A$。\n- Subtask 7（20 pts）：$S \\ge 40$。\n\n对于 $100\\%$ 的数据，$K \\le N$，$3 \\le N,S \\le 10^5$，$1 \\le A,x_i \\le 10^{17}$，$3 \\le K \\le 10$。\n\n#### 说明\n\n翻译自 [BalticOI 2021 Day1 A A Difficulty Choice](https://boi.cses.fi/files/boi2021_day1.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2021] A Difficulty Choice (Day1)", "background": "**本题为交互题。**\n\n感谢交互库与 checker 的提供者 [Hi_chocolate](https://www.luogu.com.cn/user/193198) 为本题做出的巨大贡献。\n\n### 特别提示\n\n**在洛谷提交本题时的一些注意事项（与原题面不同之处请以此处为准）：**\n\n1. 提交时请在程序里加入以下函数声明语句：\n\n```cpp\nextern \"C\" long long skim (int i);\nextern \"C\" void answer (std::vector<int> v);\nextern \"C\" void impossible ();\n```\n\n你实现的 `solve` 函数应为：\n\n```cpp\nextern \"C\" void solve (int N, int K, long long A, int S);\n```\n\n2. 程序开头不用，也不应该包含 `books.h` 头文件。\n3. 仅支持 `C++`（含 `C++`，`C++11`，`C++14`，`C++17`）提交。", "description": "您致力于 AK BalticOI，而 AK BalticOI 的方式就是学习。您走进了一家书店，架子上有 $N$ 本书，编号为 $1$ 到 $N$，第 $i$ 本的难度为 $x_i$。您要从这 $N$ 本书中挑选出 $K$ 本书用来学习，您不希望学到太简单或太难的东西，所以您想要保证这 $K$ 本书的难度之和位于 $[A,2A]$ 的区间内。\n\n可惜的是，您并不知道 $x_i$ 的具体数值，所以您要浏览这些书籍以得知他们的难度。书店老板有洁癖，他不希望您浏览太多的书籍，所以他规定您最多只能浏览 $S$ 本书，然后确定这些书的难度。幸运的是，您被告知这 $N$ 本书按照编号的增加，难度呈单调递增。\n\n请编写一个程序，通过浏览书籍，购买您需要的书籍，或者指出无解。\n\n### 交互格式\n\n本题为交互题，您需要编写 `void solve (int N, int K, long long A, int S)` 函数，$N,K,A,S$ 在上面已经定义，并且保证 $x_1<x_2<\\cdots<x_n$，该函数只被调用一次。\n\n您还可以调用如下的函数：\n\n- `long long skim (int i)` 浏览第 $i$ 本书以获取他的难度 $x_i$。\n- `void answer (vector<int> v)` 买您所需要的书。其中 $v=\\{i_1,i_2,\\cdots,i_K\\}$，并且需要满足：\n$$A \\le \\sum\\limits_{j=1}^K x_{i_j} \\le 2A$$\n- `void impossible ()` 指出不可能按照要求买下 $K$ 本书。\n\n如果存在满足要求的 $K$ 本书，您必须准确地调用 `answer` 函数一次；否则您需要准确地调用 `impossible` 函数一次。调用过后，程序会自动停止。\n\n如果您的函数调用不符合上面的格式，或者调用了超过 $S$ 次 `skim` 函数，程序会自动停止，这个测试点会判为 **Not correct**；你不能在标准输出中输出任何东西，否则会被判为 **Security violation**。\n\n如果您使用 C++ 编码，请调用 `books.h` 头文件，如果您想检验您的程序的正确性，可以在下方附件中下载 `sample_grader.cpp` 与 `books_sample.cpp`，分别为您提供检验正确性和示例说明的作用。\n\n如果您使用 Python 编码，可以在下方附件中下载 `books_sample.py` 检验。\n\n交互库希望标准输入里有两行：\n\n- 第一行四个整数，$N,K,A,S$。\n- 第二行 $N$ 个整数，$x_1,x_2,\\cdots,x_N$。\n\n随后，交互库会调用您的程序，最后，交互库会在标准输出中返回信息：\n\n|信息|意义|\n|:-:|:-:|\n|**Invalid input.**|标准输入的格式错误|\n|**Invalid skim.**|`skim` 函数调用无效|\n|**Out of books to skim.**|`skim` 函数调用超过 $S$ 次|\n|**Invalid answer.**|`answer` 函数调用无效|\n|**Wrong answer.**|`answer` 函数调用的 $v$ 不满足要求|\n|**No answer.**|`solve` 函数没有调用 `answer` 函数和 `impossible` 函数中的任意一个|\n|**Impossible (not checked): s book(s) skimmed.**|上述事件都没有发生，调用了 $S$ 次 `skim` 函数，并在有答案的时候调用了 `impossible` 函数|\n|**Correct: s book(s) skimmed.**|上述事件都没有发生，调用了 $S$ 次 `skim` 函数|\n\n针对上面若干个错误的情况，交互库仅会返回 **Not correct**，或者正确的时候返回 **Correct**。每当出现上面的若干个错误，或者您的程序调用了 `answer` 或 `impossible` 函数时，程序会被自动停止。", "inputFormat": "见「交互格式」。", "outputFormat": "见「交互格式」。", "hint": "#### 样例 1 解释\n\n$N=15$，$K=3$，$A=42$，$S=8$，下面是可能的两种会被判为通过的调用结果：\n\n示例 1：\n\n|你的程序|返回值|\n|:-:|:-:|\n|`skim(1)`|$1337$|\n|`impossible`|-|\n\n示例 2：\n\n|你的程序|返回值|\n|:-:|:-:|\n|`skim(1)`|$7$|\n|`skim(15)`|$21$|\n|`answer({11,15,7})`|-|\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 1（5 pts）：$S=N$，$170 \\le N \\le 1000$，$K=3$。\n- Subtask 2（15 pts）：$S=N$，$N \\ge 170$。\n- Subtask 3（10 pts）：$S \\ge 170$，$x_{i+1}-x_i \\le \\frac A K$。\n- Subtask 4（15 pts）：$S \\ge 170$，$x_{i+1}-x_i \\le A$。\n- Subtask 5（15 pts）：$S \\ge 170$。\n- Subtask 6（20 pts）：$S \\ge 40$，$x_{i+1}-x_i \\le A$。\n- Subtask 7（20 pts）：$S \\ge 40$。\n\n对于 $100\\%$ 的数据，$K \\le N$，$3 \\le N,S \\le 10^5$，$1 \\le A,x_i \\le 10^{17}$，$3 \\le K \\le 10$。\n\n#### 说明\n\n翻译自 [BalticOI 2021 Day1 A A Difficulty Choice](https://boi.cses.fi/files/boi2021_day1.pdf)。", "locale": "zh-CN"}}}
{"pid": "P8123", "type": "P", "difficulty": 6, "samples": [["6 9\nS 1 2\nS 1 3\nS 3 4\nQ 5 1\nS 4 5\nS 1 6\nQ 5 1\nQ 1 5\nC 1\nC 2\nC 3\nC 4\nC 5\nC 6", "no\nyes\nno\n6\n6\n5\n3\n2\n2"], ["4 4\nS 1 2\nS 1 3\nS 3 4\nQ 2 1\nQ 2 2\nQ 2 3\nQ 2 4", "yes\nyes\nno\nno"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["点分治", "2021", "可持久化线段树", "分块", "BalticOI（波罗的海）", "线段树合并"], "title": "[BalticOI 2021] Inside information (Day1)", "background": "", "description": "有 $N$ 个服务器，第 $i$ 个服务器存储着第 $i$ 块数据，现在有若干种操作：\n\n- `S a b` 第 $a$ 个服务器与第 $b$ 个服务器共享数据，即这两个服务器同时拥有这两个服务器本身拥有的数据块的和，并自动去重（可以理解为数据块之并）。\n- `Q a d` 查询第 $a$ 个服务器是否拥有第 $d$ 块数据。\n- `C a` 查询存储数据块 $a$ 的服务器数量。\n\nS 操作有 $N-1$ 次，如果把共享看做连边，那么最后将形成以 $N$ 个服务器为点的一棵树；Q 操作和 C 操作一共有 $K$ 次。\n\n求对于每个 Q 操作和 C 操作返回的结果。", "inputFormat": "第一行两个整数 $N,K$ 代表服务器个数和操作个数。\n\n接下来 $N+K-1$ 行每行代表一个操作。", "outputFormat": "$K$ 行：\n\n- 对于 Q 操作，输出 `yes` 或 `no` 代表是否拥有第 $d$ 块数据；\n- 对于 C 操作，输出一个整数代表服务器数量。", "hint": "#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 1（5 pts）：$N \\le 4000$。\n- Subtask 2（5 pts）：第 $1$ 个服务器与第 $2,3,\\cdots,N$ 个服务器共享数据。\n- Subtask 3（10 pts）：如果 $|A-B|=1$，那么第 $A$ 个服务器和第 $B$ 个服务器共享数据。\n- Subtask 4（20 pts）：如果 $A<B$ 且 $2A=B$ 或 $2A+1=B$，那么第 $A$ 个服务器和第 $B$ 个服务器共享数据。\n- Subtask 5（25 pts）：每个服务器最多与 $5$ 个服务器共享数据。\n- Subtask 6（35 pts）：无特殊限制。\n\n对于 $100\\%$  的数据，$1 \\le N,K \\le 1.2 \\times 10^5$。\n\n#### 说明\n\n翻译自 [BalticOI 2021 Day1 B Inside information](https://boi.cses.fi/files/boi2021_day1.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2021] Inside information (Day1)", "background": "", "description": "有 $N$ 个服务器，第 $i$ 个服务器存储着第 $i$ 块数据，现在有若干种操作：\n\n- `S a b` 第 $a$ 个服务器与第 $b$ 个服务器共享数据，即这两个服务器同时拥有这两个服务器本身拥有的数据块的和，并自动去重（可以理解为数据块之并）。\n- `Q a d` 查询第 $a$ 个服务器是否拥有第 $d$ 块数据。\n- `C a` 查询存储数据块 $a$ 的服务器数量。\n\nS 操作有 $N-1$ 次，如果把共享看做连边，那么最后将形成以 $N$ 个服务器为点的一棵树；Q 操作和 C 操作一共有 $K$ 次。\n\n求对于每个 Q 操作和 C 操作返回的结果。", "inputFormat": "第一行两个整数 $N,K$ 代表服务器个数和操作个数。\n\n接下来 $N+K-1$ 行每行代表一个操作。", "outputFormat": "$K$ 行：\n\n- 对于 Q 操作，输出 `yes` 或 `no` 代表是否拥有第 $d$ 块数据；\n- 对于 C 操作，输出一个整数代表服务器数量。", "hint": "#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 1（5 pts）：$N \\le 4000$。\n- Subtask 2（5 pts）：第 $1$ 个服务器与第 $2,3,\\cdots,N$ 个服务器共享数据。\n- Subtask 3（10 pts）：如果 $|A-B|=1$，那么第 $A$ 个服务器和第 $B$ 个服务器共享数据。\n- Subtask 4（20 pts）：如果 $A<B$ 且 $2A=B$ 或 $2A+1=B$，那么第 $A$ 个服务器和第 $B$ 个服务器共享数据。\n- Subtask 5（25 pts）：每个服务器最多与 $5$ 个服务器共享数据。\n- Subtask 6（35 pts）：无特殊限制。\n\n对于 $100\\%$  的数据，$1 \\le N,K \\le 1.2 \\times 10^5$。\n\n#### 说明\n\n翻译自 [BalticOI 2021 Day1 B Inside information](https://boi.cses.fi/files/boi2021_day1.pdf)。", "locale": "zh-CN"}}}
{"pid": "P8124", "type": "P", "difficulty": 7, "samples": [["6 6\n1 2\n2 3\n3 4\n4 5\n5 2\n5 6\n1\n4 3 2 5 4", "4"], ["6 6\n1 2\n2 3\n3 4\n4 5\n5 2\n5 6\n1\n4 4 5 2 3", "5"], ["11 13\n1 2\n2 3\n3 4\n4 2\n3 5\n5 6\n6 7\n7 5\n6 8\n8 9\n9 10\n10 8\n9 11\n3\n3 4 2 3\n3 7 6 5\n3 10 8 9", "impossible"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "BalticOI（波罗的海）"], "title": "[BalticOI 2021] From Hacks to Snitches (Day1)", "background": "", "description": "给定一个 $N$ 个点 $M$ 条边的无向图，有 $K$ 个守卫第 $i$ 个守卫会经过 $\\ell_i$ 个节点，这 $\\ell_i$ 个节点分别为 $v_1,v_2,\\cdots,v_{\\ell_i}$，运行机制为守卫刚开始位于第 $v_1$ 个节点，设其为第 $0$ 分钟，$1$ 分钟时从第 $v_1$ 个节点走到第 $v_2$ 个节点，$2$ 分钟时从第 $v_2$ 个节点走到第 $v_3$ 个节点，……，$\\ell_i-1$ 分钟时从第 $v_{\\ell_i-1}$ 个节点走到第 $v_{\\ell_i}$ 个节点，$\\ell_i$ 分钟时从第 $v_{\\ell_i}$ 个节点走到第 $v_1$ 个节点，以此类推，无限循环。\n\n您是一个小偷，您要从第 $1$ 个节点到达第 $N$ 个节点，即 $0$ 分钟时您位于 $1$ 号节点，您可以一个节点直接到另一个节点，但是要经过这两个节点之间的路径，您要保证这条路径上没有一个节点上有守卫，且守卫也不经过这些组成路径的边。您经过每一条边的时间都是一分钟。保证任意两个守卫的路径不相交，并且起点和终点均不在任意守卫的路径上。\n\n您想知道不被守卫发现的情况下需要最短多少分钟或者提出无解。", "inputFormat": "第一行两个整数 $N,M$ 代表点数和边数。\n\n接下来 $M$ 行每行两个整数 $u,v$ 代表一条边。\n\n第 $M+2$ 行一个整数 $K$ 代表守卫个数。\n\n接下来 $K$ 行首先一个整数 $\\ell_i$ 代表守卫的路径长度，接下来 $\\ell_i$ 个整数 $v_1,v_2,\\cdots,v_{\\ell_i}$ 描述路径。", "outputFormat": "一行一个整数代表最少需要多少分钟或者无解时输出 `impossible`。", "hint": "#### 样例 1 解释\n\n第 $1$ 个守卫的路径如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0p8adii9.png)\n\n一种可行方式是：\n\n- $0$ 分钟时，开始在节点 $1$；\n- $1$ 分钟时，在节点 $1$ 等待；\n- $2$ 分钟时，移动到节点 $2$；\n- $3$ 分钟时，移动到节点 $5$；\n- $4$ 分钟时，移动到节点 $6$。\n\n#### 样例 2 解释\n\n图和路径与样例 1 一样，只是起点和终点不同。\n\n一种可行方式是，没有等待，直接按照 $1 \\to 2 \\to 3 \\to 4 \\to 5 \\to 6$ 走。\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 1（5 pts）：$N,M \\le 10^5$，$K=1$，$ ℓ_1 \\le 125$。\n- Subtask 2（10 pts）：$N,M \\le 10^5$，$\\sum  ℓ_i \\le 125$，满足性质 A。\n- Subtask 3（10 pts）：$ ℓ_i \\le 200$，$\\sum  ℓ_i \\le 350$，满足性质 A。\n- Subtask 4（10 pts）：满足性质 A。\n- Subtask 5（25 pts）：$\\sum  ℓ_i \\le 125$。\n- Subtask 6（20 pts）：$ ℓ_i \\le 200$，$\\sum  ℓ_i \\le 350$。\n- Subtask 7（20 pts）：无特殊限制。\n- Subtask Ex（0 pts）：Extra Subtask。\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 2.5 \\times 10^5$，$1 \\le M \\le 3 \\times 10^6$，$3 \\le  ℓ_i \\le 1500$，$\\sum  ℓ_i \\le 2750$。\n\n性质 A 为没有一条边连接任意两个守卫的路径。\n\n#### 说明\n\n翻译自 [BalticOI 2021 Day1 C From Hacks to Snitches](https://boi.cses.fi/files/boi2021_day1.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2021] From Hacks to Snitches (Day1)", "background": "", "description": "给定一个 $N$ 个点 $M$ 条边的无向图，有 $K$ 个守卫第 $i$ 个守卫会经过 $\\ell_i$ 个节点，这 $\\ell_i$ 个节点分别为 $v_1,v_2,\\cdots,v_{\\ell_i}$，运行机制为守卫刚开始位于第 $v_1$ 个节点，设其为第 $0$ 分钟，$1$ 分钟时从第 $v_1$ 个节点走到第 $v_2$ 个节点，$2$ 分钟时从第 $v_2$ 个节点走到第 $v_3$ 个节点，……，$\\ell_i-1$ 分钟时从第 $v_{\\ell_i-1}$ 个节点走到第 $v_{\\ell_i}$ 个节点，$\\ell_i$ 分钟时从第 $v_{\\ell_i}$ 个节点走到第 $v_1$ 个节点，以此类推，无限循环。\n\n您是一个小偷，您要从第 $1$ 个节点到达第 $N$ 个节点，即 $0$ 分钟时您位于 $1$ 号节点，您可以一个节点直接到另一个节点，但是要经过这两个节点之间的路径，您要保证这条路径上没有一个节点上有守卫，且守卫也不经过这些组成路径的边。您经过每一条边的时间都是一分钟。保证任意两个守卫的路径不相交，并且起点和终点均不在任意守卫的路径上。\n\n您想知道不被守卫发现的情况下需要最短多少分钟或者提出无解。", "inputFormat": "第一行两个整数 $N,M$ 代表点数和边数。\n\n接下来 $M$ 行每行两个整数 $u,v$ 代表一条边。\n\n第 $M+2$ 行一个整数 $K$ 代表守卫个数。\n\n接下来 $K$ 行首先一个整数 $\\ell_i$ 代表守卫的路径长度，接下来 $\\ell_i$ 个整数 $v_1,v_2,\\cdots,v_{\\ell_i}$ 描述路径。", "outputFormat": "一行一个整数代表最少需要多少分钟或者无解时输出 `impossible`。", "hint": "#### 样例 1 解释\n\n第 $1$ 个守卫的路径如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0p8adii9.png)\n\n一种可行方式是：\n\n- $0$ 分钟时，开始在节点 $1$；\n- $1$ 分钟时，在节点 $1$ 等待；\n- $2$ 分钟时，移动到节点 $2$；\n- $3$ 分钟时，移动到节点 $5$；\n- $4$ 分钟时，移动到节点 $6$。\n\n#### 样例 2 解释\n\n图和路径与样例 1 一样，只是起点和终点不同。\n\n一种可行方式是，没有等待，直接按照 $1 \\to 2 \\to 3 \\to 4 \\to 5 \\to 6$ 走。\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 1（5 pts）：$N,M \\le 10^5$，$K=1$，$ ℓ_1 \\le 125$。\n- Subtask 2（10 pts）：$N,M \\le 10^5$，$\\sum  ℓ_i \\le 125$，满足性质 A。\n- Subtask 3（10 pts）：$ ℓ_i \\le 200$，$\\sum  ℓ_i \\le 350$，满足性质 A。\n- Subtask 4（10 pts）：满足性质 A。\n- Subtask 5（25 pts）：$\\sum  ℓ_i \\le 125$。\n- Subtask 6（20 pts）：$ ℓ_i \\le 200$，$\\sum  ℓ_i \\le 350$。\n- Subtask 7（20 pts）：无特殊限制。\n- Subtask Ex（0 pts）：Extra Subtask。\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 2.5 \\times 10^5$，$1 \\le M \\le 3 \\times 10^6$，$3 \\le  ℓ_i \\le 1500$，$\\sum  ℓ_i \\le 2750$。\n\n性质 A 为没有一条边连接任意两个守卫的路径。\n\n#### 说明\n\n翻译自 [BalticOI 2021 Day1 C From Hacks to Snitches](https://boi.cses.fi/files/boi2021_day1.pdf)。", "locale": "zh-CN"}}}
{"pid": "P8125", "type": "P", "difficulty": 6, "samples": [["5 1 42\n13 37 47 11 42", "4"], ["5 2 5\n1 9 4 6 7", "2"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "BalticOI（波罗的海）"], "title": "[BalticOI 2021] The short shank (Day2)", "background": null, "description": "你入狱了，你现在正在洛谷第一监狱里。\n\n监狱共有 $N$ 个牢房，从左到右编号为 $1 \\sim N$。你和你的狱友们准备策划一场造反，第 $i$ 个牢房里的罪犯准备在第 $t_i$ 个时刻点造反，如果第 $i$ 个牢房的罪犯造反后，第 $i+1$ 个牢房的罪犯会无视他在第 $t_{i+1}$ 个时间点造反的规矩，在第 $t'_i+1$ 个时间点就会造反，其中 $t'_i$ 是第 $i$ 个牢房的罪犯实际造反的时刻。\n\n狱警提前预知了一切，所以他们会放置 $D$ 个床垫，如果在第 $i$ 个牢房和第 $i+1$ 个牢房中间放置一个床垫，那么当第 $i$ 个牢房的罪犯造反时，第 $i+1$ 个牢房的罪犯不会立即造反，而会等到第 $t_{i+1}$ 个时间点。\n\n你想知道，狱警合理安排床垫后，在第 $T$ 个时间点及以前最少会有多少个罪犯造反。", "inputFormat": "第一行三个整数 $N,D,T$ 代表罪犯个数，床垫个数和希望的时间点。\n\n第二行 $N$ 个整数 $t_i$ 代表第 $i$ 个罪犯造反的时间点。", "outputFormat": "一行一个整数代表答案。", "hint": "#### 样例 1 解释\n\n最优解是在第 $2$ 个牢房和第 $3$ 个牢房之间放入床垫，造反的是第 $1,2,4,5$ 个牢房里的罪犯。\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 1（15 pts）：$N \\le 500$。\n- Subtask 2（10 pts）：$N \\le 5 \\times 10^5$，$D=1$。\n- Subtask 3（20 pts）：$N \\le 4000$。\n- Subtask 4（10 pts）：$N \\le 7.5 \\times 10^4$，$D \\le 15$。\n- Subtask 5（25 pts）：$N \\le 7.5 \\times 10^4$。\n- Subtask 6（20 pts）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1 \\le D<N \\le 2 \\times 10^6$，$1 \\le T,t_i \\le 10^9$。\n\n另有 Subtask 0 为样例。\n\n#### 说明\n\n翻译自 [BalticOI 2021 Day2 A The short shank](https://boi.cses.fi/files/boi2021_day2.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2021] The short shank (Day2)", "background": null, "description": "你入狱了，你现在正在洛谷第一监狱里。\n\n监狱共有 $N$ 个牢房，从左到右编号为 $1 \\sim N$。你和你的狱友们准备策划一场造反，第 $i$ 个牢房里的罪犯准备在第 $t_i$ 个时刻点造反，如果第 $i$ 个牢房的罪犯造反后，第 $i+1$ 个牢房的罪犯会无视他在第 $t_{i+1}$ 个时间点造反的规矩，在第 $t'_i+1$ 个时间点就会造反，其中 $t'_i$ 是第 $i$ 个牢房的罪犯实际造反的时刻。\n\n狱警提前预知了一切，所以他们会放置 $D$ 个床垫，如果在第 $i$ 个牢房和第 $i+1$ 个牢房中间放置一个床垫，那么当第 $i$ 个牢房的罪犯造反时，第 $i+1$ 个牢房的罪犯不会立即造反，而会等到第 $t_{i+1}$ 个时间点。\n\n你想知道，狱警合理安排床垫后，在第 $T$ 个时间点及以前最少会有多少个罪犯造反。", "inputFormat": "第一行三个整数 $N,D,T$ 代表罪犯个数，床垫个数和希望的时间点。\n\n第二行 $N$ 个整数 $t_i$ 代表第 $i$ 个罪犯造反的时间点。", "outputFormat": "一行一个整数代表答案。", "hint": "#### 样例 1 解释\n\n最优解是在第 $2$ 个牢房和第 $3$ 个牢房之间放入床垫，造反的是第 $1,2,4,5$ 个牢房里的罪犯。\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 1（15 pts）：$N \\le 500$。\n- Subtask 2（10 pts）：$N \\le 5 \\times 10^5$，$D=1$。\n- Subtask 3（20 pts）：$N \\le 4000$。\n- Subtask 4（10 pts）：$N \\le 7.5 \\times 10^4$，$D \\le 15$。\n- Subtask 5（25 pts）：$N \\le 7.5 \\times 10^4$。\n- Subtask 6（20 pts）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1 \\le D<N \\le 2 \\times 10^6$，$1 \\le T,t_i \\le 10^9$。\n\n另有 Subtask 0 为样例。\n\n#### 说明\n\n翻译自 [BalticOI 2021 Day2 A The short shank](https://boi.cses.fi/files/boi2021_day2.pdf)。", "locale": "zh-CN"}}}
{"pid": "P8126", "type": "P", "difficulty": 6, "samples": [["4 50", ""]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "交互题", "Special Judge", "BalticOI（波罗的海）"], "title": "[BalticOI 2021] The Collection Game (Day2)", "background": "**本题是交互题。**\n\n你的代码不需要也不应该包含 `swaps.h` 头文件，但应包含以下声明：\n\n```cpp\nextern \"C\" void schedule(int i, int j);\nextern \"C\" std::vector<int> visit();\nextern \"C\" void answer(std::vector<int> r);\nextern \"C\" void solve(int N, int Q) {\n  // Code Here\n}\n```", "description": "您要参观博物馆的 $N$ 个展馆，因为您之前有入狱史（BalticOI 2021 Day2 A），所以博物馆官方仅允许您参观小于等于 $V$ 次。每一次参观您可以浏览多次，每一次浏览您可以浏览 **一对** 展馆 $(i,j)$，然后您就可以得知这两个展馆哪个展馆的艺术价值最高。为了不浪费您的时间，每一次参观每个展馆只能浏览最多一次。\n\n不幸的是，因为您的入狱史，博物馆 **可能** 会交换您要浏览的一对展馆里的展品，这样您得到的艺术价值关系就是反过来的，您最后对这 $N$ 个展馆中的其中一个的排名也应基于 **最后一次** 对这个展馆的浏览。\n\n现在请通过浏览来确定这 $N$ 个展馆的艺术价值的排列。\n\n### 交互格式\n\n您需要实现函数 `void solve (int N, int V)`，其中 $N $ 和 $V$ 为展馆数量和最多参观次数。\n\n`solve` 函数只被调用一次，并且可以在 `solve` 函数里面调用：\n\n- `void schedule (int i, int j)` 浏览一对展馆 $(i,j)$，博物馆有可能交换展品。\n- `vector <int> visit ()` 整理浏览结果，返回的序列按照浏览的展馆对数 $(i,j)$ 顺序返回若干个 $k$，如果第 $i$ 个展馆的艺术价值高于第 $j$ 个展馆，$k=1$，否则 $k=0$。\n- `void answer (vector <int> r)` $r$ 是一个长度为 $N$ 的序列，并且是一个 $1 \\sim N$ 的排列，$r_i=p$ 代表第 $i$ 个展馆在这 $N$ 个展馆的艺术价值排序中排第 $p$ 个。\n\n如果您函数的调用不满足要求，一次参观一个展馆浏览了超过 $1$ 次，或者参观了超过 $V$ 次，您的程序都会立即停止然后判为 `Not correct`。请不要在标准输出中输出任何东西，否则会被判为 `Security violation!`。\n\n如果您使用 C++ 编码，请调用 swaps.h 头文件，如果您想检验您的程序的正确性，可以在下方附件中下载 sample_grader.cpp 与 swaps_sample.cpp，分别为您提供检验正确性和示例说明的作用。\n\n如果您使用 Python 编码，可以在下方附件中下载 swaps_sample.py 检验。\n\n交互库希望标准输入里有一行：\n\n- 一行两个整数 $N,V$。\n\n随后，交互库会调用您的程序，最后，交互库会在标准输出中返回信息：\n\n|信息|意义|\n|:-:|:-:|\n|**Invalid input.**|标准输入的格式错误|\n|**Invalid schedule.**|`schedule` 函数调用无效|\n|**Out of visits.**|`visit` 函数调用超过 $V$ 次|\n|**Invalid answer.**|`answer` 函数调用无效|\n|**Wrong answer.**|`answer` 函数调用的 $r$ 错误|\n|**No answer.**|`solve` 函数没有调用 `answer` 函数|\n|**Correct: v visit(s) used.**|上述事件都没有发生，调用了 $V$ 次 `visit` 函数|\n\n针对上面若干个错误的情况，交互库仅会返回 **Not correct**，或者正确的时候返回 **Correct**。每当出现上面的若干个错误，或者您的程序调用了 `answer` 函数时，程序会被自动停止。", "inputFormat": "见「交互格式」。", "outputFormat": "见「交互格式」。", "hint": "#### 样例 1 解释\n\n$N=4$，$V=50$，下面是一种合法的调用：\n\n|你的程序|返回值|博物馆是否交换\n|:-:|:-:|:-:|\n|`schedule(1,2)`|-|否|\n|`schedule(3,4)`|-|是|\n|`visit()`|`{1,0}`|-|\n|`schedule(2,4)`|-|否|\n|`visit()`|`{1}`|-|\n|`answer({1,2,4,3})`|-|-|\n\n对于上表，$r=\\{2,1,4,3\\}$ 也满足要求。如果第三次 `visit` 交换了，那么 $r=\\{4,1,2,3\\}$ 满足要求。\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 1（5 pts）：$V=5000$，博物馆永远不会交换展品。\n- Subtask 2（10 pts）：$V \\ge 1000$，博物馆永远不会交换展品。\n- Subtask 3（5 pts）：$N \\le 100$，$V=5000$。\n- Subtask 4（15 pts）：$V=5000$。\n- Subtask 5（15 pts）：$V\\ge 500$。\n- Subtask 6（35 pts）：$V \\ge 100$。\n- Subtask 7（15 pts）：$V \\ge 50$。\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 500$，$50 \\le V \\le 5000$。\n\n#### 说明\n\n翻译自 [BalticOI 2021 Day2 B The Collection Game](https://boi.cses.fi/files/boi2021_day2.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2021] The Collection Game (Day2)", "background": "**本题是交互题。**\n\n你的代码不需要也不应该包含 `swaps.h` 头文件，但应包含以下声明：\n\n```cpp\nextern \"C\" void schedule(int i, int j);\nextern \"C\" std::vector<int> visit();\nextern \"C\" void answer(std::vector<int> r);\nextern \"C\" void solve(int N, int Q) {\n  // Code Here\n}\n```", "description": "您要参观博物馆的 $N$ 个展馆，因为您之前有入狱史（BalticOI 2021 Day2 A），所以博物馆官方仅允许您参观小于等于 $V$ 次。每一次参观您可以浏览多次，每一次浏览您可以浏览 **一对** 展馆 $(i,j)$，然后您就可以得知这两个展馆哪个展馆的艺术价值最高。为了不浪费您的时间，每一次参观每个展馆只能浏览最多一次。\n\n不幸的是，因为您的入狱史，博物馆 **可能** 会交换您要浏览的一对展馆里的展品，这样您得到的艺术价值关系就是反过来的，您最后对这 $N$ 个展馆中的其中一个的排名也应基于 **最后一次** 对这个展馆的浏览。\n\n现在请通过浏览来确定这 $N$ 个展馆的艺术价值的排列。\n\n### 交互格式\n\n您需要实现函数 `void solve (int N, int V)`，其中 $N $ 和 $V$ 为展馆数量和最多参观次数。\n\n`solve` 函数只被调用一次，并且可以在 `solve` 函数里面调用：\n\n- `void schedule (int i, int j)` 浏览一对展馆 $(i,j)$，博物馆有可能交换展品。\n- `vector <int> visit ()` 整理浏览结果，返回的序列按照浏览的展馆对数 $(i,j)$ 顺序返回若干个 $k$，如果第 $i$ 个展馆的艺术价值高于第 $j$ 个展馆，$k=1$，否则 $k=0$。\n- `void answer (vector <int> r)` $r$ 是一个长度为 $N$ 的序列，并且是一个 $1 \\sim N$ 的排列，$r_i=p$ 代表第 $i$ 个展馆在这 $N$ 个展馆的艺术价值排序中排第 $p$ 个。\n\n如果您函数的调用不满足要求，一次参观一个展馆浏览了超过 $1$ 次，或者参观了超过 $V$ 次，您的程序都会立即停止然后判为 `Not correct`。请不要在标准输出中输出任何东西，否则会被判为 `Security violation!`。\n\n如果您使用 C++ 编码，请调用 swaps.h 头文件，如果您想检验您的程序的正确性，可以在下方附件中下载 sample_grader.cpp 与 swaps_sample.cpp，分别为您提供检验正确性和示例说明的作用。\n\n如果您使用 Python 编码，可以在下方附件中下载 swaps_sample.py 检验。\n\n交互库希望标准输入里有一行：\n\n- 一行两个整数 $N,V$。\n\n随后，交互库会调用您的程序，最后，交互库会在标准输出中返回信息：\n\n|信息|意义|\n|:-:|:-:|\n|**Invalid input.**|标准输入的格式错误|\n|**Invalid schedule.**|`schedule` 函数调用无效|\n|**Out of visits.**|`visit` 函数调用超过 $V$ 次|\n|**Invalid answer.**|`answer` 函数调用无效|\n|**Wrong answer.**|`answer` 函数调用的 $r$ 错误|\n|**No answer.**|`solve` 函数没有调用 `answer` 函数|\n|**Correct: v visit(s) used.**|上述事件都没有发生，调用了 $V$ 次 `visit` 函数|\n\n针对上面若干个错误的情况，交互库仅会返回 **Not correct**，或者正确的时候返回 **Correct**。每当出现上面的若干个错误，或者您的程序调用了 `answer` 函数时，程序会被自动停止。", "inputFormat": "见「交互格式」。", "outputFormat": "见「交互格式」。", "hint": "#### 样例 1 解释\n\n$N=4$，$V=50$，下面是一种合法的调用：\n\n|你的程序|返回值|博物馆是否交换\n|:-:|:-:|:-:|\n|`schedule(1,2)`|-|否|\n|`schedule(3,4)`|-|是|\n|`visit()`|`{1,0}`|-|\n|`schedule(2,4)`|-|否|\n|`visit()`|`{1}`|-|\n|`answer({1,2,4,3})`|-|-|\n\n对于上表，$r=\\{2,1,4,3\\}$ 也满足要求。如果第三次 `visit` 交换了，那么 $r=\\{4,1,2,3\\}$ 满足要求。\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 1（5 pts）：$V=5000$，博物馆永远不会交换展品。\n- Subtask 2（10 pts）：$V \\ge 1000$，博物馆永远不会交换展品。\n- Subtask 3（5 pts）：$N \\le 100$，$V=5000$。\n- Subtask 4（15 pts）：$V=5000$。\n- Subtask 5（15 pts）：$V\\ge 500$。\n- Subtask 6（35 pts）：$V \\ge 100$。\n- Subtask 7（15 pts）：$V \\ge 50$。\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 500$，$50 \\le V \\le 5000$。\n\n#### 说明\n\n翻译自 [BalticOI 2021 Day2 B The Collection Game](https://boi.cses.fi/files/boi2021_day2.pdf)。", "locale": "zh-CN"}}}
{"pid": "P8127", "type": "P", "difficulty": 5, "samples": [["5\n1 2\n1 3\n2 4\n2 5\n0 1 0 1 1", "4"], ["5\n1 2\n2 3\n3 4\n4 5\n0 1 1 1 1", "impossible"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2021", "树形 DP", "BalticOI（波罗的海）"], "title": "[BalticOI 2021] The Xana coup (Day2)", "background": "", "description": "给定一棵点数为 $N$ 个树，第 $i$ 个点有点权 $a_i$，$a_i \\in \\{0,1\\}$。\n\n你可以进行切换操作：\n\n- 对点 $i$ 进行切换操作会使得点 $i$ 及与其 **直接相连** 的点的点权取反。\n\n其中直接相连指两点之间恰好只有一条边。\n\n求至少需要多少次切换操作才能使得所有点的点权变为 $0$。", "inputFormat": "第一行一个整数 $N$ 代表树的点数。\n\n接下来 $N-1$ 行每行两个整数代表树的一条边。\n\n第 $N+1$ 行 $N$ 个整数 $a_i$ 代表第 $i$ 个点的点权。", "outputFormat": "如果有解，一行一个整数代表答案。\n\n如果无解，输出 `impossible`。", "hint": "#### 样例 1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qyej3711.png)\n\n$a_i=0$ 为黑色，$a_i=1$ 为白色。\n\n可以对点 $4,5,3,1$ 进行切换操作使得所有点的点权为 $0$。\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 1（5 pts）：$N \\le 20$。\n- Subtask 2（15 pts）：$N \\le 40$。\n- Subtask 3（10 pts）：如果点 $u$ 和点 $v$ 满足 $|u-v|=1$，那么他们有边相连。\n- Subtask 4（40 pts）：一个点最多与 $3$ 个点相连。\n- Subtask 5（30 pts）：无特殊限制。\n\n对于 $100\\%$ 的数据，$3 \\le N \\le 10^5$。\n\n#### 说明\n\n翻译自 [BalticOI 2021 Day2 C The Xana coup](https://boi.cses.fi/files/boi2021_day2.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2021] The Xana coup (Day2)", "background": "", "description": "给定一棵点数为 $N$ 个树，第 $i$ 个点有点权 $a_i$，$a_i \\in \\{0,1\\}$。\n\n你可以进行切换操作：\n\n- 对点 $i$ 进行切换操作会使得点 $i$ 及与其 **直接相连** 的点的点权取反。\n\n其中直接相连指两点之间恰好只有一条边。\n\n求至少需要多少次切换操作才能使得所有点的点权变为 $0$。", "inputFormat": "第一行一个整数 $N$ 代表树的点数。\n\n接下来 $N-1$ 行每行两个整数代表树的一条边。\n\n第 $N+1$ 行 $N$ 个整数 $a_i$ 代表第 $i$ 个点的点权。", "outputFormat": "如果有解，一行一个整数代表答案。\n\n如果无解，输出 `impossible`。", "hint": "#### 样例 1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qyej3711.png)\n\n$a_i=0$ 为黑色，$a_i=1$ 为白色。\n\n可以对点 $4,5,3,1$ 进行切换操作使得所有点的点权为 $0$。\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 1（5 pts）：$N \\le 20$。\n- Subtask 2（15 pts）：$N \\le 40$。\n- Subtask 3（10 pts）：如果点 $u$ 和点 $v$ 满足 $|u-v|=1$，那么他们有边相连。\n- Subtask 4（40 pts）：一个点最多与 $3$ 个点相连。\n- Subtask 5（30 pts）：无特殊限制。\n\n对于 $100\\%$ 的数据，$3 \\le N \\le 10^5$。\n\n#### 说明\n\n翻译自 [BalticOI 2021 Day2 C The Xana coup](https://boi.cses.fi/files/boi2021_day2.pdf)。", "locale": "zh-CN"}}}
{"pid": "P8128", "type": "P", "difficulty": 0, "samples": [["7 3", "2 4 2 3"], ["8 3\n", "1 1 1 3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "O2优化", "ICPC", "WF"], "title": "[ICPC 2020 WF] Cardiology", "background": "ICPC2020 WF A", "description": "The Great Cardoni, Master Prestidigitator, has a deck of 21 numbered cards which he uses in a\ntrick as follows:\n\n> A spectator secretly selects a number between $1$ and $21$, inclusive, after which\n> Cardoni deals the $21$ cards, face-up, row by row in order from $1$ to $21$,\n> into a\n> $3$-column grid. The spectator then indicates which of the three\n> columns contains the selected card, at which point the magician picks up\n> the cards by columns, picking up the specified column second (the\n> order of collecting the other two columns is unimportant).\n> Cards are collected face up, beginning with the top card in each column and\n> placing each succeeding card immediately beneath the previously collected card.\n> The cards are then redealt by rows into a $3$-column grid, starting from the\n> top of the face-up deck. The process is\n> repeated two more times; each time, the column indicated by the spectator\n> is the second column picked up by the magician. After three such\n> iterations, Cardoni announces, \"I have penetrated to the heart of your\n> mind; your card lies at the heart of this display.\" And it's true---the\n> selected card is located at the \"heart\" of the array (row four, column\n> two). Moreover, the selected card will always remain in this stable\n> location for any further iterations of the column indication and card\n> redealing process.\n\nThe process always works, no matter the number selected, provided that\nthe column containing the secret number is the second column to be\npicked up and redealt.\n\nCardoni would like to expand his trick to use different numbers of\ncards, rows, and columns, and to experiment with different orderings\nof picking up the columns after the spectator indicates a\ncolumn. However, it is not a trivial problem. For instance, when using $24$\ncards in $8$ rows and $3$ columns, and always picking up the indicated\ncolumn as the second one to redeal, the number $5$ eventually\nends up in stable location row $4$, column $3$, while the number $20$\nends up in stable location row $5$, column $1$. Also, neither location\nis one of the two \"heart\" positions in column $2$ of rows $4$ or\n$5$.  Moreover, Cardoni is uncertain of how many iterations of the\n\"indicate column and redeal\" process are needed before a\nselected card reaches a stable location.\n\nGiven the number of rows and columns of cards, help Cardoni set up his\ntrick in such a way that there is a unique stable location that is as\nclose to the center as possible.", "inputFormat": "The input consists of a single line with two integers $r$ and $c$ ($2 \\le r, c \\le 10^6$), the number of rows and columns used in the trick.\nThe cards are numbered from $1$ to $r \\cdot c$ and are initially dealt row by row in increasing order.", "outputFormat": "Output a line containing four integers $p$, $i$, $j$, and $s$, where:\n\n- the column indicated by the spectator should be picked up as the $p^{\\text{th}}$ column,\n- using this value of $p$ causes all cards to eventually end up in the stable location at row $i$ column $j$, and\n- $s$ is the maximum number of iterations required for any card to reach the stable location.\n\nThe value of $p$ should be chosen so that the stable location $(i, j)$\nis as close as possible to any of the one, two or four central\npositions in the grid, where the distance between locations $(i, j)$\nand $(i', j')$ is $|i-i'| + |j-j'|$.  If more than one value of $p$\nresults in the same minimum distance, choose the smallest such $p$.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 WF] Cardiology", "background": "ICPC2020 WF A", "description": "The Great Cardoni, Master Prestidigitator, has a deck of 21 numbered cards which he uses in a\ntrick as follows:\n\n> A spectator secretly selects a number between $1$ and $21$, inclusive, after which\n> Cardoni deals the $21$ cards, face-up, row by row in order from $1$ to $21$,\n> into a\n> $3$-column grid. The spectator then indicates which of the three\n> columns contains the selected card, at which point the magician picks up\n> the cards by columns, picking up the specified column second (the\n> order of collecting the other two columns is unimportant).\n> Cards are collected face up, beginning with the top card in each column and\n> placing each succeeding card immediately beneath the previously collected card.\n> The cards are then redealt by rows into a $3$-column grid, starting from the\n> top of the face-up deck. The process is\n> repeated two more times; each time, the column indicated by the spectator\n> is the second column picked up by the magician. After three such\n> iterations, Cardoni announces, \"I have penetrated to the heart of your\n> mind; your card lies at the heart of this display.\" And it's true---the\n> selected card is located at the \"heart\" of the array (row four, column\n> two). Moreover, the selected card will always remain in this stable\n> location for any further iterations of the column indication and card\n> redealing process.\n\nThe process always works, no matter the number selected, provided that\nthe column containing the secret number is the second column to be\npicked up and redealt.\n\nCardoni would like to expand his trick to use different numbers of\ncards, rows, and columns, and to experiment with different orderings\nof picking up the columns after the spectator indicates a\ncolumn. However, it is not a trivial problem. For instance, when using $24$\ncards in $8$ rows and $3$ columns, and always picking up the indicated\ncolumn as the second one to redeal, the number $5$ eventually\nends up in stable location row $4$, column $3$, while the number $20$\nends up in stable location row $5$, column $1$. Also, neither location\nis one of the two \"heart\" positions in column $2$ of rows $4$ or\n$5$.  Moreover, Cardoni is uncertain of how many iterations of the\n\"indicate column and redeal\" process are needed before a\nselected card reaches a stable location.\n\nGiven the number of rows and columns of cards, help Cardoni set up his\ntrick in such a way that there is a unique stable location that is as\nclose to the center as possible.", "inputFormat": "The input consists of a single line with two integers $r$ and $c$ ($2 \\le r, c \\le 10^6$), the number of rows and columns used in the trick.\nThe cards are numbered from $1$ to $r \\cdot c$ and are initially dealt row by row in increasing order.", "outputFormat": "Output a line containing four integers $p$, $i$, $j$, and $s$, where:\n\n- the column indicated by the spectator should be picked up as the $p^{\\text{th}}$ column,\n- using this value of $p$ causes all cards to eventually end up in the stable location at row $i$ column $j$, and\n- $s$ is the maximum number of iterations required for any card to reach the stable location.\n\nThe value of $p$ should be chosen so that the stable location $(i, j)$\nis as close as possible to any of the one, two or four central\npositions in the grid, where the distance between locations $(i, j)$\nand $(i', j')$ is $|i-i'| + |j-j'|$.  If more than one value of $p$\nresults in the same minimum distance, choose the smallest such $p$.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 WF] Cardiology", "background": "", "description": "伟大的魔术师 Cardoni 拥有一副编号为 1 到 21 的牌，他用这副牌进行一个魔术表演。观众秘密选择一个 1 到 21 之间的数字，然后 Cardoni 将 21 张牌面朝上按顺序从 1 到 21 逐行发到一个 3 列的网格中。观众随后指出三列中的哪一列包含所选的牌，此时魔术师按列收起牌，第二个收起观众指定的列（收集其他两列的顺序不重要）。牌是面朝上收集的，从每列的顶部牌开始，每张后续的牌立即放在前一张牌的下面。然后从面朝上的牌堆顶部开始逐行重新发牌到一个 3 列的网格中。这个过程重复两次；每次观众指定的列都是魔术师第二个收起的列。经过三次这样的迭代后，Cardoni 宣布：“我已经洞察了你的心灵；你的牌就在这个展示的中心。”这是真的——所选的牌位于数组的“中心”（第 4 行，第 2 列）。而且，对于任何进一步的列指示和重新发牌过程，所选的牌将始终保持在这个稳定的位置。这个过程总是有效的，无论选择的数字是多少，只要包含秘密数字的列是第二个被收起和重新发牌的列。Cardoni 希望扩展他的魔术，使用不同数量的牌、行和列，并尝试在观众指示列后以不同的顺序收起列。然而，这不是一个简单的问题。例如，当使用 24 张牌在 8 行 3 列中，并且始终将指示的列作为第二个重新发牌的列时，数字 5 最终会在稳定位置第 4 行第 3 列，而数字 20 最终会在稳定位置第 5 行第 1 列。此外，这两个位置都不是第 4 行或第 5 行第 2 列的两个“中心”位置之一。此外，Cardoni 不确定在选定的牌到达稳定位置之前需要多少次“指示列和重新发牌”过程的迭代。给定卡牌的行数和列数，帮助 Cardoni 设置他的魔术，使得有一个唯一的稳定位置尽可能靠近中心。", "inputFormat": "输入由一行包含两个整数 $r$ 和 $c$（$2 \\le r, c \\le 10^6$）组成，表示魔术中使用的行数和列数。牌从 1 到 $r \\cdot c$ 编号，最初按行按升序发牌。", "outputFormat": "输出一行包含四个整数 $p$、$i$、$j$ 和 $s$，其中：\n\n- 观众指示的列应作为第 $p$ 列收起，\n- 使用这个 $p$ 值会导致所有牌最终到达第 $i$ 行第 $j$ 列的稳定位置，\n- $s$ 是任何牌到达稳定位置所需的最大迭代次数。\n\n$p$ 的值应选择使得稳定位置 $(i, j)$ 尽可能接近网格中的一个、两个或四个中心位置，其中位置 $(i, j)$ 和 $(i', j')$ 之间的距离为 $|i-i'| + |j-j'|$。如果多个 $p$ 值导致相同的最小距离，则选择最小的 $p$。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P8129", "type": "P", "difficulty": 5, "samples": [["5 2\n1 2 10\n1 3 5\n1 4 7\n2 5 9", "7"], ["5 100\n1 2 10\n1 3 5\n1 4 7\n2 5 9", "9"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2020", "O2优化", "ICPC", "WF"], "title": "[ICPC 2020 WF] The Cost of Speed Limits", "background": "ICPC2020 WF B", "description": "By the year 3031, the ICPC has become so popular that a whole new town has to be built to house all the\nWorld Finals teams.\nThe town is beautifully designed, complete with a road network.\nUnfortunately, when preparing the budget, the town planners forgot to take into account the cost of speed-limit signs.\nThey have asked you to help them determine the minimum additional funds they will need.\n\nThe ICPC road network consists of roads, each connecting two intersections. Each road is two-way\nand has already been assigned a speed limit, valid for both directions.\nTo save money, the minimum possible number of roads was used. In other words, there is exactly\none route from any intersection to any other intersection.\n\nThe speed-limit signs need to be installed\nin all places where the speed limit may change for any driver that follows any route.\nMore precisely, if there exists an intersection where at least two roads meet with different speed limits,\nthen *all* of the roads going from that intersection need a speed-limit sign installed at that intersection. \nNote that some roads might need two speed-limit signs, one at each end.\n\nIt costs $c$ dollars to install one speed-limit sign. It is also possible to improve the safety and quality of\nany road so that its speed limit can be increased, which may in turn reduce the number of speed-limit signs required.\nIt costs $x$ dollars to increase the speed limit of one road by $x$ km/h (in both directions).\nTo avoid complaints, the town council does not allow decreasing any of the already-assigned speed limits.\n\nFigure B.1 illustrates the situation given in both Sample Input 1 and Sample Input 2.\n\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4kx82pq4.png)", "inputFormat": "The first line of input contains two integers $n$ and $c$, where $n$ ($1 \\le n \\le 20\\,000$) is the number of intersections\nand $c$ ($1 \\le c \\le 10^5$) is the cost of installing one sign.\nEach of the remaining $n-1$ lines contains three integers $u$, $v$, and $s$, where $u$ and $v$ ($1 \\le u, v \\le n; u \\ne v$)\nare the intersections at the ends of a road, and $s$ ($1 \\le s \\le 10^5$) is the current speed limit of that\nroad in kilometers per hour.", "outputFormat": "Output the minimum cost to upgrade roads and install speed-limit signs such that the town\nplan satisfies all the rules above.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 WF] The Cost of Speed Limits", "background": "ICPC2020 WF B", "description": "By the year 3031, the ICPC has become so popular that a whole new town has to be built to house all the\nWorld Finals teams.\nThe town is beautifully designed, complete with a road network.\nUnfortunately, when preparing the budget, the town planners forgot to take into account the cost of speed-limit signs.\nThey have asked you to help them determine the minimum additional funds they will need.\n\nThe ICPC road network consists of roads, each connecting two intersections. Each road is two-way\nand has already been assigned a speed limit, valid for both directions.\nTo save money, the minimum possible number of roads was used. In other words, there is exactly\none route from any intersection to any other intersection.\n\nThe speed-limit signs need to be installed\nin all places where the speed limit may change for any driver that follows any route.\nMore precisely, if there exists an intersection where at least two roads meet with different speed limits,\nthen *all* of the roads going from that intersection need a speed-limit sign installed at that intersection. \nNote that some roads might need two speed-limit signs, one at each end.\n\nIt costs $c$ dollars to install one speed-limit sign. It is also possible to improve the safety and quality of\nany road so that its speed limit can be increased, which may in turn reduce the number of speed-limit signs required.\nIt costs $x$ dollars to increase the speed limit of one road by $x$ km/h (in both directions).\nTo avoid complaints, the town council does not allow decreasing any of the already-assigned speed limits.\n\nFigure B.1 illustrates the situation given in both Sample Input 1 and Sample Input 2.\n\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4kx82pq4.png)", "inputFormat": "The first line of input contains two integers $n$ and $c$, where $n$ ($1 \\le n \\le 20\\,000$) is the number of intersections\nand $c$ ($1 \\le c \\le 10^5$) is the cost of installing one sign.\nEach of the remaining $n-1$ lines contains three integers $u$, $v$, and $s$, where $u$ and $v$ ($1 \\le u, v \\le n; u \\ne v$)\nare the intersections at the ends of a road, and $s$ ($1 \\le s \\le 10^5$) is the current speed limit of that\nroad in kilometers per hour.", "outputFormat": "Output the minimum cost to upgrade roads and install speed-limit signs such that the town\nplan satisfies all the rules above.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 WF] The Cost of Speed Limits", "background": "", "description": "到了 3031 年，ICPC 变得如此受欢迎，以至于需要建造一个全新的小镇来容纳所有的世界总决赛队伍。小镇设计得非常漂亮，配备了道路网络。不幸的是，在准备预算时，城镇规划者忘记考虑限速标志的成本。他们请你帮助他们确定所需的最小额外资金。\n\nICPC 的道路网络由连接两个交叉路口的道路组成。每条道路都是双向的，并且已经分配了一个速度限制，该限制对两个方向都有效。为了节省资金，使用了最少可能数量的道路。换句话说，从任何一个交叉路口到另一个交叉路口只有一条路线。\n\n限速标志需要安装在任何驾驶员沿任何路线行驶时限速可能发生变化的所有地方。更准确地说，如果存在一个交叉路口，至少有两条道路的限速不同，那么从该交叉路口出发的所有道路都需要在该交叉路口安装限速标志。注意，有些道路可能需要在两端各安装一个限速标志。\n\n安装一个限速标志的成本是 $c$ 美元。也可以提高任何道路的安全性和质量，以便可以提高其限速，这可能会减少所需的限速标志数量。将一条道路的限速提高 $x$ 公里/小时（在两个方向上）需要花费 $x$ 美元。为了避免投诉，市议会不允许降低任何已经分配的限速。\n\n图 B.1 展示了样例输入 1 和样例输入 2 中给出的情况。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4kx82pq4.png)", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $c$，其中 $n$ ($1 \\le n \\le 20,000$) 是交叉路口的数量，$c$ ($1 \\le c \\le 10^5$) 是安装一个标志的成本。接下来的 $n-1$ 行中的每一行包含三个整数 $u$，$v$ 和 $s$，其中 $u$ 和 $v$ ($1 \\le u, v \\le n; u \ne v$) 是道路两端的交叉路口，$s$ ($1 \\le s \\le 10^5$) 是该道路当前的限速（以公里/小时为单位）。", "outputFormat": "输出升级道路和安装限速标志的最低成本，以使城镇计划满足上述所有规则。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P8130", "type": "P", "difficulty": 6, "samples": [["100 100 5\n30 70\n50 60\n50 40\n30 30\n20 50\n4 3 5 2 1", "450.000000"], ["100 100 5\n30 70\n50 60\n50 40\n30 30\n20 50\n1 2 5 4 3", "0.000000"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "Special Judge", "O2优化", "ICPC", "WF"], "title": "[ICPC 2020 WF] Domes", "background": "ICPC2020 WF C", "description": "Saint Basil's Cathedral is the best-known landmark of Moscow and maybe even of all of Russia. Built under Ivan the Terrible in the $16$$^{\\text {th }}$ century, the cathedral is known for its colorful domes. No visit to the city is complete without taking a photo of the former church in Red Square.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0s8tbi50.png)\n\nThe Moscow Tourism Board (MTB) wants to make it as safe as possible for tourists to take the perfect shot of the cathedral. Depending on where you stand when you take a picture, the relative positions of the domes will be different (see Figure C.1). The MTB is concerned that for some desired configurations of domes the region in Red Square where such a photo is possible will be so small as to lead to a dangerous overcrowding of photographers. Wanting to avoid the inevitable pushing, shoving, injury, and Covid that this could cause, the MTB would like to find the area of the region where a photo is possible for any desired ordering of the domes.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/a5pgv6kt.png)\n\nFor simplicity, assume that cameras have a $180$-degree viewing angle. As an illustration consider Figure C.2, which shows the location of the domes (labeled $1$$\\sim$$5$) and the photographer (green dot) in the plane. If the photographer shoots a picture aiming the camera straight towards the left (directly at dome $5$), then everything in the shaded area will be visible in the photograph. Note that in this photograph, the domes will appear in order $4, 3, 5, 2, 1$ from the left to the right.\n\nGiven the location of the domes within Red Square and a desired left-to-right order of the domes in the photograph, MTB wants to know the area of the region within Red Square from which such a photograph can be taken. You can assume that the domes are points, so that they do not block each other unless they are in a straight line from the photographer's view.\n", "inputFormat": "The first line of input contains three integers $d_x$, $d_y$, and $n$, where $d_x$ and $d_y$ $(2 \\leq d_x, d_y \\leq 10^5)$ are the dimensions of Red Square, and $n$ $(1 \\leq n \\leq 100)$ is the number of domes. The bottom-left corner of Red Square is at the origin $(0,0)$ and the top-right corner is at coordinate $(d_x,d_y)$.\n\nEach of the next $n$ lines contains two integers $x_i$ and $y_i$ $(0 < x_i < d_x, 0 < y_i < d_y)$, giving the locations $(x_i, y_i)$ of the domes. The $i^{\\text {th }}$ line describes dome number $i$. No two domes are in the same location.\n\nThe last line contains a permutation of the numbers $\\{1, \\ldots, n\\}$ specifying the desired left-to-right viewing order of the domes in the picture.", "outputFormat": "Output the area of the region within Red Square from which one can take a photo that shows the domes in the requested order.  Note that the area may be $0$ if there is no position from which to take the requested photo.  Your answer should have an absolute or relative error of at most $10^{-3}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 WF] Domes", "background": "ICPC2020 WF C", "description": "Saint Basil's Cathedral is the best-known landmark of Moscow and maybe even of all of Russia. Built under Ivan the Terrible in the $16$$^{\\text {th }}$ century, the cathedral is known for its colorful domes. No visit to the city is complete without taking a photo of the former church in Red Square.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0s8tbi50.png)\n\nThe Moscow Tourism Board (MTB) wants to make it as safe as possible for tourists to take the perfect shot of the cathedral. Depending on where you stand when you take a picture, the relative positions of the domes will be different (see Figure C.1). The MTB is concerned that for some desired configurations of domes the region in Red Square where such a photo is possible will be so small as to lead to a dangerous overcrowding of photographers. Wanting to avoid the inevitable pushing, shoving, injury, and Covid that this could cause, the MTB would like to find the area of the region where a photo is possible for any desired ordering of the domes.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/a5pgv6kt.png)\n\nFor simplicity, assume that cameras have a $180$-degree viewing angle. As an illustration consider Figure C.2, which shows the location of the domes (labeled $1$$\\sim$$5$) and the photographer (green dot) in the plane. If the photographer shoots a picture aiming the camera straight towards the left (directly at dome $5$), then everything in the shaded area will be visible in the photograph. Note that in this photograph, the domes will appear in order $4, 3, 5, 2, 1$ from the left to the right.\n\nGiven the location of the domes within Red Square and a desired left-to-right order of the domes in the photograph, MTB wants to know the area of the region within Red Square from which such a photograph can be taken. You can assume that the domes are points, so that they do not block each other unless they are in a straight line from the photographer's view.\n", "inputFormat": "The first line of input contains three integers $d_x$, $d_y$, and $n$, where $d_x$ and $d_y$ $(2 \\leq d_x, d_y \\leq 10^5)$ are the dimensions of Red Square, and $n$ $(1 \\leq n \\leq 100)$ is the number of domes. The bottom-left corner of Red Square is at the origin $(0,0)$ and the top-right corner is at coordinate $(d_x,d_y)$.\n\nEach of the next $n$ lines contains two integers $x_i$ and $y_i$ $(0 < x_i < d_x, 0 < y_i < d_y)$, giving the locations $(x_i, y_i)$ of the domes. The $i^{\\text {th }}$ line describes dome number $i$. No two domes are in the same location.\n\nThe last line contains a permutation of the numbers $\\{1, \\ldots, n\\}$ specifying the desired left-to-right viewing order of the domes in the picture.", "outputFormat": "Output the area of the region within Red Square from which one can take a photo that shows the domes in the requested order.  Note that the area may be $0$ if there is no position from which to take the requested photo.  Your answer should have an absolute or relative error of at most $10^{-3}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 WF] Domes", "background": "", "description": "圣瓦西里大教堂是莫斯科乃至全俄罗斯最著名的地标。这座教堂建于 16 世纪伊凡雷帝时期，以其色彩斑斓的圆顶而闻名。到访这座城市时，如果不在红场拍摄这座前教堂的照片，旅程就不算完整。\n\n莫斯科旅游局（MTB）希望游客能够尽可能安全地拍摄到教堂的完美照片。根据拍摄时所站的位置，圆顶的相对位置会有所不同（见图 C.1）。MTB 担心对于某些期望的圆顶排列，红场中可以拍摄到这种照片的区域会非常小，导致摄影师过度拥挤。为了避免可能导致的推搡、受伤以及新冠病毒传播，MTB 希望找到可以拍摄到任何期望圆顶排列的区域面积。\n\n为了简化问题，假设相机具有 180 度的视角。作为说明，考虑图 C.2，其中显示了圆顶（标记为 1 到 5）和摄影师（绿色点）在平面上的位置。如果摄影师将相机直接对准左侧（直接对准圆顶 5）拍摄照片，则阴影区域内的所有内容都将在照片中可见。注意，在这张照片中，圆顶从左到右的顺序为 4, 3, 5, 2, 1。\n\n给定红场内圆顶的位置以及照片中期望的圆顶从左到右的顺序，MTB 想知道在红场内可以拍摄到这种照片的区域面积。可以假设圆顶是点，因此除非在摄影师视角中成一条直线，否则它们不会相互遮挡。", "inputFormat": "输入的第一行包含三个整数 $d_x$、$d_y$ 和 $n$，其中 $d_x$ 和 $d_y$ $(2 \\leq d_x, d_y \\leq 10^5)$ 是红场的尺寸，$n$ $(1 \\leq n \\leq 100)$ 是圆顶的数量。红场的左下角位于原点 $(0,0)$，右上角位于坐标 $(d_x,d_y)$。\n\n接下来的 $n$ 行中的每一行包含两个整数 $x_i$ 和 $y_i$ $(0 < x_i < d_x, 0 < y_i < d_y)$，给出圆顶的位置 $(x_i, y_i)$。第 $i$ 行描述了第 $i$ 个圆顶。没有两个圆顶位于同一位置。\n\n最后一行包含数字 $\\{1, \\ldots, n\\}$ 的一个排列，指定照片中圆顶从左到右的期望顺序。", "outputFormat": "输出红场内可以拍摄到圆顶按请求顺序排列的照片的区域面积。注意，如果没有位置可以拍摄到请求的照片，则面积可能为 $0$。你的答案的绝对误差或相对误差应不超过 $10^{-3}$。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P8131", "type": "P", "difficulty": 5, "samples": [["ATTACC", "3"], ["AAAAGAATTAA", "5"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "O2优化", "Manacher 算法", "ICPC", "WF"], "title": "[ICPC 2020 WF] Gene Folding", "background": "ICPC2020 WF D", "description": "International Cell Processing Company (ICPC) is a world leader in the analysis of genetic\nsequences. A genetic sequence is a sequence of nucleotides, which in this problem is\nrepresented by a string containing only the letters $\\texttt{A}$, $\\texttt{C}$, $\\texttt{G}$, and $\\texttt{T}$ \nin some combination, each letter representing a single nucleotide \n($\\textbf{A}$denine, $\\textbf{C}$ytosine, $\\textbf{G}$uanine, and $\\textbf{T}$hymine, respectively).\n\nOne of the key discoveries made by ICPC is that through a process called Genetically Optimized\nOrganic Folding (GOOF), they can take a genetic sequence and transform it into a simpler one,\nwhile preserving many of the properties of the sequence that ICPC wants to analyze.\n\nA single application of GOOF works as follows. Find a point between two adjacent \nnucleotides in the nucleotide sequence, such that the sequence reads the same from that point in\nboth directions, up until the nearer end of the sequence. For instance, in the sequence $\\texttt{ATTACC}$,\nthere are two such points: $\\texttt{AT-TACC}$ and $\\texttt{ATTAC-C}$. Then pick one of these points\n(say, the first one), and fold the genetic sequence at that point, merging the identical nucleotides (so, in this\ncase the $\\texttt{AT}$ and $\\texttt{TA}$ would become merged, and the resulting sequence would be $\\texttt{CCAT}$\nor $\\texttt{TACC}$).\n\nThrough repeated application of GOOF, a nucleotide can potentially be made much shorter.\nHowever, manually searching for the appropriate folding points is very time-consuming.  ICPC\nreached out to you to write a program that would automate the process of finding the folding\npoints and choosing them so as to obtain the shortest possible genetic sequence from a given\ninput sequence.\n", "inputFormat": "The input contains a single string $s$ representing the nucleotide sequence to be analyzed. \nThe string consists of characters $\\texttt{A}$, $\\texttt{C}$, $\\texttt{G}$, and $\\texttt{T}$ only. \nThe length of $s$ is between $1$ and $4 \\cdot 10^6$, inclusive.", "outputFormat": "Output the smallest possible length of a sequence obtained from\nthe input by applying GOOF zero or more times.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 WF] Gene Folding", "background": "ICPC2020 WF D", "description": "International Cell Processing Company (ICPC) is a world leader in the analysis of genetic\nsequences. A genetic sequence is a sequence of nucleotides, which in this problem is\nrepresented by a string containing only the letters $\\texttt{A}$, $\\texttt{C}$, $\\texttt{G}$, and $\\texttt{T}$ \nin some combination, each letter representing a single nucleotide \n($\\textbf{A}$denine, $\\textbf{C}$ytosine, $\\textbf{G}$uanine, and $\\textbf{T}$hymine, respectively).\n\nOne of the key discoveries made by ICPC is that through a process called Genetically Optimized\nOrganic Folding (GOOF), they can take a genetic sequence and transform it into a simpler one,\nwhile preserving many of the properties of the sequence that ICPC wants to analyze.\n\nA single application of GOOF works as follows. Find a point between two adjacent \nnucleotides in the nucleotide sequence, such that the sequence reads the same from that point in\nboth directions, up until the nearer end of the sequence. For instance, in the sequence $\\texttt{ATTACC}$,\nthere are two such points: $\\texttt{AT-TACC}$ and $\\texttt{ATTAC-C}$. Then pick one of these points\n(say, the first one), and fold the genetic sequence at that point, merging the identical nucleotides (so, in this\ncase the $\\texttt{AT}$ and $\\texttt{TA}$ would become merged, and the resulting sequence would be $\\texttt{CCAT}$\nor $\\texttt{TACC}$).\n\nThrough repeated application of GOOF, a nucleotide can potentially be made much shorter.\nHowever, manually searching for the appropriate folding points is very time-consuming.  ICPC\nreached out to you to write a program that would automate the process of finding the folding\npoints and choosing them so as to obtain the shortest possible genetic sequence from a given\ninput sequence.\n", "inputFormat": "The input contains a single string $s$ representing the nucleotide sequence to be analyzed. \nThe string consists of characters $\\texttt{A}$, $\\texttt{C}$, $\\texttt{G}$, and $\\texttt{T}$ only. \nThe length of $s$ is between $1$ and $4 \\cdot 10^6$, inclusive.", "outputFormat": "Output the smallest possible length of a sequence obtained from\nthe input by applying GOOF zero or more times.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 WF] Gene Folding", "background": null, "description": "国际细胞加工公司(ICPC)在基因序列分析方面处于世界领先地位。遗传序列是核苷酸的序列，在这个问题中，它由一个只包含字母 $\\texttt{A}$、$\\texttt{C}$、$\\texttt{G}$ 和 $\\texttt{T}$ 的某种组合的字符串来表示，每个字母分别代表一个核苷酸腺嘌呤（$\\textbf{A}$denine）、胞嘧啶（$\\textbf{C}$ytosine）、鸟嘌呤（$\\textbf{G}$uanine）和胸腺嘧啶（$\\textbf{T}$hymine）。\n\nICPC 的一个重要发现是，通过一种被称为基因优化有机折叠（GOOF）的过程，他们可以将一个基因序列转化为一个更简单的序列，同时保留ICPC想要分析的序列的许多属性。\n\n以下是 GOOF 的一个应用。在核苷酸序列中两个相邻核苷酸之间找到一个点，使从该点开始的序列在两个方向上都是相同的，直到序列的最后一个点。例如，在序列 $\\texttt{ATTACC}$ 中，有两个这样的点：$\\texttt{AT-TACC}$ 和 $\\texttt{ATTAC-C}$。然后选择其中一个点(比如第一个点)，在那个点折叠基因序列，合并相同的核苷酸（因此，在这种情况下，$\\texttt{AT}$ 和 $\\texttt{TA}$ 会合并，得到的序列将是 $\\texttt{CCAT}$ 或 $\\texttt{TACC}$）。\n\n通过重复使用 GOOF，可以使核苷酸变得更短。但是，手工寻找合适的折叠点非常耗时。ICPC 找到你，让你写一个程序来自动找到折叠点并选择它们，从而从给定的输入序列中获得尽可能短的基因序列。", "inputFormat": "输入包含一个表示要分析的核苷酸序列的字符串。只包含 $\\texttt{A}$、$\\texttt{C}$、$\\texttt{G}$ 和 $\\texttt{T}$。$s$ 长度在 $1 \\sim 4\\cdot10^6$ 之间。", "outputFormat": "输出从输入中应用零次或多次 GOOF 得到的序列的最小可能长度。", "hint": null, "locale": "zh-CN"}}}
