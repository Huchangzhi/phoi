{"pid": "P4379", "type": "P", "difficulty": 2, "samples": [["5\n7 1 400 2 2", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2018", "USACO", "排序"], "title": "[USACO18OPEN] Lemonade Line S", "background": "", "description": "这是农场上一个炎热的夏日，Farmer John 要给他的 $N$ 头奶牛发柠檬汽水了！所有的 $N$ 头奶牛（编号为 $1 \\dots N$）都喜欢柠檬汽水，只是有些喜欢的程度更高一些。具体来说，奶牛 $i$ 为了获得柠檬汽水，最多愿意排在 $w_i$ 头奶牛之后。现在所有的 $N$ 头奶牛都在田里，但只要 Farmer John 敲响牛铃，这些奶牛就会立刻赶到柠檬汽水站。她们会在 Farmer John 开始分发柠檬汽水之前到达，但没有两头奶牛会在同一时刻到达。此外，当奶牛 $i$ 到达时，当且仅当队伍中至多有 $w_i$ 头奶牛时，她才会加入队伍。\n\nFarmer John 想要提前准备一定量的柠檬汽水，但他不想浪费。排队的奶牛数量可能取决于她们的到达顺序。请帮助他求出在所有可能的到达顺序下，最小的可能排队奶牛数量。\n", "inputFormat": "第一行包含 $N$，第二行包含 $N$ 个用空格分隔的整数 $w_1, w_2, \\dots, w_N$。输入保证 $1 \\leq N \\leq 10^5$，此外对于每头奶牛 $i$，$0 \\leq w_i \\leq 10^9$。", "outputFormat": "输出在所有可能的奶牛到达顺序下，最小的可能排队奶牛数量。", "hint": "在这个情况下，可能最后仅有三头奶牛在队伍中（这也是最小可能值）。假设 $w = 7$ 和 $w = 400$ 的奶牛先到并等在队伍中。然后 $w = 1$ 的奶牛到达并且会离开，因为已经有 $2$ 头奶牛在队伍中了。接着 $w = 2$ 的两头奶牛到达，一头留下排队，另一头离开。\n\n供题：Dhruv Rohatgi", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18OPEN] Lemonade Line S", "background": "", "description": "It is a hot summer day on the farm, and Farmer John is handing out lemonade to his $N$ cows! All $N$ cows (numbered $1 \\dots N$) like lemonade, though some like it more than others. Specifically, cow $i$ is willing to stand behind at most $w_i$ other cows to get lemonade. All $N$ cows are currently out in the field, but as soon as Farmer John rings the cowbell, they will immediately head to the lemonade stand. They will all arrive before Farmer John begins distributing lemonade, and no two cows arrive at the same time. Additionally, when cow $i$ arrives, she joins the line if and only if there are at most $w_i$ cows in the line.\n\nFarmer John wants to prepare some amount of lemonade in advance, but he does not want to waste any. The number of cows who line up may depend on their arrival order. Please help him determine, over all possible arrival orders, the minimum possible number of cows that end up in line.", "inputFormat": "The first line contains $N$. The second line contains $N$ space-separated integers $w_1, w_2, \\dots, w_N$. The input guarantees $1 \\leq N \\leq 10^5$, and for each cow $i$, $0 \\leq w_i \\leq 10^9$.", "outputFormat": "Output the minimum possible number of cows in line over all possible arrival orders.", "hint": "For example, it is possible that only three cows end up in the line (which is also the minimum possible). Suppose the cows with $w = 7$ and $w = 400$ arrive first and wait in line. Then the cow with $w = 1$ arrives and leaves because there are already $2$ cows in line. Next, two cows with $w = 2$ arrive; one stays in line and the other leaves.\n\nProblem setter: Dhruv Rohatgi.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18OPEN] Lemonade Line S", "background": "", "description": "这是农场上一个炎热的夏日，Farmer John 要给他的 $N$ 头奶牛发柠檬汽水了！所有的 $N$ 头奶牛（编号为 $1 \\dots N$）都喜欢柠檬汽水，只是有些喜欢的程度更高一些。具体来说，奶牛 $i$ 为了获得柠檬汽水，最多愿意排在 $w_i$ 头奶牛之后。现在所有的 $N$ 头奶牛都在田里，但只要 Farmer John 敲响牛铃，这些奶牛就会立刻赶到柠檬汽水站。她们会在 Farmer John 开始分发柠檬汽水之前到达，但没有两头奶牛会在同一时刻到达。此外，当奶牛 $i$ 到达时，当且仅当队伍中至多有 $w_i$ 头奶牛时，她才会加入队伍。\n\nFarmer John 想要提前准备一定量的柠檬汽水，但他不想浪费。排队的奶牛数量可能取决于她们的到达顺序。请帮助他求出在所有可能的到达顺序下，最小的可能排队奶牛数量。\n", "inputFormat": "第一行包含 $N$，第二行包含 $N$ 个用空格分隔的整数 $w_1, w_2, \\dots, w_N$。输入保证 $1 \\leq N \\leq 10^5$，此外对于每头奶牛 $i$，$0 \\leq w_i \\leq 10^9$。", "outputFormat": "输出在所有可能的奶牛到达顺序下，最小的可能排队奶牛数量。", "hint": "在这个情况下，可能最后仅有三头奶牛在队伍中（这也是最小可能值）。假设 $w = 7$ 和 $w = 400$ 的奶牛先到并等在队伍中。然后 $w = 1$ 的奶牛到达并且会离开，因为已经有 $2$ 头奶牛在队伍中了。接着 $w = 2$ 的两头奶牛到达，一头留下排队，另一头离开。\n\n供题：Dhruv Rohatgi", "locale": "zh-CN"}}}
{"pid": "P4380", "type": "P", "difficulty": 5, "samples": [["4\n2 3 9 3\n4 9 9 1\n9 9 1 7\n2 1 1 9", "5\n10\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "USACO", "并查集", "枚举", "随机化"], "title": "[USACO18OPEN] Multiplayer Moo S", "background": "", "description": "奶牛们提出了一款创新性的新游戏，令人惊讶的是她们给这款游戏取了个最没创意的名字：“Moo”。  \nMoo 游戏在一个由 $N \\times N$ 个正方形格子组成的棋盘上进行。一头奶牛可以通过大叫一声“哞！”然后把她的数字编号写在这个格子里来占有这个格子。\n\n在游戏结束时，每个格子中都包含一个数。此时，如果一头奶牛创建了一个由连通的格子组成的领域，且该领域的大小不小于其他所有领域，那么这头奶牛就获胜。一个“领域”被定义为一些具有相同数字编号的格子，其中每个格子都直接与另一个同一领域中的格子通过上、下、左或右相邻（对角线不计）。\n\n由于以单牛形式进行游戏有点无聊，奶牛们也对双牛组队进行游戏感兴趣。同一队的两头奶牛可以创建一个领域，但现在领域中的格子可以属于队伍中的任一头奶牛。\n\n给定游戏棋盘的最终状态，请帮助奶牛们计算：  \n1. 任何单头奶牛占有的最大领域包含的格子数量。  \n2. 任何两头奶牛组成的队伍占有的最大领域包含的格子数量。  \n\n注意，两头奶牛占有的领域必须同时包含队伍中两头奶牛的编号，不能仅仅包含一头。", "inputFormat": "输入的第一行包含 $N$（$1 \\leq N \\leq 250$）。接下来的 $N$ 行，每行包含 $N$ 个整数（每个整数在 $0 \\ldots 10^6$ 之间），描述棋盘的最终状态。棋盘中至少出现两种不同的数字。", "outputFormat": "输出的第一行描述任何单头奶牛占有的最大领域大小，第二行描述任何两头奶牛的队伍占有的最大领域大小。", "hint": "在这个例子中，单头奶牛占有的最大领域是由五个 $9$ 组成的。如果编号为 $1$ 和 $9$ 的奶牛组队，她们可以形成一个大小为 $10$ 的领域。\n\n供题：Brian Dean", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18OPEN] Multiplayer Moo S", "background": "", "description": "The cows have invented a new game, and surprisingly, they gave it the least creative name: \"Moo\".\nThe Moo game is played on a board consisting of $N \\times N$ square cells. A cow can claim a cell by shouting \"Moo!\" and then writing her numeric ID in that cell.\n\nAt the end of the game, each cell contains a number. At that point, if a cow has created a region of connected cells and that region is at least as large as every other region, then that cow wins. A \"region\" is defined as a set of cells with the same numeric ID, where each cell is directly adjacent (up, down, left, or right) to another cell in the same region (diagonals do not count).\n\nSince playing solo can be a bit boring, the cows are also interested in playing in two-cow teams. Two cows on the same team can form a region, but now the cells in the region may belong to either cow on the team.\n\nGiven the final state of the game board, please help the cows compute:\n1. The number of cells in the largest region owned by any single cow.\n2. The number of cells in the largest region owned by any team of two cows.\n\nNote that a region owned by two cows must contain IDs from both cows on the team; it cannot contain only one cow’s ID.", "inputFormat": "The first line contains $N$ ($1 \\leq N \\leq 250$). Each of the next $N$ lines contains $N$ integers (each in the range $0 \\ldots 10^6$), describing the final state of the board. The board contains at least two distinct numbers.", "outputFormat": "Output two lines: the first line is the size of the largest region owned by any single cow, and the second line is the size of the largest region owned by any two-cow team.", "hint": "In this example, the largest single-cow region consists of five $9$s. If cows with IDs $1$ and $9$ form a team, they can form a region of size $10$.\n\nProblem by: Brian Dean.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18OPEN] Multiplayer Moo S", "background": "", "description": "奶牛们提出了一款创新性的新游戏，令人惊讶的是她们给这款游戏取了个最没创意的名字：“Moo”。  \nMoo 游戏在一个由 $N \\times N$ 个正方形格子组成的棋盘上进行。一头奶牛可以通过大叫一声“哞！”然后把她的数字编号写在这个格子里来占有这个格子。\n\n在游戏结束时，每个格子中都包含一个数。此时，如果一头奶牛创建了一个由连通的格子组成的领域，且该领域的大小不小于其他所有领域，那么这头奶牛就获胜。一个“领域”被定义为一些具有相同数字编号的格子，其中每个格子都直接与另一个同一领域中的格子通过上、下、左或右相邻（对角线不计）。\n\n由于以单牛形式进行游戏有点无聊，奶牛们也对双牛组队进行游戏感兴趣。同一队的两头奶牛可以创建一个领域，但现在领域中的格子可以属于队伍中的任一头奶牛。\n\n给定游戏棋盘的最终状态，请帮助奶牛们计算：  \n1. 任何单头奶牛占有的最大领域包含的格子数量。  \n2. 任何两头奶牛组成的队伍占有的最大领域包含的格子数量。  \n\n注意，两头奶牛占有的领域必须同时包含队伍中两头奶牛的编号，不能仅仅包含一头。", "inputFormat": "输入的第一行包含 $N$（$1 \\leq N \\leq 250$）。接下来的 $N$ 行，每行包含 $N$ 个整数（每个整数在 $0 \\ldots 10^6$ 之间），描述棋盘的最终状态。棋盘中至少出现两种不同的数字。", "outputFormat": "输出的第一行描述任何单头奶牛占有的最大领域大小，第二行描述任何两头奶牛的队伍占有的最大领域大小。", "hint": "在这个例子中，单头奶牛占有的最大领域是由五个 $9$ 组成的。如果编号为 $1$ 和 $9$ 的奶牛组队，她们可以形成一个大小为 $10$ 的领域。\n\n供题：Brian Dean", "locale": "zh-CN"}}}
{"pid": "P4381", "type": "P", "difficulty": 5, "samples": [["7\n3 8\n7 2\n4 2\n1 4\n1 9\n3 4\n2 3", "24"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["动态规划 DP", "2008", "IOI", "O2优化", "树的直径", "栈", "队列", "基环树"], "title": "[IOI 2008] Island", "background": "", "description": "你准备浏览一个公园，该公园由 $N$ 个岛屿组成，当地管理部门从每个岛屿 $i$ 出发向另外一个岛屿建了一座长度为 $L_i$ 的桥，不过桥是可以双向行走的。同时，每对岛屿之间都有一艘专用的往来两岛之间的渡船。相对于乘船而言，你更喜欢步行。你希望经过的桥的总长度尽可能长，但受到以下的限制：\n\n- 可以自行挑选一个岛开始游览。\n- 任何一个岛都不能游览一次以上。\n- 无论任何时间，你都可以由当前所在的岛 $S$ 去另一个从未到过的岛 $D$。从 $S$ 到 $D$ 有如下方法：\n  - 步行：仅当两个岛之间有一座桥时才有可能。对于这种情况，桥的长度会累加到你步行的总距离中。\n  - 渡船：你可以选择这种方法，仅当没有任何桥和以前使用过的渡船的组合可以由 $S$ 走到 $D$ (当检查是否可到达时，你应该考虑所有的路径，包括经过你曾游览过的那些岛)。\n\n注意，你不必游览所有的岛，也可能无法走完所有的桥。\n\n请你编写一个程序，给定 $N$ 座桥以及它们的长度，按照上述的规则，计算你可以走过的桥的长度之和的最大值。", "inputFormat": "第一行包含一个整数 $N$，即公园内岛屿的数目。\n\n随后的 $N$ 行每一行用来表示一个岛。第 $i$ 行由两个以单空格分隔的整数，表示由岛 $i$ 筑的桥。第一个整数表示桥另一端的岛，第二个整数表示该桥的长度 $L_i$。你可以假设对于每座桥，其端点总是位于不同的岛上。", "outputFormat": "仅包含一个整数，即可能的最大步行距离。", "hint": "**样例解释**：\n\n![样例图示](https://cdn.vijos.org/fs/c82895f1d6f84d5756610176662d6ee644c3e55e)\n\n样例 $N=7$ 座桥，分别为 $(1-3), (2-7), (3-4), (4-1), (5-1), (6-3)$ 以及 $(7-2)$。注意连接岛 $2$ 与岛 $7$ 之间有两座不同的桥。\n\n其中一个可以取得最大的步行距离的方法如下：\n\n- 由岛 $5$ 开始。\n- 步行长度为 $9$ 的桥到岛 $1$。\n- 步行长度为 $8$ 的桥到岛 $3$。\n- 步行长度为 $4$ 的桥到岛 $6$。\n- 搭渡船由岛 $6$ 到岛 $7$。\n- 步行长度为 $3$ 的桥到岛 $2$。\n\n最后，你到达岛 $2$，而你的总步行距离为 $9+8+4+3=24$。\n\n只有岛 $4$ 没有去。注意，上述游览结束时，你不能再游览这个岛。更准确地说：\n\n- 你不可以步行去游览，因为没有桥连接岛 $2$ (你现在的岛) 与岛 $4$。\n- 你不可以搭渡船去游览，因为你可由当前所在的岛 $2$ 到达岛 $4$。一个方法是：走 $(2-7)$ 桥，再搭你曾搭过的渡船由岛 $7$ 去岛 $6$，然后走 $(6-3)$ 桥，最后走 $(3-4)$ 桥。\n\n**数据范围**：\n\n对于 $100\\%$ 的数据，$2\\leqslant N\\leqslant 10^6,1\\leqslant L_i\\leqslant 10^8$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2008] Island", "background": "", "description": "You plan to tour a park that consists of $N$ islands. From each island $i$, the local authority has built a bridge to another island, with length $L_i$, and bridges can be walked in both directions. In addition, for every pair of islands there is a dedicated ferry that connects the two. Compared with taking a ferry, you prefer walking. You want the total length of bridges you walk across to be as large as possible, subject to the following rules:\n\n- You may choose any island to start your tour.\n- No island may be visited more than once.\n- At any time, you may move from your current island $S$ to another unvisited island $D$. You may do so in one of the following ways:\n  - Walk: only if there is a bridge directly between the two islands. In this case, the bridge length is added to your total walking distance.\n  - Ferry: you may choose this only if there is no combination of bridges and ferries you have already used that allows you to get from $S$ to $D$. When checking reachability, you should consider all paths, including those that pass through islands you have already visited.\n\nNote that you do not have to visit all the islands, and you might be unable to walk across all the bridges.\n\nWrite a program that, given $N$ bridges and their lengths, computes the maximum possible sum of bridge lengths you can walk under the rules above.", "inputFormat": "The first line contains an integer $N$, the number of islands in the park.\n\nEach of the next $N$ lines describes one island. The $i$-th line contains two integers, separated by a single space, describing the bridge built from island $i$: the first integer is the other endpoint island, and the second integer is the bridge length $L_i$. You may assume that the endpoints of every bridge are always different islands.", "outputFormat": "Output a single integer, the maximum possible walking distance.", "hint": "Sample explanation:\n\n![Sample illustration](https://cdn.vijos.org/fs/c82895f1d6f84d5756610176662d6ee644c3e55e)\n\nIn the sample, $N=7$ bridges are $(1-3)$, $(2-7)$, $(3-4)$, $(4-1)$, $(5-1)$, $(6-3)$, and $(7-2)$. Note that there are two different bridges between islands $2$ and $7$.\n\nOne way to achieve the maximum walking distance is as follows:\n- Start at island $5$.\n- Walk across the bridge of length $9$ to island $1$.\n- Walk across the bridge of length $8$ to island $3$.\n- Walk across the bridge of length $4$ to island $6$.\n- Take the ferry from island $6$ to island $7$.\n- Walk across the bridge of length $3$ to island $2$.\n\nYou end at island $2$, and your total walking distance is $9+8+4+3=24$.\n\nOnly island $4$ is not visited. Note that, at the end of the tour above, you cannot visit that island. More precisely:\n- You cannot walk there because there is no bridge between island $2$ (your current island) and island $4$.\n- You cannot take a ferry there because island $4$ is reachable from your current island $2$. One possible way is: take bridge $(2-7)$, then the previously used ferry from island $7$ to island $6$, then take bridge $(6-3)$, and finally bridge $(3-4)$.\n\nConstraints:\nFor $100\\%$ of the testdata, $2 \\leqslant N \\leqslant 10^6$, $1 \\leqslant L_i \\leqslant 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2008] Island", "background": "", "description": "你准备浏览一个公园，该公园由 $N$ 个岛屿组成，当地管理部门从每个岛屿 $i$ 出发向另外一个岛屿建了一座长度为 $L_i$ 的桥，不过桥是可以双向行走的。同时，每对岛屿之间都有一艘专用的往来两岛之间的渡船。相对于乘船而言，你更喜欢步行。你希望经过的桥的总长度尽可能长，但受到以下的限制：\n\n- 可以自行挑选一个岛开始游览。\n- 任何一个岛都不能游览一次以上。\n- 无论任何时间，你都可以由当前所在的岛 $S$ 去另一个从未到过的岛 $D$。从 $S$ 到 $D$ 有如下方法：\n  - 步行：仅当两个岛之间有一座桥时才有可能。对于这种情况，桥的长度会累加到你步行的总距离中。\n  - 渡船：你可以选择这种方法，仅当没有任何桥和以前使用过的渡船的组合可以由 $S$ 走到 $D$ (当检查是否可到达时，你应该考虑所有的路径，包括经过你曾游览过的那些岛)。\n\n注意，你不必游览所有的岛，也可能无法走完所有的桥。\n\n请你编写一个程序，给定 $N$ 座桥以及它们的长度，按照上述的规则，计算你可以走过的桥的长度之和的最大值。", "inputFormat": "第一行包含一个整数 $N$，即公园内岛屿的数目。\n\n随后的 $N$ 行每一行用来表示一个岛。第 $i$ 行由两个以单空格分隔的整数，表示由岛 $i$ 筑的桥。第一个整数表示桥另一端的岛，第二个整数表示该桥的长度 $L_i$。你可以假设对于每座桥，其端点总是位于不同的岛上。", "outputFormat": "仅包含一个整数，即可能的最大步行距离。", "hint": "**样例解释**：\n\n![样例图示](https://cdn.vijos.org/fs/c82895f1d6f84d5756610176662d6ee644c3e55e)\n\n样例 $N=7$ 座桥，分别为 $(1-3), (2-7), (3-4), (4-1), (5-1), (6-3)$ 以及 $(7-2)$。注意连接岛 $2$ 与岛 $7$ 之间有两座不同的桥。\n\n其中一个可以取得最大的步行距离的方法如下：\n\n- 由岛 $5$ 开始。\n- 步行长度为 $9$ 的桥到岛 $1$。\n- 步行长度为 $8$ 的桥到岛 $3$。\n- 步行长度为 $4$ 的桥到岛 $6$。\n- 搭渡船由岛 $6$ 到岛 $7$。\n- 步行长度为 $3$ 的桥到岛 $2$。\n\n最后，你到达岛 $2$，而你的总步行距离为 $9+8+4+3=24$。\n\n只有岛 $4$ 没有去。注意，上述游览结束时，你不能再游览这个岛。更准确地说：\n\n- 你不可以步行去游览，因为没有桥连接岛 $2$ (你现在的岛) 与岛 $4$。\n- 你不可以搭渡船去游览，因为你可由当前所在的岛 $2$ 到达岛 $4$。一个方法是：走 $(2-7)$ 桥，再搭你曾搭过的渡船由岛 $7$ 去岛 $6$，然后走 $(6-3)$ 桥，最后走 $(3-4)$ 桥。\n\n**数据范围**：\n\n对于 $100\\%$ 的数据，$2\\leqslant N\\leqslant 10^6,1\\leqslant L_i\\leqslant 10^8$。\n", "locale": "zh-CN"}}}
{"pid": "P4382", "type": "P", "difficulty": 7, "samples": [["3 5\n2 2\n1 1\n2 2\n1 2\n1 1\n2 2\n1 1\n1 2\n1 2\n2 1\n2 2\n1 1\n0 1\n0 1\n2 2", "2 1\n1 0\n1 2\n0 1\n1 3\n0 1"], ["1 5\n4 3\n2 1 1\n3 1 3\n0 0 1\n3 1 2\n2 3 1\n2 3 3 3", "1 1 3 2\n0 0 0 0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "各省省选", "网络流", "O2优化", "枚举", "图论建模"], "title": "[八省联考 2018] 劈配", "background": "一年一度的综艺节目《中国新代码》又开始了。Zayid 从小就梦想成为一名程序员，他觉得这是一个展示自己的舞台，于是他毫不犹豫地报名了。", "description": "轻车熟路的 Zayid 顺利地通过了海选，接下来的环节是导师盲选，这一阶段的规则是这样的：\n\n总共 $n$ 名参赛选手（编号从 $1$ 至 $n$ ）每人写出一份代码并介绍自己的梦想。接着 由所有导师对这些选手进行排名。为了避免后续的麻烦，规定**不存在排名并列的情况**。\n\n同时，每名选手都将独立地填写一份志愿表，来对总共 $m$ 位导师（编号从 $1$ 至 $m$ ）作出评价。志愿表上包含了共 $m$ 档志愿。对于每一档志愿，选手被允许填写最多 $C$ 位导师，每位导师最多被每位选手填写**一次**（**放弃某些导师也是被允许的**）。\n\n在双方的工作都完成后，进行录取工作。每位导师都有自己战队的人数上限，这意味着可能有部分选手的较高志愿、甚至是全部志愿无法得到满足。节目组对“前 $i$ 名的录取结果最优”作出如下定义：\n\n- 前 $1$ 名的录取结果最优，**当且仅当**第 $1$ 名被其最高非空志愿录取（**特别地**，如果第 $1$ 名没有填写志愿表，那么该选手出局）。\n\n- 前 $i$ 名的录取结果最优，当且仅当在前 $i - 1$ 名的录取结果最优的情况下，第 $i$ 名 被其理论可能的最高志愿录取（特别地，如果第 $i$ 名没有填写志愿表，或其所有志愿中的导师战队均已满员，那么该选手出局）。\n\n如果一种方案满足“前 $n$ 名的录取结果最优”，那么我们可以简称这种方案是**最优的**。\n\n举例而言，$2$ 位导师 $\\rm T$ 老师、 $\\rm F$ 老师的战队人数上限分别都是 $1$ 人；$2$ 位选手 Zayid 、DuckD 分列第 $1$ 、 $2$ 名。那么下面 $3$ 种志愿表及其对应的最优录取结果如表中所示：\n\n![](https://cdn.luogu.com.cn/upload/pic/17003.png)\n\n![](https://cdn.luogu.com.cn/upload/pic/17004.png)\n\n可以证明，对于上面的志愿表，对应的方案都是唯一的最优录取结果。\n\n每个人都有一个自己的理想值 $s_i$ ，表示第 $i$ 位同学希望自己被第 $s_i$ 或更高的志愿录取，如果没有，那么他就会非常沮丧。\n\n现在，所有选手的志愿表和排名都已公示。巧合的是，每位选手的排名都恰好与它们的编号相同。\n\n对于每一位选手，Zayid 都想知道下面两个问题的答案：\n\n- 在最优的录取方案中，他会被第几志愿录取。\n\n- 在其他选手相对排名不变的情况下，至少上升多少名才能使得他不沮丧。\n\n作为《中国新代码》的实力派代码手，Zayid 当然轻松地解决了这个问题。不过他还是想请你再算一遍，来检验自己计算的正确性。", "inputFormat": "每个测试点包含多组测试数据，第一行 $2$ 个用空格隔开的非负整数 $T,C$ ，分别表示数据组数、每档志愿最多允许填写的导师数目。\n\n接下来依次描述每组数据，对于每组数据：\n\n- 第 $1$ 行两个用空格隔开的正整数 $n,m$ 。\n\n> $n,m$ 分别表示选手的数量、导师的数量。\n\n- 第 $2$ 行 $m$ 个用空格隔开的正整数：其中第 $i$ 个整数为 $b_i$ 。\n\n> $b_i$ 表示编号为 $i$ 的导师战队人数的上限。\n\n第 $3$ 行至第 $n + 2$ 行，每行 $m$ 个用空格隔开的非负整数：其中第 $i + 2$ 行左起第 $j$ 个数为 $a_{i,j}$ 。\n\n> $a_{i,j}$ 表示编号为 $i$ 的选手将编号为 $j$ 的导师编排在了第 $a_{i,j}$ 志愿。特别地，如果 $a_{i,j}= 0$ ，则表示该选手没有将该导师填入志愿表。\n\n> 在这一部分，保证每行中不存在某一个正数出现超过 $C$ 次（ **$0$ 可能出现超过 $C$ 次**），同时保证所有  $a_{i,j} \\leqslant m$ 。\n\n- 第 $n + 3$ 行 $n$ 个用空格隔开的正整数，其中第 $i$ 个整数为 $s_i$ 。\n\n> $s_i$ 表示编号为 $i$ 的选手的理想值。\n\n> 在这一部分，保证 $s_i \\leqslant m$ 。", "outputFormat": "按顺序输出每组数据的答案。对于每组数据，输出 $2$ 行：\n\n- 第 $1$ 行输出 $n$ 个用空格隔开的正整数，其中第 $i$ 个整数的意义为：\n\n\t在最优的录取方案中，编号为 $i$ 的选手会被该档志愿录取。\n\n> **特别地，如果该选手出局，则这个数为 $m + 1$** 。\n\n- 第 $2$ 行输出 $n$ 个用空格隔开的非负整数，其中第 $i$ 个整数的意义为：\n\n\t使编号为 $i$ 的选手不沮丧，最少需要让他上升的排名数。\n    \n> **特别地，如果该选手一定会沮丧，则这个数为 $i$ 。**", "hint": "- 样例 $1$ 解释\n\n三组数据分别与【题目描述】中的三个表格对应。\n\n对于第 $1$ 组数据：由于选手 $1$ 没有填写第一志愿，所以他一定无法被第一志愿录取，也就一定会沮丧。选手 $2$ 按原排名就不沮丧，因此他不需要提升排名。\n\n对于第 $2$ 组和第 $3$ 组数据： $1$ 号选手都不需要提升排名。而希望被第一志愿录取的 $2$ 号选手都必须升到第 $1$ 名才能如愿。\n\n- 样例 $2$ 解释\n\n$1$ 号选手的第一志愿只填写了 $2$ 号导师，因此 $1$ 号选手必定被 $2$ 号导师录取。\n\n$2$ 号选手的第一志愿只填写了 $3$ 号导师，因此 $2$ 号选手必定被 $3$ 号导师录取。\n\n由于 $2,3$ 号导师均满员，且 $3,4$ 号选手均填写了 $1$ 号导师，因此他们都会被 $1$ 号导师录取。\n\n所以 $1,2$ 号选手均被第 $1$ 志愿录取，$3$ 号选手被第 $3$ 志愿录取， $4$ 号选手被第 $2$ 志愿录取。\n\n由于他们都如愿以偿了，所以他们都不需要提升名次。\n\n\n|测试点编号|$n \\leqslant$|$m \\leqslant$|$C$|其他约定|\n|:----:|:---:|:----:|:----:|:----:|\n|1| $10$|$1$|$=1$|无|\n|2|$10$|$2$|$=2$|$s_i=m$|\n|3|$10$|$3$|$=3$|无|\n|4|$100$|$100$|$=1$|$b_i=1$|\n|5|$100$|$100$|$=1$|无|\n|6|$200$|$200$|$=1$|$b_i=1$|\n|7|$200$|$200$|$=1$|无|\n|8|$100$|$100$|$=10$|无|\n|9|$200$|$200$|$=10$|$b_i=1$|\n|10|$200$|$200$|$=10$|无|\n\n- 对于所有测试点，保证 $ T \\leqslant 5$ 。\n\n- 对于所有测试点钟的所有数据，保证 $ m \\leqslant n \\leqslant 200, b_i \\leqslant n$", "locale": "zh-CN", "translations": {"en": {"title": "[Eight-Province Joint Exam 2018] Pi Pei", "background": "The annual variety show \"China's New Code\" has begun again. Zayid has dreamed of becoming a programmer since childhood. He feels this is a stage to show himself, so he signed up without hesitation.", "description": "Skilled as usual, Zayid smoothly passed the open auditions. The next stage is the mentors' blind selection, with rules as follows:\n\nThere are $n$ contestants in total (numbered from $1$ to $n$). Each writes a piece of code and presents their dream. Then all mentors rank these contestants. To avoid future trouble, it is required that there are no ties in the rankings.\n\nAt the same time, each contestant independently fills out a preference form to evaluate the $m$ mentors (numbered from $1$ to $m$). The form contains $m$ preference tiers. For each tier, the contestant may list at most $C$ mentors, and each mentor may be listed at most once by each contestant (skipping some mentors is allowed).\n\nAfter both sides finish, admissions are carried out. Each mentor has an upper bound on their team size, which means some contestants' higher preferences, or even all their preferences, may not be met. The show defines \"the result for the top $i$ contestants is optimal\" as follows:\n\n- The result for the top $1$ contestant is optimal if and only if contestant $1$ is admitted to their highest nonempty preference (in particular, if contestant $1$ did not submit a preference form, then this contestant is eliminated).\n\n- The result for the top $i$ contestants is optimal if and only if, given that the result for the top $i - 1$ contestants is optimal, contestant $i$ is admitted to the highest preference that is theoretically possible (in particular, if contestant $i$ did not submit a preference form, or if all mentors in their preferences are already full, then this contestant is eliminated).\n\nIf a scheme satisfies \"the result for the top $n$ contestants is optimal,\" we simply call this scheme optimal.\n\nFor example, there are $2$ mentors, Teacher $\\rm T$ and Teacher $\\rm F$, each with a team size cap of $1$; there are $2$ contestants, Zayid and DuckD, ranked $1$ and $2$, respectively. Then the following $3$ preference forms and their corresponding optimal admission results are as shown in the tables:\n\n![](https://cdn.luogu.com.cn/upload/pic/17003.png)\n\n![](https://cdn.luogu.com.cn/upload/pic/17004.png)\n\nIt can be proved that, for the above preference forms, the corresponding schemes are the unique optimal admission results.\n\nEveryone has an ideal value $s_i$, meaning that contestant $i$ hopes to be admitted to their $s_i$-th or better preference; otherwise, they will be very disappointed.\n\nNow all contestants' preference forms and rankings have been published. Coincidentally, each contestant's ranking exactly matches their ID.\n\nFor each contestant, Zayid wants to know the answers to the following two questions:\n\n- In the optimal admission scheme, to which preference tier will they be admitted?\n\n- With other contestants' relative order unchanged, by at least how many ranks must they climb so that they are not disappointed?\n\nAs a top-notch coder on \"China's New Code,\" Zayid certainly solved this problem easily. But he still wants you to compute it again to verify his result.", "inputFormat": "Each test point contains multiple testcases. The first line contains $2$ non-negative integers $T, C$ separated by a space, representing the number of testcases and the maximum number of mentors allowed per preference tier, respectively.\n\nThen for each testcase:\n\n- The first line contains two positive integers $n, m$ separated by a space.\n\n> $n, m$ denote the number of contestants and the number of mentors, respectively.\n\n- The second line contains $m$ positive integers separated by spaces: the $i$-th integer is $b_i$.\n\n> $b_i$ is the team size upper bound of mentor $i$.\n\nLines $3$ to $n + 2$ each contain $m$ non-negative integers: in line $i + 2$, the $j$-th number from the left is $a_{i,j}$.\n\n> $a_{i,j}$ means contestant $i$ placed mentor $j$ as their $a_{i,j}$-th preference. In particular, if $a_{i,j} = 0$, it means this contestant did not include this mentor on the form.\n\n> In this part, it is guaranteed that within each row no positive number appears more than $C$ times ($0$ may appear more than $C$ times), and all $a_{i,j} \\leqslant m$.\n\n- Line $n + 3$ contains $n$ positive integers separated by spaces, where the $i$-th integer is $s_i$.\n\n> $s_i$ is the ideal value of contestant $i$.\n\n> In this part, it is guaranteed that $s_i \\leqslant m$.", "outputFormat": "Output the answers for each testcase in order. For each testcase, output $2$ lines:\n\n- The first line contains $n$ positive integers separated by spaces. The $i$-th integer means:\n\n\tthe preference tier to which contestant $i$ will be admitted in the optimal scheme.\n\n> In particular, if this contestant is eliminated, this number is $m + 1$.\n\n- The second line contains $n$ non-negative integers separated by spaces. The $i$-th integer means:\n\n\tthe minimum number of ranks contestant $i$ must climb so as not to be disappointed.\n    \n> In particular, if this contestant will certainly be disappointed, this number is $i$.", "hint": "- Explanation for Sample $1$:\n\nThe three datasets correspond to the three tables in the Description.\n\nFor the first dataset: because contestant $1$ did not list any first preference, they definitely cannot be admitted to their first preference tier and will definitely be disappointed. Contestant $2$ is not disappointed with the original ranking, so they do not need to improve their rank.\n\nFor the second and third datasets: contestant $1$ does not need to improve their rank. Aiming for first preference, contestant $2$ must rise to rank $1$ to get their wish.\n\n- Explanation for Sample $2$:\n\nContestant $1$ listed only mentor $2$ as first preference, so contestant $1$ must be admitted by mentor $2$.\n\nContestant $2$ listed only mentor $3$ as first preference, so contestant $2$ must be admitted by mentor $3$.\n\nSince mentors $2$ and $3$ are full, and contestants $3$ and $4$ both listed mentor $1$, they will both be admitted by mentor $1$.\n\nTherefore, contestants $1$ and $2$ are both admitted to their $1$-st preference, contestant $3$ is admitted to their $3$-rd preference, and contestant $4$ is admitted to their $2$-nd preference.\n\nSince they all get what they want, none of them needs to improve their rank.\n\n| Test point ID | $n \\leqslant$ | $m \\leqslant$ | $C$ | Other conditions |\n|:----:|:---:|:----:|:----:|:----:|\n| 1 | $10$ | $1$ | $=1$ | None |\n| 2 | $10$ | $2$ | $=2$ | $s_i = m$ |\n| 3 | $10$ | $3$ | $=3$ | None |\n| 4 | $100$ | $100$ | $=1$ | $b_i = 1$ |\n| 5 | $100$ | $100$ | $=1$ | None |\n| 6 | $200$ | $200$ | $=1$ | $b_i = 1$ |\n| 7 | $200$ | $200$ | $=1$ | None |\n| 8 | $100$ | $100$ | $=10$ | None |\n| 9 | $200$ | $200$ | $=10$ | $b_i = 1$ |\n| 10 | $200$ | $200$ | $=10$ | None |\n\n- For all test points, it is guaranteed that $T \\leqslant 5$.\n\n- Across all data of all test points, it is guaranteed that $m \\leqslant n \\leqslant 200, b_i \\leqslant n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[八省联考 2018] 劈配", "background": "一年一度的综艺节目《中国新代码》又开始了。Zayid 从小就梦想成为一名程序员，他觉得这是一个展示自己的舞台，于是他毫不犹豫地报名了。", "description": "轻车熟路的 Zayid 顺利地通过了海选，接下来的环节是导师盲选，这一阶段的规则是这样的：\n\n总共 $n$ 名参赛选手（编号从 $1$ 至 $n$ ）每人写出一份代码并介绍自己的梦想。接着 由所有导师对这些选手进行排名。为了避免后续的麻烦，规定**不存在排名并列的情况**。\n\n同时，每名选手都将独立地填写一份志愿表，来对总共 $m$ 位导师（编号从 $1$ 至 $m$ ）作出评价。志愿表上包含了共 $m$ 档志愿。对于每一档志愿，选手被允许填写最多 $C$ 位导师，每位导师最多被每位选手填写**一次**（**放弃某些导师也是被允许的**）。\n\n在双方的工作都完成后，进行录取工作。每位导师都有自己战队的人数上限，这意味着可能有部分选手的较高志愿、甚至是全部志愿无法得到满足。节目组对“前 $i$ 名的录取结果最优”作出如下定义：\n\n- 前 $1$ 名的录取结果最优，**当且仅当**第 $1$ 名被其最高非空志愿录取（**特别地**，如果第 $1$ 名没有填写志愿表，那么该选手出局）。\n\n- 前 $i$ 名的录取结果最优，当且仅当在前 $i - 1$ 名的录取结果最优的情况下，第 $i$ 名 被其理论可能的最高志愿录取（特别地，如果第 $i$ 名没有填写志愿表，或其所有志愿中的导师战队均已满员，那么该选手出局）。\n\n如果一种方案满足“前 $n$ 名的录取结果最优”，那么我们可以简称这种方案是**最优的**。\n\n举例而言，$2$ 位导师 $\\rm T$ 老师、 $\\rm F$ 老师的战队人数上限分别都是 $1$ 人；$2$ 位选手 Zayid 、DuckD 分列第 $1$ 、 $2$ 名。那么下面 $3$ 种志愿表及其对应的最优录取结果如表中所示：\n\n![](https://cdn.luogu.com.cn/upload/pic/17003.png)\n\n![](https://cdn.luogu.com.cn/upload/pic/17004.png)\n\n可以证明，对于上面的志愿表，对应的方案都是唯一的最优录取结果。\n\n每个人都有一个自己的理想值 $s_i$ ，表示第 $i$ 位同学希望自己被第 $s_i$ 或更高的志愿录取，如果没有，那么他就会非常沮丧。\n\n现在，所有选手的志愿表和排名都已公示。巧合的是，每位选手的排名都恰好与它们的编号相同。\n\n对于每一位选手，Zayid 都想知道下面两个问题的答案：\n\n- 在最优的录取方案中，他会被第几志愿录取。\n\n- 在其他选手相对排名不变的情况下，至少上升多少名才能使得他不沮丧。\n\n作为《中国新代码》的实力派代码手，Zayid 当然轻松地解决了这个问题。不过他还是想请你再算一遍，来检验自己计算的正确性。", "inputFormat": "每个测试点包含多组测试数据，第一行 $2$ 个用空格隔开的非负整数 $T,C$ ，分别表示数据组数、每档志愿最多允许填写的导师数目。\n\n接下来依次描述每组数据，对于每组数据：\n\n- 第 $1$ 行两个用空格隔开的正整数 $n,m$ 。\n\n> $n,m$ 分别表示选手的数量、导师的数量。\n\n- 第 $2$ 行 $m$ 个用空格隔开的正整数：其中第 $i$ 个整数为 $b_i$ 。\n\n> $b_i$ 表示编号为 $i$ 的导师战队人数的上限。\n\n第 $3$ 行至第 $n + 2$ 行，每行 $m$ 个用空格隔开的非负整数：其中第 $i + 2$ 行左起第 $j$ 个数为 $a_{i,j}$ 。\n\n> $a_{i,j}$ 表示编号为 $i$ 的选手将编号为 $j$ 的导师编排在了第 $a_{i,j}$ 志愿。特别地，如果 $a_{i,j}= 0$ ，则表示该选手没有将该导师填入志愿表。\n\n> 在这一部分，保证每行中不存在某一个正数出现超过 $C$ 次（ **$0$ 可能出现超过 $C$ 次**），同时保证所有  $a_{i,j} \\leqslant m$ 。\n\n- 第 $n + 3$ 行 $n$ 个用空格隔开的正整数，其中第 $i$ 个整数为 $s_i$ 。\n\n> $s_i$ 表示编号为 $i$ 的选手的理想值。\n\n> 在这一部分，保证 $s_i \\leqslant m$ 。", "outputFormat": "按顺序输出每组数据的答案。对于每组数据，输出 $2$ 行：\n\n- 第 $1$ 行输出 $n$ 个用空格隔开的正整数，其中第 $i$ 个整数的意义为：\n\n\t在最优的录取方案中，编号为 $i$ 的选手会被该档志愿录取。\n\n> **特别地，如果该选手出局，则这个数为 $m + 1$** 。\n\n- 第 $2$ 行输出 $n$ 个用空格隔开的非负整数，其中第 $i$ 个整数的意义为：\n\n\t使编号为 $i$ 的选手不沮丧，最少需要让他上升的排名数。\n    \n> **特别地，如果该选手一定会沮丧，则这个数为 $i$ 。**", "hint": "- 样例 $1$ 解释\n\n三组数据分别与【题目描述】中的三个表格对应。\n\n对于第 $1$ 组数据：由于选手 $1$ 没有填写第一志愿，所以他一定无法被第一志愿录取，也就一定会沮丧。选手 $2$ 按原排名就不沮丧，因此他不需要提升排名。\n\n对于第 $2$ 组和第 $3$ 组数据： $1$ 号选手都不需要提升排名。而希望被第一志愿录取的 $2$ 号选手都必须升到第 $1$ 名才能如愿。\n\n- 样例 $2$ 解释\n\n$1$ 号选手的第一志愿只填写了 $2$ 号导师，因此 $1$ 号选手必定被 $2$ 号导师录取。\n\n$2$ 号选手的第一志愿只填写了 $3$ 号导师，因此 $2$ 号选手必定被 $3$ 号导师录取。\n\n由于 $2,3$ 号导师均满员，且 $3,4$ 号选手均填写了 $1$ 号导师，因此他们都会被 $1$ 号导师录取。\n\n所以 $1,2$ 号选手均被第 $1$ 志愿录取，$3$ 号选手被第 $3$ 志愿录取， $4$ 号选手被第 $2$ 志愿录取。\n\n由于他们都如愿以偿了，所以他们都不需要提升名次。\n\n\n|测试点编号|$n \\leqslant$|$m \\leqslant$|$C$|其他约定|\n|:----:|:---:|:----:|:----:|:----:|\n|1| $10$|$1$|$=1$|无|\n|2|$10$|$2$|$=2$|$s_i=m$|\n|3|$10$|$3$|$=3$|无|\n|4|$100$|$100$|$=1$|$b_i=1$|\n|5|$100$|$100$|$=1$|无|\n|6|$200$|$200$|$=1$|$b_i=1$|\n|7|$200$|$200$|$=1$|无|\n|8|$100$|$100$|$=10$|无|\n|9|$200$|$200$|$=10$|$b_i=1$|\n|10|$200$|$200$|$=10$|无|\n\n- 对于所有测试点，保证 $ T \\leqslant 5$ 。\n\n- 对于所有测试点钟的所有数据，保证 $ m \\leqslant n \\leqslant 200, b_i \\leqslant n$", "locale": "zh-CN"}}}
{"pid": "P4383", "type": "P", "difficulty": 7, "samples": [["5 1\n1 2 3\n2 3 5\n2 4 -3\n4 5 6", "14"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["动态规划 DP", "2018", "各省省选", "枚举", "凸完全单调性（wqs 二分）", "树的直径", "差分"], "title": "[八省联考 2018] 林克卡特树", "background": "", "description": "小 L 最近沉迷于塞尔达传说：荒野之息（The Legend of Zelda: Breath of The Wild）无法自拔，他尤其喜欢游戏中的迷你挑战。\n\n游戏中有一个叫做 LCT 的挑战，它的规则是这样子的：现在有一个 $N$ 个点的树，每条边有一个整数边权 $v_i$，若 $v_i \\geq 0$，表示走这条边会获得 $v_i$ 的收益；若 $v_i \\lt 0$ ，则表示走这条边需要支付 $-v_i$ 的过路费。小 L 需要控制主角 Link 切掉（Cut）树上的恰好 $K$ 条边，然后再连接 $K$ 条边权为 0 的边，得到一棵新的树。接着，他会选择树上的两个点 $p,q$，并沿着树上连接这两点的简单路径从 $p$ 走到 $q$，并为经过的每条边支付过路费/ 获取相应收益。\n\n海拉鲁大陆之神 TemporaryDO 想考验一下 Link。他告诉 Link，如果 Link 能切掉合适的边、选择合适的路径从而使 总收益 - 总过路费 最大化的话，就把传说中的大师之剑送给他。\n\n小 L 想得到大师之剑，于是他找到了你来帮忙，请你告诉他，Link 能得到的 总收益 - 总过路费 最大是多少。", "inputFormat": "输入第一行包含两个正整数 $N,K$。\n\n接下来 $N - 1$ 行，每行包含三个整数 $x_i,y_i,v_i$，表示第 $i$ 条边连接图中的 $x_i, y_i$ 两点，它的边权为 $v_i$。", "outputFormat": "输出一行一个整数，表示答案。", "hint": "### 样例解释\n\n一种可能的最优方案为：切掉 $(2, 4, -3)$ 这条边，连接 $(3, 4, 0)$ 这条边，选择 $(p, q) = (1, 5)$。\n\n### 数据范围\n\n- 对于 $10\\%$ 的数据，$k = 0$；\n- 对于另外 $10\\%$ 的数据，$k = 1$；\n- 对于另外 $15\\%$ 的数据，$k = 2$；\n- 对于另外 $25\\%$ 的数据，$k \\leq 100$；\n- 对于其他数据，没有特殊约定。\n\n对于全部的测试数据，保证 $1 \\leq N \\leq 3 \\times 10^5$，$0 \\leq K \\leq 3 \\times 10^5$，$K \\lt N$，$1 \\leq x_i,y_i \\leq N$，$|v_i| \\leq 10^6$。\n\n### 提示\n\n题目并不难。", "locale": "zh-CN", "translations": {"en": {"title": "[Eight-Province Joint Exam 2018] Link-Cut Tree", "background": "", "description": "Little L has recently become obsessed with The Legend of Zelda: Breath of the Wild, and he especially enjoys the mini challenges.\n\nIn the game, there is a challenge called LCT. Its rules are as follows: There is a tree with $N$ nodes. Each edge has an integer weight $v_i$. If $v_i \\geq 0$, traversing this edge yields a gain of $v_i$; if $v_i \\lt 0$, traversing this edge requires paying a toll of $-v_i$. Little L needs to control the protagonist Link to cut exactly $K$ edges from the tree, then connect $K$ new edges each with weight $0$, producing a new tree. Next, he will choose two nodes $p, q$ on the tree, and walk from $p$ to $q$ along the unique simple path connecting them, paying tolls or obtaining gains for each edge he traverses.\n\nThe god of Hyrule, TemporaryDO, wants to test Link. He tells Link that if Link can cut appropriate edges and choose an appropriate path so that the total gain $-$ total toll is maximized, he will give him the legendary Master Sword.\n\nLittle L wants the Master Sword, so he asks you for help. Please tell him the maximum possible value of total gain $-$ total toll that Link can obtain.", "inputFormat": "The first line contains two positive integers $N, K$.\n\nThe next $N - 1$ lines each contain three integers $x_i, y_i, v_i$, indicating that the $i$-th edge connects nodes $x_i$ and $y_i$, and its weight is $v_i$.", "outputFormat": "Output a single integer, the answer.", "hint": "Sample Explanation:\nOne possible optimal plan is: cut edge $(2, 4, -3)$, add edge $(3, 4, 0)$, and choose $(p, q) = (1, 5)$.\n\nConstraints:\n- For $10\\%$ of the testdata, $K = 0$.\n- For another $10\\%$ of the testdata, $K = 1$.\n- For another $15\\%$ of the testdata, $K = 2$.\n- For another $25\\%$ of the testdata, $K \\leq 100$.\n- For the remaining testdata, there are no special constraints.\n\nFor all testdata, it is guaranteed that $1 \\leq N \\leq 3 \\times 10^5$, $0 \\leq K \\leq 3 \\times 10^5$, $K \\lt N$, $1 \\leq x_i, y_i \\leq N$, and $|v_i| \\leq 10^6$.\n\nHint:\nThis problem is not difficult.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[八省联考 2018] 林克卡特树", "background": "", "description": "小 L 最近沉迷于塞尔达传说：荒野之息（The Legend of Zelda: Breath of The Wild）无法自拔，他尤其喜欢游戏中的迷你挑战。\n\n游戏中有一个叫做 LCT 的挑战，它的规则是这样子的：现在有一个 $N$ 个点的树，每条边有一个整数边权 $v_i$，若 $v_i \\geq 0$，表示走这条边会获得 $v_i$ 的收益；若 $v_i \\lt 0$ ，则表示走这条边需要支付 $-v_i$ 的过路费。小 L 需要控制主角 Link 切掉（Cut）树上的恰好 $K$ 条边，然后再连接 $K$ 条边权为 0 的边，得到一棵新的树。接着，他会选择树上的两个点 $p,q$，并沿着树上连接这两点的简单路径从 $p$ 走到 $q$，并为经过的每条边支付过路费/ 获取相应收益。\n\n海拉鲁大陆之神 TemporaryDO 想考验一下 Link。他告诉 Link，如果 Link 能切掉合适的边、选择合适的路径从而使 总收益 - 总过路费 最大化的话，就把传说中的大师之剑送给他。\n\n小 L 想得到大师之剑，于是他找到了你来帮忙，请你告诉他，Link 能得到的 总收益 - 总过路费 最大是多少。", "inputFormat": "输入第一行包含两个正整数 $N,K$。\n\n接下来 $N - 1$ 行，每行包含三个整数 $x_i,y_i,v_i$，表示第 $i$ 条边连接图中的 $x_i, y_i$ 两点，它的边权为 $v_i$。", "outputFormat": "输出一行一个整数，表示答案。", "hint": "### 样例解释\n\n一种可能的最优方案为：切掉 $(2, 4, -3)$ 这条边，连接 $(3, 4, 0)$ 这条边，选择 $(p, q) = (1, 5)$。\n\n### 数据范围\n\n- 对于 $10\\%$ 的数据，$k = 0$；\n- 对于另外 $10\\%$ 的数据，$k = 1$；\n- 对于另外 $15\\%$ 的数据，$k = 2$；\n- 对于另外 $25\\%$ 的数据，$k \\leq 100$；\n- 对于其他数据，没有特殊约定。\n\n对于全部的测试数据，保证 $1 \\leq N \\leq 3 \\times 10^5$，$0 \\leq K \\leq 3 \\times 10^5$，$K \\lt N$，$1 \\leq x_i,y_i \\leq N$，$|v_i| \\leq 10^6$。\n\n### 提示\n\n题目并不难。", "locale": "zh-CN"}}}
{"pid": "P4384", "type": "P", "difficulty": 7, "samples": [["5 2\n00100\n1 2\n1 3\n", "5\n1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["字符串", "2018", "线段树", "倍增", "各省省选", "后缀自动机 SAM"], "title": "[八省联考 2018] 制胡窜", "background": "", "description": "对于一个字符串 $s$，我们定义 $|s|$ 表示 $s$ 的长度。\n\n接着，我们定义 $s_i$ 表示 $s$ 中第 $i$ 个字符，$s_{l,r}$ 表示由 $s$ 中从左往右数，第 $l$ 个字符到第 $r$ 个字符依次连接形成的字符串。特别的，如果 $l \\gt r$，或者 $l \\notin [1, |s|]$，或者 $r \\notin [1, |s|]$，我们可以认为 $s_{l,r}$ 为空串。\n\n给定一个长度为 $n$ 的仅由数字构成的字符串 $s$，现在有 $q$ 次询问，第 $k$ 次询问会给出 $s$ 的一个子串 $s_{l,r}$，请你求出有多少对 $(i, j)$，满足 $1 \\leq i \\lt j \\leq n$，$i + 1 < j$，且 $s_{l,r}$ 出现在 $s_{1,i}$ 中或 $s_{i+1,j-1}$中或 $s_{j,n}$ 中。", "inputFormat": "输入的第一行是两个整数，分别表示字符串长度 $n$ 和询问次数 $q$。\n\n第二行有一个长度为 $n$ 的只包含数字字符的字符串，表示 $s$。\n\n接下来 $q$ 行，每行两个正整数 $l$ 和 $r$，表示此次询问的子串是 $s_{l,r}$。", "outputFormat": "对于每个询问，输出一行一个整数表示答案。", "hint": "|    测试点    |     $n$     |     $q$     |               其它约定                |\n| :----------: | :-------: | :-------: | :-----------------------------------: |\n|     $1$      |   $=50$   |  $=100$   |                  无                   |\n|  $2 \\sim 3$  |  $=300$   |  $=300$   |                  无                   |\n|  $4 \\sim 5$  |  $=2000$  |  $=3000$  |                  无                   |\n|  $6 \\sim 9$  | $=100000$ | $=100000$ | $\\sum \\lvert s_{l,r} \\rvert \\le 10^6$ |\n| $10 \\sim 12$ | $=30000$  | $=50000$  |                  无                   |\n|     $13$     | $=100000$ | $=100000$ |            $s$ 中只有 $0$             |\n| $14 \\sim 20$ | $=100000$ | $=300000$ |                  无                   |\n\n\n对于所有测试数据，$1 \\le n \\le 10^5$，$1 \\le q \\le 3 \\times 10^5$，$1 \\le l \\le r \\le n$，$s$ 中只有数字字符。", "locale": "zh-CN", "translations": {"en": {"title": "[Eight Provinces Joint Exam 2018] Zhi Hu Cuan", "background": "", "description": "For a string $s$, define $|s|$ to denote the length of $s$.\n\nNext, define $s_i$ as the $i$-th character of $s$, and $s_{l,r}$ as the string formed by concatenating, from left to right, the $l$-th through the $r$-th characters of $s$. In particular, if $l \\gt r$, or $l \\notin [1, |s|]$, or $r \\notin [1, |s|]$, we consider $s_{l,r}$ to be the empty string.\n\nGiven a string $s$ of length $n$ consisting only of digits, there are $q$ queries. In the $k$-th query, a substring $s_{l,r}$ of $s$ is given. For this substring, count the number of pairs $(i, j)$ such that $1 \\le i \\lt j \\le n$, $i + 1 < j$, and $s_{l,r}$ occurs in $s_{1,i}$ or in $s_{i+1,j-1}$ or in $s_{j,n}$.", "inputFormat": "The first line contains two integers, the string length $n$ and the number of queries $q$.\n\nThe second line contains a string of length $n$ consisting only of digit characters, representing $s$.\n\nEach of the next $q$ lines contains two positive integers $l$ and $r$, indicating that the queried substring is $s_{l,r}$.", "outputFormat": "For each query, output a single integer on its own line representing the answer.", "hint": "|   Test point   |     $n$     |     $q$     |               Other conditions                |\n| :------------: | :---------: | :---------: | :-------------------------------------------: |\n|       $1$      |    $=50$    |   $=100$    |                     None                      |\n|   $2 \\sim 3$   |   $=300$    |   $=300$    |                     None                      |\n|   $4 \\sim 5$   |   $=2000$   |   $=3000$   |                     None                      |\n|   $6 \\sim 9$   |  $=100000$  |  $=100000$  | $\\sum \\lvert s_{l,r} \\rvert \\le 10^6$        |\n|  $10 \\sim 12$  |   $=30000$  |   $=50000$  |                     None                      |\n|      $13$      |  $=100000$  |  $=100000$  |       The string $s$ contains only $0$.       |\n|  $14 \\sim 20$  |  $=100000$  |  $=300000$  |                     None                      |\n\nFor all testdata, $1 \\le n \\le 10^5$, $1 \\le q \\le 3 \\times 10^5$, $1 \\le l \\le r \\le n$, and $s$ contains only digit characters.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[八省联考 2018] 制胡窜", "background": "", "description": "对于一个字符串 $s$，我们定义 $|s|$ 表示 $s$ 的长度。\n\n接着，我们定义 $s_i$ 表示 $s$ 中第 $i$ 个字符，$s_{l,r}$ 表示由 $s$ 中从左往右数，第 $l$ 个字符到第 $r$ 个字符依次连接形成的字符串。特别的，如果 $l \\gt r$，或者 $l \\notin [1, |s|]$，或者 $r \\notin [1, |s|]$，我们可以认为 $s_{l,r}$ 为空串。\n\n给定一个长度为 $n$ 的仅由数字构成的字符串 $s$，现在有 $q$ 次询问，第 $k$ 次询问会给出 $s$ 的一个子串 $s_{l,r}$，请你求出有多少对 $(i, j)$，满足 $1 \\leq i \\lt j \\leq n$，$i + 1 < j$，且 $s_{l,r}$ 出现在 $s_{1,i}$ 中或 $s_{i+1,j-1}$中或 $s_{j,n}$ 中。", "inputFormat": "输入的第一行是两个整数，分别表示字符串长度 $n$ 和询问次数 $q$。\n\n第二行有一个长度为 $n$ 的只包含数字字符的字符串，表示 $s$。\n\n接下来 $q$ 行，每行两个正整数 $l$ 和 $r$，表示此次询问的子串是 $s_{l,r}$。", "outputFormat": "对于每个询问，输出一行一个整数表示答案。", "hint": "|    测试点    |     $n$     |     $q$     |               其它约定                |\n| :----------: | :-------: | :-------: | :-----------------------------------: |\n|     $1$      |   $=50$   |  $=100$   |                  无                   |\n|  $2 \\sim 3$  |  $=300$   |  $=300$   |                  无                   |\n|  $4 \\sim 5$  |  $=2000$  |  $=3000$  |                  无                   |\n|  $6 \\sim 9$  | $=100000$ | $=100000$ | $\\sum \\lvert s_{l,r} \\rvert \\le 10^6$ |\n| $10 \\sim 12$ | $=30000$  | $=50000$  |                  无                   |\n|     $13$     | $=100000$ | $=100000$ |            $s$ 中只有 $0$             |\n| $14 \\sim 20$ | $=100000$ | $=300000$ |                  无                   |\n\n\n对于所有测试数据，$1 \\le n \\le 10^5$，$1 \\le q \\le 3 \\times 10^5$，$1 \\le l \\le r \\le n$，$s$ 中只有数字字符。", "locale": "zh-CN"}}}
{"pid": "P4385", "type": "P", "difficulty": 7, "samples": [["4\n0 0 R\n0 1 B\n1 1 R\n1 0 B", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2009", "线段树", "排序", "COCI（克罗地亚）"], "title": "[CHCI 2009 Final Exam #2] DVAPRAVCA", "background": null, "description": "给定平面上的 $N$ 个点，其中有一些是红点，其他是蓝点。\n\n现在让你找一对平行线（可以不平行于坐标轴），在满足在平行线之间没有蓝点，并且平行线不经过任何一个点的情况下，使得被夹在平行线之间的红点个数最多。你只需要计算夹在这对平行线之间的红点数量。", "inputFormat": "第一行一个整数 $N$，表示总点数。\n\n接下来 $N$ 行，每行两个整数 $x_i,y_i$ 和一个字符 `R`（红色）或者 `B`（蓝色），表示点的坐标和颜色。", "outputFormat": "一个整数表示红点数量。", "hint": "#### 数据规模与约定\n\n对于 $50\\%$ 的数据，$N\\le 350$。\n\n对于 $100\\%$ 的数据，$1\\le N\\le 1000$，$|x_i|,|y_i|\\le 10^9$，保证没有三点共线。\n\n#### 说明\n\n翻译自 [Croatian Highschool Competitions In Informatics 2009 Final Exam #2 T1 DVAPRAVCA](https://hsin.hr/2009/final/second_day/tasks.pdf)。", "locale": "zh-CN", "translations": {"en": {"title": "[CHCI 2009 Final Exam #2] DVAPRAVCA", "background": "", "description": "Given $N$ points in the plane, some are red and the others are blue.\n\nFind a pair of parallel lines (not necessarily parallel to the coordinate axes) such that there are no blue points between the lines, and the lines do not pass through any point. Among all such pairs, maximize the number of red points strictly between the lines. You only need to compute the number of red points that are between the chosen pair of parallel lines.", "inputFormat": "The first line contains an integer $N$, the total number of points.\n\nEach of the next $N$ lines contains two integers $x_i, y_i$ and a character `R` (red) or `B` (blue), specifying the point’s coordinates and color.", "outputFormat": "Output a single integer: the number of red points.", "hint": "Constraints\n\n- For $50\\%$ of the testdata, $N \\le 350$.\n- For $100\\%$ of the testdata, $1 \\le N \\le 1000$, $|x_i|, |y_i| \\le 10^9$, and no three points are collinear.\n\nNotes\n\nTranslated from [Croatian Highschool Competitions In Informatics 2009 Final Exam #2 T1 DVAPRAVCA](https://hsin.hr/2009/final/second_day/tasks.pdf).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CHCI 2009 Final Exam #2] DVAPRAVCA", "background": null, "description": "给定平面上的 $N$ 个点，其中有一些是红点，其他是蓝点。\n\n现在让你找一对平行线（可以不平行于坐标轴），在满足在平行线之间没有蓝点，并且平行线不经过任何一个点的情况下，使得被夹在平行线之间的红点个数最多。你只需要计算夹在这对平行线之间的红点数量。", "inputFormat": "第一行一个整数 $N$，表示总点数。\n\n接下来 $N$ 行，每行两个整数 $x_i,y_i$ 和一个字符 `R`（红色）或者 `B`（蓝色），表示点的坐标和颜色。", "outputFormat": "一个整数表示红点数量。", "hint": "#### 数据规模与约定\n\n对于 $50\\%$ 的数据，$N\\le 350$。\n\n对于 $100\\%$ 的数据，$1\\le N\\le 1000$，$|x_i|,|y_i|\\le 10^9$，保证没有三点共线。\n\n#### 说明\n\n翻译自 [Croatian Highschool Competitions In Informatics 2009 Final Exam #2 T1 DVAPRAVCA](https://hsin.hr/2009/final/second_day/tasks.pdf)。", "locale": "zh-CN"}}}
{"pid": "P4386", "type": "P", "difficulty": 7, "samples": [["3\n1 0\n2 0\n4 6\n0 1\n0 2\n1 2\n1 3\n2 3\n3 0", "YES\nNO\nYES"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2015", "各省省选", "上海"], "title": "[SHOI2015] 零件组装机", "background": "", "description": "曾经发明了激光发生器的发明家 SHTSC 又公开了他的新发明：零件组装机——一种可以生产并组装零件的神秘装置。\n\n一个零件是一张顶点由 $0$ 到 $n-1$ 标号的无向图，零件组装机有以下两种功能：\n\n 1. 生产一个仅有一个顶点标号为 $0$ 而没有边的零件。\n\n 2. 组合两个已有的零件 $G_1$、$G_2$，且 $G_2$ 的顶点数 $m$ 大于等于 $G_1$ 的顶点数 $n$ ，得到新的零件 $G$ 。$G$ 的顶点集合是 $G_1,G_2$ 顶点集合的并集，并且 $G_2$ 的顶点 $i(0\\leq i < m)$ 被重新标号为  $n+i$ 。$G$ 的边集是 $G_1,G_2$ 边集的并集再对所有标号为 $a(a \\geq n)$ 的顶点添加一条连接$(a,a \\bmod n)$的无向边。\n\n![](https://cdn.luogu.com.cn/upload/pic/17059.png)\n\n现在 SHTSC 正在思考，对于一个给定的零件，能否由零件组装机生产组装得到。注意：零件是带标号的，这意味着两个零件即使仅有标号不同也被视为不同的零件。为了帮助你理解问题，SHTSC 特地给了你顶点数 $\\le 5$的所有零件的图例。\n\n![](https://cdn.luogu.com.cn/upload/pic/17060.png)", "inputFormat": "第一行一个整数 $t$ ，表示有 $t$ 组数据。\n\n每组数据的第一行有两个整数 $n$，$m$，表示某个带标号的无向图有 $n$ 个从 $0$ 到 $n - 1$ 标号的顶点，以及 $m$ 条边。 接下来 $m$ 行，每行两个整数 $u,v$ ，表示一条从 $u$ 到 $v$ 的无向边。", "outputFormat": "对于每组数据，输出一行。如果这个无向图可以被零件制造机制造，输出 `YES`，否则输出 `NO`。", "hint": "对于 $5\\%$ 的数据，图给定的图联通且 $m = n - 1$；  \n对于另 $15\\%$ 的数据，$n \\leq 5$；  \n对于 $50\\%$ 的数据，$n \\leq 1000$；  \n对于所有测试点，$t \\leq 10$，$n,m \\leq 100000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2015] Parts Assembly Machine", "background": "", "description": "SHTSC, the inventor who once created a laser generator, has now unveiled his new invention: the Parts Assembly Machine — a mysterious device that can produce and assemble parts.\n\nA part is an undirected graph whose vertices are labeled from $0$ to $n-1$, and the machine has the following two functions:\n\n1. Produce a part that has only one vertex labeled $0$ and no edges.\n2. Combine two existing parts $G_1$ and $G_2$, with the number of vertices of $G_2$ being $m$ and greater than or equal to the number of vertices of $G_1$, which is $n$, to obtain a new part $G$. The vertex set of $G$ is the union of the vertex sets of $G_1$ and $G_2$, and vertex $i(0\\leq i < m)$ of $G_2$ is relabeled as $n+i$. The edge set of $G$ is the union of the edge sets of $G_1$ and $G_2$, then for every vertex with label $a(a \\geq n)$, add an undirected edge connecting $(a,a \\bmod n)$.\n\n![](https://cdn.luogu.com.cn/upload/pic/17059.png)\n\nNow SHTSC is wondering whether a given part can be produced by the machine. Note that parts are labeled, which means two parts are considered different even if they only differ by labels. To help you understand the problem, SHTSC has provided diagrams of all parts with number of vertices $\\le 5$.\n\n![](https://cdn.luogu.com.cn/upload/pic/17060.png)", "inputFormat": "The first line contains an integer $t$, the number of test cases.\n\nFor each test case, the first line contains two integers $n$ and $m$, indicating a labeled undirected graph with $n$ vertices labeled from $0$ to $n - 1$ and $m$ edges. Then $m$ lines follow, each containing two integers $u,v$, representing an undirected edge between $u$ and $v$.", "outputFormat": "For each test case, output one line. If the undirected graph can be produced by the Parts Assembly Machine, output `YES`; otherwise, output `NO`.", "hint": "For $5\\%$ of the testdata, the given graph is connected and $m = n - 1$.  \nFor another $15\\%$ of the testdata, $n \\leq 5$.  \nFor $50\\%$ of the testdata, $n \\leq 1000$.  \nFor all test points, $t \\leq 10$, $n, m \\leq 100000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2015] 零件组装机", "background": "", "description": "曾经发明了激光发生器的发明家 SHTSC 又公开了他的新发明：零件组装机——一种可以生产并组装零件的神秘装置。\n\n一个零件是一张顶点由 $0$ 到 $n-1$ 标号的无向图，零件组装机有以下两种功能：\n\n 1. 生产一个仅有一个顶点标号为 $0$ 而没有边的零件。\n\n 2. 组合两个已有的零件 $G_1$、$G_2$，且 $G_2$ 的顶点数 $m$ 大于等于 $G_1$ 的顶点数 $n$ ，得到新的零件 $G$ 。$G$ 的顶点集合是 $G_1,G_2$ 顶点集合的并集，并且 $G_2$ 的顶点 $i(0\\leq i < m)$ 被重新标号为  $n+i$ 。$G$ 的边集是 $G_1,G_2$ 边集的并集再对所有标号为 $a(a \\geq n)$ 的顶点添加一条连接$(a,a \\bmod n)$的无向边。\n\n![](https://cdn.luogu.com.cn/upload/pic/17059.png)\n\n现在 SHTSC 正在思考，对于一个给定的零件，能否由零件组装机生产组装得到。注意：零件是带标号的，这意味着两个零件即使仅有标号不同也被视为不同的零件。为了帮助你理解问题，SHTSC 特地给了你顶点数 $\\le 5$的所有零件的图例。\n\n![](https://cdn.luogu.com.cn/upload/pic/17060.png)", "inputFormat": "第一行一个整数 $t$ ，表示有 $t$ 组数据。\n\n每组数据的第一行有两个整数 $n$，$m$，表示某个带标号的无向图有 $n$ 个从 $0$ 到 $n - 1$ 标号的顶点，以及 $m$ 条边。 接下来 $m$ 行，每行两个整数 $u,v$ ，表示一条从 $u$ 到 $v$ 的无向边。", "outputFormat": "对于每组数据，输出一行。如果这个无向图可以被零件制造机制造，输出 `YES`，否则输出 `NO`。", "hint": "对于 $5\\%$ 的数据，图给定的图联通且 $m = n - 1$；  \n对于另 $15\\%$ 的数据，$n \\leq 5$；  \n对于 $50\\%$ 的数据，$n \\leq 1000$；  \n对于所有测试点，$t \\leq 10$，$n,m \\leq 100000$。\n", "locale": "zh-CN"}}}
{"pid": "P4387", "type": "P", "difficulty": 3, "samples": [["2\n5\n1 2 3 4 5\n5 4 3 2 1\n4\n1 2 3 4\n2 4 1 3", "Yes\nNo"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "栈"], "title": "【深基15.习9】验证栈序列", "background": null, "description": "给出两个序列 pushed 和 poped 两个序列，其取值从 $1$ 到 $n(n \\le 100000)$。已知入栈序列是 pushed，如果出栈序列有可能是 poped，则输出 `Yes`，否则输出 `No`。请注意，给定的序列一定是一个**排列**（即没有重复数字）。\n\n为了防止骗分，每个测试点有多组数据，不超过 $5$ 组。", "inputFormat": "第一行一个整数 $q$，询问次数。\n\n接下来 $q$ 个询问，对于每个询问：\n\n第一行一个整数 $n$ 表示序列长度；\n\n第二行 $n$ 个整数表示入栈序列；\n\n第三行 $n$ 个整数表示出栈序列；", "outputFormat": "对于每个询问输出答案。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[Deep Basics 15.Exercise 9] Validate Stack Sequences", "background": "", "description": "Given two sequences pushed and poped, whose values range from $1$ to $n$ $(n \\le 100000)$. The push sequence is known to be pushed. If the pop sequence could be poped, output `Yes`; otherwise output `No`. Note that the given sequences are guaranteed to be a **permutation** (i.e., there are no repeated numbers).\n\nTo prevent hacking, each test point contains multiple testdata sets, no more than $5$ sets.", "inputFormat": "The first line contains an integer $q$, the number of queries.\n\nNext come $q$ queries. For each query:\n\nThe first line contains an integer $n$, the length of the sequence.\n\nThe second line contains $n$ integers, the push sequence.\n\nThe third line contains $n$ integers, the pop sequence.", "outputFormat": "For each query, output the answer.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【深基15.习9】验证栈序列", "background": null, "description": "给出两个序列 pushed 和 poped 两个序列，其取值从 $1$ 到 $n(n \\le 100000)$。已知入栈序列是 pushed，如果出栈序列有可能是 poped，则输出 `Yes`，否则输出 `No`。请注意，给定的序列一定是一个**排列**（即没有重复数字）。\n\n为了防止骗分，每个测试点有多组数据，不超过 $5$ 组。", "inputFormat": "第一行一个整数 $q$，询问次数。\n\n接下来 $q$ 个询问，对于每个询问：\n\n第一行一个整数 $n$ 表示序列长度；\n\n第二行 $n$ 个整数表示入栈序列；\n\n第三行 $n$ 个整数表示出栈序列；", "outputFormat": "对于每个询问输出答案。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P4388", "type": "P", "difficulty": 5, "samples": [["4", "4"]], "limits": {"time": [350, 350, 350, 350, 350, 350, 350, 350, 350, 350], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "数论", "枚举", "素数判断,质数,筛法", "最大公约数 gcd", "欧拉函数"], "title": "付公主的矩形", "background": "付公主月考炸了，感到非常郁闷。", "description": "为了排解心中的怒气，她造了大量的稻草人来发泄。每天付公主都会把一些稻草人摆成一个 $ R*C $ 的矩形，矩形的每个方格上都有一个稻草人。然后她站在这个矩形的左上角，向矩形的右下角射箭。付公主的箭术过人，她能穿透任意多的稻草人。弓箭经过的方格上的稻草人难逃厄运，报废掉了。看着被毁坏的稻草人，付公主开心了一些。\n\n但是制造稻草人需要大量的金钱，所以付公主不希望坏掉太多的稻草人，所以她每天都选择毁坏掉 $ N $ 个稻草人。付公主还是个喜新厌旧的人，她希望每天能看到一种不同的稻草人摆放矩形。矩形是可以旋转的，即 $ R\\times C $ 和 $ C\\times R $ 等价。她毫不费力地算出了摆放方案数，于是她决定刁难你一下。不甘示弱的你决定写个程序计算这个数来提交付公主的答卷。", "inputFormat": "输入只有一行且只有一个数 $N$（$1\\le N\\le 10^6$），代表每次被毁坏的稻草人数量。", "outputFormat": "一个整数表示总方案数。", "hint": "样例解释：\n![](https://cdn.luogu.com.cn/upload/pic/16262.png)\n\n对于 $40\\%$ 的数据，$1 \\le N \\le 10^4$。\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10^6$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Princess Fu's Rectangle", "background": "Princess Fu did poorly in the monthly exam and felt very upset.", "description": "To vent her anger, she made a large number of scarecrows. Every day, Princess Fu arranges some scarecrows into an $ R*C $ rectangle, with one scarecrow on each cell of the grid. Then she stands at the top-left corner and shoots an arrow toward the bottom-right corner of the rectangle. Princess Fu is an excellent archer; she can pierce through any number of scarecrows. Any scarecrow on a cell that the arrow passes through is destroyed. Seeing the ruined scarecrows makes Princess Fu a little happier.\n\nHowever, making scarecrows costs a lot of money, so Princess Fu does not want to destroy too many scarecrows. Therefore, each day she chooses to destroy exactly $ N $ scarecrows. Princess Fu is also fickle; she wants to see a different rectangle arrangement each day. Rectangles are considered up to rotation, i.e., $ R\\times C $ and $ C\\times R $ are equivalent. She easily computed the number of arrangements, and decided to make things difficult for you. Unwilling to admit defeat, you decide to write a program to compute this number and submit it as your answer to Princess Fu.", "inputFormat": "The input consists of a single line with one integer $ N $ ($ 1\\le N\\le 10^6 $), representing the number of scarecrows destroyed each time.", "outputFormat": "Output a single integer representing the total number of arrangements.", "hint": "Sample explanation:\n![](https://cdn.luogu.com.cn/upload/pic/16262.png)\n\nFor $ 40\\% $ of the testdata, $ 1 \\le N \\le 10^4 $.\n\nFor $ 100\\% $ of the testdata, $ 1 \\le N \\le 10^6 $.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "付公主的矩形", "background": "付公主月考炸了，感到非常郁闷。", "description": "为了排解心中的怒气，她造了大量的稻草人来发泄。每天付公主都会把一些稻草人摆成一个 $ R*C $ 的矩形，矩形的每个方格上都有一个稻草人。然后她站在这个矩形的左上角，向矩形的右下角射箭。付公主的箭术过人，她能穿透任意多的稻草人。弓箭经过的方格上的稻草人难逃厄运，报废掉了。看着被毁坏的稻草人，付公主开心了一些。\n\n但是制造稻草人需要大量的金钱，所以付公主不希望坏掉太多的稻草人，所以她每天都选择毁坏掉 $ N $ 个稻草人。付公主还是个喜新厌旧的人，她希望每天能看到一种不同的稻草人摆放矩形。矩形是可以旋转的，即 $ R\\times C $ 和 $ C\\times R $ 等价。她毫不费力地算出了摆放方案数，于是她决定刁难你一下。不甘示弱的你决定写个程序计算这个数来提交付公主的答卷。", "inputFormat": "输入只有一行且只有一个数 $N$（$1\\le N\\le 10^6$），代表每次被毁坏的稻草人数量。", "outputFormat": "一个整数表示总方案数。", "hint": "样例解释：\n![](https://cdn.luogu.com.cn/upload/pic/16262.png)\n\n对于 $40\\%$ 的数据，$1 \\le N \\le 10^4$。\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10^6$。\n", "locale": "zh-CN"}}}
{"pid": "P4389", "type": "P", "difficulty": 6, "samples": [["2 4\n1 2", "1\n2\n2\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "O2优化", "背包 DP", "生成函数", "快速傅里叶变换 FFT"], "title": "付公主的背包", "background": "付公主有一个可爱的背包qwq\n\n", "description": "这个背包最多可以装 $10^5$ 大小的东西\n\n付公主有 $n$ 种商品，她要准备出摊了\n\n每种商品体积为 $v_i$，都有无限件\n\n给定 $m$，对于 $s\\in [1,m]$，请你回答用这些商品恰好装 $s$ 体积的方案数\n", "inputFormat": "第一行两个正整数 $n,m$。\n第二行 $n$ 个正整数，表示每种商品的体积。\n", "outputFormat": "输出 $m$ 行，第 $i$ 行代表 $s=i$ 时方案数，对 $998244353$ 取模。", "hint": "【数据范围】  \n对于 $30\\%$ 的数据，$1\\le n,m \\le 3000$；  \n对于 $60\\%$ 的数据，纯随机生成；   \n对于 $100\\%$ 的数据， $1\\le n,m \\le 10^5$，$1\\le v_i \\le m$。", "locale": "zh-CN", "translations": {"en": {"title": "Princess Fu's Backpack", "background": "Princess Fu has a cute backpack qwq.", "description": "This backpack can hold a total size of at most $10^5$.\n\nPrincess Fu has $n$ types of goods and she is about to set up a stall.\n\nEach type has volume $v_i$, and there are infinitely many pieces available.\n\nGiven $m$, for $s \\in [1,m]$, please answer the number of ways to fill exactly volume $s$ using these goods.", "inputFormat": "The first line contains two positive integers $n, m$.\nThe second line contains $n$ positive integers, representing the volume of each type of good.", "outputFormat": "Output $m$ lines, where the $i$-th line represents the number of ways when $s = i$, taken modulo $998244353$.", "hint": "Constraints  \nFor 30% of the testdata, $1 \\le n, m \\le 3000$.  \nFor 60% of the testdata, purely randomly generated.  \nFor 100% of the testdata, $1 \\le n, m \\le 10^5$, $1 \\le v_i \\le m$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "付公主的背包", "background": "付公主有一个可爱的背包qwq\n\n", "description": "这个背包最多可以装 $10^5$ 大小的东西\n\n付公主有 $n$ 种商品，她要准备出摊了\n\n每种商品体积为 $v_i$，都有无限件\n\n给定 $m$，对于 $s\\in [1,m]$，请你回答用这些商品恰好装 $s$ 体积的方案数\n", "inputFormat": "第一行两个正整数 $n,m$。\n第二行 $n$ 个正整数，表示每种商品的体积。\n", "outputFormat": "输出 $m$ 行，第 $i$ 行代表 $s=i$ 时方案数，对 $998244353$ 取模。", "hint": "【数据范围】  \n对于 $30\\%$ 的数据，$1\\le n,m \\le 3000$；  \n对于 $60\\%$ 的数据，纯随机生成；   \n对于 $100\\%$ 的数据， $1\\le n,m \\le 10^5$，$1\\le v_i \\le m$。", "locale": "zh-CN"}}}
{"pid": "P4390", "type": "P", "difficulty": 6, "samples": [["0 4\n1 2 3 3\n2 1 1 3 3\n1 2 2 2\n2 2 2 3 4\n3", "3\n5\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "树状数组", "cdq 分治", "分治", "排序", "BalkanOI（巴尔干半岛）"], "title": "[BalkanOI 2007] Mokia 摩基亚", "background": "", "description": "摩尔瓦多的移动电话公司摩基亚（Mokia）设计出了一种新的用户定位系统。和其他的定位系统一样，它能够迅速回答任何形如 “用户 C 的位置在哪？” 的问题，精确到毫米。但其真正高科技之处在于，它能够回答形如 “给定区域内有多少名用户？” 的问题。\n\n在定位系统中，世界被认为是一个 $w\\times w$ 的正方形区域，由 $1\\times 1$ 的方格组成。每个方格都有一个坐标 $(x, y)$，$1\\leq x,y\\leq w$。坐标的编号从 $1$ 开始。对于一个 $4\\times 4$ 的正方形，就有 $1\\leq x\\leq 4$，$1\\leq y\\leq 4$（如图）：\n\n![](https://cdn.luogu.com.cn/upload/pic/17271.png)\n\n请帮助 Mokia 公司编写一个程序来计算在某个矩形区域内有多少名用户。", "inputFormat": "有三种命令，意义如下：\n\n|命令|参数|意义|\n|:-:|:-:|:-:|\n|$0$|$w$|初始化一个全零矩阵。本命令仅开始时出现一次。|\n|$1$|$x\\ y\\ a$|向方格 $(x, y)$ 中添加 $a$ 个用户。$a$ 是正整数。|\n|$2$|$x_1\\ y_1\\ x_2\\ y_2$|查询 $x_1\\leq x\\leq x_2$，$y_1\\leq y\\leq y_2$ 所规定的矩形中的用户数量。|\n|$3$|无参数|结束程序。本命令仅结束时出现一次。|\n\n输入共若干行，每行有若干个整数，表示一个命令。", "outputFormat": "对所有命令 $2$，输出一个一行整数，即当前询问矩形内的用户数量。", "hint": "#### 数据规模与约定\n\n\n对于 $100\\%$ 的数据，保证：\n- $1\\leq w\\leq 2\\times 10 ^ 6$。\n- $1\\leq x_1\\leq x_2\\leq w$，$1\\leq y_1\\leq y_2\\leq w$，$1\\leq x,y\\leq w$，$0<a\\leq 10000$。\n- 命令 $1$ 不超过 $160000$ 个。\n- 命令 $2$ 不超过 $10000$ 个。", "locale": "zh-CN", "translations": {"en": {"title": "[BalkanOI 2007] Mokia", "background": "", "description": "The mobile phone company Mokia in Morvado has designed a new user localization system. Like other localization systems, it can quickly answer any question of the form “Where is user C?”, accurate to the millimeter. But its truly high-tech feature is that it can answer questions like “How many users are there in a given area?”.\n\nIn this localization system, the world is considered a $w\\times w$ square region, composed of $1\\times 1$ cells. Each cell has a coordinate $(x, y)$, $1\\leq x,y\\leq w$. Coordinates are 1-indexed. For a $4\\times 4$ square, we have $1\\leq x\\leq 4$, $1\\leq y\\leq 4$ (see the figure).\n\n![](https://cdn.luogu.com.cn/upload/pic/17271.png)\n\nPlease help Mokia write a program to compute how many users are in a rectangular region.", "inputFormat": "There are three types of commands with the following meanings:\n\n| Command | Parameters | Meaning |\n|:-:|:-:|:-:|\n| $0$ | $w$ | Initialize an all-zero matrix. This command appears exactly once at the beginning. |\n| $1$ | $x\\ y\\ a$ | Add $a$ users to cell $(x, y)$. $a$ is a positive integer. |\n| $2$ | $x_1\\ y_1\\ x_2\\ y_2$ | Query the number of users in the rectangle defined by $x_1\\leq x\\leq x_2$, $y_1\\leq y\\leq y_2$. |\n| $3$ | none | End the program. This command appears exactly once at the end. |\n\nThe input consists of multiple lines. Each line contains several integers representing one command.", "outputFormat": "For every command $2$, output one integer on a separate line: the number of users currently in the queried rectangle.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that:\n- $1\\leq w\\leq 2\\times 10 ^ 6$.\n- $1\\leq x_1\\leq x_2\\leq w$, $1\\leq y_1\\leq y_2\\leq w$, $1\\leq x,y\\leq w$, $0<a\\leq 10000$.\n- The number of command $1$ does not exceed $160000$.\n- The number of command $2$ does not exceed $10000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalkanOI 2007] Mokia 摩基亚", "background": "", "description": "摩尔瓦多的移动电话公司摩基亚（Mokia）设计出了一种新的用户定位系统。和其他的定位系统一样，它能够迅速回答任何形如 “用户 C 的位置在哪？” 的问题，精确到毫米。但其真正高科技之处在于，它能够回答形如 “给定区域内有多少名用户？” 的问题。\n\n在定位系统中，世界被认为是一个 $w\\times w$ 的正方形区域，由 $1\\times 1$ 的方格组成。每个方格都有一个坐标 $(x, y)$，$1\\leq x,y\\leq w$。坐标的编号从 $1$ 开始。对于一个 $4\\times 4$ 的正方形，就有 $1\\leq x\\leq 4$，$1\\leq y\\leq 4$（如图）：\n\n![](https://cdn.luogu.com.cn/upload/pic/17271.png)\n\n请帮助 Mokia 公司编写一个程序来计算在某个矩形区域内有多少名用户。", "inputFormat": "有三种命令，意义如下：\n\n|命令|参数|意义|\n|:-:|:-:|:-:|\n|$0$|$w$|初始化一个全零矩阵。本命令仅开始时出现一次。|\n|$1$|$x\\ y\\ a$|向方格 $(x, y)$ 中添加 $a$ 个用户。$a$ 是正整数。|\n|$2$|$x_1\\ y_1\\ x_2\\ y_2$|查询 $x_1\\leq x\\leq x_2$，$y_1\\leq y\\leq y_2$ 所规定的矩形中的用户数量。|\n|$3$|无参数|结束程序。本命令仅结束时出现一次。|\n\n输入共若干行，每行有若干个整数，表示一个命令。", "outputFormat": "对所有命令 $2$，输出一个一行整数，即当前询问矩形内的用户数量。", "hint": "#### 数据规模与约定\n\n\n对于 $100\\%$ 的数据，保证：\n- $1\\leq w\\leq 2\\times 10 ^ 6$。\n- $1\\leq x_1\\leq x_2\\leq w$，$1\\leq y_1\\leq y_2\\leq w$，$1\\leq x,y\\leq w$，$0<a\\leq 10000$。\n- 命令 $1$ 不超过 $160000$ 个。\n- 命令 $2$ 不超过 $10000$ 个。", "locale": "zh-CN"}}}
{"pid": "P4391", "type": "P", "difficulty": 4, "samples": [["8\ncabcabca", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2009", "前缀和", "KMP 算法", "BalticOI（波罗的海）"], "title": "[BalticOI 2009] Radio Transmission 无线传输", "background": "", "description": "给你一个字符串 $s_1$，它是由某个字符串 $s_2$ 不断自我连接形成的（保证至少重复 $2$ 次）。但是字符串 $s_2$ 是不确定的，现在只想知道它的最短长度是多少。", "inputFormat": "第一行一个整数 $L$，表示给出字符串的长度。 \n\n第二行给出字符串 $s_1$ 的一个子串，全由小写字母组成。  ", "outputFormat": "仅一行，表示 $s_2$ 的最短长度。", "hint": "#### 样例输入输出 1 解释\n对于样例，我们可以利用 $\\texttt{abc}$ 不断自我连接得到 $\\texttt{abcabcabcabc}$，读入的 $\\texttt{cabcabca}$，是它的子串。\n\n#### 规模与约定\n对于全部的测试点，保证 $1\\le L \\le 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2009] Radio Transmission", "background": "", "description": "You are given a string $s_1$ that is formed by repeatedly concatenating some string $s_2$ (guaranteed to repeat at least $2$ times). However, $s_2$ is unknown. You only need to determine the shortest possible length of $s_2$.", "inputFormat": "The first line contains an integer $L$, which is the length of the given string.\n\nThe second line contains a substring of $s_1$, consisting entirely of lowercase letters.", "outputFormat": "Output a single line containing the shortest length of $s_2$.", "hint": "#### Explanation for Sample Input/Output 1\nFor the sample, we can obtain $\\texttt{abcabcabcabc}$ by repeatedly concatenating $\\texttt{abc}$. The input $\\texttt{cabcabca}$ is its substring.\n\n#### Constraints\nFor all test points, it is guaranteed that $1 \\le L \\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2009] Radio Transmission 无线传输", "background": "", "description": "给你一个字符串 $s_1$，它是由某个字符串 $s_2$ 不断自我连接形成的（保证至少重复 $2$ 次）。但是字符串 $s_2$ 是不确定的，现在只想知道它的最短长度是多少。", "inputFormat": "第一行一个整数 $L$，表示给出字符串的长度。 \n\n第二行给出字符串 $s_1$ 的一个子串，全由小写字母组成。  ", "outputFormat": "仅一行，表示 $s_2$ 的最短长度。", "hint": "#### 样例输入输出 1 解释\n对于样例，我们可以利用 $\\texttt{abc}$ 不断自我连接得到 $\\texttt{abcabcabcabc}$，读入的 $\\texttt{cabcabca}$，是它的子串。\n\n#### 规模与约定\n对于全部的测试点，保证 $1\\le L \\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P4392", "type": "P", "difficulty": 3, "samples": [["7 2 0\n0 1 1 2 3 2 2", "2\n6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2007", "线段树", "树状数组", "单调队列", "ST 表", "BalticOI（波罗的海）"], "title": "[BalticOI 2007] Sound 静音问题", "background": "", "description": "数字录音中，声音是用表示空气压力的数字序列描述的，序列中的每个值称为一个采样，每个采样之间间隔一定的时间。 \n\n很多声音处理任务都需要将录到的声音分成由静音隔开的几段非静音段。为了避免分成过多或者过少的非静音段，静音通常是这样定义的：$m$ 个采样的序列，该序列中采样的最大值和最小值之差不超过一个特定的阈值 $c$。 \n\n请你写一个程序，检测 $n$ 个采样中的静音。", "inputFormat": "第一行有三个整数 $n,m,c$（$1\\le n\\le10^6$，$1\\le m\\le10^4$，$0\\le c\\le10^4$），分别表示总的采样数、静音的长度和静音中允许的最大噪音程度。\n\n第 $2$ 行 $n$ 个整数 $a_i$（$0\\le a_i\\le 10^6$），表示声音的每个采样值，每两个整数之间用空格隔开。", "outputFormat": "列出了所有静音的起始位置 $i$（$i$ 满足$\\max\\{a_i,a_{i+1}\\cdots a_{i+m-1}\\}-\\min\\{a_i,a_{i+1}\\cdots a_{i+m-1}\\}\\le c$），每行表示一段静音的起始位置，按照出现的先后顺序输出。如果没有静音则输出 `NONE`。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2007] Sound Silence Problem", "background": "", "description": "In digital audio recording, sound is represented by a sequence of numbers describing air pressure, with each value called a sample, and adjacent samples separated by equal time intervals.\n\nMany audio processing tasks need to split the recorded sound into non-silent segments separated by silence. To avoid producing too many or too few non-silent segments, silence is defined as follows: a sequence of $m$ samples in which the difference between the maximum and the minimum sample values does not exceed a given threshold $c$.\n\nWrite a program to detect silence within $n$ samples.", "inputFormat": "The first line contains three integers $n, m, c$ ($1 \\le n \\le 10^6$, $1 \\le m \\le 10^4$, $0 \\le c \\le 10^4$), denoting the total number of samples, the length of a silence segment, and the maximum allowed noise level within a silence segment.\n\nThe second line contains $n$ integers $a_i$ ($0 \\le a_i \\le 10^6$), the value of each sample, separated by spaces.", "outputFormat": "List all starting positions $i$ of silence segments (i.e., those $i$ such that $\\max\\{a_i, a_{i+1}, \\ldots, a_{i+m-1}\\} - \\min\\{a_i, a_{i+1}, \\ldots, a_{i+m-1}\\} \\le c$). Output one starting position per line, in order of appearance. If there is no silence, output `NONE`.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2007] Sound 静音问题", "background": "", "description": "数字录音中，声音是用表示空气压力的数字序列描述的，序列中的每个值称为一个采样，每个采样之间间隔一定的时间。 \n\n很多声音处理任务都需要将录到的声音分成由静音隔开的几段非静音段。为了避免分成过多或者过少的非静音段，静音通常是这样定义的：$m$ 个采样的序列，该序列中采样的最大值和最小值之差不超过一个特定的阈值 $c$。 \n\n请你写一个程序，检测 $n$ 个采样中的静音。", "inputFormat": "第一行有三个整数 $n,m,c$（$1\\le n\\le10^6$，$1\\le m\\le10^4$，$0\\le c\\le10^4$），分别表示总的采样数、静音的长度和静音中允许的最大噪音程度。\n\n第 $2$ 行 $n$ 个整数 $a_i$（$0\\le a_i\\le 10^6$），表示声音的每个采样值，每两个整数之间用空格隔开。", "outputFormat": "列出了所有静音的起始位置 $i$（$i$ 满足$\\max\\{a_i,a_{i+1}\\cdots a_{i+m-1}\\}-\\min\\{a_i,a_{i+1}\\cdots a_{i+m-1}\\}\\le c$），每行表示一段静音的起始位置，按照出现的先后顺序输出。如果没有静音则输出 `NONE`。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4393", "type": "P", "difficulty": 3, "samples": [["3\n1\n2\n3", "5"]], "limits": {"time": [1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000]}, "tags": ["模拟", "贪心", "2007", "线段树", "BalticOI（波罗的海）"], "title": "[BalticOI 2007] Sequence 序列问题", "background": "", "description": "对于一个给定的序列 $a _ 1, \\cdots, a _ n$，我们对它进行一个操作 $\\text{reduce}(i)$，该操作将数列中的元素 $a _ i$ 和 $a _ {i+1}$ 用一个元素 $\\max(a _ i,a _ {i+1})$ 替代，这样得到一个比原来序列短的新序列。这一操作的代价是 $\\max(a _ i,a _ {i+1})$。进行 $n-1$ 次该操作后，可以得到一个长度为 $1$ 的序列。\n\n我们的任务是计算代价最小的 $\\text{reduce}$ 操作步骤，将给定的序列变成长度为 $1$ 的序列。", "inputFormat": "第一行为一个整数 $n$（$1 \\leq n \\leq 10 ^6$），表示给定序列的长度。\n\n接下来的 $n$ 行，每行一个整数 $a _ i$（$0 \\leq a _ i \\leq 10 ^ 9$），为序列中的元素。", "outputFormat": "只有一行，为一个整数，即将序列变成一个元素的最小代价。 \n", "hint": "### 数据规模与约定\n\n- 对于 $30\\%$ 的测试数据，$n\\le 500$； \n- 对于 $50\\%$ 的测试数据，$n \\le 20000$；\n- 对于 $100\\%$ 的测试数据，$1 \\le n \\le 10^6$，$0 \\le a_i \\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2007] Sequence Problem", "background": "", "description": "Given a sequence $a _ 1, \\cdots, a _ n$, we perform an operation $\\text{reduce}(i)$ that replaces the two elements $a _ i$ and $a _ {i+1}$ with a single element $\\max(a _ i,a _ {i+1})$, producing a new sequence shorter than the original. The cost of this operation is $\\max(a _ i,a _ {i+1})$. After performing this operation $n-1$ times, we obtain a sequence of length $1$.\n\nOur task is to compute the sequence of $\\text{reduce}$ operations with the minimum total cost to turn the given sequence into a sequence of length $1$.", "inputFormat": "The first line contains an integer $n$ ($1 \\leq n \\leq 10 ^6$), the length of the given sequence.\n\nThe next $n$ lines each contain an integer $a _ i$ ($0 \\leq a _ i \\leq 10 ^ 9$), the elements of the sequence.", "outputFormat": "Output a single line with one integer: the minimum total cost to reduce the sequence to a single element.", "hint": "- For $30\\%$ of the testdata, $n\\le 500$.\n- For $50\\%$ of the testdata, $n \\le 20000$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 10^6$, $0 \\le a_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2007] Sequence 序列问题", "background": "", "description": "对于一个给定的序列 $a _ 1, \\cdots, a _ n$，我们对它进行一个操作 $\\text{reduce}(i)$，该操作将数列中的元素 $a _ i$ 和 $a _ {i+1}$ 用一个元素 $\\max(a _ i,a _ {i+1})$ 替代，这样得到一个比原来序列短的新序列。这一操作的代价是 $\\max(a _ i,a _ {i+1})$。进行 $n-1$ 次该操作后，可以得到一个长度为 $1$ 的序列。\n\n我们的任务是计算代价最小的 $\\text{reduce}$ 操作步骤，将给定的序列变成长度为 $1$ 的序列。", "inputFormat": "第一行为一个整数 $n$（$1 \\leq n \\leq 10 ^6$），表示给定序列的长度。\n\n接下来的 $n$ 行，每行一个整数 $a _ i$（$0 \\leq a _ i \\leq 10 ^ 9$），为序列中的元素。", "outputFormat": "只有一行，为一个整数，即将序列变成一个元素的最小代价。 \n", "hint": "### 数据规模与约定\n\n- 对于 $30\\%$ 的测试数据，$n\\le 500$； \n- 对于 $50\\%$ 的测试数据，$n \\le 20000$；\n- 对于 $100\\%$ 的测试数据，$1 \\le n \\le 10^6$，$0 \\le a_i \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4394", "type": "P", "difficulty": 3, "samples": [["4\n1 3 2 4", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "排序", "背包 DP"], "title": "选举", "background": "", "description": "Byteland 国的居民最近一直为议会选举投票。现在，当结果公布的时候，党派不得不决定联合组建政府。 \n\n每个党派都会获得议会中的一定席位。联合政府由这些党派中的一部分组成，他们在议会中的席位数之和**严格大于**总席位数的一半。对于联合政府来说，席位越多越好。\n\n一个**过剩**的联合政府是指联合政府中的一个党派被移出后，剩余的联合政府在国会中仍有过半数的席位。\n\n请写一个程序能够找到一个在议会中有着**最大可能席位数**且**不过剩**的联合政府。", "inputFormat": "标准输出的第一行包含一个整数 $n$，表示参加选举的党派数。党派被从 $1$ 到 $n$ 编号。\n\n第二行包含 $n$ 个非负整数 $a_1,\\dots ,a_n$，被一个空格隔开，$a_i$ 是第 $i$ 个党派获得的席位数。你可以假设国会中的中的总席位数为小于等于 $10^5$ 的正整数。", "outputFormat": "包含一个整数，表示最大可能席位数。", "hint": "样例解释：选择第二个政党和第四个。\n\n对于全部数据，$1\\le n\\le 300$。", "locale": "zh-CN", "translations": {"en": {"title": "Election", "background": "", "description": "The residents of Byteland have recently voted in a parliamentary election. Now, as the results are announced, the parties must decide on forming a coalition government.\n\nEach party obtains a certain number of seats in the parliament. A coalition government consists of a subset of these parties whose total number of seats is **strictly greater than** half of all seats. For a coalition, having more seats is better.\n\nAn **excessive** coalition is one in which, after removing one party from the coalition, the remaining coalition still holds a majority of seats in the parliament.\n\nWrite a program to find a coalition with the **maximum possible** number of seats in the parliament that is **not excessive**.", "inputFormat": "The first line of standard input contains an integer $ n $, the number of parties in the election. The parties are numbered from $ 1 $ to $ n $.\n\nThe second line contains $ n $ non-negative integers $ a_1, \\dots, a_n $ separated by single spaces, where $ a_i $ is the number of seats won by the $ i $-th party. You may assume that the total number of seats in the parliament is a positive integer not exceeding $ 10^5 $.", "outputFormat": "Output a single integer: the maximum possible number of seats.", "hint": "Sample explanation: choose the second and the fourth party.\n\nConstraints: For all testdata, $ 1 \\le n \\le 300 $.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "选举", "background": "", "description": "Byteland 国的居民最近一直为议会选举投票。现在，当结果公布的时候，党派不得不决定联合组建政府。 \n\n每个党派都会获得议会中的一定席位。联合政府由这些党派中的一部分组成，他们在议会中的席位数之和**严格大于**总席位数的一半。对于联合政府来说，席位越多越好。\n\n一个**过剩**的联合政府是指联合政府中的一个党派被移出后，剩余的联合政府在国会中仍有过半数的席位。\n\n请写一个程序能够找到一个在议会中有着**最大可能席位数**且**不过剩**的联合政府。", "inputFormat": "标准输出的第一行包含一个整数 $n$，表示参加选举的党派数。党派被从 $1$ 到 $n$ 编号。\n\n第二行包含 $n$ 个非负整数 $a_1,\\dots ,a_n$，被一个空格隔开，$a_i$ 是第 $i$ 个党派获得的席位数。你可以假设国会中的中的总席位数为小于等于 $10^5$ 的正整数。", "outputFormat": "包含一个整数，表示最大可能席位数。", "hint": "样例解释：选择第二个政党和第四个。\n\n对于全部数据，$1\\le n\\le 300$。", "locale": "zh-CN"}}}
{"pid": "P4395", "type": "P", "difficulty": 4, "samples": [["10 \n7 5 \n1 2 \n1 7 \n8 9 \n4 1 \n9 7 \n5 6 \n10 2 \n9 3", "14"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2003", "树形 DP", "BalticOI（波罗的海）"], "title": "[BalticOI 2003] Gem 气垫车", "background": "", "description": "给出一棵树，要求你为树上的结点标上权值，权值可以是任意的正整数。\n\n唯一的限制条件是相邻的两个结点不能标上相同的权值，要求一种方案，使得整棵树的总价值最小。", "inputFormat": "先给出一个数字 $N$ 代表树上有 $N$ 个点，$N \\le 10000$。\n\n下面 $N-1$ 行，代表两个结点 $u,v(1\\le u,v\\le N)$ 相连。", "outputFormat": "最小的总权值。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2003] Gem Hovercraft", "background": "", "description": "Given a tree, assign a weight to each node. The weight can be any positive integer.\n\nThe only constraint is that two adjacent nodes cannot have the same weight. Find an assignment that minimizes the total weight of the entire tree.", "inputFormat": "The first line contains an integer $N$ representing the number of nodes in the tree, with $N \\le 10000$.\n\nEach of the next $N-1$ lines indicates that two nodes $u,v(1\\le u,v\\le N)$ are connected by an edge.", "outputFormat": "The minimum possible total weight.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2003] Gem 气垫车", "background": "", "description": "给出一棵树，要求你为树上的结点标上权值，权值可以是任意的正整数。\n\n唯一的限制条件是相邻的两个结点不能标上相同的权值，要求一种方案，使得整棵树的总价值最小。", "inputFormat": "先给出一个数字 $N$ 代表树上有 $N$ 个点，$N \\le 10000$。\n\n下面 $N-1$ 行，代表两个结点 $u,v(1\\le u,v\\le N)$ 相连。", "outputFormat": "最小的总权值。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4396", "type": "P", "difficulty": 6, "samples": [["3 4\n1 2 2\n1 2 1 3\n1 2 1 1\n1 3 1 3\n2 3 2 3", "2 2\n1 1\n3 2\n2 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2013", "莫队", "各省省选", "树状数组", "安徽", "cdq 分治", "可持久化线段树", "分块"], "title": "[AHOI2013] 作业", "background": "", "description": "此时己是凌晨两点，刚刚做了 Codeforces 的小 A 掏出了英语试卷。英语作业其实不算多，一个小时刚好可以做完。然后是一个小时可以做完的数学作业，接下来是分别都是一个小时可以做完的化学，物理，语文……小 A 压力巨大。\n\n这时小 A 碰见了一道非常恶心的数学题，给定了一个长度为 $n$ 的数列和若干个询问，每个询问是关于数列的区间表示数列的第 $l$ 个数到第 $r$ 个数)，首先你要统计该区间内大于等于 $a$，小于等于 $b$ 的数的个数，其次是所有大于等于 $a$，小于等于 $b$ 的，且在该区间中出现过的数值的个数。\n\n小 A 望着那数万的数据规模几乎绝望，只能向大神您求救，请您帮帮他吧。", "inputFormat": "第一行两个整数 $n,m$\n\n接下来 $n$ 个不超过 $10^5$ 的正整数表示数列\n\n接下来 $m$ 行，每行四个整数 $l,r,a,b$，具体含义参见题意。\n", "outputFormat": "输出 $m$ 行，分别对应每个询问，输出两个数，分别为在 $l$ 到 $r$ 这段区间中大小在 $[a,b]$ 中的数的个数，以及大于等于 $a$，小于等于 $b$ 的，且在该区间中出现过的数值的个数（具体可以参考样例）。\n", "hint": "$N\\leq 100000,M\\leq 100000$，读入的数字均为 $[1,10^5]$ 内的正整数。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2013] Homework", "background": "", "description": "It is already 2 a.m. After finishing some Codeforces problems, Xiao A pulled out the English test paper. The English homework is not much; it takes exactly one hour to finish. Then there is math homework that also takes one hour, followed by chemistry, physics, Chinese, and so on, each of which also takes one hour. Xiao A feels enormous pressure.\n\nAt this moment, Xiao A ran into a very nasty math problem: given a sequence of length $n$ and several queries, each query is on an interval of the sequence (from the $l$-th number to the $r$-th number). First, you need to count how many numbers in this interval are greater than or equal to $a$ and less than or equal to $b$. Second, you need to count how many distinct values are greater than or equal to $a$ and less than or equal to $b$ and appear in this interval.\n\nFacing testdata of tens of thousands in scale, Xiao A is almost desperate and can only ask you, the expert, for help. Please help him.", "inputFormat": "The first line contains two integers $n, m$.\n\nThe next $n$ positive integers, each not exceeding $10^5$, form the sequence.\n\nThen there are $m$ lines. Each line contains four integers $l, r, a, b$; see the statement for their meanings.", "outputFormat": "Output $m$ lines, one for each query. For each query, output two numbers: the number of elements in the interval $[l, r]$ whose values lie in $[a, b]$, and the number of distinct values that are greater than or equal to $a$ and less than or equal to $b$ and appear in this interval (see the sample).", "hint": "$N \\le 100000, M \\le 100000$. All read numbers are positive integers in $[1, 10^5]$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2013] 作业", "background": "", "description": "此时己是凌晨两点，刚刚做了 Codeforces 的小 A 掏出了英语试卷。英语作业其实不算多，一个小时刚好可以做完。然后是一个小时可以做完的数学作业，接下来是分别都是一个小时可以做完的化学，物理，语文……小 A 压力巨大。\n\n这时小 A 碰见了一道非常恶心的数学题，给定了一个长度为 $n$ 的数列和若干个询问，每个询问是关于数列的区间表示数列的第 $l$ 个数到第 $r$ 个数)，首先你要统计该区间内大于等于 $a$，小于等于 $b$ 的数的个数，其次是所有大于等于 $a$，小于等于 $b$ 的，且在该区间中出现过的数值的个数。\n\n小 A 望着那数万的数据规模几乎绝望，只能向大神您求救，请您帮帮他吧。", "inputFormat": "第一行两个整数 $n,m$\n\n接下来 $n$ 个不超过 $10^5$ 的正整数表示数列\n\n接下来 $m$ 行，每行四个整数 $l,r,a,b$，具体含义参见题意。\n", "outputFormat": "输出 $m$ 行，分别对应每个询问，输出两个数，分别为在 $l$ 到 $r$ 这段区间中大小在 $[a,b]$ 中的数的个数，以及大于等于 $a$，小于等于 $b$ 的，且在该区间中出现过的数值的个数（具体可以参考样例）。\n", "hint": "$N\\leq 100000,M\\leq 100000$，读入的数字均为 $[1,10^5]$ 内的正整数。", "locale": "zh-CN"}}}
{"pid": "P4397", "type": "P", "difficulty": 5, "samples": [["42", "3\n20 26 41"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2014", "各省省选", "吉林", "枚举", "深度优先搜索 DFS", "素数判断,质数,筛法"], "title": "[JLOI2014] 聪明的燕姿", "background": "> 阴天傍晚车窗外\n>\n> 未来有一个人在等待\n>\n> 向左向右向前看\n>\n> 爱要拐几个弯才来\n>\n> 我遇见谁会有怎样的对白\n>\n> 我等的人他在多远的未来\n>\n> 我听见风来自地铁和人海\n>\n> 我排着队拿着爱的号码牌", "description": "城市中人们总是拿着号码牌，不停寻找，不断匹配，可是谁也不知道自己等的那个人是谁。\n\n可是燕姿不一样，燕姿知道自己等的人是谁，因为燕姿数学学得好！燕姿发现了一个神奇的算法：假设自己的号码牌上写着数字 $S$，那么自己等的人手上的号码牌数字的所有正约数之和必定等于 $S$。\n\n所以燕姿总是拿着号码牌在地铁和人海找数字（喂！这样真的靠谱吗）可是她忙着唱《绿光》，想拜托你写一个程序能够快速地找到所有自己等的人。", "inputFormat": "输入包含 $k$ 组数据。\n\n对于每组数据，输入包含一个号码牌 $S$。", "outputFormat": "对于每组数据，输出有两行，第一行包含一个整数 $m$，表示有 $m$ 个等的人。\n\n第二行包含相应的 $m$ 个数，表示所有等的人的号码牌。\n\n特别地，当某组数据出现 $m=0$，即不存在满足题意的号码牌时，该组数据不应输出第二行（只应输出第一行的 $0$）。\n\n注意：你输出的号码牌必须按照升序排列。", "hint": "对于 $100\\%$ 的数据，$k\\leqslant100$，$S\\leqslant2\\times10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[JLOI2014] Smart Yanzi", "background": "> Outside the car window on a cloudy evening.\n>\n> Someone is waiting in the future.\n>\n> Look left, right, and forward.\n>\n> Love takes a few turns before it arrives.\n>\n> Whom will I meet, and what kind of conversation will we have.\n>\n> How far in the future is the one I'm waiting for.\n>\n> I hear the wind coming from the subway and the sea of people.\n>\n> I stand in line holding a number for love.", "description": "In the city, people always hold number tickets, keep searching, and keep matching, yet no one knows whom they are waiting for.\n\nBut Yanzi is different. Yanzi knows whom she is waiting for, because she is good at math. Yanzi discovered a magical algorithm: suppose the number on her ticket is $S$, then the sum of all positive divisors of the number on the other person's ticket must equal $S$.\n\nSo Yanzi always searches through subways and crowds holding her number ticket to find numbers (Hey! Is this really reliable?), but she is busy singing \"Green Light\" and wants to ask you to write a program to quickly find everyone she is waiting for.", "inputFormat": "The input contains $k$ test cases.\n\nFor each test case, the input consists of a single integer $S$.", "outputFormat": "For each test case, output two lines. The first line contains an integer $m$, denoting there are $m$ people she is waiting for.\n\nThe second line contains the corresponding $m$ numbers, which are the number tickets of all those people.\n\nIn particular, when $m=0$, i.e., no number satisfies the requirement, that test case should not output the second line (only output the single line $0$).\n\nNote: The numbers you output must be in ascending order.", "hint": "For $100\\%$ of the testdata, $k \\leqslant 100$, $S \\leqslant 2 \\times 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JLOI2014] 聪明的燕姿", "background": "> 阴天傍晚车窗外\n>\n> 未来有一个人在等待\n>\n> 向左向右向前看\n>\n> 爱要拐几个弯才来\n>\n> 我遇见谁会有怎样的对白\n>\n> 我等的人他在多远的未来\n>\n> 我听见风来自地铁和人海\n>\n> 我排着队拿着爱的号码牌", "description": "城市中人们总是拿着号码牌，不停寻找，不断匹配，可是谁也不知道自己等的那个人是谁。\n\n可是燕姿不一样，燕姿知道自己等的人是谁，因为燕姿数学学得好！燕姿发现了一个神奇的算法：假设自己的号码牌上写着数字 $S$，那么自己等的人手上的号码牌数字的所有正约数之和必定等于 $S$。\n\n所以燕姿总是拿着号码牌在地铁和人海找数字（喂！这样真的靠谱吗）可是她忙着唱《绿光》，想拜托你写一个程序能够快速地找到所有自己等的人。", "inputFormat": "输入包含 $k$ 组数据。\n\n对于每组数据，输入包含一个号码牌 $S$。", "outputFormat": "对于每组数据，输出有两行，第一行包含一个整数 $m$，表示有 $m$ 个等的人。\n\n第二行包含相应的 $m$ 个数，表示所有等的人的号码牌。\n\n特别地，当某组数据出现 $m=0$，即不存在满足题意的号码牌时，该组数据不应输出第二行（只应输出第一行的 $0$）。\n\n注意：你输出的号码牌必须按照升序排列。", "hint": "对于 $100\\%$ 的数据，$k\\leqslant100$，$S\\leqslant2\\times10^9$。", "locale": "zh-CN"}}}
{"pid": "P4398", "type": "P", "difficulty": 3, "samples": [["3\n1 2 3\n4 5 6\n7 8 9\n5 6 7\n8 9 1\n2 3 4", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2008", "各省省选", "江苏", "枚举", "哈希 hashing"], "title": "[JSOI2008] Blue Mary的战役地图", "background": null, "description": "Blue Mary 最近迷上了玩 Starcraft（星际争霸）的 RPG 游戏。她正在设法寻找更多的战役地图以进一步提高自己的水平。\n \n由于 Blue Mary 的技术已经达到了一定的高度,因此，对于用同一种打法能够通过的战役地图，她只需要玩一张，她就能了解这一类战役的打法，然后她就没有兴趣再玩儿这一类地图了。而网上流传的地图有很多都是属于同一种打法，因此 Blue Mary 需要你写一个程序，来帮助她判断哪些地图是属于同一类的。 \n\n具体来说，Blue Mary 已经将战役地图编码为 $n \\times n$ 的矩阵，矩阵的每个格子里面是一个 $32$ 位（有符号）正整数。对于两个矩阵，他们的相似程度定义为他们的最大公共正方形矩阵的边长。两个矩阵的相似程度越大，这两张战役地图就越有可能是属于同一类的。", "inputFormat": "第一行包含一个正整数 $n$。 \n\n以下 $n$ 行，每行包含 $n$ 个正整数，表示第一张战役地图的代表矩阵。 \n\n再以下 $n$ 行，每行包含 $n$ 个正整数，表示第二张战役地图的代表矩阵。", "outputFormat": "仅包含一行。这一行仅有一个正整数，表示这两个矩阵的相似程度。", "hint": "#### 样例解释： \n\n子矩阵：$\n\\begin{bmatrix}\n  5 & 6 \\\\\n  8 & 9 \\\\\n\\end{bmatrix}\n$ 为两个地图的最大公共矩阵。\n\n约定：$n \\le 50$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2008] Blue Mary's Campaign Map", "background": "", "description": "Blue Mary has recently become hooked on playing StarCraft RPGs. She is trying to find more campaign maps to further improve her skills.\n\nSince Blue Mary has reached a certain skill level, for campaign maps that can be cleared using the same strategy, she only needs to play one of them to learn that type of strategy, and then she loses interest in other maps of the same type. Many maps circulating online share the same strategy, so Blue Mary needs you to write a program to help her determine which maps belong to the same type.\n\nSpecifically, Blue Mary has encoded each campaign map as an $n \\times n$ matrix, where each cell contains a positive 32-bit (signed) integer. For two matrices, their similarity is defined as the side length of their largest common square submatrix. The greater the similarity between two matrices, the more likely the two campaign maps are of the same type.", "inputFormat": "The first line contains a positive integer $n$.\n\nThe next $n$ lines each contain $n$ positive integers, representing the matrix of the first campaign map.\n\nThe following $n$ lines each contain $n$ positive integers, representing the matrix of the second campaign map.", "outputFormat": "Output a single line containing one positive integer, which is the similarity between the two matrices.", "hint": "Sample explanation:\n\nSubmatrix: $\n\\begin{bmatrix}\n  5 & 6 \\\\\n  8 & 9 \\\\\n\\end{bmatrix}\n$ is the largest common submatrix of the two maps.\n\nConstraints: $n \\le 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2008] Blue Mary的战役地图", "background": null, "description": "Blue Mary 最近迷上了玩 Starcraft（星际争霸）的 RPG 游戏。她正在设法寻找更多的战役地图以进一步提高自己的水平。\n \n由于 Blue Mary 的技术已经达到了一定的高度,因此，对于用同一种打法能够通过的战役地图，她只需要玩一张，她就能了解这一类战役的打法，然后她就没有兴趣再玩儿这一类地图了。而网上流传的地图有很多都是属于同一种打法，因此 Blue Mary 需要你写一个程序，来帮助她判断哪些地图是属于同一类的。 \n\n具体来说，Blue Mary 已经将战役地图编码为 $n \\times n$ 的矩阵，矩阵的每个格子里面是一个 $32$ 位（有符号）正整数。对于两个矩阵，他们的相似程度定义为他们的最大公共正方形矩阵的边长。两个矩阵的相似程度越大，这两张战役地图就越有可能是属于同一类的。", "inputFormat": "第一行包含一个正整数 $n$。 \n\n以下 $n$ 行，每行包含 $n$ 个正整数，表示第一张战役地图的代表矩阵。 \n\n再以下 $n$ 行，每行包含 $n$ 个正整数，表示第二张战役地图的代表矩阵。", "outputFormat": "仅包含一行。这一行仅有一个正整数，表示这两个矩阵的相似程度。", "hint": "#### 样例解释： \n\n子矩阵：$\n\\begin{bmatrix}\n  5 & 6 \\\\\n  8 & 9 \\\\\n\\end{bmatrix}\n$ 为两个地图的最大公共矩阵。\n\n约定：$n \\le 50$。", "locale": "zh-CN"}}}
