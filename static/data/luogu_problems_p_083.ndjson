{"pid": "P2682", "type": "P", "difficulty": 7, "samples": [["例：一个使用1*1的土豆田处理单元(下称处理单元)的A+B problem\n输入两个整数a,b,|a|,|b|<=10^9\n输出a+b\n\n1 1\n5\nin\nswap\nin\nadd tmp\nout\n", "解释：\n第一行的1 1表示用的处理单元为1*1\n第二行表示第一个处理单元有5条指令。\n第三行的命令在第一个周期执行，读入了一个数(假定为a) ，此时该单元的状态为key=0,tmp=a\n第四行在第二个周期执行，交换了key和tmp,状态为key=a,tmp=0\n第五行在第三个周期执行，读入了另一个数b，状态为key=a,tmp=b\n第六行在第四个周期执行，给key加上tmp，状态为key=a+b,tmp=b\n第七行在第五个周期执行，输出该单元的key，即输出了a+b"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["提交答案", "Special Judge"], "title": "土豆田", "background": "大宁在他家门口种了一大片土豆田，划分为 $n \\times m$ 的地块。\n\n大宁准备搭建学校的 OJ，为了测试土豆田的性能，大宁找到了你，为他的土豆编写代码。", "description": "大宁的土豆田是以地块为单位的，每个地块里的所有土豆的集合称为一个处理单元，可以储存两个值：key（键值）和 tmp（缓存值），均为 $32$ 位带符号整数，每个单元。可以执行若干命令。大宁会骑着自行车轮流给每个处理单元供电，顺序如图，展示的是一个被分割为 $4\\times 4$ 处理单元的土豆田：\n\n  ![](https://cdn.luogu.com.cn/upload/pic/12313.png) \n\n单元的编号就是供电的顺序，每次按编号顺序从 $1$ 号到 $n\\times m$ 号遍历一遍。\n\n每一次完整的遍历称为一个周期。\n\n只有一块地上的土豆得到供电，它们才会工作，执行命令，所有命令执行完之后大宁会停止供电。\n\n对于每一个处理单元，命令格式如下：\n\n1. `in` 读取一个数，存放到该单元的 $\\text{tmp}$ 中。（如果 $\\text{tmp}$ 中有数，那么覆盖掉，以下的所有存放均如此）\n\n1. `out` 输出当前处理单元的 $\\text{key}$ 值。\n\n1. `swap` 交换该单元的 $\\text{key}$ 和 $\\text{tmp}$。\n\n1. `add X` 给 $\\text{key}$ 值加上 $X$，$X$ 只能是一个常数或者 $\\text{tmp}$，下同。\n\n1. `set X` 把 $\\text{key}$ 值修改为 $X$。\n\n1. `opp` 对 $\\text{key}$ 值取相反数。\n\n1. `rev` 对 $\\text{key}$ 值按位取反。\n\n1. `L/R X` 左/右移 $\\text{key}$ 值 $X$ 位。\n\n1. `get u/d/l/r` 将当前单元上(u)/下(d)/左(l)/右(r)面的单元的 $\\text{key}$ 值并把它复制到本单元的 $\\text{tmp}$，位置规则按照前面的图片所示。\n\n1. `or/and/xor X` 对 $\\text{key}$ 值按位或/与/异或 $X$。\n\n1. `wait` 在本次供电的时间中等待，即什么事情也不做。\n\n1. `if X` 如果此时 X(只能是 $\\text{key}$ 或者 $\\text{tmp}$ )不等于 $0$ 则在下一次供电执行该语句的下一条语句，否则跳过下一条语句，执行下下条(如果存在的话)。\n\n1. `goto Y`  下一次供电从第 $Y$ 号命令开始执行，$Y$ 只能是常数。\n\n1. `end` 强制结束所有的处理单元的命令，无视所有尚未执行的命令。\n\n我们提供了 check.exe,把你的土豆程序 potato.out 和你想测试的输入数据 potato.in 放到与 check.exe 同文件夹下，运行之后可以在 report.txt 中查看你的程序的详细运行情况。\n\n我们还提供了另一个样例土豆程序 example2.out,使用 $2\\times2$ 处理单元的土豆程序，内容为计算一个整数 $a$ 的 $10$ 倍,可以自行解读（该样例并非该计算的最优解，只是为了展示命令）。\n\n下面展示了一个 $1 \\times 3$ 的处理单元，所有单元不一定需要全部使用。\n\n![](https://cdn.luogu.com.cn/upload/pic/12314.png)\n\n你有以下任务需要用编写土豆程序完成：\n\n|编号|输入|输出|数据范围|处理单元大小限制|分数|补充说明|\n| :----------: | :----------: | :----------:| :----------:| :----------:|:----------: | :----------: |\n|$1$|$a\\text{，}b$|$b-a$|$\\lvert a\\rvert \\text{，}\\lvert b\\rvert \\le10^9 $|$1 \\times 3$|$7$|无|\n|$2$|$a$|$233\\times a$|$1 \\le\\lvert a\\rvert \\le10^7 $|$2 \\times 2$|$9$|无|\n|$3$|$a$|$\\lvert a \\rvert$|$1 \\le\\lvert a\\rvert \\le10^9 $|$2 \\times 2$|$12$|求 $a$ 的绝对值|\n|$4$|$128$ 个整数 $a_i$|$\\sum^{128}_{i=1}a_i$|$1 \\le\\lvert a\\rvert \\le2 \\times 10^6 $|$4 \\times 2$|$12$|无|\n|$5$|$a\\text{，}b$|$\\lfloor \\frac{a+b}{2}\\rfloor$|$\\lvert a\\rvert \\text{，}\\lvert b\\rvert \\le2.1\\times10^9 $|$2 \\times 2$|$13$|无|\n|$6$|$a$|$\\operatorname{popcount}(a)$|$\\lvert a\\rvert\\le10^9 $|$2 \\times 2$|$13$|$\\operatorname{popcount}(a)$表示 $a$ 在二进制表示下 $1$ 的个数|\n|$7$|$a\\text{，}b$|$\\max {(a,b)}$|$\\lvert a\\rvert \\text{，}\\lvert b\\rvert \\le10^9 $|$2 \\times 2$|$14$|无|\n|$8$|$n$|$f(n)$|$1 \\le n \\le 42$|$3 \\times 3$|$20$|$f(n)=\\begin{cases}1 & n<2\\\\f(n-1)+f(n-2) & n\\ge 2\\end{cases}$|", "inputFormat": "本题为提交答案题。", "outputFormat": "第一行为 $n$ 和 $m$，表示你用了 $n$ 行 $m$ 列。\n\n接下来$n\\times m$个部分，第 $i$ 个部分的第一行 $t_i$ 表示在第 $i$ 个处理单元中命令的数量(可以为 $0$)，接下来 $t_i$ 行每行描述一个命令，见上文所述。", "hint": "#### 样例#1解释\n\n这个样例实现了 A+B problem。\n\n第一行的 `1 1` 表示用的处理单元为 $1\\times1$。\n\n第二行表示第一个处理单元有 $5$ 条指令。\n\n第三行的命令在第一个周期执行，读入了一个数(假定为 $a$) ，此时该单元的状态为 $\\text{key}= 0 \\text{，}\\text{tmp}= a$。\n\n第四行在第二个周期执行，交换了 $\\text{key}$ 和 $\\text{tmp}$，状态为 $\\text{key}= a \\text{，}\\text{tmp}= 0$。\n\n第五行在第三个周期执行，读入了另一个数 $b$，状态为 $\\text{key}= a \\text{，}\\text{tmp}= b$。\n\n第六行在第四个周期执行，给 $\\text{key}$ 加上 $\\text{tmp}$，状态为 $\\text{key}= a+b \\text{，}\\text{tmp}= b$。\n\n第七行在第五个周期执行，输出该单元的 $\\text{key}$，即输出了 $a+b$。\n\n\n如果你的程序在 $2000$ 个周期内没有运行完毕，或者有语法错误，或者超过处理单元尺寸限制，得 $0$ 分。\n\n如果你的第 $i$ 个任务的程序能得出正确的结果，并且和标准答案运行所需的周期数量相同或比其更少，得会得到该测试点的满分，否则设你的程序运行了 $a$ 个周期，标准答案运行了 $s$ 个周期，你的分数为 $\\lfloor\\text{该测试点分数}\\times(\\frac{s}{a})\\times0.8 \\rfloor$(注意，部分正确显示WA,但是仍然有分数)。\n\n```cpp\nP1=7\nP2=9\nP3=12\nP4=12\nP5=13\nP6=13\nP7=14\nP8=20\n```\n\nPS:如果你构造了什么好玩的土豆程序(可以和本题目中的任务无关)，请到答疑博客下或者私信告诉我，会酌情给予奖励。\n\nCheck 下载见附件。\n\nexample2.out：\n\n```\n2 2 8 in add tmp\nL 3 get r add tmp\nget d add tmp\nout 3 wait get l add tmp\n3 wait get u add tmp\n```", "locale": "zh-CN", "translations": {"en": {"title": "Potato Field", "background": "Daning planted a large potato field divided into $n \\times m$ plots in front of his house.\n\nDaning is setting up the school's OJ. To test the performance of the potato field, he found you to write code for his potatoes.", "description": "Daning’s potato field works at the granularity of plots. The set of all potatoes in a plot is called a processing unit. Each processing unit can store two values: key and tmp, both are 32-bit signed integers. Each unit can execute several commands. Daning will power the processing units one by one by riding his bicycle. The order is shown in the figure below; it shows a potato field split into $4 \\times 4$ processing units:\n\n![](https://cdn.luogu.com.cn/upload/pic/12313.png)\n\nThe unit number is the power-on order. Each time, units are visited in order from No. $1$ to No. $n \\times m$.\n\nEach complete traversal is called one cycle.\n\nOnly when the potatoes in a plot are powered will they work and execute commands. After all commands finish, Daning will stop supplying power.\n\nFor each processing unit, the command formats are as follows:\n\n1. `in` Read a number and store it into this unit’s $\\\\text{tmp}$. (If there is already a number in $\\\\text{tmp}$, it is overwritten; the same applies to all stores below.)\n2. `out` Output the current unit’s $\\\\text{key}$.\n3. `swap` Swap this unit’s $\\\\text{key}$ and $\\\\text{tmp}$.\n4. `add X` Add $X$ to $\\\\text{key}$. $X$ can only be a constant or $\\\\text{tmp}$; same below.\n5. `set X` Set $\\\\text{key}$ to $X$.\n6. `opp` Negate $\\\\text{key}$.\n7. `rev` Bitwise NOT on $\\\\text{key}$.\n8. `L/R X` Left/Right shift $\\\\text{key}$ by $X$ bits.\n9. `get u/d/l/r` Read the $\\\\text{key}$ of the unit above (u) / below (d) / left (l) / right (r) and copy it into this unit’s $\\\\text{tmp}$. Neighbor positions follow the picture above.\n10. `or/and/xor X` Bitwise OR/AND/XOR $\\\\text{key}$ with $X$.\n11. `wait` Wait during this power-on period; i.e., do nothing.\n12. `if X` If $X$ (can only be $\\\\text{key}$ or $\\\\text{tmp}$) is not equal to $0$, then during the next time this unit is powered, execute the next instruction; otherwise skip the next instruction and execute the one after that (if it exists).\n13. `goto Y` During the next time this unit is powered, start execution from instruction No. $Y$. $Y$ must be a constant.\n14. `end` Forcibly end the commands of all processing units, ignoring all remaining unexecuted commands.\n\nWe provide check.exe. Put your potato program potato.out and the input testdata you want to use potato.in in the same folder as check.exe. After running, you can view the detailed running status of your program in report.txt.\n\nWe also provide another sample potato program example2.out, a potato program using $2 \\times 2$ processing units that computes $10$ times an integer $a$. You can read it yourself (this sample is not the optimal solution for that computation; it is only to demonstrate the commands).\n\nBelow is a $1 \\times 3$ processing unit layout. Not all units must be used.\n\n![](https://cdn.luogu.com.cn/upload/pic/12314.png)\n\nYou have the following tasks to complete by writing potato programs:\n\n| ID | Input | Output | Constraints | Processing Unit Size Limit | Score | Additional Notes |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $a, b$ | $b - a$ | $\\\\lvert a \\\\rvert, \\\\lvert b \\\\rvert \\\\le 10^9$ | $1 \\\\times 3$ | $7$ | None |\n| $2$ | $a$ | $233 \\\\times a$ | $1 \\\\le \\\\lvert a \\\\rvert \\\\le 10^7$ | $2 \\\\times 2$ | $9$ | None |\n| $3$ | $a$ | $\\\\lvert a \\\\rvert$ | $1 \\\\le \\\\lvert a \\\\rvert \\\\le 10^9$ | $2 \\\\times 2$ | $12$ | Compute the absolute value of $a$. |\n| $4$ | $128$ integers $a_i$ | $\\\\sum_{i=1}^{128} a_i$ | $1 \\\\le \\\\lvert a_i \\\\rvert \\\\le 2 \\\\times 10^6$ | $4 \\\\times 2$ | $12$ | None |\n| $5$ | $a, b$ | $\\\\left\\\\lfloor \\\\dfrac{a + b}{2} \\\\right\\\\rfloor$ | $\\\\lvert a \\\\rvert, \\\\lvert b \\\\rvert \\\\le 2.1 \\\\times 10^9$ | $2 \\\\times 2$ | $13$ | None |\n| $6$ | $a$ | $\\\\operatorname{popcount}(a)$ | $\\\\lvert a \\\\rvert \\\\le 10^9$ | $2 \\\\times 2$ | $13$ | $\\\\operatorname{popcount}(a)$ denotes the number of $1$s in the binary representation of $a$. |\n| $7$ | $a, b$ | $\\\\max(a, b)$ | $\\\\lvert a \\\\rvert, \\\\lvert b \\\\rvert \\\\le 10^9$ | $2 \\\\times 2$ | $14$ | None |\n| $8$ | $n$ | $f(n)$ | $1 \\\\le n \\\\le 42$ | $3 \\\\times 3$ | $20$ | $f(n) = \\\\begin{cases} 1 & n < 2 \\\\\\\\ f(n-1) + f(n-2) & n \\\\ge 2 \\\\end{cases}$ |", "inputFormat": "This is an output-only problem.", "outputFormat": "The first line contains $n$ and $m$, indicating you used $n$ rows and $m$ columns.\n\nThen there are $n \\\\times m$ sections. In the $i$-th section, the first line contains $t_i$, the number of commands in the $i$-th processing unit (can be $0$). The next $t_i$ lines each describe a command, as described above.", "hint": "#### Explanation of Sample #1\n\nThis sample implements the A+B problem.\n\nThe first line `1 1` indicates the processing unit size is $1 \\\\times 1$.\n\nThe second line indicates there are $5$ instructions in the first processing unit.\n\nThe command on the third line executes in the first cycle and reads a number (assume it is $a$). At this time, the unit’s state is $\\\\text{key} = 0, \\\\text{tmp} = a$.\n\nThe fourth line executes in the second cycle and swaps $\\\\text{key}$ and $\\\\text{tmp}$. The state becomes $\\\\text{key} = a, \\\\text{tmp} = 0$.\n\nThe fifth line executes in the third cycle and reads another number $b$. The state is $\\\\text{key} = a, \\\\text{tmp} = b$.\n\nThe sixth line executes in the fourth cycle and adds $\\\\text{tmp}$ to $\\\\text{key}$. The state is $\\\\text{key} = a + b, \\\\text{tmp} = b$.\n\nThe seventh line executes in the fifth cycle and outputs this unit’s $\\\\text{key}$, i.e., it outputs $a + b$.\n\nIf your program does not finish within $2000$ cycles, or has a syntax error, or exceeds the processing unit size limit, you get $0$ points.\n\nIf your program for task $i$ produces the correct result, and the number of cycles required is the same as or fewer than the standard solution, you get full points for that test point. Otherwise, suppose your program ran for $a$ cycles and the standard solution ran for $s$ cycles. Your score is $\\\\left\\\\lfloor \\\\text{(points for that test point)} \\\\times \\\\left( \\\\dfrac{s}{a} \\\\right) \\\\times 0.8 \\\\right\\\\rfloor$. Note that even if it shows WA for partially correct solutions, you still receive points.\n\n```cpp\nP1=7\nP2=9\nP3=12\nP4=12\nP5=13\nP6=13\nP7=14\nP8=20\n```\n\nPS: If you craft any fun potato programs (they can be unrelated to the tasks in this problem), please reply under the Q&A blog or send me a private message. Rewards will be given at my discretion.\n\nCheck download is available in the attachment.\n\nexample2.out:\n\n```\n2 2 8 in add tmp\nL 3 get r add tmp\nget d add tmp\nout 3 wait get l add tmp\n3 wait get u add tmp\n```\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "土豆田", "background": "大宁在他家门口种了一大片土豆田，划分为 $n \\times m$ 的地块。\n\n大宁准备搭建学校的 OJ，为了测试土豆田的性能，大宁找到了你，为他的土豆编写代码。", "description": "大宁的土豆田是以地块为单位的，每个地块里的所有土豆的集合称为一个处理单元，可以储存两个值：key（键值）和 tmp（缓存值），均为 $32$ 位带符号整数，每个单元。可以执行若干命令。大宁会骑着自行车轮流给每个处理单元供电，顺序如图，展示的是一个被分割为 $4\\times 4$ 处理单元的土豆田：\n\n  ![](https://cdn.luogu.com.cn/upload/pic/12313.png) \n\n单元的编号就是供电的顺序，每次按编号顺序从 $1$ 号到 $n\\times m$ 号遍历一遍。\n\n每一次完整的遍历称为一个周期。\n\n只有一块地上的土豆得到供电，它们才会工作，执行命令，所有命令执行完之后大宁会停止供电。\n\n对于每一个处理单元，命令格式如下：\n\n1. `in` 读取一个数，存放到该单元的 $\\text{tmp}$ 中。（如果 $\\text{tmp}$ 中有数，那么覆盖掉，以下的所有存放均如此）\n\n1. `out` 输出当前处理单元的 $\\text{key}$ 值。\n\n1. `swap` 交换该单元的 $\\text{key}$ 和 $\\text{tmp}$。\n\n1. `add X` 给 $\\text{key}$ 值加上 $X$，$X$ 只能是一个常数或者 $\\text{tmp}$，下同。\n\n1. `set X` 把 $\\text{key}$ 值修改为 $X$。\n\n1. `opp` 对 $\\text{key}$ 值取相反数。\n\n1. `rev` 对 $\\text{key}$ 值按位取反。\n\n1. `L/R X` 左/右移 $\\text{key}$ 值 $X$ 位。\n\n1. `get u/d/l/r` 将当前单元上(u)/下(d)/左(l)/右(r)面的单元的 $\\text{key}$ 值并把它复制到本单元的 $\\text{tmp}$，位置规则按照前面的图片所示。\n\n1. `or/and/xor X` 对 $\\text{key}$ 值按位或/与/异或 $X$。\n\n1. `wait` 在本次供电的时间中等待，即什么事情也不做。\n\n1. `if X` 如果此时 X(只能是 $\\text{key}$ 或者 $\\text{tmp}$ )不等于 $0$ 则在下一次供电执行该语句的下一条语句，否则跳过下一条语句，执行下下条(如果存在的话)。\n\n1. `goto Y`  下一次供电从第 $Y$ 号命令开始执行，$Y$ 只能是常数。\n\n1. `end` 强制结束所有的处理单元的命令，无视所有尚未执行的命令。\n\n我们提供了 check.exe,把你的土豆程序 potato.out 和你想测试的输入数据 potato.in 放到与 check.exe 同文件夹下，运行之后可以在 report.txt 中查看你的程序的详细运行情况。\n\n我们还提供了另一个样例土豆程序 example2.out,使用 $2\\times2$ 处理单元的土豆程序，内容为计算一个整数 $a$ 的 $10$ 倍,可以自行解读（该样例并非该计算的最优解，只是为了展示命令）。\n\n下面展示了一个 $1 \\times 3$ 的处理单元，所有单元不一定需要全部使用。\n\n![](https://cdn.luogu.com.cn/upload/pic/12314.png)\n\n你有以下任务需要用编写土豆程序完成：\n\n|编号|输入|输出|数据范围|处理单元大小限制|分数|补充说明|\n| :----------: | :----------: | :----------:| :----------:| :----------:|:----------: | :----------: |\n|$1$|$a\\text{，}b$|$b-a$|$\\lvert a\\rvert \\text{，}\\lvert b\\rvert \\le10^9 $|$1 \\times 3$|$7$|无|\n|$2$|$a$|$233\\times a$|$1 \\le\\lvert a\\rvert \\le10^7 $|$2 \\times 2$|$9$|无|\n|$3$|$a$|$\\lvert a \\rvert$|$1 \\le\\lvert a\\rvert \\le10^9 $|$2 \\times 2$|$12$|求 $a$ 的绝对值|\n|$4$|$128$ 个整数 $a_i$|$\\sum^{128}_{i=1}a_i$|$1 \\le\\lvert a\\rvert \\le2 \\times 10^6 $|$4 \\times 2$|$12$|无|\n|$5$|$a\\text{，}b$|$\\lfloor \\frac{a+b}{2}\\rfloor$|$\\lvert a\\rvert \\text{，}\\lvert b\\rvert \\le2.1\\times10^9 $|$2 \\times 2$|$13$|无|\n|$6$|$a$|$\\operatorname{popcount}(a)$|$\\lvert a\\rvert\\le10^9 $|$2 \\times 2$|$13$|$\\operatorname{popcount}(a)$表示 $a$ 在二进制表示下 $1$ 的个数|\n|$7$|$a\\text{，}b$|$\\max {(a,b)}$|$\\lvert a\\rvert \\text{，}\\lvert b\\rvert \\le10^9 $|$2 \\times 2$|$14$|无|\n|$8$|$n$|$f(n)$|$1 \\le n \\le 42$|$3 \\times 3$|$20$|$f(n)=\\begin{cases}1 & n<2\\\\f(n-1)+f(n-2) & n\\ge 2\\end{cases}$|", "inputFormat": "本题为提交答案题。", "outputFormat": "第一行为 $n$ 和 $m$，表示你用了 $n$ 行 $m$ 列。\n\n接下来$n\\times m$个部分，第 $i$ 个部分的第一行 $t_i$ 表示在第 $i$ 个处理单元中命令的数量(可以为 $0$)，接下来 $t_i$ 行每行描述一个命令，见上文所述。", "hint": "#### 样例#1解释\n\n这个样例实现了 A+B problem。\n\n第一行的 `1 1` 表示用的处理单元为 $1\\times1$。\n\n第二行表示第一个处理单元有 $5$ 条指令。\n\n第三行的命令在第一个周期执行，读入了一个数(假定为 $a$) ，此时该单元的状态为 $\\text{key}= 0 \\text{，}\\text{tmp}= a$。\n\n第四行在第二个周期执行，交换了 $\\text{key}$ 和 $\\text{tmp}$，状态为 $\\text{key}= a \\text{，}\\text{tmp}= 0$。\n\n第五行在第三个周期执行，读入了另一个数 $b$，状态为 $\\text{key}= a \\text{，}\\text{tmp}= b$。\n\n第六行在第四个周期执行，给 $\\text{key}$ 加上 $\\text{tmp}$，状态为 $\\text{key}= a+b \\text{，}\\text{tmp}= b$。\n\n第七行在第五个周期执行，输出该单元的 $\\text{key}$，即输出了 $a+b$。\n\n\n如果你的程序在 $2000$ 个周期内没有运行完毕，或者有语法错误，或者超过处理单元尺寸限制，得 $0$ 分。\n\n如果你的第 $i$ 个任务的程序能得出正确的结果，并且和标准答案运行所需的周期数量相同或比其更少，得会得到该测试点的满分，否则设你的程序运行了 $a$ 个周期，标准答案运行了 $s$ 个周期，你的分数为 $\\lfloor\\text{该测试点分数}\\times(\\frac{s}{a})\\times0.8 \\rfloor$(注意，部分正确显示WA,但是仍然有分数)。\n\n```cpp\nP1=7\nP2=9\nP3=12\nP4=12\nP5=13\nP6=13\nP7=14\nP8=20\n```\n\nPS:如果你构造了什么好玩的土豆程序(可以和本题目中的任务无关)，请到答疑博客下或者私信告诉我，会酌情给予奖励。\n\nCheck 下载见附件。\n\nexample2.out：\n\n```\n2 2 8 in add tmp\nL 3 get r add tmp\nget d add tmp\nout 3 wait get l add tmp\n3 wait get u add tmp\n```", "locale": "zh-CN"}}}
{"pid": "P2683", "type": "P", "difficulty": 3, "samples": [["3 8 \n1 3 1 10 \n0 2 3 \n1 2 3 20 \n1 1 2 5 \n0 3 2 \n1 1 3 7 \n1 2 1 9 \n0 2 3", "-1\n15\n12"], ["5 16\n1 1 2 343750\n1 1 3 3343\n1 1 4 347392\n1 1 5 5497\n1 2 3 123394\n1 2 4 545492\n1 2 5 458\n1 3 4 343983\n1 3 5 843468\n1 4 5 15934\n0 2 1\n0 4 1\n0 3 2\n0 4 2\n0 4 3\n0 5 3", "5955\n21431\n9298\n16392\n24774\n8840"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "2015", "安徽"], "title": "[AHOI2015 初中组] 小岛", "background": "西伯利亚北部的寒地，坐落着由 $N$ 个小岛组成的岛屿群，我们把这些小岛依次编号为 $1$ 到 $N$。", "description": "起初，岛屿之间没有任何的航线。后来随着交通的发展，逐渐出现了一些连通两座小岛的航线。例如增加一条在 $u$ 号小岛与 $v$ 号小岛之间的航线，这条航线的用时为 $e$。那么沿着这条航线，$u$ 号小岛上的人可以前往 $v$ 号小岛，同样的 $v$ 号小岛上的人也可以前往 $u$ 号小岛，其中沿着这一条航线花费的时间为 $e$。\n\n同时，随着旅游业的发展，越来越多的人前来游玩。那么两个小岛之间的最短路径是多少便成为了饱受关注的话题。", "inputFormat": "输入共 $M+1$ 行。\n\n第一行有两个整数 $N$ 和 $M$，分别表示小岛的数与总操作数。\n\n接下来的 $M$ 行，每行表示一个操作，格式如下：\n\n`0 s t`：表示询问从 $s$ 号小岛到 $t$ 号小岛的最短用时（$1\\le s\\le n,~ 1\\le t\\le n,~ s\\neq t$）。\n\n`1 u v e`：表示新增了一条从 $u$ 号小岛到 $v$ 号小岛，用时为 $e$ 的双向航线（$1\\le u\\le n, ~1\\le v\\le n,~ u ≠ v,~ 1\\le e\\le 10^6$）。", "outputFormat": "输出针对每一次询问，单独输出一行。\n\n对于每一组询问来说，如果不存在可行的道路，则输出 `-1`，否则输出最短用时。", "hint": "对于 $20\\%$ 的数据，$N\\le 5$ 且 $M\\le 30$。\n\n对于 $40\\%$ 的数据，$N\\le 20$ 且 $M\\le 200$。\n\n对于 $60\\%$ 的数据，$N\\le 80$ 且 $M\\le 500$。\n\n对于 $80\\%$ 的数据，$N\\le 100$ 且 $M\\le 2500$。\n\n对于 $100\\%$ 的数据，$N\\le 100$ 且 $M\\le 5000$。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2015 Middle School Division] Small Island", "background": "In the frigid lands of northern Siberia lies an archipelago consisting of $N$ small islands, which we number from $1$ to $N$ in order.", "description": "At first, there are no routes between the islands. Later, as transportation develops, routes connecting pairs of islands gradually appear. For example, when a route between island $u$ and island $v$ is added with travel time $e$, people on island $u$ can travel to island $v$, and people on island $v$ can also travel to island $u$, with time $e$ along this route.\n\nMeanwhile, with the growth of tourism, more and more people come to visit. The shortest path between two islands has therefore become a topic of great interest.", "inputFormat": "The input has $M+1$ lines.\n\nThe first line contains two integers $N$ and $M$, representing the number of islands and the total number of operations, respectively.\n\nEach of the next $M$ lines describes one operation, in one of the following formats:\n\n`0 s t`: Query the shortest travel time from island $s$ to island $t$ ($1 \\le s \\le N$, $1 \\le t \\le N$, $s \\ne t$).\n\n`1 u v e`: Add a new bidirectional route between island $u$ and island $v$ with travel time $e$ ($1 \\le u \\le N$, $1 \\le v \\le N$, $u \\ne v$, $1 \\le e \\le 10^6$).", "outputFormat": "For each query, output one line.\n\nFor each query, if no feasible path exists, output `-1`; otherwise, output the shortest travel time.", "hint": "For $20\\%$ of the testdata, $N \\le 5$ and $M \\le 30$.\n\nFor $40\\%$ of the testdata, $N \\le 20$ and $M \\le 200$.\n\nFor $60\\%$ of the testdata, $N \\le 80$ and $M \\le 500$.\n\nFor $80\\%$ of the testdata, $N \\le 100$ and $M \\le 2500$.\n\nFor $100\\%$ of the testdata, $N \\le 100$ and $M \\le 5000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2015 初中组] 小岛", "background": "西伯利亚北部的寒地，坐落着由 $N$ 个小岛组成的岛屿群，我们把这些小岛依次编号为 $1$ 到 $N$。", "description": "起初，岛屿之间没有任何的航线。后来随着交通的发展，逐渐出现了一些连通两座小岛的航线。例如增加一条在 $u$ 号小岛与 $v$ 号小岛之间的航线，这条航线的用时为 $e$。那么沿着这条航线，$u$ 号小岛上的人可以前往 $v$ 号小岛，同样的 $v$ 号小岛上的人也可以前往 $u$ 号小岛，其中沿着这一条航线花费的时间为 $e$。\n\n同时，随着旅游业的发展，越来越多的人前来游玩。那么两个小岛之间的最短路径是多少便成为了饱受关注的话题。", "inputFormat": "输入共 $M+1$ 行。\n\n第一行有两个整数 $N$ 和 $M$，分别表示小岛的数与总操作数。\n\n接下来的 $M$ 行，每行表示一个操作，格式如下：\n\n`0 s t`：表示询问从 $s$ 号小岛到 $t$ 号小岛的最短用时（$1\\le s\\le n,~ 1\\le t\\le n,~ s\\neq t$）。\n\n`1 u v e`：表示新增了一条从 $u$ 号小岛到 $v$ 号小岛，用时为 $e$ 的双向航线（$1\\le u\\le n, ~1\\le v\\le n,~ u ≠ v,~ 1\\le e\\le 10^6$）。", "outputFormat": "输出针对每一次询问，单独输出一行。\n\n对于每一组询问来说，如果不存在可行的道路，则输出 `-1`，否则输出最短用时。", "hint": "对于 $20\\%$ 的数据，$N\\le 5$ 且 $M\\le 30$。\n\n对于 $40\\%$ 的数据，$N\\le 20$ 且 $M\\le 200$。\n\n对于 $60\\%$ 的数据，$N\\le 80$ 且 $M\\le 500$。\n\n对于 $80\\%$ 的数据，$N\\le 100$ 且 $M\\le 2500$。\n\n对于 $100\\%$ 的数据，$N\\le 100$ 且 $M\\le 5000$。", "locale": "zh-CN"}}}
{"pid": "P2684", "type": "P", "difficulty": 3, "samples": [["3 10\n1 7\n3 6\n8 10\n", "2\n\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟"], "title": "搞清洁", "background": null, "description": "FJ 准备分配它的 $N$ 只奶牛 $(1 \\le N \\le 2.5\\times 10^4)$ 做清洁工作，他把一天分成 $T(1 \\le T \\le 10^6)$ 个时间段，他希望每一个时间段都有奶牛在清洁，但搞清洁的奶牛数越少越好。", "inputFormat": "第一行，两下整数 $N$ 和 $T$。\n\n接下来 $N$ 行，每行两个整数，表示第 $i$ 头奶牛能工作的时间段。", "outputFormat": "使每一个时间段都有奶牛工作的最少奶牛数，如果不可能，则输出 `-1`。", "hint": "样例解释：\n\n有 $3$ 头奶牛，第 $1$ 头能工作的时间段是 $1\\sim7$，即从时间 $1$ 开始工作，时间 $7$ 结束（时间 $7$ 也在工作的），第 $2$ 头是 $3\\sim6$，第 $3$ 头是 $8\\sim10$，则只需要第 $1$ 头和第 $3$ 头奶牛就能使每一个时间都有奶牛工作。", "locale": "zh-CN", "translations": {"en": {"title": "Cleaning Up", "background": "", "description": "FJ plans to assign his $N$ cows $(1 \\le N \\le 2.5\\times 10^4)$ to do cleaning. He divides the day into $T(1 \\le T \\le 10^6)$ time slots. He wants every time slot to have a cow cleaning, while using as few cows as possible.", "inputFormat": "The first line contains two integers $N$ and $T$.\n\nThe next $N$ lines each contain two integers, representing the time interval during which the $i$-th cow can work (inclusive).", "outputFormat": "Output the minimum number of cows needed so that every time slot has a cow working. If it is impossible, output `-1`.", "hint": "Sample explanation:\n\nThere are $3$ cows. The $1$-st can work during $1\\sim7$, that is, starts at time $1$ and ends at time $7$ (time $7$ is also covered). The $2$-nd works during $3\\sim6$, and the $3$-rd during $8\\sim10$. Then only the $1$-st and the $3$-rd cows are needed to ensure every time slot is covered.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "搞清洁", "background": null, "description": "FJ 准备分配它的 $N$ 只奶牛 $(1 \\le N \\le 2.5\\times 10^4)$ 做清洁工作，他把一天分成 $T(1 \\le T \\le 10^6)$ 个时间段，他希望每一个时间段都有奶牛在清洁，但搞清洁的奶牛数越少越好。", "inputFormat": "第一行，两下整数 $N$ 和 $T$。\n\n接下来 $N$ 行，每行两个整数，表示第 $i$ 头奶牛能工作的时间段。", "outputFormat": "使每一个时间段都有奶牛工作的最少奶牛数，如果不可能，则输出 `-1`。", "hint": "样例解释：\n\n有 $3$ 头奶牛，第 $1$ 头能工作的时间段是 $1\\sim7$，即从时间 $1$ 开始工作，时间 $7$ 结束（时间 $7$ 也在工作的），第 $2$ 头是 $3\\sim6$，第 $3$ 头是 $8\\sim10$，则只需要第 $1$ 头和第 $3$ 头奶牛就能使每一个时间都有奶牛工作。", "locale": "zh-CN"}}}
{"pid": "P2685", "type": "P", "difficulty": 6, "samples": [["3 4\n1 2 1\n1 2 2\n2 3 1\n2 3 2", "3 2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2012", "各省省选", "天津"], "title": "[TJOI2012] 桥", "background": "", "description": "有 $n$ 个岛屿，$m$ 座桥，每座桥连通两座岛屿，桥上会有一些敌人，玩家只有消灭了桥上的敌人才能通过，与此同时桥上的敌人会对玩家造成一定伤害。而且会有一个大 Boss 镇守一座桥，以玩家目前的能力，是不可能通过的。而 Boss 是邪恶的， Boss 会镇守某一座使得玩家受到最多的伤害才能从岛屿 $1$ 到达岛屿 $n$（当然玩家会选择伤害最小的路径）。问，Boss 可能镇守的桥有哪些。\n\n注意可以有**重边**和**自环**。", "inputFormat": "第一行两个整数 $n,m$。\n\n接下来 $m$ 行，每行三个整数 $s,t,c$，表示一座连接岛屿 $s$ 和 $t$ 的桥上的敌人会对玩家造成 $c$ 的伤害。\n", "outputFormat": "一行，两个整数 $d,cnt$，$d$ 表示有 Boss 的情况下，玩家至少要受到的伤害，$cnt$ 表示 Boss 可能镇守的桥的数目。\n", "hint": "- $30\\%$ 的数据，$1 ≤ n ≤ 1000$；\n- $100\\%$ 的数据，$1 ≤ n ≤ 100000, 1 ≤ m ≤ 200000, 1 ≤ c ≤ 10000$；\n- 数据保证玩家可以从岛屿 $1$ 到达岛屿 $n$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2012] Bridge", "background": "", "description": "There are $n$ islands and $m$ bridges. Each bridge connects two islands. There are some enemies on every bridge; the player can pass a bridge only after defeating the enemies on it, and doing so inflicts some damage to the player. There is also a big Boss guarding exactly one bridge, which is impassable for the player given their current ability. The Boss is evil and will choose a bridge to guard so that, after blocking that bridge, the minimum possible total damage the player must suffer to travel from island $1$ to island $n$ (of course the player will choose the path with the least damage) is as large as possible. Determine which bridges the Boss might guard.\n\nNote: **multiple edges** and **self-loops** are allowed.", "inputFormat": "The first line contains two integers $n, m$.\n\nThe next $m$ lines each contain three integers $s, t, c$, indicating that the enemies on the bridge connecting islands $s$ and $t$ will inflict $c$ damage on the player.", "outputFormat": "One line with two integers $d, cnt$, where $d$ is the minimum damage the player must suffer in the presence of the Boss, and $cnt$ is the number of bridges that the Boss might guard.", "hint": "- For $30\\%$ of the testdata, $1 \\le n \\le 1000$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 100000$, $1 \\le m \\le 200000$, $1 \\le c \\le 10000$.\n- It is guaranteed that the player can reach island $n$ from island $1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2012] 桥", "background": "", "description": "有 $n$ 个岛屿，$m$ 座桥，每座桥连通两座岛屿，桥上会有一些敌人，玩家只有消灭了桥上的敌人才能通过，与此同时桥上的敌人会对玩家造成一定伤害。而且会有一个大 Boss 镇守一座桥，以玩家目前的能力，是不可能通过的。而 Boss 是邪恶的， Boss 会镇守某一座使得玩家受到最多的伤害才能从岛屿 $1$ 到达岛屿 $n$（当然玩家会选择伤害最小的路径）。问，Boss 可能镇守的桥有哪些。\n\n注意可以有**重边**和**自环**。", "inputFormat": "第一行两个整数 $n,m$。\n\n接下来 $m$ 行，每行三个整数 $s,t,c$，表示一座连接岛屿 $s$ 和 $t$ 的桥上的敌人会对玩家造成 $c$ 的伤害。\n", "outputFormat": "一行，两个整数 $d,cnt$，$d$ 表示有 Boss 的情况下，玩家至少要受到的伤害，$cnt$ 表示 Boss 可能镇守的桥的数目。\n", "hint": "- $30\\%$ 的数据，$1 ≤ n ≤ 1000$；\n- $100\\%$ 的数据，$1 ≤ n ≤ 100000, 1 ≤ m ≤ 200000, 1 ≤ c ≤ 10000$；\n- 数据保证玩家可以从岛屿 $1$ 到达岛屿 $n$。\n", "locale": "zh-CN"}}}
{"pid": "P2686", "type": "P", "difficulty": 4, "samples": [["6 4 5\n1 3 3 2 2 1\n2 3 1 4 5 2\n", "21\n\n注：样例中，3场，第一场选1，2两题，第二场选3，4两题，第三场选4，5，6三题。\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "线段树", "区间 DP", "前缀和"], "title": "老虎的题目", "background": null, "description": "随着小老虎做题越来越多，现在可做小老师了，小老虎经常帮老师出题供信息学奥赛班的同学测试用。出题确实是一件麻烦事。现在有更麻烦的事了：\n\n小老虎收集到了一大堆的题目，并且按照收集的时间顺序排成一排。每个题目都有自己的题面长度和难度。小老虎想用这些题出好多好多场比赛。但是呢，有要求：\n\n- 同一场比赛的题目，必须是这一排题目中连续的一段，但题目数量不限。\n- 题面长度的总和，不能超过 $H$，也不能低于 $L$。\n- 不允许出现两场比赛，使得其中一场的题目全部在另一场出现过了。（也就是说，不同比赛的题目集合不能出现包含和被包含关系）\n\n题目可以在不同比赛中重复使用。\n\n\n现在，小老虎想知道，在满足以上条件的基础上，所有比赛的难度总和最大是多少？（定义一场比赛的难度为本场比赛出现的所有题目的难度和）", "inputFormat": "第一行是三个整数，$N$、$L$、$H$。\n\n第二行有 $N$ 个整数，第 $i$ 个整数 $a_i$ 代表第 $i$ 题题面的长度。\n\n第三行有 $N$ 个整数，第 $i$ 个整数 $b_i$ 代表第 $i$ 题题目的难度。", "outputFormat": "输出一个整数，所有比赛的最大难度总和。", "hint": "对于 $40\\%$ 的数据，$1 \\le N \\le 100$。\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 1000$，$0 \\le a_i,b_i \\le {10}^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Tiger's Problem", "background": null, "description": "As Little Tiger solves more and more problems, he can now act as a little teacher and often helps teachers create problems for the informatics olympiad class to use for practice. Making problems is indeed a troublesome task. Now there is an even more troublesome situation:\n\nLittle Tiger has collected a large number of problems and arranged them in a sequence in the order they were collected. Each problem has its own statement length and difficulty. Little Tiger wants to use these problems to create many contests. However, there are requirements:\n\n- The problems in the same contest must form a contiguous segment of this sequence, and the number of problems is unrestricted.\n- The total statement length must not exceed $H$ and must not be less than $L$.\n- It is not allowed to have two contests such that all problems of one contest also appear in the other. (In other words, the problem sets of different contests must not have a containment or be-contained relationship.)\n\nProblems may be reused across different contests.\n\nNow, Little Tiger wants to know, under the above constraints, what is the maximum possible total difficulty over all contests? (Define the difficulty of a contest as the sum of the difficulties of all problems appearing in that contest.)", "inputFormat": "The first line contains three integers $N$, $L$, and $H$.\n\nThe second line contains $N$ integers. The $i$-th integer $a_i$ denotes the statement length of the $i$-th problem.\n\nThe third line contains $N$ integers. The $i$-th integer $b_i$ denotes the difficulty of the $i$-th problem.", "outputFormat": "Output a single integer: the maximum total difficulty over all contests.", "hint": "For $40\\%$ of the testdata, $1 \\le N \\le 100$.\n\nFor $100\\%$ of the testdata, $1 \\le N \\le 1000$, $0 \\le a_i, b_i \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "老虎的题目", "background": null, "description": "随着小老虎做题越来越多，现在可做小老师了，小老虎经常帮老师出题供信息学奥赛班的同学测试用。出题确实是一件麻烦事。现在有更麻烦的事了：\n\n小老虎收集到了一大堆的题目，并且按照收集的时间顺序排成一排。每个题目都有自己的题面长度和难度。小老虎想用这些题出好多好多场比赛。但是呢，有要求：\n\n- 同一场比赛的题目，必须是这一排题目中连续的一段，但题目数量不限。\n- 题面长度的总和，不能超过 $H$，也不能低于 $L$。\n- 不允许出现两场比赛，使得其中一场的题目全部在另一场出现过了。（也就是说，不同比赛的题目集合不能出现包含和被包含关系）\n\n题目可以在不同比赛中重复使用。\n\n\n现在，小老虎想知道，在满足以上条件的基础上，所有比赛的难度总和最大是多少？（定义一场比赛的难度为本场比赛出现的所有题目的难度和）", "inputFormat": "第一行是三个整数，$N$、$L$、$H$。\n\n第二行有 $N$ 个整数，第 $i$ 个整数 $a_i$ 代表第 $i$ 题题面的长度。\n\n第三行有 $N$ 个整数，第 $i$ 个整数 $b_i$ 代表第 $i$ 题题目的难度。", "outputFormat": "输出一个整数，所有比赛的最大难度总和。", "hint": "对于 $40\\%$ 的数据，$1 \\le N \\le 100$。\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 1000$，$0 \\le a_i,b_i \\le {10}^5$。", "locale": "zh-CN"}}}
{"pid": "P2687", "type": "P", "difficulty": 4, "samples": [["12\n68 69 54 64 68 64 70 67\n78 62 98 87", "4 2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "USACO"], "title": "[USACO4.3] 逢低吸纳 Buy Low, Buy Lower", "background": "本题可以使用 `long double` 通过是刻意的。加强版请到 [P12930](https://www.luogu.com.cn/problem/P12930)。在本题中，$N\\leq 5000$。", "description": "“逢低吸纳”是炒股的一条成功秘诀。如果你想成为一个成功的投资者，就要遵守这条秘诀：“逢低吸纳，越低越买”。\n\n这句话的意思是：每次你购买股票时的股价一定要比你上次购买时的股价低。按照这个规则购买股票的次数越多越好，看看你最多能按这个规则买几次。\n\n给定连续的 $N$ 天中每天的股价。你可以在任何一天购买一次股票，但是购买时的股价一定要比你上次购买时的股价低。写一个程序，求出最多能买几次股票。\n\n以下面这个表为例，某几天的股价是：\n\n|天数    |股价    |\n|:-------|:-------|\n|$1$|$68$|\n|$2$|$69$|\n|$3$|$54$|\n|$4$|$64$|\n|$5$|$68$|\n|$6$|$64$|\n|$7$|$70$|\n|$8$|$67$|\n|$9$|$78$|\n|$10$|$62$|\n|$11$|$98$|\n|$12$|$87$|\n\n\n这个例子中，如果每次买股票时的股价都比上一次买时低，那么最多能买 $4$ 次股票。一种买法如下（可能有其他的买法）：\n\n\n|天数    |股价    |\n|:-------|:-------|\n|$2$|$69$|\n|$5$|$68$|\n|$6$|$64$|\n|$10$|$62$|", "inputFormat": "第 $1$ 行：一个整数 $N$，表示能买股票的天数。\n\n以后多行，输入 $N$ 个正整数（可能分多行），第 $i$ 个正整数表示第 $i$ 天的股价。这些正整数大小不会超过 $2^{31}-1$。", "outputFormat": "一行两个整数，表示按每次买股票时的股价都比上一次买时低的要求最多能够买进股票的天数，和能够买进这些天数的股票的股票购买方案数量。\n\n两个方案不相同当且仅当这两个方案中所购买的股票的价格序列不相同。", "hint": "$1 \\le N \\le 5000$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO4.3] Buy on Dips — Buy Low, Buy Lower", "background": "It is intentional that using `long double` can pass this problem. For a strengthened version, see [P12930](https://www.luogu.com.cn/problem/P12930). In this problem, $N\\leq 5000$.", "description": "“Buy on dips” is a successful tip for stock trading. If you want to be a successful investor, follow this tip: “Buy on dips, the lower the better.”\n\nThis means: every time you buy, the stock price must be lower than the price at your previous purchase. The more times you can buy under this rule, the better. See how many times at most you can buy following this rule.\n\nYou are given the price of the stock for each of $N$ consecutive days. You may buy once on any day, but the price at purchase must be lower than the price at your previous purchase. Write a program to find the maximum number of times you can buy.\n\nFor example, suppose the prices on some days are:\n\n|Day    |Price    |\n|:-------|:-------|\n|$1$|$68$|\n|$2$|$69$|\n|$3$|$54$|\n|$4$|$64$|\n|$5$|$68$|\n|$6$|$64$|\n|$7$|$70$|\n|$8$|$67$|\n|$9$|$78$|\n|$10$|$62$|\n|$11$|$98$|\n|$12$|$87$|\n\nIn this example, if each purchase price is lower than the previous one, you can buy at most $4$ times. One valid way is as follows (there may be others):\n\n\n|Day    |Price    |\n|:-------|:-------|\n|$2$|$69$|\n|$5$|$68$|\n|$6$|$64$|\n|$10$|$62$|", "inputFormat": "The first line: an integer $N$, the number of days on which you can buy.\n\nThen $N$ positive integers (possibly across multiple lines), where the $i$-th integer is the stock price on day $i$. Each integer does not exceed $2^{31}-1$.", "outputFormat": "One line with two integers: the maximum number of days you can buy under the rule that each purchase price is lower than the previous one, and the number of purchase plans that achieve this maximum.\n\nTwo plans are different if and only if the sequences of purchased prices are different.", "hint": "$1 \\le N \\le 5000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO4.3] 逢低吸纳 Buy Low, Buy Lower", "background": "本题可以使用 `long double` 通过是刻意的。加强版请到 [P12930](https://www.luogu.com.cn/problem/P12930)。在本题中，$N\\leq 5000$。", "description": "“逢低吸纳”是炒股的一条成功秘诀。如果你想成为一个成功的投资者，就要遵守这条秘诀：“逢低吸纳，越低越买”。\n\n这句话的意思是：每次你购买股票时的股价一定要比你上次购买时的股价低。按照这个规则购买股票的次数越多越好，看看你最多能按这个规则买几次。\n\n给定连续的 $N$ 天中每天的股价。你可以在任何一天购买一次股票，但是购买时的股价一定要比你上次购买时的股价低。写一个程序，求出最多能买几次股票。\n\n以下面这个表为例，某几天的股价是：\n\n|天数    |股价    |\n|:-------|:-------|\n|$1$|$68$|\n|$2$|$69$|\n|$3$|$54$|\n|$4$|$64$|\n|$5$|$68$|\n|$6$|$64$|\n|$7$|$70$|\n|$8$|$67$|\n|$9$|$78$|\n|$10$|$62$|\n|$11$|$98$|\n|$12$|$87$|\n\n\n这个例子中，如果每次买股票时的股价都比上一次买时低，那么最多能买 $4$ 次股票。一种买法如下（可能有其他的买法）：\n\n\n|天数    |股价    |\n|:-------|:-------|\n|$2$|$69$|\n|$5$|$68$|\n|$6$|$64$|\n|$10$|$62$|", "inputFormat": "第 $1$ 行：一个整数 $N$，表示能买股票的天数。\n\n以后多行，输入 $N$ 个正整数（可能分多行），第 $i$ 个正整数表示第 $i$ 天的股价。这些正整数大小不会超过 $2^{31}-1$。", "outputFormat": "一行两个整数，表示按每次买股票时的股价都比上一次买时低的要求最多能够买进股票的天数，和能够买进这些天数的股票的股票购买方案数量。\n\n两个方案不相同当且仅当这两个方案中所购买的股票的价格序列不相同。", "hint": "$1 \\le N \\le 5000$。", "locale": "zh-CN"}}}
{"pid": "P2688", "type": "P", "difficulty": 6, "samples": [["3\n12 2 2\n1 1\n2 5\n6 8\n5 1 2\n3 1\n1 5\n11 3 0\n2 2\n3 1\n5 1", "2\n-1\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "二分"], "title": "大海战", "background": "一天，GD和MW正在玩一款名叫大海战的游戏。\n", "description": "游戏在一个 $1 \\times n$ 的棋盘上进行。一开始 GD 拥有 $c$ 种战舰，每种战舰的宽度为 $1$，长度为 $c_i$，共有 $t_i$ 个。GD 要将所有这些战舰放置在棋盘上，并且任意两艘战舰间不能重叠（但可以相邻）。\n\n接下来，MW 进行 $q$ 次“攻击”，每次攻击一个 $1 \\times 1$ 的格子，而 MW 将告知他这次攻击是否“打中”了一艘战舰（或者它的某个部分）。\n\n令人疑惑的是，每次 MW 都告诉 GD 说他没有打中任何一艘战舰，而这显然是不现实的。现在 MW 把整个游戏的过程告诉了你，他想知道，最早在他的第几次询问之后，可以断定 GD 一定（至少有一次）说了谎。", "inputFormat": "**本题单测试点内有多组数据**。\n\n第一行一个整数 $t$，表示测试数据的组数。    \n\n每组数据的输入格式如下：\n\n每组数据的第一行有三个整数，分别代表棋盘的长度 $n$ 、战舰的种数 $c$ 和攻击的次数 $q$。\n\n对于每组数据的第 $2$ 到第 $(c + 1)$ 行，每行两个整数，第 $(i + 1)$ 行的两个整数分别代表第 $i$ 种战舰的长度 $c_i$ 和数量 $t_i$。\n\n第 $(c + 2)$ 行有 $q$ 个整数，第 $i$ 个整数 $a_i$ 代表 MW 第 $i$ 次攻击的位置。", "outputFormat": "对于每组数据，输出一个整数 $ans$，表示最早在第 $ans$ 次操作后可以断定 GD 说了谎。特别地，如果一开始就不可能按要求摆上所有的战舰，输出 $0$；如果 $q$ 次询问后都不能判断 GD 是否说了谎，则输出 $-1$。", "hint": "#### 样例输入输出 1 解释\n\n- 对于第一个样例，存在布阵 $\\{1,22,22,0,22,22,22\\}$（$0$ 表示没有放置），使得第一次不会受到攻击；不存在一个布阵使得两次都没有受到攻击。\n- 对于第二个样例，存在布阵 $\\{0,333,0\\}$，使得两次均不会受到攻击。\n- 对于第三个样例，一开始就不可能把所有战舰合法地布置在棋盘上。\n\n---\n\n#### 数据规模与约定\n\n- 对于测试点1，$n \\leq 1000000000$，$c \\leq 100000$，$q=0$；\n- 对于测试点2、3，所有的 $t_i$ 均为 $1$；\n- 对于测试点2-8，$n \\leq 400000$，$c \\leq 100$，$q=1$；\n- 对于测试点9，$n \\leq 100$，$c=1$，$q \\leq 100$；\n- 对于测试点10-14，$n \\leq 200000$，$c=1$，$q \\leq 200000$；\n- 对于测试点15、16，$n \\leq 200$，$c=2$，$q \\leq 200$；\n- 对于测试点17-20，$n \\leq 4000$，$c=2$，$q \\leq 4000$。\n- 对于 $100\\%$ 的数据，$1 \\le t \\le 5,n \\ge 1,c \\ge 1,q \\ge 0,1 \\le q_i \\le n,0 \\le c_i \\le 10^5,0 \\le t_i \\le 10^5$。\n\n---\n\n#### 提示\n\n- 请注意常数因子对程序效率造成的影响。\n\n", "locale": "zh-CN", "translations": {"en": {"title": "Battleship", "background": "One day, GD and MW were playing a game called Battleship.", "description": "The game is played on a $1 \\times n$ board. Initially, GD has $c$ types of ships. Each ship has width $1$, length $c_i$, and there are $t_i$ ships of the $i$-th type. GD must place all these ships on the board so that no two ships overlap (they may be adjacent).\n\nNext, MW makes $q$ “attacks,” each time targeting a $1 \\times 1$ cell, and GD will tell him whether that attack “hit” a ship (or any part of it).\n\nPuzzlingly, GD tells MW every time that he did not hit any ship, which is clearly unrealistic. Now MW reveals the entire gameplay to you. He wants to know the earliest time, after which of his attacks, one can conclude that GD must have lied at least once.", "inputFormat": "There are multiple test cases within a single test file.\n\nThe first line contains an integer $t$, the number of test cases.\n\nFor each test case:\n\n- The first line contains three integers, the board length $n$, the number of ship types $c$, and the number of attacks $q$.\n- The next $c$ lines (lines $2$ to $(c + 1)$) each contain two integers. On line $(i + 1)$, the two integers are the length $c_i$ and the count $t_i$ of the $i$-th type of ship.\n- Line $(c + 2)$ contains $q$ integers. The $i$-th integer $a_i$ is the position targeted by MW’s $i$-th attack.", "outputFormat": "For each test case, output a single integer $ans$, the earliest index such that after the $ans$-th operation you can conclude GD has lied. In particular, if it is impossible from the very beginning to place all ships as required, output $0$. If after all $q$ attacks you still cannot determine whether GD has lied, output $-1$.", "hint": "- Sample Input/Output 1 Explanation:\n  - For the first sample, there exists a layout $\\{1,22,22,0,22,22,22\\}$ ($0$ means empty) such that the first attack misses; no layout can make both attacks miss.\n  - For the second sample, there exists a layout $\\{0,333,0\\}$ such that both attacks miss.\n  - For the third sample, it is impossible to place all ships legally from the start.\n\n- Constraints:\n  - For test point 1, $n \\leq 1000000000$, $c \\leq 100000$, $q = 0$.\n  - For test points 2–3, all $t_i$ are $1$.\n  - For test points 2–8, $n \\leq 400000$, $c \\leq 100$, $q = 1$.\n  - For test point 9, $n \\leq 100$, $c = 1$, $q \\leq 100$.\n  - For test points 10–14, $n \\leq 200000$, $c = 1$, $q \\leq 200000$.\n  - For test points 15–16, $n \\leq 200$, $c = 2$, $q \\leq 200$.\n  - For test points 17–20, $n \\leq 4000$, $c = 2$, $q \\leq 4000$.\n  - For $100\\%$ of the testdata, $1 \\le t \\le 5, n \\ge 1, c \\ge 1, q \\ge 0, 1 \\le a_i \\le n, 0 \\le c_i \\le 10^5, 0 \\le t_i \\le 10^5$.\n\n- Note: Please be mindful of the impact of constant factors on performance.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "大海战", "background": "一天，GD和MW正在玩一款名叫大海战的游戏。\n", "description": "游戏在一个 $1 \\times n$ 的棋盘上进行。一开始 GD 拥有 $c$ 种战舰，每种战舰的宽度为 $1$，长度为 $c_i$，共有 $t_i$ 个。GD 要将所有这些战舰放置在棋盘上，并且任意两艘战舰间不能重叠（但可以相邻）。\n\n接下来，MW 进行 $q$ 次“攻击”，每次攻击一个 $1 \\times 1$ 的格子，而 MW 将告知他这次攻击是否“打中”了一艘战舰（或者它的某个部分）。\n\n令人疑惑的是，每次 MW 都告诉 GD 说他没有打中任何一艘战舰，而这显然是不现实的。现在 MW 把整个游戏的过程告诉了你，他想知道，最早在他的第几次询问之后，可以断定 GD 一定（至少有一次）说了谎。", "inputFormat": "**本题单测试点内有多组数据**。\n\n第一行一个整数 $t$，表示测试数据的组数。    \n\n每组数据的输入格式如下：\n\n每组数据的第一行有三个整数，分别代表棋盘的长度 $n$ 、战舰的种数 $c$ 和攻击的次数 $q$。\n\n对于每组数据的第 $2$ 到第 $(c + 1)$ 行，每行两个整数，第 $(i + 1)$ 行的两个整数分别代表第 $i$ 种战舰的长度 $c_i$ 和数量 $t_i$。\n\n第 $(c + 2)$ 行有 $q$ 个整数，第 $i$ 个整数 $a_i$ 代表 MW 第 $i$ 次攻击的位置。", "outputFormat": "对于每组数据，输出一个整数 $ans$，表示最早在第 $ans$ 次操作后可以断定 GD 说了谎。特别地，如果一开始就不可能按要求摆上所有的战舰，输出 $0$；如果 $q$ 次询问后都不能判断 GD 是否说了谎，则输出 $-1$。", "hint": "#### 样例输入输出 1 解释\n\n- 对于第一个样例，存在布阵 $\\{1,22,22,0,22,22,22\\}$（$0$ 表示没有放置），使得第一次不会受到攻击；不存在一个布阵使得两次都没有受到攻击。\n- 对于第二个样例，存在布阵 $\\{0,333,0\\}$，使得两次均不会受到攻击。\n- 对于第三个样例，一开始就不可能把所有战舰合法地布置在棋盘上。\n\n---\n\n#### 数据规模与约定\n\n- 对于测试点1，$n \\leq 1000000000$，$c \\leq 100000$，$q=0$；\n- 对于测试点2、3，所有的 $t_i$ 均为 $1$；\n- 对于测试点2-8，$n \\leq 400000$，$c \\leq 100$，$q=1$；\n- 对于测试点9，$n \\leq 100$，$c=1$，$q \\leq 100$；\n- 对于测试点10-14，$n \\leq 200000$，$c=1$，$q \\leq 200000$；\n- 对于测试点15、16，$n \\leq 200$，$c=2$，$q \\leq 200$；\n- 对于测试点17-20，$n \\leq 4000$，$c=2$，$q \\leq 4000$。\n- 对于 $100\\%$ 的数据，$1 \\le t \\le 5,n \\ge 1,c \\ge 1,q \\ge 0,1 \\le q_i \\le n,0 \\le c_i \\le 10^5,0 \\le t_i \\le 10^5$。\n\n---\n\n#### 提示\n\n- 请注意常数因子对程序效率造成的影响。\n\n", "locale": "zh-CN"}}}
{"pid": "P2689", "type": "P", "difficulty": 1, "samples": [["1 1\n2 2\n5\nE\nN\nW\nW\nN", "2"], ["1 1\n2 2\n1\nW", "-1"], ["1 1\n2 2\n3\nW\nW\nW", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "搜索", "洛谷原创"], "title": "东南西北", "background": null, "description": "给出起点和终点的坐标，及接下来 $T$ 个时刻的顺风方向（东南西北），每个时刻可以选择顺风偏移 $1$ 个单位或者不移动。求到达终点的**最少移动步数**。\n\n坐标采用平面直角坐标系，$x$ 轴正向为东，$y$ 轴正向为北。\n\n如果无法偏移至终点，输出 $-1$。", "inputFormat": "第一行两个正整数 $x_1,y_1$，表示起点坐标。\n\n第二行两个正整数 $x_2,y_2$，表示终点坐标。\n\n第三行一个整数 $T$，表示 $T$ 个时刻。\n\n第四至第 $T+3$ 行，每行一个字符，表示顺风方向，即东（$\\verb!E!$）南（$\\verb!S!$）西（$\\verb!W!$）北（$\\verb!N!$）的英文单词的首字母。", "outputFormat": "一行一个整数，表示最少移动步数。", "hint": "### 样例解释\n\n- 样例 $1$：向东走一步，向北走一步。\n- 样例 $2,3$：无法到达。\n\n### 数据范围\n\n对于全部数据，$1\\le x_1,y_1,x_2,y_2,T\\le 50$。", "locale": "zh-CN", "translations": {"en": {"title": "East, South, West, North", "background": "", "description": "Given the coordinates of the start and end points, and the wind direction (east, south, west, north) at each of the next $T$ time steps, you may either move $1$ unit with the wind or stay in place at each time step. Find the **minimum number of moves** needed to reach the destination.\n\nThe coordinate system is the Cartesian plane, where the positive $x$-axis points east and the positive $y$-axis points north.\n\nIf it is impossible to reach the destination, output $-1$.", "inputFormat": "The first line contains two positive integers $x_1, y_1$, representing Xiaoming’s current position.\n\nThe second line contains two positive integers $x_2, y_2$, representing the position Xiaoming wants to reach.\n\nThe third line contains an integer $T$, representing $T$ time steps.\n\nFrom line $4$ to line $T+3$, each line contains one character representing the wind direction, i.e., the first letter of the English words for east ($\\verb!E!$), south ($\\verb!S!$), west ($\\verb!W!$), and north ($\\verb!N!$).", "outputFormat": "Output a single integer, the minimum number of moves.", "hint": "Sample Explanation\n\n- Sample $1$: Move one step east, then one step north.\n- Samples $2$ and $3$: Impossible to reach.\n\nConstraints\n\nFor all testdata, $1 \\le T \\le 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "东南西北", "background": null, "description": "给出起点和终点的坐标，及接下来 $T$ 个时刻的顺风方向（东南西北），每个时刻可以选择顺风偏移 $1$ 个单位或者不移动。求到达终点的**最少移动步数**。\n\n坐标采用平面直角坐标系，$x$ 轴正向为东，$y$ 轴正向为北。\n\n如果无法偏移至终点，输出 $-1$。", "inputFormat": "第一行两个正整数 $x_1,y_1$，表示起点坐标。\n\n第二行两个正整数 $x_2,y_2$，表示终点坐标。\n\n第三行一个整数 $T$，表示 $T$ 个时刻。\n\n第四至第 $T+3$ 行，每行一个字符，表示顺风方向，即东（$\\verb!E!$）南（$\\verb!S!$）西（$\\verb!W!$）北（$\\verb!N!$）的英文单词的首字母。", "outputFormat": "一行一个整数，表示最少移动步数。", "hint": "### 样例解释\n\n- 样例 $1$：向东走一步，向北走一步。\n- 样例 $2,3$：无法到达。\n\n### 数据范围\n\n对于全部数据，$1\\le x_1,y_1,x_2,y_2,T\\le 50$。", "locale": "zh-CN"}}}
{"pid": "P2690", "type": "P", "difficulty": 3, "samples": [["7 2\n2\n1\n1\n2\n2\n1\n1\n", "6\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "搜索", "2004", "USACO", "记忆化搜索"], "title": "[USACO04NOV] Apple Catching G", "background": "", "description": "很少有人知道奶牛爱吃苹果。农夫约翰的农场上有两棵苹果树（编号为 $1$ 和 $2$ ）， 每一棵树上都长满了苹果。奶牛贝茜无法摘下树上的苹果，所以她只能等待苹果 从树上落下。但是，由于苹果掉到地上会摔烂，贝茜必须在半空中接住苹果（没有人爱吃摔烂的苹果）。贝茜吃东西很快，她接到苹果后仅用几秒钟就能吃完。每一分钟，两棵苹果树其中的一棵会掉落一个苹果。贝茜已经过了足够的训练， 只要站在树下就一定能接住这棵树上掉落的苹果。同时，贝茜能够在两棵树之间 快速移动（移动时间远少于 $1$ 分钟），因此当苹果掉落时，她必定站在两棵树其中的一棵下面。此外，奶牛不愿意不停地往返于两棵树之间，因此会错过一些苹果。苹果每分钟掉落一个，共 $T$（$1 \\le T \\le 1000$）分钟，贝茜最多愿意移动 $W$（$1 \\le W \\le 30$） 次。现给出每分钟掉落苹果的树的编号，要求判定贝茜能够接住的最多苹果数。 开始时贝茜在 1 号树下。", "inputFormat": "第一行 $2$ 个数， $T$ 和 $W$。接下来的 $t$ 行，每行一个数，代表在时刻 $t$ 苹果是从 $1$ 号苹果树还是从 $2$ 号苹果树上掉下来的。", "outputFormat": "对于每个测试点，输出一行，一个数，为奶牛最多接到的苹果的数量。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[USACO04NOV] Apple Catching G", "background": "", "description": "Few people know that cows love apples. There are two apple trees on Farmer John's farm (numbered $1$ and $2$), and both are laden with apples. Bessie the cow cannot pick apples from the trees, so she must wait for apples to fall. However, since apples that hit the ground get smashed, Bessie must catch them in midair (nobody likes smashed apples). Bessie eats quickly and can finish an apple within a few seconds after catching it.\n\nEvery minute, exactly one of the two trees drops one apple. Bessie is well trained: as long as she stands under a tree, she is guaranteed to catch any apple that falls from that tree. She can move quickly between the two trees (the moving time is much less than $1$ minute), so when an apple falls, she will definitely be standing under one of the two trees. However, she is unwilling to keep running back and forth between the trees, so she may miss some apples.\n\nApples fall once per minute for $T$ minutes ($1 \\le T \\le 1000$). Bessie is willing to move at most $W$ times ($1 \\le W \\le 30$). Given, for each minute, the index of the tree from which an apple falls, determine the maximum number of apples Bessie can catch. Initially, Bessie is under tree 1.", "inputFormat": "The first line contains 2 integers, $T$ and $W$. The next $T$ lines each contain one integer, indicating whether at that minute the apple falls from tree $1$ or tree $2$.", "outputFormat": "For each test case, output one line with a single integer: the maximum number of apples Bessie can catch.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO04NOV] Apple Catching G", "background": "", "description": "很少有人知道奶牛爱吃苹果。农夫约翰的农场上有两棵苹果树（编号为 $1$ 和 $2$ ）， 每一棵树上都长满了苹果。奶牛贝茜无法摘下树上的苹果，所以她只能等待苹果 从树上落下。但是，由于苹果掉到地上会摔烂，贝茜必须在半空中接住苹果（没有人爱吃摔烂的苹果）。贝茜吃东西很快，她接到苹果后仅用几秒钟就能吃完。每一分钟，两棵苹果树其中的一棵会掉落一个苹果。贝茜已经过了足够的训练， 只要站在树下就一定能接住这棵树上掉落的苹果。同时，贝茜能够在两棵树之间 快速移动（移动时间远少于 $1$ 分钟），因此当苹果掉落时，她必定站在两棵树其中的一棵下面。此外，奶牛不愿意不停地往返于两棵树之间，因此会错过一些苹果。苹果每分钟掉落一个，共 $T$（$1 \\le T \\le 1000$）分钟，贝茜最多愿意移动 $W$（$1 \\le W \\le 30$） 次。现给出每分钟掉落苹果的树的编号，要求判定贝茜能够接住的最多苹果数。 开始时贝茜在 1 号树下。", "inputFormat": "第一行 $2$ 个数， $T$ 和 $W$。接下来的 $t$ 行，每行一个数，代表在时刻 $t$ 苹果是从 $1$ 号苹果树还是从 $2$ 号苹果树上掉下来的。", "outputFormat": "对于每个测试点，输出一行，一个数，为奶牛最多接到的苹果的数量。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2691", "type": "P", "difficulty": 5, "samples": [["6\n10\n2 2\n2 4\n2 6\n3 1\n3 2\n3 4\n3 6\n4 2\n4 4\n4 6\n", "YES"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论"], "title": "逃离", "background": "", "description": "**译自 CLRS Problem 26-1 Escape problem**\n\n在一个 $n\\times n$ 的网格中有 $m$ 个起始点 $(x_1, y_1),$ $(x_2, y_2),$ $\\dots,$ $(x_m, y_m)$，试问：能否为这些结点分别找一条到边界的路径，且这 $m$ 条路径互不相交（即任意两条路径上没有一个相同的结点）。\n\n![https://i.loli.net/2018/10/14/5bc2ec2948f8b.png](https://i.loli.net/2018/10/14/5bc2ec2948f8b.png)\n\n黑点表示起始点，其他点用白点表示。找出的路径用加粗的线表示。图 (a) 存在符合条件的 $m$ 条路径，图 (b) 则不存在。\n\n", "inputFormat": "第一行是一个整数，为 $n$ $(1\\le n≤35)$。\n\n第二行还是一个整数，为 $m(1\\le m\\le n^2)$。\n\n以下 $m$ 行，第 $(i+2)$ 行包含两个整数 $x_i$ 和 $y_i$，表示第 $i$ 行第 $j$ 列的点是起始点。保证起始点坐标互不相同。", "outputFormat": "只包括一行。若存在逃脱输出 `YES`，不存在逃脱输出 `NO`。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Escape", "background": "", "description": "Translated from CLRS Problem 26-1: Escape problem.\n\nIn an $n \\times n$ grid, there are $m$ starting points $(x_1, y_1)$, $(x_2, y_2)$, $\\dots$, $(x_m, y_m)$. Determine whether it is possible to find a path for each starting point to the boundary such that these $m$ paths are pairwise disjoint (that is, no two paths share any point).\n\n![https://i.loli.net/2018/10/14/5bc2ec2948f8b.png](https://i.loli.net/2018/10/14/5bc2ec2948f8b.png)\n\nBlack dots indicate starting points, and other points are white. The found paths are shown with bold lines. In figure (a), there exist $m$ valid paths; in figure (b), there do not.", "inputFormat": "The first line contains an integer $n$ ($1 \\le n \\le 35$).\n\nThe second line contains an integer $m$ ($1 \\le m \\le n^2$).\n\nEach of the following $m$ lines, the $(i + 2)$-th line, contains two integers $x_i$ and $y_i$, meaning that the point at row $x_i$, column $y_i$ is a starting point. The starting points are guaranteed to be distinct.", "outputFormat": "Output a single line. If an escape exists, output `YES`; otherwise, output `NO`.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "逃离", "background": "", "description": "**译自 CLRS Problem 26-1 Escape problem**\n\n在一个 $n\\times n$ 的网格中有 $m$ 个起始点 $(x_1, y_1),$ $(x_2, y_2),$ $\\dots,$ $(x_m, y_m)$，试问：能否为这些结点分别找一条到边界的路径，且这 $m$ 条路径互不相交（即任意两条路径上没有一个相同的结点）。\n\n![https://i.loli.net/2018/10/14/5bc2ec2948f8b.png](https://i.loli.net/2018/10/14/5bc2ec2948f8b.png)\n\n黑点表示起始点，其他点用白点表示。找出的路径用加粗的线表示。图 (a) 存在符合条件的 $m$ 条路径，图 (b) 则不存在。\n\n", "inputFormat": "第一行是一个整数，为 $n$ $(1\\le n≤35)$。\n\n第二行还是一个整数，为 $m(1\\le m\\le n^2)$。\n\n以下 $m$ 行，第 $(i+2)$ 行包含两个整数 $x_i$ 和 $y_i$，表示第 $i$ 行第 $j$ 列的点是起始点。保证起始点坐标互不相同。", "outputFormat": "只包括一行。若存在逃脱输出 `YES`，不存在逃脱输出 `NO`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2692", "type": "P", "difficulty": 2, "samples": [["4 5 2 2\n1 2\n4 4\n3 4\n4 5", "18"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟"], "title": "覆盖", "background": "WSR 的学校有 $B$ 个男生和 $G$ 个女生都来到一个巨大的操场上扫地。", "description": "操场可以看成是 $N$ 行 $M$ 列的方格矩阵，如下图 (1) 是一个 $4$ 行 $5$ 列的方格矩阵。每个男生负责打扫一些连续的行，每个女生负责打扫一些连续的列。比如有两个男生，第一个男生负责第 $1, 2$ 两行、第二个男生负责第 $4$ 行，如图 (2) 的蓝色。打扫的区域可能重复，比如，又有两个女生，第一个女生负责打扫第 $3, 4$ 两列，第二个女生负责打扫第 $4, 5$ 两列，如图 (3) 的红色。从图 (3) 可以容易看出，有颜色覆盖的方格数为 $18$，即这 $4$ 名学生总共打扫了 $18$ 个方格。\n\n![](https://cdn.luogu.com.cn/upload/pic/1474.png) \n\n老师要 WSR 在学校给出打扫安排的数据后快速计算出这些学生总共打扫了多少方格。", "inputFormat": "第一行 $4$ 个正整数：$N, M, B, G$。其中 $N$ 表示方阵行数，$M$ 表示方阵列数，$B$ 表示男生数，$G$ 表示女生数。\n\n接下来 $B$ 行，每行两个整数 $x, y$。表示相应某个男生负责打扫从第 $x$ 行到第 $y$ 行（共 $y - x + 1$ 行），保证 $1 \\le x \\le y \\le N$。\n\n再接下来 $G$ 行，每行两个整数 $x, y$。表示相应某个女生负责打扫从第 $x$ 列到第 $y$ 列（共 $y - x + 1$ 列），保证 $1 \\le x \\le y \\le M$。", "outputFormat": "一个整数，表示所打扫的面积。（即格子的总数）", "hint": "不会可以自己画图。\n\n### 数据范围与约定\n\n对于 $80\\%$ 的数据，$1 \\le N,M,B,G \\le 10^2$。\n\n对于 $100\\%$ 的数据，$ 1 \\le N,M,B,G \\le 5 \\times 10^3$。", "locale": "zh-CN", "translations": {"en": {"title": "Coverage", "background": "In WSR's school, $B$ boys and $G$ girls have come to a huge playground to sweep the ground.", "description": "The playground can be viewed as an $N$-by-$M$ grid of cells. As shown in Figure (1), this is a $4$-by-$5$ grid. Each boy is responsible for sweeping some consecutive rows, and each girl is responsible for sweeping some consecutive columns. For example, suppose there are two boys: the first boy is responsible for rows $1, 2$, and the second boy is responsible for row $4$, shown in blue in Figure (2). The swept regions may overlap. For instance, suppose there are also two girls: the first girl is responsible for columns $3, 4$, and the second girl is responsible for columns $4, 5$, shown in red in Figure (3). From Figure (3), it is easy to see that the number of colored cells is 18, i.e., these four students have swept a total of 18 cells.\n\n![](https://cdn.luogu.com.cn/upload/pic/1474.png)\n\nThe teacher asks WSR to quickly compute, given the cleaning plan data, how many cells have been swept in total.", "inputFormat": "The first line contains $4$ positive integers: $N, M, B, G$. Here, $N$ is the number of rows, $M$ is the number of columns, $B$ is the number of boys, and $G$ is the number of girls.\n\nThe next $B$ lines each contain two integers $x, y$. Each line indicates that a boy is responsible for rows $x$ through $y$ inclusive (a total of $y - x + 1$ rows), with the guarantee that $1 \\le x \\le y \\le N$.\n\nThen the next $G$ lines each contain two integers $x, y$. Each line indicates that a girl is responsible for columns $x$ through $y$ inclusive (a total of $y - x + 1$ columns), with the guarantee that $1 \\le x \\le y \\le M$.", "outputFormat": "Output a single integer, the swept area (i.e., the total number of cells).", "hint": "If you are not sure, try drawing a diagram yourself.\n\nConstraints:\n- For $80\\%$ of the testdata, $1 \\le N,M,B,G \\le 10^2$.\n- For $100\\%$ of the testdata, $ 1 \\le N,M,B,G \\le 5 \\times 10^3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "覆盖", "background": "WSR 的学校有 $B$ 个男生和 $G$ 个女生都来到一个巨大的操场上扫地。", "description": "操场可以看成是 $N$ 行 $M$ 列的方格矩阵，如下图 (1) 是一个 $4$ 行 $5$ 列的方格矩阵。每个男生负责打扫一些连续的行，每个女生负责打扫一些连续的列。比如有两个男生，第一个男生负责第 $1, 2$ 两行、第二个男生负责第 $4$ 行，如图 (2) 的蓝色。打扫的区域可能重复，比如，又有两个女生，第一个女生负责打扫第 $3, 4$ 两列，第二个女生负责打扫第 $4, 5$ 两列，如图 (3) 的红色。从图 (3) 可以容易看出，有颜色覆盖的方格数为 $18$，即这 $4$ 名学生总共打扫了 $18$ 个方格。\n\n![](https://cdn.luogu.com.cn/upload/pic/1474.png) \n\n老师要 WSR 在学校给出打扫安排的数据后快速计算出这些学生总共打扫了多少方格。", "inputFormat": "第一行 $4$ 个正整数：$N, M, B, G$。其中 $N$ 表示方阵行数，$M$ 表示方阵列数，$B$ 表示男生数，$G$ 表示女生数。\n\n接下来 $B$ 行，每行两个整数 $x, y$。表示相应某个男生负责打扫从第 $x$ 行到第 $y$ 行（共 $y - x + 1$ 行），保证 $1 \\le x \\le y \\le N$。\n\n再接下来 $G$ 行，每行两个整数 $x, y$。表示相应某个女生负责打扫从第 $x$ 列到第 $y$ 列（共 $y - x + 1$ 列），保证 $1 \\le x \\le y \\le M$。", "outputFormat": "一个整数，表示所打扫的面积。（即格子的总数）", "hint": "不会可以自己画图。\n\n### 数据范围与约定\n\n对于 $80\\%$ 的数据，$1 \\le N,M,B,G \\le 10^2$。\n\n对于 $100\\%$ 的数据，$ 1 \\le N,M,B,G \\le 5 \\times 10^3$。", "locale": "zh-CN"}}}
{"pid": "P2693", "type": "P", "difficulty": 2, "samples": [["50\n1 2 3\n5 6 7\n", "249"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "USACO", "枚举"], "title": "[USACO1.3] 号码锁 Combination Lock", "background": "感谢 @[Fond_Dream](https://www.luogu.com.cn/user/321680) 提供五道 USACO 题目的标准题面。", "description": "农夫约翰的奶牛不停地从他的农场中逃出来，导致了很多损害。为了防止它们再逃出来，他买了一只很大的号码锁以防止奶牛们打开牧场的门。\n\n农夫约翰知道他的奶牛很聪明，所以他希望确保它们不会在简单地试了很多不同的号码组合之后就能轻易开锁。锁上有三个转盘，每个上面有数字 $1$ ~ $n$，因为转盘是圆的，所以 $1$ 和 $n$ 是相邻的。有两种能开锁的号码组合，一种是农夫约翰设定的，还有一种“预设”号码组合是锁匠设定的。但是，锁有一定的容错性，所以，在每个转盘上的数字都与一个合法的号码组合中相应的数字相距两个位置以内时，锁也会打开。\n\n比如说，如果农夫约翰的号码组合是 ( $1$ , $2$ , $3$ )，预设号码组合是 ( $4$ , $5$ , $6$ )，在转盘被设定为 ( $1$ , $4$ , $5$)（因为这和农夫约翰的号码组合足够接近）或 ( $2$ , $4$ , $8$ )（因为这和预设号码组合足够接近）时可以打开锁。注意，( $1$ , $5$ , $6$ )并不会打开锁，因为它与任一号码组合都不够接近。\n\n给出农夫约翰的号码组合和预设号码组合，请计算能够开锁的不同的号码组合的数目。号码是有序的，所以 ( $1$ , $2$ , $3$ ) 与 ( $3$ , $2$ , $1$ ) 不同。\n", "inputFormat": "输入的第一行是一个整数 $n$，代表锁上的数字个数。\n\n输入的第二行有三个整数 $x, y, z$，代表农夫约翰的号码组合。\n\n输入的第三行有三个整数 $a, b, c$，代表预设的号码组合。", "outputFormat": "输出一行一个整数代表能够开锁的组合数目。", "hint": "#### 输入输出样例 1 解释\n\n每个转盘的标号是 $1$ ~ $50$。农夫约翰的号码组合是 ( $1$ , $2$ , $3$ )，预设号码组合是 ( $5$ , $6$ , $7$ )。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 100$，$1 \\leq x, y, z, a, b, c \\leq n$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.3] Combination Lock", "background": "Thanks to @[Fond_Dream](https://www.luogu.com.cn/user/321680) for providing the standard statements for five USACO problems.", "description": "Farmer John’s cows keep escaping from his farm, causing a lot of damage. To prevent them from escaping again, he buys a large combination lock to secure the pasture gate.\n\nFarmer John knows his cows are smart, so he wants to make sure they cannot easily open the lock by simply trying many different number combinations. The lock has three dials, each labeled with the numbers $1$ to $n$. Because the dials are circular, $1$ and $n$ are adjacent. There are two combinations that can open the lock: one set by Farmer John, and another “preset” combination set by the locksmith. However, the lock has some tolerance: if on each dial the chosen number is within two positions (inclusive) of the corresponding number in some valid combination, the lock will also open.\n\nFor example, if Farmer John’s combination is ( $1$ , $2$ , $3$ ) and the preset combination is ( $4$ , $5$ , $6$ ), then the lock will open when the dials are set to ( $1$ , $4$ , $5$ ) (because this is close enough to Farmer John’s combination) or ( $2$ , $4$ , $8$ ) (because this is close enough to the preset combination). Note that ( $1$ , $5$ , $6$ ) will not open the lock because it is not close enough to either combination.\n\nGiven Farmer John’s combination and the preset combination, compute the number of distinct combinations that open the lock. The numbers are ordered, so ( $1$ , $2$ , $3$ ) is different from ( $3$ , $2$ , $1$ ).", "inputFormat": "The first line contains an integer $n$, representing the number of numbers on each dial.\n\nThe second line contains three integers $x, y, z$, representing Farmer John’s combination.\n\nThe third line contains three integers $a, b, c$, representing the preset combination.", "outputFormat": "Output a single integer on one line representing the number of combinations that open the lock.", "hint": "Explanation for Sample 1.\n\nEach dial is labeled $1$ to $50$. Farmer John’s combination is ( $1$ , $2$ , $3$ ), and the preset combination is ( $5$ , $6$ , $7$ ).\n\nConstraints.\n\nFor $100\\%$ of the testdata, it is guaranteed that $1 \\leq n \\leq 100$, $1 \\leq x, y, z, a, b, c \\leq n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.3] 号码锁 Combination Lock", "background": "感谢 @[Fond_Dream](https://www.luogu.com.cn/user/321680) 提供五道 USACO 题目的标准题面。", "description": "农夫约翰的奶牛不停地从他的农场中逃出来，导致了很多损害。为了防止它们再逃出来，他买了一只很大的号码锁以防止奶牛们打开牧场的门。\n\n农夫约翰知道他的奶牛很聪明，所以他希望确保它们不会在简单地试了很多不同的号码组合之后就能轻易开锁。锁上有三个转盘，每个上面有数字 $1$ ~ $n$，因为转盘是圆的，所以 $1$ 和 $n$ 是相邻的。有两种能开锁的号码组合，一种是农夫约翰设定的，还有一种“预设”号码组合是锁匠设定的。但是，锁有一定的容错性，所以，在每个转盘上的数字都与一个合法的号码组合中相应的数字相距两个位置以内时，锁也会打开。\n\n比如说，如果农夫约翰的号码组合是 ( $1$ , $2$ , $3$ )，预设号码组合是 ( $4$ , $5$ , $6$ )，在转盘被设定为 ( $1$ , $4$ , $5$)（因为这和农夫约翰的号码组合足够接近）或 ( $2$ , $4$ , $8$ )（因为这和预设号码组合足够接近）时可以打开锁。注意，( $1$ , $5$ , $6$ )并不会打开锁，因为它与任一号码组合都不够接近。\n\n给出农夫约翰的号码组合和预设号码组合，请计算能够开锁的不同的号码组合的数目。号码是有序的，所以 ( $1$ , $2$ , $3$ ) 与 ( $3$ , $2$ , $1$ ) 不同。\n", "inputFormat": "输入的第一行是一个整数 $n$，代表锁上的数字个数。\n\n输入的第二行有三个整数 $x, y, z$，代表农夫约翰的号码组合。\n\n输入的第三行有三个整数 $a, b, c$，代表预设的号码组合。", "outputFormat": "输出一行一个整数代表能够开锁的组合数目。", "hint": "#### 输入输出样例 1 解释\n\n每个转盘的标号是 $1$ ~ $50$。农夫约翰的号码组合是 ( $1$ , $2$ , $3$ )，预设号码组合是 ( $5$ , $6$ , $7$ )。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 100$，$1 \\leq x, y, z, a, b, c \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P2694", "type": "P", "difficulty": 2, "samples": [["5\n3\n-1 1\n1 3\n0 4\n1\n-3 2\n3\n-1 1\n1 2\n0 4\n3\n0 9\n-1 1\n1 3\n8\n70 141\n-108 299\n52 402\n-70 280\n84 28\n-29 363\n66 427\n-33 232\n", "Abletocatch\nNotabletocatch\nNotabletocatch\nAbletocatch\nNotabletocatch\n"]], "limits": {"time": [869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "USACO"], "title": "接金币", "background": "", "description": "在二维坐标系里，有 $n$ 个金币，编号 $0\\sim n-1$。初始时，第 $i$ 个金币位于 $(x_i,y_i)$。所有的金币每秒向下垂直下降 $1$ 个单位高度。例如有个金币当前坐标是 $(x,y)$，那么 $t$ 秒后金币所在的位置就是$(x,y-t)$。初始时，FJ 在 $(0,0)$ 处，FJ 每秒只能向左右移动 $1$ 个单位距离，当然 FJ 也可以不移动。如果在某个时刻某个金币和 FJ 所在的位置重合，那么 FJ 就能接住这个金币。求 FJ 能否把所有的金币都接住，如果行输出 $\\texttt{Abletocatch}$，否则输出 $\\texttt{Notabletocatch}$。\n", "inputFormat": "本题有 $g$ 组数据。\n\n第一行，一个整数 $g$，表示有 $g$ 组测试数据。\n\n对于每组测试数据，格式如下：\n\n第一行，一个整数 $n$。\n\n接下来有 $n$ 行，第 $i$ 行两个整数表示 $x_i,y_i$。", "outputFormat": "共 $g$ 行，每行输出 $\\texttt{Abletocatch}$ 或 $\\texttt{Notabletocatch}$。\n", "hint": "对于所有数据，$1\\le g\\le5$，$1\\le n\\le50$，$-10^3\\le x_i\\le10^3$，$0\\le y_i\\le10^3$。\n\n> **tips：测试点与样例描述不符，实际上每组数据之间有个换行。**", "locale": "zh-CN", "translations": {"en": {"title": "Catching Coins", "background": "", "description": "In a 2D coordinate system, there are $n$ coins, numbered $0\\sim n-1$. Initially, the $i$-th coin is at $(x_i,y_i)$. All coins fall vertically downward by $1$ unit of height per second. For example, if a coin is currently at $(x,y)$, then after $t$ seconds its position will be $(x,y-t)$. Initially, FJ is at $(0,0)$. FJ can move left or right by $1$ unit per second, and FJ may also stay still. If at some moment a coin’s position coincides with FJ’s position, then FJ can catch that coin. Determine whether FJ can catch all the coins. If yes, output $\\texttt{Abletocatch}$, otherwise output $\\texttt{Notabletocatch}$.", "inputFormat": "This problem has $g$ groups of testdata.\n\nThe first line contains an integer $g$, indicating there are $g$ groups of testdata.\n\nFor each group of testdata, the format is as follows:\n\n- The first line contains an integer $n$.\n- The next $n$ lines each contain two integers, representing $x_i,y_i$ for the $i$-th coin.", "outputFormat": "Output $g$ lines. For each group, output $\\texttt{Abletocatch}$ or $\\texttt{Notabletocatch}$.", "hint": "For all testdata, $1 \\le g \\le 5$, $1 \\le n \\le 50$, $-10^3 \\le x_i \\le 10^3$, $0 \\le y_i \\le 10^3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "接金币", "background": "", "description": "在二维坐标系里，有 $n$ 个金币，编号 $0\\sim n-1$。初始时，第 $i$ 个金币位于 $(x_i,y_i)$。所有的金币每秒向下垂直下降 $1$ 个单位高度。例如有个金币当前坐标是 $(x,y)$，那么 $t$ 秒后金币所在的位置就是$(x,y-t)$。初始时，FJ 在 $(0,0)$ 处，FJ 每秒只能向左右移动 $1$ 个单位距离，当然 FJ 也可以不移动。如果在某个时刻某个金币和 FJ 所在的位置重合，那么 FJ 就能接住这个金币。求 FJ 能否把所有的金币都接住，如果行输出 $\\texttt{Abletocatch}$，否则输出 $\\texttt{Notabletocatch}$。\n", "inputFormat": "本题有 $g$ 组数据。\n\n第一行，一个整数 $g$，表示有 $g$ 组测试数据。\n\n对于每组测试数据，格式如下：\n\n第一行，一个整数 $n$。\n\n接下来有 $n$ 行，第 $i$ 行两个整数表示 $x_i,y_i$。", "outputFormat": "共 $g$ 行，每行输出 $\\texttt{Abletocatch}$ 或 $\\texttt{Notabletocatch}$。\n", "hint": "对于所有数据，$1\\le g\\le5$，$1\\le n\\le50$，$-10^3\\le x_i\\le10^3$，$0\\le y_i\\le10^3$。\n\n> **tips：测试点与样例描述不符，实际上每组数据之间有个换行。**", "locale": "zh-CN"}}}
{"pid": "P2695", "type": "P", "difficulty": 2, "samples": [["2 3\n5 \n4\n7 \n8\n4", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "排序"], "title": "骑士的工作", "background": "你作为一个村的村长，保卫村庄是理所当然的了。今天，村庄里来了一只恶龙，他有 $n$ 个头，恶龙到处杀人放火。你着急了。不过天无绝人之路，现在来了一个骑士团。里面有 $m$ 位成员（往下看）。", "description": "每个人都可以砍掉**至多**一个大小不超过 $z_i$ 的头，需要 $z_i$ 个金币，求最小花费。", "inputFormat": "第一行两个整数 $n$，$m$。\n\n下接 $n$ 行，第 $i$ 个整数 $a_i$，表示第 $i$ 个头的大小。\n\n下接 $m$ 行，每个人可以砍的头大小和需要的金币数 $z_1, \\cdots, z_m$。", "outputFormat": "一个整数，最小花费。如果无解，输出 `you died!`。", "hint": "对于所有数据，$1 \\le n,m \\le 2 \\times 10^4$，$1 \\leq a_i,z_i \\leq 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "The Knight's Job", "background": "As the village chief, it is your duty to defend the village. Today, a dragon has come with $n$ heads, wreaking havoc everywhere. You are anxious. Fortunately, a group of knights has arrived. There are $m$ members in the group.", "description": "Each person can cut off at most one head of size not exceeding $z_i$, and it costs $z_i$ coins. Find the minimum total cost.", "inputFormat": "- The first line contains two integers $n$, $m$.\n- The next $n$ lines each contain one integer, the size of a head.\n- The next $m$ lines each contain one integer $z_i$, the maximum head size the $i$-th person can cut and the number of coins required.", "outputFormat": "Output a single integer, the minimum total cost. If it is impossible, output `you died!`.", "hint": "For all testdata, $1 \\le n, m \\le 2 \\times 10^4$, $1 \\le z_i \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "骑士的工作", "background": "你作为一个村的村长，保卫村庄是理所当然的了。今天，村庄里来了一只恶龙，他有 $n$ 个头，恶龙到处杀人放火。你着急了。不过天无绝人之路，现在来了一个骑士团。里面有 $m$ 位成员（往下看）。", "description": "每个人都可以砍掉**至多**一个大小不超过 $z_i$ 的头，需要 $z_i$ 个金币，求最小花费。", "inputFormat": "第一行两个整数 $n$，$m$。\n\n下接 $n$ 行，第 $i$ 个整数 $a_i$，表示第 $i$ 个头的大小。\n\n下接 $m$ 行，每个人可以砍的头大小和需要的金币数 $z_1, \\cdots, z_m$。", "outputFormat": "一个整数，最小花费。如果无解，输出 `you died!`。", "hint": "对于所有数据，$1 \\le n,m \\le 2 \\times 10^4$，$1 \\leq a_i,z_i \\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P2696", "type": "P", "difficulty": 3, "samples": [["10", "13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "递归", "数论"], "title": "慈善的约瑟夫", "background": null, "description": "你一定听说过约瑟夫问题吧？即从 $N$ 个人中找出唯一的幸存者。现在老约瑟夫将组织一个皆大欢喜的新游戏，假设 $N$ 个人站成一圈，从第 $1$ 人开始交替的去掉游戏者，但只是暂时去掉，直到最后剩下唯一的幸存者为止。幸存者选出后，所有比幸存者号码高的人每人得到 $1$ 个金币，永久性离开。其余剩下的将重复以上的游戏过程，比幸存者号码大的人每人得到 $1$ 个金币后离开。经过若干轮这样的过程后，一旦人数不再减少，则最后剩下的那些人将得到 $2$ 个金币。请你计算一下老约瑟夫一共要付出多少钱？", "inputFormat": "一行一个正整数 $N$ 表示人数。", "outputFormat": "一行一个正整数表示共需支付的钱数。", "hint": "$1\\le N \\le 10^5$", "locale": "zh-CN", "translations": {"en": {"title": "Charitable Josephus", "background": "", "description": "You have probably heard of the Josephus problem, which finds the unique survivor among $N$ people. Now Old Josephus is organizing a new game that makes everyone happy. Suppose $N$ people stand in a circle. Starting from person 1, players are removed alternately (i.e., every other player), but only temporarily, until only one survivor remains. After the survivor is selected, every person whose number is greater than the survivor's number receives 1 gold coin and leaves permanently. The remaining people then repeat the above process; after selecting a survivor, everyone with a number larger than that survivor's number receives 1 gold coin and leaves. After several such rounds, once the number of people no longer decreases, the remaining people each receive 2 gold coins. Please compute the total amount of money Old Josephus has to pay.", "inputFormat": "A single line containing a positive integer $N$ representing the number of people.", "outputFormat": "A single line containing a positive integer representing the total amount of money to be paid.", "hint": "Constraints: $1\\le N \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "慈善的约瑟夫", "background": null, "description": "你一定听说过约瑟夫问题吧？即从 $N$ 个人中找出唯一的幸存者。现在老约瑟夫将组织一个皆大欢喜的新游戏，假设 $N$ 个人站成一圈，从第 $1$ 人开始交替的去掉游戏者，但只是暂时去掉，直到最后剩下唯一的幸存者为止。幸存者选出后，所有比幸存者号码高的人每人得到 $1$ 个金币，永久性离开。其余剩下的将重复以上的游戏过程，比幸存者号码大的人每人得到 $1$ 个金币后离开。经过若干轮这样的过程后，一旦人数不再减少，则最后剩下的那些人将得到 $2$ 个金币。请你计算一下老约瑟夫一共要付出多少钱？", "inputFormat": "一行一个正整数 $N$ 表示人数。", "outputFormat": "一行一个正整数表示共需支付的钱数。", "hint": "$1\\le N \\le 10^5$", "locale": "zh-CN"}}}
{"pid": "P2697", "type": "P", "difficulty": 3, "samples": [["GRGGRG", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "前缀和"], "title": "宝石串", "background": "", "description": "有一种宝石串，由绿宝石和红宝石串成，仅当绿宝石和红宝石数目相同的时候，宝石串才最为稳定，不易断裂。安安想知道从给定的宝石串中，可以截取一段最长的稳定的宝石串，有多少颗宝石组成。请你帮助他。\n\n绿宝石用 $\\texttt G$ 表示，红宝石用 $\\texttt R$ 表示。\n", "inputFormat": "一行，一个由 $\\texttt G$ 和 $\\texttt R$ 组成的字符串。\n", "outputFormat": "一行一个整数，表示最长的稳定的宝石串有多少颗宝石组成。\n", "hint": "$\\texttt {RGGR}$ 为答案。\n\n宝石数小于等于 $10^6$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Gem String", "background": "", "description": "There is a kind of gem string made of emeralds and rubies. The string is most stable and least likely to break only when the numbers of emeralds and rubies are equal. An An wants to know, from a given gem string, how many gems the longest stable substring contains. Please help him.\n\nEmeralds are denoted by $\\texttt G$, and rubies are denoted by $\\texttt R$.", "inputFormat": "One line, a string consisting of $\\texttt G$ and $\\texttt R$.", "outputFormat": "One line with an integer, the number of gems in the longest stable gem string.", "hint": "$\\texttt {RGGR}$ is the answer.\n\nConstraints: the number of gems is at most $10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "宝石串", "background": "", "description": "有一种宝石串，由绿宝石和红宝石串成，仅当绿宝石和红宝石数目相同的时候，宝石串才最为稳定，不易断裂。安安想知道从给定的宝石串中，可以截取一段最长的稳定的宝石串，有多少颗宝石组成。请你帮助他。\n\n绿宝石用 $\\texttt G$ 表示，红宝石用 $\\texttt R$ 表示。\n", "inputFormat": "一行，一个由 $\\texttt G$ 和 $\\texttt R$ 组成的字符串。\n", "outputFormat": "一行一个整数，表示最长的稳定的宝石串有多少颗宝石组成。\n", "hint": "$\\texttt {RGGR}$ 为答案。\n\n宝石数小于等于 $10^6$。\n", "locale": "zh-CN"}}}
{"pid": "P2698", "type": "P", "difficulty": 4, "samples": [["4 5\n6 3\n2 4\n4 10\n12 15", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "二分", "USACO", "单调队列"], "title": "[USACO12MAR] Flowerpot S", "background": null, "description": "![](https://cdn.luogu.com.cn/upload/pic/9174.png) \n\n老板需要你帮忙浇花。给出 $N$ 滴水的坐标，$(x,y)$ 表示水滴最初的坐标。\n\n每滴水均以每秒 $1$ 个单位长度的速度下落。你需要把花盆放在 $x$ 轴上的某个位置，使得花盆接到第 $1$ 滴水与最后 $1$ 滴水之间的时间差至少为 $D$。\n\n如果水滴落在 $x$ 轴上的位置与花盆的边沿对齐，也认为被接住。\n\n给出 $N$ 滴水的坐标和时间差 $D$ ，请算出最小的花盆宽度 $W$。", "inputFormat": "第一行 $2$ 个整数 $N$ 和 $D$。\n\n接下来 $N$ 行，每行 $2$ 个整数，表示水滴的坐标 $(x,y)$。", "outputFormat": "一行 $1$ 个整数，表示最小的花盆宽度。如果无法构造出满足题意的花盆，则输出 $-1$。", "hint": "**【样例解释】**\n\n有 $4$ 滴水，初始位置分别在 $(6,3)$，$(2,4)$，$(4,10)$，$(12,15)$。水滴至少用 $5$ 秒时间先后落入花盆。花盆的宽度为 $2$ 是必须且足够的，此时把花盆放在 $x=4\\dots6$ 的位置，它可以接到水滴 $1$ 和 $3$ ，之间的时间差为 $10-3=7$，满足条件。\n\n**【数据范围】**\n\n$40\\%$ 的数据：$1 \\le N \\le 1000$ ，$1 \\le D \\le 2000$。\n\n$100\\%$ 的数据：$1 \\le N \\le 10 ^ 5$，$1 \\le D \\le 10 ^ 6$，$0\\le x,y\\le10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO12MAR] Flowerpot S", "background": null, "description": "Farmer John has been having trouble making his plants grow, and needs your help to water them properly.  You are given the locations of N raindrops (1 <= N <= 100,000) in the 2D plane, where y represents vertical height of the drop, and x represents its location over a 1D number line:\n\n ![](https://cdn.luogu.com.cn/upload/pic/9174.png) \n\nEach drop falls downward (towards the x axis) at a rate of 1 unit per second.  You would like to place Farmer John's flowerpot of width W somewhere along the x axis so that the difference in time between the first raindrop to hit the flowerpot and the last raindrop to hit the flowerpot is at least some amount D (so that the flowers in the pot receive plenty of water).  A drop of water that lands just on the edge of the flowerpot counts as hitting the flowerpot. \n\nGiven the value of D and the locations of the N raindrops, please compute the minimum possible value of W.", "inputFormat": null, "outputFormat": null, "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO12MAR] Flowerpot S", "background": null, "description": "![](https://cdn.luogu.com.cn/upload/pic/9174.png) \n\n老板需要你帮忙浇花。给出 $N$ 滴水的坐标，$(x,y)$ 表示水滴最初的坐标。\n\n每滴水均以每秒 $1$ 个单位长度的速度下落。你需要把花盆放在 $x$ 轴上的某个位置，使得花盆接到第 $1$ 滴水与最后 $1$ 滴水之间的时间差至少为 $D$。\n\n如果水滴落在 $x$ 轴上的位置与花盆的边沿对齐，也认为被接住。\n\n给出 $N$ 滴水的坐标和时间差 $D$ ，请算出最小的花盆宽度 $W$。", "inputFormat": "第一行 $2$ 个整数 $N$ 和 $D$。\n\n接下来 $N$ 行，每行 $2$ 个整数，表示水滴的坐标 $(x,y)$。", "outputFormat": "一行 $1$ 个整数，表示最小的花盆宽度。如果无法构造出满足题意的花盆，则输出 $-1$。", "hint": "**【样例解释】**\n\n有 $4$ 滴水，初始位置分别在 $(6,3)$，$(2,4)$，$(4,10)$，$(12,15)$。水滴至少用 $5$ 秒时间先后落入花盆。花盆的宽度为 $2$ 是必须且足够的，此时把花盆放在 $x=4\\dots6$ 的位置，它可以接到水滴 $1$ 和 $3$ ，之间的时间差为 $10-3=7$，满足条件。\n\n**【数据范围】**\n\n$40\\%$ 的数据：$1 \\le N \\le 1000$ ，$1 \\le D \\le 2000$。\n\n$100\\%$ 的数据：$1 \\le N \\le 10 ^ 5$，$1 \\le D \\le 10 ^ 6$，$0\\le x,y\\le10^6$。", "locale": "zh-CN"}}}
{"pid": "P2699", "type": "P", "difficulty": 3, "samples": [["1 10 2", "1 2 4 8"], ["2 4 5", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟"], "title": "【数学 1】小浩的幂次运算", "background": null, "description": "幂次运算让小浩觉得有些烦，最近他碰到了一些问题。  \n他需要求出所有 $w^i$ 使得 $l \\le w^i \\le r$ ，于是他找到了你。", "inputFormat": "输入为一行，有三个整数 $l,r,w$。", "outputFormat": "输出为一行，输出所有满足条件的数字，用空格分开。  \n如果没有满足条件的数字，则输出 $-1$。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据：$1\\le l\\le r \\le 1 \\times 10^{18}$ , $1\\le w \\le10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[Mathematics 1] Xiao Hao's Exponentiation", "background": "", "description": "Exponentiation makes Xiao Hao a bit annoyed; recently he encountered some problems.  \nHe needs to find all $w^i$ such that $l \\le w^i \\le r$, so he turned to you.", "inputFormat": "The input consists of one line with three integers $l,r,w$.", "outputFormat": "Output one line with all numbers that satisfy the condition, separated by spaces.  \nIf no number satisfies the condition, output $-1$.", "hint": "Constraints  \nFor $100\\%$ of the testdata: $1\\le l\\le r \\le 1 \\times 10^{18}$ , $1\\le w \\le10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【数学 1】小浩的幂次运算", "background": null, "description": "幂次运算让小浩觉得有些烦，最近他碰到了一些问题。  \n他需要求出所有 $w^i$ 使得 $l \\le w^i \\le r$ ，于是他找到了你。", "inputFormat": "输入为一行，有三个整数 $l,r,w$。", "outputFormat": "输出为一行，输出所有满足条件的数字，用空格分开。  \n如果没有满足条件的数字，则输出 $-1$。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据：$1\\le l\\le r \\le 1 \\times 10^{18}$ , $1\\le w \\le10^9$。", "locale": "zh-CN"}}}
{"pid": "P2700", "type": "P", "difficulty": 4, "samples": [["5 3\n1 2 4\n1 0 4\n1 3 8\n2 1 1\n2 4 3", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "树形数据结构", "并查集", "生成树"], "title": "逐个击破", "background": "三大战役的平津战场上，傅作义集团在以北平、天津为中心，东起唐山西至张家口的铁路线上摆起了一字长蛇阵，并企图在溃败时从海上南逃或向西逃窜。为了就地歼敌不让其逃走，指挥官制定了先切断敌人东西两头退路然后再逐个歼灭敌人的战略方针。秉承伟大军事家的战略思想，作为一个有智慧的军长你，遇到了一个类似的战场局面。", "description": "现在有 $N$ 个城市，其中 $K$ 个被敌方军团占领了，$N$ 个城市间有 $N-1$ 条公路相连，破坏其中某条公路的代价是已知的，现在，告诉你 $K$ 个敌方军团所在的城市，以及所有公路破坏的代价，请你算出花费最少的代价将这 $K$ 个敌方军团互相隔离开，以便第二步逐个击破敌人。", "inputFormat": "第一行包含两个正整数 $N$ 和 $K$。\n\n第二行包含 $K$ 个整数，表示哪些城市被敌军占领。\n\n接下来 $N-1$ 行，每行包含三个正整数 $a,b,c$，表示从 $a$ 城市到 $b$ 城市有一条公路，以及破坏的代价 $c$。城市的编号从 $0$ 开始。", "outputFormat": "输出一行一个整数，表示最少花费的代价。", "hint": "对于 $10\\%$ 的数据，$N\\le 10$。\n\n对于 $100\\%$ 的数据，$2\\le N\\le10^5$，$2\\le K\\le N$，$1\\le c\\le 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "Eliminate Them One by One", "background": "On the Pingjin battlefield of the three major campaigns, the Fu Zuoyi group deployed a long, thin defensive line centered on Beiping and Tianjin, stretching from Tangshan in the east to Zhangjiakou in the west along the railway. They planned to flee south by sea or retreat westward in case of collapse. To annihilate the enemy in place and prevent their escape, the commander formulated a strategy to first cut off the enemy’s retreat routes at both ends and then eliminate them one by one. Following the strategic thinking of a great military leader, as a wise corps commander, you encounter a similar battlefield situation.", "description": "There are $N$ cities, among which $K$ are occupied by enemy corps. There are $N - 1$ roads connecting the $N$ cities. The cost to destroy any given road is known. You are given the $K$ cities occupied by the enemy and the destruction cost of every road. Please compute the minimum total cost to isolate these $K$ enemy corps from each other, so that in the second step they can be eliminated one by one.", "inputFormat": "- The first line contains two positive integers $N$ and $K$.\n- The second line contains $K$ integers, indicating which cities are occupied by the enemy.\n- The next $N - 1$ lines each contain three positive integers $a, b, c$, indicating there is a road between city $a$ and city $b$, and the cost to destroy it is $c$. City indices start from $0$.", "outputFormat": "Output a single line with one integer, the minimum total cost.", "hint": "Constraints:\n- For $10\\%$ of the testdata, $N \\le 10$.\n- For $100\\%$ of the testdata, $2 \\le N \\le 10^5$, $2 \\le K \\le N$, $1 \\le c \\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "逐个击破", "background": "三大战役的平津战场上，傅作义集团在以北平、天津为中心，东起唐山西至张家口的铁路线上摆起了一字长蛇阵，并企图在溃败时从海上南逃或向西逃窜。为了就地歼敌不让其逃走，指挥官制定了先切断敌人东西两头退路然后再逐个歼灭敌人的战略方针。秉承伟大军事家的战略思想，作为一个有智慧的军长你，遇到了一个类似的战场局面。", "description": "现在有 $N$ 个城市，其中 $K$ 个被敌方军团占领了，$N$ 个城市间有 $N-1$ 条公路相连，破坏其中某条公路的代价是已知的，现在，告诉你 $K$ 个敌方军团所在的城市，以及所有公路破坏的代价，请你算出花费最少的代价将这 $K$ 个敌方军团互相隔离开，以便第二步逐个击破敌人。", "inputFormat": "第一行包含两个正整数 $N$ 和 $K$。\n\n第二行包含 $K$ 个整数，表示哪些城市被敌军占领。\n\n接下来 $N-1$ 行，每行包含三个正整数 $a,b,c$，表示从 $a$ 城市到 $b$ 城市有一条公路，以及破坏的代价 $c$。城市的编号从 $0$ 开始。", "outputFormat": "输出一行一个整数，表示最少花费的代价。", "hint": "对于 $10\\%$ 的数据，$N\\le 10$。\n\n对于 $100\\%$ 的数据，$2\\le N\\le10^5$，$2\\le K\\le N$，$1\\le c\\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P2701", "type": "P", "difficulty": 3, "samples": [["8 3\r\n2 2\r\n2 6\r\n6 3", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "USACO"], "title": "[USACO5.3] 巨大的牛棚 Big Barn", "background": null, "description": "FJ 有一个大小为 $n\\times n$ 的农场（$1\\le n\\le 1000$），他想要在他的农场上建造一座正方形大牛棚。他的农场中有 $t$ 棵果树（$1\\le t\\le10000$），但他为了不破坏果树，就想找一个空旷无树的地方修建牛棚。你的任务是计算并输出，在他的农场中，不需要砍树却能够修建的最大正方形牛棚的边长。当然，牛棚的边必须和水平轴和垂直轴平行。\n\n考虑下面的农场，`.` 表示没有树的方格，`#` 表示有树的方格。\n```plain\n0 1 2 3 4 5 6 7 8\n1 . . . . . . . .\n2 . # . . . # . .\n3 . . . . . . . .\n4 . . . . . . . .\n5 . . . . . . . .\n6 . . # . . . . .\n7 . . . . . . . .\n8 . . . . . . . .\n```\n最大的牛棚是边长为 $5$ 的，可以建造在农场右下角的两个位置其中一个。", "inputFormat": "第 $1$ 行输入两个正整数 $n$ 和 $t$。\n\n第 $2\\sim t+1$ 行输入两个正整数 $x,y\\ (1\\le x,y\\le n)$。", "outputFormat": "只由一行组成，约翰的牛棚的最大边长。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 5.3", "locale": "zh-CN", "translations": {"en": {"title": "[USACO5.3] Big Barn", "background": "", "description": "Farmer John (FJ) has an $n \\times n$ farm ($1 \\le n \\le 1000$), and he wants to build a square barn on it. There are $t$ fruit trees on his farm ($1 \\le t \\le 10000$). To avoid cutting any trees, he wants to find an open area with no trees to build the barn. Your task is to compute and output the side length of the largest square barn that can be built on his farm without removing any trees. Of course, the sides of the barn must be parallel to the horizontal and vertical axes.\n\nConsider the farm below, where '.' represents an empty cell and '#' represents a cell with a tree.\n```plain\n0 1 2 3 4 5 6 7 8\n1 . . . . . . . .\n2 . # . . . # . .\n3 . . . . . . . .\n4 . . . . . . . .\n5 . . . . . . . .\n6 . . # . . . . .\n7 . . . . . . . .\n8 . . . . . . . .\n```\nThe largest barn has a side length of $5$ and can be placed at one of two positions in the lower-right corner.", "inputFormat": "The first line contains two positive integers $n$ and $t$.\n\nLines $2$ through $t+1$ each contain two positive integers $x, y$ ($1 \\le x, y \\le n$).", "outputFormat": "Output a single line: the maximum side length of John's barn.", "hint": "Problem translation from NOCOW.\n\nUSACO Training Section 5.3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO5.3] 巨大的牛棚 Big Barn", "background": null, "description": "FJ 有一个大小为 $n\\times n$ 的农场（$1\\le n\\le 1000$），他想要在他的农场上建造一座正方形大牛棚。他的农场中有 $t$ 棵果树（$1\\le t\\le10000$），但他为了不破坏果树，就想找一个空旷无树的地方修建牛棚。你的任务是计算并输出，在他的农场中，不需要砍树却能够修建的最大正方形牛棚的边长。当然，牛棚的边必须和水平轴和垂直轴平行。\n\n考虑下面的农场，`.` 表示没有树的方格，`#` 表示有树的方格。\n```plain\n0 1 2 3 4 5 6 7 8\n1 . . . . . . . .\n2 . # . . . # . .\n3 . . . . . . . .\n4 . . . . . . . .\n5 . . . . . . . .\n6 . . # . . . . .\n7 . . . . . . . .\n8 . . . . . . . .\n```\n最大的牛棚是边长为 $5$ 的，可以建造在农场右下角的两个位置其中一个。", "inputFormat": "第 $1$ 行输入两个正整数 $n$ 和 $t$。\n\n第 $2\\sim t+1$ 行输入两个正整数 $x,y\\ (1\\le x,y\\le n)$。", "outputFormat": "只由一行组成，约翰的牛棚的最大边长。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 5.3", "locale": "zh-CN"}}}
