{"pid": "P2228", "type": "P", "difficulty": 5, "samples": [["2 3                            \n4 5 -2\n-1 2 1\n", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2001", "各省省选", "湖南", "轮廓线 DP", "状压 DP"], "title": "[HNOI2001] 洋洋吃蛋糕", "background": "", "description": "洋洋是有名的“小馋猫”。他爱吃许多东西，但也有一些不爱吃的东西。一天，洋洋发现家中有一块刚烤好的长方形的蛋糕，而且蛋糕里放上了各种各样的东西，有爱吃的草莓，奶酪，也有不爱吃的核桃仁。这使得洋洋有一些为难，到底是吃还是不吃呢？这时，爷爷看出了洋洋的烦恼，然后说：你若能够遵守以下几条规则的话，蛋糕可以随便吃：\n\n1. 蛋糕的尺寸为 $n\\times m$，在吃之前，需先把蛋糕划分成 $n\\times m$ 个单位蛋糕块，然后对每一个单位蛋糕块按照自己的喜好给其打分，分数越高表示越爱吃，反之则表示越不爱吃。这个分数为这一个单位蛋糕块的好吃程度值。\n\n1. 每一个单位蛋糕块要么全部被吃掉，要么不吃。\n\n1. 被吃掉的蛋糕块必须成长方形或正方形，是由一些单位蛋糕块组成的，且蛋糕块的两边必须和原来的大蛋糕块的两边平行。一块蛋糕块的好吃程度值就是所有组成这个蛋糕块的单位蛋糕块的分数之和。\n\n1. 被吃掉的蛋糕块的尺寸任意，且块数也任意。\n\n1. 为了保持蛋糕块的美观，所有被吃掉的蛋糕块在原来的大蛋糕块中的位置不能相邻，且不能重叠。如图 1 和图 2 的吃法是不允许的，而图 3 和图 4 的吃法是允许的。\n![](https://cdn.luogu.com.cn/upload/pic/1295.png) \n1. 所有被吃掉的蛋糕块的好吃程度值之和最大。\n\n爷爷的话并没有消去洋洋的烦恼，因为他只能做好第一点，而不知如何选择蛋糕块。于是，洋洋请你帮忙选择蛋糕块，以使得所有被吃掉的蛋糕块的好吃程度值之和最大。", "inputFormat": "第一行是两个整数 $n$ 和 $m$。\n\n以下 $n$ 行是一个 $n$ 行 $m$ 列的矩阵，第 $i$ 行第 $j$ 列的整数表示单位蛋糕块 $(i,j)$ 的好吃程度值 $c$。", "outputFormat": "只有一个数，即为最大的好吃程度值。", "hint": "#### 数据规模与约定\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 200$，$1\\le m\\le 10$，$-100\\le c\\le 100$。", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2001] Yangyang Eats Cake", "background": "", "description": "Yangyang is a well-known “little foodie.” He loves to eat many things, but there are also some things he doesn’t like. One day, Yangyang found a freshly baked rectangular cake at home, and the cake had all sorts of ingredients: strawberries and cheese that he likes, and walnuts that he doesn’t like. This put Yangyang in a dilemma: should he eat it or not? At this moment, his grandpa noticed Yangyang’s trouble and said: If you can follow the rules below, you may eat the cake as you wish:\n\n1. The cake has size $n \\times m$. Before eating, it should be partitioned into $n \\times m$ unit cake cells. Then, for each unit cell, assign a score according to your preference: a higher score means he likes it more, and a lower score means he dislikes it more. This score is the taste value of that unit cell.\n2. Each unit cell is either eaten completely or not eaten at all.\n3. Any eaten cake piece must be a rectangle or a square, composed of some unit cells, and its sides must be parallel to the sides of the original cake. The taste value of a cake piece is the sum of the scores of all unit cells that form this piece.\n4. The sizes of the eaten pieces are arbitrary, and the number of pieces is also arbitrary.\n5. To keep the cake looking nice, all eaten pieces, in their positions within the original cake, must not be adjacent and must not overlap. The eating methods shown in Figures 1 and 2 are not allowed, while those in Figures 3 and 4 are allowed.\n![](https://cdn.luogu.com.cn/upload/pic/1295.png) \n6. The sum of the taste values of all eaten pieces must be maximized.\n\nGrandpa’s words did not remove Yangyang’s worry, because he can only accomplish the first step and does not know how to choose the pieces. So, Yangyang asks you to help select the pieces so that the total taste value of all eaten pieces is maximized.", "inputFormat": "The first line contains two integers $n$ and $m$.\n\nThe next $n$ lines contain an $n$-by-$m$ matrix. The integer in row $i$, column $j$ denotes the taste value $c$ of unit cake cell $(i, j)$.", "outputFormat": "Output a single integer: the maximum total taste value.", "hint": "Constraints  \nFor $100\\%$ of the testdata, it is guaranteed that $1 \\le n \\le 200$, $1 \\le m \\le 10$, $-100 \\le c \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2001] 洋洋吃蛋糕", "background": "", "description": "洋洋是有名的“小馋猫”。他爱吃许多东西，但也有一些不爱吃的东西。一天，洋洋发现家中有一块刚烤好的长方形的蛋糕，而且蛋糕里放上了各种各样的东西，有爱吃的草莓，奶酪，也有不爱吃的核桃仁。这使得洋洋有一些为难，到底是吃还是不吃呢？这时，爷爷看出了洋洋的烦恼，然后说：你若能够遵守以下几条规则的话，蛋糕可以随便吃：\n\n1. 蛋糕的尺寸为 $n\\times m$，在吃之前，需先把蛋糕划分成 $n\\times m$ 个单位蛋糕块，然后对每一个单位蛋糕块按照自己的喜好给其打分，分数越高表示越爱吃，反之则表示越不爱吃。这个分数为这一个单位蛋糕块的好吃程度值。\n\n1. 每一个单位蛋糕块要么全部被吃掉，要么不吃。\n\n1. 被吃掉的蛋糕块必须成长方形或正方形，是由一些单位蛋糕块组成的，且蛋糕块的两边必须和原来的大蛋糕块的两边平行。一块蛋糕块的好吃程度值就是所有组成这个蛋糕块的单位蛋糕块的分数之和。\n\n1. 被吃掉的蛋糕块的尺寸任意，且块数也任意。\n\n1. 为了保持蛋糕块的美观，所有被吃掉的蛋糕块在原来的大蛋糕块中的位置不能相邻，且不能重叠。如图 1 和图 2 的吃法是不允许的，而图 3 和图 4 的吃法是允许的。\n![](https://cdn.luogu.com.cn/upload/pic/1295.png) \n1. 所有被吃掉的蛋糕块的好吃程度值之和最大。\n\n爷爷的话并没有消去洋洋的烦恼，因为他只能做好第一点，而不知如何选择蛋糕块。于是，洋洋请你帮忙选择蛋糕块，以使得所有被吃掉的蛋糕块的好吃程度值之和最大。", "inputFormat": "第一行是两个整数 $n$ 和 $m$。\n\n以下 $n$ 行是一个 $n$ 行 $m$ 列的矩阵，第 $i$ 行第 $j$ 列的整数表示单位蛋糕块 $(i,j)$ 的好吃程度值 $c$。", "outputFormat": "只有一个数，即为最大的好吃程度值。", "hint": "#### 数据规模与约定\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 200$，$1\\le m\\le 10$，$-100\\le c\\le 100$。", "locale": "zh-CN"}}}
{"pid": "P2229", "type": "P", "difficulty": 6, "samples": [["start\r\n     i=0\r\n     j=0\r\n     loop 100\r\n          i=i+1\r\n          j=j+i\r\n          continue\r\n          loop 10\r\n               write j\r\n          end\r\n     end\r\n     loop 100\r\n          j=j+1\r\n          break\r\n          j=j+1\r\n     end\r\n     write j\r\nend\r\n", "5051"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2002", "各省省选", "湖南", "栈"], "title": "[HNOI2002] 沙漠寻宝", "background": "", "description": "传说在漫无边际的沙漠中有一个古代城市的废墟，里面埋藏了大量的宝藏。听到这个消息的人一个又一个的前去寻宝，却没有发现一个回来的人。\n\n探险家 Jack 是冒险者队伍中的后起之秀，它加入冒险者队伍的时间虽然不长，却屡屡依靠自己过人的智慧使自己和队友们脱离了险境。“明知山有虎，偏向虎山行”。 在 Jack 探险队的宗旨的指引下，Jack 和他的队友们踏上了沙漠寻宝的旅程。\n\n“我发现沙漠废墟了。”在一名队员的叫喊声中，Jack 隐约看到了一些古代城市的残垣断壁和一个通道。 “一定就是这里了。”Jack 带领着大家进入了通道。\n\n然而，不幸的事情发生了。就在 Jack 他们进入通道的同时，通道的入口“轰”的一声就关闭了。Jack 和他的队友走到了通道的尽头，正前方是一个巨大的铁门。最令人奇怪的是，铁门竟然使用的是一个极度先进的带有键盘和显示器的电子密码锁，铁门旁还赫然写着开锁的方法：“想到得到我的宝藏的人们，到这里的路途很辛苦吧！不过这一切很快就会结束的，这个铁门就是你们的葬身之地。除非你们能够计算出我屏幕上程序的结果，并且通过键盘输入进去，这扇门就会打开，里面就是我所有的宝藏”\n\n我们的 Jack 果然不负众望，他打开了他的行囊，拿出了一个类似保险箱的东西。“没见过吗？这是最新型的笔记本电脑，没有它，我再怎么天才也不可能打开这扇门的。”面对大家疑惑的目光，Jack 打开了笔记本电脑的开关。\n\n“这个宝藏主人的程序十分的奇怪，我虽然没见过，但根据我的猜测，它的结构应该是这样的：\n\n程序共包含 $7$ 种语句：`start`,`end`,`loop`,`continue`,`break`,`write`,以及 `?=*` 形式的语句。\n\n`start` 是程序的开始标志，其对应了一个结束标志 `end`。\n\n`loop` 后面空一格并紧跟了一个表达式 `*`，表达式 `*` 的值 $N$ 表示即将循环 $N$ 次，对应的循环结束标志也是 `end`。\n\n`continue` 表示程序跳转到当前循环对应的 `end` 语句，`break` 表示程序将跳出当前的循环。\n\n`write` 后面空一格并紧跟了一个表达式 `*`，表示要输出表达式 `*` 的值，也就是要输入到密码锁中的内容。\n\n`?=*` 是赋值语句，`?` 是变量的名字，`*` 计算出来的值是要给 `?` 的。\n\n另外，值得庆幸的是，变量名只允许使用 `a`$\\dots$`z`这 $26$ 个小写字母，表达式也只允许使用加减乘除四种运算和以及括号，参与运算的也只能是 $26$ 个变量或者是整数（允许不止一位整数）。表达式不会超过 $80$ 个字符。”\n\n“希望 Jack 能很快将锁打开。”大家心里默念着。\n\n给定程序对所有语句的执行次数的总和小于 $2000000$ 次。", "inputFormat": "输入文件为 program.in，给出了宝藏主人的程序。其中任两条语句用若干个空格或回车符隔开。", "outputFormat": "输出文件为 program.out，是你要输入密码锁的内容。每次输出占一行。", "hint": "1. 程序中的任何计算都在长整形范围以内，无需使用高精度。\n2. 任何除法的结果都是整数且除数不为 0。\n3. 保证给出的代码没有语法错误，你不需要判错。", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2002] Desert Treasure Hunt", "background": "", "description": "It is said that there are ruins of an ancient city buried with a large amount of treasure in the boundless desert. One after another, people who heard the news went to look for treasure, but none returned.\n\nThe explorer Jack is a rising star among the adventurers. Although he joined the team not long ago, he and his teammates have repeatedly escaped danger thanks to his extraordinary wisdom. “Knowing there are tigers on the mountain, we head for the mountain anyway.” Guided by the creed of Jack’s expedition, Jack and his teammates set off on a desert treasure hunt.\n\n“I found the desert ruins.” With a teammate’s shout, Jack vaguely saw some broken walls of an ancient city and a passage. “This must be it.” Jack led everyone into the passage.\n\nHowever, misfortune struck. As Jack and the others entered the passage, the entrance slammed shut with a bang. Jack and his teammates reached the end of the passage, and in front of them was a huge iron gate. Strangely, the gate used an extremely advanced electronic lock with a keyboard and display, and the unlocking method was written clearly beside the gate: “Those who wish to obtain my treasure, the journey here must have been arduous! But it will soon be over; this iron door will be your tomb. Unless you can compute the result of the program shown on my screen and enter it through the keyboard, this door will open, and inside lies all my treasure.”\n\nTrue to expectations, Jack opened his pack and took out something like a safe. “Never seen one? This is the latest laptop. Without it, no matter how much of a genius I am, I couldn’t open this door.” Facing everyone’s puzzled looks, Jack turned on the laptop.\n\n“This treasure owner’s program is very strange. Although I haven’t seen it before, based on my guess, its structure should be as follows:\n\nThe program contains 6 types of statements: start, end, loop, continue, write, and statements of the form ?=\\*.\n\nstart marks the beginning of the program and corresponds to a closing marker end.\n\nloop is followed by a space and then an expression \\*. The value N of expression \\* indicates that the following block will loop N times; the corresponding loop closing marker is also end.\n\ncontinue means the program jumps to the end statement corresponding to the current loop, and break means the program exits the current loop.\n\nwrite is followed by a space and then an expression \\*, indicating that the value of expression \\* should be output, which is what must be entered into the password lock.\n\n?=\\* is an assignment statement, where ? is the variable name, and the computed value of \\* is assigned to ?.\n\nFortunately, variable names are restricted to the 26 lowercase letters 'a'..'z'. Expressions are restricted to the four arithmetic operations (addition, subtraction, multiplication, division) and parentheses; operands can only be the 26 variables or integers (multi-digit integers are allowed). An expression will not exceed 80 characters.”\n\n“Hope Jack can open the lock soon.” Everyone prayed silently.\n\nThe sum of the execution counts of all statements in the given program is less than 2000000.", "inputFormat": "The input file is program.in, which contains the treasure owner’s program. Any two statements are separated by one or more spaces or newline characters.", "outputFormat": "The output file is program.out, which is the content you must enter into the password lock. Output one result per line.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2002] 沙漠寻宝", "background": "", "description": "传说在漫无边际的沙漠中有一个古代城市的废墟，里面埋藏了大量的宝藏。听到这个消息的人一个又一个的前去寻宝，却没有发现一个回来的人。\n\n探险家 Jack 是冒险者队伍中的后起之秀，它加入冒险者队伍的时间虽然不长，却屡屡依靠自己过人的智慧使自己和队友们脱离了险境。“明知山有虎，偏向虎山行”。 在 Jack 探险队的宗旨的指引下，Jack 和他的队友们踏上了沙漠寻宝的旅程。\n\n“我发现沙漠废墟了。”在一名队员的叫喊声中，Jack 隐约看到了一些古代城市的残垣断壁和一个通道。 “一定就是这里了。”Jack 带领着大家进入了通道。\n\n然而，不幸的事情发生了。就在 Jack 他们进入通道的同时，通道的入口“轰”的一声就关闭了。Jack 和他的队友走到了通道的尽头，正前方是一个巨大的铁门。最令人奇怪的是，铁门竟然使用的是一个极度先进的带有键盘和显示器的电子密码锁，铁门旁还赫然写着开锁的方法：“想到得到我的宝藏的人们，到这里的路途很辛苦吧！不过这一切很快就会结束的，这个铁门就是你们的葬身之地。除非你们能够计算出我屏幕上程序的结果，并且通过键盘输入进去，这扇门就会打开，里面就是我所有的宝藏”\n\n我们的 Jack 果然不负众望，他打开了他的行囊，拿出了一个类似保险箱的东西。“没见过吗？这是最新型的笔记本电脑，没有它，我再怎么天才也不可能打开这扇门的。”面对大家疑惑的目光，Jack 打开了笔记本电脑的开关。\n\n“这个宝藏主人的程序十分的奇怪，我虽然没见过，但根据我的猜测，它的结构应该是这样的：\n\n程序共包含 $7$ 种语句：`start`,`end`,`loop`,`continue`,`break`,`write`,以及 `?=*` 形式的语句。\n\n`start` 是程序的开始标志，其对应了一个结束标志 `end`。\n\n`loop` 后面空一格并紧跟了一个表达式 `*`，表达式 `*` 的值 $N$ 表示即将循环 $N$ 次，对应的循环结束标志也是 `end`。\n\n`continue` 表示程序跳转到当前循环对应的 `end` 语句，`break` 表示程序将跳出当前的循环。\n\n`write` 后面空一格并紧跟了一个表达式 `*`，表示要输出表达式 `*` 的值，也就是要输入到密码锁中的内容。\n\n`?=*` 是赋值语句，`?` 是变量的名字，`*` 计算出来的值是要给 `?` 的。\n\n另外，值得庆幸的是，变量名只允许使用 `a`$\\dots$`z`这 $26$ 个小写字母，表达式也只允许使用加减乘除四种运算和以及括号，参与运算的也只能是 $26$ 个变量或者是整数（允许不止一位整数）。表达式不会超过 $80$ 个字符。”\n\n“希望 Jack 能很快将锁打开。”大家心里默念着。\n\n给定程序对所有语句的执行次数的总和小于 $2000000$ 次。", "inputFormat": "输入文件为 program.in，给出了宝藏主人的程序。其中任两条语句用若干个空格或回车符隔开。", "outputFormat": "输出文件为 program.out，是你要输入密码锁的内容。每次输出占一行。", "hint": "1. 程序中的任何计算都在长整形范围以内，无需使用高精度。\n2. 任何除法的结果都是整数且除数不为 0。\n3. 保证给出的代码没有语法错误，你不需要判错。", "locale": "zh-CN"}}}
{"pid": "P2230", "type": "P", "difficulty": 5, "samples": [["4 3\n3\n5\n4\n", "28\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2002", "各省省选", "湖南"], "title": "[HNOI2002] Tinux系统", "background": "", "description": "在 dos 系统诞生以前，美国曾研究出一种类似的操作系统，名为 Tinux 系统。但由于硬件设施的制约，Tinux 系统有许多的缺点。下面就对 Tinux 系统作一个简单的介绍：\n\nTinux 系统是 Tiger 博士为美国军方研制开发的一种操作系统，该系统对文件的存储方式类似于 dos 系统，像一棵树一样，每一个叶子节点表示一个文件，每一个非叶子节点表示一个目录。其中定义 $i$ 级子目录表示从根目录开始访问，一直访问到该子目录（不包括该子目录）需要访问的目录的个数为 $i$ 的目录，所以根目录下的目录为一级子目录，其他的目录以此类推。但是在同一子目录下，受到硬件的制约 Tinux 系统最多只能够存储 $k$ 个文件或子目录，也就是说这棵树里面的每一个非叶子节点最多只有 $k$ 个子节点。这样就导致在文件数量较多的情况下，访问存储在该系统当中的文件 A，往往要先访问一系列的子目录，我们称这些子目录为文件 A 的上级目录。例如下面这一个例子：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/11pz60gn.png)\n\n当我们要访问文件 A4A2A1 时就必须先访问它的上级目录：一级子目录 A4 和二级子目录 A4A2。\n\nTinux 系统在存储文件时，给每一个子目录都分配了 $k$ 个指针，分别指向存放在该目录下的每一个文件和每一个目录，因此对文件的访问实质上就是对指针的访问。但是由于硬件原因，这 $k$ 个指针不尽相同，因此访问它们的时间也不同，访问第 $i$ 个指针所耗费的时间为 $P_i$。但是对于两个不同的子目录（不管它们各自属于哪一级目录）而言它们各自所拥有的 $k$ 个指针是相同的。\n\nTinux 系统最大的缺点是访问一个目录时，必须把该目录下所有的文件读入到内存当中来，这些文件包括在其各级子目录当中的文件，例如上面那一个例子，访问 A4 那一个目录，就必须把 A4A1，A4A2A1，A4A2A2，A4A3 这四个文件都读入到内存当中来，访问一个目录所需要的时间为 $P_i \\times x$（$x$ 表示该目录及其各级子目录下文件的个数，$P_i$ 表示指向该目录的指针的访问时间）。因此根据上面介绍的访问方法，单独访问一个文件所需要的总时间为访问其所有上级目录（不包括根目录）所需要的时间与访问指向该文件的指针所需要的时间的和，例如上面那一个例子，访问文件 A4A2A1 需要的时间 = 访问目录 A4 的时间 + 访问目录 A4A2 的时间 + 访问指向文件 A4A2A1 的指针需要的时间。\n\n现在，tiger 博士准备将 $n$ 个文件存储到一个空的 Tinux 系统当中，希望你帮助他设计一个程序找到一种最优的存储方法，使得单独访问这 $n$ 个文件所需要的时间总和最小。", "inputFormat": "文件的第一行为两个正整数 $n, k$，接下来的 $k$ 行每行有一个正整数 $P_i$。", "outputFormat": "输出仅一个正整数，表示在最优存储方案下，单独访问这 $n$ 个文件所需要的时间总和（结果小于 $2^{31}$）。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/1296.png)\n\n**【数据范围】**\n\n$1 \\le n \\le 1000$，$2 \\le k \\le 150$，$1 \\le P_i \\le 150$。", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2002] Tinux System", "background": "# Description\n\nBefore the DOS system was born, the United States studied a similar operating system called the Tinux system. However, due to hardware limitations, the Tinux system had many drawbacks. Below is a brief introduction to the Tinux system.\n\nThe Tinux system was developed by Dr. Tiger for the U.S. military. Its file storage method is similar to DOS: it is like a tree, where each leaf node represents a file, and each non-leaf node represents a directory. We define an $i$-level subdirectory as a directory such that, starting from the root directory, the number of directories that must be visited to reach (but not including) this subdirectory is $i$. Therefore, directories directly under the root are level 1 subdirectories, and so on.\n\nWithin any single directory, due to hardware limits, the Tinux system can store at most $k$ files or subdirectories. In other words, every non-leaf node in this tree has at most $k$ children. As a result, when there are many files, to access a file A stored in the system, one often has to visit a sequence of directories first; we call these directories the ancestor directories of file A. For example:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/11pz60gn.png)\n\nWhen we want to access file A4A2A1, we must first visit its ancestor directories: the level-1 directory A4 and the level-2 directory A4A2.\n\nWhen storing files, the Tinux system allocates $k$ pointers to every directory, each pointing to one file or subdirectory under it. Therefore, accessing a file is essentially accessing pointers. However, due to hardware reasons, these $k$ pointers are not identical, so the time to access them is different: the time to access the $i$-th pointer is $P_i$. For two different directories (regardless of their depth), their sets of $k$ pointers are the same.\n\nThe biggest drawback of the Tinux system is that when accessing a directory, all files under that directory must be read into memory, including files in all its subdirectories. For example, in the figure above, accessing directory A4 requires loading four files into memory: A4A1, A4A2A1, A4A2A2, and A4A3. The time to access a directory is $P_i \\times x$ (where $x$ is the number of files under that directory and all of its subdirectories, and $P_i$ is the time to access the pointer pointing to that directory). Therefore, according to the access method described above, the total time to access a single file equals the sum of the times to access all its ancestor directories (excluding the root) plus the time to access the pointer to that file. For example, in the figure above, the time to access file A4A2A1 = the time to access directory A4 + the time to access directory A4A2 + the time to access the pointer to file A4A2A1.\n\nNow, Dr. Tiger plans to store $n$ files into an empty Tinux system. Please help him design a program to find an optimal storage plan that minimizes the total time needed to access these $n$ files individually.", "description": "", "inputFormat": "", "outputFormat": "Output a single positive integer: under the optimal storage plan, the total time required to access these $n$ files individually (the result is less than $2^{31}$).", "hint": "![](https://cdn.luogu.com.cn/upload/pic/1296.png)\n\nConstraints\n\n$1 \\le n \\le 1000$, $2 \\le k \\le 150$, $1 \\le P_i \\le 150$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2002] Tinux系统", "background": "", "description": "在 dos 系统诞生以前，美国曾研究出一种类似的操作系统，名为 Tinux 系统。但由于硬件设施的制约，Tinux 系统有许多的缺点。下面就对 Tinux 系统作一个简单的介绍：\n\nTinux 系统是 Tiger 博士为美国军方研制开发的一种操作系统，该系统对文件的存储方式类似于 dos 系统，像一棵树一样，每一个叶子节点表示一个文件，每一个非叶子节点表示一个目录。其中定义 $i$ 级子目录表示从根目录开始访问，一直访问到该子目录（不包括该子目录）需要访问的目录的个数为 $i$ 的目录，所以根目录下的目录为一级子目录，其他的目录以此类推。但是在同一子目录下，受到硬件的制约 Tinux 系统最多只能够存储 $k$ 个文件或子目录，也就是说这棵树里面的每一个非叶子节点最多只有 $k$ 个子节点。这样就导致在文件数量较多的情况下，访问存储在该系统当中的文件 A，往往要先访问一系列的子目录，我们称这些子目录为文件 A 的上级目录。例如下面这一个例子：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/11pz60gn.png)\n\n当我们要访问文件 A4A2A1 时就必须先访问它的上级目录：一级子目录 A4 和二级子目录 A4A2。\n\nTinux 系统在存储文件时，给每一个子目录都分配了 $k$ 个指针，分别指向存放在该目录下的每一个文件和每一个目录，因此对文件的访问实质上就是对指针的访问。但是由于硬件原因，这 $k$ 个指针不尽相同，因此访问它们的时间也不同，访问第 $i$ 个指针所耗费的时间为 $P_i$。但是对于两个不同的子目录（不管它们各自属于哪一级目录）而言它们各自所拥有的 $k$ 个指针是相同的。\n\nTinux 系统最大的缺点是访问一个目录时，必须把该目录下所有的文件读入到内存当中来，这些文件包括在其各级子目录当中的文件，例如上面那一个例子，访问 A4 那一个目录，就必须把 A4A1，A4A2A1，A4A2A2，A4A3 这四个文件都读入到内存当中来，访问一个目录所需要的时间为 $P_i \\times x$（$x$ 表示该目录及其各级子目录下文件的个数，$P_i$ 表示指向该目录的指针的访问时间）。因此根据上面介绍的访问方法，单独访问一个文件所需要的总时间为访问其所有上级目录（不包括根目录）所需要的时间与访问指向该文件的指针所需要的时间的和，例如上面那一个例子，访问文件 A4A2A1 需要的时间 = 访问目录 A4 的时间 + 访问目录 A4A2 的时间 + 访问指向文件 A4A2A1 的指针需要的时间。\n\n现在，tiger 博士准备将 $n$ 个文件存储到一个空的 Tinux 系统当中，希望你帮助他设计一个程序找到一种最优的存储方法，使得单独访问这 $n$ 个文件所需要的时间总和最小。", "inputFormat": "文件的第一行为两个正整数 $n, k$，接下来的 $k$ 行每行有一个正整数 $P_i$。", "outputFormat": "输出仅一个正整数，表示在最优存储方案下，单独访问这 $n$ 个文件所需要的时间总和（结果小于 $2^{31}$）。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/1296.png)\n\n**【数据范围】**\n\n$1 \\le n \\le 1000$，$2 \\le k \\le 150$，$1 \\le P_i \\le 150$。", "locale": "zh-CN"}}}
{"pid": "P2231", "type": "P", "difficulty": 5, "samples": [["2 4", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2002", "各省省选", "数论", "湖南", "最大公约数 gcd", "不定方程", "莫比乌斯反演"], "title": "[HNOI2002] 跳蚤", "background": null, "description": "Z 城市居住着很多只跳蚤。在 Z 城市周六生活频道有一个娱乐节目。一只跳蚤将被请上一个高空钢丝的正中央。钢丝很长，可以看作是无限长。节目主持人会给该跳蚤发一张卡片。卡片上写有 $N+1$ 个正整数。其中最后一个是 $M$，而前 $N$ 个数都不超过 $M$，卡片上允许有相同的数字。跳蚤每次可以从卡片上任意选择一个正整数 $S$，然后向左，或向右跳 $S$ 个单位长度。而他最终的任务是跳到距离他左边一个单位长度的地方，并捡起位于那里的礼物。\n\n比如当 $N=2,M=18$ 时，持有卡片 $(10, 15, 18)$ 的跳蚤，就可以完成任务：他可以先向左跳 $10$ 个单位长度，然后再连向左跳 $3$ 次，每次 $15$ 个单位长度，最后再向右连跳 $3$ 次，每次 $18$ 个单位长度。而持有卡片 $(12, 15, 18)$ 的跳蚤，则怎么也不可能跳到距他左边一个单位长度的地方。\n\n当确定 $N$ 和 $M$ 后，显然一共有 $M^ N$ 张不同的卡片。现在的问题是，在这所有的卡片中，有多少张可以完成任务。", "inputFormat": "输入文件有且仅有一行，包括用空格分开的两个整数 $N$ 和 $M$。", "outputFormat": "输出文件有且仅有一行，即可以完成任务的卡片数。\n\n$1\\le N\\le M\\le 10^8$，且 $M^N\\le 10^{16}$。", "hint": "这 12 张卡片分别是：\n\n$(1, 1, 4), (1, 2, 4), (1, 3, 4), (1, 4, 4), (2, 1, 4), (2, 3, 4)$\n\n$(3, 1, 4), (3, 2, 4), (3, 3, 4), (3, 4, 4), (4, 1, 4), (4, 3, 4)$", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2002] Flea", "background": "", "description": "Many fleas live in Z City. There is an entertainment show on the Saturday Life channel in Z City. A flea will be placed at the exact middle of a high wire. The wire is very long and can be regarded as infinite. The host will give the flea a card. The card has $N+1$ positive integers. The last one is $M$, and each of the first $N$ numbers does not exceed $M$. Duplicate numbers are allowed on the card. Each time, the flea can choose any positive integer $S$ from the card and then jump $S$ units either to the left or to the right. Its task is to end up at the point located one unit to its left and pick up the gift there.\n\nFor example, when $N=2, M=18$, a flea holding the card $(10, 15, 18)$ can complete the task: it can first jump $10$ units to the left, then jump left $3$ more times, $15$ units each time, and finally jump right $3$ times, $18$ units each time. However, with the card $(12, 15, 18)$, it is impossible to reach the point one unit to its left.\n\nWhen $N$ and $M$ are fixed, there are clearly $M^N$ different cards. The question is: among all these cards, how many of them can complete the task?", "inputFormat": "The input consists of a single line with two integers $N$ and $M$ separated by a space.", "outputFormat": "Output a single line containing the number of cards that can complete the task.\n\nConstraints\n\n$1 \\le N \\le M \\le 10^8$, and $M^N \\le 10^{16}$.", "hint": "These 12 cards are:\n\n$(1, 1, 4), (1, 2, 4), (1, 3, 4), (1, 4, 4), (2, 1, 4), (2, 3, 4)$\n\n$(3, 1, 4), (3, 2, 4), (3, 3, 4), (3, 4, 4), (4, 1, 4), (4, 3, 4)$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2002] 跳蚤", "background": null, "description": "Z 城市居住着很多只跳蚤。在 Z 城市周六生活频道有一个娱乐节目。一只跳蚤将被请上一个高空钢丝的正中央。钢丝很长，可以看作是无限长。节目主持人会给该跳蚤发一张卡片。卡片上写有 $N+1$ 个正整数。其中最后一个是 $M$，而前 $N$ 个数都不超过 $M$，卡片上允许有相同的数字。跳蚤每次可以从卡片上任意选择一个正整数 $S$，然后向左，或向右跳 $S$ 个单位长度。而他最终的任务是跳到距离他左边一个单位长度的地方，并捡起位于那里的礼物。\n\n比如当 $N=2,M=18$ 时，持有卡片 $(10, 15, 18)$ 的跳蚤，就可以完成任务：他可以先向左跳 $10$ 个单位长度，然后再连向左跳 $3$ 次，每次 $15$ 个单位长度，最后再向右连跳 $3$ 次，每次 $18$ 个单位长度。而持有卡片 $(12, 15, 18)$ 的跳蚤，则怎么也不可能跳到距他左边一个单位长度的地方。\n\n当确定 $N$ 和 $M$ 后，显然一共有 $M^ N$ 张不同的卡片。现在的问题是，在这所有的卡片中，有多少张可以完成任务。", "inputFormat": "输入文件有且仅有一行，包括用空格分开的两个整数 $N$ 和 $M$。", "outputFormat": "输出文件有且仅有一行，即可以完成任务的卡片数。\n\n$1\\le N\\le M\\le 10^8$，且 $M^N\\le 10^{16}$。", "hint": "这 12 张卡片分别是：\n\n$(1, 1, 4), (1, 2, 4), (1, 3, 4), (1, 4, 4), (2, 1, 4), (2, 3, 4)$\n\n$(3, 1, 4), (3, 2, 4), (3, 3, 4), (3, 4, 4), (4, 1, 4), (4, 3, 4)$", "locale": "zh-CN"}}}
{"pid": "P2232", "type": "P", "difficulty": 6, "samples": [["2 2\n", "225 1296\n400 2304\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2002", "各省省选", "湖南", "Special Judge"], "title": "[HNOI2002] 填数游戏", "background": "", "description": "某商店最近开展了一个答题有奖的促销活动，公司经理将若干道有一定难度的问题贴到了商场的宣传栏内，如果你能够做出其中一道的话，你就能够获得优惠购买商品的权利。一段日子以后，大多数题目都被消费者们找出了答案，可是惟独有一道题目难倒了所有的人，这道题目是这样描述的：\n\n将不同的完全平方数填满 $n \\times m$ 的矩形方格表中的每一个小方格，使得每行、每列的和也是完全平方数（这个和必须小于 ${10}^{17}$）。希望你找到一种合理的方案。\n\nTiger 希望自己能够获得优惠购物的权利，于是他找到了准备参加 NOI2002 的你，希望你能够帮他设计一个程序找到一种合理的方案。\n", "inputFormat": "输入文件中仅有一行，为两个正整数 $n, m$（$2 \\le n, m \\le 15$）。", "outputFormat": "如果有解的话，输出 $n$ 行，每行有 $m$ 个数，表示一种合理的填数方案，无解时输出 `No answer`。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2002] Filling Numbers Game", "background": "", "description": "A store recently launched a promotional event with prizes for solving questions. The manager posted several challenging problems on the store’s bulletin board, and if you can solve any one of them, you can obtain the right to purchase goods at a discount. After some time, most problems were solved by customers, but there was one problem that stumped everyone. It is described as follows:\n\nFill every cell of an $n \\times m$ rectangular grid with distinct perfect squares, such that the sum of each row and each column is also a perfect square (each such sum must be less than ${10}^{17}$). Please find a valid arrangement.\n\nTiger hopes to earn the discount, so he turns to you, who are preparing for NOI 2002, and asks you to design a program to find a valid arrangement.", "inputFormat": "The input consists of a single line with two positive integers $n, m$ ($2 \\le n, m \\le 15$).", "outputFormat": "If a solution exists, output $n$ lines, each containing $m$ numbers that represent a valid arrangement. If there is no solution, output `No answer`.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2002] 填数游戏", "background": "", "description": "某商店最近开展了一个答题有奖的促销活动，公司经理将若干道有一定难度的问题贴到了商场的宣传栏内，如果你能够做出其中一道的话，你就能够获得优惠购买商品的权利。一段日子以后，大多数题目都被消费者们找出了答案，可是惟独有一道题目难倒了所有的人，这道题目是这样描述的：\n\n将不同的完全平方数填满 $n \\times m$ 的矩形方格表中的每一个小方格，使得每行、每列的和也是完全平方数（这个和必须小于 ${10}^{17}$）。希望你找到一种合理的方案。\n\nTiger 希望自己能够获得优惠购物的权利，于是他找到了准备参加 NOI2002 的你，希望你能够帮他设计一个程序找到一种合理的方案。\n", "inputFormat": "输入文件中仅有一行，为两个正整数 $n, m$（$2 \\le n, m \\le 15$）。", "outputFormat": "如果有解的话，输出 $n$ 行，每行有 $m$ 个数，表示一种合理的填数方案，无解时输出 `No answer`。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2233", "type": "P", "difficulty": 4, "samples": [["6", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2002", "各省省选", "湖南", "矩阵乘法"], "title": "[HNOI2002] 公交车路线", "background": "", "description": "在长沙城新建的环城公路上一共有 $8$ 个公交站，分别为 A、B、C、D、E、F、G、H。公共汽车只能够在相邻的两个公交站之间运行，因此你从某一个公交站到另外一个公交站往往要换几次车，例如从公交站 A 到公交站 D，你就至少需要换 $3$ 次车。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1297.png) \n\nTiger 的方向感极其糟糕，我们知道从公交站 A 到公交 E 只需要换 $4$ 次车就可以到达，可是 tiger 却总共换了 $n$ 次车，注意 tiger 一旦到达公交站 E，他不会愚蠢到再去换车。现在希望你计算一下 tiger 有多少种可能的乘车方案。\n", "inputFormat": "仅有一个正整数 $n$，表示 tiger 从公交车站 A 到公交车站 E 共换了 $n$ 次车。", "outputFormat": "输出一个正整数表示方案数，由于方案数很大，请输出方案数除以 $1000$ 后的余数。", "hint": "8 条路线分别是：\n\n(A→B→C→D→C→D→E)，(A→B→C→B→C→D→E)，\n\n(A→B→A→B→C→D→E)，(A→H→A→B→C→D→E)，\n\n(A→H→G→F→G→F→E)，(A→H→G→H→G→F→E)，\n\n(A→H→A→H→G→F→E)，(A→B→A→H→G→F→E)。\n\n#### 数据范围\n\n$4\\le n\\le10^7$。", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2002] Bus Routes", "background": "", "description": "On the newly built ring road in Changsha, there are $8$ bus stops: A, B, C, D, E, F, G, H. Buses can only run between two adjacent stops. Therefore, to go from one stop to another, you often have to change buses several times. For example, to get from stop A to stop D, you need to change buses at least $3$ times.\n\n![](https://cdn.luogu.com.cn/upload/pic/1297.png)\n\nTiger has a very poor sense of direction. We know that to get from bus stop A to bus stop E, it takes only $4$ changes to arrive, but Tiger changed buses a total of $n$ times. Note that once Tiger reaches bus stop E, he will not be foolish enough to transfer again. Now, please compute how many possible riding plans Tiger may have.", "inputFormat": "A single positive integer $n$, indicating that Tiger changed buses a total of $n$ times from bus stop A to bus stop E.", "outputFormat": "Output a single integer representing the number of plans. Since the number may be large, output the remainder after dividing by $1000$.", "hint": "The $8$ routes are:\n\n(A→B→C→D→C→D→E), (A→B→C→B→C→D→E),\n\n(A→B→A→B→C→D→E), (A→H→A→B→C→D→E),\n\n(A→H→G→F→G→F→E), (A→H→G→H→G→F→E),\n\n(A→H→A→H→G→F→E), (A→B→A→H→G→F→E).\n\nConstraints: $4\\le n\\le10^7$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2002] 公交车路线", "background": "", "description": "在长沙城新建的环城公路上一共有 $8$ 个公交站，分别为 A、B、C、D、E、F、G、H。公共汽车只能够在相邻的两个公交站之间运行，因此你从某一个公交站到另外一个公交站往往要换几次车，例如从公交站 A 到公交站 D，你就至少需要换 $3$ 次车。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1297.png) \n\nTiger 的方向感极其糟糕，我们知道从公交站 A 到公交 E 只需要换 $4$ 次车就可以到达，可是 tiger 却总共换了 $n$ 次车，注意 tiger 一旦到达公交站 E，他不会愚蠢到再去换车。现在希望你计算一下 tiger 有多少种可能的乘车方案。\n", "inputFormat": "仅有一个正整数 $n$，表示 tiger 从公交车站 A 到公交车站 E 共换了 $n$ 次车。", "outputFormat": "输出一个正整数表示方案数，由于方案数很大，请输出方案数除以 $1000$ 后的余数。", "hint": "8 条路线分别是：\n\n(A→B→C→D→C→D→E)，(A→B→C→B→C→D→E)，\n\n(A→B→A→B→C→D→E)，(A→H→A→B→C→D→E)，\n\n(A→H→G→F→G→F→E)，(A→H→G→H→G→F→E)，\n\n(A→H→A→H→G→F→E)，(A→B→A→H→G→F→E)。\n\n#### 数据范围\n\n$4\\le n\\le10^7$。", "locale": "zh-CN"}}}
{"pid": "P2234", "type": "P", "difficulty": 2, "samples": [["6\n5\n1\n2\n5\n4\n6\n", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2002", "二分", "各省省选", "湖南", "排序"], "title": "[HNOI2002] 营业额统计", "background": null, "description": "Tiger 最近被公司升任为营业部经理，他上任后接受公司交给的第一项任务便是统计并分析公司成立以来的营业情况。\n\nTiger 拿出了公司的账本，账本上记录了公司成立以来每天的营业额。分析营业情况是一项相当复杂的工作。由于节假日，大减价或者是其他情况的时候，营业额会出现一定的波动，当然一定的波动是能够接受的，但是在某些时候营业额突变得很高或是很低，这就证明公司此时的经营状况出现了问题。经济管理学上定义了一种最小波动值来衡量这种情况：当最小波动值越大时，就说明营业情况越不稳定。\n\n而分析整个公司的从成立到现在营业情况是否稳定，只需要把每一天的最小波动值加起来就可以了。你的任务就是编写一个程序帮助 Tiger 来计算这一个值。\n\n我们定义，一天的最小波动值 = $\\min\\{|\\text{该天以前某一天的营业额}-\\text{该天营业额}|\\}$。\n\n特别地，第一天的最小波动值为第一天的营业额。", "inputFormat": "第一行为正整数 $n$（$n \\leq 32767$） ，表示该公司从成立一直到现在的天数，接下来的 $n$ 行每行有一个整数 $a_i$（$|a_i| \\leq 10^6$) ，表示第 $i$ 天公司的营业额，可能存在负数。", "outputFormat": "输出一个整数，即每一天最小波动值的和，保证结果小于 $2^{31}$。", "hint": "结果说明：$5+|1-5|+|2-1|+|5-5|+|4-5|+|6-5|=5+4+1+0+1+1=12$", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2002] Turnover Statistics", "background": "", "description": "Tiger was recently promoted to the Sales Department manager. His first task from the company is to compile statistics and analyze the company’s turnover since its founding.\n\nTiger took out the company’s ledger, which records the turnover of each day since the company was founded. Analyzing turnover is a rather complex task. Because of holidays, big discounts, or other situations, turnover may fluctuate. A certain degree of fluctuation is acceptable, but sometimes the turnover suddenly becomes very high or very low, which indicates a problem in the company’s operations. In economics and management, a minimum fluctuation value is defined to measure this: the larger the minimum fluctuation value, the less stable the turnover is.\n\nTo analyze whether the overall turnover from the company’s founding to now is stable, you only need to sum the minimum fluctuation value of each day. Your task is to write a program to help Tiger compute this value.\n\nWe define the minimum fluctuation value of a day as $\\min\\{|\\text{the turnover of some previous day} - \\text{the turnover of the current day}|\\}$.\n\nIn particular, the minimum fluctuation value of the first day is the turnover of the first day.", "inputFormat": "The first line contains a positive integer $n$ ($n \\leq 32767$), representing the number of days from the company’s founding up to now.  \nEach of the next $n$ lines contains an integer $a_i$ ($|a_i| \\leq 10^6$), representing the turnover on day $i$, which may be negative.", "outputFormat": "Output a single integer: the sum of the minimum fluctuation values of each day. It is guaranteed that the result is less than $2^{31}$.", "hint": "Result explanation: $5+|1-5|+|2-1|+|5-5|+|4-5|+|6-5|=5+4+1+0+1+1=12$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2002] 营业额统计", "background": null, "description": "Tiger 最近被公司升任为营业部经理，他上任后接受公司交给的第一项任务便是统计并分析公司成立以来的营业情况。\n\nTiger 拿出了公司的账本，账本上记录了公司成立以来每天的营业额。分析营业情况是一项相当复杂的工作。由于节假日，大减价或者是其他情况的时候，营业额会出现一定的波动，当然一定的波动是能够接受的，但是在某些时候营业额突变得很高或是很低，这就证明公司此时的经营状况出现了问题。经济管理学上定义了一种最小波动值来衡量这种情况：当最小波动值越大时，就说明营业情况越不稳定。\n\n而分析整个公司的从成立到现在营业情况是否稳定，只需要把每一天的最小波动值加起来就可以了。你的任务就是编写一个程序帮助 Tiger 来计算这一个值。\n\n我们定义，一天的最小波动值 = $\\min\\{|\\text{该天以前某一天的营业额}-\\text{该天营业额}|\\}$。\n\n特别地，第一天的最小波动值为第一天的营业额。", "inputFormat": "第一行为正整数 $n$（$n \\leq 32767$） ，表示该公司从成立一直到现在的天数，接下来的 $n$ 行每行有一个整数 $a_i$（$|a_i| \\leq 10^6$) ，表示第 $i$ 天公司的营业额，可能存在负数。", "outputFormat": "输出一个整数，即每一天最小波动值的和，保证结果小于 $2^{31}$。", "hint": "结果说明：$5+|1-5|+|2-1|+|5-5|+|4-5|+|6-5|=5+4+1+0+1+1=12$", "locale": "zh-CN"}}}
{"pid": "P2235", "type": "P", "difficulty": 6, "samples": [["5", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "高精度", "2002", "各省省选", "湖南", "数位 DP"], "title": "[HNOI2002] Kathy函数", "background": "", "description": "Tiger 非常喜欢数学，所以他参加了学校组织的数学课外兴趣小组。在兴趣小组的学习当中，老师向 Tiger 介绍了 Kathy 函数，Kathy 函数是这样定义的：\n\n$$\n\\left\\{\n\\begin{aligned}\n&f(1)=1\\\\\n&f(3)=3\\\\\n&f(2n)=f(n)\\\\\n&f(4n+1)=2f(2n+1)-f(n)\\\\\n&f(4n+3)=3f(2n+1)-2f(n)\n\\end{aligned}\n\\right.\n$$\n\nTiger 对 Kathy 函数产生了浓厚的兴趣，他通过研究发现有很多的数 $n$ 都满足 $f(n)=n$。\n\n对于一个给定的数 $m$，他希望你求出所有的满足 $f(n)=n$ 的正整数 $n$ 的个数，其中 $n\\leq m$。", "inputFormat": "输入只有一行一个整数，表示 $m$。", "outputFormat": "输出一行一个整数，表示 $n$。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq m \\leq 10^{100}$。", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2002] Kathy Function", "background": "", "description": "Tiger likes math very much, so he joined the school's extracurricular math club. In the club, the teacher introduced the Kathy function to Tiger, which is defined as:\n\n$$\n\\left\\{\n\\begin{aligned}\n&f(1)=1\\\\\n&f(3)=3\\\\\n&f(2n)=f(n)\\\\\n&f(4n+1)=2f(2n+1)-f(n)\\\\\n&f(4n+3)=3f(2n+1)-2f(n)\n\\end{aligned}\n\\right.\n$$\n\nTiger became very interested in the Kathy function, and through studying he found that many numbers $n$ satisfy $f(n)=n$.\n\nGiven a number $m$, he wants you to find the number of positive integers $n$ such that $f(n)=n$, where $n \\leq m$.", "inputFormat": "The input contains a single line with an integer $m$.", "outputFormat": "Output a single integer: the number of positive integers $n$ with $n \\leq m$ that satisfy $f(n)=n$.", "hint": "Constraints\n\nFor all testdata, it is guaranteed that $1 \\leq m \\leq 10^{100}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2002] Kathy函数", "background": "", "description": "Tiger 非常喜欢数学，所以他参加了学校组织的数学课外兴趣小组。在兴趣小组的学习当中，老师向 Tiger 介绍了 Kathy 函数，Kathy 函数是这样定义的：\n\n$$\n\\left\\{\n\\begin{aligned}\n&f(1)=1\\\\\n&f(3)=3\\\\\n&f(2n)=f(n)\\\\\n&f(4n+1)=2f(2n+1)-f(n)\\\\\n&f(4n+3)=3f(2n+1)-2f(n)\n\\end{aligned}\n\\right.\n$$\n\nTiger 对 Kathy 函数产生了浓厚的兴趣，他通过研究发现有很多的数 $n$ 都满足 $f(n)=n$。\n\n对于一个给定的数 $m$，他希望你求出所有的满足 $f(n)=n$ 的正整数 $n$ 的个数，其中 $n\\leq m$。", "inputFormat": "输入只有一行一个整数，表示 $m$。", "outputFormat": "输出一行一个整数，表示 $n$。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq m \\leq 10^{100}$。", "locale": "zh-CN"}}}
{"pid": "P2236", "type": "P", "difficulty": 5, "samples": [["2 4 3 4", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2002", "各省省选", "湖南", "深度优先搜索 DFS"], "title": "[HNOI2002] 彩票", "background": "", "description": "某地发行一套彩票。彩票上写有 $1$ 到 $M$ 这 $M$ 个自然数。彩民可以在这 $M$ 个数中任意选取 $N$ 个不同的数打圈。每个彩民只能买一张彩票，不同的彩民的彩票上的选择不同。\n\n每次抽奖将抽出两个自然数 $X$ 和 $Y$。如果某人拿到的彩票上，所选 $N$ 个自然数的倒数和，恰好等于 $\\dfrac{X}{Y}$，则他将获得一个纪念品。\n\n已知抽奖结果 $X$ 和 $Y$。现在的问题是，必须准备多少纪念品，才能保证支付所有获奖者的奖品。", "inputFormat": "输入文件有且仅有一行，就是用空格分开的四个整数 $N$，$M$，$X$，$Y$。\n", "outputFormat": "输出文件有且仅有一行，即所需准备的纪念品数量。\n", "hint": "$1 \\leq X, Y \\leq 100$，$1 \\leq N \\leq 10$，$1 \\leq M \\leq 50$。\n\n输入数据保证输出结果不超过 $10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2002] Lottery", "background": "", "description": "A set of lottery tickets is issued in a certain place. Each ticket displays the $M$ natural numbers from $1$ to $M$. A player may circle any $N$ distinct numbers among these $M$ numbers. Each player can buy only one ticket, and different players choose different sets.\n\nEach draw picks two natural numbers $X$ and $Y$. If, on someone's ticket, the sum of the reciprocals of the $N$ selected natural numbers is exactly equal to $\\dfrac{X}{Y}$, then they will receive a souvenir.\n\nGiven the draw result $X$ and $Y$, determine how many souvenirs must be prepared to ensure all winners can be awarded.", "inputFormat": "The input contains exactly one line with four integers $N$, $M$, $X$, $Y$ separated by spaces.", "outputFormat": "Output one line with the required number of souvenirs.", "hint": "$1 \\leq X, Y \\leq 100$, $1 \\leq N \\leq 10$, $1 \\leq M \\leq 50$.\n\nThe input guarantees the output does not exceed $10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2002] 彩票", "background": "", "description": "某地发行一套彩票。彩票上写有 $1$ 到 $M$ 这 $M$ 个自然数。彩民可以在这 $M$ 个数中任意选取 $N$ 个不同的数打圈。每个彩民只能买一张彩票，不同的彩民的彩票上的选择不同。\n\n每次抽奖将抽出两个自然数 $X$ 和 $Y$。如果某人拿到的彩票上，所选 $N$ 个自然数的倒数和，恰好等于 $\\dfrac{X}{Y}$，则他将获得一个纪念品。\n\n已知抽奖结果 $X$ 和 $Y$。现在的问题是，必须准备多少纪念品，才能保证支付所有获奖者的奖品。", "inputFormat": "输入文件有且仅有一行，就是用空格分开的四个整数 $N$，$M$，$X$，$Y$。\n", "outputFormat": "输出文件有且仅有一行，即所需准备的纪念品数量。\n", "hint": "$1 \\leq X, Y \\leq 100$，$1 \\leq N \\leq 10$，$1 \\leq M \\leq 50$。\n\n输入数据保证输出结果不超过 $10^5$。", "locale": "zh-CN"}}}
{"pid": "P2237", "type": "P", "difficulty": 4, "samples": [["10 3\ndab\nba\nab\ndaa\naa\naaa\naab\nabc\nac\ndadba\n4 a\n2 da\n4 da", "3\n1\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "USACO", "枚举"], "title": "[USACO14FEB] Auto-complete S", "background": "", "description": "Bessie the cow has a new cell phone and enjoys sending text messages, although she keeps making spelling errors since she has trouble typing on such a small screen with her large hooves.  Farmer John has agreed to help her by writing an auto-completion app that takes a partial word and suggests how to complete it.\n\nThe auto-completion app has access to a dictionary of W words, each consisting of lowercase letters in the range a..z, where the total number of letters among all words is at most 1,000,000.  The app is given as input a list of N partial words (1 <= N <= 1000), each containing at most 1000 lowercase letters.  Along with each partial word i, an integer K\\_i is also provided, such that the app must find the (K\\_i)th word in alphabetical order that has partial word i as a prefix.  That is, if one ordered all of the valid completions of the ith partial word, the app should output the completion that is (K\\_i)th in this sequence.\n", "inputFormat": "\\* Line 1: Two integers: W and N.\n\n\n\\* Lines 2..W+1: Line i+1: The ith word in the dictionary.\n\n\n\\* Lines W+2..W+N+1: Line W+i+1: A single integer K\\_i followed by a    partial word.\n", "outputFormat": "\\* Lines 1..N: Line i should contain the index within the dictionary\n\n(an integer in the range 1..W) of the (K\\_i)th completion (in\n\nalphabetical order) of the ith partial word, or -1 if there\n\nare less than K\\_i completions.\n", "hint": "OUTPUT DETAILS:\n\n\nThe completions of a are {aa,aaa,aab,ab,abc,ac}. The 4th is ab, which\n\nis listed on line 3 of the dictionary.  The completions of da are\n\n{daa,dab,dadba}. The 2nd is dab, listed on line 1 of the dictionary.\n\nThere is no 4th completion of da.\n\n\nSource: USACO 2014 Feburary Contest, Silver\n", "locale": "en", "translations": {"en": {"title": "[USACO14FEB] Auto-complete S", "background": "", "description": "Bessie the cow has a new cell phone and enjoys sending text messages, although she keeps making spelling errors since she has trouble typing on such a small screen with her large hooves.  Farmer John has agreed to help her by writing an auto-completion app that takes a partial word and suggests how to complete it.\n\nThe auto-completion app has access to a dictionary of W words, each consisting of lowercase letters in the range a..z, where the total number of letters among all words is at most 1,000,000.  The app is given as input a list of N partial words (1 <= N <= 1000), each containing at most 1000 lowercase letters.  Along with each partial word i, an integer K\\_i is also provided, such that the app must find the (K\\_i)th word in alphabetical order that has partial word i as a prefix.  That is, if one ordered all of the valid completions of the ith partial word, the app should output the completion that is (K\\_i)th in this sequence.\n", "inputFormat": "\\* Line 1: Two integers: W and N.\n\n\n\\* Lines 2..W+1: Line i+1: The ith word in the dictionary.\n\n\n\\* Lines W+2..W+N+1: Line W+i+1: A single integer K\\_i followed by a    partial word.\n", "outputFormat": "\\* Lines 1..N: Line i should contain the index within the dictionary\n\n(an integer in the range 1..W) of the (K\\_i)th completion (in\n\nalphabetical order) of the ith partial word, or -1 if there\n\nare less than K\\_i completions.\n", "hint": "OUTPUT DETAILS:\n\n\nThe completions of a are {aa,aaa,aab,ab,abc,ac}. The 4th is ab, which\n\nis listed on line 3 of the dictionary.  The completions of da are\n\n{daa,dab,dadba}. The 2nd is dab, listed on line 1 of the dictionary.\n\nThere is no 4th completion of da.\n\n\nSource: USACO 2014 Feburary Contest, Silver\n", "locale": "en"}, "zh-CN": {"title": "[USACO14FEB] Auto-complete S", "background": null, "description": "有 $w$ 个由小写字符构成的字典和 $n$ 个询问。每个询问由一个字符串 $s$ 和一个整数 $k$ 构成，求在字典序排序下字典内由 $s$ 为前缀的第 $k$ 字符串在输入字典的位置。若不存在，则输出 $-1$", "inputFormat": "第 $1$ 行是两个整数 $w$ 和 $n$ \n\n第 $2$ 行到第 $w$ + $1$ 行为字典中的第 $i$ - $1$ 个，每行由字符串构成（$i$ 指输入的第 $i$ 行）\n\n第 $w$ + $2$ 行到第 $w$ + $n$ + $1$ 行由一个整数 $k$ 和一个字符串 $s$ 构成", "outputFormat": "第 $1$ 行到第 $n$ 行是对于每个询问的结果，由一个整数构成", "hint": "对于 $100\\%$ 的数据，$w \\le 30000$，$1\\le n \\le 3000$，字典内每个字符串的长度均小于等于 $1000$，且字典的单词总长不超过 $10 ^ 6$。\n\n样例解释：\n\n对于第 $1$ 个询问，含义为在字典中找到以 ```a``` 为前缀且按字典序排序后第 $4$ 个字符串，而字典中以 ```a``` 为前缀且按字典序排序后为 $\\{$  ```aa```，```aaa```，```aab```，```ab```，```abc```，```ac``` $\\}$，第 $4$ 个是 ```ab```，其在输入中为第 $3$ 个，故输出为 $3$\n\n同理，对于第 $2$ 个和第 $3$ 个询问是在字典中找到以 ```da``` 为前缀且按字典序排序后的第 $2$ 和第 $4$ 个字符串。而以 ```da``` 为前缀的字符串按字典序排序后为 $\\{$```daa```，```dab```，```dadba``` $\\}$，故第 $2$ 个为 ```dab``` ，其在输入中为第 $1$ 个，故第 $2$ 个输出为 $1$，而该序列中没有第 $4$ 个，故第 $3$ 个询问无解，输出 $-1$\n\n来源：USACO 2014 Feburary Contest Silver\n\n翻译：@[zymooll](/user/289296)", "locale": "zh-CN"}}}
{"pid": "P2238", "type": "P", "difficulty": 6, "samples": [["5 5\n....7\n.21.8\n9346.\n..45.\n.8...", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "洛谷原创", "O2优化", "洛谷月赛", "状压 DP"], "title": "逛庙会", "background": "本题时限 3s，请考虑常数优化或者读入优化。（std 没有特别进行优化）", "description": "城市里正在举行庙会。庙会里有很多摊位。庙会的会场是一个南北向 $H$ 个摊位、东西向 $W$ 个摊位组成的大型方阵。从北开始第 $i$ 行、西开始第 $j$ 列的一个摊位，我们表示为 $(i,j)$。\n\n正妹现在处于庙会的 $(1,1)$ 位置，然后要往东或者往南走，一直走到 $(H,W)$ 跟小 B 汇合。$(1,1)$ 点、$(H,W)$ 点和它们的东西南北邻近一个摊位都没有开张。别的地方也可能有一些摊位没有开张。\n\n正妹是个吃货。只要到达一个摊位，总是经不起小吃的诱惑。如果这个摊位开张了，而且该摊位小吃还没有买过，就会买下这个摊位的小吃。无论这个摊位是否有开张，其东西南北直接相邻的摊位小吃的香味也很诱人，如果邻近的摊位的小吃没有买过，那么就在这些邻近（上下左右）的且没有买过的摊位（假设有 $r$ 个）中，买其中的 $r-1$ 个摊位的小吃。然后继续往东或者南走。同一家小摊，不会购买多次。\n\n虽然正妹是个吃货，但是零用钱还是很有限。可是她又是管不住自己，就是要买买买。所以她希望知道自己最少能吃掉多少钱的东西。", "inputFormat": "第一行两个整数 $H$ 和 $W$。\n\n接下来 $H$ 行，每行一个长度为 $W$ 的字符串，**没有空格隔开**，是 $1\\sim9$ 或者 `.` 中的一个，数字表示价格，`.` 表示没有开张。", "outputFormat": "一个整数，表示最少花掉的钱。", "hint": "```plain\n5 5\noooo7\n.2xoo\n9346o\n..45o\n.8..o\n```\n\n样例解释：`o` 为正妹经过的路线，`x` 为她顺便买的小吃。当走到 $(2,4)$ 时，左下右都有开张且没有买过的摊位，于是买左和右，继续沿着路线走。由于之后路线没有经过没有买过摊位，而且上下左右开张且没买过的摊位不超过 $1$，所以一个都不买了。\n\n对于 $20\\%$ 的数据，开张的摊位不超过 $20$；\n\n对于 $100\\%$ 的数据，保证 $3\\le H,W\\le1000$。\n\n特别注意：数据是在 Windows 生成，输入数据换行符可能是 `\\r\\n`（两个字符）或者 `\\n`。而评测机是 Linux。请特别注意。不接受赛后以「本地能过，评测 WA」的理由申诉。\n\n参考读入方式（节选自 std）：\n\n```cpp\nfor (i = 0; i < H; ++i) {\n\tscanf(\"%s\", in);\n\tfor (j = 0; j < W; ++j) {\n\t\tshop[i][j] = blabla..\n\t}\n}\n```", "locale": "zh-CN", "translations": {"en": {"title": "Visiting the Temple Fair", "background": "The time limit is 3 s. Please consider constant-factor optimization or fast I/O. (The std does not use special optimizations.)", "description": "A temple fair is being held in the city. There are many stalls at the fair. The venue forms a large grid with $H$ stalls from north to south and $W$ stalls from west to east. A stall at the $i$-th row from the north and the $j$-th column from the west is denoted by $(i, j)$.\n\nThe girl starts at position $(1, 1)$ in the fair and can only move east or south, continuing until she reaches $(H, W)$ to meet Xiao B. The stalls at $(1, 1)$ and $(H, W)$, as well as each of their four directly adjacent stalls (north, south, east, west), are not open. There may also be other stalls that are not open elsewhere.\n\nThe girl is a foodie. Whenever she arrives at a stall, she cannot resist the snacks there. If the stall is open and she has not bought from it before, she will buy the snack at this stall. Regardless of whether the current stall is open, the aromas from its four directly adjacent stalls are tempting as well. Among its directly adjacent open stalls that have not been bought yet (suppose there are $r$ of them), she will buy snacks from exactly $r - 1$ of these adjacent stalls. She then continues moving east or south. She will never buy from the same stall more than once.\n\nAlthough she is a foodie, her pocket money is limited. She cannot control herself and will keep buying. Therefore, she wants to know the minimum total amount of money she will spend.", "inputFormat": "The first line contains two integers $H$ and $W$.\n\nThe next $H$ lines each contain a string of length $W$ without spaces. Each character is one of $1 \\sim 9$ or `.`. A digit represents the price, and `.` represents a stall that is not open.", "outputFormat": "Output a single integer, the minimum amount of money spent.", "hint": "```plain\n5 5\noooo7\n.2xoo\n9346o\n..45o\n.8..o\n```\n\nExplanation of the illustration: `o` marks the route the girl takes, and `x` marks snacks she buys incidentally. When she reaches $(2, 4)$, the left, down, and right neighbors are open and not yet bought, so she buys the left and right ones, then continues along the route. After that, the route does not pass any not-yet-bought stalls, and each time the number of open and not-yet-bought adjacent stalls is at most $1$, so she buys none of them.\n\nConstraints:\n- For $20\\%$ of the testdata, the number of open stalls does not exceed $20$.\n- For $100\\%$ of the testdata, $3 \\le H, W \\le 1000$.\n\nSpecial note: The testdata was generated on Windows. Line endings in the input may be `\\r\\n` (two characters) or `\\n`. The judge runs on Linux. Please be careful. Appeals like “it passes locally but gets WA on the judge” will not be accepted.\n\nReference input method (excerpt from std):\n\n```cpp\nfor (i = 0; i < H; ++i) {\n\tscanf(\"%s\", in);\n\tfor (j = 0; j < W; ++j) {\n\t\tshop[i][j] = blabla..\n\t}\n}\n```\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "逛庙会", "background": "本题时限 3s，请考虑常数优化或者读入优化。（std 没有特别进行优化）", "description": "城市里正在举行庙会。庙会里有很多摊位。庙会的会场是一个南北向 $H$ 个摊位、东西向 $W$ 个摊位组成的大型方阵。从北开始第 $i$ 行、西开始第 $j$ 列的一个摊位，我们表示为 $(i,j)$。\n\n正妹现在处于庙会的 $(1,1)$ 位置，然后要往东或者往南走，一直走到 $(H,W)$ 跟小 B 汇合。$(1,1)$ 点、$(H,W)$ 点和它们的东西南北邻近一个摊位都没有开张。别的地方也可能有一些摊位没有开张。\n\n正妹是个吃货。只要到达一个摊位，总是经不起小吃的诱惑。如果这个摊位开张了，而且该摊位小吃还没有买过，就会买下这个摊位的小吃。无论这个摊位是否有开张，其东西南北直接相邻的摊位小吃的香味也很诱人，如果邻近的摊位的小吃没有买过，那么就在这些邻近（上下左右）的且没有买过的摊位（假设有 $r$ 个）中，买其中的 $r-1$ 个摊位的小吃。然后继续往东或者南走。同一家小摊，不会购买多次。\n\n虽然正妹是个吃货，但是零用钱还是很有限。可是她又是管不住自己，就是要买买买。所以她希望知道自己最少能吃掉多少钱的东西。", "inputFormat": "第一行两个整数 $H$ 和 $W$。\n\n接下来 $H$ 行，每行一个长度为 $W$ 的字符串，**没有空格隔开**，是 $1\\sim9$ 或者 `.` 中的一个，数字表示价格，`.` 表示没有开张。", "outputFormat": "一个整数，表示最少花掉的钱。", "hint": "```plain\n5 5\noooo7\n.2xoo\n9346o\n..45o\n.8..o\n```\n\n样例解释：`o` 为正妹经过的路线，`x` 为她顺便买的小吃。当走到 $(2,4)$ 时，左下右都有开张且没有买过的摊位，于是买左和右，继续沿着路线走。由于之后路线没有经过没有买过摊位，而且上下左右开张且没买过的摊位不超过 $1$，所以一个都不买了。\n\n对于 $20\\%$ 的数据，开张的摊位不超过 $20$；\n\n对于 $100\\%$ 的数据，保证 $3\\le H,W\\le1000$。\n\n特别注意：数据是在 Windows 生成，输入数据换行符可能是 `\\r\\n`（两个字符）或者 `\\n`。而评测机是 Linux。请特别注意。不接受赛后以「本地能过，评测 WA」的理由申诉。\n\n参考读入方式（节选自 std）：\n\n```cpp\nfor (i = 0; i < H; ++i) {\n\tscanf(\"%s\", in);\n\tfor (j = 0; j < W; ++j) {\n\t\tshop[i][j] = blabla..\n\t}\n}\n```", "locale": "zh-CN"}}}
{"pid": "P2239", "type": "P", "difficulty": 3, "samples": [["4 2 3", "14"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "数学", "2014", "NOIP 普及组"], "title": "[NOIP 2014 普及组] 螺旋矩阵", "background": "NOIP2014 普及组 T3", "description": "一个 $n$ 行 $ n$ 列的螺旋矩阵可由如下方法生成：\n\n\n从矩阵的左上角（第 $1$ 行第 $1$ 列）出发，初始时向右移动；如果前方是未曾经过的格子，则继续前进，否则右转；重复上述操作直至经过矩阵中所有格子。根据经过顺序，在格子中依次填入 $1, 2, 3, \\dots, n^2$，便构成了一个螺旋矩阵。\n\n\n下图是一个 $n = 4$ 时的螺旋矩阵。\n\n$$\\begin{pmatrix}\n 1 &    2  &   3   &  4 \\\\\n12 &   13  &  14   &  5 \\\\\n11 &   16  &  15   &  6 \\\\\n10 &    9  &   8   &  7 \\\\\n\\end{pmatrix}$$\n\n现给出矩阵大小 $n$ 以及 $i$ 和 $j$，请你求出该矩阵中第 $i$ 行第 $j$ 列的数是多少。\n", "inputFormat": "共一行，包含三个整数 $n$, $i$, $j$，每两个整数之间用一个空格隔开，分别表示矩阵大小、待求的数所在的行号和列号。\n", "outputFormat": "一个整数，表示相应矩阵中第 $i$ 行第 $j$ 列的数。\n", "hint": "【数据说明】\n\n对于 $50\\%$ 的数据，$1 \\leqslant n \\leqslant 100$;\n\n对于 $100\\%$ 的数据，$1 \\leqslant n \\leqslant 30,000,1 \\leqslant i \\leqslant n,1 \\leqslant j \\leqslant n$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2014 Junior] Spiral Matrix", "background": "NOIP 2014 Junior T3.", "description": "A spiral matrix with $n$ rows and $n$ columns can be generated as follows:\n\nStarting from the top-left corner (row $1$, column $1$), initially move to the right. If the cell ahead has not been visited, keep moving forward; otherwise, turn right. Repeat this process until all cells in the matrix have been visited. According to the visiting order, fill the cells with $1, 2, 3, \\dots, n^2$ in sequence to form a spiral matrix.\n\nBelow is the spiral matrix when $n = 4$.\n\n$$\\begin{pmatrix}\n 1 &    2  &   3   &  4 \\\\\n12 &   13  &  14   &  5 \\\\\n11 &   16  &  15   &  6 \\\\\n10 &    9  &   8   &  7 \\\\\n\\end{pmatrix}$$\n\nGiven the matrix size $n$ and $i$ and $j$, please compute the number at row $i$, column $j$ in this matrix.", "inputFormat": "A single line containing three integers $n$, $i$, $j$, separated by a single space. They represent the matrix size, and the row and column of the number to query.", "outputFormat": "A single integer, the number at row $i$, column $j$ in the corresponding matrix.", "hint": "Constraints\n\n- For $50\\%$ of the testdata, $1 \\leqslant n \\leqslant 100$.\n- For $100\\%$ of the testdata, $1 \\leqslant n \\leqslant 30{,}000$; $1 \\leqslant i \\leqslant n$; $1 \\leqslant j \\leqslant n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2014 普及组] 螺旋矩阵", "background": "NOIP2014 普及组 T3", "description": "一个 $n$ 行 $ n$ 列的螺旋矩阵可由如下方法生成：\n\n\n从矩阵的左上角（第 $1$ 行第 $1$ 列）出发，初始时向右移动；如果前方是未曾经过的格子，则继续前进，否则右转；重复上述操作直至经过矩阵中所有格子。根据经过顺序，在格子中依次填入 $1, 2, 3, \\dots, n^2$，便构成了一个螺旋矩阵。\n\n\n下图是一个 $n = 4$ 时的螺旋矩阵。\n\n$$\\begin{pmatrix}\n 1 &    2  &   3   &  4 \\\\\n12 &   13  &  14   &  5 \\\\\n11 &   16  &  15   &  6 \\\\\n10 &    9  &   8   &  7 \\\\\n\\end{pmatrix}$$\n\n现给出矩阵大小 $n$ 以及 $i$ 和 $j$，请你求出该矩阵中第 $i$ 行第 $j$ 列的数是多少。\n", "inputFormat": "共一行，包含三个整数 $n$, $i$, $j$，每两个整数之间用一个空格隔开，分别表示矩阵大小、待求的数所在的行号和列号。\n", "outputFormat": "一个整数，表示相应矩阵中第 $i$ 行第 $j$ 列的数。\n", "hint": "【数据说明】\n\n对于 $50\\%$ 的数据，$1 \\leqslant n \\leqslant 100$;\n\n对于 $100\\%$ 的数据，$1 \\leqslant n \\leqslant 30,000,1 \\leqslant i \\leqslant n,1 \\leqslant j \\leqslant n$。\n", "locale": "zh-CN"}}}
{"pid": "P2240", "type": "P", "difficulty": 2, "samples": [["4 50\n10 60\n20 100\n25 100\n15 45\n", "240.00"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心"], "title": "【深基12.例1】部分背包问题", "background": "", "description": "阿里巴巴走进了装满宝藏的藏宝洞。藏宝洞里面有 $N(N \\le 100)$ 堆金币，第 $i$ 堆金币的总重量和总价值分别是 $m_i,v_i(1\\le m_i,v_i \\le 100)$。阿里巴巴有一个承重量为 $T(T \\le 1000)$ 的背包，但并不一定有办法将全部的金币都装进去。他想装走尽可能多价值的金币。所有金币都可以随意分割，分割完的金币重量价值比（也就是单位价格）不变。请问阿里巴巴最多可以拿走多少价值的金币？", "inputFormat": "第一行两个整数 $N,T$。\n\n接下来 $N$ 行，每行两个整数 $m_i,v_i$。", "outputFormat": "一个实数表示答案，输出两位小数", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[Deep Basics 12.Example 1] Fractional Knapsack Problem", "background": "", "description": "Alibaba walked into a treasure cave full of treasures. In the cave, there are $N(N \\le 100)$ piles of gold coins. For the $i$-th pile, the total weight and total value are $m_i,v_i(1\\le m_i,v_i \\le 100)$. Alibaba has a knapsack with capacity $T(T \\le 1000)$, but it may not be possible to pack all the gold coins. He wants to take away gold coins with as much total value as possible. All gold coins can be divided freely, and after dividing, the value-to-weight ratio (i.e., the unit price) stays the same. Find the maximum total value of gold coins that Alibaba can take away.", "inputFormat": "The first line contains two integers $N, T$.\n\nThe next $N$ lines each contain two integers $m_i, v_i$.", "outputFormat": "Output one real number as the answer, printed to two decimal places.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【深基12.例1】部分背包问题", "background": "", "description": "阿里巴巴走进了装满宝藏的藏宝洞。藏宝洞里面有 $N(N \\le 100)$ 堆金币，第 $i$ 堆金币的总重量和总价值分别是 $m_i,v_i(1\\le m_i,v_i \\le 100)$。阿里巴巴有一个承重量为 $T(T \\le 1000)$ 的背包，但并不一定有办法将全部的金币都装进去。他想装走尽可能多价值的金币。所有金币都可以随意分割，分割完的金币重量价值比（也就是单位价格）不变。请问阿里巴巴最多可以拿走多少价值的金币？", "inputFormat": "第一行两个整数 $N,T$。\n\n接下来 $N$ 行，每行两个整数 $m_i,v_i$。", "outputFormat": "一个实数表示答案，输出两位小数", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2241", "type": "P", "difficulty": 2, "samples": [["2 3", "8 10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "1997", "NOIP 普及组", "枚举"], "title": "统计方形（数据加强版）", "background": "1997年普及组第一题\n", "description": "有一个 $n \\times m$ 方格的棋盘，求其方格包含多少正方形、长方形（不包含正方形）。", "inputFormat": "一行，两个正整数 $n,m$（$n \\leq 5000,m \\leq 5000$）。\n", "outputFormat": "一行，两个正整数，分别表示方格包含多少正方形、长方形（不包含正方形）。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Counting Squares (Enhanced Testdata Version)", "background": "1997 Junior Problem 1.", "description": "Given an $n \\times m$ grid board, compute how many squares and how many rectangles (excluding squares) it contains.", "inputFormat": "One line: two positive integers $n,m$ ($n \\leq 5000,m \\leq 5000$).", "outputFormat": "One line: two positive integers, the numbers of squares and rectangles (excluding squares) in the grid, respectively.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "统计方形（数据加强版）", "background": "1997年普及组第一题\n", "description": "有一个 $n \\times m$ 方格的棋盘，求其方格包含多少正方形、长方形（不包含正方形）。", "inputFormat": "一行，两个正整数 $n,m$（$n \\leq 5000,m \\leq 5000$）。\n", "outputFormat": "一行，两个正整数，分别表示方格包含多少正方形、长方形（不包含正方形）。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2242", "type": "P", "difficulty": 2, "samples": [["18 4\n3 4 6 8 14 15 16 17 21 25 26 27 30 31 40 41 42 43\n", "25"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "贪心", "线性数据结构"], "title": "公路维修问题", "background": null, "description": "由于长期没有得到维修，A 国的高速公路上出现了 $n$ 个坑。为了尽快填补好这 $n$ 个坑，A 国决定对 $m$ 处地段采取交通管制。为了求解方便，假设 A 国的高速公路只有一条，而且是笔直的。现在给出 $n$ 个坑的位置，请你计算，最少要对多远的路段实施交通管制？", "inputFormat": "输入数据共两行，第一行为两个正整数 $n, m(2\\le m \\le n\\le 15000)$。第二行给出了 $n$ 个坑的坐标（坐标值均在长整范围内，按从小到大的顺序给出，且不会有两个点坐标相同）。", "outputFormat": "仅一行，为最小长度和。", "hint": "【样例说明】\n\n需要在整条路上取 $4$ 小段，这 $4$ 段路需要包含所有坑。取 $[3,8],[14,21],[25,31],[40,43]$ 这四段即可，长度总和为 $6+8+7+4=25$。", "locale": "zh-CN", "translations": {"en": {"title": "Highway Maintenance Problem", "background": "", "description": "Due to long-term lack of maintenance, there are $n$ potholes on Country A’s highway. To repair these $n$ potholes quickly, Country A decides to impose traffic control on $m$ segments of the road. For simplicity, assume there is only one highway, and it is straight. Given the positions of the $n$ potholes, compute the minimal total length of road that must be under traffic control.", "inputFormat": "The input consists of two lines.\n- The first line contains two positive integers $n, m$ ($2 \\le m \\le n \\le 15000$).\n- The second line contains the coordinates of the $n$ potholes (each within the 64-bit signed integer range), given in strictly increasing order with no duplicate coordinates.", "outputFormat": "Output a single line: the minimal total length.", "hint": "[Sample Explanation]\n\nThe controlled segments are: $3-8, 14-21, 25-31, 40-43$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "公路维修问题", "background": null, "description": "由于长期没有得到维修，A 国的高速公路上出现了 $n$ 个坑。为了尽快填补好这 $n$ 个坑，A 国决定对 $m$ 处地段采取交通管制。为了求解方便，假设 A 国的高速公路只有一条，而且是笔直的。现在给出 $n$ 个坑的位置，请你计算，最少要对多远的路段实施交通管制？", "inputFormat": "输入数据共两行，第一行为两个正整数 $n, m(2\\le m \\le n\\le 15000)$。第二行给出了 $n$ 个坑的坐标（坐标值均在长整范围内，按从小到大的顺序给出，且不会有两个点坐标相同）。", "outputFormat": "仅一行，为最小长度和。", "hint": "【样例说明】\n\n需要在整条路上取 $4$ 小段，这 $4$ 段路需要包含所有坑。取 $[3,8],[14,21],[25,31],[40,43]$ 这四段即可，长度总和为 $6+8+7+4=25$。", "locale": "zh-CN"}}}
{"pid": "P2244", "type": "P", "difficulty": 5, "samples": [["4\n2 2 3\n0\n1 2\n1 2\n", "3 1 3 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索"], "title": "选举预测", "background": "科学院的领袖Dunkelheit 的任期，随着局势的平复很快就要结束了。于是，这次具有非凡意义的科学院新领袖的选举很快就要开始了。\n", "description": "选举的第一步是辩论赛。它的规则是这样的：如果当前剩下的候选人多于 $2$ 人，那么就从中任选 $2$ 人进行辩论。输者退出比赛，胜利者继续留在比赛中，如此直到只剩下一个候选人，他就取得了辩论赛的胜利。  \n\n辩论赛的胜者在后面的选举中将会更占优势，所以说人们都很关注这次比赛的结果，历史学家 Geheimnis 也不例外。 \n\n他收集了所有 $n$ 个候选人的资料，发现如果两个候选人以前曾经比赛过，那么这两个人再次比赛的时候比赛结果是很难改变的（可以认为是不可能）。按照 Geheimnis 掌握的情报，你需要帮助他判断那些候选人有可能取得胜利。\n", "inputFormat": "第一行包含一个正整数 $n$，表示候选人的数目。\n\n之后 $n$ 行，候选人从 $1$ 开始编号，第 $i+1$ 行描述第 $i$ 个候选人。第一个数为 $k$，后面 $k$ 个编号，表示候选人 $i$ 之前赢过的候选人。\n", "outputFormat": "输出一行。第一个数为 $c$，表示有 $c$ 个候选人有可能取得胜利；之后 $c$ 个数表示他们的编号。\n", "hint": "【数据范围】   \n对于 $50\\%$ 的数据，$n \\le 200$。   \n对于 $100\\%$ 的数据，$n \\le 10^6$，胜负关系不会超过 $10^6$ 对。\n", "locale": "zh-CN", "translations": {"en": {"title": "Election Prediction", "background": "As the situation stabilizes, the term of the Academy of Sciences' leader, Dunkelheit, is about to end soon. Therefore, the election for the new leader of the Academy of Sciences, which carries extraordinary significance, is about to begin.", "description": "The first stage of the election is a debate tournament. Its rules are as follows: if the number of remaining candidates is greater than $2$, then any $2$ of them are chosen to debate. The loser exits the tournament, and the winner stays. This continues until only one candidate remains, who is then the winner of the debate tournament.\n\nThe winner of the debate tournament will have an advantage in the subsequent election, so people are very concerned about the result of this tournament, including the historian Geheimnis.\n\nHe gathered information on all $n$ candidates and found that if two candidates have competed before, then the result is very unlikely to change when they meet again (you may assume it will not change). Based on the intelligence Geheimnis has, you need to determine which candidates could possibly become the winner.", "inputFormat": "The first line contains a positive integer $n$, the number of candidates.\n\nThen follow $n$ lines. Candidates are indexed from $1$. The $(i+1)$-th line describes candidate $i$. The first number is $k$, followed by $k$ indices, indicating the candidates that candidate $i$ has previously defeated.", "outputFormat": "Output one line. The first number is $c$, the number of candidates who can possibly win; then output $c$ numbers denoting their indices.", "hint": "Constraints  \nFor $50\\%$ of the testdata, $n \\le 200$.  \nFor $100\\%$ of the testdata, $n \\le 10^6$, and the number of win–loss pairs does not exceed $10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "选举预测", "background": "科学院的领袖Dunkelheit 的任期，随着局势的平复很快就要结束了。于是，这次具有非凡意义的科学院新领袖的选举很快就要开始了。\n", "description": "选举的第一步是辩论赛。它的规则是这样的：如果当前剩下的候选人多于 $2$ 人，那么就从中任选 $2$ 人进行辩论。输者退出比赛，胜利者继续留在比赛中，如此直到只剩下一个候选人，他就取得了辩论赛的胜利。  \n\n辩论赛的胜者在后面的选举中将会更占优势，所以说人们都很关注这次比赛的结果，历史学家 Geheimnis 也不例外。 \n\n他收集了所有 $n$ 个候选人的资料，发现如果两个候选人以前曾经比赛过，那么这两个人再次比赛的时候比赛结果是很难改变的（可以认为是不可能）。按照 Geheimnis 掌握的情报，你需要帮助他判断那些候选人有可能取得胜利。\n", "inputFormat": "第一行包含一个正整数 $n$，表示候选人的数目。\n\n之后 $n$ 行，候选人从 $1$ 开始编号，第 $i+1$ 行描述第 $i$ 个候选人。第一个数为 $k$，后面 $k$ 个编号，表示候选人 $i$ 之前赢过的候选人。\n", "outputFormat": "输出一行。第一个数为 $c$，表示有 $c$ 个候选人有可能取得胜利；之后 $c$ 个数表示他们的编号。\n", "hint": "【数据范围】   \n对于 $50\\%$ 的数据，$n \\le 200$。   \n对于 $100\\%$ 的数据，$n \\le 10^6$，胜负关系不会超过 $10^6$ 对。\n", "locale": "zh-CN"}}}
{"pid": "P2245", "type": "P", "difficulty": 5, "samples": [["4 5\n1 2 5\n1 3 2\n2 3 11\n2 4 6\n3 4 4\n3\n2 3\n1 4\n1 2\n", "5\n4\n5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["图论", "Kruskal 重构树", "最近公共祖先 LCA"], "title": "星际导航", "background": "", "description": "$\\text{sideman}$ 做好了回到 $\\text{Gliese}$ 星球的硬件准备，但是 $\\text{sideman}$ 的导航系统还没有完全设计好。为了方便起见，我们可以认为宇宙是一张有 $N$ 个顶点和 $M$ 条边的带权无向图，顶点表示各个星系，两个星系之间有边就表示两个星系之间可以直航，而边权则是航行的危险程度。\n\n$\\text{sideman}$ 现在想把危险程度降到最小，具体地来说，就是对于若干个询问 $(A, B)$，$\\text{sideman}$ 想知道从顶点 $A$ 航行到顶点 $B$ 所经过的最危险的边的危险程度值最小可能是多少。作为 $\\text{sideman}$ 的同学，你们要帮助 $\\text{sideman}$ 返回家园，兼享受安全美妙的宇宙航行。所以这个任务就交给你了。", "inputFormat": "第一行包含两个正整数 $N$ 和 $M$，表示点数和边数。\n\n之后 $M$ 行，每行三个整数 $A$，$B$ 和 $L$，表示顶点 $A$ 和 $B$ 之间有一条边长为 $L$ 的边。顶点从 $1$ 开始标号。\n\n下面一行包含一个正整数 $Q$，表示询问的数目。\n\n之后 $Q$ 行，每行两个整数 $A$ 和 $B$，表示询问 $A$ 和 $B$ 之间最危险的边危险程度的可能最小值。", "outputFormat": "对于每个询问， 在单独的一行内输出结果。如果两个顶点之间不可达， 输出 $\\text{impossible}$。", "hint": "对于 $40\\%$ 的数据，满足 $N \\leq 1000, M \\leq 3000, Q \\leq 1000$。\n\n对于 $80\\%$ 的数据，满足 $N \\leq 10000, M \\leq 10^5, Q \\leq 1000$。\n\n对于 $100\\%$ 的数据，满足 $N \\leq 10^5, M \\leq 3 \\times 10^5, Q \\leq 10^5, L \\leq 10^9$。数据不保证没有重边和自环。", "locale": "zh-CN", "translations": {"en": {"title": "Interstellar Navigation", "background": "", "description": "$\\text{sideman}$ has prepared the hardware to return to the planet $\\text{Gliese}$, but $\\text{sideman}$'s navigation system is not fully designed yet. For convenience, we can regard the universe as a weighted undirected graph with $N$ vertices and $M$ edges. Vertices represent galaxies, an edge between two galaxies means there is a direct flight between them, and the edge weight is the danger level of the voyage.\n\nNow $\\text{sideman}$ wants to minimize the danger level. Specifically, for several queries $(A, B)$, $\\text{sideman}$ wants to know the minimal possible value of the danger level of the most dangerous edge along a route from vertex $A$ to vertex $B$. As $\\text{sideman}$'s classmates, you should help $\\text{sideman}$ return home and enjoy a safe and beautiful journey through the universe. So this task is yours.", "inputFormat": "The first line contains two positive integers $N$ and $M$, the number of vertices and edges.\n\nEach of the next $M$ lines contains three integers $A$, $B$, and $L$, indicating that there is an edge of length $L$ between vertices $A$ and $B$. Vertices are numbered starting from $1$.\n\nThe next line contains a positive integer $Q$, the number of queries.\n\nEach of the next $Q$ lines contains two integers $A$ and $B$, asking for the minimal possible value of the danger level of the most dangerous edge along any path between $A$ and $B$.", "outputFormat": "For each query, output the result on a separate line. If the two vertices are not reachable from each other, output $\\text{impossible}$.", "hint": "For $40\\%$ of the testdata, $N \\leq 1000$, $M \\leq 3000$, $Q \\leq 1000$.\n\nFor $80\\%$ of the testdata, $N \\leq 10000$, $M \\leq 10^5$, $Q \\leq 1000$.\n\nFor $100\\%$ of the testdata, $N \\leq 10^5$, $M \\leq 3 \\times 10^5$, $Q \\leq 10^5$, $L \\leq 10^9$. The testdata do not guarantee the absence of parallel edges and self-loops.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "星际导航", "background": "", "description": "$\\text{sideman}$ 做好了回到 $\\text{Gliese}$ 星球的硬件准备，但是 $\\text{sideman}$ 的导航系统还没有完全设计好。为了方便起见，我们可以认为宇宙是一张有 $N$ 个顶点和 $M$ 条边的带权无向图，顶点表示各个星系，两个星系之间有边就表示两个星系之间可以直航，而边权则是航行的危险程度。\n\n$\\text{sideman}$ 现在想把危险程度降到最小，具体地来说，就是对于若干个询问 $(A, B)$，$\\text{sideman}$ 想知道从顶点 $A$ 航行到顶点 $B$ 所经过的最危险的边的危险程度值最小可能是多少。作为 $\\text{sideman}$ 的同学，你们要帮助 $\\text{sideman}$ 返回家园，兼享受安全美妙的宇宙航行。所以这个任务就交给你了。", "inputFormat": "第一行包含两个正整数 $N$ 和 $M$，表示点数和边数。\n\n之后 $M$ 行，每行三个整数 $A$，$B$ 和 $L$，表示顶点 $A$ 和 $B$ 之间有一条边长为 $L$ 的边。顶点从 $1$ 开始标号。\n\n下面一行包含一个正整数 $Q$，表示询问的数目。\n\n之后 $Q$ 行，每行两个整数 $A$ 和 $B$，表示询问 $A$ 和 $B$ 之间最危险的边危险程度的可能最小值。", "outputFormat": "对于每个询问， 在单独的一行内输出结果。如果两个顶点之间不可达， 输出 $\\text{impossible}$。", "hint": "对于 $40\\%$ 的数据，满足 $N \\leq 1000, M \\leq 3000, Q \\leq 1000$。\n\n对于 $80\\%$ 的数据，满足 $N \\leq 10000, M \\leq 10^5, Q \\leq 1000$。\n\n对于 $100\\%$ 的数据，满足 $N \\leq 10^5, M \\leq 3 \\times 10^5, Q \\leq 10^5, L \\leq 10^9$。数据不保证没有重边和自环。", "locale": "zh-CN"}}}
{"pid": "P2246", "type": "P", "difficulty": 4, "samples": [["HhEeLlLlOoWwOoRrLlDd", "1536"], ["Gou Li Guo Jia Sheng Si Yi\nQi Yin Huo Fu Bi Qu Zhi\nRiver can feed people\nAlso can race boats\nHall Ellen Ok Words locked ", "273"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "洛谷原创", "O2优化", "洛谷月赛"], "title": "SAC#1 - Hello World（升级版）", "background": "一天，智障的 pipapi 正在看某辣鸡讲义学程序设计。", "description": "在讲义的某一面，他看见了一篇文章。这篇文章由英文字母（大小写均有）、数字、和空白字符（制表/空格/回车）构成。\n\npipapi 想起了他最近刚刚学会写的 `Hello World` 程序。他非常好奇，这篇文章中，`Hello World` 作为子序列到底出现过多少次呢？（**忽略大小写和空格**）\n\n两个子序列相同当且仅当它们每一个字符所在的位置都相同。\n\n\n由于答案可能很大，请输出答案对 ${10}^9+7$ 取模的余数。", "inputFormat": "输入包含若干行，这些行的内容共同构成一篇文章。\n\n文章以 `EOF`（文件结尾）结束。", "outputFormat": "输出仅包含一个整数，表示这篇文章中 `Hello World` 出现的次数。", "hint": "记 $n$ 为输入的文章的长度（字符数）。\n\n对于 $20\\%$ 的数据，$n \\le 20$。\n\n对于 $50\\%$ 的数据，$n \\le 500$。\n\n对于所有的数据，$15 \\le n \\le 500000$。", "locale": "zh-CN", "translations": {"en": {"title": "SAC#1 - Hello World (Enhanced Version)", "background": "One day, the silly pipapi was studying programming with a rather poor handout.", "description": "On one page of the handout, he saw an article. This article consists of English letters (both uppercase and lowercase), digits, and whitespace characters (tab/space/newline).\n\npipapi recalled the `Hello World` program he had just learned to write. He was very curious: in this article, how many times does `Hello World` occur as a subsequence? (**ignoring case and spaces**)\n\nTwo subsequences are the same if and only if the positions of every character are identical.\n\nSince the answer may be large, please output the answer modulo ${10}^9+7$.", "inputFormat": "The input contains several lines, which together form an article.\n\nThe article ends at `EOF` (end of file).", "outputFormat": "Output only a single integer, representing how many times `Hello World` appears in the article.", "hint": "Let $n$ be the length of the input article (number of characters).\n\nFor $20\\%$ of the testdata, $n \\le 20$.\n\nFor $50\\%$ of the testdata, $n \\le 500$.\n\nFor all the testdata, $15 \\le n \\le 500000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "SAC#1 - Hello World（升级版）", "background": "一天，智障的 pipapi 正在看某辣鸡讲义学程序设计。", "description": "在讲义的某一面，他看见了一篇文章。这篇文章由英文字母（大小写均有）、数字、和空白字符（制表/空格/回车）构成。\n\npipapi 想起了他最近刚刚学会写的 `Hello World` 程序。他非常好奇，这篇文章中，`Hello World` 作为子序列到底出现过多少次呢？（**忽略大小写和空格**）\n\n两个子序列相同当且仅当它们每一个字符所在的位置都相同。\n\n\n由于答案可能很大，请输出答案对 ${10}^9+7$ 取模的余数。", "inputFormat": "输入包含若干行，这些行的内容共同构成一篇文章。\n\n文章以 `EOF`（文件结尾）结束。", "outputFormat": "输出仅包含一个整数，表示这篇文章中 `Hello World` 出现的次数。", "hint": "记 $n$ 为输入的文章的长度（字符数）。\n\n对于 $20\\%$ 的数据，$n \\le 20$。\n\n对于 $50\\%$ 的数据，$n \\le 500$。\n\n对于所有的数据，$15 \\le n \\le 500000$。", "locale": "zh-CN"}}}
{"pid": "P2247", "type": "P", "difficulty": 5, "samples": [["4 4 2\n1 2\n2 3\n3 4\n4 1", "1 3"], ["4 6 2\n1 2\n2 3\n3 4\n4 1\n1 3\n2 4 ", "How oversuspicious you are, SOL!"], ["4 0 2", "Poor SOL!"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "洛谷原创", "Special Judge", "O2优化", "洛谷月赛"], "title": "SAC#1 - ACOJ云评测计划", "background": "本题由世界上最蒟蒻最辣鸡最撒比的 SOL 提供。\n\n寂月城网站是完美信息教室的官网。地址：http://191.101.11.174/mgzd 。", "description": "ACOJ 的服务器简直是差到了一个令人发指的地步。于是 SAC 的出题人，也就是傻逼 SOL，不得不强制要求每一个通过下载 ACOJ 软件包而搭建的分站，都为主站启动云端评测服务。\n\n云评测服务是由网络来连接的。这样的网络连接是双向的；但是由于地理位置等因素的限制，并不是任意两台服务器都可以直接相连。ACOJ 主站已经得到了可以直连的服务器的表，其中包含 $n$ 个分站（包括主站）以及它们的 $m$ 条连接情况，可以根据这个来分配各个分站的任务。\n\n有一些分站的服主是 SOL 的脑残粉。他们会无条件地将他们的服务器提供给 SOL。这些 ACOJ 分站称作“好站”。但是还有一些分站的服主是 SOL 黑。他们虽然拿到了 ACOJ 的服务端，但是并不愿意为 SOL 提供资源，于是利用黑科技关掉了云服务。也就是说，虽然主站仍然认为这些站点存在，但是它们不会起到任何作用——既不能传递通信，也不能进行评测。它们称作“坏站”。\n\n经过千辛万苦的调查，SOL 确定了 ACOJ 云评测系统中有最多 $k$ 个坏站存在，而且这 $k$ 个坏站似乎会使得 ACOJ 的云网络不再联通！大危机！\n\n但是 SOL 太弱智了，并不能确定是哪 $k$ 个。于是他请你来帮他找出任意一组可能会使得网络不再联通的 $k$ 个站点，以便加强防范。\n", "inputFormat": "输入包含 $m+1$ 行。\n\n第 $1$ 行 $3$ 个整数 $n,m,k$。\n\n接下来 $m$ 行，每行两个整数 $a,b$，表示标号为 $a$ 和 $b$ 的站点可以直接相连。", "outputFormat": "输出包含 $1$ 行。\n\n不超过 $k$ 个整数，表示能够将原图割开的任意一组节点组合。\n\n因为使用了 Special Judge，所以节点的顺序并不用担心。只需要满足能够割开原图即可。\n\n如果不存在这样的站点集合，输出 `How oversuspicious you are, SOL!`；如果网络不存在任何坏站时本来就无法连通，输出 `Poor SOL!`。", "hint": "对于 $20\\%$ 的数据，$n \\le 15$；\n\n对于另外 $20\\%$ 的数据，$n \\le 100$，$k=1$；\n\n对于另外 $20\\%$ 的数据，$n \\le 100$，$k=2$；\n\n对于 $100\\%$ 的数据，$3 \\le  n\\le 500$，$k \\le 3$，$2\\le n - k$，云网络不存在自环和重边。", "locale": "zh-CN", "translations": {"en": {"title": "SAC#1 - ACOJ Cloud Judging Plan", "background": "This problem is provided by SOL.\n\nThe Jiyue City website is the official site of the Perfect Information Classroom. Address: http://191.101.11.174/mgzd.", "description": "The ACOJ server is in a poor state. Therefore, the SAC problem setter SOL has to require every branch site that is set up by downloading the ACOJ software package to enable the cloud judging service for the main site.\n\nThe cloud judging service is connected via a network. The network is bidirectional; however, due to geographic and other constraints, not every pair of servers can be directly connected. The ACOJ main site has obtained the list of pairs that can be directly connected. It contains $n$ stations (including the main site) and their $m$ connections, based on which tasks can be assigned.\n\nSome station owners are SOL’s diehard fans and will unconditionally offer their servers to SOL. These ACOJ stations are called “good stations.” However, some station owners are SOL “haters.” Although they obtained the ACOJ server program, they do not want to provide resources to SOL and use tricks to turn off the cloud service. In other words, although the main site still regards these stations as present, they are useless — they can neither relay communication nor run judging. These are called “bad stations.”\n\nAfter thorough investigation, SOL determined that there are at most $k$ bad stations in the ACOJ cloud judging system, and these $k$ bad stations may make the ACOJ cloud network disconnected. Crisis!\n\nHowever, SOL cannot determine which $k$ stations they are. He asks you to find any set of stations, of size up to $k$, whose removal would make the network disconnected, so that precautionary measures can be taken.", "inputFormat": "The input contains $m + 1$ lines.\n\n- Line $1$: three integers $n, m, k$.\n- The next $m$ lines: each contains two integers $a, b$, meaning stations $a$ and $b$ can be directly connected.", "outputFormat": "The output contains $1$ line.\n\nOutput at most $k$ integers, representing any set of vertices whose removal disconnects the original graph.\n\nBecause a Special Judge is used, the order of the vertices does not matter. You only need to ensure that the original graph can be disconnected.\n\nIf no such set of stations exists, output `How oversuspicious you are, SOL!`. If the network is already disconnected even when there are no bad stations, output `Poor SOL!`.", "hint": "- For $20\\%$ of the testdata, $n \\le 15$.\n- For another $20\\%$ of the testdata, $n \\le 100$, $k = 1$.\n- For another $20\\%$ of the testdata, $n \\le 100$, $k = 2$.\n- For $100\\%$ of the testdata, $3 \\le n \\le 500$, $k \\le 3$, $2 \\le n - k$; the cloud network has no self-loops or multiple edges.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "SAC#1 - ACOJ云评测计划", "background": "本题由世界上最蒟蒻最辣鸡最撒比的 SOL 提供。\n\n寂月城网站是完美信息教室的官网。地址：http://191.101.11.174/mgzd 。", "description": "ACOJ 的服务器简直是差到了一个令人发指的地步。于是 SAC 的出题人，也就是傻逼 SOL，不得不强制要求每一个通过下载 ACOJ 软件包而搭建的分站，都为主站启动云端评测服务。\n\n云评测服务是由网络来连接的。这样的网络连接是双向的；但是由于地理位置等因素的限制，并不是任意两台服务器都可以直接相连。ACOJ 主站已经得到了可以直连的服务器的表，其中包含 $n$ 个分站（包括主站）以及它们的 $m$ 条连接情况，可以根据这个来分配各个分站的任务。\n\n有一些分站的服主是 SOL 的脑残粉。他们会无条件地将他们的服务器提供给 SOL。这些 ACOJ 分站称作“好站”。但是还有一些分站的服主是 SOL 黑。他们虽然拿到了 ACOJ 的服务端，但是并不愿意为 SOL 提供资源，于是利用黑科技关掉了云服务。也就是说，虽然主站仍然认为这些站点存在，但是它们不会起到任何作用——既不能传递通信，也不能进行评测。它们称作“坏站”。\n\n经过千辛万苦的调查，SOL 确定了 ACOJ 云评测系统中有最多 $k$ 个坏站存在，而且这 $k$ 个坏站似乎会使得 ACOJ 的云网络不再联通！大危机！\n\n但是 SOL 太弱智了，并不能确定是哪 $k$ 个。于是他请你来帮他找出任意一组可能会使得网络不再联通的 $k$ 个站点，以便加强防范。\n", "inputFormat": "输入包含 $m+1$ 行。\n\n第 $1$ 行 $3$ 个整数 $n,m,k$。\n\n接下来 $m$ 行，每行两个整数 $a,b$，表示标号为 $a$ 和 $b$ 的站点可以直接相连。", "outputFormat": "输出包含 $1$ 行。\n\n不超过 $k$ 个整数，表示能够将原图割开的任意一组节点组合。\n\n因为使用了 Special Judge，所以节点的顺序并不用担心。只需要满足能够割开原图即可。\n\n如果不存在这样的站点集合，输出 `How oversuspicious you are, SOL!`；如果网络不存在任何坏站时本来就无法连通，输出 `Poor SOL!`。", "hint": "对于 $20\\%$ 的数据，$n \\le 15$；\n\n对于另外 $20\\%$ 的数据，$n \\le 100$，$k=1$；\n\n对于另外 $20\\%$ 的数据，$n \\le 100$，$k=2$；\n\n对于 $100\\%$ 的数据，$3 \\le  n\\le 500$，$k \\le 3$，$2\\le n - k$，云网络不存在自环和重边。", "locale": "zh-CN"}}}
{"pid": "P2248", "type": "P", "difficulty": 6, "samples": [["5 2\n3 1\n2 3 12 14 16\n2 3\n3 1", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "洛谷原创", "O2优化", "洛谷月赛"], "title": "分段", "background": null, "description": "给你 $n$ 个数 $a_1 \\sim a_n$，要求将它们分成若干连续的段，其中有 $m$ 对给定的数不能被分到同一段。\n\n分出一个段的代价是：\n\n$$K + S \\times (P - Q)$$\n\n其中 $K$ 和 $S$ 均为给定的常数，$P$ 是该段中所有数的最大值，$Q$ 是该段中所有数的最小值。\n\n你需要求出每段代价之和最小的分段方案。", "inputFormat": "第一行两个正整数 $n,m$。\n\n第二行两个非负整数 $K,S$。\n\n第三行 $n$ 个非负整数 $a_1 \\sim a_n$。\n\n下面 $m$ 行，每行 $2$ 个正整数 $p_i,q_i$，表示 $a_{p_i},a_{q_i}$ 不能共存。", "outputFormat": "输出仅一行，表示最小的每段代价之和。", "hint": "对于 $10\\%$ 的数据，$n \\leq 10$。\n\n对于 $30\\%$ 的数据，$n \\leq 1500$。\n\n对于另外 $10\\%$ 的数据，$S = 0$。\n\n对于另外 $30\\%$ 的数据，$m = 0$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10^5$，$0 \\le m \\le 10^5$，$0 \\le K,S,a_i \\le 10^5$，$1 \\le p_i,q_i \\le n$，$p_i \\ne q_i$。", "locale": "zh-CN", "translations": {"en": {"title": "Segmentation", "background": null, "description": "You are given $n$ numbers $a_1 \\sim a_n$, and you need to partition them into several contiguous segments, with the constraint that there are $m$ specified pairs of numbers that cannot be placed in the same segment.\n\nThe cost of creating one segment is:\n$$K + S \\times (P - Q)$$\nwhere $K$ and $S$ are given constants, $P$ is the maximum value in that segment, and $Q$ is the minimum value in that segment.\n\nYou need to find a partitioning scheme that minimizes the sum of costs over all segments.", "inputFormat": "The first line contains two positive integers $n,m$.\n\nThe second line contains two non-negative integers $K,S$.\n\nThe third line contains $n$ non-negative integers $a_1 \\sim a_n$.\n\nEach of the next $m$ lines contains $2$ positive integers $p_i,q_i$, indicating that $a_{p_i},a_{q_i}$ cannot be in the same segment.", "outputFormat": "Output a single line containing the minimum possible sum of the costs over all segments.", "hint": "For $10\\%$ of the testdata, $n \\leq 10$.\n\nFor $30\\%$ of the testdata, $n \\leq 1500$.\n\nFor another $10\\%$ of the testdata, $S = 0$.\n\nFor another $30\\%$ of the testdata, $m = 0$.\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 10^5$, $0 \\le m \\le 10^5$, $0 \\le K,S,a_i \\le 10^5$, $1 \\le p_i,q_i \\le n$, $p_i \\ne q_i$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "分段", "background": null, "description": "给你 $n$ 个数 $a_1 \\sim a_n$，要求将它们分成若干连续的段，其中有 $m$ 对给定的数不能被分到同一段。\n\n分出一个段的代价是：\n\n$$K + S \\times (P - Q)$$\n\n其中 $K$ 和 $S$ 均为给定的常数，$P$ 是该段中所有数的最大值，$Q$ 是该段中所有数的最小值。\n\n你需要求出每段代价之和最小的分段方案。", "inputFormat": "第一行两个正整数 $n,m$。\n\n第二行两个非负整数 $K,S$。\n\n第三行 $n$ 个非负整数 $a_1 \\sim a_n$。\n\n下面 $m$ 行，每行 $2$ 个正整数 $p_i,q_i$，表示 $a_{p_i},a_{q_i}$ 不能共存。", "outputFormat": "输出仅一行，表示最小的每段代价之和。", "hint": "对于 $10\\%$ 的数据，$n \\leq 10$。\n\n对于 $30\\%$ 的数据，$n \\leq 1500$。\n\n对于另外 $10\\%$ 的数据，$S = 0$。\n\n对于另外 $30\\%$ 的数据，$m = 0$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10^5$，$0 \\le m \\le 10^5$，$0 \\le K,S,a_i \\le 10^5$，$1 \\le p_i,q_i \\le n$，$p_i \\ne q_i$。", "locale": "zh-CN"}}}
