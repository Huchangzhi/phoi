{"pid": "P13075", "type": "P", "difficulty": 0, "samples": [["6 3\n1 3 2 4 1 2\n2 3 4", "5\n9\n21"], ["6 3\n2 2 5 2 2 2\n1 2 10", "0\n9\n21"], ["2 1\n1 2\n1000000", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "NOISG（新加坡）"], "title": "[NOISG 2019] Pilot", "background": "小猫 Rar 终于实现了自己童年的梦想，成为了一名飞行员，想带他的朋友 Dinosaur 进行几次观光飞行。Rar 生活在一个线性的世界中，这个世界可以描述为一列 $N$ 个整数，第 $i$ 个整数 $H_i$ 表示从世界最左端起第 $i$ 座山的高度。", "description": "Rar 有 $Q$ 架飞机，第 $i$ 架飞机的最大巡航高度为 $Y_i$ 米。每次飞行从第 $s$ 座山起飞，到第 $e$ 座山降落，保证 $s \\leq e$，即 Rar 总是朝右飞行。\n\n由于飞机有最大巡航高度，Rar 无法飞越、起飞或降落在高度大于巡航高度的山上。也就是说，若使用第 $j$ 架飞机，Rar 只能在满足 $H_i \\leq Y_j$ 的山上飞行。\n\n对于第 $i$ 架飞机，请你帮助 Rar 计算，他一共可以进行多少次不同的飞行。也就是说，求有多少对 $s,e$ 满足：\n\n- $1 \\leq s \\leq e \\leq N$；\n- $s$ 到 $e$ 之间所有山的高度均不超过该飞机的最大巡航高度。", "inputFormat": "第一行包含两个整数 $N$ 和 $Q$。\n\n第二行包含 $N$ 个整数 $H_1, H_2, \\dots, H_N$。\n\n第三行包含 $Q$ 个整数 $Y_1, Y_2, \\dots, Y_Q$。\n", "outputFormat": "输出 $Q$ 行，第 $i$ 行输出一个整数，表示使用第 $i$ 架飞机时，Rar 可以进行的不同飞行次数。\n", "hint": "【样例解释】\n\n对于样例 1：\n\n对于第一架飞机，$5$ 次飞行分别是：$(1,1)$、$(3,3)$、$(5,5)$、$(5,6)$、$(6,6)$。\n\n对于第二架飞机，$9$ 次飞行分别是：$(1,1)$、$(1,2)$、$(1,3)$、$(2,2)$、$(2,3)$、$(3,3)$、$(5,5)$、$(5,6)$、$(6,6)$。\n\n对于第三架飞机，所有 $21$ 种飞行均可进行。\n\n【数据范围】\n\n- $1 \\leq N, Q, H_i, Y_i \\leq 10^6$\n\n| 子任务编号 | 分值 | 额外限制 |\n| :---: | :---: | :---: |\n| $1$ | $3$ | $N = 2,\\ Q = 1$ |\n| $2$ | $10$ | $1 \\leq N, Q \\leq 30$ |\n| $3$ | $12$ | $1 \\leq N, Q \\leq 200$ |\n| $4$ | $15$ | $1 \\leq N, Q \\leq 10^3$ |\n| $5$ | $5$ | $1 \\leq N \\leq 10^5,\\ Q = 1,\\ Y_i = 10^6$ |\n| $6$ | $9$ | $1 \\leq N, Q \\leq 10^5,\\ H_i = i$ |\n| $7$ | $14$ | $1 \\leq N, Q \\leq 10^5,\\ H$ 严格递增 |\n| $8$ | $10$ | $1 \\leq N \\leq 10^5,\\ Q = 1$ |\n| $9$ | $11$ | $1 \\leq N, Q \\leq 10^5$ |\n| $10$ | $11$ | 无额外限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2019] Pilot", "background": "小猫 Rar 终于实现了自己童年的梦想，成为了一名飞行员，想带他的朋友 Dinosaur 进行几次观光飞行。Rar 生活在一个线性的世界中，这个世界可以描述为一列 $N$ 个整数，第 $i$ 个整数 $H_i$ 表示从世界最左端起第 $i$ 座山的高度。", "description": "Rar 有 $Q$ 架飞机，第 $i$ 架飞机的最大巡航高度为 $Y_i$ 米。每次飞行从第 $s$ 座山起飞，到第 $e$ 座山降落，保证 $s \\leq e$，即 Rar 总是朝右飞行。\n\n由于飞机有最大巡航高度，Rar 无法飞越、起飞或降落在高度大于巡航高度的山上。也就是说，若使用第 $j$ 架飞机，Rar 只能在满足 $H_i \\leq Y_j$ 的山上飞行。\n\n对于第 $i$ 架飞机，请你帮助 Rar 计算，他一共可以进行多少次不同的飞行。也就是说，求有多少对 $s,e$ 满足：\n\n- $1 \\leq s \\leq e \\leq N$；\n- $s$ 到 $e$ 之间所有山的高度均不超过该飞机的最大巡航高度。", "inputFormat": "第一行包含两个整数 $N$ 和 $Q$。\n\n第二行包含 $N$ 个整数 $H_1, H_2, \\dots, H_N$。\n\n第三行包含 $Q$ 个整数 $Y_1, Y_2, \\dots, Y_Q$。\n", "outputFormat": "输出 $Q$ 行，第 $i$ 行输出一个整数，表示使用第 $i$ 架飞机时，Rar 可以进行的不同飞行次数。\n", "hint": "【样例解释】\n\n对于样例 1：\n\n对于第一架飞机，$5$ 次飞行分别是：$(1,1)$、$(3,3)$、$(5,5)$、$(5,6)$、$(6,6)$。\n\n对于第二架飞机，$9$ 次飞行分别是：$(1,1)$、$(1,2)$、$(1,3)$、$(2,2)$、$(2,3)$、$(3,3)$、$(5,5)$、$(5,6)$、$(6,6)$。\n\n对于第三架飞机，所有 $21$ 种飞行均可进行。\n\n【数据范围】\n\n- $1 \\leq N, Q, H_i, Y_i \\leq 10^6$\n\n| 子任务编号 | 分值 | 额外限制 |\n| :---: | :---: | :---: |\n| $1$ | $3$ | $N = 2,\\ Q = 1$ |\n| $2$ | $10$ | $1 \\leq N, Q \\leq 30$ |\n| $3$ | $12$ | $1 \\leq N, Q \\leq 200$ |\n| $4$ | $15$ | $1 \\leq N, Q \\leq 10^3$ |\n| $5$ | $5$ | $1 \\leq N \\leq 10^5,\\ Q = 1,\\ Y_i = 10^6$ |\n| $6$ | $9$ | $1 \\leq N, Q \\leq 10^5,\\ H_i = i$ |\n| $7$ | $14$ | $1 \\leq N, Q \\leq 10^5,\\ H$ 严格递增 |\n| $8$ | $10$ | $1 \\leq N \\leq 10^5,\\ Q = 1$ |\n| $9$ | $11$ | $1 \\leq N, Q \\leq 10^5$ |\n| $10$ | $11$ | 无额外限制 |", "locale": "zh-CN"}}}
{"pid": "P13076", "type": "P", "difficulty": 0, "samples": [["11 3\n2 2 3\n1 7\n2 4 1", "3"], ["10 3\n3 1 5 1\n4 2 2 3 1\n3 1 6 2", "6"], ["10 1\n1 4", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "NOISG（新加坡）"], "title": "[NOISG 2019] Lasers", "background": "熊猫先生知道小猫非常喜欢激光玩具，于是他决定给 Rar the Cat 买一个激光玩具。", "description": "这个激光玩具的顶部有 $L$ 个间距均匀的激光，全部朝下。第 $1$ 个激光距离左边缘 $0.5$ 个单位，第 $L$ 个激光距离右边缘 $0.5$ 个单位，相邻激光之间距离为 $1$ 个单位。\n\n该玩具共有 $R$ 排滑动的挡板，每排有若干不重叠的挡板。具体来说：\n\n- 每排有若干长度为正整数的挡板，总长度不超过 $L$。\n- 同一排内，所有挡板可以整体平移，但挡板之间相对位置不变，且不会重叠。\n- 一个宽度为 $x$ 的挡板可以完全阻挡连续 $x$ 个激光。\n\n请你计算，在所有挡板可能的配置中，有多少个激光会始终被至少一个挡板阻挡。", "inputFormat": "第一行包含两个整数 $L$ 和 $R$。\n\n接下来 $R$ 行描述每排的挡板情况，每行格式如下：\n\n- 一个整数 $X$，表示该排有 $X$ 个挡板。\n- 接下来 $X$ 个整数，依次表示每个挡板的宽度，第一个整数是最左边挡板的宽度。\n\n保证每排所有挡板的总宽度不超过 $L$。", "outputFormat": "输出一个整数，表示始终被至少一个挡板阻挡的激光数量。", "hint": "【样例解释】\n\n对于样例 1：\n\n第 $2$ 排有一个宽度为 $7$ 的挡板，它无论怎么移动，第 $5$、$6$、$7$ 号激光总会被阻挡。\n\n对于样例 2：\n\n第 $3$、$4$、$5$、$6$、$7$、$9$ 号激光始终被至少一个挡板阻挡。\n\n对于样例 3：\n\n所有激光在至少一种挡板配置下都可以通过。\n\n【数据范围】\n\n- $1 \\leq R \\leq 5 \\times 10^5$\n- $1 \\leq L \\leq 10^9$\n- $1 \\leq \\sum X \\leq 5 \\times 10^5$\n- 每排所有挡板宽度和不超过 $L$\n\n| 子任务编号 | 分值 | 额外限制 |\n| :---: | :---: | :---: |\n| $1$ | $10$ | $R = 1,\\ X = 1$ |\n| $2$ | $14$ | $X = 1$ |\n| $3$ | $20$ | $R = 2,\\ 1 \\leq L \\leq 10^6$ |\n| $4$ | $21$ | $1 \\leq L \\leq 10^3,\\ 1 \\leq \\sum X \\leq 10^3$ |\n| $5$ | $22$ | $1 \\leq L \\leq 10^6$ |\n| $6$ | $13$ | 无额外限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2019] Lasers", "background": "熊猫先生知道小猫非常喜欢激光玩具，于是他决定给 Rar the Cat 买一个激光玩具。", "description": "这个激光玩具的顶部有 $L$ 个间距均匀的激光，全部朝下。第 $1$ 个激光距离左边缘 $0.5$ 个单位，第 $L$ 个激光距离右边缘 $0.5$ 个单位，相邻激光之间距离为 $1$ 个单位。\n\n该玩具共有 $R$ 排滑动的挡板，每排有若干不重叠的挡板。具体来说：\n\n- 每排有若干长度为正整数的挡板，总长度不超过 $L$。\n- 同一排内，所有挡板可以整体平移，但挡板之间相对位置不变，且不会重叠。\n- 一个宽度为 $x$ 的挡板可以完全阻挡连续 $x$ 个激光。\n\n请你计算，在所有挡板可能的配置中，有多少个激光会始终被至少一个挡板阻挡。", "inputFormat": "第一行包含两个整数 $L$ 和 $R$。\n\n接下来 $R$ 行描述每排的挡板情况，每行格式如下：\n\n- 一个整数 $X$，表示该排有 $X$ 个挡板。\n- 接下来 $X$ 个整数，依次表示每个挡板的宽度，第一个整数是最左边挡板的宽度。\n\n保证每排所有挡板的总宽度不超过 $L$。", "outputFormat": "输出一个整数，表示始终被至少一个挡板阻挡的激光数量。", "hint": "【样例解释】\n\n对于样例 1：\n\n第 $2$ 排有一个宽度为 $7$ 的挡板，它无论怎么移动，第 $5$、$6$、$7$ 号激光总会被阻挡。\n\n对于样例 2：\n\n第 $3$、$4$、$5$、$6$、$7$、$9$ 号激光始终被至少一个挡板阻挡。\n\n对于样例 3：\n\n所有激光在至少一种挡板配置下都可以通过。\n\n【数据范围】\n\n- $1 \\leq R \\leq 5 \\times 10^5$\n- $1 \\leq L \\leq 10^9$\n- $1 \\leq \\sum X \\leq 5 \\times 10^5$\n- 每排所有挡板宽度和不超过 $L$\n\n| 子任务编号 | 分值 | 额外限制 |\n| :---: | :---: | :---: |\n| $1$ | $10$ | $R = 1,\\ X = 1$ |\n| $2$ | $14$ | $X = 1$ |\n| $3$ | $20$ | $R = 2,\\ 1 \\leq L \\leq 10^6$ |\n| $4$ | $21$ | $1 \\leq L \\leq 10^3,\\ 1 \\leq \\sum X \\leq 10^3$ |\n| $5$ | $22$ | $1 \\leq L \\leq 10^6$ |\n| $6$ | $13$ | 无额外限制 |", "locale": "zh-CN"}}}
{"pid": "P13077", "type": "P", "difficulty": 5, "samples": [["6 1\n1 -2 3 -1 5 -6", "7"], ["6 2\n1 2 3 -10 5 6", "17"], ["6 4\n-1 -2 -1 0 -5 -1", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "2019", "线段树", "NOISG（新加坡）"], "title": "[NOISG 2019] Feast", "background": "", "description": "Gug 正在为他的朋友们准备一场盛宴。盛宴由 $N$ 盘食物组成，按顺序排列，第 $i$ 盘食物若被食用，可带来 $A_i$ 点满足感。部分食物可能已经腐烂，因此 $A_i$ 可能为负数。\n\n共有 $K$ 个人参加盛宴，每人将被分配一段连续的食物区间食用。该区间可以为空，且不同人的区间不得重叠，每盘食物最多只能被食用一次。\n\nGug 希望合理分配食物，使得所有被食用的食物带来的满足感总和最大。\n\n请你计算，最大满足感总和是多少。", "inputFormat": "第一行包含两个整数 $N$ 和 $K$。\n\n第二行包含 $N$ 个整数 $A_1, A_2, \\dots, A_N$。\n", "outputFormat": "输出一个整数，表示最大满足感总和。", "hint": "【样例解释】\n\n对于样例 1：\n\n将唯一一人分配到区间 $[3,-1,5]$，满足感总和为 $7$。\n\n对于样例 2：\n\n选择连续区间 $[1,2,3]$ 和 $[5,6]$，总和最大。\n\n对于样例 3：\n\n所有满足感均不为正，最优选择是所有人都选择空区间，总和为 $0$。\n\n【数据范围】\n\n- $1 \\leq K \\leq N \\leq 3 \\times 10^5$\n- $0 \\leq |A_i| \\leq 10^9$\n\n| 子任务编号 | 分值 | 额外限制 |\n| :---: | :---: | :---: |\n| $1$ | $4$ | $A_i \\geq 0$ |\n| $2$ | $8$ | 至多有一个位置 $A_i < 0$ |\n| $3$ | $18$ | $K = 1$ |\n| $4$ | $10$ | $1 \\leq K \\leq N \\leq 80$ |\n| $5$ | $11$ | $1 \\leq K \\leq N \\leq 300$ |\n| $6$ | $20$ | $1 \\leq K \\leq N \\leq 2000$ |\n| $7$ | $29$ | 无额外限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2019] Feast", "background": "", "description": "Gug 正在为他的朋友们准备一场盛宴。盛宴由 $N$ 盘食物组成，按顺序排列，第 $i$ 盘食物若被食用，可带来 $A_i$ 点满足感。部分食物可能已经腐烂，因此 $A_i$ 可能为负数。\n\n共有 $K$ 个人参加盛宴，每人将被分配一段连续的食物区间食用。该区间可以为空，且不同人的区间不得重叠，每盘食物最多只能被食用一次。\n\nGug 希望合理分配食物，使得所有被食用的食物带来的满足感总和最大。\n\n请你计算，最大满足感总和是多少。", "inputFormat": "第一行包含两个整数 $N$ 和 $K$。\n\n第二行包含 $N$ 个整数 $A_1, A_2, \\dots, A_N$。\n", "outputFormat": "输出一个整数，表示最大满足感总和。", "hint": "【样例解释】\n\n对于样例 1：\n\n将唯一一人分配到区间 $[3,-1,5]$，满足感总和为 $7$。\n\n对于样例 2：\n\n选择连续区间 $[1,2,3]$ 和 $[5,6]$，总和最大。\n\n对于样例 3：\n\n所有满足感均不为正，最优选择是所有人都选择空区间，总和为 $0$。\n\n【数据范围】\n\n- $1 \\leq K \\leq N \\leq 3 \\times 10^5$\n- $0 \\leq |A_i| \\leq 10^9$\n\n| 子任务编号 | 分值 | 额外限制 |\n| :---: | :---: | :---: |\n| $1$ | $4$ | $A_i \\geq 0$ |\n| $2$ | $8$ | 至多有一个位置 $A_i < 0$ |\n| $3$ | $18$ | $K = 1$ |\n| $4$ | $10$ | $1 \\leq K \\leq N \\leq 80$ |\n| $5$ | $11$ | $1 \\leq K \\leq N \\leq 300$ |\n| $6$ | $20$ | $1 \\leq K \\leq N \\leq 2000$ |\n| $7$ | $29$ | 无额外限制 |", "locale": "zh-CN"}}}
{"pid": "P13078", "type": "P", "difficulty": 6, "samples": [["4 5\n3 4\n1 2\n2 3\n1 3\n1 4\n2 4 5", "3 4 5 1 2"], ["4 4\n1 2\n1 4\n2 3\n3 4\n1 3 4", "1 4 2 3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "并查集", "NOISG（新加坡）"], "title": "[NOISG 2019] Rigged Roads", "background": "Silvermill 最近财政紧张，市长 Peanut 打算拆除部分道路以节省养护成本。", "description": "Silvermill 可以看作一个城市，包含 $N$ 个道路交汇点和 $E$ 条道路，第 $i$ 条道路连接交汇点 $A_i$ 和 $B_i$。交汇点编号为 $1$ 到 $N$，道路编号为 $1$ 到 $E$。保证任意两个交汇点之间总可以直接或间接到达，且没有两条道路连接同一对交汇点。\n\n为了方便决策，Peanut 请你帮忙评估各条道路的养护成本。你的任务是：\n\n你需要给出一个长度为 $E$ 的排列 $W = (W_1, W_2, \\dots, W_E)$，表示第 $i$ 条道路的养护成本为 $W_i$，其中 $W$ 是 $1$ 到 $E$ 的一个排列。\n\nPeanut 会根据你提供的养护成本，保留一组道路，满足：\n\n- 所有交汇点仍然连通；\n- 保留道路的养护成本之和最小。\n\n即，Peanut 实际上会选择最小生成树，且由于所有成本互不相同，最小生成树唯一。\n\n但你另有所图。你想让最终被保留的道路集合恰好是你指定的一组道路 $R$，且 $R$ 恰好构成一棵生成树。通过合理选择 $W$，你可以让 $R$ 恰好成为最小生成树。\n\n请你计算，满足上述条件的字典序最小的排列 $W$。\n\n给定城市结构和你想保留的道路集合 $R$，请输出字典序最小的养护成本分配方案 $W$，使得 $R$ 成为唯一的最小生成树。\n\n注：若存在第 $1 \\leq p \\leq E$ 使得 $W_p < W'_p$，且 $W_1 = W'_1, \\dots, W_{p-1} = W'_{p-1}$，则 $W$ 的字典序小于 $W'$。", "inputFormat": "第一行包含两个整数 $N$ 和 $E$。\n\n接下来 $E$ 行，每行两个整数 $A_i$ 和 $B_i$，表示第 $i$ 条道路连接的两个交汇点。\n\n最后一行包含 $N - 1$ 个整数，表示你想保留的道路编号，构成的集合 $R$。", "outputFormat": "输出 $E$ 个整数，表示字典序最小的排列 $W$，第 $i$ 个数是第 $i$ 条道路的养护成本。", "hint": "【数据范围】\n\n- $1 \\leq N, E \\leq 3 \\times 10^5$\n- $1 \\leq A_i \\neq B_i \\leq N$\n- $1 \\leq R_i \\leq E$\n- 仅使用 $R$ 中的道路也能保证所有交汇点连通。\n\n| 子任务编号 | 分值 | 额外限制 |\n| :---: | :---: | :---: |\n| $1$ | $8$ | $1 \\leq N, E \\leq 9$ |\n| $2$ | $19$ | $1 \\leq N, E \\leq 10^3$ |\n| $3$ | $9$ | $A_{R_i} = 1,\\ B_{R_i} = i + 1$，即 $R$ 构成一棵星形树 |\n| $4$ | $10$ | $A_{R_i} = i,\\ B_{R_i} = i + 1$，即 $R$ 构成一条链 |\n| $5$ | $10$ | $E = N,\\ A_i = i,\\ B_i = i \\bmod N + 1$ |\n| $6$ | $12$ | $E = N$ |\n| $7$ | $32$ | 无额外限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2019] Rigged Roads", "background": "Silvermill 最近财政紧张，市长 Peanut 打算拆除部分道路以节省养护成本。", "description": "Silvermill 可以看作一个城市，包含 $N$ 个道路交汇点和 $E$ 条道路，第 $i$ 条道路连接交汇点 $A_i$ 和 $B_i$。交汇点编号为 $1$ 到 $N$，道路编号为 $1$ 到 $E$。保证任意两个交汇点之间总可以直接或间接到达，且没有两条道路连接同一对交汇点。\n\n为了方便决策，Peanut 请你帮忙评估各条道路的养护成本。你的任务是：\n\n你需要给出一个长度为 $E$ 的排列 $W = (W_1, W_2, \\dots, W_E)$，表示第 $i$ 条道路的养护成本为 $W_i$，其中 $W$ 是 $1$ 到 $E$ 的一个排列。\n\nPeanut 会根据你提供的养护成本，保留一组道路，满足：\n\n- 所有交汇点仍然连通；\n- 保留道路的养护成本之和最小。\n\n即，Peanut 实际上会选择最小生成树，且由于所有成本互不相同，最小生成树唯一。\n\n但你另有所图。你想让最终被保留的道路集合恰好是你指定的一组道路 $R$，且 $R$ 恰好构成一棵生成树。通过合理选择 $W$，你可以让 $R$ 恰好成为最小生成树。\n\n请你计算，满足上述条件的字典序最小的排列 $W$。\n\n给定城市结构和你想保留的道路集合 $R$，请输出字典序最小的养护成本分配方案 $W$，使得 $R$ 成为唯一的最小生成树。\n\n注：若存在第 $1 \\leq p \\leq E$ 使得 $W_p < W'_p$，且 $W_1 = W'_1, \\dots, W_{p-1} = W'_{p-1}$，则 $W$ 的字典序小于 $W'$。", "inputFormat": "第一行包含两个整数 $N$ 和 $E$。\n\n接下来 $E$ 行，每行两个整数 $A_i$ 和 $B_i$，表示第 $i$ 条道路连接的两个交汇点。\n\n最后一行包含 $N - 1$ 个整数，表示你想保留的道路编号，构成的集合 $R$。", "outputFormat": "输出 $E$ 个整数，表示字典序最小的排列 $W$，第 $i$ 个数是第 $i$ 条道路的养护成本。", "hint": "【数据范围】\n\n- $1 \\leq N, E \\leq 3 \\times 10^5$\n- $1 \\leq A_i \\neq B_i \\leq N$\n- $1 \\leq R_i \\leq E$\n- 仅使用 $R$ 中的道路也能保证所有交汇点连通。\n\n| 子任务编号 | 分值 | 额外限制 |\n| :---: | :---: | :---: |\n| $1$ | $8$ | $1 \\leq N, E \\leq 9$ |\n| $2$ | $19$ | $1 \\leq N, E \\leq 10^3$ |\n| $3$ | $9$ | $A_{R_i} = 1,\\ B_{R_i} = i + 1$，即 $R$ 构成一棵星形树 |\n| $4$ | $10$ | $A_{R_i} = i,\\ B_{R_i} = i + 1$，即 $R$ 构成一条链 |\n| $5$ | $10$ | $E = N,\\ A_i = i,\\ B_i = i \\bmod N + 1$ |\n| $6$ | $12$ | $E = N$ |\n| $7$ | $32$ | 无额外限制 |", "locale": "zh-CN"}}}
{"pid": "P13079", "type": "P", "difficulty": 0, "samples": [["6 3 2 100 2", "3 4 1 5 2 6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "交互题", "NOISG（新加坡）"], "title": "[NOISG 2019] Shuffle【交互题待配置】", "background": "", "description": "Lim Li 非常喜欢动漫，最近她在 Amazon 购买了一整季的《干物妹小埋》。这季共有 $N$ 集，每集刻录在一张光盘上，光盘编号为 $1$ 到 $N$，每集的集数也是 $1$ 到 $N$。\n\n然而，Lim Li 发现由于生产问题，光盘编号与剧集集数不对应！Amazon 告诉她，剧集只是被打乱顺序，所有剧集都在，没有缺失。\n\n为了避免剧透，Lim Li 不愿自己播放光盘来确认剧集顺序。于是她决定请朋友 Rar the Cat 帮忙。具体流程如下：\n\n- Lim Li 将 $N$ 张光盘分为 $B$ 个盒子，每个盒子装 $K$ 张光盘（$N = B \\times K$）。\n- 这些盒子寄给 Rar。在运输过程中，盒子之间的顺序和每个盒子内部光盘的顺序可能会被打乱。\n- Rar 接收到盒子后，会播放每张光盘，并记录下盒子内各张光盘对应的剧集集数，然后将每个盒子的结果分别写在 $B$ 张纸上寄回给 Lim Li。\n- 所有光盘最终被寄回给 Lim Li。\n\n整个过程最多允许进行 $Q$ 次。Rar 如果不耐烦就不再帮忙。\n\n你的任务是，帮助 Lim Li 在尽量少的查询次数内，确定每张光盘上的剧集集数。\n\n本题为交互题，请实现以下函数：\n\n- C++: `vector<int> solve(int N, int B, int K, int Q, int ST)`\n- ~~Java: `public int[] solve(int N, int B, int K, int Q, int ST)`~~\n\n你可以调用如下交互函数：\n\n- C++: `vector<vector<int>> shuffle(vector<vector<int>> boxes)`\n- ~~Java: `public static int[][] shuffle(int[][] boxes)`~~\n\n参数 `boxes` 是 $B$ 个数组，每个数组包含 $K$ 个整数，表示 Lim Li 寄出的光盘编号分组。\n\n返回值为 $B$ 个数组，每个数组 $K$ 个整数，表示收到盒子后，每张光盘的剧集集数。\n\n注意：\n\n- `boxes` 传入参数不会被修改。\n- 超过 $Q$ 次调用或参数非法，判定为 Wrong Answer。", "inputFormat": "所有必要信息通过函数参数提供。", "outputFormat": "程序通过返回值完成答案，无需额外输出。", "hint": "【样例解释】\n\n假设 $N = 6$，$B = 3$，$K = 2$，$Q = 100$，剧集顺序为 $[3, 1, 4, 5, 2, 6]$。\n\n调用 `solve(6, 3, 2, 100, 2)`。\n\n一次可能的交互：\n\n- 调用 `shuffle([[1, 2], [3, 4], [5, 6]])`，返回 `[[6, 2], [5, 4], [3, 1]]`。\n- 调用 `shuffle([[2, 6], [3, 1], [5, 4]])`，返回 `[[6, 1], [2, 5], [4, 3]]`。\n- 调用 `shuffle([[6, 5], [4, 2], [3, 1]])`，返回 `[[5, 1], [3, 4], [2, 6]]`。\n\n最终确定顺序为 $[3, 4, 1, 5, 2, 6]$，输出该数组即为正确答案。\n\n【数据范围】\n\n- $B, K \\geq 2$\n- $N \\geq 6$\n- $N = B \\times K$\n\n| 子任务编号 | 分值 | 额外限制 |\n| :---: | :---: | :---: |\n| $1$ | $2$ | $N = 6,\\ B = 2,\\ K = 3,\\ Q = 100$ |\n| $2$ | $3$ | $N = 6,\\ B = 3,\\ K = 2,\\ Q = 100$ |\n| $3$ | $12$ | $N \\leq 1000,\\ Q = 12$，盒子顺序保持不变 |\n| $4$ | $16$ | $N \\leq 1000,\\ K = 2,\\ Q = 4$ |\n| $5$ | $15$ | $N \\leq 1000,\\ B = 2,\\ Q = 12$ |\n| $6$ | $52$ | $N \\leq 1000,\\ Q = 2000,\\ B,K > 2$，具体见评分规则 |\n\n【评分规则】\n\n对于子任务 6，根据查询次数 $q$ 计分：\n\n- $q > 2000$，得 $0$ 分；\n- $500 < q \\leq 2000$，得 $8$ 分；\n- $50 < q \\leq 500$，得 $17$ 分；\n- $9 < q \\leq 50$，得 $22 + 30 \\times \\left(\\dfrac{50 - q}{41}\\right)^2$ 分；\n- $q \\leq 9$，得 $52$ 分。\n\n【测试说明】\n\n官方提供裁判程序、头文件、模板与样例测试数据。请严格使用官方提供的测试脚本。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2019] Shuffle【交互题待配置】", "background": "", "description": "Lim Li 非常喜欢动漫，最近她在 Amazon 购买了一整季的《干物妹小埋》。这季共有 $N$ 集，每集刻录在一张光盘上，光盘编号为 $1$ 到 $N$，每集的集数也是 $1$ 到 $N$。\n\n然而，Lim Li 发现由于生产问题，光盘编号与剧集集数不对应！Amazon 告诉她，剧集只是被打乱顺序，所有剧集都在，没有缺失。\n\n为了避免剧透，Lim Li 不愿自己播放光盘来确认剧集顺序。于是她决定请朋友 Rar the Cat 帮忙。具体流程如下：\n\n- Lim Li 将 $N$ 张光盘分为 $B$ 个盒子，每个盒子装 $K$ 张光盘（$N = B \\times K$）。\n- 这些盒子寄给 Rar。在运输过程中，盒子之间的顺序和每个盒子内部光盘的顺序可能会被打乱。\n- Rar 接收到盒子后，会播放每张光盘，并记录下盒子内各张光盘对应的剧集集数，然后将每个盒子的结果分别写在 $B$ 张纸上寄回给 Lim Li。\n- 所有光盘最终被寄回给 Lim Li。\n\n整个过程最多允许进行 $Q$ 次。Rar 如果不耐烦就不再帮忙。\n\n你的任务是，帮助 Lim Li 在尽量少的查询次数内，确定每张光盘上的剧集集数。\n\n本题为交互题，请实现以下函数：\n\n- C++: `vector<int> solve(int N, int B, int K, int Q, int ST)`\n- ~~Java: `public int[] solve(int N, int B, int K, int Q, int ST)`~~\n\n你可以调用如下交互函数：\n\n- C++: `vector<vector<int>> shuffle(vector<vector<int>> boxes)`\n- ~~Java: `public static int[][] shuffle(int[][] boxes)`~~\n\n参数 `boxes` 是 $B$ 个数组，每个数组包含 $K$ 个整数，表示 Lim Li 寄出的光盘编号分组。\n\n返回值为 $B$ 个数组，每个数组 $K$ 个整数，表示收到盒子后，每张光盘的剧集集数。\n\n注意：\n\n- `boxes` 传入参数不会被修改。\n- 超过 $Q$ 次调用或参数非法，判定为 Wrong Answer。", "inputFormat": "所有必要信息通过函数参数提供。", "outputFormat": "程序通过返回值完成答案，无需额外输出。", "hint": "【样例解释】\n\n假设 $N = 6$，$B = 3$，$K = 2$，$Q = 100$，剧集顺序为 $[3, 1, 4, 5, 2, 6]$。\n\n调用 `solve(6, 3, 2, 100, 2)`。\n\n一次可能的交互：\n\n- 调用 `shuffle([[1, 2], [3, 4], [5, 6]])`，返回 `[[6, 2], [5, 4], [3, 1]]`。\n- 调用 `shuffle([[2, 6], [3, 1], [5, 4]])`，返回 `[[6, 1], [2, 5], [4, 3]]`。\n- 调用 `shuffle([[6, 5], [4, 2], [3, 1]])`，返回 `[[5, 1], [3, 4], [2, 6]]`。\n\n最终确定顺序为 $[3, 4, 1, 5, 2, 6]$，输出该数组即为正确答案。\n\n【数据范围】\n\n- $B, K \\geq 2$\n- $N \\geq 6$\n- $N = B \\times K$\n\n| 子任务编号 | 分值 | 额外限制 |\n| :---: | :---: | :---: |\n| $1$ | $2$ | $N = 6,\\ B = 2,\\ K = 3,\\ Q = 100$ |\n| $2$ | $3$ | $N = 6,\\ B = 3,\\ K = 2,\\ Q = 100$ |\n| $3$ | $12$ | $N \\leq 1000,\\ Q = 12$，盒子顺序保持不变 |\n| $4$ | $16$ | $N \\leq 1000,\\ K = 2,\\ Q = 4$ |\n| $5$ | $15$ | $N \\leq 1000,\\ B = 2,\\ Q = 12$ |\n| $6$ | $52$ | $N \\leq 1000,\\ Q = 2000,\\ B,K > 2$，具体见评分规则 |\n\n【评分规则】\n\n对于子任务 6，根据查询次数 $q$ 计分：\n\n- $q > 2000$，得 $0$ 分；\n- $500 < q \\leq 2000$，得 $8$ 分；\n- $50 < q \\leq 500$，得 $17$ 分；\n- $9 < q \\leq 50$，得 $22 + 30 \\times \\left(\\dfrac{50 - q}{41}\\right)^2$ 分；\n- $q \\leq 9$，得 $52$ 分。\n\n【测试说明】\n\n官方提供裁判程序、头文件、模板与样例测试数据。请严格使用官方提供的测试脚本。", "locale": "zh-CN"}}}
{"pid": "P13080", "type": "P", "difficulty": 2, "samples": [["2\n1 0\n4 0", "3 0"], ["6\n1 0\n3 0\n5 0\n7 0\n9 0\n11 0\n", "7 0"], ["9\n1 16\n3 12\n5 6\n7 10\n9 8\n11 4\n13 14\n15 2\n17 18\n", "9 10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2017", "Special Judge", "排序", "NOISG（新加坡）"], "title": "[NOISG 2017] Best Places / 最佳选址", "background": "译自 [NOISG 2017 A.Best Places](https://github.com/noisg/sg_noi_archive/tree/master/2017/bestplace)。", "description": "IOI 2020 将在新加坡举行！举办这样的国际赛事，选择举办地自然成了十分重要的事。\n\n现在，组委会拿到了一份选手住址名单，共有 $N$ 位选手，他们所在的城市可以看作一个坐标系，第 $i$ 位选手住在 $(X_i,Y_i)$。\n\n为了选手们方便参加比赛，组委会想要选择一个点 $(X,Y)$，使得所有 $|X-X_i|+|Y-Y_i|$ 之和最小。\n\n请你输出这个 $(X,Y)$。如果有多种可能的答案，输出任意一个即可。\n\n**注意：最终答案 $(X,Y)$ 可能与某个 $(X_i,Y_i)$ 相同。一个 $(X_i,Y_i)$ 点上也可能不止一位选手。你应该认为住在同一个点的选手分别单独去赛场，而不是将他们视为同一个人。**", "inputFormat": "第一行一个正整数 $N$。\n\n接下来 $N$ 行，每行两个整数 $X_i,Y_i$。", "outputFormat": "一行两个整数 $X,Y$。", "hint": "### 【样例解释】\n\n对于样例一，不难发现 $(1,0),(2,0),(4,0)$ 也是正确的输出。无论选择 $(1,0),(2,0),(3,0)$ 还是 $(4,0)$，都有 $\\sum\\limits_{i=1}^N(|X-X_i|+|Y-Y_i|)=3$。可以证明没有 $(X,Y)$ 可以使 $|X-X_i|+|Y-Y_i|$ 之和更小。\n\n对于样例二，$(5,0),(6,0)$ 也是正确的输出。\n\n对于样例三，可以证明这是唯一正确的输出。\n\n### 【数据范围】\n\n**本题采用 $\\text{Subtask}$ 捆绑测试。**\n\n|$\\text{Subtask}$|分值|$N$|$X_i,Y_i$|\n|:-:|:-:|:-:|:-:|\n|$1$|$3$|$N=2$|$0\\le X_i,Y_i\\le10^9$|\n|$2$|$20$|$2\\le N\\le1000$|$0\\le X_i\\le1000,Y_i=0$\n|$3$|$28$|$2\\le N\\le10^6$|$0 \\le X_i\\le10^9,Y_i=0$|\n|$4$|$13$|$2\\le N\\le100$|$0\\le X_i,Y_i\\le100$|\n|$5$|$17$|$2\\le N\\le1000$|$0\\le X_i,Y_i\\le10^9$|\n|$6$|$19$|$2\\le N\\le10^6$|$0\\le X_i,Y_i\\le10^9$|\n\n对于 $100\\%$ 的数据，$2\\le N\\le10^6$，$0\\le X_i,Y_i\\le10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2017] Best Places / 最佳选址", "background": "译自 [NOISG 2017 A.Best Places](https://github.com/noisg/sg_noi_archive/tree/master/2017/bestplace)。", "description": "IOI 2020 将在新加坡举行！举办这样的国际赛事，选择举办地自然成了十分重要的事。\n\n现在，组委会拿到了一份选手住址名单，共有 $N$ 位选手，他们所在的城市可以看作一个坐标系，第 $i$ 位选手住在 $(X_i,Y_i)$。\n\n为了选手们方便参加比赛，组委会想要选择一个点 $(X,Y)$，使得所有 $|X-X_i|+|Y-Y_i|$ 之和最小。\n\n请你输出这个 $(X,Y)$。如果有多种可能的答案，输出任意一个即可。\n\n**注意：最终答案 $(X,Y)$ 可能与某个 $(X_i,Y_i)$ 相同。一个 $(X_i,Y_i)$ 点上也可能不止一位选手。你应该认为住在同一个点的选手分别单独去赛场，而不是将他们视为同一个人。**", "inputFormat": "第一行一个正整数 $N$。\n\n接下来 $N$ 行，每行两个整数 $X_i,Y_i$。", "outputFormat": "一行两个整数 $X,Y$。", "hint": "### 【样例解释】\n\n对于样例一，不难发现 $(1,0),(2,0),(4,0)$ 也是正确的输出。无论选择 $(1,0),(2,0),(3,0)$ 还是 $(4,0)$，都有 $\\sum\\limits_{i=1}^N(|X-X_i|+|Y-Y_i|)=3$。可以证明没有 $(X,Y)$ 可以使 $|X-X_i|+|Y-Y_i|$ 之和更小。\n\n对于样例二，$(5,0),(6,0)$ 也是正确的输出。\n\n对于样例三，可以证明这是唯一正确的输出。\n\n### 【数据范围】\n\n**本题采用 $\\text{Subtask}$ 捆绑测试。**\n\n|$\\text{Subtask}$|分值|$N$|$X_i,Y_i$|\n|:-:|:-:|:-:|:-:|\n|$1$|$3$|$N=2$|$0\\le X_i,Y_i\\le10^9$|\n|$2$|$20$|$2\\le N\\le1000$|$0\\le X_i\\le1000,Y_i=0$\n|$3$|$28$|$2\\le N\\le10^6$|$0 \\le X_i\\le10^9,Y_i=0$|\n|$4$|$13$|$2\\le N\\le100$|$0\\le X_i,Y_i\\le100$|\n|$5$|$17$|$2\\le N\\le1000$|$0\\le X_i,Y_i\\le10^9$|\n|$6$|$19$|$2\\le N\\le10^6$|$0\\le X_i,Y_i\\le10^9$|\n\n对于 $100\\%$ 的数据，$2\\le N\\le10^6$，$0\\le X_i,Y_i\\le10^9$。", "locale": "zh-CN"}}}
{"pid": "P13081", "type": "P", "difficulty": 4, "samples": [["5\n0 1 1\n1 2 2\n2 3 3\n3 4 4\n1\n4 0 3 1 2", "10"], ["6\n4 0 4\n0 1 2\n1 3 9\n3 5 1\n3 2 5\n2\n4 0 3 5 2\n0 4 1 3 5", "21\n16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "倍增", "最近公共祖先 LCA", "NOISG（新加坡）"], "title": "[NOISG 2017] Roadside Advertisements / 广告投放", "background": "译自 [NOISG 2017 B.Roadside Advertisements](https://github.com/noisg/sg_noi_archive/tree/master/2017/roadsideadverts)。\n\n------------\n\nNOISG2017 拥有 $5$ 个赞助商。", "description": "新加坡的地图可以视为一张 $V$ 个点 $V-1$ 条边的图，其中点的编号为 $0,1,\\cdots V-1$。保证任意两点间有且仅有唯一路径。\n\n已知 $5$ 个赞助商分别位于 $a,b,c,d,e$ 号点，NOISG 主席 TAN Sun-Teck 想要在一些边上投放广告，使得 $5$ 个赞助商两两间最短路径上的每一条边都投放了广告。\n\n对于每条边，在该边上投放广告的成本是已知的。投放广告的总成本是每条需投放广告的道路成本的总和。$Q$ 次询问，每次给定 $a,b,c,d,e$，求满足要求的最低总成本。", "inputFormat": "第一行一个正整数 $V$。\n\n接下来 $V−1$ 行，每行三个整数 $u,v,w$，表示 $u$ 号点和 $v$ 号点间有一条道路相连，并且在这条道路上投放广告需要 $w$ 新加坡元。\n\n接下来一行包含一个正整数 $Q$，表示询问次数。\n\n接下来 $Q$ 行，每行五个整数 $a,b,c,d,e$，表示 $5$ 个赞助商的位置。保证 $a,b,c,d,e$ 两两不同。", "outputFormat": "对于每次询问，一行一个整数表示投放广告的最低总成本。", "hint": "### 【样例 2 解释】\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bflmat2l.png)\n\n对于第一次询问，$5$ 个赞助商分别位于 $4,0,3,5,2$ 号点（请注意编号不一定按升序排列）。易知我们需要在每一条路边投放广告，最低成本是所有道路的成本之和，即 $4+2+9+1+5=21$。\n\n对于第二次询问，$5$ 个赞助商位于 $0,4,1,3,5$ 号点。这一次我们不需要在 $(3,2)$ 这条道路上投放广告。因此总成本为 $21−5=16$。\n\n### 【数据范围】\n\n**本题采用 $\\text{Subtask}$ 捆绑测试。**\n\n|$\\text{Subtask}$|分值|$V,Q$ 的范围|特殊性质|\n|:-:|:-:|:-:|:-:|\n|$1$|$7$|$V=5,Q=1$|无|\n|$2$|$23$|$5\\le V\\le5\\times10^4,1\\le Q\\le 10^4$|有|\n|$3$|$40$|$5\\le V\\le5\\times10^4,1\\le Q\\le 100$|无|\n|$4$|$30$|$5\\le V\\le5\\times10^4,1\\le Q\\le 10^4$|无|\n\n特殊性质：保证每个点最多与 $2$ 个点间有道路相连。\n\n对于所有数据，保证 $5\\le V\\le5\\times10^4$，$1\\le Q\\le 10^4$，$0\\le u,v<V$ 且 $1\\le w\\le1000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2017] Roadside Advertisements / 广告投放", "background": "译自 [NOISG 2017 B.Roadside Advertisements](https://github.com/noisg/sg_noi_archive/tree/master/2017/roadsideadverts)。\n\n------------\n\nNOISG2017 拥有 $5$ 个赞助商。", "description": "新加坡的地图可以视为一张 $V$ 个点 $V-1$ 条边的图，其中点的编号为 $0,1,\\cdots V-1$。保证任意两点间有且仅有唯一路径。\n\n已知 $5$ 个赞助商分别位于 $a,b,c,d,e$ 号点，NOISG 主席 TAN Sun-Teck 想要在一些边上投放广告，使得 $5$ 个赞助商两两间最短路径上的每一条边都投放了广告。\n\n对于每条边，在该边上投放广告的成本是已知的。投放广告的总成本是每条需投放广告的道路成本的总和。$Q$ 次询问，每次给定 $a,b,c,d,e$，求满足要求的最低总成本。", "inputFormat": "第一行一个正整数 $V$。\n\n接下来 $V−1$ 行，每行三个整数 $u,v,w$，表示 $u$ 号点和 $v$ 号点间有一条道路相连，并且在这条道路上投放广告需要 $w$ 新加坡元。\n\n接下来一行包含一个正整数 $Q$，表示询问次数。\n\n接下来 $Q$ 行，每行五个整数 $a,b,c,d,e$，表示 $5$ 个赞助商的位置。保证 $a,b,c,d,e$ 两两不同。", "outputFormat": "对于每次询问，一行一个整数表示投放广告的最低总成本。", "hint": "### 【样例 2 解释】\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bflmat2l.png)\n\n对于第一次询问，$5$ 个赞助商分别位于 $4,0,3,5,2$ 号点（请注意编号不一定按升序排列）。易知我们需要在每一条路边投放广告，最低成本是所有道路的成本之和，即 $4+2+9+1+5=21$。\n\n对于第二次询问，$5$ 个赞助商位于 $0,4,1,3,5$ 号点。这一次我们不需要在 $(3,2)$ 这条道路上投放广告。因此总成本为 $21−5=16$。\n\n### 【数据范围】\n\n**本题采用 $\\text{Subtask}$ 捆绑测试。**\n\n|$\\text{Subtask}$|分值|$V,Q$ 的范围|特殊性质|\n|:-:|:-:|:-:|:-:|\n|$1$|$7$|$V=5,Q=1$|无|\n|$2$|$23$|$5\\le V\\le5\\times10^4,1\\le Q\\le 10^4$|有|\n|$3$|$40$|$5\\le V\\le5\\times10^4,1\\le Q\\le 100$|无|\n|$4$|$30$|$5\\le V\\le5\\times10^4,1\\le Q\\le 10^4$|无|\n\n特殊性质：保证每个点最多与 $2$ 个点间有道路相连。\n\n对于所有数据，保证 $5\\le V\\le5\\times10^4$，$1\\le Q\\le 10^4$，$0\\le u,v<V$ 且 $1\\le w\\le1000$。", "locale": "zh-CN"}}}
{"pid": "P13082", "type": "P", "difficulty": 0, "samples": [["5 5\n0 1\n1 2\n2 3\n3 4\n4 0\n2\n1 3\n2 4", "2"], ["5 4\n0 1\n1 2\n2 3\n3 4\n3\n0 2\n1 3\n2 4", "2"], ["6 5\n0 2\n1 2\n2 3\n3 4\n3 5\n2\n0 5\n1 4", "2"], ["15 19\n0 3\n1 3\n1 4\n1 5\n2 5\n3 6\n3 7\n4 7\n5 7\n6 10\n7 9\n7 10\n7 11\n8 11\n9 12\n9 13\n10 13\n11 13\n11 14\n2\n4 10\n3 8", "7"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "Special Judge", "NOISG（新加坡）"], "title": "[NOISG 2017] Hotspot / 热门地点", "background": "译自 [NOISG 2017 C.Hotspot](https://github.com/noisg/sg_noi_archive/tree/master/2017/hotspot)。", "description": "一个国家有 $n$ 个城镇，这些城镇由 $m$ 条长度相同的道路连接。\n\n这个国家有 $k$ 个公民。有趣的是，第 $i$ 位公民的家和办公室位于两个不同的城镇 $A_i$ 和 $B_i$。因此，第 $i$ 个公民每天都会在 $A_i$ 和 $B_i$ 两个固定的城镇间往返。\n\n为了节省时间，第 $i$ 个公民将选择长度最短的路径。如果 $A_i$ 和 $B_i$ 间有多条最短路径，他 / 她将随机选择一条最短路径。第 $i$ 个公民通过城镇 $w$ 的期望为：\n\n$$E_i(w)=\\dfrac{S_w(A_i,B_i)}{S(A_i,B_i)}$$\n\n其中 $S(u,v)$ 表示 $u$ 和 $v$ 间的最短路数量，$S_w(u,v)$ 表示 $u$ 和 $v$ 间经过 $w$ 的的最短路数量。\n\n小 D 是这个国家的总统。他想了解公民的需求，于是想在国家的某一个城镇上设立一个会议办公室，因为这样他就可以会见尽可能多的公民。确切地说，他想将会议办公室设立在使 $\\sum\\limits_{i=0}^{k-1}E_i(w)$ 最大的城镇 $w$。\n\n你的任务是帮助小 D 找到符合要求的 $w$。当有多个符合要求的城镇 $w$ 时，你可以输出其中的任何一个。\n\n注意本题需要使用**双精度浮点数**。", "inputFormat": "第一行两个正整数 $n,m$，分别表示城镇和道路的数量。\n\n接下来 $m$ 行，每行两个整数 $u,v$，表示城镇 $u$ 和城镇 $v$ 间有一条道路相连。\n\n接下来一行包含一个正整数 $k$，表示公民的个数。\n\n接下来 $k$ 行，第 $i$ 行两个整数 $A_i,B_i$，表示第 $i$ 个公民的家和办公室的位置。", "outputFormat": "一行一个整数表示使 $\\sum\\limits_{i=0}^{k-1}E_i(w)$ 最大的城镇 $w$。如果有多个符合要求的解，输出其中的任何一个即可。", "hint": "### 样例解释\n\n对于样例 1 和 3，显然选择城镇 $3$ 也是正确的。\n\n对于样例 4（如下图），在城镇 $4$ 和城镇 $10$ 之间只有一条长度为 $2$ 的最短路径，即 $4\\to7\\to10$。此外，城镇 $3$ 和城镇 $8$ 之间只有一条长度为 $3$ 的最短路径，即 $3\\to7\\to11\\to8$。\n如果小 D 在城镇 $7$ 建造会议办公室，那么 $\\sum\\limits_{i=0}^{k-1}E_i(w)=2$ 最大。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/z7tp37kw.png)\n\n### 数据范围\n\n请注意本题时限为 $2.5$ 秒。\n\n**本题采用 $\\text{Subtask}$ 捆绑测试。**\n\n|$\\text{Subtask}$|分值|性质|\n|:-:|:-:|:-:|\n|$1$|$4$|图是一条链，且 $n\\le1000$，$m=n-1$，$k=1$|\n|$2$|$5$|图是一棵树，且 $n\\le1000$，$m=n-1$，$k=1$|\n|$3$|$11$|图是一条链，且 $n\\le1000$，$m=n-1$，$k\\le200$|\n|$4$|$18$|图是一棵树，且 $n\\le1000$，$m=n-1$，$k\\le200$|\n|$5$|$26$|$n\\le1000$，$m\\le8000$，$k\\le20$|\n|$6$|$36$|$1\\le n\\le5000$，$1\\le m\\le 4\\times 10^4$，$1\\le k \\le2000$|\n\n对于所有数据，保证 $1\\le n\\le5000$，$1\\le m\\le 4\\times 10^4$，$1\\le k \\le2000$，$1\\le u,v,A_i,B_i\\le n$，任何两个城镇之间的最短路不会超过 $2^{15}$ 条。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2017] Hotspot / 热门地点", "background": "译自 [NOISG 2017 C.Hotspot](https://github.com/noisg/sg_noi_archive/tree/master/2017/hotspot)。", "description": "一个国家有 $n$ 个城镇，这些城镇由 $m$ 条长度相同的道路连接。\n\n这个国家有 $k$ 个公民。有趣的是，第 $i$ 位公民的家和办公室位于两个不同的城镇 $A_i$ 和 $B_i$。因此，第 $i$ 个公民每天都会在 $A_i$ 和 $B_i$ 两个固定的城镇间往返。\n\n为了节省时间，第 $i$ 个公民将选择长度最短的路径。如果 $A_i$ 和 $B_i$ 间有多条最短路径，他 / 她将随机选择一条最短路径。第 $i$ 个公民通过城镇 $w$ 的期望为：\n\n$$E_i(w)=\\dfrac{S_w(A_i,B_i)}{S(A_i,B_i)}$$\n\n其中 $S(u,v)$ 表示 $u$ 和 $v$ 间的最短路数量，$S_w(u,v)$ 表示 $u$ 和 $v$ 间经过 $w$ 的的最短路数量。\n\n小 D 是这个国家的总统。他想了解公民的需求，于是想在国家的某一个城镇上设立一个会议办公室，因为这样他就可以会见尽可能多的公民。确切地说，他想将会议办公室设立在使 $\\sum\\limits_{i=0}^{k-1}E_i(w)$ 最大的城镇 $w$。\n\n你的任务是帮助小 D 找到符合要求的 $w$。当有多个符合要求的城镇 $w$ 时，你可以输出其中的任何一个。\n\n注意本题需要使用**双精度浮点数**。", "inputFormat": "第一行两个正整数 $n,m$，分别表示城镇和道路的数量。\n\n接下来 $m$ 行，每行两个整数 $u,v$，表示城镇 $u$ 和城镇 $v$ 间有一条道路相连。\n\n接下来一行包含一个正整数 $k$，表示公民的个数。\n\n接下来 $k$ 行，第 $i$ 行两个整数 $A_i,B_i$，表示第 $i$ 个公民的家和办公室的位置。", "outputFormat": "一行一个整数表示使 $\\sum\\limits_{i=0}^{k-1}E_i(w)$ 最大的城镇 $w$。如果有多个符合要求的解，输出其中的任何一个即可。", "hint": "### 样例解释\n\n对于样例 1 和 3，显然选择城镇 $3$ 也是正确的。\n\n对于样例 4（如下图），在城镇 $4$ 和城镇 $10$ 之间只有一条长度为 $2$ 的最短路径，即 $4\\to7\\to10$。此外，城镇 $3$ 和城镇 $8$ 之间只有一条长度为 $3$ 的最短路径，即 $3\\to7\\to11\\to8$。\n如果小 D 在城镇 $7$ 建造会议办公室，那么 $\\sum\\limits_{i=0}^{k-1}E_i(w)=2$ 最大。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/z7tp37kw.png)\n\n### 数据范围\n\n请注意本题时限为 $2.5$ 秒。\n\n**本题采用 $\\text{Subtask}$ 捆绑测试。**\n\n|$\\text{Subtask}$|分值|性质|\n|:-:|:-:|:-:|\n|$1$|$4$|图是一条链，且 $n\\le1000$，$m=n-1$，$k=1$|\n|$2$|$5$|图是一棵树，且 $n\\le1000$，$m=n-1$，$k=1$|\n|$3$|$11$|图是一条链，且 $n\\le1000$，$m=n-1$，$k\\le200$|\n|$4$|$18$|图是一棵树，且 $n\\le1000$，$m=n-1$，$k\\le200$|\n|$5$|$26$|$n\\le1000$，$m\\le8000$，$k\\le20$|\n|$6$|$36$|$1\\le n\\le5000$，$1\\le m\\le 4\\times 10^4$，$1\\le k \\le2000$|\n\n对于所有数据，保证 $1\\le n\\le5000$，$1\\le m\\le 4\\times 10^4$，$1\\le k \\le2000$，$1\\le u,v,A_i,B_i\\le n$，任何两个城镇之间的最短路不会超过 $2^{15}$ 条。", "locale": "zh-CN"}}}
{"pid": "P13083", "type": "P", "difficulty": 5, "samples": [["5 3\n0 2 1\n1 3 0\n1 4 0", "1 4 3 0 2"], ["3 2\n0 1 1\n1 2 1", "-1 -1 -1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2017", "Special Judge", "NOISG（新加坡）"], "title": "[NOISG 2017] RMQ", "background": "译自 [NOISG 2017 D.RMQ](https://github.com/noisg/sg_noi_archive/tree/master/2017/rmq)。", "description": "小 K 有 $N$ 头奶牛，编号分别为 $0$ 至 $N-1$。这些奶牛以某种未知的顺序排成了一排。\n\n现在给出 $Q$ 条信息，每条信息包含三个整数 $L_i,R_i,A_i$，表示区间 $[L_i,R_i]$ 内编号最小的奶牛的编号为 $A_i$。请你构造一组奶牛的顺序使得其可以满足所有信息。", "inputFormat": "第一行两个正整数 $N,Q$，分别表示奶牛数和信息数。\n\n接下来 $Q$ 行，每行三个整数 $L_i,R_i,A_i$，代表一条信息。", "outputFormat": "一行 $N$ 个整数表示你构造的奶牛的顺序。如果有多个解，输出任意一个即可。如果无解，输出 $N$ 个 $-1$。", "hint": "### 样例解释\n\n对于样例 1，请注意这不是唯一满足要求的顺序。\n\n对于样例 2，如果 $0$ 号奶牛在 $0$ 号位置或者 $1$ 号位置，那么区间 $[0,1]$ 的最小值应为 $0$ 而非 $1$；如果 $0$ 号奶牛在 $2$ 号位置，那么区间 $[1,1]$ 的最小值应为 $0$ 而非 $1$。因此，不存在符合要求的顺序。\n\n### 评分标准\n\n对于一个测试点：\n- 如果你的输出满足以下要求，你将获得该测试点所有的分数：\n\t- 输出 $N$ 个数。\n\t- 该测试点无解，并且你也判断无解。\n\t- 该测试点有解，并且你构造的顺序满足所有信息而且没有奶牛编号相同。\n- 如果你的输出满足以下要求，你将获得该测试点 $30\\%$ 的分数：\n\t- 输出 $N$ 个数。\n\t- 你构造的顺序满足所有信息但是有奶牛编号相同。\n- 否则你将获得该测试点 $0\\%$ 的分数。\n\n例如，对于样例 2，如果你输出 `1 1 1`，那么你将获得该点 $30\\%$ 的分数。\n\n### 数据范围\n\n**本题采用 $\\text{Subtask}$ 捆绑测试。**\n\n|$\\text{Subtask}$|分值|$N,Q$|\n|:-:|:-:|:-:|\n|$1$|$23$|$\\le10$|\n|$2$|$44$|$\\le1000$|\n|$3$|$33$|$\\le10^5$|\n\n对于所有数据，保证 $1\\le N,Q\\le10^5$，$0\\le L_i,R_i< N$，$0\\le A_i< N$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2017] RMQ", "background": "译自 [NOISG 2017 D.RMQ](https://github.com/noisg/sg_noi_archive/tree/master/2017/rmq)。", "description": "小 K 有 $N$ 头奶牛，编号分别为 $0$ 至 $N-1$。这些奶牛以某种未知的顺序排成了一排。\n\n现在给出 $Q$ 条信息，每条信息包含三个整数 $L_i,R_i,A_i$，表示区间 $[L_i,R_i]$ 内编号最小的奶牛的编号为 $A_i$。请你构造一组奶牛的顺序使得其可以满足所有信息。", "inputFormat": "第一行两个正整数 $N,Q$，分别表示奶牛数和信息数。\n\n接下来 $Q$ 行，每行三个整数 $L_i,R_i,A_i$，代表一条信息。", "outputFormat": "一行 $N$ 个整数表示你构造的奶牛的顺序。如果有多个解，输出任意一个即可。如果无解，输出 $N$ 个 $-1$。", "hint": "### 样例解释\n\n对于样例 1，请注意这不是唯一满足要求的顺序。\n\n对于样例 2，如果 $0$ 号奶牛在 $0$ 号位置或者 $1$ 号位置，那么区间 $[0,1]$ 的最小值应为 $0$ 而非 $1$；如果 $0$ 号奶牛在 $2$ 号位置，那么区间 $[1,1]$ 的最小值应为 $0$ 而非 $1$。因此，不存在符合要求的顺序。\n\n### 评分标准\n\n对于一个测试点：\n- 如果你的输出满足以下要求，你将获得该测试点所有的分数：\n\t- 输出 $N$ 个数。\n\t- 该测试点无解，并且你也判断无解。\n\t- 该测试点有解，并且你构造的顺序满足所有信息而且没有奶牛编号相同。\n- 如果你的输出满足以下要求，你将获得该测试点 $30\\%$ 的分数：\n\t- 输出 $N$ 个数。\n\t- 你构造的顺序满足所有信息但是有奶牛编号相同。\n- 否则你将获得该测试点 $0\\%$ 的分数。\n\n例如，对于样例 2，如果你输出 `1 1 1`，那么你将获得该点 $30\\%$ 的分数。\n\n### 数据范围\n\n**本题采用 $\\text{Subtask}$ 捆绑测试。**\n\n|$\\text{Subtask}$|分值|$N,Q$|\n|:-:|:-:|:-:|\n|$1$|$23$|$\\le10$|\n|$2$|$44$|$\\le1000$|\n|$3$|$33$|$\\le10^5$|\n\n对于所有数据，保证 $1\\le N,Q\\le10^5$，$0\\le L_i,R_i< N$，$0\\le A_i< N$。", "locale": "zh-CN"}}}
{"pid": "P13084", "type": "P", "difficulty": 0, "samples": [["1 5 5\n1 2 3 4 5\n1 1 2 1 2\n2 2 1 2\n2 1 1 4\n2 4 1 3\n1 3 1 1\n2 3 1 4", "1\n2\n0\n1"], ["1 5 5\n1 2 3 4 5\n3 4 3 2 5\n2 3 1 3\n2 1 1 5\n2 4 1 2\n1 4 1 4\n2 3 1 5", "2\n4\n0\n3"], ["3 3 5\n1 4 3\n11 2 7\n5 10 6\n1 1 1\n2 1 2\n1 2 1\n2 2 1 6\n2 2 3 10\n2 3 2 3\n1 2 2 2\n2 2 1 4", "1\n2\n0\n2"], ["3 3 5\n1 4 3\n11 2 7\n5 10 6\n6 3 3\n4 6 4\n9 4 9\n2 2 1 6\n2 2 3 10\n2 3 2 3\n1 2 2 7\n2 2 1 4", "2\n4\n0\n3"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "NOISG（新加坡）"], "title": "[NOISG 2017] I want to be the very best too! / 宝可梦大师", "background": "译自 [NOISG 2017 E.I want to be the very best too! (Pokémon Master)](https://github.com/noisg/sg_noi_archive/tree/master/2017/pokemonmaster)。\n\n------------\n\n看到小智成功成为最优秀的人后，小 P 也想追随他的脚步，成为最出色的人！\n\n为了做到这一点，他想抓住种类尽可能多的宝可梦，以填满他的宝可梦图鉴并成为最出色的人。\n\n然而，还有许多其他的宝可梦训练家挡在他面前，他必须打败他们，才能实现他的目标。", "description": "小 P 和宝可梦生活在一个可以用 $R$ 行 $C$ 列的网格表示的世界里。其中左上角的网格为 $(1,1)$，右下角的网格为 $(C,R)$。小 P 每次只能从一个网格移动到与其相邻的另一个网格。\n\n每一个网格中都有一个宝可梦训练家。小 P 必须与之战斗才能通过这一个网格并获得该宝可梦训练家的宝可梦。\n\n每个宝可梦训练家都有自己的等级。我们不妨认为所有宝可梦训练家的等级都是不同的（这样方便知道每一场战斗的获胜者）。其中，网格 $(j,i)$ 中的训练家的等级为 $L_{i,j}$，并用种类为 $P_{i,j}$ 的宝可梦进行战斗。\n\n让事情变得更加困难的是，宝可梦训练家们有时会改变他们的宝可梦的种类。于是，小 P 想提前规划好他的出发时间。因此，小 P 会随时询问你，如果他现在从 $(X_q,Y_q)$ 出发，并且只能击败等级小于或等于 $L_q$ 的宝可梦训练家，那么他最终能拥有多少种宝可梦。\n\n注意，如果他不能打败一个网格中的宝可梦训练家，他就不能穿过该网格。", "inputFormat": "第一行三个整数 $R,C,Q$，分别表示世界的行数。\n\n接下来 $R$ 行，每行 $C$ 个整数，第 $i$ 行第 $j$ 列的整数 $L_{i,j}$ 表示网格 $(j,i)$ 中的训练家的等级。\n\n接下来 $R$ 行，每行 $C$ 个整数，第 $i$ 行第 $j$ 列的整数 $P_{i,j}$ 表示网格 $(j,i)$ 中的训练家的宝可梦的种类。\n\n最后 $Q$ 行，每行四个整数。第一个整数为 $op$，如果 $op=1$，则其后三个整数 $X_q,Y_q,P_q$，代表 $(X_q,Y_q)$ 处的训练师将宝可梦的种类更换为了 $P_q$；如果 $op=2$，则其后三个整数 $X_q,Y_q,L_q$，代表小 P 询问你，如果他现在从 $(X_q,Y_q)$ 出发，并且只能击败等级小于或等于 $L_q$ 的宝可梦训练家，那么他最终能拥有多少种宝可梦。", "outputFormat": "对于小 P 的每次询问，输出一行一个整数，即他最终能拥有的宝可梦种类数。", "hint": "### 样例 4 解释\n\n对于第一次询问，小 P 只能通过击败等级分别为 $1,2,3,4$ 的宝可梦训练家来捕捉种类为 $3$ 和 $6$ 的宝可梦。\n\n对于第二次询问，小 P 可以捕捉到所有种类的宝可梦，因为他可以击败除 $11$ 级之外的所有宝可梦训练家。\n\n对于第三次询问，小 P 无法打败出发的位置处的宝可梦训练家，因此他无法去任何地方，也无法抓住任何种类的宝可梦。\n\n对于第四次询问，小 P 可以捕捉到 $3$ 种类型的宝可梦，因为 $(2,2)$ 处的训练师现在使用的是种类为 $7$ 的宝可梦。\n\n### 数据范围\n\n请注意本题时限为 $5$ 秒。\n\n**本题采用 $\\text{Subtask}$ 捆绑测试。**\n\n|$\\text{Subtask}$|分值|$R$|$Q$|特殊性质|\n|:-:|:-:|:-:|:-:|:-:|\n|$1$|$11$|$=1$|$\\le1000$|$(X,1)$ 处的训练家的等级为 $X$|\n|$2$|$16$|$\\le5\\times10^4$|$\\le10$|无|\n|$3$|$20$|$\\le5\\times10^4$|$\\le10^5$|$1\\le P_{i,j},P_q\\le2$|\n|$4$|$24$|$=1$|$\\le10^5$|$(X,1)$ 处的训练家的等级为 $X$|\n|$5$|$29$|$\\le5\\times10^4$|$\\le10^5$|无|\n\n对于所有数据，保证 $1\\le R\\times C\\le5\\times10^4$，$1\\le Q\\le 10^5$，$1\\le L_{i,j},L_q \\le10^9$，$1\\le P_{i,j},P_q\\le 5\\times10^4$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2017] I want to be the very best too! / 宝可梦大师", "background": "译自 [NOISG 2017 E.I want to be the very best too! (Pokémon Master)](https://github.com/noisg/sg_noi_archive/tree/master/2017/pokemonmaster)。\n\n------------\n\n看到小智成功成为最优秀的人后，小 P 也想追随他的脚步，成为最出色的人！\n\n为了做到这一点，他想抓住种类尽可能多的宝可梦，以填满他的宝可梦图鉴并成为最出色的人。\n\n然而，还有许多其他的宝可梦训练家挡在他面前，他必须打败他们，才能实现他的目标。", "description": "小 P 和宝可梦生活在一个可以用 $R$ 行 $C$ 列的网格表示的世界里。其中左上角的网格为 $(1,1)$，右下角的网格为 $(C,R)$。小 P 每次只能从一个网格移动到与其相邻的另一个网格。\n\n每一个网格中都有一个宝可梦训练家。小 P 必须与之战斗才能通过这一个网格并获得该宝可梦训练家的宝可梦。\n\n每个宝可梦训练家都有自己的等级。我们不妨认为所有宝可梦训练家的等级都是不同的（这样方便知道每一场战斗的获胜者）。其中，网格 $(j,i)$ 中的训练家的等级为 $L_{i,j}$，并用种类为 $P_{i,j}$ 的宝可梦进行战斗。\n\n让事情变得更加困难的是，宝可梦训练家们有时会改变他们的宝可梦的种类。于是，小 P 想提前规划好他的出发时间。因此，小 P 会随时询问你，如果他现在从 $(X_q,Y_q)$ 出发，并且只能击败等级小于或等于 $L_q$ 的宝可梦训练家，那么他最终能拥有多少种宝可梦。\n\n注意，如果他不能打败一个网格中的宝可梦训练家，他就不能穿过该网格。", "inputFormat": "第一行三个整数 $R,C,Q$，分别表示世界的行数。\n\n接下来 $R$ 行，每行 $C$ 个整数，第 $i$ 行第 $j$ 列的整数 $L_{i,j}$ 表示网格 $(j,i)$ 中的训练家的等级。\n\n接下来 $R$ 行，每行 $C$ 个整数，第 $i$ 行第 $j$ 列的整数 $P_{i,j}$ 表示网格 $(j,i)$ 中的训练家的宝可梦的种类。\n\n最后 $Q$ 行，每行四个整数。第一个整数为 $op$，如果 $op=1$，则其后三个整数 $X_q,Y_q,P_q$，代表 $(X_q,Y_q)$ 处的训练师将宝可梦的种类更换为了 $P_q$；如果 $op=2$，则其后三个整数 $X_q,Y_q,L_q$，代表小 P 询问你，如果他现在从 $(X_q,Y_q)$ 出发，并且只能击败等级小于或等于 $L_q$ 的宝可梦训练家，那么他最终能拥有多少种宝可梦。", "outputFormat": "对于小 P 的每次询问，输出一行一个整数，即他最终能拥有的宝可梦种类数。", "hint": "### 样例 4 解释\n\n对于第一次询问，小 P 只能通过击败等级分别为 $1,2,3,4$ 的宝可梦训练家来捕捉种类为 $3$ 和 $6$ 的宝可梦。\n\n对于第二次询问，小 P 可以捕捉到所有种类的宝可梦，因为他可以击败除 $11$ 级之外的所有宝可梦训练家。\n\n对于第三次询问，小 P 无法打败出发的位置处的宝可梦训练家，因此他无法去任何地方，也无法抓住任何种类的宝可梦。\n\n对于第四次询问，小 P 可以捕捉到 $3$ 种类型的宝可梦，因为 $(2,2)$ 处的训练师现在使用的是种类为 $7$ 的宝可梦。\n\n### 数据范围\n\n请注意本题时限为 $5$ 秒。\n\n**本题采用 $\\text{Subtask}$ 捆绑测试。**\n\n|$\\text{Subtask}$|分值|$R$|$Q$|特殊性质|\n|:-:|:-:|:-:|:-:|:-:|\n|$1$|$11$|$=1$|$\\le1000$|$(X,1)$ 处的训练家的等级为 $X$|\n|$2$|$16$|$\\le5\\times10^4$|$\\le10$|无|\n|$3$|$20$|$\\le5\\times10^4$|$\\le10^5$|$1\\le P_{i,j},P_q\\le2$|\n|$4$|$24$|$=1$|$\\le10^5$|$(X,1)$ 处的训练家的等级为 $X$|\n|$5$|$29$|$\\le5\\times10^4$|$\\le10^5$|无|\n\n对于所有数据，保证 $1\\le R\\times C\\le5\\times10^4$，$1\\le Q\\le 10^5$，$1\\le L_{i,j},L_q \\le10^9$，$1\\le P_{i,j},P_q\\le 5\\times10^4$。", "locale": "zh-CN"}}}
{"pid": "P13085", "type": "P", "difficulty": 5, "samples": [["1 10", "9"], ["25 50\n", "20\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2009", "四川", "各省省选", "数位 DP"], "title": "[SCOI2009] windy 数（加强版）", "background": "**本题与 [P2657 [SCOI2009] windy 数](https://www.luogu.com.cn/problem/P2657) 的区别在于 $\\bm{a}$ 与 $\\bm{b}$ 的范围。**\n\nwindy 定义了一种 windy 数。", "description": "不含前导零且相邻两个数字之差至少为 $2$ 的正整数被称为 windy 数。windy 想知道，在 $a$ 和 $b$ 之间，包括 $a$ 和 $b$，总共有多少个 windy 数？", "inputFormat": "输入只有一行两个整数，分别表示 $a$ 和 $b$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq a \\leq b \\leq 10^{18}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[SCOI2009] windy 数（加强版）", "background": "**本题与 [P2657 [SCOI2009] windy 数](https://www.luogu.com.cn/problem/P2657) 的区别在于 $\\bm{a}$ 与 $\\bm{b}$ 的范围。**\n\nwindy 定义了一种 windy 数。", "description": "不含前导零且相邻两个数字之差至少为 $2$ 的正整数被称为 windy 数。windy 想知道，在 $a$ 和 $b$ 之间，包括 $a$ 和 $b$，总共有多少个 windy 数？", "inputFormat": "输入只有一行两个整数，分别表示 $a$ 和 $b$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq a \\leq b \\leq 10^{18}$。", "locale": "zh-CN"}}}
{"pid": "P13086", "type": "P", "difficulty": 7, "samples": [["", "1\n2\n4\n8\n16\n32\n64\n128\n256\n512\n1024\n2048\n1\n2\n4\n8\n16\n32\n64\n128\n256\n512\n1024\n2048\n3\n3 XOR 1 2\n3 OR 3 N 7\n3 POPCNT 3"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["提交答案", "Special Judge", "O2优化"], "title": "『STA - H1』Code Golf (16bit[v])", "background": "这是问题的 16bit[v] 版本。本题与 [24bit 版本](https://www.luogu.com.cn/problem/P13087)和 [68bit 版本](https://www.luogu.com.cn/problem/P13088)的区别在于此版本中电路的位长 $w=16$。此外，另外两个版本和本题的另一个区别是本题的电路中 `LSH` 与 `RSH` 的右操作数**不**必须是字面量。", "description": "**本题为提交答案题。**\n\n以下是简要题面，关于其中名词的详细定义见后文（有些名词可能和你所见过的定义并不完全相符）。\n\n定义所有**长度为 $\\bm4$** 的排列组成的集合为 $\\mathcal P$，$w=\\color{blue}16$ 是位长，$B$ 是 $[0,2^w)$ 内的整数组成的集合。\n\n你需要设计一个**函数** $f:\\mathcal P\\to B$ 和一个**电路** $C:(B, B)\\to B$，使得对于任意 $p,q\\in\\mathcal P$ 都有：\n$$\\operatorname{cyc}(p\\circ q)=C(f(p),f(q))$$\n其中 $\\circ$ 是排列的复合，$\\operatorname{cyc}(\\cdot)$ 表示排列的置换环个数。\n\n电路 $C$ 中涉及到的运算门个数不能超过 $10^4$，得分将根据电路 $C$ 中的运算门个数评定，得分计算方式见说明 / 提示部分。\n***\n\n以下是可能涉及到的定义：\n\n> **关于排列**\n>\n> 一个长度为 $n$ 的排列是元素为 $1$ 到 $n$ 中互不重复的整数的长度为 $n$ 的序列。两个排列 $p,q$ 的复合 $(p\\circ q)_i=p_{q_i}$。对于一个排列 $p$，集合 $S$ 是其置换环当且仅当 $S$ 是极小的满足 $S=\\{p_x\\mid x\\in S\\}$ 的集合。$\\operatorname{cyc}(p)$ 是排列 $p$ 的置换环个数。\n>\n> 一个排列 $p$ 的排名是字典序不大于它的排列个数，关于字典序的定义选手可以自行搜索。\n>\n> **关于电路**\n>\n> 在一个电路 $C$ 中，你有 $100$ 个变量 $x_{1\\dots 100}$ 可供使用，其中 $x_1,x_2$ 是输入信号接收 $C$ 的两个参数，$x_3$ 是输出信号在电路运行完毕后作为 $C$ 的返回值传出。初始除了 $x_1,x_2$ 每个变量的值都是 $0$。每个变量都是 $B$ 内的整数，并且运算时随时保持对 $2^w$ 取模。你可以认为电路中的变量都是 $w$ 位的自然溢出的无符号整数。\n>\n> 一个数值有以下两种表达（后将值为 $p$ 的数值记作 `#p`，不带 `#` 的字母表示普通变量）：\n> - `i`，表示变量 $x_i$。\n> - `N n`，表示十进制字面量 $n$，其中 $0\\le n<2^w$。\n>\n> 电路由若干计算门组成，所有计算门按顺序依次进行。计算门分以下七种：\n> - `i AND #p #q`，令 $x_i\\gets p\\land q$，其中 $\\land$ 是按位与运算。\n> - `i OR #p #q`，令 $x_i\\gets p\\lor q$，其中 $\\lor$ 是按位或运算。\n> - `i XOR #p #q`，令 $x_i\\gets p\\oplus q$，其中 $\\oplus$ 是按位异或运算。\n> - `i NOT #p`，令 $x_i\\gets \\lnot p$，其中 $\\lnot$ 是按位取反运算。\n> - `i LSH #p #q`，令 $x_i\\gets p\\cdot 2^q$，**其中要求 $\\bm{q<w}$**。\n> - `i RSH #p #q`，令 $x_i\\gets \\lfloor\\frac p{2^q}\\rfloor$，**其中要求 $\\bm{q<w}$**。\n> - `i POPCNT #p`，令 $x_i\\gets\\operatorname{popcount}(p)$，其中 $\\operatorname{popcount}(\\cdot)$ 表示二进制中一的个数。\n>\n> 关于各类位运算的详细定义，选手可以自行搜索。", "inputFormat": "没有任何输入。", "outputFormat": "你可以选择提交答案的生成器代码，或者直接提交答案。如果想要直接提交答案的话需要把答案文件压缩到一个 zip 文件内并使用提交文件方式提交。\n\n首先 $24$ 行，第 $i$ 行一个 $[0,2^w)$ 内的整数 $x$ 表示排名为 $i$ 的排列 $p$ 的 $f$ 值 $f(p)=x$。\n\n接下来一行一个非负整数 $L$，表示电路涉及到的计算门个数。\n\n接下来 $L$ 行，每行描述一个计算门。", "hint": "**样例解释**\n\n样例仅供演示输出格式，并没有实际意义，也不能在本题得到任何分数。\n\n样例输出中的电路 $C$ 描述了 $C(x,y)=\\operatorname{popcount}((x\\oplus y)\\lor7)$。\n\n**电路模拟**\n\n我们在下发文件中提供了一个可以计算电路的运行结果的 C++ 代码 `compiler.cpp`（需要以至少 C++ 11 标准运行），选手可以使用 `compiler.cpp` 辅助理解电路的运行模式。\n\n注意：`compiler.cpp` 仅对合法的输入有效，对不合法的输入的运行结果不做任何保证。\n\n**评分标准**\n\n若你的输出出现下列情况，那么该测试点不得分：\n\n- $\\operatorname{cyc}(p\\circ q)\\neq C(f(p),f(q))$。\n- 电路 $C$ 不合法（使用标号不在 $[1,100]$ 内的变量 / 字面量的值 $\\ge2^w$ / 出现无法识别或不合法的语句 / 使用超过 $10^4$ 个运算门 / 运算门参数不合法）。\n\n否则若你使用了 $c$ 个运算门，那么你的得分为：\n$$\\mathit{score}=\\min\\left(100,\\left\\lfloor\\frac{1315.15}{8.73+e^{0.03c}}\\right\\rfloor\\right)$$\n\n下表为在一些特殊的 $c$ 中选手在该测试点得到的分数：  \n\n| $c$ | $\\mathit{score}$ | $c$ | $\\mathit{score}$ |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| $240$ | $0$ | $90$ | $55$ |\n| $200$ | $3$ | $80$ | $66$ |\n| $160$ | $10$ | $70$ | $77$ |\n| $140$ | $17$ | $60$ | $88$ |\n| $120$ | $29$ | $50$ | $99$ |\n| $100$ | $45$ | $49$ | $100$ |\n\n这里给出得分函数的函数图像，以供参考（由 desmos 提供）。  \n\n![image](https://cdn.luogu.com.cn/upload/image_hosting/10zy6f0i.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『STA - H1』Code Golf (16bit[v])", "background": "这是问题的 16bit[v] 版本。本题与 [24bit 版本](https://www.luogu.com.cn/problem/P13087)和 [68bit 版本](https://www.luogu.com.cn/problem/P13088)的区别在于此版本中电路的位长 $w=16$。此外，另外两个版本和本题的另一个区别是本题的电路中 `LSH` 与 `RSH` 的右操作数**不**必须是字面量。", "description": "**本题为提交答案题。**\n\n以下是简要题面，关于其中名词的详细定义见后文（有些名词可能和你所见过的定义并不完全相符）。\n\n定义所有**长度为 $\\bm4$** 的排列组成的集合为 $\\mathcal P$，$w=\\color{blue}16$ 是位长，$B$ 是 $[0,2^w)$ 内的整数组成的集合。\n\n你需要设计一个**函数** $f:\\mathcal P\\to B$ 和一个**电路** $C:(B, B)\\to B$，使得对于任意 $p,q\\in\\mathcal P$ 都有：\n$$\\operatorname{cyc}(p\\circ q)=C(f(p),f(q))$$\n其中 $\\circ$ 是排列的复合，$\\operatorname{cyc}(\\cdot)$ 表示排列的置换环个数。\n\n电路 $C$ 中涉及到的运算门个数不能超过 $10^4$，得分将根据电路 $C$ 中的运算门个数评定，得分计算方式见说明 / 提示部分。\n***\n\n以下是可能涉及到的定义：\n\n> **关于排列**\n>\n> 一个长度为 $n$ 的排列是元素为 $1$ 到 $n$ 中互不重复的整数的长度为 $n$ 的序列。两个排列 $p,q$ 的复合 $(p\\circ q)_i=p_{q_i}$。对于一个排列 $p$，集合 $S$ 是其置换环当且仅当 $S$ 是极小的满足 $S=\\{p_x\\mid x\\in S\\}$ 的集合。$\\operatorname{cyc}(p)$ 是排列 $p$ 的置换环个数。\n>\n> 一个排列 $p$ 的排名是字典序不大于它的排列个数，关于字典序的定义选手可以自行搜索。\n>\n> **关于电路**\n>\n> 在一个电路 $C$ 中，你有 $100$ 个变量 $x_{1\\dots 100}$ 可供使用，其中 $x_1,x_2$ 是输入信号接收 $C$ 的两个参数，$x_3$ 是输出信号在电路运行完毕后作为 $C$ 的返回值传出。初始除了 $x_1,x_2$ 每个变量的值都是 $0$。每个变量都是 $B$ 内的整数，并且运算时随时保持对 $2^w$ 取模。你可以认为电路中的变量都是 $w$ 位的自然溢出的无符号整数。\n>\n> 一个数值有以下两种表达（后将值为 $p$ 的数值记作 `#p`，不带 `#` 的字母表示普通变量）：\n> - `i`，表示变量 $x_i$。\n> - `N n`，表示十进制字面量 $n$，其中 $0\\le n<2^w$。\n>\n> 电路由若干计算门组成，所有计算门按顺序依次进行。计算门分以下七种：\n> - `i AND #p #q`，令 $x_i\\gets p\\land q$，其中 $\\land$ 是按位与运算。\n> - `i OR #p #q`，令 $x_i\\gets p\\lor q$，其中 $\\lor$ 是按位或运算。\n> - `i XOR #p #q`，令 $x_i\\gets p\\oplus q$，其中 $\\oplus$ 是按位异或运算。\n> - `i NOT #p`，令 $x_i\\gets \\lnot p$，其中 $\\lnot$ 是按位取反运算。\n> - `i LSH #p #q`，令 $x_i\\gets p\\cdot 2^q$，**其中要求 $\\bm{q<w}$**。\n> - `i RSH #p #q`，令 $x_i\\gets \\lfloor\\frac p{2^q}\\rfloor$，**其中要求 $\\bm{q<w}$**。\n> - `i POPCNT #p`，令 $x_i\\gets\\operatorname{popcount}(p)$，其中 $\\operatorname{popcount}(\\cdot)$ 表示二进制中一的个数。\n>\n> 关于各类位运算的详细定义，选手可以自行搜索。", "inputFormat": "没有任何输入。", "outputFormat": "你可以选择提交答案的生成器代码，或者直接提交答案。如果想要直接提交答案的话需要把答案文件压缩到一个 zip 文件内并使用提交文件方式提交。\n\n首先 $24$ 行，第 $i$ 行一个 $[0,2^w)$ 内的整数 $x$ 表示排名为 $i$ 的排列 $p$ 的 $f$ 值 $f(p)=x$。\n\n接下来一行一个非负整数 $L$，表示电路涉及到的计算门个数。\n\n接下来 $L$ 行，每行描述一个计算门。", "hint": "**样例解释**\n\n样例仅供演示输出格式，并没有实际意义，也不能在本题得到任何分数。\n\n样例输出中的电路 $C$ 描述了 $C(x,y)=\\operatorname{popcount}((x\\oplus y)\\lor7)$。\n\n**电路模拟**\n\n我们在下发文件中提供了一个可以计算电路的运行结果的 C++ 代码 `compiler.cpp`（需要以至少 C++ 11 标准运行），选手可以使用 `compiler.cpp` 辅助理解电路的运行模式。\n\n注意：`compiler.cpp` 仅对合法的输入有效，对不合法的输入的运行结果不做任何保证。\n\n**评分标准**\n\n若你的输出出现下列情况，那么该测试点不得分：\n\n- $\\operatorname{cyc}(p\\circ q)\\neq C(f(p),f(q))$。\n- 电路 $C$ 不合法（使用标号不在 $[1,100]$ 内的变量 / 字面量的值 $\\ge2^w$ / 出现无法识别或不合法的语句 / 使用超过 $10^4$ 个运算门 / 运算门参数不合法）。\n\n否则若你使用了 $c$ 个运算门，那么你的得分为：\n$$\\mathit{score}=\\min\\left(100,\\left\\lfloor\\frac{1315.15}{8.73+e^{0.03c}}\\right\\rfloor\\right)$$\n\n下表为在一些特殊的 $c$ 中选手在该测试点得到的分数：  \n\n| $c$ | $\\mathit{score}$ | $c$ | $\\mathit{score}$ |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| $240$ | $0$ | $90$ | $55$ |\n| $200$ | $3$ | $80$ | $66$ |\n| $160$ | $10$ | $70$ | $77$ |\n| $140$ | $17$ | $60$ | $88$ |\n| $120$ | $29$ | $50$ | $99$ |\n| $100$ | $45$ | $49$ | $100$ |\n\n这里给出得分函数的函数图像，以供参考（由 desmos 提供）。  \n\n![image](https://cdn.luogu.com.cn/upload/image_hosting/10zy6f0i.png)", "locale": "zh-CN"}}}
{"pid": "P13087", "type": "P", "difficulty": 7, "samples": [["", "1\n2\n4\n8\n16\n32\n64\n128\n256\n512\n1024\n2048\n4096\n8192\n16384\n32768\n65536\n131072\n262144\n524288\n1048576\n2097152\n4194304\n8388608\n3\n3 XOR 1 2\n3 OR 3 N 7\n3 POPCNT 3"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["提交答案", "Special Judge", "O2优化"], "title": "『STA - H1』Code Golf (24bit)", "background": "这是问题的 24bit 版本。本题与 [68bit 版本](https://www.luogu.com.cn/problem/P13088)和 [16bit[v] 版本](https://www.luogu.com.cn/problem/P13086)的区别在于此版本中电路的位长 $w=24$。此外，[16bit[v] 版本](https://www.luogu.com.cn/problem/P13086)和本题的另一个区别是本题的电路中 `LSH` 与 `RSH` 的右操作数必须是字面量。", "description": "**本题为提交答案题。**\n\n以下是简要题面，关于其中名词的详细定义见后文（有些名词可能和你所见过的定义并不完全相符）。\n\n定义所有**长度为 $\\bm4$** 的排列组成的集合为 $\\mathcal P$，$w=\\color{blue}24$ 是位长，$B$ 是 $[0,2^w)$ 内的整数组成的集合。\n\n你需要设计一个**函数** $f:\\mathcal P\\to B$ 和一个**电路** $C:(B, B)\\to B$，使得对于任意 $p,q\\in\\mathcal P$ 都有：\n$$\\operatorname{cyc}(p\\circ q)=C(f(p),f(q))$$\n其中 $\\circ$ 是排列的复合，$\\operatorname{cyc}(\\cdot)$ 表示排列的置换环个数。\n\n电路 $C$ 中涉及到的运算门个数不能超过 $10^4$，得分将根据电路 $C$ 中的运算门个数评定，得分计算方式见说明 / 提示部分。\n***\n\n以下是可能涉及到的定义：\n\n> **关于排列**\n>\n> 一个长度为 $n$ 的排列是元素为 $1$ 到 $n$ 中互不重复的整数的长度为 $n$ 的序列。两个排列 $p,q$ 的复合 $(p\\circ q)_i=p_{q_i}$。对于一个排列 $p$，集合 $S$ 是其置换环当且仅当 $S$ 是极小的满足 $S=\\{p_x\\mid x\\in S\\}$ 的集合。$\\operatorname{cyc}(p)$ 是排列 $p$ 的置换环个数。\n>\n> 一个排列 $p$ 的排名是字典序不大于它的排列个数，关于字典序的定义选手可以自行搜索。\n>\n> **关于电路**\n>\n> 在一个电路 $C$ 中，你有 $100$ 个变量 $x_{1\\dots 100}$ 可供使用，其中 $x_1,x_2$ 是输入信号接收 $C$ 的两个参数，$x_3$ 是输出信号在电路运行完毕后作为 $C$ 的返回值传出。初始除了 $x_1,x_2$ 每个变量的值都是 $0$。每个变量都是 $B$ 内的整数，并且运算时随时保持对 $2^w$ 取模。你可以认为电路中的变量都是 $w$ 位的自然溢出的无符号整数。\n>\n> 一个数值有以下两种表达（后将值为 $p$ 的数值记作 `#p`，不带 `#` 的字母表示普通变量）：\n> - `i`，表示变量 $x_i$。\n> - `N n`，表示十进制字面量 $n$，其中 $0\\le n<2^w$。\n>\n> 电路由若干计算门组成，所有计算门按顺序依次进行。计算门分以下七种：\n> - `i AND #p #q`，令 $x_i\\gets p\\land q$，其中 $\\land$ 是按位与运算。\n> - `i OR #p #q`，令 $x_i\\gets p\\lor q$，其中 $\\lor$ 是按位或运算。\n> - `i XOR #p #q`，令 $x_i\\gets p\\oplus q$，其中 $\\oplus$ 是按位异或运算。\n> - `i NOT #p`，令 $x_i\\gets \\lnot p$，其中 $\\lnot$ 是按位取反运算。\n> - `i LSH #p #q`，令 $x_i\\gets p\\cdot 2^q$，**其中要求 $\\bm{q<w}$ 且 $\\bm q$ 必须是字面量**。\n> - `i RSH #p #q`，令 $x_i\\gets \\lfloor\\frac p{2^q}\\rfloor$，**其中要求 $\\bm{q<w}$ 且 $\\bm q$ 必须是字面量**。\n> - `i POPCNT #p`，令 $x_i\\gets\\operatorname{popcount}(p)$，其中 $\\operatorname{popcount}(\\cdot)$ 表示二进制中一的个数。\n>\n> 关于各类位运算的详细定义，选手可以自行搜索。", "inputFormat": "没有任何输入。", "outputFormat": "你可以选择提交答案的生成器代码，或者直接提交答案。如果想要直接提交答案的话需要把答案文件压缩到一个 zip 文件内并使用提交文件方式提交。\n\n首先 $24$ 行，第 $i$ 行一个 $[0,2^w)$ 内的整数 $x$ 表示排名为 $i$ 的排列 $p$ 的 $f$ 值 $f(p)=x$。\n\n接下来一行一个非负整数 $L$，表示电路涉及到的计算门个数。\n\n接下来 $L$ 行，每行描述一个计算门。", "hint": "**样例解释**\n\n样例仅供演示输出格式，并没有实际意义，也不能在本题得到任何分数。\n\n样例输出中的电路 $C$ 描述了 $C(x,y)=\\operatorname{popcount}((x\\oplus y)\\lor7)$。\n\n**电路模拟**\n\n我们在下发文件中提供了一个可以计算电路的运行结果的 C++ 代码 `compiler.cpp`（需要以至少 C++ 11 标准运行），选手可以使用 `compiler.cpp` 辅助理解电路的运行模式。\n\n注意：`compiler.cpp` 仅对合法的输入有效，对不合法的输入的运行结果不做任何保证。\n\n**评分标准**\n\n若你的输出出现下列情况，那么该测试点不得分：\n\n- $\\operatorname{cyc}(p\\circ q)\\neq C(f(p),f(q))$。\n- 电路 $C$ 不合法（使用标号不在 $[1,100]$ 内的变量 / 字面量的值 $\\ge2^w$ / 出现无法识别或不合法的语句 / 使用超过 $10^4$ 个运算门 / 运算门参数不合法）。\n\n否则若你使用了 $c$ 个运算门，那么你的得分为：\n\n$$\\mathrm{score}=\\begin{cases}100&c\\le 24\\\\\\left\\lfloor15.25\\log_{30}\\left(\\frac{0.09}{c-23}\\right)+111\\right\\rfloor&24<c\\le30\\\\\\left\\lceil-0.16c+95\\right\\rceil&30<c\\le350\\\\\\left\\lceil49\\cdot0.9994^{c}\\right\\rceil&350<c\\le10^4\\\\0&c>10^4\\end{cases}$$\n\n下表为在一些特殊的 $c$ 中选手在该测试点得到的分数：\n\n| $c$ | $\\mathrm{score}$ | $c$ | $\\mathrm{score}$ |\n| :---: | :---: | :---: | :---: |\n| $10^4$ | $1$ | $300$ | $47$ |\n| $6000$ | $2$ | $200$ | $63$ |\n| $5000$ | $3$ | $100$ | $79$ |\n| $3000$ | $9$ | $80$ | $83$ |\n| $2000$ | $15$ | $50$ | $87$ |\n| $1000$ | $27$ | $30$ | $91$ |\n| $700$ | $33$ | $25$ | $97$ |\n| $500$ | $37$ | $24$ | $100$ |\n\n这里给出 $c>24$ 时两张得分函数缩放不同的图像，以供参考（由 desmos 提供）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n9l07rb3.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nxrlgckv.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『STA - H1』Code Golf (24bit)", "background": "这是问题的 24bit 版本。本题与 [68bit 版本](https://www.luogu.com.cn/problem/P13088)和 [16bit[v] 版本](https://www.luogu.com.cn/problem/P13086)的区别在于此版本中电路的位长 $w=24$。此外，[16bit[v] 版本](https://www.luogu.com.cn/problem/P13086)和本题的另一个区别是本题的电路中 `LSH` 与 `RSH` 的右操作数必须是字面量。", "description": "**本题为提交答案题。**\n\n以下是简要题面，关于其中名词的详细定义见后文（有些名词可能和你所见过的定义并不完全相符）。\n\n定义所有**长度为 $\\bm4$** 的排列组成的集合为 $\\mathcal P$，$w=\\color{blue}24$ 是位长，$B$ 是 $[0,2^w)$ 内的整数组成的集合。\n\n你需要设计一个**函数** $f:\\mathcal P\\to B$ 和一个**电路** $C:(B, B)\\to B$，使得对于任意 $p,q\\in\\mathcal P$ 都有：\n$$\\operatorname{cyc}(p\\circ q)=C(f(p),f(q))$$\n其中 $\\circ$ 是排列的复合，$\\operatorname{cyc}(\\cdot)$ 表示排列的置换环个数。\n\n电路 $C$ 中涉及到的运算门个数不能超过 $10^4$，得分将根据电路 $C$ 中的运算门个数评定，得分计算方式见说明 / 提示部分。\n***\n\n以下是可能涉及到的定义：\n\n> **关于排列**\n>\n> 一个长度为 $n$ 的排列是元素为 $1$ 到 $n$ 中互不重复的整数的长度为 $n$ 的序列。两个排列 $p,q$ 的复合 $(p\\circ q)_i=p_{q_i}$。对于一个排列 $p$，集合 $S$ 是其置换环当且仅当 $S$ 是极小的满足 $S=\\{p_x\\mid x\\in S\\}$ 的集合。$\\operatorname{cyc}(p)$ 是排列 $p$ 的置换环个数。\n>\n> 一个排列 $p$ 的排名是字典序不大于它的排列个数，关于字典序的定义选手可以自行搜索。\n>\n> **关于电路**\n>\n> 在一个电路 $C$ 中，你有 $100$ 个变量 $x_{1\\dots 100}$ 可供使用，其中 $x_1,x_2$ 是输入信号接收 $C$ 的两个参数，$x_3$ 是输出信号在电路运行完毕后作为 $C$ 的返回值传出。初始除了 $x_1,x_2$ 每个变量的值都是 $0$。每个变量都是 $B$ 内的整数，并且运算时随时保持对 $2^w$ 取模。你可以认为电路中的变量都是 $w$ 位的自然溢出的无符号整数。\n>\n> 一个数值有以下两种表达（后将值为 $p$ 的数值记作 `#p`，不带 `#` 的字母表示普通变量）：\n> - `i`，表示变量 $x_i$。\n> - `N n`，表示十进制字面量 $n$，其中 $0\\le n<2^w$。\n>\n> 电路由若干计算门组成，所有计算门按顺序依次进行。计算门分以下七种：\n> - `i AND #p #q`，令 $x_i\\gets p\\land q$，其中 $\\land$ 是按位与运算。\n> - `i OR #p #q`，令 $x_i\\gets p\\lor q$，其中 $\\lor$ 是按位或运算。\n> - `i XOR #p #q`，令 $x_i\\gets p\\oplus q$，其中 $\\oplus$ 是按位异或运算。\n> - `i NOT #p`，令 $x_i\\gets \\lnot p$，其中 $\\lnot$ 是按位取反运算。\n> - `i LSH #p #q`，令 $x_i\\gets p\\cdot 2^q$，**其中要求 $\\bm{q<w}$ 且 $\\bm q$ 必须是字面量**。\n> - `i RSH #p #q`，令 $x_i\\gets \\lfloor\\frac p{2^q}\\rfloor$，**其中要求 $\\bm{q<w}$ 且 $\\bm q$ 必须是字面量**。\n> - `i POPCNT #p`，令 $x_i\\gets\\operatorname{popcount}(p)$，其中 $\\operatorname{popcount}(\\cdot)$ 表示二进制中一的个数。\n>\n> 关于各类位运算的详细定义，选手可以自行搜索。", "inputFormat": "没有任何输入。", "outputFormat": "你可以选择提交答案的生成器代码，或者直接提交答案。如果想要直接提交答案的话需要把答案文件压缩到一个 zip 文件内并使用提交文件方式提交。\n\n首先 $24$ 行，第 $i$ 行一个 $[0,2^w)$ 内的整数 $x$ 表示排名为 $i$ 的排列 $p$ 的 $f$ 值 $f(p)=x$。\n\n接下来一行一个非负整数 $L$，表示电路涉及到的计算门个数。\n\n接下来 $L$ 行，每行描述一个计算门。", "hint": "**样例解释**\n\n样例仅供演示输出格式，并没有实际意义，也不能在本题得到任何分数。\n\n样例输出中的电路 $C$ 描述了 $C(x,y)=\\operatorname{popcount}((x\\oplus y)\\lor7)$。\n\n**电路模拟**\n\n我们在下发文件中提供了一个可以计算电路的运行结果的 C++ 代码 `compiler.cpp`（需要以至少 C++ 11 标准运行），选手可以使用 `compiler.cpp` 辅助理解电路的运行模式。\n\n注意：`compiler.cpp` 仅对合法的输入有效，对不合法的输入的运行结果不做任何保证。\n\n**评分标准**\n\n若你的输出出现下列情况，那么该测试点不得分：\n\n- $\\operatorname{cyc}(p\\circ q)\\neq C(f(p),f(q))$。\n- 电路 $C$ 不合法（使用标号不在 $[1,100]$ 内的变量 / 字面量的值 $\\ge2^w$ / 出现无法识别或不合法的语句 / 使用超过 $10^4$ 个运算门 / 运算门参数不合法）。\n\n否则若你使用了 $c$ 个运算门，那么你的得分为：\n\n$$\\mathrm{score}=\\begin{cases}100&c\\le 24\\\\\\left\\lfloor15.25\\log_{30}\\left(\\frac{0.09}{c-23}\\right)+111\\right\\rfloor&24<c\\le30\\\\\\left\\lceil-0.16c+95\\right\\rceil&30<c\\le350\\\\\\left\\lceil49\\cdot0.9994^{c}\\right\\rceil&350<c\\le10^4\\\\0&c>10^4\\end{cases}$$\n\n下表为在一些特殊的 $c$ 中选手在该测试点得到的分数：\n\n| $c$ | $\\mathrm{score}$ | $c$ | $\\mathrm{score}$ |\n| :---: | :---: | :---: | :---: |\n| $10^4$ | $1$ | $300$ | $47$ |\n| $6000$ | $2$ | $200$ | $63$ |\n| $5000$ | $3$ | $100$ | $79$ |\n| $3000$ | $9$ | $80$ | $83$ |\n| $2000$ | $15$ | $50$ | $87$ |\n| $1000$ | $27$ | $30$ | $91$ |\n| $700$ | $33$ | $25$ | $97$ |\n| $500$ | $37$ | $24$ | $100$ |\n\n这里给出 $c>24$ 时两张得分函数缩放不同的图像，以供参考（由 desmos 提供）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n9l07rb3.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nxrlgckv.png)", "locale": "zh-CN"}}}
{"pid": "P13088", "type": "P", "difficulty": 7, "samples": [["", "1\n2\n4\n8\n16\n32\n64\n128\n256\n512\n1024\n2048\n4096\n8192\n16384\n32768\n65536\n131072\n262144\n524288\n1048576\n2097152\n4194304\n8388608\n3\n3 XOR 1 2\n3 OR 3 N 7\n3 POPCNT 3"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["提交答案", "Special Judge", "O2优化"], "title": "『STA - H1』Code Golf (68bit)", "background": "这是问题的 68bit 版本。本题与 [24bit 版本](https://www.luogu.com.cn/problem/P13087)和 [16bit[v] 版本](https://www.luogu.com.cn/problem/P13086)的区别在于此版本中电路的位长 $w=68$。此外，[16bit[v] 版本](https://www.luogu.com.cn/problem/P13086)和本题的另一个区别是本题的电路中 `LSH` 与 `RSH` 的右操作数必须是字面量。", "description": "**本题为提交答案题。**\n\n以下是简要题面，关于其中名词的详细定义见后文（有些名词可能和你所见过的定义并不完全相符）。\n\n定义所有**长度为 $\\bm4$** 的排列组成的集合为 $\\mathcal P$，$w=\\color{blue}68$ 是位长，$B$ 是 $[0,2^w)$ 内的整数组成的集合。\n\n你需要设计一个**函数** $f:\\mathcal P\\to B$ 和一个**电路** $C:(B, B)\\to B$，使得对于任意 $p,q\\in\\mathcal P$ 都有：\n$$\\operatorname{cyc}(p\\circ q)=C(f(p),f(q))$$\n其中 $\\circ$ 是排列的复合，$\\operatorname{cyc}(\\cdot)$ 表示排列的置换环个数。\n\n电路 $C$ 中涉及到的运算门个数不能超过 $10^4$，得分将根据电路 $C$ 中的运算门个数评定，得分计算方式见说明 / 提示部分。\n***\n\n以下是可能涉及到的定义：\n\n> **关于排列**\n>\n> 一个长度为 $n$ 的排列是元素为 $1$ 到 $n$ 中互不重复的整数的长度为 $n$ 的序列。两个排列 $p,q$ 的复合 $(p\\circ q)_i=p_{q_i}$。对于一个排列 $p$，集合 $S$ 是其置换环当且仅当 $S$ 是极小的满足 $S=\\{p_x\\mid x\\in S\\}$ 的集合。$\\operatorname{cyc}(p)$ 是排列 $p$ 的置换环个数。\n>\n> 一个排列 $p$ 的排名是字典序不大于它的排列个数，关于字典序的定义选手可以自行搜索。\n>\n> **关于电路**\n>\n> 在一个电路 $C$ 中，你有 $100$ 个变量 $x_{1\\dots 100}$ 可供使用，其中 $x_1,x_2$ 是输入信号接收 $C$ 的两个参数，$x_3$ 是输出信号在电路运行完毕后作为 $C$ 的返回值传出。初始除了 $x_1,x_2$ 每个变量的值都是 $0$。每个变量都是 $B$ 内的整数，并且运算时随时保持对 $2^w$ 取模。你可以认为电路中的变量都是 $w$ 位的自然溢出的无符号整数。\n>\n> 一个数值有以下两种表达（后将值为 $p$ 的数值记作 `#p`，不带 `#` 的字母表示普通变量）：\n> - `i`，表示变量 $x_i$。\n> - `N n`，表示十进制字面量 $n$，其中 $0\\le n<2^w$。\n>\n> 电路由若干计算门组成，所有计算门按顺序依次进行。计算门分以下七种：\n> - `i AND #p #q`，令 $x_i\\gets p\\land q$，其中 $\\land$ 是按位与运算。\n> - `i OR #p #q`，令 $x_i\\gets p\\lor q$，其中 $\\lor$ 是按位或运算。\n> - `i XOR #p #q`，令 $x_i\\gets p\\oplus q$，其中 $\\oplus$ 是按位异或运算。\n> - `i NOT #p`，令 $x_i\\gets \\lnot p$，其中 $\\lnot$ 是按位取反运算。\n> - `i LSH #p #q`，令 $x_i\\gets p\\cdot 2^q$，**其中要求 $\\bm{q<w}$ 且 $\\bm q$ 必须是字面量**。\n> - `i RSH #p #q`，令 $x_i\\gets \\lfloor\\frac p{2^q}\\rfloor$，**其中要求 $\\bm{q<w}$ 且 $\\bm q$ 必须是字面量**。\n> - `i POPCNT #p`，令 $x_i\\gets\\operatorname{popcount}(p)$，其中 $\\operatorname{popcount}(\\cdot)$ 表示二进制中一的个数。\n>\n> 关于各类位运算的详细定义，选手可以自行搜索。", "inputFormat": "没有任何输入。", "outputFormat": "你可以选择提交答案的生成器代码，或者直接提交答案。如果想要直接提交答案的话需要把答案文件压缩到一个 zip 文件内并使用提交文件方式提交。\n\n首先 $24$ 行，第 $i$ 行一个 $[0,2^w)$ 内的整数 $x$ 表示排名为 $i$ 的排列 $p$ 的 $f$ 值 $f(p)=x$。\n\n接下来一行一个非负整数 $L$，表示电路涉及到的计算门个数。\n\n接下来 $L$ 行，每行描述一个计算门。", "hint": "**样例解释**\n\n样例仅供演示输出格式，并没有实际意义，也不能在本题得到任何分数。\n\n样例输出中的电路 $C$ 描述了 $C(x,y)=\\operatorname{popcount}((x\\oplus y)\\lor7)$。\n\n**电路模拟**\n\n我们在下发文件中提供了一个可以计算电路的运行结果的 C++ 代码 `compiler.cpp`（需要以 GCC、至少 C++ 11 标准运行），选手可以使用 `compiler.cpp` 辅助理解电路的运行模式。\n\n注意：`compiler.cpp` 仅对合法的输入有效，对不合法的输入的运行结果不做任何保证。\n\n**评分标准**\n\n若你的输出出现下列情况，那么该测试点不得分：\n\n- $\\operatorname{cyc}(p\\circ q)\\neq C(f(p),f(q))$。\n- 电路 $C$ 不合法（使用标号不在 $[1,100]$ 内的变量 / 字面量的值 $\\ge2^w$ / 出现无法识别或不合法的语句 / 使用超过 $10^4$ 个运算门 / 运算门参数不合法）。\n\n否则若你使用了 $c$ 个运算门，那么你的得分为：\n\n$$\\mathrm{score}=\\left\\lfloor\\frac{500}{\\max\\{5,\\min\\{500,x\\}\\}}\\right\\rfloor$$\n\n提示：如果 $c\\le5$，你的得分 $\\mathrm{score}=100$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『STA - H1』Code Golf (68bit)", "background": "这是问题的 68bit 版本。本题与 [24bit 版本](https://www.luogu.com.cn/problem/P13087)和 [16bit[v] 版本](https://www.luogu.com.cn/problem/P13086)的区别在于此版本中电路的位长 $w=68$。此外，[16bit[v] 版本](https://www.luogu.com.cn/problem/P13086)和本题的另一个区别是本题的电路中 `LSH` 与 `RSH` 的右操作数必须是字面量。", "description": "**本题为提交答案题。**\n\n以下是简要题面，关于其中名词的详细定义见后文（有些名词可能和你所见过的定义并不完全相符）。\n\n定义所有**长度为 $\\bm4$** 的排列组成的集合为 $\\mathcal P$，$w=\\color{blue}68$ 是位长，$B$ 是 $[0,2^w)$ 内的整数组成的集合。\n\n你需要设计一个**函数** $f:\\mathcal P\\to B$ 和一个**电路** $C:(B, B)\\to B$，使得对于任意 $p,q\\in\\mathcal P$ 都有：\n$$\\operatorname{cyc}(p\\circ q)=C(f(p),f(q))$$\n其中 $\\circ$ 是排列的复合，$\\operatorname{cyc}(\\cdot)$ 表示排列的置换环个数。\n\n电路 $C$ 中涉及到的运算门个数不能超过 $10^4$，得分将根据电路 $C$ 中的运算门个数评定，得分计算方式见说明 / 提示部分。\n***\n\n以下是可能涉及到的定义：\n\n> **关于排列**\n>\n> 一个长度为 $n$ 的排列是元素为 $1$ 到 $n$ 中互不重复的整数的长度为 $n$ 的序列。两个排列 $p,q$ 的复合 $(p\\circ q)_i=p_{q_i}$。对于一个排列 $p$，集合 $S$ 是其置换环当且仅当 $S$ 是极小的满足 $S=\\{p_x\\mid x\\in S\\}$ 的集合。$\\operatorname{cyc}(p)$ 是排列 $p$ 的置换环个数。\n>\n> 一个排列 $p$ 的排名是字典序不大于它的排列个数，关于字典序的定义选手可以自行搜索。\n>\n> **关于电路**\n>\n> 在一个电路 $C$ 中，你有 $100$ 个变量 $x_{1\\dots 100}$ 可供使用，其中 $x_1,x_2$ 是输入信号接收 $C$ 的两个参数，$x_3$ 是输出信号在电路运行完毕后作为 $C$ 的返回值传出。初始除了 $x_1,x_2$ 每个变量的值都是 $0$。每个变量都是 $B$ 内的整数，并且运算时随时保持对 $2^w$ 取模。你可以认为电路中的变量都是 $w$ 位的自然溢出的无符号整数。\n>\n> 一个数值有以下两种表达（后将值为 $p$ 的数值记作 `#p`，不带 `#` 的字母表示普通变量）：\n> - `i`，表示变量 $x_i$。\n> - `N n`，表示十进制字面量 $n$，其中 $0\\le n<2^w$。\n>\n> 电路由若干计算门组成，所有计算门按顺序依次进行。计算门分以下七种：\n> - `i AND #p #q`，令 $x_i\\gets p\\land q$，其中 $\\land$ 是按位与运算。\n> - `i OR #p #q`，令 $x_i\\gets p\\lor q$，其中 $\\lor$ 是按位或运算。\n> - `i XOR #p #q`，令 $x_i\\gets p\\oplus q$，其中 $\\oplus$ 是按位异或运算。\n> - `i NOT #p`，令 $x_i\\gets \\lnot p$，其中 $\\lnot$ 是按位取反运算。\n> - `i LSH #p #q`，令 $x_i\\gets p\\cdot 2^q$，**其中要求 $\\bm{q<w}$ 且 $\\bm q$ 必须是字面量**。\n> - `i RSH #p #q`，令 $x_i\\gets \\lfloor\\frac p{2^q}\\rfloor$，**其中要求 $\\bm{q<w}$ 且 $\\bm q$ 必须是字面量**。\n> - `i POPCNT #p`，令 $x_i\\gets\\operatorname{popcount}(p)$，其中 $\\operatorname{popcount}(\\cdot)$ 表示二进制中一的个数。\n>\n> 关于各类位运算的详细定义，选手可以自行搜索。", "inputFormat": "没有任何输入。", "outputFormat": "你可以选择提交答案的生成器代码，或者直接提交答案。如果想要直接提交答案的话需要把答案文件压缩到一个 zip 文件内并使用提交文件方式提交。\n\n首先 $24$ 行，第 $i$ 行一个 $[0,2^w)$ 内的整数 $x$ 表示排名为 $i$ 的排列 $p$ 的 $f$ 值 $f(p)=x$。\n\n接下来一行一个非负整数 $L$，表示电路涉及到的计算门个数。\n\n接下来 $L$ 行，每行描述一个计算门。", "hint": "**样例解释**\n\n样例仅供演示输出格式，并没有实际意义，也不能在本题得到任何分数。\n\n样例输出中的电路 $C$ 描述了 $C(x,y)=\\operatorname{popcount}((x\\oplus y)\\lor7)$。\n\n**电路模拟**\n\n我们在下发文件中提供了一个可以计算电路的运行结果的 C++ 代码 `compiler.cpp`（需要以 GCC、至少 C++ 11 标准运行），选手可以使用 `compiler.cpp` 辅助理解电路的运行模式。\n\n注意：`compiler.cpp` 仅对合法的输入有效，对不合法的输入的运行结果不做任何保证。\n\n**评分标准**\n\n若你的输出出现下列情况，那么该测试点不得分：\n\n- $\\operatorname{cyc}(p\\circ q)\\neq C(f(p),f(q))$。\n- 电路 $C$ 不合法（使用标号不在 $[1,100]$ 内的变量 / 字面量的值 $\\ge2^w$ / 出现无法识别或不合法的语句 / 使用超过 $10^4$ 个运算门 / 运算门参数不合法）。\n\n否则若你使用了 $c$ 个运算门，那么你的得分为：\n\n$$\\mathrm{score}=\\left\\lfloor\\frac{500}{\\max\\{5,\\min\\{500,x\\}\\}}\\right\\rfloor$$\n\n提示：如果 $c\\le5$，你的得分 $\\mathrm{score}=100$。", "locale": "zh-CN"}}}
{"pid": "P13089", "type": "P", "difficulty": 7, "samples": [["5\nabb\n1 1 3 1 2\noixcpc\n1 1 4 5 1 4 1 9\ntarjen\n1 1 1 1 1 1 1\nnanani\n1 1 1 1 1 1 1\nwildfire\n1 1 1 1 1 1 1 1 1 1\n", "13\n109\n21\n21\n36"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "福建", "省赛/邀请赛"], "title": "[FJCPC 2025] We are watching you!", "background": "作弊哥是一个资深代打高手，他经常在 OCASU、oaiqnal、CPCX 等各种编程比赛中替别人代写代码，赚取了丰厚的收入。在比赛过程中，作弊哥会将题目的正确代码 $s_1$ 发送给作弊的参赛选手；这个参赛选手会在代码的 开头 随便加点没用的东西，构造出完整代码 $s$，就能提交。\n\n作弊哥靠着这招屡试不爽。然而，这一次他不幸被官方盯上了。\n\n作为官方的技术审查专家，小 A 需要对于选手提交的代码 $s$，分析 $s$ 的任意一个后缀的代码风格有多大概率出自于作弊哥。为了方便检验代码的同时，尽量不影响评测机速度，小 A 构造了一个能接受所有 $s$ 后缀的最小化确定型有限状态自动机（Deterministic Finite Automaton，DFA）。\n\n接下来，小 A 按深度优先搜索的方法，遍历这个 DFA，并分析出状态 $i$ 和作弊哥的代码风格有 $c_i$ 点相似度。小 A 认为子串 $s'$ 的相似度为 DFA 在输出 $s'$ 的过程中，经过状态的最大相似度；而完整代码的相似度为其所有非空子串相似度的平均值。\n\n现在，小 A 拿到了一些选手的完整代码 $s$，依此构建了最小化 DFA，并按深度优先搜索的遍历方法给出了 DFA 各状态的相似度。请你帮忙评估这些代码和作弊哥代码的相似度。\n\n如果你不了解 DFA 以及 DFA 的深度优先遍历，请阅读补充提示。\n\n", "description": "形式化的，以下代码描述了上述过程以及需求，但由于过大的时间复杂度，需要你优化并使其可以通过本题。\n\n```cpp\n#include <bits/stdc++.h>\nusing i64 = long long;\nstruct SAM {\n    struct Node {\n        int fa, len;\n        std::array<int, 26> trans; \n        Node() : fa{}, len{}, trans{} {}\n    };\n    std::vector<Node> t;\n    SAM() : t(2) {}\n    int New() {\n        t.push_back(Node());\n        return t.size() - 1;\n    }\n    int extend(int lst, int c) {\n        int u = lst, v;\n        if (trans(u, c)) {\n            if (len(u) + 1 == len(v = trans(u, c))) {\n                return v;\n            }\n            int x = New();\n            len(x) = len(u) + 1, fa(x) = fa(v);\n            t[x].trans = t[v].trans;\n            for (fa(v) = x; u && trans(u, c) == v; trans(u, c) = x, u = fa(u));\n            return x;\n        }\n        int x = New();\n        len(x) = len(u) + 1;\n        for(; u && !trans(u, c); trans(u, c) = x, u = fa(u));\n        if (!u) {\n            fa(x) = 1;\n        } else if (len(u) + 1 == len(v = trans(u, c))) {\n            fa(x) = v;\n        } else {\n            int w = New();\n            len(w) = len(u) + 1, fa(w) = fa(v);\n            t[w].trans = t[v].trans;\n            for (fa(v) = fa(x) = w; u && trans(u, c) == v; trans(u, c) = w, u = fa(u));\n        }\n        return x;\n    }\n    int& fa(int x) { return t[x].fa; }\n    int& len(int x) { return t[x].len; }\n    int& trans(int x, int c) { return t[x].trans[c]; }\n};\n\nvoid solve() {\n    std::string s;\n    std::cin >> s;\n    SAM sam;\n    int lst = 1;\n    for (auto c : s) {  // 请注意这里是建立后缀自动机\n        lst = sam.extend(lst, c - 'a');\n    }\n    std::vector<int> c(sam.t.size());\n    for (int i = 1; i < c.size(); i++) {\n        std::cin >> c[i];\n    }\n    i64 ans = 0;\n    for (int i = 0; i < s.size(); i++) {\n        int now = c[1], x = 1;\n        for (int j = i; j >= 0; j--) {\n            x = sam.trans(x, s[j] - 'a');\n            now = std::max(now, c[x]);\n            ans += now;\n        }\n    }\n    std::cout << ans << std::endl;\n}\nint main() {\n    int T;\n    std::cin >> T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```", "inputFormat": "本题包含多组测试数据。\n\n第一行是一个正整数 $T$（$1\\leq T\\leq 2\\times 10^5$），表示有 $T$ 份完整代码。\n\n接下来 $T$ 组数据。第一行是一个由小写字母组成的字符串 $S$，表示选手提交的代码。保证字符串长度 $|S|$ 满足（$1\\leq |S|\\leq 2\\times 10^5$）。\n\n第二行由 $m$ 个整数 $c_1, c_2, \\cdots, c_m$（$1\\leq c_i\\leq 2\\times 10^5$）构成。其中 $m$ 表示小 A 构造的最小化 DFA 的状态数，$c_i$ 表示这个 DFA 按深度优先搜索，访问到的第 $i$ 个状态的相似度。\n\n数据保证 $\\sum|S|\\leq 2\\times 10^5$；数据保证对于每组的字符串 $S$，其所有后缀构成的最小化 DFA 状态数恰好为 $m$。", "outputFormat": "输出包含 $T$ 行，其中第 $i$ 行表示第 $i$ 份代码的相似度。\n\n为了避免除法运算，对于每个提问 $S$，你只需要输出答案乘上 $\\frac{|S|\\cdot (|S|+1)}{2}$，答案可以保证这是个整数。", "hint": "1. 确定型有限状态自动机（DFA）\n\n确定型有限状态自动机（DFA）是一个状态机。它从固定的起始状态 $q_0$ 出发，不断读入字符 $c$，并不断依此跳到后续状态；读入不同的字符将会跳转到不同的后续状态。如果读入完整个字符串后停在\"接受状态\"，我们认为 DFA 接受这个字符串；否则，认为 DFA 不接受这个字符串。特别的，如果 DFA 在某个状态 $q$ 时读入字符 $c$ 无后续状态，我们同样认为 DFA 不接受这个字符串。\n\n如下图所示，带两个圆的状态为接受状态。左侧的 DFA 从初始状态 $q_0$ 开始，读入 abab、bab、ab、b 后会分别停止于 $q_4, q_7, q_2, q_5$，均是接受状态；且读入其他字符串均不能进入接受状态。因此左侧的 DFA 可以接受 abab 的所有后缀；右侧的同理。\n\n对于能识别相同字符串的所有 DFA，我们认为状态最少的 DFA 就是最小化 DFA。可以证明，不同的最小化 DFA 可以通过给状态重新编号，而变成相同的 DFA。\n\n如该图所示，左右两侧的 DFA 均只能接受 abab、bab、ab、b 这四个字符串，因此两者等价。此外，可以证明，右侧的 DFA 是能识别这类字符串的最小化 DFA。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zpo9dm5b.png)\n\n2. DFA 的深度优先遍历\n\nDFA 的深度优先遍历将从起始状态 $q_0$ 开始，每次选择当前状态未访问的、按字母表从小到大的下一个字符对应的边，直到遍历完所有状态。各状态的编号即为其被访问到的顺序。\n\n如左侧的 DFA 的深度优先遍历顺序为 $q_0, q_1, q_2, q_3, q_4, q_5, q_6, q_7$；\n\n右侧 DFA 的深度优先遍历顺序为 $q_0, q_1, q_2, q_3, q_4$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[FJCPC 2025] We are watching you!", "background": "作弊哥是一个资深代打高手，他经常在 OCASU、oaiqnal、CPCX 等各种编程比赛中替别人代写代码，赚取了丰厚的收入。在比赛过程中，作弊哥会将题目的正确代码 $s_1$ 发送给作弊的参赛选手；这个参赛选手会在代码的 开头 随便加点没用的东西，构造出完整代码 $s$，就能提交。\n\n作弊哥靠着这招屡试不爽。然而，这一次他不幸被官方盯上了。\n\n作为官方的技术审查专家，小 A 需要对于选手提交的代码 $s$，分析 $s$ 的任意一个后缀的代码风格有多大概率出自于作弊哥。为了方便检验代码的同时，尽量不影响评测机速度，小 A 构造了一个能接受所有 $s$ 后缀的最小化确定型有限状态自动机（Deterministic Finite Automaton，DFA）。\n\n接下来，小 A 按深度优先搜索的方法，遍历这个 DFA，并分析出状态 $i$ 和作弊哥的代码风格有 $c_i$ 点相似度。小 A 认为子串 $s'$ 的相似度为 DFA 在输出 $s'$ 的过程中，经过状态的最大相似度；而完整代码的相似度为其所有非空子串相似度的平均值。\n\n现在，小 A 拿到了一些选手的完整代码 $s$，依此构建了最小化 DFA，并按深度优先搜索的遍历方法给出了 DFA 各状态的相似度。请你帮忙评估这些代码和作弊哥代码的相似度。\n\n如果你不了解 DFA 以及 DFA 的深度优先遍历，请阅读补充提示。\n\n", "description": "形式化的，以下代码描述了上述过程以及需求，但由于过大的时间复杂度，需要你优化并使其可以通过本题。\n\n```cpp\n#include <bits/stdc++.h>\nusing i64 = long long;\nstruct SAM {\n    struct Node {\n        int fa, len;\n        std::array<int, 26> trans; \n        Node() : fa{}, len{}, trans{} {}\n    };\n    std::vector<Node> t;\n    SAM() : t(2) {}\n    int New() {\n        t.push_back(Node());\n        return t.size() - 1;\n    }\n    int extend(int lst, int c) {\n        int u = lst, v;\n        if (trans(u, c)) {\n            if (len(u) + 1 == len(v = trans(u, c))) {\n                return v;\n            }\n            int x = New();\n            len(x) = len(u) + 1, fa(x) = fa(v);\n            t[x].trans = t[v].trans;\n            for (fa(v) = x; u && trans(u, c) == v; trans(u, c) = x, u = fa(u));\n            return x;\n        }\n        int x = New();\n        len(x) = len(u) + 1;\n        for(; u && !trans(u, c); trans(u, c) = x, u = fa(u));\n        if (!u) {\n            fa(x) = 1;\n        } else if (len(u) + 1 == len(v = trans(u, c))) {\n            fa(x) = v;\n        } else {\n            int w = New();\n            len(w) = len(u) + 1, fa(w) = fa(v);\n            t[w].trans = t[v].trans;\n            for (fa(v) = fa(x) = w; u && trans(u, c) == v; trans(u, c) = w, u = fa(u));\n        }\n        return x;\n    }\n    int& fa(int x) { return t[x].fa; }\n    int& len(int x) { return t[x].len; }\n    int& trans(int x, int c) { return t[x].trans[c]; }\n};\n\nvoid solve() {\n    std::string s;\n    std::cin >> s;\n    SAM sam;\n    int lst = 1;\n    for (auto c : s) {  // 请注意这里是建立后缀自动机\n        lst = sam.extend(lst, c - 'a');\n    }\n    std::vector<int> c(sam.t.size());\n    for (int i = 1; i < c.size(); i++) {\n        std::cin >> c[i];\n    }\n    i64 ans = 0;\n    for (int i = 0; i < s.size(); i++) {\n        int now = c[1], x = 1;\n        for (int j = i; j >= 0; j--) {\n            x = sam.trans(x, s[j] - 'a');\n            now = std::max(now, c[x]);\n            ans += now;\n        }\n    }\n    std::cout << ans << std::endl;\n}\nint main() {\n    int T;\n    std::cin >> T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```", "inputFormat": "本题包含多组测试数据。\n\n第一行是一个正整数 $T$（$1\\leq T\\leq 2\\times 10^5$），表示有 $T$ 份完整代码。\n\n接下来 $T$ 组数据。第一行是一个由小写字母组成的字符串 $S$，表示选手提交的代码。保证字符串长度 $|S|$ 满足（$1\\leq |S|\\leq 2\\times 10^5$）。\n\n第二行由 $m$ 个整数 $c_1, c_2, \\cdots, c_m$（$1\\leq c_i\\leq 2\\times 10^5$）构成。其中 $m$ 表示小 A 构造的最小化 DFA 的状态数，$c_i$ 表示这个 DFA 按深度优先搜索，访问到的第 $i$ 个状态的相似度。\n\n数据保证 $\\sum|S|\\leq 2\\times 10^5$；数据保证对于每组的字符串 $S$，其所有后缀构成的最小化 DFA 状态数恰好为 $m$。", "outputFormat": "输出包含 $T$ 行，其中第 $i$ 行表示第 $i$ 份代码的相似度。\n\n为了避免除法运算，对于每个提问 $S$，你只需要输出答案乘上 $\\frac{|S|\\cdot (|S|+1)}{2}$，答案可以保证这是个整数。", "hint": "1. 确定型有限状态自动机（DFA）\n\n确定型有限状态自动机（DFA）是一个状态机。它从固定的起始状态 $q_0$ 出发，不断读入字符 $c$，并不断依此跳到后续状态；读入不同的字符将会跳转到不同的后续状态。如果读入完整个字符串后停在\"接受状态\"，我们认为 DFA 接受这个字符串；否则，认为 DFA 不接受这个字符串。特别的，如果 DFA 在某个状态 $q$ 时读入字符 $c$ 无后续状态，我们同样认为 DFA 不接受这个字符串。\n\n如下图所示，带两个圆的状态为接受状态。左侧的 DFA 从初始状态 $q_0$ 开始，读入 abab、bab、ab、b 后会分别停止于 $q_4, q_7, q_2, q_5$，均是接受状态；且读入其他字符串均不能进入接受状态。因此左侧的 DFA 可以接受 abab 的所有后缀；右侧的同理。\n\n对于能识别相同字符串的所有 DFA，我们认为状态最少的 DFA 就是最小化 DFA。可以证明，不同的最小化 DFA 可以通过给状态重新编号，而变成相同的 DFA。\n\n如该图所示，左右两侧的 DFA 均只能接受 abab、bab、ab、b 这四个字符串，因此两者等价。此外，可以证明，右侧的 DFA 是能识别这类字符串的最小化 DFA。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zpo9dm5b.png)\n\n2. DFA 的深度优先遍历\n\nDFA 的深度优先遍历将从起始状态 $q_0$ 开始，每次选择当前状态未访问的、按字母表从小到大的下一个字符对应的边，直到遍历完所有状态。各状态的编号即为其被访问到的顺序。\n\n如左侧的 DFA 的深度优先遍历顺序为 $q_0, q_1, q_2, q_3, q_4, q_5, q_6, q_7$；\n\n右侧 DFA 的深度优先遍历顺序为 $q_0, q_1, q_2, q_3, q_4$。", "locale": "zh-CN"}}}
{"pid": "P13090", "type": "P", "difficulty": 5, "samples": [["8 7\n", "0 0 1 2 2 1 1 1\n"], ["10 8\n", "0 0 1 2 2 2 2 1 1 1"], ["12 1\n", "0 1 2 2 3 3 2 2 2 1 1 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "福建", "前缀和", "省赛/邀请赛"], "title": "[FJCPC 2025] XCPC", "background": "", "description": "XCPC 赛事拥有金、银、铜、铁四种奖牌。作为一名参与该赛事的魔法师，小 A 可通过金、银、铜、铁四种奖牌作为媒介，施展“红日初升”法阵，召唤太阳，祈求保佑。\n\n在施展“红日初升”法阵的过程中，每一个奖牌都可以提供光亮值。其中金、银、铜、铁奖牌分别具有 $4$，$3$，$2$，$1$ 的光亮值。而施展“红日初升”法阵要求所有奖牌的光亮值之和大于等于 $p$ 。\n\n初始时小 A 有 $n$ 块铁牌，他可以通过炼金术进行奖牌转换：将 $2$ 个铁牌合成 $1$ 个铜牌、将 $2$ 个铜牌合成 $1$ 个银牌、将 $2$ 个银牌合成 $1$ 个金牌。\n\n假设用四元组 $(a_1,a_2,a_3,a_4)$ 分别表示金、银、铜、铁奖牌的数量。请回答以下 $n$ 个问题，其中第 $i~(1\\le i\\le n)$ 个问题是：\n\n* 初始有 $n$ 块铁牌，最终有多少种不同的四元组 $(a_1,a_2,a_3,a_4)$，同时满足：\n\n（1）一共有 $i$ 个牌子，即 $a_1+a_2+a_3+a_4=i$；\n\n（2）可以施展“红日初升”法阵，即 $4a_1+3a_2+2a_3+a_4\\ge p$。\n\n其中 $p$ 通过输入给定。\n\n两个四元组不同当且仅当它们存在某一位对应的数字不同。\n", "inputFormat": "第一行输入两个整数 $n,p~(1\\le p\\le n\\le 10^6)$，用空格相隔，分别表示初始有 $n$ 个奖牌，以及问题要求的奖牌价值之和大于等于 $p$。\n", "outputFormat": "输出一行 $n$ 个整数，用空格相隔，第 $i~(1\\le i\\le n)$ 个数字表示第 $i$ 个问题的答案。\n", "hint": "**样例解释**：对于样例一，初始的 $8$ 个铁牌最终可以得到多个四元组，以下列出光亮值之和大于等于 $7$ 的：\n\n* 第 $1,2$ 个问题：（无）；\n\n* 第 $3$ 个问题：$(0,1,2,0)$；\n\n* 第 $4$ 个问题：$(0,0,4,0),(0,1,1,2)$；\n\n* 第 $5$ 个问题：$(0,1,0,4),(0,0,3,2)$；\n\n* 第 $6$ 个问题：$(0,0,2,4)$；\n\n* 第 $7$ 个问题：$(0,0,1,6)$；\n\n* 第 $8$ 个问题：$(0,0,0,8)$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[FJCPC 2025] XCPC", "background": "", "description": "XCPC 赛事拥有金、银、铜、铁四种奖牌。作为一名参与该赛事的魔法师，小 A 可通过金、银、铜、铁四种奖牌作为媒介，施展“红日初升”法阵，召唤太阳，祈求保佑。\n\n在施展“红日初升”法阵的过程中，每一个奖牌都可以提供光亮值。其中金、银、铜、铁奖牌分别具有 $4$，$3$，$2$，$1$ 的光亮值。而施展“红日初升”法阵要求所有奖牌的光亮值之和大于等于 $p$ 。\n\n初始时小 A 有 $n$ 块铁牌，他可以通过炼金术进行奖牌转换：将 $2$ 个铁牌合成 $1$ 个铜牌、将 $2$ 个铜牌合成 $1$ 个银牌、将 $2$ 个银牌合成 $1$ 个金牌。\n\n假设用四元组 $(a_1,a_2,a_3,a_4)$ 分别表示金、银、铜、铁奖牌的数量。请回答以下 $n$ 个问题，其中第 $i~(1\\le i\\le n)$ 个问题是：\n\n* 初始有 $n$ 块铁牌，最终有多少种不同的四元组 $(a_1,a_2,a_3,a_4)$，同时满足：\n\n（1）一共有 $i$ 个牌子，即 $a_1+a_2+a_3+a_4=i$；\n\n（2）可以施展“红日初升”法阵，即 $4a_1+3a_2+2a_3+a_4\\ge p$。\n\n其中 $p$ 通过输入给定。\n\n两个四元组不同当且仅当它们存在某一位对应的数字不同。\n", "inputFormat": "第一行输入两个整数 $n,p~(1\\le p\\le n\\le 10^6)$，用空格相隔，分别表示初始有 $n$ 个奖牌，以及问题要求的奖牌价值之和大于等于 $p$。\n", "outputFormat": "输出一行 $n$ 个整数，用空格相隔，第 $i~(1\\le i\\le n)$ 个数字表示第 $i$ 个问题的答案。\n", "hint": "**样例解释**：对于样例一，初始的 $8$ 个铁牌最终可以得到多个四元组，以下列出光亮值之和大于等于 $7$ 的：\n\n* 第 $1,2$ 个问题：（无）；\n\n* 第 $3$ 个问题：$(0,1,2,0)$；\n\n* 第 $4$ 个问题：$(0,0,4,0),(0,1,1,2)$；\n\n* 第 $5$ 个问题：$(0,1,0,4),(0,0,3,2)$；\n\n* 第 $6$ 个问题：$(0,0,2,4)$；\n\n* 第 $7$ 个问题：$(0,0,1,6)$；\n\n* 第 $8$ 个问题：$(0,0,0,8)$。", "locale": "zh-CN"}}}
{"pid": "P13091", "type": "P", "difficulty": 5, "samples": [["6\n1\n1\n3\n1 2 2\n5\n1 3 4 5 2\n7\n1 2 3 5 6 7 4\n9\n9 9 8 2 4 4 3 5 3\n9\n4 4 9 2 9 5 8 3 3", "1 \n2 \n3 \n5 \n9 \n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["二分", "2025", "福建", "省赛/邀请赛"], "title": "[FJCPC 2025] 中位数", "background": "", "description": " CFJ 拥有一个长度为 $n$ 的数组 $a$，且 $n$ 必定为奇数。\n\n由于 CFJ 十分喜爱中位数，他将进行以下操作：每次选择数组中连续的三个数字，并将它们合并为其中位数，替换这三个数字。具体而言，每次选择任意一个位置 $i$（满足 $1 < i < n$），删除 $a_{i-1}$、$a_i$ 和 $a_{i+1}$，并在该位置插入这三个数字的中位数。\n\n CFJ 将持续进行上述操作，直到数组中仅剩一个数字为止。整个过程共需进行 $\\frac{n-1}{2}$ 次合并。他期望这个最终剩余的数字尽可能大。你的任务是帮助 CFJ 确定这个数字的最大可能值。\n\n**中位数的定义为：将一组长度为 $n$ 的数组从小到大排序后，排名第$\\lfloor \\frac{n+1}{2} \\rfloor$小的数字。**", "inputFormat": "**本题包含多组测试数据。**\n\n第一行，包含一个整数 $T$（$1\\le T \\le 10^6$），表示测试数据的组数。\n\n对于每组数据：\n\n第一行，包含一个整数 $n$（$1\\le n< 10^5$），且 $n$ 必定为奇数。\n\n第二行，包含 $n$ 个整数 $a_1,a_2,\\cdots, a_n$（$1\\le a_i\\le 10^9$）。\n\n数据保证 $\\sum n \\leq 10^6$。", "outputFormat": "对于每个测试用例，输出 $\\frac{n-1}{2}$ 次合并以后剩下数字的最大值。\n\n", "hint": "对于第四个样例而言，数组 $ A = [ \\ 1 \\ 2 \\ 3 \\ 5 \\ 6 \\ 7 \\ 4 \\ ] $ 一种可行的方案是：$ [ \\  \\underline{1 \\ 2 \\ 3} \\ 5 \\ 6 \\ 7 \\ 4 \\ ] \\rightarrow [ \\ \\underline{2 \\ 5 \\ 6}  \\ 7  \\ 4 \\ ] \\rightarrow [ \\ \\underline{5 \\ 7 \\ 4} \\  ] \\rightarrow [ \\ 5 \\ ]$。\n\n其中 $  \\underline{a_{i-1} \\ a_i \\ a_{i+1}}  $ 下划线选择的连续三个数字表示每次操作合并的对象。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[FJCPC 2025] 中位数", "background": "", "description": " CFJ 拥有一个长度为 $n$ 的数组 $a$，且 $n$ 必定为奇数。\n\n由于 CFJ 十分喜爱中位数，他将进行以下操作：每次选择数组中连续的三个数字，并将它们合并为其中位数，替换这三个数字。具体而言，每次选择任意一个位置 $i$（满足 $1 < i < n$），删除 $a_{i-1}$、$a_i$ 和 $a_{i+1}$，并在该位置插入这三个数字的中位数。\n\n CFJ 将持续进行上述操作，直到数组中仅剩一个数字为止。整个过程共需进行 $\\frac{n-1}{2}$ 次合并。他期望这个最终剩余的数字尽可能大。你的任务是帮助 CFJ 确定这个数字的最大可能值。\n\n**中位数的定义为：将一组长度为 $n$ 的数组从小到大排序后，排名第$\\lfloor \\frac{n+1}{2} \\rfloor$小的数字。**", "inputFormat": "**本题包含多组测试数据。**\n\n第一行，包含一个整数 $T$（$1\\le T \\le 10^6$），表示测试数据的组数。\n\n对于每组数据：\n\n第一行，包含一个整数 $n$（$1\\le n< 10^5$），且 $n$ 必定为奇数。\n\n第二行，包含 $n$ 个整数 $a_1,a_2,\\cdots, a_n$（$1\\le a_i\\le 10^9$）。\n\n数据保证 $\\sum n \\leq 10^6$。", "outputFormat": "对于每个测试用例，输出 $\\frac{n-1}{2}$ 次合并以后剩下数字的最大值。\n\n", "hint": "对于第四个样例而言，数组 $ A = [ \\ 1 \\ 2 \\ 3 \\ 5 \\ 6 \\ 7 \\ 4 \\ ] $ 一种可行的方案是：$ [ \\  \\underline{1 \\ 2 \\ 3} \\ 5 \\ 6 \\ 7 \\ 4 \\ ] \\rightarrow [ \\ \\underline{2 \\ 5 \\ 6}  \\ 7  \\ 4 \\ ] \\rightarrow [ \\ \\underline{5 \\ 7 \\ 4} \\  ] \\rightarrow [ \\ 5 \\ ]$。\n\n其中 $  \\underline{a_{i-1} \\ a_i \\ a_{i+1}}  $ 下划线选择的连续三个数字表示每次操作合并的对象。", "locale": "zh-CN"}}}
{"pid": "P13092", "type": "P", "difficulty": 5, "samples": [["3\n2\n1 2\n14\n8 14\n5 10\n9 14\n2 4\n12 13\n7 14\n1 5\n2 6\n2 1\n7 12\n3 5\n12 4\n11 2\n10\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n1 8\n8 9\n8 10", "1\n4\n7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "福建", "Special Judge", "省赛/邀请赛"], "title": "[FJCPC 2025] 二叉树", "background": "", "description": "墨菲特非常喜欢完美的树。在某一天，他决定用茂凯给的神秘种子自己种一棵树。\n\n这颗种子拥有非常旺盛的生命力。将这颗种子种下后，如果我们把第一天种下的种子记为初始的叶子节点，那么从第二天开始，每个前一天长出来的叶子节点，都会长出两个新的叶子节点。换句话说，如果这颗树生长了 $k$ 天，那么它就是一棵拥有 $2^k - 1$ 个节点的满二叉树。\n\n由于其迅速的生长速度，墨菲特很快就能得到一棵拥有很多节点的满二叉树，他认为满二叉树是十分完美的。\n\n茂凯也知道墨菲特非常喜欢树，因此他带来了一份礼物：由同样的神秘种子种出来的一棵树（大小不一定相同）。然而墨菲特已经有一颗这样的树了，两棵树的存放不太方便，于是他在两棵树之间连接了一条新的边，这样就是一棵树了。\n\n显然，这样的树已经不是完美的二叉树了，因此墨菲特很快就把他丢在了角落。\n\n过了很久很久之后，墨菲特又想起来了这棵由两棵满二叉树连接形成的新树，他想要重新把这棵树拆成两棵满二叉树，但是他已经忘记哪条边是他额外添加上去的了。\n\n希望聪明的你可以帮助墨菲特解决这个问题。\n\n形式化地，给定一棵树，你需要删除其中的一条边，使得分成的两棵树都是满二叉树，保证至少存在一个解。\n\n*所有叶结点的深度均相同，且所有非叶节点的子节点数量均为 $2$ 的二叉树称为满二叉树。", "inputFormat": "**输入包含多组测试数据。**\n\n第一行包含一个正整数 $T$ ( $1 \\le T \\le 10^5$ ) ，表示测试数据的数量。接下来是测试数据的描述。\n\n每组测试数据的第一行包含一个正整数 $n\\ (2 \\le n \\le 2^{17} - 2)$ ，表示墨菲特手上的树的节点个数。\n\n接下来 $n - 1$ 行，每行两个由空格分开的正整数 $u_i, v_i\\ (1 \\le u_i, v_i \\le n)$ ，表示树上的一条边 $(u_i, v_i)$ 。输入保证给定的边集构成一棵树。\n\n另外，保证 $\\sum n \\le 10^6$ 。", "outputFormat": "对于每一组测试数据，输出一行一个正整数 $i$ ，表示如果删除了给定边集中的第 $i$ 条边 $(u_i, v_i)$ ，分成的两棵树都是满二叉树。保证这样的解一定存在。如果有多个可行的解，输出任意一个即可。", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/u2r7vj65.png)\n\n第二组样例的树如上图所示，可以发现，只有删除边 $(2, 4)$ 是合法的。\n\n第三组样例的树如下图所示，可以发现，删除边 $(1, 2), (1, 3), (1, 8)$ 都是合法的，你可以输出任意一种。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[FJCPC 2025] 二叉树", "background": "", "description": "墨菲特非常喜欢完美的树。在某一天，他决定用茂凯给的神秘种子自己种一棵树。\n\n这颗种子拥有非常旺盛的生命力。将这颗种子种下后，如果我们把第一天种下的种子记为初始的叶子节点，那么从第二天开始，每个前一天长出来的叶子节点，都会长出两个新的叶子节点。换句话说，如果这颗树生长了 $k$ 天，那么它就是一棵拥有 $2^k - 1$ 个节点的满二叉树。\n\n由于其迅速的生长速度，墨菲特很快就能得到一棵拥有很多节点的满二叉树，他认为满二叉树是十分完美的。\n\n茂凯也知道墨菲特非常喜欢树，因此他带来了一份礼物：由同样的神秘种子种出来的一棵树（大小不一定相同）。然而墨菲特已经有一颗这样的树了，两棵树的存放不太方便，于是他在两棵树之间连接了一条新的边，这样就是一棵树了。\n\n显然，这样的树已经不是完美的二叉树了，因此墨菲特很快就把他丢在了角落。\n\n过了很久很久之后，墨菲特又想起来了这棵由两棵满二叉树连接形成的新树，他想要重新把这棵树拆成两棵满二叉树，但是他已经忘记哪条边是他额外添加上去的了。\n\n希望聪明的你可以帮助墨菲特解决这个问题。\n\n形式化地，给定一棵树，你需要删除其中的一条边，使得分成的两棵树都是满二叉树，保证至少存在一个解。\n\n*所有叶结点的深度均相同，且所有非叶节点的子节点数量均为 $2$ 的二叉树称为满二叉树。", "inputFormat": "**输入包含多组测试数据。**\n\n第一行包含一个正整数 $T$ ( $1 \\le T \\le 10^5$ ) ，表示测试数据的数量。接下来是测试数据的描述。\n\n每组测试数据的第一行包含一个正整数 $n\\ (2 \\le n \\le 2^{17} - 2)$ ，表示墨菲特手上的树的节点个数。\n\n接下来 $n - 1$ 行，每行两个由空格分开的正整数 $u_i, v_i\\ (1 \\le u_i, v_i \\le n)$ ，表示树上的一条边 $(u_i, v_i)$ 。输入保证给定的边集构成一棵树。\n\n另外，保证 $\\sum n \\le 10^6$ 。", "outputFormat": "对于每一组测试数据，输出一行一个正整数 $i$ ，表示如果删除了给定边集中的第 $i$ 条边 $(u_i, v_i)$ ，分成的两棵树都是满二叉树。保证这样的解一定存在。如果有多个可行的解，输出任意一个即可。", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/u2r7vj65.png)\n\n第二组样例的树如上图所示，可以发现，只有删除边 $(2, 4)$ 是合法的。\n\n第三组样例的树如下图所示，可以发现，删除边 $(1, 2), (1, 3), (1, 8)$ 都是合法的，你可以输出任意一种。", "locale": "zh-CN"}}}
{"pid": "P13093", "type": "P", "difficulty": 5, "samples": [["4\n2\n1 3 2 4\n1\n1000000000 1\n3\n1 1 2 3 5 8\n4\n1 2 4 8 16 32 64 128", "5\n1\n9\n106"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "福建", "前缀和", "省赛/邀请赛"], "title": "[FJCPC 2025] 卡牌游戏", "background": "", "description": "小 A 和小 B 正在玩卡牌游戏。\n\n有 $2n$ 张卡牌垒成一摞牌堆，自上而下的第 $i$（$1\\leq i\\leq 2n$）张牌上标注了数字 $a_i$。发牌时，牌堆中的卡牌自上而下以 $1, 2, \\dots, 2n$ 编号，编号为奇数的卡牌将分给一位玩家，编号为偶数的卡牌将分给另一位玩家。这意味着，小 A 将会获得编号同为奇数或同为偶数的 $n$ 张卡牌。\n\n对于玩家而言，所得到的卡牌上的数字之和越大，游戏局面对他越有利。因此小 A 想最大化最坏情况下他所得到的卡牌数字之和。为了达到这个目的，小 A 可以对当前牌堆执行恰好一次以下操作：\n\n-   从当前牌堆中抽出一张卡牌，并插回牌堆中的任意位置。注意发牌时的编号可能会发生变化。\n\n例如，初始时牌堆中卡牌标注的数字自上而下依次是 $1, 2, 3, 4$，发牌时一位玩家将得到 $1, 3$，另一位玩家将得到 $2, 4$。小 A 可以选择抽出第二张卡牌，并将其插回最后一张卡牌后面，此时牌堆为 $1, 3, 4, 2$，发牌时一位玩家将得到 $1, 4$，另一位玩家将得到 $3, 2$。\n\n你需要求出小 A 在执行恰好一次操作后，最坏情况下所得到的卡牌数字之和的最大值。", "inputFormat": "**本题包含多组测试数据。**\n\n第一行，一个正整数 $t$（$1\\leq t\\leq 10^4$），表示测试数据组数。\n\n对于每组数据：\n\n第一行，一个正整数 $n$（$1\\leq n\\leq 10^5$），表示每位玩家将得到的卡牌数量。\n\n第二行，$2n$ 个正整数 $a_1, a_2, \\dots, a_{2n}$（$1\\leq a_i\\leq 10^9$），表示当前牌堆中卡牌标注的数字。\n\n对于每个测试点，保证 $\\sum n$ 不超过 $10^5$。", "outputFormat": "对于每组数据，输出一行，一个整数，表示在执行恰好一次操作后，最坏情况下小 A 所得到的卡牌数字之和的最大值。", "hint": "第一组样例即是题目描述中所给出的例子。发牌时，一位玩家的卡牌数字之和为 $1 + 4 = 5$，另一位玩家的卡牌数字之和为 $3 + 2 = 5$，可以证明这即是所能取得的最大值。\n\n第二组样例中，无论如何操作，发牌情况都将是一位玩家得到 $1$，而另一位玩家得到 $10^9$。因此最坏情况下小 A 只能得到 $1$，即为答案。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[FJCPC 2025] 卡牌游戏", "background": "", "description": "小 A 和小 B 正在玩卡牌游戏。\n\n有 $2n$ 张卡牌垒成一摞牌堆，自上而下的第 $i$（$1\\leq i\\leq 2n$）张牌上标注了数字 $a_i$。发牌时，牌堆中的卡牌自上而下以 $1, 2, \\dots, 2n$ 编号，编号为奇数的卡牌将分给一位玩家，编号为偶数的卡牌将分给另一位玩家。这意味着，小 A 将会获得编号同为奇数或同为偶数的 $n$ 张卡牌。\n\n对于玩家而言，所得到的卡牌上的数字之和越大，游戏局面对他越有利。因此小 A 想最大化最坏情况下他所得到的卡牌数字之和。为了达到这个目的，小 A 可以对当前牌堆执行恰好一次以下操作：\n\n-   从当前牌堆中抽出一张卡牌，并插回牌堆中的任意位置。注意发牌时的编号可能会发生变化。\n\n例如，初始时牌堆中卡牌标注的数字自上而下依次是 $1, 2, 3, 4$，发牌时一位玩家将得到 $1, 3$，另一位玩家将得到 $2, 4$。小 A 可以选择抽出第二张卡牌，并将其插回最后一张卡牌后面，此时牌堆为 $1, 3, 4, 2$，发牌时一位玩家将得到 $1, 4$，另一位玩家将得到 $3, 2$。\n\n你需要求出小 A 在执行恰好一次操作后，最坏情况下所得到的卡牌数字之和的最大值。", "inputFormat": "**本题包含多组测试数据。**\n\n第一行，一个正整数 $t$（$1\\leq t\\leq 10^4$），表示测试数据组数。\n\n对于每组数据：\n\n第一行，一个正整数 $n$（$1\\leq n\\leq 10^5$），表示每位玩家将得到的卡牌数量。\n\n第二行，$2n$ 个正整数 $a_1, a_2, \\dots, a_{2n}$（$1\\leq a_i\\leq 10^9$），表示当前牌堆中卡牌标注的数字。\n\n对于每个测试点，保证 $\\sum n$ 不超过 $10^5$。", "outputFormat": "对于每组数据，输出一行，一个整数，表示在执行恰好一次操作后，最坏情况下小 A 所得到的卡牌数字之和的最大值。", "hint": "第一组样例即是题目描述中所给出的例子。发牌时，一位玩家的卡牌数字之和为 $1 + 4 = 5$，另一位玩家的卡牌数字之和为 $3 + 2 = 5$，可以证明这即是所能取得的最大值。\n\n第二组样例中，无论如何操作，发牌情况都将是一位玩家得到 $1$，而另一位玩家得到 $10^9$。因此最坏情况下小 A 只能得到 $1$，即为答案。", "locale": "zh-CN"}}}
{"pid": "P13094", "type": "P", "difficulty": 6, "samples": [["8 7\n1 9 7 8 0 7 2 3\n19 20 5 6 1 14 9 5\n1 8\n3 7\n2 6\n4 4\n5 7\n3 8\n6 7", "1\n2\n1\n1\n1\n2\n1"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "福建", "cdq 分治", "扫描线", "省赛/邀请赛"], "title": "[FJCPC 2025] 帕累托前沿", "background": "", "description": "给出 $n$ 个二元组 $(x_i,y_i)$，你需要回答 $q$ 个询问，每个询问给出闭区间 $[l,r]$，请回答满足以下条件的整数 $j$ 数量：\n\n- $l\\leq j\\leq r$；\n\n- 不存在 $l\\leq k\\leq r, k\\neq j$，使得 $x_k\\geq x_j$ 且 $y_k\\geq y_j$。", "inputFormat": "第一行两个正整数 $n,q$（$1\\leq n,q\\leq 10^6$），分别表示二元组数量和询问数量。\n\n第二行 $n$ 个非负整数 $x_1,x_2,\\dots,x_n$（$0\\le x_i\\le 10^6$）。\n\n第三行 $n$ 个非负整数 $y_1,y_2,\\dots,y_n$（$0\\le y_i\\le 10^6$）。\n\n接下来 $q$ 行，每行两个正整数 $l,r$（$1\\leq l\\leq r\\leq n$），表示询问的区间。", "outputFormat": "对于每个询问，输出一行一个整数表示答案。", "hint": "对于询问 $1$，满足条件的整数为 $2$。\n\n对于询问 $2$，满足条件的整数为 $4$、$6$。\n\n对于询问 $3$，满足条件的整数为 $2$。\n\n对于询问 $4$，满足条件的整数为 $4$。\n\n对于询问 $5$，满足条件的整数为 $6$。\n\n对于询问 $6$，满足条件的整数为 $4$、$6$。\n\n对于询问 $7$，满足条件的整数为 $6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[FJCPC 2025] 帕累托前沿", "background": "", "description": "给出 $n$ 个二元组 $(x_i,y_i)$，你需要回答 $q$ 个询问，每个询问给出闭区间 $[l,r]$，请回答满足以下条件的整数 $j$ 数量：\n\n- $l\\leq j\\leq r$；\n\n- 不存在 $l\\leq k\\leq r, k\\neq j$，使得 $x_k\\geq x_j$ 且 $y_k\\geq y_j$。", "inputFormat": "第一行两个正整数 $n,q$（$1\\leq n,q\\leq 10^6$），分别表示二元组数量和询问数量。\n\n第二行 $n$ 个非负整数 $x_1,x_2,\\dots,x_n$（$0\\le x_i\\le 10^6$）。\n\n第三行 $n$ 个非负整数 $y_1,y_2,\\dots,y_n$（$0\\le y_i\\le 10^6$）。\n\n接下来 $q$ 行，每行两个正整数 $l,r$（$1\\leq l\\leq r\\leq n$），表示询问的区间。", "outputFormat": "对于每个询问，输出一行一个整数表示答案。", "hint": "对于询问 $1$，满足条件的整数为 $2$。\n\n对于询问 $2$，满足条件的整数为 $4$、$6$。\n\n对于询问 $3$，满足条件的整数为 $2$。\n\n对于询问 $4$，满足条件的整数为 $4$。\n\n对于询问 $5$，满足条件的整数为 $6$。\n\n对于询问 $6$，满足条件的整数为 $4$、$6$。\n\n对于询问 $7$，满足条件的整数为 $6$。", "locale": "zh-CN"}}}
