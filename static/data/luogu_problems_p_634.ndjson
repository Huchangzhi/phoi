{"pid": "P13856", "type": "P", "difficulty": 6, "samples": [["5 7 6 3\nabcbca\n3 2 1 1\n2 1 5 1\n2 5 4 2\n3 1 1 2\n3 4 3 2\n1 4 6 1\n5 4 5 2", "2 3 1\n2 3 2\n1 3\n3 3 1 4\n3 3 2 5"]], "limits": {"time": [15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "Special Judge", "哈希 hashing", "后缀数组 SA", "ICPC", "CERC"], "title": "[CERC 2023] Labelled Paths", "background": "", "description": "We are given a directed acyclic graph with $n$ vertices and $m$ edges. Each edge has a label (a string of lowercase letters; possibly even an empty string). We can now extend the concept of labels from edges to paths by defining the label of a path as the concatenation of the labels of the edges that constitute this path (in the same order in which they appear in the path). The smallest path from a start vertex $s$ to a destination vertex $t$ is the path (from $s$ to $t$) whose label is lexicographically smallest (i.e. the earliest in lexicographical order) amongst all the paths from $s$ to $t$. Write a program that, for a given $s$, outputs the smallest paths from $s$ to $t$ for all vertices $t$ of the graph.\n", "inputFormat": "The first line contains four space-separated integers: $n$ (the number of vertices), $m$ (the number of edges), $d$ (the length of the string $A$, on which see below) and $s$ (the number of the start vertex). The vertices are numbered by integers from $1$ to $n$.\n\nThe second line contains a string $A$, which is exactly $d$ characters long; all these characters are lowercase letters of the English alphabet. All the edge labels in our graph are substrings of the string $A$.\n\nThe remaining $m$ lines describe the edges of the graph. The $i$-th of these lines describes the $i$-th edge and contains four space-separated integers: $u_i$ (the start vertex of this edge), $v_i$ (the end vertex of this edge), $p_i$ and $\\ell_i$. The last two of these integers indicate that the label of this edge is the substring of $A$ that begins with the $p_i$-th character of $A$ and is $\\ell_i$ characters long. For this purpose we consider the characters of $A$ to be indexed by integers from $1$ to $d$.", "outputFormat": "Output $n$ lines, where the $t$-th line (for $t = 1, \\dots, n$) describes the smallest path from $s$ to $t$. If there is no path from $s$ to $t$, the line should contain only the integer $0$ and nothing else. Otherwise the line should start with the number of vertices on the path (including vertices $s$ and $t$), followed by the list of those vertices, separated by spaces. If there are several possible solutions, you may output any of them.", "hint": "### Comment\n\nIn this example, the edge $3 \\rightarrow 1$ has the label ab; the edge $1 \\rightarrow 4$ has the label a; the smallest path from $3$ to $4$ is $3 \\rightarrow 1 \\rightarrow 4$, whose label is aba.\n\n### Input limits\n\n- $1 \\leq s \\leq n \\leq 600$\n- $1 \\leq m \\leq 2000$\n- $1 \\leq d \\leq 10^6$\n- $1 \\leq u_i \\leq n$, $1 \\leq v_i \\leq n$, $u_i \\neq v_i$ (for all $i = 1, \\dots, m$)\n- $1 \\leq p_i$, $0 \\leq \\ell_i$, $p_i + \\ell_i - 1 \\leq d$ (for all $i = 1, \\dots, m$)\n- The graph is acyclic and has no parallel edges (i.e. from $i \\neq j$ it follows that $u_i \\neq u_j$ and/or $v_i \\neq v_j$).\n", "locale": "en", "translations": {"en": {"title": "[CERC 2023] Labelled Paths", "background": "", "description": "We are given a directed acyclic graph with $n$ vertices and $m$ edges. Each edge has a label (a string of lowercase letters; possibly even an empty string). We can now extend the concept of labels from edges to paths by defining the label of a path as the concatenation of the labels of the edges that constitute this path (in the same order in which they appear in the path). The smallest path from a start vertex $s$ to a destination vertex $t$ is the path (from $s$ to $t$) whose label is lexicographically smallest (i.e. the earliest in lexicographical order) amongst all the paths from $s$ to $t$. Write a program that, for a given $s$, outputs the smallest paths from $s$ to $t$ for all vertices $t$ of the graph.\n", "inputFormat": "The first line contains four space-separated integers: $n$ (the number of vertices), $m$ (the number of edges), $d$ (the length of the string $A$, on which see below) and $s$ (the number of the start vertex). The vertices are numbered by integers from $1$ to $n$.\n\nThe second line contains a string $A$, which is exactly $d$ characters long; all these characters are lowercase letters of the English alphabet. All the edge labels in our graph are substrings of the string $A$.\n\nThe remaining $m$ lines describe the edges of the graph. The $i$-th of these lines describes the $i$-th edge and contains four space-separated integers: $u_i$ (the start vertex of this edge), $v_i$ (the end vertex of this edge), $p_i$ and $\\ell_i$. The last two of these integers indicate that the label of this edge is the substring of $A$ that begins with the $p_i$-th character of $A$ and is $\\ell_i$ characters long. For this purpose we consider the characters of $A$ to be indexed by integers from $1$ to $d$.", "outputFormat": "Output $n$ lines, where the $t$-th line (for $t = 1, \\dots, n$) describes the smallest path from $s$ to $t$. If there is no path from $s$ to $t$, the line should contain only the integer $0$ and nothing else. Otherwise the line should start with the number of vertices on the path (including vertices $s$ and $t$), followed by the list of those vertices, separated by spaces. If there are several possible solutions, you may output any of them.", "hint": "### Comment\n\nIn this example, the edge $3 \\rightarrow 1$ has the label ab; the edge $1 \\rightarrow 4$ has the label a; the smallest path from $3$ to $4$ is $3 \\rightarrow 1 \\rightarrow 4$, whose label is aba.\n\n### Input limits\n\n- $1 \\leq s \\leq n \\leq 600$\n- $1 \\leq m \\leq 2000$\n- $1 \\leq d \\leq 10^6$\n- $1 \\leq u_i \\leq n$, $1 \\leq v_i \\leq n$, $u_i \\neq v_i$ (for all $i = 1, \\dots, m$)\n- $1 \\leq p_i$, $0 \\leq \\ell_i$, $p_i + \\ell_i - 1 \\leq d$ (for all $i = 1, \\dots, m$)\n- The graph is acyclic and has no parallel edges (i.e. from $i \\neq j$ it follows that $u_i \\neq u_j$ and/or $v_i \\neq v_j$).\n", "locale": "en"}, "zh-CN": {"title": "[CERC 2023] Labelled Paths", "background": "", "description": "给定一个有向无环图，其中有 $n$ 个顶点和 $m$ 条边。每条边都有一个标记（由小写字母组成的字符串；可能为空字符串）。我们将“路径的标记”定义为这条路径上各边标记按路径顺序拼接而成的字符串。若从起点顶点 $s$ 到目标顶点 $t$ 存在多条路径，则其中**最小的路径**指的是其标记在所有路径的标记中按字典序最小的那条。请你编写一个程序，对于给定的起点 $s$，输出从 $s$ 到每个顶点 $t$ 的最小路径。", "inputFormat": "第一行包含四个整数，分别是 $n$（顶点数）、$m$（边数）、$d$（字符串 $A$ 的长度，见下文）、$s$（起点的编号）。顶点编号为 $1$ 到 $n$。\n\n第二行给出一个字符串 $A$，长度正好为 $d$，所有字符均为小写英文字母。图中所有边的标记都是字符串 $A$ 的子串。\n\n接下来 $m$ 行描述各条边。第 $i$ 行描述第 $i$ 条边，包含四个整数：$u_i$（该边的起点）、$v_i$（该边的终点）、$p_i$ 和 $\\ell_i$。其中最后两个数表示该边的标记是字符串 $A$ 的一个子串：它从 $A$ 的第 $p_i$ 个字符开始，长度为 $\\ell_i$。这里我们认为 $A$ 的字符编号从 $1$ 到 $d$。\n", "outputFormat": "输出 $n$ 行，第 $t$ 行（$t = 1, \\dots, n$）描述从 $s$ 到 $t$ 的最小路径。\n\n- 如果从 $s$ 到 $t$ 不存在路径，则这一行只输出整数 $0$。\n- 否则，先输出路径上的顶点数（包含 $s$ 与 $t$），随后输出该路径上所有顶点的编号，按路径顺序排列，彼此间以空格分隔。\n\n如果存在多条合法解，输出任意一条均可。", "hint": "### 注释\n\n在这个样例中，边 $3 \\rightarrow 1$ 的标记是 \"ab\"；边 $1 \\rightarrow 4$ 的标记是 \"a\"；因此从 $3$ 到 $4$ 的最小路径是 $3 \\rightarrow 1 \\rightarrow 4$，其标记为 \"aba\"。\n\n### 输入限制\n\n- $1 \\leq s \\leq n \\leq 600$\n- $1 \\leq m \\leq 2000$\n- $1 \\leq d \\leq 10^6$\n- $1 \\leq u_i \\leq n$，$1 \\leq v_i \\leq n$，且 $u_i \\neq v_i$（对所有 $i = 1, \\dots, m$ 成立）\n- $1 \\leq p_i$，$0 \\leq \\ell_i$，并且 $p_i + \\ell_i - 1 \\leq d$（对所有 $i = 1, \\dots, m$ 成立）\n- 图是无环的，且不存在平行边（即若 $i \\neq j$，则有 $u_i \\neq u_j$ 或 $v_i \\neq v_j$）。\n\n---\n\n翻译由 ChatGPT-5 完成", "locale": "zh-CN"}}}
{"pid": "P13857", "type": "P", "difficulty": 2, "samples": [["2 2\nSupportive parents\nBeing able to solve a hard problem\nGood food\nFun game with friends\nGood food\nBeing healthy", "Good food\nBeing healthy"], ["2 6\nSupportive parents\nBeing able to solve a hard problem\nGood food\nFun game with friends\nGood food\nBeing healthy", "Good food\nBeing healthy\nFun game with friends\nBeing able to solve a hard problem\nSupportive parents"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "排序", "ICPC"], "title": "[SWERC 2020] Gratitude", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/1d363717aaf4e8091a4ead169bbb804adaf001d8.png)\n\n:::\n\nBen heard about studies by Emmons and McCullough that suggest that intentionally\npracticing gratitude has a lasting effect on people's happiness.\nSince he wants to be happy too, he decided that at the end of each day he will\nthink back over the past day and write down three things he is thankful for,\none thing per line.\nAt the end of $N$ days in which he practiced this exercise, he was curious to know which things appear the most on his list.\nHelp Ben get the $K$ things he was grateful for most frequently.", "inputFormat": "The input begins with one line containing two space-separated integers, $N$ and $K$, in that order.\nThen follow $3N$ lines containing Ben's notes from $N$ days.\nYou may assume that the three lines that correspond to the same day contain no repetitions. That is, if you partition the input into $N$ chunks of $3$ consecutive lines, no chunk contains two identical lines.\n\n**Limits**\n\n- $1 \\le K \\le 3N \\le 100\\,000$\n- Each input line contains at most $50$ (ASCII) characters.", "outputFormat": "The output should represent the list of things that Ben is grateful\nfor, ordered by frequency of appearance in Ben's list (with the most\nfrequent item first).\nIn case of two items with equal frequency, the most recent item should appear first. That is, in case of a tie in the number of appearances, the item whose last appearance is later in the input should appear earlier in the output. \nFinally, if there are more than $K$\ndifferent items in Ben's list, your output should contain only the $K$\nfirst items (according to the required order).", "hint": "**Sample Explanation 1**\n\n$\\texttt{Good food}$ is the only item that appears twice in\nBen's list, so it should appear first in the output. All other items appear once in the input, \nbut $\\texttt{Being healthy}$ takes precedence as it is the most recent.\n\n**Sample Explanation 1**\n\nHere there are only $5$ different items that Ben is grateful for, so there are only $5$ lines of output. In this list, $\\texttt{Good food}$\nis first in the output since it appears twice in the input, and the other items are ordered by last appearance in Ben's list.", "locale": "en", "translations": {"en": {"title": "[SWERC 2020] Gratitude", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/1d363717aaf4e8091a4ead169bbb804adaf001d8.png)\n\n:::\n\nBen heard about studies by Emmons and McCullough that suggest that intentionally\npracticing gratitude has a lasting effect on people's happiness.\nSince he wants to be happy too, he decided that at the end of each day he will\nthink back over the past day and write down three things he is thankful for,\none thing per line.\nAt the end of $N$ days in which he practiced this exercise, he was curious to know which things appear the most on his list.\nHelp Ben get the $K$ things he was grateful for most frequently.", "inputFormat": "The input begins with one line containing two space-separated integers, $N$ and $K$, in that order.\nThen follow $3N$ lines containing Ben's notes from $N$ days.\nYou may assume that the three lines that correspond to the same day contain no repetitions. That is, if you partition the input into $N$ chunks of $3$ consecutive lines, no chunk contains two identical lines.\n\n**Limits**\n\n- $1 \\le K \\le 3N \\le 100\\,000$\n- Each input line contains at most $50$ (ASCII) characters.", "outputFormat": "The output should represent the list of things that Ben is grateful\nfor, ordered by frequency of appearance in Ben's list (with the most\nfrequent item first).\nIn case of two items with equal frequency, the most recent item should appear first. That is, in case of a tie in the number of appearances, the item whose last appearance is later in the input should appear earlier in the output. \nFinally, if there are more than $K$\ndifferent items in Ben's list, your output should contain only the $K$\nfirst items (according to the required order).", "hint": "**Sample Explanation 1**\n\n$\\texttt{Good food}$ is the only item that appears twice in\nBen's list, so it should appear first in the output. All other items appear once in the input, \nbut $\\texttt{Being healthy}$ takes precedence as it is the most recent.\n\n**Sample Explanation 1**\n\nHere there are only $5$ different items that Ben is grateful for, so there are only $5$ lines of output. In this list, $\\texttt{Good food}$\nis first in the output since it appears twice in the input, and the other items are ordered by last appearance in Ben's list.", "locale": "en"}, "zh-CN": {"title": "[SWERC 2020] Gratitude", "background": null, "description": ":::align{center}\n\n![](https://espresso.codeforces.com/1d363717aaf4e8091a4ead169bbb804adaf001d8.png)\n\n:::\n\nBen 听说了 Emmons 和 McCullough 的研究，该研究表明刻意练习感恩能对人的幸福感产生持久影响。由于他也想变得快乐，所以他决定在每天结束时回顾过去的一天，并写下三件他感激的事情，每行一件。在坚持这项练习 $N$ 天后，他很好奇想知道哪些事物在他的清单中出现得最频繁。请帮助 Ben 找出他最常感激的 $K$ 件事物。", "inputFormat": "输入的第一行包含两个以空格分隔的整数 $N$ 和 $K$。随后是 $3N$ 行，包含 Ben 在 $N$ 天中的记录。你可以假设对应同一天的三行中没有重复项。也就是说，如果你将输入划分为 $N$ 个连续 3 行的块，则每个块中不会包含两个相同的行。", "outputFormat": "输出应代表 Ben 感激的事物列表，按在 Ben 清单中出现的频率排序（出现次数最多的项排在最前面）。如果两个项频率相同，则最近出现的项应排在前面。也就是说，如果出现次数相同，则最后出现在输入中较晚位置的项在输出中应排在较前的位置。最后，如果 Ben 的列表中有超过 $K$ 个不同的项，你的输出应只包含前 $K$ 个项（根据要求的顺序）。", "hint": "#### 限制条件\n\n- $1 \\le K \\le 3N \\le 100,000$。\n\n- 每个输入行最多包含 $50$ 个 (ASCII) 字符。\n\n#### 样例解释 1\n\n$\\texttt{Good food}$ 是 Ben 列表中唯一出现两次的项目，因此它应在输出中排在第一位。其他所有项目在输入中出现一次，但 $\\texttt{Being healthy}$ 因出现时间最近而优先。\n\n#### 样例解释 2\n\n这里 Ben 感激的不同项目只有 $5$ 个，因此输出只有 $5$ 行。在此列表中，$\\texttt{Good food}$ 在输出中排在第一，因为它在输入中出现了两次，而其他项目则按在 Ben 列表中最后出现的位置排序。", "locale": "zh-CN"}}}
{"pid": "P13858", "type": "P", "difficulty": 7, "samples": [["0001001101111100\n5", "11"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "倍增", "记忆化搜索", "ICPC"], "title": "[SWERC 2020] Rule 110", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/da2cb2d4bcf3f414be73ab8a00b7e82a5051c6a9.png)\n\n:::\n\n\nAnn is decorating her office with the coolest arrangement of lights\never.  She is using very long LED strips, where each individual cell\nis switched on or off every second, according to the following simple\nand pretty algorithm.\nAt each step, the status of each cell (0 for off and 1 for on) is\ndetermined from the status of its two neighbor cells on the\nstrip (left and right) and its own status, according to the following\ntable:\n\n\n$$\n\\begin{array}{l|c|c|c|c|c|c|c|c}\n        \\textbf{Current pattern} & 111 & 110 & 101 & 100 & 011 & 010 & 001 & 000  \\\\ \n\\hline\n\\textbf{New state for center cell} &  0  &  1  &  1  &  0  &  1  &  1  &  1  &  0  \\\\\n\\end{array}\n$$\n\nAnn is choosing an initial configuration for the cells and she\nmarvels at the resulting animation, which happens to be highly similar\nto Conway's Game of Life, with interesting behavior on the boundary\nbetween stability and chaos.", "inputFormat": "The input is composed of two lines.\n\n- The first line contains the initial configuration, as a string\n  of 16 characters $\\texttt{0}$ and $\\texttt{1}$.\n  All the cells to the left and to the right of this string are\n  considered to be 0.\n- The second line contains the number $N$ of steps to perform.\n\n**Limits**\n\n- $0 \\le N < 2^{60}$\n- The LED strip is\nconsidered to be large enough to ensure that no 1-cells will ever\nreach the ends of the strip.", "outputFormat": "The output should contain a single line with a single integer that is\nthe total number of 1-cells in the final configuration.", "hint": "**Sample Explanation**\n\nthe output is $11$ since we have the following five steps:\n$$\n\\begin{aligned}\n\\texttt{...0000000010011011111000...}\\\\\n\\texttt{...0000000110111110001000...}\\\\\n\\texttt{...0000001111100010011000...}\\\\\n\\texttt{...0000011000100110111000...}\\\\\n\\texttt{...0000111001101111101000...}\\\\\n\\texttt{...0001101011111000111000...}\\\\\n\\end{aligned}\n$$\nwhere everything not displayed contains only 0-cells.", "locale": "en", "translations": {"en": {"title": "[SWERC 2020] Rule 110", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/da2cb2d4bcf3f414be73ab8a00b7e82a5051c6a9.png)\n\n:::\n\n\nAnn is decorating her office with the coolest arrangement of lights\never.  She is using very long LED strips, where each individual cell\nis switched on or off every second, according to the following simple\nand pretty algorithm.\nAt each step, the status of each cell (0 for off and 1 for on) is\ndetermined from the status of its two neighbor cells on the\nstrip (left and right) and its own status, according to the following\ntable:\n\n\n$$\n\\begin{array}{l|c|c|c|c|c|c|c|c}\n        \\textbf{Current pattern} & 111 & 110 & 101 & 100 & 011 & 010 & 001 & 000  \\\\ \n\\hline\n\\textbf{New state for center cell} &  0  &  1  &  1  &  0  &  1  &  1  &  1  &  0  \\\\\n\\end{array}\n$$\n\nAnn is choosing an initial configuration for the cells and she\nmarvels at the resulting animation, which happens to be highly similar\nto Conway's Game of Life, with interesting behavior on the boundary\nbetween stability and chaos.", "inputFormat": "The input is composed of two lines.\n\n- The first line contains the initial configuration, as a string\n  of 16 characters $\\texttt{0}$ and $\\texttt{1}$.\n  All the cells to the left and to the right of this string are\n  considered to be 0.\n- The second line contains the number $N$ of steps to perform.\n\n**Limits**\n\n- $0 \\le N < 2^{60}$\n- The LED strip is\nconsidered to be large enough to ensure that no 1-cells will ever\nreach the ends of the strip.", "outputFormat": "The output should contain a single line with a single integer that is\nthe total number of 1-cells in the final configuration.", "hint": "**Sample Explanation**\n\nthe output is $11$ since we have the following five steps:\n$$\n\\begin{aligned}\n\\texttt{...0000000010011011111000...}\\\\\n\\texttt{...0000000110111110001000...}\\\\\n\\texttt{...0000001111100010011000...}\\\\\n\\texttt{...0000011000100110111000...}\\\\\n\\texttt{...0000111001101111101000...}\\\\\n\\texttt{...0001101011111000111000...}\\\\\n\\end{aligned}\n$$\nwhere everything not displayed contains only 0-cells.", "locale": "en"}}}
{"pid": "P13859", "type": "P", "difficulty": 4, "samples": [["8 6\n3\n3 1\n3 5.5\n6.5 1.5", "2.250000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "二分", "并查集", "Special Judge", "ICPC"], "title": "[SWERC 2020] Safe Distance", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/576cf263ac1df37ed5abd75cfa081608a638ae40.png)\n\n:::\n\nThe past year has been difficult, with a virus spreading among the population.\nFortunately, Alice knows that one of the keys to be healthy is to keep a safe distance from other people.\n\nAlice is currently in a closed room, represented in the $2D$ plane, with width $X$ and height $Y$.\nThere are $N$ other people inside the room, and we're given their $(x_i, y_i)$ coordinates.\n\nWe consider Alice and the $N$ people as points in the $2D$ plane.\nAlice's initial position is $(0, 0)$ and she wants to move to the exit at position $(X, Y)$. \nShe can move freely in any direction inside the room, but can not step outside the room bounds.\n\nFind the maximum distance Alice can keep from other people while moving from $(0, 0)$ to $(X, Y)$.\n\n", "inputFormat": "The input begins with one line containing two space-separated\nintegers, $X$ and $Y$, where $X$ is the width, and $Y$ is the height\nof the room.  The second line consists of a single integer $N$, the\nnumber of people in the room.  Then $N$ lines follow, each of them\nconsisting of two floating-point numbers $x_i$ and $y_i$, the\ncoordinates of the $i^{th}$ person in the room.\n\n**Limits**\n\n- $1 \\le X, Y \\le 1\\,000\\,000 $\n- $1 \\le N \\le 1\\,000$\n- $0 \\le x_i \\le X$\n- $0 \\le y_i \\le Y$", "outputFormat": "The output consists of a single value $d$, the maximum safe distance,  as a floating-point number. \n\nAn additive or multiplicative error of $10^{-5}$ is tolerated: if $d$ is the answer, \nany number either within $[d - 10^{-5}; d + 10^{-5}]$ or within $[(1 - 10^{-5})d ;(1 + 10^{-5})d]$ is accepted.", "hint": "Alice can keep a distance of 2.25 from every other person, and this is\nthe best she can do. The picture below shows a possible path (in green).\n\n\n:::align{center}\n\n![](https://espresso.codeforces.com/f255fbcd3516966354b195a2a130d94c9406d985.png)\n\n:::", "locale": "en", "translations": {"en": {"title": "[SWERC 2020] Safe Distance", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/576cf263ac1df37ed5abd75cfa081608a638ae40.png)\n\n:::\n\nThe past year has been difficult, with a virus spreading among the population.\nFortunately, Alice knows that one of the keys to be healthy is to keep a safe distance from other people.\n\nAlice is currently in a closed room, represented in the $2D$ plane, with width $X$ and height $Y$.\nThere are $N$ other people inside the room, and we're given their $(x_i, y_i)$ coordinates.\n\nWe consider Alice and the $N$ people as points in the $2D$ plane.\nAlice's initial position is $(0, 0)$ and she wants to move to the exit at position $(X, Y)$. \nShe can move freely in any direction inside the room, but can not step outside the room bounds.\n\nFind the maximum distance Alice can keep from other people while moving from $(0, 0)$ to $(X, Y)$.\n\n", "inputFormat": "The input begins with one line containing two space-separated\nintegers, $X$ and $Y$, where $X$ is the width, and $Y$ is the height\nof the room.  The second line consists of a single integer $N$, the\nnumber of people in the room.  Then $N$ lines follow, each of them\nconsisting of two floating-point numbers $x_i$ and $y_i$, the\ncoordinates of the $i^{th}$ person in the room.\n\n**Limits**\n\n- $1 \\le X, Y \\le 1\\,000\\,000 $\n- $1 \\le N \\le 1\\,000$\n- $0 \\le x_i \\le X$\n- $0 \\le y_i \\le Y$", "outputFormat": "The output consists of a single value $d$, the maximum safe distance,  as a floating-point number. \n\nAn additive or multiplicative error of $10^{-5}$ is tolerated: if $d$ is the answer, \nany number either within $[d - 10^{-5}; d + 10^{-5}]$ or within $[(1 - 10^{-5})d ;(1 + 10^{-5})d]$ is accepted.", "hint": "Alice can keep a distance of 2.25 from every other person, and this is\nthe best she can do. The picture below shows a possible path (in green).\n\n\n:::align{center}\n\n![](https://espresso.codeforces.com/f255fbcd3516966354b195a2a130d94c9406d985.png)\n\n:::", "locale": "en"}, "zh-CN": {"title": "[SWERC 2020] Safe Distance", "background": null, "description": ":::align{center}\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9dkboio9.png)\n\n:::\n\n刚刚过去的一年非常艰难，因为一种病毒在人群中传播。\n幸运的是，Alice 知道保持健康的关键之一就是与他人保持安全距离。\n\n Alice 目前正处在一个封闭的房间里，该房间可以看作一个宽度为 $X$ ，高度为 $Y$ 的二维平面。\n房间内有 $N$ 个其他人，我们知道他们的坐标，第 $i$ 个人的坐标是 $(x_i, y_i)$。\n\n我们将 Alice 和这 $N$ 个人分别视为在一个二维平面上的点。\nAlice 的初始位置是 $(0, 0)$，她想要移动到位于 $(X, Y)$ 处的出口。\n她可以在房间内自由地向任何方向移动，但不能踏出房间边界。\n\n请找出 Alice 在从 $(0,0)$ 移动到 $(X, Y)$ 的过程中能够保持的与其他人的最大距离。", "inputFormat": "输入第一行包含两个空格分隔的整数 $X$ 和 $Y$，分别表示房间的宽度和高度。\n\n第二行包含一个整数 $N$，表示房间中的人数。\n\n接下来 $N$ 行，每行包含两个浮点数 $x_i$ 和 $y_i$，表示第 $i$个人的坐标。\n\n**限制条件**\n\n- $1 \\le X, Y \\le 1\\,000\\,000 $\n- $1 \\le N \\le 1\\,000$\n- $0 \\le x_i \\le X$\n- $0 \\le y_i \\le Y$", "outputFormat": "输出一个浮点数 $d$，表示 Alice 能与每个人保持的最大距离。\n\n允许$10^{-5}$ 的相对或绝对误差：如果 $d$ 是正确答案，\n那么任何在区间 $[d - 10^{-5}; d + 10^{-5}]$ 内或区间 $[(1 - 10^{-5})d ;(1 + 10^{-5})d]$ 内的数值都被认为是正确答案。", "hint": "Alice 可以与每个人保持 2.25 的距离，这是她能做到的最好结果。\n下图中展示了一条可能的路径（颜色为绿色）。\n\n:::align{center}\n\n![](https://espresso.codeforces.com/f255fbcd3516966354b195a2a130d94c9406d985.png)\n\n:::\n\nTranslate by SegmentSplay ，使用 Deepseek R1作为辅助翻译。", "locale": "zh-CN"}}}
{"pid": "P13860", "type": "P", "difficulty": 3, "samples": [["4 4 80 90\n0 1 40\n0 2 50\n1 2 30\n2 3 10", "3"], ["2 1 7 7\n0 1 3", "1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "最短路", "ICPC"], "title": "[SWERC 2020] Jogging", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/453bbfab2709b17ff1fe56b9730cc31acfb43f9a.png)\n\n:::\n\nPheobe has heard that exercise has a tremendous affect on both physical and mental health.\nShe never went jogging before, and she wants to try it out.\nHowever, she knows that she gets bored quickly and it is difficult for her to repeatedly do the same thing.\nIn order to get into the habit of jogging, Pheobe decided to take up a challenge:\nshe will go out for a run every evening as long as she finds an interesting path to take.\nFor her, a path is interesting if it goes through a street where she did not run before.\nPheobe asks for your help in understanding what is the maximum number of days she can run if she plans well.\n\nPheobe gives you as input a description of her neighborhood. She lives on an intersection,\nand she describes all of the intersections in the neighborhood. She also tells you which\nintersections are connected by streets, and what is the length of each street in meters.\nEvery street connects two different intersections, and it is not possible that two different streets connect the same two intersections.\nIn addition, you may assume that Pheobe only describes streets that can be reached from her home and that\nstreets can be traversed in both directions as Phoebe is on foot.\n\nA valid run starts and ends in Pheobe's home, and its length should be within the range that Pheobe specifies.\nWhen Pheobe enters a street, she does not have to go through the entire street (she is allowed to turn around at any point),\nbut even if she does that, it counts as if she has seen the entire street for the purpose of determining whether runs are interesting.\nA run is considered interesting if it includes a street (or a segment of it) that did not appear on previous runs.\nReaching an intersection does not count as visiting all streets adjacent to\nit.", "inputFormat": "The input begins with one line containing four space-separated integers, $I$ $S$ $L$ $U$, in that order.\n$I$ represents the number of intersections in the neighborhood, and $S$ represents the number of streets.\n$L$ is the minimum number of meters in a valid run, and $U$ is the maximum number of meters in a valid run.\n\nThen, follow $S$ lines, each line representing a street.\nEach such line contains $3$ space-separated integers, $i$ $j$ $\\ell$, in that order.\nIntegers $i$ and $j$ are the intersections that the street connects, and $\\ell$ is the length of the street in meters.\nThe intersections are numbered between $0$ and $I-1$ such that Pheobe lives in intersection number $0$.\n\n**Limits**\n\n- $1 \\le I \\le 100\\,000$\n- $0 \\le S \\le 100\\,000$\n- $1 \\le L \\le U \\le 42\\,195$ (Pheobe will not run more than a marathon)\n- $1 \\le \\ell \\le 1\\,000$\n", "outputFormat": "A single line containing a single integer holding the length of the longest sequence of interesting runs.", "hint": "**Sample Explanation 1**\n\nHere is an example for an interesting 3-day jogging plan for the first sample input:\n- On the first day, run back and forth on the street between $0$ and $1$ ($80$ meters).\n\n- On the second day, run for 40 meters on the street  to $2$ and then go back the same way ($80$ meters).\n- On the third day, run on the street to $1$, then run for $5$ meters in the direction of $2$, and then go back the same way ($90$ meters).\n\n**Sample Explanation 2**\n\nHere is one possible valid run: Run from $0$ to $1$, then back to $0$,\nthen half a meter in the direction of $1$, and then back to $0$.", "locale": "en", "translations": {"en": {"title": "[SWERC 2020] Jogging", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/453bbfab2709b17ff1fe56b9730cc31acfb43f9a.png)\n\n:::\n\nPheobe has heard that exercise has a tremendous affect on both physical and mental health.\nShe never went jogging before, and she wants to try it out.\nHowever, she knows that she gets bored quickly and it is difficult for her to repeatedly do the same thing.\nIn order to get into the habit of jogging, Pheobe decided to take up a challenge:\nshe will go out for a run every evening as long as she finds an interesting path to take.\nFor her, a path is interesting if it goes through a street where she did not run before.\nPheobe asks for your help in understanding what is the maximum number of days she can run if she plans well.\n\nPheobe gives you as input a description of her neighborhood. She lives on an intersection,\nand she describes all of the intersections in the neighborhood. She also tells you which\nintersections are connected by streets, and what is the length of each street in meters.\nEvery street connects two different intersections, and it is not possible that two different streets connect the same two intersections.\nIn addition, you may assume that Pheobe only describes streets that can be reached from her home and that\nstreets can be traversed in both directions as Phoebe is on foot.\n\nA valid run starts and ends in Pheobe's home, and its length should be within the range that Pheobe specifies.\nWhen Pheobe enters a street, she does not have to go through the entire street (she is allowed to turn around at any point),\nbut even if she does that, it counts as if she has seen the entire street for the purpose of determining whether runs are interesting.\nA run is considered interesting if it includes a street (or a segment of it) that did not appear on previous runs.\nReaching an intersection does not count as visiting all streets adjacent to\nit.", "inputFormat": "The input begins with one line containing four space-separated integers, $I$ $S$ $L$ $U$, in that order.\n$I$ represents the number of intersections in the neighborhood, and $S$ represents the number of streets.\n$L$ is the minimum number of meters in a valid run, and $U$ is the maximum number of meters in a valid run.\n\nThen, follow $S$ lines, each line representing a street.\nEach such line contains $3$ space-separated integers, $i$ $j$ $\\ell$, in that order.\nIntegers $i$ and $j$ are the intersections that the street connects, and $\\ell$ is the length of the street in meters.\nThe intersections are numbered between $0$ and $I-1$ such that Pheobe lives in intersection number $0$.\n\n**Limits**\n\n- $1 \\le I \\le 100\\,000$\n- $0 \\le S \\le 100\\,000$\n- $1 \\le L \\le U \\le 42\\,195$ (Pheobe will not run more than a marathon)\n- $1 \\le \\ell \\le 1\\,000$\n", "outputFormat": "A single line containing a single integer holding the length of the longest sequence of interesting runs.", "hint": "**Sample Explanation 1**\n\nHere is an example for an interesting 3-day jogging plan for the first sample input:\n- On the first day, run back and forth on the street between $0$ and $1$ ($80$ meters).\n\n- On the second day, run for 40 meters on the street  to $2$ and then go back the same way ($80$ meters).\n- On the third day, run on the street to $1$, then run for $5$ meters in the direction of $2$, and then go back the same way ($90$ meters).\n\n**Sample Explanation 2**\n\nHere is one possible valid run: Run from $0$ to $1$, then back to $0$,\nthen half a meter in the direction of $1$, and then back to $0$.", "locale": "en"}, "zh-CN": {"title": "[SWERC 2020] Jogging", "background": null, "description": "菲比听说运动对身心健康都有着极大影响。她以前从未慢跑过，现在想尝试一下。但她知道自己很容易感到无聊，难以重复做同一件事。为了养成慢跑习惯，菲比决定接受一项挑战：只要能找到有趣的路线，她就会每天晚上出去跑步。对她而言，若路线会经过一条她之前没跑过的街道，这条路线就是有趣的。菲比希望你帮忙分析，若规划得当，她最多能跑步多少天。  \n菲比会向你提供她所在社区的相关信息作为输入。她住在一个十字路口，同时会描述社区里所有的十字路口。她还会告知哪些十字路口之间有街道相连，以及每条街道的长度（以米为单位）。每条街道都连接两个不同的十字路口，且不存在两条不同的街道连接同一对十字路口的情况。此外，你可以默认菲比描述的所有街道都能从她家抵达，且由于菲比是步行，这些街道都可以双向通行。  \n一次有效的跑步需从菲比家出发并回到家，且跑步长度需在她指定的范围内。当菲比进入一条街道时，她无需跑完整条街道（可以在任意位置转身），但即便如此，在判断跑步是否 “有趣” 时，仍会将其视为已经见过了整条街道。若一次跑步包含了一条之前跑步中未出现过的街道（或街道的某一段），这次跑步就会被认定为 “有趣”。需要注意的是，抵达某个十字路口并不等同于访问了该路口相邻的所有街道。", "inputFormat": "输入以一行内容开头，包含四个用空格分隔的整数，顺序依次为 $I$、$S$、$L$、$U$。各参数含义如下：  \n$I$ 表示社区内十字路口的数量。  \n$S$ 表示街道的数量。  \n$L$ 表示一次有效跑步的最小长度（单位：米）。  \n$U$ 表示一次有效跑步的最大长度（单位：米）。   \n随后是 $S$ 行内容，每行代表一条街道。每行包含三个用空格分隔的整数，顺序依次为 $i$、$j$、$ℓ$。各参数含义如下：  \n整数 $i$ 和 $j$ 是该街道连接的两个十字路口的编号。  \n$ℓ$ 是该街道的长度（单位：米）。  \n所有十字路口的编号范围为 $0$ 到 $I - 1$，其中菲比（Pheobe）居住在编号为 $0$ 的十字路口。", "outputFormat": "输出一行内容，包含一个整数，该整数表示 “有趣的跑步” 所能构成的最长序列的长度（即最多能跑步的天数）。", "hint": "##### 示例解释 1\n以下是针对第一个示例输入的一份为期 $3$ 天的 “有趣跑步” 计划：\n第一天，在连接十字路口 $0$ 和 $1$ 的街道上来回跑步（总长度 $80$ 米）。\n第二天，沿街道向十字路口 $2$ 的方向跑 $40$ 米，之后沿原路返回（总长度 $80$ 米）。\n第三天，先沿街道跑到十字路口 $1$，再向十字路口 $2$ 的方向跑 $5$ 米，之后沿原路返回（总长度 $90$ 米）。\n##### 示例解释 2\n以下是一个有效的跑步方案：从十字路口 $0$ 跑到十字路口 $1$，再返回十字路口 $0$，接着向十字路口 $1$ 的方向跑 $0.5$ 米，最后返回十字路口 $0$。\n\n- $1 \\le I \\le 100\\,000$\n- $0 \\le S \\le 100\\,000$\n- $1 \\le L \\le U \\le 42\\,195$ (菲比不会跑超过一场马拉松的距离)\n- $1 \\le \\ell \\le 1\\,000$", "locale": "zh-CN"}}}
{"pid": "P13861", "type": "P", "difficulty": 1, "samples": [["3\n100 500\n2 5\n70 1000", "2"], ["3\n100 50\n2 5\n70 1000", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "ICPC"], "title": "[SWERC 2020] Cakes", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/d802e25d143983ebaf159911df93c32ec3a1f5ba.png)\n\n:::\n\n\nThis summer, you plan to organize a large party and invite many\nfriends. They have a sweet tooth, so you plan to bake nice cakes for them.\nYou know the recipe for a nice chocolate cake, and you want to cook as\nmany of them as possible.\n\nGiven the $N$ ingredients needed to make a single cake and the\ningredients that you have in your kitchen, how many cakes can you\nmake?", "inputFormat": "- The first line of the input contains a single integer $N$.\n- Then, $N$ lines follow, one for each ingredient. Each of these lines\ncontains two positive integers: the first one is the required quantity\nof this ingredient per cake, the second one is the quantity of this\ningredient you have in your kitchen.\n\n**Limits**\n\n- $1 \\leq N \\leq 10$\n- All ingredient quantities will be integers between $1$ and $10\\,000$.", "outputFormat": "The output should contain a single integer: the maximum number of\ncakes you can make using the available ingredients.", "hint": "", "locale": "en", "translations": {"en": {"title": "[SWERC 2020] Cakes", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/d802e25d143983ebaf159911df93c32ec3a1f5ba.png)\n\n:::\n\n\nThis summer, you plan to organize a large party and invite many\nfriends. They have a sweet tooth, so you plan to bake nice cakes for them.\nYou know the recipe for a nice chocolate cake, and you want to cook as\nmany of them as possible.\n\nGiven the $N$ ingredients needed to make a single cake and the\ningredients that you have in your kitchen, how many cakes can you\nmake?", "inputFormat": "- The first line of the input contains a single integer $N$.\n- Then, $N$ lines follow, one for each ingredient. Each of these lines\ncontains two positive integers: the first one is the required quantity\nof this ingredient per cake, the second one is the quantity of this\ningredient you have in your kitchen.\n\n**Limits**\n\n- $1 \\leq N \\leq 10$\n- All ingredient quantities will be integers between $1$ and $10\\,000$.", "outputFormat": "The output should contain a single integer: the maximum number of\ncakes you can make using the available ingredients.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[SWERC 2020] Cakes", "background": null, "description": ":::align{center}\n![](https://espresso.codeforces.com/d802e25d143983ebaf159911df93c32ec3a1f5ba.png)\n:::\n\n这个夏天，你打算举办一个大型聚会并邀请许多朋友。他们都很喜欢甜食，所以你打算为他们烤一些美味的巧克力蛋糕。\n你已经掌握了一份巧克力蛋糕的配方，现在你想尽可能多地烤蛋糕。\n\n已知做一个蛋糕需要用到 $N$ 种食材，同时你也知道自己厨房里现有的食材数量。请问，你最多能烤出多少个蛋糕？", "inputFormat": "- 输入的第一行包含一个整数 $N$。\n- 接下来 $N$ 行，每行包含两个正整数：第一个整数表示制作一个蛋糕所需的该种食材数量；第二个整数表示你厨房里现有的该种食材数量。\n\n### 数据范围\n\n* $1 \\leq N \\leq 10$\n* 所有食材数量均为 $1$ 到 $10\\,000$ 之间的整数。", "outputFormat": "输出一个整数，表示在现有食材下你最多能烤出的蛋糕数量。", "hint": "本翻译由 ChatGPT-5 生成", "locale": "zh-CN"}}}
{"pid": "P13862", "type": "P", "difficulty": 5, "samples": [["2 4 2", "1"], ["2 4 3", "0"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2020", "ICPC"], "title": "[SWERC 2020] Mentors", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/2baac29ca18cd12329d389601156eed04920c7b6.png)\n\n:::\n\nThe Happy Tree Friends have gathered for their\nannual meeting, in which they take their most important\ndecisions for the year to come.\nThis year, they will set up a mentoring program\nto help each other take better care of their loved ones.\nThis programme follows a tree-like hierarchical\nstructure as follows.\n\nThe $N$ members of the programme are ranked\nfrom $1$ to $N$ (each rank is assigned once),\nby increasing seniority. For the mentorship\nprogramme to be efficient, a person ranked $A$ can mentor\na person ranked $B$ only if $A > B$.\nThe most senior Happy Tree Friend can have no mentor, but\neverybody else has a unique mentor. Conversely,\neverybody is allowed to mentor from zero to two people.\n\nHowever, Mr. Pickles, who was assigned the rank $R$,\nplans to take a sabbatical this year. Thus,\nhe will not be able to mentor anybody,\nand the Happy Tree Friends\nshould choose their hierarchical structure among those\ntrees in which the node labelled $R$ is a leaf.\n\nAiming to help his friends to choose such a tree,\nMr. Pickles decides to first count how many trees would\nmatch his constraint. Unfortunately,\nhe stopped school early, and\nthus did not learn how to manipulate integers of arbitrary\nsize. Instead, he counts modulo $M$, where $M$ is a fixed\npositive integer: this is already enough for most purposes\nin life.\n\nWhat is the number $L$ that Mr. Pickles will obtain\nafter counting all suitable trees?", "inputFormat": "The input consists of a single line,\nwith three space-separated integers:\n$R$, $N$, $M$, in that order.\n\n**Limits**\n\n- $1 \\leqslant R \\leqslant N \\leqslant 2021$\n- $1 \\leqslant M \\leqslant 1\\,000\\,000\\,000$", "outputFormat": "The output should contain a single line with\nthe single integer $L$, which is the number of tree-like\nhierarchical structures that would match\nMr. Pickles' constraints, counted modulo $M$.", "hint": "**Sample Explanation 1**\n\nThe node with label $R = 2$ is a leaf in exactly\n$3$ of five trees listed below, and thus there are\n$3$ trees that match Mr. Pickles' constraints.\nThe only meaningful feature of our trees is parenthood,\nwhich represents mentorship relations,\nand thus there is no notion of *left child* or\n*right child* of a node.\nMr. Pickles counts modulo $M = 2$, and therefore he ends up\nwith the number $L = 3~(\\mathrm{mod~}2) = 1$.\n\n:::align{center}\n\n![](https://espresso.codeforces.com/dd699730f7c7f1af79ed751feae42e8074e464c5.png)\n\n:::\n\n\n**Sample Explanation 2**\n\nMr. Pickles now counts modulo $M = 3$, and \nthus he ends up\nwith the number $L = 3~(\\mathrm{mod~}3) = 0$.", "locale": "en", "translations": {"en": {"title": "[SWERC 2020] Mentors", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/2baac29ca18cd12329d389601156eed04920c7b6.png)\n\n:::\n\nThe Happy Tree Friends have gathered for their\nannual meeting, in which they take their most important\ndecisions for the year to come.\nThis year, they will set up a mentoring program\nto help each other take better care of their loved ones.\nThis programme follows a tree-like hierarchical\nstructure as follows.\n\nThe $N$ members of the programme are ranked\nfrom $1$ to $N$ (each rank is assigned once),\nby increasing seniority. For the mentorship\nprogramme to be efficient, a person ranked $A$ can mentor\na person ranked $B$ only if $A > B$.\nThe most senior Happy Tree Friend can have no mentor, but\neverybody else has a unique mentor. Conversely,\neverybody is allowed to mentor from zero to two people.\n\nHowever, Mr. Pickles, who was assigned the rank $R$,\nplans to take a sabbatical this year. Thus,\nhe will not be able to mentor anybody,\nand the Happy Tree Friends\nshould choose their hierarchical structure among those\ntrees in which the node labelled $R$ is a leaf.\n\nAiming to help his friends to choose such a tree,\nMr. Pickles decides to first count how many trees would\nmatch his constraint. Unfortunately,\nhe stopped school early, and\nthus did not learn how to manipulate integers of arbitrary\nsize. Instead, he counts modulo $M$, where $M$ is a fixed\npositive integer: this is already enough for most purposes\nin life.\n\nWhat is the number $L$ that Mr. Pickles will obtain\nafter counting all suitable trees?", "inputFormat": "The input consists of a single line,\nwith three space-separated integers:\n$R$, $N$, $M$, in that order.\n\n**Limits**\n\n- $1 \\leqslant R \\leqslant N \\leqslant 2021$\n- $1 \\leqslant M \\leqslant 1\\,000\\,000\\,000$", "outputFormat": "The output should contain a single line with\nthe single integer $L$, which is the number of tree-like\nhierarchical structures that would match\nMr. Pickles' constraints, counted modulo $M$.", "hint": "**Sample Explanation 1**\n\nThe node with label $R = 2$ is a leaf in exactly\n$3$ of five trees listed below, and thus there are\n$3$ trees that match Mr. Pickles' constraints.\nThe only meaningful feature of our trees is parenthood,\nwhich represents mentorship relations,\nand thus there is no notion of *left child* or\n*right child* of a node.\nMr. Pickles counts modulo $M = 2$, and therefore he ends up\nwith the number $L = 3~(\\mathrm{mod~}2) = 1$.\n\n:::align{center}\n\n![](https://espresso.codeforces.com/dd699730f7c7f1af79ed751feae42e8074e464c5.png)\n\n:::\n\n\n**Sample Explanation 2**\n\nMr. Pickles now counts modulo $M = 3$, and \nthus he ends up\nwith the number $L = 3~(\\mathrm{mod~}3) = 0$.", "locale": "en"}}}
{"pid": "P13863", "type": "P", "difficulty": 5, "samples": [["18 10", "11 13 15 1 2 4 7 9 12 0"], ["168 9", "1 2 4 7 9 12 18 24 32"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "Special Judge", "基环树", "ICPC"], "title": "[SWERC 2020] Decoration", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/5880fd0271455e7f384666c403e859578d418187.png)\n\n:::\n\nAfter all these months of lockdown, you are tired of the interior decoration of your home and decide to redesign it.\nHence, you read many blog posts and magazines about Feng Shui decorating and other recent trends on home design.\nAfter some time of thinking, you decide to reproduce the idea of the famous designer Sweta Marc for replacing your bookcase with a new one you will build.\n\nAccording to S. Marc, a harmonious bookcase always has several shelves spaced in an heterogeneous manner, and always following some very precise rules.\nMore precisely, such a bookcase has a *serenity value* $N$ and is composed of $K+1$ shelves spaced by $s_1, \\ldots, s_K$ millimeters between each other, from the bottom to the top.\nAccording to S. Marc ideals, these spaces should verify the following properties:\n1. They should be *heterogeneous*, i.e., no two spaces have the same height.\n2. They should be *not too high*, i.e., for all $i \\in [1, K]$, we should have $0 \\leq s_i < N$. Note that one of these spaces might actually have size $0$: this is one of the oddities which make Sweta's tastes so visually attractive (arguably, this is a loss of space, but you are ready for that in the name of elegance, well-being... and trendiness).\n3. They should be *serene*, i.e., for all $i \\in [1, K-1]$, Sweta prefers if $s_{i+1}$ is congruent modulo $N$ to $s_i$ plus the number of divisors of $s_i$. (Yes, Ms. Marc is sophisticated and loves arithmetic.)\n\nYou tried to design a bookcase according to the advice of Sweta Marc, but you find it hard to satisfy all the requirements.\nThe only few solutions you found result in a bookcase which is too tall for your place.\n\nTherefore, you decide to write a program which, given the number of shelves $K$ and the serenity value $N$, computes the values of the spaces $s_1, \\ldots, s_K$ of one of the minimum height bookcases, i.e. a bookcase where the sum of spaces $s_1 + \\cdots + s_K$ is the smallest.", "inputFormat": "The only line of input contains two integers $N$ and $K$ separated by a space.\n\n**Limits**\n\n- $1 \\leq N \\leq 1\\,000\\,000 $\n- $1 \\leq K \\leq 1\\,000\\,000 $", "outputFormat": "The output should contain a single line containing either:\n- $-1$ if it is not possible to satisfy Sweta Marc's prescriptions for the given values of $K$ and $N$,\n- otherwise, $K$ integers $s_1, \\ldots, s_K$, corresponding to the spaces between the shelves of one of the minimum height bookcases satisfying the constraints. If several solutions are possible, the output should contain any of them.", "hint": "We recall the following mathematical definitions ($a$ and $b$ are arbitrary integers):\n- $a$ *divides* $b$ if there exists an integer $q$ such that $b = aq$;\n- $a$ is a *divisor* of $b$ if $b \\neq 0$ and $a$ divides $b$;\n- $a$ is *congruent* to $b$ if $N$ divides $b-a$.\n", "locale": "en", "translations": {"en": {"title": "[SWERC 2020] Decoration", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/5880fd0271455e7f384666c403e859578d418187.png)\n\n:::\n\nAfter all these months of lockdown, you are tired of the interior decoration of your home and decide to redesign it.\nHence, you read many blog posts and magazines about Feng Shui decorating and other recent trends on home design.\nAfter some time of thinking, you decide to reproduce the idea of the famous designer Sweta Marc for replacing your bookcase with a new one you will build.\n\nAccording to S. Marc, a harmonious bookcase always has several shelves spaced in an heterogeneous manner, and always following some very precise rules.\nMore precisely, such a bookcase has a *serenity value* $N$ and is composed of $K+1$ shelves spaced by $s_1, \\ldots, s_K$ millimeters between each other, from the bottom to the top.\nAccording to S. Marc ideals, these spaces should verify the following properties:\n1. They should be *heterogeneous*, i.e., no two spaces have the same height.\n2. They should be *not too high*, i.e., for all $i \\in [1, K]$, we should have $0 \\leq s_i < N$. Note that one of these spaces might actually have size $0$: this is one of the oddities which make Sweta's tastes so visually attractive (arguably, this is a loss of space, but you are ready for that in the name of elegance, well-being... and trendiness).\n3. They should be *serene*, i.e., for all $i \\in [1, K-1]$, Sweta prefers if $s_{i+1}$ is congruent modulo $N$ to $s_i$ plus the number of divisors of $s_i$. (Yes, Ms. Marc is sophisticated and loves arithmetic.)\n\nYou tried to design a bookcase according to the advice of Sweta Marc, but you find it hard to satisfy all the requirements.\nThe only few solutions you found result in a bookcase which is too tall for your place.\n\nTherefore, you decide to write a program which, given the number of shelves $K$ and the serenity value $N$, computes the values of the spaces $s_1, \\ldots, s_K$ of one of the minimum height bookcases, i.e. a bookcase where the sum of spaces $s_1 + \\cdots + s_K$ is the smallest.", "inputFormat": "The only line of input contains two integers $N$ and $K$ separated by a space.\n\n**Limits**\n\n- $1 \\leq N \\leq 1\\,000\\,000 $\n- $1 \\leq K \\leq 1\\,000\\,000 $", "outputFormat": "The output should contain a single line containing either:\n- $-1$ if it is not possible to satisfy Sweta Marc's prescriptions for the given values of $K$ and $N$,\n- otherwise, $K$ integers $s_1, \\ldots, s_K$, corresponding to the spaces between the shelves of one of the minimum height bookcases satisfying the constraints. If several solutions are possible, the output should contain any of them.", "hint": "We recall the following mathematical definitions ($a$ and $b$ are arbitrary integers):\n- $a$ *divides* $b$ if there exists an integer $q$ such that $b = aq$;\n- $a$ is a *divisor* of $b$ if $b \\neq 0$ and $a$ divides $b$;\n- $a$ is *congruent* to $b$ if $N$ divides $b-a$.\n", "locale": "en"}}}
{"pid": "P13864", "type": "P", "difficulty": 5, "samples": [["3\n+0 +2\n-0 +1\n-1 -2\n1\n2\n2", "2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "可持久化线段树", "ICPC"], "title": "[SWERC 2020] Figurines", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/904ae68696bdc1013bdb48d17e3f365f0a7f90a7.png)\n\n:::\n\nBob has a lot of mini figurines. He likes to display some of them on a\nshelf above his computer screen and he likes to regularly change which\nfigurines appear. This ever-changing decoration is really enjoyable.\nBob takes care of never adding the same mini figurine more than\nonce. Bob has only $N$ mini figurines and after $N$ days he arrives at\nthe point where each of the $N$ figurines have been added and then\nremoved from the shelf (which is thus empty).\n\nBob has a very good memory. He is able to remember which mini\nfigurines were displayed on each of the past days.\nSo Bob wants to run a little mental\nexercise to test its memory and computation ability. For this purpose,\nBob numbers his figurines with the numbers $0, \\dots, N-1$ and selects\na sequence of $N$ integers $d_0 \\dots d_{N-1}$ all in the range\n$[0;N]$. Then, Bob computes a sequence $x_0,\\dots, x_N$ in the\nfollowing way: $x_0=0$ and $x_{i+1}=(x_i+y_i)\\text{ mod } N$\nwhere $\\text{mod}$ is the modulo operation and $y_i$ is the number of\nfigurines displayed on day $d_i$ that have a number higher or equal to\n$x_i$.  The result of Bob's computation is $x_N$.\n\nMore formally, if we note $S(i)$ the subset of $\\{0,\\dots,N-1\\}$ corresponding\nto figurines displayed on the shelf on day $i$, we have:\n- $S(0)$ is the empty set;\n- $S(i)$ is obtained from $S(i-1)$ by inserting and removing some elements.\n\nEach element $0 \\le j < N$ is inserted and removed exactly once and\nthus, the last set $S(N)$ is also the empty set.  The computation that\nBob performs corresponds to the following program:\n\n$$\n\\begin{array}{l}\nx_0 \\leftarrow 0 \\\\\n\\text{for } i \\in [0;N-1] \\\\\n\\;\\;\\;\\;\\;\\;\\; x_{i+1} \\leftarrow (x_i + \\#\\{y \\in S(d_i) ~\\text{ such that } ~ y \\ge x_i\\}) \\mod N \\\\\n\\text{output } x_N\n\\end{array}\n$$\n\nBob asks you to verify his computation. For that he gives you the\nnumbers he used during its computation (the $d_0, \\dots, d_{N-1}$) as\nwell as the log of which figurines he added or removed every day. Note\nthat a mini figurine added on day $i$ and removed on day $j$ is\npresent on a day $k$ when $i\\leq k < j$. You should tell him the\nnumber that you found at the end of the computation.", "inputFormat": "The input is composed of $2N+1$ lines.\n- The first line contains the integer $N$.\n- Lines $2$ to $N+1$ describe the figurines added and removed.\n  Line $i+1$ contains space-separated $+j$ or $-j$,\n  with $0 \\le j < N$, to indicate that $j$ is added or removed on day\n  $i$. This line may be empty. A line may contain both $+j$\n  and $-j$, in that order.\n- Lines $N+2$ to $2N+1$ describe the sequence $d_0,\\dots, d_{N-1}$.\n      Line $N+2+i$ contains the integer $d_i$ with $0 \\le d_i \\le N$.\n\n**Limits**\n\n- $1 \\le N \\le 100\\,000$\n", "outputFormat": "The output should contain a single line with a single integer which is $x_N$.", "hint": "**Sample Explanation**\n\nThe output is $2$ since\n- first, $x \\leftarrow 2$ since $S(1) = \\{ 0, 2 \\}$ and $\\#\\{y \\in S(1)\n  ~\\text{such that}~ y \\ge 0\\} = 2$;\n- then, $x \\leftarrow 0$ since $S(2) = \\{ 1, 2 \\}$ and $\\#\\{y \\in S(2)\n  ~\\text{such that}~ y \\ge 2\\} = 1$;\n- and finally, $x \\leftarrow 2$ since $S(2) = \\{ 1, 2 \\}$ and $\\#\\{y \\in\n  S(2) ~\\text{such that}~ y \\ge 0\\} = 2$.", "locale": "en", "translations": {"en": {"title": "[SWERC 2020] Figurines", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/904ae68696bdc1013bdb48d17e3f365f0a7f90a7.png)\n\n:::\n\nBob has a lot of mini figurines. He likes to display some of them on a\nshelf above his computer screen and he likes to regularly change which\nfigurines appear. This ever-changing decoration is really enjoyable.\nBob takes care of never adding the same mini figurine more than\nonce. Bob has only $N$ mini figurines and after $N$ days he arrives at\nthe point where each of the $N$ figurines have been added and then\nremoved from the shelf (which is thus empty).\n\nBob has a very good memory. He is able to remember which mini\nfigurines were displayed on each of the past days.\nSo Bob wants to run a little mental\nexercise to test its memory and computation ability. For this purpose,\nBob numbers his figurines with the numbers $0, \\dots, N-1$ and selects\na sequence of $N$ integers $d_0 \\dots d_{N-1}$ all in the range\n$[0;N]$. Then, Bob computes a sequence $x_0,\\dots, x_N$ in the\nfollowing way: $x_0=0$ and $x_{i+1}=(x_i+y_i)\\text{ mod } N$\nwhere $\\text{mod}$ is the modulo operation and $y_i$ is the number of\nfigurines displayed on day $d_i$ that have a number higher or equal to\n$x_i$.  The result of Bob's computation is $x_N$.\n\nMore formally, if we note $S(i)$ the subset of $\\{0,\\dots,N-1\\}$ corresponding\nto figurines displayed on the shelf on day $i$, we have:\n- $S(0)$ is the empty set;\n- $S(i)$ is obtained from $S(i-1)$ by inserting and removing some elements.\n\nEach element $0 \\le j < N$ is inserted and removed exactly once and\nthus, the last set $S(N)$ is also the empty set.  The computation that\nBob performs corresponds to the following program:\n\n$$\n\\begin{array}{l}\nx_0 \\leftarrow 0 \\\\\n\\text{for } i \\in [0;N-1] \\\\\n\\;\\;\\;\\;\\;\\;\\; x_{i+1} \\leftarrow (x_i + \\#\\{y \\in S(d_i) ~\\text{ such that } ~ y \\ge x_i\\}) \\mod N \\\\\n\\text{output } x_N\n\\end{array}\n$$\n\nBob asks you to verify his computation. For that he gives you the\nnumbers he used during its computation (the $d_0, \\dots, d_{N-1}$) as\nwell as the log of which figurines he added or removed every day. Note\nthat a mini figurine added on day $i$ and removed on day $j$ is\npresent on a day $k$ when $i\\leq k < j$. You should tell him the\nnumber that you found at the end of the computation.", "inputFormat": "The input is composed of $2N+1$ lines.\n- The first line contains the integer $N$.\n- Lines $2$ to $N+1$ describe the figurines added and removed.\n  Line $i+1$ contains space-separated $+j$ or $-j$,\n  with $0 \\le j < N$, to indicate that $j$ is added or removed on day\n  $i$. This line may be empty. A line may contain both $+j$\n  and $-j$, in that order.\n- Lines $N+2$ to $2N+1$ describe the sequence $d_0,\\dots, d_{N-1}$.\n      Line $N+2+i$ contains the integer $d_i$ with $0 \\le d_i \\le N$.\n\n**Limits**\n\n- $1 \\le N \\le 100\\,000$\n", "outputFormat": "The output should contain a single line with a single integer which is $x_N$.", "hint": "**Sample Explanation**\n\nThe output is $2$ since\n- first, $x \\leftarrow 2$ since $S(1) = \\{ 0, 2 \\}$ and $\\#\\{y \\in S(1)\n  ~\\text{such that}~ y \\ge 0\\} = 2$;\n- then, $x \\leftarrow 0$ since $S(2) = \\{ 1, 2 \\}$ and $\\#\\{y \\in S(2)\n  ~\\text{such that}~ y \\ge 2\\} = 1$;\n- and finally, $x \\leftarrow 2$ since $S(2) = \\{ 1, 2 \\}$ and $\\#\\{y \\in\n  S(2) ~\\text{such that}~ y \\ge 0\\} = 2$.", "locale": "en"}}}
{"pid": "P13865", "type": "P", "difficulty": 4, "samples": [["4 3\n1 2\n2 3\n3 4", "2"], ["6 3\n1 2\n3 4\n5 6", "-1"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "Special Judge", "ICPC"], "title": "[SWERC 2020] Emails", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/ae92ce4c3694b86be54a3fb897367fc7774d5a18.png)\n\n:::\n\nAriadna's blog is filled with delicious recipes and sensible advice for a healthy and balanced lifestyle. Unsurprisingly, it has thus gathered an impressive number of readers. This reader base is now stable, and Ariadna feels that it would be useful for them to interact more and form a tighter community, one that is not solely anchored to the blog.\n\nAriadna knows that some of the readers are already friends or acquaintances, and therefore have each other's email addresses.\nShe thinks that a good start for developing the community would be for everyone to have everyone else's email address, so that everyone would be able to reach out to the entire group. \nSince she knows her blog's readers also greatly enjoy doing things in a \"decentralized\" fashion, she therefore devises the following protocol, to be started on day $D$:\n\n- Every day at 8am, everyone sends the current list of contacts in their address book to all of the contacts in their address book.\n- Every day at 8pm, everyone updates their address book, adding any new received email addresses.\n\nIf a person does not need to do any update at 8pm, then the process is said to have *converged* for this person, and she will no longer need to continue sending emails over the next days.\n\n\nYou are a skillful hacker and you have managed to get access to all of the blog readers' address books. \nYou would like to surprise and impress Ariadna by notifying her of whether or not the process she proposes will lead to everyone getting everyone else's address. Moreover, if the process is meant to succeed, you want to give her a good estimate of how many days it would take. \nMore precisely, if the process succeeds, you can either give her:\n- the number $E$ of days (including the first day) elapsed until the last update takes place, or\n- the number of days (including the first day) elapsed until the process has *converged* on everyone's side. Note that, according to Ariadna's definition, this is equal to $E+1$.", "inputFormat": "The first line of the input contains two integers $N$ and $M$, corresponding to the number of readers and respectively to the number of pairs of readers that initially have each other's email address. Readers are numbered from $1$ to $N$.\n\nThe $M$ following lines each contain two integers, $i$ and $j$, meaning that readers $i$ and $j$ initially have each other's email address. Note that this means that both reader $i$ has reader $j$'s address and reader $j$ has reader $i$'s address.\n\n**Limits**\n\n- $2\\leq N\\leq 100\\,000$\n- $1\\leq M\\leq 100\\,000$", "outputFormat": "The output should contain a single integer equal to either:\n- $-1$ if the process does not lead to everyone eventually having everyone else's email address, or\n- the estimated necessary number of days, otherwise. Note that this number may be equal to 0.\n", "hint": "- We assume the reader base is stable, i.e. no reader leaves and no additional reader joins throughout the process.\n- We assume that everyone knows their own email address; receiving one's own address is simply ignored. \n- You do no have to be \"consistent\" in your answers across several tests cases, meaning that you can output the value $E$ for one test case and $E+1$ for another.\n\n**Sample Explanation 1**\n\nThe process proceeds as follows:\n- On day $D$ at 8am:\n  - Reader $1$ sends the address of reader $2$ to reader $2$.\n  - Reader $2$ sends the addresses of readers $1$ and $3$ to readers $1$ and $3$.\n  - Reader $3$ sends the addresses of readers $2$ and $4$ to readers $2$ and $4$.\n  - Reader $4$ sends the address of reader $3$ to reader $3$. \n- On day $D$ after the 8pm update:\n  - Reader $1$'s address-book has been updated and contains the addresses of readers $2$ and $3$.\n  - Reader $2$'s address-book has been updated and contains the addresses of readers $1$, $3$ and $4$.\n  - Reader $3$'s address-book has been updated and contains the addresses of readers $1$, $2$ and $4$.\n  - Reader $4$'s address-book has been updated and contains the addresses of readers $2$ and $3$.\n- On day $D+1$ at 8am:\n  - Reader $1$ sends the addresses of readers $2$ and $3$ to readers $2$ and $3$.\n  - Reader $2$ sends the addresses of readers $1$, $3$ and $4$ to readers $1$, $3$ and $4$.\n  - Reader $3$ sends the addresses of readers $1$, $2$ and $4$ to readers $1$, $2$ and $4$.\n  - Reader $4$ sends the addresses of readers $2$ and $3$ to readers $2$ and $3$.\n- On day $D+1$ after the 8pm update:\n  - Reader $1$'s address-book has been updated and contains the addresses of readers $2$, $3$ and $4$.\n  - The process has converged for reader $2$ since there is no update.\n  - The process has converged for reader $3$ since there is no update.\n  - Reader $4$'s address-book has been updated and contains the addresses of readers $1$, $2$ and $3$.\n- On day $D+2$ at 8am:\n  - Reader $1$ sends the addresses of readers $2$, $3$ and $4$ to readers $2$, $3$ and $4$.\n  - Reader $4$ sends the addresses of readers $1$, $2$ and $3$ to readers $1$, $2$ and $3$.\n- On day $D+2$ after the 8pm update:\n  - The process has converged for reader $1$ since there is no update.\n  - The process has converged for reader $4$ since there is no update.\nThe last update takes place on day $D+1$, after ${\\textbf 2}$ elapsed days. \nThe process has converged for everyone on day $D+2$, after \n${\\textbf 3}$ elapsed days. \nThe sample output contains the former value, ${\\textbf 2}$.\nOutputting the latter value, ${\\textbf 3}$, is an equally correct alternative.", "locale": "en", "translations": {"en": {"title": "[SWERC 2020] Emails", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/ae92ce4c3694b86be54a3fb897367fc7774d5a18.png)\n\n:::\n\nAriadna's blog is filled with delicious recipes and sensible advice for a healthy and balanced lifestyle. Unsurprisingly, it has thus gathered an impressive number of readers. This reader base is now stable, and Ariadna feels that it would be useful for them to interact more and form a tighter community, one that is not solely anchored to the blog.\n\nAriadna knows that some of the readers are already friends or acquaintances, and therefore have each other's email addresses.\nShe thinks that a good start for developing the community would be for everyone to have everyone else's email address, so that everyone would be able to reach out to the entire group. \nSince she knows her blog's readers also greatly enjoy doing things in a \"decentralized\" fashion, she therefore devises the following protocol, to be started on day $D$:\n\n- Every day at 8am, everyone sends the current list of contacts in their address book to all of the contacts in their address book.\n- Every day at 8pm, everyone updates their address book, adding any new received email addresses.\n\nIf a person does not need to do any update at 8pm, then the process is said to have *converged* for this person, and she will no longer need to continue sending emails over the next days.\n\n\nYou are a skillful hacker and you have managed to get access to all of the blog readers' address books. \nYou would like to surprise and impress Ariadna by notifying her of whether or not the process she proposes will lead to everyone getting everyone else's address. Moreover, if the process is meant to succeed, you want to give her a good estimate of how many days it would take. \nMore precisely, if the process succeeds, you can either give her:\n- the number $E$ of days (including the first day) elapsed until the last update takes place, or\n- the number of days (including the first day) elapsed until the process has *converged* on everyone's side. Note that, according to Ariadna's definition, this is equal to $E+1$.", "inputFormat": "The first line of the input contains two integers $N$ and $M$, corresponding to the number of readers and respectively to the number of pairs of readers that initially have each other's email address. Readers are numbered from $1$ to $N$.\n\nThe $M$ following lines each contain two integers, $i$ and $j$, meaning that readers $i$ and $j$ initially have each other's email address. Note that this means that both reader $i$ has reader $j$'s address and reader $j$ has reader $i$'s address.\n\n**Limits**\n\n- $2\\leq N\\leq 100\\,000$\n- $1\\leq M\\leq 100\\,000$", "outputFormat": "The output should contain a single integer equal to either:\n- $-1$ if the process does not lead to everyone eventually having everyone else's email address, or\n- the estimated necessary number of days, otherwise. Note that this number may be equal to 0.\n", "hint": "- We assume the reader base is stable, i.e. no reader leaves and no additional reader joins throughout the process.\n- We assume that everyone knows their own email address; receiving one's own address is simply ignored. \n- You do no have to be \"consistent\" in your answers across several tests cases, meaning that you can output the value $E$ for one test case and $E+1$ for another.\n\n**Sample Explanation 1**\n\nThe process proceeds as follows:\n- On day $D$ at 8am:\n  - Reader $1$ sends the address of reader $2$ to reader $2$.\n  - Reader $2$ sends the addresses of readers $1$ and $3$ to readers $1$ and $3$.\n  - Reader $3$ sends the addresses of readers $2$ and $4$ to readers $2$ and $4$.\n  - Reader $4$ sends the address of reader $3$ to reader $3$. \n- On day $D$ after the 8pm update:\n  - Reader $1$'s address-book has been updated and contains the addresses of readers $2$ and $3$.\n  - Reader $2$'s address-book has been updated and contains the addresses of readers $1$, $3$ and $4$.\n  - Reader $3$'s address-book has been updated and contains the addresses of readers $1$, $2$ and $4$.\n  - Reader $4$'s address-book has been updated and contains the addresses of readers $2$ and $3$.\n- On day $D+1$ at 8am:\n  - Reader $1$ sends the addresses of readers $2$ and $3$ to readers $2$ and $3$.\n  - Reader $2$ sends the addresses of readers $1$, $3$ and $4$ to readers $1$, $3$ and $4$.\n  - Reader $3$ sends the addresses of readers $1$, $2$ and $4$ to readers $1$, $2$ and $4$.\n  - Reader $4$ sends the addresses of readers $2$ and $3$ to readers $2$ and $3$.\n- On day $D+1$ after the 8pm update:\n  - Reader $1$'s address-book has been updated and contains the addresses of readers $2$, $3$ and $4$.\n  - The process has converged for reader $2$ since there is no update.\n  - The process has converged for reader $3$ since there is no update.\n  - Reader $4$'s address-book has been updated and contains the addresses of readers $1$, $2$ and $3$.\n- On day $D+2$ at 8am:\n  - Reader $1$ sends the addresses of readers $2$, $3$ and $4$ to readers $2$, $3$ and $4$.\n  - Reader $4$ sends the addresses of readers $1$, $2$ and $3$ to readers $1$, $2$ and $3$.\n- On day $D+2$ after the 8pm update:\n  - The process has converged for reader $1$ since there is no update.\n  - The process has converged for reader $4$ since there is no update.\nThe last update takes place on day $D+1$, after ${\\textbf 2}$ elapsed days. \nThe process has converged for everyone on day $D+2$, after \n${\\textbf 3}$ elapsed days. \nThe sample output contains the former value, ${\\textbf 2}$.\nOutputting the latter value, ${\\textbf 3}$, is an equally correct alternative.", "locale": "en"}, "zh-CN": {"title": "[SWERC 2020] Emails", "background": null, "description": "阿里亚德娜知道，部分读者之间本就是朋友或熟人，因此彼此存有对方的电子邮箱地址。她认为，打造这个社群的良好开端，是让所有人都拥有其他所有人的邮箱地址，这样每个人都能联系到整个群体。由于她了解自己博客的读者也非常喜欢以 “去中心化” 的方式行事，于是她设计了如下协议，将于第 $D$ 天启动：\n\n- 每天早上 $8$ 点，所有人都会将自己通讯录中当前的联系人列表发送给通讯录里的每一位联系人。\n- 每天晚上 $8$ 点，所有人都会更新自己的通讯录，添加所有新收到的邮箱地址。\n\n如果某人在晚上 8 点无需进行任何更新，那么就称该流程对这个人而言已 “收敛”，此后她无需在后续日子里继续发送邮件。\n\n你是一名技艺高超的黑客，设法获取了该博客所有读者的通讯录权限。你想给阿里亚德娜一个惊喜，告知她其提出的这套流程是否能让所有人最终都获得其他人的地址。此外，如果流程能成功，你还需要为她准确估算所需天数。更具体地说，若流程成功，你可以选择给出以下任一数值：\n\n- 直至最后一次更新发生时所经过的天数 $E$（包含第一天）；\n- 直至流程在所有人端都收敛时所经过的天数（包含第一天）。请注意，根据阿里亚德娜的定义，该数值等于 $E + 1$。", "inputFormat": "输入的第一行包含两个整数 $N$ 和 $M$，分别对应读者数量和初始时互有对方邮箱地址的读者对数。读者编号从 $1$ 到 $N$。\n\n接下来 $M$ 行，每行包含两个整数 $i$ 和 $j$，表示读者 $i$ 和读者 $j$ 初始时互有对方的邮箱地址（即读者 $i$ 存有读者 $i$ 的地址，且读者 $j$ 也存有读者 $i$ 的地址）。", "outputFormat": "输出仅包含一个整数：\n\n- 若流程无法让所有人最终获得其他人的地址，输出 $-1$；\n- 否则输出估算所需的天数（该数值可以为 $0$）。", "hint": "**数据范围**\n- $2\\leq N\\leq 10^5$\n- $1\\leq M\\leq 10^5$\n- 我们假设读者群体是稳定的，即整个流程期间无读者退出、也无新读者加入。\n- 我们假设所有人都知晓自己的邮箱地址；收到自己的地址会被直接忽略。 \n- 你无需在不同测试用例间保持答案的 “一致性”，即可以在某个测试用例中输出 $E$，在另一个测试用例中输出 $E+1$。\n\n**样例 1 解释**\n\n流程的执行过程如下：\n- 第 $D$ 天早上 $8$ 点：\n  - 读者 $1$ 向读者 $2$ 发送读者 $2$ 的地址。\n  - 读者 $2$ 向读者 $1$ 和读者 $3$ 发送读者 $1$ 与读者 $3$ 的地址。\n  - 读者 $3$ 向读者 $2$ 和读者 $4$ 发送读者 $2$ 与读者 $4$ 的地址。\n  - 读者 $4$ 向读者 $3$ 发送读者 $3$ 的地址。\n- 第 $D$ 天晚上 $8$ 点更新后：\n  - 读者 $1$ 的通讯录完成更新，包含读者 $2$ 和读者 $3$ 的地址。\n  - 读者 $2$ 的通讯录完成更新，包含读者 $1$、读者 $3$ 和读者 $4$ 的地址。\n  - 读者 $3$ 的通讯录完成更新，包含读者 $1$、读者 $2$ 和读者 $4$ 的地址。\n  - 读者 $4$ 的通讯录完成更新，包含读者 $2$ 和读者 $3$ 的地址。\n- 第 $D + 1$ 天早上 $8$ 点：\n  - 读者 $1$ 向读者 $2$ 和读者 $3$ 发送读者 $2$ 与读者 $3$ 的地址。\n  - 读者 $2$ 向读者 $1$、读者 $3$ 和读者 $4$ 发送读者 $1$、读者 $3$ 与读者 $4$ 的地址。\n  - 读者 $3$ 向读者 $1$、读者 $2$ 和读者 $4$ 发送读者 $1$、读者 $2$ 与读者 $4$ 的地址。\n  - 读者 $4$ 向读者 $2$ 和读者 $3$ 发送读者 $2$ 与读者 $3$ 的地址。\n- 第 $D + 1$ 天晚上 $8$ 点更新后：\n  - 读者 $1$ 的通讯录完成更新，包含读者 $2$、读者 $3$ 和读者 $4$ 的地址。\n  - 读者 $2$ 无需更新。\n  - 读者 $3$ 无需更新。\n  - 读者 $4$ 的通讯录完成更新，包含读者 $1$、读者 $2$ 和读者 $3$ 的地址。\n- 第 $D + 2$ 天早上 $8$ 点：\n  - 读者 $1$ 向读者 $2$、读者 $3$ 和读者 $4$ 发送读者 $2$、读者 $3$ 与读者 $4$ 的地址。\n  - 读者 $$4$$ 向读者 $1$、读者 $2$ 和读者 $3$ 发送读者 $1$、读者 $2$ 与读者 $3$ 的地址。\n- 第 $D + 2$ 天晚上 $8$ 点更新后：\n  - 读者 $1$ 无需更新。\n  - 读者 $4$ 无需更新。\n  \n最后一次更新发生在第 $D+1$ 天，共计经过 $2$ 天。流程在全体读者端完成是在第 $D+2$ 天，共计经过 $3$ 天。\n\n样例输出选取的是前者，即 $2$；输出后者 $3$ 也同样正确。", "locale": "zh-CN"}}}
{"pid": "P13866", "type": "P", "difficulty": 7, "samples": [["4 4 2\n0 1 0\n1 2 0\n2 0 0\n1 3 1", "0"], ["3 3 2\n0 1 1\n1 0 1\n1 2 0", "1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "ICPC"], "title": "[SWERC 2020] Daisy's Mazes", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/38af479aa5920e413b45abfa2b8c99c82c3f43fa.png)\n\n:::\n\nDaisy enjoys walking in mazes to evacuate the stress of a long day of work. The\nmazes that she likes are all composed of a set of rooms with one\nentry room, one exit room, and in each room there are several one-way\ndoors leading to other rooms. Daisy's goal is to find a path from the\nentry to the exit.\n\nDaisy has a technique to solve mazes. She has noticed that the\ndifferent doors of any room have different colors and thus she can\nremember her path by keeping track of the colors of doors along her\npath. For that, she looks at the plan before entering the maze and\nbuilds a deck of colored cards corresponding to the colors of doors\nshe needs to take. Whenever she enters a room, she goes through the\ndoor that has the color of the topmost card in her deck and then she\ndiscards this card.\n\nIt sometimes happens that Daisy's decks are \"incomplete\" and she\narrives in a room with an empty deck or with a topmost card that has a\ncolor corresponding to none of the doors. In those cases, Daisy goes\nthrough one of the doors in the room and, instead of discarding the\ntopmost card, she adds on top of her deck a card of the color of the\ndoor she took.\n\nLet us consider the following example maze with three rooms and three\ndoors: a red door from the entry to room 1, a second red door from\nroom 1 back to the entry, and a blue door between room 1 and the\nexit. In this example maze (also depicted below) then:\n- if Daisy starts with a deck containing a *red* card on top and a *blue* card below, she will go to room 1 and discard the red card, then go to the exit and discard the blue card;\n- if Daisy starts with a deck containing a single *red* card\nthen she will necessarily go to room 1 as a first step, discard the\nred card and from there she can choose to take the *blue* door and\nexit (it does not matter whether her deck is empty at the end) or she\ncan choose to take the red door and goes back to her initial situation:\nin the entry room with a single red card;\n-  if she starts or arrives in the entry room with an empty deck,\n       she will necessarily loop indefinitely.\n       Indeed, the entry has only one door that leads to room 1. Once\n       she arrives in room 1, her deck contains a *red* card on top\n       and thus she has to take the *red* door and discard this card,\n       which leads her back to the entry room with an empty deck.\n\n:::align{center}\n\n![](https://espresso.codeforces.com/191dcaa311dc0598a9bf64c99783d97a0bd38f64.png)\n\n:::\n\n\nDaisy knows that, in all of her labyrinths, she can always go from the\nentry room to the exit room with the right deck.  However, some decks\ndo not allow her to escape, whatever the choices she may ever do.\nShe wonders: what is the\nminimal size of a deck that allows her to escape? Daisy gives you the\nplan of the maze and asks you to help her determine the minimal size\nof a deck that allows her go from the entry room to the exit if she\nmakes the right choices.", "inputFormat": "The first line contains three integers $R$, $D$, and $C$,\nseparated by spaces.\n$R$ is the number of rooms, $D$ is the number of doors, and $C$ is the number of colors.\nRooms are numbered from $0$ to $R-1$, and colors\nare numbered from $0$ to $C-1$.\n\nThe next $D$ lines each describes a door with three integers $f$, $t$\nand $c$, separated by spaces, and such that $0\\leq f \\leq R-1$,\n$0 \\leq t \\leq R-1$, $f\\neq t$, and $0\\leq c \\leq C-1$.  This\nindicates that there is a door from room $f$ to room $t$, and that this door has color $c$.\n\n**Limits**\n\n- $2 \\leq R \\leq 50$\n- $2 \\leq D \\leq 100$\n- $2 \\leq C \\leq 20$", "outputFormat": "The output should contain a single line with a single integer: the\nminimal integer $S$ such that there is a deck composed of $S$ cards\nthat allows Daisy, if she makes the right choices, to go from the entry\n(the room numbered $0$) to the exit (the room numbered $R-1$).", "hint": "**Sample Explanation 1**\n\n- Daisy starts in room 0 with an empty deck\n- She goes to room 1 with a card $\\textbf{0}$ on her deck\n- She goes to room 2 with an empty deck\n- She goes to room 0 with a card $\\textbf{0}$ on her deck\n- She goes to room 1 with an empty deck\n- She now has the choice to go the exit.\n\n**Sample Explanation 2**\n\nThis example corresponds to the one given in the text with red represented as 1 and blue as 0.", "locale": "en", "translations": {"en": {"title": "[SWERC 2020] Daisy's Mazes", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/38af479aa5920e413b45abfa2b8c99c82c3f43fa.png)\n\n:::\n\nDaisy enjoys walking in mazes to evacuate the stress of a long day of work. The\nmazes that she likes are all composed of a set of rooms with one\nentry room, one exit room, and in each room there are several one-way\ndoors leading to other rooms. Daisy's goal is to find a path from the\nentry to the exit.\n\nDaisy has a technique to solve mazes. She has noticed that the\ndifferent doors of any room have different colors and thus she can\nremember her path by keeping track of the colors of doors along her\npath. For that, she looks at the plan before entering the maze and\nbuilds a deck of colored cards corresponding to the colors of doors\nshe needs to take. Whenever she enters a room, she goes through the\ndoor that has the color of the topmost card in her deck and then she\ndiscards this card.\n\nIt sometimes happens that Daisy's decks are \"incomplete\" and she\narrives in a room with an empty deck or with a topmost card that has a\ncolor corresponding to none of the doors. In those cases, Daisy goes\nthrough one of the doors in the room and, instead of discarding the\ntopmost card, she adds on top of her deck a card of the color of the\ndoor she took.\n\nLet us consider the following example maze with three rooms and three\ndoors: a red door from the entry to room 1, a second red door from\nroom 1 back to the entry, and a blue door between room 1 and the\nexit. In this example maze (also depicted below) then:\n- if Daisy starts with a deck containing a *red* card on top and a *blue* card below, she will go to room 1 and discard the red card, then go to the exit and discard the blue card;\n- if Daisy starts with a deck containing a single *red* card\nthen she will necessarily go to room 1 as a first step, discard the\nred card and from there she can choose to take the *blue* door and\nexit (it does not matter whether her deck is empty at the end) or she\ncan choose to take the red door and goes back to her initial situation:\nin the entry room with a single red card;\n-  if she starts or arrives in the entry room with an empty deck,\n       she will necessarily loop indefinitely.\n       Indeed, the entry has only one door that leads to room 1. Once\n       she arrives in room 1, her deck contains a *red* card on top\n       and thus she has to take the *red* door and discard this card,\n       which leads her back to the entry room with an empty deck.\n\n:::align{center}\n\n![](https://espresso.codeforces.com/191dcaa311dc0598a9bf64c99783d97a0bd38f64.png)\n\n:::\n\n\nDaisy knows that, in all of her labyrinths, she can always go from the\nentry room to the exit room with the right deck.  However, some decks\ndo not allow her to escape, whatever the choices she may ever do.\nShe wonders: what is the\nminimal size of a deck that allows her to escape? Daisy gives you the\nplan of the maze and asks you to help her determine the minimal size\nof a deck that allows her go from the entry room to the exit if she\nmakes the right choices.", "inputFormat": "The first line contains three integers $R$, $D$, and $C$,\nseparated by spaces.\n$R$ is the number of rooms, $D$ is the number of doors, and $C$ is the number of colors.\nRooms are numbered from $0$ to $R-1$, and colors\nare numbered from $0$ to $C-1$.\n\nThe next $D$ lines each describes a door with three integers $f$, $t$\nand $c$, separated by spaces, and such that $0\\leq f \\leq R-1$,\n$0 \\leq t \\leq R-1$, $f\\neq t$, and $0\\leq c \\leq C-1$.  This\nindicates that there is a door from room $f$ to room $t$, and that this door has color $c$.\n\n**Limits**\n\n- $2 \\leq R \\leq 50$\n- $2 \\leq D \\leq 100$\n- $2 \\leq C \\leq 20$", "outputFormat": "The output should contain a single line with a single integer: the\nminimal integer $S$ such that there is a deck composed of $S$ cards\nthat allows Daisy, if she makes the right choices, to go from the entry\n(the room numbered $0$) to the exit (the room numbered $R-1$).", "hint": "**Sample Explanation 1**\n\n- Daisy starts in room 0 with an empty deck\n- She goes to room 1 with a card $\\textbf{0}$ on her deck\n- She goes to room 2 with an empty deck\n- She goes to room 0 with a card $\\textbf{0}$ on her deck\n- She goes to room 1 with an empty deck\n- She now has the choice to go the exit.\n\n**Sample Explanation 2**\n\nThis example corresponds to the one given in the text with red represented as 1 and blue as 0.", "locale": "en"}}}
{"pid": "P13867", "type": "P", "difficulty": 3, "samples": [["AABAABB", "BA"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "二分", "ICPC", "哈希表"], "title": "[SWERC 2020] Unique Activities", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/1ed0c281b1e7fd92ebf40281db92d3ecb9903761.png)\n\n:::\n\nEmily is tired of having studied at home throughout 2020. She has noticed the same\ntasks occur over and over: she has to cook and wash the dishes. Then it's time for her class;\nafterwards she resumes washing the dishes, has to attend another class, washes some more dishes\nbefore cooking and washing the dishes for the last time of the day.\n\nThere is a part of her day she loves, though: it's when the sequence of activities\nshe is currently carrying out happens only once during her day. She rejoices\nthe most when that activity sequence is unique and really short.\n\nEach activity is represented by an uppercase letter. Given the list of\nactivities Emily has to carry out today, help Emily find the\nbest moment of her day by finding the shortest \nsubstring that only occurs once in the input.\n\nIf Cooking is C, Dishes is D, and Studying is S, the list of\nactivities in the example above are C D S D S D C D, and the shortest\nsubstring that occurs only once is D C. (All the one-letter substrings\nand the other two-letter substrings occur at least twice).\n\n\n", "inputFormat": "The input consists of a single line, with a sequence of $N$ uppercase letters (from `A` to `Z`).\nThe line is terminated by a newline character which is not considered to be part of the input\nstring.\n\n**Limits**\n\n- $0< N\\leq 300\\,000$", "outputFormat": "The output should contain a single line with the shortest substring that happens only\nonce in the input string. If there are multiple shortest substrings (with the same length),\noutput the one that occurs first.", "hint": "", "locale": "en", "translations": {"en": {"title": "[SWERC 2020] Unique Activities", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/1ed0c281b1e7fd92ebf40281db92d3ecb9903761.png)\n\n:::\n\nEmily is tired of having studied at home throughout 2020. She has noticed the same\ntasks occur over and over: she has to cook and wash the dishes. Then it's time for her class;\nafterwards she resumes washing the dishes, has to attend another class, washes some more dishes\nbefore cooking and washing the dishes for the last time of the day.\n\nThere is a part of her day she loves, though: it's when the sequence of activities\nshe is currently carrying out happens only once during her day. She rejoices\nthe most when that activity sequence is unique and really short.\n\nEach activity is represented by an uppercase letter. Given the list of\nactivities Emily has to carry out today, help Emily find the\nbest moment of her day by finding the shortest \nsubstring that only occurs once in the input.\n\nIf Cooking is C, Dishes is D, and Studying is S, the list of\nactivities in the example above are C D S D S D C D, and the shortest\nsubstring that occurs only once is D C. (All the one-letter substrings\nand the other two-letter substrings occur at least twice).\n\n\n", "inputFormat": "The input consists of a single line, with a sequence of $N$ uppercase letters (from `A` to `Z`).\nThe line is terminated by a newline character which is not considered to be part of the input\nstring.\n\n**Limits**\n\n- $0< N\\leq 300\\,000$", "outputFormat": "The output should contain a single line with the shortest substring that happens only\nonce in the input string. If there are multiple shortest substrings (with the same length),\noutput the one that occurs first.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[SWERC 2020] Unique Activities", "background": null, "description": ":::align{center}\n\n![](https://espresso.codeforces.com/1ed0c281b1e7fd92ebf40281db92d3ecb9903761.png)\n\n:::\n\nEmily 对 2020 年全年在家学习感到厌倦。她发现日常任务总是重复出现：做饭和洗碗。接着是上课时间；之后她又继续洗碗，然后参加另一节课，再洗一些碗，最后做饭并完成当天的最后一次洗碗。\n\n不过，她一天中也有特别喜欢的时刻：即当她当前进行的一系列活动在全天只出现一次时。如果这个活动序列既唯一又非常短，她就会格外高兴。\n\n每个活动用一个大写字母表示。给定 Emily 今天需要完成的活动列表，请通过找出输入字符串中只出现一次的最短子串，来帮助 Emily 找到她一天中最喜欢的时刻。\n\n记做饭为 `C`，记洗碗为 `D`，记学习为 `S` ，则上述情景中的活动序列为 `CDSDSDCD`，其中只出现一次的最短子串是 `DC`。（所有单字母子串以及其他双字母子串都至少出现两次）。", "inputFormat": "一行输入，包含一个由 $N$ 个大写字母（从 `A` 到 `Z`）组成的序列。该行以换行符结束，换行符不视为输入字符串的一部分。", "outputFormat": "输出一行，即输入字符串中只出现一次的最短子串。如果存在多个长度相同的最短子串，输出最先出现的那一个。", "hint": "- 对于 $ 100\\% $ 的数据，满足 $0< N\\leq 300\\,000$", "locale": "zh-CN"}}}
{"pid": "P13868", "type": "P", "difficulty": 5, "samples": [["4 4\n2\n2\n2\n1\n2\n2 3\n2 1 3\n1 2 4 3\n3 4\n3 2 4 1\n3 4 2\n4", "2\n3\n4"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "队列", "ICPC"], "title": "[SWERC 2020] Restaurants", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/02ace2147abf50b49e102aeaff720257b2a4fb52.png)\n\n:::\n\n\nEverybody is very happy to go back outside and to restaurants in Paris.\nHowever, for a while yet the restaurants have a very limited number of seats.\nWe want to ensure that both restaurants can receive as many people as\npossible, and that customers go in their preferred seats.\n\nWe have $N$ customers, numbered from $1$ to $N$, and $M$ restaurants, numbered\nfrom $1$ to $M$. \n\nEach customer makes reservation in a subset of the restaurants, and\ngive their list of reservations ordered by preference.  Each\nrestaurant ranks the reservations it received by some order of\npreference -- for instance, the restaurant might wish customers who\nhave signed up first to be ranked higher. Each restaurant $i$ also has\na capacity $c_i$, i.e. the maximal number of customers it can support.\n\nYour task is to find an allocation of *some* of the customers in restaurants\nsuch that the following conditions are fulfilled:\n1. No restaurant places more customers than their capacity.\n2. Each customer is given a table in at most one restaurant.\n3. There is no restaurant $r$ and customer $c$ having made a reservation for $r$, such that:\n    - $c$ has not been given a table or prefers $r$ to the restaurant he was given a table in, and \n    - $r$ has some seats left or $r$ is full but prefers $c$ to at least one of the customers assigned to it.\n\nOther remarks to note:\n- Every customer has made at least one reservation.\n- Restaurants only rank the customers having expressed a reservation for\n    them. It is possible that a restaurant has no customers wishing to make a\n    reservation.", "inputFormat": "The first line contains $N$ and $M$.\n\nThe $M$ following lines describe capacities with the $i$-th line\ncontaining an integer $c_i$, the capacity of restaurant $i$.\n\n$N$ lines follow. The $i$-th line describes the list of reservations\nfor customer $i$, sorted by preferences: the line contains a list of\ndistinct space-separated integers (between 1 and $M$), from most to\nleast preferred.\n\n$M$ lines follow. The $i$-th line describes the sorted preferences of\nrestaurant $i$. This line contains either the number 0 when no\ncustomer made a reservation to restaurant $i$ or it contains a list of\nspace-separated distinct integers, the list of customers who made a\nreservation to restaurant $i$ ordered from most to least preferred by\nthe restaurant.\n\n**Limits**\n\n- $1\\leq N \\leq 50\\,000$\n- $1\\leq M \\leq 10\\,000$\n- total number of reservation options is at most $1\\,000\\,000$.\n- $1\\leq c_i \\leq N$\n", "outputFormat": "The output described the set of customers which have a table in one\npossible allocation (according to the rules above). The set is given\nwith one customer per line, sorted ascending by id.", "hint": "", "locale": "en", "translations": {"en": {"title": "[SWERC 2020] Restaurants", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/02ace2147abf50b49e102aeaff720257b2a4fb52.png)\n\n:::\n\n\nEverybody is very happy to go back outside and to restaurants in Paris.\nHowever, for a while yet the restaurants have a very limited number of seats.\nWe want to ensure that both restaurants can receive as many people as\npossible, and that customers go in their preferred seats.\n\nWe have $N$ customers, numbered from $1$ to $N$, and $M$ restaurants, numbered\nfrom $1$ to $M$. \n\nEach customer makes reservation in a subset of the restaurants, and\ngive their list of reservations ordered by preference.  Each\nrestaurant ranks the reservations it received by some order of\npreference -- for instance, the restaurant might wish customers who\nhave signed up first to be ranked higher. Each restaurant $i$ also has\na capacity $c_i$, i.e. the maximal number of customers it can support.\n\nYour task is to find an allocation of *some* of the customers in restaurants\nsuch that the following conditions are fulfilled:\n1. No restaurant places more customers than their capacity.\n2. Each customer is given a table in at most one restaurant.\n3. There is no restaurant $r$ and customer $c$ having made a reservation for $r$, such that:\n    - $c$ has not been given a table or prefers $r$ to the restaurant he was given a table in, and \n    - $r$ has some seats left or $r$ is full but prefers $c$ to at least one of the customers assigned to it.\n\nOther remarks to note:\n- Every customer has made at least one reservation.\n- Restaurants only rank the customers having expressed a reservation for\n    them. It is possible that a restaurant has no customers wishing to make a\n    reservation.", "inputFormat": "The first line contains $N$ and $M$.\n\nThe $M$ following lines describe capacities with the $i$-th line\ncontaining an integer $c_i$, the capacity of restaurant $i$.\n\n$N$ lines follow. The $i$-th line describes the list of reservations\nfor customer $i$, sorted by preferences: the line contains a list of\ndistinct space-separated integers (between 1 and $M$), from most to\nleast preferred.\n\n$M$ lines follow. The $i$-th line describes the sorted preferences of\nrestaurant $i$. This line contains either the number 0 when no\ncustomer made a reservation to restaurant $i$ or it contains a list of\nspace-separated distinct integers, the list of customers who made a\nreservation to restaurant $i$ ordered from most to least preferred by\nthe restaurant.\n\n**Limits**\n\n- $1\\leq N \\leq 50\\,000$\n- $1\\leq M \\leq 10\\,000$\n- total number of reservation options is at most $1\\,000\\,000$.\n- $1\\leq c_i \\leq N$\n", "outputFormat": "The output described the set of customers which have a table in one\npossible allocation (according to the rules above). The set is given\nwith one customer per line, sorted ascending by id.", "hint": "", "locale": "en"}}}
{"pid": "P13869", "type": "P", "difficulty": 6, "samples": [["4 3\n....\n.#..\n....\n....\n..#.\n....", "2 1\n1 1"], ["9 12\n.........\n...###...\n...#.#...\n.#######.\n...###...\n...###...\n.#..#....\n.#######.\n...###.#.\n...###...\n..##.##..\n.........\n.........\n..#####..\n..##.##..\n..#...#..\n..#.#.#..\n..#...#..\n..#####..\n...#.#...\n...#.#...\n...#.#...\n.###.###.\n.........", "IMPOSSIBLE"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "Special Judge", "构造", "ICPC"], "title": "[SWERC 2020] Fantasmagorie", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/3567d1b7371c8063e2b0c4b0dab3805a6e6d6434.png)\n\n:::\n\nÉmile's dreams often feature people or animals who become distorted\ninto others. Émile would like to show the enchanting world of his\ndreams to everybody by creating the very first animated cartoon, in\nblack and white of course. After waking up, Émile only remembers the\ninitial and final forms appearing in his dream, not the transformation\nitself, so he's asking you to reproduce these \"morphings\" by detailing the steps taken for transforming the first image into the second.\n\nThe images in Émile's dreams are not just any black and white image,\nthey respect the following three constraints.\nFirst, all pixels on the border of the image -- the leftmost and righmost columns, and the top and the bottom rows -- have the same color.\nSecond, the image does not contain any $2 \\times 2$ square of the form\n\n:::align{center}\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/srpxgqzf.png)\n\nor\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vw64a8m8.png)\n\n.\n\n:::\n\nThe third constraint is more complex, and can be described as follows.\nLet us subdivide the image into *regions*,\nwhich are defined as\nthe connected monochromatic areas of the image,\ni.e., they form the finest partition of the pixels such that\nany two adjacent pixels of the same color are in the same\nregion. Two regions are considered adjacent if they contain\nadjacent pixels. In Émile's images, every region is adjacent\nto at most two other regions, and the region containing border pixels is\nadjacent to at most one other region.\n\nYou are given two black and white images of the same size $W \\times H$,\nand your goal is to find a \"morphing\" transforming the first image\ninto the second one. A morphing from image $A$ to image $B$ is a\nsequence of images starting with $A$ and ending with $B$ such that:\n- each image (except the first) can be obtained from the previous one by flipping one bit;\n- each image respects the three above constraints;\n- the number of regions of each color does not change during the morphing.", "inputFormat": "The first line of the input contains two space-separated integers:\n$W$ and $H$. Then come $H$ lines that describe the first image row by row,\nfrom top to bottom. Each of these lines is composed of $W$ characters\ndescribing the row's $W$ pixels, from left to right: the $k$-th character\nof the line is $\\texttt{`.'}$ if the $k$-th pixel of the row is white, and\nit is $\\texttt{`\\#'}$ if that pixel is black.\nFinally come $H$ lines that describe the second image row by row, following\nthe same format as above.", "outputFormat": "If no morphing exists, the output should contain the\nword $\\texttt{\"IMPOSSIBLE\"}$ on a single line.  Otherwise, the output\nshould describe one possible morphing as follows:\nif the $(k+1)$-th image is obtained from the $k$-th image by flipping the\npixel in column $c$ and row $r$ (with $0 \\le c < W$ and $0 \\le r < H$, where $c = 0$ represents the leftmost column and $r = 0$ represents the\ntopmost row), the $k$-th output line contains the pair $(c,r)$.\n\n**Limits and Remarks**\n\n- $1 \\le H \\le 64$\n- $1 \\le W \\le 103$\n- Émile's first and last images are distinct from each other.\n- The output should contain at most $250\\,000$ pixel flips.", "hint": "", "locale": "en", "translations": {"en": {"title": "[SWERC 2020] Fantasmagorie", "background": "", "description": ":::align{center}\n\n![](https://espresso.codeforces.com/3567d1b7371c8063e2b0c4b0dab3805a6e6d6434.png)\n\n:::\n\nÉmile's dreams often feature people or animals who become distorted\ninto others. Émile would like to show the enchanting world of his\ndreams to everybody by creating the very first animated cartoon, in\nblack and white of course. After waking up, Émile only remembers the\ninitial and final forms appearing in his dream, not the transformation\nitself, so he's asking you to reproduce these \"morphings\" by detailing the steps taken for transforming the first image into the second.\n\nThe images in Émile's dreams are not just any black and white image,\nthey respect the following three constraints.\nFirst, all pixels on the border of the image -- the leftmost and righmost columns, and the top and the bottom rows -- have the same color.\nSecond, the image does not contain any $2 \\times 2$ square of the form\n\n:::align{center}\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/srpxgqzf.png)\n\nor\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vw64a8m8.png)\n\n.\n\n:::\n\nThe third constraint is more complex, and can be described as follows.\nLet us subdivide the image into *regions*,\nwhich are defined as\nthe connected monochromatic areas of the image,\ni.e., they form the finest partition of the pixels such that\nany two adjacent pixels of the same color are in the same\nregion. Two regions are considered adjacent if they contain\nadjacent pixels. In Émile's images, every region is adjacent\nto at most two other regions, and the region containing border pixels is\nadjacent to at most one other region.\n\nYou are given two black and white images of the same size $W \\times H$,\nand your goal is to find a \"morphing\" transforming the first image\ninto the second one. A morphing from image $A$ to image $B$ is a\nsequence of images starting with $A$ and ending with $B$ such that:\n- each image (except the first) can be obtained from the previous one by flipping one bit;\n- each image respects the three above constraints;\n- the number of regions of each color does not change during the morphing.", "inputFormat": "The first line of the input contains two space-separated integers:\n$W$ and $H$. Then come $H$ lines that describe the first image row by row,\nfrom top to bottom. Each of these lines is composed of $W$ characters\ndescribing the row's $W$ pixels, from left to right: the $k$-th character\nof the line is $\\texttt{`.'}$ if the $k$-th pixel of the row is white, and\nit is $\\texttt{`\\#'}$ if that pixel is black.\nFinally come $H$ lines that describe the second image row by row, following\nthe same format as above.", "outputFormat": "If no morphing exists, the output should contain the\nword $\\texttt{\"IMPOSSIBLE\"}$ on a single line.  Otherwise, the output\nshould describe one possible morphing as follows:\nif the $(k+1)$-th image is obtained from the $k$-th image by flipping the\npixel in column $c$ and row $r$ (with $0 \\le c < W$ and $0 \\le r < H$, where $c = 0$ represents the leftmost column and $r = 0$ represents the\ntopmost row), the $k$-th output line contains the pair $(c,r)$.\n\n**Limits and Remarks**\n\n- $1 \\le H \\le 64$\n- $1 \\le W \\le 103$\n- Émile's first and last images are distinct from each other.\n- The output should contain at most $250\\,000$ pixel flips.", "hint": "", "locale": "en"}}}
{"pid": "P13870", "type": "P", "difficulty": 2, "samples": [["", ""]], "limits": {"time": [3000], "memory": [524288]}, "tags": ["数学", "2024", "蓝桥杯省赛"], "title": "[蓝桥杯 2024 省 Java/Python A] 召唤数学精灵", "background": "", "description": "数学家们发现了两种用于召唤强大的数学精灵的仪式，这两种仪式分别被称为累加法仪式 $A(n)$ 和累乘法仪式 $B(n)$。\n\n累加法仪式 $A(n)$ 是将从 $1$ 到 $n$ 的所有数字进行累加求和，即：$A(n) = 1 + 2 + \\cdots + n$。\n\n累乘法仪式 $B(n)$ 则是将从 $1$ 到 $n$ 的所有数字进行累乘求积，即：$B(n) = 1 \\times 2 \\times \\cdots \\times n$。\n\n据说，当某个数字 $i$ 满足 $A(i) - B(i)$ 能被 $100$ 整除时，数学精灵就会被召唤出来。\n\n现在，请你寻找在 $1$ 到 $2024041331404202$ 之间有多少个数字 $i$，能够成功召唤出强大的数学精灵。", "inputFormat": "", "outputFormat": "这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只输出这个整数，填写多余的内容将无法得分。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 省 Java/Python A] 召唤数学精灵", "background": "", "description": "数学家们发现了两种用于召唤强大的数学精灵的仪式，这两种仪式分别被称为累加法仪式 $A(n)$ 和累乘法仪式 $B(n)$。\n\n累加法仪式 $A(n)$ 是将从 $1$ 到 $n$ 的所有数字进行累加求和，即：$A(n) = 1 + 2 + \\cdots + n$。\n\n累乘法仪式 $B(n)$ 则是将从 $1$ 到 $n$ 的所有数字进行累乘求积，即：$B(n) = 1 \\times 2 \\times \\cdots \\times n$。\n\n据说，当某个数字 $i$ 满足 $A(i) - B(i)$ 能被 $100$ 整除时，数学精灵就会被召唤出来。\n\n现在，请你寻找在 $1$ 到 $2024041331404202$ 之间有多少个数字 $i$，能够成功召唤出强大的数学精灵。", "inputFormat": "", "outputFormat": "这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只输出这个整数，填写多余的内容将无法得分。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P13871", "type": "P", "difficulty": 4, "samples": [["4 4\naabb\nabba\nacca\nabcd", "8"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2024", "生成树", "KMP 算法", "蓝桥杯省赛", "线性 DP"], "title": "[蓝桥杯 2024 省 Java/Python A] 吊坠", "background": "", "description": "小蓝想制作一个吊坠，他手上有 $n$ 个长度为 $m$ 的首尾相连的环形字符串 $\\{s_1, s_2, \\cdots, s_n\\}$，他想用 $n-1$ 条边将这 $n$ 个字符串连接起来做成吊坠，要求所有的字符串连完后形成一个整体。连接两个字符串 $s_i, s_j$ 的边的边权为这两个字符串的最长公共子串的长度（可以按环形旋转改变起始位置，但不能翻转），小蓝希望连完后的这 $n-1$ 条边的边权和最大，这样的吊坠他觉得最好看，请计算最大的边权和是多少。", "inputFormat": "输入的第一行包含两个正整数 $n, m$，用一个空格分隔。\n\n接下来 $n$ 行，每行包含一个长度为 $m$ 的字符串，分别表示 $s_1, s_2, \\cdots, s_n$。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "**【样例说明】**\n\n连接 $\\langle 1,2\\rangle, \\langle 2,3\\rangle, \\langle 2,4\\rangle$，边权和为 $4 + 2 + 2 = 8$\n\n**【评测用例规模与约定】**\n\n对于 $20\\%$ 的评测用例，$1 \\leq n, m \\leq 10$；\n\n对于所有评测用例，$1 \\leq n \\leq 200$，$1 \\leq m \\leq 50$。所有字符串由小写英文字母组成。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 省 Java/Python A] 吊坠", "background": "", "description": "小蓝想制作一个吊坠，他手上有 $n$ 个长度为 $m$ 的首尾相连的环形字符串 $\\{s_1, s_2, \\cdots, s_n\\}$，他想用 $n-1$ 条边将这 $n$ 个字符串连接起来做成吊坠，要求所有的字符串连完后形成一个整体。连接两个字符串 $s_i, s_j$ 的边的边权为这两个字符串的最长公共子串的长度（可以按环形旋转改变起始位置，但不能翻转），小蓝希望连完后的这 $n-1$ 条边的边权和最大，这样的吊坠他觉得最好看，请计算最大的边权和是多少。", "inputFormat": "输入的第一行包含两个正整数 $n, m$，用一个空格分隔。\n\n接下来 $n$ 行，每行包含一个长度为 $m$ 的字符串，分别表示 $s_1, s_2, \\cdots, s_n$。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "**【样例说明】**\n\n连接 $\\langle 1,2\\rangle, \\langle 2,3\\rangle, \\langle 2,4\\rangle$，边权和为 $4 + 2 + 2 = 8$\n\n**【评测用例规模与约定】**\n\n对于 $20\\%$ 的评测用例，$1 \\leq n, m \\leq 10$；\n\n对于所有评测用例，$1 \\leq n \\leq 200$，$1 \\leq m \\leq 50$。所有字符串由小写英文字母组成。", "locale": "zh-CN"}}}
{"pid": "P13872", "type": "P", "difficulty": 4, "samples": [["3\n1\n2\n6", "0\n1\n1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "博弈论", "2024", "数论", "素数判断,质数,筛法", "蓝桥杯省赛"], "title": "[蓝桥杯 2024 省 Java/Python A] 砍柴", "background": "", "description": "小蓝和小乔正在森林里砍柴，它们有 $T$ 根长度分别为 $n_1, n_2, \\cdots, n_T$ 的木头。对于每个初始长度为 $n$ 的木头，小蓝和小乔准备进行交替砍柴，小蓝先出手。每次砍柴时，若当前木头长度为 $x$，需要砍下一截长度为 $p$ 的木头，然后换另一个人继续砍，其中 $2 \\leq p \\leq x$ 且 $p$ 必须为质数。当轮到某一方时 $x=1$ 或 $x=0$，它就没法继续砍柴，它就输了。它们会使用最优策略进行砍柴。请对每根木头判断是小蓝赢还是小乔赢，如果小蓝赢请输出 1（数字 1），如果小乔赢请输出 0（数字 0）。\n", "inputFormat": "输入的第一行包含一个正整数 $T$，\n\n接下来 $T$ 行，每行包含一个正整数，其中第 $i$ 的整数为 $n_i$。", "outputFormat": "输出 $T$ 行，每行包含一个整数，依次表示对于每一根木头的答案。", "hint": "**【样例说明】**\n\n对于 $n_1 = 1$，由于当前长度 $x = 1$，小蓝直接输掉，小乔赢；\n\n对于 $n_2 = 2$，小蓝选择 $p = 2$，轮到小乔时当前长度 $x = 2 - 2 = 0$，小乔输掉，小蓝赢；\n\n对于 $n_3 = 6$，小蓝选择 $p = 5$，轮到小乔时 $x = 6 - 5 = 1$，小乔输掉，小蓝赢。\n\n**【评测用例规模与约定】**\n\n对于 $20\\%$ 的评测用例，$1 \\leq n_i \\leq 10^3$；\n\n对于所有评测用例，$1 \\leq n_i \\leq 10^5$，$1 \\leq T \\leq 10^4$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 省 Java/Python A] 砍柴", "background": "", "description": "小蓝和小乔正在森林里砍柴，它们有 $T$ 根长度分别为 $n_1, n_2, \\cdots, n_T$ 的木头。对于每个初始长度为 $n$ 的木头，小蓝和小乔准备进行交替砍柴，小蓝先出手。每次砍柴时，若当前木头长度为 $x$，需要砍下一截长度为 $p$ 的木头，然后换另一个人继续砍，其中 $2 \\leq p \\leq x$ 且 $p$ 必须为质数。当轮到某一方时 $x=1$ 或 $x=0$，它就没法继续砍柴，它就输了。它们会使用最优策略进行砍柴。请对每根木头判断是小蓝赢还是小乔赢，如果小蓝赢请输出 1（数字 1），如果小乔赢请输出 0（数字 0）。\n", "inputFormat": "输入的第一行包含一个正整数 $T$，\n\n接下来 $T$ 行，每行包含一个正整数，其中第 $i$ 的整数为 $n_i$。", "outputFormat": "输出 $T$ 行，每行包含一个整数，依次表示对于每一根木头的答案。", "hint": "**【样例说明】**\n\n对于 $n_1 = 1$，由于当前长度 $x = 1$，小蓝直接输掉，小乔赢；\n\n对于 $n_2 = 2$，小蓝选择 $p = 2$，轮到小乔时当前长度 $x = 2 - 2 = 0$，小乔输掉，小蓝赢；\n\n对于 $n_3 = 6$，小蓝选择 $p = 5$，轮到小乔时 $x = 6 - 5 = 1$，小乔输掉，小蓝赢。\n\n**【评测用例规模与约定】**\n\n对于 $20\\%$ 的评测用例，$1 \\leq n_i \\leq 10^3$；\n\n对于所有评测用例，$1 \\leq n_i \\leq 10^5$，$1 \\leq T \\leq 10^4$。\n", "locale": "zh-CN"}}}
{"pid": "P13873", "type": "P", "difficulty": 5, "samples": [["4 4 2\n4 2 3 1\n2 1 2 1\n4 4 1 1 \n2 2 2 4", "4\n0"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "离散化", "组合数学", "蓝桥杯省赛"], "title": "[蓝桥杯 2024 省 Java/Python A] 智力测试", "background": "", "description": "小蓝考上了世界上最好的魔法师学校，然而入学第一件事就是智力测试，老师给出了一个 $n \\times m$ 大小的棋盘，同时对每行每列设置了权重 $\\{R_1, R_2, \\cdots, R_n\\}$ 和 $\\{C_1, C_2, \\cdots, C_m\\}$，因此，对于第 $r$ 行第 $c$ 列的格子 $(r, c)$，其权重为一个二元组 $(R_r, C_c)$。\n\n小蓝可以在格子之间进行移动，若某时刻小蓝在格子 $(r, c)$，那么他可以一步走到任意的格子 $(r', c)$ 或 $(r, c')$，其中 $r', c'$ 满足：\n\n（1）$R_{r'} > R_r, C_{c'} > C_c$，\n\n（2）$\\nexists r''. R_{r'} > R_{r''} > R_r; \\nexists c''. C_{c'} > C_{c''} > C_r$。\n\n之后，老师提出了 $T$ 个问题，第 $i$ 个问题为：假设小蓝从格子 $(s_r^i, s_c^i)$ 出发，移动到格子 $(t_r^i, t_c^i)$ 有多少种不同的走法，答案对 $1000000007$ 取模。\n", "inputFormat": "输入的第一行包含三个正整数 $n, m, T$，相邻整数之间使用一个空格分隔。\n\n第二行包含 $n$ 个正整数 $R_1, R_2, \\cdots, R_n$，相邻整数之间使用一个空格分隔。\n\n第三行包含 $m$ 个正整数 $C_1, C_2, \\cdots, C_m$，相邻整数之间使用一个空格分隔。\n\n接下来 $T$ 行，第 $i$ 行包含四个正整数 $s_r^i, s_c^i, t_r^i, t_c^i$，相邻整数之间使用一个空格分隔。\n", "outputFormat": "输出 $T$ 行，每行包含一个整数，依次表示每个问题的答案。", "hint": "**【样例说明】**\n\n询问 1：\n\n- $(4, 4) \\rightarrow (2, 4) \\rightarrow (3, 4) \\rightarrow (1, 4) \\rightarrow (1, 1)$;\n- $(4, 4) \\rightarrow (2, 4) \\rightarrow (3, 4) \\rightarrow (3, 1) \\rightarrow (1, 1)$;\n- $(4, 4) \\rightarrow (2, 4) \\rightarrow (2, 1) \\rightarrow (3, 1) \\rightarrow (1, 1)$;\n- $(4, 4) \\rightarrow (4, 1) \\rightarrow (2, 1) \\rightarrow (3, 1) \\rightarrow (1, 1)$。\n\n询问 2：\n\n- 不存在方案可以从 $(2, 2)$ 走到 $(2, 4)$。\n\n**【评测用例规模与约定】**\n\n对于 $20\\%$ 的评测用例，$1 \\leq n, m, T \\leq 10^3$；\n\n对于所有评测用例，$1 \\leq n, m, T \\leq 10^5$，$1 \\leq R_i, C_i \\leq 10^8$，$1 \\leq s_r^i, t_r^i \\leq n$，$1 \\leq s_c^i, t_c^i \\leq m$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 省 Java/Python A] 智力测试", "background": "", "description": "小蓝考上了世界上最好的魔法师学校，然而入学第一件事就是智力测试，老师给出了一个 $n \\times m$ 大小的棋盘，同时对每行每列设置了权重 $\\{R_1, R_2, \\cdots, R_n\\}$ 和 $\\{C_1, C_2, \\cdots, C_m\\}$，因此，对于第 $r$ 行第 $c$ 列的格子 $(r, c)$，其权重为一个二元组 $(R_r, C_c)$。\n\n小蓝可以在格子之间进行移动，若某时刻小蓝在格子 $(r, c)$，那么他可以一步走到任意的格子 $(r', c)$ 或 $(r, c')$，其中 $r', c'$ 满足：\n\n（1）$R_{r'} > R_r, C_{c'} > C_c$，\n\n（2）$\\nexists r''. R_{r'} > R_{r''} > R_r; \\nexists c''. C_{c'} > C_{c''} > C_r$。\n\n之后，老师提出了 $T$ 个问题，第 $i$ 个问题为：假设小蓝从格子 $(s_r^i, s_c^i)$ 出发，移动到格子 $(t_r^i, t_c^i)$ 有多少种不同的走法，答案对 $1000000007$ 取模。\n", "inputFormat": "输入的第一行包含三个正整数 $n, m, T$，相邻整数之间使用一个空格分隔。\n\n第二行包含 $n$ 个正整数 $R_1, R_2, \\cdots, R_n$，相邻整数之间使用一个空格分隔。\n\n第三行包含 $m$ 个正整数 $C_1, C_2, \\cdots, C_m$，相邻整数之间使用一个空格分隔。\n\n接下来 $T$ 行，第 $i$ 行包含四个正整数 $s_r^i, s_c^i, t_r^i, t_c^i$，相邻整数之间使用一个空格分隔。\n", "outputFormat": "输出 $T$ 行，每行包含一个整数，依次表示每个问题的答案。", "hint": "**【样例说明】**\n\n询问 1：\n\n- $(4, 4) \\rightarrow (2, 4) \\rightarrow (3, 4) \\rightarrow (1, 4) \\rightarrow (1, 1)$;\n- $(4, 4) \\rightarrow (2, 4) \\rightarrow (3, 4) \\rightarrow (3, 1) \\rightarrow (1, 1)$;\n- $(4, 4) \\rightarrow (2, 4) \\rightarrow (2, 1) \\rightarrow (3, 1) \\rightarrow (1, 1)$;\n- $(4, 4) \\rightarrow (4, 1) \\rightarrow (2, 1) \\rightarrow (3, 1) \\rightarrow (1, 1)$。\n\n询问 2：\n\n- 不存在方案可以从 $(2, 2)$ 走到 $(2, 4)$。\n\n**【评测用例规模与约定】**\n\n对于 $20\\%$ 的评测用例，$1 \\leq n, m, T \\leq 10^3$；\n\n对于所有评测用例，$1 \\leq n, m, T \\leq 10^5$，$1 \\leq R_i, C_i \\leq 10^8$，$1 \\leq s_r^i, t_r^i \\leq n$，$1 \\leq s_c^i, t_c^i \\leq m$。\n", "locale": "zh-CN"}}}
{"pid": "P13874", "type": "P", "difficulty": 5, "samples": [["5\n1 0 5 3 4\n-1 0 1 0 1", "7"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "字典树 Trie", "蓝桥杯省赛"], "title": "[蓝桥杯 2024 省 Java/Python A] 最大异或结点", "background": null, "description": "小蓝有一棵树，树中包含 $N$ 个结点，编号为 $0, 1, 2, \\cdots, N-1$，其中每个结点上都有一个整数 $X_i$。他可以从树中任意选择两个不直接相连的结点 $a$、$b$ 并获得分数 $X_a \\oplus X_b$，其中 $\\oplus$ 表示按位异或操作。\n\n请问小蓝可以获得的最大分数是多少？", "inputFormat": "输入的第一行包含一个整数 $N$，表示有 $N$ 个结点。\n\n第二行包含 $N$ 个整数 $X_0, X_1, \\cdots, X_{N-1}$，相邻整数之间使用一个空格分隔。\n\n第三行包含 $N$ 个整数 $F_0, F_1, \\cdots, F_{N-1}$，相邻整数之间使用一个空格分隔，其中第 $i$ 个整数表示 $i$ 的父结点编号，$F_i = -1$ 表示结点 $i$ 没有父结点。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "**【样例说明】**\n\n选择编号为 3 和 4 的结点，$x_3 = 3$，$x_4 = 4$，他们的值异或后的结果为 $3 \\oplus 4 = 7$。\n\n**【评测用例规模与约定】**\n\n对于 $50\\%$ 的评测用例，$1 \\leq N \\leq 1000$；\n\n对于所有评测用例，$1 \\leq N \\leq 10^5$，$0 \\leq X_i \\leq 2^{31} - 1$，$-1 \\leq F_i \\leq N$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 省 Java/Python A] 最大异或结点", "background": null, "description": "小蓝有一棵树，树中包含 $N$ 个结点，编号为 $0, 1, 2, \\cdots, N-1$，其中每个结点上都有一个整数 $X_i$。他可以从树中任意选择两个不直接相连的结点 $a$、$b$ 并获得分数 $X_a \\oplus X_b$，其中 $\\oplus$ 表示按位异或操作。\n\n请问小蓝可以获得的最大分数是多少？", "inputFormat": "输入的第一行包含一个整数 $N$，表示有 $N$ 个结点。\n\n第二行包含 $N$ 个整数 $X_0, X_1, \\cdots, X_{N-1}$，相邻整数之间使用一个空格分隔。\n\n第三行包含 $N$ 个整数 $F_0, F_1, \\cdots, F_{N-1}$，相邻整数之间使用一个空格分隔，其中第 $i$ 个整数表示 $i$ 的父结点编号，$F_i = -1$ 表示结点 $i$ 没有父结点。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "**【样例说明】**\n\n选择编号为 3 和 4 的结点，$x_3 = 3$，$x_4 = 4$，他们的值异或后的结果为 $3 \\oplus 4 = 7$。\n\n**【评测用例规模与约定】**\n\n对于 $50\\%$ 的评测用例，$1 \\leq N \\leq 1000$；\n\n对于所有评测用例，$1 \\leq N \\leq 10^5$，$0 \\leq X_i \\leq 2^{31} - 1$，$-1 \\leq F_i \\leq N$。", "locale": "zh-CN"}}}
{"pid": "P13875", "type": "P", "difficulty": 5, "samples": [["6 1\n6 5 3 2 4 1\n1 2\n1 3\n2 4\n2 5\n3 6", "4"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["树状数组", "2024", "数论", "蓝桥杯省赛"], "title": "[蓝桥杯 2024 省研究生组] 植物生命力", "background": null, "description": "小蓝是一位资深的植物学家。他专注于研究植物的相互关系和生命力。在他所照料的森林中，每个品种的植物都拥有独特的生命力，彼此之间互不相同。\n\n植物的生命力会影响其下级品种的生长。具体地，如果下级品种的生命力数值无法被上级品种的生命力数值整除，或者下级品种的生命力数值大于上级品种的生命力数值时，它们便会受到压制，无法茁壮成长。\n\n为了深入研究和定量分析这一现象，小蓝构建了一种模型。他将森林中的植物品种关系抽象成了一棵包含 $n$ 个结点的树，结点的编号从 1 到 $n$，代表不同的植物品种。其中，树的根结点编号为 $s$，结点 $i$（$1 \\leq i \\leq n$）的生命力表示为 $a_i$。\n\n现在，小蓝想要对于每个结点 $i$，统计其子树（以 $i$ 为根的子树）中同时满足以下两个条件的子结点的数量：\n\n1. 子结点的生命力小于结点 $i$ 的生命力 $a_i$。\n2. 结点 $i$ 的生命力 $a_i$ 无法被子结点的生命力整除。\n\n请你帮助小蓝计算出所有子树中满足条件的结点个数的总和。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $s$，分别表示结点的数量和根结点的编号。\n\n第二行包含 $n$ 个互不相同的整数 $a_1, a_2, \\cdots, a_n$，相邻整数之间使用一个空格分隔，其中 $a_i$ 表示编号为 $i$ 的结点的生命力。\n\n接下来的 $n-1$ 行，每行包含两个整数 $u$ 和 $v$，用一个空格分隔，表示编号为 $u$ 和 $v$ 的结点之间存在一条边。", "outputFormat": "输出一行包含一个整数，表示所有子树中满足条件的结点个数的总和。", "hint": "**【样例说明】**\n\n在给定的样例中，树的结构如下：\n\n```\n    1\n   / \\\n  2   3\n / \\   \\\n4  5    6\n```\n\n在以 $1$ 为根的子树中，满足条件的结点有 $2, 5$，个数为 $2$。\n\n在以 $2$ 为根的子树中，满足条件的结点有 $4, 5$，个数为 $2$。\n\n在以 $3 \\sim 6$ 为根的子树中，没有满足条件的结点，个数均为 $0$。\n\n因此答案为 $2 + 2 = 4$。\n\n**【评测用例规模与约定】**\n\n对于 $30\\%$ 的评测用例，$1 \\leq n \\leq 2 \\times 10^3$，$1 \\leq s, u, v, a_i \\leq n$，$a_1, a_2, \\ldots, a_n$ 互不相同。\n\n对于所有评测用例，$1 \\leq n \\leq 10^5$，$1 \\leq s, u, v, a_i \\leq n$，$a_1, a_2, \\ldots, a_n$ 互不相同。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 省研究生组] 植物生命力", "background": null, "description": "小蓝是一位资深的植物学家。他专注于研究植物的相互关系和生命力。在他所照料的森林中，每个品种的植物都拥有独特的生命力，彼此之间互不相同。\n\n植物的生命力会影响其下级品种的生长。具体地，如果下级品种的生命力数值无法被上级品种的生命力数值整除，或者下级品种的生命力数值大于上级品种的生命力数值时，它们便会受到压制，无法茁壮成长。\n\n为了深入研究和定量分析这一现象，小蓝构建了一种模型。他将森林中的植物品种关系抽象成了一棵包含 $n$ 个结点的树，结点的编号从 1 到 $n$，代表不同的植物品种。其中，树的根结点编号为 $s$，结点 $i$（$1 \\leq i \\leq n$）的生命力表示为 $a_i$。\n\n现在，小蓝想要对于每个结点 $i$，统计其子树（以 $i$ 为根的子树）中同时满足以下两个条件的子结点的数量：\n\n1. 子结点的生命力小于结点 $i$ 的生命力 $a_i$。\n2. 结点 $i$ 的生命力 $a_i$ 无法被子结点的生命力整除。\n\n请你帮助小蓝计算出所有子树中满足条件的结点个数的总和。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $s$，分别表示结点的数量和根结点的编号。\n\n第二行包含 $n$ 个互不相同的整数 $a_1, a_2, \\cdots, a_n$，相邻整数之间使用一个空格分隔，其中 $a_i$ 表示编号为 $i$ 的结点的生命力。\n\n接下来的 $n-1$ 行，每行包含两个整数 $u$ 和 $v$，用一个空格分隔，表示编号为 $u$ 和 $v$ 的结点之间存在一条边。", "outputFormat": "输出一行包含一个整数，表示所有子树中满足条件的结点个数的总和。", "hint": "**【样例说明】**\n\n在给定的样例中，树的结构如下：\n\n```\n    1\n   / \\\n  2   3\n / \\   \\\n4  5    6\n```\n\n在以 $1$ 为根的子树中，满足条件的结点有 $2, 5$，个数为 $2$。\n\n在以 $2$ 为根的子树中，满足条件的结点有 $4, 5$，个数为 $2$。\n\n在以 $3 \\sim 6$ 为根的子树中，没有满足条件的结点，个数均为 $0$。\n\n因此答案为 $2 + 2 = 4$。\n\n**【评测用例规模与约定】**\n\n对于 $30\\%$ 的评测用例，$1 \\leq n \\leq 2 \\times 10^3$，$1 \\leq s, u, v, a_i \\leq n$，$a_1, a_2, \\ldots, a_n$ 互不相同。\n\n对于所有评测用例，$1 \\leq n \\leq 10^5$，$1 \\leq s, u, v, a_i \\leq n$，$a_1, a_2, \\ldots, a_n$ 互不相同。", "locale": "zh-CN"}}}
