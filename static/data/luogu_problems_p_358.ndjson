{"pid": "P8255", "type": "P", "difficulty": 5, "samples": [["1\n10 240", "12"], ["3\n5 30\n4 8\n11 11", "6\n-1\n1"], ["见附件中的 math3.in", "见附件中的 math3.out"], ["见附件中的 math4.in", "见附件中的 math4.out"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2022", "O2优化", "最大公约数 gcd", "NOI Online"], "title": "[NOI Online 2022 入门组] 数学游戏", "background": "**经过管理员的考虑，我们打算将民间数据单独存放在最后一个 Subtask 中。这些测试点分数均为 0 分，但是没有通过其中的任何测试点将会视为此题不通过。**\n\n民间数据提供者：@一扶苏一。本题不保证民间数据强度，详见[这个帖子](https://www.luogu.com.cn/discuss/422596)。", "description": "Kri 喜欢玩数字游戏。\n\n一天，他在草稿纸上写下了 $t$ 对正整数 $(x,y)$，并对于每一对正整数计算出了 $z=x\\times y\\times\\gcd(x,y)$。\n\n可是调皮的 Zay 找到了 Kri 的草稿纸，并把每一组的 $y$ 都擦除了，还可能改动了一些 $z$。\n\n现在 Kri 想请你帮忙还原每一组的 $y$，具体地，对于每一组中的 $x$ 和 $z$，你需要输出最小的正整数 $y$，使得 $z=x\\times y\\times\\gcd(x,y)$。如果这样的 $y$ 不存在，也就是 Zay 一定改动了 $z$，那么请输出 $-1$。\n\n注：$\\gcd(x,y)$ 表示 $x$ 和 $y$ 的最大公约数，也就是最大的正整数 $d$，满足 $d$ 既是 $x$ 的约数，又是 $y$ 的约数。", "inputFormat": "第一行一个整数 ，表示有 $t$ 对正整数 $x$ 和 $z$。\n\n接下来 $t$ 行，每行两个正整数 $x$ 和 $z$，含义见题目描述。", "outputFormat": "对于每对数字输出一行，如果不存在满足条件的正整数 $y$，请输出 $-1$，否则输出满足条件的最小正整数 $y$。", "hint": "**【样例 1 解释】**\n\n$x\\times y\\times \\gcd(x,y)=10\\times 12\\times\\gcd(10,12)=240$。\n\n**【数据范围】**\n\n对于 $20\\%$ 的数据，$t, x, z \\le {10}^3$。\n\n对于 $40\\%$ 的数据，$t \\le {10}^3$，$x \\le {10}^6$，$z \\le {10}^9$。\n\n对于另 $30\\%$ 的数据，$t \\le {10}^4$。\n\n对于另 $20\\%$ 的数据，$x \\le {10}^6$。\n\n对于 $100\\%$ 的数据，$1 \\le t \\le 5 \\times {10}^5$，$1 \\le x \\le {10}^9$，$1 \\le z < 2^{63}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOI Online 2022 入门组] 数学游戏", "background": "**经过管理员的考虑，我们打算将民间数据单独存放在最后一个 Subtask 中。这些测试点分数均为 0 分，但是没有通过其中的任何测试点将会视为此题不通过。**\n\n民间数据提供者：@一扶苏一。本题不保证民间数据强度，详见[这个帖子](https://www.luogu.com.cn/discuss/422596)。", "description": "Kri 喜欢玩数字游戏。\n\n一天，他在草稿纸上写下了 $t$ 对正整数 $(x,y)$，并对于每一对正整数计算出了 $z=x\\times y\\times\\gcd(x,y)$。\n\n可是调皮的 Zay 找到了 Kri 的草稿纸，并把每一组的 $y$ 都擦除了，还可能改动了一些 $z$。\n\n现在 Kri 想请你帮忙还原每一组的 $y$，具体地，对于每一组中的 $x$ 和 $z$，你需要输出最小的正整数 $y$，使得 $z=x\\times y\\times\\gcd(x,y)$。如果这样的 $y$ 不存在，也就是 Zay 一定改动了 $z$，那么请输出 $-1$。\n\n注：$\\gcd(x,y)$ 表示 $x$ 和 $y$ 的最大公约数，也就是最大的正整数 $d$，满足 $d$ 既是 $x$ 的约数，又是 $y$ 的约数。", "inputFormat": "第一行一个整数 ，表示有 $t$ 对正整数 $x$ 和 $z$。\n\n接下来 $t$ 行，每行两个正整数 $x$ 和 $z$，含义见题目描述。", "outputFormat": "对于每对数字输出一行，如果不存在满足条件的正整数 $y$，请输出 $-1$，否则输出满足条件的最小正整数 $y$。", "hint": "**【样例 1 解释】**\n\n$x\\times y\\times \\gcd(x,y)=10\\times 12\\times\\gcd(10,12)=240$。\n\n**【数据范围】**\n\n对于 $20\\%$ 的数据，$t, x, z \\le {10}^3$。\n\n对于 $40\\%$ 的数据，$t \\le {10}^3$，$x \\le {10}^6$，$z \\le {10}^9$。\n\n对于另 $30\\%$ 的数据，$t \\le {10}^4$。\n\n对于另 $20\\%$ 的数据，$x \\le {10}^6$。\n\n对于 $100\\%$ 的数据，$1 \\le t \\le 5 \\times {10}^5$，$1 \\le x \\le {10}^9$，$1 \\le z < 2^{63}$。", "locale": "zh-CN"}}}
{"pid": "P8256", "type": "P", "difficulty": 5, "samples": [["3\n6 2\n10-01-\n01\n7 3\n010-1-1\n101\n6 4\n111-00\n1100", "2\n1\n2"], ["见附件中的 string2.in", "见附件中的 string2.out"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2022", "O2优化", "NOI Online"], "title": "[NOI Online 2022 入门组] 字符串", "background": "**经过管理员的考虑，我们打算将民间数据单独存放在最后一个 Subtask 中。这些测试点分数均为 0 分，但是没有通过其中的任何测试点将会视为此题不通过。**\n\n**这一题中出现了评测记录测试点编号错乱的问题，是民间数据命名方式冲突导致的。但是我们保证其相对顺序没有混乱。**\n\n民间数据提供者：@tiger2005。", "description": "Kri 非常喜欢字符串，所以他准备找 $t$ 组字符串研究。\n\n第 $i$ 次研究中，Kri 准备了两个字符串 $S$ 和 $R$ ，其中 $S$ 长度为 $n$，且只由 `0`, `1`, `-` 三种字符构成（注：这里的第三种字符是减号），$R$ 初始时为空。\n\n每次研究，Zay 会带着一个美丽的长度为 $m$ 的字符串 $T$ 来找 Kri 玩，Kri 非常羡慕 Zay 拥有如此美丽的字符串，便也想用字符串 $S$ 和 $R$ 变出字符串 $T$。\n\n具体地，Kri 将会进行 $n$ 次操作。每次操作中，Kri 会取出 $S$ 的第一个字符（记为 $c$），并将其从 $S$ 中删去。如果 $c = \\texttt{-}$，则 Kri 要删去 $R$ 的开头字符或结尾字符（数据保证删去后 $R$ 不为空）。否则，Kri 会将 $c$ 加入到 $R$ 的末尾。\n\n当进行完所有操作后，Kri 会检查 $R$ 是否和 $T$ 相等。如果 $R = T$，Kri 就会感到开心；否则，Kri 会感到难受。\n\n请问在每次研究中，Kri 有多少种操作方式使自己最后感到开心？我们定义两种方案不同，当且仅当在某种方案的某次操作中， Kri 删去了 $R$ 的开头字符。而在另一种方案的这次操作中， Kri 删去了 $R$ 的结尾字符。\n\n由于答案可能很大，你只需要输出答案除以 $1,000,000,007$（即 $10^9+7$）的余数。", "inputFormat": "第一行一个正整数 $t$。\n\n接下来有 $t$ 组数据分别表示 $t$ 次字符串的研究，对于每组数据：\n\n第一行有两个正整数 $n,m$，分别表示字符串 $S,T$ 的长度。\n\n第二行是字符串 $S$。\n\n第三行是字符串 $T$。", "outputFormat": "共 $t$ 行，第 $i$ 行表示第 $i$ 组研究的答案。", "hint": "**【样例 1 解释】**\n\n对于第一组数据，有以下两种方案：\n\n- 第一个 `-` 删 $R$ 的开头，第二个 `-` 删 $R$ 的开头。\n- 第一个 `-` 删 $R$ 的结尾，第二个 `-` 删 $R$ 的开头。\n\n**【数据范围】**\n\n对于 $20\\%$ 的数据，$n,m\\le 15$。\n\n对于 $30\\%$ 的数据，$n,m\\le 30$。\n\n对于 $70\\%$ 的数据，$n,m\\le 80$。\n\n对于另 $10\\%$ 的数据，保证答案不超过 $1$。\n\n对于 $100\\%$ 的数据，$1\\le t\\le 5$，$1\\le n,m\\le 400$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOI Online 2022 入门组] 字符串", "background": "**经过管理员的考虑，我们打算将民间数据单独存放在最后一个 Subtask 中。这些测试点分数均为 0 分，但是没有通过其中的任何测试点将会视为此题不通过。**\n\n**这一题中出现了评测记录测试点编号错乱的问题，是民间数据命名方式冲突导致的。但是我们保证其相对顺序没有混乱。**\n\n民间数据提供者：@tiger2005。", "description": "Kri 非常喜欢字符串，所以他准备找 $t$ 组字符串研究。\n\n第 $i$ 次研究中，Kri 准备了两个字符串 $S$ 和 $R$ ，其中 $S$ 长度为 $n$，且只由 `0`, `1`, `-` 三种字符构成（注：这里的第三种字符是减号），$R$ 初始时为空。\n\n每次研究，Zay 会带着一个美丽的长度为 $m$ 的字符串 $T$ 来找 Kri 玩，Kri 非常羡慕 Zay 拥有如此美丽的字符串，便也想用字符串 $S$ 和 $R$ 变出字符串 $T$。\n\n具体地，Kri 将会进行 $n$ 次操作。每次操作中，Kri 会取出 $S$ 的第一个字符（记为 $c$），并将其从 $S$ 中删去。如果 $c = \\texttt{-}$，则 Kri 要删去 $R$ 的开头字符或结尾字符（数据保证删去后 $R$ 不为空）。否则，Kri 会将 $c$ 加入到 $R$ 的末尾。\n\n当进行完所有操作后，Kri 会检查 $R$ 是否和 $T$ 相等。如果 $R = T$，Kri 就会感到开心；否则，Kri 会感到难受。\n\n请问在每次研究中，Kri 有多少种操作方式使自己最后感到开心？我们定义两种方案不同，当且仅当在某种方案的某次操作中， Kri 删去了 $R$ 的开头字符。而在另一种方案的这次操作中， Kri 删去了 $R$ 的结尾字符。\n\n由于答案可能很大，你只需要输出答案除以 $1,000,000,007$（即 $10^9+7$）的余数。", "inputFormat": "第一行一个正整数 $t$。\n\n接下来有 $t$ 组数据分别表示 $t$ 次字符串的研究，对于每组数据：\n\n第一行有两个正整数 $n,m$，分别表示字符串 $S,T$ 的长度。\n\n第二行是字符串 $S$。\n\n第三行是字符串 $T$。", "outputFormat": "共 $t$ 行，第 $i$ 行表示第 $i$ 组研究的答案。", "hint": "**【样例 1 解释】**\n\n对于第一组数据，有以下两种方案：\n\n- 第一个 `-` 删 $R$ 的开头，第二个 `-` 删 $R$ 的开头。\n- 第一个 `-` 删 $R$ 的结尾，第二个 `-` 删 $R$ 的开头。\n\n**【数据范围】**\n\n对于 $20\\%$ 的数据，$n,m\\le 15$。\n\n对于 $30\\%$ 的数据，$n,m\\le 30$。\n\n对于 $70\\%$ 的数据，$n,m\\le 80$。\n\n对于另 $10\\%$ 的数据，保证答案不超过 $1$。\n\n对于 $100\\%$ 的数据，$1\\le t\\le 5$，$1\\le n,m\\le 400$。", "locale": "zh-CN"}}}
{"pid": "P8257", "type": "P", "difficulty": 7, "samples": [["5 2\n1 1 1 2 4\n1 5\n3 5\n", "3\n2"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "CTSC/CTS"], "title": "[CTS2022] 普罗霍洛夫卡", "background": "", "description": "给定序列 $a_1,\\dots,a_n$，共 $m$ 次询问，每次询问给出 $l,r$，查询所有满足 $l\\le L\\le R\\le r$ 的 $(L,R)$ 的权值的按位异或和，二元组 $(L,R)$ 的权值是 $|\\{a_i\\mid L\\le i\\le R\\}|$。", "inputFormat": "从标准输入读入数据。\n\n第一行两个整数 $n\\ m$；\n\n接下来一行 $n$ 个整数 $a_1,\\dots,a_n$；\n\n接下来 $m$ 行，每行两个整数 $l\\ r$ 表示一次查询。", "outputFormat": "输出到标准输出。\n\n输出 $m$ 行，依次表示每个询问的答案。", "hint": "对于 $5\\%$ 的数据，满足 $1\\le n,m\\le 100$。\n\n对于 $10\\%$ 的数据，满足 $1\\le n,m\\le 5000$。\n\n对于 $20\\%$ 的数据，满足 $1\\le n,m\\le 10^5$。\n\n对于 $30\\%$ 的数据，满足 $1\\le n,m\\le 2\\times 10^5$。\n\n对于 $40\\%$ 的数据，满足 $1\\le n,m\\le 3\\times 10^5$。\n\n对于 $50\\%$ 的数据，满足 $1\\le n,m\\le 3.5\\times 10^5$。\n\n对于另外 $10\\%$ 的数据，满足 $m=n^2$。\n\n对于另外 $10\\%$ 的数据，满足对任意 $i=1\\cdots n$，$a_i\\le 2$。\n\n对于另外 $10\\%$ 的数据，满足对任意 $i=1\\cdots n$，$a_i\\le 10$。\n\n对于 $100\\%$ 的数据，满足 $1\\le n,m\\le 4\\times 10^5$，$1\\le a_i\\le n$，所有数值为整数。\n\n每类数据构成子任务。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CTS2022] 普罗霍洛夫卡", "background": "", "description": "给定序列 $a_1,\\dots,a_n$，共 $m$ 次询问，每次询问给出 $l,r$，查询所有满足 $l\\le L\\le R\\le r$ 的 $(L,R)$ 的权值的按位异或和，二元组 $(L,R)$ 的权值是 $|\\{a_i\\mid L\\le i\\le R\\}|$。", "inputFormat": "从标准输入读入数据。\n\n第一行两个整数 $n\\ m$；\n\n接下来一行 $n$ 个整数 $a_1,\\dots,a_n$；\n\n接下来 $m$ 行，每行两个整数 $l\\ r$ 表示一次查询。", "outputFormat": "输出到标准输出。\n\n输出 $m$ 行，依次表示每个询问的答案。", "hint": "对于 $5\\%$ 的数据，满足 $1\\le n,m\\le 100$。\n\n对于 $10\\%$ 的数据，满足 $1\\le n,m\\le 5000$。\n\n对于 $20\\%$ 的数据，满足 $1\\le n,m\\le 10^5$。\n\n对于 $30\\%$ 的数据，满足 $1\\le n,m\\le 2\\times 10^5$。\n\n对于 $40\\%$ 的数据，满足 $1\\le n,m\\le 3\\times 10^5$。\n\n对于 $50\\%$ 的数据，满足 $1\\le n,m\\le 3.5\\times 10^5$。\n\n对于另外 $10\\%$ 的数据，满足 $m=n^2$。\n\n对于另外 $10\\%$ 的数据，满足对任意 $i=1\\cdots n$，$a_i\\le 2$。\n\n对于另外 $10\\%$ 的数据，满足对任意 $i=1\\cdots n$，$a_i\\le 10$。\n\n对于 $100\\%$ 的数据，满足 $1\\le n,m\\le 4\\times 10^5$，$1\\le a_i\\le n$，所有数值为整数。\n\n每类数据构成子任务。", "locale": "zh-CN"}}}
{"pid": "P8258", "type": "P", "difficulty": 7, "samples": [["4\n-1 2 3 4\n1 1 1\n", "10\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "树形 DP", "CTSC/CTS"], "title": "[CTS2022] 独立集问题", "background": "", "description": "小 E 喜欢出最大权独立集问题。\n\n接下来，他还想了 $n$ 道最大权独立集问题。\n\n但是和之前不一样，这回他想把 $n$ 道题整合成一道题出出来。\n\n小 E 有 $n$ 个 AI，编号为 $1\\sim n$ 。\n\n开始第 $i$ 个 AI 里面存有一道小 E 事先出好的一道难度为 $d_i$ 的最大权独立集问题。\n\n有些 AI 之间可以互相通信，对于所有的 $2 \\le i \\le n$ ，第 $i$ 个 AI 可以和第 $c_i$ 个 AI 互相通信。其中 $c_i<i$。所以，这些 AI 连成了一个树的形状。此外，其他对 AI 不可以互相通信。\n\n小 E 每次可以选择一个存有一道最大权独立集问题的 AI，结合它能够直接互相通信的所有 AI 中的问题，变成一道新的最大权独立集问题。整合问题时总有难度损失，不可能是把所有问题的难度直接相加。这道新的最大权独立集问题的难度是那些能够直接互相通信的 AI 中的题目难度和减去原本存在该 AI 上的问题的难度。然后那些能够直接互相通信的 AI 中的问题难度会变成 $0$。\n\n小 E 希望通过若干次操作，把 $n-1$ 个 AI 中的题目难度都变成 $0$，然后把最后一个 AI 中的题目出出来。\n\n由于出题人的丧病心理，小 E 想要出出来的最大权独立集问题的难度尽量大。\n\n他想叫你帮他解决这个问题，还说如果你成功解决了这个问题，那么在出那道最大权独立集问题的时候，他会帮你提交一份标程代码。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个整数，第 $i$ 个表示 $d_i$。\n\n第三行 $n-1$ 个正整数，第 $i$ 个表示 $c_{i+1}$。", "outputFormat": "一行一个整数表示答案。", "hint": "保证 $1\\le n\\le 351493$。\n\n保证 $1\\le c_i <i$。\n\n保证 $|d_i|\\le 10^9$。\n\n\n\n子任务 1（13 分）：$c_i=i-1$。\n\n子任务 2（6 分）：$d_i>0$。\n\n子任务 3（11 分）：$n\\le 7$。\n\n子任务 4（13 分）：$n\\le 16$。\n\n子任务 5（22 分）：$n\\le 100$。\n\n子任务 6（35 分）：无特殊性质。\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CTS2022] 独立集问题", "background": "", "description": "小 E 喜欢出最大权独立集问题。\n\n接下来，他还想了 $n$ 道最大权独立集问题。\n\n但是和之前不一样，这回他想把 $n$ 道题整合成一道题出出来。\n\n小 E 有 $n$ 个 AI，编号为 $1\\sim n$ 。\n\n开始第 $i$ 个 AI 里面存有一道小 E 事先出好的一道难度为 $d_i$ 的最大权独立集问题。\n\n有些 AI 之间可以互相通信，对于所有的 $2 \\le i \\le n$ ，第 $i$ 个 AI 可以和第 $c_i$ 个 AI 互相通信。其中 $c_i<i$。所以，这些 AI 连成了一个树的形状。此外，其他对 AI 不可以互相通信。\n\n小 E 每次可以选择一个存有一道最大权独立集问题的 AI，结合它能够直接互相通信的所有 AI 中的问题，变成一道新的最大权独立集问题。整合问题时总有难度损失，不可能是把所有问题的难度直接相加。这道新的最大权独立集问题的难度是那些能够直接互相通信的 AI 中的题目难度和减去原本存在该 AI 上的问题的难度。然后那些能够直接互相通信的 AI 中的问题难度会变成 $0$。\n\n小 E 希望通过若干次操作，把 $n-1$ 个 AI 中的题目难度都变成 $0$，然后把最后一个 AI 中的题目出出来。\n\n由于出题人的丧病心理，小 E 想要出出来的最大权独立集问题的难度尽量大。\n\n他想叫你帮他解决这个问题，还说如果你成功解决了这个问题，那么在出那道最大权独立集问题的时候，他会帮你提交一份标程代码。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个整数，第 $i$ 个表示 $d_i$。\n\n第三行 $n-1$ 个正整数，第 $i$ 个表示 $c_{i+1}$。", "outputFormat": "一行一个整数表示答案。", "hint": "保证 $1\\le n\\le 351493$。\n\n保证 $1\\le c_i <i$。\n\n保证 $|d_i|\\le 10^9$。\n\n\n\n子任务 1（13 分）：$c_i=i-1$。\n\n子任务 2（6 分）：$d_i>0$。\n\n子任务 3（11 分）：$n\\le 7$。\n\n子任务 4（13 分）：$n\\le 16$。\n\n子任务 5（22 分）：$n\\le 100$。\n\n子任务 6（35 分）：无特殊性质。\n\n", "locale": "zh-CN"}}}
{"pid": "P8259", "type": "P", "difficulty": 7, "samples": [["5\n1 3 4 5 1\n2 1 4 3 5\n1 2 4 2 2\n2 4 5 3 5\n1 4 4 4 8", "46\n21"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "O2优化", "CTSC/CTS"], "title": "[CTS2022] 回", "background": "", "description": "你需要维护平面上的整点，每个点初始有点权 $0$，共 $m$ 次操作。\n\n修改操作：给定 $x,y,d,w$，将满足 $|X-x|<d,|Y-y|<d$ 的整点 $(X,Y)$ 的点权增加 $w\\cdot(d-\\max(|X-x|,|Y-y|))$；\n\n查询操作：给定 $x_1,x_2,y_1,y_2$，查询满足 $x_1\\le X\\le x_2,\\;y_1\\le Y\\le y_2$ 的整点 $(X,Y)$ 的点权之和，答案对 $2^{30}$ 取模。", "inputFormat": "从标准输入读入数据。\n\n第一行一个整数 $m$，接下来 $m$ 行，每行表示一个操作。\n\n修改操作表示为 `1 x y d w`；\n\n查询操作表示为 `2 x1 x2 y1 y2`。", "outputFormat": "输出到标准输出。\n\n对每个查询操作，输出一行，包含一个整数，表示取模后的答案。", "hint": "对于 $23\\%$ 的数据，满足 $1\\le m\\le 10^3$。\n\n对于 $31\\%$ 的数据，满足 $1\\le m\\le 2\\times 10^4$。\n\n对于 $39\\%$ 的数据，满足 $1\\le m\\le 4\\times 10^4$。\n\n对于 $47\\%$ 的数据，满足 $1\\le m\\le 6\\times 10^4$。\n\n对于 $55\\%$ 的数据，满足 $1\\le m\\le 8\\times 10^4$。\n\n对于另外 $15\\%$ 的数据，满足对任意询问操作，不存在一个修改操作，该修改操作在该询问操作之后。\n\n对于另外 $10\\%$ 的数据，满足 $x_2-x_1\\le 5$，$y_2-y_1\\le 5$，$d\\le 5$。\n\n对于另外 $10\\%$ 的数据，满足 $d\\le 5$。\n\n对于 $100\\%$ 的数据，满足 $1\\le m\\le 10^5$，$1\\le x_1\\le x_2\\le {10}^8$，$1\\le y_1\\le y_2\\le {10}^8$，$1\\le x,y,d,w\\le {10}^8$。\n\n每类数据构成子任务。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CTS2022] 回", "background": "", "description": "你需要维护平面上的整点，每个点初始有点权 $0$，共 $m$ 次操作。\n\n修改操作：给定 $x,y,d,w$，将满足 $|X-x|<d,|Y-y|<d$ 的整点 $(X,Y)$ 的点权增加 $w\\cdot(d-\\max(|X-x|,|Y-y|))$；\n\n查询操作：给定 $x_1,x_2,y_1,y_2$，查询满足 $x_1\\le X\\le x_2,\\;y_1\\le Y\\le y_2$ 的整点 $(X,Y)$ 的点权之和，答案对 $2^{30}$ 取模。", "inputFormat": "从标准输入读入数据。\n\n第一行一个整数 $m$，接下来 $m$ 行，每行表示一个操作。\n\n修改操作表示为 `1 x y d w`；\n\n查询操作表示为 `2 x1 x2 y1 y2`。", "outputFormat": "输出到标准输出。\n\n对每个查询操作，输出一行，包含一个整数，表示取模后的答案。", "hint": "对于 $23\\%$ 的数据，满足 $1\\le m\\le 10^3$。\n\n对于 $31\\%$ 的数据，满足 $1\\le m\\le 2\\times 10^4$。\n\n对于 $39\\%$ 的数据，满足 $1\\le m\\le 4\\times 10^4$。\n\n对于 $47\\%$ 的数据，满足 $1\\le m\\le 6\\times 10^4$。\n\n对于 $55\\%$ 的数据，满足 $1\\le m\\le 8\\times 10^4$。\n\n对于另外 $15\\%$ 的数据，满足对任意询问操作，不存在一个修改操作，该修改操作在该询问操作之后。\n\n对于另外 $10\\%$ 的数据，满足 $x_2-x_1\\le 5$，$y_2-y_1\\le 5$，$d\\le 5$。\n\n对于另外 $10\\%$ 的数据，满足 $d\\le 5$。\n\n对于 $100\\%$ 的数据，满足 $1\\le m\\le 10^5$，$1\\le x_1\\le x_2\\le {10}^8$，$1\\le y_1\\le y_2\\le {10}^8$，$1\\le x,y,d,w\\le {10}^8$。\n\n每类数据构成子任务。", "locale": "zh-CN"}}}
{"pid": "P8260", "type": "P", "difficulty": 7, "samples": [["5 4\n1 2 3 3\n3 5\n2 2\n5 2\n2 5\n", "7\n"]], "limits": {"time": [12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2022", "CTSC/CTS"], "title": "[CTS2022] 燃烧的呐球", "background": "**警告：滥用本题卡评测者将被封号。**", "description": "已知 $n$ 个顶点的有根树，以及 $m$ 个二元组 $(x_i,y_i)$，其中 $x_i,y_i$ 是树的顶点。\n\n对于树的顶点 $a,b$，定义 $D(a,b)$ 为：在以 $a$ 为根的子树中，但不在以 $b$ 为根的子树中的顶点个数。\n\n你需要求出以这些二元组为顶点的完全图的最小生成树，其中 $(x_i,y_i)$ 和 $(x_j,y_j)$ 之间的边权是 $D(x_i,x_j)+D(x_j,x_i)+D(y_i,y_j)+D(y_j,y_i)$。", "inputFormat": "第一行两个数表示 $n,m$。\n\n之后一行 $n-1$ 个数，其中第 $i$ 个数表示编号为 $i+1$ 的节点的父亲 $f_{i+1}$，保证 $f_{i+1}< i+1$。\n\n之后 $m$ 行，第 $i$ 行两个数 $x_i,y_i$，表示一个给定的二元组。", "outputFormat": "输出一个整数，表示最小生成树的边权和。", "hint": "样例解释：\n\n最小生成树包含边 $(1,4,1),(2,3,3),(2,4,3)$，三元组表示第一个二元组的编号，第二个二元组的编号，边权。边权和为 $7$。\n\n数据范围：\n\n对于 $10\\%$ 的数据，满足 $1\\le n,m\\le 1000$。\n\n对于另外 $10\\%$ 的数据，满足 $1\\le m\\le 2\\times 10^4$。\n\n对于另外 $10\\%$ 的数据，满足 $1\\le m\\le 5\\times 10^4$。\n\n对于另外 $20\\%$ 的数据，满足 $m=n^2$，且每个二元组互不相同。\n\n对于另外 $10\\%$ 的数据，满足对任意 $i=2\\cdots n$，$f_i=i-1$。\n\n对于另外 $10\\%$ 的数据，满足对任意 $i=2\\cdots n$，$f_i=1$。\n\n对于 $100\\%$ 的数据，满足 $1\\le n\\le 10^6,1\\le m\\le 10^5$。对任意 $i=1,2,\\dots n-1$，满足 $1\\le f_{i+1}<i+1$。对任意 $i=1,2,\\dots m$，满足 $1\\le x_i,y_i\\le n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CTS2022] 燃烧的呐球", "background": "**警告：滥用本题卡评测者将被封号。**", "description": "已知 $n$ 个顶点的有根树，以及 $m$ 个二元组 $(x_i,y_i)$，其中 $x_i,y_i$ 是树的顶点。\n\n对于树的顶点 $a,b$，定义 $D(a,b)$ 为：在以 $a$ 为根的子树中，但不在以 $b$ 为根的子树中的顶点个数。\n\n你需要求出以这些二元组为顶点的完全图的最小生成树，其中 $(x_i,y_i)$ 和 $(x_j,y_j)$ 之间的边权是 $D(x_i,x_j)+D(x_j,x_i)+D(y_i,y_j)+D(y_j,y_i)$。", "inputFormat": "第一行两个数表示 $n,m$。\n\n之后一行 $n-1$ 个数，其中第 $i$ 个数表示编号为 $i+1$ 的节点的父亲 $f_{i+1}$，保证 $f_{i+1}< i+1$。\n\n之后 $m$ 行，第 $i$ 行两个数 $x_i,y_i$，表示一个给定的二元组。", "outputFormat": "输出一个整数，表示最小生成树的边权和。", "hint": "样例解释：\n\n最小生成树包含边 $(1,4,1),(2,3,3),(2,4,3)$，三元组表示第一个二元组的编号，第二个二元组的编号，边权。边权和为 $7$。\n\n数据范围：\n\n对于 $10\\%$ 的数据，满足 $1\\le n,m\\le 1000$。\n\n对于另外 $10\\%$ 的数据，满足 $1\\le m\\le 2\\times 10^4$。\n\n对于另外 $10\\%$ 的数据，满足 $1\\le m\\le 5\\times 10^4$。\n\n对于另外 $20\\%$ 的数据，满足 $m=n^2$，且每个二元组互不相同。\n\n对于另外 $10\\%$ 的数据，满足对任意 $i=2\\cdots n$，$f_i=i-1$。\n\n对于另外 $10\\%$ 的数据，满足对任意 $i=2\\cdots n$，$f_i=1$。\n\n对于 $100\\%$ 的数据，满足 $1\\le n\\le 10^6,1\\le m\\le 10^5$。对任意 $i=1,2,\\dots n-1$，满足 $1\\le f_{i+1}<i+1$。对任意 $i=1,2,\\dots m$，满足 $1\\le x_i,y_i\\le n$。", "locale": "zh-CN"}}}
{"pid": "P8261", "type": "P", "difficulty": 7, "samples": [["5 2\n2 -1 1\n0 -3 5\n1 -3 2\n1 3 5\n3 2 2\n1 2 4\n1 -2 -9\n", "2\n9\n"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "O2优化", "根号分治", "CTSC/CTS"], "title": "[CTS2022] 袜子", "background": "", "description": "给定 $n$ 个点 $(x_i,y_i,c_i)$，$i=1,2,\\dots,n$，共有 $m$ 次查询操作，每次查询给定 $A,B,C$，问满足 $Ax_i+By_i+C<0$，$Ax_j+By_j+C<0$，$c_i=c_j$ 的二元组 $(i,j)$ 的个数。", "inputFormat": "第一行两个整数 $n\\ m$；\n\n接下来 $n$ 行，每行三个整数 $x_i\\ y_i\\ c_i$，$i=1,2,\\dots,n$；\n\n接下来 $m$ 行，每行三个整数 $A\\ B\\ C$。", "outputFormat": "共 $m$ 行，每行一个整数，表示答案。", "hint": "样例解释：\n\n第一个查询对应 $(2,2)(3,3)$；\n\n第二个查询对应 $(1,1)(2,2)(2,4)(3,3)(3,5)(4,2)(4,4)(5,3)(5,5)$。\n\n数据范围：\n\n对 $5\\%$ 的数据，$n,m\\le 10^3$；\n\n对另外 $10\\%$ 的数据，$c_i\\le 2$；\n\n对另外 $15\\%$ 的数据，$c_i\\le 100$；\n\n对另外 $15\\%$ 的数据，$\\max(|x_i|,|y_i|)=10^6$；\n\n对另外 $15\\%$ 的数据，$|A|=|B|=1$；\n\n对另外 $10\\%$ 的数据，$n\\le 20000,\\;m\\le 200000$；\n\n对于其余数据，无特殊约束。\n\n每部分数据构成子任务，无依赖关系。\n\n所有数据满足：\n\n$1\\le n\\le 50000$；\n\n$1\\le m\\le 500000$；\n\n$A^2+B^2>0$；\n\n$-10^9\\le x_i,y_i,A,B,C\\le 10^9$；\n\n$1\\le c_i\\le n$；\n\n所有数值为整数；\n\n当 $i\\ne j$ 时，$x_i\\ne x_j$ 或 $y_i\\ne y_j$。\n\n对于除了子任务 4 以外的数据，满足 $n$ 个点的 $x,y$ 坐标分别在某个预设的区间内均匀随机选取，并保证没有重复的点，且对于第 $i$ 个点，$c_i$ 和 $x_i,y_i$ 是分别独立地随机选取的，但 $c_i$ 的分布没有特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CTS2022] 袜子", "background": "", "description": "给定 $n$ 个点 $(x_i,y_i,c_i)$，$i=1,2,\\dots,n$，共有 $m$ 次查询操作，每次查询给定 $A,B,C$，问满足 $Ax_i+By_i+C<0$，$Ax_j+By_j+C<0$，$c_i=c_j$ 的二元组 $(i,j)$ 的个数。", "inputFormat": "第一行两个整数 $n\\ m$；\n\n接下来 $n$ 行，每行三个整数 $x_i\\ y_i\\ c_i$，$i=1,2,\\dots,n$；\n\n接下来 $m$ 行，每行三个整数 $A\\ B\\ C$。", "outputFormat": "共 $m$ 行，每行一个整数，表示答案。", "hint": "样例解释：\n\n第一个查询对应 $(2,2)(3,3)$；\n\n第二个查询对应 $(1,1)(2,2)(2,4)(3,3)(3,5)(4,2)(4,4)(5,3)(5,5)$。\n\n数据范围：\n\n对 $5\\%$ 的数据，$n,m\\le 10^3$；\n\n对另外 $10\\%$ 的数据，$c_i\\le 2$；\n\n对另外 $15\\%$ 的数据，$c_i\\le 100$；\n\n对另外 $15\\%$ 的数据，$\\max(|x_i|,|y_i|)=10^6$；\n\n对另外 $15\\%$ 的数据，$|A|=|B|=1$；\n\n对另外 $10\\%$ 的数据，$n\\le 20000,\\;m\\le 200000$；\n\n对于其余数据，无特殊约束。\n\n每部分数据构成子任务，无依赖关系。\n\n所有数据满足：\n\n$1\\le n\\le 50000$；\n\n$1\\le m\\le 500000$；\n\n$A^2+B^2>0$；\n\n$-10^9\\le x_i,y_i,A,B,C\\le 10^9$；\n\n$1\\le c_i\\le n$；\n\n所有数值为整数；\n\n当 $i\\ne j$ 时，$x_i\\ne x_j$ 或 $y_i\\ne y_j$。\n\n对于除了子任务 4 以外的数据，满足 $n$ 个点的 $x,y$ 坐标分别在某个预设的区间内均匀随机选取，并保证没有重复的点，且对于第 $i$ 个点，$c_i$ 和 $x_i,y_i$ 是分别独立地随机选取的，但 $c_i$ 的分布没有特殊限制。", "locale": "zh-CN"}}}
{"pid": "P8262", "type": "P", "difficulty": 7, "samples": [], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "交互题", "Special Judge", "O2优化", "CTSC/CTS"], "title": "[CTS2022] 隆", "background": "这是一道交互题。\n\n本地测试需 #include <long.h>\n提交时请采用以下模板，而不 include long.h，具体方法就是直接把这个模板放在自己代码里面，然后需要完善题目中要求的函数。\n\n```cpp\nstruct sethash{\n\tint val;\n\tvoid encode();\n\tvoid decode();\n\tvoid operator=(int x);\n};\nstruct infoset{\n\tsethash sum;\n\tint sz;\n\tint size()const{\n\t\treturn sz;\n\t}\n};\nextern const infoset emptyset;\ninfoset merge(const infoset&a,const infoset&b);\nvoid report(infoset p);\nvoid init(int id,int n,int q,vector<int>dad,vector<infoset>ve);\nvoid modify(int x,int y);\nvoid ask(int x,int y);\n```\n***\n\n伟大的科学家欣准备建造强人工智能隆统治世界。在输入一些越南的算法竞赛题作为训练集后，她发现隆自动生成了一个新的问题，并给出了一份解答。同时隆还将测试集中30%的输入数据归约到了这个问题。\n欣连忙将这个问题抄录如下：\n给定一棵有根树，你需要支持两种操作\n\n* 查询树链元素和\n* 将一个点的父亲改成另一个点\n\n“这个问题并不强啊，为什么能解决测试集中30%的问题呢？”欣心里想。\n在关闭训练结果页面前，欣突然发现，隆给出的这个问题中，信息合并的代价并不是 $O(1)$ 的。\n欣陷入了沉思，发现自己并不会这道题。\n为了知道这题有多难，欣将这题放到了您的面前。", "description": "你需要维护一棵以 $1$ 为根的有根树。这棵树有 $n$ 个点。初始时对于所有 $2 \\le i \\le n$，点 $i$ 有个父亲 $p_i$，保证 $p_i \\lt i$。\n\n一开始你有 $n$ 个集合 $\\{1\\},\\{2\\},\\cdots,\\{n\\}  $。对于任意两个集合 $A$ 和 $B$，如果 $A \\cap B=\\empty$，那么你可以通过一次操作，消耗 $|A|+|B|$ 的代价，获得集合 $A \\cup B$。\n\n之后有 $q$ 次操作。每次操作有两种类型\n\n* `0 a b` 记树上 $a$ 到 $b$ 之间的路径上的点构成的点集为 $S$。你需要将 $S$ 表示为 $\\cup_{i=1}^{k}A_i$，需要满足 $A_i$ 是你已经获得的集合，且 $\\forall i \\neq j,A_i \\cap A_j=\\empty$。用 $(A_1,A_2,\\cdots,A_k) $ 回答一次询问的代价为 $k$。\n* `1 a b` 表示将点 $a$ 的父亲改为 $b$，保证 $a \\gt 1$，且修改后这 $n$ 个点仍构成一棵树，但不保证 $a \\gt b$ 。你可以在这次操作中新生成一些集合用以应对之后的询问。\n\n记你整个程序运行过程中消耗的总代价为 $C_1$，单次操作消耗代价最大值为 $C_2$。每个子任务会根据 $C_1,C_2$ 的大小按照一定方式给分。", "inputFormat": "### 实现细节\n\n\n头文件中定义了数据类型 `infoset`，用于存储你获得的集合。\n\n该类型包括成员函数 `size()`，表示集合大小。**头文件还为你提供了表示空集的常量 `emptyset`**。\n\n此外你还可以调用如下函数：\n\n`infoset merge(const infoset&A,const infoset&B);`\n\n* 以一定代价生成一个新集合 $A \\cup B$\n* 注意你可以多次重复生成同一个集合，并且需要多次计入代价\n\n`void report(infoset A);`\n\n* 你仅可以在查询操作过程中调用该函数，表示你需要消耗 $1$ 的代价在最终的并中添加一个集合 $A$\n\n你不需要，也不应该实现主函数。你需要实现如下几个函数：\n\n`void init(int id,int n,int q,vector<int>dad,vector<infoset>ve);`\n\n* 你可以在 $q$ 次操作开始前预处理一些信息\n* 在该函数中消耗的代价不会计入**单次操作消耗代价最大值**，但会计入**整个程序运行过程中消耗的总代价**\n* `id` 表示子任务编号，`n` 表示总点数，`q`表示总操作数\n* `dad` 的大小为  $n-1$，`dad[i]` 表示初始时刻点 $i+2$ 的父亲\n* `ve` 的大小为 $n$，`ve[i]` 表示初始集合 $\\{i+1\\}$\n\n`void modify(int x,int y);`\n\n* 执行一次修改操作，将点 $x$ 的父亲置为点 $y$\n\n`void ask(int x,int y);`\n\n* 执行一次查询操作，询问 $x$ 到 $y$ 的树链信息\n* 你需要调用若干次 `report` 来回答询问，本次询问结束时交互库会检查你汇报的所有集合 $A$ 是否满足条件\n\n评测时，交互库会先调用 `init` 一次，然后调用 `modify` 和 `ask` 总共 $q$ 次。\n\n本题保证树的形态与执行的操作在交互开始之前已经完全确定，不会根据和你的程序的交互过程动态构造，因此题目中的交互操作都是确定性的，你不需要关心这些操作在交互库中的具体实现。\n\n评测时交互库会使用特殊的实现方式，单个 `infoset` 类型的变量会恒定消耗 $8$ 字节内存，请保证你的程序运行过程中没有过多的 `infoset` 类型变量同时存在。\n\n保证在调用次数限制下，交互库运行所需的时间不超过 2s；交互库本身所消耗的内存不超过16MB。", "outputFormat": "### 测试程序方式\n\n下发文件中的 `grader.cpp` 是我们提供的交互库参考实现，最终测试时所用的交互库实现与该参考实现有所不同，因此选手的解法不应该依赖交互库实现。\n\n你需要使用如下命令编译得到可执行程序：\n`g++ grader.cpp long.cpp -o long -static -O2 -std=c++14`\n\n对于编译得到的可执行程序：\n\n- 可执行文件将从标准输入读入以下格式的数据：\n  - 第一行包含一个整数 $id$ ，表示子任务编号\n  - 第二行包含两个整数 $n,q$，表示总点数和总操作数\n  - 第三行包含 $n-1$ 个整数，分别表示第 $2$ 至$n$ 个点的父亲节点编号\n  - 接下来 $q$ 行，每行三个整数 $op,x,y$，描述一次操作。$op=0$ 表示这是一次询问操作，$op=1$ 表示这是一次修改操作\n- 读入完成之后，交互库将调用恰好一次函数 `init` 和 $q$ 次 `modify` 或 `ask` ，用输入的数据测试你的函数。程序正常运行后会输出若干行，每行若干个数表示你对每次询问操作给出的回答；最后一行会包括两个整数 $W_1,W_2$，分别表示你程序运行消耗的总代价和单次操作消耗代价的最大值。\n\n**下发文件中包括四组样例文件，其中第四组样例满足子任务二的特殊性质**。测试样例时请忽略输出文件最后一行的比较情况，因为交互库输出的最后一行为程序运行代价而不是询问操作的查询结果。", "hint": "### 评分方式\n\n**本题首先会受到和传统题相同的限制**。例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制等会导致相应测试点得 $0$ 分等。你只能访问自己定义的和交互库给出的变量及其对应的内存空间，尝试访问其他空间将可能导致编译错误或运行错误。\n\n在上述条件基础上，在一个测试点中，若程序执行了非法的函数调用、没有正常结束运行或询问操作给出了错误回答，该测试点将会获得 $0$ 分。否则，将根据你程序消耗的代价，有两种评分方式：\n\n* 评测方式一：若 $W_1 \\gt 6 \\cdot 10^8$，则该测试点得 $0$ 分；否则该测试点得分为 $\\frac{\\frac{1.5 \\cdot 10^8}{max(W_1,1.5 \\cdot 10^8)} \\cdot 7+3}{10} \\times 该测试点所属子任务分值 $ \n* 评测方式二：若 $W_2 \\gt 2 \\cdot 10^4$，则该测试点得 $0$ 分；否则该测试点得分为 $\\frac{5000}{max(W_2,5000)} \\times 该测试点所属子任务分值$\n\n不同的子任务会使用不同的评测方式。一个子任务的得分为其中所有测试点得分的最小值。\n\n### 限制与约定\n\n保证对于所有测试点均有 $1 \\le n,q \\le 10^5$。\n\n| 子任务编号 | $n,q \\le$ | 特殊性质 | 评测方式 | 分值 |\n| ---------- | --------- | -------- | -------- | ---- |\n| $1$        | $100$     | 无       | 一       | $10$ |\n| $2$        | $10^5$    | 有       | 一       | $20$ |\n| $3$        | $10^5$    | 有       | 二       | $20$ |\n| $4$        | $10^5$    | 无       | 一       | $30$ |\n| $5$        | $10^5$    | 无       | 二       | $20$ |\n\n特殊性质：保证每个时刻除了 $1$ 号节点外每个节点至多只有一个儿子。\n\n### 后记\n\n欣发现您五个小时还是没有做出本题，对隆的能力感到非常满意。然而第二天早上起来后，欣突然发现隆做法的复杂度证明是错的。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CTS2022] 隆", "background": "这是一道交互题。\n\n本地测试需 #include <long.h>\n提交时请采用以下模板，而不 include long.h，具体方法就是直接把这个模板放在自己代码里面，然后需要完善题目中要求的函数。\n\n```cpp\nstruct sethash{\n\tint val;\n\tvoid encode();\n\tvoid decode();\n\tvoid operator=(int x);\n};\nstruct infoset{\n\tsethash sum;\n\tint sz;\n\tint size()const{\n\t\treturn sz;\n\t}\n};\nextern const infoset emptyset;\ninfoset merge(const infoset&a,const infoset&b);\nvoid report(infoset p);\nvoid init(int id,int n,int q,vector<int>dad,vector<infoset>ve);\nvoid modify(int x,int y);\nvoid ask(int x,int y);\n```\n***\n\n伟大的科学家欣准备建造强人工智能隆统治世界。在输入一些越南的算法竞赛题作为训练集后，她发现隆自动生成了一个新的问题，并给出了一份解答。同时隆还将测试集中30%的输入数据归约到了这个问题。\n欣连忙将这个问题抄录如下：\n给定一棵有根树，你需要支持两种操作\n\n* 查询树链元素和\n* 将一个点的父亲改成另一个点\n\n“这个问题并不强啊，为什么能解决测试集中30%的问题呢？”欣心里想。\n在关闭训练结果页面前，欣突然发现，隆给出的这个问题中，信息合并的代价并不是 $O(1)$ 的。\n欣陷入了沉思，发现自己并不会这道题。\n为了知道这题有多难，欣将这题放到了您的面前。", "description": "你需要维护一棵以 $1$ 为根的有根树。这棵树有 $n$ 个点。初始时对于所有 $2 \\le i \\le n$，点 $i$ 有个父亲 $p_i$，保证 $p_i \\lt i$。\n\n一开始你有 $n$ 个集合 $\\{1\\},\\{2\\},\\cdots,\\{n\\}  $。对于任意两个集合 $A$ 和 $B$，如果 $A \\cap B=\\empty$，那么你可以通过一次操作，消耗 $|A|+|B|$ 的代价，获得集合 $A \\cup B$。\n\n之后有 $q$ 次操作。每次操作有两种类型\n\n* `0 a b` 记树上 $a$ 到 $b$ 之间的路径上的点构成的点集为 $S$。你需要将 $S$ 表示为 $\\cup_{i=1}^{k}A_i$，需要满足 $A_i$ 是你已经获得的集合，且 $\\forall i \\neq j,A_i \\cap A_j=\\empty$。用 $(A_1,A_2,\\cdots,A_k) $ 回答一次询问的代价为 $k$。\n* `1 a b` 表示将点 $a$ 的父亲改为 $b$，保证 $a \\gt 1$，且修改后这 $n$ 个点仍构成一棵树，但不保证 $a \\gt b$ 。你可以在这次操作中新生成一些集合用以应对之后的询问。\n\n记你整个程序运行过程中消耗的总代价为 $C_1$，单次操作消耗代价最大值为 $C_2$。每个子任务会根据 $C_1,C_2$ 的大小按照一定方式给分。", "inputFormat": "### 实现细节\n\n\n头文件中定义了数据类型 `infoset`，用于存储你获得的集合。\n\n该类型包括成员函数 `size()`，表示集合大小。**头文件还为你提供了表示空集的常量 `emptyset`**。\n\n此外你还可以调用如下函数：\n\n`infoset merge(const infoset&A,const infoset&B);`\n\n* 以一定代价生成一个新集合 $A \\cup B$\n* 注意你可以多次重复生成同一个集合，并且需要多次计入代价\n\n`void report(infoset A);`\n\n* 你仅可以在查询操作过程中调用该函数，表示你需要消耗 $1$ 的代价在最终的并中添加一个集合 $A$\n\n你不需要，也不应该实现主函数。你需要实现如下几个函数：\n\n`void init(int id,int n,int q,vector<int>dad,vector<infoset>ve);`\n\n* 你可以在 $q$ 次操作开始前预处理一些信息\n* 在该函数中消耗的代价不会计入**单次操作消耗代价最大值**，但会计入**整个程序运行过程中消耗的总代价**\n* `id` 表示子任务编号，`n` 表示总点数，`q`表示总操作数\n* `dad` 的大小为  $n-1$，`dad[i]` 表示初始时刻点 $i+2$ 的父亲\n* `ve` 的大小为 $n$，`ve[i]` 表示初始集合 $\\{i+1\\}$\n\n`void modify(int x,int y);`\n\n* 执行一次修改操作，将点 $x$ 的父亲置为点 $y$\n\n`void ask(int x,int y);`\n\n* 执行一次查询操作，询问 $x$ 到 $y$ 的树链信息\n* 你需要调用若干次 `report` 来回答询问，本次询问结束时交互库会检查你汇报的所有集合 $A$ 是否满足条件\n\n评测时，交互库会先调用 `init` 一次，然后调用 `modify` 和 `ask` 总共 $q$ 次。\n\n本题保证树的形态与执行的操作在交互开始之前已经完全确定，不会根据和你的程序的交互过程动态构造，因此题目中的交互操作都是确定性的，你不需要关心这些操作在交互库中的具体实现。\n\n评测时交互库会使用特殊的实现方式，单个 `infoset` 类型的变量会恒定消耗 $8$ 字节内存，请保证你的程序运行过程中没有过多的 `infoset` 类型变量同时存在。\n\n保证在调用次数限制下，交互库运行所需的时间不超过 2s；交互库本身所消耗的内存不超过16MB。", "outputFormat": "### 测试程序方式\n\n下发文件中的 `grader.cpp` 是我们提供的交互库参考实现，最终测试时所用的交互库实现与该参考实现有所不同，因此选手的解法不应该依赖交互库实现。\n\n你需要使用如下命令编译得到可执行程序：\n`g++ grader.cpp long.cpp -o long -static -O2 -std=c++14`\n\n对于编译得到的可执行程序：\n\n- 可执行文件将从标准输入读入以下格式的数据：\n  - 第一行包含一个整数 $id$ ，表示子任务编号\n  - 第二行包含两个整数 $n,q$，表示总点数和总操作数\n  - 第三行包含 $n-1$ 个整数，分别表示第 $2$ 至$n$ 个点的父亲节点编号\n  - 接下来 $q$ 行，每行三个整数 $op,x,y$，描述一次操作。$op=0$ 表示这是一次询问操作，$op=1$ 表示这是一次修改操作\n- 读入完成之后，交互库将调用恰好一次函数 `init` 和 $q$ 次 `modify` 或 `ask` ，用输入的数据测试你的函数。程序正常运行后会输出若干行，每行若干个数表示你对每次询问操作给出的回答；最后一行会包括两个整数 $W_1,W_2$，分别表示你程序运行消耗的总代价和单次操作消耗代价的最大值。\n\n**下发文件中包括四组样例文件，其中第四组样例满足子任务二的特殊性质**。测试样例时请忽略输出文件最后一行的比较情况，因为交互库输出的最后一行为程序运行代价而不是询问操作的查询结果。", "hint": "### 评分方式\n\n**本题首先会受到和传统题相同的限制**。例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制等会导致相应测试点得 $0$ 分等。你只能访问自己定义的和交互库给出的变量及其对应的内存空间，尝试访问其他空间将可能导致编译错误或运行错误。\n\n在上述条件基础上，在一个测试点中，若程序执行了非法的函数调用、没有正常结束运行或询问操作给出了错误回答，该测试点将会获得 $0$ 分。否则，将根据你程序消耗的代价，有两种评分方式：\n\n* 评测方式一：若 $W_1 \\gt 6 \\cdot 10^8$，则该测试点得 $0$ 分；否则该测试点得分为 $\\frac{\\frac{1.5 \\cdot 10^8}{max(W_1,1.5 \\cdot 10^8)} \\cdot 7+3}{10} \\times 该测试点所属子任务分值 $ \n* 评测方式二：若 $W_2 \\gt 2 \\cdot 10^4$，则该测试点得 $0$ 分；否则该测试点得分为 $\\frac{5000}{max(W_2,5000)} \\times 该测试点所属子任务分值$\n\n不同的子任务会使用不同的评测方式。一个子任务的得分为其中所有测试点得分的最小值。\n\n### 限制与约定\n\n保证对于所有测试点均有 $1 \\le n,q \\le 10^5$。\n\n| 子任务编号 | $n,q \\le$ | 特殊性质 | 评测方式 | 分值 |\n| ---------- | --------- | -------- | -------- | ---- |\n| $1$        | $100$     | 无       | 一       | $10$ |\n| $2$        | $10^5$    | 有       | 一       | $20$ |\n| $3$        | $10^5$    | 有       | 二       | $20$ |\n| $4$        | $10^5$    | 无       | 一       | $30$ |\n| $5$        | $10^5$    | 无       | 二       | $20$ |\n\n特殊性质：保证每个时刻除了 $1$ 号节点外每个节点至多只有一个儿子。\n\n### 后记\n\n欣发现您五个小时还是没有做出本题，对隆的能力感到非常满意。然而第二天早上起来后，欣突然发现隆做法的复杂度证明是错的。", "locale": "zh-CN"}}}
{"pid": "P8263", "type": "P", "difficulty": 6, "samples": [["11\n11011100010\n5\n3 2 3\n2 6 8 5\n1 2 5 3\n4 8\n4 100", "10\n-1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "O2优化", "Ynoi"], "title": "[Ynoi Easy Round 2020] TEST_8", "background": "", "description": "给出一个长度为 $n$ 的 $01$ 串 $S$（一个由 $0$ 和 $1$ 组成的序列，下标为 $1$ 到 $n$ 的整数）。\n\n支持以下几种操作：\n\n操作1：给出 $l,r,k$，将 $01$ 串下标为 $l$ 到 $r$ 的一段重复 $k$ 次并放回原位；\n\n操作2：给出 $l,r,k$，将 $01$ 串下标为 $l$ 到 $r$ 的一段带翻转地重复 $k$ 次（具体地说，第 $i$（$1\\leq i\\leq k$）次重复时，若 $i-1$ 的二进制表示中有奇数个 $1$，则这次重复时要左右反转，否则不变），最后放回原位；\n\n操作3：给出 $l,r$，将 $01$ 串下标为 $l$ 到 $r$ 的一段删除；\n\n操作4：给出 $k$，求 $01$ 串中从左到右第 $k$ 个 $1$ 的位置，若 $k$ 超过 $01$ 串中 $1$ 的个数，则输出 $-1$。\n\n", "inputFormat": "第一行一个整数 $n$。\n\n接下来一行，一个长度为 $n$ 的 $01$ 串。\n\n接下来一行，一个整数 $m$。\n\n接下来 $m$ 行，每行第一个整数 $op$ 表示操作类型。\n\n若 $op=1$ 或 $op=2$，这一行接下来有三个整数 $l,r,k$。\n\n若 $op=3$，这一行接下来有两个整数 $l,r$。\n\n若 $op=4$，这一行接下来有一个整数 $k$。", "outputFormat": "对每个操作4，输出一行，表示答案。", "hint": "Idea：ccz181078，Solution：ccz181078，Code：ccz181078，Data：ccz181078\n\n保证$1\\leq l\\leq r\\leq $ $01$串在操作前的长度；\n\n在操作 $1,2,4$ 中，$1\\leq k\\leq 10^8$。\n\n对于 $20\\%$ 的数据，$n,m$ 以及 $01$ 串的长度始终不超过 $20$；\n\n对于 $40\\%$ 的数据，只有一次操作4，且没有操作2。\n\n对于 $100\\%$ 的数据，$1\\leq n,m\\leq 10^5$，$01$ 串的长度始终不超过 $10^8$；\n\n样例解释：\n\n第1次操作：1[10]11100010->111100010，删除了10、\n\n第2次操作：11110[001]0->11110[001,100,100,001,100]0->111100011001000011000，将001重复了5次，其中第2,3,5次是翻转的、\n\n第3次操作：1[1110]0011001000011000->1[1110,1110,1110]0011001000011000->11110111011100011001000011000，将1110重复了3次、\n\n第4次操作：111101110[1]1100011001000011000，第8个1在01串中的第10个位置、\n\n第5次操作：不存在100个1，输出-1、", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi Easy Round 2020] TEST_8", "background": "", "description": "给出一个长度为 $n$ 的 $01$ 串 $S$（一个由 $0$ 和 $1$ 组成的序列，下标为 $1$ 到 $n$ 的整数）。\n\n支持以下几种操作：\n\n操作1：给出 $l,r,k$，将 $01$ 串下标为 $l$ 到 $r$ 的一段重复 $k$ 次并放回原位；\n\n操作2：给出 $l,r,k$，将 $01$ 串下标为 $l$ 到 $r$ 的一段带翻转地重复 $k$ 次（具体地说，第 $i$（$1\\leq i\\leq k$）次重复时，若 $i-1$ 的二进制表示中有奇数个 $1$，则这次重复时要左右反转，否则不变），最后放回原位；\n\n操作3：给出 $l,r$，将 $01$ 串下标为 $l$ 到 $r$ 的一段删除；\n\n操作4：给出 $k$，求 $01$ 串中从左到右第 $k$ 个 $1$ 的位置，若 $k$ 超过 $01$ 串中 $1$ 的个数，则输出 $-1$。\n\n", "inputFormat": "第一行一个整数 $n$。\n\n接下来一行，一个长度为 $n$ 的 $01$ 串。\n\n接下来一行，一个整数 $m$。\n\n接下来 $m$ 行，每行第一个整数 $op$ 表示操作类型。\n\n若 $op=1$ 或 $op=2$，这一行接下来有三个整数 $l,r,k$。\n\n若 $op=3$，这一行接下来有两个整数 $l,r$。\n\n若 $op=4$，这一行接下来有一个整数 $k$。", "outputFormat": "对每个操作4，输出一行，表示答案。", "hint": "Idea：ccz181078，Solution：ccz181078，Code：ccz181078，Data：ccz181078\n\n保证$1\\leq l\\leq r\\leq $ $01$串在操作前的长度；\n\n在操作 $1,2,4$ 中，$1\\leq k\\leq 10^8$。\n\n对于 $20\\%$ 的数据，$n,m$ 以及 $01$ 串的长度始终不超过 $20$；\n\n对于 $40\\%$ 的数据，只有一次操作4，且没有操作2。\n\n对于 $100\\%$ 的数据，$1\\leq n,m\\leq 10^5$，$01$ 串的长度始终不超过 $10^8$；\n\n样例解释：\n\n第1次操作：1[10]11100010->111100010，删除了10、\n\n第2次操作：11110[001]0->11110[001,100,100,001,100]0->111100011001000011000，将001重复了5次，其中第2,3,5次是翻转的、\n\n第3次操作：1[1110]0011001000011000->1[1110,1110,1110]0011001000011000->11110111011100011001000011000，将1110重复了3次、\n\n第4次操作：111101110[1]1100011001000011000，第8个1在01串中的第10个位置、\n\n第5次操作：不存在100个1，输出-1、", "locale": "zh-CN"}}}
{"pid": "P8264", "type": "P", "difficulty": 6, "samples": [["5 5\n4 5 2 5 3\n3 5 3\n3 3 0\n5 0 6\n5 0 5\n6 0 4", "1\n4\n4\n5\n1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2020", "O2优化", "Ynoi"], "title": "[Ynoi Easy Round 2020] TEST_100", "background": "", "description": "给定一个长为 $n$ 的序列 $a$，每个位置是一个变换 $x=|x-a_i|$，每次查询给出一个区间 $[l,r]$ 和一个值 $v$，依次令 $i$ 从 $l$ 到 $r$ ，访问每个元素 $a_i$，将 $v$ 变为 $|v-a_i|$，求结束后的 $v$ 的值。", "inputFormat": "第一行两个数 $n,m$。\n\n第二行 $n$ 个用空格隔开的数表示序列 $a$。\n\n之后 $m$ 行，每行三个用空格隔开的数 $l,r,v$ 表示一次询问。\n\n本题强制在线，所有输入的 $l,r,v$ 均需要异或上次询问的答案，若之前没有询问操作，则为 $0$。", "outputFormat": "对每个询问操作，输出一行一个数表示答案。", "hint": "Idea：nzhtl1477，Solution：nzhtl1477&ccz181078，Code：nzhtl1477，Data：nzhtl1477&\t\nFutaRimeWoawaSete\n\n样例解释：\n\n第一次询问中，$3$ 依次经过值为 $2,5,3$ 的变化，变为 $1,4,1$，答案为 $1$。\n\n经过解密，第二次询问为区间 $[2,2]$，值为 $1$。\n\n第二次询问中，$1$ 依次经过值为 $5$ 的变化，变为 $4$，答案为 $4$。\n\n经过解密，第三次询问为区间 $[1,4]$，值为 $2$。\n\n第三次询问中，$2$ 依次经过值为 $4,5,2,5$ 的变化，变为 $2,3,1,4$，答案为 $4$。\n\n经过解密，第四次询问为区间 $[1,4]$，值为 $1$。\n\n第四次询问中，$1$ 依次经过值为 $4,5,2,5$ 的变化，变为 $3,2,0,5$，答案为 $5$。\n\n经过解密，第五次询问为区间 $[3,5]$，值为 $1$。\n\n第五次询问中，$1$ 依次经过值为 $2,5,3$ 的变化，变为 $1,4,1$，答案为 $1$。\n\n数据范围：\n\n对于 $100\\%$ 的数据 $1\\le n,m,a_i,v \\le10^5$，$1\\le l,r\\le n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi Easy Round 2020] TEST_100", "background": "", "description": "给定一个长为 $n$ 的序列 $a$，每个位置是一个变换 $x=|x-a_i|$，每次查询给出一个区间 $[l,r]$ 和一个值 $v$，依次令 $i$ 从 $l$ 到 $r$ ，访问每个元素 $a_i$，将 $v$ 变为 $|v-a_i|$，求结束后的 $v$ 的值。", "inputFormat": "第一行两个数 $n,m$。\n\n第二行 $n$ 个用空格隔开的数表示序列 $a$。\n\n之后 $m$ 行，每行三个用空格隔开的数 $l,r,v$ 表示一次询问。\n\n本题强制在线，所有输入的 $l,r,v$ 均需要异或上次询问的答案，若之前没有询问操作，则为 $0$。", "outputFormat": "对每个询问操作，输出一行一个数表示答案。", "hint": "Idea：nzhtl1477，Solution：nzhtl1477&ccz181078，Code：nzhtl1477，Data：nzhtl1477&\t\nFutaRimeWoawaSete\n\n样例解释：\n\n第一次询问中，$3$ 依次经过值为 $2,5,3$ 的变化，变为 $1,4,1$，答案为 $1$。\n\n经过解密，第二次询问为区间 $[2,2]$，值为 $1$。\n\n第二次询问中，$1$ 依次经过值为 $5$ 的变化，变为 $4$，答案为 $4$。\n\n经过解密，第三次询问为区间 $[1,4]$，值为 $2$。\n\n第三次询问中，$2$ 依次经过值为 $4,5,2,5$ 的变化，变为 $2,3,1,4$，答案为 $4$。\n\n经过解密，第四次询问为区间 $[1,4]$，值为 $1$。\n\n第四次询问中，$1$ 依次经过值为 $4,5,2,5$ 的变化，变为 $3,2,0,5$，答案为 $5$。\n\n经过解密，第五次询问为区间 $[3,5]$，值为 $1$。\n\n第五次询问中，$1$ 依次经过值为 $2,5,3$ 的变化，变为 $1,4,1$，答案为 $1$。\n\n数据范围：\n\n对于 $100\\%$ 的数据 $1\\le n,m,a_i,v \\le10^5$，$1\\le l,r\\le n$。", "locale": "zh-CN"}}}
{"pid": "P8265", "type": "P", "difficulty": 7, "samples": [["5 10\n1 4 2 5\n1 1 4 2\n1 2 5 3\n0 4 2 3\n1 4 3 4\n1 1 5 3\n0 1 5 4\n0 5 2 4\n0 1 4 1\n1 5 2 3\n", "1\n5\n2\n7\n7\n6\n7\n2\n1\n7\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "O2优化", "Ynoi"], "title": "[Ynoi Easy Round 2020] TEST_63", "background": "", "description": "给定一棵包含 $n$ 个点的由有根树构成的森林（初始没有边，每个顶点是一棵有根树的根），顶点由 $1$ 到 $n$ 的整数编号表示。\n你需要维护森林的轻重链剖分结构，具体如下：\n\n对每个顶点 $w\\;(1\\le w\\le n)$，记其孩子构成的集合为 $\\mathrm{children}(w)$，对 $w$ 若 $w$ 不是根则记其父亲为 $\\mathrm{father}(w)$；\n\n一个顶点 $w$ 的子树规模 $\\mathrm{size(w)}$ 定义为 $1+\\sum\\limits_{u\\in\\mathrm{children}(w)}\\mathrm{size(u)}$；\n\n一个顶点 $w$ 如果不是叶子（即 $\\mathrm{children}(w)\\ne\\varnothing$），则它的重孩子 $\\mathrm{hc}(w)$ 被定义为 $\\mathrm{arg}\\max_{u\\in\\mathrm{children}(w)}size(u)\\cdot n+\\max(u,\\mathrm{hc}(u),\\mathrm{hc}(\\mathrm{hc}(u)),\\dots)$，即子树规模最大的孩子（若有多个孩子 $u$ 的子树规模相同则取以 $u$ 为根的子树中，$u$ 所在重链中最大的编号最大）；\n\n重链是一个由顶点构成的序列 $w_1,w_2,\\dots,w_k\\;(k>0)$，满足条件：\n\n- $w_1$ 是根或 $w_1\\ne \\mathrm{hc}(\\mathrm{father}(w_1))$\n- $w_i=\\mathrm{hc}(w_{i-1})\\;(2\\le i\\le k)$\n\n对一棵树，每个顶点恰好属于一条重链。\n重链的权值为 $w_1\\oplus w_2\\oplus\\dots\\oplus w_k$，即序列中顶点编号的按位异或和。\n\n需要依次进行 $2m$ 次操作，操作类型如下：\n\n- 加边：给出两个顶点 $a,b$，令 $b$ 成为 $b$ 所在有根树的根（设顶点构成的序列 $t_1,t_2,\\dots,t_l$ 满足 $t_l=b$，且 $t_1$ 为根，$(t_i,t_{i+1}),\\;1\\le i<l$ 是 $b$ 所在有根树上的有向边，将这些边的方向反转为 $(t_{i+1},t_i)$ 即可令 $b$ 成为根），然后加入 $a$ 到 $b$ 的有向边 $(a,b)$，保证操作前 $a,b$ 在不同的有根树上；\n- 删边：给出两个顶点 $a,b$，删除 $a,b$ 间的有向边（可能为 $(a,b)$ 或 $(b,a)$ ），保证这条边之前存在；\n- 查询：给出一个整数 $k$，设当前共有 $N$ 条重链，询问将当前存在的所有重链按权值从小到大排序后，第 $((k-1) \\mod N)+1$ 小的权值。", "inputFormat": "第 $1$ 行有两个整数 `n m` ；\n\n接下来 $m$ 行，每行四个整数 `o a b k` ，若 $o=1$ 则表示先加边 $a,b$，然后查询 $k$，若 $o=0$ 则表示先删边 $a,b$，然后查询 $k$。", "outputFormat": "共 $m$ 行，每行一个整数，依次为每次查询操作的结果。", "hint": "Idea：nzhtl1477，Solution：ccz181078，Code：ccz181078，Data：ccz181078\n\n本题采用子任务评测。\n\n共 $31$ 个测试点，所有测试点满足 $1\\le n\\le 10^5$，$1\\le m\\le 5\\times 10^5$，$0\\le o\\le 1$，$1\\le a\\le n$，$1\\le b \\le n$，$1\\le k\\le n$，$n,m,o,a,b,k$ 均为整数；\n\n测试点可能具有以下性质：\n\n- 性质1：操作使用以下策略随机生成，重复直到生成了 $m$ 行的操作序列：\n\n- 在 $[1,n]$ 中等概率选取三个整数 $x,y,k$，若 $x,y$ 在不同的有根树上，则生成一行 `1 x y k`，否则若 $x$ 不是根，等概率地生成一行 `0 x father(x) k` 或 `0 father(x) x k` 之一，否则不进行操作。\n\n- 性质2：$m=n-1$，且对 $2\\le i\\le n$，数据的第 $i$ 行为 `1 a i k`，其中 $a$ 在 $[1,i-1]$ 中的整数等概率选取；\n- 性质3：$m=n-1$，且对 $2\\le i\\le n$，数据的第 $i$ 行为 `1 i b k`，其中 $b$ 在 $[1,i-1]$ 中的整数等概率选取；\n- 其它对 $n,m$ 的限制。\n\n每个测试点的性质如下：\n\n第1个测试点，$n=10,\\;m=50$，满足性质1，共10分；\n\n第2个测试点，$n=100,\\;m=500$，满足性质1，共10分；\n\n第3个测试点，$n=1000,\\;m=5000$，满足性质1，共10分；\n\n第4个测试点，满足性质2，共15分；\n\n第5个测试点，满足性质3，共15分；\n\n第6~10个测试点，满足性质1，共20分；\n\n第11~31个测试点没有特殊限制，共20分。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi Easy Round 2020] TEST_63", "background": "", "description": "给定一棵包含 $n$ 个点的由有根树构成的森林（初始没有边，每个顶点是一棵有根树的根），顶点由 $1$ 到 $n$ 的整数编号表示。\n你需要维护森林的轻重链剖分结构，具体如下：\n\n对每个顶点 $w\\;(1\\le w\\le n)$，记其孩子构成的集合为 $\\mathrm{children}(w)$，对 $w$ 若 $w$ 不是根则记其父亲为 $\\mathrm{father}(w)$；\n\n一个顶点 $w$ 的子树规模 $\\mathrm{size(w)}$ 定义为 $1+\\sum\\limits_{u\\in\\mathrm{children}(w)}\\mathrm{size(u)}$；\n\n一个顶点 $w$ 如果不是叶子（即 $\\mathrm{children}(w)\\ne\\varnothing$），则它的重孩子 $\\mathrm{hc}(w)$ 被定义为 $\\mathrm{arg}\\max_{u\\in\\mathrm{children}(w)}size(u)\\cdot n+\\max(u,\\mathrm{hc}(u),\\mathrm{hc}(\\mathrm{hc}(u)),\\dots)$，即子树规模最大的孩子（若有多个孩子 $u$ 的子树规模相同则取以 $u$ 为根的子树中，$u$ 所在重链中最大的编号最大）；\n\n重链是一个由顶点构成的序列 $w_1,w_2,\\dots,w_k\\;(k>0)$，满足条件：\n\n- $w_1$ 是根或 $w_1\\ne \\mathrm{hc}(\\mathrm{father}(w_1))$\n- $w_i=\\mathrm{hc}(w_{i-1})\\;(2\\le i\\le k)$\n\n对一棵树，每个顶点恰好属于一条重链。\n重链的权值为 $w_1\\oplus w_2\\oplus\\dots\\oplus w_k$，即序列中顶点编号的按位异或和。\n\n需要依次进行 $2m$ 次操作，操作类型如下：\n\n- 加边：给出两个顶点 $a,b$，令 $b$ 成为 $b$ 所在有根树的根（设顶点构成的序列 $t_1,t_2,\\dots,t_l$ 满足 $t_l=b$，且 $t_1$ 为根，$(t_i,t_{i+1}),\\;1\\le i<l$ 是 $b$ 所在有根树上的有向边，将这些边的方向反转为 $(t_{i+1},t_i)$ 即可令 $b$ 成为根），然后加入 $a$ 到 $b$ 的有向边 $(a,b)$，保证操作前 $a,b$ 在不同的有根树上；\n- 删边：给出两个顶点 $a,b$，删除 $a,b$ 间的有向边（可能为 $(a,b)$ 或 $(b,a)$ ），保证这条边之前存在；\n- 查询：给出一个整数 $k$，设当前共有 $N$ 条重链，询问将当前存在的所有重链按权值从小到大排序后，第 $((k-1) \\mod N)+1$ 小的权值。", "inputFormat": "第 $1$ 行有两个整数 `n m` ；\n\n接下来 $m$ 行，每行四个整数 `o a b k` ，若 $o=1$ 则表示先加边 $a,b$，然后查询 $k$，若 $o=0$ 则表示先删边 $a,b$，然后查询 $k$。", "outputFormat": "共 $m$ 行，每行一个整数，依次为每次查询操作的结果。", "hint": "Idea：nzhtl1477，Solution：ccz181078，Code：ccz181078，Data：ccz181078\n\n本题采用子任务评测。\n\n共 $31$ 个测试点，所有测试点满足 $1\\le n\\le 10^5$，$1\\le m\\le 5\\times 10^5$，$0\\le o\\le 1$，$1\\le a\\le n$，$1\\le b \\le n$，$1\\le k\\le n$，$n,m,o,a,b,k$ 均为整数；\n\n测试点可能具有以下性质：\n\n- 性质1：操作使用以下策略随机生成，重复直到生成了 $m$ 行的操作序列：\n\n- 在 $[1,n]$ 中等概率选取三个整数 $x,y,k$，若 $x,y$ 在不同的有根树上，则生成一行 `1 x y k`，否则若 $x$ 不是根，等概率地生成一行 `0 x father(x) k` 或 `0 father(x) x k` 之一，否则不进行操作。\n\n- 性质2：$m=n-1$，且对 $2\\le i\\le n$，数据的第 $i$ 行为 `1 a i k`，其中 $a$ 在 $[1,i-1]$ 中的整数等概率选取；\n- 性质3：$m=n-1$，且对 $2\\le i\\le n$，数据的第 $i$ 行为 `1 i b k`，其中 $b$ 在 $[1,i-1]$ 中的整数等概率选取；\n- 其它对 $n,m$ 的限制。\n\n每个测试点的性质如下：\n\n第1个测试点，$n=10,\\;m=50$，满足性质1，共10分；\n\n第2个测试点，$n=100,\\;m=500$，满足性质1，共10分；\n\n第3个测试点，$n=1000,\\;m=5000$，满足性质1，共10分；\n\n第4个测试点，满足性质2，共15分；\n\n第5个测试点，满足性质3，共15分；\n\n第6~10个测试点，满足性质1，共20分；\n\n第11~31个测试点没有特殊限制，共20分。", "locale": "zh-CN"}}}
{"pid": "P8266", "type": "P", "difficulty": 4, "samples": [["14\nGGGHGHHGHHHGHG", "1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "USACO", "2022"], "title": "[USACO22OPEN] Photoshoot B", "background": "", "description": "迫切希望在郡县集市上赢得最佳奶牛摄影师的 Farmer John 正在尝试为他的 $N$ 头奶牛拍摄一张完美的照片（$2 \\leq N \\leq 2\\cdot 10^5$，$N$ 为偶数）。\n\nFarmer John 拥有两种品种的奶牛：更赛牛（Guernsey）和荷斯坦牛（Holstein）。为了使他的照片尽可能地艺术，他想把他的奶牛排成一排，使得尽可能多的更赛牛处于队列中的偶数位置（队列中的第一个位置是奇数位置，下一个是偶数位置，以此类推）。由于他与他的奶牛缺乏有效的沟通，他可以达到目的的唯一方法是让他的奶牛的偶数长的「前缀」进行反转（一个前缀指的是对于某个位置 $j$，从第一头奶牛到第 $j$ 头奶牛范围内的所有奶牛）。\n\n请计算 Farmer John 达到目的所需要的最小反转次数。\n", "inputFormat": "输入的第一行包含 $N$ 的值。\n\n第二行包含一个长为 $N$ 的字符串，给出初始时所有奶牛从左到右的排列方式。每个 'H' 代表一头荷斯坦牛，每个 'G' 代表一头更赛牛。", "outputFormat": "输出一行，包含达到目的所需要的最小反转次数。", "hint": "【样例解释】\n\n在这个例子中，只需反转由前六头奶牛组成的前缀即可。\n```\n   GGGHGHHGHHHGHG （反转前）\n-> HGHGGGHGHHHGHG （反转后）\n```\n在反转之前，四头更赛牛处于偶数位置。反转后，六头更赛牛处于偶数位置。不可能使得超过六头更赛牛处于偶数位置。\n\n【测试点性质】\n\n- 测试点 2-6 满足 $N\\le 1000$。\n- 测试点 7-11 没有额外限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO22OPEN] Photoshoot B", "background": "", "description": "迫切希望在郡县集市上赢得最佳奶牛摄影师的 Farmer John 正在尝试为他的 $N$ 头奶牛拍摄一张完美的照片（$2 \\leq N \\leq 2\\cdot 10^5$，$N$ 为偶数）。\n\nFarmer John 拥有两种品种的奶牛：更赛牛（Guernsey）和荷斯坦牛（Holstein）。为了使他的照片尽可能地艺术，他想把他的奶牛排成一排，使得尽可能多的更赛牛处于队列中的偶数位置（队列中的第一个位置是奇数位置，下一个是偶数位置，以此类推）。由于他与他的奶牛缺乏有效的沟通，他可以达到目的的唯一方法是让他的奶牛的偶数长的「前缀」进行反转（一个前缀指的是对于某个位置 $j$，从第一头奶牛到第 $j$ 头奶牛范围内的所有奶牛）。\n\n请计算 Farmer John 达到目的所需要的最小反转次数。\n", "inputFormat": "输入的第一行包含 $N$ 的值。\n\n第二行包含一个长为 $N$ 的字符串，给出初始时所有奶牛从左到右的排列方式。每个 'H' 代表一头荷斯坦牛，每个 'G' 代表一头更赛牛。", "outputFormat": "输出一行，包含达到目的所需要的最小反转次数。", "hint": "【样例解释】\n\n在这个例子中，只需反转由前六头奶牛组成的前缀即可。\n```\n   GGGHGHHGHHHGHG （反转前）\n-> HGHGGGHGHHHGHG （反转后）\n```\n在反转之前，四头更赛牛处于偶数位置。反转后，六头更赛牛处于偶数位置。不可能使得超过六头更赛牛处于偶数位置。\n\n【测试点性质】\n\n- 测试点 2-6 满足 $N\\le 1000$。\n- 测试点 7-11 没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P8267", "type": "P", "difficulty": 2, "samples": [["2\nG 3\nL 5", "0"], ["2\nG 3\nL 2", "1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "USACO", "2022", "排序"], "title": "[USACO22OPEN] Counting Liars B", "background": "", "description": "奶牛 Bessie 躲在数轴上的某处。Farmer John 的 $N$ 头奶牛（$1\\le N\\le 1000$）中的每头奶牛都有一条信息要分享：第 $i$ 头奶牛说 Bessie 躲在小于或等于 $p_i$ 的某个位置，或者说 Bessie 躲在大于或等于 $p_i$ 的某个位置（$0\\le p_i\\le 10^9$）。\n\n不幸的是，可能不存在躲藏位置与所有奶牛的回答均一致，这意味着并非所有奶牛都在说真话。计算在撒谎的奶牛的最小数量。", "inputFormat": "输入的第一行包含 $N$。\n\n以下 $N$ 行每行包含字符 L 或 G，之后是一个整数 $p_i$。L 表示第 $i$ 头奶牛说 Bessie 的躲藏位置小于或等于 $p_i$，而 G 表示第 $i$ 头奶牛说 Bessie 的躲藏位置大于或等于 $p_i$。", "outputFormat": "输出在撒谎的奶牛的最小数量。", "hint": "【样例解释 1】\n\n有可能没有奶牛在撒谎。\n\n【样例解释 2】\n\n至少一头奶牛在撒谎。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO22OPEN] Counting Liars B", "background": "", "description": "奶牛 Bessie 躲在数轴上的某处。Farmer John 的 $N$ 头奶牛（$1\\le N\\le 1000$）中的每头奶牛都有一条信息要分享：第 $i$ 头奶牛说 Bessie 躲在小于或等于 $p_i$ 的某个位置，或者说 Bessie 躲在大于或等于 $p_i$ 的某个位置（$0\\le p_i\\le 10^9$）。\n\n不幸的是，可能不存在躲藏位置与所有奶牛的回答均一致，这意味着并非所有奶牛都在说真话。计算在撒谎的奶牛的最小数量。", "inputFormat": "输入的第一行包含 $N$。\n\n以下 $N$ 行每行包含字符 L 或 G，之后是一个整数 $p_i$。L 表示第 $i$ 头奶牛说 Bessie 的躲藏位置小于或等于 $p_i$，而 G 表示第 $i$ 头奶牛说 Bessie 的躲藏位置大于或等于 $p_i$。", "outputFormat": "输出在撒谎的奶牛的最小数量。", "hint": "【样例解释 1】\n\n有可能没有奶牛在撒谎。\n\n【样例解释 2】\n\n至少一头奶牛在撒谎。", "locale": "zh-CN"}}}
{"pid": "P8268", "type": "P", "difficulty": 3, "samples": [["5\n2 0 0 1 0\n3\n5 2 3 4\n2 1 1\n3 1 2", "1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["二分", "USACO", "递归", "2022"], "title": "[USACO22OPEN] Alchemy B", "background": "", "description": "总是热衷于培养新的爱好的奶牛 Bessie 正在学习如何转化金属。对于 $1 \\le i \\le N \\le 100$，她有 $a_i$（$0 \\le a_i \\le 10^4$）单位的金属 $i$。此外，她知道 $K$（$1\\le K< N$）个配方，她可以融合若干种金属各一单位，制造一单位编号大于所有被融合金属的金属。另外保证，对于每种金属，Bessie 最多知道一种制造该金属的配方。\n\n计算经过一系列转化后，Bessie 可能拥有的金属 $N$ 的最大单位数。", "inputFormat": "输入的第一行包含 $N$。\n\n第二行包含 $N$ 个整数 $a_i$。\n\n第三行包含 $K$。\n\n以下 $K$ 行每行包含两个整数 $L$ 和 $M$（$M\\ge 1$），随后是 $M$ 个整数。后 $M$ 个整数表示配方中用于制造一单位金属 $L$ 所需要被融合的金属。输入保证 $L$ 大于这 $M$ 个数。", "outputFormat": "输出在应用一系列零次或多次转化后，Bessie 可能拥有的金属 $N$ 的最大单位数。", "hint": "【样例解释】\n\n在这个例子中，以下是一种最优的转化方式：\n\n- 将一单位金属 1 转化为金属 2。\n- 将一单位金属 2 转化为金属 3。\n- 将一单位金属 3 和金属 4 转化为金属 5。\n\n现在 Bessie 还有一单位金属 1 和一单位金属 5。她无法再制造更多的金属 5。\n\n【测试点性质】\n\n- 测试点 2 中，对于 $1\\le i< N$，一单位金属 $i$ 可以被转化为一单位金属 $i+1$；\n\n- 测试点 3-4 中，每个配方均将一单位的一种金属转化为另一种金属；\n\n- 测试点 5-11 没有额外限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO22OPEN] Alchemy B", "background": "", "description": "总是热衷于培养新的爱好的奶牛 Bessie 正在学习如何转化金属。对于 $1 \\le i \\le N \\le 100$，她有 $a_i$（$0 \\le a_i \\le 10^4$）单位的金属 $i$。此外，她知道 $K$（$1\\le K< N$）个配方，她可以融合若干种金属各一单位，制造一单位编号大于所有被融合金属的金属。另外保证，对于每种金属，Bessie 最多知道一种制造该金属的配方。\n\n计算经过一系列转化后，Bessie 可能拥有的金属 $N$ 的最大单位数。", "inputFormat": "输入的第一行包含 $N$。\n\n第二行包含 $N$ 个整数 $a_i$。\n\n第三行包含 $K$。\n\n以下 $K$ 行每行包含两个整数 $L$ 和 $M$（$M\\ge 1$），随后是 $M$ 个整数。后 $M$ 个整数表示配方中用于制造一单位金属 $L$ 所需要被融合的金属。输入保证 $L$ 大于这 $M$ 个数。", "outputFormat": "输出在应用一系列零次或多次转化后，Bessie 可能拥有的金属 $N$ 的最大单位数。", "hint": "【样例解释】\n\n在这个例子中，以下是一种最优的转化方式：\n\n- 将一单位金属 1 转化为金属 2。\n- 将一单位金属 2 转化为金属 3。\n- 将一单位金属 3 和金属 4 转化为金属 5。\n\n现在 Bessie 还有一单位金属 1 和一单位金属 5。她无法再制造更多的金属 5。\n\n【测试点性质】\n\n- 测试点 2 中，对于 $1\\le i< N$，一单位金属 $i$ 可以被转化为一单位金属 $i+1$；\n\n- 测试点 3-4 中，每个配方均将一单位的一种金属转化为另一种金属；\n\n- 测试点 5-11 没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P8269", "type": "P", "difficulty": 4, "samples": [["4\n2 10\n3 20\n4 30\n1 40", "90"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["USACO", "2022", "拓扑排序", "连通块", "强连通分量", "基环树"], "title": "[USACO22OPEN] Visits S", "background": "", "description": "Bessie 的 $N$（$2\\le N\\le 10^5$）个奶牛伙伴（编号为 $1\\cdots N$）每一个都拥有自己的农场。对于每个 $1\\le i\\le N$，伙伴 i 想要访问伙伴 $a_i$（$a_i\\neq i$）。\n\n给定 $1\\ldots N$ 的一个排列 $(p_1,p_2,\\ldots, p_N)$，访问按以下方式发生。\n\n对于 $1$ 到 $N$ 的每一个 $i$：\n\n- 如果伙伴 $a_{p_i}$ 已经离开了她的农场，则伙伴 $p_i$ 仍然留在她的农场。\n- 否则，伙伴 $p_i$ 离开她的农场去访问伙伴 $a_{p_i}$ 的农场。这次访问会产生快乐的哞叫 $v_{p_i}$ 次（$0\\le v_{p_i}\\le 10^9$）。\n\n\n对于所有可能的排列 $p$，计算所有访问结束后可能得到的最大哞叫次数。", "inputFormat": "输入的第一行包含 $N$。\n\n对于每一个 $1\\le i\\le N$，第 $i+1$ 行包含两个空格分隔的整数 $a_i$ 和 $v_i$。", "outputFormat": "输出一个整数，为所求的答案。\n\n**注意这个问题涉及到的整数可能需要使用 64 位整数型（例如，C/C++ 中的 \"long long\"）。**", "hint": "【样例解释】\n\n\n如果 $p=(1,4,3,2)$，则\n\n- 伙伴 $1$ 访问伙伴 $2$ 的农场，产生 $10$ 次哞叫。\n- 伙伴 $4$ 看到伙伴 $1$ 已经离开了农场，所以无事发生。\n- 伙伴 $3$ 访问伙伴 $4$ 的农场，又产生 $30$ 次哞叫。\n- 伙伴 $2$ 看到伙伴 $3$ 已经离开了农场，所以无事发生。\n\n这样总计得到了 $10+30=40$ 次哞叫。\n\n另一方面，如果 $p=(2,3,4,1)$，则\n\n- 伙伴 $2$ 访问伙伴 $3$ 的农场，产生 $20$ 次哞叫。\n- 伙伴 $3$ 访问伙伴 $4$ 的农场，产生 $30$ 次哞叫。\n- 伙伴 $4$ 访问伙伴 $1$ 的农场，产生 $40$ 次哞叫。\n- 伙伴 $1$ 看到伙伴 $2$ 已经离开了农场，所以无事发生。\n\n这样总计得到了 $20+30+40=90$ 次哞叫。可以证明这是所有可能的排列 $p$ 中访问结束后得到的最大可能的哞叫次数。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO22OPEN] Visits S", "background": "", "description": "Bessie 的 $N$（$2\\le N\\le 10^5$）个奶牛伙伴（编号为 $1\\cdots N$）每一个都拥有自己的农场。对于每个 $1\\le i\\le N$，伙伴 i 想要访问伙伴 $a_i$（$a_i\\neq i$）。\n\n给定 $1\\ldots N$ 的一个排列 $(p_1,p_2,\\ldots, p_N)$，访问按以下方式发生。\n\n对于 $1$ 到 $N$ 的每一个 $i$：\n\n- 如果伙伴 $a_{p_i}$ 已经离开了她的农场，则伙伴 $p_i$ 仍然留在她的农场。\n- 否则，伙伴 $p_i$ 离开她的农场去访问伙伴 $a_{p_i}$ 的农场。这次访问会产生快乐的哞叫 $v_{p_i}$ 次（$0\\le v_{p_i}\\le 10^9$）。\n\n\n对于所有可能的排列 $p$，计算所有访问结束后可能得到的最大哞叫次数。", "inputFormat": "输入的第一行包含 $N$。\n\n对于每一个 $1\\le i\\le N$，第 $i+1$ 行包含两个空格分隔的整数 $a_i$ 和 $v_i$。", "outputFormat": "输出一个整数，为所求的答案。\n\n**注意这个问题涉及到的整数可能需要使用 64 位整数型（例如，C/C++ 中的 \"long long\"）。**", "hint": "【样例解释】\n\n\n如果 $p=(1,4,3,2)$，则\n\n- 伙伴 $1$ 访问伙伴 $2$ 的农场，产生 $10$ 次哞叫。\n- 伙伴 $4$ 看到伙伴 $1$ 已经离开了农场，所以无事发生。\n- 伙伴 $3$ 访问伙伴 $4$ 的农场，又产生 $30$ 次哞叫。\n- 伙伴 $2$ 看到伙伴 $3$ 已经离开了农场，所以无事发生。\n\n这样总计得到了 $10+30=40$ 次哞叫。\n\n另一方面，如果 $p=(2,3,4,1)$，则\n\n- 伙伴 $2$ 访问伙伴 $3$ 的农场，产生 $20$ 次哞叫。\n- 伙伴 $3$ 访问伙伴 $4$ 的农场，产生 $30$ 次哞叫。\n- 伙伴 $4$ 访问伙伴 $1$ 的农场，产生 $40$ 次哞叫。\n- 伙伴 $1$ 看到伙伴 $2$ 已经离开了农场，所以无事发生。\n\n这样总计得到了 $20+30+40=90$ 次哞叫。可以证明这是所有可能的排列 $p$ 中访问结束后得到的最大可能的哞叫次数。", "locale": "zh-CN"}}}
{"pid": "P8270", "type": "P", "difficulty": 5, "samples": [["aabcd\ncaabd\n4\na\nac\nabd\nabcd", "YNYN"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["USACO", "2022", "枚举", "Ad-hoc"], "title": "[USACO22OPEN] Subset Equality S", "background": "", "description": "奶牛们正在尝试一种相互交换编码信息的新方法，她们在相关的字母中混入不相关的字母，使信息难以解码。\n\n奶牛们传输两个字符串 $s$ 和 $t$，每个字符串的长度不超过 $10^5$，仅由小写字母 'a' 到 'r' 组成。为了尝试理解这条编码消息，你将被给定 $Q$ 个询问（$1 \\leq Q \\leq 10^5$）。\n\n每个询问给定小写字母 'a' 到 'r' 的一个子集。你需要对每个询问判断 $s$ 和 $t$ 在仅包含询问中给定的字母时是否相等。\n", "inputFormat": "输入的第一行包含 $s$。\n\n第二行包含 $t$。\n\n第三行包含 $Q$。\n\n以下 $Q$ 行每行包含一个询问字符串。在一个询问字符串中，所有字母均不相同。此外，所有询问字符串均已排序，且没有一个询问字符串出现超过一次。", "outputFormat": "对每个询问，如果 $s$ 和 $t$ 在仅包含询问中给定的字母时相等则输出 'Y'，否则输出 'N'。", "hint": "【样例解释】\n\n对于第一个询问，当仅包含字符 'a' 时，两个字符串均变为 \"aa\"。\n\n对于第二个询问，第一个字符串变为 \"aac\" 而第二个字符串变为 \"caa\"。\n\n【测试点性质】\n\n- 测试点 2 满足 $|s|,|t|,Q\\le 1000$。\n- 测试点 3-11 没有额外限制。\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO22OPEN] Subset Equality S", "background": "", "description": "奶牛们正在尝试一种相互交换编码信息的新方法，她们在相关的字母中混入不相关的字母，使信息难以解码。\n\n奶牛们传输两个字符串 $s$ 和 $t$，每个字符串的长度不超过 $10^5$，仅由小写字母 'a' 到 'r' 组成。为了尝试理解这条编码消息，你将被给定 $Q$ 个询问（$1 \\leq Q \\leq 10^5$）。\n\n每个询问给定小写字母 'a' 到 'r' 的一个子集。你需要对每个询问判断 $s$ 和 $t$ 在仅包含询问中给定的字母时是否相等。\n", "inputFormat": "输入的第一行包含 $s$。\n\n第二行包含 $t$。\n\n第三行包含 $Q$。\n\n以下 $Q$ 行每行包含一个询问字符串。在一个询问字符串中，所有字母均不相同。此外，所有询问字符串均已排序，且没有一个询问字符串出现超过一次。", "outputFormat": "对每个询问，如果 $s$ 和 $t$ 在仅包含询问中给定的字母时相等则输出 'Y'，否则输出 'N'。", "hint": "【样例解释】\n\n对于第一个询问，当仅包含字符 'a' 时，两个字符串均变为 \"aa\"。\n\n对于第二个询问，第一个字符串变为 \"aac\" 而第二个字符串变为 \"caa\"。\n\n【测试点性质】\n\n- 测试点 2 满足 $|s|,|t|,Q\\le 1000$。\n- 测试点 3-11 没有额外限制。\n\n", "locale": "zh-CN"}}}
{"pid": "P8271", "type": "P", "difficulty": 4, "samples": [["COW\n6\n1 1\n1 2\n1 3\n2 2\n2 3\n3 3", "YNNNYN"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["USACO", "2022", "前缀和"], "title": "[USACO22OPEN] COW Operations S", "background": "", "description": "Bessie 找到了一个长度不超过 $2 \\cdot 10^5$ 且仅包含字符 'C'，'O' 和 'W' 的字符串 $s$。她想知道是否可以使用以下操作将该字符串变为单个字母 'C'（她最喜欢的字母）：\n\n1. 选择两个相邻相等的字母并将其删除。\n\n2. 选择一个字母，将其替换为另外两个字母的任一排列。\n\n求出这个字符串本身的答案对 Bessie 而言并不足够，所以她想要知道 $s$ 的 $Q$（$1\\le Q\\le 2\\cdot 10^5$）个子串的答案。\n", "inputFormat": "输入的第一行包含 $s$。\n\n第二行包含 $Q$。\n\n以下 $Q$ 行每行包含两个整数 $l$ 和 $r$（$1\\le l\\le r\\le |s|$，其中 $|s|$ 表示 $s$ 的长度）。\n", "outputFormat": "输出一个长为 $Q$ 的字符串，如果第 $i$ 个子串可以被转变则第 $i$ 个字符为 'Y'，否则为 'N'。", "hint": "【样例解释】\n\n第一个询问的答案是「是」，因为 s 的第一个字符已经等于 'C'。\n\n第五个询问的答案是「是」，因为 s 的第二到第三个字符组成的子串 OW 可以通过两步操作变为 'C'：\n\n```\n   OW\n-> CWW\n-> C\n```\n\n这个样例字符串 COW 的其他子串均不能被转变为 'C'。\n\n【测试点性质】\n\n- 测试点 2-4 满足 $|s|\\le 5000$ 以及 $Q\\le 5000$。\n- 测试点 5-11 没有额外限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO22OPEN] COW Operations S", "background": "", "description": "Bessie 找到了一个长度不超过 $2 \\cdot 10^5$ 且仅包含字符 'C'，'O' 和 'W' 的字符串 $s$。她想知道是否可以使用以下操作将该字符串变为单个字母 'C'（她最喜欢的字母）：\n\n1. 选择两个相邻相等的字母并将其删除。\n\n2. 选择一个字母，将其替换为另外两个字母的任一排列。\n\n求出这个字符串本身的答案对 Bessie 而言并不足够，所以她想要知道 $s$ 的 $Q$（$1\\le Q\\le 2\\cdot 10^5$）个子串的答案。\n", "inputFormat": "输入的第一行包含 $s$。\n\n第二行包含 $Q$。\n\n以下 $Q$ 行每行包含两个整数 $l$ 和 $r$（$1\\le l\\le r\\le |s|$，其中 $|s|$ 表示 $s$ 的长度）。\n", "outputFormat": "输出一个长为 $Q$ 的字符串，如果第 $i$ 个子串可以被转变则第 $i$ 个字符为 'Y'，否则为 'N'。", "hint": "【样例解释】\n\n第一个询问的答案是「是」，因为 s 的第一个字符已经等于 'C'。\n\n第五个询问的答案是「是」，因为 s 的第二到第三个字符组成的子串 OW 可以通过两步操作变为 'C'：\n\n```\n   OW\n-> CWW\n-> C\n```\n\n这个样例字符串 COW 的其他子串均不能被转变为 'C'。\n\n【测试点性质】\n\n- 测试点 2-4 满足 $|s|\\le 5000$ 以及 $Q\\le 5000$。\n- 测试点 5-11 没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P8272", "type": "P", "difficulty": 5, "samples": [["5\n2 5 10 100\n2 6 0 3\n2 8 10 7\n1 2 4 5\n1 4 7 6", "10"], ["5\n2 5 10 100\n2 6 0 3\n2 8 11 7\n1 2 4 5\n1 4 7 6", "9"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "USACO", "2022", "排序"], "title": "[USACO22OPEN] Apple Catching G", "background": "", "description": "天上下苹果了！在某些时刻，一定数量的苹果会落到数轴上。在某些时刻，Farmer John 的一些奶牛将到达数轴并开始接苹果。\n\n如果一个苹果在没有奶牛接住的情况下落到数轴上，它就会永远消失。如果一头奶牛和一个苹果同时到达，奶牛就会接住苹果。每头奶牛每秒可以移动一单位距离。一旦一头奶牛接住了一个苹果，她就会离开数轴。\n\n如果 FJ 的奶牛以最优方式合作，她们总共能接住多少个苹果？", "inputFormat": "输入的第一行包含 $N$（$1\\le N\\le 2\\cdot 10^5$），为苹果落到数轴上的次数或 FJ 的奶牛出现的次数。\n\n以下 $N$ 行每行包含四个整数 $q_i$，$t_i$，$x_i$ 和 $n_i$（$q_i\\in \\{1,2\\}, 0\\le t_i\\le 10^9, 0\\le x_i\\le 10^9, 1\\le n_i\\le 10^3$）。\n\n- 如果 $q_i=1$，意味着 FJ 的 $n_i$ 头奶牛在 $t_i$ 时刻来到数轴上的 $x_i$ 位置。\n- 如果 $q_i=2$，意味着 $n_i$ 个苹果在 $t_i$ 时刻落到了数轴上的 $x_i$ 位置。\n\n输入保证所有有序对 $(t_i,x_i)$ 各不相同。", "outputFormat": "输出 FJ 的奶牛总计能接住的苹果的最大数量。", "hint": "【样例解释 1】\n\n在这个例子中，在 $t=5$ 时刻落地的 $100$ 个苹果均不能被接住。以下是一种接住 $10$ 个苹果的方式：\n\n- FJ 的所有六头 $t=4$ 时刻到达的奶牛各接一个 $t=8$ 时刻落地的苹果。\n- FJ 的一头 $t=2$ 时刻到达的奶牛接一个 $t=8$ 时刻落地的苹果。\n- 余下三头 $t=2$ 时刻到达的奶牛各接一个 $t=6$ 时刻落地的苹果。\n\n【样例解释 2】\n\n再一次地，在 $t=5$ 时刻落地的苹果均不能被接住。除此之外，在 $t=2$ 时刻到达的奶牛均不能接住 $t=8$ 时刻落地的苹果。以下是一种接住 $9$ 个苹果的方式：\n\n- FJ 的所有六头 $t=4$ 时刻到达的奶牛各接一个 $t=8$ 时刻落地的苹果。\n- 余下三头 $t=2$ 时刻到达的奶牛各接一个 $t=6$ 时刻落地的苹果。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO22OPEN] Apple Catching G", "background": "", "description": "天上下苹果了！在某些时刻，一定数量的苹果会落到数轴上。在某些时刻，Farmer John 的一些奶牛将到达数轴并开始接苹果。\n\n如果一个苹果在没有奶牛接住的情况下落到数轴上，它就会永远消失。如果一头奶牛和一个苹果同时到达，奶牛就会接住苹果。每头奶牛每秒可以移动一单位距离。一旦一头奶牛接住了一个苹果，她就会离开数轴。\n\n如果 FJ 的奶牛以最优方式合作，她们总共能接住多少个苹果？", "inputFormat": "输入的第一行包含 $N$（$1\\le N\\le 2\\cdot 10^5$），为苹果落到数轴上的次数或 FJ 的奶牛出现的次数。\n\n以下 $N$ 行每行包含四个整数 $q_i$，$t_i$，$x_i$ 和 $n_i$（$q_i\\in \\{1,2\\}, 0\\le t_i\\le 10^9, 0\\le x_i\\le 10^9, 1\\le n_i\\le 10^3$）。\n\n- 如果 $q_i=1$，意味着 FJ 的 $n_i$ 头奶牛在 $t_i$ 时刻来到数轴上的 $x_i$ 位置。\n- 如果 $q_i=2$，意味着 $n_i$ 个苹果在 $t_i$ 时刻落到了数轴上的 $x_i$ 位置。\n\n输入保证所有有序对 $(t_i,x_i)$ 各不相同。", "outputFormat": "输出 FJ 的奶牛总计能接住的苹果的最大数量。", "hint": "【样例解释 1】\n\n在这个例子中，在 $t=5$ 时刻落地的 $100$ 个苹果均不能被接住。以下是一种接住 $10$ 个苹果的方式：\n\n- FJ 的所有六头 $t=4$ 时刻到达的奶牛各接一个 $t=8$ 时刻落地的苹果。\n- FJ 的一头 $t=2$ 时刻到达的奶牛接一个 $t=8$ 时刻落地的苹果。\n- 余下三头 $t=2$ 时刻到达的奶牛各接一个 $t=6$ 时刻落地的苹果。\n\n【样例解释 2】\n\n再一次地，在 $t=5$ 时刻落地的苹果均不能被接住。除此之外，在 $t=2$ 时刻到达的奶牛均不能接住 $t=8$ 时刻落地的苹果。以下是一种接住 $9$ 个苹果的方式：\n\n- FJ 的所有六头 $t=4$ 时刻到达的奶牛各接一个 $t=8$ 时刻落地的苹果。\n- 余下三头 $t=2$ 时刻到达的奶牛各接一个 $t=6$ 时刻落地的苹果。", "locale": "zh-CN"}}}
{"pid": "P8273", "type": "P", "difficulty": 5, "samples": [["4\n1\n0\n1\n3\n12+\n+02\n3\n0++\n++9\n4\n5+++\n+6+1", "1\n3\n9\n9"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "USACO", "2022"], "title": "[USACO22OPEN] Pair Programming G", "background": "由于题目数据问题，在本题中，你**无需考虑**非平凡的（都有 0 或者只差若干个 1 或者仅顺序不同时称为平凡的）、两组不同的数乘积一样的情况，例如 $t\\times2\\times3=t\\times6$；或者，你应当把题面中的 $\\times 2,3,4,5,6,7,8,9$ 分别视为 $\\times 2,3,5,7,11,13,17,19$ 处理。", "description": "一个程序由一系列指令组成，每条指令都具有以下形式之一：\n\n- $\\times d$，其中 $d$ 是一个 $[0,9]$ 范围内的一位数；\n- $+s$，其中 $s$ 是一个表示变量名称的字符串。一个程序中出现的所有的变量名均不相同。\n\n程序执行的结果定义对表达式 $0$ 依次应用每条指令后得到的表达式。例如，执行程序 $[\\times 3,+x,+y,\\times 2,+z]$ 得到的结果是表达式 $(0\\times 3+x+y)\\times 2+z=2 \\times x+2\\times y+z$。不同的程序执行后可能会得到相同的表达式；例如，执行 $[+w,\\times 0,+y,+x,\\times 2,+z,\\times 1]$ 也会得到表达式 $2\\times x+2\\times y+z$。\n\nBessie 和 Elsie 各有一个 $N$（$1\\le N\\le 2000$）条指令的程序。他们将交错这些程序的指令以制造一个 $2N$ 条指令的新程序。注意有 $\\frac{(2N)!}{N!\\times N!}$ 种方法可以做到这一点，但并非所有这样的程序在执行后都会得到不同的表达式。\n\n计算执行 Bessie 和 Elsie 的交错程序可能得到的不同表达式的数量，对 $10^9+7$ 取模。\n\n每个测试用例包含 $T$（$1\\le T\\le 10$）个需要独立求解的子测试用例。输入保证所有子测试用例中的 $N$ 之和不超过 $2000$。", "inputFormat": "输入的第一行包含 $T$，为子测试用例的数量。\n\n每个子测试用例的第一行包含 $N$。\n\n每个子测试用例的第二行包含 Bessie 的程序，用一个长为 $N$ 的字符串表示。每个字符是一个一位数 $d\\in [0,9]$，表示类型 1 的一条指令，或字符 $+$，表示类型 2 的一条指令。\n\n每个子测试用例的第三行包含 Elsie 的程序，格式与 Bessie 的程序相同。\n\n在一个子测试用例中，所有指令内的变量名均不相同。注意在这里没有给出它们的实际名称，这是由于它们并不会影响答案。", "outputFormat": "输出通过执行 Bessie 和 Elsie 的交错程序可能得到的不同表达式的数量，对 $10^9+7$ 取模。", "hint": "【样例解释】\n\n对于第一个子测试用例，两个可以制造的交错程序为 $[\\times 1, \\times 0]$ 和 $[\\times 0,\\times 1]$。它们执行后均会得到表达式 $0$。\n\n对于第二个子测试用例，执行 $[\\times 1,\\times 2, +x]$ 和 $[+y, \\times 0,\\times 2]$ 的交错程序可以得到表达式 $0$，$x$ 和 $2\\times x$ 之一。\n\n【测试点性质】\n\n- 测试点 2 满足 $N\\le 6$。\n- 测试点 3-5 中，所有 $N$ 之和不超过 $100$。\n- 测试点 6-8 中，所有 $N$ 之和不超过 $500$。\n- 测试点 9-16 没有额外限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO22OPEN] Pair Programming G", "background": "由于题目数据问题，在本题中，你**无需考虑**非平凡的（都有 0 或者只差若干个 1 或者仅顺序不同时称为平凡的）、两组不同的数乘积一样的情况，例如 $t\\times2\\times3=t\\times6$；或者，你应当把题面中的 $\\times 2,3,4,5,6,7,8,9$ 分别视为 $\\times 2,3,5,7,11,13,17,19$ 处理。", "description": "一个程序由一系列指令组成，每条指令都具有以下形式之一：\n\n- $\\times d$，其中 $d$ 是一个 $[0,9]$ 范围内的一位数；\n- $+s$，其中 $s$ 是一个表示变量名称的字符串。一个程序中出现的所有的变量名均不相同。\n\n程序执行的结果定义对表达式 $0$ 依次应用每条指令后得到的表达式。例如，执行程序 $[\\times 3,+x,+y,\\times 2,+z]$ 得到的结果是表达式 $(0\\times 3+x+y)\\times 2+z=2 \\times x+2\\times y+z$。不同的程序执行后可能会得到相同的表达式；例如，执行 $[+w,\\times 0,+y,+x,\\times 2,+z,\\times 1]$ 也会得到表达式 $2\\times x+2\\times y+z$。\n\nBessie 和 Elsie 各有一个 $N$（$1\\le N\\le 2000$）条指令的程序。他们将交错这些程序的指令以制造一个 $2N$ 条指令的新程序。注意有 $\\frac{(2N)!}{N!\\times N!}$ 种方法可以做到这一点，但并非所有这样的程序在执行后都会得到不同的表达式。\n\n计算执行 Bessie 和 Elsie 的交错程序可能得到的不同表达式的数量，对 $10^9+7$ 取模。\n\n每个测试用例包含 $T$（$1\\le T\\le 10$）个需要独立求解的子测试用例。输入保证所有子测试用例中的 $N$ 之和不超过 $2000$。", "inputFormat": "输入的第一行包含 $T$，为子测试用例的数量。\n\n每个子测试用例的第一行包含 $N$。\n\n每个子测试用例的第二行包含 Bessie 的程序，用一个长为 $N$ 的字符串表示。每个字符是一个一位数 $d\\in [0,9]$，表示类型 1 的一条指令，或字符 $+$，表示类型 2 的一条指令。\n\n每个子测试用例的第三行包含 Elsie 的程序，格式与 Bessie 的程序相同。\n\n在一个子测试用例中，所有指令内的变量名均不相同。注意在这里没有给出它们的实际名称，这是由于它们并不会影响答案。", "outputFormat": "输出通过执行 Bessie 和 Elsie 的交错程序可能得到的不同表达式的数量，对 $10^9+7$ 取模。", "hint": "【样例解释】\n\n对于第一个子测试用例，两个可以制造的交错程序为 $[\\times 1, \\times 0]$ 和 $[\\times 0,\\times 1]$。它们执行后均会得到表达式 $0$。\n\n对于第二个子测试用例，执行 $[\\times 1,\\times 2, +x]$ 和 $[+y, \\times 0,\\times 2]$ 的交错程序可以得到表达式 $0$，$x$ 和 $2\\times x$ 之一。\n\n【测试点性质】\n\n- 测试点 2 满足 $N\\le 6$。\n- 测试点 3-5 中，所有 $N$ 之和不超过 $100$。\n- 测试点 6-8 中，所有 $N$ 之和不超过 $500$。\n- 测试点 9-16 没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P8274", "type": "P", "difficulty": 5, "samples": [["3 0\n3\n1 1\n0 100\n1 1\n6 7\n5\n1 2 3 4\n6 6\n1 6\n1 6\n1 6\n5 5\n3\n1 1\n0 10\n0 1\n9 10", "3\n1\n4\n"], ["3 1\n3\n1 1\n0 100\n1 1\n6 7\n5\n1 2 3 4\n6 6\n1 6\n1 6\n1 6\n5 5\n3\n1 1\n0 10\n0 1\n9 10", "3\n3 1 6\n1\n6 5 5 5 5\n4\n5 1 9"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "贪心", "二分", "USACO", "2022", "Special Judge", "构造"], "title": "[USACO22OPEN] Balancing a Tree G", "background": "感谢 @tiger2005 配置 SPJ。", "description": "Farmer John 对不同奶牛品种的进化进行了广泛的研究。所得到的结果形成一棵 $N$（$2\\le N\\le 10^5$）个结点的有根树，编号为 $1\\ldots N$，每个结点对应一个奶牛品种。对于每一个 $i\\in [2,N]$，结点 $i$ 的父结点是结点 $p_i$（$1\\le p_i< i$），意味着品种 $i$ 是由品种 $p_i$ 进化而来的。称结点 $j$ 为结点 $i$ 的祖先，如果 $j=p_i$ 或者 $j$ 是 $p_i$ 的祖先。\n\n树中的结点 $i$ 所关联的品种具有整数 $s_i$ 数量的斑点。定义树的「不平衡度」为所有结点对 $(i,j)$ 中 $|s_i-s_j|$ 的最大值，其中 $j$ 是 $i$ 的祖先。\n\nFarmer John 不知道每个品种的 $s_i$ 的确切数值，但他知道这些值的下界和上界。你的任务是为每个结点分配一个整数值 $s_i \\in [l_i,r_i]$（$0\\le l_i\\le r_i\\le 10^9$），以最小化树的不平衡度。", "inputFormat": "输入的第一行包含 $T$（$1\\le T\\le 10$），为需要独立求解的子测试用例的数量，以及一个整数 $B\\in \\{0,1\\}$。\n\n每个子测试用例的第一行包含 $N$，第二行包含 $N-1$ 个整数 $p_2,p_3,\\ldots,p_N$。\n\n以下 $N$ 行每行包含两个整数 $l_i$ 和 $r_i$。\n\n输入保证所有子测试用例的 $N$ 之和不超过 $10^5$。", "outputFormat": "对每个子测试用例，根据 $B$ 的值输出一行或两行。\n\n每个子测试用例的第一行包含最小不平衡度。\n\n如果 $B=1$，则再输出一行，包含 $N$ 个空格分隔的整数 $s_1,s_2,\\ldots, s_N$，为达到以上不平衡度的一种斑点数量的分配方式。任何合法的分配方式均正确。\n", "hint": "【样例解释 1】\n\n对于第一个子测试用例，最小不平衡度为 $3$。一种达到不平衡度 $3$ 的方式是令 $[s_1,s_2,s_3]=[4,1,7]$。\n\n【样例解释 2】\n\n这个测试用例除了 $B$ 的值之外与第一个测试用例完全相同。另一种达到不平衡度 $3$ 的方式是令 $[s_1,s_2,s_3]=[3,1,6]$。\n\n【数据范围】\n\n- 测试点 3-4 对于所有的 $i$ 满足 $l_i=r_i$。\n- 测试点 5-6 对于所有的 $i$ 满足 $p_i=i-1$。\n- 测试点 7-16 没有额外限制。\n\n在每一部分子任务中，前一半的测试点满足 $B=0$，后一半测试点满足 $B=1$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO22OPEN] Balancing a Tree G", "background": "感谢 @tiger2005 配置 SPJ。", "description": "Farmer John 对不同奶牛品种的进化进行了广泛的研究。所得到的结果形成一棵 $N$（$2\\le N\\le 10^5$）个结点的有根树，编号为 $1\\ldots N$，每个结点对应一个奶牛品种。对于每一个 $i\\in [2,N]$，结点 $i$ 的父结点是结点 $p_i$（$1\\le p_i< i$），意味着品种 $i$ 是由品种 $p_i$ 进化而来的。称结点 $j$ 为结点 $i$ 的祖先，如果 $j=p_i$ 或者 $j$ 是 $p_i$ 的祖先。\n\n树中的结点 $i$ 所关联的品种具有整数 $s_i$ 数量的斑点。定义树的「不平衡度」为所有结点对 $(i,j)$ 中 $|s_i-s_j|$ 的最大值，其中 $j$ 是 $i$ 的祖先。\n\nFarmer John 不知道每个品种的 $s_i$ 的确切数值，但他知道这些值的下界和上界。你的任务是为每个结点分配一个整数值 $s_i \\in [l_i,r_i]$（$0\\le l_i\\le r_i\\le 10^9$），以最小化树的不平衡度。", "inputFormat": "输入的第一行包含 $T$（$1\\le T\\le 10$），为需要独立求解的子测试用例的数量，以及一个整数 $B\\in \\{0,1\\}$。\n\n每个子测试用例的第一行包含 $N$，第二行包含 $N-1$ 个整数 $p_2,p_3,\\ldots,p_N$。\n\n以下 $N$ 行每行包含两个整数 $l_i$ 和 $r_i$。\n\n输入保证所有子测试用例的 $N$ 之和不超过 $10^5$。", "outputFormat": "对每个子测试用例，根据 $B$ 的值输出一行或两行。\n\n每个子测试用例的第一行包含最小不平衡度。\n\n如果 $B=1$，则再输出一行，包含 $N$ 个空格分隔的整数 $s_1,s_2,\\ldots, s_N$，为达到以上不平衡度的一种斑点数量的分配方式。任何合法的分配方式均正确。\n", "hint": "【样例解释 1】\n\n对于第一个子测试用例，最小不平衡度为 $3$。一种达到不平衡度 $3$ 的方式是令 $[s_1,s_2,s_3]=[4,1,7]$。\n\n【样例解释 2】\n\n这个测试用例除了 $B$ 的值之外与第一个测试用例完全相同。另一种达到不平衡度 $3$ 的方式是令 $[s_1,s_2,s_3]=[3,1,6]$。\n\n【数据范围】\n\n- 测试点 3-4 对于所有的 $i$ 满足 $l_i=r_i$。\n- 测试点 5-6 对于所有的 $i$ 满足 $p_i=i-1$。\n- 测试点 7-16 没有额外限制。\n\n在每一部分子任务中，前一半的测试点满足 $B=0$，后一半测试点满足 $B=1$。\n", "locale": "zh-CN"}}}
