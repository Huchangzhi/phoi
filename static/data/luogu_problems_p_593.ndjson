{"pid": "P13035", "type": "P", "difficulty": 3, "samples": [["2 4\n\n4\n\n2\n\n1\n\n4\n\n1\n\n1\n\n3\n\n1\n\n3\n\n2\n\n1", "\nM 2 4\n\nM 1 3\n\nS 1 4\n\nM 3 4\n\nS 3 4\n\nD\n\nM 1 4\n\nS 1 3\n\nM 3 4\n\nM 2 4\n\nD"]], "limits": {"time": [60000], "memory": [1048576]}, "tags": ["2021", "交互题", "Special Judge", "排序", "Google Code Jam"], "title": "[GCJ 2021 #2] Minimum Sort", "background": "", "description": "In this problem, you need to sort a list of $N = 100$ distinct integers in strictly increasing order. You can rearrange the list by swapping the contents of any two positions (they do not need to be adjacent). Unfortunately, you cannot read those contents directly. You can access information about the list contents by querying the minimum of a range. The minimum query gives you the position of the minimum value over a range of consecutive positions. For example, in the list $[51, 33, 100, 11]$, the minimum over the range between positions 2 and 4, inclusive (1-based), is at position 4 and the minimum between positions 1 and 3 is at position 2.\n\nQueries about the minimum within a range are limited by a coin budget per test case. Larger ranges are cheaper: asking about the position of the minimum between positions $i$ and $j$ (for $i < j$) costs $\\lceil 10^8 / (j - i + 1) \\rceil$ coins, where $\\lceil x \\rceil$ is the smallest integer greater than or equal to $x$ (that is, $x$ rounded up). Swap operations, on the other hand, do not cost any coins.\n\nWrite a program that sorts lists of integers using any number of swaps and at most $6 \\times 10^8$ coins per test case distributed among any number of minimum queries.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, the judge will send you a single line containing two integers $\\mathbf{T}$ and $\\mathbf{N}$: the number of test cases and the number of elements to sort within each test case, respectively. The judge has the initial lists preset before it gets any input from your program, and the only changes done to them during the exchanges with your program are the swaps that you request.\n\nThen, you must process $\\mathbf{T}$ test cases. Each test case consists of a series of exchanges plus an additional line indicating you are done. Each exchange consists of you printing one line and the judge printing one line in response. Your program must print a single line containing one of these options:\n\n- An uppercase $\\mathbf{M}$ and two integers $i$ and $j$ with $i < j$ representing a minimum query. The judge responds with a single integer representing the position of the minimum value in the list within 1-based positions $i$ and $j$, inclusive.\n- An uppercase $\\mathbf{S}$ and two integers $i$ and $j$ with $i < j$ representing a swap operation. The judge swaps the two elements at 1-based positions $i$ and $j$ and responds with 1.\n- An uppercase $\\mathbf{D}$ representing that you are done sorting the list. The judge checks the list. It responds with 1 if the list is sorted in strictly increasing order and -1 if it is not.\n\nAfter the judge responds 1 to a $\\mathbf{D}$, it will finish if it was the last test case or it will immediately start waiting for your first command for the next test case. After receiving the judge's response for the $\\mathbf{T}$-th case, your program must finish in order to not receive a Time Limit Exceeded error.\n\nIf the judge receives an invalidly formatted line or invalid values from your program at any moment, including a minimum operation whose cost would exceed your remaining budget for the test case, the judge will print a single number -1. After the judge prints -1 for any of the reasons explained above, it will not print any further output. If your program continues to wait for the judge after receiving a -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "You can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our interactive runner for that.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n**Test Set 1 (15 Pts, Visible Verdict)**\n\n- $\\mathbf{T} = 100$.\n- $\\mathbf{N} = 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #2] Minimum Sort", "background": "", "description": "In this problem, you need to sort a list of $N = 100$ distinct integers in strictly increasing order. You can rearrange the list by swapping the contents of any two positions (they do not need to be adjacent). Unfortunately, you cannot read those contents directly. You can access information about the list contents by querying the minimum of a range. The minimum query gives you the position of the minimum value over a range of consecutive positions. For example, in the list $[51, 33, 100, 11]$, the minimum over the range between positions 2 and 4, inclusive (1-based), is at position 4 and the minimum between positions 1 and 3 is at position 2.\n\nQueries about the minimum within a range are limited by a coin budget per test case. Larger ranges are cheaper: asking about the position of the minimum between positions $i$ and $j$ (for $i < j$) costs $\\lceil 10^8 / (j - i + 1) \\rceil$ coins, where $\\lceil x \\rceil$ is the smallest integer greater than or equal to $x$ (that is, $x$ rounded up). Swap operations, on the other hand, do not cost any coins.\n\nWrite a program that sorts lists of integers using any number of swaps and at most $6 \\times 10^8$ coins per test case distributed among any number of minimum queries.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, the judge will send you a single line containing two integers $\\mathbf{T}$ and $\\mathbf{N}$: the number of test cases and the number of elements to sort within each test case, respectively. The judge has the initial lists preset before it gets any input from your program, and the only changes done to them during the exchanges with your program are the swaps that you request.\n\nThen, you must process $\\mathbf{T}$ test cases. Each test case consists of a series of exchanges plus an additional line indicating you are done. Each exchange consists of you printing one line and the judge printing one line in response. Your program must print a single line containing one of these options:\n\n- An uppercase $\\mathbf{M}$ and two integers $i$ and $j$ with $i < j$ representing a minimum query. The judge responds with a single integer representing the position of the minimum value in the list within 1-based positions $i$ and $j$, inclusive.\n- An uppercase $\\mathbf{S}$ and two integers $i$ and $j$ with $i < j$ representing a swap operation. The judge swaps the two elements at 1-based positions $i$ and $j$ and responds with 1.\n- An uppercase $\\mathbf{D}$ representing that you are done sorting the list. The judge checks the list. It responds with 1 if the list is sorted in strictly increasing order and -1 if it is not.\n\nAfter the judge responds 1 to a $\\mathbf{D}$, it will finish if it was the last test case or it will immediately start waiting for your first command for the next test case. After receiving the judge's response for the $\\mathbf{T}$-th case, your program must finish in order to not receive a Time Limit Exceeded error.\n\nIf the judge receives an invalidly formatted line or invalid values from your program at any moment, including a minimum operation whose cost would exceed your remaining budget for the test case, the judge will print a single number -1. After the judge prints -1 for any of the reasons explained above, it will not print any further output. If your program continues to wait for the judge after receiving a -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "You can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our interactive runner for that.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n**Test Set 1 (15 Pts, Visible Verdict)**\n\n- $\\mathbf{T} = 100$.\n- $\\mathbf{N} = 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #2] Minimum Sort", "background": "", "description": "在这个问题中，你需要将一个包含 $N = 100$ 个不同整数的列表按严格递增的顺序排序。你可以通过交换任意两个位置的内容来重新排列列表（这两个位置不需要相邻）。但遗憾的是，你无法直接读取这些内容。你可以通过查询区间最小值来获取列表内容的信息。最小值查询会给出一个连续位置区间内最小值所在的位置。例如，在列表 $[51, 33, 100, 11]$ 中，位置 2 到 4（基于 1 的索引）的最小值位于位置 4，而位置 1 到 3 的最小值位于位置 2。\n\n关于区间最小值的查询受到每个测试用例的硬币预算限制。更大的区间更便宜：查询位置 $i$ 到 $j$（$i < j$）的最小值位置需要花费 $\\lceil 10^8 / (j - i + 1) \\rceil$ 枚硬币，其中 $\\lceil x \\rceil$ 表示大于或等于 $x$ 的最小整数（即 $x$ 向上取整）。而交换操作不消耗任何硬币。\n\n编写一个程序，使用任意次数的交换操作和最多 $6 \\times 10^8$ 枚硬币（每个测试用例中分配到任意数量的最小值查询）对整数列表进行排序。\n\n### 交互协议\n\n这是一个交互式问题。\n\n最初，评测机会发送一行包含两个整数 $\\mathbf{T}$ 和 $\\mathbf{N}$：分别是测试用例的数量和每个测试用例中需要排序的元素数量。评测机在收到你的程序的任何输入之前已经预设了初始列表，并且在与你程序的交互过程中，列表的唯一变化是你请求的交换操作。\n\n然后，你需要处理 $\\mathbf{T}$ 个测试用例。每个测试用例由一系列交互加上一行表示完成的指令组成。每次交互由你打印一行和评测机打印一行响应组成。你的程序必须打印以下选项之一的一行内容：\n\n- 一个大写字母 $\\mathbf{M}$ 和两个整数 $i$ 和 $j$（$i < j$），表示一个最小值查询。评测机会响应一个整数，表示基于 1 的索引中位置 $i$ 到 $j$（包含）区间内最小值的位置。\n- 一个大写字母 $\\mathbf{S}$ 和两个整数 $i$ 和 $j$（$i < j$），表示一个交换操作。评测机会交换基于 1 的索引中位置 $i$ 和 $j$ 的两个元素，并响应 1。\n- 一个大写字母 $\\mathbf{D}$，表示你已完成列表的排序。评测机会检查列表。如果列表已按严格递增顺序排序，则响应 1；否则响应 -1。\n\n当评测机对 $\\mathbf{D}$ 响应 1 后，如果是最后一个测试用例，评测机会结束；否则会立即开始等待你对下一个测试用例的第一条指令。在收到第 $\\mathbf{T}$ 个测试用例的响应后，你的程序必须结束，否则会收到“超出时间限制”错误。\n\n如果评测机在任何时候收到格式无效的行或无效的值（包括最小值查询的硬币成本超过了当前测试用例的剩余预算），评测机会打印一个数字 -1。在评测机因上述任何原因打印 -1 后，它将不再输出任何内容。如果你的程序在收到 -1 后继续等待评测机的响应，你的程序将因超时而收到“超出时间限制”错误。请注意，你的程序有责任及时退出以避免收到“超出时间限制”错误，而应收到“答案错误”的判定。与往常一样，如果超出内存限制或程序出现运行时错误，你将收到相应的判定。", "inputFormat": "参见交互协议。", "outputFormat": "参见交互协议。", "hint": "你可以使用此测试工具在本地或我们的平台上进行测试。要在本地测试，你需要同时运行该工具和你的代码；你可以使用我们的[交互式运行器](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)来实现。\n\n测试工具的说明包含在工具的注释中。我们鼓励你添加自己的测试用例。请注意，尽管该测试工具旨在模拟评测系统，但它**并非**真实的评测系统，可能会表现出不同的行为。\n\n**限制**\n\n**测试集 1（15 分，可见判定）**\n\n- $\\mathbf{T} = 100$。\n- $\\mathbf{N} = 100$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13036", "type": "P", "difficulty": 4, "samples": [["3\n33\n15\n41", "Case #1: 3\nCase #2: 2\nCase #3: 1"]], "limits": {"time": [20000, 20000, 40000], "memory": [1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2021", "Google Code Jam"], "title": "[GCJ 2021 #2] Matrygons", "background": "", "description": "A [matryoshka](https://en.wikipedia.org/wiki/Matryoshka_doll) is a type of doll that originated in Russia over a century ago. Their defining characteristic is that they consist of a set of dolls, all of a different size, with smaller dolls fitting nicely inside larger dolls.\n\nIn this problem, we work with matrygons, which are sets of regular convex polygons that follow a similar nesting pattern. A matrygon consists of a set of regular convex polygons with positive area $p_1, p_2, \\ldots, p_k$ such that, for all $i$, the vertices of $p_{i+1}$ overlap with a proper subset of the vertices of $p_i$ ($p_{i+1}$ has strictly less vertices than $p_i$).\n\nFor example, the following pictures illustrate two matrygons. The first one contains 3 regular convex polygons: a regular icositetragon (24 sides), a regular hexagon (6 sides), and an equilateral triangle (3 sides). The second one contains 2 regular convex polygons: a regular icosidigon (22 sides) and a regular hendecagon (11 sides). Each of these matrygons has 33 total sides among all polygons in it.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3kcm72a3.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/pf69u83n.png)\n\nGiven a fixed total number of sides $\\mathbf{N}$, calculate the largest number of polygons that can be part of a matrygon such that the total number of sides among all polygons in it is exactly $\\mathbf{N}$.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line represents a test case and contains a single integer $\\mathbf{N}$, the target total number of sides.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of polygons in a matrygon such that the total number of sides among all polygons in it is exactly $\\mathbf{N}$.", "hint": "**Sample Explanation**\n\nThe first matrygon pictured in the problem statement is an optimal solution for Sample Case #1.\n\nIn Sample Case #2, we can get to two polygons by fitting a regular pentagon (5 sides) inside a regular decagon (10 sides).\n\nIn Sample Case #3, there is no way to create a matrygon with multiple regular polygons, so our only option is to use a single regular tetracontahenagon (41 sides).\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $3 \\leq \\mathbf{N} \\leq 1000$.\n\n**Test Set 2 (13 Pts, Visible Verdict)**\n\n- Time limit: 40 seconds.\n- $3 \\leq \\mathbf{N} \\leq 10^6$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #2] Matrygons", "background": "", "description": "A [matryoshka](https://en.wikipedia.org/wiki/Matryoshka_doll) is a type of doll that originated in Russia over a century ago. Their defining characteristic is that they consist of a set of dolls, all of a different size, with smaller dolls fitting nicely inside larger dolls.\n\nIn this problem, we work with matrygons, which are sets of regular convex polygons that follow a similar nesting pattern. A matrygon consists of a set of regular convex polygons with positive area $p_1, p_2, \\ldots, p_k$ such that, for all $i$, the vertices of $p_{i+1}$ overlap with a proper subset of the vertices of $p_i$ ($p_{i+1}$ has strictly less vertices than $p_i$).\n\nFor example, the following pictures illustrate two matrygons. The first one contains 3 regular convex polygons: a regular icositetragon (24 sides), a regular hexagon (6 sides), and an equilateral triangle (3 sides). The second one contains 2 regular convex polygons: a regular icosidigon (22 sides) and a regular hendecagon (11 sides). Each of these matrygons has 33 total sides among all polygons in it.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3kcm72a3.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/pf69u83n.png)\n\nGiven a fixed total number of sides $\\mathbf{N}$, calculate the largest number of polygons that can be part of a matrygon such that the total number of sides among all polygons in it is exactly $\\mathbf{N}$.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line represents a test case and contains a single integer $\\mathbf{N}$, the target total number of sides.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of polygons in a matrygon such that the total number of sides among all polygons in it is exactly $\\mathbf{N}$.", "hint": "**Sample Explanation**\n\nThe first matrygon pictured in the problem statement is an optimal solution for Sample Case #1.\n\nIn Sample Case #2, we can get to two polygons by fitting a regular pentagon (5 sides) inside a regular decagon (10 sides).\n\nIn Sample Case #3, there is no way to create a matrygon with multiple regular polygons, so our only option is to use a single regular tetracontahenagon (41 sides).\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $3 \\leq \\mathbf{N} \\leq 1000$.\n\n**Test Set 2 (13 Pts, Visible Verdict)**\n\n- Time limit: 40 seconds.\n- $3 \\leq \\mathbf{N} \\leq 10^6$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #2] Matrygons", "background": "", "description": "[套娃](https://en.wikipedia.org/wiki/Matryoshka_doll)是一种起源于一个多世纪前俄罗斯的玩偶。它们的显著特征是由一组大小各异的玩偶组成，较小的玩偶可以完美地嵌套在较大的玩偶内部。\n\n在本问题中，我们研究**套娃多边形**，这是一组遵循类似嵌套规则的正则凸多边形。一个套娃多边形由一组面积为正的正则凸多边形 $p_1, p_2, \\ldots, p_k$ 组成，且满足对于所有 $i$，$p_{i+1}$ 的顶点是 $p_i$ 顶点的**真子集**（即 $p_{i+1}$ 的边数严格少于 $p_i$）。\n\n例如，下图展示了两个套娃多边形。第一个包含 3 个正则凸多边形：一个正二十四边形（24 条边）、一个正六边形（6 条边）和一个等边三角形（3 条边）。第二个包含 2 个正则凸多边形：一个正二十二边形（22 条边）和一个正十一边形（11 条边）。这两个套娃多边形的总边数均为 33。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3kcm72a3.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/pf69u83n.png)\n\n给定总边数 $\\mathbf{N}$，计算在总边数恰好为 $\\mathbf{N}$ 的套娃多边形中，最多可以包含多少个多边形。", "inputFormat": "输入第一行包含测试用例数量 $\\mathbf{T}$。随后 $\\mathbf{T}$ 行，每行一个整数 $\\mathbf{N}$，表示目标总边数。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为满足条件的套娃多边形中最多包含的多边形数量。\n", "hint": "**样例解释**\n\n问题描述中的第一个套娃多边形是样例 #1 的最优解。\n\n在样例 #2 中，我们可以将一个正五边形（5 条边）嵌套在正十边形（10 条边）内，得到包含 2 个多边形的套娃多边形。\n\n在样例 #3 中，无法创建包含多个正则多边形的套娃多边形，因此唯一选择是使用单个正四十一边形（41 条边）。\n\n**限制条件**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n\n**测试集 1（7 分，可见判定）**\n\n- 时间限制：20 秒。\n- $3 \\leq \\mathbf{N} \\leq 1000$。\n\n**测试集 2（13 分，可见判定）**\n\n- 时间限制：40 秒。\n- $3 \\leq \\mathbf{N} \\leq 10^6$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13037", "type": "P", "difficulty": 5, "samples": [["3\n4\n1 2 2 1\n3\n1 1 2\n3\n1 1 3", "Case #1: 1\nCase #2: 2\nCase #3: 0"], ["1\n24\n1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2", "Case #1: 234141013"]], "limits": {"time": [30000, 30000, 40000], "memory": [1048576, 1048576, 1048576]}, "tags": ["线段树", "二分", "2021", "分治", "组合数学", "Google Code Jam"], "title": "[GCJ 2021 #2] Hidden Pancakes", "background": "", "description": "We are cooking $\\mathbf{N}$ pancakes in total. We cook one pancake with a 1 centimeter (cm) radius, one with a $2 \\mathrm{~cm}$ radius, one with a $3 \\mathrm{~cm}$ radius, ..., and one with an $\\mathbf{N} \\mathrm{cm}$ radius, not necessarily in that order. After we cook the first pancake, we just lay it on a plate. After we cook each subsequent pancake, we lay it on top of the previously made pancake, with their centers coinciding. In this way, a pancake is visible from the top of the stack when we first add it. A pancake only becomes hidden if we later cook another pancake with a larger radius.\n\nFor example, say we cook 4 pancakes. We first cook the pancake with radius $3 \\mathrm{~cm}$, and it is visible. Then, we cook the pancake with radius $1 \\mathrm{~cm}$, lay it on top of the first one and both are visible. Third, we cook the pancake with radius $2 \\mathrm{~cm}$, and now that covers the previous pancake, but not the first one, so 2 pancakes remain visible in total. Finally, we cook the pancake with radius $4 \\mathrm{~cm}$ which covers the other pancakes leaving only 1 visible pancake. The picture below illustrates the state of the stack after each pancake is cooked. Within each stack, the fully colored pancakes are visible and the semi-transparent pancakes are not visible.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s69k9evw.png)\n\nLet $\\mathbf{V}_{\\mathbf{i}}$ be the number of visible pancakes when the stack contains exactly $i$ pancakes. In the example above, $\\mathbf{V}_{1}=1, \\mathbf{V}_{2}=2, \\mathbf{V}_{3}=2$, and $\\mathbf{V}_{4}=1$.\n\nGiven the list $\\mathbf{V}_{1}, \\mathbf{V}_{2}, \\ldots, \\mathbf{V}_{\\mathbf{N}}$, how many of the $\\mathbf{N} !$ possible cooking orders yield those values? Since the output can be a really big number, we only ask you to output the remainder of dividing the result by the prime $10^{9}+7(1000000007)$.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow, each described with two lines. The first line of a test case contains a single integer $\\mathbf{N}$, the number of pancakes we cook. The second line of a test case contains $\\mathbf{N}$ integers $\\mathbf{V}_{1}, \\mathbf{V}_{2}, \\ldots, \\mathbf{V}_{\\mathbf{N}}$, representing the number of visible pancakes after we cook $1,2, \\ldots, \\mathbf{N}$ pancakes, respectively.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of cooking orders of $\\mathbf{N}$ pancakes that yield the given numbers of visible pancakes after each step, modulo the prime $10^{9}+7(1000000007)$.", "hint": "Sample Case #1 is explained in the problem statement. The order $3,1,2,4$ is the only one that yields the given $\\mathbf{V}_{\\mathbf{i}} \\mathrm{s}$.\n\nIn Sample Case #2, both the order $1,3,2$ and the order $2,3,1$ yield the intended $\\mathbf{V}_{\\mathbf{i}} \\mathrm{s}$. The pictures below illustrate both options.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/o981r60x.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3vhqt53k.png)\n\nIn Sample Case #3, only 1 pancake is visible after the second is made, so there is no way to have more than 2 visible pancakes by only adding a third.\n\nSample Test Set 2 fits the limits of Test Set 2. It will not be run against your submitted solutions.\n\nIn the Sample Case for Test Set 2, there are $316234143225$ cooking orders that yield the given $\\mathbf{V}_{\\mathbf{i}} \\mathrm{s}$. Modulo $10^{9}+7$, this value is $234141013$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{V}_{\\mathbf{i}} \\leq i$, for all $i$.\n\n**Test Set 1 (Visible Verdict)**\n\n- Time limit: 30 seconds.\n- $2 \\leq \\mathbf{N} \\leq 13$.\n\n**Test Set 2 (Hidden Verdict)**\n\n- Time limit: 40 seconds.\n- $2 \\leq \\mathbf{N} \\leq 10^{5}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #2] Hidden Pancakes", "background": "", "description": "We are cooking $\\mathbf{N}$ pancakes in total. We cook one pancake with a 1 centimeter (cm) radius, one with a $2 \\mathrm{~cm}$ radius, one with a $3 \\mathrm{~cm}$ radius, ..., and one with an $\\mathbf{N} \\mathrm{cm}$ radius, not necessarily in that order. After we cook the first pancake, we just lay it on a plate. After we cook each subsequent pancake, we lay it on top of the previously made pancake, with their centers coinciding. In this way, a pancake is visible from the top of the stack when we first add it. A pancake only becomes hidden if we later cook another pancake with a larger radius.\n\nFor example, say we cook 4 pancakes. We first cook the pancake with radius $3 \\mathrm{~cm}$, and it is visible. Then, we cook the pancake with radius $1 \\mathrm{~cm}$, lay it on top of the first one and both are visible. Third, we cook the pancake with radius $2 \\mathrm{~cm}$, and now that covers the previous pancake, but not the first one, so 2 pancakes remain visible in total. Finally, we cook the pancake with radius $4 \\mathrm{~cm}$ which covers the other pancakes leaving only 1 visible pancake. The picture below illustrates the state of the stack after each pancake is cooked. Within each stack, the fully colored pancakes are visible and the semi-transparent pancakes are not visible.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s69k9evw.png)\n\nLet $\\mathbf{V}_{\\mathbf{i}}$ be the number of visible pancakes when the stack contains exactly $i$ pancakes. In the example above, $\\mathbf{V}_{1}=1, \\mathbf{V}_{2}=2, \\mathbf{V}_{3}=2$, and $\\mathbf{V}_{4}=1$.\n\nGiven the list $\\mathbf{V}_{1}, \\mathbf{V}_{2}, \\ldots, \\mathbf{V}_{\\mathbf{N}}$, how many of the $\\mathbf{N} !$ possible cooking orders yield those values? Since the output can be a really big number, we only ask you to output the remainder of dividing the result by the prime $10^{9}+7(1000000007)$.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow, each described with two lines. The first line of a test case contains a single integer $\\mathbf{N}$, the number of pancakes we cook. The second line of a test case contains $\\mathbf{N}$ integers $\\mathbf{V}_{1}, \\mathbf{V}_{2}, \\ldots, \\mathbf{V}_{\\mathbf{N}}$, representing the number of visible pancakes after we cook $1,2, \\ldots, \\mathbf{N}$ pancakes, respectively.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of cooking orders of $\\mathbf{N}$ pancakes that yield the given numbers of visible pancakes after each step, modulo the prime $10^{9}+7(1000000007)$.", "hint": "Sample Case #1 is explained in the problem statement. The order $3,1,2,4$ is the only one that yields the given $\\mathbf{V}_{\\mathbf{i}} \\mathrm{s}$.\n\nIn Sample Case #2, both the order $1,3,2$ and the order $2,3,1$ yield the intended $\\mathbf{V}_{\\mathbf{i}} \\mathrm{s}$. The pictures below illustrate both options.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/o981r60x.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3vhqt53k.png)\n\nIn Sample Case #3, only 1 pancake is visible after the second is made, so there is no way to have more than 2 visible pancakes by only adding a third.\n\nSample Test Set 2 fits the limits of Test Set 2. It will not be run against your submitted solutions.\n\nIn the Sample Case for Test Set 2, there are $316234143225$ cooking orders that yield the given $\\mathbf{V}_{\\mathbf{i}} \\mathrm{s}$. Modulo $10^{9}+7$, this value is $234141013$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{V}_{\\mathbf{i}} \\leq i$, for all $i$.\n\n**Test Set 1 (Visible Verdict)**\n\n- Time limit: 30 seconds.\n- $2 \\leq \\mathbf{N} \\leq 13$.\n\n**Test Set 2 (Hidden Verdict)**\n\n- Time limit: 40 seconds.\n- $2 \\leq \\mathbf{N} \\leq 10^{5}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #2] Hidden Pancakes", "background": "", "description": "我们总共要烹饪 $\\mathbf{N}$ 张煎饼。这些煎饼的半径分别为 $1$ 厘米（cm）、$2 \\mathrm{~cm}$、$3 \\mathrm{~cm}$，……，以及 $\\mathbf{N} \\mathrm{cm}$，但烹饪顺序不一定按半径从小到大排列。烹饪完第一张煎饼后，我们直接将其放在盘子上。之后每烹饪完一张煎饼，就将其叠放在之前所有煎饼的最上方，且所有煎饼的中心对齐。这样，每张煎饼在刚被加入时都能从顶部被看到。只有当之后烹饪了比它半径更大的煎饼时，这张煎饼才会被隐藏。\n\n例如，假设我们烹饪 4 张煎饼。首先烹饪半径为 $3 \\mathrm{~cm}$ 的煎饼，此时它可见。接着烹饪半径为 $1 \\mathrm{~cm}$ 的煎饼，叠放在第一张煎饼上，此时两张煎饼都可见。然后烹饪半径为 $2 \\mathrm{~cm}$ 的煎饼，它会覆盖前一张煎饼（半径为 $1 \\mathrm{~cm}$ 的煎饼），但不会覆盖第一张煎饼，因此此时共有 2 张煎饼可见。最后，烹饪半径为 $4 \\mathrm{~cm}$ 的煎饼，它会覆盖所有其他煎饼，此时只有 1 张煎饼可见。下图展示了每张煎饼被烹饪后叠放的状态，其中完全不透明的煎饼表示可见，半透明的煎饼表示不可见。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s69k9evw.png)\n\n设 $\\mathbf{V}_{\\mathbf{i}}$ 表示叠放了恰好 $i$ 张煎饼时可见的煎饼数量。在上面的例子中，$\\mathbf{V}_{1}=1$、$\\mathbf{V}_{2}=2$、$\\mathbf{V}_{3}=2$、$\\mathbf{V}_{4}=1$。\n\n给定列表 $\\mathbf{V}_{1}, \\mathbf{V}_{2}, \\ldots, \\mathbf{V}_{\\mathbf{N}}$，问在所有 $\\mathbf{N} !$ 种可能的烹饪顺序中，有多少种顺序能恰好得到给定的 $\\mathbf{V}_{\\mathbf{i}}$ 序列？由于结果可能非常大，只需输出结果对质数 $10^{9}+7$（即 $1000000007$）取模后的值。\n", "inputFormat": "输入的第一行包含测试用例数量 $\\mathbf{T}$。每个测试用例包含两行：第一行是一个整数 $\\mathbf{N}$，表示烹饪的煎饼数量；第二行包含 $\\mathbf{N}$ 个整数 $\\mathbf{V}_{1}, \\mathbf{V}_{2}, \\ldots, \\mathbf{V}_{\\mathbf{N}}$，分别表示叠放了 $1, 2, \\ldots, \\mathbf{N}$ 张煎饼时的可见煎饼数量。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是满足条件的烹饪顺序数量对 $10^{9}+7$ 取模后的结果。\n", "hint": "**样例解释**\n\n样例 #1 已在题目描述中说明，唯一的满足条件的烹饪顺序是 $3,1,2,4$。\n\n在样例 #2 中，顺序 $1,3,2$ 和 $2,3,1$ 均能满足给定的 $\\mathbf{V}_{\\mathbf{i}}$ 序列。下图展示了这两种情况：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/o981r60x.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3vhqt53k.png)\n\n在样例 #3 中，叠加第二张煎饼后只有 1 张煎饼可见，因此无法通过叠加第三张煎饼使可见煎饼数量超过 2。\n\n样例测试集 2 符合测试集 2 的限制条件，但提交的解法不会实际运行该测试集。\n\n在测试集 2 的样例中，共有 $316234143225$ 种烹饪顺序满足给定的 $\\mathbf{V}_{\\mathbf{i}}$ 序列，对 $10^{9}+7$ 取模后的结果是 $234141013$。\n\n**限制条件**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 对于所有 $i$，$1 \\leq \\mathbf{V}_{\\mathbf{i}} \\leq i$。\n\n**测试集 1（可见判定）**\n\n- 时间限制：30 秒。\n- $2 \\leq \\mathbf{N} \\leq 13$。\n\n**测试集 2（隐藏判定）**\n\n- 时间限制：40 秒。\n- $2 \\leq \\mathbf{N} \\leq 10^{5}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13038", "type": "P", "difficulty": 6, "samples": [["2\n2 4 1 1\nMGMG\nMMMG\nGMGM\nMMMM\n3 3 1 1\nMGG\nGMG\nMMM\nMMM\nMGM\nMMG", "Case #1: 3\nCase #2: 4"], ["1\n1 5 1000 1\nMGGGG\nGGGMM", "Case #1: 1003"]], "limits": {"time": [40000, 40000, 40000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2021", "二分图", "费用流", "Google Code Jam"], "title": "[GCJ 2021 #2] Retiling", "background": "", "description": "Cody-Jamal's latest artistic installment is a tiled kitchen floor that can be retiled to different patterns. The floor consists of a matrix of $\\mathbf{R}$ rows and $\\mathbf{C}$ columns of square tiles. Each tile is reversible, one side is magenta and the other one is green.\n\nTo retile the kitchen, there are two allowed operations:\n\n* flip a tile, changing its visible color from magenta to green, or vice versa, and\n* swap two adjacent tiles (horizontally or vertically, but not diagonally), without flipping either.\n\nViewing Cody-Jamal's artistic floor is free, but interacting with it is not. Performing a single flip operation costs $\\mathbf{F}$ coins, and performing a single swap operation costs $\\mathbf{S}$ coins.\n\nYou can see the current state of the floor and want to turn it into a particular pattern. What is the minimum amount of coins you need to spend to achieve your goal?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of a test case contains 4 integers: $\\mathbf{R}$, $\\mathbf{C}$, $\\mathbf{F}$ and $\\mathbf{S}$, the number of rows and columns of the floor, the cost in coins of flipping and the cost in coins of swapping, respectively. Then, $2 \\cdot \\mathbf{R}$ lines follow. The first $\\mathbf{R}$ lines contain $\\mathbf{C}$ characters each. The $j$-th character of the $i$-th of these lines represents the current state of the tile in the $i$-th row and $j$-th column. The character is $\\mathsf{M}$ if the currently visible side is magenta and $\\mathsf{G}$ otherwise. The last $\\mathbf{R}$ lines also contain $\\mathbf{C}$ characters each. The $j$-th character of the $i$-th of these lines represents the color you want for the tile in the $i$-th row and $j$-th column, using the same character code as for the current state.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum amount of coins you need to spend to perform operations that allow you to change the tile colors from their current state to your intended one.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are 5 tiles that have a different color between the current and the desired states of the floor. Since each operation can change at most 2 tiles, at least 3 operations, costing 3 coins, are needed. One way to do it with exactly 3 coins is:\n\n1. Swap the leftmost two tiles in the top row.\n2. Swap the rightmost two tiles in the top row.\n3. Flip the bottom right corner tile.\n\nThe picture below illustrates the states the floor goes through. The highlighted tile or tiles in each state are the ones being changed by the operation.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lnckx68s.png)\n\nIn Sample Case #2, there are 6 tiles that need changing. However, since only swaps can change two tiles at a time, solving it with 3 operations would require all of them to be swaps. There is no way to involve all 6 tiles in a single swap each, so we need at least 4 operations. One way to use exactly 4 operations is:\n\n1. Swap the topmost two tiles in the middle column.\n2. Flip the top right corner tile.\n3. Swap the bottommost two tiles in the rightmost column.\n4. Flip the middle tile of the leftmost column.\n\nThe picture below illustrates the states the floor goes through.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yholjw9b.png)\n\nSample Test Set 2 fits the limits of Test Set 2. It will not be run against your submitted solutions.\n\nIn the Sample Case for Test Set 2, flips are so expensive that we want to avoid them at all costs. We need at least one since our desired floor state has more magenta tiles than the current one, and swaps do not change that amount. We can do it optimally with just one flip like this:\n\n1. Swap the leftmost two tiles.\n2. Flip the rightmost tile.\n3. Swap the second and third tiles from the left.\n4. Swap the third and fourth tiles from the left.\n\nThe picture below illustrates all the states the floor goes through.\n\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7c22w7hy.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{R} \\leq 10$.\n- $1 \\leq \\mathbf{C} \\leq 10$.\n\n**Test Set 1 (11 Pts, Visible Verdict)**\n\n- $\\mathbf{F}=1$.\n- $\\mathbf{S}=1$.\n\n**Test Set 2 (23 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{F} \\leq 10^{6}$.\n- $1 \\leq \\mathbf{S} \\leq 10^{6}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #2] Retiling", "background": "", "description": "Cody-Jamal's latest artistic installment is a tiled kitchen floor that can be retiled to different patterns. The floor consists of a matrix of $\\mathbf{R}$ rows and $\\mathbf{C}$ columns of square tiles. Each tile is reversible, one side is magenta and the other one is green.\n\nTo retile the kitchen, there are two allowed operations:\n\n* flip a tile, changing its visible color from magenta to green, or vice versa, and\n* swap two adjacent tiles (horizontally or vertically, but not diagonally), without flipping either.\n\nViewing Cody-Jamal's artistic floor is free, but interacting with it is not. Performing a single flip operation costs $\\mathbf{F}$ coins, and performing a single swap operation costs $\\mathbf{S}$ coins.\n\nYou can see the current state of the floor and want to turn it into a particular pattern. What is the minimum amount of coins you need to spend to achieve your goal?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of a test case contains 4 integers: $\\mathbf{R}$, $\\mathbf{C}$, $\\mathbf{F}$ and $\\mathbf{S}$, the number of rows and columns of the floor, the cost in coins of flipping and the cost in coins of swapping, respectively. Then, $2 \\cdot \\mathbf{R}$ lines follow. The first $\\mathbf{R}$ lines contain $\\mathbf{C}$ characters each. The $j$-th character of the $i$-th of these lines represents the current state of the tile in the $i$-th row and $j$-th column. The character is $\\mathsf{M}$ if the currently visible side is magenta and $\\mathsf{G}$ otherwise. The last $\\mathbf{R}$ lines also contain $\\mathbf{C}$ characters each. The $j$-th character of the $i$-th of these lines represents the color you want for the tile in the $i$-th row and $j$-th column, using the same character code as for the current state.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum amount of coins you need to spend to perform operations that allow you to change the tile colors from their current state to your intended one.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are 5 tiles that have a different color between the current and the desired states of the floor. Since each operation can change at most 2 tiles, at least 3 operations, costing 3 coins, are needed. One way to do it with exactly 3 coins is:\n\n1. Swap the leftmost two tiles in the top row.\n2. Swap the rightmost two tiles in the top row.\n3. Flip the bottom right corner tile.\n\nThe picture below illustrates the states the floor goes through. The highlighted tile or tiles in each state are the ones being changed by the operation.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lnckx68s.png)\n\nIn Sample Case #2, there are 6 tiles that need changing. However, since only swaps can change two tiles at a time, solving it with 3 operations would require all of them to be swaps. There is no way to involve all 6 tiles in a single swap each, so we need at least 4 operations. One way to use exactly 4 operations is:\n\n1. Swap the topmost two tiles in the middle column.\n2. Flip the top right corner tile.\n3. Swap the bottommost two tiles in the rightmost column.\n4. Flip the middle tile of the leftmost column.\n\nThe picture below illustrates the states the floor goes through.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yholjw9b.png)\n\nSample Test Set 2 fits the limits of Test Set 2. It will not be run against your submitted solutions.\n\nIn the Sample Case for Test Set 2, flips are so expensive that we want to avoid them at all costs. We need at least one since our desired floor state has more magenta tiles than the current one, and swaps do not change that amount. We can do it optimally with just one flip like this:\n\n1. Swap the leftmost two tiles.\n2. Flip the rightmost tile.\n3. Swap the second and third tiles from the left.\n4. Swap the third and fourth tiles from the left.\n\nThe picture below illustrates all the states the floor goes through.\n\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7c22w7hy.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{R} \\leq 10$.\n- $1 \\leq \\mathbf{C} \\leq 10$.\n\n**Test Set 1 (11 Pts, Visible Verdict)**\n\n- $\\mathbf{F}=1$.\n- $\\mathbf{S}=1$.\n\n**Test Set 2 (23 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{F} \\leq 10^{6}$.\n- $1 \\leq \\mathbf{S} \\leq 10^{6}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #2] Retiling", "background": "", "description": "Cody-Jamal 最新的艺术装置是一个可以重新铺设不同图案的厨房瓷砖地面。地面由 $\\mathbf{R}$ 行 $\\mathbf{C}$ 列的正方形瓷砖组成。每块瓷砖都是双面的，一面是品红色（M），另一面是绿色（G）。\n\n要重新铺设厨房地面，允许进行以下两种操作：\n* **翻转**一块瓷砖，将其可见面从品红色变为绿色，或反之，每次操作花费 $\\mathbf{F}$ 枚硬币；\n* **交换**两块相邻的瓷砖（水平或垂直相邻，不包括对角线相邻），不翻转任何瓷砖，每次操作花费 $\\mathbf{S}$ 枚硬币。\n\n观看 Cody-Jamal 的艺术地面是免费的，但与之互动需要花费硬币。已知地面的当前状态和目标图案，求最少需要花费多少枚硬币才能将地面从当前状态转变为目标图案。", "inputFormat": "输入第一行包含测试用例数量 $\\mathbf{T}$。每个测试用例包含：\n1. 第一行四个整数 $\\mathbf{R}$、$\\mathbf{C}$、$\\mathbf{F}$、$\\mathbf{S}$，分别表示地面的行数、列数、翻转操作的花费和交换操作的花费；\n2. 接下来 $\\mathbf{R}$ 行，每行 $\\mathbf{C}$ 个字符，表示地面的当前状态（$\\mathsf{M}$ 表示品红色，$\\mathsf{G}$ 表示绿色）；\n3. 最后 $\\mathbf{R}$ 行，每行 $\\mathbf{C}$ 个字符，表示目标图案（字符编码与当前状态相同）。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是将地面转变为目标图案所需的最小硬币花费。\n", "hint": "**样例解释**\n\n在样例 #1 中：\n- 当前状态与目标图案有 5 处颜色不同；\n- 最少需要 3 次操作（每次操作最多改变 2 处颜色）；\n- 一种最优方案：\n  1. 交换第一行最左两块瓷砖；\n  2. 交换第一行最右两块瓷砖；\n  3. 翻转右下角瓷砖。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lnckx68s.png)\n\n在样例 #2 中：\n- 有 6 处颜色需要改变；\n- 由于只能通过交换同时改变两处颜色，最少需要 4 次操作；\n- 一种最优方案：\n  1. 交换中间列最上两块瓷砖；\n  2. 翻转右上角瓷砖；\n  3. 交换最右列最下两块瓷砖；\n  4. 翻转最左列中间瓷砖。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yholjw9b.png)\n\n测试集 2 的样例中：\n- 翻转操作非常昂贵，应尽量避免；\n- 由于目标图案比当前状态多 1 块品红色瓷砖，必须至少进行 1 次翻转；\n- 最优方案（花费 1003 枚硬币）：\n  1. 交换最左两块瓷砖；\n  2. 翻转最右瓷砖；\n  3. 交换左数第二和第三块瓷砖；\n  4. 交换左数第三和第四块瓷砖。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7c22w7hy.png)\n\n**限制条件**\n\n- $1 \\leq \\mathbf{T} \\leq 100$；\n- $1 \\leq \\mathbf{R} \\leq 10$；\n- $1 \\leq \\mathbf{C} \\leq 10$。\n\n**测试集 1（11 分，可见判定）**\n\n- $\\mathbf{F}=1$；\n- $\\mathbf{S}=1$。\n\n**测试集 2（23 分，隐藏判定）**\n\n- $1 \\leq \\mathbf{F} \\leq 10^{6}$；\n- $1 \\leq \\mathbf{S} \\leq 10^{6}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13039", "type": "P", "difficulty": 4, "samples": [["4\n1234\n0011\n07080\n0899", "Case #1: 7\nCase #2: 0\nCase #3: 620\nCase #4: 1"]], "limits": {"time": [5000, 5000, 5000], "memory": [1048576, 1048576, 1048576]}, "tags": ["贪心", "2021", "枚举", "分类讨论", "Google Code Jam"], "title": "[GCJ 2021 #3] Build-A-Pair", "background": "", "description": "You want to build a pair of positive integers. To do that, you are given a list of decimal digits to use. You must use every digit in the list exactly once, but you get to choose which ones to use for the first integer and which ones to use for the second integer. You also get to choose the order of the digits within each integer, except you cannot put a zero as the most significant (leftmost) digit in either integer. Note that you cannot choose just a zero for one integer either, because it would not be positive.\n\nFor example, you could be given the list $[1, 0, 2, 0, 4, 3]$. Two of the valid pairs you can build are $(200, 143)$ and $(3, 12400)$. The following pairs, on the other hand, are not valid:\n\n* $(0102, 34)$: has a leading zero.\n* $(0, 12340)$: has a non-positive integer.\n* $(10, 243)$ and $(12300, 47)$: the list of digits in each of these pairs is not exactly equal to the given list of digits.\n\nGiven the list of digits to use, what is the minimum absolute difference between the two built integers that can be achieved?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line describes a test case with a single string of digits $\\mathbf{D}$. Each character of $\\mathbf{D}$ is a digit you must use.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum possible absolute difference between the two integers built from $\\mathbf{D}$ according to the rules above.", "hint": "**Sample Explanation**\n\nThe optimal pair of integers to build are $31$ and $24$ for Sample Case #1, $10$ and $10$ for Sample Case #2, $700$ and $80$ for Sample Case #3, and $89$ and $90$ for Sample Case #4.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- Each character of $\\mathbf{D}$ is a decimal digit.\n- At least two characters of $\\mathbf{D}$ are not $\\emptyset$.\n\n**Test Set 1 (3 Pts, Visible Verdict)**\n\n- $2 \\leq$ the length of $\\mathbf{D} \\leq 8$.\n\n**Test Set 2 (12 Pts, Visible Verdict)**\n\n- $2 \\leq$ the length of $\\mathbf{D} \\leq 36$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #3] Build-A-Pair", "background": "", "description": "You want to build a pair of positive integers. To do that, you are given a list of decimal digits to use. You must use every digit in the list exactly once, but you get to choose which ones to use for the first integer and which ones to use for the second integer. You also get to choose the order of the digits within each integer, except you cannot put a zero as the most significant (leftmost) digit in either integer. Note that you cannot choose just a zero for one integer either, because it would not be positive.\n\nFor example, you could be given the list $[1, 0, 2, 0, 4, 3]$. Two of the valid pairs you can build are $(200, 143)$ and $(3, 12400)$. The following pairs, on the other hand, are not valid:\n\n* $(0102, 34)$: has a leading zero.\n* $(0, 12340)$: has a non-positive integer.\n* $(10, 243)$ and $(12300, 47)$: the list of digits in each of these pairs is not exactly equal to the given list of digits.\n\nGiven the list of digits to use, what is the minimum absolute difference between the two built integers that can be achieved?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line describes a test case with a single string of digits $\\mathbf{D}$. Each character of $\\mathbf{D}$ is a digit you must use.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum possible absolute difference between the two integers built from $\\mathbf{D}$ according to the rules above.", "hint": "**Sample Explanation**\n\nThe optimal pair of integers to build are $31$ and $24$ for Sample Case #1, $10$ and $10$ for Sample Case #2, $700$ and $80$ for Sample Case #3, and $89$ and $90$ for Sample Case #4.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- Each character of $\\mathbf{D}$ is a decimal digit.\n- At least two characters of $\\mathbf{D}$ are not $\\emptyset$.\n\n**Test Set 1 (3 Pts, Visible Verdict)**\n\n- $2 \\leq$ the length of $\\mathbf{D} \\leq 8$.\n\n**Test Set 2 (12 Pts, Visible Verdict)**\n\n- $2 \\leq$ the length of $\\mathbf{D} \\leq 36$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #3] Build-A-Pair", "background": "", "description": "你需要构造一对正整数。为此，你会获得一个十进制数字列表作为可用数字。你必须**恰好使用列表中的每个数字一次**，但可以自由选择哪些数字用于第一个整数，哪些数字用于第二个整数。同时，你可以自由决定每个整数内部数字的排列顺序，但**不允许在任何整数的最高位（最左侧）放置零**。请注意，你也不能选择仅包含一个零的整数，因为它不是正整数。\n\n例如，给定数字列表 $[1, 0, 2, 0, 4, 3]$。你可以构造的有效数字对包括 $(200, 143)$ 和 $(3, 12400)$。而以下数字对则是**无效的**：\n\n* $(0102, 34)$：存在前导零。\n* $(0, 12340)$：包含非正整数。\n* $(10, 243)$ 和 $(12300, 47)$：这些数字对中使用的数字列表与给定列表不完全一致。\n\n给定数字列表，如何构造一对数字，使得它们的绝对差最小？", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 行，每行描述一个测试用例，包含一个数字字符串 $\\mathbf{D}$。$\\mathbf{D}$ 的每个字符都是你必须使用的数字。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是根据上述规则从 $\\mathbf{D}$ 构造的两个整数的**最小可能绝对差**。\n", "hint": "**样例解释**\n\n最优构造的数字对为：\n- 样例 #1：$31$ 和 $24$；\n- 样例 #2：$10$ 和 $10$；\n- 样例 #3：$700$ 和 $80$；\n- 样例 #4：$89$ 和 $90$。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $\\mathbf{D}$ 的每个字符均为十进制数字。\n- $\\mathbf{D}$ 中至少有两个字符不为 $\\emptyset$。\n\n**测试集 1（3 分，可见判定）**\n\n- $2 \\leq \\mathbf{D}$ 的长度 $\\leq 8$。\n\n**测试集 2（12 分，可见判定）**\n\n- $2 \\leq \\mathbf{D}$ 的长度 $\\leq 36$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13040", "type": "P", "difficulty": 6, "samples": [["4\n4 4\n3 2 3 3\n3 3 2 3\n2 3\n1 1\n1 1 1\n2 3\n1 2\n1 1 1\n3 3\n2 0 2\n2 0 2", "Case #1: POSSIBLE\n//\\/\n\\/\\/\n///\\\n/\\//\nCase #2: IMPOSSIBLE\nCase #3: POSSIBLE\n\\\\/\n//\\\nCase #4: POSSIBLE\n/\\/\n\\\\\\\n/\\/"]], "limits": {"time": [15000, 15000, 15000], "memory": [1048576, 1048576, 1048576]}, "tags": ["图论", "2021", "Special Judge", "费用流", "Google Code Jam"], "title": "[GCJ 2021 #3] Square Free", "background": "", "description": "We have a matrix of square cells with $\\mathbf{R}$ rows and $\\mathbf{C}$ columns. We need to draw a diagonal in each cell. Exactly one of two possible diagonals must be drawn in each cell: the forward slash diagonal, which connects the bottom-left and the top-right corners of the cell, or the backslash diagonal, which connects the top-left and the bottom-right corners of the cell.\n\nFor each row and column, we want to draw a specific number of diagonals of each type. Also, after all the diagonals are drawn, the matrix should be square free. That is, there should be no squares formed using the diagonals we added.\n\nFor example, suppose we have a matrix with 4 rows and 4 columns. The number next to each row is the exact number of forward slash diagonals there must be in that row. The number below each column is the exact number of forward slash diagonals there must be in that column.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xc6yu1qy.png)\n\nThere are multiple ways to fill the matrix respecting those per-row and per-column amounts. Below we depict three possibilities:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1gul8pxa.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/xip3jkqs.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/o3qbkh80.png)\n\nThe first two matrices are not square free, while the third matrix is. In the first matrix, there is a square of side-length 2 diagonals with its vertices in the middle of each side of the matrix. In the second matrix, there is a square of side-length 1 diagonal drawn in the bottom-right corner. In the third matrix, there is no square. The third matrix would then be a valid drawing according to all the rules.\n\nGiven the size of the matrix and the exact number of forward slash diagonals that must be drawn in each row and column, produce any square free matrix that satisfies the row and column constraints, or say that one does not exist.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of exactly three lines. The first line of a test case contains $\\mathbf{R}$ and $\\mathbf{C}$, the number of rows and columns of the matrix. The second line of a test case contains $\\mathbf{R}$ integers $\\mathbf{S}_1, \\mathbf{S}_2, \\ldots, \\mathbf{S}_\\mathbf{R}$. $\\mathbf{S}_i$ is the exact number of forward slash diagonals that must be drawn in the $i$-th row from the top. The third line of a test case contains $\\mathbf{C}$ integers $\\mathbf{D}_1, \\mathbf{D}_2, \\ldots, \\mathbf{D}_\\mathbf{C}$. $\\mathbf{D}_i$ is the exact number of forward slash diagonals that must be drawn in the $i$-th column from the left.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is `IMPOSSIBLE` if there is no filled matrix that follows all rules and `POSSIBLE` otherwise. If you output `POSSIBLE`, output $\\mathbf{R}$ more lines with $\\mathbf{C}$ characters each. The $j$-th character of the $i$-th of these lines must be `/` if the diagonal drawn in the $i$-th row from the top and $j$-th column from the left in your proposed matrix is a forward slash diagonal, and `\\` otherwise. Your proposed matrix must be valid according to all rules.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one explained above.\n\nIn Sample Case #2, there must be a total of 2 forward slash diagonals according to the sum of the row totals, but a total of 3 according to the sum of the column totals. It is therefore impossible to follow all rules.\n\nIn Sample Case #3 the only matrices that follow the row and column totals are the following:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qrbza4hc.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/439fpaug.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/ib6vqil8.png)\n\nSince the first two contain a square, the third one is the only valid output for this case.\n\nIn Sample Case #4 there is only one way to fill the matrix that follows the row and column totals, shown in the picture below. Note that it produces a single rectangle, shown in blue in the picture. But, since that rectangle is not a square, the matrix is square free.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ljxlouhx.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $0 \\leq \\mathbf{S}_i \\leq \\mathbf{C}$, for all $i$.\n- $0 \\leq \\mathbf{D}_i \\leq \\mathbf{R}$, for all $i$.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{R} \\leq 6$.\n- $2 \\leq \\mathbf{C} \\leq 6$.\n\n**Test Set 2 (13 Pts, Hidden Verdict)**\n\n- $2 \\leq \\mathbf{R} \\leq 20$.\n- $2 \\leq \\mathbf{C} \\leq 20$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #3] Square Free", "background": "", "description": "We have a matrix of square cells with $\\mathbf{R}$ rows and $\\mathbf{C}$ columns. We need to draw a diagonal in each cell. Exactly one of two possible diagonals must be drawn in each cell: the forward slash diagonal, which connects the bottom-left and the top-right corners of the cell, or the backslash diagonal, which connects the top-left and the bottom-right corners of the cell.\n\nFor each row and column, we want to draw a specific number of diagonals of each type. Also, after all the diagonals are drawn, the matrix should be square free. That is, there should be no squares formed using the diagonals we added.\n\nFor example, suppose we have a matrix with 4 rows and 4 columns. The number next to each row is the exact number of forward slash diagonals there must be in that row. The number below each column is the exact number of forward slash diagonals there must be in that column.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xc6yu1qy.png)\n\nThere are multiple ways to fill the matrix respecting those per-row and per-column amounts. Below we depict three possibilities:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1gul8pxa.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/xip3jkqs.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/o3qbkh80.png)\n\nThe first two matrices are not square free, while the third matrix is. In the first matrix, there is a square of side-length 2 diagonals with its vertices in the middle of each side of the matrix. In the second matrix, there is a square of side-length 1 diagonal drawn in the bottom-right corner. In the third matrix, there is no square. The third matrix would then be a valid drawing according to all the rules.\n\nGiven the size of the matrix and the exact number of forward slash diagonals that must be drawn in each row and column, produce any square free matrix that satisfies the row and column constraints, or say that one does not exist.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of exactly three lines. The first line of a test case contains $\\mathbf{R}$ and $\\mathbf{C}$, the number of rows and columns of the matrix. The second line of a test case contains $\\mathbf{R}$ integers $\\mathbf{S}_1, \\mathbf{S}_2, \\ldots, \\mathbf{S}_\\mathbf{R}$. $\\mathbf{S}_i$ is the exact number of forward slash diagonals that must be drawn in the $i$-th row from the top. The third line of a test case contains $\\mathbf{C}$ integers $\\mathbf{D}_1, \\mathbf{D}_2, \\ldots, \\mathbf{D}_\\mathbf{C}$. $\\mathbf{D}_i$ is the exact number of forward slash diagonals that must be drawn in the $i$-th column from the left.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is `IMPOSSIBLE` if there is no filled matrix that follows all rules and `POSSIBLE` otherwise. If you output `POSSIBLE`, output $\\mathbf{R}$ more lines with $\\mathbf{C}$ characters each. The $j$-th character of the $i$-th of these lines must be `/` if the diagonal drawn in the $i$-th row from the top and $j$-th column from the left in your proposed matrix is a forward slash diagonal, and `\\` otherwise. Your proposed matrix must be valid according to all rules.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one explained above.\n\nIn Sample Case #2, there must be a total of 2 forward slash diagonals according to the sum of the row totals, but a total of 3 according to the sum of the column totals. It is therefore impossible to follow all rules.\n\nIn Sample Case #3 the only matrices that follow the row and column totals are the following:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qrbza4hc.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/439fpaug.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/ib6vqil8.png)\n\nSince the first two contain a square, the third one is the only valid output for this case.\n\nIn Sample Case #4 there is only one way to fill the matrix that follows the row and column totals, shown in the picture below. Note that it produces a single rectangle, shown in blue in the picture. But, since that rectangle is not a square, the matrix is square free.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ljxlouhx.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $0 \\leq \\mathbf{S}_i \\leq \\mathbf{C}$, for all $i$.\n- $0 \\leq \\mathbf{D}_i \\leq \\mathbf{R}$, for all $i$.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{R} \\leq 6$.\n- $2 \\leq \\mathbf{C} \\leq 6$.\n\n**Test Set 2 (13 Pts, Hidden Verdict)**\n\n- $2 \\leq \\mathbf{R} \\leq 20$.\n- $2 \\leq \\mathbf{C} \\leq 20$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #3] Square Free", "background": "", "description": "我们有一个由正方形单元格组成的矩阵，包含 $\\mathbf{R}$ 行和 $\\mathbf{C}$ 列。我们需要在每个单元格中绘制一条对角线。每个单元格必须且只能绘制两种对角线之一：**正斜杠对角线（/）**（连接单元格的左下角和右上角）或 **反斜杠对角线（\\）**（连接单元格的左上角和右下角）。\n\n对于每一行和每一列，我们需要绘制特定数量的正斜杠对角线。此外，在所有对角线绘制完成后，矩阵必须满足**无方格**条件。即，不能存在由所绘制的对角线构成的正方形。\n\n例如，假设我们有一个 4 行 4 列的矩阵。每行旁边的数字表示该行必须绘制的正斜杠对角线的确切数量，每列下方的数字表示该列必须绘制的正斜杠对角线的确切数量。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xc6yu1qy.png)\n\n存在多种方式填充该矩阵以满足每行和每列的要求。以下是三种可能的填充方式：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1gul8pxa.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/xip3jkqs.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/o3qbkh80.png)\n\n前两个矩阵**不满足无方格条件**，而第三个矩阵满足。在第一个矩阵中，存在一个边长为 2 的对角线组成的正方形，其顶点位于矩阵各边的中点；在第二个矩阵中，右下角存在一个边长为 1 的对角线组成的正方形；第三个矩阵则不存在任何此类正方形。因此，第三个矩阵是符合所有规则的合法填充方案。\n\n给定矩阵的大小以及每行和每列必须绘制的正斜杠对角线的数量，请构造一个满足行和列约束的无方格矩阵，或者判断这样的矩阵不存在。\n", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。接下来是 $\\mathbf{T}$ 组测试用例。每组测试用例包含三行：\n1. 第一行包含 $\\mathbf{R}$ 和 $\\mathbf{C}$，分别表示矩阵的行数和列数。\n2. 第二行包含 $\\mathbf{R}$ 个整数 $\\mathbf{S}_1, \\mathbf{S}_2, \\ldots, \\mathbf{S}_\\mathbf{R}$，其中 $\\mathbf{S}_i$ 表示第 $i$ 行（从上到下）必须绘制的正斜杠对角线的数量。\n3. 第三行包含 $\\mathbf{C}$ 个整数 $\\mathbf{D}_1, \\mathbf{D}_2, \\ldots, \\mathbf{D}_\\mathbf{C}$，其中 $\\mathbf{D}_i$ 表示第 $i$ 列（从左到右）必须绘制的正斜杠对角线的数量。\n", "outputFormat": "对于每组测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 为 `IMPOSSIBLE`（如果不存在满足所有规则的矩阵）或 `POSSIBLE`（如果存在）。如果输出 `POSSIBLE`，则还需额外输出 $\\mathbf{R}$ 行，每行包含 $\\mathbf{C}$ 个字符。其中第 $i$ 行的第 $j$ 个字符为 `/`（表示该单元格绘制正斜杠对角线）或 `\\`（表示绘制反斜杠对角线）。你的方案必须满足所有规则。\n", "hint": "**样例解释**\n\n样例 #1 是题目描述中提到的示例。\n\n在样例 #2 中，根据行的总和，需要绘制 2 条正斜杠对角线，但根据列的总和，需要绘制 3 条。因此无法满足所有规则。\n\n样例 #3 中唯一满足行和列约束的矩阵如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qrbza4hc.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/439fpaug.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/ib6vqil8.png)\n\n由于前两个矩阵包含正方形，第三个矩阵是唯一合法的输出。\n\n在样例 #4 中，只有一种填充方式满足行和列约束（如下图所示）。注意，它产生了一个矩形（图中蓝色部分），但由于该矩形不是正方形，因此矩阵满足无方格条件。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ljxlouhx.png)\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 对于所有 $i$，$0 \\leq \\mathbf{S}_i \\leq \\mathbf{C}$。\n- 对于所有 $i$，$0 \\leq \\mathbf{D}_i \\leq \\mathbf{R}$。\n\n**测试集 1（7 分，可见判定）**\n\n- $2 \\leq \\mathbf{R} \\leq 6$。\n- $2 \\leq \\mathbf{C} \\leq 6$。\n\n**测试集 2（13 分，隐藏判定）**\n\n- $2 \\leq \\mathbf{R} \\leq 20$。\n- $2 \\leq \\mathbf{C} \\leq 20$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13041", "type": "P", "difficulty": 7, "samples": [["2\n4\n0 0\n0 1\n1 1\n1 0\n1 2\n3 4\n5\n0 0\n0 1\n1 1\n1 0\n2 3\n1 2\n3 5", "Case #1: 3\n1 4\n2 3\n4 2\nCase #2: 6\n5 4\n2 4\n5 2\n1 4\n4 3\n3 2"]], "limits": {"time": [60000, 60000, 90000], "memory": [1048576, 1048576, 1048576]}, "tags": ["计算几何", "2021", "Special Judge", "分治", "凸包", "Google Code Jam"], "title": "[GCJ 2021 #3] Fence Design", "background": "", "description": "You are hired as a temporary employee of the Fence Construction Company and have been tasked with finishing the design of the fencing for a field. Each fence must run in a straight line between two poles. Each pole occupies a single point and the location of each pole is fixed. No three poles are collinear. Fences cannot intersect each other, except possibly at their endpoints (the poles).\n\nThe design was started by someone else, but they quit the project after adding exactly two fences. You need to finish their design. To impress your bosses and clients, you want the design to have as many fences as possible, regardless of their lengths.\n\nGiven the positions of the poles and the already-built fences, please find a way to add as many fences as possible such that no pair of fences (new or existing) intersect each other, except possibly at their endpoints (the poles).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a single line containing an integer $\\mathbf{N}$, indicating the number of poles. Then, $\\mathbf{N}$ lines follow. The $i$-th of these lines contains two integers $\\mathbf{X}_i$ and $\\mathbf{Y}_i$, representing the X and Y coordinates of the $i$-th pole's position. The last two lines for each test case represent the two existing fences. These two lines contain two integers each: $\\mathbf{P}_k$ and $\\mathbf{Q}_k$, representing that the $k$-th existing fence runs between the $\\mathbf{P}_k$-th and the $\\mathbf{Q}_k$-th pole (poles are numbered starting from 1).\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of fences that can be added to the design (not including the existing ones). Then, output $y$ more lines. Each line must contain two distinct integers $i$ and $j$ (both between 1 and $\\mathbf{N}$, inclusive), representing a different fence that connects the $i$-th and $j$-th poles. No pair of the $y + 2$ fences (the existing fences as well as the ones you have added) may overlap, except possibly at their endpoints.", "hint": "**Sample Explanation**\n\nThe following pictures show the poles and fences in the given samples. The fences with the wider blue line on them are the existing ones, and the rest show the way of adding a maximum number of fences shown in the sample output.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j0yr6b9n.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/is24xybt.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 50$.\n- $-10^9 \\leq \\mathbf{X}_i \\leq 10^9$, for all $i$.\n- $-10^9 \\leq \\mathbf{Y}_i \\leq 10^9$, for all $i$.\n- $(\\mathbf{X}_i, \\mathbf{Y}_i) \\neq (\\mathbf{X}_j, \\mathbf{Y}_j)$, for all $i \\neq j$.\n- $1 \\leq \\mathbf{P}_k < \\mathbf{Q}_k \\leq \\mathbf{N}$, for all $k$.\n- The existing fences do not intersect, except possibly at their endpoints.\n- No three poles are collinear.\n\n**Test Set 1 (11 Pts, Visible Verdict)**\n\n- Time limit: 60 seconds.\n- $4 \\leq \\mathbf{N} \\leq 100$.\n\n**Test Set 2 (19 Pts, Hidden Verdict)**\n\n- Time limit: 90 seconds.\n- $4 \\leq \\mathbf{N} \\leq 10^5$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #3] Fence Design", "background": "", "description": "You are hired as a temporary employee of the Fence Construction Company and have been tasked with finishing the design of the fencing for a field. Each fence must run in a straight line between two poles. Each pole occupies a single point and the location of each pole is fixed. No three poles are collinear. Fences cannot intersect each other, except possibly at their endpoints (the poles).\n\nThe design was started by someone else, but they quit the project after adding exactly two fences. You need to finish their design. To impress your bosses and clients, you want the design to have as many fences as possible, regardless of their lengths.\n\nGiven the positions of the poles and the already-built fences, please find a way to add as many fences as possible such that no pair of fences (new or existing) intersect each other, except possibly at their endpoints (the poles).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a single line containing an integer $\\mathbf{N}$, indicating the number of poles. Then, $\\mathbf{N}$ lines follow. The $i$-th of these lines contains two integers $\\mathbf{X}_i$ and $\\mathbf{Y}_i$, representing the X and Y coordinates of the $i$-th pole's position. The last two lines for each test case represent the two existing fences. These two lines contain two integers each: $\\mathbf{P}_k$ and $\\mathbf{Q}_k$, representing that the $k$-th existing fence runs between the $\\mathbf{P}_k$-th and the $\\mathbf{Q}_k$-th pole (poles are numbered starting from 1).\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of fences that can be added to the design (not including the existing ones). Then, output $y$ more lines. Each line must contain two distinct integers $i$ and $j$ (both between 1 and $\\mathbf{N}$, inclusive), representing a different fence that connects the $i$-th and $j$-th poles. No pair of the $y + 2$ fences (the existing fences as well as the ones you have added) may overlap, except possibly at their endpoints.", "hint": "**Sample Explanation**\n\nThe following pictures show the poles and fences in the given samples. The fences with the wider blue line on them are the existing ones, and the rest show the way of adding a maximum number of fences shown in the sample output.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j0yr6b9n.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/is24xybt.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 50$.\n- $-10^9 \\leq \\mathbf{X}_i \\leq 10^9$, for all $i$.\n- $-10^9 \\leq \\mathbf{Y}_i \\leq 10^9$, for all $i$.\n- $(\\mathbf{X}_i, \\mathbf{Y}_i) \\neq (\\mathbf{X}_j, \\mathbf{Y}_j)$, for all $i \\neq j$.\n- $1 \\leq \\mathbf{P}_k < \\mathbf{Q}_k \\leq \\mathbf{N}$, for all $k$.\n- The existing fences do not intersect, except possibly at their endpoints.\n- No three poles are collinear.\n\n**Test Set 1 (11 Pts, Visible Verdict)**\n\n- Time limit: 60 seconds.\n- $4 \\leq \\mathbf{N} \\leq 100$.\n\n**Test Set 2 (19 Pts, Hidden Verdict)**\n\n- Time limit: 90 seconds.\n- $4 \\leq \\mathbf{N} \\leq 10^5$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #3] Fence Design", "background": "", "description": "你被临时雇佣为围栏建设公司的员工，负责完成一块场地的围栏设计工作。每条围栏必须沿着直线连接两根立柱。每根立柱占据一个固定点，且**任意三根立柱不共线**。围栏之间**不能相互交叉**，但可以在端点（立柱位置）处相连。\n\n前员工在项目中已经铺设了两条围栏后就离职了。现在需要由你来完成剩余设计。为了让老板和客户满意，你希望在不考虑围栏长度的情况下，尽可能多地添加围栏。\n\n给定所有立柱的位置和已建好的两条围栏，请找出可以添加的**最大数量**的围栏，使得所有围栏（包括已有的和新增的）两两之间不交叉（仅在端点处相连是允许的）。", "inputFormat": "输入的第一行包含测试用例数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 组测试用例：\n1. 每组测试用例的第一行是一个整数 $\\mathbf{N}$，表示立柱数量。\n2. 接下来 $\\mathbf{N}$ 行，每行包含两个整数 $\\mathbf{X}_i$ 和 $\\mathbf{Y}_i$，表示第 $i$ 根立柱的坐标。\n3. 最后两行分别描述已有的两条围栏，每行包含两个整数 $\\mathbf{P}_k$ 和 $\\mathbf{Q}_k$，表示第 $k$ 条围栏连接第 $\\mathbf{P}_k$ 根和第 $\\mathbf{Q}_k$ 根立柱（立柱编号从 1 开始）。\n", "outputFormat": "对于每组测试用例：\n1. 首先输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是能添加的围栏最大数量（不包括已有围栏）。\n2. 接着输出 $y$ 行，每行包含两个不同的整数 $i$ 和 $j$（$1 \\leq i, j \\leq \\mathbf{N}$），表示新增的围栏连接第 $i$ 根和第 $j$ 根立柱。\n3. 所有围栏（包括已有的和新增的）必须满足两两不交叉（仅在端点处允许相连）。", "hint": "**样例解释**\n\n下图展示了样例中的立柱和围栏布局。蓝色加粗线条表示已有围栏，其余线条表示样例输出中添加的围栏方案：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j0yr6b9n.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/is24xybt.png)\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 50$。\n- 对所有 $i$，$-10^9 \\leq \\mathbf{X}_i, \\mathbf{Y}_i \\leq 10^9$。\n- 对所有 $i \\neq j$，$(\\mathbf{X}_i, \\mathbf{Y}_i) \\neq (\\mathbf{X}_j, \\mathbf{Y}_j)$。\n- 对所有 $k$，$1 \\leq \\mathbf{P}_k < \\mathbf{Q}_k \\leq \\mathbf{N}$。\n- 已有围栏之间不交叉（仅在端点处允许相连）。\n- 任意三根立柱不共线。\n\n**测试集 1（11 分，可见判定）**\n\n- 时间限制：60 秒。\n- $4 \\leq \\mathbf{N} \\leq 100$。\n\n**测试集 2（19 分，隐藏判定）**\n\n- 时间限制：90 秒。\n- $4 \\leq \\mathbf{N} \\leq 10^5$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13042", "type": "P", "difficulty": 7, "samples": [["3\n2 2 2\n2 1 1 1\n4 3 2\n3 1 1 4\n5 100 3\n2 4 1 1 4 5 2 5", "Case #1: 6\nCase #2: 144\nCase #3: 991661422"]], "limits": {"time": [30000, 30000, 30000], "memory": [1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2021", "多项式", "组合数学", "拉格朗日插值法", "Google Code Jam"], "title": "[GCJ 2021 #3] Binary Search Game", "background": "", "description": "Alice and Bob are going to play the Binary Search game. The game is played on a board consisting of a single row of $2^{\\mathbf{L}}$ cells. Each cell contains an integer between 1 and $\\mathbf{N}$, inclusive. There are also $\\mathbf{N}$ cards numbered 1 through $\\mathbf{N}$. Before the game starts, the referee writes an integer between 1 and $\\mathbf{M}$, inclusive, on each card, in one of the $\\mathbf{M}^{\\mathbf{N}}$ ways in which that can be done. Alice and Bob know the integers in the cells and on each card before they start playing.\n\nThe game proceeds alternating turns, with Alice having the first turn. There are $\\mathbf{L}$ turns in total, which means Alice plays $\\lceil \\mathbf{L}/2 \\rceil$ turns and Bob plays $\\lfloor \\mathbf{L}/2 \\rfloor$ turns. During a turn, a player can eliminate either the leftmost half or the rightmost half of the remaining cells. For example, let us consider a board that contains the numbers $[2, 4, 1, 1, 4, 5, 2, 5]$. In her first turn, Alice must choose to eliminate one half, leaving either $[2, 4, 1, 1]$ or $[4, 5, 2, 5]$. If she eliminates the leftmost half and leaves $[4, 5, 2, 5]$, then Bob must choose between leaving $[4, 5]$ and $[2, 5]$. If he were to leave $[2, 5]$, the game's final turn would have Alice choosing between $[2]$ and $[5]$.\n\nWhen the game is over, they look at the number $X$ in the only remaining cell. The score of the game is the integer written on card number $X$. In the example above, if Alice were to eliminate $[5]$ and leave $[2]$ in her final turn, the score of the game would be the number the referee wrote on card number 2.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l71ofi6o.png)\n\nAlice plays optimally to maximize the score of the game, while Bob plays optimally to minimize it. They are given a fixed board with integers $\\mathbf{A}_1$, $\\mathbf{A}_2$, …, $\\mathbf{A}_{2^{\\mathbf{L}}}$ in its cells. For maximal fairness, they will play $\\mathbf{M}^{\\mathbf{N}}$ games, and the referee will choose a different way to write integers on the cards for each one. That means that for any given way of writing integers on the cards, Alice and Bob will play exactly one game with it. Given the game parameters and the fixed board contents, please determine the sum of the scores of all those games. Since the output can be a really big number, we only ask you to output the remainder of dividing the result by the prime $10^9 + 7$ ($1000000007$).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of exactly two lines. The first line of each test case contains the three integers $\\mathbf{N}$, $\\mathbf{M}$, and $\\mathbf{L}$. The second line contains $2^{\\mathbf{L}}$ integers $\\mathbf{A}_1$, $\\mathbf{A}_2$, …, $\\mathbf{A}_{2^{\\mathbf{L}}}$, where $\\mathbf{A}_i$ is the integer contained in the $i$-th cell from the left of the board.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the sum of scores of all $\\mathbf{M}^{\\mathbf{N}}$ games, modulo the prime $10^9 + 7$ ($1000000007$).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are 4 ways to write the integers on the blank cards: $[1, 1], [1, 2], [2, 1]$, and $[2, 2]$. In the first two ways, no matter what Alice chooses in her first turn, Bob can always make the number in the last remaining cell be a 1, and card 1 contains a 1, which means those two games have a score of 1. In the last two ways, Alice can start by eliminating the leftmost half of the board, leaving $[1, 1]$ for Bob, who then has no choice but to leave $[1]$ at the end. Since card 1 has a 2 on it in these ways, the score of both of these games is 2. The sum of all scores is therefore $1 + 1 + 2 + 2 = 6$.\n\n**Limits**\n\n- $1 \\leq \\text{T} \\leq 12$.\n- $1 \\leq \\text{L} \\leq 5$.\n- $1 \\leq \\text{A}_i \\leq \\text{N}$, for all $i$.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- $1 \\leq \\text{N} \\leq 8$.\n- $1 \\leq \\text{M} \\leq 100$.\n\n**Test Set 2 (26 Pts, Hidden Verdict)**\n\n- $1 \\leq \\text{N} \\leq 32$.\n- $1 \\leq \\text{M} \\leq 10^9$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #3] Binary Search Game", "background": "", "description": "Alice and Bob are going to play the Binary Search game. The game is played on a board consisting of a single row of $2^{\\mathbf{L}}$ cells. Each cell contains an integer between 1 and $\\mathbf{N}$, inclusive. There are also $\\mathbf{N}$ cards numbered 1 through $\\mathbf{N}$. Before the game starts, the referee writes an integer between 1 and $\\mathbf{M}$, inclusive, on each card, in one of the $\\mathbf{M}^{\\mathbf{N}}$ ways in which that can be done. Alice and Bob know the integers in the cells and on each card before they start playing.\n\nThe game proceeds alternating turns, with Alice having the first turn. There are $\\mathbf{L}$ turns in total, which means Alice plays $\\lceil \\mathbf{L}/2 \\rceil$ turns and Bob plays $\\lfloor \\mathbf{L}/2 \\rfloor$ turns. During a turn, a player can eliminate either the leftmost half or the rightmost half of the remaining cells. For example, let us consider a board that contains the numbers $[2, 4, 1, 1, 4, 5, 2, 5]$. In her first turn, Alice must choose to eliminate one half, leaving either $[2, 4, 1, 1]$ or $[4, 5, 2, 5]$. If she eliminates the leftmost half and leaves $[4, 5, 2, 5]$, then Bob must choose between leaving $[4, 5]$ and $[2, 5]$. If he were to leave $[2, 5]$, the game's final turn would have Alice choosing between $[2]$ and $[5]$.\n\nWhen the game is over, they look at the number $X$ in the only remaining cell. The score of the game is the integer written on card number $X$. In the example above, if Alice were to eliminate $[5]$ and leave $[2]$ in her final turn, the score of the game would be the number the referee wrote on card number 2.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l71ofi6o.png)\n\nAlice plays optimally to maximize the score of the game, while Bob plays optimally to minimize it. They are given a fixed board with integers $\\mathbf{A}_1$, $\\mathbf{A}_2$, …, $\\mathbf{A}_{2^{\\mathbf{L}}}$ in its cells. For maximal fairness, they will play $\\mathbf{M}^{\\mathbf{N}}$ games, and the referee will choose a different way to write integers on the cards for each one. That means that for any given way of writing integers on the cards, Alice and Bob will play exactly one game with it. Given the game parameters and the fixed board contents, please determine the sum of the scores of all those games. Since the output can be a really big number, we only ask you to output the remainder of dividing the result by the prime $10^9 + 7$ ($1000000007$).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of exactly two lines. The first line of each test case contains the three integers $\\mathbf{N}$, $\\mathbf{M}$, and $\\mathbf{L}$. The second line contains $2^{\\mathbf{L}}$ integers $\\mathbf{A}_1$, $\\mathbf{A}_2$, …, $\\mathbf{A}_{2^{\\mathbf{L}}}$, where $\\mathbf{A}_i$ is the integer contained in the $i$-th cell from the left of the board.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the sum of scores of all $\\mathbf{M}^{\\mathbf{N}}$ games, modulo the prime $10^9 + 7$ ($1000000007$).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are 4 ways to write the integers on the blank cards: $[1, 1], [1, 2], [2, 1]$, and $[2, 2]$. In the first two ways, no matter what Alice chooses in her first turn, Bob can always make the number in the last remaining cell be a 1, and card 1 contains a 1, which means those two games have a score of 1. In the last two ways, Alice can start by eliminating the leftmost half of the board, leaving $[1, 1]$ for Bob, who then has no choice but to leave $[1]$ at the end. Since card 1 has a 2 on it in these ways, the score of both of these games is 2. The sum of all scores is therefore $1 + 1 + 2 + 2 = 6$.\n\n**Limits**\n\n- $1 \\leq \\text{T} \\leq 12$.\n- $1 \\leq \\text{L} \\leq 5$.\n- $1 \\leq \\text{A}_i \\leq \\text{N}$, for all $i$.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- $1 \\leq \\text{N} \\leq 8$.\n- $1 \\leq \\text{M} \\leq 100$.\n\n**Test Set 2 (26 Pts, Hidden Verdict)**\n\n- $1 \\leq \\text{N} \\leq 32$.\n- $1 \\leq \\text{M} \\leq 10^9$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #3] Binary Search Game", "background": "", "description": "**Alice** 和 **Bob** 将要玩一个名为二分搜索的游戏。游戏在一个由 $2^{\\mathbf{L}}$ 个格子组成的单行棋盘上进行。每个格子中包含一个介于 1 到 $\\mathbf{N}$ 之间的整数（包括 1 和 $\\mathbf{N}$）。此外，还有编号为 1 到 $\\mathbf{N}$ 的 $\\mathbf{N}$ 张卡片。在游戏开始前，裁判会以 $\\mathbf{M}^{\\mathbf{N}}$ 种可能的分配方式之一，在每张卡片上写下一个介于 1 到 $\\mathbf{M}$ 之间的整数（包括 1 和 $\\mathbf{M}$）。**Alice** 和 **Bob** 在游戏开始前知道棋盘上每个格子的整数以及每张卡片上的数字。\n\n游戏以轮流进行的方式展开，**Alice** 先手。总共有 $\\mathbf{L}$ 轮，这意味着 **Alice** 会进行 $\\lceil \\mathbf{L}/2 \\rceil$ 轮，而 **Bob** 会进行 $\\lfloor \\mathbf{L}/2 \\rfloor$ 轮。在每一轮中，玩家可以选择消除剩余格子中最左侧的一半或最右侧的一半。例如，假设棋盘上的数字为 $[2, 4, 1, 1, 4, 5, 2, 5]$。在 **Alice** 的第一轮中，她必须选择消除其中一半，留下 $[2, 4, 1, 1]$ 或 $[4, 5, 2, 5]$。如果她选择消除最左侧的一半并留下 $[4, 5, 2, 5]$，那么 **Bob** 必须在下一轮中选择留下 $[4, 5]$ 或 $[2, 5]$。如果他选择留下 $[2, 5]$，那么在最后一轮中，**Alice** 将需要在 $[2]$ 和 $[5]$ 之间做出选择。\n\n游戏结束时，他们查看唯一剩下的格子中的数字 $X$。游戏的分数就是编号为 $X$ 的卡片上所写的整数。在上述例子中，如果 **Alice** 在最后一轮中消除 $[5]$ 并留下 $[2]$，那么游戏的分数就是裁判在编号为 2 的卡片上写的数字。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l71ofi6o.png)\n\n**Alice** 会采取最优策略以最大化游戏分数，而 **Bob** 则会采取最优策略以最小化分数。他们在一个固定的棋盘上进行游戏，棋盘上的格子中分别写着整数 $\\mathbf{A}_1$, $\\mathbf{A}_2$, …, $\\mathbf{A}_{2^{\\mathbf{L}}}$。为了确保最大限度的公平性，他们会进行 $\\mathbf{M}^{\\mathbf{N}}$ 局游戏，每局游戏中裁判会以不同的方式在卡片上写数字。这意味着对于每一种可能的卡片分配方式，**Alice** 和 **Bob** 都会恰好进行一局游戏。给定游戏参数和固定的棋盘内容，请计算所有游戏的分数之和。由于输出可能是一个非常大的数字，我们只要求你输出结果对质数 $10^9 + 7$（即 $1000000007$）取模后的余数。", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例包含恰好两行。第一行包含三个整数 $\\mathbf{N}$、$\\mathbf{M}$ 和 $\\mathbf{L}$。第二行包含 $2^{\\mathbf{L}}$ 个整数 $\\mathbf{A}_1$, $\\mathbf{A}_2$, …, $\\mathbf{A}_{2^{\\mathbf{L}}}$，其中 $\\mathbf{A}_i$ 表示棋盘上从左数第 $i$ 个格子中的整数。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是所有 $\\mathbf{M}^{\\mathbf{N}}$ 局游戏的分数之和模 $10^9 + 7$（即 $1000000007$）后的结果。\n", "hint": "**样例解释**\n\n在样例 #1 中，有 4 种卡片分配方式：$[1, 1]$、$[1, 2]$、$[2, 1]$ 和 $[2, 2]$。在前两种分配方式中，无论 **Alice** 在首轮如何选择，**Bob** 总能使得最终剩下的格子中的数字为 1，而卡片 1 上的数字为 1，因此这两局游戏的分数均为 1。在后两种分配方式中，**Alice** 可以通过在首轮消除棋盘最左侧的一半，留下 $[1, 1]$，此时 **Bob** 别无选择，只能留下 $[1]$。由于在这两种分配方式中卡片 1 上的数字为 2，因此这两局游戏的分数均为 2。所有分数的总和为 $1 + 1 + 2 + 2 = 6$。\n\n**数据范围**\n\n- $1 \\leq \\text{T} \\leq 12$。\n- $1 \\leq \\text{L} \\leq 5$。\n- 对于所有 $i$，满足 $1 \\leq \\text{A}_i \\leq \\text{N}$。\n\n**测试集 1（9 分，可见判定结果）**\n\n- $1 \\leq \\text{N} \\leq 8$。\n- $1 \\leq \\text{M} \\leq 100$。\n\n**测试集 2（26 分，隐藏判定结果）**\n\n- $1 \\leq \\text{N} \\leq 32$。\n- $1 \\leq \\text{M} \\leq 10^9$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13043", "type": "P", "difficulty": 6, "samples": [["4\n1 5 5\n3 -1 2 2\n1 2 -10 5\n2 100000000 50000000\n80000000 0 40000000 40000000\n5000001 2500000 500 -501\n15000000 5000000 501 -400\n2 10 10\n0 2 4 2\n2 2 -4 5\n4 6 -6 5\n3 622460462 608203753\n486076103 36373156 502082214 284367873\n98895371 126167607 823055173 -740793281\n26430289 116311281 -398612375 -223683435\n46950301 278229490 766767410 -550292032", "Case #1: 5/1\nCase #2: 288309900002019999899/320000000000000000\nCase #3: 37/4\nCase #4: 216757935773010988373334129808263414106891/187470029508637421883991794137967"]], "limits": {"time": [45000, 45000], "memory": [1048576, 1048576]}, "tags": ["数学", "高精度", "2021", "扫描线", "Google Code Jam"], "title": "[GCJ 2021 Finals] Cutting Cake", "background": "", "description": "Today is your and your twin sibling's birthday. To celebrate, you got a rectangular cake to share. The cake is decorated with $\\mathbf{N}$ triangular patches of icing (which may overlap). All the icing patches were created with the same triangular mold, so they have the same shape and orientation. Although you and your twin are very similar, your tastes in icing are much different. This difference is formalized by each of you having a different enjoyment value for each patch of icing. Specifically, your enjoyment value for eating the entire $i$-th patch of icing is $\\mathbf{A}_i$, and your twin's is $\\mathbf{B}_i$. If someone eats part of a patch, they get enjoyment proportional to the eaten area. For example, if you eat $\\frac{2}{3}$ of the area of the $i$-th icing patch, you would get $\\frac{2\\mathbf{A}_i}{3}$ enjoyment from it. Note that there may be some flavors of icing that you or your twin do not enjoy, so the $\\mathbf{A}_i$ and/or $\\mathbf{B}_i$ values can be negative.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bb02prmd.png)\n\nYou will cut the cake into two rectangular pieces by making a single vertical cut (parallel to the Y-axis). After cutting the cake, you will eat the left piece and your twin will eat the right piece. Your total enjoyment is the sum of the enjoyment you get from all icing to the left of the cut. Similarly, your twin's enjoyment is the sum of the enjoyment they get from all icing to the right of the cut.\n\nTo be as fair as possible, you want to cut the cake such that the absolute value of the difference between your total enjoyment and your twin's total enjoyment is as small as possible. Given the $\\mathbf{N}$ triangular icing patches on a rectangular cake, what is the minimum possible absolute value of the difference between your and your twin's total enjoyments you can get?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing three positive integers, $\\mathbf{N}$, $\\mathbf{W}$, and $\\mathbf{H}$, representing the number of icing patches on the cake and the width and height of the top of the cake, respectively. The bottom-left corner of the cake is located at $(0,0)$ and the top-right corner is at $(\\mathbf{W}, \\mathbf{H})$. Then, a line describing the icing patch mold follows. This line contains four integers: $\\mathbf{P}$, $\\mathbf{Q}$, $\\mathbf{R}$, and $\\mathbf{S}$. The icing patch mold is a triangle with vertices at $(0,0)$, $(\\mathbf{P}, \\mathbf{Q})$, and $(\\mathbf{R}, \\mathbf{S})$. Then, $\\mathbf{N}$ lines follow. The $i$-th of these lines contains four integers $\\mathbf{X}_i$, $\\mathbf{Y}_i$, $\\mathbf{A}_i$, and $\\mathbf{B}_i$. The $i$-th patch is a triangle with vertices at $(\\mathbf{X}_i, \\mathbf{Y}_i)$, $(\\mathbf{X}_i + \\mathbf{P}, \\mathbf{Y}_i + \\mathbf{Q})$, and $(\\mathbf{X}_i + \\mathbf{R}, \\mathbf{Y}_i + \\mathbf{S})$. You would get $\\mathbf{A}_i$ enjoyment from eating it and your twin would get $\\mathbf{B}_i$ enjoyment.", "outputFormat": "For each test case, output one line containing `Case #x: y/z`, where $x$ is the test case number (starting from 1) and $\\frac{y}{z}$ is the minimum absolute value of the difference between your and your twin's total enjoyment that can be achieved with a single vertical cut as an irreducible fraction (that is, $z$ must be positive and of minimum possible value).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there is a single icing patch. The optimal cut is to the left of the patch. You will eat no icing and receive 0 enjoyment. Your twin will eat all of the icing patch and receive 5 enjoyment from it. The absolute value of the difference between your and your twin's enjoyments is $|0 - 5| = 5$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0l7tbto8.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/nfrgziry.png)\n\nIn Sample Case #2, there are two icing patches. The optimal cut is at $X = 15099999.99$. Notice that the numerator and denominator of the answer can get very large.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wer6hjfq.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/bjelfqv7.png)\n\nIn Sample Case #3, there are two icing patches. The optimal cut is at $X = 4$. You will eat 75% of the first icing patch and receive $-3$ enjoyment from it. Your twin will eat 25% of the first icing patch and all of the second icing patch getting $5 \\cdot 0.25 + 5 = 6.25$ enjoyment. The absolute value of the difference between your and your twin's enjoyments is $|-3 - 6.25| = 9.25 = \\frac{37}{4}$.\n\nNotice that cutting at $X = 1$ would give you $0$ enjoyment and your twin $10$ enjoyment. While both of those values are greater than the corresponding enjoyment when cutting at $X = 4$, the difference between them is $10 > 9.25$, which means cutting at $X = 4$ is preferable anyway.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x0dpaoy4.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/kgtk2lkh.png)\n\nIn Sample Case #4, there are three icing patches. The optimal cut is at $X \\approx 521241077.6027$.\n\n**Test Set 1 (20 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{N} \\leq 100$.\n- $3 \\leq \\mathbf{W} \\leq 10^{9}$.\n- $3 \\leq \\mathbf{H} \\leq 10^{9}$.\n- $-10^{9} \\leq \\mathbf{A}_{i} \\leq 10^{9}$, for all $i$.\n- $-10^{9} \\leq \\mathbf{B}_{i} \\leq 10^{9}$, for all $i$.\n- $0 \\leq \\mathbf{P} \\leq 10^{9}$.\n- $-10^{9} \\leq \\mathbf{Q} \\leq 10^{9}$.\n- $0 \\leq \\mathbf{R} \\leq 10^{9}$.\n- $-10^{9} \\leq \\mathbf{S} \\leq 10^{9}$.\n- The three vertices of the mold $(0, 0)$, $(\\mathbf{P}, \\mathbf{Q})$, and $(\\mathbf{R}, \\mathbf{S})$ are not collinear.\n- The three vertices of each triangular icing patch are strictly inside the cake's borders. Formally:\n  - $1 \\leq \\mathbf{X}_{i} \\leq \\mathbf{W} - \\max(\\mathbf{P}, \\mathbf{R}) - 1$, for all $i$, and\n  - $\\max(0, -\\mathbf{Q}, -\\mathbf{S}) + 1 \\leq \\mathbf{Y}_{i} \\leq \\mathbf{H} - \\max(0, \\mathbf{Q}, \\mathbf{S}) - 1$, for all $i$.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 Finals] Cutting Cake", "background": "", "description": "Today is your and your twin sibling's birthday. To celebrate, you got a rectangular cake to share. The cake is decorated with $\\mathbf{N}$ triangular patches of icing (which may overlap). All the icing patches were created with the same triangular mold, so they have the same shape and orientation. Although you and your twin are very similar, your tastes in icing are much different. This difference is formalized by each of you having a different enjoyment value for each patch of icing. Specifically, your enjoyment value for eating the entire $i$-th patch of icing is $\\mathbf{A}_i$, and your twin's is $\\mathbf{B}_i$. If someone eats part of a patch, they get enjoyment proportional to the eaten area. For example, if you eat $\\frac{2}{3}$ of the area of the $i$-th icing patch, you would get $\\frac{2\\mathbf{A}_i}{3}$ enjoyment from it. Note that there may be some flavors of icing that you or your twin do not enjoy, so the $\\mathbf{A}_i$ and/or $\\mathbf{B}_i$ values can be negative.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bb02prmd.png)\n\nYou will cut the cake into two rectangular pieces by making a single vertical cut (parallel to the Y-axis). After cutting the cake, you will eat the left piece and your twin will eat the right piece. Your total enjoyment is the sum of the enjoyment you get from all icing to the left of the cut. Similarly, your twin's enjoyment is the sum of the enjoyment they get from all icing to the right of the cut.\n\nTo be as fair as possible, you want to cut the cake such that the absolute value of the difference between your total enjoyment and your twin's total enjoyment is as small as possible. Given the $\\mathbf{N}$ triangular icing patches on a rectangular cake, what is the minimum possible absolute value of the difference between your and your twin's total enjoyments you can get?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing three positive integers, $\\mathbf{N}$, $\\mathbf{W}$, and $\\mathbf{H}$, representing the number of icing patches on the cake and the width and height of the top of the cake, respectively. The bottom-left corner of the cake is located at $(0,0)$ and the top-right corner is at $(\\mathbf{W}, \\mathbf{H})$. Then, a line describing the icing patch mold follows. This line contains four integers: $\\mathbf{P}$, $\\mathbf{Q}$, $\\mathbf{R}$, and $\\mathbf{S}$. The icing patch mold is a triangle with vertices at $(0,0)$, $(\\mathbf{P}, \\mathbf{Q})$, and $(\\mathbf{R}, \\mathbf{S})$. Then, $\\mathbf{N}$ lines follow. The $i$-th of these lines contains four integers $\\mathbf{X}_i$, $\\mathbf{Y}_i$, $\\mathbf{A}_i$, and $\\mathbf{B}_i$. The $i$-th patch is a triangle with vertices at $(\\mathbf{X}_i, \\mathbf{Y}_i)$, $(\\mathbf{X}_i + \\mathbf{P}, \\mathbf{Y}_i + \\mathbf{Q})$, and $(\\mathbf{X}_i + \\mathbf{R}, \\mathbf{Y}_i + \\mathbf{S})$. You would get $\\mathbf{A}_i$ enjoyment from eating it and your twin would get $\\mathbf{B}_i$ enjoyment.", "outputFormat": "For each test case, output one line containing `Case #x: y/z`, where $x$ is the test case number (starting from 1) and $\\frac{y}{z}$ is the minimum absolute value of the difference between your and your twin's total enjoyment that can be achieved with a single vertical cut as an irreducible fraction (that is, $z$ must be positive and of minimum possible value).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there is a single icing patch. The optimal cut is to the left of the patch. You will eat no icing and receive 0 enjoyment. Your twin will eat all of the icing patch and receive 5 enjoyment from it. The absolute value of the difference between your and your twin's enjoyments is $|0 - 5| = 5$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0l7tbto8.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/nfrgziry.png)\n\nIn Sample Case #2, there are two icing patches. The optimal cut is at $X = 15099999.99$. Notice that the numerator and denominator of the answer can get very large.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wer6hjfq.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/bjelfqv7.png)\n\nIn Sample Case #3, there are two icing patches. The optimal cut is at $X = 4$. You will eat 75% of the first icing patch and receive $-3$ enjoyment from it. Your twin will eat 25% of the first icing patch and all of the second icing patch getting $5 \\cdot 0.25 + 5 = 6.25$ enjoyment. The absolute value of the difference between your and your twin's enjoyments is $|-3 - 6.25| = 9.25 = \\frac{37}{4}$.\n\nNotice that cutting at $X = 1$ would give you $0$ enjoyment and your twin $10$ enjoyment. While both of those values are greater than the corresponding enjoyment when cutting at $X = 4$, the difference between them is $10 > 9.25$, which means cutting at $X = 4$ is preferable anyway.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x0dpaoy4.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/kgtk2lkh.png)\n\nIn Sample Case #4, there are three icing patches. The optimal cut is at $X \\approx 521241077.6027$.\n\n**Test Set 1 (20 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{N} \\leq 100$.\n- $3 \\leq \\mathbf{W} \\leq 10^{9}$.\n- $3 \\leq \\mathbf{H} \\leq 10^{9}$.\n- $-10^{9} \\leq \\mathbf{A}_{i} \\leq 10^{9}$, for all $i$.\n- $-10^{9} \\leq \\mathbf{B}_{i} \\leq 10^{9}$, for all $i$.\n- $0 \\leq \\mathbf{P} \\leq 10^{9}$.\n- $-10^{9} \\leq \\mathbf{Q} \\leq 10^{9}$.\n- $0 \\leq \\mathbf{R} \\leq 10^{9}$.\n- $-10^{9} \\leq \\mathbf{S} \\leq 10^{9}$.\n- The three vertices of the mold $(0, 0)$, $(\\mathbf{P}, \\mathbf{Q})$, and $(\\mathbf{R}, \\mathbf{S})$ are not collinear.\n- The three vertices of each triangular icing patch are strictly inside the cake's borders. Formally:\n  - $1 \\leq \\mathbf{X}_{i} \\leq \\mathbf{W} - \\max(\\mathbf{P}, \\mathbf{R}) - 1$, for all $i$, and\n  - $\\max(0, -\\mathbf{Q}, -\\mathbf{S}) + 1 \\leq \\mathbf{Y}_{i} \\leq \\mathbf{H} - \\max(0, \\mathbf{Q}, \\mathbf{S}) - 1$, for all $i$.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 Finals] Cutting Cake", "background": "", "description": "今天是你和你的双胞胎兄弟姐妹的生日。为了庆祝，你们得到了一个长方形的蛋糕来分享。蛋糕上装饰有 $\\mathbf{N}$ 个三角形的糖霜区域（这些区域可能重叠）。所有的糖霜区域都是用同一个三角形模具制作的，因此它们的形状和方向完全相同。尽管你和你的双胞胎非常相似，但你们对糖霜的喜好却大不相同。具体来说，吃掉第 $i$ 个糖霜区域的全部，你会获得 $\\mathbf{A}_i$ 的享受值，而你的双胞胎会获得 $\\mathbf{B}_i$ 的享受值。如果有人吃掉了一部分糖霜区域，他们获得的享受值与吃掉的部分面积成正比。例如，如果你吃掉了第 $i$ 个糖霜区域的 $\\frac{2}{3}$，你会获得 $\\frac{2\\mathbf{A}_i}{3}$ 的享受值。注意，有些糖霜口味可能是你或你的双胞胎不喜欢的，因此 $\\mathbf{A}_i$ 和/或 $\\mathbf{B}_i$ 的值可能是负数。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bb02prmd.png)\n\n你将通过一次垂直切割（平行于 Y 轴）将蛋糕分成两个长方形部分。切完蛋糕后，你将吃掉左边的部分，而你的双胞胎将吃掉右边的部分。你的总享受值是你从切割线左侧所有糖霜区域获得的享受值之和。类似地，你的双胞胎的总享受值是他们从切割线右侧所有糖霜区域获得的享受值之和。\n\n为了尽可能公平，你希望切割蛋糕使得你和你的双胞胎的总享受值之差的绝对值尽可能小。给定长方形蛋糕上的 $\\mathbf{N}$ 个三角形糖霜区域，你和你的双胞胎的总享受值之差的最小可能绝对值是多少？", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含三个正整数 $\\mathbf{N}$、$\\mathbf{W}$ 和 $\\mathbf{H}$，分别表示蛋糕上的糖霜区域数量、蛋糕顶部的宽度和高度。蛋糕的左下角位于 $(0,0)$，右上角位于 $(\\mathbf{W}, \\mathbf{H})$。接下来的一行描述糖霜区域模具，包含四个整数 $\\mathbf{P}$、$\\mathbf{Q}$、$\\mathbf{R}$ 和 $\\mathbf{S}$。糖霜区域模具是一个顶点位于 $(0,0)$、$(\\mathbf{P}, \\mathbf{Q})$ 和 $(\\mathbf{R}, \\mathbf{S})$ 的三角形。随后是 $\\mathbf{N}$ 行，每行包含四个整数 $\\mathbf{X}_i$、$\\mathbf{Y}_i$、$\\mathbf{A}_i$ 和 $\\mathbf{B}_i$。第 $i$ 个糖霜区域是一个顶点位于 $(\\mathbf{X}_i, \\mathbf{Y}_i)$、$(\\mathbf{X}_i + \\mathbf{P}, \\mathbf{Y}_i + \\mathbf{Q})$ 和 $(\\mathbf{X}_i + \\mathbf{R}, \\mathbf{Y}_i + \\mathbf{S})$ 的三角形。你会从吃掉它中获得 $\\mathbf{A}_i$ 的享受值，而你的双胞胎会获得 $\\mathbf{B}_i$ 的享受值。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y/z`，其中 $x$ 是测试用例编号（从 1 开始），$\\frac{y}{z}$ 是通过一次垂直切割可以实现你和你的双胞胎总享受值之差的最小绝对值，且必须为不可约分式（即 $z$ 必须为正且尽可能小）。\n", "hint": "**样例解释**\n\n在样例 #1 中，只有一个糖霜区域。最优切割位于该区域的左侧。你将不会吃到任何糖霜，享受值为 0。你的双胞胎会吃掉整个糖霜区域并获得 5 的享受值。你和你的双胞胎享受值之差的绝对值为 $|0 - 5| = 5$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0l7tbto8.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/nfrgziry.png)\n\n在样例 #2 中，有两个糖霜区域。最优切割位于 $X = 15099999.99$ 处。注意答案的分子和分母可能非常大。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wer6hjfq.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/bjelfqv7.png)\n\n在样例 #3 中，有两个糖霜区域。最优切割位于 $X = 4$ 处。你将吃掉第一个糖霜区域的 75%，获得 $-3$ 的享受值。你的双胞胎会吃掉第一个糖霜区域的 25% 和整个第二个糖霜区域，获得 $5 \\times 0.25 + 5 = 6.25$ 的享受值。你和你的双胞胎享受值之差的绝对值为 $|-3 - 6.25| = 9.25 = \\frac{37}{4}$。\n\n注意，在 $X = 1$ 处切割会让你获得 $0$ 享受值，而你的双胞胎获得 $10$ 享受值。虽然这两个值都比在 $X = 4$ 处切割时的对应值大，但它们之间的差值为 $10 > 9.25$，因此仍然选择在 $X = 4$ 处切割更优。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x0dpaoy4.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/kgtk2lkh.png)\n\n在样例 #4 中，有三个糖霜区域。最优切割位于 $X \\approx 521241077.6027$ 处。\n\n**测试集 1（20 分，可见判定）**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{N} \\leq 100$。\n- $3 \\leq \\mathbf{W} \\leq 10^{9}$。\n- $3 \\leq \\mathbf{H} \\leq 10^{9}$。\n- $-10^{9} \\leq \\mathbf{A}_{i} \\leq 10^{9}$，对所有 $i$ 成立。\n- $-10^{9} \\leq \\mathbf{B}_{i} \\leq 10^{9}$，对所有 $i$ 成立。\n- $0 \\leq \\mathbf{P} \\leq 10^{9}$。\n- $-10^{9} \\leq \\mathbf{Q} \\leq 10^{9}$。\n- $0 \\leq \\mathbf{R} \\leq 10^{9}$。\n- $-10^{9} \\leq \\mathbf{S} \\leq 10^{9}$。\n- 模具的三个顶点 $(0, 0)$、$(\\mathbf{P}, \\mathbf{Q})$ 和 $(\\mathbf{R}, \\mathbf{S})$ 不共线。\n- 每个三角形糖霜区域的三个顶点严格位于蛋糕的边界内。即：\n  - $1 \\leq \\mathbf{X}_{i} \\leq \\mathbf{W} - \\max(\\mathbf{P}, \\mathbf{R}) - 1$，对所有 $i$ 成立；\n  - $\\max(0, -\\mathbf{Q}, -\\mathbf{S}) + 1 \\leq \\mathbf{Y}_{i} \\leq \\mathbf{H} - \\max(0, \\mathbf{Q}, \\mathbf{S}) - 1$，对所有 $i$ 成立。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13044", "type": "P", "difficulty": 6, "samples": [["2\n3 3 5\n1 2\n2 3\n3 1\nE 1 2 1\nE 3 3 1\nD 1 3 2\nD 1 3 3\nE 1 2 2\n5 8 10\n1 5\n5 3\n4 1\n3 2\n2 4\n2 5\n2 1\n1 4\nE 1 8 2\nD 4 8 2\nE 3 5 1\nE 1 1 3\nE 1 1 1\nE 5 8 2\nD 1 8 3\nD 5 8 4\nD 4 5 1\nE 3 4 1", "Case #1: 3 X 2 X 3\nCase #2: 3 X 1 1 X X X 3 X 5"]], "limits": {"time": [10000, 10000, 120000], "memory": [1048576, 1048576, 1048576]}, "tags": ["图论", "2021", "哈希 hashing", "Google Code Jam"], "title": "[GCJ 2021 Finals] Slide Circuits", "background": "", "description": "Gooli is a huge company that owns $\\mathbf{B}$ buildings in a hilly area. Five years ago, Gooli built slides that allowed employees to go from one building to another (they are not bidirectional), starting a tradition of building slides between buildings. Currently, $\\mathbf{S}$ slides exist.\n\nMelek is Gooli's Head of Transportation and a problem-solving enthusiast. She was tasked with keeping the slides enjoyable to use. The idea she came up with was disabling some slides such that only circuits remained. A circuit is a set of two or more buildings $b_{1}, b_{2}, \\ldots, b_{k}$ such that there is exactly one slide enabled from building $b_{i}$ to building $b_{i+1}$, for each $i$, and exactly one slide enabled from building $b_{k}$ to building $b_{1}$. No other slides from or to any of those buildings should be enabled, to prevent misdirection. A state of the slides is then called fun if each building belongs to exactly one circuit.\n\nSlides in Gooli's campus are numbered with integers between 1 and $\\mathbf{S}$, inclusive. Melek created a slide controlling console that supports two operations: enable and disable. Both operations receive three parameters $\\ell, r$, and $m$ and perform the operation on each slide $x$ such that $\\ell \\leq x \\leq r$ and $x$ is a multiple of $m$. An enable operation is valid only if all affected slides are in a disabled state right before the operation is performed. Similarly, a disable operation is valid only if all affected slides are in an enabled state right before the operation is performed.\n\nThe following picture illustrates a possible succession of states and operations. The layout has 3 buildings and 3 slides. Slides are light grey when disabled and dark grey when enabled.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9vcfdd3y.png)\n\n1. Initial state. All sides are disabled.\n2. After enable operation with $\\ell=1$, $r=2$, and $m=1$.\n3. After enable operation with $\\ell=3$, $r=3$, and $m=1$.\n4. After disable operation with $\\ell=1, r=3$, and $m=2$.\n5. After disable operation with $\\ell=1, r=3$, and $m=3$.\n6. After enable operation with $\\ell=1, r=2$, and $m=2$.\n\nUnfortunately, Sult, Melek's cat, found the console and started performing several valid enable and disable operations. After every console operation performed by Sult, Melek wants to know if the state of the slides can be made fun by enabling exactly one currently disabled slide. Note that Melek does not actually enable this slide.\n\nIn the picture above, we can see that after the first, third, and last operations, Melek could enable the only disabled slide and get to a fun state. After the second operation, there are two issues. One issue is that there are no currently disabled slides, so Melek cannot enable any. Additionally, the state is already fun, so even if there were additional disabled slides, enabling anything would result in a not fun state. After the fourth operation, there are two disabled slides, but enabling either would not yield a fun state.\n\nAll slides are initially disabled, then Sult performs its operations one at a time. After each of Sult's operations, determine which disabled slide, if any, Melek can enable to put the slides in a fun state.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing three integers $\\mathbf{B}$, $\\mathbf{S}$, and $\\mathbf{N}$: the number of buildings, slides, and operations to process, respectively. Then, $\\mathbf{S}$ lines follow. The $i$-th of these lines contains two integers $\\mathbf{X}_{i}$ and $\\mathbf{Y}_{i}$, indicating that the slide with number $i$ goes from building $\\mathbf{X}_{i}$ to building $\\mathbf{Y}_{i}$. Finally, $\\mathbf{N}$ lines represent the operations. The $j$-th of these lines contains a character $\\mathbf{A}_{j}$ and three integers $\\mathbf{L}_{j}, \\mathbf{R}_{j}$, and $\\mathbf{M}_{j}$, describing the $j$-th operation. $\\mathbf{A}_{j}$ describes the type of operation using an uppercase $\\mathbf{E}$ for enable and an uppercase $\\mathbf{D}$ for disable. The operation is to be performed on slides with numbers that are simultaneously a multiple of $\\mathbf{M}_{j}$ and between $\\mathbf{L}_{j}$ and $\\mathbf{R}_{j}$, inclusive.", "outputFormat": "For each test case, output one line containing `Case #x:` $y_{1}\\ y_{2}\\ \\ldots\\ y_{N}$, where $x$ is the test case number (starting from 1) and $y_{j}$ is an uppercase $\\mathbf{X}$ if there is no way to turn the state of slides created by the first $j$ console operations into a fun state by enabling exactly one disabled slide. Otherwise, $y_{j}$ should be an integer representing that enabling the $y_{j}$-th slide would turn the state created by the first $j$ console operations into a fun state.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one depicted in the problem statement.\n\nThe following picture shows the building and slide layout of Sample Case #2.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gc127wx5.png)\n\nThe sets of enabled slides after each operation are:\n\n- $\\{2,4,6,8\\}$,\n- $\\{2\\}$,\n- $\\{2,3,4,5\\}$,\n- $\\{2,3,4,5\\}$,\n- $\\{1,2,3,4,5\\}$,\n- $\\{1,2,3,4,5,6,8\\}$,\n- $\\{1,2,4,5,8\\}$,\n- $\\{1,2,4,5\\}$,\n- $\\{1,2\\}$, and\n- $\\{1,2,3,4\\}$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{X}_{i} \\leq \\mathbf{B}$, for all $i$.\n- $1 \\leq \\mathbf{Y}_{i} \\leq \\mathbf{B}$, for all $i$.\n- $\\mathbf{X}_{i} \\neq \\mathbf{Y}_{i}$, for all $i$.\n- $\\left(\\mathbf{X}_{i}, \\mathbf{Y}_{i}\\right) \\neq\\left(\\mathbf{X}_{j}, \\mathbf{Y}_{j}\\right)$, for all $i \\neq j$.\n- $\\mathbf{A}_{j}$ is either uppercase $\\mathbf{E}$ or uppercase $\\mathbf{D}$, for all $j$.\n- $1 \\leq \\mathbf{L}_{j} \\leq \\mathbf{R}_{j} \\leq \\mathbf{S}$, for all $j$.\n- $1 \\leq \\mathbf{M}_{j} \\leq \\mathbf{S}$, for all $j$.\n- Each operation is valid.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- Time limit: 10 seconds.\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{B} \\leq 100$.\n- $2 \\leq \\mathbf{S} \\leq 1000$.\n- $1 \\leq \\mathbf{N} \\leq 1000$.\n\n**Test Set 2 (20 Pts, Hidden Verdict)**\n\n- Time limit: 120 seconds.\n- $1 \\leq \\mathbf{T} \\leq 30$.\n- $2 \\leq \\mathbf{B} \\leq 3 \\times 10^{4}$.\n- $2 \\leq \\mathbf{S} \\leq 3 \\times 10^{5}$.\n- $1 \\leq \\mathbf{N} \\leq 3 \\times 10^{5}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 Finals] Slide Circuits", "background": "", "description": "Gooli is a huge company that owns $\\mathbf{B}$ buildings in a hilly area. Five years ago, Gooli built slides that allowed employees to go from one building to another (they are not bidirectional), starting a tradition of building slides between buildings. Currently, $\\mathbf{S}$ slides exist.\n\nMelek is Gooli's Head of Transportation and a problem-solving enthusiast. She was tasked with keeping the slides enjoyable to use. The idea she came up with was disabling some slides such that only circuits remained. A circuit is a set of two or more buildings $b_{1}, b_{2}, \\ldots, b_{k}$ such that there is exactly one slide enabled from building $b_{i}$ to building $b_{i+1}$, for each $i$, and exactly one slide enabled from building $b_{k}$ to building $b_{1}$. No other slides from or to any of those buildings should be enabled, to prevent misdirection. A state of the slides is then called fun if each building belongs to exactly one circuit.\n\nSlides in Gooli's campus are numbered with integers between 1 and $\\mathbf{S}$, inclusive. Melek created a slide controlling console that supports two operations: enable and disable. Both operations receive three parameters $\\ell, r$, and $m$ and perform the operation on each slide $x$ such that $\\ell \\leq x \\leq r$ and $x$ is a multiple of $m$. An enable operation is valid only if all affected slides are in a disabled state right before the operation is performed. Similarly, a disable operation is valid only if all affected slides are in an enabled state right before the operation is performed.\n\nThe following picture illustrates a possible succession of states and operations. The layout has 3 buildings and 3 slides. Slides are light grey when disabled and dark grey when enabled.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9vcfdd3y.png)\n\n1. Initial state. All sides are disabled.\n2. After enable operation with $\\ell=1$, $r=2$, and $m=1$.\n3. After enable operation with $\\ell=3$, $r=3$, and $m=1$.\n4. After disable operation with $\\ell=1, r=3$, and $m=2$.\n5. After disable operation with $\\ell=1, r=3$, and $m=3$.\n6. After enable operation with $\\ell=1, r=2$, and $m=2$.\n\nUnfortunately, Sult, Melek's cat, found the console and started performing several valid enable and disable operations. After every console operation performed by Sult, Melek wants to know if the state of the slides can be made fun by enabling exactly one currently disabled slide. Note that Melek does not actually enable this slide.\n\nIn the picture above, we can see that after the first, third, and last operations, Melek could enable the only disabled slide and get to a fun state. After the second operation, there are two issues. One issue is that there are no currently disabled slides, so Melek cannot enable any. Additionally, the state is already fun, so even if there were additional disabled slides, enabling anything would result in a not fun state. After the fourth operation, there are two disabled slides, but enabling either would not yield a fun state.\n\nAll slides are initially disabled, then Sult performs its operations one at a time. After each of Sult's operations, determine which disabled slide, if any, Melek can enable to put the slides in a fun state.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing three integers $\\mathbf{B}$, $\\mathbf{S}$, and $\\mathbf{N}$: the number of buildings, slides, and operations to process, respectively. Then, $\\mathbf{S}$ lines follow. The $i$-th of these lines contains two integers $\\mathbf{X}_{i}$ and $\\mathbf{Y}_{i}$, indicating that the slide with number $i$ goes from building $\\mathbf{X}_{i}$ to building $\\mathbf{Y}_{i}$. Finally, $\\mathbf{N}$ lines represent the operations. The $j$-th of these lines contains a character $\\mathbf{A}_{j}$ and three integers $\\mathbf{L}_{j}, \\mathbf{R}_{j}$, and $\\mathbf{M}_{j}$, describing the $j$-th operation. $\\mathbf{A}_{j}$ describes the type of operation using an uppercase $\\mathbf{E}$ for enable and an uppercase $\\mathbf{D}$ for disable. The operation is to be performed on slides with numbers that are simultaneously a multiple of $\\mathbf{M}_{j}$ and between $\\mathbf{L}_{j}$ and $\\mathbf{R}_{j}$, inclusive.", "outputFormat": "For each test case, output one line containing `Case #x:` $y_{1}\\ y_{2}\\ \\ldots\\ y_{N}$, where $x$ is the test case number (starting from 1) and $y_{j}$ is an uppercase $\\mathbf{X}$ if there is no way to turn the state of slides created by the first $j$ console operations into a fun state by enabling exactly one disabled slide. Otherwise, $y_{j}$ should be an integer representing that enabling the $y_{j}$-th slide would turn the state created by the first $j$ console operations into a fun state.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one depicted in the problem statement.\n\nThe following picture shows the building and slide layout of Sample Case #2.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gc127wx5.png)\n\nThe sets of enabled slides after each operation are:\n\n- $\\{2,4,6,8\\}$,\n- $\\{2\\}$,\n- $\\{2,3,4,5\\}$,\n- $\\{2,3,4,5\\}$,\n- $\\{1,2,3,4,5\\}$,\n- $\\{1,2,3,4,5,6,8\\}$,\n- $\\{1,2,4,5,8\\}$,\n- $\\{1,2,4,5\\}$,\n- $\\{1,2\\}$, and\n- $\\{1,2,3,4\\}$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{X}_{i} \\leq \\mathbf{B}$, for all $i$.\n- $1 \\leq \\mathbf{Y}_{i} \\leq \\mathbf{B}$, for all $i$.\n- $\\mathbf{X}_{i} \\neq \\mathbf{Y}_{i}$, for all $i$.\n- $\\left(\\mathbf{X}_{i}, \\mathbf{Y}_{i}\\right) \\neq\\left(\\mathbf{X}_{j}, \\mathbf{Y}_{j}\\right)$, for all $i \\neq j$.\n- $\\mathbf{A}_{j}$ is either uppercase $\\mathbf{E}$ or uppercase $\\mathbf{D}$, for all $j$.\n- $1 \\leq \\mathbf{L}_{j} \\leq \\mathbf{R}_{j} \\leq \\mathbf{S}$, for all $j$.\n- $1 \\leq \\mathbf{M}_{j} \\leq \\mathbf{S}$, for all $j$.\n- Each operation is valid.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- Time limit: 10 seconds.\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{B} \\leq 100$.\n- $2 \\leq \\mathbf{S} \\leq 1000$.\n- $1 \\leq \\mathbf{N} \\leq 1000$.\n\n**Test Set 2 (20 Pts, Hidden Verdict)**\n\n- Time limit: 120 seconds.\n- $1 \\leq \\mathbf{T} \\leq 30$.\n- $2 \\leq \\mathbf{B} \\leq 3 \\times 10^{4}$.\n- $2 \\leq \\mathbf{S} \\leq 3 \\times 10^{5}$.\n- $1 \\leq \\mathbf{N} \\leq 3 \\times 10^{5}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 Finals] Slide Circuits", "background": "", "description": "**Gooli** 是一家大型公司，在一个丘陵地区拥有 $\\mathbf{B}$ 栋建筑。五年前，**Gooli** 建造了允许员工从一栋建筑滑向另一栋建筑的滑道（单向），由此开启了在建筑间建造滑道的传统。目前共有 $\\mathbf{S}$ 条滑道。\n\n**Melek** 是 **Gooli** 的交通主管，也是一位热衷解决问题的爱好者。她接到任务要保持滑道的使用乐趣。她想出的办法是禁用部分滑道，使得仅保留电路。一个电路是指由两栋或更多建筑 $b_{1}, b_{2}, \\ldots, b_{k}$ 组成的集合，其中对于每个 $i$，从建筑 $b_{i}$ 到建筑 $b_{i+1}$ 恰好有一条启用的滑道，且从建筑 $b_{k}$ 到建筑 $b_{1}$ 恰好有一条启用的滑道。这些建筑的其他任何滑道都不应启用，以防止误导。此时滑道的状态被称为 **有趣状态**，当且仅当每栋建筑恰好属于一个电路。\n\n**Gooli** 园区内的滑道用 1 到 $\\mathbf{S}$ 的整数编号。**Melek** 创建了一个滑道控制台，支持两种操作：**启用** 和 **禁用**。两种操作都接收三个参数 $\\ell$、$r$ 和 $m$，并对所有满足 $\\ell \\leq x \\leq r$ 且 $x$ 是 $m$ 的倍数的滑道 $x$ 执行操作。启用操作仅在操作执行前所有受影响的滑道处于禁用状态时才有效。类似地，禁用操作仅在操作执行前所有受影响的滑道处于启用状态时才有效。\n\n下图展示了可能的操作序列和状态变化。布局包含 3 栋建筑和 3 条滑道。禁用状态的滑道显示为浅灰色，启用状态的滑道显示为深灰色。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9vcfdd3y.png)\n\n1. 初始状态。所有滑道禁用。\n2. 执行启用操作 $\\ell=1$，$r=2$，$m=1$ 后。\n3. 执行启用操作 $\\ell=3$，$r=3$，$m=1$ 后。\n4. 执行禁用操作 $\\ell=1$，$r=3$，$m=2$ 后。\n5. 执行禁用操作 $\\ell=1$，$r=3$，$m=3$ 后。\n6. 执行启用操作 $\\ell=1$，$r=2$，$m=2$ 后。\n\n不幸的是，**Melek** 的猫 **Sult** 发现了控制台，并开始执行一系列有效的启用和禁用操作。在 **Sult** 执行每次操作后，**Melek** 想知道是否可以通过 **恰好启用一条当前禁用的滑道** 使滑道达到有趣状态。注意 **Melek** 实际上并不会启用这条滑道。\n\n在上图中可以看到，在第一次、第三次和最后一次操作后，**Melek** 可以启用唯一禁用的滑道，使状态变为有趣状态。第二次操作后存在两个问题：一是当前没有禁用的滑道，因此 **Melek** 无法启用任何滑道；此外，状态已经是有趣状态，即使有其他禁用的滑道，启用任何滑道都会导致状态不再有趣。第四次操作后，有两条禁用的滑道，但启用任意一条都无法得到有趣状态。\n\n所有滑道最初都是禁用的，然后 **Sult** 依次执行操作。在 **Sult** 的每次操作后，确定 **Melek** 可以启用哪条禁用的滑道（如果有的话）使滑道达到有趣状态。\n", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含三个整数 $\\mathbf{B}$、$\\mathbf{S}$ 和 $\\mathbf{N}$，分别表示建筑数量、滑道数量和处理的操作数量。接下来 $\\mathbf{S}$ 行，每行包含两个整数 $\\mathbf{X}_{i}$ 和 $\\mathbf{Y}_{i}$，表示编号为 $i$ 的滑道从建筑 $\\mathbf{X}_{i}$ 通向建筑 $\\mathbf{Y}_{i}$。最后 $\\mathbf{N}$ 行描述操作。第 $j$ 行包含一个字符 $\\mathbf{A}_{j}$ 和三个整数 $\\mathbf{L}_{j}$、$\\mathbf{R}_{j}$ 和 $\\mathbf{M}_{j}$，描述第 $j$ 个操作。$\\mathbf{A}_{j}$ 表示操作类型，大写字母 $\\mathbf{E}$ 表示启用，大写字母 $\\mathbf{D}$ 表示禁用。操作会对所有编号是 $\\mathbf{M}_{j}$ 的倍数且介于 $\\mathbf{L}_{j}$ 和 $\\mathbf{R}_{j}$ 之间的滑道执行。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x:` $y_{1} y_{2} ... y_{N}$，其中 $x$ 是测试用例编号（从 1 开始），$y_{j}$ 是一个大写字母 $\\mathbf{X}$（如果在前 $j$ 次操作后无法通过启用恰好一条禁用滑道使状态变为有趣状态），否则 $y_{j}$ 是一个整数，表示启用编号为 $y_{j}$ 的滑道可以使前 $j$ 次操作后的状态变为有趣状态。\n", "hint": "**样例解释**\n\n样例 #1 对应题目描述中的图示案例。\n\n下图展示了样例 #2 的建筑和滑道布局：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gc127wx5.png)\n\n每次操作后启用的滑道集合依次为：\n\n1. $\\{2,4,6,8\\}$\n2. $\\{2\\}$\n3. $\\{2,3,4,5\\}$\n4. $\\{2,3,4,5\\}$\n5. $\\{1,2,3,4,5\\}$\n6. $\\{1,2,3,4,5,6,8\\}$\n7. $\\{1,2,4,5,8\\}$\n8. $\\{1,2,4,5\\}$\n9. $\\{1,2\\}$\n10. $\\{1,2,3,4\\}$\n\n**数据范围**\n\n- 对所有 $i$，$1 \\leq \\mathbf{X}_{i} \\leq \\mathbf{B}$\n- 对所有 $i$，$1 \\leq \\mathbf{Y}_{i} \\leq \\mathbf{B}$\n- 对所有 $i$，$\\mathbf{X}_{i} \\neq \\mathbf{Y}_{i}$\n- 对所有 $i \\neq j$，$\\left(\\mathbf{X}_{i}, \\mathbf{Y}_{i}\\right) \\neq\\left(\\mathbf{X}_{j}, \\mathbf{Y}_{j}\\right)$\n- 对所有 $j$，$\\mathbf{A}_{j}$ 为大写字母 $\\mathbf{E}$ 或 $\\mathbf{D}$\n- 对所有 $j$，$1 \\leq \\mathbf{L}_{j} \\leq \\mathbf{R}_{j} \\leq \\mathbf{S}$\n- 对所有 $j$，$1 \\leq \\mathbf{M}_{j} \\leq \\mathbf{S}$\n- 每个操作都有效\n\n**测试集 1（10 分，可见判定）**\n\n- 时间限制：10 秒\n- $1 \\leq \\mathbf{T} \\leq 100$\n- $2 \\leq \\mathbf{B} \\leq 100$\n- $2 \\leq \\mathbf{S} \\leq 1000$\n- $1 \\leq \\mathbf{N} \\leq 1000$\n\n**测试集 2（20 分，隐藏判定）**\n\n- 时间限制：120 秒\n- $1 \\leq \\mathbf{T} \\leq 30$\n- $2 \\leq \\mathbf{B} \\leq 3 \\times 10^{4}$\n- $2 \\leq \\mathbf{S} \\leq 3 \\times 10^{5}$\n- $1 \\leq \\mathbf{N} \\leq 3 \\times 10^{5}$\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13045", "type": "P", "difficulty": 7, "samples": [["2 2 1\n\n4 1\n\n2 4\n0\n\n2 3\n\n4 4\n1", "\n3 2\n\n1 3\n\n\n1 1\n\n3 2"]], "limits": {"time": [90000, 90000, 90000], "memory": [1048576, 1048576, 1048576]}, "tags": ["贪心", "2021", "交互题", "Special Judge", "Ad-hoc", "Google Code Jam"], "title": "[GCJ 2021 Finals] Ropes", "background": "", "description": "Two scout teams are taking part in a scouting competition. It is the finals and each team is well prepared. The game is played along a river that flows west to east. There are $4 \\mathrm{~N}$ trees planted along the river, with exactly $2 \\mathrm{~N}$ of them lined up along the north bank and $2 \\mathrm{~N}$ lined up along the south bank. Both teams alternate turns playing the game. Your team goes first.\n\nOn each turn, the playing team selects one tree on each bank that does not have any ropes tied to it and ties a rope between both trees, making it cross the river. Each rope that is added is placed higher than all previous ropes. The playing team scores 1 point per each previously used rope that passes below the newly added rope.\n\nAfter $2 \\mathrm{~N}$ turns, all trees have exactly one rope tied to them, so there are no more possible plays and the game is over. The score of each team is the sum of the scores they got in all of their turns. If your team's score is strictly greater than the opposing team's score, your team wins. If your team's score is less than or equal to the opposing team's score, your team does not win.\n\nThe following animation shows a possible game with $\\mathrm{N}=2$. Your team is represented by the color red and the other team by the color blue.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/85s69ke7)\n\nThe opposing team felt confident that going second is a large advantage, so they revealed their strategy. On their turn, they choose the play that yields the maximum possible score for this turn. If multiple such plays exist, they choose one at random. This choice is generated uniformly at random, and independently for each play, for each test case and for each submission. Therefore, even if you submit exactly the same code twice, the opposing team can make different random choices.\n\nYou play $\\mathrm{T}$ games in total, and your team must win at least $\\mathrm{W}$ of them.\n\n### Interactive Protocol\n\nThis is an interactive problem. You should make sure you have read the information in the Interactive Problems section of our $F A Q$.\n\nInitially, your program should read a single line containing three integers $\\mathbf{T}, \\mathbf{N}$, and $\\mathbf{W}$ : the number of test cases, the number of turns of your team and the number of wins you need to get for your solution to be considered correct, respectively. Note that the opposing team also gets $\\mathbf{N}$ turns, for a total of $2 \\mathbf{N}$ turns for each test case.\n\nFor each test case, your program must process $\\mathbf{N}$ exchanges. Each exchange represents two consecutive turns, one from your team and one from the opposing team.\n\nFor the $i$-th exchange, you must first print a single line with two integers $\\mathbf{A}_{i}$ and $\\mathbf{B}_{i}$ and then read a single line with two integers $\\mathbf{C}_{i}$ and $\\mathbf{D}_{i}$. This represents that in your $i$-th turn you tied the rope between the $\\mathbf{A}_{i}$-th tree from the west on the north bank and the $\\mathbf{B}_{i}$-th tree from the west on the south bank. Similarly, in the opposing team's $i$-th turn they used the $\\mathbf{C}_{i}$-th tree from the west on the north bank and the $\\mathbf{D}_{i}$-th tree from the west on the south bank. Trees are indexed starting from 1.\n\nAfter the $\\mathbf{N}$ exchanges, you must read one number that represents the result of this game. This number will be 1 if your team won, otherwise it will be 0 .\n\nThe next test case starts immediately if there is one. If this was the last test case, the judge will expect no more output and will send no further input to your program. In addition, all $\\mathbf{T}$ test cases are always processed, regardless of whether it is already guaranteed that the threshold for correctness will or cannot be met. The threshold is only checked after correctly processing all test cases.\n\nIf the judge receives an invalidly formatted line or invalid move (like using a tree that has already been used) from your program at any moment, the judge will print a single number -1 and will not print any further output. If your program continues to wait for the judge after receiving a -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "You can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently. \n\n**Limits**\n\n- $\\mathbf{T}=2000$.\n- $\\mathbf{N}=50$.\n\n**Test Set 1 (15 Pts, Visible Verdict)**\n\n- $\\mathbf{W}=1200(\\mathbf{W}=0.6 \\cdot \\mathbf{T})$.\n\n**Test Set 2 (10 Pts, Visible Verdict)**\n\n- $\\mathbf{W}=1560(\\mathbf{W}=0.78 \\cdot \\mathbf{T})$.\n\n**Test Set 3 (15 Pts, Visible Verdict)**\n\n- $\\mathbf{W}=1720(\\mathbf{W}=0.86 \\cdot \\mathbf{T})$.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 Finals] Ropes", "background": "", "description": "Two scout teams are taking part in a scouting competition. It is the finals and each team is well prepared. The game is played along a river that flows west to east. There are $4 \\mathrm{~N}$ trees planted along the river, with exactly $2 \\mathrm{~N}$ of them lined up along the north bank and $2 \\mathrm{~N}$ lined up along the south bank. Both teams alternate turns playing the game. Your team goes first.\n\nOn each turn, the playing team selects one tree on each bank that does not have any ropes tied to it and ties a rope between both trees, making it cross the river. Each rope that is added is placed higher than all previous ropes. The playing team scores 1 point per each previously used rope that passes below the newly added rope.\n\nAfter $2 \\mathrm{~N}$ turns, all trees have exactly one rope tied to them, so there are no more possible plays and the game is over. The score of each team is the sum of the scores they got in all of their turns. If your team's score is strictly greater than the opposing team's score, your team wins. If your team's score is less than or equal to the opposing team's score, your team does not win.\n\nThe following animation shows a possible game with $\\mathrm{N}=2$. Your team is represented by the color red and the other team by the color blue.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/85s69ke7)\n\nThe opposing team felt confident that going second is a large advantage, so they revealed their strategy. On their turn, they choose the play that yields the maximum possible score for this turn. If multiple such plays exist, they choose one at random. This choice is generated uniformly at random, and independently for each play, for each test case and for each submission. Therefore, even if you submit exactly the same code twice, the opposing team can make different random choices.\n\nYou play $\\mathrm{T}$ games in total, and your team must win at least $\\mathrm{W}$ of them.\n\n### Interactive Protocol\n\nThis is an interactive problem. You should make sure you have read the information in the Interactive Problems section of our $F A Q$.\n\nInitially, your program should read a single line containing three integers $\\mathbf{T}, \\mathbf{N}$, and $\\mathbf{W}$ : the number of test cases, the number of turns of your team and the number of wins you need to get for your solution to be considered correct, respectively. Note that the opposing team also gets $\\mathbf{N}$ turns, for a total of $2 \\mathbf{N}$ turns for each test case.\n\nFor each test case, your program must process $\\mathbf{N}$ exchanges. Each exchange represents two consecutive turns, one from your team and one from the opposing team.\n\nFor the $i$-th exchange, you must first print a single line with two integers $\\mathbf{A}_{i}$ and $\\mathbf{B}_{i}$ and then read a single line with two integers $\\mathbf{C}_{i}$ and $\\mathbf{D}_{i}$. This represents that in your $i$-th turn you tied the rope between the $\\mathbf{A}_{i}$-th tree from the west on the north bank and the $\\mathbf{B}_{i}$-th tree from the west on the south bank. Similarly, in the opposing team's $i$-th turn they used the $\\mathbf{C}_{i}$-th tree from the west on the north bank and the $\\mathbf{D}_{i}$-th tree from the west on the south bank. Trees are indexed starting from 1.\n\nAfter the $\\mathbf{N}$ exchanges, you must read one number that represents the result of this game. This number will be 1 if your team won, otherwise it will be 0 .\n\nThe next test case starts immediately if there is one. If this was the last test case, the judge will expect no more output and will send no further input to your program. In addition, all $\\mathbf{T}$ test cases are always processed, regardless of whether it is already guaranteed that the threshold for correctness will or cannot be met. The threshold is only checked after correctly processing all test cases.\n\nIf the judge receives an invalidly formatted line or invalid move (like using a tree that has already been used) from your program at any moment, the judge will print a single number -1 and will not print any further output. If your program continues to wait for the judge after receiving a -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "You can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently. \n\n**Limits**\n\n- $\\mathbf{T}=2000$.\n- $\\mathbf{N}=50$.\n\n**Test Set 1 (15 Pts, Visible Verdict)**\n\n- $\\mathbf{W}=1200(\\mathbf{W}=0.6 \\cdot \\mathbf{T})$.\n\n**Test Set 2 (10 Pts, Visible Verdict)**\n\n- $\\mathbf{W}=1560(\\mathbf{W}=0.78 \\cdot \\mathbf{T})$.\n\n**Test Set 3 (15 Pts, Visible Verdict)**\n\n- $\\mathbf{W}=1720(\\mathbf{W}=0.86 \\cdot \\mathbf{T})$.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 Finals] Ropes", "background": "", "description": "两支侦察队正在参加一场侦察竞赛。这是决赛环节，每支队伍都做好了充分准备。比赛在一条自西向东流动的河流沿岸进行。河岸两侧共种植了 $4 \\mathrm{~N}$ 棵树，其中北岸和南岸各有恰好 $2 \\mathrm{~N}$ 棵。两支队伍轮流进行游戏，你的队伍先手。\n\n在每个回合中，当前行动队伍需要在两岸各选择一棵尚未绑绳的树，并在两棵树之间系一条跨河的绳索。每条新添加的绳索必须位于所有先前绳索的上方。该队伍每有一条先前使用的绳索从新绳索下方穿过，就能获得 1 分。\n\n经过 $2 \\mathrm{~N}$ 个回合后，所有树都恰好绑有一条绳索，游戏结束。每支队伍的总得分是他们在所有回合中获得分数的总和。若你队伍的得分严格大于对手队伍的得分，则你队获胜；否则不获胜。\n\n以下动画展示了一个 $\\mathrm{N}=2$ 时的可能对局。你队用红色表示，对手队用蓝色表示。\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/85s69ke7)\n\n对手队认为后手具有巨大优势，因此公开了他们的策略：在他们的回合中，会选择使当前回合得分最大化的操作。若存在多个这样的操作，则随机选择其一。这个选择在每次操作、每个测试用例和每次提交中都是独立且均匀随机的。因此，即使提交完全相同的代码两次，对手队也可能做出不同的随机选择。\n\n你们共进行 $\\mathrm{T}$ 局游戏，你队需要至少赢得其中的 $\\mathrm{W}$ 局。\n\n### 交互协议\n\n这是一个交互题。请确保你已阅读交互题常见问题部分。\n\n初始时，你的程序需读取包含三个整数 $\\mathbf{T}$、$\\mathbf{N}$ 和 $\\mathbf{W}$ 的单行输入，分别表示测试用例数量、你队的回合数以及需要获胜的局数。注意对手队也有 $\\mathbf{N}$ 个回合，因此每个测试用例共进行 $2 \\mathbf{N}$ 个回合。\n\n对于每个测试用例，你的程序需要处理 $\\mathbf{N}$ 轮交互。每轮交互代表连续的两个回合，分别由你队和对手队进行。\n\n对于第 $i$ 轮交互，你需要先输出两个整数 $\\mathbf{A}_{i}$ 和 $\\mathbf{B}_{i}$，然后读取两个整数 $\\mathbf{C}_{i}$ 和 $\\mathbf{D}_{i}$。这表示在你队的第 $i$ 个回合中，你选择了北岸从西数第 $\\mathbf{A}_{i}$ 棵树和南岸从西数第 $\\mathbf{B}_{i}$ 棵树系绳；对手队则在他们的第 $i$ 个回合中选择了北岸第 $\\mathbf{C}_{i}$ 棵和南岸第 $\\mathbf{D}_{i}$ 棵树。树的编号从 1 开始。\n\n完成 $\\mathbf{N}$ 轮交互后，你需要读取一个表示本局结果数字：1 表示你队获胜，0 表示未获胜。\n\n若还有后续测试用例，则立即开始处理。若是最后一个测试用例，评测系统将不再提供输入。注意所有 $\\mathbf{T}$ 个测试用例都会被处理，不论是否已确定能否达到正确率阈值。该阈值仅在正确处理所有测试用例后才进行检查。\n\n若评测系统在任何时刻接收到非法格式或无效操作（如选择已使用的树），将输出 -1 并终止交互。若你的程序在收到 -1 后仍等待输入，将导致超时错误。请注意确保程序及时退出以避免该情况。\n", "inputFormat": "参见交互协议部分。", "outputFormat": "参见交互协议部分。", "hint": "你可以使用测试工具在本地或平台上进行测试。本地测试时需要并行运行工具和代码，我们提供了[交互运行器](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)。更多说明请参阅该文件中的注释。\n\n测试工具的使用说明包含在工具的注释中。建议你添加自己的测试用例。请注意该工具虽然用于模拟评测系统，但并非真实评测系统，其行为可能有所不同。\n\n**数据范围**\n\n- $\\mathbf{T}=2000$\n- $\\mathbf{N}=50$\n\n**测试集 1（15 分，可见判定）**\n\n- $\\mathbf{W}=1200$（$\\mathbf{W}=0.6 \\cdot \\mathbf{T}$）\n\n**测试集 2（10 分，可见判定）**\n\n- $\\mathbf{W}=1560$（$\\mathbf{W}=0.78 \\cdot \\mathbf{T}$）\n\n**测试集 3（15 分，可见判定）**\n\n- $\\mathbf{W}=1720$（$\\mathbf{W}=0.86 \\cdot \\mathbf{T}$）\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13046", "type": "P", "difficulty": 6, "samples": [["3\n0145217 7\n100100 10\n5555 12", "Case #1: 16\nCase #2: 30\nCase #3: 1"]], "limits": {"time": [60000, 60000, 60000], "memory": [1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "数学", "2021", "数论", "中国剩余定理 CRT", "Google Code Jam"], "title": "[GCJ 2021 Finals] Divisible Divisions", "background": "", "description": "We have a string $\\mathbf{S}$ consisting of decimal digits. A division of $\\mathbf{S}$ is created by dividing $\\mathbf{S}$ into contiguous substrings. For example, if $\\mathbf{S}$ is 0145217, two possible divisions are 014 5 21 7 and 0 14 52 17. Each digit must be used in exactly one substring, and each substring must be non-empty. If $\\mathbf{S}$ has $L$ digits, then there are exactly $2^{L-1}$ possible divisions of it.\n\nGiven a positive integer $\\mathbf{D}$, a division of $\\mathbf{S}$ is called divisible by $\\mathbf{D}$ if for every pair of consecutive substrings, at least one of the integers they represent in base 10 is divisible by $\\mathbf{D}$. If $\\mathbf{D}=7$, the first example division above is divisible because 014, 21, and 7 represent integers divisible by 7. The second example division is not divisible because 52 and 17 are consecutive substrings and neither represents an integer divisible by 7. Dividing 0145217 as 0145217 is divisible by any $\\mathbf{D}$ because there are no pairs of consecutive substrings.\n\nGiven $\\mathbf{S}$ and $\\mathbf{D}$, count how many divisions of $\\mathbf{S}$ exist that are divisible by $\\mathbf{D}$. Since the output can be a really big number, we only ask you to output the remainder of dividing the result by the prime $10^{9}+7$ ($1000000007$).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line represents a test case with a string of digits $\\mathbf{S}$ and a positive integer $\\mathbf{D}$, as mentioned above.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of different divisions of $\\mathbf{S}$ that are divisible by $\\mathbf{D}$, modulo the prime $10^{9}+7$ ($1000000007$).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, all $16$ divisible divisions of $\\mathbf{S}$ are:\n\n- 0145217,\n- 0 145217,\n- 0 14 5217,\n- 0 14 5 217,\n- 0 14 5 21 7,\n- 0 14 521 7,\n- 0 145 217,\n- 0 145 21 7,\n- 0 14521 7,\n- 014 5217,\n- 014 5 217,\n- 014 5 21 7,\n- 014 521 7,\n- 0145 217,\n- 0145 21 7, and\n- 014521 7.\n\nIn Sample Case #2, there are $2^{5}=32$ ways to divide in total. To get two consecutive substrings to not be divisible by 10, we need both of them to not end in 0. The only 2 ways of doing that are $1 \\ 001 \\ 00$ and $1 \\ 001 \\ 0 \\ 0$, which means the other 30 divisions of $\\mathbf{S}$ are divisible by 10.\n\nIn Sample Case #3, no possible substring represents an even integer, which in turn means it is not divisible by 12. Therefore, the only way to not have two consecutive substrings that are not divisible by 12 is to not have two consecutive substrings at all, which can be done in only 1 way: 5555.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{D} \\leq 10^{6}$.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{S} \\leq 1000$.\n\n**Test Set 2 (35 Pts, Hidden Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{S} \\leq 10^{5}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 Finals] Divisible Divisions", "background": "", "description": "We have a string $\\mathbf{S}$ consisting of decimal digits. A division of $\\mathbf{S}$ is created by dividing $\\mathbf{S}$ into contiguous substrings. For example, if $\\mathbf{S}$ is 0145217, two possible divisions are 014 5 21 7 and 0 14 52 17. Each digit must be used in exactly one substring, and each substring must be non-empty. If $\\mathbf{S}$ has $L$ digits, then there are exactly $2^{L-1}$ possible divisions of it.\n\nGiven a positive integer $\\mathbf{D}$, a division of $\\mathbf{S}$ is called divisible by $\\mathbf{D}$ if for every pair of consecutive substrings, at least one of the integers they represent in base 10 is divisible by $\\mathbf{D}$. If $\\mathbf{D}=7$, the first example division above is divisible because 014, 21, and 7 represent integers divisible by 7. The second example division is not divisible because 52 and 17 are consecutive substrings and neither represents an integer divisible by 7. Dividing 0145217 as 0145217 is divisible by any $\\mathbf{D}$ because there are no pairs of consecutive substrings.\n\nGiven $\\mathbf{S}$ and $\\mathbf{D}$, count how many divisions of $\\mathbf{S}$ exist that are divisible by $\\mathbf{D}$. Since the output can be a really big number, we only ask you to output the remainder of dividing the result by the prime $10^{9}+7$ ($1000000007$).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line represents a test case with a string of digits $\\mathbf{S}$ and a positive integer $\\mathbf{D}$, as mentioned above.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of different divisions of $\\mathbf{S}$ that are divisible by $\\mathbf{D}$, modulo the prime $10^{9}+7$ ($1000000007$).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, all $16$ divisible divisions of $\\mathbf{S}$ are:\n\n- 0145217,\n- 0 145217,\n- 0 14 5217,\n- 0 14 5 217,\n- 0 14 5 21 7,\n- 0 14 521 7,\n- 0 145 217,\n- 0 145 21 7,\n- 0 14521 7,\n- 014 5217,\n- 014 5 217,\n- 014 5 21 7,\n- 014 521 7,\n- 0145 217,\n- 0145 21 7, and\n- 014521 7.\n\nIn Sample Case #2, there are $2^{5}=32$ ways to divide in total. To get two consecutive substrings to not be divisible by 10, we need both of them to not end in 0. The only 2 ways of doing that are $1 \\ 001 \\ 00$ and $1 \\ 001 \\ 0 \\ 0$, which means the other 30 divisions of $\\mathbf{S}$ are divisible by 10.\n\nIn Sample Case #3, no possible substring represents an even integer, which in turn means it is not divisible by 12. Therefore, the only way to not have two consecutive substrings that are not divisible by 12 is to not have two consecutive substrings at all, which can be done in only 1 way: 5555.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{D} \\leq 10^{6}$.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{S} \\leq 1000$.\n\n**Test Set 2 (35 Pts, Hidden Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{S} \\leq 10^{5}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 Finals] Divisible Divisions", "background": "", "description": "我们有一个由十进制数字组成的字符串 $\\mathbf{S}$。$\\mathbf{S}$ 的一个**分割**是通过将 $\\mathbf{S}$ 划分为连续的若干子串得到的。例如，若 $\\mathbf{S}$ 为 `0145217`，则两种可能的分割为 `014 5 21 7` 和 `0 14 52 17`。每个数字必须恰好出现在一个子串中，且每个子串必须非空。如果 $\\mathbf{S}$ 有 $L$ 个数字，则它共有 $2^{L-1}$ 种可能的分割方式。\n\n给定一个正整数 $\\mathbf{D}$，若 $\\mathbf{S}$ 的某个分割满足：对于任意两个相邻的子串，它们表示的十进制整数中至少有一个能被 $\\mathbf{D}$ 整除，则称该分割是**可被 $\\mathbf{D}$ 整除的**。若 $\\mathbf{D}=7$，上述第一个示例分割是可被整除的，因为 `014`、`21` 和 `7` 表示的整数均能被 7 整除。第二个示例分割不可被整除，因为 `52` 和 `17` 是相邻子串且均不能被 7 整除。将 `0145217` 分割为 `0145217`（即不分割）对任意 $\\mathbf{D}$ 都是可被整除的，因为此时不存在相邻子串对。\n\n给定 $\\mathbf{S}$ 和 $\\mathbf{D}$，统计 $\\mathbf{S}$ 的可被 $\\mathbf{D}$ 整除的分割数量。由于结果可能非常大，只需输出其对质数 $10^{9}+7$（即 $1000000007$）取模后的余数。\n", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。随后 $\\mathbf{T}$ 行，每行表示一个测试用例，包含一个数字字符串 $\\mathbf{S}$ 和一个正整数 $\\mathbf{D}$，如上所述。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为 $\\mathbf{S}$ 的可被 $\\mathbf{D}$ 整除的分割数量，对 $10^{9}+7$ 取模后的结果。\n", "hint": "**样例解释**\n\n在样例 #1 中，$\\mathbf{S}$ 的所有 16 种可被 7 整除的分割为：\n\n- 0145217,\n- 0 145217,\n- 0 14 5217,\n- 0 14 5 217,\n- 0 14 5 21 7,\n- 0 14 521 7,\n- 0 145 217,\n- 0 145 21 7,\n- 0 14521 7,\n- 014 5217,\n- 014 5 217,\n- 014 5 21 7,\n- 014 521 7,\n- 0145 217,\n- 0145 21 7, 和\n- 014521 7.\n\n在样例 #2 中，共有 $2^{5}=32$ 种分割方式。若要使两个相邻子串均不被 10 整除，则这两个子串的末尾均不能为 0。唯一满足此条件的分割是 `1 001 00` 和 `1 001 0 0`，因此其余 30 种分割均是可被 10 整除的。\n\n在样例 #3 中，没有任何子串表示的整数是偶数（即无法被 12 整除）。因此，唯一避免两个相邻子串均不被 12 整除的方式是不进行任何分割，即仅有一种分割：`5555`。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{D} \\leq 10^{6}$。\n\n**测试集 1（10 分，可见判定）**\n\n- $1 \\leq \\mathbf{S}$ 的长度 $\\leq 1000$。\n\n**测试集 2（35 分，隐藏判定）**\n\n- $1 \\leq \\mathbf{S}$ 的长度 $\\leq 10^{5}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13047", "type": "P", "difficulty": 7, "samples": [["5\n3 1 8\n3 0 0\n2 0 2\n3 1 5\n3 0 0\n2 0 2\n4 1 27\n3 4 2 4\n2 2 4 0\n4 1 28\n3 4 2 4\n2 2 4 0\n3 1 10\n1 3 1\n3 2 1", "Case #1: 3\nCase #2: 2\nCase #3: 4\nCase #4: 5\nCase #5: 3"], ["4\n3 5 7\n3 0 0\n2 0 2\n3 4 9\n3 0 0\n2 0 2\n4 11 18\n3 4 2 4\n2 2 4 0\n4 21 22\n3 4 2 4\n2 2 4 0", "Case #1: 4\nCase #2: 3\nCase #3: 5\nCase #4: 8"]], "limits": {"time": [90000, 90000, 90000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2021", "矩阵加速", "最近公共祖先 LCA", "Google Code Jam"], "title": "[GCJ 2021 Finals] Infinitree", "background": "", "description": "This problem is about finding the distance between two nodes of a strictly binary tree. Oh, is that too easy?! Ok, the tree is potentially infinite now. Keep it up and we will start going up the aleph numbers.\n\nIn this problem, a tree is either a single node $X$, or a node $X$ with two trees attached to it: a left subtree and a right subtree. In both cases, $X$ is the root of the tree. If the tree is not a single node, the roots of both the left and right subtrees are the only children of $X$.\n\nThere is a set of colors numbered from 0 to $\\mathbf{N}$, inclusive. Each node is of exactly one color. There might be zero, one, or multiple nodes of each color. Each node of color 0 (white) is a leaf node (that is, it has no children). Each node of color $i$, for $1 \\leq i \\leq \\mathbf{N}$, has exactly 2 children: the left one is color $\\mathbf{L}_{i}$ and the right one is color $\\mathbf{R}_{i}$. The root of the tree is color 1 (black). Note that the tree may have a finite or countably infinite number of nodes.\n\nFor example, the following picture illustrates a finite tree defined by the lists $\\mathbf{L}=[3,0,0]$ and $\\mathbf{R}=[2,0,2]$. Color 2 is blue and color 3 is yellow.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sj19pjad.png)\n\nThe distance between two nodes in the tree is the minimum number of steps that are needed to get from one node to the other. A step is a move from a node to its direct parent or its direct child.\n\nNodes in the tree are indexed using positive integers. The root has index $1$. Then, other nodes are indexed using consecutive integers, with nodes with smaller distances to the root being indexed first. For nodes that are equidistant to the root, nodes that are further to the left are indexed first. For example, the following picture adds indices to each node in the tree we presented before. Notice that each node's index is independent from its color.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nx04usnw.png)\n\nAs another example, the following picture shows the first $33$ nodes of an infinite tree defined by the lists $\\mathbf{L}=[3,4,2,4]$ and $\\mathbf{R}=[2,2,4,0]$. Color $4$ is green.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zc3569sp.png)\n\nGiven the lists $\\mathbf{L}$ and $\\mathbf{R}$ that define a tree and the indices of two different nodes in the tree, return the distance between those two nodes.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of three lines. The first line contains $\\mathbf{N}$, $\\mathbf{A}$, and $\\mathbf{B}$: the size of the lists that define the tree, and the indices of the two nodes whose distance you need to calculate, respectively. The second line contains $\\mathbf{N}$ integers $\\mathbf{L}_{1}$, $\\mathbf{L}_{2}$, $\\ldots$, $\\mathbf{L}_{\\mathbf{N}}$ and the third line contains $\\mathbf{N}$ integers $\\mathbf{R}_{1}$, $\\mathbf{R}_{2}$, $\\ldots$, $\\mathbf{R}_{\\mathbf{N}}$, as described above.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the distance between the nodes with indices $\\mathbf{A}$ and $\\mathbf{B}$ in the tree defined by the lists $\\mathbf{L}$ and $\\mathbf{R}$.", "hint": "**Sample Explanation**\n\nThe tree in Sample Cases #1 and #2 is the first tree shown in the statement. The tree in Sample Cases #3 and #4 is the last tree shown in the statement. The same is true for the additional samples below. In Sample Case #5, notice that some colors may not be present in the tree.\n\nSample Test Set 2 fits the limits of Test Set 2. It will not be run against your submitted solutions.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{N} \\leq 50$.\n- $0 \\leq \\mathbf{L}_{i} \\leq \\mathbf{N}$.\n- $0 \\leq \\mathbf{R}_{i} \\leq \\mathbf{N}$.\n- $\\mathbf{A} < \\mathbf{B} \\leq 10^{18}$.\n- The tree defined by $\\mathbf{L}$ and $\\mathbf{R}$ has at least $\\mathbf{B}$ nodes.\n\n**Test Set 1 (25 Pts, Visible Verdict)**\n\n- $\\mathbf{A} = 1$.\n\n**Test Set 2 (40 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{A} \\leq 10^{18}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 Finals] Infinitree", "background": "", "description": "This problem is about finding the distance between two nodes of a strictly binary tree. Oh, is that too easy?! Ok, the tree is potentially infinite now. Keep it up and we will start going up the aleph numbers.\n\nIn this problem, a tree is either a single node $X$, or a node $X$ with two trees attached to it: a left subtree and a right subtree. In both cases, $X$ is the root of the tree. If the tree is not a single node, the roots of both the left and right subtrees are the only children of $X$.\n\nThere is a set of colors numbered from 0 to $\\mathbf{N}$, inclusive. Each node is of exactly one color. There might be zero, one, or multiple nodes of each color. Each node of color 0 (white) is a leaf node (that is, it has no children). Each node of color $i$, for $1 \\leq i \\leq \\mathbf{N}$, has exactly 2 children: the left one is color $\\mathbf{L}_{i}$ and the right one is color $\\mathbf{R}_{i}$. The root of the tree is color 1 (black). Note that the tree may have a finite or countably infinite number of nodes.\n\nFor example, the following picture illustrates a finite tree defined by the lists $\\mathbf{L}=[3,0,0]$ and $\\mathbf{R}=[2,0,2]$. Color 2 is blue and color 3 is yellow.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sj19pjad.png)\n\nThe distance between two nodes in the tree is the minimum number of steps that are needed to get from one node to the other. A step is a move from a node to its direct parent or its direct child.\n\nNodes in the tree are indexed using positive integers. The root has index $1$. Then, other nodes are indexed using consecutive integers, with nodes with smaller distances to the root being indexed first. For nodes that are equidistant to the root, nodes that are further to the left are indexed first. For example, the following picture adds indices to each node in the tree we presented before. Notice that each node's index is independent from its color.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nx04usnw.png)\n\nAs another example, the following picture shows the first $33$ nodes of an infinite tree defined by the lists $\\mathbf{L}=[3,4,2,4]$ and $\\mathbf{R}=[2,2,4,0]$. Color $4$ is green.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zc3569sp.png)\n\nGiven the lists $\\mathbf{L}$ and $\\mathbf{R}$ that define a tree and the indices of two different nodes in the tree, return the distance between those two nodes.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of three lines. The first line contains $\\mathbf{N}$, $\\mathbf{A}$, and $\\mathbf{B}$: the size of the lists that define the tree, and the indices of the two nodes whose distance you need to calculate, respectively. The second line contains $\\mathbf{N}$ integers $\\mathbf{L}_{1}$, $\\mathbf{L}_{2}$, $\\ldots$, $\\mathbf{L}_{\\mathbf{N}}$ and the third line contains $\\mathbf{N}$ integers $\\mathbf{R}_{1}$, $\\mathbf{R}_{2}$, $\\ldots$, $\\mathbf{R}_{\\mathbf{N}}$, as described above.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the distance between the nodes with indices $\\mathbf{A}$ and $\\mathbf{B}$ in the tree defined by the lists $\\mathbf{L}$ and $\\mathbf{R}$.", "hint": "**Sample Explanation**\n\nThe tree in Sample Cases #1 and #2 is the first tree shown in the statement. The tree in Sample Cases #3 and #4 is the last tree shown in the statement. The same is true for the additional samples below. In Sample Case #5, notice that some colors may not be present in the tree.\n\nSample Test Set 2 fits the limits of Test Set 2. It will not be run against your submitted solutions.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{N} \\leq 50$.\n- $0 \\leq \\mathbf{L}_{i} \\leq \\mathbf{N}$.\n- $0 \\leq \\mathbf{R}_{i} \\leq \\mathbf{N}$.\n- $\\mathbf{A} < \\mathbf{B} \\leq 10^{18}$.\n- The tree defined by $\\mathbf{L}$ and $\\mathbf{R}$ has at least $\\mathbf{B}$ nodes.\n\n**Test Set 1 (25 Pts, Visible Verdict)**\n\n- $\\mathbf{A} = 1$.\n\n**Test Set 2 (40 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{A} \\leq 10^{18}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 Finals] Infinitree", "background": "", "description": "本题需要计算一棵严格二叉树上两个节点之间的距离。哦，这太简单了？！好吧，现在这棵树可能是无限的。继续努力的话，我们可能要开始讨论阿列夫数了。\n\n在这道题中，一棵树要么是一个单独的节点 $X$，要么是一个节点 $X$ 附带两棵子树：左子树和右子树。无论是哪种情况，$X$ 都是这棵树的根节点。如果树不是单个节点，那么左子树和右子树的根节点是 $X$ 仅有的两个子节点。\n\n有一组颜色编号从 0 到 $\\mathbf{N}$（包括 $\\mathbf{N}$）。每个节点恰好有一种颜色。每种颜色可能有零个、一个或多个节点。颜色为 0（白色）的节点是叶节点（即没有子节点）。对于颜色为 $i$（$1 \\leq i \\leq \\mathbf{N}$）的节点，它恰好有两个子节点：左子节点的颜色为 $\\mathbf{L}_{i}$，右子节点的颜色为 $\\mathbf{R}_{i}$。树的根节点颜色为 1（黑色）。注意，这棵树的节点数量可能是有限的或可数无限的。\n\n例如，下图展示了一棵由列表 $\\mathbf{L}=[3,0,0]$ 和 $\\mathbf{R}=[2,0,2]$ 定义的有限树。颜色 2 为蓝色，颜色 3 为黄色。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sj19pjad.png)\n\n树中两个节点之间的距离是从一个节点到另一个节点所需的最少步数。每一步可以是从一个节点移动到其直接父节点或直接子节点。\n\n树中的节点用正整数编号。根节点的编号为 $1$。其他节点按以下规则编号：距离根节点较近的节点优先编号；若距离相同，则左侧的节点优先编号。例如，下图展示了之前那棵树中每个节点的编号。注意，每个节点的编号与其颜色无关。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nx04usnw.png)\n\n再举一个例子，下图展示了由列表 $\\mathbf{L}=[3,4,2,4]$ 和 $\\mathbf{R}=[2,2,4,0]$ 定义的无限树的前 $33$ 个节点。颜色 4 为绿色。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zc3569sp.png)\n\n给定定义树的列表 $\\mathbf{L}$ 和 $\\mathbf{R}$，以及树中两个不同节点的编号，返回这两个节点之间的距离。", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。随后 $\\mathbf{T}$ 个测试用例，每个测试用例包含三行。第一行包含 $\\mathbf{N}$、$\\mathbf{A}$ 和 $\\mathbf{B}$：分别表示定义树的列表的大小，以及需要计算距离的两个节点的编号。第二行包含 $\\mathbf{N}$ 个整数 $\\mathbf{L}_{1}, \\mathbf{L}_{2}, \\ldots, \\mathbf{L}_{\\mathbf{N}}$，第三行包含 $\\mathbf{N}$ 个整数 $\\mathbf{R}_{1}, \\mathbf{R}_{2}, \\ldots, \\mathbf{R}_{\\mathbf{N}}$，如上所述。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为由 $\\mathbf{L}$ 和 $\\mathbf{R}$ 定义的树中编号为 $\\mathbf{A}$ 和 $\\mathbf{B}$ 的两个节点之间的距离。\n", "hint": "**样例解释**\n\n样例 #1 和 #2 中的树是题目描述中的第一棵树。样例 #3 和 #4 中的树是题目描述中的最后一棵树。样例 #5 中，注意某些颜色可能在树中不存在。\n\n样例测试集 2 符合测试集 2 的限制条件，但不会对提交的解决方案运行。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{N} \\leq 50$。\n- $0 \\leq \\mathbf{L}_{i} \\leq \\mathbf{N}$。\n- $0 \\leq \\mathbf{R}_{i} \\leq \\mathbf{N}$。\n- $\\mathbf{A} < \\mathbf{B} \\leq 10^{18}$。\n- 由 $\\mathbf{L}$ 和 $\\mathbf{R}$ 定义的树至少有 $\\mathbf{B}$ 个节点。\n\n**测试集 1（25 分，可见判定）**\n\n- $\\mathbf{A} = 1$。\n\n**测试集 2（40 分，隐藏判定）**\n\n- $1 \\leq \\mathbf{A} \\leq 10^{18}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13048", "type": "P", "difficulty": 2, "samples": [["3\n4\n1 2 3 4\n2 1 4 3\n3 4 1 2\n4 3 2 1\n4\n2 2 2 2\n2 3 2 3\n2 2 2 3\n2 2 2 2\n3\n2 1 3\n1 3 2\n1 2 3", "Case #1: 4 0 0\nCase #2: 9 4 4\nCase #3: 8 0 2"]], "limits": {"time": [20000, 20000], "memory": [1048576, 1048576]}, "tags": ["模拟", "2020", "排序", "Google Code Jam"], "title": "[GCJ 2020 Qualification] Vestigium", "background": "", "description": "Vestigium means \"trace\" in Latin. In this problem we work with Latin squares and matrix traces.\n\nThe trace of a square matrix is the sum of the values on the main diagonal (which runs from the upper left to the lower right).\n\nAn $N$-by-$N$ square matrix is a *Latin square* if each cell contains one of $N$ different values, and no value is repeated within a row or a column. In this problem, we will deal only with \"natural Latin squares\" in which the $N$ values are the integers between 1 and $N$.\n\nGiven a matrix that contains only integers between 1 and $N$, we want to compute its trace and check whether it is a natural Latin square. To give some additional information, instead of simply telling us whether the matrix is a natural Latin square or not, please compute the number of rows and the number of columns that contain repeated values.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each starts with a line containing a single integer $N$: the size of the matrix to explore. Then, $N$ lines follow. The $i$-th of these lines contains $N$ integers $M_{i,1}$, $M_{i,2}$, $\\dots$, $M_{i,N}$. $M_{i,j}$ is the integer in the $i$-th row and $j$-th column of the matrix.\n", "outputFormat": "For each test case, output one line containing `Case #x: k r c`, where $x$ is the test case number (starting from 1), $k$ is the trace of the matrix, $r$ is the number of rows of the matrix that contain repeated elements, and $c$ is the number of columns of the matrix that contain repeated elements.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the input is a natural Latin square, which means no row or column has repeated elements. All four values in the main diagonal are 1, and so the trace (their sum) is 4.\n\nIn Sample Case #2, all rows and columns have repeated elements. Notice that each row or column with repeated elements is counted only once regardless of the number of elements that are repeated or how often they are repeated within the row or column. In addition, notice that some integers in the range 1 through $N$ may be absent from the input.\n\nIn Sample Case #3, the leftmost and rightmost columns have repeated elements.\n\n**Limits**\n\n**Test set 1 (7 Pts, Visible Verdict)**\n\n- $1 \\leq T \\leq 100.$\n- $2 \\leq N \\leq 100.$\n- $1 \\leq M_{i,j} \\leq N,$ for all $i, j.$", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 Qualification] Vestigium", "background": "", "description": "Vestigium means \"trace\" in Latin. In this problem we work with Latin squares and matrix traces.\n\nThe trace of a square matrix is the sum of the values on the main diagonal (which runs from the upper left to the lower right).\n\nAn $N$-by-$N$ square matrix is a *Latin square* if each cell contains one of $N$ different values, and no value is repeated within a row or a column. In this problem, we will deal only with \"natural Latin squares\" in which the $N$ values are the integers between 1 and $N$.\n\nGiven a matrix that contains only integers between 1 and $N$, we want to compute its trace and check whether it is a natural Latin square. To give some additional information, instead of simply telling us whether the matrix is a natural Latin square or not, please compute the number of rows and the number of columns that contain repeated values.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each starts with a line containing a single integer $N$: the size of the matrix to explore. Then, $N$ lines follow. The $i$-th of these lines contains $N$ integers $M_{i,1}$, $M_{i,2}$, $\\dots$, $M_{i,N}$. $M_{i,j}$ is the integer in the $i$-th row and $j$-th column of the matrix.\n", "outputFormat": "For each test case, output one line containing `Case #x: k r c`, where $x$ is the test case number (starting from 1), $k$ is the trace of the matrix, $r$ is the number of rows of the matrix that contain repeated elements, and $c$ is the number of columns of the matrix that contain repeated elements.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the input is a natural Latin square, which means no row or column has repeated elements. All four values in the main diagonal are 1, and so the trace (their sum) is 4.\n\nIn Sample Case #2, all rows and columns have repeated elements. Notice that each row or column with repeated elements is counted only once regardless of the number of elements that are repeated or how often they are repeated within the row or column. In addition, notice that some integers in the range 1 through $N$ may be absent from the input.\n\nIn Sample Case #3, the leftmost and rightmost columns have repeated elements.\n\n**Limits**\n\n**Test set 1 (7 Pts, Visible Verdict)**\n\n- $1 \\leq T \\leq 100.$\n- $2 \\leq N \\leq 100.$\n- $1 \\leq M_{i,j} \\leq N,$ for all $i, j.$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 Qualification] Vestigium", "background": null, "description": "Vestigium 在拉丁语中意为“痕迹”。本题中，我们将研究拉丁方阵与矩阵的迹。\n\n一个方阵的迹是指其主对角线上所有元素的和（主对角线从左上角延伸至右下角）。\n\n一个 $N \\times N$ 的方阵被称为**拉丁方阵**，当且仅当每个单元格包含 $N$ 个不同的值，且每一行和每一列中都没有重复的值。在本题中，我们仅讨论“自然拉丁方阵”，即这些 $N$ 个值为 $1$ 到 $N$ 之间的整数。\n\n给定一个仅包含 $1$ 到 $N$ 之间整数的矩阵，我们需要计算其迹，并检查它是否是一个自然拉丁方阵。为了提供更多信息，除了简单地告诉我们矩阵是否为自然拉丁方阵外，请计算包含重复值的行数和列数。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。随后是 $T$ 个测试用例。每个测试用例的第一行包含一个整数 $N$，表示矩阵的大小。接下来的 $N$ 行中，第 $i$ 行包含 $N$ 个整数 $M_{i,1}, M_{i,2},\\dots,M_{i,N},M_{i,j}$ 表示矩阵第 $i$ 行第 $j$ 列的整数值。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: k r c`，其中 $x$ 是测试用例编号（从 $1$ 开始），$k$ 是矩阵的迹，$r$ 是包含重复元素的行数，$c$ 是包含重复元素的列数。", "hint": "**样例解释**\n\n在样例一中，输入是一个自然拉丁方阵，因此没有任何行或列包含重复元素。主对角线上的四个值均为 $1$，因此迹（它们的和）为 $4$。\n\n在样例二中，所有行和列均包含重复元素。注意，无论重复元素的数量或重复次数如何，每行或每列仅被计数一次。此外，$1$ 到 $N$ 之间的某些整数可能在输入中缺失。\n\n在样例三中，最左和最右的列包含重复元素。\n\n**数据范围**\n\n**测试集 $1$（$7$ 分，可见判定）**\n\n- $1 \\leq T \\leq 100$。\n- $2 \\leq N \\leq 100$。\n- 对于所有 $i, j$，$1 \\leq M_{i,j} \\leq N$。\n\n翻译由 DeepSeek V3 完成。", "locale": "zh-CN"}}}
{"pid": "P13049", "type": "P", "difficulty": 2, "samples": [["4\n0000\n101\n111000\n1", "Case #1: 0000\nCase #2: (1)0(1)\nCase #3: (111)000\nCase #4: (1)"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["字符串", "贪心", "2020", "Google Code Jam"], "title": "[GCJ 2020 Qualification] Nesting Depth", "background": "", "description": "tl;dr: Given a string of digits $\\mathbf{S}$, insert a minimum number of opening and closing parentheses into it such that the resulting string is balanced and each digit $d$ is inside exactly $d$ pairs of matching parentheses.\n\nLet the *nesting* of two parentheses within a string be the substring that occurs strictly between them. An opening parenthesis and a closing parenthesis that is further to its right are said to *match* if their nesting is empty, or if every parenthesis in their nesting matches with another parenthesis in their nesting. The *nesting depth* of a position $p$ is the number of pairs of matching parentheses $m$ such that $p$ is included in the nesting of $m$.\n\nFor example, in the following strings, all digits match their nesting depth: 0((2)1), (((3))1(2)), ((((4)))), ((2))((2))(1). The first three strings have minimum length among those that have the same digits in the same order, but the last one does not since ((22)1) also has the digits 221 and is shorter.\n\nGiven a string of digits $\\mathbf{S}$, find another string $\\mathbf{S}'$, comprised of parentheses and digits, such that:\n\n* all parentheses in $\\mathbf{S}'$ match some other parenthesis,\n* removing any and all parentheses from $\\mathbf{S}'$ results in $\\mathbf{S}$,\n* each digit in $\\mathbf{S}'$ is equal to its nesting depth, and\n* $\\mathbf{S}'$ is of minimum length.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line represents a test case and contains only the string $\\mathbf{S}$.", "outputFormat": "For each test case, output one line containing case #x: y, where $x$ is the test case number (starting from 1) and $y$ is the string $\\mathbf{S}'$ defined above.", "hint": "**Sample Explanation**\n\nThe strings ()0000(), (1)0(((()))1) and (1)(11)000 are not valid solutions to Sample Cases #1, #2 and #3, respectively, only because they are not of minimum length. In addition, 1)( and )(1 are not valid solutions to Sample Case #4 because they contain unmatched parentheses and the nesting depth is 0 at the position where there is a 1.\n\nYou can create sample inputs that are valid only for Test Set 2 by removing the parentheses from the example strings mentioned in the problem statement.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq$ length of $\\mathbf{S} \\leq 100$.\n\n**Test set 1 (5 Pts, Visible Verdict)**\n\n- Each character in $\\mathbf{S}$ is either 0 or 1 .\n\n**Test set 2 (11 Pts, Visible Verdict)**\n\n- Each character in $\\mathbf{S}$ is a decimal digit between 0 and 9 , inclusive.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 Qualification] Nesting Depth", "background": "", "description": "tl;dr: Given a string of digits $\\mathbf{S}$, insert a minimum number of opening and closing parentheses into it such that the resulting string is balanced and each digit $d$ is inside exactly $d$ pairs of matching parentheses.\n\nLet the *nesting* of two parentheses within a string be the substring that occurs strictly between them. An opening parenthesis and a closing parenthesis that is further to its right are said to *match* if their nesting is empty, or if every parenthesis in their nesting matches with another parenthesis in their nesting. The *nesting depth* of a position $p$ is the number of pairs of matching parentheses $m$ such that $p$ is included in the nesting of $m$.\n\nFor example, in the following strings, all digits match their nesting depth: 0((2)1), (((3))1(2)), ((((4)))), ((2))((2))(1). The first three strings have minimum length among those that have the same digits in the same order, but the last one does not since ((22)1) also has the digits 221 and is shorter.\n\nGiven a string of digits $\\mathbf{S}$, find another string $\\mathbf{S}'$, comprised of parentheses and digits, such that:\n\n* all parentheses in $\\mathbf{S}'$ match some other parenthesis,\n* removing any and all parentheses from $\\mathbf{S}'$ results in $\\mathbf{S}$,\n* each digit in $\\mathbf{S}'$ is equal to its nesting depth, and\n* $\\mathbf{S}'$ is of minimum length.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line represents a test case and contains only the string $\\mathbf{S}$.", "outputFormat": "For each test case, output one line containing case #x: y, where $x$ is the test case number (starting from 1) and $y$ is the string $\\mathbf{S}'$ defined above.", "hint": "**Sample Explanation**\n\nThe strings ()0000(), (1)0(((()))1) and (1)(11)000 are not valid solutions to Sample Cases #1, #2 and #3, respectively, only because they are not of minimum length. In addition, 1)( and )(1 are not valid solutions to Sample Case #4 because they contain unmatched parentheses and the nesting depth is 0 at the position where there is a 1.\n\nYou can create sample inputs that are valid only for Test Set 2 by removing the parentheses from the example strings mentioned in the problem statement.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq$ length of $\\mathbf{S} \\leq 100$.\n\n**Test set 1 (5 Pts, Visible Verdict)**\n\n- Each character in $\\mathbf{S}$ is either 0 or 1 .\n\n**Test set 2 (11 Pts, Visible Verdict)**\n\n- Each character in $\\mathbf{S}$ is a decimal digit between 0 and 9 , inclusive.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 Qualification] Nesting Depth", "background": "", "description": "**简要题意**：给定一个数字字符串 $\\mathbf{S}$，在其中插入最少数量的左右括号，使得生成的字符串是平衡的，并且每个数字 $d$ 恰好位于 $d$ 对匹配的括号内。\n\n我们定义字符串中两个括号的**嵌套**为它们之间严格包含的子串。一个左括号和其右侧的一个右括号称为**匹配**，如果它们的嵌套为空，或者它们的嵌套中的每个括号都与另一个括号匹配。位置 $p$ 的**嵌套深度**是包含 $p$ 的匹配括号对的数量 $m$。\n\n例如，在以下字符串中，所有数字都与其嵌套深度匹配：`0((2)1)`、`(((3))1(2))`、`((((4))))`、`((2))((2))(1)`。前三个字符串在保持数字顺序相同的情况下长度最短，但最后一个不是，因为 `((22)1)` 也包含数字 `221` 且更短。\n\n给定一个数字字符串 $\\mathbf{S}$，找到另一个由括号和数字组成的字符串 $\\mathbf{S}'$，满足以下条件：\n\n* $\\mathbf{S}'$ 中的所有括号都与其他括号匹配；\n* 从 $\\mathbf{S}'$ 中移除所有括号后得到 $\\mathbf{S}$；\n* $\\mathbf{S}'$ 中的每个数字等于其嵌套深度；\n* $\\mathbf{S}'$ 的长度最短。", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 行，每行表示一个测试用例，仅包含字符串 $\\mathbf{S}$。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是上述定义的字符串 $\\mathbf{S}'$。\n", "hint": "**样例解释**\n\n字符串 `()0000()`、`(1)0(((()))1)` 和 `(1)(11)000` 分别不是样例 #1、#2 和 #3 的有效解，因为它们不是最短的。此外，`1)(` 和 `)(1` 不是样例 #4 的有效解，因为它们包含未匹配的括号，且在数字 `1` 的位置嵌套深度为 0。\n\n你可以通过移除题目描述中提到的示例字符串的括号来创建仅适用于测试集 2 的样例输入。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$；\n- $1 \\leq \\mathbf{S}$ 的长度 $\\leq 100$。\n\n**测试集 1（5 分，可见判定）**\n\n- $\\mathbf{S}$ 中的每个字符为 `0` 或 `1`。\n\n**测试集 2（11 分，可见判定）**\n\n- $\\mathbf{S}$ 中的每个字符为 `0` 到 `9` 的数字（含）。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13050", "type": "P", "difficulty": 3, "samples": [["4\n3\n360 480\n420 540\n600 660\n3\n0 1440\n1 3\n2 4\n5\n99 150\n1 100\n100 301\n2 5\n150 250\n2\n0 720\n720 1440", "Case #1: CJC\nCase #2: IMPOSSIBLE\nCase #3: JCCJJ\nCase #4: CC"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["贪心", "2020", "Special Judge", "Google Code Jam"], "title": "[GCJ 2020 Qualification] Parenting Partnering Returns", "background": "", "description": "Cameron and Jamie's kid is almost 3 years old! However, even though the child is more independent now, scheduling kid activities and domestic necessities is still a challenge for the couple.\n\nCameron and Jamie have a list of $\\mathbf{N}$ activities to take care of during the day. Each activity happens during a specified interval during the day. They need to assign each activity to one of them, so that neither of them is responsible for two activities that overlap. An activity that ends at time $\\mathbf{t}$ is not considered to overlap with another activity that starts at time $\\mathbf{t}$.\n\nFor example, suppose that Jamie and Cameron need to cover 3 activities: one running from 18:00 to 20:00, another from 19:00 to 21:00 and another from 22:00 to 23:00. One possibility would be for Jamie to cover the activity running from 19:00 to 21:00, with Cameron covering the other two. Another valid schedule would be for Cameron to cover the activity from 18:00 to 20:00 and Jamie to cover the other two. Notice that the first two activities overlap in the time between 19:00 and 20:00, so it is impossible to assign both of those activities to the same partner.\n\nGiven the starting and ending times of each activity, find any schedule that does not require the same person to cover overlapping activities, or say that it is impossible.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing a single integer $\\mathbf{N}$, the number of activities to assign. Then, $\\mathbf{N}$ more lines follow. The $\\mathbf{i}$-th of these lines (counting starting from 1) contains two integers $\\mathbf{S}_{\\mathbf{i}}$ and $\\mathbf{E}_{\\mathbf{i}}$. The $\\mathbf{i}$-th activity starts exactly $\\mathbf{S}_{\\mathbf{i}}$ minutes after midnight and ends exactly $\\mathbf{E}_{\\mathbf{i}}$ minutes after midnight.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathbf{x}$ is the test case number (starting from 1) and $\\mathbf{y}$ is IMPOSSIBLE if there is no valid schedule according to the above rules, or a string of exactly $\\mathbf{N}$ characters otherwise. The $\\mathbf{i}$-th character in $\\mathbf{y}$ must be $\\mathbf{c}$ if the $\\mathbf{i}$-th activity is assigned to Cameron in your proposed schedule, and $\\mathbf{j}$ if it is assigned to Jamie.\n\nIf there are multiple solutions, you may output any one of them.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one described in the problem statement. As mentioned above, there are other valid solutions, like `JCJ` and `JCC`.\n\nIn Sample Case #2, all three activities overlap with each other. Assigning them all would mean someone would end up with at least two overlapping activities, so there is no valid schedule.\n\nIn Sample Case #3, notice that Cameron ends an activity and starts another one at minute 100 .\n\nIn Sample Case #4, any schedule would be valid. Specifically, it is OK for one partner to do all activities.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $0 \\leq \\mathbf{S}_{\\mathbf{i}}<\\mathbf{E}_{\\mathbf{i}} \\leq 24 \\times 60$.\n\n**Test set 1 (7 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 10$.\n\n**Test set 2 (12 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 Qualification] Parenting Partnering Returns", "background": "", "description": "Cameron and Jamie's kid is almost 3 years old! However, even though the child is more independent now, scheduling kid activities and domestic necessities is still a challenge for the couple.\n\nCameron and Jamie have a list of $\\mathbf{N}$ activities to take care of during the day. Each activity happens during a specified interval during the day. They need to assign each activity to one of them, so that neither of them is responsible for two activities that overlap. An activity that ends at time $\\mathbf{t}$ is not considered to overlap with another activity that starts at time $\\mathbf{t}$.\n\nFor example, suppose that Jamie and Cameron need to cover 3 activities: one running from 18:00 to 20:00, another from 19:00 to 21:00 and another from 22:00 to 23:00. One possibility would be for Jamie to cover the activity running from 19:00 to 21:00, with Cameron covering the other two. Another valid schedule would be for Cameron to cover the activity from 18:00 to 20:00 and Jamie to cover the other two. Notice that the first two activities overlap in the time between 19:00 and 20:00, so it is impossible to assign both of those activities to the same partner.\n\nGiven the starting and ending times of each activity, find any schedule that does not require the same person to cover overlapping activities, or say that it is impossible.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing a single integer $\\mathbf{N}$, the number of activities to assign. Then, $\\mathbf{N}$ more lines follow. The $\\mathbf{i}$-th of these lines (counting starting from 1) contains two integers $\\mathbf{S}_{\\mathbf{i}}$ and $\\mathbf{E}_{\\mathbf{i}}$. The $\\mathbf{i}$-th activity starts exactly $\\mathbf{S}_{\\mathbf{i}}$ minutes after midnight and ends exactly $\\mathbf{E}_{\\mathbf{i}}$ minutes after midnight.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathbf{x}$ is the test case number (starting from 1) and $\\mathbf{y}$ is IMPOSSIBLE if there is no valid schedule according to the above rules, or a string of exactly $\\mathbf{N}$ characters otherwise. The $\\mathbf{i}$-th character in $\\mathbf{y}$ must be $\\mathbf{c}$ if the $\\mathbf{i}$-th activity is assigned to Cameron in your proposed schedule, and $\\mathbf{j}$ if it is assigned to Jamie.\n\nIf there are multiple solutions, you may output any one of them.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one described in the problem statement. As mentioned above, there are other valid solutions, like `JCJ` and `JCC`.\n\nIn Sample Case #2, all three activities overlap with each other. Assigning them all would mean someone would end up with at least two overlapping activities, so there is no valid schedule.\n\nIn Sample Case #3, notice that Cameron ends an activity and starts another one at minute 100 .\n\nIn Sample Case #4, any schedule would be valid. Specifically, it is OK for one partner to do all activities.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $0 \\leq \\mathbf{S}_{\\mathbf{i}}<\\mathbf{E}_{\\mathbf{i}} \\leq 24 \\times 60$.\n\n**Test set 1 (7 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 10$.\n\n**Test set 2 (12 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 Qualification] Parenting Partnering Returns", "background": "", "description": "Cameron 和 Jamie 的孩子快 3 岁了！虽然孩子现在更独立了，但安排孩子的活动和家务对这对夫妇来说仍然是个挑战。\n\nCameron 和 Jamie 需要共同完成 $\\mathbf{N}$ 项当天的活动。每项活动都在一天中的特定时间段进行。他们需要将这些活动分配给两人，确保每人不会被分配到时间重叠的两项活动。注意：一项在时间 $\\mathbf{t}$ 结束的活动与另一项在时间 $\\mathbf{t}$ 开始的活动不算重叠。\n\n例如，假设 Jamie 和 Cameron 需要安排 3 项活动：第一项从 18:00 到 20:00，第二项从 19:00 到 21:00，第三项从 22:00 到 23:00。一种可能的分配方式是 Jamie 负责第二项活动（19:00-21:00），Cameron 负责另外两项。另一种有效分配是 Cameron 负责第一项活动（18:00-20:00），Jamie 负责另外两项。注意前两项活动在 19:00 至 20:00 期间重叠，因此不能将它们分配给同一个人。\n\n给定每项活动的开始和结束时间，找出任意一个不要求同一人承担重叠活动的排班方案，或者判定这是不可能的。\n", "inputFormat": "输入的第一行包含测试用例数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含一个整数 $\\mathbf{N}$，表示活动数量。接下来 $\\mathbf{N}$ 行中，第 $\\mathbf{i}$ 行（从 1 开始计数）包含两个整数 $\\mathbf{S}_{\\mathbf{i}}$ 和 $\\mathbf{E}_{\\mathbf{i}}$，表示第 $\\mathbf{i}$ 项活动从午夜后 $\\mathbf{S}_{\\mathbf{i}}$ 分钟开始，到午夜后 $\\mathbf{E}_{\\mathbf{i}}$ 分钟结束。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $\\mathbf{x}$ 是测试用例编号（从 1 开始），$\\mathbf{y}$ 如果不存在有效排班方案则输出 `IMPOSSIBLE`，否则输出一个长度为 $\\mathbf{N}$ 的字符串。字符串的第 $\\mathbf{i}$ 个字符如果是 $\\mathbf{c}$ 表示第 $\\mathbf{i}$ 项活动分配给 Cameron，$\\mathbf{j}$ 表示分配给 Jamie。\n\n若存在多个解，输出任意一个即可。", "hint": "**样例解释**\n\n样例 #1 对应题目描述中的情况。如所述，还存在其他有效解，例如 `JCJ` 和 `JCC`。\n\n样例 #2 中，三项活动互相重叠。无论如何分配都会导致至少一人承担两项重叠活动，因此无解。\n\n样例 #3 中，注意 Cameron 在 100 分钟时结束一项活动并立即开始另一项活动。\n\n样例 #4 中，任意分配方案都有效。特别地，允许一人承担所有活动。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$；\n- $0 \\leq \\mathbf{S}_{\\mathbf{i}} < \\mathbf{E}_{\\mathbf{i}} \\leq 24 \\times 60$。\n\n**测试集 1（7 分，可见判定）**\n\n- $2 \\leq \\mathbf{N} \\leq 10$。\n\n**测试集 2（12 分，可见判定）**\n\n- $2 \\leq \\mathbf{N} \\leq 1000$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13051", "type": "P", "difficulty": 5, "samples": [["", ""]], "limits": {"time": [40000, 40000, 40000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2020", "交互题", "Special Judge", "Google Code Jam"], "title": "[GCJ 2020 Qualification] ESAb ATAd", "background": "", "description": "Last year, a research consortium had some trouble with a distributed database system that sometimes lost pieces of the data. You do not need to read or understand that problem in order to solve this one!\n\nThe consortium has decided that distributed systems are too complicated, so they are storing $\\mathbf{B}$ bits of important information in a single array on one awesome machine. As an additional layer of security, they have made it difficult to obtain the information quickly; the user must query for a bit position between 1 and $\\mathbf{B}$, and then they receive that bit of the stored array as a response.\n\nUnfortunately, this ultra-modern machine is subject to random quantum fluctuations! Specifically, after every 1st, 11th, 21st, 31st... etc. query is sent, but before the response is given, quantum fluctuation causes exactly one of the following four effects, with equal probability:\n\n- 25% of the time, the array is complemented: every 0 becomes a 1, and vice versa.\n- 25% of the time, the array is reversed: the first bit swaps with the last bit, the second bit swaps with the second-to-last bit, and so on.\n- 25% of the time, both of the things above (complementation and reversal) happen to the array. (Notice that the order in which they happen does not matter.)\n- 25% of the time, nothing happens to the array.\n\nMoreover, there is no indication of what effect the quantum fluctuation has had each time. The consortium is now concerned, and it has hired you to get its precious data back, in whatever form it is in! Can you find the entire array, such that your answer is accurate as of the time that you give it? Answering does not count as a query, so if you answer after your 30th query, for example, the array will be the same as it was after your 21st through 30th queries.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing two integers $\\mathbf{T}$ and $\\mathbf{B}$ : the number of test cases and the number of bits in the array, respectively. Note that $\\mathbf{B}$ is the same for every test case.\n\nThen, you need to process $\\mathbf{T}$ test cases. In each case, the judge begins with a predetermined $\\mathbf{B}$-bit array; note that this array can vary from test case to test case, and is not necessarily chosen at random. Then, you may make up to 150 queries of the following form:\n\n* Your program outputs one line containing a single integer $\\mathrm{P}$ between 1 and $\\mathbf{B}$, inclusive, indicating which position in the array you wish to look at.\n* If the number of queries you have made so far ends with a 1 , the judge chooses one of the four possibilities described above (complementation, reversal, complementation + reversal, or nothing), uniformly at random and independently of all other choices, and alters the stored array accordingly. (Notice that this will happen on the very first query you make.)\n* The judge responds with one line containing a single character 0 or 1 , the value it currently has stored at bit position $\\mathrm{P}$, or $\\mathrm{N}$ if you provided a malformed line (e.g., an invalid position).\n\nThen, after you have made as many of the 150 queries above as you want, you must make one more exchange of the following form:\n\n* Your program outputs one line containing a string of $\\mathbf{B}$ characters, each of which is 0 or 1 , representing the bits currently stored in the array (which will not necessarily match the bits that were initially present!)\n* The judge responds with one line containing a single letter: uppercase $\\mathrm{Y}$ if your answer was correct, and uppercase $\\mathrm{N}$ if it was not (or you provided a malformed line). If you receive $\\mathrm{Y}$, you should begin the next test case, or stop sending input if there are no more test cases.\n\nAfter the judge sends $\\mathrm{N}$ to your input stream, it will not send any other output. If your program continues to wait for the judge after receiving $\\mathrm{N}$, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.\n", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "The following interaction corresponds to Test Set 1.\n\n```\n  t, b = readline_int_list()      // reads 100 into t and 10 into b.\n  // The judge starts with the predetermined array for this test case:\n  // 0001101111. (Note: the actual Test Set 1 will not necessarily\n  // use this array.)\n  printline 1 to stdout   // we ask about position 1.\n  flush stdout\n  // Since this is our 1st query, and 1 is 1 mod 10, the judge secretly and\n  // randomly chooses one of the four possible quantum fluctuation effects, as\n  // described above. It happens to choose complementation + reversal, so now\n  // the stored value is 0000100111.\n  r = readline_chr()      // reads 0.\n  printline 6 to stdout   // we ask about position 6.\n  flush stdout\n  // Since this is our 2nd query, and 2 is 2 mod 10, the judge does not choose\n  // a quantum fluctuation effect.\n  r = readline_chr()      // reads 0.\n  ...\n  // We have omitted the third through tenth queries in this example.\n  ...\n  printline 1 to stdout   // we decide to ask about position 1 again.\n  flush stdout\n  // Since this is our 11th query, and 11 is 1 mod 10, the judge secretly and\n  // randomly chooses a quantum fluctuation effect, and happens to get\n  // reversal, so now the stored value is 1110010000.\n  r = readline_chr()      // reads 1.\n  printline 1110110000 to stdout   // we try to answer. why?!?!\n  flush stdout\n  ok = readline_chr()     // reads N -- we have made a mistake!\n  exit                    // exits to avoid an ambiguous TLE error\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\n**Limits**\n\n$1 \\leq \\mathbf{T} \\leq 100$.\n\n**Test set 1 (1 Pts, Visible Verdict)**\n\n- $\\mathrm{B}=10$.\n\n**Test set 2 (9 Pts, Visible Verdict)**\n\n- $\\mathrm{B}=20$.\n\n**Test set 3 (16 Pts, Hidden Verdict)**\n\n- $\\mathrm{B}=100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 Qualification] ESAb ATAd", "background": "", "description": "Last year, a research consortium had some trouble with a distributed database system that sometimes lost pieces of the data. You do not need to read or understand that problem in order to solve this one!\n\nThe consortium has decided that distributed systems are too complicated, so they are storing $\\mathbf{B}$ bits of important information in a single array on one awesome machine. As an additional layer of security, they have made it difficult to obtain the information quickly; the user must query for a bit position between 1 and $\\mathbf{B}$, and then they receive that bit of the stored array as a response.\n\nUnfortunately, this ultra-modern machine is subject to random quantum fluctuations! Specifically, after every 1st, 11th, 21st, 31st... etc. query is sent, but before the response is given, quantum fluctuation causes exactly one of the following four effects, with equal probability:\n\n- 25% of the time, the array is complemented: every 0 becomes a 1, and vice versa.\n- 25% of the time, the array is reversed: the first bit swaps with the last bit, the second bit swaps with the second-to-last bit, and so on.\n- 25% of the time, both of the things above (complementation and reversal) happen to the array. (Notice that the order in which they happen does not matter.)\n- 25% of the time, nothing happens to the array.\n\nMoreover, there is no indication of what effect the quantum fluctuation has had each time. The consortium is now concerned, and it has hired you to get its precious data back, in whatever form it is in! Can you find the entire array, such that your answer is accurate as of the time that you give it? Answering does not count as a query, so if you answer after your 30th query, for example, the array will be the same as it was after your 21st through 30th queries.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing two integers $\\mathbf{T}$ and $\\mathbf{B}$ : the number of test cases and the number of bits in the array, respectively. Note that $\\mathbf{B}$ is the same for every test case.\n\nThen, you need to process $\\mathbf{T}$ test cases. In each case, the judge begins with a predetermined $\\mathbf{B}$-bit array; note that this array can vary from test case to test case, and is not necessarily chosen at random. Then, you may make up to 150 queries of the following form:\n\n* Your program outputs one line containing a single integer $\\mathrm{P}$ between 1 and $\\mathbf{B}$, inclusive, indicating which position in the array you wish to look at.\n* If the number of queries you have made so far ends with a 1 , the judge chooses one of the four possibilities described above (complementation, reversal, complementation + reversal, or nothing), uniformly at random and independently of all other choices, and alters the stored array accordingly. (Notice that this will happen on the very first query you make.)\n* The judge responds with one line containing a single character 0 or 1 , the value it currently has stored at bit position $\\mathrm{P}$, or $\\mathrm{N}$ if you provided a malformed line (e.g., an invalid position).\n\nThen, after you have made as many of the 150 queries above as you want, you must make one more exchange of the following form:\n\n* Your program outputs one line containing a string of $\\mathbf{B}$ characters, each of which is 0 or 1 , representing the bits currently stored in the array (which will not necessarily match the bits that were initially present!)\n* The judge responds with one line containing a single letter: uppercase $\\mathrm{Y}$ if your answer was correct, and uppercase $\\mathrm{N}$ if it was not (or you provided a malformed line). If you receive $\\mathrm{Y}$, you should begin the next test case, or stop sending input if there are no more test cases.\n\nAfter the judge sends $\\mathrm{N}$ to your input stream, it will not send any other output. If your program continues to wait for the judge after receiving $\\mathrm{N}$, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.\n", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "The following interaction corresponds to Test Set 1.\n\n```\n  t, b = readline_int_list()      // reads 100 into t and 10 into b.\n  // The judge starts with the predetermined array for this test case:\n  // 0001101111. (Note: the actual Test Set 1 will not necessarily\n  // use this array.)\n  printline 1 to stdout   // we ask about position 1.\n  flush stdout\n  // Since this is our 1st query, and 1 is 1 mod 10, the judge secretly and\n  // randomly chooses one of the four possible quantum fluctuation effects, as\n  // described above. It happens to choose complementation + reversal, so now\n  // the stored value is 0000100111.\n  r = readline_chr()      // reads 0.\n  printline 6 to stdout   // we ask about position 6.\n  flush stdout\n  // Since this is our 2nd query, and 2 is 2 mod 10, the judge does not choose\n  // a quantum fluctuation effect.\n  r = readline_chr()      // reads 0.\n  ...\n  // We have omitted the third through tenth queries in this example.\n  ...\n  printline 1 to stdout   // we decide to ask about position 1 again.\n  flush stdout\n  // Since this is our 11th query, and 11 is 1 mod 10, the judge secretly and\n  // randomly chooses a quantum fluctuation effect, and happens to get\n  // reversal, so now the stored value is 1110010000.\n  r = readline_chr()      // reads 1.\n  printline 1110110000 to stdout   // we try to answer. why?!?!\n  flush stdout\n  ok = readline_chr()     // reads N -- we have made a mistake!\n  exit                    // exits to avoid an ambiguous TLE error\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\n**Limits**\n\n$1 \\leq \\mathbf{T} \\leq 100$.\n\n**Test set 1 (1 Pts, Visible Verdict)**\n\n- $\\mathrm{B}=10$.\n\n**Test set 2 (9 Pts, Visible Verdict)**\n\n- $\\mathrm{B}=20$.\n\n**Test set 3 (16 Pts, Hidden Verdict)**\n\n- $\\mathrm{B}=100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 Qualification] ESAb ATAd", "background": "", "description": "去年，一个研究联盟在使用分布式数据库系统时遇到了问题，该系统有时会丢失部分数据。不过你不需要理解那个问题就能解决本题！\n\n该联盟认为分布式系统过于复杂，于是决定将 $\\mathbf{B}$ 位重要信息存储在一台超级计算机的单个数组中。为了增加安全性，他们设置了获取信息的障碍：用户必须查询 1 到 $\\mathbf{B}$ 之间的位位置，才能获得该位存储的值。\n\n不幸的是，这台超现代计算机会受到随机量子涨落的影响！具体来说，在发送第 1、11、21、31...次查询后（但在返回响应前），量子涨落会以均等概率（各 25%）引发以下四种效应之一：\n\n* 数组取反：所有 0 变 1，所有 1 变 0；\n* 数组反转：第 1 位与第 $\\mathbf{B}$ 位交换，第 2 位与第 $\\mathbf{B}-1$ 位交换，以此类推；\n* 同时发生取反和反转（顺序无关）；\n* 数组保持不变。\n\n每次量子涨落的影响没有任何提示。联盟现在非常担忧，雇佣你来恢复这些珍贵数据（无论它们当前处于何种状态）！你能否找出整个数组，使得你的答案在提交时是准确的？注意：提交答案不算作查询，例如如果你在第 30 次查询后提交答案，数组状态将与第 21-30 次查询期间的状态一致。\n\n### 交互协议\n\n这是一个交互题。\n\n初始时，你的程序应读取包含两个整数 $\\mathbf{T}$ 和 $\\mathbf{B}$ 的单行输入：分别表示测试用例数量和数组位数。注意所有测试用例的 $\\mathbf{B}$ 相同。\n\n接着处理 $\\mathbf{T}$ 个测试用例。每个用例中，评测系统会预设一个 $\\mathbf{B}$ 位数组（注意该数组可能因用例而异，且不一定是随机生成的）。你可以进行最多 150 次如下形式的查询：\n\n* 你的程序输出 1 到 $\\mathbf{B}$ 之间的整数 $\\mathrm{P}$，表示要查询的位位置；\n* 若当前查询次数是第 1、11、21...次（即模 10 余 1），评测系统会随机选择上述四种效应之一（独立于之前的选择）改变数组；\n* 评测系统返回单字符 0 或 1 表示当前 $\\mathrm{P}$ 位的值，若 $\\mathrm{P}$ 非法则返回 $\\mathrm{N}$。\n\n完成查询后，你必须进行如下最终交互：\n\n* 你的程序输出由 $\\mathbf{B}$ 个 0/1 组成的字符串，表示当前数组状态（可能与初始状态不同）；\n* 评测系统返回 $\\mathrm{Y}$ 表示答案正确，$\\mathrm{N}$ 表示错误（或格式非法）。收到 $\\mathrm{Y}$ 后应处理下一个测试用例，若无更多用例则终止程序。\n\n当评测系统返回 $\\mathrm{N}$ 后，将不再发送任何输出。若你的程序继续等待会导致超时错误。注意：你需要确保程序及时退出以避免超时错误。若内存超限或运行时错误，将得到相应判果。", "inputFormat": "参见交互协议。", "outputFormat": "参见交互协议。", "hint": "以下交互对应测试集 1：\n\n```\nt, b = readline_int_list() // 读取 t=100 和 b=10\n// 评测系统初始数组：0001101111（实际测试集 1 不一定使用此数组）\nprintline 1 // 查询第 1 位\nflush stdout\n// 这是第 1 次查询（1 mod 10），系统随机选择取反+反转，数组变为 0000100111\nr = readline_chr() // 返回 0\nprintline 6 // 查询第 6 位\nflush stdout\n// 第 2 次查询（2 mod 10），无量子涨落\nr = readline_chr() // 返回 0\n...\n// 此处省略第 3-10 次查询\n...\nprintline 1 // 再次查询第 1 位\nflush stdout\n// 第 11 次查询（11 mod 10），系统随机选择反转，数组变为 1110010000\nr = readline_chr() // 返回 1\nprintline 1110110000 // 尝试提交错误答案\nflush stdout\nok = readline_chr() // 返回 N\nexit // 退出以避免超时错误\n```\n\n可使用[交互测试工具](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)进行本地测试。\n\n**数据范围**\n\n$1 \\leq \\mathbf{T} \\leq 100$\n\n**测试集 1（1 分，可见判果）**\n\n- $\\mathrm{B}=10$\n\n**测试集 2（9 分，可见判果）**\n\n- $\\mathrm{B}=20$\n\n**测试集 3（16 分，隐藏判果）**\n\n- $\\mathrm{B}=100$\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13052", "type": "P", "difficulty": 6, "samples": [["2\n3 6\n2 3", "Case #1: POSSIBLE\n2 1 3\n3 2 1\n1 3 2\nCase #2: IMPOSSIBLE"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2020", "Special Judge", "构造", "Ad-hoc", "Google Code Jam"], "title": "[GCJ 2020 Qualification] Indicium", "background": "", "description": "Indicium means \"trace\" in Latin. In this problem we work with Latin squares and matrix traces.\n\nA Latin square is an $\\mathbf{N}$-by-$\\mathbf{N}$ square matrix in which each cell contains one of $\\mathbf{N}$ different values, such that no value is repeated within a row or a column. In this problem, we will deal only with \"natural Latin squares\" in which the $\\mathbf{N}$ values are the integers between 1 and $\\mathbf{N}$.\n\nThe trace of a square matrix is the sum of the values on the main diagonal (which runs from the upper left to the lower right).\n\nGiven values $\\mathbf{N}$ and $\\mathbf{K}$, produce any $\\mathbf{N}$-by-$\\mathbf{N}$ \"natural Latin square\" with trace $\\mathbf{K}$, or say it is impossible. For example, here are two possible answers for $\\mathbf{N}=3, \\mathbf{K}=6$. In each case, the values that contribute to the trace are underlined.\n\n$\\begin{array}{llll}\\underline{2} & 1 & 3 & \\underline{3} \\\\3 & \\underline{2} & 1 & 1 \\\\1 & 3 & \\underline{2} & 2\\end{array} \\begin{array}{lll}1 & 2 \\\\ \\underline{2} & 3 \\\\3 & \\underline{1}\\end{array}$\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each consists of one line containing two integers $\\mathbf{N}$ and $\\mathbf{K}$ : the desired size of the matrix and the desired trace.\n\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is IMPOSSIBLE if there is no answer for the given parameters or POSSIBLE otherwise. In the latter case, output $\\mathbf{N}$ more lines of $\\mathbf{N}$ integers each, representing a valid \"natural Latin square\" with a trace of $\\mathbf{K}$, as described above.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one described in the problem statement.\n\nSample Case #2 has no answer. The only possible 2-by-2 \"natural Latin squares\" are as follows:\n\n```\n1 2 2 1\n2 1 1 2\n```\n\nThese have traces of 2 and 4, respectively. There is no way to get a trace of 3.\n\n**Limits**\n\n- $\\mathrm{N} \\leqslant \\mathrm{K} \\leqslant \\mathrm{N}^{2}$.\n\n**Test set 1 (7 Pts, Visible Verdict)**\n\n- $\\mathrm{T}=44$.\n- $2 \\leqslant \\mathrm{N} \\leqslant 5$.\n\n**Test set 2 (25 Pts, Hidden Verdict)**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$.\n- $2 \\leqslant \\mathrm{N} \\leqslant 50$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 Qualification] Indicium", "background": "", "description": "Indicium means \"trace\" in Latin. In this problem we work with Latin squares and matrix traces.\n\nA Latin square is an $\\mathbf{N}$-by-$\\mathbf{N}$ square matrix in which each cell contains one of $\\mathbf{N}$ different values, such that no value is repeated within a row or a column. In this problem, we will deal only with \"natural Latin squares\" in which the $\\mathbf{N}$ values are the integers between 1 and $\\mathbf{N}$.\n\nThe trace of a square matrix is the sum of the values on the main diagonal (which runs from the upper left to the lower right).\n\nGiven values $\\mathbf{N}$ and $\\mathbf{K}$, produce any $\\mathbf{N}$-by-$\\mathbf{N}$ \"natural Latin square\" with trace $\\mathbf{K}$, or say it is impossible. For example, here are two possible answers for $\\mathbf{N}=3, \\mathbf{K}=6$. In each case, the values that contribute to the trace are underlined.\n\n$\\begin{array}{llll}\\underline{2} & 1 & 3 & \\underline{3} \\\\3 & \\underline{2} & 1 & 1 \\\\1 & 3 & \\underline{2} & 2\\end{array} \\begin{array}{lll}1 & 2 \\\\ \\underline{2} & 3 \\\\3 & \\underline{1}\\end{array}$\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each consists of one line containing two integers $\\mathbf{N}$ and $\\mathbf{K}$ : the desired size of the matrix and the desired trace.\n\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is IMPOSSIBLE if there is no answer for the given parameters or POSSIBLE otherwise. In the latter case, output $\\mathbf{N}$ more lines of $\\mathbf{N}$ integers each, representing a valid \"natural Latin square\" with a trace of $\\mathbf{K}$, as described above.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one described in the problem statement.\n\nSample Case #2 has no answer. The only possible 2-by-2 \"natural Latin squares\" are as follows:\n\n```\n1 2 2 1\n2 1 1 2\n```\n\nThese have traces of 2 and 4, respectively. There is no way to get a trace of 3.\n\n**Limits**\n\n- $\\mathrm{N} \\leqslant \\mathrm{K} \\leqslant \\mathrm{N}^{2}$.\n\n**Test set 1 (7 Pts, Visible Verdict)**\n\n- $\\mathrm{T}=44$.\n- $2 \\leqslant \\mathrm{N} \\leqslant 5$.\n\n**Test set 2 (25 Pts, Hidden Verdict)**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$.\n- $2 \\leqslant \\mathrm{N} \\leqslant 50$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 Qualification] Indicium", "background": null, "description": "Indicium 在拉丁语中意为\"迹\"。本题中我们将研究拉丁方阵及其矩阵迹。\n\n一个拉丁方阵是指 $\\mathbf{N} \\times \\mathbf{N}$ 的方阵，其中每个单元格包含 $\\mathbf{N}$ 个不同值之一，且每行每列都不重复出现相同值。在本题中，我们仅处理\"自然拉丁方阵\"，即这些 $\\mathbf{N}$ 个值为 1 到 $\\mathbf{N}$ 的整数。\n\n方阵的迹是指主对角线（从左上到右下）上所有值的和。\n\n给定 $\\mathbf{N}$ 和 $\\mathbf{K}$，构造任意一个迹为 $\\mathbf{K}$ 的 $\\mathbf{N} \\times \\mathbf{N}$ 自然拉丁方阵，或判定其不存在。例如，以下是 $\\mathbf{N}=3, \\mathbf{K}=6$ 时的两种可能解（贡献迹的值已加下划线）：\n\n$\\begin{array}{lll}\n\\underline{2} & 1 & 3 \\\\ \n3 & \\underline{2} & 1 \\\\ \n1 & 3 & \\underline{2}\n\\end{array}\n\\quad\n\\begin{array}{lll}\n\\underline{3} & 1 & 2 \\\\ \n1 & \\underline{2} &3 \\\\ \n2 & 3 & \\underline{1}\n\\end{array}$", "inputFormat": "输入第一行包含测试用例数 $\\mathbf{T}$。随后 $\\mathbf{T}$ 行，每行包含两个整数 $\\mathbf{N}$ 和 $\\mathbf{K}$，分别表示方阵大小和期望的迹。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为 `IMPOSSIBLE`（无解时）或 `POSSIBLE`（有解时）。若有解，还需输出 $\\mathbf{N}$ 行，每行 $\\mathbf{N}$ 个整数表示满足条件的自然拉丁方阵。", "hint": "**样例解释**\n\n样例 #1 对应题目描述中的情况。\n\n样例 #2 无解。所有可能的 2×2 自然拉丁方阵如下：\n\n```\n1 2 2 1\n2 1 1 2\n```\n\n它们的迹分别为 2 和 4，无法得到迹 3。\n\n**数据范围**\n\n- $\\mathrm{N} \\leqslant \\mathrm{K} \\leqslant \\mathrm{N}^{2}$\n\n**测试集 1（7 分，可见判果）**\n\n- $\\mathrm{T}=44$\n- $2 \\leqslant \\mathrm{N} \\leqslant 5$\n\n**测试集 2（25 分，隐藏判果）**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$\n- $2 \\leqslant \\mathrm{N} \\leqslant 50$\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13053", "type": "P", "difficulty": 3, "samples": [["2\n5\n*CONUTS\n*COCONUTS\n*OCONUTS\n*CONUTS\n*S\n2\n*XZ\n*XYZ", "Case #1: COCONUTS\nCase #2: *"]], "limits": {"time": [20000, 20000, 20000, 20000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["字符串", "2020", "Special Judge", "Google Code Jam"], "title": "[GCJ 2020 #1A] Pattern Matching", "background": "", "description": "Many terminals use asterisks (`*`) to signify \"any string\", including the empty string. For example, when listing files matching `BASH*`, a terminal may list BASH, BASHER and BASHFUL. For `*FUL`, it may list BEAUTIFUL, AWFUL and BASHFUL. When listing `B*L`, BASHFUL, BEAUTIFUL and BULL may be listed.\n\nIn this problem, formally, a pattern is a string consisting of only uppercase English letters and asterisks (`*`), and a name is a string consisting of only uppercase English letters. A pattern $p$ matches a name $m$ if there is a way of replacing every asterisk in $p$ with a (possibly empty) string to obtain $m$. Notice that each asterisk may be replaced by a different string.\n\nGiven $\\mathrm{N}$ patterns, can you find a single name of at most $10^{4}$ letters that matches all those patterns at once, or report that it cannot be done?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. Each test case starts with a line with a single integer $\\mathrm{N}$: the number of patterns to simultaneously match. Then, $\\mathrm{N}$ lines follow, each one containing a single string $\\mathrm{P}_{\\mathrm{i}}$ representing the $\\mathrm{i}$-th pattern.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is any name containing at most $10^{4}$ letters such that each $\\mathrm{P}_{\\mathrm{i}}$ matches $\\mathrm{y}$ according to the definition above, or `*` (i.e., just an asterisk) if there is no such name.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are other possible answers, including COCOCONUTS and ILIKECOCONUTS. Neither COCONUTSAREGREAT nor COCOANUTS would be acceptable. Notice that the same pattern may appear more than once within a test case.\n\nIn Sample Case #2, there is no acceptable name, so the answer is `*`.\n\nThe following cases could not appear in Test Set 1, but could appear in Test Set 2 or Test Set 3:\n```\n  4\n  H*O\n  HELLO*\n  *HELLO\n  HE*\n```\nHELLO and HELLOGOODBYEHELLO are examples of acceptable answers. OTHELLO and HELLOO would not be acceptable.\n```\n  2\n  CO*DE\n  J*AM\n```\nThere is no name that matches both patterns, so the answer would be `*`.\n```\n  2\n  CODE*\n  *JAM\n```\nCODEJAM is one example of an acceptable answer.\n\nThe following cases could not appear in Test Set 1 or Test Set 2, but could appear in Test Set 3:\n```\n  2\n  A*C*E\n  *B*D*\n```\nABCDE and ABUNDANCE are among the possible acceptable answers, but BOLDFACE is not.\n```\n  2\n  A*C*E\n  *B*D\n```\nThere is no name that matches both patterns, so the answer would be `*`.\n\n**Limits**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$.\n- $2 \\leqslant \\mathrm{N} \\leqslant 50$.\n- $2 \\leqslant$ length of $\\mathrm{P}_{\\mathrm{i}} \\leqslant 100$, for all $\\mathrm{i}$.\n- Each character of $\\mathrm{P}_{\\mathrm{i}}$ is either an uppercase English letter or an asterisk (*), for all $\\mathrm{i}$.\n- At least one character of $\\mathrm{P}_{\\mathrm{i}}$ is an uppercase English letter, for all $\\mathrm{i}$.\n\n**Test set 1 (5 Pts, Visible Verdict)**\n\n- Exactly one character of $\\mathrm{P}_{\\mathrm{i}}$ is an asterisk (*), for all $\\mathrm{i}$.\n\n- The leftmost character of $\\mathrm{P}_{\\mathrm{i}}$ is the only asterisk (*), for all $\\mathrm{i}$.\n\n**Test set 2 (5 Pts, Visible Verdict)**\n\n- Exactly one character of $\\mathrm{P}_{\\mathrm{i}}$ is an asterisk (*), for all $\\mathrm{i}$.\n\n**Test set 3 (18 Pts, Visible Verdict)**\n\n- At least one character of $\\mathrm{P}_{\\mathrm{i}}$ is an asterisk (*), for all $\\mathrm{i}$.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #1A] Pattern Matching", "background": "", "description": "Many terminals use asterisks (`*`) to signify \"any string\", including the empty string. For example, when listing files matching `BASH*`, a terminal may list BASH, BASHER and BASHFUL. For `*FUL`, it may list BEAUTIFUL, AWFUL and BASHFUL. When listing `B*L`, BASHFUL, BEAUTIFUL and BULL may be listed.\n\nIn this problem, formally, a pattern is a string consisting of only uppercase English letters and asterisks (`*`), and a name is a string consisting of only uppercase English letters. A pattern $p$ matches a name $m$ if there is a way of replacing every asterisk in $p$ with a (possibly empty) string to obtain $m$. Notice that each asterisk may be replaced by a different string.\n\nGiven $\\mathrm{N}$ patterns, can you find a single name of at most $10^{4}$ letters that matches all those patterns at once, or report that it cannot be done?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. Each test case starts with a line with a single integer $\\mathrm{N}$: the number of patterns to simultaneously match. Then, $\\mathrm{N}$ lines follow, each one containing a single string $\\mathrm{P}_{\\mathrm{i}}$ representing the $\\mathrm{i}$-th pattern.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is any name containing at most $10^{4}$ letters such that each $\\mathrm{P}_{\\mathrm{i}}$ matches $\\mathrm{y}$ according to the definition above, or `*` (i.e., just an asterisk) if there is no such name.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are other possible answers, including COCOCONUTS and ILIKECOCONUTS. Neither COCONUTSAREGREAT nor COCOANUTS would be acceptable. Notice that the same pattern may appear more than once within a test case.\n\nIn Sample Case #2, there is no acceptable name, so the answer is `*`.\n\nThe following cases could not appear in Test Set 1, but could appear in Test Set 2 or Test Set 3:\n```\n  4\n  H*O\n  HELLO*\n  *HELLO\n  HE*\n```\nHELLO and HELLOGOODBYEHELLO are examples of acceptable answers. OTHELLO and HELLOO would not be acceptable.\n```\n  2\n  CO*DE\n  J*AM\n```\nThere is no name that matches both patterns, so the answer would be `*`.\n```\n  2\n  CODE*\n  *JAM\n```\nCODEJAM is one example of an acceptable answer.\n\nThe following cases could not appear in Test Set 1 or Test Set 2, but could appear in Test Set 3:\n```\n  2\n  A*C*E\n  *B*D*\n```\nABCDE and ABUNDANCE are among the possible acceptable answers, but BOLDFACE is not.\n```\n  2\n  A*C*E\n  *B*D\n```\nThere is no name that matches both patterns, so the answer would be `*`.\n\n**Limits**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$.\n- $2 \\leqslant \\mathrm{N} \\leqslant 50$.\n- $2 \\leqslant$ length of $\\mathrm{P}_{\\mathrm{i}} \\leqslant 100$, for all $\\mathrm{i}$.\n- Each character of $\\mathrm{P}_{\\mathrm{i}}$ is either an uppercase English letter or an asterisk (*), for all $\\mathrm{i}$.\n- At least one character of $\\mathrm{P}_{\\mathrm{i}}$ is an uppercase English letter, for all $\\mathrm{i}$.\n\n**Test set 1 (5 Pts, Visible Verdict)**\n\n- Exactly one character of $\\mathrm{P}_{\\mathrm{i}}$ is an asterisk (*), for all $\\mathrm{i}$.\n\n- The leftmost character of $\\mathrm{P}_{\\mathrm{i}}$ is the only asterisk (*), for all $\\mathrm{i}$.\n\n**Test set 2 (5 Pts, Visible Verdict)**\n\n- Exactly one character of $\\mathrm{P}_{\\mathrm{i}}$ is an asterisk (*), for all $\\mathrm{i}$.\n\n**Test set 3 (18 Pts, Visible Verdict)**\n\n- At least one character of $\\mathrm{P}_{\\mathrm{i}}$ is an asterisk (*), for all $\\mathrm{i}$.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #1A] Pattern Matching", "background": "", "description": "许多终端使用星号(`*`)表示\"任意字符串\"，包括空字符串。例如，当列出匹配`BASH*`的文件时，终端可能显示 BASH、BASHER 和 BASHFUL。对于`*FUL`，可能显示 BEAUTIFUL、AWFUL 和 BASHFUL。当列出`B*L`时，可能显示 BASHFUL、BEAUTIFUL 和 BULL。\n\n在本题中，**模式**是仅由大写字母和星号(`*`)组成的字符串，**名称**是仅由大写字母组成的字符串。若模式 $p$ 能通过将每个星号替换为任意字符串（可为空）得到名称 $m$，则称 $p$ 匹配 $m$。注意不同星号可被替换为不同字符串。\n\n给定 $\\mathrm{N}$ 个模式，请构造一个长度不超过 $10^{4}$ 的字符串，使其同时匹配所有给定模式；若不存在这样的字符串，则报告无解。", "inputFormat": "输入第一行包含测试用例数 $\\mathrm{T}$。随后每个测试用例包含：\n- 第一行：整数 $\\mathrm{N}$ 表示模式数量\n- 随后 $\\mathrm{N}$ 行：每行一个字符串 $\\mathrm{P}_{\\mathrm{i}}$ 表示第 $\\mathrm{i}$ 个模式\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中：\n- $x$ 为测试用例编号（从 1 开始）\n- $y$ 为满足条件的长度不超过 $10^{4}$ 的字符串，若无解则输出 `*`\n", "hint": "样例 #1 中，其他可行解包括 COCOCONUTS 和 ILIKECOCONUTS，但 COCONUTSAREGREAT 和 COCOANUTS 不符合要求。注意同一模式可能在测试用例中重复出现。\n\n样例 #2 无解，故输出 `*`。\n\n以下情况不会出现在测试集 1，但可能出现在测试集 2 或 3：\n\n```\n  4\n  H*O\n  HELLO*\n  *HELLO\n  HE*\n```\n\n可行解包括 HELLO 和 HELLOGOODBYEHELLO，但 OTHELLO 和 HELLOO 不符合。\n\n```\n  2\n  CO*DE\n  J*AM\n```\n\n无解，输出 `*`。\n\n```\n  2\n  CODE*\n  *JAM\n```\n\nCODEJAM 是可行解之一。\n\n以下情况仅可能出现在测试集 3：\n\n```\n  2\n  A*C*E\n  *B*D*\n```\n\n可行解包括 ABCDE 和 ABUNDANCE，但 BOLDFACE 不符合。\n\n```\n  2\n  A*C*E\n  *B*D\n```\n\n无解，输出 `*`。\n\n**数据范围**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$\n- $2 \\leqslant \\mathrm{N} \\leqslant 50$\n- $2 \\leqslant \\mathrm{P}_{\\mathrm{i}}$ 长度 $\\leqslant 100$\n- 每个 $\\mathrm{P}_{\\mathrm{i}}$ 仅含大写字母和星号\n- 每个 $\\mathrm{P}_{\\mathrm{i}}$ 至少包含一个大写字母\n\n**测试集 1（5 分，可见判果）**\n- 每个 $\\mathrm{P}_{\\mathrm{i}}$ 仅含一个星号\n- 星号必须位于模式开头\n\n**测试集 2（5 分，可见判果）**\n- 每个 $\\mathrm{P}_{\\mathrm{i}}$ 仅含一个星号\n\n**测试集 3（18 分，可见判果）**\n- 每个 $\\mathrm{P}_{\\mathrm{i}}$ 至少含一个星号\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13054", "type": "P", "difficulty": 4, "samples": [["3\n1\n4\n19", "Case #1:\n1 1\nCase #2:\n1 1\n2 1\n2 2\n3 3\nCase #3:\n1 1\n2 2\n3 2\n4 3\n5 3\n5 2\n4 1\n3 1"]], "limits": {"time": [20000, 20000, 20000, 20000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "2020", "Special Judge", "构造", "Google Code Jam"], "title": "[GCJ 2020 #1A] Pascal Walk", "background": "", "description": "Pascal's triangle consists of an infinite number of rows of an increasing number of integers each, arranged in a triangular shape.\n\nLet us define $(r, k)$ as the $k$-th position from the left in the $r$-th row, with both $r$ and $k$ counted starting from 1. Then Pascal's triangle is defined by the following rules:\n\n- The $r$-th row contains $r$ positions $(r, 1),(r, 2), \\ldots,(r, r)$.\n- The numbers at positions $(r, 1)$ and $(r, r)$ are 1 , for all $r$.\n- The number at position $(r, k)$ is the sum of the numbers at positions $(r-1, k-1)$ and $(r-1, k)$, for all $k$ with $2 \\leqslant k \\leqslant r-1$.\n\nThe first 5 rows of Pascal's triangle look like this:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6s8m35j7.png)\n\nIn this problem, a Pascal walk is a sequence of $\\mathrm{s}$ positions $\\left(\\mathrm{r}_{1}, \\mathrm{k}_{1}\\right),\\left(\\mathrm{r}_{2}, \\mathrm{k}_{2}\\right), \\ldots,\\left(\\mathrm{r}_{\\mathrm{s}}, \\mathrm{k}_{\\mathrm{s}}\\right)$ in Pascal's triangle that satisfy the following criteria:\n\n- $\\mathrm{r}_{1}=1$ and $\\mathrm{k}_{1}=1$.\n- Each subsequent position must be within the triangle and adjacent (in one of the six possible directions) to the previous position. That is, for all $\\mathrm{i} \\geqslant 1,\\left(\\mathrm{r}_{\\mathrm{i}+1}, \\mathrm{k}_{\\mathrm{i}+1}\\right)$ must be one of the following that is within the triangle: $\\left(\\mathrm{r}_{\\mathrm{i}}-1, \\mathrm{k}_{\\mathrm{i}}-1\\right),\\left(\\mathrm{r}_{\\mathrm{i}}-1, \\mathrm{k}_{\\mathrm{i}}\\right),\\left(\\mathrm{r}_{\\mathrm{i}}, \\mathrm{k}_{\\mathrm{i}}-1\\right),\\left(\\mathrm{r}_{\\mathrm{i}}, \\mathrm{k}_{\\mathrm{i}}+1\\right),\\left(\\mathrm{r}_{\\mathrm{i}}+1, \\mathrm{k}_{\\mathrm{i}}\\right),\\left(\\mathrm{r}_{\\mathrm{i}}+1, \\mathrm{k}_{\\mathrm{i}}+1\\right)$.\n- No position may be repeated within the sequence. That is, for every $\\mathrm{i} \\neq \\mathrm{j}$, either $\\mathrm{r}_{\\mathrm{i}} \\neq \\mathrm{r}_{\\mathrm{j}}$ or $\\mathrm{k}_{\\mathrm{i}} \\neq \\mathrm{k}_{\\mathrm{j}}$, or both.\n\nFind any Pascal walk of $\\mathrm{S} \\leqslant 500$ positions such that the sum of the numbers in all of the positions it visits is equal to $\\mathrm{N}$. It is guaranteed that at least one such walk exists for every $\\mathrm{N}$.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. Each consists of a single line containing a single integer $\\mathrm{N}$.\n", "outputFormat": "For each test case, first output a line containing case #x:, where $\\mathrm{x}$ is the test case number (starting from 1). Then, output your proposed Pascal walk of length $\\mathrm{S} \\leqslant 500$ using $\\mathrm{S}$ additional lines. The $\\mathrm{i}$-th of these lines must be $\\mathrm{r}_{\\mathrm{i}} \\mathrm{k}_{\\mathrm{i}}$ where $\\left(\\mathrm{r}_{\\mathrm{i}}, \\mathrm{k}_{\\mathrm{i}}\\right)$ is the $\\mathrm{i}$-th position in the walk. For example, the first line should be $1 \\quad 1$ since the first position for all valid walks is $(1,1)$. The sum of the numbers at the $\\mathrm{S}$ positions of your proposed Pascal walk must be exactly $\\mathrm{N}$.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, only the starting position is needed.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/06jwicgw.png)\n\nIn Sample Case #2, notice that although a shorter path exists, the path does not need to be of minimal length, as long as it uses no more than 500 positions.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/scfogipe.png)\n\nThe following image depicts our solution to Sample Case #3:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x6b2j5as.png)\n\n**Limits**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$.\n\n**Test set 1 (3 Pts, Visible Verdict)**\n\n- $1 \\leqslant \\mathrm{N} \\leqslant 501$.\n\n**Test set 2 (11 Pts, Visible Verdict)**\n\n- $1 \\leqslant \\mathrm{N} \\leqslant 1000$.\n\n**Test set 3 (21 Pts, Hidden Verdict)**\n\n- $1 \\leqslant \\mathrm{N} \\leqslant 10^{9}$.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #1A] Pascal Walk", "background": "", "description": "Pascal's triangle consists of an infinite number of rows of an increasing number of integers each, arranged in a triangular shape.\n\nLet us define $(r, k)$ as the $k$-th position from the left in the $r$-th row, with both $r$ and $k$ counted starting from 1. Then Pascal's triangle is defined by the following rules:\n\n- The $r$-th row contains $r$ positions $(r, 1),(r, 2), \\ldots,(r, r)$.\n- The numbers at positions $(r, 1)$ and $(r, r)$ are 1 , for all $r$.\n- The number at position $(r, k)$ is the sum of the numbers at positions $(r-1, k-1)$ and $(r-1, k)$, for all $k$ with $2 \\leqslant k \\leqslant r-1$.\n\nThe first 5 rows of Pascal's triangle look like this:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6s8m35j7.png)\n\nIn this problem, a Pascal walk is a sequence of $\\mathrm{s}$ positions $\\left(\\mathrm{r}_{1}, \\mathrm{k}_{1}\\right),\\left(\\mathrm{r}_{2}, \\mathrm{k}_{2}\\right), \\ldots,\\left(\\mathrm{r}_{\\mathrm{s}}, \\mathrm{k}_{\\mathrm{s}}\\right)$ in Pascal's triangle that satisfy the following criteria:\n\n- $\\mathrm{r}_{1}=1$ and $\\mathrm{k}_{1}=1$.\n- Each subsequent position must be within the triangle and adjacent (in one of the six possible directions) to the previous position. That is, for all $\\mathrm{i} \\geqslant 1,\\left(\\mathrm{r}_{\\mathrm{i}+1}, \\mathrm{k}_{\\mathrm{i}+1}\\right)$ must be one of the following that is within the triangle: $\\left(\\mathrm{r}_{\\mathrm{i}}-1, \\mathrm{k}_{\\mathrm{i}}-1\\right),\\left(\\mathrm{r}_{\\mathrm{i}}-1, \\mathrm{k}_{\\mathrm{i}}\\right),\\left(\\mathrm{r}_{\\mathrm{i}}, \\mathrm{k}_{\\mathrm{i}}-1\\right),\\left(\\mathrm{r}_{\\mathrm{i}}, \\mathrm{k}_{\\mathrm{i}}+1\\right),\\left(\\mathrm{r}_{\\mathrm{i}}+1, \\mathrm{k}_{\\mathrm{i}}\\right),\\left(\\mathrm{r}_{\\mathrm{i}}+1, \\mathrm{k}_{\\mathrm{i}}+1\\right)$.\n- No position may be repeated within the sequence. That is, for every $\\mathrm{i} \\neq \\mathrm{j}$, either $\\mathrm{r}_{\\mathrm{i}} \\neq \\mathrm{r}_{\\mathrm{j}}$ or $\\mathrm{k}_{\\mathrm{i}} \\neq \\mathrm{k}_{\\mathrm{j}}$, or both.\n\nFind any Pascal walk of $\\mathrm{S} \\leqslant 500$ positions such that the sum of the numbers in all of the positions it visits is equal to $\\mathrm{N}$. It is guaranteed that at least one such walk exists for every $\\mathrm{N}$.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. Each consists of a single line containing a single integer $\\mathrm{N}$.\n", "outputFormat": "For each test case, first output a line containing case #x:, where $\\mathrm{x}$ is the test case number (starting from 1). Then, output your proposed Pascal walk of length $\\mathrm{S} \\leqslant 500$ using $\\mathrm{S}$ additional lines. The $\\mathrm{i}$-th of these lines must be $\\mathrm{r}_{\\mathrm{i}} \\mathrm{k}_{\\mathrm{i}}$ where $\\left(\\mathrm{r}_{\\mathrm{i}}, \\mathrm{k}_{\\mathrm{i}}\\right)$ is the $\\mathrm{i}$-th position in the walk. For example, the first line should be $1 \\quad 1$ since the first position for all valid walks is $(1,1)$. The sum of the numbers at the $\\mathrm{S}$ positions of your proposed Pascal walk must be exactly $\\mathrm{N}$.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, only the starting position is needed.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/06jwicgw.png)\n\nIn Sample Case #2, notice that although a shorter path exists, the path does not need to be of minimal length, as long as it uses no more than 500 positions.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/scfogipe.png)\n\nThe following image depicts our solution to Sample Case #3:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x6b2j5as.png)\n\n**Limits**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$.\n\n**Test set 1 (3 Pts, Visible Verdict)**\n\n- $1 \\leqslant \\mathrm{N} \\leqslant 501$.\n\n**Test set 2 (11 Pts, Visible Verdict)**\n\n- $1 \\leqslant \\mathrm{N} \\leqslant 1000$.\n\n**Test set 3 (21 Pts, Hidden Verdict)**\n\n- $1 \\leqslant \\mathrm{N} \\leqslant 10^{9}$.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #1A] Pascal Walk", "background": "", "description": "**帕斯卡三角形** 由无限多行整数构成，每行的整数数量逐行递增，排列成三角形。\n\n定义 $(r, k)$ 为第 $r$ 行从左数第 $k$ 个位置，其中 $r$ 和 $k$ 均从 1 开始计数。帕斯卡三角形的构造遵循以下规则：\n\n- 第 $r$ 行包含 $r$ 个位置 $(r, 1), (r, 2), \\ldots, (r, r)$。\n- 对于所有 $r$，位置 $(r, 1)$ 和 $(r, r)$ 的数字均为 $1$。\n- 对于所有满足 $2 \\leqslant k \\leqslant r-1$ 的 $k$，位置 $(r, k)$ 的数字等于位置 $(r-1, k-1)$ 和 $(r-1, k)$ 的数字之和。\n\n帕斯卡三角形的前 5 行如下所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6s8m35j7.png)\n\n在本问题中，**帕斯卡游走** 是指帕斯卡三角形中一个长度为 $\\mathrm{s}$ 的位置序列 $\\left(\\mathrm{r}_{1}, \\mathrm{k}_{1}\\right), \\left(\\mathrm{r}_{2}, \\mathrm{k}_{2}\\right), \\ldots, \\left(\\mathrm{r}_{\\mathrm{s}}, \\mathrm{k}_{\\mathrm{s}}\\right)$，满足以下条件：\n\n1. $\\mathrm{r}_{1}=1$ 且 $\\mathrm{k}_{1}=1$。\n2. 每个后续位置必须在三角形内，并且与前一个位置相邻（六个可能方向之一）。即对于所有 $\\mathrm{i} \\geqslant 1$，$\\left(\\mathrm{r}_{\\mathrm{i}+1}, \\mathrm{k}_{\\mathrm{i}+1}\\right)$ 必须是以下之一且位于三角形内：$\\left(\\mathrm{r}_{\\mathrm{i}}-1, \\mathrm{k}_{\\mathrm{i}}-1\\right)$、$\\left(\\mathrm{r}_{\\mathrm{i}}-1, \\mathrm{k}_{\\mathrm{i}}\\right)$、$\\left(\\mathrm{r}_{\\mathrm{i}}, \\mathrm{k}_{\\mathrm{i}}-1\\right)$、$\\left(\\mathrm{r}_{\\mathrm{i}}, \\mathrm{k}_{\\mathrm{i}}+1\\right)$、$\\left(\\mathrm{r}_{\\mathrm{i}}+1, \\mathrm{k}_{\\mathrm{i}}\\right)$、$\\left(\\mathrm{r}_{\\mathrm{i}}+1, \\mathrm{k}_{\\mathrm{i}}+1\\right)$。\n3. 序列中不能重复访问同一位置。即对于任意 $\\mathrm{i} \\neq \\mathrm{j}$，必须满足 $\\mathrm{r}_{\\mathrm{i}} \\neq \\mathrm{r}_{\\mathrm{j}}$ 或 $\\mathrm{k}_{\\mathrm{i}} \\neq \\mathrm{k}_{\\mathrm{j}}$，或两者均不相等。\n\n请构造一个长度 $\\mathrm{S} \\leqslant 500$ 的帕斯卡游走，使得所访问位置中所有数字之和恰好等于 $\\mathrm{N}$。题目保证对于所有 $\\mathrm{N}$，至少存在一个这样的游走。", "inputFormat": "输入的第一行包含测试用例数量 $\\mathrm{T}$。随后是 $\\mathrm{T}$ 个测试用例，每个用例占一行，包含一个整数 $\\mathrm{N}$。\n", "outputFormat": "对于每个测试用例，首先输出一行 `Case #x:`，其中 $\\mathrm{x}$ 为测试用例编号（从 1 开始）。接着输出你构造的帕斯卡游走，共 $\\mathrm{S} \\leqslant 500$ 行，每行格式为 $\\mathrm{r}_{\\mathrm{i}} \\ \\mathrm{k}_{\\mathrm{i}}$，表示游走的第 $\\mathrm{i}$ 个位置 $\\left(\\mathrm{r}_{\\mathrm{i}}, \\mathrm{k}_{\\mathrm{i}}\\right)$。例如，第一行必须为 `1 1`，因为所有有效游走的起点均为 $(1,1)$。游走中所有位置的数字之和必须严格等于 $\\mathrm{N}$。\n", "hint": "\n## 说明/提示\n\n**样例解释**\n\n- 样例 #1 仅需起点位置即可满足要求。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/06jwicgw.png)\n\n- 样例 #2 中，虽然存在更短的路径，但路径长度只需不超过 500 即可，无需最短。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/scfogipe.png)\n\n- 下图展示了样例 #3 的解决方案：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x6b2j5as.png)\n\n**数据范围**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$。\n\n**测试集 1（3 分，可见评测结果）**\n\n- $1 \\leqslant \\mathrm{N} \\leqslant 501$。\n\n**测试集 2（11 分，可见评测结果）**\n\n- $1 \\leqslant \\mathrm{N} \\leqslant 1000$。\n\n**测试集 3（21 分，隐藏评测结果）**\n\n- $1 \\leqslant \\mathrm{N} \\leqslant 10^{9}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
