{"pid": "P15107", "type": "P", "difficulty": 6, "samples": [["5 5 114514\n", "1562674565"], ["114 514 1919", "903488587"], ["5000 5000 998244353", "1845377756"], ["2000000 2000000 1004535809", "1498751009"], ["4000000 4000000 1000000007", "981318194"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["O2优化", "模板题"], "title": "【模板】Wavelet Matrix", "background": "**请注意本题并不寻常的数据范围与时空限制。**", "description": "给定一个长度为 $n$ 的序列 $a_{1\\sim n}$。$m$ 次查询，给定 $op,l,r,k$：\n\n- 若 $op=0$，查询区间 $[l,r]$ 内有多少个数小于 $k$。\n- 若 $op=1$，查询区间 $[l,r]$ 内第 $k$ 小的数。\n\n强制在线。", "inputFormat": "由于 IO 量过大，数据使用随机生成。你可以使用以下方式获取 $a_{1\\sim n}$ 以及每次询问的 $op,l,r,k$：\n\n```cpp\ntypedef unsigned uint;\nconst int MAXN = 4e6 + 10;\nconst uint mask = 0x5f3759dfu;\n\nuint seed, lst;\n\ninline uint rnd() {\n\tseed ^= lst ^ mask;\n\tseed ^= seed << 13;\n\tseed ^= seed >> 7;\n\tseed ^= seed << 17;\n\tseed ^= lst ^ mask;\n\treturn seed;\n}\n\nint n, m; uint a[MAXN];\n\nint main() {\n    scanf(\"%d%d%u\", &n, &m, &seed);\n    for (int i = 1; i <= n; i++) a[i] = rnd();\n    for (int i = 1; i <= m; i++) {\n    \tuint op = rnd() & 1, l = rnd() % n + 1, r = rnd() % n + 1;\n    \tif (l > r) swap(l, r);\n    \tif (op) {\n    \t\tuint k = rnd() % (r - l + 1) + 1;\n    \t\t// do sth...\n\t\t} else {\n\t\t\tuint k = rnd();\n\t\t\t// do sth...\n\t\t}\n\t}\n}\n```\n\n其中 $lst$ 表示上一次询问的答案，初始为 $0$。", "outputFormat": "一行一个非负整数，表示所有查询的答案的异或和。", "hint": "#### 【样例 1 解释】\n\n解密后的输入如下：\n\n```cpp\n5 5\n3453473247 1341133007 2686835293 4244725722 2878739094\n0 3 5 4197138810\n1 2 5 2\n1 2 3 2\n1 1 5 2\n1 3 5 3\n```\n\n其中第一行为 $n,m$，第二行为 $a_{1\\sim n}$，接下来 $m$ 行为询问。\n\n#### 【数据范围】\n\n**本题开启捆绑测试。**\n\n|$\\text{Subtask}$|$n,m\\le$|分值|\n|:-:|:-:|:-:|\n|$1$|$500$|$10$|\n|$2$|$5000$|$20$|\n|$3$|$2\\times 10^5$|$30$|\n|$4$|$4\\times 10^6$|$40$|\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le 4\\times 10^6$，$0\\le seed<2^{32}$。同一个 Subtask 内数据有梯度。\n\n**请注意常数因子对程序时空效率的影响。尤其注意 $\\log$ 与 $\\log$ 之间亦有分别。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "【模板】Wavelet Matrix", "background": "**请注意本题并不寻常的数据范围与时空限制。**", "description": "给定一个长度为 $n$ 的序列 $a_{1\\sim n}$。$m$ 次查询，给定 $op,l,r,k$：\n\n- 若 $op=0$，查询区间 $[l,r]$ 内有多少个数小于 $k$。\n- 若 $op=1$，查询区间 $[l,r]$ 内第 $k$ 小的数。\n\n强制在线。", "inputFormat": "由于 IO 量过大，数据使用随机生成。你可以使用以下方式获取 $a_{1\\sim n}$ 以及每次询问的 $op,l,r,k$：\n\n```cpp\ntypedef unsigned uint;\nconst int MAXN = 4e6 + 10;\nconst uint mask = 0x5f3759dfu;\n\nuint seed, lst;\n\ninline uint rnd() {\n\tseed ^= lst ^ mask;\n\tseed ^= seed << 13;\n\tseed ^= seed >> 7;\n\tseed ^= seed << 17;\n\tseed ^= lst ^ mask;\n\treturn seed;\n}\n\nint n, m; uint a[MAXN];\n\nint main() {\n    scanf(\"%d%d%u\", &n, &m, &seed);\n    for (int i = 1; i <= n; i++) a[i] = rnd();\n    for (int i = 1; i <= m; i++) {\n    \tuint op = rnd() & 1, l = rnd() % n + 1, r = rnd() % n + 1;\n    \tif (l > r) swap(l, r);\n    \tif (op) {\n    \t\tuint k = rnd() % (r - l + 1) + 1;\n    \t\t// do sth...\n\t\t} else {\n\t\t\tuint k = rnd();\n\t\t\t// do sth...\n\t\t}\n\t}\n}\n```\n\n其中 $lst$ 表示上一次询问的答案，初始为 $0$。", "outputFormat": "一行一个非负整数，表示所有查询的答案的异或和。", "hint": "#### 【样例 1 解释】\n\n解密后的输入如下：\n\n```cpp\n5 5\n3453473247 1341133007 2686835293 4244725722 2878739094\n0 3 5 4197138810\n1 2 5 2\n1 2 3 2\n1 1 5 2\n1 3 5 3\n```\n\n其中第一行为 $n,m$，第二行为 $a_{1\\sim n}$，接下来 $m$ 行为询问。\n\n#### 【数据范围】\n\n**本题开启捆绑测试。**\n\n|$\\text{Subtask}$|$n,m\\le$|分值|\n|:-:|:-:|:-:|\n|$1$|$500$|$10$|\n|$2$|$5000$|$20$|\n|$3$|$2\\times 10^5$|$30$|\n|$4$|$4\\times 10^6$|$40$|\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le 4\\times 10^6$，$0\\le seed<2^{32}$。同一个 Subtask 内数据有梯度。\n\n**请注意常数因子对程序时空效率的影响。尤其注意 $\\log$ 与 $\\log$ 之间亦有分别。**", "locale": "zh-CN"}}}
{"pid": "P15108", "type": "P", "difficulty": 0, "samples": [["6\n6 5 1 1 5", "1 5 3 6 2 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168, 263168]}, "tags": ["交互题", "Special Judge", "O2优化"], "title": "白井黑子", "background": "这是一道交互题。\n\n请勿使用 C++14 (GCC 9) 提交。\n\n此题是黑子测试你是否具有空间系超能力而制作的。", "description": "给定一棵以 $1$ 为根有根树，标号 $1$ 到 $n$，求这棵树的 DFS 序。\n\n具体地，有如下伪代码：\n\n```cpp\nint d[n], tot = 0\nset son[n]\nvoid dfs(int u):\n    d[tot] = u\n    tot += 1\n    for v in son[u]: // in any order\n        dfs(v)\ndfs(1)\n```\n\n$d$ 数组即为所求。\n\n显然，一棵树可以有多个 DFS 序，你只要求出任意一个即可。\n\n### 交互方式\n\n我们定义了类型 `Array` 表示长度 $n$，值域 $[0,n]$ 的数组。你可以调用它的两个方法：\n\n1. `int operator[](int x)`，表示获取该数组第 $x$ 位的值。必须满足 $x\\in[0,n]$。\n2. `void set(int x,int y)`，表示将数组第 $x$ 位设置为 $y$。必须满足 $x\\in [0,n]$ 以及 $y\\in[0,n]$。调用 `a.set(x,y)` 后，$a[x]$ 将返回 $y$。\n\n所有方法的复杂度均为 $O(1)$。\n\n你需要编写一个函数 `void dfs(int n, Array &f,Array &a)`。其中 $f[i]$ 的初始值为点 $i$ 的父亲，这里规定根的父亲为 $0$，且 $f[0]=0$；$a[i]$ 初始值全部为 $0$。\n\n该函数会被调用恰好一次。你需要在函数返回时，在 $a$ 中写入你求出的 DFS 序。具体地，对于每一个 $i\\in [1,n]$，最后一次调用 `a.set(i,x)` 的 $x$ 需为 DFS 序的第 $x$ 项，$a[0]$ 的值没有要求。\n\n\n另外，你还可以调用函数 `int fa(int x)`，它返回 $f[x]$ 的初始值（$x$ 的父亲），要求 $x\\in[0,n]$。注意，如果调用了该函数，仅能获得当前测试点 $50\\%$ 的分数。\n\n**本题实际的空间限制为 1MB，多余空间将由交互器消耗。需要注意的是，递归函数消耗的栈空间也计入空间限制。**\n\n请注意，任何绕过提供的方法而直接使用传入的类型空间的行为被视为攻击交互器，将会被判为 $0$ 分。\n\n下发文件中提供了 `dfs.cpp`，你可以在此程序的基础上编写代码。该代码已内置交互器，可以直接测试样例以及提交。你只需要完善其中的 `dfs` 函数。\n\n", "inputFormat": "以下是提供给示例交互器的输入格式：\n\n第一行，一个正整数 $n$。\n\n接下来一行 $n-1$ 个整数，表示 $2\\sim n$ 号结点的父亲。", "outputFormat": "以下是提供给示例交互器的输出格式：\n\n一行 $n$ 个整数，表示选手代码返回的 DFS 序。", "hint": "**本题采用捆绑测试。**\n\n- Subtask 1（20 pts）：$n\\le 10^5$，时限 1s。\n- Subtask 2（30 pts）：$n\\le 10^6$，时限 6s。\n- Subtask 3（30 pts）：$n\\le 5\\times 10^6$，时限 6s。\n- Subtask 4（10 pts）：对于 $i\\ge 1$，初始有 $f[i]<i$，时限 8s。\n- Subtask 5（10 pts）：无特殊限制，时限 8s。\n\n对于全部的测试点，$1\\leq n\\leq 10^7$。\n\n你可以提交示例程序来测试交互器的运行时间。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "白井黑子", "background": "这是一道交互题。\n\n请勿使用 C++14 (GCC 9) 提交。\n\n此题是黑子测试你是否具有空间系超能力而制作的。", "description": "给定一棵以 $1$ 为根有根树，标号 $1$ 到 $n$，求这棵树的 DFS 序。\n\n具体地，有如下伪代码：\n\n```cpp\nint d[n], tot = 0\nset son[n]\nvoid dfs(int u):\n    d[tot] = u\n    tot += 1\n    for v in son[u]: // in any order\n        dfs(v)\ndfs(1)\n```\n\n$d$ 数组即为所求。\n\n显然，一棵树可以有多个 DFS 序，你只要求出任意一个即可。\n\n### 交互方式\n\n我们定义了类型 `Array` 表示长度 $n$，值域 $[0,n]$ 的数组。你可以调用它的两个方法：\n\n1. `int operator[](int x)`，表示获取该数组第 $x$ 位的值。必须满足 $x\\in[0,n]$。\n2. `void set(int x,int y)`，表示将数组第 $x$ 位设置为 $y$。必须满足 $x\\in [0,n]$ 以及 $y\\in[0,n]$。调用 `a.set(x,y)` 后，$a[x]$ 将返回 $y$。\n\n所有方法的复杂度均为 $O(1)$。\n\n你需要编写一个函数 `void dfs(int n, Array &f,Array &a)`。其中 $f[i]$ 的初始值为点 $i$ 的父亲，这里规定根的父亲为 $0$，且 $f[0]=0$；$a[i]$ 初始值全部为 $0$。\n\n该函数会被调用恰好一次。你需要在函数返回时，在 $a$ 中写入你求出的 DFS 序。具体地，对于每一个 $i\\in [1,n]$，最后一次调用 `a.set(i,x)` 的 $x$ 需为 DFS 序的第 $x$ 项，$a[0]$ 的值没有要求。\n\n\n另外，你还可以调用函数 `int fa(int x)`，它返回 $f[x]$ 的初始值（$x$ 的父亲），要求 $x\\in[0,n]$。注意，如果调用了该函数，仅能获得当前测试点 $50\\%$ 的分数。\n\n**本题实际的空间限制为 1MB，多余空间将由交互器消耗。需要注意的是，递归函数消耗的栈空间也计入空间限制。**\n\n请注意，任何绕过提供的方法而直接使用传入的类型空间的行为被视为攻击交互器，将会被判为 $0$ 分。\n\n下发文件中提供了 `dfs.cpp`，你可以在此程序的基础上编写代码。该代码已内置交互器，可以直接测试样例以及提交。你只需要完善其中的 `dfs` 函数。\n\n", "inputFormat": "以下是提供给示例交互器的输入格式：\n\n第一行，一个正整数 $n$。\n\n接下来一行 $n-1$ 个整数，表示 $2\\sim n$ 号结点的父亲。", "outputFormat": "以下是提供给示例交互器的输出格式：\n\n一行 $n$ 个整数，表示选手代码返回的 DFS 序。", "hint": "**本题采用捆绑测试。**\n\n- Subtask 1（20 pts）：$n\\le 10^5$，时限 1s。\n- Subtask 2（30 pts）：$n\\le 10^6$，时限 6s。\n- Subtask 3（30 pts）：$n\\le 5\\times 10^6$，时限 6s。\n- Subtask 4（10 pts）：对于 $i\\ge 1$，初始有 $f[i]<i$，时限 8s。\n- Subtask 5（10 pts）：无特殊限制，时限 8s。\n\n对于全部的测试点，$1\\leq n\\leq 10^7$。\n\n你可以提交示例程序来测试交互器的运行时间。\n", "locale": "zh-CN"}}}
{"pid": "P15109", "type": "P", "difficulty": 5, "samples": [["4 1\n4 3 2 1", "2\n2 1 3\n2 1 3"], ["5 1\n5 2 3 4 1", "2\n3 2 3 4\n1 1"], ["5 0\n5 2 3 4 1", "2\n-1"], ["8 0\n1 8 5 4 3 2 6 7", "3\n-1"], ["8 0\n1 3 5 7 2 4 6 8", "2\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["Special Judge", "O2优化", "构造"], "title": "Adverse Present", "background": "", "description": "给你一个长度为 $n$ 的排列，和一个整数 $tp\\in\\{0,1\\}$。\n\n定义一次操作如下：\n    \n选择一个子序列从原序列删除，并按原来顺序添加到排列最后。\n\n请输出将这个排列**从小到大排序**所需要的最小操作次数 $k$ 并构造，特别地，如果 $k\\cdot n\\geq 3\\times 10^6$ 或者 $tp=0$，你不需要构造（请参考输入输出格式）。\n\n排列的定义：一个长度为 $n$ 的排列是一个由 $1\\sim n$ 的正整数组成的序列，满足其中每个数都出现了恰好一次。\n\n子序列的定义：我们称序列 $b$ 是序列 $a$ 的子序列，当且仅当可以通过删除 $a$ 中的若干个元素得到 $b$。\n", "inputFormat": "第一行两个整数 $n,tp$，代表排列长度，以及你是否需要构造方案。\n\n第二行 $n$ 个数，第 $i$ 个数为排列中第 $i$ 个元素 $a_i$，保证这些数互不相同。", "outputFormat": "第一行一个数 $k$，代表所需最小次数。\n\n若 $k\\cdot n\\geq 3\\times 10^6$ 或者 $tp=0$，在第二行输出 `-1` 并退出。\n\n否则接下来 $k$ 行，每行第一个数 $c$ 代表此次操作所选择的子序列长度。然后输出 $c$ 个互不相同的数，代表此次操作选择的子序列由当前序列哪些下标的元素组成，这些数顺序随意。", "hint": "**本题采用捆绑测试。**\n\n\n$\\texttt{Subtask 1(1pts)}:$ $a_i=i$。\n\n$\\texttt{Subtask 2(19pts):}$ $a_i=n-i+1$。\n\n$\\texttt{Subtask 3(15pts):}$ $n\\le 5$。\n\n$\\texttt{Subtask 4(20pts):}$ $n\\le 2\\times 10^3$。\n\n$\\texttt{Subtask 5(15pts):}$ $tp=0$。\n\n$\\texttt{Subtask 6(30pts):}$ 无特殊限制。\n\n对于所有数据，$1\\leq n \\leq 10^5$，保证 $a$ 是一个排列。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Adverse Present", "background": "", "description": "给你一个长度为 $n$ 的排列，和一个整数 $tp\\in\\{0,1\\}$。\n\n定义一次操作如下：\n    \n选择一个子序列从原序列删除，并按原来顺序添加到排列最后。\n\n请输出将这个排列**从小到大排序**所需要的最小操作次数 $k$ 并构造，特别地，如果 $k\\cdot n\\geq 3\\times 10^6$ 或者 $tp=0$，你不需要构造（请参考输入输出格式）。\n\n排列的定义：一个长度为 $n$ 的排列是一个由 $1\\sim n$ 的正整数组成的序列，满足其中每个数都出现了恰好一次。\n\n子序列的定义：我们称序列 $b$ 是序列 $a$ 的子序列，当且仅当可以通过删除 $a$ 中的若干个元素得到 $b$。\n", "inputFormat": "第一行两个整数 $n,tp$，代表排列长度，以及你是否需要构造方案。\n\n第二行 $n$ 个数，第 $i$ 个数为排列中第 $i$ 个元素 $a_i$，保证这些数互不相同。", "outputFormat": "第一行一个数 $k$，代表所需最小次数。\n\n若 $k\\cdot n\\geq 3\\times 10^6$ 或者 $tp=0$，在第二行输出 `-1` 并退出。\n\n否则接下来 $k$ 行，每行第一个数 $c$ 代表此次操作所选择的子序列长度。然后输出 $c$ 个互不相同的数，代表此次操作选择的子序列由当前序列哪些下标的元素组成，这些数顺序随意。", "hint": "**本题采用捆绑测试。**\n\n\n$\\texttt{Subtask 1(1pts)}:$ $a_i=i$。\n\n$\\texttt{Subtask 2(19pts):}$ $a_i=n-i+1$。\n\n$\\texttt{Subtask 3(15pts):}$ $n\\le 5$。\n\n$\\texttt{Subtask 4(20pts):}$ $n\\le 2\\times 10^3$。\n\n$\\texttt{Subtask 5(15pts):}$ $tp=0$。\n\n$\\texttt{Subtask 6(30pts):}$ 无特殊限制。\n\n对于所有数据，$1\\leq n \\leq 10^5$，保证 $a$ 是一个排列。", "locale": "zh-CN"}}}
{"pid": "P15110", "type": "P", "difficulty": 6, "samples": [["5 7\n1 2 4\n1 3 5\n5 4 4\n2 5 7\n5 1 1\n4 2 2\n1 5 7", "YES\n2 3 4 5 6"], ["4 6\n1 2 1\n3 2 2\n4 2 3\n1 3 5\n1 4 6\n4 1 4", "NO"], ["3 4\n1 2 1\n3 2 4\n3 1 2\n2 3 2", "NO"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["Special Judge", "O2优化"], "title": "Silent End", "background": "机房里有一些神在讨论代码部队。grg 发现自己太菜参与不进去，所以只能听他们高谈阔论。", "description": "grg 听到了其中 $m$ 条评价。第 $i$ 条形式为 $(u_i,v_i,w_i)$，分别为评价者，被评价者以及预估的 rating。然而这些评价不一定准确。具体地，如果评价者的真实 rating 大于等于被评价者，他会低估被评价者导致 $w$ 比实际 rating 小 $1$，若小于被评价者，他会高估被评价者导致 $w$ 比实际 rating 大 $1$。\n\n因为这群人关系很好，所以**每个人都至少被评价了一次**。\n\n现在 grg 想要你构造一组这些人的 rating，需要满足所有评价。如果不存在，请报告。", "inputFormat": "第一行两个正整数 $n,m$。\n\n接下来 $m$ 行，每行三个非负整数 $u_i,v_i,w_i$，含义如上。", "outputFormat": "若无解，请输出 `NO`。\n\n否则输出 `YES`，再输出一行 $n$ 个整数，代表你构造的这些人的 rating，你需要保证构造的这些这些 rating 处于带符号 32 位整数的范围内，否则随机报错。", "hint": "**本题采用捆绑测试。**\n\n$\\texttt{Subtask 1(30pts)}:$ $n \\leq 20$，$m \\leq 100$。\n\n$\\texttt{Subtask 2(70pts)}:$ 无额外限制。\n\n\n\n对于所有的数据，满足 $1\\le n \\leq 5 \\cdot 10^5$，$n\\le m \\leq 10^6$，$0 \\leq w_i \\leq 10^9$。\n\n**保证每个人都至少被评价了一次。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Silent End", "background": "机房里有一些神在讨论代码部队。grg 发现自己太菜参与不进去，所以只能听他们高谈阔论。", "description": "grg 听到了其中 $m$ 条评价。第 $i$ 条形式为 $(u_i,v_i,w_i)$，分别为评价者，被评价者以及预估的 rating。然而这些评价不一定准确。具体地，如果评价者的真实 rating 大于等于被评价者，他会低估被评价者导致 $w$ 比实际 rating 小 $1$，若小于被评价者，他会高估被评价者导致 $w$ 比实际 rating 大 $1$。\n\n因为这群人关系很好，所以**每个人都至少被评价了一次**。\n\n现在 grg 想要你构造一组这些人的 rating，需要满足所有评价。如果不存在，请报告。", "inputFormat": "第一行两个正整数 $n,m$。\n\n接下来 $m$ 行，每行三个非负整数 $u_i,v_i,w_i$，含义如上。", "outputFormat": "若无解，请输出 `NO`。\n\n否则输出 `YES`，再输出一行 $n$ 个整数，代表你构造的这些人的 rating，你需要保证构造的这些这些 rating 处于带符号 32 位整数的范围内，否则随机报错。", "hint": "**本题采用捆绑测试。**\n\n$\\texttt{Subtask 1(30pts)}:$ $n \\leq 20$，$m \\leq 100$。\n\n$\\texttt{Subtask 2(70pts)}:$ 无额外限制。\n\n\n\n对于所有的数据，满足 $1\\le n \\leq 5 \\cdot 10^5$，$n\\le m \\leq 10^6$，$0 \\leq w_i \\leq 10^9$。\n\n**保证每个人都至少被评价了一次。**", "locale": "zh-CN"}}}
{"pid": "P15111", "type": "P", "difficulty": 6, "samples": [["3 3\n1 0 0", "2.00000\n1.33333\n2.66667\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["Special Judge", "O2优化", "期望"], "title": "群星", "background": "你和一群朋友一起颓废。", "description": "你打开了群星,开了一局游戏，打开看海模式。游戏自动生成了 $n$ 个文明，其中第 $i$ 个文明初始国力排名为 $i$ 。你们决定按照如下方式进行看海。\n\n游戏分为 $k$ 个世纪，其中第 $i$ 个世纪会发生 $a_i$ 场战争，每一场战争会在 $n \\choose 2$ 对不同文明对中随机选一对，交换它们的排名。每个世纪刚开始时，大家会进行一次选文明操作，具体来说因为你是主人，你可以先选择是否在这回合选文明，如果是，则你选择任意一个尚未被选择的文明；否则恰有一个朋友会选择目前还没被选择的文明里排名第一的文明。文明选择完后不能更改（即你只可以在一个世纪初选择文明）。\n\n讨论完规则之后，你对于选文明的最优策略很感兴趣。因此你打算编写程序对于所有 $i$ 计算你如果在第 $i$ 个世纪初选择文明，选择的文明最终期望的排名最小可以是多少。因为你不喜欢取模，你的答案只需要保留五位小数输出（多输出也没事）。", "inputFormat": "第一行两个数字 $n,k$。\n\n第二行 $k$ 个数，第 $i$ 个数代表 $a_i$ 。", "outputFormat": "$k$ 行，每行输出内容如题意所述。", "hint": "**本题采用捆绑测试和 Special Judge，你的答案和标准答案差距不大于 $10^{-5} $ 即可。**\n\n对于 $20\\%$ 的数据，满足 $n ,k , a_i \\leq 3$\n\n对于 $60\\%$ 的数据，满足 $n,k \\leq 50$，$\\sum a_i \\leq 10000$\n\n对于 $100\\%$ 的数据，满足 $n \\leq 50 , k \\leq 50 , 0 \\leq a_i \\leq 10^7$,$k \\leq n$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "群星", "background": "你和一群朋友一起颓废。", "description": "你打开了群星,开了一局游戏，打开看海模式。游戏自动生成了 $n$ 个文明，其中第 $i$ 个文明初始国力排名为 $i$ 。你们决定按照如下方式进行看海。\n\n游戏分为 $k$ 个世纪，其中第 $i$ 个世纪会发生 $a_i$ 场战争，每一场战争会在 $n \\choose 2$ 对不同文明对中随机选一对，交换它们的排名。每个世纪刚开始时，大家会进行一次选文明操作，具体来说因为你是主人，你可以先选择是否在这回合选文明，如果是，则你选择任意一个尚未被选择的文明；否则恰有一个朋友会选择目前还没被选择的文明里排名第一的文明。文明选择完后不能更改（即你只可以在一个世纪初选择文明）。\n\n讨论完规则之后，你对于选文明的最优策略很感兴趣。因此你打算编写程序对于所有 $i$ 计算你如果在第 $i$ 个世纪初选择文明，选择的文明最终期望的排名最小可以是多少。因为你不喜欢取模，你的答案只需要保留五位小数输出（多输出也没事）。", "inputFormat": "第一行两个数字 $n,k$。\n\n第二行 $k$ 个数，第 $i$ 个数代表 $a_i$ 。", "outputFormat": "$k$ 行，每行输出内容如题意所述。", "hint": "**本题采用捆绑测试和 Special Judge，你的答案和标准答案差距不大于 $10^{-5} $ 即可。**\n\n对于 $20\\%$ 的数据，满足 $n ,k , a_i \\leq 3$\n\n对于 $60\\%$ 的数据，满足 $n,k \\leq 50$，$\\sum a_i \\leq 10000$\n\n对于 $100\\%$ 的数据，满足 $n \\leq 50 , k \\leq 50 , 0 \\leq a_i \\leq 10^7$,$k \\leq n$", "locale": "zh-CN"}}}
{"pid": "P15112", "type": "P", "difficulty": 0, "samples": [["5 1\n1 3 1 1 1\n1 \n3 \n7 \n2 \n1 \n", "1"], ["6 2\n2 2 7 3 8 4\n4 4\n5 6\n1 7\n3 9\n3 8\n6 8", "62390273"], ["6 2\n2 2 6 3 1 10\n5 8\n7 9\n9 7\n9 3\n10 6\n10 4", "1"], ["5 5\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1", "1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化"], "title": "For The Emperor！", "background": "来自帝皇的温馨提示：出题人比较坏，请小心谨慎。", "description": "  伊斯塔万五号上，忠诚派与叛乱派正展开血战。\n  \n  战场可以被表示为一个 $5 \\cdot n$ 的矩形。叛乱派于第二行，忠诚派于第四行分别驻扎了 $n$ 支军团。\n  \n  忠诚派在第 $i$ 列的军团战斗力固定为 $a_i$。但由于混沌巫术的影响，叛乱派的战斗力难以预测。具体而言，叛乱派在第 $i$ 列军团的战斗力存在 $k$ 种可能，分别为 $b_{i,1},b_{i,2},...,b_{i,k}$。战斗打响后，每一列的叛乱派军团都将在对应 $k$ 种可能性中独立均匀随机选择一个作为其实际战斗力。\n  \n  开战后，双方将轮流进行操作，忠诚派先行。每次操作可以令一个己方军团走到无军团占据且在自身**左前方/正前方/右前方**（忠诚派的\"前\"即向上，叛乱派相反）的格子或被敌方军团占据且在自身**左前方/右前方**的格子。当然，走到的任何格子都需要位于战场内。\n  \n  若选择后者，执行一次\"战斗\"，若己方军团战斗力**大于等于**移动到的格子的敌方军团战斗力，将己方军团战斗力减去敌方军团战斗力并移除敌方军团，反之亦然。\n  \n  若轮到某方行动时，其不存在合法操作，则其对手获胜。若一次操作后，存在某只军团位于敌方底线（第一行/第五行），则该军团的所属者获胜。\n  \n  已知双方指挥官都绝顶聪明且想要获胜。作为正在使用灵能监督战局的帝国宰相马卡多，你需要向帝皇报告忠诚派的获胜概率，对 $\\texttt{998244353}$ 取模。", "inputFormat": "  第一行两个整数 $n,k$。\n  \n  第二行 $n$ 个整数，代表 $a_1,a_2,...,a_n$。\n  \n  接下来 $n$ 行每行 $k$ 个数代表 $b$。\n  \n  **本题输入量较大，请注意你的 IO 效率**。\n", "outputFormat": "  一行一个整数，代表答案。", "hint": "  **本题采用捆绑测试**。  \n  \n  对于 $100\\%$ 的数据，满足 $1 \\leq n\\leq 2 \\cdot 10^3,1 \\leq k \\leq n,1 \\leq a_i,b_{i,j} < 998244353$。\n  \n  |编号 |分数 |特殊性质 |\n| -----------: | -----------: | -----------: |\n| 1 | 5 | $n \\leq 3$ |\n| 2 | 10 | $n \\leq 5$ |\n| 3 | 35 | $k \\leq 1$ |\n| 4 | 20 | $n \\leq 100$ |\n| 5 | 10 | $n \\leq 500$ |\n| 6 | 20 | 无 |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "For The Emperor！", "background": "来自帝皇的温馨提示：出题人比较坏，请小心谨慎。", "description": "  伊斯塔万五号上，忠诚派与叛乱派正展开血战。\n  \n  战场可以被表示为一个 $5 \\cdot n$ 的矩形。叛乱派于第二行，忠诚派于第四行分别驻扎了 $n$ 支军团。\n  \n  忠诚派在第 $i$ 列的军团战斗力固定为 $a_i$。但由于混沌巫术的影响，叛乱派的战斗力难以预测。具体而言，叛乱派在第 $i$ 列军团的战斗力存在 $k$ 种可能，分别为 $b_{i,1},b_{i,2},...,b_{i,k}$。战斗打响后，每一列的叛乱派军团都将在对应 $k$ 种可能性中独立均匀随机选择一个作为其实际战斗力。\n  \n  开战后，双方将轮流进行操作，忠诚派先行。每次操作可以令一个己方军团走到无军团占据且在自身**左前方/正前方/右前方**（忠诚派的\"前\"即向上，叛乱派相反）的格子或被敌方军团占据且在自身**左前方/右前方**的格子。当然，走到的任何格子都需要位于战场内。\n  \n  若选择后者，执行一次\"战斗\"，若己方军团战斗力**大于等于**移动到的格子的敌方军团战斗力，将己方军团战斗力减去敌方军团战斗力并移除敌方军团，反之亦然。\n  \n  若轮到某方行动时，其不存在合法操作，则其对手获胜。若一次操作后，存在某只军团位于敌方底线（第一行/第五行），则该军团的所属者获胜。\n  \n  已知双方指挥官都绝顶聪明且想要获胜。作为正在使用灵能监督战局的帝国宰相马卡多，你需要向帝皇报告忠诚派的获胜概率，对 $\\texttt{998244353}$ 取模。", "inputFormat": "  第一行两个整数 $n,k$。\n  \n  第二行 $n$ 个整数，代表 $a_1,a_2,...,a_n$。\n  \n  接下来 $n$ 行每行 $k$ 个数代表 $b$。\n  \n  **本题输入量较大，请注意你的 IO 效率**。\n", "outputFormat": "  一行一个整数，代表答案。", "hint": "  **本题采用捆绑测试**。  \n  \n  对于 $100\\%$ 的数据，满足 $1 \\leq n\\leq 2 \\cdot 10^3,1 \\leq k \\leq n,1 \\leq a_i,b_{i,j} < 998244353$。\n  \n  |编号 |分数 |特殊性质 |\n| -----------: | -----------: | -----------: |\n| 1 | 5 | $n \\leq 3$ |\n| 2 | 10 | $n \\leq 5$ |\n| 3 | 35 | $k \\leq 1$ |\n| 4 | 20 | $n \\leq 100$ |\n| 5 | 10 | $n \\leq 500$ |\n| 6 | 20 | 无 |\n", "locale": "zh-CN"}}}
{"pid": "P15113", "type": "P", "difficulty": 7, "samples": [["8 4 8 1", "1 127 966 1701 1050 266 28 1\n1 10 65 350 1701 7770 34105 145750"], ["8 4 8 0", "1 7 21 35 35 21 7 1\n1 4 10 20 35 56 84 120"], ["8 4 8 2", "1 1093 34041 122861 77527 9807 247 1\n1 26 480 7870 122861 1876956 28393720 427584740"], ["20 10 20 5", "1 287921741 197538754 417997771 330974293 599777130 328477156 548671166 770352032 110248695 539485921 565871517 217002594 291371341 141328110 747637192 848546735 926168809 945690124 1\n1 3051755 660508903 761237775 200310096 713887381 483477004 628232938 254386116 853526578 110248695 979696047 765825484 385364031 517701641 799832905 699031448 23144968 304263185 631524901"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["倍增", "Stirling 数", "生成函数", "快速数论变换 NTT", "2077"], "title": "[Aboi 2077] Hero", "background": "[![](https://cdn.luogu.com.cn/upload/image_hosting/49l4s31h.png)](https://www.bilibili.com/video/BV1osSEYGEMd)", "description": "将 $[1,n]$ 中的整数划分为 $m$ 个集合 $S_1,S_2,\\cdots,S_m$，集合间按照其中的最小值 $\\min\\{S_i\\}$ 从小到大排序，记数 $i$ 在第 $p_i$ 个集合中。\n\n唐吉诃德定义整数数对 $(i,j)$ 是**逆序对**，如果：\n\n- $i\\in[1,n],j\\in[1,m]$；\n- $p_i<j\\land i>\\min\\{S_j\\}$。\n\n称一个划分方案 $P=\\{S_1,S_2,\\cdots,S_m\\}$ 的**价值**为 $q^{\\text{inv}(P)}$，其中 $\\text{inv}(P)$ 为该划分方案中的逆序对个数。\n\n唐吉诃德给了你两个任务：\n\n1. $n$ 固定时，对于 $[1,n]$ 中的每个整数 $m$，求所有划分方案的价值之和；\n2. $m$ 固定时，对于 $[m,m+k-1]$ 中的每个整数 $n$，求所有划分方案的价值之和。\n\n两问答案均对 $998244353$ 取模。", "inputFormat": "一行四个正整数 $n,m,k,q$。", "outputFormat": "第一行输出 $n$ 个整数，第 $i$ 个整数表示 $n$ 固定、$m=i$ 时的答案；  \n第二行输出 $k$ 个整数，第 $i$ 个整数表示 $m$ 固定、$n=m+i-1$ 时的答案。\n\n两问答案均对 $998244353$ 取模。", "hint": "对于所有数据，$1\\le n,m,k\\le10^6$，$0\\le q<998244353$，保证若 $q\\neq1$ 则 $\\forall i\\in[1,\\max(n,m+k-1)],q^i\\not\\equiv1\\pmod{998244353}$。\n\n- 对于 $20\\%$ 的数据，$n,m,k\\le5\\times10^3$；\n- 对于另外 $20\\%$ 的数据，$q=0$；\n- 对于另外 $20\\%$ 的数据，$q=1$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Aboi 2077] Hero", "background": "[![](https://cdn.luogu.com.cn/upload/image_hosting/49l4s31h.png)](https://www.bilibili.com/video/BV1osSEYGEMd)", "description": "将 $[1,n]$ 中的整数划分为 $m$ 个集合 $S_1,S_2,\\cdots,S_m$，集合间按照其中的最小值 $\\min\\{S_i\\}$ 从小到大排序，记数 $i$ 在第 $p_i$ 个集合中。\n\n唐吉诃德定义整数数对 $(i,j)$ 是**逆序对**，如果：\n\n- $i\\in[1,n],j\\in[1,m]$；\n- $p_i<j\\land i>\\min\\{S_j\\}$。\n\n称一个划分方案 $P=\\{S_1,S_2,\\cdots,S_m\\}$ 的**价值**为 $q^{\\text{inv}(P)}$，其中 $\\text{inv}(P)$ 为该划分方案中的逆序对个数。\n\n唐吉诃德给了你两个任务：\n\n1. $n$ 固定时，对于 $[1,n]$ 中的每个整数 $m$，求所有划分方案的价值之和；\n2. $m$ 固定时，对于 $[m,m+k-1]$ 中的每个整数 $n$，求所有划分方案的价值之和。\n\n两问答案均对 $998244353$ 取模。", "inputFormat": "一行四个正整数 $n,m,k,q$。", "outputFormat": "第一行输出 $n$ 个整数，第 $i$ 个整数表示 $n$ 固定、$m=i$ 时的答案；  \n第二行输出 $k$ 个整数，第 $i$ 个整数表示 $m$ 固定、$n=m+i-1$ 时的答案。\n\n两问答案均对 $998244353$ 取模。", "hint": "对于所有数据，$1\\le n,m,k\\le10^6$，$0\\le q<998244353$，保证若 $q\\neq1$ 则 $\\forall i\\in[1,\\max(n,m+k-1)],q^i\\not\\equiv1\\pmod{998244353}$。\n\n- 对于 $20\\%$ 的数据，$n,m,k\\le5\\times10^3$；\n- 对于另外 $20\\%$ 的数据，$q=0$；\n- 对于另外 $20\\%$ 的数据，$q=1$。", "locale": "zh-CN"}}}
{"pid": "P15114", "type": "P", "difficulty": 7, "samples": [["0 0 1\n5 5\n1 1 2 2\n1 0 0\n1 0 0\n1 0 0\n1 0 0\n1 0 0", "1 2 3 4 7 "], ["0 1 1\n5 5\n1 1 2 2\n1 0 0\n1 0 0\n1 0 0\n1 0 0\n1 0 0", "7\n1 1 2 0 1 "]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["点分治", "Special Judge", "凸完全单调性（wqs 二分）", "树链剖分"], "title": "[集训队论文 2026] 无处存储", "background": null, "description": "给定一棵 $n$ 个点以 $1$ 为根的树和 $n$ 个三元组 $(a_i,b_i,c_i)$。\n\n$\\forall s\\in[1,k]$，你需要求一个长度为 $n$ 的非负整数序列 $h$，满足：\n\n- $\\forall i\\in[1,n],h_i\\in[0,k]$。\n- $\\sum_{i=1}^nh_i=s$。\n- $\\forall i\\in[1,n],(h_i\\bmod 2)\\ge\\sum_{j\\in\\mathrm{son(i)}}(g_j\\bmod 2)$，其中 $\\mathrm{son}(i)$ 表示点 $i$ 的儿子集合，$g_j$ 表示 $j$ 子树内 $h$ 的和。\n\n并最小化 $\\sum_{i=1}^nf(a_i,b_i,c_i,h_i)$ 的值，其中 $f(a,b,c,x)=ax^2+bx+c$。\n\n给定 $op\\in\\{0,1\\}$，若 $op=0$，则请求出 $s=1,2,...,k$ 的答案；若 $op=1$，则请求出 $s=k$ 的答案并构造任意一种最优方案。", "inputFormat": "**本题包含多组测试数据。**\n\n第一行三个数 $id,op,T$，分别表示子任务编号、是否要求输出 $s=k$ 的方案和测试组数。\n\n接下来依次输入每组测试数据，对于每组测试数据：\n\n第一行两个数 $n,k$。\n\n第二行 $n-1$ 个数 $p_2,p_3,...,p_n$，$p_i$ 表示 $i$ 号点的父亲。\n\n接下来 $n$ 行，每行三个数，第 $i$ 行的三个数分别表示 $a_i,b_i,c_i$。", "outputFormat": "若 $op=0$，则对于每组测试数据，输出一行 $k$ 个数，第 $i$ 个数表示 $s=i$ 的答案。\n\n若 $op=1$，则对于每组测试数据，先输出一行一个数表示 $s=k$ 时的答案，再输出一行 $n$ 个数，第 $i$ 个数表示 $h_i$，描述 $s=k$ 时的一种最优方案。", "hint": "对于 $100\\%$ 的数据，$1\\le T,\\sum n\\le 3\\times 10^4,1\\le k\\le 2\\times 10^3,0\\le a_i,|b_i|,|c_i|\\le 10^6,1\\le p_i<i$，注意没有保证 $\\sum k$ 的范围。\n\n| 子任务编号 |  $\\sum n\\le$   |      $k\\le$      | $op=$ |     特殊性质     | 空间限制 | 分值 |\n| :--------: | :------------: | :--------------: | :---: | :--------------: | :------: | :--: |\n|    $1$     |      $10$      |       $5$        |  $0$  |        无        | $512$ MB | $5$  |\n|    $2$     |     $300$      |      $200$       |  $0$  |        无        | $512$ MB | $5$  |\n|    $3$     | $2\\times 10^4$ | $1.5\\times 10^3$ |  $0$  |        无        | $512$ MB | $15$ |\n|    $4$     | $2\\times 10^4$ | $1.5\\times 10^3$ |  $1$  |        无        | $512$ MB | $10$ |\n|    $5$     | $2\\times 10^4$ | $1.5\\times 10^3$ |  $0$  | 树的形态随机生成 | $32$ MB  | $5$  |\n|    $6$     | $2\\times 10^4$ | $1.5\\times 10^3$ |  $1$  | 树的形态随机生成 | $32$ MB  | $5$  |\n|    $7$     | $2\\times 10^4$ | $1.5\\times 10^3$ |  $1$  | 树的形态是一条链 | $32$ MB  | $15$ |\n|    $8$     | $2\\times 10^4$ | $1.5\\times 10^3$ |  $0$  |        无        | $32$ MB  | $10$ |\n|    $9$     | $2\\times 10^4$ | $1.5\\times 10^3$ |  $1$  |        无        | $32$ MB  | $10$ |\n|    $10$    | $3\\times 10^4$ |  $2\\times 10^3$  |  $0$  |        无        | $32$ MB  | $10$ |\n|    $11$    | $3\\times 10^4$ |  $2\\times 10^3$  |  $1$  |        无        | $32$ MB  | $10$ |\n\n树的形态随机生成是指，$p_i$ 在 $[1,i-1]$ 之间随机生成。\n\n对于 $op=0$ 的子任务，时间限制为 $3$ s。\n\n对于 $op=1$ 的子任务，时间限制为 $8$ s。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[集训队论文 2026] 无处存储", "background": null, "description": "给定一棵 $n$ 个点以 $1$ 为根的树和 $n$ 个三元组 $(a_i,b_i,c_i)$。\n\n$\\forall s\\in[1,k]$，你需要求一个长度为 $n$ 的非负整数序列 $h$，满足：\n\n- $\\forall i\\in[1,n],h_i\\in[0,k]$。\n- $\\sum_{i=1}^nh_i=s$。\n- $\\forall i\\in[1,n],(h_i\\bmod 2)\\ge\\sum_{j\\in\\mathrm{son(i)}}(g_j\\bmod 2)$，其中 $\\mathrm{son}(i)$ 表示点 $i$ 的儿子集合，$g_j$ 表示 $j$ 子树内 $h$ 的和。\n\n并最小化 $\\sum_{i=1}^nf(a_i,b_i,c_i,h_i)$ 的值，其中 $f(a,b,c,x)=ax^2+bx+c$。\n\n给定 $op\\in\\{0,1\\}$，若 $op=0$，则请求出 $s=1,2,...,k$ 的答案；若 $op=1$，则请求出 $s=k$ 的答案并构造任意一种最优方案。", "inputFormat": "**本题包含多组测试数据。**\n\n第一行三个数 $id,op,T$，分别表示子任务编号、是否要求输出 $s=k$ 的方案和测试组数。\n\n接下来依次输入每组测试数据，对于每组测试数据：\n\n第一行两个数 $n,k$。\n\n第二行 $n-1$ 个数 $p_2,p_3,...,p_n$，$p_i$ 表示 $i$ 号点的父亲。\n\n接下来 $n$ 行，每行三个数，第 $i$ 行的三个数分别表示 $a_i,b_i,c_i$。", "outputFormat": "若 $op=0$，则对于每组测试数据，输出一行 $k$ 个数，第 $i$ 个数表示 $s=i$ 的答案。\n\n若 $op=1$，则对于每组测试数据，先输出一行一个数表示 $s=k$ 时的答案，再输出一行 $n$ 个数，第 $i$ 个数表示 $h_i$，描述 $s=k$ 时的一种最优方案。", "hint": "对于 $100\\%$ 的数据，$1\\le T,\\sum n\\le 3\\times 10^4,1\\le k\\le 2\\times 10^3,0\\le a_i,|b_i|,|c_i|\\le 10^6,1\\le p_i<i$，注意没有保证 $\\sum k$ 的范围。\n\n| 子任务编号 |  $\\sum n\\le$   |      $k\\le$      | $op=$ |     特殊性质     | 空间限制 | 分值 |\n| :--------: | :------------: | :--------------: | :---: | :--------------: | :------: | :--: |\n|    $1$     |      $10$      |       $5$        |  $0$  |        无        | $512$ MB | $5$  |\n|    $2$     |     $300$      |      $200$       |  $0$  |        无        | $512$ MB | $5$  |\n|    $3$     | $2\\times 10^4$ | $1.5\\times 10^3$ |  $0$  |        无        | $512$ MB | $15$ |\n|    $4$     | $2\\times 10^4$ | $1.5\\times 10^3$ |  $1$  |        无        | $512$ MB | $10$ |\n|    $5$     | $2\\times 10^4$ | $1.5\\times 10^3$ |  $0$  | 树的形态随机生成 | $32$ MB  | $5$  |\n|    $6$     | $2\\times 10^4$ | $1.5\\times 10^3$ |  $1$  | 树的形态随机生成 | $32$ MB  | $5$  |\n|    $7$     | $2\\times 10^4$ | $1.5\\times 10^3$ |  $1$  | 树的形态是一条链 | $32$ MB  | $15$ |\n|    $8$     | $2\\times 10^4$ | $1.5\\times 10^3$ |  $0$  |        无        | $32$ MB  | $10$ |\n|    $9$     | $2\\times 10^4$ | $1.5\\times 10^3$ |  $1$  |        无        | $32$ MB  | $10$ |\n|    $10$    | $3\\times 10^4$ |  $2\\times 10^3$  |  $0$  |        无        | $32$ MB  | $10$ |\n|    $11$    | $3\\times 10^4$ |  $2\\times 10^3$  |  $1$  |        无        | $32$ MB  | $10$ |\n\n树的形态随机生成是指，$p_i$ 在 $[1,i-1]$ 之间随机生成。\n\n对于 $op=0$ 的子任务，时间限制为 $3$ s。\n\n对于 $op=1$ 的子任务，时间限制为 $8$ s。", "locale": "zh-CN"}}}
{"pid": "P15115", "type": "P", "difficulty": 6, "samples": [["4\n0 0 10 10\n0 0 10 10\n10 10 -10 -10\n10 0 -20 0", "22.2222222222222"], ["3\n0 -1 0 2\n1 1 1 1\n-1 1 -1 1", "0"], ["3\n0 -1 0 -2\n1 1 1 1\n-1 1 -1 1", "4"], ["1\n0 0 0 0", "0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "Special Judge", "ICPC"], "title": "[ICPC 2024 LAC] Almost Aligned", "background": "", "description": "A meteor shower is about to happen! As the enthusiastic astronomy photographer that you are, you want to take a single picture of all the meteors that will be part of the phenomenon. Not only that, you want to take the best possible picture. You know that the smaller the area of the photo, the better the picture. But how small can you make the photo to capture them all?\n\nYou can take a picture of any rectangular region of your camera’s view, but you cannot rotate the camera. That is, your photo can be any axis-aligned rectangle. The challenge? The meteors are constantly moving. Think of time ($t$) as the number of seconds that have passed since the start of the meteor shower. Your goal is to find a non-negative value of $t$ at which you can capture every single meteor with the smallest possible rectangle. A photo captures all the meteors within the rectangle, including those on the border.", "inputFormat": "The first line contains an integer $N$ ($1 \\le N \\le 10^6$) indicating the number of meteors.\n\nEach of the next $N$ lines describes a meteor with four integers $X, Y, V_X$ and $V_Y$ ($-10^9 \\le X, Y, V_X, V_Y \\le 10^9$), representing the location and velocity of the meteor, as seen by your camera. This means that at any time $t \\ge 0$ the coordinates of the meteor are $(X + t \\cdot V_X, Y + t \\cdot V_Y)$. If $t < 0$ the location of the meteor is undefined.", "outputFormat": "Output a single line with the minimum area of an axis-aligned rectangle containing all the meteors at a time $t \\ge 0$. The output must have an absolute or relative error of at most $10^{-9}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 LAC] Almost Aligned", "background": "", "description": "A meteor shower is about to happen! As the enthusiastic astronomy photographer that you are, you want to take a single picture of all the meteors that will be part of the phenomenon. Not only that, you want to take the best possible picture. You know that the smaller the area of the photo, the better the picture. But how small can you make the photo to capture them all?\n\nYou can take a picture of any rectangular region of your camera’s view, but you cannot rotate the camera. That is, your photo can be any axis-aligned rectangle. The challenge? The meteors are constantly moving. Think of time ($t$) as the number of seconds that have passed since the start of the meteor shower. Your goal is to find a non-negative value of $t$ at which you can capture every single meteor with the smallest possible rectangle. A photo captures all the meteors within the rectangle, including those on the border.", "inputFormat": "The first line contains an integer $N$ ($1 \\le N \\le 10^6$) indicating the number of meteors.\n\nEach of the next $N$ lines describes a meteor with four integers $X, Y, V_X$ and $V_Y$ ($-10^9 \\le X, Y, V_X, V_Y \\le 10^9$), representing the location and velocity of the meteor, as seen by your camera. This means that at any time $t \\ge 0$ the coordinates of the meteor are $(X + t \\cdot V_X, Y + t \\cdot V_Y)$. If $t < 0$ the location of the meteor is undefined.", "outputFormat": "Output a single line with the minimum area of an axis-aligned rectangle containing all the meteors at a time $t \\ge 0$. The output must have an absolute or relative error of at most $10^{-9}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 LAC] Almost Aligned", "background": "", "description": "一场流星雨即将来临！作为一位热情的天文摄影爱好者，你希望为这场现象中的所有流星拍摄一张照片。不仅如此，你还想拍出尽可能最好的照片。你知道照片的面积越小，照片质量越好。但是，要捕捉到所有流星，你能把照片拍得多小呢？\n\n你可以拍摄相机视野中的任意矩形区域，但不能旋转相机。也就是说，你的照片可以是任意轴对齐的矩形。挑战在于流星在不断移动。将时间（$t$）视为流星雨开始后经过的秒数。你的目标是找到一个非负的 $t$ 值，使得你能用尽可能小的矩形捕捉到每一颗流星。一张照片可以捕捉矩形内的所有流星，包括边界上的流星。", "inputFormat": "第一行包含一个整数 $N$（$1 \\le N \\le 10^6$），表示流星的数量。\n\n接下来的 $N$ 行，每行描述一颗流星，包含四个整数 $X, Y, V_X$ 和 $V_Y$（$-10^9 \\le X, Y, V_X, V_Y \\le 10^9$），表示从你的相机视角看到的流星的位置和速度。这意味着在任意时间 $t \\ge 0$，流星的坐标为 $(X + t \\cdot V_X, Y + t \\cdot V_Y)$。如果 $t < 0$，则流星的位置未定义。", "outputFormat": "输出一行，表示在某个时间 $t \\ge 0$ 包含所有流星的轴对齐矩形的最小面积。输出的绝对误差或相对误差不得超过 $10^{-9}$。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P15116", "type": "P", "difficulty": 6, "samples": [["1 100 50\n50 48 49 1 1 50", "98.5"], ["1 100 50\n50 48 49 52 1 50", "97.15384615384615"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "Special Judge", "ICPC"], "title": "[ICPC 2024 LAC] Beating the Record", "background": "", "description": "Speedy Greedy is a professional speedrunner: they play a videogame repeatedly, with the aim of finishing it as quickly as possible.\n\nThe game that Speedy Greedy is currently tackling consists of $N$ levels, numbered sequentially from 1 to $N$. Although these levels must be completed in order, each of them is independent of the other in terms of gameplay. That is, no event from one level can have a relevant effect on the next levels (unlike other games where items, spells, points, lives, etc. are carried over from one level to the next).\n\nThe current world record for the fastest completion time of the game is $T$ seconds. Speedy Greedy is determined to beat this world record, with no concern for the margin. Whether the game is finished 1 second or 1000 seconds faster than the current record is irrelevant: what matters to Speedy Greedy is improving the world record.\n\nSpeedrunners often choose and adjust their actions dynamically during a run, depending on various factors such as the situation of their character in the game. It is also common to restart the game, as for example once $T$ seconds have passed there is no more hope to beat the world record. Any run of the game can be restarted at any point. When a restart command is issued by the speedrunner, the game instantly restarts from the beginning. Thus, to beat the world record, Speedy Greedy must complete the $N$ levels sequentially, in a single run that takes less than $T$ seconds.\n\nHow can Speedy Greedy achieve that? Well, most sections of the game are completely safe and easy to play for a speedrunner of such skill. Those sections take fixed amounts of time and have no risk of failing. However, there is a very hard section in each of the $N$ levels, where the result of playing that section is not completely under Speedy Greedy’s control, and also depends on the chosen strategy.\n\nIn each level, there are two possible strategies, and when reaching the hard section, Speedy Greedy can choose exactly one of them to attempt. Each strategy has its own probability of success, and the actual time that the level takes to complete depends on the chosen strategy and whether the attempt is successful or not.\n\nFor the purposes of this problem, we assume that Speedy Greedy can instantly detect whether the chosen strategy for a level succeeded or failed, right at the moment that the hard section of the level is reached. That is, reaching the hard section of a level, choosing a strategy, and knowing whether the attempted strategy succeeded or failed are all simultaneous events, occurring at exactly the same time.\n\nGrinding the game by playing again and again and again becomes tiring and physically exhausting at such a high level of speedrunning competition. Speedy Greedy then decided to play the game so as to minimize the expected total play time until beating the world record. Your task is to compute this minimum.\n\nNote that the total play time not only includes the time of the final successful run that takes less than $T$ seconds (beating the world record), but also includes the time spent during all previous failed runs.", "inputFormat": "The first line contains three integers $N$ ($1 \\le N \\le 4$), $T$ ($1 \\le T \\le 5000$) and $S$ ($1 \\le S \\le 1000$), indicating respectively the number of levels, the time of the current world record, and the time from the start of level 1 until the instant that the hard section in level 1 is reached.\n\nThe $i$-th of the next $N$ lines describes the two strategies for level $i$ by means of six integers $P_1, G_1, B_1, P_2, G_2$ and $B_2$ ($1 \\le P_j \\le 99$ and $0 \\le G_j \\le B_j \\le 1000$, for $j = 1, 2$).\n\n- $P_j$ indicates the probability (as a percentage) that strategy $j$ succeeds when used.\n- $G_j$ represents the “good time” for strategy $j$, that is, the time from the moment the strategy succeeds, until the moment that the hard section of the next level is reached. For the last level, $G_j$ represents the time from the moment the strategy succeeds, until the completion of the game.\n- $B_j$ denotes the “bad time” for strategy $j$. It is analogous to $G_j$, but indicates the time corresponding to the case when the strategy fails.\n\nAll input times are given in seconds. It is guaranteed that the input is such that beating the world record is possible.", "outputFormat": "Output a single line with the minimum expected total play time until Speedy Greedy beats the world record. The output must have an absolute or relative error of at most $10^{-9}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 LAC] Beating the Record", "background": "", "description": "Speedy Greedy is a professional speedrunner: they play a videogame repeatedly, with the aim of finishing it as quickly as possible.\n\nThe game that Speedy Greedy is currently tackling consists of $N$ levels, numbered sequentially from 1 to $N$. Although these levels must be completed in order, each of them is independent of the other in terms of gameplay. That is, no event from one level can have a relevant effect on the next levels (unlike other games where items, spells, points, lives, etc. are carried over from one level to the next).\n\nThe current world record for the fastest completion time of the game is $T$ seconds. Speedy Greedy is determined to beat this world record, with no concern for the margin. Whether the game is finished 1 second or 1000 seconds faster than the current record is irrelevant: what matters to Speedy Greedy is improving the world record.\n\nSpeedrunners often choose and adjust their actions dynamically during a run, depending on various factors such as the situation of their character in the game. It is also common to restart the game, as for example once $T$ seconds have passed there is no more hope to beat the world record. Any run of the game can be restarted at any point. When a restart command is issued by the speedrunner, the game instantly restarts from the beginning. Thus, to beat the world record, Speedy Greedy must complete the $N$ levels sequentially, in a single run that takes less than $T$ seconds.\n\nHow can Speedy Greedy achieve that? Well, most sections of the game are completely safe and easy to play for a speedrunner of such skill. Those sections take fixed amounts of time and have no risk of failing. However, there is a very hard section in each of the $N$ levels, where the result of playing that section is not completely under Speedy Greedy’s control, and also depends on the chosen strategy.\n\nIn each level, there are two possible strategies, and when reaching the hard section, Speedy Greedy can choose exactly one of them to attempt. Each strategy has its own probability of success, and the actual time that the level takes to complete depends on the chosen strategy and whether the attempt is successful or not.\n\nFor the purposes of this problem, we assume that Speedy Greedy can instantly detect whether the chosen strategy for a level succeeded or failed, right at the moment that the hard section of the level is reached. That is, reaching the hard section of a level, choosing a strategy, and knowing whether the attempted strategy succeeded or failed are all simultaneous events, occurring at exactly the same time.\n\nGrinding the game by playing again and again and again becomes tiring and physically exhausting at such a high level of speedrunning competition. Speedy Greedy then decided to play the game so as to minimize the expected total play time until beating the world record. Your task is to compute this minimum.\n\nNote that the total play time not only includes the time of the final successful run that takes less than $T$ seconds (beating the world record), but also includes the time spent during all previous failed runs.", "inputFormat": "The first line contains three integers $N$ ($1 \\le N \\le 4$), $T$ ($1 \\le T \\le 5000$) and $S$ ($1 \\le S \\le 1000$), indicating respectively the number of levels, the time of the current world record, and the time from the start of level 1 until the instant that the hard section in level 1 is reached.\n\nThe $i$-th of the next $N$ lines describes the two strategies for level $i$ by means of six integers $P_1, G_1, B_1, P_2, G_2$ and $B_2$ ($1 \\le P_j \\le 99$ and $0 \\le G_j \\le B_j \\le 1000$, for $j = 1, 2$).\n\n- $P_j$ indicates the probability (as a percentage) that strategy $j$ succeeds when used.\n- $G_j$ represents the “good time” for strategy $j$, that is, the time from the moment the strategy succeeds, until the moment that the hard section of the next level is reached. For the last level, $G_j$ represents the time from the moment the strategy succeeds, until the completion of the game.\n- $B_j$ denotes the “bad time” for strategy $j$. It is analogous to $G_j$, but indicates the time corresponding to the case when the strategy fails.\n\nAll input times are given in seconds. It is guaranteed that the input is such that beating the world record is possible.", "outputFormat": "Output a single line with the minimum expected total play time until Speedy Greedy beats the world record. The output must have an absolute or relative error of at most $10^{-9}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 LAC] Beating the Record", "background": "", "description": "Speedy Greedy 是一名专业的速通玩家：他们反复玩一款电子游戏，目标是尽可能快地通关。\n\nSpeedy Greedy 目前挑战的游戏由 $N$ 个关卡组成，按顺序编号为 1 到 $N$。尽管这些关卡必须按顺序完成，但每个关卡在游戏玩法上是相互独立的。也就是说，一个关卡中的任何事件都不会对后续关卡产生相关影响（不像其他游戏那样，物品、法术、分数、生命等会从一个关卡延续到下一个关卡）。\n\n当前游戏最快通关时间的世界纪录是 $T$ 秒。Speedy Greedy 决心打破这个世界纪录，并不在意领先多少。无论是比当前纪录快 1 秒还是快 1000 秒都无关紧要：对 Speedy Greedy 来说，重要的是刷新世界纪录。\n\n速通玩家在游戏中经常根据各种因素（例如角色在游戏中的状况）动态选择和调整行动。重启游戏也很常见，因为一旦超过 $T$ 秒，就没有希望打破世界纪录了。游戏中的任何一次流程都可以在任何时候重启。当速通玩家发出重启指令时，游戏会立即从头开始。因此，为了打破世界纪录，Speedy Greedy 必须在一个单独的流程中按顺序完成 $N$ 个关卡，且总时间少于 $T$ 秒。\n\nSpeedy Greedy 如何才能做到这一点呢？好吧，对于这样一位技术高超的速通玩家来说，游戏的大部分部分是完全安全且容易操作的。这些部分花费固定的时间，并且没有失败的风险。然而，在 $N$ 个关卡的每一个中，都有一个非常困难的部分，其游玩结果并不完全受 Speedy Greedy 控制，还取决于所选择的策略。\n\n在每个关卡中，有两种可能的策略，当到达困难部分时，Speedy Greedy 可以恰好选择其中一种进行尝试。每种策略都有自己的成功概率，而关卡实际完成所需的时间取决于所选策略以及尝试是否成功。\n\n为了本问题的目的，我们假设 Speedy Greedy 可以在到达关卡的困难部分的瞬间立即检测到所选的策略是成功还是失败。也就是说，到达关卡的困难部分、选择策略以及得知尝试的策略成功或失败，都是同时发生的事件，发生在完全相同的时刻。\n\n在这种高水平的速通竞赛中，一遍又一遍地反复玩游戏会变得令人疲惫和筋疲力尽。于是 Speedy Greedy 决定以最小化直到打破世界纪录的预期总游戏时间来游玩。你的任务是计算这个最小值。\n\n请注意，总游戏时间不仅包括最终那次耗时少于 $T$ 秒的成功流程（打破世界纪录）的时间，还包括之前所有失败流程所花费的时间。", "inputFormat": "第一行包含三个整数 $N$（$1 \\le N \\le 4$）、$T$（$1 \\le T \\le 5000$）和 $S$（$1 \\le S \\le 1000$），分别表示关卡数量、当前世界纪录的时间，以及从关卡 1 开始到关卡 1 的困难部分被到达的时刻所经过的时间。\n\n接下来的 $N$ 行中的第 $i$ 行通过六个整数 $P_1, G_1, B_1, P_2, G_2$ 和 $B_2$（对于 $j = 1, 2$，有 $1 \\le P_j \\le 99$ 和 $0 \\le G_j \\le B_j \\le 1000$）描述了第 $i$ 关的两种策略。\n\n- $P_j$ 表示使用策略 $j$ 时成功的概率（以百分比计）。\n- $G_j$ 表示策略 $j$ 的“好时间”，即从策略成功的时刻到下一个关卡的困难部分被到达的时刻所经过的时间。对于最后一个关卡，$G_j$ 表示从策略成功的时刻到游戏完成所经过的时间。\n- $B_j$ 表示策略 $j$ 的“坏时间”。它与 $G_j$ 类似，但对应于策略失败情况下的时间。\n\n所有输入时间均以秒为单位。保证输入数据使得打破世界纪录是可能的。", "outputFormat": "输出一行，表示 Speedy Greedy 打破世界纪录前的最小预期总游戏时间。输出的绝对误差或相对误差不得超过 $10^{-9}$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P15117", "type": "P", "difficulty": 5, "samples": [["3 3\n#.#\n...\n#.#", "4"], ["3 3\n..#\n...\n...", "0"], ["1 4\n...#", "2"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "ICPC"], "title": "[ICPC 2024 LAC] Clever Cell Choices", "background": "", "description": "Two players play the following game on an $N \\times M$ grid:\n\n- Initially each cell of the grid is either empty or occupied.\n- Players take turns placing a stone on an empty cell, occupying the cell. Each new stone must be adjacent to the last placed stone, with the exception of the starting stone that can be placed on any empty cell. A stone is adjacent to another stone if they are located in two cells that share a side.\n- The game ends whenever a player cannot place a stone according to the above rules. In that case, the player who cannot place a stone loses the game, and the other player wins.\n\nA winning starting cell is a cell such that the first player wins the game if they place their starting stone there, assuming both players play optimally. Given a description of the initial grid, you must tell how many winning starting cells it has.\n", "inputFormat": "The first line contains two integers $N$ and $M$ ($1 \\le N, M \\le 50$) indicating the dimensions of the grid.\n\nEach of the next $N$ lines contains a string of length $M$. In the $i$-th string, the $j$-th character describes the initial state of cell $(i, j)$. The character is either \".\" (dot) denoting an empty cell, or \"#\" (hash) representing an occupied cell.", "outputFormat": "Output a single line with an integer indicating the number of winning starting cells.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 LAC] Clever Cell Choices", "background": "", "description": "Two players play the following game on an $N \\times M$ grid:\n\n- Initially each cell of the grid is either empty or occupied.\n- Players take turns placing a stone on an empty cell, occupying the cell. Each new stone must be adjacent to the last placed stone, with the exception of the starting stone that can be placed on any empty cell. A stone is adjacent to another stone if they are located in two cells that share a side.\n- The game ends whenever a player cannot place a stone according to the above rules. In that case, the player who cannot place a stone loses the game, and the other player wins.\n\nA winning starting cell is a cell such that the first player wins the game if they place their starting stone there, assuming both players play optimally. Given a description of the initial grid, you must tell how many winning starting cells it has.\n", "inputFormat": "The first line contains two integers $N$ and $M$ ($1 \\le N, M \\le 50$) indicating the dimensions of the grid.\n\nEach of the next $N$ lines contains a string of length $M$. In the $i$-th string, the $j$-th character describes the initial state of cell $(i, j)$. The character is either \".\" (dot) denoting an empty cell, or \"#\" (hash) representing an occupied cell.", "outputFormat": "Output a single line with an integer indicating the number of winning starting cells.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 LAC] Clever Cell Choices", "background": "", "description": "两个玩家在一个 $N \\times M$ 的网格上进行如下游戏：\n\n- 初始时，网格中的每个单元格要么是空的，要么被占据。\n- 玩家轮流在一个空单元格上放置一颗棋子，占据该单元格。除了起始棋子可以放在任意空单元格外，每颗新放置的棋子必须与上一颗放置的棋子相邻。如果两颗棋子所在的单元格共享一条边，则它们相邻。\n- 一旦有玩家无法根据上述规则放置棋子，游戏立即结束。此时，无法放置棋子的玩家输掉游戏，另一名玩家获胜。\n\n一个**必胜起始单元格**是指：如果先手玩家将起始棋子放在该单元格上，并且双方都采取最优策略，那么先手玩家能够赢得游戏。给定初始网格的描述，你需要计算它有多少个必胜起始单元格。", "inputFormat": "第一行包含两个整数 $N$ 和 $M$（$1 \\le N, M \\le 50$），表示网格的尺寸。\n\n接下来的 $N$ 行，每行包含一个长度为 $M$ 的字符串。第 $i$ 个字符串中的第 $j$ 个字符描述了单元格 $(i, j)$ 的初始状态。字符是 “.”（点号）表示空单元格，或是 “#”（井号）表示被占据的单元格。\n", "outputFormat": "输出一行一个整数，表示必胜起始单元格的数量。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P15118", "type": "P", "difficulty": 4, "samples": [["10", "Y"], ["9", "N"], ["1", "N"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "2024", "ICPC"], "title": "[ICPC 2024 LAC] DiviDuelo", "background": "", "description": "The Intense Challenges Players Club (ICPC) is hosting a DiviDuelo tournament.\n\nDiviDuelo is a new two-player, turn-based game. In DiviDuelo, a number $N$ is selected and the list of its divisors is written. For example, if $N = 10$ is selected, the list of numbers $1, 2, 5, 10$ is written. Players alternate turns picking one still unpicked divisor from the list each turn, until all divisors have been picked.\n\nThe winner is determined by the greatest common divisor (GCD) of the numbers picked by the starting player. If the GCD is **not** equal to 1, the starting player wins. Otherwise, if the GCD is equal to 1, the other player wins.\n\nThe ICPC needs your help to prepare some statistics about the games played in the tournament. Given the value of $N$, determine if the starting player can win the game assuming both players play optimally.", "inputFormat": "The input consists of a single line that contains an integer $N$ ($1 \\le N \\le 10^{12}$) indicating the number selected for the game.\n", "outputFormat": "Output a single line with the uppercase letter \"Y\" if the starting player can win the game and the uppercase letter \"N\" otherwise, assuming both players play optimally.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 LAC] DiviDuelo", "background": "", "description": "The Intense Challenges Players Club (ICPC) is hosting a DiviDuelo tournament.\n\nDiviDuelo is a new two-player, turn-based game. In DiviDuelo, a number $N$ is selected and the list of its divisors is written. For example, if $N = 10$ is selected, the list of numbers $1, 2, 5, 10$ is written. Players alternate turns picking one still unpicked divisor from the list each turn, until all divisors have been picked.\n\nThe winner is determined by the greatest common divisor (GCD) of the numbers picked by the starting player. If the GCD is **not** equal to 1, the starting player wins. Otherwise, if the GCD is equal to 1, the other player wins.\n\nThe ICPC needs your help to prepare some statistics about the games played in the tournament. Given the value of $N$, determine if the starting player can win the game assuming both players play optimally.", "inputFormat": "The input consists of a single line that contains an integer $N$ ($1 \\le N \\le 10^{12}$) indicating the number selected for the game.\n", "outputFormat": "Output a single line with the uppercase letter \"Y\" if the starting player can win the game and the uppercase letter \"N\" otherwise, assuming both players play optimally.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 LAC] DiviDuelo", "background": "", "description": "“高强度挑战玩家俱乐部”（ICPC）正在举办一场 DiviDuelo 锦标赛。\n\nDiviDuelo 是一款新的双人回合制游戏。在 DiviDuelo 中，选定一个数字 $N$ 并列出其所有因数。例如，如果选定 $N = 10$，则列出数字 $1, 2, 5, 10$。玩家轮流从列表中选取一个尚未被选中的因数，直到所有因数都被选取完毕。\n\n胜负由先手玩家所选数字的最大公约数（GCD）决定。如果 GCD **不等于** 1，则先手玩家获胜。否则，如果 GCD 等于 1，则另一名玩家获胜。\n\nICPC 需要你帮助准备锦标赛中游戏的一些统计数据。给定 $N$ 的值，假设双方都采取最优策略，判断先手玩家是否能够赢得游戏。", "inputFormat": "输入只有一行，包含一个整数 $N$（$1 \\le N \\le 10^{12}$），表示游戏选定的数字。\n", "outputFormat": "输出一行，包含大写字母 “Y” 表示先手玩家能够赢得游戏，否则输出大写字母 “N”，假设双方都采取最优策略。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P15119", "type": "P", "difficulty": 3, "samples": [["2\n+2 +1 -1 -2", "GG"], ["2\n+1 +2 -1 -2", "GS"], ["2\n+1 +2 -1 -2", "SG"], ["3\n+1 +2 +3 -1 -2 -3", "*"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "Special Judge", "ICPC"], "title": "[ICPC 2024 LAC] Expanding STACKS!", "background": "", "description": "Tired of always waiting in lines, you invented a revolutionary restaurant concept: “STACKS! Where the last customer is served first”.\n\nThe restaurant operates as follows:\n\n- There is a single line inside the restaurant.\n- When a customer enters, they immediately join the back of the line.\n- Whenever a stack of glazed pancakes (the only dish at STACKS!) is ready, it’s served to the person at the back of the line, who then immediately devours the pancakes and leaves the restaurant.\n\nThis business model has been incredibly successful, so much so that STACKS! is beginning to expand.\n\nIn fact, you just opened the very first STACKS!+, offering two types of pancakes: glazed and savory. The new restaurant works as follows:\n\n- There are two lines, one for each type of pancake. Each customer joins the back of the line corresponding to the type of pancake they want.\n- Whenever a stack of glazed pancakes is ready, it is served to the customer at the back of the glazed pancake line, who immediately devours it and leaves the restaurant.\n- Whenever a stack of savory pancakes is ready, it is served to the customer at the back of the savory pancake line, who instantly gobbles it and leaves the restaurant.\n\nAs the boss, you want to ensure your employees follow the concept and maintain your vision. Given the order in which customers come in and out of the restaurant, you need to determine whether there is an assignment of customers to lines such that the STACKS!+ concept is followed.\n\nYou can assume that whenever a customer enters the restaurant, they immediately join the back of a line, and that they leave as soon as they are served. Also, each customer visits the restaurant exactly once.", "inputFormat": "The first line contains an integer $N$ ($1 \\le N \\le 1000$) indicating the number of customers who visited STACKS!+. Each customer is identified by a distinct integer from 1 to $N$.\n\nThe second line contains $2N$ signed integers $X_1, X_2, \\dots, X_{2N}$ ($1 \\le |X_i| \\le N$ for $i = 1, 2, \\dots, 2N$) indicating, in chronological order, the entrance and departure of the customers. The value $X_i = +c$ denotes the entrance of customer $c$ into the restaurant, while $X_i = -c$ represents their departure. It is guaranteed that each customer enters and leaves the restaurant exactly once, and that they do not leave before entering.", "outputFormat": "Output a single line with a string of length $N$ if there is an assignment of customers to lines such that the STACKS!+ concept can be honored. In this case the $i$-th character of the string must be the uppercase letter \"G\" if customer $i$ is assigned to the glazed pancake line, and the uppercase letter \"S\" if they are assigned to the savory line. If there are multiple solutions, output any of them.\n\nIf the STACKS!+ concept cannot be honored with the given input, output the character \"*\" (asterisk) instead.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 LAC] Expanding STACKS!", "background": "", "description": "Tired of always waiting in lines, you invented a revolutionary restaurant concept: “STACKS! Where the last customer is served first”.\n\nThe restaurant operates as follows:\n\n- There is a single line inside the restaurant.\n- When a customer enters, they immediately join the back of the line.\n- Whenever a stack of glazed pancakes (the only dish at STACKS!) is ready, it’s served to the person at the back of the line, who then immediately devours the pancakes and leaves the restaurant.\n\nThis business model has been incredibly successful, so much so that STACKS! is beginning to expand.\n\nIn fact, you just opened the very first STACKS!+, offering two types of pancakes: glazed and savory. The new restaurant works as follows:\n\n- There are two lines, one for each type of pancake. Each customer joins the back of the line corresponding to the type of pancake they want.\n- Whenever a stack of glazed pancakes is ready, it is served to the customer at the back of the glazed pancake line, who immediately devours it and leaves the restaurant.\n- Whenever a stack of savory pancakes is ready, it is served to the customer at the back of the savory pancake line, who instantly gobbles it and leaves the restaurant.\n\nAs the boss, you want to ensure your employees follow the concept and maintain your vision. Given the order in which customers come in and out of the restaurant, you need to determine whether there is an assignment of customers to lines such that the STACKS!+ concept is followed.\n\nYou can assume that whenever a customer enters the restaurant, they immediately join the back of a line, and that they leave as soon as they are served. Also, each customer visits the restaurant exactly once.", "inputFormat": "The first line contains an integer $N$ ($1 \\le N \\le 1000$) indicating the number of customers who visited STACKS!+. Each customer is identified by a distinct integer from 1 to $N$.\n\nThe second line contains $2N$ signed integers $X_1, X_2, \\dots, X_{2N}$ ($1 \\le |X_i| \\le N$ for $i = 1, 2, \\dots, 2N$) indicating, in chronological order, the entrance and departure of the customers. The value $X_i = +c$ denotes the entrance of customer $c$ into the restaurant, while $X_i = -c$ represents their departure. It is guaranteed that each customer enters and leaves the restaurant exactly once, and that they do not leave before entering.", "outputFormat": "Output a single line with a string of length $N$ if there is an assignment of customers to lines such that the STACKS!+ concept can be honored. In this case the $i$-th character of the string must be the uppercase letter \"G\" if customer $i$ is assigned to the glazed pancake line, and the uppercase letter \"S\" if they are assigned to the savory line. If there are multiple solutions, output any of them.\n\nIf the STACKS!+ concept cannot be honored with the given input, output the character \"*\" (asterisk) instead.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 LAC] Expanding STACKS!", "background": "", "description": "厌倦了总是排队等候，你发明了一个革命性的餐厅概念：“STACKS！最后来的顾客最先被服务”。\n\n这家餐厅的运营方式如下：\n\n- 餐厅内只有一条队伍。\n- 当顾客进入餐厅时，他们立即排到队伍的末尾。\n- 每当一份浇了糖浆的煎饼（STACKS！唯一供应的菜品）准备好时，它会被提供给队伍末尾的人，然后该顾客立即吃掉煎饼并离开餐厅。\n\n这种商业模式取得了巨大成功，以至于 STACKS！开始扩张。\n\n事实上，你刚刚开了第一家 STACKS！+，提供两种类型的煎饼：浇糖浆的和咸味的。新餐厅的运营方式如下：\n\n- 有两条队伍，每种煎饼对应一条。每位顾客排到他们想要的那种煎饼所对应的队伍的末尾。\n- 每当一份浇糖浆的煎饼准备好时，它被提供给浇糖浆煎饼队伍末尾的顾客，该顾客立即吃掉它并离开餐厅。\n- 每当一份咸味煎饼准备好时，它被提供给咸味煎饼队伍末尾的顾客，该顾客立即狼吞虎咽地吃掉它并离开餐厅。\n\n作为老板，你想确保员工遵循这一概念并维护你的愿景。给定顾客进出餐厅的顺序，你需要判断是否存在一种将顾客分配到两条队伍的方法，使得 STACKS！+ 的概念得以遵循。\n\n你可以假设每当顾客进入餐厅时，他们立即排到一条队伍的末尾，并且他们一被服务就立即离开。此外，每位顾客恰好光顾餐厅一次。", "inputFormat": "第一行包含一个整数 $N$（$1 \\le N \\le 1000$），表示光顾 STACKS！+ 的顾客数量。每位顾客由 $1$ 到 $N$ 之间的一个不同整数标识。\n\n第二行包含 $2N$ 个有符号整数 $X_1, X_2, \\dots, X_{2N}$（对于 $i = 1, 2, \\dots, 2N$，有 $1 \\le |X_i| \\le N$），按时间顺序表示顾客的进入和离开。值 $X_i = +c$ 表示顾客 $c$ 进入餐厅，而 $X_i = -c$ 表示他们离开。保证每位顾客恰好进入和离开餐厅各一次，且他们不会在进入之前离开。", "outputFormat": "如果存在一种将顾客分配到两条队伍的方法使得 STACKS！+ 的概念得以遵循，则输出一行一个长度为 $N$ 的字符串。在这种情况下，字符串的第 $i$ 个字符必须是大写字母 \"G\"（如果顾客 $i$ 被分配到浇糖浆煎饼队伍）或大写字母 \"S\"（如果被分配到咸味煎饼队伍）。如果存在多种解决方案，输出任意一种即可。\n\n如果给定的输入无法遵循 STACKS！+ 的概念，则输出字符 \"*\"（星号）。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P15120", "type": "P", "difficulty": 4, "samples": [["3\n1 1\n0 3\n2 1", "Y"], ["3\n3 2\n2 1\n3 2", "Y"], ["3\n1 10\n2 20\n4 30", "N"], ["1\n1 1", "N"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "ICPC"], "title": "[ICPC 2024 LAC] Fair Distribution", "background": "", "description": "An entrepreneur has $N$ blueprints, each describing a type of building. Each blueprint specifies the building’s height through two integers $G$ and $R$.\n\n- $G$: Height of the ground floor. It can be zero, indicating that the building has no ground floor.\n- $R$: Height of each residential floor. Each building has at least one residential floor.\n\nThe entrepreneur wants to distribute all of these blueprints among their two children Alice and Bob. Each child will build exactly one building from each blueprint allocated to them, choosing the number of residential floors for each building.\n\nThe entrepreneur wants to avoid showing favoritism towards either child, so they are looking for a fair distribution of the blueprints. They decided that a fair distribution is one in which it is possible to construct the buildings in such a way that the sum of the heights of the buildings constructed by each child is the same. Can you tell whether a fair distribution exists?\n\nConsider the following example for $N = 3$ blueprints:\n\n1. $G = 1$ and $R = 1$ (possible heights are $2, 3, 4, \\dots$);\n2. $G = 0$ and $R = 3$ (no ground floor, possible heights are $3, 6, 9, \\dots$);\n3. $G = 2$ and $R = 1$ (possible heights are $3, 4, 5, \\dots$).\n\nIn this case a possible fair distribution is assigning the second blueprint to Alice and the rest to Bob. Even though Alice receives a single blueprint while Bob receives two, they may construct two residential floors on the first building type (height 3), two residential floors on the second (height 6), and one residential floor on the third (height 3). In this way, the sum of the heights of the buildings constructed by each child would be 6.", "inputFormat": "The first line contains an integer $N$ ($1 \\le N \\le 2 \\cdot 10^5$) indicating the number of blueprints.\n\nEach of the next $N$ lines contains two integers $G$ ($0 \\le G \\le 2 \\cdot 10^5$) and $R$ ($1 \\le R \\le 10^9$) denoting respectively the height of the ground floor and the height of each residential floor specified by the corresponding blueprint. The sum of the heights of the ground floors of all blueprints is at most $2 \\cdot 10^5$.\n", "outputFormat": "Output a single line with the uppercase letter \"Y\" if there exists a fair distribution of the blueprints, and the uppercase letter \"N\" otherwise.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 LAC] Fair Distribution", "background": "", "description": "An entrepreneur has $N$ blueprints, each describing a type of building. Each blueprint specifies the building’s height through two integers $G$ and $R$.\n\n- $G$: Height of the ground floor. It can be zero, indicating that the building has no ground floor.\n- $R$: Height of each residential floor. Each building has at least one residential floor.\n\nThe entrepreneur wants to distribute all of these blueprints among their two children Alice and Bob. Each child will build exactly one building from each blueprint allocated to them, choosing the number of residential floors for each building.\n\nThe entrepreneur wants to avoid showing favoritism towards either child, so they are looking for a fair distribution of the blueprints. They decided that a fair distribution is one in which it is possible to construct the buildings in such a way that the sum of the heights of the buildings constructed by each child is the same. Can you tell whether a fair distribution exists?\n\nConsider the following example for $N = 3$ blueprints:\n\n1. $G = 1$ and $R = 1$ (possible heights are $2, 3, 4, \\dots$);\n2. $G = 0$ and $R = 3$ (no ground floor, possible heights are $3, 6, 9, \\dots$);\n3. $G = 2$ and $R = 1$ (possible heights are $3, 4, 5, \\dots$).\n\nIn this case a possible fair distribution is assigning the second blueprint to Alice and the rest to Bob. Even though Alice receives a single blueprint while Bob receives two, they may construct two residential floors on the first building type (height 3), two residential floors on the second (height 6), and one residential floor on the third (height 3). In this way, the sum of the heights of the buildings constructed by each child would be 6.", "inputFormat": "The first line contains an integer $N$ ($1 \\le N \\le 2 \\cdot 10^5$) indicating the number of blueprints.\n\nEach of the next $N$ lines contains two integers $G$ ($0 \\le G \\le 2 \\cdot 10^5$) and $R$ ($1 \\le R \\le 10^9$) denoting respectively the height of the ground floor and the height of each residential floor specified by the corresponding blueprint. The sum of the heights of the ground floors of all blueprints is at most $2 \\cdot 10^5$.\n", "outputFormat": "Output a single line with the uppercase letter \"Y\" if there exists a fair distribution of the blueprints, and the uppercase letter \"N\" otherwise.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 LAC] Fair Distribution", "background": "", "description": "一位企业家有 $N$ 份蓝图，每份描述了一种建筑类型。每份蓝图通过两个整数 $G$ 和 $R$ 来规定建筑的高度。\n\n- $G$：底层的高度。它可以为零，表示该建筑没有底层。\n- $R$：每个住宅层的高度。每栋建筑至少有一个住宅层。\n\n这位企业家希望将这些蓝图全部分配给他的两个孩子 Alice 和 Bob。每个孩子将为分配给他们的每份蓝图建造恰好一栋建筑，并可以为每栋建筑选择住宅层的数量。\n\n企业家希望避免对任一孩子表现出偏袒，因此他正在寻找一种公平的蓝图分配方案。他决定，一种公平的分配方案是指：能够以某种方式建造建筑，使得每个孩子建造的建筑高度之和相同。你能判断是否存在这样的公平分配吗？\n\n考虑以下 $N = 3$ 份蓝图的例子：\n\n1. $G = 1$ 和 $R = 1$（可能的高度为 $2, 3, 4, \\dots$）；\n2. $G = 0$ 和 $R = 3$（没有底层，可能的高度为 $3, 6, 9, \\dots$）；\n3. $G = 2$ 和 $R = 1$（可能的高度为 $3, 4, 5, \\dots$）。\n\n在这种情况下，一种可能的公平分配方案是将第二份蓝图分配给 Alice，其余分配给 Bob。尽管 Alice 只收到一份蓝图而 Bob 收到两份，但他们可以在第一类建筑上建造两个住宅层（高度为 3），在第二类建筑上建造两个住宅层（高度为 6），在第三类建筑上建造一个住宅层（高度为 3）。这样，每个孩子建造的建筑高度之和都将为 6。", "inputFormat": "第一行包含一个整数 $N$（$1 \\le N \\le 2 \\cdot 10^5$），表示蓝图的数量。\n\n接下来的 $N$ 行，每行包含两个整数 $G$（$0 \\le G \\le 2 \\cdot 10^5$）和 $R$（$1 \\le R \\le 10^9$），分别表示对应蓝图规定的底层高度和每个住宅层的高度。所有蓝图的底层高度之和不超过 $2 \\cdot 10^5$。\n", "outputFormat": "输出一行，如果存在一种公平的蓝图分配方案，则输出大写字母 \"Y\"，否则输出大写字母 \"N\"。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P15121", "type": "P", "difficulty": 5, "samples": [["3\n1 1 1", "3.5"], ["3\n1 1 2", "3.6666666667"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "Special Judge", "ICPC"], "title": "[ICPC 2024 LAC] Greek Casino", "background": "", "description": "Since the early civilizations, humankind has enjoyed games of chance. Even the ingenious Greeks, known for their groundbreaking concept of the least common multiple (LCM), couldn’t resist a good gamble.\n\nInspired by this mathematical marvel, folks in Athens devised a unique betting system: after purchasing a ticket, a participant would receive a random number of coins. To determine this number, there are $N \\ge 3$ ordered slots numbered from 1 to $N$. A token is initially placed at slot 1, and the following steps are repeated:\n\n- Let $x$ be the number of the slot where the token is currently located.\n- Generate a random integer $y$ between 1 and $N$, and compute $z$ the LCM of $x$ and $y$.\n- If $z > N$, the procedure ends.\n- Otherwise, the token is moved to slot $z$, and the participant receives one coin.\n\nAs it is well known, the house always wins: the casino employs a particular probability distribution for generating random integers, so as to ensure a profitable outcome.\n\nThe casino owner is constantly seeking to optimize the betting system’s profitability. You, an AI designed to aid in such tasks, are given $N$ and the probability distribution. Determine the expected total number of coins awarded to a participant.", "inputFormat": "The first line contains an integer $N$ ($3 \\le N \\le 10^5$) indicating the number of slots.\n\nThe second line contains $N$ integers $W_1, W_2, \\dots, W_N$ ($1 \\le W_i \\le 1000$ for $i = 1, 2, \\dots, N$), representing that the probability of generating $i$ is $W_i / \\left(\\sum_j W_j\\right)$, that is, the probability of generating $i$ is the relative weight of $W_i$ with respect to the sum of the whole list $W_1, W_2, \\dots, W_N$.\n", "outputFormat": "Output a single line with the expected total number of coins awarded to a participant. The output must have an absolute or relative error of at most $10^{-9}$. It can be proven that the procedure described in the statement ends within a finite number of iterations with probability 1, and that the expected total number of coins is indeed finite.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 LAC] Greek Casino", "background": "", "description": "Since the early civilizations, humankind has enjoyed games of chance. Even the ingenious Greeks, known for their groundbreaking concept of the least common multiple (LCM), couldn’t resist a good gamble.\n\nInspired by this mathematical marvel, folks in Athens devised a unique betting system: after purchasing a ticket, a participant would receive a random number of coins. To determine this number, there are $N \\ge 3$ ordered slots numbered from 1 to $N$. A token is initially placed at slot 1, and the following steps are repeated:\n\n- Let $x$ be the number of the slot where the token is currently located.\n- Generate a random integer $y$ between 1 and $N$, and compute $z$ the LCM of $x$ and $y$.\n- If $z > N$, the procedure ends.\n- Otherwise, the token is moved to slot $z$, and the participant receives one coin.\n\nAs it is well known, the house always wins: the casino employs a particular probability distribution for generating random integers, so as to ensure a profitable outcome.\n\nThe casino owner is constantly seeking to optimize the betting system’s profitability. You, an AI designed to aid in such tasks, are given $N$ and the probability distribution. Determine the expected total number of coins awarded to a participant.", "inputFormat": "The first line contains an integer $N$ ($3 \\le N \\le 10^5$) indicating the number of slots.\n\nThe second line contains $N$ integers $W_1, W_2, \\dots, W_N$ ($1 \\le W_i \\le 1000$ for $i = 1, 2, \\dots, N$), representing that the probability of generating $i$ is $W_i / \\left(\\sum_j W_j\\right)$, that is, the probability of generating $i$ is the relative weight of $W_i$ with respect to the sum of the whole list $W_1, W_2, \\dots, W_N$.\n", "outputFormat": "Output a single line with the expected total number of coins awarded to a participant. The output must have an absolute or relative error of at most $10^{-9}$. It can be proven that the procedure described in the statement ends within a finite number of iterations with probability 1, and that the expected total number of coins is indeed finite.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 LAC] Greek Casino", "background": "", "description": "自早期文明以来，人类就一直热衷于碰运气的游戏。即便是以开创性概念“最小公倍数”（LCM）闻名的智慧古希腊人，也无法抗拒一场好的赌博。\n\n受这一数学奇观的启发，雅典的人们设计了一套独特的博彩系统：参与者购买一张票后，会获得随机数量的硬币。为了确定这个数量，设有 $N \\ge 3$ 个有序的槽位，编号从 1 到 $N$。一开始，一个令牌被放置在槽位 1，然后重复以下步骤：\n\n- 令 $x$ 为令牌当前所在槽位的编号。\n- 生成一个介于 1 和 $N$ 之间的随机整数 $y$，并计算 $x$ 和 $y$ 的 LCM，记为 $z$。\n- 如果 $z > N$，则过程结束。\n- 否则，令牌移动到槽位 $z$，并且参与者获得一枚硬币。\n\n众所周知，庄家总是赢家：赌场采用一种特定的概率分布来生成随机整数，以确保有利可图的结果。\n\n赌场老板不断寻求优化博彩系统的盈利能力。你是一个旨在协助此类任务的人工智能，现给定 $N$ 和概率分布。请确定参与者获得的硬币总数的期望值。", "inputFormat": "第一行包含一个整数 $N$（$3 \\le N \\le 10^5$），表示槽位的数量。\n\n第二行包含 $N$ 个整数 $W_1, W_2, \\dots, W_N$（对于 $i = 1, 2, \\dots, N$，有 $1 \\le W_i \\le 1000$），表示生成 $i$ 的概率为 $W_i / \\left(\\sum_j W_j\\right)$，即生成 $i$ 的概率是 $W_i$ 相对于整个列表 $W_1, W_2, \\dots, W_N$ 之和的相对权重。", "outputFormat": "输出一行，表示参与者获得的硬币总数的期望值。输出的绝对误差或相对误差不得超过 $10^{-9}$。可以证明，题目描述的过程会在有限次迭代内以概率 1 结束，并且硬币总数的期望值确实是有限的。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P15122", "type": "P", "difficulty": 6, "samples": [["pda\n2\nR 2\nL 2", "1"], ["aaa\n4\nR 1\nI\nI\nR 1", "10"], ["caso\n6\nL 1\nI\nI\nR 1\nI\nI", "4"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "ICPC"], "title": "[ICPC 2024 LAC] Harmonic Operations", "background": "", "description": "In this problem we consider three types of operations that can be applied to any 0-based string $t$ of length $|t| \\ge 2$.\n\n- $I(t)$: Reverses $t$.\n- $R(t, D)$: Rotates $t$ to the right $D$ positions, for some positive integer $D < |t|$. That is, for each $0 \\le i < |t|$, the character at position $(i + D) \\bmod |t|$ in $R(t, D)$ is the character at position $i$ in $t$.\n- $L(t, D)$: Analogous to $R(t, D)$, but rotates $t$ to the left instead of to the right.\n\nFor example, $I(\\text{“pda”}) = \\text{“adp”}$, $R(\\text{“pda”}, 2) = \\text{“dap”}$, and $L(\\text{“pda”}, 2) = \\text{“apd”}$. Note that for any $t$ and any $D$ it holds that $|I(t)| = |R(t, D)| = |L(t, D)| = |t|$.\n\nWhen a list of the above operations is applied to a string, it is done sequentially in list order. That is, the first operation of the list is applied to the original string, the second operation is applied to the result after having applied the first operation, the third operation is applied to the result after having applied the first two operations, and so on.\n\nYou are given a string $S$ consisting of lowercase letters, and a list of $K$ operations $F_1, F_2, \\dots, F_K$. Your task is to find out how many pairs of indices $(i, j)$ there are such that $1 \\le i \\le j \\le K$, and applying the sublist of operations $F_i, F_{i+1}, \\dots, F_j$ to $S$ yields $S$ as the final result.\n\nConsider for instance $S = \\text{“pda”}$, $K = 2$, $F_1 = R(t, 2)$ and $F_2 = L(t, 2)$. The result of applying the sublist $F_1$ to $S$ is $R(\\text{“pda”}, 2) = \\text{“dap”}$, which is different from $S$. The result of applying the sublist $F_1, F_2$ to $S$ is $L(R(\\text{“pda”}, 2), 2) = L(\\text{“dap”}, 2) = \\text{“pda”} = S$. Finally, the result of applying the sublist $F_2$ to $S$ is $L(\\text{“pda”}, 2) = \\text{“apd”}$, which is different from $S$. Thus, in this example the answer is 1.", "inputFormat": "The first line contains a string $S$ ($2 \\le |S| \\le 2 \\cdot 10^5$) which is made up of lowercase letters.\n\nThe second line contains an integer $K$ ($1 \\le K \\le 2 \\cdot 10^5$) indicating the number of operations in the list of operations that is being considered.\n\nOperations are described in the next $K$ lines, in the order they appear in the list, one operation per line. If the operation is $I(t)$, the line contains the uppercase letter “I”. If the operation is $R(t, D)$, the line contains the uppercase letter “R” and the integer $D$ ($1 \\le D < |S|$). Finally, if the operation is $L(t, D)$, the line contains the uppercase letter “L” and the integer $D$ ($1 \\le D < |S|$).", "outputFormat": "Output a single line with an integer indicating the requested number of pairs.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 LAC] Harmonic Operations", "background": "", "description": "In this problem we consider three types of operations that can be applied to any 0-based string $t$ of length $|t| \\ge 2$.\n\n- $I(t)$: Reverses $t$.\n- $R(t, D)$: Rotates $t$ to the right $D$ positions, for some positive integer $D < |t|$. That is, for each $0 \\le i < |t|$, the character at position $(i + D) \\bmod |t|$ in $R(t, D)$ is the character at position $i$ in $t$.\n- $L(t, D)$: Analogous to $R(t, D)$, but rotates $t$ to the left instead of to the right.\n\nFor example, $I(\\text{“pda”}) = \\text{“adp”}$, $R(\\text{“pda”}, 2) = \\text{“dap”}$, and $L(\\text{“pda”}, 2) = \\text{“apd”}$. Note that for any $t$ and any $D$ it holds that $|I(t)| = |R(t, D)| = |L(t, D)| = |t|$.\n\nWhen a list of the above operations is applied to a string, it is done sequentially in list order. That is, the first operation of the list is applied to the original string, the second operation is applied to the result after having applied the first operation, the third operation is applied to the result after having applied the first two operations, and so on.\n\nYou are given a string $S$ consisting of lowercase letters, and a list of $K$ operations $F_1, F_2, \\dots, F_K$. Your task is to find out how many pairs of indices $(i, j)$ there are such that $1 \\le i \\le j \\le K$, and applying the sublist of operations $F_i, F_{i+1}, \\dots, F_j$ to $S$ yields $S$ as the final result.\n\nConsider for instance $S = \\text{“pda”}$, $K = 2$, $F_1 = R(t, 2)$ and $F_2 = L(t, 2)$. The result of applying the sublist $F_1$ to $S$ is $R(\\text{“pda”}, 2) = \\text{“dap”}$, which is different from $S$. The result of applying the sublist $F_1, F_2$ to $S$ is $L(R(\\text{“pda”}, 2), 2) = L(\\text{“dap”}, 2) = \\text{“pda”} = S$. Finally, the result of applying the sublist $F_2$ to $S$ is $L(\\text{“pda”}, 2) = \\text{“apd”}$, which is different from $S$. Thus, in this example the answer is 1.", "inputFormat": "The first line contains a string $S$ ($2 \\le |S| \\le 2 \\cdot 10^5$) which is made up of lowercase letters.\n\nThe second line contains an integer $K$ ($1 \\le K \\le 2 \\cdot 10^5$) indicating the number of operations in the list of operations that is being considered.\n\nOperations are described in the next $K$ lines, in the order they appear in the list, one operation per line. If the operation is $I(t)$, the line contains the uppercase letter “I”. If the operation is $R(t, D)$, the line contains the uppercase letter “R” and the integer $D$ ($1 \\le D < |S|$). Finally, if the operation is $L(t, D)$, the line contains the uppercase letter “L” and the integer $D$ ($1 \\le D < |S|$).", "outputFormat": "Output a single line with an integer indicating the requested number of pairs.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 LAC] Harmonic Operations", "background": "", "description": "在这个问题中，我们考虑三种可以应用于任何长度 $|t| \\ge 2$ 的基于 0 起始的字符串 $t$ 的操作。\n\n- $I(t)$：反转 $t$。\n- $R(t, D)$：将 $t$ 向右循环移位 $D$ 个位置，其中 $D$ 是一个小于 $|t|$ 的正整数。也就是说，对于每个 $0 \\le i < |t|$，$R(t, D)$ 中位置 $(i + D) \\bmod |t|$ 的字符是 $t$ 中位置 $i$ 的字符。\n- $L(t, D)$：与 $R(t, D)$ 类似，但将 $t$ 向左循环移位而不是向右。\n\n例如，$I(\\text{\"pda\"}) = \\text{\"adp\"}$，$R(\\text{\"pda\"}, 2) = \\text{\"dap\"}$，以及 $L(\\text{\"pda\"}, 2) = \\text{\"apd\"}$。注意对于任意 $t$ 和任意 $D$，都有 $|I(t)| = |R(t, D)| = |L(t, D)| = |t|$。\n\n当一系列上述操作应用于一个字符串时，它们按照列表顺序依次执行。也就是说，列表中的第一个操作应用于原始字符串，第二个操作应用于执行第一个操作后的结果，第三个操作应用于执行前两个操作后的结果，依此类推。\n\n给定一个由小写字母组成的字符串 $S$，以及一个包含 $K$ 个操作的列表 $F_1, F_2, \\dots, F_K$。你的任务是找出有多少对索引 $(i, j)$，满足 $1 \\le i \\le j \\le K$，并且将操作子列表 $F_i, F_{i+1}, \\dots, F_j$ 应用于 $S$ 后，最终结果等于 $S$。\n\n例如，考虑 $S = \\text{\"pda\"}$，$K = 2$，$F_1 = R(t, 2)$ 和 $F_2 = L(t, 2)$。将子列表 $F_1$ 应用于 $S$ 的结果是 $R(\\text{\"pda\"}, 2) = \\text{\"dap\"}$，它与 $S$ 不同。将子列表 $F_1, F_2$ 应用于 $S$ 的结果是 $L(R(\\text{\"pda\"}, 2), 2) = L(\\text{\"dap\"}, 2) = \\text{\"pda\"} = S$。最后，将子列表 $F_2$ 应用于 $S$ 的结果是 $L(\\text{\"pda\"}, 2) = \\text{\"apd\"}$，它与 $S$ 不同。因此，在这个例子中，答案是 1。", "inputFormat": "第一行包含一个字符串 $S$（$2 \\le |S| \\le 2 \\cdot 10^5$），由小写字母组成。\n\n第二行包含一个整数 $K$（$1 \\le K \\le 2 \\cdot 10^5$），表示正在考虑的操作列表中的操作数量。\n\n接下来的 $K$ 行按列表中的顺序描述操作，每行一个操作。如果操作是 $I(t)$，则该行包含大写字母 \"I\"。如果操作是 $R(t, D)$，则该行包含大写字母 \"R\" 和整数 $D$（$1 \\le D < |S|$）。最后，如果操作是 $L(t, D)$，则该行包含大写字母 \"L\" 和整数 $D$（$1 \\le D < |S|$）。", "outputFormat": "输出一行一个整数，表示所求的对数。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P15123", "type": "P", "difficulty": 6, "samples": [["4 1000\n-1000 0\n0 0\n1000 0\n0 -1000", "2000000"], ["2 100\n17 7\n19 90", "4849.704644437563740570981348"], ["1 100\n13 37", "0.0"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "Special Judge", "ICPC"], "title": "[ICPC 2024 LAC] Insects, Mathematics, Accuracy, and Efficiency", "background": "", "description": "Bog has three passions in life: insects, mathematics, accuracy, and efficiency. His last passion led him to wanting to merge the first two, so Bog decided to adopt a differential grasshopper, an adorable little green guy that he named Dydx.\n\nIn order to keep Dydx happy, Bog made him a little lair. He bought a sprinkler that could water any plant within a circle with radius $R$, and planted $N$ crops within this circle.\n\nDydx really liked his new home! But Bog realized that the grasshopper would only stay within the area defined by the smallest convex polygon that encloses all crops. Now he regrets not having spread the crops out more. Fortunately, Bog managed to find one last crop he hadn’t planted yet. Bog wants your help to maximize the area Dydx can inhabit by planting his last crop within the sprinkler’s range.\n", "inputFormat": "The first line contains two integers $N$ and $R$ ($1 \\le N, R \\le 10^4$), indicating respectively the number of planted crops and the radius of the circle defined by the sprinkler. Crops are represented as points in the two-dimensional plane, where $(0, 0)$ are the coordinates of the sprinkler.\n\nEach of the next $N$ lines describes a crop with two integers $X$ and $Y$, indicating that the crop is planted at coordinates $(X, Y)$. The Euclidean distance from $(X, Y)$ to $(0, 0)$ is at most $R$. No two crops have the same location.\n", "outputFormat": "Output a single line with the maximum area of the region Dydx can inhabit after planting one more crop within the range of the sprinkler. The output must have an absolute or relative error of at most $10^{-9}$. Notice that the added crop does not need to have integer coordinates.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 LAC] Insects, Mathematics, Accuracy, and Efficiency", "background": "", "description": "Bog has three passions in life: insects, mathematics, accuracy, and efficiency. His last passion led him to wanting to merge the first two, so Bog decided to adopt a differential grasshopper, an adorable little green guy that he named Dydx.\n\nIn order to keep Dydx happy, Bog made him a little lair. He bought a sprinkler that could water any plant within a circle with radius $R$, and planted $N$ crops within this circle.\n\nDydx really liked his new home! But Bog realized that the grasshopper would only stay within the area defined by the smallest convex polygon that encloses all crops. Now he regrets not having spread the crops out more. Fortunately, Bog managed to find one last crop he hadn’t planted yet. Bog wants your help to maximize the area Dydx can inhabit by planting his last crop within the sprinkler’s range.\n", "inputFormat": "The first line contains two integers $N$ and $R$ ($1 \\le N, R \\le 10^4$), indicating respectively the number of planted crops and the radius of the circle defined by the sprinkler. Crops are represented as points in the two-dimensional plane, where $(0, 0)$ are the coordinates of the sprinkler.\n\nEach of the next $N$ lines describes a crop with two integers $X$ and $Y$, indicating that the crop is planted at coordinates $(X, Y)$. The Euclidean distance from $(X, Y)$ to $(0, 0)$ is at most $R$. No two crops have the same location.\n", "outputFormat": "Output a single line with the maximum area of the region Dydx can inhabit after planting one more crop within the range of the sprinkler. The output must have an absolute or relative error of at most $10^{-9}$. Notice that the added crop does not need to have integer coordinates.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 LAC] Insects, Mathematics, Accuracy, and Efficiency", "background": "", "description": "Bog 人生中有三大爱好：昆虫、数学、精确和效率。他的最后一个爱好促使他想把前两者结合起来，于是 Bog 决定收养一只差分蚱蜢，一个可爱的小绿家伙，他给它取名为 Dydx。\n\n为了让 Dydx 开心，Bog 为它打造了一个小巢穴。他购买了一个洒水器，可以灌溉半径为 $R$ 的圆形区域内的任何植物，并在这个圆形内种植了 $N$ 株作物。\n\nDydx 非常喜欢它的新家！但 Bog 意识到，蚱蜢只会待在包围所有作物的最小凸多边形所定义的区域内。现在他后悔没有把作物种植得更分散一些。幸运的是，Bog 设法找到了他尚未种植的最后一株作物。Bog 希望你能帮助他，通过在洒水器范围内种植最后一株作物，来最大化 Dydx 可以栖息区域的面积。", "inputFormat": "第一行包含两个整数 $N$ 和 $R$（$1 \\le N, R \\le 10^4$），分别表示已种植作物的数量和洒水器定义的圆的半径。作物在二维平面中表示为点，其中 $(0, 0)$ 是洒水器的坐标。\n\n接下来的 $N$ 行，每行描述一株作物，包含两个整数 $X$ 和 $Y$，表示该作物种植在坐标 $(X, Y)$ 处。从 $(X, Y)$ 到 $(0, 0)$ 的欧几里得距离不超过 $R$。没有两株作物位于同一位置。", "outputFormat": "输出一行，表示在洒水器范围内再种植一株作物后，Dydx 可以栖息区域的最大面积。输出的绝对误差或相对误差不得超过 $10^{-9}$。注意，新增的作物不需要具有整数坐标。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P15124", "type": "P", "difficulty": 5, "samples": [["2\n1 2 4 1\n2 1 3 4", "17.5"], ["3\n1 1 2 1\n2 1 1 1\n1 1 1 1", "6"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "Special Judge", "ICPC"], "title": "[ICPC 2024 LAC] Joys of Trading", "background": "", "description": "Apolyanka and Büdelsdorf are two small neolithic villages that have recently come into contact. There are $N$ resources, numbered from 1 to $N$, and each village is capable of independently producing any of them, albeit with different efficiencies. In order to produce one unit of resource $i$, Apolyanka needs $A_i$ person-hours, while Büdelsdorf needs $B_i$ person-hours. Currently Apolyanka is producing $U_i$ units of resource $i$ in each given time period, while Büdelsdorf is producing $W_i$ units.\n\nEach village is currently working at maximum capacity, that is, there is no way they can put more person-hours to work than they are employing now. However, through the recently discovered benefits of trade, it is possible for both villages to produce all the resources they need while reducing the total person-hours worked, and thus becoming able to spend those freed person-hours resting and playing some games. All that is needed is that the villages cooperate, coordinate and exchange resources among them.\n\nFor example, suppose $N = 2$, resource 1 is wood, resource 2 is food, $A_1 = 1$, $U_1 = 2$, $B_1 = 4$, $W_1 = 1$, $A_2 = 2$, $U_2 = 1$, $B_2 = 3$, and $W_2 = 4$. Then Apolyanka is doing 4 person-hours of work: $A_1 \\cdot U_1 = 2$ for producing $U_1 = 2$ units of wood, and $A_2 \\cdot U_2 = 2$ for producing $U_2 = 1$ unit of food. Similarly, Büdelsdorf is doing 16 person-hours of work: $B_1 \\cdot W_1 = 4$ for producing $W_1 = 1$ unit of wood, and $B_2 \\cdot W_2 = 12$ for producing $W_2 = 4$ units of food. Thus, the total production is $U_1 + W_1 = 3$ units of wood and $U_2 + W_2 = 5$ units of food, requiring $4 + 16 = 20$ person-hours.\n\nHowever, a better organization is possible: Apolyanka could produce 3 units of wood and 0.5 units of food, while Büdelsdorf could produce no wood and 4.5 units of food. The total production of each resource would be the same, but requiring only $3A_1 + 0.5A_2 + 0B_1 + 4.5B_2 = 3 + 1 + 13.5 = 17.5$ person-hours.\n\nAnother example with $N = 3$ is $A_1 = 1$, $B_1 = 2$, $A_2 = 2$, $B_2 = 1$, $A_3 = 1$, $B_3 = 1$, and $U_i = W_i = 1$ for $i = 1, 2, 3$. In this case, each village is currently working 4 person-hours. With a slight reorganization however, they can each work 3 person-hours while producing the exact same total resources! All that is required is for Apolyanka to produce one less unit of resource 2 and one more of resource 1, while Büdelsdorf does the opposite.\n\nGiven all of these values, can you compute what is the minimum total number of person-hours that the villages have to work, in order to produce exactly the same total resources? Note that the number of person-hours invested in producing a resource is not required to be integer.", "inputFormat": "The first line contains an integer $N$ ($1 \\le N \\le 10^5$) indicating the number of resources. Each resource is identified by a distinct integer from 1 to $N$.\n\nThe $i$-th of the next $N$ lines describes resource $i$ with four integers $A_i$, $U_i$, $B_i$ and $W_i$ ($1 \\le A_i, U_i, B_i, W_i \\le 1000$ for $i = 1, 2, \\dots, N$), as explained in the statement.\n", "outputFormat": "Output a single line with the minimum total number of person-hours required to produce the resources. The output must have an absolute or relative error of at most $10^{-9}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 LAC] Joys of Trading", "background": "", "description": "Apolyanka and Büdelsdorf are two small neolithic villages that have recently come into contact. There are $N$ resources, numbered from 1 to $N$, and each village is capable of independently producing any of them, albeit with different efficiencies. In order to produce one unit of resource $i$, Apolyanka needs $A_i$ person-hours, while Büdelsdorf needs $B_i$ person-hours. Currently Apolyanka is producing $U_i$ units of resource $i$ in each given time period, while Büdelsdorf is producing $W_i$ units.\n\nEach village is currently working at maximum capacity, that is, there is no way they can put more person-hours to work than they are employing now. However, through the recently discovered benefits of trade, it is possible for both villages to produce all the resources they need while reducing the total person-hours worked, and thus becoming able to spend those freed person-hours resting and playing some games. All that is needed is that the villages cooperate, coordinate and exchange resources among them.\n\nFor example, suppose $N = 2$, resource 1 is wood, resource 2 is food, $A_1 = 1$, $U_1 = 2$, $B_1 = 4$, $W_1 = 1$, $A_2 = 2$, $U_2 = 1$, $B_2 = 3$, and $W_2 = 4$. Then Apolyanka is doing 4 person-hours of work: $A_1 \\cdot U_1 = 2$ for producing $U_1 = 2$ units of wood, and $A_2 \\cdot U_2 = 2$ for producing $U_2 = 1$ unit of food. Similarly, Büdelsdorf is doing 16 person-hours of work: $B_1 \\cdot W_1 = 4$ for producing $W_1 = 1$ unit of wood, and $B_2 \\cdot W_2 = 12$ for producing $W_2 = 4$ units of food. Thus, the total production is $U_1 + W_1 = 3$ units of wood and $U_2 + W_2 = 5$ units of food, requiring $4 + 16 = 20$ person-hours.\n\nHowever, a better organization is possible: Apolyanka could produce 3 units of wood and 0.5 units of food, while Büdelsdorf could produce no wood and 4.5 units of food. The total production of each resource would be the same, but requiring only $3A_1 + 0.5A_2 + 0B_1 + 4.5B_2 = 3 + 1 + 13.5 = 17.5$ person-hours.\n\nAnother example with $N = 3$ is $A_1 = 1$, $B_1 = 2$, $A_2 = 2$, $B_2 = 1$, $A_3 = 1$, $B_3 = 1$, and $U_i = W_i = 1$ for $i = 1, 2, 3$. In this case, each village is currently working 4 person-hours. With a slight reorganization however, they can each work 3 person-hours while producing the exact same total resources! All that is required is for Apolyanka to produce one less unit of resource 2 and one more of resource 1, while Büdelsdorf does the opposite.\n\nGiven all of these values, can you compute what is the minimum total number of person-hours that the villages have to work, in order to produce exactly the same total resources? Note that the number of person-hours invested in producing a resource is not required to be integer.", "inputFormat": "The first line contains an integer $N$ ($1 \\le N \\le 10^5$) indicating the number of resources. Each resource is identified by a distinct integer from 1 to $N$.\n\nThe $i$-th of the next $N$ lines describes resource $i$ with four integers $A_i$, $U_i$, $B_i$ and $W_i$ ($1 \\le A_i, U_i, B_i, W_i \\le 1000$ for $i = 1, 2, \\dots, N$), as explained in the statement.\n", "outputFormat": "Output a single line with the minimum total number of person-hours required to produce the resources. The output must have an absolute or relative error of at most $10^{-9}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 LAC] Joys of Trading", "background": "", "description": "Apolyanka 和 Büdelsdorf 是两个最近才开始接触的新石器时代小村庄。有 $N$ 种资源，编号从 1 到 $N$，每个村庄都能独立生产其中任何一种，但效率不同。为了生产一单位资源 $i$，Apolyanka 需要 $A_i$ 人时，而 Büdelsdorf 需要 $B_i$ 人时。目前，在每个给定的时间段内，Apolyanka 生产 $U_i$ 单位资源 $i$，而 Büdelsdorf 生产 $W_i$ 单位。\n\n每个村庄目前都在以最大产能工作，也就是说，他们无法投入比现在更多的人时。然而，通过最近发现的贸易优势，两个村庄有可能在减少总人时工作量的同时，生产出他们所需的所有资源，从而能够将这些节省下来的人时用于休息和玩一些游戏。所需要的就是村庄之间合作、协调并交换资源。\n\n例如，假设 $N = 2$，资源 1 是木材，资源 2 是食物，$A_1 = 1$，$U_1 = 2$，$B_1 = 4$，$W_1 = 1$，$A_2 = 2$，$U_2 = 1$，$B_2 = 3$，$W_2 = 4$。那么 Apolyanka 正在做 4 人时的工作：生产 $U_1 = 2$ 单位木材需要 $A_1 \\cdot U_1 = 2$，生产 $U_2 = 1$ 单位食物需要 $A_2 \\cdot U_2 = 2$。类似地，Büdelsdorf 正在做 16 人时的工作：生产 $W_1 = 1$ 单位木材需要 $B_1 \\cdot W_1 = 4$，生产 $W_2 = 4$ 单位食物需要 $B_2 \\cdot W_2 = 12$。因此，总产量为 $U_1 + W_1 = 3$ 单位木材和 $U_2 + W_2 = 5$ 单位食物，需要 $4 + 16 = 20$ 人时。\n\n然而，可以有一种更好的组织方式：Apolyanka 可以生产 3 单位木材和 0.5 单位食物，而 Büdelsdorf 可以不生产木材，生产 4.5 单位食物。每种资源的总产量将相同，但仅需要 $3A_1 + 0.5A_2 + 0B_1 + 4.5B_2 = 3 + 1 + 13.5 = 17.5$ 人时。\n\n另一个 $N = 3$ 的例子是 $A_1 = 1$，$B_1 = 2$，$A_2 = 2$，$B_2 = 1$，$A_3 = 1$，$B_3 = 1$，且对于 $i = 1, 2, 3$，$U_i = W_i = 1$。在这种情况下，每个村庄目前都在工作 4 人时。然而，通过稍微调整，他们可以在生产完全相同的总资源的同时，每个只工作 3 人时！只需要 Apolyanka 少生产一单位资源 2，多生产一单位资源 1，而 Büdelsdorf 则相反。\n\n给定所有这些值，你能计算出村庄为了生产完全相同总资源而必须工作的最小总人时数吗？请注意，生产一种资源所投入的人时数不必是整数。", "inputFormat": "第一行包含一个整数 $N$（$1 \\le N \\le 10^5$），表示资源的数量。每种资源由 $1$ 到 $N$ 之间的一个不同整数标识。\n\n接下来的 $N$ 行中的第 $i$ 行描述资源 $i$，包含四个整数 $A_i$、$U_i$、$B_i$ 和 $W_i$（对于 $i = 1, 2, \\dots, N$，有 $1 \\le A_i, U_i, B_i, W_i \\le 1000$），如题目描述中所述。", "outputFormat": "输出一行，表示生产这些资源所需的最小总人时数。输出的绝对误差或相对误差不得超过 $10^{-9}$。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P15125", "type": "P", "difficulty": 3, "samples": [["3\nKNUTH\nMORRIS\nPRATT", "4"], ["3\nKNUTH\nM\nPRATT", "5"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "ICPC"], "title": "[ICPC 2024 LAC] KMOP", "background": "", "description": "You probably know the KMP algorithm. You may also know that “KMP” is an acronym that stands for “Knuth Morris Pratt”, who jointly published the algorithm in 1977. How do you pronounce “KMP”? Of course, you can just say “Knuth Morris Pratt”, but what about pronouncing the acronym itself? Since “KMP” is not a pronounceable word, you are forced to say the letters one by one. In this problem we are interested in pronounceable acronyms.\n\nWe need a few definitions to formalize the requirement. A phrase is a list of words and a word is a sequence of letters. Each letter is either a vowel or a consonant. Deciding whether a letter is a vowel or a consonant depends on the language and other elements. For simplicity, we say that the six letters “A”, “E”, “I”, “O”, “U” and “Y” are vowels, while all the rest are consonants. Although it is debatable whether a given word is pronounceable, we say that a word is pronounceable when it does not contain more than two contiguous consonants. For instance, “LEMPEL” is a pronounceable word, while “DIJKSTRA” is not.\n\nGiven a phrase composed of $N$ words, an acronym for the phrase is the concatenation of $N$ prefixes, one prefix for each word, in the order they appear in the phrase. Each prefix must have at least one and at most three letters. Your task is to determine the minimum length a pronounceable acronym can have.\n\nAs an example with $N = 3$ consider the phrase “KNUTH MORRIS PRATT”. There are 27 possible acronyms for this phrase, such as “KMP”, “KMPR”, “KMPRA”, “KMOP”, “KMOPR” and “KNUMOPRA”, among others. Some of these acronyms are pronounceable (“KMOP” and “KMOPR”), while some others not (“KMP”, “KMPR”, “KMPRA” and “KNUMOPRA”). Since the only three-letter acronym “KMP” is not pronounceable, it follows that “KMOP” is a minimum-length pronounceable acronym for the phrase.", "inputFormat": "The first line contains a positive integer $N$ indicating the number of words in the phrase.\n\nEach of the next $N$ lines contains a non-empty string made of uppercase letters representing a word in the phrase. Words are given in the order they appear in the phrase. The sum of the lengths of all the strings is at most $10^6$.\n", "outputFormat": "Output a single line with an integer indicating the minimum length a pronounceable acronym can have, or the character “*” (asterisk) if no pronounceable acronym exists for the phrase.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 LAC] KMOP", "background": "", "description": "You probably know the KMP algorithm. You may also know that “KMP” is an acronym that stands for “Knuth Morris Pratt”, who jointly published the algorithm in 1977. How do you pronounce “KMP”? Of course, you can just say “Knuth Morris Pratt”, but what about pronouncing the acronym itself? Since “KMP” is not a pronounceable word, you are forced to say the letters one by one. In this problem we are interested in pronounceable acronyms.\n\nWe need a few definitions to formalize the requirement. A phrase is a list of words and a word is a sequence of letters. Each letter is either a vowel or a consonant. Deciding whether a letter is a vowel or a consonant depends on the language and other elements. For simplicity, we say that the six letters “A”, “E”, “I”, “O”, “U” and “Y” are vowels, while all the rest are consonants. Although it is debatable whether a given word is pronounceable, we say that a word is pronounceable when it does not contain more than two contiguous consonants. For instance, “LEMPEL” is a pronounceable word, while “DIJKSTRA” is not.\n\nGiven a phrase composed of $N$ words, an acronym for the phrase is the concatenation of $N$ prefixes, one prefix for each word, in the order they appear in the phrase. Each prefix must have at least one and at most three letters. Your task is to determine the minimum length a pronounceable acronym can have.\n\nAs an example with $N = 3$ consider the phrase “KNUTH MORRIS PRATT”. There are 27 possible acronyms for this phrase, such as “KMP”, “KMPR”, “KMPRA”, “KMOP”, “KMOPR” and “KNUMOPRA”, among others. Some of these acronyms are pronounceable (“KMOP” and “KMOPR”), while some others not (“KMP”, “KMPR”, “KMPRA” and “KNUMOPRA”). Since the only three-letter acronym “KMP” is not pronounceable, it follows that “KMOP” is a minimum-length pronounceable acronym for the phrase.", "inputFormat": "The first line contains a positive integer $N$ indicating the number of words in the phrase.\n\nEach of the next $N$ lines contains a non-empty string made of uppercase letters representing a word in the phrase. Words are given in the order they appear in the phrase. The sum of the lengths of all the strings is at most $10^6$.\n", "outputFormat": "Output a single line with an integer indicating the minimum length a pronounceable acronym can have, or the character “*” (asterisk) if no pronounceable acronym exists for the phrase.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 LAC] KMOP", "background": "", "description": "你可能知道 KMP 算法。你也可能知道 “KMP” 是一个首字母缩写词，代表 “Knuth Morris Pratt”，他们于 1977 年共同发表了该算法。你如何发音 “KMP”？当然，你可以直接说 “Knuth Morris Pratt”，但发音这个缩写本身呢？由于 “KMP” 不是一个可发音的单词，你被迫逐个字母念出来。在这个问题中，我们关注的是可发音的首字母缩写词。\n\n我们需要一些定义来形式化这个要求。一个**短语**是一个单词列表，而一个**单词**是一个字母序列。每个字母要么是元音，要么是辅音。判断一个字母是元音还是辅音取决于语言和其他因素。为简单起见，我们说六个字母 “A”、“E”、“I”、“O”、“U” 和 “Y” 是元音，其余所有字母都是辅音。尽管一个给定的单词是否可发音存在争议，但我们说一个单词是**可发音的**，当它不包含超过两个连续的辅音。例如，“LEMPEL” 是一个可发音的单词，而 “DIJKSTRA” 则不是。\n\n给定一个由 $N$ 个单词组成的短语，该短语的一个**首字母缩写词**是 $N$ 个前缀的连接，每个单词一个前缀，按它们在短语中出现的顺序排列。每个前缀必须至少有一个字母，至多有三个字母。你的任务是确定一个可发音的首字母缩写词的最小长度。\n\n以 $N = 3$ 为例，考虑短语 “KNUTH MORRIS PRATT”。这个短语有 27 个可能的首字母缩写词，例如 “KMP”、“KMPR”、“KMPRA”、“KMOP”、“KMOPR” 和 “KNUMOPRA” 等。其中一些缩写词是可发音的（“KMOP” 和 “KMOPR”），而另一些则不是（“KMP”、“KMPR”、“KMPRA” 和 “KNUMOPRA”）。由于唯一的三字母缩写词 “KMP” 不可发音，因此 “KMOP” 是该短语的一个最小长度的可发音缩写词。", "inputFormat": "第一行包含一个正整数 $N$，表示短语中的单词数量。\n\n接下来的 $N$ 行，每行包含一个由大写字母组成的非空字符串，表示短语中的一个单词。单词按它们在短语中出现的顺序给出。所有字符串的长度之和不超过 $10^6$。", "outputFormat": "输出一行，包含一个整数，表示可发音的首字母缩写词的最小长度；如果短语不存在可发音的首字母缩写词，则输出字符 “*”（星号）。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P15126", "type": "P", "difficulty": 2, "samples": [["6 6 6\n****** --*---\n****** -**---\n****** ******\n****** ******\n****** -**---\n*****- --*---", "N"], ["2 4 6\n**** ------\n***- *-----", "N"], ["2 6 4\n****** ****\n*-**-* ----", "Y"], ["1 1 1\n* *", "Y"], ["1 1 1\n* -", "Y"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["模拟", "2024", "ICPC"], "title": "[ICPC 2024 LAC] LED Matrix", "background": "", "description": "A LED matrix is a two-dimensional array of LEDs that is used to display information. This is achieved by turning on the LEDs that form a desired pattern. The figure below represents a LED matrix displaying a smiling-face pattern. LEDs that are turned off are shown in white, while LEDs that are turned on appear colored.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/s8a6yarc.png)\n:::\n\nSome LED matrices scroll the pattern from right to left across the matrix, turning on just the appropriate LEDs at each step. Thus, any pattern with the same height than the matrix can be displayed, even patterns that are wider than the matrix. The pattern scrolling works as follows: Initially, all the LEDs in the matrix are turned off. The next step, the last column of the matrix displays the first column of the pattern. At each new step the pattern is moved one column to the left across the matrix, until the first column of the matrix displays the last column of the pattern. Finally, all the LEDs in the matrix are turned off again. If a LED matrix is equipped with pattern scrolling, the scrolling occurs even if the pattern is not wider than the matrix.\n\nThe picture below shows all the steps required to display a pattern of an arrow that is pointing to the left.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/x8k0zjlb.png)\n:::\n\nAstrid has just received an old LED matrix with pattern scrolling, and she thinks that some LEDs might be broken. Since broken LEDs cannot be turned on, she is worried that some patterns will not display properly. Given the description of the state of each LED, and the pattern to display, you must tell whether the appropriate LEDs can be turned on at every step of the pattern scrolling.\n", "inputFormat": "The first line contains three integers $R$, $C$ and $K$ ($1 \\le R, C, K \\le 1000$), indicating respectively the number of rows of both the LED matrix and the pattern, the number of columns of the matrix, and the number of columns of the pattern.\n\nThe next $R$ lines describe the matrix and the pattern from top to bottom. Each of these lines contains a string $M$ of length $C$ and a string $P$ of length $K$, describing respectively a row of the matrix and a row of the pattern. Each character of both $M$ and $P$ is either `*` (asterisk) or “-” (hyphen). For $M$, the character `*` indicates a good LED while the character “-” represents a broken LED. For $P$, the character `*` indicates a LED that must be turned on while the character “-” represents a LED that must be turned off.\n", "outputFormat": "Output a single line with the uppercase letter “Y” if the appropriate LEDs can be turned on at every step of the pattern scrolling, and the uppercase letter “N” otherwise.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 LAC] LED Matrix", "background": "", "description": "A LED matrix is a two-dimensional array of LEDs that is used to display information. This is achieved by turning on the LEDs that form a desired pattern. The figure below represents a LED matrix displaying a smiling-face pattern. LEDs that are turned off are shown in white, while LEDs that are turned on appear colored.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/s8a6yarc.png)\n:::\n\nSome LED matrices scroll the pattern from right to left across the matrix, turning on just the appropriate LEDs at each step. Thus, any pattern with the same height than the matrix can be displayed, even patterns that are wider than the matrix. The pattern scrolling works as follows: Initially, all the LEDs in the matrix are turned off. The next step, the last column of the matrix displays the first column of the pattern. At each new step the pattern is moved one column to the left across the matrix, until the first column of the matrix displays the last column of the pattern. Finally, all the LEDs in the matrix are turned off again. If a LED matrix is equipped with pattern scrolling, the scrolling occurs even if the pattern is not wider than the matrix.\n\nThe picture below shows all the steps required to display a pattern of an arrow that is pointing to the left.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/x8k0zjlb.png)\n:::\n\nAstrid has just received an old LED matrix with pattern scrolling, and she thinks that some LEDs might be broken. Since broken LEDs cannot be turned on, she is worried that some patterns will not display properly. Given the description of the state of each LED, and the pattern to display, you must tell whether the appropriate LEDs can be turned on at every step of the pattern scrolling.\n", "inputFormat": "The first line contains three integers $R$, $C$ and $K$ ($1 \\le R, C, K \\le 1000$), indicating respectively the number of rows of both the LED matrix and the pattern, the number of columns of the matrix, and the number of columns of the pattern.\n\nThe next $R$ lines describe the matrix and the pattern from top to bottom. Each of these lines contains a string $M$ of length $C$ and a string $P$ of length $K$, describing respectively a row of the matrix and a row of the pattern. Each character of both $M$ and $P$ is either `*` (asterisk) or “-” (hyphen). For $M$, the character `*` indicates a good LED while the character “-” represents a broken LED. For $P$, the character `*` indicates a LED that must be turned on while the character “-” represents a LED that must be turned off.\n", "outputFormat": "Output a single line with the uppercase letter “Y” if the appropriate LEDs can be turned on at every step of the pattern scrolling, and the uppercase letter “N” otherwise.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 LAC] LED Matrix", "background": "", "description": "LED 矩阵是一个由 LED 组成的二维阵列，用于显示信息。这是通过点亮形成所需图案的 LED 来实现的。下图展示了一个显示笑脸图案的 LED 矩阵。熄灭的 LED 显示为白色，而点亮的 LED 显示为彩色。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/s8a6yarc.png)\n:::\n\n一些 LED 矩阵支持图案在矩阵中从右向左滚动，每一步只点亮相应的 LED。因此，任何与矩阵高度相同的图案都可以显示，甚至包括宽度超过矩阵的图案。图案滚动的工作原理如下：初始时，矩阵中的所有 LED 都熄灭。下一步，矩阵的最后一列显示图案的第一列。在每一个新的步骤中，图案在矩阵中向左移动一列，直到矩阵的第一列显示图案的最后一列。最后，矩阵中的所有 LED 再次全部熄灭。如果一个 LED 矩阵配备了图案滚动功能，那么即使图案宽度不超过矩阵，滚动也会发生。\n\n下图展示了显示一个指向左侧的箭头图案所需的所有步骤。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/x8k0zjlb.png)\n:::\n\nAstrid 刚刚收到一个带有图案滚动功能的旧 LED 矩阵，她认为有些 LED 可能已经损坏。由于损坏的 LED 无法点亮，她担心某些图案无法正常显示。给定每个 LED 状态的描述以及要显示的图案，你需要判断在图案滚动的每一步中，是否都能点亮相应的 LED。", "inputFormat": "第一行包含三个整数 $R$、$C$ 和 $K$（$1 \\le R, C, K \\le 1000$），分别表示 LED 矩阵和图案的行数、矩阵的列数以及图案的列数。\n\n接下来的 $R$ 行从上到下描述矩阵和图案。这些行中的每一行包含一个长度为 $C$ 的字符串 $M$ 和一个长度为 $K$ 的字符串 $P$，分别描述矩阵的一行和图案的一行。$M$ 和 $P$ 中的每个字符要么是 `*`（星号），要么是 “-”（连字符）。对于 $M$，字符 `*` 表示完好的 LED，而字符 “-” 表示损坏的 LED。对于 $P$，字符 `*` 表示必须点亮的 LED，而字符 “-” 表示必须熄灭的 LED。\n", "outputFormat": "如果在图案滚动的每一步都能点亮相应的 LED，则输出一行大写字母 “Y”，否则输出大写字母 “N”。\n", "hint": "", "locale": "zh-CN"}}}
