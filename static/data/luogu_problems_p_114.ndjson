{"pid": "P3309", "type": "P", "difficulty": 6, "samples": [["6 A\nA 3 2\nQ 1 5 1 1\nA 15 14\nA 12 9\nQ 12 8 12 15\nQ 21 18 19 18", "13\n17\n17\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000]}, "tags": ["2014", "线段树", "各省省选", "山东", "向量", "凸包"], "title": "[SDOI2014] 向量集", "background": "", "description": "维护一个向量集合，在线支持以下操作：\n\n- `A x y`（$|x|,|y| \\le 10^8$）：加入向量 $(x,y)$；\n- `Q x y l r`（$|x|,|y| \\le 10^8$，$1 \\le l \\le r \\le t$，其中 $t$ 为已经加入的向量个数）：询问第 $l$ 个到第 $r$ 个加入的向量与向量 $(x,y)$ 的点积的最大值。\n\n集合初始时为空。", "inputFormat": "输入的第一行包含整数 $N(1 \\le N \\le 4 \\times 10^5)$ 和字符 $s$，分别表示操作数和数据类别；\n\n接下来 $N$ 行，每行一个操作，格式如上所述。    \n\n请注意 $s$ 不为 `E` 时，输入中的所有整数都经过了加密。你可以使用以下程序得到原始输入：\n\n```\ninline int decode(int x, long long lastans) {    \n    return x ^ (lastans & 0x7fffffff);\n}\n```\n\n其中 `x` 为程序读入的数，`lastans` 为之前最后一次询问的答案。在第一次询问之前，`lastans` 为 $0$。注：向量 $(x, y)$ 和 $(z, w)$ 的点积定义为 $xz+yw$。", "outputFormat": "对每个 `Q` 操作，输出一个整数表示答案。", "hint": "样例解释：解密之后的输入为\n```\n    6 E\n    A 3 2\n    Q 1 5 1 1\n    A 2 3\n    A 1 4\n    Q 1 5 1 2\n    Q 4 3 2 3\n```\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2014] Vector Set", "background": "", "description": "Maintain a set of vectors and support the following operations online:\n\n- `A x y` ($|x|, |y| \\le 10^8$): insert the vector $(x, y)$.\n- `Q x y l r` ($|x|, |y| \\le 10^8$, $1 \\le l \\le r \\le t$, where $t$ is the number of vectors already inserted): query the maximum dot product between the vector $(x, y)$ and each of the vectors from the $l$-th to the $r$-th inserted.\n\nInitially, the set is empty.", "inputFormat": "The first line contains an integer $N (1 \\le N \\le 4 \\times 10^5)$ and a character $s$, representing the number of operations and the data category, respectively.\n\nThen follow $N$ lines, each containing one operation in the format described above.\n\nNote that when $s$ is not `E`, all integers in the input are encrypted. You can use the following program to obtain the original input:\n```\ninline int decode(int x, long long lastans) {    \n    return x ^ (lastans & 0x7fffffff);\n}\n```\nHere, $x$ is the number read by your program, and `lastans` is the answer to the most recent previous query. Before the first query, `lastans` is $0$. Note: the dot product of vectors $(x, y)$ and $(z, w)$ is defined as $xz + yw$.", "outputFormat": "For each `Q` operation, output an integer representing the answer.", "hint": "Sample explanation: after decryption, the input is\n```\n    6 E\n    A 3 2\n    Q 1 5 1 1\n    A 2 3\n    A 1 4\n    Q 1 5 1 2\n    Q 4 3 2 3\n```\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2014] 向量集", "background": "", "description": "维护一个向量集合，在线支持以下操作：\n\n- `A x y`（$|x|,|y| \\le 10^8$）：加入向量 $(x,y)$；\n- `Q x y l r`（$|x|,|y| \\le 10^8$，$1 \\le l \\le r \\le t$，其中 $t$ 为已经加入的向量个数）：询问第 $l$ 个到第 $r$ 个加入的向量与向量 $(x,y)$ 的点积的最大值。\n\n集合初始时为空。", "inputFormat": "输入的第一行包含整数 $N(1 \\le N \\le 4 \\times 10^5)$ 和字符 $s$，分别表示操作数和数据类别；\n\n接下来 $N$ 行，每行一个操作，格式如上所述。    \n\n请注意 $s$ 不为 `E` 时，输入中的所有整数都经过了加密。你可以使用以下程序得到原始输入：\n\n```\ninline int decode(int x, long long lastans) {    \n    return x ^ (lastans & 0x7fffffff);\n}\n```\n\n其中 `x` 为程序读入的数，`lastans` 为之前最后一次询问的答案。在第一次询问之前，`lastans` 为 $0$。注：向量 $(x, y)$ 和 $(z, w)$ 的点积定义为 $xz+yw$。", "outputFormat": "对每个 `Q` 操作，输出一个整数表示答案。", "hint": "样例解释：解密之后的输入为\n```\n    6 E\n    A 3 2\n    Q 1 5 1 1\n    A 2 3\n    A 1 4\n    Q 1 5 1 2\n    Q 4 3 2 3\n```\n", "locale": "zh-CN"}}}
{"pid": "P3310", "type": "P", "difficulty": 7, "samples": [["1\n0 1 0 2 0 3\n6\n0 0 3\n0 0 4\n0 0 5\n0 0 6\n0 0 7\n0 0 8", "45\n9\n10\n2\n19\n25"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "各省省选", "山东", "分治", "快速傅里叶变换 FFT"], "title": "[SDOI2014] 括号序列计数", "background": "", "description": "Alice 和 Bob 知道，一个由空格、左括号、右括号组成的序列被称为括号序列。有一类特殊的括号序列被称为\"合法括号序列\"。已知：\n\n- 空串是合法括号序列；\n- 如果 $S_1$ 和 $S_2$ 均是合法括号序列，则 $S_1+S_2$ 是合法括号序列；\n- 如果 $S$是合法括号序列，则 $(+S+)$ 是合法括号序列；\n- 如果 $S$ 是合法括号序列，在 $S$ 的任何位置（包括头尾位置）插入一个空格得到的序列是合法括号序列。\n\n现在 Alice 希望知道：对于某个已知的有限状态自动机中的状态 $s$ 与 $t$ ，存在多少以 $s$ 为起点、$t$ 为终点、长度为 $k$ 的合法括号序列。\n\n有限状态自动机是一个有向图 $G$，由 $n$ 个结点组成，每一个结点表示一个状态，且存在三类以此为起点的有向边。对于每一个状态，其向外的同一类有向边指向同样的状态。三类有向边分别代表三种符号：左括号、右括号和空格。\n\n我们将状态从 $0$ 开始编号。对于第 $i$ 个状态，用 $dfa_{i,0/1/2}$ 分别表示从 $i$ 出发，代表了左括号、右括号和空格的那一类边指向的状态，再用 $dfa2_{i,0/1/2}$ 表示每一类边的个数。对于一条从 $s$ 出发到 $t$ 结束的路径，满足长度为 $k$ 且路径经过的边对应的符号构成的序列组成了一组合法的括号匹配，则称作\"满足 $[G,s,t,k]$ 的合法括号序列\"。\n\n现在，Alice 为 Bob 提供了自动机 $G$，并提出 $Q$ 组询问。对于每一组询问，Alice 会给出 $s,t,k$，她希望 Bob 可以告诉她满足 $[G,s,t,k]$ 的合法括号序列有多少组。她只需要知道答案除以 $47$ 后的余数。", "inputFormat": "第一行一个整数 $n$ 表示状态数，第二到 $n+1$ 行，第 $i$ 行六个整数 $dfa_{i-1,0},dfa2_{i-1,0},dfa_{i-1,1},dfa2_{i-1,1},dfa_{i-1,2},dfa2_{i-1,2}$，描述第 $i-1$ 个状态的出边。\n\n接下来一行一个整数 $q$ 表示询问数，接下来 $q$ 行每行三个整数 $s,t,k$ 描述一组询问。", "outputFormat": "输出 $q$ 行，每行一个整数表示对应询问的答案 $\\bmod\\ 47$ 的结果。\n", "hint": "在样例解释中使用符号 `_` 代表空格。\n\n对于第一组询问长度为 $3$ 的合法括号序列有：\n\n- `___`，合法方案数为 $3^3 = 27$；\n- `_()`、`(_)`、`()_`，合法方案数均为 $1\\times2\\times3=6$。\n\n所以总方案数为 $27+6\\times3=45$。\n\n对于 $100 \\%$ 的数据，$1 \\leq n \\leq 2$，$0 \\leq dfa_{i,j} , s , t < n$，$0 \\leq dfa2_{i,j} < 2^{31}$，$1 \\leq k \\leq 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2014] Counting Bracket Sequences", "background": "", "description": "Alice and Bob know that a sequence consisting of spaces, left parentheses, and right parentheses is called a bracket sequence. A special type of bracket sequence is called a \"legal bracket sequence.\" It is known that:\n\n- The empty string is a legal bracket sequence.\n- If $S_1$ and $S_2$ are both legal bracket sequences, then $S_1+S_2$ is a legal bracket sequence.\n- If $S$ is a legal bracket sequence, then $(+S+)$ is a legal bracket sequence.\n- If $S$ is a legal bracket sequence, then inserting a space at any position in $S$ (including the beginning and the end) yields a legal bracket sequence.\n\nNow Alice wants to know: for certain states $s$ and $t$ in a given finite state automaton, how many legal bracket sequences of length $k$ start at $s$ and end at $t$.\n\nA finite state automaton is a directed graph $G$ with $n$ nodes, each node representing a state, and there are three categories of outgoing directed edges from each state. For every state, all outgoing edges of the same category point to the same state. The three categories correspond to three symbols: left parenthesis, right parenthesis, and space.\n\nWe number the states starting from $0$. For the $i$-th state, let $dfa_{i,0/1/2}$ denote the target state of the category representing left parenthesis, right parenthesis, and space, respectively, and let $dfa2_{i,0/1/2}$ denote the number of edges in each category. For a path starting from $s$ and ending at $t$, if it has length $k$ and the sequence of symbols corresponding to the edges on the path forms a legal bracket sequence, we call it \"a legal bracket sequence that satisfies $[G,s,t,k]$.\"\n\nNow Alice provides Bob with the automaton $G$ and poses $Q$ queries. For each query, Alice will give $s,t,k$, and she hopes Bob can tell her how many legal bracket sequences satisfy $[G,s,t,k]$. She only needs the answer modulo $47$.", "inputFormat": "The first line contains an integer $n$ denoting the number of states. Lines $2$ through $n+1$, where the $i$-th of them contains six integers $dfa_{i-1,0},dfa2_{i-1,0},dfa_{i-1,1},dfa2_{i-1,1},dfa_{i-1,2},dfa2_{i-1,2}$, describe the outgoing edges of state $i-1$.\n\nThe next line contains an integer $q$ denoting the number of queries. Each of the following $q$ lines contains three integers $s,t,k$ describing one query.", "outputFormat": "Output $q$ lines, each containing one integer, the answer for the corresponding query $\\bmod\\ 47$.", "hint": "In the sample explanation, the symbol `_` represents a space.\n\nFor the first query, the legal bracket sequences of length $3$ are:\n\n- `___`, with the number of legal options being $3^3 = 27$.\n- `_()`, `(_)`, `()_`, each with the number of legal options being $1 \\times 2 \\times 3 = 6$.\n\nTherefore, the total number of options is $27 + 6 \\times 3 = 45$.\n\nConstraints:\n\nFor $100\\%$ of the testdata, $1 \\leq n \\leq 2$, $0 \\leq dfa_{i,j}, s, t < n$, $0 \\leq dfa2_{i,j} < 2^{31}$, $1 \\leq k \\leq 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2014] 括号序列计数", "background": "", "description": "Alice 和 Bob 知道，一个由空格、左括号、右括号组成的序列被称为括号序列。有一类特殊的括号序列被称为\"合法括号序列\"。已知：\n\n- 空串是合法括号序列；\n- 如果 $S_1$ 和 $S_2$ 均是合法括号序列，则 $S_1+S_2$ 是合法括号序列；\n- 如果 $S$是合法括号序列，则 $(+S+)$ 是合法括号序列；\n- 如果 $S$ 是合法括号序列，在 $S$ 的任何位置（包括头尾位置）插入一个空格得到的序列是合法括号序列。\n\n现在 Alice 希望知道：对于某个已知的有限状态自动机中的状态 $s$ 与 $t$ ，存在多少以 $s$ 为起点、$t$ 为终点、长度为 $k$ 的合法括号序列。\n\n有限状态自动机是一个有向图 $G$，由 $n$ 个结点组成，每一个结点表示一个状态，且存在三类以此为起点的有向边。对于每一个状态，其向外的同一类有向边指向同样的状态。三类有向边分别代表三种符号：左括号、右括号和空格。\n\n我们将状态从 $0$ 开始编号。对于第 $i$ 个状态，用 $dfa_{i,0/1/2}$ 分别表示从 $i$ 出发，代表了左括号、右括号和空格的那一类边指向的状态，再用 $dfa2_{i,0/1/2}$ 表示每一类边的个数。对于一条从 $s$ 出发到 $t$ 结束的路径，满足长度为 $k$ 且路径经过的边对应的符号构成的序列组成了一组合法的括号匹配，则称作\"满足 $[G,s,t,k]$ 的合法括号序列\"。\n\n现在，Alice 为 Bob 提供了自动机 $G$，并提出 $Q$ 组询问。对于每一组询问，Alice 会给出 $s,t,k$，她希望 Bob 可以告诉她满足 $[G,s,t,k]$ 的合法括号序列有多少组。她只需要知道答案除以 $47$ 后的余数。", "inputFormat": "第一行一个整数 $n$ 表示状态数，第二到 $n+1$ 行，第 $i$ 行六个整数 $dfa_{i-1,0},dfa2_{i-1,0},dfa_{i-1,1},dfa2_{i-1,1},dfa_{i-1,2},dfa2_{i-1,2}$，描述第 $i-1$ 个状态的出边。\n\n接下来一行一个整数 $q$ 表示询问数，接下来 $q$ 行每行三个整数 $s,t,k$ 描述一组询问。", "outputFormat": "输出 $q$ 行，每行一个整数表示对应询问的答案 $\\bmod\\ 47$ 的结果。\n", "hint": "在样例解释中使用符号 `_` 代表空格。\n\n对于第一组询问长度为 $3$ 的合法括号序列有：\n\n- `___`，合法方案数为 $3^3 = 27$；\n- `_()`、`(_)`、`()_`，合法方案数均为 $1\\times2\\times3=6$。\n\n所以总方案数为 $27+6\\times3=45$。\n\n对于 $100 \\%$ 的数据，$1 \\leq n \\leq 2$，$0 \\leq dfa_{i,j} , s , t < n$，$0 \\leq dfa2_{i,j} < 2^{31}$，$1 \\leq k \\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P3311", "type": "P", "difficulty": 6, "samples": [["20\n3\n2\n3\n14", "14"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["字符串", "动态规划 DP", "2014", "各省省选", "山东", "O2优化", "数位 DP", "AC 自动机"], "title": "[SDOI2014] 数数", "background": "", "description": "我们称一个正整数 $x$ 是幸运数，当且仅当它的十进制表示中不包含数字串集合 $s$ 中任意一个元素作为其子串。例如当 $s = \\{22, 333, 0233\\}$ 时，$233$ 是幸运数，$2333$、$20233$、$3223$ 不是幸运数。给定 $n$ 和 $s$，计算不大于 $n$ 的幸运数个数。\n\n答案对 $10^9 + 7$ 取模。", "inputFormat": "第一行有一个整数，表示 $n$。\n\n第二行有一个整数，表示 $s$ 中的元素个数 $m$。\n\n接下来 $m$ 行，每行一个数字串 $s_i$，表示 $s$ 中的一个元素。", "outputFormat": "输出一行一个整数，表示答案对 $10^9 + 7$ 取模的结果。", "hint": "#### 样例 1 解释\n\n除了 $3, 13, 2, 12, 20, 14$ 以外，不大于 $20$ 的整数都是幸运数字。\n\n#### 数据规模与约定\n\n对于全部的测试点，保证：\n\n$1 \\leq n < 10^{1201}$，$1 \\leq m \\leq 100$，$1 \\leq \\sum_{i = 1}^m |s_i| \\leq 1500$，$\\min_{i = 1}^m |s_i| \\geq 1$，其中 $|s_i|$ 表示字符串 $s_i$ 的长度。$n$ 没有前导 $0$，但是 $s_i$ 可能有前导 $0$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2014] Counting", "background": "", "description": "We call a positive integer $x$ a lucky number if and only if its decimal representation does not contain any element from the set $s$ as a substring. For example, when $s = \\{22, 333, 0233\\}$, $233$ is a lucky number, while $2333$, $20233$, and $3223$ are not. Given $n$ and $s$, compute the number of lucky numbers not greater than $n$.\n\nThe answer is taken modulo $10^9 + 7$.", "inputFormat": "The first line contains an integer $n$.\n\nThe second line contains an integer $m$, the number of elements in $s$.\n\nThe next $m$ lines each contain a digit string $s_i$, representing an element of $s$.", "outputFormat": "Output a single line containing one integer, the answer modulo $10^9 + 7$.", "hint": "#### Sample 1 Explanation\n\nExcept for $3, 13, 2, 12, 20, 14$, all integers not exceeding $20$ are lucky numbers.\n\n#### Constraints\n\nFor all testdata, it is guaranteed that:\n\n$1 \\leq n < 10^{1201}$, $1 \\leq m \\leq 100$, $1 \\leq \\sum_{i = 1}^m |s_i| \\leq 1500$, $\\min_{i = 1}^m |s_i| \\geq 1$, where $|s_i|$ denotes the length of string $s_i$. $n$ has no leading $0$, but $s_i$ may have leading $0$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2014] 数数", "background": "", "description": "我们称一个正整数 $x$ 是幸运数，当且仅当它的十进制表示中不包含数字串集合 $s$ 中任意一个元素作为其子串。例如当 $s = \\{22, 333, 0233\\}$ 时，$233$ 是幸运数，$2333$、$20233$、$3223$ 不是幸运数。给定 $n$ 和 $s$，计算不大于 $n$ 的幸运数个数。\n\n答案对 $10^9 + 7$ 取模。", "inputFormat": "第一行有一个整数，表示 $n$。\n\n第二行有一个整数，表示 $s$ 中的元素个数 $m$。\n\n接下来 $m$ 行，每行一个数字串 $s_i$，表示 $s$ 中的一个元素。", "outputFormat": "输出一行一个整数，表示答案对 $10^9 + 7$ 取模的结果。", "hint": "#### 样例 1 解释\n\n除了 $3, 13, 2, 12, 20, 14$ 以外，不大于 $20$ 的整数都是幸运数字。\n\n#### 数据规模与约定\n\n对于全部的测试点，保证：\n\n$1 \\leq n < 10^{1201}$，$1 \\leq m \\leq 100$，$1 \\leq \\sum_{i = 1}^m |s_i| \\leq 1500$，$\\min_{i = 1}^m |s_i| \\geq 1$，其中 $|s_i|$ 表示字符串 $s_i$ 的长度。$n$ 没有前导 $0$，但是 $s_i$ 可能有前导 $0$。", "locale": "zh-CN"}}}
{"pid": "P3312", "type": "P", "difficulty": 6, "samples": [["2\n4 4 3\n10 10 5", "20\n148"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "各省省选", "树状数组", "山东", "最大公约数 gcd", "莫比乌斯反演", "前缀和"], "title": "[SDOI2014] 数表", "background": "", "description": "有一张 $n\\times m$ 的数表，其第 $i$ 行第 $j$ 列（$1\\le i\\le n$，$1\\le j\\le m$）的数值为能同时整除 $i$ 和 $j$ 的所有自然数之和。给定 $a$，计算数表中不大于 $a$ 的数之和。", "inputFormat": "**输入包含多组数据。**\n\n输入的第一行一个整数 $Q$ 表示测试点内的数据组数。\n\n接下来 $Q$ 行，每行三个整数 $n$，$m$，$a$（$|a|\\le 10^9$）描述一组数据。", "outputFormat": "对每组数据，输出一行一个整数，表示答案模 $2^{31}$ 的值。\n", "hint": "### 数据范围及约定\n\n对于全部数据，$1\\le n,m\\le 10^5$，$1\\le Q\\le 2\\times 10^4$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2014] Number Table", "background": "", "description": "There is an $n\\times m$ table of numbers. The value at row $i$ and column $j$ ($1\\le i\\le n$, $1\\le j\\le m$) equals the sum of all natural numbers that divide both $i$ and $j$. Given $a$, compute the sum of all numbers in the table that are not greater than $a$.", "inputFormat": "The input contains multiple test cases.\n\nThe first line contains an integer $Q$, the number of test cases.\n\nEach of the next $Q$ lines contains three integers $n$, $m$, $a$ ($|a|\\le 10^9$), describing one test case.", "outputFormat": "For each test case, output one line with a single integer: the answer modulo $2^{31}$.", "hint": "### Constraints and Conventions\n\nFor all testdata, $1\\le n,m\\le 10^5$, $1\\le Q\\le 2\\times 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2014] 数表", "background": "", "description": "有一张 $n\\times m$ 的数表，其第 $i$ 行第 $j$ 列（$1\\le i\\le n$，$1\\le j\\le m$）的数值为能同时整除 $i$ 和 $j$ 的所有自然数之和。给定 $a$，计算数表中不大于 $a$ 的数之和。", "inputFormat": "**输入包含多组数据。**\n\n输入的第一行一个整数 $Q$ 表示测试点内的数据组数。\n\n接下来 $Q$ 行，每行三个整数 $n$，$m$，$a$（$|a|\\le 10^9$）描述一组数据。", "outputFormat": "对每组数据，输出一行一个整数，表示答案模 $2^{31}$ 的值。\n", "hint": "### 数据范围及约定\n\n对于全部数据，$1\\le n,m\\le 10^5$，$1\\le Q\\le 2\\times 10^4$。\n", "locale": "zh-CN"}}}
{"pid": "P3313", "type": "P", "difficulty": 5, "samples": [["5 6\n3 1\n2 3\n1 2\n3 3\n5 1\n1 2\n1 3\n3 4\n3 5\nQS 1 5\nCC 3 1\nQS 1 5\nCW 3 3\nQS 1 5\nQM 2 4", "8\n9\n11\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "线段树", "各省省选", "山东", "树链剖分", "分块"], "title": "[SDOI2014] 旅行", "background": "", "description": "S 国有 $N$ 个城市，编号从 $1$ 到 $N$。城市间用 $N-1$ 条双向道路连接，满足从一个城市出发可以到达其它所有城市。每个城市信仰不同的宗教，如飞天面条神教、隐形独角兽教、绝地教都是常见的信仰。\n\n为了方便，我们用不同的正整数代表各种宗教，S 国的居民常常旅行。旅行时他们总会走最短路，并且为了避免麻烦，只在信仰和他们相同的城市留宿。当然旅程的终点也是信仰与他相同的城市。S 国为每个城市标定了不同的旅行评级，旅行者们常会记下途中（包括起点和终点）留宿过的城市的评级总和或最大值。\n\n在 S 国的历史上常会发生以下几种事件：\n\n- `CC x c`：城市 $x$ 的居民全体改信了 $c$ 教；\n- `CW x w`：城市 $x$ 的评级调整为 $w$；\n- `QS x y`：一位旅行者从城市 $x$ 出发，到城市 $y$，并记下了途中留宿过的城市的评级总和；\n- `QM x y`：一位旅行者从城市 $x$ 出发，到城市 $y$，并记下了途中留宿过的城市的评级最大值。\n\n由于年代久远，旅行者记下的数字已经遗失了，但记录开始之前每座城市的信仰与评级，还有事件记录本身是完好的。请根据这些信息，还原旅行者记下的数字。 为了方便，我们认为事件之间的间隔足够长，以致在任意一次旅行中，所有城市的评级和信仰保持不变。", "inputFormat": "输入的第一行包含整数 $N,Q$ 依次表示城市数和事件数。\n\n接下来 $N$ 行，第 $i+1$ 行两个整数 $W_i,C_i$ 依次表示记录开始之前，城市 $i$ 的评级和信仰。\n\n接下来 $N-1$ 行每行两个整数 $x,y$ 表示一条双向道路。\n\n接下来 $Q$ 行，每行一个操作，格式如上所述。", "outputFormat": "对每个 `QS` 和 `QM` 事件，输出一行，表示旅行者记下的数字。", "hint": "对于 $100\\%$ 的数据，$N,Q \\leq10^5,C \\leq10^5$\n\n数据保证对所有 `QS` 和 `QM` 事件，起点和终点城市的信仰相同；在任意时刻，城市的评级总是不大于 $10^4$ 的正整数，且宗教值不大于 $C$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2014] Travel", "background": "", "description": "Country S has $N$ cities, numbered from $1$ to $N$. The cities are connected by $N-1$ undirected roads, forming a structure where starting from any city, one can reach all other cities. Each city believes in a different religion; common beliefs include the Church of the Flying Spaghetti Monster, the Invisible Pink Unicorn, and Jediism.\n\nFor convenience, we use different positive integers to represent various religions. Residents of Country S often travel. They always take the shortest path, and to avoid trouble, they only stay overnight in cities whose religion is the same as theirs. Of course, the destination of the trip also has the same religion as the traveler. Country S assigns a distinct travel rating to each city. Travelers often record the sum or the maximum of the ratings of the cities where they stayed overnight along the way, including the start and end cities.\n\nIn the history of Country S, the following types of events often occur:\n- `CC x c`: All residents of city $x$ convert to religion $c$.\n- `CW x w`: The rating of city $x$ is adjusted to $w$.\n- `QS x y`: A traveler starts from city $x$, goes to city $y$, and records the sum of the ratings of the cities where they stayed overnight along the way.\n- `QM x y`: A traveler starts from city $x$, goes to city $y$, and records the maximum of the ratings of the cities where they stayed overnight along the way.\n\nThe recorded numbers have been lost, but the religion and rating of each city before the records began, as well as the event log itself, are intact. Based on this information, restore the numbers that the travelers recorded. For convenience, we assume that the interval between events is long enough so that during any single trip, all cities’ ratings and religions remain unchanged.", "inputFormat": "The first line contains the integers $N, Q$, representing the number of cities and the number of events, respectively.\n\nThe next $N$ lines: on the $(i+1)$-th line, two integers $W_i, C_i$ denote the initial rating and religion of city $i$ before the records began.\n\nThe next $N-1$ lines each contain two integers $x, y$, indicating an undirected road between cities $x$ and $y$.\n\nThe next $Q$ lines each contain one operation, in one of the formats described above.", "outputFormat": "For each `QS` and `QM` event, output one line containing the number recorded by the traveler.", "hint": "For $100\\%$ of the testdata, $N, Q \\le 10^5$, $C \\le 10^5$.\n\nIt is guaranteed that for all `QS` and `QM` events, the start and end cities have the same religion. At any time, a city’s rating is a positive integer not exceeding $10^4$, and the religion value does not exceed $C$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2014] 旅行", "background": "", "description": "S 国有 $N$ 个城市，编号从 $1$ 到 $N$。城市间用 $N-1$ 条双向道路连接，满足从一个城市出发可以到达其它所有城市。每个城市信仰不同的宗教，如飞天面条神教、隐形独角兽教、绝地教都是常见的信仰。\n\n为了方便，我们用不同的正整数代表各种宗教，S 国的居民常常旅行。旅行时他们总会走最短路，并且为了避免麻烦，只在信仰和他们相同的城市留宿。当然旅程的终点也是信仰与他相同的城市。S 国为每个城市标定了不同的旅行评级，旅行者们常会记下途中（包括起点和终点）留宿过的城市的评级总和或最大值。\n\n在 S 国的历史上常会发生以下几种事件：\n\n- `CC x c`：城市 $x$ 的居民全体改信了 $c$ 教；\n- `CW x w`：城市 $x$ 的评级调整为 $w$；\n- `QS x y`：一位旅行者从城市 $x$ 出发，到城市 $y$，并记下了途中留宿过的城市的评级总和；\n- `QM x y`：一位旅行者从城市 $x$ 出发，到城市 $y$，并记下了途中留宿过的城市的评级最大值。\n\n由于年代久远，旅行者记下的数字已经遗失了，但记录开始之前每座城市的信仰与评级，还有事件记录本身是完好的。请根据这些信息，还原旅行者记下的数字。 为了方便，我们认为事件之间的间隔足够长，以致在任意一次旅行中，所有城市的评级和信仰保持不变。", "inputFormat": "输入的第一行包含整数 $N,Q$ 依次表示城市数和事件数。\n\n接下来 $N$ 行，第 $i+1$ 行两个整数 $W_i,C_i$ 依次表示记录开始之前，城市 $i$ 的评级和信仰。\n\n接下来 $N-1$ 行每行两个整数 $x,y$ 表示一条双向道路。\n\n接下来 $Q$ 行，每行一个操作，格式如上所述。", "outputFormat": "对每个 `QS` 和 `QM` 事件，输出一行，表示旅行者记下的数字。", "hint": "对于 $100\\%$ 的数据，$N,Q \\leq10^5,C \\leq10^5$\n\n数据保证对所有 `QS` 和 `QM` 事件，起点和终点城市的信仰相同；在任意时刻，城市的评级总是不大于 $10^4$ 的正整数，且宗教值不大于 $C$。", "locale": "zh-CN"}}}
{"pid": "P3314", "type": "P", "difficulty": 7, "samples": [["4 4 4\n0 0 0 0\n0 0 0 0\n0 0 0 0\n0 0 0 0\n1 2 2 1\n2 1 1 2\n1 2 2 1\n2 1 1 2\n4 4 2\n0 0 1 1\n0 0 0 0\n1 0 0 0\n0 0 0 0\n1 0 2 2\n0 0 3 0\n0 0 0", "16 96\n12 1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "各省省选", "山东", "轮廓线 DP"], "title": "[SDOI2014] 电路板", "background": "", "description": "对于用户给出的电路图和指定大小的电路板，$\\text{Alice}$ 和 $\\text{Bob}$ 需要将电路在电路板上实现出来。\n\n所谓电路板，可以看作是一个 $n \\times m$ 的格子图。\n\n用户给定的电路由若干电路原件组成，每一个电路原件可能会占用一个或多个格子。这里，我们将被电路原件占据的格子分为两类。\n\n第一类只是纯粹占据了这个格子，之后这个格子不会再被使用，也不会从被占据的位置连出去任何的电路线。这样的格子被我们视作是电路板上的障碍物。\n\n还有一类格子，我们称为是电路原件的接口，上面虽然被电路原件占用，但是仍有可能从其中连出去一些电路线到其它的电路原件上，从而形成电路。\n\n对于电路图中一些链接某两个原件的电路线，我们可以指定为电路板上的 $k$ 个格子对，要求每对格子对之间连一条电路线。\n\n同一个格子可能属于多个格子对（比如一些并联电路）。\n\n任意两条电路线不能相交（但可以连接到同一个有着电路原件的格子中），且电路板上的每一个格子的每一条边都只能经过一条电路线。（所以每一个电路原件的接口上只能接出去最多 $4$ 条不同的电路线）。然而，每一个不被电路原件占用的格子内却可以经过多条电路线。\n\n具体来说：为了保证电路线不相交，可以一条电路线从上边界进入当前格子，从左边界离开这个格子，另外一条电路线可以从下边界进入格子，从右边界出去。（需要注意的是：电路线本身是没有方向感念的，即格子对描述的边关系是无向边。所以这样的方案也可以描述为从左边界进入后从上边界出去，从右边界进入后从下边界出去）相似的方案还有好几种。\n\n现在，$\\text{Alice}$ 希望找到一个可行方案，使得路径的总长度最短。而 $\\text{Bob}$ 则希望知道满足最短长度的方案有多少种。", "inputFormat": "第一行三个整数 $n,m,k$，表示电路板的大小，以及需要连接电路线的格子对个数。\n\n接下来 $m$ 行，每行 $n$ 个整数，为 $0$ 或 $1$。$0$ 代表当前格子可以用，否则表示有障碍，不能使用。\n\n接下来 $k$ 行，每行 $4$ 个整数 $x1,y1,x2,y2$，给出一组格子对，表示对应的电路要连接的两个格子。**格子的行列都从 $0$ 开始编号，所以 $0 \\le x1,x2 < n$，$0 \\le y1,y2 < m$。**\n\n本题有多组数据（最多 $30$ 组），输入文件最后以 `0 0 0` 结束。", "outputFormat": "对于每组数据，输出两个整数，最短电线长度和最短电线长度的方案数。\n\n方案数只需要输出对 $25619849$ 取余数后的结果。 \n\n如果无解，输出 `-1 0`。", "hint": "**样例解释：**\n\n第一组数据：$(1,2)$ 与 $(2,1)$ 之间有 $4$ 条路径，立刻可以发现，最短路径长度和为 $16$。对于每一种可行方案，任意一条 $(1,2)$ 与 $(2,1)$ 之间的路径都可以对应要求的 $4$ 条路径中的任何一条。而若就形态来说，完全不同的方案有 $4$ 种，考虑到排列数 $4! = 24$，所以总的方案为 $96$ 种。\n\n第二组数据：因为有 $3$ 个障碍点，所以可行路径只有一条。\n\n**数据规模：**\n\n对于 $20\\%$ 的数据：$n, m \\le 4$。\n\n对于 $40\\%$ 的数据：$n, m \\le 8$。\n\n对于 $100\\%$ 的数据，$n, m \\le 9$，$k \\le 10$。\n\n此外：\n\n存在 $10\\%$ 的数据：$k=1$。\n\n存在 $30\\%$ 的数据：$k \\le 3$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2014] Circuit Board", "background": "", "description": "Given a circuit diagram and a circuit board of specified size, $\\text{Alice}$ and $\\text{Bob}$ need to realize the circuit on the board.\n\nYou can regard the circuit board as an $n \\times m$ grid.\n\nThe user’s circuit consists of several components, each of which may occupy one or more cells. We classify the cells occupied by components into two types:\n\n- One type merely occupies the cell; afterward the cell will no longer be used, and no wire will run from that occupied position. Such cells are considered obstacles on the circuit board.\n- The other type are interfaces of components. Although occupied by a component, wires may still be connected from these cells to other components to form the circuit.\n\nFor some wires in the circuit that connect two components, we specify them as $k$ pairs of cells on the board. Each pair must be connected by exactly one wire.\n\nThe same cell may belong to multiple pairs (for example, in some parallel circuits).\n\nAny two wires must not intersect (but they may connect to the same cell that contains a component), and each edge of every cell on the board can be used by at most one wire. Therefore, each component interface can have at most $4$ wires attached. However, a cell not occupied by a component may be traversed by multiple wires.\n\nSpecifically, to ensure that wires do not intersect: one wire can enter a cell from the top edge and leave from the left edge, while another wire can enter from the bottom edge and leave from the right edge. Note that wires themselves are undirected; that is, the relation described by a pair of cells is an undirected edge. So the same configuration can also be described as entering from the left edge and leaving from the top edge, and entering from the right edge and leaving from the bottom edge. There are several similar valid pairings.\n\nNow, $\\text{Alice}$ wants to find a feasible scheme that minimizes the total length of all wires. $\\text{Bob}$ wants to know how many schemes achieve this minimal total length.", "inputFormat": "The first line contains three integers $n, m, k$, denoting the size of the circuit board and the number of pairs of cells that must be connected by wires.\n\nThen follow $n$ lines, each containing $m$ integers, each being $0$ or $1$. A $0$ means the cell is usable; a $1$ means it is an obstacle and cannot be used.\n\nThen follow $k$ lines, each containing $4$ integers $x1,y1,x2,y2$, giving one pair of cells to be connected by a wire. The row and column indices of cells are $0$-based, so $0 \\le x1,x2 < n$ and $0 \\le y1,y2 < m$.\n\nThis problem has multiple testcases (at most $30$). The input ends with a line `0 0 0`.", "outputFormat": "For each testcase, output two integers: the minimal total wire length, and the number of schemes that achieve this minimal length.\n\nOutput the number of schemes modulo $25619849$.\n\nIf there is no solution, output `-1 0`.", "hint": "Sample explanation:\n\n- For the first testcase: there are $4$ paths between $(1,2)$ and $(2,1)$, and it is easy to see that the minimal total path length is $16$. In any feasible scheme, any path between $(1,2)$ and $(2,1)$ can correspond to any of the required $4$ paths. If we consider distinct shapes, there are $4$ different schemes. Taking into account permutations, $4! = 24$, the total number of schemes is $96$.\n- For the second testcase: due to $3$ obstacle cells, there is only one feasible path.\n\nConstraints:\n\n- For $20\\%$ of the testdata: $n, m \\le 4$.\n- For $40\\%$ of the testdata: $n, m \\le 8$.\n- For $100\\%$ of the testdata: $n, m \\le 9$, $k \\le 10$.\n\nIn addition:\n\n- There exists $10\\%$ of the testdata with $k=1$.\n- There exists $30\\%$ of the testdata with $k \\le 3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2014] 电路板", "background": "", "description": "对于用户给出的电路图和指定大小的电路板，$\\text{Alice}$ 和 $\\text{Bob}$ 需要将电路在电路板上实现出来。\n\n所谓电路板，可以看作是一个 $n \\times m$ 的格子图。\n\n用户给定的电路由若干电路原件组成，每一个电路原件可能会占用一个或多个格子。这里，我们将被电路原件占据的格子分为两类。\n\n第一类只是纯粹占据了这个格子，之后这个格子不会再被使用，也不会从被占据的位置连出去任何的电路线。这样的格子被我们视作是电路板上的障碍物。\n\n还有一类格子，我们称为是电路原件的接口，上面虽然被电路原件占用，但是仍有可能从其中连出去一些电路线到其它的电路原件上，从而形成电路。\n\n对于电路图中一些链接某两个原件的电路线，我们可以指定为电路板上的 $k$ 个格子对，要求每对格子对之间连一条电路线。\n\n同一个格子可能属于多个格子对（比如一些并联电路）。\n\n任意两条电路线不能相交（但可以连接到同一个有着电路原件的格子中），且电路板上的每一个格子的每一条边都只能经过一条电路线。（所以每一个电路原件的接口上只能接出去最多 $4$ 条不同的电路线）。然而，每一个不被电路原件占用的格子内却可以经过多条电路线。\n\n具体来说：为了保证电路线不相交，可以一条电路线从上边界进入当前格子，从左边界离开这个格子，另外一条电路线可以从下边界进入格子，从右边界出去。（需要注意的是：电路线本身是没有方向感念的，即格子对描述的边关系是无向边。所以这样的方案也可以描述为从左边界进入后从上边界出去，从右边界进入后从下边界出去）相似的方案还有好几种。\n\n现在，$\\text{Alice}$ 希望找到一个可行方案，使得路径的总长度最短。而 $\\text{Bob}$ 则希望知道满足最短长度的方案有多少种。", "inputFormat": "第一行三个整数 $n,m,k$，表示电路板的大小，以及需要连接电路线的格子对个数。\n\n接下来 $m$ 行，每行 $n$ 个整数，为 $0$ 或 $1$。$0$ 代表当前格子可以用，否则表示有障碍，不能使用。\n\n接下来 $k$ 行，每行 $4$ 个整数 $x1,y1,x2,y2$，给出一组格子对，表示对应的电路要连接的两个格子。**格子的行列都从 $0$ 开始编号，所以 $0 \\le x1,x2 < n$，$0 \\le y1,y2 < m$。**\n\n本题有多组数据（最多 $30$ 组），输入文件最后以 `0 0 0` 结束。", "outputFormat": "对于每组数据，输出两个整数，最短电线长度和最短电线长度的方案数。\n\n方案数只需要输出对 $25619849$ 取余数后的结果。 \n\n如果无解，输出 `-1 0`。", "hint": "**样例解释：**\n\n第一组数据：$(1,2)$ 与 $(2,1)$ 之间有 $4$ 条路径，立刻可以发现，最短路径长度和为 $16$。对于每一种可行方案，任意一条 $(1,2)$ 与 $(2,1)$ 之间的路径都可以对应要求的 $4$ 条路径中的任何一条。而若就形态来说，完全不同的方案有 $4$ 种，考虑到排列数 $4! = 24$，所以总的方案为 $96$ 种。\n\n第二组数据：因为有 $3$ 个障碍点，所以可行路径只有一条。\n\n**数据规模：**\n\n对于 $20\\%$ 的数据：$n, m \\le 4$。\n\n对于 $40\\%$ 的数据：$n, m \\le 8$。\n\n对于 $100\\%$ 的数据，$n, m \\le 9$，$k \\le 10$。\n\n此外：\n\n存在 $10\\%$ 的数据：$k=1$。\n\n存在 $30\\%$ 的数据：$k \\le 3$。", "locale": "zh-CN"}}}
{"pid": "P3315", "type": "P", "difficulty": 7, "samples": [["2 2\n1 2\n3\n4\n4\n0 0 0 1\n1 0 0 1\n1 1 0 1\n0 1 1 0", "7.0000\n10.0000\n8.0000\n10.0000"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "各省省选", "山东", "Special Judge", "高斯消元"], "title": "[SDOI2014] 酗酒者", "background": "", "description": "$\\text{Alice}$ 发现：人在心情不好的时候，便会选择酗酒。这往往与 $\\text{OI}$ 选手比赛胜利后的欢腾庆祝不同，酗酒者喝醉后便会忘记回家的路，然后在大街上无规律地乱走乱逛，同时喊着一些谁也听不懂的话。\n\n这几天，$\\text{Bob}$ 因为考试的原因心情很不好，每天晚上都会在城里面找一处酒吧。喝醉后离开酒吧开始在城市街道中无规律乱走，直到某一时刻，若他碰巧遇到了在夜晚出来看星星的 $\\text{Alice}$，便会被她带回家。\n\n已知 $\\text{Alice}$ 和 $\\text{Bob}$ 所在的城市街道可以被描绘为一个 $N$ 行 $M$ 列的格点地图，$N$ 行依次编号为 $0$ 到 $N-1$，$M$ 列依次编号为 $0$ 到 $M-1$。城市中共有 $N\\times M$ 处路口，每一个路口可以用坐标 $(i,j)$ 表示。若 $i<N$，则 $(i,j)$ 与 $(i+1,j)$ 有无向的连边，边权长度，$p_{(i,j)}$ 表示走过这一条路所需的时间。若 $j<M$，则 $(i,j)$ 与 $(i,j+1)$ 有连无向边，边权长度 $q_{(i,j)}$。\n\n对于给定的两个点 $(u,v)$ 和 $(s,t)$ 分别为 $\\text{Bob}$ 今晚去的酒吧的位置，和 $\\text{Alice}$ 今晚看星星的位置。$\\text{Bob}$ 离开酒吧后，对于每一个路口，他会等概率选择其中之一，然后走向下一个路口。在走到下一个路口之前，$\\text{Bob}$ 不会回头。同时 $\\text{Bob}$ 并不会因为之前走过什么道路而影响之后的行走路线。\n\n具体来说：如果 $\\text{Bob}$ 从 $(3,4)$ 走到 $(3,5)$，他有可能在抵达 $(3,5)$ 后立刻折回 $(3,4)$。对于四叉路口，$\\text{Bob}$ 向每一个方向行走的概率都是 $1/4$，对于三叉路口（这只存在于城市的边界上）则是 $1/3$，对于二叉路口（这只存在于城市的 $4$ 个角落）就是 $1/2$。\n\n$\\text{Alice}$ 希望知道，从 $\\text{Bob}$ 离开酒吧，$\\text{Alice}$ 期望情况下还需要等多久才能等到 $\\text{Bob}$，即对于给定的两个点 $(u,v)$ 与 $(s,t)$，$\\text{Bob}$ 从 $(u,v)$ 走到 $(s,t)$ 的期望用时是多少？", "inputFormat": "第一行 $N$，$M$。\n\n之后 $N-1$ 行，每行 $M$ 个正整数，其中第 $i$ 行第 $j$ 个为 $p_{(i,j)}$。\n\n之后 $N$ 行，每行 $M-1$ 个正整数，其中第 $i$ 行第 $j$ 个为 $q_{(i,j)}$。\n\n单独一行给出一个整数 $Q$，表示总询问次数。\n\n之后 $Q$ 行，每行有 $4$ 个整数 $u$，$v$，$s$，$t$。", "outputFormat": "一共 $Q$ 行，每一行对应一次询问：从 $(u,v)$ 走到 $(s,t)$ 的期望时间是多少？你的答案可以保留任意多位小数，但只有与正确答案的错误率在 $0.1\\%$ 内才算正确。", "hint": "对于 $10\\%$ 的数据，$N \\times M \\le 25$。\n\n对于 $30\\%$ 的数据，$N \\times M \\le 625$。\n\n对于 $50\\%$ 的数据，$N \\times M \\le 2500$。\n\n对于 $100\\%$ 的数据，$1 \\le N \\times M \\le 10^4$，$1 \\le Q \\le 100$。$1 \\le p_{(i,j)},q_{(i,j)} \\le 200$。\n\n此外存在 $10\\%$ 的数据，$\\min(N,M) \\le 10$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2014] The Drunkard", "background": "", "description": "$\\text{Alice}$ finds that when people are in a bad mood, they tend to drink heavily. Unlike the jubilant celebration after an $\\text{OI}$ contestant’s victory, a drunkard often forgets the way home and wanders randomly around the streets, shouting incomprehensible words.\n\nThese days, $\\text{Bob}$ is in a bad mood due to exams. Every night he finds a bar in the city. After getting drunk and leaving the bar, he begins to wander randomly through the city streets until, at some moment, if he happens to meet $\\text{Alice}$ who is out watching the stars at night, she will take him home.\n\nThe city streets where $\\text{Alice}$ and $\\text{Bob}$ live can be modeled as a grid of $N$ rows and $M$ columns. Rows are numbered from $0$ to $N - 1$, and columns from $0$ to $M - 1$. There are $N \\times M$ intersections in total, and each intersection is denoted by coordinates $(i, j)$. If $i < N - 1$, then $(i, j)$ and $(i + 1, j)$ are connected by an undirected edge whose length is $p_{(i,j)}$, representing the time needed to traverse this road. If $j < M - 1$, then $(i, j)$ and $(i, j + 1)$ are connected by an undirected edge whose length is $q_{(i,j)}$.\n\nGiven two points $(u, v)$ and $(s, t)$, which are the locations of the bar that $\\text{Bob}$ visits tonight and the place where $\\text{Alice}$ watches the stars tonight, respectively. After leaving the bar, at each intersection, $\\text{Bob}$ will choose uniformly at random one of the adjacent intersections and then move to it. Before reaching the next intersection, $\\text{Bob}$ will not turn back mid-edge. Also, $\\text{Bob}$’s future movement is not affected by the roads he has previously taken.\n\nSpecifically: if $\\text{Bob}$ moves from $(3, 4)$ to $(3, 5)$, he may immediately return to $(3, 4)$ after arriving at $(3, 5)$. At a four-way intersection, $\\text{Bob}$ moves in each direction with probability $1/4$; at a three-way intersection (only on the boundary), with probability $1/3$ for each; at a two-way intersection (only at the four corners), with probability $1/2$ for each.\n\n$\\text{Alice}$ wants to know, starting from when $\\text{Bob}$ leaves the bar, how long she expects to wait until meeting $\\text{Bob}$. That is, for the given points $(u, v)$ and $(s, t)$, what is the expected time for $\\text{Bob}$ to go from $(u, v)$ to $(s, t)$?", "inputFormat": "The first line contains $N$, $M$.\n\nThen there are $N - 1$ lines, each containing $M$ positive integers, where the entry in row $i$ and column $j$ is $p_{(i,j)}$.\n\nThen there are $N$ lines, each containing $M - 1$ positive integers, where the entry in row $i$ and column $j$ is $q_{(i,j)}$.\n\nA single line follows with an integer $Q$, the number of queries.\n\nThen $Q$ lines follow, each containing four integers $u$, $v$, $s$, $t$.", "outputFormat": "Output $Q$ lines. For each query, print the expected time for $\\text{Bob}$ to go from $(u, v)$ to $(s, t)$. You may output any number of decimal places, but your answer is considered correct only if the error rate is within $0.1\\%$.", "hint": "For $10\\%$ of the testdata, $N \\times M \\le 25$.\n\nFor $30\\%$ of the testdata, $N \\times M \\le 625$.\n\nFor $50\\%$ of the testdata, $N \\times M \\le 2500$.\n\nFor $100\\%$ of the testdata, $1 \\le N \\times M \\le 10^4$, $1 \\le Q \\le 100$, and $1 \\le p_{(i,j)}, q_{(i,j)} \\le 200$.\n\nAdditionally, for $10\\%$ of the testdata, $\\min(N, M) \\le 10$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2014] 酗酒者", "background": "", "description": "$\\text{Alice}$ 发现：人在心情不好的时候，便会选择酗酒。这往往与 $\\text{OI}$ 选手比赛胜利后的欢腾庆祝不同，酗酒者喝醉后便会忘记回家的路，然后在大街上无规律地乱走乱逛，同时喊着一些谁也听不懂的话。\n\n这几天，$\\text{Bob}$ 因为考试的原因心情很不好，每天晚上都会在城里面找一处酒吧。喝醉后离开酒吧开始在城市街道中无规律乱走，直到某一时刻，若他碰巧遇到了在夜晚出来看星星的 $\\text{Alice}$，便会被她带回家。\n\n已知 $\\text{Alice}$ 和 $\\text{Bob}$ 所在的城市街道可以被描绘为一个 $N$ 行 $M$ 列的格点地图，$N$ 行依次编号为 $0$ 到 $N-1$，$M$ 列依次编号为 $0$ 到 $M-1$。城市中共有 $N\\times M$ 处路口，每一个路口可以用坐标 $(i,j)$ 表示。若 $i<N$，则 $(i,j)$ 与 $(i+1,j)$ 有无向的连边，边权长度，$p_{(i,j)}$ 表示走过这一条路所需的时间。若 $j<M$，则 $(i,j)$ 与 $(i,j+1)$ 有连无向边，边权长度 $q_{(i,j)}$。\n\n对于给定的两个点 $(u,v)$ 和 $(s,t)$ 分别为 $\\text{Bob}$ 今晚去的酒吧的位置，和 $\\text{Alice}$ 今晚看星星的位置。$\\text{Bob}$ 离开酒吧后，对于每一个路口，他会等概率选择其中之一，然后走向下一个路口。在走到下一个路口之前，$\\text{Bob}$ 不会回头。同时 $\\text{Bob}$ 并不会因为之前走过什么道路而影响之后的行走路线。\n\n具体来说：如果 $\\text{Bob}$ 从 $(3,4)$ 走到 $(3,5)$，他有可能在抵达 $(3,5)$ 后立刻折回 $(3,4)$。对于四叉路口，$\\text{Bob}$ 向每一个方向行走的概率都是 $1/4$，对于三叉路口（这只存在于城市的边界上）则是 $1/3$，对于二叉路口（这只存在于城市的 $4$ 个角落）就是 $1/2$。\n\n$\\text{Alice}$ 希望知道，从 $\\text{Bob}$ 离开酒吧，$\\text{Alice}$ 期望情况下还需要等多久才能等到 $\\text{Bob}$，即对于给定的两个点 $(u,v)$ 与 $(s,t)$，$\\text{Bob}$ 从 $(u,v)$ 走到 $(s,t)$ 的期望用时是多少？", "inputFormat": "第一行 $N$，$M$。\n\n之后 $N-1$ 行，每行 $M$ 个正整数，其中第 $i$ 行第 $j$ 个为 $p_{(i,j)}$。\n\n之后 $N$ 行，每行 $M-1$ 个正整数，其中第 $i$ 行第 $j$ 个为 $q_{(i,j)}$。\n\n单独一行给出一个整数 $Q$，表示总询问次数。\n\n之后 $Q$ 行，每行有 $4$ 个整数 $u$，$v$，$s$，$t$。", "outputFormat": "一共 $Q$ 行，每一行对应一次询问：从 $(u,v)$ 走到 $(s,t)$ 的期望时间是多少？你的答案可以保留任意多位小数，但只有与正确答案的错误率在 $0.1\\%$ 内才算正确。", "hint": "对于 $10\\%$ 的数据，$N \\times M \\le 25$。\n\n对于 $30\\%$ 的数据，$N \\times M \\le 625$。\n\n对于 $50\\%$ 的数据，$N \\times M \\le 2500$。\n\n对于 $100\\%$ 的数据，$1 \\le N \\times M \\le 10^4$，$1 \\le Q \\le 100$。$1 \\le p_{(i,j)},q_{(i,j)} \\le 200$。\n\n此外存在 $10\\%$ 的数据，$\\min(N,M) \\le 10$。", "locale": "zh-CN"}}}
{"pid": "P3316", "type": "P", "difficulty": 7, "samples": [["6\n249999999 499999998\n583333331 83333333\n83333333 333333332\n333333332 999999996\n833333330 749999997\n499999998 833333330\n12\n0 1 872826049 679758020 472526437 270998755 15447952 502239247\n1 833333330 749999997 499999998 833333330 916666663 666666664\n1 833333330 749999997 916666663 666666664 416666665 916666663\n0 1 371653715 747730364 409617871 21996163 118531999 759280767\n1 249999999 499999998 583333331 83333333 666666664 166666666\n0 1 195920917 488293591 322952040 262793733 678458193 506876149\n0 1 203963007 782710007 391614158 831643205 340800821 896322422\n0 1 498571077 461554269 765704840 973009111 152064733 114249255\n1 499999998 833333330 249999999 499999998 999999996 583333331\n0 1 159294077 702544938 787871788 619972292 941209243 950700951\n0 1 791254252 411705638 382076333 263993056 306662346 47793905\n0 1 13359599 513224793 415037020 28305143 48117026 34994422", "out\nout\nin\nin\nout\nout\nout\nin"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["计算几何", "2014", "各省省选", "山东"], "title": "[SDOI2014] 里面还是外面", "background": "upd：\n\n- 数据更新：现在选取了原题的总共 10 个测试点，并删除了其中两个不符合题意的。", "description": "Alice 给出了平面上的一个简单 $N$-多边形。所谓简单 $N$-多边形，包括 $N$ 个给定的端点，和连接相邻点的直线段。特别的，我们认为 1 号点与 $N$ 号点相邻。\n\n对于边界上不同的直线段，保证它们只会在公共端点处相交。有的时候 Alice 会指着平面上一个点，然后问 Bob：“这个点是在多边形的里面呢，还是外面呢，还是在边界上呢？”\n\n这个时候，如果她所指的点是多边形的一个顶点或者在多边形某条边的边界上，都将被认为是在多边形的边界上。还有的时候，Alice 为了加大难度，会删除连接 $a$ 和 $b$ 的边，并插入新的点 $c$（新插入的点保证不与任何已有的端点重合，也不在任何边界上），然后新增 $a$ 到 $c$ 的边与 $b$ 到 $c$ 的边，从而得到一个新的简单多边形。\n\nAlice 保证这样的操作得到的新图形总是简单多边形。Bob 要做的，就是准确回答出 Alice 的提问。而实际上，Alice 的每一次提问都将由 Bob 上一次的回答决定，虽然这个回答是唯一的，但却意味着如果 Bob 不能回答出前一个问题，就不能拿到 Alice 的下一个问题。\n\n不过，Alice 对多边形的修改确实事先准备好的。详细来说：Alice 的每一次修改命令可以看作是一个六元组：$\\langle x_a, y_a, x_b, y_b, x_c, y_c \\rangle$ 表示删除了坐标位置 $(x_a, y_a)$ 与坐标位置 $(x_b, y_b)$ 的点之间的连边，并插入新的点 $(x_c, y_c)$。\n\n这里我们保证坐标为 $(x_a, y_a)$ 的点与坐标为 $(x_b, y_b)$ 的点总是存在的。因为 Alice 保证了所有出现的点（这包括了询问点）的坐标都是非负整数，且都小于 $10^9$，且多边形中（这不包括询问点）任意两个点的 $x$ 坐标不同，$y$ 坐标也不同。所以每一次询问 Alice 将给出 7 个非负整数：$r$，$x_{\\text{in}}$，$y_{\\text{in}}$，$x_{\\text{out}}$，$y_{\\text{out}}$，$x_{\\text{bd}}$，$y_{\\text{bd}}$。而 Alice 这一次询问真正要询问的点 $(X, Y)$ 的坐标将由上一次询问的点 $(x_0, y_0)$ 与上一次询问的回答而决定。例如，若上一次询问的点在多边形外，则：\n$$\nX = (r \\times x_0 + x_{\\text{out}}) \\bmod 10^9\n$$\n$$\nY = (r \\times y_0 + y_{\\text{out}}) \\bmod 10^9\n$$\n对于第一次询问，我们假设 $x_0 = y_0 = 0$，也就是说将 $(0,0)$ 考虑为前一次的询问。", "inputFormat": "输入文件的第一行有一个整数 $N$，表示初始时多边形的点数。\n\n之后 $N$ 行，每行一对非负整数 $x$ 和 $y$（$0 \\leq x, y < 10^9$）。按照某一顺序依次描述了多边形的所有顶点的坐标，并编号为 1 到 $N$。这里我们只认为，对于平面上的一点 $(10^{100}, 10^{100})$ 一定是处在多边形以外的。之后一行有一个整数 $Q$，表示总的操作次数。\n\n之后 $Q$ 行，每行第一个数字 $p$，如果 $p=0$ 则表示询问；如果 $p=1$ 则表示修改。\n- 对于询问，之后给出了 7 个非负整数，它们是：$r$，$x_{\\text{in}}$，$y_{\\text{in}}$，$x_{\\text{out}}$，$y_{\\text{out}}$，$x_{\\text{bd}}$，$y_{\\text{bd}}$\n- 对于修改，之后给出了 6 个整数，它们是：$x_a$，$y_a$，$x_b$，$y_b$，$x_c$，$y_c$", "outputFormat": "对于每一次询问操作，单独输出一行且只包含一个字符串，它或者是 `in`、或者是 `out`、或者是 `bd`（均为小写字符），分别表示询问点在多边形的内、外或边界。\n", "hint": "对于 100% 的数据：$N \\leq 50000$，$Q \\leq 50000$，所有坐标非负且均小于 $10^9$，而 $r$ 或者为 1 或者为 0。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2014] Inside or Outside", "background": "upd:\n\n- Testdata update: a total of 10 test points from the original problem are selected, and two that did not meet the statement have been removed.", "description": "Alice gives a simple $N$-gon on the plane. A simple $N$-gon consists of $N$ given endpoints and straight segments connecting adjacent points. In particular, we consider vertex $1$ adjacent to vertex $N$.\n\nFor distinct boundary segments, they only intersect at common endpoints. Sometimes Alice points to a point in the plane and asks Bob: “Is this point inside the polygon, outside the polygon, or on the boundary?”\n\nAt that time, if the pointed point is a vertex of the polygon or lies on any edge of the polygon, it is considered to be on the boundary. Sometimes, to increase the difficulty, Alice deletes the edge connecting $a$ and $b$, inserts a new point $c$ (the newly inserted point is guaranteed not to coincide with any existing endpoint and not to lie on any existing edge), and then adds edges from $a$ to $c$ and from $b$ to $c$, thereby obtaining a new simple polygon.\n\nAlice guarantees that the figure obtained by such an operation is always a simple polygon. What Bob has to do is answer Alice’s questions correctly. In fact, each of Alice’s questions will be determined by Bob’s previous answer: although this answer is unique, it implies that if Bob cannot answer the previous question, he cannot get Alice’s next question.\n\nHowever, Alice’s modifications are indeed prepared in advance. In detail: each modification command by Alice can be viewed as a 6-tuple $\\langle x_a, y_a, x_b, y_b, x_c, y_c \\rangle$, which means the edge between $(x_a, y_a)$ and $(x_b, y_b)$ is deleted, and a new point $(x_c, y_c)$ is inserted.\n\nWe guarantee that the points at coordinates $(x_a, y_a)$ and $(x_b, y_b)$ always exist. Because Alice guarantees that all appearing points (this includes query points) have non-negative integer coordinates, all less than $10^9$, and among the polygon’s points (this does not include query points) any two points have distinct $x$-coordinates and also distinct $y$-coordinates. Therefore, for each query Alice will give 7 non-negative integers: $r$, $x_{\\text{in}}$, $y_{\\text{in}}$, $x_{\\text{out}}$, $y_{\\text{out}}$, $x_{\\text{bd}}$, $y_{\\text{bd}}$. The actual query point $(X, Y)$ for this query is determined by the previous query point $(x_0, y_0)$ and the previous answer. For example, if the previous query point was outside the polygon, then:\n$$\nX = (r \\times x_0 + x_{\\text{out}}) \\bmod 10^9\n$$\n$$\nY = (r \\times y_0 + y_{\\text{out}}) \\bmod 10^9\n$$\nFor the first query, assume $x_0 = y_0 = 0$, i.e., treat $(0, 0)$ as the previous query.\n\nSimilarly, if the previous point was inside, replace $x_{\\text{out}}, y_{\\text{out}}$ with $x_{\\text{in}}, y_{\\text{in}}$; if it was on the boundary, use $x_{\\text{bd}}, y_{\\text{bd}}$.", "inputFormat": "The first line contains an integer $N$, the number of vertices of the initial polygon.\n\nThen follow $N$ lines, each with a pair of non-negative integers $x$ and $y$ ($0 \\leq x, y < 10^9$). They describe all vertices of the polygon in some order and are indexed from $1$ to $N$. Here we only assume that the point $(10^{100}, 10^{100})$ in the plane is certainly outside the polygon. The next line contains an integer $Q$, the total number of operations.\n\nEach of the next $Q$ lines starts with a number $p$. If $p = 0$, it is a query; if $p = 1$, it is a modification.\n- For a query, the next 7 non-negative integers are: $r$, $x_{\\text{in}}$, $y_{\\text{in}}$, $x_{\\text{out}}$, $y_{\\text{out}}$, $x_{\\text{bd}}$, $y_{\\text{bd}}$.\n- For a modification, the next 6 integers are: $x_a$, $y_a$, $x_b$, $y_b$, $x_c$, $y_c$.", "outputFormat": "For each query operation, output a single line containing exactly one string: either `in`, `out`, or `bd` (all lowercase), indicating that the query point is inside the polygon, outside the polygon, or on the boundary, respectively.", "hint": "For 100% of the testdata: $N \\leq 50000$, $Q \\leq 50000$, all coordinates are non-negative and less than $10^9$, and $r$ is either $1$ or $0$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2014] 里面还是外面", "background": "upd：\n\n- 数据更新：现在选取了原题的总共 10 个测试点，并删除了其中两个不符合题意的。", "description": "Alice 给出了平面上的一个简单 $N$-多边形。所谓简单 $N$-多边形，包括 $N$ 个给定的端点，和连接相邻点的直线段。特别的，我们认为 1 号点与 $N$ 号点相邻。\n\n对于边界上不同的直线段，保证它们只会在公共端点处相交。有的时候 Alice 会指着平面上一个点，然后问 Bob：“这个点是在多边形的里面呢，还是外面呢，还是在边界上呢？”\n\n这个时候，如果她所指的点是多边形的一个顶点或者在多边形某条边的边界上，都将被认为是在多边形的边界上。还有的时候，Alice 为了加大难度，会删除连接 $a$ 和 $b$ 的边，并插入新的点 $c$（新插入的点保证不与任何已有的端点重合，也不在任何边界上），然后新增 $a$ 到 $c$ 的边与 $b$ 到 $c$ 的边，从而得到一个新的简单多边形。\n\nAlice 保证这样的操作得到的新图形总是简单多边形。Bob 要做的，就是准确回答出 Alice 的提问。而实际上，Alice 的每一次提问都将由 Bob 上一次的回答决定，虽然这个回答是唯一的，但却意味着如果 Bob 不能回答出前一个问题，就不能拿到 Alice 的下一个问题。\n\n不过，Alice 对多边形的修改确实事先准备好的。详细来说：Alice 的每一次修改命令可以看作是一个六元组：$\\langle x_a, y_a, x_b, y_b, x_c, y_c \\rangle$ 表示删除了坐标位置 $(x_a, y_a)$ 与坐标位置 $(x_b, y_b)$ 的点之间的连边，并插入新的点 $(x_c, y_c)$。\n\n这里我们保证坐标为 $(x_a, y_a)$ 的点与坐标为 $(x_b, y_b)$ 的点总是存在的。因为 Alice 保证了所有出现的点（这包括了询问点）的坐标都是非负整数，且都小于 $10^9$，且多边形中（这不包括询问点）任意两个点的 $x$ 坐标不同，$y$ 坐标也不同。所以每一次询问 Alice 将给出 7 个非负整数：$r$，$x_{\\text{in}}$，$y_{\\text{in}}$，$x_{\\text{out}}$，$y_{\\text{out}}$，$x_{\\text{bd}}$，$y_{\\text{bd}}$。而 Alice 这一次询问真正要询问的点 $(X, Y)$ 的坐标将由上一次询问的点 $(x_0, y_0)$ 与上一次询问的回答而决定。例如，若上一次询问的点在多边形外，则：\n$$\nX = (r \\times x_0 + x_{\\text{out}}) \\bmod 10^9\n$$\n$$\nY = (r \\times y_0 + y_{\\text{out}}) \\bmod 10^9\n$$\n对于第一次询问，我们假设 $x_0 = y_0 = 0$，也就是说将 $(0,0)$ 考虑为前一次的询问。", "inputFormat": "输入文件的第一行有一个整数 $N$，表示初始时多边形的点数。\n\n之后 $N$ 行，每行一对非负整数 $x$ 和 $y$（$0 \\leq x, y < 10^9$）。按照某一顺序依次描述了多边形的所有顶点的坐标，并编号为 1 到 $N$。这里我们只认为，对于平面上的一点 $(10^{100}, 10^{100})$ 一定是处在多边形以外的。之后一行有一个整数 $Q$，表示总的操作次数。\n\n之后 $Q$ 行，每行第一个数字 $p$，如果 $p=0$ 则表示询问；如果 $p=1$ 则表示修改。\n- 对于询问，之后给出了 7 个非负整数，它们是：$r$，$x_{\\text{in}}$，$y_{\\text{in}}$，$x_{\\text{out}}$，$y_{\\text{out}}$，$x_{\\text{bd}}$，$y_{\\text{bd}}$\n- 对于修改，之后给出了 6 个整数，它们是：$x_a$，$y_a$，$x_b$，$y_b$，$x_c$，$y_c$", "outputFormat": "对于每一次询问操作，单独输出一行且只包含一个字符串，它或者是 `in`、或者是 `out`、或者是 `bd`（均为小写字符），分别表示询问点在多边形的内、外或边界。\n", "hint": "对于 100% 的数据：$N \\leq 50000$，$Q \\leq 50000$，所有坐标非负且均小于 $10^9$，而 $r$ 或者为 1 或者为 0。", "locale": "zh-CN"}}}
{"pid": "P3317", "type": "P", "difficulty": 6, "samples": [["3\n0 0.5 0.5\n0.5 0 0.5\n0.5 0.5 0", "0.375"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "各省省选", "矩阵树定理", "山东", "Special Judge", "生成树", "期望"], "title": "[SDOI2014] 重建", "background": "", "description": "T 国有 $N$ 个城市，用若干双向道路连接。一对城市之间至多存在一条道路。    \n\n在一次洪水之后，一些道路受损无法通行。虽然已经有人开始调查道路的损毁情况，但直到现在几乎没有消息传回。    \n\n幸运的是，此前 T 国政府调查过每条道路的强度，现在他们希望只利用这些信息估计灾情。具体地，给定每条道路在洪水后仍能通行的概率，请计算仍能通行的道路恰有 $N-1$ 条，且能联通所有城市的概率。\n", "inputFormat": "输入的第一行包含整数 $N$。  \n\n接下来 $N$ 行，每行 $N$ 个实数，第 $i+1$ 行，列的数 $G_{i,j}$ 表示城市 $i$ 与 $j$ 之间仍有道路联通的概率。    \n\n输入保证 $G_{i,j}=G_{j,i}$，且 $G_{i,i}=0$。$G_{i, j}$ 至多包含两位小数。\n", "outputFormat": "输出一个任意位数的实数表示答案。    \n\n你的答案与标准答案相对误差不超过 $10^{-4}$ 即视为正确。\n", "hint": "$1<N\\leq 50$。\n\n数据保证答案非零时，答案不小于 $10^{-4}$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2014] Reconstruction", "background": "", "description": "Country T has $N$ cities, connected by several bidirectional roads. Between any pair of cities, there is at most one road.\n\nAfter a flood, some roads were damaged and are no longer passable. Although an investigation into the damage has begun, almost no information has come back so far.\n\nFortunately, the government of Country T had previously investigated the strength of each road, and now they hope to estimate the damage using only this information. Specifically, given for each road the probability that it remains passable after the flood, compute the probability that exactly $N-1$ roads remain passable and they connect all cities.", "inputFormat": "The first line contains the integer $N$.\n\nThen follow $N$ lines, each containing $N$ real numbers. In the $(i+1)$-th line, the number in column $j$, denoted $G_{i,j}$, represents the probability that cities $i$ and $j$ are still connected by a road after the flood.\n\nIt is guaranteed that $G_{i,j}=G_{j,i}$ and $G_{i,i}=0$. Each $G_{i,j}$ contains at most two decimal places.", "outputFormat": "Output a real number representing the answer.\n\nYour answer will be accepted if its relative error does not exceed $10^{-4}$.", "hint": "$1 < N \\leq 50$.\n\nIt is guaranteed that if the answer is non-zero, then it is at least $10^{-4}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2014] 重建", "background": "", "description": "T 国有 $N$ 个城市，用若干双向道路连接。一对城市之间至多存在一条道路。    \n\n在一次洪水之后，一些道路受损无法通行。虽然已经有人开始调查道路的损毁情况，但直到现在几乎没有消息传回。    \n\n幸运的是，此前 T 国政府调查过每条道路的强度，现在他们希望只利用这些信息估计灾情。具体地，给定每条道路在洪水后仍能通行的概率，请计算仍能通行的道路恰有 $N-1$ 条，且能联通所有城市的概率。\n", "inputFormat": "输入的第一行包含整数 $N$。  \n\n接下来 $N$ 行，每行 $N$ 个实数，第 $i+1$ 行，列的数 $G_{i,j}$ 表示城市 $i$ 与 $j$ 之间仍有道路联通的概率。    \n\n输入保证 $G_{i,j}=G_{j,i}$，且 $G_{i,i}=0$。$G_{i, j}$ 至多包含两位小数。\n", "outputFormat": "输出一个任意位数的实数表示答案。    \n\n你的答案与标准答案相对误差不超过 $10^{-4}$ 即视为正确。\n", "hint": "$1<N\\leq 50$。\n\n数据保证答案非零时，答案不小于 $10^{-4}$。\n", "locale": "zh-CN"}}}
{"pid": "P3318", "type": "P", "difficulty": 6, "samples": [["4 4 7 3\nvijosvi\njosvivi\nvijosos\nijosvsv\njos\nvij\nijo\njos", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["字符串", "2015", "各省省选", "山东", "哈希 hashing"], "title": "[SDOI2015] 双旋转字符串", "background": "", "description": "给定两个字符串集合 $\\mathcal{S}$ 和 $\\mathcal{T}$。其中 $S$ 中的所有字符串长度都恰好为 $N$，而 $T$ 中所有字符串长度都恰好为 $M$。且 $N+M$ 恰好为偶数。\n\n如果记 $\\mathcal{S}$ 中字符串全体为 $S_1,S_2,\\dots,S_{Total_S}$，而 $\\mathcal{T}$ 中字符串全体为 $T_1,T_2,\\dots,T_{Total_T}$。现在希望知道有多少对 $\\langle i, j \\rangle$，满足将 $S_i$ 和 $T_j$ 拼接后得到的字符串 $S_i+T_j$ 满足双旋转性。\n\n一个长度为偶数字符串 $W$ 可以表示成两段长度相同的字符串的拼接，即 $W=U+V$。如果 $V$ 可以通过 $U$ 旋转得到，则称 $W$ 是满足双旋转性的。比如说字符串 `vijos` 可以通过旋转得到 `ijosv`,`josvi`,`osvij` 或 `svijo`。那么 `vijosjosvi` 就是满足双旋转性的字符串。", "inputFormat": "第一行输入四个正整数，分别为 $Total_S,Total_T,N,M$，依次表示集合 $\\mathcal{S}$ 的大小，集合 $\\mathcal{T}$ 的大小，集合 $\\mathcal{S}$ 中字符串的长度和集合 $\\mathcal{T}$ 中字符串的长度。\n\n之后 $Total_S$ 行，依次给出 $S$ 中所有的字符串 $S_i$，$1\\le i\\le Total_S$。保证每一个字符串长度都恰为 $N$，且字符串只由 $26$ 个小写字母组成。\n\n之后 $Total_T$ 行，依次给出 $T$ 中所有的字符串 $T_i$，$1\\le i\\le Total_T$。保证每一个字符串长度都恰为 $M$，且字符串只由 $26$ 个小写字母组成。", "outputFormat": "输出一个整数，表示满足要求的数字对 $\\langle i, j \\rangle$ 有多少个。", "hint": "对于 $10\\%$ 的数据，$1\\leq N\\leq 100$，$1\\leq M\\leq 100$，$1\\leq Total_S\\leq 100$，$1\\leq Total_T\\leq 100$。\n\n对于 $30\\%$ 的数据，$1\\leq N\\leq 500$，$1\\leq M\\leq 500$，$1\\leq Total_S\\leq 500$，$1\\leq Total_T\\leq 500$。\n\n对于 $60\\%$ 的数据，$2\\le N\\times Total_S+M\\times Total_T\\le 4\\times 10^5$。\n\n对于 $100\\%$ 的数据，$2\\le N\\times Total_S+M\\times Total_T\\le 4\\times 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2015] Double Rotation Strings", "background": "", "description": "Given two sets of strings $\\mathcal{S}$ and $\\mathcal{T}$. All strings in $\\mathcal{S}$ have length exactly $N$, and all strings in $\\mathcal{T}$ have length exactly $M$. Moreover, $N + M$ is even.\n\nIf we denote all strings in $\\mathcal{S}$ by $S_1, S_2, \\dots, S_{Total_S}$, and all strings in $\\mathcal{T}$ by $T_1, T_2, \\dots, T_{Total_T}$, we want to know how many pairs $\\langle i, j \\rangle$ satisfy that the concatenation $S_i + T_j$ has the double rotation property.\n\nAn even-length string $W$ can be written as the concatenation of two strings of equal length, i.e., $W = U + V$. If $V$ can be obtained from $U$ by a rotation (cyclic shift), then $W$ is said to have the double rotation property. For example, the string `vijos` can be rotated to `ijosv`, `josvi`, `osvij`, or `svijo`. Thus, `vijosjosvi` has the double rotation property.", "inputFormat": "The first line contains four positive integers $Total_S, Total_T, N, M$, denoting respectively the size of set $\\mathcal{S}$, the size of set $\\mathcal{T}$, the length of strings in $\\mathcal{S}$, and the length of strings in $\\mathcal{T}$.\n\nThe next $Total_S$ lines each contain a string $S_i$, $1 \\le i \\le Total_S$. Each string has length exactly $N$, and consists only of the 26 lowercase letters.\n\nThe next $Total_T$ lines each contain a string $T_i$, $1 \\le i \\le Total_T$. Each string has length exactly $M$, and consists only of the 26 lowercase letters.", "outputFormat": "Output a single integer, the number of pairs $\\langle i, j \\rangle$ that satisfy the requirement.", "hint": "For $10\\%$ of the testdata, $1 \\leq N \\leq 100$, $1 \\leq M \\leq 100$, $1 \\leq Total_S \\leq 100$, $1 \\leq Total_T \\leq 100$.\n\nFor $30\\%$ of the testdata, $1 \\leq N \\leq 500$, $1 \\leq M \\leq 500$, $1 \\leq Total_S \\leq 500$, $1 \\leq Total_T \\leq 500$.\n\nFor $60\\%$ of the testdata, $2 \\le N \\times Total_S + M \\times Total_T \\le 4 \\times 10^5$.\n\nFor $100\\%$ of the testdata, $2 \\le N \\times Total_S + M \\times Total_T \\le 4 \\times 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2015] 双旋转字符串", "background": "", "description": "给定两个字符串集合 $\\mathcal{S}$ 和 $\\mathcal{T}$。其中 $S$ 中的所有字符串长度都恰好为 $N$，而 $T$ 中所有字符串长度都恰好为 $M$。且 $N+M$ 恰好为偶数。\n\n如果记 $\\mathcal{S}$ 中字符串全体为 $S_1,S_2,\\dots,S_{Total_S}$，而 $\\mathcal{T}$ 中字符串全体为 $T_1,T_2,\\dots,T_{Total_T}$。现在希望知道有多少对 $\\langle i, j \\rangle$，满足将 $S_i$ 和 $T_j$ 拼接后得到的字符串 $S_i+T_j$ 满足双旋转性。\n\n一个长度为偶数字符串 $W$ 可以表示成两段长度相同的字符串的拼接，即 $W=U+V$。如果 $V$ 可以通过 $U$ 旋转得到，则称 $W$ 是满足双旋转性的。比如说字符串 `vijos` 可以通过旋转得到 `ijosv`,`josvi`,`osvij` 或 `svijo`。那么 `vijosjosvi` 就是满足双旋转性的字符串。", "inputFormat": "第一行输入四个正整数，分别为 $Total_S,Total_T,N,M$，依次表示集合 $\\mathcal{S}$ 的大小，集合 $\\mathcal{T}$ 的大小，集合 $\\mathcal{S}$ 中字符串的长度和集合 $\\mathcal{T}$ 中字符串的长度。\n\n之后 $Total_S$ 行，依次给出 $S$ 中所有的字符串 $S_i$，$1\\le i\\le Total_S$。保证每一个字符串长度都恰为 $N$，且字符串只由 $26$ 个小写字母组成。\n\n之后 $Total_T$ 行，依次给出 $T$ 中所有的字符串 $T_i$，$1\\le i\\le Total_T$。保证每一个字符串长度都恰为 $M$，且字符串只由 $26$ 个小写字母组成。", "outputFormat": "输出一个整数，表示满足要求的数字对 $\\langle i, j \\rangle$ 有多少个。", "hint": "对于 $10\\%$ 的数据，$1\\leq N\\leq 100$，$1\\leq M\\leq 100$，$1\\leq Total_S\\leq 100$，$1\\leq Total_T\\leq 100$。\n\n对于 $30\\%$ 的数据，$1\\leq N\\leq 500$，$1\\leq M\\leq 500$，$1\\leq Total_S\\leq 500$，$1\\leq Total_T\\leq 500$。\n\n对于 $60\\%$ 的数据，$2\\le N\\times Total_S+M\\times Total_T\\le 4\\times 10^5$。\n\n对于 $100\\%$ 的数据，$2\\le N\\times Total_S+M\\times Total_T\\le 4\\times 10^6$。", "locale": "zh-CN"}}}
{"pid": "P3319", "type": "P", "difficulty": 7, "samples": [["9 0\n1 2\n1 3\n1 4\n1 5\n2 6\n2 7\n2 8\n2 9\n2.5", "0.253"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2015", "各省省选", "山东"], "title": "[SDOI2015] 嫁接树", "background": "", "description": "Alice 设计了一个树结构，有 $N$ 个结点（包括根）被依次编号为 $1$ 到 $N$，由 $N-1$ 条边连接。后来，Bob 在上面增加了 $K$ 条原来没有的边（也就是说既不是自环，也不会因此产生重边）并称这样得到的图为” $K$-嫁接树“。\n\n现在 Alice 希望对嫁接树的每一个结点进行染色，允许使用的颜色恰有 $N$ 种，分别编号为 $1$ 到 $N$。Alice 要求相邻两个结点要涂上不同的颜色。假设颜色为 $i$ 的结点有 $t_i$ 个，则 Bob 给出了如下的评价分数：\n\n$$\\mathit{score}=\\dfrac{t_1+\\dfrac{1}{2}t_2+\\dfrac{1}{3}t_3+\\cdots+\\dfrac{1}{N}t_N}{1+P\\times (t_1+2t_2+3t_3+\\cdots+Nt_N)}$$\n\n其中 $P$ 为非负系数。现在，Alice 希望可以找到一种染色方案，使得 Bob 给出来的评分最大。你能帮助他吗？", "inputFormat": "第一行有 $2$ 个整数，依次为 $N$ 和 $K$，如题所述。第二行到第 $N+K$ 行，每行有两个整数 $u$ 和 $v$，依次给出了 $N+K-1$ 条边。**其中，首先给出 $N - 1$ 条树边，其次给出新增加的边**。保证不存在自环，也不存在重边。最后一行给定非负浮点数 $P$。\n\n$K \\le 2$，$1 \\le N \\le 2 \\times 10^5$，$0 \\le P<10$。", "outputFormat": "输出最大的可能评分，四舍五入保留到小数点后第三位。\n", "hint": "2024-10-11 update: 更新了数据精度问题 ", "locale": "zh-CN", "translations": {"en": {"title": "{{[SDOI2015] Grafting Tree}}", "background": "{{}}", "description": "{{Alice designed a tree with $N$ nodes (including the root), numbered consecutively from $1$ to $N$, connected by $N - 1$ edges. Later, Bob added $K$ new edges that did not exist before (i.e., they are neither self-loops nor parallel edges), and called the resulting graph a \"$K$-grafted tree\".\n\nNow Alice wants to color every node of the grafted tree using exactly $N$ available colors, numbered $1$ to $N$. Adjacent nodes must be colored differently. Suppose the number of nodes colored with color $i$ is $t_i$. Bob gives the following score:\n$$\\mathit{score}=\\dfrac{t_1+\\dfrac{1}{2}t_2+\\dfrac{1}{3}t_3+\\cdots+\\dfrac{1}{N}t_N}{1+P\\times (t_1+2t_2+3t_3+\\cdots+Nt_N)}$$\nHere $P$ is a non-negative coefficient. Alice wants to find a coloring that maximizes Bob’s score. Can you help her?}}", "inputFormat": "{{The first line contains $2$ integers $N$ and $K$, as described. Lines $2$ through $N+K$ each contain two integers $u$ and $v$, giving the $N+K-1$ edges. **First, the $N - 1$ tree edges are given, then the newly added edges.** There are no self-loops or parallel edges. The last line contains a non-negative floating-point number $P$.\n\n$K \\le 2$, $1 \\le N \\le 2 \\times 10^5$, $0 \\le P < 10$.}}", "outputFormat": "{{Output the maximum possible score, rounded to three decimal places.}}", "hint": "{{2024-10-11 update: Updated the testdata precision issue.}}\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2015] 嫁接树", "background": "", "description": "Alice 设计了一个树结构，有 $N$ 个结点（包括根）被依次编号为 $1$ 到 $N$，由 $N-1$ 条边连接。后来，Bob 在上面增加了 $K$ 条原来没有的边（也就是说既不是自环，也不会因此产生重边）并称这样得到的图为” $K$-嫁接树“。\n\n现在 Alice 希望对嫁接树的每一个结点进行染色，允许使用的颜色恰有 $N$ 种，分别编号为 $1$ 到 $N$。Alice 要求相邻两个结点要涂上不同的颜色。假设颜色为 $i$ 的结点有 $t_i$ 个，则 Bob 给出了如下的评价分数：\n\n$$\\mathit{score}=\\dfrac{t_1+\\dfrac{1}{2}t_2+\\dfrac{1}{3}t_3+\\cdots+\\dfrac{1}{N}t_N}{1+P\\times (t_1+2t_2+3t_3+\\cdots+Nt_N)}$$\n\n其中 $P$ 为非负系数。现在，Alice 希望可以找到一种染色方案，使得 Bob 给出来的评分最大。你能帮助他吗？", "inputFormat": "第一行有 $2$ 个整数，依次为 $N$ 和 $K$，如题所述。第二行到第 $N+K$ 行，每行有两个整数 $u$ 和 $v$，依次给出了 $N+K-1$ 条边。**其中，首先给出 $N - 1$ 条树边，其次给出新增加的边**。保证不存在自环，也不存在重边。最后一行给定非负浮点数 $P$。\n\n$K \\le 2$，$1 \\le N \\le 2 \\times 10^5$，$0 \\le P<10$。", "outputFormat": "输出最大的可能评分，四舍五入保留到小数点后第三位。\n", "hint": "2024-10-11 update: 更新了数据精度问题 ", "locale": "zh-CN"}}}
{"pid": "P3320", "type": "P", "difficulty": 6, "samples": [["4 5\n1 2 30\n2 3 50\n2 4 60\n2\n3\n4\n2\n1", "0\n100\n220\n220\n280"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "各省省选", "山东", "深度优先搜索 DFS", "最近公共祖先 LCA", "虚树"], "title": "[SDOI2015] 寻宝游戏", "background": "", "description": "小 B 最近正在玩一个寻宝游戏，这个游戏的地图中有 $N$ 个村庄和 $N-1$ 条道路，并且任何两个村庄之间有且仅有一条路径可达。游戏开始时，玩家可以任意选择一个村庄，瞬间转移到这个村庄，然后可以任意在地图的道路上行走，若走到某个村庄中有宝物，则视为找到该村庄内的宝物，直到找到所有宝物并返回到最初转移到的村庄为止。\n\n小 B 希望评测一下这个游戏的难度，因此他需要知道玩家找到所有宝物需要行走的最短路程。但是这个游戏中宝物经常变化，有时某个村庄中会突然出现宝物，有时某个村庄内的宝物会突然消失，因此小 B 需要不断地更新数据，但是小 B 太懒了，不愿意自己计算，因此他向你求助。为了简化问题，我们认为最开始时所有村庄内均没有宝物。", "inputFormat": "第一行，两个整数 $N,M$，其中 $M$ 为宝物的变动次数。\n\n接下来的 $N-1$ 行，每行三个整数 $x,y,z$，表示村庄 $x,y$ 之间有一条长度为 $z$ 的道路。\n\n接下来的 $M$ 行，每行一个整数 $t$，表示一个宝物变动的操作。若该操作前村庄 $t$ 内没有宝物，则操作后村庄内有宝物；若该操作前村庄 $t$ 内有宝物，则操作后村庄内没有宝物。", "outputFormat": "$M$ 行，每行一个整数，其中第 $i$ 行的整数表示第 $i$ 次操作之后玩家找到所有宝物需要行走的最短路程。若只有一个村庄内有宝物，或者所有村庄内都没有宝物，则输出 `0`。", "hint": "- 对于 $10\\%$ 的数据，$1 \\leq N \\leq 100, 1 \\leq M \\leq 100$；\n- 对于 $20\\%$ 的数据，$1 \\leq N \\leq 1000, 1 \\leq M \\leq 1000$；\n- 对于另外 $15\\%$ 的数据，每个村庄最多成为两条道路的端点；\n- 对于 $100\\%$ 的数据，$1 \\leq N \\leq 100000,\\ 1 \\leq M \\leq 100000,\\ 1 \\leq z \\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2015] Treasure Hunt", "background": "", "description": "Xiao B is playing a treasure hunt game. The map has $N$ villages and $N-1$ roads, and there is exactly one path between any two villages. At the beginning, the player may choose any village and instantly teleport to it, then walk arbitrarily along the roads on the map. If the player reaches a village that contains a treasure, that treasure is considered found. The process continues until all treasures are found and the player returns to the village they initially teleported to.\n\nXiao B wants to evaluate the difficulty of this game, so he needs to know the shortest distance a player must walk to find all treasures. However, the treasures in this game change frequently: sometimes a treasure suddenly appears in a village, and sometimes a treasure in a village suddenly disappears. Therefore, Xiao B needs to update the data continuously. Since he is too lazy to do the calculations himself, he asks for your help. To simplify the problem, assume that initially no village contains a treasure.", "inputFormat": "The first line contains two integers $N, M$, where $M$ is the number of treasure changes.\n\nThe next $N-1$ lines each contain three integers $x, y, z$, indicating that there is a road of length $z$ between villages $x$ and $y$.\n\nThe next $M$ lines each contain one integer $t$, representing a treasure toggle operation. If before this operation village $t$ does not contain a treasure, then after the operation it contains a treasure; if before the operation village $t$ contains a treasure, then after the operation it does not.", "outputFormat": "Output $M$ lines, each containing one integer. The integer on the $i$-th line is the shortest distance the player needs to walk to find all treasures after the $i$-th operation. If there is only one village with a treasure, or no village has a treasure, output `0`.", "hint": "- For 10% of the testdata, $1 \\leq N \\leq 100, 1 \\leq M \\leq 100$.\n- For 20% of the testdata, $1 \\leq N \\leq 1000, 1 \\leq M \\leq 1000$.\n- For another 15% of the testdata, each village is incident to at most two roads.\n- For 100% of the testdata, $1 \\leq N \\leq 100000,\\ 1 \\leq M \\leq 100000,\\ 1 \\leq z \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2015] 寻宝游戏", "background": "", "description": "小 B 最近正在玩一个寻宝游戏，这个游戏的地图中有 $N$ 个村庄和 $N-1$ 条道路，并且任何两个村庄之间有且仅有一条路径可达。游戏开始时，玩家可以任意选择一个村庄，瞬间转移到这个村庄，然后可以任意在地图的道路上行走，若走到某个村庄中有宝物，则视为找到该村庄内的宝物，直到找到所有宝物并返回到最初转移到的村庄为止。\n\n小 B 希望评测一下这个游戏的难度，因此他需要知道玩家找到所有宝物需要行走的最短路程。但是这个游戏中宝物经常变化，有时某个村庄中会突然出现宝物，有时某个村庄内的宝物会突然消失，因此小 B 需要不断地更新数据，但是小 B 太懒了，不愿意自己计算，因此他向你求助。为了简化问题，我们认为最开始时所有村庄内均没有宝物。", "inputFormat": "第一行，两个整数 $N,M$，其中 $M$ 为宝物的变动次数。\n\n接下来的 $N-1$ 行，每行三个整数 $x,y,z$，表示村庄 $x,y$ 之间有一条长度为 $z$ 的道路。\n\n接下来的 $M$ 行，每行一个整数 $t$，表示一个宝物变动的操作。若该操作前村庄 $t$ 内没有宝物，则操作后村庄内有宝物；若该操作前村庄 $t$ 内有宝物，则操作后村庄内没有宝物。", "outputFormat": "$M$ 行，每行一个整数，其中第 $i$ 行的整数表示第 $i$ 次操作之后玩家找到所有宝物需要行走的最短路程。若只有一个村庄内有宝物，或者所有村庄内都没有宝物，则输出 `0`。", "hint": "- 对于 $10\\%$ 的数据，$1 \\leq N \\leq 100, 1 \\leq M \\leq 100$；\n- 对于 $20\\%$ 的数据，$1 \\leq N \\leq 1000, 1 \\leq M \\leq 1000$；\n- 对于另外 $15\\%$ 的数据，每个村庄最多成为两条道路的端点；\n- 对于 $100\\%$ 的数据，$1 \\leq N \\leq 100000,\\ 1 \\leq M \\leq 100000,\\ 1 \\leq z \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P3321", "type": "P", "difficulty": 6, "samples": [["4 3 1 2\n1 2", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "各省省选", "山东", "素数判断,质数,筛法", "快速傅里叶变换 FFT", "快速数论变换 NTT"], "title": "[SDOI2015] 序列统计", "background": null, "description": "小 C 有一个集合 $S$，里面的元素都是小于 $m$ 的非负整数。他用程序编写了一个数列生成器，可以生成一个长度为 $n$ 的数列，数列中的每个数都属于集合 $S$。  \n\n小 C 用这个生成器生成了许多这样的数列。但是小 C 有一个问题需要你的帮助：给定整数 $x$，求所有可以生成出的，且满足数列中所有数的乘积 $\\bmod \\ m$ 的值等于 $x$ 的不同的数列的有多少个。  \n\n小 C 认为，两个数列 $A$ 和 $B$ 不同，当且仅当 $\\exists i \\text{ s.t. } A_i \\neq B_i$。另外，小 C 认为这个问题的答案可能很大，因此他只需要你帮助他求出答案对 $1004535809$ 取模的值就可以了。", "inputFormat": "一行，四个整数，$n,m,x,|S|$，其中 $|S|$ 为集合 $S$ 中元素个数。  \n第二行，$|S|$ 个整数，表示集合 $S$ 中的所有元素。", "outputFormat": "一行一个整数表示答案。", "hint": "【样例说明】\n\n可以生成的满足要求的不同的数列有 $(1,1,1,1)$、$(1,1,2,2)$、$(1,2,1,2)$、$(1,2,2,1)$、$(2,1,1,2)$、$(2,1,2,1)$、$(2,2,1,1)$、$(2,2,2,2)$。\n\n【数据规模和约定】\n\n对于 $10\\%$ 的数据，$1\\le n \\le 1000$；   \n对于 $30\\%$ 的数据，$3 \\le m \\le 100$；    \n对于 $60\\%$ 的数据，$3 \\le m \\le 800$；   \n对于 $100\\%$ 的数据，$1 \\le n \\le 10^9$，$3 \\le m \\le 8000$，$1\\le x < m$。   \n$m$ 为质数，输入数据保证集合 $S$ 中元素不重复。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2015] Sequence Statistics", "background": "", "description": "Xiao C has a set $S$ whose elements are non-negative integers less than $m$. He wrote a sequence generator that can generate a sequence of length $n$, where every term belongs to the set $S$.\n\nXiao C generated many such sequences. However, he needs your help with the following question: given an integer $x$, count how many different sequences can be generated such that the product of all numbers in the sequence $\\bmod \\ m$ equals $x$.\n\nXiao C considers two sequences $A$ and $B$ different if and only if $\\exists i \\text{ s.t. } A_i \\neq B_i$. Since the answer may be large, he only needs the answer modulo $1004535809$.", "inputFormat": "One line with four integers $n, m, x, |S|$, where $|S|$ is the number of elements in the set $S$.  \nThe second line contains $|S|$ integers, representing all elements of the set $S$.", "outputFormat": "Output a single integer on one line, representing the answer.", "hint": "Sample explanation:\n\nThe different sequences that can be generated and satisfy the requirement are $(1,1,1,1)$, $(1,1,2,2)$, $(1,2,1,2)$, $(1,2,2,1)$, $(2,1,1,2)$, $(2,1,2,1)$, $(2,2,1,1)$, $(2,2,2,2)$.\n\nConstraints:\n\nFor $10\\%$ of the testdata, $1 \\le n \\le 1000$.  \nFor $30\\%$ of the testdata, $3 \\le m \\le 100$.  \nFor $60\\%$ of the testdata, $3 \\le m \\le 800$.  \nFor $100\\%$ of the testdata, $1 \\le n \\le 10^9$, $3 \\le m \\le 8000$, $1 \\le x < m$.  \n$m$ is a prime, and the input guarantees that the elements in set $S$ are distinct.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2015] 序列统计", "background": null, "description": "小 C 有一个集合 $S$，里面的元素都是小于 $m$ 的非负整数。他用程序编写了一个数列生成器，可以生成一个长度为 $n$ 的数列，数列中的每个数都属于集合 $S$。  \n\n小 C 用这个生成器生成了许多这样的数列。但是小 C 有一个问题需要你的帮助：给定整数 $x$，求所有可以生成出的，且满足数列中所有数的乘积 $\\bmod \\ m$ 的值等于 $x$ 的不同的数列的有多少个。  \n\n小 C 认为，两个数列 $A$ 和 $B$ 不同，当且仅当 $\\exists i \\text{ s.t. } A_i \\neq B_i$。另外，小 C 认为这个问题的答案可能很大，因此他只需要你帮助他求出答案对 $1004535809$ 取模的值就可以了。", "inputFormat": "一行，四个整数，$n,m,x,|S|$，其中 $|S|$ 为集合 $S$ 中元素个数。  \n第二行，$|S|$ 个整数，表示集合 $S$ 中的所有元素。", "outputFormat": "一行一个整数表示答案。", "hint": "【样例说明】\n\n可以生成的满足要求的不同的数列有 $(1,1,1,1)$、$(1,1,2,2)$、$(1,2,1,2)$、$(1,2,2,1)$、$(2,1,1,2)$、$(2,1,2,1)$、$(2,2,1,1)$、$(2,2,2,2)$。\n\n【数据规模和约定】\n\n对于 $10\\%$ 的数据，$1\\le n \\le 1000$；   \n对于 $30\\%$ 的数据，$3 \\le m \\le 100$；    \n对于 $60\\%$ 的数据，$3 \\le m \\le 800$；   \n对于 $100\\%$ 的数据，$1 \\le n \\le 10^9$，$3 \\le m \\le 8000$，$1\\le x < m$。   \n$m$ 为质数，输入数据保证集合 $S$ 中元素不重复。", "locale": "zh-CN"}}}
{"pid": "P3322", "type": "P", "difficulty": 5, "samples": [["3\n7 8 5 6 1 2 4 3", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2015", "各省省选", "山东", "排序", "深度优先搜索 DFS"], "title": "[SDOI2015] 排序", "background": null, "description": "小 A 有一个 $1\\sim 2^N$ 的排列 $A_1\\sim A_{2^N}$，他希望将 $A$ 数组从小到大排序,小 $A$ 可以执行的操作有 $N$ 种，每种操作最多可以执行一次，对于所有的 $i(1\\le i\\le N)$，第 $i$ 种操作为将序列从左到右划分为 $2^{N-i+1}$ 段，每段恰好包括 $2^{i-1}$ 个数,然后整体交换其中两段。\n\n小 A 想知道可以将数组 $A$ 从小到大排序的不同的操作序列有多少个。小 A 认为两个操作序列不同，当且仅当操作个数不同，或者至少一个操作不同（种类不同或者操作位置不同）。\n\n下面是一个操作示例: $N=3,A=[3,6,1,2,7,8,5,4]$。\n- 第一次操作，执行第 $3$ 种操作，交换 $A[1..4]$ 和 $A[5..8]$，交换后的 $A$ 为$[7,8,5,4,3,6,1,2]$。\n- 第二次操作，执行第 $1$ 种操作，交换 $A[3]$ 和 $A[5]$，交换后的 $A$ 为$[7,8,3,4,5,6,1,2]$。\n- 第三次操作，执行第 $2$ 种操作，交换 $A[1..2]$ 和 $A[7..8]$，交换后的 $A[1..8]$ 为$[1,2,3,4,5,6,7,8]$。", "inputFormat": "第一行，一个整数 $N$。\n\n第二行，$2^N$ 个整数，$A_1\\sim A_{2^N}$。", "outputFormat": "一个整数表示答案。", "hint": "$100\\%$ 的数据, $1\\le N\\le 12$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2015] Sorting", "background": "", "description": "Xiao A has a permutation $A_1$ through $A_{2^N}$ of $1$ through $2^N$. He wants to sort array $A$ in ascending order. Xiao A can perform $N$ types of operations, and each type can be used at most once. For every $i$ ($1 \\le i \\le N$), the $i$-th operation splits the sequence from left to right into $2^{N-i+1}$ blocks, each containing exactly $2^{i-1}$ numbers, and then swaps two of these blocks as a whole.\n\nXiao A wants to know how many different sequences of operations can sort array $A$ in ascending order. Two sequences of operations are considered different if and only if the number of operations is different, or at least one operation is different (either the type or the positions are different).\n\nHere is an example of operations: $N = 3$, $A = [3,6,1,2,7,8,5,4]$.\n- First operation: perform the 3rd operation, swap A[1..4] and A[5..8]. After the swap, $A = [7,8,5,4,3,6,1,2]$.\n- Second operation: perform the 1st operation, swap A[3] and A[5]. After the swap, $A = [7,8,3,4,5,6,1,2]$.\n- Third operation: perform the 2nd operation, swap A[1..2] and A[7..8]. After the swap, $A[1..8] = [1,2,3,4,5,6,7,8]$.", "inputFormat": "The first line contains an integer $N$.\n\nThe second line contains $2^N$ integers, $A_1$ through $A_{2^N}$.", "outputFormat": "Output a single integer denoting the answer.", "hint": "Constraints: For 100% of the testdata, $1 \\le N \\le 12$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2015] 排序", "background": null, "description": "小 A 有一个 $1\\sim 2^N$ 的排列 $A_1\\sim A_{2^N}$，他希望将 $A$ 数组从小到大排序,小 $A$ 可以执行的操作有 $N$ 种，每种操作最多可以执行一次，对于所有的 $i(1\\le i\\le N)$，第 $i$ 种操作为将序列从左到右划分为 $2^{N-i+1}$ 段，每段恰好包括 $2^{i-1}$ 个数,然后整体交换其中两段。\n\n小 A 想知道可以将数组 $A$ 从小到大排序的不同的操作序列有多少个。小 A 认为两个操作序列不同，当且仅当操作个数不同，或者至少一个操作不同（种类不同或者操作位置不同）。\n\n下面是一个操作示例: $N=3,A=[3,6,1,2,7,8,5,4]$。\n- 第一次操作，执行第 $3$ 种操作，交换 $A[1..4]$ 和 $A[5..8]$，交换后的 $A$ 为$[7,8,5,4,3,6,1,2]$。\n- 第二次操作，执行第 $1$ 种操作，交换 $A[3]$ 和 $A[5]$，交换后的 $A$ 为$[7,8,3,4,5,6,1,2]$。\n- 第三次操作，执行第 $2$ 种操作，交换 $A[1..2]$ 和 $A[7..8]$，交换后的 $A[1..8]$ 为$[1,2,3,4,5,6,7,8]$。", "inputFormat": "第一行，一个整数 $N$。\n\n第二行，$2^N$ 个整数，$A_1\\sim A_{2^N}$。", "outputFormat": "一个整数表示答案。", "hint": "$100\\%$ 的数据, $1\\le N\\le 12$。", "locale": "zh-CN"}}}
{"pid": "P3323", "type": "P", "difficulty": 7, "samples": [["1\n5 6 4\n1 2\n2 3\n3 5\n1 4\n4 5\n2 5", "NYYYY \nYNNYY \nYNNYN \nYYYNY \nYYNYN"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2015", "各省省选", "山东", "枚举"], "title": "[SDOI2015] 旅行计划", "background": "", "description": "在有 $N$ 座城市的国度，Alice 希望可以开始一场充满传奇的旅行。TA 希望可以从一个城市出发开始旅行，每次前往一个相邻的城市，途中不重复得经过恰好 $K$ 座城市，最后抵达另外一个城市并结束旅行。\n\n需要注意的是，起点与终点也被考虑为经过的城市，也就是说包括起点和终点在内经过的所有城市都是不能重复的。现在，Alice 希望知道哪些城市对 $(u,v)$ 可以作为合法的旅行起点与终点。\n", "inputFormat": "本题每一个测试点有多组测试数据。\n\n第一行给定正整数 $T$ ，表示数据组数。\n\n对于每一组数据来说，第一行给定三个整数 $N$，$M$ 和 $K$，表示城市个数，城市之间的相邻关系个数，还有旅途应该经过的城市个数。\n\n接下来 $M$ 行．每一行给定两个整数 $u$ 和 $v$ ，表示标号为 $u$ 的城市与标号为 $v$ 的城市之间是相邻的，即可以从其中一个城市出发前往另外一个。\n\n$N\\le 1000$，$M\\le 5000$，$2\\le K\\le 7$ 且 $T\\times \\left\\lfloor \\frac k 2 \\right\\rfloor^{\\left\\lfloor \\frac k 2 \\right\\rfloor}\\le 60$\n", "outputFormat": "对于每一组数据，输出 $N$ 行，每行 $N$ 个字符，其中第 $i$ 行第 $j$ 个字符，或者为 `Y` 或者为 `N`，分别表示是否存在从城市 $i$ 出发到城市 $j$ 结束的合法旅行方案。\n", "hint": "24.11.15：增加了 hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2015] Travel Plan", "background": "", "description": "In a country with $N$ cities, Alice wants to embark on a legendary journey. They wish to start from a city, each time moving to an adjacent city, visit exactly $K$ cities without repetition along the way, and finally arrive at another city to end the journey.\n\nNote that the starting city and the ending city are also counted among the visited cities. That is, including the start and end, all visited cities must be distinct. Now, Alice wants to know which ordered city pairs $(u, v)$ can serve as a valid start and end for such a journey.", "inputFormat": "Each test file contains multiple test cases.\n\nThe first line contains a positive integer $T$, the number of test cases.\n\nFor each test case, the first line contains three integers $N$, $M$, and $K$, denoting the number of cities, the number of adjacency relations between cities, and the number of cities that the trip should visit.\n\nThe next $M$ lines each contain two integers $u$ and $v$, indicating that city $u$ and city $v$ are adjacent, i.e., you can travel from either city to the other.\n\n$N\\le 1000$, $M\\le 5000$, $2\\le K\\le 7$, and $T\\times \\left\\lfloor \\frac k 2 \\right\\rfloor^{\\left\\lfloor \\frac k 2 \\right\\rfloor}\\le 60$.", "outputFormat": "For each test case, output $N$ lines, each containing $N$ characters. In the $i$-th row, the $j$-th character is either `Y` or `N`, indicating whether there exists a valid travel plan starting from city $i$ and ending at city $j$.", "hint": "2024-11-15: Added hack testdata.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2015] 旅行计划", "background": "", "description": "在有 $N$ 座城市的国度，Alice 希望可以开始一场充满传奇的旅行。TA 希望可以从一个城市出发开始旅行，每次前往一个相邻的城市，途中不重复得经过恰好 $K$ 座城市，最后抵达另外一个城市并结束旅行。\n\n需要注意的是，起点与终点也被考虑为经过的城市，也就是说包括起点和终点在内经过的所有城市都是不能重复的。现在，Alice 希望知道哪些城市对 $(u,v)$ 可以作为合法的旅行起点与终点。\n", "inputFormat": "本题每一个测试点有多组测试数据。\n\n第一行给定正整数 $T$ ，表示数据组数。\n\n对于每一组数据来说，第一行给定三个整数 $N$，$M$ 和 $K$，表示城市个数，城市之间的相邻关系个数，还有旅途应该经过的城市个数。\n\n接下来 $M$ 行．每一行给定两个整数 $u$ 和 $v$ ，表示标号为 $u$ 的城市与标号为 $v$ 的城市之间是相邻的，即可以从其中一个城市出发前往另外一个。\n\n$N\\le 1000$，$M\\le 5000$，$2\\le K\\le 7$ 且 $T\\times \\left\\lfloor \\frac k 2 \\right\\rfloor^{\\left\\lfloor \\frac k 2 \\right\\rfloor}\\le 60$\n", "outputFormat": "对于每一组数据，输出 $N$ 行，每行 $N$ 个字符，其中第 $i$ 行第 $j$ 个字符，或者为 `Y` 或者为 `N`，分别表示是否存在从城市 $i$ 出发到城市 $j$ 结束的合法旅行方案。\n", "hint": "24.11.15：增加了 hack 数据。", "locale": "zh-CN"}}}
{"pid": "P3324", "type": "P", "difficulty": 6, "samples": [["2 2\n3 10\n4 6\n0 1\n1 1", "1.300000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "二分", "各省省选", "网络流", "山东", "Special Judge"], "title": "[SDOI2015] 星际战争", "background": null, "description": "$3333$ 年，在银河系的某星球上，X 军团和 Y 军团正在激烈地作战。\n\n在战斗的某一阶段，Y 军团一共派遣了 $N$ 个巨型机器人进攻 X 军团的阵地，其中第 $i$ 个巨型机器人的装甲值为 $A_i$。当一个巨型机器人的装甲值减少到 $0$ 或者以下时，这个巨型机器人就被摧毁了。\n\nX 军团有 $M$ 个激光武器，其中第 $i$ 个激光武器每秒可以削减一个巨型机器人 $B_i$ 的装甲值。激光武器的攻击是连续的。\n\n这种激光武器非常奇怪，一个激光武器只能攻击一些特定的敌人。Y 军团看到自己的巨型机器人被 X 军团一个一个消灭，他们急需下达更多的指令。\n\n为了这个目标，Y 军团需要知道 X 军团最少需要用多长时间才能将 Y 军团的所有巨型机器人摧毁。但是他们不会计算这个问题，因此向你求助。", "inputFormat": "第一行，两个整数，$N,M$。\n\n第二行，$N$ 个整数，$A_1,A_2 \\cdots A_N$。\n\n第三行，$M$ 个整数，$B_1,B_2 \\cdots B_M$。\n\n接下来的 $M$ 行，每行 $N$ 个整数，这些整数均为 $0$ 或者 $1$。这部分中的第 $i$ 行的第 $j$ 个整数为 $0$ 表示第 $i$ 个激光武器不可以攻击第 $j$ 个巨型机器人，为 $1$ 表示第 $i$ 个激光武器可以攻击第 $j$ 个巨型机器人。", "outputFormat": "一行，一个实数，表示 X 军团要摧毁 Y 军团的所有巨型机器人最少需要的时间。输出结果与标准答案的绝对误差不超过 $10^{-3}$ 即视为正确。", "hint": "**【样例说明1】**\n\n战斗开始后的前 $0.5$ 秒，激光武器 $1$ 攻击 $2$ 号巨型机器人，激光武器 $2$ 攻击 $1$ 号巨型机器人。$1$ 号巨型机器人被完全摧毁，$2$ 号巨型机器人还剩余 $8$ 的装甲值；\n\n接下来的 $0.8$ 秒，激光武器 $1$ 、 $2$ 同时攻击 $2$ 号巨型机器人。$2$ 号巨型机器人被完全摧毁。\n\n**【数据范围】**\n\n对于全部的数据，$1 \\le N,M \\le 50$，$1 \\le A_i \\le 10^5$，$1 \\le B_i \\le 1000$，输入数据保证 X 军团一定能摧毁 Y 军团的所有巨型机器人。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2015] Interstellar War", "background": "", "description": "In the year $3333$, on a certain planet in the Milky Way, the X Legion and the Y Legion are fighting fiercely.\n\nAt a certain stage of the battle, the Y Legion sends $N$ giant robots to attack the X Legion’s position. The $i$-th giant robot has an armor value of $A_i$. When a robot’s armor value drops to $0$ or below, the robot is destroyed.\n\nThe X Legion has $M$ laser weapons. The $i$-th laser weapon can reduce the armor of a single giant robot by $B_i$ per second. The laser weapons’ attacks are continuous over time.\n\nThese laser weapons are peculiar: each weapon can attack only certain designated enemies. Seeing their robots being destroyed one after another, the Y Legion urgently needs to issue more commands.\n\nTo this end, the Y Legion needs to know the minimum time the X Legion requires to destroy all of the Y Legion’s giant robots. However, they cannot compute this themselves, so they ask you for help.", "inputFormat": "The first line contains two integers, $N, M$.\n\nThe second line contains $N$ integers, $A_1, A_2 \\cdots A_N$.\n\nThe third line contains $M$ integers, $B_1, B_2 \\cdots B_M$.\n\nEach of the next $M$ lines contains $N$ integers, each being $0$ or $1$. In this part, the $j$-th integer of the $i$-th line is $0$ if the $i$-th laser weapon cannot attack the $j$-th giant robot, and $1$ if it can.", "outputFormat": "Output a single real number: the minimum time required for the X Legion to destroy all of the Y Legion’s giant robots. Answers with an absolute error not exceeding $10^{-3}$ are accepted.", "hint": "- Sample Explanation 1:\n\nFor the first $0.5$ seconds, laser weapon $1$ attacks robot $2$, and laser weapon $2$ attacks robot $1$. Robot $1$ is completely destroyed; robot $2$ has $8$ armor remaining.\n\nFor the next $0.8$ seconds, laser weapons $1$ and $2$ attack robot $2$ simultaneously. Robot $2$ is completely destroyed.\n\n- Constraints:\n\nFor all testdata, $1 \\le N, M \\le 50$, $1 \\le A_i \\le 10^5$, $1 \\le B_i \\le 1000$, and the input guarantees that the X Legion can destroy all of the Y Legion’s giant robots.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2015] 星际战争", "background": null, "description": "$3333$ 年，在银河系的某星球上，X 军团和 Y 军团正在激烈地作战。\n\n在战斗的某一阶段，Y 军团一共派遣了 $N$ 个巨型机器人进攻 X 军团的阵地，其中第 $i$ 个巨型机器人的装甲值为 $A_i$。当一个巨型机器人的装甲值减少到 $0$ 或者以下时，这个巨型机器人就被摧毁了。\n\nX 军团有 $M$ 个激光武器，其中第 $i$ 个激光武器每秒可以削减一个巨型机器人 $B_i$ 的装甲值。激光武器的攻击是连续的。\n\n这种激光武器非常奇怪，一个激光武器只能攻击一些特定的敌人。Y 军团看到自己的巨型机器人被 X 军团一个一个消灭，他们急需下达更多的指令。\n\n为了这个目标，Y 军团需要知道 X 军团最少需要用多长时间才能将 Y 军团的所有巨型机器人摧毁。但是他们不会计算这个问题，因此向你求助。", "inputFormat": "第一行，两个整数，$N,M$。\n\n第二行，$N$ 个整数，$A_1,A_2 \\cdots A_N$。\n\n第三行，$M$ 个整数，$B_1,B_2 \\cdots B_M$。\n\n接下来的 $M$ 行，每行 $N$ 个整数，这些整数均为 $0$ 或者 $1$。这部分中的第 $i$ 行的第 $j$ 个整数为 $0$ 表示第 $i$ 个激光武器不可以攻击第 $j$ 个巨型机器人，为 $1$ 表示第 $i$ 个激光武器可以攻击第 $j$ 个巨型机器人。", "outputFormat": "一行，一个实数，表示 X 军团要摧毁 Y 军团的所有巨型机器人最少需要的时间。输出结果与标准答案的绝对误差不超过 $10^{-3}$ 即视为正确。", "hint": "**【样例说明1】**\n\n战斗开始后的前 $0.5$ 秒，激光武器 $1$ 攻击 $2$ 号巨型机器人，激光武器 $2$ 攻击 $1$ 号巨型机器人。$1$ 号巨型机器人被完全摧毁，$2$ 号巨型机器人还剩余 $8$ 的装甲值；\n\n接下来的 $0.8$ 秒，激光武器 $1$ 、 $2$ 同时攻击 $2$ 号巨型机器人。$2$ 号巨型机器人被完全摧毁。\n\n**【数据范围】**\n\n对于全部的数据，$1 \\le N,M \\le 50$，$1 \\le A_i \\le 10^5$，$1 \\le B_i \\le 1000$，输入数据保证 X 军团一定能摧毁 Y 军团的所有巨型机器人。", "locale": "zh-CN"}}}
{"pid": "P3325", "type": "P", "difficulty": 7, "samples": [["5\nCC/..\n././/\n..C.C\n/.C..\n/./C/\n1 1\n1 2\n1 3\n1 4\n1 5\n0.3 0.3 0.3 0.3 0.3\n0.3 0.3 0.3 0.3 0.3", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "各省省选", "山东"], "title": "[SDOI2015] 模拟电路", "background": "", "description": "一家著名的芯片公司希望您能帮他们在一些最新的产品上安装可以稳定电压的组件。每块芯片都被设计成 $N\\times M$ 的带插槽的正方形，一个插槽可以安装一块单独的组件，你的任务是尽可能多地插入这些组件。\n\n现代处理器的设计是很复杂的。为了可以稳定电压，你要面对下面几个限制：一些插槽是不可用的。一些插槽已经被其它的组件占据了，因而无法被新的组件使用。内存总线要连接到芯片的水平和垂直的边界上，它们的负载电压需要是安全的。\n\n具体来说，芯片公司提供了 $N$ 组限制条件，分别对应了 $N$ 行。其中对于第 $i$ 行以及第 $i$ 组限制条件，给定非负整数 $T_i$ 与 $T_i$ 个列编号，记为 $r_{i,j}$（$1\\le j\\le T_i$），要求满足：第 $i$ 行的组件数目不能超过指定的 $T_i$ 个列方向上组件数目的和（也就是不超过“第 $r_{i,1}$ 列的组件数目 $+$ 第 $r_{i,2}$ 列的组件数目 $+$ $\\cdots$”）。为了避免插槽过热，给定浮点数 $s_i$（$1\\le i\\le N$） 且 $0\\le s_i\\le 1$，要求第 $i$ 行的组件数不超过总组件数的 $s_i$。同样给定浮点数 $t_i$（$1\\le i\\le N$）且 $0\\le T_i\\le 1$，要求第 $i$ 列的组件数不超过总组件数的 $t_i$。\n\n需要注意的是，已经占据了位置的组件，在统计一行或一列组件总数时，也是要被考虑在内的。而在计算芯片总组件数时．也要将已经占据了位置的组件考虑进去。芯片被描述为一个 $N$ 行，每行 $N$ 个字符的矩阵，其中 `.` 表示开放插槽，`/` 表示不可用插槽，`C` 表示插槽已被一个组件占据。\n", "inputFormat": "第一行给定 $1$ 个正整数，表示芯片的规模 $N$（$1\\le N\\le 40$）。\n\n然后给出 $N$ 行，每行 $N$ 个字符描述插槽，字符为 `.` ， `/` 或 `C` 之一，含义如上所述。\n\n之后 $N$ 行，描述了限制条件。其中第 $i$ 行首先给出非负整数 $T_i$，表示第 $i$ 行的限制条件涉及到的列的个数。之后再给出 $T_i$ 个不重复的整数（都在 $1$ 到 $N$ 的范围中），描述了相关的列。\n\n再下一行，给出了 $N$ 个浮点数依次对应 $s_i$。每一个数字小数点后不超过三位。\n\n再下一行，给出了 $N$ 个浮点数依次对应 $t_i$。每一个数字小数点后不超过三位。\n", "outputFormat": "如果存在合法的策略，输出最多可以再在芯片上安装多少个组件。否则输出 `impossible`。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2015] Analog Circuit", "background": "", "description": "A well-known chip company asks you to help install components that stabilize voltage on some of their latest products. Each chip is designed as an $N \\times N$ grid of slots; a slot can hold a single component. Your task is to insert as many new components as possible.\n\nModern processors are complex. To keep the voltage stable, you must obey several restrictions: some slots are unusable; some slots are already occupied by other components and thus cannot be used for new ones; memory buses attach to the horizontal and vertical boundaries of the chip, and their load voltages must be safe.\n\nSpecifically, the company provides $N$ sets of constraints, one per row. For row $i$ (and its constraint set $i$), you are given a nonnegative integer $T_i$ and $T_i$ column indices $r_{i,j}$ ($1 \\le j \\le T_i$). The requirement is: the number of components in row $i$ must not exceed the sum of the numbers of components in the specified $T_i$ columns (i.e., at most “the number of components in column $r_{i,1}$ + the number of components in column $r_{i,2}$ + $\\cdots$”).\n\nTo avoid slot overheating, you are given a real number $s_i$ ($1 \\le i \\le N$) with $0 \\le s_i \\le 1$, and you must ensure that the number of components in row $i$ does not exceed $s_i$ times the total number of components. Similarly, you are given a real number $t_i$ ($1 \\le i \\le N$) with $0 \\le t_i \\le 1$, and you must ensure that the number of components in column $i$ does not exceed $t_i$ times the total number of components.\n\nNote that slots already occupied by components are counted when computing the number of components in any row or column. They are also counted in the total number of components on the chip. The chip is described by an $N$-row, $N$-column character matrix, where `.` denotes an open slot, `/` denotes an unusable slot, and `C` denotes a slot already occupied by a component.", "inputFormat": "- The first line contains a positive integer $N$ ($1 \\le N \\le 40$), the size of the chip.\n- Then follow $N$ lines, each containing $N$ characters describing the slots, each character being one of `.`, `/`, or `C`, as defined above.\n- Then follow $N$ lines describing the constraint sets. On the $i$-th of these lines, first a nonnegative integer $T_i$ is given, followed by $T_i$ distinct integers (each between $1$ and $N$) specifying the related columns.\n- The next line contains $N$ real numbers, in order, corresponding to $s_i$. Each number has at most three digits after the decimal point.\n- The next line contains $N$ real numbers, in order, corresponding to $t_i$. Each number has at most three digits after the decimal point.", "outputFormat": "If there exists a valid placement strategy, output the maximum number of additional components that can be installed on the chip. Otherwise, output `impossible`.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2015] 模拟电路", "background": "", "description": "一家著名的芯片公司希望您能帮他们在一些最新的产品上安装可以稳定电压的组件。每块芯片都被设计成 $N\\times M$ 的带插槽的正方形，一个插槽可以安装一块单独的组件，你的任务是尽可能多地插入这些组件。\n\n现代处理器的设计是很复杂的。为了可以稳定电压，你要面对下面几个限制：一些插槽是不可用的。一些插槽已经被其它的组件占据了，因而无法被新的组件使用。内存总线要连接到芯片的水平和垂直的边界上，它们的负载电压需要是安全的。\n\n具体来说，芯片公司提供了 $N$ 组限制条件，分别对应了 $N$ 行。其中对于第 $i$ 行以及第 $i$ 组限制条件，给定非负整数 $T_i$ 与 $T_i$ 个列编号，记为 $r_{i,j}$（$1\\le j\\le T_i$），要求满足：第 $i$ 行的组件数目不能超过指定的 $T_i$ 个列方向上组件数目的和（也就是不超过“第 $r_{i,1}$ 列的组件数目 $+$ 第 $r_{i,2}$ 列的组件数目 $+$ $\\cdots$”）。为了避免插槽过热，给定浮点数 $s_i$（$1\\le i\\le N$） 且 $0\\le s_i\\le 1$，要求第 $i$ 行的组件数不超过总组件数的 $s_i$。同样给定浮点数 $t_i$（$1\\le i\\le N$）且 $0\\le T_i\\le 1$，要求第 $i$ 列的组件数不超过总组件数的 $t_i$。\n\n需要注意的是，已经占据了位置的组件，在统计一行或一列组件总数时，也是要被考虑在内的。而在计算芯片总组件数时．也要将已经占据了位置的组件考虑进去。芯片被描述为一个 $N$ 行，每行 $N$ 个字符的矩阵，其中 `.` 表示开放插槽，`/` 表示不可用插槽，`C` 表示插槽已被一个组件占据。\n", "inputFormat": "第一行给定 $1$ 个正整数，表示芯片的规模 $N$（$1\\le N\\le 40$）。\n\n然后给出 $N$ 行，每行 $N$ 个字符描述插槽，字符为 `.` ， `/` 或 `C` 之一，含义如上所述。\n\n之后 $N$ 行，描述了限制条件。其中第 $i$ 行首先给出非负整数 $T_i$，表示第 $i$ 行的限制条件涉及到的列的个数。之后再给出 $T_i$ 个不重复的整数（都在 $1$ 到 $N$ 的范围中），描述了相关的列。\n\n再下一行，给出了 $N$ 个浮点数依次对应 $s_i$。每一个数字小数点后不超过三位。\n\n再下一行，给出了 $N$ 个浮点数依次对应 $t_i$。每一个数字小数点后不超过三位。\n", "outputFormat": "如果存在合法的策略，输出最多可以再在芯片上安装多少个组件。否则输出 `impossible`。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3326", "type": "P", "difficulty": 6, "samples": [["2 2\n2 1\n1 1\nR**\n***\n**G\n", "        +-------+\n       /Y\\YYYY'/|\n      /YY.*'YY/G|\n     /.YYYY\\Y/G/|\n    +-------+G.G|\n    |\\GGGGG/|\\:G|\n    |G\\GGG/G|G*G|\n    |GG\\G/GG|G:\\|\n    |GGGXGGG|G'G+-------+\n    |GG/G\\GG|/G/G\\YYYY'/|\n    |G/GGG\\G|G/GG.*'YY/G|\n    |/GGGGG\\|/.GGGG\\Y/G/|\n    +-------+-------+G.G|\n   /Y\\GGGG'/G\\GGGG'/|\\:G|\n  /YY.*'GG/GG.*'GG/G|G*G|\n /.YYYY\\G/.GGGG\\G/G/|G:\\|\n+-------+-------+G.G|G'G+\n|\\GGGGG/|\\GGGGG/|\\:G|/G/\n|G\\GGG/G|G\\GGG/G|G*G|G/\n|GG\\G/GG|GG\\G/GG|G:\\|/\n|GGGXGGG|GGGXGGG|G'G+\n|GG/G\\GG|GG/G\\GG|/G/\n|G/GGG\\G|G/GGG\\G|G/\n|/GGGGG\\|/GGGGG\\|/\n+-------+-------+\n"], ["3 4\n1 1 2 1\n1 2 1 2\n2 1 2 1\n**B\n***\nR*G\n", "                            +-------+\n                           /W\\WWWW'/|\n                          /WW.*'WW/C|\n                         /.WWWW\\W/C/|\n                +-------+-------+-------+\n               /W\\WWWW'/|\\YYYYY/W\\WWWW'/|\n              /WW.*'WW/C|G\\YYY/WW.*'WW/C|\n             /.WWWW\\W/C/|GG\\Y/.WWWW\\W/C/|\n    +-------+-------+-------+-------+C.C|---+\n   /W\\WWWW'/|\\YYYYY/W\\WWWW'/|\\YYYYY/|\\:C|C'/|\n  /WW.*'WW/C|G\\YYY/WW.*'WW/C|G\\YYY/Y|C*C|C/C|\n /.WWWW\\W/C/|GG\\Y/.WWWW\\W/C/|GG\\Y/YY|C:\\|/C/|\n+-------+C.G|GGG+-------+C.G|GGGXYYY|C'C+C.C|\n|\\YYYYY/|\\:G|GG/|\\YYYYY/|\\:G|GG/G\\YY|/C/|\\:C|\n|Y\\YYY/Y|C*G|G/K|Y\\YYY/Y|C*G|G/GGG\\Y|C/C|C*C|\n|YY\\Y/YY|C:\\|/KK|YY\\Y/YY|C:\\|/GGGGG\\|/C/|C:\\|\n|YYYXYYY|C'G+---|YYYXYYY|C'G+-------+C.C|C'C+\n|YY/Y\\YY|/G/G\\KK|YY/Y\\YY|/G/G\\GGGG'/|\\:C|/C/\n|Y/YYY\\Y|G/GG.*'|Y/YYY\\Y|G/GG.*'WW/C|C*C|C/\n|/YYYYY\\|/.YYYY\\|/YYYYY\\|/.WWWW\\W/C/|C:\\|/\n+-------+-------+-------+-------+C.C|C'C+\n|\\YYYYY/|\\YYYYY/|\\YYYYY/|\\YYYYY/|\\:C|/C/\n|Y\\YYY/Y|Y\\YYY/Y|Y\\YYY/Y|Y\\YYY/Y|C*C|C/\n|YY\\Y/YY|YY\\Y/YY|YY\\Y/YY|YY\\Y/YY|C:\\|/\n|YYYXYYY|YYYXYYY|YYYXYYY|YYYXYYY|C'C+\n|YY/Y\\YY|YY/Y\\YY|YY/Y\\YY|YY/Y\\YY|/C/\n|Y/YYY\\Y|Y/YYY\\Y|Y/YYY\\Y|Y/YYY\\Y|C/\n|/YYYYY\\|/YYYYY\\|/YYYYY\\|/YYYYY\\|/\n+-------+-------+-------+-------+"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "各省省选", "山东", "枚举"], "title": "[SDOI2015] 立体图", "background": null, "description": "小渊是个聪明的孩子，他经常会给周围的小朋友们讲些自己认为有趣的内容。最近，他准备给小朋友们讲解彩色水平光源照射下的立体图，并请你帮他在平面上画出来。\n\n小渊有一块面积为 $m\\times n$ 的矩形区域，上面有 $m\\times n$ 个边长为 1 的格子，每个格子上堆了一些同样大小的积木（积木的长宽高都是 $1$）。\n\n为了方便阐述，我们假设这块区域是坐北朝南的，下面我们给出一个例子。\n\n![](https://cdn.luogu.com.cn/upload/pic/22187.png)\n\n小渊想请你打印出这些格子的立体图。我们定义每个积木为如下格式，并且不会做任何翻转旋转，只会严格以这一种形式摆放（左侧是应该打印出来的图样，右侧为对应每一个位置符号的十进制 ASCII，其中 ASCII 为 $32$ 的符号为空格）。\n\n![](https://cdn.luogu.com.cn/upload/pic/22188.png)\n\n在良好的光学环境下，小渊将 $T$ 束平行光同时照射在这些积木上。这些平行光首先满足一定是红绿蓝三基色之一，其次入射角度满足：与 $x$ 轴 $y$ 轴的夹角度数均为 $45^\\circ$ 的倍数；且与 $z$ 轴正方向的夹角或为 $45^\\circ$，或为 $0^\\circ$，或为 $315^\\circ$。\n\n具体来说，我们最多会考虑 $9$ 个方向的不同平行光，它们的入射方向可以被描述为：西北方 $45^\\circ$ 仰角、正北方 $45^\\circ$ 仰角、东北方 $45^\\circ$ 仰角、正西方 $45^\\circ$ 仰角、垂直从上入射光、正东方 $45^\\circ$ 仰角、西南方 $45^\\circ$ 仰角、正南方 $45^\\circ$ 仰角、东南方 $45^\\circ$ 仰角。对于每一个单位积木来说，可以打印出来的三个表面被分为 $12$ 个小三角形。\n\n![](https://cdn.luogu.com.cn/upload/pic/22189.png)\n\n红绿蓝三基色分别用字母 R、G、B 来表示。而二次叠加后的三种颜色青黄紫，分别用 C、Y、P 来表示。对于三次叠加后的颜色，也就是白色，用 W 来表示。", "inputFormat": "第一行有两个正整数 $m,n$，表示区域有 $m$ 行 $n$ 列。之后 $m$ 行，依次由远及近描述了每一行的情况。每一行给出 $n$ 个正整数，表示第 $i$ 行第 $j$ 列中有堆放了多少积木。\n\n之后 $3$ 行，每行三个字符，描述了 $9$ 个对应方向（与地图描述方向相同）的光照颜色。其中每一个字符或者为 RGB 中之一，表示对应的颜色。或者为 `*`，表示没有照射光。这九个方向依次是：西北方 $45^\\circ$ 仰角、正北方 $45^\\circ$ 仰角、东北方 $45^\\circ$ 仰角、正西方 $45^\\circ$ 仰角、垂直从上入射光、正东方 $45^\\circ$ 仰角、西南方 $45^\\circ$ 仰角、正南方 $45^\\circ$ 仰角、东南方 $45^\\circ$ 仰角。", "outputFormat": "输出给出了打印后的效果。其中要求输出结果不含前导空行，结尾也没有额外空行。输出的第一列不能全是空格，且每一行末尾也没有额外空格。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/22190.png)\n\n对于 $15\\%$ 的数据，$1\\leq n,m\\leq100$，没有入射光。\n\n对于 $40\\%$ 的数据，$1\\leq n,m\\leq100$，入射光只有一束，且入射方向一定是东南方。\n\n对于 $100\\%$ 的数据，$1\\leq n,m\\leq100$，每一个位置堆放的积木总数不超过 $100$，入射光颜色可能是 R、G、B 中的任何一种颜色，最多可以有 $9$ 束入射光。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2015] 3D Diagram", "background": "", "description": "Xiaoyuan (pinyin) is a smart kid who often explains things he finds interesting to the children around him. Recently, he plans to explain stereograms under colored horizontal light sources to the kids and asks you to help draw them on a plane.\n\nXiaoyuan has a rectangular area of size $m\\times n$ with $m\\times n$ unit squares, each of side length $1$. On each square, some identical blocks are stacked (each block has length, width, and height all equal to $1$).\n\nFor convenience, assume this area faces south with north at the top. Below is an example.\n\n![](https://cdn.luogu.com.cn/upload/pic/22187.png)\n\nXiaoyuan wants you to print the stereogram of these squares. We define each block in the following fixed format, and it will never be flipped or rotated; it is always placed strictly in this single orientation (the left side shows the pattern to be printed, and the right side shows the decimal ASCII for each position; ASCII $32$ is a space).\n\n![](https://cdn.luogu.com.cn/upload/pic/22188.png)\n\nUnder good optical conditions, Xiaoyuan shines $T$ beams of parallel light on these blocks simultaneously. These parallel lights satisfy: each is one of the three primary colors red, green, or blue; the angles with the $x$-axis and $y$-axis are multiples of $45^\\circ$; and the angle with the positive $z$-axis is either $45^\\circ$, $0^\\circ$, or $315^\\circ$.\n\nSpecifically, we consider at most $9$ different directions of parallel light. Their incident directions can be described as: northwest with $45^\\circ$ elevation, due north with $45^\\circ$ elevation, northeast with $45^\\circ$ elevation, due west with $45^\\circ$ elevation, vertical incidence from above, due east with $45^\\circ$ elevation, southwest with $45^\\circ$ elevation, due south with $45^\\circ$ elevation, and southeast with $45^\\circ$ elevation. For each unit block, the three printable faces are divided into $12$ small triangles.\n\n![](https://cdn.luogu.com.cn/upload/pic/22189.png)\n\nThe three primary colors red, green, and blue are represented by the letters R, G, and B. The three secondary colors after double overlap, cyan, yellow, and purple, are represented by C, Y, and P, respectively. For triple overlap, i.e., white, use W.", "inputFormat": "The first line contains two positive integers $m,n$, meaning the area has $m$ rows and $n$ columns. Then $m$ lines follow, describing each row from far to near in order. Each line gives $n$ positive integers, indicating how many blocks are stacked at cell $(i,j)$.\n\nThen there are $3$ lines, each with three characters, describing the colors of light in the $9$ corresponding directions (same directional order as described on the map). Each character is either one of RGB, indicating the corresponding color, or `*`, indicating no incident light. The nine directions, in order, are: northwest with $45^\\circ$ elevation, due north with $45^\\circ$ elevation, northeast with $45^\\circ$ elevation, due west with $45^\\circ$ elevation, vertical incidence from above, due east with $45^\\circ$ elevation, southwest with $45^\\circ$ elevation, due south with $45^\\circ$ elevation, and southeast with $45^\\circ$ elevation.", "outputFormat": "Output the rendered result. The output must not contain a leading blank line, and there must be no extra blank line at the end. The first column must not be all spaces, and there must be no trailing spaces at the end of any line.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/22190.png)\n\nFor $15\\%$ of the testdata, $1\\leq n,m\\leq 100$, and there is no incident light.\n\nFor $40\\%$ of the testdata, $1\\leq n,m\\leq 100$, there is only one incident beam, and its direction is guaranteed to be southeast.\n\nFor $100\\%$ of the testdata, $1\\leq n,m\\leq 100$, the number of blocks stacked at each position does not exceed $100$, the incident light color may be any one of R, G, or B, and there can be at most $9$ incident beams.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2015] 立体图", "background": null, "description": "小渊是个聪明的孩子，他经常会给周围的小朋友们讲些自己认为有趣的内容。最近，他准备给小朋友们讲解彩色水平光源照射下的立体图，并请你帮他在平面上画出来。\n\n小渊有一块面积为 $m\\times n$ 的矩形区域，上面有 $m\\times n$ 个边长为 1 的格子，每个格子上堆了一些同样大小的积木（积木的长宽高都是 $1$）。\n\n为了方便阐述，我们假设这块区域是坐北朝南的，下面我们给出一个例子。\n\n![](https://cdn.luogu.com.cn/upload/pic/22187.png)\n\n小渊想请你打印出这些格子的立体图。我们定义每个积木为如下格式，并且不会做任何翻转旋转，只会严格以这一种形式摆放（左侧是应该打印出来的图样，右侧为对应每一个位置符号的十进制 ASCII，其中 ASCII 为 $32$ 的符号为空格）。\n\n![](https://cdn.luogu.com.cn/upload/pic/22188.png)\n\n在良好的光学环境下，小渊将 $T$ 束平行光同时照射在这些积木上。这些平行光首先满足一定是红绿蓝三基色之一，其次入射角度满足：与 $x$ 轴 $y$ 轴的夹角度数均为 $45^\\circ$ 的倍数；且与 $z$ 轴正方向的夹角或为 $45^\\circ$，或为 $0^\\circ$，或为 $315^\\circ$。\n\n具体来说，我们最多会考虑 $9$ 个方向的不同平行光，它们的入射方向可以被描述为：西北方 $45^\\circ$ 仰角、正北方 $45^\\circ$ 仰角、东北方 $45^\\circ$ 仰角、正西方 $45^\\circ$ 仰角、垂直从上入射光、正东方 $45^\\circ$ 仰角、西南方 $45^\\circ$ 仰角、正南方 $45^\\circ$ 仰角、东南方 $45^\\circ$ 仰角。对于每一个单位积木来说，可以打印出来的三个表面被分为 $12$ 个小三角形。\n\n![](https://cdn.luogu.com.cn/upload/pic/22189.png)\n\n红绿蓝三基色分别用字母 R、G、B 来表示。而二次叠加后的三种颜色青黄紫，分别用 C、Y、P 来表示。对于三次叠加后的颜色，也就是白色，用 W 来表示。", "inputFormat": "第一行有两个正整数 $m,n$，表示区域有 $m$ 行 $n$ 列。之后 $m$ 行，依次由远及近描述了每一行的情况。每一行给出 $n$ 个正整数，表示第 $i$ 行第 $j$ 列中有堆放了多少积木。\n\n之后 $3$ 行，每行三个字符，描述了 $9$ 个对应方向（与地图描述方向相同）的光照颜色。其中每一个字符或者为 RGB 中之一，表示对应的颜色。或者为 `*`，表示没有照射光。这九个方向依次是：西北方 $45^\\circ$ 仰角、正北方 $45^\\circ$ 仰角、东北方 $45^\\circ$ 仰角、正西方 $45^\\circ$ 仰角、垂直从上入射光、正东方 $45^\\circ$ 仰角、西南方 $45^\\circ$ 仰角、正南方 $45^\\circ$ 仰角、东南方 $45^\\circ$ 仰角。", "outputFormat": "输出给出了打印后的效果。其中要求输出结果不含前导空行，结尾也没有额外空行。输出的第一列不能全是空格，且每一行末尾也没有额外空格。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/22190.png)\n\n对于 $15\\%$ 的数据，$1\\leq n,m\\leq100$，没有入射光。\n\n对于 $40\\%$ 的数据，$1\\leq n,m\\leq100$，入射光只有一束，且入射方向一定是东南方。\n\n对于 $100\\%$ 的数据，$1\\leq n,m\\leq100$，每一个位置堆放的积木总数不超过 $100$，入射光颜色可能是 R、G、B 中的任何一种颜色，最多可以有 $9$ 束入射光。", "locale": "zh-CN"}}}
{"pid": "P3327", "type": "P", "difficulty": 6, "samples": [["2\n7 4\n5 6", "110\n121"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2015", "各省省选", "数论", "山东", "最大公约数 gcd", "莫比乌斯反演", "整除分块", "筛法"], "title": "[SDOI2015] 约数个数和", "background": "", "description": "设 $d(x)$ 为 $x$ 的约数个数，给定 $n,m$，求    \n$$\\sum_{i=1}^n\\sum_{j=1}^md(ij)$$\n", "inputFormat": "输入文件包含多组测试数据。   \n第一行，一个整数 $T$，表示测试数据的组数。  \n接下来的 $T$ 行，每行两个整数 $n,m$。\n", "outputFormat": "$T$ 行，每行一个整数，表示你所求的答案。\n", "hint": "【数据范围】   \n对于 $100\\%$ 的数据，$1\\le T,n,m \\le 50000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2015] Sum of Divisor Counts", "background": "", "description": "Let $d(x)$ be the number of divisors of $x$. Given $n, m$, compute\n$$\\sum_{i=1}^n\\sum_{j=1}^m d(ij).$$", "inputFormat": "The input contains multiple test cases.  \nThe first line contains an integer $T$, the number of test cases.  \nEach of the next $T$ lines contains two integers $n, m$.", "outputFormat": "Output $T$ lines, each containing one integer, the required answer.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le T, n, m \\le 50000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2015] 约数个数和", "background": "", "description": "设 $d(x)$ 为 $x$ 的约数个数，给定 $n,m$，求    \n$$\\sum_{i=1}^n\\sum_{j=1}^md(ij)$$\n", "inputFormat": "输入文件包含多组测试数据。   \n第一行，一个整数 $T$，表示测试数据的组数。  \n接下来的 $T$ 行，每行两个整数 $n,m$。\n", "outputFormat": "$T$ 行，每行一个整数，表示你所求的答案。\n", "hint": "【数据范围】   \n对于 $100\\%$ 的数据，$1\\le T,n,m \\le 50000$。\n", "locale": "zh-CN"}}}
{"pid": "P3328", "type": "P", "difficulty": 6, "samples": [["7 7\n1 0\n3 4 5 6 7 8 9\nquery 2 4\nquery 3 7\nplus 3 5\nquery 2 4\nplus 4 7\nquery 3 7\nquery 1 7", "64 \n1766 \n104 \n7479 \n7687"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2015", "线段树", "各省省选", "山东", "矩阵乘法"], "title": "[SDOI2015] 音质检测", "background": "", "description": "万老板希望在新的智能音乐播放设备 $\\operatorname{IPOOD}$ 中，实现对波文件音质性能的评定。离散的波文件被考虑为长度为 $N$ 的整数序列：$A_1,A_2,\\cdots,A_N$。所谓的音质性能检测，可以评定任何的一个区间范围 $[L,R]$ ，音质性能取决于下述评分：\n\n$$\\sum_{L<i<R}F[A_{i-1}+1]F[A_{i+1}-1] \\operatorname{mod}\\;(10^9+7)$$\n\n其中 $F$ 是可归纳定义的数列，满足 $F_1=1$，$F_2=2$ 且 $F_{k+2}=F_{k+1}+aF_{k}+b$ 对于任何 $k>0$ 成立。\n\n其中 $a$ 和 $b$ 为正整系数。为了可以为用户提供更好的服务体验，并希望对给定的波文件进行修正优化。这一款设备中，还应该支持对波文件的修改。对于给定的区间范围 $[L,R]$ ，允许用户将 $A_L$ 至 $A_R$ 同时增加一，或同时减少一。", "inputFormat": "输入的第一行有两个正整数，波文件的总长度 $N$ ，和总的修改与询问次数 $Q$ 。\n\n第二行有两个整数，分别表示系数 $a$ 和 $b$ 。\n\n之后若干行，一共给出 $N$ 个正整数 $A_1$ 到 $A_N$ ，满足 $1\\leq A_i\\leq 2\\times 10^9$ 。\n\n之后 $Q$ 行，每行是下述三种形式之一：\n- $\\text{plus}\\;L\\;R:$将波文件数列中下标在区间 $[L,R]$ 内的元素每一个都加一。\n- $\\text{minus}\\;L\\;R:$将波文件数列中下标在区间 $[L,R]$ 内的元素每一个都减一。\n- $\\text{query}\\;L\\;R:$询问区间 $[L,R]$ 的音质性能评分。修改和询问中，均保证 $L\\leq R$ ，且保证 $A_i$ 严格大于总的修改次数加一(修改操作包括 $\\text{plus}$ 和 $\\text{minus}$ 两种)。", "outputFormat": "输出若干行，每一行对应一次询问，输出一个整数。\n", "hint": "$N\\leq 3\\times10^5,Q\\leq10^4,0\\leq a,b\\leq10^9$", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2015] Audio Quality Detection", "background": "", "description": "Boss Wan wants to implement an evaluation of the audio quality performance of wave files in the new smart music player $\\operatorname{IPOOD}$. A discrete wave file is considered as an integer sequence of length $N$: $A_1, A_2, \\cdots, A_N$. The audio quality evaluation can be computed for any interval $[L, R]$, and the score depends on the following expression:\n\n$$\\sum_{L<i<R}F[A_{i-1}+1]F[A_{i+1}-1] \\operatorname{mod}\\;(10^9+7)$$\n\nHere $F$ is an inductively defined sequence, satisfying $F_1=1$, $F_2=2$, and $F_{k+2}=F_{k+1}+aF_{k}+b$ for any $k>0$.\n\nHere $a$ and $b$ are non-negative integer coefficients. To provide a better user experience and to allow optimization of the given wave file, the device should also support modifications to the wave file. For a given interval $[L, R]$, the user is allowed to increase $A_L$ through $A_R$ by one simultaneously, or decrease them by one simultaneously.", "inputFormat": "The first line contains two positive integers: the total length $N$ of the wave file, and the total number $Q$ of modifications and queries.\n\nThe second line contains two integers, the coefficients $a$ and $b$.\n\nThen, over several lines, $N$ positive integers $A_1$ through $A_N$ are given, satisfying $1 \\leq A_i \\leq 2 \\times 10^9$.\n\nThen follow $Q$ lines, each in one of the following three forms:\n- $\\text{plus}\\;L\\;R:$ increase every element with index in $[L, R]$ by one.\n- $\\text{minus}\\;L\\;R:$ decrease every element with index in $[L, R]$ by one.\n- $\\text{query}\\;L\\;R:$ ask for the audio quality score of the interval $[L, R]$. In both modifications and queries, it is guaranteed that $L \\leq R$, and that $A_i$ is strictly greater than the total number of modifications plus one (modification operations include both $\\text{plus}$ and $\\text{minus}$).", "outputFormat": "Output several lines, each corresponding to one query. For each query, output one integer.", "hint": "$N\\leq 3\\times10^5,Q\\leq10^4,0\\leq a,b\\leq10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2015] 音质检测", "background": "", "description": "万老板希望在新的智能音乐播放设备 $\\operatorname{IPOOD}$ 中，实现对波文件音质性能的评定。离散的波文件被考虑为长度为 $N$ 的整数序列：$A_1,A_2,\\cdots,A_N$。所谓的音质性能检测，可以评定任何的一个区间范围 $[L,R]$ ，音质性能取决于下述评分：\n\n$$\\sum_{L<i<R}F[A_{i-1}+1]F[A_{i+1}-1] \\operatorname{mod}\\;(10^9+7)$$\n\n其中 $F$ 是可归纳定义的数列，满足 $F_1=1$，$F_2=2$ 且 $F_{k+2}=F_{k+1}+aF_{k}+b$ 对于任何 $k>0$ 成立。\n\n其中 $a$ 和 $b$ 为正整系数。为了可以为用户提供更好的服务体验，并希望对给定的波文件进行修正优化。这一款设备中，还应该支持对波文件的修改。对于给定的区间范围 $[L,R]$ ，允许用户将 $A_L$ 至 $A_R$ 同时增加一，或同时减少一。", "inputFormat": "输入的第一行有两个正整数，波文件的总长度 $N$ ，和总的修改与询问次数 $Q$ 。\n\n第二行有两个整数，分别表示系数 $a$ 和 $b$ 。\n\n之后若干行，一共给出 $N$ 个正整数 $A_1$ 到 $A_N$ ，满足 $1\\leq A_i\\leq 2\\times 10^9$ 。\n\n之后 $Q$ 行，每行是下述三种形式之一：\n- $\\text{plus}\\;L\\;R:$将波文件数列中下标在区间 $[L,R]$ 内的元素每一个都加一。\n- $\\text{minus}\\;L\\;R:$将波文件数列中下标在区间 $[L,R]$ 内的元素每一个都减一。\n- $\\text{query}\\;L\\;R:$询问区间 $[L,R]$ 的音质性能评分。修改和询问中，均保证 $L\\leq R$ ，且保证 $A_i$ 严格大于总的修改次数加一(修改操作包括 $\\text{plus}$ 和 $\\text{minus}$ 两种)。", "outputFormat": "输出若干行，每一行对应一次询问，输出一个整数。\n", "hint": "$N\\leq 3\\times10^5,Q\\leq10^4,0\\leq a,b\\leq10^9$", "locale": "zh-CN"}}}
