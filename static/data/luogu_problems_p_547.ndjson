{"pid": "P12103", "type": "P", "difficulty": 6, "samples": [["2\n3 3\n1 1 1 1 1 1\n1 1 1 1 1 -1\n5 4\n2 2 1 1 -1 -1\n2 1 2 2 1 -1", "1/2\n1/3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "ICPC", "NERC/NEERC"], "title": "[NERC2024] Legacy Screensaver", "background": "", "description": "On a very old operating system, a screensaver consists of two rectangles flying around the screen. The screen is $W$ pixels wide and $H$ pixels high. Consider the origin to be in the top-left corner of the screen, the $x$-axis to go from the origin to the right, and the $y$-axis to go from the origin to the bottom.\n\nRectangle $i$ ($i = 1, 2$) has a width of $w_i$ pixels, a height of $h_i$ pixels, initially its top-left corner has coordinates $(x_i, y_i)$, and its initial movement direction is $(\\delta x_i, \\delta y_i)$, where each of $\\delta x_i$ and $\\delta y_i$ is either $-1$ or $1$. At the end of each second, rectangle $i$'s top-left corner coordinates instantly change by $(\\delta x_i, \\delta y_i)$. \n\nWhenever rectangle $i$ touches the left or the right border of the screen, the value of $\\delta x_i$ changes sign before the next second. Similarly, whenever rectangle $i$ touches the top or the bottom border of the screen, the value of $\\delta y_i$ changes sign before the next second. Whenever rectangle $i$ touches two borders of the screen at the same time (which can only happen at the corner of the screen), both $\\delta x_i$ and $\\delta y_i$ change sign.\n\nAs a result of the above, both rectangles stay fully within the screen at all times. Informally, collisions of the rectangles with the screen borders are perfectly elastic. Note, however, that rectangle movement is still discrete: each rectangle moves instantly by $1$ pixel in both directions at the end of each second.\n\nYou are curious how often these two rectangles overlap. The rectangles are considered to be overlapping if their intersection has a positive area.\n\nLet $f(t)$ be the number of integers $\\tau = 0, 1, \\ldots, t - 1$ such that the rectangles overlap during second $\\tau$ (where second $0$ is before the rectangles start moving).\n\nFind the limit of $\\frac{f(t)}{t}$ as $t \\rightarrow \\infty$ as an irreducible fraction. It can be shown that this limit is a rational number.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $T$ ($1 \\le T \\le 1000$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $W$ and $H$, denoting the width and the height of the screen ($3 \\le W, H \\le 4000$).\n\nThe next two lines describe the two rectangles. Each rectangle is described by six integers $w_i$, $h_i$, $x_i$, $y_i$, $\\delta x_i$, $\\delta y_i$, describing the $i$-th rectangle and denoting its width, its height, the coordinates of its top-left corner, and its initial movement direction ($1 \\le w_i \\le W - 2$; $1 \\le h_i \\le H - 2$; $0 < x_i < W - w_i$; $0 < y_i < H - h_i$; $\\delta x_i, \\delta y_i \\in \\{-1, 1\\})$.\n\nThe sum of the values of $W + H$ across all test cases is guaranteed to not exceed $8000$.", "outputFormat": "For each test case, print a non-negative integer $p$ and a positive integer $q$, separated by a slash ($\\tt{/}$) without spaces, meaning that the limit of $\\frac{f(t)}{t}$ as $t \\rightarrow \\infty$ is equal to $\\frac{p}{q}$. The fraction must be irreducible --- that is, the greatest common divisor of $p$ and $q$ must be equal to $1$.", "hint": "For the second test case, the state of rectangles during the first few seconds is shown in the following pictures. The rectangles overlap during seconds $\\tau = 0$ and $\\tau = 6$. Thus, for example, $f(8) = 2$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nskvvhru.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jaaryddz.png)", "locale": "en", "translations": {"en": {"title": "[NERC2024] Legacy Screensaver", "background": "", "description": "On a very old operating system, a screensaver consists of two rectangles flying around the screen. The screen is $W$ pixels wide and $H$ pixels high. Consider the origin to be in the top-left corner of the screen, the $x$-axis to go from the origin to the right, and the $y$-axis to go from the origin to the bottom.\n\nRectangle $i$ ($i = 1, 2$) has a width of $w_i$ pixels, a height of $h_i$ pixels, initially its top-left corner has coordinates $(x_i, y_i)$, and its initial movement direction is $(\\delta x_i, \\delta y_i)$, where each of $\\delta x_i$ and $\\delta y_i$ is either $-1$ or $1$. At the end of each second, rectangle $i$'s top-left corner coordinates instantly change by $(\\delta x_i, \\delta y_i)$. \n\nWhenever rectangle $i$ touches the left or the right border of the screen, the value of $\\delta x_i$ changes sign before the next second. Similarly, whenever rectangle $i$ touches the top or the bottom border of the screen, the value of $\\delta y_i$ changes sign before the next second. Whenever rectangle $i$ touches two borders of the screen at the same time (which can only happen at the corner of the screen), both $\\delta x_i$ and $\\delta y_i$ change sign.\n\nAs a result of the above, both rectangles stay fully within the screen at all times. Informally, collisions of the rectangles with the screen borders are perfectly elastic. Note, however, that rectangle movement is still discrete: each rectangle moves instantly by $1$ pixel in both directions at the end of each second.\n\nYou are curious how often these two rectangles overlap. The rectangles are considered to be overlapping if their intersection has a positive area.\n\nLet $f(t)$ be the number of integers $\\tau = 0, 1, \\ldots, t - 1$ such that the rectangles overlap during second $\\tau$ (where second $0$ is before the rectangles start moving).\n\nFind the limit of $\\frac{f(t)}{t}$ as $t \\rightarrow \\infty$ as an irreducible fraction. It can be shown that this limit is a rational number.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $T$ ($1 \\le T \\le 1000$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $W$ and $H$, denoting the width and the height of the screen ($3 \\le W, H \\le 4000$).\n\nThe next two lines describe the two rectangles. Each rectangle is described by six integers $w_i$, $h_i$, $x_i$, $y_i$, $\\delta x_i$, $\\delta y_i$, describing the $i$-th rectangle and denoting its width, its height, the coordinates of its top-left corner, and its initial movement direction ($1 \\le w_i \\le W - 2$; $1 \\le h_i \\le H - 2$; $0 < x_i < W - w_i$; $0 < y_i < H - h_i$; $\\delta x_i, \\delta y_i \\in \\{-1, 1\\})$.\n\nThe sum of the values of $W + H$ across all test cases is guaranteed to not exceed $8000$.", "outputFormat": "For each test case, print a non-negative integer $p$ and a positive integer $q$, separated by a slash ($\\tt{/}$) without spaces, meaning that the limit of $\\frac{f(t)}{t}$ as $t \\rightarrow \\infty$ is equal to $\\frac{p}{q}$. The fraction must be irreducible --- that is, the greatest common divisor of $p$ and $q$ must be equal to $1$.", "hint": "For the second test case, the state of rectangles during the first few seconds is shown in the following pictures. The rectangles overlap during seconds $\\tau = 0$ and $\\tau = 6$. Thus, for example, $f(8) = 2$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nskvvhru.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jaaryddz.png)", "locale": "en"}, "zh-CN": {"title": "[NERC2024] Legacy Screensaver", "background": "", "description": "在一个非常古老的操作系统中，屏保由两个在屏幕上飞来飞去的矩形组成。屏幕宽 $W$ 像素，高 $H$ 像素。我们规定屏幕左上角为坐标原点，$x$ 轴从原点向右延伸，$y$ 轴从原点向下延伸。\n\n第 $i$ 个矩形（$i=1,2$）的宽度为 $w_i$ 像素，高度为 $h_i$ 像素，初始时其左上角坐标为 $(x_i, y_i)$，初始移动方向为 $(\\delta x_i, \\delta y_i)$，其中 $\\delta x_i$ 和 $\\delta y_i$ 的取值均为 $-1$ 或 $1$。每过一秒，矩形 $i$ 的左上角坐标都会立刻变化 $(\\delta x_i, \\delta y_i)$。\n\n每当矩形 $i$ 碰到屏幕的左边界或右边界时，$\\delta x_i$ 的符号会在下一秒之前反转。同样地，每当矩形 $i$ 碰到屏幕的上边界或下边界时，$\\delta y_i$ 的符号会在下一秒之前反转。如果矩形 $i$ 同时碰到两条边界（只能发生在屏幕的角落处），那么 $\\delta x_i$ 和 $\\delta y_i$ 都会反转。\n\n因此，两个矩形始终完全位于屏幕内部。简而言之，矩形与屏幕边界的碰撞是完全弹性的。注意，尽管如此，矩形的移动依然是离散的：每过一秒，矩形的坐标瞬间移动 $1$ 个像素单位。\n\n你很好奇这两个矩形有多频繁地重叠。当两个矩形的交集面积为正时，认为它们发生了重叠。\n\n设 $f(t)$ 表示在第 $0, 1, \\ldots, t-1$ 秒内，矩形发生重叠的时刻数量（其中第 $0$ 秒是矩形开始移动之前）。\n\n请你求出 $\\dfrac{f(t)}{t}$ 在 $t \\to +\\infty$ 时的极限，并以最简分数的形式表示。可以证明，该极限值是一个有理数。", "inputFormat": "每个测试包含多个测试用例。\n\n第一行包含一个整数 $T\\;(1 \\le T \\le 1000)$，表示测试用例的数量。\n\n接下来是每个测试用例的描述。\n\n每个测试用例的第一行包含两个整数 $W$ 和 $H$，表示屏幕的宽和高（$3 \\le W,H \\le 4000$）。\n\n接下来的两行分别描述两个矩形。每个矩形由六个整数 $w_i, h_i, x_i, y_i, \\delta x_i, \\delta y_i$ 描述，表示第 $i$ 个矩形的宽度、高度、左上角坐标以及初始移动方向（$1 \\le w_i \\le W-2$；$1 \\le h_i \\le H-2$；$0 < x_i < W-w_i$；$0 < y_i < H-h_i$；$\\delta x_i, \\delta y_i \\in \\{-1, 1\\}$）。\n\n保证所有测试用例中 $W+H$ 的总和不超过 $8000$。", "outputFormat": "对于每个测试用例，输出一行，包含两个用斜杠（$\\tt{/}$）分隔的整数 $p$ 和 $q$（中间无空格），表示 $\\dfrac{f(t)}{t}$ 的极限值为 $\\dfrac{p}{q}$。输出的分数必须是最简形式，即 $p$ 和 $q$ 的最大公约数为 $1$。", "hint": "对于第二个测试用例，矩形在最初几秒内的状态如下图所示。矩形在第 $\\tau=0$ 秒和第 $\\tau=6$ 秒发生重叠。例如，$f(8)=2$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nskvvhru.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jaaryddz.png)", "locale": "zh-CN"}}}
{"pid": "P12104", "type": "P", "difficulty": 6, "samples": [["3\n2\n1 2 2 1\n1 2\n2 3\n3 4\n4\n4 3 1 3 2 4 1 2\n1 2\n3 1\n3 4\n5 1\n5 6\n2 7\n2 8\n3\n1 1 2 2 3 3\n1 2\n1 3\n1 4\n1 5\n1 6", "1\n1 3\n3\n1 5\n8 3\n4 7\n0"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC2024] Managing Cluster", "background": "", "description": "You want to write a cluster manager extension that will improve your product performance. Your product has $n$ services (numbered from $1$ to $n$) and is hosted on a cluster with $2n$ machines (numbered from $1$ to $2n$). Each service is running in exactly two replicas. Each replica is run on some machine. Each machine runs exactly one replica of some service.\n\nOne of the key factors of this cluster's performance is the network. Some pairs of machines are connected directly and can transfer data between them very efficiently. There are exactly $2n-1$ direct connections, and it is possible to transfer data between any two machines using direct connections. In other words, direct connections form a tree.\n\nDuring the deployment, all $2n$ replicas were assigned to machines. Your extension gets the direct connections list and the sequence $a_1, a_2, \\ldots, a_{2n}$, where $a_i$ is the number of the service that will be running on machine $i$. Your extension can swap some replicas between machines. The swap operation takes two machines $i$, $j$ and swaps values $a_i$ and $a_j$. Each machine is allowed to participate in at most one swap operation. Your extension should make some swap operations that maximize the cluster performance.\n\nDue to the fact that most data will be transferred between two replicas of the same service, the cluster performance is measured as the number of services that have two replicas running on machines connected directly. Help to write the extension that will maximize the cluster performance.", "inputFormat": "The first line contains a single integer $T$ ($1 \\leq T \\leq 10^5$) --- the number of test cases. Descriptions of test cases follow.\n\nThe first line of each test case contains a single integer $n$ ($1 \\leq n \\leq 10^5$).\n\nThe second line contains $2n$ integers $a_1, a_2, \\ldots, a_{2n}$ ($1 \\leq a_i \\leq n$). It is guaranteed that each value from $1$ to $n$ appears exactly twice in this sequence.\n\nEach of the next $2n-1$ lines contains two integers $u$ and $v$ ($1 \\leq u, v \\leq 2n$, $u \\neq v$), meaning that machines $u$ and $v$ are connected directly. Direct connections are guaranteed to form a tree.\n\nIt is guaranteed that the sum of $n$ for all test cases does not exceed $10^5$.", "outputFormat": "For each test case on the first line print a single integer $k$ ($0 \\leq k \\leq n$) --- the number of swap operations the extension wants to make.\n\nEach of the next $k$ lines should contain two integers $i$, $j$ ($1 \\leq i, j \\leq 2n$, $i \\neq j$) --- swap operations. Each number from $1$ to $2n$ should appear at most once.\n\nNote that the order of operations is not important. After applying swap operations, the cluster performance should be the maximum possible. You can print any answer that satisfies the requirements.", "hint": "In the first test case only replicas of service 2 run on directly connected machines, so the performance is 1. The performance can be increased to 2 by swapping replicas between machines 1 and 3.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6cp342uy.png)\n\nIn the second test case no two replicas run on directly connected machines, so the performance is zero. The performance can be increased to 3 by performing swaps $1-5$, $8-3$, and $4-7$ so that replicas of services 2, 3, and 4 run on directly connected machines. It can be shown that it is impossible to get performance 4 here. \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ljhz2pf2.png)\n\nIn the third test case only replicas of service 1 run on directly connected machines, so the performance is 1. It is obvious that here the performance cannot be made any bigger.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ss4oj9ok.png)", "locale": "en", "translations": {"en": {"title": "[NERC2024] Managing Cluster", "background": "", "description": "You want to write a cluster manager extension that will improve your product performance. Your product has $n$ services (numbered from $1$ to $n$) and is hosted on a cluster with $2n$ machines (numbered from $1$ to $2n$). Each service is running in exactly two replicas. Each replica is run on some machine. Each machine runs exactly one replica of some service.\n\nOne of the key factors of this cluster's performance is the network. Some pairs of machines are connected directly and can transfer data between them very efficiently. There are exactly $2n-1$ direct connections, and it is possible to transfer data between any two machines using direct connections. In other words, direct connections form a tree.\n\nDuring the deployment, all $2n$ replicas were assigned to machines. Your extension gets the direct connections list and the sequence $a_1, a_2, \\ldots, a_{2n}$, where $a_i$ is the number of the service that will be running on machine $i$. Your extension can swap some replicas between machines. The swap operation takes two machines $i$, $j$ and swaps values $a_i$ and $a_j$. Each machine is allowed to participate in at most one swap operation. Your extension should make some swap operations that maximize the cluster performance.\n\nDue to the fact that most data will be transferred between two replicas of the same service, the cluster performance is measured as the number of services that have two replicas running on machines connected directly. Help to write the extension that will maximize the cluster performance.", "inputFormat": "The first line contains a single integer $T$ ($1 \\leq T \\leq 10^5$) --- the number of test cases. Descriptions of test cases follow.\n\nThe first line of each test case contains a single integer $n$ ($1 \\leq n \\leq 10^5$).\n\nThe second line contains $2n$ integers $a_1, a_2, \\ldots, a_{2n}$ ($1 \\leq a_i \\leq n$). It is guaranteed that each value from $1$ to $n$ appears exactly twice in this sequence.\n\nEach of the next $2n-1$ lines contains two integers $u$ and $v$ ($1 \\leq u, v \\leq 2n$, $u \\neq v$), meaning that machines $u$ and $v$ are connected directly. Direct connections are guaranteed to form a tree.\n\nIt is guaranteed that the sum of $n$ for all test cases does not exceed $10^5$.", "outputFormat": "For each test case on the first line print a single integer $k$ ($0 \\leq k \\leq n$) --- the number of swap operations the extension wants to make.\n\nEach of the next $k$ lines should contain two integers $i$, $j$ ($1 \\leq i, j \\leq 2n$, $i \\neq j$) --- swap operations. Each number from $1$ to $2n$ should appear at most once.\n\nNote that the order of operations is not important. After applying swap operations, the cluster performance should be the maximum possible. You can print any answer that satisfies the requirements.", "hint": "In the first test case only replicas of service 2 run on directly connected machines, so the performance is 1. The performance can be increased to 2 by swapping replicas between machines 1 and 3.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6cp342uy.png)\n\nIn the second test case no two replicas run on directly connected machines, so the performance is zero. The performance can be increased to 3 by performing swaps $1-5$, $8-3$, and $4-7$ so that replicas of services 2, 3, and 4 run on directly connected machines. It can be shown that it is impossible to get performance 4 here. \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ljhz2pf2.png)\n\nIn the third test case only replicas of service 1 run on directly connected machines, so the performance is 1. It is obvious that here the performance cannot be made any bigger.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ss4oj9ok.png)", "locale": "en"}, "zh-CN": {"title": "[NERC2024] Managing Cluster", "background": "", "description": "你打算开发一个集群管理扩展，以提升产品性能。你的产品包含 $n$ 个服务（编号从 $1$ 到 $n$），运行在一个拥有 $2n$ 台机器（编号从 $1$ 到 $2n$）的集群上。每个服务运行恰好两个副本，每个副本部署在某台机器上。每台机器恰好运行一个服务的副本。\n\n这个集群性能的关键因素之一是网络结构。一些机器之间存在直接连接，能够高效传输数据。一共存在 $2n - 1$ 条直接连接，并且任意两台机器之间都可以通过这些连接实现通信。换句话说，这些直接连接构成了一棵树。\n\n部署过程中，$2n$ 个副本已分配到机器。你的扩展程序将获取所有直接连接的信息，以及一个长度为 $2n$ 的序列 $a_1,a_2,\\ldots,a_{2n}$，其中 $a_i$ 表示第 $i$ 台机器上运行的服务编号。\n\n你的程序可以对副本进行交换操作。一次交换操作选定两台机器 $i$ 和 $j$，交换 $a_i$ 和 $a_j$ 的值。每台机器最多参与一次交换操作。\n\n你需要设计一组交换操作，以使集群性能最大化。\n\n由于同一服务的两个副本之间的数据交换最为频繁，集群性能定义为：有多少个服务的两个副本位于一对直接连接的机器上。\n\n请你编写程序，输出一组交换操作，使得集群性能最大。", "inputFormat": "第一行包含一个整数 $T\\;(1 \\leq T \\leq 10^5)$，表示测试用例的数量。\n\n每组测试用例包括如下内容：\n\n- 第一行一个整数 $n\\;(1 \\leq n \\leq 10^5)$，表示服务数量；\n- 第二行 $2n$ 个整数 $a_1,a_2,\\ldots,a_{2n}$（$1 \\leq a_i \\leq n$），表示每台机器当前运行的服务编号。保证每个服务编号出现恰好两次；\n- 接下来的 $2n - 1$ 行，每行两个整数 $u,v$（$1 \\leq u,v \\leq 2n$，$u \\ne v$），表示第 $u$ 台机器与第 $v$ 台机器之间存在直接连接。保证这些连接构成一棵树。\n\n保证所有测试用例中 $n$ 的总和不超过 $10^5$。", "outputFormat": "对于每组测试用例：\n\n- 第一行输出一个整数 $k\\;(0 \\leq k \\leq n)$，表示进行的交换操作次数；\n- 接下来的 $k$ 行，每行输出两个整数 $i$ 和 $j$（$1 \\leq i,j \\leq 2n$，$i \\ne j$），表示将第 $i$ 台机器和第 $j$ 台机器上的服务副本进行交换。注意，每台机器至多参与一次交换。\n\n交换操作的顺序无关紧要。交换完成后，集群性能必须达到最大。输出任意一组满足条件的解均可。", "hint": "在第一个测试用例中，只有服务 $2$ 的两个副本处于相邻的机器上，因此性能为 $1$。通过交换机器 $1$ 和 $3$ 上的副本，可以使服务 $1$ 和服务 $2$ 的副本都位于相邻机器上，性能提升至 $2$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6cp342uy.png)\n\n在第二个测试用例中，没有任何服务的副本处于相邻机器上，初始性能为 $0$。通过交换 $(1,5)$，$(8,3)$ 和 $(4,7)$ 三对机器，可以让服务 $2$、$3$ 和 $4$ 的副本分别配对，从而性能提升到 $3$。可以证明此时无法再提升至 $4$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ljhz2pf2.png)\n\n在第三个测试用例中，只有服务 $1$ 的两个副本在相邻机器上，性能为 $1$，且无法进一步提升。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ss4oj9ok.png)", "locale": "zh-CN"}}}
{"pid": "P12105", "type": "P", "difficulty": 2, "samples": [["7 4", "4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "ICPC", "NWRRC"], "title": "[NWRRC2024] Another Brick in the Wall", "background": "", "description": "Alice likes building toy walls. She has a lot of $1 \\times 2$ bricks and a limited supply of $1 \\times 3$ bricks. Both types of bricks have a height of 1 and can not be rotated.\n\nAlice is going to build a one unit thick wall of length $l$ and height $h$ out of these bricks. A wall is $\\textit{solid}$ if there are no seams directly above another seam.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zgs4gn57.png)\n\nHelp Alice determine the minimum number of $1 \\times 3$ bricks required to build a solid wall of length $l$ and height $h$.", "inputFormat": "The only line contains two integers $l$ and $h$, denoting the length and the height of the wall ($5 \\le l \\le 1000$; $2 \\le h \\le 1000$).", "outputFormat": "Print the minimum number of $1 \\times 3$ bricks required to build a solid $l \\times h$ wall.\n\nIt can be shown that it is always possible to build a solid wall of length $l$ and height $h$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NWRRC2024] Another Brick in the Wall", "background": "", "description": "Alice likes building toy walls. She has a lot of $1 \\times 2$ bricks and a limited supply of $1 \\times 3$ bricks. Both types of bricks have a height of 1 and can not be rotated.\n\nAlice is going to build a one unit thick wall of length $l$ and height $h$ out of these bricks. A wall is $\\textit{solid}$ if there are no seams directly above another seam.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zgs4gn57.png)\n\nHelp Alice determine the minimum number of $1 \\times 3$ bricks required to build a solid wall of length $l$ and height $h$.", "inputFormat": "The only line contains two integers $l$ and $h$, denoting the length and the height of the wall ($5 \\le l \\le 1000$; $2 \\le h \\le 1000$).", "outputFormat": "Print the minimum number of $1 \\times 3$ bricks required to build a solid $l \\times h$ wall.\n\nIt can be shown that it is always possible to build a solid wall of length $l$ and height $h$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NWRRC2024] Another Brick in the Wall", "background": "", "description": "Alice 喜欢搭建玩具墙。她拥有许多 $1 \\times 2$ 的砖块和数量有限的 $1 \\times 3$ 砖块。两种砖块的高度均为 1 且不可旋转。\n\nAlice 打算用这些砖块建造一堵长度为 $l$、高度为 $h$ 的单层厚度墙。一堵墙被称为$\\textit{坚固的}$，当且仅当不存在上下直接对齐的砖缝。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zgs4gn57.png)\n\n请帮助 Alice 计算出建造一堵长度为 $l$、高度为 $h$ 的坚固墙所需的最少数量的 $1 \\times 3$ 砖块。", "inputFormat": "输入仅一行，包含两个整数 $l$ 和 $h$，分别表示墙的长度和高度（$5 \\le l \\le 1000$；$2 \\le h \\le 1000$）。", "outputFormat": "输出建造一堵 $l \\times h$ 的坚固墙所需的最少数量的 $1 \\times 3$ 砖块。\n\n可以证明，总是能够建造出满足条件的坚固墙。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12106", "type": "P", "difficulty": 0, "samples": [["3\n3 3\ns.#\n...\n#.f\n6 7\n..#.#..\ns..#..#\n....#f.\n#..#...\n#......\n#.....#\n2 2\ns.\n.f", "1\n2\n-1"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "ICPC", "NWRRC"], "title": "[NWRRC2024] Brick in the Wall, Part 2", "background": "", "description": "Barrett 在他的房子下方发现了一个古老的迷宫。该迷宫呈 $n \\times m$ 网格状，其中部分格子为空地，其他则为障碍物。若两个空格子共享一条边，则可以从一个格子走到另一个。迷宫中有一个入口格子和一个出口格子，且可以通过空格子从入口走到出口。\n\nBarrett 希望通过在迷宫中建造一堵墙来隔离他的房子，通过阻挡部分格子使得出口无法从入口到达。这堵墙必须是笔直的，且方向只能是垂直或水平。具体而言，长度为 $k$ 的墙将阻挡恰好 $k$ 个连续的行或列格子。墙不能包含入口、出口或任何已有障碍物的格子。\n\n请帮助 Barrett 确定这堵墙的最小可能长度。", "inputFormat": "每个测试包含多个测试用例。第一行包含测试用例的数量 $t$（$1 \\le t \\le 10^5$）。接下来是各测试用例的描述。\n\n每个测试用例的第一行包含两个整数 $n$ 和 $m$，分别表示迷宫的高度和宽度（$2 \\le n, m \\le 1000$）。\n\n接下来的 $n$ 行中，第 $i$ 行包含 $m$ 个字符，描述迷宫的第 $i$ 行，其中：\n\n- $\\texttt{.}$ 表示空格子；\n- $\\texttt{\\#}$ 表示障碍物格子；\n- $\\texttt{s}$ 表示入口格子；\n- $\\texttt{f}$ 表示出口格子。\n\n迷宫中恰好有一个入口格子和一个出口格子，且可以通过空格子从入口走到出口。\n\n保证所有测试用例的 $n \\cdot m$ 之和不超过 $10^6$。", "outputFormat": "对于每个测试用例，输出使得出口无法从入口到达所需建造的墙的最小长度。\n\n如果无法建造这样的墙，则输出 $-1$。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[NWRRC2024] Brick in the Wall, Part 2", "background": "", "description": "Barrett has discovered an ancient maze under his house. It has the shape of an $n \\times m$ grid, where some cells are empty, while others are blocked. It is possible to walk from one empty cell to another if they share a side. Two of the empty cells are an entrance and an exit, and it is possible to reach one from the other by walking through empty cells.\n\nBarrett wants to isolate his house by building a wall inside the maze, blocking some cells to make the exit unreachable from the entrance. The wall should be straight and oriented either vertically or horizontally. Specifically, a wall of length $k$ will block a consecutive row or column of exactly $k$ cells. The wall may not contain the entrance, the exit, or any already blocked cells.\n\nHelp Barrett determine the minimum possible length of the wall.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^5$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$, denoting the height and the width of the~maze ($2 \\le n, m \\le 1000$).\n\nThe $i$-th of the following $n$ lines contains $m$ characters and describes the $i$-th row of the maze, where:\n\n- $\\texttt{.}$ denotes an empty cell;\n- $\\texttt{\\#}$ denotes a blocked cell;\n- $\\texttt{s}$ denotes an entrance cell;\n- $\\texttt{f}$ denotes an exit cell.\n\nThe maze contains exactly one entrance cell and exactly one exit cell, and it is possible to reach one from the other by walking through empty cells.\n\nIt is guaranteed that the sum of $n \\cdot m$ over all test cases does not exceed $10^6$.", "outputFormat": "For each test case, print the minimum length of the wall required to make the exit unreachable from the entrance.\n\nIf it is impossible to build such a wall, print $-1$ instead.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NWRRC2024] Brick in the Wall, Part 2", "background": "", "description": "Barrett 在他的房子下方发现了一个古老的迷宫。该迷宫呈 $n \\times m$ 网格状，其中部分格子为空地，其他则为障碍物。若两个空格子共享一条边，则可以从一个格子走到另一个。迷宫中有一个入口格子和一个出口格子，且可以通过空格子从入口走到出口。\n\nBarrett 希望通过在迷宫中建造一堵墙来隔离他的房子，通过阻挡部分格子使得出口无法从入口到达。这堵墙必须是笔直的，且方向只能是垂直或水平。具体而言，长度为 $k$ 的墙将阻挡恰好 $k$ 个连续的行或列格子。墙不能包含入口、出口或任何已有障碍物的格子。\n\n请帮助 Barrett 确定这堵墙的最小可能长度。", "inputFormat": "每个测试包含多个测试用例。第一行包含测试用例的数量 $t$（$1 \\le t \\le 10^5$）。接下来是各测试用例的描述。\n\n每个测试用例的第一行包含两个整数 $n$ 和 $m$，分别表示迷宫的高度和宽度（$2 \\le n, m \\le 1000$）。\n\n接下来的 $n$ 行中，第 $i$ 行包含 $m$ 个字符，描述迷宫的第 $i$ 行，其中：\n\n- $\\texttt{.}$ 表示空格子；\n- $\\texttt{\\#}$ 表示障碍物格子；\n- $\\texttt{s}$ 表示入口格子；\n- $\\texttt{f}$ 表示出口格子。\n\n迷宫中恰好有一个入口格子和一个出口格子，且可以通过空格子从入口走到出口。\n\n保证所有测试用例的 $n \\cdot m$ 之和不超过 $10^6$。", "outputFormat": "对于每个测试用例，输出使得出口无法从入口到达所需建造的墙的最小长度。\n\n如果无法建造这样的墙，则输出 $-1$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12107", "type": "P", "difficulty": 6, "samples": [["4\n4 1 3\n1 3\n5 0 2\n9 4 3\n1 3\n1 6\n4 6\n6 8\n3 0 1001", "6\n0\n54\n1754647"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2024", "分治", "矩阵加速", "组合数学", "ICPC", "NWRRC"], "title": "[NWRRC2024] Capybara Cozy Carnival", "background": "", "description": "Chilling capybaras celebrate Capybara Cozy Carnival. Chairman capybara cuts convex cake. Cake contains $n$ colorful corners. Countless colors comprise $k$ choices. Creating $m$ continuous crossing-free corner-to-corner cuts, chairman cuts cake chunks, catering $m + 1$ comrades. Curiously, consecutive cake chunks corners contain contrasting colors. \n\nCalculate cake corners color combinations, considering cuts conditions.\n\nIn other words, you are given a cake in the shape of a regular $n$-sided polygon and $m$ non-intersecting diagonal cuts, which divide it into $m + 1$ slices.\n\nCalculate the number of ways to color each corner of the original cake with one of the $k$ colors, such that no two neighboring corners of the resulting slices have the same color. Two corners are considered neighboring if they are either consecutive in the original cake, or they are the endpoints of the same cut. It is not necessary to use all the colors. As the number of ways might be large, find it modulo $998\\,244\\,353$.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $m$, and $k$, denoting the number of cake corners, the number of cuts, and the number of available colors ($3 \\le n \\le 10^9$; $0 \\le m \\le 2\\cdot 10^5$; $2 \\le k \\le 10^6$).\n\nThe $i$-th of the following $m$ lines contains two integers $u_i$ and $v_i$, denoting the corners connected by the $i$-th cut ($1 \\le u_i < v_i \\le n$). No two cuts may coincide or intersect except at the ends of the cuts. All cuts are straight, going strictly inside the cake.\n\nIt is guaranteed that the sum of $m$ over all test cases does not exceed $2\\cdot 10^5$.", "outputFormat": "For each test case, print the number of ways to color the cake corners such that no two neighboring corners have the same color, modulo $998\\,244\\,353$. Remember that you don't have to use all the colors.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NWRRC2024] Capybara Cozy Carnival", "background": "", "description": "Chilling capybaras celebrate Capybara Cozy Carnival. Chairman capybara cuts convex cake. Cake contains $n$ colorful corners. Countless colors comprise $k$ choices. Creating $m$ continuous crossing-free corner-to-corner cuts, chairman cuts cake chunks, catering $m + 1$ comrades. Curiously, consecutive cake chunks corners contain contrasting colors. \n\nCalculate cake corners color combinations, considering cuts conditions.\n\nIn other words, you are given a cake in the shape of a regular $n$-sided polygon and $m$ non-intersecting diagonal cuts, which divide it into $m + 1$ slices.\n\nCalculate the number of ways to color each corner of the original cake with one of the $k$ colors, such that no two neighboring corners of the resulting slices have the same color. Two corners are considered neighboring if they are either consecutive in the original cake, or they are the endpoints of the same cut. It is not necessary to use all the colors. As the number of ways might be large, find it modulo $998\\,244\\,353$.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $m$, and $k$, denoting the number of cake corners, the number of cuts, and the number of available colors ($3 \\le n \\le 10^9$; $0 \\le m \\le 2\\cdot 10^5$; $2 \\le k \\le 10^6$).\n\nThe $i$-th of the following $m$ lines contains two integers $u_i$ and $v_i$, denoting the corners connected by the $i$-th cut ($1 \\le u_i < v_i \\le n$). No two cuts may coincide or intersect except at the ends of the cuts. All cuts are straight, going strictly inside the cake.\n\nIt is guaranteed that the sum of $m$ over all test cases does not exceed $2\\cdot 10^5$.", "outputFormat": "For each test case, print the number of ways to color the cake corners such that no two neighboring corners have the same color, modulo $998\\,244\\,353$. Remember that you don't have to use all the colors.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NWRRC2024] Capybara Cozy Carnival", "background": "", "description": "悠闲的水豚们正在庆祝水豚温馨嘉年华。水豚主席正在切分一块凸形蛋糕。这块蛋糕有 $n$ 个彩色顶点，使用无数种颜色中的 $k$ 种可选颜色。主席通过制作 $m$ 条连续且不相交的顶点间切分线，将蛋糕分成 $m + 1$ 块分发给同伴们。有趣的是，相邻蛋糕块的顶点必须使用对比色。\n\n请计算满足切分条件的蛋糕顶点着色方案数。\n\n换句话说，给定一个正 $n$ 边形的蛋糕和 $m$ 条不相交的对角线切分，这些切分将蛋糕分成 $m + 1$ 个切片。\n\n计算将原始蛋糕每个顶点用 $k$ 种颜色之一着色的方案数，要求最终切片中任何相邻顶点颜色不同。两个顶点被认为是相邻的，如果它们在原始蛋糕中是连续的，或者是同一条切分线的端点。不需要使用所有颜色。由于方案数可能很大，请输出其对 $998\\,244\\,353$ 取模的结果。\n", "inputFormat": "每个测试包含多个测试用例。第一行包含测试用例数量 $t$（$1 \\le t \\le 10^4$）。接下来是各测试用例的描述。\n\n每个测试用例的第一行包含三个整数 $n$、$m$ 和 $k$，分别表示蛋糕顶点数、切分线数和可用颜色数（$3 \\le n \\le 10^9$；$0 \\le m \\le 2\\cdot 10^5$；$2 \\le k \\le 10^6$）。\n\n接下来的 $m$ 行中，第 $i$ 行包含两个整数 $u_i$ 和 $v_i$，表示第 $i$ 条切分线连接的两个顶点（$1 \\le u_i < v_i \\le n$）。任意两条切分线不能重合或相交（端点除外），所有切分线都严格位于蛋糕内部。\n\n保证所有测试用例的 $m$ 之和不超过 $2\\cdot 10^5$。", "outputFormat": "对于每个测试用例，输出满足相邻顶点颜色不同的着色方案数，对 $998\\,244\\,353$ 取模。注意不需要使用所有颜色。\n", "hint": "在第一个测试用例中，顶点 $1$ 有 $3$ 种颜色可选，顶点 $2$ 有 $2$ 种剩余颜色可选，顶点 $3$ 使用最后一种颜色，顶点 $4$ 必须与顶点 $2$ 同色。因此共有 $6$ 种方案。\n\n在第二个测试用例中，顶点数为奇数且只有两种颜色，要求每对连续顶点颜色不同，这是不可能的。", "locale": "zh-CN"}}}
{"pid": "P12108", "type": "P", "difficulty": 5, "samples": [["5\n4\n9 9 6 8\n2\n3 5\n9\n9 9 8 2 4 4 3 5 3\n3\n777 777 777\n6\n0 1 0 1 0 1", "5\n1\n0\n777\n0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "数论", "高斯消元", "ICPC", "NWRRC"], "title": "[NWRRC2024] Defective Script", "background": "", "description": "Devin is a system administrator at a tech company that manages a network of $n$ servers arranged in a ring topology. Each server is handling a certain amount of computational load, represented by a non-negative integer $a_i$, where $i$ ranges from $1$ to $n$.\n\nTo optimize the network performance and ensure fairness, Devin wants to equalize the load across all servers, making each server handle the same amount of load. He aims to maximize this equal load as much as possible.\n\nDevin has developed a script to reduce the load on any server. When he runs the script on server $i$, it is supposed to decrease the load on that server by $2$ units (down to a minimum of zero). However, due to a known bug in the script, every time it's executed on server $i$, it inadvertently removes an additional~$1$~unit of load from the previous server in the network (server $i-1$). If $i = 1$, the previous server is server $n$ (since the servers form a ring).\n\nDevin can run this buggy script any number of times (including zero), each time choosing any server to run it on. He can run the script on a server even if its current load is less than $2$ units, or if the load of the previous server is zero (in both cases the load goes to zero).\n\nHelp Devin determine the maximum possible equal load that can be achieved on all servers using his script.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$, denoting the number of servers ($2 \\le n \\le 2 \\cdot 10^5$).\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$, denoting the amounts of load the servers are handling ($0 \\le a_i \\le 10^9$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.", "outputFormat": "For each test case, print the maximum possible equal load that can be achieved on all servers.", "hint": "In the first test case, Devin can run the script once on server $1$, twice on server $2$, and once on server $4$. As a result, each server will be handling $5$ units of load.", "locale": "en", "translations": {"en": {"title": "[NWRRC2024] Defective Script", "background": "", "description": "Devin is a system administrator at a tech company that manages a network of $n$ servers arranged in a ring topology. Each server is handling a certain amount of computational load, represented by a non-negative integer $a_i$, where $i$ ranges from $1$ to $n$.\n\nTo optimize the network performance and ensure fairness, Devin wants to equalize the load across all servers, making each server handle the same amount of load. He aims to maximize this equal load as much as possible.\n\nDevin has developed a script to reduce the load on any server. When he runs the script on server $i$, it is supposed to decrease the load on that server by $2$ units (down to a minimum of zero). However, due to a known bug in the script, every time it's executed on server $i$, it inadvertently removes an additional~$1$~unit of load from the previous server in the network (server $i-1$). If $i = 1$, the previous server is server $n$ (since the servers form a ring).\n\nDevin can run this buggy script any number of times (including zero), each time choosing any server to run it on. He can run the script on a server even if its current load is less than $2$ units, or if the load of the previous server is zero (in both cases the load goes to zero).\n\nHelp Devin determine the maximum possible equal load that can be achieved on all servers using his script.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$, denoting the number of servers ($2 \\le n \\le 2 \\cdot 10^5$).\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$, denoting the amounts of load the servers are handling ($0 \\le a_i \\le 10^9$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.", "outputFormat": "For each test case, print the maximum possible equal load that can be achieved on all servers.", "hint": "In the first test case, Devin can run the script once on server $1$, twice on server $2$, and once on server $4$. As a result, each server will be handling $5$ units of load.", "locale": "en"}, "zh-CN": {"title": "[NWRRC2024] Defective Script", "background": "", "description": "Devin 是一家科技公司的系统管理员，负责管理由 $n$ 台服务器组成的环形拓扑网络。每台服务器当前承载的计算负载用一个非负整数 $a_i$ 表示，其中 $i$ 的取值范围是 $1$ 到 $n$。\n\n为了优化网络性能并确保公平性，Devin 希望均衡所有服务器的负载，使每台服务器承担相同的工作量。他的目标是尽可能最大化这个均衡后的负载值。\n\nDevin 开发了一个脚本来减少服务器的负载。当在服务器 $i$ 上运行该脚本时，理论上应该将该服务器的负载减少 $2$ 个单位（最低减至零）。但由于脚本中存在已知缺陷，每次在服务器 $i$ 上执行时，还会意外地使网络中前一台服务器（服务器 $i-1$）的负载减少 $1$ 个单位。如果 $i = 1$，则前一台服务器是服务器 $n$（因为服务器构成环形拓扑）。\n\nDevin 可以任意次数（包括零次）运行这个有缺陷的脚本，每次可以选择任意服务器执行。即使某台服务器当前负载不足 $2$ 个单位，或者前一台服务器的负载为零，仍然可以运行脚本（在这两种情况下负载都会降至零）。\n\n请帮助 Devin 确定使用该脚本后，所有服务器能够达到的最大可能均衡负载值。", "inputFormat": "每个测试包含多个测试用例。第一行包含测试用例数量 $t$（$1 \\le t \\le 10^4$）。接下来是各测试用例的描述。\n\n每个测试用例的第一行包含一个整数 $n$，表示服务器数量（$2 \\le n \\le 2 \\cdot 10^5$）。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\ldots, a_n$，表示各服务器当前承载的负载值（$0 \\le a_i \\le 10^9$）。\n\n保证所有测试用例的 $n$ 之和不超过 $2 \\cdot 10^5$。", "outputFormat": "对于每个测试用例，输出所有服务器能够达到的最大可能均衡负载值。", "hint": "在第一个测试用例中，Devin 可以在服务器 $1$ 上运行脚本 $1$ 次，服务器 $2$ 上运行 $2$ 次，服务器 $4$ 上运行 $1$ 次。最终每台服务器都将承担 $5$ 个单位的负载。", "locale": "zh-CN"}}}
{"pid": "P12109", "type": "P", "difficulty": 7, "samples": [["2\n5\n1 1 1\n1 3 1\n3 1 1\n3 3 1\n6 7 4\n6\n-3 0 3\n-2 0 2\n-1 0 1\n1 0 1\n2 0 2\n3 0 3", "5\n9"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "ICPC", "NWRRC"], "title": "[NWRRC2024] Eight-Shaped Figures", "background": "*Looking at problems `K-Shaped Figures` and `H-Shaped Figures` from the past two years, you took the warning seriously. You came prepared. For each of the remaining 24 letters of the alphabet, you theorized what the problem could be. You even implemented all 24 solutions and used up all of your Digital Team Reference Document space just to bring these codes to the contest. If the judges are so unoriginal that they set another problem about letter shapes, you'll just get it accepted on minute 1 and leave everyone puzzled.*\n\n*What, another shapes problem? Really?! Ha-ha! Oh... wait a second...*", "description": "Let's say that two circles on a plane form an $\\textit{8-shaped figure}$ if they touch each other, but neither of them lies inside the other one.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/selhsqb5.png)\n\nYou are given a collection of $n$ circles on the plane. No two circles have more than one common point. In other words, no two circles intersect twice or coincide, but they can touch or lie one within another.\n\nFind the number of pairs of circles from this collection that form an 8-shaped figure.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$, denoting the number of circles ($2 \\le n \\le 2 \\cdot 10^5$).\n \nThe $i$-th of the following $n$ lines contains three integers $x_i$, $y_i$, and $r_i$, denoting the coordinates of the center of the $i$-th circle and its radius ($-10^9 \\le x_i, y_i \\le 10^9$; $1 \\le r_i \\le 10^9$). No two circles intersect twice or coincide, but they can touch or lie one within another.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.", "outputFormat": "For each test case, print the number of pairs of circles that form an 8-shaped figure.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[NWRRC2024] Eight-Shaped Figures", "background": "*Looking at problems `K-Shaped Figures` and `H-Shaped Figures` from the past two years, you took the warning seriously. You came prepared. For each of the remaining 24 letters of the alphabet, you theorized what the problem could be. You even implemented all 24 solutions and used up all of your Digital Team Reference Document space just to bring these codes to the contest. If the judges are so unoriginal that they set another problem about letter shapes, you'll just get it accepted on minute 1 and leave everyone puzzled.*\n\n*What, another shapes problem? Really?! Ha-ha! Oh... wait a second...*", "description": "Let's say that two circles on a plane form an $\\textit{8-shaped figure}$ if they touch each other, but neither of them lies inside the other one.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/selhsqb5.png)\n\nYou are given a collection of $n$ circles on the plane. No two circles have more than one common point. In other words, no two circles intersect twice or coincide, but they can touch or lie one within another.\n\nFind the number of pairs of circles from this collection that form an 8-shaped figure.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$, denoting the number of circles ($2 \\le n \\le 2 \\cdot 10^5$).\n \nThe $i$-th of the following $n$ lines contains three integers $x_i$, $y_i$, and $r_i$, denoting the coordinates of the center of the $i$-th circle and its radius ($-10^9 \\le x_i, y_i \\le 10^9$; $1 \\le r_i \\le 10^9$). No two circles intersect twice or coincide, but they can touch or lie one within another.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.", "outputFormat": "For each test case, print the number of pairs of circles that form an 8-shaped figure.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NWRRC2024] Eight-Shaped Figures", "background": "*看到过去两年\"K 字形图形\"和\"H 字形图形\"的问题后，你认真对待了这个警告。你做好了充分准备。对于字母表中剩下的 24 个字母，你都设想了可能出现的题目。你甚至实现了所有 24 个解决方案，并耗尽了数字团队参考文档的所有空间，就为了把这些代码带到比赛现场。如果评委们如此缺乏创意，又出了一道关于字母形状的题目，你就能在第 1 分钟提交通过，让所有人都困惑不已。*\n\n*什么，又是图形题？真的吗？！哈哈！哦...等等...*", "description": "我们定义平面上的两个圆构成一个 $\\textit{8 字形图形}$，当且仅当它们彼此相切，且没有一个圆完全位于另一个圆内部。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/selhsqb5.png)\n\n给定平面上 $n$ 个圆的集合。任意两个圆最多有一个公共点。换句话说，任意两个圆不会相交两次或重合，但它们可以相切或一个圆位于另一个圆内部。\n\n请计算这些圆中有多少对构成了 8 字形图形。", "inputFormat": "每个测试包含多个测试用例。第一行包含测试用例数量 $t$（$1 \\le t \\le 10^4$）。接下来是各测试用例的描述。\n\n每个测试用例的第一行包含一个整数 $n$，表示圆的个数（$2 \\le n \\le 2 \\cdot 10^5$）。\n\n接下来的 $n$ 行中，第 $i$ 行包含三个整数 $x_i$、$y_i$ 和 $r_i$，分别表示第 $i$ 个圆的圆心坐标和半径（$-10^9 \\le x_i, y_i \\le 10^9$；$1 \\le r_i \\le 10^9$）。任意两个圆不会相交两次或重合，但它们可以相切或一个圆位于另一个圆内部。\n\n保证所有测试用例的 $n$ 之和不超过 $2 \\cdot 10^5$。", "outputFormat": "对于每个测试用例，输出构成 8 字形图形的圆的对数。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12110", "type": "P", "difficulty": 2, "samples": [["5\n7:47\n7:56\n7:59\n8:05\n8:13", "0"], ["7\n8:00\n8:10\n8:20\n8:30\n8:40\n8:50\n9:00", "1"], ["3\n7:13\n7:41\n8:36", "2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "排序", "ICPC", "NWRRC"], "title": "[NWRRC2024] False Alarm", "background": "", "description": "Faina is going to sleep, but she needs to wake up early tomorrow for a very important contest. She has already set $n$ alarms at different times between 7:00 and 9:00 in the morning.\n\nHowever, Faina is a deep sleeper. She knows that in order to wake up, she will need to hear at least three alarms within a 10-minute timespan. In other words, for some three alarms, the difference between the first and the last alarm must be 10 minutes or less.\n\nFaina is not sure if the current set of alarms she has satisfies this condition, and she is worried she might oversleep the contest (and make her teammates angry!). Thus, she wants to set some additional alarms. All new alarms should also be set between 7:00 and 9:00, and all alarms, including the old ones, must be set at different times.\n\nFind the smallest number of additional alarms Faina has to set to be confident that she will wake up. In~particular, if she can already be sure she'll wake up, the number of additional alarms is $0$.", "inputFormat": "The first line contains a single integer $n$, denoting the number of alarms Faina has set ($1 \\le n \\le 20$).\n\nThe $i$-th of the following $n$ lines contains the time of the $i$-th alarm in the $\\tt{h:mm}$ format ($7 \\le \\mathtt{h} \\le 9$; $00 \\le \\mathtt{mm} \\le 59$; if $\\mathtt{h} = 9$, then $\\mathtt{mm} = 00$). The alarms are given in strictly increasing order of time.", "outputFormat": "Print the smallest number of additional alarms Faina has to set in order to guarantee waking up.", "hint": "In the first test, three alarms at 7:56, 7:59, and 8:05 guarantee that Faina will wake up.\n\nIn the second test, any time between 8:00 and 9:00 that does not coincide with existing alarms works.\n\nIn the third test, one possible solution is to set two more alarms at 7:45 and 7:46.", "locale": "en", "translations": {"en": {"title": "[NWRRC2024] False Alarm", "background": "", "description": "Faina is going to sleep, but she needs to wake up early tomorrow for a very important contest. She has already set $n$ alarms at different times between 7:00 and 9:00 in the morning.\n\nHowever, Faina is a deep sleeper. She knows that in order to wake up, she will need to hear at least three alarms within a 10-minute timespan. In other words, for some three alarms, the difference between the first and the last alarm must be 10 minutes or less.\n\nFaina is not sure if the current set of alarms she has satisfies this condition, and she is worried she might oversleep the contest (and make her teammates angry!). Thus, she wants to set some additional alarms. All new alarms should also be set between 7:00 and 9:00, and all alarms, including the old ones, must be set at different times.\n\nFind the smallest number of additional alarms Faina has to set to be confident that she will wake up. In~particular, if she can already be sure she'll wake up, the number of additional alarms is $0$.", "inputFormat": "The first line contains a single integer $n$, denoting the number of alarms Faina has set ($1 \\le n \\le 20$).\n\nThe $i$-th of the following $n$ lines contains the time of the $i$-th alarm in the $\\tt{h:mm}$ format ($7 \\le \\mathtt{h} \\le 9$; $00 \\le \\mathtt{mm} \\le 59$; if $\\mathtt{h} = 9$, then $\\mathtt{mm} = 00$). The alarms are given in strictly increasing order of time.", "outputFormat": "Print the smallest number of additional alarms Faina has to set in order to guarantee waking up.", "hint": "In the first test, three alarms at 7:56, 7:59, and 8:05 guarantee that Faina will wake up.\n\nIn the second test, any time between 8:00 and 9:00 that does not coincide with existing alarms works.\n\nIn the third test, one possible solution is to set two more alarms at 7:45 and 7:46.", "locale": "en"}, "zh-CN": {"title": "[NWRRC2024] False Alarm", "background": "", "description": "Faina 正准备睡觉，但她明天早上需要早起参加一场非常重要的比赛。她已经在早上 7:00 到 9:00 之间设置了 $n$ 个不同时间的闹钟。\n\n然而，Faina 是个睡得很沉的人。她知道要想醒来，必须在 10 分钟的时间段内听到至少三个闹钟。换句话说，需要存在三个闹钟，其中第一个和最后一个闹钟之间的时间差不超过 10 分钟。\n\nFaina 不确定当前的闹钟设置是否满足这个条件，她担心可能会睡过头错过比赛（还会让队友生气！）。因此，她想要设置一些额外的闹钟。所有新闹钟也必须在 7:00 到 9:00 之间设置，并且所有闹钟（包括原有的）时间都必须不同。\n\n请找出 Faina 需要设置的最少数量的额外闹钟，以确保她能够醒来。特别地，如果现有的闹钟已经能确保她醒来，则额外闹钟数量为 $0$。", "inputFormat": "第一行包含一个整数 $n$，表示 Faina 已设置的闹钟数量（$1 \\le n \\le 20$）。\n\n接下来的 $n$ 行中，第 $i$ 行以 $\\tt{h:mm}$ 格式给出第 $i$ 个闹钟的时间（$7 \\le \\mathtt{h} \\le 9$；$00 \\le \\mathtt{mm} \\le 59$；如果 $\\mathtt{h} = 9$，则 $\\mathtt{mm} = 00$）。闹钟按时间严格递增的顺序给出。", "outputFormat": "输出 Faina 需要设置的最少数量的额外闹钟，以确保能够醒来。", "hint": "在第一个测试用例中，7:56、7:59 和 8:05 的三个闹钟已经能确保 Faina 醒来。\n\n在第二个测试用例中，任何在 8:00 到 9:00 之间且不与现有闹钟时间重合的时间都可以作为新增闹钟。\n\n在第三个测试用例中，一个可能的解决方案是新增 7:45 和 7:46 两个闹钟。\n", "locale": "zh-CN"}}}
{"pid": "P12111", "type": "P", "difficulty": 0, "samples": [["10\n2\n1 1 R\n2 1 B\n2\n1 1 B\n2 1 R\n2\n1 2 B\n4 1 R\n4\n1 1 B\n2 1 R\n4 3 B\n6 1 R\n2\n1 2 B\n3 1 R\n2\n1 2 B\n2 1 R\n2\n1 1 R\n2 2 B\n2\n1 2 R\n3 1 B\n3\n1 1 R\n2 1 R\n4 1 B\n2\n1 2 R\n2 1 B", "Draw 0 0\nDraw 2 -\nDraw 4 -\nDraw 2 -\nDraw 0 0\nDraw 2 +\nSecond\nDraw 0 0\nDraw 2 -\nFirst 1 +"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC2024] Game of Annihilation", "background": "", "description": "Two players are playing a game on a tape divided into cells that is infinite to the right. The cells are numbered with $1, 2, 3, \\ldots$ from left to right. Each cell $x$ is adjacent to cells $x - 1$ and $x + 1$, except for cell $1$, which is only adjacent to cell $2$.\n\nThere is a finite number of red chips (the first player's chips) and blue chips (the second player's chips) on the tape. Each cell contains either several red chips, or several blue chips, or no chips at all.\n\nThe players take turns. On their turn, a player can either skip the turn or take one of their chips and move it to an adjacent cell. If there are no opponent's chips in the adjacent cell, the turn ends; if there is at least one opponent's chip there, one chip from each player is removed from that cell --- thus, at the end of the turn, there will still be no two chips of different colors in the same cell.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bx8qdg2e.png)\n\nIf both players run out of chips, the game ends in a draw. If only one player runs out of chips, they are declared the loser, and their opponent is declared the winner. Finally, if after $10^{100}$ turns the game has not ended, it is forcibly concluded and declared a draw.\n\nYou are given the initial setup of the tape. Determine who will win with perfect play from both players, and find any optimal first move for the first player.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$, denoting the number of cells that initially contain at least one chip ($2 \\le n \\le 2 \\cdot 10^5$).\n\nThe $i$-th of the following $n$ lines contains two integers $x_i$, $m_i$, and a character $c_i$, denoting the coordinate of the $i$-th non-empty cell from the left, the number of chips in it, and the color of these chips ($1 \\le x_1 < x_2 < \\cdots < x_n \\le 10^6$; $1 \\le m_i \\le 10^6$; $c_i \\in \\{\\mathtt{R}, \\mathtt{B}\\}$). There is at least one chip of each color on the tape.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.", "outputFormat": "For each test case, print:\n- $\\texttt{First}$ $x$ $d$, if the first player (moving red chips) will win;\n- $\\texttt{Second}$, if the second player (moving blue chips) will win;\n- $\\texttt{Draw}$ $x$ $d$, if the outcome of the game will be a draw.\n\nIn the first and third cases, $x$ $d$ specifies any winning or drawing move, respectively --- that is, a move after which, with perfect play from the second player, there remains a possibility to win or draw the game. Here, $x$ is the coordinate of the red chip that the first player should move, and $d \\in \\{\\texttt{-}, \\texttt{+}\\}$ is the direction of the move ($\\texttt{-}$ means the chip should be moved to cell $x - 1$, and $\\texttt{+}$ means the chip should be moved to cell $x + 1$). If $d$ is $\\texttt{-}$, then $x$ must be greater than $1$. If you suggest that the first player skips their turn, print $\\texttt{0 0}$ instead of $x$ $d$.\n\nYou can print each letter in upper- or lowercase: for instance, the strings $\\texttt{First}$, $\\texttt{FIRST}$, $\\texttt{fiRST}$ will be considered equivalent by the checker.", "hint": "In the last test case, there is only one possible move besides $\\texttt{1 +}$, namely, $\\texttt{0 0}$ (skip the turn). It is a drawing move, though; hence, it will not be accepted.", "locale": "en", "translations": {"en": {"title": "[NWRRC2024] Game of Annihilation", "background": "", "description": "Two players are playing a game on a tape divided into cells that is infinite to the right. The cells are numbered with $1, 2, 3, \\ldots$ from left to right. Each cell $x$ is adjacent to cells $x - 1$ and $x + 1$, except for cell $1$, which is only adjacent to cell $2$.\n\nThere is a finite number of red chips (the first player's chips) and blue chips (the second player's chips) on the tape. Each cell contains either several red chips, or several blue chips, or no chips at all.\n\nThe players take turns. On their turn, a player can either skip the turn or take one of their chips and move it to an adjacent cell. If there are no opponent's chips in the adjacent cell, the turn ends; if there is at least one opponent's chip there, one chip from each player is removed from that cell --- thus, at the end of the turn, there will still be no two chips of different colors in the same cell.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bx8qdg2e.png)\n\nIf both players run out of chips, the game ends in a draw. If only one player runs out of chips, they are declared the loser, and their opponent is declared the winner. Finally, if after $10^{100}$ turns the game has not ended, it is forcibly concluded and declared a draw.\n\nYou are given the initial setup of the tape. Determine who will win with perfect play from both players, and find any optimal first move for the first player.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$, denoting the number of cells that initially contain at least one chip ($2 \\le n \\le 2 \\cdot 10^5$).\n\nThe $i$-th of the following $n$ lines contains two integers $x_i$, $m_i$, and a character $c_i$, denoting the coordinate of the $i$-th non-empty cell from the left, the number of chips in it, and the color of these chips ($1 \\le x_1 < x_2 < \\cdots < x_n \\le 10^6$; $1 \\le m_i \\le 10^6$; $c_i \\in \\{\\mathtt{R}, \\mathtt{B}\\}$). There is at least one chip of each color on the tape.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.", "outputFormat": "For each test case, print:\n- $\\texttt{First}$ $x$ $d$, if the first player (moving red chips) will win;\n- $\\texttt{Second}$, if the second player (moving blue chips) will win;\n- $\\texttt{Draw}$ $x$ $d$, if the outcome of the game will be a draw.\n\nIn the first and third cases, $x$ $d$ specifies any winning or drawing move, respectively --- that is, a move after which, with perfect play from the second player, there remains a possibility to win or draw the game. Here, $x$ is the coordinate of the red chip that the first player should move, and $d \\in \\{\\texttt{-}, \\texttt{+}\\}$ is the direction of the move ($\\texttt{-}$ means the chip should be moved to cell $x - 1$, and $\\texttt{+}$ means the chip should be moved to cell $x + 1$). If $d$ is $\\texttt{-}$, then $x$ must be greater than $1$. If you suggest that the first player skips their turn, print $\\texttt{0 0}$ instead of $x$ $d$.\n\nYou can print each letter in upper- or lowercase: for instance, the strings $\\texttt{First}$, $\\texttt{FIRST}$, $\\texttt{fiRST}$ will be considered equivalent by the checker.", "hint": "In the last test case, there is only one possible move besides $\\texttt{1 +}$, namely, $\\texttt{0 0}$ (skip the turn). It is a drawing move, though; hence, it will not be accepted.", "locale": "en"}, "zh-CN": {"title": "[NWRRC2024] Game of Annihilation", "background": "", "description": "两名玩家在一个向右无限延伸的纸带上进行游戏。纸带被划分为编号为 $1, 2, 3, \\ldots$ 的格子，从左到右排列。每个格子 $x$ 与 $x - 1$ 和 $x + 1$ 相邻，除了格子 $1$ 只与格子 $2$ 相邻。\n\n纸带上放置有有限数量的红色筹码（先手玩家的筹码）和蓝色筹码（后手玩家的筹码）。每个格子要么包含多个红色筹码，要么包含多个蓝色筹码，要么为空。\n\n玩家轮流行动。在自己的回合中，玩家可以选择跳过回合，或者移动自己的一个筹码到相邻格子。如果目标格子没有对手的筹码，回合结束；如果目标格子有至少一个对手筹码，则双方各移除一个筹码——因此回合结束时，同一格子中仍不会存在不同颜色的筹码。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bx8qdg2e.png)\n\n如果双方筹码都耗尽，游戏以平局结束。如果仅一方筹码耗尽，则该方判负，对手获胜。若经过 $10^{100}$ 回合后游戏仍未结束，则强制判定为平局。\n\n给定纸带的初始状态，确定在双方都采取最优策略的情况下谁会获胜，并找出先手玩家的任意最优首步行动。", "inputFormat": "每个测试包含多个测试用例。第一行给出测试用例数量 $t$（$1 \\le t \\le 10^4$）。随后是各测试用例的描述。\n\n每个测试用例的第一行包含一个整数 $n$，表示初始有筹码的格子数量（$2 \\le n \\le 2 \\cdot 10^5$）。\n\n接下来的 $n$ 行中，第 $i$ 行包含两个整数 $x_i$, $m_i$ 和一个字符 $c_i$，分别表示从左数第 $i$ 个非空格子的坐标、筹码数量和颜色（$1 \\le x_1 < x_2 < \\cdots < x_n \\le 10^6$；$1 \\le m_i \\le 10^6$；$c_i \\in \\{\\mathtt{R}, \\mathtt{B}\\}$）。纸带上至少有一个红色和一个蓝色筹码。\n\n保证所有测试用例的 $n$ 之和不超过 $2 \\cdot 10^5$。", "outputFormat": "对于每个测试用例，输出：\n- $\\texttt{First}$ $x$ $d$，如果先手玩家（红色筹码）将获胜；\n- $\\texttt{Second}$，如果后手玩家（蓝色筹码）将获胜；\n- $\\texttt{Draw}$ $x$ $d$，如果游戏将以平局结束。\n\n在第一种和第三种情况下，$x$ $d$ 分别表示任意致胜或致和的首步行动——即在采取该行动后，面对后手玩家的最优策略，仍有可能获胜或达成平局。其中 $x$ 表示应移动的红色筹码坐标，$d \\in \\{\\texttt{-}, \\texttt{+}\\}$ 表示移动方向（$\\texttt{-}$ 表示移动到 $x - 1$，$\\texttt{+}$ 表示移动到 $x + 1$）。若 $d$ 为 $\\texttt{-}$，则 $x$ 必须大于 $1$。若建议先手玩家跳过回合，则输出 $\\texttt{0 0}$ 代替 $x$ $d$。\n\n输出字母大小写不限：例如 $\\texttt{First}$、$\\texttt{FIRST}$、$\\texttt{fiRST}$ 都会被判题器视为等效。", "hint": "在最后一个测试用例中，除了 $\\texttt{1 +}$ 外只有 $\\texttt{0 0}$（跳过回合）一种可能行动。虽然这是致和行动，但不会被接受为有效输出。\n", "locale": "zh-CN"}}}
{"pid": "P12112", "type": "P", "difficulty": 0, "samples": [["4\n1\n1\n3\n2\n3 3\n2 1\n3\n3 2 1\n1 2 3\n4\n2 1 3 2\n2 1 3 2", "2\n7\n20\n0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "ICPC", "NWRRC"], "title": "[NWRRC2024] Hanoi Towers Reloaded", "background": "", "description": "The $\\textit{Towers of Hanoi}$ is a famous mathematical puzzle consisting of three rods and $n$ disks with diameters $1, 2, \\ldots, n$. Each of the three rods contains some disks, stacked in order of decreasing diameter from bottom to top, so that the smallest disk is always at the top. A valid move consists of taking the smallest disk from a rod and putting it on top of another rod. This move must preserve the sorted order: you can't put a larger disk onto a smaller one. The original puzzle's goal is to transfer all disks from one rod to another.\n\nIn this variation of the puzzle, you can only move the disks $\\textbf{between adjacent rods}$: you can move a disk between rods $1$ and $2$, and between rods $2$ and $3$, but not between rods $1$ and $3$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8p2sy9bm.png)\n\nGiven two configurations of this puzzle, find the minimum number of moves required to reach the second configuration starting from the first one. As this number might be large, print it modulo $998\\,244\\,353$.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^3$). Descriptions of the test cases follow.\n\nThe first line of each test case contains an integer $n$, denoting the number of disks involved ($1 \\le n \\le 10^5$).\n\nThe second line contains $n$ integers $x_1, x_2, \\ldots, x_n$, describing the initial configuration of the puzzle, where $x_i$ is the rod that contains the $i$-th disk ($x_i \\in \\{ 1, 2, 3 \\}$).\n\nThe third line describes the final configuration of the puzzle in the same format.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.", "outputFormat": "For each test case, print the minimum number of moves required to reach the second configuration from the first one, modulo $998\\,244\\,353$.\n\nIt can be shown that any two configurations are reachable from each other in this variation of the puzzle.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NWRRC2024] Hanoi Towers Reloaded", "background": "", "description": "The $\\textit{Towers of Hanoi}$ is a famous mathematical puzzle consisting of three rods and $n$ disks with diameters $1, 2, \\ldots, n$. Each of the three rods contains some disks, stacked in order of decreasing diameter from bottom to top, so that the smallest disk is always at the top. A valid move consists of taking the smallest disk from a rod and putting it on top of another rod. This move must preserve the sorted order: you can't put a larger disk onto a smaller one. The original puzzle's goal is to transfer all disks from one rod to another.\n\nIn this variation of the puzzle, you can only move the disks $\\textbf{between adjacent rods}$: you can move a disk between rods $1$ and $2$, and between rods $2$ and $3$, but not between rods $1$ and $3$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8p2sy9bm.png)\n\nGiven two configurations of this puzzle, find the minimum number of moves required to reach the second configuration starting from the first one. As this number might be large, print it modulo $998\\,244\\,353$.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^3$). Descriptions of the test cases follow.\n\nThe first line of each test case contains an integer $n$, denoting the number of disks involved ($1 \\le n \\le 10^5$).\n\nThe second line contains $n$ integers $x_1, x_2, \\ldots, x_n$, describing the initial configuration of the puzzle, where $x_i$ is the rod that contains the $i$-th disk ($x_i \\in \\{ 1, 2, 3 \\}$).\n\nThe third line describes the final configuration of the puzzle in the same format.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.", "outputFormat": "For each test case, print the minimum number of moves required to reach the second configuration from the first one, modulo $998\\,244\\,353$.\n\nIt can be shown that any two configurations are reachable from each other in this variation of the puzzle.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NWRRC2024] Hanoi Towers Reloaded", "background": "", "description": " _汉诺塔_  是一个著名的数学谜题，由三根柱子和 $n$ 个直径分别为 $1, 2, \\ldots, n$ 的圆盘组成。每根柱子上都叠放着若干圆盘，从上到下直径依次递减，因此最小的圆盘总是在顶部。一个合法的移动操作是将某根柱子上最小的圆盘移动到另一根柱子的顶部。这个移动必须保持有序性：不能将较大的圆盘放在较小的圆盘上。原版谜题的目标是将所有圆盘从一根柱子移动到另一根柱子。\n\n在这个变体版本中，你只能 **在相邻柱子之间** 移动圆盘：可以在柱子 $1$ 和 $2$ 之间移动，也可以在柱子 $2$ 和 $3$ 之间移动，但不能直接在柱子 $1$ 和 $3$ 之间移动。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8p2sy9bm.png)\n\n给定汉诺塔的两个状态，求从初始状态到达目标状态所需的最少移动次数。由于这个数字可能很大，请输出其对 $998\\,244\\,353$ 取模的结果。", "inputFormat": "每个测试包含多个测试用例。第一行包含测试用例数量 $t$（$1 \\le t \\le 10^3$）。接下来是各测试用例的描述。\n\n每个测试用例的第一行包含一个整数 $n$，表示涉及的圆盘数量（$1 \\le n \\le 10^5$）。\n\n第二行包含 $n$ 个整数 $x_1, x_2, \\ldots, x_n$，描述初始状态，其中 $x_i$ 表示第 $i$ 个圆盘所在的柱子（$x_i \\in \\{ 1, 2, 3 \\}$）。\n\n第三行以相同格式描述目标状态。\n\n保证所有测试用例的 $n$ 之和不超过 $10^5$。", "outputFormat": "对于每个测试用例，输出从初始状态到达目标状态所需的最少移动次数，对 $998\\,244\\,353$ 取模。\n\n可以证明，在这个变体版本中，任何两个状态之间都是可以相互转换的。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12113", "type": "P", "difficulty": 0, "samples": [["4\n4\n3 2 4 2\n5 3 6 2\n1\n10\n100000\n5\n1 2 3 4 5\n1 2 3 4 5\n3\n1 4 6\n4 1 8", "2\n99990\n0\n-1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "ICPC", "NWRRC"], "title": "[NWRRC2024] If I Could Turn Back Time", "background": "", "description": "Inna is an avid hiker. She's visiting a range of $n$ mountains with heights $h_1, h_2, \\ldots, h_n$.\n\nAt a nearby shop, Inna has found a book that mentions that at some point in the past, the heights of the mountains were $p_1, p_2, \\ldots, p_n$ in the same order. However, there is no evidence of how old this book is.\n\nThe book also describes a model of erosion that makes the mountains shorter year after year. Every year, based on the weather, a certain height threshold $x$ can be determined. Then, every mountain with the current height of at least $x$ decreases in height by exactly $1$. Different years can have different values of $x$.\n\nInna is curious how old the book actually is, and whether the described model is sound. Help her figure out the smallest number of years in which erosion could take the mountains from heights $p_1, p_2, \\ldots, p_n$ to heights $h_1, h_2, \\ldots, h_n$ in the same order, or determine that it is impossible under the given model.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$, denoting the number of mountains ($1 \\le n \\le 10^5$).\n\nThe second line contains $n$ integers $h_1, h_2, \\ldots, h_n$, denoting the current heights of the mountains ($1 \\le h_i \\le 10^6$).\n\nThe third line contains $n$ integers $p_1, p_2, \\ldots, p_n$, denoting the heights of the mountains in the same order at some point in the past ($1 \\le p_i \\le 10^6$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.", "outputFormat": "For each test case, print the smallest number of years in which erosion could take the mountains from heights $p_1, p_2, \\ldots, p_n$ to heights $h_1, h_2, \\ldots, h_n$, or a single integer $-1$ if the described model is unsound.", "hint": "In the first test case, the heights of the mountains could go from $(5, 3, 6, 2)$ to $(3, 2, 4, 2)$ in just two years:\n- Suppose that in the first year, $x = 4$. After this year, the heights of the mountains are $(4, 3, 5, 2)$.\n- Suppose that in the second year, $x = 3$. After this year, the heights of the mountains are $(3, 2, 4, 2)$.", "locale": "en", "translations": {"en": {"title": "[NWRRC2024] If I Could Turn Back Time", "background": "", "description": "Inna is an avid hiker. She's visiting a range of $n$ mountains with heights $h_1, h_2, \\ldots, h_n$.\n\nAt a nearby shop, Inna has found a book that mentions that at some point in the past, the heights of the mountains were $p_1, p_2, \\ldots, p_n$ in the same order. However, there is no evidence of how old this book is.\n\nThe book also describes a model of erosion that makes the mountains shorter year after year. Every year, based on the weather, a certain height threshold $x$ can be determined. Then, every mountain with the current height of at least $x$ decreases in height by exactly $1$. Different years can have different values of $x$.\n\nInna is curious how old the book actually is, and whether the described model is sound. Help her figure out the smallest number of years in which erosion could take the mountains from heights $p_1, p_2, \\ldots, p_n$ to heights $h_1, h_2, \\ldots, h_n$ in the same order, or determine that it is impossible under the given model.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$, denoting the number of mountains ($1 \\le n \\le 10^5$).\n\nThe second line contains $n$ integers $h_1, h_2, \\ldots, h_n$, denoting the current heights of the mountains ($1 \\le h_i \\le 10^6$).\n\nThe third line contains $n$ integers $p_1, p_2, \\ldots, p_n$, denoting the heights of the mountains in the same order at some point in the past ($1 \\le p_i \\le 10^6$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.", "outputFormat": "For each test case, print the smallest number of years in which erosion could take the mountains from heights $p_1, p_2, \\ldots, p_n$ to heights $h_1, h_2, \\ldots, h_n$, or a single integer $-1$ if the described model is unsound.", "hint": "In the first test case, the heights of the mountains could go from $(5, 3, 6, 2)$ to $(3, 2, 4, 2)$ in just two years:\n- Suppose that in the first year, $x = 4$. After this year, the heights of the mountains are $(4, 3, 5, 2)$.\n- Suppose that in the second year, $x = 3$. After this year, the heights of the mountains are $(3, 2, 4, 2)$.", "locale": "en"}, "zh-CN": {"title": "[NWRRC2024] If I Could Turn Back Time", "background": "", "description": "Inna 是一位狂热的登山爱好者。她正在游览一系列由 $n$ 座山峰组成的山脉，这些山峰当前的高度分别为 $h_1, h_2, \\ldots, h_n$。\n\n在一家附近的商店里，Inna 发现了一本书，书中提到在过去某个时期，这些山峰的高度依次为 $p_1, p_2, \\ldots, p_n$。然而，这本书的年代无从考证。\n\n书中还描述了一个山峰侵蚀的模型：每年，根据天气情况会确定一个特定的高度阈值 $x$。然后，所有当前高度不低于 $x$ 的山峰都会恰好降低 $1$ 个单位高度。不同年份的 $x$ 值可以不同。\n\nInna 很好奇这本书究竟有多古老，以及这个侵蚀模型是否合理。请帮助她计算出山峰从高度 $p_1, p_2, \\ldots, p_n$ 侵蚀到当前高度 $h_1, h_2, \\ldots, h_n$ 所需的最少年份数，或者判断该模型下这种情况不可能发生。", "inputFormat": "每个测试包含多个测试用例。第一行包含测试用例数量 $t$（$1 \\le t \\le 10^4$）。接下来是各测试用例的描述。\n\n每个测试用例的第一行包含一个整数 $n$，表示山峰的数量（$1 \\le n \\le 10^5$）。\n\n第二行包含 $n$ 个整数 $h_1, h_2, \\ldots, h_n$，表示山峰当前的高度（$1 \\le h_i \\le 10^6$）。\n\n第三行包含 $n$ 个整数 $p_1, p_2, \\ldots, p_n$，表示山峰过去的高度（$1 \\le p_i \\le 10^6$）。\n\n保证所有测试用例的 $n$ 之和不超过 $10^5$。", "outputFormat": "对于每个测试用例，输出山峰从高度 $p_1, p_2, \\ldots, p_n$ 侵蚀到 $h_1, h_2, \\ldots, h_n$ 所需的最少年份数。如果该模型下这种情况不可能发生，则输出 $-1$。", "hint": "在第一个测试用例中，山峰高度从 $(5, 3, 6, 2)$ 变为 $(3, 2, 4, 2)$ 最少需要两年：\n- 假设第一年的 $x = 4$，侵蚀后的高度为 $(4, 3, 5, 2)$；\n- 假设第二年的 $x = 3$，侵蚀后的高度为 $(3, 2, 4, 2)$。", "locale": "zh-CN"}}}
{"pid": "P12114", "type": "P", "difficulty": 4, "samples": [["2\n3 3\n1 2\n2 3\n3 1\n5 6\n4 2\n2 1\n4 3\n1 4\n3 2\n3 5", "1 2 3\n3 1 5 4 2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "Special Judge", "构造", "ICPC", "NWRRC"], "title": "[NWRRC2024] Just Half is Enough", "background": "", "description": "Jacob is studying graph theory. Today he learned that a $\\textit{topological ordering}$ of a directed graph is a linear ordering of its vertices such that for every directed edge $(u, v)$ from vertex $u$ to vertex $v$, $u$ comes before~$v$ in the ordering.\n\nIt is well-known that topological orderings exist only for graphs without cycles. But how do we generalize this concept for arbitrary graphs?\n\nJacob came up with the concept of a $\\textit{half-topological ordering}$: a linear ordering of the graph's vertices such that $\\textbf{for at least half}$ of all directed edges $(u, v)$ in the graph, $u$ comes before $v$ in the ordering.\n\nIn other words, if the graph has $m$ edges, and for a particular ordering, $k$ of them satisfy the condition above, then the ordering is called $\\textit{half-topological}$ if $k \\ge \\lceil \\frac{m}{2} \\rceil$.\n\nHelp Jacob find any half-topological ordering of the given graph, or report that none exist.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$, denoting the number of vertices and the number of edges in the graph ($2 \\le n \\le 10^5$; $1 \\le m \\le 2 \\cdot 10^5$).\n\nThe $i$-th of the following $m$ lines contains two integers $u_i$ and $v_i$, describing an edge from vertex $u_i$ to vertex $v_i$ ($1 \\le u_i, v_i \\le n$; $u_i \\ne v_i$). The graph does not contain multiple edges: each directed edge $(u, v)$ appears at most once. However, having both edges $(u, v)$ and $(v, u)$ is allowed.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$, and the sum of $m$ over all test cases does not exceed $2 \\cdot 10^5$.", "outputFormat": "For each test case, print a single integer $-1$ if the required half-topological ordering does not exist.\n\nOtherwise, print $n$ distinct integers $p_1, p_2, \\ldots, p_n$, describing the ordering of the given graph ($1 \\le p_i \\le n$). For at least $\\lceil \\frac{m}{2} \\rceil$ of the edges $(u_i, v_i)$, integer $u_i$ must come before integer $v_i$ in this list. If there are multiple answers, print any of them.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NWRRC2024] Just Half is Enough", "background": "", "description": "Jacob is studying graph theory. Today he learned that a $\\textit{topological ordering}$ of a directed graph is a linear ordering of its vertices such that for every directed edge $(u, v)$ from vertex $u$ to vertex $v$, $u$ comes before~$v$ in the ordering.\n\nIt is well-known that topological orderings exist only for graphs without cycles. But how do we generalize this concept for arbitrary graphs?\n\nJacob came up with the concept of a $\\textit{half-topological ordering}$: a linear ordering of the graph's vertices such that $\\textbf{for at least half}$ of all directed edges $(u, v)$ in the graph, $u$ comes before $v$ in the ordering.\n\nIn other words, if the graph has $m$ edges, and for a particular ordering, $k$ of them satisfy the condition above, then the ordering is called $\\textit{half-topological}$ if $k \\ge \\lceil \\frac{m}{2} \\rceil$.\n\nHelp Jacob find any half-topological ordering of the given graph, or report that none exist.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$, denoting the number of vertices and the number of edges in the graph ($2 \\le n \\le 10^5$; $1 \\le m \\le 2 \\cdot 10^5$).\n\nThe $i$-th of the following $m$ lines contains two integers $u_i$ and $v_i$, describing an edge from vertex $u_i$ to vertex $v_i$ ($1 \\le u_i, v_i \\le n$; $u_i \\ne v_i$). The graph does not contain multiple edges: each directed edge $(u, v)$ appears at most once. However, having both edges $(u, v)$ and $(v, u)$ is allowed.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$, and the sum of $m$ over all test cases does not exceed $2 \\cdot 10^5$.", "outputFormat": "For each test case, print a single integer $-1$ if the required half-topological ordering does not exist.\n\nOtherwise, print $n$ distinct integers $p_1, p_2, \\ldots, p_n$, describing the ordering of the given graph ($1 \\le p_i \\le n$). For at least $\\lceil \\frac{m}{2} \\rceil$ of the edges $(u_i, v_i)$, integer $u_i$ must come before integer $v_i$ in this list. If there are multiple answers, print any of them.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NWRRC2024] Just Half is Enough", "background": "", "description": "Jacob 正在学习图论。今天他了解到，有向图的 *拓扑排序* 是指对图中顶点的一个线性排序，使得对于图中的每一条有向边 $(u, v)$，$u$ 在排序中总是位于 $v$ 之前。\n\n众所周知，拓扑排序仅适用于无环图。那么我们如何将这个概念推广到任意图呢？\n\nJacob 提出了  _半拓扑排序_  的概念：图的顶点的一个线性排序，使得 **至少一半** 的有向边 $(u, v)$ 满足 $u$ 在排序中位于 $v$ 之前。\n\n换句话说，如果图有 $m$ 条边，对于某个排序，有 $k$ 条边满足上述条件，则当 $k \\ge \\lceil \\frac{m}{2} \\rceil$ 时，该排序被称为 *半拓扑排序*。\n\n请帮助 Jacob 找出给定图的任意一个半拓扑排序，或者报告不存在这样的排序。", "inputFormat": "每个测试包含多个测试用例。第一行包含测试用例数量 $t$（$1 \\le t \\le 10^4$）。接下来是各测试用例的描述。\n\n每个测试用例的第一行包含两个整数 $n$ 和 $m$，分别表示图中的顶点数和边数（$2 \\le n \\le 10^5$；$1 \\le m \\le 2 \\cdot 10^5$）。\n\n接下来的 $m$ 行中，第 $i$ 行包含两个整数 $u_i$ 和 $v_i$，描述一条从顶点 $u_i$ 到顶点 $v_i$ 的有向边（$1 \\le u_i, v_i \\le n$；$u_i \\ne v_i$）。图中不包含重边：每条有向边 $(u, v)$ 最多出现一次。但是，同时存在边 $(u, v)$ 和 $(v, u)$ 是允许的。\n\n保证所有测试用例的 $n$ 之和不超过 $10^5$，$m$ 之和不超过 $2 \\cdot 10^5$。", "outputFormat": "对于每个测试用例，如果不存在满足条件的半拓扑排序，则输出单个整数 $-1$。\n\n否则，输出 $n$ 个不同的整数 $p_1, p_2, \\ldots, p_n$，表示图的排序（$1 \\le p_i \\le n$）。对于至少 $\\lceil \\frac{m}{2} \\rceil$ 条边 $(u_i, v_i)$，整数 $u_i$ 必须位于整数 $v_i$ 之前。如果有多个解，输出任意一个即可。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12115", "type": "P", "difficulty": 0, "samples": [["1 26\nwin", "f"], ["3 3\nabc\nbca\ncab", "aa"], ["4 2\naab\nbb\na\nbab", "NO"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC2024] Keyboard Chaos", "background": "", "description": "Haven't you ever thought that an ordinary flat keyboard is boring, and you can come up with something more interesting?\n\nA little boy named Kevin came up with a keyboard with $n$ unusual keys. Each key $i$ initially contains a sequence of letters: $L_{i, 1}, L_{i, 2}, \\ldots, L_{i, |L_{i}|}$. Some letters in this sequence can be equal. Each letter is one of the first $e$ lowercase English letters. \n\nEvery time key $i$ is pressed, the first letter of its sequence is typed and immediately moved to the end of the sequence. Thus, the first time key $i$ is pressed, letter $L_{i, 1}$ is typed, and the sequence becomes $L_{i, 2}, \\ldots, L_{i, |L_{i}|}, L_{i, 1}$. The second time key $i$ is pressed, letter $L_{i, 2}$ is typed, and the sequence becomes $L_{i, 3}, \\ldots, L_{i, |L_{i}|}, L_{i, 1}, L_{i, 2}$, and so on.\n\nFor example, suppose that key $1$ contains the sequence $\\tt{a}$, $\\tt{b}$, $\\tt{a}$, and key $2$ contains the sequence $\\tt{c}$,$\\tt{d}$. Then, if you press keys $2, 1, 2, 2, 1, 1, 1, 2$ in this order, the string $\\tt{cadcbaad}$ will be typed.\n\nHelp Kevin understand how useful his keyboard is, and find the shortest possible string consisting of the first $e$ lowercase English letters that cannot be typed with such a keyboard from the given initial state.", "inputFormat": "The first line contains two integers $n$ and $e$, denoting the number of keys and the size of the alphabet ($1 \\le n \\le 100$; $2 \\le e \\le 26$).\n\nThe $i$-th of the following $n$ lines consists of characters $L_{i,1}, L_{i,2}, \\ldots, L_{i, |L_i|}$, denoting the sequence of letters key $i$ initially contains ($1 \\le |L_{i}| \\le 10$). Every character is one of the first $e$ lowercase English letters.", "outputFormat": "Print the shortest possible string, consisting of the first $e$ lowercase English letters, that can not be typed using Kevin's keyboard from the initial state. If there are multiple shortest strings, print any of them.\n\nIf any string can be typed, print a single string $\\tt{NO}$ instead.", "hint": "In the first test, the only strings that can be typed with Kevin's keyboard are prefixes of $\\tt{winwinwinwin...}$. Since you can not start the string with any letter other than $\\tt{w}$, any lowercase English letter except $\\tt{w}$ is a correct answer.\n\nIn the second test, $\\tt{bb}$ and $\\tt{cc}$ are other possible answers.", "locale": "en", "translations": {"en": {"title": "[NWRRC2024] Keyboard Chaos", "background": "", "description": "Haven't you ever thought that an ordinary flat keyboard is boring, and you can come up with something more interesting?\n\nA little boy named Kevin came up with a keyboard with $n$ unusual keys. Each key $i$ initially contains a sequence of letters: $L_{i, 1}, L_{i, 2}, \\ldots, L_{i, |L_{i}|}$. Some letters in this sequence can be equal. Each letter is one of the first $e$ lowercase English letters. \n\nEvery time key $i$ is pressed, the first letter of its sequence is typed and immediately moved to the end of the sequence. Thus, the first time key $i$ is pressed, letter $L_{i, 1}$ is typed, and the sequence becomes $L_{i, 2}, \\ldots, L_{i, |L_{i}|}, L_{i, 1}$. The second time key $i$ is pressed, letter $L_{i, 2}$ is typed, and the sequence becomes $L_{i, 3}, \\ldots, L_{i, |L_{i}|}, L_{i, 1}, L_{i, 2}$, and so on.\n\nFor example, suppose that key $1$ contains the sequence $\\tt{a}$, $\\tt{b}$, $\\tt{a}$, and key $2$ contains the sequence $\\tt{c}$,$\\tt{d}$. Then, if you press keys $2, 1, 2, 2, 1, 1, 1, 2$ in this order, the string $\\tt{cadcbaad}$ will be typed.\n\nHelp Kevin understand how useful his keyboard is, and find the shortest possible string consisting of the first $e$ lowercase English letters that cannot be typed with such a keyboard from the given initial state.", "inputFormat": "The first line contains two integers $n$ and $e$, denoting the number of keys and the size of the alphabet ($1 \\le n \\le 100$; $2 \\le e \\le 26$).\n\nThe $i$-th of the following $n$ lines consists of characters $L_{i,1}, L_{i,2}, \\ldots, L_{i, |L_i|}$, denoting the sequence of letters key $i$ initially contains ($1 \\le |L_{i}| \\le 10$). Every character is one of the first $e$ lowercase English letters.", "outputFormat": "Print the shortest possible string, consisting of the first $e$ lowercase English letters, that can not be typed using Kevin's keyboard from the initial state. If there are multiple shortest strings, print any of them.\n\nIf any string can be typed, print a single string $\\tt{NO}$ instead.", "hint": "In the first test, the only strings that can be typed with Kevin's keyboard are prefixes of $\\tt{winwinwinwin...}$. Since you can not start the string with any letter other than $\\tt{w}$, any lowercase English letter except $\\tt{w}$ is a correct answer.\n\nIn the second test, $\\tt{bb}$ and $\\tt{cc}$ are other possible answers.", "locale": "en"}, "zh-CN": {"title": "[NWRRC2024] Keyboard Chaos", "background": "", "description": "你是否曾觉得普通的平面键盘太过无聊，想要设计些更有趣的东西？\n\n一个叫 Kevin 的小男孩设计了一个有 $n$ 个特殊按键的键盘。每个按键 $i$ 初始包含一个字母序列：$L_{i,1}, L_{i,2}, \\ldots, L_{i,|L_i|}$。序列中可能有重复字母。每个字母都是前 $e$ 个小写英文字母之一。\n\n每次按下按键 $i$ 时，会输入其序列的第一个字母，并立即将该字母移到序列末尾。因此，第一次按下按键 $i$ 时输入字母 $L_{i,1}$，序列变为 $L_{i,2}, \\ldots, L_{i,|L_i|}, L_{i,1}$；第二次按下时输入 $L_{i,2}$，序列变为 $L_{i,3}, \\ldots, L_{i,|L_i|}, L_{i,1}, L_{i,2}$，以此类推。\n\n例如，假设按键 $1$ 的序列是 $\\tt{a}$, $\\tt{b}$, $\\tt{a}$，按键 $2$ 的序列是 $\\tt{c}$, $\\tt{d}$。若按顺序按下 $2,1,2,2,1,1,1,2$，将输入字符串 $\\tt{cadcbaad}$。\n\n请帮助 Kevin 评估他的键盘功能，找出从初始状态开始，该键盘无法输入的最短字符串（仅由前 $e$ 个小写字母组成）。", "inputFormat": "第一行包含两个整数 $n$ 和 $e$，分别表示按键数量和字母表大小（$1 \\le n \\le 100$；$2 \\le e \\le 26$）。\n\n接下来的 $n$ 行中，第 $i$ 行包含字符 $L_{i,1}, L_{i,2}, \\ldots, L_{i,|L_i|}$，表示按键 $i$ 的初始字母序列（$1 \\le |L_i| \\le 10$）。每个字符都是前 $e$ 个小写英文字母之一。\n", "outputFormat": "输出该键盘从初始状态开始无法输入的最短字符串（由前 $e$ 个小写字母组成）。若有多个最短字符串，输出任意一个即可。\n\n若可以输入所有可能的字符串，则输出单个字符串 $\\tt{NO}$。", "hint": "在第一个测试用例中，键盘只能输入 $\\tt{winwinwinwin...}$ 的前缀。由于无法以 $\\tt{w}$ 以外的字母开头，任何非 $\\tt{w}$ 的小写字母都是正确答案。\n\n在第二个测试用例中，$\\tt{bb}$ 和 $\\tt{cc}$ 也是可能的正确答案。", "locale": "zh-CN"}}}
{"pid": "P12116", "type": "P", "difficulty": 6, "samples": [["2 2 1\n1", "6"], ["3 4 2\n01", "28"], ["7 5 3\n110", "399"], ["23 42 3\n000", "174497840"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2024", "快速莫比乌斯变换 FMT", "ICPC", "状压 DP", "NWRRC"], "title": "[NWRRC2024] Longest Common Substring", "background": "", "description": "Lisa wrote a program to solve the Longest Common Substring problem. She then used the program to find, for some two strings $s$ and $t$ consisting of characters $\\tt{0}$ and $\\tt{1}$, the longest string $w$ that is a substring of both $s$ and $t$. If there were multiple such longest strings, she found an arbitrary one.\n\nNotably, the length of $w$ Lisa found was very small --- at most 3.\n\nLisa remembers $n$ (the length of $s$), $m$ (the length of $t$), and $w$, but she doesn't remember strings $s$ and $t$ themselves. Now she wonders how many pairs of strings $s$ and $t$ exist such that they have lengths $n$ and $m$, respectively, consist of characters $\\tt{0}$ and $\\tt{1}$, and have $w$ as one of their longest common substrings.\n\nHelp Lisa and find this number of pairs modulo $998\\,244\\,353$. Note that if $n = m$ and $s \\ne t$, pairs $(s, t)$ and $(t, s)$ are considered distinct.\n", "inputFormat": "The first line contains three integers $n$, $m$, and $k$, denoting the lengths of the strings $s$, $t$, and $w$ ($1 \\le n, m \\le 100$; $1 \\le k \\le \\min(3, n, m)$).\n\nThe second line contains the string $w$ of length $k$ consisting of characters $\\tt{0}$ and $\\tt{1}$.", "outputFormat": "Print the number of pairs of strings $(s, t)$ that have $w$ as one of their longest common substrings, modulo $998\\,244\\,353$.", "hint": "Note that a string $a$ is a substring of a string $b$ if $a$ can be obtained from $b$ by deleting zero or more characters from the beginning and zero or more characters from the end.\n\nIn the first test, all pairs of strings satisfying the conditions are ($\\tt{01}$, $\\tt{10}$), ($\\tt{01}$, $\\tt{11}$), ($\\tt{10}$, $\\tt{01}$), ($\\tt{10}$, $\\tt{11}$), ($\\tt{11}$, $\\tt{01}$), and ($\\tt{11}$, $\\tt{10}$).", "locale": "en", "translations": {"en": {"title": "[NWRRC2024] Longest Common Substring", "background": "", "description": "Lisa wrote a program to solve the Longest Common Substring problem. She then used the program to find, for some two strings $s$ and $t$ consisting of characters $\\tt{0}$ and $\\tt{1}$, the longest string $w$ that is a substring of both $s$ and $t$. If there were multiple such longest strings, she found an arbitrary one.\n\nNotably, the length of $w$ Lisa found was very small --- at most 3.\n\nLisa remembers $n$ (the length of $s$), $m$ (the length of $t$), and $w$, but she doesn't remember strings $s$ and $t$ themselves. Now she wonders how many pairs of strings $s$ and $t$ exist such that they have lengths $n$ and $m$, respectively, consist of characters $\\tt{0}$ and $\\tt{1}$, and have $w$ as one of their longest common substrings.\n\nHelp Lisa and find this number of pairs modulo $998\\,244\\,353$. Note that if $n = m$ and $s \\ne t$, pairs $(s, t)$ and $(t, s)$ are considered distinct.\n", "inputFormat": "The first line contains three integers $n$, $m$, and $k$, denoting the lengths of the strings $s$, $t$, and $w$ ($1 \\le n, m \\le 100$; $1 \\le k \\le \\min(3, n, m)$).\n\nThe second line contains the string $w$ of length $k$ consisting of characters $\\tt{0}$ and $\\tt{1}$.", "outputFormat": "Print the number of pairs of strings $(s, t)$ that have $w$ as one of their longest common substrings, modulo $998\\,244\\,353$.", "hint": "Note that a string $a$ is a substring of a string $b$ if $a$ can be obtained from $b$ by deleting zero or more characters from the beginning and zero or more characters from the end.\n\nIn the first test, all pairs of strings satisfying the conditions are ($\\tt{01}$, $\\tt{10}$), ($\\tt{01}$, $\\tt{11}$), ($\\tt{10}$, $\\tt{01}$), ($\\tt{10}$, $\\tt{11}$), ($\\tt{11}$, $\\tt{01}$), and ($\\tt{11}$, $\\tt{10}$).", "locale": "en"}, "zh-CN": {"title": "[NWRRC2024] Longest Common Substring", "background": "", "description": "Lisa 编写了一个解决最长公共子串问题的程序。她使用该程序对两个由字符 $\\tt{0}$ 和 $\\tt{1}$ 组成的字符串 $s$ 和 $t$ 进行计算，找到了它们的最长公共子串 $w$。当存在多个相同长度的最长公共子串时，她任意选择其中一个。\n\n值得注意的是，Lisa 找到的 $w$ 长度非常小——最多为 3。\n\nLisa 记得 $n$（$s$ 的长度）、$m$（$t$ 的长度）和 $w$，但她不记得字符串 $s$ 和 $t$ 本身。现在她想知道有多少对字符串 $(s, t)$ 满足：它们的长度分别为 $n$ 和 $m$，由字符 $\\tt{0}$ 和 $\\tt{1}$ 组成，并且 $w$ 是它们的最长公共子串之一。\n\n请帮助 Lisa 计算这个对数，结果对 $998\\,244\\,353$ 取模。注意当 $n = m$ 且 $s \\ne t$ 时，$(s, t)$ 和 $(t, s)$ 被视为不同的对。", "inputFormat": "第一行包含三个整数 $n$、$m$ 和 $k$，分别表示字符串 $s$、$t$ 和 $w$ 的长度（$1 \\le n, m \\le 100$；$1 \\le k \\le \\min(3, n, m)$）。\n\n第二行包含一个长度为 $k$ 的字符串 $w$，由字符 $\\tt{0}$ 和 $\\tt{1}$ 组成。", "outputFormat": "输出满足条件的字符串对 $(s, t)$ 的数量，结果对 $998\\,244\\,353$ 取模。", "hint": "注意，字符串 $a$ 是字符串 $b$ 的子串，当且仅当 $a$ 可以通过从 $b$ 的开头和结尾删除零个或多个字符得到。\n\n在第一个测试用例中，所有满足条件的字符串对为 ($\\tt{01}$, $\\tt{10}$)、($\\tt{01}$, $\\tt{11}$)、($\\tt{10}$, $\\tt{01}$)、($\\tt{10}$, $\\tt{11}$)、($\\tt{11}$, $\\tt{01}$) 和 ($\\tt{11}$, $\\tt{10}$)。", "locale": "zh-CN"}}}
{"pid": "P12117", "type": "P", "difficulty": 0, "samples": [["2\n4 2 6\n1 1\n1 2\n1 6\n2 3\n2 4 5\n3 4\n2 4", "1\n2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "ICPC", "NWRRC"], "title": "[NWRRC2024] Misère", "background": "", "description": "$\\textit{Préférence}$ is a card game which is very popular in Eastern Europe. It is usually played with a 32-card deck, which consists of pip cards from 7 to 10, Jack, Queen, King, and Ace in each of the four suits: Spades, Clubs, Diamonds, and Hearts. In each round of the game, three players receive ten cards each, and two cards are left on the table as a talon. Then, a phase of auction happens, where players make their bids, which are obligations to take at least a certain number of tricks. A special case of a bid is a so-called $\\textit{misère}$, which is an obligation to take no tricks regardless of other players' moves.\n\nIn this task, we will consider a special modification of préférence which is played with a modified deck containing $A\\cdot B$ cards, where $A$ is a number of suits, and $B$ is the number of ranks in each suit. For example, the standard 32-card deck for the préférence game has $A = 4$ suits and $B = 8$ ranks. For convenience, we'll number the suits from $1$ to $A$, and the ranks from $1$ to $B$.\n\nYou need to solve a puzzle about this modification of préférence. In this modification, we'll say that a misère is $\\textit{guaranteed}$ if for every suit, after we order the cards belonging to this suit in your hand by their rank as $b_1 < b_2 < \\cdots < b_k$ (where $k$ is the number of cards of the suit in your hand), the following condition is satisfied: $b_i \\le 2i - 1$ for all $i$ from $1$ to $k$. If you don't have any cards of the suit ($k = 0$), the condition is trivially satisfied.\n\nYou have $n$ cards in your hand, and you will be allowed to choose any $x$ cards you don't have and add them to your hand. Then, you must select any $x$ of your $n + x$ cards and drop them, leaving some $n$ cards in your hand. Your task is to find the smallest possible $x$ such that you can transform your hand to a guaranteed misère.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $A$, and $B$, denoting the number of cards in your hand, the number of suits in the deck, and the number of ranks in the deck ($1 \\le n \\le 5000$; $1\\le A, B\\le 10^9$).\n\nThe $i$-th of the following $n$ lines contains two integers $a_i$ and $b_i$ and describes one card, where $a_i$ is the suit of the $i$-th card, and $b_i$ is its rank ($1 \\le a_i \\le A$; $1 \\le b_i \\le B$). All the cards in your hand are distinct.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5000$.", "outputFormat": "For each test case, print the smallest non-negative integer value of $x$ such that you can transform your hand to a guaranteed misère by first adding $x$ cards that you don't have to your hand, and then dropping any $x$ cards from your hand.\n\nIt can be shown that such a value of $x$ always exists.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NWRRC2024] Misère", "background": "", "description": "$\\textit{Préférence}$ is a card game which is very popular in Eastern Europe. It is usually played with a 32-card deck, which consists of pip cards from 7 to 10, Jack, Queen, King, and Ace in each of the four suits: Spades, Clubs, Diamonds, and Hearts. In each round of the game, three players receive ten cards each, and two cards are left on the table as a talon. Then, a phase of auction happens, where players make their bids, which are obligations to take at least a certain number of tricks. A special case of a bid is a so-called $\\textit{misère}$, which is an obligation to take no tricks regardless of other players' moves.\n\nIn this task, we will consider a special modification of préférence which is played with a modified deck containing $A\\cdot B$ cards, where $A$ is a number of suits, and $B$ is the number of ranks in each suit. For example, the standard 32-card deck for the préférence game has $A = 4$ suits and $B = 8$ ranks. For convenience, we'll number the suits from $1$ to $A$, and the ranks from $1$ to $B$.\n\nYou need to solve a puzzle about this modification of préférence. In this modification, we'll say that a misère is $\\textit{guaranteed}$ if for every suit, after we order the cards belonging to this suit in your hand by their rank as $b_1 < b_2 < \\cdots < b_k$ (where $k$ is the number of cards of the suit in your hand), the following condition is satisfied: $b_i \\le 2i - 1$ for all $i$ from $1$ to $k$. If you don't have any cards of the suit ($k = 0$), the condition is trivially satisfied.\n\nYou have $n$ cards in your hand, and you will be allowed to choose any $x$ cards you don't have and add them to your hand. Then, you must select any $x$ of your $n + x$ cards and drop them, leaving some $n$ cards in your hand. Your task is to find the smallest possible $x$ such that you can transform your hand to a guaranteed misère.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 1000$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $A$, and $B$, denoting the number of cards in your hand, the number of suits in the deck, and the number of ranks in the deck ($1 \\le n \\le 5000$; $1\\le A, B\\le 10^9$).\n\nThe $i$-th of the following $n$ lines contains two integers $a_i$ and $b_i$ and describes one card, where $a_i$ is the suit of the $i$-th card, and $b_i$ is its rank ($1 \\le a_i \\le A$; $1 \\le b_i \\le B$). All the cards in your hand are distinct.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5000$.", "outputFormat": "For each test case, print the smallest non-negative integer value of $x$ such that you can transform your hand to a guaranteed misère by first adding $x$ cards that you don't have to your hand, and then dropping any $x$ cards from your hand.\n\nIt can be shown that such a value of $x$ always exists.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NWRRC2024] Misère", "background": "", "description": "Préférence 是一种在东欧非常流行的纸牌游戏。通常使用一副 32 张的牌组，包含四种花色（黑桃、梅花、方块、红心）中 7 到 10 的数字牌以及 J、Q、K、A。每轮游戏中，三位玩家各发 10 张牌，剩下 2 张作为底牌。随后进入叫牌阶段，玩家需要承诺赢得至少一定数量的墩。其中一种特殊的叫牌是 misère，即承诺无论其他玩家如何出牌都不赢得任何墩。\n\n本题考虑一种变体游戏，使用修改后的牌组包含 $A \\cdot B$ 张牌，其中 $A$ 表示花色数量，$B$ 表示每个花色的牌面等级数。例如标准 32 张牌组中 $A=4$，$B=8$。为方便起见，花色编号为 $1$ 到 $A$，牌面等级编号为 $1$ 到 $B$。\n\n我们需要解决关于这个变体游戏的谜题。在这个变体中，当满足以下条件时，我们称 misère 是 *保证* 的：对于每个花色，将你手中该花色的牌按等级排序为 $b_1 < b_2 < \\cdots < b_k$（$k$ 为该花色牌的数量），必须满足对所有 $1 \\le i \\le k$ 有 $b_i \\le 2i - 1$。若手中没有该花色的牌（$k=0$），则自动满足条件。\n\n你手中有 $n$ 张牌，允许选择任意 $x$ 张不拥有的牌加入手牌，然后从 $n+x$ 张牌中丢弃 $x$ 张，最终保留 $n$ 张牌。你的任务是找到最小的 $x$，使得可以通过上述操作将手牌转变为保证的 misère。", "inputFormat": "每个测试包含多个测试用例。第一行包含测试用例数 $t$（$1 \\le t \\le 1000$）。接下来是各测试用例描述。\n\n每个测试用例第一行包含三个整数 $n$、$A$ 和 $B$，分别表示手牌数量、花色数量和牌面等级数量（$1 \\le n \\le 5000$；$1 \\le A, B \\le 10^9$）。\n\n随后 $n$ 行每行包含两个整数 $a_i$ 和 $b_i$，描述一张牌的花色和等级（$1 \\le a_i \\le A$；$1 \\le b_i \\le B$）。所有手牌都是唯一的。\n\n保证所有测试用例的 $n$ 之和不超过 $5000$。", "outputFormat": "对于每个测试用例，输出最小的非负整数 $x$，使得可以通过先添加 $x$ 张新牌再丢弃 $x$ 张牌的操作，将手牌转变为保证的 misère。\n\n可以证明这样的 $x$ 总是存在。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12118", "type": "P", "difficulty": 6, "samples": [["3 5\na 1 2 1\na 2 3 2\nd\nr\nd\n", "3\n1\n"], ["6 10\na 2 3 10\na 1 2 5\na 3 4 8\nd\nr\nd\na 4 5 1\na 3 6 7\nr\nd\n", "4\n0\n2\n"]], "limits": {"time": [4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2025", "交互题", "Special Judge", "NordicOI（北欧）"], "title": "[NordicOI 2025] 点对处理 / Dodgeball Diplomacy", "background": "\nPython / Java（很）可能无法通过本题。不建议不使用 C/C++。", "description": "**这是一道交互题**。我们利用交互来让你强制在线回答询问。\n\n有 $N$ 个点，编号从 $1$ 到 $N$，你需要解决如下 $Q$ 个询问：\n\n- $\\texttt{a u v p}$，在 $u$ 和 $v$ 之间添加长度为 $p$ 的无向边。\n\n- $\\texttt{r}$，删除当前图中最长的无向边。\n\n- $\\texttt{d}$，把当前图中连通块两两配对（如果连通块数量为奇数，那就选择一个连通块和大小为 $0$ 的连通块配对），记为 $(A_i,B_i)$。\n\n\t设有 $k$ 个连通块，令连通块 $A$ 的点数为 $|A|$，最小化 $\\displaystyle \\sum_{1\\le i\\le k}||A_i|-|B_i||$。只需要输出最小化后的这个值。", "inputFormat": "第一行给定两个整数 $N,Q$。\n\n接下来 $Q$ 行查询，每行格式即题目描述三者之一。", "outputFormat": "对于每条类型为 $\\texttt{d}$ 的查询，程序必须在处理后续查询之前立即输出答案。此外，你需要在每次输出答案后立即刷新输出缓冲区。\n\n", "hint": "【样例解释】\n\n注意以下解释只按顺序解释类型为 $\\texttt{d}$ 的查询。\n\n- 对于样例 $1$，第一次查询，连通块为 $(1,2,3)$，答案为 $3$，第二次查询，连通块为 $(1,2)$ 和 $(3)$，答案为 $1$。\n\n- 对于样例 $2$，在第一次查询，有一个大小为 $4$ 的连通块和两个大小为 $1$ 的连通块，总不公平分数为 $4$；在第二次查询中，有两个大小为 $2$ 的连通块和两个大小为 $1$ 的连通块，答案为 $0$；在第三次查询，有三个大小为 $2$ 的联盟，答案为 $2$。\n\n\n【数据规模与约定】\n\n对于所有数据，满足：\n\n$1 \\leq N \\leq 100000,1 \\leq Q \\leq 500000,1 \\leq p \\leq 10^{9},1 \\leq u \\leq N,1 \\leq v \\leq N$。 \n\n对于类型 $\\texttt{a}$ 的查询，$u \\neq v$，添加无向边时，$u$ 和 $v$ 之间不存在无向边，且所有 $p$ 均唯一。\n\n详细子任务附加限制及分值如下表所示：\n\n\n|子任务编号  | 分值 | 附加限制 |\n| :-----------: |:-----------: | :-----------: |\n|$1$  | $9$ | $N \\le 10,Q \\le 20$ |\n| $2$ | $10$ | $N \\le 2000,Q\\le 4000$ |\n|$3$  | $6$ | 类型 $\\texttt{d}$ 的查询不超过 $10$ 次 |\n| $4$ | $17$ | 类型 $\\texttt{a}$ 的查询，满足 $u+1=v$  |\n| $5$ | $14$ | 满足随着边的建立，$p$ 递增 |\n| $6$ | $26$ | 满足随着边的建立，$p$ 递减  |\n| $7$ | $18$ | 无附加限制 |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NordicOI 2025] 点对处理 / Dodgeball Diplomacy", "background": "\nPython / Java（很）可能无法通过本题。不建议不使用 C/C++。", "description": "**这是一道交互题**。我们利用交互来让你强制在线回答询问。\n\n有 $N$ 个点，编号从 $1$ 到 $N$，你需要解决如下 $Q$ 个询问：\n\n- $\\texttt{a u v p}$，在 $u$ 和 $v$ 之间添加长度为 $p$ 的无向边。\n\n- $\\texttt{r}$，删除当前图中最长的无向边。\n\n- $\\texttt{d}$，把当前图中连通块两两配对（如果连通块数量为奇数，那就选择一个连通块和大小为 $0$ 的连通块配对），记为 $(A_i,B_i)$。\n\n\t设有 $k$ 个连通块，令连通块 $A$ 的点数为 $|A|$，最小化 $\\displaystyle \\sum_{1\\le i\\le k}||A_i|-|B_i||$。只需要输出最小化后的这个值。", "inputFormat": "第一行给定两个整数 $N,Q$。\n\n接下来 $Q$ 行查询，每行格式即题目描述三者之一。", "outputFormat": "对于每条类型为 $\\texttt{d}$ 的查询，程序必须在处理后续查询之前立即输出答案。此外，你需要在每次输出答案后立即刷新输出缓冲区。\n\n", "hint": "【样例解释】\n\n注意以下解释只按顺序解释类型为 $\\texttt{d}$ 的查询。\n\n- 对于样例 $1$，第一次查询，连通块为 $(1,2,3)$，答案为 $3$，第二次查询，连通块为 $(1,2)$ 和 $(3)$，答案为 $1$。\n\n- 对于样例 $2$，在第一次查询，有一个大小为 $4$ 的连通块和两个大小为 $1$ 的连通块，总不公平分数为 $4$；在第二次查询中，有两个大小为 $2$ 的连通块和两个大小为 $1$ 的连通块，答案为 $0$；在第三次查询，有三个大小为 $2$ 的联盟，答案为 $2$。\n\n\n【数据规模与约定】\n\n对于所有数据，满足：\n\n$1 \\leq N \\leq 100000,1 \\leq Q \\leq 500000,1 \\leq p \\leq 10^{9},1 \\leq u \\leq N,1 \\leq v \\leq N$。 \n\n对于类型 $\\texttt{a}$ 的查询，$u \\neq v$，添加无向边时，$u$ 和 $v$ 之间不存在无向边，且所有 $p$ 均唯一。\n\n详细子任务附加限制及分值如下表所示：\n\n\n|子任务编号  | 分值 | 附加限制 |\n| :-----------: |:-----------: | :-----------: |\n|$1$  | $9$ | $N \\le 10,Q \\le 20$ |\n| $2$ | $10$ | $N \\le 2000,Q\\le 4000$ |\n|$3$  | $6$ | 类型 $\\texttt{d}$ 的查询不超过 $10$ 次 |\n| $4$ | $17$ | 类型 $\\texttt{a}$ 的查询，满足 $u+1=v$  |\n| $5$ | $14$ | 满足随着边的建立，$p$ 递增 |\n| $6$ | $26$ | 满足随着边的建立，$p$ 递减  |\n| $7$ | $18$ | 无附加限制 |\n", "locale": "zh-CN"}}}
{"pid": "P12119", "type": "P", "difficulty": 5, "samples": [["5 3 2\n3 1 10\n2 1 5\n1 0 5\n0 2 10\n1 3 5\n", "20"]], "limits": {"time": [5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500, 5500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "2025", "扫描线", "双指针 two-pointer", "NordicOI（北欧）"], "title": "[NordicOI 2025] 垃圾收集 / Garbage Collection", "background": "", "description": "北海上漂浮着 $N$ 块垃圾，编号从 $1$ 到 $N$。第 $i$ 块垃圾位于坐标 $\\left(x_{i}, y_{i}\\right)$，重量为 $w_{i}$。作为一项清理行动的一部分，你需要在某个矩形区域内收集所有垃圾。这个矩形区域的宽度为 $W$，高度为 $H$，但具体位置尚未确定。\n\n你的任务是确定在最佳位置放置清理区域时，能够收集到的垃圾总重量的最大值。\n\n译者注：「北海（North Sea）」指的是是北大西洋的一部分，不是广西壮族自治区北海市。", "inputFormat": "第一行包含三个整数 $N,W$ 和 $H$。\n\n接下来的 $N$ 行中，第 $i$ 行包含三个整数 $x_{i}, y_{i}$ 和 $w_{i}$，分别表示第 $i$ 块垃圾的坐标和重量。", "outputFormat": "一行一个非负整数表示答案。", "hint": "【样例解释】\n\n最佳的清理区域应覆盖坐标为 $(3,1)$、$(2,1)$ 和 $(1,0)$ 的垃圾，总重量为 $10+5+5=20$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9ln6vecp.png)\n\n【数据规模与约定】\n\n对于所有数据，满足：\n\n$1 \\leq N \\leq 10^{5},1 \\leq W, H \\leq 10^{9},0 \\leq x_{i}, y_{i} < 10^{9}(1 \\leq i \\leq N),1 \\leq w_{i} \\leq 10^{9}(1 \\leq i \\leq N)$。\n\n详细子任务附加限制及分值如下表所示：\n\n|  子任务编号| 分值 | 特殊限制 |\n| :-----------: | :-----------: |:-----------: |\n| $1$ | $10$ | $N \\le 400$ |\n| $2$ | $12$ | $W,H,x_i,y_i \\le 2000$ |\n| $3$ | $15$ | $N \\le 2000$ |\n| $4$ | $22$ | $H=10^9$ |\n| $5$ | $23$ | $W,H,x_i,y_i \\le 10^5$ |\n| $6$ | $18$ |无特殊限制  |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NordicOI 2025] 垃圾收集 / Garbage Collection", "background": "", "description": "北海上漂浮着 $N$ 块垃圾，编号从 $1$ 到 $N$。第 $i$ 块垃圾位于坐标 $\\left(x_{i}, y_{i}\\right)$，重量为 $w_{i}$。作为一项清理行动的一部分，你需要在某个矩形区域内收集所有垃圾。这个矩形区域的宽度为 $W$，高度为 $H$，但具体位置尚未确定。\n\n你的任务是确定在最佳位置放置清理区域时，能够收集到的垃圾总重量的最大值。\n\n译者注：「北海（North Sea）」指的是是北大西洋的一部分，不是广西壮族自治区北海市。", "inputFormat": "第一行包含三个整数 $N,W$ 和 $H$。\n\n接下来的 $N$ 行中，第 $i$ 行包含三个整数 $x_{i}, y_{i}$ 和 $w_{i}$，分别表示第 $i$ 块垃圾的坐标和重量。", "outputFormat": "一行一个非负整数表示答案。", "hint": "【样例解释】\n\n最佳的清理区域应覆盖坐标为 $(3,1)$、$(2,1)$ 和 $(1,0)$ 的垃圾，总重量为 $10+5+5=20$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9ln6vecp.png)\n\n【数据规模与约定】\n\n对于所有数据，满足：\n\n$1 \\leq N \\leq 10^{5},1 \\leq W, H \\leq 10^{9},0 \\leq x_{i}, y_{i} < 10^{9}(1 \\leq i \\leq N),1 \\leq w_{i} \\leq 10^{9}(1 \\leq i \\leq N)$。\n\n详细子任务附加限制及分值如下表所示：\n\n|  子任务编号| 分值 | 特殊限制 |\n| :-----------: | :-----------: |:-----------: |\n| $1$ | $10$ | $N \\le 400$ |\n| $2$ | $12$ | $W,H,x_i,y_i \\le 2000$ |\n| $3$ | $15$ | $N \\le 2000$ |\n| $4$ | $22$ | $H=10^9$ |\n| $5$ | $23$ | $W,H,x_i,y_i \\le 10^5$ |\n| $6$ | $18$ |无特殊限制  |", "locale": "zh-CN"}}}
{"pid": "P12120", "type": "P", "difficulty": 5, "samples": [["4 3\n< ? 2 4\n0\n< ? 4 1\n2\n< ? 3 3\n0\n< ! 1 3 1 1", ""], ["5 4\n< ? 1 2\n3\n< ? 1 3\n1\n< ? 2 3\n2\n< ? 1 4\n3\n< ! 3 1 1 1 2", ""]], "limits": {"time": [1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "交互题", "Special Judge", "NordicOI（北欧）"], "title": "[NordicOI 2025] 时之预言 / Xoracle", "background": "目前本题交互库有误。", "description": "**这是一道交互题。**\n\n很久以前，在北欧诸国的中心地带，有一位名叫罗尼的勇敢战士。罗尼以其无畏的勇气和敏锐的头脑闻名，常常能解开连最睿智的贤者都束手无策的谜题。有一天，罗尼被召集到一片古老的森林，那里屹立着一棵神秘的树。这棵树非同寻常——它完全隐形，其节点和分支对凡人之眼不可见。树的每个节点上都居住着一位古老的精灵，而每个节点的度数（degree）是理解树结构的关键。\n\n王国的预言者，被称为**神秘树预言者**（Xoracle），是一个强大的存在，但它只能回答一种类型的问题： 「告诉我节点 A 和节点 B 的度数的按位异或结果。」\n\n凭借这些神秘的信息，罗尼必须推导出树中所有 $N$ 个节点的度数，以征服古老的精灵并揭开树的秘密。然而，神秘树预言者最多只会回答 $Q$ 次询问，之后便会永远封存其智慧。\n\n罗尼的任务是利用神秘树预言者的回答，确定这棵隐形树中所有节点的度数。这棵树有 $N$ 个节点和 $N-1$ 条边，是连通的，也就是说，任意一对节点之间都存在路径。节点的度数是指与该节点相连的边的数量。通过策略性地选择节点对并解读它们度数的按位异或结果，罗尼希望能重构树中所有节点的度数。\n\n## 交互方式\n\n你的程序首先需要读取一行输入，包含两个空格分隔的整数 $N$ 和 $Q$，分别表示树中的节点数量和你最多可以向神秘树预言者提出的询问次数。树的节点编号从 $1$ 到 $N$。\n\n接下来，你的程序可以进行最多 $Q$ 次询问。要提出一个询问，你的程序需要输出一行，格式为 `? i j`，其中 $1 \\leq i, j \\leq N$。评测程序随后会返回一行，包含一个数字 $x$，其中 $x=\\operatorname{deg}(i) \\oplus \\operatorname{deg}(j)$。这里 $\\operatorname{deg}(x)$ 表示节点 $x$ 的度数，$\\oplus$ 表示按位异或运算。\n\n两个整数 $a$ 和 $b$ 的按位异或结果是通过查看它们的二进制表示计算出来的。第 $i$ 位的结果为 $1$，当且仅当 $a$ 或 $b$ 的第 $i$ 位有且仅有一个为 $1$。在 C++ 和 Python 中，这一运算符均为 ^。\n\n在完成询问后，你的程序必须输出所有节点的度数。输出的方式是：另起一行，输出 !，后跟一个空格和 $N$ 个空格分隔的整数，表示所有 $N$ 个节点的度数（顺序不限）。\n\n输出度数的操作不会计入你的程序允许的询问次数。\n\n为了接收询问的答案并在最后提交度数，你的程序需要刷新输出缓冲区。可以通过以下方式实现：\n\n- C++：`std::cout << std::endl;`\n- Python：`print(\"\", flush=True)`\n\n", "inputFormat": "", "outputFormat": "", "hint": "【样例解释】\n\n#### 样例 $1$\n\n请观察图 1 中所示的树。\n\n以下是你与评测程序的交互过程，其中 > 表示评测程序的输出，< 表示你的程序的输出。\n\n\n- 首先，输入提供 $N$ 和 $Q$ 的值。\n- 接着，你对节点 $2$ 和 $4$ 提出询问，得到结果 $0$。\n- 然后，你对节点 $4$ 和 $1$ 提出询问，得到结果 $2$。\n- 接着，你对节点 $3$ 和 $3$ 提出询问，得到结果 $0$。\n- 最后，你的程序输出树的度数为 $1,3,1,1$，这是正确的。（注意，度数的输出顺序可以是任意的。）\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dgdkk6q8.png)\n\n#### 样例 $2$：\n\n请观察图 2 中所示的树。\n\n以下是你与评测程序的交互过程，其中 > 表示评测程序的输出，< 表示你的程序的输出。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/pft1e2nv.png)\n\n**注意**：样例中给出的询问不一定能保证推导出正确的答案。\n\n【数据范围与约定】\n\n对于所有数据，满足：\n\n- $2 \\leq N \\leq 10^{5}$。\n\n详细子任务附加限制及分值如下表所示：\n\n| 子任务编号 | 分值 | 附加限制 |\n| :-----------: | :-----------: | :-----------: |\n| $1$ | $8$ |  任意节点的度数最大为 $3$，且树中至少存在度数为 $1$、$2$ 和 $3$ 的节点。$N\\le 1000,Q=N-1$ |\n| $2$ |  $5$|  任意节点的度数最大为 $4$，且树中至少出现 $4$ 种可能度数中的 $3$ 种。$N\\le 1000,Q=N-1$  |\n| $3$ |  $9$|$Q=N^2,N\\le 300$ |\n|$4$  |  $11$|$Q=35000,N\\le 1000$ |\n| $5$ |  $24$|$Q=N-1,N\\le 1000$ |\n|$6$  | $43$ |$Q=N-1$ |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NordicOI 2025] 时之预言 / Xoracle", "background": "目前本题交互库有误。", "description": "**这是一道交互题。**\n\n很久以前，在北欧诸国的中心地带，有一位名叫罗尼的勇敢战士。罗尼以其无畏的勇气和敏锐的头脑闻名，常常能解开连最睿智的贤者都束手无策的谜题。有一天，罗尼被召集到一片古老的森林，那里屹立着一棵神秘的树。这棵树非同寻常——它完全隐形，其节点和分支对凡人之眼不可见。树的每个节点上都居住着一位古老的精灵，而每个节点的度数（degree）是理解树结构的关键。\n\n王国的预言者，被称为**神秘树预言者**（Xoracle），是一个强大的存在，但它只能回答一种类型的问题： 「告诉我节点 A 和节点 B 的度数的按位异或结果。」\n\n凭借这些神秘的信息，罗尼必须推导出树中所有 $N$ 个节点的度数，以征服古老的精灵并揭开树的秘密。然而，神秘树预言者最多只会回答 $Q$ 次询问，之后便会永远封存其智慧。\n\n罗尼的任务是利用神秘树预言者的回答，确定这棵隐形树中所有节点的度数。这棵树有 $N$ 个节点和 $N-1$ 条边，是连通的，也就是说，任意一对节点之间都存在路径。节点的度数是指与该节点相连的边的数量。通过策略性地选择节点对并解读它们度数的按位异或结果，罗尼希望能重构树中所有节点的度数。\n\n## 交互方式\n\n你的程序首先需要读取一行输入，包含两个空格分隔的整数 $N$ 和 $Q$，分别表示树中的节点数量和你最多可以向神秘树预言者提出的询问次数。树的节点编号从 $1$ 到 $N$。\n\n接下来，你的程序可以进行最多 $Q$ 次询问。要提出一个询问，你的程序需要输出一行，格式为 `? i j`，其中 $1 \\leq i, j \\leq N$。评测程序随后会返回一行，包含一个数字 $x$，其中 $x=\\operatorname{deg}(i) \\oplus \\operatorname{deg}(j)$。这里 $\\operatorname{deg}(x)$ 表示节点 $x$ 的度数，$\\oplus$ 表示按位异或运算。\n\n两个整数 $a$ 和 $b$ 的按位异或结果是通过查看它们的二进制表示计算出来的。第 $i$ 位的结果为 $1$，当且仅当 $a$ 或 $b$ 的第 $i$ 位有且仅有一个为 $1$。在 C++ 和 Python 中，这一运算符均为 ^。\n\n在完成询问后，你的程序必须输出所有节点的度数。输出的方式是：另起一行，输出 !，后跟一个空格和 $N$ 个空格分隔的整数，表示所有 $N$ 个节点的度数（顺序不限）。\n\n输出度数的操作不会计入你的程序允许的询问次数。\n\n为了接收询问的答案并在最后提交度数，你的程序需要刷新输出缓冲区。可以通过以下方式实现：\n\n- C++：`std::cout << std::endl;`\n- Python：`print(\"\", flush=True)`\n\n", "inputFormat": "", "outputFormat": "", "hint": "【样例解释】\n\n#### 样例 $1$\n\n请观察图 1 中所示的树。\n\n以下是你与评测程序的交互过程，其中 > 表示评测程序的输出，< 表示你的程序的输出。\n\n\n- 首先，输入提供 $N$ 和 $Q$ 的值。\n- 接着，你对节点 $2$ 和 $4$ 提出询问，得到结果 $0$。\n- 然后，你对节点 $4$ 和 $1$ 提出询问，得到结果 $2$。\n- 接着，你对节点 $3$ 和 $3$ 提出询问，得到结果 $0$。\n- 最后，你的程序输出树的度数为 $1,3,1,1$，这是正确的。（注意，度数的输出顺序可以是任意的。）\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dgdkk6q8.png)\n\n#### 样例 $2$：\n\n请观察图 2 中所示的树。\n\n以下是你与评测程序的交互过程，其中 > 表示评测程序的输出，< 表示你的程序的输出。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/pft1e2nv.png)\n\n**注意**：样例中给出的询问不一定能保证推导出正确的答案。\n\n【数据范围与约定】\n\n对于所有数据，满足：\n\n- $2 \\leq N \\leq 10^{5}$。\n\n详细子任务附加限制及分值如下表所示：\n\n| 子任务编号 | 分值 | 附加限制 |\n| :-----------: | :-----------: | :-----------: |\n| $1$ | $8$ |  任意节点的度数最大为 $3$，且树中至少存在度数为 $1$、$2$ 和 $3$ 的节点。$N\\le 1000,Q=N-1$ |\n| $2$ |  $5$|  任意节点的度数最大为 $4$，且树中至少出现 $4$ 种可能度数中的 $3$ 种。$N\\le 1000,Q=N-1$  |\n| $3$ |  $9$|$Q=N^2,N\\le 300$ |\n|$4$  |  $11$|$Q=35000,N\\le 1000$ |\n| $5$ |  $24$|$Q=N-1,N\\le 1000$ |\n|$6$  | $43$ |$Q=N-1$ |\n", "locale": "zh-CN"}}}
{"pid": "P12121", "type": "P", "difficulty": 2, "samples": [], "limits": {"time": [1000], "memory": [524288]}, "tags": ["模拟", "数学", "2024", "提交答案", "进制", "蓝桥杯省赛"], "title": "[蓝桥杯 2024 省 B 第二场] 进制", "background": "", "description": "$8100178706957568$ 这个数在用 $x$ 进制表示时（$x \\in [11, 36]$），仅包含数字而不包含字母，请问 $x$ 是多少。比如 $2588$ 用 $16$ 进制表示为 $a1c$，包含字母 $a$ 和 $c$。", "inputFormat": "这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。", "outputFormat": "", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 省 B 第二场] 进制", "background": "", "description": "$8100178706957568$ 这个数在用 $x$ 进制表示时（$x \\in [11, 36]$），仅包含数字而不包含字母，请问 $x$ 是多少。比如 $2588$ 用 $16$ 进制表示为 $a1c$，包含字母 $a$ 和 $c$。", "inputFormat": "这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。", "outputFormat": "", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12122", "type": "P", "difficulty": 2, "samples": [], "limits": {"time": [1000], "memory": [524288]}, "tags": ["模拟", "数学", "2024", "期望", "蓝桥杯省赛"], "title": "[蓝桥杯 2024 省 B 第二场] 逆序对期望", "background": "", "description": "有一个数组，包含 $1$ 到 $n$ 这 $n$ 个整数，初始为一个从小到大的有序排列：$\\{1, 2, 3, 4, \\dots , n\\}$。一次随机交换操作指：均匀随机选取两个位置 $i, j \\in [1, n]$ 且 $i \\neq j$，然后交换数组中这两个位置上的数。那么对于 $n = 51$，对初始数组进行两次随机交换操作之后，数组中的逆序对的数量的期望是多少个。", "inputFormat": "这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个实数，在提交答案时只填写这个实数，四舍五入保留两位小数，填写多余的内容将无法得分。", "outputFormat": "", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 省 B 第二场] 逆序对期望", "background": "", "description": "有一个数组，包含 $1$ 到 $n$ 这 $n$ 个整数，初始为一个从小到大的有序排列：$\\{1, 2, 3, 4, \\dots , n\\}$。一次随机交换操作指：均匀随机选取两个位置 $i, j \\in [1, n]$ 且 $i \\neq j$，然后交换数组中这两个位置上的数。那么对于 $n = 51$，对初始数组进行两次随机交换操作之后，数组中的逆序对的数量的期望是多少个。", "inputFormat": "这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个实数，在提交答案时只填写这个实数，四舍五入保留两位小数，填写多余的内容将无法得分。", "outputFormat": "", "hint": "", "locale": "zh-CN"}}}
