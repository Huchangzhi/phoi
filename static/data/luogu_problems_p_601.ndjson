{"pid": "P13195", "type": "P", "difficulty": 3, "samples": [["4\n2\n2 2\n3\n3 2 2\n3\n1 1 2\n3\n2 3 1", "Case #1: AB BA\nCase #2: AA BC C BA\nCase #3: C C AB\nCase #4: BA BB CA"]], "limits": {"time": [7500, 7500], "memory": [1048576, 1048576]}, "tags": ["数学", "2016", "堆", "Special Judge", "Google Code Jam"], "title": "[GCJ 2016 #1C] Senate Evacuation", "background": "", "description": "A small fire started in the senate room, and it needs to be evacuated!\n\nThere are some senators in the senate room, each of whom belongs to one of $\\mathbf{N}$ political parties. Those parties are named after the first $\\mathbf{N}$ (uppercase) letters of the English alphabet.\n\nThe emergency door is wide enough for up to two senators, so in each step of the evacuation, you may choose to remove either one or two senators from the room.\n\nThe senate rules indicate the senators in the room may vote on any bill at any time, even in the middle of an evacuation! So, the senators must be evacuated in a way that ensures that no party ever has an absolute majority. That is, it can never be the case after any evacuation step that more than half of the senators in the senate room belong to the same party.\n\nCan you construct an evacuation plan? The senate is counting on you!\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines. The first line contains a single integer $\\mathbf{N}$, the number of parties. The second line contains $\\mathbf{N}$ integers, $\\mathbf{P}_{1}, \\mathbf{P}_{2}, \\ldots, \\mathbf{P}_{\\mathbf{N}}$, where $\\mathbf{P}_{i}$ represents the number of senators of the party named after the i-th letter of the alphabet.\n", "outputFormat": "For each test case, output one line containing Case #x: y, where $x$ is the test case number (starting from 1) and $y$ is the evacuation plan. The plan must be a space-separated list of instructions, in the order in which they are to be carried out, where each instruction is either one or two characters, representing the parties of the senators to evacuate in each step.\n\nIt is guaranteed that at least one valid evacuation plan will exist. If multiple evacuation plans are valid, you may output any of them.", "hint": "**Sample Explanation**\n\nThe sample output displays one set of answers to the sample cases. Other answers may be possible.\n\nIn Case #1, there are two senators from each of the parties A and B. If we remove one from each party every time, the perfect balance is maintained until evacuation is complete.\n\nCase #2 proceeds as follows:\n\n- Initially in the room: 3 A, 2 B, 2 C.\n- Evacuate AA. Still in the room: 1 A, 2 B, 2 C.\n- Evacuate BC. Still in the room: 1 A, 1 B, 1 C.\n- Evacuate C. Still in the room: 1 A, 1 B.\n- Evacuate AB. Evacuation complete!\n\nNote that it would not be valid to begin the evacuation with BC, which would leave 3 A, 1 B, and 1 C in the room; party A would have an absolute majority (3 out of 5 = 60%).\n\nFor Case #3, note that CC AB would also be a valid answer, and C C AB is also valid even though it requires three evacuation steps instead of two.\n\n**Sample Explanation**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 50$.\n- No party will have an absolute majority before the start of the evacuation.\n- $1 \\leqslant \\mathbf{P}_{\\mathbf{i}} \\leqslant 1000$, for all i.\n\n**Small dataset (8 Pts, Test set 1 - Visible)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 3$.\n- sum of all $\\mathbf{P}_{\\mathbf{i}} \\leqslant 9$.\n\n**Large dataset (10 Pts, Test set 2 - Hidden)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 26$.\n- sum of all $\\mathbf{P}_{\\mathbf{i}} \\leqslant 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2016 #1C] Senate Evacuation", "background": "", "description": "A small fire started in the senate room, and it needs to be evacuated!\n\nThere are some senators in the senate room, each of whom belongs to one of $\\mathbf{N}$ political parties. Those parties are named after the first $\\mathbf{N}$ (uppercase) letters of the English alphabet.\n\nThe emergency door is wide enough for up to two senators, so in each step of the evacuation, you may choose to remove either one or two senators from the room.\n\nThe senate rules indicate the senators in the room may vote on any bill at any time, even in the middle of an evacuation! So, the senators must be evacuated in a way that ensures that no party ever has an absolute majority. That is, it can never be the case after any evacuation step that more than half of the senators in the senate room belong to the same party.\n\nCan you construct an evacuation plan? The senate is counting on you!\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines. The first line contains a single integer $\\mathbf{N}$, the number of parties. The second line contains $\\mathbf{N}$ integers, $\\mathbf{P}_{1}, \\mathbf{P}_{2}, \\ldots, \\mathbf{P}_{\\mathbf{N}}$, where $\\mathbf{P}_{i}$ represents the number of senators of the party named after the i-th letter of the alphabet.\n", "outputFormat": "For each test case, output one line containing Case #x: y, where $x$ is the test case number (starting from 1) and $y$ is the evacuation plan. The plan must be a space-separated list of instructions, in the order in which they are to be carried out, where each instruction is either one or two characters, representing the parties of the senators to evacuate in each step.\n\nIt is guaranteed that at least one valid evacuation plan will exist. If multiple evacuation plans are valid, you may output any of them.", "hint": "**Sample Explanation**\n\nThe sample output displays one set of answers to the sample cases. Other answers may be possible.\n\nIn Case #1, there are two senators from each of the parties A and B. If we remove one from each party every time, the perfect balance is maintained until evacuation is complete.\n\nCase #2 proceeds as follows:\n\n- Initially in the room: 3 A, 2 B, 2 C.\n- Evacuate AA. Still in the room: 1 A, 2 B, 2 C.\n- Evacuate BC. Still in the room: 1 A, 1 B, 1 C.\n- Evacuate C. Still in the room: 1 A, 1 B.\n- Evacuate AB. Evacuation complete!\n\nNote that it would not be valid to begin the evacuation with BC, which would leave 3 A, 1 B, and 1 C in the room; party A would have an absolute majority (3 out of 5 = 60%).\n\nFor Case #3, note that CC AB would also be a valid answer, and C C AB is also valid even though it requires three evacuation steps instead of two.\n\n**Sample Explanation**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 50$.\n- No party will have an absolute majority before the start of the evacuation.\n- $1 \\leqslant \\mathbf{P}_{\\mathbf{i}} \\leqslant 1000$, for all i.\n\n**Small dataset (8 Pts, Test set 1 - Visible)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 3$.\n- sum of all $\\mathbf{P}_{\\mathbf{i}} \\leqslant 9$.\n\n**Large dataset (10 Pts, Test set 2 - Hidden)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 26$.\n- sum of all $\\mathbf{P}_{\\mathbf{i}} \\leqslant 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2016 #1C] Senate Evacuation", "background": "", "description": "参议院会议厅里起了一场小火，必须进行疏散！\n\n会议厅里有若干参议员，每位参议员都属于 $\\mathbf{N}$ 个政党中的某一个。这些政党的名称分别为英语字母表前 $\\mathbf{N}$ 个大写字母。\n\n紧急出口足够宽敞，每一步疏散时你可以选择移除一名或两名参议员。\n\n参议院的规则规定，即使在疏散过程中，会议厅里的参议员也可以随时对任何议案进行投票！因此，疏散必须以一种方式进行，保证任何时刻都不会有某个政党拥有绝对多数。也就是说，在任何一次疏散操作之后，会议厅中都不能出现某个政党成员人数超过总人数一半的情况。\n\n你能制定一个疏散方案吗？参议院全靠你了！", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例数量。接下来有 $\\mathbf{T}$ 组测试用例。每组测试用例包含两行。第一行是一个整数 $\\mathbf{N}$，表示政党数量。第二行包含 $\\mathbf{N}$ 个整数，$\\mathbf{P}_1, \\mathbf{P}_2, \\ldots, \\mathbf{P}_\\mathbf{N}$，其中 $\\mathbf{P}_i$ 表示以字母表第 $i$ 个字母命名的政党拥有的参议员人数。\n", "outputFormat": "对于每组测试用例，输出一行 `Case #x: y`，其中 $x$ 表示测试用例编号（从 1 开始），$y$ 是疏散方案。方案应为一个以空格分隔的操作序列，每个操作为一个或两个字母，表示本次疏散中被移除的参议员所属政党。\n\n保证至少存在一种合法的疏散方案。如果有多种方案，你可以输出任意一种。", "hint": "**样例解释**\n\n样例输出展示的是一组可能的答案，其他答案也可能是正确的。\n\n在第 1 组中，A 和 B 两个政党各有两名参议员。如果每次各移除一人，始终保持完美平衡，直到全部疏散。\n\n第 2 组操作如下：\n\n- 初始：3 名 A，2 名 B，2 名 C。\n- 疏散 AA。剩余：1 名 A，2 名 B，2 名 C。\n- 疏散 BC。剩余：1 名 A，1 名 B，1 名 C。\n- 疏散 C。剩余：1 名 A，1 名 B。\n- 疏散 AB。全部疏散完成！\n\n注意，不能以 BC 开始疏散，否则剩下 3 名 A，1 名 B，1 名 C，A 党将拥有绝对多数（3/5 = 60%）。\n\n对于第 3 组，CC AB 也是一个合法答案，C C AB 也是合法的，尽管需要三步而不是两步。\n\n**限制条件**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 50$。\n- 在疏散开始前，没有任何政党拥有绝对多数。\n- 对所有 $i$，$1 \\leqslant \\mathbf{P}_i \\leqslant 1000$。\n\n**小数据集（8 分，测试集 1 - 可见）**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 3$。\n- 所有 $\\mathbf{P}_i$ 之和 $\\leqslant 9$。\n\n**大数据集（10 分，测试集 2 - 隐藏）**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 26$。\n- 所有 $\\mathbf{P}_i$ 之和 $\\leqslant 1000$。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13196", "type": "P", "difficulty": 4, "samples": [["3\n5 4\n2 1\n4 20", "Case #1: POSSIBLE\n01001\n00110\n00001\n00101\n00000\nCase #2: POSSIBLE\n01\n00\nCase #3: IMPOSSIBLE"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["图论", "2016", "Special Judge", "构造", "Google Code Jam"], "title": "[GCJ 2016 #1C] Slides!", "background": "", "description": "Gooli is a huge company that owns $\\mathbf{B}$ buildings in a hilly area. The buildings are numbered from 1 to $\\mathbf{B}$.\n\nThe CEO wants to build a set of slides between buildings that she can use to travel from her office in building 1 to her favorite cafe in building $\\mathbf{B}$. Slides, of course, are one-way only, but the buildings are tall and have elevators, so a slide can start in any building and end in any other building, and can go in either direction. Specifically, for any two buildings $\\mathrm{x}$ and $\\mathrm{y}$, you can build either zero or one slides from $\\mathrm{x}$ to $\\mathrm{y}$, and you can build either zero or one slides from $\\mathrm{y}$ to $\\mathrm{x}$. The exception is that no slides are allowed to originate in building $\\mathbf{B}$, since once the CEO reaches that building, there is no need for her to do any more sliding.\n\nIn honor of Gooli becoming exactly $\\mathbf{M}$ milliseconds old, the design must ensure that the CEO has exactly $\\mathbf{M}$ different ways to travel from building 1 to building $\\mathbf{B}$ using the new slides. A way is a sequence of buildings that starts with building 1, ends with building $\\mathbf{B}$, and has the property that for each pair of consecutive buildings $\\mathrm{x}$ and $\\mathrm{y}$ in the sequence, a slide exists from $\\mathrm{x}$ to $\\mathrm{y}$. Note that the CEO is not requiring that any building be reachable from any other building via slides.\n\nCan you come up with any set of one or more slides that satisfies the CEO's requirements, or determine that it is impossible?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow; each consists of one line with two integers $\\mathbf{B}$ and $\\mathbf{M}$, as described above.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the word POSSIBLE or IMPOSSIBLE, depending on whether the CEO's requirements can be fulfilled or not. If it is possible, output an additional $\\mathbf{B}$ lines containing $\\mathbf{B}$ characters each, representing a matrix describing a valid way to build slides according to the requirements. The $\\mathrm{j}$-th character of the $\\mathrm{i}$-th of these lines (with both $\\mathrm{i}$ and $\\mathrm{j}$ counting starting from 1) should be 1 if a slide should be built going from building $\\mathrm{i}$ to building $\\mathrm{j}$, and 0 otherwise. The $\\mathrm{i}$-th character of the $\\mathrm{i}$-th line should always be 0 , and every character of the last line should be 0 .\n\nIf multiple solutions are possible, you may output any of them.", "hint": "**Sample Explanation**\n\nThe sample outputs show one possible way to fulfill the specifications for each case. Other valid answers may exist.\n\nHere is an illustration of the sample answer for Case #1:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/742n0lsq.png)\n\nThe four ways to get from building 1 to building 5 are:\n\n  * 1 to 5\n  * 1 to 2 to 3 to 5\n  * 1 to 2 to 4 to 5\n  * 1 to 2 to 4 to 3 to 5\n\nIn Case #3, building slides from 1 to 2, 2 to 3, 3 to 1, and 1 to 4 would create infinitely many ways for the CEO to reach building 4 (she could go directly to 4, or go around the loop once and then go to 4, or go around the loop twice...), but the CEO requested exactly 20 ways.\n\n**Limits**\n\n$1 \\leqslant \\mathbf{T} \\leqslant 100$.\n\n**Small dataset (13 Pts, Test Set 1 - Visible)**\n\n- $2 \\leqslant \\mathbf{B} \\leqslant 6$.\n- $1 \\leqslant \\mathbf{M} \\leqslant 20$.\n\n**Large dataset (21 Pts, Test Set 2 - Hidden)**\n\n- $2 \\leqslant \\mathbf{B} \\leqslant 50$.\n- $1 \\leqslant \\mathbf{M} \\leqslant 10^{18}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2016 #1C] Slides!", "background": "", "description": "Gooli is a huge company that owns $\\mathbf{B}$ buildings in a hilly area. The buildings are numbered from 1 to $\\mathbf{B}$.\n\nThe CEO wants to build a set of slides between buildings that she can use to travel from her office in building 1 to her favorite cafe in building $\\mathbf{B}$. Slides, of course, are one-way only, but the buildings are tall and have elevators, so a slide can start in any building and end in any other building, and can go in either direction. Specifically, for any two buildings $\\mathrm{x}$ and $\\mathrm{y}$, you can build either zero or one slides from $\\mathrm{x}$ to $\\mathrm{y}$, and you can build either zero or one slides from $\\mathrm{y}$ to $\\mathrm{x}$. The exception is that no slides are allowed to originate in building $\\mathbf{B}$, since once the CEO reaches that building, there is no need for her to do any more sliding.\n\nIn honor of Gooli becoming exactly $\\mathbf{M}$ milliseconds old, the design must ensure that the CEO has exactly $\\mathbf{M}$ different ways to travel from building 1 to building $\\mathbf{B}$ using the new slides. A way is a sequence of buildings that starts with building 1, ends with building $\\mathbf{B}$, and has the property that for each pair of consecutive buildings $\\mathrm{x}$ and $\\mathrm{y}$ in the sequence, a slide exists from $\\mathrm{x}$ to $\\mathrm{y}$. Note that the CEO is not requiring that any building be reachable from any other building via slides.\n\nCan you come up with any set of one or more slides that satisfies the CEO's requirements, or determine that it is impossible?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow; each consists of one line with two integers $\\mathbf{B}$ and $\\mathbf{M}$, as described above.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the word POSSIBLE or IMPOSSIBLE, depending on whether the CEO's requirements can be fulfilled or not. If it is possible, output an additional $\\mathbf{B}$ lines containing $\\mathbf{B}$ characters each, representing a matrix describing a valid way to build slides according to the requirements. The $\\mathrm{j}$-th character of the $\\mathrm{i}$-th of these lines (with both $\\mathrm{i}$ and $\\mathrm{j}$ counting starting from 1) should be 1 if a slide should be built going from building $\\mathrm{i}$ to building $\\mathrm{j}$, and 0 otherwise. The $\\mathrm{i}$-th character of the $\\mathrm{i}$-th line should always be 0 , and every character of the last line should be 0 .\n\nIf multiple solutions are possible, you may output any of them.", "hint": "**Sample Explanation**\n\nThe sample outputs show one possible way to fulfill the specifications for each case. Other valid answers may exist.\n\nHere is an illustration of the sample answer for Case #1:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/742n0lsq.png)\n\nThe four ways to get from building 1 to building 5 are:\n\n  * 1 to 5\n  * 1 to 2 to 3 to 5\n  * 1 to 2 to 4 to 5\n  * 1 to 2 to 4 to 3 to 5\n\nIn Case #3, building slides from 1 to 2, 2 to 3, 3 to 1, and 1 to 4 would create infinitely many ways for the CEO to reach building 4 (she could go directly to 4, or go around the loop once and then go to 4, or go around the loop twice...), but the CEO requested exactly 20 ways.\n\n**Limits**\n\n$1 \\leqslant \\mathbf{T} \\leqslant 100$.\n\n**Small dataset (13 Pts, Test Set 1 - Visible)**\n\n- $2 \\leqslant \\mathbf{B} \\leqslant 6$.\n- $1 \\leqslant \\mathbf{M} \\leqslant 20$.\n\n**Large dataset (21 Pts, Test Set 2 - Hidden)**\n\n- $2 \\leqslant \\mathbf{B} \\leqslant 50$.\n- $1 \\leqslant \\mathbf{M} \\leqslant 10^{18}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2016 #1C] Slides!", "background": "", "description": "Gooli 是一家在丘陵地区拥有 $\\mathbf{B}$ 座大楼的巨型公司。这些大楼编号为 $1$ 到 $\\mathbf{B}$。\n\nCEO 希望在大楼之间建设一组滑梯，方便她从自己在 1 号大楼的办公室前往她最喜欢的咖啡馆所在的 $\\mathbf{B}$ 号大楼。滑梯当然是单向的，但由于大楼都很高且有电梯，滑梯可以从任意一栋大楼出发，通向任意另一栋大楼，方向不限。具体来说，对于任意两栋大楼 $\\mathrm{x}$ 和 $\\mathrm{y}$，你可以选择建造 $0$ 条或 $1$ 条从 $\\mathrm{x}$ 到 $\\mathrm{y}$ 的滑梯，也可以选择建造 $0$ 条或 $1$ 条从 $\\mathrm{y}$ 到 $\\mathrm{x}$ 的滑梯。唯一的例外是，不允许从 $\\mathbf{B}$ 号大楼出发建滑梯，因为 CEO 一旦到达那里，就不再需要继续滑行。\n\n为了纪念 Gooli 公司成立恰好 $\\mathbf{M}$ 毫秒，设计方案必须确保 CEO 恰好有 $\\mathbf{M}$ 种不同的方式从 1 号大楼滑到 $\\mathbf{B}$ 号大楼。一种方式定义为一个以 1 号大楼为起点、以 $\\mathbf{B}$ 号大楼为终点的楼栋序列，且序列中任意相邻的两栋楼之间都存在一条滑梯。注意，CEO 并不要求任意两栋大楼之间都能通过滑梯互达。\n\n你能否给出一种包含一条或多条滑梯的方案，使得 CEO 的要求得到满足？或者判断这种方案是否不可能存在？", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例数量。接下来有 $\\mathbf{T}$ 行，每行包含两个整数 $\\mathbf{B}$ 和 $\\mathbf{M}$，含义如上所述。\n", "outputFormat": "对于每组测试用例，输出一行 `Case #x: y`，其中 $\\mathrm{x}$ 是测试用例编号（从 1 开始），$\\mathrm{y}$ 是单词 POSSIBLE 或 IMPOSSIBLE，表示能否满足 CEO 的要求。如果可行，接下来输出 $\\mathbf{B}$ 行，每行包含 $\\mathbf{B}$ 个字符，描述一个合法的滑梯建设方案。第 $\\mathrm{i}$ 行第 $\\mathrm{j}$ 个字符为 1 表示应从第 $\\mathrm{i}$ 栋大楼到第 $\\mathrm{j}$ 栋大楼建一条滑梯，否则为 0。第 $\\mathrm{i}$ 行第 $\\mathrm{i}$ 个字符始终为 0，最后一行的所有字符也应全为 0。\n\n如果存在多种合法方案，你可以输出任意一种。", "hint": "**样例解释**\n\n样例输出展示了每组数据的一种可行方案，其他方案也是可能的。\n\n以下是第 1 组样例方案的示意图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/742n0lsq.png)\n\n从 1 号大楼到 5 号大楼共有 4 种方式：\n\n- 1 → 5\n- 1 → 2 → 3 → 5\n- 1 → 2 → 4 → 5\n- 1 → 2 → 4 → 3 → 5\n\n在第 3 组中，如果建造 1→2、2→3、3→1、1→4 的滑梯，则 CEO 可以有无数种方式到达 4 号大楼（可以直接到 4，也可以绕环多次后再到 4），但 CEO 要求恰好 20 种方式。\n\n**限制条件**\n\n$1 \\leqslant \\mathbf{T} \\leqslant 100$。\n\n**小数据集（13 分，测试集 1 - 可见）**\n\n- $2 \\leqslant \\mathbf{B} \\leqslant 6$。\n- $1 \\leqslant \\mathbf{M} \\leqslant 20$。\n\n**大数据集（21 分，测试集 2 - 隐藏）**\n\n- $2 \\leqslant \\mathbf{B} \\leqslant 50$。\n- $1 \\leqslant \\mathbf{M} \\leqslant 10^{18}$。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13197", "type": "P", "difficulty": 5, "samples": [["4\n1 1 1 10\n1 2 3 2\n1 1 3 2\n1 2 3 1", "Case #1: 1\n1 1 1\nCase #2: 4\n1 1 2\n1 2 3\n1 2 1\n1 1 1\nCase #3: 2\n1 1 2\n1 1 1\nCase #4: 2\n1 1 3\n1 2 1"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["数学", "2016", "Special Judge", "构造", "Google Code Jam"], "title": "[GCJ 2016 #1C] Fashion Police", "background": "", "description": "You are so excited about the 2016 Code Jam World Finals that you just moved to New York. You have brought along $\\mathbf{J}$ different jackets (numbered 1 through $\\mathbf{J}$), $\\mathbf{P}$ different pairs of pants (numbered 1 through $\\mathbf{P}$), and $\\mathbf{S}$ different shirts (numbered 1 through $\\mathbf{S}$). You have at least as many shirts as pairs of pants, and at least as many pairs of pants as jackets. $(\\mathbf{J} \\leqslant \\mathbf{P} \\leqslant \\mathbf{S})$.\n\nEvery day, you will pick one jacket, one pair of pants, and one shirt to wear as an outfit. You wash all of your garments every night so all of your garments are available to use each day.\n\nIn New York, the Fashion Police officers are always watching and keeping track of what everyone wears every day. If they find out that you have worn the exact same outfit twice, you will immediately be taken to the Fashion Jail on 5th Avenue for a mandatory makeover; you definitely want to avoid that! You will also immediately be taken to Fashion Jail if they find out that you have worn the same two-garment combination more than $\\mathbf{K}$ times in total. A combination consists of a particular jacket worn with a particular pair of pants, a particular jacket worn with a particular shirt, or a particular pair of pants worn with a particular shirt. For example, in the set of outfits (jacket 1, pants 2, shirt 3) and (jacket 1, pants 1, shirt 3), the combination (jacket 1, shirt 3) appears twice, whereas the combination (pants 1, shirt 3) only appears once.\n\nYou will wear one outfit per day. Can you figure out the largest possible number of days you can avoid being taken to Fashion Jail and produce a list of outfits to use each day?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow; each consists of one line with four integers $\\mathbf{J}, \\mathbf{P}, \\mathbf{S}$, and $\\mathbf{K}$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is an integer: the maximum number of days you will be able to avoid being taken to Fashion Jail. Then output $\\mathrm{y}$ more lines, each of which consists of three integers: the numbers of the jacket, pants, and shirt (in that order) for one day's outfit. The list of outfits can be in any order, but the outfits must not cause you to go to Fashion Jail as described in the statement above.\n\nIf multiple answers are possible, you may output any of them.", "hint": "**Sample Explanation**\n\nThe sample output displays one set of answers to the sample cases. Other answers may be possible.\n\nIn Case #1, even though the Fashion Police officers have set a lenient $\\mathbf{K}$ value of 10 , there is only one possible outfit that you can form, so you can only avoid Fashion Jail for one day.\n\nIn Case #2, adding any other outfit would cause you to go to Fashion Jail:\n\n* Adding 1 1 3 would use the combination (jacket 1, pants 1) more than 2 times.\n* Adding 1 2 2 would use the combination (jacket 1, pants 2) more than 2 times.\n\nIn this case, any set of 5 outfits would include at least one fashion violation.\n\nNote that the numbers of the jacket, pants, and shirt within an individual outfit do not have to be in nondecreasing order in the same way that $\\mathbf{J}, \\mathbf{P}$, and $\\mathbf{S}$ do.\n\nIn Case #3, you have only one jacket + pants combination which you must keep reusing, so no matter which shirts you wear, you cannot form more than $\\mathbf{K}=2$ different outfits.\n\nIn Case #4, another possible maximally large set of outfits is:\n```\n1 2 2\n1 1 1\n```\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{J} \\leqslant \\mathbf{P} \\leqslant \\mathbf{S}$.\n- $1 \\leqslant \\mathbf{K} \\leqslant 10$.\n\n**Small dataset (Test Set 1 - Visible)**\n\n- $\\mathbf{S} \\leqslant 3$.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- $\\mathbf{S} \\leqslant 10$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2016 #1C] Fashion Police", "background": "", "description": "You are so excited about the 2016 Code Jam World Finals that you just moved to New York. You have brought along $\\mathbf{J}$ different jackets (numbered 1 through $\\mathbf{J}$), $\\mathbf{P}$ different pairs of pants (numbered 1 through $\\mathbf{P}$), and $\\mathbf{S}$ different shirts (numbered 1 through $\\mathbf{S}$). You have at least as many shirts as pairs of pants, and at least as many pairs of pants as jackets. $(\\mathbf{J} \\leqslant \\mathbf{P} \\leqslant \\mathbf{S})$.\n\nEvery day, you will pick one jacket, one pair of pants, and one shirt to wear as an outfit. You wash all of your garments every night so all of your garments are available to use each day.\n\nIn New York, the Fashion Police officers are always watching and keeping track of what everyone wears every day. If they find out that you have worn the exact same outfit twice, you will immediately be taken to the Fashion Jail on 5th Avenue for a mandatory makeover; you definitely want to avoid that! You will also immediately be taken to Fashion Jail if they find out that you have worn the same two-garment combination more than $\\mathbf{K}$ times in total. A combination consists of a particular jacket worn with a particular pair of pants, a particular jacket worn with a particular shirt, or a particular pair of pants worn with a particular shirt. For example, in the set of outfits (jacket 1, pants 2, shirt 3) and (jacket 1, pants 1, shirt 3), the combination (jacket 1, shirt 3) appears twice, whereas the combination (pants 1, shirt 3) only appears once.\n\nYou will wear one outfit per day. Can you figure out the largest possible number of days you can avoid being taken to Fashion Jail and produce a list of outfits to use each day?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow; each consists of one line with four integers $\\mathbf{J}, \\mathbf{P}, \\mathbf{S}$, and $\\mathbf{K}$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is an integer: the maximum number of days you will be able to avoid being taken to Fashion Jail. Then output $\\mathrm{y}$ more lines, each of which consists of three integers: the numbers of the jacket, pants, and shirt (in that order) for one day's outfit. The list of outfits can be in any order, but the outfits must not cause you to go to Fashion Jail as described in the statement above.\n\nIf multiple answers are possible, you may output any of them.", "hint": "**Sample Explanation**\n\nThe sample output displays one set of answers to the sample cases. Other answers may be possible.\n\nIn Case #1, even though the Fashion Police officers have set a lenient $\\mathbf{K}$ value of 10 , there is only one possible outfit that you can form, so you can only avoid Fashion Jail for one day.\n\nIn Case #2, adding any other outfit would cause you to go to Fashion Jail:\n\n* Adding 1 1 3 would use the combination (jacket 1, pants 1) more than 2 times.\n* Adding 1 2 2 would use the combination (jacket 1, pants 2) more than 2 times.\n\nIn this case, any set of 5 outfits would include at least one fashion violation.\n\nNote that the numbers of the jacket, pants, and shirt within an individual outfit do not have to be in nondecreasing order in the same way that $\\mathbf{J}, \\mathbf{P}$, and $\\mathbf{S}$ do.\n\nIn Case #3, you have only one jacket + pants combination which you must keep reusing, so no matter which shirts you wear, you cannot form more than $\\mathbf{K}=2$ different outfits.\n\nIn Case #4, another possible maximally large set of outfits is:\n```\n1 2 2\n1 1 1\n```\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{J} \\leqslant \\mathbf{P} \\leqslant \\mathbf{S}$.\n- $1 \\leqslant \\mathbf{K} \\leqslant 10$.\n\n**Small dataset (Test Set 1 - Visible)**\n\n- $\\mathbf{S} \\leqslant 3$.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- $\\mathbf{S} \\leqslant 10$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2016 #1C] Fashion Police", "background": "", "description": "你因为对 2016 年 Code Jam 世界总决赛的兴奋，刚刚搬到了纽约。你带来了 $\\mathbf{J}$ 件不同的夹克（编号为 $1$ 到 $\\mathbf{J}$）、$\\mathbf{P}$ 条不同的裤子（编号为 $1$ 到 $\\mathbf{P}$）、以及 $\\mathbf{S}$ 件不同的衬衫（编号为 $1$ 到 $\\mathbf{S}$）。你拥有的衬衫数量不少于裤子的数量，裤子的数量不少于夹克的数量，即满足 $(\\mathbf{J} \\leqslant \\mathbf{P} \\leqslant \\mathbf{S})$。\n\n每天，你会选择一件夹克、一条裤子和一件衬衫组成当天的穿搭。每天晚上你都会清洗所有衣物，因此每天所有衣物都可以重新使用。\n\n在纽约，**时尚警察**随时在监视并记录每个人每天的穿着。如果他们发现你穿过完全相同的穿搭两次，你就会立刻被带到五大道的“时尚监狱”进行强制改造；你当然不希望那样！如果他们发现你穿过同一对衣物组合的次数超过 $\\mathbf{K}$ 次，你也会立刻被带到时尚监狱。所谓“组合”，是指某一件夹克和某一条裤子的组合、某一件夹克和某一件衬衫的组合，或者某一条裤子和某一件衬衫的组合。例如，在穿搭 (夹克 1, 裤子 2, 衬衫 3) 和 (夹克 1, 裤子 1, 衬衫 3) 这两天中，组合 (夹克 1, 衬衫 3) 出现了两次，而组合 (裤子 1, 衬衫 3) 只出现了一次。\n\n每天你只能穿一套衣服。你能否找出最多可以连续多少天避免被送进时尚监狱，并给出每天的穿搭方案列表？", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例数量。接下来有 $\\mathbf{T}$ 组测试用例，每组一行包含四个整数 $\\mathbf{J}, \\mathbf{P}, \\mathbf{S}, \\mathbf{K}$。\n", "outputFormat": "对于每组测试用例，输出一行 `Case #x: y`，其中 $\\mathrm{x}$ 为测试用例编号（从 1 开始），$\\mathrm{y}$ 为你能够连续避免被送进时尚监狱的最大天数。随后输出 $\\mathrm{y}$ 行，每行三个整数，分别表示某一天的夹克、裤子和衬衫编号（按此顺序）。穿搭顺序可以任意，但不得违反上述时尚警察的规定。\n\n如有多种合法方案，你可以输出任意一种。\n", "hint": "**样例解释**\n\n样例输出展示了一组可行解，其他答案也可能是正确的。\n\n在第 1 组中，尽管时尚警察对 $\\mathbf{K}$ 的限制很宽松（$10$），但你只能组成一种穿搭，因此只能坚持一天。\n\n在第 2 组中，添加任何其他穿搭都会导致你被送进时尚监狱：\n\n- 添加 1 1 3 会导致组合 (夹克 1, 裤子 1) 出现超过 2 次。\n- 添加 1 2 2 会导致组合 (夹克 1, 裤子 2) 出现超过 2 次。\n\n在这种情况下，任意 5 套穿搭都必然存在至少一处时尚违规。\n\n注意，单日穿搭中的夹克、裤子、衬衫编号不需要像 $\\mathbf{J}, \\mathbf{P}, \\mathbf{S}$ 那样满足递增关系。\n\n在第 3 组中，你只有一种夹克+裤子的组合，只能反复穿，所以无论衬衫怎么选，都无法组成超过 $\\mathbf{K}=2$ 套不同的穿搭。\n\n在第 4 组中，另一组同样规模的最大解为：\n\n```\n1 2 2\n1 1 1\n```\n\n\n**限制条件**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$。\n- $1 \\leqslant \\mathbf{J} \\leqslant \\mathbf{P} \\leqslant \\mathbf{S}$。\n- $1 \\leqslant \\mathbf{K} \\leqslant 10$。\n\n**小数据集（测试集 1 - 可见）**\n\n- $\\mathbf{S} \\leqslant 3$。\n\n**大数据集（测试集 2 - 隐藏）**\n\n- $\\mathbf{S} \\leqslant 10$。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13198", "type": "P", "difficulty": 3, "samples": [["4\n1 1 1 0\n1 2 0 0\n2 1 1 2\n2 2 0 2", "Case #1: PR\nCase #2: IMPOSSIBLE\nCase #3: PSRS\nCase #4: IMPOSSIBLE"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2016", "Google Code Jam"], "title": "[GCJ 2016 #2] Rather Perplexing Showdown", "background": "", "description": "You've been asked to organize a Rock-Paper-Scissors tournament. The tournament will have a single-elimination format and will run for $\\mathrm{N}$ rounds; $2^{\\mathrm{N}}$ players will participate.\n\nInitially, the players will be lined up from left to right in some order that you specify. In each round, the first and second players in the lineup (starting from the left) will play a match against each other, and the third and fourth players in the lineup (if they exist) will play a match against each other, and so on; all of these matches will occur simultaneously. The winners of these matches will remain in the lineup, in the same relative order, and the losers will leave the lineup and go home. Then a new round will begin. This will continue until only one player remains in the lineup; that player will be declared the winner.\n\nIn each Rock-Paper-Scissors match, each of the two players secretly chooses one of Rock, Paper, or Scissors, and then they compare their choices. Rock beats Scissors, Scissors beats Paper, and Paper beats Rock. If one player's choice beats the other players's choice, then that player wins and the match is over. However, if the players make the same choice, then it is a tie, and they must choose again and keep playing until there is a winner.\n\nYou know that the players this year are stubborn and not very strategic. Each one has a preferred move and will only play that move in every match, regardless of what the opponent does. Because of this, if two players with the same move go up against each other, they will keep tying and their match will go on forever! If this happens, the tournament will never end and you will be a laughingstock.\n\nThis year, there are $\\mathbf{R}$ players who prefer Rock, $\\mathbf{P}$ players who prefer Paper, and $\\mathbf{S}$ players who prefer Scissors. Knowing this, you want to create a lineup that guarantees that the tournament will go to completion and produce a single winner — that is, no match will ever be a tie. Your boss has asked you to produce a list of all such lineups (written in left to right order, with $\\mathrm{R}, \\mathrm{P}$, and $\\mathrm{S}$ standing for players who prefer Rock, Paper, and Scissors, respectively), and then put that list in alphabetical order.\n\nYou know that the boss will lazily pick the first lineup on the list; what will that be? Or do you have to tell your boss that it is IMPOSSIBLE to prevent a tie?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow; each represents one test case. Each test case consists of four integers: $\\mathbf{N}, \\mathbf{R}, \\mathbf{P}$, and $\\mathbf{S}$, as described in the statement above.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is either IMPOSSIBLE or a string of length $2^{\\mathrm{N}}$ representing the alphabetically earliest starting lineup that solves the problem. Every character in a lineup must be $\\mathrm{R}, \\mathrm{P}$, or $\\mathrm{s}$, and there must be $\\mathbf{R}$ `R`s, $\\mathbf{P}$ `P`s, and $\\mathbf{S}$ `S`s.", "hint": "**Sample Explanation**\n\nIn sample case #1, there are only two players and the tournament will consist of one round. It doesn't matter what order the two line up in; the Paper-using player will defeat the Rock-using player. You will give your boss the alphabetically ordered list PR, RP, and the first element is PR.\n\nIn sample case #2, the only two players both play Rock, so a tie is unavoidable.\n\nIn sample case #3, there are four players and the tournament will go on for two rounds. In the first round, the first player (Paper) will lose to the second player (Scissors), and the third player (Rock) will defeat the fourth player (Scissors). The second round lineup will be PR, and the first remaining player (Paper) will defeat the other remaining player (Rock), so the tournament will end with a winner and no ties.\n\nHere is an illustration of the tournament for sample case #3:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sr2g4apj.png)\n\nOther lineups such as PSSR will appear on the list you give to your boss, but PSRS is alphabetically first.\nIn sample case #4, the only way to organize the first round such that there are no ties is to create two matches with one Rock player and one Scissors player. But both of those matches will have a Rock winner, and when these two winners go on to face each other, there will be a tie.\n\n**Limits**\n\n- $\\mathbf{R}+\\mathbf{P}+\\mathbf{S}=2^{\\mathbf{N}}$.\n- $0 \\leqslant \\mathbf{R} \\leqslant 2^{\\mathbf{N}}$.\n- $0 \\leqslant \\mathbf{P} \\leqslant 2^{\\mathbf{N}}$.\n- $0 \\leqslant \\mathbf{S} \\leqslant 2^{\\mathbf{N}}$.\n\n**Small dataset (4 Pts, Test Set 1 - Visible)**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 25$.\n- $1 \\leqslant \\mathbf{N} \\leqslant 3$.\n\n**Large dataset (14 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 75$.\n- $1 \\leqslant \\mathbf{N} \\leqslant 12$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2016 #2] Rather Perplexing Showdown", "background": "", "description": "You've been asked to organize a Rock-Paper-Scissors tournament. The tournament will have a single-elimination format and will run for $\\mathrm{N}$ rounds; $2^{\\mathrm{N}}$ players will participate.\n\nInitially, the players will be lined up from left to right in some order that you specify. In each round, the first and second players in the lineup (starting from the left) will play a match against each other, and the third and fourth players in the lineup (if they exist) will play a match against each other, and so on; all of these matches will occur simultaneously. The winners of these matches will remain in the lineup, in the same relative order, and the losers will leave the lineup and go home. Then a new round will begin. This will continue until only one player remains in the lineup; that player will be declared the winner.\n\nIn each Rock-Paper-Scissors match, each of the two players secretly chooses one of Rock, Paper, or Scissors, and then they compare their choices. Rock beats Scissors, Scissors beats Paper, and Paper beats Rock. If one player's choice beats the other players's choice, then that player wins and the match is over. However, if the players make the same choice, then it is a tie, and they must choose again and keep playing until there is a winner.\n\nYou know that the players this year are stubborn and not very strategic. Each one has a preferred move and will only play that move in every match, regardless of what the opponent does. Because of this, if two players with the same move go up against each other, they will keep tying and their match will go on forever! If this happens, the tournament will never end and you will be a laughingstock.\n\nThis year, there are $\\mathbf{R}$ players who prefer Rock, $\\mathbf{P}$ players who prefer Paper, and $\\mathbf{S}$ players who prefer Scissors. Knowing this, you want to create a lineup that guarantees that the tournament will go to completion and produce a single winner — that is, no match will ever be a tie. Your boss has asked you to produce a list of all such lineups (written in left to right order, with $\\mathrm{R}, \\mathrm{P}$, and $\\mathrm{S}$ standing for players who prefer Rock, Paper, and Scissors, respectively), and then put that list in alphabetical order.\n\nYou know that the boss will lazily pick the first lineup on the list; what will that be? Or do you have to tell your boss that it is IMPOSSIBLE to prevent a tie?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow; each represents one test case. Each test case consists of four integers: $\\mathbf{N}, \\mathbf{R}, \\mathbf{P}$, and $\\mathbf{S}$, as described in the statement above.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is either IMPOSSIBLE or a string of length $2^{\\mathrm{N}}$ representing the alphabetically earliest starting lineup that solves the problem. Every character in a lineup must be $\\mathrm{R}, \\mathrm{P}$, or $\\mathrm{s}$, and there must be $\\mathbf{R}$ `R`s, $\\mathbf{P}$ `P`s, and $\\mathbf{S}$ `S`s.", "hint": "**Sample Explanation**\n\nIn sample case #1, there are only two players and the tournament will consist of one round. It doesn't matter what order the two line up in; the Paper-using player will defeat the Rock-using player. You will give your boss the alphabetically ordered list PR, RP, and the first element is PR.\n\nIn sample case #2, the only two players both play Rock, so a tie is unavoidable.\n\nIn sample case #3, there are four players and the tournament will go on for two rounds. In the first round, the first player (Paper) will lose to the second player (Scissors), and the third player (Rock) will defeat the fourth player (Scissors). The second round lineup will be PR, and the first remaining player (Paper) will defeat the other remaining player (Rock), so the tournament will end with a winner and no ties.\n\nHere is an illustration of the tournament for sample case #3:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sr2g4apj.png)\n\nOther lineups such as PSSR will appear on the list you give to your boss, but PSRS is alphabetically first.\nIn sample case #4, the only way to organize the first round such that there are no ties is to create two matches with one Rock player and one Scissors player. But both of those matches will have a Rock winner, and when these two winners go on to face each other, there will be a tie.\n\n**Limits**\n\n- $\\mathbf{R}+\\mathbf{P}+\\mathbf{S}=2^{\\mathbf{N}}$.\n- $0 \\leqslant \\mathbf{R} \\leqslant 2^{\\mathbf{N}}$.\n- $0 \\leqslant \\mathbf{P} \\leqslant 2^{\\mathbf{N}}$.\n- $0 \\leqslant \\mathbf{S} \\leqslant 2^{\\mathbf{N}}$.\n\n**Small dataset (4 Pts, Test Set 1 - Visible)**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 25$.\n- $1 \\leqslant \\mathbf{N} \\leqslant 3$.\n\n**Large dataset (14 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 75$.\n- $1 \\leqslant \\mathbf{N} \\leqslant 12$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2016 #2] Rather Perplexing Showdown", "background": null, "description": "你被要求组织一场石头-剪刀-布锦标赛。该锦标赛采用单败淘汰制，将进行 $\\mathrm{N}$ 轮比赛；共有 $2^{\\mathrm{N}}$ 名选手参赛。\n\n最初，选手们将按照你指定的顺序从左到右排成一列。在每一轮中，队列中第 1 和第 2 名选手（从左到右）进行一场对决，第 3 和第 4 名选手（如果存在）也进行对决，以此类推；所有这些对决将同时进行。每场对决的胜者将留在队列中，保持相对顺序不变，败者则离开队列回家。随后开始新一轮比赛。如此反复，直到队列中只剩一名选手；该选手即为冠军。\n\n在每场石头-剪刀-布对决中，双方选手各自秘密选择石头（Rock）、布（Paper）或剪刀（Scissors）中的一种，然后比较选择。石头胜剪刀，剪刀胜布，布胜石头。如果一方的选择能击败对方，则该方获胜，对决结束。然而，如果双方选择相同，则为平局，他们必须重新选择并继续比，直到分出胜负为止。\n\n你知道，今年的选手们都很固执且毫无策略性。每位选手都有自己偏好的手势，并且无论对手如何，每场比赛都只会出这个手势。因此，如果两位出同样手势的选手对决，他们会一直打平，这场比赛永远不会结束！如果出现这种情况，整个锦标赛将无法结束，你也会沦为笑柄。\n\n今年，有 $\\mathbf{R}$ 名选手只出石头（Rock），$\\mathbf{P}$ 名选手只出布（Paper），$\\mathbf{S}$ 名选手只出剪刀（Scissors）。鉴于此，你希望安排一个选手顺序，保证锦标赛一定可以顺利进行并决出唯一冠军——即任何一场比赛都不会出现平局。你的老板要求你列出所有满足条件的初始排列（按从左到右顺序，用 $\\mathrm{R}$、$\\mathrm{P}$、$\\mathrm{S}$ 分别代表偏好石头、布、剪刀的选手），然后按字典序排序。\n\n你知道老板会懒得看完整个列表，只会挑第一个排列；你能告诉老板这个排列是什么吗？还是你必须告诉老板无法避免平局（即 IMPOSSIBLE）？", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例数量。接下来有 $\\mathbf{T}$ 行，每行对应一个测试用例。每个测试用例包含四个整数：$\\mathbf{N}, \\mathbf{R}, \\mathbf{P}, \\mathbf{S}$，含义如上所述。", "outputFormat": "对于每组测试用例，输出一行 `Case #x: y`，其中 $\\mathrm{x}$ 表示测试用例编号（从 1 开始），$\\mathrm{y}$ 要么是 IMPOSSIBLE，要么是一个长度为 $2^{\\mathrm{N}}$ 的字符串，表示字典序最小的、满足要求的初始选手排列。排列中的每个字符必须是 $\\mathrm{R}$、$\\mathrm{P}$ 或 $\\mathrm{S}$，并且总共有 $\\mathbf{R}$ 个 R，$\\mathbf{P}$ 个 P，$\\mathbf{S}$ 个 S。", "hint": "**样例解释**\n\n在样例第 1 组中，只有两名选手，比赛只进行一轮。无论两人顺序如何，布选手都会击败石头选手。你将向老板提供按字典序排序的 PR、RP，首个排列为 PR。\n\n在样例第 2 组中，两名选手都只出石头，无法避免平局。\n\n在样例第 3 组中，共有四名选手，比赛进行两轮。第一轮，第一名（布）输给第二名（剪刀），第三名（石头）击败第四名（剪刀）。第二轮，队列变为 SR，第一名（剪刀）输给第二名（石头），比赛顺利结束且无平局。\n\n以下是样例第 3 组的比赛流程示意图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sr2g4apj.png)\n\n其他排列如 PSSR 也会出现在你给老板的列表中，但 PSRS 是字典序最小的。\n\n在样例第 4 组中，唯一能安排首轮无平局的方式是让两场比赛分别为一名石头对一名剪刀。但这样会有两名石头选手晋级，下一轮他们会相遇并陷入平局。\n\n**限制条件**\n\n- $\\mathbf{R}+\\mathbf{P}+\\mathbf{S}=2^{\\mathbf{N}}$。\n- $0 \\leqslant \\mathbf{R} \\leqslant 2^{\\mathbf{N}}$。\n- $0 \\leqslant \\mathbf{P} \\leqslant 2^{\\mathbf{N}}$。\n- $0 \\leqslant \\mathbf{S} \\leqslant 2^{\\mathbf{N}}$。\n\n**小数据集（4 分，测试集 1 - 可见）**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 25$。\n- $1 \\leqslant \\mathbf{N} \\leqslant 3$。\n\n**大数据集（14 分，测试集 2 - 隐藏）**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 75$。\n- $1 \\leqslant \\mathbf{N} \\leqslant 12$。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13199", "type": "P", "difficulty": 4, "samples": [["3\n2 2\n0.50 0.50\n4 2\n0.00 0.00 1.00 1.00\n3 2\n0.75 1.00 0.50", "Case #1: 0.5\nCase #2: 1.0\nCase #3: 0.5"]], "limits": {"time": [15000, 30000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2016", "Special Judge", "概率论", "Google Code Jam"], "title": "[GCJ 2016 #2] Red Tape Committee", "background": "", "description": "You are the head of the Department of Redundancy Reduction and Superfluity Shrinkage. Currently, the department cannot agree on whether there is too much \"red tape\" (inefficiency) in the department itself. They have asked you to form a Red Tape Committee to vote on the issue.\n\nThe department has $\\mathbf{N}$ members. For each member, you know the probability $\\mathbf{P}_{\\mathbf{i}}$ that that member will vote \"Yes\". If a member does not vote \"Yes\", they necessarily vote \"No\"; nobody abstains.\n\nYou must choose exactly $\\mathbf{K}$ members to be on the committee. The department rules dictate that $\\mathbf{K}$ must be an even number to allow for ties, which are seen as part of a healthy bureaucracy.\n\nIf you choose committee members to maximize the probability of a tie, what is that probability?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow; each consists of two lines. The first line of a test case consists of two integers $\\mathbf{N}$ and $\\mathbf{K}$, the sizes of the department and the committee. The second line of a test case consists of $\\mathbf{N}$ decimal values $\\mathbf{P}_{\\mathbf{i}}$; each has exactly two decimal places of precision and represents the probability that the $i$-th department member will vote \"Yes\".\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is a floating-point number: the maximum possible probability of a tie. $\\mathrm{y}$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer.", "hint": "**Sample Explanation**\n\nIn sample case #1, you must use the only two available department members to form the committee. That committee will tie only if the two committee members vote differently, which will happen half the time. (Without loss of generality, choose the vote of the first. Then the probability that the second will vote the other way is $0.5$.)\n\nIn sample case #2, the best strategy is to pick one of the members with \"Yes\" probability $0.00$ and one of the members with \"Yes\" probability $1.00$. This guarantees a tie.\n\nIn sample case #3, suppose that we pick the two members with \"Yes\" probabilities of $0.50$ and $0.75$. A tie will happen if the first one votes \"Yes\" and the second one votes \"No\" (probability $0.5 \\times 0.25 = 0.125$), or if the first one votes \"No\" and the second one votes \"Yes\" (probability $0.5 \\times 0.75 = 0.375$). So the total probability of a tie is $0.125 + 0.375 = 0.5$. Choosing the two members with \"Yes\" probabilities of $0.50$ and $1.00$ would also make the tie probability $0.5$, since the $1.00$ member will vote \"Yes\" and the $0.50$ member must vote \"No\". Choosing the two members with \"Yes\" probabilities of $0.75$ and $1.00$ would make the tie probability only $0.25$, since the $1.00$ member will vote \"Yes\" and the $0.75$ member must vote \"No\". So $0.5$ is the best we can do.\n\n**Sample Explanation**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $2 \\leqslant \\mathbf{K} \\leqslant \\mathbf{N}$.\n- $\\mathbf{K}$ is even.\n- $0.00 \\leqslant$ each $\\mathbf{P}_{\\mathbf{i}} \\leqslant 1.00$.\n\n**Small dataset (5 Pts, Test Set 1 - Visible)**\n\n- Time limit: ~~60~~ 15 seconds.\n- $2 \\leqslant \\mathbf{N} \\leqslant 16$.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- Time limit: ~~120~~ 30 seconds.\n- $2 \\leqslant \\mathbf{N} \\leqslant 200$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2016 #2] Red Tape Committee", "background": "", "description": "You are the head of the Department of Redundancy Reduction and Superfluity Shrinkage. Currently, the department cannot agree on whether there is too much \"red tape\" (inefficiency) in the department itself. They have asked you to form a Red Tape Committee to vote on the issue.\n\nThe department has $\\mathbf{N}$ members. For each member, you know the probability $\\mathbf{P}_{\\mathbf{i}}$ that that member will vote \"Yes\". If a member does not vote \"Yes\", they necessarily vote \"No\"; nobody abstains.\n\nYou must choose exactly $\\mathbf{K}$ members to be on the committee. The department rules dictate that $\\mathbf{K}$ must be an even number to allow for ties, which are seen as part of a healthy bureaucracy.\n\nIf you choose committee members to maximize the probability of a tie, what is that probability?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow; each consists of two lines. The first line of a test case consists of two integers $\\mathbf{N}$ and $\\mathbf{K}$, the sizes of the department and the committee. The second line of a test case consists of $\\mathbf{N}$ decimal values $\\mathbf{P}_{\\mathbf{i}}$; each has exactly two decimal places of precision and represents the probability that the $i$-th department member will vote \"Yes\".\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is a floating-point number: the maximum possible probability of a tie. $\\mathrm{y}$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer.", "hint": "**Sample Explanation**\n\nIn sample case #1, you must use the only two available department members to form the committee. That committee will tie only if the two committee members vote differently, which will happen half the time. (Without loss of generality, choose the vote of the first. Then the probability that the second will vote the other way is $0.5$.)\n\nIn sample case #2, the best strategy is to pick one of the members with \"Yes\" probability $0.00$ and one of the members with \"Yes\" probability $1.00$. This guarantees a tie.\n\nIn sample case #3, suppose that we pick the two members with \"Yes\" probabilities of $0.50$ and $0.75$. A tie will happen if the first one votes \"Yes\" and the second one votes \"No\" (probability $0.5 \\times 0.25 = 0.125$), or if the first one votes \"No\" and the second one votes \"Yes\" (probability $0.5 \\times 0.75 = 0.375$). So the total probability of a tie is $0.125 + 0.375 = 0.5$. Choosing the two members with \"Yes\" probabilities of $0.50$ and $1.00$ would also make the tie probability $0.5$, since the $1.00$ member will vote \"Yes\" and the $0.50$ member must vote \"No\". Choosing the two members with \"Yes\" probabilities of $0.75$ and $1.00$ would make the tie probability only $0.25$, since the $1.00$ member will vote \"Yes\" and the $0.75$ member must vote \"No\". So $0.5$ is the best we can do.\n\n**Sample Explanation**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $2 \\leqslant \\mathbf{K} \\leqslant \\mathbf{N}$.\n- $\\mathbf{K}$ is even.\n- $0.00 \\leqslant$ each $\\mathbf{P}_{\\mathbf{i}} \\leqslant 1.00$.\n\n**Small dataset (5 Pts, Test Set 1 - Visible)**\n\n- Time limit: ~~60~~ 15 seconds.\n- $2 \\leqslant \\mathbf{N} \\leqslant 16$.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- Time limit: ~~120~~ 30 seconds.\n- $2 \\leqslant \\mathbf{N} \\leqslant 200$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2016 #2] Red Tape Committee", "background": "", "description": "你是“冗余缩减与多余消减部”的负责人。目前，部门内部对于自身是否存在过多的“繁文缛节”（低效）意见不一。他们请求你组建一个“繁文缛节委员会”，对这个问题进行投票。\n\n部门共有 $\\mathbf{N}$ 名成员。对于每一位成员，你都知道他投“同意”票的概率 $\\mathbf{P}_{\\mathbf{i}}$。如果某位成员没有投“同意”，则必然投“反对”；不会有人弃权。\n\n你必须恰好选择 $\\mathbf{K}$ 名成员组成该委员会。部门规定 $\\mathbf{K}$ 必须是偶数，以便允许投票出现平局，因为平局被视为健康官僚体系的一部分。\n\n如果你选择委员会成员，使得平局出现的概率最大，这个最大概率是多少？", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例数量。接下来有 $\\mathbf{T}$ 组测试用例，每组两行。第一行为两个整数 $\\mathbf{N}$ 和 $\\mathbf{K}$，分别表示部门成员数和委员会成员数。第二行为 $\\mathbf{N}$ 个十进制小数 $\\mathbf{P}_{\\mathbf{i}}$，每个小数精确到小数点后两位，表示第 $i$ 位成员投“同意”票的概率。\n", "outputFormat": "对于每组测试用例，输出一行 `Case #x: y`，其中 $\\mathrm{x}$ 是测试用例编号（从 1 开始），$\\mathrm{y}$ 是一个浮点数，表示平局出现的最大概率。$\\mathrm{y}$ 只要与正确答案的绝对误差或相对误差不超过 $10^{-6}$ 即视为正确。\n", "hint": "**样例解释**\n\n在样例第 1 组中，你只能用这两名成员组建委员会。仅当两人投票不同，才会出现平局，这种情况发生的概率为一半。（不妨设定第一人的投票，第二人投相反的概率为 $0.5$。）\n\n在样例第 2 组中，最优策略是选中一位“同意”概率为 $0.00$ 的成员和一位“同意”概率为 $1.00$ 的成员，这样必然平局。\n\n在样例第 3 组中，假设你选择“同意”概率为 $0.50$ 和 $0.75$ 的两人。平局发生在第一个人投“同意”、第二个人投“反对”（概率 $0.5 \\times 0.25 = 0.125$），或第一个人投“反对”、第二个人投“同意”（概率 $0.5 \\times 0.75 = 0.375$）。总平局概率为 $0.125 + 0.375 = 0.5$。如果选 $0.50$ 和 $1.00$，平局概率也是 $0.5$，因为 $1.00$ 那个人一定投“同意”，$0.50$ 那个人必须投“反对”。如果选 $0.75$ 和 $1.00$，平局概率只有 $0.25$，因为 $1.00$ 那个人一定投“同意”，$0.75$ 那个人必须投“反对”。所以 $0.5$ 是最优解。\n\n**限制条件**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$。\n- $2 \\leqslant \\mathbf{K} \\leqslant \\mathbf{N}$。\n- $\\mathbf{K}$ 为偶数。\n- $0.00 \\leqslant \\mathbf{P}_{\\mathbf{i}} \\leqslant 1.00$。\n\n**小数据集（5 分，测试集 1 - 可见）**\n\n- 时间限制：~~60~~ 15 秒。\n- $2 \\leqslant \\mathbf{N} \\leqslant 16$。\n\n**大数据集（测试集 2 - 隐藏）**\n\n- 时间限制：~~120~~ 30 秒。\n- $2 \\leqslant \\mathbf{N} \\leqslant 200$。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13200", "type": "P", "difficulty": 6, "samples": [["4\n1 1\n1 4 3 2\n1 3\n1 8 2 7 3 4 5 6\n2 2\n8 1 4 5 2 3 7 6\n1 1\n1 3 2 4", "Case #1:\n/\nCase #2:\n//\\\nCase #3:\n//\n\\/\nCase #4:\nIMPOSSIBLE"]], "limits": {"time": [10000, 10000], "memory": [1048576, 1048576]}, "tags": ["模拟", "贪心", "2016", "Special Judge", "构造", "Google Code Jam"], "title": "[GCJ 2016 #2] The Gardener of Seville", "background": "", "description": "You are the Gardener of Seville, a minor character in an opera. The setting for the opera is a courtyard which is a rectangle of unit cells, with $\\mathbf{R}$ rows and $\\mathbf{C}$ columns. You have been asked to install a maze of hedges in the courtyard: every cell must contain a hedge that runs diagonally from one corner to another. For any cell, there are two possible kinds of hedge: lower left to upper right, which we represent with /, and upper left to lower right, which we represent with $\\backslash$. Wherever two hedges touch, they form a continuous wall.\n\nAround the courtyard is an outer ring of unit cells, one cell wide, with the four corners missing. Each of these outer cells is the home of a courtier. The courtiers in these outer cells are numbered clockwise, starting with 1 for the leftmost of the cells in the top row, and ending with $2 \\times (\\mathbf{R}+\\mathbf{C})$ for the topmost cell in the left column. For example, for $\\mathbf{R}=2, \\mathbf{C}=2$, the numbering in the outer ring looks like this. (Note that no hedges have been added yet.)\n\n```\n 12 \n8  3\n7  4\n 65\n```\n\nIn this unusual opera, love is mutual and exclusive: each courtier loves exactly one other courtier, who reciprocally loves only them. Each courtier wants to be able to sneak through the hedge maze to his or her lover without encountering any other courtiers. That is, any two courtiers in love with each other must be connected by a path through the maze that is separated from every other path by hedge walls. It is fine if there are parts of the maze that are not part of any courtier's path, as long as all of the pairs of lovers are connected.\n\nGiven a list of who loves who, can you construct the hedge maze so that every pair of lovers is connected, or determine that this is IMPOSSIBLE?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each consists of one line with two integers $\\mathbf{R}$ and $\\mathbf{C}$, followed by another line with a permutation of all of the integers from 1 to $2 \\times (\\mathbf{R}+\\mathbf{C})$, inclusive. Each integer is the number of a courtier; the first and second courtiers in the list are in love and must be connected, the third and fourth courtiers in the list are in love and must be connected, and so on.\n", "outputFormat": "For each test case, output one line containing only `Case #x:`, where $\\mathrm{x}$ is the test case number (starting from 1). Then, if it is impossible to satisfy the conditions, output one more line with the text IMPOSSIBLE. Otherwise, output $\\mathbf{R}$ more lines of $\\mathbf{C}$ characters each, representing a hedge maze that satisfies the conditions, where every character is $/$ or $\\backslash$. You may not leave any cells in the maze blank. If multiple mazes are possible, you may output any one of them.", "hint": "**Sample Explanation**\n\nIn Case #3, the following pairs of courtiers are lovers: $(8, 1), (4, 5), (2, 3), (7, 6)$. Here is an illustration of our sample output:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bxa3n9a8.png)\n\nFor Case #3, note that this would also be a valid maze:\n\n```\n/\\\n\\/\n```\n\nIn Case #4, the courtyard consists of only one cell, so the courtiers living around it, starting from the top and reading clockwise, are 1, 2, 3, and 4. There are only two possible options to put in the one cell: / or \\\\. The first of these choices would form paths from 1 to 4, and from 2 to 3. The second of these choices would form paths from 1 to 2, and from 3 to 4. However, neither of these helps our lovesick courtiers, since in this case, 1 loves 3 and 2 loves 4. So this case is IMPOSSIBLE, and the opera will be full of unhappy arias!\n\n**Limits**\n\n**Small dataset (6 Pts, Test Set 1 - Visible)**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{R} \\times \\mathbf{C} \\leqslant 16$.\n\n**Large dataset (23 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 500$.\n- $1 \\leqslant \\mathbf{R} \\times \\mathbf{C} \\leqslant 100$.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2016 #2] The Gardener of Seville", "background": "", "description": "You are the Gardener of Seville, a minor character in an opera. The setting for the opera is a courtyard which is a rectangle of unit cells, with $\\mathbf{R}$ rows and $\\mathbf{C}$ columns. You have been asked to install a maze of hedges in the courtyard: every cell must contain a hedge that runs diagonally from one corner to another. For any cell, there are two possible kinds of hedge: lower left to upper right, which we represent with /, and upper left to lower right, which we represent with $\\backslash$. Wherever two hedges touch, they form a continuous wall.\n\nAround the courtyard is an outer ring of unit cells, one cell wide, with the four corners missing. Each of these outer cells is the home of a courtier. The courtiers in these outer cells are numbered clockwise, starting with 1 for the leftmost of the cells in the top row, and ending with $2 \\times (\\mathbf{R}+\\mathbf{C})$ for the topmost cell in the left column. For example, for $\\mathbf{R}=2, \\mathbf{C}=2$, the numbering in the outer ring looks like this. (Note that no hedges have been added yet.)\n\n```\n 12 \n8  3\n7  4\n 65\n```\n\nIn this unusual opera, love is mutual and exclusive: each courtier loves exactly one other courtier, who reciprocally loves only them. Each courtier wants to be able to sneak through the hedge maze to his or her lover without encountering any other courtiers. That is, any two courtiers in love with each other must be connected by a path through the maze that is separated from every other path by hedge walls. It is fine if there are parts of the maze that are not part of any courtier's path, as long as all of the pairs of lovers are connected.\n\nGiven a list of who loves who, can you construct the hedge maze so that every pair of lovers is connected, or determine that this is IMPOSSIBLE?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each consists of one line with two integers $\\mathbf{R}$ and $\\mathbf{C}$, followed by another line with a permutation of all of the integers from 1 to $2 \\times (\\mathbf{R}+\\mathbf{C})$, inclusive. Each integer is the number of a courtier; the first and second courtiers in the list are in love and must be connected, the third and fourth courtiers in the list are in love and must be connected, and so on.\n", "outputFormat": "For each test case, output one line containing only `Case #x:`, where $\\mathrm{x}$ is the test case number (starting from 1). Then, if it is impossible to satisfy the conditions, output one more line with the text IMPOSSIBLE. Otherwise, output $\\mathbf{R}$ more lines of $\\mathbf{C}$ characters each, representing a hedge maze that satisfies the conditions, where every character is $/$ or $\\backslash$. You may not leave any cells in the maze blank. If multiple mazes are possible, you may output any one of them.", "hint": "**Sample Explanation**\n\nIn Case #3, the following pairs of courtiers are lovers: $(8, 1), (4, 5), (2, 3), (7, 6)$. Here is an illustration of our sample output:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bxa3n9a8.png)\n\nFor Case #3, note that this would also be a valid maze:\n\n```\n/\\\n\\/\n```\n\nIn Case #4, the courtyard consists of only one cell, so the courtiers living around it, starting from the top and reading clockwise, are 1, 2, 3, and 4. There are only two possible options to put in the one cell: / or \\\\. The first of these choices would form paths from 1 to 4, and from 2 to 3. The second of these choices would form paths from 1 to 2, and from 3 to 4. However, neither of these helps our lovesick courtiers, since in this case, 1 loves 3 and 2 loves 4. So this case is IMPOSSIBLE, and the opera will be full of unhappy arias!\n\n**Limits**\n\n**Small dataset (6 Pts, Test Set 1 - Visible)**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{R} \\times \\mathbf{C} \\leqslant 16$.\n\n**Large dataset (23 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 500$.\n- $1 \\leqslant \\mathbf{R} \\times \\mathbf{C} \\leqslant 100$.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2016 #2] The Gardener of Seville", "background": "", "description": "你是歌剧中的一个小角色——塞维利亚的园丁。歌剧的舞台背景是一个由单位格组成的矩形庭院，共有 $\\mathbf{R}$ 行 $\\mathbf{C}$ 列。你被要求在庭院中布置一组树篱迷宫：每个格子都必须放置一根对角树篱。对于任意一个格子，有两种可能的树篱类型：从左下到右上（用 `/` 表示），或从左上到右下（用 `\\` 表示）。任何相邻的树篱相接处都会形成一堵连续的墙。\n\n庭院外围有一圈单位格，宽度为一格，四个角格子缺失。每一个外围格子里都住着一位廷臣。外围格子的编号顺时针排列，从顶行最左侧的格子编号为 1，最后一个编号为 $2 \\times (\\mathbf{R}+\\mathbf{C})$，即左列最顶端的格子。例如，当 $\\mathbf{R}=2, \\mathbf{C}=2$ 时，外围格子的编号如下（注意，此时还未放置树篱）：\n\n```\n 12 \n8  3\n7  4\n 65\n```\n\n\n在这个与众不同的歌剧中，爱情是互相且唯一的：每位廷臣只爱一位其他廷臣，且这份爱是双向且专属的。每位廷臣都希望能穿越树篱迷宫，悄悄地与心上人相会，并且不被其他廷臣遇见。也就是说，任意一对恋人廷臣之间，必须存在一条只属于他们两人的、被树篱墙与其他路径完全隔开的通路。迷宫中可以存在不属于任何廷臣路径的部分，只要所有恋人对都能连通即可。\n\n给定所有恋人配对关系，你能否构造出这样一组树篱迷宫，使得每一对恋人都能连通？如无法实现，请输出 IMPOSSIBLE。\n", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例组数。接下来有 $\\mathbf{T}$ 组测试用例，每组包含两行。第一行为两个整数 $\\mathbf{R}$ 和 $\\mathbf{C}$，表示庭院的行数和列数。第二行为一个长度为 $2 \\times (\\mathbf{R}+\\mathbf{C})$ 的排列，包含所有廷臣的编号。第 1、2 个编号为一对恋人，第 3、4 个编号为一对恋人，以此类推。\n", "outputFormat": "对于每组测试用例，先输出一行 `Case #x:`，其中 $x$ 为测试用例编号（从 1 开始）。如果无法满足条件，再输出一行 IMPOSSIBLE。否则，输出 $\\mathbf{R}$ 行，每行 $\\mathbf{C}$ 个字符，表示一个合法的树篱迷宫，每个字符为 `/` 或 `\\`。迷宫中的每个格子都必须填满，不能留空。若存在多种方案，你可任选其一输出。\n", "hint": "**样例解释**\n\n在第 3 组中，恋人配对为 $(8, 1), (4, 5), (2, 3), (7, 6)$。如下是样例输出的示意图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bxa3n9a8.png)\n\n对于第 3 组，下面这种迷宫也是合法的：\n\n```\n/\\\n\\/\n```\n\n\n在第 4 组中，庭院仅有一个格子，外围廷臣编号按顺时针分别为 1、2、3、4。此时只有两种放置方式：/ 或 \\。第一种会形成 1 到 4、2 到 3 的通路，第二种会形成 1 到 2、3 到 4 的通路。但本组数据中 1 爱 3、2 爱 4，无论哪种方式都无法满足条件，因此输出 IMPOSSIBLE，歌剧中将充满悲伤的咏叹调！\n\n**限制条件**\n\n**小数据集（6 分，测试集 1 - 可见）**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$。\n- $1 \\leqslant \\mathbf{R} \\times \\mathbf{C} \\leqslant 16$。\n\n**大数据集（23 分，测试集 2 - 隐藏）**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 500$。\n- $1 \\leqslant \\mathbf{R} \\times \\mathbf{C} \\leqslant 100$。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13201", "type": "P", "difficulty": 6, "samples": [["5\n2\n11\n10\n2\n10\n00\n3\n000\n000\n000\n1\n1\n3\n000\n110\n000", "Case #1: 1\nCase #2: 1\nCase #3: 3\nCase #4: 0\nCase #5: 3"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "图论", "2016", "二分图", "Google Code Jam"], "title": "[GCJ 2016 #2] Freeform Factory", "background": "", "description": "You have just built a brand new factory. Your factory has $\\mathbf{N}$ different machines, and each machine needs to be operated by exactly one worker for the factory to function well.\n\nYou have also hired $\\mathbf{N}$ workers to operate those machines. Since you were in a hurry when you hired them, you did not check whether they actually know how to operate your machines. Now you have finally asked them, and so you have the information on whether the i-th worker can operate the j-th machine, for each i and j.\n\nIn a typical working day, the workers will arrive at the factory in a random order, which can be different each day. As each worker arrives, they will find all machines that they know how to operate and that do not already have an operator. They will choose one of those at random and operate it for the whole working day. If all machines they know how to operate already have an operator, they will not work that day. Your goal is to make sure that all machines are being operated each working day, regardless of what order the workers arrive in and which machines they choose.\n\nFor example, suppose there are two workers $\\mathrm{A}$ and $\\mathrm{B}$, and two machines 1 and 2. Suppose that $\\mathrm{A}$ knows how to operate 1 and 2, and $\\mathrm{B}$ knows how to operate 1 but not 2. If worker $\\mathrm{B}$ arrives first, he will pick machine 1, then when worker $\\mathrm{A}$ arrives she will have to choose 2, and the factory will work well. However, if worker $\\mathrm{A}$ arrives first, it might happen that she chooses to operate 1 on that day, and then when worker $\\mathrm{B}$ arrives he does not have anything to do, leaving machine 2 without an operator, and causing your factory to waste a whole day!\n\nAs another example, suppose there are two workers $\\mathrm{A}$ and $\\mathrm{B}$, and two machines 1 and 2, and that $\\mathrm{A}$ knows how to operate 1 but not 2, and $\\mathrm{B}$ does not know how to operate anything. Then, regardless of the order in which the workers arrive, the factory will not be able to function well.\n\nBefore you open your factory, in order to guarantee that the factory will constantly function well, you can teach your workers how to operate machines. It costs one dollar to give a single worker a lesson on how to operate a single machine. Each lesson involves only one worker and only one machine, but you can teach any number of lessons to any number of workers, and the same worker can receive multiple lessons. You cannot make a worker forget how to operate a machine if they already know how to operate it.\n\nFor example, both examples above can be fixed by teaching worker $\\mathrm{B}$ to operate machine 2. In that case each machine is guaranteed to have an operator every day, regardless of which order the workers arrive in and which machines they choose to operate when they have more than one possibility.\n\nWhat is the minimum amount of dollars you need to spend on training workers to make sure the factory functions well every day?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with one line with an integer $\\mathbf{N}$, the number of workers (and machines). This line is followed by $\\mathbf{N}$ lines with a string of $\\mathbf{N}$ characters each. The $\\mathrm{j}$-th character on the i-th of those lines is 1 if the i-th worker knows how to operate the $\\mathrm{j}$-th machine, and 0 otherwise.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathrm{x}$ is the test case number (starting from 1), and $\\mathrm{y}$ is a non-negative integer: the minimum amount of dollars you need to spend to make sure that all $\\mathbf{N}$ machines will always have an operator.", "hint": "**Sample Explanation**\n\nSample cases #1 and #2 are the ones described in the problem statement.\n\nIn sample case #3, nobody knows how to do anything! One optimal strategy is to teach worker A to operate machine 1, worker B to operate machine 2, and worker C to operate machine 3.\n\nIn sample case #4, no action is necessary. There is only one worker, and the worker already knows how to operate the one machine.\n\nIn sample case #5, worker B already knows how to operate machines 1 and 2. One optimal strategy is to teach worker A to operate machine 3, and make A the only worker who can operate that machine. But now we have to consider that B might operate either machine 1 or 2 upon arrival, so C needs to be able to operate the one not chosen by B. So C must be taught to operate both 1 and 2.\n\n**Sample Explantion**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n\n**Small dataset (6 Pts, Test Set 1 - Visible)**\n\n- $1 \\leqslant \\mathbf{N} \\leqslant 4$.\n\n**Large dataset (25 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leqslant \\mathbf{N} \\leqslant 25$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2016 #2] Freeform Factory", "background": "", "description": "You have just built a brand new factory. Your factory has $\\mathbf{N}$ different machines, and each machine needs to be operated by exactly one worker for the factory to function well.\n\nYou have also hired $\\mathbf{N}$ workers to operate those machines. Since you were in a hurry when you hired them, you did not check whether they actually know how to operate your machines. Now you have finally asked them, and so you have the information on whether the i-th worker can operate the j-th machine, for each i and j.\n\nIn a typical working day, the workers will arrive at the factory in a random order, which can be different each day. As each worker arrives, they will find all machines that they know how to operate and that do not already have an operator. They will choose one of those at random and operate it for the whole working day. If all machines they know how to operate already have an operator, they will not work that day. Your goal is to make sure that all machines are being operated each working day, regardless of what order the workers arrive in and which machines they choose.\n\nFor example, suppose there are two workers $\\mathrm{A}$ and $\\mathrm{B}$, and two machines 1 and 2. Suppose that $\\mathrm{A}$ knows how to operate 1 and 2, and $\\mathrm{B}$ knows how to operate 1 but not 2. If worker $\\mathrm{B}$ arrives first, he will pick machine 1, then when worker $\\mathrm{A}$ arrives she will have to choose 2, and the factory will work well. However, if worker $\\mathrm{A}$ arrives first, it might happen that she chooses to operate 1 on that day, and then when worker $\\mathrm{B}$ arrives he does not have anything to do, leaving machine 2 without an operator, and causing your factory to waste a whole day!\n\nAs another example, suppose there are two workers $\\mathrm{A}$ and $\\mathrm{B}$, and two machines 1 and 2, and that $\\mathrm{A}$ knows how to operate 1 but not 2, and $\\mathrm{B}$ does not know how to operate anything. Then, regardless of the order in which the workers arrive, the factory will not be able to function well.\n\nBefore you open your factory, in order to guarantee that the factory will constantly function well, you can teach your workers how to operate machines. It costs one dollar to give a single worker a lesson on how to operate a single machine. Each lesson involves only one worker and only one machine, but you can teach any number of lessons to any number of workers, and the same worker can receive multiple lessons. You cannot make a worker forget how to operate a machine if they already know how to operate it.\n\nFor example, both examples above can be fixed by teaching worker $\\mathrm{B}$ to operate machine 2. In that case each machine is guaranteed to have an operator every day, regardless of which order the workers arrive in and which machines they choose to operate when they have more than one possibility.\n\nWhat is the minimum amount of dollars you need to spend on training workers to make sure the factory functions well every day?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with one line with an integer $\\mathbf{N}$, the number of workers (and machines). This line is followed by $\\mathbf{N}$ lines with a string of $\\mathbf{N}$ characters each. The $\\mathrm{j}$-th character on the i-th of those lines is 1 if the i-th worker knows how to operate the $\\mathrm{j}$-th machine, and 0 otherwise.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathrm{x}$ is the test case number (starting from 1), and $\\mathrm{y}$ is a non-negative integer: the minimum amount of dollars you need to spend to make sure that all $\\mathbf{N}$ machines will always have an operator.", "hint": "**Sample Explanation**\n\nSample cases #1 and #2 are the ones described in the problem statement.\n\nIn sample case #3, nobody knows how to do anything! One optimal strategy is to teach worker A to operate machine 1, worker B to operate machine 2, and worker C to operate machine 3.\n\nIn sample case #4, no action is necessary. There is only one worker, and the worker already knows how to operate the one machine.\n\nIn sample case #5, worker B already knows how to operate machines 1 and 2. One optimal strategy is to teach worker A to operate machine 3, and make A the only worker who can operate that machine. But now we have to consider that B might operate either machine 1 or 2 upon arrival, so C needs to be able to operate the one not chosen by B. So C must be taught to operate both 1 and 2.\n\n**Sample Explantion**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n\n**Small dataset (6 Pts, Test Set 1 - Visible)**\n\n- $1 \\leqslant \\mathbf{N} \\leqslant 4$.\n\n**Large dataset (25 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leqslant \\mathbf{N} \\leqslant 25$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2016 #2] Freeform Factory", "background": "", "description": "你刚刚建成了一家全新的工厂。你的工厂有 $\\mathbf{N}$ 台不同的机器，并且每台机器都需要恰好一名工人来操作，才能保证工厂正常运转。\n\n你也雇佣了 $\\mathbf{N}$ 名工人来操作这些机器。由于你招聘时很匆忙，并没有核查他们是否真的会操作你的机器。现在你终于询问了每个人，得知对于每个 $i$ 和 $j$，第 $i$ 个工人是否会操作第 $j$ 台机器的信息。\n\n在一个典型的工作日，工人们会以随机顺序到达工厂，每天的顺序可能不同。每当一名工人到达时，他会查看所有自己会操作且尚未被占用的机器，并从中随机选择一台，全天进行操作。如果他会操作的所有机器都已被占用，那么当天他就不会工作。你的目标是，无论工人到达的顺序和他们在有多种选择时的选择如何，都能保证每天所有机器都有人操作。\n\n举个例子，假设有两名工人 $\\mathrm{A}$ 和 $\\mathrm{B}$，以及两台机器 1 和 2。假设 $\\mathrm{A}$ 会操作 1 号和 2 号机器，$\\mathrm{B}$ 只会操作 1 号机器。如果 $\\mathrm{B}$ 先到，他会选 1 号机器，$\\mathrm{A}$ 到时只能选 2 号，这样工厂能正常运转。但如果 $\\mathrm{A}$ 先到，她可能选择 1 号机器，这时 $\\mathrm{B}$ 就没法工作，2 号机器没人操作，导致工厂当天无法正常运转！\n\n再比如，假设仍有两名工人 $\\mathrm{A}$ 和 $\\mathrm{B}$，两台机器 1 和 2，且 $\\mathrm{A}$ 只会操作 1 号机器，$\\mathrm{B}$ 什么都不会操作。无论工人到达顺序如何，工厂都无法正常运转。\n\n在工厂开业前，为了保证工厂永远都能正常运转，你可以培训工人学会操作新机器。给一名工人培训一台机器的费用为 1 美元。每次培训只涉及一名工人和一台机器，但你可以给任意多名工人、任意多台机器进行培训，同一名工人可以接受多次培训。如果某名工人已经会操作某台机器，你不能让他忘掉。\n\n例如，上述两个例子都可以通过教 $\\mathrm{B}$ 操作 2 号机器来解决。这样无论到达顺序和选择如何，每台机器都能保证有人操作。\n\n请问，为了保证每天工厂都能正常运转，你最少需要花多少钱培训工人？", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例数量。接下来有 $\\mathbf{T}$ 组测试用例。每组数据的第一行为一个整数 $\\mathbf{N}$，表示工人（和机器）数量。之后有 $\\mathbf{N}$ 行，每行是一个长度为 $\\mathbf{N}$ 的字符串，第 $i$ 行第 $j$ 个字符为 1 表示第 $i$ 个工人会操作第 $j$ 台机器，为 0 表示不会。\n", "outputFormat": "对于每组测试用例，输出一行 `Case #x: y`，其中 $\\mathrm{x}$ 为测试用例编号（从 1 开始），$\\mathrm{y}$ 为保证所有 $\\mathbf{N}$ 台机器始终有人操作所需的最小培训费用。\n", "hint": "**样例解释**\n\n样例第 1 组和第 2 组即为题面中的示例。\n\n在第 3 组中，没有人会操作任何机器！一种最优方案是教 $\\mathrm{A}$ 操作 1 号机器，$\\mathrm{B}$ 操作 2 号机器，$\\mathrm{C}$ 操作 3 号机器。\n\n第 4 组无需任何操作。只有一名工人，他已经会操作唯一的那台机器。\n\n第 5 组中，$\\mathrm{B}$ 已会操作 1 号和 2 号机器。一种最优方案是教 $\\mathrm{A}$ 操作 3 号机器，并让 $\\mathrm{A}$ 成为唯一能操作该机器的人。但此时必须考虑 $\\mathrm{B}$ 可能会选择 1 号或 2 号机器，因此 $\\mathrm{C}$ 还需要学会操作剩下的那一台。所以 $\\mathrm{C}$ 必须被教会操作 1 号和 2 号机器。\n\n**限制条件**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$。\n\n**小数据集（6 分，测试集 1 - 可见）**\n\n- $1 \\leqslant \\mathbf{N} \\leqslant 4$。\n\n**大数据集（25 分，测试集 2 - 隐藏）**\n\n- $1 \\leqslant \\mathbf{N} \\leqslant 25$。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13202", "type": "P", "difficulty": 3, "samples": [["5\nCCJJ\nCJCJ\nCJJC\nCJJJ\nCCCCCC", "Case #1: 20\nCase #2: 10\nCase #3: 20\nCase #4: 15\nCase #5: 30"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2016", "Google Code Jam"], "title": "[GCJ 2016 #3] Teaching Assistant", "background": "", "description": "You are taking a programming course which is graded using problem sets of different types. The course goes for a positive even number of days. You start the course with no problem sets. On each day of the course, you must do exactly one of the following:\n\n* Request a \"Coding\" problem set.\n* Request a \"Jamming\" problem set.\n* Submit a problem set for grading. You must have at least one problem set to choose this option. If you have multiple problem sets, you must submit the one among those that was requested **most recently**, regardless of its type.\n\nAll problem sets are different. There is no requirement on how many sets of each type must be submitted. Once you submit a set, you no longer have that set. Any problem sets that you have not submitted before the end of the course get you no points.\n\nThe problem sets are requested from and submitted to an artificially-intelligent teaching assistant. Strangely, the assistant has different moods — on each day it is in the mood for either \"Coding\" or \"Jamming\".\n\n* When you request a problem set:\n    * If the requested topic matches the assistant's mood, it assigns a problem set worth a maximum of 10 points.\n    * If the requested topic does not match its mood, it assigns a problem set worth a maximum of 5 points.\n* When you submit a problem set:\n    * If the topic of the submitted set matches the assistant's mood that day, it gives you the maximum number of points for that set.\n    * If the topic of the submitted set does not match its mood that day, it gives you 5 points fewer than the maximum number of points for that set.\n\nFor example:\n\n* If you request a \"Coding\" problem set on a day in which the assistant is in a \"Coding\" mood, and submit it on a day in which it is in a \"Jamming\" mood, you will earn 5 points: the problem set is worth a maximum of 10, but the assistant gives 5 points fewer than that.\n* If you request a \"Jamming\" problem set on a day in which the assistant is in a \"Coding\" mood, and submit it on a day in which it is in a \"Jamming\" mood, you will earn 5 points: the set is worth a maximum of 5, and the assistant gives you the maximum number of points.\n\nThanks to some help from a senior colleague who understands the assistant very well, you know what sort of mood the assistant will be in on each day of the course. What is the maximum total score that you will be able to obtain?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$; $\\mathbf{T}$ test cases follow. Each test case consists of one line with a string $\\mathbf{S}$ of $\\mathbf{C}$ and/or $\\mathbf{J}$ characters. The i-th character of $\\mathbf{S}$ denotes the assistant's mood on the i-th day of the course. If it is $\\mathbf{C}$, it is in the mood for \"Coding\"; if it is $\\mathbf{J}$, it is in the mood for \"Jamming\".\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the maximum number of points you can obtain for that case.", "hint": "**Sample Explanation**\n\nThis strategy is optimal for sample case #1:\n- Day 1: Request a \"Coding\" problem set (call it C1).\n- Day 2: Submit C1.\n- Day 3: Request a \"Jamming\" problem set (call it J1).\n- Day 4: Submit J1.\n\nThe following strategy is optimal for sample cases #2, #3, and #4: request C1, request J1, submit J1, submit C1.\n\nFor case #2, for example, note that you could not request C1, request J1, and then submit C1. Only the most recently requested problem set can be submitted.\n\nIn sample case #5, you can alternate between requesting a \"Coding\" problem set on one day, and submitting it on the next day.\n\n**Sample Explanation**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- The length of $\\mathbf{S}$ is even.\n\n**Small dataset (5 Pts, Test Set 1 - Visible)**\n\n- $2 \\leqslant$ the length of $\\mathbf{S} \\leqslant 50$.\n\n**Large dataset (10 Pts, Test Set 2 - Hidden)**\n\n- $2 \\leqslant$ the length of $\\mathbf{S} \\leqslant 20000$.\n- The sum of lengths of all $\\mathbf{S}$ in the dataset is at most 150000.", "locale": "en", "translations": {"en": {"title": "[GCJ 2016 #3] Teaching Assistant", "background": "", "description": "You are taking a programming course which is graded using problem sets of different types. The course goes for a positive even number of days. You start the course with no problem sets. On each day of the course, you must do exactly one of the following:\n\n* Request a \"Coding\" problem set.\n* Request a \"Jamming\" problem set.\n* Submit a problem set for grading. You must have at least one problem set to choose this option. If you have multiple problem sets, you must submit the one among those that was requested **most recently**, regardless of its type.\n\nAll problem sets are different. There is no requirement on how many sets of each type must be submitted. Once you submit a set, you no longer have that set. Any problem sets that you have not submitted before the end of the course get you no points.\n\nThe problem sets are requested from and submitted to an artificially-intelligent teaching assistant. Strangely, the assistant has different moods — on each day it is in the mood for either \"Coding\" or \"Jamming\".\n\n* When you request a problem set:\n    * If the requested topic matches the assistant's mood, it assigns a problem set worth a maximum of 10 points.\n    * If the requested topic does not match its mood, it assigns a problem set worth a maximum of 5 points.\n* When you submit a problem set:\n    * If the topic of the submitted set matches the assistant's mood that day, it gives you the maximum number of points for that set.\n    * If the topic of the submitted set does not match its mood that day, it gives you 5 points fewer than the maximum number of points for that set.\n\nFor example:\n\n* If you request a \"Coding\" problem set on a day in which the assistant is in a \"Coding\" mood, and submit it on a day in which it is in a \"Jamming\" mood, you will earn 5 points: the problem set is worth a maximum of 10, but the assistant gives 5 points fewer than that.\n* If you request a \"Jamming\" problem set on a day in which the assistant is in a \"Coding\" mood, and submit it on a day in which it is in a \"Jamming\" mood, you will earn 5 points: the set is worth a maximum of 5, and the assistant gives you the maximum number of points.\n\nThanks to some help from a senior colleague who understands the assistant very well, you know what sort of mood the assistant will be in on each day of the course. What is the maximum total score that you will be able to obtain?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$; $\\mathbf{T}$ test cases follow. Each test case consists of one line with a string $\\mathbf{S}$ of $\\mathbf{C}$ and/or $\\mathbf{J}$ characters. The i-th character of $\\mathbf{S}$ denotes the assistant's mood on the i-th day of the course. If it is $\\mathbf{C}$, it is in the mood for \"Coding\"; if it is $\\mathbf{J}$, it is in the mood for \"Jamming\".\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the maximum number of points you can obtain for that case.", "hint": "**Sample Explanation**\n\nThis strategy is optimal for sample case #1:\n- Day 1: Request a \"Coding\" problem set (call it C1).\n- Day 2: Submit C1.\n- Day 3: Request a \"Jamming\" problem set (call it J1).\n- Day 4: Submit J1.\n\nThe following strategy is optimal for sample cases #2, #3, and #4: request C1, request J1, submit J1, submit C1.\n\nFor case #2, for example, note that you could not request C1, request J1, and then submit C1. Only the most recently requested problem set can be submitted.\n\nIn sample case #5, you can alternate between requesting a \"Coding\" problem set on one day, and submitting it on the next day.\n\n**Sample Explanation**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- The length of $\\mathbf{S}$ is even.\n\n**Small dataset (5 Pts, Test Set 1 - Visible)**\n\n- $2 \\leqslant$ the length of $\\mathbf{S} \\leqslant 50$.\n\n**Large dataset (10 Pts, Test Set 2 - Hidden)**\n\n- $2 \\leqslant$ the length of $\\mathbf{S} \\leqslant 20000$.\n- The sum of lengths of all $\\mathbf{S}$ in the dataset is at most 150000.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2016 #3] Teaching Assistant", "background": "", "description": "你正在上一门以题集为评分方式的编程课程。课程持续天数为正偶数天。你开始时没有任何题集。在课程的每一天，你必须执行以下三种操作之一：\n\n* 申请一个“编程（Coding）”题集；\n* 申请一个“Jamming”题集；\n* 提交一个题集进行评分。你必须至少拥有一个题集才能选择此操作。如果你有多个题集，必须提交**最近申请的那一个**，无论其类型如何。\n\n所有题集都是不同的。对提交题集的类型和数量没有要求。一旦你提交了某个题集，你就不再拥有该题集。任何在课程结束前未提交的题集都不会获得分数。\n\n题集的申请和提交都通过一个人工智能助教完成。奇怪的是，助教每天都有不同的心情——每一天只会喜欢“Coding”或“Jamming”中的一种。\n\n* 当你申请题集时：\n   * 如果申请的题集类型与助教当天的心情一致，则该题集最高可得 10 分。\n   * 如果申请的题集类型与助教当天的心情不一致，则该题集最高可得 5 分。\n* 当你提交题集时：\n   * 如果提交的题集类型与助教当天的心情一致，则你能获得该题集的最高分。\n   * 如果提交的题集类型与助教当天的心情不一致，则你获得的分数比最高分少 5 分。\n\n例如：\n\n* 如果你在助教心情为“Coding”的那天申请了一个“Coding”题集，并在助教心情为“Jamming”的那天提交，则你能获得 5 分：该题集最高分为 10 分，但助教会少给 5 分。\n* 如果你在助教心情为“Coding”的那天申请了一个“Jamming”题集，并在助教心情为“Jamming”的那天提交，则你能获得 5 分：该题集最高分为 5 分，助教会给你最高分。\n\n幸运的是，你有一位非常了解助教的师兄，他告诉了你课程每一天助教的心情。请问你最多能获得多少分？", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例数量。接下来有 $\\mathbf{T}$ 组测试用例，每组一行，包含一个由 $\\mathbf{C}$ 和/或 $\\mathbf{J}$ 组成的字符串 $\\mathbf{S}$。第 $i$ 个字符表示课程第 $i$ 天助教的心情，$\\mathbf{C}$ 表示“Coding”，$\\mathbf{J}$ 表示“Jamming”。\n", "outputFormat": "对于每组测试用例，输出一行 `Case #x: y`，其中 $\\mathrm{x}$ 为测试用例编号（从 1 开始），$\\mathrm{y}$ 表示你在该组测试用例下能获得的最高分。\n", "hint": "**样例解释**\n\n对于样例第 1 组，最优策略如下：\n- 第 1 天：申请“Coding”题集（记为 C1）。\n- 第 2 天：提交 C1。\n- 第 3 天：申请“Jamming”题集（记为 J1）。\n- 第 4 天：提交 J1。\n\n对于样例第 2、3、4 组，最优策略为：先申请 C1，再申请 J1，然后提交 J1，最后提交 C1。\n\n以第 2 组为例，注意你不能先申请 C1，再申请 J1，然后提交 C1。因为每次只能提交最近申请的题集。\n\n对于第 5 组，你可以每隔一天申请一个“Coding”题集，下一天就提交它。\n\n**限制条件**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$。\n- $\\mathbf{S}$ 的长度为偶数。\n\n**小数据集（5 分，测试集 1 - 可见）**\n\n- $2 \\leqslant \\mathbf{S}$ 的长度 $\\leqslant 50$。\n\n**大数据集（10 分，测试集 2 - 隐藏）**\n\n- $2 \\leqslant \\mathbf{S}$ 的长度 $\\leqslant 20000$。\n- 所有测试用例的 $\\mathbf{S}$ 总长度不超过 150000。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13203", "type": "P", "difficulty": 5, "samples": [["2\n2\n0 1\nCJ\n4\nCJ C D JC\n3\n0 1 0\nBAA\n3\nAA AAB ABA", "Case #1: 1.0 1.0 0.0 0.0\nCase #2: 0.67 0.0 0.33"]], "limits": {"time": [75000], "memory": [1048576]}, "tags": ["图论", "2016", "Special Judge", "图论建模", "概率论", "随机化", "Google Code Jam"], "title": "[GCJ 2016 #3] Forest University", "background": "", "description": "The Forest University offers its students $\\mathbf{N}$ courses, which must all be taken to obtain the degree. The courses can only be taken one at a time - you must complete a course before starting another. Each course is either basic, which means one can take it without any prior knowledge, or advanced, in which case exactly one other course is its prerequisite.\n\nA student must take the prerequisite for a course before taking the course, although they do not need to be taken immediately one after the other. A course might be the prerequisite for multiple other courses. There are no prerequisite cycles. Any sequence of the $\\mathbf{N}$ courses that meets the rules for prerequisites is valid for obtaining the degree.\n\nWhen you graduate, the university commemorates the sequence of courses you have taken by printing an abbreviated version of it on your graduation hat. More precisely, this abbreviated version is a string consisting of the first letter of the name of each course you have taken, in the order you have taken them. For example, if you have taken a Coding course and a Jamming course, in that order, your graduation hat will say `CJ`. It is considered trendy to have certain cool words as a substring of the string on one's graduation hat.\n\nConsider all possible valid sequences in which the courses can be taken. For each cool word, you need to find the fraction of those sequences that have the cool word as a substring (at least once) of the string on the corresponding graduation hat. Note that we're interested in the fraction of possible course sequences, not the fraction of possible different graduation hat strings. (Since multiple courses may start with the same letter, there may be fewer possible strings than course sequences.)\n\nSomewhat unusually for Code Jam, we are only looking for an approximate answer to this problem; pay careful attention to the output format.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of five lines, in this order, which contain the following:\n\n1. the number $\\mathbf{N}$ of courses.\n2. $\\mathbf{N}$ integers; the i-th of these integers gives the number of the prerequisite course for the i-th course, or 0 if the i-th course is basic. The courses are numbered from 1 to $\\mathbf{N}$.\n3. $\\mathbf{N}$ uppercase English letters (without whitespace in between), with the i-th character giving the first letter of the i-th course's name.\n4. the number $\\mathbf{M}$ of cool words.\n5. $\\mathbf{M}$ cool words, each of which consists only of uppercase English letters.", "outputFormat": "For each test case, output one line containing Case #x: $y_{1}$ $y_{2}$ $\\ldots$ $y_{\\mathbf{M}}$, where $\\mathrm{x}$ is the test case number (starting from 1) and $y_{\\mathrm{i}}$ is the fraction of valid course sequences that will have the i-th cool word as a substring of the string on the graduation hat.\n\n$y_{\\mathrm{i}}$ will be considered correct if it is within an absolute error of 0.03 of the correct answer. See the FAQ for an explanation of what that means, and what formats of real numbers we accept.", "hint": "**Sample Explanation**\n\nThe sample output displays one set of acceptable answers to the sample cases. Other answers are possible within the allowed precision.\n\nIn sample case #1, course 1 (C) is a basic course that is a prerequisite for the advanced course 2 (J). The only way to complete the courses is to take course 1 and then course 2. This creates the string CJ. So the cool words CJ, C, D, and JC are present as substrings in 1, 1, 0, and 0 out of 1 possible cases, respectively.\n\nIn sample case #2, the basic course 1 (B) is a prerequisite for the advanced course 2 (A), and course 3 (A) is another basic course. There are three possible ways of completing the courses:\n\n1. take course 1, then course 2, then course 3 (string: BAA)\n2. take course 1, then course 3, then course 2 (string: BAA)\n3. take course 3, then course 1, then course 2 (string: ABA)\n\nThe cool words AA, AAB, and ABA are present as substrings in 2, 0, and 1 out of 3 possible cases, respectively.\n\n**Limits**\n\n**Small dataset (25 Pts, Test Set 1 - Visible)**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{N} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{M} \\leqslant 5$.\n- The length of each cool word is between 1 and 20.\n- Each cool word consists of uppercase English letters only.\n- There are no cycles formed by the prerequisites.", "locale": "en", "translations": {"en": {"title": "[GCJ 2016 #3] Forest University", "background": "", "description": "The Forest University offers its students $\\mathbf{N}$ courses, which must all be taken to obtain the degree. The courses can only be taken one at a time - you must complete a course before starting another. Each course is either basic, which means one can take it without any prior knowledge, or advanced, in which case exactly one other course is its prerequisite.\n\nA student must take the prerequisite for a course before taking the course, although they do not need to be taken immediately one after the other. A course might be the prerequisite for multiple other courses. There are no prerequisite cycles. Any sequence of the $\\mathbf{N}$ courses that meets the rules for prerequisites is valid for obtaining the degree.\n\nWhen you graduate, the university commemorates the sequence of courses you have taken by printing an abbreviated version of it on your graduation hat. More precisely, this abbreviated version is a string consisting of the first letter of the name of each course you have taken, in the order you have taken them. For example, if you have taken a Coding course and a Jamming course, in that order, your graduation hat will say `CJ`. It is considered trendy to have certain cool words as a substring of the string on one's graduation hat.\n\nConsider all possible valid sequences in which the courses can be taken. For each cool word, you need to find the fraction of those sequences that have the cool word as a substring (at least once) of the string on the corresponding graduation hat. Note that we're interested in the fraction of possible course sequences, not the fraction of possible different graduation hat strings. (Since multiple courses may start with the same letter, there may be fewer possible strings than course sequences.)\n\nSomewhat unusually for Code Jam, we are only looking for an approximate answer to this problem; pay careful attention to the output format.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of five lines, in this order, which contain the following:\n\n1. the number $\\mathbf{N}$ of courses.\n2. $\\mathbf{N}$ integers; the i-th of these integers gives the number of the prerequisite course for the i-th course, or 0 if the i-th course is basic. The courses are numbered from 1 to $\\mathbf{N}$.\n3. $\\mathbf{N}$ uppercase English letters (without whitespace in between), with the i-th character giving the first letter of the i-th course's name.\n4. the number $\\mathbf{M}$ of cool words.\n5. $\\mathbf{M}$ cool words, each of which consists only of uppercase English letters.", "outputFormat": "For each test case, output one line containing Case #x: $y_{1}$ $y_{2}$ $\\ldots$ $y_{\\mathbf{M}}$, where $\\mathrm{x}$ is the test case number (starting from 1) and $y_{\\mathrm{i}}$ is the fraction of valid course sequences that will have the i-th cool word as a substring of the string on the graduation hat.\n\n$y_{\\mathrm{i}}$ will be considered correct if it is within an absolute error of 0.03 of the correct answer. See the FAQ for an explanation of what that means, and what formats of real numbers we accept.", "hint": "**Sample Explanation**\n\nThe sample output displays one set of acceptable answers to the sample cases. Other answers are possible within the allowed precision.\n\nIn sample case #1, course 1 (C) is a basic course that is a prerequisite for the advanced course 2 (J). The only way to complete the courses is to take course 1 and then course 2. This creates the string CJ. So the cool words CJ, C, D, and JC are present as substrings in 1, 1, 0, and 0 out of 1 possible cases, respectively.\n\nIn sample case #2, the basic course 1 (B) is a prerequisite for the advanced course 2 (A), and course 3 (A) is another basic course. There are three possible ways of completing the courses:\n\n1. take course 1, then course 2, then course 3 (string: BAA)\n2. take course 1, then course 3, then course 2 (string: BAA)\n3. take course 3, then course 1, then course 2 (string: ABA)\n\nThe cool words AA, AAB, and ABA are present as substrings in 2, 0, and 1 out of 3 possible cases, respectively.\n\n**Limits**\n\n**Small dataset (25 Pts, Test Set 1 - Visible)**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{N} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{M} \\leqslant 5$.\n- The length of each cool word is between 1 and 20.\n- Each cool word consists of uppercase English letters only.\n- There are no cycles formed by the prerequisites.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2016 #3] Forest University", "background": "", "description": "森林大学为学生开设了 $\\mathbf{N}$ 门课程，想要获得学位，必须修完所有课程。课程只能一次上一门——你必须完成一门课程后才能开始另一门。每门课程要么是基础课程（即无任何先修要求），要么是进阶课程（此时恰好有一门其他课程作为它的先修课程）。\n\n学生必须在修读某门课程前先修完其先修课程，虽然这两门课不必连续修读。一门课程可以是多门其他课程的先修课程。不存在先修关系的环路。任意一种满足先修关系的 $\\mathbf{N}$ 门课程修读顺序，都是有效的毕业方案。\n\n当你毕业时，学校会在你的毕业帽上印上你修读课程顺序的缩写。具体来说，这个缩写是一个字符串，按你修课顺序依次取每门课程名称的首字母。例如，如果你先修了 Coding 课，再修 Jamming 课，你的毕业帽上会写 `CJ`。有些“炫酷单词”作为毕业帽字符串的子串被认为很时髦。\n\n请考虑所有满足先修关系的有效修课顺序。对于每个炫酷单词，你需要计算有多少比例的修课顺序，其毕业帽字符串包含该炫酷单词（至少一次）作为子串。注意，我们关注的是修课顺序的比例，而不是不同毕业帽字符串的比例。（因为多门课程可能首字母相同，实际可能的字符串种类比修课顺序种类少。）\n\n这道题与 Code Jam 常规题目不同，只需给出近似答案；请特别注意输出格式。", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例组数。接下来有 $\\mathbf{T}$ 组测试用例，每组包含以下五行：\n\n1. 一个整数 $\\mathbf{N}$，表示课程数。\n2. $\\mathbf{N}$ 个整数，第 $i$ 个数表示第 $i$ 门课程的先修课程编号，若为 0 则表示该课程为基础课程。课程编号为 1 到 $\\mathbf{N}$。\n3. $\\mathbf{N}$ 个大写英文字母（中间无空格），第 $i$ 个字母为第 $i$ 门课程名称的首字母。\n4. 一个整数 $\\mathbf{M}$，表示炫酷单词的数量。\n5. $\\mathbf{M}$ 个炫酷单词，每个由大写英文字母组成。", "outputFormat": "对于每组测试用例，输出一行 `Case #x: $y_1$ $y_2$ ... $y_{\\mathbf{M}}$`，其中 $\\mathrm{x}$ 是测试用例编号（从 1 开始），$y_i$ 表示第 $i$ 个炫酷单词作为子串出现在毕业帽字符串中的有效修课顺序比例。\n\n若 $y_i$ 与正确答案的绝对误差不超过 0.03，即视为正确。详见 FAQ 关于什么格式的实数是可接受的说明。\n", "hint": "**样例解释**\n\n样例输出展示了一组可接受答案，其他答案只要精度满足要求也可以。\n\n在样例第 1 组中，课程 1（C）为基础课，是课程 2（J）的先修课。唯一的修课顺序是先修 1 再修 2，毕业帽字符串为 CJ。所以炫酷单词 CJ、C、D、JC 分别在 1、1、0、0 个有效顺序中出现，比例分别为 1、1、0、0。\n\n在样例第 2 组中，基础课 1（B）是进阶课 2（A）的先修课，课程 3（A）也是基础课。共有三种修课顺序：\n\n1. 先修 1，再修 2，再修 3（字符串：BAA）\n2. 先修 1，再修 3，再修 2（字符串：BAA）\n3. 先修 3，再修 1，再修 2（字符串：ABA）\n\n炫酷单词 AA、AAB、ABA 分别在 2、0、1 个有效顺序中出现，比例分别为 2/3、0、1/3。\n\n**限制条件**\n\n**小数据集（25 分，测试集 1 - 可见）**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$。\n- $1 \\leqslant \\mathbf{N} \\leqslant 100$。\n- $1 \\leqslant \\mathbf{M} \\leqslant 5$。\n- 每个炫酷单词长度 $1 \\leqslant \\text{len} \\leqslant 20$。\n- 每个炫酷单词只包含大写英文字母。\n- 先修关系无环。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13204", "type": "P", "difficulty": 6, "samples": [["3\n3 7\n0 0 0 0 0 0\n1 2 2 0 0 0\n1 1 1 0 0 0\n5 10\n0 0 0 0 0 0\n35 0 0 -1 0 0\n1 54 0 0 -2 0\n2 -150 0 0 10 0\n4 0 0 -1 0 0\n3 1\n-10 2 0 1 0 0\n0 0 10 0 0 -1\n-10 -2 0 1 0 0", "Case #1: 1.7320508\nCase #2: 2.0000000\nCase #3: 4.0000000"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["图论", "2016", "Special Judge", "最短路", "Google Code Jam"], "title": "[GCJ 2016 #3] Rebel Against The Empire", "background": "", "description": "You are a rebel against the evil Galactic Empire, and you are on the run!\n\nYou have sabotaged the Empire's Factory of Evil, and imperial security forces will be after you soon! The factory is located on asteroid 0 in a system of $\\mathbf{N}$ numbered asteroids. Your getaway ship, the Century Quail, is located on asteroid 1, and if you can get there, you will be able to fly away safely.\n\nEach asteroid is a single point in space with a velocity, and you move through space along with whichever asteroid you are currently on. Your Asteroid Jumper will allow you to instantaneously jump between any two asteroids in the system. Long jumps are scarier than short ones (and the vacuum of space is terrifying), so you want to minimize the maximum distance you need to jump. However, starting now, if you ever spend more than a continuous $\\mathbf{S}$ seconds without jumping, the imperial security forces will catch you. That is, the interval from now until your first jump, and each interval between subsequent jumps, must be less than or equal to $\\mathbf{S}$. You may jump at any instant; it does not have to be after an integer number of seconds have elapsed. You escape the instant you jump to asteroid 1.\n\nThe i-th asteroid starts at position $(\\mathbf{x}_{\\mathbf{i}}, \\mathbf{y}_{\\mathbf{i}}, \\mathbf{z}_{\\mathbf{i}})$ in space, and it will move a total distance of $(\\mathbf{V}_{\\mathbf{x i}}, \\mathbf{V}_{\\mathbf{y i}}, \\mathbf{V}_{\\mathbf{z i}})$ each second. This movement is continuous throughout time; it does not update discretely each second. (It is also possible for an asteroid to be stationary.) Nothing happens if asteroids occupy the same point in space at the same time. You can only travel between two asteroids by jumping, even if they happen to occupy the same point at the instant of your jump.\n\nIn the escape plan that minimizes the maximum jump distance, what is that maximum jump distance?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of each test case contains two integers: $\\mathbf{N}$ (the number of asteroids) and $\\mathbf{S}$ (the limit on how long you can go without jumping). Next, there are $\\mathbf{N}$ lines describing the asteroids. The i-th of these lines (counting starting from 0) contains six integers: the initial $(\\mathbf{x}_{\\mathbf{i}}, \\mathbf{y}_{\\mathbf{i}}, \\mathbf{z}_{\\mathbf{i}})$ position of the i-th asteroid in space, and the distance $(\\mathbf{V}_{\\mathbf{x i}}, \\mathbf{V}_{\\mathbf{y i}}, \\mathbf{V}_{\\mathbf{z i}})$ it moves in a single second.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is a floating-point number: the distance of the longest jump you will have to make in order to get away. $\\mathrm{y}$ will be considered correct if it is within an absolute or relative error of $10^{-4}$ of the correct answer.", "hint": "**Sample Explanation**\n\nSample case #1 is the only sample case that could appear in the Small dataset. Any of the sample cases could appear in the Large dataset.\n\nIn sample case #1, we start on a stationary asteroid at $(0,0,0)$, and our ship is on an asteroid at $(1,2,2)$. There is another asteroid at $(1,1,1)$. One option is to jump directly to our ship, which is a distance of 3 away. Another option is to jump to the other asteroid, which is a distance of $\\operatorname{sqrt}(3)$ away, and then jump to the ship from there, which is a distance of $\\operatorname{sqrt}(2)$ away. The maximum jump distance is 3 for the first option and $\\operatorname{sqrt}(3)$ for the second option, so the second option is preferable.\n\nNote that the value of $\\mathbf{S}$ does not matter in the Small cases. Since all of the asteroids are stationary, there is no reason to wait around; we can make all jumps instantaneously.\n\nIn sample case #2, we start on a stationary asteroid at $(0,0,0)$. We can wait there for 4 seconds for asteroid 4 to come very close, jump onto it, fly for 1 second on it, and then jump back at time 5 back to asteroid 0 (the distance between the two asteroids is 1 at this moment). There we wait 10 seconds, cutting it very close to being caught, and then jump to the speeding asteroid 3 at time 15. Two seconds later, asteroid 3 flies by asteroid 2, and we jump to asteroid 2. At time 27, we can jump from asteroid 2 to asteroid 0. There we patiently wait until time 35 when asteroid 1 reaches us, then we can jump onto it and escape. The longest jump we made was from asteroid 0 to asteroid 3 at time 15, and the distance we jumped was 2.\n\nIn sample case #3, the security forces are really active! You could, of course, wait one second and jump directly to asteroid 1, but a better choice - that allows you to make jumps no longer than 4 - is to jump back and forth between asteroids 0 and 2; while waiting for asteroid 1 to get close, and only then jump to it.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 20$.\n- $2 \\leqslant \\mathbf{N} \\leqslant 1000$.\n- $1 \\leqslant \\mathbf{S} \\leqslant 100$.\n- $-500 \\leqslant \\mathbf{x}_{\\mathbf{i}} \\leqslant 500$.\n- $-500 \\leqslant \\mathbf{y}_{\\mathbf{i}} \\leqslant 500$.\n- $-500 \\leqslant \\mathbf{z}_{\\mathbf{i}} \\leqslant 500$.\n\n**Small dataset (8 Pts, Test Set 1 - Visible)**\n\n- $\\mathbf{V}_{\\mathbf{x i}}=0$.\n- $\\mathbf{V}_{\\mathbf{y i}}=0$.\n- $\\mathbf{V}_{\\mathbf{z i}}=0$.\n\n**Large dataset (17 Pts, Test Set 2 - Hidden)**\n\n- $-500 \\leqslant \\mathbf{V}_{\\mathbf{x i}} \\leqslant 500$.\n- $-500 \\leqslant \\mathbf{V}_{\\mathbf{y i}} \\leqslant 500$.\n- $-500 \\leqslant \\mathbf{V}_{\\mathbf{z i}} \\leqslant 500$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2016 #3] Rebel Against The Empire", "background": "", "description": "You are a rebel against the evil Galactic Empire, and you are on the run!\n\nYou have sabotaged the Empire's Factory of Evil, and imperial security forces will be after you soon! The factory is located on asteroid 0 in a system of $\\mathbf{N}$ numbered asteroids. Your getaway ship, the Century Quail, is located on asteroid 1, and if you can get there, you will be able to fly away safely.\n\nEach asteroid is a single point in space with a velocity, and you move through space along with whichever asteroid you are currently on. Your Asteroid Jumper will allow you to instantaneously jump between any two asteroids in the system. Long jumps are scarier than short ones (and the vacuum of space is terrifying), so you want to minimize the maximum distance you need to jump. However, starting now, if you ever spend more than a continuous $\\mathbf{S}$ seconds without jumping, the imperial security forces will catch you. That is, the interval from now until your first jump, and each interval between subsequent jumps, must be less than or equal to $\\mathbf{S}$. You may jump at any instant; it does not have to be after an integer number of seconds have elapsed. You escape the instant you jump to asteroid 1.\n\nThe i-th asteroid starts at position $(\\mathbf{x}_{\\mathbf{i}}, \\mathbf{y}_{\\mathbf{i}}, \\mathbf{z}_{\\mathbf{i}})$ in space, and it will move a total distance of $(\\mathbf{V}_{\\mathbf{x i}}, \\mathbf{V}_{\\mathbf{y i}}, \\mathbf{V}_{\\mathbf{z i}})$ each second. This movement is continuous throughout time; it does not update discretely each second. (It is also possible for an asteroid to be stationary.) Nothing happens if asteroids occupy the same point in space at the same time. You can only travel between two asteroids by jumping, even if they happen to occupy the same point at the instant of your jump.\n\nIn the escape plan that minimizes the maximum jump distance, what is that maximum jump distance?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of each test case contains two integers: $\\mathbf{N}$ (the number of asteroids) and $\\mathbf{S}$ (the limit on how long you can go without jumping). Next, there are $\\mathbf{N}$ lines describing the asteroids. The i-th of these lines (counting starting from 0) contains six integers: the initial $(\\mathbf{x}_{\\mathbf{i}}, \\mathbf{y}_{\\mathbf{i}}, \\mathbf{z}_{\\mathbf{i}})$ position of the i-th asteroid in space, and the distance $(\\mathbf{V}_{\\mathbf{x i}}, \\mathbf{V}_{\\mathbf{y i}}, \\mathbf{V}_{\\mathbf{z i}})$ it moves in a single second.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is a floating-point number: the distance of the longest jump you will have to make in order to get away. $\\mathrm{y}$ will be considered correct if it is within an absolute or relative error of $10^{-4}$ of the correct answer.", "hint": "**Sample Explanation**\n\nSample case #1 is the only sample case that could appear in the Small dataset. Any of the sample cases could appear in the Large dataset.\n\nIn sample case #1, we start on a stationary asteroid at $(0,0,0)$, and our ship is on an asteroid at $(1,2,2)$. There is another asteroid at $(1,1,1)$. One option is to jump directly to our ship, which is a distance of 3 away. Another option is to jump to the other asteroid, which is a distance of $\\operatorname{sqrt}(3)$ away, and then jump to the ship from there, which is a distance of $\\operatorname{sqrt}(2)$ away. The maximum jump distance is 3 for the first option and $\\operatorname{sqrt}(3)$ for the second option, so the second option is preferable.\n\nNote that the value of $\\mathbf{S}$ does not matter in the Small cases. Since all of the asteroids are stationary, there is no reason to wait around; we can make all jumps instantaneously.\n\nIn sample case #2, we start on a stationary asteroid at $(0,0,0)$. We can wait there for 4 seconds for asteroid 4 to come very close, jump onto it, fly for 1 second on it, and then jump back at time 5 back to asteroid 0 (the distance between the two asteroids is 1 at this moment). There we wait 10 seconds, cutting it very close to being caught, and then jump to the speeding asteroid 3 at time 15. Two seconds later, asteroid 3 flies by asteroid 2, and we jump to asteroid 2. At time 27, we can jump from asteroid 2 to asteroid 0. There we patiently wait until time 35 when asteroid 1 reaches us, then we can jump onto it and escape. The longest jump we made was from asteroid 0 to asteroid 3 at time 15, and the distance we jumped was 2.\n\nIn sample case #3, the security forces are really active! You could, of course, wait one second and jump directly to asteroid 1, but a better choice - that allows you to make jumps no longer than 4 - is to jump back and forth between asteroids 0 and 2; while waiting for asteroid 1 to get close, and only then jump to it.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 20$.\n- $2 \\leqslant \\mathbf{N} \\leqslant 1000$.\n- $1 \\leqslant \\mathbf{S} \\leqslant 100$.\n- $-500 \\leqslant \\mathbf{x}_{\\mathbf{i}} \\leqslant 500$.\n- $-500 \\leqslant \\mathbf{y}_{\\mathbf{i}} \\leqslant 500$.\n- $-500 \\leqslant \\mathbf{z}_{\\mathbf{i}} \\leqslant 500$.\n\n**Small dataset (8 Pts, Test Set 1 - Visible)**\n\n- $\\mathbf{V}_{\\mathbf{x i}}=0$.\n- $\\mathbf{V}_{\\mathbf{y i}}=0$.\n- $\\mathbf{V}_{\\mathbf{z i}}=0$.\n\n**Large dataset (17 Pts, Test Set 2 - Hidden)**\n\n- $-500 \\leqslant \\mathbf{V}_{\\mathbf{x i}} \\leqslant 500$.\n- $-500 \\leqslant \\mathbf{V}_{\\mathbf{y i}} \\leqslant 500$.\n- $-500 \\leqslant \\mathbf{V}_{\\mathbf{z i}} \\leqslant 500$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2016 #3] Rebel Against The Empire", "background": "", "description": "你是邪恶银河帝国的反抗者，现在正处于逃亡之中！\n\n你已经破坏了帝国的邪恶工厂，帝国安全部队很快就会追捕你！工厂位于编号为 0 的小行星上，在一个包含 $\\mathbf{N}$ 个编号小行星的系统中。你的逃生飞船 Century Quail 停靠在编号为 1 的小行星上，如果你能到达那里，就能安全逃脱。\n\n每颗小行星在空间中是一个点，并且有自己的速度，你始终随着你当前所在的小行星一起运动。你的“小行星跳跃器”允许你在系统内任意两颗小行星间瞬间跳跃。长距离跳跃比短距离跳跃更令人恐惧（宇宙真空更让人害怕），所以你希望最小化你所需跳跃的最大距离。然而，从现在开始，如果你连续超过 $\\mathbf{S}$ 秒没有跳跃，就会被帝国安全部队抓住。也就是说，从现在到第一次跳跃的间隔，以及之后每次跳跃之间的间隔，都必须小于等于 $\\mathbf{S}$。你可以在任意时刻跳跃，不必等到整秒。你只要跳跃到 1 号小行星，就算逃脱成功。\n\n第 $i$ 颗小行星在空间中的初始位置为 $(\\mathbf{x}_{\\mathbf{i}}, \\mathbf{y}_{\\mathbf{i}}, \\mathbf{z}_{\\mathbf{i}})$，每秒会移动 $(\\mathbf{V}_{\\mathbf{x i}}, \\mathbf{V}_{\\mathbf{y i}}, \\mathbf{V}_{\\mathbf{z i}})$ 的距离。小行星的运动是连续的，而不是每秒离散地更新。（也可能有静止的小行星。）即使两颗小行星在同一时刻占据同一点，也不会发生任何事。你只能通过跳跃在小行星之间移动，即便它们在你跳跃的那一刻正好重合。\n\n在最小化最大跳跃距离的逃脱方案中，这个最大跳跃距离是多少？", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例数量。接下来有 $\\mathbf{T}$ 组测试用例。每组数据的第一行为两个整数：$\\mathbf{N}$（小行星数量）和 $\\mathbf{S}$（你最多能连续不跳跃的秒数）。接下来有 $\\mathbf{N}$ 行描述小行星。第 $i$ 行（从 0 开始编号）包含 6 个整数，分别为该小行星的初始位置 $(\\mathbf{x}_{\\mathbf{i}}, \\mathbf{y}_{\\mathbf{i}}, \\mathbf{z}_{\\mathbf{i}})$，以及每秒移动的距离 $(\\mathbf{V}_{\\mathbf{x i}}, \\mathbf{V}_{\\mathbf{y i}}, \\mathbf{V}_{\\mathbf{z i}})$。\n", "outputFormat": "对于每组测试用例，输出一行 `Case #x: y`，其中 $\\mathrm{x}$ 为测试用例编号（从 1 开始），$\\mathrm{y}$ 为你为逃脱所需的最大跳跃距离（浮点数）。如果 $\\mathrm{y}$ 与正确答案的绝对误差或相对误差不超过 $10^{-4}$，则视为正确。\n", "hint": "**样例解释**\n\n样例第 1 组是唯一可能出现在小数据集中的样例。其他样例可能出现在大数据集中。\n\n在样例第 1 组中，我们从 $(0,0,0)$ 的静止小行星出发，飞船在 $(1,2,2)$ 的小行星上。还有一颗小行星在 $(1,1,1)$。一种做法是直接跳到飞船上，距离为 3。另一种做法是先跳到另一颗小行星，距离为 $\\operatorname{sqrt}(3)$，再从那里跳到飞船，距离为 $\\operatorname{sqrt}(2)$。最大跳跃距离分别为 3 和 $\\operatorname{sqrt}(3)$，所以第二种方案更优。\n\n注意，小数据集中 $\\mathbf{S}$ 的值无关紧要。因为所有小行星都静止，所以可以瞬间完成所有跳跃。\n\n在样例第 2 组中，我们从 $(0,0,0)$ 的静止小行星出发。我们可以等待 4 秒直到第 4 号小行星靠近，跳到它上面，在它上面飞 1 秒，然后在第 5 秒跳回 0 号小行星（此时两者距离为 1）。然后我们在 0 号小行星上等待 10 秒，刚好不被抓住，然后在第 15 秒跳到高速移动的第 3 号小行星。两秒后，第 3 号小行星飞到第 2 号小行星附近，我们跳到第 2 号小行星。在第 27 秒时，我们可以从第 2 号小行星跳回第 0 号。我们耐心等待，直到第 35 秒第 1 号小行星到达我们这里，跳上去即可逃脱。我们跳的最长距离是第 15 秒从 0 号跳到 3 号，距离为 2。\n\n在样例第 3 组中，安全部队非常活跃！你当然可以等 1 秒直接跳到 1 号小行星，但更优的方案是反复在 0 号和 2 号小行星之间跳跃，等待 1 号小行星靠近再跳过去，这样最长跳跃距离只有 4。\n\n**限制条件**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 20$。\n- $2 \\leqslant \\mathbf{N} \\leqslant 1000$。\n- $1 \\leqslant \\mathbf{S} \\leqslant 100$。\n- $-500 \\leqslant \\mathbf{x}_{\\mathbf{i}} \\leqslant 500$。\n- $-500 \\leqslant \\mathbf{y}_{\\mathbf{i}} \\leqslant 500$。\n- $-500 \\leqslant \\mathbf{z}_{\\mathbf{i}} \\leqslant 500$。\n\n**小数据集（8 分，测试集 1 - 可见）**\n\n- $\\mathbf{V}_{\\mathbf{x i}}=0$。\n- $\\mathbf{V}_{\\mathbf{y i}}=0$。\n- $\\mathbf{V}_{\\mathbf{z i}}=0$。\n\n**大数据集（17 分，测试集 2 - 隐藏）**\n\n- $-500 \\leqslant \\mathbf{V}_{\\mathbf{x i}} \\leqslant 500$。\n- $-500 \\leqslant \\mathbf{V}_{\\mathbf{y i}} \\leqslant 500$。\n- $-500 \\leqslant \\mathbf{z}_{\\mathbf{i}} \\leqslant 500$。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13205", "type": "P", "difficulty": 6, "samples": [["3\n2 2\n10 00\n11\n3 2\n11 10 00\n01\n4 2\n00 01 10 11\n11", "Case #1: ? 10?1\nCase #2: 1?? 0\nCase #3: IMPOSSIBLE"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["2016", "Special Judge", "构造", "Google Code Jam"], "title": "[GCJ 2016 #3] Go++", "background": "", "description": "The Go language was designed to have a simple API and to support multi-threading. The Code Jam team wants to push these goals to the limit, so we are proposing a new language called Go++.\n\nThe Go++ language uses one register, which stores one boolean value (0 or 1). This register is initialized to 0. The language has three instructions:\n\n* $\\mathbf{0}$, which sets the register to 0.\n* $\\mathbf{1}$, which sets the register to 1.\n* $\\mathbf{?}$, which prints the current register value.\n\nSimple, right? To support multi-threading, we allow two different Go++ programs to run simultaneously while sharing the one register. Each instruction executes atomically - that is, one instruction must completely finish before the next instruction can start. However, the two programs may be interleaved in any way that preserves the relative order within each program.\n\nFor example, here are the only six ways in which the two programs $1 \\mathbf{?}$ and $\\mathbf{?} \\mathbf{0}$ could be executed together. (The underline on the second program is just to distinguish its instructions from the instructions in the first program.)\n\n* $\\mathbf{?} \\mathbf{0} \\mathbf{1} \\mathbf{?}$, which will print $\\mathbf{0 1}$. (Remember that the register is initialized to 0.)\n* $\\mathbf{?} \\mathbf{1} \\mathbf{0} \\mathbf{?}$, which will print $\\mathbf{0 0}$.\n* $\\mathbf{?} \\mathbf{1} \\mathbf{?} \\mathbf{0}$, which will print $\\mathbf{0 1}$.\n* $\\mathbf{1} \\mathbf{?} \\mathbf{0} \\mathbf{?}$, which will print $\\mathbf{1 0}$.\n* $\\mathbf{1} \\mathbf{?} \\mathbf{?} \\mathbf{0}$, which will print $\\mathbf{1 1}$.\n* $\\mathbf{1} \\mathbf{?} \\mathbf{?} \\mathbf{0}$, which will print $\\mathbf{1 1}$.\n\nNote that the output string always consists of $\\mathbf{0}$ s and $\\mathbf{1}$ s, and never $\\mathbf{?}$ s, since $\\mathbf{?}$ is not a state the register can be in.\n\nUsually, programmers write programs to produce a desired output, but your task will be to write two programs that won't produce an undesired output! Specifically, you will be given a \"bad\" string $\\mathbf{B}$ of length $\\mathbf{L}$, and a set $\\mathbf{G}$ of $\\mathbf{N}$ \"good\" strings, all of length $\\mathbf{L}$. You must produce two Go++ programs (not necessarily of the same length), which, when run in the way described here, could produce all of the strings in $\\mathbf{G}$, but could not produce the string $\\mathbf{B}$. It is fine if the programs could also produce other strings that are not $\\mathbf{B}$ and not in $\\mathbf{G}$. Note that there must be a combined total of exactly $\\mathbf{L}$ ? instructions in the two programs. The combined number of instructions in the two programs must not exceed 200 .\n\nFor example, for $\\mathbf{B}=\\mathbf{1 1}$ and $\\mathbf{G}=\\{\\mathbf{1 0}, \\mathbf{0 0}\\}$, the programs $\\mathbf{?}$ and $\\mathbf{1 0} \\mathbf{?} \\mathbf{1}$ would be one valid answer. They can produce every string in $\\mathbf{G}$, but they cannot produce $\\mathbf{B}$, no matter how they are interleaved. (They can also produce the string $\\mathbf{0 1}$, which is not $\\mathbf{B}$ and is not in $\\mathbf{G}$, but that is fine.) However, the programs $\\mathbf{1} \\mathbf{?}$ and $\\mathbf{?} \\mathbf{0}$ would not be a valid answer, since (as we saw above) they can produce $\\mathbf{B}$. The programs $\\mathbf{0 0}$ and $\\mathbf{?} \\mathbf{?}$ would not be a valid answer, since they cannot produce every string in $\\mathbf{G}$.\n\nCan you produce two programs that satisfy the conditions, or determine that the task is IMPOSSIBLE?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow; each consists of three lines. The first line of each test case has two integers $\\mathbf{N}$ and $\\mathbf{L}$ : the number of strings in $\\mathbf{G}$, and the length of the $\\mathbf{B}$ string and the strings in $\\mathbf{G}$. The second line has $\\mathbf{N}$ different strings of length $\\mathbf{L}$ : the strings in $\\mathbf{G}$. The third line has one string of length $\\mathbf{L}$ : the bad string $\\mathbf{B}$. $\\mathbf{B}$ and all of the strings in $\\mathbf{G}$ are made up of only $\\mathbf{0}$ s and/or $\\mathbf{1}$ s.", "outputFormat": "For each test case, output one line containing `Case # x : IMPOSSIBLE`, if no programs will satisfy the conditions; otherwise, output `Case #x: y z`, where $\\mathbf{x}$ is the test case number (starting from 1) and $\\mathbf{y}$ and $\\mathbf{z}$ are your two programs that satisfy the conditions. The combined number of instructions in your programs must not exceed 200. Each program must contain at least one instruction. There must be a combined total of exactly $\\mathbf{L} \\mathbf{?}$ instructions in the two programs.", "hint": "**Sample Explanation**\n\nThe sample output displays one set of answers to the sample cases. Other answers may be possible.\n\nSample case #1 is the one described in the problem statement.\n\nSample case #2 would not appear in the Small dataset.\n\nSample case #3 is obviously IMPOSSIBLE because B is in G.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{N} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{L} \\leqslant 50$.\n- All strings in $\\mathbf{G}$ are different.\n\n**Small dataset (7 Pts, Test Set 1 - Visible)**\n\n- $\\mathbf{B}$ consists entirely of $\\mathbf{1}$ s.\n\n**Large dataset (28 Pts, Test Set 2 - Hidden)**\n\n- $\\mathbf{B}$ may be any string consisting of $\\mathbf{0}$ s and/or $\\mathbf{1}$ s.", "locale": "en", "translations": {"en": {"title": "[GCJ 2016 #3] Go++", "background": "", "description": "The Go language was designed to have a simple API and to support multi-threading. The Code Jam team wants to push these goals to the limit, so we are proposing a new language called Go++.\n\nThe Go++ language uses one register, which stores one boolean value (0 or 1). This register is initialized to 0. The language has three instructions:\n\n* $\\mathbf{0}$, which sets the register to 0.\n* $\\mathbf{1}$, which sets the register to 1.\n* $\\mathbf{?}$, which prints the current register value.\n\nSimple, right? To support multi-threading, we allow two different Go++ programs to run simultaneously while sharing the one register. Each instruction executes atomically - that is, one instruction must completely finish before the next instruction can start. However, the two programs may be interleaved in any way that preserves the relative order within each program.\n\nFor example, here are the only six ways in which the two programs $1 \\mathbf{?}$ and $\\mathbf{?} \\mathbf{0}$ could be executed together. (The underline on the second program is just to distinguish its instructions from the instructions in the first program.)\n\n* $\\mathbf{?} \\mathbf{0} \\mathbf{1} \\mathbf{?}$, which will print $\\mathbf{0 1}$. (Remember that the register is initialized to 0.)\n* $\\mathbf{?} \\mathbf{1} \\mathbf{0} \\mathbf{?}$, which will print $\\mathbf{0 0}$.\n* $\\mathbf{?} \\mathbf{1} \\mathbf{?} \\mathbf{0}$, which will print $\\mathbf{0 1}$.\n* $\\mathbf{1} \\mathbf{?} \\mathbf{0} \\mathbf{?}$, which will print $\\mathbf{1 0}$.\n* $\\mathbf{1} \\mathbf{?} \\mathbf{?} \\mathbf{0}$, which will print $\\mathbf{1 1}$.\n* $\\mathbf{1} \\mathbf{?} \\mathbf{?} \\mathbf{0}$, which will print $\\mathbf{1 1}$.\n\nNote that the output string always consists of $\\mathbf{0}$ s and $\\mathbf{1}$ s, and never $\\mathbf{?}$ s, since $\\mathbf{?}$ is not a state the register can be in.\n\nUsually, programmers write programs to produce a desired output, but your task will be to write two programs that won't produce an undesired output! Specifically, you will be given a \"bad\" string $\\mathbf{B}$ of length $\\mathbf{L}$, and a set $\\mathbf{G}$ of $\\mathbf{N}$ \"good\" strings, all of length $\\mathbf{L}$. You must produce two Go++ programs (not necessarily of the same length), which, when run in the way described here, could produce all of the strings in $\\mathbf{G}$, but could not produce the string $\\mathbf{B}$. It is fine if the programs could also produce other strings that are not $\\mathbf{B}$ and not in $\\mathbf{G}$. Note that there must be a combined total of exactly $\\mathbf{L}$ ? instructions in the two programs. The combined number of instructions in the two programs must not exceed 200 .\n\nFor example, for $\\mathbf{B}=\\mathbf{1 1}$ and $\\mathbf{G}=\\{\\mathbf{1 0}, \\mathbf{0 0}\\}$, the programs $\\mathbf{?}$ and $\\mathbf{1 0} \\mathbf{?} \\mathbf{1}$ would be one valid answer. They can produce every string in $\\mathbf{G}$, but they cannot produce $\\mathbf{B}$, no matter how they are interleaved. (They can also produce the string $\\mathbf{0 1}$, which is not $\\mathbf{B}$ and is not in $\\mathbf{G}$, but that is fine.) However, the programs $\\mathbf{1} \\mathbf{?}$ and $\\mathbf{?} \\mathbf{0}$ would not be a valid answer, since (as we saw above) they can produce $\\mathbf{B}$. The programs $\\mathbf{0 0}$ and $\\mathbf{?} \\mathbf{?}$ would not be a valid answer, since they cannot produce every string in $\\mathbf{G}$.\n\nCan you produce two programs that satisfy the conditions, or determine that the task is IMPOSSIBLE?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow; each consists of three lines. The first line of each test case has two integers $\\mathbf{N}$ and $\\mathbf{L}$ : the number of strings in $\\mathbf{G}$, and the length of the $\\mathbf{B}$ string and the strings in $\\mathbf{G}$. The second line has $\\mathbf{N}$ different strings of length $\\mathbf{L}$ : the strings in $\\mathbf{G}$. The third line has one string of length $\\mathbf{L}$ : the bad string $\\mathbf{B}$. $\\mathbf{B}$ and all of the strings in $\\mathbf{G}$ are made up of only $\\mathbf{0}$ s and/or $\\mathbf{1}$ s.", "outputFormat": "For each test case, output one line containing `Case # x : IMPOSSIBLE`, if no programs will satisfy the conditions; otherwise, output `Case #x: y z`, where $\\mathbf{x}$ is the test case number (starting from 1) and $\\mathbf{y}$ and $\\mathbf{z}$ are your two programs that satisfy the conditions. The combined number of instructions in your programs must not exceed 200. Each program must contain at least one instruction. There must be a combined total of exactly $\\mathbf{L} \\mathbf{?}$ instructions in the two programs.", "hint": "**Sample Explanation**\n\nThe sample output displays one set of answers to the sample cases. Other answers may be possible.\n\nSample case #1 is the one described in the problem statement.\n\nSample case #2 would not appear in the Small dataset.\n\nSample case #3 is obviously IMPOSSIBLE because B is in G.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{N} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{L} \\leqslant 50$.\n- All strings in $\\mathbf{G}$ are different.\n\n**Small dataset (7 Pts, Test Set 1 - Visible)**\n\n- $\\mathbf{B}$ consists entirely of $\\mathbf{1}$ s.\n\n**Large dataset (28 Pts, Test Set 2 - Hidden)**\n\n- $\\mathbf{B}$ may be any string consisting of $\\mathbf{0}$ s and/or $\\mathbf{1}$ s.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2016 #3] Go++", "background": "", "description": "Go 语言的设计目标是提供简单的 API 并支持多线程。Code Jam 团队希望将这些目标发挥到极致，因此我们提出了一种新语言，名为 Go++。\n\nGo++ 语言只使用一个寄存器，该寄存器存储一个布尔值（0 或 1）。寄存器初始值为 0。该语言有三种指令：\n\n* $\\mathbf{0}$，将寄存器设置为 0。\n* $\\mathbf{1}$，将寄存器设置为 1。\n* $\\mathbf{?}$，输出当前寄存器的值。\n\n很简单，对吧？为了支持多线程，我们允许两段不同的 Go++ 程序同时运行，并共享同一个寄存器。每条指令都是原子的——也就是说，每条指令必须完全执行完毕后，下一条指令才能开始执行。不过，两段程序的指令可以以任意方式交错执行，只要每段程序内部指令的相对顺序不变。\n\n例如，下面是将两段程序 $1\\mathbf{?}$ 和 $\\mathbf{?} \\mathbf{0}$ 同时执行时所有可能的六种交错方式（下划线仅用于区分第二段程序的指令）：\n\n* $\\mathbf{?}\\mathbf{0}1\\mathbf{?}$，输出为 $\\mathbf{0\\ 1}$。（记住寄存器初始为 0。）\n* $\\mathbf{?}1\\mathbf{0}\\mathbf{?}$，输出为 $\\mathbf{0\\ 0}$。\n* $\\mathbf{?}1\\mathbf{?}\\mathbf{0}$，输出为 $\\mathbf{0\\ 1}$。\n* $1\\mathbf{?}\\mathbf{0}\\mathbf{?}$，输出为 $\\mathbf{1\\ 0}$。\n* $1\\mathbf{?}\\mathbf{?}\\mathbf{0}$，输出为 $\\mathbf{1\\ 1}$。\n* $1\\mathbf{?}\\mathbf{?}\\mathbf{0}$，输出为 $\\mathbf{1\\ 1}$。\n\n注意，输出字符串始终只包含 $\\mathbf{0}$ 和 $\\mathbf{1}$，而不会有 $\\mathbf{?}$，因为 $\\mathbf{?}$ 不是寄存器的状态。\n\n通常，程序员会写程序以产生期望的输出，而你的任务则是编写两段程序，保证不会产生某个“不良输出”！具体来说，你会得到一个长度为 $\\mathbf{L}$ 的“不良字符串” $\\mathbf{B}$，以及一个包含 $\\mathbf{N}$ 个长度为 $\\mathbf{L}$ 的“良好字符串”集合 $\\mathbf{G}$。你需要构造两段 Go++ 程序（长度可以不同），使得两段程序以上述规则交错执行时，能够产生 $\\mathbf{G}$ 中所有字符串，但绝不可能产生字符串 $\\mathbf{B}$。如果还能产生其他既不是 $\\mathbf{B}$ 也不在 $\\mathbf{G}$ 的字符串，也没关系。注意，两段程序中 $\\mathbf{?}$ 指令的总数必须恰好为 $\\mathbf{L}$。两段程序总指令数不得超过 200。\n\n举例来说，若 $\\mathbf{B}=\\mathbf{11}$，$\\mathbf{G}=\\{\\mathbf{10}, \\mathbf{00}\\}$，则程序 $\\mathbf{?}$ 和 $\\mathbf{10?1}$ 是一个合法答案。它们能产生 $\\mathbf{G}$ 中的所有字符串，但无论如何交错都不可能产生 $\\mathbf{B}$。（它们也能产生 $\\mathbf{01}$，但这既不是 $\\mathbf{B}$ 也不在 $\\mathbf{G}$，这没关系。）而程序 $1\\mathbf{?}$ 和 $\\mathbf{?}\\mathbf{0}$ 不是合法答案，因为它们可能产生 $\\mathbf{B}$。程序 $\\mathbf{00}$ 和 $\\mathbf{??}$ 也不是合法答案，因为它们无法产生 $\\mathbf{G}$ 中的所有字符串。\n\n你能否构造出满足条件的两段程序，或判断任务不可能完成（IMPOSSIBLE）？", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例数量。接下来有 $\\mathbf{T}$ 组测试用例，每组三行。每组的第一行为两个整数 $\\mathbf{N}$ 和 $\\mathbf{L}$，分别表示 $\\mathbf{G}$ 中字符串数量，以及 $\\mathbf{B}$ 和 $\\mathbf{G}$ 中字符串的长度。第二行为 $\\mathbf{N}$ 个长度为 $\\mathbf{L}$ 的不同字符串，表示 $\\mathbf{G}$。第三行为一个长度为 $\\mathbf{L}$ 的字符串，表示不良字符串 $\\mathbf{B}$。$\\mathbf{B}$ 和 $\\mathbf{G}$ 中所有字符串仅由 $\\mathbf{0}$ 和 $\\mathbf{1}$ 组成。\n", "outputFormat": "对于每组测试用例，若无法满足条件，输出一行 `Case #x: IMPOSSIBLE`，否则输出一行 `Case #x: y z`，其中 $\\mathbf{x}$ 为测试用例编号（从 1 开始），$\\mathbf{y}$ 和 $\\mathbf{z}$ 是你构造的两段程序。两段程序的总指令数不得超过 200，每段程序至少包含一条指令，且两段程序中 $\\mathbf{?}$ 指令总数恰好为 $\\mathbf{L}$。", "hint": "**样例解释**\n\n样例输出展示了一组可能答案，其他答案也可能是正确的。\n\n样例第 1 组即为题面中的例子。\n\n样例第 2 组不会出现在小数据集中。\n\n样例第 3 组显然 IMPOSSIBLE，因为 $\\mathbf{B}$ 就在 $\\mathbf{G}$ 中。\n\n**限制条件**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$。\n- $1 \\leqslant \\mathbf{N} \\leqslant 100$。\n- $1 \\leqslant \\mathbf{L} \\leqslant 50$。\n- $\\mathbf{G}$ 中所有字符串均不同。\n\n**小数据集（7 分，测试集 1 - 可见）**\n\n- $\\mathbf{B}$ 全部由 $\\mathbf{1}$ 组成。\n\n**大数据集（28 分，测试集 2 - 隐藏）**\n\n- $\\mathbf{B}$ 可以是任意由 $\\mathbf{0}$ 和/或 $\\mathbf{1}$ 组成的字符串。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13206", "type": "P", "difficulty": 7, "samples": [["8\n1 1000\n(0)*1(0)*\n379009 379009\n379009\n1 10000\n(12)*(34)*\n4 5\n45\n1 100\n((0|1))*\n1 50\n(01|23|45|67|23)\n1 1000000000000000000\n((0|1|2|3|4|5|6|7|8|9))*\n1 1000\n1(56|(((7|8))*9)*)", "Case #1: 4\nCase #2: 1\nCase #3: 5\nCase #4: 0\nCase #5: 4\nCase #6: 2\nCase #7: 1000000000000000000\nCase #8: 6"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2016", "有限状态自动机", "Google Code Jam"], "title": "[GCJ 2016 Finals] Integeregex", "background": "", "description": "In this problem, a valid regular expression is one of the following. In the following descriptions, $E_{1}, E_{2}$, etc. denote (not necessarily different) valid regular expressions.\n\n* A decimal digit: that is, one of $\\mathbf{0} \\mathbf{1} \\mathbf{2} \\mathbf{3} \\mathbf{4} \\mathbf{5} \\mathbf{6} \\mathbf{7} \\mathbf{8} \\mathbf{9}$.\n* Concatenation: $E_{1} E_{2}$.\n* Disjunction: $\\left(E_{1}\\left|E_{2}\\right| \\ldots\\left|E_{N}\\right)\\right.$, for at least two expressions. Note that the outer parentheses are required.\n* Repetition: $\\left(E_{1}\\right)^{*}$. Note that the outer parentheses are required.\n\nFor example, $7,23, (7)^{*},(45)^{*},(1|2| 3),((2)^{*} \\mid 3),(1|2| 3)$, and $((0|1))^{*}$ are valid expressions. $(7), 4|5,4^{*},(1|)$, and $(0|1)^{*}$ are not.\n\nWe say that an expression $E$ matches a string of digits $D$ if and only if at least one of the following is true:\n\n* $E=D$.\n* $E=E_{1} E_{2}$ and there exist $D_{1}$ and $D_{2}$ such that $D=D_{1} D_{2}$ and $E_{i}$ matches $D_{i}$.\n* $E=\\left(E_{1}\\left|E_{2}\\right| \\ldots\\left|E_{N}\\right)\\right.$ and at least one of the $E_{i}$ matches $D$.\n* $E=\\left(E_{1}\\right)^{*}$ and there exist $D_{1}, D_{2}, \\ldots, D_{N}$ for some non-negative integer $N$ such that $D=D_{1} D_{2} \\ldots D_{N}$ and $E_{1}$ matches each of the $D_{i}$. In particular, note that $\\left(E_{1}\\right)^{*}$ matches the empty string.\n\nFor example, the expression $((1|2))^{*} 3$ matches $3,13,123$, and $2221123$, among other strings. However, it does not match $1234,3123,12,$ or $33$, among other strings.\n\nGiven a valid regular expression $\\mathbf{R}$, for how many integers between $\\mathbf{A}$ and $\\mathbf{B}$, inclusive, does $\\mathbf{R}$ match the integer's base 10 representation (with no leading zeroes)?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow; each consists of two lines. The first line has two positive integers $\\mathbf{A}$ and $\\mathbf{B}$ : the inclusive limits of the integer range we are interested in. The second has a string $\\mathbf{R}$ consisting only of characters in the set `0123456789()|*`, which is guaranteed to be a valid regular expression as described in the statement above.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of integers in the inclusive range $[\\mathbf{A}, \\mathbf{B}]$ that the the regular expression $\\mathbf{R}$ matches.", "hint": "**Sample Explanation**\n\nNote that sample cases 5 through 8 would not appear in the Small dataset.\n\nIn sample case 1, the matches in range are $1, 10, 100$, and $1000$.\n\nIn sample case 2, the match in range is $379009$.\n\nIn sample case 3, the matches in range are $12, 34, 1212, 1234$, and $3434$.\n\nIn sample case 4, there are no matches in range.\n\nIn sample case 5, the matches in range are $1, 10, 11$, and $100$.\n\nIn sample case 6, the matches in range are $23$ and $45$.\n\nIn sample case 7, it is possible to form any number in the range.\n\nIn sample case 8, the matches in range are $1, 19, 156, 179, 189$, and $199$.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{A} \\leqslant \\mathbf{B} \\leqslant 10^{18}$.\n- $1 \\leqslant$ length of $\\mathbf{R} \\leqslant 30$.\n\n**Small dataset (15 Pts, Test Set 1 - Visible)**\n\n- $\\mathbf{R}$ contains no | characters.\n\n**Large dataset (15 Pts, Test Set 2 - Hidden)**\n\n- No additional limits.", "locale": "en", "translations": {"en": {"title": "[GCJ 2016 Finals] Integeregex", "background": "", "description": "In this problem, a valid regular expression is one of the following. In the following descriptions, $E_{1}, E_{2}$, etc. denote (not necessarily different) valid regular expressions.\n\n* A decimal digit: that is, one of $\\mathbf{0} \\mathbf{1} \\mathbf{2} \\mathbf{3} \\mathbf{4} \\mathbf{5} \\mathbf{6} \\mathbf{7} \\mathbf{8} \\mathbf{9}$.\n* Concatenation: $E_{1} E_{2}$.\n* Disjunction: $\\left(E_{1}\\left|E_{2}\\right| \\ldots\\left|E_{N}\\right)\\right.$, for at least two expressions. Note that the outer parentheses are required.\n* Repetition: $\\left(E_{1}\\right)^{*}$. Note that the outer parentheses are required.\n\nFor example, $7,23, (7)^{*},(45)^{*},(1|2| 3),((2)^{*} \\mid 3),(1|2| 3)$, and $((0|1))^{*}$ are valid expressions. $(7), 4|5,4^{*},(1|)$, and $(0|1)^{*}$ are not.\n\nWe say that an expression $E$ matches a string of digits $D$ if and only if at least one of the following is true:\n\n* $E=D$.\n* $E=E_{1} E_{2}$ and there exist $D_{1}$ and $D_{2}$ such that $D=D_{1} D_{2}$ and $E_{i}$ matches $D_{i}$.\n* $E=\\left(E_{1}\\left|E_{2}\\right| \\ldots\\left|E_{N}\\right)\\right.$ and at least one of the $E_{i}$ matches $D$.\n* $E=\\left(E_{1}\\right)^{*}$ and there exist $D_{1}, D_{2}, \\ldots, D_{N}$ for some non-negative integer $N$ such that $D=D_{1} D_{2} \\ldots D_{N}$ and $E_{1}$ matches each of the $D_{i}$. In particular, note that $\\left(E_{1}\\right)^{*}$ matches the empty string.\n\nFor example, the expression $((1|2))^{*} 3$ matches $3,13,123$, and $2221123$, among other strings. However, it does not match $1234,3123,12,$ or $33$, among other strings.\n\nGiven a valid regular expression $\\mathbf{R}$, for how many integers between $\\mathbf{A}$ and $\\mathbf{B}$, inclusive, does $\\mathbf{R}$ match the integer's base 10 representation (with no leading zeroes)?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow; each consists of two lines. The first line has two positive integers $\\mathbf{A}$ and $\\mathbf{B}$ : the inclusive limits of the integer range we are interested in. The second has a string $\\mathbf{R}$ consisting only of characters in the set `0123456789()|*`, which is guaranteed to be a valid regular expression as described in the statement above.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of integers in the inclusive range $[\\mathbf{A}, \\mathbf{B}]$ that the the regular expression $\\mathbf{R}$ matches.", "hint": "**Sample Explanation**\n\nNote that sample cases 5 through 8 would not appear in the Small dataset.\n\nIn sample case 1, the matches in range are $1, 10, 100$, and $1000$.\n\nIn sample case 2, the match in range is $379009$.\n\nIn sample case 3, the matches in range are $12, 34, 1212, 1234$, and $3434$.\n\nIn sample case 4, there are no matches in range.\n\nIn sample case 5, the matches in range are $1, 10, 11$, and $100$.\n\nIn sample case 6, the matches in range are $23$ and $45$.\n\nIn sample case 7, it is possible to form any number in the range.\n\nIn sample case 8, the matches in range are $1, 19, 156, 179, 189$, and $199$.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{A} \\leqslant \\mathbf{B} \\leqslant 10^{18}$.\n- $1 \\leqslant$ length of $\\mathbf{R} \\leqslant 30$.\n\n**Small dataset (15 Pts, Test Set 1 - Visible)**\n\n- $\\mathbf{R}$ contains no | characters.\n\n**Large dataset (15 Pts, Test Set 2 - Hidden)**\n\n- No additional limits.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2016 Finals] Integeregex", "background": "", "description": "在本题中，一个合法的正则表达式是下列之一。描述中的 $E_1, E_2$ 等表示（不一定不同的）合法正则表达式。\n\n* 一个十进制数字：即 $\\mathbf{0}\\ \\mathbf{1}\\ \\mathbf{2}\\ \\mathbf{3}\\ \\mathbf{4}\\ \\mathbf{5}\\ \\mathbf{6}\\ \\mathbf{7}\\ \\mathbf{8}\\ \\mathbf{9}$ 之一。\n* 连接：$E_1 E_2$。\n* 并选：$\\left(E_1|E_2|\\ldots|E_N\\right)$，其中至少有两个表达式。注意外层括号是必须的。\n* 重复：$\\left(E_1\\right)^*$。注意外层括号是必须的。\n\n例如，$7$, $23$, $(7)^*$, $(45)^*$, $(1|2|3)$, $((2)^*|3)$, $(1|2|3)$, $((0|1))^*$ 都是合法表达式。$(7)$, $4|5$, $4^*$, $(1|)$, $(0|1)^*$ 都不是。\n\n我们说表达式 $E$ 匹配数字字符串 $D$ 当且仅当下列之一成立：\n\n* $E=D$。\n* $E=E_1 E_2$，且存在 $D_1, D_2$ 使得 $D=D_1 D_2$ 且 $E_i$ 匹配 $D_i$。\n* $E=\\left(E_1|E_2|\\ldots|E_N\\right)$，且至少有一个 $E_i$ 匹配 $D$。\n* $E=\\left(E_1\\right)^*$，且存在若干非负整数 $N$ 及 $D_1, D_2, \\ldots, D_N$，使得 $D=D_1 D_2 \\ldots D_N$ 且 $E_1$ 匹配每个 $D_i$。特别地，$\\left(E_1\\right)^*$ 匹配空串。\n\n例如，表达式 $((1|2))^*3$ 匹配 $3, 13, 123, 2221123$ 等字符串，但不匹配 $1234, 3123, 12, 33$ 等。\n\n给定一个合法的正则表达式 $\\mathbf{R}$，问有多少个整数在 $[\\mathbf{A}, \\mathbf{B}]$ 间，其十进制表示（无前导零）能被 $\\mathbf{R}$ 匹配？", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例数量。接下来有 $\\mathbf{T}$ 组测试用例，每组包含两行。第一行为两个正整数 $\\mathbf{A}$ 和 $\\mathbf{B}$，表示所关心的整数区间（闭区间）。第二行为一个仅由 `0123456789()|*` 组成的字符串 $\\mathbf{R}$，保证其为合法正则表达式（如上所述）。\n", "outputFormat": "对于每组测试用例，输出一行 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为区间 $[\\mathbf{A}, \\mathbf{B}]$ 内能被正则表达式 $\\mathbf{R}$ 匹配的整数个数。\n", "hint": "**样例解释**\n\n注意，样例 5 至 8 不会出现在小数据集中。\n\n在样例 1 中，区间内匹配的数字为 $1, 10, 100, 1000$。\n\n在样例 2 中，区间内匹配的数字为 $379009$。\n\n在样例 3 中，区间内匹配的数字为 $12, 34, 1212, 1234, 3434$。\n\n在样例 4 中，没有匹配的数字。\n\n在样例 5 中，区间内匹配的数字为 $1, 10, 11, 100$。\n\n在样例 6 中，区间内匹配的数字为 $23, 45$。\n\n在样例 7 中，区间内的任意数字都能被匹配。\n\n在样例 8 中，区间内匹配的数字为 $1, 19, 156, 179, 189, 199$。\n\n**限制条件**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$。\n- $1 \\leqslant \\mathbf{A} \\leqslant \\mathbf{B} \\leqslant 10^{18}$。\n- $1 \\leqslant \\mathbf{R}$ 的长度 $\\leqslant 30$。\n\n**小数据集（15 分，测试集 1 - 可见）**\n\n- $\\mathbf{R}$ 不包含 | 字符。\n\n**大数据集（15 分，测试集 2 - 隐藏）**\n\n- 无其他限制。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13207", "type": "P", "difficulty": 6, "samples": [["4\n3 1\n3 2\n4 1\n4 2", "Case #1: 500000004\nCase #2: 1\nCase #3: 666666672\nCase #4: 1"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2016", "概率论", "Google Code Jam"], "title": "[GCJ 2016 Finals] Family Hotel", "background": "", "description": "You run a hotel with $\\mathbf{N}$ rooms arranged along one long corridor, numbered from 1 to $\\mathbf{N}$ along that corridor. Your guests are big families, and every family asks for exactly two adjacent rooms when they arrive. Two rooms are adjacent if their numbers differ by exactly 1.\n\nAt the start of the day today, your hotel was empty. You have been using the following simple strategy to assign rooms to your guests. As each family arrives, you consider all possible pairs of adjacent rooms that are both free, pick one of those pairs uniformly at random, and assign the two rooms in that pair to the family. New families constantly arrive, one family at a time, but once there are no more pairs of adjacent rooms that are both free, you turn on the NO VACANCY sign and you do not give out any more rooms.\n\nGiven a specific room number, what is the probability that it will be occupied at the time that you turn on the NO VACANCY sign?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line contains two numbers: the number of rooms $\\mathbf{N}$ and the room number $\\mathbf{K}$ that we are interested in.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the sought probability computed modulo $10^9 + 7$, which is defined precisely as follows. Represent the probability that room $\\mathbf{K}$ is occupied as an irreducible fraction $\\frac{p}{q}$. The number $y$ then must satisfy the modular equation $y \\times q \\equiv p \\pmod{10^9 + 7}$, and be between 0 and $10^9 + 6$, inclusive. It can be shown that under the constraints of this problem such a number $y$ always exists and is uniquely determined.", "hint": "**Sample Explanation**\n\nIn sample case #3, there are four rooms and we are looking for probability that the first room is occupied. When the first family arrives, there are 3 possible situations, each with probability $1/3$: occupy rooms $1+2, 2+3$ or $3+4$. In the first situation, the first room is already occupied and will stay occupied. In the second situation, the first room is free and no more families can be accommodated, so it will stay free. Finally, in the third situation, the next arriving family will definitely get rooms $1+2$, and thus the first room will be occupied. The probability that the first room is occupied is thus $2/3$, and the answer is $666666672$, since $(666666672 \\times 3) \\mod 1000000007 = 2 \\mod 1000000007$.\n\nThe probability for sample case #1 is $1/2$, and for sample cases #2 and #4 it is $1$.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{K} \\leqslant \\mathbf{N}$.\n\n**Small dataset (10 Pts, Test Set 1 - Visible)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 10^{4}$.\n\n**Large dataset (20 Pts, Test Set 2 - Hidden)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 10^{7}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2016 Finals] Family Hotel", "background": "", "description": "You run a hotel with $\\mathbf{N}$ rooms arranged along one long corridor, numbered from 1 to $\\mathbf{N}$ along that corridor. Your guests are big families, and every family asks for exactly two adjacent rooms when they arrive. Two rooms are adjacent if their numbers differ by exactly 1.\n\nAt the start of the day today, your hotel was empty. You have been using the following simple strategy to assign rooms to your guests. As each family arrives, you consider all possible pairs of adjacent rooms that are both free, pick one of those pairs uniformly at random, and assign the two rooms in that pair to the family. New families constantly arrive, one family at a time, but once there are no more pairs of adjacent rooms that are both free, you turn on the NO VACANCY sign and you do not give out any more rooms.\n\nGiven a specific room number, what is the probability that it will be occupied at the time that you turn on the NO VACANCY sign?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line contains two numbers: the number of rooms $\\mathbf{N}$ and the room number $\\mathbf{K}$ that we are interested in.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the sought probability computed modulo $10^9 + 7$, which is defined precisely as follows. Represent the probability that room $\\mathbf{K}$ is occupied as an irreducible fraction $\\frac{p}{q}$. The number $y$ then must satisfy the modular equation $y \\times q \\equiv p \\pmod{10^9 + 7}$, and be between 0 and $10^9 + 6$, inclusive. It can be shown that under the constraints of this problem such a number $y$ always exists and is uniquely determined.", "hint": "**Sample Explanation**\n\nIn sample case #3, there are four rooms and we are looking for probability that the first room is occupied. When the first family arrives, there are 3 possible situations, each with probability $1/3$: occupy rooms $1+2, 2+3$ or $3+4$. In the first situation, the first room is already occupied and will stay occupied. In the second situation, the first room is free and no more families can be accommodated, so it will stay free. Finally, in the third situation, the next arriving family will definitely get rooms $1+2$, and thus the first room will be occupied. The probability that the first room is occupied is thus $2/3$, and the answer is $666666672$, since $(666666672 \\times 3) \\mod 1000000007 = 2 \\mod 1000000007$.\n\nThe probability for sample case #1 is $1/2$, and for sample cases #2 and #4 it is $1$.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{K} \\leqslant \\mathbf{N}$.\n\n**Small dataset (10 Pts, Test Set 1 - Visible)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 10^{4}$.\n\n**Large dataset (20 Pts, Test Set 2 - Hidden)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 10^{7}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2016 Finals] Family Hotel", "background": "", "description": "你经营着一家拥有 $\\mathbf{N}$ 个房间的旅馆，这些房间沿着一条长走廊依次排列，编号为 $1$ 到 $\\mathbf{N}$。你的客人都是大家庭，每个家庭到来时都会要求恰好两个相邻的房间。两个房间如果房号相差恰好为 $1$，则视为相邻。\n\n今天一开始，旅馆是空的。你一直采用如下简单策略为客人分配房间：每当有家庭到来时，你会考虑所有当前仍然空闲且成对相邻的房间组合，从中等概率随机选择一对，将这两个房间分配给该家庭。新家庭会不断到来，每次只来一个，但一旦没有任何成对相邻且都空闲的房间，你就会亮起“无空房”标志，不再接待新客人。\n\n现在，给定一个具体的房间号，问当你亮起“无空房”标志时，这个房间被占用的概率是多少？", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例数量。接下来有 $\\mathbf{T}$ 行，每行包含两个整数：房间总数 $\\mathbf{N}$ 和你关心的房间号 $\\mathbf{K}$。\n", "outputFormat": "对于每组测试用例，输出一行 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为所求概率对 $10^9+7$ 取模后的值，具体定义如下。设房间 $\\mathbf{K}$ 被占用的概率为最简分数 $\\frac{p}{q}$，则 $y$ 应满足 $y \\times q \\equiv p \\pmod{10^9+7}$，且 $y$ 在 $0$ 到 $10^9+6$ 之间。可以证明，在本题约束下，这样的 $y$ 总是存在且唯一。\n", "hint": "**样例解释**\n\n在样例第 3 组中，共有 4 个房间，我们关心第 1 个房间被占用的概率。第一个家庭到来时，有 3 种可能的分配（每种概率为 $1/3$）：入住 $1+2$、$2+3$ 或 $3+4$。第一种情况下，第 1 个房间立即被占用且之后不会再变；第二种情况下，第 1 个房间空着，且无法再安排其他家庭，因此始终空着；第三种情况下，下一个到来的家庭必然入住 $1+2$，从而第 1 个房间也会被占用。因此第 1 个房间被占用的概率为 $2/3$，答案为 $666666672$，因为 $(666666672 \\times 3) \\bmod 1000000007 = 2 \\bmod 1000000007$。\n\n样例第 1 组的概率为 $1/2$，第 2 组和第 4 组的概率均为 $1$。\n\n**限制条件**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$。\n- $1 \\leqslant \\mathbf{K} \\leqslant \\mathbf{N}$。\n\n**小数据集（10 分，测试集 1 - 可见）**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 10^4$。\n\n**大数据集（20 分，测试集 2 - 隐藏）**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 10^7$。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13208", "type": "P", "difficulty": 6, "samples": [["4\n4 100000\n4 300000\n3 300000\n100 499999", "Case #1: 9\nCase #2: 7\nCase #3: 5\nCase #4: 3"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["2016", "数论", "莫比乌斯反演", "容斥原理", "平面几何", "Google Code Jam"], "title": "[GCJ 2016 Finals] Gallery of Pillars", "background": "", "description": "Your friend Cody-Jamal is working on his new artistic installment called \"Gallery of Pillars\". The installment is to be exhibited in a square gallery of $\\mathbf{N}$ by $\\mathbf{N}$ meters. The gallery is divided into $\\mathbf{N}^{2}$ squares of 1 by 1 meter, forming an $\\mathbf{N}$ by $\\mathbf{N}$ matrix. The exact center of the southwest corner cell is called the viewpoint; a person viewing the artwork is supposed to stand there. Each other cell contains a cylindrical pillar. All pillars have two circular bases of radius $\\mathbf{R}$: one resting on the floor, in the center of its corresponding cell, and the other touching the gallery's ceiling. The observer will stand in the viewpoint, observe the $\\mathbf{N}^{2} - 1$ pillars, and marvel.\n\nCody-Jamal is currently scouting venues trying to see how large he can make the value of $\\mathbf{N}$. Also, he has not decided which material the pillars will be made of; it could be concrete, or carbon nanotubes, so the radius $\\mathbf{R}$ of the base of each pillar could vary from 1 micrometer to almost half a meter. Notice that a radius of half a meter would make neighboring pillars touch.\n\nYou, as a trained mathematician, quickly observe that there could be pillars impossible to see from the viewpoint. Cody-Jamal asks your help in determining, for different combinations of $\\mathbf{N}$ and $\\mathbf{R}$, the number of visible pillars. Formally, a pillar is visible if and only if there is a straight line segment that runs from the center of the southwest corner cell (the viewpoint) to any point on the pillar's boundary, and does not touch or intersect any other pillar.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line describes a different test case with two integers $\\mathbf{N}$ and $\\mathbf{R}$. $\\mathbf{N}$ is the number of 1 meter square cells along either dimension of the gallery, and $\\mathbf{R}$ is the radius of each pillar, in micrometers. Thus, $\\mathbf{R} / 10^{6}$ is the radius of each pillar in meters.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of pillars in the installment that are visible from the viewpoint.", "hint": "**Sample Explanation**\n\nThe pictures below illustrate the first two samples (not to scale). In the center of the black circle is the observer. The other circles are pillars, with the visible ones in gray and the not visible ones in red. The blue dotted lines represent some of the unblocked lines of sight; the red dotted lines represent blocked lines of sight (that turn gray at the point at which they are first blocked).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kz9mmqav.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/zbn7wv7d.png)\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{R} < 10^{6} / 2$.\n\n**Small dataset (10 Pts, Test Set 1 - Visible)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 300$.\n\n**Large dataset (30 Pts, Test Set 2 - Hidden)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 10^{9}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2016 Finals] Gallery of Pillars", "background": "", "description": "Your friend Cody-Jamal is working on his new artistic installment called \"Gallery of Pillars\". The installment is to be exhibited in a square gallery of $\\mathbf{N}$ by $\\mathbf{N}$ meters. The gallery is divided into $\\mathbf{N}^{2}$ squares of 1 by 1 meter, forming an $\\mathbf{N}$ by $\\mathbf{N}$ matrix. The exact center of the southwest corner cell is called the viewpoint; a person viewing the artwork is supposed to stand there. Each other cell contains a cylindrical pillar. All pillars have two circular bases of radius $\\mathbf{R}$: one resting on the floor, in the center of its corresponding cell, and the other touching the gallery's ceiling. The observer will stand in the viewpoint, observe the $\\mathbf{N}^{2} - 1$ pillars, and marvel.\n\nCody-Jamal is currently scouting venues trying to see how large he can make the value of $\\mathbf{N}$. Also, he has not decided which material the pillars will be made of; it could be concrete, or carbon nanotubes, so the radius $\\mathbf{R}$ of the base of each pillar could vary from 1 micrometer to almost half a meter. Notice that a radius of half a meter would make neighboring pillars touch.\n\nYou, as a trained mathematician, quickly observe that there could be pillars impossible to see from the viewpoint. Cody-Jamal asks your help in determining, for different combinations of $\\mathbf{N}$ and $\\mathbf{R}$, the number of visible pillars. Formally, a pillar is visible if and only if there is a straight line segment that runs from the center of the southwest corner cell (the viewpoint) to any point on the pillar's boundary, and does not touch or intersect any other pillar.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line describes a different test case with two integers $\\mathbf{N}$ and $\\mathbf{R}$. $\\mathbf{N}$ is the number of 1 meter square cells along either dimension of the gallery, and $\\mathbf{R}$ is the radius of each pillar, in micrometers. Thus, $\\mathbf{R} / 10^{6}$ is the radius of each pillar in meters.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of pillars in the installment that are visible from the viewpoint.", "hint": "**Sample Explanation**\n\nThe pictures below illustrate the first two samples (not to scale). In the center of the black circle is the observer. The other circles are pillars, with the visible ones in gray and the not visible ones in red. The blue dotted lines represent some of the unblocked lines of sight; the red dotted lines represent blocked lines of sight (that turn gray at the point at which they are first blocked).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kz9mmqav.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/zbn7wv7d.png)\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{R} < 10^{6} / 2$.\n\n**Small dataset (10 Pts, Test Set 1 - Visible)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 300$.\n\n**Large dataset (30 Pts, Test Set 2 - Hidden)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 10^{9}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2016 Finals] Gallery of Pillars", "background": "", "description": "你的朋友 Cody-Jamal 正在筹备他的新艺术装置“柱廊美术馆”。这个装置将在一个边长为 $\\mathbf{N}$ 米的正方形美术馆中展出。美术馆被划分为 $\\mathbf{N}^2$ 个 $1 \\times 1$ 米的方格，组成一个 $\\mathbf{N} \\times \\mathbf{N}$ 的矩阵。西南角单元格的正中心被称为“观景点”；观众应站在这里欣赏作品。其余每个格子里都竖立着一根圆柱形立柱。所有立柱都有两个半径为 $\\mathbf{R}$ 的圆形底面：一个底面落在地板上，位于对应格子的正中心，另一个底面顶到美术馆的天花板。观众将站在观景点，欣赏 $\\mathbf{N}^2-1$ 根立柱。\n\nCody-Jamal 目前正在考察场地，试图确定 $\\mathbf{N}$ 的最大可能值。同时，他还没有决定立柱的材质——可能是混凝土，也可能是碳纳米管，因此每根立柱的底面半径 $\\mathbf{R}$ 可能从 1 微米到接近半米不等。注意，如果半径达到半米，相邻的立柱就会相互接触。\n\n你作为一名训练有素的数学家，很快就发现有些立柱可能无法从观景点看到。Cody-Jamal 请你帮忙，判断在不同的 $\\mathbf{N}$ 和 $\\mathbf{R}$ 组合下，从观景点能看到多少根立柱。形式化地说，某根立柱是可见的，当且仅当存在一条从西南角单元格中心（观景点）到该立柱边界上任意一点的直线段，且这条线段不与其他任何立柱相交或接触。", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例数量。接下来有 $\\mathbf{T}$ 行，每行描述一个测试用例，包含两个整数 $\\mathbf{N}$ 和 $\\mathbf{R}$。$\\mathbf{N}$ 表示美术馆在每个方向上的方格数，$\\mathbf{R}$ 表示每根立柱的半径，单位为微米。因此，每根立柱的半径为 $\\mathbf{R}/10^6$ 米。\n", "outputFormat": "对于每组测试用例，输出一行 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为从观景点能看到的立柱数量。\n", "hint": "**样例解释**\n\n下图展示了前两个样例的示意（非真实比例）。黑色圆圈中心为观众，其余圆圈为立柱，灰色为可见立柱，红色为不可见立柱。蓝色虚线表示部分无遮挡的视线，红色虚线表示被阻挡的视线（在首次被阻挡处变为灰色）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kz9mmqav.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/zbn7wv7d.png)\n\n**限制条件**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$。\n- $1 \\leqslant \\mathbf{R} < 10^6/2$。\n\n**小数据集（10 分，测试集 1 - 可见）**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 300$。\n\n**大数据集（30 分，测试集 2 - 隐藏）**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 10^9$。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13209", "type": "P", "difficulty": 7, "samples": [["3\n6 13 15\n#############\n#S..#..##...#\n###.##..#.#F#\n#...##.##.###\n#.#.........#\n#############\n5 8 3\n########\n#S.....#\n####...#\n#F.....#\n########\n4 10 11\n##########\n#S#...#.F#\n#...#...##\n##########", "Case #1: POSSIBLE\n#############\n#S..#..##...#\n###.##..#.#F#\n#...##.##.#.#\n#.#.........#\n#############\nCase #2: IMPOSSIBLE\nCase #3: POSSIBLE\n##########\n#S#...#.F#\n#...#...##\n##########"]], "limits": {"time": [15000, 75000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2016", "Special Judge", "广度优先搜索 BFS", "构造", "Ad-hoc", "Google Code Jam"], "title": "[GCJ 2016 Finals] Map Reduce", "background": "", "description": "Ben the brilliant video game designer is trying to design maps for his upcoming augmented-reality mobile game. Recently, he has created a map which is represented as a matrix of $\\mathbf{R}$ rows and $\\mathbf{C}$ columns. The map consists of a bunch of `.` characters representing empty squares, a bunch of `#` characters representing impassable walls, a single start position represented by `S` and a single finish position represented by `F`. For example, the map could look like:\n\n```\n#############\n#S..#..##...#\n###.##..#.#F#\n#...##.##.###\n#.#.........#\n#############\n```\n\nIn Ben's game, a path is a sequence of steps (up, down, left or right) to go from one cell to another while not going through any impassable walls.\n\nBen considers a good map to have the following properties:\n\n- There is a path between any two empty squares (including the start and finish positions).\n- To preserve structural integrity, impassable walls must meet at edges and not just corners. For every $2 \\times 2$ region in the map, if the region contains exactly two walls, then those walls are either in the same row or the same column. In other words, there is no $2 \\times 2$ region where the walls are in one of these two configurations:\n  ```\n  #.   .#\n  .#   #.\n  ```\n- The boundary consists of only impassable walls. A cell is considered part of the boundary if it is in the uppermost/lowermost rows or if it is in the leftmost/rightmost columns.\n\nThe distance of the shortest path is the minimum number of steps required to reach the finish position from the start position. For instance, the shortest path in the above example takes $17$ steps.\n\nBeing such a clever mapmaker, Ben realized that he has created a map that is too hard for his friends to solve. He would like to reduce its difficulty by removing some of the impassable walls. In particular, he wants to know whether it is possible to remove zero or more impassable walls from his map such that the shortest path from start to finish takes exactly $\\mathbf{D}$ steps, and that the resulting map is still good. Note that it is not enough to simply find a path with $\\mathbf{D}$ steps; $\\mathbf{D}$ must be the number of steps in the shortest path.\n\nFor example, if $\\mathbf{D} = 15$, we could remove the impassable wall directly below the finish position to get a good solution.\n\n```\n#############\n#S..#..##...#\n###.##..#.#F#\n#...##.##.#.#\n#.#.........#\n#############\n```\n\nThere is no solution if $\\mathbf{D}=5$.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing three space-separated integers $\\mathbf{R}$, $\\mathbf{C}$ and $\\mathbf{D}$: the number of rows and columns in the map, and the desired number of steps in the shortest path from start to finish after possibly removing impassable walls. $\\mathbf{R}$ lines follow, each consisting of $\\mathbf{C}$ characters (either ., #, S or F) representing Ben's map.\n\nIt is guaranteed that the map is good, as described in the problem statement.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the word POSSIBLE or IMPOSSIBLE, depending on whether the shortest path can be made equal to $\\mathbf{D}$ by removing some number of walls such that the map is still good. If it is possible, output $\\mathbf{R}$ more lines containing $\\mathbf{C}$ characters each, representing the new map. In your output, replace the # characters for removed walls (if any) with . characters.\n\nIf multiple solutions are possible, you may output any of them.", "hint": "**Sample Explanation**\n\nThe sample output displays one set of answers to the sample cases. Other answers may be possible.\n\nSample case #1 is the example in the problem statement.\n\nIn sample case #2, it is possible to remove walls to make the distance of the shortest path either 2 or 4, for example. However, there is no way to make the distance of the shortest path exactly 3.\n\nIn sample case #3, the shortest path already takes 11 steps to begin with, so there is no need to reduce the difficulty of the map.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- Each test case contains exactly one $\\mathbf{S}$ and exactly one $\\mathbf{F}$.\n- The input file is at most 3MB in size.\n\n**Small dataset (Test Set 1 - Visible)**\n\n- Time limit: ~~60~~ 15 seconds.\n- $3 \\leq \\mathbf{R} \\leq 40$.\n- $3 \\leq \\mathbf{C} \\leq 40$.\n- $1 \\leq \\mathbf{D} \\leq 1600$.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- Time limit: ~~300~~ 75 seconds.\n- $3 \\leq \\mathbf{R} \\leq 1000$.\n- $3 \\leq \\mathbf{C} \\leq 1000$.\n- $1 \\leq \\mathbf{D} \\leq 10^6$.\n- NOTE: The Large output breaks the usual cap on Code Jam output size, but you can upload it as normal.", "locale": "en", "translations": {"en": {"title": "[GCJ 2016 Finals] Map Reduce", "background": "", "description": "Ben the brilliant video game designer is trying to design maps for his upcoming augmented-reality mobile game. Recently, he has created a map which is represented as a matrix of $\\mathbf{R}$ rows and $\\mathbf{C}$ columns. The map consists of a bunch of `.` characters representing empty squares, a bunch of `#` characters representing impassable walls, a single start position represented by `S` and a single finish position represented by `F`. For example, the map could look like:\n\n```\n#############\n#S..#..##...#\n###.##..#.#F#\n#...##.##.###\n#.#.........#\n#############\n```\n\nIn Ben's game, a path is a sequence of steps (up, down, left or right) to go from one cell to another while not going through any impassable walls.\n\nBen considers a good map to have the following properties:\n\n- There is a path between any two empty squares (including the start and finish positions).\n- To preserve structural integrity, impassable walls must meet at edges and not just corners. For every $2 \\times 2$ region in the map, if the region contains exactly two walls, then those walls are either in the same row or the same column. In other words, there is no $2 \\times 2$ region where the walls are in one of these two configurations:\n  ```\n  #.   .#\n  .#   #.\n  ```\n- The boundary consists of only impassable walls. A cell is considered part of the boundary if it is in the uppermost/lowermost rows or if it is in the leftmost/rightmost columns.\n\nThe distance of the shortest path is the minimum number of steps required to reach the finish position from the start position. For instance, the shortest path in the above example takes $17$ steps.\n\nBeing such a clever mapmaker, Ben realized that he has created a map that is too hard for his friends to solve. He would like to reduce its difficulty by removing some of the impassable walls. In particular, he wants to know whether it is possible to remove zero or more impassable walls from his map such that the shortest path from start to finish takes exactly $\\mathbf{D}$ steps, and that the resulting map is still good. Note that it is not enough to simply find a path with $\\mathbf{D}$ steps; $\\mathbf{D}$ must be the number of steps in the shortest path.\n\nFor example, if $\\mathbf{D} = 15$, we could remove the impassable wall directly below the finish position to get a good solution.\n\n```\n#############\n#S..#..##...#\n###.##..#.#F#\n#...##.##.#.#\n#.#.........#\n#############\n```\n\nThere is no solution if $\\mathbf{D}=5$.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing three space-separated integers $\\mathbf{R}$, $\\mathbf{C}$ and $\\mathbf{D}$: the number of rows and columns in the map, and the desired number of steps in the shortest path from start to finish after possibly removing impassable walls. $\\mathbf{R}$ lines follow, each consisting of $\\mathbf{C}$ characters (either ., #, S or F) representing Ben's map.\n\nIt is guaranteed that the map is good, as described in the problem statement.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the word POSSIBLE or IMPOSSIBLE, depending on whether the shortest path can be made equal to $\\mathbf{D}$ by removing some number of walls such that the map is still good. If it is possible, output $\\mathbf{R}$ more lines containing $\\mathbf{C}$ characters each, representing the new map. In your output, replace the # characters for removed walls (if any) with . characters.\n\nIf multiple solutions are possible, you may output any of them.", "hint": "**Sample Explanation**\n\nThe sample output displays one set of answers to the sample cases. Other answers may be possible.\n\nSample case #1 is the example in the problem statement.\n\nIn sample case #2, it is possible to remove walls to make the distance of the shortest path either 2 or 4, for example. However, there is no way to make the distance of the shortest path exactly 3.\n\nIn sample case #3, the shortest path already takes 11 steps to begin with, so there is no need to reduce the difficulty of the map.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- Each test case contains exactly one $\\mathbf{S}$ and exactly one $\\mathbf{F}$.\n- The input file is at most 3MB in size.\n\n**Small dataset (Test Set 1 - Visible)**\n\n- Time limit: ~~60~~ 15 seconds.\n- $3 \\leq \\mathbf{R} \\leq 40$.\n- $3 \\leq \\mathbf{C} \\leq 40$.\n- $1 \\leq \\mathbf{D} \\leq 1600$.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- Time limit: ~~300~~ 75 seconds.\n- $3 \\leq \\mathbf{R} \\leq 1000$.\n- $3 \\leq \\mathbf{C} \\leq 1000$.\n- $1 \\leq \\mathbf{D} \\leq 10^6$.\n- NOTE: The Large output breaks the usual cap on Code Jam output size, but you can upload it as normal.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2016 Finals] Map Reduce", "background": "", "description": "天才游戏设计师 Ben 正在为他即将发布的增强现实手游设计地图。最近，他制作了一张地图，用一个 $\\mathbf{R}$ 行 $\\mathbf{C}$ 列的矩阵表示。地图由若干 `.` 字符（表示空地）、若干 `#` 字符（表示不可通过的墙）、一个起点 `S` 和一个终点 `F` 组成。例如，地图可能如下所示：\n\n```\n#############\n#S..#..##...#\n###.##..#.#F#\n#...##.##.###\n#.#.........#\n#############\n```\n\n在 Ben 的游戏中，一条路径是一系列上下左右的步伐，从一个格子走到另一个格子，且不能经过任何不可通过的墙。\n\nBen 认为一张好地图需要满足以下条件：\n\n- 任意两个空地（包括起点和终点）之间都存在一条路径。\n- 为了保证结构完整性，不可通过的墙必须在边上相连，而不能只是通过角相连。对于地图中的任意 $2 \\times 2$ 区域，如果该区域恰好有两堵墙，这两堵墙必须在同一行或同一列。换句话说，不能存在如下两种 $2 \\times 2$ 区域的墙分布：\n  ```\n  #. .#\n  .# #.\n  ```\n\n- 地图的边界只能由不可通过的墙组成。一个格子被认为是边界，如果它在最上/最下行，或最左/最右列。\n\n最短路径长度指的是从起点到终点所需的最少步数。例如，上述例子的最短路径长度为 $17$ 步。\n\n作为如此聪明的制图者，Ben 发现他设计的这张地图对朋友们来说太难了。他希望通过移除一些不可通过的墙来降低难度。具体来说，他想知道是否可以移除零个或若干墙，使得从起点到终点的最短路径恰好为 $\\mathbf{D}$ 步，并且修改后的地图依然是好地图。注意，仅仅找到一条长度为 $\\mathbf{D}$ 的路径是不够的，$\\mathbf{D}$ 必须是最短路径长度。\n\n例如，如果 $\\mathbf{D}=15$，我们可以移除终点正下方的一堵墙，得到一个合法解：\n\n```\n#############\n#S..#..##...#\n###.##..#.#F#\n#...##.##.#.#\n#.#.........#\n#############\n```\n\n如果 $\\mathbf{D}=5$，则没有解。", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例组数。接下来有 $\\mathbf{T}$ 组测试用例。每组数据第一行为三个空格分隔的整数 $\\mathbf{R}$、$\\mathbf{C}$ 和 $\\mathbf{D}$，分别表示地图的行数、列数，以及期望的最短路径长度。接下来 $\\mathbf{R}$ 行，每行包含 $\\mathbf{C}$ 个字符（为 `.`、`#`、`S` 或 `F`），表示 Ben 的地图。\n\n保证输入地图均为好地图（如题面描述）。", "outputFormat": "对于每组测试用例，输出一行 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为 POSSIBLE 或 IMPOSSIBLE，分别表示能否通过移除若干堵墙（可为零）使得最短路径长度恰好为 $\\mathbf{D}$，且修改后的地图依然是好地图。如果可行，继续输出 $\\mathbf{R}$ 行，每行 $\\mathbf{C}$ 个字符，表示新的地图。输出时，移除的墙用 `.` 替换原有的 `#`。\n\n若有多种方案，可输出任意一种。", "hint": "**样例解释**\n\n样例输出展示了一组可能的答案，其他答案也可能是正确的。\n\n样例第 1 组即为题面中的例子。\n\n样例第 2 组中，可以移除一些墙使最短路径长度变为 2 或 4，但无法使其恰好为 3。\n\n样例第 3 组中，最短路径本身就是 11 步，因此无需移除墙。\n\n**限制条件**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 每组数据恰好有一个 $\\mathbf{S}$ 和一个 $\\mathbf{F}$。\n- 输入文件大小不超过 3MB。\n\n**小数据集（测试集 1 - 可见）**\n\n- 时间限制：~~60~~ 15 秒。\n- $3 \\leq \\mathbf{R} \\leq 40$。\n- $3 \\leq \\mathbf{C} \\leq 40$。\n- $1 \\leq \\mathbf{D} \\leq 1600$。\n\n**大数据集（测试集 2 - 隐藏）**\n\n- 时间限制：~~300~~ 75 秒。\n- $3 \\leq \\mathbf{R} \\leq 1000$。\n- $3 \\leq \\mathbf{C} \\leq 1000$。\n- $1 \\leq \\mathbf{D} \\leq 10^6$。\n- 注意：大数据集的输出突破了 Code Jam 通常的输出大小限制，但你可以正常上传。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13210", "type": "P", "difficulty": 7, "samples": [["2\n1 1.00 -2.00\n0.00\n2 0.00 0.00\n3.00 -3.00", "Case #1: 21.806\nCase #2: 21.706"]], "limits": {"time": [30000, 60000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2016", "Special Judge", "爬山算法 Local search", "微积分", "梯度下降法", "Google Code Jam"], "title": "[GCJ 2016 Finals] Radioactive Islands", "background": "", "description": "You are steering a boat from the coordinates $(-10, A)$ to the coordinates $(10, B)$. The coordinates are measured in kilometers, and your boat travels at a constant speed of 1 kilometer per hour. You have full control over the path the boat takes. We model the boat as a single point.\n\nThere are $\\mathbf{N}$ islands in the area; we model them as single points. The i-th island is at the coordinates ($0$, $\\mathbf{C}_{\\mathbf{i}}$).\n\nThe area is radioactive, and you constantly receive 1 microsievert per hour of radiation from the general environment, no matter where you are. Moreover, the islands themselves are radioactive, and you constantly receive additional radiation at a rate of $(\\mathbf{D}_{\\mathbf{i}})^{-2}$ microsieverts per hour from the i-th island, where $\\mathbf{D}_{\\mathbf{i}}$ is your current distance (in kilometers) from the i-th island. (Formally: let $\\mathbf{D}_{\\mathbf{i}}(\\mathbf{t})$ be your distance from the i-th island as a function of time $\\mathbf{t}$, and $\\mathbf{X}$ be the total time your journey takes. Then the total radiation received from the i-th island is the definite integral from $0$ to $\\mathbf{X}$ of $\\mathbf{D}_{\\mathbf{i}}(\\mathbf{t})^{-2}$.) You can get as close to an island as you would like, as long as you do not match its exact coordinates.\n\nFind the minimum total radiation dose that you can receive if you plot your course optimally.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$; $\\mathbf{T}$ test cases follow. Each test cases consists of two lines. The first line of a test case consists of three values: an integer $\\mathbf{N}$, and two floating-point numbers $\\mathbf{A}$ and $\\mathbf{B}$, as described in the statement above. The second line of a test case consists of $\\mathbf{N}$ floating-point numbers $\\mathbf{C}_{\\mathbf{i}}$; the i-th of these numbers gives the y coordinate of the i-th island.\n\nAll floating-point numbers are specified to exactly two decimal places.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathbf{x}$ is the test case number (starting from 1) and $\\mathbf{y}$ is the minimum radiation dose (in microsieverts) received while completing the journey.\n\n$\\mathbf{y}$ will be considered correct if it is within an absolute or relative error of $10^{-3}$ of the correct answer. See the FAQ for an explanation of what that means, and what formats of real numbers we accept.", "hint": "**Sample Explantion**\n\nHere is a diagram of the optimal path for sample case #1. We have enlarged the island to make it more visible, but remember to treat it as a single point.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/23t3oyj6.png)\n\n**Limits**\n\n- $-10.00 \\leq \\mathbf{A} \\leq 10.00$.\n- $-10.00 \\leq \\mathbf{B} \\leq 10.00$.\n- $-10.00 \\leq \\mathbf{C}_{\\mathbf{i}} \\leq 10.00$, for all $\\mathbf{i}$.\n- $\\mathbf{C}_{\\mathbf{i}} \\neq \\mathbf{C}_{\\mathbf{j}}$, for all $\\mathbf{i} \\neq \\mathbf{j}$.\n\n**Small dataset (25 Pts, Test Set 1 - Visible)**\n\n- Time limit: ~~120~~ 30 seconds.\n- $\\mathbf{T} \\leq 20$;\n- $\\mathbf{N} = 1$.\n\n**Large dataset (25 Pts, Test Set 2 - Hidden)**\n\n- Time limit: ~~240~~ 60 seconds.\n- $\\mathbf{T} \\leq 50$;\n- $1 \\leq \\mathbf{N} \\leq 2$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2016 Finals] Radioactive Islands", "background": "", "description": "You are steering a boat from the coordinates $(-10, A)$ to the coordinates $(10, B)$. The coordinates are measured in kilometers, and your boat travels at a constant speed of 1 kilometer per hour. You have full control over the path the boat takes. We model the boat as a single point.\n\nThere are $\\mathbf{N}$ islands in the area; we model them as single points. The i-th island is at the coordinates ($0$, $\\mathbf{C}_{\\mathbf{i}}$).\n\nThe area is radioactive, and you constantly receive 1 microsievert per hour of radiation from the general environment, no matter where you are. Moreover, the islands themselves are radioactive, and you constantly receive additional radiation at a rate of $(\\mathbf{D}_{\\mathbf{i}})^{-2}$ microsieverts per hour from the i-th island, where $\\mathbf{D}_{\\mathbf{i}}$ is your current distance (in kilometers) from the i-th island. (Formally: let $\\mathbf{D}_{\\mathbf{i}}(\\mathbf{t})$ be your distance from the i-th island as a function of time $\\mathbf{t}$, and $\\mathbf{X}$ be the total time your journey takes. Then the total radiation received from the i-th island is the definite integral from $0$ to $\\mathbf{X}$ of $\\mathbf{D}_{\\mathbf{i}}(\\mathbf{t})^{-2}$.) You can get as close to an island as you would like, as long as you do not match its exact coordinates.\n\nFind the minimum total radiation dose that you can receive if you plot your course optimally.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$; $\\mathbf{T}$ test cases follow. Each test cases consists of two lines. The first line of a test case consists of three values: an integer $\\mathbf{N}$, and two floating-point numbers $\\mathbf{A}$ and $\\mathbf{B}$, as described in the statement above. The second line of a test case consists of $\\mathbf{N}$ floating-point numbers $\\mathbf{C}_{\\mathbf{i}}$; the i-th of these numbers gives the y coordinate of the i-th island.\n\nAll floating-point numbers are specified to exactly two decimal places.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathbf{x}$ is the test case number (starting from 1) and $\\mathbf{y}$ is the minimum radiation dose (in microsieverts) received while completing the journey.\n\n$\\mathbf{y}$ will be considered correct if it is within an absolute or relative error of $10^{-3}$ of the correct answer. See the FAQ for an explanation of what that means, and what formats of real numbers we accept.", "hint": "**Sample Explantion**\n\nHere is a diagram of the optimal path for sample case #1. We have enlarged the island to make it more visible, but remember to treat it as a single point.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/23t3oyj6.png)\n\n**Limits**\n\n- $-10.00 \\leq \\mathbf{A} \\leq 10.00$.\n- $-10.00 \\leq \\mathbf{B} \\leq 10.00$.\n- $-10.00 \\leq \\mathbf{C}_{\\mathbf{i}} \\leq 10.00$, for all $\\mathbf{i}$.\n- $\\mathbf{C}_{\\mathbf{i}} \\neq \\mathbf{C}_{\\mathbf{j}}$, for all $\\mathbf{i} \\neq \\mathbf{j}$.\n\n**Small dataset (25 Pts, Test Set 1 - Visible)**\n\n- Time limit: ~~120~~ 30 seconds.\n- $\\mathbf{T} \\leq 20$;\n- $\\mathbf{N} = 1$.\n\n**Large dataset (25 Pts, Test Set 2 - Hidden)**\n\n- Time limit: ~~240~~ 60 seconds.\n- $\\mathbf{T} \\leq 50$;\n- $1 \\leq \\mathbf{N} \\leq 2$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2016 Finals] Radioactive Islands", "background": "", "description": "你正驾驶一艘船，从坐标 $(-10, A)$ 出发，前往坐标 $(10, B)$。所有坐标单位均为千米，且你的船以恒定速度 1 千米/小时行驶。你可以完全自主规划航线。我们将船视为一个点。\n\n该区域内有 $\\mathbf{N}$ 座岛屿；每座岛屿也被视为一个点。第 $i$ 座岛屿位于 $(0, \\mathbf{C}_i)$。\n\n该区域存在放射性，无论你身处何处，每小时都会受到 1 微西弗的环境辐射。此外，每座岛屿本身也具有放射性，你每小时还会从第 $i$ 座岛屿额外受到 $(\\mathbf{D}_i)^{-2}$ 微西弗的辐射，其中 $\\mathbf{D}_i$ 是你当前与第 $i$ 座岛屿的距离（单位：千米）。（形式化地说：设 $\\mathbf{D}_i(\\mathbf{t})$ 为你在时刻 $\\mathbf{t}$ 与第 $i$ 座岛屿的距离，$\\mathbf{X}$ 为你完成旅程所需的总时间。那么你从第 $i$ 座岛屿获得的总辐射量为 $\\int_0^\\mathbf{X} \\mathbf{D}_i(\\mathbf{t})^{-2} d\\mathbf{t}$。）你可以任意接近某个岛屿，只要不与其精确重合。\n\n请问，如果你最优规划航线，你能收到的最小总辐射剂量是多少？", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例数。接下来有 $\\mathbf{T}$ 组测试用例，每组包含两行。每组的第一行包含三个值：一个整数 $\\mathbf{N}$，以及两个浮点数 $\\mathbf{A}$ 和 $\\mathbf{B}$，意义如上文所述。第二行包含 $\\mathbf{N}$ 个浮点数 $\\mathbf{C}_i$，第 $i$ 个数表示第 $i$ 座岛屿的纵坐标。\n\n所有浮点数精确到小数点后两位。", "outputFormat": "对于每组测试用例，输出一行 `Case #x: y`，其中 $\\mathbf{x}$ 为测试用例编号（从 1 开始），$\\mathbf{y}$ 为你在完成航行过程中能收到的最小总辐射剂量（单位：微西弗）。\n\n如果 $\\mathbf{y}$ 与正确答案的绝对误差或相对误差不超过 $10^{-3}$，则视为正确。", "hint": "**样例解释**\n\n下图展示了样例第 1 组的最优路径。我们已将岛屿放大以便观察，但在计算时应视为一个点。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/23t3oyj6.png)\n\n**限制条件**\n\n- $-10.00 \\leq \\mathbf{A} \\leq 10.00$。\n- $-10.00 \\leq \\mathbf{B} \\leq 10.00$。\n- 对所有 $i$，$-10.00 \\leq \\mathbf{C}_i \\leq 10.00$。\n- 对所有 $i \\neq j$，$\\mathbf{C}_i \\neq \\mathbf{C}_j$。\n\n**小数据集（25 分，测试集 1 - 可见）**\n\n- 时间限制：~~120~~ 30 秒。\n- $\\mathbf{T} \\leq 20$；\n- $\\mathbf{N} = 1$。\n\n**大数据集（25 分，测试集 2 - 隐藏）**\n\n- 时间限制：~~240~~ 60 秒。\n- $\\mathbf{T} \\leq 50$；\n- $1 \\leq \\mathbf{N} \\leq 2$。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13211", "type": "P", "difficulty": 2, "samples": [["4\n4 11111\n1 09\n5 110011\n0 1", "Case #1: 0\nCase #2: 1\nCase #3: 2\nCase #4: 0"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2015", "Google Code Jam"], "title": "[GCJ 2015 Qualification] Standing Ovation", "background": "", "description": "It's opening night at the opera, and your friend is the prima donna (the lead female singer). You will not be in the audience, but you want to make sure she receives a standing ovation -- with every audience member standing up and clapping their hands for her.\n\nInitially, the entire audience is seated. Everyone in the audience has a *shyness level*. An audience member with shyness level $\\mathbf{S}_{\\mathbf{i}}$ will wait until at least $\\mathbf{S}_{\\mathbf{i}}$ other audience members have already stood up to clap, and if so, she will immediately stand up and clap. If $\\mathbf{S}_{\\mathbf{i}} = 0$, then the audience member will always stand up and clap immediately, regardless of what anyone else does. For example, an audience member with $\\mathbf{S}_{\\mathbf{i}} = 2$ will be seated at the beginning, but will stand up to clap later after she sees at least two other people standing and clapping.\n\nYou know the shyness level of everyone in the audience, and you are prepared to invite additional friends of the prima donna to be in the audience to ensure that everyone in the crowd stands up and claps in the end. Each of these friends may have any shyness value that you wish, not necessarily the same. What is the minimum number of friends that you need to invite to guarantee a standing ovation?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each consists of one line with $\\mathbf{S}_{\\text {max }}$, the maximum shyness level of the shyest person in the audience, followed by a string of $\\mathbf{S}_{\\text {max }} + 1$ single digits. The $k$th digit of this string (counting starting from 0) represents how many people in the audience have shyness level $\\mathbf{k}$. For example, the string \"409\" would mean that there were four audience members with $\\mathbf{S}_{\\mathbf{i}} = 0$ and nine audience members with $\\mathbf{S}_{\\mathbf{i}} = 2$ (and none with $\\mathbf{S}_{\\mathbf{i}} = 1$ or any other value). Note that there will initially always be between 0 and 9 people with each shyness level.\n\nThe string will never end in a 0. Note that this implies that there will always be at least one person in the audience.", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1) and y is the minimum number of friends you must invite.", "hint": "**Sample Explanation**\n\nIn Case #1, the audience will eventually produce a standing ovation on its own, without you needing to add anyone -- first the audience member with $\\mathbf{S}_{\\mathbf{i}} = 0$ will stand up, then the audience member with $\\mathbf{S}_{\\mathbf{i}} = 1$ will stand up, etc.\n\nIn Case #2, a friend with $\\mathbf{S}_{\\mathbf{i}} = 0$ must be invited, but that is enough to get the entire audience to stand up.\n\nIn Case #3, one optimal solution is to add two audience members with $\\mathbf{S}_{\\mathbf{i}} = 2$.\n\nIn Case #4, there is only one audience member and he will stand up immediately. No friends need to be invited.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\n**Small dataset(7 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $0 \\leq \\mathbf{S}_{\\text{max}} \\leq 6$.\n\n**Large dataset(10 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.\n- $0 \\leq \\mathbf{S}_{\\text{max}} \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2015 Qualification] Standing Ovation", "background": "", "description": "It's opening night at the opera, and your friend is the prima donna (the lead female singer). You will not be in the audience, but you want to make sure she receives a standing ovation -- with every audience member standing up and clapping their hands for her.\n\nInitially, the entire audience is seated. Everyone in the audience has a *shyness level*. An audience member with shyness level $\\mathbf{S}_{\\mathbf{i}}$ will wait until at least $\\mathbf{S}_{\\mathbf{i}}$ other audience members have already stood up to clap, and if so, she will immediately stand up and clap. If $\\mathbf{S}_{\\mathbf{i}} = 0$, then the audience member will always stand up and clap immediately, regardless of what anyone else does. For example, an audience member with $\\mathbf{S}_{\\mathbf{i}} = 2$ will be seated at the beginning, but will stand up to clap later after she sees at least two other people standing and clapping.\n\nYou know the shyness level of everyone in the audience, and you are prepared to invite additional friends of the prima donna to be in the audience to ensure that everyone in the crowd stands up and claps in the end. Each of these friends may have any shyness value that you wish, not necessarily the same. What is the minimum number of friends that you need to invite to guarantee a standing ovation?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each consists of one line with $\\mathbf{S}_{\\text {max }}$, the maximum shyness level of the shyest person in the audience, followed by a string of $\\mathbf{S}_{\\text {max }} + 1$ single digits. The $k$th digit of this string (counting starting from 0) represents how many people in the audience have shyness level $\\mathbf{k}$. For example, the string \"409\" would mean that there were four audience members with $\\mathbf{S}_{\\mathbf{i}} = 0$ and nine audience members with $\\mathbf{S}_{\\mathbf{i}} = 2$ (and none with $\\mathbf{S}_{\\mathbf{i}} = 1$ or any other value). Note that there will initially always be between 0 and 9 people with each shyness level.\n\nThe string will never end in a 0. Note that this implies that there will always be at least one person in the audience.", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1) and y is the minimum number of friends you must invite.", "hint": "**Sample Explanation**\n\nIn Case #1, the audience will eventually produce a standing ovation on its own, without you needing to add anyone -- first the audience member with $\\mathbf{S}_{\\mathbf{i}} = 0$ will stand up, then the audience member with $\\mathbf{S}_{\\mathbf{i}} = 1$ will stand up, etc.\n\nIn Case #2, a friend with $\\mathbf{S}_{\\mathbf{i}} = 0$ must be invited, but that is enough to get the entire audience to stand up.\n\nIn Case #3, one optimal solution is to add two audience members with $\\mathbf{S}_{\\mathbf{i}} = 2$.\n\nIn Case #4, there is only one audience member and he will stand up immediately. No friends need to be invited.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\n**Small dataset(7 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $0 \\leq \\mathbf{S}_{\\text{max}} \\leq 6$.\n\n**Large dataset(10 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.\n- $0 \\leq \\mathbf{S}_{\\text{max}} \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2015 Qualification] Standing Ovation", "background": null, "description": "今晚是歌剧的首演，你的朋友是女主角（首席女歌手）。你不会在观众席中，但你希望确保她能获得全场起立鼓掌——让每一位观众都站起来为她鼓掌。\n\n最初，所有观众都坐着。每位观众都有一个“害羞等级”。害羞等级为 $S_i$ 的观众会等到至少有 $S_i$ 位其他观众已经站起来鼓掌后，才会立即站起来鼓掌。如果 $S_i = 0$，那么这位观众会无论如何都立刻站起来鼓掌。例如，害羞等级为 $S_i = 2$ 的观众一开始会坐着，只有在看到至少有两个人已经站起来鼓掌后，她才会站起来鼓掌。\n\n你知道所有观众的害羞等级，并且你可以邀请额外的朋友加入观众席，以确保最终所有人都能站起来鼓掌。你可以为这些朋友分配任意害羞等级，不必相同。请问你至少需要邀请多少位朋友，才能保证全场起立鼓掌？", "inputFormat": "输入的第一行包含测试用例的数量 $T$。接下来有 $T$ 组测试数据。每组测试数据包含一行，首先是一个整数 $S_{\\text{max}}$，表示观众中最害羞的人的害羞等级，然后是一个长度为 $S_{\\text{max}} + 1$ 的数字字符串。该字符串的第 $k$ 个数字（从 0 开始计数）表示有多少位观众的害羞等级为 $k$。例如，字符串 \"409\" 表示有 4 位观众的害羞等级为 0，9 位观众的害羞等级为 2（害羞等级为 1 及其他等级的人数为 0）。注意，每个害羞等级的人数范围始终在 0 到 9 之间。\n\n该字符串不会以 0 结尾。这意味着观众中至少有一人。", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #x: y\"，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是你需要邀请的最少朋友数。", "hint": "**样例解释**\n\n在第 1 组样例中，观众最终会自行完成全场起立鼓掌，无需你邀请任何人——首先害羞等级为 0 的观众会站起来，然后害羞等级为 1 的观众会站起来，依此类推。\n\n在第 2 组样例中，必须邀请一位害羞等级为 0 的朋友，但这样就足以让所有观众都站起来。\n\n在第 3 组样例中，一种最优方案是添加两位害羞等级为 2 的观众。\n\n在第 4 组样例中，只有一位观众，他会立刻站起来。无需邀请任何朋友。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n\n**小数据集（7 分）**\n\n- 时间限制：5 秒。\n- $0 \\leq S_{\\text{max}} \\leq 6$。\n\n**大数据集（10 分）**\n\n- 时间限制：10 秒。\n- $0 \\leq S_{\\text{max}} \\leq 1000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13212", "type": "P", "difficulty": 3, "samples": [["3\n1\n3\n4\n1 2 1 2\n1\n4", "Case #1: 3\nCase #2: 2\nCase #3: 3"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["数学", "贪心", "2015", "整除分块", "Google Code Jam"], "title": "[GCJ 2015 Qualification] Infinite House of Pancakes", "background": "", "description": "At the Infinite House of Pancakes, there are only finitely many pancakes, but there are infinitely many diners who would be willing to eat them! When the restaurant opens for breakfast, among the infinitely many diners, exactly $\\mathbf{D}$ have non-empty plates; the $i$th of these has $\\mathbf{P}_{\\mathbf{i}}$ pancakes on his or her plate. Everyone else has an empty plate.\n\nNormally, every minute, every diner with a non-empty plate will eat one pancake from his or her plate. However, some minutes may be *special*. In a special minute, the head server asks for the diners' attention, chooses a diner with a non-empty plate, and carefully lifts some number of pancakes off of that diner's plate and moves those pancakes onto one other diner's (empty or non-empty) plate. No diners eat during a special minute, because it would be rude.\n\nYou are the head server on duty this morning, and it is your job to decide which minutes, if any, will be special, and which pancakes will move where. That is, every minute, you can decide to either do nothing and let the diners eat, or declare a special minute and interrupt the diners to make a single movement of one or more pancakes, as described above.\n\nBreakfast ends when there are no more pancakes left to eat. How quickly can you make that happen?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each consists of one line with $\\mathbf{D}$, the number of diners with non-empty plates, followed by another line with $\\mathbf{D}$ space-separated integers representing the numbers of pancakes on those diners' plates.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where x is the test case number (starting from 1) and y is the smallest number of minutes needed to finish the breakfast.", "hint": "**Sample Explanation**\n\nIn Case #1, one diner starts with 3 pancakes and everyone else's plate is empty. One optimal strategy is:\n\nMinute 1: Do nothing. The diner will eat one pancake.\n\nMinute 2 (special): Interrupt and move one pancake from that diner's stack onto another diner's empty plate. (Remember that there are always infinitely many diners with empty plates available, no matter how many diners start off with pancakes.) No pancakes are eaten during an interruption.\n\nMinute 3: Do nothing. Each of those two diners will eat one of the last two remaining pancakes.\n\nIn Case #2, it is optimal to let the diners eat for 2 minutes, with no interruptions, during which time they will finish all the pancakes.\n\nIn Case #3, one diner starts with 4 pancakes and everyone else's plate is empty. It is optimal to use the first minute as a special minute to move two pancakes from the diner's plate to another diner's empty plate, and then do nothing and let the diners eat for the second and third minutes.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\n**Small dataset(9 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq \\mathbf{D} \\leq 6$.\n- $1 \\leq \\mathbf{P}_{\\mathbf{i}} \\leq 9$.\n\n**Large dataset(12 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq \\mathbf{D} \\leq 1000$.\n- $1 \\leq \\mathbf{P}_{\\mathbf{i}} \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2015 Qualification] Infinite House of Pancakes", "background": "", "description": "At the Infinite House of Pancakes, there are only finitely many pancakes, but there are infinitely many diners who would be willing to eat them! When the restaurant opens for breakfast, among the infinitely many diners, exactly $\\mathbf{D}$ have non-empty plates; the $i$th of these has $\\mathbf{P}_{\\mathbf{i}}$ pancakes on his or her plate. Everyone else has an empty plate.\n\nNormally, every minute, every diner with a non-empty plate will eat one pancake from his or her plate. However, some minutes may be *special*. In a special minute, the head server asks for the diners' attention, chooses a diner with a non-empty plate, and carefully lifts some number of pancakes off of that diner's plate and moves those pancakes onto one other diner's (empty or non-empty) plate. No diners eat during a special minute, because it would be rude.\n\nYou are the head server on duty this morning, and it is your job to decide which minutes, if any, will be special, and which pancakes will move where. That is, every minute, you can decide to either do nothing and let the diners eat, or declare a special minute and interrupt the diners to make a single movement of one or more pancakes, as described above.\n\nBreakfast ends when there are no more pancakes left to eat. How quickly can you make that happen?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each consists of one line with $\\mathbf{D}$, the number of diners with non-empty plates, followed by another line with $\\mathbf{D}$ space-separated integers representing the numbers of pancakes on those diners' plates.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where x is the test case number (starting from 1) and y is the smallest number of minutes needed to finish the breakfast.", "hint": "**Sample Explanation**\n\nIn Case #1, one diner starts with 3 pancakes and everyone else's plate is empty. One optimal strategy is:\n\nMinute 1: Do nothing. The diner will eat one pancake.\n\nMinute 2 (special): Interrupt and move one pancake from that diner's stack onto another diner's empty plate. (Remember that there are always infinitely many diners with empty plates available, no matter how many diners start off with pancakes.) No pancakes are eaten during an interruption.\n\nMinute 3: Do nothing. Each of those two diners will eat one of the last two remaining pancakes.\n\nIn Case #2, it is optimal to let the diners eat for 2 minutes, with no interruptions, during which time they will finish all the pancakes.\n\nIn Case #3, one diner starts with 4 pancakes and everyone else's plate is empty. It is optimal to use the first minute as a special minute to move two pancakes from the diner's plate to another diner's empty plate, and then do nothing and let the diners eat for the second and third minutes.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\n**Small dataset(9 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq \\mathbf{D} \\leq 6$.\n- $1 \\leq \\mathbf{P}_{\\mathbf{i}} \\leq 9$.\n\n**Large dataset(12 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq \\mathbf{D} \\leq 1000$.\n- $1 \\leq \\mathbf{P}_{\\mathbf{i}} \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2015 Qualification] Infinite House of Pancakes", "background": "", "description": "在 Infinite House of Pancakes（无限煎饼屋），实际上只有有限数量的煎饼，但有无限多的食客愿意来吃！当餐厅早晨开门时，在无数食客中，恰好有 $D$ 位食客的盘子里有煎饼；第 $i$ 位食客的盘子里有 $P_i$ 块煎饼。其他所有人的盘子都是空的。\n\n通常情况下，每过一分钟，每个盘子里有煎饼的食客会吃掉自己盘子中的一块煎饼。然而，有些分钟可能是“特殊分钟”。在特殊分钟里，主服务员会请大家注意，选择一位盘子里有煎饼的食客，从该食客的盘子中取出若干块煎饼，并将这些煎饼转移到另一位食客（无论其盘子是否为空）的盘子里。在特殊分钟里，没人会吃煎饼，因为那样太不礼貌了。\n\n你是今天早上的主服务员，你需要决定哪些分钟（如果有的话）是特殊分钟，以及哪些煎饼要转移到哪里。也就是说，每一分钟，你可以选择什么都不做，让食客们吃煎饼，或者宣布这是一个特殊分钟，打断食客们，进行一次煎饼的转移操作，如上所述。\n\n当所有煎饼都被吃完时，早餐结束。你能让早餐在最短的时间内结束吗？", "inputFormat": "输入的第一行包含测试用例的数量 $T$。接下来有 $T$ 组测试用例。每组测试用例包含两行，第一行为 $D$，表示盘子里有煎饼的食客数量，第二行为 $D$ 个用空格分隔的整数，分别表示这些食客盘子里的煎饼数量。", "outputFormat": "对于每组测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是完成早餐所需的最少分钟数。", "hint": "**样例解释**\n\n在第 1 组样例中，一位食客一开始有 3 块煎饼，其他人的盘子都是空的。一种最优策略如下：\n\n第 1 分钟：什么都不做。该食客吃掉一块煎饼。\n\n第 2 分钟（特殊分钟）：打断，取出一块煎饼放到另一位空盘子的食客那里。（注意，无论有多少食客一开始有煎饼，总有无限多的空盘子可用。）\n\n第 3 分钟：什么都不做。这两位食客各自吃掉最后一块煎饼。\n\n在第 2 组样例中，最优策略是不进行任何打断，让食客们连续吃 2 分钟即可吃完所有煎饼。\n\n在第 3 组样例中，一位食客一开始有 4 块煎饼，其他人的盘子都是空的。最优策略是在第 1 分钟进行一次特殊分钟，将两块煎饼分给另一位空盘子的食客，然后在第 2、3 分钟什么都不做，让两位食客各自吃掉剩下的煎饼。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n\n**小数据集（9 分）**\n\n- 时间限制：~~240~~ 5 秒。\n- $1 \\leq D \\leq 6$。\n- $1 \\leq P_i \\leq 9$。\n\n**大数据集（12 分）**\n\n- 时间限制：~~240~~ 10 秒。\n- $1 \\leq D \\leq 1000$。\n- $1 \\leq P_i \\leq 1000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13213", "type": "P", "difficulty": 4, "samples": [["5\n2 1\nik\n3 1\nijk\n3 1\nkji\n2 6\nji\n1 10000\ni", "Case #1: NO\nCase #2: YES\nCase #3: NO\nCase #4: YES\nCase #5: NO"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["数学", "2015", "Google Code Jam"], "title": "[GCJ 2015 Qualification] Dijkstra", "background": "", "description": "The Dutch computer scientist Edsger Dijkstra made many important contributions to the field, including the shortest path finding algorithm that bears his name. This problem is not about that algorithm.\n\nYou were marked down one point on an algorithms exam for misspelling \"Dijkstra\" -- between d and stra, you wrote some number of characters, each of which was either $i, j$, or $k$. You are prepared to argue to get your point back using quaternions, an actual number system (extended from complex numbers) with the following multiplicative structure:\n\n|   | $1$ | $i$ | $j$ | $k$ |\n|:---:|:---:|:---:|:---:|:---:|\n| $1$ | $1$ | $i$ | $j $| $k$ |\n| $i$ | $i$ | $-1$ | $k$ | $-j$ |\n| $j$ | $j$ | $-k$ | $-1$ | $i$ |\n| $k$ | $k$ | $j$ | $-i$ | $-1$ |\n\nTo multiply one quaternion by another, look at the row for the first quaternion and the column for the second quaternion. For example, to multiply $i$ by $j$, look in the row for $i$ and the column for $j$ to find that the answer is $k$. To multiply $j$ by $i$, look in the row for $j$ and the column for $i$ to find that the answer is $-k$.\n\nAs you can see from the above examples, the quaternions are not commutative -- that is, there are some $\\mathbf{a}$ and $\\mathbf{b}$ for which $\\mathbf{a} \\times \\mathbf{b} \\neq \\mathbf{b} \\times \\mathbf{a}$. However they are associative -- for any $\\mathbf{a}$, $\\mathbf{b}$, and $\\mathbf{c}$, it's true that $\\mathbf{a} \\times (\\mathbf{b} \\times \\mathbf{c}) = (\\mathbf{a} \\times \\mathbf{b}) \\times \\mathbf{c}$.\n\nNegative signs before quaternions work as they normally do -- for any quaternions $\\mathbf{a}$ and $\\mathbf{b}$, it's true that $-\\mathbf{a} \\times -\\mathbf{b} = \\mathbf{a} \\times \\mathbf{b}$, and $-\\mathbf{a} \\times \\mathbf{b} = \\mathbf{a} \\times -\\mathbf{b} = -(\\mathbf{a} \\times \\mathbf{b})$.\n\nYou want to argue that your misspelling was equivalent to the correct spelling `ijk` by showing that you can split your string of `i`s, `j`s, and `k`s in two places, forming three substrings, such that the leftmost substring reduces (under quaternion multiplication) to $i$, the middle substring reduces to $j$, and the right substring reduces to $k$. (For example, `jij` would be interpreted as $j \\times i \\times j$; $j \\times i$ is $-k$, and $-k \\times j$ is $i$, so `jij` reduces to $i$.) If this is possible, you will get your point back. Can you find a way to do it?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each consists of one line with two space-separated integers $\\mathbf{L}$ and $\\mathbf{X}$, followed by another line with $\\mathbf{L}$ characters, all of which are $\\mathbf{i}$, $\\mathbf{j}$, or $\\mathbf{k}$. Note that the string never contains negative signs, 1s, or any other characters. The string that you are to evaluate is the given string of $\\mathbf{L}$ characters repeated $\\mathbf{X}$ times. For instance, for $\\mathbf{L} = 4$, $\\mathbf{X} = 3$, and the given string $\\mathbf{kiiij}$, your input string would be $\\mathbf{kiijkiijkiij}$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathbf{x}$ is the test case number (starting from 1) and $\\mathbf{y}$ is either $\\mathbf{yes}$ or $\\mathbf{no}$, depending on whether the string can be broken into three parts that reduce to $i$, $j$, and $k$, in that order, as described above.", "hint": "**Sample Explanation**\n\nIn Case #1, the string is too short to be split into three substrings.\n\nIn Case #2, just split the string into i, j, and k.\n\nIn Case #3, the only way to split the string into three parts is k, j, i, and this does not satisfy the conditions.\n\nIn Case #4, the string is $\\mathbf{jijijijijiji}$. It can be split into $\\mathbf{jij}$ (which reduces to i), $\\mathbf{iji}$ (which reduces to j), and $\\mathbf{jijiji}$ (which reduces to k).\n\nIn Case #5, no matter how you choose your substrings, none of them can ever reduce to a j or a k.\n\n**Sample Explanation**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{L} \\leq 10000$.\n\n**Small dataset(11 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq \\mathbf{X} \\leq 10000$.\n- $1 \\leq \\mathbf{L} \\times \\mathbf{X} \\leq 10000$.\n\n**Large dataset(17 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq \\mathbf{X} \\leq 10^{12}$.\n- $1 \\leq \\mathbf{L} \\times \\mathbf{X} \\leq 10^{16}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2015 Qualification] Dijkstra", "background": "", "description": "The Dutch computer scientist Edsger Dijkstra made many important contributions to the field, including the shortest path finding algorithm that bears his name. This problem is not about that algorithm.\n\nYou were marked down one point on an algorithms exam for misspelling \"Dijkstra\" -- between d and stra, you wrote some number of characters, each of which was either $i, j$, or $k$. You are prepared to argue to get your point back using quaternions, an actual number system (extended from complex numbers) with the following multiplicative structure:\n\n|   | $1$ | $i$ | $j$ | $k$ |\n|:---:|:---:|:---:|:---:|:---:|\n| $1$ | $1$ | $i$ | $j $| $k$ |\n| $i$ | $i$ | $-1$ | $k$ | $-j$ |\n| $j$ | $j$ | $-k$ | $-1$ | $i$ |\n| $k$ | $k$ | $j$ | $-i$ | $-1$ |\n\nTo multiply one quaternion by another, look at the row for the first quaternion and the column for the second quaternion. For example, to multiply $i$ by $j$, look in the row for $i$ and the column for $j$ to find that the answer is $k$. To multiply $j$ by $i$, look in the row for $j$ and the column for $i$ to find that the answer is $-k$.\n\nAs you can see from the above examples, the quaternions are not commutative -- that is, there are some $\\mathbf{a}$ and $\\mathbf{b}$ for which $\\mathbf{a} \\times \\mathbf{b} \\neq \\mathbf{b} \\times \\mathbf{a}$. However they are associative -- for any $\\mathbf{a}$, $\\mathbf{b}$, and $\\mathbf{c}$, it's true that $\\mathbf{a} \\times (\\mathbf{b} \\times \\mathbf{c}) = (\\mathbf{a} \\times \\mathbf{b}) \\times \\mathbf{c}$.\n\nNegative signs before quaternions work as they normally do -- for any quaternions $\\mathbf{a}$ and $\\mathbf{b}$, it's true that $-\\mathbf{a} \\times -\\mathbf{b} = \\mathbf{a} \\times \\mathbf{b}$, and $-\\mathbf{a} \\times \\mathbf{b} = \\mathbf{a} \\times -\\mathbf{b} = -(\\mathbf{a} \\times \\mathbf{b})$.\n\nYou want to argue that your misspelling was equivalent to the correct spelling `ijk` by showing that you can split your string of `i`s, `j`s, and `k`s in two places, forming three substrings, such that the leftmost substring reduces (under quaternion multiplication) to $i$, the middle substring reduces to $j$, and the right substring reduces to $k$. (For example, `jij` would be interpreted as $j \\times i \\times j$; $j \\times i$ is $-k$, and $-k \\times j$ is $i$, so `jij` reduces to $i$.) If this is possible, you will get your point back. Can you find a way to do it?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each consists of one line with two space-separated integers $\\mathbf{L}$ and $\\mathbf{X}$, followed by another line with $\\mathbf{L}$ characters, all of which are $\\mathbf{i}$, $\\mathbf{j}$, or $\\mathbf{k}$. Note that the string never contains negative signs, 1s, or any other characters. The string that you are to evaluate is the given string of $\\mathbf{L}$ characters repeated $\\mathbf{X}$ times. For instance, for $\\mathbf{L} = 4$, $\\mathbf{X} = 3$, and the given string $\\mathbf{kiiij}$, your input string would be $\\mathbf{kiijkiijkiij}$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathbf{x}$ is the test case number (starting from 1) and $\\mathbf{y}$ is either $\\mathbf{yes}$ or $\\mathbf{no}$, depending on whether the string can be broken into three parts that reduce to $i$, $j$, and $k$, in that order, as described above.", "hint": "**Sample Explanation**\n\nIn Case #1, the string is too short to be split into three substrings.\n\nIn Case #2, just split the string into i, j, and k.\n\nIn Case #3, the only way to split the string into three parts is k, j, i, and this does not satisfy the conditions.\n\nIn Case #4, the string is $\\mathbf{jijijijijiji}$. It can be split into $\\mathbf{jij}$ (which reduces to i), $\\mathbf{iji}$ (which reduces to j), and $\\mathbf{jijiji}$ (which reduces to k).\n\nIn Case #5, no matter how you choose your substrings, none of them can ever reduce to a j or a k.\n\n**Sample Explanation**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{L} \\leq 10000$.\n\n**Small dataset(11 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.\n- $1 \\leq \\mathbf{X} \\leq 10000$.\n- $1 \\leq \\mathbf{L} \\times \\mathbf{X} \\leq 10000$.\n\n**Large dataset(17 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.\n- $1 \\leq \\mathbf{X} \\leq 10^{12}$.\n- $1 \\leq \\mathbf{L} \\times \\mathbf{X} \\leq 10^{16}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2015 Qualification] Dijkstra", "background": null, "description": "荷兰计算机科学家 Edsger Dijkstra 对该领域做出了许多重要贡献，其中包括以他名字命名的最短路径算法。但本题与该算法无关。\n\n你在一次算法考试中因为拼错了 “Dijkstra” 而被扣了一分——你在 d 和 stra 之间写入了一些字符，每个字符都是 $i$、$j$ 或 $k$。你准备用四元数（一种实际存在的数系，扩展自复数）来为自己辩解。四元数的乘法结构如下表所示：\n\n|   | $1$ | $i$ | $j$ | $k$ |\n|:---:|:---:|:---:|:---:|:---:|\n| $1$ | $1$ | $i$ | $j$ | $k$ |\n| $i$ | $i$ | $-1$ | $k$ | $-j$ |\n| $j$ | $j$ | $-k$ | $-1$ | $i$ |\n| $k$ | $k$ | $j$ | $-i$ | $-1$ |\n\n要将一个四元数与另一个四元数相乘，请查找第一个四元数所在的行和第二个四元数所在的列。例如，要计算 $i$ 乘以 $j$，查找 $i$ 行和 $j$ 列，得到 $k$。要计算 $j$ 乘以 $i$，查找 $j$ 行和 $i$ 列，得到 $-k$。\n\n如上例所示，四元数的乘法不是交换律的——即存在某些 $\\mathbf{a}$ 和 $\\mathbf{b}$，使得 $\\mathbf{a} \\times \\mathbf{b} \\neq \\mathbf{b} \\times \\mathbf{a}$。但它满足结合律——对于任意 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{c}$，都有 $\\mathbf{a} \\times (\\mathbf{b} \\times \\mathbf{c}) = (\\mathbf{a} \\times \\mathbf{b}) \\times \\mathbf{c}$。\n\n四元数前的负号与通常意义下的负号一致——对于任意四元数 $\\mathbf{a}$ 和 $\\mathbf{b}$，都有 $-\\mathbf{a} \\times -\\mathbf{b} = \\mathbf{a} \\times \\mathbf{b}$，且 $-\\mathbf{a} \\times \\mathbf{b} = \\mathbf{a} \\times -\\mathbf{b} = -(\\mathbf{a} \\times \\mathbf{b})$。\n\n你想要证明你的拼写错误等价于正确拼写的 `ijk`，方法是：你能否将由 $i$、$j$、$k$ 组成的字符串在两个位置切分，形成三个子串，使得最左边的子串在四元数乘法下约化为 $i$，中间的子串约化为 $j$，最右边的子串约化为 $k$。（例如，`jij` 被解释为 $j \\times i \\times j$；$j \\times i$ 等于 $-k$，$-k \\times j$ 等于 $i$，所以 `jij` 约化为 $i$。）如果可以做到，你就能拿回那一分。你能找到切分方法吗？", "inputFormat": "输入的第一行包含测试用例数 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试用例。每组测试用例包含一行，包含两个用空格分隔的整数 $\\mathbf{L}$ 和 $\\mathbf{X}$，接着一行包含 $\\mathbf{L}$ 个字符，每个字符都是 $\\mathbf{i}$、$\\mathbf{j}$ 或 $\\mathbf{k}$。注意，字符串中不会出现负号、1 或其他字符。你需要评估的字符串是给定的 $\\mathbf{L}$ 个字符重复 $\\mathbf{X}$ 次。例如，若 $\\mathbf{L} = 4$，$\\mathbf{X} = 3$，给定字符串为 $\\mathbf{kiiij}$，则你的输入字符串为 $\\mathbf{kiijkiijkiij}$。", "outputFormat": "对于每组测试用例，输出一行，格式为 `Case #x: y`，其中 $\\mathbf{x}$ 为测试用例编号（从 1 开始），$\\mathbf{y}$ 为 `yes` 或 `no`，表示是否可以将字符串切分为三部分，分别约化为 $i$、$j$、$k$，顺序如上所述。", "hint": "**样例解释**\n\n在第 1 组样例中，字符串长度太短，无法切分为三个子串。\n\n在第 2 组样例中，可以直接将字符串切分为 i、j 和 k。\n\n在第 3 组样例中，唯一的切分方式是 k、j、i，这不满足要求。\n\n在第 4 组样例中，字符串为 $\\mathbf{jijijijijiji}$。可以切分为 $\\mathbf{jij}$（约化为 i）、$\\mathbf{iji}$（约化为 j）、$\\mathbf{jijiji}$（约化为 k）。\n\n在第 5 组样例中，无论如何切分子串，都无法得到约化为 j 或 k 的部分。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{L} \\leq 10000$。\n\n**小数据集（11 分）**\n\n- 时间限制：5 秒。\n- $1 \\leq \\mathbf{X} \\leq 10000$。\n- $1 \\leq \\mathbf{L} \\times \\mathbf{X} \\leq 10000$。\n\n**大数据集（17 分）**\n\n- 时间限制：10 秒。\n- $1 \\leq \\mathbf{X} \\leq 10^{12}$。\n- $1 \\leq \\mathbf{L} \\times \\mathbf{X} \\leq 10^{16}$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13214", "type": "P", "difficulty": 7, "samples": [["4\n2 2 2\n2 1 3\n4 4 1\n3 2 3", "Case #1: GABRIEL\nCase #2: RICHARD\nCase #3: RICHARD\nCase #4: GABRIEL"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["博弈论", "2015", "分类讨论", "Google Code Jam"], "title": "[GCJ 2015 Qualification] Ominous Omino", "background": "", "description": "An $N$-omino is a two-dimensional shape formed by joining $N$ unit cells fully along their edges in some way. More formally, a 1-omino is a $1\\times 1$ unit square, and an $N$-omino is an $(N-1)$-omino with one or more of its edges joined to an adjacent $1\\times 1$ unit square. For the purpose of this problem, we consider two $N$-ominoes to be the same if one can be transformed into the other via reflection and/or rotation. For example, these are the five possible $4$-ominoes:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wkp3irgd.png)\n\nAnd here are some of the $108$ possible $7$-ominoes:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gy8e9z55.png)\n\nRichard and Gabriel are going to play a game with the following rules, for some predetermined values of $\\mathbf{X}$, $\\mathbf{R}$, and $\\mathbf{C}$:\n\n1. Richard will choose any one of the possible $\\mathbf{X}$-ominoes.\n2. Gabriel must use at least one copy of that $\\mathbf{X}$-omino, along with arbitrarily many copies of any $\\mathbf{X}$-ominoes (which can include the one Richard chose), to completely fill in an $\\mathbf{R}$-by-$\\mathbf{C}$ grid, with no overlaps and no spillover. That is, every cell must be covered by exactly one of the $\\mathbf{X}$ cells making up an $\\mathbf{X}$-omino, and no $\\mathbf{X}$-omino can extend outside the grid. Gabriel is allowed to rotate or reflect as many of the $\\mathbf{X}$-ominoes as he wants, including the one Richard chose. If Gabriel can completely fill in the grid, he wins; otherwise, Richard wins.\n\nGiven particular values $\\mathbf{X}$, $\\mathbf{R}$, and $\\mathbf{C}$, can Richard choose an $\\mathbf{X}$-omino that will ensure that he wins, or is Gabriel guaranteed to win no matter what Richard chooses?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each contains three space-separated integers: $\\mathbf{X}$, $\\mathbf{R}$, and $\\mathbf{C}$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where x is the test case number (starting from 1) and y is either RICHARD (if there is at least one choice that ensures victory for Richard) or GABRIEL (if Gabriel will win no matter what Richard chooses).", "hint": "**Sample Explanation**\n\nIn case #1, Richard only has one $2$-omino available to choose -- the $1\\times 2$ block formed by joining two unit cells together. No matter how Gabriel places this block in the $2\\times 2$ grid, he will leave a hole that can be exactly filled with another $1\\times 2$ block. So Gabriel wins.\n\nIn case #2, Richard has to choose the $1\\times 2$ block, but no matter where Gabriel puts it, he will be left with a single $1\\times 1$ hole that he cannot fill using only $2$-ominoes. So Richard wins.\n\nIn case #3, one winning strategy for Richard is to choose the $2\\times 2$ square $4$-omino. There is no way for Gabriel to fit that square into the $4\\times 1$ grid such that it is completely contained within the grid, so Richard wins.\n\nIn case #4, Richard can either pick the straight $3$-omino or the L-shaped $3$-omino. In either case, Gabriel can fit it into the grid and then use another copy of the same $3$-omino to fill in the remaining hole.\n\n**Limits**\n\n**Small dataset(8 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.  \n- $\\mathbf{T} = 64$.\n- $1 \\leq \\mathbf{X}, \\mathbf{R}, \\mathbf{C} \\leq 4$.\n\n**Large dataset(26 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.  \n- $1 \\leq \\mathbf{T} \\leq 100$.  \n- $1 \\leq \\mathbf{X}, \\mathbf{R}, \\mathbf{C} \\leq 20$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2015 Qualification] Ominous Omino", "background": "", "description": "An $N$-omino is a two-dimensional shape formed by joining $N$ unit cells fully along their edges in some way. More formally, a 1-omino is a $1\\times 1$ unit square, and an $N$-omino is an $(N-1)$-omino with one or more of its edges joined to an adjacent $1\\times 1$ unit square. For the purpose of this problem, we consider two $N$-ominoes to be the same if one can be transformed into the other via reflection and/or rotation. For example, these are the five possible $4$-ominoes:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wkp3irgd.png)\n\nAnd here are some of the $108$ possible $7$-ominoes:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gy8e9z55.png)\n\nRichard and Gabriel are going to play a game with the following rules, for some predetermined values of $\\mathbf{X}$, $\\mathbf{R}$, and $\\mathbf{C}$:\n\n1. Richard will choose any one of the possible $\\mathbf{X}$-ominoes.\n2. Gabriel must use at least one copy of that $\\mathbf{X}$-omino, along with arbitrarily many copies of any $\\mathbf{X}$-ominoes (which can include the one Richard chose), to completely fill in an $\\mathbf{R}$-by-$\\mathbf{C}$ grid, with no overlaps and no spillover. That is, every cell must be covered by exactly one of the $\\mathbf{X}$ cells making up an $\\mathbf{X}$-omino, and no $\\mathbf{X}$-omino can extend outside the grid. Gabriel is allowed to rotate or reflect as many of the $\\mathbf{X}$-ominoes as he wants, including the one Richard chose. If Gabriel can completely fill in the grid, he wins; otherwise, Richard wins.\n\nGiven particular values $\\mathbf{X}$, $\\mathbf{R}$, and $\\mathbf{C}$, can Richard choose an $\\mathbf{X}$-omino that will ensure that he wins, or is Gabriel guaranteed to win no matter what Richard chooses?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each contains three space-separated integers: $\\mathbf{X}$, $\\mathbf{R}$, and $\\mathbf{C}$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where x is the test case number (starting from 1) and y is either RICHARD (if there is at least one choice that ensures victory for Richard) or GABRIEL (if Gabriel will win no matter what Richard chooses).", "hint": "**Sample Explanation**\n\nIn case #1, Richard only has one $2$-omino available to choose -- the $1\\times 2$ block formed by joining two unit cells together. No matter how Gabriel places this block in the $2\\times 2$ grid, he will leave a hole that can be exactly filled with another $1\\times 2$ block. So Gabriel wins.\n\nIn case #2, Richard has to choose the $1\\times 2$ block, but no matter where Gabriel puts it, he will be left with a single $1\\times 1$ hole that he cannot fill using only $2$-ominoes. So Richard wins.\n\nIn case #3, one winning strategy for Richard is to choose the $2\\times 2$ square $4$-omino. There is no way for Gabriel to fit that square into the $4\\times 1$ grid such that it is completely contained within the grid, so Richard wins.\n\nIn case #4, Richard can either pick the straight $3$-omino or the L-shaped $3$-omino. In either case, Gabriel can fit it into the grid and then use another copy of the same $3$-omino to fill in the remaining hole.\n\n**Limits**\n\n**Small dataset(8 Pts)**\n\n- Time limit: ~~240~~ 5 seconds.  \n- $\\mathbf{T} = 64$.\n- $1 \\leq \\mathbf{X}, \\mathbf{R}, \\mathbf{C} \\leq 4$.\n\n**Large dataset(26 Pts)**\n\n- Time limit: ~~480~~ 10 seconds.  \n- $1 \\leq \\mathbf{T} \\leq 100$.  \n- $1 \\leq \\mathbf{X}, \\mathbf{R}, \\mathbf{C} \\leq 20$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2015 Qualification] Ominous Omino", "background": null, "description": "一个 $N$-omino 是由 $N$ 个单位方格通过边完全连接而成的二维图形。更正式地说，$1$-omino 是一个 $1\\times 1$ 的单位正方形，而 $N$-omino 是在一个 $(N-1)$-omino 的某一条或多条边上连接一个相邻的 $1\\times 1$ 单位正方形。对于本题，如果两个 $N$-omino 通过旋转和/或翻转可以互相变换，则认为它们是相同的。例如，下面是所有可能的五种 $4$-omino：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wkp3irgd.png)\n\n下面是 $108$ 种可能的 $7$-omino 中的一部分：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gy8e9z55.png)\n\nRichard 和 Gabriel 要玩一个游戏，规则如下，给定预先确定的 $\\mathbf{X}$、$\\mathbf{R}$ 和 $\\mathbf{C}$：\n\n1. Richard 可以选择任意一种可能的 $\\mathbf{X}$-omino。\n2. Gabriel 必须至少使用一个该 $\\mathbf{X}$-omino，并可以任意多次使用任意 $\\mathbf{X}$-omino（包括 Richard 选择的那一个），将 $\\mathbf{R}\\times\\mathbf{C}$ 的网格完全填满，不能有重叠或溢出。也就是说，每个格子必须被恰好一个 $\\mathbf{X}$-omino 的单元格覆盖，且不能有 $\\mathbf{X}$-omino 超出网格范围。Gabriel 可以随意旋转或翻转任意数量的 $\\mathbf{X}$-omino，包括 Richard 选择的那一个。如果 Gabriel 能完全填满网格，则他获胜；否则，Richard 获胜。\n\n给定特定的 $\\mathbf{X}$、$\\mathbf{R}$ 和 $\\mathbf{C}$，Richard 能否选择一种 $\\mathbf{X}$-omino 保证自己获胜，还是无论 Richard 选择什么，Gabriel 都必胜？", "inputFormat": "输入的第一行包含测试用例数 $\\mathbf{T}$。接下来的 $\\mathbf{T}$ 行，每行包含三个用空格分隔的整数：$\\mathbf{X}$、$\\mathbf{R}$ 和 $\\mathbf{C}$。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 为 `RICHARD`（如果存在至少一种选择能保证 Richard 获胜）或 `GABRIEL`（如果无论 Richard 选择什么 Gabriel 都能获胜）。", "hint": "**样例解释**\n\n对于第 1 个样例，Richard 只有一种 $2$-omino 可选——由两个单位格组成的 $1\\times 2$ 长条。不论 Gabriel 如何放置这个长条，都可以用另一个 $1\\times 2$ 长条正好填满 $2\\times 2$ 的网格，所以 Gabriel 获胜。\n\n对于第 2 个样例，Richard 只能选择 $1\\times 2$ 的长条，但无论 Gabriel 如何放置它，都会剩下一个 $1\\times 1$ 的空格，无法用 $2$-omino 填满，所以 Richard 获胜。\n\n对于第 3 个样例，Richard 可以选择 $2\\times 2$ 的正方形 $4$-omino。这个正方形无法完整放入 $4\\times 1$ 的网格，因此 Richard 获胜。\n\n对于第 4 个样例，Richard 可以选择直线型 $3$-omino 或 L 形 $3$-omino。无论选择哪种，Gabriel 都可以用它填满网格。\n\n**数据范围**\n\n**小数据集（8 分）**\n\n- 时间限制：5 秒。\n- $\\mathbf{T} = 64$。\n- $1 \\leq \\mathbf{X}, \\mathbf{R}, \\mathbf{C} \\leq 4$。\n\n**大数据集（26 分）**\n\n- 时间限制：10 秒。\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{X}, \\mathbf{R}, \\mathbf{C} \\leq 20$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
