{"pid": "P5531", "type": "P", "difficulty": 6, "samples": [["1 3\nJJD\n3 1\n", "0.667"], ["2 2\nJJ\nDD\n3 1\n", "0.000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2019", "CCO（加拿大）"], "title": "[CCO 2019] Human Error", "background": "", "description": "Justin和Donald正在玩一种游戏：跳棋。你可能没有听说过，但是规则非常简单。\n\n棋盘是一个矩形网格，在最开始时，每一格上恰好有一个棋子，并且每名玩家在棋盘上最少拥有一枚棋子。Justin的棋子被标记为`J`，而Donald的被标记为`D`。\n\nJustin先下棋。在一次移动中，这位玩家可以移动自己的一枚棋子并吃掉相邻的一枚棋子 **（不一定是对手的）** ，随后轮到对手。如果当前玩家无法进行这样的操作，那么这位玩家就输了。\n\n棋子$A$与$B$是相邻的，当且仅当$A$正好在$B$的上/下/左/右一格。\n\n在理想的世界中，两人都是绝佳的逻辑学者，可以知晓每种棋盘上的最佳策略。然而这是不现实的。事实上，在游玩时，两人只会选择相对较好的走法。它到底有多好取决于Justin和Donald的误差常数，分别是$J$和$D$。\n\n形式化地，拥有误差常数$A$的玩家会从所有可能的走法中选择其中$A$种组成方案集合。如果所有可能的走法数$ P \\le A $，那么方案集合仅包含这$P$种。之后，这位玩家会随机（等概率）地挑选其中的一种并依此进行操作。\n\n两人在挑选方案组成集合时总会选择最优的方案，亦知晓对手也会选择最优方案。\n\n请问Justin获胜的概率是多少？", "inputFormat": "第一行两个正整数，$R C$（用空格隔开）。\n\n之后$R$行，每行$C$个字符，代表初始棋盘上的棋子分布（含义见题目描述）。\n\n之后一行两个正整数，$J D$（用空格隔开），含义见题目描述。", "outputFormat": "一行，一个精确到3位小数的浮点数，代表Justin获胜的概率。", "hint": "### 限制\n\n$ 1 \\le R \\times C \\le 13 $\n\n$ 1 \\le J,D \\le 13 $\n\n初始棋盘棋子分布只用`J`和`D`这两种字符表示。\n\n### 样例说明\n\n**样例1：**\n\nJustin拥有3种移动的可能性，移动后分别为：（用`_`表示空棋子）\n\n`_JD`（第一颗向右移），`J_J`（第二颗向右移），`J_D`（第二颗向左移）。\n\n对于情况1，Justin败。对于情况2和3，Justin胜。由于Justin的误差常数为3，他会选择所有的情况，故胜率为$\\frac{2}{3}$，取0.667。\n\n**样例2：**\n\nJustin拥有4种移动的可能性，移动后分别为：（用`_`表示空棋子）\n\n```\nJ_ _J J_ _J\nDD DD DJ JD\n```\n\n然而，无论Justin选择哪种，他都没有可能赢。\n\n之后Donald会选择最优的移动。他可以选择以下的方式击败对应的Justin：\n\n```\nD_ _D J_ _J\n_D D_ _D D_\n```\n\n故而Justin不可能赢。", "locale": "zh-CN", "translations": {"en": {"title": "[CCO 2019] Human Error", "background": "", "description": "Justin and Donald are playing a game: checkers. You may not have heard of it, but the rules are very simple.\n\nThe board is a rectangular grid. At the beginning, each cell contains exactly one piece, and each player has at least one piece on the board. Justin’s pieces are marked `J`, and Donald’s are marked `D`.\n\nJustin moves first. In one move, the player may move one of their own pieces and capture one adjacent piece **(not necessarily the opponent’s)**, then it becomes the other player’s turn. If the current player cannot make such a move, then this player loses.\n\nPieces $A$ and $B$ are adjacent if and only if $A$ is exactly one cell above, below, left, or right of $B$.\n\nIn an ideal world, both players are perfect logicians and can know the best strategy for every board position. However, this is not realistic. In fact, while playing, they only choose relatively good moves. How good it is depends on Justin’s and Donald’s error constants, which are $J$ and $D$, respectively.\n\nFormally, a player with error constant $A$ will select a set of plans consisting of $A$ moves from all possible moves. If the number of all possible moves $P \\le A$, then the plan set contains only these $P$ moves. Then, the player randomly (with equal probability) picks one move from the set and makes that move.\n\nWhen choosing which moves form the set, both players always choose the optimal set, and they also know that the opponent will choose the optimal set.\n\nWhat is the probability that Justin wins?", "inputFormat": "The first line contains two positive integers $R C$ (separated by a space).\n\nThen there are $R$ lines, each containing $C$ characters, representing the initial distribution of pieces on the board (see the description for meanings).\n\nThen one line contains two positive integers $J D$ (separated by a space), with the meanings described above.", "outputFormat": "Output one line with a floating-point number rounded to 3 decimal places, representing the probability that Justin wins.", "hint": "### Constraints\n\n$ 1 \\le R \\times C \\le 13 $\n\n$ 1 \\le J,D \\le 13 $\n\nThe initial board distribution uses only the two characters `J` and `D`.\n\n### Sample Explanation\n\n**Sample 1:**\n\nJustin has 3 possible moves, and the resulting boards are (use `_` to represent an empty cell).\n\n`_JD` (move the first piece to the right), `J_J` (move the second piece to the right), `J_D` (move the second piece to the left).\n\nFor case 1, Justin loses. For cases 2 and 3, Justin wins. Since Justin’s error constant is 3, he will choose all cases, so the win rate is $\\frac{2}{3}$, which is $0.667$.\n\n**Sample 2:**\n\nJustin has 4 possible moves, and the resulting boards are (use `_` to represent an empty cell).\n\n```\nJ_ _J J_ _J\nDD DD DJ JD\n```\n\nHowever, no matter which one Justin chooses, he has no way to win.\n\nThen Donald will choose the optimal move. He can choose the following moves to defeat the corresponding Justin moves:\n\n```\nD_ _D J_ _J\n_D D_ _D D_\n```\n\nTherefore, Justin cannot win.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CCO 2019] Human Error", "background": "", "description": "Justin和Donald正在玩一种游戏：跳棋。你可能没有听说过，但是规则非常简单。\n\n棋盘是一个矩形网格，在最开始时，每一格上恰好有一个棋子，并且每名玩家在棋盘上最少拥有一枚棋子。Justin的棋子被标记为`J`，而Donald的被标记为`D`。\n\nJustin先下棋。在一次移动中，这位玩家可以移动自己的一枚棋子并吃掉相邻的一枚棋子 **（不一定是对手的）** ，随后轮到对手。如果当前玩家无法进行这样的操作，那么这位玩家就输了。\n\n棋子$A$与$B$是相邻的，当且仅当$A$正好在$B$的上/下/左/右一格。\n\n在理想的世界中，两人都是绝佳的逻辑学者，可以知晓每种棋盘上的最佳策略。然而这是不现实的。事实上，在游玩时，两人只会选择相对较好的走法。它到底有多好取决于Justin和Donald的误差常数，分别是$J$和$D$。\n\n形式化地，拥有误差常数$A$的玩家会从所有可能的走法中选择其中$A$种组成方案集合。如果所有可能的走法数$ P \\le A $，那么方案集合仅包含这$P$种。之后，这位玩家会随机（等概率）地挑选其中的一种并依此进行操作。\n\n两人在挑选方案组成集合时总会选择最优的方案，亦知晓对手也会选择最优方案。\n\n请问Justin获胜的概率是多少？", "inputFormat": "第一行两个正整数，$R C$（用空格隔开）。\n\n之后$R$行，每行$C$个字符，代表初始棋盘上的棋子分布（含义见题目描述）。\n\n之后一行两个正整数，$J D$（用空格隔开），含义见题目描述。", "outputFormat": "一行，一个精确到3位小数的浮点数，代表Justin获胜的概率。", "hint": "### 限制\n\n$ 1 \\le R \\times C \\le 13 $\n\n$ 1 \\le J,D \\le 13 $\n\n初始棋盘棋子分布只用`J`和`D`这两种字符表示。\n\n### 样例说明\n\n**样例1：**\n\nJustin拥有3种移动的可能性，移动后分别为：（用`_`表示空棋子）\n\n`_JD`（第一颗向右移），`J_J`（第二颗向右移），`J_D`（第二颗向左移）。\n\n对于情况1，Justin败。对于情况2和3，Justin胜。由于Justin的误差常数为3，他会选择所有的情况，故胜率为$\\frac{2}{3}$，取0.667。\n\n**样例2：**\n\nJustin拥有4种移动的可能性，移动后分别为：（用`_`表示空棋子）\n\n```\nJ_ _J J_ _J\nDD DD DJ JD\n```\n\n然而，无论Justin选择哪种，他都没有可能赢。\n\n之后Donald会选择最优的移动。他可以选择以下的方式击败对应的Justin：\n\n```\nD_ _D J_ _J\n_D D_ _D D_\n```\n\n故而Justin不可能赢。", "locale": "zh-CN"}}}
{"pid": "P5532", "type": "P", "difficulty": 6, "samples": [["5 4\n..#.\n##.#\n.##.\n#...\n#...\n", "....\n....\n###.\n###.\n#..#"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "CCO（加拿大）", "图论建模", "最短路", "差分约束"], "title": "[CCO 2019] Sirtet", "background": "", "description": "在一款新型的无人游戏（话说这算游戏吗）Sirlet中，界面是一个矩形网格。在游戏开始之前，一些方格是空白的（表示为`.`），而一些方格是被填充的（表示为`#`）。那些被填充的方格代表一组物体，而相邻的被填充方格被视作同一物体。\n\n例如，这个初始网格：\n\n```\n..#.\n##.#\n.##.\n#...\n#...\n```\n\n包含以下4个物体：\n\n```\n##   #  #  #\n ##  #\n```\n\n当游戏开始时，每个物体开始以相同的速度匀速下落，它们持续下落，直到它接触到最下面的一行或是另一物体的顶部，而在接触时停止下落。\n\n求网格的最终状态。", "inputFormat": "第一行，两个正整数$N M$（用空格隔开）。\n\n随后$N$行，每行$M$个字符，代表网格。它们或是`#`，或是`.`，含义见题目描述。", "outputFormat": "$N$行，每行$M$个字符，代表网格的最终状态。它们或是`#`，或是`.`，含义见题目描述。", "hint": "### 限制\n\n$ 1 \\le N \\times M \\le 10^6 $\n\n### 子任务\n\nSubtask 1 （40分）：$ 1 \\le N \\times M \\le 2000 $\n\nSubtask 2 （24分）：$ M = 2 $\n\nSubtask 3 （36分）：没有附加限制。", "locale": "zh-CN", "translations": {"en": {"title": "[CCO 2019] Sirtet", "background": "", "description": "In a new kind of unattended game (does this even count as a game) called Sirlet, the screen is a rectangular grid. Before the game starts, some cells are empty (shown as `.`), and some cells are filled (shown as `#`). The filled cells represent a set of objects, and adjacent filled cells are considered to be the same object.\n\nFor example, this initial grid:\n\n```\n..#.\n##.#\n.##.\n#...\n#...\n```\n\ncontains the following 4 objects:\n\n```\n##   #  #  #\n ##  #\n```\n\nWhen the game starts, each object begins to fall downward at the same constant speed. They keep falling until they touch the bottom row or the top of another object, and then stop falling at the moment of contact.\n\nFind the final state of the grid.", "inputFormat": "The first line contains two positive integers $N$ and $M$ (separated by a space).\n\nThe next $N$ lines each contain $M$ characters representing the grid. Each character is either `#` or `.`, with meanings as described above.", "outputFormat": "Output $N$ lines, each containing $M$ characters representing the final state of the grid. Each character is either `#` or `.`, with meanings as described above.", "hint": "### Constraints\n\n$ 1 \\le N \\times M \\le 10^6 $\n\n### Subtasks\n\nSubtask 1 (40 points): $ 1 \\le N \\times M \\le 2000 $\n\nSubtask 2 (24 points): $ M = 2 $\n\nSubtask 3 (36 points): No additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CCO 2019] Sirtet", "background": "", "description": "在一款新型的无人游戏（话说这算游戏吗）Sirlet中，界面是一个矩形网格。在游戏开始之前，一些方格是空白的（表示为`.`），而一些方格是被填充的（表示为`#`）。那些被填充的方格代表一组物体，而相邻的被填充方格被视作同一物体。\n\n例如，这个初始网格：\n\n```\n..#.\n##.#\n.##.\n#...\n#...\n```\n\n包含以下4个物体：\n\n```\n##   #  #  #\n ##  #\n```\n\n当游戏开始时，每个物体开始以相同的速度匀速下落，它们持续下落，直到它接触到最下面的一行或是另一物体的顶部，而在接触时停止下落。\n\n求网格的最终状态。", "inputFormat": "第一行，两个正整数$N M$（用空格隔开）。\n\n随后$N$行，每行$M$个字符，代表网格。它们或是`#`，或是`.`，含义见题目描述。", "outputFormat": "$N$行，每行$M$个字符，代表网格的最终状态。它们或是`#`，或是`.`，含义见题目描述。", "hint": "### 限制\n\n$ 1 \\le N \\times M \\le 10^6 $\n\n### 子任务\n\nSubtask 1 （40分）：$ 1 \\le N \\times M \\le 2000 $\n\nSubtask 2 （24分）：$ M = 2 $\n\nSubtask 3 （36分）：没有附加限制。", "locale": "zh-CN"}}}
{"pid": "P5533", "type": "P", "difficulty": 6, "samples": [["4\n3 3 4 1\n1 2 1", "67"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "CCO（加拿大）"], "title": "[CCO 2019] Winter Driving", "background": "", "description": "在雪白帝国背部分布有$N$个城市，从$1$到$N$编号。对于一座城市$i$，有$A_i$位居民居住在其中。\n\n它们间分布有$N-1$条道路，从$2$到$N$编号。对于一条路$j$，它连接城市$j$和$P_j$，其中$P_j \\lt j$。任何城市最多被连接到36条路。\n\n在冬季，危险的驾驶条件使得政府执行交通管制，所有的路都变为单向高速公路，即对于一条路$j$，它要么成为从城市$j$到城市$P_j$的单向高速公路，要么成为从城市$P_j$到城市$j$的单向高速公路。\n\n此时，每个居民都想给其他所有公民寄假日贺卡。然而，如果要从城市$X$向城市$Y$发送一张假日贺卡，必须保证可以通过高速公路连接$X$和$Y$，或者$X=Y$。\n\n请求出，当所有的公路都被转换为单向高速公路后，最多可以被送出的贺卡总数。", "inputFormat": "第一行，一个正整数$N$。\n\n第二行，$N$个正整数$A_1$ ~ $A_N$。\n\n第三行，$N-1$个正整数$P_2$ ~ $P_N$。", "outputFormat": "一行，一个正整数，即最多可以被送出的贺卡总数。", "hint": "### 样例解释\n\n一种可能的做法是将：\n\n![avatar](https://s2.ax1x.com/2019/08/29/mq4eat.png)\n\n转化为：\n\n![avatar](https://s2.ax1x.com/2019/08/29/mq5jtx.png)\n\n此时，3号城的每个居民都可以往3号城寄3张卡片，往2号城寄3张，往1号城寄3张，往4号城寄1张。所以3号城共计可以发送40张。\n\n相似地，2号城共可寄18张，3号城共可寄9张，4号城一张也寄不了。\n\n所以答案为$40+18+9+0=67$。\n\n### 限制\n\n$2 \\le N \\le 200 000$\n\n对于任意合法$i$，$1 \\le A_i \\le 10 000$\n\n对于任意合法$j$，$1 \\le P_j \\le j$\n\n设$D$为任意一个城市连接的道路数量。$D \\le 36$。\n\n### 子任务\n\nSubtask 1（20分）：$N \\le 10$\n\nSubtask 2（20分）：$N \\le 1000$，$D \\le 10$\n\nSubtask 3（20分）：$D \\le 18$\n\nSubtask 4（20分）：$N=37$，且所有的道路均连向一个城市，亦即这个城市有36条连接的城市，且它们均只通过一条道路连向此城。\n\nSubtask 5（20分）：没有附加限制。", "locale": "zh-CN", "translations": {"en": {"title": "[CCO 2019] Winter Driving", "background": "", "description": "There are $N$ cities in the Northern White Empire, numbered from $1$ to $N$. In city $i$, there are $A_i$ residents.\n\nThere are $N - 1$ roads, numbered from $2$ to $N$. Road $j$ connects city $j$ and city $P_j$, where $P_j \\lt j$. Each city is connected to at most 36 roads.\n\nIn winter, dangerous driving conditions cause the government to enforce traffic control, and all roads become one-way highways. That is, for each road $j$, it becomes either a one-way highway from city $j$ to city $P_j$, or a one-way highway from city $P_j$ to city $j$.\n\nNow, every resident wants to send holiday cards to all other citizens. However, to send a holiday card from city $X$ to city $Y$, it must be possible to travel from $X$ to $Y$ using the highways, or $X = Y$.\n\nFind the maximum total number of cards that can be delivered after all roads are converted into one-way highways.", "inputFormat": "The first line contains a positive integer $N$.\n\nThe second line contains $N$ positive integers $A_1$ to $A_N$.\n\nThe third line contains $N - 1$ positive integers $P_2$ to $P_N$.", "outputFormat": "One line containing a positive integer, the maximum total number of holiday cards that can be delivered.", "hint": "### Sample Explanation\n\nOne possible way is to convert:\n\n![avatar](https://s2.ax1x.com/2019/08/29/mq4eat.png)\n\ninto:\n\n![avatar](https://s2.ax1x.com/2019/08/29/mq5jtx.png)\n\nThen, each resident in city 3 can send 3 cards to city 3, 3 cards to city 2, 3 cards to city 1, and 1 card to city 4. So city 3 can send a total of 40 cards.\n\nSimilarly, city 2 can send 18 cards in total, city 1 can send 9 cards in total, and city 4 cannot send any cards.\n\nSo the answer is $40 + 18 + 9 + 0 = 67$.\n\n### Constraints\n\n$2 \\le N \\le 200\\,000$\n\nFor any valid $i$, $1 \\le A_i \\le 10\\,000$\n\nFor any valid $j$, $1 \\le P_j \\le j$\n\nLet $D$ be the number of roads connected to any city. $D \\le 36$.\n\n### Subtasks\n\nSubtask 1 (20 points): $N \\le 10$\n\nSubtask 2 (20 points): $N \\le 1000$, $D \\le 10$\n\nSubtask 3 (20 points): $D \\le 18$\n\nSubtask 4 (20 points): $N = 37$, and all roads connect to one city, i.e. this city has 36 connected cities, and each of those cities is connected to it by only one road.\n\nSubtask 5 (20 points): No additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CCO 2019] Winter Driving", "background": "", "description": "在雪白帝国背部分布有$N$个城市，从$1$到$N$编号。对于一座城市$i$，有$A_i$位居民居住在其中。\n\n它们间分布有$N-1$条道路，从$2$到$N$编号。对于一条路$j$，它连接城市$j$和$P_j$，其中$P_j \\lt j$。任何城市最多被连接到36条路。\n\n在冬季，危险的驾驶条件使得政府执行交通管制，所有的路都变为单向高速公路，即对于一条路$j$，它要么成为从城市$j$到城市$P_j$的单向高速公路，要么成为从城市$P_j$到城市$j$的单向高速公路。\n\n此时，每个居民都想给其他所有公民寄假日贺卡。然而，如果要从城市$X$向城市$Y$发送一张假日贺卡，必须保证可以通过高速公路连接$X$和$Y$，或者$X=Y$。\n\n请求出，当所有的公路都被转换为单向高速公路后，最多可以被送出的贺卡总数。", "inputFormat": "第一行，一个正整数$N$。\n\n第二行，$N$个正整数$A_1$ ~ $A_N$。\n\n第三行，$N-1$个正整数$P_2$ ~ $P_N$。", "outputFormat": "一行，一个正整数，即最多可以被送出的贺卡总数。", "hint": "### 样例解释\n\n一种可能的做法是将：\n\n![avatar](https://s2.ax1x.com/2019/08/29/mq4eat.png)\n\n转化为：\n\n![avatar](https://s2.ax1x.com/2019/08/29/mq5jtx.png)\n\n此时，3号城的每个居民都可以往3号城寄3张卡片，往2号城寄3张，往1号城寄3张，往4号城寄1张。所以3号城共计可以发送40张。\n\n相似地，2号城共可寄18张，3号城共可寄9张，4号城一张也寄不了。\n\n所以答案为$40+18+9+0=67$。\n\n### 限制\n\n$2 \\le N \\le 200 000$\n\n对于任意合法$i$，$1 \\le A_i \\le 10 000$\n\n对于任意合法$j$，$1 \\le P_j \\le j$\n\n设$D$为任意一个城市连接的道路数量。$D \\le 36$。\n\n### 子任务\n\nSubtask 1（20分）：$N \\le 10$\n\nSubtask 2（20分）：$N \\le 1000$，$D \\le 10$\n\nSubtask 3（20分）：$D \\le 18$\n\nSubtask 4（20分）：$N=37$，且所有的道路均连向一个城市，亦即这个城市有36条连接的城市，且它们均只通过一条道路连向此城。\n\nSubtask 5（20分）：没有附加限制。", "locale": "zh-CN"}}}
{"pid": "P5534", "type": "P", "difficulty": 1, "samples": [["1 2 3\n", "6\n"], ["-5 -10 5\n", "-75\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["模拟", "数学", "O2优化"], "title": "【XR-3】等差数列", "background": "", "description": "小 X 给了你一个等差数列的前两项以及项数，请你求出这个等差数列各项之和。\n\n等差数列：对于一个 $n$ 项数列 $a$，如果满足对于任意 $i \\in [1,n)$，有 $a_{i+1} - a_i = d$，其中 $d$ 为定值，则称这个数列为一个等差数列。", "inputFormat": "一行 $3$ 个整数 $a_1, a_2, n$，表示等差数列的第 $1,2$ 项以及项数。\n\n**数据范围：**\n\n- $|a_1|,|a_2| \\le 10^6$。\n- $3 \\le n \\le 10^6$。", "outputFormat": "一行一个整数，表示答案。", "hint": "【样例 $1$ 说明】\n\n这个等差数列为 `1 2 3`，其各项之和为 $6$。", "locale": "zh-CN", "translations": {"en": {"title": "[XR-3] Arithmetic Progression.", "background": "", "description": "Xiao X gives you the first two terms and the number of terms of an arithmetic progression. Please find the sum of all terms of this arithmetic progression.\n\nArithmetic progression: For an $n$-term sequence $a$, if for any $i \\in [1,n)$ it satisfies $a_{i+1} - a_i = d$, where $d$ is a constant, then this sequence is called an arithmetic progression.", "inputFormat": "One line with $3$ integers $a_1, a_2, n$, representing the 1st and 2nd terms of the arithmetic progression and the number of terms.\n\n**Constraints:**\n\n- $|a_1|,|a_2| \\le 10^6$.\n- $3 \\le n \\le 10^6$.", "outputFormat": "One line with one integer, representing the answer.", "hint": "**Sample $1$ Explanation**\n\nThis arithmetic progression is `1 2 3`, and the sum of its terms is $6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【XR-3】等差数列", "background": "", "description": "小 X 给了你一个等差数列的前两项以及项数，请你求出这个等差数列各项之和。\n\n等差数列：对于一个 $n$ 项数列 $a$，如果满足对于任意 $i \\in [1,n)$，有 $a_{i+1} - a_i = d$，其中 $d$ 为定值，则称这个数列为一个等差数列。", "inputFormat": "一行 $3$ 个整数 $a_1, a_2, n$，表示等差数列的第 $1,2$ 项以及项数。\n\n**数据范围：**\n\n- $|a_1|,|a_2| \\le 10^6$。\n- $3 \\le n \\le 10^6$。", "outputFormat": "一行一个整数，表示答案。", "hint": "【样例 $1$ 说明】\n\n这个等差数列为 `1 2 3`，其各项之和为 $6$。", "locale": "zh-CN"}}}
{"pid": "P5535", "type": "P", "difficulty": 3, "samples": [["3 1\n", "2\n"], ["6 4\n", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["数学", "O2优化", "素数判断,质数,筛法", "最大公约数 gcd"], "title": "【XR-3】小道消息", "background": "", "description": "小 X 想探究小道消息传播的速度有多快，于是他做了一个社会实验。\n\n有 $n$ 个人，其中第 $i$ 个人的衣服上有一个数 $i+1$。小 X 发现了一个规律：当一个衣服上的数为 $i$ 的人在某一天知道了一条信息，他会在第二天把这条信息告诉衣服上的数为 $j$ 的人，其中 $\\gcd(i,j)=1$（即 $i,j$ 的最大公约数为 $1$）。在第 $0$ 天，小 X 把一条小道消息告诉了第 $k$ 个人，小 X 想知道第几天时所有人都会知道这条小道消息。\n\n可以证明，一定存在所有人都知道了这条小道消息的那一天。\n\n提示：你可能需要用到的定理——[伯特兰-切比雪夫定理](https://baike.baidu.com/item/%E4%BC%AF%E7%89%B9%E5%85%B0-%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E5%AE%9A%E7%90%86/2053704)。", "inputFormat": "一行 $2$ 个正整数 $n,k$。\n\n**数据范围：**\n\n- $2 \\le n \\le 10^{14}$。\n- $1 \\le k \\le n$。", "outputFormat": "一行一个正整数，表示答案。", "hint": "【样例 $1$ 说明】\n\n$3$ 个人的衣服上的数分别为 `2 3 4`。\n\n在第 $0$ 天，小 X 把一条小道消息告诉了第 $1$ 个人，他的衣服上的数为2。\n\n在第 $1$ 天，第 $1$ 个人会告诉第 $2$ 个人，因为 $\\gcd(2,3) = 1$，但他不会告诉第 $3$ 个人，因为 $\\gcd(2,4) = 2 \\ne 1$。\n\n在第 $2$ 天，第 $2$ 个人会告诉第 $3$ 个人，因为 $\\gcd(3,4) = 1$，这时所有人都知道了这条小道消息，因此答案为 $2$。", "locale": "zh-CN", "translations": {"en": {"title": "[XR-3] Rumors", "background": "", "description": "Xiao X wants to study how fast a rumor spreads, so he did a social experiment.\n\nThere are $n$ people. The number on person $i$'s clothes is $i+1$. Xiao X found a rule: if a person whose clothing number is $i$ learns a piece of information on some day, then on the next day he will tell this information to every person whose clothing number is $j$ such that $\\gcd(i,j)=1$ (that is, the greatest common divisor of $i$ and $j$ is $1$). On day $0$, Xiao X tells a rumor to the $k$-th person. Xiao X wants to know on which day everyone will know this rumor.\n\nIt can be proven that such a day when everyone knows the rumor must exist.\n\nHint: You may need the following theorem — [Bertrand–Chebyshev theorem](https://baike.baidu.com/item/%E4%BC%AF%E7%89%B9%E5%85%B0-%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E5%AE%9A%E7%90%86/2053704).", "inputFormat": "One line with $2$ positive integers $n,k$.\n\n**Constraints:**\n\n- $2 \\le n \\le 10^{14}$.\n- $1 \\le k \\le n$.", "outputFormat": "One line with one positive integer, the answer.", "hint": "**Explanation for Sample $1$**\n\nThe clothing numbers of the $3$ people are `2 3 4`.\n\nOn day $0$, Xiao X tells a rumor to person $1$, whose clothing number is $2$.\n\nOn day $1$, person $1$ will tell person $2$ because $\\gcd(2,3)=1$, but he will not tell person $3$ because $\\gcd(2,4)=2 \\ne 1$.\n\nOn day $2$, person $2$ will tell person $3$ because $\\gcd(3,4)=1$. Now everyone knows the rumor, so the answer is $2$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【XR-3】小道消息", "background": "", "description": "小 X 想探究小道消息传播的速度有多快，于是他做了一个社会实验。\n\n有 $n$ 个人，其中第 $i$ 个人的衣服上有一个数 $i+1$。小 X 发现了一个规律：当一个衣服上的数为 $i$ 的人在某一天知道了一条信息，他会在第二天把这条信息告诉衣服上的数为 $j$ 的人，其中 $\\gcd(i,j)=1$（即 $i,j$ 的最大公约数为 $1$）。在第 $0$ 天，小 X 把一条小道消息告诉了第 $k$ 个人，小 X 想知道第几天时所有人都会知道这条小道消息。\n\n可以证明，一定存在所有人都知道了这条小道消息的那一天。\n\n提示：你可能需要用到的定理——[伯特兰-切比雪夫定理](https://baike.baidu.com/item/%E4%BC%AF%E7%89%B9%E5%85%B0-%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E5%AE%9A%E7%90%86/2053704)。", "inputFormat": "一行 $2$ 个正整数 $n,k$。\n\n**数据范围：**\n\n- $2 \\le n \\le 10^{14}$。\n- $1 \\le k \\le n$。", "outputFormat": "一行一个正整数，表示答案。", "hint": "【样例 $1$ 说明】\n\n$3$ 个人的衣服上的数分别为 `2 3 4`。\n\n在第 $0$ 天，小 X 把一条小道消息告诉了第 $1$ 个人，他的衣服上的数为2。\n\n在第 $1$ 天，第 $1$ 个人会告诉第 $2$ 个人，因为 $\\gcd(2,3) = 1$，但他不会告诉第 $3$ 个人，因为 $\\gcd(2,4) = 2 \\ne 1$。\n\n在第 $2$ 天，第 $2$ 个人会告诉第 $3$ 个人，因为 $\\gcd(3,4) = 1$，这时所有人都知道了这条小道消息，因此答案为 $2$。", "locale": "zh-CN"}}}
{"pid": "P5536", "type": "P", "difficulty": 4, "samples": [["6 3\n1 2\n2 3\n2 4\n1 5\n5 6\n", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["贪心", "堆", "O2优化", "树的直径"], "title": "【XR-3】核心城市", "background": null, "description": "X 国有 $n$ 座城市，$n - 1$ 条长度为 $1$ 的道路，每条道路连接两座城市，且任意两座城市都能通过若干条道路相互到达，显然，城市和道路形成了一棵树。\n\nX 国国王决定将 $k$ 座城市钦定为 X 国的核心城市，其余城市为非核心城市。这 $k$ 座核心城市需满足以下两个条件：\n\n1. 这 $k$ 座城市可以通过道路，在不经过非核心城市的情况下两两相互到达。\n2. 定义某个非核心城市与这 $k$ 座核心城市的距离为，这座城市与 $k$ 座核心城市的距离的最小值。\n\n为了衡量交通状况，国王发明了交通拥堵度，它为所有非核心城市与核心城市的距离中的最大值。\n\n问题来了，如何安排核心城市才能使交通拥堵度最小呢？请输出满足条件的最小交通拥堵度。", "inputFormat": "第一行 $2$ 个正整数 $n,k$。\n\n接下来 $n - 1$ 行，每行 $2$ 个正整数 $u,v$，表示第 $u$ 座城市与第 $v$ 座城市之间有一条长度为 $1$ 的道路。\n\n**数据范围：**\n\n- $1 \\le k < n \\le 10 ^ 5$。\n- $1 \\le u,v \\le n, u \\ne v$，保证城市与道路形成一棵树。", "outputFormat": "一行一个整数，表示满足条件的最小交通拥堵度。", "hint": "【样例说明】\n\n钦定 $1,2,5$ 这 $3$ 座城市为核心城市，这样 $3,4,6$ 另外 $3$ 座非核心城市与核心城市的距离均为 $1$，因此答案为 $1$。", "locale": "zh-CN", "translations": {"en": {"title": "[XR-3] Core Cities", "background": "", "description": "Country X has $n$ cities and $n - 1$ roads of length $1$. Each road connects two cities, and any two cities can reach each other through some roads. Obviously, the cities and roads form a tree.\n\nThe king of Country X decides to designate $k$ cities as the core cities of Country X, and the remaining cities are non-core cities. These $k$ core cities must satisfy the following two conditions:\n\n1. These $k$ cities can reach each other pairwise via roads without passing through any non-core city.\n2. Define the distance from a non-core city to the $k$ core cities as the minimum value among its distances to the $k$ core cities.\n\nTo measure traffic conditions, the king invented the traffic congestion level, which is the maximum value among the distances from all non-core cities to the core cities.\n\nThe problem is: how should we choose the core cities to minimize the traffic congestion level? Output the minimum possible traffic congestion level that satisfies the conditions.", "inputFormat": "The first line contains $2$ positive integers $n, k$.\n\nThe next $n - 1$ lines each contain $2$ positive integers $u, v$, meaning there is a road of length $1$ between city $u$ and city $v$.\n\n**Constraints:**\n\n- $1 \\le k < n \\le 10 ^ 5$.\n- $1 \\le u, v \\le n, u \\ne v$, and it is guaranteed that the cities and roads form a tree.", "outputFormat": "One line with one integer, representing the minimum traffic congestion level that satisfies the conditions.", "hint": "[Sample Explanation]\n\nDesignate cities $1, 2, 5$ as the $3$ core cities. Then the distances from the other $3$ non-core cities $3, 4, 6$ to the core cities are all $1$, so the answer is $1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【XR-3】核心城市", "background": null, "description": "X 国有 $n$ 座城市，$n - 1$ 条长度为 $1$ 的道路，每条道路连接两座城市，且任意两座城市都能通过若干条道路相互到达，显然，城市和道路形成了一棵树。\n\nX 国国王决定将 $k$ 座城市钦定为 X 国的核心城市，其余城市为非核心城市。这 $k$ 座核心城市需满足以下两个条件：\n\n1. 这 $k$ 座城市可以通过道路，在不经过非核心城市的情况下两两相互到达。\n2. 定义某个非核心城市与这 $k$ 座核心城市的距离为，这座城市与 $k$ 座核心城市的距离的最小值。\n\n为了衡量交通状况，国王发明了交通拥堵度，它为所有非核心城市与核心城市的距离中的最大值。\n\n问题来了，如何安排核心城市才能使交通拥堵度最小呢？请输出满足条件的最小交通拥堵度。", "inputFormat": "第一行 $2$ 个正整数 $n,k$。\n\n接下来 $n - 1$ 行，每行 $2$ 个正整数 $u,v$，表示第 $u$ 座城市与第 $v$ 座城市之间有一条长度为 $1$ 的道路。\n\n**数据范围：**\n\n- $1 \\le k < n \\le 10 ^ 5$。\n- $1 \\le u,v \\le n, u \\ne v$，保证城市与道路形成一棵树。", "outputFormat": "一行一个整数，表示满足条件的最小交通拥堵度。", "hint": "【样例说明】\n\n钦定 $1,2,5$ 这 $3$ 座城市为核心城市，这样 $3,4,6$ 另外 $3$ 座非核心城市与核心城市的距离均为 $1$，因此答案为 $1$。", "locale": "zh-CN"}}}
{"pid": "P5537", "type": "P", "difficulty": 6, "samples": [["6 6 10\n0 1 2 2 1 5\n1 2 2 1 2 1\n1 1 1 3\n1 5 2 6\n1 6 5 6\n1 2 3 5\n1 2 4 4\n2 2 1\n1 1 1 6\n1 1 2 4\n2 1 2\n1 1 1 5\n", "4\n5\n6\n4\n3\n3\n4\n6\n"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["字符串", "线段树", "二分", "树状数组", "O2优化", "哈希 hashing"], "title": "【XR-3】系统设计", "background": "", "description": "小 X 需要你设计一个系统。\n\n这个系统首先需要输入一棵 $n$ 个点的有根树和一个长度为 $m$ 的序列 $a$，接下来需要实现 $q$ 个操作。\n\n操作分两种：\n\n1. `1 x l r` 表示设定起点为有根树的节点 $x$，接下来依次遍历 $l \\sim r$。当遍历到 $i$ 时，从当前节点走向它的编号第 $a_i$ 小的儿子。如果某一时刻当前节点的儿子个数小于 $a_i$，或者已经遍历完 $l \\sim r$，则在这个点停住，并输出这个点的编号，同时停止遍历。\n2. `2 t k` 表示将序列中第 $t$ 个数 $a_t$ 修改为 $k$。", "inputFormat": "第一行 $3$ 个正整数 $n,m,q$，分别表示树的点数、序列的长度和操作个数。\n\n第二行 $n$ 个整数 $f_{1 \\dots n}$，其中 $f_i$ 表示点 $i$ 在树中的父亲节点编号，特别地，设根节点为 $rt$，则 $f_{rt} = 0$。\n\n第三行 $m$ 个正整数 $a_{1 \\dots m}$，表示序列 $a$。\n\n接下来 $q$ 行，每行描述一个操作。\n\n**数据范围：**\n\n- $1 \\le n,m,q \\le 5 \\times 10 ^ 5$。\n- $1 \\le a_i \\le n$。\n- 对于操作 $1$，保证 $1 \\le x \\le n$，$1 \\le l \\le r \\le m$。\n- 对于操作 $2$，保证 $1 \\le t \\le m$，$1 \\le k \\le n$。", "outputFormat": "对于每个操作 $1$，一行一个正整数，表示答案。", "hint": "本题读入、输出量较大，请使用[读入、输出优化](https://oi-wiki.org/misc/io/)。\n\n【样例说明】\n\n第一个操作为 `1 1 1 3`，即 $1 \\rightarrow 2 \\rightarrow 4$，因此答案为 $4$。\n\n第九个操作后，序列变为 `2 1 2 1 2 1`。\n\n第十个操作为 `1 1 1 5`，即 $1 \\rightarrow 5 \\rightarrow 6$，因此答案为 $6$。", "locale": "zh-CN", "translations": {"en": {"title": "[XR-3] System Design", "background": "", "description": "Little X needs you to design a system.\n\nThis system first needs to read a rooted tree with $n$ nodes and a sequence $a$ of length $m$, and then process $q$ operations.\n\nThere are two types of operations:\n\n1. `1 x l r` means: set the starting point as node $x$ in the rooted tree, then traverse $l \\sim r$ in order. When traversing to $i$, move from the current node to its $a_i$-th smallest child (by node index). If at some moment the current node has fewer than $a_i$ children, or you have already finished traversing $l \\sim r$, then stop at this node, output its index, and stop traversing.\n2. `2 t k` means: modify the $t$-th number in the sequence, changing $a_t$ to $k$.", "inputFormat": "The first line contains $3$ positive integers $n, m, q$, representing the number of nodes in the tree, the length of the sequence, and the number of operations.\n\nThe second line contains $n$ integers $f_{1 \\dots n}$, where $f_i$ is the index of the parent of node $i$ in the tree. In particular, let the root be $rt$, then $f_{rt} = 0$.\n\nThe third line contains $m$ positive integers $a_{1 \\dots m}$, representing the sequence $a$.\n\nThen follow $q$ lines, each describing one operation.\n\n**Constraints:**\n\n- $1 \\le n, m, q \\le 5 \\times 10 ^ 5$.\n- $1 \\le a_i \\le n$.\n- For operation type $1$, it is guaranteed that $1 \\le x \\le n$, $1 \\le l \\le r \\le m$.\n- For operation type $2$, it is guaranteed that $1 \\le t \\le m$, $1 \\le k \\le n$.", "outputFormat": "For each operation of type $1$, output one positive integer per line, representing the answer.", "hint": "The input and output size of this problem is large. Please use [fast input/output](https://oi-wiki.org/misc/io/).\n\n**Sample Explanation**\n\nThe first operation is `1 1 1 3`, that is, $1 \\rightarrow 2 \\rightarrow 4$, so the answer is $4$.\n\nAfter the ninth operation, the sequence becomes `2 1 2 1 2 1`.\n\nThe tenth operation is `1 1 1 5`, that is, $1 \\rightarrow 5 \\rightarrow 6$, so the answer is $6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【XR-3】系统设计", "background": "", "description": "小 X 需要你设计一个系统。\n\n这个系统首先需要输入一棵 $n$ 个点的有根树和一个长度为 $m$ 的序列 $a$，接下来需要实现 $q$ 个操作。\n\n操作分两种：\n\n1. `1 x l r` 表示设定起点为有根树的节点 $x$，接下来依次遍历 $l \\sim r$。当遍历到 $i$ 时，从当前节点走向它的编号第 $a_i$ 小的儿子。如果某一时刻当前节点的儿子个数小于 $a_i$，或者已经遍历完 $l \\sim r$，则在这个点停住，并输出这个点的编号，同时停止遍历。\n2. `2 t k` 表示将序列中第 $t$ 个数 $a_t$ 修改为 $k$。", "inputFormat": "第一行 $3$ 个正整数 $n,m,q$，分别表示树的点数、序列的长度和操作个数。\n\n第二行 $n$ 个整数 $f_{1 \\dots n}$，其中 $f_i$ 表示点 $i$ 在树中的父亲节点编号，特别地，设根节点为 $rt$，则 $f_{rt} = 0$。\n\n第三行 $m$ 个正整数 $a_{1 \\dots m}$，表示序列 $a$。\n\n接下来 $q$ 行，每行描述一个操作。\n\n**数据范围：**\n\n- $1 \\le n,m,q \\le 5 \\times 10 ^ 5$。\n- $1 \\le a_i \\le n$。\n- 对于操作 $1$，保证 $1 \\le x \\le n$，$1 \\le l \\le r \\le m$。\n- 对于操作 $2$，保证 $1 \\le t \\le m$，$1 \\le k \\le n$。", "outputFormat": "对于每个操作 $1$，一行一个正整数，表示答案。", "hint": "本题读入、输出量较大，请使用[读入、输出优化](https://oi-wiki.org/misc/io/)。\n\n【样例说明】\n\n第一个操作为 `1 1 1 3`，即 $1 \\rightarrow 2 \\rightarrow 4$，因此答案为 $4$。\n\n第九个操作后，序列变为 `2 1 2 1 2 1`。\n\n第十个操作为 `1 1 1 5`，即 $1 \\rightarrow 5 \\rightarrow 6$，因此答案为 $6$。", "locale": "zh-CN"}}}
{"pid": "P5538", "type": "P", "difficulty": 7, "samples": [["10\n15 50 89 9 38 73 38 23 6 52\n2 1\n3 2\n4 2\n5 3\n6 3\n7 5\n8 7\n9 1\n10 7\n", "54184\n"], ["20\n17 56 72 12 16 43 33 8 28 90 21 12 7 43 55 95 25 65 63 77\n2 1\n3 2\n4 1\n5 3\n6 5\n7 1\n8 7\n9 7\n10 3\n11 5\n12 7\n13 5\n14 7\n15 11\n16 6\n17 3\n18 15\n19 15\n20 13\n", "503636\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["图论", "O2优化", "树论", "位运算"], "title": "【XR-3】Namid[A]me", "background": "", "description": "小 X 给了你一棵 $n$ 个点的树，点有点权。\n\n你需要求出下列式子模 $786433$ 的值：\n\n$\\sum_{1\\leq u\\leq v\\leq n}f(u,v)^{f(u,v)}$\n\n其中 $f(u,v)$ 表示 $u$ 到 $v$ 的最短路径上所有点的点权按位与在一起之后的值。\n\n提示：为了方便你的计算，这里我们认为 $0^0=0$。另外，$786433$ 是一个质数，同时也是一个不常用的 NTT 模数，它的原根为 $10$，如果你不知道什么是 NTT 或者不知道什么是原根，你可以忽略这个提示。", "inputFormat": "第一行一个正整数 $n$，表示树的点数。\n\n第二行 $n$ 个正整数 $a_{1\\dots n}$，其中 $a_i$ 表示编号为 $i$ 的点的点权。\n\n接下来 $n-1$ 行，每行 $2$ 个正整数 $u,v$，表示编号为 $u$ 和编号为 $v$ 的点之间有一条边。\n\n**数据范围：**\n\n- $2 \\le n \\le 2 \\times 10^5$。\n- 对于所有满足 $1\\le i \\le n$ 的 $i$ 都有 $1 \\le a_i < 2^{30}$。\n- $1 \\le u,v \\le n, u \\ne v$。\n- 设 $d$ 为树中叶子（度数为 $1$ 的点）的个数，数据保证 $4\\le n \\cdot d \\le 3 \\times 10 ^ 6$。", "outputFormat": "一行一个整数，表示答案对 $786433$ 取模后的值。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[XR-3] Namid[A]me", "background": "", "description": "X gives you a tree with $n$ nodes, and each node has a weight.\n\nYou need to compute the value of the following expression modulo $786433$:\n\n$\\sum_{1\\leq u\\leq v\\leq n}f(u,v)^{f(u,v)}$\n\nHere, $f(u,v)$ is the value obtained by taking the bitwise AND of the weights of all nodes on the shortest path from $u$ to $v$.\n\nHint: To make calculation easier, we define $0^0=0$. Also, $786433$ is a prime number and an uncommon NTT modulus, whose primitive root is $10$. If you do not know what NTT is or what a primitive root is, you can ignore this hint.", "inputFormat": "The first line contains a positive integer $n$, the number of nodes in the tree.\n\nThe second line contains $n$ positive integers $a_{1\\dots n}$, where $a_i$ is the weight of node $i$.\n\nThe next $n-1$ lines each contain two positive integers $u,v$, meaning there is an edge between node $u$ and node $v$.\n\n**Constraints:**\n\n- $2 \\le n \\le 2 \\times 10^5$.\n- For all $i$ satisfying $1\\le i \\le n$, $1 \\le a_i < 2^{30}$.\n- $1 \\le u,v \\le n, u \\ne v$.\n- Let $d$ be the number of leaves in the tree (nodes with degree $1$). The testdata guarantees that $4\\le n \\cdot d \\le 3 \\times 10 ^ 6$.", "outputFormat": "Output one integer on one line, the answer modulo $786433$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【XR-3】Namid[A]me", "background": "", "description": "小 X 给了你一棵 $n$ 个点的树，点有点权。\n\n你需要求出下列式子模 $786433$ 的值：\n\n$\\sum_{1\\leq u\\leq v\\leq n}f(u,v)^{f(u,v)}$\n\n其中 $f(u,v)$ 表示 $u$ 到 $v$ 的最短路径上所有点的点权按位与在一起之后的值。\n\n提示：为了方便你的计算，这里我们认为 $0^0=0$。另外，$786433$ 是一个质数，同时也是一个不常用的 NTT 模数，它的原根为 $10$，如果你不知道什么是 NTT 或者不知道什么是原根，你可以忽略这个提示。", "inputFormat": "第一行一个正整数 $n$，表示树的点数。\n\n第二行 $n$ 个正整数 $a_{1\\dots n}$，其中 $a_i$ 表示编号为 $i$ 的点的点权。\n\n接下来 $n-1$ 行，每行 $2$ 个正整数 $u,v$，表示编号为 $u$ 和编号为 $v$ 的点之间有一条边。\n\n**数据范围：**\n\n- $2 \\le n \\le 2 \\times 10^5$。\n- 对于所有满足 $1\\le i \\le n$ 的 $i$ 都有 $1 \\le a_i < 2^{30}$。\n- $1 \\le u,v \\le n, u \\ne v$。\n- 设 $d$ 为树中叶子（度数为 $1$ 的点）的个数，数据保证 $4\\le n \\cdot d \\le 3 \\times 10 ^ 6$。", "outputFormat": "一行一个整数，表示答案对 $786433$ 取模后的值。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P5539", "type": "P", "difficulty": 5, "samples": [["10 3\n2 4 5\n", "1\n"], ["100000 6\n14 47 31 233 666 59\n", "91\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["O2优化", "枚举", "位运算"], "title": "【XR-3】Unknown Mother-Goose", "background": "", "description": "小 X 得到了一个正整数 $n$ 和一个正整数集合 $S$，他想知道有多少个正整数 $x$ 满足以下所有条件：\n\n- $3 \\le x \\le n$\n- 存在 $a \\in S, x \\equiv 0 \\pmod a$\n- 存在 $b \\in S,x-1 \\equiv 0 \\pmod b$\n- 存在 $c \\in S,x-2 \\equiv 0 \\pmod c$\n\n请你帮小 X 求出来。", "inputFormat": "第一行两个正整数 $n,|S|$，表示你得到的 $n$ 和正整数集合 $S$ 的大小。\n\n第二行 $|S|$ 个正整数，表示正整数集合 $S$ 中的元素。\n\n**数据范围：**\n\n- $3 \\le n \\le 10^9$。\n- $3 \\le |S| \\le 20$。\n- 保证 $S$ 中所有元素均小于 $n$，不保证所有元素互不相同。", "outputFormat": "一行一个整数，表示答案。", "hint": "【样例 $1$ 说明】\n\n只有当 $x = 6$ 时：\n\n- $x \\equiv 0 \\pmod 2$\n- $x \\equiv 1 \\pmod 5$\n- $x \\equiv 2 \\pmod 4$\n\n满足条件。", "locale": "zh-CN", "translations": {"en": {"title": "[XR-3] Unknown Mother-Goose", "background": "", "description": "Xiao X is given a positive integer $n$ and a set of positive integers $S$. He wants to know how many positive integers $x$ satisfy all of the following conditions:\n\n- $3 \\le x \\le n$\n- There exists $a \\in S$ such that $x \\equiv 0 \\pmod a$\n- There exists $b \\in S$ such that $x-1 \\equiv 0 \\pmod b$\n- There exists $c \\in S$ such that $x-2 \\equiv 0 \\pmod c$\n\nPlease help Xiao X compute the answer.", "inputFormat": "The first line contains two positive integers $n, |S|$, representing the given $n$ and the size of the set $S$.\n\nThe second line contains $|S|$ positive integers, representing the elements in the set $S$.\n\n**Constraints:**\n\n- $3 \\le n \\le 10^9$.\n- $3 \\le |S| \\le 20$.\n- All elements in $S$ are less than $n$. Elements are not guaranteed to be distinct.", "outputFormat": "Output one integer in a single line, representing the answer.", "hint": "[Sample $1$ Explanation]\n\nOnly when $x = 6$:\n\n- $x \\equiv 0 \\pmod 2$\n- $x \\equiv 1 \\pmod 5$\n- $x \\equiv 2 \\pmod 4$\n\ndo the conditions hold.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【XR-3】Unknown Mother-Goose", "background": "", "description": "小 X 得到了一个正整数 $n$ 和一个正整数集合 $S$，他想知道有多少个正整数 $x$ 满足以下所有条件：\n\n- $3 \\le x \\le n$\n- 存在 $a \\in S, x \\equiv 0 \\pmod a$\n- 存在 $b \\in S,x-1 \\equiv 0 \\pmod b$\n- 存在 $c \\in S,x-2 \\equiv 0 \\pmod c$\n\n请你帮小 X 求出来。", "inputFormat": "第一行两个正整数 $n,|S|$，表示你得到的 $n$ 和正整数集合 $S$ 的大小。\n\n第二行 $|S|$ 个正整数，表示正整数集合 $S$ 中的元素。\n\n**数据范围：**\n\n- $3 \\le n \\le 10^9$。\n- $3 \\le |S| \\le 20$。\n- 保证 $S$ 中所有元素均小于 $n$，不保证所有元素互不相同。", "outputFormat": "一行一个整数，表示答案。", "hint": "【样例 $1$ 说明】\n\n只有当 $x = 6$ 时：\n\n- $x \\equiv 0 \\pmod 2$\n- $x \\equiv 1 \\pmod 5$\n- $x \\equiv 2 \\pmod 4$\n\n满足条件。", "locale": "zh-CN"}}}
{"pid": "P5540", "type": "P", "difficulty": 7, "samples": [["4 5\n0 1 1 2\n0 2 2 3\n0 3 1 5\n1 3 3 4\n2 3 1 3", "3 10"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["图论", "计算几何", "2011", "生成树", "BalkanOI（巴尔干半岛）"], "title": "[BalkanOI 2011] timeismoney", "background": "", "description": "给出一个 $n$ 个点 $m$ 条边的无向图，第 $i$ 条边有两个权值 $a_i$ 和 $b_i$ 。\n\n求该图的一棵生成树 $T$ ，使得\n\n$$\\left(\\sum_{e\\in T}a_e\\right)\\times\\left(\\sum_{e\\in T}b_e\\right)$$\n\n最小。", "inputFormat": "第一行两个正整数 $n,m$ 。\n\n下 $m$ 行，每行 $4$ 个整数 $u_i,v_i,a_i,b_i$ ，表示第 $i$ 条边连接  $u_i$ 和 $v_i$ ，权值为 $a_i$ 和 $b_i$ 。\n\n点的编号为 $0\\sim n-1$ 。", "outputFormat": "假设你求出的生成树为 $T$ ，你需要输出一行两个整数，分别为 $\\displaystyle\\sum_{e\\in T}a_e$ 和 $\\displaystyle\\sum_{e\\in T}b_e$ 。\n\n如果有多解，请输出 $\\displaystyle\\sum_{e\\in T}a_e$ 最小的那个。", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 200,1\\leq m\\leq 10000,0\\leq a_i,b_i\\leq 255$ 。", "locale": "zh-CN", "translations": {"en": {"title": "[BalkanOI 2011] timeismoney", "background": "", "description": "Given an undirected graph with $n$ vertices and $m$ edges, the $i$-th edge has two weights $a_i$ and $b_i$.\n\nFind a spanning tree $T$ of this graph such that\n\n$$\\left(\\sum_{e\\in T}a_e\\right)\\times\\left(\\sum_{e\\in T}b_e\\right)$$\n\nis minimized.", "inputFormat": "The first line contains two positive integers $n,m$.\n\nThe next $m$ lines each contain $4$ integers $u_i,v_i,a_i,b_i$, meaning that the $i$-th edge connects $u_i$ and $v_i$, with weights $a_i$ and $b_i$.\n\nThe vertices are numbered from $0$ to $n-1$.", "outputFormat": "Suppose the spanning tree you found is $T$. Output one line with two integers, which are $\\displaystyle\\sum_{e\\in T}a_e$ and $\\displaystyle\\sum_{e\\in T}b_e$.\n\nIf there are multiple solutions, output the one with the smallest $\\displaystyle\\sum_{e\\in T}a_e$.", "hint": "For $100\\%$ of the testdata, $1\\leq n\\leq 200$, $1\\leq m\\leq 10000$, $0\\leq a_i,b_i\\leq 255$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalkanOI 2011] timeismoney", "background": "", "description": "给出一个 $n$ 个点 $m$ 条边的无向图，第 $i$ 条边有两个权值 $a_i$ 和 $b_i$ 。\n\n求该图的一棵生成树 $T$ ，使得\n\n$$\\left(\\sum_{e\\in T}a_e\\right)\\times\\left(\\sum_{e\\in T}b_e\\right)$$\n\n最小。", "inputFormat": "第一行两个正整数 $n,m$ 。\n\n下 $m$ 行，每行 $4$ 个整数 $u_i,v_i,a_i,b_i$ ，表示第 $i$ 条边连接  $u_i$ 和 $v_i$ ，权值为 $a_i$ 和 $b_i$ 。\n\n点的编号为 $0\\sim n-1$ 。", "outputFormat": "假设你求出的生成树为 $T$ ，你需要输出一行两个整数，分别为 $\\displaystyle\\sum_{e\\in T}a_e$ 和 $\\displaystyle\\sum_{e\\in T}b_e$ 。\n\n如果有多解，请输出 $\\displaystyle\\sum_{e\\in T}a_e$ 最小的那个。", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 200,1\\leq m\\leq 10000,0\\leq a_i,b_i\\leq 255$ 。", "locale": "zh-CN"}}}
{"pid": "P5541", "type": "P", "difficulty": 3, "samples": [["3 \n4 \n7 \n9", "1\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["模拟", "贪心", "2019", "USACO", "排序"], "title": "[USACO19FEB] Sleepy Cow Herding S", "background": "", "description": "Farmer John 的 $N$ 头奶牛，总是会迷路走到农场上遥远的地方去！他需要你帮助将她们一起赶回来。\n\n农场的草地大体是一块狭长的区域——我们可以将其想象成一条数轴，奶牛可以占据数轴上的任意整数位置。这 $N$ 头奶牛现在正位于不同的整数位置，Farmer John 想要移动她们，使得她们占据 $N$ 个相邻的位置（例如，位置 $6$、$7$、$8$）。\n\n不幸的是，奶牛们现在很困，Farmer John 要让她们集中精力听从命令移动并不容易。任意时刻，他只能使得一头处在“端点”（在所有奶牛中位置最小或最大）位置的奶牛移动。当他移动奶牛时，他可以命令她走到任意一个未被占用的整数位置，只要在新的位置上她不再是一个端点。可以看到随着时间的推移，这样的移动可以使奶牛们趋向越来越近。\n\n请求出使得奶牛们集中到相邻位置所进行的移动次数的最小和最大可能值。", "inputFormat": "先输入一个整数 $N$（$N \\leq 100000$），接下来输入 $N$ 个数，表示 $N$ 头奶牛的位置。", "outputFormat": "输出的第一行包含 Farmer John 需要将奶牛们聚集起来所需进行的最小移动次数。第二行包含他将奶牛聚集起来能够进行的最大移动次数。", "hint": "2019 USACO 二月月赛银牌组第一题", "locale": "zh-CN", "translations": {"en": {"title": "[USACO19FEB] Sleepy Cow Herding S", "background": "", "description": "Farmer John’s $N$ cows always get lost and wander far away on the farm. He needs your help to herd them back together.\n\nThe farm’s pasture is basically a long narrow region—we can think of it as a number line, and cows can stand at any integer position on this line. These $N$ cows are currently at distinct integer positions. Farmer John wants to move them so that they occupy $N$ consecutive positions (for example, positions $6$, $7$, $8$).\n\nUnfortunately, the cows are very sleepy right now, so it is not easy for Farmer John to get them to focus and follow moving orders. At any moment, he can only move a cow that is at an “endpoint” (the cow with the smallest or largest position among all cows). When he moves a cow, he may command it to go to any unoccupied integer position, as long as at its new position it is no longer an endpoint. You can see that over time, such moves can make the cows get closer and closer together.\n\nFind the minimum and maximum possible number of moves required to make the cows gather into consecutive positions.", "inputFormat": "First input an integer $N$ ($N \\leq 100000$). Then input $N$ numbers, representing the positions of the $N$ cows.", "outputFormat": "The first line contains the minimum number of moves Farmer John needs to gather the cows together. The second line contains the maximum number of moves he could make while still gathering the cows together.", "hint": "The first problem of the Silver Division in the February 2019 USACO contest.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO19FEB] Sleepy Cow Herding S", "background": "", "description": "Farmer John 的 $N$ 头奶牛，总是会迷路走到农场上遥远的地方去！他需要你帮助将她们一起赶回来。\n\n农场的草地大体是一块狭长的区域——我们可以将其想象成一条数轴，奶牛可以占据数轴上的任意整数位置。这 $N$ 头奶牛现在正位于不同的整数位置，Farmer John 想要移动她们，使得她们占据 $N$ 个相邻的位置（例如，位置 $6$、$7$、$8$）。\n\n不幸的是，奶牛们现在很困，Farmer John 要让她们集中精力听从命令移动并不容易。任意时刻，他只能使得一头处在“端点”（在所有奶牛中位置最小或最大）位置的奶牛移动。当他移动奶牛时，他可以命令她走到任意一个未被占用的整数位置，只要在新的位置上她不再是一个端点。可以看到随着时间的推移，这样的移动可以使奶牛们趋向越来越近。\n\n请求出使得奶牛们集中到相邻位置所进行的移动次数的最小和最大可能值。", "inputFormat": "先输入一个整数 $N$（$N \\leq 100000$），接下来输入 $N$ 个数，表示 $N$ 头奶牛的位置。", "outputFormat": "输出的第一行包含 Farmer John 需要将奶牛们聚集起来所需进行的最小移动次数。第二行包含他将奶牛聚集起来能够进行的最大移动次数。", "hint": "2019 USACO 二月月赛银牌组第一题", "locale": "zh-CN"}}}
{"pid": "P5542", "type": "P", "difficulty": 3, "samples": [["3 2\n1 1 5 5\n4 4 7 6\n3 3 8 7", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "USACO", "前缀和", "差分"], "title": "[USACO19FEB] Painting The Barn S", "background": "", "description": "农夫约翰不擅长多任务处理。他经常分心，很难完成长的项目。目前，他正试图在谷仓的一侧上漆，但他一直在画小矩形区域，然后由于照料奶牛的需要而偏离了方向，使得谷仓的某些部分上漆的涂料比其他部分多。\n\n我们可以将谷仓的一侧描述为一个二维 $x-y$ 平面，农夫约翰在该平面上绘制 $n$ 个矩形，每个矩形的边都与坐标轴平行，每个矩形由谷仓的左下角和右上角点的坐标描述。\n\n农夫约翰想在谷仓上涂几层油漆，这样在不久的将来就不需要再重新粉刷了。但是，他不想浪费时间涂太多的油漆。结果表明，$K$ 涂层是最佳用量。请在他画完所有的长方形后，帮他确定谷仓有多少面积被 $K$ 层油漆覆盖。", "inputFormat": "输入的第一行包含 $n$ 和 $K$。\n\n其余 $n$ 行中的每一行包含四个整数 $x_1$、$y_1$、$x_2$、$y_2$，描述正在绘制的矩形区域，左下角 $(x_1,y_1)$ 和右上角 $(x_2,y_2)$。所有 $x$ 和 $y$ 值都在 $0$ 到 $1000$ 范围内，并且所有矩形都有正面积。", "outputFormat": "请输出谷仓被 $K$ 层油漆覆盖的区域。", "hint": "$1\\le K\\le n\\le 10^5$。\n\nUSACO 2019 二月月赛银牌组第二题。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO19FEB] Painting The Barn S", "background": "", "description": "Farmer John is not good at multitasking. He often gets distracted and has trouble finishing long projects. Right now, he is trying to paint one side of his barn, but he keeps painting small rectangular regions and then gets sidetracked to take care of the cows, causing some parts of the barn to have more layers of paint than others.\n\nWe can describe one side of the barn as a 2D $x-y$ plane. Farmer John paints $n$ rectangles on this plane. The sides of each rectangle are parallel to the coordinate axes, and each rectangle is described by the coordinates of its bottom-left corner and top-right corner.\n\nFarmer John wants to paint enough layers so that he will not need to repaint again in the near future. However, he does not want to waste time applying too much paint. It turns out that $K$ layers is the best amount. After he finishes painting all rectangles, help him determine how much area of the barn is covered by exactly $K$ layers of paint.", "inputFormat": "The first line contains $n$ and $K$.\n\nEach of the remaining $n$ lines contains four integers $x_1$, $y_1$, $x_2$, $y_2$, describing a painted rectangular region with bottom-left corner $(x_1,y_1)$ and top-right corner $(x_2,y_2)$. All $x$ and $y$ values are in the range from $0$ to $1000$, and all rectangles have positive area.", "outputFormat": "Output the area of the barn that is covered by exactly $K$ layers of paint.", "hint": "$1\\le K\\le n\\le 10^5$.\n\nThe second problem of the USACO February 2019 contest, Silver division.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO19FEB] Painting The Barn S", "background": "", "description": "农夫约翰不擅长多任务处理。他经常分心，很难完成长的项目。目前，他正试图在谷仓的一侧上漆，但他一直在画小矩形区域，然后由于照料奶牛的需要而偏离了方向，使得谷仓的某些部分上漆的涂料比其他部分多。\n\n我们可以将谷仓的一侧描述为一个二维 $x-y$ 平面，农夫约翰在该平面上绘制 $n$ 个矩形，每个矩形的边都与坐标轴平行，每个矩形由谷仓的左下角和右上角点的坐标描述。\n\n农夫约翰想在谷仓上涂几层油漆，这样在不久的将来就不需要再重新粉刷了。但是，他不想浪费时间涂太多的油漆。结果表明，$K$ 涂层是最佳用量。请在他画完所有的长方形后，帮他确定谷仓有多少面积被 $K$ 层油漆覆盖。", "inputFormat": "输入的第一行包含 $n$ 和 $K$。\n\n其余 $n$ 行中的每一行包含四个整数 $x_1$、$y_1$、$x_2$、$y_2$，描述正在绘制的矩形区域，左下角 $(x_1,y_1)$ 和右上角 $(x_2,y_2)$。所有 $x$ 和 $y$ 值都在 $0$ 到 $1000$ 范围内，并且所有矩形都有正面积。", "outputFormat": "请输出谷仓被 $K$ 层油漆覆盖的区域。", "hint": "$1\\le K\\le n\\le 10^5$。\n\nUSACO 2019 二月月赛银牌组第二题。", "locale": "zh-CN"}}}
{"pid": "P5543", "type": "P", "difficulty": 4, "samples": [["3 2\nS 1 2\nD 3 2", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["图论", "2019", "USACO", "并查集", "图遍历"], "title": "[USACO19FEB] The Great Revegetation S", "background": null, "description": "一场漫长的干旱使农场主约翰的 $N$ 个牧场没有草。然而，随着雨季的到来，是时候“重新种植”了。在农夫约翰的小屋里，他有两个桶，每个桶都有不同类型的草籽。他想在他的每一个牧场种草，在每一个牧场中选择一种类型的草。\n\n作为一名奶农，农场主约翰想确保他能满足他那几头奶牛的特殊饮食需求。他的 $m$ 头奶牛都有两个最喜欢的牧场。他的一些奶牛有一个饮食限制，那就是他们应该只吃一种类型的草，因此农场主约翰希望确保在这类奶牛最喜欢的两个田里种植同一种类型的草。其他的奶牛有一个不同的饮食限制，要求他们吃不同类型的草。对于那些奶牛，农场主约翰当然想确保他们最喜欢的两块田地里有不同的草。\n\n\n请帮助农场主约翰确定他在他的 $N$ 个牧场上种植草的不同方式的数量。", "inputFormat": "输入的第一行包含两个整数 $N$（$2\\le N\\le10^5$）和 $m$（$1\\le m\\le10^5$）。\n\n之后 $m$ 行，每行描述了一头奶牛。首先是一个字符 `S` 或 `D`，表示这头奶牛需要相同（`S`）还是不同（`D`）的草类型，然后是两个 $1\\sim N$ 的整数，表示这头奶牛喜欢的两块牧场。", "outputFormat": "输出农场主约翰在他的 $N$ 个牧场上植草的方式总数。请用二进制写你的答案。", "hint": "USACO 2019 二月月赛银牌组第三题", "locale": "zh-CN", "translations": {"en": {"title": "[USACO19FEB] The Great Revegetation S", "background": "", "description": "A long drought has left Farmer John’s $N$ pastures without grass. However, with the arrival of the rainy season, it is time to “revegetate”. In Farmer John’s barn, he has two buckets, each containing a different type of grass seed. He wants to plant grass in each of his pastures, choosing one type of grass for each pasture.\n\nAs a dairy farmer, Farmer John wants to make sure he can meet the special dietary needs of his cows. His $m$ cows each have two favorite pastures. Some cows have a dietary restriction that they should eat only one type of grass, so Farmer John wants to make sure that the same type of grass is planted in the two pastures favored by such cows. Other cows have a different dietary restriction that requires them to eat different types of grass. For those cows, Farmer John of course wants to make sure that there is different grass in their two favorite pastures.\n\nPlease help Farmer John determine the number of different ways to plant grass on his $N$ pastures.", "inputFormat": "The first line of input contains two integers $N$ ($2\\le N\\le10^5$) and $m$ ($1\\le m\\le10^5$).\n\nThe next $m$ lines each describe one cow. Each line begins with a character `S` or `D`, indicating whether this cow needs the same (`S`) or different (`D`) grass types, followed by two integers in $1\\sim N$, representing the two pastures favored by this cow.", "outputFormat": "Output the total number of ways Farmer John can plant grass on his $N$ pastures. Please write your answer in binary.", "hint": "USACO February 2019 Contest, Silver Division, Problem 3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO19FEB] The Great Revegetation S", "background": null, "description": "一场漫长的干旱使农场主约翰的 $N$ 个牧场没有草。然而，随着雨季的到来，是时候“重新种植”了。在农夫约翰的小屋里，他有两个桶，每个桶都有不同类型的草籽。他想在他的每一个牧场种草，在每一个牧场中选择一种类型的草。\n\n作为一名奶农，农场主约翰想确保他能满足他那几头奶牛的特殊饮食需求。他的 $m$ 头奶牛都有两个最喜欢的牧场。他的一些奶牛有一个饮食限制，那就是他们应该只吃一种类型的草，因此农场主约翰希望确保在这类奶牛最喜欢的两个田里种植同一种类型的草。其他的奶牛有一个不同的饮食限制，要求他们吃不同类型的草。对于那些奶牛，农场主约翰当然想确保他们最喜欢的两块田地里有不同的草。\n\n\n请帮助农场主约翰确定他在他的 $N$ 个牧场上种植草的不同方式的数量。", "inputFormat": "输入的第一行包含两个整数 $N$（$2\\le N\\le10^5$）和 $m$（$1\\le m\\le10^5$）。\n\n之后 $m$ 行，每行描述了一头奶牛。首先是一个字符 `S` 或 `D`，表示这头奶牛需要相同（`S`）还是不同（`D`）的草类型，然后是两个 $1\\sim N$ 的整数，表示这头奶牛喜欢的两块牧场。", "outputFormat": "输出农场主约翰在他的 $N$ 个牧场上植草的方式总数。请用二进制写你的答案。", "hint": "USACO 2019 二月月赛银牌组第三题", "locale": "zh-CN"}}}
{"pid": "P5544", "type": "P", "difficulty": 6, "samples": [["1 5 3\n0 0 1\n3 3\n-3 3\n3 -3\n3 0\n0 3 ", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2016", "各省省选", "江苏", "模拟退火"], "title": "[JSOI2016] 炸弹攻击1", "background": "JYY 最近迷上了一款塔防游戏，在游戏中，JYY 除了建设建筑，还可以使用炸弹对屏幕上的敌人进行范围杀伤。", "description": "游戏地图可以简单认为是一个二维平面。JYY 建造了 $N$ 个建筑，每个建筑都是一个圆，其中第 $i$ 个建筑的圆心位于 $(x_i,y_i)$ 且半径为 $r_i$。地图上一共有 $M$ 个敌人，一个敌人可以近似看成一个平面上的点，其中第 $i$ 个敌人位于$ (p_i,q_i)$。JYY 可以使用一枚可以设置半径的炸弹，可以设置一个不超过 $R$ 的范围，然后选择平面上的一个点引爆，范围内的所有敌人全部消灭。\n\n当然，由于炸弹威力巨大，如果爆炸范围接触到 JYY 的建筑，那么 JYY 的建筑也会受到损伤。（注：如果炸弹的爆炸范围仅接触到了 JYY 建筑的边界，则不会对 JYY 的建筑造成损伤；如果敌人出现在了爆炸范围的边界，则该敌人被消灭）JYY 可以自由控制炸弹的爆炸地点和爆炸半径。作为一个保守的玩家，他希望在保证自己建筑毫发无损的情况下，消灭尽量多的敌人。", "inputFormat": "第一行包含三个非负整数，分别为 $N,M,R$；\n\n接下来 $N$ 行，每行三个整数，其中第 $i$ 行为 $x_i,y_i,r_i$，表示第 $i$ 个建筑的位置和半径。数据保证所有建筑不相交（但是有可能边界接触）；\n\n接下来 $M$ 行，每行两个整数，其中第 $i$ 行为 $p_i,q_i$，表示第 $i$ 个敌人的位置。", "outputFormat": "输出一行一个整数，表示 JYY 最多可以消灭的敌人数量。", "hint": "- 对于 $20\\%$ 的数据，满足 $M = 2$；\n- 对于另外 $20\\%$ 的数据，满足 $N = 0$；\n- 对于另外 $20\\%$ 的数据，满足 $M \\leq 50$；\n- 对于 $100\\%$ 的数据，满足：\n  - $0 \\leq N \\leq 10$；\n  - $0 < M \\leq 10^3$；\n  - $1 \\leq R, r_i \\leq 2 \\times 10^4$；\n  - $|p_i|, |q_i|, |x_i|, |y_i| \\leq 2 \\times 10^4$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2016] Bomb Attack 1", "background": "JYY has recently become obsessed with a tower defense game. In the game, besides building structures, JYY can also use bombs to deal area damage to enemies on the screen.", "description": "The game map can be simply regarded as a two-dimensional plane. JYY has built $N$ buildings, and each building is a circle. The center of the $i$-th building is at $(x_i,y_i)$ with radius $r_i$. There are $M$ enemies on the map, and each enemy can be approximated as a point on the plane. The $i$-th enemy is located at $(p_i,q_i)$. JYY can use a bomb with an adjustable radius: he can set a radius not exceeding $R$, then choose a point on the plane to detonate it, and all enemies within the range are eliminated.\n\nOf course, because the bomb is very powerful, if the explosion range touches JYY's buildings, then JYY's buildings will be damaged. (Note: if the bomb's explosion range only touches the boundary of a building, it will not damage the building; if an enemy appears on the boundary of the explosion range, that enemy is eliminated.) JYY can freely control the detonation position and the explosion radius. As a cautious player, he wants to eliminate as many enemies as possible while ensuring that none of his buildings are damaged at all.", "inputFormat": "The first line contains three non-negative integers: $N, M, R$.\n\nThe next $N$ lines each contain three integers. The $i$-th line gives $x_i,y_i,r_i$, describing the position and radius of the $i$-th building. The data guarantees that no buildings intersect (but their boundaries may touch).\n\nThe next $M$ lines each contain two integers. The $i$-th line gives $p_i,q_i$, describing the position of the $i$-th enemy.", "outputFormat": "Output one line with one integer, representing the maximum number of enemies that JYY can eliminate.", "hint": "- For $20\\%$ of the data, $M = 2$.\n- For another $20\\%$ of the data, $N = 0$.\n- For another $20\\%$ of the data, $M \\leq 50$.\n- For $100\\%$ of the data, the Constraints are:\n  - $0 \\leq N \\leq 10$.\n  - $0 < M \\leq 10^3$.\n  - $1 \\leq R, r_i \\leq 2 \\times 10^4$.\n  - $|p_i|, |q_i|, |x_i|, |y_i| \\leq 2 \\times 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2016] 炸弹攻击1", "background": "JYY 最近迷上了一款塔防游戏，在游戏中，JYY 除了建设建筑，还可以使用炸弹对屏幕上的敌人进行范围杀伤。", "description": "游戏地图可以简单认为是一个二维平面。JYY 建造了 $N$ 个建筑，每个建筑都是一个圆，其中第 $i$ 个建筑的圆心位于 $(x_i,y_i)$ 且半径为 $r_i$。地图上一共有 $M$ 个敌人，一个敌人可以近似看成一个平面上的点，其中第 $i$ 个敌人位于$ (p_i,q_i)$。JYY 可以使用一枚可以设置半径的炸弹，可以设置一个不超过 $R$ 的范围，然后选择平面上的一个点引爆，范围内的所有敌人全部消灭。\n\n当然，由于炸弹威力巨大，如果爆炸范围接触到 JYY 的建筑，那么 JYY 的建筑也会受到损伤。（注：如果炸弹的爆炸范围仅接触到了 JYY 建筑的边界，则不会对 JYY 的建筑造成损伤；如果敌人出现在了爆炸范围的边界，则该敌人被消灭）JYY 可以自由控制炸弹的爆炸地点和爆炸半径。作为一个保守的玩家，他希望在保证自己建筑毫发无损的情况下，消灭尽量多的敌人。", "inputFormat": "第一行包含三个非负整数，分别为 $N,M,R$；\n\n接下来 $N$ 行，每行三个整数，其中第 $i$ 行为 $x_i,y_i,r_i$，表示第 $i$ 个建筑的位置和半径。数据保证所有建筑不相交（但是有可能边界接触）；\n\n接下来 $M$ 行，每行两个整数，其中第 $i$ 行为 $p_i,q_i$，表示第 $i$ 个敌人的位置。", "outputFormat": "输出一行一个整数，表示 JYY 最多可以消灭的敌人数量。", "hint": "- 对于 $20\\%$ 的数据，满足 $M = 2$；\n- 对于另外 $20\\%$ 的数据，满足 $N = 0$；\n- 对于另外 $20\\%$ 的数据，满足 $M \\leq 50$；\n- 对于 $100\\%$ 的数据，满足：\n  - $0 \\leq N \\leq 10$；\n  - $0 < M \\leq 10^3$；\n  - $1 \\leq R, r_i \\leq 2 \\times 10^4$；\n  - $|p_i|, |q_i|, |x_i|, |y_i| \\leq 2 \\times 10^4$。\n", "locale": "zh-CN"}}}
{"pid": "P5545", "type": "P", "difficulty": 6, "samples": [["3\n1 12\n10 30\n30 10\n1\n10 -10\n4\n2 -11\n9 -1\n11 -1\n15 -14", "7"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["计算几何", "2016", "各省省选", "江苏"], "title": "[JSOI2016] 炸弹攻击2", "background": "还记得那款题为炸弹攻击的塔防游戏吗？这款游戏出了续作，炸弹的威力大大加强了。", "description": "游戏的地图是一个二维平面。JYY 的阵地位于 $x$ 轴下方，而所有的敌人目前都位于 $x$ 轴上方。\n\n在 JYY 的阵地中有建有 $T$ 个激光塔和 $S$ 个发射源。其中第 $i$ 个防御塔 $T_i$ 的坐标为 $(tx_i,ty_i)$，第 $i$ 个发射源 $S_i$ 的坐标为 $(sx_i,sy_i)$。\n\n地图上有 $D$ 个敌人，第 $i$ 个敌人 $D_i$ 的坐标为 $(dx_i,dy_i)$。\n\n两座激光塔可以相互连接形成能量墙。发射源朝向敌人发出的能量如果穿过了能量墙，可以得到巨大的加强而变为超级射线并瞬间消灭敌人。\n\nJYY 想知道他有多少种可以可以发出超级射线的攻击方案。\n\n具体来说，一个可以发出超级射线的攻击方案为一个由四个点组成的集合：$\\{T_i,T_j,S_k,D_l\\}$，满足$1 \\leq i < j \\leq T,1 \\leq k \\leq S,1 \\leq l \\leq D$，并且线段 $T_iT_j$ 和线段 $S_kD_l$ 相交。\n\n游戏设定保证在这 $T+D+S$ 个点中，不存在重点也不存在三点共线。", "inputFormat": "第一行包含一个正整数 $D$；\n\n接下来 $D$ 行，每行包含两个整数 $dx_i,dy_i$，表示一个敌人的坐标；\n\n第 $D+1$ 行包含一个整数 $S$；\n\n接下来 $S$ 行，每行包含两个整数 $sx_i,sy_i$，表示一个发射源的坐标；\n\n第 $D+S+1$ 行包含一个整数 $T$；\n\n接下来 $T$ 行，每行包含两个整数 $(tx_i,ty_i)$，表示一个激光塔的坐标。", "outputFormat": "输出一行一个整数，可以发出超级射线的攻击方案个数。", "hint": "对于 $20\\%$ 的数据，满足 $D,S,T \\leq 30$；\n\n对于$50\\%$ 的数据，满足 $D,S,T \\leq 150$；\n\n对于$100\\%$ 的数据，满足 $1 \\leq D,S,T \\leq 800 , dy_i>0,sy_i,ty_i<0$，所有坐标绝对值不超过 $10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2016] Bomb Attack 2", "background": "Do you still remember the tower defense game called Bomb Attack? This game now has a sequel, and the bombs are much more powerful.", "description": "The game map is a two-dimensional plane. JYY's base is below the $x$-axis, and all enemies are currently above the $x$-axis.\n\nIn JYY's base, there are $T$ laser towers and $S$ launchers. The coordinates of the $i$-th tower $T_i$ are $(tx_i,ty_i)$, and the coordinates of the $i$-th launcher $S_i$ are $(sx_i,sy_i)$.\n\nThere are $D$ enemies on the map. The coordinates of the $i$-th enemy $D_i$ are $(dx_i,dy_i)$.\n\nTwo laser towers can be connected to form an energy wall. If the energy fired from a launcher toward an enemy passes through an energy wall, it can be greatly strengthened, becoming a super ray that instantly destroys the enemy.\n\nJYY wants to know how many different attack plans can produce a super ray.\n\nSpecifically, an attack plan that can produce a super ray is a set of four points: $\\{T_i,T_j,S_k,D_l\\}$, satisfying $1 \\leq i < j \\leq T,1 \\leq k \\leq S,1 \\leq l \\leq D$, and the line segment $T_iT_j$ intersects the line segment $S_kD_l$.\n\nThe game guarantees that among these $T+D+S$ points, there are no duplicate points and no three points are collinear.", "inputFormat": "The first line contains a positive integer $D$.\n\nThe next $D$ lines each contain two integers $dx_i,dy_i$, representing the coordinates of an enemy.\n\nLine $D+1$ contains an integer $S$.\n\nThe next $S$ lines each contain two integers $sx_i,sy_i$, representing the coordinates of a launcher.\n\nLine $D+S+1$ contains an integer $T$.\n\nThe next $T$ lines each contain two integers $(tx_i,ty_i)$, representing the coordinates of a laser tower.", "outputFormat": "Output one line containing one integer: the number of attack plans that can produce a super ray.", "hint": "For $20\\%$ of the testdata, $D,S,T \\leq 30$.\n\nFor $50\\%$ of the testdata, $D,S,T \\leq 150$.\n\nFor $100\\%$ of the testdata, $1 \\leq D,S,T \\leq 800, dy_i>0,sy_i,ty_i<0$, and the absolute value of every coordinate does not exceed $10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2016] 炸弹攻击2", "background": "还记得那款题为炸弹攻击的塔防游戏吗？这款游戏出了续作，炸弹的威力大大加强了。", "description": "游戏的地图是一个二维平面。JYY 的阵地位于 $x$ 轴下方，而所有的敌人目前都位于 $x$ 轴上方。\n\n在 JYY 的阵地中有建有 $T$ 个激光塔和 $S$ 个发射源。其中第 $i$ 个防御塔 $T_i$ 的坐标为 $(tx_i,ty_i)$，第 $i$ 个发射源 $S_i$ 的坐标为 $(sx_i,sy_i)$。\n\n地图上有 $D$ 个敌人，第 $i$ 个敌人 $D_i$ 的坐标为 $(dx_i,dy_i)$。\n\n两座激光塔可以相互连接形成能量墙。发射源朝向敌人发出的能量如果穿过了能量墙，可以得到巨大的加强而变为超级射线并瞬间消灭敌人。\n\nJYY 想知道他有多少种可以可以发出超级射线的攻击方案。\n\n具体来说，一个可以发出超级射线的攻击方案为一个由四个点组成的集合：$\\{T_i,T_j,S_k,D_l\\}$，满足$1 \\leq i < j \\leq T,1 \\leq k \\leq S,1 \\leq l \\leq D$，并且线段 $T_iT_j$ 和线段 $S_kD_l$ 相交。\n\n游戏设定保证在这 $T+D+S$ 个点中，不存在重点也不存在三点共线。", "inputFormat": "第一行包含一个正整数 $D$；\n\n接下来 $D$ 行，每行包含两个整数 $dx_i,dy_i$，表示一个敌人的坐标；\n\n第 $D+1$ 行包含一个整数 $S$；\n\n接下来 $S$ 行，每行包含两个整数 $sx_i,sy_i$，表示一个发射源的坐标；\n\n第 $D+S+1$ 行包含一个整数 $T$；\n\n接下来 $T$ 行，每行包含两个整数 $(tx_i,ty_i)$，表示一个激光塔的坐标。", "outputFormat": "输出一行一个整数，可以发出超级射线的攻击方案个数。", "hint": "对于 $20\\%$ 的数据，满足 $D,S,T \\leq 30$；\n\n对于$50\\%$ 的数据，满足 $D,S,T \\leq 150$；\n\n对于$100\\%$ 的数据，满足 $1 \\leq D,S,T \\leq 800 , dy_i>0,sy_i,ty_i<0$，所有坐标绝对值不超过 $10^9$。", "locale": "zh-CN"}}}
{"pid": "P5546", "type": "P", "difficulty": 4, "samples": [["3\nabcb\nbca\nacbc", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2000", "二分", "POI（波兰）", "哈希 hashing", "字典树 Trie", "后缀数组 SA"], "title": "[POI 2000] 公共串", "background": null, "description": "给出几个由小写字母构成的单词，求它们最长的公共子串的长度。", "inputFormat": "文件的第一行是整数 $n$，$1\\le n \\le 5$，表示单词的数量。接下来 $n$ 行每行一个单词，只由小写字母组成，单词的长度至少为 $1$，最大为 $2000$。", "outputFormat": "仅一行，一个整数，最长公共子串的长度。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[POI 2000] Common Substring", "background": "", "description": "Given several words consisting of lowercase letters, find the length of their longest common substring.", "inputFormat": "The first line of the file is an integer $n$, $1\\le n \\le 5$, which represents the number of words. The next $n$ lines each contain one word, consisting only of lowercase letters. The length of each word is at least $1$ and at most $2000$.", "outputFormat": "Only one line containing one integer: the length of the longest common substring.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2000] 公共串", "background": null, "description": "给出几个由小写字母构成的单词，求它们最长的公共子串的长度。", "inputFormat": "文件的第一行是整数 $n$，$1\\le n \\le 5$，表示单词的数量。接下来 $n$ 行每行一个单词，只由小写字母组成，单词的长度至少为 $1$，最大为 $2000$。", "outputFormat": "仅一行，一个整数，最长公共子串的长度。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P5547", "type": "P", "difficulty": 6, "samples": [["2 998244353", "5"], ["3 998244353", "15"], ["20 998244353", "578067492"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "数学", "北京", "O2优化", "组合数学"], "title": "[BJ United Round #3] 三色树", "background": "", "description": "请你对满足以下要求的 $n$ 个节点的 **无标号无根树** 计数： \n \n- 每个节点是三种颜色之一：红，蓝，黄\n- 红色节点度数不超过 $4$，蓝色和黄色节点度数均不超过 $3$  \n- 黄色节点不能相邻\n\n注意 **无标号无根树** 的意义是：如果两颗树可以通过重新编号的方法使得对应点颜色相同，对应连边一致，则认为是同一颗树。\n\n答案对输入的质数 $p$ 取模。", "inputFormat": "两个正整数 $n,p$，意义如题面所示。", "outputFormat": "一个整数，表示方案数对 $p$ 取模的结果。", "hint": "\n\n对于 $100\\%$ 的数据，保证：  \n$1\\le n \\le 3000$  \n$9\\times 10^8 \\le p \\le 1.01 \\times 10^9$   \n保证 $p$ 为质数\n\nBy：EntropyIncreaser", "locale": "zh-CN", "translations": {"en": {"title": "[BJ United Round #3] Three-Color Tree", "background": "", "description": "Please count the number of **unlabeled unrooted trees** with $n$ nodes that satisfy the following requirements:\n\n- Each node has one of three colors: red, blue, or yellow.\n- The degree of a red node is at most $4$, and the degrees of blue and yellow nodes are both at most $3$.\n- Yellow nodes cannot be adjacent.\n\nNote that the meaning of an **unlabeled unrooted tree** is: if two trees can be made identical by renumbering the nodes so that the corresponding nodes have the same colors and the corresponding edges match, then they are considered the same tree.\n\nThe answer should be taken modulo the prime number $p$ given in the input.", "inputFormat": "Two positive integers $n,p$, with the meanings as described above.", "outputFormat": "One integer, representing the number of valid trees modulo $p$.", "hint": "For $100\\%$ of the testdata, it is guaranteed that:\n$1\\le n \\le 3000$.\n$9\\times 10^8 \\le p \\le 1.01 \\times 10^9$.\nIt is guaranteed that $p$ is prime.\n\nBy: EntropyIncreaser\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJ United Round #3] 三色树", "background": "", "description": "请你对满足以下要求的 $n$ 个节点的 **无标号无根树** 计数： \n \n- 每个节点是三种颜色之一：红，蓝，黄\n- 红色节点度数不超过 $4$，蓝色和黄色节点度数均不超过 $3$  \n- 黄色节点不能相邻\n\n注意 **无标号无根树** 的意义是：如果两颗树可以通过重新编号的方法使得对应点颜色相同，对应连边一致，则认为是同一颗树。\n\n答案对输入的质数 $p$ 取模。", "inputFormat": "两个正整数 $n,p$，意义如题面所示。", "outputFormat": "一个整数，表示方案数对 $p$ 取模的结果。", "hint": "\n\n对于 $100\\%$ 的数据，保证：  \n$1\\le n \\le 3000$  \n$9\\times 10^8 \\le p \\le 1.01 \\times 10^9$   \n保证 $p$ 为质数\n\nBy：EntropyIncreaser", "locale": "zh-CN"}}}
{"pid": "P5548", "type": "P", "difficulty": 7, "samples": [["2 2 2", "8"], ["2 3 4", "213"], ["2 4 6", "5548"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "北京", "组合数学", "生成函数"], "title": "[BJ United Round #3] 押韵", "background": "韵要怎么押？棋要怎么下？敌要怎么杀？旗要怎么插？", "description": "现在你想要写一首歌词，一共有 $nd$ 个字，你一共设计了 $k$ 种韵脚，每个字恰好要符合一种韵脚。  \n\n并且只有当每种韵脚在歌词中出现的字数恰为 $d$ 的倍数时，这首歌才好听。\n\n试问一共有多少种韵脚的搭配方法，使得歌词好听？\n\n你只需要回答方案数对于 $1049874433$ 取模的结果即可。", "inputFormat": "一行三个整数 $n,k,d$，如题意所示。", "outputFormat": "一行一个整数，表示答案。", "hint": "对于 $100\\%$ 的数据，保证：  \n$0 \\le n \\le 10^9$  \n$1\\le k \\le 2000$  \n$d\\in \\{ 1,2,3,4,6 \\}$\n\nBy：EntropyIncreaser", "locale": "zh-CN", "translations": {"en": {"title": "[BJ United Round #3] Rhyming.", "background": "How do you rhyme? How do you play chess? How do you kill enemies? How do you plant the flag?", "description": "Now you want to write a song lyric with a total of $nd$ characters. You have designed $k$ types of rhyme endings, and each character must fit exactly one type of rhyme ending.\n\nAlso, the song sounds good only if, for every rhyme ending type, the number of characters in the lyric that use this rhyme ending is exactly a multiple of $d$.\n\nHow many ways are there to assign rhyme endings so that the song sounds good?\n\nYou only need to output the number of ways modulo $1049874433$.", "inputFormat": "One line with three integers $n,k,d$, as described.", "outputFormat": "One line with one integer, the answer.", "hint": "For $100\\%$ of the testdata, it is guaranteed that:  \n$0 \\le n \\le 10^9$  \n$1 \\le k \\le 2000$  \n$d \\in \\{ 1,2,3,4,6 \\}$\n\nBy: EntropyIncreaser\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJ United Round #3] 押韵", "background": "韵要怎么押？棋要怎么下？敌要怎么杀？旗要怎么插？", "description": "现在你想要写一首歌词，一共有 $nd$ 个字，你一共设计了 $k$ 种韵脚，每个字恰好要符合一种韵脚。  \n\n并且只有当每种韵脚在歌词中出现的字数恰为 $d$ 的倍数时，这首歌才好听。\n\n试问一共有多少种韵脚的搭配方法，使得歌词好听？\n\n你只需要回答方案数对于 $1049874433$ 取模的结果即可。", "inputFormat": "一行三个整数 $n,k,d$，如题意所示。", "outputFormat": "一行一个整数，表示答案。", "hint": "对于 $100\\%$ 的数据，保证：  \n$0 \\le n \\le 10^9$  \n$1\\le k \\le 2000$  \n$d\\in \\{ 1,2,3,4,6 \\}$\n\nBy：EntropyIncreaser", "locale": "zh-CN"}}}
{"pid": "P5549", "type": "P", "difficulty": 6, "samples": [["4 3\n0 0\n1 1\n2 3\n3 3", "1.41421356"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "二分", "北京", "Special Judge", "随机化"], "title": "[BJ United Round #3] 观察星象", "background": "", "description": "EI 在用望远镜观察星星，星空中共有  $n$ 个星星，每个星星观察起来有一个二维直角坐标 $(x,y)$。  \n\n他的望远镜如果定位在 $(x_0,y_0)$ 处，可以看到所有 $(x_0-x)^2 + (y_0-y)^2 \\le r^2$ 的星星。  \n\n望远镜的大小 $r$ 是可以调整的，EI 想知道如果他要至少看到 $m$ 个星星，至少需要把 $r$ 设置到多大？", "inputFormat": "第一行两个正整数 $n,m$，表示星星的数量和要求看到的星星数量。  \n接下来 $n$ 行，每行两个整数 $x,y$，表示一个星星的坐标。  \n保证星星坐标两两不同。", "outputFormat": "输出一行一个正实数，表示望远镜的最小半径。  \n令你的答案为 $a$，标准答案为 $b$，若 $\\frac{|a-b|}{\\max(1,b)} \\le 10^{-6}$  \n( 即绝对误差或者相对误差不超过 $10^{-6}$ ) 即为正确。", "hint": "| 子任务编号 | $n$ | $m$ | 分值 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $\\leq 50$ | $\\leq n$ | $10$ |\n| $2$ | $\\leq 200$ | $\\leq n$ | $15$ |\n| $3$ | $\\leq 700$ | $\\leq n$ | $15$ |\n| $4$ | $\\leq 2000$ | $= n$ | $20$ |\n| $5$ | $\\leq 2000$ | $\\leq n$ | $40$ |\n\n\n对于 $100\\%$ 的数据，保证：  \n$2 \\le m \\le n  \\le 2000$  \n$|x|,|y| \\le 10^4$\n\nBy：EntropyIncreaser", "locale": "zh-CN", "translations": {"en": {"title": "[BJ United Round #3] Observing the Stars", "background": "", "description": "EI is using a telescope to observe stars. There are $n$ stars in the sky, and each star has a 2D Cartesian coordinate $(x,y)$.\n\nIf the telescope is positioned at $(x_0,y_0)$, it can see all stars satisfying $(x_0-x)^2 + (y_0-y)^2 \\le r^2$.\n\nThe telescope size $r$ can be adjusted. EI wants to know: if he wants to see at least $m$ stars, what is the minimum value to set $r$ to?", "inputFormat": "The first line contains two positive integers $n,m$, representing the number of stars and the required number of stars to be seen.\n\nThe next $n$ lines each contain two integers $x,y$, representing the coordinate of one star.\n\nIt is guaranteed that all star coordinates are pairwise distinct.", "outputFormat": "Output one line containing one positive real number, representing the minimum radius of the telescope.\n\nLet your answer be $a$ and the standard answer be $b$. If $\\frac{|a-b|}{\\max(1,b)} \\le 10^{-6}$ (i.e., the absolute error or relative error does not exceed $10^{-6}$), then your answer is accepted.", "hint": "| Subtask ID | $n$ | $m$ | Score |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $\\leq 50$ | $\\leq n$ | $10$ |\n| $2$ | $\\leq 200$ | $\\leq n$ | $15$ |\n| $3$ | $\\leq 700$ | $\\leq n$ | $15$ |\n| $4$ | $\\leq 2000$ | $= n$ | $20$ |\n| $5$ | $\\leq 2000$ | $\\leq n$ | $40$ |\n\nFor $100\\%$ of the testdata, it is guaranteed that:\n\n$2 \\le m \\le n \\le 2000$.\n\n$|x|,|y| \\le 10^4$.\n\nBy: EntropyIncreaser.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJ United Round #3] 观察星象", "background": "", "description": "EI 在用望远镜观察星星，星空中共有  $n$ 个星星，每个星星观察起来有一个二维直角坐标 $(x,y)$。  \n\n他的望远镜如果定位在 $(x_0,y_0)$ 处，可以看到所有 $(x_0-x)^2 + (y_0-y)^2 \\le r^2$ 的星星。  \n\n望远镜的大小 $r$ 是可以调整的，EI 想知道如果他要至少看到 $m$ 个星星，至少需要把 $r$ 设置到多大？", "inputFormat": "第一行两个正整数 $n,m$，表示星星的数量和要求看到的星星数量。  \n接下来 $n$ 行，每行两个整数 $x,y$，表示一个星星的坐标。  \n保证星星坐标两两不同。", "outputFormat": "输出一行一个正实数，表示望远镜的最小半径。  \n令你的答案为 $a$，标准答案为 $b$，若 $\\frac{|a-b|}{\\max(1,b)} \\le 10^{-6}$  \n( 即绝对误差或者相对误差不超过 $10^{-6}$ ) 即为正确。", "hint": "| 子任务编号 | $n$ | $m$ | 分值 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $\\leq 50$ | $\\leq n$ | $10$ |\n| $2$ | $\\leq 200$ | $\\leq n$ | $15$ |\n| $3$ | $\\leq 700$ | $\\leq n$ | $15$ |\n| $4$ | $\\leq 2000$ | $= n$ | $20$ |\n| $5$ | $\\leq 2000$ | $\\leq n$ | $40$ |\n\n\n对于 $100\\%$ 的数据，保证：  \n$2 \\le m \\le n  \\le 2000$  \n$|x|,|y| \\le 10^4$\n\nBy：EntropyIncreaser", "locale": "zh-CN"}}}
{"pid": "P5550", "type": "P", "difficulty": 4, "samples": [["4 1 2 3\n1 2 3 4", "1 2 3 4"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["矩阵乘法"], "title": "Chino的数列", "background": "没有背景\n\n我写不出来了qwq", "description": "Chino给定了 $n$ 个数 $a_1...a_n$，给定常数 $s,m$ ，她会轮流对这 $n$ 个数做 $k$ 组操作，每组操作包含以下几步：\n\n1. $\\operatorname{swap}(a_s,a_m)$（交换 $a_s,a_m$）。\n\n2. 将 $n$ 个数都向前平移一位（第 $1$ 个移动到第 $n$ 个位置上）。\n\nChino 想知道，$k$ 组操作后，这 $n$ 个数分别是多少？\n \nOrz yky,dyh,wjk,jjy,cxr,gsy,cpy,zcy,tyz,yy,hz,zhr,ygg", "inputFormat": "第一行，四个数，$n,s,m,k$。\n\n接下来一行 $n$ 个数，分别代表 $a_1,a_2...a_n$。", "outputFormat": "输出一行，$n$ 个数，分别代表 $a_1,a_2...a_n$。", "hint": "对于 $40\\%$ 的数据，$1 \\leq k \\leq 10^7$\n\n对于 $100\\% $的数据，$1 \\leq n \\leq 80$，$1 \\leq s,m\\leq n$，$1 \\leq k \\leq 10^{18}$\n\n所有数字均在 `long long` 以内", "locale": "zh-CN", "translations": {"en": {"title": "Chino’s Sequence.", "background": "None.\n\nI can’t write it anymore qwq.", "description": "Chino is given $n$ numbers $a_1...a_n$, and two constants $s, m$. She will repeatedly perform $k$ rounds of operations on these $n$ numbers. Each round includes the following steps:\n\n1. $\\operatorname{swap}(a_s,a_m)$ (swap $a_s$ and $a_m$).\n\n2. Shift all $n$ numbers forward by one position (the 1st number moves to the $n$-th position).\n\nChino wants to know what these $n$ numbers are after $k$ rounds of operations.\n\nOrz yky,dyh,wjk,jjy,cxr,gsy,cpy,zcy,tyz,yy,hz,zhr,ygg.", "inputFormat": "The first line contains four numbers: $n, s, m, k$.\n\nThe next line contains $n$ numbers, representing $a_1, a_2...a_n$.", "outputFormat": "Output one line with $n$ numbers, representing $a_1, a_2...a_n$.", "hint": "For $40\\%$ of the testdata, $1 \\leq k \\leq 10^7$.\n\nFor $100\\%$ of the testdata, $1 \\leq n \\leq 80$, $1 \\leq s, m \\leq n$, $1 \\leq k \\leq 10^{18}$.\n\nAll numbers fit in `long long`.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Chino的数列", "background": "没有背景\n\n我写不出来了qwq", "description": "Chino给定了 $n$ 个数 $a_1...a_n$，给定常数 $s,m$ ，她会轮流对这 $n$ 个数做 $k$ 组操作，每组操作包含以下几步：\n\n1. $\\operatorname{swap}(a_s,a_m)$（交换 $a_s,a_m$）。\n\n2. 将 $n$ 个数都向前平移一位（第 $1$ 个移动到第 $n$ 个位置上）。\n\nChino 想知道，$k$ 组操作后，这 $n$ 个数分别是多少？\n \nOrz yky,dyh,wjk,jjy,cxr,gsy,cpy,zcy,tyz,yy,hz,zhr,ygg", "inputFormat": "第一行，四个数，$n,s,m,k$。\n\n接下来一行 $n$ 个数，分别代表 $a_1,a_2...a_n$。", "outputFormat": "输出一行，$n$ 个数，分别代表 $a_1,a_2...a_n$。", "hint": "对于 $40\\%$ 的数据，$1 \\leq k \\leq 10^7$\n\n对于 $100\\% $的数据，$1 \\leq n \\leq 80$，$1 \\leq s,m\\leq n$，$1 \\leq k \\leq 10^{18}$\n\n所有数字均在 `long long` 以内", "locale": "zh-CN"}}}
