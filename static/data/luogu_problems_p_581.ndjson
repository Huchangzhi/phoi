{"pid": "P12792", "type": "P", "difficulty": 7, "samples": [["6 1\n8 1 2 3 1 4 5 6 4\n10 2\n9 1 2 3 1 10 4 5 6 4\n5 7 8 9 7 10\n0 0", "Yes\nNo"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "ICPC", "NERC/NEERC"], "title": "[NERC 2022] Cactus Meets Torus", "background": "", "description": "Alice has a nice cactus graph that she wanted to place on a sheet of paper. Eve threatens to take one cycle of this cactus and cut the paper along all edges on this cycle. This way, the sheet of paper will be divided in two parts, and Alice will be upset. Luckily, Barbara just gave Alice a paper torus --- a sheet of paper where top and bottom edges are connected as well as left and right edges are connected without twisting. On torus, you can sometimes cut paper along all edges on a cycle, but it would still remain in one piece. Help Alice to determine if she can place her cactus on a torus such that Eve cannot cut paper along one cycle dividing the torus into two unconnected pieces.\n\n$\\textit{Cactus}$ is a connected undirected graph in which every edge lies on at most one simple cycle. Intuitively, cactus is a generalization of a tree where some cycles are allowed. Multiedges (multiple edges between a pair of vertices) and loops (edges that connect a vertex to itself) are not allowed in a cactus.\n\nWe say that a graph is placed on a sheet of paper if each vertex is a point on this sheet, each edge is a segment between points corresponding to its vertices, and these segments only intersect at their ends. On torus segments can go through sheet edges any number of times.", "inputFormat": "The input consists of one or more independent test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ \n($1 \\le n \\le 10^5$; $0 \\le m \\le 10^5$), where $n$ is the number of vertices in the graph. Vertices are numbered from $1$ to $n$. The edges of the graph are represented by a set of edge-distinct paths, where $m$ is the number of such paths. \n\nEach of the following $m$ lines contains a path in the graph. A path starts\nwith an integer $s_i$ ($2 \\le s_i \\le 1000$) followed by $s_i$ integers\nfrom $1$ to $n$. These $s_i$ integers represent vertices of a path. Adjacent vertices in a path are distinct. The path can go through the same vertex multiple times, but every edge is traversed exactly once in the whole test case. There are no multiedges in the graph (there is at most one edge between any two vertices).\n\nThe last line of the input after all test cases contains two zeros. It does $\\textbf{not}$ define a test case. It just marks the end of the input and does not require any output.\n\nAll graphs in the input are cacti. The total sum of all values of $n$ and\nthe total sum of all values of $m$ throughout the input both do not exceed $10^5$.", "outputFormat": "Print the answer for each test case in the same order the cases appear in the input. For each test case, print a single line with ``Yes`` if you can place this cactus on a torus or print ``No`` otherwise.", "hint": "One way to place the cactus from the first case on a torus is shown on the picture.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dvhu6d05.png)", "locale": "en", "translations": {"en": {"title": "[NERC 2022] Cactus Meets Torus", "background": "", "description": "Alice has a nice cactus graph that she wanted to place on a sheet of paper. Eve threatens to take one cycle of this cactus and cut the paper along all edges on this cycle. This way, the sheet of paper will be divided in two parts, and Alice will be upset. Luckily, Barbara just gave Alice a paper torus --- a sheet of paper where top and bottom edges are connected as well as left and right edges are connected without twisting. On torus, you can sometimes cut paper along all edges on a cycle, but it would still remain in one piece. Help Alice to determine if she can place her cactus on a torus such that Eve cannot cut paper along one cycle dividing the torus into two unconnected pieces.\n\n$\\textit{Cactus}$ is a connected undirected graph in which every edge lies on at most one simple cycle. Intuitively, cactus is a generalization of a tree where some cycles are allowed. Multiedges (multiple edges between a pair of vertices) and loops (edges that connect a vertex to itself) are not allowed in a cactus.\n\nWe say that a graph is placed on a sheet of paper if each vertex is a point on this sheet, each edge is a segment between points corresponding to its vertices, and these segments only intersect at their ends. On torus segments can go through sheet edges any number of times.", "inputFormat": "The input consists of one or more independent test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ \n($1 \\le n \\le 10^5$; $0 \\le m \\le 10^5$), where $n$ is the number of vertices in the graph. Vertices are numbered from $1$ to $n$. The edges of the graph are represented by a set of edge-distinct paths, where $m$ is the number of such paths. \n\nEach of the following $m$ lines contains a path in the graph. A path starts\nwith an integer $s_i$ ($2 \\le s_i \\le 1000$) followed by $s_i$ integers\nfrom $1$ to $n$. These $s_i$ integers represent vertices of a path. Adjacent vertices in a path are distinct. The path can go through the same vertex multiple times, but every edge is traversed exactly once in the whole test case. There are no multiedges in the graph (there is at most one edge between any two vertices).\n\nThe last line of the input after all test cases contains two zeros. It does $\\textbf{not}$ define a test case. It just marks the end of the input and does not require any output.\n\nAll graphs in the input are cacti. The total sum of all values of $n$ and\nthe total sum of all values of $m$ throughout the input both do not exceed $10^5$.", "outputFormat": "Print the answer for each test case in the same order the cases appear in the input. For each test case, print a single line with ``Yes`` if you can place this cactus on a torus or print ``No`` otherwise.", "hint": "One way to place the cactus from the first case on a torus is shown on the picture.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dvhu6d05.png)", "locale": "en"}, "zh-CN": {"title": "[NERC 2022] Cactus Meets Torus", "background": "", "description": "Alice 有一个漂亮的仙人掌图，她想把它画在一张纸上。Eve 威胁说要拿走这个仙人掌图的一个环，并沿着这个环上的所有边把纸剪开。这样一来，这张纸就会被分成两部分，Alice 会因此而难过。幸运的是，Barbara 刚刚给了 Alice 一个纸质环面——一张将顶边和底边、左边和右边分别连接起来且没有扭曲的纸。在环面上，有时你可以沿着一个环的所有边剪开纸，但它仍然会保持为一整块。请帮助 Alice 判断她是否能将她的仙人掌图画在一个环面上，使得 Eve 无法沿着任何一个环剪开纸并把环面分成两个不相连的部分。\n\n仙人掌图 (Cactus) 是一个连通的无向图，其中每条边最多只属于一个简单环。直观地说，仙人掌图是树的一种推广，允许存在一些环。仙人掌图中不允许存在重边（一对顶点之间的多条边）和自环（连接一个顶点到其自身的边）。\n\n我们说一个图被画在一张纸上，如果每个顶点是这张纸上的一个点，每条边是其对应顶点之间的线段，并且这些线段只在它们的端点处相交。在环面上，线段可以穿过纸的边界任意次数。", "inputFormat": "输入包含一个或多个独立的测试用例。\n\n每个测试用例的第一行包含两个整数 $n$ 和 $m$ ($1 \\le n \\le 10^5$; $0 \\le m \\le 10^5$)，其中 $n$ 是图中顶点的数量。顶点编号从 $1$ 到 $n$。图的边由一组边不重复的路径表示，其中 $m$ 是这些路径的数量。\n\n接下来的 $m$ 行，每行描述了图中的一条路径。一条路径以一个整数 $s_i$ ($2 \\le s_i \\le 1000$) 开始，后面跟着 $s_i$ 个从 $1$ 到 $n$ 的整数。这 $s_i$ 个整数表示路径上的顶点。路径中相邻的顶点是不同的。路径可以多次经过同一个顶点，但在整个测试用例中，每条边都恰好被遍历一次。图中没有重边（任意两个顶点之间最多只有一条边）。\n\n所有测试用例结束后的最后一行包含两个零。它**不**定义一个测试用例，仅仅是标记输入的结束，不需要任何输出。\n\n输入中的所有图都是仙人掌图。在整个输入中，所有 $n$ 的值的总和以及所有 $m$ 的值的总和均不超过 $10^5$。", "outputFormat": "对于每个测试用例，按照它们在输入中出现的顺序输出答案。对于每个测试用例，如果可以将这个仙人掌图画在环面上，则在单行中输出 ``Yes``，否则输出 ``No``。\n", "hint": "将第一个样例中的仙人掌图画在环面上的一种方式如图片所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dvhu6d05.png)\n\n翻译由 gemini2.5pro 完成", "locale": "zh-CN"}}}
{"pid": "P12793", "type": "P", "difficulty": 6, "samples": [["3 6\n...#..\n......\n#...##", "52"], ["2 2\n..\n..", "2"], ["2 2\n#.\n#.", "0"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "二分图", "ICPC", "NERC/NEERC"], "title": "[NERC 2022] Dominoes", "background": "", "description": "Dora likes to play with dominoes. She takes $n \\times m$ table, marks some cells as occupied, and then tries to fill all unoccupied cells with $2 \\times 1$ dominoes.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/izci2rsk.png)\n\nHer little brother Dani loves to play pranks on his older sister. So when she is away, he marks two more unoccupied cells as occupied. He wants to do it in such a way that it will be impossible to fill all unoccupied cells with dominoes.\n\nHelp Dani to count the number of ways he can select these two cells. Since Dani can only count to one million, if this number of ways is $x$, output $\\min(x, 10^6)$.", "inputFormat": "The first line contains integers $n$ and $m$ ($1\\le n, m\\le 1000$). Next $n$ lines contain $m$ characters each --- the initial state of the table. Character $\\tt{\\#}$ corresponds to an occupied cell, and character $\\tt{.}$ corresponds to an unoccupied cell. It is guaranteed that there are at least two unoccupied cells, and that it is possible to fill all unoccupied cells with dominoes.", "outputFormat": "Let $x$ be the number of ways Dani can mark two cells in such a way that it will be impossible to fill all unoccupied cells with dominoes. \n\nPrint one integer $\\min(x, 10^6)$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2022] Dominoes", "background": "", "description": "Dora likes to play with dominoes. She takes $n \\times m$ table, marks some cells as occupied, and then tries to fill all unoccupied cells with $2 \\times 1$ dominoes.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/izci2rsk.png)\n\nHer little brother Dani loves to play pranks on his older sister. So when she is away, he marks two more unoccupied cells as occupied. He wants to do it in such a way that it will be impossible to fill all unoccupied cells with dominoes.\n\nHelp Dani to count the number of ways he can select these two cells. Since Dani can only count to one million, if this number of ways is $x$, output $\\min(x, 10^6)$.", "inputFormat": "The first line contains integers $n$ and $m$ ($1\\le n, m\\le 1000$). Next $n$ lines contain $m$ characters each --- the initial state of the table. Character $\\tt{\\#}$ corresponds to an occupied cell, and character $\\tt{.}$ corresponds to an unoccupied cell. It is guaranteed that there are at least two unoccupied cells, and that it is possible to fill all unoccupied cells with dominoes.", "outputFormat": "Let $x$ be the number of ways Dani can mark two cells in such a way that it will be impossible to fill all unoccupied cells with dominoes. \n\nPrint one integer $\\min(x, 10^6)$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2022] Dominoes", "background": "", "description": "Dora 喜欢玩多米诺骨牌。她拿来一个 $n \\times m$ 的棋盘，将一些单元格标记为已占据，然后尝试用 $2 \\times 1$ 的多米诺骨牌填满所有未被占据的单元格。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/izci2rsk.png)\n\n她的弟弟 Dani 喜欢对他姐姐搞恶作剧。所以当她不在的时候，他又将两个未被占据的单元格标记为已占据。他想通过这种方式，使得无法再用多米诺骨牌填满所有未被占据的单元格。\n\n请帮助 Dani 计算他有多少种选择这两个单元格的方法。由于 Dani 最多数到一百万，如果方法数是 $x$，请输出 $\\min(x, 10^6)$。", "inputFormat": "第一行包含整数 $n$ 和 $m$ ($1\\le n, m\\le 1000$)。接下来的 $n$ 行每行包含 $m$ 个字符——表示棋盘的初始状态。字符 $\\tt{\\#}$ 对应已占据的单元格，字符 $\\tt{.}$ 对应未被占据的单元格。保证至少有两个未被占据的单元格，并且初始时可以用多米诺骨牌填满所有未被占据的单元格。", "outputFormat": "令 $x$ 为 Dani 标记两个单元格后，导致无法用多米诺骨牌填满所有未被占据的单元格的方法数。\n\n输出一个整数 $\\min(x, 10^6)$。", "hint": "翻译由 gemini2.5pro 完成", "locale": "zh-CN"}}}
{"pid": "P12794", "type": "P", "difficulty": 3, "samples": [["2\n3 3 5 8\n2 9 2", "1 2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "ICPC", "NERC/NEERC"], "title": "[NERC 2022] Easy Assembly", "background": "", "description": "Emma loves playing with blocks. She has several cubic blocks of the same size that are numbered with $\\textbf{distinct}$ integers written on them. She assembles towers from those blocks by stacking them vertically. \n\nA configuration of her game is a set of towers that she has assembled from the blocks. Emma can perform two kinds of operations on a configuration of towers:\n\n- $\\textbf{Split}$ any tower with more than one block in it by taking any number of blocks from the top of the tower and moving them to a new tower keeping their order, so that the top block of the old tower becomes the top block of the new tower. As a result of this operation, the number of towers increases by one.\n\n- $\\textbf{Combine}$ any two towers by moving blocks from one tower on top of the other tower in the same order. As a result of this operation, the number of towers decreases by one.\n\nEmma wants to stack all the blocks into a single tower so that all blocks come in order sorted by the numbers --- from the block with the minimal number at the top to the block with the maximal number at the bottom. Emma wants to do as little of splitting and combining operations as possible. Your task is to find the minimal number of operations she has to make and output how many splits and combines are needed.\n ", "inputFormat": "The first line of the input file contains an integer $n$ ($1 \\le n \\le 10\\,000$) --- the number of towers in the initial configuration. Next $n$ lines describe towers. Each tower $i$ is described by a line that starts with the number $k_i$ ($k_i \\ge 1$; $\\sum_1^n{k_i} \\le 10\\,000$) --- the number of blocks in the tower, followed by $k_i$ numbers $b_{i,j}$ ($1 \\le b_{i,j} \\le 10^9$) --- numbers written on the blocks in the $i$-th tower, listed from top to bottom. All block numbers listed in the input are different. ", "outputFormat": "Output a line with two integers $s$ and $c$ --- the number of split and combine operations Emma should make to get a single tower with blocks sorted by their numbers, so that the total number of operations is minimized.", "hint": "The example needs the following operations (1 split and 2 combines).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vcr3xth0.png)", "locale": "en", "translations": {"en": {"title": "[NERC 2022] Easy Assembly", "background": "", "description": "Emma loves playing with blocks. She has several cubic blocks of the same size that are numbered with $\\textbf{distinct}$ integers written on them. She assembles towers from those blocks by stacking them vertically. \n\nA configuration of her game is a set of towers that she has assembled from the blocks. Emma can perform two kinds of operations on a configuration of towers:\n\n- $\\textbf{Split}$ any tower with more than one block in it by taking any number of blocks from the top of the tower and moving them to a new tower keeping their order, so that the top block of the old tower becomes the top block of the new tower. As a result of this operation, the number of towers increases by one.\n\n- $\\textbf{Combine}$ any two towers by moving blocks from one tower on top of the other tower in the same order. As a result of this operation, the number of towers decreases by one.\n\nEmma wants to stack all the blocks into a single tower so that all blocks come in order sorted by the numbers --- from the block with the minimal number at the top to the block with the maximal number at the bottom. Emma wants to do as little of splitting and combining operations as possible. Your task is to find the minimal number of operations she has to make and output how many splits and combines are needed.\n ", "inputFormat": "The first line of the input file contains an integer $n$ ($1 \\le n \\le 10\\,000$) --- the number of towers in the initial configuration. Next $n$ lines describe towers. Each tower $i$ is described by a line that starts with the number $k_i$ ($k_i \\ge 1$; $\\sum_1^n{k_i} \\le 10\\,000$) --- the number of blocks in the tower, followed by $k_i$ numbers $b_{i,j}$ ($1 \\le b_{i,j} \\le 10^9$) --- numbers written on the blocks in the $i$-th tower, listed from top to bottom. All block numbers listed in the input are different. ", "outputFormat": "Output a line with two integers $s$ and $c$ --- the number of split and combine operations Emma should make to get a single tower with blocks sorted by their numbers, so that the total number of operations is minimized.", "hint": "The example needs the following operations (1 split and 2 combines).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vcr3xth0.png)", "locale": "en"}, "zh-CN": {"title": "[NERC 2022] Easy Assembly", "background": "", "description": "Emma 喜欢玩积木。她有几个大小相同的立方体积木，上面写着**不同**的整数。她通过将这些积木垂直堆叠来搭建塔。\n\n她的游戏中的一个局面是由她用积木搭建的一组塔构成的。Emma 可以对一个塔的局面执行两种操作：\n\n- **分裂**：将任意一个包含多于一个积木的塔，从顶部取下任意数量的积木，并按原顺序移动到一个新的塔中，使得旧塔的顶部积木成为新塔的顶部积木。此操作的结果是，塔的数量增加一。\n\n- **合并**：将任意两个塔，把其中一个塔的积木按原顺序移动到另一个塔的顶部。此操作的结果是，塔的数量减少一。\n\nEmma 想要将所有积木堆叠成一个单独的塔，使得所有积木按数字顺序排列——从数字最小的积木在顶部，到数字最大的积木在底部。Emma 希望进行尽可能少的分裂和合并操作。你的任务是找到她必须进行的最少操作次数，并输出需要多少次分裂和多少次合并。", "inputFormat": "输入文件的第一行包含一个整数 $n$ ($1 \\le n \\le 10\\,000$)——初始局面中塔的数量。接下来的 $n$ 行描述了这些塔。每个塔 $i$ 的描述占一行，以该塔中积木的数量 $k_i$ ($k_i \\ge 1$; $\\sum_1^n{k_i} \\le 10\\,000$) 开始，后面跟着 $k_i$ 个数字 $b_{i,j}$ ($1 \\le b_{i,j} \\le 10^9$)——表示第 $i$ 个塔中积木上写的数字，按从上到下的顺序列出。输入中列出的所有积木上的数字都是不同的。\n", "outputFormat": "输出一行，包含两个整数 $s$ 和 $c$——Emma 为了得到一个积木按数字排序的单独的塔，在总操作次数最少的情况下，应该进行的分裂和合并操作的次数。\n", "hint": "样例需要以下操作（1 次分裂和 2 次合并）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vcr3xth0.png)\n\n翻译由 gemini2.5pro 完成", "locale": "zh-CN"}}}
{"pid": "P12795", "type": "P", "difficulty": 2, "samples": [["3\n2\n4", "0\n1:0\n1:2\n0:2"], ["1\n2\n2", "1\n2:2"], ["4\n0\n7", "0\n0:1\n0:2\n0:1\n0:3"], ["6\n3\n1", "2\n0:0\n1:0\n0:0\n0:1\n1:0\n1:0"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2022] Football", "background": "", "description": "Scientists are researching an impact of football match results on the mood of football fans. They have a hypothesis that there is a correlation between the number of draws and fans' desire to watch football matches in the future.\n\nIn football, two teams play a match. The teams score goals throughout a match. A score \"$x$ $\\tt{:}$ $y$\" means that the team we observe scored $x$ goals and conceded $y$ goals. If $x = y$, then the match ends in a draw. If $x > y$, then the observed team wins, and if $x < y$, then it loses.\n\nTo find out if there is a correlation, the scientists gathered information about the results of teams in lower leagues. The information they found is the number of matches played by the team ($n$), the number of goals scored in these matches ($a$), and the number of goals conceded in these matches ($b$). \n\nYou are given this information for a single team. You are asked to calculate the minimum number of draws that could have happened during the team's matches and provide a list of match scores with the minimum number of draws.", "inputFormat": "The first line contains an integer $n$ --- the number of matches played by the team ($1 \\le n \\le 100$). The second line contains an integer $a$ --- the total number of goals scored by the team in all $n$ matches ($0 \\le a \\le 1000$). The third line contains an integer $b$ --- the total number of goals conceded by the team in all $n$ matches ($0 \\le b \\le 1000$).", "outputFormat": "In the first line, print a single integer $d$ --- the minimum number of draws.\n\nIn the following $n$ lines, print a list of match scores, each line in the format \"$x$ $\\tt{:}$ $y$\", where $x$ is the number of goals scored in the match, and $y$ -- the number of goals conceded, so that exactly $d$ of these matches have ended in a draw. In case multiple such lists of match scores exist, print any of them.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2022] Football", "background": "", "description": "Scientists are researching an impact of football match results on the mood of football fans. They have a hypothesis that there is a correlation between the number of draws and fans' desire to watch football matches in the future.\n\nIn football, two teams play a match. The teams score goals throughout a match. A score \"$x$ $\\tt{:}$ $y$\" means that the team we observe scored $x$ goals and conceded $y$ goals. If $x = y$, then the match ends in a draw. If $x > y$, then the observed team wins, and if $x < y$, then it loses.\n\nTo find out if there is a correlation, the scientists gathered information about the results of teams in lower leagues. The information they found is the number of matches played by the team ($n$), the number of goals scored in these matches ($a$), and the number of goals conceded in these matches ($b$). \n\nYou are given this information for a single team. You are asked to calculate the minimum number of draws that could have happened during the team's matches and provide a list of match scores with the minimum number of draws.", "inputFormat": "The first line contains an integer $n$ --- the number of matches played by the team ($1 \\le n \\le 100$). The second line contains an integer $a$ --- the total number of goals scored by the team in all $n$ matches ($0 \\le a \\le 1000$). The third line contains an integer $b$ --- the total number of goals conceded by the team in all $n$ matches ($0 \\le b \\le 1000$).", "outputFormat": "In the first line, print a single integer $d$ --- the minimum number of draws.\n\nIn the following $n$ lines, print a list of match scores, each line in the format \"$x$ $\\tt{:}$ $y$\", where $x$ is the number of goals scored in the match, and $y$ -- the number of goals conceded, so that exactly $d$ of these matches have ended in a draw. In case multiple such lists of match scores exist, print any of them.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2022] Football", "background": "", "description": "科学家们正在研究足球比赛结果对球迷情绪的影响。他们有一个假设，即平局的数量与球迷未来观看足球比赛的意愿之间存在关联。\n\n在足球比赛中，两支球队进行一场比赛。球队在整场比赛中进球得分。比分“$x$ $\\tt{:}$ $y$”表示我们观察的球队打进了 $x$ 个球，并丢了 $y$ 个球。如果 $x = y$，则比赛以平局结束。如果 $x > y$，则被观察的球队获胜，如果 $x < y$，则该队告负。\n\n为了找出是否存在这种关联，科学家们收集了关于低级别联赛中球队赛果的信息。他们找到的信息是该队参加的比赛场数 ($n$)、在这些比赛中的总进球数 ($a$) 以及总失球数 ($b$)。\n\n现在给你一支球队的这些信息。你需要计算该队比赛中可能发生的最小平局次数，并提供一个在该最小平局次数下所有比赛的比分列表。\n", "inputFormat": "第一行包含一个整数 $n$——该队参加的比赛场数 ($1 \\le n \\le 100$)。\n第二行包含一个整数 $a$——该队在所有 $n$ 场比赛中的总进球数 ($0 \\le a \\le 1000$)。\n第三行包含一个整数 $b$——该队在所有 $n$ 场比赛中的总失球数 ($0 \\le b \\le 1000$)。\n", "outputFormat": "在第一行，输出一个整数 $d$——最小的平局次数。\n\n在接下来的 $n$ 行中，输出一个比赛比分列表，每行格式为“$x$ $\\tt{:}$ $y$”，其中 $x$ 是该场比赛的进球数，$y$ 是失球数，并使得这些比赛中恰好有 $d$ 场以平局结束。如果存在多种这样的比分列表，输出任意一种即可。\n", "hint": "翻译由 gemini2.5pro 完成", "locale": "zh-CN"}}}
{"pid": "P12796", "type": "P", "difficulty": 6, "samples": [["1 5\n11010", "1.0000000000000000"], ["3 3\n011\n101\n110", "0.3333333333333333"], ["6 4\n1011\n0110\n1111\n0110\n0000\n1101", "0.1666666666666667"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "Special Judge", "快速沃尔什变换 FWT", "快速莫比乌斯变换 FMT", "ICPC", "状压 DP", "NERC/NEERC"], "title": "[NERC 2022] Game of Questions", "background": "", "description": "Genie is taking part in an intellectual game. The game consists of $n$ questions, and there are $m$ participants numbered from $1$ to $m$. Genie is the participant number $1$.\n\nFor each question $i$ and participant $j$, it is known whether the participant will answer the question correctly or not.\n\nThe goal of the game is to be the last participant staying in the game.\n\nThe game is conducted as follows. First, all $n$ questions get shuffled uniformly at random (all $n!$ permutations are equally likely). Then, the questions are asked one by one. Each participant answers the question. If all participants still in the game answer the question correctly, or if all of them answer the question incorrectly, nothing happens. Otherwise, those participants who answer the question incorrectly lose and leave the game.\n\nAfter all $n$ questions are asked, all participants who are still in the game are declared to be the winners.\n\nWhat is the probability that Genie will win the game?", "inputFormat": "The first line contains two integers $n$ and $m$ --- the number of questions and the number of participants ($1 \\le n \\le 2 \\cdot 10^5$; $2 \\le m \\le 17$).\n\nThe $i$-th of the next $n$ lines contains $m$ characters $s_{i, 1}, s_{i, 2}, \\ldots, s_{i, m}$. Character $s_{i, j}$ is $\\tt{1}$ if participant $j$ answers question $i$ correctly or $\\tt{0}$ otherwise.", "outputFormat": "Print the probability that Genie will win the game. Your answer will be considered correct if its absolute or relative error does not exceed $10^{-9}$.", "hint": "In the first example, there is a single question and Genie will answer it correctly, thus winning the game (along with participants $2$ and $4$).\n\nIn the second example, one participant will leave after the first asked question, and another participant will leave after the second asked question. Each participant will win with probability $\\frac{1}{3}$.", "locale": "en", "translations": {"en": {"title": "[NERC 2022] Game of Questions", "background": "", "description": "Genie is taking part in an intellectual game. The game consists of $n$ questions, and there are $m$ participants numbered from $1$ to $m$. Genie is the participant number $1$.\n\nFor each question $i$ and participant $j$, it is known whether the participant will answer the question correctly or not.\n\nThe goal of the game is to be the last participant staying in the game.\n\nThe game is conducted as follows. First, all $n$ questions get shuffled uniformly at random (all $n!$ permutations are equally likely). Then, the questions are asked one by one. Each participant answers the question. If all participants still in the game answer the question correctly, or if all of them answer the question incorrectly, nothing happens. Otherwise, those participants who answer the question incorrectly lose and leave the game.\n\nAfter all $n$ questions are asked, all participants who are still in the game are declared to be the winners.\n\nWhat is the probability that Genie will win the game?", "inputFormat": "The first line contains two integers $n$ and $m$ --- the number of questions and the number of participants ($1 \\le n \\le 2 \\cdot 10^5$; $2 \\le m \\le 17$).\n\nThe $i$-th of the next $n$ lines contains $m$ characters $s_{i, 1}, s_{i, 2}, \\ldots, s_{i, m}$. Character $s_{i, j}$ is $\\tt{1}$ if participant $j$ answers question $i$ correctly or $\\tt{0}$ otherwise.", "outputFormat": "Print the probability that Genie will win the game. Your answer will be considered correct if its absolute or relative error does not exceed $10^{-9}$.", "hint": "In the first example, there is a single question and Genie will answer it correctly, thus winning the game (along with participants $2$ and $4$).\n\nIn the second example, one participant will leave after the first asked question, and another participant will leave after the second asked question. Each participant will win with probability $\\frac{1}{3}$.", "locale": "en"}, "zh-CN": {"title": "[NERC 2022] Game of Questions", "background": "", "description": "Genie 正在参加一个智力游戏。游戏包含 $n$ 个问题，有 $m$ 名从 $1$ 到 $m$ 编号的参赛者。Genie 是 $1$ 号参赛者。\n\n对于每个问题 $i$ 和参赛者 $j$，已知该参赛者是否会正确回答该问题。\n\n游戏的目标是成为坚持到最后的参赛者之一。\n\n游戏按如下方式进行。首先，所有 $n$ 个问题会被随机均匀打乱（所有 $n!$ 种排列都是等可能的）。然后，问题会一个接一个地被提出。每位参赛者都会回答问题。如果所有仍在游戏中的参赛者都回答正确，或都回答错误，则什么也不会发生。否则，回答错误的参赛者将输掉并离开游戏。\n\n在所有 $n$ 个问题都被问完后，所有仍在游戏中的参赛者都被宣布为获胜者。\n\nGenie 赢得游戏的概率是多少？", "inputFormat": "第一行包含两个整数 $n$ 和 $m$——问题的数量和参赛者的数量 ($1 \\le n \\le 2 \\cdot 10^5$; $2 \\le m \\le 17$)。\n\n接下来的 $n$ 行中的第 $i$ 行包含 $m$ 个字符 $s_{i, 1}, s_{i, 2}, \\ldots, s_{i, m}$。如果参赛者 $j$ 正确回答了问题 $i$，则字符 $s_{i, j}$ 为 $\\tt{1}$，否则为 $\\tt{0}$。\n", "outputFormat": "输出 Genie 赢得游戏的概率。如果你的答案的绝对或相对误差不超过 $10^{-9}$，则该答案将被认为是正确的。\n", "hint": "在第一个样例中，只有一个问题，Genie 会正确回答，因此赢得比赛（与参赛者 $2$ 和 $4$ 一起）。\n\n在第二个样例中，一名参赛者将在第一个被问到的问题后离开，另一名参赛者将在第二个被问到的问题后离开。每位参赛者获胜的概率为 $\\frac{1}{3}$。\n\n翻译由 gemini2.5pro 完成", "locale": "zh-CN"}}}
{"pid": "P12797", "type": "P", "difficulty": 6, "samples": [["\nTabilmadi\n\nDaha yakin\n\nDaha yakin\n\nSama distanco\n\nDalej\n\nZnaydeno!", "500 200\n\n560 230\n\n566 240\n\n566 238\n\n30 239\n\n566 239"], ["\nYou are lucky today!", "777777 777777"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "交互题", "Special Judge", "构造", "ICPC", "NERC/NEERC"], "title": "[NERC 2022] Hot and Cold", "background": "", "description": "This is an interactive problem.\n\nAfter emigrating to another country, little Hanna came across the fact that playing \"Hot and cold\" became more difficult: she does not understand the hint phrases! You are to write a helping program for her.\n\nThe playground where the game happens is a rectangle, and the treasure is hidden in some point with integer coordinates between 0 and $10^6$, inclusive. Hanna visits several points with valid coordinates. If the visited point contains the hidden treasure, she receives the phrase \"Found!\" in the local language. Fortunately, the intonations allow her to recognize this phrase --- in this problem it will be denoted by an exclamation mark.\n\nOtherwise, for each visited point except for the first one, Hanna receives a phrase in the local language stating whether she is now \"Closer\", \"Further\", or \"At the same distance\" from the treasure, compared to the previous point. The distances are measured in Euclidean metric. After the first visited point, in case of no treasure there, Hanna receives the phrase \"Not found\" in the local language.\n\nYour program must help Hanna find the treasure by visiting $\\textbf{at most 64 points}$.\n\n### Interactive Protocol\n\nYour program should print each visited point in a line with two coordinates between 0 and $10^6$, inclusive, and flush the output after each one.\n\nFor each visited point, the testing system writes one of the phrases: \"Found!\", \"Closer\", \"Further\", \"At the same distance\", or \"Not found\" in some language, consistent throughout the game. The first phrase ends with an exclamation mark, all other phrases do not contain exclamation marks. All phrases contain only Latin letters, spaces and exclamation marks, have lengths between 2 and 30, inclusive, don't start or end with a space, and are pairwise distinct. The phrases are not necessarily coming from any real human language. \n\nAfter receiving a phrase with an exclamation mark, your program must halt without printing anything else. Visiting points more than once is allowed, and each such visit counts towards the limit of 64 queries.", "inputFormat": "See interactive protocol.", "outputFormat": "See interactive protocol.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2022] Hot and Cold", "background": "", "description": "This is an interactive problem.\n\nAfter emigrating to another country, little Hanna came across the fact that playing \"Hot and cold\" became more difficult: she does not understand the hint phrases! You are to write a helping program for her.\n\nThe playground where the game happens is a rectangle, and the treasure is hidden in some point with integer coordinates between 0 and $10^6$, inclusive. Hanna visits several points with valid coordinates. If the visited point contains the hidden treasure, she receives the phrase \"Found!\" in the local language. Fortunately, the intonations allow her to recognize this phrase --- in this problem it will be denoted by an exclamation mark.\n\nOtherwise, for each visited point except for the first one, Hanna receives a phrase in the local language stating whether she is now \"Closer\", \"Further\", or \"At the same distance\" from the treasure, compared to the previous point. The distances are measured in Euclidean metric. After the first visited point, in case of no treasure there, Hanna receives the phrase \"Not found\" in the local language.\n\nYour program must help Hanna find the treasure by visiting $\\textbf{at most 64 points}$.\n\n### Interactive Protocol\n\nYour program should print each visited point in a line with two coordinates between 0 and $10^6$, inclusive, and flush the output after each one.\n\nFor each visited point, the testing system writes one of the phrases: \"Found!\", \"Closer\", \"Further\", \"At the same distance\", or \"Not found\" in some language, consistent throughout the game. The first phrase ends with an exclamation mark, all other phrases do not contain exclamation marks. All phrases contain only Latin letters, spaces and exclamation marks, have lengths between 2 and 30, inclusive, don't start or end with a space, and are pairwise distinct. The phrases are not necessarily coming from any real human language. \n\nAfter receiving a phrase with an exclamation mark, your program must halt without printing anything else. Visiting points more than once is allowed, and each such visit counts towards the limit of 64 queries.", "inputFormat": "See interactive protocol.", "outputFormat": "See interactive protocol.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2022] Hot and Cold", "background": "", "description": "这是一道交互题。\n\n移居到另一个国家后，小 Hanna 发现玩“热与冷”游戏变得更加困难了：她听不懂提示语！你需要为她编写一个辅助程序。\n\n游戏进行的场地是一个矩形，宝藏藏在某个整点坐标处，坐标范围在 $0$ 和 $10^6$ 之间（包含两端）。Hanna 会访问几个坐标合法的点。如果访问的点藏有宝藏，她会收到当地语言的短语“Found!”。幸运的是，语调让她能够识别出这个短语——在本题中，它将以一个感叹号作为标记。\n\n否则，对于除第一个点外的每个访问点，Hanna 都会收到一个当地语言的短语，说明与前一个点相比，她现在距离宝藏是“Closer”、“Further”还是“At the same distance”。距离使用欧几里得度量进行计算。在访问第一个点后，如果那里没有宝藏，Hanna 会收到当地语言的短语“Not found”。\n\n你的程序必须帮助 Hanna 在**最多访问 64 个点**的情况下找到宝藏。\n\n### 交互方式\n\n你的程序应该每行输出一个访问点的两个坐标（范围在 $0$ 到 $10^6$ 之间，包含两端），并在每次输出后刷新输出流。\n\n对于每个访问的点，测试系统会用某种在整个游戏过程中保持一致的语言写入以下短语之一：“Found!”、“Closer”、“Further”、“At the same distance”或“Not found”。第一个短语以感叹号结尾，所有其他短语不包含感叹号。所有短语只包含拉丁字母、空格和感叹号，长度在 $2$ 到 $30$ 之间（包含两端），不以空格开头或结尾，并且两两不同。这些短语不一定来自任何真实的人类语言。\n\n在收到带感叹号的短语后，你的程序必须停止，且不再打印任何内容。允许重复访问同一点，每次这样的访问都会计入 64 次查询的限制中。", "inputFormat": "见交互方式。", "outputFormat": "见交互方式。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12798", "type": "P", "difficulty": 6, "samples": [["2\n\n1\n\nYES\n\n0\n\n2\n\nYES", "\n? 0\n\n! 1\n\n? 0\n\n? 19997\n\n! 5982"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "交互题", "Special Judge", "构造", "ICPC", "NERC/NEERC"], "title": "[NERC 2022] Interactive Factorial Guessing", "background": "", "description": "Oh no, this wicked jury hides something from you again, and you need to guess it interactively. \n\nThis time, you need to find an integer $n$. To do that, you can make at most 10 queries of the form \"What is the $k$-th decimal digit of the product of all integers from 1 to $n$ (also known as factorial and denoted as $n!$)?\". \n\n### Interactive Protocol\n\nIn the first line, there is an integer $t$ ($1 \\le t \\le 100$) --- the number of tests you shall process. \n\nFor each test, the integer $n$ is chosen in advance. The length of $n!$ is at most $20\\,000$, so $1 \\le n \\le 5982$.\n\nYou can make $\\textbf{at most 10 queries}$ of the form \"$\\tt{? }$ $k$\" ($0 \\le k < 20\\,000$). In response to the query, you will get a single digit --- the $k$-th decimal digit of $n!$ (the response is between 0 and 9 inclusive). Digits are numbered from 0, starting with the least significant digit. If $n!$ is too short, and there is no $k$-th digit, then 0 is returned. \n\nAfter your program finds the value of $n$ it shall answer with \"$\\tt{! }$ $n$\". If the answer is correct, then you will receive \"$\\tt{YES}$\" and should proceed to the next test or terminate if it was the last one. If the answer is not correct, or you are trying to guess, and there are several possible answers consistent with the information you have received, you will get \"$\\tt{NO}$\". In that case, your submission will receive \"$\\tt{Wrong\\ answer}$\" verdict and your code shall terminate immediately. ", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2022] Interactive Factorial Guessing", "background": "", "description": "Oh no, this wicked jury hides something from you again, and you need to guess it interactively. \n\nThis time, you need to find an integer $n$. To do that, you can make at most 10 queries of the form \"What is the $k$-th decimal digit of the product of all integers from 1 to $n$ (also known as factorial and denoted as $n!$)?\". \n\n### Interactive Protocol\n\nIn the first line, there is an integer $t$ ($1 \\le t \\le 100$) --- the number of tests you shall process. \n\nFor each test, the integer $n$ is chosen in advance. The length of $n!$ is at most $20\\,000$, so $1 \\le n \\le 5982$.\n\nYou can make $\\textbf{at most 10 queries}$ of the form \"$\\tt{? }$ $k$\" ($0 \\le k < 20\\,000$). In response to the query, you will get a single digit --- the $k$-th decimal digit of $n!$ (the response is between 0 and 9 inclusive). Digits are numbered from 0, starting with the least significant digit. If $n!$ is too short, and there is no $k$-th digit, then 0 is returned. \n\nAfter your program finds the value of $n$ it shall answer with \"$\\tt{! }$ $n$\". If the answer is correct, then you will receive \"$\\tt{YES}$\" and should proceed to the next test or terminate if it was the last one. If the answer is not correct, or you are trying to guess, and there are several possible answers consistent with the information you have received, you will get \"$\\tt{NO}$\". In that case, your submission will receive \"$\\tt{Wrong\\ answer}$\" verdict and your code shall terminate immediately. ", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2022] Interactive Factorial Guessing", "background": "", "description": "哦不，这可恶的出题人又向你隐瞒了一些东西，你需要通过交互来猜出它。\n\n这一次，你需要找到一个整数 $n$。为此，你可以进行最多 10 次查询，询问 $n!$（即从 1 到 $n$ 的所有整数的乘积，也称为阶乘）的第 $k$ 位十进制数字。\n\n### 交互方式\n\n第一行是一个整数 $t$ ($1 \\le t \\le 100$)——你需要处理的测试数据组数。\n\n对于每组测试，整数 $n$ 是预先选定的。$n!$ 的长度最多为 $20\\,000$，因此 $1 \\le n \\le 5982$。\n\n你可以进行**最多 10 次**形如“$\\tt{? }$ $k$” ($0 \\le k < 20\\,000$) 的查询。作为对查询的回应，你将得到一个数字——$n!$ 的第 $k$ 位十进制数字（回应介于 0 和 9 之间，包含两端）。数字从 0 开始编号，从最低有效位开始。如果 $n!$ 太短，没有第 $k$ 位数字，则返回 0。\n\n当你的程序找到 $n$ 的值后，应以“$\\tt{! }$ $n$”的形式作答。如果答案正确，你将收到“$\\tt{YES}$”，并应继续处理下一组测试，或者如果这是最后一组则终止程序。如果答案不正确，或者你试图猜测，并且存在多个与你收到的信息一致的可能答案，你将收到“$\\tt{NO}$”。在这种情况下，你的提交将获得“$\\tt{Wrong\\ answer}$”的评测结果，你的代码应立即终止。\n", "inputFormat": "见交互方式。", "outputFormat": "见交互方式。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12799", "type": "P", "difficulty": 6, "samples": [["3 3 101\n1 2 30\n2 3 40\n3 1 50", "3\n10 1 2\n20 1 3\n30 2 3"], ["2 2 37\n1 2 8\n1 2 15", "2\n8 1\n15 2"], ["5 4 5\n1 3 1\n2 3 2\n2 5 3\n4 1 4", "-1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2022] Jumbled Trees", "background": "", "description": "You are given an undirected connected graph with $n$ vertices and $m$ edges. Each edge has an associated counter, initially equal to $0$. In one operation, you can choose an arbitrary spanning tree and add any value $v$ to all edges of this spanning tree. \n\nDetermine if it's possible to make every counter equal to its target value $x_i$ modulo prime $p$, and provide a sequence of operations that achieves it.", "inputFormat": "The first line contains three integers $n$, $m$, and $p$ --- the number of vertices, the number of edges, and the prime modulus ($1 \\le n \\le 500$; $1 \\le m \\le 1000$; $2 \\le p \\le 10^9$, $p$ is prime).\n\nNext $m$ lines contain three integers $u_i$, $v_i$, $x_i$ each --- the two endpoints of the $i$-th edge and the target value of that edge's counter ($1 \\le u_i, v_i \\le n$; $0 \\le x_i < p$; $u_i \\neq v_i$). \n\nThe graph is connected. There are no loops, but there may be multiple edges between the same two vertices.", "outputFormat": "If the target values on counters cannot be achieved, print $\\tt{-1}$. \n\nOtherwise, print $t$ --- the number of operations, followed by $t$ lines, describing the sequence of operations. Each line starts with integer $v$ ($0 \\le v < p$) --- the counter increment for this operation. Then, in the same line, followed by $n - 1$ integers $e_1$, $e_2$, $\\ldots$ $e_{n - 1}$ ($1 \\le e_i \\le m$) --- the edges of the spanning tree.\n\nThe number of operations $t$ should not exceed $2m$. You don't need to minimize $t$. Any correct answer within the $2m$ bound is accepted. You are allowed to repeat spanning trees.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2022] Jumbled Trees", "background": "", "description": "You are given an undirected connected graph with $n$ vertices and $m$ edges. Each edge has an associated counter, initially equal to $0$. In one operation, you can choose an arbitrary spanning tree and add any value $v$ to all edges of this spanning tree. \n\nDetermine if it's possible to make every counter equal to its target value $x_i$ modulo prime $p$, and provide a sequence of operations that achieves it.", "inputFormat": "The first line contains three integers $n$, $m$, and $p$ --- the number of vertices, the number of edges, and the prime modulus ($1 \\le n \\le 500$; $1 \\le m \\le 1000$; $2 \\le p \\le 10^9$, $p$ is prime).\n\nNext $m$ lines contain three integers $u_i$, $v_i$, $x_i$ each --- the two endpoints of the $i$-th edge and the target value of that edge's counter ($1 \\le u_i, v_i \\le n$; $0 \\le x_i < p$; $u_i \\neq v_i$). \n\nThe graph is connected. There are no loops, but there may be multiple edges between the same two vertices.", "outputFormat": "If the target values on counters cannot be achieved, print $\\tt{-1}$. \n\nOtherwise, print $t$ --- the number of operations, followed by $t$ lines, describing the sequence of operations. Each line starts with integer $v$ ($0 \\le v < p$) --- the counter increment for this operation. Then, in the same line, followed by $n - 1$ integers $e_1$, $e_2$, $\\ldots$ $e_{n - 1}$ ($1 \\le e_i \\le m$) --- the edges of the spanning tree.\n\nThe number of operations $t$ should not exceed $2m$. You don't need to minimize $t$. Any correct answer within the $2m$ bound is accepted. You are allowed to repeat spanning trees.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2022] Jumbled Trees", "background": "", "description": "给定一个有 $n$ 个顶点和 $m$ 条边的无向连通图。每条边都有一个关联的计数器，初始值等于 $0$。在一次操作中，你可以选择任意一个生成树，并将这个生成树中所有边的计数器都加上一个任意值 $v$。\n\n请判断是否可能使每个计数器的值在模质数 $p$ 的意义下等于其目标值 $x_i$，如果可能，请提供一组能实现目标的操作序列。\n", "inputFormat": "第一行包含三个整数 $n$、$m$ 和 $p$——顶点的数量、边的数量以及一个质数模数 ($1 \\le n \\le 500$; $1 \\le m \\le 1000$; $2 \\le p \\le 10^9$，$p$ 是一个质数)。\n\n接下来的 $m$ 行，每行包含三个整数 $u_i$、$v_i$、$x_i$——表示第 $i$ 条边的两个端点以及该边计数器的目标值 ($1 \\le u_i, v_i \\le n$; $0 \\le x_i < p$; $u_i \\neq v_i$)。\n\n该图是连通的。图中没有自环，但相同的两个顶点之间可能存在多条边。", "outputFormat": "如果无法达到计数器的目标值，则输出 $\\tt{-1}$。\n\n否则，输出操作次数 $t$，然后是 $t$ 行描述操作序列的内容。每行以一个整数 $v$ ($0 \\le v < p$) 开始——表示本次操作的计数器增量。然后，在同一行中，跟着 $n - 1$ 个整数 $e_1, e_2, \\ldots, e_{n - 1}$ ($1 \\le e_i \\le m$)——表示生成树的边。\n\n操作次数 $t$ 不应超过 $2m$。你不需要最小化 $t$。任何在 $2m$ 限制内的正确答案都会被接受。你可以重复使用生成树。\n", "hint": "翻译由 gemini2.5pro 完成", "locale": "zh-CN"}}}
{"pid": "P12800", "type": "P", "difficulty": 4, "samples": [["5 2", "YES\n4\n1 2\n1 3\n1 4\n1 5"], ["4 1", "YES\n4\n1 2\n2 3\n3 4\n4 1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "Special Judge", "构造", "ICPC", "Ad-hoc", "NERC/NEERC"], "title": "[NERC 2022] King' s Puzzle", "background": "", "description": "King Kendrick is a sovereign ruler of Kotlin Kingdom. He is getting ready for the next session of the government. Kotlin Kingdom consists of $n$ cities. These cities need to be connected by several bidirectional roads. Since ministries are responsible for aspects of safety and comfort of the kingdom's residents, some of them have made the following requirements:\n\n- \"All the cities should be connected by new roads, i.e. there should be a path from any city to any other city via the roads\" --- Ministry of Transport and Digital Infrastructure.\n- \"There may not be a loop road --- a road that connects a city with itself\" --- Ministry of Environment.\n- \"There should be at most one road between a pair of cities\" --- Treasury Department.\n- \"If $a_i$ is the number of roads connected to $i$-th city, then the set $\\{a_1, \\ldots, a_n\\}$ should consist of exactly $k$ distinct numbers\" --- Ministry of ICPC.\n\nKing Kendrick has issues with the requirements from the Ministry of ICPC. He asks you to help him. Find any set of roads that suits all the requirements above or say that it is impossible.", "inputFormat": "The only line of the input consists of two integers $n$ and $k$ ($1 \\le k \\le n \\le 500$).", "outputFormat": "If it is impossible to satisfy all the requirements, output $\\texttt{NO}$ in the only line.\n\nOtherwise, output $\\texttt{YES}$ in the first line.\n\nOutput $m$ --- the number of roads ($0 \\le m \\le \\frac{n \\cdot (n - 1)}{2}$) in the second line.\n\nNext $m$ lines should contain pairs of integers $a$ and $b$ --- the cities to connect by a road ($1 \\le a, b \\le n$).", "hint": "### Sample 1 Explanation\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cuv06x7v.png)\n\nCity 1 has four roads connected to it while other cities have exactly one.\n\n### Sample 2 Explanation\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xbm5xgu8.png)\n\nEvery city has exactly two roads connected to it.", "locale": "en", "translations": {"en": {"title": "[NERC 2022] King' s Puzzle", "background": "", "description": "King Kendrick is a sovereign ruler of Kotlin Kingdom. He is getting ready for the next session of the government. Kotlin Kingdom consists of $n$ cities. These cities need to be connected by several bidirectional roads. Since ministries are responsible for aspects of safety and comfort of the kingdom's residents, some of them have made the following requirements:\n\n- \"All the cities should be connected by new roads, i.e. there should be a path from any city to any other city via the roads\" --- Ministry of Transport and Digital Infrastructure.\n- \"There may not be a loop road --- a road that connects a city with itself\" --- Ministry of Environment.\n- \"There should be at most one road between a pair of cities\" --- Treasury Department.\n- \"If $a_i$ is the number of roads connected to $i$-th city, then the set $\\{a_1, \\ldots, a_n\\}$ should consist of exactly $k$ distinct numbers\" --- Ministry of ICPC.\n\nKing Kendrick has issues with the requirements from the Ministry of ICPC. He asks you to help him. Find any set of roads that suits all the requirements above or say that it is impossible.", "inputFormat": "The only line of the input consists of two integers $n$ and $k$ ($1 \\le k \\le n \\le 500$).", "outputFormat": "If it is impossible to satisfy all the requirements, output $\\texttt{NO}$ in the only line.\n\nOtherwise, output $\\texttt{YES}$ in the first line.\n\nOutput $m$ --- the number of roads ($0 \\le m \\le \\frac{n \\cdot (n - 1)}{2}$) in the second line.\n\nNext $m$ lines should contain pairs of integers $a$ and $b$ --- the cities to connect by a road ($1 \\le a, b \\le n$).", "hint": "### Sample 1 Explanation\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cuv06x7v.png)\n\nCity 1 has four roads connected to it while other cities have exactly one.\n\n### Sample 2 Explanation\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xbm5xgu8.png)\n\nEvery city has exactly two roads connected to it.", "locale": "en"}, "zh-CN": {"title": "[NERC 2022] King' s Puzzle", "background": "", "description": "国王 Kendrick 是 Kotlin 王国的君主。他正在为下一次政$ $府会议做准备。Kotlin 王国由 $n$ 个城市组成。这些城市需要通过若干条双向道路连接起来。由于各个部门负责王国居民的安全和舒适等方面，其中一些部门提出了以下要求：\n\n- “所有城市都应通过新修的道路连接起来，即任意一个城市都应能通过道路到达其他任何城市”——交通与数字基础设施部。\n- “不能有自环路——即连接一个城市到其自身的道路”——环境部。\n- “任意一对城市之间最多只能有一条道路”——财政部。\n- “如果 $a_i$ 是连接到第 $i$ 个城市的道路数量，那么集合 $\\{a_1, \\ldots, a_n\\}$ 应恰好由 $k$ 个不同的数字组成”——ICPC 部。\n\n国王 Kendrick 对 ICPC 部的要求感到头疼。他请求你帮助他。请找出一组满足上述所有要求的道路方案，或者说明这是不可能的。", "inputFormat": "输入的唯一一行包含两个整数 $n$ 和 $k$ ($1 \\le k \\le n \\le 500$)。\n", "outputFormat": "如果无法满足所有要求，则在唯一一行输出 $\\texttt{NO}$。\n\n否则，在第一行输出 $\\texttt{YES}$。\n\n在第二行输出道路的数量 $m$ ($0 \\le m \\le \\frac{n \\cdot (n - 1)}{2}$)。\n\n接下来的 $m$ 行应包含整数对 $a$ 和 $b$——表示要用道路连接的城市 ($1 \\le a, b \\le n$)。", "hint": "### 样例 1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cuv06x7v.png)\n\n城市 1 有四条道路与之相连，而其他城市都只有一条。\n\n### 样例 2 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xbm5xgu8.png)\n\n每个城市都恰好有两条道路与之相连。\n\n翻译由 gemini2.5pro 完成", "locale": "zh-CN"}}}
{"pid": "P12801", "type": "P", "difficulty": 7, "samples": [["5 3\n1 2 3 4 5", "2\n1 0 3 0 5"], ["6 3\n1 1 1 1 1 1", "3\n1 100000 0 1 0 1"], ["6 4\n1 1 4 4 1 1", "1\n1 1 4 0 1 1"], ["6 4\n4 4 4 2 2 2", "2\n4 4 0 2 0 2"], ["6 4\n4 4 4 3 4 4", "1\n4 4 100000 3 4 4"], ["8 4\n2 1 1 3 3 1 1 2", "2\n2 1 1 3 0 1 0 2"], ["10 4\n1 1 1 2 2 1 1 2 2 1", "2\n1 1 100000 2 2 100000 1 2 2 1"], ["7 5\n5 4 4 3 4 4 4", "0\n5 4 4 3 4 4 4"], ["10 10\n1 1 1 1 1 1 1 1 1 1", "1\n1 1 1 1 1 1 1 1 0 1"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2022] Lisa's Sequences", "background": "", "description": "Lisa loves playing with the sequences of integers. When she gets a new integer sequence $a_i$ of length $n$, she starts looking for all $\\textit{monotone}$ subsequences. A monotone subsequence $[l, r]$ is defined by two indices $l$ and $r$ ($1 \\le l < r \\le n$) such that $\\forall i = l, l+1, \\ldots, r-1: a_i \\le a_{i+1}$ or $\\forall i = l, l+1, \\ldots, r-1: a_i \\ge a_{i+1}$. \n\nLisa considers a sequence $a_i$ to be $\\textit{boring}$ if there is a monotone subsequence $[l, r]$ that is as long as her boredom threshold $k$, that is when $r - l + 1 = k$.\n\nLucas has a sequence $b_i$ that he wants to present to Lisa, but the sequence might be boring for Lisa. So, he wants to change some elements of his sequence $b_i$, so that Lisa does not get bored playing with it. However, Lucas is lazy and wants to change as few elements of the sequence $b_i$ as possible. Your task is to help Lucas find the required changes. ", "inputFormat": "The first line of the input contains two integers $n$ and $k$ ($3 \\le k \\le n \\le 10^6$) --- the length of the sequence and Lisa's boredom threshold. The second line contains $n$ integers $b_i$ ($1 \\le b_i \\le 99\\,999$) --- the original sequence that Lucas has.", "outputFormat": "On the first line output an integer $m$ --- the minimal number of elements in $b_i$ that needs to be changed to make the sequence not boring for Lisa. On the second line output $n$ integers $a_i$ ($0 \\le a_i \\le 100\\,000$), so that the sequence of integers $a_i$ is not boring for Lisa and is different from the original sequence $b_i$ in exactly $m$ positions.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2022] Lisa's Sequences", "background": "", "description": "Lisa loves playing with the sequences of integers. When she gets a new integer sequence $a_i$ of length $n$, she starts looking for all $\\textit{monotone}$ subsequences. A monotone subsequence $[l, r]$ is defined by two indices $l$ and $r$ ($1 \\le l < r \\le n$) such that $\\forall i = l, l+1, \\ldots, r-1: a_i \\le a_{i+1}$ or $\\forall i = l, l+1, \\ldots, r-1: a_i \\ge a_{i+1}$. \n\nLisa considers a sequence $a_i$ to be $\\textit{boring}$ if there is a monotone subsequence $[l, r]$ that is as long as her boredom threshold $k$, that is when $r - l + 1 = k$.\n\nLucas has a sequence $b_i$ that he wants to present to Lisa, but the sequence might be boring for Lisa. So, he wants to change some elements of his sequence $b_i$, so that Lisa does not get bored playing with it. However, Lucas is lazy and wants to change as few elements of the sequence $b_i$ as possible. Your task is to help Lucas find the required changes. ", "inputFormat": "The first line of the input contains two integers $n$ and $k$ ($3 \\le k \\le n \\le 10^6$) --- the length of the sequence and Lisa's boredom threshold. The second line contains $n$ integers $b_i$ ($1 \\le b_i \\le 99\\,999$) --- the original sequence that Lucas has.", "outputFormat": "On the first line output an integer $m$ --- the minimal number of elements in $b_i$ that needs to be changed to make the sequence not boring for Lisa. On the second line output $n$ integers $a_i$ ($0 \\le a_i \\le 100\\,000$), so that the sequence of integers $a_i$ is not boring for Lisa and is different from the original sequence $b_i$ in exactly $m$ positions.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2022] Lisa's Sequences", "background": "", "description": "丽莎喜欢玩整数序列。当她得到一个长度为 $n$ 的新整数序列 $a_i$ 时，她会开始寻找所有 **单调** 子序列。一个单调子序列 $[l, r]$ 由两个索引 $l$ 和 $r$ ($1 \\le l < r \\le n$) 定义，满足 $\\forall i = l, l+1, \\ldots, r-1: a_i \\le a_{i+1}$ 或 $\\forall i = l, l+1, \\ldots, r-1: a_i \\ge a_{i+1}$。\n\n如果存在一个长度等于她的厌倦阈值 $k$ 的单调子序列 $[l, r]$，即 $r - l + 1 = k$，丽莎就认为序列 $a_i$ 是 **无聊的**。\n\n卢卡斯有一个序列 $b_i$ 想送给丽莎，但这个序列对丽莎来说可能很无聊。所以，他想修改序列 $b_i$ 中的一些元素，使得丽莎在玩这个序列时不会感到无聊。然而，卢卡斯很懒，只想修改序列 $b_i$ 中尽可能少的元素。你的任务是帮助卢卡斯找到需要进行的修改。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $k$ ($3 \\le k \\le n \\le 10^6$)——序列的长度和丽莎的厌倦阈值。第二行包含 $n$ 个整数 $b_i$ ($1 \\le b_i \\le 99\\,999$)——卢卡斯拥有的原始序列。\n", "outputFormat": "在第一行输出一个整数 $m$——为了使序列对丽莎来说不无聊，需要修改 $b_i$ 中元素的最少数量。在第二行输出 $n$ 个整数 $a_i$ ($0 \\le a_i \\le 100\\,000$)，使得整数序列 $a_i$ 对丽莎来说不无聊，并且与原始序列 $b_i$ 恰好在 $m$ 个位置上不同。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12802", "type": "P", "difficulty": 3, "samples": [["4\n3 15\n6 5 26\n3 15\n6 5 27\n2 1000000000\n500123123 497000000\n7 2\n6 2 4 1 9 3 12", "2\n-1\n0\n4"]], "limits": {"time": [1000, 1000, 1000], "memory": [524288, 524288, 524288]}, "tags": ["贪心", "2019", "排序", "优先队列", "ICPC"], "title": "[AMPPZ 2019] Assimilation", "background": "Source: [AMPPZ 2019](https://amppz.tcs.uj.edu.pl/2019/data.html).", "description": "一群开化的外星种族计划同化一个恒星系统，以帮助其居民臻至完美。他们可能会抵抗，但——正如你们所深知的那样——抵抗是徒劳的。  \n\n该星系中有 $ n $ 颗行星，其上分别居住着 $ a_1, a_2, \\ldots, a_n $ 个居民。外星人初始拥有 $ k $ 艘同化飞船，并允许执行以下任意操作：  \n\n- **入侵** (invasion) 需要派遣部分舰队登陆行星。  \n  登陆飞船数量 $ s $ 必须大于或等于该行星人口 $ m $。  \n  入侵后，这些飞船消失，该行星被**征服** (conquered) 且人口变为 $ m + s $。  \n\n- **动员** (mobilization) 可从一颗被征服的行星上，创造等同于该行星人口数量的新飞船。  \n  每颗行星最多仅可被动员一次。  \n\n对外星人而言，入侵轻松而自然，但动员却略显棘手。请帮助他们以尽可能少的动员次数征服所有行星。", "inputFormat": "**本题单个测试点内有多组测试数据。**\n\n\n第一行一个整数，表示测试数据组数 $ z $ $(1 \\le z \\le 30)$。  \n\n随后依次描述 $z$ 组测试数据，每组测试数据格式如下：  \n\n- 每组数据第一行包含两个整数 $ n $ 和 $ k $ $(1 \\le n \\le 200\\,000; 1 \\le k \\le 10^9)$  \n  ——行星数量及外星人初始舰队规模。  \n- 第二行包含 $ n $ 个整数 $ a_1, \\ldots, a_n $ $(1 \\le a_i \\le 10^9)$  \n  ——各行星的人口数量。  \n\n所有测试用例的 $ n $ 值总和不超过 $500,000$。  \n", "outputFormat": "\n对每个测试用例，输出一个整数：征服所有行星所需的最小动员次数。  \n\n若无法完成征服，则输出 $\\texttt{-1}$。  \n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[AMPPZ 2019] Assimilation", "background": "\n\n**Time limit:** 1s, **Memory limit:** 512MB", "description": "\n\nAn enlightened race of aliens plans to assimilate a star system, to help its inhabitants achieve perfection. They may resist, but — as you are all well aware — resistance is futile.\n\nThere are $ n $ planets in the system, inhabited by $ a_1, a_2, \\ldots, a_n $ people, respectively. Aliens start with $ k $ assimilation ships and are allowed to make any of the following moves:\n\n- An *invasion* requires landing on a planet with some part of the fleet. The number of landing ships $ s $ must be greater or equal to the population $ m $ of the planet. After the invasion, these ships disappear, the planet is *conquered* and now has $ m + s $ inhabitants.\n\n- A *mobilization* creates, from a conquered planet, a number of new ships equal to the population of the planet. Every planet can be mobilized at most once.\n\nFor Aliens, invasions are easy and natural, but mobilizations turn out to be a bit tricky. Help them conquer all the planets in the system with minimal possible number of mobilizations.\n", "inputFormat": "\nThe first line of input contains the number of test cases $ z $ $(1 \\le z \\le 30)$. The test cases follow, each one in the following format:\n\n- The first line of every test case contains two integers $ n $ and $ k $ $(1 \\le n \\le 200\\,000; 1 \\le k \\le 10^9)$ — the number of planets, and the size of Aliens’ initial fleet.\n- The second line contains $ n $ integers $ a_1, \\ldots, a_n $ $(1 \\le a_i \\le 10^9)$ — the populations of the respective planets.\n\nThe sum of $ n $ values over all test cases does not exceed $500,000$.", "outputFormat": "\nFor every test case, output a single integer: the minimal number of mobilizations required to conquer all the planets. If such conquest is impossible, output $-1$ instead.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[AMPPZ 2019] Assimilation", "background": "Source: [AMPPZ 2019](https://amppz.tcs.uj.edu.pl/2019/data.html).", "description": "一群开化的外星种族计划同化一个恒星系统，以帮助其居民臻至完美。他们可能会抵抗，但——正如你们所深知的那样——抵抗是徒劳的。  \n\n该星系中有 $ n $ 颗行星，其上分别居住着 $ a_1, a_2, \\ldots, a_n $ 个居民。外星人初始拥有 $ k $ 艘同化飞船，并允许执行以下任意操作：  \n\n- **入侵** (invasion) 需要派遣部分舰队登陆行星。  \n  登陆飞船数量 $ s $ 必须大于或等于该行星人口 $ m $。  \n  入侵后，这些飞船消失，该行星被**征服** (conquered) 且人口变为 $ m + s $。  \n\n- **动员** (mobilization) 可从一颗被征服的行星上，创造等同于该行星人口数量的新飞船。  \n  每颗行星最多仅可被动员一次。  \n\n对外星人而言，入侵轻松而自然，但动员却略显棘手。请帮助他们以尽可能少的动员次数征服所有行星。", "inputFormat": "**本题单个测试点内有多组测试数据。**\n\n\n第一行一个整数，表示测试数据组数 $ z $ $(1 \\le z \\le 30)$。  \n\n随后依次描述 $z$ 组测试数据，每组测试数据格式如下：  \n\n- 每组数据第一行包含两个整数 $ n $ 和 $ k $ $(1 \\le n \\le 200\\,000; 1 \\le k \\le 10^9)$  \n  ——行星数量及外星人初始舰队规模。  \n- 第二行包含 $ n $ 个整数 $ a_1, \\ldots, a_n $ $(1 \\le a_i \\le 10^9)$  \n  ——各行星的人口数量。  \n\n所有测试用例的 $ n $ 值总和不超过 $500,000$。  \n", "outputFormat": "\n对每个测试用例，输出一个整数：征服所有行星所需的最小动员次数。  \n\n若无法完成征服，则输出 $\\texttt{-1}$。  \n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12803", "type": "P", "difficulty": 0, "samples": [["3\n6\n1 2\n1 3\n1 4\n4 5\n4 6\n2 3\n5 6\n15\n1 2\n1 6\n2 3\n2 4\n2 5\n6 7\n6 8\n5 9\n6 10\n9 11\n9 12\n9 13\n12 14\n14 15\n14 13\n3 6\n6\n1 2\n1 3\n2 4\n4 5\n5 6\n4 6\n3 2", "-1\n7\n15 5 2 1 6 7 3\n3\n2 1 3"]], "limits": {"time": [5000, 5000, 5000], "memory": [524288, 524288, 524288]}, "tags": ["2019", "Special Judge", "ICPC"], "title": "[AMPPZ 2019] Little Worm", "background": "Source: [AMPPZ 2019](https://amppz.tcs.uj.edu.pl/2019/data.html).", "description": "小虫住在一棵树上。 这棵树有 $ n $ 个顶点（并且是一个连通的、无向的无环图），小虫占据了顶点 $ a $ 和 $ b $ 之间的整条路径。\n\n小虫想移动到另一条路径——顶点 $ c $ 和 $ d $ 之间的那条路径——因为那里阳光更充足。 已知路径 $ a \\leftrightarrow b $ 和 $ c \\leftrightarrow d $ 没有公共顶点。\n\n为了改变它在树上的位置，小虫可以进行一些移动，这些移动包括让小虫的任意一端进入一个空闲顶点。 形式化地说，如果小虫当前占据 $ x $ 和 $ y $ 之间的路径，它可以选择一个与 $ x $ 相邻的新顶点 $ z $，该顶点不在路径 $ x \\leftrightarrow y $ 上。 然后小虫释放（停止占据） $ y $ ，改为占据 $ z $ 。 类似地，小虫可以选择一个与 $ y $ 相邻的顶点 $ z' $ ，释放 $ x $ 并占据 $ z' $ 。 在一次移动后，小虫仍然占据着某条路径，并且其长度不变。\n\n小虫的目标是到达 $ c $ 和 $ d $ 之间的路径，但由于相当懒惰，它计划移动不超过 $ 10 \\cdot n $ 次。 你能帮助它在不超过该限制的情况下达到目标吗？\n", "inputFormat": "**本题单个测试点内有多组测试数据。**\n\n输入的第一行包含测试数据的组数 $ z $ ($ 1 \\leq z \\leq 7000 $)。测试数据组随后给出，每组格式如下：\n\n*   测试数据的第一行包含一个整数 $ n $ ($ 4 \\leq n \\leq 100\\,000 $) —— 树的顶点数。 接下来的 $ n - 1 $ 行每行包含两个整数 $ u, v $ ($ 1 \\leq u \\ne v \\leq n $)，描述一条边的两个端点。\n*   下一行给出两个整数 $ a $ 和 $ b $ ($ 1 \\leq a \\ne b \\leq n $)。 这些是小虫起始位置路径的端点。\n*   下一行包含小虫目标路径的端点，以两个整数 $ c $ 和 $ d $ ($ 1 \\leq c \\ne d \\leq n $) 给出。\n\n$ a $ 和 $ b $ 之间路径上的顶点数与 $ c $ 和 $ d $ 之间路径上的顶点数相同。 你也可以假设这两条路径没有公共顶点。\n\n所有测试数据的 $ n $ 值之和不超过 $ 1\\,000\\,000 $。", "outputFormat": "\n对于每组测试数据，如果小虫不能在 $ 10 \\cdot n $ 次移动内达到目标，则输出 $-1$。 否则，在两行中输出小虫移动的一种可能序列：\n\n*   第一行：移动次数 $ q $ ($ 1 \\leq q \\leq 10 \\cdot n $)，\n*   第二行： $ q $ 个整数 $ v_1, v_2, \\ldots, v_q $ —— 所需的移动序列。\n\n对于 $ i = 1, 2, \\ldots, q $，值 $ v_i $ 应表示第 $ i $ 次移动中小虫进入的顶点。\n\n你可以输出任何将小虫移动到目标路径且移动次数不超过 $ 10 \\cdot n $ 的正确序列（特别地，你不需要最小化移动次数）。 假设小虫是对称的——它可以向两个方向移动，并且可以以任意一端朝向进入目标路径。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[AMPPZ 2019] Little Worm", "background": "", "description": "\n\nLittle Worm is living on a tree. The tree has $ n $ vertices (and is a connected, undirected acyclic graph), and Worm occupies the whole path between the vertices $ a $ and $ b $.\n\nWorm would like to move to another path – the one between vertices $ c $ and $ d $ – as it is more sunny there. It is known that the paths $ a \\leftrightarrow b $ and $ c \\leftrightarrow d $ have no vertices in common.\n\nTo change its position on the tree, Worm can make some moves, which consist of entering a free vertex with Worm’s either end. Formally, if Worm is currently occupying a path between $ x $ and $ y $, it may choose a new vertex $ z $ adjacent to $ x $, which is not on the path $ x \\leftrightarrow y $. Then Worm frees (stops occupying) $ y $, taking $ z $ instead. In a similar way, Worm can choose a vertex $ z' $ adjacent to $ y $, free $ x $ and occupy $ z' $. After a single move Worm still occupies some path, and its length does not change.\n\nWorm is aiming to get to the path between $ c $ and $ d $, but being quite lazy, it doesn’t plan for more than $ 10 \\cdot n $ moves. Can you help it reach its goal within that limit?\n", "inputFormat": "\nThe first line of input contains the number of test cases $ z $ ($ 1 \\leq z \\leq 7000 $). The test cases follow, each one in the following format:\n\n- The first line of a test case contains a single integer $ n $ ($ 4 \\leq n \\leq 100\\,000 $) – the number of the vertices of a tree. Each of the following $ n - 1 $ lines contains two integers $ u, v $ ($ 1 \\leq u \\ne v \\leq n $), describing the endpoints of a single edge.\n- In the next line two integers $ a $ and $ b $ ($ 1 \\leq a \\ne b \\leq n $) are given. These are the endpoints of the path that is Worm’s starting position.\n- The next line contains the endpoints of the path which is Worm’s goal, given as two integers $ c $ and $ d $ ($ 1 \\leq c \\ne d \\leq n $).\n\nThe number of vertices on the path between $ a $ and $ b $ match the number of vertices on the path between $ c $ and $ d $. You may also assume that those two paths have no common vertices.\n\nThe sum of all values of $ n $ over all test cases does not exceed $ 1\\,000\\,000 $.\n", "outputFormat": "\nFor every test case, if Worm cannot reach its goal in $ 10 \\cdot n $ moves, output $-1$. Otherwise, output a possible sequence of Worm’s moves in two lines:\n\n- First line: the number of moves $ q $ ($ 1 \\leq q \\leq 10 \\cdot n $),\n- Second line: $ q $ integers $ v_1, v_2, \\ldots, v_q $ – the required moves.\n\nFor $ i = 1, 2, \\ldots, q $, the value $ v_i $ should denote the vertex which is entered by Worm in the $ i $-th move.\n\nYou may output any correct sequence that moves Worm to the goal and has no more than $ 10 \\cdot n $ moves (in particular, you do not have to minimize the number of moves). Assume that Worm is symmetrical – it can move in both directions and it can enter the goal path facing either side.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[AMPPZ 2019] Little Worm", "background": "Source: [AMPPZ 2019](https://amppz.tcs.uj.edu.pl/2019/data.html).", "description": "小虫住在一棵树上。 这棵树有 $ n $ 个顶点（并且是一个连通的、无向的无环图），小虫占据了顶点 $ a $ 和 $ b $ 之间的整条路径。\n\n小虫想移动到另一条路径——顶点 $ c $ 和 $ d $ 之间的那条路径——因为那里阳光更充足。 已知路径 $ a \\leftrightarrow b $ 和 $ c \\leftrightarrow d $ 没有公共顶点。\n\n为了改变它在树上的位置，小虫可以进行一些移动，这些移动包括让小虫的任意一端进入一个空闲顶点。 形式化地说，如果小虫当前占据 $ x $ 和 $ y $ 之间的路径，它可以选择一个与 $ x $ 相邻的新顶点 $ z $，该顶点不在路径 $ x \\leftrightarrow y $ 上。 然后小虫释放（停止占据） $ y $ ，改为占据 $ z $ 。 类似地，小虫可以选择一个与 $ y $ 相邻的顶点 $ z' $ ，释放 $ x $ 并占据 $ z' $ 。 在一次移动后，小虫仍然占据着某条路径，并且其长度不变。\n\n小虫的目标是到达 $ c $ 和 $ d $ 之间的路径，但由于相当懒惰，它计划移动不超过 $ 10 \\cdot n $ 次。 你能帮助它在不超过该限制的情况下达到目标吗？\n", "inputFormat": "**本题单个测试点内有多组测试数据。**\n\n输入的第一行包含测试数据的组数 $ z $ ($ 1 \\leq z \\leq 7000 $)。测试数据组随后给出，每组格式如下：\n\n*   测试数据的第一行包含一个整数 $ n $ ($ 4 \\leq n \\leq 100\\,000 $) —— 树的顶点数。 接下来的 $ n - 1 $ 行每行包含两个整数 $ u, v $ ($ 1 \\leq u \\ne v \\leq n $)，描述一条边的两个端点。\n*   下一行给出两个整数 $ a $ 和 $ b $ ($ 1 \\leq a \\ne b \\leq n $)。 这些是小虫起始位置路径的端点。\n*   下一行包含小虫目标路径的端点，以两个整数 $ c $ 和 $ d $ ($ 1 \\leq c \\ne d \\leq n $) 给出。\n\n$ a $ 和 $ b $ 之间路径上的顶点数与 $ c $ 和 $ d $ 之间路径上的顶点数相同。 你也可以假设这两条路径没有公共顶点。\n\n所有测试数据的 $ n $ 值之和不超过 $ 1\\,000\\,000 $。", "outputFormat": "\n对于每组测试数据，如果小虫不能在 $ 10 \\cdot n $ 次移动内达到目标，则输出 $-1$。 否则，在两行中输出小虫移动的一种可能序列：\n\n*   第一行：移动次数 $ q $ ($ 1 \\leq q \\leq 10 \\cdot n $)，\n*   第二行： $ q $ 个整数 $ v_1, v_2, \\ldots, v_q $ —— 所需的移动序列。\n\n对于 $ i = 1, 2, \\ldots, q $，值 $ v_i $ 应表示第 $ i $ 次移动中小虫进入的顶点。\n\n你可以输出任何将小虫移动到目标路径且移动次数不超过 $ 10 \\cdot n $ 的正确序列（特别地，你不需要最小化移动次数）。 假设小虫是对称的——它可以向两个方向移动，并且可以以任意一端朝向进入目标路径。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12804", "type": "P", "difficulty": 2, "samples": [["4\n6\n1 2 3 4 5 6\n3\n9 5 14\n4\n5 15 4 6\n2\n10 11", "21\n0\n15\n0"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["贪心", "2019", "ICPC"], "title": "[AMPPZ 2019] Polygon", "background": "Source: [AMPPZ 2019](https://amppz.tcs.uj.edu.pl/2019/data.html).", "description": " \n给定 $n$ 条长度分别为 $\\ell_1, \\ell_2, \\ldots, \\ell_n$ 的线段。确定可以用这些线段（以任意顺序，且不一定全部使用）构造出的凸多边形可能的最大周长。 \n\n该多边形必须是非退化的——换句话说，其面积必须为正。  \n", "inputFormat": "\n**本题单个测试点内有多组测试数据。** \n\n输入的第一行包含测试数据组数 $z$ ($1 \\le z \\le 100\\,000$)。  \n测试数据紧随其后，每组数据格式如下：  \n\n*   测试数据的第一行包含线段数量 $n$ ($1 \\le n \\le 100\\,000$)。  \n*   第二行包含 $n$ 个整数 $\\ell_1, \\ldots, \\ell_n$ ($1 \\le \\ell_i \\le 10^9$) —— 表示线段的长度。  \n \n所有测试数据中 $n$ 的总和不超过 $1\\,000\\,000$。  ", "outputFormat": "\n对于每组测试数据，输出一个整数 —— 表示用给定线段构造出的凸多边形可能的最大周长。  \n如果无法构造出这样的多边形，则输出 $0$。  \n\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[AMPPZ 2019] Polygon", "background": "**Time limit:** 1s, **memory limit:** 512MB\n", "description": "\nYou are given $n$ segments of lengths $\\ell_1, \\ell_2, \\ldots, \\ell_n$, respectively. Determine the largest possible circumference of a convex polygon that can be constructed using these segments (in any order, and not neccessarily all of them). The polygon must be non-degenerate – in other words, its area must be positive.\n", "inputFormat": "\nThe first line of input contains the number of test cases $z$ ($1 \\le z \\le 100\\,000$). The test cases follow, each one in the following format:\n\n- The first line of a test case contains the number of segments $n$ ($1 \\le n \\le 100\\,000$).  \n- In the second line, there are $n$ integers $\\ell_1, \\ldots, \\ell_n$ ($1 \\le \\ell_i \\le 10^9$) – the lengths of the segments.\n\nThe sum of $n$ values over all test cases does not exceed $1\\,000\\,000$.", "outputFormat": "\nFor each test case, output a single integer – the largest possible circumference of a convex polygon made of given segments. If no such polygon can be constructed at all, output $0$.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[AMPPZ 2019] Polygon", "background": "Source: [AMPPZ 2019](https://amppz.tcs.uj.edu.pl/2019/data.html).", "description": " \n给定 $n$ 条长度分别为 $\\ell_1, \\ell_2, \\ldots, \\ell_n$ 的线段。确定可以用这些线段（以任意顺序，且不一定全部使用）构造出的凸多边形可能的最大周长。 \n\n该多边形必须是非退化的——换句话说，其面积必须为正。  \n", "inputFormat": "\n**本题单个测试点内有多组测试数据。** \n\n输入的第一行包含测试数据组数 $z$ ($1 \\le z \\le 100\\,000$)。  \n测试数据紧随其后，每组数据格式如下：  \n\n*   测试数据的第一行包含线段数量 $n$ ($1 \\le n \\le 100\\,000$)。  \n*   第二行包含 $n$ 个整数 $\\ell_1, \\ldots, \\ell_n$ ($1 \\le \\ell_i \\le 10^9$) —— 表示线段的长度。  \n \n所有测试数据中 $n$ 的总和不超过 $1\\,000\\,000$。  ", "outputFormat": "\n对于每组测试数据，输出一个整数 —— 表示用给定线段构造出的凸多边形可能的最大周长。  \n如果无法构造出这样的多边形，则输出 $0$。  \n\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12805", "type": "P", "difficulty": 3, "samples": [["3\n4\n1 39\n2 17\n4 5\n1 40\n3\n1 10\n1 20\n1 30\n7\n5 4\n4 3\n3 2\n2 1\n3 2\n4 3\n5 4", "62\n60\n11"]], "limits": {"time": [3000, 3000, 3000], "memory": [524288, 524288, 524288]}, "tags": ["2019", "ICPC"], "title": "[AMPPZ 2019] Frogs", "background": "Source: [AMPPZ 2019](https://amppz.tcs.uj.edu.pl/2019/data.html).", "description": "\n你可能会认为[青蛙](https://www.luogu.com.cn/user/3296)只擅长跳跃和鸣叫，但事实证明它们也相当精通编程！你的任务是选择三只青蛙组成参加 OpenFrogCup 的最佳团队。\n\n在青蛙最喜欢的池塘中，有 $n$ 块石头排成一行，彼此间隔 1 米。每块石头上坐着一只青蛙。石头（和青蛙）从左到右编号为 $1, 2, \\ldots, n$。第 $i$ 只青蛙坐在第 $i$ 块石头上，并由两个参数描述：其跳跃范围 $r_i$ 和编程能力 $s_i$。这只青蛙可以到达任何距离不超过 $r_i$ 米的石头（即索引 $j$ 在 $[i - r_i, i + r_i]$ 区间内的任何石头）。每只青蛙最多愿意跳跃一次。\n\n参加 OpenFrogCup 的团队必须恰好由三名成员组成，且成员需能共同训练。这意味着必须存在一块所有三只青蛙都能跳到的石头（允许零距离跳跃）。请确定此类团队可能达到的最大编程能力总和。\n\n问题的限制条件保证至少存在一个可能的三蛙团队。\n", "inputFormat": "**本题单个测试点内有多组测试数据。**\n\n输入的第一行包含测试数据组数 $z$（$1 \\leq z \\leq 30$）。测试数据组按如下格式给出：\n\n每组测试数据的第一行包含一个整数 $n$（$3 \\leq n \\leq 200\\,000$）——石头数量（也即青蛙数量）。接下来的 $n$ 行每行包含两个整数 $r_i, s_i$（$1 \\leq r_i, s_i \\leq 200\\,000$）——分别表示第 $i$ 只青蛙的跳跃范围和编程能力。\n\n所有测试数据的 $n$ 值总和不超过 $500\\,000$。", "outputFormat": "\n对于每组测试数据，输出一个整数——可能达到的最大编程能力总和。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[AMPPZ 2019] Frogs", "background": "\n**Time limit:** 3s, **memory limit:** 512MB.", "description": "\n\nYou may think that frogs are only good for leaping and croaking, but it turns out that they are also quite proficient coders! Your task is to choose three frogs which would form the best team for OpenFrogCup.\n\nIn the frogs’ favourite pond there are $n$ stones in a row, spaced 1 meter apart from each other. On every stone, a frog sits. Stones (and frogs) are numbered $1, 2, \\ldots, n$ from the leftmost to the rightmost one. The $i$-th frog sits on $i$-th stone and is described by two parameters: its leap range $r_i$ and its programming skill $s_i$. The frog can reach any stone which is not farther than $r_i$ meters (in other words, any stone with index $j$ in $[i - r_i, i + r_i]$). Each frog is willing to jump at most once.\n\nThe team for OpenFrogCup must consist of exactly three members which can train together. This means that there must be a stone that all three frogs can jump to (allowing zero-length jumps). Determine the largest possible sum of programming skills of such a team.\n\nThe limits for the problem guarantee that there always exists at least one possible three-frog team.\n", "inputFormat": "\nThe first line of input contains the number of test cases $z$ ($1 \\leq z \\leq 30$). The test cases follow, each one in the following format:\n\nThe first line of a test case contains an integer $n$ ($3 \\leq n \\leq 200\\,000$) – the number of stones (and also the frogs). Each of the following $n$ lines contain two integers $r_i, s_i$ ($1 \\leq r_i, s_i \\leq 200\\,000$) – the range and the skill of the $i$-th frog, respectively.\n\nThe sum of $n$ values over all test cases does not exceed $500\\,000$.", "outputFormat": "\nFor every test case, output a single integer – the largest possible sum of skills of a three-frog team.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[AMPPZ 2019] Frogs", "background": "Source: [AMPPZ 2019](https://amppz.tcs.uj.edu.pl/2019/data.html).", "description": "\n你可能会认为[青蛙](https://www.luogu.com.cn/user/3296)只擅长跳跃和鸣叫，但事实证明它们也相当精通编程！你的任务是选择三只青蛙组成参加 OpenFrogCup 的最佳团队。\n\n在青蛙最喜欢的池塘中，有 $n$ 块石头排成一行，彼此间隔 1 米。每块石头上坐着一只青蛙。石头（和青蛙）从左到右编号为 $1, 2, \\ldots, n$。第 $i$ 只青蛙坐在第 $i$ 块石头上，并由两个参数描述：其跳跃范围 $r_i$ 和编程能力 $s_i$。这只青蛙可以到达任何距离不超过 $r_i$ 米的石头（即索引 $j$ 在 $[i - r_i, i + r_i]$ 区间内的任何石头）。每只青蛙最多愿意跳跃一次。\n\n参加 OpenFrogCup 的团队必须恰好由三名成员组成，且成员需能共同训练。这意味着必须存在一块所有三只青蛙都能跳到的石头（允许零距离跳跃）。请确定此类团队可能达到的最大编程能力总和。\n\n问题的限制条件保证至少存在一个可能的三蛙团队。\n", "inputFormat": "**本题单个测试点内有多组测试数据。**\n\n输入的第一行包含测试数据组数 $z$（$1 \\leq z \\leq 30$）。测试数据组按如下格式给出：\n\n每组测试数据的第一行包含一个整数 $n$（$3 \\leq n \\leq 200\\,000$）——石头数量（也即青蛙数量）。接下来的 $n$ 行每行包含两个整数 $r_i, s_i$（$1 \\leq r_i, s_i \\leq 200\\,000$）——分别表示第 $i$ 只青蛙的跳跃范围和编程能力。\n\n所有测试数据的 $n$ 值总和不超过 $500\\,000$。", "outputFormat": "\n对于每组测试数据，输出一个整数——可能达到的最大编程能力总和。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12806", "type": "P", "difficulty": 0, "samples": [["1\n4\n0 0\n0 12\n0 24\n0 25\n3\n1 2 13\n2 3 13\n3 4 1\n4\n3 1\n2 6\n3 1\n2 -6\n4\n1 2\n2 3\n3 4\n1 4", "2\n-1\n1\n1"]], "limits": {"time": [30000, 30000, 30000, 30000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "ICPC"], "title": "[AMPPZ 2019] The Great Drone Show", "background": "Source: [AMPPZ 2019](https://amppz.tcs.uj.edu.pl/2019/data.html).", "description": " \n今年的盛大无人机表演将会取得惊人成功！当然，前提是没有任何事情出大错。并且每个人都按计划行事。  \n\n计划已经详细制定。开始时，有 $n$ 架无人机停在地面上。为了描述它们的运动，我们引入标准的三维欧几里得坐标系，其中地面是 $z = 0$ 平面。第 $i$ 架无人机的起始位置被描述为 $(x_i, y_i, 0)$。  \n\n为了在表演期间允许通信，有 $m$ 条电缆连接在无人机对之间。电缆最初也放置在地面上，以直线段的形式连接一些无人机对。已知从每架无人机到其他每架无人机都有一条电缆序列（电缆网络是连通的）。此外，为了避免电缆缠结，**没有两条线段相交**（它们只能有公共端点）。  \n\n在表演期间，将执行一系列 $k$ 个动作。每个动作包括改变一架无人机的高度（即 $z$ 坐标）。每个动作将平滑执行，并且只有在前一个动作结束后才开始。在一个动作期间，一些无人机之间的距离可能改变——幸运的是，电缆可以一定程度地拉伸。对于每条电缆，我们知道它能承受的最大长度——如果其端点无人机之间的距离超过这个值，电缆就会断裂。  \n\n表演组织者预见到一些电缆可能会断裂。然而，一些无人机对必须保持能够直接或间接通信。给定 $q$ 个特定的**关键**无人机对，确定在表演期间的某个时刻这些对之间的通信是否变得不可能，如果是，确定导致连接丢失的动作。  \n", "inputFormat": "**本题单个测试点内有多组测试数据。**\n\n输入的第一行包含测试数据的组数 $z$（$1 \\le z \\le 400$）。\n\n每组测试数据格式如下：  \n第一行包含无人机的数量 $n$（$2 \\le n \\le 500\\ 000$）。  \n接下来的 $n$ 行每行包含两个整数 $x_i, y_i$（$|x_i|, |y_i| \\le 10^8$）——第 $i$ 架无人机的 $x$ 和 $y$ 坐标。  \n没有两架无人机占据相同的起始位置。  \n\n下一行包含一个整数 $m$（$1 \\le m \\le 3 \\cdot n$）——电缆的数量。  \n接下来的 $m$ 行每行描述一条电缆，包含三个整数 $u, v, l$（$1 \\le u \\ne v \\le n$；$1 \\le l \\le 10^9$）——分别是连接的无人机编号和其最大长度。  \n一对无人机最多只能由一条电缆连接。  \n每条电缆在其起始位置的长度都在给定的长度限制内。  \n\n下一行包含动作的数量 $k$（$1 \\le k \\le 500\\ 000$）。  \n接下来的 $k$ 行每行包含两个整数 $v, h$（$1 \\le v \\le n$；$|h| \\le 10^9$）——移动无人机的编号和其高度的变化（正数表示无人机上升，负数表示下降）。  \n你可以假设没有无人机下降到地面以下（$z$ 坐标保持非负）。  \n\n最后，下一行包含一个整数 $q$（$1 \\le q \\le 500\\ 000$）——需要检查的关键对的数量。  \n在接下来的 $q$ 行中，这些对被描述——每行包含两个无人机编号 $u, v$（$1 \\le u \\ne v \\le n$）。  \n\n所有测试数据中 $n$ 值的总和不超过 $1\\ 000\\ 000$。  \n类似地，$k$ 值的总和和 $q$ 值的总和也都不超过 $1\\ 000\\ 000$。  \n", "outputFormat": "\n对于每个测试数据，输出 $q$ 个整数，每个占一行——每个关键对的答案。对于每个这样的无人机对，输出导致它们失去通信能力的第一个动作的编号。 动作从 1 开始编号。如果一个关键对在整个表演期间保持连通，则输出 $\\texttt{-1}$。\n\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[AMPPZ 2019] The Great Drone Show", "background": "\n**Time limit:** 30s, **memory limit:** 1024MB\n\n", "description": "\nThis year’s Great Drone Show is going to be a stunning success! Well, if nothing goes horribly wrong. And if everybody sticks to the plan.\n\nThe plan is worked out in every detail. At the beginning, $n$ drones are parked on the ground. To describe their movement, we introduce standard Euclidean coordinates in three dimensions, in which the ground is the $z = 0$ plane. The starting position of the $i$-th drone is then described as $(x_i, y_i, 0)$.\n\nTo allow communication during the show, there are $m$ cables between pairs of drones. The cables initially also lie on the ground, in the form of straight segments connecting some pairs of drones. It is known that from every drone there is a sequence of cables to every other drone (the cable network is connected). Moreover, to avoid tangling the cables, **no two segments cross each other** (they can only have common endpoints).\n\nDuring the show a sequence of $k$ moves will be performed. Every move consists of changing the height (i.e. the $z$-coordinate) of one of the drones. Each move will be performed smoothly and will start only after the previous one ends. During a move, the distance between some drones may change – fortunately, the cables can stretch to some degree. For every cable we know the maximal length it can have – if its endpoint drones go further than this value, the cable breaks.\n\nThe show organizers are prepared for some cables to break. However, some pairs of drones must remain able to communicate, directly or indirectly. Given $q$ specific, *critical* pairs of drones, determine if communication between these pairs becomes impossible at some point during the show, and if so, determine the move which will cause the connection loss.\n", "inputFormat": "\nThe first line of input contains the number of test cases $z$ ($1 \\le z \\le 400$). The test cases follow, each one in the following format:\n\n- The first line contains the number of drones $n$ ($2 \\le n \\le 500\\ 000$). Each of the following $n$ lines contains two integers $x_i, y_i$ ($|x_i|, |y_i| \\le 10^8$) – the $x$ and $y$ coordinates of the $i$-th drone. No two drones occupy the same starting location.\n- The next line contains an integer $m$ ($1 \\le m \\le 3 \\cdot n$) – the number of cables. Each of the following $m$ lines describes a single cable, and contains three integers $u, v, l$ ($1 \\le u \\ne v \\le n$; $1 \\le l \\le 10^9$) – the numbers of connected drones and its maximal length, respectively. A pair of drones can be connected by at most one cable. Every cable’s length at its starting position fits within the given length limit.\n- The next line contains the number of moves $k$ ($1 \\le k \\le 500\\ 000$). Each of the following $k$ lines contain two integers $v, h$ ($1 \\le v \\le n$; $|h| \\le 10^9$) – number of the moving drone and its change of height (positive if the drone raises, negative if it falls). You may assume that no drone ever falls below the ground (the $z$ coordinates remain non-negative).\n- Finally, the following line contains an integer $q$ ($1 \\le q \\le 500\\ 000$) – the number of critical pairs to be checked. In the next $q$ lines, these pairs are described – each one contains two drone numbers $u, v$ ($1 \\le u \\ne v \\le n$).\n\nThe sum of $n$ values over all test cases does not exceed $1\\ 000\\ 000$. Similarly, both the sum of $k$ values and the sum of $q$ values also do not exceed $1\\ 000\\ 000$.", "outputFormat": "\nFor every test case, output in separate lines $q$ integers – the answers for each critical pair. For every such pair of drones, output the number of the first move after which the drones lost the ability to communicate. The moves are numbered starting from 1. If a critical pair remains connected during the whole show, output $-1$ instead.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[AMPPZ 2019] The Great Drone Show", "background": "Source: [AMPPZ 2019](https://amppz.tcs.uj.edu.pl/2019/data.html).", "description": " \n今年的盛大无人机表演将会取得惊人成功！当然，前提是没有任何事情出大错。并且每个人都按计划行事。  \n\n计划已经详细制定。开始时，有 $n$ 架无人机停在地面上。为了描述它们的运动，我们引入标准的三维欧几里得坐标系，其中地面是 $z = 0$ 平面。第 $i$ 架无人机的起始位置被描述为 $(x_i, y_i, 0)$。  \n\n为了在表演期间允许通信，有 $m$ 条电缆连接在无人机对之间。电缆最初也放置在地面上，以直线段的形式连接一些无人机对。已知从每架无人机到其他每架无人机都有一条电缆序列（电缆网络是连通的）。此外，为了避免电缆缠结，**没有两条线段相交**（它们只能有公共端点）。  \n\n在表演期间，将执行一系列 $k$ 个动作。每个动作包括改变一架无人机的高度（即 $z$ 坐标）。每个动作将平滑执行，并且只有在前一个动作结束后才开始。在一个动作期间，一些无人机之间的距离可能改变——幸运的是，电缆可以一定程度地拉伸。对于每条电缆，我们知道它能承受的最大长度——如果其端点无人机之间的距离超过这个值，电缆就会断裂。  \n\n表演组织者预见到一些电缆可能会断裂。然而，一些无人机对必须保持能够直接或间接通信。给定 $q$ 个特定的**关键**无人机对，确定在表演期间的某个时刻这些对之间的通信是否变得不可能，如果是，确定导致连接丢失的动作。  \n", "inputFormat": "**本题单个测试点内有多组测试数据。**\n\n输入的第一行包含测试数据的组数 $z$（$1 \\le z \\le 400$）。\n\n每组测试数据格式如下：  \n第一行包含无人机的数量 $n$（$2 \\le n \\le 500\\ 000$）。  \n接下来的 $n$ 行每行包含两个整数 $x_i, y_i$（$|x_i|, |y_i| \\le 10^8$）——第 $i$ 架无人机的 $x$ 和 $y$ 坐标。  \n没有两架无人机占据相同的起始位置。  \n\n下一行包含一个整数 $m$（$1 \\le m \\le 3 \\cdot n$）——电缆的数量。  \n接下来的 $m$ 行每行描述一条电缆，包含三个整数 $u, v, l$（$1 \\le u \\ne v \\le n$；$1 \\le l \\le 10^9$）——分别是连接的无人机编号和其最大长度。  \n一对无人机最多只能由一条电缆连接。  \n每条电缆在其起始位置的长度都在给定的长度限制内。  \n\n下一行包含动作的数量 $k$（$1 \\le k \\le 500\\ 000$）。  \n接下来的 $k$ 行每行包含两个整数 $v, h$（$1 \\le v \\le n$；$|h| \\le 10^9$）——移动无人机的编号和其高度的变化（正数表示无人机上升，负数表示下降）。  \n你可以假设没有无人机下降到地面以下（$z$ 坐标保持非负）。  \n\n最后，下一行包含一个整数 $q$（$1 \\le q \\le 500\\ 000$）——需要检查的关键对的数量。  \n在接下来的 $q$ 行中，这些对被描述——每行包含两个无人机编号 $u, v$（$1 \\le u \\ne v \\le n$）。  \n\n所有测试数据中 $n$ 值的总和不超过 $1\\ 000\\ 000$。  \n类似地，$k$ 值的总和和 $q$ 值的总和也都不超过 $1\\ 000\\ 000$。  \n", "outputFormat": "\n对于每个测试数据，输出 $q$ 个整数，每个占一行——每个关键对的答案。对于每个这样的无人机对，输出导致它们失去通信能力的第一个动作的编号。 动作从 1 开始编号。如果一个关键对在整个表演期间保持连通，则输出 $\\texttt{-1}$。\n\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12807", "type": "P", "difficulty": 0, "samples": [["2\n5 3\n8 10 12\n5 3\n10 10 10", "2\n1 2 5 3 4\n2 1 5 4 3\n0"]], "limits": {"time": [3000, 3000, 3000], "memory": [524288, 524288, 524288]}, "tags": ["2019", "ICPC"], "title": "[AMPPZ 2019] Fantastic compression", "background": "Source: [AMPPZ 2019](https://amppz.tcs.uj.edu.pl/2019/data.html).", "description": "\nFranek 有一项任务：记住序列 $(1, 2, \\ldots, n)$ 的一个排列 $P$。然而，这对他来说太无聊了。于是，他发明了一种全新的、奇妙的方式来压缩这些数字：他选取了一个较小的整数 $k$，并只记住了 $P$ 中所有连续的 $k$ 长度片段的和。换句话说，Franek 现在有一个序列 $S = (S_1, S_2, \\ldots, S_{n-k+1})$，其中：  \n\n- $S_1 = P_1 + P_2 + \\ldots + P_k$，  \n- $S_2 = P_2 + P_3 + \\ldots + P_{k+1}$，  \n- $\\ldots$  \n- $S_{n-k+1} = P_{n-k+1} + P_{n-k+2} + \\ldots + P_n$。  \n\n然而，这种方法很快被证明并不那么奇妙。首先，Franek 惊恐地发现，有时会有多个排列压缩成相同的序列。此外，他现在甚至不确定自己是否正确地记住了压缩后的序列——初始排列可能已经永远丢失了！  \n\n给定一个压缩序列 $S$，帮助 Franek 找到所有与 $S$ 对应的排列 $P$。  \n", "inputFormat": "\n**本题单个测试点内有多组测试数据。**  \n\n第一行输入包含测试数据的数量 $z$（$1 \\le z \\le 1000$）。接下来是每组测试数据，格式如下：  \n\n每组测试数据的第一行包含排列的长度 $n$ 和 Franek 选择的小整数 $k$（$2 \\le n \\le 25000$；$2 \\le k \\le \\min(n, 6)$）。第二行包含 $n - k + 1$ 个整数：压缩序列 $S$ 的元素（$1 \\le S_i \\le 1\\,000\\,000$）。  \n\n所有测试数据中排列的总长度不超过 250, 000。  ", "outputFormat": "\n对于每组测试数据，首先输出与给定序列 $S$ 对应的排列的数量 $c$。接下来的 $c$ 行，按字典序输出这些排列。每个排列应在一行内用 $n$ 个整数表示，用空格分隔。  \n\n假设在给定的测试数据中，$c$ 永远不会超过 1000。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[AMPPZ 2019] Fantastic compression", "background": "\n**Time limit: 3s, memory limit: 512MB.**\n", "description": "\nFranek had one job: to memorize a permutation $ P $ of the sequence $ (1, 2, \\ldots, n) $. This, however, proved too boring. Instead, he compressed the numbers in a new, fantastic way he devised: he took a small integer $ k $ and memorized only the sums of all connected $ k $-length fragments of $ P $. In other words, Franek now has a sequence $ S = (S_1, S_2, \\ldots, S_{n-k+1}) $, where:\n\n- $ S_1 = P_1 + P_2 + \\ldots + P_k $,\n- $ S_2 = P_2 + P_3 + \\ldots + P_{k+1} $,\n- $ \\ldots $\n- $ S_{n-k+1} = P_{n-k+1} + P_{n-k+2} + \\ldots + P_n $.\n\nThe method swiftly proved not-so-fantastic, though. First, Franek discovered, to his horror, that sometimes there are several permutations which all compress to the same sequence. Also, he is not sure anymore if he remembered the compressed sequence correctly – the initial permutation may now be lost forever!\n\nGiven a compressed sequence $ S $, help Franek find all permutations $ P $ which correspond to $ S $.\n", "inputFormat": "\nThe first line of input contains the number of test cases $ z $ ($ 1 \\le z \\le 1000 $). The test cases follow, each one in the following format:\n\nThe first line of a test case contains the length of the permutation $ n $ and the small integer $ k $ chosen by Franek ($ 2 \\le n \\le 25000 $; $ 2 \\le k \\le \\min(n, 6) $). The second line contains $ n - k + 1 $ integers: the elements of the compressed sequence $ S $ ($ 1 \\le S_i \\le 1\\,000\\,000 $).\n\nThe total length of permutations in all test cases does not exceed 250,000.\n", "outputFormat": "\nFor every test case, output first the number $ c $ of permutations that correspond to the given sequence $ S $. In the next $ c $ lines, output these permutations in lexicographic order. Every permutation should be given as $ n $ integers in a single line, separated by spaces.\n\nAssume that for the given tests, $ c $ is never greater than 1000.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[AMPPZ 2019] Fantastic compression", "background": "Source: [AMPPZ 2019](https://amppz.tcs.uj.edu.pl/2019/data.html).", "description": "\nFranek 有一项任务：记住序列 $(1, 2, \\ldots, n)$ 的一个排列 $P$。然而，这对他来说太无聊了。于是，他发明了一种全新的、奇妙的方式来压缩这些数字：他选取了一个较小的整数 $k$，并只记住了 $P$ 中所有连续的 $k$ 长度片段的和。换句话说，Franek 现在有一个序列 $S = (S_1, S_2, \\ldots, S_{n-k+1})$，其中：  \n\n- $S_1 = P_1 + P_2 + \\ldots + P_k$，  \n- $S_2 = P_2 + P_3 + \\ldots + P_{k+1}$，  \n- $\\ldots$  \n- $S_{n-k+1} = P_{n-k+1} + P_{n-k+2} + \\ldots + P_n$。  \n\n然而，这种方法很快被证明并不那么奇妙。首先，Franek 惊恐地发现，有时会有多个排列压缩成相同的序列。此外，他现在甚至不确定自己是否正确地记住了压缩后的序列——初始排列可能已经永远丢失了！  \n\n给定一个压缩序列 $S$，帮助 Franek 找到所有与 $S$ 对应的排列 $P$。  \n", "inputFormat": "\n**本题单个测试点内有多组测试数据。**  \n\n第一行输入包含测试数据的数量 $z$（$1 \\le z \\le 1000$）。接下来是每组测试数据，格式如下：  \n\n每组测试数据的第一行包含排列的长度 $n$ 和 Franek 选择的小整数 $k$（$2 \\le n \\le 25000$；$2 \\le k \\le \\min(n, 6)$）。第二行包含 $n - k + 1$ 个整数：压缩序列 $S$ 的元素（$1 \\le S_i \\le 1\\,000\\,000$）。  \n\n所有测试数据中排列的总长度不超过 250, 000。  ", "outputFormat": "\n对于每组测试数据，首先输出与给定序列 $S$ 对应的排列的数量 $c$。接下来的 $c$ 行，按字典序输出这些排列。每个排列应在一行内用 $n$ 个整数表示，用空格分隔。  \n\n假设在给定的测试数据中，$c$ 永远不会超过 1000。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12808", "type": "P", "difficulty": 0, "samples": [["2\n10 3\n9 9 3 2 1 9 6 9 1 7\n1 13\n6 6\n2 9\n5 1\n66575 45720 67904 18764 35162\n20000 80000", "55\n1\n17\n7"]], "limits": {"time": [7000], "memory": [524288]}, "tags": ["2019", "ICPC"], "title": "[AMPPZ 2019] Bookstore", "background": "Source: [AMPPZ 2019](https://amppz.tcs.uj.edu.pl/2019/data.html).", "description": "你拥有一家非常特别的书店，专门售卖旧书。但你将所有书籍随机排列在单一书架上，并不关心书籍的内容。你的客户也是如此——他们通常走进书店，直接要求“书架上从**这本**开始到**这本**结束的所有书”。准确地说，每位客户购买的是书架上某个连续（且非空）的书籍片段。\n\n不过，有时你会遇到更挑剔的客户，他们对书籍有更高的要求——实际上，他们希望书籍的尺寸合适。一位挑剔的客户希望书架上某个连续片段中的所有书籍高度均不小于 $ l $ 且不大于 $ h $。\n\n给定一个整数序列——书架上所有书籍的高度——请确定满足这些要求的连续片段数量。\n\n另外，我们提到书籍是**随机**排列的。形式上，输入序列由以下程序生成，其中 $ N \\in \\{1, 2, \\ldots, 100000\\} $ 且 $ M = 10^q $（$ q \\in \\{1, 2, \\ldots, 6\\} $）：\n\n```cpp\nsrand48(N + M);\nfor (int i = 0; i < N; ++i)\n    a[i] = 1 + lrand48() % M;\n```\n\n你实际上无需了解 RAND48 库的工作原理。只需假设函数 `lrand48` 返回均匀随机生成的 31 位非负整数即可。\n", "inputFormat": "\n**本题单个测试点内有多组测试数据。** \n\n输入的第一行包含测试数据数量 $ z $（$ 1 \\leq z \\leq 5 $）。每组测试数据的格式如下：\n\n- 测试数据的第一行包含书籍数量 $ n $ 和挑剔客户数量 $ k $（$ 1 \\leq n \\leq 200\\,000 $，$ 1 \\leq k \\leq 500\\,000 $）。\n- 第二行包含 $ n $ 个不超过 $1\\,000\\,000$ 的正整数——从左到右所有书籍的高度。\n- 接下来的 $ k $ 行描述客户的需求。第 $ i $ 行包含两个整数 $ l_i $ 和 $ h_i $（$ 1 \\leq l_i \\leq h_i \\leq 1\\,000\\,000 $），表示客户要求书籍高度不小于 $ l_i $ 且不大于 $ h_i $。\n\n所有测试数据中书籍总数不超过 $600\\,000$，客户总数不超过 $1\\,500\\,000$。\n", "outputFormat": "\n对于每位客户，输出满足其要求的非空连续书籍片段的数量。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[AMPPZ 2019] Bookstore", "background": "\n**Time limit: 7s, memory limit: 512MB.**", "description": "\n\nYou own a very peculiar bookstore, which sells old books, but you store all of them on a single shelf, in random order, and you do not care about the books’ content. Nor do your clients – they tend to come into the store and simply ask for “all the books on that shelf, starting from _this_ one and ending _here_”. To be precise, every client buys some connected (and non-empty) fragment of books from the shelf.\n\nSometimes, though, you get more picky clients, who expect more from a book – actually, they expect it to have the right size. A picky client wants a fragment of shelf in which all the books have their height not smaller than $ l $ and not greater than $ h $.\n\nGiven a sequence of integers – the heights of all the books on the shelf – determine the number of possible connected fragments which satisfy these requirements.\n\nAlso, we mentioned that the books are in _random_ order. Formally, the input sequence was generated with the following program, for some values of $ N \\in \\{1, 2, \\ldots, 100000\\} $ and $ M = 10^q $ with $ q \\in \\{1, 2, \\ldots, 6\\} $.\n\n```cpp\nsrand48(N + M);\nfor (int i = 0; i < N; ++i)\n    a[i] = 1 + lrand48() % M;\n```\n\nYou do not actually need to know how the RAND48 library works. It is enough to assume that the function `lrand48` returns 31-bit non-negative integers picked uniformly at random.\n", "inputFormat": "\n\nThe first line of input contains the number of test cases $ z $ ($ 1 \\leq z \\leq 5 $). The test cases follow, each one in the following format:\n\n- The first line of a test case contains the number of books $ n $ and the number of picky clients $ k $ ($ 1 \\leq n \\leq 200000 $, $ 1 \\leq k \\leq 500000 $).\n- The second line contains a sequence of $ n $ positive integers not exceeding 1 000 000 – the heights of all the books, from the first (leftmost) to the last (rightmost) one.\n- The final $ k $ lines describe the clients’ requirements. The $ i $-th of these lines contains two integers $ l_i, h_i $ ($ 1 \\leq l_i \\leq h_i \\leq 1000000 $), describing a client that wants books to be not smaller than $ l_i $ and not greater than $ h_i $.\n\nThe total number of books in all test cases does not exceed 600 000, and the total number of clients in all test cases does not exceed 1 500 000.\n", "outputFormat": "\nFor every client, output the number of non-empty connected fragments of the book sequence which satisfy the client’s requirements.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[AMPPZ 2019] Bookstore", "background": "Source: [AMPPZ 2019](https://amppz.tcs.uj.edu.pl/2019/data.html).", "description": "你拥有一家非常特别的书店，专门售卖旧书。但你将所有书籍随机排列在单一书架上，并不关心书籍的内容。你的客户也是如此——他们通常走进书店，直接要求“书架上从**这本**开始到**这本**结束的所有书”。准确地说，每位客户购买的是书架上某个连续（且非空）的书籍片段。\n\n不过，有时你会遇到更挑剔的客户，他们对书籍有更高的要求——实际上，他们希望书籍的尺寸合适。一位挑剔的客户希望书架上某个连续片段中的所有书籍高度均不小于 $ l $ 且不大于 $ h $。\n\n给定一个整数序列——书架上所有书籍的高度——请确定满足这些要求的连续片段数量。\n\n另外，我们提到书籍是**随机**排列的。形式上，输入序列由以下程序生成，其中 $ N \\in \\{1, 2, \\ldots, 100000\\} $ 且 $ M = 10^q $（$ q \\in \\{1, 2, \\ldots, 6\\} $）：\n\n```cpp\nsrand48(N + M);\nfor (int i = 0; i < N; ++i)\n    a[i] = 1 + lrand48() % M;\n```\n\n你实际上无需了解 RAND48 库的工作原理。只需假设函数 `lrand48` 返回均匀随机生成的 31 位非负整数即可。\n", "inputFormat": "\n**本题单个测试点内有多组测试数据。** \n\n输入的第一行包含测试数据数量 $ z $（$ 1 \\leq z \\leq 5 $）。每组测试数据的格式如下：\n\n- 测试数据的第一行包含书籍数量 $ n $ 和挑剔客户数量 $ k $（$ 1 \\leq n \\leq 200\\,000 $，$ 1 \\leq k \\leq 500\\,000 $）。\n- 第二行包含 $ n $ 个不超过 $1\\,000\\,000$ 的正整数——从左到右所有书籍的高度。\n- 接下来的 $ k $ 行描述客户的需求。第 $ i $ 行包含两个整数 $ l_i $ 和 $ h_i $（$ 1 \\leq l_i \\leq h_i \\leq 1\\,000\\,000 $），表示客户要求书籍高度不小于 $ l_i $ 且不大于 $ h_i $。\n\n所有测试数据中书籍总数不超过 $600\\,000$，客户总数不超过 $1\\,500\\,000$。\n", "outputFormat": "\n对于每位客户，输出满足其要求的非空连续书籍片段的数量。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12809", "type": "P", "difficulty": 0, "samples": [["2\n3\n10 10 10\n4\n1 2 3 4", "20\n7"]], "limits": {"time": [2000, 2000], "memory": [524288, 524288]}, "tags": ["2019", "ICPC"], "title": "[AMPPZ 2019] Cheese Game", "background": "Source: [AMPPZ 2019](https://amppz.tcs.uj.edu.pl/2019/data.html).", "description": "在参加了一年一度的**双人游戏与应用密码学研讨会**后，Alice 和 Bob 想通过玩他们最喜欢的游戏来放松。他们将 $n$ 片奶酪排成一排，编号从 $1$ 到 $n$。众所周知，尽管奶酪通常很美味，但某些切片可能比其他切片更美味——这就是为什么第 $i$ 片奶酪的美味度为 $o_i$。\n\nAlice 先开始游戏，两位玩家轮流行动。在每次行动中，玩家可以吃掉仍然留在棋盘上的任意一组奶酪切片，条件是这组切片中不能包含任何两片相邻的切片（即编号为 $i$ 和 $i+1$ 的切片，其中 $1 \\leq i \\leq n - 1$）。我们假设切片的编号不会改变，因此在游戏过程中不会出现新的相邻对。\n\n当然，两位玩家的目标都是最大化他们所吃奶酪切片的总美味度。  \n假设他们都采取最优策略，Alice 能够获得的最大分数是多少？\n", "inputFormat": "\n**本题单个测试点内有多组测试数据。**  \n输入的第一行包含测试数据数量 $z$（$1 \\leq z \\leq 20$）。每组测试数据的格式如下：\n\n- 测试数据的第一行包含奶酪切片数量 $n$（$1 \\leq n \\leq 100\\,000$）。\n- 第二行包含 $n$ 个整数 $o_1, o_2, \\dots, o_n$（$1 \\leq o_i \\leq 1\\,000\\,000$）——每片奶酪的美味度。\n", "outputFormat": "\n对于每组测试数据，输出一个整数——假设双方都采取最优策略时，Alice 所吃奶酪切片的总美味度。\n\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[AMPPZ 2019] Cheese Game", "background": "\n**Time limit: 2s, memory limit: 512MB.**\n", "description": "\nAfter taking part in the annual _Two-player Games and Applied Cryptography Symposium_, Alice and Bob want to relax by playing their favourite game. They have arranged $n$ cheese slices in a row, numbered from $1$ to $n$. As we all know, though cheese is tasty in general, some slices can be better than others – this is why the $i$-th slice is described by its deliciousness $o_i$.\n\nAlice starts the game and the players alternate their moves. In a move, a player may eat any set of cheese slices that are still left on the board, providing that the set contains no two neighbouring slices (i.e. numbered $i$ and $i+1$ for any $1 \\leq i \\leq n - 1$). We assume that the numbers of the slices do not change, so during the game no new neighbouring pairs appear.\n\nOf course, both players aim to maximize the total deliciousness of their eaten pieces.  \nAssuming that they both play optimally, what is the maximal score that Alice can achieve?\n", "inputFormat": "\nThe first line of input contains the number of test cases $z$ ($1 \\leq z \\leq 20$). The test cases follow, each one in the following format:\n\n- The first line of a test case contains the number of cheese slices $n$ ($1 \\leq n \\leq 100\\,000$).\n- The second line contains $n$ integers $o_1, o_2, \\dots, o_n$ ($1 \\leq o_i \\leq 1\\,000\\,000$) – the values of the pieces’ deliciousness.\n", "outputFormat": "\nFor every test case, output a single integer – the total deliciousness of the slices eaten by Alice, assuming that both players play optimally.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[AMPPZ 2019] Cheese Game", "background": "Source: [AMPPZ 2019](https://amppz.tcs.uj.edu.pl/2019/data.html).", "description": "在参加了一年一度的**双人游戏与应用密码学研讨会**后，Alice 和 Bob 想通过玩他们最喜欢的游戏来放松。他们将 $n$ 片奶酪排成一排，编号从 $1$ 到 $n$。众所周知，尽管奶酪通常很美味，但某些切片可能比其他切片更美味——这就是为什么第 $i$ 片奶酪的美味度为 $o_i$。\n\nAlice 先开始游戏，两位玩家轮流行动。在每次行动中，玩家可以吃掉仍然留在棋盘上的任意一组奶酪切片，条件是这组切片中不能包含任何两片相邻的切片（即编号为 $i$ 和 $i+1$ 的切片，其中 $1 \\leq i \\leq n - 1$）。我们假设切片的编号不会改变，因此在游戏过程中不会出现新的相邻对。\n\n当然，两位玩家的目标都是最大化他们所吃奶酪切片的总美味度。  \n假设他们都采取最优策略，Alice 能够获得的最大分数是多少？\n", "inputFormat": "\n**本题单个测试点内有多组测试数据。**  \n输入的第一行包含测试数据数量 $z$（$1 \\leq z \\leq 20$）。每组测试数据的格式如下：\n\n- 测试数据的第一行包含奶酪切片数量 $n$（$1 \\leq n \\leq 100\\,000$）。\n- 第二行包含 $n$ 个整数 $o_1, o_2, \\dots, o_n$（$1 \\leq o_i \\leq 1\\,000\\,000$）——每片奶酪的美味度。\n", "outputFormat": "\n对于每组测试数据，输出一个整数——假设双方都采取最优策略时，Alice 所吃奶酪切片的总美味度。\n\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12810", "type": "P", "difficulty": 0, "samples": [["1\n8\n0 1 0 3 0 1 1 0", "4\n00010000\n01000101\n10111010\n11101111"]], "limits": {"time": [25000], "memory": [524288]}, "tags": ["2019", "ICPC"], "title": "[AMPPZ 2019]  Henry Porter and the Palindromic Radius", "background": "Source: [AMPPZ 2019](https://amppz.tcs.uj.edu.pl/2019/data.html).", "description": "\n\n年轻的巫师 Henry Porter 刚刚收到一个悲伤的消息——他家族中最年长的长辈，Markus Radius Palindromus Black 叔叔去世了。Black 叔叔以性格古怪著称，擅长复杂的二进制魔法，同时也以极其富有闻名。  \n\nBlack 的遗嘱声明，Henry 将继承他神秘的宝藏密室。然而，要进入并认领宝藏，这位年轻巫师必须说出正确的密码 $H$——这是一个长度为 $n$、由字符 0 和 1 组成的单词。Black 叔叔并未直接告诉 Henry 密码（这显然不符合他的风格），而是为每个位置 $x = 1, 2, \\ldots, n$ 计算了**回文半径** $p_x$——最大的整数，使得以 $H[x]$ 为中心、长度为 $2p_x + 1$ 的子串 $H[x - p_x \\ldots x + p_x]$ 存在且为回文。Henry 只收到了这些值 $p_1, \\ldots, p_n$。例如，如果密码是 `10111010`，Henry 会得到序列 $(0, 1, 0, 3, 0, 1, 1, 0)$。  \n\nHenry 希望 Black 叔叔别在死后还要考验他的算法能力，但抱怨也无济于事。好在他有能帮忙的朋友！根据遗嘱中留下的序列，确定所有可能的对应密码。由于遗嘱破损且污迹斑斑，甚至可能根本无解。\n\n", "inputFormat": "\n**本题单个测试点内有多组测试数据。**  \n输入的第一行包含测试数据数量 $z$（$1 \\le z \\le 200\\,000$）。每组测试数据的格式如下：  \n\n每组测试数据包含两行。第一行包含一个整数 $n$——密码和 Black 序列的长度（$2 \\le n \\le 1\\,000\\,000$）。第二行包含 $n$ 个整数 $p_1, p_2, \\ldots, p_n$（$0 \\le p_i < n$）——密码中每个字符对应的回文半径。  \n所有测试数据的 $n$ 值总和不超过 $5 \\cdot 10^7$。  ", "outputFormat": "\n对于每组测试数据，首先输出可能密码的数量 $k$。  \n如果 $k > 0$，则在接下来的 $k$ 行中按**字典序**输出所有可能的 $\\{0, 1\\}$ 序列形式的解。  \n\n可以假设 $k$ 不超过 100。  ", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[AMPPZ 2019] Henry Porter and the Palindromic Radius", "background": "\n**Time limit: 25s, memory limit: 512MB.**\n", "description": "\nA young wizard, Henry Porter, has just received sad news – the eldest of his family, uncle Markus Radius Palindromus Black, passed away. Uncle Markus had a reputation of being a quite eccentric person, using complicated binary magic, and was also known to be very, very rich.\n\nBlack’s will states that Henry should inherit his mysterious chamber of treasures. To enter and claim it, however, the young wizard must say the right password $H$, which is a word of length $n$, consisting of characters 0 and 1. Uncle Markus did not tell Henry the password – it certainly wouldn’t be his style. Instead, he computed, for every $x = 1, 2, \\ldots, n$, the **palindromic radius** $p_x$ – the largest possible integer such that the word $H[x - p_x \\ldots x + p_x]$ of length $2p_x + 1$ centered at $H[x]$ exists and is a palindrome. Henry then only received the values $p_1, \\ldots, p_n$. For example, if the password was `10111010`, Henry would get the sequence $(0, 1, 0, 3, 0, 1, 1, 0)$.\n\nHenry would prefer Uncle Markus not to test his algorithmic skills while being dead, but, well, there is no one to complain. And he has good friends who can help him! Given the sequence left by Markus in his will, determine all possible passwords that correspond to it. As the will is battered and stained, it might even happen that there is no solution at all.", "inputFormat": "\nThe first line of input contains the number of test cases $z$ ($1 \\le z \\le 200\\ 000$). The test cases follow, each one in the following format:\n\nA test case consists of two lines. The first line contains a single integer $n$ – the length of both the password and Black’s sequence ($2 \\le n \\le 1\\ 000\\ 000$). The second line contains $n$ integers $p_1, p_2, \\ldots, p_n$ ($0 \\le p_i < n$) – the palindromic radii for all the characters in the password.  \nThe sum of $n$ values over all test cases does not exceed $5 \\cdot 10^7$.\n", "outputFormat": "\nFor every test case, output first the number $k$ of possible passwords.  \nIf $k > 0$, output in the next $k$ lines all the solutions as $\\{0, 1\\}$-sequences.  \nThe sequences must be given in **lexicographic order**.\n\nYou may assume that $k$ does not exceed 100.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[AMPPZ 2019]  Henry Porter and the Palindromic Radius", "background": "Source: [AMPPZ 2019](https://amppz.tcs.uj.edu.pl/2019/data.html).", "description": "\n\n年轻的巫师 Henry Porter 刚刚收到一个悲伤的消息——他家族中最年长的长辈，Markus Radius Palindromus Black 叔叔去世了。Black 叔叔以性格古怪著称，擅长复杂的二进制魔法，同时也以极其富有闻名。  \n\nBlack 的遗嘱声明，Henry 将继承他神秘的宝藏密室。然而，要进入并认领宝藏，这位年轻巫师必须说出正确的密码 $H$——这是一个长度为 $n$、由字符 0 和 1 组成的单词。Black 叔叔并未直接告诉 Henry 密码（这显然不符合他的风格），而是为每个位置 $x = 1, 2, \\ldots, n$ 计算了**回文半径** $p_x$——最大的整数，使得以 $H[x]$ 为中心、长度为 $2p_x + 1$ 的子串 $H[x - p_x \\ldots x + p_x]$ 存在且为回文。Henry 只收到了这些值 $p_1, \\ldots, p_n$。例如，如果密码是 `10111010`，Henry 会得到序列 $(0, 1, 0, 3, 0, 1, 1, 0)$。  \n\nHenry 希望 Black 叔叔别在死后还要考验他的算法能力，但抱怨也无济于事。好在他有能帮忙的朋友！根据遗嘱中留下的序列，确定所有可能的对应密码。由于遗嘱破损且污迹斑斑，甚至可能根本无解。\n\n", "inputFormat": "\n**本题单个测试点内有多组测试数据。**  \n输入的第一行包含测试数据数量 $z$（$1 \\le z \\le 200\\,000$）。每组测试数据的格式如下：  \n\n每组测试数据包含两行。第一行包含一个整数 $n$——密码和 Black 序列的长度（$2 \\le n \\le 1\\,000\\,000$）。第二行包含 $n$ 个整数 $p_1, p_2, \\ldots, p_n$（$0 \\le p_i < n$）——密码中每个字符对应的回文半径。  \n所有测试数据的 $n$ 值总和不超过 $5 \\cdot 10^7$。  ", "outputFormat": "\n对于每组测试数据，首先输出可能密码的数量 $k$。  \n如果 $k > 0$，则在接下来的 $k$ 行中按**字典序**输出所有可能的 $\\{0, 1\\}$ 序列形式的解。  \n\n可以假设 $k$ 不超过 100。  ", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12811", "type": "P", "difficulty": 0, "samples": [["2\n\n5\n0 0\n0 5\n3 7\n6 5\n6 0\n4\n1 2\n1 3\n5 2\n5 3\n3\n0 3\n1 4\n1 2\n\n4\n-1 -1\n-1 1\n2 1\n2 -1\n2\n0 0\n1 0\n6\n0 1\n0 2\n0 3\n1 2\n1 3\n2 3", "4 1 0\n0 1 0 0 0 0"]], "limits": {"time": [8000, 8000, 8000], "memory": [524288, 524288, 524288]}, "tags": ["2019", "ICPC"], "title": "[AMPPZ 2019] Antennas", "background": "Source: [AMPPZ 2019](https://amppz.tcs.uj.edu.pl/2019/data.html).", "description": "\n某秘密军事基地正在测试新型通信技术，基地内部建造了 $m$ 个天线。  \n\n从俯视图看，基地是一个凸多边形区域，其边界围墙既用于防范入侵者，也能阻挡无线电波外泄以免被外国间谍截获。  \n\n由于施工需要，基地必须拆除两段围墙。这将导致安全隐患：若两名间谍被安置在基地外，且某两个天线的连线经过这两名间谍所在位置，同时该连线未被剩余围墙阻挡，则间谍可能窃听这两个天线间的通信。  \n\n你的任务是为每种拆除两段围墙的场景，计算因此暴露的天线对数量（即连接该对天线的直线不再被任何围墙阻挡）。  \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/pm8reqsj.png)\n\n（上方图示对应样例输入的第一组数据，展示了一个五边形基地和四个天线的分布情况，图中标出了所有天线间的连线。）\n\n", "inputFormat": "**本题单个测试点内有多组测试数据。**  \n输入的第一行包含测试数据数量 $z$（$1 \\leq z \\leq 200\\,000$）。每组测试数据的格式如下：  \n\n每组测试数据以空行开始。  \n第一行包含一个整数 $n$（$3 \\leq n \\leq 10$）——多边形的顶点数。接下来 $n$ 行每行包含两个整数，按顺时针顺序给出各顶点的坐标。顶点依次编号为 $0, 1, \\ldots, n-1$。  \n\n下一行包含一个整数 $m$（$2 \\leq m \\leq 50\\,000$）——基地内的天线数量，随后 $m$ 行给出各天线的坐标。  \n\n接着一行包含整数 $q$（$1 \\leq q \\leq 10$）——需考虑的场景数量。最后 $q$ 行描述场景——第 $i$ 行包含两个整数 $a_i$, $b_i$（$0 \\leq a_i < b_i \\leq n-1$）。该组数字表示拆除顶点 $a_i$ 与 $a_i + 1$ 之间、以及 $b_i$ 与 $(b_i + 1) \\bmod n$ 之间的两段围墙，要求计算满足以下条件的天线对数量：连接该对天线的直线既不穿过被拆除的第一段围墙，也不穿过被拆除的第二段围墙。  \n\n所有坐标均为绝对值不超过 $10^9$ 的整数。单个测试数据中所有输入点互不相同且任意三点不共线。  \n所有测试数据的 $m$ 值总和不超过 $300\\,000$。  ", "outputFormat": "\n对于每个测试数据的每个场景，输出一行对应的答案。  \n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[AMPPZ 2019] Antennas", "background": "\n**Time limit: 8s, memory limit: 512MB.**\n", "description": "\nIn a secret military base, a new communication technology is being tested. For the experiment, $m$ antennas were constructed inside.\n\nThe terrain around the base is perfectly flat, and the base, seen from above, is a convex polygon. The boundary of the polygon is a wall that protects the base from intruders, as well as blocks the radio waves from leaving the base to be possibly intercepted by foreign agents.\n\nUnfortunately, some construction works are required in the facility, and two of the polygon’s walls must be torn down. This creates a security risk: if two spies are placed outside the base in such a way that two of the antennas lie on the line between them, and there is no wall blocking this line, then the spies may listen to the communication between those two antennas.\n\nYour goal is, for some possible scenarios of removal of two walls, to determine the number of  \npairs of antennas which are compromised in the way described above.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/pm8reqsj.png)\n\nThe picture above corresponds to the first case of the example input from the “Example” section. In this case, the base is a pentagon with four antennas, denoted by little crosses. All the lines between pairs of antennas are also shown.", "inputFormat": "\nThe first line of input contains the number of test cases $z$ ($1 \\leq z \\leq 200\\,000$). The test cases  \nfollow, each one in the following format:\n\nThe first line of a test case contains an integer $n$ ($3 \\leq n \\leq 10$) – the number of vertices of  \nthe polygon. The next $n$ lines contain two integers – the coordinates of the vertices, presented  \nclockwise. The vertices are numbered $0, 1, \\ldots, n-1$ in order in which they appear.\n\nThe next line contains an integer $m$ ($2 \\leq m \\leq 50\\,000$) – the number of antennas inside the  \nbase – and the $m$ following lines contain the coordinates of the antennas.\n\nThe next line contains another integer $q$ ($1 \\leq q \\leq 10$) – the number of scenarios to consider.  \nThe last $q$ lines describe scenarios – the $i$-th line contains two integers $a_i$, $b_i$ ($0 \\leq a_i < b_i \\leq n-1$).  \nSuch a pair denotes removing the walls $a_i$ and $b_i$ and requires to compute the number of distinct  \nlines that go through some two antennas and do not cross neither the segment between the vertices $a_i$ and $a_i + 1$ nor the segment between $b_i$ and $(b_i + 1) \\bmod n$.\n\nAll coordinates are integers whose absolute values do not exceed $10^9$. In any single testcase, all points of the input are distinct and no three of them are collinear.\n\nEvery test case, including the first, is preceded by a single empty line.\n\nThe sum of all $m$ values in all test cases does not exceed $300\\,000$.\n", "outputFormat": "\nFor every testcase output, in separate lines, the answers to all given scenarios.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[AMPPZ 2019] Antennas", "background": "Source: [AMPPZ 2019](https://amppz.tcs.uj.edu.pl/2019/data.html).", "description": "\n某秘密军事基地正在测试新型通信技术，基地内部建造了 $m$ 个天线。  \n\n从俯视图看，基地是一个凸多边形区域，其边界围墙既用于防范入侵者，也能阻挡无线电波外泄以免被外国间谍截获。  \n\n由于施工需要，基地必须拆除两段围墙。这将导致安全隐患：若两名间谍被安置在基地外，且某两个天线的连线经过这两名间谍所在位置，同时该连线未被剩余围墙阻挡，则间谍可能窃听这两个天线间的通信。  \n\n你的任务是为每种拆除两段围墙的场景，计算因此暴露的天线对数量（即连接该对天线的直线不再被任何围墙阻挡）。  \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/pm8reqsj.png)\n\n（上方图示对应样例输入的第一组数据，展示了一个五边形基地和四个天线的分布情况，图中标出了所有天线间的连线。）\n\n", "inputFormat": "**本题单个测试点内有多组测试数据。**  \n输入的第一行包含测试数据数量 $z$（$1 \\leq z \\leq 200\\,000$）。每组测试数据的格式如下：  \n\n每组测试数据以空行开始。  \n第一行包含一个整数 $n$（$3 \\leq n \\leq 10$）——多边形的顶点数。接下来 $n$ 行每行包含两个整数，按顺时针顺序给出各顶点的坐标。顶点依次编号为 $0, 1, \\ldots, n-1$。  \n\n下一行包含一个整数 $m$（$2 \\leq m \\leq 50\\,000$）——基地内的天线数量，随后 $m$ 行给出各天线的坐标。  \n\n接着一行包含整数 $q$（$1 \\leq q \\leq 10$）——需考虑的场景数量。最后 $q$ 行描述场景——第 $i$ 行包含两个整数 $a_i$, $b_i$（$0 \\leq a_i < b_i \\leq n-1$）。该组数字表示拆除顶点 $a_i$ 与 $a_i + 1$ 之间、以及 $b_i$ 与 $(b_i + 1) \\bmod n$ 之间的两段围墙，要求计算满足以下条件的天线对数量：连接该对天线的直线既不穿过被拆除的第一段围墙，也不穿过被拆除的第二段围墙。  \n\n所有坐标均为绝对值不超过 $10^9$ 的整数。单个测试数据中所有输入点互不相同且任意三点不共线。  \n所有测试数据的 $m$ 值总和不超过 $300\\,000$。  ", "outputFormat": "\n对于每个测试数据的每个场景，输出一行对应的答案。  \n", "hint": "", "locale": "zh-CN"}}}
