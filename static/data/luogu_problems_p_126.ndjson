{"pid": "P3552", "type": "P", "difficulty": 6, "samples": [["4 6\n0000 1011\n0110\n0111\n0011\n1101\n1010\n1001\n", "TAK\n"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "2013", "POI（波兰）", "哈希 hashing"], "title": "[POI 2013] SPA-Walk", "background": "", "description": "The names of towns in Byteotia are unique sequences of exactly $n$ bits.\n\nThere are $2^n-k$ towns in Byteotia, and thus,only $k$ sequences of $n$ bits do not correspond to any town.\n\nSome pairs of towns are connected with roads.\n\nSpecifically, two towns are directly linked by a road if and only if their names differ in a single bit.\n\nThe roads do not cross outside of towns.\n\nByteasar intends to take a stroll - he intends to walk from the town $x$ to the town $y$, taking the existing roads.\n\nYour task is to write a program that will determine if such a walk is possible.\n\n有2^n个长度为n的01串，两个01串之间有边当且仅当这两个01串只有一位不同，现在从这2n个串中拿掉k个，问指定两个串之间能否到达\n", "inputFormat": "In the first line of the standard input, there are two integers,$n$ and $k$($1\\le n\\le 60$, $0\\le k\\le 1\\ 000\\ 000$, $k\\le 2^n-1$, $n\\times k\\le 5\\ 000\\ 000$),      separated by a single space.\n\nThese are the length of town names in bits and the the number of $n$-bit sequences that do not correspond to any town, respectively.\n\nIn the second line, there are two strings, separated by a single space,      each consisting of $n$ characters 0 and/or 1.\n\nThese are the names of the towns $x$ and $y$.\n\nIn the $k$ lines that follow, all the sequences of $n$ bits that do not correspond to any town are given, one sequence per line.In the $k$ lines that follow, all the sequences of $n$ bits that do not correspond to any town are given, one sequence per line.Each such sequence is a string of $n$ characters 0 and/or 1.You may assume that $x$ and $y$ are not among those $k$ sequences.\n", "outputFormat": "Your program should print to the standard output the word TAK (Polish for yes) if walking from the town x to the town y is possible, and the word NIE (Polish for no) otherwise.\n", "hint": "有2^n个长度为n的01串，两个01串之间有边当且仅当这两个01串只有一位不同，现在从这2n个串中拿掉k个，问指定两个串之间能否到达\n", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2013] SPA-Walk", "background": "", "description": "The names of towns in Byteotia are unique sequences of exactly $n$ bits. There are $2^n-k$ towns in Byteotia, and thus, only $k$ sequences of $n$ bits do not correspond to any town.\n\nSome pairs of towns are connected by roads. Specifically, two towns are directly linked by a road if and only if their names differ in exactly one bit. The roads do not cross outside of towns.\n\nByteasar intends to take a stroll — he plans to walk from the town $x$ to the town $y$, taking the existing roads. Your task is to determine whether such a walk is possible.", "inputFormat": "The first line contains two integers $n$ and $k$ ($1 \\le n \\le 60$, $0 \\le k \\le 1\\ 000\\ 000$, $k \\le 2^n - 1$, $n \\times k \\le 5\\ 000\\ 000$), separated by a single space. These are the length of the town names in bits and the number of $n$-bit sequences that do not correspond to any town, respectively.\n\nThe second line contains two strings, separated by a single space, each consisting of $n$ characters 0 and/or 1. These are the names of the towns $x$ and $y$.\n\nEach of the next $k$ lines contains one sequence of $n$ bits that does not correspond to any town. You may assume that $x$ and $y$ are not among these $k$ sequences.", "outputFormat": "Print TAK if it is possible to walk from $x$ to $y$, and NIE otherwise.", "hint": "There are $2^n$ binary strings of length $n$. Two strings are connected by an edge if and only if they differ in exactly one bit. After removing $k$ of these $2^n$ strings, determine whether the two specified strings are reachable from each other.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2013] SPA-Walk", "background": "", "description": "The names of towns in Byteotia are unique sequences of exactly $n$ bits.\n\nThere are $2^n-k$ towns in Byteotia, and thus,only $k$ sequences of $n$ bits do not correspond to any town.\n\nSome pairs of towns are connected with roads.\n\nSpecifically, two towns are directly linked by a road if and only if their names differ in a single bit.\n\nThe roads do not cross outside of towns.\n\nByteasar intends to take a stroll - he intends to walk from the town $x$ to the town $y$, taking the existing roads.\n\nYour task is to write a program that will determine if such a walk is possible.\n\n有2^n个长度为n的01串，两个01串之间有边当且仅当这两个01串只有一位不同，现在从这2n个串中拿掉k个，问指定两个串之间能否到达\n", "inputFormat": "In the first line of the standard input, there are two integers,$n$ and $k$($1\\le n\\le 60$, $0\\le k\\le 1\\ 000\\ 000$, $k\\le 2^n-1$, $n\\times k\\le 5\\ 000\\ 000$),      separated by a single space.\n\nThese are the length of town names in bits and the the number of $n$-bit sequences that do not correspond to any town, respectively.\n\nIn the second line, there are two strings, separated by a single space,      each consisting of $n$ characters 0 and/or 1.\n\nThese are the names of the towns $x$ and $y$.\n\nIn the $k$ lines that follow, all the sequences of $n$ bits that do not correspond to any town are given, one sequence per line.In the $k$ lines that follow, all the sequences of $n$ bits that do not correspond to any town are given, one sequence per line.Each such sequence is a string of $n$ characters 0 and/or 1.You may assume that $x$ and $y$ are not among those $k$ sequences.\n", "outputFormat": "Your program should print to the standard output the word TAK (Polish for yes) if walking from the town x to the town y is possible, and the word NIE (Polish for no) otherwise.\n", "hint": "有2^n个长度为n的01串，两个01串之间有边当且仅当这两个01串只有一位不同，现在从这2n个串中拿掉k个，问指定两个串之间能否到达\n", "locale": "zh-CN"}}}
{"pid": "P3553", "type": "P", "difficulty": 6, "samples": [["2\n3 5\n1 1 1\n1 2 1\n2 3 1\n4 1 1\n4 2 1\n3 3\n3 3 0\n2 2 0\n1 1 0\n", "4\n3\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2013", "二分", "POI（波兰）", "构造"], "title": "INS-Inspector", "background": "", "description": "Inspector Byteasar is investigating a crime that took place on the premises of a software development company.\n\nHe is trying to establish the chain of events.\n\nUnfortunately, the programmers are rather scatterbrained.\n\nStatements of the kind \"Well, when I checked at 14:42,    there were five other programmers logged in on the server.\"    are the most informative of those that Byteasar could get.\n\nIt is known that every programmer came to office at some point    during that day, spent some time in there without going out,    and then left for good, never coming back on the same day.\n\nByteasar, confused by the programmers' statements, is not sure    if he should rely on them.  In fact, he is wondering whether it is at all    possible that they all tell the truth.  He asks you for help in finding    that out.", "inputFormat": "In the first line of the standard input, there is an integer $z$($1\\le z\\le 50$),      the number of data sets.\n\nThe lines that follow contain the $z$ data sets.\n\nThe first line of each data set holds two integers, $n$ and $m$,separated by a single space ($1\\le n,m\\le 100\\ 000$).\n\nThese are the number of programmers working in the office and the      number of statements recorded by Byteasar.\n\nThe programmers are numbered from 1 to $n$.\n\nEach of the $m$ lines that follow describes a single statement.\n\nEach such line contains three integers $t$,$j$ and $i$, separated by single spaces ($1\\le t\\le m$,$1\\le j\\le n$,$0\\le i\\le n$). These indicate that the programmer no. $j$ confessed that at time $t$ he was in the office and there were $i$ more programmers apart from him.We assume that the programmers came in to the office and left it at times different from those appearing in the statements, i.e., either before, after or in between them.", "outputFormat": "For each data set, your program should print a single positive integer      to the standard output.\n\nPrinting out the number $k$ ($1\\le k\\le m$) indicates that the first $k$ statements given on the input can be true but the first $k+1$ statements cannot.  In particular, if $k=m$, then all the statements given as input can be true.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "INS-Inspector", "background": "", "description": "Inspector Byteasar is investigating a crime that took place on the premises of a software development company.\n\nHe is trying to establish the chain of events.\n\nUnfortunately, the programmers are rather scatterbrained.\n\nStatements of the kind \"Well, when I checked at 14:42,    there were five other programmers logged in on the server.\"    are the most informative of those that Byteasar could get.\n\nIt is known that every programmer came to office at some point    during that day, spent some time in there without going out,    and then left for good, never coming back on the same day.\n\nByteasar, confused by the programmers' statements, is not sure    if he should rely on them.  In fact, he is wondering whether it is at all    possible that they all tell the truth.  He asks you for help in finding    that out.", "inputFormat": "In the first line of the standard input, there is an integer $z$($1\\le z\\le 50$),      the number of data sets.\n\nThe lines that follow contain the $z$ data sets.\n\nThe first line of each data set holds two integers, $n$ and $m$,separated by a single space ($1\\le n,m\\le 100\\ 000$).\n\nThese are the number of programmers working in the office and the      number of statements recorded by Byteasar.\n\nThe programmers are numbered from 1 to $n$.\n\nEach of the $m$ lines that follow describes a single statement.\n\nEach such line contains three integers $t$,$j$ and $i$, separated by single spaces ($1\\le t\\le m$,$1\\le j\\le n$,$0\\le i\\le n$). These indicate that the programmer no. $j$ confessed that at time $t$ he was in the office and there were $i$ more programmers apart from him.We assume that the programmers came in to the office and left it at times different from those appearing in the statements, i.e., either before, after or in between them.", "outputFormat": "For each data set, your program should print a single positive integer      to the standard output.\n\nPrinting out the number $k$ ($1\\le k\\le m$) indicates that the first $k$ statements given on the input can be true but the first $k+1$ statements cannot.  In particular, if $k=m$, then all the statements given as input can be true.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2013] INS-Inspector", "background": null, "description": "一天公司有 $n$ 个员工和 $m$ 个员工记录，每个员工只会在连续的一段时间内工作。现在给出 $m$ 条记录，表示某个时刻某个人在工作以及除他之外还有多少人在工作。求最大的 $k$ 使得前 $k$ 条记录互不矛盾。", "inputFormat": "第一行一个整数 $T(1 \\le T \\le 50)$，表示一个测试点有 $T$ 组测试数据。\n\n接下来的每组测试数据的第一行包含两个由空格分隔的整数 $ n,m(1 \\le n, m \\le 10^5)$，分别表示员工数量和员工记录数量。接下来的 $m$ 行中，每一行包含三个由空格分隔的整数 $t,j,i(1 \\le t \\le m，1 \\le j \\le n,0 \\le i \\le n )$。表示在时间为 $t$ 时，编号为 $j$ 的员工在办公室里工作并且除了他以外还有 $i$ 个员工在那里。", "outputFormat": "输出共 $T$ 行。对于每一个测试数据，输出最大的 $k$ 使得前 $k$ 条记录互不矛盾。两个答案之间用换行隔开。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3554", "type": "P", "difficulty": 5, "samples": [["7\n1 2\n1 3\n2 5\n2 6\n7 2\n4 1\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2013", "二分", "POI（波兰）", "树形 DP"], "title": "[POI 2013] LUK-Triumphal arch", "background": null, "description": "给一颗 $n$ 个节点的树，初始时 $1$ 号节点被染黑，其余是白的。两个人轮流操作，一开始 B 在 $1$ 号节点。每一轮，A 选择 $k$ 个点染黑，然后 B 走到一个相邻节点，如果 B 当前处于白点则 B 胜，否则当 A 将所有点染为黑点时 A 胜。求能让 A 获胜的最小的 $k$。", "inputFormat": "第一行读入一个整数 $n$，表示树的节点数\n\n接下来 $n-1$ 行，每行读入两个用空格分隔的整数 $u,v$，表示 $u$、$v$ 之间有一条边。", "outputFormat": "输出仅有一行，表示让 A 获胜的最小的 $k$。", "hint": "$n \\le 3 \\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2013] LUK-Triumphal arch", "background": null, "description": "The king of Byteotia, Byteasar, is returning to his country after a victorious battle.\n\nIn Byteotia, there are $n$ towns connected with only $n-1$ roads.\n\nIt is known that every town can be reached from every other town by a unique route, consisting of one or more (direct) roads.\n\n(In other words, the road network forms a tree).\n\nThe king has just entered the capital.\n\nTherein a triumphal arch, i.e., a gate a victorious king rides through, has been erected.\n\nByteasar, delighted by a warm welcome by his subjects, has planned a triumphal procession to visit all the towns of Byteotia, starting with the capital he is currently in.\n\nThe other towns are not ready to greet their king just yet - the constructions of the triumphal arches in those towns did not even begin!\n\nBut Byteasar's trusted advisor is seeing to the issue.\n\nHe desires to hire a number of construction crews.\n\nEvery crew can construct a single arch each day, in any town.\n\nUnfortunately, no one knows the order in which the king will visit the towns.\n\nThe only thing that is clear is that every day the king will travel from the city he is currently in to a neighboring one.\n\nThe king may visit any town an arbitrary number of times (but as he is not vain, one arch in each town will suffice).\n\nByteasar's advisor has to pay each crew the same flat fee, regardless of how many arches this crew builds.\n\nThus, while he needs to ensure that every town has an arch when it is visited by the king, he wants to hire as few crews as possible.\n\nHelp him out by writing a program that will determine the minimum number of crews that allow a timely delivery of the arches.", "inputFormat": "The first line of the standard input contains a single integer $n$ ($n\\le 300000$), the number of towns in Byteotia.\n\nThe towns are numbered from $1$ to $n$, where the number $1$ corresponds to the capital.\n\nThe road network is described in $n-1$ lines that then follow.\n\nEach of those lines contains two integers, $a,b$ ($1\\le a,b\\le n$), separated by a single space, indicating that towns $a$ and $b$ are directly connected with a two way road.\n\nIn tests worth $50\\%$ of the total points, an additional condition $n\\le 10000$ holds.", "outputFormat": "The first and only line of the standard output is to hold a single integer, the minimum number of crews that Byteasar's advisor needs to hire.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[POI 2013] LUK-Triumphal arch", "background": null, "description": "给一颗 $n$ 个节点的树，初始时 $1$ 号节点被染黑，其余是白的。两个人轮流操作，一开始 B 在 $1$ 号节点。每一轮，A 选择 $k$ 个点染黑，然后 B 走到一个相邻节点，如果 B 当前处于白点则 B 胜，否则当 A 将所有点染为黑点时 A 胜。求能让 A 获胜的最小的 $k$。", "inputFormat": "第一行读入一个整数 $n$，表示树的节点数\n\n接下来 $n-1$ 行，每行读入两个用空格分隔的整数 $u,v$，表示 $u$、$v$ 之间有一条边。", "outputFormat": "输出仅有一行，表示让 A 获胜的最小的 $k$。", "hint": "$n \\le 3 \\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P3556", "type": "P", "difficulty": 5, "samples": [["8 7 4\n1 2\n2 3\n3 4\n5 6\n6 7\n7 8\n8 5\n2 3 1\n1 4 1\n5 5 8\n1 8 10\n", "TAK\nNIE\nTAK\nNIE\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "2013", "POI（波兰）"], "title": "[POI 2013] MOR-Tales of seafaring", "background": "", "description": "Young Bytensson loves to hang out in the port tavern, where he often    listens to the sea dogs telling their tales of seafaring.\n\nInitially, he believed them all, however incredible they sounded.\n\nOver time though, he became suspicious.\n\nHe has decided to write a program that will verify if there may be    any grain of truth in those tall stories.\n\nBytensson reasoned that while he cannot tell if the sailors indeed    weathered all those storms, he can at least find out if their travel    itineraries make sense.\n\nThis is a task for a programmer, which Bytensson, unfortunately, is not.\n\nHelp him out!\n\nThere are $n$ ports and $m$ waterways connecting them in the waters    frequented by the sailors Bytensson listened to.\n\nIf there is a waterway between two ports, then sailing from one to the    other is possible.  Any waterway can be sailed in both    directions.\n\nBytensson got to know $k$ seafaring tales.\n\nEach tells of a sailor who began his journey in one port,    sailed a number of waterways, and ended up in another port,    which may have been the one he initially set sail from.\n\nThe sailor in question may have sailed through the same waterway    many times, each time in any direction.", "inputFormat": "In the first line of the standard input, there are three integers, $n$,$m$ and $k$ ($2\\le n\\le 5\\ 000$, $1\\le m\\le 5\\ 000$, $1\\le k\\le 1\\ 000\\ 000$).\n\nThese denote, respectively: the number of ports in the waters      frequented by the sailors who told Bytensson their stories,the number of waterways, and the number of tales.\n\nThe $m$ lines that follow specify the waterways.\n\nA single waterway's description consists of a single line that contains two integers, $a$ and $b$ ($1\\le a,b\\le n$,$a\\ne b$), separated by a single space; these specify the numbers of ports at the two ends of this particular waterway.\n\nThe $k$ lines that follow specify the tales that Bytensson has heard. A single tale's description consists of a single line with three integers,$s$,$t$,and $d$ ($1\\le s,t\\le n$,$1\\le d\\le 1\\ 000\\ 000\\ 000$ ), separated by single spaces. These indicate that the tale's protagonist set sail from port no. $s$ , ended the journey in port no. $t$ , and sailed exactly $d$ times through various waterways.", "outputFormat": "Your program should print exactly $k$ lines to the standard output; the $i$-th of them should contain the word TAK (Polish for yes) if the journey described in the $i$-th tale(in input order) could have taken place.\n\nIf it could not, then the line should contain the word NIE (Polish for no).", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2013] MOR-Tales of seafaring", "background": "", "description": "Young Bytensson loves to hang out in the port tavern, where he often    listens to the sea dogs telling their tales of seafaring.\n\nInitially, he believed them all, however incredible they sounded.\n\nOver time though, he became suspicious.\n\nHe has decided to write a program that will verify if there may be    any grain of truth in those tall stories.\n\nBytensson reasoned that while he cannot tell if the sailors indeed    weathered all those storms, he can at least find out if their travel    itineraries make sense.\n\nThis is a task for a programmer, which Bytensson, unfortunately, is not.\n\nHelp him out!\n\nThere are $n$ ports and $m$ waterways connecting them in the waters    frequented by the sailors Bytensson listened to.\n\nIf there is a waterway between two ports, then sailing from one to the    other is possible.  Any waterway can be sailed in both    directions.\n\nBytensson got to know $k$ seafaring tales.\n\nEach tells of a sailor who began his journey in one port,    sailed a number of waterways, and ended up in another port,    which may have been the one he initially set sail from.\n\nThe sailor in question may have sailed through the same waterway    many times, each time in any direction.", "inputFormat": "In the first line of the standard input, there are three integers, $n$,$m$ and $k$ ($2\\le n\\le 5\\ 000$, $1\\le m\\le 5\\ 000$, $1\\le k\\le 1\\ 000\\ 000$).\n\nThese denote, respectively: the number of ports in the waters      frequented by the sailors who told Bytensson their stories,the number of waterways, and the number of tales.\n\nThe $m$ lines that follow specify the waterways.\n\nA single waterway's description consists of a single line that contains two integers, $a$ and $b$ ($1\\le a,b\\le n$,$a\\ne b$), separated by a single space; these specify the numbers of ports at the two ends of this particular waterway.\n\nThe $k$ lines that follow specify the tales that Bytensson has heard. A single tale's description consists of a single line with three integers,$s$,$t$,and $d$ ($1\\le s,t\\le n$,$1\\le d\\le 1\\ 000\\ 000\\ 000$ ), separated by single spaces. These indicate that the tale's protagonist set sail from port no. $s$ , ended the journey in port no. $t$ , and sailed exactly $d$ times through various waterways.", "outputFormat": "Your program should print exactly $k$ lines to the standard output; the $i$-th of them should contain the word TAK (Polish for yes) if the journey described in the $i$-th tale(in input order) could have taken place.\n\nIf it could not, then the line should contain the word NIE (Polish for no).", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2013] MOR-Tales of seafaring", "background": "", "description": "年轻的你喜欢在港口酒馆闲逛，经常听海员们讲述他们的航海故事。\n\n起初，你对所有故事都深信不疑，无论听起来多么不可思议。\n\n但随着时间的推移，你开始产生怀疑。\n\n你决定编写一个程序来验证这些夸张的故事是否可能有一丝真实性。\n\n你认为，虽然你无法判断水手们是否真的经历过那些风暴，但至少可以检查他们的航行路线是否合理。\n\n这不是你能完成的任务，因为你不是程序员，但你还是要完成！\n\n在你所听说的海域中，有 $n$ 个港口和 $m$ 条连接它们的水道。\n\n如果两个港口之间有水道，则可以双向航行。\n\n你收集了 $k$ 个航海故事。每个故事讲述了一名水手从某个港口出发，经过若干水道航行后，到达另一个港口（可能与出发港相同）。水手可能多次航行通过同一水道，每次方向不限。\n", "inputFormat": "第一行三个整数 $n,m,k（2≤n≤5000，1≤m≤5000，1≤k≤1000000）$，分别表示港口数量、水道数量和故事数量。\n\n接下来 $m$ 行描述水道，每行两个整数 $a,b（1≤a,b≤n，a≠b）$，表示水道连接的两个港口。\n\n接下来 $k$ 行描述故事，每行三个整数 $s,t,d（1≤s,t≤n，1≤d≤1000000000）$，表示水手从港口 $s$ 出发，经过 $d$ 次航行后到达港口 $t$。", "outputFormat": "输出 $k$ 行，对每个故事，如果可能则输出 `TAK`（波兰语的\"是\"），否则输出 `NIE`（波兰语的\"否\"）。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3557", "type": "P", "difficulty": 4, "samples": [["9 8 3\n1 2\n2 3\n3 4\n1 4\n3 5\n4 6\n7 8\n8 9\n", "3\n1 5 7 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2013", "POI（波兰）", "Special Judge", "构造"], "title": "[POI 2013] GRA-Tower Defense Game", "background": null, "description": "Bytie 正在玩一款电脑游戏 Tower Defense。\n\n他的目标是建造守卫塔楼，以保护他的整个领地。\n\n在 Bytie 的领地中有多个城镇，其中一些城镇通过双向道路相连。\n\n如果 Bytie 在一个城市建造了守卫塔楼，那么这座塔楼将保护它所在的城市以及所有通过道路直接与之相连的城市。\n\n正当 Bytie 在思考如何在他的领地上布置守卫塔楼时，他的姐姐 Bytea 走进了房间。她瞥了一眼屏幕上显示的地图，片刻之后大声说道：\n\n“嗨，这有什么好想的，显然 $k$ 座塔就足够了！”\n\n被姐姐破坏了游戏乐趣所激怒，Bytie 把姐姐请出了门，然后开始思考接下来该怎么办。\n\n他的自尊心不允许他建造超过 $k$ 座塔楼。\n\n不过，他自有妙计：\n\n他可以研发一项技术，使他能够建造升级版守卫塔楼。\n\n一座升级版守卫塔楼不仅能保护它所在的城镇及其直接相邻的城镇，还能保护更远距离的城镇。\n\n具体来说，如果满足以下任一条件，则建在城镇 $u$ 的升级版守卫塔楼将保护城镇 $v$：\n\n- $u = v$；\n\n- 存在一条从 $u$ 直接通往 $v$ 的道路；\n\n- 或者存在一个城镇 $w$，使得存在从 $u$ 到 $w$ 的直接道路和从 $w$ 到 $v$ 的直接道路。\n\n当然，Bytie 仍然努力最多只建造 $k$ 座塔楼，但他现在对这些塔楼是升级版守卫塔楼毫无顾虑。", "inputFormat": "标准输入的第一行包含三个整数 $n$、$m$ 和 $k$（$2\\le n\\le 500\\ 000$，$0\\le m\\le 1\\ 000\\ 000$，$1\\le k\\le n$），它们以单个空格分隔，分别表示 Bytie 领地中的城镇数量、道路数量，以及 Bytea 给定的数值 $k$。\n\nBytie 领地中的城镇编号为 1 至 $n$。\n\n接下来是 $m$ 行道路描述。\n\n每行包含两个整数 $a_i$ 和 $b_i$（$1\\le a_i,b_i\\le n$，$a_i \\ne b_i$），表示编号为 $a_i$ 和 $b_i$ 的城镇间存在双向道路直接相连。任意两座城镇之间至多由一条道路连接。", "outputFormat": "你的程序需要向标准输出打印两行内容，描述升级版守卫塔楼在 Bytie 领地中的部署方案：\n\n第一行输出整数 $r$（$1\\le r\\le k$），表示 Bytie 应建造的升级版守卫塔楼数量。\n\n第二行通过提供 $r$ 个两两不同的整数来指定塔楼部署位置，这些整数即建造升级版守卫塔楼的城镇编号。\n\n城镇编号可以按任意顺序输出。\n\n若存在多种可行方案，输出任意一种即可。\n\n需特别说明：任意不超过 $k$ 座升级版塔楼的部署方案均可接受——你无需最小化塔楼数量。\n\n你可以默认 Bytea 的判断是正确的，即 Bytie 的整个领地确实能被 $k$ 座普通（非升级版）守卫塔楼保护。因此本题始终存在可行解。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[POI 2013] GRA-Tower Defense Game", "background": null, "description": "Bytie is playing the computer game Tower Defense.\n\nHis aim is to construct guard towers, so that they protect all of his domain.\n\nThere are multiple towns in Bytie's domain, some of which are linked by  bidirectional roads.\n\nIf Bytie erects a guard tower in a city, then the tower protects its city and  all the cities directly linked with it by roads.\n\nJust as Bytie was pondering over the placement of guard towers in his domain,  his elder sister Bytea entered the room.  She glanced at the map displayed on  the screen, and after a moment exclaimed:\n\n\"Oi, what is there to think about, clearly $k$ towers suffice!\".\n\nAngered by his sister spoiling the fun, Bytie showed his sister the door,  and began wondering what to do next.\n\nPride will not let him construct more than $k$ towers.\n\nHe has an up his sleeve though:\n\nhe can research a technology that will allow him to construct improved guard towers.\n\nAn improved guard tower protects not only the town it was erected in and its  immediate neighbors but also the towns that are further away.\n\nFormally, an improved guard tower built in the town $u$ protects the town $v$ if either of the following holds:\n\n- $u=v$;\n\n- there is a direct road from $u$ to $v$;\n\n- or there is such a town $w$ that there are direct roads from $u$ to $w$ and from $w$ to $v$.\n\nOf course, Bytie still strives to erect at most $k$ towers,  but he has no qualms about making these the improved guard towers.", "inputFormat": "In the first line of the standard input, there are three integers,  $n$, $m$, and $k$ ($2\\le n\\le 500\\ 000$,  $0\\le m\\le 1\\ 000\\ 000$, $1\\le k\\le n$), separated by single spaces,  that specify, respectively, the number of towns and roads in Bytie's domain,  and the number $k$ given by Bytea.\n\nThe towns in Bytie's domain are numbered from 1 to $n$.\n\nNext,$m$ lines describing the roads follow.\n\nEach of those lines holds two integers, $a_i$ and $b_i$ ($1\\le a_i,b_i\\le n$,$a_i\\ne b_i$), indicating that the towns no. $a_i$ and $b_i$ are directly linked by a bidirectional road. Each pair of towns is linked by at most a single road.", "outputFormat": "Your program is to print two lines, describing the placement of improved  guard towers in Bytie's domain, to the standard output.\n\nThe first line is to hold an integer $r$ ($1\\le r\\le k$), the number of  improved guard towers that Bytie should construct.\n\nThe second line is to specify the placement of these by providing $r$ pairwise disjoint integers that are the numbers of town where the improved  guard towers are to be built.\n\nThe town numbers can be given in an arbitrary order.\n\nIf more than one solution exists, any solution can be printed.\n\nLet us remind that any placement of no more than $k$ improved towers will do  - you need not minimize their number.\n\nYou may assume that Bytea was correct, i.e., that the whole domain of Bytie  can indeed be protected by $k$ plain (not improved) guard towers. Thus a solution always exists.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[POI 2013] GRA-Tower Defense Game", "background": null, "description": "Bytie 正在玩一款电脑游戏 Tower Defense。\n\n他的目标是建造守卫塔楼，以保护他的整个领地。\n\n在 Bytie 的领地中有多个城镇，其中一些城镇通过双向道路相连。\n\n如果 Bytie 在一个城市建造了守卫塔楼，那么这座塔楼将保护它所在的城市以及所有通过道路直接与之相连的城市。\n\n正当 Bytie 在思考如何在他的领地上布置守卫塔楼时，他的姐姐 Bytea 走进了房间。她瞥了一眼屏幕上显示的地图，片刻之后大声说道：\n\n“嗨，这有什么好想的，显然 $k$ 座塔就足够了！”\n\n被姐姐破坏了游戏乐趣所激怒，Bytie 把姐姐请出了门，然后开始思考接下来该怎么办。\n\n他的自尊心不允许他建造超过 $k$ 座塔楼。\n\n不过，他自有妙计：\n\n他可以研发一项技术，使他能够建造升级版守卫塔楼。\n\n一座升级版守卫塔楼不仅能保护它所在的城镇及其直接相邻的城镇，还能保护更远距离的城镇。\n\n具体来说，如果满足以下任一条件，则建在城镇 $u$ 的升级版守卫塔楼将保护城镇 $v$：\n\n- $u = v$；\n\n- 存在一条从 $u$ 直接通往 $v$ 的道路；\n\n- 或者存在一个城镇 $w$，使得存在从 $u$ 到 $w$ 的直接道路和从 $w$ 到 $v$ 的直接道路。\n\n当然，Bytie 仍然努力最多只建造 $k$ 座塔楼，但他现在对这些塔楼是升级版守卫塔楼毫无顾虑。", "inputFormat": "标准输入的第一行包含三个整数 $n$、$m$ 和 $k$（$2\\le n\\le 500\\ 000$，$0\\le m\\le 1\\ 000\\ 000$，$1\\le k\\le n$），它们以单个空格分隔，分别表示 Bytie 领地中的城镇数量、道路数量，以及 Bytea 给定的数值 $k$。\n\nBytie 领地中的城镇编号为 1 至 $n$。\n\n接下来是 $m$ 行道路描述。\n\n每行包含两个整数 $a_i$ 和 $b_i$（$1\\le a_i,b_i\\le n$，$a_i \\ne b_i$），表示编号为 $a_i$ 和 $b_i$ 的城镇间存在双向道路直接相连。任意两座城镇之间至多由一条道路连接。", "outputFormat": "你的程序需要向标准输出打印两行内容，描述升级版守卫塔楼在 Bytie 领地中的部署方案：\n\n第一行输出整数 $r$（$1\\le r\\le k$），表示 Bytie 应建造的升级版守卫塔楼数量。\n\n第二行通过提供 $r$ 个两两不同的整数来指定塔楼部署位置，这些整数即建造升级版守卫塔楼的城镇编号。\n\n城镇编号可以按任意顺序输出。\n\n若存在多种可行方案，输出任意一种即可。\n\n需特别说明：任意不超过 $k$ 座升级版塔楼的部署方案均可接受——你无需最小化塔楼数量。\n\n你可以默认 Bytea 的判断是正确的，即 Bytie 的整个领地确实能被 $k$ 座普通（非升级版）守卫塔楼保护。因此本题始终存在可行解。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3558", "type": "P", "difficulty": 4, "samples": [["6\n-1 1 0 -1 0 1\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2013", "POI（波兰）"], "title": "[POI 2013] BAJ-Bytecomputer", "background": "", "description": "A sequence of $n$ integers $x_1,x_2,\\cdots,x_n$ from the set $\\{-1, 0, 1\\}$ is given. The bytecomputer is a device that allows the following operation on the sequence: incrementing $x_{i + 1}$ by $x_i$ for any $1\\leq i\\leq n$. There is no limit on the range of integers the bytecomputer can store, i.e., each $x_i$ can (in principle) have arbitrarily small or large value.\n\nProgram the bytecomputer so that it transforms the input sequence into a non - decreasing sequence (i.e., such that $x_1\\leq x_2\\leq\\cdots\\leq x_n$) with the minimum number of operations.", "inputFormat": "The first line of the standard input holds a single integer $n$ ($1\\leq n\\leq1000000$), the number of elements in the (bytecomputer's) input sequence.\n\nThe second line contains $n$ integers $x_1,x_2,\\cdots,x_n$ ($x_i\\in\\{-1, 0, 1\\}$) that are the successive elements of the (bytecomputer's) input sequence, separated by single spaces.\n\nIn tests worth 24% of the total points it holds that $n\\leq500$, and in tests worth 48% of the total points it holds that $n\\leq10000$.", "outputFormat": "The first and only line of the standard output should give one integer, the minimum number of operations the bytecomputer has to perform to make its input sequence non - decreasing, or the single word BRAK (Polish for *none*) if obtaining such a sequence is impossible. ", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2013] BAJ-Bytecomputer", "background": "", "description": "A sequence of $n$ integers $x_1,x_2,\\cdots,x_n$ from the set $\\{-1, 0, 1\\}$ is given. The bytecomputer is a device that allows the following operation on the sequence: incrementing $x_{i + 1}$ by $x_i$ for any $1\\leq i\\leq n$. There is no limit on the range of integers the bytecomputer can store, i.e., each $x_i$ can (in principle) have arbitrarily small or large value.\n\nProgram the bytecomputer so that it transforms the input sequence into a non - decreasing sequence (i.e., such that $x_1\\leq x_2\\leq\\cdots\\leq x_n$) with the minimum number of operations.", "inputFormat": "The first line of the standard input holds a single integer $n$ ($1\\leq n\\leq1000000$), the number of elements in the (bytecomputer's) input sequence.\n\nThe second line contains $n$ integers $x_1,x_2,\\cdots,x_n$ ($x_i\\in\\{-1, 0, 1\\}$) that are the successive elements of the (bytecomputer's) input sequence, separated by single spaces.\n\nIn tests worth 24% of the total points it holds that $n\\leq500$, and in tests worth 48% of the total points it holds that $n\\leq10000$.", "outputFormat": "The first and only line of the standard output should give one integer, the minimum number of operations the bytecomputer has to perform to make its input sequence non - decreasing, or the single word BRAK (Polish for *none*) if obtaining such a sequence is impossible. ", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2013] BAJ-Bytecomputer", "background": null, "description": "给定一个由集合 $\\{-1, 0, 1\\}$ 中的 $n$ 个整数 $x_1, x_2, \\cdots, x_n$ 组成的序列。字节计算机是一种允许对序列进行以下操作的设备：对于任何 $1 \\leq i < n$，可以将 $x_{i+1}$ 改为 $x_{i+1} + x_i$。字节计算机可以存储的整数范围没有限制，即每个 $x_i$ 可以（原则上）具有任意小或大的值。\n\n编程实现字节计算机，使其将输入序列转换为非递减序列（即 $x_1 \\leq x_2 \\leq \\cdots \\leq x_n$），并使操作次数最少。", "inputFormat": "标准输入的第一行包含一个整数 $n$ ($1 \\leq n \\leq 1000000$)，表示（字节计算机的）输入序列中的元素个数。\n\n第二行包含 $n$ 个整数 $x_1, x_2, \\cdots, x_n$ ($x_i \\in \\{-1, 0, 1\\}$)，它们是（字节计算机的）输入序列的连续元素，元素之间用单个空格分隔。\n\n在占总分 24% 的测试中，$n \\leq 500$；在占总分 48% 的测试中，$n \\leq 10000$。", "outputFormat": "标准输出的第一行应输出一个整数，即字节计算机必须执行的最小操作次数，以使其输入序列成为非递减序列；如果无法获得这样的序列，则输出单词 BRAK（波兰语，意为“无”）。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3559", "type": "P", "difficulty": 7, "samples": [["LLLLPPLL\n", "0 0\n2 0\n2 2\n-1 2\n-1 -2\n1 -2\n1 -1\n0 -1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["计算几何", "2013", "POI（波兰）", "Special Judge"], "title": "[POI 2013] LAB-Maze", "background": null, "description": "注意：在比赛期间，你可以询问关于此问题任意三个提交的得分情况。\n\n拜特萨最近读了一个有趣的故事。\n\n故事的主人公是一位希腊王子，他用一根毛线击败了怪物，或诸如此类的情节。\n\n但故事中另一点让拜特萨着迷的是：高潮部分发生在一个迷宫中。\n\n从那时起，拜特萨就对迷宫产生了浓厚的兴趣。\n\n拜特萨在方格纸上绘制迷宫草图。\n\n每个草图是一个多边形（代表迷宫的墙壁），其边平行于纸张的边缘（即笛卡尔坐标系的坐标轴），且每两条相邻边相互垂直。\n\n拜特萨发现，如果将入口放置在迷宫的某条边（**不能是顶点**）上，那么通过始终将右手放在墙上行走，可以遍历整个迷宫并返回入口。\n\n此外，在迷宫遍历过程中，我们可以记录所采取的转弯方向。\n\n当从一面墙移动到另一面墙时，如果左转，我们记下字母 `L`；如果右转，则记下字母 `P`。\n\n拜特萨想知道，对于给定的由字母 `L` 和 `P` 组成的字符串，是否存在一个迷宫，其遍历过程恰好生成该字符串，如果是，则输出这个迷宫。", "inputFormat": "标准输入的第一行给出一个由字母 `L` 和 `P` 组成的字符串 $S$（$1 \\leq |S| \\leq 10^5$），描述了在迷宫遍历过程中连续转弯的序列。\n\n在占总分 $50\\%$ 的测试用例中，额外满足约束 $|S| \\leq 1000$。", "outputFormat": "如果没有迷宫与输入的描述相对应，则在标准输出上打印单词 `NIE`（波兰语中的“否”）。\n\n否则，应恰好输出 $|S|$ 行，指定任意一个与输入一致的迷宫，格式如下：\n\n第 $i$ 行包含两个整数 $x_i$ 和 $y_i$（用单个空格分隔），表示迷宫草图第 $i$ 个顶点的坐标。\n顶点需按多边形外围**逆时针**顺序输出；可以选择任意一个顶点作为第一个顶点，且无需指明入口的位置。", "hint": "翻译由 Deepseek-V3 完成，并进行了微调。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2013] LAB-Maze", "background": "", "description": "Note: During the contest, you may query the scores of any three submissions for this problem.\n\nBajtazar recently read an interesting story.\n\nIts hero was a Greek prince who defeated a monster with a ball of thread, or something like that.\n\nBut what fascinated Bajtazar was that the climax took place in a maze.\n\nSince then, Bajtazar has been very interested in mazes.\n\nHe sketches mazes on squared paper.\n\nEach sketch is a polygon (representing the maze walls) whose edges are parallel to the edges of the paper (i.e., to the axes of the Cartesian coordinate system), and every two consecutive edges are perpendicular.\n\nBajtazar found that if the entrance is placed on some edge of the maze (not at a vertex), then by always walking with his right hand on the wall, one can traverse the entire maze and return to the entrance.\n\nMoreover, during the traversal, we can record the directions of turns.\n\nWhen moving from one wall to the next, if we turn left, we write the letter 'L'; if we turn right, we write the letter 'P'.\n\nBajtazar wants to know whether, for a given string consisting of letters 'L' and 'P', there exists a maze whose traversal produces exactly that string, and if so, output such a maze.", "inputFormat": "The first line of the standard input contains a string $S$ consisting of letters 'L' and 'P' ($1 \\leq |S| \\leq 10^5$), describing the sequence of consecutive turns taken during the traversal of the maze.\n\nIn testcases worth 50% of the points, it additionally holds that $|S| \\leq 1000$.", "outputFormat": "If no maze corresponds to the input description, print the word 'NIE' (Polish for 'no') to the standard output.\n\nOtherwise, print exactly $|S|$ lines, specifying any maze consistent with the input, in the following format:\n\nOn the $i$-th line, print two integers $x_i$ and $y_i$ (separated by a single space), which are the coordinates of the $i$-th vertex of the maze sketch.\nThe vertices must be output in counterclockwise order along the outer boundary of the polygon; you may choose any vertex as the first one, and you do not need to indicate the entrance position.", "hint": "Translation by Deepseek-V3, with minor edits.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2013] LAB-Maze", "background": null, "description": "注意：在比赛期间，你可以询问关于此问题任意三个提交的得分情况。\n\n拜特萨最近读了一个有趣的故事。\n\n故事的主人公是一位希腊王子，他用一根毛线击败了怪物，或诸如此类的情节。\n\n但故事中另一点让拜特萨着迷的是：高潮部分发生在一个迷宫中。\n\n从那时起，拜特萨就对迷宫产生了浓厚的兴趣。\n\n拜特萨在方格纸上绘制迷宫草图。\n\n每个草图是一个多边形（代表迷宫的墙壁），其边平行于纸张的边缘（即笛卡尔坐标系的坐标轴），且每两条相邻边相互垂直。\n\n拜特萨发现，如果将入口放置在迷宫的某条边（**不能是顶点**）上，那么通过始终将右手放在墙上行走，可以遍历整个迷宫并返回入口。\n\n此外，在迷宫遍历过程中，我们可以记录所采取的转弯方向。\n\n当从一面墙移动到另一面墙时，如果左转，我们记下字母 `L`；如果右转，则记下字母 `P`。\n\n拜特萨想知道，对于给定的由字母 `L` 和 `P` 组成的字符串，是否存在一个迷宫，其遍历过程恰好生成该字符串，如果是，则输出这个迷宫。", "inputFormat": "标准输入的第一行给出一个由字母 `L` 和 `P` 组成的字符串 $S$（$1 \\leq |S| \\leq 10^5$），描述了在迷宫遍历过程中连续转弯的序列。\n\n在占总分 $50\\%$ 的测试用例中，额外满足约束 $|S| \\leq 1000$。", "outputFormat": "如果没有迷宫与输入的描述相对应，则在标准输出上打印单词 `NIE`（波兰语中的“否”）。\n\n否则，应恰好输出 $|S|$ 行，指定任意一个与输入一致的迷宫，格式如下：\n\n第 $i$ 行包含两个整数 $x_i$ 和 $y_i$（用单个空格分隔），表示迷宫草图第 $i$ 个顶点的坐标。\n顶点需按多边形外围**逆时针**顺序输出；可以选择任意一个顶点作为第一个顶点，且无需指明入口的位置。", "hint": "翻译由 Deepseek-V3 完成，并进行了微调。", "locale": "zh-CN"}}}
{"pid": "P3560", "type": "P", "difficulty": 4, "samples": [["7 3\n2 1 1\n1 2 3\n4 2 1 3 1 2 5\n", "2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "POI（波兰）", "哈希 hashing"], "title": "[POI 2013] LAN-Colorful Chain", "background": null, "description": "Little Bytie loves to play with colorful chains.\n\nHe already has quite an impressive collection, and some of them he likes    more than the others.\n\nEach chain consists of a certain number of colorful links.\n\nByteasar has noticed that Bytie's sense of aesthetics is very precise.\n\nIt turns out that Bytie finds a contiguous fragment of a chain nice if    it contains exactly    ![](http://main.edu.pl/images/OI20/lan-en-tex.1.png) links of color ![](http://main.edu.pl/images/OI20/lan-en-tex.2.png) links of color ![](http://main.edu.pl/images/OI20/lan-en-tex.3.png) links of color ![](http://main.edu.pl/images/OI20/lan-en-tex.4.png),    and moreover it contains no links of other colors.\n\nA chain's appeal is its number of (contiguous) fragments that are nice.\n\nBy trial and error, Byteasar has determined the values ![](http://main.edu.pl/images/OI20/lan-en-tex.5.png) and ![](http://main.edu.pl/images/OI20/lan-en-tex.6.png).\n\nNow he would like to buy a new chain, and therefore asks you to write a program to aid him in shopping.\n\n给定一个长度为 $n$ 的序列 $\\{a\\}$ 和 $m$ 个条件（每个条件中包含键 $c_i$ 和值 $l_i$），要求找出满足下列条件的子串的数量并输出：\n\n+ 对于 $m$ 个条件中存在的 $c_i$（$1\\le i\\le n$），子串中包含**恰好** $l_i$ 个 $c_i$；\n\n+ 对于 $m$ 个条件中不存在的键值，子串中不包含它。", "inputFormat": "The first line of the standard input gives two integers, ![](http://main.edu.pl/images/OI20/lan-en-tex.7.png) and ![](http://main.edu.pl/images/OI20/lan-en-tex.8.png)      (![](http://main.edu.pl/images/OI20/lan-en-tex.9.png)), separated by a single space.\n\nThese are the length of the chain and the length of a nice fragment's description.\n\nThe second line gives ![](http://main.edu.pl/images/OI20/lan-en-tex.10.png) integers, ![](http://main.edu.pl/images/OI20/lan-en-tex.11.png) (![](http://main.edu.pl/images/OI20/lan-en-tex.12.png)),      separated by single spaces.\n\nThe third line gives ![](http://main.edu.pl/images/OI20/lan-en-tex.13.png) integers, ![](http://main.edu.pl/images/OI20/lan-en-tex.14.png)      (![](http://main.edu.pl/images/OI20/lan-en-tex.15.png), ![](http://main.edu.pl/images/OI20/lan-en-tex.16.png) for ![](http://main.edu.pl/images/OI20/lan-en-tex.17.png)), also separated by single spaces.\n\nThe sequences ![](http://main.edu.pl/images/OI20/lan-en-tex.18.png) and ![](http://main.edu.pl/images/OI20/lan-en-tex.19.png) define a nice fragment of a chain - it has to contain exactly ![](http://main.edu.pl/images/OI20/lan-en-tex.20.png) links of color ![](http://main.edu.pl/images/OI20/lan-en-tex.21.png).\n\nThe fourth line gives ![](http://main.edu.pl/images/OI20/lan-en-tex.22.png) integers, ![](http://main.edu.pl/images/OI20/lan-en-tex.23.png) (![](http://main.edu.pl/images/OI20/lan-en-tex.24.png)),      separated by single spaces, that are the colors of successive links of      the chain.\n\nIn tests worth 50% of total points the constraint ![](http://main.edu.pl/images/OI20/lan-en-tex.25.png) holds in addition.\n\n先输入 $n$ 和 $m$，再输入 $m$ 个条件的 $l_i$，然后输入 $m$ 个条件的 $c_i$，最后输入 $a_i$。", "outputFormat": "Your program is to print a single integer, the number of nice contiguous    fragments in the chain, to the first and only line of the standard output.\n\n输出一行一个整数，表示满足条件的子串数量。", "hint": "### 数据范围：\n\n对于 $100\\%$ 的数据，$1\\leq m\\leq n \\leq 10^6$，$1\\leq a_i,l_i,c_i\\leq n$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2013] LAN-Colorful Chain", "background": "", "description": "Little Bytie loves to play with colorful chains. Each chain consists of a certain number of colorful links. Bytie finds a contiguous fragment of a chain nice if it contains exactly $l_i$ links of color $c_i$ for every $i$ in $[1, m]$, and moreover contains no links of any other colors. The appeal of a chain is the number of its contiguous fragments that are nice.\n\nGiven a sequence of length $n$ representing the colors of the chain and $m$ conditions (each condition gives a color $c_i$ and a required count $l_i$), count how many contiguous substrings are nice, that is:\n- For every $c_i$ among the $m$ conditions, the substring contains exactly $l_i$ occurrences of $c_i$.\n- For any color not listed among the $m$ conditions, the substring contains none of it.", "inputFormat": "- The first line contains two integers $n$ and $m$ ($1 \\le m \\le n \\le 10^6$). These are the length of the chain and the number of conditions.\n- The second line contains $m$ integers $l_1, l_2, \\dots, l_m$ ($1 \\le l_i \\le n$).\n- The third line contains $m$ integers $c_1, c_2, \\dots, c_m$ ($1 \\le c_i \\le n$). These define that a nice fragment must contain exactly $l_i$ links of color $c_i$ for each $i$ and no links of any other colors.\n- The fourth line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le n$), the colors of successive links of the chain.", "outputFormat": "Print a single integer, the number of nice contiguous fragments in the chain.", "hint": "Constraints:\n\nFor $100\\%$ of the testdata, $1 \\le m \\le n \\le 10^6$ and $1 \\le a_i, l_i, c_i \\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2013] LAN-Colorful Chain", "background": null, "description": "Little Bytie loves to play with colorful chains.\n\nHe already has quite an impressive collection, and some of them he likes    more than the others.\n\nEach chain consists of a certain number of colorful links.\n\nByteasar has noticed that Bytie's sense of aesthetics is very precise.\n\nIt turns out that Bytie finds a contiguous fragment of a chain nice if    it contains exactly    ![](http://main.edu.pl/images/OI20/lan-en-tex.1.png) links of color ![](http://main.edu.pl/images/OI20/lan-en-tex.2.png) links of color ![](http://main.edu.pl/images/OI20/lan-en-tex.3.png) links of color ![](http://main.edu.pl/images/OI20/lan-en-tex.4.png),    and moreover it contains no links of other colors.\n\nA chain's appeal is its number of (contiguous) fragments that are nice.\n\nBy trial and error, Byteasar has determined the values ![](http://main.edu.pl/images/OI20/lan-en-tex.5.png) and ![](http://main.edu.pl/images/OI20/lan-en-tex.6.png).\n\nNow he would like to buy a new chain, and therefore asks you to write a program to aid him in shopping.\n\n给定一个长度为 $n$ 的序列 $\\{a\\}$ 和 $m$ 个条件（每个条件中包含键 $c_i$ 和值 $l_i$），要求找出满足下列条件的子串的数量并输出：\n\n+ 对于 $m$ 个条件中存在的 $c_i$（$1\\le i\\le n$），子串中包含**恰好** $l_i$ 个 $c_i$；\n\n+ 对于 $m$ 个条件中不存在的键值，子串中不包含它。", "inputFormat": "The first line of the standard input gives two integers, ![](http://main.edu.pl/images/OI20/lan-en-tex.7.png) and ![](http://main.edu.pl/images/OI20/lan-en-tex.8.png)      (![](http://main.edu.pl/images/OI20/lan-en-tex.9.png)), separated by a single space.\n\nThese are the length of the chain and the length of a nice fragment's description.\n\nThe second line gives ![](http://main.edu.pl/images/OI20/lan-en-tex.10.png) integers, ![](http://main.edu.pl/images/OI20/lan-en-tex.11.png) (![](http://main.edu.pl/images/OI20/lan-en-tex.12.png)),      separated by single spaces.\n\nThe third line gives ![](http://main.edu.pl/images/OI20/lan-en-tex.13.png) integers, ![](http://main.edu.pl/images/OI20/lan-en-tex.14.png)      (![](http://main.edu.pl/images/OI20/lan-en-tex.15.png), ![](http://main.edu.pl/images/OI20/lan-en-tex.16.png) for ![](http://main.edu.pl/images/OI20/lan-en-tex.17.png)), also separated by single spaces.\n\nThe sequences ![](http://main.edu.pl/images/OI20/lan-en-tex.18.png) and ![](http://main.edu.pl/images/OI20/lan-en-tex.19.png) define a nice fragment of a chain - it has to contain exactly ![](http://main.edu.pl/images/OI20/lan-en-tex.20.png) links of color ![](http://main.edu.pl/images/OI20/lan-en-tex.21.png).\n\nThe fourth line gives ![](http://main.edu.pl/images/OI20/lan-en-tex.22.png) integers, ![](http://main.edu.pl/images/OI20/lan-en-tex.23.png) (![](http://main.edu.pl/images/OI20/lan-en-tex.24.png)),      separated by single spaces, that are the colors of successive links of      the chain.\n\nIn tests worth 50% of total points the constraint ![](http://main.edu.pl/images/OI20/lan-en-tex.25.png) holds in addition.\n\n先输入 $n$ 和 $m$，再输入 $m$ 个条件的 $l_i$，然后输入 $m$ 个条件的 $c_i$，最后输入 $a_i$。", "outputFormat": "Your program is to print a single integer, the number of nice contiguous    fragments in the chain, to the first and only line of the standard output.\n\n输出一行一个整数，表示满足条件的子串数量。", "hint": "### 数据范围：\n\n对于 $100\\%$ 的数据，$1\\leq m\\leq n \\leq 10^6$，$1\\leq a_i,l_i,c_i\\leq n$。", "locale": "zh-CN"}}}
{"pid": "P3561", "type": "P", "difficulty": 6, "samples": [["4\n1\n1 1\n1 0 1", "4 1 2 3 4\n3 2 3 4\n3 3 4 2\n3 4 2 3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2017", "POI（波兰）", "Special Judge"], "title": "[POI 2017] Turysta", "background": "", "description": "给出一个 $n$ 个点的有向图，任意两个点之间有且仅一条有向边。\n\n对于每个点 $v$，求出从 $v$ 出发的一条经过点数最多，且没有重复经过同一个点两次及两次以上的简单路径。", "inputFormat": "第一行包含一个正整数 $n$，表示点数。\n\n接下来的 $n-1$ 行，其中的第 $i$ 行有 $i-1$ 个数。\n\n如果第 $j$ 个数是 $1$，那么表示有向边 $j\\rightarrow i+1$ ，如果是 $0$，那么表示有向边 $j\\leftarrow i+1$。", "outputFormat": "输出 $n$ 行，第 $i$ 行首先包含一个正整数 $k$，表示从 $i$ 点出发的最优路径所经过的点数。\n\n接下来 $k$ 个正整数，依次表示路径上的每个点。\n\n若有多组最优解，输出任意一组。\n\n**本题使用 SPJ （Claris 制作）**", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 2 \\times 10^3$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2017] Turysta", "background": "", "description": "给出一个 $n$ 个点的有向图，任意两个点之间有且仅一条有向边。\n\n对于每个点 $v$，求出从 $v$ 出发的一条经过点数最多，且没有重复经过同一个点两次及两次以上的简单路径。", "inputFormat": "第一行包含一个正整数 $n$，表示点数。\n\n接下来的 $n-1$ 行，其中的第 $i$ 行有 $i-1$ 个数。\n\n如果第 $j$ 个数是 $1$，那么表示有向边 $j\\rightarrow i+1$ ，如果是 $0$，那么表示有向边 $j\\leftarrow i+1$。", "outputFormat": "输出 $n$ 行，第 $i$ 行首先包含一个正整数 $k$，表示从 $i$ 点出发的最优路径所经过的点数。\n\n接下来 $k$ 个正整数，依次表示路径上的每个点。\n\n若有多组最优解，输出任意一组。\n\n**本题使用 SPJ （Claris 制作）**", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 2 \\times 10^3$。", "locale": "zh-CN"}}}
{"pid": "P3562", "type": "P", "difficulty": 6, "samples": [["3 6\n1 2 2 4\n3 1 5 1\n3 2 2 3\n3 3 3 4\n2 2 2 2\n6 1 3 5", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "POI（波兰）"], "title": "[POI 2013] LAS-Laser", "background": "", "description": "平面上有些线段，你最多从原点射出 $k$ 条射线，穿过最多的线段，且使得每条线段最多被穿过 $1$ 次。\n\n求最多能穿过多少线段。", "inputFormat": "第一行两个整数 $k$，$n$，其中 $n$ 是线段数量。  \n\n之后 $n$ 行，每行四个整数 $x_1,y_1,x_2,y_2$ 表示一条线段。", "outputFormat": "输出一个整数，表示最多能穿过几条线段。", "hint": "对于 $100\\%$ 的数据，$1 \\leq k\\le100$，$1 \\leq n\\le5\\times10^5$，$1 \\leq x_1, y_1, x_2, y_2 \\leq 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2013] LAS-Laser", "background": "", "description": "There are some line segments in the plane. You may shoot at most $k$ rays starting from the origin to intersect as many segments as possible, and each segment may be counted at most once.\n\nFind the maximum number of segments that can be intersected.", "inputFormat": "The first line contains two integers $k$, $n$, where $n$ is the number of segments.  \nThen $n$ lines follow, each containing four integers $x_1, y_1, x_2, y_2$ describing a segment.", "outputFormat": "Output a single integer, the maximum number of segments that can be intersected.", "hint": "For $100\\%$ of the testdata, $1 \\leq k \\leq 100$, $1 \\leq n \\leq 5\\times10^5$, $1 \\leq x_1, y_1, x_2, y_2 \\leq 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2013] LAS-Laser", "background": "", "description": "平面上有些线段，你最多从原点射出 $k$ 条射线，穿过最多的线段，且使得每条线段最多被穿过 $1$ 次。\n\n求最多能穿过多少线段。", "inputFormat": "第一行两个整数 $k$，$n$，其中 $n$ 是线段数量。  \n\n之后 $n$ 行，每行四个整数 $x_1,y_1,x_2,y_2$ 表示一条线段。", "outputFormat": "输出一个整数，表示最多能穿过几条线段。", "hint": "对于 $100\\%$ 的数据，$1 \\leq k\\le100$，$1 \\leq n\\le5\\times10^5$，$1 \\leq x_1, y_1, x_2, y_2 \\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P3563", "type": "P", "difficulty": 6, "samples": [["4\n1 2\n1 3\n1 4\n", "3 5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "动态规划 DP", "贪心", "2013", "POI（波兰）"], "title": "[POI 2013] POL-Polarization", "background": "", "description": "Everyone knew it would only be a matter of time. So what? Faced for years on, a peril becomes the every-day reality. It loses its meaning...\n\nToday the letter of the Bitotian char Bittard to the Byteotian king Byteasar was released to the public. Bitotia requested annexation of the whole Byteotia on pain of using the Bit Polarizing Magnet (BPM). If used, the BPM would make each and every road in Byteotia unidirectional. The enemy knows only too well that this could be a fatal blow to the minimalist Byteotian infrastructure - there is a unique way between each pair of towns.\n\nHow badly can the BPM damage the Byteotian infrastructure? Determine the minimum and the maximum number of such pairs of towns that it will still be possible to travel from one of them to the other while observing the new roads orientation.", "inputFormat": "The first line of the standard input gives a single integer n (1 ≤ n ≤ 250,000), the number of towns in Byteotia. The n-1 lines that follow describe these roads. Each such line holds two integers, u and v (1 ≤ u ≤ v ≤ n), which indicate that there is a direct road (still bidirectional at the moment) linking the towns no. u and v.", "outputFormat": "Two integers should be printed to the first and only line of the standard output. \n\nThe first number should be the minimum and the second - the maximum number of pairs of towns which could remain connected (though in one direction only) after the roads are polarized.", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2013] POL-Polarization", "background": "", "description": "Everyone knew it would only be a matter of time. So what? Faced for years on, a peril becomes the every-day reality. It loses its meaning...\n\nToday the letter of the Bitotian char Bittard to the Byteotian king Byteasar was released to the public. Bitotia requested annexation of the whole Byteotia on pain of using the Bit Polarizing Magnet (BPM). If used, the BPM would make each and every road in Byteotia unidirectional. The enemy knows only too well that this could be a fatal blow to the minimalist Byteotian infrastructure - there is a unique way between each pair of towns.\n\nHow badly can the BPM damage the Byteotian infrastructure? Determine the minimum and the maximum number of such pairs of towns that it will still be possible to travel from one of them to the other while observing the new roads orientation.", "inputFormat": "The first line of the standard input gives a single integer n (1 ≤ n ≤ 250,000), the number of towns in Byteotia. The n-1 lines that follow describe these roads. Each such line holds two integers, u and v (1 ≤ u ≤ v ≤ n), which indicate that there is a direct road (still bidirectional at the moment) linking the towns no. u and v.", "outputFormat": "Two integers should be printed to the first and only line of the standard output. \n\nThe first number should be the minimum and the second - the maximum number of pairs of towns which could remain connected (though in one direction only) after the roads are polarized.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2013] POL-Polarization", "background": null, "description": "每个人都知道这只是时间问题。那么又如何呢？\n\n面对多年的威胁，这种危险成为了日常现实。\n\n它失去了意义……\n\n今天，Bitotia 的 char Bittard 给 Byteotia 国王 Byteasar 的信被公开了。\n\nBitotia 要求吞并整个 Byteotia，否则将使用 Bit 极化磁铁（BPM）。\n\n如果使用，BPM 将使 Byteotia 的每条道路变为单向。\n\n敌人非常清楚，这可能会对极简的 Byteotia 基础设施造成致命打击——在每对城镇之间只有唯一的路径。\n\nBPM 能对 Byteotia 的基础设施造成多大的破坏？\n\n确定在新的道路方向下，仍然可以从一个城镇到另一个城镇的最小和最大城镇对数。", "inputFormat": "标准输入的第一行给出一个整数 $n$ ($1 \\leq n \\leq 250\\,000$)，表示 Byteotia 中的城镇数量。\n\n接下来的 $n-1$ 行描述这些道路。\n\n每行包含两个整数，$a$ 和 $b$ ($1 \\leq a, b \\leq n$)，表示目前仍为双向的直接道路连接城镇 $a$ 和 $b$。\n\n在占总分 60% 的测试中，额外的约束 $n \\leq 5\\,000$ 成立；此外，在其中一些占总分 30% 的测试中，甚至有 $n \\leq 1\\,000$。", "outputFormat": "标准输出的第一行应打印两个整数。\n\n第一个数字应为在道路极化后仍然可以连接的城镇对数的最小值，第二个数字应为最大值（尽管仅为单向）。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3564", "type": "P", "difficulty": 6, "samples": [["6\njpjppj\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "二分", "POI（波兰）", "前缀和", "ST 表", "单调栈"], "title": "[POI 2014] BAR-Salad Bar", "background": "", "description": "Bytea went to a salad bar.\n\nThere are $n$ fruits one next to another on the bar counter.\n\nSpecifically, these are apples and oranges.\n\nBytea can pick any contiguous part of the line of fruits for her salad.\n\nThe fruits she chooses will be added to the salad either from left to right or from right to left.\n\nAs Bytea loves oranges, she requires that throughout the salad making process, the number of oranges    in it should always be no smaller than the number of apples, regardless of whether these are added %    from left to right or from right to left.\n\nHelp Bytea out by writing a program that will find the longest contiguous part of the line of fruits    that satisfies her requirements.\n\n有一个长度为n的字符串，每一位只会是p或j。求一个最长子串，使得不管是从左往右还是从右往左取，都保证每时每刻已取出的p的个数不小于j的个数。\n", "inputFormat": "The first line of the standard input contains a single integer $n$ ($1\\le n\\le 1\\ 000\\ 000$), denoting the number of fruits.\n\nThe next line contains a string of $n$ characters $a_1,a_2,\\cdots,a_n$ ($a_i\\in \\{j,p\\}$).\n\nThese stand for Polish names of apples and oranges: jab\\l{ka} and pomara\\'ncze).\n\nConsequently, if $a_i=j$, then the $i$-th fruit in a line is an apple,      and otherwise it is an orange.\n", "outputFormat": "The first and only line of the standard output should contain a single integer equal to the number of fruits in the longest contiguous part of the line that satisfies Bytea's requirements.\n\nNote that it could be the case that $0$ is the correct result.\n", "hint": "有一个长度为n的字符串，每一位只会是p或j。求一个最长子串，使得不管是从左往右还是从右往左取，都保证每时每刻已取出的p的个数不小于j的个数。\n", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2014] BAR-Salad Bar", "background": "", "description": "Bytea went to a salad bar.\n\nThere are $n$ fruits lined up on the bar counter.\n\nSpecifically, these are apples and oranges.\n\nBytea can pick any contiguous segment of the line of fruits for her salad.\n\nThe fruits she chooses will be added to the salad either from left to right or from right to left.\n\nAs Bytea loves oranges, she requires that throughout the salad-making process, the number of oranges in the salad should always be no smaller than the number of apples, regardless of whether the fruits are added from left to right or from right to left.\n\nHelp Bytea by writing a program that finds the longest contiguous segment of the line of fruits that satisfies her requirements.", "inputFormat": "The first line of the standard input contains a single integer $n$ ($1 \\le n \\le 1\\ 000\\ 000$), denoting the number of fruits.\n\nThe next line contains a string of $n$ characters $a_1, a_2, \\cdots, a_n$ ($a_i \\in \\{j, p\\}$).\n\nThese stand for Polish names of apples and oranges: jab\\l{ka} and pomara\\'ncze.\n\nConsequently, if $a_i = j$, then the $i$-th fruit in the line is an apple, and otherwise it is an orange.", "outputFormat": "The first and only line of the standard output should contain a single integer equal to the number of fruits in the longest contiguous segment that satisfies Bytea's requirements.\n\nNote that it could be the case that $0$ is the correct result.", "hint": "Given a string of length $n$ consisting only of 'p' and 'j', find the longest substring such that, whether you take it from left to right or from right to left, at every moment the number of 'p' taken is no less than the number of 'j'.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2014] BAR-Salad Bar", "background": "", "description": "Bytea went to a salad bar.\n\nThere are $n$ fruits one next to another on the bar counter.\n\nSpecifically, these are apples and oranges.\n\nBytea can pick any contiguous part of the line of fruits for her salad.\n\nThe fruits she chooses will be added to the salad either from left to right or from right to left.\n\nAs Bytea loves oranges, she requires that throughout the salad making process, the number of oranges    in it should always be no smaller than the number of apples, regardless of whether these are added %    from left to right or from right to left.\n\nHelp Bytea out by writing a program that will find the longest contiguous part of the line of fruits    that satisfies her requirements.\n\n有一个长度为n的字符串，每一位只会是p或j。求一个最长子串，使得不管是从左往右还是从右往左取，都保证每时每刻已取出的p的个数不小于j的个数。\n", "inputFormat": "The first line of the standard input contains a single integer $n$ ($1\\le n\\le 1\\ 000\\ 000$), denoting the number of fruits.\n\nThe next line contains a string of $n$ characters $a_1,a_2,\\cdots,a_n$ ($a_i\\in \\{j,p\\}$).\n\nThese stand for Polish names of apples and oranges: jab\\l{ka} and pomara\\'ncze).\n\nConsequently, if $a_i=j$, then the $i$-th fruit in a line is an apple,      and otherwise it is an orange.\n", "outputFormat": "The first and only line of the standard output should contain a single integer equal to the number of fruits in the longest contiguous part of the line that satisfies Bytea's requirements.\n\nNote that it could be the case that $0$ is the correct result.\n", "hint": "有一个长度为n的字符串，每一位只会是p或j。求一个最长子串，使得不管是从左往右还是从右往左取，都保证每时每刻已取出的p的个数不小于j的个数。\n", "locale": "zh-CN"}}}
{"pid": "P3565", "type": "P", "difficulty": 5, "samples": [["7\n1 2\n5 7\n2 5\n2 3\n5 6\n4 5\n", "5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["动态规划 DP", "2014", "POI（波兰）", "树形 DP"], "title": "[POI 2014] HOT-Hotels", "background": "", "description": "There are $n$ towns in Byteotia, connected with only $n-1$ roads.\n\nEach road directly links two towns.\n\nAll the roads have the same length and are two way.\n\nIt is known that every town can be reached from every other town    via a route consisting of one or more (direct-link) roads.\n\nIn other words, the road network forms a tree.\n\nByteasar, the king of Byteotia, wants three luxury hotels    erected to attract tourists from all over the world.\n\nThe king desires that the hotels be in different towns    and at the same distance one from each other.\n\nHelp the king out by writing a program that determines the number    of possible locations of the hotel triplet in Byteotia.", "inputFormat": "The first line of the standard input contains a single integer $n$ ($1\\le n\\le 5\\ 000$),   the number of towns in Byteotia.\n\nThe towns are numbered from $1$ to $n$.\n\nThe Byteotian road network is then described in $n-1$ lines.\n\nEach line contains two integers $a$ and $b$ ($1\\le a\\le b\\le n$) ,   separated by a single space, that indicate there is   a direct road between the towns $a$ and $b$.\n", "outputFormat": "The first and only line of the standard output should contain a single integer    equal to the number of possible placements of the hotels.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2014] HOT-Hotels", "background": "", "description": "There are $n$ towns in Byteotia, connected with only $n-1$ roads.\n\nEach road directly links two towns.\n\nAll the roads have the same length and are two way.\n\nIt is known that every town can be reached from every other town    via a route consisting of one or more (direct-link) roads.\n\nIn other words, the road network forms a tree.\n\nByteasar, the king of Byteotia, wants three luxury hotels    erected to attract tourists from all over the world.\n\nThe king desires that the hotels be in different towns    and at the same distance one from each other.\n\nHelp the king out by writing a program that determines the number    of possible locations of the hotel triplet in Byteotia.", "inputFormat": "The first line of the standard input contains a single integer $n$ ($1\\le n\\le 5\\ 000$),   the number of towns in Byteotia.\n\nThe towns are numbered from $1$ to $n$.\n\nThe Byteotian road network is then described in $n-1$ lines.\n\nEach line contains two integers $a$ and $b$ ($1\\le a\\le b\\le n$) ,   separated by a single space, that indicate there is   a direct road between the towns $a$ and $b$.\n", "outputFormat": "The first and only line of the standard output should contain a single integer    equal to the number of possible placements of the hotels.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2014] HOT-Hotels", "background": "", "description": "在 Byteotia 有 $n$ 个城镇，通过 $n-1$ 条道路连接。\n\n每条道路直接连接两个城镇。\n\n所有的道路长度相同，并且是双向的。\n\n已知每个城镇都可以通过一条或多条（直接连接的）道路到达其他城镇。\n\n换句话说，道路网络形成了一棵树。\n\nByteotia 的国王 Byteasar 希望建造三家豪华酒店，以吸引来自世界各地的游客。\n\n国王希望这些酒店位于不同的城镇，并且彼此之间的距离相同。\n\n请通过编写程序来帮助国王，确定在 Byteotia 中可能的酒店三元组位置的数量。", "inputFormat": "标准输入的第一行包含一个整数 $n$ ($1\\le n\\le 5\\ 000$)，表示 Byteotia 中的城镇数量。\n\n城镇编号从 $1$ 到 $n$。\n\n接下来 $n-1$ 行描述了 Byteotia 的道路网络。\n\n每行包含两个整数 $a$ 和 $b$ ($1\\le a\\le b\\le n$)，用一个空格分隔，表示在城镇 $a$ 和 $b$ 之间有一条直接的道路。", "outputFormat": "标准输出的第一行应包含一个整数，表示可能的酒店位置的数量。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3566", "type": "P", "difficulty": 6, "samples": [["3 3 1\n2 3 3\n", "3 2 1 3 2 3 2 1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2014", "POI（波兰）", "Special Judge"], "title": "[POI 2014] KLO-Bricks", "background": "", "description": "Little Bitie and his friends spent the whole yesterday playing    with colorful bricks in the kindergarten.\n\nInitially they made building models but they quickly got bored with that.\n\nThen they decided to place the bricks in a line, one after another.\n\nTo avoid a dull look, they tried to avoid putting two bricks of the same    color next to each other.\n\nAfter a long while they succeeded in placing all the bricks while observing    this rule.\n\nThen the day care was over, and the children went home with their parents.\n\nToday Bitie came to the kindergarten early.\n\nHe was satisfied to see that their yesterday's creation was still standing.\n\nBut then he tripped over in a most unfortunate way,    falling right on the line of bricks, which all mixed in a pile.\n\nThe boy quickly sorted them by color and wondered how best to quickly    reassemble the perfect line.\n\nHe managed to recall what were the colors of the two bricks on both end of the line.\n\nHelp little Bitie out and tell him how to order the bricks in a line so that    no two bricks of the same color are next to each other and the bricks at the ends    of the line have the colors that he recalled.\n\nNote that Bitie could have made a mistake in recalling the two colors    or perhaps he did not find some of the blocks after falling into them,    so the reconstruction might not be possible.", "inputFormat": "There are three integers in the first line of the standard input,    $k$,$p$, and $q$ ($1\\le k\\le 1 000 000$,$1\\le p,q\\le k$), separated by single spaces,    denoting the number of brick colors, and the colors of    the first and the last brick in the desired arrangement, respectively.\n\nIn the second line, there are $k$ integers,$i_{1},i_{2},...,i{k}$ ($1\\le i_{j}\\le 1 000 000$),    separated by single spaces.\n\nThe number $i_{j}$ signifies that Bitie has exactly $i_{j}$ bricks    of color $j$.\n\nYou may assume that the total number of bricks does not exceed one million, i.e., that $n=i_1+i_2+\\cdots+i_k\\le 1\\ 000\\ 000$.\n", "outputFormat": "Your program should print $n$ integers to the standard output,    separated by single spaces.\n\nThe numbers should represent the colors of successive bricks in    an arrangement that satisfies aforementioned constraints.\n\nIf no such arrangement exists, your program should print only    a single integer: $0$.\n\nIf there are several correct answers, your program can pick one    arbitrarily.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2014] KLO-Bricks", "background": "", "description": "Little Bitie and his friends spent the whole yesterday playing    with colorful bricks in the kindergarten.\n\nInitially they made building models but they quickly got bored with that.\n\nThen they decided to place the bricks in a line, one after another.\n\nTo avoid a dull look, they tried to avoid putting two bricks of the same    color next to each other.\n\nAfter a long while they succeeded in placing all the bricks while observing    this rule.\n\nThen the day care was over, and the children went home with their parents.\n\nToday Bitie came to the kindergarten early.\n\nHe was satisfied to see that their yesterday's creation was still standing.\n\nBut then he tripped over in a most unfortunate way,    falling right on the line of bricks, which all mixed in a pile.\n\nThe boy quickly sorted them by color and wondered how best to quickly    reassemble the perfect line.\n\nHe managed to recall what were the colors of the two bricks on both end of the line.\n\nHelp little Bitie out and tell him how to order the bricks in a line so that    no two bricks of the same color are next to each other and the bricks at the ends    of the line have the colors that he recalled.\n\nNote that Bitie could have made a mistake in recalling the two colors    or perhaps he did not find some of the blocks after falling into them,    so the reconstruction might not be possible.", "inputFormat": "There are three integers in the first line of the standard input,    $k$,$p$, and $q$ ($1\\le k\\le 1 000 000$,$1\\le p,q\\le k$), separated by single spaces,    denoting the number of brick colors, and the colors of    the first and the last brick in the desired arrangement, respectively.\n\nIn the second line, there are $k$ integers,$i_{1},i_{2},...,i{k}$ ($1\\le i_{j}\\le 1 000 000$),    separated by single spaces.\n\nThe number $i_{j}$ signifies that Bitie has exactly $i_{j}$ bricks    of color $j$.\n\nYou may assume that the total number of bricks does not exceed one million, i.e., that $n=i_1+i_2+\\cdots+i_k\\le 1\\ 000\\ 000$.\n", "outputFormat": "Your program should print $n$ integers to the standard output,    separated by single spaces.\n\nThe numbers should represent the colors of successive bricks in    an arrangement that satisfies aforementioned constraints.\n\nIf no such arrangement exists, your program should print only    a single integer: $0$.\n\nIf there are several correct answers, your program can pick one    arbitrarily.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2014] KLO-Bricks", "background": null, "description": "现在你有 $k$ 种颜色的砖块，已知每种颜色砖块的数量，问是否有一种方案可以将砖块放成一排并且第一块和最后一块砖块的颜色为 $p,q$ 且相邻的砖块颜色不同，如果没有合法方案则输出 $0$。", "inputFormat": "第一行输入三个整数 $k,p,q$ 分别代表砖块有 $k$ 种颜色，第一块和最后一块的砖块颜色分别是 $p,q$，第二行输入 $k$ 个数，第 $j$ 个数表示颜色为 $j$ 砖块的数量。", "outputFormat": "输出一个排列，要求用完全部砖块并且满足上述约束条件，如果有多个正确答案只需要输出其中一种，特别的，如果无解输出 $0$。在最后一个数字后请不要输出空格。", "hint": "$1 \\leq k \\leq 10^6,1\\leq p,q \\leq k$。\n\n其中保证砖块总数量之和不超过 $10^6$。", "locale": "zh-CN"}}}
{"pid": "P3567", "type": "P", "difficulty": 5, "samples": [["7 5\n1 1 3 2 3 4 3\n1 3\n1 4\n3 7\n1 7\n6 6\n", "1\n0\n3\n0\n4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "线段树", "POI（波兰）", "可持久化线段树", "可持久化", "随机化"], "title": "[POI 2014] KUR-Couriers", "background": "", "description": "Byteasar works for the BAJ company, which sells computer games.\n\nThe BAJ company cooperates with many courier companies    that deliver the games sold by the BAJ company to its customers.\n\nByteasar is inspecting the cooperation of the BAJ company with the couriers.\n\nHe has a log of successive packages with the courier company that made the delivery    specified for each package.\n\nHe wants to make sure that no courier company had an unfair advantage over the others.\n\nIf a given courier company delivered more than half of all packages sent in some period of time,    we say that it dominated in that period.\n\nByteasar wants to find out which courier companies dominated in certain periods of time, if any.\n\nHelp Byteasar out!\n\nWrite a program that determines a dominating courier company or that there was none.\n\n给一个数列，每次询问一个区间内有没有一个数出现次数超过一半\n", "inputFormat": "The first line of the standard input contains two integers, ![](http://main.edu.pl/images/OI21/kur-en-tex.1.png) and ![](http://main.edu.pl/images/OI21/kur-en-tex.2.png) (![](http://main.edu.pl/images/OI21/kur-en-tex.3.png)),    separated by a single space, that are the number of packages shipped by the BAJ company    and the number of time periods for which the dominating courier is to be determined, respectively.\n\nThe courier companies are numbered from ![](http://main.edu.pl/images/OI21/kur-en-tex.4.png) to (at most) ![](http://main.edu.pl/images/OI21/kur-en-tex.5.png).\n\nThe second line of input contains ![](http://main.edu.pl/images/OI21/kur-en-tex.6.png) integers, ![](http://main.edu.pl/images/OI21/kur-en-tex.7.png) (![](http://main.edu.pl/images/OI21/kur-en-tex.8.png)),    separated by single spaces;    ![](http://main.edu.pl/images/OI21/kur-en-tex.9.png) is the number of the courier company that delivered the ![](http://main.edu.pl/images/OI21/kur-en-tex.10.png)-th package (in shipment chronology).\n\nThe ![](http://main.edu.pl/images/OI21/kur-en-tex.11.png) lines that follow specify the time period queries, one per line.\n\nEach query is specified by two integers, ![](http://main.edu.pl/images/OI21/kur-en-tex.12.png) and ![](http://main.edu.pl/images/OI21/kur-en-tex.13.png) (![](http://main.edu.pl/images/OI21/kur-en-tex.14.png)),    separated by a single space.\n\nThese mean that the courier company dominating in the period between the shipments of the    ![](http://main.edu.pl/images/OI21/kur-en-tex.15.png)-th and the ![](http://main.edu.pl/images/OI21/kur-en-tex.16.png)-th package, including those, is to be determined.\n\nIn tests worth ![](http://main.edu.pl/images/OI21/kur-en-tex.17.png) of total score, the condition ![](http://main.edu.pl/images/OI21/kur-en-tex.18.png) holds,    and in tests worth ![](http://main.edu.pl/images/OI21/kur-en-tex.19.png) of total score ![](http://main.edu.pl/images/OI21/kur-en-tex.20.png).\n", "outputFormat": "The answers to successive queries should be printed to the standard output, one per line.\n\n(Thus a total of ![](http://main.edu.pl/images/OI21/kur-en-tex.21.png) lines should be printed.)    Each line should hold a single integer: the number of the courier company that dominated    in the corresponding time period, or ![](http://main.edu.pl/images/OI21/kur-en-tex.22.png) if there was no such company.\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2014] KUR-Couriers", "background": "", "description": "Byteasar works for the BAJ company, which sells computer games.\n\nThe BAJ company cooperates with many courier companies that deliver the games sold by the BAJ company to its customers.\n\nByteasar is inspecting the cooperation of the BAJ company with the couriers.\n\nHe has a log of successive packages with the courier company that made the delivery specified for each package.\n\nHe wants to make sure that no courier company had an unfair advantage over the others.\n\nIf a given courier company delivered more than half of all packages sent in some period of time, we say that it dominated in that period.\n\nByteasar wants to find out which courier companies dominated in certain periods of time, if any.\n\nHelp Byteasar out!\n\nWrite a program that determines a dominating courier company or that there was none.\n\nGiven a sequence of integers, for each query on an interval, determine whether there is a number whose occurrences are more than half of the interval length; if so, report it, otherwise report $0$.", "inputFormat": "The first line contains two integers $n$ and $m$, which are the number of packages shipped by the BAJ company and the number of time periods (queries) for which the dominating courier is to be determined, respectively.\n\nThe courier companies are numbered from $1$ to (at most) $C$.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ separated by single spaces; $a_i$ is the number of the courier company that delivered the $i$-th package (in shipment chronology).\n\nThe next $m$ lines each describe one time period. Each line contains two integers $l$ and $r$, separated by a single space. These mean that the courier company dominating in the period between the shipments of the $l$-th and the $r$-th package, inclusive, is to be determined.", "outputFormat": "Print $m$ lines. Each line should contain a single integer: the number of the courier company that dominated in the corresponding time period, or $0$ if there was no such company.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2014] KUR-Couriers", "background": "", "description": "Byteasar works for the BAJ company, which sells computer games.\n\nThe BAJ company cooperates with many courier companies    that deliver the games sold by the BAJ company to its customers.\n\nByteasar is inspecting the cooperation of the BAJ company with the couriers.\n\nHe has a log of successive packages with the courier company that made the delivery    specified for each package.\n\nHe wants to make sure that no courier company had an unfair advantage over the others.\n\nIf a given courier company delivered more than half of all packages sent in some period of time,    we say that it dominated in that period.\n\nByteasar wants to find out which courier companies dominated in certain periods of time, if any.\n\nHelp Byteasar out!\n\nWrite a program that determines a dominating courier company or that there was none.\n\n给一个数列，每次询问一个区间内有没有一个数出现次数超过一半\n", "inputFormat": "The first line of the standard input contains two integers, ![](http://main.edu.pl/images/OI21/kur-en-tex.1.png) and ![](http://main.edu.pl/images/OI21/kur-en-tex.2.png) (![](http://main.edu.pl/images/OI21/kur-en-tex.3.png)),    separated by a single space, that are the number of packages shipped by the BAJ company    and the number of time periods for which the dominating courier is to be determined, respectively.\n\nThe courier companies are numbered from ![](http://main.edu.pl/images/OI21/kur-en-tex.4.png) to (at most) ![](http://main.edu.pl/images/OI21/kur-en-tex.5.png).\n\nThe second line of input contains ![](http://main.edu.pl/images/OI21/kur-en-tex.6.png) integers, ![](http://main.edu.pl/images/OI21/kur-en-tex.7.png) (![](http://main.edu.pl/images/OI21/kur-en-tex.8.png)),    separated by single spaces;    ![](http://main.edu.pl/images/OI21/kur-en-tex.9.png) is the number of the courier company that delivered the ![](http://main.edu.pl/images/OI21/kur-en-tex.10.png)-th package (in shipment chronology).\n\nThe ![](http://main.edu.pl/images/OI21/kur-en-tex.11.png) lines that follow specify the time period queries, one per line.\n\nEach query is specified by two integers, ![](http://main.edu.pl/images/OI21/kur-en-tex.12.png) and ![](http://main.edu.pl/images/OI21/kur-en-tex.13.png) (![](http://main.edu.pl/images/OI21/kur-en-tex.14.png)),    separated by a single space.\n\nThese mean that the courier company dominating in the period between the shipments of the    ![](http://main.edu.pl/images/OI21/kur-en-tex.15.png)-th and the ![](http://main.edu.pl/images/OI21/kur-en-tex.16.png)-th package, including those, is to be determined.\n\nIn tests worth ![](http://main.edu.pl/images/OI21/kur-en-tex.17.png) of total score, the condition ![](http://main.edu.pl/images/OI21/kur-en-tex.18.png) holds,    and in tests worth ![](http://main.edu.pl/images/OI21/kur-en-tex.19.png) of total score ![](http://main.edu.pl/images/OI21/kur-en-tex.20.png).\n", "outputFormat": "The answers to successive queries should be printed to the standard output, one per line.\n\n(Thus a total of ![](http://main.edu.pl/images/OI21/kur-en-tex.21.png) lines should be printed.)    Each line should hold a single integer: the number of the courier company that dominated    in the corresponding time period, or ![](http://main.edu.pl/images/OI21/kur-en-tex.22.png) if there was no such company.\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3568", "type": "P", "difficulty": 7, "samples": [["9\n0 0 5 0 17 0 0 0 21\n8 0 0 3 16 0 0 25 0\n0 0 0 0 0 0 0 0 23\n", "7 6 5 4 17 18 19 20 21\n8 1 2 3 16 15 26 25 22\n9 10 11 12 13 14 27 24 23\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "POI（波兰）", "Special Judge"], "title": "[POI 2014] WAZ-Snake", "background": "", "description": "A snake fills a ![](http://main.edu.pl/images/OI21/waz-en-tex.1.png) board completely.\n\nSuccessive segments of the snake are numbered from ![](http://main.edu.pl/images/OI21/waz-en-tex.2.png) to ![](http://main.edu.pl/images/OI21/waz-en-tex.3.png).\n\nThe segments with successive numbers (i.e., 1 and 2, 2 and 3, 3 and 4...) occupy squares  that share an edge.\n\nFor example, a snake can fill a ![](http://main.edu.pl/images/OI21/waz-en-tex.4.png) board as follows:\n\nThe snake's segment numbers in some of the squares have been erased.\n\n  Can you reconstruct the snake?\n\n一只蛇被放在了一块3\\*n的木板上（填充满了），蛇被分为多个小段，小段的编号是1到3n。比如说蛇可以填写一个3\\*9的木板，如下所示：\n\n\n部分木板上的蛇段已删遮挡。\n\n\n你能重建蛇吗？\n", "inputFormat": "In the first line of the standard input, there is a single integer ![](http://main.edu.pl/images/OI21/waz-en-tex.5.png)  (![](http://main.edu.pl/images/OI21/waz-en-tex.6.png)), the length of the board.\n\nThe three lines that follow describe the board;  the ![](http://main.edu.pl/images/OI21/waz-en-tex.7.png)-th of them contains ![](http://main.edu.pl/images/OI21/waz-en-tex.8.png) integers ![](http://main.edu.pl/images/OI21/waz-en-tex.9.png)  (![](http://main.edu.pl/images/OI21/waz-en-tex.10.png) for ![](http://main.edu.pl/images/OI21/waz-en-tex.11.png)).\n\nIf ![](http://main.edu.pl/images/OI21/waz-en-tex.12.png), then ![](http://main.edu.pl/images/OI21/waz-en-tex.13.png) is the number of the snake's segment  occupying the ![](http://main.edu.pl/images/OI21/waz-en-tex.14.png)-th square of the ![](http://main.edu.pl/images/OI21/waz-en-tex.15.png)-th row of the board.\n\nIf on the other hand ![](http://main.edu.pl/images/OI21/waz-en-tex.16.png), then the number of the snake's segment  on this square is unknown.\n\nIn tests worth 15% of the total score ![](http://main.edu.pl/images/OI21/waz-en-tex.17.png) holds,  in those worth 40% of the total score ![](http://main.edu.pl/images/OI21/waz-en-tex.18.png) holds,  and finally, in those worth 70% of the total score ![](http://main.edu.pl/images/OI21/waz-en-tex.19.png) holds.\n\n在标准输入的第一行中，有一个整数n（1<=n<=1000），即板的长度。\n\n\n下面三行描述木板的情况，第i行是n个整数aij（0<=aij<=3n）(1<=j<=n)。\n\n\n如果aij大于0，那么aij就是蛇段的第aij部分\n\n\n如果aij=0，那么这个蛇段就是我们不知道的\n", "outputFormat": "Your program is to print three lines to the standard output.\n\nThe ![](http://main.edu.pl/images/OI21/waz-en-tex.20.png)-th lines should hold ![](http://main.edu.pl/images/OI21/waz-en-tex.21.png) positive integers ![](http://main.edu.pl/images/OI21/waz-en-tex.22.png) (for ![](http://main.edu.pl/images/OI21/waz-en-tex.23.png)).\n\nAll the numbers ![](http://main.edu.pl/images/OI21/waz-en-tex.24.png) together should be a permutation of the numbers from ![](http://main.edu.pl/images/OI21/waz-en-tex.25.png) to ![](http://main.edu.pl/images/OI21/waz-en-tex.26.png).\n\nThe output numbers should be a valid reconstruction of the snake, i.e., they should  be consistent with the (positive) input numbers and satisfy aforementioned constraints.\n\nYou may assume that there is at least one valid reconstruction of the snake.\n\nIf there is more than one, your program can print any valid reconstruction.\n\n将所有aij为0的蛇段补齐\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2014] WAZ-Snake", "background": "# Description\n\nA snake fills a $3 \\times n$ board completely. The snake is divided into segments numbered from $1$ to $3n$. Consecutive segments (i.e., $k$ and $k+1$) must occupy squares that share an edge. Some segment numbers on the board are erased. Can you reconstruct the snake?\n\nConstraints: $1 \\le n \\le 1000$.", "description": "A snake fills a $3 \\times n$ board completely. The snake is divided into segments numbered from $1$ to $3n$. Consecutive segments (i.e., $k$ and $k+1$) must occupy squares that share an edge. Some segment numbers on the board are erased. Can you reconstruct the snake?\n\nConstraints: $1 \\le n \\le 1000$.\n\n# Description", "inputFormat": "The first line contains an integer $n$ ($1 \\le n \\le 1000$), the length of the board.\n\nThe next three lines describe the board. The $i$-th of these lines contains $n$ integers $a_{i j}$ ($0 \\le a_{i j} \\le 3n$) for $1 \\le j \\le n$.\n\nIf $a_{i j} > 0$, then $a_{i j}$ is the number of the snake’s segment occupying the $j$-th square of the $i$-th row. If $a_{i j} = 0$, then the number on this square is unknown.\n\nIt is guaranteed that there is at least one valid reconstruction.", "outputFormat": "Print three lines. The $i$-th line should contain $n$ positive integers $b_{i j}$ ($1 \\le j \\le n$).\n\nAll numbers $b_{i j}$ together must form a permutation of $1, 2, \\dots, 3n$. For every $(i, j)$ with $a_{i j} > 0$, it must hold that $b_{i j} = a_{i j}$. Moreover, for every $k$ from $1$ to $3n-1$, the squares containing $k$ and $k+1$ must share an edge.\n\nIf multiple solutions exist, output any of them.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2014] WAZ-Snake", "background": "", "description": "A snake fills a ![](http://main.edu.pl/images/OI21/waz-en-tex.1.png) board completely.\n\nSuccessive segments of the snake are numbered from ![](http://main.edu.pl/images/OI21/waz-en-tex.2.png) to ![](http://main.edu.pl/images/OI21/waz-en-tex.3.png).\n\nThe segments with successive numbers (i.e., 1 and 2, 2 and 3, 3 and 4...) occupy squares  that share an edge.\n\nFor example, a snake can fill a ![](http://main.edu.pl/images/OI21/waz-en-tex.4.png) board as follows:\n\nThe snake's segment numbers in some of the squares have been erased.\n\n  Can you reconstruct the snake?\n\n一只蛇被放在了一块3\\*n的木板上（填充满了），蛇被分为多个小段，小段的编号是1到3n。比如说蛇可以填写一个3\\*9的木板，如下所示：\n\n\n部分木板上的蛇段已删遮挡。\n\n\n你能重建蛇吗？\n", "inputFormat": "In the first line of the standard input, there is a single integer ![](http://main.edu.pl/images/OI21/waz-en-tex.5.png)  (![](http://main.edu.pl/images/OI21/waz-en-tex.6.png)), the length of the board.\n\nThe three lines that follow describe the board;  the ![](http://main.edu.pl/images/OI21/waz-en-tex.7.png)-th of them contains ![](http://main.edu.pl/images/OI21/waz-en-tex.8.png) integers ![](http://main.edu.pl/images/OI21/waz-en-tex.9.png)  (![](http://main.edu.pl/images/OI21/waz-en-tex.10.png) for ![](http://main.edu.pl/images/OI21/waz-en-tex.11.png)).\n\nIf ![](http://main.edu.pl/images/OI21/waz-en-tex.12.png), then ![](http://main.edu.pl/images/OI21/waz-en-tex.13.png) is the number of the snake's segment  occupying the ![](http://main.edu.pl/images/OI21/waz-en-tex.14.png)-th square of the ![](http://main.edu.pl/images/OI21/waz-en-tex.15.png)-th row of the board.\n\nIf on the other hand ![](http://main.edu.pl/images/OI21/waz-en-tex.16.png), then the number of the snake's segment  on this square is unknown.\n\nIn tests worth 15% of the total score ![](http://main.edu.pl/images/OI21/waz-en-tex.17.png) holds,  in those worth 40% of the total score ![](http://main.edu.pl/images/OI21/waz-en-tex.18.png) holds,  and finally, in those worth 70% of the total score ![](http://main.edu.pl/images/OI21/waz-en-tex.19.png) holds.\n\n在标准输入的第一行中，有一个整数n（1<=n<=1000），即板的长度。\n\n\n下面三行描述木板的情况，第i行是n个整数aij（0<=aij<=3n）(1<=j<=n)。\n\n\n如果aij大于0，那么aij就是蛇段的第aij部分\n\n\n如果aij=0，那么这个蛇段就是我们不知道的\n", "outputFormat": "Your program is to print three lines to the standard output.\n\nThe ![](http://main.edu.pl/images/OI21/waz-en-tex.20.png)-th lines should hold ![](http://main.edu.pl/images/OI21/waz-en-tex.21.png) positive integers ![](http://main.edu.pl/images/OI21/waz-en-tex.22.png) (for ![](http://main.edu.pl/images/OI21/waz-en-tex.23.png)).\n\nAll the numbers ![](http://main.edu.pl/images/OI21/waz-en-tex.24.png) together should be a permutation of the numbers from ![](http://main.edu.pl/images/OI21/waz-en-tex.25.png) to ![](http://main.edu.pl/images/OI21/waz-en-tex.26.png).\n\nThe output numbers should be a valid reconstruction of the snake, i.e., they should  be consistent with the (positive) input numbers and satisfy aforementioned constraints.\n\nYou may assume that there is at least one valid reconstruction of the snake.\n\nIf there is more than one, your program can print any valid reconstruction.\n\n将所有aij为0的蛇段补齐\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3569", "type": "P", "difficulty": 5, "samples": [["4\n2 5\n3 4\n6 3\n2 7\n2\n3 4\n1 3\n", "NIE\nTAK\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2014", "线段树", "POI（波兰）"], "title": "[POI 2014] KAR-Cards", "background": "", "description": "There are $n$ cards arranged on a table in a certain order.\n\nTwo integers are written on each card, one per side: the obverse and the reverse.\n\nInitially all cards lie with the averse facing up.\n\nByteasar, The Great Illusionist, intends to perform (multiple times!) his signature    Binary Search Card Manipulation.  However, to present it, he needs the sequence of numbers    as seen on the cards to be non-decreasing.\n\nThus, Byteasar may have to turn over some cards so that the numbers on their reverse sides    become visible.\n\nFurthermore, the illusion requires a participant from the audience.\n\nAlas, some of the volunteers are deployed by Byteasar's competitors who want him to fail.\n\nEach such supposititious volunteer, upon entering the scene, would swap two cards on the table in a lightning move of a hand.  After each such swap, Byteasar can again turn over any cards he desires but nevertheless, he may not be able to perform his great illusion.\n\nIf that were to happen, he would be forced to turn to traditional illusions, such as pulling a rabbit out of a hat.\n\nWrite a program that determines, after each card swap, if Byteasar can perform his great illusion.\n\n有一些卡牌，正反各有一个数，你可以任意翻转，每次操作会将两张卡牌的位置调换，你需要在每次操作后回答以现在的卡牌顺序能否通过反转形成一个单调不降的序列\n", "inputFormat": "In the first line of the standard input, there is a single integer, $n$ ($2\\le n\\le 200\\ 000$), the number of the cards.\n\nThe $n$ lines that follow describe the cards, one per line,in the order they are arranged on the table.\n\nThe $i$-th of these lines has two integers $x_i$ and $y_i$ ($0\\le x_i,y_i\\le 10^7$), separated by a single space.\n\nThese are the numbers written on the $i$-th card:\n\n$x_i$ is the one written on the obverse and $y_i$ the one on the reverse.\n\nThe initial sequence of cards may not allow performing the great illusion.\n\nAfterwards, there is a line with a single integer $m$ ($1\\le m\\le 1\\ 000\\ 000$), the number of card swaps.The $m$ lines that follow describe the swaps: $j$-th of these lines has two integers $a_j$ and $b_j$ ($1\\le a_j,b_j\\le n$), separated by a single space, indicating that the $j$-th (supposititious) volunteer will swap the $a_j$-th and the $b_j$-th cards.\n", "outputFormat": "Your program should print $m$ lines to the standard output, each containing a single word:\n\nTAK (Polish for yes) or NIE (Polish for no).\n\nThe $j$-th line should read TAK if Byteasar can obtain a non-decreasing sequence      of numbers by turning the cards over after the $j$-th card swap.  If he cannot,      the line should read NIE.\n", "hint": "有一些卡牌，正反各有一个数，你可以任意翻转，每次操作会将两张卡牌的位置调换，你需要在每次操作后回答以现在的卡牌顺序能否通过反转形成一个单调不降的序列\n", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2014] KAR-Cards", "background": "", "description": "There are $n$ cards arranged on a table in a fixed order.\n\nEach card has two integers, one on each side: the obverse and the reverse. The $i$-th card has $x_i$ on the obverse and $y_i$ on the reverse. Initially, all cards lie with the obverse side up.\n\nByteasar, the Great Illusionist, wants the sequence of visible numbers on the cards to be non-decreasing. He may flip any subset of cards to show the other side.\n\nHowever, an audience participant will repeatedly swap two cards on the table. After each such swap, Byteasar may again flip any cards, but he might still be unable to achieve a non-decreasing sequence. After each swap, determine whether it is possible to obtain a non-decreasing sequence of visible numbers by flipping cards as needed.", "inputFormat": "The first line contains a single integer $n$ ($2 \\le n \\le 200\\ 000$), the number of cards.\n\nThe next $n$ lines describe the cards, in their current order on the table. The $i$-th of these lines contains two integers $x_i$ and $y_i$ ($0 \\le x_i, y_i \\le 10^7$), separated by a single space, where $x_i$ is written on the obverse and $y_i$ on the reverse of the $i$-th card.\n\nThe initial sequence of cards may not allow forming a non-decreasing sequence.\n\nAfterwards, there is a line with a single integer $m$ ($1 \\le m \\le 1\\ 000\\ 000$), the number of card swaps. The next $m$ lines describe the swaps: the $j$-th of these lines has two integers $a_j$ and $b_j$ ($1 \\le a_j, b_j \\le n$), indicating that the $j$-th participant swaps the $a_j$-th and $b_j$-th cards.", "outputFormat": "Print $m$ lines. On the $j$-th line, print TAK (Polish for yes) if, after the $j$-th swap, Byteasar can obtain a non-decreasing sequence of visible numbers by flipping any subset of cards; otherwise, print NIE (Polish for no).", "hint": "There are several cards, each with a number on both sides. You may flip any cards. Each operation swaps two cards’ positions. After each operation, determine whether, with the current card order, flipping some cards can form a non-decreasing sequence.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2014] KAR-Cards", "background": "", "description": "There are $n$ cards arranged on a table in a certain order.\n\nTwo integers are written on each card, one per side: the obverse and the reverse.\n\nInitially all cards lie with the averse facing up.\n\nByteasar, The Great Illusionist, intends to perform (multiple times!) his signature    Binary Search Card Manipulation.  However, to present it, he needs the sequence of numbers    as seen on the cards to be non-decreasing.\n\nThus, Byteasar may have to turn over some cards so that the numbers on their reverse sides    become visible.\n\nFurthermore, the illusion requires a participant from the audience.\n\nAlas, some of the volunteers are deployed by Byteasar's competitors who want him to fail.\n\nEach such supposititious volunteer, upon entering the scene, would swap two cards on the table in a lightning move of a hand.  After each such swap, Byteasar can again turn over any cards he desires but nevertheless, he may not be able to perform his great illusion.\n\nIf that were to happen, he would be forced to turn to traditional illusions, such as pulling a rabbit out of a hat.\n\nWrite a program that determines, after each card swap, if Byteasar can perform his great illusion.\n\n有一些卡牌，正反各有一个数，你可以任意翻转，每次操作会将两张卡牌的位置调换，你需要在每次操作后回答以现在的卡牌顺序能否通过反转形成一个单调不降的序列\n", "inputFormat": "In the first line of the standard input, there is a single integer, $n$ ($2\\le n\\le 200\\ 000$), the number of the cards.\n\nThe $n$ lines that follow describe the cards, one per line,in the order they are arranged on the table.\n\nThe $i$-th of these lines has two integers $x_i$ and $y_i$ ($0\\le x_i,y_i\\le 10^7$), separated by a single space.\n\nThese are the numbers written on the $i$-th card:\n\n$x_i$ is the one written on the obverse and $y_i$ the one on the reverse.\n\nThe initial sequence of cards may not allow performing the great illusion.\n\nAfterwards, there is a line with a single integer $m$ ($1\\le m\\le 1\\ 000\\ 000$), the number of card swaps.The $m$ lines that follow describe the swaps: $j$-th of these lines has two integers $a_j$ and $b_j$ ($1\\le a_j,b_j\\le n$), separated by a single space, indicating that the $j$-th (supposititious) volunteer will swap the $a_j$-th and the $b_j$-th cards.\n", "outputFormat": "Your program should print $m$ lines to the standard output, each containing a single word:\n\nTAK (Polish for yes) or NIE (Polish for no).\n\nThe $j$-th line should read TAK if Byteasar can obtain a non-decreasing sequence      of numbers by turning the cards over after the $j$-th card swap.  If he cannot,      the line should read NIE.\n", "hint": "有一些卡牌，正反各有一个数，你可以任意翻转，每次操作会将两张卡牌的位置调换，你需要在每次操作后回答以现在的卡牌顺序能否通过反转形成一个单调不降的序列\n", "locale": "zh-CN"}}}
{"pid": "P3570", "type": "P", "difficulty": 6, "samples": [["15 7\n2 5 6 2 4 7 3 3 2 3 7 5 3 6 2\n3 2\n4 7 3\n5 3\n", "3\n7 8 10\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2014", "线性数据结构", "POI（波兰）", "枚举"], "title": "[POI 2014] PRZ-Criminals", "background": "", "description": "Byteburg is a beautiful town by a river.\n\nThere are $n$ houses along the river, numbered downstream with successive integers from $1$ to $n$.\n\nByteburg used to be a nice quiet town in which everyone was happy.\n\nAlas, this changed recently, as two dangerous criminals - Bitie and Bytie set up shop in it.\n\nThey did so many robberies already that the citizens are afraid to leave their houses.\n\nBitie and Bytie do no mere burglaries but rather whole raids: each time they leave their houses and walk towards each other, never turning back.\n\nBitie walks downstream (towards larger numbers) while Bytie walks upstream (towards smaller numbers).\n\nAlong the way, before they meet, each chooses several houses to break into and steal precious items    (and vital data).\n\nAfter the robberies they meet in a house and divide their loot.\n\nByteburgers are sick of this already - they would all rather have their tranquility restored.\n\nSo they asked the detective Bythony for help.\n\nThe detective established that the bandits live in houses of the same color but he does not know which one.\n\nJust a moment ago, an anonymous tip claimed that the robbers are on a raid.\n\nFearing for their own safety, the source did not say which houses will be broken into.\n\nThey did however specify their colors.\n\nAs it turns out, the bandits are quite superstitious - each of them will rob a house of each color at most once.\n\nBythony can wait no longer.\n\nHe intends to ambush the criminals at their meeting place.\n\nAid Bythony in his undertaking by writing a program to find all possible meeting places of the robbers.\n", "inputFormat": "There are two integers in the first line of the standard input, $n$ and $k$ ($3\\le n\\le 1\\ 000\\ 000$, $1\\le k\\le 1\\ 000\\ 000$, $k\\le n$),  separated by a single space, that specify the number of houses and the number of house colors  in Byteburg respectively.\n\nThe colors are number with successive integers from $1$ to $k$.\n\nIn the second line of input, there is a sequence of $n$ integers, $c_1,c_2,\\cdots,c_n$ ($1\\le c_i\\le k$), separated by single spaces.\n\nThese are the colors of successive houses in Byteburg.\n\nIn the third line of input, there are two integers $m$ and $l$($1\\le m,l\\le n$,$m+l\\le n-1$), separated by a single space, specifying the numbers of houses (to be) broken into by Bitie and Bytie respectively. In the fourth line of input, there are $m$ pairwise different integers $x_1,x_2,\\cdots,x_m$($1\\le x_i\\le k$), separated by single spaces. These are the colors of houses robbed by Bitie in the order of being broken into (i.e., excluding Bitie's house). In the fifth, which is the last, line of input, there are $l$ pairwise different integers $y_1,y_2,\\cdots,y_l$ ($1\\le y_i\\le k$), separated by single spaces. These are the colors of houses robbed by Bytie in the order of being broken into (again, these do not include Bytie's house). Moreover, $x_m=y_l$ is the color of the house in which the robbers will divide the plunder. (Clearly, they have to break into that one as well!)\n", "outputFormat": "Your program it to print exactly two lines to the standard output.\n\nThe first of those should give the number of houses in which the criminals can meet  while respecting aforementioned constraints.\n\nThe second line should contain the increasing sequence of the numbers of those houses,  separated by single spaces.\n\nIf the robbers cannot meet at all, the first line should contain the number 0 while the second one should be empty.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2014] PRZ-Criminals", "background": "", "description": "Byteburg is a beautiful town by a river.\n\nThere are $n$ houses along the river, numbered downstream with successive integers from $1$ to $n$.\n\nByteburg used to be a nice quiet town in which everyone was happy.\n\nAlas, this changed recently, as two dangerous criminals - Bitie and Bytie set up shop in it.\n\nThey did so many robberies already that the citizens are afraid to leave their houses.\n\nBitie and Bytie do no mere burglaries but rather whole raids: each time they leave their houses and walk towards each other, never turning back.\n\nBitie walks downstream (towards larger numbers) while Bytie walks upstream (towards smaller numbers).\n\nAlong the way, before they meet, each chooses several houses to break into and steal precious items    (and vital data).\n\nAfter the robberies they meet in a house and divide their loot.\n\nByteburgers are sick of this already - they would all rather have their tranquility restored.\n\nSo they asked the detective Bythony for help.\n\nThe detective established that the bandits live in houses of the same color but he does not know which one.\n\nJust a moment ago, an anonymous tip claimed that the robbers are on a raid.\n\nFearing for their own safety, the source did not say which houses will be broken into.\n\nThey did however specify their colors.\n\nAs it turns out, the bandits are quite superstitious - each of them will rob a house of each color at most once.\n\nBythony can wait no longer.\n\nHe intends to ambush the criminals at their meeting place.\n\nAid Bythony in his undertaking by writing a program to find all possible meeting places of the robbers.\n", "inputFormat": "There are two integers in the first line of the standard input, $n$ and $k$ ($3\\le n\\le 1\\ 000\\ 000$, $1\\le k\\le 1\\ 000\\ 000$, $k\\le n$),  separated by a single space, that specify the number of houses and the number of house colors  in Byteburg respectively.\n\nThe colors are number with successive integers from $1$ to $k$.\n\nIn the second line of input, there is a sequence of $n$ integers, $c_1,c_2,\\cdots,c_n$ ($1\\le c_i\\le k$), separated by single spaces.\n\nThese are the colors of successive houses in Byteburg.\n\nIn the third line of input, there are two integers $m$ and $l$($1\\le m,l\\le n$,$m+l\\le n-1$), separated by a single space, specifying the numbers of houses (to be) broken into by Bitie and Bytie respectively. In the fourth line of input, there are $m$ pairwise different integers $x_1,x_2,\\cdots,x_m$($1\\le x_i\\le k$), separated by single spaces. These are the colors of houses robbed by Bitie in the order of being broken into (i.e., excluding Bitie's house). In the fifth, which is the last, line of input, there are $l$ pairwise different integers $y_1,y_2,\\cdots,y_l$ ($1\\le y_i\\le k$), separated by single spaces. These are the colors of houses robbed by Bytie in the order of being broken into (again, these do not include Bytie's house). Moreover, $x_m=y_l$ is the color of the house in which the robbers will divide the plunder. (Clearly, they have to break into that one as well!)\n", "outputFormat": "Your program it to print exactly two lines to the standard output.\n\nThe first of those should give the number of houses in which the criminals can meet  while respecting aforementioned constraints.\n\nThe second line should contain the increasing sequence of the numbers of those houses,  separated by single spaces.\n\nIf the robbers cannot meet at all, the first line should contain the number 0 while the second one should be empty.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2014] PRZ-Criminals", "background": "", "description": "两个罪犯 Bitie 和 Bytie 抢劫 $n$ 个房子，每个房子有一个颜色，Bitie 从低编号到高编号，Bytie 从高编号到低编号，直到相遇为止。已知罪犯开始时所在房子颜色相同（但不知道是什么颜色），并且知道罪犯依次抢劫的所有房子的颜色，且每个罪犯对每种颜色的房子分别最多抢劫一次，求所有可能的相遇点。", "inputFormat": "第一行两个整数 $n,k$ ，分别表示房子的个数和不同的颜色数。颜色以从 $1$ 到 $k$ 的整数标号。\n\n接下来一行有 $n$ 个整数 $c_1,c_2,...,c_n (1 \\le c_i \\le k)$，表示房子的颜色。\n\n第三行有两个整数 $m,l (1 \\le m,l \\le n,m+l \\le n-1)$，分别表示 Bitie 和 Bytie 抢劫房子的个数。\n\n第四行有 $m$ 个两两不同的整数 $x_1, x_2, ..., x_m (1 \\le x_i \\le k)$，表示 Bitie 抢劫房子的颜色（不包括 Bitie 开始时所在房子的颜色）。\n\n第五行有 $l$ 个两两不同的整数 $y_1, y_2, ..., y_l (1 \\le y_i \\le k)$，表示 Bytie 抢劫房子的颜色 （不包括 Bytie 开始时所在房子的颜色）。\n\n保证 $x_m = y_l$。", "outputFormat": "输出两行，第一行一个整数，表示可能相遇的房子个数，第二行升序输出可能相遇的房子编号。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3571", "type": "P", "difficulty": 7, "samples": [["20 1\n3\n1 1 1 3 4 3 2 8 6 9 10 12 12 13 14 11 11 11 11\n", "8\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "POI（波兰）", "斜率优化", "凸包"], "title": "[POI 2014] SUP-Supercomputer", "background": "", "description": "Byteasar has designed a supercomputer of novel architecture.\n\n```plain\nIt may comprise of many (identical) processing units.\n```\nEach processing unit can execute a single instruction per time unit.\n\nThe programs for this computer are not sequential but rather have a tree structure.\n\nEach instruction may have zero, one, or multiple subsequent instructions,    for which it is the parent instruction.\n\nThe instructions of the program can be executed in parallel on all available    processing units.  Moreover, they can be executed in many orders: the only    restriction is that an instruction cannot be executed unless its parent    instruction has been executed before.  For example, as many subsequent    instructions of an instruction that has been executed already can be    executed in parallel as there are processing units.\n\nByteasar has a certain program to run.  Since he likes utilizing his resources    optimally, he is wondering how the number of processing units would affect the running time.\n\nHe asks you to determine, for a given program and number of processing units,    the minimum execution time of the program on a supercomputer with this many processing units.\n\n给定一棵N个节点的有根树，根节点为1。Q次询问，每次给定一个K，用最少的操作次数遍历完整棵树，输出最少操作次数。每次操作可以选择访问不超过K个未访问的点，且这些点的父亲必须在之前被访问过。\n", "inputFormat": "In the first line of standard input, there are two integers, $n$ and $q$ ($1\\le n,q\\le 1\\ 000\\ 000$), separated by a single space, that specify the number of    instructions in Byteasar's program and the number of running time queries (for different numbers    of processing units).\n\nIn the second line of input, there is a sequence of $q$ integers, $k_1,k_2,\\cdots,k_q$ ($1\\le k_i\\le 1\\ 000\\ 000$), separated by single spaces: $k_i$ is the number of processing units in    Byteasar's $i$-th query.\n\nIn the third and last input line, there is a sequence of $n-1$ integers, $a_2,a_3,\\cdots,a_n$($1\\le a_i<i$) separated by single spaces: $a_i$ specifies the number of the parent instruction of the instruction number $i$. The instructions are numbered with successive integers from 1 to $n$, where the instruction no. 1 is the first instruction of the program.\n", "outputFormat": "Your program should print one line consisting of $q$ integers, separated by single spaces,    to the standard output:\n\nthe $i$-th of these numbers should specify the minimum execution time of the program on a supercomputer with $k_i$ processing units.\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2014] SUP-Supercomputer", "background": "", "description": "Byteasar has designed a supercomputer of novel architecture.\n\n```plain\nIt may comprise of many (identical) processing units.\n```\nEach processing unit can execute a single instruction per time unit.\n\nThe programs for this computer are not sequential but rather have a tree structure.\n\nEach instruction may have zero, one, or multiple subsequent instructions, for which it is the parent instruction.\n\nThe instructions of the program can be executed in parallel on all available processing units. Moreover, they can be executed in many orders: the only restriction is that an instruction cannot be executed unless its parent instruction has been executed before. For example, as many subsequent instructions of an instruction that has been executed already can be executed in parallel as there are processing units.\n\nByteasar has a certain program to run. Since he likes utilizing his resources optimally, he is wondering how the number of processing units would affect the running time.\n\nHe asks you to determine, for a given program and number of processing units, the minimum execution time of the program on a supercomputer with this many processing units.\n\nEquivalent formulation: You are given a rooted tree with $n$ nodes, with root $1$. There are $q$ queries; in each query, a number $k$ is given. In one step, you may visit up to $k$ unvisited vertices whose parents have already been visited. Find the minimum number of steps needed to visit the whole tree for each given $k$.", "inputFormat": "In the first line of standard input, there are two integers, $n$ and $q$ ($1\\le n, q\\le 1\\,000\\,000$), separated by a single space, that specify the number of instructions in Byteasar's program and the number of running time queries (for different numbers of processing units).\n\nIn the second line of input, there is a sequence of $q$ integers, $k_1, k_2, \\ldots, k_q$ ($1\\le k_i\\le 1\\,000\\,000$), separated by single spaces: $k_i$ is the number of processing units in Byteasar's $i$-th query.\n\nIn the third and last input line, there is a sequence of $n-1$ integers, $a_2, a_3, \\ldots, a_n$ ($1\\le a_i<i$) separated by single spaces: $a_i$ specifies the number of the parent instruction of instruction number $i$. The instructions are numbered with successive integers from $1$ to $n$, where instruction no. $1$ is the first instruction of the program.", "outputFormat": "Your program should print one line consisting of $q$ integers, separated by single spaces: the $i$-th of these numbers should specify the minimum execution time of the program on a supercomputer with $k_i$ processing units.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2014] SUP-Supercomputer", "background": "", "description": "Byteasar has designed a supercomputer of novel architecture.\n\n```plain\nIt may comprise of many (identical) processing units.\n```\nEach processing unit can execute a single instruction per time unit.\n\nThe programs for this computer are not sequential but rather have a tree structure.\n\nEach instruction may have zero, one, or multiple subsequent instructions,    for which it is the parent instruction.\n\nThe instructions of the program can be executed in parallel on all available    processing units.  Moreover, they can be executed in many orders: the only    restriction is that an instruction cannot be executed unless its parent    instruction has been executed before.  For example, as many subsequent    instructions of an instruction that has been executed already can be    executed in parallel as there are processing units.\n\nByteasar has a certain program to run.  Since he likes utilizing his resources    optimally, he is wondering how the number of processing units would affect the running time.\n\nHe asks you to determine, for a given program and number of processing units,    the minimum execution time of the program on a supercomputer with this many processing units.\n\n给定一棵N个节点的有根树，根节点为1。Q次询问，每次给定一个K，用最少的操作次数遍历完整棵树，输出最少操作次数。每次操作可以选择访问不超过K个未访问的点，且这些点的父亲必须在之前被访问过。\n", "inputFormat": "In the first line of standard input, there are two integers, $n$ and $q$ ($1\\le n,q\\le 1\\ 000\\ 000$), separated by a single space, that specify the number of    instructions in Byteasar's program and the number of running time queries (for different numbers    of processing units).\n\nIn the second line of input, there is a sequence of $q$ integers, $k_1,k_2,\\cdots,k_q$ ($1\\le k_i\\le 1\\ 000\\ 000$), separated by single spaces: $k_i$ is the number of processing units in    Byteasar's $i$-th query.\n\nIn the third and last input line, there is a sequence of $n-1$ integers, $a_2,a_3,\\cdots,a_n$($1\\le a_i<i$) separated by single spaces: $a_i$ specifies the number of the parent instruction of the instruction number $i$. The instructions are numbered with successive integers from 1 to $n$, where the instruction no. 1 is the first instruction of the program.\n", "outputFormat": "Your program should print one line consisting of $q$ integers, separated by single spaces,    to the standard output:\n\nthe $i$-th of these numbers should specify the minimum execution time of the program on a supercomputer with $k_i$ processing units.\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3572", "type": "P", "difficulty": 4, "samples": [["9\n4 6 3 6 3 7 2 6 5\n2\n2\n5\n", "2\n1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2014", "单调队列", "POI（波兰）"], "title": "[POI 2014] PTA-Little Bird", "background": "", "description": "In the Byteotian Line Forest there are $n$ trees in a row.\n\nOn top of the first one, there is a little bird who would like to fly over to the top of the last tree.\n\nBeing in fact very little, the bird might lack the strength to fly there without any stop.\n\nIf the bird is sitting on top of the tree no. i, then in a single flight leg it can fly toany of the trees no. $i+1,i+2,\\cdots,i+k$, and then has to rest afterward.\n\nMoreover, flying up is far harder to flying down.  A flight leg is tiresome if it ends in a tree at leastas high as the one where is started.  Otherwise the flight leg is not tiresome.\n\nThe goal is to select the trees on which the little bird will land so that the overall flight is leasttiresome, i.e., it has the minimum number of tiresome legs.\n\nWe note that birds are social creatures, and our bird has a few bird-friends who would also like to getfrom the first tree to the last one.  The stamina of all the birds varies,so the bird's friends may have different values of the parameter $k$.\n\nHelp all the birds, little and big!", "inputFormat": "There is a single integer $n$ ($2\\le n\\le 1\\ 000\\ 000$) in the first line of the standard input:\n\nthe number of trees in the Byteotian Line Forest.\n\nThe second line of input holds $n$ integers $d_1,d_2,\\cdots,d_n$ ($1\\le d_i\\le 10^9$)separated by single spaces: $d_i$ is the height of the i-th tree.\n\nThe third line of the input holds a single integer $q$ ($1\\le q\\le 25$): the number of birds whoseflights need to be planned.\n\nThe following $q$ lines describe these birds: in the $i$-th of these lines, there is an integer $k_i$ ($1\\le k_i\\le n-1$) specifying the $i$-th bird's stamina. In other words, the maximum number of trees that the $i$-th bird can pass before it has to rest is $k_i-1$.\n", "outputFormat": "Your program should print exactly $q$ lines to the standard output.\n\nIn the $i$-th line, it should specify the minimum number of tiresome flight legs of the $i$-th bird.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2014] PTA-Little Bird", "background": "", "description": "In the Byteotian Line Forest there are $n$ trees in a row.\n\nOn top of the first one, there is a little bird who would like to fly over to the top of the last tree.\n\nBeing in fact very little, the bird might lack the strength to fly there without any stop.\n\nIf the bird is sitting on top of the tree no. i, then in a single flight leg it can fly toany of the trees no. $i+1,i+2,\\cdots,i+k$, and then has to rest afterward.\n\nMoreover, flying up is far harder to flying down.  A flight leg is tiresome if it ends in a tree at leastas high as the one where is started.  Otherwise the flight leg is not tiresome.\n\nThe goal is to select the trees on which the little bird will land so that the overall flight is leasttiresome, i.e., it has the minimum number of tiresome legs.\n\nWe note that birds are social creatures, and our bird has a few bird-friends who would also like to getfrom the first tree to the last one.  The stamina of all the birds varies,so the bird's friends may have different values of the parameter $k$.\n\nHelp all the birds, little and big!", "inputFormat": "There is a single integer $n$ ($2\\le n\\le 1\\ 000\\ 000$) in the first line of the standard input:\n\nthe number of trees in the Byteotian Line Forest.\n\nThe second line of input holds $n$ integers $d_1,d_2,\\cdots,d_n$ ($1\\le d_i\\le 10^9$)separated by single spaces: $d_i$ is the height of the i-th tree.\n\nThe third line of the input holds a single integer $q$ ($1\\le q\\le 25$): the number of birds whoseflights need to be planned.\n\nThe following $q$ lines describe these birds: in the $i$-th of these lines, there is an integer $k_i$ ($1\\le k_i\\le n-1$) specifying the $i$-th bird's stamina. In other words, the maximum number of trees that the $i$-th bird can pass before it has to rest is $k_i-1$.\n", "outputFormat": "Your program should print exactly $q$ lines to the standard output.\n\nIn the $i$-th line, it should specify the minimum number of tiresome flight legs of the $i$-th bird.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2014] PTA-Little Bird", "background": "", "description": "有 $n$ 棵树排成一排，第 $i$ 棵树的高度是 $d_i$。\n\n有 $q$ 只鸟要从第 $1$ 棵树到第 $n$ 棵树。\n\n当第 $i$ 只鸟在第 $j$ 棵树时，它可以飞到第 $j+1, j+2, \\cdots, j+k_i$ 棵树。\n\n如果一只鸟飞到一颗高度大于等于当前树的树，那么它的劳累值会增加 $1$，否则不会。\n\n由于这些鸟已经体力不支，所以它们想要最小化劳累值。", "inputFormat": "第一行输入 $n$。\n\n第二行 $n$ 个数，第 $i$ 个数表示 $d_i$。\n\n第三行输入 $q$。\n\n接下来 $q$ 行，每一行一个整数，第 $i$ 行的整数为 $k_i$。", "outputFormat": "共 $q$ 行，每一行输出第 $i$ 只鸟的最小劳累值。", "hint": "$1 \\le n \\le 10^6$，$1 \\le d_i \\le 10^9$，$1 \\le q \\le 25$，$1 \\le k_i \\le n - 1$。", "locale": "zh-CN"}}}
