{"pid": "P2146", "type": "P", "difficulty": 5, "samples": [["7\n0 0 0 1 1 5\n5\ninstall 5\ninstall 6\nuninstall 1\ninstall 4\nuninstall 0", "3\n1\n3\n2\n3"], ["10\n0 1 2 1 3 0 0 3 2\n10\ninstall 0\ninstall 3\nuninstall 2\ninstall 7\ninstall 5\ninstall 9\nuninstall 9\ninstall 4\ninstall 1\ninstall 9", "1\n3\n2\n1\n3\n1\n1\n1\n0\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["树形数据结构", "2015", "线段树", "颜色段均摊（珂朵莉树 ODT）", "NOI", "深度优先搜索 DFS", "树链剖分"], "title": "[NOI2015] 软件包管理器", "background": "Linux 用户和 OSX 用户一定对软件包管理器不会陌生。通过软件包管理器，你可以通过一行命令安装某一个软件包，然后软件包管理器会帮助你从软件源下载软件包，同时自动解决所有的依赖（即下载安装这个软件包的安装所依赖的其它软件包），完成所有的配置。Debian/Ubuntu 使用的 apt-get，Fedora/CentOS 使用的 yum，以及 OSX 下可用的 homebrew 都是优秀的软件包管理器。", "description": "你决定设计你自己的软件包管理器。不可避免地，你要解决软件包之间的依赖问题。如果软件包 $a$ 依赖软件包 $b$，那么安装软件包 $a$ 以前，必须先安装软件包 $b$。同时，如果想要卸载软件包 $b$，则必须卸载软件包 $a$。\n\n现在你已经获得了所有的软件包之间的依赖关系。而且，由于你之前的工作，除 $0$ 号软件包以外，在你的管理器当中的软件包都会依赖一个且仅一个软件包，而 $0$ 号软件包不依赖任何一个软件包。且依赖关系不存在环（即不会存在 $m$ 个软件包 $a_1,a_2, \\dots , a_m$，对于 $i<m$，$a_i$ 依赖 $a_{i+1}$，而 $a_m$ 依赖 $a_1$ 的情况）。\n\n现在你要为你的软件包管理器写一个依赖解决程序。根据反馈，用户希望在安装和卸载某个软件包时，快速地知道这个操作实际上会改变多少个软件包的安装状态（即安装操作会安装多少个未安装的软件包，或卸载操作会卸载多少个已安装的软件包），你的任务就是实现这个部分。\n\n注意，安装一个已安装的软件包，或卸载一个未安装的软件包，都不会改变任何软件包的安装状态，即在此情况下，改变安装状态的软件包数为 $0$。", "inputFormat": "第一行一个正整数 $n$，表示软件包个数，从 $0$ 开始编号。  \n第二行有 $n-1$ 个整数，第 $i$ 个表示 $i$ 号软件包依赖的软件包编号。  \n然后一行一个正整数 $q$，表示操作个数，格式如下：  \n\n- `install x` 表示安装 $x$ 号软件包\n- `uninstall x` 表示卸载 $x$ 号软件包\n\n一开始所有软件包都是未安装的。  \n\n对于每个操作，你需要输出这步操作会改变多少个软件包的安装状态，随后应用这个操作（即改变你维护的安装状态）。", "outputFormat": "输出 $q$ 行，每行一个整数，表示每次询问的答案。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/1504.png)  \n一开始所有软件包都处于未安装状态。\n\n安装 $5$ 号软件包，需要安装 $0,1,5$ 三个软件包。\n\n之后安装 $6$ 号软件包，只需要安装 $6$ 号软件包。此时安装了 $0,1,5,6$ 四个软件包。\n\n卸载 $1$ 号软件包需要卸载 $1,5,6$ 三个软件包。此时只有 $0$ 号软件包还处于安装状态。\n\n之后安装 $4$ 号软件包，需要安装 $1,4$ 两个软件包。此时 $0,1,4$ 处在安装状态。最后，卸载 $0$ 号软件包会卸载所有的软件包。\n\n**【数据范围】**\n\n::cute-table{tuack}\n\n| 测试点编号 | $$n$$ 的规模      | $$q$$ 的规模      | 备注 |\n|:----------:|:----------------:|:----------------:|:----:|\n| $1$          | ${n = 5{,}000}$  | ${q = 5{,}000}$  |      |\n| $2$          | ^                | ^                | ^    |\n| $3$          | ${n = 100{,}000}$| ${q = 100{,}000}$| 数据不包含卸载操作 |\n| $4$          | ^                | ^                | ^    |\n| $5$          | ${n = 100{,}000}$| ${q = 100{,}000}$ | 编号为 $i$ 的软件包所依赖的软件包编号在 $[0,i - 1]$ 内均匀随机，每次执行操作的软件包编号在 $[0,n-1]$ 内均匀随机 |\n| $6$          | ^                | ^                | ^ |\n| $7$          | ^                | ^                | ^    |\n| $8$          | ^                | ^                | ^    |\n| $9$          | ${n = 100{,}000}$| ${q = 100{,}000}$ |     |\n| $10$         | ^                | ^                | ^   |\n| $11$         | ^                | ^                | ^    |\n| $12$         | ^                | ^                | ^    |\n| $13$         | ^                | ^                | ^    |\n| $14$         | ^                | ^                | ^    |\n| $15$         | ^                | ^                | ^    |\n| $16$         | ^                | ^                | ^    |\n| $17$         | ^                | ^                | ^    |\n| $18$         | ^                | ^                | ^    |\n| $19$         | ^                | ^                | ^    |\n| $20$         | ^                | ^                | ^    |", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2015] Software Package Manager", "background": "Linux users and OSX users are certainly familiar with package managers. With a package manager, you can install a package with a single command. The package manager will download the package from repositories and automatically resolve all dependencies (that is, download and install other packages required for this package), and finish all configurations. apt-get for Debian/Ubuntu, yum for Fedora/CentOS, and homebrew on OSX are all excellent package managers.", "description": "You decide to design your own package manager. Inevitably, you must handle dependencies between packages. If package $a$ depends on package $b$, then before installing package $a$, you must first install package $b$. Likewise, if you want to uninstall package $b$, you must uninstall package $a$.\n\nNow you have obtained all dependency relations among packages. Moreover, due to your previous design, every package in your manager except package $0$ depends on exactly one package, and package $0$ depends on none. The dependency relations contain no cycles (i.e., there do not exist $m$ packages $a_1, a_2, \\dots, a_m$ such that for $i < m$, $a_i$ depends on $a_{i+1}$, and $a_m$ depends on $a_1$).\n\nYou now need to write a dependency resolver for your package manager. According to user feedback, when installing or uninstalling a package, users want to quickly know how many packages will actually change their installation state as a result of the operation (that is, how many currently uninstalled packages will be installed by an install operation, or how many currently installed packages will be uninstalled by an uninstall operation). Your task is to implement this part.\n\nNote that installing an already installed package, or uninstalling a package that is not installed, will not change any installation state. In this case, the number of packages whose installation state changes is $0$.", "inputFormat": "The first line contains a positive integer $n$, the number of packages, numbered starting from $0$.  \nThe second line contains $n - 1$ integers; the $i$-th integer denotes the package ID that package $i$ depends on.  \nThen a line with a positive integer $q$ follows, denoting the number of operations, in the following format:\n\n- `install x` means install package $x$.\n- `uninstall x` means uninstall package $x$.\n\nInitially, all packages are not installed.\n\nFor each operation, you need to output how many packages will change their installation state because of this step, and then apply the operation (i.e., update the installation states you maintain).", "outputFormat": "Output $q$ lines, each containing an integer, which is the answer for each query.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/1504.png)  \nInitially, all packages are not installed.\n\nTo install package $5$, you need to install packages $0, 1, 5$.\n\nAfter that, installing package $6$ only requires installing package $6$. At this point, packages $0, 1, 5, 6$ are installed.\n\nUninstalling package $1$ requires uninstalling packages $1, 5, 6$. Now only package $0$ remains installed.\n\nNext, installing package $4$ requires installing packages $1, 4$. Now packages $0, 1, 4$ are installed. Finally, uninstalling package $0$ will uninstall all packages.\n\n**Constraints**\n\n::cute-table{tuack}\n\n| Test point ID | $$n$$ size          | $$q$$ size          | Notes |\n|:-------------:|:-------------------:|:-------------------:|:-----:|\n| $1$           | ${n = 5{,}000}$     | ${q = 5{,}000}$     |       |\n| $2$           | ^                   | ^                   | ^     |\n| $3$           | ${n = 100{,}000}$   | ${q = 100{,}000}$   | testdata does not include uninstall operations |\n| $4$           | ^                   | ^                   | ^     |\n| $5$           | ${n = 100{,}000}$   | ${q = 100{,}000}$   | For package $i$, the ID of the package it depends on is uniformly random in $[0, i - 1]$, and the package ID in each operation is uniformly random in $[0, n - 1]$. |\n| $6$           | ^                   | ^                   | ^ |\n| $7$           | ^                   | ^                   | ^     |\n| $8$           | ^                   | ^                   | ^     |\n| $9$           | ${n = 100{,}000}$   | ${q = 100{,}000}$   |       |\n| $10$          | ^                   | ^                   | ^     |\n| $11$          | ^                   | ^                   | ^     |\n| $12$          | ^                   | ^                   | ^     |\n| $13$          | ^                   | ^                   | ^     |\n| $14$          | ^                   | ^                   | ^     |\n| $15$          | ^                   | ^                   | ^     |\n| $16$          | ^                   | ^                   | ^     |\n| $17$          | ^                   | ^                   | ^     |\n| $18$          | ^                   | ^                   | ^     |\n| $19$          | ^                   | ^                   | ^     |\n| $20$          | ^                   | ^                   | ^     |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2015] 软件包管理器", "background": "Linux 用户和 OSX 用户一定对软件包管理器不会陌生。通过软件包管理器，你可以通过一行命令安装某一个软件包，然后软件包管理器会帮助你从软件源下载软件包，同时自动解决所有的依赖（即下载安装这个软件包的安装所依赖的其它软件包），完成所有的配置。Debian/Ubuntu 使用的 apt-get，Fedora/CentOS 使用的 yum，以及 OSX 下可用的 homebrew 都是优秀的软件包管理器。", "description": "你决定设计你自己的软件包管理器。不可避免地，你要解决软件包之间的依赖问题。如果软件包 $a$ 依赖软件包 $b$，那么安装软件包 $a$ 以前，必须先安装软件包 $b$。同时，如果想要卸载软件包 $b$，则必须卸载软件包 $a$。\n\n现在你已经获得了所有的软件包之间的依赖关系。而且，由于你之前的工作，除 $0$ 号软件包以外，在你的管理器当中的软件包都会依赖一个且仅一个软件包，而 $0$ 号软件包不依赖任何一个软件包。且依赖关系不存在环（即不会存在 $m$ 个软件包 $a_1,a_2, \\dots , a_m$，对于 $i<m$，$a_i$ 依赖 $a_{i+1}$，而 $a_m$ 依赖 $a_1$ 的情况）。\n\n现在你要为你的软件包管理器写一个依赖解决程序。根据反馈，用户希望在安装和卸载某个软件包时，快速地知道这个操作实际上会改变多少个软件包的安装状态（即安装操作会安装多少个未安装的软件包，或卸载操作会卸载多少个已安装的软件包），你的任务就是实现这个部分。\n\n注意，安装一个已安装的软件包，或卸载一个未安装的软件包，都不会改变任何软件包的安装状态，即在此情况下，改变安装状态的软件包数为 $0$。", "inputFormat": "第一行一个正整数 $n$，表示软件包个数，从 $0$ 开始编号。  \n第二行有 $n-1$ 个整数，第 $i$ 个表示 $i$ 号软件包依赖的软件包编号。  \n然后一行一个正整数 $q$，表示操作个数，格式如下：  \n\n- `install x` 表示安装 $x$ 号软件包\n- `uninstall x` 表示卸载 $x$ 号软件包\n\n一开始所有软件包都是未安装的。  \n\n对于每个操作，你需要输出这步操作会改变多少个软件包的安装状态，随后应用这个操作（即改变你维护的安装状态）。", "outputFormat": "输出 $q$ 行，每行一个整数，表示每次询问的答案。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/1504.png)  \n一开始所有软件包都处于未安装状态。\n\n安装 $5$ 号软件包，需要安装 $0,1,5$ 三个软件包。\n\n之后安装 $6$ 号软件包，只需要安装 $6$ 号软件包。此时安装了 $0,1,5,6$ 四个软件包。\n\n卸载 $1$ 号软件包需要卸载 $1,5,6$ 三个软件包。此时只有 $0$ 号软件包还处于安装状态。\n\n之后安装 $4$ 号软件包，需要安装 $1,4$ 两个软件包。此时 $0,1,4$ 处在安装状态。最后，卸载 $0$ 号软件包会卸载所有的软件包。\n\n**【数据范围】**\n\n::cute-table{tuack}\n\n| 测试点编号 | $$n$$ 的规模      | $$q$$ 的规模      | 备注 |\n|:----------:|:----------------:|:----------------:|:----:|\n| $1$          | ${n = 5{,}000}$  | ${q = 5{,}000}$  |      |\n| $2$          | ^                | ^                | ^    |\n| $3$          | ${n = 100{,}000}$| ${q = 100{,}000}$| 数据不包含卸载操作 |\n| $4$          | ^                | ^                | ^    |\n| $5$          | ${n = 100{,}000}$| ${q = 100{,}000}$ | 编号为 $i$ 的软件包所依赖的软件包编号在 $[0,i - 1]$ 内均匀随机，每次执行操作的软件包编号在 $[0,n-1]$ 内均匀随机 |\n| $6$          | ^                | ^                | ^ |\n| $7$          | ^                | ^                | ^    |\n| $8$          | ^                | ^                | ^    |\n| $9$          | ${n = 100{,}000}$| ${q = 100{,}000}$ |     |\n| $10$         | ^                | ^                | ^   |\n| $11$         | ^                | ^                | ^    |\n| $12$         | ^                | ^                | ^    |\n| $13$         | ^                | ^                | ^    |\n| $14$         | ^                | ^                | ^    |\n| $15$         | ^                | ^                | ^    |\n| $16$         | ^                | ^                | ^    |\n| $17$         | ^                | ^                | ^    |\n| $18$         | ^                | ^                | ^    |\n| $19$         | ^                | ^                | ^    |\n| $20$         | ^                | ^                | ^    |", "locale": "zh-CN"}}}
{"pid": "P2147", "type": "P", "difficulty": 6, "samples": [["200 5\nQuery 123 127\nConnect 123 127\nQuery 123 127\nDestroy 127 123\nQuery 123 127", "No\nYes\nNo\n"], ["3 5\nConnect 1 2\nConnect 3 1\nQuery 2 3\nDestroy 1 3\nQuery 2 3", "Yes\nNo"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "各省省选", "平衡树", "山东", "动态树 LCT", "线段树分治"], "title": "[SDOI2008] 洞穴勘测", "background": null, "description": "辉辉热衷于洞穴勘测。\n\n某天，他按照地图来到了一片被标记为 JSZX 的洞穴群地区。经过初步勘测，辉辉发现这片区域由 $n$ 个洞穴（分别编号为 $1$ 到 $n$）以及若干通道组成，并且每条通道连接了恰好两个洞穴。假如两个洞穴可以通过一条或者多条通道按一定顺序连接起来，那么这两个洞穴就是连通的，按顺序连接在一起的这些通道则被称之为这两个洞穴之间的一条路径。洞穴都十分坚固无法破坏，然而通道不太稳定，时常因为外界影响而发生改变，比如，根据有关仪器的监测结果，$123$ 号洞穴和 $127$ 号洞穴之间有时会出现一条通道，有时这条通道又会因为某种稀奇古怪的原因被毁。\n\n辉辉有一台监测仪器可以实时将通道的每一次改变状况在辉辉手边的终端机上显示：\n\n- 如果监测到洞穴 $u$ 和洞穴 $v$ 之间出现了一条通道（**保证原来没有**），终端机上会显示一条指令 `Connect u v`。\n- 如果监测到洞穴 $u$ 和洞穴 $v$ 之间的通道被毁（**保证原来存在**），终端机上会显示一条指令 `Destroy u v`。\n\n经过长期的艰苦卓绝的手工推算，辉辉发现一个奇怪的现象：无论通道怎么改变，任意时刻任意两个洞穴之间至多只有一条路径。\n\n因而，辉辉坚信这是由于某种本质规律的支配导致的。因而，辉辉更加夜以继日地坚守在终端机之前，试图通过通道的改变情况来研究这条本质规律。然而，终于有一天，辉辉在堆积成山的演算纸中崩溃了……他把终端机往地面一砸（终端机也足够坚固无法破坏），转而求助于你，说道：“你老兄把这程序写写吧。”\n\n辉辉希望能随时通过终端机发出指令 `Query u v`，向监测仪询问此时洞穴 $u$ 和洞穴 $v$ 是否连通。现在你要为他编写程序回答每一次询问。已知在第一条指令显示之前，JSZX 洞穴群中没有任何通道存在。", "inputFormat": "第一行为两个正整数 $n$ 和 $m$，分别表示洞穴的个数和终端机上出现过的指令的个数。\n\n以下 $m$ 行，依次表示终端机上出现的各条指令：\n\n- 每行开头是一个表示指令种类的字符串 $S$。\n- 之后有两个整数 $u,v$，分别表示两个洞穴的编号。", "outputFormat": "对每个 `Query` 指令，输出洞穴 $u$ 和洞穴 $v$ 是否互相连通：连通输出 `Yes`，不连通输出 `No`。", "hint": "对于 $(i \\times 10)\\%$ 的数据，$n \\le i \\times 10^3$，$m \\le 2i \\times 10^4$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10^4$，$1 \\le m \\le 2 \\times 10^5$，$1 \\le u,v \\le n$，所有指令都是合法的。\n\n本题 I/O 规模比较大，建议 C/C++ 选手使用 `scanf` 和 `printf` 进行 I/O 操作以免超时。\n\n---\n\n@namespace_std 于 2019.12.1 添加一组 Hack 数据", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2008] Cave Exploration", "background": "", "description": "Huihui is enthusiastic about cave exploration.\n\nOne day, following a map, he arrived at an area marked as JSZX, which is a cluster of caves. After a preliminary survey, Huihui found that this area consists of $n$ caves (numbered from $1$ to $n$) and several tunnels, where each tunnel connects exactly two caves. If two caves can be connected in order by one or more tunnels, then these two caves are said to be connected, and the sequence of tunnels connected in order is called a path between the two caves. The caves are very solid and cannot be destroyed, but the tunnels are unstable and often change due to external influences. For example, according to the monitoring device, sometimes a tunnel appears between cave $123$ and cave $127$, and sometimes this tunnel is destroyed for some odd reason.\n\nHuihui has a monitoring device that can display every change to the tunnels on the terminal at his side:\n\n- If a tunnel appears between cave $u$ and cave $v$ (guaranteed that it did not previously exist), the terminal displays the instruction `Connect u v`.\n- If the tunnel between cave $u$ and cave $v$ is destroyed (guaranteed that it previously existed), the terminal displays the instruction `Destroy u v`.\n\nAfter long and arduous manual calculations, Huihui discovered a strange phenomenon: no matter how the tunnels change, at any time there is at most one path between any two caves.\n\nTherefore, he is convinced that this is governed by some essential rule. He kept working day and night in front of the terminal, trying to study this rule through the changes in the tunnels. However, one day he finally collapsed among the piles of scratch paper... He smashed the terminal onto the ground (the terminal is also solid and cannot be destroyed) and turned to you for help, saying: “Please write this program for me.”\n\nHuihui wants to be able to issue the instruction `Query u v` at any time to ask the monitor whether cave $u$ and cave $v$ are currently connected. Now you need to write a program to answer each query. It is known that before the first instruction appears, there are no tunnels in the JSZX cave cluster.", "inputFormat": "The first line contains two positive integers $n$ and $m$, representing the number of caves and the number of instructions shown on the terminal.\n\nThe following $m$ lines describe the instructions that appear on the terminal in order:\n- Each line begins with a string $S$ indicating the type of instruction.\n- Then there are two integers $u, v$, representing the indices of the two caves.", "outputFormat": "For each `Query` instruction, output whether cave $u$ and cave $v$ are connected: output `Yes` if connected, otherwise output `No`.", "hint": "Constraints:\n- For $ (i \\times 10)\\% $ of the testdata, $n \\le i \\times 10^3$, $m \\le 2 i \\times 10^4$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 10^4$, $1 \\le m \\le 2 \\times 10^5$, $1 \\le u, v \\le n$, and all instructions are valid.\n\nThe I/O scale is large. It is recommended that C/C++ users use `scanf` and `printf` for I/O to avoid timeouts.\n\n@namespace_std added a set of hack testdata on 2019.12.1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2008] 洞穴勘测", "background": null, "description": "辉辉热衷于洞穴勘测。\n\n某天，他按照地图来到了一片被标记为 JSZX 的洞穴群地区。经过初步勘测，辉辉发现这片区域由 $n$ 个洞穴（分别编号为 $1$ 到 $n$）以及若干通道组成，并且每条通道连接了恰好两个洞穴。假如两个洞穴可以通过一条或者多条通道按一定顺序连接起来，那么这两个洞穴就是连通的，按顺序连接在一起的这些通道则被称之为这两个洞穴之间的一条路径。洞穴都十分坚固无法破坏，然而通道不太稳定，时常因为外界影响而发生改变，比如，根据有关仪器的监测结果，$123$ 号洞穴和 $127$ 号洞穴之间有时会出现一条通道，有时这条通道又会因为某种稀奇古怪的原因被毁。\n\n辉辉有一台监测仪器可以实时将通道的每一次改变状况在辉辉手边的终端机上显示：\n\n- 如果监测到洞穴 $u$ 和洞穴 $v$ 之间出现了一条通道（**保证原来没有**），终端机上会显示一条指令 `Connect u v`。\n- 如果监测到洞穴 $u$ 和洞穴 $v$ 之间的通道被毁（**保证原来存在**），终端机上会显示一条指令 `Destroy u v`。\n\n经过长期的艰苦卓绝的手工推算，辉辉发现一个奇怪的现象：无论通道怎么改变，任意时刻任意两个洞穴之间至多只有一条路径。\n\n因而，辉辉坚信这是由于某种本质规律的支配导致的。因而，辉辉更加夜以继日地坚守在终端机之前，试图通过通道的改变情况来研究这条本质规律。然而，终于有一天，辉辉在堆积成山的演算纸中崩溃了……他把终端机往地面一砸（终端机也足够坚固无法破坏），转而求助于你，说道：“你老兄把这程序写写吧。”\n\n辉辉希望能随时通过终端机发出指令 `Query u v`，向监测仪询问此时洞穴 $u$ 和洞穴 $v$ 是否连通。现在你要为他编写程序回答每一次询问。已知在第一条指令显示之前，JSZX 洞穴群中没有任何通道存在。", "inputFormat": "第一行为两个正整数 $n$ 和 $m$，分别表示洞穴的个数和终端机上出现过的指令的个数。\n\n以下 $m$ 行，依次表示终端机上出现的各条指令：\n\n- 每行开头是一个表示指令种类的字符串 $S$。\n- 之后有两个整数 $u,v$，分别表示两个洞穴的编号。", "outputFormat": "对每个 `Query` 指令，输出洞穴 $u$ 和洞穴 $v$ 是否互相连通：连通输出 `Yes`，不连通输出 `No`。", "hint": "对于 $(i \\times 10)\\%$ 的数据，$n \\le i \\times 10^3$，$m \\le 2i \\times 10^4$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10^4$，$1 \\le m \\le 2 \\times 10^5$，$1 \\le u,v \\le n$，所有指令都是合法的。\n\n本题 I/O 规模比较大，建议 C/C++ 选手使用 `scanf` 和 `printf` 进行 I/O 操作以免超时。\n\n---\n\n@namespace_std 于 2019.12.1 添加一组 Hack 数据", "locale": "zh-CN"}}}
{"pid": "P2148", "type": "P", "difficulty": 5, "samples": [["2\n4\n1 2 3 1\n6\n1 1 1 1 1 1\n", "YES\nNO\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["博弈论", "2009", "各省省选", "山东", "枚举", "位运算", "SG 函数"], "title": "[SDOI2009] E&D", "background": "", "description": "小 E 与小 W 进行一项名为 `E&D` 游戏。\n\n游戏的规则如下：桌子上有 $2n$ 堆石子，编号为 $1 \\sim 2n$。其中，为了方便起见，我们将第 $2k-1$ 堆与第 $2k$ 堆（$1 \\le k \\le n$）视为同一组。第 $i$ 堆的石子个数用一个正整数 $S_i$ 表示。\n\n一次分割操作指的是，从桌子上任取一堆石子，将其移走。然后分割它同一组的另一堆石子，从中取出若干个石子放在被移走的位置，组成新的一堆。操作完成后，所有堆的石子数必须保证大于 $0$。显然，被分割的一堆的石子数至少要为 $2$。两个人轮流进行分割操作。如果轮到某人进行操作时，所有堆的石子数均为 $1$，则此时没有石子可以操作，判此人输掉比赛。\n\n小 E 进行第一次分割。他想知道，是否存在某种策略使得他一定能战胜小 W。因此，他求助于小 F，也就是你，请你告诉他是否存在必胜策略。例如，假设初始时桌子上有 $4$ 堆石子，数量分别为 $1,2,3,1$。小 E 可以选择移走第 $1$ 堆，然后将第 $2$ 堆分割（只能分出 $1$ 个石子）。接下来，小 W 只能选择移走第 $4$ 堆，然后将第 $3$ 堆分割为 $1$ 和 $2$。最后轮到小 E，他只能移走后两堆中数量为 $1$ 的一堆，将另一堆分割为 $1$ 和 $1$。这样，轮到小 W 时，所有堆的数量均为 $1$，则他输掉了比赛。故小 E 存在必胜策略。", "inputFormat": "**本题有多组数据。**\n\n第一行一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n第一行一个整数 $N$，表示桌子上共有 $N$ 堆石子，这里的 $N$ 即为题目描述中的 $2n$。\n\n第二行 $N$ 个整数 $S_{1 \\dots N}$。", "outputFormat": "对于每组数据，如果小 E 必胜，则一行一个字符串 `YES`，否则一行一个字符串 `NO`。\n\n", "hint": "对于 $20\\%$ 的数据，$N=2$。\n\n对于另外 $20\\%$ 的数据，$N \\le 4$，$S_i \\le 50$。\n\n对于 $100\\%$ 的数据，$1 \\le T \\le 20$，$1 \\le N \\le 2 \\times 10^4$ 且 $N$ 为偶数，$1 \\le S_i \\le 2 \\times 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2009] E&D", "background": "", "description": "E and W play a game called `E&D`.\n\nThe rules are as follows: There are $2n$ piles of stones on the table, numbered $1 \\sim 2n$. For convenience, we regard pile $2k-1$ and pile $2k$ ($1 \\le k \\le n$) as one group. The number of stones in pile $i$ is a positive integer $S_i$.\n\nOne split operation is defined as follows: choose any pile of stones and remove it from the table. Then split the other pile in the same group, take some stones from it, and place them at the removed position to form a new pile. After the operation, the number of stones in every pile must be greater than $0$. Obviously, the pile being split must contain at least $2$ stones. The two players alternate performing split operations. If, on a player's turn, all piles have exactly $1$ stone, then no move is possible and that player loses.\n\nE makes the first move. He wants to know whether there exists a strategy that guarantees he can defeat W. Therefore, he asks F (you) to tell him whether a winning strategy exists. For example, suppose initially there are $4$ piles with sizes $1,2,3,1$. E can choose to remove pile $1$, then split pile $2$ (he can only split off $1$ stone). Next, W can only remove pile $4$, then split pile $3$ into $1$ and $2$. Finally, it is E's turn; he can only remove the pile of size $1$ among the last two piles, and split the other into $1$ and $1$. Thus, when it is W's turn, all piles have size $1$, so he loses. Therefore, E has a winning strategy.", "inputFormat": "**There are multiple test cases in this problem.**\n\nThe first line contains an integer $T$, the number of test cases.\n\nFor each test case:\n\nThe first line contains an integer $N$, the total number of piles on the table; here $N$ is the $2n$ from the problem description.\n\nThe second line contains $N$ integers $S_{1 \\dots N}$.", "outputFormat": "For each test case, if E has a winning strategy, output a single string `YES`; otherwise, output a single string `NO`.", "hint": "For $20\\%$ of the testdata, $N=2$.\n\nFor another $20\\%$ of the testdata, $N \\le 4$, $S_i \\le 50$.\n\nFor $100\\%$ of the testdata, $1 \\le T \\le 20$, $1 \\le N \\le 2 \\times 10^4$ and $N$ is even, $1 \\le S_i \\le 2 \\times 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2009] E&D", "background": "", "description": "小 E 与小 W 进行一项名为 `E&D` 游戏。\n\n游戏的规则如下：桌子上有 $2n$ 堆石子，编号为 $1 \\sim 2n$。其中，为了方便起见，我们将第 $2k-1$ 堆与第 $2k$ 堆（$1 \\le k \\le n$）视为同一组。第 $i$ 堆的石子个数用一个正整数 $S_i$ 表示。\n\n一次分割操作指的是，从桌子上任取一堆石子，将其移走。然后分割它同一组的另一堆石子，从中取出若干个石子放在被移走的位置，组成新的一堆。操作完成后，所有堆的石子数必须保证大于 $0$。显然，被分割的一堆的石子数至少要为 $2$。两个人轮流进行分割操作。如果轮到某人进行操作时，所有堆的石子数均为 $1$，则此时没有石子可以操作，判此人输掉比赛。\n\n小 E 进行第一次分割。他想知道，是否存在某种策略使得他一定能战胜小 W。因此，他求助于小 F，也就是你，请你告诉他是否存在必胜策略。例如，假设初始时桌子上有 $4$ 堆石子，数量分别为 $1,2,3,1$。小 E 可以选择移走第 $1$ 堆，然后将第 $2$ 堆分割（只能分出 $1$ 个石子）。接下来，小 W 只能选择移走第 $4$ 堆，然后将第 $3$ 堆分割为 $1$ 和 $2$。最后轮到小 E，他只能移走后两堆中数量为 $1$ 的一堆，将另一堆分割为 $1$ 和 $1$。这样，轮到小 W 时，所有堆的数量均为 $1$，则他输掉了比赛。故小 E 存在必胜策略。", "inputFormat": "**本题有多组数据。**\n\n第一行一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n第一行一个整数 $N$，表示桌子上共有 $N$ 堆石子，这里的 $N$ 即为题目描述中的 $2n$。\n\n第二行 $N$ 个整数 $S_{1 \\dots N}$。", "outputFormat": "对于每组数据，如果小 E 必胜，则一行一个字符串 `YES`，否则一行一个字符串 `NO`。\n\n", "hint": "对于 $20\\%$ 的数据，$N=2$。\n\n对于另外 $20\\%$ 的数据，$N \\le 4$，$S_i \\le 50$。\n\n对于 $100\\%$ 的数据，$1 \\le T \\le 20$，$1 \\le N \\le 2 \\times 10^4$ 且 $N$ 为偶数，$1 \\le S_i \\le 2 \\times 10^9$。", "locale": "zh-CN"}}}
{"pid": "P2149", "type": "P", "difficulty": 5, "samples": [["9 10\n1 6 7 8\n1 2 1\n2 5 2\n2 3 3\n3 4 2\n3 9 5\n4 5 3\n4 6 4\n4 7 2\n5 8 1\n7 9 1", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2009", "各省省选", "山东", "拓扑排序", "最短路"], "title": "[SDOI2009] Elaxia的路线", "background": null, "description": "最近，Elaxia 和 w** 的关系特别好，他们很想整天在一起，但是大学的学习太紧张了，他们必须合理地安排两个人在一起的时间。\n\nElaxia 和 w** 每天都要奔波于宿舍和实验室之间，他们希望在节约时间的前提下，一起走的时间尽可能的长。\n\n现在已知的是 Elaxia 和 w** 所在的宿舍和实验室的编号以及学校的地图：  \n\n地图上有 $n$ 个路口，$m$ 条路，经过每条路都需要一定的时间。 具体地说，就是要求无向图中，两对点间最短路的最长公共路径。\n\n**注意**：本题公共路径行走方向可以不同，依照形式化题意为准。", "inputFormat": "第一行两个正整数 $n,m$，表示点数和边数。\n  \n第二行四个正整数 $x_1,y_1,x_2,y_2$，分别表示 Elaxia 的宿舍和实验室及 w** 的宿舍和实验室的标号。\n\n接下来 $m$ 行，每行三个整数 $u,v,w$，表示 $u,v$之间有一条边，需要 $w$ 的时间经过。", "outputFormat": "一行一个整数表示答案。（即最长公共路径的长度）", "hint": "【数据范围】    \n对于 $30\\%$ 的数据，$1\\le n \\le 100$；   \n对于 $60\\%$ 的数据，$1\\le n \\le 1000$；   \n对于 $100\\%$ 的数据，$1\\le n \\le 1500$，$1 \\leq m \\leq 3 \\times 10^5$，$1\\le w \\le 10^4$，输入数据保证没有重边和自环。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2009] Elaxia's Route", "background": "", "description": "Recently, Elaxia and w** have become very close. They want to be together all day, but university studies are intense, so they must plan their time together wisely.\n\nElaxia and w** commute daily between their dormitories and laboratories. They hope to maximize the time they walk together while still minimizing their own travel time.\n\nYou are given the IDs of Elaxia's dormitory and laboratory and w**'s dormitory and laboratory, as well as the school map: the map has $n$ intersections and $m$ roads, and traversing each road takes a certain amount of time. Specifically, on an undirected graph, find the longest common path shared by the shortest paths between two pairs of vertices.", "inputFormat": "The first line contains two positive integers $n,m$, the numbers of vertices and edges.\n\nThe second line contains four positive integers $x_1,y_1,x_2,y_2$, which are the IDs of Elaxia's dormitory and laboratory, and w**'s dormitory and laboratory, respectively.\n\nEach of the next $m$ lines contains three integers $u,v,w$, meaning there is an edge between $u$ and $v$, and it takes $w$ time to traverse.", "outputFormat": "Output a single integer, the length of the longest common path.", "hint": "Constraints  \nFor $30\\%$ of the testdata, $1\\le n \\le 100$.  \nFor $60\\%$ of the testdata, $1\\le n \\le 1000$.  \nFor $100\\%$ of the testdata, $1\\le n \\le 1500$, $1 \\leq m \\leq 3 \\times 10^5$, $1\\le w \\le 10^4$. The input guarantees there are no multiple edges or self-loops.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2009] Elaxia的路线", "background": null, "description": "最近，Elaxia 和 w** 的关系特别好，他们很想整天在一起，但是大学的学习太紧张了，他们必须合理地安排两个人在一起的时间。\n\nElaxia 和 w** 每天都要奔波于宿舍和实验室之间，他们希望在节约时间的前提下，一起走的时间尽可能的长。\n\n现在已知的是 Elaxia 和 w** 所在的宿舍和实验室的编号以及学校的地图：  \n\n地图上有 $n$ 个路口，$m$ 条路，经过每条路都需要一定的时间。 具体地说，就是要求无向图中，两对点间最短路的最长公共路径。\n\n**注意**：本题公共路径行走方向可以不同，依照形式化题意为准。", "inputFormat": "第一行两个正整数 $n,m$，表示点数和边数。\n  \n第二行四个正整数 $x_1,y_1,x_2,y_2$，分别表示 Elaxia 的宿舍和实验室及 w** 的宿舍和实验室的标号。\n\n接下来 $m$ 行，每行三个整数 $u,v,w$，表示 $u,v$之间有一条边，需要 $w$ 的时间经过。", "outputFormat": "一行一个整数表示答案。（即最长公共路径的长度）", "hint": "【数据范围】    \n对于 $30\\%$ 的数据，$1\\le n \\le 100$；   \n对于 $60\\%$ 的数据，$1\\le n \\le 1000$；   \n对于 $100\\%$ 的数据，$1\\le n \\le 1500$，$1 \\leq m \\leq 3 \\times 10^5$，$1\\le w \\le 10^4$，输入数据保证没有重边和自环。", "locale": "zh-CN"}}}
{"pid": "P2150", "type": "P", "difficulty": 6, "samples": [["3 10000", "9"], ["4 10000", "21"], ["100 100000000", "3107203"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "数学", "2015", "NOI", "素数判断,质数,筛法", "根号分治", "状压 DP"], "title": "[NOI2015] 寿司晚宴", "background": "", "description": "为了庆祝 NOI 的成功开幕，主办方为大家准备了一场寿司晚宴。小 G 和小 W 作为参加 NOI 的选手，也被邀请参加了寿司晚宴。\n\n在晚宴上，主办方为大家提供了 $n−1$ 种不同的寿司，编号 $1,2,3,\\ldots,n-1$，其中第 $i$ 种寿司的美味度为 $i+1$。（即寿司的美味度为从 $2$ 到 $n$）\n\n现在小 G 和小 W 希望每人选一些寿司种类来品尝，他们规定一种品尝方案为不和谐的当且仅当：**小 G 品尝的寿司种类中存在一种美味度为 $x$ 的寿司，小 W 品尝的寿司中存在一种美味度为 $y$ 的寿司，而 $x$ 与 $y$ 不互质。**\n\n现在小 G 和小 W 希望统计一共有多少种和谐的品尝寿司的方案（对给定的正整数 $p$ 取模）。注意一个人可以不吃任何寿司。", "inputFormat": "输入文件的第 $1$ 行包含 $2$ 个正整数 $n, p$ 中间用单个空格隔开，表示共有 $n$ 种寿司，最终和谐的方案数要对 $p$ 取模。", "outputFormat": "输出一行包含 $1$ 个整数，表示所求的方案模 $p$ 的结果。", "hint": "【数据范围】\n\n::cute-table{tuack}\n\n| 测试点编号  | $n$ 的规模  | 约定  |\n|:-:|:-:|:-:|\n| $1$  | $2\\le n\\le 30$  | $0 < p \\le 1{,}000{,}000{,}000$  |\n| $2$  |^  |^  |\n| $3$  |^  |^  |\n| $4$  | $2\\le n\\le 100$  |^  |\n| $5$  |^  |^  |\n| $6$  | $2\\le n\\le 200$  |^  |\n| $7$  |^  |^  |\n| $8$  | $2\\le n\\le 500$  |^  |\n| $9$  |^  |^  |\n| $10$  |^  |^  |", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2015] Sushi Dinner", "background": "", "description": "To celebrate the successful opening of NOI, the organizers prepared a sushi dinner. Xiao G and Xiao W, as NOI contestants, were invited to attend.\n\nAt the dinner, the organizers provided $n - 1$ different types of sushi, numbered $1, 2, 3, \\ldots, n - 1$, where the tastiness of the $i$-th type is $i + 1$ (that is, tastiness values range from $2$ to $n$).\n\nNow Xiao G and Xiao W each want to choose some types of sushi to taste. A tasting plan is called discordant if and only if: there exists a sushi with tastiness $x$ chosen by Xiao G and a sushi with tastiness $y$ chosen by Xiao W such that $x$ and $y$ are not coprime.\n\nThey want to count how many harmonious tasting plans there are (i.e., plans that are not discordant), modulo a given positive integer $p$. Note that a person may choose no sushi.", "inputFormat": "The first line contains two positive integers $n, p$ separated by a single space. There are $n - 1$ types of sushi in total, with tastiness values from $2$ to $n$, and the final answer should be taken modulo $p$.", "outputFormat": "Output a single integer, which is the number of harmonious plans modulo $p$.", "hint": "[Constraints]\n\n| Test point ID | Range of $n$        | Convention                          |\n|:-------------:|:--------------------:|:------------------------------------:|\n| 1             | $2 \\le n \\le 30$    | $0 < p \\le 1{,}000{,}000{,}000$     |\n| 2             | Same as above.       | Same as above.                       |\n| 3             | Same as above.       | Same as above.                       |\n| 4             | $2 \\le n \\le 100$   | Same as above.                       |\n| 5             | Same as above.       | Same as above.                       |\n| 6             | $2 \\le n \\le 200$   | Same as above.                       |\n| 7             | Same as above.       | Same as above.                       |\n| 8             | $2 \\le n \\le 500$   | Same as above.                       |\n| 9             | Same as above.       | Same as above.                       |\n| 10            | Same as above.       | Same as above.                       |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2015] 寿司晚宴", "background": "", "description": "为了庆祝 NOI 的成功开幕，主办方为大家准备了一场寿司晚宴。小 G 和小 W 作为参加 NOI 的选手，也被邀请参加了寿司晚宴。\n\n在晚宴上，主办方为大家提供了 $n−1$ 种不同的寿司，编号 $1,2,3,\\ldots,n-1$，其中第 $i$ 种寿司的美味度为 $i+1$。（即寿司的美味度为从 $2$ 到 $n$）\n\n现在小 G 和小 W 希望每人选一些寿司种类来品尝，他们规定一种品尝方案为不和谐的当且仅当：**小 G 品尝的寿司种类中存在一种美味度为 $x$ 的寿司，小 W 品尝的寿司中存在一种美味度为 $y$ 的寿司，而 $x$ 与 $y$ 不互质。**\n\n现在小 G 和小 W 希望统计一共有多少种和谐的品尝寿司的方案（对给定的正整数 $p$ 取模）。注意一个人可以不吃任何寿司。", "inputFormat": "输入文件的第 $1$ 行包含 $2$ 个正整数 $n, p$ 中间用单个空格隔开，表示共有 $n$ 种寿司，最终和谐的方案数要对 $p$ 取模。", "outputFormat": "输出一行包含 $1$ 个整数，表示所求的方案模 $p$ 的结果。", "hint": "【数据范围】\n\n::cute-table{tuack}\n\n| 测试点编号  | $n$ 的规模  | 约定  |\n|:-:|:-:|:-:|\n| $1$  | $2\\le n\\le 30$  | $0 < p \\le 1{,}000{,}000{,}000$  |\n| $2$  |^  |^  |\n| $3$  |^  |^  |\n| $4$  | $2\\le n\\le 100$  |^  |\n| $5$  |^  |^  |\n| $6$  | $2\\le n\\le 200$  |^  |\n| $7$  |^  |^  |\n| $8$  | $2\\le n\\le 500$  |^  |\n| $9$  |^  |^  |\n| $10$  |^  |^  |", "locale": "zh-CN"}}}
{"pid": "P2151", "type": "P", "difficulty": 6, "samples": [["4 5 3 0 0\n0 1\n0 2\n0 3\n2 1\n3 2", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "2009", "各省省选", "山东", "矩阵乘法", "构造"], "title": "[SDOI2009] HH 去散步", "background": "", "description": "HH 有个一成不变的习惯，喜欢饭后百步走。所谓百步走，就是散步，就是在一定的时间内，走过一定的距离。但是同时 HH 又是个喜欢变化的人，所以他不会立刻沿着刚刚走来的路走回。又因为 HH 是个喜欢变化的人，所以他每天走过的路径都不完全一样，他想知道他究竟有多少种散步的方法。\n\n现在给你学校的地图（假设每条路的长度都是一样的都是 $1$），问长度为 $t$，从给定地点 $A$ 走到给定地点 $B$ 共有多少条符合条件的路径。", "inputFormat": "第一行：五个整数 $N,M,t,A,B$。其中 $N$ 表示学校里的路口的个数，$M$ 表示学校里的路的条数，$t$ 表示 HH 想要散步的距离，$A$ 表示散步的出发点，而 $B$ 则表示散步的终点。\n\n接下来 $M$ 行，每行一组 $A_i,B_i$，表示从路口 $A_i$ 到路口 $B_i$ 有一条路。数据保证 $A_i \\neq B_i$，但不保证任意两个路口之间至多只有一条路相连接。路口编号从 $0$ 到 $N-1$。同一行内所有数据均由一个空格隔开，行首行尾没有多余空格。没有多余空行。答案模 $45989$。", "outputFormat": "一行，表示答案。\n", "hint": "### 数据范围及约定\n\n对于 $30\\%$ 的数据，$N \\le 4$，$M \\le 10$，$t \\le 10$。\n\n对于 $100\\%$ 的数据，$N \\le 50$，$M \\le 60$，$t \\le 2^{30}$，$0 \\le A,B$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2009] HH Goes for a Walk", "background": "", "description": "HH has an unchanging habit: he likes to walk one hundred steps after meals. By “one hundred steps,” he means taking a walk, that is, covering a certain distance within a certain time. However, HH also likes variety, so he will not immediately walk back along the road he just took. Since he likes variety, the path he takes each day is not exactly the same. He wants to know how many different ways he can take such a walk.\n\nYou are given the school’s map (assume every road has the same length, which is $1$). Find the number of valid paths of length $t$ from a given location $A$ to a given location $B$.", "inputFormat": "The first line contains five integers $N, M, t, A, B$. Here $N$ is the number of intersections in the school, $M$ is the number of roads, $t$ is the distance HH wants to walk, $A$ is the starting point, and $B$ is the destination.\n\nThe next $M$ lines each contain a pair $A_i, B_i$, meaning there is a road from intersection $A_i$ to intersection $B_i$. It is guaranteed that $A_i \\neq B_i$, but there may be multiple roads connecting the same pair of intersections. Intersections are numbered from $0$ to $N-1$. All data on the same line are separated by a single space, and there are no extra spaces at the beginning or end of lines. There are no extra blank lines.", "outputFormat": "Output one line: the answer modulo $45989$.", "hint": "### Constraints and Conventions\n\nFor $30\\%$ of the testdata, $N \\le 4$, $M \\le 10$, $t \\le 10$.\n\nFor $100\\%$ of the testdata, $N \\le 50$, $M \\le 60$, $t \\le 2^{30}$, $0 \\le A, B$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2009] HH 去散步", "background": "", "description": "HH 有个一成不变的习惯，喜欢饭后百步走。所谓百步走，就是散步，就是在一定的时间内，走过一定的距离。但是同时 HH 又是个喜欢变化的人，所以他不会立刻沿着刚刚走来的路走回。又因为 HH 是个喜欢变化的人，所以他每天走过的路径都不完全一样，他想知道他究竟有多少种散步的方法。\n\n现在给你学校的地图（假设每条路的长度都是一样的都是 $1$），问长度为 $t$，从给定地点 $A$ 走到给定地点 $B$ 共有多少条符合条件的路径。", "inputFormat": "第一行：五个整数 $N,M,t,A,B$。其中 $N$ 表示学校里的路口的个数，$M$ 表示学校里的路的条数，$t$ 表示 HH 想要散步的距离，$A$ 表示散步的出发点，而 $B$ 则表示散步的终点。\n\n接下来 $M$ 行，每行一组 $A_i,B_i$，表示从路口 $A_i$ 到路口 $B_i$ 有一条路。数据保证 $A_i \\neq B_i$，但不保证任意两个路口之间至多只有一条路相连接。路口编号从 $0$ 到 $N-1$。同一行内所有数据均由一个空格隔开，行首行尾没有多余空格。没有多余空行。答案模 $45989$。", "outputFormat": "一行，表示答案。\n", "hint": "### 数据范围及约定\n\n对于 $30\\%$ 的数据，$N \\le 4$，$M \\le 10$，$t \\le 10$。\n\n对于 $100\\%$ 的数据，$N \\le 50$，$M \\le 60$，$t \\le 2^{30}$，$0 \\le A,B$。", "locale": "zh-CN"}}}
{"pid": "P2152", "type": "P", "difficulty": 5, "samples": [["12\n54", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["高精度", "2009", "各省省选", "山东", "O2优化", "最大公约数 gcd"], "title": "[SDOI2009] SuperGCD", "background": null, "description": "Sheng bill 有着惊人的心算能力，甚至能用大脑计算出两个巨大的数的最大公约数！因此他经常和别人比赛计算最大公约数。有一天 Sheng bill 很嚣张地找到了你，并要求和你比赛，但是输给 Sheng bill 岂不是很丢脸！所以你决定写一个程序来教训他。", "inputFormat": "共两行，第一行一个整数 $a$，第二行一个整数 $b$。", "outputFormat": "一行，表示 $a$ 和 $b$ 的最大公约数。", "hint": "#### 数据规模与约定\n- 对于 $20\\%$ 的数据，有 $0<a,b\\le 10^{18}$。\n- 对于 $100\\%$ 的数据，有 $0<a,b\\le 10^{10000}$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2009] SuperGCD", "background": "", "description": "Sheng bill has amazing mental arithmetic skills and can even compute the greatest common divisor of two huge numbers in his head. Therefore, he often competes with others in computing the greatest common divisor. One day, Sheng bill arrogantly challenged you, but losing to Sheng bill would be embarrassing. So you decide to write a program to teach him a lesson.", "inputFormat": "Two lines: the first line contains an integer $a$, and the second line contains an integer $b$.", "outputFormat": "One line, representing the greatest common divisor of $a$ and $b$.", "hint": "#### Constraints\n- For $20\\%$ of the testdata, $0<a,b\\le 10^{18}$.\n- For $100\\%$ of the testdata, $0<a,b\\le 10^{10000}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2009] SuperGCD", "background": null, "description": "Sheng bill 有着惊人的心算能力，甚至能用大脑计算出两个巨大的数的最大公约数！因此他经常和别人比赛计算最大公约数。有一天 Sheng bill 很嚣张地找到了你，并要求和你比赛，但是输给 Sheng bill 岂不是很丢脸！所以你决定写一个程序来教训他。", "inputFormat": "共两行，第一行一个整数 $a$，第二行一个整数 $b$。", "outputFormat": "一行，表示 $a$ 和 $b$ 的最大公约数。", "hint": "#### 数据规模与约定\n- 对于 $20\\%$ 的数据，有 $0<a,b\\le 10^{18}$。\n- 对于 $100\\%$ 的数据，有 $0<a,b\\le 10^{10000}$。", "locale": "zh-CN"}}}
{"pid": "P2153", "type": "P", "difficulty": 6, "samples": [["7 10\n1 2 1\n1 3 1\n2 4 1\n3 4 1\n4 5 1\n4 6 1\n2 5 5\n3 6 6\n5 7 1\n6 7 1", "2 11\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "各省省选", "山东", "深度优先搜索 DFS", "费用流"], "title": "[SDOI2009] 晨跑", "background": null, "description": "Elaxia 最近迷恋上了空手道，他为自己设定了一套健身计划，比如俯卧撑、仰卧起坐等等，不过到目前为止，他坚持下来的只有晨跑。 \n\n现在给出一张学校附近的地图，这张地图中包含 $N$ 个十字路口和 $M$ 条街道，Elaxia 只能从 一个十字路口跑向另外一个十字路口，街道之间只在十字路口处相交。\n\nElaxia 每天从寝室出发跑到学校，保证寝室编号为 $1$，学校编号为 $N$。 \n\nElaxia 的晨跑计划是按周期（包含若干天）进行的，由于他不喜欢走重复的路线，所以在一个周期内，每天的晨跑路线都不会经过同一个十字路口，寝室和学校不算十字路口。\n\nElaxia 耐力不太好，他希望在一个周期内跑的路程尽量短，但是又希望训练周期包含的天数尽量长。\n\n除了练空手道，Elaxia 其他时间都花在了学习和找 MM 上面，所有他想请你帮忙为他设计一套满足他要求的晨跑计划。\n\n可能存在 $1\\rightarrow n$ 的边。这种情况下，这条边只能走一次。", "inputFormat": "第一行两个整数 $N,M$，表示十字路口数和街道数。 \n\n接下来 $M$ 行，每行 $3$ 个数 $a,b,c$，表示路口 $a$ 和路口 $b$ 之间有条长度为 $c$ 的街道（单向）。", "outputFormat": "一行两个整数，最长周期的天数和满足最长天数的条件下最短的跑步总路程长度。", "hint": "- 对于 $30\\%$ 的数据，$N\\le 20$，$M \\le 120$。\n- 对于 $100\\%$ 的数据，$2\\leq N\\le 200$，$1\\leq M\\le 2\\times 10^4$，$1\\le c\\le 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2009] Morning Run", "background": "", "description": "Elaxia has recently become obsessed with karate. He set up a fitness plan for himself, such as push-ups and sit-ups, but so far, the only thing he has stuck with is the morning run.\n\nYou are given a map of the area near the school, containing $N$ intersections and $M$ streets. Elaxia can only run from one intersection to another, and streets intersect only at intersections.\n\nEvery day, Elaxia runs from the dorm to the school. The dorm is numbered $1$, and the school is numbered $N$.\n\nElaxia’s morning runs follow a cycle (spanning several days). Because he dislikes repeating routes, within one cycle, the routes chosen on different days must not intersect at any intersection; the dorm and the school are not considered intersections.\n\nElaxia’s stamina is limited. He wants the total distance run in one cycle to be as short as possible, but he also wants the number of days in the training cycle to be as large as possible.\n\nBesides practicing karate, Elaxia spends the rest of his time studying and looking for “MM” (meimei), so he asks you to design a morning running plan that meets his requirements.\n\nThere may exist an edge $1 \\rightarrow N$. In that case, this edge can be used at most once.", "inputFormat": "The first line contains two integers $N, M$, the number of intersections and streets.\n\nThe next $M$ lines each contain three integers $a, b, c$, indicating there is a directed street from intersection $a$ to intersection $b$ with length $c$.", "outputFormat": "Output one line with two integers: the maximum number of days in a cycle, and, among all plans achieving this maximum, the minimal total distance.", "hint": "- For 30% of the testdata, $N \\le 20$, $M \\le 120$.\n- For 100% of the testdata, $2 \\leq N \\le 200$, $1 \\leq M \\le 2 \\times 10^4$, $1 \\le c \\le 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2009] 晨跑", "background": null, "description": "Elaxia 最近迷恋上了空手道，他为自己设定了一套健身计划，比如俯卧撑、仰卧起坐等等，不过到目前为止，他坚持下来的只有晨跑。 \n\n现在给出一张学校附近的地图，这张地图中包含 $N$ 个十字路口和 $M$ 条街道，Elaxia 只能从 一个十字路口跑向另外一个十字路口，街道之间只在十字路口处相交。\n\nElaxia 每天从寝室出发跑到学校，保证寝室编号为 $1$，学校编号为 $N$。 \n\nElaxia 的晨跑计划是按周期（包含若干天）进行的，由于他不喜欢走重复的路线，所以在一个周期内，每天的晨跑路线都不会经过同一个十字路口，寝室和学校不算十字路口。\n\nElaxia 耐力不太好，他希望在一个周期内跑的路程尽量短，但是又希望训练周期包含的天数尽量长。\n\n除了练空手道，Elaxia 其他时间都花在了学习和找 MM 上面，所有他想请你帮忙为他设计一套满足他要求的晨跑计划。\n\n可能存在 $1\\rightarrow n$ 的边。这种情况下，这条边只能走一次。", "inputFormat": "第一行两个整数 $N,M$，表示十字路口数和街道数。 \n\n接下来 $M$ 行，每行 $3$ 个数 $a,b,c$，表示路口 $a$ 和路口 $b$ 之间有条长度为 $c$ 的街道（单向）。", "outputFormat": "一行两个整数，最长周期的天数和满足最长天数的条件下最短的跑步总路程长度。", "hint": "- 对于 $30\\%$ 的数据，$N\\le 20$，$M \\le 120$。\n- 对于 $100\\%$ 的数据，$2\\leq N\\le 200$，$1\\leq M\\le 2\\times 10^4$，$1\\le c\\le 10^4$。", "locale": "zh-CN"}}}
{"pid": "P2154", "type": "P", "difficulty": 6, "samples": [["5 6\r\n13\r\n0 2\r\n0 3\r\n1 2\r\n1 3\r\n2 0\r\n2 1\r\n2 4\r\n2 5\r\n2 6\r\n3 2\r\n3 3\r\n4 3\r\n5 2\r\n2", "6"]], "limits": {"time": [800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2009", "各省省选", "树状数组", "山东", "排列组合"], "title": "[SDOI2009] 虔诚的墓主人", "background": "", "description": "小W是一片新造公墓的管理人。公墓可以看成一块 $N×M$ 的矩形，矩形的每个格点，要么种着一棵常青树，要么是一块还没有归属的墓地。\n\n当地的居民都是非常虔诚的基督徒，他们愿意提前为自己找一块合适墓地。为了体现自己对主的真诚，他们希望自己的墓地拥有着较高的虔诚度。\n\n一块墓地的虔诚度是指以这块墓地为中心的十字架的数目。一个十字架可以看成中间是墓地，墓地的正上、正下、正左、正右都有恰好 $k$ 棵常青树。\n\n形式化地，对于一个坐标为 $(x, y)$ 的墓地，以其为中心的十字架个数是这样的长度为 $4k$ 的二元组序列 $[(x_{1,1},y_{1,1}),\\allowbreak(x_{1,2},y_{1,2}),\\allowbreak\\cdots,(x_{1,k},y_{1,k}),\\allowbreak(x_{2,1},y_{2,1}),\\allowbreak(x_{2,2},y_{2,2}),\\allowbreak\\cdots,(x_{2,k},y_{2,k}),\\allowbreak(x_{3,1},y_{3,1}),\\allowbreak(x_{3,2},y_{3,2}),\\allowbreak\\cdots,(x_{3,k},y_{3,k}),\\allowbreak(x_{4,1},y_{4,1}),\\allowbreak(x_{4,2},y_{4,2}),\\allowbreak\\cdots,(x_{4,k},y_{4,k})]$ 的方案数：\n\n- 每一个二元组对应着一棵常青树的坐标；\n- $x_{1,1}<x_{1,2}<\\cdots< x_{1,k}<x$ 且 $y_{1,1}=y_{1,2}=\\cdots=y_{1,k}=y$；\n- $x<x_{2,1}<x_{2,2}<\\cdots< x_{2,k}$ 且 $y_{2,1}=y_{2,2}=\\cdots=y_{2,k}=y$；\n- $y_{3,1}<y_{3,2}<\\cdots< y_{3,k}<y$ 且 $x_{3,1}=x_{3,2}=\\cdots=x_{3,k}=x$；\n- $y<y_{4,1}<y_{4,2}<\\cdots< y_{4,k}$ 且 $x_{4,1}=x_{4,2}=\\cdots=x_{4,k}=x$。\n\n小W希望知道他所管理的这片公墓中所有墓地的虔诚度总和是多少。", "inputFormat": "第一行包含两个用空格分隔的正整数 $N$ 和 $M$，表示公墓的宽和长，因此这个矩形公墓共有 $(N+1) ×(M+1)$ 个格点，左下角的坐标为 $(0, 0)$，右上角的坐标为 $(N, M)$。\n\n第二行包含一个正整数 $W$，表示公墓中常青树的个数。\n\n第三行起共 $W$ 行，每行包含两个用空格分隔的非负整数 $x_i$ 和 $y_i$，表示一棵常青树的坐标。输入保证没有两棵常青树拥有相同的坐标。\n\n最后一行包含一个正整数 $k$，意义如题目所示。", "outputFormat": "输出仅包含一个非负整数，表示这片公墓中所有墓地的虔诚度总和。为了方便起见，答案对 $2{,}147{,}483{,}648$ 取模。", "hint": "图中，以墓地 $(2, 2)$ 和 $(2, 3)$ 为中心的十字架各有 $3$ 个，即它们的虔诚度均为 $3$。其他墓地的虔诚度为 $0$。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1589.png) \n\n对于 $30\\%$ 的数据，满足 $1 ≤ N, M ≤ 10^3$。\n\n对于 $60\\%$ 的数据，满足 $1 ≤ N, M ≤ 10^6$。\n\n对于 $100\\%$ 的数据，满足 $1 ≤ N, M ≤ 10^9$，$0 ≤ x_i ≤ N$，$0 ≤ y_i ≤ M$，$1 ≤ W ≤ 10^5$，$1 ≤ k ≤ 10$。\n\n存在 $50\\%$ 的数据，满足 $1 ≤ k ≤ 2$。\n\n存在 $25\\%$ 的数据，满足 $1 ≤ W ≤ 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2009] The Devout Grave Keeper", "background": "", "description": "Xiao W is the manager of a newly built cemetery. The cemetery can be regarded as an $N×M$ rectangle. Each lattice point is either planted with an evergreen tree, or is a grave plot that has not yet been assigned.\n\nThe local residents are very devout Christians, and they are willing to choose a suitable grave plot for themselves in advance. To show their sincerity to the Lord, they hope their grave plot has a high level of piety.\n\nThe piety of a grave plot is defined as the number of crosses centered at this plot. A cross consists of a center grave plot, and exactly $k$ evergreen trees immediately above, below, left, and right of it.\n\nFormally, for a grave plot at coordinates $(x, y)$, the number of crosses centered at it is the number of sequences of length $4k$ of ordered pairs $[(x_{1,1},y_{1,1}),\\allowbreak(x_{1,2},y_{1,2}),\\allowbreak\\cdots,(x_{1,k},y_{1,k}),\\allowbreak(x_{2,1},y_{2,1}),\\allowbreak(x_{2,2},y_{2,2}),\\allowbreak\\cdots,(x_{2,k},y_{2,k}),\\allowbreak(x_{3,1},y_{3,1}),\\allowbreak(x_{3,2},y_{3,2}),\\allowbreak\\cdots,(x_{3,k},y_{3,k}),\\allowbreak(x_{4,1},y_{4,1}),\\allowbreak(x_{4,2},y_{4,2}),\\allowbreak\\cdots,(x_{4,k},y_{4,k})]$ that satisfy:\n\n- Each ordered pair corresponds to the coordinates of an evergreen tree.\n- $x_{1,1}<x_{1,2}<\\cdots< x_{1,k}<x$ and $y_{1,1}=y_{1,2}=\\cdots=y_{1,k}=y$.\n- $x<x_{2,1}<x_{2,2}<\\cdots< x_{2,k}$ and $y_{2,1}=y_{2,2}=\\cdots=y_{2,k}=y$.\n- $y_{3,1}<y_{3,2}<\\cdots< y_{3,k}<y$ and $x_{3,1}=x_{3,2}=\\cdots=x_{3,k}=x$.\n- $y<y_{4,1}<y_{4,2}<\\cdots< y_{4,k}$ and $x_{4,1}=x_{4,2}=\\cdots=x_{4,k}=x$.\n\nXiao W wants to know the sum of the piety levels of all grave plots in the cemetery.", "inputFormat": "The first line contains two positive integers $N$ and $M$, representing the width and length of the cemetery. Therefore, this rectangular cemetery has $(N+1) ×(M+1)$ lattice points, with the lower-left corner at $(0, 0)$ and the upper-right corner at $(N, M)$.\n\nThe second line contains a positive integer $W$, representing the number of evergreen trees in the cemetery.\n\nFrom the third line, there are $W$ lines. Each line contains two non-negative integers $x_i$ and $y_i$, representing the coordinates of an evergreen tree. The input guarantees that no two evergreen trees have the same coordinates.\n\nThe last line contains a positive integer $k$, as defined in the statement.", "outputFormat": "Output a single non-negative integer, which is the sum of the piety levels over all grave plots in this cemetery. For convenience, output the answer modulo $2{,}147{,}483{,}648$.", "hint": "In the figure, the number of crosses centered at grave plots $(2, 2)$ and $(2, 3)$ is $3$, so their piety levels are both $3$. The piety level of every other grave plot is $0$.\n\n ![](https://cdn.luogu.com.cn/upload/pic/1589.png) \n\nFor $30\\%$ of the testdata, $1 ≤ N, M ≤ 10^3$.\n\nFor $60\\%$ of the testdata, $1 ≤ N, M ≤ 10^6$.\n\nFor $100\\%$ of the testdata, $1 ≤ N, M ≤ 10^9$，$0 ≤ x_i ≤ N$，$0 ≤ y_i ≤ M$，$1 ≤ W ≤ 10^5$，$1 ≤ k ≤ 10$。\n\nThere exists $50\\%$ of the testdata such that $1 ≤ k ≤ 2$.\n\nThere exists $25\\%$ of the testdata such that $1 ≤ W ≤ 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2009] 虔诚的墓主人", "background": "", "description": "小W是一片新造公墓的管理人。公墓可以看成一块 $N×M$ 的矩形，矩形的每个格点，要么种着一棵常青树，要么是一块还没有归属的墓地。\n\n当地的居民都是非常虔诚的基督徒，他们愿意提前为自己找一块合适墓地。为了体现自己对主的真诚，他们希望自己的墓地拥有着较高的虔诚度。\n\n一块墓地的虔诚度是指以这块墓地为中心的十字架的数目。一个十字架可以看成中间是墓地，墓地的正上、正下、正左、正右都有恰好 $k$ 棵常青树。\n\n形式化地，对于一个坐标为 $(x, y)$ 的墓地，以其为中心的十字架个数是这样的长度为 $4k$ 的二元组序列 $[(x_{1,1},y_{1,1}),\\allowbreak(x_{1,2},y_{1,2}),\\allowbreak\\cdots,(x_{1,k},y_{1,k}),\\allowbreak(x_{2,1},y_{2,1}),\\allowbreak(x_{2,2},y_{2,2}),\\allowbreak\\cdots,(x_{2,k},y_{2,k}),\\allowbreak(x_{3,1},y_{3,1}),\\allowbreak(x_{3,2},y_{3,2}),\\allowbreak\\cdots,(x_{3,k},y_{3,k}),\\allowbreak(x_{4,1},y_{4,1}),\\allowbreak(x_{4,2},y_{4,2}),\\allowbreak\\cdots,(x_{4,k},y_{4,k})]$ 的方案数：\n\n- 每一个二元组对应着一棵常青树的坐标；\n- $x_{1,1}<x_{1,2}<\\cdots< x_{1,k}<x$ 且 $y_{1,1}=y_{1,2}=\\cdots=y_{1,k}=y$；\n- $x<x_{2,1}<x_{2,2}<\\cdots< x_{2,k}$ 且 $y_{2,1}=y_{2,2}=\\cdots=y_{2,k}=y$；\n- $y_{3,1}<y_{3,2}<\\cdots< y_{3,k}<y$ 且 $x_{3,1}=x_{3,2}=\\cdots=x_{3,k}=x$；\n- $y<y_{4,1}<y_{4,2}<\\cdots< y_{4,k}$ 且 $x_{4,1}=x_{4,2}=\\cdots=x_{4,k}=x$。\n\n小W希望知道他所管理的这片公墓中所有墓地的虔诚度总和是多少。", "inputFormat": "第一行包含两个用空格分隔的正整数 $N$ 和 $M$，表示公墓的宽和长，因此这个矩形公墓共有 $(N+1) ×(M+1)$ 个格点，左下角的坐标为 $(0, 0)$，右上角的坐标为 $(N, M)$。\n\n第二行包含一个正整数 $W$，表示公墓中常青树的个数。\n\n第三行起共 $W$ 行，每行包含两个用空格分隔的非负整数 $x_i$ 和 $y_i$，表示一棵常青树的坐标。输入保证没有两棵常青树拥有相同的坐标。\n\n最后一行包含一个正整数 $k$，意义如题目所示。", "outputFormat": "输出仅包含一个非负整数，表示这片公墓中所有墓地的虔诚度总和。为了方便起见，答案对 $2{,}147{,}483{,}648$ 取模。", "hint": "图中，以墓地 $(2, 2)$ 和 $(2, 3)$ 为中心的十字架各有 $3$ 个，即它们的虔诚度均为 $3$。其他墓地的虔诚度为 $0$。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1589.png) \n\n对于 $30\\%$ 的数据，满足 $1 ≤ N, M ≤ 10^3$。\n\n对于 $60\\%$ 的数据，满足 $1 ≤ N, M ≤ 10^6$。\n\n对于 $100\\%$ 的数据，满足 $1 ≤ N, M ≤ 10^9$，$0 ≤ x_i ≤ N$，$0 ≤ y_i ≤ M$，$1 ≤ W ≤ 10^5$，$1 ≤ k ≤ 10$。\n\n存在 $50\\%$ 的数据，满足 $1 ≤ k ≤ 2$。\n\n存在 $25\\%$ 的数据，满足 $1 ≤ W ≤ 10^4$。", "locale": "zh-CN"}}}
{"pid": "P2155", "type": "P", "difficulty": 5, "samples": [["1 11\n4 2", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "2008", "各省省选", "山东", "素数判断,质数,筛法", "逆元"], "title": "[SDOI2008] 沙拉公主的困惑", "background": "", "description": "大富翁国因为通货膨胀，以及假钞泛滥，政府决定推出一项新的政策：现有钞票编号范围为 $1$ 到 $N$ 的阶乘，但是，政府只发行编号与 $M!$ 互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于数量可能非常大，你只需计算出答案对 $R$ 取模后的结果即可。 ", "inputFormat": "第一行为两个整数 $T$ 和 $R$，其中 $T$ 为该组中测试数据数目，$R$ 为模数。\n\n接下来 $T$ 行，每行一对整数 $N$ 和 $M$，具体意义见题目描述。 ", "outputFormat": "共 $T$ 行，对于每一对 $N$ 和 $M$，输出 $[1, N!]$ 中与 $M!$ 互质的数的数量对 $R$ 取模后的值。  ", "hint": "对于 $100\\% $ 的数据，$1\\leq M\\leq N\\leq 10^7$，$1\\leq T\\leq 10^4$，$2\\leq R\\leq 10^9+10$ 且 $R$ 为质数。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2008] Princess Shala's Confusion", "background": "", "description": "Due to inflation and rampant counterfeiting, the government of the Monopoly Kingdom decides on a new policy: the serial numbers of existing banknotes range from $1$ to $N!$, but the government will issue only banknotes whose serial numbers are coprime to $M!$. Princess Shala, the largest real estate holder, wants to estimate the total number of genuine banknotes now. Please help Princess Shala solve this problem. Since the number can be very large, you only need to compute the answer modulo $R$.", "inputFormat": "The first line contains two integers $T$ and $R$, where $T$ is the number of testdata in this set, and $R$ is the modulus.\n\nThe next $T$ lines each contain a pair of integers $N$ and $M$, as described above.", "outputFormat": "Output $T$ lines. For each pair $N$ and $M$, output the number of integers in $[1, N!]$ that are coprime to $M!$, taken modulo $R$.", "hint": "For $100\\%$ of the testdata, $1 \\le M \\le N \\le 10^7$, $1 \\le T \\le 10^4$, $2 \\le R \\le 10^9+10$, and $R$ is prime.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2008] 沙拉公主的困惑", "background": "", "description": "大富翁国因为通货膨胀，以及假钞泛滥，政府决定推出一项新的政策：现有钞票编号范围为 $1$ 到 $N$ 的阶乘，但是，政府只发行编号与 $M!$ 互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于数量可能非常大，你只需计算出答案对 $R$ 取模后的结果即可。 ", "inputFormat": "第一行为两个整数 $T$ 和 $R$，其中 $T$ 为该组中测试数据数目，$R$ 为模数。\n\n接下来 $T$ 行，每行一对整数 $N$ 和 $M$，具体意义见题目描述。 ", "outputFormat": "共 $T$ 行，对于每一对 $N$ 和 $M$，输出 $[1, N!]$ 中与 $M!$ 互质的数的数量对 $R$ 取模后的值。  ", "hint": "对于 $100\\% $ 的数据，$1\\leq M\\leq N\\leq 10^7$，$1\\leq T\\leq 10^4$，$2\\leq R\\leq 10^9+10$ 且 $R$ 为质数。", "locale": "zh-CN"}}}
{"pid": "P2156", "type": "P", "difficulty": 6, "samples": [["12 13\r\n.###..#####..\r\n#...#.#....#.\r\n#.#.#.#..#.#.\r\n#...#..#...#.\r\n.###.#..###..\r\n....#..##...#\r\n..........###\r\n##########..#\r\n#...........#\r\n#.###...###.#\r\n#...........#\r\n#############\r\n", "1\r\n......#####..\r\n......#....#.\r\n......#..#.#.\r\n.......#...#.\r\n........###..\r\n.......##....\r\n.............\r\n.............\r\n.............\r\n.............\r\n.............\r\n.............\r\n"], ["9 14\r\n#########.....\r\n#.......#....#\r\n#.#####.#...#.\r\n#.#...#.#..#..\r\n#.#.#.#.#.#..#\r\n#.#...#.#..#..\r\n#.#####.#...#.\r\n#.......#....#\r\n#########.....\r\n", "1\r\n..............\r\n..............\r\n..#####.......\r\n..#...#.......\r\n..#.#.#.......\r\n..#...#.......\r\n..#####.......\r\n..............\r\n..............\r\n"], ["7 15\r\n#######.#######\r\n#.....#.#.....#\r\n#.###.#.#.###.#\r\n#.#.#.#.#.#...#\r\n#.###.#.#.###.#\r\n#.....#.#.....#\r\n#######.#######\r\n", "1\r\n........#######\r\n........#.....#\r\n........#.###.#\r\n........#.#...#\r\n........#.###.#\r\n........#.....#\r\n........#######\r\n"]], "limits": {"time": [606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606, 606], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2009", "各省省选", "山东"], "title": "[SDOI2009] 细胞探索", "background": "", "description": "生物课上，老师开始为同学们介绍细胞。为了加深同学们的印象，老师在一张 $n \\times m$ 的矩阵中定义了一种细胞，矩阵中仅有井号 `#` 和点 `.`。\n\n细胞由细胞核、细胞质及细胞膜构成。细胞核是一个四联通（上下左右相连）的全为 `#` 的连通块，它必须实心，即不能存在一个四联通的 `.` 连通块被其完全包围（所谓完全包围指的是，这个 `.` 连通块不能位于矩阵边界相邻，且它的 $4$ 相邻格子均属于包含它的 `#` 连通块）。细胞膜是一个八联通（上下左右，以及 $4$ 个对角方向）的全为 `#` 的非实心连通块。细胞膜仅包围一个四联通的区域，且这个区域内有且仅有一个细胞核，这个区域剩下的位置全为 `.`。\n\n所有连通块必须极大化，即一个八联通块周围不能找到一个 `#` 与这个连通块的任意一个 `#`八联通；同样，对于一个四联通块周围不能找到一个 `#` 与这个连通块的任意一个 `#`四联通。\n\n现在，老师画了一幅图画，让小 E 回答图画中一共有几个细胞，并把图画中不属于任何一个细胞的 `#` 改成 `.`。", "inputFormat": "第一行两个正整数 $n,m$。\n\n下面一个 $n \\times m$ 的字符矩阵，保证其中只含 `#` 和 `.`。", "outputFormat": "第一行一个整数，表示输入的矩阵中的细胞数。\n\n下面一个 $n \\times m$ 的字符矩阵，表示按照要求修改后的图画。", "hint": "对于 $20\\%$ 的数据，$n,m \\le 20$。\n\n对于另外 $20\\%$ 的数据，保证所有 `#` 都属于某一个正确的细胞。\n\n对于 $100\\%$ 的数据，$1 \\le n,m \\le 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2009] Cell Exploration", "background": "", "description": "In biology class, the teacher began introducing cells. To deepen the students’ impression, the teacher defined a kind of cell in an $n \\times m$ matrix that contains only the hash `#` and the dot `.`.\n\nA cell is composed of a nucleus, cytoplasm, and membrane. The nucleus is a 4-connected (connected via up, down, left, right) connected component consisting entirely of `#`. It must be solid, i.e., there cannot exist a 4-connected `.` component that is completely enclosed by it (completely enclosed means that this `.` component is not adjacent to the matrix border, and all of its 4-neighbor cells belong to the `#` component that contains it). The membrane is an 8-connected (up, down, left, right, and the 4 diagonal directions) connected component consisting entirely of `#` that is non-solid. The membrane encloses exactly one 4-connected region, and there is exactly one nucleus inside this region; all other positions in this region are `.`.\n\nAll connected components must be maximal, i.e., for an 8-connected component, there must not exist a `#` outside that is 8-connected to any `#` in this component; similarly, for a 4-connected component, there must not exist a `#` outside that is 4-connected to any `#` in this component.\n\nNow, the teacher drew a picture and asked Xiao E to determine how many cells are in the picture and to change every `#` that does not belong to any cell into `.`.", "inputFormat": "The first line contains two positive integers $n, m$.\n\nThen follows an $n \\times m$ character matrix, guaranteed to contain only `#` and `.`.", "outputFormat": "The first line contains an integer, the number of cells in the input matrix.\n\nThen output an $n \\times m$ character matrix, representing the modified picture according to the requirements.", "hint": "For $20\\%$ of the testdata, $n, m \\le 20$.\n\nFor another $20\\%$ of the testdata, it is guaranteed that all `#` belong to some valid cell.\n\nFor $100\\%$ of the testdata, $1 \\le n, m \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2009] 细胞探索", "background": "", "description": "生物课上，老师开始为同学们介绍细胞。为了加深同学们的印象，老师在一张 $n \\times m$ 的矩阵中定义了一种细胞，矩阵中仅有井号 `#` 和点 `.`。\n\n细胞由细胞核、细胞质及细胞膜构成。细胞核是一个四联通（上下左右相连）的全为 `#` 的连通块，它必须实心，即不能存在一个四联通的 `.` 连通块被其完全包围（所谓完全包围指的是，这个 `.` 连通块不能位于矩阵边界相邻，且它的 $4$ 相邻格子均属于包含它的 `#` 连通块）。细胞膜是一个八联通（上下左右，以及 $4$ 个对角方向）的全为 `#` 的非实心连通块。细胞膜仅包围一个四联通的区域，且这个区域内有且仅有一个细胞核，这个区域剩下的位置全为 `.`。\n\n所有连通块必须极大化，即一个八联通块周围不能找到一个 `#` 与这个连通块的任意一个 `#`八联通；同样，对于一个四联通块周围不能找到一个 `#` 与这个连通块的任意一个 `#`四联通。\n\n现在，老师画了一幅图画，让小 E 回答图画中一共有几个细胞，并把图画中不属于任何一个细胞的 `#` 改成 `.`。", "inputFormat": "第一行两个正整数 $n,m$。\n\n下面一个 $n \\times m$ 的字符矩阵，保证其中只含 `#` 和 `.`。", "outputFormat": "第一行一个整数，表示输入的矩阵中的细胞数。\n\n下面一个 $n \\times m$ 的字符矩阵，表示按照要求修改后的图画。", "hint": "对于 $20\\%$ 的数据，$n,m \\le 20$。\n\n对于另外 $20\\%$ 的数据，保证所有 `#` 都属于某一个正确的细胞。\n\n对于 $100\\%$ 的数据，$1 \\le n,m \\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P2157", "type": "P", "difficulty": 6, "samples": [["2\n5\n5 2\n4 1\n12 0\n3 3\n2 2\n2\n5 0\n4 0", "16\n1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2009", "各省省选", "山东", "枚举", "状压 DP"], "title": "[SDOI2009] 学校食堂", "background": "", "description": "小 F 的学校在城市的一个偏僻角落，所有学生都只好在学校吃饭。学校有一个食堂，虽然简陋，但食堂大厨总能做出让同学们满意的菜肴。当然，不同的人口味也不一定相同，但每个人的口味都可以用一个非负整数表示。 由于人手不够，食堂每次只能为一个人做菜。做每道菜所需的时间是和前一道菜有关的，若前一道菜的对应的口味是 $a$，这一道为 $b$，则做这道菜所需的时间为 $(a\\operatorname{or}b)-(a\\operatorname{and}b)$，而做第一道菜是不需要计算时间的。其中，$\\operatorname{or}$ 和 $\\operatorname{and}$ 表示整数逐位或运算及逐位与运算，C 语言中对应的运算符为 `|` 和 `&`。\n\n\n学生数目相对于这个学校还是比较多的，吃饭做菜往往就会花去不少时间。因此，学校食堂偶尔会不按照大家的排队顺序做菜，以缩短总的进餐时间。\n\n虽然同学们能够理解学校食堂的这种做法，不过每个同学还是有一定容忍度的。也就是说，队伍中的第 $i$ 个同学，最多允许紧跟他身后的 $B_i$ 个人先拿到饭菜。一旦在此之后的任意同学比当前同学先拿到饭，当前同学将会十分愤怒。因此，食堂做菜还得照顾到同学们的情绪。 现在，小 F 想知道在满足所有人的容忍度这一前提下，自己的学校食堂做完这些菜最少需要多少时间。\n", "inputFormat": "第一行包含一个正整数 $C$，表示测试点的数据组数。 每组数据的第一行包含一个正整数 $N$，表示同学数。 每组数据的第二行起共 $N$ 行，每行包含两个用空格分隔的非负整数 $T_i$ 和 $B_i$，表示按队伍顺序从前往后的每个同学所需的菜的口味和这个同学的忍受度。 每组数据之间没有多余空行。\n", "outputFormat": "包含 $C$ 行，每行一个整数，表示对应数据中食堂完成所有菜所需的最少时间。\n", "hint": "对于第一组数据：\n\n同学 1 允许同学 2 或同学 3 在他之前拿到菜；同学 2 允许同学 3 在他之前拿到菜；同学 3 比较小气，他必须比他后面的同学先拿菜。\n\n一种最优的方案是按同学 3、同学 2、同学 1、同学 4、同学 5 做菜，每道菜所需的时间分别是 0、8、1、6 及 1。\n\n\n**数据规模和约定**\n\n- 对于 $30\\%$ 的数据，满足 $1 \\le N \\le 20$。\n\n- 对于 $ 100\\% $ 的数据，满足 $1 \\le N \\le 1000,0 \\le T_i \\le 1000,0 \\le B_i \\le 7，1 \\le C \\le 5$。\n\n- 存在 $30\\%$ 的数据，满足 $0 \\le B_i \\le 1$。\n\n- 存在 $65\\%$ 的数据，满足 $0 \\le B_i \\le 5$。\n\n- 存在 $45\\%$ 的数据，满足 $0 \\le T_i \\le 130$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2009] School Canteen", "background": "", "description": "Xiao F’s school is in a remote corner of the city, so all students have to eat at school. The school has a canteen which, although simple, always serves dishes that satisfy the students. Of course, people have different tastes, but each person’s taste can be represented by a non-negative integer. Due to limited staff, the canteen can only cook for one person at a time. The time to cook each dish depends on the previous one: if the previous dish has taste $a$ and the current dish has taste $b$, then the time needed to cook this dish is $(a\\operatorname{or}b)-(a\\operatorname{and}b)$, and no time is counted for the first dish. Here, $\\operatorname{or}$ and $\\operatorname{and}$ denote bitwise OR and bitwise AND on integers, corresponding to the C language operators `|` and `&`.\n\nThere are many students in this school, so cooking often takes a lot of time. Therefore, the canteen may sometimes deviate from the original queue order to shorten the total dining time.\n\nAlthough students can understand this practice, everyone has a certain tolerance. Specifically, the $i$-th student in the queue allows at most the $B_i$ people immediately behind them to be served before them. If any student beyond those $B_i$ immediately behind is served earlier than the $i$-th student, the $i$-th student will be very angry. Thus, the canteen also needs to take students’ emotions into account. Now, under the premise of satisfying everyone’s tolerance, Xiao F wants to know the minimum total time needed for the school canteen to finish all the dishes.", "inputFormat": "The first line contains a positive integer $C$, the number of test cases.  \nFor each test case, the first line contains a positive integer $N$, the number of students.  \nStarting from the second line of each test case, there are $N$ lines. Each line contains two space-separated non-negative integers $T_i$ and $B_i$, representing, in queue order from front to back, each student’s required dish taste and their tolerance.  \nThere are no extra blank lines between test cases.", "outputFormat": "Output $C$ lines, each containing one integer, the minimum total time for the canteen to finish all dishes for the corresponding test case.", "hint": "For the first test case:\n- Student 1 allows Student 2 or Student 3 to be served before them; Student 2 allows Student 3 to be served before them; Student 3 is strict and must be served before any student behind them.\n- One optimal order is to cook for Students 3, 2, 1, 4, 5. The time for each dish is respectively $0$, $8$, $1$, $6$, and $1$.\n\nConstraints:\n- For $30\\%$ of the testdata, $1 \\le N \\le 20$.\n- For $100\\%$ of the testdata, $1 \\le N \\le 1000$, $0 \\le T_i \\le 1000$, $0 \\le B_i \\le 7$, $1 \\le C \\le 5$.\n- For $30\\%$ of the testdata, $0 \\le B_i \\le 1$.\n- For $65\\%$ of the testdata, $0 \\le B_i \\le 5$.\n- For $45\\%$ of the testdata, $0 \\le T_i \\le 130$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2009] 学校食堂", "background": "", "description": "小 F 的学校在城市的一个偏僻角落，所有学生都只好在学校吃饭。学校有一个食堂，虽然简陋，但食堂大厨总能做出让同学们满意的菜肴。当然，不同的人口味也不一定相同，但每个人的口味都可以用一个非负整数表示。 由于人手不够，食堂每次只能为一个人做菜。做每道菜所需的时间是和前一道菜有关的，若前一道菜的对应的口味是 $a$，这一道为 $b$，则做这道菜所需的时间为 $(a\\operatorname{or}b)-(a\\operatorname{and}b)$，而做第一道菜是不需要计算时间的。其中，$\\operatorname{or}$ 和 $\\operatorname{and}$ 表示整数逐位或运算及逐位与运算，C 语言中对应的运算符为 `|` 和 `&`。\n\n\n学生数目相对于这个学校还是比较多的，吃饭做菜往往就会花去不少时间。因此，学校食堂偶尔会不按照大家的排队顺序做菜，以缩短总的进餐时间。\n\n虽然同学们能够理解学校食堂的这种做法，不过每个同学还是有一定容忍度的。也就是说，队伍中的第 $i$ 个同学，最多允许紧跟他身后的 $B_i$ 个人先拿到饭菜。一旦在此之后的任意同学比当前同学先拿到饭，当前同学将会十分愤怒。因此，食堂做菜还得照顾到同学们的情绪。 现在，小 F 想知道在满足所有人的容忍度这一前提下，自己的学校食堂做完这些菜最少需要多少时间。\n", "inputFormat": "第一行包含一个正整数 $C$，表示测试点的数据组数。 每组数据的第一行包含一个正整数 $N$，表示同学数。 每组数据的第二行起共 $N$ 行，每行包含两个用空格分隔的非负整数 $T_i$ 和 $B_i$，表示按队伍顺序从前往后的每个同学所需的菜的口味和这个同学的忍受度。 每组数据之间没有多余空行。\n", "outputFormat": "包含 $C$ 行，每行一个整数，表示对应数据中食堂完成所有菜所需的最少时间。\n", "hint": "对于第一组数据：\n\n同学 1 允许同学 2 或同学 3 在他之前拿到菜；同学 2 允许同学 3 在他之前拿到菜；同学 3 比较小气，他必须比他后面的同学先拿菜。\n\n一种最优的方案是按同学 3、同学 2、同学 1、同学 4、同学 5 做菜，每道菜所需的时间分别是 0、8、1、6 及 1。\n\n\n**数据规模和约定**\n\n- 对于 $30\\%$ 的数据，满足 $1 \\le N \\le 20$。\n\n- 对于 $ 100\\% $ 的数据，满足 $1 \\le N \\le 1000,0 \\le T_i \\le 1000,0 \\le B_i \\le 7，1 \\le C \\le 5$。\n\n- 存在 $30\\%$ 的数据，满足 $0 \\le B_i \\le 1$。\n\n- 存在 $65\\%$ 的数据，满足 $0 \\le B_i \\le 5$。\n\n- 存在 $45\\%$ 的数据，满足 $0 \\le T_i \\le 130$。\n", "locale": "zh-CN"}}}
{"pid": "P2158", "type": "P", "difficulty": 5, "samples": [["4", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "各省省选", "山东", "素数判断,质数,筛法", "莫比乌斯反演", "容斥原理", "欧拉函数"], "title": "[SDOI2008] 仪仗队", "background": "", "description": "作为体育委员，C 君负责这次运动会仪仗队的训练。仪仗队是由学生组成的 $N \\times N$ 的方阵，为了保证队伍在行进中整齐划一，C 君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐（如下图）。\n\n![](https://cdn.luogu.com.cn/upload/pic/1149.png)\n\n现在，C 君希望你告诉他队伍整齐时能看到的学生人数。", "inputFormat": "一行，一个正整数 $N$。", "outputFormat": "输出一行一个数，即 C 君应看到的学生人数。", "hint": "对于 $100 \\%$ 的数据，$1 \\le N \\le 40000$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2008] Honor Guard", "background": "", "description": "As the sports committee member, Mr. C is responsible for training the honor guard for this sports meet. The honor guard is an $N \\times N$ square formation of students. To ensure the formation marches in perfect order, Mr. C follows at the back-left of the formation and judges whether it is neat based on the number of students visible to him (as shown in the figure).\n\n![](https://cdn.luogu.com.cn/upload/pic/1149.png)\n\nNow, Mr. C wants you to tell him the number of students he can see when the formation is neat.", "inputFormat": "One line with a positive integer $N$.", "outputFormat": "Output one line with a single number: the number of students Mr. C should see.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\le N \\le 40000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2008] 仪仗队", "background": "", "description": "作为体育委员，C 君负责这次运动会仪仗队的训练。仪仗队是由学生组成的 $N \\times N$ 的方阵，为了保证队伍在行进中整齐划一，C 君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐（如下图）。\n\n![](https://cdn.luogu.com.cn/upload/pic/1149.png)\n\n现在，C 君希望你告诉他队伍整齐时能看到的学生人数。", "inputFormat": "一行，一个正整数 $N$。", "outputFormat": "输出一行一个数，即 C 君应看到的学生人数。", "hint": "对于 $100 \\%$ 的数据，$1 \\le N \\le 40000$。", "locale": "zh-CN"}}}
{"pid": "P2159", "type": "P", "difficulty": 6, "samples": [["3 0\n178\n188\n176\n168\n178\n170\n", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2009", "各省省选", "上海", "排序"], "title": "[SHOI2009] 舞会", "background": null, "description": "OItown 要举办一年一度的超级舞会了。\n\n为了使今年的舞会规模空前，作为主办方的 Constantine 邀请了许多他的好友和同学去。\n\n舞会那天，恰好来了 $n$ 个男生 $n$ 个女生。\n\nConstantine 发现，一般情况下，舞伴之间，总是男伴总是比女伴长得高，不过，偶尔也是有特殊情况的。\n\n所以，Constantine 现在想知道，如果把这 $2n$ 个人恰好配成 $n$ 对舞伴，有多少种搭配方法，使得最多只有 $k$ 对舞伴之间女伴比男伴高。\n\n现在，Constantine 需要参加 SHTSC 的你帮助他算出这个答案。\n\n当然啦，他会先告诉你这 $2n$ 个同学的身高。", "inputFormat": "第一行：两个整数 $n,k$，含义如问题中所示。\n\n第 $2$ 行到第 $n+1$ 行：$n$ 个整数，表示 $n$ 个男生的身高。\n\n第 $n+2$ 行到第 $2n+1$ 行：$n$ 个整数，表示 $n$ 个女生的身高。", "outputFormat": "一行一个整数表示满足 $n$ 对舞伴中最多只有 $k$ 对舞伴之间女伴比男伴高的男女搭配方案数。", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 200$，$0 \\le k \\le n$，且身高均为不大于 $10^9$ 的正整数。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2009] Dance Party", "background": "# Description\n\nOItown is holding its annual super dance party.\n\nTo make this year’s party bigger than ever, the organizer Constantine invited many of his friends and classmates.\n\nOn the day of the party, exactly $n$ boys and $n$ girls came.\n\nConstantine noticed that, in general, in a pair the boy is taller than the girl, but there are occasional exceptions.\n\nSo Constantine wants to know: if we pair these $2n$ people into exactly $n$ couples, how many ways are there such that at most $k$ couples have the girl taller than the boy?\n\nNow Constantine asks you, who is attending SHTSC, to compute the answer.\n\nOf course, he will first tell you the heights of all $2n$ students.", "description": "", "inputFormat": "", "outputFormat": "Output a single integer in one line: the number of pairing schemes where among the $n$ couples, at most $k$ couples have the girl taller than the boy.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\le n \\le 200$, $0 \\le k \\le n$, and all heights are positive integers not greater than $10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2009] 舞会", "background": null, "description": "OItown 要举办一年一度的超级舞会了。\n\n为了使今年的舞会规模空前，作为主办方的 Constantine 邀请了许多他的好友和同学去。\n\n舞会那天，恰好来了 $n$ 个男生 $n$ 个女生。\n\nConstantine 发现，一般情况下，舞伴之间，总是男伴总是比女伴长得高，不过，偶尔也是有特殊情况的。\n\n所以，Constantine 现在想知道，如果把这 $2n$ 个人恰好配成 $n$ 对舞伴，有多少种搭配方法，使得最多只有 $k$ 对舞伴之间女伴比男伴高。\n\n现在，Constantine 需要参加 SHTSC 的你帮助他算出这个答案。\n\n当然啦，他会先告诉你这 $2n$ 个同学的身高。", "inputFormat": "第一行：两个整数 $n,k$，含义如问题中所示。\n\n第 $2$ 行到第 $n+1$ 行：$n$ 个整数，表示 $n$ 个男生的身高。\n\n第 $n+2$ 行到第 $2n+1$ 行：$n$ 个整数，表示 $n$ 个女生的身高。", "outputFormat": "一行一个整数表示满足 $n$ 对舞伴中最多只有 $k$ 对舞伴之间女伴比男伴高的男女搭配方案数。", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 200$，$0 \\le k \\le n$，且身高均为不大于 $10^9$ 的正整数。", "locale": "zh-CN"}}}
{"pid": "P2160", "type": "P", "difficulty": 6, "samples": [["4\n220 29\n195 20\n200 9\n180 30", "18000"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "数学", "2007", "各省省选", "上海", "排序"], "title": "[SHOI2007] 书柜的尺寸", "background": "", "description": "Tom 不喜欢那种一字长龙式的大书架，他只想要一个小书柜来存放他的系列工具书。Tom 打算把书柜放在桌子的后面，这样需要查书的时候就可以不用起身离开了。\n\n显然，这种书柜不能太大，Tom 希望它的体积越小越好。另外，出于他的审美要求，他只想要一个三层的书柜。为了物尽其用，Tom 规定每层必须至少放一本书。现在的问题是，Tom 怎么分配他的工具书，才能让木匠造出最小的书柜来呢？ \n\nTom很快意识到这是一个数学问题。每本书都有自己的高度 $h_i$ 和厚度 $t_i$。我们需要求的是一个分配方案，也就是要求把所有的书分配在 $S_1$、$S_2$ 和 $S_3$ **三个非空集合**里面的一个，不重复也不遗漏，那么，很明显，书柜正面表面积（$S$）的计算公式就是：  \n\n$$S=\\left(\\sum_{j=1}^3 \\max_{i \\in S_j} h_i\\right) \\times \\left(\\max_{j=1}^3 \\sum_{i \\in S_j} t_i\\right) $$\n\n由于书柜的深度是固定的（显然，它应该等于那本最宽的书的长度），所以要求书柜的体积最小就是**要求 $S$ 最小**。Tom 离答案只有一步之遥了。不过很遗憾，Tom 并不擅长于编程，于是他邀请你来帮助他解决这个问题。", "inputFormat": "第一行一个整数 $n$，代表书本的个数。\n\n接下来 $n$ 行每行有两个整数 $h_i$ 和 $t_i$，代表每本书的高度和厚度。", "outputFormat": "只有一行，即输出最小的 $S$。", "hint": "对于全部数据，$3 \\leq n \\leq 70$，$150 \\leq h_i \\leq 300$，$5 \\leq t_i \\leq 30$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2007] Size of the Bookcase", "background": "", "description": "Tom does not like those long, single-row bookshelves. He only wants a small bookcase to store his series of reference books. Tom plans to place the bookcase behind his desk so he does not need to stand up to look things up.\n\nObviously, this bookcase cannot be too large. Tom wants its volume to be as small as possible. Also, for aesthetic reasons, he wants a three-tier bookcase. To make full use of the space, Tom requires that each tier must contain at least one book. Now the question is: how should Tom distribute his reference books so that the carpenter can build the smallest possible bookcase?\n\nTom quickly realized that this is a math problem. Each book has its own height $h_i$ and thickness $t_i$. What we need is an assignment plan, meaning we must assign every book to exactly one of $S_1$, $S_2$, and $S_3$ — the **three non-empty sets** — with no duplication and no omission. Then, it is clear that the front surface area of the bookcase ($S$) is given by:\n\n$$S=\\left(\\sum_{j=1}^3 \\max_{i \\in S_j} h_i\\right) \\times \\left(\\max_{j=1}^3 \\sum_{i \\in S_j} t_i\\right) $$\n\nSince the depth of the bookcase is fixed (obviously, it should equal the length of the widest book), minimizing the volume of the bookcase is equivalent to minimizing $S$. Tom is just one step away from the answer. Unfortunately, Tom is not good at programming, so he invites you to help him solve this problem.", "inputFormat": "The first line contains an integer $n$, the number of books.\n\nEach of the next $n$ lines contains two integers $h_i$ and $t_i$, representing the height and thickness of each book.", "outputFormat": "Output a single line: the minimal $S$.", "hint": "Constraints: for all testdata, $3 \\leq n \\leq 70$, $150 \\leq h_i \\leq 300$, $5 \\leq t_i \\leq 30$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2007] 书柜的尺寸", "background": "", "description": "Tom 不喜欢那种一字长龙式的大书架，他只想要一个小书柜来存放他的系列工具书。Tom 打算把书柜放在桌子的后面，这样需要查书的时候就可以不用起身离开了。\n\n显然，这种书柜不能太大，Tom 希望它的体积越小越好。另外，出于他的审美要求，他只想要一个三层的书柜。为了物尽其用，Tom 规定每层必须至少放一本书。现在的问题是，Tom 怎么分配他的工具书，才能让木匠造出最小的书柜来呢？ \n\nTom很快意识到这是一个数学问题。每本书都有自己的高度 $h_i$ 和厚度 $t_i$。我们需要求的是一个分配方案，也就是要求把所有的书分配在 $S_1$、$S_2$ 和 $S_3$ **三个非空集合**里面的一个，不重复也不遗漏，那么，很明显，书柜正面表面积（$S$）的计算公式就是：  \n\n$$S=\\left(\\sum_{j=1}^3 \\max_{i \\in S_j} h_i\\right) \\times \\left(\\max_{j=1}^3 \\sum_{i \\in S_j} t_i\\right) $$\n\n由于书柜的深度是固定的（显然，它应该等于那本最宽的书的长度），所以要求书柜的体积最小就是**要求 $S$ 最小**。Tom 离答案只有一步之遥了。不过很遗憾，Tom 并不擅长于编程，于是他邀请你来帮助他解决这个问题。", "inputFormat": "第一行一个整数 $n$，代表书本的个数。\n\n接下来 $n$ 行每行有两个整数 $h_i$ 和 $t_i$，代表每本书的高度和厚度。", "outputFormat": "只有一行，即输出最小的 $S$。", "hint": "对于全部数据，$3 \\leq n \\leq 70$，$150 \\leq h_i \\leq 300$，$5 \\leq t_i \\leq 30$。", "locale": "zh-CN"}}}
{"pid": "P2161", "type": "P", "difficulty": 5, "samples": [["6\nA 10 15\nA 17 19\nA 12 17\nA 90 99\nA 11 12\nB", "0\n0\n2\n0\n1\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "各省省选", "平衡树", "树状数组", "上海", "优先队列"], "title": "[SHOI2009] 会场预约", "background": "**形式化题意：**\n\n你需要维护一个在数轴上的线段的集合 $S$，支持两种操作：\n\n`A l r` 表示将 $S$ 中所有与线段 $[l,r]$ 相交的线段删去，并将 $[l,r]$ 加入 $S$ 中。\n\n`B` 查询 $S$ 中的元素数量。\n\n对于 `A` 操作，每次还需输出删掉的元素个数。", "description": "PP 大厦有一间空的礼堂，可以为企业或者单位提供会议场地。\n\n这些会议中的大多数都需要连续几天的时间（个别的可能只需要一天），不过场地只有一个，所以不同的会议的时间申请不能够冲突。也就是说，前一个会议的结束日期必须在后一个会议的开始日期之前。所以，如果要接受一个新的场地预约申请，就必须拒绝掉与这个申请相冲突的预约。\n\n一般来说，如果 PP 大厦方面事先已经接受了一个会场预约（例如从 $10$ 日到 $15$ 日），就不会再接受与之相冲突的预约（例如从 $12$ 日到 $17$ 日）。\n\n不过，有时出于经济利益，PP 大厦方面有时会为了接受一个新的会场预约，而拒绝掉一个甚至几个之前预订的预约。 于是，礼堂管理员 QQ 的笔记本上经常记录着这样的信息：（本题中为方便起见，所有的日期都用一个整数表示）例如，如果一个为期 $10$ 天的会议从 $90$ 日开始到 $99$ 日，那么下一个会议最早只能在 $100$ 日开始。（此处前后矛盾，若无法理解请参考形式化描述。）\n\n最近，这个业务的工作量与日俱增，礼堂的管理员 QQ 希望参加 SHTSC 的你替他设计一套计算机系统，方便他的工作。这个系统应当能执行下面两个操作：\n\n`A` 操作：有一个新的预约是从 $start$ 日到 $end$ 日，并且拒绝掉所有与它相冲突的预约。执行这个操作的时候，你的系统应当返回为了这个新预约而拒绝掉的预约个数，以方便 QQ 与自己的记录相校对。\n\n`B` 操作：请你的系统返回当前的仍然有效的预约的总数。", "inputFormat": "第一行一个正整数 $n$，表示操作个数。  \n接下来 $n$ 行，每行表示一个操作，都是上面两种中的一个。", "outputFormat": "输出 $n$ 行，每行一个整数，表示对应操作的答案。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 2\\times 10^5$，$1\\le l \\le r \\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2009] Venue Reservation", "background": "Formal statement:\n\nYou need to maintain a set $S$ of segments on the number line, supporting two operations:\n\n`A l r` means to delete from $S$ all segments that intersect the segment $[l, r]$, and then insert $[l, r]$ into $S$.\n\n`B` queries the number of elements in $S$.\n\nFor operation `A`, you also need to output the number of elements deleted each time.", "description": "There is an empty auditorium in the PP Building that can provide a meeting venue for companies or organizations.\n\nMost of these meetings require several consecutive days (some may require only one day). However, there is only one venue, so the times of different meetings cannot conflict. That is, the end date of the previous meeting must be before the start date of the next meeting. Therefore, to accept a new reservation request, all reservations that conflict with it must be rejected.\n\nIn general, if the PP Building has already accepted a venue reservation (for example, from day $10$ to day $15$), then it will not accept any reservation that conflicts with it (for example, from day $12$ to day $17$).\n\nHowever, sometimes for economic reasons, the PP Building will reject one or even several previously accepted reservations in order to accept a new one. Therefore, the administrator QQ’s notebook often records such information. (For convenience in this problem, all dates are represented by an integer.) For example, if a $10$-day meeting runs from day $90$ to day $99$, then the earliest the next meeting can start is day $100$. (There is a contradiction here; if you cannot understand, please refer to the formal description.)\n\nRecently, the workload has been increasing. The administrator QQ hopes you, a participant in SHTSC, can design a computer system to make the work easier. This system should be able to perform the following two operations:\n\nOperation `A`: A new reservation is from day $start$ to day $end$, and all reservations that conflict with it are rejected. When performing this operation, your system should return the number of reservations that were rejected for this new reservation, so QQ can check against the records.\n\nOperation `B`: Your system should return the current total number of valid reservations.", "inputFormat": "The first line contains a positive integer $n$, the number of operations.  \nThen follow $n$ lines, each describing one operation, which is one of the two types above.", "outputFormat": "Output $n$ lines, each with one integer, representing the answer for the corresponding operation.", "hint": "Constraints:  \nFor $100\\%$ of the testdata, $1 \\le n \\le 2 \\times 10^5$, $1 \\le l \\le r \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2009] 会场预约", "background": "**形式化题意：**\n\n你需要维护一个在数轴上的线段的集合 $S$，支持两种操作：\n\n`A l r` 表示将 $S$ 中所有与线段 $[l,r]$ 相交的线段删去，并将 $[l,r]$ 加入 $S$ 中。\n\n`B` 查询 $S$ 中的元素数量。\n\n对于 `A` 操作，每次还需输出删掉的元素个数。", "description": "PP 大厦有一间空的礼堂，可以为企业或者单位提供会议场地。\n\n这些会议中的大多数都需要连续几天的时间（个别的可能只需要一天），不过场地只有一个，所以不同的会议的时间申请不能够冲突。也就是说，前一个会议的结束日期必须在后一个会议的开始日期之前。所以，如果要接受一个新的场地预约申请，就必须拒绝掉与这个申请相冲突的预约。\n\n一般来说，如果 PP 大厦方面事先已经接受了一个会场预约（例如从 $10$ 日到 $15$ 日），就不会再接受与之相冲突的预约（例如从 $12$ 日到 $17$ 日）。\n\n不过，有时出于经济利益，PP 大厦方面有时会为了接受一个新的会场预约，而拒绝掉一个甚至几个之前预订的预约。 于是，礼堂管理员 QQ 的笔记本上经常记录着这样的信息：（本题中为方便起见，所有的日期都用一个整数表示）例如，如果一个为期 $10$ 天的会议从 $90$ 日开始到 $99$ 日，那么下一个会议最早只能在 $100$ 日开始。（此处前后矛盾，若无法理解请参考形式化描述。）\n\n最近，这个业务的工作量与日俱增，礼堂的管理员 QQ 希望参加 SHTSC 的你替他设计一套计算机系统，方便他的工作。这个系统应当能执行下面两个操作：\n\n`A` 操作：有一个新的预约是从 $start$ 日到 $end$ 日，并且拒绝掉所有与它相冲突的预约。执行这个操作的时候，你的系统应当返回为了这个新预约而拒绝掉的预约个数，以方便 QQ 与自己的记录相校对。\n\n`B` 操作：请你的系统返回当前的仍然有效的预约的总数。", "inputFormat": "第一行一个正整数 $n$，表示操作个数。  \n接下来 $n$ 行，每行表示一个操作，都是上面两种中的一个。", "outputFormat": "输出 $n$ 行，每行一个整数，表示对应操作的答案。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 2\\times 10^5$，$1\\le l \\le r \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P2162", "type": "P", "difficulty": 7, "samples": [["17\n", "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020922789888000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "各省省选", "上海"], "title": "[SHOI2007] 宝石纪念币", "background": null, "description": "Constantine 刚结束在 MySky Island 的度假，正准备离开的时候，他想送给她的好朋友 YY 一份特别的礼物——MySky Island 上特别的手工艺品宝石纪念币。\n\n宝石纪念币的一面上刻着小岛的名字 `MySky`，或者收礼物的人，比如 `to YY`。不过特别的是，每枚纪念币的反面，依次均匀的镶着一圈共 $n$ 颗彩色的宝石。\n\n例如，下面是一个 $n=7$ 时的简单例子：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l936rcm4.png)\n\n因为纪念币是圆的，所以如果两种“宝石颜色的排布”经过旋转后对应位置的颜色相重合，就认为它们是相同的排布方式。\n\n（请注意：纪念币只有一面镶宝石，所以两种排布若经过翻转以后是可以重合的，但只经过旋转无法使两者重合，则认为他们是不同的排布。）\n\n例如下面的两种排布方式就是相同的：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/o7uxs4ti.png)\n\n另外，由于 MySky Island 当地的习俗，每枚钱币上都只能嵌奇数颗宝石，不然就认为是不吉利的。\n\n宝石纪念币是现场制作的，游客可以选择自己喜欢的颜色的宝石。所以 Constantine 选出了他最喜欢的 $17$ 种颜色（你如果要问为什么选这么多的话，只能告诉你因为 $17$ 是他的幸运数字）。他想知道，如果按他要求把这 ${17}$ 种颜色的宝石都用上的话，可以制作出多少枚不同的纪念币。\n\n由于答案可能很大，你只需要计算答案的最后 $120$ 位（十进制）就可以了。", "inputFormat": "一行一个正奇数 $n\\ (1 \\le n \\le 10^9-1)$。", "outputFormat": "一行 $120$ 个数字字符，表示不同纪念币的枚数的最后 $120$ 位。这 $120$ 位从高位到低位依次输出，位数不足的用 $0$ 在高位补足。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2007] Gem Commemorative Coin", "background": "", "description": "Constantine has just finished his vacation on MySky Island. As he is about to leave, he wants to give his good friend YY a special gift—a handcrafted gem commemorative coin from MySky Island.\n\nOne side of the coin is engraved with the island’s name “MySky,” or the recipient’s name, for example, “to YY.” What is special is that on the reverse side, there are $n$ colored gems evenly embedded in a circle.\n\nFor example, here is a simple example for $n=7$:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l936rcm4.png)\n\nSince the coin is circular, two “color arrangements of the gems” are considered the same if they can be made to match by a rotation.\n\n(Please note: the gems are embedded on only one side of the coin. Therefore, two arrangements that can be made to match by a reflection but not by any rotation are considered different.)\n\nFor example, the following two arrangements are the same:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/o7uxs4ti.png)\n\nAdditionally, due to local custom on MySky Island, only coins with an odd number of gems are considered auspicious.\n\nThe gem coins are made on site, and tourists can choose the colors they like. Constantine picked his 17 favorite colors (if you ask why so many, it’s because 17 is his lucky number). He wants to know, if all these 17 colors must be used, how many different coins can be made.\n\nSince the answer can be very large, you only need to compute the last 120 digits (in decimal).", "inputFormat": "One line with an odd positive integer $n$ ($1 \\le n \\le 10^9 - 1$).", "outputFormat": "One line with 120 digit characters, representing the last 120 digits of the number of distinct coins. Output the digits from most significant to least significant; if the number has fewer than 120 digits, pad with leading zeros on the left.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2007] 宝石纪念币", "background": null, "description": "Constantine 刚结束在 MySky Island 的度假，正准备离开的时候，他想送给她的好朋友 YY 一份特别的礼物——MySky Island 上特别的手工艺品宝石纪念币。\n\n宝石纪念币的一面上刻着小岛的名字 `MySky`，或者收礼物的人，比如 `to YY`。不过特别的是，每枚纪念币的反面，依次均匀的镶着一圈共 $n$ 颗彩色的宝石。\n\n例如，下面是一个 $n=7$ 时的简单例子：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l936rcm4.png)\n\n因为纪念币是圆的，所以如果两种“宝石颜色的排布”经过旋转后对应位置的颜色相重合，就认为它们是相同的排布方式。\n\n（请注意：纪念币只有一面镶宝石，所以两种排布若经过翻转以后是可以重合的，但只经过旋转无法使两者重合，则认为他们是不同的排布。）\n\n例如下面的两种排布方式就是相同的：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/o7uxs4ti.png)\n\n另外，由于 MySky Island 当地的习俗，每枚钱币上都只能嵌奇数颗宝石，不然就认为是不吉利的。\n\n宝石纪念币是现场制作的，游客可以选择自己喜欢的颜色的宝石。所以 Constantine 选出了他最喜欢的 $17$ 种颜色（你如果要问为什么选这么多的话，只能告诉你因为 $17$ 是他的幸运数字）。他想知道，如果按他要求把这 ${17}$ 种颜色的宝石都用上的话，可以制作出多少枚不同的纪念币。\n\n由于答案可能很大，你只需要计算答案的最后 $120$ 位（十进制）就可以了。", "inputFormat": "一行一个正奇数 $n\\ (1 \\le n \\le 10^9-1)$。", "outputFormat": "一行 $120$ 个数字字符，表示不同纪念币的枚数的最后 $120$ 位。这 $120$ 位从高位到低位依次输出，位数不足的用 $0$ 在高位补足。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2163", "type": "P", "difficulty": 4, "samples": [["3 1\n0 0 \n0 1\n1 0\n0 0 1 1\n", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "各省省选", "树状数组", "离散化", "上海", "cdq 分治", "扫描线"], "title": "[SHOI2007] 园丁的烦恼", "background": "很久很久以前，在遥远的大陆上有一个美丽的国家。统治着这个美丽国家的国王是一个园艺爱好者，在他的皇家花园里种植着各种奇花异草。\n\n有一天国王漫步在花园里，若有所思，他问一个园丁道： “最近我在思索一个问题，如果我们把花坛摆成六个六角形，那么……”\n\n“那么本质上它是一个深度优先搜索，陛下。”园丁深深地向国王鞠了一躬。\n\n“嗯……我听说有一种怪物叫九头蛇，它非常贪吃苹果树……”\n\n“是的，显然这是一道经典的动态规划题，早在 N 元 $4002$ 年我们就已经发现了其中的奥秘了，陛下。”\n\n“该死的，你究竟是什么来头？”\n\n“陛下息怒，干我们的这行经常莫名其妙地被问到和 OI 有关的题目，我也是为了预防万一啊！” 王者的尊严受到了伤害，这是不可容忍的。", "description": "看来一般的难题是难不倒这位园丁的，国王最后打算用车轮战来消耗他的实力： “年轻人，在我的花园里有 $n$ 棵树，每一棵树可以用一个整数坐标来表示，一会儿，我的 $m$ 个骑士们会来轮番询问你某一个矩阵内有多少树，如果你不能立即答对，你就准备走人吧！”说完，国王气呼呼地先走了。\n\n这下轮到园丁傻眼了，他没有准备过这样的问题。所幸的是，作为“全国园丁保护联盟”的会长——你，可以成为他的最后一根救命稻草。", "inputFormat": "第一行有两个整数 $n, m$，分别表示树木个数和询问次数。\n\n接下来 $n$ 行，每行两个整数 $x, y$，表示存在一棵坐标为 $(x, y)$ 的树。有可能存在两棵树位于同一坐标。\n\n接下来 $m$ 行，每行四个整数 $a, b, c, d$，表示查询以 $(a, b)$ 为左下角，$(c, d)$ 为右上角的矩形内部（包括边界）有多少棵树。\n", "outputFormat": "对于每个查询，输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n, m \\leq 10$。\n- 对于 $100\\%$ 的数据，保证 $0 \\leq n \\leq 5 \\times 10^5$，$1 \\leq m \\leq 5 \\times 10^5$，$0 \\leq x, y, a, b, c, d \\leq 10^7$，$a \\leq c$，$b \\leq d$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2007] The Gardener's Trouble", "background": "Long, long ago, on a distant continent there was a beautiful kingdom. The king who ruled this beautiful country was a gardening enthusiast, and in his royal garden he planted all kinds of exotic flowers and grasses.\n\nOne day the king was strolling in the garden, lost in thought. He asked a gardener: \"Lately I have been pondering a question: if we arrange the flowerbeds into six hexagons, then...\"\n\n\"Then, in essence it's a depth-first search, Your Majesty.\" The gardener bowed deeply to the king.\n\n\"Hmm... I have heard of a monster called the Hydra, and it is very fond of eating apple trees...\"\n\n\"Yes, clearly this is a classic dynamic programming problem. As early as the N 元 $4002$ 年 we had already uncovered its secret, Your Majesty.\"\n\n\"Damn it, what on earth are you?\"\n\n\"Please calm down, Your Majesty. In our line of work we often get inexplicably asked questions related to OI. I'm just being prepared for anything!\" The king's dignity was hurt, which was intolerable.", "description": "It seems ordinary hard problems cannot stump this gardener. The king decided to exhaust his strength with a war of attrition: \"Young man, there are $n$ trees in my garden, and each tree can be represented by an integer coordinate. Soon, my $m$ knights will come in turns to ask you how many trees lie inside a certain rectangle. If you cannot answer immediately and correctly, be ready to leave!\" After saying this, the king stormed off.\n\nNow it was the gardener's turn to be dumbfounded—he had not prepared for such a problem. Fortunately, as the president of the \"National Gardeners Protection Alliance\"—you—can become his last lifeline.", "inputFormat": "The first line contains two integers $n, m$, representing the number of trees and the number of queries.\n\nThe next $n$ lines each contain two integers $x, y$, indicating that there is a tree at coordinate $(x, y)$. It is possible that two trees share the same coordinate.\n\nThe next $m$ lines each contain four integers $a, b, c, d$, describing a query: count how many trees are inside the rectangle with lower-left corner $(a, b)$ and upper-right corner $(c, d)$, including the boundary.", "outputFormat": "For each query, output a single integer on its own line indicating the answer.", "hint": "#### Constraints and Conventions\n\n- For $30\\%$ of the testdata, it is guaranteed that $n, m \\leq 10$.\n- For $100\\%$ of the testdata, it is guaranteed that $0 \\leq n \\leq 5 \\times 10^5$, $1 \\leq m \\leq 5 \\times 10^5$, $0 \\leq x, y, a, b, c, d \\leq 10^7$, $a \\leq c$, $b \\leq d$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2007] 园丁的烦恼", "background": "很久很久以前，在遥远的大陆上有一个美丽的国家。统治着这个美丽国家的国王是一个园艺爱好者，在他的皇家花园里种植着各种奇花异草。\n\n有一天国王漫步在花园里，若有所思，他问一个园丁道： “最近我在思索一个问题，如果我们把花坛摆成六个六角形，那么……”\n\n“那么本质上它是一个深度优先搜索，陛下。”园丁深深地向国王鞠了一躬。\n\n“嗯……我听说有一种怪物叫九头蛇，它非常贪吃苹果树……”\n\n“是的，显然这是一道经典的动态规划题，早在 N 元 $4002$ 年我们就已经发现了其中的奥秘了，陛下。”\n\n“该死的，你究竟是什么来头？”\n\n“陛下息怒，干我们的这行经常莫名其妙地被问到和 OI 有关的题目，我也是为了预防万一啊！” 王者的尊严受到了伤害，这是不可容忍的。", "description": "看来一般的难题是难不倒这位园丁的，国王最后打算用车轮战来消耗他的实力： “年轻人，在我的花园里有 $n$ 棵树，每一棵树可以用一个整数坐标来表示，一会儿，我的 $m$ 个骑士们会来轮番询问你某一个矩阵内有多少树，如果你不能立即答对，你就准备走人吧！”说完，国王气呼呼地先走了。\n\n这下轮到园丁傻眼了，他没有准备过这样的问题。所幸的是，作为“全国园丁保护联盟”的会长——你，可以成为他的最后一根救命稻草。", "inputFormat": "第一行有两个整数 $n, m$，分别表示树木个数和询问次数。\n\n接下来 $n$ 行，每行两个整数 $x, y$，表示存在一棵坐标为 $(x, y)$ 的树。有可能存在两棵树位于同一坐标。\n\n接下来 $m$ 行，每行四个整数 $a, b, c, d$，表示查询以 $(a, b)$ 为左下角，$(c, d)$ 为右上角的矩形内部（包括边界）有多少棵树。\n", "outputFormat": "对于每个查询，输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n, m \\leq 10$。\n- 对于 $100\\%$ 的数据，保证 $0 \\leq n \\leq 5 \\times 10^5$，$1 \\leq m \\leq 5 \\times 10^5$，$0 \\leq x, y, a, b, c, d \\leq 10^7$，$a \\leq c$，$b \\leq d$。", "locale": "zh-CN"}}}
{"pid": "P2164", "type": "P", "difficulty": 6, "samples": [["6 7\n1 2\n1 3\n2 4\n2 5\n3 5\n4 6\n5 6\n0 0 0 0 0 1\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0", "0.7\n0.3\n0.3\n0.3\n0.3\n0.3\n0.7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "各省省选", "上海", "Special Judge"], "title": "[SHOI2007] 交通网络", "background": null, "description": "著名的城市交通规划师 L.Serenade 为 OItown 的各个城堡之间设计了一套的地铁交通网络。每一条地铁线路都用来双向连通两个城堡。因为是建在地下的不同深度，所以这些地铁线路是可以“交叉”的。\n\nOItown 的居民们的生活和工作都在不同的城堡中进行，于是，每个 OItown 的居民都要在每天早晨从家出发，乘地铁去工作，当然地铁换乘是允许的。不过每个居民都会选择换乘次数最少的乘车方式。如果有多种乘车方式，这些乘车方式所需要的换乘次数一样，那么居民每天都会等概率的随机选择其中一种。\n\n现在 L.Serenade 想请你为他计算出，每天每条地铁线路在早晨的期望客流量。他会告诉你，每个居民的家和工作地址，还有他设计的地铁交通网络的全部信息。", "inputFormat": "第一行两个正整数 $n,m\\ (2 \\le n \\le 300, n-1 \\le m \\le \\dfrac{n(n-1)}{2})$，表示城堡和线路的个数。\n\n下面 $m$ 行，每行两个正整数 $u,v\\ (1 \\le u,v \\le n, u \\ne v)$，表示一条双向线路 $u \\leftrightarrow v$。\n\n下面一个 $n \\times n$ 的矩阵 $\\{C_{n,n}\\}\\ (0 \\le C_{i,j} \\le 100,C_{i,i}=0)$，其中 $C_{i,j}$ 表示每天早上进行 $i \\to j$ 的出行的居民个数。\n\nL.Serenade 保证，交通网络能把城市连为一体，而且任意两个城堡之间的最优乘车方式（即换乘次数最少的）不超过 $2^{63}-1$ 种。", "outputFormat": "$m$ 行，每行一个一位小数，表示该条线路的期望客流量，绝对误差不得大于 $0.1$。", "hint": "样例解释：\n\n唯一一位居民会等概率地从以下三条路径中选择一条：\n\n- $1 \\to 2 \\to 4 \\to 6$\n- $1 \\to 2 \\to 5 \\to 6$\n- $1 \\to 3 \\to 5 \\to 6$", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2007] Transportation Network", "background": "", "description": "The renowned urban transit planner L.Serenade designed a subway network connecting the castles of OItown. Each subway line bidirectionally connects two castles. Since they are built underground at different depths, these lines can “cross.”\n\nThe residents of OItown live and work in different castles, so every morning each resident departs from home and takes the subway to work. Transfers are allowed. However, each resident chooses a way to travel that minimizes the number of transfers. If there are multiple ways whose numbers of transfers are the same, then each resident chooses one of them uniformly at random every day.\n\nNow L.Serenade asks you to compute the expected passenger flow on each subway line every morning. He will tell you each resident’s home and workplace, as well as all information about the subway network he designed.", "inputFormat": "The first line contains two positive integers $n, m\\ (2 \\le n \\le 300,\\ n - 1 \\le m \\le \\dfrac{n(n - 1)}{2})$, denoting the numbers of castles and lines.\n\nThe next $m$ lines each contain two positive integers $u, v\\ (1 \\le u, v \\le n,\\ u \\ne v)$, indicating a bidirectional line $u \\leftrightarrow v$.\n\nThen follows an $n \\times n$ matrix $\\{C_{i,j}\\}\\ (0 \\le C_{i,j} \\le 100,\\ C_{i,i} = 0)$, where $C_{i,j}$ denotes the number of residents who travel from $i$ to $j$ every morning.\n\nIt is guaranteed that the transit network is connected, and for any two castles the number of optimal ways to travel (i.e., minimizing the number of transfers) does not exceed $2^{63} - 1$.", "outputFormat": "Output $m$ lines, each containing a number with one decimal digit, denoting the expected passenger flow on that line. The absolute error must not exceed $0.1$.", "hint": "Sample explanation:\n\nThe only resident will choose uniformly at random one of the following three paths:\n- $1 \\to 2 \\to 4 \\to 6$.\n- $1 \\to 2 \\to 5 \\to 6$.\n- $1 \\to 3 \\to 5 \\to 6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2007] 交通网络", "background": null, "description": "著名的城市交通规划师 L.Serenade 为 OItown 的各个城堡之间设计了一套的地铁交通网络。每一条地铁线路都用来双向连通两个城堡。因为是建在地下的不同深度，所以这些地铁线路是可以“交叉”的。\n\nOItown 的居民们的生活和工作都在不同的城堡中进行，于是，每个 OItown 的居民都要在每天早晨从家出发，乘地铁去工作，当然地铁换乘是允许的。不过每个居民都会选择换乘次数最少的乘车方式。如果有多种乘车方式，这些乘车方式所需要的换乘次数一样，那么居民每天都会等概率的随机选择其中一种。\n\n现在 L.Serenade 想请你为他计算出，每天每条地铁线路在早晨的期望客流量。他会告诉你，每个居民的家和工作地址，还有他设计的地铁交通网络的全部信息。", "inputFormat": "第一行两个正整数 $n,m\\ (2 \\le n \\le 300, n-1 \\le m \\le \\dfrac{n(n-1)}{2})$，表示城堡和线路的个数。\n\n下面 $m$ 行，每行两个正整数 $u,v\\ (1 \\le u,v \\le n, u \\ne v)$，表示一条双向线路 $u \\leftrightarrow v$。\n\n下面一个 $n \\times n$ 的矩阵 $\\{C_{n,n}\\}\\ (0 \\le C_{i,j} \\le 100,C_{i,i}=0)$，其中 $C_{i,j}$ 表示每天早上进行 $i \\to j$ 的出行的居民个数。\n\nL.Serenade 保证，交通网络能把城市连为一体，而且任意两个城堡之间的最优乘车方式（即换乘次数最少的）不超过 $2^{63}-1$ 种。", "outputFormat": "$m$ 行，每行一个一位小数，表示该条线路的期望客流量，绝对误差不得大于 $0.1$。", "hint": "样例解释：\n\n唯一一位居民会等概率地从以下三条路径中选择一条：\n\n- $1 \\to 2 \\to 4 \\to 6$\n- $1 \\to 2 \\to 5 \\to 6$\n- $1 \\to 3 \\to 5 \\to 6$", "locale": "zh-CN"}}}
{"pid": "P2165", "type": "P", "difficulty": 3, "samples": [["8\n1\n2\n2\n3\n1\n1\n3\n3\n", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2009", "各省省选", "安徽"], "title": "[AHOI2009] 飞行棋", "background": "", "description": "给出圆周上的若干个点，已知点与点之间的弧长，其值均为正整数，并依圆周顺序排列。请找出这些点中有没有可以围成矩形的，并希望在最短时间内找出所有不重复矩形。", "inputFormat": "第一行为正整数 $N$，表示点的个数，接下来 $N$ 行分别为这 $N$ 个点所分割的各个圆弧长度。", "outputFormat": "所构成不重复矩形的个数。", "hint": "$N \\le 20$。\n\n![](https://cdn.luogu.com.cn/upload/pic/13233.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2009] Aeroplane Chess", "background": "", "description": "Given several points on a circle and the arc lengths between consecutive points in circular order (each a positive integer), determine how many distinct rectangles can be formed by choosing four of these points as vertices.", "inputFormat": "The first line contains a positive integer $N$, the number of points. Each of the next $N$ lines gives the length of the arc between consecutive points along the circle, in circular order.", "outputFormat": "Output a single integer: the number of distinct rectangles formed.", "hint": "$N \\le 20$。\n\n![](https://cdn.luogu.com.cn/upload/pic/13233.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2009] 飞行棋", "background": "", "description": "给出圆周上的若干个点，已知点与点之间的弧长，其值均为正整数，并依圆周顺序排列。请找出这些点中有没有可以围成矩形的，并希望在最短时间内找出所有不重复矩形。", "inputFormat": "第一行为正整数 $N$，表示点的个数，接下来 $N$ 行分别为这 $N$ 个点所分割的各个圆弧长度。", "outputFormat": "所构成不重复矩形的个数。", "hint": "$N \\le 20$。\n\n![](https://cdn.luogu.com.cn/upload/pic/13233.png)\n", "locale": "zh-CN"}}}
