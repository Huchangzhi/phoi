{"pid": "P12955", "type": "P", "difficulty": 5, "samples": [["3\n4\n2 3 4 3\n4 3 2 1\n4\n2 3 4 1\n1 3 1 3\n7\n3 5 2 5 3 7 6\n3 4 6 3 5 1 2", "Case #1: 4\nCase #2: 5\nCase #3: 10"]], "limits": {"time": [40000, 40000, 40000], "memory": [2097152, 2097152, 2097152]}, "tags": ["2023", "Google Code Jam"], "title": "[GCJ Farewell Round #2] Railroad Management", "background": "", "description": "You are in charge of the management of a railroad network. The network consists of $\\mathbf{N}$ stations. Each station $i$ needs to ship goods to exactly one other station $\\mathbf{D}_i$. Station $i$ will send exactly one shipment, in a train with exactly $\\mathbf{C}_i$ railroad cars.\n\nYou get all the shipment information well in advance, so you plan on saving on railroad cars by reusing them. If station $i$ sends $n$ railroad cars to station $\\mathbf{D}_i$, then $\\mathbf{D}_i$ can add those railroad cars to its supply to use for its own shipment if it did not already happen.\n\nFormally, you must give an initial supply of railroad cars to each station (some stations may get 0) and provide an order for the shipments so that, by the time station $i$ must ship, the number of railroad cars between its initial supply and any previous shipments that arrived at $i$ must be at least the number it needs for its own shipment $\\mathbf{C}_i$. You cannot send more than $\\mathbf{C}_i$ cars in a shipment out of station $i$, even if the station has more than $\\mathbf{C}_i$ available.\n\nFor example, suppose that station 1 sends a train carrying exactly 3 railroad cars to station 4. Now, if station 4 needs 2 cars, it could reuse 2 of the cars it received from station 1. And if station 4 needs to send 5 cars, it can reuse all 3 cars received from station 1 and add 2 of its own supply. Note that when station 4 needs to send 2 cars, it cannot send all 3 it received from station 1.\n\nGiven the shipment information, what is the minimum number of railroad cars you need to distribute for the stations' initial supplies, such that you can do all shipments in some order?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of 3 lines. The first line contains a single integer $\\mathbf{N}$, the number of stations in the network. The second line contains $\\mathbf{N}$ integers $\\mathbf{D}_1, \\mathbf{D}_2, \\ldots, \\mathbf{D}_\\mathbf{N}$ and the third and last line contains $\\mathbf{N}$ integers $\\mathbf{C}_1, \\mathbf{C}_2, \\ldots, \\mathbf{C}_\\mathbf{N}$. These represent that station $i$ must send a train of exactly $\\mathbf{C}_i$ railroad cars to station $\\mathbf{D}_i$.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of railroad cars you need to distribute among the stations so that all shipments can be performed.", "hint": "**Sample Explanation**\n\nIn Sample Case #1 one optimal way is to do the shipments in increasing order of departure station. That requires sending 4 cars to station 1. But after that, each station receives enough cars for its shipment, for a total of 4 overall. Since no cars arrive at station 1, it definitely needs the initial 4, so this is also the minimum possible.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rzy2faew.png)\n\nIn Sample Case #2 one minimal way is to supply 1 car to station 3 and 2 cars each to stations and 2 and 4, for a total of 5. Then, we can start with the shipment $3 \\rightarrow 4$ which gets one additional car to station 4. This makes station 4 have the 3 cars it needs to ship $4 \\rightarrow 1$. Station 1 now has 3 cars which is enough to do $1 \\rightarrow 2$ with a single car, taking the total at station 2 to 3 cars, enough to do the final shipment $2 \\rightarrow 3$. Notice that the shipment $1 \\rightarrow 2$ cannot bring extra cars to station 2, even though there are cars available and it would be helpful to do so. There are other ways to do all shipments with 5 initial cars, but no way to do it with less.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ax0frede.png)\n\nIn Sample Case #3, one optimal starting number of cars is 3 cars at stations 1 and 4 and 2 cars at stations 5 and 7.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{D}_{\\mathbf{i}} \\leq \\mathbf{N}$, for all $i$.\n- $\\mathbf{D}_{\\mathbf{i}} \\neq i$, for all $i$.\n- $1 \\leq \\mathbf{C}_{\\mathbf{i}} \\leq 10^{9}$, for all $i$.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 8$.\n\n**Test Set 2 (20 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 10^{5}$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #2] Railroad Management", "background": "", "description": "You are in charge of the management of a railroad network. The network consists of $\\mathbf{N}$ stations. Each station $i$ needs to ship goods to exactly one other station $\\mathbf{D}_i$. Station $i$ will send exactly one shipment, in a train with exactly $\\mathbf{C}_i$ railroad cars.\n\nYou get all the shipment information well in advance, so you plan on saving on railroad cars by reusing them. If station $i$ sends $n$ railroad cars to station $\\mathbf{D}_i$, then $\\mathbf{D}_i$ can add those railroad cars to its supply to use for its own shipment if it did not already happen.\n\nFormally, you must give an initial supply of railroad cars to each station (some stations may get 0) and provide an order for the shipments so that, by the time station $i$ must ship, the number of railroad cars between its initial supply and any previous shipments that arrived at $i$ must be at least the number it needs for its own shipment $\\mathbf{C}_i$. You cannot send more than $\\mathbf{C}_i$ cars in a shipment out of station $i$, even if the station has more than $\\mathbf{C}_i$ available.\n\nFor example, suppose that station 1 sends a train carrying exactly 3 railroad cars to station 4. Now, if station 4 needs 2 cars, it could reuse 2 of the cars it received from station 1. And if station 4 needs to send 5 cars, it can reuse all 3 cars received from station 1 and add 2 of its own supply. Note that when station 4 needs to send 2 cars, it cannot send all 3 it received from station 1.\n\nGiven the shipment information, what is the minimum number of railroad cars you need to distribute for the stations' initial supplies, such that you can do all shipments in some order?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of 3 lines. The first line contains a single integer $\\mathbf{N}$, the number of stations in the network. The second line contains $\\mathbf{N}$ integers $\\mathbf{D}_1, \\mathbf{D}_2, \\ldots, \\mathbf{D}_\\mathbf{N}$ and the third and last line contains $\\mathbf{N}$ integers $\\mathbf{C}_1, \\mathbf{C}_2, \\ldots, \\mathbf{C}_\\mathbf{N}$. These represent that station $i$ must send a train of exactly $\\mathbf{C}_i$ railroad cars to station $\\mathbf{D}_i$.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of railroad cars you need to distribute among the stations so that all shipments can be performed.", "hint": "**Sample Explanation**\n\nIn Sample Case #1 one optimal way is to do the shipments in increasing order of departure station. That requires sending 4 cars to station 1. But after that, each station receives enough cars for its shipment, for a total of 4 overall. Since no cars arrive at station 1, it definitely needs the initial 4, so this is also the minimum possible.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rzy2faew.png)\n\nIn Sample Case #2 one minimal way is to supply 1 car to station 3 and 2 cars each to stations and 2 and 4, for a total of 5. Then, we can start with the shipment $3 \\rightarrow 4$ which gets one additional car to station 4. This makes station 4 have the 3 cars it needs to ship $4 \\rightarrow 1$. Station 1 now has 3 cars which is enough to do $1 \\rightarrow 2$ with a single car, taking the total at station 2 to 3 cars, enough to do the final shipment $2 \\rightarrow 3$. Notice that the shipment $1 \\rightarrow 2$ cannot bring extra cars to station 2, even though there are cars available and it would be helpful to do so. There are other ways to do all shipments with 5 initial cars, but no way to do it with less.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ax0frede.png)\n\nIn Sample Case #3, one optimal starting number of cars is 3 cars at stations 1 and 4 and 2 cars at stations 5 and 7.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{D}_{\\mathbf{i}} \\leq \\mathbf{N}$, for all $i$.\n- $\\mathbf{D}_{\\mathbf{i}} \\neq i$, for all $i$.\n- $1 \\leq \\mathbf{C}_{\\mathbf{i}} \\leq 10^{9}$, for all $i$.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 8$.\n\n**Test Set 2 (20 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 10^{5}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #2] Railroad Management", "background": "", "description": "你负责管理一个铁路运输网络。该网络由 $\\mathbf{N}$ 个车站组成。每个车站 $i$ 需要向另一个车站 $\\mathbf{D}_i$ 运输货物。车站 $i$ 将发送恰好一趟列车，该列车包含恰好 $\\mathbf{C}_i$ 节车厢。\n\n你提前获得了所有运输信息，因此计划通过重复使用车厢来节省资源。如果车站 $i$ 向车站 $\\mathbf{D}_i$ 发送了 $n$ 节车厢，那么车站 $\\mathbf{D}_i$ 可以将这些车厢加入自己的资源库以供后续使用（前提是这些车厢尚未被使用过）。\n\n具体来说，你需要为每个车站分配初始车厢数量（某些车站可能分配 0 节），并确定运输顺序，使得当车站 $i$ 需要进行运输时，其初始分配的车厢数量加上之前到达该站的车厢数量至少等于其运输需求 $\\mathbf{C}_i$。注意：即使车站 $i$ 当前拥有的车厢数量多于 $\\mathbf{C}_i$，每次运输也只能发送恰好 $\\mathbf{C}_i$ 节车厢。\n\n例如，假设车站 1 向车站 4 发送了 3 节车厢。如果车站 4 需要 2 节车厢，它可以重复使用从车站 1 接收的 2 节车厢。如果车站 4 需要发送 5 节车厢，它可以重复使用从车站 1 接收的 3 节车厢，并额外使用自己初始分配的 2 节。需要注意的是，当车站 4 只需要发送 2 节车厢时，它不能发送从车站 1 接收的全部 3 节车厢。\n\n给定运输信息，问：在所有可能的运输顺序中，车站初始分配的车厢总数的最小值是多少？", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例包含 3 行：第一行是一个整数 $\\mathbf{N}$，表示车站数量；第二行包含 $\\mathbf{N}$ 个整数 $\\mathbf{D}_1, \\mathbf{D}_2, \\ldots, \\mathbf{D}_\\mathbf{N}$；第三行包含 $\\mathbf{N}$ 个整数 $\\mathbf{C}_1, \\mathbf{C}_2, \\ldots, \\mathbf{C}_\\mathbf{N}$。这表示车站 $i$ 需要向车站 $\\mathbf{D}_i$ 发送恰好 $\\mathbf{C}_i$ 节车厢。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是满足所有运输需求所需的最少初始车厢总数。\n", "hint": "**样例解释**\n\n在样例 #1 中，最优方案是按照车站编号递增的顺序进行运输。这需要为车站 1 初始分配 4 节车厢。之后每个车站都能从接收的车厢中获得足够的资源，因此初始车厢总数为 4。由于没有车厢到达车站 1，它必须初始拥有全部 4 节车厢，因此这也是可能的最小值。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rzy2faew.png)\n\n在样例 #2 中，一种最优方案是为车站 3 分配 1 节车厢，为车站 2 和 4 各分配 2 节车厢，总计 5 节。然后可以先执行运输 $3 \\rightarrow 4$，这将为车站 4 增加 1 节车厢。此时车站 4 拥有 3 节车厢，足以完成运输 $4 \\rightarrow 1$。车站 1 现在有 3 节车厢，可以完成运输 $1 \\rightarrow 2$（只发送 1 节），使车站 2 的车厢总数达到 3 节，足以完成最后的运输 $2 \\rightarrow 3$。注意运输 $1 \\rightarrow 2$ 不能额外发送更多车厢，即使这对后续运输有帮助。存在其他使用 5 节初始车厢的方案，但无法使用更少的初始车厢完成所有运输。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ax0frede.png)\n\n在样例 #3 中，一种最优方案是为车站 1 和 4 各分配 3 节车厢，为车站 5 和 7 各分配 2 节车厢。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 对所有 $i$，$1 \\leq \\mathbf{D}_i \\leq \\mathbf{N}$。\n- 对所有 $i$，$\\mathbf{D}_i \\neq i$。\n- 对所有 $i$，$1 \\leq \\mathbf{C}_i \\leq 10^9$。\n\n**测试集 1（9 分，可见判定）**\n- $2 \\leq \\mathbf{N} \\leq 8$。\n\n**测试集 2（20 分，可见判定）**\n- $2 \\leq \\mathbf{N} \\leq 10^5$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12956", "type": "P", "difficulty": 3, "samples": [["3\n3\nCO DEJ AM\n3\nCODE JA M\n2\nABABABAB AAA", "Case #1: POSSIBLE\nCO DEJ MA\nCase #2: POSSIBLE\nCODE JA M\nCase #3: IMPOSSIBLE"]], "limits": {"time": [5000, 5000, 5000], "memory": [2097152, 2097152, 2097152]}, "tags": ["2023", "Special Judge", "Google Code Jam"], "title": "[GCJ Farewell Round #3] Game Sort: Part 1", "background": null, "description": "Note: The main parts of the statements of the problems \"Game Sort: Part 1\" and \"Game Sort: Part 2\" are identical, except for the last paragraph. The problems can otherwise be solved independently.\n\nAmir and Badari are playing a sorting game. The game starts with a string $\\mathbf{S}$ and an integer $\\mathbf{P}$ being chosen by an impartial judge. Then, Amir has to split $\\mathbf{S}$ into exactly $\\mathbf{P}$ contiguous non-empty parts (substrings). For example, if $\\mathbf{S} = \\text{CODEJAM}$ was the chosen string and $\\mathbf{P} = 3$, Amir could split it up as $[\\text{COD}, \\text{EJA}, \\text{M}]$ or as $[\\text{CO}, \\text{D}, \\text{EJAM}]$, but not as $[\\text{COD}, \\text{EJAM}]$, $[\\text{COD}, \\text{JA}, \\text{M}]$, $[\\text{EJA}, \\text{COD}, \\text{M}]$, nor as $[\\text{CODE}, \\text{EJA}, \\text{M}]$.\n\nThen, Badari must rearrange the letters within each part to make the list of parts be sorted in non-decreasing lexicographical order. If she can, then she wins. Otherwise, Amir wins.\n\nGiven the partition Amir made, can you help Badari win the game, or say that it is not possible?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines. The first line of a test case contains a single integer $\\mathbf{P}$, the number of parts Amir made. The second line contains $\\mathbf{P}$ strings $\\mathbf{S}_1, \\mathbf{S}_2, \\ldots, \\mathbf{S}_\\mathbf{P}$, representing the $\\mathbf{P}$ parts, in order.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either $\\text{POSSIBLE}$ if Badari can win the game, or $\\text{IMPOSSIBLE}$ if she cannot. If she can win the game, output a second line containing $t_1 t_2 \\ldots t_\\mathbf{P}$ where $t_i$ is a rearrangement of the letters of $\\mathbf{S}_i$, and $t_i$ is lexicographically earlier than or equal to $t_{i+1}$, for all $i$. If there are multiple solutions, you may output any one of them.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, Badari could also win in 5 other ways. Two of them are $[\\text{CO}, \\text{JED}, \\text{MA}]$ and $[\\text{CO}, \\text{EJD}, \\text{MA}]$.\n\nIn Sample Case #2, Badari can win simply by leaving all parts as Amir gave it to her, but other ways are also possible.\n\nIn Sample Case #3 Amir has guaranteed a win for himself leaving Badari no winning option.\n\n**Limits**\n\n$1 \\leq \\mathbf{T} \\leq 100$.\n\nEach character of $\\mathbf{S}_i$ is an English uppercase letter A through Z, for all $i$.\n\n**Test Set 1 (4 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{P} \\leq 3$.\n- $1 \\leq \\text{the length of } \\mathbf{S}_i \\leq 8$, for all $i$.\n\n**Test Set 2 (9 Pts, Hidden Verdict)**\n\n- $2 \\leq \\mathbf{P} \\leq 100$.\n- $1 \\leq \\text{the length of } \\mathbf{S}_i \\leq 100$, for all $i$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #3] Game Sort: Part 1", "background": null, "description": "Note: The main parts of the statements of the problems \"Game Sort: Part 1\" and \"Game Sort: Part 2\" are identical, except for the last paragraph. The problems can otherwise be solved independently.\n\nAmir and Badari are playing a sorting game. The game starts with a string $\\mathbf{S}$ and an integer $\\mathbf{P}$ being chosen by an impartial judge. Then, Amir has to split $\\mathbf{S}$ into exactly $\\mathbf{P}$ contiguous non-empty parts (substrings). For example, if $\\mathbf{S} = \\text{CODEJAM}$ was the chosen string and $\\mathbf{P} = 3$, Amir could split it up as $[\\text{COD}, \\text{EJA}, \\text{M}]$ or as $[\\text{CO}, \\text{D}, \\text{EJAM}]$, but not as $[\\text{COD}, \\text{EJAM}]$, $[\\text{COD}, \\text{JA}, \\text{M}]$, $[\\text{EJA}, \\text{COD}, \\text{M}]$, nor as $[\\text{CODE}, \\text{EJA}, \\text{M}]$.\n\nThen, Badari must rearrange the letters within each part to make the list of parts be sorted in non-decreasing lexicographical order. If she can, then she wins. Otherwise, Amir wins.\n\nGiven the partition Amir made, can you help Badari win the game, or say that it is not possible?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines. The first line of a test case contains a single integer $\\mathbf{P}$, the number of parts Amir made. The second line contains $\\mathbf{P}$ strings $\\mathbf{S}_1, \\mathbf{S}_2, \\ldots, \\mathbf{S}_\\mathbf{P}$, representing the $\\mathbf{P}$ parts, in order.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either $\\text{POSSIBLE}$ if Badari can win the game, or $\\text{IMPOSSIBLE}$ if she cannot. If she can win the game, output a second line containing $t_1 t_2 \\ldots t_\\mathbf{P}$ where $t_i$ is a rearrangement of the letters of $\\mathbf{S}_i$, and $t_i$ is lexicographically earlier than or equal to $t_{i+1}$, for all $i$. If there are multiple solutions, you may output any one of them.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, Badari could also win in 5 other ways. Two of them are $[\\text{CO}, \\text{JED}, \\text{MA}]$ and $[\\text{CO}, \\text{EJD}, \\text{MA}]$.\n\nIn Sample Case #2, Badari can win simply by leaving all parts as Amir gave it to her, but other ways are also possible.\n\nIn Sample Case #3 Amir has guaranteed a win for himself leaving Badari no winning option.\n\n**Limits**\n\n$1 \\leq \\mathbf{T} \\leq 100$.\n\nEach character of $\\mathbf{S}_i$ is an English uppercase letter A through Z, for all $i$.\n\n**Test Set 1 (4 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{P} \\leq 3$.\n- $1 \\leq \\text{the length of } \\mathbf{S}_i \\leq 8$, for all $i$.\n\n**Test Set 2 (9 Pts, Hidden Verdict)**\n\n- $2 \\leq \\mathbf{P} \\leq 100$.\n- $1 \\leq \\text{the length of } \\mathbf{S}_i \\leq 100$, for all $i$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #3] Game Sort: Part 1", "background": null, "description": "**注意**：问题 **Game Sort: Part 1** 和 **Game Sort: Part 2** 的题目描述主要部分相同，仅最后一段不同。这两个问题可以独立解决。\n\nAmir 和 Badari 正在玩一个排序游戏。游戏开始时，一位公正的裁判会选择一个字符串 $\\mathbf{S}$ 和一个整数 $\\mathbf{P}$。然后，Amir 需要将 $\\mathbf{S}$ 分割成恰好 $\\mathbf{P}$ 个连续的非空部分（子字符串）。例如，如果选择的字符串是 $\\mathbf{S} = \\text{CODEJAM}$ 且 $\\mathbf{P} = 3$，Amir 可以将其分割为 $[\\text{COD}, \\text{EJA}, \\text{M}]$ 或 $[\\text{CO}, \\text{D}, \\text{EJAM}]$，但不能分割为 $[\\text{COD}, \\text{EJAM}]$、$[\\text{COD}, \\text{JA}, \\text{M}]$、$[\\text{EJA}, \\text{COD}, \\text{M}]$ 或 $[\\text{CODE}, \\text{EJA}, \\text{M}]$。\n\n接着，Badari 必须对每个部分的字母重新排列，使得这些部分按字典序非递减的顺序排列。如果她能完成，则她获胜；否则，Amir 获胜。\n\n给定 Amir 的分割方案，你能帮助 Badari 赢得游戏，或者判断这是否不可能吗？", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。接下来是 $\\mathbf{T}$ 个测试用例。每个测试用例包含两行：第一行是一个整数 $\\mathbf{P}$，表示 Amir 分割的部分数量；第二行包含 $\\mathbf{P}$ 个字符串 $\\mathbf{S}_1, \\mathbf{S}_2, \\ldots, \\mathbf{S}_\\mathbf{P}$，按顺序表示分割后的部分。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是 `POSSIBLE`（如果 Badari 可以获胜）或 `IMPOSSIBLE`（如果她不能）。如果她可以获胜，则额外输出一行，包含 $t_1 t_2 \\ldots t_\\mathbf{P}$，其中 $t_i$ 是 $\\mathbf{S}_i$ 的字母重新排列后的结果，且对于所有 $i$，$t_i$ 的字典序不大于 $t_{i+1}$。如果有多种解，输出任意一种即可。", "hint": "**样例解释**\n\n在样例 #1 中，Badari 还可以通过其他 5 种方式获胜，其中两种是 $[\\text{CO}, \\text{JED}, \\text{MA}]$ 和 $[\\text{CO}, \\text{EJD}, \\text{MA}]$。\n\n在样例 #2 中，Badari 可以直接保留 Amir 给出的分割方案获胜，但其他方式也是可行的。\n\n在样例 #3 中，Amir 确保了 Badari 无法获胜。\n\n**限制条件**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 对于所有 $i$，$\\mathbf{S}_i$ 的每个字符均为大写字母 A 到 Z。\n\n**测试集 1（4 分，可见判定）**\n\n- $2 \\leq \\mathbf{P} \\leq 3$。\n- 对于所有 $i$，$1 \\leq \\mathbf{S}_i \\text{ 的长度} \\leq 8$。\n\n**测试集 2（9 分，隐藏判定）**\n\n- $2 \\leq \\mathbf{P} \\leq 100$。\n- 对于所有 $i$，$1 \\leq \\mathbf{S}_i \\text{ 的长度} \\leq 100$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12957", "type": "P", "difficulty": 3, "samples": [["4\n5 4\n121 312 271 422 75\n199 464 160 234 368\n271 -109 -70 371\n2 2\n1 3\n4 4\n4 -1\n2 2\n1 4\n4 3\n4 -1\n1 10\n1\n2\n-987654321 -987654321 -987654321 -987654321 -987654321 987654321 987654321 987654321 987654321 987654323", "Case #1: 1 0 1 1\nCase #2: 2 0\nCase #3: 1 1\nCase #4: 0 0 0 0 0 0 0 0 0 1"]], "limits": {"time": [20000, 20000, 40000], "memory": [2097152, 2097152, 2097152]}, "tags": ["模拟", "堆", "2023", "Google Code Jam"], "title": "[GCJ Farewell Round #3] Immunization Operation", "background": "", "description": "Making every vaccine available to the entire world population is a complicated problem in many respects. Ñambi is leading the charge to optimize delivery. To reduce the access barriers as much as possible, she is trying to have automated robots deliver and apply vaccines directly in patients' homes.\n\nIn the current iteration, the robot that Ñambi is designing will work on a single street that runs from west to east. As such, the robot accepts a single command 'move $x$ meters'. If $x$ is positive, the robot moves $x$ meters to the east. If $x$ is negative, the robot moves $-x$ meters to the west.\n\nThe robot is loaded at the start of the day with the information about all immunizations it must provide that day. Each of these pieces of information consists of the current location of the vaccine, for pickup, and the location of the patient that must receive it, for delivery. Each vaccine is custom-made for one patient. Of course, the delivery location of a vaccine is never the same as its own pickup location. The robot must pick up the vaccine before it delivers it to the patient.\n\nThe robot is programmed to automatically pick up and load onto its cargo area vaccines when it passes through their pickup locations for the first time. The robot is also programmed to deliver the vaccine to its recipient as soon as it passes through their location if the vaccine was already picked up. Ñambi wants to track how many vaccinations happen after each movement command. A vaccination happens when the vaccine is delivered. Notice that the vaccine might be picked up during any of the previous commands, or during the same command, but before delivery.\n\nThe following picture illustrates one possible scenario (Sample Case #1 below). The smiley face represents the initial position of the robot, and the long black line is the street. The marks above the line are the pickup locations and the marks below are the delivery locations. Finally, the arrows below represent the moves the robot makes, in order from top to bottom, labeled with how many deliveries are completed during the move.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/05p9howp.png)\n\nThis is what happens during each move, in order:\n\n* Move 1. The robot picks up vaccines 5 and 1, then delivers vaccine 1, and then picks up vaccine 3 just as the move is finishing. Notice that the robot passes through the delivery location for vaccine 3, but since that happens before picking vaccine 3 up, it cannot deliver it.\n* Move 2. The robot passes through the delivery locations of vaccines 1 and 4. However, vaccine 1 is already delivered and vaccine 4 has not been picked up, so no vaccination is finished.\n* Move 3. The robot delivers vaccine 3.\n* Move 4. The robot picks up vaccine 2, delivers vaccine 5 and picks up vaccine 4.\n\nNotice that vaccine 2 and 4 were picked up but not delivered because the delivery location of vaccine 2 was never reached, and the delivery location of vaccine 4 was not reached after the vaccine had been picked up.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of 4 lines. The first line of a test case contains 2 integers $\\mathbf{V}$ and $\\mathbf{M}$, the number of vaccinations and the number of move commands.\n\nThe second line of a test case contains $\\mathbf{V}$ integers $\\mathbf{P}_1, \\mathbf{P}_2, \\ldots, \\mathbf{P}_\\mathbf{V}$, representing that the $i$-th vaccine must be picked up exactly $\\mathbf{P}_i$ meters to the east of the robot's initial location. Note that several vaccines can have the same pickup location.\n\nThe third line contains $\\mathbf{V}$ integers $\\mathbf{D}_1, \\mathbf{D}_2, \\ldots, \\mathbf{D}_\\mathbf{V}$, representing that the $i$-th vaccine must be delivered exactly $\\mathbf{D}_i$ meters to the east of the robot's initial location. Note that several vaccines can have the same delivery location.\n\nThe final line of a test case contains $\\mathbf{M}$ integers $\\mathbf{X}_1, \\mathbf{X}_2, \\ldots, \\mathbf{X}_\\mathbf{M}$, where the absolute value of $\\mathbf{X}_j$ is the number of meters the robot must move for the $j$-th movement command. The $j$-th move must be towards the east if $\\mathbf{X}_j$ is positive, and towards the west if it is negative. Notice that the vaccinations can happen in an order different than the numbering of the input, but movement commands happen in the given order.", "outputFormat": "For each test case, output one line containing `case #x: y1 y2 ... yM`, where $x$ is the test case number (starting from 1) and $y_j$ is the number of vaccinations completed while performing the $j$-th given movement command.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one explained and illustrated in the problem statement.\n\nIn Sample Case #2 and Sample Case #3, notice that it is possible to pick up and deliver vaccines in the same move only if the pickup place is visited first. In addition, notice that it is possible pick up and to deliver exactly as a move is ending.\n\nSample Case #4, the robot moves $987654321$ meters to the west five times, then $987654321$ meters to the east four times, then $987654323$ meters to the east. The only pickup and delivery are both made in the final move. Note that the commands can be very extreme so the robot can be at some point very far away from its initial position, either west or east.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{P}_i \\leq 10^9$, for all $i$.\n- $1 \\leq \\mathbf{D}_i \\leq 10^9$, for all $i$.\n- $\\mathbf{P}_i \\neq \\mathbf{D}_i$, for all $i$.\n- $-10^9 \\leq \\mathbf{X}_j \\leq 10^9$, for all $j$.\n- $\\mathbf{X}_j \\neq 0$, for all $j$.\n\n**Test Set 1 (4 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $1 \\leq \\mathbf{V} \\leq 100$.\n- $1 \\leq \\mathbf{M} \\leq 100$.\n\n**Test Set 2 (9 Pts, Hidden Verdict)**\n\n- Time limit: 40 seconds.\n- $1 \\leq \\mathbf{V} \\leq 10^5$.\n- $1 \\leq \\mathbf{M} \\leq 10^5$.\n", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #3] Immunization Operation", "background": "", "description": "Making every vaccine available to the entire world population is a complicated problem in many respects. Ñambi is leading the charge to optimize delivery. To reduce the access barriers as much as possible, she is trying to have automated robots deliver and apply vaccines directly in patients' homes.\n\nIn the current iteration, the robot that Ñambi is designing will work on a single street that runs from west to east. As such, the robot accepts a single command 'move $x$ meters'. If $x$ is positive, the robot moves $x$ meters to the east. If $x$ is negative, the robot moves $-x$ meters to the west.\n\nThe robot is loaded at the start of the day with the information about all immunizations it must provide that day. Each of these pieces of information consists of the current location of the vaccine, for pickup, and the location of the patient that must receive it, for delivery. Each vaccine is custom-made for one patient. Of course, the delivery location of a vaccine is never the same as its own pickup location. The robot must pick up the vaccine before it delivers it to the patient.\n\nThe robot is programmed to automatically pick up and load onto its cargo area vaccines when it passes through their pickup locations for the first time. The robot is also programmed to deliver the vaccine to its recipient as soon as it passes through their location if the vaccine was already picked up. Ñambi wants to track how many vaccinations happen after each movement command. A vaccination happens when the vaccine is delivered. Notice that the vaccine might be picked up during any of the previous commands, or during the same command, but before delivery.\n\nThe following picture illustrates one possible scenario (Sample Case #1 below). The smiley face represents the initial position of the robot, and the long black line is the street. The marks above the line are the pickup locations and the marks below are the delivery locations. Finally, the arrows below represent the moves the robot makes, in order from top to bottom, labeled with how many deliveries are completed during the move.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/05p9howp.png)\n\nThis is what happens during each move, in order:\n\n* Move 1. The robot picks up vaccines 5 and 1, then delivers vaccine 1, and then picks up vaccine 3 just as the move is finishing. Notice that the robot passes through the delivery location for vaccine 3, but since that happens before picking vaccine 3 up, it cannot deliver it.\n* Move 2. The robot passes through the delivery locations of vaccines 1 and 4. However, vaccine 1 is already delivered and vaccine 4 has not been picked up, so no vaccination is finished.\n* Move 3. The robot delivers vaccine 3.\n* Move 4. The robot picks up vaccine 2, delivers vaccine 5 and picks up vaccine 4.\n\nNotice that vaccine 2 and 4 were picked up but not delivered because the delivery location of vaccine 2 was never reached, and the delivery location of vaccine 4 was not reached after the vaccine had been picked up.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of 4 lines. The first line of a test case contains 2 integers $\\mathbf{V}$ and $\\mathbf{M}$, the number of vaccinations and the number of move commands.\n\nThe second line of a test case contains $\\mathbf{V}$ integers $\\mathbf{P}_1, \\mathbf{P}_2, \\ldots, \\mathbf{P}_\\mathbf{V}$, representing that the $i$-th vaccine must be picked up exactly $\\mathbf{P}_i$ meters to the east of the robot's initial location. Note that several vaccines can have the same pickup location.\n\nThe third line contains $\\mathbf{V}$ integers $\\mathbf{D}_1, \\mathbf{D}_2, \\ldots, \\mathbf{D}_\\mathbf{V}$, representing that the $i$-th vaccine must be delivered exactly $\\mathbf{D}_i$ meters to the east of the robot's initial location. Note that several vaccines can have the same delivery location.\n\nThe final line of a test case contains $\\mathbf{M}$ integers $\\mathbf{X}_1, \\mathbf{X}_2, \\ldots, \\mathbf{X}_\\mathbf{M}$, where the absolute value of $\\mathbf{X}_j$ is the number of meters the robot must move for the $j$-th movement command. The $j$-th move must be towards the east if $\\mathbf{X}_j$ is positive, and towards the west if it is negative. Notice that the vaccinations can happen in an order different than the numbering of the input, but movement commands happen in the given order.", "outputFormat": "For each test case, output one line containing `case #x: y1 y2 ... yM`, where $x$ is the test case number (starting from 1) and $y_j$ is the number of vaccinations completed while performing the $j$-th given movement command.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one explained and illustrated in the problem statement.\n\nIn Sample Case #2 and Sample Case #3, notice that it is possible to pick up and deliver vaccines in the same move only if the pickup place is visited first. In addition, notice that it is possible pick up and to deliver exactly as a move is ending.\n\nSample Case #4, the robot moves $987654321$ meters to the west five times, then $987654321$ meters to the east four times, then $987654323$ meters to the east. The only pickup and delivery are both made in the final move. Note that the commands can be very extreme so the robot can be at some point very far away from its initial position, either west or east.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{P}_i \\leq 10^9$, for all $i$.\n- $1 \\leq \\mathbf{D}_i \\leq 10^9$, for all $i$.\n- $\\mathbf{P}_i \\neq \\mathbf{D}_i$, for all $i$.\n- $-10^9 \\leq \\mathbf{X}_j \\leq 10^9$, for all $j$.\n- $\\mathbf{X}_j \\neq 0$, for all $j$.\n\n**Test Set 1 (4 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $1 \\leq \\mathbf{V} \\leq 100$.\n- $1 \\leq \\mathbf{M} \\leq 100$.\n\n**Test Set 2 (9 Pts, Hidden Verdict)**\n\n- Time limit: 40 seconds.\n- $1 \\leq \\mathbf{V} \\leq 10^5$.\n- $1 \\leq \\mathbf{M} \\leq 10^5$.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #3] Immunization Operation", "background": null, "description": "为全球人口提供疫苗是一个涉及多方面的复杂问题。**Ñambi** 正致力于优化疫苗配送流程。为了尽可能降低接种门槛，她尝试使用自动化机器人直接将疫苗配送到患者家中并完成接种。\n\n在当前的方案中，**Ñambi** 设计的机器人将在一条东西走向的街道上工作。机器人接受单一指令“移动 $x$ 米”：若 $x$ 为正，则向东移动 $x$ 米；若 $x$ 为负，则向西移动 $x$ 米。\n\n机器人每天启动时会加载当天需完成的所有疫苗接种信息。每条信息包含疫苗的当前位置（用于取货）和患者位置（用于配送）。每支疫苗均为特定患者定制，且配送位置永远不会与取货位置相同。机器人必须在配送疫苗前先取货。\n\n机器人编程逻辑如下：\n- 首次经过疫苗取货位置时，自动取货并装载至货舱。\n- 若已取货的疫苗对应的患者位置被经过，则立即完成配送。\n**Ñambi** 需要统计每条移动指令后完成的疫苗接种次数。疫苗接种发生在疫苗被配送时。注意：疫苗可能在同一指令的移动过程中被取货（需在配送前完成取货）。\n\n下图展示了样例 #1 的场景：笑脸为机器人初始位置，黑线为街道。上方标记为取货位置，下方标记为配送位置，底部箭头按从上到下的顺序标注了每次移动完成的配送次数。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/05p9howp.png)\n\n各次移动的具体过程：\n1. **移动 1**：取货疫苗 5 和 1 → 配送疫苗 1 → 在移动结束时取货疫苗 3。注意：虽然经过疫苗 3 的配送位置，但因未取货，无法配送。\n2. **移动 2**：经过疫苗 1 和 4 的配送位置。疫苗 1 已配送，疫苗 4 未取货，故无配送。\n3. **移动 3**：配送疫苗 3。\n4. **移动 4**：取货疫苗 2 → 配送疫苗 5 → 取货疫苗 4。疫苗 2 和 4 未被配送（疫苗 2 的配送位置未到达，疫苗 4 的配送位置在取货前已通过）。", "inputFormat": "输入第一行包含测试用例数量 $\\mathbf{T}$。每个测试用例包含 4 行：\n1. 两个整数 $\\mathbf{V}$（疫苗接种数）和 $\\mathbf{M}$（移动指令数）。\n2. $\\mathbf{V}$ 个整数 $\\mathbf{P}_1, \\mathbf{P}_2, \\ldots, \\mathbf{P}_\\mathbf{V}$，表示第 $i$ 支疫苗的取货位置在初始位置以东 $\\mathbf{P}_i$ 米处（允许多支疫苗同一取货点）。\n3. $\\mathbf{V}$ 个整数 $\\mathbf{D}_1, \\mathbf{D}_2, \\ldots, \\mathbf{D}_\\mathbf{V}$，表示第 $i$ 支疫苗的配送位置在初始位置以东 $\\mathbf{D}_i$ 米处（允许多支疫苗同一配送点）。\n4. $\\mathbf{M}$ 个整数 $\\mathbf{X}_1, \\mathbf{X}_2, \\ldots, \\mathbf{X}_\\mathbf{M}$，第 $j$ 次移动的米数为 $|\\mathbf{X}_j|$，方向为东（$\\mathbf{X}_j > 0$）或西（$\\mathbf{X}_j < 0$）。疫苗接种顺序可能与输入编号不同，但移动指令按给定顺序执行。", "outputFormat": "对每个测试用例，输出一行 `Case #x: y1 y2 ... yM`，其中 $x$ 为测试用例编号（从 1 开始），$y_j$ 为第 $j$ 次移动完成的疫苗接种次数。", "hint": "**样例解释**\n- **样例 #1**：题目描述中的图示场景。\n- **样例 #2 和 #3**：若取货位置先于配送位置被访问，则同一移动中可完成取货和配送。移动结束时也可能完成操作。\n- **样例 #4**：机器人先向西移动 5 次（每次 987654321 米），再向东移动 4 次（每次 987654321 米），最后向东移动 987654323 米。唯一一次取货和配送均在最后一次移动中完成。移动指令的数值可能极大。\n\n**限制条件**\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{P}_i, \\mathbf{D}_i \\leq 10^9$，且 $\\mathbf{P}_i \\neq \\mathbf{D}_i$。\n- $\\mathbf{X}_j \\in [-10^9, 10^9]$ 且 $\\mathbf{X}_j \\neq 0$。\n\n**测试集 1（4 分，可见判定）**\n- 时间限制：20 秒。\n- $1 \\leq \\mathbf{V}, \\mathbf{M} \\leq 100$。\n\n**测试集 2（9 分，隐藏判定）**\n- 时间限制：40 秒。\n- $1 \\leq \\mathbf{V}, \\mathbf{M} \\leq 10^5$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12958", "type": "P", "difficulty": 4, "samples": [["2\n5 2\n3 3 6 2 2\n3 1 1 3\n7 3\n2 4 7 2 2 1 8\n6 1 7 3 1 3", "Case #1: 1\nCase #2: 7"]], "limits": {"time": [40000, 40000, 40000], "memory": [2097152, 2097152, 2097152]}, "tags": ["树状数组", "2023", "Google Code Jam"], "title": "[GCJ Farewell Round #3] Evolutionary Algorithms", "background": "", "description": "Ada is working on a science project for school. She is studying evolution and she would like to compare how different species of organisms would perform when trying to solve a coding competition problem.\n\nThe $\\mathbf{N}$ species are numbered with integers between 1 and $\\mathbf{N}$, inclusive. Species 1 has no direct ancestor, and all other species have exactly one direct ancestor each, from which they directly evolved. A (not necessarily direct) ancestor of species $x$ is any other species $y$ such that $y$ can be reached from $x$ by moving one or more times to a species direct ancestor starting from $x$. In this way, species 1 is a (direct or indirect) ancestor of every other species.\n\nThrough complex genetic simulations, she calculated the average score each of the $\\mathbf{N}$ species would get in a particular coding competition. $\\mathbf{S}_i$ is that average score for species $i$.\n\nAda is looking for interesting triplets to showcase in her presentation. An interesting triplet is defined as an ordered triplet of distinct species $(a, b, c)$ such that:\n\n1. Species $b$ is a (direct or indirect) ancestor of species $a$.\n2. Species $b$ is not a (direct or indirect) ancestor of species $c$.\n3. Species $b$ has an average score strictly more than $\\mathbf{K}$ times higher than both of those of $a$ and $c$. That is, $\\mathbf{S}_b \\geq \\mathbf{K} \\times \\max(\\mathbf{S}_a, \\mathbf{S}_c) + 1$.\n\nGiven the species scores and ancestry relationships, help Ada by writing a program to count the total number of interesting triplets.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow.\n\nThe first line of each test case contains two integers $\\mathbf{N}$ and $\\mathbf{K}$, denoting the number of species and the factor which determines interesting triplets, respectively.\n\nThe second line of each test case contains $\\mathbf{N}$ integers $\\mathbf{S}_1, \\mathbf{S}_2, \\ldots, \\mathbf{S}_\\mathbf{N}$, where $\\mathbf{S}_i$ denotes the average score of species $i$.\n\nThe third line of each test case contains $\\mathbf{N} - 1$ integers $\\mathbf{P}_2, \\mathbf{P}_3, \\ldots, \\mathbf{P}_\\mathbf{N}$, meaning species $\\mathbf{P}_i$ is the direct ancestor of species $i$.", "outputFormat": "For each test case, output one line containing `case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the total number of interesting triplets according to Ada's definition.", "hint": "**Sample Explanation**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4o5vn91i.png)\n\nIn Sample Case #1, there is only one possible interesting triplet: $(5, 3, 4)$. Indeed, we can verify that:\n\n1. Species $b = 3$ is an ancestor of species $a = 5$.\n2. Species $b = 3$ is not an ancestor of species $c = 4$.\n3. The score of species $b = 3$ is more than $\\mathbf{K}$ times higher than the scores of both $a = 5$ and $c = 4$: $6 = \\mathbf{S}_3 \\geq \\mathbf{K} \\times \\max(\\mathbf{S}_4, \\mathbf{S}_5) + 1 = 2 \\times \\max(2, 2) + 1 = 5$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vi8pvu68.png)\n\nIn Sample Case #2, there are seven interesting triplets:\n\n* $(4, 3, 1)$\n* $(4, 3, 6)$\n* $(4, 7, 1)$\n* $(4, 7, 5)$\n* $(4, 7, 6)$\n* $(5, 3, 1)$\n* $(5, 3, 6)$\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{K} \\leq 10^9$.\n- $1 \\leq \\mathbf{S}_i \\leq 10^9$, for all $i$.\n- $1 \\leq \\mathbf{P}_i \\leq \\mathbf{N}$, for all $i$.\n- Species 1 is a (direct or indirect) ancestor of all other species.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- $3 \\leq \\mathbf{N} \\leq 1000$.\n\n**Test Set 2 (16 Pts, Hidden Verdict)**\n\nFor at most 30 cases:\n\n- $3 \\leq \\mathbf{N} \\leq 2 \\times 10^5$.\n\nFor the remaining cases:\n\n- $3 \\leq \\mathbf{N} \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #3] Evolutionary Algorithms", "background": "", "description": "Ada is working on a science project for school. She is studying evolution and she would like to compare how different species of organisms would perform when trying to solve a coding competition problem.\n\nThe $\\mathbf{N}$ species are numbered with integers between 1 and $\\mathbf{N}$, inclusive. Species 1 has no direct ancestor, and all other species have exactly one direct ancestor each, from which they directly evolved. A (not necessarily direct) ancestor of species $x$ is any other species $y$ such that $y$ can be reached from $x$ by moving one or more times to a species direct ancestor starting from $x$. In this way, species 1 is a (direct or indirect) ancestor of every other species.\n\nThrough complex genetic simulations, she calculated the average score each of the $\\mathbf{N}$ species would get in a particular coding competition. $\\mathbf{S}_i$ is that average score for species $i$.\n\nAda is looking for interesting triplets to showcase in her presentation. An interesting triplet is defined as an ordered triplet of distinct species $(a, b, c)$ such that:\n\n1. Species $b$ is a (direct or indirect) ancestor of species $a$.\n2. Species $b$ is not a (direct or indirect) ancestor of species $c$.\n3. Species $b$ has an average score strictly more than $\\mathbf{K}$ times higher than both of those of $a$ and $c$. That is, $\\mathbf{S}_b \\geq \\mathbf{K} \\times \\max(\\mathbf{S}_a, \\mathbf{S}_c) + 1$.\n\nGiven the species scores and ancestry relationships, help Ada by writing a program to count the total number of interesting triplets.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow.\n\nThe first line of each test case contains two integers $\\mathbf{N}$ and $\\mathbf{K}$, denoting the number of species and the factor which determines interesting triplets, respectively.\n\nThe second line of each test case contains $\\mathbf{N}$ integers $\\mathbf{S}_1, \\mathbf{S}_2, \\ldots, \\mathbf{S}_\\mathbf{N}$, where $\\mathbf{S}_i$ denotes the average score of species $i$.\n\nThe third line of each test case contains $\\mathbf{N} - 1$ integers $\\mathbf{P}_2, \\mathbf{P}_3, \\ldots, \\mathbf{P}_\\mathbf{N}$, meaning species $\\mathbf{P}_i$ is the direct ancestor of species $i$.", "outputFormat": "For each test case, output one line containing `case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the total number of interesting triplets according to Ada's definition.", "hint": "**Sample Explanation**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4o5vn91i.png)\n\nIn Sample Case #1, there is only one possible interesting triplet: $(5, 3, 4)$. Indeed, we can verify that:\n\n1. Species $b = 3$ is an ancestor of species $a = 5$.\n2. Species $b = 3$ is not an ancestor of species $c = 4$.\n3. The score of species $b = 3$ is more than $\\mathbf{K}$ times higher than the scores of both $a = 5$ and $c = 4$: $6 = \\mathbf{S}_3 \\geq \\mathbf{K} \\times \\max(\\mathbf{S}_4, \\mathbf{S}_5) + 1 = 2 \\times \\max(2, 2) + 1 = 5$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vi8pvu68.png)\n\nIn Sample Case #2, there are seven interesting triplets:\n\n* $(4, 3, 1)$\n* $(4, 3, 6)$\n* $(4, 7, 1)$\n* $(4, 7, 5)$\n* $(4, 7, 6)$\n* $(5, 3, 1)$\n* $(5, 3, 6)$\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{K} \\leq 10^9$.\n- $1 \\leq \\mathbf{S}_i \\leq 10^9$, for all $i$.\n- $1 \\leq \\mathbf{P}_i \\leq \\mathbf{N}$, for all $i$.\n- Species 1 is a (direct or indirect) ancestor of all other species.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- $3 \\leq \\mathbf{N} \\leq 1000$.\n\n**Test Set 2 (16 Pts, Hidden Verdict)**\n\nFor at most 30 cases:\n\n- $3 \\leq \\mathbf{N} \\leq 2 \\times 10^5$.\n\nFor the remaining cases:\n\n- $3 \\leq \\mathbf{N} \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #3] Evolutionary Algorithms", "background": null, "description": "Ada 正在为学校的科学项目工作。她研究生物进化，并希望比较不同物种在解决编程竞赛问题时的表现。\n\n共有 $\\mathbf{N}$ 个物种，编号为 1 到 $\\mathbf{N}$。物种 1 没有直接祖先，其他每个物种都有且仅有一个直接祖先。物种 $x$ 的（直接或间接）祖先是指从 $x$ 出发，通过一次或多次向上追溯直接祖先能到达的任何其他物种 $y$。因此，物种 1 是所有其他物种的（直接或间接）祖先。\n\n通过复杂的遗传模拟，她计算了每个物种在特定编程竞赛中的平均得分 $\\mathbf{S}_i$（$i$ 为物种编号）。\n\nAda 希望在她的展示中呈现一些有趣的三元组。一个有趣的三元组定义为满足以下条件的有序三元组 $(a, b, c)$（$a, b, c$ 为不同物种）：\n\n1. 物种 $b$ 是物种 $a$ 的（直接或间接）祖先。\n2. 物种 $b$ **不是**物种 $c$ 的（直接或间接）祖先。\n3. 物种 $b$ 的平均得分严格大于 $\\mathbf{K}$ 倍 $\\max(\\mathbf{S}_a, \\mathbf{S}_c)$，即 $\\mathbf{S}_b \\geq \\mathbf{K} \\times \\max(\\mathbf{S}_a, \\mathbf{S}_c) + 1$。\n\n给定物种得分和祖先关系，编写程序计算所有满足条件的有趣三元组数量。", "inputFormat": "输入第一行包含测试用例数量 $\\mathbf{T}$。每个测试用例包含三行：\n1. 两个整数 $\\mathbf{N}$（物种数）和 $\\mathbf{K}$（判定系数）。\n2. $\\mathbf{N}$ 个整数 $\\mathbf{S}_1, \\mathbf{S}_2, \\ldots, \\mathbf{S}_\\mathbf{N}$，表示各物种的平均得分。\n3. $\\mathbf{N} - 1$ 个整数 $\\mathbf{P}_2, \\mathbf{P}_3, \\ldots, \\mathbf{P}_\\mathbf{N}$，表示物种 $i$ 的直接祖先为 $\\mathbf{P}_i$。", "outputFormat": "对每个测试用例，输出一行 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为有趣三元组的总数。", "hint": "**样例解释**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4o5vn91i.png)\n\n在样例 #1 中，唯一满足条件的三元组是 $(5, 3, 4)$。验证如下：\n1. 物种 3 是物种 5 的祖先。\n2. 物种 3 不是物种 4 的祖先。\n3. $\\mathbf{S}_3 = 6 \\geq 2 \\times \\max(2, 2) + 1 = 5$（设 $\\mathbf{K} = 2$）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vi8pvu68.png)\n\n在样例 #2 中，共有 7 个有趣三元组：\n- $(4, 3, 1)$\n- $(4, 3, 6)$\n- $(4, 7, 1)$\n- $(4, 7, 5)$\n- $(4, 7, 6)$\n- $(5, 3, 1)$\n- $(5, 3, 6)$\n\n**限制条件**\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{K} \\leq 10^9$。\n- $1 \\leq \\mathbf{S}_i \\leq 10^9$。\n- 物种 1 是所有其他物种的祖先。\n\n**测试集 1（7 分，可见判定）**\n- $3 \\leq \\mathbf{N} \\leq 1000$。\n\n**测试集 2（16 分，隐藏判定）**\n- 最多 30 个测试用例：$3 \\leq \\mathbf{N} \\leq 2 \\times 10^5$。\n- 其余测试用例：$3 \\leq \\mathbf{N} \\leq 1000$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12959", "type": "P", "difficulty": 4, "samples": [["2\n5 5 3\n1 2 1\n2 3 2\n2 4 1\n2 5 1\n4 5 1\n1 3\n3 4\n5 1\n3 1 2\n1 3 1\n1 2\n1 3", "Case #1: 1\nCase #2: 1"], ["1\n4 5 2\n1 2 3\n1 3 3\n3 4 7\n2 3 3\n2 4 6\n1 2\n1 4", "Case #1: 2"]], "limits": {"time": [20000, 20000, 40000, 120000], "memory": [2097152, 2097152, 2097152, 2097152]}, "tags": ["图论", "并查集", "2023", "Google Code Jam"], "title": "[GCJ Farewell Round #3] The Decades of Coding Competitions", "background": "", "description": "It has been almost 15 years since Sphinny became the premiere programming contestant by mastering the art of scheduling contests. She has grown alongside Coding Competitions and graduated into a programming contest organizer, and her Programming Club League (PCL) is the most popular sport in her city.\n\nThere are $\\mathbf{N}$ bus stops in Sphinny's city, and $\\mathbf{M}$ express bus routes. Each route bidirectionally connects two different bus stops, called their endpoints. Because of the popularity of PCL, the driver of each bus routes cheers for exactly one club.\n\nSphinny has to pick up the contest materials for the $j$-th contest at bus stop $\\mathbf{P}_j$ and then the contest will be run in bus stop $\\mathbf{C}_j$. She can only use the given bus routes to travel between them. Formally, a path for Sphinny to go from $\\mathbf{P}_j$ to $\\mathbf{C}_j$ is a list of bus routes such that each two consecutive routes have a common endpoint. Also the first route in the path has $\\mathbf{P}_j$ as an endpoint and the last one has $\\mathbf{C}_j$ as an endpoint. Notice that the same bus route can be used multiple times in a path. If Sphinny's path from $\\mathbf{P}_j$ to $\\mathbf{C}_j$ contains one or more bus routes whose driver cheers for club $c$, then club $c$ will join the contest. Otherwise, club $c$ will not join the contest. For organizational reasons, Sphinny needs the number of clubs in each contest to be an odd number.\n\nGiven the layout of Sphinny's city's bus routes and the contests' details, find out for how many contests there exists a path for Sphinny to take that can ensure an odd number of clubs joining it.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow.\n\nThe first line of each test case contains three integers $\\mathbf{N}$, $\\mathbf{M}$, and $\\mathbf{Q}$: the number of bus stops, bus routes, and contests, respectively.\n\nThen, $\\mathbf{M}$ lines follow representing a different bus route each. The $i$-th of these lines contains three integers $\\mathbf{U}_i$, $\\mathbf{V}_i$, and $\\mathbf{K}_i$, meaning that the $i$-th bus route connects bus stops $\\mathbf{U}_i$ and $\\mathbf{V}_i$ and its driver cheers for club $\\mathbf{K}_i$.\n\nFinally, the last $\\mathbf{Q}$ lines represent a contest each. The $j$-th of these lines contains two integers $\\mathbf{P}_j$ and $\\mathbf{C}_j$, representing that materials for the $j$-th contest need to be picked up at bus stop $\\mathbf{P}_j$ and the contest needs to be run at bus stop $\\mathbf{C}_j$.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of contests for which Sphinny can find a path that ensures an odd number of clubs join it.", "hint": "**Sample Explanation**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/axkzo8s5.png)\n\nSample Case #1 is pictured above. In the first two contests, both clubs (green and blue) must be involved in it no matter what path is chosen. For the last contest, it is possible to involve only the green club by using the path through bus stops $1, 2, 4, 5$.\n\nFor Sample Case #2, the first contest is not possible because there is no path to go from bus stop $1$ to bus stop $2$. For the second contest, there is a path including the only bus route going bus stop $1$ to bus stop $3$, therefore yielding a contest involving exactly $1$ club, which is an acceptable odd number of clubs.\n\nThe following additional sample fits the limits of Test Set 2. It will not be run against your submitted solutions.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ycyh0jsk.png)\n\nThis additional Sample Case is pictured above. In this case, both contests can be done with an odd number of clubs. An example path that achieves that is shown in the picture.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{U}_i \\leq \\mathbf{N}$, for all $i$.\n- $1 \\leq \\mathbf{V}_i \\leq \\mathbf{N}$, for all $i$.\n- $\\mathbf{U}_i \\neq \\mathbf{V}_i$, for all $i$\n- $(\\mathbf{U}_i, \\mathbf{V}_i) \\neq (\\mathbf{U}_j, \\mathbf{V}_j)$ and $(\\mathbf{U}_i, \\mathbf{V}_i) \\neq (\\mathbf{V}_j, \\mathbf{U}_j)$, for all $i \\neq j$. (No two bus routes have the same pair of endpoints.)\n- $1 \\leq \\mathbf{P}_j \\leq \\mathbf{N}$, for all $j$.\n- $1 \\leq \\mathbf{C}_j \\leq \\mathbf{N}$, for all $j$.\n- $\\mathbf{P}_j \\neq \\mathbf{C}_j$, for all $j$.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $2 \\leq \\mathbf{N} \\leq 500$.\n- $1 \\leq \\mathbf{M} \\leq 500$.\n- $1 \\leq \\mathbf{Q} \\leq 500$.\n- $1 \\leq \\mathbf{K}_j \\leq 2$, for all $j$.\n\n**Test Set 2 (6 Pts, Visible Verdict)**\n\n- Time limit: 40 seconds.\n- $2 \\leq \\mathbf{N} \\leq 500$.\n- $1 \\leq \\mathbf{M} \\leq 500$.\n- $1 \\leq \\mathbf{Q} \\leq 500$.\n- $1 \\leq \\mathbf{K}_j \\leq 100$, for all $j$.\n\n**Test Set 3 (10 Pts, Hidden Verdict)**\n\n- Time limit: 120 seconds.\n- $2 \\leq \\mathbf{N} \\leq 10000$.\n- $1 \\leq \\mathbf{M} \\leq 10000$.\n- $1 \\leq \\mathbf{Q} \\leq 10000$.\n- $1 \\leq \\mathbf{K}_j \\leq 100$, for all $j$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #3] The Decades of Coding Competitions", "background": "", "description": "It has been almost 15 years since Sphinny became the premiere programming contestant by mastering the art of scheduling contests. She has grown alongside Coding Competitions and graduated into a programming contest organizer, and her Programming Club League (PCL) is the most popular sport in her city.\n\nThere are $\\mathbf{N}$ bus stops in Sphinny's city, and $\\mathbf{M}$ express bus routes. Each route bidirectionally connects two different bus stops, called their endpoints. Because of the popularity of PCL, the driver of each bus routes cheers for exactly one club.\n\nSphinny has to pick up the contest materials for the $j$-th contest at bus stop $\\mathbf{P}_j$ and then the contest will be run in bus stop $\\mathbf{C}_j$. She can only use the given bus routes to travel between them. Formally, a path for Sphinny to go from $\\mathbf{P}_j$ to $\\mathbf{C}_j$ is a list of bus routes such that each two consecutive routes have a common endpoint. Also the first route in the path has $\\mathbf{P}_j$ as an endpoint and the last one has $\\mathbf{C}_j$ as an endpoint. Notice that the same bus route can be used multiple times in a path. If Sphinny's path from $\\mathbf{P}_j$ to $\\mathbf{C}_j$ contains one or more bus routes whose driver cheers for club $c$, then club $c$ will join the contest. Otherwise, club $c$ will not join the contest. For organizational reasons, Sphinny needs the number of clubs in each contest to be an odd number.\n\nGiven the layout of Sphinny's city's bus routes and the contests' details, find out for how many contests there exists a path for Sphinny to take that can ensure an odd number of clubs joining it.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow.\n\nThe first line of each test case contains three integers $\\mathbf{N}$, $\\mathbf{M}$, and $\\mathbf{Q}$: the number of bus stops, bus routes, and contests, respectively.\n\nThen, $\\mathbf{M}$ lines follow representing a different bus route each. The $i$-th of these lines contains three integers $\\mathbf{U}_i$, $\\mathbf{V}_i$, and $\\mathbf{K}_i$, meaning that the $i$-th bus route connects bus stops $\\mathbf{U}_i$ and $\\mathbf{V}_i$ and its driver cheers for club $\\mathbf{K}_i$.\n\nFinally, the last $\\mathbf{Q}$ lines represent a contest each. The $j$-th of these lines contains two integers $\\mathbf{P}_j$ and $\\mathbf{C}_j$, representing that materials for the $j$-th contest need to be picked up at bus stop $\\mathbf{P}_j$ and the contest needs to be run at bus stop $\\mathbf{C}_j$.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of contests for which Sphinny can find a path that ensures an odd number of clubs join it.", "hint": "**Sample Explanation**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/axkzo8s5.png)\n\nSample Case #1 is pictured above. In the first two contests, both clubs (green and blue) must be involved in it no matter what path is chosen. For the last contest, it is possible to involve only the green club by using the path through bus stops $1, 2, 4, 5$.\n\nFor Sample Case #2, the first contest is not possible because there is no path to go from bus stop $1$ to bus stop $2$. For the second contest, there is a path including the only bus route going bus stop $1$ to bus stop $3$, therefore yielding a contest involving exactly $1$ club, which is an acceptable odd number of clubs.\n\nThe following additional sample fits the limits of Test Set 2. It will not be run against your submitted solutions.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ycyh0jsk.png)\n\nThis additional Sample Case is pictured above. In this case, both contests can be done with an odd number of clubs. An example path that achieves that is shown in the picture.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{U}_i \\leq \\mathbf{N}$, for all $i$.\n- $1 \\leq \\mathbf{V}_i \\leq \\mathbf{N}$, for all $i$.\n- $\\mathbf{U}_i \\neq \\mathbf{V}_i$, for all $i$\n- $(\\mathbf{U}_i, \\mathbf{V}_i) \\neq (\\mathbf{U}_j, \\mathbf{V}_j)$ and $(\\mathbf{U}_i, \\mathbf{V}_i) \\neq (\\mathbf{V}_j, \\mathbf{U}_j)$, for all $i \\neq j$. (No two bus routes have the same pair of endpoints.)\n- $1 \\leq \\mathbf{P}_j \\leq \\mathbf{N}$, for all $j$.\n- $1 \\leq \\mathbf{C}_j \\leq \\mathbf{N}$, for all $j$.\n- $\\mathbf{P}_j \\neq \\mathbf{C}_j$, for all $j$.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $2 \\leq \\mathbf{N} \\leq 500$.\n- $1 \\leq \\mathbf{M} \\leq 500$.\n- $1 \\leq \\mathbf{Q} \\leq 500$.\n- $1 \\leq \\mathbf{K}_j \\leq 2$, for all $j$.\n\n**Test Set 2 (6 Pts, Visible Verdict)**\n\n- Time limit: 40 seconds.\n- $2 \\leq \\mathbf{N} \\leq 500$.\n- $1 \\leq \\mathbf{M} \\leq 500$.\n- $1 \\leq \\mathbf{Q} \\leq 500$.\n- $1 \\leq \\mathbf{K}_j \\leq 100$, for all $j$.\n\n**Test Set 3 (10 Pts, Hidden Verdict)**\n\n- Time limit: 120 seconds.\n- $2 \\leq \\mathbf{N} \\leq 10000$.\n- $1 \\leq \\mathbf{M} \\leq 10000$.\n- $1 \\leq \\mathbf{Q} \\leq 10000$.\n- $1 \\leq \\mathbf{K}_j \\leq 100$, for all $j$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #3] The Decades of Coding Competitions", "background": "", "description": "自 **Sphinny** 通过掌握竞赛排程的艺术成为顶尖编程选手以来，已经过去了近 15 年。她与 **Coding Competitions** 一同成长，并转型为一名编程竞赛组织者，而她创立的 **Programming Club League (PCL)** 已成为她所在城市最受欢迎的运动。\n\n**Sphinny** 的城市中有 $\\mathbf{N}$ 个公交站点和 $\\mathbf{M}$ 条快速公交线路。每条线路双向连接两个不同的公交站点（称为端点）。由于 **PCL** 的流行，每条公交线路的司机恰好为一个俱乐部加油。\n\n**Sphinny** 需要在第 $j$ 场比赛前从公交站点 $\\mathbf{P}_j$ 取比赛材料，然后在公交站点 $\\mathbf{C}_j$ 举办比赛。她只能使用给定的公交线路在两者之间通行。形式上，**Sphinny** 从 $\\mathbf{P}_j$ 到 $\\mathbf{C}_j$ 的路径是一个公交线路列表，其中每两条相邻线路有一个共同的端点，且第一条线路的端点为 $\\mathbf{P}_j$，最后一条线路的端点为 $\\mathbf{C}_j$。注意，同一条公交线路可以在路径中多次使用。如果 **Sphinny** 从 $\\mathbf{P}_j$ 到 $\\mathbf{C}_j$ 的路径中包含一条或多条司机为俱乐部 $c$ 加油的公交线路，则俱乐部 $c$ 会参加比赛；否则，俱乐部 $c$ 不会参加比赛。出于组织原因，**Sphinny** 需要每场比赛参加的俱乐部数量为奇数。\n\n给定 **Sphinny** 所在城市的公交线路布局和比赛详情，计算有多少场比赛存在一条路径，使得参加的俱乐部数量为奇数。", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。\n\n每个测试用例的第一行包含三个整数 $\\mathbf{N}$、$\\mathbf{M}$ 和 $\\mathbf{Q}$，分别表示公交站点的数量、公交线路的数量和比赛的数量。\n\n接下来是 $\\mathbf{M}$ 行，每行表示一条公交线路。第 $i$ 行包含三个整数 $\\mathbf{U}_i$、$\\mathbf{V}_i$ 和 $\\mathbf{K}_i$，表示第 $i$ 条公交线路连接公交站点 $\\mathbf{U}_i$ 和 $\\mathbf{V}_i$，且其司机为俱乐部 $\\mathbf{K}_i$ 加油。\n\n最后是 $\\mathbf{Q}$ 行，每行表示一场比赛。第 $j$ 行包含两个整数 $\\mathbf{P}_j$ 和 $\\mathbf{C}_j$，表示第 $j$ 场比赛的材料需要在公交站点 $\\mathbf{P}_j$ 取，并在公交站点 $\\mathbf{C}_j$ 举办比赛。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是满足条件的比赛数量。\n", "hint": "**样例解释**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/axkzo8s5.png)\n\n样例 #1 如上图所示。在前两场比赛中，无论选择哪条路径，两个俱乐部（绿色和蓝色）都必须参加。对于最后一场比赛，可以通过路径 $1, 2, 4, 5$ 仅让绿色俱乐部参加。\n\n对于样例 #2，第一场比赛无法进行，因为没有从公交站点 $1$ 到 $2$ 的路径。第二场比赛有一条路径包含从公交站点 $1$ 到 $3$ 的唯一公交线路，因此恰好有 $1$ 个俱乐部参加，这是一个可接受的奇数。\n\n以下附加样例（样例组 #2）符合测试集 2 的限制，但不会用于测试您的提交。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ycyh0jsk.png)\n\n此附加样例如上图所示。在这种情况下，两场比赛均可通过奇数个俱乐部完成。图中展示了一条满足条件的路径。\n\n**限制**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 对于所有 $i$，$1 \\leq \\mathbf{U}_i \\leq \\mathbf{N}$。\n- 对于所有 $i$，$1 \\leq \\mathbf{V}_i \\leq \\mathbf{N}$。\n- 对于所有 $i$，$\\mathbf{U}_i \\neq \\mathbf{V}_i$。\n- 对于所有 $i \\neq j$，$(\\mathbf{U}_i, \\mathbf{V}_i) \\neq (\\mathbf{U}_j, \\mathbf{V}_j)$ 且 $(\\mathbf{U}_i, \\mathbf{V}_i) \\neq (\\mathbf{V}_j, \\mathbf{U}_j)$。（没有两条公交线路具有相同的端点对。）\n- 对于所有 $j$，$1 \\leq \\mathbf{P}_j \\leq \\mathbf{N}$。\n- 对于所有 $j$，$1 \\leq \\mathbf{C}_j \\leq \\mathbf{N}$。\n- 对于所有 $j$，$\\mathbf{P}_j \\neq \\mathbf{C}_j$。\n\n**测试集 1（7 分，可见评测结果）**\n\n- 时间限制：20 秒。\n- $2 \\leq \\mathbf{N} \\leq 500$。\n- $1 \\leq \\mathbf{M} \\leq 500$。\n- $1 \\leq \\mathbf{Q} \\leq 500$。\n- 对于所有 $j$，$1 \\leq \\mathbf{K}_j \\leq 2$。\n\n**测试集 2（6 分，可见评测结果）**\n\n- 时间限制：40 秒。\n- $2 \\leq \\mathbf{N} \\leq 500$。\n- $1 \\leq \\mathbf{M} \\leq 500$。\n- $1 \\leq \\mathbf{Q} \\leq 500$。\n- 对于所有 $j$，$1 \\leq \\mathbf{K}_j \\leq 100$。\n\n**测试集 3（10 分，隐藏评测结果）**\n\n- 时间限制：120 秒。\n- $2 \\leq \\mathbf{N} \\leq 10000$。\n- $1 \\leq \\mathbf{M} \\leq 10000$。\n- $1 \\leq \\mathbf{Q} \\leq 10000$。\n- 对于所有 $j$，$1 \\leq \\mathbf{K}_j \\leq 100$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12960", "type": "P", "difficulty": 7, "samples": [["3\n3 CODEJAM\n2 ABABABABAAAA\n3 AABBCDEEFGHIJJKLMNOPQRRSTUVWXYZZ", "Case #1: POSSIBLE\nC O DEJAM\nCase #2: POSSIBLE\nABABABABA AAA\nCase #3: IMPOSSIBLE"]], "limits": {"time": [40000, 40000, 40000], "memory": [2097152, 2097152, 2097152]}, "tags": ["贪心", "2023", "Special Judge", "构造", "Google Code Jam"], "title": "[GCJ Farewell Round #3] Game Sort: Part 2", "background": "", "description": "Note: The main parts of the statements of the problems \"Game Sort: Part 1\" and \"Game Sort: Part 2\" are identical, except for the last paragraph. The problems can otherwise be solved independently.\n\nAmir and Badari are playing a sorting game. The game starts with a string $\\mathbf{S}$ and an integer $\\mathbf{P}$ being chosen by an impartial judge. Then, Amir has to split $\\mathbf{S}$ into exactly $\\mathbf{P}$ contiguous non-empty parts (substrings). For example, if $\\mathbf{S} = \\text{CODEJAM}$ was the chosen string and $\\mathbf{P} = 3$, Amir could split it up as $[\\text{COD}, \\text{EJA}, \\text{M}]$ or as $[\\text{CO}, \\text{D}, \\text{EJAM}]$, but not as $[\\text{COD}, \\text{EJAM}]$, $[\\text{COD}, \\text{JA}, \\text{M}]$, $[\\text{EJA}, \\text{COD}, \\text{M}]$, nor as $[\\text{CODE}, \\text{EJA}, \\text{M}]$.\n\nThen, Badari must rearrange the letters within each part to make the list of parts be sorted in non-decreasing lexicographical order. If she can, then she wins. Otherwise, Amir wins.\n\nGiven the initial string and number of parts, can you help Amir win the game by choosing his parts in a way Badari cannot win herself? If not, say that it is not possible.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow, each describing a single test case containing an integer $\\mathbf{P}$ and a string $\\mathbf{S}$, the number of parts and string to be partitioned, respectively.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either `POSSIBLE` if Amir can win the game, or `IMPOSSIBLE` if he cannot. If he can win the game, output a second line containing $t_1 t_2 \\ldots t_p$ where $t_i$ is the $i$-th part of the winning partition you found for Amir. If there are multiple solutions, you may output any one of them.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there is no way for Badari to rearrange $\\text{DEJAM}$ to be lexicographically after $\\text{O}$, so Amir guaranteed a win.\n\nIn Sample Case #2, $\\text{AAA}$ is guaranteed to be earlier than any rearrangement of a string containing more than 3 letters, so Amir also wins.\n\nIn Sample Case #3, all possible partitions result in a list of parts that is already sorted in lexicographical order, so Amir cannot possibly win.\n\n**Limits**\n\n$1 \\leq \\mathbf{T} \\leq 100$.\n\nEach character of $\\mathbf{S}$ is an English uppercase letter A through Z.\n\n**Test Set 1 (8 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{P} \\leq 3$.\n- $\\mathbf{P} \\leq \\text{the length of } \\mathbf{S} \\leq 100$.\n\n**Test Set 2 (20 Pts, Hidden Verdict)**\n\n- $2 \\leq \\mathbf{P} \\leq 100$.\n- $\\mathbf{P} \\leq \\text{the length of } \\mathbf{S} \\leq 10^5$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #3] Game Sort: Part 2", "background": "", "description": "Note: The main parts of the statements of the problems \"Game Sort: Part 1\" and \"Game Sort: Part 2\" are identical, except for the last paragraph. The problems can otherwise be solved independently.\n\nAmir and Badari are playing a sorting game. The game starts with a string $\\mathbf{S}$ and an integer $\\mathbf{P}$ being chosen by an impartial judge. Then, Amir has to split $\\mathbf{S}$ into exactly $\\mathbf{P}$ contiguous non-empty parts (substrings). For example, if $\\mathbf{S} = \\text{CODEJAM}$ was the chosen string and $\\mathbf{P} = 3$, Amir could split it up as $[\\text{COD}, \\text{EJA}, \\text{M}]$ or as $[\\text{CO}, \\text{D}, \\text{EJAM}]$, but not as $[\\text{COD}, \\text{EJAM}]$, $[\\text{COD}, \\text{JA}, \\text{M}]$, $[\\text{EJA}, \\text{COD}, \\text{M}]$, nor as $[\\text{CODE}, \\text{EJA}, \\text{M}]$.\n\nThen, Badari must rearrange the letters within each part to make the list of parts be sorted in non-decreasing lexicographical order. If she can, then she wins. Otherwise, Amir wins.\n\nGiven the initial string and number of parts, can you help Amir win the game by choosing his parts in a way Badari cannot win herself? If not, say that it is not possible.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow, each describing a single test case containing an integer $\\mathbf{P}$ and a string $\\mathbf{S}$, the number of parts and string to be partitioned, respectively.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either `POSSIBLE` if Amir can win the game, or `IMPOSSIBLE` if he cannot. If he can win the game, output a second line containing $t_1 t_2 \\ldots t_p$ where $t_i$ is the $i$-th part of the winning partition you found for Amir. If there are multiple solutions, you may output any one of them.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there is no way for Badari to rearrange $\\text{DEJAM}$ to be lexicographically after $\\text{O}$, so Amir guaranteed a win.\n\nIn Sample Case #2, $\\text{AAA}$ is guaranteed to be earlier than any rearrangement of a string containing more than 3 letters, so Amir also wins.\n\nIn Sample Case #3, all possible partitions result in a list of parts that is already sorted in lexicographical order, so Amir cannot possibly win.\n\n**Limits**\n\n$1 \\leq \\mathbf{T} \\leq 100$.\n\nEach character of $\\mathbf{S}$ is an English uppercase letter A through Z.\n\n**Test Set 1 (8 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{P} \\leq 3$.\n- $\\mathbf{P} \\leq \\text{the length of } \\mathbf{S} \\leq 100$.\n\n**Test Set 2 (20 Pts, Hidden Verdict)**\n\n- $2 \\leq \\mathbf{P} \\leq 100$.\n- $\\mathbf{P} \\leq \\text{the length of } \\mathbf{S} \\leq 10^5$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #3] Game Sort: Part 2", "background": "", "description": "注意：问题 **Game Sort: Part 1** 和 **Game Sort: Part 2** 的题目描述主要部分相同，仅最后一段不同。这两个问题可以独立解决。\n\n**Amir** 和 **Badari** 正在玩一个排序游戏。游戏开始时，一位公正的裁判会选择一个字符串 $\\mathbf{S}$ 和一个整数 $\\mathbf{P}$。然后，**Amir** 需要将 $\\mathbf{S}$ 分割成恰好 $\\mathbf{P}$ 个连续的非空部分（子字符串）。例如，如果选中的字符串是 $\\mathbf{S} = \\text{CODEJAM}$ 且 $\\mathbf{P} = 3$，**Amir** 可以将其分割为 $[\\text{COD}, \\text{EJA}, \\text{M}]$ 或 $[\\text{CO}, \\text{D}, \\text{EJAM}]$，但不能分割为 $[\\text{COD}, \\text{EJAM}]$、$[\\text{COD}, \\text{JA}, \\text{M}]$、$[\\text{EJA}, \\text{COD}, \\text{M}]$ 或 $[\\text{CODE}, \\text{EJA}, \\text{M}]$。\n\n接着，**Badari** 必须重新排列每个部分的字母，使得这些部分按字典序非递减顺序排列。如果她能成功，则她获胜；否则，**Amir** 获胜。\n\n给定初始字符串和分割数量，你能帮助 **Amir** 通过选择一种 **Badari** 无法获胜的分割方式来赢得游戏吗？如果不可能，请说明无法实现。", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 行，每行描述一个测试用例，包含一个整数 $\\mathbf{P}$ 和一个字符串 $\\mathbf{S}$，分别表示分割数量和待分割的字符串。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是 `POSSIBLE`（如果 **Amir** 可以赢得游戏）或 `IMPOSSIBLE`（如果他不能）。如果可以赢得游戏，则额外输出一行，包含 $t_1 t_2 \\ldots t_p$，其中 $t_i$ 是你为 **Amir** 找到的获胜分割的第 $i$ 部分。如果有多种解，可以输出其中任意一种。\n", "hint": "**样例解释**\n\n在样例 #1 中，**Badari** 无法将 $\\text{DEJAM}$ 重新排列为字典序大于 $\\text{O}$ 的字符串，因此 **Amir** 确保了胜利。\n\n在样例 #2 中，$\\text{AAA}$ 的字典序必然小于任何包含超过 3 个字母的字符串的重排结果，因此 **Amir** 也获胜。\n\n在样例 #3 中，所有可能的分割方式都会使得部分列表已经按字典序排列，因此 **Amir** 无法获胜。\n\n**限制**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $\\mathbf{S}$ 的每个字符均为大写字母 A 到 Z。\n\n**测试集 1（8 分，可见评测结果）**\n\n- $2 \\leq \\mathbf{P} \\leq 3$。\n- $\\mathbf{P} \\leq \\mathbf{S} \\text{ 的长度} \\leq 100$。\n\n**测试集 2（20 分，隐藏评测结果）**\n\n- $2 \\leq \\mathbf{P} \\leq 100$。\n- $\\mathbf{P} \\leq \\mathbf{S} \\text{ 的长度} \\leq 10^5$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12961", "type": "P", "difficulty": 5, "samples": [["3\n2 3 2\n2\n3 3\n1 1\n2 3\n3 4 2\n2 3\n3 3 4\n1 3\n1 2\n3 4 1\n2 3\n3 3 4\n2 2", "Case #1: 2.0 1.8\nCase #2: 2.19047619 2.47619048\nCase #3: 2.2857142857"]], "limits": {"time": [20000, 20000, 40000], "memory": [2097152, 2097152, 2097152]}, "tags": ["2023", "Special Judge", "树形 DP", "Google Code Jam"], "title": "[GCJ Farewell Round #4] Indispensable Overpass", "background": "", "description": "A modern railroad system built in Ekiya's town bumped into a major hurdle: the main freeway running north to south. $\\mathbf{W}$ stations have already been built and connected on the western side of the freeway and $\\mathbf{E}$ on the eastern side. One more connection is needed between a western and an eastern station, but because the freeway is in the way, that connection needs to be built using an overpass.\n\nEkiya is assessing which stations would be most convenient to connect with the overpass. As part of that assessment, she wants to know how the average length (in number of stations) of a path within the system might change with each possible option.\n\nA path between stations $s$ and $t$ is a list of distinct stations that starts with $s$, ends with $t$, and such that any two consecutive stations on the list share a connection. The railroad system currently has $\\mathbf{W}$ stations on the western side, connected through $\\mathbf{W}-1$ connections such that there is exactly one path between any two distinct western stations. Similarly, there are $\\mathbf{E}$ eastern stations connected through $\\mathbf{E}-1$ connections such that there is exactly one path between any two distinct eastern stations. After the overpass connection is built connecting one western and one eastern station, there will be exactly one path between any two distinct stations.\n\nA complete map is a map that has $\\mathbf{W}+\\mathbf{E}-1$ total connections and exactly one path between any pair of stations. The average distance of a complete map is the average of the length of paths between all pairs of different stations. The length of a path is one less than the length of the list of stations that defines it (e.g., the path between directly connected stations has a length of 1).\n\nAs an example, the picture below illustrates a scenario with $\\mathbf{W}=2$ stations on the west side and $\\mathbf{E}=3$ stations on the east side. There are 2 possible overpasses shown.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7o2t0xms.png)\n\nThis table shows the lengths of the paths between pairs of stations if each overpass were to be built.\n\n| West 1 | West 2 | 1 ↔ 1 | 2 ↔ 3 |\n| :---: | :---: | :---: | :---: |\n| West 1 | East 1 | 1 | 3 |\n| West 1 | East 2 | 3 | 3 |\n| West 1 | East 3 | 2 | 2 |\n| West 2 | East 1 | 2 | 2 |\n| West 2 | East 2 | 4 | 2 |\n| West 2 | East 3 | 3 | 1 |\n| East 1 | East 2 | 2 | 2 |\n| East 1 | East 3 | 1 | 1 |\n| East 2 | East 3 | 1 | 1 |\n|  | Average: | 2 | 1.8 |\n\nGiven the current stations and connections, and a list of options for the overpass connection, help Ekiya by calculating the average distance of the map that would result if that option was the only overpass connection built.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line with three integers $\\mathbf{W}$, $\\mathbf{E}$, and $\\mathbf{C}$, the number of western and eastern stations, and the number of options for the overpass connection, respectively. Western stations are numbered between $1$ and $\\mathbf{W}$ and eastern connections are numbered between $1$ and $\\mathbf{E}$.\n\nThe second line of a test case contains $\\mathbf{W}-1$ integers $\\mathbf{X}_1$, $\\mathbf{X}_2$, $\\ldots$, $\\mathbf{X}_{\\mathbf{W}-1}$ representing that the $i$-th existing connection among western stations connects western stations $i$ and $\\mathbf{X}_i$.\n\nThe third line of a test case contains $\\mathbf{E}-1$ integers $\\mathbf{F}_1$, $\\mathbf{F}_2$, $\\ldots$, $\\mathbf{F}_{\\mathbf{E}-1}$ representing that the $j$-th existing connection among eastern stations connects eastern stations $j$ and $\\mathbf{F}_j$.\n\nFinally, the last $\\mathbf{C}$ lines of a test case describe the options for the overpass connection. The $k$-th of these lines contains two integers $\\mathbf{A}_k$ and $\\mathbf{B}_k$ representing the western and eastern stations, respectively, that the $k$-th option for an overpass connection would connect.", "outputFormat": "For each test case, output one line containing `Case #x:` $y_1$ $y_2$ $\\cdots$ $y_{\\mathbf{C}}$, where $x$ is the test case number (starting from $1$) and $y_k$ is the average distance of the map resulting in adding the $k$-th option as an overpass connection to all existing connections.\n\n$y_1$, $y_2$, $\\ldots$ and $y_k$ will be considered correct if they are within an absolute or relative error of $10^{-6}$ of the correct answer. See the FAQ for an explanation of what that means, and what formats of real numbers we accept.", "hint": "**Sample Explanation**\n\nSample Case #1 is explained and illustrated in the problem statement. Sample Case #2 and Sample Case #3 are illustrated below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5w12npwf.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{W} \\leq 10^{5}$.\n- $2 \\leq \\mathbf{E} \\leq 10^{5}$.\n- $i+1 \\leq \\mathbf{X}_{i} \\leq \\mathbf{W}$, for all $i$. (This implies that there is exactly one path between each pair of western stations.)\n- $j+1 \\leq \\mathbf{F}_{j} \\leq \\mathbf{E}$, for all $j$. (This implies that there is exactly one path between each pair of eastern stations.)\n- $1 \\leq \\mathbf{A}_{k} \\leq \\mathbf{W}$, for all $k$.\n- $1 \\leq \\mathbf{B}_{k} \\leq \\mathbf{E}$, for all $k$.\n- $(\\mathbf{A}_{k}, \\mathbf{B}_{k}) \\neq (\\mathbf{A}_{\\ell}, \\mathbf{B}_{\\ell})$, for all $k \\neq \\ell$. (Each listed overpass connection is different.)\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $1 \\leq \\mathbf{C} \\leq 2$.\n\n**Test Set 2 (7 Pts, Hidden Verdict)**\n\n- Time limit: 40 seconds.\n- $1 \\leq \\mathbf{C} \\leq 10^{5}$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #4] Indispensable Overpass", "background": "", "description": "A modern railroad system built in Ekiya's town bumped into a major hurdle: the main freeway running north to south. $\\mathbf{W}$ stations have already been built and connected on the western side of the freeway and $\\mathbf{E}$ on the eastern side. One more connection is needed between a western and an eastern station, but because the freeway is in the way, that connection needs to be built using an overpass.\n\nEkiya is assessing which stations would be most convenient to connect with the overpass. As part of that assessment, she wants to know how the average length (in number of stations) of a path within the system might change with each possible option.\n\nA path between stations $s$ and $t$ is a list of distinct stations that starts with $s$, ends with $t$, and such that any two consecutive stations on the list share a connection. The railroad system currently has $\\mathbf{W}$ stations on the western side, connected through $\\mathbf{W}-1$ connections such that there is exactly one path between any two distinct western stations. Similarly, there are $\\mathbf{E}$ eastern stations connected through $\\mathbf{E}-1$ connections such that there is exactly one path between any two distinct eastern stations. After the overpass connection is built connecting one western and one eastern station, there will be exactly one path between any two distinct stations.\n\nA complete map is a map that has $\\mathbf{W}+\\mathbf{E}-1$ total connections and exactly one path between any pair of stations. The average distance of a complete map is the average of the length of paths between all pairs of different stations. The length of a path is one less than the length of the list of stations that defines it (e.g., the path between directly connected stations has a length of 1).\n\nAs an example, the picture below illustrates a scenario with $\\mathbf{W}=2$ stations on the west side and $\\mathbf{E}=3$ stations on the east side. There are 2 possible overpasses shown.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7o2t0xms.png)\n\nThis table shows the lengths of the paths between pairs of stations if each overpass were to be built.\n\n| West 1 | West 2 | 1 ↔ 1 | 2 ↔ 3 |\n| :---: | :---: | :---: | :---: |\n| West 1 | East 1 | 1 | 3 |\n| West 1 | East 2 | 3 | 3 |\n| West 1 | East 3 | 2 | 2 |\n| West 2 | East 1 | 2 | 2 |\n| West 2 | East 2 | 4 | 2 |\n| West 2 | East 3 | 3 | 1 |\n| East 1 | East 2 | 2 | 2 |\n| East 1 | East 3 | 1 | 1 |\n| East 2 | East 3 | 1 | 1 |\n|  | Average: | 2 | 1.8 |\n\nGiven the current stations and connections, and a list of options for the overpass connection, help Ekiya by calculating the average distance of the map that would result if that option was the only overpass connection built.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line with three integers $\\mathbf{W}$, $\\mathbf{E}$, and $\\mathbf{C}$, the number of western and eastern stations, and the number of options for the overpass connection, respectively. Western stations are numbered between $1$ and $\\mathbf{W}$ and eastern connections are numbered between $1$ and $\\mathbf{E}$.\n\nThe second line of a test case contains $\\mathbf{W}-1$ integers $\\mathbf{X}_1$, $\\mathbf{X}_2$, $\\ldots$, $\\mathbf{X}_{\\mathbf{W}-1}$ representing that the $i$-th existing connection among western stations connects western stations $i$ and $\\mathbf{X}_i$.\n\nThe third line of a test case contains $\\mathbf{E}-1$ integers $\\mathbf{F}_1$, $\\mathbf{F}_2$, $\\ldots$, $\\mathbf{F}_{\\mathbf{E}-1}$ representing that the $j$-th existing connection among eastern stations connects eastern stations $j$ and $\\mathbf{F}_j$.\n\nFinally, the last $\\mathbf{C}$ lines of a test case describe the options for the overpass connection. The $k$-th of these lines contains two integers $\\mathbf{A}_k$ and $\\mathbf{B}_k$ representing the western and eastern stations, respectively, that the $k$-th option for an overpass connection would connect.", "outputFormat": "For each test case, output one line containing `Case #x:` $y_1$ $y_2$ $\\cdots$ $y_{\\mathbf{C}}$, where $x$ is the test case number (starting from $1$) and $y_k$ is the average distance of the map resulting in adding the $k$-th option as an overpass connection to all existing connections.\n\n$y_1$, $y_2$, $\\ldots$ and $y_k$ will be considered correct if they are within an absolute or relative error of $10^{-6}$ of the correct answer. See the FAQ for an explanation of what that means, and what formats of real numbers we accept.", "hint": "**Sample Explanation**\n\nSample Case #1 is explained and illustrated in the problem statement. Sample Case #2 and Sample Case #3 are illustrated below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5w12npwf.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{W} \\leq 10^{5}$.\n- $2 \\leq \\mathbf{E} \\leq 10^{5}$.\n- $i+1 \\leq \\mathbf{X}_{i} \\leq \\mathbf{W}$, for all $i$. (This implies that there is exactly one path between each pair of western stations.)\n- $j+1 \\leq \\mathbf{F}_{j} \\leq \\mathbf{E}$, for all $j$. (This implies that there is exactly one path between each pair of eastern stations.)\n- $1 \\leq \\mathbf{A}_{k} \\leq \\mathbf{W}$, for all $k$.\n- $1 \\leq \\mathbf{B}_{k} \\leq \\mathbf{E}$, for all $k$.\n- $(\\mathbf{A}_{k}, \\mathbf{B}_{k}) \\neq (\\mathbf{A}_{\\ell}, \\mathbf{B}_{\\ell})$, for all $k \\neq \\ell$. (Each listed overpass connection is different.)\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $1 \\leq \\mathbf{C} \\leq 2$.\n\n**Test Set 2 (7 Pts, Hidden Verdict)**\n\n- Time limit: 40 seconds.\n- $1 \\leq \\mathbf{C} \\leq 10^{5}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #4] Indispensable Overpass", "background": null, "description": "Ekiya 所在城镇新建的现代铁路系统遇到了一个主要障碍：一条贯穿南北的高速公路。高速公路西侧已经建造并连接了 $\\mathbf{W}$ 个车站，东侧则有 $\\mathbf{E}$ 个车站。现在需要在西侧和东侧车站之间再建立一条连接，但由于高速公路的阻隔，这条连接必须通过一座立交桥来实现。\n\nEkiya 正在评估哪些车站组合最适合通过立交桥连接。作为评估的一部分，她想知道系统内路径的平均长度（以车站数量计）会如何随每种可能的连接方案而变化。\n\n车站 $s$ 和 $t$ 之间的路径是指一个由不同车站组成的列表，该列表以 $s$ 开头、以 $t$ 结尾，且列表中任意两个连续车站之间存在连接。当前铁路系统中，西侧的 $\\mathbf{W}$ 个车站通过 $\\mathbf{W}-1$ 条连接构成，使得任意两个不同的西侧车站之间恰好存在一条路径。类似地，东侧的 $\\mathbf{E}$ 个车站通过 $\\mathbf{E}-1$ 条连接构成，使得任意两个不同的东侧车站之间也恰好存在一条路径。在建立连接一个西侧车站和一个东侧车站的立交桥后，任意两个不同车站之间将恰好存在一条路径。\n\n一个完整地图是指具有 $\\mathbf{W}+\\mathbf{E}-1$ 条总连接，且任意两个车站之间恰好存在一条路径的地图。完整地图的平均距离是指所有不同车站对之间路径长度的平均值。路径长度是指定义该路径的车站列表长度减 1（例如，直接连接的两个车站之间的路径长度为 1）。\n\n举例说明，下图展示了 $\\mathbf{W}=2$ 个西侧车站和 $\\mathbf{E}=3$ 个东侧车站的场景，图中显示了 2 种可能的立交桥方案。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7o2t0xms.png)\n\n下表展示了每种立交桥方案下各车站对之间的路径长度。\n\n| 起点 | 终点 | 1 ↔ 1 | 2 ↔ 3 |\n| :---: | :---: | :---: | :---: |\n| 西 1 | 西 2 | 1 | 1 |\n| 西 1 | 东 1 | 1 | 3 |\n| 西 1 | 东 2 | 3 | 3 |\n| 西 1 | 东 3 | 2 | 2 |\n| 西 2 | 东 1 | 2 | 2 |\n| 西 2 | 东 2 | 4 | 2 |\n| 西 2 | 东 3 | 3 | 1 |\n| 东 1 | 东 2 | 2 | 2 |\n| 东 1 | 东 3 | 1 | 1 |\n| 东 2 | 东 3 | 1 | 1 |\n|  | 平均值： | 2 | 1.8 |\n\n给定当前的车站和连接情况，以及立交桥连接方案的列表，请帮助 Ekiya 计算每种方案作为唯一立交桥连接时，所形成地图的平均距离。", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含三个整数 $\\mathbf{W}$、$\\mathbf{E}$ 和 $\\mathbf{C}$，分别表示西侧和东侧车站的数量，以及立交桥连接方案的数量。西侧车站编号为 $1$ 到 $\\mathbf{W}$，东侧车站编号为 $1$ 到 $\\mathbf{E}$。\n\n测试用例的第二行包含 $\\mathbf{W}-1$ 个整数 $\\mathbf{X}_1, \\mathbf{X}_2, \\ldots, \\mathbf{X}_{\\mathbf{W}-1}$，表示西侧车站的第 $i$ 条现有连接连接了西侧车站 $i$ 和 $\\mathbf{X}_i$。\n\n测试用例的第三行包含 $\\mathbf{E}-1$ 个整数 $\\mathbf{F}_1, \\mathbf{F}_2, \\ldots, \\mathbf{F}_{\\mathbf{E}-1}$，表示东侧车站的第 $j$ 条现有连接连接了东侧车站 $j$ 和 $\\mathbf{F}_j$。\n\n最后，测试用例的最后 $\\mathbf{C}$ 行描述了立交桥连接方案。其中第 $k$ 行包含两个整数 $\\mathbf{A}_k$ 和 $\\mathbf{B}_k$，表示第 $k$ 种立交桥方案将连接的西侧和东侧车站。", "outputFormat": "对于每个测试用例，输出一行 `Case #x:` $y_1$ $y_2$ $\\cdots$ $y_{\\mathbf{C}}$，其中 $x$ 是测试用例编号（从 $1$ 开始），$y_k$ 表示添加第 $k$ 种立交桥方案后所形成地图的平均距离。\n\n$y_1$, $y_2$, $\\ldots$, $y_k$ 只要与正确答案的绝对误差或相对误差不超过 $10^{-6}$ 即视为正确。有关误差说明及可接受的实数格式，请参阅 FAQ。", "hint": "**样例解释**\n\n样例 #1 已在题目描述中解释并图示。样例 #2 和样例 #3 图示如下。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5w12npwf.png)\n\n**限制**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $2 \\leq \\mathbf{W} \\leq 10^{5}$。\n- $2 \\leq \\mathbf{E} \\leq 10^{5}$。\n- 对所有 $i$，$i+1 \\leq \\mathbf{X}_{i} \\leq \\mathbf{W}$。（这意味着任意两个西侧车站之间恰好存在一条路径。）\n- 对所有 $j$，$j+1 \\leq \\mathbf{F}_{j} \\leq \\mathbf{E}$。（这意味着任意两个东侧车站之间恰好存在一条路径。）\n- 对所有 $k$，$1 \\leq \\mathbf{A}_{k} \\leq \\mathbf{W}$。\n- 对所有 $k$，$1 \\leq \\mathbf{B}_{k} \\leq \\mathbf{E}$。\n- 对所有 $k \\neq \\ell$，$(\\mathbf{A}_{k}, \\mathbf{B}_{k}) \\neq (\\mathbf{A}_{\\ell}, \\mathbf{B}_{\\ell})$。（列出的每种立交桥连接方案均不相同。）\n\n**测试集 1（5 分，可见评测结果）**\n\n- 时间限制：20 秒。\n- $1 \\leq \\mathbf{C} \\leq 2$。\n\n**测试集 2（7 分，隐藏评测结果）**\n\n- 时间限制：40 秒。\n- $1 \\leq \\mathbf{C} \\leq 10^{5}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12962", "type": "P", "difficulty": 6, "samples": [["3\nABCABAC CABABA 3\n3 6\n7 6\n6 5\nBANANA HABANA 2\n5 4\n5 5\nABC ABD 1\n2 1", "Case #1: 1 4 3\nCase #2: 4 1\nCase #3: 0"]], "limits": {"time": [20000, 20000, 20000], "memory": [2097152, 2097152, 2097152]}, "tags": ["2023", "后缀自动机 SAM", "ST 表", "后缀数组 SA", "Google Code Jam"], "title": "[GCJ Farewell Round #4] Genetic Sequences", "background": "", "description": "Margaret researches genetic sequences. She is analysing two sequences $\\mathbf{A}$ and $\\mathbf{B}$ from a new kind of life that does not use the typical four letter genetic alphabet. The code for the genetic sequences conveniently requires 26 letters represented by the uppercase English letters 'A' through 'Z'.\n\nMargaret wants to compare the sequences $\\mathbf{A}$ and $\\mathbf{B}$. The best way to do this is to do a series of sequence analysis tests. Each test involves taking a prefix from $\\mathbf{A}$ containing only the first $\\mathbf{P}$ letters from $\\mathbf{A}$, which is called the $\\mathbf{A}$-prefix. Each test also involves taking a suffix from $\\mathbf{B}$ containing only the last $\\mathbf{S}$ letters from $\\mathbf{B}$, which is called the $\\mathbf{B}$-suffix. Margaret then needs to compare the $\\mathbf{A}$-prefix to the $\\mathbf{B}$-suffix. A substring is a subsequence of contiguous letters. A substring from the $\\mathbf{A}$-prefix matches the $\\mathbf{B}$-suffix if the $\\mathbf{B}$-suffix starts with that substring. That is, the substring is a prefix of the $\\mathbf{B}$-suffix. The result of a test is the length of the longest substring from the $\\mathbf{A}$-prefix that matches the $\\mathbf{B}$-suffix.\n\nMargaret needs some software to determine the outcome of a batch of $\\mathbf{Q}$ sequence analysis tests. Note that each test is independent. Margaret has many copies of $\\mathbf{A}$ and $\\mathbf{B}$ and a new one is used for each test.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case begins with a line containing two strings and an integer, $\\mathbf{A}$, $\\mathbf{B}$, and $\\mathbf{Q}$ respectively. Each test case ends with $\\mathbf{Q}$ lines, the $i$-th of which contains two integers $\\mathbf{P}_i$ and $\\mathbf{S}_i$, which are the prefix and suffix sizes for the $i$-th sequence analysis test.\n", "outputFormat": "For each test case, output one line containing Case #$x$: $y_1$ $y_2$ $\\ldots$ $y_{\\mathbf{Q}}$, where $x$ is the test case number (starting from 1) and $y_i$ is the answer to the $i$-th query in the input.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are 3 tests. The prefix $\\mathbf{A B C}$ from $\\mathbf{A}$ and the complete suffix $\\mathbf{C A B A B A}$ from $\\mathbf{B}$ are compared in the first test. The answer is 1, since $\\mathbf{c}$ is the longest substring that is contained in $\\mathbf{A B C}$ and is a prefix of $\\mathbf{C A B A B A}$. In the second test, $\\mathbf{A B C A B A C}$ is tested against $\\mathbf{C A B A B A}$ and the longest match is $\\mathbf{C A B A}$. In the third test, $\\mathbf{A B C A B A}$ is tested against $\\mathbf{A B A B A}$ and the longest match is $\\mathbf{A B A}$.\n\nIn Sample Case #2, there are 2 tests. In the first, $\\mathbf{B A N A N}$ is tested against $\\mathbf{B A N A}$, and the longest match is $\\mathbf{B A N A}$. In the second, $\\mathbf{B A N A N}$ is tested against $\\mathbf{A B A N A}$, and the longest match is $\\mathbf{A}$.\n\nIn Sample Case #3, there is one test. In it, $\\mathbf{A B}$ is tested against $\\mathbf{d}$. Since there is no match the answer is 0.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{P}_{i} \\leq$ the length of $\\mathbf{A}$.\n- $1 \\leq \\mathbf{S}_{i} \\leq$ the length of $\\mathbf{B}$.\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{A} \\leq 3000$.\n- $1 \\leq$ the length of $\\mathbf{B} \\leq 3000$.\n- $1 \\leq \\mathbf{Q} \\leq 3000$.\n\n**Test Set 2 (17 Pts, Hidden Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{A} \\leq 10^{5}$.\n- $1 \\leq$ the length of $\\mathbf{B} \\leq 10^{5}$.\n- The sum of the lengths of $\\mathbf{A}$ over all test cases is $\\leq 5 \\times 10^{5}$\n- The sum of the lengths of $\\mathbf{B}$ over all test cases is $\\leq 5 \\times 10^{5}$\n- $1 \\leq \\mathbf{Q} \\leq 10^{5}$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #4] Genetic Sequences", "background": "", "description": "Margaret researches genetic sequences. She is analysing two sequences $\\mathbf{A}$ and $\\mathbf{B}$ from a new kind of life that does not use the typical four letter genetic alphabet. The code for the genetic sequences conveniently requires 26 letters represented by the uppercase English letters 'A' through 'Z'.\n\nMargaret wants to compare the sequences $\\mathbf{A}$ and $\\mathbf{B}$. The best way to do this is to do a series of sequence analysis tests. Each test involves taking a prefix from $\\mathbf{A}$ containing only the first $\\mathbf{P}$ letters from $\\mathbf{A}$, which is called the $\\mathbf{A}$-prefix. Each test also involves taking a suffix from $\\mathbf{B}$ containing only the last $\\mathbf{S}$ letters from $\\mathbf{B}$, which is called the $\\mathbf{B}$-suffix. Margaret then needs to compare the $\\mathbf{A}$-prefix to the $\\mathbf{B}$-suffix. A substring is a subsequence of contiguous letters. A substring from the $\\mathbf{A}$-prefix matches the $\\mathbf{B}$-suffix if the $\\mathbf{B}$-suffix starts with that substring. That is, the substring is a prefix of the $\\mathbf{B}$-suffix. The result of a test is the length of the longest substring from the $\\mathbf{A}$-prefix that matches the $\\mathbf{B}$-suffix.\n\nMargaret needs some software to determine the outcome of a batch of $\\mathbf{Q}$ sequence analysis tests. Note that each test is independent. Margaret has many copies of $\\mathbf{A}$ and $\\mathbf{B}$ and a new one is used for each test.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case begins with a line containing two strings and an integer, $\\mathbf{A}$, $\\mathbf{B}$, and $\\mathbf{Q}$ respectively. Each test case ends with $\\mathbf{Q}$ lines, the $i$-th of which contains two integers $\\mathbf{P}_i$ and $\\mathbf{S}_i$, which are the prefix and suffix sizes for the $i$-th sequence analysis test.\n", "outputFormat": "For each test case, output one line containing Case #$x$: $y_1$ $y_2$ $\\ldots$ $y_{\\mathbf{Q}}$, where $x$ is the test case number (starting from 1) and $y_i$ is the answer to the $i$-th query in the input.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are 3 tests. The prefix $\\mathbf{A B C}$ from $\\mathbf{A}$ and the complete suffix $\\mathbf{C A B A B A}$ from $\\mathbf{B}$ are compared in the first test. The answer is 1, since $\\mathbf{c}$ is the longest substring that is contained in $\\mathbf{A B C}$ and is a prefix of $\\mathbf{C A B A B A}$. In the second test, $\\mathbf{A B C A B A C}$ is tested against $\\mathbf{C A B A B A}$ and the longest match is $\\mathbf{C A B A}$. In the third test, $\\mathbf{A B C A B A}$ is tested against $\\mathbf{A B A B A}$ and the longest match is $\\mathbf{A B A}$.\n\nIn Sample Case #2, there are 2 tests. In the first, $\\mathbf{B A N A N}$ is tested against $\\mathbf{B A N A}$, and the longest match is $\\mathbf{B A N A}$. In the second, $\\mathbf{B A N A N}$ is tested against $\\mathbf{A B A N A}$, and the longest match is $\\mathbf{A}$.\n\nIn Sample Case #3, there is one test. In it, $\\mathbf{A B}$ is tested against $\\mathbf{d}$. Since there is no match the answer is 0.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{P}_{i} \\leq$ the length of $\\mathbf{A}$.\n- $1 \\leq \\mathbf{S}_{i} \\leq$ the length of $\\mathbf{B}$.\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{A} \\leq 3000$.\n- $1 \\leq$ the length of $\\mathbf{B} \\leq 3000$.\n- $1 \\leq \\mathbf{Q} \\leq 3000$.\n\n**Test Set 2 (17 Pts, Hidden Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{A} \\leq 10^{5}$.\n- $1 \\leq$ the length of $\\mathbf{B} \\leq 10^{5}$.\n- The sum of the lengths of $\\mathbf{A}$ over all test cases is $\\leq 5 \\times 10^{5}$\n- The sum of the lengths of $\\mathbf{B}$ over all test cases is $\\leq 5 \\times 10^{5}$\n- $1 \\leq \\mathbf{Q} \\leq 10^{5}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #4] Genetic Sequences", "background": "", "description": "Margaret 正在研究基因序列。她正在分析一种新型生命体的两个序列 $\\mathbf{A}$ 和 $\\mathbf{B}$，这种生命体不使用典型的四字母遗传密码。基因序列的编码方便地使用了 26 个大写英文字母 'A' 到 'Z' 来表示。\n\nMargaret 想要比较序列 $\\mathbf{A}$ 和 $\\mathbf{B}$。最佳方法是进行一系列序列分析测试。每个测试需要从 $\\mathbf{A}$ 中取出一个前缀（称为 $\\mathbf{A}$-前缀），包含 $\\mathbf{A}$ 的前 $\\mathbf{P}$ 个字母；同时从 $\\mathbf{B}$ 中取出一个后缀（称为 $\\mathbf{B}$-后缀），包含 $\\mathbf{B}$ 的最后 $\\mathbf{S}$ 个字母。然后 Margaret 需要比较 $\\mathbf{A}$-前缀和 $\\mathbf{B}$-后缀。子串是指连续的字母子序列。如果 $\\mathbf{B}$-后缀以某个 $\\mathbf{A}$-前缀的子串开头，即该子串是 $\\mathbf{B}$-后缀的前缀，则称该子串与 $\\mathbf{B}$-后缀匹配。测试的结果是 $\\mathbf{A}$-前缀中能与 $\\mathbf{B}$-后缀匹配的最长子串的长度。\n\nMargaret 需要一些软件来确定一批 $\\mathbf{Q}$ 个序列分析测试的结果。注意每个测试都是独立的。Margaret 有 $\\mathbf{A}$ 和 $\\mathbf{B}$ 的多个副本，每个测试都使用新的副本。\n", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含两个字符串和一个整数，分别是 $\\mathbf{A}$、$\\mathbf{B}$ 和 $\\mathbf{Q}$。每个测试用例的最后是 $\\mathbf{Q}$ 行，第 $i$ 行包含两个整数 $\\mathbf{P}_i$ 和 $\\mathbf{S}_i$，表示第 $i$ 个序列分析测试的前缀和后缀大小。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y1 y2 ... yQ`，其中 $x$ 是测试用例编号（从 1 开始），$y_i$ 是第 $i$ 个查询的答案。\n", "hint": "**样例解释**\n\n在样例 #1 中，有 3 个测试。第一个测试比较 $\\mathbf{A}$ 的前缀 $\\mathbf{A B C}$ 和 $\\mathbf{B}$ 的完整后缀 $\\mathbf{C A B A B A}$。答案是 1，因为 $\\mathbf{C}$ 是 $\\mathbf{A B C}$ 中包含的最长子串，且是 $\\mathbf{C A B A B A}$ 的前缀。第二个测试比较 $\\mathbf{A B C A B A C}$ 和 $\\mathbf{C A B A B A}$，最长匹配是 $\\mathbf{C A B A}$。第三个测试比较 $\\mathbf{A B C A B A}$ 和 $\\mathbf{A B A B A}$，最长匹配是 $\\mathbf{A B A}$。\n\n在样例 #2 中，有 2 个测试。第一个测试比较 $\\mathbf{B A N A N}$ 和 $\\mathbf{B A N A}$，最长匹配是 $\\mathbf{B A N A}$。第二个测试比较 $\\mathbf{B A N A N}$ 和 $\\mathbf{A B A N A}$，最长匹配是 $\\mathbf{A}$。\n\n在样例 #3 中，有一个测试。比较 $\\mathbf{A B}$ 和 $\\mathbf{D}$。由于没有匹配，答案是 0。\n\n**限制**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{P}_i \\leq \\mathbf{A}$ 的长度。\n- $1 \\leq \\mathbf{S}_i \\leq \\mathbf{B}$ 的长度。\n\n**测试集 1（5 分，可见评测结果）**\n\n- $1 \\leq \\mathbf{A}$ 的长度 $\\leq 3000$。\n- $1 \\leq \\mathbf{B}$ 的长度 $\\leq 3000$。\n- $1 \\leq \\mathbf{Q} \\leq 3000$。\n\n**测试集 2（17 分，隐藏评测结果）**\n\n- $1 \\leq \\mathbf{A}$ 的长度 $\\leq 10^5$。\n- $1 \\leq \\mathbf{B}$ 的长度 $\\leq 10^5$。\n- 所有测试用例中 $\\mathbf{A}$ 的长度总和 $\\leq 5 \\times 10^5$。\n- 所有测试用例中 $\\mathbf{B}$ 的长度总和 $\\leq 5 \\times 10^5$。\n- $1 \\leq \\mathbf{Q} \\leq 10^5$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12963", "type": "P", "difficulty": 7, "samples": [["4\n1 2\naZ\n4 4\na..c\n**.*\n.Y.#\nbX#Z\n2 2\na*\n*Z\n2 7\na*bcd*.\n...*F#.", "Case #1: aZ\nCase #2: aY bX bY cY\nCase #3: NONE\nCase #4: dF"]], "limits": {"time": [60000, 60000, 60000], "memory": [2097152, 2097152, 2097152]}, "tags": ["2023", "广度优先搜索 BFS", "Google Code Jam"], "title": "[GCJ Farewell Round #4] Hey Google, Drive!", "background": "", "description": "The Google Assistant and Android Auto teams are collaborating on a new prototype car that can be driven via voice commands. The early prototype works through a phone connected to a car simulator. Unfortunately, one of the early testers dropped their phone in the toilet, damaging the microphone and making it harder to use the new feature. Since they do not want to miss out on the opportunity, they want your help to use it anyway.\n\nThe early prototype moves on a simple grid of $\\mathbf{R}$ rows and $\\mathbf{C}$ columns and only understands 4 very simple voice commands: north, south, east, and west. Each command makes the car try to move exactly one cell in the corresponding direction. Because of the microphone issues, however, the system may mishear and interchange north and south, and separately, east and west. That means that a command of north may make the car move north or south, a command of south may make the car move south or north, and similarly both commands east and west may make the car move east or west when issued. In all cases, both movement options can happen with equal probability $(1 / 2)$.\n\nThe tester set up a driving grid such that each cell can contain either a wall, a hazard, or be empty. If a command would make the car move into a wall, or outside the grid, it does nothing instead. If a command makes the car move into a hazard, the car cannot execute any more commands.\n\nThe tester has marked some empty cells of the grid as interesting starts and others as interesting finishes. A pair of an interesting start and an interesting finish is drivable if there is a strategy to drive the car through voice commands from the start that makes it end at the finish with probability at least $1-10^{-10^{100}}$. A strategy can choose which command to issue and when to stop depending on the outcome of the previous commands. Notice that if the car moves into a hazard it stops moving, so it cannot make it to the finish. The tester wants your help finding the list of all drivable pairs.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing two integers $\\mathbf{R}$ and $\\mathbf{C}$, the number of rows and columns of the grid. Then, $\\mathbf{R}$ lines follow containing a string of $\\mathbf{C}$ characters each. The $j$-th character on the $i$-th of these lines $\\mathbf{G}_{\\mathbf{i}, \\mathbf{j}}$ represents the grid in the $i$-th row and $j$-th column as follows:\n\n*   A period (. ) represents an uninteresting empty cell.\n*   A hash symbol (#) represents a cell containing a wall.\n*   An asterisk (*) represents a cell containing a hazard.\n*   An English lowercase letter (a through z) represents an empty cell that is an interesting start.\n*   An English uppercase letter (A through z) represents an empty cell that is an interesting finish.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is NONE if there are no drivable pairs. Otherwise, $y$ must be a series of 2 character strings separated by spaces, representing all drivable pairs with the start letter first and the finish letter second, in alphabetical order.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, simply repeating the west command until reaching the finish is a viable strategy. Each time there is a $1 / 2$ probability of reaching the finish and a $1 / 2$ probability of staying in the same place. Thus, the probability of not reaching the finish in $10^{101}$ or fewer steps is $2^{-10^{101}}<10^{-10^{100}}$.\n\nIn Sample Case #2 a similar strategy as in Sample Case #1 can be used to get the car from any position in the top row (1) to any other with probability as high as desired, and similarly for all non-wall positions in the third row from the top (2). Analogously, but using the south command, the car can move between non-wall positions on the third column from the left (3).\n\nFrom both a and c we can use (1) to get to the third column from the left, then (3) to get right next to $\\mathrm{Y}$ and then (2) to get to $\\mathrm{Y}$ making both $\\mathrm{aY}$ and $\\mathrm{cY}$ drivable. Notice, however, that safely using the north or south commands from the third row can only be done in the third column, or otherwise the car may go into a hazard. Therefore, there is no safe way to move the car from the third to the fourth row, making $\\mathrm{aX}$ and $\\mathrm{cX}$ not drivable.\n\nFrom $\\mathrm{b}$, however, the car can use a similar strategy to get to $\\mathrm{x}$, and from $\\mathrm{x}$ the car can get to $\\mathrm{Y}$ by using the north or south command repeatedly (and stop when reaching $\\mathrm{Y}$, never risking going into the hazard above).\n\nFinally, the finish $\\mathrm{z}$ is completely isolated, so it cannot be part of a drivable pair.\n\nIn Sample Case #3, every path from the interesting start to the interesting finish goes through a hazard, which makes the pair not drivable.\n\nIn Sample Case #4, only the interesting start $\\mathrm{d}$ has a viable strategy to get to the finish $\\mathrm{F}$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $\\mathbf{G}_{\\mathbf{i}, \\mathbf{j}}$ is either a period (.), a hash symbol (#), an asterisk (*) or a lowercase or uppercase English letter, for all $i, j$.\n- The set $\\left\\{\\mathbf{G}_{\\mathbf{i}, \\mathbf{j}}\\right.$ for all $\\left.i, j\\right\\}$ contains at least 1 lowercase and at least 1 uppercase English letter.\n- Each lowercase and uppercase letter appears at most once among all $\\mathbf{G}_{\\mathbf{i}, \\mathbf{j}}$.\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{R} \\leq 20$.\n- $1 \\leq \\mathbf{C} \\leq 20$.\n\n**Test Set 2 (17 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{R} \\leq 100$.\n- $1 \\leq \\mathbf{C} \\leq 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #4] Hey Google, Drive!", "background": "", "description": "The Google Assistant and Android Auto teams are collaborating on a new prototype car that can be driven via voice commands. The early prototype works through a phone connected to a car simulator. Unfortunately, one of the early testers dropped their phone in the toilet, damaging the microphone and making it harder to use the new feature. Since they do not want to miss out on the opportunity, they want your help to use it anyway.\n\nThe early prototype moves on a simple grid of $\\mathbf{R}$ rows and $\\mathbf{C}$ columns and only understands 4 very simple voice commands: north, south, east, and west. Each command makes the car try to move exactly one cell in the corresponding direction. Because of the microphone issues, however, the system may mishear and interchange north and south, and separately, east and west. That means that a command of north may make the car move north or south, a command of south may make the car move south or north, and similarly both commands east and west may make the car move east or west when issued. In all cases, both movement options can happen with equal probability $(1 / 2)$.\n\nThe tester set up a driving grid such that each cell can contain either a wall, a hazard, or be empty. If a command would make the car move into a wall, or outside the grid, it does nothing instead. If a command makes the car move into a hazard, the car cannot execute any more commands.\n\nThe tester has marked some empty cells of the grid as interesting starts and others as interesting finishes. A pair of an interesting start and an interesting finish is drivable if there is a strategy to drive the car through voice commands from the start that makes it end at the finish with probability at least $1-10^{-10^{100}}$. A strategy can choose which command to issue and when to stop depending on the outcome of the previous commands. Notice that if the car moves into a hazard it stops moving, so it cannot make it to the finish. The tester wants your help finding the list of all drivable pairs.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing two integers $\\mathbf{R}$ and $\\mathbf{C}$, the number of rows and columns of the grid. Then, $\\mathbf{R}$ lines follow containing a string of $\\mathbf{C}$ characters each. The $j$-th character on the $i$-th of these lines $\\mathbf{G}_{\\mathbf{i}, \\mathbf{j}}$ represents the grid in the $i$-th row and $j$-th column as follows:\n\n*   A period (. ) represents an uninteresting empty cell.\n*   A hash symbol (#) represents a cell containing a wall.\n*   An asterisk (*) represents a cell containing a hazard.\n*   An English lowercase letter (a through z) represents an empty cell that is an interesting start.\n*   An English uppercase letter (A through z) represents an empty cell that is an interesting finish.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is NONE if there are no drivable pairs. Otherwise, $y$ must be a series of 2 character strings separated by spaces, representing all drivable pairs with the start letter first and the finish letter second, in alphabetical order.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, simply repeating the west command until reaching the finish is a viable strategy. Each time there is a $1 / 2$ probability of reaching the finish and a $1 / 2$ probability of staying in the same place. Thus, the probability of not reaching the finish in $10^{101}$ or fewer steps is $2^{-10^{101}}<10^{-10^{100}}$.\n\nIn Sample Case #2 a similar strategy as in Sample Case #1 can be used to get the car from any position in the top row (1) to any other with probability as high as desired, and similarly for all non-wall positions in the third row from the top (2). Analogously, but using the south command, the car can move between non-wall positions on the third column from the left (3).\n\nFrom both a and c we can use (1) to get to the third column from the left, then (3) to get right next to $\\mathrm{Y}$ and then (2) to get to $\\mathrm{Y}$ making both $\\mathrm{aY}$ and $\\mathrm{cY}$ drivable. Notice, however, that safely using the north or south commands from the third row can only be done in the third column, or otherwise the car may go into a hazard. Therefore, there is no safe way to move the car from the third to the fourth row, making $\\mathrm{aX}$ and $\\mathrm{cX}$ not drivable.\n\nFrom $\\mathrm{b}$, however, the car can use a similar strategy to get to $\\mathrm{x}$, and from $\\mathrm{x}$ the car can get to $\\mathrm{Y}$ by using the north or south command repeatedly (and stop when reaching $\\mathrm{Y}$, never risking going into the hazard above).\n\nFinally, the finish $\\mathrm{z}$ is completely isolated, so it cannot be part of a drivable pair.\n\nIn Sample Case #3, every path from the interesting start to the interesting finish goes through a hazard, which makes the pair not drivable.\n\nIn Sample Case #4, only the interesting start $\\mathrm{d}$ has a viable strategy to get to the finish $\\mathrm{F}$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $\\mathbf{G}_{\\mathbf{i}, \\mathbf{j}}$ is either a period (.), a hash symbol (#), an asterisk (*) or a lowercase or uppercase English letter, for all $i, j$.\n- The set $\\left\\{\\mathbf{G}_{\\mathbf{i}, \\mathbf{j}}\\right.$ for all $\\left.i, j\\right\\}$ contains at least 1 lowercase and at least 1 uppercase English letter.\n- Each lowercase and uppercase letter appears at most once among all $\\mathbf{G}_{\\mathbf{i}, \\mathbf{j}}$.\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{R} \\leq 20$.\n- $1 \\leq \\mathbf{C} \\leq 20$.\n\n**Test Set 2 (17 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{R} \\leq 100$.\n- $1 \\leq \\mathbf{C} \\leq 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #4] Hey Google, Drive!", "background": "", "description": "Google Assistant 和 Android Auto 团队正在合作开发一款可以通过语音命令驾驶的新型原型车。早期原型通过连接汽车模拟器的手机工作。不幸的是，一位早期测试者将手机掉进了马桶，导致麦克风损坏，使得新功能更难使用。由于他们不想错过这个机会，因此希望你能帮助他们继续使用。\n\n早期原型在一个简单的 $\\mathbf{R}$ 行 $\\mathbf{C}$ 列的网格上移动，仅能理解 4 个非常简单的语音命令：north（北）、south（南）、east（东）和 west（西）。每个命令会使汽车尝试向对应方向移动一格。但由于麦克风问题，系统可能会混淆 north 和 south，以及 east 和 west。这意味着 north 命令可能使汽车向北或向南移动，south 命令可能使汽车向南或向北移动，类似地，east 和 west 命令也可能使汽车向东或向西移动。在所有情况下，两种移动选项的概率均为 $(1 / 2)$。\n\n测试者设置了一个驾驶网格，每个单元格可以是墙壁、危险区域或空地。如果命令会使汽车移动到墙壁或网格外，则汽车不会移动。如果命令会使汽车移动到危险区域，则汽车无法执行更多命令。\n\n测试者将一些空单元格标记为有趣的起点，另一些标记为有趣的终点。如果一个有趣的起点和有趣的终点组成的配对满足：存在一种通过语音命令驾驶汽车从起点出发的策略，使得汽车以至少 $1-10^{-10^{100}}$ 的概率到达终点，则该配对是可驾驶的。策略可以根据之前命令的结果选择发出哪个命令以及何时停止。注意，如果汽车移动到危险区域，它将停止移动，因此无法到达终点。测试者希望你帮助找出所有可驾驶的配对。", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含两个整数 $\\mathbf{R}$ 和 $\\mathbf{C}$，表示网格的行数和列数。接下来是 $\\mathbf{R}$ 行，每行包含一个长度为 $\\mathbf{C}$ 的字符串。第 $i$ 行的第 $j$ 个字符 $\\mathbf{G}_{\\mathbf{i}, \\mathbf{j}}$ 表示网格的第 $i$ 行第 $j$ 列，具体如下：\n\n*   句点 (.) 表示不感兴趣的空单元格。\n*   井号 (#) 表示包含墙壁的单元格。\n*   星号 (*) 表示包含危险区域的单元格。\n*   小写英文字母 (a 到 z) 表示作为有趣起点的空单元格。\n*   大写英文字母 (A 到 Z) 表示作为有趣终点的空单元格。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是 NONE（如果没有可驾驶的配对）。否则，$y$ 必须是由空格分隔的一系列 2 字符字符串，表示所有可驾驶的配对，起点字母在前，终点字母在后，按字母顺序排列。\n", "hint": "**样例解释**\n\n在样例 #1 中，简单地重复 west 命令直到到达终点是一种可行的策略。每次有 $1 / 2$ 的概率到达终点，$1 / 2$ 的概率停留在原地。因此，在 $10^{101}$ 步或更少步内未到达终点的概率为 $2^{-10^{101}}<10^{-10^{100}}$。\n\n在样例 #2 中，类似于样例 #1 的策略可以用于将汽车从顶行（1）的任何位置以任意高的概率移动到其他位置，类似地也适用于从顶部数第三行（2）的所有非墙壁位置。类似地，但使用 south 命令，汽车可以在从左数第三列（3）的非墙壁位置之间移动。\n\n从 a 和 c 出发，可以使用（1）到达从左数第三列，然后使用（3）到达 $\\mathrm{Y}$ 旁边，再使用（2）到达 $\\mathrm{Y}$，因此 $\\mathrm{aY}$ 和 $\\mathrm{cY}$ 是可驾驶的。然而，从第三行安全使用 north 或 south 命令只能在第三列进行，否则汽车可能会进入危险区域。因此，无法将汽车从第三行安全移动到第四行，因此 $\\mathrm{aX}$ 和 $\\mathrm{cX}$ 不可驾驶。\n\n从 $\\mathrm{b}$ 出发，可以使用类似策略到达 $\\mathrm{X}$，然后从 $\\mathrm{X}$ 出发，通过重复使用 north 或 south 命令（并在到达 $\\mathrm{Y}$ 时停止，避免进入上方的危险区域）到达 $\\mathrm{Y}$。\n\n最后，终点 $\\mathrm{Z}$ 完全孤立，因此无法成为可驾驶配对的一部分。\n\n在样例 #3 中，从有趣起点到有趣终点的每条路径都经过危险区域，因此该配对不可驾驶。\n\n在样例 #4 中，只有有趣起点 $\\mathrm{d}$ 存在可行的策略到达终点 $\\mathrm{F}$。\n\n**限制**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 对于所有 $i, j$，$\\mathbf{G}_{\\mathbf{i}, \\mathbf{j}}$ 是句点 (.)、井号 (#)、星号 (*) 或小写或大写英文字母。\n- 集合 $\\left\\{\\mathbf{G}_{\\mathbf{i}, \\mathbf{j}}\\right.$ 对于所有 $\\left.i, j\\right\\}$ 至少包含 1 个小写和 1 个大写英文字母。\n- 每个小写和大写字母在所有 $\\mathbf{G}_{\\mathbf{i}, \\mathbf{j}}$ 中最多出现一次。\n\n**测试集 1（5 分，可见评测结果）**\n\n- $1 \\leq \\mathbf{R} \\leq 20$。\n- $1 \\leq \\mathbf{C} \\leq 20$。\n\n**测试集 2（17 分，隐藏评测结果）**\n\n- $1 \\leq \\mathbf{R} \\leq 100$。\n- $1 \\leq \\mathbf{C} \\leq 100$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12964", "type": "P", "difficulty": 6, "samples": [["4\no..=>..\n...o>..........\n.=.\n.........o........", "Case #1: 3\nCase #2: 0\nCase #3: 1\nCase #4: 131072"]], "limits": {"time": [20000, 20000, 40000], "memory": [2097152, 2097152, 2097152]}, "tags": ["动态规划 DP", "2023", "Google Code Jam"], "title": "[GCJ Farewell Round #4] Old Gold", "background": "", "description": "A long, long time ago (7 years) you were in a West-East road in southeast Asia known to contain at least one gold nugget, with a limited but reliable gold detector. After getting immensely rich with that gold, you have tried and got bored of every conceivable activity. While wandering around your huge mansion you found some notes from that gold hunt.\n\nThe notes are in the form of a diagram of the road. For each kilometer of road, you have one of 5 markings:\n\n*   $<$, indicating that the closest gold nugget is to the West,\n*   $=$, indicating that the closest gold nuggets to the East and to the West are at the same distance, and no gold nugget is at that position,\n*   $>$, indicating that the closest gold nugget is to the East,\n*   o, indicating that there is a gold nugget at that position, or\n*   ., indicating that nothing is known about that location.\n\nSince each of the $k$ unknown (.) positions could contain or not contain a gold nugget independently, you want to find out how many of the $2^{k}$ placements of gold are compatible with all your notes and result in the road overall containing at least one gold nugget. Since the output can be a really big number, we only ask you to output the remainder of dividing the result by the prime $10^{9}+7$ ($1000000007$).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line contains a string $\\mathbf{S}$ representing a single test case. The $i$-th character of $\\mathbf{S}$ represents the marking in your notes for the $i$-th kilometer of road, from West to East, using the code explained above.\n", "outputFormat": "For each test case, output one line containing case #$x$: $y$, where $x$ is the test case number (starting from 1) and $y$ is the number of different gold placements that are compatible with your notes, modulo the prime $10^{9}+7$ ($1000000007$).", "hint": "**Sample Explanation**\nIn Sample Case #1, there are three valid placements resulting in roads $\\mathrm{o} \\mathrm{o}<=>\\mathrm{o}<$, $\\mathrm{o} \\mathrm{o}<=>\\mathrm{oo}$ and $\\mathrm{o}<<=>\\mathrm{o}$.\n\nIn Sample Case #2, there is no valid placement.\n\nIn Sample Case #3, the only valid placement results in road $\\mathrm{o}=\\mathrm{o}$. Note that a valid placement must always result in a road containing at least one gold nugget.\n\nIn Sample Case #4, all $2^{17}$ placements are valid. In this case, a placement selecting to leave all the unknown (.) positions empty (without a gold nugget) is valid because the road overall still has one gold nugget in such a placement.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- Each character of $\\mathbf{S}$ is either $<$ (less than), $=$ (equals), $>$ (greater than), o (lowercase o), or . (period).\n- At least 1 and not all characters of $\\mathbf{S}$ are . (period).\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $2 \\leq$ the length of $\\mathbf{S} \\leq 100$.\n\n**Test Set 2 (17 Pts, Hidden Verdict)**\n\n- Time limit: 40 seconds.\n- $2 \\leq$ the length of $\\mathbf{S} \\leq 5 \\times 10^{5}$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #4] Old Gold", "background": "", "description": "A long, long time ago (7 years) you were in a West-East road in southeast Asia known to contain at least one gold nugget, with a limited but reliable gold detector. After getting immensely rich with that gold, you have tried and got bored of every conceivable activity. While wandering around your huge mansion you found some notes from that gold hunt.\n\nThe notes are in the form of a diagram of the road. For each kilometer of road, you have one of 5 markings:\n\n*   $<$, indicating that the closest gold nugget is to the West,\n*   $=$, indicating that the closest gold nuggets to the East and to the West are at the same distance, and no gold nugget is at that position,\n*   $>$, indicating that the closest gold nugget is to the East,\n*   o, indicating that there is a gold nugget at that position, or\n*   ., indicating that nothing is known about that location.\n\nSince each of the $k$ unknown (.) positions could contain or not contain a gold nugget independently, you want to find out how many of the $2^{k}$ placements of gold are compatible with all your notes and result in the road overall containing at least one gold nugget. Since the output can be a really big number, we only ask you to output the remainder of dividing the result by the prime $10^{9}+7$ ($1000000007$).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line contains a string $\\mathbf{S}$ representing a single test case. The $i$-th character of $\\mathbf{S}$ represents the marking in your notes for the $i$-th kilometer of road, from West to East, using the code explained above.\n", "outputFormat": "For each test case, output one line containing case #$x$: $y$, where $x$ is the test case number (starting from 1) and $y$ is the number of different gold placements that are compatible with your notes, modulo the prime $10^{9}+7$ ($1000000007$).", "hint": "**Sample Explanation**\nIn Sample Case #1, there are three valid placements resulting in roads $\\mathrm{o} \\mathrm{o}<=>\\mathrm{o}<$, $\\mathrm{o} \\mathrm{o}<=>\\mathrm{oo}$ and $\\mathrm{o}<<=>\\mathrm{o}$.\n\nIn Sample Case #2, there is no valid placement.\n\nIn Sample Case #3, the only valid placement results in road $\\mathrm{o}=\\mathrm{o}$. Note that a valid placement must always result in a road containing at least one gold nugget.\n\nIn Sample Case #4, all $2^{17}$ placements are valid. In this case, a placement selecting to leave all the unknown (.) positions empty (without a gold nugget) is valid because the road overall still has one gold nugget in such a placement.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- Each character of $\\mathbf{S}$ is either $<$ (less than), $=$ (equals), $>$ (greater than), o (lowercase o), or . (period).\n- At least 1 and not all characters of $\\mathbf{S}$ are . (period).\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $2 \\leq$ the length of $\\mathbf{S} \\leq 100$.\n\n**Test Set 2 (17 Pts, Hidden Verdict)**\n\n- Time limit: 40 seconds.\n- $2 \\leq$ the length of $\\mathbf{S} \\leq 5 \\times 10^{5}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #4] Old Gold", "background": null, "description": "很久很久以前（7 年前），你曾在东南亚一条东西向的道路上寻找黄金，这条道路已知至少含有一块金块。当时你使用了一个有限但可靠的金块探测器。在靠这些黄金暴富后，你尝试并厌倦了所有能想到的活动。某天，你在巨大的豪宅中闲逛时，发现了当年寻金时的一些笔记。\n\n这些笔记以道路示意图的形式记录。对于道路的每一公里，笔记上有以下 5 种标记之一：\n\n*   $<$，表示最近的金块位于西侧，\n*   $=$，表示东西两侧最近的金块距离相等，且当前位置没有金块，\n*   $>$，表示最近的金块位于东侧，\n*   o，表示当前位置有金块，或\n*   .，表示该位置信息未知。\n\n由于每个未知位置（.）可以独立地选择是否放置金块，你需要计算在所有 $2^{k}$ 种可能的金块分布中，有多少种分布既符合所有笔记记录，又能保证整条道路上至少存在一块金块。由于结果可能非常大，只需输出结果对质数 $10^{9}+7$（即 $1000000007$）取模后的余数。", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 行，每行包含一个字符串 $\\mathbf{S}$，表示一个测试用例。字符串 $\\mathbf{S}$ 的第 $i$ 个字符表示从西向东第 $i$ 公里处的标记，使用上述代码表示。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是符合笔记记录的金块分布数量，对质数 $10^{9}+7$ 取模后的结果。", "hint": "**样例解释**\n\n在样例 #1 中，有三种有效的金块分布，分别对应道路 $\\mathrm{o} \\mathrm{o}<=>\\mathrm{o}<$、$\\mathrm{o} \\mathrm{o}<=>\\mathrm{oo}$ 和 $\\mathrm{o}<<=>>\\mathrm{o}$。\n\n在样例 #2 中，没有有效的金块分布。\n\n在样例 #3 中，唯一有效的分布对应道路 $\\mathrm{o}=\\mathrm{o}$。注意有效的分布必须保证整条道路上至少有一块金块。\n\n在样例 #4 中，所有 $2^{17}$ 种分布都有效。在这种情况下，即使选择在所有未知位置（.）不放置金块，整条道路仍有一块金块，因此这种分布也是有效的。\n\n**限制**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 字符串 $\\mathbf{S}$ 的每个字符是 $<$（小于）、$=$（等于）、$>$（大于）、o（小写字母 o）或 .（句点）之一。\n- $\\mathbf{S}$ 中至少有 1 个但并非全部字符是 .（句点）。\n\n**测试集 1（5 分，可见评测结果）**\n\n- 时间限制：20 秒。\n- $2 \\leq \\mathbf{S}$ 的长度 $\\leq 100$。\n\n**测试集 2（17 分，隐藏评测结果）**\n\n- 时间限制：40 秒。\n- $2 \\leq \\mathbf{S}$ 的长度 $\\leq 5 \\times 10^{5}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12965", "type": "P", "difficulty": 6, "samples": [["2\n4 5\n\n\n\n\n\n1 2\n1 3\n1 4\n2 4\n3 4\n\n4 4\n\n\n\n\n1 2\n1 3\n2 4\n3 4", "\n\n1 2\n1 3\n4 2\n4 3\n1 4\n\n\n\n\n\n1 2 4 2\n\n1 2\n1 4\n3 2\n3 4\n\n\n\n\n2 1 3 4"]], "limits": {"time": [30000, 30000], "memory": [2097152, 2097152]}, "tags": ["2023", "交互题", "Special Judge", "Google Code Jam"], "title": "[GCJ Farewell Round #4] Ring-Preserving Networks", "background": "", "description": "A research consortium is building a new datacenter. In the datacenter, a set of computers is set up to work together and communicate via a network. The network works only with direct bidirectional links between computers. After the success of their name-preserving networks, they decided to do other designs with guaranteed properties.\n\nThe consortium has asked you to submit a design of a ring-preserving network. We define a ring of a network as an ordering of all the computers of the network such that any two computers that are consecutive in the ordering have a direct link between them, and the same is true for the first and last computers in the ordering.\n\nA ring-preserving network is a network design that can efficiently find a ring of itself even after losing the original computer identifications. You need to submit several network designs that are ring-preserving.\n\nTo evaluate your network designs, the research consortium has set up an automated program. You will be asked for network designs specifying the exact number of computers $\\mathbf{C}$ and the exact number of bidirectional links $\\mathbf{L}$ it must contain. You must assign each computer a unique ID between 1 and $\\mathbf{C}$ and list the $\\mathbf{L}$ links using the IDs to refer to the links' endpoints. The evaluating program will receive that design and send back a copy of the network design with the following changes:\n\n*   the unique IDs have been permuted uniformly at random (that is, each ID is now equally likely to be on any of the computers),\n*   every link is listed with the smallest ID first (using the new IDs), and\n*   the set of links is listed in increasing order of the first endpoint (using the new IDs), breaking ties by smallest second endpoint (i.e., lexicographical order).\n\nYou need to be able to find a ring of the modified network. It does not need to be the original ring.\n\n### Interactive Protocol\n\nThis is an interactive problem. You should make sure you have read the information in the Interactive Problems section of our FAQ.\n\nInitially, your program should read a single line containing an integer, $\\mathbf{T}$, the number of test cases. Then, $\\mathbf{T}$ test cases must be processed.\n\nFor each test case, your program must first read a line containing two integers $\\mathbf{C}$ and $\\mathbf{L}$: the number of computers and links to include in the network design.\n\nThen, you need to create a network design with $\\mathbf{C}$ computers and $\\mathbf{L}$ links and print exactly $\\mathbf{L}$ lines representing that design. Each of these lines must contain two integers $\\mathrm{A}$ and $\\mathrm{B}$ each, representing a different link between computers $\\mathrm{A}$ and $\\mathrm{B}$, where $A \\neq B$. Notice that if you list link $\\mathrm{A} \\mathrm{B}$, you may not list $\\mathrm{A} \\mathrm{B}$ nor $\\mathrm{B} \\mathrm{A}$ again.\n\nUpon reading your network design, the judge will send you $\\mathbf{L}$ lines back representing the permuted design. The $i$-th of these lines contains two integers $\\mathbf{U}_{\\mathbf{i}}$ and $\\mathbf{V}_{\\mathbf{i}}$ representing a bidirectional link between the computers with new ids $\\mathbf{U}_{\\mathbf{i}}$ and $\\mathbf{V}_{\\mathbf{i}}$. The copy is generated using a permutation chosen uniformly at random from all possible permutations, and independently of any other choices.\n\nTo finish a test case, you need to send the judge a single line with $\\mathbf{C}$ integers $x_{1}, x_{2}, \\ldots, x_{\\mathbf{C}}$, representing a ring of the permuted design. That is, the set of lines the judge sent back must include either $x_{1} x_{\\mathbf{C}}$ or $x_{\\mathbf{C}} x_{1}$, and, for all $i$, it must include either $x_{i} x_{i+1}$ or $x_{i+1} x_{i}$.\n\nYou should not send additional information to the judge after solving all test cases. In other words, if your program keeps printing to standard output after printing the list of $x s$ for the last test case, you will receive a Wrong Answer judgment.\n\nIf at any point the judge reads from your program malformed input (wrong number of tokens, non-integer tokens or out of range numbers) it will immediately stop and assume Wrong Answer. However, if your program happens to remain waiting for input from the judge, it may end up exceeding the time limit and receiving a Time Limit Exceeded judgement. On the other hand, if you commit a recoverable error (sending over a network with a repeated connection, or a connection from a computer to itself, or sending a ring that repeats a computer or that uses an edge that does not exist in the permuted version) the judge will continue to communicate with your program trying to finish, but the overall judgement will be Wrong Answer.\n\nNotice that you are allowed to submit the same network design for different test cases, as long as that design complies with all restrictions for both cases. Additionally, the seed for random generation in the judge is fixed, so sending the same set of original network designs in the same order will get back the same set of copies.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Explanation**\n\nCase 2 is correct, but Case 1 is not, so the final judgement is Wrong Answer.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $3 \\leq \\mathbf{C} \\leq 10000$.\n- $\\mathbf{C} \\leq \\mathbf{L} \\leq \\mathbf{C} \\times (\\mathbf{C} - 1) / 2$.\n- $1 \\leq \\mathbf{U}_{\\mathbf{i}} < \\mathbf{V}_{\\mathbf{i}} \\leq \\mathbf{C}$, for all $i$.\n- $\\mathbf{U}_{\\mathbf{i}} \\leq \\mathbf{U}_{\\mathbf{i+1}}$, for all $i$.\n- If $\\mathbf{U}_{\\mathbf{i}} = \\mathbf{U}_{\\mathbf{i+1}}$ then $\\mathbf{V}_{\\mathbf{i}} \\leq \\mathbf{V}_{\\mathbf{i+1}}$, for all $i$.\n- There exist permutations $f$ of length $\\mathbf{C}$ and $g$ of length $\\mathbf{L}$ such that, for each $i$, if $A \\ B$ is the $g(i)$-th line in your original design, then $\\{\\mathbf{U}_{\\mathbf{i}}, \\mathbf{V}_{\\mathbf{i}}\\} = \\{f(A), f(B)\\}$. (The given links result from applying a permutation of computer IDs to the ones you gave, and then sorting the links lexicographically).\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- $\\mathbf{L} \\leq \\mathbf{C} + 10$.\n\n**Test Set 2 (17 Pts, Hidden Verdict)**\n\n- $\\mathbf{L} \\leq 20000$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #4] Ring-Preserving Networks", "background": "", "description": "A research consortium is building a new datacenter. In the datacenter, a set of computers is set up to work together and communicate via a network. The network works only with direct bidirectional links between computers. After the success of their name-preserving networks, they decided to do other designs with guaranteed properties.\n\nThe consortium has asked you to submit a design of a ring-preserving network. We define a ring of a network as an ordering of all the computers of the network such that any two computers that are consecutive in the ordering have a direct link between them, and the same is true for the first and last computers in the ordering.\n\nA ring-preserving network is a network design that can efficiently find a ring of itself even after losing the original computer identifications. You need to submit several network designs that are ring-preserving.\n\nTo evaluate your network designs, the research consortium has set up an automated program. You will be asked for network designs specifying the exact number of computers $\\mathbf{C}$ and the exact number of bidirectional links $\\mathbf{L}$ it must contain. You must assign each computer a unique ID between 1 and $\\mathbf{C}$ and list the $\\mathbf{L}$ links using the IDs to refer to the links' endpoints. The evaluating program will receive that design and send back a copy of the network design with the following changes:\n\n*   the unique IDs have been permuted uniformly at random (that is, each ID is now equally likely to be on any of the computers),\n*   every link is listed with the smallest ID first (using the new IDs), and\n*   the set of links is listed in increasing order of the first endpoint (using the new IDs), breaking ties by smallest second endpoint (i.e., lexicographical order).\n\nYou need to be able to find a ring of the modified network. It does not need to be the original ring.\n\n### Interactive Protocol\n\nThis is an interactive problem. You should make sure you have read the information in the Interactive Problems section of our FAQ.\n\nInitially, your program should read a single line containing an integer, $\\mathbf{T}$, the number of test cases. Then, $\\mathbf{T}$ test cases must be processed.\n\nFor each test case, your program must first read a line containing two integers $\\mathbf{C}$ and $\\mathbf{L}$: the number of computers and links to include in the network design.\n\nThen, you need to create a network design with $\\mathbf{C}$ computers and $\\mathbf{L}$ links and print exactly $\\mathbf{L}$ lines representing that design. Each of these lines must contain two integers $\\mathrm{A}$ and $\\mathrm{B}$ each, representing a different link between computers $\\mathrm{A}$ and $\\mathrm{B}$, where $A \\neq B$. Notice that if you list link $\\mathrm{A} \\mathrm{B}$, you may not list $\\mathrm{A} \\mathrm{B}$ nor $\\mathrm{B} \\mathrm{A}$ again.\n\nUpon reading your network design, the judge will send you $\\mathbf{L}$ lines back representing the permuted design. The $i$-th of these lines contains two integers $\\mathbf{U}_{\\mathbf{i}}$ and $\\mathbf{V}_{\\mathbf{i}}$ representing a bidirectional link between the computers with new ids $\\mathbf{U}_{\\mathbf{i}}$ and $\\mathbf{V}_{\\mathbf{i}}$. The copy is generated using a permutation chosen uniformly at random from all possible permutations, and independently of any other choices.\n\nTo finish a test case, you need to send the judge a single line with $\\mathbf{C}$ integers $x_{1}, x_{2}, \\ldots, x_{\\mathbf{C}}$, representing a ring of the permuted design. That is, the set of lines the judge sent back must include either $x_{1} x_{\\mathbf{C}}$ or $x_{\\mathbf{C}} x_{1}$, and, for all $i$, it must include either $x_{i} x_{i+1}$ or $x_{i+1} x_{i}$.\n\nYou should not send additional information to the judge after solving all test cases. In other words, if your program keeps printing to standard output after printing the list of $x s$ for the last test case, you will receive a Wrong Answer judgment.\n\nIf at any point the judge reads from your program malformed input (wrong number of tokens, non-integer tokens or out of range numbers) it will immediately stop and assume Wrong Answer. However, if your program happens to remain waiting for input from the judge, it may end up exceeding the time limit and receiving a Time Limit Exceeded judgement. On the other hand, if you commit a recoverable error (sending over a network with a repeated connection, or a connection from a computer to itself, or sending a ring that repeats a computer or that uses an edge that does not exist in the permuted version) the judge will continue to communicate with your program trying to finish, but the overall judgement will be Wrong Answer.\n\nNotice that you are allowed to submit the same network design for different test cases, as long as that design complies with all restrictions for both cases. Additionally, the seed for random generation in the judge is fixed, so sending the same set of original network designs in the same order will get back the same set of copies.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Explanation**\n\nCase 2 is correct, but Case 1 is not, so the final judgement is Wrong Answer.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $3 \\leq \\mathbf{C} \\leq 10000$.\n- $\\mathbf{C} \\leq \\mathbf{L} \\leq \\mathbf{C} \\times (\\mathbf{C} - 1) / 2$.\n- $1 \\leq \\mathbf{U}_{\\mathbf{i}} < \\mathbf{V}_{\\mathbf{i}} \\leq \\mathbf{C}$, for all $i$.\n- $\\mathbf{U}_{\\mathbf{i}} \\leq \\mathbf{U}_{\\mathbf{i+1}}$, for all $i$.\n- If $\\mathbf{U}_{\\mathbf{i}} = \\mathbf{U}_{\\mathbf{i+1}}$ then $\\mathbf{V}_{\\mathbf{i}} \\leq \\mathbf{V}_{\\mathbf{i+1}}$, for all $i$.\n- There exist permutations $f$ of length $\\mathbf{C}$ and $g$ of length $\\mathbf{L}$ such that, for each $i$, if $A \\ B$ is the $g(i)$-th line in your original design, then $\\{\\mathbf{U}_{\\mathbf{i}}, \\mathbf{V}_{\\mathbf{i}}\\} = \\{f(A), f(B)\\}$. (The given links result from applying a permutation of computer IDs to the ones you gave, and then sorting the links lexicographically).\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- $\\mathbf{L} \\leq \\mathbf{C} + 10$.\n\n**Test Set 2 (17 Pts, Hidden Verdict)**\n\n- $\\mathbf{L} \\leq 20000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #4] Ring-Preserving Networks", "background": "", "description": "一个研究联盟正在建设一个新的数据中心。在数据中心中，一组计算机通过网络相互连接和通信。该网络仅通过计算机之间的直接双向链路工作。在他们成功开发了**名称保持网络**后，决定开发其他具有保证特性的设计。\n\n该联盟要求你提交一种**环保持网络**的设计方案。我们将网络的**环**定义为网络中所有计算机的一个排列顺序，使得排列中任意两个相邻计算机之间存在直接链路，且排列的首尾计算机之间也存在直接链路。\n\n**环保持网络**是一种网络设计方案，即使在丢失原始计算机标识后，仍能高效找到自身的环。你需要提交多个满足环保持特性的网络设计。\n\n为了评估你的网络设计，研究联盟设置了一个自动化程序。你需要根据指定的计算机数量 $\\mathbf{C}$ 和双向链路数量 $\\mathbf{L}$ 提交网络设计。你必须为每台计算机分配一个 1 到 $\\mathbf{C}$ 之间的唯一 ID，并用这些 ID 列出 $\\mathbf{L}$ 条链路。评估程序会接收该设计，并返回一个经过以下修改的网络设计副本：\n\n*   唯一 ID 被均匀随机排列（即每个新 ID 可能出现在任意计算机上），\n*   每条链路按新 ID 从小到大排列，\n*   链路集合按第一个端点的升序排列（使用新 ID），若第一个端点相同则按第二个端点的升序排列（即字典序）。\n\n你需要能够从修改后的网络中找到至少一个环。这个环不需要是原始环。\n\n### 交互协议\n\n这是一个交互式问题。请确保你已阅读我们 FAQ 中关于交互式问题的部分。\n\n最初，你的程序应读取一个整数 $\\mathbf{T}$，表示测试用例的数量。然后，需要处理 $\\mathbf{T}$ 个测试用例。\n\n对于每个测试用例，你的程序首先读取一行包含两个整数 $\\mathbf{C}$ 和 $\\mathbf{L}$，分别表示网络设计中的计算机数量和链路数量。\n\n然后，你需要创建一个包含 $\\mathbf{C}$ 台计算机和 $\\mathbf{L}$ 条链路的网络设计，并打印恰好 $\\mathbf{L}$ 行表示该设计。每行包含两个不同的整数 $\\mathrm{A}$ 和 $\\mathrm{B}$，表示计算机 $\\mathrm{A}$ 和 $\\mathrm{B}$ 之间的一条链路（$A \\neq B$）。注意，如果你列出了链路 $\\mathrm{A} \\mathrm{B}$，就不能再列出 $\\mathrm{A} \\mathrm{B}$ 或 $\\mathrm{B} \\mathrm{A}$。\n\n在读取你的网络设计后，评测系统会返回 $\\mathbf{L}$ 行表示经过排列的设计。第 $i$ 行包含两个整数 $\\mathbf{U}_{\\mathbf{i}}$ 和 $\\mathbf{V}_{\\mathbf{i}}$，表示新 ID 为 $\\mathbf{U}_{\\mathbf{i}}$ 和 $\\mathbf{V}_{\\mathbf{i}}$ 的计算机之间的双向链路。该副本使用从所有可能排列中均匀随机选择的排列生成，且与其他选择独立。\n\n要完成一个测试用例，你需要向评测系统发送一行包含 $\\mathbf{C}$ 个整数 $x_{1}, x_{2}, \\ldots, x_{\\mathbf{C}}$，表示排列后设计中的一个环。即，评测系统返回的链路集合中必须包含 $x_{1} x_{\\mathbf{C}}$ 或 $x_{\\mathbf{C}} x_{1}$，并且对于所有 $i$，必须包含 $x_{i} x_{i+1}$ 或 $x_{i+1} x_{i}$。\n\n在处理完所有测试用例后，你不应再向评测系统发送任何信息。换句话说，如果在打印最后一个测试用例的环列表后，你的程序继续向标准输出打印内容，将被判为错误答案。\n\n如果在任何时候评测系统从你的程序中读取到格式错误的输入（令牌数量错误、非整数令牌或超出范围的数字），它将立即停止并判定为错误答案。然而，如果你的程序在等待评测系统的输入时超时，可能会被判为超出时间限制。另一方面，如果你犯了一个可恢复的错误（发送的网络中包含重复连接、自环连接，或发送的环中重复使用计算机或使用了排列后版本中不存在的边），评测系统会继续与你的程序通信以完成测试，但最终判定仍为错误答案。\n\n请注意，你可以在不同的测试用例中提交相同的网络设计，只要该设计同时满足所有限制条件。此外，评测系统中的随机生成种子是固定的，因此以相同顺序提交相同的原始网络设计集将获得相同的副本集。\n", "inputFormat": "参见交互协议。", "outputFormat": "参见交互协议。", "hint": "**样例解释**\n\n第一组样例是错误的，第二组样例是正确的，因此最后的评判为 Wrong Answer。\n\n**限制**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $3 \\leq \\mathbf{C} \\leq 10000$。\n- $\\mathbf{C} \\leq \\mathbf{L} \\leq \\mathbf{C} \\times (\\mathbf{C} - 1) / 2$。\n- 对于所有 $i$，$1 \\leq \\mathbf{U}_{\\mathbf{i}} < \\mathbf{V}_{\\mathbf{i}} \\leq \\mathbf{C}$。\n- 对于所有 $i$，$\\mathbf{U}_{\\mathbf{i}} \\leq \\mathbf{U}_{\\mathbf{i+1}}$。\n- 如果 $\\mathbf{U}_{\\mathbf{i}} = \\mathbf{U}_{\\mathbf{i+1}}$，则对于所有 $i$，$\\mathbf{V}_{\\mathbf{i}} \\leq \\mathbf{V}_{\\mathbf{i+1}}$。\n- 存在长度为 $\\mathbf{C}$ 的排列 $f$ 和长度为 $\\mathbf{L}$ 的排列 $g$，使得对于每个 $i$，如果 $A \\ B$ 是你的原始设计中的第 $g(i)$ 行，则 $\\{\\mathbf{U}_{\\mathbf{i}}, \\mathbf{V}_{\\mathbf{i}}\\} = \\{f(A), f(B)\\}$。（给定的链路是通过对计算机 ID 进行排列并对链路按字典序排序后得到的）。\n\n**测试集 1（5 分，可见评测结果）**\n\n- $\\mathbf{L} \\leq \\mathbf{C} + 10$。\n\n**测试集 2（17 分，隐藏评测结果）**\n\n- $\\mathbf{L} \\leq 20000$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12966", "type": "P", "difficulty": 5, "samples": [["6 10 \n1 1\n5 2\n200 6\n9 2\n6 2\n100 1", "310"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "贪心", "2025", "排序", "CCO（加拿大）"], "title": "[CCO 2025] Asteroid Mining", "background": "", "description": "It is the year 2017 and Ryan is an asteroid miner. He makes a living by mining asteroids and selling them at the CCO (Celestial Cargo Outpost).\n\nOn his latest mining expedition, he has mined $N$ mineral chunks where the $i$-th chunk has a value $v_i$ and a mass $m_i$. Ryan plans to transport a set of chunks to the CCO with his rocket, but he only has enough fuel to last one more trip. He calculated that the maximum total mass he can safely carry on his rocket is $M$. Due to Ryan's mining technique, the chunks exhibit a special property: for any two mineral chunks, one's mass is divisible by the other chunk's mass.\n\nHelp Ryan find the maximum total value he can ship to CCO while adhering to his rocket's constraints.", "inputFormat": "The first line will contain two space-separated integers $N$ ($1 \\leq N \\leq 500000$) and $M$ ($1 \\leq M \\leq 10^{12}$).\n\nThe next $N$ lines will each contain two space-separated integers $v_i$ ($1 \\leq v_i \\leq 10^{12}$) and $m_i$ ($1 \\leq m_i \\leq 10^{12}$), representing the value and mass of the $i$-th mineral chunk respectively. **Additionally, for any two mineral chunks $i, j$ ($1 \\leq i, j \\leq N$), either $m_i \\mid m_j$ or $m_j \\mid m_i$, where $a \\mid b$ means that $a$ is a divisor of $b$ (i.e., $\\frac{b}{a}$ is an integer).**", "outputFormat": "On one line, output one integer, the maximum total value Ryan can ship to CCO.", "hint": "**Sample Explanation**\n\nRyan can take all the chucks except the second and fifth chucks to achieve a total value of $1 + 200 + 9 + 100 = 310$. Note that the total mass of the chunks is $1 + 6 + 2 + 1 = 10$. We can show that this is optimal.\n\nThe following table shows how the available $25$ marks are distributed:\n\n| Marks Awarded | Bounds on $N$ | Bounds on $M$ | Additional Constraints |\n| :---: | :---: | :---: | :---: |\n| 2 marks | $N = 2$ | $1 \\leq M \\leq 10^4$ | None |\n| 2 marks | $1 \\leq N \\leq 20$ | $1 \\leq M \\leq 10^4$ | None |\n| 4 marks | $1 \\leq N \\leq 1000$ | $1 \\leq M \\leq 10^4$ | None |\n| 6 marks | $1 \\leq N \\leq 1000$ | $1 \\leq M \\leq 10^8$ | None |\n| 2 marks | $1 \\leq N \\leq 500000$ | $1 \\leq M \\leq 10^8$ | All $m_i$ are equal. |\n| 3 marks | $1 \\leq N \\leq 500000$ | $1 \\leq M \\leq 10^8$ | At most 2 distinct $m_i$. |\n| 6 marks | $1 \\leq N \\leq 500000$ | $1 \\leq M \\leq 10^{12}$ | None |\n", "locale": "en", "translations": {"en": {"title": "[CCO 2025] Asteroid Mining", "background": "", "description": "It is the year 2017 and Ryan is an asteroid miner. He makes a living by mining asteroids and selling them at the CCO (Celestial Cargo Outpost).\n\nOn his latest mining expedition, he has mined $N$ mineral chunks where the $i$-th chunk has a value $v_i$ and a mass $m_i$. Ryan plans to transport a set of chunks to the CCO with his rocket, but he only has enough fuel to last one more trip. He calculated that the maximum total mass he can safely carry on his rocket is $M$. Due to Ryan's mining technique, the chunks exhibit a special property: for any two mineral chunks, one's mass is divisible by the other chunk's mass.\n\nHelp Ryan find the maximum total value he can ship to CCO while adhering to his rocket's constraints.", "inputFormat": "The first line will contain two space-separated integers $N$ ($1 \\leq N \\leq 500000$) and $M$ ($1 \\leq M \\leq 10^{12}$).\n\nThe next $N$ lines will each contain two space-separated integers $v_i$ ($1 \\leq v_i \\leq 10^{12}$) and $m_i$ ($1 \\leq m_i \\leq 10^{12}$), representing the value and mass of the $i$-th mineral chunk respectively. **Additionally, for any two mineral chunks $i, j$ ($1 \\leq i, j \\leq N$), either $m_i \\mid m_j$ or $m_j \\mid m_i$, where $a \\mid b$ means that $a$ is a divisor of $b$ (i.e., $\\frac{b}{a}$ is an integer).**", "outputFormat": "On one line, output one integer, the maximum total value Ryan can ship to CCO.", "hint": "**Sample Explanation**\n\nRyan can take all the chucks except the second and fifth chucks to achieve a total value of $1 + 200 + 9 + 100 = 310$. Note that the total mass of the chunks is $1 + 6 + 2 + 1 = 10$. We can show that this is optimal.\n\nThe following table shows how the available $25$ marks are distributed:\n\n| Marks Awarded | Bounds on $N$ | Bounds on $M$ | Additional Constraints |\n| :---: | :---: | :---: | :---: |\n| 2 marks | $N = 2$ | $1 \\leq M \\leq 10^4$ | None |\n| 2 marks | $1 \\leq N \\leq 20$ | $1 \\leq M \\leq 10^4$ | None |\n| 4 marks | $1 \\leq N \\leq 1000$ | $1 \\leq M \\leq 10^4$ | None |\n| 6 marks | $1 \\leq N \\leq 1000$ | $1 \\leq M \\leq 10^8$ | None |\n| 2 marks | $1 \\leq N \\leq 500000$ | $1 \\leq M \\leq 10^8$ | All $m_i$ are equal. |\n| 3 marks | $1 \\leq N \\leq 500000$ | $1 \\leq M \\leq 10^8$ | At most 2 distinct $m_i$. |\n| 6 marks | $1 \\leq N \\leq 500000$ | $1 \\leq M \\leq 10^{12}$ | None |\n", "locale": "en"}, "zh-CN": {"title": "[CCO 2025] Asteroid Mining", "background": "", "description": "现在是 2017 年，**Ryan** 是一名小行星矿工。他以开采小行星并在 **CCO**（天体货运前哨站）出售矿物为生。\n\n在最近的一次采矿探险中，他开采了 $N$ 块矿物，其中第 $i$ 块矿物的价值为 $v_i$，质量为 $m_i$。**Ryan** 计划用他的火箭将一组矿物运送到 **CCO**，但他只剩下足够进行一次飞行的燃料。他计算出火箭能够安全携带的最大总质量为 $M$。由于 **Ryan** 的采矿技术，这些矿物具有一个特殊性质：对于任意两块矿物，其中一块的质量可以被另一块的质量整除。\n\n帮助 **Ryan** 在火箭的限制下找到他能运送到 **CCO** 的最大总价值。", "inputFormat": "第一行包含两个以空格分隔的整数 $N$（$1 \\leq N \\leq 500000$）和 $M$（$1 \\leq M \\leq 10^{12}$）。\n\n接下来的 $N$ 行，每行包含两个以空格分隔的整数 $v_i$（$1 \\leq v_i \\leq 10^{12}$）和 $m_i$（$1 \\leq m_i \\leq 10^{12}$），分别表示第 $i$ 块矿物的价值和质量。**此外，对于任意两块矿物 $i, j$（$1 \\leq i, j \\leq N$），要么 $m_i \\mid m_j$，要么 $m_j \\mid m_i$，其中 $a \\mid b$ 表示 $a$ 是 $b$ 的因数（即 $\\frac{b}{a}$ 是整数）。**\n", "outputFormat": "输出一行，包含一个整数，表示 **Ryan** 能运送到 **CCO** 的最大总价值。\n", "hint": "**样例解释**\n\n**Ryan** 可以携带除第二块和第五块之外的所有矿物，以获得总价值 $1 + 200 + 9 + 100 = 310$。注意，这些矿物的总质量为 $1 + 6 + 2 + 1 = 10$。可以证明这是最优解。\n\n以下表格展示了 25 分的分布情况：\n\n| 分值 | $N$ 的范围 | $M$ 的范围 | 额外约束 |\n| :---: | :---: | :---: | :---: |\n| 2 分 | $N = 2$ | $1 \\leq M \\leq 10^4$ | 无 |\n| 2 分 | $1 \\leq N \\leq 20$ | $1 \\leq M \\leq 10^4$ | 无 |\n| 4 分 | $1 \\leq N \\leq 1000$ | $1 \\leq M \\leq 10^4$ | 无 |\n| 6 分 | $1 \\leq N \\leq 1000$ | $1 \\leq M \\leq 10^8$ | 无 |\n| 2 分 | $1 \\leq N \\leq 500000$ | $1 \\leq M \\leq 10^8$ | 所有 $m_i$ 相等。 |\n| 3 分 | $1 \\leq N \\leq 500000$ | $1 \\leq M \\leq 10^8$ | 最多 2 种不同的 $m_i$。 |\n| 6 分 | $1 \\leq N \\leq 500000$ | $1 \\leq M \\leq 10^{12}$ | 无 |\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12967", "type": "P", "difficulty": 6, "samples": [["8 3\n1 2\n1 3\n1 4\n2 5\n2 6\n3 7\n3 8", "1"], ["14 5\n1 2\n1 3\n3 4\n3 5\n1 6\n6 7\n7 8\n7 9\n2 10\n10 11\n10 12\n10 13\n10 14", "2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "CCO（加拿大）"], "title": "[CCO 2025] Tree Decorations", "background": "", "description": "Mateo recently found the perfect decorations for his Christmas tree — more trees!\n\nSpecifically, his Christmas tree is a rooted tree $T$ initially with $M$ nodes, all painted green. He has another rooted tree $D$ that he uses as a reference for his decorations. Mateo uses the following process to put on all of his decorations:\n\n- For each node $i$ in $D$, he creates a **copy** of the subtree rooted at $i$. Let this copy be $C_i$. Then, he paints the nodes of $C_i$ red. Finally, he chooses some green node in $T$ to be the parent of the root of $C_i$ by connecting them with an edge.\n\nAfter applying all the decorations, $T$ ends up containing $N$ nodes. Unfortunately, he realized that he had forgotten to record what $D$ is! To make things worse, he accidentally spilled water on $T$, washing off all the colour from the nodes. After all that, he labels the root of $T$ as 1, and then labels the rest of the nodes from 2 to $N$.\n\nThe only information he currently has is the final state of $T$, as well as $M$. Help him find the number of possible $D$ that he could have started with, where two possibilities are considered different if they are structurally distinct.\n\nRooted trees $A$ and $B$ are said to be structurally identical if and only if they have the same number of nodes $S$, and there is a way to label $A$'s nodes from 1 to $S$ and $B$'s nodes from 1 to $S$ such that:\n\n- Their roots are labeled the same.\n- Nodes labeled $x$ and $y$ in $A$ are connected by an edge if and only if nodes labeled $x$ and $y$ in $B$ are connected by an edge.\n\nOtherwise, $A$ and $B$ are considered structurally distinct.", "inputFormat": "The first line of input contains two space-separated integers $N$ and $M$.\n\nThe next $N - 1$ lines each contain two space-separated integers $u_i$ and $v_i$ ($1 \\leq u_i, v_i \\leq N$, $u_i \\neq v_i$), describing an edge in $T$ connecting nodes $u_i$ and $v_", "outputFormat": "Output the number of possible $D$ that he could have started with, where two possibilities are considered different if they are structurally distinct.", "hint": "**Sample 1 Explanation**\n\nIt is provable that the only possible $D$ is:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/prs3i0ia.png)\n\nWe can get $T$ the following way:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/es4cbjcu.png)\n\nIn the diagram above, the red parts are added as decorations, while the green, filled-in part represents the initial state of $T$. The dotted lines represent the edges connecting the decorations to the tree.\n\n**Sample 2 Explanation**\n\nThe first possibility for $D$ is:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xn2gjm2q.png)\n\nUsing this, we can get $T$ the following way:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yu3ac03q.png)\n\nThe second possibility for $D$ is:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/d7m3kjgj.png)\n\nUsing this, we can get $T$ the following way:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7lulazk0.png)\n\nThe following table shows how the available $25$ marks are distributed:\n\n| Marks Awarded | Bounds on $N$ | Bounds on $M$ |\n|:---------------:|:---------------:|:----------------:|\n| 2 marks       | $2 \\leq N \\leq 10$ | $M = 1$        |\n| 3 marks       | $2 \\leq N \\leq 200$ | $M = 1$        |\n| 2 marks       | $2 \\leq N \\leq 500000$ | $M = 1$        |\n| 6 marks       | $2 \\leq N \\leq 200$ | $1 \\leq M < N$ |\n| 4 marks       | $2 \\leq N \\leq 2000$ | $1 \\leq M < N$ |\n| 8 marks       | $2 \\leq N \\leq 500000$ | $1 \\leq M < N$ |", "locale": "en", "translations": {"en": {"title": "[CCO 2025] Tree Decorations", "background": "", "description": "Mateo recently found the perfect decorations for his Christmas tree — more trees!\n\nSpecifically, his Christmas tree is a rooted tree $T$ initially with $M$ nodes, all painted green. He has another rooted tree $D$ that he uses as a reference for his decorations. Mateo uses the following process to put on all of his decorations:\n\n- For each node $i$ in $D$, he creates a **copy** of the subtree rooted at $i$. Let this copy be $C_i$. Then, he paints the nodes of $C_i$ red. Finally, he chooses some green node in $T$ to be the parent of the root of $C_i$ by connecting them with an edge.\n\nAfter applying all the decorations, $T$ ends up containing $N$ nodes. Unfortunately, he realized that he had forgotten to record what $D$ is! To make things worse, he accidentally spilled water on $T$, washing off all the colour from the nodes. After all that, he labels the root of $T$ as 1, and then labels the rest of the nodes from 2 to $N$.\n\nThe only information he currently has is the final state of $T$, as well as $M$. Help him find the number of possible $D$ that he could have started with, where two possibilities are considered different if they are structurally distinct.\n\nRooted trees $A$ and $B$ are said to be structurally identical if and only if they have the same number of nodes $S$, and there is a way to label $A$'s nodes from 1 to $S$ and $B$'s nodes from 1 to $S$ such that:\n\n- Their roots are labeled the same.\n- Nodes labeled $x$ and $y$ in $A$ are connected by an edge if and only if nodes labeled $x$ and $y$ in $B$ are connected by an edge.\n\nOtherwise, $A$ and $B$ are considered structurally distinct.", "inputFormat": "The first line of input contains two space-separated integers $N$ and $M$.\n\nThe next $N - 1$ lines each contain two space-separated integers $u_i$ and $v_i$ ($1 \\leq u_i, v_i \\leq N$, $u_i \\neq v_i$), describing an edge in $T$ connecting nodes $u_i$ and $v_", "outputFormat": "Output the number of possible $D$ that he could have started with, where two possibilities are considered different if they are structurally distinct.", "hint": "**Sample 1 Explanation**\n\nIt is provable that the only possible $D$ is:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/prs3i0ia.png)\n\nWe can get $T$ the following way:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/es4cbjcu.png)\n\nIn the diagram above, the red parts are added as decorations, while the green, filled-in part represents the initial state of $T$. The dotted lines represent the edges connecting the decorations to the tree.\n\n**Sample 2 Explanation**\n\nThe first possibility for $D$ is:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xn2gjm2q.png)\n\nUsing this, we can get $T$ the following way:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yu3ac03q.png)\n\nThe second possibility for $D$ is:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/d7m3kjgj.png)\n\nUsing this, we can get $T$ the following way:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7lulazk0.png)\n\nThe following table shows how the available $25$ marks are distributed:\n\n| Marks Awarded | Bounds on $N$ | Bounds on $M$ |\n|:---------------:|:---------------:|:----------------:|\n| 2 marks       | $2 \\leq N \\leq 10$ | $M = 1$        |\n| 3 marks       | $2 \\leq N \\leq 200$ | $M = 1$        |\n| 2 marks       | $2 \\leq N \\leq 500000$ | $M = 1$        |\n| 6 marks       | $2 \\leq N \\leq 200$ | $1 \\leq M < N$ |\n| 4 marks       | $2 \\leq N \\leq 2000$ | $1 \\leq M < N$ |\n| 8 marks       | $2 \\leq N \\leq 500000$ | $1 \\leq M < N$ |", "locale": "en"}, "zh-CN": {"title": "[CCO 2025] Tree Decorations", "background": "", "description": "**Mateo** 最近为他的圣诞树找到了完美的装饰品——更多的树！\n\n具体来说，他的圣诞树是一棵初始有 $M$ 个节点、全部涂成绿色的有根树 $T$。他还有另一棵用作装饰参考的有根树 $D$。**Mateo** 通过以下步骤完成所有装饰：\n\n- 对于 $D$ 中的每个节点 $i$，他创建一份以 $i$ 为根的子树**副本**，记为 $C_i$。然后，他将 $C_i$ 的所有节点涂成红色。最后，他选择 $T$ 中的某个绿色节点作为 $C_i$ 根节点的父节点，并通过一条边将它们连接起来。\n\n完成所有装饰后，$T$ 最终包含 $N$ 个节点。不幸的是，他忘记记录 $D$ 的具体形态了！更糟的是，他不小心将水洒在 $T$ 上，导致所有节点的颜色都被洗掉了。之后，他将 $T$ 的根节点标记为 1，其余节点依次标记为 2 到 $N$。\n\n目前他唯一掌握的信息是 $T$ 的最终形态以及 $M$ 的值。请帮助他计算可能的初始树 $D$ 的数量（若两棵树结构不同，则视为不同的可能性）。\n\n若两棵有根树 $A$ 和 $B$ 满足以下条件，则称它们是**结构相同**的：\n- 节点数 $S$ 相同；\n- 存在一种对 $A$ 和 $B$ 的节点分别从 1 到 $S$ 的标号方式，使得：\n  - 它们的根节点标号相同；\n  - $A$ 中标号为 $x$ 和 $y$ 的节点之间有边当且仅当 $B$ 中标号为 $x$ 和 $y$ 的节点之间有边。\n\n否则，$A$ 和 $B$ 被视为**结构不同**。", "inputFormat": "第一行输入包含两个以空格分隔的整数 $N$ 和 $M$。\n\n接下来的 $N - 1$ 行，每行包含两个以空格分隔的整数 $u_i$ 和 $v_i$（$1 \\leq u_i, v_i \\leq N$，$u_i \\neq v_i$），表示 $T$ 中连接节点 $u_i$ 和 $v_i$ 的一条边。\n", "outputFormat": "输出可能的初始树 $D$ 的数量（结构不同的树视为不同情况）。\n", "hint": "**样例 1 解释**\n\n可以证明，唯一可能的 $D$ 如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/prs3i0ia.png)\n\n通过以下方式可以得到 $T$：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/es4cbjcu.png)\n\n上图中，红色部分为添加的装饰，绿色填充部分表示 $T$ 的初始状态，虚线表示连接装饰品的边。\n\n**样例 2 解释**\n\n第一种可能的 $D$：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xn2gjm2q.png)\n\n通过以下方式可以得到 $T$：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yu3ac03q.png)\n\n第二种可能的 $D$：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/d7m3kjgj.png)\n\n通过以下方式可以得到 $T$：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7lulazk0.png)\n\n以下表格展示了 25 分的分布情况：\n\n| 分值   | $N$ 的范围          | $M$ 的范围          |\n|:------:|:-------------------:|:-------------------:|\n| 2 分   | $2 \\leq N \\leq 10$  | $M = 1$             |\n| 3 分   | $2 \\leq N \\leq 200$ | $M = 1$             |\n| 2 分   | $2 \\leq N \\leq 500000$ | $M = 1$          |\n| 6 分   | $2 \\leq N \\leq 200$ | $1 \\leq M < N$      |\n| 4 分   | $2 \\leq N \\leq 2000$ | $1 \\leq M < N$     |\n| 8 分   | $2 \\leq N \\leq 500000$ | $1 \\leq M < N$  |\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12968", "type": "P", "difficulty": 7, "samples": [["4 100", "141"], ["7 10000000000", "16926961207710"]], "limits": {"time": [30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2025", "CCO（加拿大）"], "title": "[CCO 2025] Balanced Integer", "background": "**Abusing judging resources leads to an account ban.**\n\nYou can self-test the first three test cases of each Subtask at the link: https://www.luogu.com.cn/problem/U576602 to avoid long judging wait times.", "description": "Since the CCO often uses integers, Alice needs to learn about the integers! A positive integer $n$ can be written in base $b$ as the sequence $d_{m-1}d_{m-2} \\ldots d_{1}d_{0}$ if the following hold:\n\n- Each digit $d_{i}$ is between 0 and $b-1$, inclusive.\n- $d_{m-1}>0$.\n- $n=d_{m-1} \\times b^{m-1}+d_{m-2} \\times b^{m-2}+\\cdots+d_{1} \\times b^{1}+d_{0} \\times b^{0}$.\n\n\nFor example, the integer 2025 in base 19 is the sequence $(5,11,11)$ because $2025=5 \\times 19^{2}+11 \\times 19^{1}+11 \\times 19^{0}$.\n\nAn integer $n$ is $b$-balanced if, when $n$ is written in base $b$, the average of the digits is $\\frac{b-1}{2}$. For example, 2025 is 19-balanced because $\\frac{5+11+11}{3}=9=\\frac{19-1}{2}$.\n\nAlice can easily find integers that are 19-balanced. However, she has trouble finding integers that are balanced in multiple ways. Given $B$ and $N$, please help Alice find the minimum integer $x$ such that:\n\n- $x$ is $b$-balanced, for all $2 \\leq b \\leq B$.\n- $x \\geq N$.", "inputFormat": "The first line of input contains two space-separated integers $B$ and $N$ ($N \\geq 1$).\n\nIt is guaranteed that the answer does not exceed $10^{18}$.", "outputFormat": "Output the minimum integer $x$ from the problem statement.", "hint": "**Sample 1 Explanation**\n\n$141$ in base $2$ is $10001101$. The average digit is\n\n$$\\frac{1+0+0+0+1+1+0+1}{8}=0.5=\\frac{2-1}{2}.$$\n\nTherefore, $141$ is 2-balanced.\n\n$141$ in base 3 is $12020$. The average digit is\n\n$$\\frac{1+2+0+2+0}{5}=1=\\frac{3-1}{2}.$$\n\nTherefore, $141$ is 3-balanced.\n\n$141$ in base 4 is $2031$. The average digit is\n\n$$\\frac{2+0+3+1}{4}=1.5=\\frac{4-1}{2}.$$\n\nTherefore, $141$ is 4-balanced.\n\nLastly, $141 \\geq 100$.\n\nFeel free to use these code snippets as part of your solution.\n\n```cpp\n// Important: If x is 0, the result is undefined.\nint base_2_length(unsigned long long x) {\n  return 64-__builtin_clzll(x);\n}\n\nint base_2_sum(unsigned long long x) {\n  return __builtin_popcountll(x);\n}\n```\n\nThe following table shows how the available $25$ marks are distributed:\n\n| Marks Awarded | Bounds on $B$ | Bounds on $N$ |\n| :---: | :---: | :---: |\n| 2 marks | $2 \\leq B \\leq 7$ | $1 \\leq N \\leq 10^{4}$ |\n| 6 marks | $2 \\leq B \\leq 6$ | $N = 10^{10}$ |\n| 2 marks | $2 \\leq B \\leq 7$ | None |\n| 9 marks | $8 \\leq B \\leq 11$ | $N = 1$ |\n| 4 marks | $B = 8$ | None |\n| 2 marks | $9 \\leq B \\leq 11$ | None |", "locale": "en", "translations": {"en": {"title": "[CCO 2025] Balanced Integer", "background": "**Abusing judging resources leads to an account ban.**\n\nYou can self-test the first three test cases of each Subtask at the link: https://www.luogu.com.cn/problem/U576602 to avoid long judging wait times.", "description": "Since the CCO often uses integers, Alice needs to learn about the integers! A positive integer $n$ can be written in base $b$ as the sequence $d_{m-1}d_{m-2} \\ldots d_{1}d_{0}$ if the following hold:\n\n- Each digit $d_{i}$ is between 0 and $b-1$, inclusive.\n- $d_{m-1}>0$.\n- $n=d_{m-1} \\times b^{m-1}+d_{m-2} \\times b^{m-2}+\\cdots+d_{1} \\times b^{1}+d_{0} \\times b^{0}$.\n\n\nFor example, the integer 2025 in base 19 is the sequence $(5,11,11)$ because $2025=5 \\times 19^{2}+11 \\times 19^{1}+11 \\times 19^{0}$.\n\nAn integer $n$ is $b$-balanced if, when $n$ is written in base $b$, the average of the digits is $\\frac{b-1}{2}$. For example, 2025 is 19-balanced because $\\frac{5+11+11}{3}=9=\\frac{19-1}{2}$.\n\nAlice can easily find integers that are 19-balanced. However, she has trouble finding integers that are balanced in multiple ways. Given $B$ and $N$, please help Alice find the minimum integer $x$ such that:\n\n- $x$ is $b$-balanced, for all $2 \\leq b \\leq B$.\n- $x \\geq N$.", "inputFormat": "The first line of input contains two space-separated integers $B$ and $N$ ($N \\geq 1$).\n\nIt is guaranteed that the answer does not exceed $10^{18}$.", "outputFormat": "Output the minimum integer $x$ from the problem statement.", "hint": "**Sample 1 Explanation**\n\n$141$ in base $2$ is $10001101$. The average digit is\n\n$$\\frac{1+0+0+0+1+1+0+1}{8}=0.5=\\frac{2-1}{2}.$$\n\nTherefore, $141$ is 2-balanced.\n\n$141$ in base 3 is $12020$. The average digit is\n\n$$\\frac{1+2+0+2+0}{5}=1=\\frac{3-1}{2}.$$\n\nTherefore, $141$ is 3-balanced.\n\n$141$ in base 4 is $2031$. The average digit is\n\n$$\\frac{2+0+3+1}{4}=1.5=\\frac{4-1}{2}.$$\n\nTherefore, $141$ is 4-balanced.\n\nLastly, $141 \\geq 100$.\n\nFeel free to use these code snippets as part of your solution.\n\n```cpp\n// Important: If x is 0, the result is undefined.\nint base_2_length(unsigned long long x) {\n  return 64-__builtin_clzll(x);\n}\n\nint base_2_sum(unsigned long long x) {\n  return __builtin_popcountll(x);\n}\n```\n\nThe following table shows how the available $25$ marks are distributed:\n\n| Marks Awarded | Bounds on $B$ | Bounds on $N$ |\n| :---: | :---: | :---: |\n| 2 marks | $2 \\leq B \\leq 7$ | $1 \\leq N \\leq 10^{4}$ |\n| 6 marks | $2 \\leq B \\leq 6$ | $N = 10^{10}$ |\n| 2 marks | $2 \\leq B \\leq 7$ | None |\n| 9 marks | $8 \\leq B \\leq 11$ | $N = 1$ |\n| 4 marks | $B = 8$ | None |\n| 2 marks | $9 \\leq B \\leq 11$ | None |", "locale": "en"}, "zh-CN": {"title": "[CCO 2025] Balanced Integer", "background": "滥用评测资源的行为将直接被封号。\n\n可在链接：<https://www.luogu.com.cn/problem/U576602> 自测每个 Subtask 的前三个测试点，避免评测等待过长时间。", "description": "由于 **CCO** 经常使用整数，**Alice** 需要学习关于整数的知识！一个正整数 $n$ 可以用基数为 $b$ 的数字序列 $d_{m-1}d_{m-2} \\ldots d_{1}d_{0}$ 表示，当且仅当满足以下条件：\n\n- 每个数字 $d_{i}$ 都在 $0$ 到 $b-1$ 之间（包含边界）。\n- $d_{m-1} > 0$。\n- $n = d_{m-1} \\times b^{m-1} + d_{m-2} \\times b^{m-2} + \\cdots + d_{1} \\times b^{1} + d_{0} \\times b^{0}$。\n\n例如，整数 $2025$ 在基数为 $19$ 时可以表示为序列 $(5,11,11)$，因为 $2025 = 5 \\times 19^{2} + 11 \\times 19^{1} + 11 \\times 19^{0}$。\n\n如果一个整数 $n$ 在基数为 $b$ 时，其各位数字的平均值等于 $\\frac{b-1}{2}$，则称 $n$ 是 **$b$-平衡** 的。例如，$2025$ 是 **19-平衡** 的，因为 $\\frac{5 + 11 + 11}{3} = 9 = \\frac{19 - 1}{2}$。\n\n**Alice** 可以轻松找到 **19-平衡** 的整数，但她难以找到同时在多个基数下平衡的整数。给定 $B$ 和 $N$，请帮助 **Alice** 找到最小的整数 $x$，满足以下条件：\n\n- $x$ 在 **所有** $2 \\leq b \\leq B$ 的基数下都是 $b$-平衡的。\n- $x \\geq N$。", "inputFormat": "第一行输入包含两个以空格分隔的整数 $B$ 和 $N$（$N \\geq 1$）。\n\n保证答案不超过 $10^{18}$。", "outputFormat": "输出题目描述中所要求的最小整数 $x$。", "hint": "**样例 1 解释**\n\n$141$ 在基数为 $2$ 时表示为 $10001101$，各位数字的平均值为：\n\n$$\\frac{1 + 0 + 0 + 0 + 1 + 1 + 0 + 1}{8} = 0.5 = \\frac{2 - 1}{2}.$$\n\n因此，$141$ 是 **2-平衡** 的。\n\n$141$ 在基数为 $3$ 时表示为 $12020$，各位数字的平均值为：\n\n$$\\frac{1 + 2 + 0 + 2 + 0}{5} = 1 = \\frac{3 - 1}{2}.$$\n\n因此，$141$ 是 **3-平衡** 的。\n\n$141$ 在基数为 $4$ 时表示为 $2031$，各位数字的平均值为：\n\n$$\\frac{2 + 0 + 3 + 1}{4} = 1.5 = \\frac{4 - 1}{2}.$$\n\n因此，$141$ 是 **4-平衡** 的。\n\n最后，$141 \\geq 100$。\n\n你可以在解题时使用以下代码片段：\n\n```cpp\n// 注意：如果 x 为 0，结果未定义。\nint base_2_length(unsigned long long x) {\n  return 64 - __builtin_clzll(x);\n}\n\nint base_2_sum(unsigned long long x) {\n  return __builtin_popcountll(x);\n}\n```\n\n| 分值   | $B$ 的范围         | $N$ 的范围             |\n|:------:|:------------------:|:----------------------:|\n| 2 分   | $2 \\leq B \\leq 7$  | $1 \\leq N \\leq 10^4$   |\n| 6 分   | $2 \\leq B \\leq 6$  | $N = 10^{10}$          |\n| 2 分   | $2 \\leq B \\leq 7$  | 无限制                 |\n| 9 分   | $8 \\leq B \\leq 11$ | $N = 1$                |\n| 4 分   | $B = 8$            | 无限制                 |\n| 2 分   | $9 \\leq B \\leq 11$ | 无限制                 |", "locale": "zh-CN"}}}
{"pid": "P12969", "type": "P", "difficulty": 6, "samples": [["5 3\n1 2 0 0 1\n0 2\n1 3\n3 2", "1 4\n1 1\n1 2\n1 2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["线段树", "2025", "CCO（加拿大）"], "title": "[CCO 2025] Restaurant Recommendation Rescue", "background": "", "description": "A certain aspiring musician K loves going for shabu-shabu! Recently, she's been to $N$ shabu-shabu restaurants, numbered $1, 2, \\ldots, N$, following the following algorithm:\n\n1. K keeps an ordered list of recommendations, starting with restaurant 1.\n2. On the $i$-th day, she visits the next recommended restaurant on her list, which recommends her restaurants $R_i = \\{r_{i,1}, \\ldots, r_{i,l_i}\\}$.\n3. K appends $R_i$ to her list of restaurants to visit.\n4. K repeats steps 2-4 until she runs out of recommended restaurants.\n5. K writes down the array $A_0, \\ldots, A_{N-1}$, where $A_i$ equals the number of restaurants she was recommended on the $(i+1)$-th day. That is, $A_i = |R_{i+1}|$.\n\nIt is guaranteed that $\\bigcup_{i=1}^{N} R_i = \\{2, \\ldots, N\\}$ and $R_i \\cap R_j = \\emptyset$ for $i \\neq j$, that is, every restaurant, other than the first, will be recommended by exactly one other restaurant.\n\nOnce K finishes her list, K's delinquent friend H decides to play a prank on her! She replaces the array $A_0, \\ldots, A_{N-1}$ with another array $B_0, \\ldots, B_{N-1}$! K thinks that this new array $B_i$ might just be a cyclic shift of her array, so she asks you to determine all possible $0 \\leq k < N$ such that $A_i = B_{(i+k) \\bmod N}$, for all $0 \\leq i < N$ and any valid output of her algorithm $A_0, \\ldots, A_{N-1}$.\n\nFurthermore, K will then perform $Q$ operations, where for the $i$-th operation, she swaps $B_{x_i}, B_{y_i}$ and asks you to do the same on the new array. Can you help K see through her friend's prank?", "inputFormat": "The first line of input will contain two integers, $N$ ($1 \\leq N \\leq 500\\,000$) and $Q$ ($0 \\leq Q \\leq 300\\,000$).\n\nThe next line of input will contain $N$ space-separated non-negative integers, $B_0, B_1, \\ldots, B_{N-1}$ ($0 \\leq B_i < N$), the initial sequence.\n\nThe $i$-th of the next $Q$ lines of input will contain two integers each, $x_i$ and $y_i$ ($0 \\leq x_i, y_i < N$ and $x_i \\neq y_i$), indicating you are to swap $B_{x_i}$ with $B_{y_i}$.", "outputFormat": "For each of the $Q + 1$ arrays (including the initial array $B_0, \\ldots, B_{N-1}$), let $S = \\{k_1, \\ldots, k_m\\}$ denote the set of integers $0 \\leq k_j < N$ such that there exists a valid output $A_0, \\ldots, A_{N-1}$ of K's algorithm such that $A_i = B_{(i + k_j) \\bmod N}$ for all $0 \\leq i < N$. Output, on a single line, the integers $m$ and $\\sum_{i=1}^{m} k_i \\pmod{998\\,244\\,353}$, separated by a space.\n\nIn particular, if $S = \\emptyset$, your output should be `0 0`.", "hint": "**Sample 1 Explanation**\n\nThe array $A$ is $[1, 1, 2, 0, 0]$; it can be shown this is the only valid output of K's algorithm that corresponds to the array $B = [1, 2, 0, 0, 1]$. One input for K's algorithm that yields this array $A$ is:\n\n$\\begin{aligned} R_1 &= \\{2\\} \\\\ R_2 &= \\{3\\} \\\\ R_3 &= \\{4, 5\\} \\\\ R_4 &= \\varnothing \\\\ R_5 &= \\varnothing. \\end{aligned}$\n\nAfter swapping $B_0$ and $B_2$, we get the array\n\n$B = [0, 2, 1, 0, 1].$\n\nIt can be shown the only valid output of K's algorithm that corresponds to this is\n\n$A = [2, 1, 0, 1, 0].$\n\nOne possible input to K's algorithm that yields this array $A$ is\n\n$\\begin{aligned} R_1 &= \\{2, 3\\} \\\\ R_2 &= \\{4\\} \\\\ R_3 &= \\varnothing \\\\ R_4 &= \\{5\\} \\\\ R_5 &= \\varnothing. \\end{aligned}$\n\nThe following table shows how the available $25$ marks are distributed:\n\n| Marks Awarded | Bounds on $N$ | Bounds on $Q$ |\n|:---------------:|:----------------:|:----------------:|\n| 3 marks       | $1 \\leq N \\leq 8$ | $Q = 0$        |\n| 7 marks       | $1 \\leq N \\leq 5\\,000$ | $Q = 0$        |\n| 10 marks      | $1 \\leq N \\leq 500\\,000$ | $Q = 0$        |\n| 5 marks       | $1 \\leq N \\leq 500\\,000$ | $0 \\leq Q \\leq 300\\,000$ |", "locale": "en", "translations": {"en": {"title": "[CCO 2025] Restaurant Recommendation Rescue", "background": "", "description": "A certain aspiring musician K loves going for shabu-shabu! Recently, she's been to $N$ shabu-shabu restaurants, numbered $1, 2, \\ldots, N$, following the following algorithm:\n\n1. K keeps an ordered list of recommendations, starting with restaurant 1.\n2. On the $i$-th day, she visits the next recommended restaurant on her list, which recommends her restaurants $R_i = \\{r_{i,1}, \\ldots, r_{i,l_i}\\}$.\n3. K appends $R_i$ to her list of restaurants to visit.\n4. K repeats steps 2-4 until she runs out of recommended restaurants.\n5. K writes down the array $A_0, \\ldots, A_{N-1}$, where $A_i$ equals the number of restaurants she was recommended on the $(i+1)$-th day. That is, $A_i = |R_{i+1}|$.\n\nIt is guaranteed that $\\bigcup_{i=1}^{N} R_i = \\{2, \\ldots, N\\}$ and $R_i \\cap R_j = \\emptyset$ for $i \\neq j$, that is, every restaurant, other than the first, will be recommended by exactly one other restaurant.\n\nOnce K finishes her list, K's delinquent friend H decides to play a prank on her! She replaces the array $A_0, \\ldots, A_{N-1}$ with another array $B_0, \\ldots, B_{N-1}$! K thinks that this new array $B_i$ might just be a cyclic shift of her array, so she asks you to determine all possible $0 \\leq k < N$ such that $A_i = B_{(i+k) \\bmod N}$, for all $0 \\leq i < N$ and any valid output of her algorithm $A_0, \\ldots, A_{N-1}$.\n\nFurthermore, K will then perform $Q$ operations, where for the $i$-th operation, she swaps $B_{x_i}, B_{y_i}$ and asks you to do the same on the new array. Can you help K see through her friend's prank?", "inputFormat": "The first line of input will contain two integers, $N$ ($1 \\leq N \\leq 500\\,000$) and $Q$ ($0 \\leq Q \\leq 300\\,000$).\n\nThe next line of input will contain $N$ space-separated non-negative integers, $B_0, B_1, \\ldots, B_{N-1}$ ($0 \\leq B_i < N$), the initial sequence.\n\nThe $i$-th of the next $Q$ lines of input will contain two integers each, $x_i$ and $y_i$ ($0 \\leq x_i, y_i < N$ and $x_i \\neq y_i$), indicating you are to swap $B_{x_i}$ with $B_{y_i}$.", "outputFormat": "For each of the $Q + 1$ arrays (including the initial array $B_0, \\ldots, B_{N-1}$), let $S = \\{k_1, \\ldots, k_m\\}$ denote the set of integers $0 \\leq k_j < N$ such that there exists a valid output $A_0, \\ldots, A_{N-1}$ of K's algorithm such that $A_i = B_{(i + k_j) \\bmod N}$ for all $0 \\leq i < N$. Output, on a single line, the integers $m$ and $\\sum_{i=1}^{m} k_i \\pmod{998\\,244\\,353}$, separated by a space.\n\nIn particular, if $S = \\emptyset$, your output should be `0 0`.", "hint": "**Sample 1 Explanation**\n\nThe array $A$ is $[1, 1, 2, 0, 0]$; it can be shown this is the only valid output of K's algorithm that corresponds to the array $B = [1, 2, 0, 0, 1]$. One input for K's algorithm that yields this array $A$ is:\n\n$\\begin{aligned} R_1 &= \\{2\\} \\\\ R_2 &= \\{3\\} \\\\ R_3 &= \\{4, 5\\} \\\\ R_4 &= \\varnothing \\\\ R_5 &= \\varnothing. \\end{aligned}$\n\nAfter swapping $B_0$ and $B_2$, we get the array\n\n$B = [0, 2, 1, 0, 1].$\n\nIt can be shown the only valid output of K's algorithm that corresponds to this is\n\n$A = [2, 1, 0, 1, 0].$\n\nOne possible input to K's algorithm that yields this array $A$ is\n\n$\\begin{aligned} R_1 &= \\{2, 3\\} \\\\ R_2 &= \\{4\\} \\\\ R_3 &= \\varnothing \\\\ R_4 &= \\{5\\} \\\\ R_5 &= \\varnothing. \\end{aligned}$\n\nThe following table shows how the available $25$ marks are distributed:\n\n| Marks Awarded | Bounds on $N$ | Bounds on $Q$ |\n|:---------------:|:----------------:|:----------------:|\n| 3 marks       | $1 \\leq N \\leq 8$ | $Q = 0$        |\n| 7 marks       | $1 \\leq N \\leq 5\\,000$ | $Q = 0$        |\n| 10 marks      | $1 \\leq N \\leq 500\\,000$ | $Q = 0$        |\n| 5 marks       | $1 \\leq N \\leq 500\\,000$ | $0 \\leq Q \\leq 300\\,000$ |", "locale": "en"}, "zh-CN": {"title": "[CCO 2025] Restaurant Recommendation Rescue", "background": "", "description": "一位有抱负的音乐家 **K** 非常喜欢吃涮涮锅！最近，她按照以下算法光顾了编号为 $1, 2, \\ldots, N$ 的 $N$ 家涮涮锅餐厅：\n\n1. **K** 维护一个有序的推荐列表，初始时仅包含餐厅 1。\n2. 在第 $i$ 天，她访问列表中下一个被推荐的餐厅，该餐厅会向她推荐餐厅集合 $R_i = \\{r_{i,1}, \\ldots, r_{i,l_i}\\}$。\n3. **K** 将 $R_i$ 追加到她的待访问餐厅列表中。\n4. **K** 重复步骤 2-4，直到没有更多推荐餐厅为止。\n5. **K** 记录数组 $A_0, \\ldots, A_{N-1}$，其中 $A_i$ 表示第 $(i+1)$ 天她被推荐的餐厅数量，即 $A_i = |R_{i+1}|$。\n\n题目保证 $\\bigcup_{i=1}^{N} R_i = \\{2, \\ldots, N\\}$ 且 $R_i \\cap R_j = \\emptyset$（$i \\neq j$），即除了第一家餐厅外，每家餐厅恰好被另一家餐厅推荐一次。\n\n当 **K** 完成列表后，她的捣蛋朋友 **H** 决定捉弄她！**H** 将数组 $A_0, \\ldots, A_{N-1}$ 替换为另一个数组 $B_0, \\ldots, B_{N-1}$！**K** 认为这个新数组 $B_i$ 可能是她的数组的循环移位，因此她请你找出所有可能的 $0 \\leq k < N$，使得对于所有 $0 \\leq i < N$ 和任意合法的算法输出 $A_0, \\ldots, A_{N-1}$，满足 $A_i = B_{(i+k) \\bmod N}$。\n\n此外，**K** 还会执行 $Q$ 次操作，其中第 $i$ 次操作会交换 $B_{x_i}$ 和 $B_{y_i}$，并要求你对新数组执行相同的计算。你能帮 **K** 识破朋友的恶作剧吗？", "inputFormat": "第一行输入包含两个整数 $N$（$1 \\leq N \\leq 500\\,000$）和 $Q$（$0 \\leq Q \\leq 300\\,000$）。\n\n第二行输入包含 $N$ 个以空格分隔的非负整数 $B_0, B_1, \\ldots, B_{N-1}$（$0 \\leq B_i < N$），表示初始序列。\n\n接下来的 $Q$ 行每行包含两个整数 $x_i$ 和 $y_i$（$0 \\leq x_i, y_i < N$ 且 $x_i \\neq y_i$），表示交换 $B_{x_i}$ 和 $B_{y_i}$。\n", "outputFormat": "对于每个 $Q + 1$ 个数组（包括初始数组 $B_0, \\ldots, B_{N-1}$），设 $S = \\{k_1, \\ldots, k_m\\}$ 表示所有满足条件的整数 $0 \\leq k_j < N$ 的集合，其中存在一个合法的算法输出 $A_0, \\ldots, A_{N-1}$，使得对于所有 $0 \\leq i < N$ 有 $A_i = B_{(i + k_j) \\bmod N}$。在一行中输出两个整数 $m$ 和 $\\sum_{i=1}^{m} k_i \\pmod{998\\,244\\,353}$，以空格分隔。\n\n特别地，如果 $S = \\emptyset$，则输出 `0 0`。", "hint": "**样例 1 解释**\n\n数组 $A$ 为 $[1, 1, 2, 0, 0]$；可以证明这是唯一对应 $B = [1, 2, 0, 0, 1]$ 的合法算法输出。一种可能的算法输入如下：\n\n$\\begin{aligned} R_1 &= \\{2\\} \\\\ R_2 &= \\{3\\} \\\\ R_3 &= \\{4, 5\\} \\\\ R_4 &= \\varnothing \\\\ R_5 &= \\varnothing. \\end{aligned}$\n\n交换 $B_0$ 和 $B_2$ 后，得到数组\n\n$B = [0, 2, 1, 0, 1].$\n\n可以证明唯一对应此数组的合法算法输出为\n\n$A = [2, 1, 0, 1, 0].$\n\n一种可能的算法输入如下：\n\n$\\begin{aligned} R_1 &= \\{2, 3\\} \\\\ R_2 &= \\{4\\} \\\\ R_3 &= \\varnothing \\\\ R_4 &= \\{5\\} \\\\ R_5 &= \\varnothing. \\end{aligned}$\n\n以下表格展示了 25 分的分布情况：\n\n| 分值   | $N$ 的范围          | $Q$ 的范围              |\n|:------:|:-------------------:|:-----------------------:|\n| 3 分   | $1 \\leq N \\leq 8$   | $Q = 0$                |\n| 7 分   | $1 \\leq N \\leq 5\\,000$ | $Q = 0$              |\n| 10 分  | $1 \\leq N \\leq 500\\,000$ | $Q = 0$          |\n| 5 分   | $1 \\leq N \\leq 500\\,000$ | $0 \\leq Q \\leq 300\\,000$ |\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12970", "type": "P", "difficulty": 7, "samples": [["4\n0 0\n1 1\n1 2\n2 1", "3\n1 2\n2 3\n2 4"], ["8\n0 0\n0 3\n1 1\n1 2\n4 1\n4 2\n5 0\n5 3", "9\n1 2\n2 4\n4 8\n8 7\n7 5\n5 1\n3 4\n4 5\n5 6"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2025", "Special Judge", "CCO（加拿大）"], "title": "[CCO 2025] Patrol Robot", "background": "", "description": "The Coordinate Control Organization has developed an autonomous robot to patrol $N$ distinct important locations on a two-dimensional plane. The $i$-th location has coordinates $(x_i, y_i)$, and it is guaranteed that no three locations lie on a common line.\n\nTo help guide the robot, you may paint some line segments on the ground. Each segment must directly connect two important locations, and no two segments may intersect, except possibly at their endpoints.\n\nThe robot will begin its patrol at the midpoint of an arbitrary segment, facing towards one of its endpoints. It will move indefinitely according to the following procedure:\n\n- As long as the robot is in the interior of a segment, it will move forward, towards a segment endpoint.\n- When the robot reaches an important location, it will initially be facing directly away from the segment it just traversed. The robot will turn right/clockwise until its line of vision is aligned with a segment that leads away from the current location. The robot will then begin moving along this new segment.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ltjemrp6.png)\n\nYour task is to paint the segments in such a way that, no matter where the robot starts, it is guaranteed to visit every important location infinitely often. It can be proven that this is always possible.", "inputFormat": "The first line of input contains a single integer $N (2 \\leq N \\leq 2000)$, the number of important locations.\n\nThe next $N$ lines of input each contain two space-separated integers, $x_i$ and $y_i$ ($-10^9 \\leq x_i, y_i \\leq 10^9$), the coordinates of the $i$-th important location.\n\nIt is guaranteed that all $N$ important locations are distinct and no three lie on a common line.", "outputFormat": "On the first line, output a positive integer $M$, the number of line segments you paint on the ground.\n\nThe next $M$ lines of output should each contain two space-separated integers, $u_i$ and $v_i$ ($1 \\leq u_i, v_i \\leq N$, $u_i \\neq v_i$), denoting that you paint a line segment between the $u_i$-th and $v_i$-th important locations.\n\nIf there are multiple acceptable answers, output any of them.", "hint": "**Sample 1 Explanation**\n\nThe important locations and painted segments are shown in the following figure:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/y6azp4y5.png)\n\nNo matter where the robot starts, it will visit every important location infinitely many times. For example, if the robot starts in the middle of the segment between locations $1$ and $2$, facing towards location $2$, the locations the robot will visit in order are:\n\n$$2, 4, 2, 3, 2, 1, 2, 4, \\ldots,$$\n\nwhere the underlined portion is repeated infinitely.\n\n**Sample 2 Explanation**\n\nThe important locations and painted segments are shown in the following figure:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p2yj86fu.png)\n\nNo matter where the robot starts, it will visit every important location infinitely many times. For example, if the robot starts in the middle of the segment between locations $4$ and $5$, facing towards location $5$, the locations the robot will visit in order are:\n\n$$5, 7, 5, 6, 5, 1, 2, 4, 3, 4, 8, 7, 5, \\ldots,$$\n\nwhere the underlined portion is repeated infinitely. Note that it is not necessary for every segment to be traversed infinitely many times; the solution is valid as long as every location is visited infinitely many times.\n\nThe following table shows how the available 25 marks are distributed:\n\n| Marks Awarded | Additional Constraints |\n|:---------------:|:------------------------:|\n| 2 marks       | $2 \\leq N \\leq 4$      |\n| 4 marks       | $2 \\leq N \\leq 8$      |\n| 3 marks       | $3 \\leq N$ and the $N$ points are the vertices of a convex polygon in some order. |\n| 7 marks       | The $N$ points form a convex polygon with $N-1$ vertices plus an additional point inside the polygon. |\n| 9 marks       | None                   |", "locale": "en", "translations": {"en": {"title": "[CCO 2025] Patrol Robot", "background": "", "description": "The Coordinate Control Organization has developed an autonomous robot to patrol $N$ distinct important locations on a two-dimensional plane. The $i$-th location has coordinates $(x_i, y_i)$, and it is guaranteed that no three locations lie on a common line.\n\nTo help guide the robot, you may paint some line segments on the ground. Each segment must directly connect two important locations, and no two segments may intersect, except possibly at their endpoints.\n\nThe robot will begin its patrol at the midpoint of an arbitrary segment, facing towards one of its endpoints. It will move indefinitely according to the following procedure:\n\n- As long as the robot is in the interior of a segment, it will move forward, towards a segment endpoint.\n- When the robot reaches an important location, it will initially be facing directly away from the segment it just traversed. The robot will turn right/clockwise until its line of vision is aligned with a segment that leads away from the current location. The robot will then begin moving along this new segment.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ltjemrp6.png)\n\nYour task is to paint the segments in such a way that, no matter where the robot starts, it is guaranteed to visit every important location infinitely often. It can be proven that this is always possible.", "inputFormat": "The first line of input contains a single integer $N (2 \\leq N \\leq 2000)$, the number of important locations.\n\nThe next $N$ lines of input each contain two space-separated integers, $x_i$ and $y_i$ ($-10^9 \\leq x_i, y_i \\leq 10^9$), the coordinates of the $i$-th important location.\n\nIt is guaranteed that all $N$ important locations are distinct and no three lie on a common line.", "outputFormat": "On the first line, output a positive integer $M$, the number of line segments you paint on the ground.\n\nThe next $M$ lines of output should each contain two space-separated integers, $u_i$ and $v_i$ ($1 \\leq u_i, v_i \\leq N$, $u_i \\neq v_i$), denoting that you paint a line segment between the $u_i$-th and $v_i$-th important locations.\n\nIf there are multiple acceptable answers, output any of them.", "hint": "**Sample 1 Explanation**\n\nThe important locations and painted segments are shown in the following figure:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/y6azp4y5.png)\n\nNo matter where the robot starts, it will visit every important location infinitely many times. For example, if the robot starts in the middle of the segment between locations $1$ and $2$, facing towards location $2$, the locations the robot will visit in order are:\n\n$$2, 4, 2, 3, 2, 1, 2, 4, \\ldots,$$\n\nwhere the underlined portion is repeated infinitely.\n\n**Sample 2 Explanation**\n\nThe important locations and painted segments are shown in the following figure:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p2yj86fu.png)\n\nNo matter where the robot starts, it will visit every important location infinitely many times. For example, if the robot starts in the middle of the segment between locations $4$ and $5$, facing towards location $5$, the locations the robot will visit in order are:\n\n$$5, 7, 5, 6, 5, 1, 2, 4, 3, 4, 8, 7, 5, \\ldots,$$\n\nwhere the underlined portion is repeated infinitely. Note that it is not necessary for every segment to be traversed infinitely many times; the solution is valid as long as every location is visited infinitely many times.\n\nThe following table shows how the available 25 marks are distributed:\n\n| Marks Awarded | Additional Constraints |\n|:---------------:|:------------------------:|\n| 2 marks       | $2 \\leq N \\leq 4$      |\n| 4 marks       | $2 \\leq N \\leq 8$      |\n| 3 marks       | $3 \\leq N$ and the $N$ points are the vertices of a convex polygon in some order. |\n| 7 marks       | The $N$ points form a convex polygon with $N-1$ vertices plus an additional point inside the polygon. |\n| 9 marks       | None                   |", "locale": "en"}, "zh-CN": {"title": "[CCO 2025] Patrol Robot", "background": "Checker 来自 [LibreOJ](https://loj.ac/p/5143)。", "description": "坐标控制组织（**Coordinate Control Organization**）开发了一款自主机器人，用于在二维平面上巡逻 $N$ 个不同的重要地点。第 $i$ 个地点的坐标为 $(x_i, y_i)$，且保证任意三个地点不共线。\n\n为了引导机器人巡逻，你可以在地面上绘制一些线段。每条线段必须直接连接两个重要地点，且任意两条线段不能相交（端点处除外）。\n\n机器人将从任意一条线段的中点开始巡逻，初始朝向该线段的某一端点。它将按照以下规则无限移动：\n\n- 只要机器人位于某条线段的内部，它就会向前移动，朝线段的一个端点前进。\n- 当机器人到达一个重要地点时，它最初会背向刚刚经过的线段。机器人将向右（顺时针）旋转，直到视线与一条从当前地点出发的线段对齐，然后开始沿这条新线段移动。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ltjemrp6.png)\n\n你的任务是绘制这些线段，使得无论机器人从何处开始，都能保证无限次访问每一个重要地点。可以证明这总是可行的。", "inputFormat": "第一行输入一个整数 $N$（$2 \\leq N \\leq 2000$），表示重要地点的数量。\n\n接下来的 $N$ 行每行包含两个以空格分隔的整数 $x_i$ 和 $y_i$（$-10^9 \\leq x_i, y_i \\leq 10^9$），表示第 $i$ 个重要地点的坐标。\n\n保证所有 $N$ 个重要地点互不相同，且任意三点不共线。", "outputFormat": "第一行输出一个正整数 $M$，表示你绘制的线段数量。\n\n接下来的 $M$ 行每行包含两个以空格分隔的整数 $u_i$ 和 $v_i$（$1 \\leq u_i, v_i \\leq N$，$u_i \\neq v_i$），表示你在第 $u_i$ 个和第 $v_i$ 个重要地点之间绘制了一条线段。\n\n如果有多种可行解，输出其中任意一种即可。", "hint": "**样例 1 解释**\n\n重要地点及绘制的线段如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/y6azp4y5.png)\n\n无论机器人从何处开始，它都会无限次访问每一个重要地点。例如，如果机器人从地点 $1$ 和 $2$ 之间的线段中点开始，朝向地点 $2$，则机器人访问地点的顺序为：\n\n$$2, 4, 2, 3, 2, 1, 2, 4, \\ldots,$$\n\n其中下划线部分无限循环。\n\n**样例 2 解释**\n\n重要地点及绘制的线段如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p2yj86fu.png)\n\n无论机器人从何处开始，它都会无限次访问每一个重要地点。例如，如果机器人从地点 $4$ 和 $5$ 之间的线段中点开始，朝向地点 $5$，则机器人访问地点的顺序为：\n\n$$5, 7, 5, 6, 5, 1, 2, 4, 3, 4, 8, 7, 5, \\ldots,$$\n\n其中下划线部分无限循环。注意，并非所有线段都需要被无限次遍历，只要每个地点被无限次访问即可。\n\n以下表格展示了 25 分的分布情况：\n\n| 分值   | 额外约束条件                     |\n|:------:|:--------------------------------:|\n| 2 分   | $2 \\leq N \\leq 4$               |\n| 4 分   | $2 \\leq N \\leq 8$               |\n| 3 分   | $3 \\leq N$ 且所有 $N$ 个点按某种顺序构成凸多边形的顶点。 |\n| 7 分   | $N$ 个点构成一个 $N-1$ 个顶点的凸多边形，外加一个内部点。 |\n| 9 分   | 无额外约束                      |\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12971", "type": "P", "difficulty": 7, "samples": [["2 4\n1 1 3\n3 3 13\n0 0 2\n0 2 5\n2 0 4\n2 2 3", "12"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2025", "CCO（加拿大）"], "title": "[CCO 2025] Shopping Deals", "background": "", "description": "You are shopping from a store that sells a total of $M$ items. The store layout can be modelled as a two-dimensional plane, where the $i$-th item is located at the point $(x_i, y_i)$ and has a price of $p_i$.\n\nThe store offers $N$ shopping deals. The $i$-th shopping deal is specified by a point $(a_i, b_i)$, and for a cost of $c_i$, you can obtain one of every item within exactly one of the following four regions of your choice:\n\n- The region of points $(x, y)$ such that $x \\leq a_i$ and $y \\leq b_i$.\n- The region of points $(x, y)$ such that $x \\leq a_i$ and $y \\geq b_i$.\n- The region of points $(x, y)$ such that $x \\geq a_i$ and $y \\leq b_i$.\n- The region of points $(x, y)$ such that $x \\geq a_i$ and $y \\geq b_i$.\n\nEach shopping deal can only be used at most once. Items can also be purchased individually by paying their respective price $p_i$.\n\nYou want to obtain at least one of each item in the store. Find the minimum total cost you must pay to do so.", "inputFormat": "The first line of input contains two space-separated integers $N$ and $M$.\n\nThe next $N$ lines of input each contain three space-separated integers, $a_i$, $b_i$, and $c_i$ ($-10^9 \\leq a_i, b_i \\leq 10^9$, $1 \\leq c_i \\leq 10^9$).\n\nThe next $M$ lines of input each contain three space-separated integers, $x_i$, $y_i$, and $p_i$ ($-10^9 \\leq x_i, y_i \\leq 10^9$, $1 \\leq p_i \\leq 10^9$).", "outputFormat": "On a single line, output the minimum total cost that you must pay to obtain at least one of each item.", "hint": "**Sample 1 Explanation**\n\nUse the first shopping deal on the region $\\{(x, y) \\mid x \\leq 1, y \\geq 1\\}$ to obtain the second item. Then, purchase items 1, 3, and 4 individually. The total cost is $3 + (2 + 4 + 3) = 12$.\n\nThe following table shows how the available $25$ marks are distributed:\n\n| Marks Awarded | Bounds on $N$ | Bounds on $M$ | Additional Constraints |\n| :---: | :---: | :---: | :---: |\n| 1 mark | $1 \\leq N \\leq 8$ | $1 \\leq M \\leq 20$ | None |\n| 3 marks | $1 \\leq N \\leq 70$ | $1 \\leq M \\leq 20$ | None |\n| 3 marks | $1 \\leq N \\leq 70$ | $1 \\leq M \\leq 70$ | None |\n| 4 marks | $1 < N \\leq 100$ | $1 < M \\leq 100000$ | No two points $(a_i, b_i)$ or $(x_j, y_j)$ have the same $x$ or $y$-coordinate. |\n| 2 marks | $1 \\leq N \\leq 100$ | $1 \\leq M \\leq 100000$ | None |\n| 8 marks | $1 \\leq N \\leq 1000$ | $1 \\leq M \\leq 100000$ | No two points $(a_i, b_i)$ or $(x_j, y_j)$ have the same $x$ or $y$-coordinate. |\n| 4 marks | $1 \\leq N \\leq 1000$ | $1 \\leq M \\leq 100000$ | None |\n", "locale": "en", "translations": {"en": {"title": "[CCO 2025] Shopping Deals", "background": "", "description": "You are shopping from a store that sells a total of $M$ items. The store layout can be modelled as a two-dimensional plane, where the $i$-th item is located at the point $(x_i, y_i)$ and has a price of $p_i$.\n\nThe store offers $N$ shopping deals. The $i$-th shopping deal is specified by a point $(a_i, b_i)$, and for a cost of $c_i$, you can obtain one of every item within exactly one of the following four regions of your choice:\n\n- The region of points $(x, y)$ such that $x \\leq a_i$ and $y \\leq b_i$.\n- The region of points $(x, y)$ such that $x \\leq a_i$ and $y \\geq b_i$.\n- The region of points $(x, y)$ such that $x \\geq a_i$ and $y \\leq b_i$.\n- The region of points $(x, y)$ such that $x \\geq a_i$ and $y \\geq b_i$.\n\nEach shopping deal can only be used at most once. Items can also be purchased individually by paying their respective price $p_i$.\n\nYou want to obtain at least one of each item in the store. Find the minimum total cost you must pay to do so.", "inputFormat": "The first line of input contains two space-separated integers $N$ and $M$.\n\nThe next $N$ lines of input each contain three space-separated integers, $a_i$, $b_i$, and $c_i$ ($-10^9 \\leq a_i, b_i \\leq 10^9$, $1 \\leq c_i \\leq 10^9$).\n\nThe next $M$ lines of input each contain three space-separated integers, $x_i$, $y_i$, and $p_i$ ($-10^9 \\leq x_i, y_i \\leq 10^9$, $1 \\leq p_i \\leq 10^9$).", "outputFormat": "On a single line, output the minimum total cost that you must pay to obtain at least one of each item.", "hint": "**Sample 1 Explanation**\n\nUse the first shopping deal on the region $\\{(x, y) \\mid x \\leq 1, y \\geq 1\\}$ to obtain the second item. Then, purchase items 1, 3, and 4 individually. The total cost is $3 + (2 + 4 + 3) = 12$.\n\nThe following table shows how the available $25$ marks are distributed:\n\n| Marks Awarded | Bounds on $N$ | Bounds on $M$ | Additional Constraints |\n| :---: | :---: | :---: | :---: |\n| 1 mark | $1 \\leq N \\leq 8$ | $1 \\leq M \\leq 20$ | None |\n| 3 marks | $1 \\leq N \\leq 70$ | $1 \\leq M \\leq 20$ | None |\n| 3 marks | $1 \\leq N \\leq 70$ | $1 \\leq M \\leq 70$ | None |\n| 4 marks | $1 < N \\leq 100$ | $1 < M \\leq 100000$ | No two points $(a_i, b_i)$ or $(x_j, y_j)$ have the same $x$ or $y$-coordinate. |\n| 2 marks | $1 \\leq N \\leq 100$ | $1 \\leq M \\leq 100000$ | None |\n| 8 marks | $1 \\leq N \\leq 1000$ | $1 \\leq M \\leq 100000$ | No two points $(a_i, b_i)$ or $(x_j, y_j)$ have the same $x$ or $y$-coordinate. |\n| 4 marks | $1 \\leq N \\leq 1000$ | $1 \\leq M \\leq 100000$ | None |\n", "locale": "en"}, "zh-CN": {"title": "[CCO 2025] Shopping Deals", "background": "", "description": "你正在一家出售 $M$ 件商品的商店购物。商店的布局可以建模为一个二维平面，其中第 $i$ 件商品位于点 $(x_i, y_i)$，价格为 $p_i$。\n\n商店提供 $N$ 种购物优惠。第 $i$ 种购物优惠由点 $(a_i, b_i)$ 指定，花费 $c_i$ 的代价，你可以选择以下四个区域之一，获得该区域内所有商品各一件：\n\n- 满足 $x \\leq a_i$ 且 $y \\leq b_i$ 的点 $(x, y)$ 所在区域\n- 满足 $x \\leq a_i$ 且 $y \\geq b_i$ 的点 $(x, y)$ 所在区域\n- 满足 $x \\geq a_i$ 且 $y \\leq b_i$ 的点 $(x, y)$ 所在区域\n- 满足 $x \\geq a_i$ 且 $y \\geq b_i$ 的点 $(x, y)$ 所在区域\n\n每种购物优惠最多只能使用一次。商品也可以单独购买，只需支付其对应的价格 $p_i$。\n\n你需要获取商店中的每件商品至少一件。求达成该目标所需支付的最小总成本。", "inputFormat": "第一行输入包含两个以空格分隔的整数 $N$ 和 $M$。\n\n接下来 $N$ 行每行包含三个以空格分隔的整数 $a_i$、$b_i$ 和 $c_i$（$-10^9 \\leq a_i, b_i \\leq 10^9$，$1 \\leq c_i \\leq 10^9$）。\n\n随后 $M$ 行每行包含三个以空格分隔的整数 $x_i$、$y_i$ 和 $p_i$（$-10^9 \\leq x_i, y_i \\leq 10^9$，$1 \\leq p_i \\leq 10^9$）。\n", "outputFormat": "输出一行，表示获取所有商品至少一件所需的最小总成本。", "hint": "**样例 1 解释**\n\n使用第一种购物优惠，选择区域 $\\{(x, y) \\mid x \\leq 1, y \\geq 1\\}$ 获取第二件商品。然后单独购买第 1、3、4 件商品。总成本为 $3 + (2 + 4 + 3) = 12$。\n\n以下表格展示了 25 分的分布情况：\n\n| 分值   | $N$ 的范围        | $M$ 的范围         | 额外约束条件                                                                 |\n|:------:|:-----------------:|:------------------:|:---------------------------------------------------------------------------:|\n| 1 分   | $1 \\leq N \\leq 8$ | $1 \\leq M \\leq 20$ | 无                                                                         |\n| 3 分   | $1 \\leq N \\leq 70$ | $1 \\leq M \\leq 20$ | 无                                                                         |\n| 3 分   | $1 \\leq N \\leq 70$ | $1 \\leq M \\leq 70$ | 无                                                                         |\n| 4 分   | $1 < N \\leq 100$ | $1 < M \\leq 100000$ | 所有 $(a_i, b_i)$ 和 $(x_j, y_j)$ 点的 $x$ 或 $y$ 坐标互不相同              |\n| 2 分   | $1 \\leq N \\leq 100$ | $1 \\leq M \\leq 100000$ | 无                                                                         |\n| 8 分   | $1 \\leq N \\leq 1000$ | $1 \\leq M \\leq 100000$ | 所有 $(a_i, b_i)$ 和 $(x_j, y_j)$ 点的 $x$ 或 $y$ 坐标互不相同              |\n| 4 分   | $1 \\leq N \\leq 1000$ | $1 \\leq M \\leq 100000$ | 无                                                                         |\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12972", "type": "P", "difficulty": 3, "samples": [["4\n1 3 8 12", "15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "位运算"], "title": "一道恶心的签到题", "background": "愿你们能够不被此题所迷倒。", "description": "小 L 一共有 $n$ 瓶饮料需要拿走，第 $i$ 瓶饮料的重量为 $a_i$。小 L 将会分 $x$ 轮拿饮料（$1 \\le x \\le n$，$x$ 自定）。每一轮拿饮料，她拿走第 $i$ 瓶（此轮第 $1$ 瓶）饮料耗费的精力值为 $a_i$；假设这轮原来已经耗费 $k$ 的精力值，之后再拿走第 $j$（$1 \\le j \\le n$）瓶饮料，则拿走这瓶饮料将新耗费 $(k \\And a_j) + (k \\oplus a_j) - k$ 精力值（$\\And$ 表示按位与，$\\oplus$ 表示按位异或）。每一轮拿的饮料都是位置连续的一段饮料。我们设第 $i$ 轮拿完饮料总共消耗了 $l_i$ 精力值，请你求出 $\\sum\\limits_{i=1}^xl_i$。\n\n**简易题面:**\n\n小 L 的面前有 $n$ 瓶饮料，第 $i$ 瓶的重量为 $w_i$。她会分成若干轮把所有饮料全部拿走，第 $p$ 轮中拿走的第 $k$ 瓶（设拿走的第 $k$ 瓶饮料编号为 $d$）会花费体力 $f_{p,k}=\\begin{cases}a_d&(k=1)\\\\(a_d\\operatorname{and}\\sum\\limits_{1\\leqslant j<k}f_{p,j})+(a_d\\operatorname{xor}\\sum\\limits_{1\\leqslant j<k}f_{p,j})-\\sum\\limits_{1\\leqslant j<k}f_{p,j}&(k\\geqslant2)\\end{cases}$。若第 $p$ 轮拿走了 $c$ 瓶饮料，则该轮耗费的体力 $s_p=\\sum\\limits_{k=1}^cf_{p,k}$。若小 L 用了 $m$ 轮把饮料拿完，请问 $\\sum\\limits_{p=1}^ms_p$ 最小为多少。", "inputFormat": "第一行输入一个数 $n$。\n\n第二行输入 $n$ 个数，第 $i$ 个数表示 $a_i$。", "outputFormat": "共一行，一个数，表示最小的 $\\sum^x_{i=1} l_i$。", "hint": "**【样例解释】**\n\n1. 拿走第二瓶饮料，新耗费 $3$ 精力值。\n2. 拿走第一瓶饮料，新耗费 $(3\\And 1)+(3\\oplus 1)-3=0$ 精力值，并将这两瓶饮料拿走，结束这轮。\n3. 拿走第三瓶饮料，新耗费 $8$ 精力值。\n4. 拿走第四瓶饮料，新耗费 $(8\\And 12)+(8\\oplus 12)-8=4$ 精力值，将这两瓶饮料拿走，结束这轮。\n\n总共耗费 $3+0+8+4=15$ 精力值。\n\n**【数据范围】**\n\n对于 $100\\%$ 的数据：$1\\leq n\\leq 10^6$，$0\\leq \\sum^x_{i=1} l_i \\leq 2^{63}-1$，$0\\leq a_i \\leq 2^{63}-1$。\n\n| 数据点 |     $n\\leq $      |      特殊性质       |\n| :----: | :----------: | :-----------------: |\n|  $1$   |  $9$   |         无          |\n| $2\\sim3$  | $10^3$ | $\\sum l \\leq 2^5-1$ |\n|  $4$   | $10^3$ |         无          |\n| $5\\sim10$ | $10^6$ |         无          |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "一道恶心的签到题", "background": "愿你们能够不被此题所迷倒。", "description": "小 L 一共有 $n$ 瓶饮料需要拿走，第 $i$ 瓶饮料的重量为 $a_i$。小 L 将会分 $x$ 轮拿饮料（$1 \\le x \\le n$，$x$ 自定）。每一轮拿饮料，她拿走第 $i$ 瓶（此轮第 $1$ 瓶）饮料耗费的精力值为 $a_i$；假设这轮原来已经耗费 $k$ 的精力值，之后再拿走第 $j$（$1 \\le j \\le n$）瓶饮料，则拿走这瓶饮料将新耗费 $(k \\And a_j) + (k \\oplus a_j) - k$ 精力值（$\\And$ 表示按位与，$\\oplus$ 表示按位异或）。每一轮拿的饮料都是位置连续的一段饮料。我们设第 $i$ 轮拿完饮料总共消耗了 $l_i$ 精力值，请你求出 $\\sum\\limits_{i=1}^xl_i$。\n\n**简易题面:**\n\n小 L 的面前有 $n$ 瓶饮料，第 $i$ 瓶的重量为 $w_i$。她会分成若干轮把所有饮料全部拿走，第 $p$ 轮中拿走的第 $k$ 瓶（设拿走的第 $k$ 瓶饮料编号为 $d$）会花费体力 $f_{p,k}=\\begin{cases}a_d&(k=1)\\\\(a_d\\operatorname{and}\\sum\\limits_{1\\leqslant j<k}f_{p,j})+(a_d\\operatorname{xor}\\sum\\limits_{1\\leqslant j<k}f_{p,j})-\\sum\\limits_{1\\leqslant j<k}f_{p,j}&(k\\geqslant2)\\end{cases}$。若第 $p$ 轮拿走了 $c$ 瓶饮料，则该轮耗费的体力 $s_p=\\sum\\limits_{k=1}^cf_{p,k}$。若小 L 用了 $m$ 轮把饮料拿完，请问 $\\sum\\limits_{p=1}^ms_p$ 最小为多少。", "inputFormat": "第一行输入一个数 $n$。\n\n第二行输入 $n$ 个数，第 $i$ 个数表示 $a_i$。", "outputFormat": "共一行，一个数，表示最小的 $\\sum^x_{i=1} l_i$。", "hint": "**【样例解释】**\n\n1. 拿走第二瓶饮料，新耗费 $3$ 精力值。\n2. 拿走第一瓶饮料，新耗费 $(3\\And 1)+(3\\oplus 1)-3=0$ 精力值，并将这两瓶饮料拿走，结束这轮。\n3. 拿走第三瓶饮料，新耗费 $8$ 精力值。\n4. 拿走第四瓶饮料，新耗费 $(8\\And 12)+(8\\oplus 12)-8=4$ 精力值，将这两瓶饮料拿走，结束这轮。\n\n总共耗费 $3+0+8+4=15$ 精力值。\n\n**【数据范围】**\n\n对于 $100\\%$ 的数据：$1\\leq n\\leq 10^6$，$0\\leq \\sum^x_{i=1} l_i \\leq 2^{63}-1$，$0\\leq a_i \\leq 2^{63}-1$。\n\n| 数据点 |     $n\\leq $      |      特殊性质       |\n| :----: | :----------: | :-----------------: |\n|  $1$   |  $9$   |         无          |\n| $2\\sim3$  | $10^3$ | $\\sum l \\leq 2^5-1$ |\n|  $4$   | $10^3$ |         无          |\n| $5\\sim10$ | $10^6$ |         无          |", "locale": "zh-CN"}}}
{"pid": "P12973", "type": "P", "difficulty": 2, "samples": [["3\n1\n2\n3", "1\n1 2\n2 1 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["构造"], "title": "一道搞笑的构造题", "background": "Many thanks to idea provider @[vegetable_king](https://www.luogu.com.cn/user/477443)!\n\n------\n\n构造题真的有那么难吗？", "description": "设 $a$ 是一个序列，定义 $\\operatorname{MEX}(a)$ 为 $a$ 中最小没有出现的正整数，$a[l, r]$ 为 $a$ 的第 $l$ 项到 $a$ 的第 $r$ 项组成的连续子序列。\n\n给你 $n$，让你构造一个 $1 \\sim n$ 的排列 $a$，使得\n\n$$\n\\sum\\limits_{l = 1}^n  \\sum\\limits_{r = l}^n \\operatorname{MEX}(a[l, r])\n$$\n\n的值最大。（如果看不懂可以看题目末尾）\n\n如果有多个 $a$ 的构造方案，请你输出字典序最小的一个。", "inputFormat": "第一行一个整数 $t$，表示数据组数。\n\n对于每组数据，第一行一个整数 $n$。", "outputFormat": "对于每一个数据输出一行，表示你构造出来的 $a$。", "hint": "**【样例解释】**\n\n对于第二组测试数据（$n=2$）：\n\n$a[1, 1] = \\{1\\}$，最小没有出现的正整数是 $2$。\n\n$a[2, 2] = \\{2\\}$，最小没有出现的正整数是 $1$。\n\n$a[1, 2] = \\{1, 2\\}$，最小没有出现的正整数是 $3$。\n\n上述式子的值为 $2 + 1 + 3 = 6$。\n\n对于第三组测试数据（$n=3$）：\n\n$a[1, 1] = \\{2\\}$，最小没有出现的正整数是 $1$。\n\n$a[2, 2] = \\{1\\}$，最小没有出现的正整数是 $2$。\n\n$a[3, 3] = \\{3\\}$，最小没有出现的正整数是 $1$。\n\n$a[1, 2] = \\{2, 1\\}$，最小没有出现的正整数是 $3$。\n\n$a[2, 3] = \\{1, 3\\}$，最小没有出现的正整数是 $2$。\n\n$a[1, 3] = \\{2, 1, 3\\}$，最小没有出现的正整数是 $4$。\n\n上述式子的值为 $1 + 2 + 1 + 3 + 2 + 4 = 13$。\n\n可以证明，没有其他的排列可以使得上述式子的值比答案更大，且没有其他的排列可以使得上述式子的值与答案相等的同时字典序比答案小。\n\n**【数据范围】**\n\n记一个测试点所有的 $n$ 之和为 $\\sum n$。\n\n对于 $30\\%$ 的数据：$\\sum n \\le 9$。\n\n对于 $100\\%$ 的数据：$1 \\le n \\le 10^6$，$1 \\le t \\le 10^6$，$\\sum n \\le 10^6$。\n\n**【温馨提示】**\n\n$$\n\\sum\\limits_{l = 1}^n ( \\sum\\limits_{r = l}^n \\operatorname{MEX}(a[l, r]))\n$$\n\n\n的伪代码如下：\n\n```\nfor each l in range(1,n):\n\tfor each r in range(l,n):\n\t\tresult = result+MEX(l,r)\n```\n\n最终结果为 $result$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "一道搞笑的构造题", "background": "Many thanks to idea provider @[vegetable_king](https://www.luogu.com.cn/user/477443)!\n\n------\n\n构造题真的有那么难吗？", "description": "设 $a$ 是一个序列，定义 $\\operatorname{MEX}(a)$ 为 $a$ 中最小没有出现的正整数，$a[l, r]$ 为 $a$ 的第 $l$ 项到 $a$ 的第 $r$ 项组成的连续子序列。\n\n给你 $n$，让你构造一个 $1 \\sim n$ 的排列 $a$，使得\n\n$$\n\\sum\\limits_{l = 1}^n  \\sum\\limits_{r = l}^n \\operatorname{MEX}(a[l, r])\n$$\n\n的值最大。（如果看不懂可以看题目末尾）\n\n如果有多个 $a$ 的构造方案，请你输出字典序最小的一个。", "inputFormat": "第一行一个整数 $t$，表示数据组数。\n\n对于每组数据，第一行一个整数 $n$。", "outputFormat": "对于每一个数据输出一行，表示你构造出来的 $a$。", "hint": "**【样例解释】**\n\n对于第二组测试数据（$n=2$）：\n\n$a[1, 1] = \\{1\\}$，最小没有出现的正整数是 $2$。\n\n$a[2, 2] = \\{2\\}$，最小没有出现的正整数是 $1$。\n\n$a[1, 2] = \\{1, 2\\}$，最小没有出现的正整数是 $3$。\n\n上述式子的值为 $2 + 1 + 3 = 6$。\n\n对于第三组测试数据（$n=3$）：\n\n$a[1, 1] = \\{2\\}$，最小没有出现的正整数是 $1$。\n\n$a[2, 2] = \\{1\\}$，最小没有出现的正整数是 $2$。\n\n$a[3, 3] = \\{3\\}$，最小没有出现的正整数是 $1$。\n\n$a[1, 2] = \\{2, 1\\}$，最小没有出现的正整数是 $3$。\n\n$a[2, 3] = \\{1, 3\\}$，最小没有出现的正整数是 $2$。\n\n$a[1, 3] = \\{2, 1, 3\\}$，最小没有出现的正整数是 $4$。\n\n上述式子的值为 $1 + 2 + 1 + 3 + 2 + 4 = 13$。\n\n可以证明，没有其他的排列可以使得上述式子的值比答案更大，且没有其他的排列可以使得上述式子的值与答案相等的同时字典序比答案小。\n\n**【数据范围】**\n\n记一个测试点所有的 $n$ 之和为 $\\sum n$。\n\n对于 $30\\%$ 的数据：$\\sum n \\le 9$。\n\n对于 $100\\%$ 的数据：$1 \\le n \\le 10^6$，$1 \\le t \\le 10^6$，$\\sum n \\le 10^6$。\n\n**【温馨提示】**\n\n$$\n\\sum\\limits_{l = 1}^n ( \\sum\\limits_{r = l}^n \\operatorname{MEX}(a[l, r]))\n$$\n\n\n的伪代码如下：\n\n```\nfor each l in range(1,n):\n\tfor each r in range(l,n):\n\t\tresult = result+MEX(l,r)\n```\n\n最终结果为 $result$。\n", "locale": "zh-CN"}}}
{"pid": "P12974", "type": "P", "difficulty": 1, "samples": [["8\n1 3 +1\n4 3 -1", "Yes\nYes"], ["8\n1 3 +1\n4 3 0", "Yes\nNo"], ["4\n1 3 +1\n4 3 0", "Yes\nYes"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "O2优化"], "title": "蒸蒸日上", "background": "Source：TYCPC 4th，Check：xjking。\n\n[オーバーライド\n](https://music.163.com/song?id=2105374808&uct2=U2FsdGVkX18PX/5u8EoipDWYOwGy7fBJZ0o/tdcVZGw=)", "description": "三国杀是一款蒸蒸日上的游戏，其中关于距离的设定比较有趣。\n\n有 $n$ 个玩家围成一圈玩三国杀，从某个位置开始顺时针依次标号从 $1$ 到 $n$ 的位次。\n\n定义位置距离为两个玩家之间**顺时针或逆时针**相隔的人数最小值**加上** $1$。\n\n定义实际距离为位置距离的修正，具体的：\n\n1. 当其中一位玩家装备了 `+1` 坐骑，**其他玩家对他**计算实际距离时变为位置距离加上 $1$。\n\n2. 当其中一位玩家装备了 `-1` 坐骑，**他对其他玩家**计算实际距离时变为位置距离减去 $1$。\n\n3. 如果一位玩家的坐骑是 `0` 则代表其没有坐骑，不产生特殊效果。\n\n注意：**实际距离**指的是计算时的距离，游戏中两人的位次**没有改变**。\n\n当一位玩家的**武器距离**大于等于**他对想要攻击的玩家**计算的实际距离时，我们称这位玩家可以攻击到他想要攻击的玩家。\n\n现在给你两个玩家 A 和 B 的位次，武器距离和坐骑情况，请你判定 A 是否能攻击到 B，B 是否能攻击到 A。\n\n", "inputFormat": "输入共三行，第一行先读入一个正整数 $n$ 表示参与游玩的人数。\n\n后两行每一行形容一个玩家的游戏情况，第一行形容 A，第二行形容 B。\n\n一行有两个整数和一个字符串，表示一个玩家的位次，武器距离和坐骑情况。", "outputFormat": "输出共两行，每一行有一个字符串形容攻击的权限，第一行表述 A 是否能攻击到 B，第二行表述 B 是否能攻击到 A。\n\n一行有一个字符串 `Yes` 或者 `No`，如果为 `Yes` 则可以成功否则不行。", "hint": "### 样例解释 1\n\n因为 A 装备了 `+1` 坐骑，B 对 A 计算实际距离应当加上 $1$，但是 B 装备了 `-1` 坐骑，所以 B 刚好能打到 A。\n\n## 数据范围\n\n共 $10$ 个测试点，不开启捆绑测试。\n\n对于前 $10\\%$ 的数据，保证坐骑只有 `0`。\n\n对于 $100\\%$ 的数据，$3\\le n\\le 8$，坐骑只有 `0,-1,1` 三种，武器距离不超过 $4$ 且不少于 $1$，保证两人的位次在 $1\\sim n$ 之间且不相等。\n\n---\n\nAI 玩过三国杀吗？", "locale": "zh-CN", "translations": {"zh-CN": {"title": "蒸蒸日上", "background": "Source：TYCPC 4th，Check：xjking。\n\n[オーバーライド\n](https://music.163.com/song?id=2105374808&uct2=U2FsdGVkX18PX/5u8EoipDWYOwGy7fBJZ0o/tdcVZGw=)", "description": "三国杀是一款蒸蒸日上的游戏，其中关于距离的设定比较有趣。\n\n有 $n$ 个玩家围成一圈玩三国杀，从某个位置开始顺时针依次标号从 $1$ 到 $n$ 的位次。\n\n定义位置距离为两个玩家之间**顺时针或逆时针**相隔的人数最小值**加上** $1$。\n\n定义实际距离为位置距离的修正，具体的：\n\n1. 当其中一位玩家装备了 `+1` 坐骑，**其他玩家对他**计算实际距离时变为位置距离加上 $1$。\n\n2. 当其中一位玩家装备了 `-1` 坐骑，**他对其他玩家**计算实际距离时变为位置距离减去 $1$。\n\n3. 如果一位玩家的坐骑是 `0` 则代表其没有坐骑，不产生特殊效果。\n\n注意：**实际距离**指的是计算时的距离，游戏中两人的位次**没有改变**。\n\n当一位玩家的**武器距离**大于等于**他对想要攻击的玩家**计算的实际距离时，我们称这位玩家可以攻击到他想要攻击的玩家。\n\n现在给你两个玩家 A 和 B 的位次，武器距离和坐骑情况，请你判定 A 是否能攻击到 B，B 是否能攻击到 A。\n\n", "inputFormat": "输入共三行，第一行先读入一个正整数 $n$ 表示参与游玩的人数。\n\n后两行每一行形容一个玩家的游戏情况，第一行形容 A，第二行形容 B。\n\n一行有两个整数和一个字符串，表示一个玩家的位次，武器距离和坐骑情况。", "outputFormat": "输出共两行，每一行有一个字符串形容攻击的权限，第一行表述 A 是否能攻击到 B，第二行表述 B 是否能攻击到 A。\n\n一行有一个字符串 `Yes` 或者 `No`，如果为 `Yes` 则可以成功否则不行。", "hint": "### 样例解释 1\n\n因为 A 装备了 `+1` 坐骑，B 对 A 计算实际距离应当加上 $1$，但是 B 装备了 `-1` 坐骑，所以 B 刚好能打到 A。\n\n## 数据范围\n\n共 $10$ 个测试点，不开启捆绑测试。\n\n对于前 $10\\%$ 的数据，保证坐骑只有 `0`。\n\n对于 $100\\%$ 的数据，$3\\le n\\le 8$，坐骑只有 `0,-1,1` 三种，武器距离不超过 $4$ 且不少于 $1$，保证两人的位次在 $1\\sim n$ 之间且不相等。\n\n---\n\nAI 玩过三国杀吗？", "locale": "zh-CN"}}}
