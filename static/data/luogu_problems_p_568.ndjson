{"pid": "P12531", "type": "P", "difficulty": 4, "samples": [["2\n1\n\n8\n\n1\n\n1\n\n0\n\n0\n\n", "\n\n! 1\n\n? 6\n\n? 4\n\n? 2\n\n? 3\n\n! 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144]}, "tags": ["二分", "2025", "交互题", "Special Judge", "O2优化", "高校校赛"], "title": "[XJTUPC 2025] Beat Verdict: Precision Strike", "background": "", "description": "**这是一道交互题。**\n\n你正在玩一款名为「乌蒙滴叉」的音乐游戏。在专家模式中，需要精确校准音符的击打时机参数，该参数是一个 $[1,n]$ 内的神秘正整数 $x$。\n\n为了确定这个参数，你可以进行至多 $4$ 次校准测试。每次测试时，你选择一个正整数测试值 $y$ ($1 \\le y \\le n$)，系统将告知你 $y > x$ 是否成立。最终你需要给出一个正整数参数估计值 $x'$ ($1 \\le x' \\le n$)，且满足 $x' \\in \\left[0.5x, 2x\\right]$。\n\n注意：最终给出的估计值 $x'$ 不计入上述至多 $4$ 次测试次数。", "inputFormat": "输入包含多个测试用例。数据的第一行包含一个整数 $t$ ($1\\le t\\le 500$) 表示测试用例数。每个测试用例的交互流程在下文中描述。\n\n在每个测试用例中，输入的第一行包含一个正整数 $n$ ($1\\le n \\le 5 \\times 10^9$)，表示参数的可能范围。\n\n若你想进行测试，输出 `? y` ($1 \\le y \\le n$)。然后你读入对该测试的响应，为一个整数 $a$ ($a \\in \\{0, 1\\}$)，$\\tt{1}$ 表示 $y>x$ 为真，$\\tt{0}$ 表示 $y>x$ 为假。\n\n若你想提交参数 $x'$，输出 `! x'` ($1 \\le x' \\le n$)。然后你立即结束本个测试用例的交互，并准备下一个测试用例的交互。这次交互不计入上述至多 $4$ 次测试次数。\n\n注意在你的程序每轮输出结束时（即，每一次输出 `? y` 或 `! x'` 后），**需要输出回车并刷新输出缓冲区**，否则你将会得到 $\\tt{Time\\ Limit\\ Exceeded}$。\n\n你可以使用： \n\n- C 的 `fflush(stdout)`；\n- C++ 的 `cout.flush()`；\n- Java 的 `System.out.flush()`；\n- Python 的 `stdout.flush()`；\n\n来刷新输出缓冲区。\n\n请注意：交互库自适应，即每个测试用例中的正整数 $x$ ($1 \\le x \\le n$) **可能会随着你的输入而变化**，但始终满足所有已经发生过的询问。\n\n如果你最后输出的答案正确，你会得到 $\\tt{Accepted}$；\n\n如果你给出的询问不符合题目范围要求，或最后输出的答案不正确，你会得到 $\\tt{Wrong\\ Answer}$；\n\n此外，其他的评测结果仍会在评测过程中根据通常情况返回。", "outputFormat": "见输入格式。", "hint": "在第一组测试用例中，可以唯一确定 $x = 1$，因此我们直接提交 $x' = 1$。\n\n在第二组测试用例中，隐藏的参数 $x = 3$，交互过程如下：\n\n- 测试 $y=6$，响应为 $y>x$ 为真；\n- 测试 $y=4$，响应为 $y>x$ 为真；\n- 测试 $y=2$，响应为 $y>x$ 为假；\n- 测试 $y=3$，响应为 $y>x$ 为假；\n- 提交 $x' = 3$。\n\n请注意，此示例仅用于演示交互格式。不能保证提供的查询是最优的或唯一确定答案。", "locale": "zh-CN", "translations": {"en": {"title": "[XJTUPC 2025] Beat Verdict: Precision Strike", "background": "", "description": "**This is an interactive problem.**\n\nYou are playing a music game. In expert mode, you need to accurately calibrate the timing parameter for hitting notes, which is a mysterious $\\textbf{integer}$ $x$ within the range $[1,n]$.\n\nTo determine this parameter, you can perform at most $4$ calibration tests. In each test, you choose an $\\textbf{integer}$ test value $y$ ($1 \\le y \\le n$), and the system will inform you whether $y > x$ is true or not. Ultimately, you need to provide an $\\textbf{integer}$ estimated parameter value $x'$ ($1 \\le x' \\le n$), such that $x' \\in \\left[0.5x, 2x\\right]$.\n\nNote: The final estimated value $x'$ does not count towards the aforementioned maximum of $4$ tests.", "inputFormat": "The input contains multiple test cases. The first line of the data contains an integer $t$ ($1\\le t\\le 500$) indicating the number of test cases. The interaction process for each test case is described below.\n\nIn each test case, the first line of input contains a positive integer $n$ ($1\\le n \\le 5 \\times 10^9$), representing the possible range of the parameter.\n\nIf you want to perform a calibration test, output $\\tt{?\\ y}$ ($1 \\le y \\le n$). Then you will read the response to that test, which will be an integer $a$ ($a \\in \\{0, 1\\}$), where $\\tt{1}$ indicates that $y>x$ is true, and $\\tt{0}$ indicates that $y>x$ is false.\n\nIf you want to submit the calibration parameter $x'$, output $\\tt{!\\ x'}$ ($1 \\le x' \\le n$). You will then immediately end the interaction for this test case and prepare for the interaction of the next test case. This interaction does not count towards the maximum of $4$ tests.\n\nNote that at the end of each round of output in your program (i.e., after each output of $\\tt{?\\ y}$ or $\\tt{!\\ x'}$), $\\textbf{you need to output a newline and flush the output buffer}$; otherwise, you will receive $\\tt{Time\\ Limit\\ Exceeded}$.\n\nYou can use:\n  - C's $\\tt{fflush(stdout)}$;\n  - C++'s $\\tt{cout.flush()}$;\n  - Java's $\\tt{System.out.flush()}$;\n  - Python's $\\tt{stdout.flush()}$;\n    \nto flush the output buffer.\n\nPlease note: The interactive library is adaptive, meaning that the positive integer $x$ ($1 \\le x \\le n$) $\\textbf{may change with your inputs}$ in each test case, but it will always satisfy all previously made inquiries.\n\nIf the answer you output at the end is correct, you will receive $\\tt{Accepted}$;\n\nIf your inquiries do not conform to the problem's range requirements, or if the final answer you output is incorrect, you will receive $\\tt{Wrong Answer}$;\n\nAdditionally, other evaluation results will still be returned during the evaluation process based on normal circumstances.", "outputFormat": "See also interactive format.", "hint": "In the first test case, it can be uniquely determined that $x = 1$, so we directly submit $x' = 1$.\n\nIn the second test case, the hidden parameter $x = 3$, and the interaction process is as follows:\n\n- Test $y=6$, the response is that $y>x$ is true;\n- Test $y=4$, the response is that $y>x$ is true;\n- Test $y=2$, the response is that $y>x$ is false;\n- Test $y=3$, the response is that $y>x$ is false;\n- Submit $x' = 3$.\n\nPlease note that this example only serves to demonstrate the interaction format. It is not guaranteed that the queries provided are optimal or uniquely determine the answer.", "locale": "en"}, "zh-CN": {"title": "[XJTUPC 2025] Beat Verdict: Precision Strike", "background": "", "description": "**这是一道交互题。**\n\n你正在玩一款名为「乌蒙滴叉」的音乐游戏。在专家模式中，需要精确校准音符的击打时机参数，该参数是一个 $[1,n]$ 内的神秘正整数 $x$。\n\n为了确定这个参数，你可以进行至多 $4$ 次校准测试。每次测试时，你选择一个正整数测试值 $y$ ($1 \\le y \\le n$)，系统将告知你 $y > x$ 是否成立。最终你需要给出一个正整数参数估计值 $x'$ ($1 \\le x' \\le n$)，且满足 $x' \\in \\left[0.5x, 2x\\right]$。\n\n注意：最终给出的估计值 $x'$ 不计入上述至多 $4$ 次测试次数。", "inputFormat": "输入包含多个测试用例。数据的第一行包含一个整数 $t$ ($1\\le t\\le 500$) 表示测试用例数。每个测试用例的交互流程在下文中描述。\n\n在每个测试用例中，输入的第一行包含一个正整数 $n$ ($1\\le n \\le 5 \\times 10^9$)，表示参数的可能范围。\n\n若你想进行测试，输出 `? y` ($1 \\le y \\le n$)。然后你读入对该测试的响应，为一个整数 $a$ ($a \\in \\{0, 1\\}$)，$\\tt{1}$ 表示 $y>x$ 为真，$\\tt{0}$ 表示 $y>x$ 为假。\n\n若你想提交参数 $x'$，输出 `! x'` ($1 \\le x' \\le n$)。然后你立即结束本个测试用例的交互，并准备下一个测试用例的交互。这次交互不计入上述至多 $4$ 次测试次数。\n\n注意在你的程序每轮输出结束时（即，每一次输出 `? y` 或 `! x'` 后），**需要输出回车并刷新输出缓冲区**，否则你将会得到 $\\tt{Time\\ Limit\\ Exceeded}$。\n\n你可以使用： \n\n- C 的 `fflush(stdout)`；\n- C++ 的 `cout.flush()`；\n- Java 的 `System.out.flush()`；\n- Python 的 `stdout.flush()`；\n\n来刷新输出缓冲区。\n\n请注意：交互库自适应，即每个测试用例中的正整数 $x$ ($1 \\le x \\le n$) **可能会随着你的输入而变化**，但始终满足所有已经发生过的询问。\n\n如果你最后输出的答案正确，你会得到 $\\tt{Accepted}$；\n\n如果你给出的询问不符合题目范围要求，或最后输出的答案不正确，你会得到 $\\tt{Wrong\\ Answer}$；\n\n此外，其他的评测结果仍会在评测过程中根据通常情况返回。", "outputFormat": "见输入格式。", "hint": "在第一组测试用例中，可以唯一确定 $x = 1$，因此我们直接提交 $x' = 1$。\n\n在第二组测试用例中，隐藏的参数 $x = 3$，交互过程如下：\n\n- 测试 $y=6$，响应为 $y>x$ 为真；\n- 测试 $y=4$，响应为 $y>x$ 为真；\n- 测试 $y=2$，响应为 $y>x$ 为假；\n- 测试 $y=3$，响应为 $y>x$ 为假；\n- 提交 $x' = 3$。\n\n请注意，此示例仅用于演示交互格式。不能保证提供的查询是最优的或唯一确定答案。", "locale": "zh-CN"}}}
{"pid": "P12532", "type": "P", "difficulty": 6, "samples": [["3\n2 2 2\n2 2 2\n1 2 3", "2"], ["3\n2 3 1\n3 5 3\n3 2 1", "4"], ["1\n201 502 10", "0"], ["4\n1 2 3\n1 2 3\n4 5 6\n4 5 6\n", "6"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["二分", "2025", "O2优化", "差分", "高校校赛"], "title": "[XJTUPC 2025] Primal Core Optimization: Attribute Balance", "background": "", "description": "你正在玩一款被称为「韵律原罪」的游戏。在这个游戏里，你需要操纵你的搭档们，在「世界」中探索。\n\n在游戏中，每一个搭档都有三种属性：$\\mathrm{Stop}$ (S)，$\\mathrm{Flag}$ (F) 和 $\\mathrm{Ever}$ (E)。当所有搭档的属性完全一致时，她们就能成功融合。\n\n现在你想要把所有搭档全部融合，换句话说就是让每一对搭档的属性全部相等。为了达成这一目的，你不得不对她们的属性进行修改。一次修改分为以下步骤：\n\n- 你任选一位搭档作为修改的目标（你只能选一位搭档）；\n- 你任选她的若干个属性；\n- 将她的所选属性的数值全部增加 $1$ 或全部减少 $1$（必须同时执行同一种操作，即全部加或全部减）。\n\n由于你的魔力不强，所以每次修改都需要花费 $1$ 源石。现在你想知道，你至少需要花费多少源石，才能达到你的目标。", "inputFormat": "第一行，一个整数 $N$ ($1\\le N\\le 10^5$) 表示你拥有的搭档个数。\n\n接下来 $N$ 行，每行三个整数 $S_i$, $F_i$ 和 $E_i$ ($1\\le S_i, F_i, E_i \\le 10^5$)，用一个空格分隔，表示第 $i$ 个搭档的三个属性的值。", "outputFormat": "仅一个整数表示答案。", "hint": "对于第一组样例，存在以下操作方式，使得总修改次数是 $2$ 次：\n\n- 选择搭档 $3$ 和她的第一个属性，将她的属性修改为 $2$, $2$, $3$；\n- 选择搭档 $3$ 和她的第三个属性，将她的属性修改为 $2$, $2$, $2$。\n\n同时可以证明，不能通过少于 $2$ 次操作达成目标。所以，你应该输出 $2$。\n\n对于第二组样例，存在以下操作方式，使得总修改次数是 $4$ 次：\n\n- 选择搭档 $1$ 和她的第一、第三属性，将她的属性修改为 $3$, $3$, $2$；\n- 选择搭档 $2$ 和她的第二、第三属性，将她的属性修改为 $3$, $4$, $2$；\n- 选择搭档 $2$ 和她的第二个属性，将她的属性修改为 $3$, $3$, $2$；\n- 选择搭档 $3$ 和她的第二、第三属性，将她的属性修改为 $3$, $3$, $2$。\n\n同时可以证明，不能通过少于 $4$ 次操作达成目标。所以，你应该输出 $4$。\n\n对于第三组样例，因为只有一位搭档，所以不需要进行操作。所以，你应该输出 $0$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[XJTUPC 2025] Primal Core Optimization: Attribute Balance", "background": "", "description": "You are playing a game called \"Rhythm Sin\". In this game, you control partners to explore the \"World\".\n\nEach partner has three attributes: $\\mathrm{Stop}$ (S), $\\mathrm{Flag}$ (F), and $\\mathrm{Ever}$ (E). When all partners' attributes are completely consistent, they can successfully fuse.\n\nYour goal is to fuse all partners, meaning you must make every pair of partners have identical attributes. To achieve this, you need to modify their attributes. Each modification consists of the following steps:\n\n- Select any partner as the target (you can only select one partner).\n- Choose any subset of her attributes.\n- Increment or decrement all selected attributes by $1$ (the same operation must be carried out simultaneously, i.e., all selected attributes increment or all selected attributes decrement).\n\nDue to limited magical power, each modification costs $1$ primal stone. Your task is to determine the minimum number of primal stones required to achieve your goal.", "inputFormat": "The first line contains an integer $N$ ($1\\le N\\le 10^5$), the number of partners.\n\nThe next $N$ lines each contain three integers $S_i$, $F_i$, and $E_i$ ($1\\le S_i, F_i, E_i \\le 10^5$), separated by a space, representing the values of the three attributes for the $i$-th partner.", "outputFormat": "A single integer representing the minimum number of primal stones required.", "hint": "For the first sample, one possible sequence of modifications (costing $2$ primal stones) is:\n\n- Select partner $3$ and S attribute, modify her attributes to $2$, $2$, $3$;\n- Select partner $3$ and E attribute, modify her attributes to $2$, $2$, $2$.\n\nIt can be proved that you cannot achieve the goal using less than $2$ primal stones, so the answer is $2$.\n\nFor the second sample, one possible sequence of modifications (costing $4$ primal stones) is:\n\n- Select partner $1$ and S and E attributes, modify her attributes to $3$, $3$, $2$;\n- Select partner $2$ and F and E attributes, modify her attributes to $3$, $4$, $2$;\n- Select partner $2$ again and F attribute, modify her attributes to $3$, $3$, $2$;\n- Select partner $3$ and F and E attributes, modify her attributes to $3$, $3$, $2$.\n\nIt can be proved that you cannot achieve the goal using less than $4$ primal stones, so the answer is $4$.\n\nFor the third sample, because there is only one partner, you don't need to perform any modifications, so the answer is $0$.", "locale": "en"}, "zh-CN": {"title": "[XJTUPC 2025] Primal Core Optimization: Attribute Balance", "background": "", "description": "你正在玩一款被称为「韵律原罪」的游戏。在这个游戏里，你需要操纵你的搭档们，在「世界」中探索。\n\n在游戏中，每一个搭档都有三种属性：$\\mathrm{Stop}$ (S)，$\\mathrm{Flag}$ (F) 和 $\\mathrm{Ever}$ (E)。当所有搭档的属性完全一致时，她们就能成功融合。\n\n现在你想要把所有搭档全部融合，换句话说就是让每一对搭档的属性全部相等。为了达成这一目的，你不得不对她们的属性进行修改。一次修改分为以下步骤：\n\n- 你任选一位搭档作为修改的目标（你只能选一位搭档）；\n- 你任选她的若干个属性；\n- 将她的所选属性的数值全部增加 $1$ 或全部减少 $1$（必须同时执行同一种操作，即全部加或全部减）。\n\n由于你的魔力不强，所以每次修改都需要花费 $1$ 源石。现在你想知道，你至少需要花费多少源石，才能达到你的目标。", "inputFormat": "第一行，一个整数 $N$ ($1\\le N\\le 10^5$) 表示你拥有的搭档个数。\n\n接下来 $N$ 行，每行三个整数 $S_i$, $F_i$ 和 $E_i$ ($1\\le S_i, F_i, E_i \\le 10^5$)，用一个空格分隔，表示第 $i$ 个搭档的三个属性的值。", "outputFormat": "仅一个整数表示答案。", "hint": "对于第一组样例，存在以下操作方式，使得总修改次数是 $2$ 次：\n\n- 选择搭档 $3$ 和她的第一个属性，将她的属性修改为 $2$, $2$, $3$；\n- 选择搭档 $3$ 和她的第三个属性，将她的属性修改为 $2$, $2$, $2$。\n\n同时可以证明，不能通过少于 $2$ 次操作达成目标。所以，你应该输出 $2$。\n\n对于第二组样例，存在以下操作方式，使得总修改次数是 $4$ 次：\n\n- 选择搭档 $1$ 和她的第一、第三属性，将她的属性修改为 $3$, $3$, $2$；\n- 选择搭档 $2$ 和她的第二、第三属性，将她的属性修改为 $3$, $4$, $2$；\n- 选择搭档 $2$ 和她的第二个属性，将她的属性修改为 $3$, $3$, $2$；\n- 选择搭档 $3$ 和她的第二、第三属性，将她的属性修改为 $3$, $3$, $2$。\n\n同时可以证明，不能通过少于 $4$ 次操作达成目标。所以，你应该输出 $4$。\n\n对于第三组样例，因为只有一位搭档，所以不需要进行操作。所以，你应该输出 $0$。\n", "locale": "zh-CN"}}}
{"pid": "P12533", "type": "P", "difficulty": 4, "samples": [["100\n000\n000\n111\n111\n011", "9\nBL\nBL\nBL\nAL\nC1\nAL\nC1\nAR\nC1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["搜索", "2025", "Special Judge", "O2优化", "广度优先搜索 BFS", "构造", "高校校赛"], "title": "[XJTUPC 2025] 9-Nine", "background": "『九次九日九重色，\n\n天色天歌天籁音，\n\n春色春恋春熙风，\n\n雪色雪花雪余痕』\n\n---  _《9-nine-》_ ", "description": "工艺品（Artifact），白巳津川市自行制作的动画《轮回转生的莫比乌斯环》（虽然收视率极低）中的道具居然来到了现实！拥有它的人都会获得独有的特殊能力，这一切的一切都要从那场地震开始。\n\n「千年之前，本世界和异世界是互通的，而工艺品正是异世界的魔法道具。由于种种原因，出现了一个叫「生命之树」的组织，将所有的工艺品回收后设下了法阵，阻止了两个世界的流通。但是由于地震，法阵被破坏，于是工艺品便流向了这个世界。」------来自异世界的玩偶索菲提娅如是说道。\n\n在索菲的帮助下，我们的主角新海翔带领四位女主与反派进行激烈的斗争，最终成功阻止其使用工艺品犯下不可饶恕的错误。不过，为了根除这个问题，新海翔和索菲决定断绝两个世界的联系，重新打开封印。\n\n封印的法阵可以看做两个 $9 \\times 9$ 的黑白方阵，新海翔和索菲分别可以控制一个方阵，他们可以做如下动作：\n\n- 新海翔将自己面前的方阵向左或向右旋转 $90$ 度；\n- 索菲将自己面前的方阵向左或向右旋转 $90$ 度（两个方阵不联动）；\n- 新海翔和索菲选择方阵的同一列，进行交换；\n\n当新海翔一侧的方阵全是白色，同时索菲一侧的方阵全是黑色，那么封印就完成了，法阵将会开启，断开两个世界的联系，大家可以回归正常生活。\n\n时间有限，请你------我们的「第九人（Nine）」，帮助他们在 $999$ 步内完成这个封印。\n\n话虽如此，但是出题人被警告题出太难了，所以决定缩小数据范围！\n\n具体的，将方阵的边长减小至 $3$，同时步数减小至 $9\\times 9=81$！\n\n形式化地说，有两个 $3 \\times 3$ 的 01 矩阵 $A$ 和 $B$，你可以做如下操作：\n\n- 操作 $1$：选择矩阵 $A$ 或 $B$，将其向左或向右旋转 $90$ 度；\n- 操作 $2$：选择一个整数 $k$ ($1 \\le k \\le 3$)，将两矩阵的第 $k$ 列交换。\n\n请在 $81$ 次操作内将 $A$ 变为全 0 矩阵。数据保证此时 $B$ 一定为全 1 矩阵。", "inputFormat": "第 $1 \\sim 3$ 行，每行是一个长度为 $3$ 的 01 字符串，表示矩阵 $A$ 的初始状态；\n\n第 $4 \\sim 6$ 行，每行是一个长度为 $3$ 的 01 字符串，表示矩阵 $B$ 的初始状态。\n\n数据保证在有限次操作内，可以将 $A$ 变为全 0 矩阵，$B$ 变为全 1 矩阵。", "outputFormat": "第一行一个整数 $N$ ($0 \\le N \\le 81$)，表示你一共需要进行 $N$ 次操作。\n\n接下来的 $N$ 行表示你依次进行的操作。请按如下格式输出：\n\n- 如果你选择使用操作 $1$，请输出矩阵名与旋转方向。具体地：\n  - 若你想将 $A$ 矩阵向左旋转 $90$ 度，输出 $\\tt{AL}$；\n  - 若你想将 $A$ 矩阵向右旋转 $90$ 度，输出 $\\tt{AR}$；\n  - 若你想将 $B$ 矩阵向左旋转 $90$ 度，输出 $\\tt{BL}$；\n  - 若你想将 $B$ 矩阵向右旋转 $90$ 度，输出 $\\tt{BR}$。\n- 如果你选择使用操作 $2$，请输出 $\\tt{C}$ 与列号。例如，你要交换两个矩阵的第 $2$ 列，请输出 $\\tt{C2}$。\n\n其中，将一个矩阵向左旋转，指逆时针旋转；将一个矩阵向右旋转，指顺时针旋转。\n\n请注意：**不要输出多余的行末空格与文末回车**。", "hint": "可以证明，在数据合法的情况下，原题在 $999$ 步内一定存在解，弱化版的题目在 $81$ 步内一定存在解。\n\n~~最重要的是还在分割商法的《9-nine-》今年即将推出新作，预计冬季上架某平台。~~", "locale": "zh-CN", "translations": {"en": {"title": "[XJTUPC 2025] 9-Nine", "background": "\"Kokonotsu Kokonoka Kokonoiro,\n\nSorairo Sorauta Soranooto,\n\nHaruiro Harukoi Harunokaze,\n\nYukiiro Yukihana Yukinoato.\"\n\n--- 9-nine-", "description": "Artifact, a kind of magic item from anime called  _Rinnetense No Moubiusu Ring_ , written by City Shiromitsukawa, comes true unpredictably! The User can get his or her own special ability. All of this story begins from that earthquake.\n\n\"Thousands of years ago, the earth and the magic world were connected. The Artifact is just a magic item from the magic world. Because of lots of things, there was set up an organization called  _Sefiruto_  (Tree of Kabbalah), retrieving all of the Artifacts, using magic to prevent the connection of two worlds. However, attributing to the earthquake, the gate was broken, and the Artifact came to this world again.\" ------ the muppet named Sophitia said so.\n\nWith the help of Sophitia, our male lead KakeruNimi leads the four female leads in a fierce struggle against the villains, ultimately successfully preventing them from making unforgivable mistakes using Artifacts. After that, KakeruNimi and Sophitia decide to disconnect the two worlds, reusing the magic gate.\n\nThe lock of the gate can be seen as two black and white matrices with size $9 \\times 9$, and either KakeruNimi or Sophitia can control the matrix in his or her own world. They can:\n\n- KakeruNimi turns the matrix in his world to rotate by $90$ degrees to the left or right;\n- Sophitia turns the matrix in her world to rotate by $90$ degrees to the left or right (two matrices can be rotated independently);\n- KakeruNimi and Sophitia choose the same column of the matrices in two worlds and then swap them;\n\nWhen KakeruNimi's matrix is all white, as soon as Sophitia's matrix is all black, the gate will be locked, and then everyone can return to normal life.\n\nTime is limited, please YOU --- our \"Nine\" --- help them complete this task within $999$ steps.\n\nThat being said, the question maker was warned that the question was too difficult, so he decided to narrow down the data range!\n\nSpecifically, reduce the side length of the square matrix to $3$ and the number of steps to $9\\times 9=81$!\n\nFormally speaking, there are two $3 \\times 3$ 01 matrices $A$ and $B$, and you can do the following:\n\n- Operation $1$: Select matrix $A$ or $B$ and rotate it $90$ degrees to the left or right;\n- Operation $2$: Select the integer $k$ ($1 \\le k \\le 3$) and swap the $k$-th column of the two matrices.\n\nPlease convert $A$ into a full 0 matrix within $81$ operations, ensuring that $B$ is always a full 1 matrix at this time.", "inputFormat": "Line $1 \\sim 3$, each line is a 01 string of length $3$, representing the initial state of matrix $A$.\n\nLine $4 \\sim 6$, each line is a 01 string of length $3$, representing the initial state of matrix $B$.\n\nThe data guarantees that within a finite number of operations, $A$ can be transformed into a full 0 matrix and $B$ into a full 1 matrix.", "outputFormat": "The first line should be an integer $N$ ($0 \\le N \\le 81$), indicating that you need to perform a total of $N$ operations.\n\nThe next $N$ lines should be in the following format:\n\n- If you choose to use operation $1$ for an item, please output the matrix name and rotation direction. Specifically:\n    - If you want to rotate the $A$ matrix to the left by $90$ degrees , output $\\tt{AL}$;\n    - If you want to rotate the $A$ matrix to the right by $90$ degrees, output $\\tt{AR}$;\n    - If you want to rotate the $B$ matrix to the left by $90$ degrees , output $\\tt{BL}$;\n    - If you want to rotate the $B$ matrix to the right by $90$ degrees, output $\\tt{BR}$.\n- If you choose to use operation $2$ for an item, please output $\\tt{C}$ and column number. For example, if you want to swap the $2$nd column of two matrices, please output $\\tt{C2}$.\n\nWhere, rotating a matrix to the left means rotating it counterclockwise; Rotating a matrix to the right means rotating it clockwise.\n\nPlease note: **Do not output extra spaces at the end of the line or carriage returns at the end of the text**.", "hint": "It can be proven that, under the condition of valid data, there must be a solution to the original question within step $999$, and the weakened version of the question must have a solution within step $81$.\n\n~~The most important thing is that 9-nine- will release a new work this year and is expected to be launched on Steam in the winter.~~", "locale": "en"}, "zh-CN": {"title": "[XJTUPC 2025] 9-Nine", "background": "『九次九日九重色，\n\n天色天歌天籁音，\n\n春色春恋春熙风，\n\n雪色雪花雪余痕』\n\n---  _《9-nine-》_ ", "description": "工艺品（Artifact），白巳津川市自行制作的动画《轮回转生的莫比乌斯环》（虽然收视率极低）中的道具居然来到了现实！拥有它的人都会获得独有的特殊能力，这一切的一切都要从那场地震开始。\n\n「千年之前，本世界和异世界是互通的，而工艺品正是异世界的魔法道具。由于种种原因，出现了一个叫「生命之树」的组织，将所有的工艺品回收后设下了法阵，阻止了两个世界的流通。但是由于地震，法阵被破坏，于是工艺品便流向了这个世界。」------来自异世界的玩偶索菲提娅如是说道。\n\n在索菲的帮助下，我们的主角新海翔带领四位女主与反派进行激烈的斗争，最终成功阻止其使用工艺品犯下不可饶恕的错误。不过，为了根除这个问题，新海翔和索菲决定断绝两个世界的联系，重新打开封印。\n\n封印的法阵可以看做两个 $9 \\times 9$ 的黑白方阵，新海翔和索菲分别可以控制一个方阵，他们可以做如下动作：\n\n- 新海翔将自己面前的方阵向左或向右旋转 $90$ 度；\n- 索菲将自己面前的方阵向左或向右旋转 $90$ 度（两个方阵不联动）；\n- 新海翔和索菲选择方阵的同一列，进行交换；\n\n当新海翔一侧的方阵全是白色，同时索菲一侧的方阵全是黑色，那么封印就完成了，法阵将会开启，断开两个世界的联系，大家可以回归正常生活。\n\n时间有限，请你------我们的「第九人（Nine）」，帮助他们在 $999$ 步内完成这个封印。\n\n话虽如此，但是出题人被警告题出太难了，所以决定缩小数据范围！\n\n具体的，将方阵的边长减小至 $3$，同时步数减小至 $9\\times 9=81$！\n\n形式化地说，有两个 $3 \\times 3$ 的 01 矩阵 $A$ 和 $B$，你可以做如下操作：\n\n- 操作 $1$：选择矩阵 $A$ 或 $B$，将其向左或向右旋转 $90$ 度；\n- 操作 $2$：选择一个整数 $k$ ($1 \\le k \\le 3$)，将两矩阵的第 $k$ 列交换。\n\n请在 $81$ 次操作内将 $A$ 变为全 0 矩阵。数据保证此时 $B$ 一定为全 1 矩阵。", "inputFormat": "第 $1 \\sim 3$ 行，每行是一个长度为 $3$ 的 01 字符串，表示矩阵 $A$ 的初始状态；\n\n第 $4 \\sim 6$ 行，每行是一个长度为 $3$ 的 01 字符串，表示矩阵 $B$ 的初始状态。\n\n数据保证在有限次操作内，可以将 $A$ 变为全 0 矩阵，$B$ 变为全 1 矩阵。", "outputFormat": "第一行一个整数 $N$ ($0 \\le N \\le 81$)，表示你一共需要进行 $N$ 次操作。\n\n接下来的 $N$ 行表示你依次进行的操作。请按如下格式输出：\n\n- 如果你选择使用操作 $1$，请输出矩阵名与旋转方向。具体地：\n  - 若你想将 $A$ 矩阵向左旋转 $90$ 度，输出 $\\tt{AL}$；\n  - 若你想将 $A$ 矩阵向右旋转 $90$ 度，输出 $\\tt{AR}$；\n  - 若你想将 $B$ 矩阵向左旋转 $90$ 度，输出 $\\tt{BL}$；\n  - 若你想将 $B$ 矩阵向右旋转 $90$ 度，输出 $\\tt{BR}$。\n- 如果你选择使用操作 $2$，请输出 $\\tt{C}$ 与列号。例如，你要交换两个矩阵的第 $2$ 列，请输出 $\\tt{C2}$。\n\n其中，将一个矩阵向左旋转，指逆时针旋转；将一个矩阵向右旋转，指顺时针旋转。\n\n请注意：**不要输出多余的行末空格与文末回车**。", "hint": "可以证明，在数据合法的情况下，原题在 $999$ 步内一定存在解，弱化版的题目在 $81$ 步内一定存在解。\n\n~~最重要的是还在分割商法的《9-nine-》今年即将推出新作，预计冬季上架某平台。~~", "locale": "zh-CN"}}}
{"pid": "P12534", "type": "P", "difficulty": 4, "samples": [["2\n9 3\n1 3\n2 1\n7 5\n9 3\n2 8\n1 5\n4 1\n6 5\n4 4\n1 2\n2 3\n4 2", "11\n9 3 1 5 7 5 6 5 1 2 8\n5\n3 2 1 2 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2025", "Special Judge", "O2优化", "树论", "构造", "高校校赛"], "title": "[XJTUPC 2025] 奥日", "background": "", "description": "精灵古树是尼博尔山的生命之源，其根系中流淌的流光维系着整片森林的生态平衡。古树的躯体由 $n$ 枚光之核心构成，这些璀璨如星的光点通过 $n−1$ 条能量枝干交织成无环的树状脉络。任意两枚核心之间，都有一条唯一的能量枝干通道蜿蜒相连，仿佛命运编织的丝线。\n\n而奥日，本是古树孕育的守护灵体，却在雷霆撕裂苍穹的雨夜，被狂暴的飓风卷入深渊。失去奥日的古树试图通过光之仪式呼唤他归来，但失控的能量反噬让它陷入永夜，原本澄澈的核心如今爬满黑暗的纹路。\n\n如今，归来的奥日必须激活所有被侵蚀的核心：当他首次触碰某个核心时，纯净能量会驱散黑暗；但重复经过时，紊乱的能量将累计形成过载波动。古树的法则严苛限定------整条路径中，重复触发的波动总和不得超过 $k$ 次。\n\n此刻，奥日悬浮在星网交织的虚空中。他可以从任意核心启程，沿着能量枝干的轨迹穿梭。奥日需要在蜿蜒的能量枝干间规划路径，在限制内点亮最多的核心。\n\n唯有让尽可能多的光之核心重新共鸣，才能唤醒古树真正的力量，让治愈的流光再次奔涌在尼博尔山的每一片叶脉中！尼博尔山将迎来破晓，而黑暗，终会在这片星网的共振中灰飞烟灭……\n\n形式化的，给定一个非负整数 $k$，给出一颗无根树 $T=(V,E)$，$V=\\{1,2,\\dots,n\\}$。\n\n定义一条由 $m$ 个可重点构成的路径 $l=(u_1,u_2,u_3,\\dots,u_m)$ 满足：对于任意的 $1\\le i\\le m-1$ 有 $(u_i,u_{i+1})\\in E$。如果存在 $1\\le i<j\\le m$，使得 $u_i=u_j$，则仍然认为 $l$ 是一条路径。\n\n定义路径 $l$ 上的本质不同点集 $V'=\\{v\\mid v=u_i,\\exists i\\in [1, m]\\}$。记 $|V'|$ 为集合 $V'$ 的大小。记路径 $l$ 上的重复点数量为 $s$，有 $s=m-|V'|$。\n\n你需要找到一条路径 $l$，在满足 $s\\le k$ 的情况下，最大化 $|V'|$。\n\n你需要输出这条路径。如果存在多组路径满足条件，输出任意一条满足题意的路径，就会被认为正确。", "inputFormat": "输入包含多个测试用例。数据的第一行包含一个整数 $t$ ($1 \\leq t \\leq 2\\times 10^3$) 表示测试用例数。接下来描述每个测试用例。\n\n每个测试用例的第一行包含两个整数 $n$ ($2\\le n\\le 2\\times 10^5$) 和 $k$ ($0\\le k\\le n$)，用一个空格分隔，分别表示树上点的个数和可重复点数量的最大值。注意，$k$ 的取值可能为 $0$。\n\n接下来 $n-1$ 行，每行两个正整数 $u$ 和 $v$ ($1\\le u,v\\le n$)，用一个空格分隔，表示树上存在一条边 $(u,v)$。保证该 $n-1$ 条边构成树。\n\n保证所有测试用例的 $n$ 之和不超过 $2\\times 10^5$。", "outputFormat": "对于每个测试用例，输出两行。\n\n第一行一个正整数 $m$，表示路径 $l$ 的可重点数量。路径 $l$ 需要在满足重复点数量 $s\\le k$ 的情况下，最大化本质不同点集大小 $|V'|$。\n\n第二行共 $m$ 个正整数 $u_1, u_2, u_3, \\dots, u_m$，每个正整数之间用一个空格分隔，表示路径 $l$ 为 $(u_1, u_2, u_3, \\dots, u_m)$。\n\n如果存在多组路径满足条件，输出任意一条满足题意的路径，就会被认为正确。\n\n可以被证明的，对于一个合法的路径，$m$ 一定有 $m\\le n+k$。输出的 $m$ 一定要满足 $m \\le n+k$，否则将直接返回 $\\tt{Wrong\\ Answer}$。", "hint": "对于第一组测试用例，$n=9$ 且 $k=3$，组成的树如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tqnhdaph.png)\n\n一组可行的解为：$l=(9,3,1,5,7,5,6,5,1,2,8)$。可以被证明的，此时本质不同点集大小 $|V'|$ 达到最大值 $8$，且重复点数量 $s=3\\le k$。\n\n对于第二组测试用例，$n=4$ 且 $k=4$，组成的树如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0awmv421.png)\n\n一组可行的解为：$l=(3,2,1,2,4)$。可以被证明的，此时本质不同点集大小 $|V'|$ 达到最大值 $4$，且重复点数量 $s=1\\le k$。\n\n由于本题输入输出数据规模较大，建议使用较为快速的输入输出方式。", "locale": "zh-CN", "translations": {"en": {"title": "[XJTUPC 2025] Ori", "background": "", "description": "The Spirit Tree is the source of life on Nibel Mountain, with its roots flowing with light that maintains the ecological balance of the entire forest. The body of the ancient tree is composed of $n$ cores of light, which are interconnected by $n−1$ energy branches to form an acyclic tree structure. Between any two cores, there is a unique energy branch path winding between them, as if woven by the threads of fate.\n\nOri, originally the guardian spirit nurtured by the ancient tree, was swept into the abyss by a violent storm on a rainy night when thunder tore the sky apart. The ancient tree, having lost Ori, attempted to call him back through a light ritual, but the uncontrolled energy backlash plunged it into eternal night, and the once clear cores are now covered with dark patterns.\n\nNow, the returning Ori must activate all the eroded cores: when he first touches a core, pure energy will dispel the darkness; however, upon repeated passes, chaotic energy will accumulate to form overload waves. The ancient tree's laws strictly limit that the total number of repeated triggered waves along the entire path must not exceed $k$.\n\nAt this moment, Ori is suspended in the void woven by the star network. He can start from any core and traverse along the trajectories of the energy branches. Ori needs to plan a path among the winding energy branches to light up the maximum number of cores within the limits.\n\nOnly by resonating with as many light cores as possible can the true power of the ancient tree be awakened, allowing the healing light to surge again through every leaf vein of Nibel Mountain! Nibel Mountain will welcome dawn, and darkness will eventually be reduced to ashes in the resonance of this star network...\n\nFormally, given a non-negative integer $k$, provide an unrooted tree $T=(V,E)$, where $V=\\{1,2,\\dots,n\\}$.\n\nDefine a path $l=(u_1,u_2,u_3,\\dots,u_m)$ composed of $m$ vertices such that for any $1\\le i\\le m-1$, $(u_i,u_{i+1})\\in E$. If there exists $1\\le i<j\\le m$ such that $u_i=u_j$, the path $l$ is still considered valid.\n\nDefine the set of essential distinct points on path $l$ as $V'=\\{v\\mid v=u_i,\\exists i\\in [1, m]\\}$. Let $|V'|$ be the size of the set $V'$. Let the number of repeated points on path $l$ be $s$, where $s=m-|V'|$.\n\nYou need to find a path $l$ that maximizes $|V'|$ while satisfying $s\\le k$.\n\nYou need to output this path. If there are multiple paths that satisfy the conditions, output any one valid path, and it will be considered correct.", "inputFormat": "The input contains multiple test cases. The first line of data contains an integer $t$ ($1 \\leq t \\leq 2\\times 10^3$) indicating the number of test cases. The following describes each test case.\n\nThe first line of each test case contains two integers $n$ ($2\\le n\\le 2\\times 10^5$) and $k$ ($0\\le k\\le n$), separated by a space, representing the number of points on the tree and the maximum number of repeatable points. Note that $k$ can be $0$.\n\nThe next $n-1$ lines each contain two positive integers $u$ and $v$ ($1\\le u,v\\le n$), separated by a space, indicating that there is an edge $(u,v)$ on the tree. It is guaranteed that these $n-1$ edges form a tree.\n\nIt is guaranteed that the sum of $n$ for all test cases does not exceed $2\\times 10^5$.", "outputFormat": "For each test case, output two lines.\n\nThe first line contains a positive integer $m$, indicating the number of vertices in path $l$. The path $l$ must maximize the size of the essential distinct point set $|V'|$ while satisfying the number of repeated points $s\\le k$.\n\nThe second line contains $m$ positive integers $u_1, u_2, u_3, \\dots, u_m$, separated by spaces, indicating that the path $l$ is $(u_1, u_2, u_3, \\dots, u_m)$.\n\nIf there are multiple paths that satisfy the conditions, output any one valid path, and it will be considered correct.\n\nIt can be proven that for a valid path, $m$ must satisfy $m\\le n+k$. The output $m$ must satisfy $m \\le n+k$, otherwise it will directly return $\\tt{Wrong\\ Answer}$.", "hint": "For the first test case, $n=9$ and $k=3$, the tree formed is as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tqnhdaph.png)\n\nOne feasible solution is: $l=(9,3,1,5,7,5,6,5,1,2,8)$. It can be proven that the size of the essential distinct point set $|V'|$ reaches the maximum value of $8$, and the number of repeated points $s=3\\le k$.\n\nFor the second test case, $n=4$ and $k=4$, the tree formed is as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0awmv421.png)\n\nOne feasible solution is: $l=(3,2,1,2,4)$. It can be proven that the size of the essential distinct point set $|V'|$ reaches the maximum value of $4$, and the number of repeated points $s=1\\le k$.\n\nDue to the large input and output data size for this problem, it is recommended to use faster input and output methods.", "locale": "en"}, "zh-CN": {"title": "[XJTUPC 2025] 奥日", "background": "", "description": "精灵古树是尼博尔山的生命之源，其根系中流淌的流光维系着整片森林的生态平衡。古树的躯体由 $n$ 枚光之核心构成，这些璀璨如星的光点通过 $n−1$ 条能量枝干交织成无环的树状脉络。任意两枚核心之间，都有一条唯一的能量枝干通道蜿蜒相连，仿佛命运编织的丝线。\n\n而奥日，本是古树孕育的守护灵体，却在雷霆撕裂苍穹的雨夜，被狂暴的飓风卷入深渊。失去奥日的古树试图通过光之仪式呼唤他归来，但失控的能量反噬让它陷入永夜，原本澄澈的核心如今爬满黑暗的纹路。\n\n如今，归来的奥日必须激活所有被侵蚀的核心：当他首次触碰某个核心时，纯净能量会驱散黑暗；但重复经过时，紊乱的能量将累计形成过载波动。古树的法则严苛限定------整条路径中，重复触发的波动总和不得超过 $k$ 次。\n\n此刻，奥日悬浮在星网交织的虚空中。他可以从任意核心启程，沿着能量枝干的轨迹穿梭。奥日需要在蜿蜒的能量枝干间规划路径，在限制内点亮最多的核心。\n\n唯有让尽可能多的光之核心重新共鸣，才能唤醒古树真正的力量，让治愈的流光再次奔涌在尼博尔山的每一片叶脉中！尼博尔山将迎来破晓，而黑暗，终会在这片星网的共振中灰飞烟灭……\n\n形式化的，给定一个非负整数 $k$，给出一颗无根树 $T=(V,E)$，$V=\\{1,2,\\dots,n\\}$。\n\n定义一条由 $m$ 个可重点构成的路径 $l=(u_1,u_2,u_3,\\dots,u_m)$ 满足：对于任意的 $1\\le i\\le m-1$ 有 $(u_i,u_{i+1})\\in E$。如果存在 $1\\le i<j\\le m$，使得 $u_i=u_j$，则仍然认为 $l$ 是一条路径。\n\n定义路径 $l$ 上的本质不同点集 $V'=\\{v\\mid v=u_i,\\exists i\\in [1, m]\\}$。记 $|V'|$ 为集合 $V'$ 的大小。记路径 $l$ 上的重复点数量为 $s$，有 $s=m-|V'|$。\n\n你需要找到一条路径 $l$，在满足 $s\\le k$ 的情况下，最大化 $|V'|$。\n\n你需要输出这条路径。如果存在多组路径满足条件，输出任意一条满足题意的路径，就会被认为正确。", "inputFormat": "输入包含多个测试用例。数据的第一行包含一个整数 $t$ ($1 \\leq t \\leq 2\\times 10^3$) 表示测试用例数。接下来描述每个测试用例。\n\n每个测试用例的第一行包含两个整数 $n$ ($2\\le n\\le 2\\times 10^5$) 和 $k$ ($0\\le k\\le n$)，用一个空格分隔，分别表示树上点的个数和可重复点数量的最大值。注意，$k$ 的取值可能为 $0$。\n\n接下来 $n-1$ 行，每行两个正整数 $u$ 和 $v$ ($1\\le u,v\\le n$)，用一个空格分隔，表示树上存在一条边 $(u,v)$。保证该 $n-1$ 条边构成树。\n\n保证所有测试用例的 $n$ 之和不超过 $2\\times 10^5$。", "outputFormat": "对于每个测试用例，输出两行。\n\n第一行一个正整数 $m$，表示路径 $l$ 的可重点数量。路径 $l$ 需要在满足重复点数量 $s\\le k$ 的情况下，最大化本质不同点集大小 $|V'|$。\n\n第二行共 $m$ 个正整数 $u_1, u_2, u_3, \\dots, u_m$，每个正整数之间用一个空格分隔，表示路径 $l$ 为 $(u_1, u_2, u_3, \\dots, u_m)$。\n\n如果存在多组路径满足条件，输出任意一条满足题意的路径，就会被认为正确。\n\n可以被证明的，对于一个合法的路径，$m$ 一定有 $m\\le n+k$。输出的 $m$ 一定要满足 $m \\le n+k$，否则将直接返回 $\\tt{Wrong\\ Answer}$。", "hint": "对于第一组测试用例，$n=9$ 且 $k=3$，组成的树如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tqnhdaph.png)\n\n一组可行的解为：$l=(9,3,1,5,7,5,6,5,1,2,8)$。可以被证明的，此时本质不同点集大小 $|V'|$ 达到最大值 $8$，且重复点数量 $s=3\\le k$。\n\n对于第二组测试用例，$n=4$ 且 $k=4$，组成的树如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0awmv421.png)\n\n一组可行的解为：$l=(3,2,1,2,4)$。可以被证明的，此时本质不同点集大小 $|V'|$ 达到最大值 $4$，且重复点数量 $s=1\\le k$。\n\n由于本题输入输出数据规模较大，建议使用较为快速的输入输出方式。", "locale": "zh-CN"}}}
{"pid": "P12535", "type": "P", "difficulty": 5, "samples": [["2\n20\n7 5\n9 5\n13 13\n5 9\n5 7\n-5 7\n-5 9\n-13 13\n-9 5\n-7 5\n-7 -5\n-9 -5\n-13 -13\n-5 -9\n-5 -7\n5 -7\n5 -9\n13 -13\n9 -5\n7 -5\n4\n1 1\n-1 1\n-1 -1\n1 -1", "YES\nNO"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["计算几何", "2025", "Special Judge", "O2优化", "凸包", "高校校赛"], "title": "[XJTUPC 2025] 棱堡", "background": "", "description": "棱堡（Bastion）是第一种仅靠直射火力而不存在攻击死角的堡垒。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ly4kphsw.png)\n\n简单非退化多边形是由 $n$ ($n\\ge 3$) 个顶点序列组成的闭合多边形 **区域**，满足以下条件：\n\n- 顶点序列首尾相连，形成 $n$ 条边，构成平面紧致闭集（含所有边界和内部点）；\n- $n$ 条边仅在顶点处相接且互不相交（相邻边在公共顶点外无其他交点）；\n- $n$ 个顶点互不重合，且不位于任何非相邻边的内部，且任意三个连续的顶点不共线。\n\n棱堡可以被视为由 $n$ 个点和 $n$ 条边组成的简单非退化多边形。对于多边形边上互异两点 $P$ 和 $Q$，我们定义点 $P$ 可以火力直射点 $Q$，当且仅当线段 $PQ$ 与多边形只交于 $P$ 和 $Q$ 两点。如下图所示，点 $A$ 和 $B$ 不能火力直射点 $X$，但是点 $C$ 可以。如果对于多边形边上一点 $P$，不存在多边形边上另外一点 $Q$ 使得点 $Q$ 可以火力直射 $P$，则我们称点 $P$ 为该多边形的火力盲区。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bz90r7zy.png)\n\n我们称一个简单非退化多边形是棱堡，当且仅当其至多存在有限个点是火力盲区。给定一个简单非退化多边形，请判断其是否是一个棱堡。\n\n形式化而言，给定一个简单非退化多边形，请判断其是否只有有限个位于多边形边上的点 $P$ 满足，不存在多边形边上的另外一点 $Q$，使得 $PQ$ 线段与多边形的交集只包含 $P$ 和 $Q$。", "inputFormat": "输入包含多组测试用例。数据的第一行包含一个整数 $t$ ($1 \\leq t \\leq 10^4$) 表示测试用例数。接下来描述每个测试用例。\n\n每个测试用例的第一行包含一个整数 $n$ ($3 \\leq n \\leq 10^5$)，为多边形的边数。\n\n接下来 $n$ 行，每行包含两个整数 $x_i$ 和 $y_i$ ($-10^9 \\leq x_i, y_i \\leq 10^9$)，描述多边形的一个顶点。\n\n输入数据保证构成简单非退化多边形。顶点以逆时针顺序给出，即按顺序走过所有顶点后恰好逆时针旋转 $360^\\circ$。按顶点的输入顺序依次连边（第 $i$ 个顶点连向第 $i + 1$ 个顶点，第 $n$ 个顶点连回第 $1$ 个顶点）。\n\n保证所有测试用例的 $n$ 之和不超过 $2 \\times 10^5$。", "outputFormat": "对于每个测试用例，输出仅包含一行一个字符串，如果多边形是棱堡，输出 $\\tt{YES}$，否则输出 $\\tt{NO}$。答案对大小写不敏感。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[XJTUPC 2025] Bastion", "background": "", "description": "A bastion is the first type of fortress that relies solely on direct firepower and has no attack blind spots.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ly4kphsw.png)\n\nA simple non-degenerate polygon is a closed polygonal $\\textbf{region}$ composed of a sequence of $n$ ($n\\ge 3$) vertices, satisfying the following conditions:\n\n- The vertex sequence connects end to end, forming $n$ edges, constituting a compact closed set in the plane (including all boundary and interior points);\n- The $n$ edges only meet at the vertices and do not intersect each other (adjacent edges have no other intersection points outside the common vertex);\n- The $n$ vertices are distinct, not located inside any non-adjacent edges, and any three consecutive vertices are not collinear.\n\nThe bastion can be viewed as a simple non-degenerate polygon composed of $n$ points and $n$ edges. For two distinct points $P$ and $Q$ on the edges of the polygon, we define that point $P$ can directly fire at point $Q$ if and only if the line segment $PQ$ intersects the polygon only at points $P$ and $Q$. As shown in the figure below, points $A$ and $B$ cannot directly fire at point $X$, but point $C$ can. If there is a point $P$ on the edge of the polygon such that there is no other point $Q$ on the edge of the polygon for which point $Q$ can directly fire at $P$, then we call point $P$ a fire blind spot of the polygon.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bz90r7zy.png)\n\nWe call a simple non-degenerate polygon a bastion if and only if it has at most a finite number of points that are fire blind spots. Given a simple non-degenerate polygon, please determine whether it is a bastion.\n\nFormally, given a simple non-degenerate polygon, please determine whether there are only a finite number of points $P$ located on the edges of the polygon such that there is no other point $Q$ on the edges of the polygon for which the line segment $PQ$ intersects the polygon only at points $P$ and $Q$.", "inputFormat": "The input contains multiple test cases. The first line of the data contains an integer $t$ ($1 \\leq t \\leq 10^4$) indicating the number of test cases. The following describes each test case.\n\nThe first line of each test case contains an integer $n$ ($3 \\leq n \\leq 10^5$), which is the number of edges of the polygon.\n\nThe next $n$ lines each contain two integers $x_i$ and $y_i$ ($-10^9 \\leq x_i, y_i \\leq 10^9$), describing a vertex of the polygon.\n\nThe input data guarantees that a simple non-degenerate polygon is formed. The vertices are given in counterclockwise order, that is, after traversing all the vertices in order, it rotates exactly $360^\\circ$ counterclockwise. Connect edges in sequence according to the input order of the vertices (the $i$-th vertex is connected to the $(i+1)$-th vertex, and the $n$-th vertex is connected back to the $1$-st vertex).\n\nIt is guaranteed that the sum of $n$ for all test cases does not exceed $2 \\times 10^5$.\n", "outputFormat": "For each test case, output a single line containing a string. If the polygon is a bastion, output $\\tt{YES}$; otherwise, output $\\tt{NO}$. The answer is case insensitive.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[XJTUPC 2025] 棱堡", "background": "", "description": "棱堡（Bastion）是第一种仅靠直射火力而不存在攻击死角的堡垒。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ly4kphsw.png)\n\n简单非退化多边形是由 $n$ ($n\\ge 3$) 个顶点序列组成的闭合多边形 **区域**，满足以下条件：\n\n- 顶点序列首尾相连，形成 $n$ 条边，构成平面紧致闭集（含所有边界和内部点）；\n- $n$ 条边仅在顶点处相接且互不相交（相邻边在公共顶点外无其他交点）；\n- $n$ 个顶点互不重合，且不位于任何非相邻边的内部，且任意三个连续的顶点不共线。\n\n棱堡可以被视为由 $n$ 个点和 $n$ 条边组成的简单非退化多边形。对于多边形边上互异两点 $P$ 和 $Q$，我们定义点 $P$ 可以火力直射点 $Q$，当且仅当线段 $PQ$ 与多边形只交于 $P$ 和 $Q$ 两点。如下图所示，点 $A$ 和 $B$ 不能火力直射点 $X$，但是点 $C$ 可以。如果对于多边形边上一点 $P$，不存在多边形边上另外一点 $Q$ 使得点 $Q$ 可以火力直射 $P$，则我们称点 $P$ 为该多边形的火力盲区。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bz90r7zy.png)\n\n我们称一个简单非退化多边形是棱堡，当且仅当其至多存在有限个点是火力盲区。给定一个简单非退化多边形，请判断其是否是一个棱堡。\n\n形式化而言，给定一个简单非退化多边形，请判断其是否只有有限个位于多边形边上的点 $P$ 满足，不存在多边形边上的另外一点 $Q$，使得 $PQ$ 线段与多边形的交集只包含 $P$ 和 $Q$。", "inputFormat": "输入包含多组测试用例。数据的第一行包含一个整数 $t$ ($1 \\leq t \\leq 10^4$) 表示测试用例数。接下来描述每个测试用例。\n\n每个测试用例的第一行包含一个整数 $n$ ($3 \\leq n \\leq 10^5$)，为多边形的边数。\n\n接下来 $n$ 行，每行包含两个整数 $x_i$ 和 $y_i$ ($-10^9 \\leq x_i, y_i \\leq 10^9$)，描述多边形的一个顶点。\n\n输入数据保证构成简单非退化多边形。顶点以逆时针顺序给出，即按顺序走过所有顶点后恰好逆时针旋转 $360^\\circ$。按顶点的输入顺序依次连边（第 $i$ 个顶点连向第 $i + 1$ 个顶点，第 $n$ 个顶点连回第 $1$ 个顶点）。\n\n保证所有测试用例的 $n$ 之和不超过 $2 \\times 10^5$。", "outputFormat": "对于每个测试用例，输出仅包含一行一个字符串，如果多边形是棱堡，输出 $\\tt{YES}$，否则输出 $\\tt{NO}$。答案对大小写不敏感。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12536", "type": "P", "difficulty": 7, "samples": [["4 5 7\n3 5 2\n5 4 3\n3 1 2\n2 5 1\n2 1\n4 2\n1 5\n3 2\n1 1 4\n2 1\n1 2 3\n2 2\n3 3\n1 1 3\n2 2", "29\n25\n63"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["2025", "O2优化", "分块", "差分", "高校校赛"], "title": "[XJTUPC 2025] 我永远喜欢希儿·芙乐艾", "background": "", "description": "**请注意本题不同寻常的空间限制。**\n\n给定 **操作序列** $A$ 和一棵有根树 $T$，$A$ 中的每个操作都形如「给 $T$ 中 $u$ 到 $v$ 的简单路径上的所有点权增加 $x$」。其中，$u$ 到 $v$ 的简单路径定义为：从 $u$ 开始到 $v$ 结束的一条不重复访问任何节点和边的路径。\n\n初始时 $T$ 的根为 $1$，所有点权皆为 $0$。\n\n你需要执行三种操作：\n\n- 给定区间 $[l,r]$，依次执行 $A_l, A_{l+1}\\dots$ 到 $A_r$ 的操作；\n- 查询 $T$ 以 $x$ 为根的子树和；\n- 换 $T$ 的根到 $y$（若当前根为 $y$，则不进行操作）。", "inputFormat": "第一行包含三个正整数 $n_1$, $n_2$ 和 $m$ ($1\\le n_1,n_2,m \\le 1\\times 10^5$)，用一个空格分隔，分别表示 $A$ 的长度、$T$ 的总点数、询问与操作的次数。\n\n接下来 $n_1$ 行，第 $i$ 行包含三个整数 $u_i$, $v_i$ 和 $x_i$ ($1\\le u_i,v_i\\le n_2, 1\\le x_i\\le 1\\times 10^2$)，用一个空格分隔，表示操作 $A_i$ 为「给 $T$ 中 $u_i$ 到 $v_i$ 的简单路径上的所有点权增加 $x_i$」。\n\n接下来 $n_2-1$ 行，每行包含两个正整数 $u$ 和 $v$ ($1\\le u,v \\le n_2$)，用一个空格分隔，表示树的一条边。保证该 $n_2-1$ 条边构成树。\n\n接下来 $m$ 行，每行的第一个数 $op$ ($op\\in \\{1,2,3\\}$) 表示操作编号，随后：\n\n- 若 $op$ 为 $1$，则后面跟随两个正整数 $l$ 和 $r$ ($1\\le l\\le r\\le n_1$)，用一个空格分隔，表示依次执行 $A_l, A_{l+1} \\dots A_r$ 的操作；\n- 若 $op$ 为 $2$，则后面跟随一个正整数 $x$ ($1\\le x\\le n_2$)，表示查询 $T$ 以 $x$ 为根的子树和；\n- 若 $op$ 为 $3$，则后面跟随一个正整数 $y$ ($1\\le y\\le n_2$)，表示换 $T$ 的根到 $y$（若当前根为 $y$，则不进行操作）。", "outputFormat": "对于每个操作 $2$，输出一行一个整数，表示 $T$ 以 $x$ 为根的子树和。\n\n数据保证答案在有符号超长整型所表达的范围内。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[XJTUPC 2025] Seele Vollerei", "background": "", "description": "**Please note the unusual space constraints for this problem.**\n\nGiven $\\textbf{an operation sequence}$ $A$ and a rooted tree $T$, each operation in $A$ is like ''add $x$ to all point weights on the simple path from $u$ to $v$ in $T$.'' The simple path from $u$ to $v$ is defined as a path starting from $u$ and ending at $v$ that does not repeatedly visit any nodes or edges.\n\nInitially, the root of $T$ is $1$, and all point weights are $0$.\n\nYou need to perform three operations:\n\n- Given an interval $[l,r]$, perform operations from $A_l, A_{l+1}\\dots$ to $A_r$ in sequence;\n- Query the sum of the subtrees of $T$ with $x$ as the root;\n- Change the root of $T$ to $y$ (If the current root is $y$, no operation will be performed).", "inputFormat": "The first line contains three positive integers $n_1$, $n_2$, and $m$ ($1\\le n_1,n_2,m \\le 1\\times 10^5$), separated by a space, representing the length of $A$, the total number of points in $T$, and the number of inquiries and operations.\n\nThe next $n_1$ lines, the $i$-th line contains three integers $u_i$, $v_i$, and $x_i$ ($1\\le u_i,v_i\\le n_2, 1\\le x_i\\le 1\\times 10^2$), separated by a space, representing the operation $A_i$ as ''add $x_i$ to all point weights on the simple path from $u_i$ to $v_i$ in $T$.''\n\nNext, there are $n_2-1$ lines, each containing two positive integers $u$ and $v$ ($1\\le u,v \\le n_2$), separated by a space, representing an edge of the tree. It is guaranteed that the $n_2-1$ edges form a tree.\n\nNext, there are $m$ lines. The first number $op$ ($op\\in \\{1,2,3\\}$) in each line indicates the operation number, followed by:\n\n- If $op$ is $1$, it is followed by two positive integers $l$ and $r$ ($1\\le l\\le r\\le n_1$), separated by a space, indicating that the operations of $A_l, A_{l+1} \\dots A_r$ are executed in sequence;\n- If $op$ is $2$, it is followed by a positive integer $x$ ($1\\le x\\le n_2$), indicating that the sum of the subtrees of $T$ with $x$ as the root is queried;\n- If $op$ is $3$, it is followed by a positive integer $y$ ($1\\le y\\le n_2$), indicating that the root of $T$ is changed to $y$ (If the current root is $y$, no operation will be performed).", "outputFormat": "For each operation $2$, output one line of one integer, representing the sum of the subtrees of $T$ with $x$ as the root.\n\nThe data ensures that the answer is within the range expressed by a signed long long integer.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[XJTUPC 2025] 我永远喜欢希儿·芙乐艾", "background": "", "description": "**请注意本题不同寻常的空间限制。**\n\n给定 **操作序列** $A$ 和一棵有根树 $T$，$A$ 中的每个操作都形如「给 $T$ 中 $u$ 到 $v$ 的简单路径上的所有点权增加 $x$」。其中，$u$ 到 $v$ 的简单路径定义为：从 $u$ 开始到 $v$ 结束的一条不重复访问任何节点和边的路径。\n\n初始时 $T$ 的根为 $1$，所有点权皆为 $0$。\n\n你需要执行三种操作：\n\n- 给定区间 $[l,r]$，依次执行 $A_l, A_{l+1}\\dots$ 到 $A_r$ 的操作；\n- 查询 $T$ 以 $x$ 为根的子树和；\n- 换 $T$ 的根到 $y$（若当前根为 $y$，则不进行操作）。", "inputFormat": "第一行包含三个正整数 $n_1$, $n_2$ 和 $m$ ($1\\le n_1,n_2,m \\le 1\\times 10^5$)，用一个空格分隔，分别表示 $A$ 的长度、$T$ 的总点数、询问与操作的次数。\n\n接下来 $n_1$ 行，第 $i$ 行包含三个整数 $u_i$, $v_i$ 和 $x_i$ ($1\\le u_i,v_i\\le n_2, 1\\le x_i\\le 1\\times 10^2$)，用一个空格分隔，表示操作 $A_i$ 为「给 $T$ 中 $u_i$ 到 $v_i$ 的简单路径上的所有点权增加 $x_i$」。\n\n接下来 $n_2-1$ 行，每行包含两个正整数 $u$ 和 $v$ ($1\\le u,v \\le n_2$)，用一个空格分隔，表示树的一条边。保证该 $n_2-1$ 条边构成树。\n\n接下来 $m$ 行，每行的第一个数 $op$ ($op\\in \\{1,2,3\\}$) 表示操作编号，随后：\n\n- 若 $op$ 为 $1$，则后面跟随两个正整数 $l$ 和 $r$ ($1\\le l\\le r\\le n_1$)，用一个空格分隔，表示依次执行 $A_l, A_{l+1} \\dots A_r$ 的操作；\n- 若 $op$ 为 $2$，则后面跟随一个正整数 $x$ ($1\\le x\\le n_2$)，表示查询 $T$ 以 $x$ 为根的子树和；\n- 若 $op$ 为 $3$，则后面跟随一个正整数 $y$ ($1\\le y\\le n_2$)，表示换 $T$ 的根到 $y$（若当前根为 $y$，则不进行操作）。", "outputFormat": "对于每个操作 $2$，输出一行一个整数，表示 $T$ 以 $x$ 为根的子树和。\n\n数据保证答案在有符号超长整型所表达的范围内。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12537", "type": "P", "difficulty": 5, "samples": [["3\n6 1\n8 7\n8 -6\n10 -8\n2 5\n7 -9\n1 0\n6 1\n0 -6\n0 0\n8 2\n10 -8\n9 -5\n2 -9\n6 1\n7 4\n8 -4\n8 9\n3 -9\n1 0\n7 2", "3\n2\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "二分", "2025", "O2优化", "高校校赛"], "title": "[XJTUPC 2025] 罗斯飞鸽", "background": "", "description": "awa 正在参加一个叫做罗斯飞鸽的真人音游活动。在活动中，awa 要在指定的时间出现在指定的位置。\n\n具体来说，罗斯飞鸽的活动场地是一条无限长的直线。罗斯飞鸽一共有 $n$ 个判定点。第 $i$ 个判定点要求 awa 在时刻 $t_i$ 出现在位置 $x_i$。\n\nawa 的最大跑步速度是 $v$ 个单位每时刻。在时刻 $0$，awa 可以任意选择一个位置，随后开始游玩罗斯飞鸽。\n\nawa 想知道，自己最多能够达成多少个判定点。", "inputFormat": "第一行一个正整数 $T$ ($1\\le T \\le 5\\times 10^5$)，表示 awa 一共进行了 $T$ 次游戏。\n\n对于每次游戏，第一行两个正整数 $n$ 和 $v$ ($1\\le n \\le 5\\times 10^5$, $1 \\le v \\le 10^9$)，用一个空格分隔，表示判定点的数量和 awa 的最大速度。\n\n接下来 $n$ 行，每行两个整数 $t_i$ 和 $x_i$ ($0 \\le t_i, |x_i| \\le 10^9$)，用一个空格分隔，描述一个判定点。保证一局游戏中没有两个完全相同的判定点。\n\n保证 $T$ 轮游戏中 $n$ 的总和不超过 $5 \\times 10^5$。", "outputFormat": "一共 $T$ 行，每行一个整数，表示对应游戏中 awa 最多能达成多少个判定点。", "hint": "由于本题输入输出数据规模较大，建议使用较为快速的输入输出方式。例如 $\\tt{scanf}$ 和 $\\tt{printf}$。", "locale": "zh-CN", "translations": {"en": {"title": "[XJTUPC 2025] Gros-Phi", "background": "", "description": "Awa is participating in a live music game called Gros-Phi. In the event, Awa must appear at a specified location at a specified time.\n\nSpecifically, Gros-Phi's activity area is an infinitely long straight line. Gros-Phi has a total of $n$ scoring points. The $i$-th scoring point requires Awa to appear at position $x_i$ at time $t_i$.\n\nAwa's maximum running speed is $v$ units per moment. At time $0$, Awa can choose any position and then start playing Gros-Phi.\n\nAwa wants to know how many scoring points she can reach at most.", "inputFormat": "The first line contains a positive integer $T$ ($1\\le T \\le 5\\times 10^5$), indicating that Awa played a total of $T$ games.\n\nFor each game, the first line contains two positive integers $n$ and $v$ ($1\\le n \\le 5\\times 10^5$, $1 \\le v \\le 10^9$), separated by a space, indicating the number of decision points and the maximum speed of Awa.\n\nThe next $n$ lines, each containing two integers $t_i$ and $x_i$ ($0 \\le t_i, |x_i| \\le 10^9$), separated by a space, describe a scoring point. It is guaranteed that there are no two identical scoring points in a game.\n\nIt is guaranteed that the sum of $n$ in $T$ rounds of games does not exceed $5 \\times 10^5$.", "outputFormat": "There should be $T$ lines in total, each line contains one integer, indicating how many scoring points Awa can reach at most in the corresponding game.", "hint": "Since the input and output data of this question are large, it is recommended to use a faster input and output method, such as $\\tt{scanf}$ and $\\tt{printf}$.", "locale": "en"}, "zh-CN": {"title": "[XJTUPC 2025] 罗斯飞鸽", "background": "", "description": "awa 正在参加一个叫做罗斯飞鸽的真人音游活动。在活动中，awa 要在指定的时间出现在指定的位置。\n\n具体来说，罗斯飞鸽的活动场地是一条无限长的直线。罗斯飞鸽一共有 $n$ 个判定点。第 $i$ 个判定点要求 awa 在时刻 $t_i$ 出现在位置 $x_i$。\n\nawa 的最大跑步速度是 $v$ 个单位每时刻。在时刻 $0$，awa 可以任意选择一个位置，随后开始游玩罗斯飞鸽。\n\nawa 想知道，自己最多能够达成多少个判定点。", "inputFormat": "第一行一个正整数 $T$ ($1\\le T \\le 5\\times 10^5$)，表示 awa 一共进行了 $T$ 次游戏。\n\n对于每次游戏，第一行两个正整数 $n$ 和 $v$ ($1\\le n \\le 5\\times 10^5$, $1 \\le v \\le 10^9$)，用一个空格分隔，表示判定点的数量和 awa 的最大速度。\n\n接下来 $n$ 行，每行两个整数 $t_i$ 和 $x_i$ ($0 \\le t_i, |x_i| \\le 10^9$)，用一个空格分隔，描述一个判定点。保证一局游戏中没有两个完全相同的判定点。\n\n保证 $T$ 轮游戏中 $n$ 的总和不超过 $5 \\times 10^5$。", "outputFormat": "一共 $T$ 行，每行一个整数，表示对应游戏中 awa 最多能达成多少个判定点。", "hint": "由于本题输入输出数据规模较大，建议使用较为快速的输入输出方式。例如 $\\tt{scanf}$ 和 $\\tt{printf}$。", "locale": "zh-CN"}}}
{"pid": "P12538", "type": "P", "difficulty": 5, "samples": [["4\n1 4 2 3", "3"], ["9\n11 4 5 14 19 1 9 8 10", "6"], ["1\n1", "1"], ["12\n4 3 7 6 8 11 9 10 12 14 13 15", "90"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "O2优化", "高校校赛"], "title": "[XJTUPC 2025] 泰拉构史", "background": "「我相信我们之间的联系会超越时间和空间。」\n\n「就算是海洋沸腾、大气消失，就算我们的卫星接连坠入重力的漩涡，就算我们的太阳凶恶地膨胀，无情地吃掉它的孩子直至万籁俱寂……我们也一样能再见面。」\n\n「在那用黑暗和星点光芒装饰的文明尽头，我们也一样会再见面。一定。」\n\n「我会等到那一天。我肯定会等到那一天。等我。你也要等我。」\n\n「这里万籁俱寂……太安静了。别留下我。」\n\n你是罗德岛的博士，是巴别塔的恶灵，但你更是普瑞赛斯的预言家。文明危在旦夕，但万幸的是，你在一切都来不及之前还是想起了她。去吧，将她自黑暗中找回，不要背叛了在时间中等待的她。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4p32bj2m.png)", "description": "这是解开谜团的第一步，一道计数题。\n\n有一个长度为 $n$ 的序列 $a_1, a_2, \\dots, a_n$，**序列中的元素互不相同**，一次操作定义如下：\n\n- 选择一个下标 $i$ ($1\\le i\\le n-1$) 满足 $|a_i-a_{i+1}|=1$，在序列中交换 $a_i$ 与 $a_{i+1}$。\n\n你可以进行 **任意次** 操作。你能得到多少种不同的序列？由于答案较大，请输出答案对 $998244353$ 取模的结果。\n\n两个序列 $a_1, a_2, \\dots, a_n$ 和 $b_1, b_2, \\dots b_n$ 不同当且仅当存在 $i\\in [1,n]$ 使得 $a_i\\neq b_i$。", "inputFormat": "输入共两行。\n\n第一行一个正整数 $n$ ($1\\le n\\le 10^6$) ，表示序列的长度。\n\n第二行 $n$ 个正整数 $a_i$ ($1\\le a_i\\le 10^9$)，用一个空格分隔，表示初始的序列为 $a_1, a_2, \\dots, a_n$。数据保证序列中的 $a_i$ 互不相同。", "outputFormat": "输出仅一个正整数，表示可能的序列的个数对 $998244353$ 取模的结果。", "hint": "对于第一组样例，初始时的序列为 $1,4,2,3$。注意，初始时的序列也是一种可能的序列，需要计数。\n\n对序列 $1,4,2,3$，因为 $|a_3 - a_4| = 1$，此时可以交换 $a_3, a_4$，交换后序列为 $1,4,3,2$。\n\n对序列 $1,4,3,2$，因为 $|a_2 - a_3| = 1$，此时可以交换 $a_2, a_3$，交换后序列为 $1,3,4,2$。\n\n可以证明，对于该序列，经过任意次操作不同的序列只有上述 $3$ 种可能。\n\n由于本题输入输出数据规模较大，建议使用较为快速的输入输出方式。", "locale": "zh-CN", "translations": {"en": {"title": "[XJTUPC 2025] History of Terra", "background": "''Doctor, the connection between us will transcend even time and space. I am sure of it.''\n\n''Even if the ocean completely boils away and the atmosphere vanishes, even if all the moons in the sky are pulled into the vortex of our planet's gravity, and even if the sun continues to mercilessly expand, eventually swallowing up all its children until none can be heard... I am sure we will meet again.''\n\n''At the far end of our civilization, once adorned by darkness and the brilliance of the stars up above, we will meet once again.''\n\n''I will wait until that day comes. I promise you I will. Wait for me. You must wait for me, too.''\n\n''It's so quiet here... Too quiet. Don't leave me behind.''\n\nYou are the Doctor of Rhodes Island, the Babel's Omen. But above all, you are the Prophet of Priestess. Civilization teeters on the brink --- yet, against all odds, you remembered her before it was too late. Now go, pull her back from the darkness. Do not betray the one who waited through time itself.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4p32bj2m.png)", "description": "This is the first step to solve the mystery, a counting problem.\n\nThere is a sequence $a_1, a_2, \\dots, a_n$ of length $n$, **elements in the sequence are different**, and an operation is defined as follows:\n\n- Select a subscript $i$ ($1\\le i\\le n-1$) that satisfies $|a_i-a_{i+1}|=1$, and swap $a_i$ with $a_{i+1}$ in the sequence.\n\nYou can perform **any number of** operations. How many different sequences can you get? Since the answer is large, please output the answer modulo $998244353$.\n\nTwo sequences $a_1, a_2, \\dots, a_n$ and $b_1, b_2, \\dots b_n$ are different if and only if there exists $i\\in [1,n]$ such that $a_i\\neq b_i$.", "inputFormat": "There are two lines of input.\n\nThe first line contains a positive integer $n$ ($1\\le n\\le 10^6$), which indicates the length of the sequence.\n\nThe second line contains $n$ positive integers $a_i$ ($1\\le a_i\\le 10^9$), separated by a space, which indicates that the initial sequence is $a_1, a_2, \\dots, a_n$. The data guarantees that $a_i$ in the sequence are different.", "outputFormat": "Output a single positive integer, representing the number of possible sequences modulo $998244353$.", "hint": "For the first sample, the initial sequence is $1,4,2,3$. Note that the initial sequence is also a possible sequence and needs to be counted.\n\nFor the sequence $1,4,2,3$, since $|a_3 - a_4| = 1$, $a_3, a_4$ can be swapped, and the sequence after swapping is $1,4,3,2$.\n\nFor the sequence $1,4,3,2$, since $|a_2 - a_3| = 1$, $a_2, a_3$ can be swapped, and the sequence after swapping is $1,3,4,2$.\n\nIt can be proved that for this sequence, there are only the above $3$ possibilities for different sequences after any number of operations.\n\nSince the input and output data scale of this question is large, it is recommended to use a faster input and output method.\n", "locale": "en"}, "zh-CN": {"title": "[XJTUPC 2025] 泰拉构史", "background": "「我相信我们之间的联系会超越时间和空间。」\n\n「就算是海洋沸腾、大气消失，就算我们的卫星接连坠入重力的漩涡，就算我们的太阳凶恶地膨胀，无情地吃掉它的孩子直至万籁俱寂……我们也一样能再见面。」\n\n「在那用黑暗和星点光芒装饰的文明尽头，我们也一样会再见面。一定。」\n\n「我会等到那一天。我肯定会等到那一天。等我。你也要等我。」\n\n「这里万籁俱寂……太安静了。别留下我。」\n\n你是罗德岛的博士，是巴别塔的恶灵，但你更是普瑞赛斯的预言家。文明危在旦夕，但万幸的是，你在一切都来不及之前还是想起了她。去吧，将她自黑暗中找回，不要背叛了在时间中等待的她。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4p32bj2m.png)", "description": "这是解开谜团的第一步，一道计数题。\n\n有一个长度为 $n$ 的序列 $a_1, a_2, \\dots, a_n$，**序列中的元素互不相同**，一次操作定义如下：\n\n- 选择一个下标 $i$ ($1\\le i\\le n-1$) 满足 $|a_i-a_{i+1}|=1$，在序列中交换 $a_i$ 与 $a_{i+1}$。\n\n你可以进行 **任意次** 操作。你能得到多少种不同的序列？由于答案较大，请输出答案对 $998244353$ 取模的结果。\n\n两个序列 $a_1, a_2, \\dots, a_n$ 和 $b_1, b_2, \\dots b_n$ 不同当且仅当存在 $i\\in [1,n]$ 使得 $a_i\\neq b_i$。", "inputFormat": "输入共两行。\n\n第一行一个正整数 $n$ ($1\\le n\\le 10^6$) ，表示序列的长度。\n\n第二行 $n$ 个正整数 $a_i$ ($1\\le a_i\\le 10^9$)，用一个空格分隔，表示初始的序列为 $a_1, a_2, \\dots, a_n$。数据保证序列中的 $a_i$ 互不相同。", "outputFormat": "输出仅一个正整数，表示可能的序列的个数对 $998244353$ 取模的结果。", "hint": "对于第一组样例，初始时的序列为 $1,4,2,3$。注意，初始时的序列也是一种可能的序列，需要计数。\n\n对序列 $1,4,2,3$，因为 $|a_3 - a_4| = 1$，此时可以交换 $a_3, a_4$，交换后序列为 $1,4,3,2$。\n\n对序列 $1,4,3,2$，因为 $|a_2 - a_3| = 1$，此时可以交换 $a_2, a_3$，交换后序列为 $1,3,4,2$。\n\n可以证明，对于该序列，经过任意次操作不同的序列只有上述 $3$ 种可能。\n\n由于本题输入输出数据规模较大，建议使用较为快速的输入输出方式。", "locale": "zh-CN"}}}
{"pid": "P12539", "type": "P", "difficulty": 4, "samples": [["5\n4 3 1 2 5\n5\n2 4\n2 5\n1 3\n1 3\n1 5", "4\npeace\n2\n3\npeace"], ["10\n10 9 4 3 2 1 6 5 8 7\n3\n1 10\n2 9\n3 9", "peace\n7\n8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["线段树", "二分", "2025", "O2优化", "高校校赛"], "title": "[XJTUPC 2025] 结束乐队", "background": "", "description": "**「我是来结束乐队的」**\n\n某个少女乐队正在进行合照，可摄影师不怀好意，她打算对拍出的照片进行处理后再发布社交媒体，引起粉丝们的不满，这会导致乐队中某些成员人气的升降。她觉得这样就能结束这支乐队了。她的计划如下：\n\n已知少女乐队有 $n$ 个成员，从左到右排成一排照相，其中每个成员的初始人气排名并不相同，分别从排名第 $1$ 到第 $n$。摄影师打算拍 $k$ 张照片并在每次拍完之后公开到社交媒体，她的每张照片只包含乐队成员排列中连续的一段，这样这段照片中未出现成员中的人气排名最靠前的成员的粉丝就会红温脱粉，导致这名成员的排名下降一名（原低一名的成员排名会上升）。通过 $k$ 次操作，她成功打乱了乐队成员的排名，她的目的就达到了。 \n\n但现在她遇到了一个问题，因为乐队的成员太多了，对于每次截取下来的某一段照片，她不能判断哪个未出现的成员排名最靠前，所以她求助于你，希望你帮她解决问题。\n\n形式化的，给定一个从 $1$ 到 $n$ 的排列 $a_1, a_2, \\dots, a_n$，进行 $k$ 次操作，每次操作：\n\n- 给定一个区间 $[l,r]$，求 **当前排列中区间 $[l,r]$ 上未出现的最小正整数** 是多少，并设此数为 $x$（即 $x=\\min\\{p\\mid \\forall i \\in [l,r],p\\neq a_i,p\\geq 1\\}$）；\n  - 若 $x<n$，则输出 $x$，并交换当前排列 $a_1, a_2, \\dots, a_n$ 中数字 $x$ 与 $x+1$ 的位置；\n  - 若 $x\\ge n$，则输出字符串 $\\tt{peace}$。\n\n其中，从 $1$ 到 $n$ 的排列 $a_1, a_2, \\dots, a_n$，是指满足 $\\{a_1, a_2, \\dots, a_n\\} = \\{1, 2, \\dots n\\}$ 的一组数。", "inputFormat": "第一行包含一个正整数 $n$ ($1\\le n\\le 5\\times 10^5$)，表示排列的大小。\n\n第二行包含 $n$ 个正整数 $a_i$，用一个空格分隔，表示初始排列 $a_1, a_2, \\dots, a_n$ ($\\{a_1, a_2, \\dots, a_n\\} = \\{1, 2, \\dots n\\}$)。\n\n第三行一个正整数 $k$ ($1\\le k\\le 10^5$)，表示操作的次数。\n\n接下来 $k$ 行，每行两个正整数 $l$ 和 $r$ ($1\\le l\\le r\\le n$)，用一个空格分隔，表示操作的区间。", "outputFormat": "对于每个测试数据中的每次操作，给出答案，并执行修改。\n\n记排列 $a_1, a_2, \\dots, a_n$ 在区间 $[l,r]$ 上未出现的最小正整数为 $x$：\n  - 若 $x<n$，则输出 $x$，并交换当前排列 $a_1, a_2, \\dots, a_n$ 中数字 $x$ 与 $x+1$ 的位置；\n  - 若 $x\\ge n$，则输出字符串 $\\tt{peace}$。", "hint": "对于第一组样例：\n\n第一次操作 $[2,4]$，当前排列为 $4,3,1,2,5$。\n\n区间 $[2,4]$ 内未出现的最小正整数为 $4$，输出 $4$ 并交换排列中 $4$ 和 $5$ 的位置。\n\n第二次操作 $[2,5]$，当前排列为 $5,3,1,2,4$。\n\n区间 $[2,5]$ 内未出现的最小正整数为 $5$，输出 $\\tt{peace}$，排列不变。\n\n第三次操作 $[1,3]$，当前排列为 $5,3,1,2,4$。\n\n区间 $[1,3]$ 内未出现的最小正整数为 $2$，输出 $2$ 并交换排列中 $2$ 和 $3$ 的位置。\n\n第四次操作 $[1,3]$，当前排列为 $5,2,1,3,4$。\n\n区间 $[1,3]$ 内未出现的最小正整数为 $3$，输出 $3$ 并交换排列中 $3$ 和 $4$ 的位置。\n\n第五次操作 $[1,5]$，当前排列为 $5,2,1,4,3$。\n\n区间 $[1,5]$ 内未出现的最小正整数为 $6$，输出 $\\tt{peace}$，排列不变。", "locale": "zh-CN", "translations": {"en": {"title": "[XJTUPC 2025] Kessoku Band", "background": "", "description": "**\"I'm here to end the band\"**\n\nA girl band is taking a group photo, but the photographer has bad intentions. She plans to process the photos and then post them on social media, causing dissatisfaction among fans, which will cause the popularity of some members of the band to rise or fall. She thinks this will end the band. Her plan is as follows:\n\nIt is known that the girl band has $n$ members, who are lined up from left to right for the photo. The initial popularity ranking of each member is different, ranging from $1$ to $n$. The photographer plans to take $k$ photos and publish them on social media after each photo. Each of her photos only contains a continuous section of the band member permutation, so that the fans of the most popular member who does not appear in this photo will be extremely angry and quit following her, causing the ranking of this member to drop by one (the original ranking of the member who was one lower will rise). Through $k$ operations, she successfully disrupted the ranking of the band members, and her goal was achieved.\n\nBut now she has a problem because there are too many members in the band; for each captured photo, she can't judge which member who doesn't appear ranks first, so she turned to you for help, hoping you can help her solve the problem.\n\nFormally, given a permutation $a_1, a_2, \\dots, a_n$ from $1$ to $n$, perform $k$ operations, each operation:\n\n- Given an interval $[l,r]$, find **the smallest positive integer that does not appear in the interval $[l,r]$ in the current permutation**, and set this number to $x$ (i.e. $x=\\min\\{p\\mid \\forall i \\in [l,r],p\\neq a_i,p\\geq 1\\}$);\n- If $x<n$, output $x$, and swap the positions of the numbers $x$ and $x+1$ in the current permutation $a_1, a_2, \\dots, a_n$;\n- If $x\\ge n$, output the string $\\tt{peace}$.\n\nWherein, the permutation $a_1, a_2, \\dots, a_n$ from $1$ to $n$ refers to a set of numbers that satisfies $\\{a_1, a_2, \\dots, a_n\\} = \\{1, 2, \\dots n\\}$.", "inputFormat": "The first line contains a positive integer $n$ ($1\\le n\\le 5\\times 10^5$), indicating the size of the permutation.\n\nThe second line contains $n$ positive integers $a_i$, separated by a space, indicating the initial permutation $a_1, a_2, \\dots, a_n$ ($\\{a_1, a_2, \\dots, a_n\\} = \\{1, 2, \\dots n\\}$).\n\nThe third line contains a positive integer $k$ ($1\\le k\\le 10^5$), indicating the number of operations.\n\nThe next $k$ lines, each containing two positive integers $l$ and $r$ ($1\\le l\\le r\\le n$), separated by a space, indicate the range of operations.", "outputFormat": "For each operation in each test data, give the answer and perform the modification.\n\nRemember that the smallest positive integer that does not appear in the interval $[l,r]$ in the permutation $a_1, a_2, \\dots, a_n$ is $x$:\n\n- If $x<n$, output $x$ and swap the positions of the numbers $x$ and $x+1$ in the current permutation $a_1, a_2, \\dots, a_n$;\n- If $x\\ge n$, output the string $\\tt{peace}$.", "hint": "For the first sample:\n\nThe first operation is $[2,4]$, and the current permutation is $4,3,1,2,5$.\n\nThe smallest positive integer that does not appear in the interval $[2,4]$ is $4$. Output $4$ and swap the positions of $4$ and $5$ in the permutation.\n\nThe second operation is $[2,5]$, and the current permutation is $5,3,1,2,4$.\n\nThe smallest positive integer that does not appear in the interval $[2,5]$ is $5$. Output $\\tt{peace}$, and the permutation remains unchanged.\n\nThe third operation is $[1,3]$, and the current permutation is $5,3,1,2,4$.\n\nThe smallest positive integer that does not appear in the interval $[1,3]$ is $2$. Output $2$ and swap the positions of $2$ and $3$ in the permutation.\n\nThe fourth operation is $[1,3]$, and the current permutation is $5,2,1,3,4$.\n\nThe smallest positive integer that does not appear in the interval $[1,3]$ is $3$. Output $3$ and swap the positions of $3$ and $4$ in the permutation.\n\nThe fifth operation $[1,5]$, the current permutation is $5,2,1,4,3$.\n\nThe smallest positive integer that does not appear in the interval $[1,5]$ is $6$. Output $\\tt{peace}$, the permutation remains unchanged.", "locale": "en"}, "zh-CN": {"title": "[XJTUPC 2025] 结束乐队", "background": "", "description": "**「我是来结束乐队的」**\n\n某个少女乐队正在进行合照，可摄影师不怀好意，她打算对拍出的照片进行处理后再发布社交媒体，引起粉丝们的不满，这会导致乐队中某些成员人气的升降。她觉得这样就能结束这支乐队了。她的计划如下：\n\n已知少女乐队有 $n$ 个成员，从左到右排成一排照相，其中每个成员的初始人气排名并不相同，分别从排名第 $1$ 到第 $n$。摄影师打算拍 $k$ 张照片并在每次拍完之后公开到社交媒体，她的每张照片只包含乐队成员排列中连续的一段，这样这段照片中未出现成员中的人气排名最靠前的成员的粉丝就会红温脱粉，导致这名成员的排名下降一名（原低一名的成员排名会上升）。通过 $k$ 次操作，她成功打乱了乐队成员的排名，她的目的就达到了。 \n\n但现在她遇到了一个问题，因为乐队的成员太多了，对于每次截取下来的某一段照片，她不能判断哪个未出现的成员排名最靠前，所以她求助于你，希望你帮她解决问题。\n\n形式化的，给定一个从 $1$ 到 $n$ 的排列 $a_1, a_2, \\dots, a_n$，进行 $k$ 次操作，每次操作：\n\n- 给定一个区间 $[l,r]$，求 **当前排列中区间 $[l,r]$ 上未出现的最小正整数** 是多少，并设此数为 $x$（即 $x=\\min\\{p\\mid \\forall i \\in [l,r],p\\neq a_i,p\\geq 1\\}$）；\n  - 若 $x<n$，则输出 $x$，并交换当前排列 $a_1, a_2, \\dots, a_n$ 中数字 $x$ 与 $x+1$ 的位置；\n  - 若 $x\\ge n$，则输出字符串 $\\tt{peace}$。\n\n其中，从 $1$ 到 $n$ 的排列 $a_1, a_2, \\dots, a_n$，是指满足 $\\{a_1, a_2, \\dots, a_n\\} = \\{1, 2, \\dots n\\}$ 的一组数。", "inputFormat": "第一行包含一个正整数 $n$ ($1\\le n\\le 5\\times 10^5$)，表示排列的大小。\n\n第二行包含 $n$ 个正整数 $a_i$，用一个空格分隔，表示初始排列 $a_1, a_2, \\dots, a_n$ ($\\{a_1, a_2, \\dots, a_n\\} = \\{1, 2, \\dots n\\}$)。\n\n第三行一个正整数 $k$ ($1\\le k\\le 10^5$)，表示操作的次数。\n\n接下来 $k$ 行，每行两个正整数 $l$ 和 $r$ ($1\\le l\\le r\\le n$)，用一个空格分隔，表示操作的区间。", "outputFormat": "对于每个测试数据中的每次操作，给出答案，并执行修改。\n\n记排列 $a_1, a_2, \\dots, a_n$ 在区间 $[l,r]$ 上未出现的最小正整数为 $x$：\n  - 若 $x<n$，则输出 $x$，并交换当前排列 $a_1, a_2, \\dots, a_n$ 中数字 $x$ 与 $x+1$ 的位置；\n  - 若 $x\\ge n$，则输出字符串 $\\tt{peace}$。", "hint": "对于第一组样例：\n\n第一次操作 $[2,4]$，当前排列为 $4,3,1,2,5$。\n\n区间 $[2,4]$ 内未出现的最小正整数为 $4$，输出 $4$ 并交换排列中 $4$ 和 $5$ 的位置。\n\n第二次操作 $[2,5]$，当前排列为 $5,3,1,2,4$。\n\n区间 $[2,5]$ 内未出现的最小正整数为 $5$，输出 $\\tt{peace}$，排列不变。\n\n第三次操作 $[1,3]$，当前排列为 $5,3,1,2,4$。\n\n区间 $[1,3]$ 内未出现的最小正整数为 $2$，输出 $2$ 并交换排列中 $2$ 和 $3$ 的位置。\n\n第四次操作 $[1,3]$，当前排列为 $5,2,1,3,4$。\n\n区间 $[1,3]$ 内未出现的最小正整数为 $3$，输出 $3$ 并交换排列中 $3$ 和 $4$ 的位置。\n\n第五次操作 $[1,5]$，当前排列为 $5,2,1,4,3$。\n\n区间 $[1,5]$ 内未出现的最小正整数为 $6$，输出 $\\tt{peace}$，排列不变。", "locale": "zh-CN"}}}
{"pid": "P12540", "type": "P", "difficulty": 4, "samples": [["3 5 7", "16"], ["14530529 19260817 19491001 ", "5660025"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "2025", "Special Judge", "O2优化", "高校校赛"], "title": "[XJTUPC 2025] 离散对数", "background": "", "description": "给定正整数 $a$, $c$, $p$，保证 $p$ 是 **素数**，求 $b$ 使得：\n\n$$a^b \\equiv b^c \\pmod{p}$$\n\n我们称整数 $A, B, C$ 有 $A \\equiv B \\pmod{C}$，当且仅当存在整数 $k$ 使得 $A - B = C \\times k$。", "inputFormat": "输入仅一行三个整数 $a$, $c$ 和 $p$ ($1 \\leq a, c < p \\leq 10^9$)，由一个空格隔开，含义如题面所述。\n\n数据保证 $p$ 是素数。", "outputFormat": "输出仅一个整数 $b$ ($1 \\leq b \\leq 10^{18}$)，如果有多个合法答案，你可以输出任意一个。\n\n可以证明，在范围内至少存在一个解。", "hint": "对于第一组样例，我们有：\n\n$$3^{16} \\equiv 16^5 \\pmod{7}$$\n\n因为：\n\n$$3^{16} \\bmod 7 = 43046721 \\bmod 7 = 4$$\n\n$$16^5 \\bmod 7 = 1048576 \\bmod 7 = 4$$", "locale": "zh-CN", "translations": {"en": {"title": "[XJTUPC 2025] Discrete Logarithm", "background": "", "description": "Given positive integers $a$, $c$, $p$, ensure that $p$ is $\\textbf{prime}$, find $b$ such that:\n\n$$a^b \\equiv b^c \\pmod{p}$$\n\nWe say that integers $A, B, C$ have $A \\equiv B \\pmod{C}$ if and only if there exists an integer $k$ such that $A - B = C \\times k$.", "inputFormat": "Input is just one line of three integers $a$, $c$, and $p$ ($1 \\leq a, c < p \\leq 10^9$), separated by a space, with the meaning as described in the question.\n\nThe data guarantees that $p$ is a prime.", "outputFormat": "Output only one integer $b$ ($1 \\leq b \\leq 10^{18}$). If there are multiple legal answers, you can output any one.\n\nIt can be proved that there is at least one solution in the range.", "hint": "For the first sample, we have:\n\n$$3^{16} \\equiv 16^5 \\pmod{7}$$\n\nBecause:\n\n$$3^{16} \\bmod 7 = 43046721 \\bmod 7 = 4$$\n\n$$16^5 \\bmod 7 = 1048576 \\bmod 7 = 4$$", "locale": "en"}, "zh-CN": {"title": "[XJTUPC 2025] 离散对数", "background": "", "description": "给定正整数 $a$, $c$, $p$，保证 $p$ 是 **素数**，求 $b$ 使得：\n\n$$a^b \\equiv b^c \\pmod{p}$$\n\n我们称整数 $A, B, C$ 有 $A \\equiv B \\pmod{C}$，当且仅当存在整数 $k$ 使得 $A - B = C \\times k$。", "inputFormat": "输入仅一行三个整数 $a$, $c$ 和 $p$ ($1 \\leq a, c < p \\leq 10^9$)，由一个空格隔开，含义如题面所述。\n\n数据保证 $p$ 是素数。", "outputFormat": "输出仅一个整数 $b$ ($1 \\leq b \\leq 10^{18}$)，如果有多个合法答案，你可以输出任意一个。\n\n可以证明，在范围内至少存在一个解。", "hint": "对于第一组样例，我们有：\n\n$$3^{16} \\equiv 16^5 \\pmod{7}$$\n\n因为：\n\n$$3^{16} \\bmod 7 = 43046721 \\bmod 7 = 4$$\n\n$$16^5 \\bmod 7 = 1048576 \\bmod 7 = 4$$", "locale": "zh-CN"}}}
{"pid": "P12541", "type": "P", "difficulty": 7, "samples": [], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "APIO", "交互题", "Special Judge", "构造", "大步小步算法 BSGS"], "title": "[APIO2025] Hack!", "background": null, "description": "It has been an hour into a Codeforces contest, when you notice that another contestant in your room has solved a problem using an `unordered_set`. Time to hack!\n\nYou know that `unordered_set` uses a hash table with $n$ buckets, which are numbered from $0$ to $n-1$. Unfortunately, you do not know the value of $n$ and wish to recover it.\n\nWhen you insert an integer $x$ into the hash table, it is inserted to the $(x \\bmod n)$-th bucket. If there are $b$ elements in this bucket prior to the insertion, this will cause $b$ hash collisions to occur.\n\nBy giving $k$ distinct integers $x[0], x[1], \\dots, x[k-1]$ to the interactor, you can find out the total number of hash collisions that had occurred while creating an `unordered_set` containing the numbers. However, feeding this interactor $k$ integers in one query will incur a cost of $k$.\n\nFor example, if $n = 5$, feeding the interactor with $x = [2, 15, 7, 27, 8, 30]$ would cause 4 collisions in total:\n\n| Operation               | New collisions | Buckets                     |\n|-------------------------|----------------|-----------------------------|\n| initially               | $-$            | $[], [], [], [], []$        |\n| insert $x[0] = 2$       | $0$            | $[], [], [2], [], []$       |\n| insert $x[1] = 15$      | $0$            | $[15], [], [2], [], []$     |\n| insert $x[2] = 7$       | $1$            | $[15], [], [2, 7], [], []$  |\n| insert $x[3] = 27$      | $2$            | $[15], [], [2, 7, 27], [], []$ |\n| insert $x[4] = 8$       | $0$            | $[15], [], [2, 7, 27], [8], []$ |\n| insert $x[5] = 30$      | $1$            | $[15, 30], [], [2, 7, 27], [8], []$ |\n\nNote that the interactor creates the hash table by inserting the elements in order into an initially empty `unordered_set`, and a new empty `unordered_set` will be created for each query. In other words, all queries are independent.\n\nYour task is to find the number of buckets $n$ using a total cost of at most $1\\,000\\,000$.\n\n### Implementation details\n\nYou should implement the following procedure:\n\n```cpp\nint hack()\n```\n\n- This procedure should return an integer – the hidden value of $n$.\n- For each test case, the grader may call this function more than once. Each call should be processed as a separately new scenario.\n\nWithin this procedure, you may call the following procedure:\n\n```cpp\nlong long collisions(std::vector<long long> x)\n```\n\n- $x$: an array of distinct numbers, where $1 \\leq x[i] \\leq 10^{18}$ for each $i$.\n- This function returns the number of collisions created by inserting the elements of $x$ to an `unordered_set`.\n- This procedure can be called multiple times. The sum of length of $x$ over all calls within one call to `hack()` must not exceed $1\\,000\\,000$.\n\n**Note**: Since the procedure `hack()` will be called more than once, contestants need to pay attention to the impact of the remaining data of the previous call on the current call, especially the state stored in global variables.\n\nThe cost limit of $1\\,000\\,000$ applies to each test case. In general, if there are $t$ calls to `hack()`, you may use a total cost of no more than $t \\times 1\\,000\\,000$, with each individual call to `hack()` using a cost no more than $1\\,000\\,000$.\n\nThe interactor is not adaptive, i.e. the values of $n$ are fixed before the start of interaction.", "inputFormat": null, "outputFormat": null, "hint": "### Example\n\nSuppose, there are 2 multitests. The grader will make a following call:\n\n```cpp\nhack()\n```\n\nLet's say, within the function, you make following calls:\n\n| Call                          | Returned value |\n|-------------------------------|----------------|\n| `collisions([2, 15, 7, 27, 8, 30])` | $4$            |\n| `collisions([1, 2, 3])`             | $0$            |\n| `collisions([10, 20, 30, 40, 50])` | $10$           |\n\nAfter that, if you find that the value of $n$ is $5$, the procedure `hack()` should return $5$.\n\nThen grader will make another call:\n\n```cpp\nhack()\n```\n\nLet's say, within the function, you make following calls:\n\n| Call              | Returned value |\n|-------------------|----------------|\n| `collisions([1, 3])` | $1$            |\n| `collisions([2, 4])` | $1$            |\n\nThe only $n$ which satisfies the queries is $2$. So, the procedure `hack()` should return $2$.\n\n### Constraints\n\n- $1 \\leq t \\leq 10$, where $t$ is the number of multitests.\n- $2 \\leq n \\leq 10^9$\n- $1 \\leq x[i] \\leq 10^{18}$ for each call to `collisions()`.\n\n### Subtasks\n\n1. (8 points) $n \\leq 500\\,000$\n2. (17 points) $n \\leq 1\\,000\\,000$\n3. (75 points) No additional constraints.\n\nIn the last subtask, you can get partial score. Let $q$ be the maximum total cost among all invocations of `hack()` over every test case of the subtask. Your score for this subtask is calculated according to the following table:\n\n| Condition                      | Points |\n|--------------------------------|--------|\n| $1\\,000\\,000 < q$              | $0$    |\n| $110\\,000 < q \\leq 1\\,000\\,000$ | $75 \\cdot \\log_{50} \\left( \\frac{10^6}{q - 90000} \\right)$ |\n| $q \\leq 110\\,000$              | $75$   |\n\nIf, in any of the test cases, the calls to the procedure `collisions()` do not conform to the constraints described in Implementation Details, or the number returned by `hack()` is incorrect, the score of your solution for that subtask will be $0$.\n\n### Sample Grader\n\nThe sample grader reads the input in the following format:\n\n- line 1: $t$\n\nThen, $t$ lines follow, each containing a value of $n$:\n\n- line 1: $n$\n\nFor each test case, let $m$ be the return value of `hack()`, and $c$ be the total cost of all queries. The sample grader prints your answer in the following format:\n\n- line 1: $m \\, c$", "locale": "en", "translations": {"en": {"title": "[APIO2025] Hack!", "background": null, "description": "It has been an hour into a Codeforces contest, when you notice that another contestant in your room has solved a problem using an `unordered_set`. Time to hack!\n\nYou know that `unordered_set` uses a hash table with $n$ buckets, which are numbered from $0$ to $n-1$. Unfortunately, you do not know the value of $n$ and wish to recover it.\n\nWhen you insert an integer $x$ into the hash table, it is inserted to the $(x \\bmod n)$-th bucket. If there are $b$ elements in this bucket prior to the insertion, this will cause $b$ hash collisions to occur.\n\nBy giving $k$ distinct integers $x[0], x[1], \\dots, x[k-1]$ to the interactor, you can find out the total number of hash collisions that had occurred while creating an `unordered_set` containing the numbers. However, feeding this interactor $k$ integers in one query will incur a cost of $k$.\n\nFor example, if $n = 5$, feeding the interactor with $x = [2, 15, 7, 27, 8, 30]$ would cause 4 collisions in total:\n\n| Operation               | New collisions | Buckets                     |\n|-------------------------|----------------|-----------------------------|\n| initially               | $-$            | $[], [], [], [], []$        |\n| insert $x[0] = 2$       | $0$            | $[], [], [2], [], []$       |\n| insert $x[1] = 15$      | $0$            | $[15], [], [2], [], []$     |\n| insert $x[2] = 7$       | $1$            | $[15], [], [2, 7], [], []$  |\n| insert $x[3] = 27$      | $2$            | $[15], [], [2, 7, 27], [], []$ |\n| insert $x[4] = 8$       | $0$            | $[15], [], [2, 7, 27], [8], []$ |\n| insert $x[5] = 30$      | $1$            | $[15, 30], [], [2, 7, 27], [8], []$ |\n\nNote that the interactor creates the hash table by inserting the elements in order into an initially empty `unordered_set`, and a new empty `unordered_set` will be created for each query. In other words, all queries are independent.\n\nYour task is to find the number of buckets $n$ using a total cost of at most $1\\,000\\,000$.\n\n### Implementation details\n\nYou should implement the following procedure:\n\n```cpp\nint hack()\n```\n\n- This procedure should return an integer – the hidden value of $n$.\n- For each test case, the grader may call this function more than once. Each call should be processed as a separately new scenario.\n\nWithin this procedure, you may call the following procedure:\n\n```cpp\nlong long collisions(std::vector<long long> x)\n```\n\n- $x$: an array of distinct numbers, where $1 \\leq x[i] \\leq 10^{18}$ for each $i$.\n- This function returns the number of collisions created by inserting the elements of $x$ to an `unordered_set`.\n- This procedure can be called multiple times. The sum of length of $x$ over all calls within one call to `hack()` must not exceed $1\\,000\\,000$.\n\n**Note**: Since the procedure `hack()` will be called more than once, contestants need to pay attention to the impact of the remaining data of the previous call on the current call, especially the state stored in global variables.\n\nThe cost limit of $1\\,000\\,000$ applies to each test case. In general, if there are $t$ calls to `hack()`, you may use a total cost of no more than $t \\times 1\\,000\\,000$, with each individual call to `hack()` using a cost no more than $1\\,000\\,000$.\n\nThe interactor is not adaptive, i.e. the values of $n$ are fixed before the start of interaction.", "inputFormat": null, "outputFormat": null, "hint": "### Example\n\nSuppose, there are 2 multitests. The grader will make a following call:\n\n```cpp\nhack()\n```\n\nLet's say, within the function, you make following calls:\n\n| Call                          | Returned value |\n|-------------------------------|----------------|\n| `collisions([2, 15, 7, 27, 8, 30])` | $4$            |\n| `collisions([1, 2, 3])`             | $0$            |\n| `collisions([10, 20, 30, 40, 50])` | $10$           |\n\nAfter that, if you find that the value of $n$ is $5$, the procedure `hack()` should return $5$.\n\nThen grader will make another call:\n\n```cpp\nhack()\n```\n\nLet's say, within the function, you make following calls:\n\n| Call              | Returned value |\n|-------------------|----------------|\n| `collisions([1, 3])` | $1$            |\n| `collisions([2, 4])` | $1$            |\n\nThe only $n$ which satisfies the queries is $2$. So, the procedure `hack()` should return $2$.\n\n### Constraints\n\n- $1 \\leq t \\leq 10$, where $t$ is the number of multitests.\n- $2 \\leq n \\leq 10^9$\n- $1 \\leq x[i] \\leq 10^{18}$ for each call to `collisions()`.\n\n### Subtasks\n\n1. (8 points) $n \\leq 500\\,000$\n2. (17 points) $n \\leq 1\\,000\\,000$\n3. (75 points) No additional constraints.\n\nIn the last subtask, you can get partial score. Let $q$ be the maximum total cost among all invocations of `hack()` over every test case of the subtask. Your score for this subtask is calculated according to the following table:\n\n| Condition                      | Points |\n|--------------------------------|--------|\n| $1\\,000\\,000 < q$              | $0$    |\n| $110\\,000 < q \\leq 1\\,000\\,000$ | $75 \\cdot \\log_{50} \\left( \\frac{10^6}{q - 90000} \\right)$ |\n| $q \\leq 110\\,000$              | $75$   |\n\nIf, in any of the test cases, the calls to the procedure `collisions()` do not conform to the constraints described in Implementation Details, or the number returned by `hack()` is incorrect, the score of your solution for that subtask will be $0$.\n\n### Sample Grader\n\nThe sample grader reads the input in the following format:\n\n- line 1: $t$\n\nThen, $t$ lines follow, each containing a value of $n$:\n\n- line 1: $n$\n\nFor each test case, let $m$ be the return value of `hack()`, and $c$ be the total cost of all queries. The sample grader prints your answer in the following format:\n\n- line 1: $m \\, c$", "locale": "en"}, "zh-CN": {"title": "[APIO2025] Hack!", "background": "请注意：本题只支持 C++ 语言提交；你不需要也不应该实现 `main` 函数；你需要在程序开头添加如下内容：\n\n```cpp\n#include <vector>\n\nint hack();\nlong long collisions(std::vector<long long> x);\n```", "description": "你参加了一场 Codeforces 的编程比赛，现在离比赛结束只有一个小时了。你发现同房间的另外一位选手通过使用 `unordered_set` 通过了一道题目。是时候把他的代码 hack 掉了！\n\n你知道 `unordered_set` 是使用一个包含 $n$ 个桶的哈希表实现的，其中桶的编号为 $0$ 到 $n-1$。不过很可惜，你并不知道 $n$ 具体是多少，所以你希望通过下面的操作将 $n$ 还原出来。\n\n当你将一个整数 $x$ 插入哈希表时，它将会被插入到第 $(x \\bmod n)$ 个桶中。如果在这次插入之前这个桶中已经有 $b$ 个元素，这将会导致 $b$ 次哈希冲突的产生。\n\n每次操作中，你可以向交互库提交 $k$ 个不同的整数 $x[0], x[1], \\dots, x[k-1]$ 进行查询，交互库会依次将这些整数插入到哈希表中，并返回创建包含这些数字的哈希表会引起的哈希冲突总次数。然而，向交互库提交一次包含 $k$ 个不同的整数的查询需要 $k$ 的花费。\n\n例如，当 $n = 5$ 时，如果你向交互库提交数组 $x = [2, 15, 7, 27, 8, 30]$，将会引起总共 $4$ 次哈希冲突，具体如下：\n\n| 操作                     | 新增哈希冲突次数 | 桶状态                     |\n|--------------------------|------------------|----------------------------|\n| 初始状态                 | -                | [], [], [], [], []          |\n| 插入 $x[0] = 2$          | 0                | [], [], [2], [], []         |\n| 插入 $x[1] = 15$         | 0                | [15], [], [2], [], []       |\n| 插入 $x[2] = 7$          | 1                | [15], [], [2, 7], [], []    |\n| 插入 $x[3] = 27$         | 2                | [15], [], [2, 7, 27], [], []|\n| 插入 $x[4] = 8$          | 0                | [15], [], [2, 7, 27], [8], [] |\n| 插入 $x[5] = 30$         | 1                | [15, 30], [], [2, 7, 27], [8], [] |\n\n请注意：交互库在每次你提交的时候都将 `unordered_set` 初始化为空集，然后把提交的数字依次插入来创建哈希表。也就是说，每一次的交互查询是相互独立的。\n\n你的任务是使用不超过 $1\\,000\\,000$ 的花费求出桶的数量 $n$。\n\n### 实现细节\n\n你需要实现以下函数：\n\n```cpp\nint hack()\n```\n\n- 该函数返回一个整数 $n$。\n- 对于每个测试点，评测程序可能会调用该函数多于一次。每次调用都应该当做新的情况分别处理。\n\n在这个函数中，你可能会调用以下交互函数：\n\n```cpp\nlong long collisions(std::vector<long long> x)\n```\n\n- $x$：一个包含不同整数的数组，其中对于所有 $i$，满足 $1 \\leq x[i] \\leq 10^{18}$。\n- 该函数返回一个整数，表示将数组 $x$ 中所有元素依次插入哈希表引起的哈希冲突次数。\n- 该函数可以多次调用。在一次 `hack()` 的调用中，多次调用的数组 $x$ 的总长度不能超过 $1\\,000\\,000$。\n\n注意：由于 `hack()` 函数调用可能会发生多次，选手需要注意之前调用的残余数据对于后续调用的影响，尤其是全局变量的状态。\n\n$1\\,000\\,000$ 的花费限制应用于每一组测试数据。即，如果 `hack()` 函数被调用了 $t$ 次，你可以使用不超过 $t \\times 1\\,000\\,000$ 的总花费，并且每次独立调用 `hack()` 时的花费不能超过 $1\\,000\\,000$。\n\n$n$ 的值在交互函数调用前已经固定。", "inputFormat": null, "outputFormat": null, "hint": "### 例子\n\n假设有两组测试用例，评测程序将首先调用 `hack()` 函数：\n\n```cpp\nhack()\n```\n\n在这个函数中，你可以进行以下调用：\n\n| 函数调用                     | 返回值 |\n|------------------------------|--------|\n| `collisions([2, 15, 7, 27, 8, 30])` | 4      |\n| `collisions([1, 2, 3])`             | 0      |\n| `collisions([10, 20, 30, 40, 50])`  | 10     |\n\n如果你还原出 $n = 5$，那么函数 `hack()` 返回 5。\n\n接下来，评测程序将再一次调用 `hack()` 函数：\n\n```cpp\nhack()\n```\n\n在这个函数中，你可以进行以下调用：\n\n| 函数调用          | 返回值 |\n|-------------------|--------|\n| `collisions([1, 3])` | 1      |\n| `collisions([2, 4])` | 1      |\n\n你从上述调用中还原出唯一满足的 $n$ 是 2，那么函数 `hack()` 返回 2。\n\n### 约束条件\n\n- $1 \\leq t \\leq 10$，其中 $t$ 为每组测试点中的测试用例数量。\n- $2 \\leq n \\leq 10^9$\n- 对于每次 `collisions()` 调用，$1 \\leq x[i] \\leq 10^{18}$\n\n### 子任务\n\n1. (8 分) $n \\leq 500\\,000$\n2. (17 分) $n \\leq 1\\,000\\,000$\n3. (75 分) 没有额外的约束条件。\n\n在最后一个子任务中，你可以获得部分分。令 $q$ 为该子任务下所有测试用例 `hack()` 函数中的最大总花费。该子任务的部分分计算如下：\n\n| 条件                     | 分数  |\n|--------------------------|-------|\n| $1\\,000\\,000 < q$        | 0     |\n| $110\\,000 < q \\leq 1\\,000\\,000$ | $75 \\cdot \\log_{50} \\left( \\frac{10^6}{x - 90000} \\right)$ |\n| $q \\leq 110\\,000$        | 75    |\n\n在任意测试用例中，如果对 `collisions()` 函数调用不满足实现细节中的约束条件，或者 `hack()` 函数调用的返回值错误，该子任务的分数为 0。\n\n### 评测程序示例\n\n评测程序示例按以下格式读取输入：\n\n- 第 1 行：$t$\n\n对于接下来 $t$ 组数据的每一组：\n\n- 第 1 行：$n$\n\n对于每组测试用例，令 $m$ 为函数 `hack()` 的返回值，$c$ 为所有查询的总花费。评测程序示例按以下格式打印你的答案：\n\n- 第 1 行：$m\\,c$", "locale": "zh-CN"}}}
{"pid": "P12542", "type": "P", "difficulty": 7, "samples": [], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["博弈论", "2025", "APIO", "交互题", "Special Judge", "Ad-hoc", "分类讨论"], "title": "[APIO2025] Permutation Game", "background": "", "description": "Alice and Bob are childhood friends, and they love playing intellectual games. Today, they are playing a new game on graphs.\n\nThe game set contains a **connected** graph with $m$ vertices, numbered from $0$ to $m-1$, and $e$ edges, numbered from $0$ to $e-1$. The $i$-th edge connects vertices $u[i]$ and $v[i]$.\n\nThe game set also contains a permutation $p[0], p[1], \\ldots, p[n-1]$ of length $n$, where $m \\leq n$. Permutation is an array in which each number from $0$ to $n-1$ appears exactly once, in some order. The **score** of permutation $p$ is the number of indices $i$ such that $p[i] = i$.\n\nThe game will last for at most $10^{100}$ turns. In each turn, the following happens:\n\n1. If Alice decides to end the game, the game stops.\n2. Otherwise, Alice chooses **distinct indices** $t[0], t[1], \\ldots, t[m-1]$, where $0 \\leq t[i] < n$. Note that, the game does **not** require $t[0] < t[1] < \\ldots < t[m-1]$.\n3. Bob chooses an index $0 \\leq j < e$ of the edges of the graph and swaps $p[t[u[j]]]$ and $p[t[v[j]]]$.\n\nAlice wishes to maximize the final score of the permutation while Bob wishes to minimize the final score of the permutation.\n\nYour task is to help Alice and play against Bob, whose moves are simulated by grader.\n\nLet's define *optimal score* as the final score of the permutation if both Alice and Bob play optimally.\n\nYou will need to determine the optimal score of the permutation and then play the game with Bob to achieve **at least** that optimal score after some turns.\n\n**Note that Alice's strategy should work no matter what moves Bob makes, including if Bob makes unoptimal moves.**\n\n### Implementation details\n\nYou should implement the following procedure:\n\n```cpp\nint Alice(int m, int e, std::vector<int> u, std::vector<int> v,\n    int n, std::vector<int> p)\n```\n\n- `m`: the number of vertices in the graph.\n- `e`: the number of edges in the graph.\n- `u` and `v`: arrays of length `e` describing the edges of the graph.\n- `n`: the length of the permutation.\n- `p`: an array of length `n` describing the permutation.\n\nThis procedure is called exactly once.\nThis procedure should return an integer – the optimal score of the game.\nWithin this procedure, you may call the following procedure:\n\n```cpp\nint Bob(std::vector<int> t)\n```\n\n- `t`: an array of size `m`, containing distinct indices, where $0 \\leq t[i] < n$ and $t[i] \\neq t[j]$ for any $i \\neq j$.\nThis function returns a single integer `j` which satisfies $0 \\leq j < e$.\nThis procedure can be called multiple times.\n", "inputFormat": "", "outputFormat": "", "hint": "### Example\n\nConsider the following call:\n\n```cpp\nAlice(5, 6, [4, 0, 3, 1, 4, 2], [2, 2, 0, 2, 0, 3], \n10, [8, 2, 7, 6, 1, 5, 0, 9, 3, 4])\n```\n\nThe graph is as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lo1c6nt9.png)\n\nand `p` is initially `[8, 2, 7, 6, 1, 5, 0, 9, 3, 4]`.\nGiven the constraints above, we can prove that the optimal score of the permutation is `1`.\n\nSuppose, Alice makes the following 4 moves:\n\n| Argument of `t` to Bob | Return value of Bob | Corresponding indices of `p` | `p` after the swap by Bob |\n|------------------------|---------------------|-----------------------------|---------------------------|\n| `[3, 1, 5, 2, 0]`      | `5`                 | `5, 2`                      | `[8, 2, 5, 6, 1, 7, 0, 9, 3, 4]` |\n| `[9, 3, 7, 2, 1]`      | `0`                 | `1, 7`                      | `[8, 9, 5, 6, 1, 7, 0, 2, 3, 4]` |\n| `[5, 6, 7, 8, 9]`      | `1`                 | `5, 7`                      | `[8, 9, 5, 6, 1, 2, 0, 7, 3, 4]` |\n| `[7, 5, 2, 3, 6]`      | `3`                 | `5, 2`                      | `[8, 9, 2, 6, 1, 5, 0, 7, 3, 4]` |\n\nNote that Alice and Bob not necessarily making the optimal moves. These moves are shown purely for demonstration purposes. Also note that Alice could finish the game immediately, as the initial score of the permutation is already `1`.\n\nAfter Alice has performed all the moves above, the actual score of the permutation is `3` ($p[2] = 2$, $p[5] = 5$, $p[7] = 7$). Finally, the function `Alice()` will return `1` – the optimal score of the permutation.\n\n**Note that even though Alice has achieved a score of 3 by playing with Bob, you would get 0 points if the return value of `Alice()` was 3 instead of 1.**\n\n### Constraints\n\n- $2 \\leq m \\leq 400$\n- $m - 1 \\leq e \\leq 400$\n- $0 \\leq u[i], v[i] < m$\n- $m \\leq n \\leq 400$\n- $0 \\leq p[i] < n$\n- The graph is connected, contains no self-loops or multiple edges.\n- $p$ is a permutation, i.e. $p[i] \\neq p[j]$ for any $i \\neq j$.\n\n### Subtasks\n\n1. (6 points) $m = 2$\n2. (6 points) $e > m$\n3. (10 points) $e = m - 1$\n4. (24 points) $e = m = 3$\n5. (24 points) $e = m = 4$\n6. (30 points) $e = m$\n\nFor each subtask, you can get partial score. Let $r$ be the maximum ratio of $\\frac{k}{n}$ among all test cases of a subtask, where $k$ is the number of turns (i.e. calls to `Bob()`). Then, your score for that subtask is multiplied by the following number:\n\n| Condition       | Multiplier                     |\n|-----------------|--------------------------------|\n| $12 \\leq r$     | $0$                            |\n| $3 < r < 12$    | $1 - \\log_{10}(r - 2)$         |\n| $r \\leq 3$      | $1$                            |\n\nIn particular, if you solve the problem within $3n$ turns, you get full points for that subtask. Using more than $12n$ turns results in getting 0 for that subtask (shown as `Output isn't correct`).\n\n### Sample Grader\n\nThe sample grader reads the input in the following format:\n\n- line 1: $m$ $e$\n- line 2 + $i$ ($0 \\leq i \\leq e - 1$): $u[i]$ $v[i]$\n- line 2 + $e$: $n$\n- line 3 + $e$: $p[0]$ $p[1]$ $\\ldots$ $p[n - 1]$\n\nThe sample grader prints the output in the following format:\n\n- line 1: final permutation $p$\n- line 2: return value of `Alice()`\n- line 3: actual score of final permutation\n- line 4: the number of turns\n", "locale": "en", "translations": {"en": {"title": "[APIO2025] Permutation Game", "background": "", "description": "Alice and Bob are childhood friends, and they love playing intellectual games. Today, they are playing a new game on graphs.\n\nThe game set contains a **connected** graph with $m$ vertices, numbered from $0$ to $m-1$, and $e$ edges, numbered from $0$ to $e-1$. The $i$-th edge connects vertices $u[i]$ and $v[i]$.\n\nThe game set also contains a permutation $p[0], p[1], \\ldots, p[n-1]$ of length $n$, where $m \\leq n$. Permutation is an array in which each number from $0$ to $n-1$ appears exactly once, in some order. The **score** of permutation $p$ is the number of indices $i$ such that $p[i] = i$.\n\nThe game will last for at most $10^{100}$ turns. In each turn, the following happens:\n\n1. If Alice decides to end the game, the game stops.\n2. Otherwise, Alice chooses **distinct indices** $t[0], t[1], \\ldots, t[m-1]$, where $0 \\leq t[i] < n$. Note that, the game does **not** require $t[0] < t[1] < \\ldots < t[m-1]$.\n3. Bob chooses an index $0 \\leq j < e$ of the edges of the graph and swaps $p[t[u[j]]]$ and $p[t[v[j]]]$.\n\nAlice wishes to maximize the final score of the permutation while Bob wishes to minimize the final score of the permutation.\n\nYour task is to help Alice and play against Bob, whose moves are simulated by grader.\n\nLet's define *optimal score* as the final score of the permutation if both Alice and Bob play optimally.\n\nYou will need to determine the optimal score of the permutation and then play the game with Bob to achieve **at least** that optimal score after some turns.\n\n**Note that Alice's strategy should work no matter what moves Bob makes, including if Bob makes unoptimal moves.**\n\n### Implementation details\n\nYou should implement the following procedure:\n\n```cpp\nint Alice(int m, int e, std::vector<int> u, std::vector<int> v,\n    int n, std::vector<int> p)\n```\n\n- `m`: the number of vertices in the graph.\n- `e`: the number of edges in the graph.\n- `u` and `v`: arrays of length `e` describing the edges of the graph.\n- `n`: the length of the permutation.\n- `p`: an array of length `n` describing the permutation.\n\nThis procedure is called exactly once.\nThis procedure should return an integer – the optimal score of the game.\nWithin this procedure, you may call the following procedure:\n\n```cpp\nint Bob(std::vector<int> t)\n```\n\n- `t`: an array of size `m`, containing distinct indices, where $0 \\leq t[i] < n$ and $t[i] \\neq t[j]$ for any $i \\neq j$.\nThis function returns a single integer `j` which satisfies $0 \\leq j < e$.\nThis procedure can be called multiple times.\n", "inputFormat": "", "outputFormat": "", "hint": "### Example\n\nConsider the following call:\n\n```cpp\nAlice(5, 6, [4, 0, 3, 1, 4, 2], [2, 2, 0, 2, 0, 3], \n10, [8, 2, 7, 6, 1, 5, 0, 9, 3, 4])\n```\n\nThe graph is as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lo1c6nt9.png)\n\nand `p` is initially `[8, 2, 7, 6, 1, 5, 0, 9, 3, 4]`.\nGiven the constraints above, we can prove that the optimal score of the permutation is `1`.\n\nSuppose, Alice makes the following 4 moves:\n\n| Argument of `t` to Bob | Return value of Bob | Corresponding indices of `p` | `p` after the swap by Bob |\n|------------------------|---------------------|-----------------------------|---------------------------|\n| `[3, 1, 5, 2, 0]`      | `5`                 | `5, 2`                      | `[8, 2, 5, 6, 1, 7, 0, 9, 3, 4]` |\n| `[9, 3, 7, 2, 1]`      | `0`                 | `1, 7`                      | `[8, 9, 5, 6, 1, 7, 0, 2, 3, 4]` |\n| `[5, 6, 7, 8, 9]`      | `1`                 | `5, 7`                      | `[8, 9, 5, 6, 1, 2, 0, 7, 3, 4]` |\n| `[7, 5, 2, 3, 6]`      | `3`                 | `5, 2`                      | `[8, 9, 2, 6, 1, 5, 0, 7, 3, 4]` |\n\nNote that Alice and Bob not necessarily making the optimal moves. These moves are shown purely for demonstration purposes. Also note that Alice could finish the game immediately, as the initial score of the permutation is already `1`.\n\nAfter Alice has performed all the moves above, the actual score of the permutation is `3` ($p[2] = 2$, $p[5] = 5$, $p[7] = 7$). Finally, the function `Alice()` will return `1` – the optimal score of the permutation.\n\n**Note that even though Alice has achieved a score of 3 by playing with Bob, you would get 0 points if the return value of `Alice()` was 3 instead of 1.**\n\n### Constraints\n\n- $2 \\leq m \\leq 400$\n- $m - 1 \\leq e \\leq 400$\n- $0 \\leq u[i], v[i] < m$\n- $m \\leq n \\leq 400$\n- $0 \\leq p[i] < n$\n- The graph is connected, contains no self-loops or multiple edges.\n- $p$ is a permutation, i.e. $p[i] \\neq p[j]$ for any $i \\neq j$.\n\n### Subtasks\n\n1. (6 points) $m = 2$\n2. (6 points) $e > m$\n3. (10 points) $e = m - 1$\n4. (24 points) $e = m = 3$\n5. (24 points) $e = m = 4$\n6. (30 points) $e = m$\n\nFor each subtask, you can get partial score. Let $r$ be the maximum ratio of $\\frac{k}{n}$ among all test cases of a subtask, where $k$ is the number of turns (i.e. calls to `Bob()`). Then, your score for that subtask is multiplied by the following number:\n\n| Condition       | Multiplier                     |\n|-----------------|--------------------------------|\n| $12 \\leq r$     | $0$                            |\n| $3 < r < 12$    | $1 - \\log_{10}(r - 2)$         |\n| $r \\leq 3$      | $1$                            |\n\nIn particular, if you solve the problem within $3n$ turns, you get full points for that subtask. Using more than $12n$ turns results in getting 0 for that subtask (shown as `Output isn't correct`).\n\n### Sample Grader\n\nThe sample grader reads the input in the following format:\n\n- line 1: $m$ $e$\n- line 2 + $i$ ($0 \\leq i \\leq e - 1$): $u[i]$ $v[i]$\n- line 2 + $e$: $n$\n- line 3 + $e$: $p[0]$ $p[1]$ $\\ldots$ $p[n - 1]$\n\nThe sample grader prints the output in the following format:\n\n- line 1: final permutation $p$\n- line 2: return value of `Alice()`\n- line 3: actual score of final permutation\n- line 4: the number of turns\n", "locale": "en"}, "zh-CN": {"title": "[APIO2025] 排列游戏", "background": "请注意：本题只支持 C++ 语言提交；你不需要也不应该实现 `main` 函数；你需要在程序开头添加如下内容：\n\n```cpp\n#include <vector>\n\nint Alice(int m, int e, std::vector<int> u, std::vector<int> v, int n, std::vector<int> p);\n\nint Bob(std::vector<int> t);\n```", "description": "Alice 和 Bob 是童年时代的朋友，他们喜欢玩智力游戏。今天，他们在玩一个关于图的新游戏。\n\n游戏中包含一个连通图，具有 $m$ 个顶点，编号为 $0$ 到 $m-1$，以及 $e$ 条边，编号为 $0$ 到 $e-1$。第 $i$ 条边连接顶点 $u[i]$ 和 $v[i]$。\n\n游戏中还包含一个长度为 $n$ 的排列 $p[0], p[1], \\ldots, p[n-1]$，其中 $m \\leq n$。排列是一个数组，其中从 $0$ 到 $n-1$ 的每个数字以某种顺序仅出现一次。排列 $p$ 的分数是满足 $p[i] = i$ 的下标 $i$ 的数量。\n\n游戏最多持续 $10^{100}$ 个回合。在每个回合中，都会发生以下情况：\n\n1. 如果 Alice 决定结束游戏，游戏终止。\n2. 否则，Alice 选择一组两两不同的下标 $t[0], t[1], \\ldots, t[m-1]$，满足 $0 \\leq t[i] < n$。请注意，游戏不要求 $t[0] < t[1] < \\ldots < t[m-1]$。\n3. Bob 选择一个图中边的下标 $0 \\leq j < e$，并交换 $p[t[u[j]]]$ 和 $p[t[v[j]]]$。\n\nAlice 希望能最大化排列的最终分数而 Bob 希望最小化排列的最终分数。\n\n你的任务是帮助 Alice，与由评测程序模拟的 Bob 进行游戏。\n\n定义一局游戏的“最优分数”为当 Alice 和 Bob 都采用最优策略进行游戏时最终得到的排列的分数。\n\n你需要求出本局游戏的最优分数，然后与 Bob 进行游戏，且需要在若干轮后至少达到最优分数。\n\n请注意：你实现的 Alice 的策略应当是普适性的，能够处理 Bob 可能采用的各种策略，即使 Bob 采用的策略可能并非最优。\n\n### 实现细节\n\n你要实现以下函数：\n\n```cpp\nint Alice(int m, int e, std::vector<int> u, std::vector<int> v, int n, std::vector<int> p)\n```\n\n- `m`: 图中顶点个数。\n- `e`: 图中边的数量。\n- `u` 和 `v`: 长度为 `e` 的数组，描述图中的边。\n- `n`: 排列的长度。\n- `p`: 长度为 `n` 的数组，描述排列。\n\n该函数恰好被调用一次。\n该函数应该返回一个整数，即游戏的最后分数，假设 Alice 和 Bob 都以最优策略玩游戏。\n\n在该函数中，你可以调用以下函数：\n\n```cpp\nint Bob(std::vector<int> t)\n```\n\n- `t`: 长度为 $m$ 的数组，包含一组两两不同的下标，满足 $0 \\leq t[i] < n$ 且对于任意 $i \\neq j$ 均有 $t[i] \\neq t[j]$。\n- 该函数返回一个整数 $j$，满足 $0 \\leq j < e$。\n- 该函数可以被调用多次。", "inputFormat": null, "outputFormat": null, "hint": "### 例子\n\n考虑以下调用：\n\n```cpp\nAlice(5, 6, [4, 0, 3, 1, 4, 2], [2, 2, 0, 2, 0, 3], 10, [8, 2, 7, 6, 1, 5, 0, 9, 3, 4])\n```\n\n如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lo1c6nt9.png)\n\n$p$ 的初值为 $[8, 2, 7, 6, 1, 5, 0, 9, 3, 4]$。\n\n给定以上约束条件，我们可以证明排列的最优分数为 1。\n\n假设，Alice 做了以下 4 次操作：\n\n| 给 Bob 的参数 $t$ | Bob 返回的值 | $p$ 对应的下标 | Bob 交换后的 $p$ |\n|------------------|-------------|----------------|------------------|\n| [3, 1, 5, 2, 0]  | 5           | 5, 2           | [8, 2, 5, 6, 1, 7, 0, 9, 3, 4] |\n| [9, 3, 7, 2, 1]  | 0           | 1, 7           | [8, 9, 5, 6, 1, 7, 0, 2, 3, 4] |\n| [5, 6, 7, 8, 9]  | 1           | 5, 7           | [8, 9, 5, 6, 1, 2, 0, 7, 3, 4] |\n| [7, 5, 2, 3, 6]  | 3           | 5, 2           | [8, 9, 2, 6, 1, 5, 0, 7, 3, 4] |\n\n注意 Alice 和 Bob 所做的操作不一定是最优的。上面显示的操作纯粹是为了演示。另外，注意到 Alice 实际上可以在一开始就结束游戏，因为最开始的排列分数已经达到了最优分数 1。\n\n在 Alice 做了上述所有操作后，排列的实际分数为 $3$（$p[2] = 2$, $p[5] = 5$, $p[7] = 7$）。\n\n函数 `Alice()` 最后返回值为 1，即排列的最优分数。\n\n请注意，即使 Alice 通过与 Bob 玩游戏获得了分数 3，但如果函数 `Alice()` 的返回值是 3 而不是 1，你将获得 0 分。\n\n### 约束条件\n\n- $2 \\leq m \\leq 400$\n- $m - 1 \\leq e \\leq 400$\n- $0 \\leq u[i], v[i] < m$\n- $m \\leq n \\leq 400$\n- $0 \\leq p[i] < n$\n\n图是连通的，并且没有自环和重边。\n$p$ 是一个排列，即对任意 $i \\neq j$, $p[i] \\neq p[j]$。\n\n### 子任务\n\n1. (6 分) $m = 2$\n2. (6 分) $e > m$\n3. (10 分) $e = m - 1$\n4. (24 分) $e = m = 3$\n5. (24 分) $e = m = 4$\n6. (30 分) $e = m$\n\n对于每个子任务，你可以获得部分分数。设 $r$ 是 $\\frac{k}{n}$ 在某个子任务的所有测试用例中的最大比值，其中 $k$ 是回合数（即对 `Bob()` 的调用次数）。那么，你在该子任务的得分为该子任务的满分乘以以下数字：\n\n| 条件         | 乘数                  |\n|--------------|-----------------------|\n| $12 \\leq r$  | 0                     |\n| $3 < r < 12$ | $1 - \\log_{10}(r - 2)$ |\n| $r \\leq 3$   | 1                     |\n\n特别地，如果在 $3n$ 个回合内解决问题，则该子任务将获得满分。使用超过 $12n$ 个回合将导致该子任务获得 0 分（显示为 output isn't correct）。\n\n### 评测程序示例\n\n评测程序示例按以下格式读取输入：\n\n- 第 1 行: $m\\,e$\n- 第 $2 + i$ 行 $(0 \\leq i \\leq e - 1)$: $u[i]\\, v[i]$\n- 第 $2 + e$ 行: $n$\n- 第 $3 + e$ 行: $p[0]\\, p[1]\\, \\ldots\\, p[n - 1]$\n\n评测程序示例按以下格式打印你的答案：\n\n- 第 1 行: 最后排列 $p$\n- 第 2 行: `Alice()` 的返回值\n- 第 3 行: 最后排列的实际得分\n- 第 4 行: 回合数", "locale": "zh-CN"}}}
{"pid": "P12543", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "2025", "APIO", "交互题", "Special Judge"], "title": "[APIO2025] Rotating Lines", "background": "", "description": "Asadullo is an outstanding researcher at APIO (Alliance for Power and Industrial Optimization). Recently, he has been studying a method to generate energy using an unknown material.\n\nThis unknown material does not produce energy on its own, but if there are several extremely long rods made of this material, they can generate energy through their interactions.\n\nSpecifically, there are $n$ rods, given by an array $v[0], v[1], \\ldots, v[n-1]$. The $i$-th rod can be positioned at an angle of $a[i] = 360 \\cdot \\frac{v[i]}{100000}$, with respect to the positive direction of the x-axis, in counterclockwise. The energy efficiency by these $n$ rods is defined as\n\n$$\\sum_{i<j} \\text{acute}(i,j)$$\n\nwhere $\\text{acute}(i,j)$ represents the acute angle formed between the $i$-th rod and the $j$-th rod. In this problem, we consider $90^\\circ$ as an acute angle.\n\nMore formally, $\\text{acute}(i,j) = \\min(|v[i] - v[j]|, 50000 - |v[i] - v[j]|)$.\n\nIn other words, the energy efficiency is calculated by adding the acute angles between every pair of rods.\n\nFor example, if $v = [5000, 12500, 37500]$ and correspondingly, $a = [18, 45, 135]$, we would get the following graph:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xkk4vtuf.png)\n\nHere, acute(0, 1) = 7500 (i.e. 27°), acute(0, 2) = 17500 (i.e. 63°), and acute(1, 2) = 25000 (i.e. 90°).\nTherefore, the energy efficiency of these rods equals $7500 + 17500 + 25000 = 50000$.\n\nAsadullo wants to adjust the arrangement of these $n$ rods to maximize their energy efficiency.\nHowever, there are several constraints:\n\n- First, since this material is extremely hazardous to living beings, the rods can only be rotated using a specialized mechanical device in a controlled manner. This device allows selecting multiple rods at once and rotating them by the same angle simultaneously.\n- Asadullo does not want the energy efficiency of the rods to decrease. Therefore, after any operation using the device, the energy efficiency must not be lower than before.\n- Since operating the device consumes a large amount of energy, the total number of rods selected across all operations must not exceed 2 000 000.\n\nUnder these constraints, Asadullo wants to perform operations optimally to maximize the energy efficiency of the rods. Write a program to help Asadullo achieve the highest possible energy efficiency.\n\n### Implementation details\n\nYou should implement the following procedure:\n\n```cpp\nvoid energy(int n, std::vector<int> v)\n```\n\n- $n$: the number of rods.\n- $v$: an array of length $n$ containing information about the rods.\n- This procedure is called exactly once.\n\nWithin this procedure, you may call the following procedure:\n\n```cpp\nvoid rotate(std::vector<int> t, int x)\n```\n\n- $t$: an array of distinct indices, i.e. $0 \\leq t[i] < n$ for each $i$ and $t[i] \\neq t[j]$ for each $i < j$. Array $t$ is not required to be sorted.\n- This procedure rotates every rod which index is given in the array $t$ by parameter $x$, simultaneously. That is, $v[i]$ becomes $(v[i] + x) \\mod 50000$ for every index $i$ which is present in $t$.\n- This procedure can be called multiple times. The total length of $t$ over all calls must not exceed 2 000 000.\n", "inputFormat": "", "outputFormat": "", "hint": "### Examples\n\n#### Example 1\n\nConsider the following call:\n\n```cpp\nenergy(2, [20000, 10000])\n```\n\nHere, $v = [20000, 10000]$ and the initial energy efficiency equals $20000 - 10000 = 10000$. One of the possible scenarios is the following:\n\n- call `rotate([0, 1], 8000)`. Then $v$ becomes $[28000, 18000]$. The energy efficiency stays the same.\n- call `rotate([0], 15000)`. Then $v$ becomes $[43000, 18000]$. The energy efficiency becomes $43000 - 18000 = 25000$.\n\nIt can be shown that for the given input, 25000 is the maximum possible energy efficiency. Therefore, Asadullo can stop performing these operations.\n\n#### Example 2\n\nConsider the following call:\n\n```cpp\nenergy(3, [5000, 12500, 37500])\n```\n\nThe image for this example was presented above. It can be shown that the initial energy efficiency is the maximum possible. Thus, no operations are needed.\n\n### Constraints\n\n- $2 \\leq n \\leq 100 \\, 000$\n- $0 \\leq v[i] \\leq 49 \\, 999$ for each $0 \\leq i < n$\n- elements of $v$ are **not** necessarily distinct\n\n### Subtasks\n\n1. (5 points) $n = 2$\n2. (11 points) $v[i] < 25 \\, 000$ for each $0 \\leq i < n$\n3. (8 points) $n \\leq 10$\n4. (15 points) $n \\leq 100$\n5. (15 points) $n \\leq 300$\n6. (20 points) $n \\leq 2000$\n7. (26 points) No additional constraints.\n\n### Sample Grader\n\nThe sample grader reads the input in the following format:\n\n- line 1: $n$\n- line 2: $v[0] \\, v[1] \\ldots \\, v[n - 1]$\n\nThe sample grader prints the output in the following format:\n\n- line 1: final energy efficiency of rods\n\nAlso, the grader will write detailed information about the rotations you made in the file `log.txt`.\n", "locale": "en", "translations": {"en": {"title": "[APIO2025] Rotating Lines", "background": "", "description": "Asadullo is an outstanding researcher at APIO (Alliance for Power and Industrial Optimization). Recently, he has been studying a method to generate energy using an unknown material.\n\nThis unknown material does not produce energy on its own, but if there are several extremely long rods made of this material, they can generate energy through their interactions.\n\nSpecifically, there are $n$ rods, given by an array $v[0], v[1], \\ldots, v[n-1]$. The $i$-th rod can be positioned at an angle of $a[i] = 360 \\cdot \\frac{v[i]}{100000}$, with respect to the positive direction of the x-axis, in counterclockwise. The energy efficiency by these $n$ rods is defined as\n\n$$\\sum_{i<j} \\text{acute}(i,j)$$\n\nwhere $\\text{acute}(i,j)$ represents the acute angle formed between the $i$-th rod and the $j$-th rod. In this problem, we consider $90^\\circ$ as an acute angle.\n\nMore formally, $\\text{acute}(i,j) = \\min(|v[i] - v[j]|, 50000 - |v[i] - v[j]|)$.\n\nIn other words, the energy efficiency is calculated by adding the acute angles between every pair of rods.\n\nFor example, if $v = [5000, 12500, 37500]$ and correspondingly, $a = [18, 45, 135]$, we would get the following graph:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xkk4vtuf.png)\n\nHere, acute(0, 1) = 7500 (i.e. 27°), acute(0, 2) = 17500 (i.e. 63°), and acute(1, 2) = 25000 (i.e. 90°).\nTherefore, the energy efficiency of these rods equals $7500 + 17500 + 25000 = 50000$.\n\nAsadullo wants to adjust the arrangement of these $n$ rods to maximize their energy efficiency.\nHowever, there are several constraints:\n\n- First, since this material is extremely hazardous to living beings, the rods can only be rotated using a specialized mechanical device in a controlled manner. This device allows selecting multiple rods at once and rotating them by the same angle simultaneously.\n- Asadullo does not want the energy efficiency of the rods to decrease. Therefore, after any operation using the device, the energy efficiency must not be lower than before.\n- Since operating the device consumes a large amount of energy, the total number of rods selected across all operations must not exceed 2 000 000.\n\nUnder these constraints, Asadullo wants to perform operations optimally to maximize the energy efficiency of the rods. Write a program to help Asadullo achieve the highest possible energy efficiency.\n\n### Implementation details\n\nYou should implement the following procedure:\n\n```cpp\nvoid energy(int n, std::vector<int> v)\n```\n\n- $n$: the number of rods.\n- $v$: an array of length $n$ containing information about the rods.\n- This procedure is called exactly once.\n\nWithin this procedure, you may call the following procedure:\n\n```cpp\nvoid rotate(std::vector<int> t, int x)\n```\n\n- $t$: an array of distinct indices, i.e. $0 \\leq t[i] < n$ for each $i$ and $t[i] \\neq t[j]$ for each $i < j$. Array $t$ is not required to be sorted.\n- This procedure rotates every rod which index is given in the array $t$ by parameter $x$, simultaneously. That is, $v[i]$ becomes $(v[i] + x) \\mod 50000$ for every index $i$ which is present in $t$.\n- This procedure can be called multiple times. The total length of $t$ over all calls must not exceed 2 000 000.\n", "inputFormat": "", "outputFormat": "", "hint": "### Examples\n\n#### Example 1\n\nConsider the following call:\n\n```cpp\nenergy(2, [20000, 10000])\n```\n\nHere, $v = [20000, 10000]$ and the initial energy efficiency equals $20000 - 10000 = 10000$. One of the possible scenarios is the following:\n\n- call `rotate([0, 1], 8000)`. Then $v$ becomes $[28000, 18000]$. The energy efficiency stays the same.\n- call `rotate([0], 15000)`. Then $v$ becomes $[43000, 18000]$. The energy efficiency becomes $43000 - 18000 = 25000$.\n\nIt can be shown that for the given input, 25000 is the maximum possible energy efficiency. Therefore, Asadullo can stop performing these operations.\n\n#### Example 2\n\nConsider the following call:\n\n```cpp\nenergy(3, [5000, 12500, 37500])\n```\n\nThe image for this example was presented above. It can be shown that the initial energy efficiency is the maximum possible. Thus, no operations are needed.\n\n### Constraints\n\n- $2 \\leq n \\leq 100 \\, 000$\n- $0 \\leq v[i] \\leq 49 \\, 999$ for each $0 \\leq i < n$\n- elements of $v$ are **not** necessarily distinct\n\n### Subtasks\n\n1. (5 points) $n = 2$\n2. (11 points) $v[i] < 25 \\, 000$ for each $0 \\leq i < n$\n3. (8 points) $n \\leq 10$\n4. (15 points) $n \\leq 100$\n5. (15 points) $n \\leq 300$\n6. (20 points) $n \\leq 2000$\n7. (26 points) No additional constraints.\n\n### Sample Grader\n\nThe sample grader reads the input in the following format:\n\n- line 1: $n$\n- line 2: $v[0] \\, v[1] \\ldots \\, v[n - 1]$\n\nThe sample grader prints the output in the following format:\n\n- line 1: final energy efficiency of rods\n\nAlso, the grader will write detailed information about the rotations you made in the file `log.txt`.\n", "locale": "en"}, "zh-CN": {"title": "[APIO2025] 转杆", "background": "请注意：本题只支持 C++ 语言提交；你不需要也不应该实现 `main` 函数；你需要在程序开头添加如下内容：\n\n```cpp\n#include <vector>\n\nvoid energy(int n, std::vector<int> v);\nvoid rotate(std::vector<int> t, int x);\n```", "description": "Asadullo 是电力与工业优化联盟（Alliance for Power and Industrial Optimization，APIO）的杰出研究员。最近，他研究出利用一种未知材料的发电方法。\n\n这种未知材料不能单独地发电；但如果用这种材料制造出若干极长的杆，这些长杆之间的相互作用能产生电力。\n\n特别地，给定 $n$ 根长杆的属性 $v[0], v[1], \\ldots, v[n-1]$。该属性描述了第 $i$ 根长杆放置在与 $x$ 轴正方向逆时针成 $a[i] = 360 \\cdot \\frac{v[i]}{100000}$ 的角度。这 $n$ 根长杆的发电效率为：\n\n$$\\sum_{i<j} \\operatorname{acute}(i,j)$$\n\n其中 $\\operatorname{acute}(i,j)$ 表示第 $i$ 根长杆和第 $j$ 根长杆所形成的锐角。在本题中，我们认为 $90^\\circ$ 也是锐角。形式化地，$\\operatorname{acute}(i,j) = \\min(|v[i] - v[j]|, 50000 - |v[i] - v[j]|)$。\n\n换句话说，发电效率取决于每对长杆所形成的锐角度数的总和。\n\n例如，当 $v = [5000, 12500, 37500]$ 则相应地 $a = [18, 45, 135]$，我们将得到下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xkk4vtuf.png)\n\n此图中，$\\operatorname{acute}(0,1) = 7500$（即 $27^\\circ$），$\\operatorname{acute}(0,2) = 17500$（即 $63^\\circ$），以及 $\\operatorname{acute}(1,2) = 25000$（即 $90^\\circ$）。因此，这些长杆的发电效率等于 $7500 + 17500 + 25000 = 50000$。\n\nAsadullo 想要调整这 $n$ 根长杆的相对角度以最大化发电效率。然而，存在以下约束条件：\n\n- 首先，由于长杆的材料对生命体具有极高危害，这些长杆只能在受控的方式下操作一个特殊的机械装置来转动。这个装置允许选择若干长杆，并将所有选择的长杆转动相同的角度。\n- Asadullo 不希望这些长杆的发电效率降低。因此，每次操作后，发电效率都不能低于转动前的发电效率。\n- 由于操作这个装置需要耗费大量的能量，所有操作里被选择的长杆总数不能超过 2000000。\n\n在这些约束条件下，Asadullo 希望执行最优的若干操作，来最大化这些长杆的发电效率。写一段代码来帮助 Asadullo 实现最大可能的发电效率。\n\n### 实现细节\n\n你需要实现以下函数：\n\n```cpp\nvoid energy(int n, std::vector<int> v)\n```\n\n- `n`：长杆的数目。\n- `v`：大小为 `n` 的数组描述这些长杆的属性。\n- 这个函数给调用一次。\n\n在上述函数里，你可以调用以下函数：\n\n```cpp\nvoid rotate(std::vector<int> t, int x)\n```\n\n- `t`：互不相同的元素组成的下标数组，即对任意 `i` 有 $0 \\leq t[i] < n$，且对任意 $i < j$ 有 $t[i] \\neq t[j]$。数组 `t` 不要求有序。\n- 这个函数将下标数组 `t` 所选择的长杆同时转动 `x` 个单位。那么，每个在 `t` 数组的元素 `i`，将使 `v[i]` 变成 $(v[i] + x) \\mod 50000$。\n- 这个函数可以被调用多次。数组 `t` 在所有调用里的累加长度不能超过 2000000。", "inputFormat": null, "outputFormat": null, "hint": "### 例子\n\n#### 例 1\n\n考虑以下函数调用：\n\n```cpp\nenergy(2, [20000, 10000])\n```\n\n此处，$v = [20000, 10000]$ 且初始的发电效率为 $20000 - 10000 = 10000$。以下是一种可能的场景：\n\n1. 调用 `rotate([0, 1], 8000)`。那么 `v` 变成 `[28000,18000]`。发电效率保持不变。\n2. 调用 `rotate([0], 15000)`。那么 `v` 变成 `[43000,18000]`。发电效率变成 $43000 - 18000 = 25000$。\n\n可以证明，对于初始配置，25000 是能实现的最大发电效率。因此，Asadullo 可以停止操作。\n\n#### 例 2\n\n考虑以下函数调用：\n\n```cpp\nenergy(3, [5000, 12500, 37500])\n```\n\n题面的示例插图描述的就是这个例子，可以证明，初始配置实现的即是最大的发电效率。所以，不需要执行任何操作。\n\n### 约束条件\n\n- $2 \\leq n \\leq 100 \\, 000$\n- 对任意的 $0 \\leq i < n$，满足 $0 \\leq v[i] \\leq 49 \\, 999$\n- 数组 `v` 的元素不一定互不相同\n\n### 子任务\n\n1. (5 分) $n = 2$\n2. (11 分) 对于每个 $0 \\leq i < n$，均有 $v[i] < 25 \\, 000$\n3. (8 分) $n \\leq 10$\n4. (15 分) $n \\leq 100$\n5. (15 分) $n \\leq 300$\n6. (20 分) $n \\leq 2000$\n7. (26 分) 没有额外的约束条件。\n\n### 评测程序示例\n\n评测程序示例按以下格式读取输入：\n\n- 第 1 行：$n$\n- 第 2 行：$v[0] \\, v[1] \\ldots \\, v[n-1]$\n\n评测程序示例按以下格式打印输出：\n\n- 第 1 行：长杆最终的发电效率\n\n此外，评测程序示例会将你所调用的转动操作的详细信息写入 `log.txt` 文件。", "locale": "zh-CN"}}}
{"pid": "P12544", "type": "P", "difficulty": 5, "samples": [["3\n2\n1 2 3\n3 4 5\n5\n1 2 1\n1 3 4\n4 5 2\n3 4 2\n1 4 3\n4\n1 2 3\n2 3 4\n3 5 4\n1 3 2", "5\n9\n10"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2025", "UOI（乌克兰）"], "title": "[UOI 2025] Boys and Girls", "background": "", "description": "There are $n$ types of boys and $2 \\cdot n$ girls. The types of boys are numbered with integers from $1$ to $n$, while the girls are numbered with integers from $1$ to $2 \\cdot n$.\n\nThere are $c_i$ boys of the $i$-th type, and each of them likes girls numbered $a_i$ and $b_i$.\n\nFind the size of the largest set of boys such that for every pair of boys in this set, there is at least one girl that both of them like.\n\nIn this problem, each test contains several sets of input data. You need to solve the problem independently for each such set.", "inputFormat": "The first line contains one integer $T$ $(1 \\le T \\le 500)$ --- the number of sets of input data. The description of the input data sets follows.\n\nIn the first line of each input data set, there is one integer $n$ $(1 \\le n \\le 7 \\cdot 10^5)$.\n\nIn the next $n$ lines, there are three integers $a_i$, $b_i$, $c_i$ $(1 \\le a_i < b_i \\le 2 \\cdot n, 1 \\le c_i \\le 10^9)$ --- the parameters for the corresponding type of boys.\n\nIt is guaranteed that $a_i \\ne a_j$ or $b_i \\ne b_j$ for any $1 \\le i < j \\le n$.\n\nIt is guaranteed that the sum of $n$ across all input data sets of a single test does not exceed $7 \\cdot 10^5$.", "outputFormat": "For each set of input data, output one integer on a separate line --- the size of the largest set of boys such that for every pair of boys in this set, there is at least one girl that both of them like.", "hint": "Let $S$ be the sum of $n$ over all test case input sets of one test, and $K$ be the sum of all $c_i$ over all test case input sets of one test.\n\n- ($5$ points): $n \\le 5$;\n- ($11$ points): $S \\le 100$;\n- ($7$ points): each girl is liked by boys of no more than two types;\n- ($10$ points): $S \\le 3000$;\n- ($23$ points): $S \\le 3 \\cdot 10^5$;\n- ($19$ points): $K \\le 10^7$;\n- ($25$ points): with no additional constraints.", "locale": "en", "translations": {"en": {"title": "[UOI 2025] Boys and Girls", "background": "", "description": "There are $n$ types of boys and $2 \\cdot n$ girls. The types of boys are numbered with integers from $1$ to $n$, while the girls are numbered with integers from $1$ to $2 \\cdot n$.\n\nThere are $c_i$ boys of the $i$-th type, and each of them likes girls numbered $a_i$ and $b_i$.\n\nFind the size of the largest set of boys such that for every pair of boys in this set, there is at least one girl that both of them like.\n\nIn this problem, each test contains several sets of input data. You need to solve the problem independently for each such set.", "inputFormat": "The first line contains one integer $T$ $(1 \\le T \\le 500)$ --- the number of sets of input data. The description of the input data sets follows.\n\nIn the first line of each input data set, there is one integer $n$ $(1 \\le n \\le 7 \\cdot 10^5)$.\n\nIn the next $n$ lines, there are three integers $a_i$, $b_i$, $c_i$ $(1 \\le a_i < b_i \\le 2 \\cdot n, 1 \\le c_i \\le 10^9)$ --- the parameters for the corresponding type of boys.\n\nIt is guaranteed that $a_i \\ne a_j$ or $b_i \\ne b_j$ for any $1 \\le i < j \\le n$.\n\nIt is guaranteed that the sum of $n$ across all input data sets of a single test does not exceed $7 \\cdot 10^5$.", "outputFormat": "For each set of input data, output one integer on a separate line --- the size of the largest set of boys such that for every pair of boys in this set, there is at least one girl that both of them like.", "hint": "Let $S$ be the sum of $n$ over all test case input sets of one test, and $K$ be the sum of all $c_i$ over all test case input sets of one test.\n\n- ($5$ points): $n \\le 5$;\n- ($11$ points): $S \\le 100$;\n- ($7$ points): each girl is liked by boys of no more than two types;\n- ($10$ points): $S \\le 3000$;\n- ($23$ points): $S \\le 3 \\cdot 10^5$;\n- ($19$ points): $K \\le 10^7$;\n- ($25$ points): with no additional constraints.", "locale": "en"}, "zh-CN": {"title": "[UOI 2025] Boys and Girls", "background": null, "description": "有 $n$ 种类型的男孩和 $2 \\cdot n$ 个女孩。男孩的类型用从 $1$ 到 $n$ 的整数编号，而女孩用从 $1$ 到 $2 \\cdot n$ 的整数编号。\n\n第 $i$ 种类型的男孩有 $c_i$ 个，这 $c_i$ 个男孩中的每一个都喜欢编号为 $a_i$ 和 $b_i$ 的女孩。\n\n求一个最大的男孩集合的大小，使得对于该集合中的任意两个男孩，至少存在一个女孩被他们两人都喜欢。\n\n本题中，每个测试点包含多组输入数据。你需要对每组数据独立求解。", "inputFormat": "第一行包含一个整数 $T$ $(1 \\le T \\le 500)$ —— 输入数据的组数。接下来是各组数据的描述。\n\n每组数据的第一行包含一个整数 $n$ $(1 \\le n \\le 7 \\cdot 10^5)$。\n\n接下来的 $n$ 行，每行包含三个整数 $a_i$, $b_i$, $c_i$ $(1 \\le a_i < b_i \\le 2 \\cdot n, 1 \\le c_i \\le 10^9)$ —— 对应类型男孩的参数。\n\n保证对于任意 $1 \\le i < j \\le n$，满足 $a_i \\ne a_j$ 或 $b_i \\ne b_j$。\n\n保证单个测试点中所有输入数据的 $n$ 之和不超过 $7 \\cdot 10^5$。", "outputFormat": "对于每组输入数据，输出一行一个整数 —— 满足条件的最大男孩集合的大小。", "hint": "设 $S$ 为单个测试点中所有输入数据的 $n$ 之和，$K$ 为单个测试点中所有 $c_i$ 之和。\n\n- （$5$ 分）：$n \\le 5$；\n- （$11$ 分）：$S \\le 100$；\n- （$7$ 分）：每个女孩最多被两种类型的男孩喜欢；\n- （$10$ 分）：$S \\le 3000$；\n- （$23$ 分）：$S \\le 3 \\cdot 10^5$；\n- （$19$ 分）：$K \\le 10^7$；\n- （$25$ 分）：无额外限制。\n\n对样例第二组输入数据的解释：\n\n- 如果我们选择类型为 2、4 和 5 的男孩，我们可以得到答案 9。也就是说，被选中的男孩喜欢的女孩对 $(a_i, b_i)$ 为 $(1, 3)$、$(3, 4)$ 和 $(1, 4)$。\n- 很容易看出，对于这个集合中的任意一对男孩，都存在至少一个他们共同喜欢的女孩。", "locale": "zh-CN"}}}
{"pid": "P12545", "type": "P", "difficulty": 5, "samples": [["4\n1 2 3 4", "1\n1 3 4"], ["7\n1 6 1 0 5 3 2", "0\n2 3 6"], ["8\n3 1 4 1 5 9 2 6", "1\n3 6 8"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2025", "Special Judge", "UOI（乌克兰）"], "title": "[UOI 2025] Partitioning into Three", "background": "", "description": "There are $n$ **non-negative** integers $a_1, a_2, \\ldots, a_n$ arranged in a circle. The neighboring numbers in the circular order are $a_1$ and $a_2$, $a_2$ and $a_3$, $\\ldots$, $a_{n-1}$ and $a_n$, $a_n$ and $a_1$.\n\nPartition these numbers into three **non-empty** groups such that each number belongs to exactly one group, the numbers in each group are **consecutively arranged in a circle**, and the difference between the maximum and minimum sums of the numbers in the groups is minimized.", "inputFormat": "The first line contains one integer $n$ $(3 \\le n \\le 10^6)$ --- the number of arranged numbers.\n\nThe second line contains $n$ non-negative integers $a_1, a_2, \\ldots, a_n$ $(0 \\le a_i \\le 10^9)$ --- the numbers arranged in a circle.", "outputFormat": "In the first line, output one integer --- the difference between the maximum and minimum sums of the numbers in the groups in the optimal partition.\n\nIn the second line, output three integers $x$, $y$, $z$ $(1 \\le x < y < z \\le n)$ --- such indices that the optimal partition of the numbers into three groups is of the form $[a_{x}, a_{x+1}, \\ldots, a_{y-1}]$, $[a_{y}, a_{y+1}, \\ldots, a_{z-1}]$, $[a_{z}, a_{z+1}, \\ldots, a_{n-1}, a_{n}, a_{1}, a_{2}, \\ldots, a_{x-1}]$.\n\nIf there are multiple correct answers, any of them is allowed to be output.", "hint": "In the third example, the optimal partition looks as follows: \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tgfp8q6u.png)\n\nIn this case, the sums in the groups are $10$, $11$, and $10$.\n\n### Scoring\n\n- ($2$ points): $n = 3$;\n- ($4$ points): $a_i \\le 1$ for $1 \\le i \\le n$;\n- ($13$ points): there exists a partition where the sought difference is equal to $0$;\n- ($8$ points): $n \\le 100$;\n- ($9$ points): $n \\le 2000$;\n- ($13$ points): $n \\le 5000$;\n- ($28$ points): $n \\le 10^5$;\n- ($23$ points): with no additional restrictions.", "locale": "en", "translations": {"en": {"title": "[UOI 2025] Partitioning into Three", "background": "", "description": "There are $n$ **non-negative** integers $a_1, a_2, \\ldots, a_n$ arranged in a circle. The neighboring numbers in the circular order are $a_1$ and $a_2$, $a_2$ and $a_3$, $\\ldots$, $a_{n-1}$ and $a_n$, $a_n$ and $a_1$.\n\nPartition these numbers into three **non-empty** groups such that each number belongs to exactly one group, the numbers in each group are **consecutively arranged in a circle**, and the difference between the maximum and minimum sums of the numbers in the groups is minimized.", "inputFormat": "The first line contains one integer $n$ $(3 \\le n \\le 10^6)$ --- the number of arranged numbers.\n\nThe second line contains $n$ non-negative integers $a_1, a_2, \\ldots, a_n$ $(0 \\le a_i \\le 10^9)$ --- the numbers arranged in a circle.", "outputFormat": "In the first line, output one integer --- the difference between the maximum and minimum sums of the numbers in the groups in the optimal partition.\n\nIn the second line, output three integers $x$, $y$, $z$ $(1 \\le x < y < z \\le n)$ --- such indices that the optimal partition of the numbers into three groups is of the form $[a_{x}, a_{x+1}, \\ldots, a_{y-1}]$, $[a_{y}, a_{y+1}, \\ldots, a_{z-1}]$, $[a_{z}, a_{z+1}, \\ldots, a_{n-1}, a_{n}, a_{1}, a_{2}, \\ldots, a_{x-1}]$.\n\nIf there are multiple correct answers, any of them is allowed to be output.", "hint": "In the third example, the optimal partition looks as follows: \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tgfp8q6u.png)\n\nIn this case, the sums in the groups are $10$, $11$, and $10$.\n\n### Scoring\n\n- ($2$ points): $n = 3$;\n- ($4$ points): $a_i \\le 1$ for $1 \\le i \\le n$;\n- ($13$ points): there exists a partition where the sought difference is equal to $0$;\n- ($8$ points): $n \\le 100$;\n- ($9$ points): $n \\le 2000$;\n- ($13$ points): $n \\le 5000$;\n- ($28$ points): $n \\le 10^5$;\n- ($23$ points): with no additional restrictions.", "locale": "en"}, "zh-CN": {"title": "[UOI 2025] Partitioning into Three", "background": "", "description": "有 $n$ 个**非负**整数 $a_1, a_2, \\ldots, a_n$ 排成一个环形。环形顺序中相邻的数字为 $a_1$ 和 $a_2$，$a_2$ 和 $a_3$，$\\ldots$，$a_{n-1}$ 和 $a_n$，$a_n$ 和 $a_1$。\n\n将这些数字分成三个**非空**的组，使得每个数字恰好属于一个组，每组中的数字在环形排列中是**连续的**，并且各组数字之和的最大值与最小值之差最小。", "inputFormat": "第一行包含一个整数 $n$ $(3 \\le n \\le 10^6)$ —— 排列的数字个数。\n\n第二行包含 $n$ 个非负整数 $a_1, a_2, \\ldots, a_n$ $(0 \\le a_i \\le 10^9)$ —— 环形排列的数字。", "outputFormat": "第一行输出一个整数 —— 最优划分下各组数字之和的最大值与最小值之差。\n\n第二行输出三个整数 $x$, $y$, $z$ $(1 \\le x < y < z \\le n)$ —— 表示最优划分的三个组的边界索引，其中：\n- 第一组为 $[a_{x}, a_{x+1}, \\ldots, a_{y-1}]$，\n- 第二组为 $[a_{y}, a_{y+1}, \\ldots, a_{z-1}]$，\n- 第三组为 $[a_{z}, a_{z+1}, \\ldots, a_{n-1}, a_{n}, a_{1}, a_{2}, \\ldots, a_{x-1}]$。\n\n如果存在多个正确答案，输出任意一个均可。", "hint": "在第三个样例中，最优划分如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tgfp8q6u.png)\n\n此时，各组的数字之和分别为 $10$、$11$ 和 $10$。\n\n### 评分标准\n\n- （$2$ 分）：$n = 3$；\n- （$4$ 分）：对于所有 $1 \\le i \\le n$，$a_i \\le 1$；\n- （$13$ 分）：存在一种划分使得所求差值为 $0$；\n- （$8$ 分）：$n \\le 100$；\n- （$9$ 分）：$n \\le 2000$；\n- （$13$ 分）：$n \\le 5000$；\n- （$28$ 分）：$n \\le 10^5$；\n- （$23$ 分）：无额外限制。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12546", "type": "P", "difficulty": 6, "samples": [["10\n4\n0 3 4 6\n4\n5 4 1 4\n8\n1 4 4 8 6 10 10 4\n7\n2 1 5 1 9 4 6\n6\n7 1 6 10 2 3\n7\n6 6 10 2 5 3 8\n4\n9 9 1 5\n4\n8 4 3 4\n7\n1 2 1 6 4 2 9\n7\n3 9 7 5 9 10 10", "YES\nNO\nNO\nYES\nYES\nNO\nYES\nYES\nYES\nNO"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2025", "动态规划优化", "分类讨论", "UOI（乌克兰）"], "title": "[UOI 2025] Convex Array", "background": "", "description": "You are given an array of integers $a$ of length $n$.\n\nDetermine whether there exists a permutation of its elements $b$ such that for every $2\\leq i \\leq n-1$, the condition $b_{i-1} + b_{i+1} \\ge 2\\cdot b_i$ holds.\n\nIn this problem, each test contains several sets of input data. You need to solve the problem independently for each such set.", "inputFormat": "The first line contains a single integer $T$ $(1\\le T\\le 10^5)$ --- the number of sets of input data. The description of the input data sets follows.\n\nIn the first line of each input data set, there is a single integer $n$ $(3\\le n\\le 3\\cdot 10^5)$ --- the length of the array $a$.\n\nIn the second line of each input data set, there are $n$ integers $a_1, a_2, \\ldots, a_n$ $(0\\le a_i\\le 10^9)$ --- the elements of the array $a$.\n\nIt is guaranteed that the sum of $n$ across all input data sets of a single test does not exceed $3\\cdot 10^5$.", "outputFormat": "For each set of input data, output on a separate line $\\tt{YES}$, if the desired permutation exists, and $\\tt{NO}$ otherwise.", "hint": "In the first set of input data from the first example, the permutations of the array $[0, 3, 4, 6]$ that satisfy the described condition are $[4, 0, 3, 6]$ and $[6, 3, 0, 4]$.\n\n### Scoring\n\nLet $S$ be the sum $n$ over all input data sets of one test.\n\n- ($3$ points): $n = 4$;\n- ($4$ points): $T = 1$, $n \\le 7$;\n- ($7$ points): $T = 1$, $n \\le 15$;\n- ($5$ points): if some desired permutation exists, then there exists such a desired permutation for which $b_1 \\ge b_2$ and $b_2 \\le b_3$;\n- ($17$ points): $S \\le 50$;\n- ($10$ points): $S \\le 400$;\n- ($13$ points): $S \\le 2000$;\n- ($9$ points): $S \\le 8000$;\n- ($18$ points): $a_i \\le 10^6$ for $1 \\le i \\le n$;\n- ($14$ points): without additional restrictions.", "locale": "en", "translations": {"en": {"title": "[UOI 2025] Convex Array", "background": "", "description": "You are given an array of integers $a$ of length $n$.\n\nDetermine whether there exists a permutation of its elements $b$ such that for every $2\\leq i \\leq n-1$, the condition $b_{i-1} + b_{i+1} \\ge 2\\cdot b_i$ holds.\n\nIn this problem, each test contains several sets of input data. You need to solve the problem independently for each such set.", "inputFormat": "The first line contains a single integer $T$ $(1\\le T\\le 10^5)$ --- the number of sets of input data. The description of the input data sets follows.\n\nIn the first line of each input data set, there is a single integer $n$ $(3\\le n\\le 3\\cdot 10^5)$ --- the length of the array $a$.\n\nIn the second line of each input data set, there are $n$ integers $a_1, a_2, \\ldots, a_n$ $(0\\le a_i\\le 10^9)$ --- the elements of the array $a$.\n\nIt is guaranteed that the sum of $n$ across all input data sets of a single test does not exceed $3\\cdot 10^5$.", "outputFormat": "For each set of input data, output on a separate line $\\tt{YES}$, if the desired permutation exists, and $\\tt{NO}$ otherwise.", "hint": "In the first set of input data from the first example, the permutations of the array $[0, 3, 4, 6]$ that satisfy the described condition are $[4, 0, 3, 6]$ and $[6, 3, 0, 4]$.\n\n### Scoring\n\nLet $S$ be the sum $n$ over all input data sets of one test.\n\n- ($3$ points): $n = 4$;\n- ($4$ points): $T = 1$, $n \\le 7$;\n- ($7$ points): $T = 1$, $n \\le 15$;\n- ($5$ points): if some desired permutation exists, then there exists such a desired permutation for which $b_1 \\ge b_2$ and $b_2 \\le b_3$;\n- ($17$ points): $S \\le 50$;\n- ($10$ points): $S \\le 400$;\n- ($13$ points): $S \\le 2000$;\n- ($9$ points): $S \\le 8000$;\n- ($18$ points): $a_i \\le 10^6$ for $1 \\le i \\le n$;\n- ($14$ points): without additional restrictions.", "locale": "en"}, "zh-CN": {"title": "[UOI 2025] Convex Array", "background": "", "description": "给定一个长度为 $n$ 的整数数组 $a$。\n\n判断是否存在一种元素排列 $b$，使得对于每个 $2 \\leq i \\leq n-1$，都满足条件 $b_{i-1} + b_{i+1} \\geq 2 \\cdot b_i$。\n\n本题中，每个测试点包含多组输入数据。你需要对每组数据独立求解。", "inputFormat": "第一行包含一个整数 $T$ $(1 \\le T \\le 10^5)$ —— 输入数据的组数。接下来是各组数据的描述。\n\n每组数据的第一行包含一个整数 $n$ $(3 \\le n \\le 3 \\cdot 10^5)$ —— 数组 $a$ 的长度。\n\n每组数据的第二行包含 $n$ 个整数 $a_1, a_2, \\ldots, a_n$ $(0 \\le a_i \\le 10^9)$ —— 数组 $a$ 的元素。\n\n保证单个测试点中所有输入数据的 $n$ 之和不超过 $3 \\cdot 10^5$。", "outputFormat": "对于每组输入数据，如果存在满足条件的排列，输出一行 $\\tt{YES}$，否则输出 $\\tt{NO}$。\n", "hint": "在第一个样例的第一组输入数据中，数组 $[0, 3, 4, 6]$ 的满足条件的排列包括 $[4, 0, 3, 6]$ 和 $[6, 3, 0, 4]$。\n\n### 评分标准\n\n设 $S$ 为单个测试点中所有输入数据的 $n$ 之和。\n\n- （$3$ 分）：$n = 4$；\n- （$4$ 分）：$T = 1$，$n \\le 7$；\n- （$7$ 分）：$T = 1$，$n \\le 15$；\n- （$5$ 分）：如果存在满足条件的排列，则存在一种满足条件的排列满足 $b_1 \\ge b_2$ 且 $b_2 \\le b_3$；\n- （$17$ 分）：$S \\le 50$；\n- （$10$ 分）：$S \\le 400$；\n- （$13$ 分）：$S \\le 2000$；\n- （$9$ 分）：$S \\le 8000$；\n- （$18$ 分）：对于所有 $1 \\le i \\le n$，$a_i \\le 10^6$；\n- （$14$ 分）：无额外限制。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12547", "type": "P", "difficulty": 6, "samples": [["5 4\n1 1 1 -1 1\n2 1 5\n1 3\n2 1 4\n2 2 5", "5\n2\n3"], ["4 4\n1 1 1 -1\n2 1 2\n2 2 4\n2 3 3\n2 3 4", "2\n2\n1\n1"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2025", "UOI（乌克兰）"], "title": "[UOI 2025] Simple Subsequence", "background": "", "description": "We call an array of integers $d_1, d_2, \\ldots, d_m$ *good* if its length is equal to $0$, or for any $1\\le i\\le m$, both values $\\sum\\limits_{j=1}^{i} d_j$ and $\\sum\\limits_{j=i}^{m} d_j$ are non-negative. Here, $\\sum\\limits_{j=l}^{r} d_j$ denotes $d_l+d_{l+1}+\\ldots+d_{r}$.\n\nWe define the *beauty* of the array as the length of its longest *good* subsequence$^1$.\n\nYou are given an array $a$ of length $n$, which **consists of numbers $-1$ and $1$**.\n\nYou need to perform $q$ queries. The queries are of two types:\n\n- replace the element $a_p$ with $-a_p$, where $p$ --- the parameter of the query;\n- find the *beauty* of the array consisting of elements $[a_{l},a_{l+1},\\ldots,a_r]$, where $(l, r)$ --- the parameters of the query.", "inputFormat": "In the first line, two integers $n$, $q$ are given $(1\\le n, q\\le 5 \\cdot 10^5)$ --- the length of the array $a$ and the number of queries, respectively.\n\nIn the second line, $n$ integers $a_1, a_2, \\ldots, a_n$ $(a_i \\in \\{-1, 1\\})$ are given --- the elements of the array $a$.\n\nIn the next $q$ lines, the description of the queries is given. The first of the numbers $type_i$ $(1 \\le type_i \\le 2)$ denotes the type of the query. Queries of the first type are given in the format $\\texttt{1 p}$ $(1 \\le p \\le n)$, and queries of the second type are given in the format $\\texttt{2 l r}$ $(1 \\le l \\le r \\le n)$.", "outputFormat": "For each query of the second type, output one integer in a separate line --- the *beauty* of the corresponding array.", "hint": "$^1$ An array $c$ is called a subsequence of an array $b$ if it is possible to remove a certain number of elements from the array $b$ (possibly zero) so that the array $c$ is formed. The empty array is a subsequence of any array.\n\n### Scoring\n\n- ($2$ points): $a_i = (-1)^{i+1}$ for $1 \\le i \\le n$, and there are no type one queries;\n- ($7$ points): $n \\le 16$, and there are no type one queries;\n- ($21$ points): $n, q \\le 100$;\n- ($20$ points): $n, q \\le 3000$;\n- ($27$ points): $n, q \\leq 2 \\cdot 10^5$, and there are no type one queries;\n- ($14$ points): $n, q \\leq 2 \\cdot 10^5$;\n- ($9$ points): no additional restrictions.", "locale": "en", "translations": {"en": {"title": "[UOI 2025] Simple Subsequence", "background": "", "description": "We call an array of integers $d_1, d_2, \\ldots, d_m$ *good* if its length is equal to $0$, or for any $1\\le i\\le m$, both values $\\sum\\limits_{j=1}^{i} d_j$ and $\\sum\\limits_{j=i}^{m} d_j$ are non-negative. Here, $\\sum\\limits_{j=l}^{r} d_j$ denotes $d_l+d_{l+1}+\\ldots+d_{r}$.\n\nWe define the *beauty* of the array as the length of its longest *good* subsequence$^1$.\n\nYou are given an array $a$ of length $n$, which **consists of numbers $-1$ and $1$**.\n\nYou need to perform $q$ queries. The queries are of two types:\n\n- replace the element $a_p$ with $-a_p$, where $p$ --- the parameter of the query;\n- find the *beauty* of the array consisting of elements $[a_{l},a_{l+1},\\ldots,a_r]$, where $(l, r)$ --- the parameters of the query.", "inputFormat": "In the first line, two integers $n$, $q$ are given $(1\\le n, q\\le 5 \\cdot 10^5)$ --- the length of the array $a$ and the number of queries, respectively.\n\nIn the second line, $n$ integers $a_1, a_2, \\ldots, a_n$ $(a_i \\in \\{-1, 1\\})$ are given --- the elements of the array $a$.\n\nIn the next $q$ lines, the description of the queries is given. The first of the numbers $type_i$ $(1 \\le type_i \\le 2)$ denotes the type of the query. Queries of the first type are given in the format $\\texttt{1 p}$ $(1 \\le p \\le n)$, and queries of the second type are given in the format $\\texttt{2 l r}$ $(1 \\le l \\le r \\le n)$.", "outputFormat": "For each query of the second type, output one integer in a separate line --- the *beauty* of the corresponding array.", "hint": "$^1$ An array $c$ is called a subsequence of an array $b$ if it is possible to remove a certain number of elements from the array $b$ (possibly zero) so that the array $c$ is formed. The empty array is a subsequence of any array.\n\n### Scoring\n\n- ($2$ points): $a_i = (-1)^{i+1}$ for $1 \\le i \\le n$, and there are no type one queries;\n- ($7$ points): $n \\le 16$, and there are no type one queries;\n- ($21$ points): $n, q \\le 100$;\n- ($20$ points): $n, q \\le 3000$;\n- ($27$ points): $n, q \\leq 2 \\cdot 10^5$, and there are no type one queries;\n- ($14$ points): $n, q \\leq 2 \\cdot 10^5$;\n- ($9$ points): no additional restrictions.", "locale": "en"}, "zh-CN": {"title": "[UOI 2025] Simple Subsequence", "background": "", "description": "我们称一个整数数组 $d_1, d_2, \\ldots, d_m$ 为*好的*，如果其长度为 $0$，或者对于任意 $1 \\le i \\le m$，$\\sum\\limits_{j=1}^{i} d_j$ 和 $\\sum\\limits_{j=i}^{m} d_j$ 都非负。其中 $\\sum\\limits_{j=l}^{r} d_j$ 表示 $d_l + d_{l+1} + \\ldots + d_r$。\n\n我们定义数组的 **美丽值** 为其最长 **好的** 子序列$^1$的长度。\n\n给定一个长度为 $n$ 的数组 $a$，其元素**仅由 $-1$ 和 $1$ 组成**。\n\n你需要处理 $q$ 个查询，查询分为两种类型：\n\n- 将元素 $a_p$ 替换为 $-a_p$，其中 $p$ 为查询参数；\n- 查询由元素 $[a_{l}, a_{l+1}, \\ldots, a_r]$ 组成的数组的 **美丽值**，其中 $(l, r)$ 为查询参数。", "inputFormat": "第一行包含两个整数 $n$, $q$ $(1 \\le n, q \\le 5 \\cdot 10^5)$ —— 数组 $a$ 的长度和查询的数量。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\ldots, a_n$ $(a_i \\in \\{-1, 1\\})$ —— 数组 $a$ 的元素。\n\n接下来的 $q$ 行描述查询。第一个数字 $type_i$ $(1 \\le type_i \\le 2)$ 表示查询类型。类型为 $1$ 的查询格式为 $\\texttt{1 p}$ $(1 \\le p \\le n)$，类型为 $2$ 的查询格式为 $\\texttt{2 l r}$ $(1 \\le l \\le r \\le n)$。\n", "outputFormat": "对于每个类型为 $2$ 的查询，输出一行一个整数 —— 对应数组的*美丽值*。\n", "hint": "$^1$ 数组 $c$ 称为数组 $b$ 的子序列，如果可以通过从 $b$ 中删除若干元素（可能为零）得到 $c$。空数组是任何数组的子序列。\n\n### 评分标准\n\n- （$2$ 分）：对于所有 $1 \\le i \\le n$，$a_i = (-1)^{i+1}$，且没有类型 $1$ 的查询；\n- （$7$ 分）：$n \\le 16$，且没有类型 $1$ 的查询；\n- （$21$ 分）：$n, q \\le 100$；\n- （$20$ 分）：$n, q \\le 3000$；\n- （$27$ 分）：$n, q \\leq 2 \\cdot 10^5$，且没有类型 $1$ 的查询；\n- （$14$ 分）：$n, q \\leq 2 \\cdot 10^5$；\n- （$9$ 分）：无额外限制。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12548", "type": "P", "difficulty": 5, "samples": [["1\n3 1\n1 0", "3"], ["3\n18 0\n3 0\n1 0\n10 0\n8 0\n14 0", "4"], ["4\n3 0\n0 1\n5 0\n2 1\n6 0\n3 0\n5 1\n2 1", "2"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "贪心", "二分", "2025", "UOI（乌克兰）"], "title": "[UOI 2025] Manhattan Pairing", "background": null, "description": "For a pair of points on the Cartesian plane $(x_1, y_1)$ and $(x_2, y_2)$, we define the *Manhattan distance* between them as $|x_1-x_2|+|y_1-y_2|$. For example, for the pair of points $(4, 1)$ and $(2, 7)$, the *Manhattan distance* between them is $|4-2|+|1-7| = 2+6 = 8$.\n\nYou are given $2 \\cdot n$ points on the Cartesian plane, whose coordinates are integers. **All $y$-coordinates of the given points are either $0$ or $1$.**\n\nSplit the given points into $n$ pairs such that each of these points belongs to exactly one pair, and the maximum *Manhattan distance* between the points of one pair is minimized.", "inputFormat": "The first line contains a single integer $n$ $(1 \\le n \\le 10^5)$.\n\nIn the following $2 \\cdot n$ lines, each line contains two integers $x_i$ and $y_i$ $(0 \\le x_i \\le 10^9, 0 \\le y_i \\le 1)$ --- the coordinates of the corresponding point.", "outputFormat": "Output a single integer --- the maximum *Manhattan distance* between the points of one pair in the optimal partition.", "hint": "In the second example, the pairing $[(18, 0), (14, 0)]$, $[(3, 0), (1, 0)]$, and $[(8, 0), (10, 0)]$ is the only optimal partition. The *Manhattan distances* between the points of one pair in this partition are $4$, $2$, and $2$, respectively.\n\nIn the third example, the pairing $[(0, 1), (2, 1)]$, $[(2, 1), (3, 0)]$, $[(3, 0), (5, 0)]$, and $[(5, 1), (6, 0)]$ is an optimal partition. All *Manhattan distances* between the points of one pair in this partition are equal to $2$.\n\nIllustration for the third example\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/g9n17g5v.png)\n\n### Scoring\n\n- ($2$ points): $n = 1$;\n- ($3$ points): $x_i = 0$ for $1 \\le i \\le 2\\cdot n$;\n- ($4$ points): $n \\le 4$;\n- ($11$ points): $n \\le 10$;\n- ($14$ points): $y_i = 0$ for $1 \\le i \\le 2\\cdot n$;\n- ($10$ points): $x_i \\neq x_j$ for $1 \\le i < j \\le 2\\cdot n$;\n- ($29$ points): $n \\le 1000$;\n- ($27$ points): no additional restrictions.", "locale": "en", "translations": {"en": {"title": "[UOI 2025] Manhattan Pairing", "background": null, "description": "For a pair of points on the Cartesian plane $(x_1, y_1)$ and $(x_2, y_2)$, we define the *Manhattan distance* between them as $|x_1-x_2|+|y_1-y_2|$. For example, for the pair of points $(4, 1)$ and $(2, 7)$, the *Manhattan distance* between them is $|4-2|+|1-7| = 2+6 = 8$.\n\nYou are given $2 \\cdot n$ points on the Cartesian plane, whose coordinates are integers. **All $y$-coordinates of the given points are either $0$ or $1$.**\n\nSplit the given points into $n$ pairs such that each of these points belongs to exactly one pair, and the maximum *Manhattan distance* between the points of one pair is minimized.", "inputFormat": "The first line contains a single integer $n$ $(1 \\le n \\le 10^5)$.\n\nIn the following $2 \\cdot n$ lines, each line contains two integers $x_i$ and $y_i$ $(0 \\le x_i \\le 10^9, 0 \\le y_i \\le 1)$ --- the coordinates of the corresponding point.", "outputFormat": "Output a single integer --- the maximum *Manhattan distance* between the points of one pair in the optimal partition.", "hint": "In the second example, the pairing $[(18, 0), (14, 0)]$, $[(3, 0), (1, 0)]$, and $[(8, 0), (10, 0)]$ is the only optimal partition. The *Manhattan distances* between the points of one pair in this partition are $4$, $2$, and $2$, respectively.\n\nIn the third example, the pairing $[(0, 1), (2, 1)]$, $[(2, 1), (3, 0)]$, $[(3, 0), (5, 0)]$, and $[(5, 1), (6, 0)]$ is an optimal partition. All *Manhattan distances* between the points of one pair in this partition are equal to $2$.\n\nIllustration for the third example\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/g9n17g5v.png)\n\n### Scoring\n\n- ($2$ points): $n = 1$;\n- ($3$ points): $x_i = 0$ for $1 \\le i \\le 2\\cdot n$;\n- ($4$ points): $n \\le 4$;\n- ($11$ points): $n \\le 10$;\n- ($14$ points): $y_i = 0$ for $1 \\le i \\le 2\\cdot n$;\n- ($10$ points): $x_i \\neq x_j$ for $1 \\le i < j \\le 2\\cdot n$;\n- ($29$ points): $n \\le 1000$;\n- ($27$ points): no additional restrictions.", "locale": "en"}, "zh-CN": {"title": "[UOI 2025] Manhattan Pairing", "background": "", "description": "对于笛卡尔平面上的两个点 $(x_1, y_1)$ 和 $(x_2, y_2)$，我们定义它们之间的*曼哈顿距离*为 $|x_1-x_2|+|y_1-y_2|$。例如，点 $(4, 1)$ 和 $(2, 7)$ 之间的曼哈顿距离为 $|4-2|+|1-7| = 2+6 = 8$。\n\n给定笛卡尔平面上的 $2 \\cdot n$ 个点，其坐标均为整数。**所有给定点的 $y$ 坐标要么是 $0$，要么是 $1$。**\n\n将这些点分成 $n$ 对，使得每个点恰好属于一对，并且所有配对中两点之间的最大曼哈顿距离最小化。", "inputFormat": "第一行包含一个整数 $n$ $(1 \\le n \\le 10^5)$。\n\n接下来的 $2 \\cdot n$ 行，每行包含两个整数 $x_i$ 和 $y_i$ $(0 \\le x_i \\le 10^9, 0 \\le y_i \\le 1)$ —— 对应点的坐标。\n", "outputFormat": "输出一个整数 —— 最优配对方案中所有配对两点之间的最大曼哈顿距离。\n", "hint": "在第二个样例中，配对 $[(18, 0), (14, 0)]$、$[(3, 0), (1, 0)]$ 和 $[(8, 0), (10, 0)]$ 是唯一的最优划分方案。该方案中各对点之间的曼哈顿距离分别为 $4$、$2$ 和 $2$。\n\n在第三个样例中，配对 $[(0, 1), (2, 1)]$、$[(2, 1), (3, 0)]$、$[(3, 0), (5, 0)]$ 和 $[(5, 1), (6, 0)]$ 是一个最优划分方案。该方案中所有配对两点之间的曼哈顿距离均为 $2$。\n\n第三个样例的图示\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/g9n17g5v.png)\n\n### 评分标准\n\n- （$2$ 分）：$n = 1$；\n- （$3$ 分）：对于所有 $1 \\le i \\le 2\\cdot n$，$x_i = 0$；\n- （$4$ 分）：$n \\le 4$；\n- （$11$ 分）：$n \\le 10$；\n- （$14$ 分）：对于所有 $1 \\le i \\le 2\\cdot n$，$y_i = 0$；\n- （$10$ 分）：对于所有 $1 \\le i < j \\le 2\\cdot n$，$x_i \\neq x_j$；\n- （$29$ 分）：$n \\le 1000$；\n- （$27$ 分）：无额外限制。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12549", "type": "P", "difficulty": 3, "samples": [["4 6", "1 1 2 2 2 1\n0 2 2 0 2 1\n1 2 0 2 2 0\n1 2 2 2 1 1"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2025", "Special Judge", "构造", "UOI（乌克兰）"], "title": "[UOI 2025] Gift for Anton", "background": "", "description": "Anton wants to receive as a gift a rectangular table of size $n\\times m$ filled with the numbers 0, 1, 2, 3, or 4.\n\nAnton will be happy if there is no other \"0\" next to each \"0\", exactly one other \"1\" next to each \"1\", exactly two other \"2\"s next to each \"2\", exactly three other \"3\"s next to each \"3\", and exactly four other \"4\"s next to each \"4\" (i.e., all neighbors of \"4\" must also be \"4\").\n\nOne cell is considered to be next to another if they share a side.\n\nYou need to come up with a table that can be gifted to Anton so that he will be happy.\n\nBelow is an example of a table that will make Anton happy with $n=4, m=6$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gldglw1a.png)", "inputFormat": "A single line contains two numbers $n, m$ ($1 \\leq n, m \\leq 200$) --- the dimensions of the table.\n\nIt can be shown that a solution always exists.", "outputFormat": "Output a table with $n$ rows and $m$ columns --- a gift for Anton.", "hint": "- ($10$ points): $n = 1$;\n- ($10$ points): $n = 2$;\n- ($10$ points): $n = 3$;\n- ($10$ points): $n = m = 4$;\n- ($10$ points): $n = m = 30$;\n- ($5$ points): $n = 30, m = 31$;\n- ($5$ points): $n = 30, m = 32$;\n- ($10$ points): $n = m = 31$;\n- ($5$ points): $n = 31, m = 32$;\n- ($10$ points): $n = m = 32$;\n- ($15$ points): no additional restrictions.", "locale": "en", "translations": {"en": {"title": "[UOI 2025] Gift for Anton", "background": "", "description": "Anton wants to receive as a gift a rectangular table of size $n\\times m$ filled with the numbers 0, 1, 2, 3, or 4.\n\nAnton will be happy if there is no other \"0\" next to each \"0\", exactly one other \"1\" next to each \"1\", exactly two other \"2\"s next to each \"2\", exactly three other \"3\"s next to each \"3\", and exactly four other \"4\"s next to each \"4\" (i.e., all neighbors of \"4\" must also be \"4\").\n\nOne cell is considered to be next to another if they share a side.\n\nYou need to come up with a table that can be gifted to Anton so that he will be happy.\n\nBelow is an example of a table that will make Anton happy with $n=4, m=6$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gldglw1a.png)", "inputFormat": "A single line contains two numbers $n, m$ ($1 \\leq n, m \\leq 200$) --- the dimensions of the table.\n\nIt can be shown that a solution always exists.", "outputFormat": "Output a table with $n$ rows and $m$ columns --- a gift for Anton.", "hint": "- ($10$ points): $n = 1$;\n- ($10$ points): $n = 2$;\n- ($10$ points): $n = 3$;\n- ($10$ points): $n = m = 4$;\n- ($10$ points): $n = m = 30$;\n- ($5$ points): $n = 30, m = 31$;\n- ($5$ points): $n = 30, m = 32$;\n- ($10$ points): $n = m = 31$;\n- ($5$ points): $n = 31, m = 32$;\n- ($10$ points): $n = m = 32$;\n- ($15$ points): no additional restrictions.", "locale": "en"}, "zh-CN": {"title": "[UOI 2025] Gift for Anton", "background": "", "description": "Anton 希望收到一份礼物：一个大小为 $n \\times m$ 的矩形表格，表格中填有数字 0、1、2、3 或 4。\n\n如果满足以下条件，Anton 就会感到开心：\n- 每个 \"0\" 的旁边没有其他 \"0\"；\n- 每个 \"1\" 的旁边恰好有一个其他 \"1\"；\n- 每个 \"2\" 的旁边恰好有两个其他 \"2\"；\n- 每个 \"3\" 的旁边恰好有三个其他 \"3\"；\n- 每个 \"4\" 的旁边恰好有四个其他 \"4\"（即 \"4\" 的所有邻居也必须是 \"4\"）。\n\n两个单元格如果共享一条边，则认为它们是相邻的。\n\n你需要设计一个能让 Anton 开心的表格作为礼物。\n\n下图是一个让 Anton 开心的表格示例（$n=4$，$m=6$）：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gldglw1a.png)", "inputFormat": "一行包含两个整数 $n, m$ ($1 \\leq n, m \\leq 200$) —— 表格的行数和列数。\n\n可以证明，解总是存在的。", "outputFormat": "输出一个 $n$ 行 $m$ 列的表格 —— 送给 Anton 的礼物。", "hint": "### 评分标准\n\n- （$10$ 分）：$n = 1$；\n- （$10$ 分）：$n = 2$；\n- （$10$ 分）：$n = 3$；\n- （$10$ 分）：$n = m = 4$；\n- （$10$ 分）：$n = m = 30$；\n- （$5$ 分）：$n = 30$，$m = 31$；\n- （$5$ 分）：$n = 30$，$m = 32$；\n- （$10$ 分）：$n = m = 31$；\n- （$5$ 分）：$n = 31$，$m = 32$；\n- （$10$ 分）：$n = m = 32$；\n- （$15$ 分）：无额外限制。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12550", "type": "P", "difficulty": 6, "samples": [["2\n5\nABCCA\n19\nCCAABBBABBAAABBCCAA", "3\n28"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2025", "UOI（乌克兰）"], "title": "[UOI 2025] Reversal ABC", "background": "", "description": "Given a string $s$ consisting of characters $\\texttt{A}$, $\\texttt{B}$, and $\\texttt{C}$.\n\nIn one operation, you are allowed to choose two **adjacent** elements of the string $s_is_{i+1}$ that are in the following order: $\\texttt{AB}$, $\\texttt{BC}$, or $\\texttt{CA}$, and swap them.\n\nFind the maximum number of consecutive operations that can be performed on the string $s$.\n\nIn this problem, each test contains several sets of input data. You need to solve the problem independently for each such set.", "inputFormat": "The first line contains one integer $T$ $(1\\le T\\le 10^5)$ --- the number of sets of input data. The description of the input data sets follows.\n\nIn the first line of each input data set, there is one integer $n$ $(1 \\le n \\le 10^6)$ --- the length of the string $s$.\n\nIn the second line of each input data set, there is a string $s$ of length $n$, consisting of characters $\\texttt{A}$, $\\texttt{B}$, and $\\texttt{C}$.\n\nIt is guaranteed that the sum of $n$ across all input data sets of a single test does not exceed $10^6$.", "outputFormat": "For each set of input data, output on a separate line one integer --- the maximum number of consecutive operations that can be performed on the string $s$.", "hint": "In the first set of input data from the first example, no more than $3$ consecutive operations can be performed on the string $\\texttt{ABCCA}$. One example of how $3$ consecutive operations can be performed is $[\\texttt{ABCCA} \\rightarrow \\texttt{BACCA}, \\texttt{BACCA} \\rightarrow \\texttt{BACAC}, \\texttt{BACAC} \\rightarrow \\texttt{BAACC}]$.\n\n### Scoring\n\nLet $K$ be the sum of $n$ over all input data sets of one test.\n\n- ($2$ points): the answer is equal to $0$ or $1$;\n- ($3$ points): $n \\le 3$;\n- ($5$ points): $s_i \\ne \\texttt{C}$ for $1 \\le i \\le n$;\n- ($5$ points): $s$ has the form $\\texttt{AA}\\ldots \\texttt{AABB}\\ldots \\texttt{BBCC}\\ldots \\texttt{CC}$ (that is, $x \\cdot \\texttt{A} + y \\cdot \\texttt{B} + z \\cdot \\texttt{C}$ for certain positive $x$, $y$, $z$);\n- ($9$ points): $s_is_{i+1} \\ne \\texttt{CA}$ for $1 \\le i < n$;\n- ($10$ points): $T = 1$, $n \\le 12$;\n- ($8$ points): $n \\le 12$;\n- ($28$ points): $K \\le 2000$;\n- ($30$ points): without additional constraints.", "locale": "en", "translations": {"en": {"title": "[UOI 2025] Reversal ABC", "background": "", "description": "Given a string $s$ consisting of characters $\\texttt{A}$, $\\texttt{B}$, and $\\texttt{C}$.\n\nIn one operation, you are allowed to choose two **adjacent** elements of the string $s_is_{i+1}$ that are in the following order: $\\texttt{AB}$, $\\texttt{BC}$, or $\\texttt{CA}$, and swap them.\n\nFind the maximum number of consecutive operations that can be performed on the string $s$.\n\nIn this problem, each test contains several sets of input data. You need to solve the problem independently for each such set.", "inputFormat": "The first line contains one integer $T$ $(1\\le T\\le 10^5)$ --- the number of sets of input data. The description of the input data sets follows.\n\nIn the first line of each input data set, there is one integer $n$ $(1 \\le n \\le 10^6)$ --- the length of the string $s$.\n\nIn the second line of each input data set, there is a string $s$ of length $n$, consisting of characters $\\texttt{A}$, $\\texttt{B}$, and $\\texttt{C}$.\n\nIt is guaranteed that the sum of $n$ across all input data sets of a single test does not exceed $10^6$.", "outputFormat": "For each set of input data, output on a separate line one integer --- the maximum number of consecutive operations that can be performed on the string $s$.", "hint": "In the first set of input data from the first example, no more than $3$ consecutive operations can be performed on the string $\\texttt{ABCCA}$. One example of how $3$ consecutive operations can be performed is $[\\texttt{ABCCA} \\rightarrow \\texttt{BACCA}, \\texttt{BACCA} \\rightarrow \\texttt{BACAC}, \\texttt{BACAC} \\rightarrow \\texttt{BAACC}]$.\n\n### Scoring\n\nLet $K$ be the sum of $n$ over all input data sets of one test.\n\n- ($2$ points): the answer is equal to $0$ or $1$;\n- ($3$ points): $n \\le 3$;\n- ($5$ points): $s_i \\ne \\texttt{C}$ for $1 \\le i \\le n$;\n- ($5$ points): $s$ has the form $\\texttt{AA}\\ldots \\texttt{AABB}\\ldots \\texttt{BBCC}\\ldots \\texttt{CC}$ (that is, $x \\cdot \\texttt{A} + y \\cdot \\texttt{B} + z \\cdot \\texttt{C}$ for certain positive $x$, $y$, $z$);\n- ($9$ points): $s_is_{i+1} \\ne \\texttt{CA}$ for $1 \\le i < n$;\n- ($10$ points): $T = 1$, $n \\le 12$;\n- ($8$ points): $n \\le 12$;\n- ($28$ points): $K \\le 2000$;\n- ($30$ points): without additional constraints.", "locale": "en"}, "zh-CN": {"title": "[UOI 2025] Reversal ABC", "background": "", "description": "给定一个由字符 $\\texttt{A}$、$\\texttt{B}$ 和 $\\texttt{C}$ 组成的字符串 $s$。\n\n每次操作中，你可以选择字符串中两个**相邻**的元素 $s_is_{i+1}$，且它们的顺序为以下之一：$\\texttt{AB}$、$\\texttt{BC}$ 或 $\\texttt{CA}$，然后交换它们的位置。\n\n求可以对字符串 $s$ 进行的最大连续操作次数。\n\n本题每个测试包含多组输入数据，你需要分别独立处理每组数据。", "inputFormat": "第一行包含一个整数 $T$ $(1\\le T\\le 10^5)$ —— 输入数据的组数。接下来是各组数据的描述。\n\n每组数据的第一行包含一个整数 $n$ $(1 \\le n \\le 10^6)$ —— 字符串 $s$ 的长度。\n\n每组数据的第二行包含一个长度为 $n$ 的字符串 $s$，由字符 $\\texttt{A}$、$\\texttt{B}$ 和 $\\texttt{C}$ 组成。\n\n保证单个测试中所有数据的 $n$ 之和不超过 $10^6$。", "outputFormat": "对于每组数据，输出一行一个整数 —— 可以对字符串 $s$ 进行的最大连续操作次数。\n", "hint": "在第一个样例的第一组数据中，字符串 $\\texttt{ABCCA}$ 最多可以进行 $3$ 次连续操作。其中一种可能的操作序列是：$[\\texttt{ABCCA} \\rightarrow \\texttt{BACCA}, \\texttt{BACCA} \\rightarrow \\texttt{BACAC}, \\texttt{BACAC} \\rightarrow \\texttt{BAACC}]$。\n\n### 评分标准\n\n设 $K$ 为单个测试中所有数据的 $n$ 之和。\n\n- （$2$ 分）：答案为 $0$ 或 $1$；\n- （$3$ 分）：$n \\le 3$；\n- （$5$ 分）：对于所有 $1 \\le i \\le n$，$s_i \\ne \\texttt{C}$；\n- （$5$ 分）：$s$ 的形式为 $\\texttt{AA}\\ldots \\texttt{AABB}\\ldots \\texttt{BBCC}\\ldots \\texttt{CC}$（即 $x \\cdot \\texttt{A} + y \\cdot \\texttt{B} + z \\cdot \\texttt{C}$，其中 $x$、$y$、$z$ 为正整数）；\n- （$9$ 分）：对于所有 $1 \\le i < n$，$s_is_{i+1} \\ne \\texttt{CA}$；\n- （$10$ 分）：$T = 1$，$n \\le 12$；\n- （$8$ 分）：$n \\le 12$；\n- （$28$ 分）：$K \\le 2000$；\n- （$30$ 分）：无额外限制。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
