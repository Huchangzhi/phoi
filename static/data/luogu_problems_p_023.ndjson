{"pid": "P1461", "type": "P", "difficulty": 3, "samples": [["16 7 3", "0 7 25 30 42 45 51 52 75 76\n82 85 97 102 120 127"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "USACO", "进制", "位运算"], "title": "[USACO2.1] 海明码 Hamming Codes", "background": null, "description": "给出 $n,b,d$，要求找出 $n$ 个由 $0,1$ 组成的编码，每个编码有 $b$ 位，使得两两编码之间至少有 $d$ 个单位的 **Hamming 距离**。 \n\n**Hamming 距离**是指两个二进制编码中的不同二进制位的数目。例如，编码 `0101 0101 0100` 和 `0010 0011 0100` 之间的 **Hamming 距离**是 $5$：\n\n```plain\n0101 0101 0100\n0010 0011 0100\n ^^^  ^^       \n```", "inputFormat": "一行三个整数 $n,b,d$。", "outputFormat": "输出字典序最小的解（$n$ 个编码同样也要升序输出），每输出 $10$ 个编码换一行。\n\n你需要先将每个编码当成二进制数，再将其转成十进制数输出。", "hint": "对于 $100\\%$ 的数据，$1\\le n \\le 64$，$1\\le b \\le 8$，$1\\le d \\le 7$。\n\n**请注意：题目中只要求 Hamming 距离至少为 $\\bm d$，因此也可以大于 $\\bm d$。**\n\nUSACO 2.1\n\n翻译来自NOCOW", "locale": "zh-CN", "translations": {"en": {"title": "[USACO2.1] Hamming Codes", "background": "", "description": "Given $n,b,d$, find $n$ binary codewords consisting of 0 and 1, each with $b$ bits, such that the Hamming distance between every pair of codewords is at least $d$.\n\nThe Hamming distance is the number of differing bit positions between two binary codewords. For example, the Hamming distance between `0101 0101 0100` and `0010 0011 0100` is $5$:\n\n```plain\n0101 0101 0100\n0010 0011 0100\n ^^^  ^^       \n```", "inputFormat": "One line containing three integers $n,b,d$.", "outputFormat": "Output the lexicographically smallest solution (the $n$ codewords must also be printed in ascending order). Print a newline after every $10$ codewords.\n\nYou should first treat each codeword as a binary number, then convert it to a decimal number for output.", "hint": "Constraints: For $100\\%$ of the testdata, $1\\le n \\le 64$, $1\\le b \\le 8$, $1\\le d \\le 7$.\n\nPlease note: the problem only requires the Hamming distance to be at least $\\bm d$, so it may also be greater than $\\bm d$.\n\nUSACO 2.1\n\nTranslation from NOCOW\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO2.1] 海明码 Hamming Codes", "background": null, "description": "给出 $n,b,d$，要求找出 $n$ 个由 $0,1$ 组成的编码，每个编码有 $b$ 位，使得两两编码之间至少有 $d$ 个单位的 **Hamming 距离**。 \n\n**Hamming 距离**是指两个二进制编码中的不同二进制位的数目。例如，编码 `0101 0101 0100` 和 `0010 0011 0100` 之间的 **Hamming 距离**是 $5$：\n\n```plain\n0101 0101 0100\n0010 0011 0100\n ^^^  ^^       \n```", "inputFormat": "一行三个整数 $n,b,d$。", "outputFormat": "输出字典序最小的解（$n$ 个编码同样也要升序输出），每输出 $10$ 个编码换一行。\n\n你需要先将每个编码当成二进制数，再将其转成十进制数输出。", "hint": "对于 $100\\%$ 的数据，$1\\le n \\le 64$，$1\\le b \\le 8$，$1\\le d \\le 7$。\n\n**请注意：题目中只要求 Hamming 距离至少为 $\\bm d$，因此也可以大于 $\\bm d$。**\n\nUSACO 2.1\n\n翻译来自NOCOW", "locale": "zh-CN"}}}
{"pid": "P1462", "type": "P", "difficulty": 4, "samples": [["4 4 8\n8\n5\n6\n10\n2 1 2\n2 4 1\n1 3 4\n3 4 3\n", "10\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "二分", "洛谷原创", "最短路"], "title": "通往奥格瑞玛的道路", "background": "在艾泽拉斯大陆上有一位名叫歪嘴哦的神奇术士，他是部落的中坚力量。\n\n有一天他醒来后发现自己居然到了联盟的主城暴风城。\n\n在被众多联盟的士兵攻击后，他决定逃回自己的家乡奥格瑞玛。", "description": "在艾泽拉斯，有 $n$ 个城市。编号为 $1,2,3,\\ldots,n$。\n\n城市之间有 $m$ 条双向的公路，连接着两个城市，从某个城市到另一个城市，会遭到联盟的攻击，进而损失一定的血量。\n\n每次经过一个城市，都会被收取一定的过路费（包括起点和终点）。路上并没有收费站。\n\n假设 $1$ 为暴风城，$n$ 为奥格瑞玛，而他的血量最多为 $b$，出发时他的血量是满的。如果他的血量降低至负数，则他就无法到达奥格瑞玛。\n\n歪嘴哦不希望花很多钱，他想知道，在所有可以到达奥格瑞玛的道路中，对于每条道路所经过的城市单次收费的最大值，其最小值为多少。", "inputFormat": "第一行 $3$ 个正整数，$n,m,b$。分别表示有 $n$ 个城市，$m$ 条公路，歪嘴哦的血量为 $b$。\n\n接下来有 $n$ 行，每行 $1$ 个非负整数，$f_i$。表示经过城市 $i$，需要交费 $f_i$ 元。\n\n再接下来有 $m$ 行，每行 $3$ 个正整数，$a_i,b_i,c_i$（$1\\leq a_i,b_i\\leq n$）。表示城市 $a_i$ 和城市 $b_i$ 之间有一条公路，如果从城市 $a_i$ 到城市 $b_i$，或者从城市 $b_i$ 到城市 $a_i$，会损失 $c_i$ 的血量。", "outputFormat": "仅一个整数，表示歪嘴哦经过城市单次交费最大值的最小值。\n\n如果他无法到达奥格瑞玛，输出 `AFK`。", "hint": "对于 $60\\%$ 的数据，满足 $n\\leq 200$，$m\\leq 10^4$，$b\\leq 200$；\n\n对于 $100\\%$ 的数据，满足 $1\\leq n\\leq 10^4$，$1\\leq m\\leq 5\\times 10^4$，$1\\leq b\\leq 10^9$；\n\n对于 $100\\%$ 的数据，满足 $1\\leq c_i\\leq 10^9$，$0\\leq f_i\\leq 10^9$，可能有两条边连接着相同的城市。", "locale": "zh-CN", "translations": {"en": {"title": "The Road to Orgrimmar", "background": "On the continent of Azeroth, there is a remarkable warlock named Waizui O, a core member of the Horde. One day he wakes up and finds himself in the Alliance capital, Stormwind City. After being attacked by many Alliance soldiers, he decides to flee back to his home, Orgrimmar.", "description": "There are $n$ cities in Azeroth, numbered $1, 2, 3, \\ldots, n$.\n\nThere are $m$ undirected roads between cities. Traveling from one city to another will trigger attacks by the Alliance, causing a certain amount of health loss.\n\nEach time he passes through a city, he must pay a toll (including the start and the end). There are no toll booths along the roads.\n\nAssume $1$ is Stormwind City, $n$ is Orgrimmar, and his maximum health is $b$. At the start, his health is full. If his health drops below zero, he cannot reach Orgrimmar.\n\nWaizui O does not want to spend too much money. Among all routes that can reach Orgrimmar, consider the maximum single-city toll along the route; find the minimal possible value of this maximum.", "inputFormat": "The first line contains 3 positive integers, $n, m, b$, representing the number of cities, the number of roads, and Waizui O’s health $b$.\n\nThen follow $n$ lines, each containing 1 non-negative integer, $f_i$, meaning that passing city $i$ requires a toll of $f_i$.\n\nThen follow $m$ lines, each containing 3 positive integers, $a_i, b_i, c_i$ ($1\\leq a_i,b_i\\leq n$). This means there is a two-way road between cities $a_i$ and $b_i$. If you travel from city $a_i$ to city $b_i$, or from city $b_i$ to city $a_i$, you will lose $c_i$ health.", "outputFormat": "Output a single integer: the minimal possible value of the maximum single-city toll along the route.\n\nIf he cannot reach Orgrimmar, output `AFK`.", "hint": "Constraints:\n- For $60\\%$ of the testdata, $n\\leq 200$, $m\\leq 10^4$, $b\\leq 200$.\n- For $100\\%$ of the testdata, $1\\leq n\\leq 10^4$, $1\\leq m\\leq 5\\times 10^4$, $1\\leq b\\leq 10^9$.\n- For $100\\%$ of the testdata, $1\\leq c_i\\leq 10^9$, $0\\leq f_i\\leq 10^9$. There may be two edges connecting the same pair of cities.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "通往奥格瑞玛的道路", "background": "在艾泽拉斯大陆上有一位名叫歪嘴哦的神奇术士，他是部落的中坚力量。\n\n有一天他醒来后发现自己居然到了联盟的主城暴风城。\n\n在被众多联盟的士兵攻击后，他决定逃回自己的家乡奥格瑞玛。", "description": "在艾泽拉斯，有 $n$ 个城市。编号为 $1,2,3,\\ldots,n$。\n\n城市之间有 $m$ 条双向的公路，连接着两个城市，从某个城市到另一个城市，会遭到联盟的攻击，进而损失一定的血量。\n\n每次经过一个城市，都会被收取一定的过路费（包括起点和终点）。路上并没有收费站。\n\n假设 $1$ 为暴风城，$n$ 为奥格瑞玛，而他的血量最多为 $b$，出发时他的血量是满的。如果他的血量降低至负数，则他就无法到达奥格瑞玛。\n\n歪嘴哦不希望花很多钱，他想知道，在所有可以到达奥格瑞玛的道路中，对于每条道路所经过的城市单次收费的最大值，其最小值为多少。", "inputFormat": "第一行 $3$ 个正整数，$n,m,b$。分别表示有 $n$ 个城市，$m$ 条公路，歪嘴哦的血量为 $b$。\n\n接下来有 $n$ 行，每行 $1$ 个非负整数，$f_i$。表示经过城市 $i$，需要交费 $f_i$ 元。\n\n再接下来有 $m$ 行，每行 $3$ 个正整数，$a_i,b_i,c_i$（$1\\leq a_i,b_i\\leq n$）。表示城市 $a_i$ 和城市 $b_i$ 之间有一条公路，如果从城市 $a_i$ 到城市 $b_i$，或者从城市 $b_i$ 到城市 $a_i$，会损失 $c_i$ 的血量。", "outputFormat": "仅一个整数，表示歪嘴哦经过城市单次交费最大值的最小值。\n\n如果他无法到达奥格瑞玛，输出 `AFK`。", "hint": "对于 $60\\%$ 的数据，满足 $n\\leq 200$，$m\\leq 10^4$，$b\\leq 200$；\n\n对于 $100\\%$ 的数据，满足 $1\\leq n\\leq 10^4$，$1\\leq m\\leq 5\\times 10^4$，$1\\leq b\\leq 10^9$；\n\n对于 $100\\%$ 的数据，满足 $1\\leq c_i\\leq 10^9$，$0\\leq f_i\\leq 10^9$，可能有两条边连接着相同的城市。", "locale": "zh-CN"}}}
{"pid": "P1463", "type": "P", "difficulty": 5, "samples": [["1000", "840"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "数学", "2001", "2006", "2007", "河南", "各省省选", "POI（波兰）", "浙江", "素数判断,质数,筛法"], "title": "[POI 2001 R1 / ZJOI2006 / HAOI2007] 反素数", "background": null, "description": "对于任何正整数 $x$，其约数的个数记作 $g(x)$。例如 $g(1)=1$，$g(6)=4$。\n\n如果某个正整数 $x$ 满足：$\\forall 0 \\lt i \\lt x$，都有 $g(x) \\gt g(i)$，则称 $x$ 为**反素数**。例如，$1,2,4,6,12,24$ 等都是反素数。\n\n现在给定一个正整数 $N$，你能求出不超过 $N$ 的最大的反素数么？", "inputFormat": "仅一行一个正整数 $N$。", "outputFormat": "仅一行一个正整数，代表不超过 $N$ 的最大的反素数。", "hint": "对于所有数据，有 $1 \\leq N \\leq 2 \\times 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2001 R1 / HAOI2007] Anti-Prime Number", "background": "", "description": "For any positive integer $x$, let $g(x)$ be the number of its divisors. For example, $g(1)=1$, $g(6)=4$.\n\nIf a positive integer $x$ satisfies: $\\forall 0 \\lt i \\lt x$, we have $g(x) \\gt g(i)$, then $x$ is called an anti-prime number. For example, $1,2,4,6,12,24$ are all anti-prime numbers.\n\nNow given a positive integer $N$, can you find the largest anti-prime number not exceeding $N$?", "inputFormat": "A single line with a positive integer $N$.", "outputFormat": "A single line with a positive integer, representing the largest anti-prime number not exceeding $N$.", "hint": "For all testdata, $1 \\leq N \\leq 2 \\times 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2001 R1 / ZJOI2006 / HAOI2007] 反素数", "background": null, "description": "对于任何正整数 $x$，其约数的个数记作 $g(x)$。例如 $g(1)=1$，$g(6)=4$。\n\n如果某个正整数 $x$ 满足：$\\forall 0 \\lt i \\lt x$，都有 $g(x) \\gt g(i)$，则称 $x$ 为**反素数**。例如，$1,2,4,6,12,24$ 等都是反素数。\n\n现在给定一个正整数 $N$，你能求出不超过 $N$ 的最大的反素数么？", "inputFormat": "仅一行一个正整数 $N$。", "outputFormat": "仅一行一个正整数，代表不超过 $N$ 的最大的反素数。", "hint": "对于所有数据，有 $1 \\leq N \\leq 2 \\times 10^9$。", "locale": "zh-CN"}}}
{"pid": "P1464", "type": "P", "difficulty": 2, "samples": [["1 1 1\n2 2 2\n-1 -1 -1", "w(1, 1, 1) = 2\nw(2, 2, 2) = 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "递归", "记忆化搜索"], "title": "Function", "background": "", "description": "对于一个递归函数 $w(a,b,c)$\n\n\n- 如果 $a \\le 0$ 或 $b \\le 0$ 或 $c \\le 0$ 就返回值 $1$。\n- 如果 $a>20$ 或 $b>20$ 或 $c>20$ 就返回 $w(20,20,20)$\n- 如果 $a<b$ 并且 $b<c$ 就返回 $w(a,b,c-1)+w(a,b-1,c-1)-w(a,b-1,c)$。\n- 其它的情况就返回 $w(a-1,b,c)+w(a-1,b-1,c)+w(a-1,b,c-1)-w(a-1,b-1,c-1)$\n\n\n这是个简单的递归函数，但实现起来可能会有些问题。当 $a,b,c$ 均为 $15$ 时，调用的次数将非常的多。你要想个办法才行。\n\n注意：例如 $w(30,-1,0)$ 又满足条件 $1$ 又满足条件 $2$，请按照最上面的条件来算，答案为 $1$。", "inputFormat": "会有若干行。\n\n并以 $-1,-1,-1$ 结束。", "outputFormat": "输出若干行，每一行格式：\n\n`w(a, b, c) = ans`\n\n注意空格。\n", "hint": "### 数据规模与约定\n\n保证输入的数在 $[-9223372036854775808,9223372036854775807]$ 之间，并且是整数。\n\n保证不包括 $-1, -1, -1$ 的输入行数 $T$ 满足 $1 \\leq T \\leq 10 ^ 5$。", "locale": "zh-CN", "translations": {"en": {"title": "Function", "background": "", "description": "For a recursive function $w(a,b,c)$:\n\n- If $a \\le 0$ or $b \\le 0$ or $c \\le 0$, return $1$.\n- If $a>20$ or $b>20$ or $c>20$, return $w(20,20,20)$.\n- If $a<b$ and $b<c$, return $w(a,b,c-1)+w(a,b-1,c-1)-w(a,b-1,c)$.\n- Otherwise, return $w(a-1,b,c)+w(a-1,b-1,c)+w(a-1,b,c-1)-w(a-1,b-1,c-1)$.\n\nThis is a simple recursive function, but implementing it naively may cause issues. When $a, b, c$ are all $15$, the number of calls becomes very large. You need to find a way to handle this efficiently.\n\nNote: For example, $w(30,-1,0)$ satisfies both condition 1 and condition 2. Evaluate according to the earliest condition listed above. The answer is $1$.", "inputFormat": "Multiple lines of input. Each line contains three integers $a, b, c$.\n\nThe input ends with $-1,-1,-1$.", "outputFormat": "Output multiple lines. Each line should be in the format:\n\n`w(a, b, c) = ans`\n\nMind the spaces.", "hint": "### Constraints\n\n- Each input number is an integer in $[-9223372036854775808, 9223372036854775807]$.\n- The number of input lines excluding $-1, -1, -1$, denoted $T$, satisfies $1 \\leq T \\leq 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Function", "background": "", "description": "对于一个递归函数 $w(a,b,c)$\n\n\n- 如果 $a \\le 0$ 或 $b \\le 0$ 或 $c \\le 0$ 就返回值 $1$。\n- 如果 $a>20$ 或 $b>20$ 或 $c>20$ 就返回 $w(20,20,20)$\n- 如果 $a<b$ 并且 $b<c$ 就返回 $w(a,b,c-1)+w(a,b-1,c-1)-w(a,b-1,c)$。\n- 其它的情况就返回 $w(a-1,b,c)+w(a-1,b-1,c)+w(a-1,b,c-1)-w(a-1,b-1,c-1)$\n\n\n这是个简单的递归函数，但实现起来可能会有些问题。当 $a,b,c$ 均为 $15$ 时，调用的次数将非常的多。你要想个办法才行。\n\n注意：例如 $w(30,-1,0)$ 又满足条件 $1$ 又满足条件 $2$，请按照最上面的条件来算，答案为 $1$。", "inputFormat": "会有若干行。\n\n并以 $-1,-1,-1$ 结束。", "outputFormat": "输出若干行，每一行格式：\n\n`w(a, b, c) = ans`\n\n注意空格。\n", "hint": "### 数据规模与约定\n\n保证输入的数在 $[-9223372036854775808,9223372036854775807]$ 之间，并且是整数。\n\n保证不包括 $-1, -1, -1$ 的输入行数 $T$ 满足 $1 \\leq T \\leq 10 ^ 5$。", "locale": "zh-CN"}}}
{"pid": "P1465", "type": "P", "difficulty": 3, "samples": [["5\n", "I 7\nV 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "USACO", "枚举"], "title": "[USACO2.2] 序言页码 Preface Numbering", "background": "", "description": "给定 $n$，求 $1 \\sim n$ 的 **罗马数字** 表示中，各个字符出现了多少次。\n\n比如 $n = 5$，表示为  I, II, III, IV, V。总共有 $7$ 个 I 出现，$2$ 个 V 出现。\n", "inputFormat": "一个整数 $n$。\n", "outputFormat": "每行一个字符和一个数字 $k$，表示这个字符出现了 $k$ 次。字符必须按罗马数字表中的递增顺序输出。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 3500$。\n\n翻译来自NOCOW\n\nUSACO 2.2\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO2.2] Preface Numbering", "background": "", "description": "Given $n$, count how many times each character appears in the Roman numeral representations of $1 \\sim n$.\n\nFor example, when $n = 5$, the representations are I, II, III, IV, V. There are $7$ occurrences of I and $2$ occurrences of V.", "inputFormat": "A single integer $n$.", "outputFormat": "Each line contains a character and an integer $k$, indicating that this character appears $k$ times. Characters must be printed in the increasing order of the Roman numeral table.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le n \\le 3500$.\n\nTranslated from NOCOW.\n\nUSACO 2.2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO2.2] 序言页码 Preface Numbering", "background": "", "description": "给定 $n$，求 $1 \\sim n$ 的 **罗马数字** 表示中，各个字符出现了多少次。\n\n比如 $n = 5$，表示为  I, II, III, IV, V。总共有 $7$ 个 I 出现，$2$ 个 V 出现。\n", "inputFormat": "一个整数 $n$。\n", "outputFormat": "每行一个字符和一个数字 $k$，表示这个字符出现了 $k$ 次。字符必须按罗马数字表中的递增顺序输出。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 3500$。\n\n翻译来自NOCOW\n\nUSACO 2.2\n", "locale": "zh-CN"}}}
{"pid": "P1466", "type": "P", "difficulty": 3, "samples": [["7\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "USACO", "背包 DP", "折半搜索 meet in the middle"], "title": "[USACO2.2] 集合 Subset Sums", "background": null, "description": "对于从 $1\\sim n$ 的连续整数集合，能划分成两个子集合，且保证每个集合的数字和是相等的。举个例子，如果 $n=3$，对于 $\\{1,2,3\\}$ 能划分成两个子集合，每个子集合的所有数字和是相等的：\n\n$\\{3\\}$ 和 $\\{1,2\\}$ 是唯一一种分法（交换集合位置被认为是同一种划分方案，因此不会增加划分方案总数）  \n\n如果 $n=7$，有四种方法能划分集合 $\\{1,2,3,4,5,6,7 \\}$，每一种分法的子集合各数字和是相等的：\n\n$\\{1,6,7\\}$ 和 $\\{2,3,4,5\\}$  \n$\\{2,5,7\\}$ 和 $\\{1,3,4,6\\}$  \n$\\{3,4,7\\}$ 和 $\\{1,2,5,6\\}$  \n$\\{1,2,4,7\\}$ 和 $\\{3,5,6\\}$  \n\n给出 $n$，你的程序应该输出划分方案总数。", "inputFormat": "输入文件只有一行，且只有一个整数 $n$。", "outputFormat": "输出划分方案总数。", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$1\\le n \\le 39$。\n\n翻译来自 NOCOW。\n\nUSACO 2.2", "locale": "zh-CN", "translations": {"en": {"title": "[USACO2.2] Subset Sums", "background": "", "description": "For the set of consecutive integers from $1\\sim n$, determine the number of ways to partition it into two subsets such that the sum of numbers in each subset is equal. For example, if $n = 3$, the set $\\{1, 2, 3\\}$ can be partitioned into two subsets with equal sums:\n\n$\\{3\\}$ and $\\{1, 2\\}$ is the only way (swapping the two subsets is considered the same partition, so it does not increase the total count).\n\nIf $n = 7$, there are four ways to partition the set $\\{1, 2, 3, 4, 5, 6, 7\\}$ into two subsets with equal sums:\n$\\{1, 6, 7\\}$ and $\\{2, 3, 4, 5\\}$.\n$\\{2, 5, 7\\}$ and $\\{1, 3, 4, 6\\}$.\n$\\{3, 4, 7\\}$ and $\\{1, 2, 5, 6\\}$.\n$\\{1, 2, 4, 7\\}$ and $\\{3, 5, 6\\}$.\n\nGiven $n$, your program should output the total number of such partitions.", "inputFormat": "The input contains a single line with one integer $n$.", "outputFormat": "Output the total number of valid partitions.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 39$.\n\nTranslation from NOCOW.\n\nUSACO 2.2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO2.2] 集合 Subset Sums", "background": null, "description": "对于从 $1\\sim n$ 的连续整数集合，能划分成两个子集合，且保证每个集合的数字和是相等的。举个例子，如果 $n=3$，对于 $\\{1,2,3\\}$ 能划分成两个子集合，每个子集合的所有数字和是相等的：\n\n$\\{3\\}$ 和 $\\{1,2\\}$ 是唯一一种分法（交换集合位置被认为是同一种划分方案，因此不会增加划分方案总数）  \n\n如果 $n=7$，有四种方法能划分集合 $\\{1,2,3,4,5,6,7 \\}$，每一种分法的子集合各数字和是相等的：\n\n$\\{1,6,7\\}$ 和 $\\{2,3,4,5\\}$  \n$\\{2,5,7\\}$ 和 $\\{1,3,4,6\\}$  \n$\\{3,4,7\\}$ 和 $\\{1,2,5,6\\}$  \n$\\{1,2,4,7\\}$ 和 $\\{3,5,6\\}$  \n\n给出 $n$，你的程序应该输出划分方案总数。", "inputFormat": "输入文件只有一行，且只有一个整数 $n$。", "outputFormat": "输出划分方案总数。", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$1\\le n \\le 39$。\n\n翻译来自 NOCOW。\n\nUSACO 2.2", "locale": "zh-CN"}}}
{"pid": "P1467", "type": "P", "difficulty": 2, "samples": [["81361\n", "81362\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "USACO"], "title": "[USACO2.2] 循环数 Runaround Numbers", "background": null, "description": "循环数是那些不包括 $0$ 且没有重复数字的正整数（比如 $81362$），并且还应同时具有一个有趣的性质——\n\n如果你从最左边的数字开始（在 $\\color{red}{8}\\color{black}1362$ 中是 $8$）向右数这个数字对应的次数（如果数到了最右边就回到最左边；在 $\\color{red}{8}\\color{black}1362$ 中是 $8$ 次），你会停止在另一个新的数字（在 $\\color{red}{8}\\color{black}1362$ 中是 $\\color{red}8\\color{black}\\to 1\\to 3\\to 6\\to 2\\to 8\\to 1\\to 3\\to \\color{red}6$；如果停在一个相同的数字上，这个数就不是循环数）。\n\n重复这样做，如果能在经过每个数位恰好一次后回到最左边，那么这个正整数就是循环数。\n\n仍然以 $81362$ 为例，以下模拟过程证明了 $81362$ 是循环数：\n\n$$\\color{red}8\\color{black}\\to 1\\to 3\\to 6\\to 2\\to 8\\to 1\\to 3\\to \\color{red}6$$  \n$$\\color{red}6\\color{black}\\to 2\\to 8\\to 1\\to 3\\to 6\\to \\color{red}2$$   \n$$\\color{red}2\\color{black}\\to 8\\to \\color{red}1$$  \n$$\\color{red}1\\color{black}\\to \\color{red}3$$  \n$$\\color{red}3\\color{black}\\to 6\\to 2\\to  \\color{red}8$$  \n\n**任务：**\n\n给你一个正整数 $m$，找出最小的比 $m$ 大的循环数 $m'$。\n\n数据保证 $m' \\le 2^{32}-1$。", "inputFormat": "仅仅一行, 包括 $m$。", "outputFormat": "仅仅一行，输出小的比 $m$ 大的循环数 $m'$。", "hint": "对于 $100\\%$ 的数据，$1\\le m \\le 10^9$。\n\nUSACO 2.2", "locale": "zh-CN", "translations": {"en": {"title": "[USACO2.2] Runaround Numbers", "background": "", "description": "Runaround numbers are positive integers that contain no $0$ and have no repeated digits (for example, $81362$). They must also have the following property:\n\nStarting from the leftmost digit (in $\\color{red}{8}\\color{black}1362$, that digit is $8$), move to the right a number of positions equal to the value of the current digit (wrapping around to the leftmost digit after the rightmost one; in $\\color{red}{8}\\color{black}1362$, you move $8$ steps). You will land on another new digit (in $\\color{red}{8}\\color{black}1362$, this is $\\color{red}8\\color{black}\\to 1\\to 3\\to 6\\to 2\\to 8\\to 1\\to 3\\to \\color{red}6$; if you land on a digit that has already been visited, then the number is not a runaround number).\n\nRepeat this process. If you return to the leftmost digit after visiting every digit exactly once, then the integer is a runaround number.\n\nUsing $81362$ as an example, the following simulation shows that $81362$ is a runaround number:\n\n$$\\color{red}8\\color{black}\\to 1\\to 3\\to 6\\to 2\\to 8\\to 1\\to 3\\to \\color{red}6$$  \n$$\\color{red}6\\color{black}\\to 2\\to 8\\to 1\\to 3\\to 6\\to \\color{red}2$$   \n$$\\color{red}2\\color{black}\\to 8\\to \\color{red}1$$  \n$$\\color{red}1\\color{black}\\to \\color{red}3$$  \n$$\\color{red}3\\color{black}\\to 6\\to 2\\to  \\color{red}8$$  \n\nTask:\nGiven a positive integer $m$, find the smallest runaround number $m'$ that is greater than $m$.\n\nIt is guaranteed that $m' \\le 2^{32} - 1$.", "inputFormat": "A single line containing $m$.", "outputFormat": "A single line containing the smallest runaround number $m'$ such that $m' > m$.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\le m \\le 10^9$.\n\nSource: USACO 2.2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO2.2] 循环数 Runaround Numbers", "background": null, "description": "循环数是那些不包括 $0$ 且没有重复数字的正整数（比如 $81362$），并且还应同时具有一个有趣的性质——\n\n如果你从最左边的数字开始（在 $\\color{red}{8}\\color{black}1362$ 中是 $8$）向右数这个数字对应的次数（如果数到了最右边就回到最左边；在 $\\color{red}{8}\\color{black}1362$ 中是 $8$ 次），你会停止在另一个新的数字（在 $\\color{red}{8}\\color{black}1362$ 中是 $\\color{red}8\\color{black}\\to 1\\to 3\\to 6\\to 2\\to 8\\to 1\\to 3\\to \\color{red}6$；如果停在一个相同的数字上，这个数就不是循环数）。\n\n重复这样做，如果能在经过每个数位恰好一次后回到最左边，那么这个正整数就是循环数。\n\n仍然以 $81362$ 为例，以下模拟过程证明了 $81362$ 是循环数：\n\n$$\\color{red}8\\color{black}\\to 1\\to 3\\to 6\\to 2\\to 8\\to 1\\to 3\\to \\color{red}6$$  \n$$\\color{red}6\\color{black}\\to 2\\to 8\\to 1\\to 3\\to 6\\to \\color{red}2$$   \n$$\\color{red}2\\color{black}\\to 8\\to \\color{red}1$$  \n$$\\color{red}1\\color{black}\\to \\color{red}3$$  \n$$\\color{red}3\\color{black}\\to 6\\to 2\\to  \\color{red}8$$  \n\n**任务：**\n\n给你一个正整数 $m$，找出最小的比 $m$ 大的循环数 $m'$。\n\n数据保证 $m' \\le 2^{32}-1$。", "inputFormat": "仅仅一行, 包括 $m$。", "outputFormat": "仅仅一行，输出小的比 $m$ 大的循环数 $m'$。", "hint": "对于 $100\\%$ 的数据，$1\\le m \\le 10^9$。\n\nUSACO 2.2", "locale": "zh-CN"}}}
{"pid": "P1468", "type": "P", "difficulty": 4, "samples": [["10\n1\n-1\n7 -1\n", "0000000000\n0101010101\n0110110110\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "搜索", "1998", "USACO", "IOI", "位运算"], "title": "[IOI 1998 / USACO2.2] 派对灯 Party Lamps", "background": null, "description": "在 IOI98 的节日宴会上，我们有 $n$ 盏彩色灯，他们分别从 $1 \\sim n$ 被标上号码。这些灯都连接到四个按钮：\n- 按钮 $1$：当按下此按钮，将改变所有的灯：本来亮着的灯就熄灭，本来是关着的灯被点亮；\n- 按钮 $2$：当按下此按钮，将改变所有奇数号的灯；\n- 按钮 $3$：当按下此按钮，将改变所有偶数号的灯；\n- 按钮 $4$：当按下此按钮，将改变所有序号是 $3k+1 \\ (k \\in [0,+\\infty) \\cap \\mathbb Z)$ 的灯。例如：$1,4,7,10 \\dots$。\n\n一个计数器 $c$ 记录按钮被按下的次数。当宴会开始，所有的灯都亮着，此时计数器 $c$ 为 $0$。\n\n你将得到计数器 $c$ 上的数值和经过若干操作后某些灯的状态。写一个程序去找出所有灯最后可能的与所给出信息相符的状态，并且没有重复。", "inputFormat": "第一行一个正整数 $n$；第二行一个整数 $c$，表示最后计数器的数值。\n\n第三行若干个整数，表示最后亮着的灯，以 `-1` 结束。\n\n第四行若干个整数，表示最后关着的灯，以 `-1` 结束。\n\n保证不会有灯会在输入中出现两次。", "outputFormat": "每一行是所有灯可能的最后状态（没有重复）。\n\n每一行有 $n$ 个字符，第 $i$ 个字符表示 $i$ 号灯。$0$ 表示关闭，$1$ 表示亮着。这些行必须从小到大排列（看作是二进制数）。\n\n如果没有可能的状态，则输出一行 `IMPOSSIBLE`。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$10 \\le n \\le 100$，$0 \\le c \\le 10^4$。\n\n【样例解释】  \n在这个样例中，有三种可能的状态：\n- 所有灯都关着；\n- $1,4,7,10$ 号灯关着，$2,3,5,6,8,9$ 亮着；\n- $1,3,5,7,9$ 号灯关着，$2,4,6,8,10$ 亮着。\n\n翻译来自 NOCOW。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 1998 / USACO2.2] Party Lamps", "background": "", "description": "At the IOI 1998 holiday banquet, we have $n$ colored lamps, numbered from 1 to $n$. These lamps are connected to four buttons:\n- Button $1$: When pressed, it toggles all lamps: lamps that are on turn off, and lamps that are off turn on.\n- Button $2$: When pressed, it toggles all lamps with odd indices.\n- Button $3$: When pressed, it toggles all lamps with even indices.\n- Button $4$: When pressed, it toggles all lamps whose indices are $3k+1 \\ (k \\in [0,+\\infty) \\cap \\mathbb Z)$. For example: 1, 4, 7, 10, …\n\nA counter $c$ records how many times buttons have been pressed. When the banquet starts, all lamps are on, and the counter $c$ is 0.\n\nYou are given the value on the counter $c$ and the final states of some lamps after several operations. Write a program to find all possible final states of the lamps that are consistent with the given information, without duplicates.", "inputFormat": "The first line contains a positive integer $n$.  \nThe second line contains an integer $c$, the final value of the counter.\n\nThe third line contains several integers, indicating the lamps that are on in the end, terminated by `-1`.\n\nThe fourth line contains several integers, indicating the lamps that are off in the end, terminated by `-1`.\n\nIt is guaranteed that no lamp appears twice in the input.", "outputFormat": "Each line contains one possible final state of all lamps (without duplicates).\n\nEach line has $n$ characters. The $i$-th character corresponds to lamp $i$. `0` means off, and `1` means on. These lines must be sorted from small to large when viewed as binary numbers.\n\nIf there is no possible state, output a single line `IMPOSSIBLE`.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $10 \\le n \\le 100$, $0 \\le c \\le 10^4$.\n\nSample explanation  \nIn this sample, there are three possible states:\n- All lamps are off.\n- Lamps 1, 4, 7, 10 are off; 2, 3, 5, 6, 8, 9 are on.\n- Lamps 1, 3, 5, 7, 9 are off; 2, 4, 6, 8, 10 are on.\n\nTranslation from NOCOW.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 1998 / USACO2.2] 派对灯 Party Lamps", "background": null, "description": "在 IOI98 的节日宴会上，我们有 $n$ 盏彩色灯，他们分别从 $1 \\sim n$ 被标上号码。这些灯都连接到四个按钮：\n- 按钮 $1$：当按下此按钮，将改变所有的灯：本来亮着的灯就熄灭，本来是关着的灯被点亮；\n- 按钮 $2$：当按下此按钮，将改变所有奇数号的灯；\n- 按钮 $3$：当按下此按钮，将改变所有偶数号的灯；\n- 按钮 $4$：当按下此按钮，将改变所有序号是 $3k+1 \\ (k \\in [0,+\\infty) \\cap \\mathbb Z)$ 的灯。例如：$1,4,7,10 \\dots$。\n\n一个计数器 $c$ 记录按钮被按下的次数。当宴会开始，所有的灯都亮着，此时计数器 $c$ 为 $0$。\n\n你将得到计数器 $c$ 上的数值和经过若干操作后某些灯的状态。写一个程序去找出所有灯最后可能的与所给出信息相符的状态，并且没有重复。", "inputFormat": "第一行一个正整数 $n$；第二行一个整数 $c$，表示最后计数器的数值。\n\n第三行若干个整数，表示最后亮着的灯，以 `-1` 结束。\n\n第四行若干个整数，表示最后关着的灯，以 `-1` 结束。\n\n保证不会有灯会在输入中出现两次。", "outputFormat": "每一行是所有灯可能的最后状态（没有重复）。\n\n每一行有 $n$ 个字符，第 $i$ 个字符表示 $i$ 号灯。$0$ 表示关闭，$1$ 表示亮着。这些行必须从小到大排列（看作是二进制数）。\n\n如果没有可能的状态，则输出一行 `IMPOSSIBLE`。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$10 \\le n \\le 100$，$0 \\le c \\le 10^4$。\n\n【样例解释】  \n在这个样例中，有三种可能的状态：\n- 所有灯都关着；\n- $1,4,7,10$ 号灯关着，$2,3,5,6,8,9$ 亮着；\n- $1,3,5,7,9$ 号灯关着，$2,4,6,8,10$ 亮着。\n\n翻译来自 NOCOW。", "locale": "zh-CN"}}}
{"pid": "P1469", "type": "P", "difficulty": 2, "samples": [["9\n2 2 1 3 3 3 2 3 1\n", "2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192]}, "tags": ["数学", "O2优化", "位运算"], "title": "找筷子", "background": "", "description": "经过一段时间的紧张筹备，电脑小组的“RP 餐厅”终于开业了，这天，经理 LXC 接到了一个定餐大单，可把大家乐坏了！员工们齐心协力按要求准备好了套餐正准备派送时，突然碰到一个棘手的问题：筷子！\n\nCX 小朋友找出了餐厅中所有的筷子，但遗憾的是这些筷子长短不一，而我们都知道筷子需要长度一样的才能组成一双，更麻烦的是 CX 找出来的这些筷子数量为奇数，但是巧合的是，这些筷子中只有一只筷子是落单的，其余都成双，善良的你，可以帮 CX 找出这只落单的筷子的长度吗？\n", "inputFormat": "第一行是一个整数，表示筷子的数量 $n$。\n\n第二行有 $n$ 个整数，第 $i$ 个整数表示第 $i$ 根筷子的长度 $a_i$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n \\leq 10^5$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 10^7 + 1$，$1 \\leq a_i \\leq 10^9$。\n\n\n#### 提示\n\n- 请注意数据读入对程序效率造成的影响。\n- 请注意本题的空间限制为 $8$ Mb。", "locale": "zh-CN", "translations": {"en": {"title": "Find the Chopstick", "background": "", "description": "After a period of intense preparation, the computer club’s \"RP Restaurant\" finally opened. One day, manager LXC received a large order, which made everyone very happy! The staff worked together to prepare the set meals as required and were about to deliver them when they suddenly encountered a tricky problem: chopsticks!\n\nCX found all the chopsticks in the restaurant, but unfortunately they are of different lengths. We all know that a pair of chopsticks must be of the same length. To make it worse, the number of chopsticks CX found is odd. Coincidentally, among these chopsticks, only one chopstick is single, and all the others are in pairs. Kind-hearted as you are, can you help CX find the length of this single chopstick?", "inputFormat": "The first line contains an integer, the number of chopsticks $n$.\n\nThe second line contains $n$ integers. The $i$-th integer is the length $a_i$ of the $i$-th chopstick.", "outputFormat": "Output a single integer in one line representing the answer.", "hint": "Constraints\n- For 30% of the testdata, it is guaranteed that $n \\leq 10^5$.\n- For 100% of the testdata, it is guaranteed that $1 \\leq n \\leq 10^7 + 1$, $1 \\leq a_i \\leq 10^9$.\n\nHints\n- Pay attention to how input reading affects program efficiency.\n- Note the space limit of $8$ Mb.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "找筷子", "background": "", "description": "经过一段时间的紧张筹备，电脑小组的“RP 餐厅”终于开业了，这天，经理 LXC 接到了一个定餐大单，可把大家乐坏了！员工们齐心协力按要求准备好了套餐正准备派送时，突然碰到一个棘手的问题：筷子！\n\nCX 小朋友找出了餐厅中所有的筷子，但遗憾的是这些筷子长短不一，而我们都知道筷子需要长度一样的才能组成一双，更麻烦的是 CX 找出来的这些筷子数量为奇数，但是巧合的是，这些筷子中只有一只筷子是落单的，其余都成双，善良的你，可以帮 CX 找出这只落单的筷子的长度吗？\n", "inputFormat": "第一行是一个整数，表示筷子的数量 $n$。\n\n第二行有 $n$ 个整数，第 $i$ 个整数表示第 $i$ 根筷子的长度 $a_i$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n \\leq 10^5$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 10^7 + 1$，$1 \\leq a_i \\leq 10^9$。\n\n\n#### 提示\n\n- 请注意数据读入对程序效率造成的影响。\n- 请注意本题的空间限制为 $8$ Mb。", "locale": "zh-CN"}}}
{"pid": "P1470", "type": "P", "difficulty": 4, "samples": [["A AB BA CA BBC\n.\nABABACABAABC\n", "11\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "动态规划 DP", "USACO", "IOI", "字典树 Trie", "KMP 算法", "1996"], "title": "[IOI 1996 / USACO2.3] 最长前缀 Longest Prefix", "background": null, "description": "在生物学中，一些生物的结构是用包含其要素的大写字母序列来表示的。生物学家对于把长的序列分解成较短的序列（即元素）很感兴趣。\n\n如果一个集合 $P$ 中的元素可以串起来（元素可以重复使用）组成一个序列 $S$，那么我们认为序列 $S$ 可以分解为 $P$ 中的元素。元素不一定要全部出现（如下例中 `BBC` 就没有出现）。举个例子，序列 `ABABACABAAB` 可以分解为下面集合中的元素：`{A,AB,BA,CA,BBC}`。\n\n序列 $S$ 的前面 $k$ 个字符称作 $S$ 中长度为 $k$ 的前缀。设计一个程序，输入一个元素集合以及一个大写字母序列，设 $S'$ 是序列 $S$ 的前缀，使其可以分解为给出的集合 $P$ 中的元素，求 $S'$ 的长度 $k$ 的最大值。", "inputFormat": "输入数据的开头包括若干个元素组成的集合 $P$，用连续的以空格分开的字符串表示。字母全部是大写，数据可能不止一行。元素集合结束的标志是一个只包含一个 `.` 的行，集合中的元素没有重复。  \n\n接着是大写字母序列 $S$，用字符串表示，每 $76$ 个字符换一行。", "outputFormat": "只有一行，输出一个整数，表示 $S$ 符合条件的前缀的最大长度。", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$1\\le \\text{card}(P) \\le 200$，$1\\le |S| \\le 2\\times 10^5$，$P$ 中的元素长度均不超过 $10$。\n\n翻译来自 NOCOW。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 1996 / USACO2.3] Longest Prefix", "background": "", "description": "In biology, the structures of some organisms are represented by sequences of uppercase letters that contain their components. Biologists are interested in breaking long sequences into shorter sequences (i.e., elements).\n\nIf the elements in a set $P$ can be concatenated (elements may be reused) to form a sequence $S$, then we say that $S$ can be decomposed into elements from $P$. Not all elements need to appear (for example, `BBC` does not appear below). For instance, the sequence `ABABACABAAB` can be decomposed into elements from the set `{A, AB, BA, CA, BBC}`.\n\nThe first $k$ characters of sequence $S$ are called the length-$k$ prefix of $S$. Design a program that, given a set of elements and an uppercase-letter sequence, lets $S'$ be the longest prefix of $S$ that can be decomposed into elements from the given set $P$, and computes the length $k$ of $S'$.", "inputFormat": "The input begins with a set $P$ consisting of several elements, given as a sequence of space-separated strings. All letters are uppercase, and the data may span multiple lines. The set ends with a line that contains only a single `.`. There are no duplicate elements in the set.\n\nThen follows the uppercase-letter sequence $S$, given as a string, with a newline after every $76$ characters.", "outputFormat": "Output a single line containing one integer: the maximum length of a prefix of $S$ that satisfies the condition.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, $1 \\le \\text{card}(P) \\le 200$, $1 \\le |S| \\le 2 \\times 10^5$, and the length of each element in $P$ does not exceed $10$.\n\nTranslation from NOCOW.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 1996 / USACO2.3] 最长前缀 Longest Prefix", "background": null, "description": "在生物学中，一些生物的结构是用包含其要素的大写字母序列来表示的。生物学家对于把长的序列分解成较短的序列（即元素）很感兴趣。\n\n如果一个集合 $P$ 中的元素可以串起来（元素可以重复使用）组成一个序列 $S$，那么我们认为序列 $S$ 可以分解为 $P$ 中的元素。元素不一定要全部出现（如下例中 `BBC` 就没有出现）。举个例子，序列 `ABABACABAAB` 可以分解为下面集合中的元素：`{A,AB,BA,CA,BBC}`。\n\n序列 $S$ 的前面 $k$ 个字符称作 $S$ 中长度为 $k$ 的前缀。设计一个程序，输入一个元素集合以及一个大写字母序列，设 $S'$ 是序列 $S$ 的前缀，使其可以分解为给出的集合 $P$ 中的元素，求 $S'$ 的长度 $k$ 的最大值。", "inputFormat": "输入数据的开头包括若干个元素组成的集合 $P$，用连续的以空格分开的字符串表示。字母全部是大写，数据可能不止一行。元素集合结束的标志是一个只包含一个 `.` 的行，集合中的元素没有重复。  \n\n接着是大写字母序列 $S$，用字符串表示，每 $76$ 个字符换一行。", "outputFormat": "只有一行，输出一个整数，表示 $S$ 符合条件的前缀的最大长度。", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$1\\le \\text{card}(P) \\le 200$，$1\\le |S| \\le 2\\times 10^5$，$P$ 中的元素长度均不超过 $10$。\n\n翻译来自 NOCOW。", "locale": "zh-CN"}}}
{"pid": "P1471", "type": "P", "difficulty": 5, "samples": [["5 5\n1 5 4 2 3\n2 1 4\n3 1 5\n1 1 1 1\n1 2 2 -1\n3 1 5\n", "3.0000\n2.0000\n0.8000\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2016", "线段树", "树状数组", "洛谷原创", "分块", "洛谷月赛"], "title": "方差", "background": "滚粗了的 HansBug 在收拾旧数学书，然而他发现了什么奇妙的东西。\n", "description": "蒟蒻 HansBug 在一本数学书里面发现了一个神奇的数列，包含 $N$ 个实数。他想算算这个数列的平均数和方差。\n", "inputFormat": "第一行包含两个正整数 $N,M$，分别表示数列中实数的个数和操作的个数。\n\n第二行包含 $N$ 个实数，其中第 $i$ 个实数表示数列的第 $i$ 项。\n\n接下来 $M$ 行，每行为一条操作，格式为以下三种之一：\n\n操作 $1$：`1 x y k` ，表示将第 $x$ 到第 $y$ 项每项加上 $k$，$k$ 为一实数。  \n操作 $2$：`2 x y` ，表示求出第 $x$ 到第 $y$ 项这一子数列的平均数。  \n操作 $3$：`3 x y` ，表示求出第 $x$ 到第 $y$ 项这一子数列的方差。", "outputFormat": "输出包含若干行，每行为一个实数，即依次为每一次操作 $2$ 或操作 $3$ 所得的结果（所有结果四舍五入保留 $4$ 位小数）。\n", "hint": "关于方差：对于一个有 $n$ 项的数列 $A$，其方差 $s^2$ 定义如下：\n$$s^2=\\frac{1}{n}\\sum\\limits_{i=1}^n\\left(A_i-\\overline A\\right)^2$$\n其中 $\\overline A$ 表示数列 $A$ 的平均数，$A_i$ 表示数列 $A$ 的第 $i$ 项。\n\n样例说明：\n| 操作步骤 | 输入内容 | 操作要求 | 数列 | 输出结果 | 说明 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $0$ | - | - | `1 5 4 2 3` | - | - |\n| $1$ | `2 1 4` | 求 $\\left[1,4\\right]$ 内所有数字的平均数 | `1 5 4 2 3` | `3.0000` | 平均数 $=\\left(1+5+4+2\\right)\\div 4=3.0000$ |\n| $2$ | `3 1 5` | 求 $\\left[1,5\\right]$ 内所有数字的方差 | `1 5 4 2 3` | `2.0000` | 平均数 $=\\left(1+5+4+2+3\\right)\\div 5=3$，方差 $=\\left(\\left(1-3\\right)^2+\\left(5-3\\right)^2+\\left(4-3\\right)^2+\\left(2-3\\right)^2+\\left(3-3\\right)^2\\right)\\div 5=2.0000$ |\n| $3$ | `1 1 1 1` | 将 $\\left[1,1\\right]$ 内所有数字加 $1$ | `2 5 4 2 3` | - | - |\n| $4$ | `1 2 2 -1` | 将 $\\left[2,2\\right]$ 内所有数字加 $-1$ | `2 4 4 2 3` | - | - |\n| $5$ | `3 1 5` | 求 $\\left[1,5\\right]$ 内所有数字的方差 | `2 4 4 2 3` | `0.8000` | 平均数 $=\\left(2+4+4+2+3\\right)\\div 5=3$，方差 $=\\left(\\left(2-3\\right)^2+\\left(4-3\\right)^2+\\left(4-3\\right)^2+\\left(2-3\\right)^2+\\left(3-3\\right)^2\\right)\\div 5=0.8000$ |\n\n数据规模：\n| 数据点 | $N$ | $M$ | 备注 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1\\sim3$ | $N\\le 8$ | $M\\le 15$ | - |\n| $4\\sim7$ | $N\\le 10^5$ | $M\\le 10^5$ | 不包含操作 $3$|\n| $8\\sim10$ | $N\\le 10^5$ | $M\\le 10^5$ | - |\n\n保证原数列和输入的所有 $k$ 均为 $[-100,100]$ 范围内的实数。", "locale": "zh-CN", "translations": {"en": {"title": "Variance", "background": "While tidying up his old math books, HansBug discovered something curious.", "description": "The noob HansBug found a magical sequence in a math book, consisting of $N$ real numbers. He wants to compute the mean and variance of this sequence.", "inputFormat": "The first line contains two positive integers $N, M$, denoting the number of real numbers in the sequence and the number of operations.\n\nThe second line contains $N$ real numbers, where the $i$-th real number is the $i$-th term of the sequence.\n\nThe next $M$ lines each describe an operation, in one of the following three formats:\n- Operation 1: `1 x y k`, add $k$ (a real number) to every term from the $x$-th to the $y$-th item.\n- Operation 2: `2 x y`, compute the mean of the subsequence from the $x$-th to the $y$-th item.\n- Operation 3: `3 x y`, compute the variance of the subsequence from the $x$-th to the $y$-th item.", "outputFormat": "Output several lines, each containing one real number, which are the results of every Operation 2 or Operation 3 in order. Round all results to $4$ decimal places using standard rounding.", "hint": "About variance: For a sequence $A$ with $n$ terms, its variance $s^2$ is defined as:\n$$s^2=\\frac{1}{n}\\sum\\limits_{i=1}^n\\left(A_i-\\overline A\\right)^2$$\nwhere $\\overline A$ is the mean of sequence $A$, and $A_i$ is the $i$-th term of sequence $A$.\n\nSample explanation:\n| Step | Input | Requirement | Sequence | Output | Note |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $0$ | - | - | `1 5 4 2 3` | - | - |\n| $1$ | `2 1 4` | Compute the mean of all numbers in $\\left[1,4\\right]$ | `1 5 4 2 3` | `3.0000` | Mean $=\\left(1+5+4+2\\right)\\div 4=3.0000$. |\n| $2$ | `3 1 5` | Compute the variance of all numbers in $\\left[1,5\\right]$ | `1 5 4 2 3` | `2.0000` | Mean $=\\left(1+5+4+2+3\\right)\\div 5=3$, variance $=\\left(\\left(1-3\\right)^2+\\left(5-3\\right)^2+\\left(4-3\\right)^2+\\left(2-3\\right)^2+\\left(3-3\\right)^2\\right)\\div 5=2.0000$. |\n| $3$ | `1 1 1 1` | Add $1$ to all numbers in $\\left[1,1\\right]$ | `2 5 4 2 3` | - | - |\n| $4$ | `1 2 2 -1` | Add $-1$ to all numbers in $\\left[2,2\\right]$ | `2 4 4 2 3` | - | - |\n| $5$ | `3 1 5` | Compute the variance of all numbers in $\\left[1,5\\right]$ | `2 4 4 2 3` | `0.8000` | Mean $=\\left(2+4+4+2+3\\right)\\div 5=3$, variance $=\\left(\\left(2-3\\right)^2+\\left(4-3\\right)^2+\\left(4-3\\right)^2+\\left(2-3\\right)^2+\\left(3-3\\right)^2\\right)\\div 5=0.8000$. |\n\nConstraints:\n| Test points | $N$ | $M$ | Note |\n| :----------: | :----------: | :----------: | :----------: |\n| $1\\sim3$ | $N\\le 8$ | $M\\le 15$ | - |\n| $4\\sim7$ | $N\\le 10^5$ | $M\\le 10^5$ | Operation $3$ not included. |\n| $8\\sim10$ | $N\\le 10^5$ | $M\\le 10^5$ | - |\n\nAll numbers in the original sequence and all input $k$ are real numbers within the range $[-100, 100]$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "方差", "background": "滚粗了的 HansBug 在收拾旧数学书，然而他发现了什么奇妙的东西。\n", "description": "蒟蒻 HansBug 在一本数学书里面发现了一个神奇的数列，包含 $N$ 个实数。他想算算这个数列的平均数和方差。\n", "inputFormat": "第一行包含两个正整数 $N,M$，分别表示数列中实数的个数和操作的个数。\n\n第二行包含 $N$ 个实数，其中第 $i$ 个实数表示数列的第 $i$ 项。\n\n接下来 $M$ 行，每行为一条操作，格式为以下三种之一：\n\n操作 $1$：`1 x y k` ，表示将第 $x$ 到第 $y$ 项每项加上 $k$，$k$ 为一实数。  \n操作 $2$：`2 x y` ，表示求出第 $x$ 到第 $y$ 项这一子数列的平均数。  \n操作 $3$：`3 x y` ，表示求出第 $x$ 到第 $y$ 项这一子数列的方差。", "outputFormat": "输出包含若干行，每行为一个实数，即依次为每一次操作 $2$ 或操作 $3$ 所得的结果（所有结果四舍五入保留 $4$ 位小数）。\n", "hint": "关于方差：对于一个有 $n$ 项的数列 $A$，其方差 $s^2$ 定义如下：\n$$s^2=\\frac{1}{n}\\sum\\limits_{i=1}^n\\left(A_i-\\overline A\\right)^2$$\n其中 $\\overline A$ 表示数列 $A$ 的平均数，$A_i$ 表示数列 $A$ 的第 $i$ 项。\n\n样例说明：\n| 操作步骤 | 输入内容 | 操作要求 | 数列 | 输出结果 | 说明 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $0$ | - | - | `1 5 4 2 3` | - | - |\n| $1$ | `2 1 4` | 求 $\\left[1,4\\right]$ 内所有数字的平均数 | `1 5 4 2 3` | `3.0000` | 平均数 $=\\left(1+5+4+2\\right)\\div 4=3.0000$ |\n| $2$ | `3 1 5` | 求 $\\left[1,5\\right]$ 内所有数字的方差 | `1 5 4 2 3` | `2.0000` | 平均数 $=\\left(1+5+4+2+3\\right)\\div 5=3$，方差 $=\\left(\\left(1-3\\right)^2+\\left(5-3\\right)^2+\\left(4-3\\right)^2+\\left(2-3\\right)^2+\\left(3-3\\right)^2\\right)\\div 5=2.0000$ |\n| $3$ | `1 1 1 1` | 将 $\\left[1,1\\right]$ 内所有数字加 $1$ | `2 5 4 2 3` | - | - |\n| $4$ | `1 2 2 -1` | 将 $\\left[2,2\\right]$ 内所有数字加 $-1$ | `2 4 4 2 3` | - | - |\n| $5$ | `3 1 5` | 求 $\\left[1,5\\right]$ 内所有数字的方差 | `2 4 4 2 3` | `0.8000` | 平均数 $=\\left(2+4+4+2+3\\right)\\div 5=3$，方差 $=\\left(\\left(2-3\\right)^2+\\left(4-3\\right)^2+\\left(4-3\\right)^2+\\left(2-3\\right)^2+\\left(3-3\\right)^2\\right)\\div 5=0.8000$ |\n\n数据规模：\n| 数据点 | $N$ | $M$ | 备注 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1\\sim3$ | $N\\le 8$ | $M\\le 15$ | - |\n| $4\\sim7$ | $N\\le 10^5$ | $M\\le 10^5$ | 不包含操作 $3$|\n| $8\\sim10$ | $N\\le 10^5$ | $M\\le 10^5$ | - |\n\n保证原数列和输入的所有 $k$ 均为 $[-100,100]$ 范围内的实数。", "locale": "zh-CN"}}}
{"pid": "P1472", "type": "P", "difficulty": 5, "samples": [["5 3\n", "2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "树形数据结构", "USACO", "前缀和", "构造"], "title": "[USACO2.3] 奶牛家谱 Cow Pedigrees", "background": "", "description": "一个有 $n$ 个节点，深度为 $k$ 的无标号完满二叉树（即每个节点的儿子数为 $0$ 或 $2$）有多少种结构？定义根节点深度为 $1$。\n\n答案对 $9901$ 取模。", "inputFormat": "两个空格分开的整数 $n,k$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$3\\le n < 200$，$2 \\le k < 100$。\n\nUSACO 2.3\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO2.3] Cow Pedigrees", "background": "", "description": "How many distinct structures are there for an unlabeled full binary tree (each node has either $0$ or $2$ children) with $n$ nodes and depth $k$? The depth of the root is defined as $1$.\n\nOutput the answer modulo $9901$.", "inputFormat": "Two space-separated integers $n, k$.", "outputFormat": "Output a single integer on one line representing the answer.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $3 \\le n < 200$, $2 \\le k < 100$.\n\nUSACO 2.3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO2.3] 奶牛家谱 Cow Pedigrees", "background": "", "description": "一个有 $n$ 个节点，深度为 $k$ 的无标号完满二叉树（即每个节点的儿子数为 $0$ 或 $2$）有多少种结构？定义根节点深度为 $1$。\n\n答案对 $9901$ 取模。", "inputFormat": "两个空格分开的整数 $n,k$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$3\\le n < 200$，$2 \\le k < 100$。\n\nUSACO 2.3\n", "locale": "zh-CN"}}}
{"pid": "P1473", "type": "P", "difficulty": 3, "samples": [["7\n", "1+2-3+4-5-6+7\n1+2-3-4+5+6-7\n1-2 3+4+5+6+7\n1-2 3-4 5+6 7\n1-2+3+4-5+6-7\n1-2-3-4-5+6+7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "搜索", "数学", "USACO", "进制"], "title": "[USACO2.3] 零的数列 Zero Sum", "background": "", "description": "请考虑一个由 $1$ 到 $N$ 的数字组成的递增数列：$1, 2, 3, \\ldots, N$。\n\n现在请在数列中插入 `+` 表示加，或者 `-` 表示减，` `（空格） 表示空白（例如 `1-2 3` 就等于 `1-23`），来将每一对数字组合在一起（请不要在第一个数字前插入符号）。\n\n计算该表达式的结果并判断其值是否为 $0$。 请你写一个程序找出所有产生和为零的长度为N的数列。\n", "inputFormat": "单独的一行表示整数 $N$（$3 \\leq N \\leq 9$）。\n", "outputFormat": "按照 ASCI I码的顺序，输出所有在每对数字间插入 `+`，`-`，` `（空格） 后能得到结果为零的数列。\n", "hint": "翻译来自NOCOW\n\nUSACO 2.3\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO2.3] Zero Sum", "background": "", "description": "Consider an increasing sequence of numbers from $1$ to $N$: $1, 2, 3, \\ldots, N$.\n\nInsert `+` for addition, `-` for subtraction, or ` ` (a space) for blank between each pair of consecutive numbers (for example, `1-2 3` equals `1-23`). Do not insert any symbol before the first number.\n\nEvaluate the resulting expression and determine whether its value is $0$. Write a program to find all expressions of length $N$ whose value is zero.", "inputFormat": "A single line containing an integer $N$ ($3 \\leq N \\leq 9$).", "outputFormat": "In ASCII order, output all expressions obtained by inserting `+`, `-`, or ` ` (space) between each pair of consecutive numbers such that the resulting expression evaluates to $0$. Print one expression per line.", "hint": "Translated from NOCOW.\n\nUSACO 2.3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO2.3] 零的数列 Zero Sum", "background": "", "description": "请考虑一个由 $1$ 到 $N$ 的数字组成的递增数列：$1, 2, 3, \\ldots, N$。\n\n现在请在数列中插入 `+` 表示加，或者 `-` 表示减，` `（空格） 表示空白（例如 `1-2 3` 就等于 `1-23`），来将每一对数字组合在一起（请不要在第一个数字前插入符号）。\n\n计算该表达式的结果并判断其值是否为 $0$。 请你写一个程序找出所有产生和为零的长度为N的数列。\n", "inputFormat": "单独的一行表示整数 $N$（$3 \\leq N \\leq 9$）。\n", "outputFormat": "按照 ASCI I码的顺序，输出所有在每对数字间插入 `+`，`-`，` `（空格） 后能得到结果为零的数列。\n", "hint": "翻译来自NOCOW\n\nUSACO 2.3\n", "locale": "zh-CN"}}}
{"pid": "P1474", "type": "P", "difficulty": 3, "samples": [["3 10\n1 2 5\n", "10\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2007", "USACO"], "title": "[USACO2.3] Money System / [USACO07OCT] Cow Cash G", "background": "", "description": "母牛们不但创建了它们自己的政党，而且选择了建立了自己的货币系统。由于它们特殊的思考方式，它们对货币的数值感到好奇。\n\n传统地，一个货币系统是由 $1,5,10,20,25,50,100$ 的单位面值组成的。\n\n母牛们想知道有多少种不同的方案来用货币系统中的货币来构造一个确定的面值。\n\n举例来说，使用一个由 $1,2,5,10$ 的单位面值组成的货币系统产生 $18$ 面值的一些可能的方法是：$18 \\times 1$，$9 \\times 2$，$8 \\times 2+2 \\times 1$，$3 \\times 5+2+1$，等等。\n\n写一个程序来计算有多少种方法用给定的货币系统来构造一定数量的面值。保证总数在 $64$ 位带符号整数的范围内。", "inputFormat": "第一行两个整数，代表货币系统中货币的种类数目 $V$（$1 \\leq V \\leq 25$）和要构造的面值 $N$（$1 \\leq N \\leq 10,000$）。\n\n第二行 $V$ 个整数，代表所有货币的单位面值。", "outputFormat": "仅一行一个整数，代表方案数。", "hint": "翻译来自 NOCOW。\n\nUSACO Training Section 2.3", "locale": "zh-CN", "translations": {"en": {"title": "[USACO2.3] Money System / [USACO07OCT] Cow Cash G", "background": "", "description": "The cows have not only created their own political party but also chosen to establish their own currency system. Because of their unique way of thinking, they are curious about monetary values.\n\nTraditionally, a currency system consists of denominations $1,5,10,20,25,50,100$.\n\nThe cows want to know how many different ways there are to form a specified value using the coins in the currency system.\n\nFor example, using a currency system with denominations $1,2,5,10$ to make a value of $18$, some possible ways are: $18 \\times 1$, $9 \\times 2$, $8 \\times 2+2 \\times 1$, $3 \\times 5+2+1$, and so on.\n\nWrite a program to compute how many ways there are to make a given amount using the provided currency system. It is guaranteed that the total fits in a $64$-bit signed integer.", "inputFormat": "The first line contains two integers, the number of coin types $V$ ($1 \\leq V \\leq 25$) and the target value $N$ ($1 \\leq N \\leq 10,000$).\n\nThe second line contains $V$ integers, the denominations of all coins.", "outputFormat": "A single line with one integer, the number of ways.", "hint": "Translated from NOCOW.\n\nUSACO Training Section 2.3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO2.3] Money System / [USACO07OCT] Cow Cash G", "background": "", "description": "母牛们不但创建了它们自己的政党，而且选择了建立了自己的货币系统。由于它们特殊的思考方式，它们对货币的数值感到好奇。\n\n传统地，一个货币系统是由 $1,5,10,20,25,50,100$ 的单位面值组成的。\n\n母牛们想知道有多少种不同的方案来用货币系统中的货币来构造一个确定的面值。\n\n举例来说，使用一个由 $1,2,5,10$ 的单位面值组成的货币系统产生 $18$ 面值的一些可能的方法是：$18 \\times 1$，$9 \\times 2$，$8 \\times 2+2 \\times 1$，$3 \\times 5+2+1$，等等。\n\n写一个程序来计算有多少种方法用给定的货币系统来构造一定数量的面值。保证总数在 $64$ 位带符号整数的范围内。", "inputFormat": "第一行两个整数，代表货币系统中货币的种类数目 $V$（$1 \\leq V \\leq 25$）和要构造的面值 $N$（$1 \\leq N \\leq 10,000$）。\n\n第二行 $V$ 个整数，代表所有货币的单位面值。", "outputFormat": "仅一行一个整数，代表方案数。", "hint": "翻译来自 NOCOW。\n\nUSACO Training Section 2.3", "locale": "zh-CN"}}}
{"pid": "P1475", "type": "P", "difficulty": 3, "samples": [["3\n1 2 80\n2 3 80\n3 1 20", "1 2\n1 3\n2 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "USACO"], "title": "[USACO2.3] 控制公司 Controlling Companies", "background": "", "description": "有些公司是其他公司的部分拥有者，因为他们获得了其他公司发行的股票的一部分。\n\n据说，如果至少满足了以下三个条件之一，公司 $A$ 就可以控制公司 $B$ 了：\n\n- 公司 $A$ = 公司 $B$。\n- 公司 $A$ 拥有大于 $50\\%$ 的公司 $B$ 的股票。\n- 公司 $A$ 控制 $K$（$K \\geq 1$）个公司，记为 $C_1, \\ldots, C_K$，每个公司 $C_i$ 拥有 $x_i\\%$ 的公司 $B$ 的股票，并且 $x_1+ \\ldots + x_K \\gt 50\\%$。\n\n给你一个表，每行包括三个数 $i,j,p$：表明公司 $i$ 享有公司 $j$ 的 $p\\%$ 的股票。计算所有的数对 $(h,s)$，表明公司 $h$ 控制公司 $s$。至多有 $100$ 个公司。", "inputFormat": "第一行一个整数 $N$，表明表格的行数。\n\n接下来 $N$ 行，每行三个整数 $i,j,p$，表示 $i$ 公司拥有 $j$ 公司 $p\\%$ 的股份。", "outputFormat": "输出零个或更多个的控制其他公司的公司。每行包括两个整数 $A,B$，表示 $A$ 公司控制了 $B$ 公司。将输出的数对以 $A$ 为第一关键字，$B$ 为第二关键字升序排列。\n\n请不要输出控制自己的公司（即你输出的数对均要满足 $A \\neq B$）。", "hint": "翻译来自NOCOW\n\nUSACO 2.3\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO2.3] Controlling Companies", "background": "", "description": "Some companies are partial owners of other companies because they own a portion of the shares issued by those companies.\n\nIt is said that if at least one of the following three conditions is met, company $A$ can control company $B$:\n\n- Company $A$ = company $B$.\n- Company $A$ owns more than $50\\%$ of company $B$'s stock.\n- Company $A$ controls $K$ ($K \\geq 1$) companies, denoted $C_1, \\ldots, C_K$, each company $C_i$ owns $x_i\\%$ of company $B$'s stock, and $x_1+ \\ldots + x_K \\gt 50\\%$.\n\nYou are given a table where each row contains three numbers $i,j,p$: it means company $i$ owns $p\\%$ of company $j$. Compute all pairs $(h,s)$ indicating that company $h$ controls company $s$. There are at most $100$ companies.", "inputFormat": "The first line contains an integer $N$, the number of rows in the table.\n\nEach of the next $N$ lines contains three integers $i,j,p$, meaning company $i$ owns $p\\%$ of company $j$'s stock.", "outputFormat": "Output zero or more companies that control other companies. Each line contains two integers $A,B$, meaning company $A$ controls company $B$. Sort the output pairs in ascending order by $A$ as the primary key and $B$ as the secondary key.\n\nDo not output cases where a company controls itself (i.e., all pairs must satisfy $A \\neq B$).", "hint": "Translated from NOCOW.\n\nUSACO 2.3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO2.3] 控制公司 Controlling Companies", "background": "", "description": "有些公司是其他公司的部分拥有者，因为他们获得了其他公司发行的股票的一部分。\n\n据说，如果至少满足了以下三个条件之一，公司 $A$ 就可以控制公司 $B$ 了：\n\n- 公司 $A$ = 公司 $B$。\n- 公司 $A$ 拥有大于 $50\\%$ 的公司 $B$ 的股票。\n- 公司 $A$ 控制 $K$（$K \\geq 1$）个公司，记为 $C_1, \\ldots, C_K$，每个公司 $C_i$ 拥有 $x_i\\%$ 的公司 $B$ 的股票，并且 $x_1+ \\ldots + x_K \\gt 50\\%$。\n\n给你一个表，每行包括三个数 $i,j,p$：表明公司 $i$ 享有公司 $j$ 的 $p\\%$ 的股票。计算所有的数对 $(h,s)$，表明公司 $h$ 控制公司 $s$。至多有 $100$ 个公司。", "inputFormat": "第一行一个整数 $N$，表明表格的行数。\n\n接下来 $N$ 行，每行三个整数 $i,j,p$，表示 $i$ 公司拥有 $j$ 公司 $p\\%$ 的股份。", "outputFormat": "输出零个或更多个的控制其他公司的公司。每行包括两个整数 $A,B$，表示 $A$ 公司控制了 $B$ 公司。将输出的数对以 $A$ 为第一关键字，$B$ 为第二关键字升序排列。\n\n请不要输出控制自己的公司（即你输出的数对均要满足 $A \\neq B$）。", "hint": "翻译来自NOCOW\n\nUSACO 2.3\n", "locale": "zh-CN"}}}
{"pid": "P1476", "type": "P", "difficulty": 3, "samples": [["4\r\n5\r\n1 2 2\r\n2 3 2\r\n3 5 3\r\n1 4 3\r\n4 5 3\r\n", "7\r\n1 2 3 5\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论"], "title": "休息中的小呆", "background": null, "description": "当大家在考场中接受考验（折磨？）的时候，小呆正在悠闲（欠扁）地玩一个叫“最初梦想”的游戏。游戏描述的是一个叫 pass 的有志少年在不同的时空穿越对抗传说中的大魔王 chinesesonic 的故事。小呆发现这个游戏的故事流程设计得很复杂，它有着很多的分支剧情，但不同的分支剧情是可以同时进行的，因此游戏可以由剧情和剧情的结束点组成，某些剧情必须要在一些特定的剧情结束后才能继续发展。为了体验游戏的完整性，小呆决定要看到所有的分支剧情——完成所有的任务。但这样做会不会耽误小呆宝贵的睡觉时间呢？所以就请你来解决这个问题了。", "inputFormat": "小呆会给你一个剧情流程和完成条件的列表，\n\n其中第一行有一个数 $n$，表示总共有 $n$ 个剧情结束点；\n\n第二行一个数 $m$，表示有 $m$ 个不同的剧情；\n\n下面的 $m$ 行中每行有三个数，表示从剧情结束点 $i$ 必须完成一个耗费时间为 $k$ 的剧情才能到达剧情结束点 $j$。", "outputFormat": "你要告诉小呆完成整个游戏至少需要多少时间，以及要经过的所有可能的剧情结束点（按升序输出）。", "hint": "### 数据范围及约定\n\n对于全部数据，$0<n<100$，$0<m\\le 120$，$0<i\\le 100$，$0<j\\le 100$，$0<k\\le 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "Xiao Dai at Rest", "background": "", "description": "While everyone is being tested (tortured?) in the exam room, Xiao Dai is leisurely (annoyingly) playing a game called \"Initial Dream.\" The game tells the story of an aspiring young man named pass who travels through different times and spaces to fight the legendary demon king chinesesonic. Xiao Dai finds the game's story flow quite complex. It has many branching plots, and different branches can proceed at the same time. Therefore, the game can be described by plots and plot endpoints, and some plots can only continue after certain specific plot endpoints are reached. To experience the game's completeness, Xiao Dai decides to see all the branches — complete all tasks. But will this delay Xiao Dai's precious sleep time? So please solve this problem.", "inputFormat": "Xiao Dai will give you a list describing the plot flow and completion conditions.\n\n- The first line contains a number $n$, meaning there are $n$ plot endpoints in total.\n- The second line contains a number $m$, meaning there are $m$ different plots.\n- Each of the next $m$ lines contains three numbers, meaning that from plot endpoint $i$, you must complete a plot that takes time $k$ in order to reach plot endpoint $j$.", "outputFormat": "You must tell Xiao Dai the minimum time needed to complete the entire game, and all possible plot endpoints that will be passed through (output in ascending order).", "hint": "Constraints\n\nFor all testdata, $0<n<100$, $0<m\\le 120$, $0<i\\le 100$, $0<j\\le 100$, $0<k\\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "休息中的小呆", "background": null, "description": "当大家在考场中接受考验（折磨？）的时候，小呆正在悠闲（欠扁）地玩一个叫“最初梦想”的游戏。游戏描述的是一个叫 pass 的有志少年在不同的时空穿越对抗传说中的大魔王 chinesesonic 的故事。小呆发现这个游戏的故事流程设计得很复杂，它有着很多的分支剧情，但不同的分支剧情是可以同时进行的，因此游戏可以由剧情和剧情的结束点组成，某些剧情必须要在一些特定的剧情结束后才能继续发展。为了体验游戏的完整性，小呆决定要看到所有的分支剧情——完成所有的任务。但这样做会不会耽误小呆宝贵的睡觉时间呢？所以就请你来解决这个问题了。", "inputFormat": "小呆会给你一个剧情流程和完成条件的列表，\n\n其中第一行有一个数 $n$，表示总共有 $n$ 个剧情结束点；\n\n第二行一个数 $m$，表示有 $m$ 个不同的剧情；\n\n下面的 $m$ 行中每行有三个数，表示从剧情结束点 $i$ 必须完成一个耗费时间为 $k$ 的剧情才能到达剧情结束点 $j$。", "outputFormat": "你要告诉小呆完成整个游戏至少需要多少时间，以及要经过的所有可能的剧情结束点（按升序输出）。", "hint": "### 数据范围及约定\n\n对于全部数据，$0<n<100$，$0<m\\le 120$，$0<i\\le 100$，$0<j\\le 100$，$0<k\\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P1477", "type": "P", "difficulty": 5, "samples": [["6 5\n1 2\n2 3\n3 4\n4 1\n3 5", "4 4\n"], ["3 3\n1 2\n2 1\n2 3", "-1 -1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "2008", "NOI", "深度优先搜索 DFS", "最大公约数 gcd"], "title": "[NOI2008] 假面舞会", "background": "", "description": "一年一度的假面舞会又开始了，栋栋也兴致勃勃的参加了今年的舞会。\n\n今年的面具都是主办方特别定制的。每个参加舞会的人都可以在入场时选择一个自己喜欢的面具。每个面具都有一个编号，主办方会把此编号告诉拿该面具的人。\n\n为了使舞会更有神秘感，主办方把面具分为 $k$（$k\\geq 3$）类，并使用特殊的技术将每个面具的编号标在了面具上，只有戴第 $i$ 类面具的人才能看到戴第 $i+1$  类面具的人的编号，戴第 $k$ 类面具的人能看到戴第 $1$ 类面具的人的编号。\n\n参加舞会的人并不知道有多少类面具，但是栋栋对此却特别好奇，他想自己算出有多少类面具，于是他开始在人群中收集信息。\n\n栋栋收集的信息都是戴第几号面具的人看到了第几号面具的编号。如戴第 $2$ 号面具的人看到了第 $5$ 号面具的编号。栋栋自己也会看到一些编号，他也会根据自己的面具编号把信息补充进去。\n\n由于并不是每个人都能记住自己所看到的全部编号，因此，栋栋收集的信息不能保证其完整性。现在请你计算，按照栋栋目前得到的信息，至多和至少有多少类面具。由于主办方已经声明了 $k\\geq 3$，所以你必须将这条信息也考虑进去。\n", "inputFormat": "第一行包含两个整数 $n, m$，用一个空格分隔，$n$ 表示主办方总共准备了多少个面具，$m$ 表示栋栋收集了多少条信息。接下来 $m$ 行，每行为两个用空格分开的整数 $a, b$，表示戴第 $a$ 号面具的人看到了第 $b$ 号面具的编号。相同的数对 $a, b$ 在输入文件中可能出现多次。\n", "outputFormat": "包含两个数，第一个数为最大可能的面具类数，第二个数为最小可能的面具类数。如果无法将所有的面具分为至少 $3$ 类，使得这些信息都满足，则认为栋栋收集的信息有错误，输出两个 `-1`。\n", "hint": "- 对于 $50\\%$ 的数据，满足 $n \\leq 300$，$m \\leq 10^3$；\n- 对于 $100\\%$ 的数据，满足 $n \\leq 10^5$，$m \\leq 10^6$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2008] Masquerade", "background": "", "description": "The annual masquerade has begun, and Dongdong is excited to attend this year’s party.\n\nThis year’s masks are specially made by the organizers. Each participant can choose a mask they like upon entry. Every mask has an ID number, and the organizer tells the wearer that number.\n\nTo add mystery, the organizer divides masks into $k$ classes ($k \\geq 3$). Using special techniques, the number of each mask is marked so that only people wearing a class $i$ mask can see the numbers of people wearing class $i+1$ masks, and people wearing class $k$ masks can see the numbers of people wearing class $1$ masks.\n\nParticipants do not know how many classes there are, but Dongdong is very curious and wants to figure it out himself, so he starts collecting information from the crowd.\n\nThe information Dongdong collects is of the form: “the wearer of mask number $a$ saw the number of mask $b$.” For example, the wearer of mask $2$ saw the number of mask $5$. Dongdong also sees some numbers himself, and he adds the corresponding information using his own mask number.\n\nSince not everyone can remember all the numbers they saw, Dongdong’s collected information may be incomplete. Please compute, based on the information Dongdong currently has, the maximum and the minimum possible numbers of mask classes. Since the organizer has declared $k \\geq 3$, you must also take this into account.", "inputFormat": "The first line contains two integers $n, m$, separated by a space, where $n$ is the total number of masks prepared by the organizer, and $m$ is the number of pieces of information Dongdong collected. The next $m$ lines each contain two integers $a, b$ separated by a space, meaning the wearer of mask $a$ saw the number of mask $b$. The same pair $a, b$ may appear multiple times in the input.", "outputFormat": "Output two numbers: the first is the maximum possible number of mask classes, and the second is the minimum possible number of mask classes. If it is impossible to partition all masks into at least $3$ classes so that all the information is satisfied, print two `-1`.", "hint": "- For $50\\%$ of the testdata, $n \\leq 300$, $m \\leq 10^3$.\n- For $100\\%$ of the testdata, $n \\leq 10^5$, $m \\leq 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2008] 假面舞会", "background": "", "description": "一年一度的假面舞会又开始了，栋栋也兴致勃勃的参加了今年的舞会。\n\n今年的面具都是主办方特别定制的。每个参加舞会的人都可以在入场时选择一个自己喜欢的面具。每个面具都有一个编号，主办方会把此编号告诉拿该面具的人。\n\n为了使舞会更有神秘感，主办方把面具分为 $k$（$k\\geq 3$）类，并使用特殊的技术将每个面具的编号标在了面具上，只有戴第 $i$ 类面具的人才能看到戴第 $i+1$  类面具的人的编号，戴第 $k$ 类面具的人能看到戴第 $1$ 类面具的人的编号。\n\n参加舞会的人并不知道有多少类面具，但是栋栋对此却特别好奇，他想自己算出有多少类面具，于是他开始在人群中收集信息。\n\n栋栋收集的信息都是戴第几号面具的人看到了第几号面具的编号。如戴第 $2$ 号面具的人看到了第 $5$ 号面具的编号。栋栋自己也会看到一些编号，他也会根据自己的面具编号把信息补充进去。\n\n由于并不是每个人都能记住自己所看到的全部编号，因此，栋栋收集的信息不能保证其完整性。现在请你计算，按照栋栋目前得到的信息，至多和至少有多少类面具。由于主办方已经声明了 $k\\geq 3$，所以你必须将这条信息也考虑进去。\n", "inputFormat": "第一行包含两个整数 $n, m$，用一个空格分隔，$n$ 表示主办方总共准备了多少个面具，$m$ 表示栋栋收集了多少条信息。接下来 $m$ 行，每行为两个用空格分开的整数 $a, b$，表示戴第 $a$ 号面具的人看到了第 $b$ 号面具的编号。相同的数对 $a, b$ 在输入文件中可能出现多次。\n", "outputFormat": "包含两个数，第一个数为最大可能的面具类数，第二个数为最小可能的面具类数。如果无法将所有的面具分为至少 $3$ 类，使得这些信息都满足，则认为栋栋收集的信息有错误，输出两个 `-1`。\n", "hint": "- 对于 $50\\%$ 的数据，满足 $n \\leq 300$，$m \\leq 10^3$；\n- 对于 $100\\%$ 的数据，满足 $n \\leq 10^5$，$m \\leq 10^6$。\n", "locale": "zh-CN"}}}
{"pid": "P1478", "type": "P", "difficulty": 2, "samples": [["8 15\n20 130\n120 3\n150 2\n110 7\n180 1\n50 8\n200 0\n140 3\n120 2", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "洛谷原创", "排序", "背包 DP"], "title": "陶陶摘苹果（升级版）", "background": "", "description": "又是一年秋季时，陶陶家的苹果树结了 $n$ 个果子。陶陶又跑去摘苹果，这次他有一个 $a$ 公分的椅子。当他手够不着时，他会站到椅子上再试试。\n\n这次与 NOIp2005 普及组第一题不同的是：陶陶之前搬凳子，力气只剩下 $s$ 了。当然，每次摘苹果时都要用一定的力气。陶陶想知道在 $s<0$ 之前最多能摘到多少个苹果。\n\n现在已知 $n$ 个苹果到达地上的高度 $x_i$，椅子的高度 $a$，陶陶手伸直的最大长度 $b$，陶陶所剩的力气 $s$，陶陶摘一个苹果需要的力气 $y_i$，求陶陶最多能摘到多少个苹果。\n", "inputFormat": "第 $1$ 行：两个数 苹果数 $n$，力气 $s$。\n\n第 $2$ 行：两个数 椅子的高度 $a$，陶陶手伸直的最大长度 $b$。\n\n第 $3$ 行~第 $3+n-1$ 行：每行两个数 苹果高度 $x_i$，摘这个苹果需要的力气 $y_i$。\n", "outputFormat": "只有一个整数，表示陶陶最多能摘到的苹果数。\n", "hint": "对于 $100\\%$ 的数据，$n\\leq 5000$, $a\\leq 50$, $b\\leq 200$, $s\\leq 1000$, $x_i\\leq 280$, $y_i\\leq 100$。\n", "locale": "zh-CN", "translations": {"en": {"title": "TaoTao Picks Apples (Upgraded Version)", "background": "", "description": "It is autumn again, and the apple tree at TaoTao’s home has borne $n$ fruits. TaoTao goes to pick apples; this time he has a chair of height $a$ centimeters. When he cannot reach with his hand, he will stand on the chair and try again.\n\nDifferent from the first problem of NOIp 2005 Junior: after moving the stool earlier, TaoTao has only $s$ strength left. Of course, each time he picks an apple, it costs some strength. TaoTao wants to know the maximum number of apples he can pick before $s < 0$.\n\nNow you are given the heights above the ground of the $n$ apples $x_i$, the chair height $a$, TaoTao’s maximum reach $b$, his remaining strength $s$, and the strength needed to pick each apple $y_i$. Find the maximum number of apples TaoTao can pick.", "inputFormat": "Line 1: two numbers, the number of apples $n$ and the strength $s$.\n\nLine 2: two numbers, the chair height $a$ and TaoTao’s maximum reach $b$.\n\nLines 3 to $3 + n - 1$: each line contains two numbers, the apple height $x_i$ and the strength needed to pick this apple $y_i$.", "outputFormat": "Output a single integer, the maximum number of apples that TaoTao can pick.", "hint": "For $100\\%$ of the testdata, $n \\leq 5000$, $a \\leq 50$, $b \\leq 200$, $s \\leq 1000$, $x_i \\leq 280$, $y_i \\leq 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "陶陶摘苹果（升级版）", "background": "", "description": "又是一年秋季时，陶陶家的苹果树结了 $n$ 个果子。陶陶又跑去摘苹果，这次他有一个 $a$ 公分的椅子。当他手够不着时，他会站到椅子上再试试。\n\n这次与 NOIp2005 普及组第一题不同的是：陶陶之前搬凳子，力气只剩下 $s$ 了。当然，每次摘苹果时都要用一定的力气。陶陶想知道在 $s<0$ 之前最多能摘到多少个苹果。\n\n现在已知 $n$ 个苹果到达地上的高度 $x_i$，椅子的高度 $a$，陶陶手伸直的最大长度 $b$，陶陶所剩的力气 $s$，陶陶摘一个苹果需要的力气 $y_i$，求陶陶最多能摘到多少个苹果。\n", "inputFormat": "第 $1$ 行：两个数 苹果数 $n$，力气 $s$。\n\n第 $2$ 行：两个数 椅子的高度 $a$，陶陶手伸直的最大长度 $b$。\n\n第 $3$ 行~第 $3+n-1$ 行：每行两个数 苹果高度 $x_i$，摘这个苹果需要的力气 $y_i$。\n", "outputFormat": "只有一个整数，表示陶陶最多能摘到的苹果数。\n", "hint": "对于 $100\\%$ 的数据，$n\\leq 5000$, $a\\leq 50$, $b\\leq 200$, $s\\leq 1000$, $x_i\\leq 280$, $y_i\\leq 100$。\n", "locale": "zh-CN"}}}
{"pid": "P1479", "type": "P", "difficulty": 2, "samples": [["11", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索"], "title": "宿舍里的故事之五子棋", "background": "", "description": "宿舍里好多好多有趣的事！\n\n7890653 今天看到不知何时流行的五子棋，在宿舍里拿个本子，画一些格子，一个棋盘就做好了。\n\n当 7890653 把目光放到棋上，突发奇想……\n\n在一个 $5 \\times 5$ 的棋盘内，放上 $n$ 颗棋子，其中 $5 \\le n \\le 25$；\n\n这 $n$ 颗棋子可以放到棋盘内任意一个地方，但是不能重叠在一起。于是，便会有五颗棋子排成一行，或一列，或处在同一条对角线上。不同的放法可能会出现不同个数的五子的排列。\n\n本题你要做的是，给你一个 $n$，你要找出不同放法出现的五子连线的数量（设为 $k$），如 $n=11$，有：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rcwazq5o.png)\n\n只有这两种非负的 $k$ 值，（注意 $k$ 不重复），你要输出的便是 $k$ 值的和。\n\n也就是 $1+2=3$。", "inputFormat": "输入共一行一个数 $n$，含义如题意所示。保证 $1\\le n\\le 25$。", "outputFormat": "输出所有可能的 $k$ 值的和。容易发现 $k\\le 12$。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Stories in the Dormitory: Gomoku", "background": "", "description": "There are lots and lots of fun things in the dormitory!\n\nToday 7890653 saw Gomoku, which had unknowingly become popular. In the dorm, they took a notebook, drew some squares, and a board was ready.\n\nWhen 7890653 looked at the board, an idea came to mind...\n\nOn a $5 \\times 5$ board, place $n$ stones, where $5 \\le n \\le 25$; the $n$ stones can be placed anywhere on the board, but they cannot overlap. Thus, there may be five stones forming a row, a column, or lying on the same diagonal. Different placements may produce different numbers of five-in-a-row lines.\n\nYour task: given $n$, find all possible counts $k$ of five-in-a-row lines that can appear over different placements (counting full lines among the 5 rows, 5 columns, and 2 diagonals). For example, when $n = 11$, we have:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rcwazq5o.png)\n\nOnly these two nonnegative $k$ values occur (note that $k$ values are not repeated). You should output the sum of these distinct $k$ values.\n\nThat is, $1 + 2 = 3$.", "inputFormat": "The input contains one line with a single integer $n$, as described. Guaranteed $1 \\le n \\le 25$.", "outputFormat": "Output the sum of all possible $k$ values. It is easy to see that $k \\le 12$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "宿舍里的故事之五子棋", "background": "", "description": "宿舍里好多好多有趣的事！\n\n7890653 今天看到不知何时流行的五子棋，在宿舍里拿个本子，画一些格子，一个棋盘就做好了。\n\n当 7890653 把目光放到棋上，突发奇想……\n\n在一个 $5 \\times 5$ 的棋盘内，放上 $n$ 颗棋子，其中 $5 \\le n \\le 25$；\n\n这 $n$ 颗棋子可以放到棋盘内任意一个地方，但是不能重叠在一起。于是，便会有五颗棋子排成一行，或一列，或处在同一条对角线上。不同的放法可能会出现不同个数的五子的排列。\n\n本题你要做的是，给你一个 $n$，你要找出不同放法出现的五子连线的数量（设为 $k$），如 $n=11$，有：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rcwazq5o.png)\n\n只有这两种非负的 $k$ 值，（注意 $k$ 不重复），你要输出的便是 $k$ 值的和。\n\n也就是 $1+2=3$。", "inputFormat": "输入共一行一个数 $n$，含义如题意所示。保证 $1\\le n\\le 25$。", "outputFormat": "输出所有可能的 $k$ 值的和。容易发现 $k\\le 12$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1480", "type": "P", "difficulty": 2, "samples": [["10\n2", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "高精度"], "title": "A/B Problem（高精度除法Ⅰ）", "background": "", "description": "输入两个整数 $a,b$，输出它们的商。\n", "inputFormat": "两行，第一行是被除数，第二行是除数。\n", "outputFormat": "一行，商的整数部分。\n", "hint": "$0\\le a\\le 10^{5000}$，$1\\le b\\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "A/B Problem(High-Precision DivisionⅠ)", "background": "", "description": "Given two integers $a, b$, output their quotient.", "inputFormat": "Two lines. The first line is the dividend, the second line is the divisor.", "outputFormat": "One line: the integer part of the quotient.", "hint": "$0\\le a\\le 10^{5000}$, $1\\le b\\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "A/B Problem（高精度除法Ⅰ）", "background": "", "description": "输入两个整数 $a,b$，输出它们的商。\n", "inputFormat": "两行，第一行是被除数，第二行是除数。\n", "outputFormat": "一行，商的整数部分。\n", "hint": "$0\\le a\\le 10^{5000}$，$1\\le b\\le 10^9$。", "locale": "zh-CN"}}}
