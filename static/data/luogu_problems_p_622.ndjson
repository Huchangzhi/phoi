{"pid": "P13616", "type": "P", "difficulty": 6, "samples": [["3 2\n0 0\n0 1\n1 0\n1 2 10\n2 3 20", "20"], ["3 3\n0 0\n0 1\n1 0\n1 2 10\n2 3 20\n1 3 30", "60"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "ICPC"], "title": "[ICPC 2024 APC]  Attraction Score", "background": "", "description": "在虚构的国家 Manteiv，有 $n$ 个城市，编号从 $1$ 到 $n$。我们可以将这些城市视为在一个二维坐标系的平面上，其中城市 $i$ 的坐标为 $(x_i, y_i)$。没有两个城市位于相同的位置。\n\n这里有 $m$ 条高速公路，编号从 $1$ 到 $m$，每条高速公路都是以两个不同的城市为其端点的线段，并且沿线设有一定数量的景点。具体来说，高速公路 $j$ 有 $a_j$ 个景点，并连接城市 $u_j$ 和 $v_j$ 作为其端点。由于高速公路上的交叉路口会导致交通堵塞，且在另一条高速公路上方建造新的高速公路成本高昂，因此题目保证：\n* 任意两条高速公路除了在城市作为端点外，不会在任何其他点相交。\n* 任意一条高速公路除了其两个端点城市外，不会穿过任何其他城市。\n* 每对城市之间最多只有一条高速公路相连。\n\nManteiv 旅游部希望选择一个城市子集作为旅游景点。直观地说，旅游部希望所选城市中有许多对城市由景点众多的高速公路相连。形式上，一个非空城市子集 $S$ 的吸引力分数定义如下：\n\n* 对于每一对整数 $(a, b)$，如果 $a < b$，城市 $a$ 和城市 $b$ 都在 $S$ 中，并且它们之间有高速公路相连，则将该高速公路的景点数加到分数中。\n* 令 $f(S)$ 为满足 $a < b$ 的整数对 $(a, b)$ 的数量，其中城市 $a$ 和城市 $b$ 都在 $S$ 中，但它们之间没有高速公路相连。分数会产生一个惩罚（负）分数，大小为 $10^6$ 乘以 $f(S)$ 的平方。换句话说，从分数中减去 $10^6 \\times f(S)^2$。\n\n例如，假设 $n=3$，城市 $1$ 和 $2$ 由一条有 $10$ 个景点的高速公路连接，城市 $2$ 和 $3$ 由一条有 $20$ 个景点的高速公路连接，而城市 $1$ 和 $3$ 之间没有高速公路。\n- 城市子集 $\\{1\\}$ 的吸引力分数为 $0$。\n- 城市子集 $\\{1,2\\}$ 的吸引力分数为 $10 - 10^6 \\times 0^2 = 10$。\n- 城市子集 $\\{2,3\\}$ 的吸引力分数为 $20 - 10^6 \\times 0^2 = 20$。\n- 城市子集 $\\{1,2,3\\}$ 的吸引力分数为 $10 + 20 - 10^6 \\times 1^2 = -999970$。\n\n作为旅游部的顾问，您需要找到所有可能的非空城市子集 $S$ 中最大的吸引力分数。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $m$ ($1 \\le n \\le 100,000; 0 \\le m \\le 300,000$)。\n\n接下来的 $n$ 行，每行包含两个整数。第 $i$ 行包含 $x_i$ 和 $y_i$ $(0 \\le x_i, y_i \\le 10^9)$。\n\n再接下来的 $m$ 行，每行包含三个整数。第 $j$ 行包含 $u_j$，$v_j$ 和 $a_j$ $(1 \\le u_j < v_j \\le n; 0 \\le a_j \\le 10^6)$。\n\n保证所有高速公路都满足题目描述中的条件。", "outputFormat": "输出一个整数，代表所有可能的非空城市子集 $S$ 中最大的吸引力分数。", "hint": "**样例解释 #1**\n\n该样例即为题目描述中给出的例子。城市子集 $\\{2,3\\}$ 得到了最高的吸引力分数 $20$。\n\n**样例解释 #2**\n\n城市和高速公路如图 B.1 所示。通过在 $S$ 中选择城市 $1, 2, 3$，吸引力分数为 $10 + 20 + 30 - 10^6 \\times 0^2 = 60$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8hds9s7r.png)\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 APC]  Attraction Score", "background": "", "description": "在虚构的国家 Manteiv，有 $n$ 个城市，编号从 $1$ 到 $n$。我们可以将这些城市视为在一个二维坐标系的平面上，其中城市 $i$ 的坐标为 $(x_i, y_i)$。没有两个城市位于相同的位置。\n\n这里有 $m$ 条高速公路，编号从 $1$ 到 $m$，每条高速公路都是以两个不同的城市为其端点的线段，并且沿线设有一定数量的景点。具体来说，高速公路 $j$ 有 $a_j$ 个景点，并连接城市 $u_j$ 和 $v_j$ 作为其端点。由于高速公路上的交叉路口会导致交通堵塞，且在另一条高速公路上方建造新的高速公路成本高昂，因此题目保证：\n* 任意两条高速公路除了在城市作为端点外，不会在任何其他点相交。\n* 任意一条高速公路除了其两个端点城市外，不会穿过任何其他城市。\n* 每对城市之间最多只有一条高速公路相连。\n\nManteiv 旅游部希望选择一个城市子集作为旅游景点。直观地说，旅游部希望所选城市中有许多对城市由景点众多的高速公路相连。形式上，一个非空城市子集 $S$ 的吸引力分数定义如下：\n\n* 对于每一对整数 $(a, b)$，如果 $a < b$，城市 $a$ 和城市 $b$ 都在 $S$ 中，并且它们之间有高速公路相连，则将该高速公路的景点数加到分数中。\n* 令 $f(S)$ 为满足 $a < b$ 的整数对 $(a, b)$ 的数量，其中城市 $a$ 和城市 $b$ 都在 $S$ 中，但它们之间没有高速公路相连。分数会产生一个惩罚（负）分数，大小为 $10^6$ 乘以 $f(S)$ 的平方。换句话说，从分数中减去 $10^6 \\times f(S)^2$。\n\n例如，假设 $n=3$，城市 $1$ 和 $2$ 由一条有 $10$ 个景点的高速公路连接，城市 $2$ 和 $3$ 由一条有 $20$ 个景点的高速公路连接，而城市 $1$ 和 $3$ 之间没有高速公路。\n- 城市子集 $\\{1\\}$ 的吸引力分数为 $0$。\n- 城市子集 $\\{1,2\\}$ 的吸引力分数为 $10 - 10^6 \\times 0^2 = 10$。\n- 城市子集 $\\{2,3\\}$ 的吸引力分数为 $20 - 10^6 \\times 0^2 = 20$。\n- 城市子集 $\\{1,2,3\\}$ 的吸引力分数为 $10 + 20 - 10^6 \\times 1^2 = -999970$。\n\n作为旅游部的顾问，您需要找到所有可能的非空城市子集 $S$ 中最大的吸引力分数。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $m$ ($1 \\le n \\le 100,000; 0 \\le m \\le 300,000$)。\n\n接下来的 $n$ 行，每行包含两个整数。第 $i$ 行包含 $x_i$ 和 $y_i$ $(0 \\le x_i, y_i \\le 10^9)$。\n\n再接下来的 $m$ 行，每行包含三个整数。第 $j$ 行包含 $u_j$，$v_j$ 和 $a_j$ $(1 \\le u_j < v_j \\le n; 0 \\le a_j \\le 10^6)$。\n\n保证所有高速公路都满足题目描述中的条件。", "outputFormat": "输出一个整数，代表所有可能的非空城市子集 $S$ 中最大的吸引力分数。", "hint": "**样例解释 #1**\n\n该样例即为题目描述中给出的例子。城市子集 $\\{2,3\\}$ 得到了最高的吸引力分数 $20$。\n\n**样例解释 #2**\n\n城市和高速公路如图 B.1 所示。通过在 $S$ 中选择城市 $1, 2, 3$，吸引力分数为 $10 + 20 + 30 - 10^6 \\times 0^2 = 60$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8hds9s7r.png)\n", "locale": "zh-CN"}}}
{"pid": "P13617", "type": "P", "difficulty": 5, "samples": [["4\n5\n3 3 4 1 2\n3\n2 1 2\n2\n60 60\n2\n8 0", "13\n3\n2305843009213693949\n-1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "位运算", "构造", "ICPC"], "title": "[ICPC 2024 APC] Bit Counting Sequence", "background": "", "description": "对于一个非负整数 $x$，令 $p(x)$ 为 $x$ 的二进制表示中 1 的个数。例如，$p(26)=3$，因为 $26=(11010)_2$。\n\n给定一个包含 $n$ 个整数的序列 $(a_1, a_2, ..., a_n)$。你的任务是判断是否存在一个非负整数 $x$，使得序列 $(p(x), p(x+1), ..., p(x+n-1))$ 与 $(a_1, a_2, ..., a_n)$ 相等。此外，如果存在，你需要计算满足条件的最小的 $x$。", "inputFormat": "输入的第一行包含一个整数 $t (1 \\le t \\le 1000)$，代表测试用例的数量。之后是 $t$ 个测试用例。每个测试用例的格式如下。\n\n第一行包含一个整数 $n (1 \\le n \\le 500,000)$。\n第二行包含 $n$ 个整数 $a_1, a_2, ..., a_n(0 \\le a_i \\le 60)$。\n\n在单个输入文件中，所有测试用例的 $n$ 的总和不超过 $500,000$。", "outputFormat": "对于每个测试用例，输出满足上述条件的最小非负整数 $x$。如果不存在这样的 $x$，则输出 $-1$。", "hint": "**样例解释 #1**\n\n对于第一个测试用例，$x=13$ 满足上述条件，因为 $(p(13), p(14), p(15), p(16), p(17))=(3, 3, 4, 1, 2)$。可以证明，不存在比 $13$ 更小的非负整数满足上述条件。\n\n翻译由 Gemini 2.5 Pro 完成。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 APC] Bit Counting Sequence", "background": "", "description": "对于一个非负整数 $x$，令 $p(x)$ 为 $x$ 的二进制表示中 1 的个数。例如，$p(26)=3$，因为 $26=(11010)_2$。\n\n给定一个包含 $n$ 个整数的序列 $(a_1, a_2, ..., a_n)$。你的任务是判断是否存在一个非负整数 $x$，使得序列 $(p(x), p(x+1), ..., p(x+n-1))$ 与 $(a_1, a_2, ..., a_n)$ 相等。此外，如果存在，你需要计算满足条件的最小的 $x$。", "inputFormat": "输入的第一行包含一个整数 $t (1 \\le t \\le 1000)$，代表测试用例的数量。之后是 $t$ 个测试用例。每个测试用例的格式如下。\n\n第一行包含一个整数 $n (1 \\le n \\le 500,000)$。\n第二行包含 $n$ 个整数 $a_1, a_2, ..., a_n(0 \\le a_i \\le 60)$。\n\n在单个输入文件中，所有测试用例的 $n$ 的总和不超过 $500,000$。", "outputFormat": "对于每个测试用例，输出满足上述条件的最小非负整数 $x$。如果不存在这样的 $x$，则输出 $-1$。", "hint": "**样例解释 #1**\n\n对于第一个测试用例，$x=13$ 满足上述条件，因为 $(p(13), p(14), p(15), p(16), p(17))=(3, 3, 4, 1, 2)$。可以证明，不存在比 $13$ 更小的非负整数满足上述条件。\n\n翻译由 Gemini 2.5 Pro 完成。", "locale": "zh-CN"}}}
{"pid": "P13618", "type": "P", "difficulty": 7, "samples": [["6 7", "780136139"], ["12 14", "22889737"], ["12 42", "96403614"], ["42 14", "94940316"]], "limits": {"time": [15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "ICPC"], "title": "[ICPC 2024 APC] Bánh Bò", "background": "*自从地球被毁灭后，Trillian 一直很想念一些地球上的美食。今天，她让飞船的食物制造机为她生成了一道她曾经很喜欢的越南美食：* bánh bò hấp *（一种蒸制的耐嚼海绵蛋糕）。*", "description": "Trillian 有无限多个 *bánh bò hấp*。每一个 *bánh bò hấp* 要么是*红色*的，要么是*白色*的。她想将 $rc$ 个 *bánh bò hấp* 组装成一个 $r \\times c$ 的网格，每个单元格中包含一个 *bánh bò hấp*。因此，总共有 $2^{rc}$ 种不同的方式来将 *bánh bò hấp* 组装成一个 $r \\times c$ 的网格，因为我们视颜色相同的糕点为完全相同。\n\n我们称一个 *bánh bò hấp* 的组装是*均匀的*，如果所有 $6 \\times 7$ 的子网格都含有相同数量的红色糕点。因此，在一个均匀的 *bánh bò hấp* 组装中，所有 $6 \\times 7$ 的子网格也同样含有相同数量的白色糕点。请注意，一个 $r \\times c$ 的网格有 $(r-5)(c-6)$ 个尺寸为 $6 \\times 7$ 的子网格。\n\n例如，图 D.1 展示了一个 $7 \\times 8$ 的 *bánh bò hấp* 均匀组装，其中阴影单元格代表红色 *bánh bò hấp*，而未着色单元格代表白色 *bánh bò hấp*。图 D.2 显示，所有四个 $6 \\times 7$ 的子网格都含有 6 个红色糕点和 36 个白色糕点。\n\n给定 $r$ 和 $c$，其中 $r$ 是 $6$ 的倍数，$c$ 是 $7$ 的倍数，Trillian 希望计算可能的均匀 *bánh bò hấp* 组装方案数，结果对 $998,244,353$ 取模。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/okmxoq7j.png)", "inputFormat": "输入只包含一行，内含两个整数 $r$ 和 $c$（$6 \\le r \\le 666,666$，$r$ 是 $6$ 的倍数；$7 \\le c \\le 777,777$，$c$ 是 $7$ 的倍数）。", "outputFormat": "输出可能的均匀 *bánh bò hấp* 组装方案数，结果对 $998,244,353$ 取模。", "hint": "**样例解释 #1**\n\n输出为 $2^{42}$ 对 $998,244,353$ 取模的结果。\n\n\n翻译由 Gemini 2.5 Pro 完成。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 APC] Bánh Bò", "background": "*自从地球被毁灭后，Trillian 一直很想念一些地球上的美食。今天，她让飞船的食物制造机为她生成了一道她曾经很喜欢的越南美食：* bánh bò hấp *（一种蒸制的耐嚼海绵蛋糕）。*", "description": "Trillian 有无限多个 *bánh bò hấp*。每一个 *bánh bò hấp* 要么是*红色*的，要么是*白色*的。她想将 $rc$ 个 *bánh bò hấp* 组装成一个 $r \\times c$ 的网格，每个单元格中包含一个 *bánh bò hấp*。因此，总共有 $2^{rc}$ 种不同的方式来将 *bánh bò hấp* 组装成一个 $r \\times c$ 的网格，因为我们视颜色相同的糕点为完全相同。\n\n我们称一个 *bánh bò hấp* 的组装是*均匀的*，如果所有 $6 \\times 7$ 的子网格都含有相同数量的红色糕点。因此，在一个均匀的 *bánh bò hấp* 组装中，所有 $6 \\times 7$ 的子网格也同样含有相同数量的白色糕点。请注意，一个 $r \\times c$ 的网格有 $(r-5)(c-6)$ 个尺寸为 $6 \\times 7$ 的子网格。\n\n例如，图 D.1 展示了一个 $7 \\times 8$ 的 *bánh bò hấp* 均匀组装，其中阴影单元格代表红色 *bánh bò hấp*，而未着色单元格代表白色 *bánh bò hấp*。图 D.2 显示，所有四个 $6 \\times 7$ 的子网格都含有 6 个红色糕点和 36 个白色糕点。\n\n给定 $r$ 和 $c$，其中 $r$ 是 $6$ 的倍数，$c$ 是 $7$ 的倍数，Trillian 希望计算可能的均匀 *bánh bò hấp* 组装方案数，结果对 $998,244,353$ 取模。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/okmxoq7j.png)", "inputFormat": "输入只包含一行，内含两个整数 $r$ 和 $c$（$6 \\le r \\le 666,666$，$r$ 是 $6$ 的倍数；$7 \\le c \\le 777,777$，$c$ 是 $7$ 的倍数）。", "outputFormat": "输出可能的均匀 *bánh bò hấp* 组装方案数，结果对 $998,244,353$ 取模。", "hint": "**样例解释 #1**\n\n输出为 $2^{42}$ 对 $998,244,353$ 取模的结果。\n\n\n翻译由 Gemini 2.5 Pro 完成。", "locale": "zh-CN"}}}
{"pid": "P13619", "type": "P", "difficulty": 3, "samples": [["5\n4\n3 2 1 1\n2 1 3 4\n1 3 3 1\n4 4 4 2\n3\n1 3 1\n2 1 3\n3 2 2\n5\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n1 1 1 1 1\n3\n1 1 2\n2 2 1\n2 3 2\n3\n1 1 3\n3 2 1\n3 1 3", "2\n2 1 1\n4 2 3\n3\n2 1 3\n2 2 3\n3 3 3\n0\n1\n1 2 2\n1\n2 1 1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2024", "Special Judge", "构造", "ICPC"], "title": "[ICPC 2024 APC] Duplicates", "background": "", "description": "我们称一个数字序列**含有重复元素**，如果序列中存在出现一次以上的元素。形式化地讲，一个序列 $(a_1, \\dots, a_n)$ 含有重复元素，如果存在两个不等的下标 $i$ 和 $j$ 使得 $a_i = a_j$。\n\n给定一个 $n \\times n$ 的矩阵 $X$。$X$ 中的每个元素都是一个 $1$ 到 $n$ 之间（含两端）的整数。你可以将 $X$ 中零个或多个元素修改为 $1$ 到 $n$ 之间（含两端）的任意整数。不同的元素可以修改为不同的整数。\n\n你的任务是通过修改 $X$ 中的元素，使得以下所有条件都成立：\n\n* 对于每一行 $i$，序列 $(X_{i1}, X_{i2}, \\dots, X_{in})$ 含有重复元素。\n* 对于每一列 $j$，序列 $(X_{1j}, X_{2j}, \\dots, X_{nj})$ 含有重复元素。\n\n你需要计算达成此目标所需的**最小**修改次数。同时，找出一种可行的修改方案。对于每次修改，你需要指明修改的是哪个元素以及它的新值。请注意，当给定的矩阵 $X$ 已经满足上述条件时，所需的最小修改次数可以为零。", "inputFormat": "输入的第一行包含一个整数 $t$（$1 \\le t \\le 1000$），代表测试用例的数量。之后是 $t$ 个测试用例。每个测试用例的格式如下。\n\n一个测试用例的第一行包含一个整数 $n$（$3 \\le n \\le 100$）。\n接下来的 $n$ 行，每行包含 $n$ 个整数。第 $i$ 行的第 $j$ 个整数代表 $X_{ij}$（$1 \\le X_{ij} \\le n$）。\n\n在单个输入文件中，所有测试用例的 $n^2$ 的总和不超过 $10,000$。", "outputFormat": "对于每个测试用例，按以下格式输出一组修改方案。\n\n第一行输出一个整数 $m$，代表需要修改的元素的最小数量。\n在接下来的 $m$ 行中，每行输出三个整数 $i, j, v$。这代表一次修改，即将元素 $X_{ij}$ 的值修改为 $v$。这三个整数都必须在 $1$ 和 $n$ 之间（含两端）。\n\n如果存在多种解法，你可以输出其中任意一种。\n", "hint": "**样例解释 #1**\n\n在第一个测试用例中，修改后的矩阵如下所示。\n\n$$\n\\begin{bmatrix}\n3 & 2 & 1 & 1 \\\\\n1 & 1 & 3 & 4 \\\\\n1 & 3 & 3 & 1 \\\\\n4 & 3 & 4 & 2 \\\\\n\\end{bmatrix}\n$$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 APC] Duplicates", "background": "", "description": "我们称一个数字序列**含有重复元素**，如果序列中存在出现一次以上的元素。形式化地讲，一个序列 $(a_1, \\dots, a_n)$ 含有重复元素，如果存在两个不等的下标 $i$ 和 $j$ 使得 $a_i = a_j$。\n\n给定一个 $n \\times n$ 的矩阵 $X$。$X$ 中的每个元素都是一个 $1$ 到 $n$ 之间（含两端）的整数。你可以将 $X$ 中零个或多个元素修改为 $1$ 到 $n$ 之间（含两端）的任意整数。不同的元素可以修改为不同的整数。\n\n你的任务是通过修改 $X$ 中的元素，使得以下所有条件都成立：\n\n* 对于每一行 $i$，序列 $(X_{i1}, X_{i2}, \\dots, X_{in})$ 含有重复元素。\n* 对于每一列 $j$，序列 $(X_{1j}, X_{2j}, \\dots, X_{nj})$ 含有重复元素。\n\n你需要计算达成此目标所需的**最小**修改次数。同时，找出一种可行的修改方案。对于每次修改，你需要指明修改的是哪个元素以及它的新值。请注意，当给定的矩阵 $X$ 已经满足上述条件时，所需的最小修改次数可以为零。", "inputFormat": "输入的第一行包含一个整数 $t$（$1 \\le t \\le 1000$），代表测试用例的数量。之后是 $t$ 个测试用例。每个测试用例的格式如下。\n\n一个测试用例的第一行包含一个整数 $n$（$3 \\le n \\le 100$）。\n接下来的 $n$ 行，每行包含 $n$ 个整数。第 $i$ 行的第 $j$ 个整数代表 $X_{ij}$（$1 \\le X_{ij} \\le n$）。\n\n在单个输入文件中，所有测试用例的 $n^2$ 的总和不超过 $10,000$。", "outputFormat": "对于每个测试用例，按以下格式输出一组修改方案。\n\n第一行输出一个整数 $m$，代表需要修改的元素的最小数量。\n在接下来的 $m$ 行中，每行输出三个整数 $i, j, v$。这代表一次修改，即将元素 $X_{ij}$ 的值修改为 $v$。这三个整数都必须在 $1$ 和 $n$ 之间（含两端）。\n\n如果存在多种解法，你可以输出其中任意一种。\n", "hint": "**样例解释 #1**\n\n在第一个测试用例中，修改后的矩阵如下所示。\n\n$$\n\\begin{bmatrix}\n3 & 2 & 1 & 1 \\\\\n1 & 1 & 3 & 4 \\\\\n1 & 3 & 3 & 1 \\\\\n4 & 3 & 4 & 2 \\\\\n\\end{bmatrix}\n$$", "locale": "zh-CN"}}}
{"pid": "P13620", "type": "P", "difficulty": 4, "samples": [["2\n4 1\n2 1 2\n3 10\n4 3", "1 1\n10 3\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "ICPC"], "title": "[ICPC 2024 APC] Forming Groups", "background": "", "description": "有 $n$ 名学生，编号从 $1$ 到 $n$，他们需要为即将到来的黑客马拉松分组。你是学生 $1$，担任队长。学生 $i$ 的技能水平为 $a_i$。学生 $2$ 到 $n$ 按顺序从左到右站成一排。你可以选择站在任意两名学生之间，或者站在学生 $2$ 的左边，或者站在学生 $n$ 的右边。你不能改变这 $n-1$ 名学生的相对顺序。\n\n你还需要选择分组的数量 $k$（$k > 1$ 且 $k$ 必须是 $n$ 的约数）来参加黑客马拉松。小组编号为 $1$ 到 $k$。在你选定自己的位置和 $k$ 的值之后，学生将按如下方式分组：\n\n* 从左数第一名学生将被分到第 $1$ 组。\n* 从左数第二名学生将被分到第 $2$ 组。\n* ...\n* 从左数第 $k$ 名学生将被分到第 $k$ 组。\n* 从左数第 $(k+1)$ 名学生将被分到第 $1$ 组。\n* 从左数第 $(k+2)$ 名学生将被分到第 $2$ 组。\n* ...\n* 从左数第 $n$ 名学生将被分到第 $k$ 组。\n\n形式化地说，对于每个 $j$（$1 \\le j \\le k$）和每个 $i$（$0 \\le i < n/k$），从左数第 $(i \\times k + j)$ 名学生将被分到第 $j$ 组。可以证明，每名学生都将被分到恰好一个小组，且所有小组的学生人数相同。\n\n一个小组的技能水平是组内所有学生技能水平的总和。通过优化选择你站立的位置以及分组数量 $k$，你希望最小化比率 $x_{\\max}/x_{\\min}$，其中\n* $x_{\\max}$ 是技能水平最高的小组的技能水平，\n* $x_{\\min}$ 是技能水平最低的小组的技能水平。", "inputFormat": "输入的第一行包含一个整数 $t (1 \\le t \\le 100,000)$，代表测试用例的数量。之后是 $t$ 个测试用例。每个测试用例的格式如下。\n\n一个测试用例的第一行包含两个整数 $n$ 和 $a_1$ ($2 \\le n \\le 10^6$; $1 \\le a_1 \\le 1000$)。\n下一行包含 $n-1$ 个整数 $a_2, a_3, \\dots, a_n$（对于所有的 $i$，$1 \\le a_i \\le 1000$）。\n\n在单个输入文件中，所有测试用例的 $n$ 的总和不超过 $10^6$。", "outputFormat": "对于每个测试用例，输出一行，包含两个正整数 $p$ 和 $q$，表示最小比率为 $p/q$。分数 $p/q$ 应该是最简分数。即 $p$ 和 $q$ 应该互质。", "hint": "**样例解释 #1**\n\n在第一个测试用例中，通过站在学生 $2$ 和 $3$ 之间（或学生 $3$ 和 $4$ 之间）并选择 $k=2$，第 1 组的技能水平为 $2+1$，第 2 组的技能水平为 $1+2$，因此比率为 $1/1$。\n\n在第二个测试用例中，$k$ 的唯一选择是 $3$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 APC] Forming Groups", "background": "", "description": "有 $n$ 名学生，编号从 $1$ 到 $n$，他们需要为即将到来的黑客马拉松分组。你是学生 $1$，担任队长。学生 $i$ 的技能水平为 $a_i$。学生 $2$ 到 $n$ 按顺序从左到右站成一排。你可以选择站在任意两名学生之间，或者站在学生 $2$ 的左边，或者站在学生 $n$ 的右边。你不能改变这 $n-1$ 名学生的相对顺序。\n\n你还需要选择分组的数量 $k$（$k > 1$ 且 $k$ 必须是 $n$ 的约数）来参加黑客马拉松。小组编号为 $1$ 到 $k$。在你选定自己的位置和 $k$ 的值之后，学生将按如下方式分组：\n\n* 从左数第一名学生将被分到第 $1$ 组。\n* 从左数第二名学生将被分到第 $2$ 组。\n* ...\n* 从左数第 $k$ 名学生将被分到第 $k$ 组。\n* 从左数第 $(k+1)$ 名学生将被分到第 $1$ 组。\n* 从左数第 $(k+2)$ 名学生将被分到第 $2$ 组。\n* ...\n* 从左数第 $n$ 名学生将被分到第 $k$ 组。\n\n形式化地说，对于每个 $j$（$1 \\le j \\le k$）和每个 $i$（$0 \\le i < n/k$），从左数第 $(i \\times k + j)$ 名学生将被分到第 $j$ 组。可以证明，每名学生都将被分到恰好一个小组，且所有小组的学生人数相同。\n\n一个小组的技能水平是组内所有学生技能水平的总和。通过优化选择你站立的位置以及分组数量 $k$，你希望最小化比率 $x_{\\max}/x_{\\min}$，其中\n* $x_{\\max}$ 是技能水平最高的小组的技能水平，\n* $x_{\\min}$ 是技能水平最低的小组的技能水平。", "inputFormat": "输入的第一行包含一个整数 $t (1 \\le t \\le 100,000)$，代表测试用例的数量。之后是 $t$ 个测试用例。每个测试用例的格式如下。\n\n一个测试用例的第一行包含两个整数 $n$ 和 $a_1$ ($2 \\le n \\le 10^6$; $1 \\le a_1 \\le 1000$)。\n下一行包含 $n-1$ 个整数 $a_2, a_3, \\dots, a_n$（对于所有的 $i$，$1 \\le a_i \\le 1000$）。\n\n在单个输入文件中，所有测试用例的 $n$ 的总和不超过 $10^6$。", "outputFormat": "对于每个测试用例，输出一行，包含两个正整数 $p$ 和 $q$，表示最小比率为 $p/q$。分数 $p/q$ 应该是最简分数。即 $p$ 和 $q$ 应该互质。", "hint": "**样例解释 #1**\n\n在第一个测试用例中，通过站在学生 $2$ 和 $3$ 之间（或学生 $3$ 和 $4$ 之间）并选择 $k=2$，第 1 组的技能水平为 $2+1$，第 2 组的技能水平为 $1+2$，因此比率为 $1/1$。\n\n在第二个测试用例中，$k$ 的唯一选择是 $3$。", "locale": "zh-CN"}}}
{"pid": "P13621", "type": "P", "difficulty": 4, "samples": [["3 3 2\nBBC\n..C\n.BC", "1 3"], ["3 3 1\nBBC\n..C\n.BC", "1 2"], ["3 3 3\nBBC\n..C\n.BC", "-1"], ["4 12 2\nGOOD.LUCK.IN\nWINNING.ICPC\nASIA.PACIFIC\nCHAMPIONSHIP", "2 3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "ICPC"], "title": "[ICPC 2024 APC] Personality Test", "background": "", "description": "有 $n$ 名学生正在参加一个包含 $m$ 个问题的人格测试。学生编号为 $1$ 到 $n$，问题编号为 $1$ 到 $m$。对于每个问题，每名学生可以用一个大写拉丁字母（`A`-`Z`）作答，也可以不作答。设 $S_i$ 是一个长度为 $m$ 的字符串，代表学生 $i$ 的答案，其中 $S_i$ 的第 $j$ 个字符如果是一个大写拉丁字母，表示他们回答了问题 $j$；如果是一个句点（`.`），表示他们没有回答。\n\n如果存在一个包含至少 $k$ 个问题的集合，满足以下条件，则两名学生被认为是**相似的**：两名学生都回答了该集合中的所有问题，并且对于该集合中的每个问题，他们的答案都相同。\n\n例如，设 $n=3, m=3, k=2, S_1=$`BBC`$, S_2=$`..C`, 并且 $S_3=$`.BC`。在这个例子中，学生 $1$ 和 $3$ 是相似的，因为他们对问题 $2$ 和 $3$ 的回答相同；而学生 $2$ 和 $3$ 不相似，因为他们仅对问题 $3$ 的回答相同。\n\n你需要找到一对整数 $(a, b)$，满足 $a < b$ 且学生 $a$ 和 $b$ 是相似的；或者确定不存在这样的配对。如果存在多对，请找出 $b$ 最小的那一对。如果仍然存在多对，请找出 $a$ 最大的那一对。", "inputFormat": "输入的第一行包含三个整数 $n$，$m$ 和 $k$ ($2 < n < 5000$; $1 \\le m \\le 3000$; $1 < k < 5$)。\n\n\n接下来的 $n$ 行，每行包含一个长度为 $m$ 的字符串。第 $i$ 行包含字符串 $S_i$。", "outputFormat": "输出一行，包含题目描述中提到的代表相似学生对的整数 $a$ 和 $b$；如果不存在这样的配对，则只输出整数 $-1$。", "hint": "**样例解释 #1**\n\n这就是题目描述中的例子。\n\n**样例解释 #2**\n\n学生 $1$ 和 $2$ 是相似的。\n\n**样例解释 #3**\n\n不存在相似的学生。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 APC] Personality Test", "background": "", "description": "有 $n$ 名学生正在参加一个包含 $m$ 个问题的人格测试。学生编号为 $1$ 到 $n$，问题编号为 $1$ 到 $m$。对于每个问题，每名学生可以用一个大写拉丁字母（`A`-`Z`）作答，也可以不作答。设 $S_i$ 是一个长度为 $m$ 的字符串，代表学生 $i$ 的答案，其中 $S_i$ 的第 $j$ 个字符如果是一个大写拉丁字母，表示他们回答了问题 $j$；如果是一个句点（`.`），表示他们没有回答。\n\n如果存在一个包含至少 $k$ 个问题的集合，满足以下条件，则两名学生被认为是**相似的**：两名学生都回答了该集合中的所有问题，并且对于该集合中的每个问题，他们的答案都相同。\n\n例如，设 $n=3, m=3, k=2, S_1=$`BBC`$, S_2=$`..C`, 并且 $S_3=$`.BC`。在这个例子中，学生 $1$ 和 $3$ 是相似的，因为他们对问题 $2$ 和 $3$ 的回答相同；而学生 $2$ 和 $3$ 不相似，因为他们仅对问题 $3$ 的回答相同。\n\n你需要找到一对整数 $(a, b)$，满足 $a < b$ 且学生 $a$ 和 $b$ 是相似的；或者确定不存在这样的配对。如果存在多对，请找出 $b$ 最小的那一对。如果仍然存在多对，请找出 $a$ 最大的那一对。", "inputFormat": "输入的第一行包含三个整数 $n$，$m$ 和 $k$ ($2 < n < 5000$; $1 \\le m \\le 3000$; $1 < k < 5$)。\n\n\n接下来的 $n$ 行，每行包含一个长度为 $m$ 的字符串。第 $i$ 行包含字符串 $S_i$。", "outputFormat": "输出一行，包含题目描述中提到的代表相似学生对的整数 $a$ 和 $b$；如果不存在这样的配对，则只输出整数 $-1$。", "hint": "**样例解释 #1**\n\n这就是题目描述中的例子。\n\n**样例解释 #2**\n\n学生 $1$ 和 $2$ 是相似的。\n\n**样例解释 #3**\n\n不存在相似的学生。", "locale": "zh-CN"}}}
{"pid": "P13622", "type": "P", "difficulty": 4, "samples": [["4\n11101101\n00\n10001\n10", "5"], ["2\n101010\n010101\n", "6"], ["5\n0000\n11\n0\n00000000\n1", "0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2024", "ICPC"], "title": "[ICPC 2024 APC] Pho Restaurant", "background": "", "description": "您可能知道，越南河粉（pho）是河内最常见的菜肴之一。它包含一种特殊的米粉、肉（通常是牛肉或鸡肉）和葱，浸在美味的汤中。越南人早餐、午餐、晚餐甚至便餐都喜欢吃河粉。对于游客来说，尤其是在河内寒冷的天气里，品尝河粉是必做之事。\n\n你在越南经营一家有 $n$ 张餐桌（编号为 $1$ 到 $n$）的 *phở bò*（牛肉河粉）餐厅。2024 年 ICPC 亚洲及太平洋锦标赛的参赛者们正在您的餐厅里。每位参赛者最初都坐在某张餐桌旁，且每张餐桌最初都至少有一位参赛者。每位参赛者想点两种最著名的河粉之一：*phở tái*（半熟牛肉河粉）或 *phở chín*（全熟牛肉河粉）。餐桌 $i$ 的初始状态由二进制字符串 $S_i$ 表示。$S_i$ 的长度是最初坐在该桌的参赛者人数。如果最初坐在该桌的第 $j$ 位参赛者想点 *phở tái*，则 $S_i$ 的第 $j$ 个字符为 $0$；如果想点 *phở chín*，则为 $1$。\n\n为了便于记录订单，餐厅希望坐在同一桌的参赛者点同样的菜。也就是说，对于每张餐桌，以下至少有一条必须成立：\n* 所有坐在该桌的参赛者都想点 *phở tái*。\n* 所有坐在该桌的参赛者都想点 *phở chín*。\n\n为了满足此要求以及参赛者的订单，您需要将零名或多名参赛者移动到其他餐桌。目标餐桌必须是这 $n$ 张餐桌之一。换句话说，您不能增加新的餐桌。每张餐桌可容纳的参赛者数量没有限制。移动参赛者后，每张餐桌都应满足以下条件：要么该餐桌没有参赛者，要么所有坐在该餐桌的参赛者都点同样的菜。\n\n由于移动参赛者需要时间，您希望计算出需要移动的参赛者的最少人数。", "inputFormat": "输入的第一行包含一个整数 $n$ ($2 \\le n \\le 100,000$)。\n\n接下来的 $n$ 行，每行包含一个二进制字符串。第 $i$ 行包含 $S_i$ ($1 \\le |S_i| \\le 200,000$)。\n\n所有 $i$ 的 $|S_i|$ 的总和不超过 $500,000$。", "outputFormat": "输出一个整数，代表您需要移动的参赛者的最少人数。", "hint": "**样例解释 #1**\n\n你可以移动\n* 最初坐在 1 号桌的第七位参赛者到 3 号桌，\n* 最初坐在 1 号桌的第四位参赛者到 4 号桌，\n* 最初坐在 3 号桌的第一和第五位参赛者到 1 号桌，以及\n* 最初坐在 4 号桌的第一位参赛者到 1 号桌。\n\n这样一来，所有坐在 1 号桌的参赛者点的都是 *phở chín*，而坐在其他桌的参赛者点的都是 *phở tái*。可以证明，无法在移动少于 5 名参赛者的情况下满足要求。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 APC] Pho Restaurant", "background": "", "description": "您可能知道，越南河粉（pho）是河内最常见的菜肴之一。它包含一种特殊的米粉、肉（通常是牛肉或鸡肉）和葱，浸在美味的汤中。越南人早餐、午餐、晚餐甚至便餐都喜欢吃河粉。对于游客来说，尤其是在河内寒冷的天气里，品尝河粉是必做之事。\n\n你在越南经营一家有 $n$ 张餐桌（编号为 $1$ 到 $n$）的 *phở bò*（牛肉河粉）餐厅。2024 年 ICPC 亚洲及太平洋锦标赛的参赛者们正在您的餐厅里。每位参赛者最初都坐在某张餐桌旁，且每张餐桌最初都至少有一位参赛者。每位参赛者想点两种最著名的河粉之一：*phở tái*（半熟牛肉河粉）或 *phở chín*（全熟牛肉河粉）。餐桌 $i$ 的初始状态由二进制字符串 $S_i$ 表示。$S_i$ 的长度是最初坐在该桌的参赛者人数。如果最初坐在该桌的第 $j$ 位参赛者想点 *phở tái*，则 $S_i$ 的第 $j$ 个字符为 $0$；如果想点 *phở chín*，则为 $1$。\n\n为了便于记录订单，餐厅希望坐在同一桌的参赛者点同样的菜。也就是说，对于每张餐桌，以下至少有一条必须成立：\n* 所有坐在该桌的参赛者都想点 *phở tái*。\n* 所有坐在该桌的参赛者都想点 *phở chín*。\n\n为了满足此要求以及参赛者的订单，您需要将零名或多名参赛者移动到其他餐桌。目标餐桌必须是这 $n$ 张餐桌之一。换句话说，您不能增加新的餐桌。每张餐桌可容纳的参赛者数量没有限制。移动参赛者后，每张餐桌都应满足以下条件：要么该餐桌没有参赛者，要么所有坐在该餐桌的参赛者都点同样的菜。\n\n由于移动参赛者需要时间，您希望计算出需要移动的参赛者的最少人数。", "inputFormat": "输入的第一行包含一个整数 $n$ ($2 \\le n \\le 100,000$)。\n\n接下来的 $n$ 行，每行包含一个二进制字符串。第 $i$ 行包含 $S_i$ ($1 \\le |S_i| \\le 200,000$)。\n\n所有 $i$ 的 $|S_i|$ 的总和不超过 $500,000$。", "outputFormat": "输出一个整数，代表您需要移动的参赛者的最少人数。", "hint": "**样例解释 #1**\n\n你可以移动\n* 最初坐在 1 号桌的第七位参赛者到 3 号桌，\n* 最初坐在 1 号桌的第四位参赛者到 4 号桌，\n* 最初坐在 3 号桌的第一和第五位参赛者到 1 号桌，以及\n* 最初坐在 4 号桌的第一位参赛者到 1 号桌。\n\n这样一来，所有坐在 1 号桌的参赛者点的都是 *phở chín*，而坐在其他桌的参赛者点的都是 *phở tái*。可以证明，无法在移动少于 5 名参赛者的情况下满足要求。", "locale": "zh-CN"}}}
{"pid": "P13623", "type": "P", "difficulty": 7, "samples": [["4\n0 0\n10 0\n8 9\n4 9", "90.0"], ["8\n8 10\n2 9\n0 8\n0 2\n2 0\n8 0\n10 2\n10 8", "-1"], ["6\n231 77\n359 20\n829 124\n998 461\n941 735\n879 825", "486567.9669655848"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "Special Judge", "ICPC"], "title": "[ICPC 2024 APC] Symmetric Boundary", "background": "", "description": "对称图形是美丽的，它们也是本题的主题。一个二维平面区域是**凸的**，当且仅当对于区域内的任意一对点 $p$ 和 $q$，连接 $p$ 和 $q$ 的线段完全包含在该区域内。此外，一个二维平面区域是**点对称的**，当且仅当将该区域围绕某个特定点旋转 $180$ 度后，旋转后的区域与原始区域完全重合。\n\n给定一个二维平面上的凸多边形，它有 $n$ 个顶点，按逆时针顺序从 $1$ 到 $n$ 编号。顶点 $i$ 的坐标为 $(x_i, y_i)$。没有三个顶点共线。\n\n请判断是否存在一个凸形的、点对称的区域，其边界包含了所有这 $n$ 个顶点。如果存在一个或多个这样的区域，请计算其中面积最小的区域的面积。", "inputFormat": "输入的第一行包含一个整数 $n$ ($3 \\le n \\le 30$)。\n接下来的 $n$ 行，每行包含两个整数。第 $i$ 行包含 $x_i$ 和 $y_i$ ($0 \\le x_i, y_i \\le 1000$)。\n\n保证给定的多边形是凸的，其顶点按逆时针顺序给出，并且没有三个顶点共线。", "outputFormat": "如果存在一个或多个这样的区域，输出其中的最小面积。输出的相对误差必须在 $10^{-9}$ 以内。\n\n如果不存在这样的区域，则输出 $-1$。", "hint": "**样例解释**\n\n图 I.1 将样例输入中的顶点以黑点的形式展示了出来。对于样例输入 #1 和 #3，阴影部分代表了可能实现的最小面积区域。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/igatyrwx.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 APC] Symmetric Boundary", "background": "", "description": "对称图形是美丽的，它们也是本题的主题。一个二维平面区域是**凸的**，当且仅当对于区域内的任意一对点 $p$ 和 $q$，连接 $p$ 和 $q$ 的线段完全包含在该区域内。此外，一个二维平面区域是**点对称的**，当且仅当将该区域围绕某个特定点旋转 $180$ 度后，旋转后的区域与原始区域完全重合。\n\n给定一个二维平面上的凸多边形，它有 $n$ 个顶点，按逆时针顺序从 $1$ 到 $n$ 编号。顶点 $i$ 的坐标为 $(x_i, y_i)$。没有三个顶点共线。\n\n请判断是否存在一个凸形的、点对称的区域，其边界包含了所有这 $n$ 个顶点。如果存在一个或多个这样的区域，请计算其中面积最小的区域的面积。", "inputFormat": "输入的第一行包含一个整数 $n$ ($3 \\le n \\le 30$)。\n接下来的 $n$ 行，每行包含两个整数。第 $i$ 行包含 $x_i$ 和 $y_i$ ($0 \\le x_i, y_i \\le 1000$)。\n\n保证给定的多边形是凸的，其顶点按逆时针顺序给出，并且没有三个顶点共线。", "outputFormat": "如果存在一个或多个这样的区域，输出其中的最小面积。输出的相对误差必须在 $10^{-9}$ 以内。\n\n如果不存在这样的区域，则输出 $-1$。", "hint": "**样例解释**\n\n图 I.1 将样例输入中的顶点以黑点的形式展示了出来。对于样例输入 #1 和 #3，阴影部分代表了可能实现的最小面积区域。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/igatyrwx.png)", "locale": "zh-CN"}}}
{"pid": "P13624", "type": "P", "difficulty": 5, "samples": [["3 2\n1 2 10\n1 3 5", "30"], ["4 3\n1 2 10\n2 3 5\n3 4 2", "-1"], ["4 4\n1 2 3\n2 4 2\n1 3 3\n3 4 4", "12"], ["3 1\n1 2 1000", "-1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "2024", "最短路", "ICPC"], "title": "[ICPC 2024 APC] There and Back Again", "background": "", "description": "亚太地区有 $n$ 个城市，编号从 $1$ 到 $n$。2024 年 ICPC 亚洲及太平洋锦标赛在河内（即城市 $n$）举行。有 $m$ 条双向道路，编号从 $1$ 到 $m$，连接着一些城市对。道路 $i$ 连接城市 $u_i$ 和 $v_i$，任一方向的旅行时间为 $t_i$。每条道路连接不同的城市，且不同的道路连接不同的城市对。\n\n你居住在城市 $1$。你希望通过一系列道路前往城市 $n$ 参加比赛，然后再通过一系列道路返回城市 $1$。走同一条路线很无聊，所以你希望两次行程的路线是不同的。如果两条路线所经过的**不同道路的集合**是不同的，那么这两条路线就被认为是不同的。\n\n在每次行程中，可以多次经过同一个城市或走同一条道路。在到达目的地城市（即城市 $1$ 或城市 $n$）后，也可以继续行进。行程时间是行程中所经过道路的旅行时间之和。如果一条道路在行程中被多次经过，那么它的旅行时间也会被相应地计算多次。\n\n请确定满足上述要求的两次行程的最小总旅行时间，或者指出无法满足要求。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $m$ $(2 \\le n \\le 100,000; 1 \\le m \\le \\min(\\frac{n(n-1)}{2}, 300,000)$。\n\n接下来的 $m$ 行，每行包含三个整数。第 $i$ 行包含 $u_i,v_i$ 和 $t_i$ $(1 \\le u_i < v_i \\le n; 1 \\le t_i \\le 1000)$。不同的道路连接不同的城市对。", "outputFormat": "输出一个整数，代表满足上述要求的两次行程的最小总旅行时间；如果无法满足要求，则输出 $-1$。", "hint": "**样例解释 #1**\n\n城市和道路如图 J.1 所示。一种可能的最小化总旅行时间的方式如下：\n* 从城市 1 前往城市 3，途经道路 2（连接城市 1 和 3）。行程时间为 $5$。经过的道路集合为 $\\{2\\}$。\n* 从城市 3 前往城市 1，途经道路 2，然后两次经过道路 1（连接城市 1 和 2）。行程时间为 $5+10+10=25$。经过的道路集合为 $\\{1,2\\}$。\n\n可以证明，没有办法以更小的总旅行时间完成两次行程。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zhgjb2k3.png)\n\n**样例解释 #2**\n\n城市和道路如图 J.2 所示。从城市 1 前往城市 4 再返回，两次行程都必须经过所有的道路。因此，无法满足上述要求。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b6kn6lyl.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 APC] There and Back Again", "background": "", "description": "亚太地区有 $n$ 个城市，编号从 $1$ 到 $n$。2024 年 ICPC 亚洲及太平洋锦标赛在河内（即城市 $n$）举行。有 $m$ 条双向道路，编号从 $1$ 到 $m$，连接着一些城市对。道路 $i$ 连接城市 $u_i$ 和 $v_i$，任一方向的旅行时间为 $t_i$。每条道路连接不同的城市，且不同的道路连接不同的城市对。\n\n你居住在城市 $1$。你希望通过一系列道路前往城市 $n$ 参加比赛，然后再通过一系列道路返回城市 $1$。走同一条路线很无聊，所以你希望两次行程的路线是不同的。如果两条路线所经过的**不同道路的集合**是不同的，那么这两条路线就被认为是不同的。\n\n在每次行程中，可以多次经过同一个城市或走同一条道路。在到达目的地城市（即城市 $1$ 或城市 $n$）后，也可以继续行进。行程时间是行程中所经过道路的旅行时间之和。如果一条道路在行程中被多次经过，那么它的旅行时间也会被相应地计算多次。\n\n请确定满足上述要求的两次行程的最小总旅行时间，或者指出无法满足要求。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $m$ $(2 \\le n \\le 100,000; 1 \\le m \\le \\min(\\frac{n(n-1)}{2}, 300,000)$。\n\n接下来的 $m$ 行，每行包含三个整数。第 $i$ 行包含 $u_i,v_i$ 和 $t_i$ $(1 \\le u_i < v_i \\le n; 1 \\le t_i \\le 1000)$。不同的道路连接不同的城市对。", "outputFormat": "输出一个整数，代表满足上述要求的两次行程的最小总旅行时间；如果无法满足要求，则输出 $-1$。", "hint": "**样例解释 #1**\n\n城市和道路如图 J.1 所示。一种可能的最小化总旅行时间的方式如下：\n* 从城市 1 前往城市 3，途经道路 2（连接城市 1 和 3）。行程时间为 $5$。经过的道路集合为 $\\{2\\}$。\n* 从城市 3 前往城市 1，途经道路 2，然后两次经过道路 1（连接城市 1 和 2）。行程时间为 $5+10+10=25$。经过的道路集合为 $\\{1,2\\}$。\n\n可以证明，没有办法以更小的总旅行时间完成两次行程。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zhgjb2k3.png)\n\n**样例解释 #2**\n\n城市和道路如图 J.2 所示。从城市 1 前往城市 4 再返回，两次行程都必须经过所有的道路。因此，无法满足上述要求。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b6kn6lyl.png)", "locale": "zh-CN"}}}
{"pid": "P13625", "type": "P", "difficulty": 6, "samples": [["5 3\n3 0 2 2 3\n1\n18\n25", "0\n82\n124"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "2024", "可持久化线段树", "ICPC"], "title": "[ICPC 2024 APC] Tree Quiz", "background": "", "description": "你的朋友想考考你。给你一棵有 $n$ 个节点的有根树，节点编号从 $1$ 到 $n$。对于每个节点 $i$，它的父节点是 $p_i$，除了根节点（没有父节点的节点）的 $p_i=0$。如果节点 $u=v$，或者节点 $u$ 是节点 $v$ 的父节点（如果存在）的祖先，那么我们说节点 $u$ 是节点 $v$ 的一个祖先。\n\n如果节点 $z$ 同时是节点 $x$ 和节点 $y$ 的祖先，我们称节点 $z$ 是节点 $x$ 和 $y$ 的一个共同祖先。如果节点 $z$ 是节点 $x$ 和 $y$ 的一个共同祖先，并且节点 $x$ 和 $y$ 的任何一个共同祖先也都是节点 $z$ 的祖先，那么我们称节点 $z$ 是节点 $x$ 和 $y$ 的最近共同祖先。我们将节点 $x$ 和 $y$ 的最近共同祖先表示为 $\\operatorname{LCA}(x,y)$。特别地，$\\operatorname{LCA}(x,x)=x$。\n\n你的朋友想要运行以下伪代码：\n\n```\nlet L be an empty array\nfor x = 1 to n\n  for y = 1 to n\n    append ((x-1)*n*n + (LCA(x,y)-1)*n + (y-1)) to L\nsort L in non-decreasing order\n```\n\n你的朋友有 $q$ 个问题，编号从 $1$ 到 $q$。在第 $j$ 个问题中，会给你一个整数 $k_j$，并要求你找出数组 $L$ 中的第 $k_j$ 个元素。请注意，$L$ 是以 $1$ 为起始下标的，所以其下标范围从 $1$ 到 $n^2$。为了通过测试，你必须回答所有问题。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $q$（$1 \\le n \\le 100,000$；$1 \\le q \\le 100,000$）。第二行包含 $n$ 个整数 $p_1, p_2, \\dots, p_n$（对于所有的 $i$，$0 \\le p_i \\le n$）。保证给定的值代表一棵有根树。接下来的 $q$ 行每行包含一个整数。第 $j$ 行包含 $k_j$（$1 \\le k_j \\le n^2$）。", "outputFormat": "对于每个问题，按顺序输出一个整数作为问题的答案。", "hint": "输入中的树如图 K.1 所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3xe1w5tx.png)\n\n$L$ 的元素为 $(0, 6, 8, 12, 14, 30, 31, 32, 33, 34, 56, 58, 60, 62, 64, 80, 81, 82, 84, 93, 106, 108, 110, 112, 124)$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 APC] Tree Quiz", "background": "", "description": "你的朋友想考考你。给你一棵有 $n$ 个节点的有根树，节点编号从 $1$ 到 $n$。对于每个节点 $i$，它的父节点是 $p_i$，除了根节点（没有父节点的节点）的 $p_i=0$。如果节点 $u=v$，或者节点 $u$ 是节点 $v$ 的父节点（如果存在）的祖先，那么我们说节点 $u$ 是节点 $v$ 的一个祖先。\n\n如果节点 $z$ 同时是节点 $x$ 和节点 $y$ 的祖先，我们称节点 $z$ 是节点 $x$ 和 $y$ 的一个共同祖先。如果节点 $z$ 是节点 $x$ 和 $y$ 的一个共同祖先，并且节点 $x$ 和 $y$ 的任何一个共同祖先也都是节点 $z$ 的祖先，那么我们称节点 $z$ 是节点 $x$ 和 $y$ 的最近共同祖先。我们将节点 $x$ 和 $y$ 的最近共同祖先表示为 $\\operatorname{LCA}(x,y)$。特别地，$\\operatorname{LCA}(x,x)=x$。\n\n你的朋友想要运行以下伪代码：\n\n```\nlet L be an empty array\nfor x = 1 to n\n  for y = 1 to n\n    append ((x-1)*n*n + (LCA(x,y)-1)*n + (y-1)) to L\nsort L in non-decreasing order\n```\n\n你的朋友有 $q$ 个问题，编号从 $1$ 到 $q$。在第 $j$ 个问题中，会给你一个整数 $k_j$，并要求你找出数组 $L$ 中的第 $k_j$ 个元素。请注意，$L$ 是以 $1$ 为起始下标的，所以其下标范围从 $1$ 到 $n^2$。为了通过测试，你必须回答所有问题。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $q$（$1 \\le n \\le 100,000$；$1 \\le q \\le 100,000$）。第二行包含 $n$ 个整数 $p_1, p_2, \\dots, p_n$（对于所有的 $i$，$0 \\le p_i \\le n$）。保证给定的值代表一棵有根树。接下来的 $q$ 行每行包含一个整数。第 $j$ 行包含 $k_j$（$1 \\le k_j \\le n^2$）。", "outputFormat": "对于每个问题，按顺序输出一个整数作为问题的答案。", "hint": "输入中的树如图 K.1 所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3xe1w5tx.png)\n\n$L$ 的元素为 $(0, 6, 8, 12, 14, 30, 31, 32, 33, 34, 56, 58, 60, 62, 64, 80, 81, 82, 84, 93, 106, 108, 110, 112, 124)$。", "locale": "zh-CN"}}}
{"pid": "P13626", "type": "P", "difficulty": 7, "samples": [["3\n1 2 1", "4"], ["4\n852415 852415 852415 852415", "1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "ICPC"], "title": "[ICPC 2024 APC] XOR Operations", "background": "", "description": "给定 $n$ 个整数 $a_1, a_2, \\dots, a_n$。你有一个包含 $n$ 个整数的序列 $B=(b_1, b_2, \\dots, b_n)$，初始时所有元素均为零。\n\n在一次操作中，你选择两个不同的下标 $i$ 和 $j$，然后同时\n* 将 $b_i$ 替换为 $b_i \\oplus a_i \\oplus a_j$，并且\n* 将 $b_j$ 替换为 $b_j \\oplus a_i \\oplus a_j$。\n\n注意，$\\oplus$ 代表按位异或（bitwise XOR）操作。对于两个整数，其操作结果整数的每个二进制位，当且仅当两个操作数对应的二进制位有且仅有一个为 $1$ 时，该位为 $1$。例如，$3 \\oplus 10 = 9$，因为 $(0011)_2 \\oplus (1010)_2 = (1001)_2$。\n\n你想要计算通过零次或多次操作可以得到的不同序列 $B$ 的数量。由于这个数字可能非常大，请计算结果对 $998,244,353$ 取模。\n\n两个长度为 $n$ 的序列被认为是不同的，当且仅当存在一个下标 $i$ ($1 \\le i \\le n$)，使得一个序列的第 $i$ 个元素与另一个序列的第 $i$ 个元素不同。", "inputFormat": "输入的第一行包含一个整数 $n$ ($2 \\le n \\le 200,000$)。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\dots, a_n$ ($0 \\le a_i < 2^{30}$)。", "outputFormat": "输出一个整数，代表可以得到的不同序列 $B$ 的数量，结果对 $998,244,353$ 取模。", "hint": "**样例解释 #1**\n\n从 $B=(0,0,0)$ 开始，我们可以得到以下两个序列 $B$：\n* 对 $i=1$ 和 $j=2$ 执行操作。我们将得到 $B=(3,3,0)$。\n* 在此之后，对 $i=2$ 和 $j=3$ 执行操作。我们将得到 $B=(3,0,3)$。\n\n从 $B=(0,0,0)$ 开始，我们也可以得到以下序列 $B$：\n* 对 $i=2$ 和 $j=3$ 执行操作。我们将得到 $B=(0,3,3)$。\n\n可以证明，$(0,0,0)$, $(3,3,0)$, $(3,0,3)$ 和 $(0,3,3)$ 是唯一可能得到的序列 $B$。因此，答案是 $4$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 APC] XOR Operations", "background": "", "description": "给定 $n$ 个整数 $a_1, a_2, \\dots, a_n$。你有一个包含 $n$ 个整数的序列 $B=(b_1, b_2, \\dots, b_n)$，初始时所有元素均为零。\n\n在一次操作中，你选择两个不同的下标 $i$ 和 $j$，然后同时\n* 将 $b_i$ 替换为 $b_i \\oplus a_i \\oplus a_j$，并且\n* 将 $b_j$ 替换为 $b_j \\oplus a_i \\oplus a_j$。\n\n注意，$\\oplus$ 代表按位异或（bitwise XOR）操作。对于两个整数，其操作结果整数的每个二进制位，当且仅当两个操作数对应的二进制位有且仅有一个为 $1$ 时，该位为 $1$。例如，$3 \\oplus 10 = 9$，因为 $(0011)_2 \\oplus (1010)_2 = (1001)_2$。\n\n你想要计算通过零次或多次操作可以得到的不同序列 $B$ 的数量。由于这个数字可能非常大，请计算结果对 $998,244,353$ 取模。\n\n两个长度为 $n$ 的序列被认为是不同的，当且仅当存在一个下标 $i$ ($1 \\le i \\le n$)，使得一个序列的第 $i$ 个元素与另一个序列的第 $i$ 个元素不同。", "inputFormat": "输入的第一行包含一个整数 $n$ ($2 \\le n \\le 200,000$)。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\dots, a_n$ ($0 \\le a_i < 2^{30}$)。", "outputFormat": "输出一个整数，代表可以得到的不同序列 $B$ 的数量，结果对 $998,244,353$ 取模。", "hint": "**样例解释 #1**\n\n从 $B=(0,0,0)$ 开始，我们可以得到以下两个序列 $B$：\n* 对 $i=1$ 和 $j=2$ 执行操作。我们将得到 $B=(3,3,0)$。\n* 在此之后，对 $i=2$ 和 $j=3$ 执行操作。我们将得到 $B=(3,0,3)$。\n\n从 $B=(0,0,0)$ 开始，我们也可以得到以下序列 $B$：\n* 对 $i=2$ 和 $j=3$ 执行操作。我们将得到 $B=(0,3,3)$。\n\n可以证明，$(0,0,0)$, $(3,3,0)$, $(3,0,3)$ 和 $(0,3,3)$ 是唯一可能得到的序列 $B$。因此，答案是 $4$。", "locale": "zh-CN"}}}
{"pid": "P13627", "type": "P", "difficulty": 7, "samples": [["4\n5\n6\n7\n890", "7\n12\n19\n502674609"]], "limits": {"time": [12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "ICPC"], "title": "[ICPC 2024 APC] Zig-zag", "background": "", "description": "扎克的泽格工效学学位（Zergonomics Zegree）教会了他，在商店里展示物品的最佳方式是把它们堆叠成一种之字形图案。扎克需要将 $n$ 个装有可动人偶的盒子在店门口排成一列。这些盒子可以相互堆叠，并且它们是相同的、不可区分的。他的目标是决定要堆叠成的堆数，然后将盒子堆起来，使得每一堆都不是空的，并且各堆的盒子数量形成一个之字形序列。\n\n形式上，如果有 $s$ ($s \\ge 1$) 堆，从左到右编号为 $1$ 到 $s$，且第 $i$ 堆包含 $a_i$ 个盒子，那么必须满足以下条件：\n* 对于每个 $i$（从 $1$ 到 $s$），$a_i \\ge 1$，\n* $a_1 + a_2 + \\dots + a_s = n$，并且\n* 以下至少一条为真：\n    * $a_1 < a_2 > a_3 < a_4 > \\dots$，或者\n    * $a_1 > a_2 < a_3 > a_4 < \\dots$\n\n例如，对于 $n=6$，总共有 $12$ 种方式，如图 M.1 所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/r26c3d3f.png)\n\n找出扎克可以用多少种不同的方式堆叠这 $n$ 个盒子，结果对 $998,244,353$ 取模。\n\n两种方式被认为是相同的，当且仅当它们的堆数相同，并且在相同位置上的堆所含的盒子数量也相同。", "inputFormat": "输入的第一行包含一个整数 $t$ ($1 \\le t \\le 300,000$)，代表测试用例的数量。之后是 $t$ 个测试用例。每个测试用例包含一行，内含一个整数 $n$ ($1 \\le n \\le 300,000$)。", "outputFormat": "对于每个测试用例，输出一个整数，代表堆叠 $n$ 个盒子的不同方式数量，结果对 $998,244,353$ 取模。", "hint": "**样例解释 #1**\n\n第二个测试用例的 $n$ 值为 $6$，其 $12$ 种方式已在题目描述中说明。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 APC] Zig-zag", "background": "", "description": "扎克的泽格工效学学位（Zergonomics Zegree）教会了他，在商店里展示物品的最佳方式是把它们堆叠成一种之字形图案。扎克需要将 $n$ 个装有可动人偶的盒子在店门口排成一列。这些盒子可以相互堆叠，并且它们是相同的、不可区分的。他的目标是决定要堆叠成的堆数，然后将盒子堆起来，使得每一堆都不是空的，并且各堆的盒子数量形成一个之字形序列。\n\n形式上，如果有 $s$ ($s \\ge 1$) 堆，从左到右编号为 $1$ 到 $s$，且第 $i$ 堆包含 $a_i$ 个盒子，那么必须满足以下条件：\n* 对于每个 $i$（从 $1$ 到 $s$），$a_i \\ge 1$，\n* $a_1 + a_2 + \\dots + a_s = n$，并且\n* 以下至少一条为真：\n    * $a_1 < a_2 > a_3 < a_4 > \\dots$，或者\n    * $a_1 > a_2 < a_3 > a_4 < \\dots$\n\n例如，对于 $n=6$，总共有 $12$ 种方式，如图 M.1 所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/r26c3d3f.png)\n\n找出扎克可以用多少种不同的方式堆叠这 $n$ 个盒子，结果对 $998,244,353$ 取模。\n\n两种方式被认为是相同的，当且仅当它们的堆数相同，并且在相同位置上的堆所含的盒子数量也相同。", "inputFormat": "输入的第一行包含一个整数 $t$ ($1 \\le t \\le 300,000$)，代表测试用例的数量。之后是 $t$ 个测试用例。每个测试用例包含一行，内含一个整数 $n$ ($1 \\le n \\le 300,000$)。", "outputFormat": "对于每个测试用例，输出一个整数，代表堆叠 $n$ 个盒子的不同方式数量，结果对 $998,244,353$ 取模。", "hint": "**样例解释 #1**\n\n第二个测试用例的 $n$ 值为 $6$，其 $12$ 种方式已在题目描述中说明。", "locale": "zh-CN"}}}
{"pid": "P13628", "type": "P", "difficulty": 1, "samples": [["1 BC\nAD 1", "1"], ["AD 1\nAD 2001", "2000"], ["AD 2022\n5508 BC", "7529"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "ICPC", "NWRRC"], "title": "[NWRRC 2021] Anno Domini 2022", "background": "", "description": "Soon we will celebrate New Year 2022, but what does this number mean? As you possibly know, this dating system was invented in AD 525 by Dionysius Exiguus. He chose the birth of Jesus Christ as the starting point of the Years of Our Lord (Anno Domini in Latin, AD for short). All the years before that were counted backwards as years Before Christ (BC for short). \n\nAn interesting detail of this dating system is that there is no year 0 --- year 1 BC is immediately followed by AD 1. Because of that, sometimes it is quite tricky to find time difference between two dates if these dates belong to two different eras.\n\nTo simplify this task, please write a program that computes how many years passed between January 1st of two years given in the input.", "inputFormat": "Two years are specified on two sequential input lines. Each year is specified in one of two forms:\n- as letters $\\tt{AD}$, followed by a space and a positive integer without leading zeroes in range $1..9999$;\n- as a positive integer without leading zeroes in range $1..9999$, followed by a space and letters $\\tt{BC}$.\n\nThe years may be specified in arbitrary order --- the earlier year is not necessarily given first.", "outputFormat": "The only line of the output must contain one integer: the number of years that passed between January 1st of the earlier year and January 1st of the later year.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NWRRC 2021] Anno Domini 2022", "background": "", "description": "Soon we will celebrate New Year 2022, but what does this number mean? As you possibly know, this dating system was invented in AD 525 by Dionysius Exiguus. He chose the birth of Jesus Christ as the starting point of the Years of Our Lord (Anno Domini in Latin, AD for short). All the years before that were counted backwards as years Before Christ (BC for short). \n\nAn interesting detail of this dating system is that there is no year 0 --- year 1 BC is immediately followed by AD 1. Because of that, sometimes it is quite tricky to find time difference between two dates if these dates belong to two different eras.\n\nTo simplify this task, please write a program that computes how many years passed between January 1st of two years given in the input.", "inputFormat": "Two years are specified on two sequential input lines. Each year is specified in one of two forms:\n- as letters $\\tt{AD}$, followed by a space and a positive integer without leading zeroes in range $1..9999$;\n- as a positive integer without leading zeroes in range $1..9999$, followed by a space and letters $\\tt{BC}$.\n\nThe years may be specified in arbitrary order --- the earlier year is not necessarily given first.", "outputFormat": "The only line of the output must contain one integer: the number of years that passed between January 1st of the earlier year and January 1st of the later year.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2021] Anno Domini 2022", "background": null, "description": "很快我们将迎来 2022 年新年，但这个数字究竟意味着什么呢？你可能知道，这种纪年系统是由 Dionysius Exiguus 在公元 525 年发明的。他选择耶稣基督的诞生作为“主的纪年”（拉丁语为 Anno Domini，简称 AD）的起点。在此之前的所有年份都按倒序计数，被称为“公元前”（简称 BC）。\n\n这个纪年系统的一个有趣细节是：没有公元 0 年——公元前 1 年（1 BC）之后紧接着就是公元 1 年（AD 1）。因此，如果两个日期分别属于不同纪元，计算它们之间的时间差有时会比较棘手。\n\n为了简化这个任务，请编写一个程序，计算输入中给定的两个年份的 1 月 1 日之间相隔了多少年。", "inputFormat": "输入共两行，每行指定一个年份。每个年份有以下两种形式之一：\n- 以字母 AD 开头，后跟一个空格和一个没有前导零、范围为 $1..9999$ 的正整数；\n- 以一个没有前导零、范围为 $1..9999$ 的正整数开头，后跟一个空格和字母 BC。\n\n年份的输入顺序是任意的——较早的年份不一定先给出。", "outputFormat": "输出仅一行，包含一个整数：表示较早年份的 1 月 1 日到较晚年份的 1 月 1 日之间相隔的年数。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13629", "type": "P", "difficulty": 2, "samples": [["1234\n500\n169", "0 7"], ["1700\n500\n200", "1 6\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "Special Judge", "枚举", "ICPC", "NWRRC"], "title": "[NWRRC 2021] Boris and Berta", "background": "", "description": "Boris is making a quest for his sister Berta. One of the tasks is to find a point on the map that is $n$ meters to the north from their house. But it's too easy if $n$ is specified directly. Boris decided to use miles and cables to specify the distance.\n\nHe found out that there are a lot of different miles: from a $500$-meter Chinese mile (called $\\textit{li}$) up to a $11\\,299$-meter Norwegian mile (called $\\textit{mil}$). And a cable length can be anywhere from $169$ to $220$ meters.\n\nBoris decided to use an $m$-meter mile and a $c$-meter cable. Now he wants to represent the $n$-meter distance as \"$M$ miles and $C$ cables\" with non-negative integers $M$ and $C$ as precisely as possible --- that is, he wants to minimize $|M\\cdot m+C\\cdot c-n|$. Help him!", "inputFormat": "Three lines contain an integer each: $n$ --- the distance to represent, $m$ --- the chosen length of a mile, and $c$ --- the chosen length of a cable ($1 \\le n \\le 10^9$; $500 \\le m \\le 11\\,299$; $169 \\le c \\le 220$). All values are given in meters.", "outputFormat": "Print two non-negative integers $M$ and $C$ --- the best approximation for the distance of $n$ meters using the chosen mile and cable lengths. If there are multiple best approximations, print any of them.", "hint": "There are two correct answers to the second example test: $\\texttt{1 6}$ and $\\texttt{3 1}$.", "locale": "en", "translations": {"en": {"title": "[NWRRC 2021] Boris and Berta", "background": "", "description": "Boris is making a quest for his sister Berta. One of the tasks is to find a point on the map that is $n$ meters to the north from their house. But it's too easy if $n$ is specified directly. Boris decided to use miles and cables to specify the distance.\n\nHe found out that there are a lot of different miles: from a $500$-meter Chinese mile (called $\\textit{li}$) up to a $11\\,299$-meter Norwegian mile (called $\\textit{mil}$). And a cable length can be anywhere from $169$ to $220$ meters.\n\nBoris decided to use an $m$-meter mile and a $c$-meter cable. Now he wants to represent the $n$-meter distance as \"$M$ miles and $C$ cables\" with non-negative integers $M$ and $C$ as precisely as possible --- that is, he wants to minimize $|M\\cdot m+C\\cdot c-n|$. Help him!", "inputFormat": "Three lines contain an integer each: $n$ --- the distance to represent, $m$ --- the chosen length of a mile, and $c$ --- the chosen length of a cable ($1 \\le n \\le 10^9$; $500 \\le m \\le 11\\,299$; $169 \\le c \\le 220$). All values are given in meters.", "outputFormat": "Print two non-negative integers $M$ and $C$ --- the best approximation for the distance of $n$ meters using the chosen mile and cable lengths. If there are multiple best approximations, print any of them.", "hint": "There are two correct answers to the second example test: $\\texttt{1 6}$ and $\\texttt{3 1}$.", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2021] Boris and Berta", "background": null, "description": "Boris 正在为他的妹妹 Berta 设计一个任务。其中一项任务是找到距离他们家正北方向 $n$ 米的一个点。但如果直接给出 $n$，就太简单了。Boris 决定用英里和缆绳来表示这个距离。\n\n他发现英里有很多种：从 $500$ 米的中国里（称为 $\\textit{li}$）到 $11\\,299$ 米的挪威英里（称为 $\\textit{mil}$）。而一根缆绳的长度可以从 $169$ 米到 $220$ 米不等。\n\nBoris 决定选用长度为 $m$ 米的英里和长度为 $c$ 米的缆绳。现在他想用“$M$ 英里和 $C$ 缆绳”来尽可能精确地表示 $n$ 米的距离——也就是说，他想最小化 $|M\\cdot m+C\\cdot c-n|$。请你帮帮他！", "inputFormat": "输入共三行，每行一个整数：$n$ —— 需要表示的距离，$m$ —— 选定的英里长度，$c$ —— 选定的缆绳长度（$1 \\le n \\le 10^9$；$500 \\le m \\le 11\\,299$；$169 \\le c \\le 220$）。所有数值均以米为单位。", "outputFormat": "输出两个非负整数 $M$ 和 $C$ —— 用选定的英里和缆绳长度最接近 $n$ 米的表示方法。如果有多种最优解，输出任意一种即可。", "hint": "对于第二个样例测试，有两个正确答案：$\\texttt{1 6}$ 和 $\\texttt{3 1}$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13630", "type": "P", "difficulty": 4, "samples": [["4 2\na\nabc\nabd\nb", "2"], ["4 2\nd\nc\nab\na", "2"], ["5 3\nplease\nremove\nall\nthese\nfiles", "3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2021", "字典树 Trie", "ICPC", "NWRRC"], "title": "[NWRRC 2021] Clean Up!", "background": "", "description": "Once Charlie decided to start a new life by deleting all files in his Downloads directory. It's easy to do that using $\\texttt{bash}$ shell! It has two useful features: the $\\texttt{rm}$ command, which removes all files given as arguments, and patterns, which are replaced with the list of files matching them before executing the command.\n\nCharlie ran $\\texttt{rm *}$, but received an $\\texttt{Argument list too long}$ response. Unfortunately, after $\\texttt{bash}$ replaced $\\texttt{*}$ with the names of all files in the Downloads directory, it failed to run the command because it had too many arguments.\n\nAfter some experiments, Charlie realized he can execute $\\texttt{rm abc*}$ to delete all files with names starting with $\\texttt{abc}$ if there are at most $k$ such files. If more than $k$ files match this pattern, none of them will be deleted. Of course, he can replace $\\texttt{abc}$ with any string.\n\nHelp Charlie to find the smallest number of $\\texttt{rm}$ commands needed to delete all files. Assume that he can only use the $\\texttt{rm}$ command as $\\texttt{rm <prefix>*}$, where $\\texttt{<prefix>}$ consists of lowercase English letters (and can be empty). ", "inputFormat": "The first line contains two integers $n$ and $k$ --- the number of files to delete, and the maximum number of files that can be deleted by one $\\texttt{rm}$ command ($1 \\le n, k \\le 3 \\cdot 10^5$).\n\nEach of the next $n$ lines contains a single string, denoting a file name. All file names are distinct, non-empty, and consist of lowercase English letters. The total length of all file names doesn't exceed $3 \\cdot 10^5$.", "outputFormat": "Print a single integer --- the smallest number of $\\texttt{rm}$ commands needed to delete all files.", "hint": "In the first example test, Charlie can execute $\\texttt{rm ab*}$ to delete files $\\texttt{abc}$ and $\\texttt{abd}$, and then execute $\\texttt{rm~*}$ to delete files $\\texttt{a}$ and $\\texttt{b}$. Note that he can't just run $\\texttt{rm *}$ immediately, because initially all four files match an empty prefix. ", "locale": "en", "translations": {"en": {"title": "[NWRRC 2021] Clean Up!", "background": "", "description": "Once Charlie decided to start a new life by deleting all files in his Downloads directory. It's easy to do that using $\\texttt{bash}$ shell! It has two useful features: the $\\texttt{rm}$ command, which removes all files given as arguments, and patterns, which are replaced with the list of files matching them before executing the command.\n\nCharlie ran $\\texttt{rm *}$, but received an $\\texttt{Argument list too long}$ response. Unfortunately, after $\\texttt{bash}$ replaced $\\texttt{*}$ with the names of all files in the Downloads directory, it failed to run the command because it had too many arguments.\n\nAfter some experiments, Charlie realized he can execute $\\texttt{rm abc*}$ to delete all files with names starting with $\\texttt{abc}$ if there are at most $k$ such files. If more than $k$ files match this pattern, none of them will be deleted. Of course, he can replace $\\texttt{abc}$ with any string.\n\nHelp Charlie to find the smallest number of $\\texttt{rm}$ commands needed to delete all files. Assume that he can only use the $\\texttt{rm}$ command as $\\texttt{rm <prefix>*}$, where $\\texttt{<prefix>}$ consists of lowercase English letters (and can be empty). ", "inputFormat": "The first line contains two integers $n$ and $k$ --- the number of files to delete, and the maximum number of files that can be deleted by one $\\texttt{rm}$ command ($1 \\le n, k \\le 3 \\cdot 10^5$).\n\nEach of the next $n$ lines contains a single string, denoting a file name. All file names are distinct, non-empty, and consist of lowercase English letters. The total length of all file names doesn't exceed $3 \\cdot 10^5$.", "outputFormat": "Print a single integer --- the smallest number of $\\texttt{rm}$ commands needed to delete all files.", "hint": "In the first example test, Charlie can execute $\\texttt{rm ab*}$ to delete files $\\texttt{abc}$ and $\\texttt{abd}$, and then execute $\\texttt{rm~*}$ to delete files $\\texttt{a}$ and $\\texttt{b}$. Note that he can't just run $\\texttt{rm *}$ immediately, because initially all four files match an empty prefix. ", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2021] Clean Up!", "background": null, "description": "有一天，Charlie 决定通过删除 Downloads 目录下的所有文件来开始新生活。使用 $\\texttt{bash}$ shell 可以很容易地完成这个操作！它有两个有用的功能：$\\texttt{rm}$ 命令可以删除作为参数传入的所有文件，通配符可以在执行命令前将其替换为所有匹配的文件列表。\n\nCharlie 执行了 $\\texttt{rm *}$，但收到了 $\\texttt{Argument list too long}$ 的提示。原来，在 $\\texttt{bash}$ 将 $\\texttt{*}$ 替换为 Downloads 目录下所有文件名后，由于参数过多，命令无法执行。\n\n经过一些实验，Charlie 发现他可以执行 $\\texttt{rm abc*}$ 来删除所有以 $\\texttt{abc}$ 开头的文件，前提是这样的文件数量不超过 $k$ 个。如果匹配该模式的文件超过 $k$ 个，则这些文件都不会被删除。当然，他可以用任意字符串替换 $\\texttt{abc}$。\n\n请你帮助 Charlie 计算，删除所有文件所需的最少 $\\texttt{rm}$ 命令次数。假设他只能使用形如 $\\texttt{rm <prefix>*}$ 的命令，其中 $\\texttt{<prefix>}$ 由小写英文字母组成（可以为空）。", "inputFormat": "第一行包含两个整数 $n$ 和 $k$，分别表示要删除的文件数量和每条 $\\texttt{rm}$ 命令最多能删除的文件数（$1 \\le n, k \\le 3 \\times 10^5$）。\n\n接下来的 $n$ 行，每行包含一个字符串，表示一个文件名。所有文件名互不相同，非空且仅由小写英文字母组成。所有文件名的总长度不超过 $3 \\times 10^5$。", "outputFormat": "输出一个整数，表示删除所有文件所需的最少 $\\texttt{rm}$ 命令次数。", "hint": "在第一个样例测试中，Charlie 可以执行 $\\texttt{rm ab*}$ 删除文件 $\\texttt{abc}$ 和 $\\texttt{abd}$，然后执行 $\\texttt{rm~*}$ 删除文件 $\\texttt{a}$ 和 $\\texttt{b}$。注意，他不能一开始就执行 $\\texttt{rm *}$，因为最初所有四个文件都匹配空前缀。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13631", "type": "P", "difficulty": 6, "samples": [["5\n4 10\n0 3 8 24\n2 10\n32 35\n10 1\n0 1 3 4 5 6 7 10 11 12\n10 24\n0 1 3 4 5 6 7 10 11 12\n8 24\n26 71 101 147 181 201 244 268", "3 2\n2 5\n5 0\n2 12\n4 15"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "2021", "Special Judge", "ICPC", "双指针 two-pointer", "NWRRC"], "title": "[NWRRC 2021] Day Streak", "background": "", "description": "Recently Deltaforces, a famous competitive programming website, added a lot of new visual information to user profiles. In particular, there is a maximum day streak --- the maximum number of days in a row with at least one problem solved. You decided that the maximum day streak in your profile does not accurately represent your training efforts. So you came up with a thought --- what if you could change the time zone in your profile to increase the maximum day streak?\n\nLet's formalize this setting as follows. Suppose you have solved $n$ problems, and the $i$-th problem was solved at time $a_i$. There are $m$ time zones, numbered from $0$ to $m - 1$. The default time zone is $0$. If you decide to change your time zone to $t$, all solutions' timestamps increase by $t$: the problem solved at time $a_i$ is now considered to be solved at time $a_i + t$, for all $i$ simultaneously.\n\nThe problem solved at time $x$ is considered to be solved on day number $\\lfloor \\frac{x}{m} \\rfloor$. Here $\\lfloor v \\rfloor$ means $v$ rounded down to the greatest integer less than or equal to $v$.\n\nTo display the maximum day streak, Deltaforces finds such $l$ and $r$ that you have solved at least one problem on each of days $l, l+1, \\ldots, r$, and $r - l + 1$ is as large as possible. Then your maximum day streak is shown as $r - l + 1$.\n\nFind the maximum day streak you can achieve by selecting a time zone.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 2 \\cdot 10^5$). Description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ --- the number of solved problems and the number of time zones ($1 \\le n \\le 2 \\cdot 10^5$; $1 \\le m \\le 10^9$). The second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ --- distinct timestamps of your solutions, in chronological order ($0 \\le a_1 < a_2 < \\dotsb < a_n \\le 10^9$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.", "outputFormat": "For each test case, print two integers $s$ and $t$ --- the maximum day streak and any time zone that achieves it ($1 \\le s \\le n$; $0 \\le t < m$).", "hint": "In the first example test case, when you select time zone $2$, the timestamps of your solutions change to $2$, $5$, $10$, and $26$. It means the problems are now considered to be solved on days $0$, $0$, $1$, and $2$; that is a~$3$-day streak. Time zones $3$, $4$, and $5$ yield the same answer.\n\nIn the second example test case, timestamps of your solutions are $37$ and $40$ in time zone $5$, which corresponds to days $3$ and $4$. Time zones $6$ and $7$ also work.\n\nIn the third example test case, only one time zone exists, and your maximum day streak is $5$.\n\nIn the fourth example test case, you have solved many problems but in a short period of time, and you can't obtain more than a $2$-day streak.", "locale": "en", "translations": {"en": {"title": "[NWRRC 2021] Day Streak", "background": "", "description": "Recently Deltaforces, a famous competitive programming website, added a lot of new visual information to user profiles. In particular, there is a maximum day streak --- the maximum number of days in a row with at least one problem solved. You decided that the maximum day streak in your profile does not accurately represent your training efforts. So you came up with a thought --- what if you could change the time zone in your profile to increase the maximum day streak?\n\nLet's formalize this setting as follows. Suppose you have solved $n$ problems, and the $i$-th problem was solved at time $a_i$. There are $m$ time zones, numbered from $0$ to $m - 1$. The default time zone is $0$. If you decide to change your time zone to $t$, all solutions' timestamps increase by $t$: the problem solved at time $a_i$ is now considered to be solved at time $a_i + t$, for all $i$ simultaneously.\n\nThe problem solved at time $x$ is considered to be solved on day number $\\lfloor \\frac{x}{m} \\rfloor$. Here $\\lfloor v \\rfloor$ means $v$ rounded down to the greatest integer less than or equal to $v$.\n\nTo display the maximum day streak, Deltaforces finds such $l$ and $r$ that you have solved at least one problem on each of days $l, l+1, \\ldots, r$, and $r - l + 1$ is as large as possible. Then your maximum day streak is shown as $r - l + 1$.\n\nFind the maximum day streak you can achieve by selecting a time zone.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 2 \\cdot 10^5$). Description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ --- the number of solved problems and the number of time zones ($1 \\le n \\le 2 \\cdot 10^5$; $1 \\le m \\le 10^9$). The second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ --- distinct timestamps of your solutions, in chronological order ($0 \\le a_1 < a_2 < \\dotsb < a_n \\le 10^9$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.", "outputFormat": "For each test case, print two integers $s$ and $t$ --- the maximum day streak and any time zone that achieves it ($1 \\le s \\le n$; $0 \\le t < m$).", "hint": "In the first example test case, when you select time zone $2$, the timestamps of your solutions change to $2$, $5$, $10$, and $26$. It means the problems are now considered to be solved on days $0$, $0$, $1$, and $2$; that is a~$3$-day streak. Time zones $3$, $4$, and $5$ yield the same answer.\n\nIn the second example test case, timestamps of your solutions are $37$ and $40$ in time zone $5$, which corresponds to days $3$ and $4$. Time zones $6$ and $7$ also work.\n\nIn the third example test case, only one time zone exists, and your maximum day streak is $5$.\n\nIn the fourth example test case, you have solved many problems but in a short period of time, and you can't obtain more than a $2$-day streak.", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2021] Day Streak", "background": null, "description": "最近，著名的竞赛编程网站 Deltaforces 在用户资料中增加了许多新的可视化信息。特别地，新增了“最大连续天数”——即连续若干天每天至少解决一道题的最大天数。你觉得你资料中的最大连续天数并不能准确反映你的训练努力。因此，你产生了一个想法——如果你可以更改资料中的时区，是否能提升你的最大连续天数？\n\n我们将这个设定形式化如下。假设你总共解决了 $n$ 道题，第 $i$ 道题是在时间 $a_i$ 被解决的。共有 $m$ 个时区，编号从 $0$ 到 $m-1$。默认时区为 $0$。如果你选择将时区更改为 $t$，那么所有题目的时间戳都会增加 $t$：即第 $i$ 道题的时间变为 $a_i + t$，对所有 $i$ 都成立。\n\n在时间 $x$ 解决的问题被认为是在第 $\\lfloor \\frac{x}{m} \\rfloor$ 天解决的。这里 $\\lfloor v \\rfloor$ 表示不超过 $v$ 的最大整数。\n\n为了展示最大连续天数，Deltaforces 会找到一组 $l$ 和 $r$，使得你在第 $l, l+1, \\ldots, r$ 天中每天至少解决了一道题，并且 $r-l+1$ 尽可能大。此时你的最大连续天数就是 $r-l+1$。\n\n请你通过选择一个合适的时区，使你的最大连续天数最大，并输出最大连续天数以及对应的时区。", "inputFormat": "每个测试点包含多组测试数据。第一行包含测试用例数 $t$（$1 \\le t \\le 2 \\cdot 10^5$）。接下来是每组测试数据的描述。\n\n每组测试数据的第一行包含两个整数 $n$ 和 $m$，分别表示你解决的问题数和时区数（$1 \\le n \\le 2 \\cdot 10^5$，$1 \\le m \\le 10^9$）。第二行包含 $n$ 个整数 $a_1, a_2, \\ldots, a_n$，表示你解决每道题的时间戳，且时间戳各不相同，按时间递增排列（$0 \\le a_1 < a_2 < \\dotsb < a_n \\le 10^9$）。\n\n保证所有测试用例中 $n$ 的总和不超过 $2 \\cdot 10^5$。", "outputFormat": "对于每组测试数据，输出两个整数 $s$ 和 $t$，分别表示最大连续天数和实现该天数的任意一个时区（$1 \\le s \\le n$，$0 \\le t < m$）。", "hint": "在第一个样例测试中，当你选择时区 $2$ 时，你的题目时间戳变为 $2$、$5$、$10$ 和 $26$。这意味着这些题目分别被认为是在第 $0$、$0$、$1$ 和 $2$ 天解决的，也就是一个 $3$ 天的连续天数。时区 $3$、$4$ 和 $5$ 也能得到相同的答案。\n\n在第二个样例测试中，选择时区 $5$ 后，你的题目时间戳变为 $37$ 和 $40$，对应第 $3$ 天和第 $4$ 天。时区 $6$ 和 $7$ 也可以。\n\n在第三个样例测试中，只有一个时区，你的最大连续天数就是 $5$。\n\n在第四个样例测试中，你在很短的时间内解决了很多题，但最大连续天数也只能是 $2$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13632", "type": "P", "difficulty": 0, "samples": [["Multiple local maxima: No\nMultiple local minima: No\nPlateaus: No", "x 3 - 4 ^ y -5 + 2 ^ +"], ["Multiple local maxima: No\nMultiple local minima: No\nPlateaus: Yes", "1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2021] Extreme Problem", "background": "", "description": "Many problems given in programming competitions are extreme in this or that regard. Examples include:\n  - a problem that is solved by doing lots of heavy math on paper and then by printing one well-known number, rounded to the number of digits given in the input file;\n  - a problem that spans more than four pages and requires you to write a simulation system that tracks multiple skills of several secret agents and chooses the best combination of them for each mission;\n  - a problem for which it is a proven fact that no correct solution will ever exist, but it was still given in a contest.\n\nThis time you are given a problem that is also extreme, in that it has only eight possible tests. And, of course, it will be about something extreme.\n\nWe consider functions of two integer variables, defined on the $[-10;10] \\times [-10;10]$ square. It means that you can perform a call to $f(x,y)$ only if $x$ and $y$ are integers and $-10 \\le x, y \\le 10$. Such a function $f$ is said to have a $\\textit{local minimum}$ at $(x,y)$ if the following statements hold simultaneously:\n\n- $f(x,y) < f(x-1,y)$;\n- $f(x,y) < f(x+1,y)$;\n- $f(x,y) < f(x,y-1)$;\n- $f(x,y) < f(x,y+1)$.\n\nA $\\textit{local maximum}$ is defined in a similar way, only the inequalities are reversed. A function $f$ is said to have a $\\textit{plateau}$ at $(x,y)$ if at least one of the following statements holds:\n\n- $f(x,y) = f(x-1,y)$;\n- $f(x,y) = f(x+1,y)$;\n- $f(x,y) = f(x,y-1)$;\n- $f(x,y) = f(x,y+1)$.\n\nNote that all the function invocations above must happen on the points from the function domain, that is, the $[-10;10] \\times [-10;10]$ square. In particular, this means that a point on the boundary of this square $\\textbf{cannot be}$ a local maximum or a local minimum, but can still be a plateau.\n\nYou need to find a function which has --- or does not have, depending on the information in the input:\n\n- multiple local maxima;\n- multiple local minima;\n- some plateaus.\n\nNote that \"multiple\" means \"at least two\". Also note that your function shall be defined in a specific way; see the Output section for details.", "inputFormat": "The input consists of three lines.  \n\n- The first line starts with $\\texttt{Multiple local maxima:~}$ and ends with either $\\texttt{Yes}$ or $\\texttt{No}$. This specifies whether your function shall or shall not have multiple local maxima.  \n- The second line starts with $\\texttt{Multiple local minima:~}$ and ends with either $\\texttt{Yes}$ or $\\texttt{No}$, and similarly deals with local minima.  \n- The third line starts with $\\texttt{Plateaus:~}$ and also ends with either $\\texttt{Yes}$ or $\\texttt{No}$. This specifies whether your function shall or shall not have plateaus. ", "outputFormat": "The output shall consist of one line that defines your function.  \n\nIf no such function can be represented as per the format below, print $\\texttt{No solution}$.  \n\nOtherwise, print your function using the reverse Polish notation. Recall that the reverse Polish notation is a way to describe a function using some sort of a stack machine: it is a sequence of operations, some of which push values onto the stack, while some pull a few values from the top of the stack, perform some math and push the result back to the stack.  \n\nYour function shall contain at most 1000 tokens, separated by single spaces, where each token is one of the following.  \n\n- An integer constant ranging from $\\texttt{-9}$ to $\\texttt{+9}$. This will push the corresponding number onto the stack.  \n- A variable, either $\\texttt{x}$ or $\\texttt{y}$. This will push the value of that variable onto the stack.  \n- An operation, which can be $\\texttt{+}$, $\\texttt{-}$, $\\texttt{*}$, or $\\texttt{\\textasciicircum}$. The asterisk means multiplication, whereas the $\\texttt{\\textasciicircum}$ character means raising to the power. Each of these operations will take two numbers from the stack, apply the operation and push the result back to the stack. The evaluation order is such that $\\texttt{9 5 -}$ evaluates to 4, and similarly $\\texttt{x 2 \\textasciicircum}$ evaluates to $x^2$. As a special case, $0^0$ evaluates to $1$.  \n\nNote that whenever one of the following things happens:  \n\n- an operation attempts to take a number from an empty stack;  \n- the $\\texttt{\\textasciicircum}$ operation attempts to raise something to a negative power;  \n- the result of an operation overflows the 32-bit signed integer;  \n- or at the end of the evaluation the size of the stack is not equal to one ---  \n\nyou receive a Wrong Answer outcome for the test where it happened. ", "hint": "The example answer to the first test encodes the function $(x-3)^4 + (y + (-5))^2$. Note that it has no local maxima, no plateaus, and just one local minimum.", "locale": "en", "translations": {"en": {"title": "[NWRRC 2021] Extreme Problem", "background": "", "description": "Many problems given in programming competitions are extreme in this or that regard. Examples include:\n  - a problem that is solved by doing lots of heavy math on paper and then by printing one well-known number, rounded to the number of digits given in the input file;\n  - a problem that spans more than four pages and requires you to write a simulation system that tracks multiple skills of several secret agents and chooses the best combination of them for each mission;\n  - a problem for which it is a proven fact that no correct solution will ever exist, but it was still given in a contest.\n\nThis time you are given a problem that is also extreme, in that it has only eight possible tests. And, of course, it will be about something extreme.\n\nWe consider functions of two integer variables, defined on the $[-10;10] \\times [-10;10]$ square. It means that you can perform a call to $f(x,y)$ only if $x$ and $y$ are integers and $-10 \\le x, y \\le 10$. Such a function $f$ is said to have a $\\textit{local minimum}$ at $(x,y)$ if the following statements hold simultaneously:\n\n- $f(x,y) < f(x-1,y)$;\n- $f(x,y) < f(x+1,y)$;\n- $f(x,y) < f(x,y-1)$;\n- $f(x,y) < f(x,y+1)$.\n\nA $\\textit{local maximum}$ is defined in a similar way, only the inequalities are reversed. A function $f$ is said to have a $\\textit{plateau}$ at $(x,y)$ if at least one of the following statements holds:\n\n- $f(x,y) = f(x-1,y)$;\n- $f(x,y) = f(x+1,y)$;\n- $f(x,y) = f(x,y-1)$;\n- $f(x,y) = f(x,y+1)$.\n\nNote that all the function invocations above must happen on the points from the function domain, that is, the $[-10;10] \\times [-10;10]$ square. In particular, this means that a point on the boundary of this square $\\textbf{cannot be}$ a local maximum or a local minimum, but can still be a plateau.\n\nYou need to find a function which has --- or does not have, depending on the information in the input:\n\n- multiple local maxima;\n- multiple local minima;\n- some plateaus.\n\nNote that \"multiple\" means \"at least two\". Also note that your function shall be defined in a specific way; see the Output section for details.", "inputFormat": "The input consists of three lines.  \n\n- The first line starts with $\\texttt{Multiple local maxima:~}$ and ends with either $\\texttt{Yes}$ or $\\texttt{No}$. This specifies whether your function shall or shall not have multiple local maxima.  \n- The second line starts with $\\texttt{Multiple local minima:~}$ and ends with either $\\texttt{Yes}$ or $\\texttt{No}$, and similarly deals with local minima.  \n- The third line starts with $\\texttt{Plateaus:~}$ and also ends with either $\\texttt{Yes}$ or $\\texttt{No}$. This specifies whether your function shall or shall not have plateaus. ", "outputFormat": "The output shall consist of one line that defines your function.  \n\nIf no such function can be represented as per the format below, print $\\texttt{No solution}$.  \n\nOtherwise, print your function using the reverse Polish notation. Recall that the reverse Polish notation is a way to describe a function using some sort of a stack machine: it is a sequence of operations, some of which push values onto the stack, while some pull a few values from the top of the stack, perform some math and push the result back to the stack.  \n\nYour function shall contain at most 1000 tokens, separated by single spaces, where each token is one of the following.  \n\n- An integer constant ranging from $\\texttt{-9}$ to $\\texttt{+9}$. This will push the corresponding number onto the stack.  \n- A variable, either $\\texttt{x}$ or $\\texttt{y}$. This will push the value of that variable onto the stack.  \n- An operation, which can be $\\texttt{+}$, $\\texttt{-}$, $\\texttt{*}$, or $\\texttt{\\textasciicircum}$. The asterisk means multiplication, whereas the $\\texttt{\\textasciicircum}$ character means raising to the power. Each of these operations will take two numbers from the stack, apply the operation and push the result back to the stack. The evaluation order is such that $\\texttt{9 5 -}$ evaluates to 4, and similarly $\\texttt{x 2 \\textasciicircum}$ evaluates to $x^2$. As a special case, $0^0$ evaluates to $1$.  \n\nNote that whenever one of the following things happens:  \n\n- an operation attempts to take a number from an empty stack;  \n- the $\\texttt{\\textasciicircum}$ operation attempts to raise something to a negative power;  \n- the result of an operation overflows the 32-bit signed integer;  \n- or at the end of the evaluation the size of the stack is not equal to one ---  \n\nyou receive a Wrong Answer outcome for the test where it happened. ", "hint": "The example answer to the first test encodes the function $(x-3)^4 + (y + (-5))^2$. Note that it has no local maxima, no plateaus, and just one local minimum.", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2021] Extreme Problem", "background": null, "description": "许多编程竞赛中的题目在某些方面都非常极端。例如：\n- 有些题目需要你在纸上进行大量复杂的数学运算，然后输出一个众所周知的数字，并按输入文件给定的位数进行四舍五入；\n- 有些题目长达四页以上，需要你编写一个模拟系统，跟踪多个特工的多项技能，并为每次任务选择最佳的特工组合；\n- 还有些题目已被证明根本不存在正确解法，但依然被拿来作为比赛题目。\n\n这一次，你将遇到一个同样极端的题目，因为它只有八组可能的测试数据。当然，这个题目也与“极端”有关。\n\n我们考虑定义在 $[-10;10] \\times [-10;10]$ 方格上的两个整数变量的函数。这意味着你只能对 $f(x, y)$ 进行调用，其中 $x$ 和 $y$ 必须是整数，且 $-10 \\le x, y \\le 10$。如果函数 $f$ 在点 $(x, y)$ 满足以下所有条件，则称其在该点有一个“局部极小值”：\n\n- $f(x, y) < f(x-1, y)$；\n- $f(x, y) < f(x+1, y)$；\n- $f(x, y) < f(x, y-1)$；\n- $f(x, y) < f(x, y+1)$。\n\n“局部极大值”的定义类似，只是将不等号方向反过来。如果函数 $f$ 在点 $(x, y)$ 满足下列至少一个条件，则称其在该点有一个“平台”：\n\n- $f(x, y) = f(x-1, y)$；\n- $f(x, y) = f(x+1, y)$；\n- $f(x, y) = f(x, y-1)$；\n- $f(x, y) = f(x, y+1)$。\n\n注意，上述所有函数调用都必须发生在函数定义域内，即 $[-10;10] \\times [-10;10]$ 的方格上。特别地，这意味着边界上的点$\\textbf{不能}$是局部极大值或局部极小值，但仍然可以是平台。\n\n你需要构造一个函数，使其满足输入中指定的以下性质（有或没有，取决于输入）：\n\n- 多个局部极大值；\n- 多个局部极小值；\n- 存在平台。\n\n注意，“多个”指的是“至少两个”。另外，你的函数必须按照特定的方式定义，详见输出部分。", "inputFormat": "输入包含三行。\n\n- 第一行以 $\\texttt{Multiple local maxima:~}$ 开头，以 $\\texttt{Yes}$ 或 $\\texttt{No}$ 结尾，表示你的函数是否应当有多个局部极大值。\n- 第二行以 $\\texttt{Multiple local minima:~}$ 开头，以 $\\texttt{Yes}$ 或 $\\texttt{No}$ 结尾，表示你的函数是否应当有多个局部极小值。\n- 第三行以 $\\texttt{Plateaus:~}$ 开头，以 $\\texttt{Yes}$ 或 $\\texttt{No}$ 结尾，表示你的函数是否应当有平台。", "outputFormat": "输出应为一行，用来定义你的函数。\n\n如果不存在符合要求的函数，输出 $\\texttt{No solution}$。\n\n否则，请使用逆波兰表示法（Reverse Polish Notation, RPN）描述你的函数。逆波兰表示法是一种用栈式机器描述函数的方法：它是一系列操作的序列，其中有些操作将数值压入栈中，有些操作从栈顶取出若干数值，进行运算后将结果压回栈中。\n\n你的函数最多包含 1000 个以单个空格分隔的记号，每个记号可以是以下之一：\n\n- 一个整数常数，范围为 $-9$ 到 $+9$。这会将对应的数字压入栈中。\n- 一个变量，$\\texttt{x}$ 或 $\\texttt{y}$。这会将该变量的值压入栈中。\n- 一个操作符，可以是 $\\texttt{+}$、$\\texttt{-}$、$\\texttt{*}$ 或 $\\texttt{\\textasciicircum}$。星号表示乘法，$\\texttt{\\textasciicircum}$ 表示幂运算。每个操作符会从栈中取出两个数，执行相应运算，并将结果压回栈中。运算顺序为 $\\texttt{9 5 -}$ 计算结果为 4，$\\texttt{x 2 \\textasciicircum}$ 计算结果为 $x^2$。特殊情况 $0^0$ 规定为 $1$。\n\n注意，若发生以下任一情况：\n\n- 某个操作试图从空栈中取数；\n- $\\texttt{\\textasciicircum}$ 操作试图对负指数求幂；\n- 运算结果超出 32 位有符号整数范围；\n- 运算结束后栈中元素数量不为 1——\n\n你在该测试点会被判为 Wrong Answer。", "hint": "第一个测试点的示例答案编码了函数 $(x-3)^4 + (y + (-5))^2$。注意它没有局部极大值，没有平台，且只有一个局部极小值。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13633", "type": "P", "difficulty": 6, "samples": [["5 3 60\n30 0 0\n40 20 0\n30 60 0\n0 0 0\n60 60 1", "1\n1\n249561089\n0\n499122177"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "ICPC", "NWRRC"], "title": "[NWRRC 2021] First to Solve", "background": "", "description": "The famous Forcedeltas Programming Contest features $n$ contestants, $m$ problems, and lasts for $k$ minutes.\n\nFor each contestant $i$ and each problem $j$, an integer $a_{i, j}$ is known. If $a_{i, j} = 0$, it means that contestant $i$ can not solve problem $j$. Otherwise, it means that contestant $i$ can solve problem $j$ in exactly $a_{i, j}$ minutes.\n\nAll contestants will follow the same strategy. Specifically, each contestant will form a list of all problems they can solve, shuffle the list uniformly at random, and solve the problems in that order, until the list ends or the contest is over.\n\nFor example, if the list for contestant $i$ looks like $j_1, j_2, \\ldots$ after shuffling, then they will solve problem $j_1$ at minute $a_{i, j_1}$, problem $j_2$ at minute $a_{i, j_1} + a_{i, j_2}$, and so on. Note that no problem can be solved at minute $k + 1$ or later.\n\nWe'll say that contestant $i$ gets the $\\textit{First to Solve}$ award for problem $j$ if no other contestant solves problem $j$ strictly earlier. In particular, it means that multiple contestants can get the award for the same problem.\n\nFind the expected number of awards each contestant will get, modulo $998\\,244\\,353$ (see the Output section for details).", "inputFormat": "The first line contains three integers $n$, $m$, and $k$ --- the number of contestants, the number of problems, and the length of the contest in minutes ($1 \\le n \\le 500$; $1 \\le m \\le 26$; $1 \\le k \\le 300$).\n\nThe $i$-th of the following $n$ lines contains $m$ integers $a_{i, 1}, a_{i, 2}, \\ldots, a_{i, m}$ ($0 \\le a_{i, j} \\le k$). The $j$-th of these integers denotes the number of minutes required for contestant $i$ to solve problem $j$, or $0$ if contestant $i$ can not solve problem $j$.", "outputFormat": "Print $n$ integers --- the expected number of awards contestants $1, 2, \\ldots, n$ will get, modulo $998\\,244\\,353$.\n\nFormally, let $M = 998\\,244\\,353$. It can be shown that the expected number of awards can be expressed as an irreducible fraction $\\frac{p}{q}$, where $p$ and $q$ are integers and $q \\not \\equiv 0 \\pmod{M}$. Print the integer equal to $p \\cdot q^{-1} \\bmod M$. In other words, print such an integer $x$ that $0 \\le x < M$ and $x \\cdot q \\equiv p \\pmod{M}$.", "hint": "In the example test, contestant $1$ will always get the award for problem $1$, contestant $2$ will always get the award for problem $2$, the expected number of awards contestant $3$ will get is $\\frac{3}{4}$, contestant $4$ will never get any awards, and the expected number of awards contestant $5$ will get is $\\frac{1}{2}$.", "locale": "en", "translations": {"en": {"title": "[NWRRC 2021] First to Solve", "background": "", "description": "The famous Forcedeltas Programming Contest features $n$ contestants, $m$ problems, and lasts for $k$ minutes.\n\nFor each contestant $i$ and each problem $j$, an integer $a_{i, j}$ is known. If $a_{i, j} = 0$, it means that contestant $i$ can not solve problem $j$. Otherwise, it means that contestant $i$ can solve problem $j$ in exactly $a_{i, j}$ minutes.\n\nAll contestants will follow the same strategy. Specifically, each contestant will form a list of all problems they can solve, shuffle the list uniformly at random, and solve the problems in that order, until the list ends or the contest is over.\n\nFor example, if the list for contestant $i$ looks like $j_1, j_2, \\ldots$ after shuffling, then they will solve problem $j_1$ at minute $a_{i, j_1}$, problem $j_2$ at minute $a_{i, j_1} + a_{i, j_2}$, and so on. Note that no problem can be solved at minute $k + 1$ or later.\n\nWe'll say that contestant $i$ gets the $\\textit{First to Solve}$ award for problem $j$ if no other contestant solves problem $j$ strictly earlier. In particular, it means that multiple contestants can get the award for the same problem.\n\nFind the expected number of awards each contestant will get, modulo $998\\,244\\,353$ (see the Output section for details).", "inputFormat": "The first line contains three integers $n$, $m$, and $k$ --- the number of contestants, the number of problems, and the length of the contest in minutes ($1 \\le n \\le 500$; $1 \\le m \\le 26$; $1 \\le k \\le 300$).\n\nThe $i$-th of the following $n$ lines contains $m$ integers $a_{i, 1}, a_{i, 2}, \\ldots, a_{i, m}$ ($0 \\le a_{i, j} \\le k$). The $j$-th of these integers denotes the number of minutes required for contestant $i$ to solve problem $j$, or $0$ if contestant $i$ can not solve problem $j$.", "outputFormat": "Print $n$ integers --- the expected number of awards contestants $1, 2, \\ldots, n$ will get, modulo $998\\,244\\,353$.\n\nFormally, let $M = 998\\,244\\,353$. It can be shown that the expected number of awards can be expressed as an irreducible fraction $\\frac{p}{q}$, where $p$ and $q$ are integers and $q \\not \\equiv 0 \\pmod{M}$. Print the integer equal to $p \\cdot q^{-1} \\bmod M$. In other words, print such an integer $x$ that $0 \\le x < M$ and $x \\cdot q \\equiv p \\pmod{M}$.", "hint": "In the example test, contestant $1$ will always get the award for problem $1$, contestant $2$ will always get the award for problem $2$, the expected number of awards contestant $3$ will get is $\\frac{3}{4}$, contestant $4$ will never get any awards, and the expected number of awards contestant $5$ will get is $\\frac{1}{2}$.", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2021] First to Solve", "background": null, "description": "著名的 Forcedeltas 编程竞赛有 $n$ 名参赛者，$m$ 道题目，比赛持续 $k$ 分钟。\n\n对于每位参赛者 $i$ 和每道题目 $j$，已知一个整数 $a_{i, j}$。如果 $a_{i, j} = 0$，表示参赛者 $i$ 无法解出题目 $j$。否则，表示参赛者 $i$ 恰好需要 $a_{i, j}$ 分钟解出题目 $j$。\n\n所有参赛者都遵循相同的策略。具体来说，每位参赛者会列出所有自己能解出的题目，将该列表等概率随机打乱，然后按顺序依次解题，直到列表结束或比赛结束。\n\n例如，若参赛者 $i$ 打乱后的题目列表为 $j_1, j_2, \\ldots$，则他会在第 $a_{i, j_1}$ 分钟解出题目 $j_1$，在第 $a_{i, j_1} + a_{i, j_2}$ 分钟解出题目 $j_2$，以此类推。注意，不能在第 $k+1$ 分钟或更晚解出题目。\n\n我们说参赛者 $i$ 获得题目 $j$ 的“最先解出”奖（First to Solve award），当且仅当没有其他参赛者比他更早解出题目 $j$。特别地，多个参赛者可以同时获得同一道题的该奖项。\n\n请计算每位参赛者期望获得的奖项数，答案对 $998\\,244\\,353$ 取模（具体见输出格式）。", "inputFormat": "第一行包含三个整数 $n$、$m$ 和 $k$，分别表示参赛者人数、题目数量和比赛时长（$1 \\le n \\le 500$；$1 \\le m \\le 26$；$1 \\le k \\le 300$）。\n\n接下来的 $n$ 行，每行包含 $m$ 个整数 $a_{i, 1}, a_{i, 2}, \\ldots, a_{i, m}$（$0 \\le a_{i, j} \\le k$）。其中第 $j$ 个整数表示参赛者 $i$ 解题 $j$ 所需的分钟数，若为 $0$ 则表示无法解出该题。", "outputFormat": "输出 $n$ 个整数，第 $i$ 个整数表示第 $i$ 位参赛者期望获得的奖项数，对 $998\\,244\\,353$ 取模。\n\n形式化地，设 $M = 998\\,244\\,353$。可以证明，期望奖项数可表示为不可约分数 $\\frac{p}{q}$，其中 $p$、$q$ 为整数且 $q \\not\\equiv 0 \\pmod{M}$。请输出满足 $0 \\le x < M$ 且 $x \\cdot q \\equiv p \\pmod{M}$ 的整数 $x$。", "hint": "在样例测试中，第 $1$ 位参赛者总能获得题目 $1$ 的奖项，第 $2$ 位参赛者总能获得题目 $2$ 的奖项，第 $3$ 位参赛者期望获得的奖项数为 $\\frac{3}{4}$，第 $4$ 位参赛者无法获得任何奖项，第 $5$ 位参赛者期望获得的奖项数为 $\\frac{1}{2}$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13634", "type": "P", "difficulty": 0, "samples": [["4\n0 0\n1 0\n1 1\n0 1", "1"], ["3\n0 0\n1 0\n0 1", "2"], ["4\n0 0\n2 0\n4 4\n0 2", "1.5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2021] Grand Center", "background": "", "description": "There is no generally accepted standard of calculating the center point of some territory. This fact is widely used to promote different places. You can always find a meaning for the word \"center\", according to which your city would be the center of the country! Gloria decided to develop one universal standard and find the true center.\n\nConsider any point inside a convex polygon, and any direction. There is a unique segment that passes through the point, is parallel to the direction, and has both ends on the boundary of the polygon. The point divides the segment into two parts. The ${\\it direction\\ imbalance}$ is defined as the ratio of the length of the bigger part to the length of the smaller part. The ${\\it imbalance}$ of the point is the maximum direction imbalance over all directions. \n\nGloria finds this value interesting, and wants to define the ${\\it Grand\\ center}$ of a convex polygon as the point inside it which has the minimum possible imbalance. Help her to calculate the imbalance of the Grand center of a given polygon.", "inputFormat": "The first line contains a single integer $n$ --- the number of vertices of the given convex polygon ($3 \\le n \\le 10\\,000$).\n\nThe $i$-th of the following $n$ lines contains two integers $x_i$ and $y_i$ --- the coordinates of the $i$-th polygon vertex ($-10^5 \\le x_i, y_i \\le 10^5$). The $x$-axis runs from left to right, and the $y$-axis runs from bottom to top. The vertices are numbered in counterclockwise order. The polygon is strictly convex: all internal angles of the polygon are strictly smaller than $\\pi$.", "outputFormat": "Print one real number --- the imbalance of the Grand center of the given polygon. Your answer will be considered correct if its absolute or relative error doesn't exceed $10^{-6}$.", "hint": "The following pictures illustrate all three example tests:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/irmla27w.png)\n\nIn the first example test, for the center of the square, the direction imbalance is equal to $1$ for any direction, i.e. any segment is split into two equal parts.\n\nIn the second example test, it's well-known that the median intersection point of a triangle splits the medians in a $2:1$ ratio. In the given triangle, the medians define the most imbalanced directions for that point. For any other point, the imbalance is even bigger.\n\nIn the third example test, the Grand center is located at $(1.6, 1.6)$. ", "locale": "en", "translations": {"en": {"title": "[NWRRC 2021] Grand Center", "background": "", "description": "There is no generally accepted standard of calculating the center point of some territory. This fact is widely used to promote different places. You can always find a meaning for the word \"center\", according to which your city would be the center of the country! Gloria decided to develop one universal standard and find the true center.\n\nConsider any point inside a convex polygon, and any direction. There is a unique segment that passes through the point, is parallel to the direction, and has both ends on the boundary of the polygon. The point divides the segment into two parts. The ${\\it direction\\ imbalance}$ is defined as the ratio of the length of the bigger part to the length of the smaller part. The ${\\it imbalance}$ of the point is the maximum direction imbalance over all directions. \n\nGloria finds this value interesting, and wants to define the ${\\it Grand\\ center}$ of a convex polygon as the point inside it which has the minimum possible imbalance. Help her to calculate the imbalance of the Grand center of a given polygon.", "inputFormat": "The first line contains a single integer $n$ --- the number of vertices of the given convex polygon ($3 \\le n \\le 10\\,000$).\n\nThe $i$-th of the following $n$ lines contains two integers $x_i$ and $y_i$ --- the coordinates of the $i$-th polygon vertex ($-10^5 \\le x_i, y_i \\le 10^5$). The $x$-axis runs from left to right, and the $y$-axis runs from bottom to top. The vertices are numbered in counterclockwise order. The polygon is strictly convex: all internal angles of the polygon are strictly smaller than $\\pi$.", "outputFormat": "Print one real number --- the imbalance of the Grand center of the given polygon. Your answer will be considered correct if its absolute or relative error doesn't exceed $10^{-6}$.", "hint": "The following pictures illustrate all three example tests:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/irmla27w.png)\n\nIn the first example test, for the center of the square, the direction imbalance is equal to $1$ for any direction, i.e. any segment is split into two equal parts.\n\nIn the second example test, it's well-known that the median intersection point of a triangle splits the medians in a $2:1$ ratio. In the given triangle, the medians define the most imbalanced directions for that point. For any other point, the imbalance is even bigger.\n\nIn the third example test, the Grand center is located at $(1.6, 1.6)$. ", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2021] Grand Center", "background": null, "description": "对于某个区域的中心点的计算方法，目前并没有公认的标准。这一事实常常被用来宣传不同的地方。你总能找到一种“中心”的定义方式，使得你的城市成为国家的中心！Gloria 决定制定一个通用的标准，并找到真正的中心。\n\n考虑一个凸多边形内部的任意一点，以及任意一个方向。存在唯一一条经过该点、与该方向平行、且两端都在多边形边界上的线段。该点将这条线段分成两部分。定义该方向下的“不平衡度”为较长部分长度与较短部分长度的比值。该点的“不平衡度”定义为所有方向下最大的不平衡度。\n\nGloria 对这个值很感兴趣，并希望将凸多边形内不平衡度最小的点定义为该多边形的“Grand center”。请你帮她计算给定多边形的 Grand center 的不平衡度。", "inputFormat": "第一行包含一个整数 $n$，表示给定凸多边形的顶点数（$3 \\le n \\le 10\\,000$）。\n\n接下来的 $n$ 行，每行包含两个整数 $x_i$ 和 $y_i$，表示第 $i$ 个顶点的坐标（$-10^5 \\le x_i, y_i \\le 10^5$）。$x$ 轴从左到右，$y$ 轴从下到上。顶点按逆时针顺序给出。该多边形是严格凸的：所有内角都严格小于 $\\pi$。", "outputFormat": "输出一个实数，表示该多边形 Grand center 的不平衡度。若你的答案的绝对误差或相对误差不超过 $10^{-6}$，则视为正确。", "hint": "下图展示了三个样例测试的情况：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/irmla27w.png)\n\n在第一个样例中，对于正方形的中心点，任意方向下的不平衡度均为 $1$，即任意线段都被平分。\n\n在第二个样例中，众所周知，三角形的中线交点将中线分成 $2:1$ 的比例。在给定的三角形中，中线方向对应该点最大的不平衡度。对于其他点，不平衡度会更大。\n\n在第三个样例中，Grand center 位于 $(1.6, 1.6)$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13635", "type": "P", "difficulty": 0, "samples": [["3\n6\n10\n19", "1\n3\n9"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "ICPC", "NWRRC"], "title": "[NWRRC 2021] Halfway There", "background": "", "description": "Given an integer $n$, find the median of the list of all integers from $1$ to $n - 1$ that are coprime with $n$.\n\nRecall that integers $a$ and $b$ are called $\\textit{coprime}$ if their greatest common divisor is 1. The $\\textit{median}$ of a list $L$ is defined to be the $\\frac {|L|}{2}$-th element of $L$ if $|L|$ is even, and the $\\frac {|L|+1}{2}$-th element of $L$ if $|L|$ is odd. Here $L$ is assumed to be sorted in ascending order, $|L|$ denotes the length of $L$, and indices are $1$-based.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^3$). Description of the test cases follows.\n\nThe only line of each test case contains a single integer $n$ ($2 \\le n \\le 10^{18}$).", "outputFormat": "For each test case, print a single integer --- the median of the list of integers from $1$ to $n - 1$ that are coprime with $n$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NWRRC 2021] Halfway There", "background": "", "description": "Given an integer $n$, find the median of the list of all integers from $1$ to $n - 1$ that are coprime with $n$.\n\nRecall that integers $a$ and $b$ are called $\\textit{coprime}$ if their greatest common divisor is 1. The $\\textit{median}$ of a list $L$ is defined to be the $\\frac {|L|}{2}$-th element of $L$ if $|L|$ is even, and the $\\frac {|L|+1}{2}$-th element of $L$ if $|L|$ is odd. Here $L$ is assumed to be sorted in ascending order, $|L|$ denotes the length of $L$, and indices are $1$-based.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^3$). Description of the test cases follows.\n\nThe only line of each test case contains a single integer $n$ ($2 \\le n \\le 10^{18}$).", "outputFormat": "For each test case, print a single integer --- the median of the list of integers from $1$ to $n - 1$ that are coprime with $n$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2021] Halfway There", "background": null, "description": "给定一个整数 $n$，请找出从 $1$ 到 $n-1$ 中所有与 $n$ 互质的整数所组成的列表的中位数。\n\n回忆一下，如果两个整数 $a$ 和 $b$ 的最大公约数为 $1$，则称它们是互质的。列表 $L$ 的中位数定义为：若 $|L|$ 为偶数，则为第 $\\frac{|L|}{2}$ 个元素；若 $|L|$ 为奇数，则为第 $\\frac{|L|+1}{2}$ 个元素。这里 $L$ 假定为升序排列，$|L|$ 表示 $L$ 的长度，且下标从 $1$ 开始。", "inputFormat": "每组测试数据包含多组测试用例。第一行包含一个整数 $t$（$1 \\le t \\le 10^3$），表示测试用例的数量。\n\n接下来的每组测试用例包含一行，一个整数 $n$（$2 \\le n \\le 10^{18}$）。", "outputFormat": "对于每组测试用例，输出一个整数，表示从 $1$ 到 $n-1$ 中所有与 $n$ 互质的整数所组成的列表的中位数。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
