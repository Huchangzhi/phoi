{"pid": "P5975", "type": "P", "difficulty": 5, "samples": [["6 4\n2 1 \n4 1 \n5 1 \n5 4 \n7 1 \n6 4", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2009", "CEOI（中欧）"], "title": "[CEOI 2009] photo", "background": "", "description": "平面上有若干个点，现在要求用最少的底边在 $X$ 轴上且面积小于等于 $A$ 的矩形覆盖所有点，这些矩形可以重叠。 矩形顶点不必是整点。", "inputFormat": "第一行两个整数 $N,A$。 \n\n以下 $N$ 行输入点坐标。", "outputFormat": "最少的矩形个数。", "hint": "对于 $100\\%$ 的数据，$1\\le N\\le 100$，$1\\le A\\le 2\\times 10^6$。坐标范围在 $[0,100000]$ 之间。\n\n------\n\n## 样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8p4pjwmq.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2009] photo", "background": "", "description": "平面上有若干个点，现在要求用最少的底边在 $X$ 轴上且面积小于等于 $A$ 的矩形覆盖所有点，这些矩形可以重叠。 矩形顶点不必是整点。", "inputFormat": "第一行两个整数 $N,A$。 \n\n以下 $N$ 行输入点坐标。", "outputFormat": "最少的矩形个数。", "hint": "对于 $100\\%$ 的数据，$1\\le N\\le 100$，$1\\le A\\le 2\\times 10^6$。坐标范围在 $[0,100000]$ 之间。\n\n------\n\n## 样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8p4pjwmq.png)", "locale": "zh-CN"}}}
{"pid": "P5976", "type": "P", "difficulty": 4, "samples": [["10 10\n3\nW 3 6 3\nB 6 4 2\nW 3 3 2", "30 9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "CEOI（中欧）"], "title": "[CEOI 2008] Dominance", "background": "", "description": "给出一个宽为 $W$，高为 $H$ 的矩形 。\n \n在它上面有两种点， $black$ 及 $white$。 每个点都有自己的辐射范围。对于其它的点如果它受到白点的辐射多于黑色的，则为白点，反之亦然，如果相同的话则中立。\n\n现给出白点及黑色的坐标及各自的辐射范围，问最后白色点一共有多少个，黑色点共有多少个 。", "inputFormat": "第一行给出 $W$ 和 $H$，左下角坐标为 $(0,0)$, 右上角为 $(W-1,H-1)$。  \n\n第二行给出数字 $N$，代表有多少个点。 \n\n接下来 $N$ 行，每行先给出点的属性，再给出坐标，再给出辐射范围(在$[0, 5\\times 10^8)$)", "outputFormat": "两个数，分别代表白色点有多少个，黑色点有多少个 。", "hint": "对于 $100\\%$ 的数据，$1 \\le  W,H \\le 10^9$，$0 \\le  N \\le  3\\times 10^3$。\n\n\n-----\n\n### 样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hfu3bgfx.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2008] Dominance", "background": "", "description": "给出一个宽为 $W$，高为 $H$ 的矩形 。\n \n在它上面有两种点， $black$ 及 $white$。 每个点都有自己的辐射范围。对于其它的点如果它受到白点的辐射多于黑色的，则为白点，反之亦然，如果相同的话则中立。\n\n现给出白点及黑色的坐标及各自的辐射范围，问最后白色点一共有多少个，黑色点共有多少个 。", "inputFormat": "第一行给出 $W$ 和 $H$，左下角坐标为 $(0,0)$, 右上角为 $(W-1,H-1)$。  \n\n第二行给出数字 $N$，代表有多少个点。 \n\n接下来 $N$ 行，每行先给出点的属性，再给出坐标，再给出辐射范围(在$[0, 5\\times 10^8)$)", "outputFormat": "两个数，分别代表白色点有多少个，黑色点有多少个 。", "hint": "对于 $100\\%$ 的数据，$1 \\le  W,H \\le 10^9$，$0 \\le  N \\le  3\\times 10^3$。\n\n\n-----\n\n### 样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hfu3bgfx.png)", "locale": "zh-CN"}}}
{"pid": "P5977", "type": "P", "difficulty": 6, "samples": [["4 3\n800 300\n200 200\n200 700\n600 700\n400 300\n600 500\n800 900", "171"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "计算几何", "2008", "CEOI（中欧）", "最短路", "凸包"], "title": "[CEOI 2008] Fence", "background": "", "description": "在一个大小为 $1000\\times 1000$ 的区域中，有 $n$ 个固定点, $m$ 棵树 。\n\n现在你要建一个围栏来保护树，建它的费用为你选用的固定点的个数 $\\times 20$ +你没有圈进围栏的树 $\\times 111$。\n\n现在希望这个值越小越好，求最小值。", "inputFormat": "第一行给出 $n,m$。\n\n接下来的 $n$ 行，给出固定的坐标。\n\n接下来的 $m$ 行，给出树的坐标。", "outputFormat": "输出最小费用。\n", "hint": "对于 $100\\%$ 的数据，$3\\le N,M\\le 100$。\n\n----\n\n## 样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7vebu0t2.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2008] Fence", "background": "", "description": "在一个大小为 $1000\\times 1000$ 的区域中，有 $n$ 个固定点, $m$ 棵树 。\n\n现在你要建一个围栏来保护树，建它的费用为你选用的固定点的个数 $\\times 20$ +你没有圈进围栏的树 $\\times 111$。\n\n现在希望这个值越小越好，求最小值。", "inputFormat": "第一行给出 $n,m$。\n\n接下来的 $n$ 行，给出固定的坐标。\n\n接下来的 $m$ 行，给出树的坐标。", "outputFormat": "输出最小费用。\n", "hint": "对于 $100\\%$ 的数据，$3\\le N,M\\le 100$。\n\n----\n\n## 样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7vebu0t2.png)", "locale": "zh-CN"}}}
{"pid": "P5978", "type": "P", "difficulty": 4, "samples": [["8 10\n7 3 5 12 2 7 3 4", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "CEOI（中欧）"], "title": "[CEOI 2018] Global warming", "background": null, "description": "给定 $n$，你可以将任意 $a_l$ 至 $a_r$（$1\\le l\\le r\\le n$）每一个元素加上一个 $d$（$-x\\le d\\le x$），求 $a$ 数组的最大严格上升子序列长度。", "inputFormat": "第一行两个整数 $n,x$。\n\n第二行 $n$ 个整数表示 $a_1$ 至 $a_n$。", "outputFormat": "一个数，即 $a$ 数组的最大严格上升子序列长度。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 2\\times 10^5$，$0\\leq x\\leq10^9$，$1\\leq a_i\\leq10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2018] Global warming", "background": null, "description": "给定 $n$，你可以将任意 $a_l$ 至 $a_r$（$1\\le l\\le r\\le n$）每一个元素加上一个 $d$（$-x\\le d\\le x$），求 $a$ 数组的最大严格上升子序列长度。", "inputFormat": "第一行两个整数 $n,x$。\n\n第二行 $n$ 个整数表示 $a_1$ 至 $a_n$。", "outputFormat": "一个数，即 $a$ 数组的最大严格上升子序列长度。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 2\\times 10^5$，$0\\leq x\\leq10^9$，$1\\leq a_i\\leq10^9$。", "locale": "zh-CN"}}}
{"pid": "P5979", "type": "P", "difficulty": 7, "samples": [["9\n1 4\n2 5\n3 4\n1 5\n1 1\n2 5\n3 5\n1 3\n1 1", "5 2"], ["2\n1 1\n2 2", "NIE"]], "limits": {"time": [7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "线段树", "cdq 分治", "动态规划优化", "扫描线", "PA（波兰）"], "title": "[PA 2014] Druzyny", "background": "", "description": "体育课上，$n$ 个小朋友排成一行（从 $1$ 到 $n$ 编号），老师想把他们分成若干组，每一组都包含编号连续的一段小朋友，每个小朋友属于且仅属于一个组。\n\n第 $i$ 个小朋友希望它所在的组的人数不多于 $d_i$，不少于 $c_i$，否则他就会不满意。\n\n在所有小朋友都满意的前提下，求可以分成的组的数目的最大值，以及有多少种分组方案能达到最大值。", "inputFormat": "第一行一个整数 $n$，表示小朋友的数目。\n\n接下来 $n$ 行，每行两个整数 $c_i,d_i$，表示 $i$ 所在组的人数的最小值和最大值。", "outputFormat": "如果不存在这样的方案，仅输出一行  `NIE`。\n\n否则输出一行包含两个整数，组的数目的最大值、方案数量。（方案数量对 $10^9+7$ 取模）", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^6$，$1\\le c_i\\le d_i\\le n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2014] Druzyny", "background": "", "description": "体育课上，$n$ 个小朋友排成一行（从 $1$ 到 $n$ 编号），老师想把他们分成若干组，每一组都包含编号连续的一段小朋友，每个小朋友属于且仅属于一个组。\n\n第 $i$ 个小朋友希望它所在的组的人数不多于 $d_i$，不少于 $c_i$，否则他就会不满意。\n\n在所有小朋友都满意的前提下，求可以分成的组的数目的最大值，以及有多少种分组方案能达到最大值。", "inputFormat": "第一行一个整数 $n$，表示小朋友的数目。\n\n接下来 $n$ 行，每行两个整数 $c_i,d_i$，表示 $i$ 所在组的人数的最小值和最大值。", "outputFormat": "如果不存在这样的方案，仅输出一行  `NIE`。\n\n否则输出一行包含两个整数，组的数目的最大值、方案数量。（方案数量对 $10^9+7$ 取模）", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^6$，$1\\le c_i\\le d_i\\le n$。", "locale": "zh-CN"}}}
{"pid": "P5980", "type": "P", "difficulty": 6, "samples": [["5\n2\n2 1 4\n2 5 2\n2\n1 4 3\n1 5 4\n2\n1 5 7\n1 7 5\n2\n1 4 1\n1 2 5\n3\n2 6 4\n1 2 3\n3 4 5", "TAK\nNIE\nTAK\nNIE\nTAK"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2019", "向量", "凸包", "PA（波兰）"], "title": "[PA 2019] Herbata", "background": null, "description": "你有无穷多个容量无限的杯子以及 $n$ 杯水，第 $i$ 杯水的体积为 $l_i$，温度为 $a_i$。\n\n你可以做无限次操作，每次操作是下面两种操作之一：\n1. 选择一杯水，假设它的体积为 $V$，温度为 $T$，那么你可以将其倒入若干个空杯中，使得每一杯的水的温度都为 $T$，且体积之和等于 $V$，注意体积可以是任意非负实数。\n\n2. 选择两杯水，假设一杯的体积为 $V_a$，温度为 $T_a$，另一杯的体积为 $V_b$，温度为 $T_b$，那么你可以将这两杯水混合为一杯体积为 $V_a+V_b$，温度为 $\\dfrac{V_a\\times T_a+V_b\\times T_b}{V_a+V_b}$的水。\n\n你的目标进行若干次操作，使得操作完毕后，对于所有的 $i(1\\le i\\le n)$ 都有第 $i$ 杯水的体积等于 $l_i$，温度等于 $b_i$。请写一个程序判断是否有解。", "inputFormat": "第一行包含一个正整数 $T$，表示测试数据的组数。\n每组测试数据第一行包含一个正整数 $n$。\n接下来 $n$ 行，每行三个正整数 $l_i,a_i,b_i$。", "outputFormat": "对于每组数据输出一行，如果有解，输出 `TAK`，否则输出 `NIE`。", "hint": "对于 $100\\%$ 的数据，$1\\le T\\le 10^5$，$1\\le n\\le 10^5$，$1\\le l_i,a_i,b_i\\le 10^6$，输入数据保证所有的 $n$ 加起来不超过 $10^6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2019] Herbata", "background": null, "description": "你有无穷多个容量无限的杯子以及 $n$ 杯水，第 $i$ 杯水的体积为 $l_i$，温度为 $a_i$。\n\n你可以做无限次操作，每次操作是下面两种操作之一：\n1. 选择一杯水，假设它的体积为 $V$，温度为 $T$，那么你可以将其倒入若干个空杯中，使得每一杯的水的温度都为 $T$，且体积之和等于 $V$，注意体积可以是任意非负实数。\n\n2. 选择两杯水，假设一杯的体积为 $V_a$，温度为 $T_a$，另一杯的体积为 $V_b$，温度为 $T_b$，那么你可以将这两杯水混合为一杯体积为 $V_a+V_b$，温度为 $\\dfrac{V_a\\times T_a+V_b\\times T_b}{V_a+V_b}$的水。\n\n你的目标进行若干次操作，使得操作完毕后，对于所有的 $i(1\\le i\\le n)$ 都有第 $i$ 杯水的体积等于 $l_i$，温度等于 $b_i$。请写一个程序判断是否有解。", "inputFormat": "第一行包含一个正整数 $T$，表示测试数据的组数。\n每组测试数据第一行包含一个正整数 $n$。\n接下来 $n$ 行，每行三个正整数 $l_i,a_i,b_i$。", "outputFormat": "对于每组数据输出一行，如果有解，输出 `TAK`，否则输出 `NIE`。", "hint": "对于 $100\\%$ 的数据，$1\\le T\\le 10^5$，$1\\le n\\le 10^5$，$1\\le l_i,a_i,b_i\\le 10^6$，输入数据保证所有的 $n$ 加起来不超过 $10^6$。", "locale": "zh-CN"}}}
{"pid": "P5981", "type": "P", "difficulty": 7, "samples": [["2\n3 1 0 1\n4 0 0 0 1\n2 0 1\n1 1", "6 0 1 0 1 0 1\n2 0 1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432, 786432]}, "tags": ["2019", "PA（波兰）"], "title": "[PA 2019] Iloczyny Fibonacciego", "background": "", "description": "定义斐波那契数列为 $F_1=1,F_2=2,F_i=F_{i-1}+F_{i-2}(i\\ge 3)$。\n对于任意一个正整数 $x$，我们总能将 $x$ 写成唯一的斐波那契表示 $(b_1,b_2,...,b_n)$，满足：\n\n1. $b_1\\times F_1+b_2\\times F_2+...+b_n\\times F_n=x$。\n2. 对于任意的 $i(1\\le i<n)$ 都有 $b_i=0$ 或 $b_i=1$；对于 $b_n$ 有 $b_n=1$。\n3. 对于任意的 $i(1\\le i<n)$ 都有 $b_i\\times b_{i+1}=0$。\n\n比如 $2=(0,1),4=(1,0,1),5=(0,0,0,1),20=(0,1,0,1,0,1)=F[2]+F[4]+F[6]=2+5+13$。\n\n给定两个斐波那契表示的正整数 $A$ 和 $B$，请输出 $A\\times B$ 的斐波那契表示。", "inputFormat": "第一行包含一个正整数 $T$，表示测试数据的组数。\n\n每组测试数据包含两行，分别描述 $A$ 和 $B$ 的斐波那契表示。每行首先是一个正整数 $n$，然后 $n$ 个非负整数 $b_1,b_2,...,b_n$。\n", "outputFormat": "对于每组数据输出一行，按照输入格式输出 $A\\times B$的斐波那契表示。", "hint": "对于 $100\\%$ 的数据，$1\\le T\\le 10^3$，输入数据保证所有的 $n$ 加起来不超过 $10^6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2019] Iloczyny Fibonacciego", "background": "", "description": "定义斐波那契数列为 $F_1=1,F_2=2,F_i=F_{i-1}+F_{i-2}(i\\ge 3)$。\n对于任意一个正整数 $x$，我们总能将 $x$ 写成唯一的斐波那契表示 $(b_1,b_2,...,b_n)$，满足：\n\n1. $b_1\\times F_1+b_2\\times F_2+...+b_n\\times F_n=x$。\n2. 对于任意的 $i(1\\le i<n)$ 都有 $b_i=0$ 或 $b_i=1$；对于 $b_n$ 有 $b_n=1$。\n3. 对于任意的 $i(1\\le i<n)$ 都有 $b_i\\times b_{i+1}=0$。\n\n比如 $2=(0,1),4=(1,0,1),5=(0,0,0,1),20=(0,1,0,1,0,1)=F[2]+F[4]+F[6]=2+5+13$。\n\n给定两个斐波那契表示的正整数 $A$ 和 $B$，请输出 $A\\times B$ 的斐波那契表示。", "inputFormat": "第一行包含一个正整数 $T$，表示测试数据的组数。\n\n每组测试数据包含两行，分别描述 $A$ 和 $B$ 的斐波那契表示。每行首先是一个正整数 $n$，然后 $n$ 个非负整数 $b_1,b_2,...,b_n$。\n", "outputFormat": "对于每组数据输出一行，按照输入格式输出 $A\\times B$的斐波那契表示。", "hint": "对于 $100\\%$ 的数据，$1\\le T\\le 10^3$，输入数据保证所有的 $n$ 加起来不超过 $10^6$。", "locale": "zh-CN"}}}
{"pid": "P5982", "type": "P", "difficulty": 6, "samples": [["5\n2 10110\n0 11010\n1 00000", "19"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "排列组合", "前缀和", "PA（波兰）"], "title": "[PA 2019] Trzy kule", "background": "", "description": "对于两个长度为 $n$ 的 $01$ 串 $a_{1..n},b_{1..n}$，定义它们的距离 $\\operatorname{d(a,b)}=|a_1-b_1|+|a_2-b_2|+...+|a_n-b_n|$。\n\n给定三个长度为 $n$的 $01$ 串 $s_1,s_2,s_3$以及三个非负整数 $r_1,r_2,r_3(0\\le r_i\\le n)$，问有多少个长度为 $n$ 的 $01$ 串 $S$满足$\\operatorname{d(S,s[1])}\\le r_1,\\operatorname{d(S,s[2])}\\le r_2,\\operatorname{d(S,s[3])}\\le r_3$ 这三个不等式中至少有一个成立。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行一个非负整数 $r_1$，然后一个长度为 $n$ 的 $01$ 串 $s_1$。\n\n第三行一个非负整数 $r_2$，然后一个长度为 $n$ 的 $01$ 串 $s_2$。\n\n第四行一个非负整数 $r_3$，然后一个长度为 $n$  的 $01$ 串 $s_3$。", "outputFormat": "输出一行一个整数，即满足条件的 $S$ 的数量模 $10^9+7$。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^4$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2019] Trzy kule", "background": "", "description": "对于两个长度为 $n$ 的 $01$ 串 $a_{1..n},b_{1..n}$，定义它们的距离 $\\operatorname{d(a,b)}=|a_1-b_1|+|a_2-b_2|+...+|a_n-b_n|$。\n\n给定三个长度为 $n$的 $01$ 串 $s_1,s_2,s_3$以及三个非负整数 $r_1,r_2,r_3(0\\le r_i\\le n)$，问有多少个长度为 $n$ 的 $01$ 串 $S$满足$\\operatorname{d(S,s[1])}\\le r_1,\\operatorname{d(S,s[2])}\\le r_2,\\operatorname{d(S,s[3])}\\le r_3$ 这三个不等式中至少有一个成立。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行一个非负整数 $r_1$，然后一个长度为 $n$ 的 $01$ 串 $s_1$。\n\n第三行一个非负整数 $r_2$，然后一个长度为 $n$ 的 $01$ 串 $s_2$。\n\n第四行一个非负整数 $r_3$，然后一个长度为 $n$  的 $01$ 串 $s_3$。", "outputFormat": "输出一行一个整数，即满足条件的 $S$ 的数量模 $10^9+7$。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^4$。", "locale": "zh-CN"}}}
{"pid": "P5983", "type": "P", "difficulty": 6, "samples": [["3 5 7\n0 1 123\n1 0 0\n4 8 0\n2 2 16\n2 3 0\n18 19 17\n3 0 0", "NIE\nTAK\nNIE\nTAK\nNIE\nTAK\nNIE"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "PA（波兰）"], "title": "[PA 2019] Osady i warownie 2", "background": "", "description": "$n\\times m$ 的网格，从上到下依次为第 $0$ 到 $n-1$ 行，从左到右依次为第 $0$ 到 $m-1$ 列，每个点都不是障碍格。\n\n定义一条从起点 $(0,0)$ 到终点 $(n-1,m-1)$ 的路径是合法的，当且仅当这条路径经过恰好 $n+m-1$ 个格子(包括起点和终点)，且每一步要么往右走一格，要么往下走一格。当然，这条路径不能经过障碍格(包括起点和终点)。\n\n你有一个 $int$ 变量 $v=0$，你现在需要模拟 $k$ 次操作，每次操作会给出三个非负整数 $r,c,z$，令 $x=(r \\operatorname{xor}\n v)\\bmod n,y=(c \\operatorname{xor}\n v)\\bmod m$：\n1. 如果 $(x,y)$ 是障碍格，那么忽略这次操作，输出 `NIE`。\n2. 否则如果将 $(x,y)$ 变成障碍格后仍然存在合法路径，那么将 $(x,y)$ 变成障碍格，输出 `NIE`。\n3. 否则如果将 $(x,y)$ 变成障碍格后不存在合法路径，那么输出 `TAK`，并将 $v $ 修改为 $v \\operatorname{xor} z$。", "inputFormat": "第一行三个正整数 $n,m,k$。\n\n接下来 $k$ 行，每行三个非负整数 $r,c,z$。", "outputFormat": "对于每个操作输出一行 `TAK` 或 `NIE`。", "hint": "对于 $100\\%$ 的数据,$2\\le n,m\\le 10^5$， $1\\le k\\le 10^6$，$0\\le r,c,z<2^{20}$。\n\n----\n\n\n### 解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/e5k1plm4.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2019] Osady i warownie 2", "background": "", "description": "$n\\times m$ 的网格，从上到下依次为第 $0$ 到 $n-1$ 行，从左到右依次为第 $0$ 到 $m-1$ 列，每个点都不是障碍格。\n\n定义一条从起点 $(0,0)$ 到终点 $(n-1,m-1)$ 的路径是合法的，当且仅当这条路径经过恰好 $n+m-1$ 个格子(包括起点和终点)，且每一步要么往右走一格，要么往下走一格。当然，这条路径不能经过障碍格(包括起点和终点)。\n\n你有一个 $int$ 变量 $v=0$，你现在需要模拟 $k$ 次操作，每次操作会给出三个非负整数 $r,c,z$，令 $x=(r \\operatorname{xor}\n v)\\bmod n,y=(c \\operatorname{xor}\n v)\\bmod m$：\n1. 如果 $(x,y)$ 是障碍格，那么忽略这次操作，输出 `NIE`。\n2. 否则如果将 $(x,y)$ 变成障碍格后仍然存在合法路径，那么将 $(x,y)$ 变成障碍格，输出 `NIE`。\n3. 否则如果将 $(x,y)$ 变成障碍格后不存在合法路径，那么输出 `TAK`，并将 $v $ 修改为 $v \\operatorname{xor} z$。", "inputFormat": "第一行三个正整数 $n,m,k$。\n\n接下来 $k$ 行，每行三个非负整数 $r,c,z$。", "outputFormat": "对于每个操作输出一行 `TAK` 或 `NIE`。", "hint": "对于 $100\\%$ 的数据,$2\\le n,m\\le 10^5$， $1\\le k\\le 10^6$，$0\\le r,c,z<2^{20}$。\n\n----\n\n\n### 解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/e5k1plm4.png)", "locale": "zh-CN"}}}
{"pid": "P5984", "type": "P", "difficulty": 7, "samples": [["5 8\n1 2 1\n3 1 3\n3 4 1\n5 3 2", "135"]], "limits": {"time": [7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "PA（波兰）"], "title": "[PA 2019] Podatki drogowe", "background": "", "description": "给定一棵 $n$ 个点的无根树，点的编号为 $1$ 到 $n$，边的边权均为 $n$ 的正整数次幂。\n定义 $u$ 到 $v$ 的距离 $\\operatorname{d(u,v)}$ 为 $u$ 和 $v$ 在树上的简单路径经过的边的边权之和。\n\n给定 $k$，请在 $\\dfrac{n\\times (n-1)}{2}$ 个 $\\operatorname{d(u,v)}(1\\le u<v\\le n)$ 中找到第 $k$ 小的值。", "inputFormat": "第一行两个正整数 $n,k$。\n\n接下来 $n-1$ 行，每行三个正整数 $x,y,z(1\\le x,y,z\\le n)$，表示一条连接 $x$ 和 $y$ 的树边，其边权为 $n$ 的 $z$ 次方。", "outputFormat": "输出一行一个整数，即第 $k$ 小的值对 $10^9+7$ 取模的结果。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 2.5\\times 10^4$，$1\\le k\\le \\dfrac{n*(n-1)}{2}$。\n\n\n----\n\n\n\n### 样例解释：\n\n所有的 $d$ 排序后依次为： $5,5,25,30,125,130,130,135,150,155$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2019] Podatki drogowe", "background": "", "description": "给定一棵 $n$ 个点的无根树，点的编号为 $1$ 到 $n$，边的边权均为 $n$ 的正整数次幂。\n定义 $u$ 到 $v$ 的距离 $\\operatorname{d(u,v)}$ 为 $u$ 和 $v$ 在树上的简单路径经过的边的边权之和。\n\n给定 $k$，请在 $\\dfrac{n\\times (n-1)}{2}$ 个 $\\operatorname{d(u,v)}(1\\le u<v\\le n)$ 中找到第 $k$ 小的值。", "inputFormat": "第一行两个正整数 $n,k$。\n\n接下来 $n-1$ 行，每行三个正整数 $x,y,z(1\\le x,y,z\\le n)$，表示一条连接 $x$ 和 $y$ 的树边，其边权为 $n$ 的 $z$ 次方。", "outputFormat": "输出一行一个整数，即第 $k$ 小的值对 $10^9+7$ 取模的结果。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 2.5\\times 10^4$，$1\\le k\\le \\dfrac{n*(n-1)}{2}$。\n\n\n----\n\n\n\n### 样例解释：\n\n所有的 $d$ 排序后依次为： $5,5,25,30,125,130,130,135,150,155$。", "locale": "zh-CN"}}}
{"pid": "P5985", "type": "P", "difficulty": 6, "samples": [["3 5\n2 -1 3", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2019", "PA（波兰）"], "title": "[PA 2019] Muzyka pop", "background": "", "description": "给定 $ n$ 个整数 $a_{1..n}$，请找到 $n$ 个非负整数 $b_{1..n}$，使得 $a_1\\times \\operatorname{f(b_1)}+a_2\\times \\operatorname{f(b_2)}+...+a_n\\times \\operatorname{f(b_n)}$ 的值最大，其中 $\\operatorname{f(x)} $ 为 $x$ 在二进制下的 $1$ 的个数。\n\n你找到的这 $n$ 个非负整数 $b_{1..n}$ 需要满足 $0\\le b_1<b_2<...<b_n\\le m$。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行包含 $n$ 个整数 $a_1,a_2,...,a_n$。", "outputFormat": "输出一行一个整数，即 $a_1\\times \\operatorname{f(b_1)}+a_2\\times \\operatorname{f(b_2)}+...+a_n\\times \\operatorname{f(b_n)}$ 的最大值。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 200$，$n-1\\le m\\le 10^{18}$，$|a_i|\\le 10^{14}$。\n\n----\n\n### 解释：\n\n$b_1=3,b_2=4,b_3=5$，则答案为 $2\\times 2+(-1)\\times 1+3\\times 2=9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2019] Muzyka pop", "background": "", "description": "给定 $ n$ 个整数 $a_{1..n}$，请找到 $n$ 个非负整数 $b_{1..n}$，使得 $a_1\\times \\operatorname{f(b_1)}+a_2\\times \\operatorname{f(b_2)}+...+a_n\\times \\operatorname{f(b_n)}$ 的值最大，其中 $\\operatorname{f(x)} $ 为 $x$ 在二进制下的 $1$ 的个数。\n\n你找到的这 $n$ 个非负整数 $b_{1..n}$ 需要满足 $0\\le b_1<b_2<...<b_n\\le m$。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行包含 $n$ 个整数 $a_1,a_2,...,a_n$。", "outputFormat": "输出一行一个整数，即 $a_1\\times \\operatorname{f(b_1)}+a_2\\times \\operatorname{f(b_2)}+...+a_n\\times \\operatorname{f(b_n)}$ 的最大值。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 200$，$n-1\\le m\\le 10^{18}$，$|a_i|\\le 10^{14}$。\n\n----\n\n### 解释：\n\n$b_1=3,b_2=4,b_3=5$，则答案为 $2\\times 2+(-1)\\times 1+3\\times 2=9$。", "locale": "zh-CN"}}}
{"pid": "P5986", "type": "P", "difficulty": 6, "samples": [["4\n1 4 8 1\n15\n1 2 3\n1 2 4\n1 2 5\n1 3 3\n1 3 5\n1 3 16\n1 4 16\n1 8 17\n1 100 101\n1 100 115\n1 3 9\n2 2\n1 3 9\n3 4\n1 3 9", "1\n2\n-1\n0\n2\n4\n3\n2\n1\n-1\n3\n2\n-1"]], "limits": {"time": [7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "PA（波兰）"], "title": "[PA 2019] Szprotki i szczupaki", "background": "", "description": "在湖中有 $n$ 条小鱼，第 $i$ 条小鱼的重量为 $w_i$。\n\n共 $q$ 个操作，每个操作是下面 $3$ 种之一：\n\n- `1 s k` 假如现在来了一条重量为 $s$ 的大鲨鱼，它的目标是让自己的重量达到至少 $k$ (包含 $k$)，问它至少需要吃掉多少条小鱼？如果鲨鱼当前的重量严格大于要吃掉的小鱼的重量 $w$，那么它可以吃掉这条小鱼，并使得自己的重量增加 $w$。\n- `2 w` 添加一条重量为 $w$ 的小鱼。\n- `3 w` 删除一条重量为 $w$ 的小鱼，保证存在至少一条这样的小鱼。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个正整数 $w_1,w_2,...,w_n$。\n\n第三行一个正整数 $q$。\n\n接下来 $q$ 行，每行若干个整数，描述一个操作。", "outputFormat": "对于每个询问，如果有解，输出一行一个整数，即最少需要吃掉的小鱼数量，如果无解，输出 `-1`。", "hint": "对于 $100\\%$ 的数据，$1\\le w_i\\le 10^{12}$，$1\\le s,k\\le 10^{18}$ ，$1\\le w\\le 10^{12}$，$1\\le n\\le 3\\times 10^5$，$1\\le q\\le 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2019] Szprotki i szczupaki", "background": "", "description": "在湖中有 $n$ 条小鱼，第 $i$ 条小鱼的重量为 $w_i$。\n\n共 $q$ 个操作，每个操作是下面 $3$ 种之一：\n\n- `1 s k` 假如现在来了一条重量为 $s$ 的大鲨鱼，它的目标是让自己的重量达到至少 $k$ (包含 $k$)，问它至少需要吃掉多少条小鱼？如果鲨鱼当前的重量严格大于要吃掉的小鱼的重量 $w$，那么它可以吃掉这条小鱼，并使得自己的重量增加 $w$。\n- `2 w` 添加一条重量为 $w$ 的小鱼。\n- `3 w` 删除一条重量为 $w$ 的小鱼，保证存在至少一条这样的小鱼。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个正整数 $w_1,w_2,...,w_n$。\n\n第三行一个正整数 $q$。\n\n接下来 $q$ 行，每行若干个整数，描述一个操作。", "outputFormat": "对于每个询问，如果有解，输出一行一个整数，即最少需要吃掉的小鱼数量，如果无解，输出 `-1`。", "hint": "对于 $100\\%$ 的数据，$1\\le w_i\\le 10^{12}$，$1\\le s,k\\le 10^{18}$ ，$1\\le w\\le 10^{12}$，$1\\le n\\le 3\\times 10^5$，$1\\le q\\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P5987", "type": "P", "difficulty": 6, "samples": [["2 10 7\n2 1 8 6\n5 2 4 4", "15"]], "limits": {"time": [3000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "离散化", "O2优化", "哈希 hashing", "扫描线", "PA（波兰）"], "title": "[PA 2019] Terytoria", "background": "", "description": "在二维平面直角坐标系上，有一个长度为 $X$，宽度为 $Y$ 的地图，注意这个地图的左边界和右边界是连通的，下边界和上边界也是连通的。\n\n在这个地图里，有 $X\\times Y$ 个格子以及 $n$ 个边平行坐标轴的矩形。你只知道每个矩形两个对顶点的坐标，请问在最好情况下，被所有 $n$ 个矩形都覆盖住的格子数量有多少？", "inputFormat": "第一行三个正整数 $n,X,Y$。\n\n接下来 $n$ 行，每行四个整数 $x_1,y_1,x_2,y_2(0\\le x_1,x_2<X,0\\le y_1,y_2<Y,x_1\\ne x_2,y_1\\ne y_2)$，表示第 $i$ 个矩形两个对顶点的坐标为 $(x_1,y_1)$ 和 $(x_2,y_2)$。", "outputFormat": "输出一行一个整数，即被所有 $n$ 个矩形都覆盖住的格子数量的最大可能值。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 5\\times 10^5$，$2\\le X,Y\\le 10^9$。\n\n\n### 样例解释：\n\n下图列举了一些情况，其中第3种情况是最优的：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9vwqe130.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2019] Terytoria", "background": "", "description": "在二维平面直角坐标系上，有一个长度为 $X$，宽度为 $Y$ 的地图，注意这个地图的左边界和右边界是连通的，下边界和上边界也是连通的。\n\n在这个地图里，有 $X\\times Y$ 个格子以及 $n$ 个边平行坐标轴的矩形。你只知道每个矩形两个对顶点的坐标，请问在最好情况下，被所有 $n$ 个矩形都覆盖住的格子数量有多少？", "inputFormat": "第一行三个正整数 $n,X,Y$。\n\n接下来 $n$ 行，每行四个整数 $x_1,y_1,x_2,y_2(0\\le x_1,x_2<X,0\\le y_1,y_2<Y,x_1\\ne x_2,y_1\\ne y_2)$，表示第 $i$ 个矩形两个对顶点的坐标为 $(x_1,y_1)$ 和 $(x_2,y_2)$。", "outputFormat": "输出一行一个整数，即被所有 $n$ 个矩形都覆盖住的格子数量的最大可能值。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 5\\times 10^5$，$2\\le X,Y\\le 10^9$。\n\n\n### 样例解释：\n\n下图列举了一些情况，其中第3种情况是最优的：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9vwqe130.png)", "locale": "zh-CN"}}}
{"pid": "P5988", "type": "P", "difficulty": 7, "samples": [["6 8 3 3\n2 -> 1\n2 -> 3\n1 -> 3\n3 -- 6\n1 -> 4\n2 -> 5\n4 -> 6\n4 -- 5", "4"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "PA（波兰）"], "title": "[PA 2019] Wyspa", "background": null, "description": "比特岛位于海上，在比特岛的中心有一个内陆湖。\n\n在比特岛一共有 $n$ 个点，编号为 $1$ 到 $n$，其中 $1$ 到 $a$ 的点按照顺时针或者逆时针表示内陆湖边上的点， $a+1$ 到 $a+b$ 的点按照顺时针或者逆时针表示比特岛海岸线上的点， $a+b+1$ 到 $n$ 的点表示既不在湖边也不在海边的点。\n\n这些点之间连着 $m$ 条单向或双向道路。满足如下限制：\n\n- 每条道路不会经过湖、海或者任意其它点。\n- 任意两点间只会连着最多一条道路\n- 这些道路中不存在“天桥”或者“地下隧道”，任意两条道路只可能在端点处相交，换言之，这是一张平面图。\n- 从任意一个湖边的点出发，都能沿着这些道路直接或间接地到达至少一个海边的点。\n\n现在要在 $b$ 个海边点中选择若干个点作为港口，问有多少种选点的方案使得任意一个湖边的点都能到达至少一个港口？", "inputFormat": "第一行四个正整数 $n,m,a,b$。\n\n接下来 $m$ 行描述 $m$ 条道路，每行要么是 `u -- v` 要么是 `u -> v`($1\\le \nu,v\\le n,u\\ne v$)：\n\n如果是“`u -- v`，表示这是一条连接 $u$ 和 $v$的双向道路。\n\n如果是 `u -> v`，表示这是一条从 $u$出发到达 $v$的单向道路。", "outputFormat": "输出一行一个整数，即满足条件的方案数模 $10^9+7$。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 5\\times 10^5$，$1\\le m\\le 10^6$，$1\\le a,b\\le n,2\\le a+b\\le n$。\n\n---\n\n### 样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/e7xeolht.png)\n\n$6$ 号点必选， $4$ 和 $5$ 可选可不选，因此有 $4$种方案。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2019] Wyspa", "background": null, "description": "比特岛位于海上，在比特岛的中心有一个内陆湖。\n\n在比特岛一共有 $n$ 个点，编号为 $1$ 到 $n$，其中 $1$ 到 $a$ 的点按照顺时针或者逆时针表示内陆湖边上的点， $a+1$ 到 $a+b$ 的点按照顺时针或者逆时针表示比特岛海岸线上的点， $a+b+1$ 到 $n$ 的点表示既不在湖边也不在海边的点。\n\n这些点之间连着 $m$ 条单向或双向道路。满足如下限制：\n\n- 每条道路不会经过湖、海或者任意其它点。\n- 任意两点间只会连着最多一条道路\n- 这些道路中不存在“天桥”或者“地下隧道”，任意两条道路只可能在端点处相交，换言之，这是一张平面图。\n- 从任意一个湖边的点出发，都能沿着这些道路直接或间接地到达至少一个海边的点。\n\n现在要在 $b$ 个海边点中选择若干个点作为港口，问有多少种选点的方案使得任意一个湖边的点都能到达至少一个港口？", "inputFormat": "第一行四个正整数 $n,m,a,b$。\n\n接下来 $m$ 行描述 $m$ 条道路，每行要么是 `u -- v` 要么是 `u -> v`($1\\le \nu,v\\le n,u\\ne v$)：\n\n如果是“`u -- v`，表示这是一条连接 $u$ 和 $v$的双向道路。\n\n如果是 `u -> v`，表示这是一条从 $u$出发到达 $v$的单向道路。", "outputFormat": "输出一行一个整数，即满足条件的方案数模 $10^9+7$。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 5\\times 10^5$，$1\\le m\\le 10^6$，$1\\le a,b\\le n,2\\le a+b\\le n$。\n\n---\n\n### 样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/e7xeolht.png)\n\n$6$ 号点必选， $4$ 和 $5$ 可选可不选，因此有 $4$种方案。", "locale": "zh-CN"}}}
{"pid": "P5989", "type": "P", "difficulty": 3, "samples": [["5 7\n1999\n2019 2010\n850 1500 1600\n900 900 710 900\n1000 800 600 800 1000", "710"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2019", "PA（波兰）"], "title": "[PA 2019] Wina", "background": "", "description": " $n$ 行 $\\dfrac{n\\times(n+1)}{2}$ 个数叠成了一个数塔。\n\n给定 $k$，你需要从中拿走恰好 $k$ 个数，使得拿走的数的最小值最小。一个数能被拿走当且仅当它左上角和右上角都没有数或者那个数已经被拿走了。", "inputFormat": "第一行两个正整数 $n,k$。\n接下来 $n$ 行，第$i$行 $i$个正整数 $a[i][1],a[i][2],...,a[i][i](1\\le a[i][j]\\le 2019)$，表示从上往下第 $i$ 行从左往右第 $j$ 个数。", "outputFormat": "输出一行一个整数，即拿走的数的最小值的最小值。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 2000$，$1\\le k\\le \\dfrac{n\\times(n+1)}{2}$。\n\n\n### 样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/pya9rv24.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2019] Wina", "background": "", "description": " $n$ 行 $\\dfrac{n\\times(n+1)}{2}$ 个数叠成了一个数塔。\n\n给定 $k$，你需要从中拿走恰好 $k$ 个数，使得拿走的数的最小值最小。一个数能被拿走当且仅当它左上角和右上角都没有数或者那个数已经被拿走了。", "inputFormat": "第一行两个正整数 $n,k$。\n接下来 $n$ 行，第$i$行 $i$个正整数 $a[i][1],a[i][2],...,a[i][i](1\\le a[i][j]\\le 2019)$，表示从上往下第 $i$ 行从左往右第 $j$ 个数。", "outputFormat": "输出一行一个整数，即拿走的数的最小值的最小值。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 2000$，$1\\le k\\le \\dfrac{n\\times(n+1)}{2}$。\n\n\n### 样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/pya9rv24.png)", "locale": "zh-CN"}}}
{"pid": "P5990", "type": "P", "difficulty": 2, "samples": [["5\n2 4 3 3 3", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2015", "PA（波兰）"], "title": "[PA 2015] Kieszonkowe", "background": null, "description": "给定 $n$ 个数，请从中选出若干个数，使得总和为偶数。\n\n请最大化这个总和。", "inputFormat": "第一行包含一个正整数 $n$。\n\n第二行包含 $n$ 个正整数 $a_1,a_2,...,a_n$。", "outputFormat": "输出一个正整数，即最大的总和，若无解则输出 `NIESTETY`。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^6$，$1\\le a_i\\le 10^3$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2015] Kieszonkowe", "background": null, "description": "给定 $n$ 个数，请从中选出若干个数，使得总和为偶数。\n\n请最大化这个总和。", "inputFormat": "第一行包含一个正整数 $n$。\n\n第二行包含 $n$ 个正整数 $a_1,a_2,...,a_n$。", "outputFormat": "输出一个正整数，即最大的总和，若无解则输出 `NIESTETY`。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^6$，$1\\le a_i\\le 10^3$。", "locale": "zh-CN"}}}
{"pid": "P5991", "type": "P", "difficulty": 3, "samples": [["51 5000 10000", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "PA（波兰）"], "title": "[PA 2015] Równanie", "background": "", "description": "对于一个正整数 $n$，定义 $\\operatorname{f}(n)$ 为它十进制下每一位数字的平方的和。\n\n现在给定三个正整数 $k,a,b$，请求出满足 $a\\le n\\le b$ 且 $k\\times \\operatorname{f}(n)=n$ 的 $n$ 的个数。", "inputFormat": "第一行包含三个正整数 $k,a,b$。", "outputFormat": "输出一个整数，即满足条件的 $n$ 的个数。", "hint": "对于 $100\\%$ 的数据，$1\\le k,a,b\\le 10^{18}$，$a\\le b$。\n\n---\n\n### 样例解释：\n\n满足的 $3$ 个 $n$ 分别为 $7293,7854$ 和 $7905$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2015] Równanie", "background": "", "description": "对于一个正整数 $n$，定义 $\\operatorname{f}(n)$ 为它十进制下每一位数字的平方的和。\n\n现在给定三个正整数 $k,a,b$，请求出满足 $a\\le n\\le b$ 且 $k\\times \\operatorname{f}(n)=n$ 的 $n$ 的个数。", "inputFormat": "第一行包含三个正整数 $k,a,b$。", "outputFormat": "输出一个整数，即满足条件的 $n$ 的个数。", "hint": "对于 $100\\%$ 的数据，$1\\le k,a,b\\le 10^{18}$，$a\\le b$。\n\n---\n\n### 样例解释：\n\n满足的 $3$ 个 $n$ 分别为 $7293,7854$ 和 $7905$。", "locale": "zh-CN"}}}
{"pid": "P5992", "type": "P", "difficulty": 5, "samples": [["6 4\n1 5\n2 5\n3 6\n4 6\n5 6\n5\n10\n20\n40", "35"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "PA（波兰）"], "title": "[PA 2015] Rozstaw szyn", "background": "", "description": "给定一棵有 $n$ 个点， $m$ 个叶子节点的树，其中 $m$ 个叶子节点分别为 $1$ 到 $m$ 号点，每个叶子节点有一个权值 $r_i$。\n\n你需要给剩下 $n-m$ 个点各指定一个权值，使得树上相邻两个点的权值差的绝对值之和最小。 ", "inputFormat": "第一行包含两个正整数 $n,m$，分别表示点数和叶子数。\n\n接下来 $n-1$ 行，每行两个正整数 $u,v$，表示 $u$ 与 $v$ 之间有一条边。\n\n接下来 $m$ 行，每行一个正整数，依次为 $r_1,r_2,...,r_m$，表示每个叶子的权值。", "outputFormat": "输出一个整数，即树上相邻两个点的权值差的绝对值之和的最小值。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 5\\times 10^5$，$1\\le m\\le n$，$1\\le u,v\\le n$，$1\\le r_i\\le 5\\times 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2015] Rozstaw szyn", "background": "", "description": "给定一棵有 $n$ 个点， $m$ 个叶子节点的树，其中 $m$ 个叶子节点分别为 $1$ 到 $m$ 号点，每个叶子节点有一个权值 $r_i$。\n\n你需要给剩下 $n-m$ 个点各指定一个权值，使得树上相邻两个点的权值差的绝对值之和最小。 ", "inputFormat": "第一行包含两个正整数 $n,m$，分别表示点数和叶子数。\n\n接下来 $n-1$ 行，每行两个正整数 $u,v$，表示 $u$ 与 $v$ 之间有一条边。\n\n接下来 $m$ 行，每行一个正整数，依次为 $r_1,r_2,...,r_m$，表示每个叶子的权值。", "outputFormat": "输出一个整数，即树上相邻两个点的权值差的绝对值之和的最小值。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 5\\times 10^5$，$1\\le m\\le n$，$1\\le u,v\\le n$，$1\\le r_i\\le 5\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P5993", "type": "P", "difficulty": 2, "samples": [["5\n5\n4\n12\n11\n10", "TAK\nTAK\nNIE\nNIE\nTAK"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "PA（波兰）"], "title": "[PA 2014] Iloczyn", "background": "译自 PA 2014 Trial Round.", "description": "斐波那契数列的定义为：\n \n- $k=0$ 或 $1$ 时， $F_k=k$；\n\n- $k>1$ 时，$F_k=F_{k-1}+F_{k-2}$。\n\n数列的开头几项为 $0,1,1,2,3,5,8,13,21,34,55,…$。\n\n你的任务是判断给定的数字能否被表示成两个斐波那契数的乘积。", "inputFormat": "第一行包含一个整数 $T$，表示询问数量。\n\n接下来的 $T$ 行，每行一个整数 $n_i$。", "outputFormat": "输出共 $T$ 行，第 $i$ 行为 `TAK`（是）或 `NIE`（否），表示 $n_i$ 能否被表示成两个斐波那契数的乘积。", "hint": "对于 $100\\%$ 的数据，$1\\le T\\le 10$，$0\\le n_i\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2014] Iloczyn", "background": "译自 PA 2014 Trial Round.", "description": "斐波那契数列的定义为：\n \n- $k=0$ 或 $1$ 时， $F_k=k$；\n\n- $k>1$ 时，$F_k=F_{k-1}+F_{k-2}$。\n\n数列的开头几项为 $0,1,1,2,3,5,8,13,21,34,55,…$。\n\n你的任务是判断给定的数字能否被表示成两个斐波那契数的乘积。", "inputFormat": "第一行包含一个整数 $T$，表示询问数量。\n\n接下来的 $T$ 行，每行一个整数 $n_i$。", "outputFormat": "输出共 $T$ 行，第 $i$ 行为 `TAK`（是）或 `NIE`（否），表示 $n_i$ 能否被表示成两个斐波那契数的乘积。", "hint": "对于 $100\\%$ 的数据，$1\\le T\\le 10$，$0\\le n_i\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P5994", "type": "P", "difficulty": 4, "samples": [["5\n1 2 3 4 5\n4 3 2 1\n3 4 5\n2 1\n5", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "2014", "生成树", "PA（波兰）"], "title": "[PA 2014] Kuglarz", "background": "", "description": "魔术师的桌子上有 $n$ 个杯子排成一行，编号为 $1,2,…,n$，其中某些杯子底下藏有一个小球，如果你准确地猜出是哪些杯子，你就可以获得奖品。\n\n花费 $c_{ij}$ 元，魔术师就会告诉你杯子 $i,i+1,…,j$ 底下藏有球的总数的奇偶性。\n\n采取最优的询问策略，你至少需要花费多少元，才能保证猜出哪些杯子底下藏着球？", "inputFormat": "第一行一个整数 $n$。\n\n第 $i+1$ 行（$1\\le i\\le n$）有 $n+1-i$ 个整数，表示每一种询问所需的花费。\n\n其中 $c_{ij}$（对区间 $[i,j]$ 进行询问的费用，$1\\le i\\le j\\le n$）为第 $i+1$ 行第 $j+1-i$ 个数。", "outputFormat": "输出一个整数，表示最少花费。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 2\\times 10^3$，$1\\le c_{ij}\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2014] Kuglarz", "background": "", "description": "魔术师的桌子上有 $n$ 个杯子排成一行，编号为 $1,2,…,n$，其中某些杯子底下藏有一个小球，如果你准确地猜出是哪些杯子，你就可以获得奖品。\n\n花费 $c_{ij}$ 元，魔术师就会告诉你杯子 $i,i+1,…,j$ 底下藏有球的总数的奇偶性。\n\n采取最优的询问策略，你至少需要花费多少元，才能保证猜出哪些杯子底下藏着球？", "inputFormat": "第一行一个整数 $n$。\n\n第 $i+1$ 行（$1\\le i\\le n$）有 $n+1-i$ 个整数，表示每一种询问所需的花费。\n\n其中 $c_{ij}$（对区间 $[i,j]$ 进行询问的费用，$1\\le i\\le j\\le n$）为第 $i+1$ 行第 $j+1-i$ 个数。", "outputFormat": "输出一个整数，表示最少花费。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 2\\times 10^3$，$1\\le c_{ij}\\le 10^9$。", "locale": "zh-CN"}}}
