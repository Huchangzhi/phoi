{"pid": "P12083", "type": "P", "difficulty": 7, "samples": [["5 7\n2 3 4 5 1\n3 3\n1 3\n0 4\n6 1\n0 4\n7 0\n1 2", "0\n1\n4\n1\n4\n0\n0\n"], ["12 10\n4 1 12 6 2 11 5 3 7 9 8 10\n8 11\n4 14\n15 7\n12 13\n2 7\n10 8\n4 10\n15 0\n7 12\n14 11", "2\n12\n14\n0\n3\n0\n8\n0\n12\n3\n"], ["20 20\n7 13 5 9 12 15 10 19 3 2 6 17 20 16 4 8 18 1 11 14\n9 15\n8 7\n93 93\n3 9\n29 25\n12 13\n7 18\n24 13\n13 11\n0 19\n140 141\n8 13\n3 10\n18 14\n8 16\n30 21\n20 25\n11 16\n13 12\n11 16", "9\n92\n0\n13\n2\n0\n31\n31\n1\n142\n0\n7\n28\n1\n27\n19\n0\n1\n0\n1\n"]], "limits": {"time": [2222, 2222, 2222, 2222, 2222, 2222, 2222, 2222, 2222, 2222, 2222, 2222, 2222, 2222, 2222, 2222, 2222, 2222, 2222, 2222, 2222, 2222, 2222, 2222, 2222], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["1998", "O2优化", "Ynoi"], "title": "[Ynoi1998] Marchen", "background": "我不需要什么夜鹰的青焰或是天蝎的赤焰。\n\n因罪恶感而发出美丽光芒的星星对我来说没有任何用处。\n\n![](https://s41.ax1x.com/2026/01/26/pZ2zBj0.png)\n\n秋夜。不知何处的彼方。沙沙地照射夜晚的阳光……\n\n『一个童话』\n\n没错，这就是一个童话。\n\n我是这样理解的。\n\n秋天的夜晚和夏天的夜晚气氛不同。\n\n台风摧毁夏天，带来了秋天的风。\n\n所以，那个夏夜已经不知消失到哪里去了。", "description": "给你一个 $1\\dots n$ 的排列 $a$，共有 $q$ 次询问，每次询问给你一个区间 $[l,r]$，求满足 $l\\le i<j<k\\le r$ 且 $a_i<a_j<a_k$ 的三元组 $(i,j,k)$ 数量。", "inputFormat": "**本题强制在线。**\n\n第一行两个整数 $n,q$。\n\n第二行 $n$ 个整数 $a_{1\\dots n}$。\n\n接下来 $q$ 行，每行两个整数 $l',r'$ 表示询问。你需要将 $l',r'$ 分别异或上次询问的答案得到真实的 $l,r$。特别地，如果这是第一次询问则 $l=l',r=r'$。", "outputFormat": "$q$ 行，每行一个整数表示答案。", "hint": "Idea：critnos，Solution：critnos，Code：critnos，Data：critnos\n\n所有数据保证 $1\\le n,q\\le 10^5$，$1\\le l\\le r\\le n$，$a$ 是一个 $1\\dots n$ 的排列。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi1998] Marchen", "background": "我不需要什么夜鹰的青焰或是天蝎的赤焰。\n\n因罪恶感而发出美丽光芒的星星对我来说没有任何用处。\n\n![](https://s41.ax1x.com/2026/01/26/pZ2zBj0.png)\n\n秋夜。不知何处的彼方。沙沙地照射夜晚的阳光……\n\n『一个童话』\n\n没错，这就是一个童话。\n\n我是这样理解的。\n\n秋天的夜晚和夏天的夜晚气氛不同。\n\n台风摧毁夏天，带来了秋天的风。\n\n所以，那个夏夜已经不知消失到哪里去了。", "description": "给你一个 $1\\dots n$ 的排列 $a$，共有 $q$ 次询问，每次询问给你一个区间 $[l,r]$，求满足 $l\\le i<j<k\\le r$ 且 $a_i<a_j<a_k$ 的三元组 $(i,j,k)$ 数量。", "inputFormat": "**本题强制在线。**\n\n第一行两个整数 $n,q$。\n\n第二行 $n$ 个整数 $a_{1\\dots n}$。\n\n接下来 $q$ 行，每行两个整数 $l',r'$ 表示询问。你需要将 $l',r'$ 分别异或上次询问的答案得到真实的 $l,r$。特别地，如果这是第一次询问则 $l=l',r=r'$。", "outputFormat": "$q$ 行，每行一个整数表示答案。", "hint": "Idea：critnos，Solution：critnos，Code：critnos，Data：critnos\n\n所有数据保证 $1\\le n,q\\le 10^5$，$1\\le l\\le r\\le n$，$a$ 是一个 $1\\dots n$ 的排列。", "locale": "zh-CN"}}}
{"pid": "P12084", "type": "P", "difficulty": 7, "samples": [["7 6\n3 11 1 5 12 19 10\n1 1\n3 5\n2 5\n1 7\n2 6\n1 4", "yumi!\nyumi!\n28\n24\n28\nyumi!"], ["20 20\n26 17 11 89 56 33 72 73 43 77 80 87 97 17 43 74 72 91 49 69\n10 19\n2 4\n3 5\n2 11\n1 12\n10 19\n3 5\n8 15\n8 12\n14 20\n5 11\n13 18\n2 18\n17 19\n1 9\n5 8\n9 12\n1 11\n4 13\n3 18", "109\nyumi!\nyumi!\n87\n54\n109\nyumi!\n103\n193\n109\n132\n163\n45\n212\n54\n161\n200\n54\n132\n87"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["1998", "O2优化", "Ynoi"], "title": "[Ynoi1998] ZYPRESSEN", "background": "大气层越发清澈澄明\\\n无声的丝柏冲天而立\n\n![](https://s41.ax1x.com/2026/01/26/pZ2zhg1.png)\n\n耀眼的大气下\\\n哀怨依然青深\\\n柏木静静摇曳\\\n鸟儿再次划破青空\\\n此处已无真心话语\\\n阿修罗泪如雨落土\n\n已经完全是秋季了。\n\n即使如此，丝柏（ZYPRESSEN）也是一如既往的黢黑吧。", "description": "给你一个长度为 $n$ 的序列 $a$，共有 $q$ 次询问，每次询问给你一个区间 $[l,r]$，求满足 $l\\le i<j<k\\le r$ 且 $2\\max(a_i,a_j,a_k)<a_i+a_j+a_k$ 的三元组 $(i,j,k)$ 中 $a_i+a_j+a_k$ 的最小值。", "inputFormat": "第一行两个整数 $n,q$。\n\n第二行 $n$ 个整数 $a_{1\\dots n}$。\n\n接下来 $q$ 行，每行两个整数 $l,r$ 表示询问。", "outputFormat": "$q$ 行，每行一个整数表示答案。\n\n特别地，如果不存在符合条件的三元组，输出 `yumi!`。", "hint": "Idea：critnos，Solution：critnos&zhoukangyang，Code：critnos，Data：critnos&Otomachi_Una_\n\n所有数据保证 $1\\le n\\le 2.5\\times 10^5$，$1\\le q\\le 5\\times 10^5$，$1\\le a_i\\le 10^7$，$1\\le l\\le r\\le n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi1998] ZYPRESSEN", "background": "大气层越发清澈澄明\\\n无声的丝柏冲天而立\n\n![](https://s41.ax1x.com/2026/01/26/pZ2zhg1.png)\n\n耀眼的大气下\\\n哀怨依然青深\\\n柏木静静摇曳\\\n鸟儿再次划破青空\\\n此处已无真心话语\\\n阿修罗泪如雨落土\n\n已经完全是秋季了。\n\n即使如此，丝柏（ZYPRESSEN）也是一如既往的黢黑吧。", "description": "给你一个长度为 $n$ 的序列 $a$，共有 $q$ 次询问，每次询问给你一个区间 $[l,r]$，求满足 $l\\le i<j<k\\le r$ 且 $2\\max(a_i,a_j,a_k)<a_i+a_j+a_k$ 的三元组 $(i,j,k)$ 中 $a_i+a_j+a_k$ 的最小值。", "inputFormat": "第一行两个整数 $n,q$。\n\n第二行 $n$ 个整数 $a_{1\\dots n}$。\n\n接下来 $q$ 行，每行两个整数 $l,r$ 表示询问。", "outputFormat": "$q$ 行，每行一个整数表示答案。\n\n特别地，如果不存在符合条件的三元组，输出 `yumi!`。", "hint": "Idea：critnos，Solution：critnos&zhoukangyang，Code：critnos，Data：critnos&Otomachi_Una_\n\n所有数据保证 $1\\le n\\le 2.5\\times 10^5$，$1\\le q\\le 5\\times 10^5$，$1\\le a_i\\le 10^7$，$1\\le l\\le r\\le n$。", "locale": "zh-CN"}}}
{"pid": "P12085", "type": "P", "difficulty": 4, "samples": [["5 3\n1 4 2 8 7", "17 7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["堆", "2023", "链表", "蓝桥杯省赛"], "title": "[蓝桥杯 2023 省 B] 整数删除", "background": "", "description": "给定一个长度为 $N$ 的整数数列：$A_{1},A_{2},\\ldots,A_{N}$。你要重复以下操作 $K$ 次：\n\n每次选择数列中最小的整数（如果最小值不止一个，选择最靠前的），将其删除。并把与它相邻的整数加上被删除的数值。\n\n输出 $K$ 次操作后的序列。", "inputFormat": "第一行包含两个整数 $N$ 和 $K$。\n\n第二行包含 $N$ 个整数，$A_{1},A_{2},A_{3},\\ldots,A_{N}$。", "outputFormat": "输出 $N-K$ 个整数，中间用一个空格隔开，代表 $K$ 次操作后的序列。", "hint": "**【样例说明】**\n\n数列变化如下，中括号里的数是当此操作中被选择的数：\n```plain\n[1] 4 2 8 7\n5 [2] 8 7\n[7] 10 7\n17 7\n```\n**【评测用例规模与约定】**\n\n对于 $20 \\%$ 的数据，$1 \\leq K<N \\leq 10^4$。\n\n对于 $100 \\%$ 的数据，$1 \\leq K<N \\leq 5 \\times 10^{5}$，$0 \\leq A_{i} \\leq 10^{8}$。 \n\n蓝桥杯 2023 省赛 B 组 H 题。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2023 省 B] 整数删除", "background": "", "description": "给定一个长度为 $N$ 的整数数列：$A_{1},A_{2},\\ldots,A_{N}$。你要重复以下操作 $K$ 次：\n\n每次选择数列中最小的整数（如果最小值不止一个，选择最靠前的），将其删除。并把与它相邻的整数加上被删除的数值。\n\n输出 $K$ 次操作后的序列。", "inputFormat": "第一行包含两个整数 $N$ 和 $K$。\n\n第二行包含 $N$ 个整数，$A_{1},A_{2},A_{3},\\ldots,A_{N}$。", "outputFormat": "输出 $N-K$ 个整数，中间用一个空格隔开，代表 $K$ 次操作后的序列。", "hint": "**【样例说明】**\n\n数列变化如下，中括号里的数是当此操作中被选择的数：\n```plain\n[1] 4 2 8 7\n5 [2] 8 7\n[7] 10 7\n17 7\n```\n**【评测用例规模与约定】**\n\n对于 $20 \\%$ 的数据，$1 \\leq K<N \\leq 10^4$。\n\n对于 $100 \\%$ 的数据，$1 \\leq K<N \\leq 5 \\times 10^{5}$，$0 \\leq A_{i} \\leq 10^{8}$。 \n\n蓝桥杯 2023 省赛 B 组 H 题。", "locale": "zh-CN"}}}
{"pid": "P12086", "type": "P", "difficulty": 7, "samples": [["3\n2\n1 1 2 0 0 0 0 0 0\n7\n2 4 2 0 0 6 2 2 2\n7\n3 3 3 0 0 6 2 2 2", "2313\n62616236261623778899\n623616236162361778899"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "Special Judge", "RMI（罗马尼亚）"], "title": "[RMI 2019] 分钱 / Devil's Share", "background": "", "description": "\n给定九个非负整数 $d_1,\\ldots,d_9$。令 $s=\\sum d_i$。\n\n构造一个（十进制下）长度为 $s$ 的正整数 $x$，在 $x$ 的数位中数字 $i$（$1\\le i\\le 9$）出现了**恰好** $d_i$ 次。\n\n在此前提下，将 $x$ 的十进制表示视为字符串，将它长度为 $k$ 的 $(s-k+1)$ 个子串全部拿出来，转成数字 $y_1,y_2,\\ldots,y_{s-k+1}$。你需要最小化 $\\max \\{y_1,y_2,\\ldots,y_{s-k+1}\\}$ 的值。\n\n", "inputFormat": "\n**本题单个测试点内有多组测试数据。**\n\n第一行，一个正整数 $T$，表示测试数据组数。\n\n接下来描述 $T$ 组测试数据：\n\n每组数据第一行，一个正整数 $k$。\n\n每组数据第二行，九个非负整数 $d_1,\\ldots,d_9$。", "outputFormat": "每组数据输出一行一个正整数，表示你构造的 $x$。\n", "hint": "\n对于 $100\\%$ 的数据，保证：\n\n- $1\\le T\\le 10^5$；\n- $1\\le s\\le 10^5$；\n- $\\sum s\\le 10^6$；\n- $1\\le k\\le s$；\n- $0\\le d_i$。\n\n### 子任务\n\n- Subtask 1（$13$ pts）：$0\\le d_1,d_2,d_3,d_4\\le 3$，$d_5=d_6=\\ldots=d_9=0$，$1\\le T\\le 1536$，保证不会出现两组相同的数据。\n- Subtask 2（$14$ pts）：$k=2$。\n- Subtask 3（$29$ pts）：$d_3=d_4=\\ldots=d_9=0$。\n- Subtask 4（$44$ pts）：无额外限制。\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RMI 2019] 分钱 / Devil's Share", "background": "", "description": "\n给定九个非负整数 $d_1,\\ldots,d_9$。令 $s=\\sum d_i$。\n\n构造一个（十进制下）长度为 $s$ 的正整数 $x$，在 $x$ 的数位中数字 $i$（$1\\le i\\le 9$）出现了**恰好** $d_i$ 次。\n\n在此前提下，将 $x$ 的十进制表示视为字符串，将它长度为 $k$ 的 $(s-k+1)$ 个子串全部拿出来，转成数字 $y_1,y_2,\\ldots,y_{s-k+1}$。你需要最小化 $\\max \\{y_1,y_2,\\ldots,y_{s-k+1}\\}$ 的值。\n\n", "inputFormat": "\n**本题单个测试点内有多组测试数据。**\n\n第一行，一个正整数 $T$，表示测试数据组数。\n\n接下来描述 $T$ 组测试数据：\n\n每组数据第一行，一个正整数 $k$。\n\n每组数据第二行，九个非负整数 $d_1,\\ldots,d_9$。", "outputFormat": "每组数据输出一行一个正整数，表示你构造的 $x$。\n", "hint": "\n对于 $100\\%$ 的数据，保证：\n\n- $1\\le T\\le 10^5$；\n- $1\\le s\\le 10^5$；\n- $\\sum s\\le 10^6$；\n- $1\\le k\\le s$；\n- $0\\le d_i$。\n\n### 子任务\n\n- Subtask 1（$13$ pts）：$0\\le d_1,d_2,d_3,d_4\\le 3$，$d_5=d_6=\\ldots=d_9=0$，$1\\le T\\le 1536$，保证不会出现两组相同的数据。\n- Subtask 2（$14$ pts）：$k=2$。\n- Subtask 3（$29$ pts）：$d_3=d_4=\\ldots=d_9=0$。\n- Subtask 4（$44$ pts）：无额外限制。\n\n", "locale": "zh-CN"}}}
{"pid": "P12087", "type": "P", "difficulty": 6, "samples": [["6 10\n560484\n2 6 4\n2 1 4\n2 5 6\n2 6 1\n2 3 6\n1 3 6\n1 1 3\n1 6 6\n1 2 6\n2 1 7", "528145\n6228\n452\n2\n63454"]], "limits": {"time": [300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2019", "数位 DP", "RMI（罗马尼亚）", "动态 DP"], "title": "[RMI 2019] 好数 / Lucky Numbers", "background": "\n在某些文化中，数字 $13$ 被视为霉运之兆。", "description": "**本题中下标是 $\\texttt{1-indexed}$ 的。**\n\n给定一个 $n$ 位数 $x$。你需要计算**不大于** $x$ 的**非负整数**中，有多少非负整数在十进制表示下不含 $13$ 作为（连续）子串。\n\n额外地，有 $q$ 次操作：\n\n- $\\texttt{1}$ $l$ $r$：将 $x$ 视为字符串，将 $x$ 的子串 $x_lx_{l+1}\\ldots x_r$ 视为数字 $y$（$y=\\overline{x_lx_{l+1}\\ldots x_r}$）。计算**不大于** $y$ 的**非负整数**中，有多少非负整数在十进制表示下不含 $13$ 作为（连续）子串。\n- $\\texttt{2}$ $p$ $d$：将 $x$ 的第 $p$ 位替换成 $d$。\n\n以上所有操作答案对 $(10^9+7)$ 取模。\n\n**注意 $x$ 和 $y$ 可能有前导零。所有的答案都要对 $(10^9+7)$ 取模。**", "inputFormat": "\n第一行，两个整数 $n,q$。\n\n第二行，非负整数 $x$。\n\n接下来 $q$ 行，每行三个非负整数描述一个操作，格式见上。\n", "outputFormat": "\n**所有的答案都要对 $(10^9+7)$ 取模。**\n\n第一行，输出一个非负整数，表示不大于 $x$ 的非负整数中，有多少非负整数在十进制表示下不含 $13$ 作为子串。\n\n接下来，对于每个 $1$ 操作输出一行一个非负整数，表示答案。", "hint": "\n对于 $100\\%$ 的数据，保证：\n\n- $1\\le n\\le 10^5$；\n- $0\\le q\\le 10^4$；\n- $1\\le l\\le r\\le n$；\n- $1\\le p\\le n$，$0\\le d\\le 9$。\n\n### 子任务\n\n| 编号 | $n\\le$ | $q$ | 特殊性质 | 分值 |\n| :-: | :-: | :-: | :-: | :-: |\n| $1$ | $6$ | $=0$ | | $14$ |\n| $2$ | $18$ | $=0$ | | $14$ |\n| $3$ | $10^4$ | $\\le 10^4$ | A | $9$ |\n| $4$ | $10^5$ | $\\le 10^4$ | A | $27$ |\n| $5$ | $10^4$ | $\\le 10^4$ | | $9$ |\n| $6$ | $10^5$ | $\\le 10^4$ | | $27$ |\n\n特殊性质 A：只有操作 $1$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RMI 2019] 好数 / Lucky Numbers", "background": "\n在某些文化中，数字 $13$ 被视为霉运之兆。", "description": "**本题中下标是 $\\texttt{1-indexed}$ 的。**\n\n给定一个 $n$ 位数 $x$。你需要计算**不大于** $x$ 的**非负整数**中，有多少非负整数在十进制表示下不含 $13$ 作为（连续）子串。\n\n额外地，有 $q$ 次操作：\n\n- $\\texttt{1}$ $l$ $r$：将 $x$ 视为字符串，将 $x$ 的子串 $x_lx_{l+1}\\ldots x_r$ 视为数字 $y$（$y=\\overline{x_lx_{l+1}\\ldots x_r}$）。计算**不大于** $y$ 的**非负整数**中，有多少非负整数在十进制表示下不含 $13$ 作为（连续）子串。\n- $\\texttt{2}$ $p$ $d$：将 $x$ 的第 $p$ 位替换成 $d$。\n\n以上所有操作答案对 $(10^9+7)$ 取模。\n\n**注意 $x$ 和 $y$ 可能有前导零。所有的答案都要对 $(10^9+7)$ 取模。**", "inputFormat": "\n第一行，两个整数 $n,q$。\n\n第二行，非负整数 $x$。\n\n接下来 $q$ 行，每行三个非负整数描述一个操作，格式见上。\n", "outputFormat": "\n**所有的答案都要对 $(10^9+7)$ 取模。**\n\n第一行，输出一个非负整数，表示不大于 $x$ 的非负整数中，有多少非负整数在十进制表示下不含 $13$ 作为子串。\n\n接下来，对于每个 $1$ 操作输出一行一个非负整数，表示答案。", "hint": "\n对于 $100\\%$ 的数据，保证：\n\n- $1\\le n\\le 10^5$；\n- $0\\le q\\le 10^4$；\n- $1\\le l\\le r\\le n$；\n- $1\\le p\\le n$，$0\\le d\\le 9$。\n\n### 子任务\n\n| 编号 | $n\\le$ | $q$ | 特殊性质 | 分值 |\n| :-: | :-: | :-: | :-: | :-: |\n| $1$ | $6$ | $=0$ | | $14$ |\n| $2$ | $18$ | $=0$ | | $14$ |\n| $3$ | $10^4$ | $\\le 10^4$ | A | $9$ |\n| $4$ | $10^5$ | $\\le 10^4$ | A | $27$ |\n| $5$ | $10^4$ | $\\le 10^4$ | | $9$ |\n| $6$ | $10^5$ | $\\le 10^4$ | | $27$ |\n\n特殊性质 A：只有操作 $1$。\n", "locale": "zh-CN"}}}
{"pid": "P12088", "type": "P", "difficulty": 5, "samples": [["4 5\n0 1 2 1\n0 2 2 0\n2 2 1 0\n0 1 1 0\n1 2 1 0", "0 1 0 0"]], "limits": {"time": [666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "Special Judge", "差分约束", "RMI（罗马尼亚）"], "title": "[RMI 2019] 还原 / Restore Arrays", "background": "", "description": "**本题中下标是 $\\texttt{\\textcolor{red}{0-indexed}}$ 的。**\n\n构造一个长度为 $n$ 的 $\\text{01}$ 串 $a_0\\sim a_{n-1}$，满足以下条件：\n\n- $\\forall 0\\le i\\lt m$，都有 $k_i\\mathrm{thmin}(a_{l_i},a_{{l_i}+1},\\ldots,a_{r_i})=\\mathrm{val}_i$。\n\n这里，$k\\mathrm{thmin}$ 表示一个数列内第 $k$ 小的元素。", "inputFormat": "\n第一行，两个正整数 $n,m$。\n\n接下来 $m$ 行，第 $i$ 行四个非负整数 $l_{i-1},r_{i-1},k_{i-1},\\mathrm{val}_{i-1}$。\n", "outputFormat": "\n如果有解，直接输出对应的 $01$ 串（元素中间**要**加空格）。\n\n否则输出一行一个 $\\texttt{-1}$。\n", "hint": "\n对于 $100\\%$ 的数据，保证：\n\n- $1\\le n\\le 5\\times 10^3$；\n- $1\\le m\\le 10^4$；\n- $0\\le l_i\\le r_i\\lt n$；\n- $1\\le k_i\\le r_i-l_i+1$；\n- $\\mathrm{val}_i\\in \\{0,1\\}$。\n\n### 子任务\n\n| 编号 | $n\\le$ | $m\\le$ | 特殊性质 | 分值 |\n| :-: | :-: | :-: | :-: | :-: |\n| $1$ | $18$ | $200$ | / | $7$ |\n| $2$ | $5\\times 10^3$ | $10^4$ | $\\text{A}$| $13$ |\n| $3$ | $5\\times 10^3$ | $10^4$ | $\\text{B}$ | $25$ |\n| $4$ | $5\\times 10^3$ | $10^4$ | / | $55$ |\n\n- 特殊性质 $\\text{A}$：$\\forall 0\\le i\\lt m$，$k_i=1$。\n- 特殊性质 $\\text{B}$：$\\forall 0\\le i\\lt m$，要么 $k_i=1$，要么 $k_i=r_i-l_i+1$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RMI 2019] 还原 / Restore Arrays", "background": "", "description": "**本题中下标是 $\\texttt{\\textcolor{red}{0-indexed}}$ 的。**\n\n构造一个长度为 $n$ 的 $\\text{01}$ 串 $a_0\\sim a_{n-1}$，满足以下条件：\n\n- $\\forall 0\\le i\\lt m$，都有 $k_i\\mathrm{thmin}(a_{l_i},a_{{l_i}+1},\\ldots,a_{r_i})=\\mathrm{val}_i$。\n\n这里，$k\\mathrm{thmin}$ 表示一个数列内第 $k$ 小的元素。", "inputFormat": "\n第一行，两个正整数 $n,m$。\n\n接下来 $m$ 行，第 $i$ 行四个非负整数 $l_{i-1},r_{i-1},k_{i-1},\\mathrm{val}_{i-1}$。\n", "outputFormat": "\n如果有解，直接输出对应的 $01$ 串（元素中间**要**加空格）。\n\n否则输出一行一个 $\\texttt{-1}$。\n", "hint": "\n对于 $100\\%$ 的数据，保证：\n\n- $1\\le n\\le 5\\times 10^3$；\n- $1\\le m\\le 10^4$；\n- $0\\le l_i\\le r_i\\lt n$；\n- $1\\le k_i\\le r_i-l_i+1$；\n- $\\mathrm{val}_i\\in \\{0,1\\}$。\n\n### 子任务\n\n| 编号 | $n\\le$ | $m\\le$ | 特殊性质 | 分值 |\n| :-: | :-: | :-: | :-: | :-: |\n| $1$ | $18$ | $200$ | / | $7$ |\n| $2$ | $5\\times 10^3$ | $10^4$ | $\\text{A}$| $13$ |\n| $3$ | $5\\times 10^3$ | $10^4$ | $\\text{B}$ | $25$ |\n| $4$ | $5\\times 10^3$ | $10^4$ | / | $55$ |\n\n- 特殊性质 $\\text{A}$：$\\forall 0\\le i\\lt m$，$k_i=1$。\n- 特殊性质 $\\text{B}$：$\\forall 0\\le i\\lt m$，要么 $k_i=1$，要么 $k_i=r_i-l_i+1$。\n", "locale": "zh-CN"}}}
{"pid": "P12089", "type": "P", "difficulty": 5, "samples": [["1 1\n1 2\n3 3\n2 1", "2"]], "limits": {"time": [1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "RMI（罗马尼亚）"], "title": "[RMI 2019] 钓鱼纸牌 / Fishing Game", "background": "", "description": "\n钓鱼游戏是一种使用一副卡牌进行的游戏，这副卡牌包含 $3N$ **对**卡牌，编号 $1\\sim 3N$（一副卡牌中有 $6N$ 张牌）。\n\n三位朋友（$\\text{A}$、$\\text{B}$ 和 $\\text{C}$）参与钓鱼游戏。游戏过程如下：\n\n1. 发牌：每位玩家首先获得 $2N$ 张卡牌。\n2. 弃牌：每位玩家丢弃手中所有相同数值的卡牌对。\n3. 打牌：重复以下三个步骤，直至所有剩余卡牌被丢弃：\n   - $\\text{A}$ 将自己的一张卡牌传给 $\\text{B}$（除非 $\\text{A}$ 没有剩余卡牌）。若此时 $\\text{B}$ 拥有相同数值的卡牌对，则立即丢弃这对卡牌。\n   - $\\text{B}$ 将自己的一张卡牌传给 $\\text{C}$（除非 $\\text{B}$ 没有剩余卡牌）。若此时 $\\text{C}$ 拥有相同数值的卡牌对，则立即丢弃这对卡牌。\n   - $\\text{C}$ 将自己的一张卡牌传给 $\\text{A}$（除非 $\\text{C}$ 没有剩余卡牌）。若此时 $\\text{A}$ 拥有相同数值的卡牌对，则立即丢弃这对卡牌。\n\n已知在「打牌」阶段的每轮循环中至少有一对相同数值的卡牌被丢弃。\n\n给定三位玩家在「发牌」阶段结束后的手牌状态，请计算**不同的**游戏过程数量。由于结果可能很大，只需要算出答案对 $(10^9+7)$ 取模的结果。\n\n> 定义：两种游戏过程被视为**不同的**，当且仅当在某一操作步骤中，当前玩家选择传了不同的卡牌。", "inputFormat": "\n\n**本题单个测试点内有多组测试数据。**\n\n第一行输入包含两个整数 $N,T$，其中 $T$ 表示测试数据组数。  \n\n接下来描述 $T$ 组数据。每组数据三行：  \n\n- 第一行，$2N$ 个正整数，表示玩家 $\\text{A}$ 在「发牌」阶段结束后的手牌。  \n- 第二行，$2N$ 个正整数，表示玩家 $\\text{B}$ 在「发牌」阶段结束后的手牌。  \n- 第三行，$2N$ 个正整数，表示玩家 $\\text{C}$ 在「发牌」阶段结束后的手牌。  ", "outputFormat": "每组数据输出一行一个非负整数，表示答案对 $(10^9+7)$ 取模后的结果。  \n", "hint": "\n\n\n### 样例解释\n\n首先，在「弃牌」阶段中，玩家 $\\text{B}$ 弃掉了所有卡牌。此时玩家的手牌状态为：  \n- $\\text{A}$：$1$, $2$；\n- $\\text{B}$：没有牌；\n- $\\text{C}$：$1$, $2$。\n\n游戏有两种不同的进行方式：  \n\n1. $\\text{A}$ 将卡牌 $1$ 传给 $\\text{B}$，然后 $\\text{B}$ 将其传给 $\\text{C}$。此时 $\\text{C}$ 弃掉数值为 $1$ 的卡牌对。接着 $\\text{C}$ 必须将剩余的卡牌传给 $\\text{A}$，$\\text{A}$ 弃掉该卡牌。  \n2. $\\text{A}$ 将卡牌 $2$ 传给 $\\text{B}$，然后 $\\text{B}$ 将其传给 $\\text{C}$。此时 $\\text{C}$ 弃掉数值为 $2$ 的卡牌对。接着 $\\text{C}$ 必须将剩余的卡牌传给 $\\text{A}$，$\\text{A}$ 弃掉该卡牌。  \n\n### 数据范围\n\n\n对于 $100\\%$ 的数据，保证：\n\n- $1\\le N\\le 99$；\n- $1\\le T\\le 10$。\n\n### 子任务\n\n注意限制是等于号，不是小于等于号。\n\n| 编号 | $n=$ | $T=$ | 分值 |\n| :-: | :-: | :-: |  :-: |\n| $1$ | $2$ | $3$ | $10$ |\n| $2$ | $3$ | $5$ | $10$ |\n| $3$ | $10$ | $5$ | $10$ |\n| $4$ | $20$ | $5$ | $10$ |\n| $5$ | $50$ | $10$ | $10$ |\n| $6$ | $60$ | $10$ | $10$ |\n| $7$ | $70$ | $10$ | $10$ |\n| $8$ | $80$ | $10$ | $10$ |\n| $9$ | $90$ | $10$ | $10$ |\n| $10$ | $99$ | $10$ | $10$ |\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RMI 2019] 钓鱼纸牌 / Fishing Game", "background": "", "description": "\n钓鱼游戏是一种使用一副卡牌进行的游戏，这副卡牌包含 $3N$ **对**卡牌，编号 $1\\sim 3N$（一副卡牌中有 $6N$ 张牌）。\n\n三位朋友（$\\text{A}$、$\\text{B}$ 和 $\\text{C}$）参与钓鱼游戏。游戏过程如下：\n\n1. 发牌：每位玩家首先获得 $2N$ 张卡牌。\n2. 弃牌：每位玩家丢弃手中所有相同数值的卡牌对。\n3. 打牌：重复以下三个步骤，直至所有剩余卡牌被丢弃：\n   - $\\text{A}$ 将自己的一张卡牌传给 $\\text{B}$（除非 $\\text{A}$ 没有剩余卡牌）。若此时 $\\text{B}$ 拥有相同数值的卡牌对，则立即丢弃这对卡牌。\n   - $\\text{B}$ 将自己的一张卡牌传给 $\\text{C}$（除非 $\\text{B}$ 没有剩余卡牌）。若此时 $\\text{C}$ 拥有相同数值的卡牌对，则立即丢弃这对卡牌。\n   - $\\text{C}$ 将自己的一张卡牌传给 $\\text{A}$（除非 $\\text{C}$ 没有剩余卡牌）。若此时 $\\text{A}$ 拥有相同数值的卡牌对，则立即丢弃这对卡牌。\n\n已知在「打牌」阶段的每轮循环中至少有一对相同数值的卡牌被丢弃。\n\n给定三位玩家在「发牌」阶段结束后的手牌状态，请计算**不同的**游戏过程数量。由于结果可能很大，只需要算出答案对 $(10^9+7)$ 取模的结果。\n\n> 定义：两种游戏过程被视为**不同的**，当且仅当在某一操作步骤中，当前玩家选择传了不同的卡牌。", "inputFormat": "\n\n**本题单个测试点内有多组测试数据。**\n\n第一行输入包含两个整数 $N,T$，其中 $T$ 表示测试数据组数。  \n\n接下来描述 $T$ 组数据。每组数据三行：  \n\n- 第一行，$2N$ 个正整数，表示玩家 $\\text{A}$ 在「发牌」阶段结束后的手牌。  \n- 第二行，$2N$ 个正整数，表示玩家 $\\text{B}$ 在「发牌」阶段结束后的手牌。  \n- 第三行，$2N$ 个正整数，表示玩家 $\\text{C}$ 在「发牌」阶段结束后的手牌。  ", "outputFormat": "每组数据输出一行一个非负整数，表示答案对 $(10^9+7)$ 取模后的结果。  \n", "hint": "\n\n\n### 样例解释\n\n首先，在「弃牌」阶段中，玩家 $\\text{B}$ 弃掉了所有卡牌。此时玩家的手牌状态为：  \n- $\\text{A}$：$1$, $2$；\n- $\\text{B}$：没有牌；\n- $\\text{C}$：$1$, $2$。\n\n游戏有两种不同的进行方式：  \n\n1. $\\text{A}$ 将卡牌 $1$ 传给 $\\text{B}$，然后 $\\text{B}$ 将其传给 $\\text{C}$。此时 $\\text{C}$ 弃掉数值为 $1$ 的卡牌对。接着 $\\text{C}$ 必须将剩余的卡牌传给 $\\text{A}$，$\\text{A}$ 弃掉该卡牌。  \n2. $\\text{A}$ 将卡牌 $2$ 传给 $\\text{B}$，然后 $\\text{B}$ 将其传给 $\\text{C}$。此时 $\\text{C}$ 弃掉数值为 $2$ 的卡牌对。接着 $\\text{C}$ 必须将剩余的卡牌传给 $\\text{A}$，$\\text{A}$ 弃掉该卡牌。  \n\n### 数据范围\n\n\n对于 $100\\%$ 的数据，保证：\n\n- $1\\le N\\le 99$；\n- $1\\le T\\le 10$。\n\n### 子任务\n\n注意限制是等于号，不是小于等于号。\n\n| 编号 | $n=$ | $T=$ | 分值 |\n| :-: | :-: | :-: |  :-: |\n| $1$ | $2$ | $3$ | $10$ |\n| $2$ | $3$ | $5$ | $10$ |\n| $3$ | $10$ | $5$ | $10$ |\n| $4$ | $20$ | $5$ | $10$ |\n| $5$ | $50$ | $10$ | $10$ |\n| $6$ | $60$ | $10$ | $10$ |\n| $7$ | $70$ | $10$ | $10$ |\n| $8$ | $80$ | $10$ | $10$ |\n| $9$ | $90$ | $10$ | $10$ |\n| $10$ | $99$ | $10$ | $10$ |\n\n", "locale": "zh-CN"}}}
{"pid": "P12090", "type": "P", "difficulty": 5, "samples": [], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "交互题", "Special Judge", "RMI（罗马尼亚）"], "title": "[RMI 2019] 秘密排列 / Secret Permutation", "background": "\n\n**不要引入 `permutation.h`。**\n\n你需要在文件头添加\n\n```cpp\nint query(vector<int>);\nvoid answer(vector<int>);\n```\n\n**我们在附件中提供了 Sample Grader。**", "description": "\n**这是一道交互题。本题中，交互库是非自适应的。**\n\n有一个隐藏的 $1\\sim n$ 的排列 $p_1\\sim p_n$。\n\n你可以进行如下的询问：\n\n> **询问** 给定 $1\\sim n$ 的排列 $v_1\\sim v_n$。交互库会返回 \n>\n> $$\\sum_{1\\le i\\le n-1} \\left|p_{v_i}-p_{v_{i+1}}\\right|$$\n\n目标是，找到与 $p$ **等价**的任意一个排列 $p'$。\n> 定义：我们说排列 $p$，$p'$ **等价**，当且仅当它们无法通过询问区分。亦即，无论 $v$ 取什么，询问的答案都相同。\n\n\n### 实现细节\n\n你不需要，也不应该实现 `main` 函数。\n\n你需要在文件头添加\n\n```cpp\nint query(vector<int>);\nvoid answer(vector<int>);\n```\n\n\n你应该实现如下的函数：\n\n```cpp\nvoid solve(int n);\n```\n\n每个测试点中仅调用一次，表示要找出长度为 $n$ 的排列 $1\\sim n$。\n\n你可以调用如下的函数：\n\n```cpp\nint query(vector<int> v);\n```\n\n- 发起一次询问。\n- $v[i-1]=v_i$（$\\forall 1\\le i\\le n$）是一个 $1\\sim n$ 的排列。\n- 返回 $\\displaystyle \\sum_{1\\le i\\le n-1} \\left|p_{v_i}-p_{v_{i+1}}\\right|$。\n\n\n\n```cpp\nvoid answer(vector<int> p);\n```\n\n- 报告排列 $p$。\n- $p[i-1]=p_i$（$\\forall 1\\le i\\le n$）表示你找到的排列。\n- **调用此函数后，程序将立刻终止。**\n\n注意：参数中的数组都是 $\\texttt{0-indexed}$ 的。\n", "inputFormat": "\nSample Grader 输入格式如下：\n\n> $n$\\\n> $p_1$ $p_2$ $\\ldots$ $p_n$", "outputFormat": "\nSample Grader 将如下内容输出到标准输出流：\n\n- 对于每次 `query` 调用，输出参数 $v$ 和 `query` 的返回值；\n- 对于 `answer` 调用，输出答案合法性（Correct / Wrong Answer），$n$，以及你调用 `query` 函数的次数 $q$。", "hint": "\n### 样例交互\n\n样例交互示例如下。\n\n```cpp\nvoid solve(int N) {\n    if (N == 2) {\n        std::vector<int> V = {1, 2};\n        int qAns = query(V);\n        if (qAns == 1) {\n            std::vector<int> P = {1, 2};\n            answer(P);\n        }\n    }\n}\n```\n\n### 数据范围\n\n\n对于 $100\\%$ 的数据，保证 $3\\le n\\le 256$。\n\n### 子任务\n\n| 编号 | $n\\le$ |  分值 |\n| :-: | :-:  | :-: |\n| $1$ | $7$  | $15$ |\n| $2$ | $50$  | $35$ |\n| $3$ | $256$ |  $50$ |\n\n### 计分方式\n\n令调用 `query` 函数的次数为 $q$。\n\n答案错误，超时，内存超限，运行时错误，得 $0$ 分。\n\n否则，得分方式按照如下方式计算：\n\n- $q\\le n$，得 $100\\%$ 测试点满分。\n- $n\\lt q\\le 2n$，得 $\\left(1-\\dfrac{0.4(q-n)}{n}\\right)$ 倍测试点满分（值域为 $[0.6,1)$，线性递减）。\n- $2n\\lt q\\le n^2$，得 $\\left(0.6-\\dfrac{0.4(q-2n)}{n^2-2n}\\right)$ 倍测试点满分（值域为 $[0.2,0.6)$，线性递减）。\n- $q\\gt n^2$，得 $0.2$ 倍测试点满分。\n\n存在得分高于 $98$ 的官解。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RMI 2019] 秘密排列 / Secret Permutation", "background": "\n\n**不要引入 `permutation.h`。**\n\n你需要在文件头添加\n\n```cpp\nint query(vector<int>);\nvoid answer(vector<int>);\n```\n\n**我们在附件中提供了 Sample Grader。**", "description": "\n**这是一道交互题。本题中，交互库是非自适应的。**\n\n有一个隐藏的 $1\\sim n$ 的排列 $p_1\\sim p_n$。\n\n你可以进行如下的询问：\n\n> **询问** 给定 $1\\sim n$ 的排列 $v_1\\sim v_n$。交互库会返回 \n>\n> $$\\sum_{1\\le i\\le n-1} \\left|p_{v_i}-p_{v_{i+1}}\\right|$$\n\n目标是，找到与 $p$ **等价**的任意一个排列 $p'$。\n> 定义：我们说排列 $p$，$p'$ **等价**，当且仅当它们无法通过询问区分。亦即，无论 $v$ 取什么，询问的答案都相同。\n\n\n### 实现细节\n\n你不需要，也不应该实现 `main` 函数。\n\n你需要在文件头添加\n\n```cpp\nint query(vector<int>);\nvoid answer(vector<int>);\n```\n\n\n你应该实现如下的函数：\n\n```cpp\nvoid solve(int n);\n```\n\n每个测试点中仅调用一次，表示要找出长度为 $n$ 的排列 $1\\sim n$。\n\n你可以调用如下的函数：\n\n```cpp\nint query(vector<int> v);\n```\n\n- 发起一次询问。\n- $v[i-1]=v_i$（$\\forall 1\\le i\\le n$）是一个 $1\\sim n$ 的排列。\n- 返回 $\\displaystyle \\sum_{1\\le i\\le n-1} \\left|p_{v_i}-p_{v_{i+1}}\\right|$。\n\n\n\n```cpp\nvoid answer(vector<int> p);\n```\n\n- 报告排列 $p$。\n- $p[i-1]=p_i$（$\\forall 1\\le i\\le n$）表示你找到的排列。\n- **调用此函数后，程序将立刻终止。**\n\n注意：参数中的数组都是 $\\texttt{0-indexed}$ 的。\n", "inputFormat": "\nSample Grader 输入格式如下：\n\n> $n$\\\n> $p_1$ $p_2$ $\\ldots$ $p_n$", "outputFormat": "\nSample Grader 将如下内容输出到标准输出流：\n\n- 对于每次 `query` 调用，输出参数 $v$ 和 `query` 的返回值；\n- 对于 `answer` 调用，输出答案合法性（Correct / Wrong Answer），$n$，以及你调用 `query` 函数的次数 $q$。", "hint": "\n### 样例交互\n\n样例交互示例如下。\n\n```cpp\nvoid solve(int N) {\n    if (N == 2) {\n        std::vector<int> V = {1, 2};\n        int qAns = query(V);\n        if (qAns == 1) {\n            std::vector<int> P = {1, 2};\n            answer(P);\n        }\n    }\n}\n```\n\n### 数据范围\n\n\n对于 $100\\%$ 的数据，保证 $3\\le n\\le 256$。\n\n### 子任务\n\n| 编号 | $n\\le$ |  分值 |\n| :-: | :-:  | :-: |\n| $1$ | $7$  | $15$ |\n| $2$ | $50$  | $35$ |\n| $3$ | $256$ |  $50$ |\n\n### 计分方式\n\n令调用 `query` 函数的次数为 $q$。\n\n答案错误，超时，内存超限，运行时错误，得 $0$ 分。\n\n否则，得分方式按照如下方式计算：\n\n- $q\\le n$，得 $100\\%$ 测试点满分。\n- $n\\lt q\\le 2n$，得 $\\left(1-\\dfrac{0.4(q-n)}{n}\\right)$ 倍测试点满分（值域为 $[0.6,1)$，线性递减）。\n- $2n\\lt q\\le n^2$，得 $\\left(0.6-\\dfrac{0.4(q-2n)}{n^2-2n}\\right)$ 倍测试点满分（值域为 $[0.2,0.6)$，线性递减）。\n- $q\\gt n^2$，得 $0.2$ 倍测试点满分。\n\n存在得分高于 $98$ 的官解。\n", "locale": "zh-CN"}}}
{"pid": "P12091", "type": "P", "difficulty": 5, "samples": [["2\n8\n10 11 12 13 14 16 25 35\n1 0 0 0 1 1 1 1\n2 2 3 3 5 1 1 1\n16\n10 11 12 13 14 15 16 17 18 19 20 23 24 31 33 37\n1 0 0 0 1 0 0 0 1 1 1 1 1 1 1 1\n2 1 7 3 1 10 10 6 5 5 1 6 1 10 8 2", "-1 -1 -1 -1 -1 -1 40 35\n-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 36 24 31 33 37"], ["2\n9\n1 2 3 4 15 16 17 18 19\n0 0 1 1 1 0 0 1 1\n5 7 4 1 2 3 1 6 2\n9\n1 2 3 4 15 16 17 18 19\n0 0 1 1 1 0 0 1 1\n5 7 4 1 2 3 1 6 1", "-1 -1 -1 -1 -1 -1 -1 32 34\n-1 -1 -1 -1 -1 -1 -1 32 23"]], "limits": {"time": [1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "RMI（罗马尼亚）"], "title": "[RMI 2019] 圣诞老人 / Santa Claus", "background": "", "description": "\n众所周知，在平安夜，圣诞老人的工作是从精灵那里获取礼物，并将它们送给孩子们，为他们的内心带来欢乐与幸福。  \n\n城市中有 $N$ 座房子在笔直的道路上。房子编号从 $1\\sim N$。  \n\n对于每座房子 $i$，已知：\n- $X_i$：$X_i$ 表示第 $i$ 座房子沿道路的位置。\n- $H_i\\in \\{0,1\\}$；  \n- $V_i$。 \n    - 如果 $H_i = 0$，则第 $i$ 座房子中有一个精灵，持有一个价值为 $V_i$ 的礼物。\n    - 如果 $H_i = 1$，则第 $i$ 座房子中有一个孩子，正在等待一个最小价值为 $V_i$ 的礼物。  \n\n\n共有 $N$ 个场景。在第 $i$ 个场景中，圣诞老人从坐标 $0$ 进入城市，携带一个空的礼物袋。他首先向右移动，直到到达第 $i$ 座房子（位于坐标 $X_i$），然后向左移动，直到到达某个其他位置 $X_{\\text{left}_i} \\leq X_i$。  \n- 当圣诞老人经过一个精灵的房子且之前未访问过时，他会拿走礼物并放入袋中。  \n- 当圣诞老人经过一个尚未收到礼物的孩子的房子时，他**可以**（但不必须）从袋中挑选一个当前存在的礼物交给孩子，并将该礼物从袋中移除。此操作仅在所选礼物的价值**至少等于**孩子指定的最小价值 $V$ 时才能完成。  \n\n在第 $i$ 个场景中，圣诞老人移动的总距离为 $D_i = 2X_i - X_{\\text{left}_i}$。你的任务是：针对每个场景，找到圣诞老人分发所有精灵礼物所需的最小距离 $D_i$。  \n- 注意：允许某些孩子未收到礼物，但必须满足所有礼物已被分发，且每个孩子至多收到一个礼物。  \n- 如果无法满足条件，则设 $D_i = -1$。特别地，若圣诞老人无法到达所有精灵的房子，则必然无法满足条件。  \n\n", "inputFormat": "\n**本题单个测试点内有多组测试数据。**\n\n第一行输入包含一个整数 $T$（$1 \\leq T \\leq 10$），表示测试数据组数。  \n\n随后描述 $T$ 组数据。每组数据包含四行：  \n\n- 第一行，一个整数 $N$，城市中的房子数量。  \n- 第二行， $N$ 个整数 $X_1, X_2, \\dots, X_N$。  \n- 第三行， $N$ 个整数 $H_1, H_2, \\dots, H_N$。  \n- 第四行， $N$ 个整数 $V_1, V_2, \\dots, V_N$。 \n", "outputFormat": "每组数据，输出一行 $N$ 个整数：$D_1, D_2, \\dots, D_N$。  \n", "hint": "\n\n### 样例解释\n\n\n#### 样例 $1$ 解释\n\n样例 $1$ 第一组数据中，共有 $8$ 座房子。第 $2$、$3$ 和 $4$ 座房子中有 $3$ 个精灵，分别持有价值为 $2$、$3$ 和 $3$ 的礼物。  \n\n第 $5$ 座房子中有一个孩子，期望获得价值为 $5$ 的礼物。由于圣诞老人无法从任何精灵处获取满足此条件的礼物，该孩子将不会收到礼物。  \n\n- 在场景 $1$、$2$ 和 $3$ 中，圣诞老人未访问所有精灵的房子，因此 $D_1 = D_2 = D_3 = -1$。  \n- 在场景 $4$、$5$ 和 $6$ 中，圣诞老人虽访问了精灵，但未找到足够多愿意接受其 $3$ 份礼物的孩子，因此 $D_4 = D_5 = D_6 = -1$。  \n- 在场景 $7$ 中，圣诞老人需要返回到第 $1$ 座房子（$X_{\\text{Left}_7} = 10$）以分发全部 $3$ 份礼物，因此 $D_7 = 40$。  \n- 在场景 $8$ 中，圣诞老人完全无需折返（$X_{\\text{Left}_8} = X_8 = 40$）即可分发所有 $3$ 份礼物，因此 $D_8 = 35$。  \n\n\n### 数据范围\n\n\n对于 $100\\%$ 的数据，保证：\n\n- $1\\le T\\le 10$；\n- $1\\le N\\le 96\\, 068$；\n- $1\\le \\sum N\\le 5\\times 10^5$；\n- $0\\le X_1\\le X_2\\le \\ldots\\le X_N\\le 10^9$；\n- $H_i\\in \\{0,1\\}$；\n- $0\\le V_i\\le N$；\n\n### 子任务\n\n| 编号 | $N\\le $  | 分值 |\n| :-: | :-: |  :-: |\n| $1$ | $84$ | $10$ |\n| $2$ | $169$ | $10$ |\n| $3$ | $1\\, 379$ | $10$ |\n| $4$ | $2\\, 709$ | $10$ |\n| $5$ | $5\\, 562$ | $10$ |\n| $6$ | $13\\, 123$ | $10$ |\n| $7$ | $27\\, 599$ | $10$ |\n| $8$ | $41\\, 646$ | $10$ |\n| $9$ | $95\\, 045$ | $10$ |\n| $10$ | $96\\, 068$  | $10$ |\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RMI 2019] 圣诞老人 / Santa Claus", "background": "", "description": "\n众所周知，在平安夜，圣诞老人的工作是从精灵那里获取礼物，并将它们送给孩子们，为他们的内心带来欢乐与幸福。  \n\n城市中有 $N$ 座房子在笔直的道路上。房子编号从 $1\\sim N$。  \n\n对于每座房子 $i$，已知：\n- $X_i$：$X_i$ 表示第 $i$ 座房子沿道路的位置。\n- $H_i\\in \\{0,1\\}$；  \n- $V_i$。 \n    - 如果 $H_i = 0$，则第 $i$ 座房子中有一个精灵，持有一个价值为 $V_i$ 的礼物。\n    - 如果 $H_i = 1$，则第 $i$ 座房子中有一个孩子，正在等待一个最小价值为 $V_i$ 的礼物。  \n\n\n共有 $N$ 个场景。在第 $i$ 个场景中，圣诞老人从坐标 $0$ 进入城市，携带一个空的礼物袋。他首先向右移动，直到到达第 $i$ 座房子（位于坐标 $X_i$），然后向左移动，直到到达某个其他位置 $X_{\\text{left}_i} \\leq X_i$。  \n- 当圣诞老人经过一个精灵的房子且之前未访问过时，他会拿走礼物并放入袋中。  \n- 当圣诞老人经过一个尚未收到礼物的孩子的房子时，他**可以**（但不必须）从袋中挑选一个当前存在的礼物交给孩子，并将该礼物从袋中移除。此操作仅在所选礼物的价值**至少等于**孩子指定的最小价值 $V$ 时才能完成。  \n\n在第 $i$ 个场景中，圣诞老人移动的总距离为 $D_i = 2X_i - X_{\\text{left}_i}$。你的任务是：针对每个场景，找到圣诞老人分发所有精灵礼物所需的最小距离 $D_i$。  \n- 注意：允许某些孩子未收到礼物，但必须满足所有礼物已被分发，且每个孩子至多收到一个礼物。  \n- 如果无法满足条件，则设 $D_i = -1$。特别地，若圣诞老人无法到达所有精灵的房子，则必然无法满足条件。  \n\n", "inputFormat": "\n**本题单个测试点内有多组测试数据。**\n\n第一行输入包含一个整数 $T$（$1 \\leq T \\leq 10$），表示测试数据组数。  \n\n随后描述 $T$ 组数据。每组数据包含四行：  \n\n- 第一行，一个整数 $N$，城市中的房子数量。  \n- 第二行， $N$ 个整数 $X_1, X_2, \\dots, X_N$。  \n- 第三行， $N$ 个整数 $H_1, H_2, \\dots, H_N$。  \n- 第四行， $N$ 个整数 $V_1, V_2, \\dots, V_N$。 \n", "outputFormat": "每组数据，输出一行 $N$ 个整数：$D_1, D_2, \\dots, D_N$。  \n", "hint": "\n\n### 样例解释\n\n\n#### 样例 $1$ 解释\n\n样例 $1$ 第一组数据中，共有 $8$ 座房子。第 $2$、$3$ 和 $4$ 座房子中有 $3$ 个精灵，分别持有价值为 $2$、$3$ 和 $3$ 的礼物。  \n\n第 $5$ 座房子中有一个孩子，期望获得价值为 $5$ 的礼物。由于圣诞老人无法从任何精灵处获取满足此条件的礼物，该孩子将不会收到礼物。  \n\n- 在场景 $1$、$2$ 和 $3$ 中，圣诞老人未访问所有精灵的房子，因此 $D_1 = D_2 = D_3 = -1$。  \n- 在场景 $4$、$5$ 和 $6$ 中，圣诞老人虽访问了精灵，但未找到足够多愿意接受其 $3$ 份礼物的孩子，因此 $D_4 = D_5 = D_6 = -1$。  \n- 在场景 $7$ 中，圣诞老人需要返回到第 $1$ 座房子（$X_{\\text{Left}_7} = 10$）以分发全部 $3$ 份礼物，因此 $D_7 = 40$。  \n- 在场景 $8$ 中，圣诞老人完全无需折返（$X_{\\text{Left}_8} = X_8 = 40$）即可分发所有 $3$ 份礼物，因此 $D_8 = 35$。  \n\n\n### 数据范围\n\n\n对于 $100\\%$ 的数据，保证：\n\n- $1\\le T\\le 10$；\n- $1\\le N\\le 96\\, 068$；\n- $1\\le \\sum N\\le 5\\times 10^5$；\n- $0\\le X_1\\le X_2\\le \\ldots\\le X_N\\le 10^9$；\n- $H_i\\in \\{0,1\\}$；\n- $0\\le V_i\\le N$；\n\n### 子任务\n\n| 编号 | $N\\le $  | 分值 |\n| :-: | :-: |  :-: |\n| $1$ | $84$ | $10$ |\n| $2$ | $169$ | $10$ |\n| $3$ | $1\\, 379$ | $10$ |\n| $4$ | $2\\, 709$ | $10$ |\n| $5$ | $5\\, 562$ | $10$ |\n| $6$ | $13\\, 123$ | $10$ |\n| $7$ | $27\\, 599$ | $10$ |\n| $8$ | $41\\, 646$ | $10$ |\n| $9$ | $95\\, 045$ | $10$ |\n| $10$ | $96\\, 068$  | $10$ |\n\n", "locale": "zh-CN"}}}
{"pid": "P12092", "type": "P", "difficulty": 3, "samples": [["3\n2 3 1", "4\n2 1\n3 1\n3 2\n2 3"], ["1\n1", "0"], ["2\n1 2", "2\n2 1\n1 2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC2024] Adrenaline Rush", "background": "", "description": "Alice's friend is a big fan of the Adrenaline Rush racing competition and always strives to attend every race. However, this time, Alice is the one watching the race. To ensure her friend does not miss any important details, Alice decides to take notes on everything that happens on the track.\n\nThe first thing Alice notices before the race begins is the numbering of the cars. All the cars line up in front of the starting line in a specific order. The car closest to the line is numbered $1$, the second car is numbered $2$, and so on, up to the last car, which is numbered $n$. How convenient! --- Alice thought.\n\nThe race begins with the countdown: ``Three! Two! One! Go!``. Alice observes that the cars start in their original order. However, as the race progresses, their order changes. She records whenever one car overtakes another, essentially swapping places with it on the track.\n\nDuring the race, Alice notices something curious: no car overtakes another more than once. In other words, for any two cars $x$ and $y$, there are at most two overtakes between them during the race: $x$ overtakes $y$ and/or $y$ overtakes $x$.\n\nAt the end of the race, Alice carefully writes down the final order of the cars $c_1, c_2, \\ldots, c_n$, where $c_1$ represents the winner of the race.\n\nAlice's friend, however, is only interested in the final ranking and discards all of Alice's notes except for the final ordering. As Alice is quite curious, she wonders: What is the longest possible sequence of overtakes she could have observed during the race? Your task is to help Alice answer this question.", "inputFormat": "The first line of the input contains a single integer $n\\;(1 \\le n \\le 1000)$ --- the number of cars in the race.\n\nThe second line contains a permutation $c_1, c_2, \\ldots, c_n\\;(1 \\le c_i \\le n, c_i \\ne c_j)$ --- the final order of the cars.", "outputFormat": "The first line of the output should contain a single integer $m$ --- the maximum possible number of overtakes that can occur during the race.\n\nEach of the next $m$ lines should contain two integers $x$ and $y$ ($1 \\le x, y \\le n$, $x \\ne y$) representing an overtake event, where car $x$ overtakes car $y$. This means that car $x$ was directly behind car $y$ and overtakes it. The overtakes must be listed in the order they occurred during the race.\n\nAfter all $m$ overtakes have occurred, the cars must arrive at the finish line in the order $c_1, c_2, \\ldots, c_n$. Note that any car $x$ should not overtake another car $y$ more than once.\n\nIf there are multiple possible longest sequences of overtakes, output any of them.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC2024] Adrenaline Rush", "background": "", "description": "Alice's friend is a big fan of the Adrenaline Rush racing competition and always strives to attend every race. However, this time, Alice is the one watching the race. To ensure her friend does not miss any important details, Alice decides to take notes on everything that happens on the track.\n\nThe first thing Alice notices before the race begins is the numbering of the cars. All the cars line up in front of the starting line in a specific order. The car closest to the line is numbered $1$, the second car is numbered $2$, and so on, up to the last car, which is numbered $n$. How convenient! --- Alice thought.\n\nThe race begins with the countdown: ``Three! Two! One! Go!``. Alice observes that the cars start in their original order. However, as the race progresses, their order changes. She records whenever one car overtakes another, essentially swapping places with it on the track.\n\nDuring the race, Alice notices something curious: no car overtakes another more than once. In other words, for any two cars $x$ and $y$, there are at most two overtakes between them during the race: $x$ overtakes $y$ and/or $y$ overtakes $x$.\n\nAt the end of the race, Alice carefully writes down the final order of the cars $c_1, c_2, \\ldots, c_n$, where $c_1$ represents the winner of the race.\n\nAlice's friend, however, is only interested in the final ranking and discards all of Alice's notes except for the final ordering. As Alice is quite curious, she wonders: What is the longest possible sequence of overtakes she could have observed during the race? Your task is to help Alice answer this question.", "inputFormat": "The first line of the input contains a single integer $n\\;(1 \\le n \\le 1000)$ --- the number of cars in the race.\n\nThe second line contains a permutation $c_1, c_2, \\ldots, c_n\\;(1 \\le c_i \\le n, c_i \\ne c_j)$ --- the final order of the cars.", "outputFormat": "The first line of the output should contain a single integer $m$ --- the maximum possible number of overtakes that can occur during the race.\n\nEach of the next $m$ lines should contain two integers $x$ and $y$ ($1 \\le x, y \\le n$, $x \\ne y$) representing an overtake event, where car $x$ overtakes car $y$. This means that car $x$ was directly behind car $y$ and overtakes it. The overtakes must be listed in the order they occurred during the race.\n\nAfter all $m$ overtakes have occurred, the cars must arrive at the finish line in the order $c_1, c_2, \\ldots, c_n$. Note that any car $x$ should not overtake another car $y$ more than once.\n\nIf there are multiple possible longest sequences of overtakes, output any of them.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC2024] Adrenaline Rush", "background": "", "description": "Alice 的朋友是《Adrenaline Rush》赛车比赛的忠实粉丝，总是尽力参加每一场比赛。然而，这一次，比赛是 Alice 观看的。为了确保她的朋友不会错过任何重要细节，Alice 决定记录比赛中赛道上发生的所有事情。\n\n比赛开始前，Alice 首先注意到车子的编号。所有车子按特定顺序排在起跑线上，距离起跑线最近的车编号为 $1$，第二辆车编号为 $2$，以此类推，直到最后一辆车，编号为 $n$。这太方便了！——Alice 想。\n\n比赛开始时，倒计时开始：“三！二！一！开始！” Alice 观察到，车子按照最初的顺序起跑。然而，随着比赛的进行，车子的顺序发生了变化。她记录下每次当一辆车超越另一辆车时，基本上是在赛道上交换了位置。\n\n在比赛过程中，Alice 注意到一件有趣的事情：没有任何一辆车超越另一辆车超过一次。换句话说，对于任何两辆车 $x$ 和 $y$，它们之间最多发生两次超车：$x$ 超越 $y$ 或者 $y$ 超越 $x$。\n\n比赛结束后，Alice 仔细写下了车子的最终顺序 $c_1, c_2, \\ldots, c_n$，其中 $c_1$ 代表比赛的冠军。\n\n然而，Alice 的朋友只对最终排名感兴趣，除了最终的顺序，其他记录都被丢弃。由于 Alice 很好奇，她想知道：她在比赛中可能观察到的最长超车序列是什么？你的任务是帮助 Alice 解答这个问题。", "inputFormat": "第一行输入一个整数 $n\\;(1 \\le n \\le 1000)$ —— 参赛车的数量。\n\n第二行输入一个排列 $c_1, c_2, \\ldots, c_n\\;(1 \\le c_i \\le n, c_i \\ne c_j)$ —— 车子最终的顺序。", "outputFormat": "输出的第一行应包含一个整数 $m$ —— 比赛中可能发生的最大超车次数。\n\n接下来的 $m$ 行每行应包含两个整数 $x$ 和 $y$ ($1 \\le x, y \\le n, x \\ne y$)，表示一次超车事件，其中车 $x$ 超越了车 $y$。这意味着车 $x$ 原本在车 $y$ 后面并超越了它。超车事件必须按发生的顺序输出。\n\n所有的 $m$ 次超车发生后，车子应当以 $c_1, c_2, \\ldots, c_n$ 的顺序到达终点。注意，任何车 $x$ 不应当超越另一辆车 $y$ 超过一次。\n\n如果存在多个可能的最长超车序列，输出其中任意一个。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12093", "type": "P", "difficulty": 5, "samples": [["0", "fff0 0026 0003  fff1 0056 0006  fff2 0086 0009  fff3 00b6 000c  fff4 00e6 000f \nfff5 0116 0012  fff6 0146 0015  fff7 0176 0018  fff8 01a6 001b  fff9 01d6 001e \nfffa 0206 0021  fffb 0236 0024  fffc 0266 0027  fffd 0296 002a  fffe 02c6 002d \nffff 02f6 0030                                                  \n0004 fff0 0fff                                                  \n0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n0000 fff0 0fff  0000 fff0 0fff  0000 fff0 0fff  0000 fff0 0fff  0000 fff0 0fff \n0000 fff0 0fff  0000 fff0 0fff  0000 fff0 0fff  0000 fff0 0fff  0000 fff0 0fff \n0000 fff0 0fff  0000 fff0 0fff  0000 fff0 0fff  0000 fff0 0fff  0000 fff0 0fff \n0000 fff0 0fff"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC2024] BitBitJump", "background": "", "description": "BitBitJump is a one instruction set computer. Thus, it has only one instruction: $\\texttt{bbj a, b, c}$, which copies an $a$-th bit of memory to the $b$-th bit of memory and then jumps to address $c$.\n\nLet's consider a 16-bit BitBitJump computer. It has $2^{16}$ bits of memory organized in $2^{12}$ 16-bit words. Words are counted from 0, and \nbits in a word are counted from the least significant (0-th) bit to the most significant (15-th) bit. \n\nThis computer has a single instruction pointer register $(\\mathrm{IP})$, and execution starts with $\\mathrm{IP}=0$. If the current $\\mathrm{IP} \\ge 2^{12}-2$, the computer stops. Otherwise, it uses the $\\mathrm{IP}$-th word as~$a$, the $(\\mathrm{IP}+1)$-th word as~$b$, the $(\\mathrm{IP}+2)$-th word as $c$, and performs the \\texttt{bbj a, b, c} instruction: copies the $(a \\& 15)$-th bit of the $(a \\gg 4)$-th word to the $(b \\& 15)$-th bit of the $(b \\gg 4)$-th word, and sets $\\mathrm{IP}=c$. Here, $\\&$ represents bitwise AND, and $\\gg$ represents bitwise shift right operation. Notice that the value of $c$ is read from memory after the bit copy, so if the instruction modified its own $c$, the new value will be used for $\\mathrm{IP}$.\n\nFor example, the $\\texttt{bbj 32, 35, 5}$ instruction placed at the memory start will\nbe executed as follows:\n\n- $a=32$ and $b=35$ are read from the memory.\n- The 0-th bit of the 2-nd word (its value is $5 \\& 1 = 1$) will be copied to the 3-rd bit of the same word, so the 2-nd word will have the value of $5 + 2^3 = 13$.\n- Then $c=13$ is read from memory, and $\\mathrm{IP}$ is set to 13.\n\nLet's call the $(2^{12}-1)$-th word ($2^{16}-16 \\ldots 2^{16}-1$-th bits of memory) an $\\textit{IO-word}$. An $\\textit{x-comparator}$ is a program which checks whether the value of the IO-word is equal to $x$. It should stop after execution of no more than $2^{12}$ instructions, leaving the lowest bit of the IO-word equal to $1$ if the original value of the IO-word was equal to $x$, and $0$ otherwise.\n\nWrite a program that generates an $x$-comparator for the given value of $x$.", "inputFormat": "The input contains a single decimal integer $x$ ($0 \\le x < 2^{16}$) --- the value for which to build the $x$-comparator.", "outputFormat": "The output should contain the $x$-comparator program dump. Dump consists of values for the first $n$ words of the memory ($1 \\le n \\le 2^{12}-1$). All other words, except the IO-word, are filled with zeroes.\n\nFor each of the $n$ words, output its value as a four-character hexadecimal number. Values should be delimited by space or new line characters.", "hint": "A dump in the sample output contains a 0-comparator. It consists of the following blocks:\n- 16 instructions: the $i$-th of them, counting from 0, copies the $i$-th bit of the input word to the 6-th bit of its own $c$. If the copied bit is zero, it will proceed to the next instruction; otherwise, the next instruction number will be increased by 64.\n- The following instruction copies the 4-th bit of the 0-th word (value 1) to the 0-th bit of the IO-word and jumps to the stop address.\n- 16 unused words filled with 0.\n- 16 equal instructions (starting from word 67). Each of them copies the 0-th bit of the 0-th word (value 0) to the 0-th bit of the IO-word and jumps to the stop address.", "locale": "en", "translations": {"en": {"title": "[NERC2024] BitBitJump", "background": "", "description": "BitBitJump is a one instruction set computer. Thus, it has only one instruction: $\\texttt{bbj a, b, c}$, which copies an $a$-th bit of memory to the $b$-th bit of memory and then jumps to address $c$.\n\nLet's consider a 16-bit BitBitJump computer. It has $2^{16}$ bits of memory organized in $2^{12}$ 16-bit words. Words are counted from 0, and \nbits in a word are counted from the least significant (0-th) bit to the most significant (15-th) bit. \n\nThis computer has a single instruction pointer register $(\\mathrm{IP})$, and execution starts with $\\mathrm{IP}=0$. If the current $\\mathrm{IP} \\ge 2^{12}-2$, the computer stops. Otherwise, it uses the $\\mathrm{IP}$-th word as~$a$, the $(\\mathrm{IP}+1)$-th word as~$b$, the $(\\mathrm{IP}+2)$-th word as $c$, and performs the \\texttt{bbj a, b, c} instruction: copies the $(a \\& 15)$-th bit of the $(a \\gg 4)$-th word to the $(b \\& 15)$-th bit of the $(b \\gg 4)$-th word, and sets $\\mathrm{IP}=c$. Here, $\\&$ represents bitwise AND, and $\\gg$ represents bitwise shift right operation. Notice that the value of $c$ is read from memory after the bit copy, so if the instruction modified its own $c$, the new value will be used for $\\mathrm{IP}$.\n\nFor example, the $\\texttt{bbj 32, 35, 5}$ instruction placed at the memory start will\nbe executed as follows:\n\n- $a=32$ and $b=35$ are read from the memory.\n- The 0-th bit of the 2-nd word (its value is $5 \\& 1 = 1$) will be copied to the 3-rd bit of the same word, so the 2-nd word will have the value of $5 + 2^3 = 13$.\n- Then $c=13$ is read from memory, and $\\mathrm{IP}$ is set to 13.\n\nLet's call the $(2^{12}-1)$-th word ($2^{16}-16 \\ldots 2^{16}-1$-th bits of memory) an $\\textit{IO-word}$. An $\\textit{x-comparator}$ is a program which checks whether the value of the IO-word is equal to $x$. It should stop after execution of no more than $2^{12}$ instructions, leaving the lowest bit of the IO-word equal to $1$ if the original value of the IO-word was equal to $x$, and $0$ otherwise.\n\nWrite a program that generates an $x$-comparator for the given value of $x$.", "inputFormat": "The input contains a single decimal integer $x$ ($0 \\le x < 2^{16}$) --- the value for which to build the $x$-comparator.", "outputFormat": "The output should contain the $x$-comparator program dump. Dump consists of values for the first $n$ words of the memory ($1 \\le n \\le 2^{12}-1$). All other words, except the IO-word, are filled with zeroes.\n\nFor each of the $n$ words, output its value as a four-character hexadecimal number. Values should be delimited by space or new line characters.", "hint": "A dump in the sample output contains a 0-comparator. It consists of the following blocks:\n- 16 instructions: the $i$-th of them, counting from 0, copies the $i$-th bit of the input word to the 6-th bit of its own $c$. If the copied bit is zero, it will proceed to the next instruction; otherwise, the next instruction number will be increased by 64.\n- The following instruction copies the 4-th bit of the 0-th word (value 1) to the 0-th bit of the IO-word and jumps to the stop address.\n- 16 unused words filled with 0.\n- 16 equal instructions (starting from word 67). Each of them copies the 0-th bit of the 0-th word (value 0) to the 0-th bit of the IO-word and jumps to the stop address.", "locale": "en"}, "zh-CN": {"title": "[NERC2024] BitBitJump", "background": "", "description": "BitBitJump 是一种单指令集计算机，仅包含一条指令：$\\texttt{bbj a, b, c}$。该指令将内存的第 $a$ 位复制到第 $b$ 位，然后跳转到地址 $c$。\n\n我们考虑一台 16 位 BitBitJump 计算机，其内存包含 $2^{16}$ 位，组织为 $2^{12}$ 个 16 位字。字从 0 开始编号，每个字中的位从最低有效位（第 0 位）到最高有效位（第 15 位）编号。\n\n该计算机有一个指令指针寄存器 $(\\mathrm{IP})$，执行从 $\\mathrm{IP}=0$ 开始。如果当前 $\\mathrm{IP} \\ge 2^{12}-2$，计算机停止运行。否则，它将 $\\mathrm{IP}$ 指向的字作为 $a$，$(\\mathrm{IP}+1)$ 指向的字作为 $b$，$(\\mathrm{IP}+2)$ 指向的字作为 $c$，执行 \\texttt{bbj a, b, c} 指令：将 $(a \\& 15)$-th 位（即 $a$ 的低 4 位）从 $(a \\gg 4)$-th 字（即 $a$ 右移 4 位后的值）复制到 $(b \\& 15)$-th 位（即 $b$ 的低 4 位）的 $(b \\gg 4)$-th 字，并设置 $\\mathrm{IP}=c$。这里 $\\&$ 表示按位与运算，$\\gg$ 表示右移运算。注意 $c$ 的值是在位复制操作之后从内存中读取的，因此如果指令修改了自己的 $c$，新值将被用作 $\\mathrm{IP}$。\n\n我们称 $(2^{12}-1)$-th 字（内存的第 $2^{16}-16$ 到 $2^{16}-1$ 位）为 $\\textit{IO-word}$。一个 $\\textit{x-比较器}$ 是检查 IO-word 的值是否等于 $x$ 的程序。它应在执行不超过 $2^{12}$ 条指令后停止，如果 IO-word 的原始值等于 $x$，则将 IO-word 的最低位设为 1，否则设为 0。\n\n请编写一个程序，为给定的 $x$ 值生成 $x$-比较器。", "inputFormat": "输入包含一个十进制整数 $x$（$0 \\le x < 2^{16}$），表示要构建比较器的目标值。", "outputFormat": "输出应包含 $x$-比较器的内存转储。转储包含内存前 $n$ 个字的值（$1 \\le n \\le 2^{12}-1$），其余字（除 IO-word 外）填充为零。\n\n每个字的值用 4 个字符的十六进制数表示，值之间用空格或换行符分隔。", "hint": "样例输出中的内存转储包含一个 0-比较器，由以下部分组成：\n1. 16 条指令：从 0 开始编号的第 $i$ 条指令将输入字的第 $i$ 位复制到自己 $c$ 的第 6 位。如果复制的位为 0，则继续执行下一条指令；否则，下一条指令的编号将增加 64。\n2. 后续指令将第 0 个字的第 4 位（值为 1）复制到 IO-word 的第 0 位，并跳转到停止地址。\n3. 16 个未使用的字，填充为 0。\n4. 16 条相同的指令（从第 67 个字开始）：每条指令将第 0 个字的第 0 位（值为 0）复制到 IO-word 的第 0 位，并跳转到停止地址。", "locale": "zh-CN"}}}
{"pid": "P12094", "type": "P", "difficulty": 7, "samples": [["5 5\n1 2\n2 3\n3 4\n4 5\n5 1", "NO"], ["8 10\n1 2\n2 3\n1 3\n1 4\n1 5\n4 5\n5 6\n6 7\n7 8\n8 5", "YES\n4\n1 2 3 2 4 3 1 2 3 2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC2024] Cactus without Bridges", "background": "", "description": "Caroline asked you for help in solving a cactus problem one year ago. During the last year, she researched extensively about cactuses. Today, she is the one presenting the problem.\n\nYou are given a **cactus without bridges** and also **the length of each odd simple cycle is greater than or equal to the number of odd simple cycles in cactus.** Your task is to answer whether it's possible to label the cactus edges with positive integers such that the following conditions are satisfied:\n\n- Let's define the maximum label with $t$. All the integers $1$, $2$, $\\ldots$, $t$ are used in labeling (note that you do not need to minimize or maximize the value of $t$);\n- For each vertex $v$ of the given cactus, the labels of edges incident to the vertex $v$ should be different and should form an interval of consecutive integers.\n\nAn edge in the graph is called $\\textit{bridge}$ if the deletion of that edge increases the number of connected components of the graph. A $\\textit{cactus}$ is a connected undirected graph in which every edge lies on at most one simple cycle. Intuitively, a cactus is a generalization of a tree where some cycles are allowed. Multiedges (multiple edges between a pair of vertices) and loops (edges that connect a vertex to itself) are not allowed in a cactus.", "inputFormat": "The first line contains two integers $n$ and $m$ ($3 \\le n \\le 10^5$, $n \\le m \\le \\lfloor \\frac{3(n - 1)}{2} \\rfloor$) --- the number of vertices and edges in the cactus. Each of the next $m$ lines contains two integers $u$ and $v$ ($1 \\le u, v \\le n$; $u \\ne v$) --- the edges of the cactus. The given cactus satisfies all constraints from the problem statement.", "outputFormat": "If finding the labeling satisfying the problem's conditions is impossible, output the single line with the word $\\tt{NO}$.\nOtherwise, in the first line output the single word $\\tt{YES}$. In the second line output an integer $t$ ($1 \\leq t \\leq m$) --- the number of different labels. In the third line output should contain $m$ integers $c_i$ ($1 \\leq i \\leq m$, $1 \\leq c_i \\leq t$) --- the labels of the edges.", "hint": "### Sample 1\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3spn9huc.png)\n\n### Sample 2\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bwmitfaw.png)", "locale": "en", "translations": {"en": {"title": "[NERC2024] Cactus without Bridges", "background": "", "description": "Caroline asked you for help in solving a cactus problem one year ago. During the last year, she researched extensively about cactuses. Today, she is the one presenting the problem.\n\nYou are given a **cactus without bridges** and also **the length of each odd simple cycle is greater than or equal to the number of odd simple cycles in cactus.** Your task is to answer whether it's possible to label the cactus edges with positive integers such that the following conditions are satisfied:\n\n- Let's define the maximum label with $t$. All the integers $1$, $2$, $\\ldots$, $t$ are used in labeling (note that you do not need to minimize or maximize the value of $t$);\n- For each vertex $v$ of the given cactus, the labels of edges incident to the vertex $v$ should be different and should form an interval of consecutive integers.\n\nAn edge in the graph is called $\\textit{bridge}$ if the deletion of that edge increases the number of connected components of the graph. A $\\textit{cactus}$ is a connected undirected graph in which every edge lies on at most one simple cycle. Intuitively, a cactus is a generalization of a tree where some cycles are allowed. Multiedges (multiple edges between a pair of vertices) and loops (edges that connect a vertex to itself) are not allowed in a cactus.", "inputFormat": "The first line contains two integers $n$ and $m$ ($3 \\le n \\le 10^5$, $n \\le m \\le \\lfloor \\frac{3(n - 1)}{2} \\rfloor$) --- the number of vertices and edges in the cactus. Each of the next $m$ lines contains two integers $u$ and $v$ ($1 \\le u, v \\le n$; $u \\ne v$) --- the edges of the cactus. The given cactus satisfies all constraints from the problem statement.", "outputFormat": "If finding the labeling satisfying the problem's conditions is impossible, output the single line with the word $\\tt{NO}$.\nOtherwise, in the first line output the single word $\\tt{YES}$. In the second line output an integer $t$ ($1 \\leq t \\leq m$) --- the number of different labels. In the third line output should contain $m$ integers $c_i$ ($1 \\leq i \\leq m$, $1 \\leq c_i \\leq t$) --- the labels of the edges.", "hint": "### Sample 1\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3spn9huc.png)\n\n### Sample 2\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bwmitfaw.png)", "locale": "en"}, "zh-CN": {"title": "[NERC2024] Cactus without Bridges", "background": "", "description": "一年前，Caroline 曾请求你帮她解决一个关于仙人掌图的问题。在过去的一年中，她对仙人掌图进行了深入研究。如今，轮到她来出题了。\n\n给定一个**没有桥的仙人掌图**，并且**其中每一个奇环的长度都大于等于仙人掌图中奇环的数量**。你的任务是判断是否可以对仙人掌图的边进行正整数标号，使其满足以下条件：\n\n- 设最大标号为 $t$。所有整数 $1, 2, \\ldots, t$ 都被用于标号（注意，不要求最小化或最大化 $t$ 的值）；\n- 对于仙人掌图中的每个顶点 $v$，与其相连的边所用的标号必须互不相同，且这些标号应构成一个连续整数区间。\n\n图中的一条边称为**桥**，如果删去这条边会使图的连通分量数量增加。**仙人掌图**是一个连通的无向图，其中每条边至多只属于一个简单环。直观来说，仙人掌图是树的一种推广形式，允许存在一些环。仙人掌图中不允许出现重边（连接同一对顶点的多条边）或自环（连接自身的边）。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$（$3 \\le n \\le 10^5$，$n \\le m \\le \\left\\lfloor \\dfrac{3(n - 1)}{2} \\right\\rfloor$）——表示仙人掌图中的顶点数和边数。\n\n接下来的 $m$ 行中，每行包含两个整数 $u$ 和 $v$（$1 \\le u, v \\le n$，$u \\ne v$）——表示仙人掌图中的一条边。\n\n所给的仙人掌图保证满足题目中的所有约束条件。", "outputFormat": "如果无法找到满足要求的标号方式，输出一行：`NO`。\n\n否则，第一行输出 `YES`。第二行输出一个整数 $t$（$1 \\le t \\le m$）——表示使用的不同标号数量。第三行输出 $m$ 个整数 $c_i$（$1 \\le i \\le m$，$1 \\le c_i \\le t$）——表示每条边的标号顺序（与输入中的边顺序对应）。", "hint": "### 样例 1\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3spn9huc.png)\n\n### 样例 2\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bwmitfaw.png)", "locale": "zh-CN"}}}
{"pid": "P12095", "type": "P", "difficulty": 4, "samples": [["5\nset true\nunset true\nset false\nunset false\nunset false\n2\n1 4\n5 2", "5 1 3 2 4"], ["3\nunset true\nunset false\nset true\n0", "2 3 1"], ["2\nunset false\nset true\n1\n2 1", "-1"], ["2\nunset false\nset false\n0", "-1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC2024] DAG Serialization", "background": "", "description": "Consider a simple single-bit boolean register that supports two operations:\n\n- $\\textbf{set}$ --- sets the register to $\\textbf{true}$ if it was $\\textbf{false}$, and returns $\\textbf{true}$; otherwise, it returns $\\textbf{false}$;\n- $\\textbf{unset}$ --- sets the register to $\\textbf{false}$ if it was $\\textbf{true}$, and returns $\\textbf{true}$; otherwise, it returns $\\textbf{false}$.\n\nThe initial state of the register is $\\textbf{false}$. Suppose there were $n$ operations $op_i$ (for $1 \\le i \\le n$) where $\\textbf{at most two operations returned true}$. Also, we are given the partial order of operations as a directed acyclic graph (DAG): an edge $i \\rightarrow j$ means that $op_i$ happened before $op_j$. You are asked whether it is possible to put these operations in some linear sequential order that satisfies the given partial order and such that if operations are applied to the register in that order, their results are the same as given.", "inputFormat": "In the first line, you are given an integer $n$ --- the number of operations ($1 \\le n \\le 10^5$). In the following $n$ lines, you are given operations in the format $\\textit{type} \\textit{result}$, where $\\textit{type}$ is either $\\texttt{set}$ or $\\texttt{unset}$ and $\\textit{result}$ is either $\\texttt{true}$ or $\\texttt{false}$. It is guaranteed that at most two operations have $\\texttt{true}$ results. \n\nIn the next line, you are given an integer $m$ --- the number of arcs of the DAG ($0 \\le m \\le 10^5$). In the following $m$ lines, you are given arcs --- pairs of integers $a$ and $b$ ($1 \\leq a, b \\leq n$; $a \\neq b$). Each arc indicates that operation $op_a$ happened before operation $op_b$.", "outputFormat": "Print any linear order of operations that satisfies the DAG constraints and ensures the results of the operations match the ones given in the input. If a correct operation order does not exist, print $-1$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC2024] DAG Serialization", "background": "", "description": "Consider a simple single-bit boolean register that supports two operations:\n\n- $\\textbf{set}$ --- sets the register to $\\textbf{true}$ if it was $\\textbf{false}$, and returns $\\textbf{true}$; otherwise, it returns $\\textbf{false}$;\n- $\\textbf{unset}$ --- sets the register to $\\textbf{false}$ if it was $\\textbf{true}$, and returns $\\textbf{true}$; otherwise, it returns $\\textbf{false}$.\n\nThe initial state of the register is $\\textbf{false}$. Suppose there were $n$ operations $op_i$ (for $1 \\le i \\le n$) where $\\textbf{at most two operations returned true}$. Also, we are given the partial order of operations as a directed acyclic graph (DAG): an edge $i \\rightarrow j$ means that $op_i$ happened before $op_j$. You are asked whether it is possible to put these operations in some linear sequential order that satisfies the given partial order and such that if operations are applied to the register in that order, their results are the same as given.", "inputFormat": "In the first line, you are given an integer $n$ --- the number of operations ($1 \\le n \\le 10^5$). In the following $n$ lines, you are given operations in the format $\\textit{type} \\textit{result}$, where $\\textit{type}$ is either $\\texttt{set}$ or $\\texttt{unset}$ and $\\textit{result}$ is either $\\texttt{true}$ or $\\texttt{false}$. It is guaranteed that at most two operations have $\\texttt{true}$ results. \n\nIn the next line, you are given an integer $m$ --- the number of arcs of the DAG ($0 \\le m \\le 10^5$). In the following $m$ lines, you are given arcs --- pairs of integers $a$ and $b$ ($1 \\leq a, b \\leq n$; $a \\neq b$). Each arc indicates that operation $op_a$ happened before operation $op_b$.", "outputFormat": "Print any linear order of operations that satisfies the DAG constraints and ensures the results of the operations match the ones given in the input. If a correct operation order does not exist, print $-1$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC2024] DAG Serialization", "background": "", "description": "考虑一个简单的单比特布尔寄存器，它支持两个操作：\n\n- $\\textbf{set}$ —— 如果寄存器是 $\\textbf{false}$，则将其设置为 $\\textbf{true}$，并返回 $\\textbf{true}$；否则，返回 $\\textbf{false}$；\n- $\\textbf{unset}$ —— 如果寄存器是 $\\textbf{true}$，则将其设置为 $\\textbf{false}$，并返回 $\\textbf{true}$；否则，返回 $\\textbf{false}$。\n\n寄存器的初始状态为 $\\textbf{false}$。假设有 $n$ 个操作 $op_i$（$1 \\le i \\le n$），并且 **至多有两个操作返回 true**。同时，我们给出了操作的部分顺序，表示为一个有向无环图（DAG）：边 $i \\rightarrow j$ 表示 $op_i$ 在 $op_j$ 之前发生。你的任务是判断是否可能将这些操作排列成某个线性顺序，使得符合给定的部分顺序，并且如果按照该顺序执行操作，得到的结果与给定的一致。", "inputFormat": "第一行，给定一个整数 $n$ —— 操作的数量（$1 \\le n \\le 10^5$）。接下来的 $n$ 行，每行给出一个操作，格式为 $\\textit{type} \\textit{result}$，其中 $\\textit{type}$ 是 `set` 或 `unset`，$\\textit{result}$ 是 `true` 或 `false`。保证最多有两个操作的结果为 `true`。\n\n接下来的一个整数 $m$，表示有向无环图中的边数（$0 \\le m \\le 10^5$）。接下来的 $m$ 行，每行给出一对整数 $a$ 和 $b$（$1 \\le a, b \\le n$，$a \\neq b$），表示边 $a \\rightarrow b$，即操作 $op_a$ 在操作 $op_b$ 之前发生。", "outputFormat": "如果存在一个线性顺序，满足有向无环图约束，并且能够使得操作的结果与给定的相符，输出任何一个满足条件的线性顺序。如果不存在这样的顺序，输出 $-1$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12096", "type": "P", "difficulty": 4, "samples": [["2+2=4", "Correct"], ["123456789+9876543210=111111110+11-1", "123456789+987654321=1111111100+11-1"], ["10+9=10", "Impossible"], ["24=55-13", "42=55-13"], ["1000000000-10=9999999999", "Impossible\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC2024] Expression Correction", "background": "", "description": "Eve is studying mathematics in school. They've already learned how to perform addition and subtraction of decimal numbers and are practicing it by solving fun puzzles. The specific type of the puzzle they are solving is described below. They are given an equality with addition and subtraction which may or may not be a correct one. They have to verify the equality, and if it is not a correct one, then they have to tell if it is possible to turn it into a correct one by moving one digit to a different place in the equality.\n\nLet us formally define the equality in this puzzle:\n\n- $\\emph{Number}$ is a string of $\\textbf{at least one and at most 10 decimal digits}$ ($\\texttt{0}$ to $\\texttt{9}$) that has no extra leading zeroes (the only number that is allowed to start with the zero digit is $\\texttt{0}$).\n- $\\emph{Expression}$ is a string composed of one or more numbers, as defined above, that are separated with addition ($\\texttt{+}$) or subtraction ($\\texttt{-}$) operators.\n- $\\emph{Equality}$ is a string composed of an expression, as defined above, followed by an equals sign ($\\texttt{=}$), followed by another expression.\n- $\\emph{Correct equality}$ is an equality where both expressions on the left and right hand sides of the equals sign evaluate to the same decimal number according to the standard arithmetic. Note that while all the numbers in the expression are positive, the evaluated number can be negative. Also, the evaluated number can be longer than 10 digits. \n- $\\emph{Moving a digit}$ in an equality means removing a digit from any position in the string and inserting it into another position so that the resulting string is again an equality.\n\nThe puzzle is pretty straightforward once you know how to add and subtract decimal numbers, but it is tenuous. It is easy to get distracted and make a mistake while performing computation. Your task is to write a program that solves the expression correction puzzle to help Eve.", "inputFormat": "The input file consists of a single line --- an equality as defined in the problem statement. The total length of the input string does not exceed 100 characters.", "outputFormat": "Write a single line to the output. If the input contains a correct equality, output a single word $\\texttt{Correct}$. Otherwise, if the input equality can be turned into a correct one by moving one digit, output the resulting correct equality. If there are multiple possible correct equalities after moving one digit, you may output any one of them. Otherwise, output a single word $\\texttt{Impossible}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC2024] Expression Correction", "background": "", "description": "Eve is studying mathematics in school. They've already learned how to perform addition and subtraction of decimal numbers and are practicing it by solving fun puzzles. The specific type of the puzzle they are solving is described below. They are given an equality with addition and subtraction which may or may not be a correct one. They have to verify the equality, and if it is not a correct one, then they have to tell if it is possible to turn it into a correct one by moving one digit to a different place in the equality.\n\nLet us formally define the equality in this puzzle:\n\n- $\\emph{Number}$ is a string of $\\textbf{at least one and at most 10 decimal digits}$ ($\\texttt{0}$ to $\\texttt{9}$) that has no extra leading zeroes (the only number that is allowed to start with the zero digit is $\\texttt{0}$).\n- $\\emph{Expression}$ is a string composed of one or more numbers, as defined above, that are separated with addition ($\\texttt{+}$) or subtraction ($\\texttt{-}$) operators.\n- $\\emph{Equality}$ is a string composed of an expression, as defined above, followed by an equals sign ($\\texttt{=}$), followed by another expression.\n- $\\emph{Correct equality}$ is an equality where both expressions on the left and right hand sides of the equals sign evaluate to the same decimal number according to the standard arithmetic. Note that while all the numbers in the expression are positive, the evaluated number can be negative. Also, the evaluated number can be longer than 10 digits. \n- $\\emph{Moving a digit}$ in an equality means removing a digit from any position in the string and inserting it into another position so that the resulting string is again an equality.\n\nThe puzzle is pretty straightforward once you know how to add and subtract decimal numbers, but it is tenuous. It is easy to get distracted and make a mistake while performing computation. Your task is to write a program that solves the expression correction puzzle to help Eve.", "inputFormat": "The input file consists of a single line --- an equality as defined in the problem statement. The total length of the input string does not exceed 100 characters.", "outputFormat": "Write a single line to the output. If the input contains a correct equality, output a single word $\\texttt{Correct}$. Otherwise, if the input equality can be turned into a correct one by moving one digit, output the resulting correct equality. If there are multiple possible correct equalities after moving one digit, you may output any one of them. Otherwise, output a single word $\\texttt{Impossible}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC2024] Expression Correction", "background": "", "description": "Eve 正在学校学习数学。他们已经学会了如何进行十进制数字的加法和减法，并通过解决有趣的难题进行练习。他们正在解决的难题的具体描述如下：给定一个包含加法和减法的等式，可能是正确的，也可能是错误的。他们需要验证这个等式，如果它不是正确的，那么他们需要判断是否可以通过将一个数字移动到等式的不同位置，使其成为正确的等式。\n\n让我们正式定义这个难题中的等式：\n\n- **数字** 是一个包含 **至少一个，至多十个十进制数字**（$0$ 到 $9$）的字符串，且没有额外的前导零（唯一允许以零开头的数字是 $\\texttt{0}$）。\n- **表达式** 是由一个或多个数字组成的字符串，这些数字通过加法（$\\texttt{+}$）或减法（$\\texttt{-}$）操作符连接。\n- **等式** 是一个由表达式（如上所述）组成的字符串，后面跟一个等号（$\\texttt{=}$），然后是另一个表达式。\n- **正确的等式** 是一个等式，其中等号两边的表达式根据标准的算术运算计算后得到相同的十进制数。请注意，尽管表达式中的所有数字都是正数，但计算结果可以为负数。此外，计算结果可以超过 10 位数字。\n- **移动数字** 在一个等式中意味着从字符串的任何位置删除一个数字并将其插入到另一个位置，从而使得结果字符串仍然是一个等式。\n\n这个难题相当简单，一旦你知道如何进行十进制数字的加法和减法，但是它也很容易出错。在进行计算时很容易分心并犯错误。你的任务是编写一个程序，帮助 Eve 解决表达式纠错难题。", "inputFormat": "输入文件包含一行 —— 如题目所述定义的等式。输入字符串的总长度不超过 100 个字符。", "outputFormat": "输出一行。如果输入包含一个正确的等式，输出一个单词 $\\texttt{Correct}$。否则，如果输入的等式通过移动一个数字可以变成正确的等式，输出得到的正确等式。如果有多个可能的正确等式，可以输出其中任何一个。否则，输出一个单词 $\\texttt{Impossible}$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12097", "type": "P", "difficulty": 3, "samples": [["4\n10\n#.......##\n##..#.##..\n6\n...#..\n..#...\n8\n........\n........\n3\n###\n###", "Unique\nNone\nMultiple\nUnique"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "ICPC", "NERC/NEERC"], "title": "[NERC2024] Fix Flooded Floor", "background": "", "description": "Archimedes conducted his famous experiments on buoyancy. But not everyone knows that while he was taking a bath, he was too focused and didn't notice the moment when the water overflowed over the edge of the bath and flooded the floor near the wall. His expensive parquet was irreversibly damaged!\n\nArchimedes noticed that not all was lost, and there were still several undamaged parquet pieces. The parquet near the wall had the shape of a long narrow stripe of $2\\times n$ cells. Archimedes had an unlimited supply of $1\\times 2$ parquet pieces that could be placed parallel or perpendicular to the wall. Archimedes didn't want to cut the parquet pieces. As a great scientist, he figured out that there was exactly one way to restore the parquet by filling the damaged area of the parquet with the non-overlapping $1\\times 2$ cell shaped pieces.\n\nHelp historians to check Archimedes' calculations. For the given configuration of the $2\\times n$ parquet floor, determine whether there is exactly one way to fill the damaged parquet cells with the $1\\times 2$ cell parquet pieces. If Archimedes was wrong, find out whether there are multiple ways to restore the parquet, or there are no ways at all.", "inputFormat": "The first line contains a single integer $T$ ($1 \\le T \\le 10^4$)~--- the number of test cases to solve.\n\nThen the description of test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2\\cdot 10^5$) --- the length of the parquet floor.\n\nThe following two lines contain exactly $n$ characters each and describe the parquet, where $\\texttt{.}$ denotes a damaged cell and $\\texttt{\\#}$ denotes an undamaged cell.\n\nThe total sum of $n$ in all $T$ test cases doesn't exceed $2\\cdot 10^5$.", "outputFormat": "For each test case, print $\\tt{Unique}$ if there is exactly one way to restore the parquet, $\\tt{Multiple}$ if there are multiple ways to do so, or $\\tt{None}$ if it is impossible to restore the parquet.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC2024] Fix Flooded Floor", "background": "", "description": "Archimedes conducted his famous experiments on buoyancy. But not everyone knows that while he was taking a bath, he was too focused and didn't notice the moment when the water overflowed over the edge of the bath and flooded the floor near the wall. His expensive parquet was irreversibly damaged!\n\nArchimedes noticed that not all was lost, and there were still several undamaged parquet pieces. The parquet near the wall had the shape of a long narrow stripe of $2\\times n$ cells. Archimedes had an unlimited supply of $1\\times 2$ parquet pieces that could be placed parallel or perpendicular to the wall. Archimedes didn't want to cut the parquet pieces. As a great scientist, he figured out that there was exactly one way to restore the parquet by filling the damaged area of the parquet with the non-overlapping $1\\times 2$ cell shaped pieces.\n\nHelp historians to check Archimedes' calculations. For the given configuration of the $2\\times n$ parquet floor, determine whether there is exactly one way to fill the damaged parquet cells with the $1\\times 2$ cell parquet pieces. If Archimedes was wrong, find out whether there are multiple ways to restore the parquet, or there are no ways at all.", "inputFormat": "The first line contains a single integer $T$ ($1 \\le T \\le 10^4$)~--- the number of test cases to solve.\n\nThen the description of test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 2\\cdot 10^5$) --- the length of the parquet floor.\n\nThe following two lines contain exactly $n$ characters each and describe the parquet, where $\\texttt{.}$ denotes a damaged cell and $\\texttt{\\#}$ denotes an undamaged cell.\n\nThe total sum of $n$ in all $T$ test cases doesn't exceed $2\\cdot 10^5$.", "outputFormat": "For each test case, print $\\tt{Unique}$ if there is exactly one way to restore the parquet, $\\tt{Multiple}$ if there are multiple ways to do so, or $\\tt{None}$ if it is impossible to restore the parquet.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC2024] Fix Flooded Floor", "background": "", "description": "阿基米德进行了他的著名浮力实验。但是少有人知道，他洗澡时太过专注，没有注意到水从浴缸边溢出，使他的木地板发生了不可逆的破坏。\n\n阿基米德发现，并非所有地板都损坏了，还剩下一些地板是完好的。墙边的木地板区域形状为 $2 \\times n$ 的长条带。阿基米德有无限多的 $1 \\times 2$ 地板块，它们可以平行或垂直于墙壁放置。阿基米德不想分割这些板块。作为伟大的科学家，他知道了恰好存在一种通过使用不重叠的 $1 \\times 2$ 地板块修复损坏区域的方式。\n\n帮助历史学家检查阿基米德的演算，对于给定的 $2 \\times n$ 的木地板，判断是否恰好存在一种方法，使得可以用 $1 \\times 2$ 地板块修复损坏区域。如果他的结果错了，请回答是存在多种修复方式还是不存在方式。", "inputFormat": "第一行包括一个整数 $T$ ($1 \\le T \\le 10^4$)，表示测试用例的数量。\n\n之后是测试用例的描述。\n\n每个测试用例的第一行包括一个整数 $n$ ($1 \\le n \\le 2 \\cdot 10^5$)，表示木地板的长度。\n\n接下来的两行各有 $n$ 个字符，表示木地板的状态，其中 $\\texttt{.}$  表示损坏的区域，$\\texttt{\\#}$ 表示完好的区域。\n\n总共 $T$ 个测试用例中 $\\sum n$ 不超过 $2 \\cdot 10^5$ 。", "outputFormat": "对于每个测试用例，若恰好存在一种修复的方式，输出 $\\tt{Unique}$；，若存在多种方式，输出 $\\tt{Mutiple}$；若无法修复，输出 $\\tt{None}$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12098", "type": "P", "difficulty": 6, "samples": [["1\ndraw 10", "180"], ["7\ndraw 1\nrotate 90\ndraw 1\nrotate 90\ndraw 1\nrotate 90\ndraw 1", "90"], ["3\ndraw 1\nmove 1\ndraw 2", "360"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "ICPC", "NERC/NEERC"], "title": "[NERC2024] Geometric Balance", "background": "", "description": "Peter's little brother Ivan likes to play with a turtle. The turtle is a special toy that lives on the plane and can execute three commands:\n  - Rotate $a$ degrees counterclockwise.\n  - Draw $d$ units in the direction it is facing while dispensing ink. No segment of the plane will be covered by ink more than once.\n  - Move $d$ units in the direction it is facing without drawing.\n\nIvan just learned about the compass, so he will only rotate his turtle so it faces one of eight cardinal or ordinal directions (angles $a$ in rotate commands are always divisible by 45). Also, he will perform at least one draw command.\n\nPeter has noted all the commands Ivan has given to his turtle. He thinks that the image drawn by the turtle is adorable. Now Peter wonders about the smallest positive angle $b$ such that he can perform the following operations: move the turtle to a point of his choosing, rotate it by $b$ degrees, and execute all the commands in the same order. These operations should produce the same image as the original one. Can you help Peter?\n\nNote, two images are considered $\\emph{the same}$ if the sets of points covered by ink on the plane are the same in both of the images.", "inputFormat": "The first line of the input contains a single integer $n\\;(1 \\le n \\le 50000)$ --- the number of commands Ivan has given.\n\nThe next $n$ lines contain commands. Each command is one of:\n\n- $\\texttt{rotate}$ $a$ ($45 \\le a \\le 360$) where $a$ is divisible by $45$;\n- $\\texttt{draw}$ $d$ ($1 \\le d \\le 10^9$);\n- $\\texttt{move}$ $d$ ($1 \\le d \\le 10^9$).\n\nAt least one and $\\textbf{at most 2000}$ of the commands are $\\texttt{draw}$. It is guaranteed that no segment of the plane will be covered by ink more than once.", "outputFormat": "Output a single number, the answer to the question. The answer always exists.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC2024] Geometric Balance", "background": "", "description": "Peter's little brother Ivan likes to play with a turtle. The turtle is a special toy that lives on the plane and can execute three commands:\n  - Rotate $a$ degrees counterclockwise.\n  - Draw $d$ units in the direction it is facing while dispensing ink. No segment of the plane will be covered by ink more than once.\n  - Move $d$ units in the direction it is facing without drawing.\n\nIvan just learned about the compass, so he will only rotate his turtle so it faces one of eight cardinal or ordinal directions (angles $a$ in rotate commands are always divisible by 45). Also, he will perform at least one draw command.\n\nPeter has noted all the commands Ivan has given to his turtle. He thinks that the image drawn by the turtle is adorable. Now Peter wonders about the smallest positive angle $b$ such that he can perform the following operations: move the turtle to a point of his choosing, rotate it by $b$ degrees, and execute all the commands in the same order. These operations should produce the same image as the original one. Can you help Peter?\n\nNote, two images are considered $\\emph{the same}$ if the sets of points covered by ink on the plane are the same in both of the images.", "inputFormat": "The first line of the input contains a single integer $n\\;(1 \\le n \\le 50000)$ --- the number of commands Ivan has given.\n\nThe next $n$ lines contain commands. Each command is one of:\n\n- $\\texttt{rotate}$ $a$ ($45 \\le a \\le 360$) where $a$ is divisible by $45$;\n- $\\texttt{draw}$ $d$ ($1 \\le d \\le 10^9$);\n- $\\texttt{move}$ $d$ ($1 \\le d \\le 10^9$).\n\nAt least one and $\\textbf{at most 2000}$ of the commands are $\\texttt{draw}$. It is guaranteed that no segment of the plane will be covered by ink more than once.", "outputFormat": "Output a single number, the answer to the question. The answer always exists.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC2024] Geometric Balance", "background": "", "description": "Peter 的弟弟 Ivan 喜欢和一只小乌龟玩耍。这只乌龟是一种特殊的玩具，它生活在平面上，能够执行三种指令：\n\n- 逆时针旋转 $a$ 度；\n- 沿当前朝向绘制 $d$ 个单位长度的线段，并留下墨迹。平面上的任意线段最多只会被涂墨一次；\n- 沿当前朝向移动 $d$ 个单位长度，但不留下任何痕迹。\n\nIvan 刚刚学会使用指南针，因此他只会让乌龟朝向八个基本方向或次方向旋转（旋转角度 $a$ 总是 $45$ 的倍数）。此外，他至少会发出一条 $\\texttt{draw}$ 指令。\n\nPeter 记录了 Ivan 给乌龟下达的所有指令。他觉得乌龟绘制出的图案非常可爱。现在 Peter 想知道一个最小的正角度 $b$，使得他可以进行如下操作：将乌龟移动到任意位置，将其旋转 $b$ 度，然后按原顺序重新执行全部指令，最终绘制出的图案与原图案完全一致。\n\n你能帮 Peter 找出这个最小的角度 $b$ 吗？\n\n注意，如果两幅图在平面上被墨迹覆盖的点集合相同，则认为它们是**相同**的图案。", "inputFormat": "第一行输入一个整数 $n\\;(1 \\le n \\le 50000)$ —— 表示 Ivan 发出的指令数。\n\n接下来的 $n$ 行中，每行表示一条指令，格式如下之一：\n\n- $\\texttt{rotate}$ $a$（$45 \\le a \\le 360$，并且 $a$ 是 $45$ 的倍数）；\n- $\\texttt{draw}$ $d$（$1 \\le d \\le 10^9$）；\n- $\\texttt{move}$ $d$（$1 \\le d \\le 10^9$）。\n\n保证至少有一条且最多 $2000$ 条指令为 $\\texttt{draw}$。同时保证绘图过程中，平面上不会有任何线段被重复涂墨。", "outputFormat": "输出一个整数，表示最小的角度 $b$，使得执行指定的操作后能够得到与原图案相同的结果。答案总是存在。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12099", "type": "P", "difficulty": 7, "samples": [["9 2\n\n0\n\n1\n\n1\n\n0\n\n1\n\n2\n\n1\n\n0\n\n0\n\n3", "\n3\n\n7\n\n5\n\n1\n\n9\n\n4\n\n5\n\n7\n\n0\n\n2"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "交互题", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC2024] Hunting Hoglins in Hogwarts", "background": "", "description": "This is an interactive problem.\n\nHarry and Hermione are trying to hunt down $\\emph{hoglins}$ which are haunting Hogwarts. There is a long hallway in Hogwarts, consisting of $n$ individual $\\emph{cells}$, numbered from $1$ to $n$ from the left to the right.\n\nHermione can cast a spell that would $\\emph{block}$ any cell of the hallway of her choosing. After the spell is cast, the blocked cell will remain blocked while she casts other spells.\n\nHoglins are simple creatures; all they do is randomly move around and bump into stuff. To be more precise, every hoglin has a range which it considers to be $\\emph{accessible}$. Initially, when the hoglin appears, it is a range from the cell $1$ to the cell $n$.\n\nInitially, a single hoglin appears in a cell of the hallway chosen uniformly at random. Then, until this hoglin is caught, the following happens on every $\\emph{round}$ of the hunt:\n\n- Hermione can cast a spell to block any single cell of her choosing, or do nothing.\n- If the cell she is trying to block is the cell with a hoglin in it, the hoglin is caught. After that, all the blocked cells become free again, and, if there are more hoglins to be caught, a new hoglin immediately appears in a random location, and the hunt begins again.\n- Otherwise, the hoglin chooses a cell uniformly at random from its accessible range and tries to move to that cell, moving one cell at a time towards a chosen cell. Regardless of the distance, all the steps of the movement, as described below, happen in the same round.\n- If the chosen cell is to the right of the hoglin, it moves to the right; if the chosen cell is to the left of the hoglin, it moves to the left. If the chosen cell is the same as where the hoglin is now, it does nothing.\n- If at any point during the movement towards the chosen cell a hoglin is trying to move to the right or to the left from an unblocked cell at position $i$ to the neighbouring blocked cell at position $i \\pm 1$, the hoglin updates the right or left boundary of its accessible range correspondingly to be $i$.\n- If on the way to the chosen cell, the hoglin tries to move to a blocked cell, Harry and Hermione hear a loud sound, as the hoglin $\\emph{bumps}$ into the blocked cell. In this case, the hoglin returns to the position it has originally started from at the beginning of this round. \n- Otherwise, if the hoglin does not bump into any blocked cells on its way, it does not change its accessible range and stays at the new position. In that case, Harry and Hermione hear nothing.\n\nTo free Hogwarts from hoglins, Harry and Hermione should catch $k$ of them, but they don't have much time. They can only afford to hunt hoglins for at most $200\\,000$ rounds. Please help them find an efficient strategy to do that.\n\n**Interaction Protocol**\n\nFirst, the testing system will write two integers $n$ and $k$ ($1 \\le n \\le 10^{18}; 1 \\le k \\le 800)$ --- the number of cells in Hogwarts' hallway and the number of hoglins that should be caught. Then the catching process begins.\n\nThe following interaction proceeds in rounds as described in the problem statement.\n\nAt the start of each round, your program should output Hermione's action --- an integer $p$ ($0 \\le p \\le n$) representing the position of the cell Hermione is going to block. If $p = 0$ or the cell at position $p$ is already blocked, she does nothing in this round.\n\nThen, if the current position of the hoglin is at the newly blocked cell $p$, the hoglin is caught; the testing system outputs $\\texttt{2}$, all the blocked cells become free, and interaction rounds start again. In case you caught the $k$-th hoglin, the testing system outputs $\\texttt{3}$ instead of $\\texttt{2}$, and your program should immediately stop execution.\n\nOtherwise, the hoglin attempts to move according to the rules described in the problem statement. If in the process it bumps into any blocked cell, the testing system outputs $\\texttt{1}$; otherwise, it outputs $\\texttt{0}$.\n\nIf your $200\\,000$-th action does not catch the $k$-th hoglin, the testing system outputs $\\texttt{-1}$ instead of its usual answer, and your program should immediately stop execution to guarantee the `Wrong Answer` verdict.\n\nThe interactor in this problem is not adaptive. It is guaranteed that the hoglins follow the rules described in the problem statement. The starting cell for each hoglin is chosen uniformly at random and their moves are chosen uniformly at random from the range of cells that they consider accessible.\n\nThe problem has at most $15$ tests.\n\nHere is the summary of all possible interactor answers:\n- $\\texttt{-1}$ --- too many actions;\n- $\\texttt{0}$ --- hoglin moved successfully, did not bump;\n- $\\texttt{1}$ --- hoglin attempted to move, bumped into blocked cell;\n- $\\texttt{2}$ --- hoglin is caught, interaction starts again;\n- $\\texttt{3}$ --- hoglin is caught, stop.", "inputFormat": "See also **Interaction Protocol**.", "outputFormat": "See also **Interaction Protocol**.", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/h3gyhxo6.png)\n\nWe show the sample from the point of view of the hoglins.\n\nThe black dot shows the current position of the hoglin.\n\nCrosses mark blocked cells.\n\nWhite cells mark the range which the hoglin considers to be accessible; other cells are marked gray.\n\nOn the right is the action that was performed by either Hermione or the hoglin to get to this state from the previous one.", "locale": "en", "translations": {"en": {"title": "[NERC2024] Hunting Hoglins in Hogwarts", "background": "", "description": "This is an interactive problem.\n\nHarry and Hermione are trying to hunt down $\\emph{hoglins}$ which are haunting Hogwarts. There is a long hallway in Hogwarts, consisting of $n$ individual $\\emph{cells}$, numbered from $1$ to $n$ from the left to the right.\n\nHermione can cast a spell that would $\\emph{block}$ any cell of the hallway of her choosing. After the spell is cast, the blocked cell will remain blocked while she casts other spells.\n\nHoglins are simple creatures; all they do is randomly move around and bump into stuff. To be more precise, every hoglin has a range which it considers to be $\\emph{accessible}$. Initially, when the hoglin appears, it is a range from the cell $1$ to the cell $n$.\n\nInitially, a single hoglin appears in a cell of the hallway chosen uniformly at random. Then, until this hoglin is caught, the following happens on every $\\emph{round}$ of the hunt:\n\n- Hermione can cast a spell to block any single cell of her choosing, or do nothing.\n- If the cell she is trying to block is the cell with a hoglin in it, the hoglin is caught. After that, all the blocked cells become free again, and, if there are more hoglins to be caught, a new hoglin immediately appears in a random location, and the hunt begins again.\n- Otherwise, the hoglin chooses a cell uniformly at random from its accessible range and tries to move to that cell, moving one cell at a time towards a chosen cell. Regardless of the distance, all the steps of the movement, as described below, happen in the same round.\n- If the chosen cell is to the right of the hoglin, it moves to the right; if the chosen cell is to the left of the hoglin, it moves to the left. If the chosen cell is the same as where the hoglin is now, it does nothing.\n- If at any point during the movement towards the chosen cell a hoglin is trying to move to the right or to the left from an unblocked cell at position $i$ to the neighbouring blocked cell at position $i \\pm 1$, the hoglin updates the right or left boundary of its accessible range correspondingly to be $i$.\n- If on the way to the chosen cell, the hoglin tries to move to a blocked cell, Harry and Hermione hear a loud sound, as the hoglin $\\emph{bumps}$ into the blocked cell. In this case, the hoglin returns to the position it has originally started from at the beginning of this round. \n- Otherwise, if the hoglin does not bump into any blocked cells on its way, it does not change its accessible range and stays at the new position. In that case, Harry and Hermione hear nothing.\n\nTo free Hogwarts from hoglins, Harry and Hermione should catch $k$ of them, but they don't have much time. They can only afford to hunt hoglins for at most $200\\,000$ rounds. Please help them find an efficient strategy to do that.\n\n**Interaction Protocol**\n\nFirst, the testing system will write two integers $n$ and $k$ ($1 \\le n \\le 10^{18}; 1 \\le k \\le 800)$ --- the number of cells in Hogwarts' hallway and the number of hoglins that should be caught. Then the catching process begins.\n\nThe following interaction proceeds in rounds as described in the problem statement.\n\nAt the start of each round, your program should output Hermione's action --- an integer $p$ ($0 \\le p \\le n$) representing the position of the cell Hermione is going to block. If $p = 0$ or the cell at position $p$ is already blocked, she does nothing in this round.\n\nThen, if the current position of the hoglin is at the newly blocked cell $p$, the hoglin is caught; the testing system outputs $\\texttt{2}$, all the blocked cells become free, and interaction rounds start again. In case you caught the $k$-th hoglin, the testing system outputs $\\texttt{3}$ instead of $\\texttt{2}$, and your program should immediately stop execution.\n\nOtherwise, the hoglin attempts to move according to the rules described in the problem statement. If in the process it bumps into any blocked cell, the testing system outputs $\\texttt{1}$; otherwise, it outputs $\\texttt{0}$.\n\nIf your $200\\,000$-th action does not catch the $k$-th hoglin, the testing system outputs $\\texttt{-1}$ instead of its usual answer, and your program should immediately stop execution to guarantee the `Wrong Answer` verdict.\n\nThe interactor in this problem is not adaptive. It is guaranteed that the hoglins follow the rules described in the problem statement. The starting cell for each hoglin is chosen uniformly at random and their moves are chosen uniformly at random from the range of cells that they consider accessible.\n\nThe problem has at most $15$ tests.\n\nHere is the summary of all possible interactor answers:\n- $\\texttt{-1}$ --- too many actions;\n- $\\texttt{0}$ --- hoglin moved successfully, did not bump;\n- $\\texttt{1}$ --- hoglin attempted to move, bumped into blocked cell;\n- $\\texttt{2}$ --- hoglin is caught, interaction starts again;\n- $\\texttt{3}$ --- hoglin is caught, stop.", "inputFormat": "See also **Interaction Protocol**.", "outputFormat": "See also **Interaction Protocol**.", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/h3gyhxo6.png)\n\nWe show the sample from the point of view of the hoglins.\n\nThe black dot shows the current position of the hoglin.\n\nCrosses mark blocked cells.\n\nWhite cells mark the range which the hoglin considers to be accessible; other cells are marked gray.\n\nOn the right is the action that was performed by either Hermione or the hoglin to get to this state from the previous one.", "locale": "en"}, "zh-CN": {"title": "[NERC2024] Hunting Hoglins in Hogwarts", "background": "", "description": "这是一道交互题。\n\nHarry 和 Hermione 正在猎捕潜伏在霍格沃茨的 **霍格林**。霍格沃茨有一条长长的走廊，由 $n$ 个独立的**单元格**组成，从左到右编号为 $1$ 到 $n$。\n\nHermione 可以施展咒语**封锁**她选择的任意一个单元格。一旦施法，该单元格将持续处于封锁状态，直到该轮结束，即使她随后继续施展其他咒语。\n\n霍格林是一种很简单的生物，它们只会随机移动并撞上障碍。更准确地说，每只霍格林都有一个它认为可以活动的**可达范围**。最初，当霍格林出现时，它的可达范围是整个走廊，即第 $1$ 到第 $n$ 个单元格。\n\n每一只霍格林初始随机地出现在走廊中的某个单元格内。之后，在猎捕过程中，每一轮按照如下流程进行：\n\n- Hermione 可以选择一个单元格进行封锁，或者什么都不做；\n- 如果她试图封锁的单元格正好是霍格林所在的位置，那么霍格林就被捕获。随后所有被封锁的单元格被解除封锁，如果还有霍格林待抓捕，则一只新的霍格林立即随机出现，猎捕继续进行；\n- 否则，霍格林会从它的当前**可达范围**中随机选择一个单元格，试图向该单元格移动，该移动将在同一轮内完成，无论其距离多远，具体过程如下：\n  - 如果目标单元格在当前霍格林位置的右侧，则霍格林向右移动；如果在左侧，则向左移动；若目标与当前位置相同，则不移动；\n  - 在向目标移动的过程中，若霍格林从某个未封锁的位置 $i$ 试图前往其相邻的封锁位置 $i \\pm 1$，则霍格林将更新其可达范围的右边界或左边界为 $i$；\n  - 如果霍格林在前往目标单元格的路途中**撞上**了封锁单元格，则 Harry 和 Hermione 会听到一声巨响，此时霍格林会回到本轮开始时的初始位置；\n  - 否则，如果途中没有撞到封锁单元格，则霍格林成功移动至目标位置，并保留原有的可达范围。Harry 和 Hermione 什么也不会听到。\n\n为了彻底清除霍格沃茨中的霍格林，Harry 和 Hermione 需要抓到 $k$ 只霍格林，但时间有限。他们最多只能进行 $200\\,000$ 轮操作。请帮助他们设计高效的策略。\n\n### 交互协议说明\n\n首先，评测器会输出两个整数 $n$ 和 $k$（$1 \\le n \\le 10^{18}$，$1 \\le k \\le 800$），分别表示走廊的长度和需要抓捕的霍格林数量。接下来开始进行猎捕。\n\n之后交互按轮进行，每轮遵循题目描述的流程：\n\n- 你的程序需输出一个整数 $p$（$0 \\le p \\le n$），表示 Hermione 本轮选择封锁的位置。如果 $p=0$ 或 $p$ 所在单元格已被封锁，则 Hermione 本轮不进行操作。\n\n- 若当前霍格林正好位于被封锁的位置 $p$，则该霍格林被捕获，评测器输出 $\\texttt{2}$，所有封锁单元格解除，并立即生成新的霍格林，猎捕继续进行；\n  - 若这是第 $k$ 个被捕获的霍格林，评测器输出 $\\texttt{3}$，你的程序应立即退出。\n\n- 若未抓到霍格林，评测器将模拟霍格林的移动并输出如下之一：\n  - $\\texttt{0}$：霍格林成功移动到目标位置，途中没有撞击；\n  - $\\texttt{1}$：霍格林在移动途中撞到了封锁单元格，发出声响并返回原位。\n\n- 若你的程序在第 $200\\,000$ 轮仍未成功抓到第 $k$ 个霍格林，评测器将输出 $\\texttt{-1}$，你的程序应立即退出，否则将判定为 `Wrong Answer`。", "inputFormat": "详见 **交互协议说明**。", "outputFormat": "详见 **交互协议说明**。", "hint": "下图展示了从霍格林的视角观察的一个示例状态：\n\n- 黑点表示当前霍格林的位置；\n- 十字表示被封锁的单元格；\n- 白色区域表示霍格林认为的可达范围；\n- 灰色区域为其不可达区域；\n- 图右侧注释了 Hermione 或霍格林执行的操作，导致状态变化。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/h3gyhxo6.png)", "locale": "zh-CN"}}}
{"pid": "P12100", "type": "P", "difficulty": 6, "samples": [["5 7\n1 3 5\n4 5 2\n3 4 3\n1 5 9\n4 2 8\n5 2 11\n3 5 5", "2"], ["6 6\n1 2 5\n2 3 9\n1 4 11\n2 1 1000000\n5 3 15\n5 6 1", "-1"], ["4 7\n1 2 5\n1 1 30\n3 2 9\n1 4 11\n1 4 16\n2 1 1000000\n1 4 11", "4"], ["2 0", "-1"], ["6 7\n1 2 5\n2 3 9\n1 6 11\n2 1 1000000\n1 5 9\n5 6 2\n5 4 4", "1"], ["4 4\n1 4 6\n1 3 2\n3 2 3\n3 4 4", "1"], ["3 2\n1 2 1\n1 3 1", "0"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "ICPC", "NERC/NEERC"], "title": "[NERC2024] Incompetent Delivery Guy", "background": "", "description": "In Isengard, wizard Saruman, with the help of some magic spells, organized a transport system between $n$ towers. To be precise, he created $m$ one-directional passages, each connecting two towers. Each passage $i$ has some number $t_i$ associated with it, meaning the time it takes, in seconds, for an orc to travel along it. In other words, Saruman's transport system can be represented with a directed weighted graph.\n\nOn December 15th, Saruman, sitting in the middle tower called $\\textit{Orthanc}$, gets a message from Sauron (via palantir) which says that a valuable present is already near Isengard's entrance tower. So, Saruman needs to instruct the garrison to select one of the orcs and send them with a gift along the shortest path from the entrance tower to Orthanc.\n\nUnfortunately, orcs... aren't exactly smart fellas. Although they are able to drag a load along passages in the transport system and they (at least, in principle) know where Orthanc is, orcs have a really poor understanding of the concept of the shortest path. To make everyone's lives easier, on some towers Saruman puts a huge flashing pointer which says $\\textbf{TO ORTHANC~--- THIS WAY}$ and points to one of the passages leading from this tower. Saruman wants orcs to reach Orthanc as fast as possible --- hence, a flashing pointer can only point to a passage that lies on one of the shortest paths to Orthanc. Formally, the flashing pointer on the tower $u$ can point to a passage $\\vec{a} = \\overrightarrow{uv}$ only if $\\mathop{\\overrightarrow{\\mathrm{dist}}}(v, O) < +\\infty$ and $\\mathop{\\overrightarrow{\\mathrm{dist}}}(u, O) = t_{\\vec{a}} + \\mathop{\\overrightarrow{\\mathrm{dist}}}(v, O)$. Here by $\\mathop{\\overrightarrow{\\mathrm{dist}}}(x, y)$ we denote the minimum time it takes to get to tower $y$ from tower $x$ (or $+\\infty$ if there is no oriented path from $x$ to $y$), by $O$ we denote the tower of Orthanc, and by $u$ and $v$ we denote the starting and the finishing towers of the passage $\\vec a$. Note that Saruman will not put a flashing pointer onto Orthanc, nor will he put it on any tower from which Orthanc is unreachable. On each of the remaining towers, he will put exactly one flashing pointer.\n\nThis still does not work perfectly well. While traveling to Orthanc, each time an orc is near some tower (any but Orthanc), the orc can either choose a marked passage with Saruman's sign or do some $\\textit{hanging around}$, as Saruman calls it, when the orc chooses an outgoing passage completely at random. For any orc, there exists an integer $d$ such that when they're given an order to go to Orthanc, during the commute the orc never chooses to hang around more than $d$ times. This exact number we will politely call this orc's $\\textit{incompetence}$.\n\nNote that at some moment it may happen that an orc finds themselves near a tower from which there is no oriented path to Orthanc. Under these unfortunate circumstances, even the least competent orc will find no flashing pointer on the tower, figure out that their mission has failed, stop immediately, and wait for a rescue operation.\n\nSaruman knows that his servants are not very brilliant minds, so he does not expect the delivery of the present to be quick, but he wants it to be successful at the very least. Therefore, it makes sense to assign to this task as competent an orc as possible; on the other hand, competent orcs are rare and pulling them out of their current activities may entirely disrupt those activities. Hence, given the description of Isengard's transport system, find the maximum number $d$ such that there exists a way Saruman can put the flashing pointers, so that an orc with a level of incompetence equal to $d$ can be assigned to deliver the present from the entrance tower and is guaranteed to carry out the order with success, reaching Orthanc.", "inputFormat": "The first line contains two integers $n$ and $m$ --- the number of towers and the number of one-directional passages between them ($2 \\le n \\le 4 \\cdot 10^5$; $0 \\le m \\le 4 \\cdot 10^5$). In the next $m$ lines the descriptions of the passages follow. Each line contains three integers $u_i$, $v_i$, $t_i$ --- the numbers of the starting and the ending towers of a passage, and the number of seconds it takes for a loaded orc to travel along this passage ($1 \\le u_i, v_i \\le n$; $1 \\le t_i \\le 10^6$). There can be several passages between the same pair of towers, in any direction, as well as passages that lead from a tower to itself --- in other words, loops, multiple passages, and symmetric pairs of passages are allowed.\n\nThe entrance tower is numbered $1$ and Orthanc is numbered $n$.", "outputFormat": "Print one integer $d$ --- the maximum incompetence of an orc who is guaranteed to complete the delivery. \nIf with any level of incompetence it is possible, print the number $n$ (the number of towers). On the other hand, if with any level of incompetence it is impossible, print $-1$.", "hint": "All samples' illustrations are shown below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kj2vol2h.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/ulvre080.png)", "locale": "en", "translations": {"en": {"title": "[NERC2024] Incompetent Delivery Guy", "background": "", "description": "In Isengard, wizard Saruman, with the help of some magic spells, organized a transport system between $n$ towers. To be precise, he created $m$ one-directional passages, each connecting two towers. Each passage $i$ has some number $t_i$ associated with it, meaning the time it takes, in seconds, for an orc to travel along it. In other words, Saruman's transport system can be represented with a directed weighted graph.\n\nOn December 15th, Saruman, sitting in the middle tower called $\\textit{Orthanc}$, gets a message from Sauron (via palantir) which says that a valuable present is already near Isengard's entrance tower. So, Saruman needs to instruct the garrison to select one of the orcs and send them with a gift along the shortest path from the entrance tower to Orthanc.\n\nUnfortunately, orcs... aren't exactly smart fellas. Although they are able to drag a load along passages in the transport system and they (at least, in principle) know where Orthanc is, orcs have a really poor understanding of the concept of the shortest path. To make everyone's lives easier, on some towers Saruman puts a huge flashing pointer which says $\\textbf{TO ORTHANC~--- THIS WAY}$ and points to one of the passages leading from this tower. Saruman wants orcs to reach Orthanc as fast as possible --- hence, a flashing pointer can only point to a passage that lies on one of the shortest paths to Orthanc. Formally, the flashing pointer on the tower $u$ can point to a passage $\\vec{a} = \\overrightarrow{uv}$ only if $\\mathop{\\overrightarrow{\\mathrm{dist}}}(v, O) < +\\infty$ and $\\mathop{\\overrightarrow{\\mathrm{dist}}}(u, O) = t_{\\vec{a}} + \\mathop{\\overrightarrow{\\mathrm{dist}}}(v, O)$. Here by $\\mathop{\\overrightarrow{\\mathrm{dist}}}(x, y)$ we denote the minimum time it takes to get to tower $y$ from tower $x$ (or $+\\infty$ if there is no oriented path from $x$ to $y$), by $O$ we denote the tower of Orthanc, and by $u$ and $v$ we denote the starting and the finishing towers of the passage $\\vec a$. Note that Saruman will not put a flashing pointer onto Orthanc, nor will he put it on any tower from which Orthanc is unreachable. On each of the remaining towers, he will put exactly one flashing pointer.\n\nThis still does not work perfectly well. While traveling to Orthanc, each time an orc is near some tower (any but Orthanc), the orc can either choose a marked passage with Saruman's sign or do some $\\textit{hanging around}$, as Saruman calls it, when the orc chooses an outgoing passage completely at random. For any orc, there exists an integer $d$ such that when they're given an order to go to Orthanc, during the commute the orc never chooses to hang around more than $d$ times. This exact number we will politely call this orc's $\\textit{incompetence}$.\n\nNote that at some moment it may happen that an orc finds themselves near a tower from which there is no oriented path to Orthanc. Under these unfortunate circumstances, even the least competent orc will find no flashing pointer on the tower, figure out that their mission has failed, stop immediately, and wait for a rescue operation.\n\nSaruman knows that his servants are not very brilliant minds, so he does not expect the delivery of the present to be quick, but he wants it to be successful at the very least. Therefore, it makes sense to assign to this task as competent an orc as possible; on the other hand, competent orcs are rare and pulling them out of their current activities may entirely disrupt those activities. Hence, given the description of Isengard's transport system, find the maximum number $d$ such that there exists a way Saruman can put the flashing pointers, so that an orc with a level of incompetence equal to $d$ can be assigned to deliver the present from the entrance tower and is guaranteed to carry out the order with success, reaching Orthanc.", "inputFormat": "The first line contains two integers $n$ and $m$ --- the number of towers and the number of one-directional passages between them ($2 \\le n \\le 4 \\cdot 10^5$; $0 \\le m \\le 4 \\cdot 10^5$). In the next $m$ lines the descriptions of the passages follow. Each line contains three integers $u_i$, $v_i$, $t_i$ --- the numbers of the starting and the ending towers of a passage, and the number of seconds it takes for a loaded orc to travel along this passage ($1 \\le u_i, v_i \\le n$; $1 \\le t_i \\le 10^6$). There can be several passages between the same pair of towers, in any direction, as well as passages that lead from a tower to itself --- in other words, loops, multiple passages, and symmetric pairs of passages are allowed.\n\nThe entrance tower is numbered $1$ and Orthanc is numbered $n$.", "outputFormat": "Print one integer $d$ --- the maximum incompetence of an orc who is guaranteed to complete the delivery. \nIf with any level of incompetence it is possible, print the number $n$ (the number of towers). On the other hand, if with any level of incompetence it is impossible, print $-1$.", "hint": "All samples' illustrations are shown below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kj2vol2h.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/ulvre080.png)", "locale": "en"}, "zh-CN": {"title": "[NERC2024] Incompetent Delivery Guy", "background": "", "description": "在伊辛格，巫师萨鲁曼借助魔法设立了一套连接 $n$ 座高塔的传送系统。具体来说，他创建了 $m$ 条单向通道，每条通道连接两座高塔。第 $i$ 条通道需要 $t_i$ 秒，表示一只兽人通过这条通道所需的时间。换句话说，萨鲁曼的传送系统可以表示为一个带权有向图。\n\n在 12 月 15 日，萨鲁曼正坐在中央高塔 $\\textit{奥桑克}$（Orthanc）中，他通过魔法石（palantír）收到索伦的消息：一份贵重的礼物已经运抵伊辛格入口塔附近。于是，萨鲁曼需要指示守卫选出一只兽人，让他沿着从入口塔到奥桑克的最短路径将礼物送达。\n\n不幸的是，兽人……并不是很聪明。虽然他们能够拖运货物穿越通道，理论上也知道奥桑克的位置，但他们对于“最短路径”的理解实在是相当贫乏。为了简化操作，萨鲁曼决定在某些塔上放置一个巨大的闪光指示牌，写着“$\\textbf{前往奥桑克 —— 此路}$”，并指向通往某条通道的方向。\n\n萨鲁曼希望兽人尽可能快地到达奥桑克，因此指示牌**只能指向某条通往奥桑克最短路径上的通道**。形式化地说，如果塔 $u$ 上的指示牌指向通道 $\\vec{a} = \\overrightarrow{uv}$，那么必须满足：\n\n$$\n\\mathop{\\overrightarrow{\\mathrm{dist}}}(v, O) < +\\infty \\quad \\text{且} \\quad \\mathop{\\overrightarrow{\\mathrm{dist}}}(u, O) = t_{\\vec{a}} + \\mathop{\\overrightarrow{\\mathrm{dist}}}(v, O)\n$$\n\n其中，$\\mathop{\\overrightarrow{\\mathrm{dist}}}(x, y)$ 表示从塔 $x$ 到塔 $y$ 的最短传送时间（若无法到达，则为 $+\\infty$），$O$ 表示奥桑克所在的高塔编号，$u,v$ 分别为通道的起点和终点。\n\n注意：萨鲁曼不会在奥桑克本身，也不会在从无法到达奥桑克的塔上设置指示牌。其余所有塔上，萨鲁曼将恰好设置一个指向某条合规通道的闪光指示牌。\n\n即便如此，事情也并不总是顺利。每当一只兽人准备前往奥桑克时，他在经过每一座塔（除奥桑克外）时，要么选择跟随萨鲁曼设置的闪光指示牌前进，要么进行一次所谓的“$\\textit{随意乱走}$”行为，即随机选择一条通道离开当前塔。\n\n对于任意一只兽人，存在一个整数 $d$，表示他在整个传送过程中最多会进行 $d$ 次“随意乱走”。我们将这个值称为这只兽人的“$\\textit{无能度}$”。\n\n如果某一时刻兽人到达一座无法通往奥桑克的塔，那么他会发现该塔没有任何指示牌。此时，即便是最“有能”的兽人也会意识到任务失败，立即停止前进并等待救援。\n\n萨鲁曼深知他的仆人们都不太聪明，所以他并不指望送货能很快完成，但他希望至少能**保证送达**。因此，有必要选择一只无能度尽可能大的兽人完成任务。但另一方面，真正聪明的兽人极为稀少，把他们从其他岗位调走会严重影响其他安排。\n\n于是，给定伊辛格的传送系统，请你帮萨鲁曼找出一个最优策略安排指示牌，使得从入口塔（编号为 $1$）出发的兽人在**无能度为 $d$ 的前提下，必然可以成功到达奥桑克（编号为 $n$）**。请你求出这个最大可能的 $d$ 值。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$（$2 \\le n \\le 4 \\cdot 10^5$，$0 \\le m \\le 4 \\cdot 10^5$），分别表示塔的数量和通道的数量。\n\n接下来 $m$ 行，每行包含三个整数 $u_i$、$v_i$ 和 $t_i$（$1 \\le u_i, v_i \\le n$，$1 \\le t_i \\le 10^6$），表示从塔 $u_i$ 到塔 $v_i$ 有一条传送时间为 $t_i$ 秒的单向通道。\n\n可能存在多条通道连接相同的两个塔（同向或反向），也可能存在指向自身的通道（自环）。\n\n塔 $1$ 为入口塔，塔 $n$ 为奥桑克。", "outputFormat": "输出一个整数 $d$，表示满足题意的最大无能度。\n\n如果任意无能度下都可以成功送达，输出 $n$；如果任意无能度下都无法送达，输出 $-1$。\n", "hint": "样例图示如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kj2vol2h.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/ulvre080.png)", "locale": "zh-CN"}}}
{"pid": "P12101", "type": "P", "difficulty": 4, "samples": [["2\n1 2 3\n10\n15\n5 5\n5 15 20\n3 4 5\n8 100 8\n10 150 20\n2 32 1 1\n9 200 51 50 10", "1 1 2\n1 4 2 2 1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "ICPC", "NERC/NEERC"], "title": "[NERC2024] Judicious Watching", "background": "", "description": "Jill loves having good grades in university, so she never misses deadlines for her homework assignments. But even more, she loves watching the series and discussing it with her best friend Johnny. And unfortunately, today she needs to choose between these two activities!\n\nJill needs to complete $n$ homework tasks. The $i$-th task would require $a_i$ minutes to complete and needs to be submitted to the teacher at most $d_i$ minutes from now. Also, there are $m$ new episodes of the series that Johnny and Jill want to discuss. The $j$-th episode lasts $l_j$ minutes. Jill can complete tasks in any order, but she needs to watch the episodes in the order they come. Neither completing a homework task nor watching an episode can be interrupted after starting. \n\nJohnny and Jill need to agree on a time $t_k$ when they would have a call to discuss the series. They are not sure yet which time to choose. For each possible time, compute the maximum number of episodes Jill could watch before that time while still being able to complete all $n$ homework tasks in time.\n\nNote that for the purpose of this problem we assume that discussing the series with Johnny at time $t_k$ does not consume significant time from Jill and **can happen even if she is in the middle of completing any of her homework tasks**.", "inputFormat": "There are several test cases in the input. The input begins with the number of test cases $T$ ($1 \\le T \\le 1\\,000$). \n\nEach test case starts with a line with three integers $n$ ($1 \\le n \\le 200\\,000$) --- the number of homework tasks, $m$ ($1 \\le m \\le 200\\,000$) --- the number of episodes, and $q$ ($1 \\le q \\le 200\\,000$) --- the number of possible times for the call with Jill.\n\nThe second line contains $n$ integers $a_i$ ($1 \\le a_i \\le 10^9$) --- the number of minutes it takes to complete the task. \nThe next line contains $n$ integers $d_i$ ($1 \\le d_i \\le 10^{15}$) --- the deadline before which this task must be completed.\nThe next line contains $m$ integers $l_j$ ($1 \\le l_j \\le 10^9$) --- the length of episodes in the order they need to be watched.\nThe next line contains $q$ integers $t_k$ ($1 \\le t_k \\le 10^{15}$) --- the possible times of call with Jill. \n\nIt is possible to complete all tasks within their respective deadlines.\n\nThe sum of each of $n$, $m$, $q$ over all test cases in input doesn't exceed $200\\,000$.", "outputFormat": "For each test case output a single line with $q$ integers --- for each possible time $t_k$ the maximum number of episodes Jill can watch.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC2024] Judicious Watching", "background": "", "description": "Jill loves having good grades in university, so she never misses deadlines for her homework assignments. But even more, she loves watching the series and discussing it with her best friend Johnny. And unfortunately, today she needs to choose between these two activities!\n\nJill needs to complete $n$ homework tasks. The $i$-th task would require $a_i$ minutes to complete and needs to be submitted to the teacher at most $d_i$ minutes from now. Also, there are $m$ new episodes of the series that Johnny and Jill want to discuss. The $j$-th episode lasts $l_j$ minutes. Jill can complete tasks in any order, but she needs to watch the episodes in the order they come. Neither completing a homework task nor watching an episode can be interrupted after starting. \n\nJohnny and Jill need to agree on a time $t_k$ when they would have a call to discuss the series. They are not sure yet which time to choose. For each possible time, compute the maximum number of episodes Jill could watch before that time while still being able to complete all $n$ homework tasks in time.\n\nNote that for the purpose of this problem we assume that discussing the series with Johnny at time $t_k$ does not consume significant time from Jill and **can happen even if she is in the middle of completing any of her homework tasks**.", "inputFormat": "There are several test cases in the input. The input begins with the number of test cases $T$ ($1 \\le T \\le 1\\,000$). \n\nEach test case starts with a line with three integers $n$ ($1 \\le n \\le 200\\,000$) --- the number of homework tasks, $m$ ($1 \\le m \\le 200\\,000$) --- the number of episodes, and $q$ ($1 \\le q \\le 200\\,000$) --- the number of possible times for the call with Jill.\n\nThe second line contains $n$ integers $a_i$ ($1 \\le a_i \\le 10^9$) --- the number of minutes it takes to complete the task. \nThe next line contains $n$ integers $d_i$ ($1 \\le d_i \\le 10^{15}$) --- the deadline before which this task must be completed.\nThe next line contains $m$ integers $l_j$ ($1 \\le l_j \\le 10^9$) --- the length of episodes in the order they need to be watched.\nThe next line contains $q$ integers $t_k$ ($1 \\le t_k \\le 10^{15}$) --- the possible times of call with Jill. \n\nIt is possible to complete all tasks within their respective deadlines.\n\nThe sum of each of $n$, $m$, $q$ over all test cases in input doesn't exceed $200\\,000$.", "outputFormat": "For each test case output a single line with $q$ integers --- for each possible time $t_k$ the maximum number of episodes Jill can watch.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC2024] Judicious Watching", "background": "", "description": "Jill 喜欢在大学里获得好成绩，所以她从不拖延作业的截止日期。但她更喜欢观看剧集并与她的好朋友 Johnny 讨论。而不幸的是，今天她必须在这两项活动之间做出选择！\n\nJill 需要完成 $n$ 个作业任务。第 $i$ 个任务需要 $a_i$ 分钟来完成，并且必须在 $d_i$ 分钟内提交给老师。此外，还有 $m$ 集 Johnny 和 Jill 想要讨论的新剧集。第 $j$ 个剧集的时长是 $l_j$ 分钟。Jill 可以按任何顺序完成作业任务，但她需要按顺序观看剧集。开始后，无论是完成作业任务还是观看剧集，都不能中断。\n\nJohnny 和 Jill 需要就一个时间 $t_k$ 达成一致，以便讨论剧集。她们尚未确定选择哪个时间。对于每个可能的时间，计算 Jill 在该时间之前可以观看的最大剧集数，同时仍能按时完成所有的作业任务。\n\n注意：在这个问题中，我们假设与 Johnny 的剧集讨论不会占用 Jill 太多时间，并且**即使 Jill 正在完成作业任务，也可以在此时进行讨论**。", "inputFormat": "输入包含多个测试用例。输入的第一行是测试用例的数量 $T$（$1 \\le T \\le 1\\,000$）。\n\n每个测试用例包含以下内容：\n\n- 第一行包含三个整数 $n$（$1 \\le n \\le 200\\,000$）——作业任务的数量，$m$（$1 \\le m \\le 200\\,000$）——剧集的数量，$q$（$1 \\le q \\le 200\\,000$）——讨论的可能时间数量。\n- 第二行包含 $n$ 个整数 $a_i$（$1 \\le a_i \\le 10^9$）——完成第 $i$ 个作业任务所需的分钟数。\n- 第三行包含 $n$ 个整数 $d_i$（$1 \\le d_i \\le 10^{15}$）——每个任务的截止时间。\n- 第四行包含 $m$ 个整数 $l_j$（$1 \\le l_j \\le 10^9$）——按顺序观看的剧集的时长。\n- 第五行包含 $q$ 个整数 $t_k$（$1 \\le t_k \\le 10^{15}$）——可能的讨论时间。\n\n可以确保所有作业都可以在各自的截止时间内完成。\n\n所有测试用例中，$n$、$m$ 和 $q$ 的总和不超过 $200\\,000$。", "outputFormat": "对于每个测试用例，输出一行，包含 $q$ 个整数——对于每个可能的时间 $t_k$，Jill 在该时间之前可以观看的最大剧集数。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12102", "type": "P", "difficulty": 6, "samples": [["2\n4\n1 2 3 4\n3 2 4 1\n3\n1 -1 -1\n3 -1 1\n4\n1 2 3 4\n3 2 4 1\n3\n1 -1 2\n3 -1 1", "Y?Y?\nInconsistent"], ["2\n3\n1 2 3\n2 1 3\n2\n-1 2\n-1 -1\n3\n1 2 3\n3 2 1\n2\n1 3\n2 -1", "YYN\nInconsistent"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "ICPC", "NERC/NEERC"], "title": "[NERC2024] Knowns and Unknowns", "background": "", "description": "Two math professors have office hours on the same day. Students visit each professor to present their assignment solutions, one by one. For the whole semester, both professors established some fixed order of the students in which they should visit the professor. There are $n$ students denoted with integers from $1$ to $n$. Each professor's order of students is a permutation of numbers from $1$ to $n$.\n\nToday only some of the students visited the university; let $A$ be the set of numbers that denote the students that were at the university today. All of the students from the set $A$ have visited both professors, and all of the students outside of the set $A$ haven't visited any professor.\n\nEach of the professors made a list of the students they have talked with, in the same order the students have visited. Note that the list has to correspond to the order the professor has established, with the only difference that the students outside of the set $A$ are missing in it. It is the beginning of the year, so the professors didn't have a chance to get to know every student. So for the students that a professor knows, the list contains their identifier, but for those that the professor doesn't know, the list contains $-1$.\n\nConsider an example: the first professor's order is $[1, 2, 3, 4]$, and the second professor's --- $[3, 2, 4, 1]$. The list made by the first professor today is $[1, -1, -1]$, and the list made by the second professor is $[3, -1, 1]$. Based on the lists, we can immediately see that three students have visited the university today. We can infer that the set $A$ was either $\\{1, 2, 3\\}$ or $\\{1, 3, 4\\}$.\n\nYou are given two permutations --- the orders established by each professor; you are also given two lists that professors made today. Your task is to help the professors. Based on the provided data, determine for each student whether they definitely visited the university, definitely did not, or whether this cannot be determined. Note that professors could have confused the students, so there is a possibility that the given data is inconsistent.", "inputFormat": "The first line contains a single integer $T$ ($T \\ge 1$) --- the number of test cases to solve.\n\nThen the description of test cases follows.\n\nThe first line of the test case contains a single integer $n$ --- the number of students ($1 \\le n \\le 2000$).\n\nThe second line of the test case contains $n$ distinct integers $p_{1, 1}, p_{1, 2}, \\ldots, p_{1, n}$ --- the order established by the first professor, meaning that student $p_{1, 1}$ comes first, and $p_{1, n}$ comes last ($1 \\le p_{1, i} \\le n$).\n\nThe third line of the test case contains $n$ distinct integers $p_{2, 1}, p_{2, 2}, \\ldots, p_{2, n}$ --- the order established by the second professor in the same format ($1 \\le p_{2, i} \\le n$).\n\nThe fourth line of the test case contains an integer $k$ --- the number of students that visited the university today ($1 \\le k \\le n$).\n\nThe fifth line of the test case contains $k$ integers $s_{1, 1}, s_{1, 2}, \\ldots, s_{1, k}$ --- the first professor's list. Each student appears in the list at most once ($s_{1, i} = -1$ or $1 \\le s_{1, i} \\le n$).\n\nThe sixth line of the test case contains $k$ integers $s_{2, 1}, s_{2, 2}, \\ldots, s_{2, k}$ --- the second professor's list in the same format ($s_{2, i} = -1$ or $1 \\le s_{2, i} \\le n$).\n\nThe total sum of $n$ in all $T$ test cases doesn't exceed 2000.", "outputFormat": "For each test case, output a single string. If the given data is inconsistent, print a single word $\\tt{Inconsistent}$. Otherwise, print a string consisting of $n$ characters, the $i$-th of which is $\\tt{Y}$ if the $i$-th student visited the university today, $\\tt{N}$ if the $i$-th student didn't visit the university today, or $\\tt{?}$ if it cannot be determined.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC2024] Knowns and Unknowns", "background": "", "description": "Two math professors have office hours on the same day. Students visit each professor to present their assignment solutions, one by one. For the whole semester, both professors established some fixed order of the students in which they should visit the professor. There are $n$ students denoted with integers from $1$ to $n$. Each professor's order of students is a permutation of numbers from $1$ to $n$.\n\nToday only some of the students visited the university; let $A$ be the set of numbers that denote the students that were at the university today. All of the students from the set $A$ have visited both professors, and all of the students outside of the set $A$ haven't visited any professor.\n\nEach of the professors made a list of the students they have talked with, in the same order the students have visited. Note that the list has to correspond to the order the professor has established, with the only difference that the students outside of the set $A$ are missing in it. It is the beginning of the year, so the professors didn't have a chance to get to know every student. So for the students that a professor knows, the list contains their identifier, but for those that the professor doesn't know, the list contains $-1$.\n\nConsider an example: the first professor's order is $[1, 2, 3, 4]$, and the second professor's --- $[3, 2, 4, 1]$. The list made by the first professor today is $[1, -1, -1]$, and the list made by the second professor is $[3, -1, 1]$. Based on the lists, we can immediately see that three students have visited the university today. We can infer that the set $A$ was either $\\{1, 2, 3\\}$ or $\\{1, 3, 4\\}$.\n\nYou are given two permutations --- the orders established by each professor; you are also given two lists that professors made today. Your task is to help the professors. Based on the provided data, determine for each student whether they definitely visited the university, definitely did not, or whether this cannot be determined. Note that professors could have confused the students, so there is a possibility that the given data is inconsistent.", "inputFormat": "The first line contains a single integer $T$ ($T \\ge 1$) --- the number of test cases to solve.\n\nThen the description of test cases follows.\n\nThe first line of the test case contains a single integer $n$ --- the number of students ($1 \\le n \\le 2000$).\n\nThe second line of the test case contains $n$ distinct integers $p_{1, 1}, p_{1, 2}, \\ldots, p_{1, n}$ --- the order established by the first professor, meaning that student $p_{1, 1}$ comes first, and $p_{1, n}$ comes last ($1 \\le p_{1, i} \\le n$).\n\nThe third line of the test case contains $n$ distinct integers $p_{2, 1}, p_{2, 2}, \\ldots, p_{2, n}$ --- the order established by the second professor in the same format ($1 \\le p_{2, i} \\le n$).\n\nThe fourth line of the test case contains an integer $k$ --- the number of students that visited the university today ($1 \\le k \\le n$).\n\nThe fifth line of the test case contains $k$ integers $s_{1, 1}, s_{1, 2}, \\ldots, s_{1, k}$ --- the first professor's list. Each student appears in the list at most once ($s_{1, i} = -1$ or $1 \\le s_{1, i} \\le n$).\n\nThe sixth line of the test case contains $k$ integers $s_{2, 1}, s_{2, 2}, \\ldots, s_{2, k}$ --- the second professor's list in the same format ($s_{2, i} = -1$ or $1 \\le s_{2, i} \\le n$).\n\nThe total sum of $n$ in all $T$ test cases doesn't exceed 2000.", "outputFormat": "For each test case, output a single string. If the given data is inconsistent, print a single word $\\tt{Inconsistent}$. Otherwise, print a string consisting of $n$ characters, the $i$-th of which is $\\tt{Y}$ if the $i$-th student visited the university today, $\\tt{N}$ if the $i$-th student didn't visit the university today, or $\\tt{?}$ if it cannot be determined.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC2024] Knowns and Unknowns", "background": "", "description": "两位数学教授在同一天安排了答疑时间。学生们按顺序依次拜访每位教授。在整个学期中，这两位教授各自为学生设定了一个固定的拜访顺序。共有 $n$ 名学生，编号为 $1$ 到 $n$。每位教授的学生拜访顺序都是 $1$ 到 $n$ 的一个排列。\n\n今天，并不是所有学生都来到了学校。设 $A$ 表示今天到校学生的编号集合。集合 $A$ 中的每个学生都拜访了两位教授，集合外的学生则没有拜访任何教授。\n\n两位教授各自记录了今天与学生交流的名单，记录顺序与学生实际拜访顺序一致。注意，该名单必须是教授原定顺序中剔除未到学生后的结果。同时，由于学期刚开始，教授们尚未认全所有学生。对于认识的学生，名单上记录的是其编号；对于不认识的学生，则用 $-1$ 表示。\n\n来看一个例子：第一位教授原定顺序为 $[1, 2, 3, 4]$，第二位教授的顺序为 $[3, 2, 4, 1]$。他们今天记录的名单分别为 $[1, -1, -1]$ 和 $[3, -1, 1]$。由此我们可以看出，有三位学生今天来了学校。可以推断集合 $A$ 可能是 $\\{1, 2, 3\\}$ 或 $\\{1, 3, 4\\}$。\n\n你将获得两位教授原定的学生顺序，以及他们今天各自记录的名单。你的任务是帮助教授们分析：对于每个学生，判断他是否一定来过学校，一定没来过，或无法确定。需要注意的是，教授们可能记错了学生，因此给出的数据也可能是不一致的。", "inputFormat": "第一行包含一个整数 $T\\;(T \\ge 1)$，表示测试数据组数。\n\n接下来是 $T$ 组测试数据，每组格式如下：\n\n- 第一行一个整数 $n$（$1 \\le n \\le 2000$），表示学生人数。\n- 第二行 $n$ 个两两不同的整数 $p_{1,1}, p_{1,2}, \\ldots, p_{1,n}$，表示第一位教授原定的学生拜访顺序，其中 $p_{1,1}$ 最先，$p_{1,n}$ 最后。\n- 第三行 $n$ 个两两不同的整数 $p_{2,1}, p_{2,2}, \\ldots, p_{2,n}$，表示第二位教授的顺序，格式同上。\n- 第四行一个整数 $k$（$1 \\le k \\le n$），表示今天到校的学生数量。\n- 第五行 $k$ 个整数 $s_{1,1}, s_{1,2}, \\ldots, s_{1,k}$，表示第一位教授的记录。每个学生最多出现一次，值为 $-1$ 表示不认识该学生，否则为其编号。\n- 第六行 $k$ 个整数 $s_{2,1}, s_{2,2}, \\ldots, s_{2,k}$，表示第二位教授的记录，格式同上。\n\n所有测试数据中 $n$ 的总和不超过 $2000$。", "outputFormat": "对于每组测试数据，输出一行：\n\n- 如果数据不一致，输出一行单词 $\\texttt{Inconsistent}$；\n- 否则，输出一个长度为 $n$ 的字符串，第 $i$ 个字符表示第 $i$ 位学生的状态：\n  - 若确定来过，输出 $\\texttt{Y}$；\n  - 若确定没来，输出 $\\texttt{N}$；\n  - 若无法确定，输出 $\\texttt{?}$。", "hint": "", "locale": "zh-CN"}}}
