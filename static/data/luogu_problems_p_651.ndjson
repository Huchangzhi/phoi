{"pid": "P14198", "type": "P", "difficulty": 7, "samples": [["2\n5 4 2\n1 0 3 1 2\n0 1 1 2\n4 5 1\n7 16 23 4\n1 3 6 20 20", "3\n6"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "ICPC", "杭州"], "title": "[ICPC 2024 Hangzhou R] Let's Go! New Adventure", "background": "", "description": "In Pigeland, $\\textit{Pishin}$ is a popular open-world action RPG where users can play multiple characters. Each character has an independent $\\textit{adventure rank}$, which increases as they earn experience points (EXP) while being played.\nInitially, every character starts with an adventure rank of level $0$ and can progress up to a maximum level of $m$. To advance from level $(i-1)$ to level $i$ ($1 \\leq i \\leq m$), the character is required to earn $b_i$ EXP. The higher the current rank, the more difficult it becomes to level up, meaning $b_i \\leq b_{i+1}$ always holds for all $i$ from $1$ to $m$.\n\nGrammy plans to play $\\textit{Pishin}$ for the next $n$ days. As a rich girl, her $\\textit{Pishin}$ account has an infinite number of characters. However, being a lazy girl, all characters in her account start with an adventure rank of level $0$ at the beginning of the $n$ days. Each day, Grammy will select exactly one character to play, but once she stops playing a character, she cannot resume playing that character on any future day. In other words, she can only continue playing the same character on consecutive days. \n\nOn the $i$-th day, Grammy will earn $a_i$ EXP for the character she plays. This means that if she plays a character continuously from the $l$-th day to the $r$-th day (both inclusive), the character's adventure rank will increase to level $k$, where $k$ is the largest integer between $0$ and $m$ such that the total EXP earned (which is $\\sum\\limits_{i=l}^r a_i$) is greater than or equal to the requirement of leveling up to $k$ (which is $\\sum\\limits_{i=1}^{k} b_i$).\n\nBeing a greedy girl, Grammy wants to maximize the total sum of adventure ranks across all her characters after the $n$ days. However, as a single-minded girl, she doesn't want to play too many different characters. To balance this, she introduces a penalty factor of $c$. Her goal is to maximize the total sum of adventure ranks across all characters after the $n$ days, minus $c \\times d$, where $d$ is the number of different characters she plays. As Grammy's best friend, your task is to compute the maximum value she can achieve under the optimal strategy for selecting characters.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\leq T \\leq 5 \\times 10^4$) indicating the number of test cases. For each test case:\n\nThe first line contains three integers $n$, $m$ and $c$ ($1 \\leq n,m \\leq 5 \\times 10^5$, $0 \\leq c \\leq 5 \\times 10^5$).\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($0 \\leq a_i \\leq 10^{12}$, $0 \\le \\sum\\limits_{i = 1}^n a_i \\leq 10^{12}$).\n\nThe third line contains $m$ integers $b_1, b_2, \\cdots, b_m$ ($0 \\leq b_i \\leq 10^{12}$, $b_i \\leq b_{i+1}$, $0 \\leq \\sum\\limits_{i=1}^m b_i \\leq 10^{12}$).\n\nIt is guaranteed that neither the sum of $n$ nor the sum of $m$ of all test cases will exceed $5 \\times 10^5$.", "outputFormat": "For each test case, output one line containing one integer, indicating the maximum value.\n", "hint": "For the first sample test case, one solution is to use the first three days to get a character with adventure rank $4$ and the next two days to get another character with adventure rank $3$. This gives us a value of $(4-2)+(3-2)=3$.\n\nFor the second sample test case, we can play a different character each day; this gives us adventure ranks $2$, $3$, $3$, and $2$, respectively. So the value is $(2-1)+(3-1)+(3-1)+(2-1)=6$.", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 Hangzhou R] Let's Go! New Adventure", "background": "", "description": "In Pigeland, $\\textit{Pishin}$ is a popular open-world action RPG where users can play multiple characters. Each character has an independent $\\textit{adventure rank}$, which increases as they earn experience points (EXP) while being played.\nInitially, every character starts with an adventure rank of level $0$ and can progress up to a maximum level of $m$. To advance from level $(i-1)$ to level $i$ ($1 \\leq i \\leq m$), the character is required to earn $b_i$ EXP. The higher the current rank, the more difficult it becomes to level up, meaning $b_i \\leq b_{i+1}$ always holds for all $i$ from $1$ to $m$.\n\nGrammy plans to play $\\textit{Pishin}$ for the next $n$ days. As a rich girl, her $\\textit{Pishin}$ account has an infinite number of characters. However, being a lazy girl, all characters in her account start with an adventure rank of level $0$ at the beginning of the $n$ days. Each day, Grammy will select exactly one character to play, but once she stops playing a character, she cannot resume playing that character on any future day. In other words, she can only continue playing the same character on consecutive days. \n\nOn the $i$-th day, Grammy will earn $a_i$ EXP for the character she plays. This means that if she plays a character continuously from the $l$-th day to the $r$-th day (both inclusive), the character's adventure rank will increase to level $k$, where $k$ is the largest integer between $0$ and $m$ such that the total EXP earned (which is $\\sum\\limits_{i=l}^r a_i$) is greater than or equal to the requirement of leveling up to $k$ (which is $\\sum\\limits_{i=1}^{k} b_i$).\n\nBeing a greedy girl, Grammy wants to maximize the total sum of adventure ranks across all her characters after the $n$ days. However, as a single-minded girl, she doesn't want to play too many different characters. To balance this, she introduces a penalty factor of $c$. Her goal is to maximize the total sum of adventure ranks across all characters after the $n$ days, minus $c \\times d$, where $d$ is the number of different characters she plays. As Grammy's best friend, your task is to compute the maximum value she can achieve under the optimal strategy for selecting characters.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\leq T \\leq 5 \\times 10^4$) indicating the number of test cases. For each test case:\n\nThe first line contains three integers $n$, $m$ and $c$ ($1 \\leq n,m \\leq 5 \\times 10^5$, $0 \\leq c \\leq 5 \\times 10^5$).\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($0 \\leq a_i \\leq 10^{12}$, $0 \\le \\sum\\limits_{i = 1}^n a_i \\leq 10^{12}$).\n\nThe third line contains $m$ integers $b_1, b_2, \\cdots, b_m$ ($0 \\leq b_i \\leq 10^{12}$, $b_i \\leq b_{i+1}$, $0 \\leq \\sum\\limits_{i=1}^m b_i \\leq 10^{12}$).\n\nIt is guaranteed that neither the sum of $n$ nor the sum of $m$ of all test cases will exceed $5 \\times 10^5$.", "outputFormat": "For each test case, output one line containing one integer, indicating the maximum value.\n", "hint": "For the first sample test case, one solution is to use the first three days to get a character with adventure rank $4$ and the next two days to get another character with adventure rank $3$. This gives us a value of $(4-2)+(3-2)=3$.\n\nFor the second sample test case, we can play a different character each day; this gives us adventure ranks $2$, $3$, $3$, and $2$, respectively. So the value is $(2-1)+(3-1)+(3-1)+(2-1)=6$.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 Hangzhou R] Let's Go! New Adventure", "background": null, "description": "在 Pigeland，“Pishin” 是一款热门的开放世界动作角色扮演游戏，玩家可以操控多个角色。每个角色都有独立的冒险等级（adventure rank），等级会随着该角色获得的经验值（EXP）升高。\n一开始，每个角色的冒险等级都是 $0$，最高可以升到 $m$ 级。要从 $(i-1)$ 级升到 $i$ 级（$1 \\leq i \\leq m$），需要获得 $b_i$ 点经验。随着等级提高，升级所需经验会越来越多，即 $b_i \\leq b_{i+1}$ 对于所有 $i$ 总是成立（$1 \\leq i < m$）。\n\nGrammy 计划在接下来的 $n$ 天里玩 “Pishin”。她很有钱，因此她的账号里有无限多个角色。不过因为她很懒，账号中的所有角色在这 $n$ 天的开头都是冒险等级 $0$。每天，Grammy 恰好选择一个角色来游玩，一旦她停止操控某个角色，在之后的日子里便无法再使用该角色。换句话说，每个角色只能被连续地游玩若干天。\n\n在第 $i$ 天，Grammy 为所操控的角色获得 $a_i$ 点经验。如果她在第 $l$ 天到第 $r$ 天（包含两端）连续操控同一个角色，则该角色一共获得了 $\\sum\\limits_{i=l}^r a_i$ 点经验，并可升级到等级 $k$，其中 $k$ 满足 $0 \\leq k \\leq m$，且 $\\sum\\limits_{i=1}^k b_i \\leq \\sum\\limits_{i=l}^r a_i$，且 $k$ 尽可能大。\n\nGrammy 很贪心，希望她账号中所有角色获得的冒险等级之和最大。然而她也不想用太多不同的角色。为了平衡，她引入了一个惩罚因子 $c$。她的目标是使所有角色的冒险等级之和减去 $c \\times d$ 最大，其中 $d$ 表示她使用过的不同角色数量。作为 Grammy 最好的朋友，你需要帮她计算在最优策略下她能获得的最大价值。", "inputFormat": "有多组测试数据。第一行为一个整数 $T$（$1 \\leq T \\leq 5 \\times 10^4$），表示测试数据组数。对于每组测试数据：\n\n第一行包含三个整数 $n,m,c$（$1 \\leq n,m \\leq 5 \\times 10^5$，$0 \\leq c \\leq 5 \\times 10^5$）。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\cdots, a_n$（$0 \\leq a_i \\leq 10^{12}$，$0 \\le \\sum\\limits_{i = 1}^n a_i \\leq 10^{12}$）。\n\n第三行包含 $m$ 个整数 $b_1, b_2, \\cdots, b_m$（$0 \\leq b_i \\leq 10^{12}$，$b_i \\leq b_{i+1}$，$0 \\leq \\sum\\limits_{i=1}^m b_i \\leq 10^{12}$）。\n\n保证所有测试数据中 $n$ 的总和以及 $m$ 的总和不超过 $5 \\times 10^5$。", "outputFormat": "对于每组测试数据，输出一行一个整数，表示最大值。", "hint": "对于第一组样例，一个方案是前 $3$ 天操控同一个角色可获得冒险等级 $4$，接下来的 $2$ 天再用另一个角色获得等级 $3$，最终价值为 $(4-2)+(3-2)=3$。\n\n对于第二组样例，可以每天使用不同的角色，获得冒险等级分别为 $2,3,3,2$，因此价值为 $(2-1)+(3-1)+(3-1)+(2-1)=6$。\n\n由 ChatGPT 5 翻译", "locale": "zh-CN"}}}
{"pid": "P14199", "type": "P", "difficulty": 5, "samples": [["3\n5 10\n7 79 1 7 1\n2 1000000000\n1 2\n1 100\n1000000000", "3 8\n0 0\n100 5050"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "ICPC", "杭州"], "title": "[ICPC 2024 Hangzhou R] Make It Divisible", "background": "", "description": "Given a sequence $a_1, a_2, \\cdots, a_n$ of length $n$ containing positive integers, we say an interval $[l, r]$ ($1 \\le l \\le r \\le n$) is a $\\textit{divisible interval}$ if there exists an integer $d$ such that $l \\le d \\le r$ and for all $l \\le i \\le r$, $a_i$ is divisible by $a_d$. We say the whole sequence is a $\\textit{divisible sequence}$ if for all $1 \\le l \\le r \\le n$, $[l, r]$ is a divisible interval.\n\nGiven another sequence $b_1, b_2, \\cdots, b_n$ of length $n$ and an integer $k$, find all integers $x$ such that $1 \\le x \\le k$ and the sequence $b_1 + x, b_2 + x, \\cdots, b_n + x$ is a divisible sequence. As the number of such integers might be large, you just need to output the number and the sum of all such integers.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\le T \\le 500$) indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $k$ ($1 \\le n \\le 5 \\times 10^4$, $1 \\le k \\le 10^9$).\n\nThe second line contains $n$ integers $b_1, b_2, \\cdots, b_n$ ($1 \\le b_i \\le 10^9$).\n\nIt's guaranteed that the sum of $n$ of all test cases does not exceed $5 \\times 10^4$.", "outputFormat": "For each test case output one line containing two integers separated by a space, where the first integer is the number of valid $x$, and the second integer is the sum of all valid $x$.", "hint": "For the first sample test case, $x = 1$, $x = 2$ and $x = 5$ are valid.\n\nFor the third sample test case, all $1 \\le x \\le 100$ are valid.\n", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 Hangzhou R] Make It Divisible", "background": "", "description": "Given a sequence $a_1, a_2, \\cdots, a_n$ of length $n$ containing positive integers, we say an interval $[l, r]$ ($1 \\le l \\le r \\le n$) is a $\\textit{divisible interval}$ if there exists an integer $d$ such that $l \\le d \\le r$ and for all $l \\le i \\le r$, $a_i$ is divisible by $a_d$. We say the whole sequence is a $\\textit{divisible sequence}$ if for all $1 \\le l \\le r \\le n$, $[l, r]$ is a divisible interval.\n\nGiven another sequence $b_1, b_2, \\cdots, b_n$ of length $n$ and an integer $k$, find all integers $x$ such that $1 \\le x \\le k$ and the sequence $b_1 + x, b_2 + x, \\cdots, b_n + x$ is a divisible sequence. As the number of such integers might be large, you just need to output the number and the sum of all such integers.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\le T \\le 500$) indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $k$ ($1 \\le n \\le 5 \\times 10^4$, $1 \\le k \\le 10^9$).\n\nThe second line contains $n$ integers $b_1, b_2, \\cdots, b_n$ ($1 \\le b_i \\le 10^9$).\n\nIt's guaranteed that the sum of $n$ of all test cases does not exceed $5 \\times 10^4$.", "outputFormat": "For each test case output one line containing two integers separated by a space, where the first integer is the number of valid $x$, and the second integer is the sum of all valid $x$.", "hint": "For the first sample test case, $x = 1$, $x = 2$ and $x = 5$ are valid.\n\nFor the third sample test case, all $1 \\le x \\le 100$ are valid.\n", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 Hangzhou R] Make It Divisible", "background": null, "description": "给定一个长度为 $n$ 的正整数序列 $a_1, a_2, \\cdots, a_n$，我们称区间 $[l, r]$（$1 \\le l \\le r \\le n$）为一个$\\textit{可整除区间}$，如果存在一个整数 $d$ 满足 $l \\le d \\le r$，并且对所有 $l \\le i \\le r$，$a_i$ 都能被 $a_d$ 整除。我们称整个序列为$\\textit{可整除序列}$，如果对于所有 $1 \\le l \\le r \\le n$，区间 $[l, r]$ 都是可整除区间。\n\n现给定另一个长度为 $n$ 的序列 $b_1, b_2, \\cdots, b_n$ 和一个整数 $k$，请找出所有 $1 \\le x \\le k$ 的整数 $x$，使得序列 $b_1 + x, b_2 + x, \\cdots, b_n + x$ 是可整除序列。由于这样的整数可能很多，你只需要输出这样的 $x$ 的个数以及所有这样的 $x$ 的和。", "inputFormat": "有多组测试数据。输入的第一行包含一个整数 $T$（$1 \\le T \\le 500$），表示测试数据组数。对于每组测试数据：\n\n第一行包含两个整数 $n$ 和 $k$（$1 \\le n \\le 5 \\times 10^4$，$1 \\le k \\le 10^9$）。\n\n第二行包含 $n$ 个整数 $b_1, b_2, \\cdots, b_n$（$1 \\le b_i \\le 10^9$）。\n\n保证所有测试数据中 $n$ 的总和不超过 $5 \\times 10^4$。", "outputFormat": "对于每组测试数据，输出一行两个整数，用空格分隔，第一个数表示满足条件的 $x$ 的个数，第二个数表示所有满足条件的 $x$ 的和。", "hint": "对于第一个样例测试数据，$x = 1$、$x = 2$ 和 $x = 5$ 是合法的。\n\n对于第三个样例测试数据，所有的 $1 \\le x \\le 100$ 都是合法的。\n\n由 ChatGPT 5 翻译", "locale": "zh-CN"}}}
{"pid": "P14200", "type": "P", "difficulty": 5, "samples": [["5 4\n5 4 3 2 1", "3"], ["3 10\n3 15 31", "2"], ["10 16\n18 7 9 6 6 2 4 8 5 10", "8"]], "limits": {"time": [700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": [], "title": "朝向过去的远方", "background": "天空很蓝。\n\n我抬头看向它。\n\n云朵飘过。", "description": "在通往世界的尽头，有一条路。路上有 $n$ 个点，其中从前往后第 $i$ 个点的记忆度为 $A_i$。\n\n抱月朝前走着。因为不想忘记太多，到点 $i$ 时，她会询问对于从 $i$ 到 $n$ 的每个点 $x$，最小的 $j$ 的值，满足 $A_j,A_{j+1},\\dots,A_x$ 按位与的结果和 $A_{i},A_{i+1},\\dots,A_{x}$ 按位与的结果相同。\n\n也许是记忆力不太好，对于每个 $i$，记 $s(i)$ 为 $x=i,i+1,\\dots,n$ 时对应的 $j$ 与 $i$ 的距离（$|i-j+1|$）的按位异或和。请你在她走到尽头时，告诉她 $\\sum\\limits_{i=1}^{n}s(i) \\bmod m$ 的值。\n\n**【形式化题面】**:\n\n给定一个长度为 $n$ 的序列 $A$。\n\n记 $g(l,r)=(A_l\\&A_{l+1}\\&\\dots\\& A_r)$，$f(r,x)=\\min\\limits_{1 \\le l \\le r \\land g(l,r)=x }^{}l$。\n\n输出 $\\sum\\limits_{i=1}^{n} (\\bigoplus\\limits_{r=i}^{n}(i-f(r,g(i,r))+1)) \\bmod m$ 的值。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数 $A_i$。", "outputFormat": "一行 $1$ 个整数表示答案。", "hint": "今天它飘得很快，目标指向远方。\n\n追逐着云朵的目光望向前方，樱花花瓣飞进我的视线。\n\n对所有数据，满足 $1 \\le n \\le 10^6,1 \\le A_i,m < 2^{30}$。\n\n::cute-table{tuack}\n\n|子任务编号|$n\\le$|特殊性质|分值|\n|:-:|:-:|:-:|:-:|\n|#1|$10^6$|A|$\\text{10pts}$|\n|#2|$10^3$|无|$\\text{10pts}$|\n|#3|$10^5$|B|$\\text{30pts}$|\n|#4|$10^6$|无|$\\text{50pts}$|\n\n特殊性质 A：$A_i$ 相同。\n\n特殊性质 B：$1 \\le A_i,m < 2^{20}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "朝向过去的远方", "background": "天空很蓝。\n\n我抬头看向它。\n\n云朵飘过。", "description": "在通往世界的尽头，有一条路。路上有 $n$ 个点，其中从前往后第 $i$ 个点的记忆度为 $A_i$。\n\n抱月朝前走着。因为不想忘记太多，到点 $i$ 时，她会询问对于从 $i$ 到 $n$ 的每个点 $x$，最小的 $j$ 的值，满足 $A_j,A_{j+1},\\dots,A_x$ 按位与的结果和 $A_{i},A_{i+1},\\dots,A_{x}$ 按位与的结果相同。\n\n也许是记忆力不太好，对于每个 $i$，记 $s(i)$ 为 $x=i,i+1,\\dots,n$ 时对应的 $j$ 与 $i$ 的距离（$|i-j+1|$）的按位异或和。请你在她走到尽头时，告诉她 $\\sum\\limits_{i=1}^{n}s(i) \\bmod m$ 的值。\n\n**【形式化题面】**:\n\n给定一个长度为 $n$ 的序列 $A$。\n\n记 $g(l,r)=(A_l\\&A_{l+1}\\&\\dots\\& A_r)$，$f(r,x)=\\min\\limits_{1 \\le l \\le r \\land g(l,r)=x }^{}l$。\n\n输出 $\\sum\\limits_{i=1}^{n} (\\bigoplus\\limits_{r=i}^{n}(i-f(r,g(i,r))+1)) \\bmod m$ 的值。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数 $A_i$。", "outputFormat": "一行 $1$ 个整数表示答案。", "hint": "今天它飘得很快，目标指向远方。\n\n追逐着云朵的目光望向前方，樱花花瓣飞进我的视线。\n\n对所有数据，满足 $1 \\le n \\le 10^6,1 \\le A_i,m < 2^{30}$。\n\n::cute-table{tuack}\n\n|子任务编号|$n\\le$|特殊性质|分值|\n|:-:|:-:|:-:|:-:|\n|#1|$10^6$|A|$\\text{10pts}$|\n|#2|$10^3$|无|$\\text{10pts}$|\n|#3|$10^5$|B|$\\text{30pts}$|\n|#4|$10^6$|无|$\\text{50pts}$|\n\n特殊性质 A：$A_i$ 相同。\n\n特殊性质 B：$1 \\le A_i,m < 2^{20}$。", "locale": "zh-CN"}}}
{"pid": "P14201", "type": "P", "difficulty": 4, "samples": [["7 3\n0 1 4 1 5 1 4\n1 3\n1 6\n5 7", "-1\n2\n3\n3\n6\n7\n8\n9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": [], "title": "樱", "background": "只属于我们两人的樱花不畏寒冬，大肆绽放。\n\n", "description": "樱有一个长度为 $n$ 的序列 $A$。她现在有 $m$ 个问题，第 $i$ 个问题是：$\\operatorname{mex}(A_{l_i},A_{l_{i+1}},\\dots,A_{r_i})$ 的值为多少。\n\n抱月想要给樱改改题。具体地，她将构造一个长度为 $k$ 的序列 $B$。那么樱的第 $i$ 个问题将变成：求 $\\operatorname{mex}(A_{l_i},A_{l_{i+1}},\\dots,A_{r_i},B_1,B_2,\\dots,B_k)$。\n\n如果对于所有 $m$ 个问题，在樱通过一切方式求出来后都是相同的，那么樱会有成就感。\n\n抱月想知道，当 $k=0,1,\\dots,n$ 时，是否能构造出来一个长度为 $k$ 的序列 $B$，使得樱开心。如果可以，那么这 $m$ 个问题的答案的最大值是多少。如果不可以，请输出 $-1$。\n\n**【形式化题面】**：\n\n给定一个长度为 $n$ 的序列 $A$ 与 $m$ 组 $l_i,r_i$。\n\n要构造一个长度为 $k$ 的序列 $B$，记 $f_i=\\operatorname{mex}(A_{l_i},A_{l_i+1},\\dots,A_{r_i},B_1,B_2,\\dots,B_k)$。那么有：$f_i(1 \\le i \\le m)$ 相等。\n\n对于 $k=0,1,\\dots ,n$，求在所有满足条件的 $B$ 中，$f_i$ 值最大是多少。若不存在任何一个 $B$，则最大值为 $-1$。\n\n\n**注**：\n\n$\\operatorname{mex}(A_{1},A_{2},A_{3},\\dots,A_m)$ 为可重集 $\\{A_1,A_2,A_3,\\dots,A_m\\}$ 中最小的不存在的**自然数**。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数 $A_i$。\n\n接下来 $m$ 行，每行两个整数 $l_i,r_i$。", "outputFormat": "对于每个 $k$，输出一个整数表示答案。", "hint": "对所有数据，满足 $1 \\le n,m \\le 10^6,0 \\le A_i <n, 1 \\le l_i \\le r_i \\le n$。\n\n::cute-table{tuack}\n\n|子任务编号|$n,m\\le$|特殊性质|分值|\n|:-:|:-:|:-:|:-:|\n|#1|$2000$|无|$\\text{15pts}$|\n|#2|$10^6$|A|$\\text{10pts}$|\n|#3|^|B|$\\text{15pts}$|\n|#4|^|无|$\\text{60pts}$|\n\n特殊性质 A：$A_i=n-1$。\n\n特殊性质 B：$\\sum(r_i-l_i+1)\\le 100$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "樱", "background": "只属于我们两人的樱花不畏寒冬，大肆绽放。\n\n", "description": "樱有一个长度为 $n$ 的序列 $A$。她现在有 $m$ 个问题，第 $i$ 个问题是：$\\operatorname{mex}(A_{l_i},A_{l_{i+1}},\\dots,A_{r_i})$ 的值为多少。\n\n抱月想要给樱改改题。具体地，她将构造一个长度为 $k$ 的序列 $B$。那么樱的第 $i$ 个问题将变成：求 $\\operatorname{mex}(A_{l_i},A_{l_{i+1}},\\dots,A_{r_i},B_1,B_2,\\dots,B_k)$。\n\n如果对于所有 $m$ 个问题，在樱通过一切方式求出来后都是相同的，那么樱会有成就感。\n\n抱月想知道，当 $k=0,1,\\dots,n$ 时，是否能构造出来一个长度为 $k$ 的序列 $B$，使得樱开心。如果可以，那么这 $m$ 个问题的答案的最大值是多少。如果不可以，请输出 $-1$。\n\n**【形式化题面】**：\n\n给定一个长度为 $n$ 的序列 $A$ 与 $m$ 组 $l_i,r_i$。\n\n要构造一个长度为 $k$ 的序列 $B$，记 $f_i=\\operatorname{mex}(A_{l_i},A_{l_i+1},\\dots,A_{r_i},B_1,B_2,\\dots,B_k)$。那么有：$f_i(1 \\le i \\le m)$ 相等。\n\n对于 $k=0,1,\\dots ,n$，求在所有满足条件的 $B$ 中，$f_i$ 值最大是多少。若不存在任何一个 $B$，则最大值为 $-1$。\n\n\n**注**：\n\n$\\operatorname{mex}(A_{1},A_{2},A_{3},\\dots,A_m)$ 为可重集 $\\{A_1,A_2,A_3,\\dots,A_m\\}$ 中最小的不存在的**自然数**。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数 $A_i$。\n\n接下来 $m$ 行，每行两个整数 $l_i,r_i$。", "outputFormat": "对于每个 $k$，输出一个整数表示答案。", "hint": "对所有数据，满足 $1 \\le n,m \\le 10^6,0 \\le A_i <n, 1 \\le l_i \\le r_i \\le n$。\n\n::cute-table{tuack}\n\n|子任务编号|$n,m\\le$|特殊性质|分值|\n|:-:|:-:|:-:|:-:|\n|#1|$2000$|无|$\\text{15pts}$|\n|#2|$10^6$|A|$\\text{10pts}$|\n|#3|^|B|$\\text{15pts}$|\n|#4|^|无|$\\text{60pts}$|\n\n特殊性质 A：$A_i=n-1$。\n\n特殊性质 B：$\\sum(r_i-l_i+1)\\le 100$。", "locale": "zh-CN"}}}
{"pid": "P14202", "type": "P", "difficulty": 6, "samples": [["5 3\n2 1\n3 2\n4 2\n5 2\n13 8\n9 10\n9 3\n20 6\n14 7\n3 2 5\n3 3 4\n3 3 8", "74\n104 \n166"], ["4 4\n2 1\n3 2\n4 3\n10 7\n5 3\n7 2\n8 5\n1 1 4\n1 4 6\n1 2 4\n3 4 10", "63"], ["6 6\n2 1\n3 2\n4 1\n5 1\n6 1\n9 6\n8 6\n2 5\n5 1\n10 1\n5 8\n1 3 3\n3 5 2\n2 2 5\n2 2 10\n1 6 7\n3 2 3", "30\n30"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["点分治", "树状数组"], "title": "雪月风花", "background": "风雪飘摇落下，这白色的天地。\n\n为了心底不可抹去的温暖啊，便让这纹路化作最后的羽翼。\n\n直到我们再度相见，哪怕重新回到昨天。", "description": "伊正在帮助薰完成她的阵法。薰的阵法可以视作一棵 $n$ 个节点的有根树，每个节点都有一个魔力阈值 $a$ 与魔力等级 $b$。初始时将会给出阵法的形态与薰为每个节点设定的 $a,b$ 值。\n\n接下来，伊将会对这个阵法进行几次测试并调整一些节点的 $a,b$ 值，以使得这个阵法可以拥有足够的效率。\n\n每一次测试时，伊都会指定一个源点 $x$ 与范围 $k$。定义本次测试消耗的能量为 $\\sum\\limits_{y=1}^n\\mathrm{dis}(x,y)(a_x+a_y)[|b_x-b_y|\\le k]$，定义 $\\mathrm{dis}(x,y)$ 为 $x,y$ 两点树上最短路径的边数。\n\n但是这个值太大了，所以伊只需要你输出结果对 $998244353$ 取模的值即可。", "inputFormat": "第一行输入两个数 $n,m$。\n\n接下来 $n-1$ 行，每行输入两个数 $u,v$，表示树上存在一条连接 $u,v$ 的边。\n\n接下来 $n$ 行，第 $i$ 行输入两个数表示 $a_i,b_i$。\n\n接下来 $m$ 行，每行输入以下格式之一：\n* `1 x v`，修改 $a_x$ 为 $v$。\n* `2 x v`，修改 $b_x$ 为 $v$。\n* `3 x k`，进行一次以 $x$ 为源点、范围为 $k$ 的测试，查询本次测试消耗的能量可能的最小值。", "outputFormat": "对每次查询操作，输出一行一个数表示答案。", "hint": "对所有数据，满足 $1\\le n,m\\le 10^5,1\\le x\\le n,1\\le a,b,k\\le 10^5$。\n\n::cute-table{tuack}\n\n|子任务编号|$n,m\\le$|特殊性质|分值|\n|:-:|:-:|:-:|:-:|\n|#1|$2000$|无|$\\text{5pts}$|\n|#2|$5\\times 10^4$|^|$\\text{20pts}$|\n|#3|$10^5$|AB|$\\text{5pts}$|\n|#4|^|B|$\\text{10pts}$|\n|#5|^|C|$\\text{10pts}$|\n|#6|^|无|$\\text{50pts}$|\n\n特殊性质 A：不存在 $1$ 操作。\n\n特殊性质 B：不存在 $2$ 操作。\n\n特殊性质 C：保证任意时刻 $b_i \\le 3$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "雪月风花", "background": "风雪飘摇落下，这白色的天地。\n\n为了心底不可抹去的温暖啊，便让这纹路化作最后的羽翼。\n\n直到我们再度相见，哪怕重新回到昨天。", "description": "伊正在帮助薰完成她的阵法。薰的阵法可以视作一棵 $n$ 个节点的有根树，每个节点都有一个魔力阈值 $a$ 与魔力等级 $b$。初始时将会给出阵法的形态与薰为每个节点设定的 $a,b$ 值。\n\n接下来，伊将会对这个阵法进行几次测试并调整一些节点的 $a,b$ 值，以使得这个阵法可以拥有足够的效率。\n\n每一次测试时，伊都会指定一个源点 $x$ 与范围 $k$。定义本次测试消耗的能量为 $\\sum\\limits_{y=1}^n\\mathrm{dis}(x,y)(a_x+a_y)[|b_x-b_y|\\le k]$，定义 $\\mathrm{dis}(x,y)$ 为 $x,y$ 两点树上最短路径的边数。\n\n但是这个值太大了，所以伊只需要你输出结果对 $998244353$ 取模的值即可。", "inputFormat": "第一行输入两个数 $n,m$。\n\n接下来 $n-1$ 行，每行输入两个数 $u,v$，表示树上存在一条连接 $u,v$ 的边。\n\n接下来 $n$ 行，第 $i$ 行输入两个数表示 $a_i,b_i$。\n\n接下来 $m$ 行，每行输入以下格式之一：\n* `1 x v`，修改 $a_x$ 为 $v$。\n* `2 x v`，修改 $b_x$ 为 $v$。\n* `3 x k`，进行一次以 $x$ 为源点、范围为 $k$ 的测试，查询本次测试消耗的能量可能的最小值。", "outputFormat": "对每次查询操作，输出一行一个数表示答案。", "hint": "对所有数据，满足 $1\\le n,m\\le 10^5,1\\le x\\le n,1\\le a,b,k\\le 10^5$。\n\n::cute-table{tuack}\n\n|子任务编号|$n,m\\le$|特殊性质|分值|\n|:-:|:-:|:-:|:-:|\n|#1|$2000$|无|$\\text{5pts}$|\n|#2|$5\\times 10^4$|^|$\\text{20pts}$|\n|#3|$10^5$|AB|$\\text{5pts}$|\n|#4|^|B|$\\text{10pts}$|\n|#5|^|C|$\\text{10pts}$|\n|#6|^|无|$\\text{50pts}$|\n\n特殊性质 A：不存在 $1$ 操作。\n\n特殊性质 B：不存在 $2$ 操作。\n\n特殊性质 C：保证任意时刻 $b_i \\le 3$。", "locale": "zh-CN"}}}
{"pid": "P14203", "type": "P", "difficulty": 6, "samples": [["4\n0 0 1 2", "4"], ["7\n3 1 0 1 2 2 0", "3"], ["10\n1 1 0 0 2 2 3 3 0 0", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 450, 1000, 450, 1000, 450, 1000, 450, 1000, 450, 1000, 450, 1000, 450, 1000, 450, 1000, 450, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": [], "title": "这次要永远 做朋友", "background": "实际上，我们的友情早已生锈、崩坏。\n\n或许今天只是残骸上的碎片，恰巧散发出了微弱光芒而已。\n\n即使如此......\n", "description": "定义 $f(l,r)$ 为 $\\{a_l,a_{l+1},\\dots,a_r\\}$ 的绝对众数的值。若不存在，则 $f(l,r)=10^{100}$。也就是出现次数 $c > \\lfloor\\frac{r-l+1}{2}\\rfloor$ 的值。\n\n定义 $\\operatorname{mex}(l,r)$ 为 $\\{a_l,a_{l+1},\\dots,a_r\\}$ 的 $\\operatorname{mex}$ 值。也就是最小的不存在的自然数。\n\n给定长度为 $n$ 的序列 $a_{1\\dots n}$，求 $\\sum\\limits_{l=1}^{n}\\sum\\limits_{r=l}^{n}[\\operatorname{mex}(l,r)\\ge f(l,r)]$。", "inputFormat": "第一行一个整数 $n$。\n\n第二行 $n$ 个整数 $a_i$。", "outputFormat": "一行一个整数，表示答案。", "hint": "我仍然真的认为——那笑容非常灿烂，甚至令我指尖发麻。\n\n对所有数据，满足 $1 \\le n \\le 3\\times 10^6,0 \\le a_i \\le n$。\n\n::cute-table{tuack}\n\n|子任务编号|$n\\le$|特殊性质|分值|时间限制|\n|:-:|:-:|:-:|:-:|:-:|\n|#1|$100$|无|$\\text{5pts}$|$\\text{1s}$|\n|#2|$5000$|^|$\\text{5pts}$|^|\n|#3|$3 \\times 10^4$|^|$\\text{15pts}$|^|\n|#4|$10^5$|^|$\\text{15pts}$|^|\n|#5|^|B|$\\text{10pts}$|^|\n|#6|$3\\times 10^6$|A|$\\text{2pts}$|^|\n|#7|^|无|$\\text{24pts}$|^|\n|#8|^|无|$\\text{24pts}$|$\\text{450ms}$|\n\n特殊性质 A：$a_i=0$。\n\n特殊性质 B：$0 \\le a_i \\le 10$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "这次要永远 做朋友", "background": "实际上，我们的友情早已生锈、崩坏。\n\n或许今天只是残骸上的碎片，恰巧散发出了微弱光芒而已。\n\n即使如此......\n", "description": "定义 $f(l,r)$ 为 $\\{a_l,a_{l+1},\\dots,a_r\\}$ 的绝对众数的值。若不存在，则 $f(l,r)=10^{100}$。也就是出现次数 $c > \\lfloor\\frac{r-l+1}{2}\\rfloor$ 的值。\n\n定义 $\\operatorname{mex}(l,r)$ 为 $\\{a_l,a_{l+1},\\dots,a_r\\}$ 的 $\\operatorname{mex}$ 值。也就是最小的不存在的自然数。\n\n给定长度为 $n$ 的序列 $a_{1\\dots n}$，求 $\\sum\\limits_{l=1}^{n}\\sum\\limits_{r=l}^{n}[\\operatorname{mex}(l,r)\\ge f(l,r)]$。", "inputFormat": "第一行一个整数 $n$。\n\n第二行 $n$ 个整数 $a_i$。", "outputFormat": "一行一个整数，表示答案。", "hint": "我仍然真的认为——那笑容非常灿烂，甚至令我指尖发麻。\n\n对所有数据，满足 $1 \\le n \\le 3\\times 10^6,0 \\le a_i \\le n$。\n\n::cute-table{tuack}\n\n|子任务编号|$n\\le$|特殊性质|分值|时间限制|\n|:-:|:-:|:-:|:-:|:-:|\n|#1|$100$|无|$\\text{5pts}$|$\\text{1s}$|\n|#2|$5000$|^|$\\text{5pts}$|^|\n|#3|$3 \\times 10^4$|^|$\\text{15pts}$|^|\n|#4|$10^5$|^|$\\text{15pts}$|^|\n|#5|^|B|$\\text{10pts}$|^|\n|#6|$3\\times 10^6$|A|$\\text{2pts}$|^|\n|#7|^|无|$\\text{24pts}$|^|\n|#8|^|无|$\\text{24pts}$|$\\text{450ms}$|\n\n特殊性质 A：$a_i=0$。\n\n特殊性质 B：$0 \\le a_i \\le 10$。", "locale": "zh-CN"}}}
{"pid": "P14204", "type": "P", "difficulty": 7, "samples": [["", ""]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "交互题", "Special Judge", "通信题", "JOISC/JOIST（日本）"], "title": "[JOIST 2023] 最后之战 / The Last Battle", "background": "在洛谷上提交时，只提交一个文件。\n\n在文件头粘贴如下的内容：\n\n```cpp\nvoid Paint(int a, int b, int c);\n```\n\n**不要引入任何头文件，并使用 C++20 提交。**\n\n由于交互库实现方式的原因，将时限改为 6s。", "description": "JOICup 是由 JOI 电视台举办的人气综艺节目。现在 JOICup 进入了最终轮。在最终轮中将进行 “messenger game（信使游戏）”。只有通过第一轮的一支队伍会进行游戏。该队伍由两名选手组成，Anna 和 Bruno。\n\n在信使游戏中，选手们使用一张 $8 \\times 8$ 的网格来传递信息。网格的行编号为 $0$ 到 $7$，列编号为 $0$ 到 $7$。\n\n在信使游戏中，Anna 和 Bruno 被隔离在不同的房间。他们将进行 $Q$ 次挑战。第 $i$ 次挑战（$1 \\le i \\le Q$）按如下流程进行。\n\n1. 主持人 Bitato 给 Anna 一张卡片和一张 $8 \\times 8$ 的网格。卡片上写有三个整数 $X_i, Y_i, N_i$（$0 \\le X_i \\le 7$，$0 \\le Y_i \\le 7$，$1 \\le N_i \\le 43$）以及一个由 `A` 和 `B` 组成、长度为 $N_i$ 的字符串 $S_i$。网格上所有单元格最初均为白色。\n2. Anna 给满足 “行不等于 $X_i$ 且列不等于 $Y_i$” 的 $49$ 个单元格分别上色。每个被上色的单元格颜色要么是蓝色，要么是红色。\n3. Anna 将这张网格交给主持人 Bitato。\n4. Bitato 将满足 “行等于 $X_i$ 或列等于 $Y_i$” 的 $15$ 个单元格分别上色。每个被上色的单元格颜色要么是蓝色，要么是红色。此步骤在 Anna 和 Bruno 都看不到的房间内完成。\n5. 主持人 Bitato 将一张卡片和网格交给 Bruno。卡片上只写有整数 $N_i$。\n6. Bruno 在纸上写下一个字符串。如果它与 $S_i$ 完全一致，Anna 和 Bruno 就赢得这次游戏。\n\n挑战流程如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oqmy1edv.png)\n\n请编写程序，实现 Anna 和 Bruno 的策略，从而赢得 “messenger game”。有关本题的评分方法，请参见下文 “评分”。\n\n### 实现细节（Anna.cpp）\n\n你需要提交两个文件。第一个文件是 `Anna.cpp`，用于实现 Anna 的策略，需实现下列函数。程序应通过预处理指令 `#include` 包含 `Anna.h`。\n\n* `void Anna(int X, int Y, int N, std::string S)`  \n  该函数被调用 $Q$ 次。第 $i$ 次调用（$1 \\le i \\le Q$）对应第 $i$ 次挑战的步骤 1、2、3。  \n  * 参数 $X$ 为第 $i$ 次挑战步骤 1 中卡片上写的整数 $X_i$。  \n  * 参数 $Y$ 为第 $i$ 次挑战步骤 1 中卡片上写的整数 $Y_i$。  \n  * 参数 $N$ 为第 $i$ 次挑战步骤 1 中卡片上写的整数 $N_i$。  \n  * 参数 $S$ 为第 $i$ 次挑战步骤 1 中卡片上写的字符串 $S_i$。\n\n对每次调用 `Anna`，以下函数总计应被调用 $49$ 次。应对恰好那 $49$ 个 “行不等于 $X_i$ 且列不等于 $Y_i$” 的单元格各调用一次下列函数。\n\n* `void Paint(int a, int b, int c)`  \n  * 参数 $a, b$ 表示 Anna 给第 $a$ 行第 $b$ 列的单元格上色。必须满足 $0 \\le a \\le 7$，$0 \\le b \\le 7$，$a \\ne X$，$b \\ne Y$。若不满足，则判为 **Wrong Answer [1]**。  \n  * 参数 $c$ 表示上色的颜色：当 $c = 0$ 时为蓝色，当 $c = 1$ 时为红色。必须满足 $0 \\le c \\le 1$。若不满足，则判为 **Wrong Answer [2]**。  \n  * 若对相同的 $(a, b)$ 多次调用 `Paint`，则判为 **Wrong Answer [3]**。  \n  * 当 `Anna` 函数结束时，若调用 `Paint` 的次数不是 $49$，则判为 **Wrong Answer [4]**。\n\n### 实现细节（Bruno.cpp）\n\n第二个文件是 `Bruno.cpp`，用于实现 Bruno 的策略，需实现下列函数。程序应通过预处理指令 `#include` 包含 `Bruno.h`。\n\n* `std::string Bruno(int N, std::vector<std::vector<int>> T)`  \n  * 每当 Anna 完成网格上色后调用一次此函数。总计调用 $Q$ 次。第 $i$ 次调用（$1 \\le i \\le Q$）对应第 $i$ 次挑战的步骤 5、6。  \n  * 参数 $N$ 为第 $i$ 次挑战步骤 5 中卡片上写的整数 $N_i$。  \n  * 参数 $T$ 为大小为 $8 \\times 8$ 的二维数组，对应第 $i$ 次挑战步骤 5 中交给 Bruno 的网格。若行号为 $a$（$0 \\le a \\le 7$）且列号为 $b$（$0 \\le b \\le 7$）的单元格颜色为蓝色，则有 $\\texttt{T[a][b] = 0}$；若为红色，则有 $\\texttt{T[a][b] = 1}$。  \n  * 返回值为 Bruno 写在纸上的字符串。  \n  * 若返回值的长度不少于 $44$，则判为 **Wrong Answer [5]**。  \n  * 返回值的每个字符必须是 ‘A’ 或 ‘B’。若不满足，则判为 **Wrong Answer [6]**。\n\n### 重要注意事项\n\n* 你的程序可以实现其他供内部使用的函数，或使用全局变量。提交的文件将与评测器一同编译，生成单一的可执行文件。为避免与其他文件冲突，所有全局变量和内部函数应声明在匿名命名空间中。评测时将以 Anna 和 Bruno 两个进程的形式运行。Anna 进程与 Bruno 进程不能共享全局变量。\n* 你的程序不得使用标准输入与标准输出。你的程序不得通过任何方式与其他文件通信。不过，你可以向标准错误输出调试信息。\n\n### 编译与本地测试\n\n你可以从竞赛网页下载包含样例评测器的压缩包以测试你的程序。压缩包中也包含示例程序源码。\n\n样例评测器文件为 `grader.cpp`。要测试你的程序，请将 `grader.cpp`、`Anna.cpp`、`Bruno.cpp`、`Anna.h`、`Bruno.h` 放在同一目录下，并运行以下命令进行编译。你也可以运行压缩包内的 `compile.sh`。\n\n```\ng++ -std=gnu++17 -O2 -o grader grader.cpp Anna.cpp Bruno.cpp\n```\n\n编译成功后会生成可执行文件 `grader`。需要注意，实际评测器与样例评测器不同。特别地，**Bitaro 不一定随机给单元格上色**。样例评测器将以单进程方式运行，从标准输入读取数据并将结果输出到标准输出。", "inputFormat": "样例评测器从标准输入读取如下数据。\n\n> $Q$  \n> $X_1$ $Y_1$ $N_1$ $S_1$  \n> $X_2$ $Y_2$ $N_2$ $S_2$  \n> $\\vdots$  \n> $X_Q$ $Y_Q$ $N_Q$ $S_Q$", "outputFormat": "样例评测器向标准输出输出如下信息（为便于说明加了引号）。\n\n* 若你的程序被判定为正确，它会输出 $L^*$ 的值，如 “$\\texttt{Accepted: 28}$”。关于 $L^*$ 的定义，见下文 “评分”。\n* 若你的程序被判定为任一种 Wrong Answer，它会输出对应类型，如 “$\\texttt{Wrong Answer [1]}$”。\n\n如果你的程序同时满足多种 Wrong Answer 的判定条件，样例评测器只报告其中一种。\n\n在样例评测器中，每次挑战中 Bitaro 选择颜色是由伪随机数决定的，不同次执行的结果不变。要更改伪随机数的种子，请按如下方式以一个整数参数运行样例评测器。\n\n```\n./grader 2023\n```", "hint": "### 约束\n\n* $1 \\le Q \\le 20000$。  \n* $0 \\le X_i \\le 7$（$1 \\le i \\le Q$）。  \n* $0 \\le Y_i \\le 7$（$1 \\le i \\le Q$）。  \n* $1 \\le N_i \\le 43$（$1 \\le i \\le Q$）。  \n* $Q, X_i, Y_i, N_i$ 为整数。  \n* $S_i$（$1 \\le i \\le Q$）为由 ‘$\\texttt{A}$’ 与 ‘$\\texttt{B}$’ 组成、长度为 $N_i$ 的字符串。\n\n### 评分\n\n若你的程序在任一测试用例中出现实现细节部分的 Wrong Answer [1]–[6] 或任意运行时错误（TLE、MLE、异常结束等），则无论在其他测试用例中是否赢得挑战，得分均为 $0$。否则，令 $L^*$ 为对本题所有测试用例取下述值的最小值。你的得分按下表计算。\n\n* $L$ 的定义为：使得当 $N_i \\le L$ 时，Anna 与 Bruno 能赢得所有挑战的最大值。但若他们在全部测试用例中都赢得了所有挑战，则令 $L = 43$。\n\n| $L^*$ | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 |\n|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|\n| Score | 0 | 5 | 8 | 10 | 11 | 13 | 14 | 16 | 18 | 19 | 21 | 22 | 24 | 26 | 27 |\n\n| $L^*$ | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 |\n|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|\n| Score | 29 | 30 | 32 | 34 | 35 | 37 | 38 | 40 | 42 | 43 | 45 | 46 | 48 | 50 | 51 |\n\n| $L^*$ | 30 | 31 | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 |\n|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|\n| Score | 53 | 54 | 56 | 57 | 59 | 60 | 62 | 65 | 68 | 71 | 74 | 77 | 84 | 100 |\n\n### 样例交互\n\n下述是样例评测器的一组输入与对应的函数调用。为简洁起见，Bruno 的函数调用参数 $T$ 省略。\n\n### 样例输入 1\n```\n2\n0 0 1 B\n5 7 8 AAAABBBB\n```\n\n### 样例函数调用\n| 调用 Anna 的函数 | 调用 Bruno 的函数 | Bruno 的返回值 |\n|---|---|---|\n| $\\texttt{Anna(0, 0, 1, \"B\")}$ | | |\n| $\\texttt{Paint(1, 1, 0)}$ | | |\n| $\\texttt{Paint(1, 2, 1)}$ | | |\n| $\\vdots$ | | |\n| $\\texttt{Paint(7, 7, 1)}$ | | |\n| | $\\texttt{Bruno(1, ...)}$ | $\\texttt{\"B\"}$ |\n| $\\texttt{Anna(5, 7, 8, \"AAAABBBB\")}$ | | |\n| $\\texttt{Paint(0, 0, 1)}$ | | |\n| $\\texttt{Paint(0, 1, 1)}$ | | |\n| $\\vdots$ | | |\n| $\\texttt{Paint(7, 6, 0)}$ | | |\n| | $\\texttt{Bruno(8, ...)}$ | $\\texttt{\"AAAABBBB\"}$ |\n\n在这组样例输入中，有 $Q = 2$ 次挑战。  \n* 第一次挑战中，$X_1 = 0$，$Y_1 = 0$，$N_1 = 1$，$S_1 = \\texttt{\"B\"}$。Anna 给所有 “行不为 $0$ 且列不为 $0$” 的 $49$ 个单元格上色。  \n* 第二次挑战中，$X_2 = 5$，$Y_2 = 7$，$N_2 = 8$，$S_2 = \\texttt{\"AAAABBBB\"}$。Anna 给所有 “行不为 $5$ 且列不为 $7$” 的 $49$ 个单元格上色。\n\n例如，若你的程序在第一次挑战中调用了 $\\texttt{Paint(0, 2, 1)}$，则因为其指定了行号为 $0$ 的单元格而被判为 **Wrong Answer [1]**。\n\n这里还给出样例评测器的另一组输入。\n\n\n```\n30\n3 1 1 A\n1 4 1 A\n6 6 2 AA\n1 1 2 BB\n3 1 3 BAB\n7 4 3 AAB\n6 4 4 BAAB\n6 7 4 BABA\n3 3 5 BABBA\n1 5 5 ABBBA\n4 3 6 ABBBBB\n2 1 6 ABAAAA\n6 0 7 AAABABA\n6 6 7 BBABBAA\n0 4 8 AABAABAB\n2 1 8 AABBBBBA\n2 0 9 BABABBAAA\n1 5 9 BBAAABABB\n6 7 10 BAAABAAABB\n1 7 10 BBBBBBBABA\n2 6 12 AABAABABABAB\n3 4 15 BBAABAAAABABAAB\n5 6 18 BAAAABBABABBBABBAB\n7 0 22 BABBAABAAABBABBBBBBABA\n2 0 26 AAAABBABBAAAAABABABBAABAAA\n0 7 30 AAABBBAAABAABBBBAABBAAABBBABBB\n2 7 34 BABAABBAABABBABAABBABBABAABBBBABBB\n2 5 38 BBBBAABAABAABABABBBBBAAABBABAAABAAABBB\n5 2 41 AABABBAAABBABAAAABBABABBAAAAAABBABBABBABA\n1 0 43 AABBABBBBABABBBABBBBAAAAAABABAAABBBAABBAAAB\n```", "locale": "zh-CN", "translations": {"en": {"title": "[JOIST 2023] The Last Battle", "background": "", "description": " JOICup is a popular television variety program held by JOI broadcast station. Now JOICup becomes the final round. In the final round, the “messenger game” will be played. Only one team which passed the first round will play the game. The team consists of two players, Anna and Bruno.\n\nIn the messenger game, the players send information using a grid of $8 \\times 8$ cells. The rows of the grid are numbered from $0$ to $7$, and the columns of the grid are numbered from $0$ to $7$.\n\nIn the messenger game, Anna and Bruno are isolated in different rooms. They will play $Q$ challenges. The $i$-th challenge ($1 \\le i \\le Q$) proceeds as follows.\n\n1. Bitato, the moderator of the game, gives a card and a grid of $8 \\times 8$ cells to Anna. On the card, three integers $X_i, Y_i$, ($0 \\le X_i \\le 7$, $0 \\le Y_i \\le 7$, $1 \\le N_i \\le 43$) and a string $S_i$ of length $N_i$ consisting of ‘A’ and ‘B’ are written. All of the cells in the grid are white.\n2. Anna paints each of the 49 cells whose row is different from $X_i$ and column is different from $Y_i$. The color of each cell is either blue or red.\n3. Anna gives the grid of cells to Bitato, the moderator of the game.\n4. Bitato paints each of the 15 cells whose row is equal to $X_i$ or column is equal to $Y_i$. The color of each cell is either blue or red. This process is done in a room which is not seen by Anna nor Bruno.\n5. Bitato, the moderator of the game, gives a card and the grid of cells to Bruno. Only the integer $N_i$ is written on the card.\n6. Bruno writes a string on a paper. If it coincides with $S_i$, Anna and Bruno win the game.\n\nThe challenges proceed as in the following figure.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oqmy1edv.png)\n\nWrite programs which implement the strategies of Anna and Bruno to win the “messenger game.” For the grading of this task, see Grading.\n\n### Implementation Details\n\nYou need to submit two files.\nThe first file is `Anna.cpp`. It should implement Anna’s strategy. It should implement the following functions.\nThe program should include `Anna.h` using the preprocessing directive `#include`.\n\n* `void Anna(int X, int Y, int N, std::string S)`\n  This function is called $Q$ times. The $i$-th call ($1 \\le i \\le Q$) corresponds to the procedures 1., 2., 3. of the $i$-th challenge.\n  * The parameter $X$ is the integer $X_i$ written on the card given to Anna in the procedure 1. of the $i$-th challenge.\n  * The parameter $Y$ is the integer $Y_i$ written on the card given to Anna in the procedure 1. of the $i$-th challenge.\n  * The parameter $N$ is the integer $N_i$ written on the card given to Anna in the procedure 1. of the $i$-th challenge.\n  * The parameter $S$ is the string $S_i$ written on the card given to Anna in the procedure 1. of the $i$-th challenge.\n\nFor each function call to `Anna`, the following function should be called 49 times in total. The following function should be called once for each of the 49 cells whose row is different from $X_i$ and column is different from $Y_i$.\n\n* `void Paint(int a, int b, int c)`\n  * The parameters $a, b$ mean Anna paints the cell whose row is $a$ and column is $b$. Here the conditions $0 \\le a \\le 7$, $0 \\le b \\le 7$, $a \\ne X$, $b \\ne Y$ should be satisfied. If this condition is not satisfied, your program is judged as **Wrong Answer [1]**.\n  * The parameter $c$ means the color painted by Anna is blue if $c = 0$, and red if $c = 1$. Here, $0 \\le c \\le 1$ should be satisfied. If this condition is not satisfied, your program is judged as **Wrong Answer [2]**.\n  * If the function `Paint` is called with the same parameters $(a, b)$ more than once, your program is judged as **Wrong Answer [3]**.\n  * When the function `Anna` terminates, if the number of function calls to `Paint` is different from 49, your program is judged as **Wrong Answer [4]**.\n\n ### Bruno.cpp Implementation Details\n\nThe second file is `Bruno.cpp`. It should implement Bruno's strategy. It should implement the following function. The program should include `Bruno.h` using the preprocessing directive `#include`.\n\n*   `std::string Bruno(int N, std::vector<std::vector<int>> T)`\n    *   This function is called every time when Anna finishes painting the grid. This function is called $Q$ times in total. The $i$-th call ($1 \\le i \\le Q$) corresponds to the procedures 5., 6. of the $i$-th challenge of the game.\n    *   The parameter $N$ is the integer $N_i$ written on the card given to Bruno in the procedure 5. of the $i$-th challenge.\n    *   The parameter $T$ is a two-dimensional array of size $8 \\times 8$ corresponding to the grid of cells given to Bruno in the procedure 5. of the $i$-th challenge. The color of the cell whose row is a ($0 \\le a \\le 7$) and column is b ($0 \\le b \\le 7$) is blue if $\\texttt{T[a][b] = 0}$, and red if $\\texttt{T[a][b] = 1}$.\n    *   The return value is the string written by Bruno on a paper.\n    *   If the return value is a string of length 44 or more, your program is judged as **Wrong Answer [5]**.\n    *   Each character of the return value should be either 'A' or 'B'. If this condition is not satisfied, your program is judged as **Wrong Answer [6]**.\n\n### Important Notices\n\n*   Your program can implement other functions for internal use, or use global variables. Submitted files will be compiled with the grader, and become a single executable file. All global variables and internal functions should be declared in an unnamed namespace to avoid confliction with other files. When it is graded, it will be executed as two processes of Anna and Bruno. The process of Anna and the process of Bruno cannot share global variables.\n*   Your program must not use the standard input and the standard output. Your program must not communicate with other files by any methods. However, your program may output debugging information to the standard error.\n\n ### Compilation and Test Run\n\nYou can download an archive file from the contest webpage which contains the sample grader to test your program. The archive file also contains a sample source file of your program.\n\nThe sample grader is the file `grader.cpp`. In order to test your program, put `grader.cpp`, `Anna.cpp`, `Bruno.cpp`, `Anna.h`, `Bruno.h` in the same directory, and run the following command to compile your programs. Instead, you may run `compile.sh` contained in the archive file.\n\n```\ng++ -std=gnu++17 -O2 -o grader grader.cpp Anna.cpp Bruno.cpp\n```\n\nWhen the compilation succeeds, the executable file `grader` is generated.\nNote that the actual grader is different from the sample grader. In particular, **Bitaro does not necessarily choose the colors to paint the cells randomly**. The sample grader will be executed as a single process, which will read input data from the standard input and write the results to the standard output.\n", "inputFormat": "\nThe sample grader reads the following data from the standard input.\n\n> $Q$ \\\n> $X_1$ $Y_1$ $N_1$ $S_1$ \\\n> $X_2$ $Y_2$ $N_2$ $S_2$ \\\n> $\\vdots$ \\\n> $X_Q$ $Y_Q$ $N_Q$ $S_Q$ ", "outputFormat": "\nThe sample grader outputs the following information to the standard output (quotes for clarity).\n\n* If your program is judged as correct, it writes the value of $L^*$ as \"$\\texttt{Accepted: 28}$\". For the value of $L^*$, see Grading.\n* If your program is judged as any type of Wrong Answer, the sample grader writes its type as \"$\\texttt{Wrong Answer [1]}$\".\n\nIf your program satisfies the conditions of several types of Wrong Answer, the sample grader reports only one of them.\n\nIn sample grader, the colors chosen by Bitaro for challenges are randomly determined by pseudorandom numbers whose results do not change for different executions. In order to change the seed of pseudorandom numbers, run the sample grader with the first integer argument as follows.\n\n```\n./grader 2023\n```", "hint": "\n### Constraints\n\n* $1 \\le Q \\le 20000$.\n* $0 \\le X_i \\le 7$ ($1 \\le i \\le Q$).\n* $0 \\le Y_i \\le 7$ ($1 \\le i \\le Q$).\n* $1 \\le N_i \\le 43$ ($1 \\le i \\le Q$).\n* $Q, X_i, Y_i, N_i$ are integers.\n* $S_i$ ($1 \\le i \\le Q$) is a string of length $N_i$ consisting of '$\\texttt{A}$' and '$\\texttt{B}$'.\n\n### Grading\n\nIf your program is judged as any type of Wrong Answer [1]-[6] (see Implementation Details) or any type of runtime errors (TLE (Time Limit Exceeded), MLE (Memory Limit Exceeded), Abnormal End, etc.) in any of the test cases, your score is 0 point regardless of whether your program wins challenges in other test cases. Otherwise, let $L^*$ be the minimum of the following values for all test cases of this task. Your score is calculated as in the following table.\n\n* The maximum value of $L$ such that Anna and Bruno win all the challenges satisfying $N_i \\le L$. However, if they win all the challenges in the test cases, we set $L = 43$.\n\n| $L^*$ | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 |\n|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|\n| Score | 0 | 5 | 8 | 10 | 11 | 13 | 14 | 16 | 18 | 19 | 21 | 22 | 24 | 26 | 27 |\n\n| $L^*$ | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 |\n|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|\n| Score | 29 | 30 | 32 | 34 | 35 | 37 | 38 | 40 | 42 | 43 | 45 | 46 | 48 | 50 | 51 |\n\n| $L^*$ | 30 | 31 | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 |\n|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|\n| Score | 53 | 54 | 56 | 57 | 59 | 60 | 62 | 65 | 68 | 71 | 74 | 77 | 84 | 100 |\n\n ### Sample Communication\nHere is a sample input for the sample grader and corresponding function calls. The parameters $T$ for the function calls to Bruno are omitted.\n\n### Sample Input 1\n```\n2\n0 0 1 B\n5 7 8 AAAABBBB\n```\n\n### Sample Function Calls\n| Function call to Anna | Function call to Bruno | Return value of Bruno |\n|---|---|---|\n| $\\texttt{Anna(0, 0, 1, \"B\")}$ | | |\n| $\\texttt{Paint(1, 1, 0)}$ | | |\n| $\\texttt{Paint(1, 2, 1)}$ | | |\n| $\\vdots$ | | |\n| $\\texttt{Paint(7, 7, 1)}$ | | |\n| | $\\texttt{Bruno(1, ...)}$ | $\\texttt{\"B\"}$ |\n| $\\texttt{Anna(5, 7, 8, \"AAAABBBB\")}$ | | |\n| $\\texttt{Paint(0, 0, 1)}$ | | |\n| $\\texttt{Paint(0, 1, 1)}$ | | |\n| $\\vdots$ | | |\n| $\\texttt{Paint(7, 6, 0)}$ | | |\n| | $\\texttt{Bruno(8, ...)}$ | $\\texttt{\"AAAABBBB\"}$ |\n\nIn this sample input, there are $Q = 2$ challenges.\n* In the first challenge, we have $X_1 = 0, Y_1 = 0, N_1 = 1, S_1 = \\texttt{\"B\"}$. Anna paints the 49 cells whose row is different from 0 and column is different from 0.\n* In the second challenge, we have $X_2 = 5, Y_2 = 7, N_2 = 8, S_2 = \\texttt{\"AAAABBBB\"}$. Anna paints the 49 cells whose row is different from 5 and column is different from 7.\n\nFor example, if your program calls $\\texttt{Paint(0, 2, 1)}$ in the first challenge, it is judged as **Wrong Answer [1]** because it designates a cell whose row is 0.\n\nHere is another sample input for the sample grader.\n\n```\n30\n3 1 1 A\n1 4 1 A\n6 6 2 AA\n1 1 2 BB\n3 1 3 BAB\n7 4 3 AAB\n6 4 4 BAAB\n6 7 4 BABA\n3 3 5 BABBA\n1 5 5 ABBBA\n4 3 6 ABBBBB\n2 1 6 ABAAAA\n6 0 7 AAABABA\n6 6 7 BBABBAA\n0 4 8 AABAABAB\n2 1 8 AABBBBBA\n2 0 9 BABABBAAA\n1 5 9 BBAAABABB\n6 7 10 BAAABAAABB\n1 7 10 BBBBBBBABA\n2 6 12 AABAABABABAB\n3 4 15 BBAABAAAABABAAB\n5 6 18 BAAAABBABABBBABBAB\n7 0 22 BABBAABAAABBABBBBBBABA\n2 0 26 AAAABBABBAAAAABABABBAABAAA\n0 7 30 AAABBBAAABAABBBBAABBAAABBBABBB\n2 7 34 BABAABBAABABBABAABBABBABAABBBBABBB\n2 5 38 BBBBAABAABAABABABBBBBAAABBABAAABAAABBB\n5 2 41 AABABBAAABBABAAAABBABABBAAAAAABBABBABBABA\n1 0 43 AABBABBBBABABBBABBBBAAAAAABABAAABBBAABBAAAB\n```", "locale": "en"}, "zh-CN": {"title": "[JOIST 2023] 最后之战 / The Last Battle", "background": "在洛谷上提交时，只提交一个文件。\n\n在文件头粘贴如下的内容：\n\n```cpp\nvoid Paint(int a, int b, int c);\n```\n\n**不要引入任何头文件，并使用 C++20 提交。**\n\n由于交互库实现方式的原因，将时限改为 6s。", "description": "JOICup 是由 JOI 电视台举办的人气综艺节目。现在 JOICup 进入了最终轮。在最终轮中将进行 “messenger game（信使游戏）”。只有通过第一轮的一支队伍会进行游戏。该队伍由两名选手组成，Anna 和 Bruno。\n\n在信使游戏中，选手们使用一张 $8 \\times 8$ 的网格来传递信息。网格的行编号为 $0$ 到 $7$，列编号为 $0$ 到 $7$。\n\n在信使游戏中，Anna 和 Bruno 被隔离在不同的房间。他们将进行 $Q$ 次挑战。第 $i$ 次挑战（$1 \\le i \\le Q$）按如下流程进行。\n\n1. 主持人 Bitato 给 Anna 一张卡片和一张 $8 \\times 8$ 的网格。卡片上写有三个整数 $X_i, Y_i, N_i$（$0 \\le X_i \\le 7$，$0 \\le Y_i \\le 7$，$1 \\le N_i \\le 43$）以及一个由 `A` 和 `B` 组成、长度为 $N_i$ 的字符串 $S_i$。网格上所有单元格最初均为白色。\n2. Anna 给满足 “行不等于 $X_i$ 且列不等于 $Y_i$” 的 $49$ 个单元格分别上色。每个被上色的单元格颜色要么是蓝色，要么是红色。\n3. Anna 将这张网格交给主持人 Bitato。\n4. Bitato 将满足 “行等于 $X_i$ 或列等于 $Y_i$” 的 $15$ 个单元格分别上色。每个被上色的单元格颜色要么是蓝色，要么是红色。此步骤在 Anna 和 Bruno 都看不到的房间内完成。\n5. 主持人 Bitato 将一张卡片和网格交给 Bruno。卡片上只写有整数 $N_i$。\n6. Bruno 在纸上写下一个字符串。如果它与 $S_i$ 完全一致，Anna 和 Bruno 就赢得这次游戏。\n\n挑战流程如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oqmy1edv.png)\n\n请编写程序，实现 Anna 和 Bruno 的策略，从而赢得 “messenger game”。有关本题的评分方法，请参见下文 “评分”。\n\n### 实现细节（Anna.cpp）\n\n你需要提交两个文件。第一个文件是 `Anna.cpp`，用于实现 Anna 的策略，需实现下列函数。程序应通过预处理指令 `#include` 包含 `Anna.h`。\n\n* `void Anna(int X, int Y, int N, std::string S)`  \n  该函数被调用 $Q$ 次。第 $i$ 次调用（$1 \\le i \\le Q$）对应第 $i$ 次挑战的步骤 1、2、3。  \n  * 参数 $X$ 为第 $i$ 次挑战步骤 1 中卡片上写的整数 $X_i$。  \n  * 参数 $Y$ 为第 $i$ 次挑战步骤 1 中卡片上写的整数 $Y_i$。  \n  * 参数 $N$ 为第 $i$ 次挑战步骤 1 中卡片上写的整数 $N_i$。  \n  * 参数 $S$ 为第 $i$ 次挑战步骤 1 中卡片上写的字符串 $S_i$。\n\n对每次调用 `Anna`，以下函数总计应被调用 $49$ 次。应对恰好那 $49$ 个 “行不等于 $X_i$ 且列不等于 $Y_i$” 的单元格各调用一次下列函数。\n\n* `void Paint(int a, int b, int c)`  \n  * 参数 $a, b$ 表示 Anna 给第 $a$ 行第 $b$ 列的单元格上色。必须满足 $0 \\le a \\le 7$，$0 \\le b \\le 7$，$a \\ne X$，$b \\ne Y$。若不满足，则判为 **Wrong Answer [1]**。  \n  * 参数 $c$ 表示上色的颜色：当 $c = 0$ 时为蓝色，当 $c = 1$ 时为红色。必须满足 $0 \\le c \\le 1$。若不满足，则判为 **Wrong Answer [2]**。  \n  * 若对相同的 $(a, b)$ 多次调用 `Paint`，则判为 **Wrong Answer [3]**。  \n  * 当 `Anna` 函数结束时，若调用 `Paint` 的次数不是 $49$，则判为 **Wrong Answer [4]**。\n\n### 实现细节（Bruno.cpp）\n\n第二个文件是 `Bruno.cpp`，用于实现 Bruno 的策略，需实现下列函数。程序应通过预处理指令 `#include` 包含 `Bruno.h`。\n\n* `std::string Bruno(int N, std::vector<std::vector<int>> T)`  \n  * 每当 Anna 完成网格上色后调用一次此函数。总计调用 $Q$ 次。第 $i$ 次调用（$1 \\le i \\le Q$）对应第 $i$ 次挑战的步骤 5、6。  \n  * 参数 $N$ 为第 $i$ 次挑战步骤 5 中卡片上写的整数 $N_i$。  \n  * 参数 $T$ 为大小为 $8 \\times 8$ 的二维数组，对应第 $i$ 次挑战步骤 5 中交给 Bruno 的网格。若行号为 $a$（$0 \\le a \\le 7$）且列号为 $b$（$0 \\le b \\le 7$）的单元格颜色为蓝色，则有 $\\texttt{T[a][b] = 0}$；若为红色，则有 $\\texttt{T[a][b] = 1}$。  \n  * 返回值为 Bruno 写在纸上的字符串。  \n  * 若返回值的长度不少于 $44$，则判为 **Wrong Answer [5]**。  \n  * 返回值的每个字符必须是 ‘A’ 或 ‘B’。若不满足，则判为 **Wrong Answer [6]**。\n\n### 重要注意事项\n\n* 你的程序可以实现其他供内部使用的函数，或使用全局变量。提交的文件将与评测器一同编译，生成单一的可执行文件。为避免与其他文件冲突，所有全局变量和内部函数应声明在匿名命名空间中。评测时将以 Anna 和 Bruno 两个进程的形式运行。Anna 进程与 Bruno 进程不能共享全局变量。\n* 你的程序不得使用标准输入与标准输出。你的程序不得通过任何方式与其他文件通信。不过，你可以向标准错误输出调试信息。\n\n### 编译与本地测试\n\n你可以从竞赛网页下载包含样例评测器的压缩包以测试你的程序。压缩包中也包含示例程序源码。\n\n样例评测器文件为 `grader.cpp`。要测试你的程序，请将 `grader.cpp`、`Anna.cpp`、`Bruno.cpp`、`Anna.h`、`Bruno.h` 放在同一目录下，并运行以下命令进行编译。你也可以运行压缩包内的 `compile.sh`。\n\n```\ng++ -std=gnu++17 -O2 -o grader grader.cpp Anna.cpp Bruno.cpp\n```\n\n编译成功后会生成可执行文件 `grader`。需要注意，实际评测器与样例评测器不同。特别地，**Bitaro 不一定随机给单元格上色**。样例评测器将以单进程方式运行，从标准输入读取数据并将结果输出到标准输出。", "inputFormat": "样例评测器从标准输入读取如下数据。\n\n> $Q$  \n> $X_1$ $Y_1$ $N_1$ $S_1$  \n> $X_2$ $Y_2$ $N_2$ $S_2$  \n> $\\vdots$  \n> $X_Q$ $Y_Q$ $N_Q$ $S_Q$", "outputFormat": "样例评测器向标准输出输出如下信息（为便于说明加了引号）。\n\n* 若你的程序被判定为正确，它会输出 $L^*$ 的值，如 “$\\texttt{Accepted: 28}$”。关于 $L^*$ 的定义，见下文 “评分”。\n* 若你的程序被判定为任一种 Wrong Answer，它会输出对应类型，如 “$\\texttt{Wrong Answer [1]}$”。\n\n如果你的程序同时满足多种 Wrong Answer 的判定条件，样例评测器只报告其中一种。\n\n在样例评测器中，每次挑战中 Bitaro 选择颜色是由伪随机数决定的，不同次执行的结果不变。要更改伪随机数的种子，请按如下方式以一个整数参数运行样例评测器。\n\n```\n./grader 2023\n```", "hint": "### 约束\n\n* $1 \\le Q \\le 20000$。  \n* $0 \\le X_i \\le 7$（$1 \\le i \\le Q$）。  \n* $0 \\le Y_i \\le 7$（$1 \\le i \\le Q$）。  \n* $1 \\le N_i \\le 43$（$1 \\le i \\le Q$）。  \n* $Q, X_i, Y_i, N_i$ 为整数。  \n* $S_i$（$1 \\le i \\le Q$）为由 ‘$\\texttt{A}$’ 与 ‘$\\texttt{B}$’ 组成、长度为 $N_i$ 的字符串。\n\n### 评分\n\n若你的程序在任一测试用例中出现实现细节部分的 Wrong Answer [1]–[6] 或任意运行时错误（TLE、MLE、异常结束等），则无论在其他测试用例中是否赢得挑战，得分均为 $0$。否则，令 $L^*$ 为对本题所有测试用例取下述值的最小值。你的得分按下表计算。\n\n* $L$ 的定义为：使得当 $N_i \\le L$ 时，Anna 与 Bruno 能赢得所有挑战的最大值。但若他们在全部测试用例中都赢得了所有挑战，则令 $L = 43$。\n\n| $L^*$ | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 |\n|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|\n| Score | 0 | 5 | 8 | 10 | 11 | 13 | 14 | 16 | 18 | 19 | 21 | 22 | 24 | 26 | 27 |\n\n| $L^*$ | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 |\n|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|\n| Score | 29 | 30 | 32 | 34 | 35 | 37 | 38 | 40 | 42 | 43 | 45 | 46 | 48 | 50 | 51 |\n\n| $L^*$ | 30 | 31 | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 |\n|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|\n| Score | 53 | 54 | 56 | 57 | 59 | 60 | 62 | 65 | 68 | 71 | 74 | 77 | 84 | 100 |\n\n### 样例交互\n\n下述是样例评测器的一组输入与对应的函数调用。为简洁起见，Bruno 的函数调用参数 $T$ 省略。\n\n### 样例输入 1\n```\n2\n0 0 1 B\n5 7 8 AAAABBBB\n```\n\n### 样例函数调用\n| 调用 Anna 的函数 | 调用 Bruno 的函数 | Bruno 的返回值 |\n|---|---|---|\n| $\\texttt{Anna(0, 0, 1, \"B\")}$ | | |\n| $\\texttt{Paint(1, 1, 0)}$ | | |\n| $\\texttt{Paint(1, 2, 1)}$ | | |\n| $\\vdots$ | | |\n| $\\texttt{Paint(7, 7, 1)}$ | | |\n| | $\\texttt{Bruno(1, ...)}$ | $\\texttt{\"B\"}$ |\n| $\\texttt{Anna(5, 7, 8, \"AAAABBBB\")}$ | | |\n| $\\texttt{Paint(0, 0, 1)}$ | | |\n| $\\texttt{Paint(0, 1, 1)}$ | | |\n| $\\vdots$ | | |\n| $\\texttt{Paint(7, 6, 0)}$ | | |\n| | $\\texttt{Bruno(8, ...)}$ | $\\texttt{\"AAAABBBB\"}$ |\n\n在这组样例输入中，有 $Q = 2$ 次挑战。  \n* 第一次挑战中，$X_1 = 0$，$Y_1 = 0$，$N_1 = 1$，$S_1 = \\texttt{\"B\"}$。Anna 给所有 “行不为 $0$ 且列不为 $0$” 的 $49$ 个单元格上色。  \n* 第二次挑战中，$X_2 = 5$，$Y_2 = 7$，$N_2 = 8$，$S_2 = \\texttt{\"AAAABBBB\"}$。Anna 给所有 “行不为 $5$ 且列不为 $7$” 的 $49$ 个单元格上色。\n\n例如，若你的程序在第一次挑战中调用了 $\\texttt{Paint(0, 2, 1)}$，则因为其指定了行号为 $0$ 的单元格而被判为 **Wrong Answer [1]**。\n\n这里还给出样例评测器的另一组输入。\n\n\n```\n30\n3 1 1 A\n1 4 1 A\n6 6 2 AA\n1 1 2 BB\n3 1 3 BAB\n7 4 3 AAB\n6 4 4 BAAB\n6 7 4 BABA\n3 3 5 BABBA\n1 5 5 ABBBA\n4 3 6 ABBBBB\n2 1 6 ABAAAA\n6 0 7 AAABABA\n6 6 7 BBABBAA\n0 4 8 AABAABAB\n2 1 8 AABBBBBA\n2 0 9 BABABBAAA\n1 5 9 BBAAABABB\n6 7 10 BAAABAAABB\n1 7 10 BBBBBBBABA\n2 6 12 AABAABABABAB\n3 4 15 BBAABAAAABABAAB\n5 6 18 BAAAABBABABBBABBAB\n7 0 22 BABBAABAAABBABBBBBBABA\n2 0 26 AAAABBABBAAAAABABABBAABAAA\n0 7 30 AAABBBAAABAABBBBAABBAAABBBABBB\n2 7 34 BABAABBAABABBABAABBABBABAABBBBABBB\n2 5 38 BBBBAABAABAABABABBBBBAAABBABAAABAAABBB\n5 2 41 AABABBAAABBABAAAABBABABBAAAAAABBABBABBABA\n1 0 43 AABBABBBBABABBBABBBBAAAAAABABAAABBBAABBAAAB\n```", "locale": "zh-CN"}}}
{"pid": "P14205", "type": "P", "difficulty": 3, "samples": [["1 10\n8 1", "0"], ["3 3\n4 2\n1 1\n10 8", "3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "ROI（俄罗斯）"], "title": "[ROI 2016 Day1] 要塞防御", "background": "**译自 [ROI 2016](http://neerc.ifmo.ru/school/archive/2015-2016.html) Day1 T1.** ***[Оборона крепости](http://neerc.ifmo.ru/school/archive/2015-2016/ru-olymp-roi-2016-day1.pdf)***", "description": "被围困的要塞之墙由 $n$ 个防御段组成，这些防御段从 $1$ 到 $n$ 编号。侦察报告称，在下一次进攻中，敌人将派出 $a_i$ 名士兵进攻编号为 $i$ 的防御段。要塞共有 $s$ 名守卫，需要分配到这些防御段上。\n\n不同的防御段加固程度不同，这导致了防守效率的差异。编号为 $i$ 的防御段上，每一名守卫都能抵御 $k_i$ 名进攻者。假设编号为 $i$ 的防御段上派遣了 $x_i$ 名守卫。那么，如果敌人的数量不超过 $x_i \\cdot k_i$，则该段防线将完全守住，不会有敌人突破；否则，将有 $a_i - x_i \\cdot k_i$ 名敌人突破防线，攻入要塞。\n\n你的任务是编写一个程序，合理分配守卫人数，使得总人数恰好为 $s$，并使得突破要塞的敌人数最少。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $s$，分别表示防御段的数量和要塞的守卫总数（$1 \\le n \\le 100\\,000$；$1 \\le s \\le 10^9$）。\n\n接下来的 $n$ 行中，每行包含两个整数 $a_i, k_i$，分别表示进攻编号为 $i$ 的防御段的敌人总数，以及该段上每名守卫能够抵御的敌人数（$1 \\le a_i, k_i \\le 10^9$）。", "outputFormat": "输出一个整数——即最少能突破要塞的敌人数。", "hint": "### 样例解释\n\n在第一个测试中，如果将全部 $10$ 名守卫派往唯一的防御段，他们可以击退所有 $8$ 名敌人，因此不会有敌人突破防线。  \n\n在第二个测试中，一种可行的方案是将 $2$ 名守卫派往第一个防御段，将 $1$ 名守卫派往第三个防御段，这样可以使突破的敌人数量最小化。\n\n### 数据范围\n\n| 子任务编号 | 分值 | $n$ | $s$ | $a$ | $k$ | 必须通过的子任务 |\n|:-----------:|:----:|:---:|:---:|:---:|:---:|:----------------:|\n| 1 | 17 | $1 \\le n \\le 100$ | $1 \\le s \\le 10\\,000$ | $1 \\le a_i \\le 100$ | $k_i = 1$ |  |\n| 2 | 21 | $1 \\le n \\le 100$ | $1 \\le s \\le 10\\,000$ | $1 \\le a_i \\le 100$ | $k_i \\le 2$ | 1 |\n| 3 | 23 | $1 \\le n \\le 100$ | $1 \\le s \\le 10\\,000$ | $1 \\le a_i \\le 100$ | $1 \\le k_i \\le 100$ | 1, 2 |\n| 4 | 39 | $1 \\le n \\le 100\\,000$ | $1 \\le s \\le 10^9$ | $1 \\le a_i \\le 10^9$ | $1 \\le k_i \\le 10^9$ | 1, 2, 3 |\n\n翻译由 ChatGPT-5 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROI 2016 Day1] 要塞防御", "background": "**译自 [ROI 2016](http://neerc.ifmo.ru/school/archive/2015-2016.html) Day1 T1.** ***[Оборона крепости](http://neerc.ifmo.ru/school/archive/2015-2016/ru-olymp-roi-2016-day1.pdf)***", "description": "被围困的要塞之墙由 $n$ 个防御段组成，这些防御段从 $1$ 到 $n$ 编号。侦察报告称，在下一次进攻中，敌人将派出 $a_i$ 名士兵进攻编号为 $i$ 的防御段。要塞共有 $s$ 名守卫，需要分配到这些防御段上。\n\n不同的防御段加固程度不同，这导致了防守效率的差异。编号为 $i$ 的防御段上，每一名守卫都能抵御 $k_i$ 名进攻者。假设编号为 $i$ 的防御段上派遣了 $x_i$ 名守卫。那么，如果敌人的数量不超过 $x_i \\cdot k_i$，则该段防线将完全守住，不会有敌人突破；否则，将有 $a_i - x_i \\cdot k_i$ 名敌人突破防线，攻入要塞。\n\n你的任务是编写一个程序，合理分配守卫人数，使得总人数恰好为 $s$，并使得突破要塞的敌人数最少。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $s$，分别表示防御段的数量和要塞的守卫总数（$1 \\le n \\le 100\\,000$；$1 \\le s \\le 10^9$）。\n\n接下来的 $n$ 行中，每行包含两个整数 $a_i, k_i$，分别表示进攻编号为 $i$ 的防御段的敌人总数，以及该段上每名守卫能够抵御的敌人数（$1 \\le a_i, k_i \\le 10^9$）。", "outputFormat": "输出一个整数——即最少能突破要塞的敌人数。", "hint": "### 样例解释\n\n在第一个测试中，如果将全部 $10$ 名守卫派往唯一的防御段，他们可以击退所有 $8$ 名敌人，因此不会有敌人突破防线。  \n\n在第二个测试中，一种可行的方案是将 $2$ 名守卫派往第一个防御段，将 $1$ 名守卫派往第三个防御段，这样可以使突破的敌人数量最小化。\n\n### 数据范围\n\n| 子任务编号 | 分值 | $n$ | $s$ | $a$ | $k$ | 必须通过的子任务 |\n|:-----------:|:----:|:---:|:---:|:---:|:---:|:----------------:|\n| 1 | 17 | $1 \\le n \\le 100$ | $1 \\le s \\le 10\\,000$ | $1 \\le a_i \\le 100$ | $k_i = 1$ |  |\n| 2 | 21 | $1 \\le n \\le 100$ | $1 \\le s \\le 10\\,000$ | $1 \\le a_i \\le 100$ | $k_i \\le 2$ | 1 |\n| 3 | 23 | $1 \\le n \\le 100$ | $1 \\le s \\le 10\\,000$ | $1 \\le a_i \\le 100$ | $1 \\le k_i \\le 100$ | 1, 2 |\n| 4 | 39 | $1 \\le n \\le 100\\,000$ | $1 \\le s \\le 10^9$ | $1 \\le a_i \\le 10^9$ | $1 \\le k_i \\le 10^9$ | 1, 2, 3 |\n\n翻译由 ChatGPT-5 完成", "locale": "zh-CN"}}}
{"pid": "P14206", "type": "P", "difficulty": 4, "samples": [["3 4 0\nSSSS\nEESW\nENWW", "4"], ["3 4 1\nSSSS\nEeSW\nENwW", "4\n2 3 2\n3 2 1\n3 4 1\n2 1 2"], ["4 4 1\nessS\nEess\nSnww\nEeWN", "5\n1 4 9\n2 1 4\n4 3 3\n4 1 2\n4 4 7"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "Special Judge", "ROI（俄罗斯）"], "title": "[ROI 2016 Day1] 机器人实验", "background": "**译自 [ROI 2016](http://neerc.ifmo.ru/school/archive/2015-2016.html) Day1 T2.** ***[ Экспериментальная робототехника](http://neerc.ifmo.ru/school/archive/2015-2016/ru-olymp-roi-2016-day1.pdf)***", "description": "鞑靼斯坦的各大学是教育机器人学领域的领先中心。为了推广这一方向，决定向中小学生提出一个有趣的实验——让机器人在有限空间内进行“生存实验”。\n\n实验在一个大小为 $n \\times m$ 的矩形场地上进行。在实验开始时，部分给定的格子中各放置一个尚未激活的机器人。在收到“开始”指令后，计时器启动，并在每秒开始时发出信号。在每次计时器信号发出后（但不超过 $T_{\\max} = 10^9$ 秒），允许激活部分机器人。\n\n场地中的每个格子被涂成四种颜色之一，机器人通过传感器可以识别这些颜色。颜色对应于从当前格子移动到相邻格子的方向——北、南、东或西。在每次计时器信号发出的那一刻，所有已激活的机器人**同时**按照当前所在格子的颜色所指的方向移动到相邻格子。颜色的分布方式保证了：机器人永远不会移动出场地边界之外。\n\n为了避免损坏，禁止以可能导致机器人**碰撞**的方式激活机器人。“碰撞”指的是两台或以上已激活的机器人在同一个时刻出现在同一个格子中。如果发生碰撞，则实验被视为失败。注意：若两个机器人从相邻格子相向移动，并最终互换位置，这**不算作碰撞**。\n\n若所有已激活的机器人能在场地上无限长时间内持续移动而不发生碰撞，则实验视为**成功完成**。实验的结果定义为：**被激活机器人的数量**。\n\n请你编写一个程序，帮助学生根据场地描述及初始放置的机器人位置，确定实验可能达到的最大结果；若有需要，还要指出应当激活哪些机器人以及在什么时刻激活，以达到这一最优结果。", "inputFormat": "第一行包含三个整数 $n$、$m$ 和 $g$，其中：\n\n- $n, m$ —— 场地的行数（从北到南）与列数（从西到东），满足 $1 \\le n, m \\le 1000$；\n- $g$ —— 一个标志变量，取值为 $1$ 或 $0$。若 $g = 1$，则要求输出具体的机器人激活方案；若 $g = 0$，则仅需输出最大结果。\n\n接下来 $n$ 行，每行包含 $m$ 个字符，描述场地格子的颜色及初始是否有机器人。颜色由一个字母表示移动方向：  \n- **N** 或 **n** 表示北；  \n- **S** 或 **s** 表示南；  \n- **E** 或 **e** 表示东；  \n- **W** 或 **w** 表示西。  \n\n若该格子初始放置了机器人，则对应字母为大写；否则为小写。", "outputFormat": "输出的第一行包含一个整数 $k$ —— 实验中可被激活的机器人最大数量。\n\n如果输入中 $g = 1$，则在接下来的 $k$ 行中，每行输出三个整数 $r, c, t$：  \n- $r$ 表示行号（从北到南，$1 \\le r \\le n$）；  \n- $c$ 表示列号（从西到东，$1 \\le c \\le m$）；  \n- $t$ 表示激活该机器人的时刻（$1 \\le t \\le 10^9$）。\n\n若存在多种可达到最大结果的激活策略，输出任意一种均可。", "hint": "### 样例解释\n\n在第一个示例中，可以通过选择合适的时刻激活任意四个机器人来实现最大结果。例如，位于格子 $(1, 1)$ 和 $(3, 1)$ 的机器人不能同时被激活。由于本测试中 $g = 0$，无需给出具体的激活方案。\n\n在第二个示例中，给出的答案并非唯一。\n\n在第三个示例中，位于格子 $(4, 1)$ 与 $(4, 3)$ 的机器人被激活后，可以在格子 $(4, 2)$ 与 $(4, 3)$ 之间无限次交换位置，而不会发生碰撞。\n\n### 数据范围\n\n| 子任务编号 | 分值 | $n, m$ | $g$ | 其他条件 | 必须通过的子任务 |\n|:----------:|:----:|:------:|:--:|:---------:|:----------------:|\n| 1 | 11 | $1 \\le n, m \\le 10$ | $g = 0$ | 每个格子中初始均有机器人 |  |\n| 2 | 13 | $1 \\le n, m \\le 100$ | $g = 0$ | 每个格子中初始均有机器人 | 1 |\n| 3 | 13 | $1 \\le n, m \\le 100$ | $g = 0$ | 无额外条件 | 1, 2 |\n| 4 | 23 | $1 \\le n, m \\le 100$ | $g = 1$ | 无额外条件 | 1–3 |\n| 5 | 17 | $1 \\le n, m \\le 1000$ | $g = 0$ | 无额外条件 | 1–3 |\n| 6 | 23 | $1 \\le n, m \\le 1000$ | $g = 1$ | 无额外条件 | 1–5 |\n\n翻译由 ChatGPT-5 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROI 2016 Day1] 机器人实验", "background": "**译自 [ROI 2016](http://neerc.ifmo.ru/school/archive/2015-2016.html) Day1 T2.** ***[ Экспериментальная робототехника](http://neerc.ifmo.ru/school/archive/2015-2016/ru-olymp-roi-2016-day1.pdf)***", "description": "鞑靼斯坦的各大学是教育机器人学领域的领先中心。为了推广这一方向，决定向中小学生提出一个有趣的实验——让机器人在有限空间内进行“生存实验”。\n\n实验在一个大小为 $n \\times m$ 的矩形场地上进行。在实验开始时，部分给定的格子中各放置一个尚未激活的机器人。在收到“开始”指令后，计时器启动，并在每秒开始时发出信号。在每次计时器信号发出后（但不超过 $T_{\\max} = 10^9$ 秒），允许激活部分机器人。\n\n场地中的每个格子被涂成四种颜色之一，机器人通过传感器可以识别这些颜色。颜色对应于从当前格子移动到相邻格子的方向——北、南、东或西。在每次计时器信号发出的那一刻，所有已激活的机器人**同时**按照当前所在格子的颜色所指的方向移动到相邻格子。颜色的分布方式保证了：机器人永远不会移动出场地边界之外。\n\n为了避免损坏，禁止以可能导致机器人**碰撞**的方式激活机器人。“碰撞”指的是两台或以上已激活的机器人在同一个时刻出现在同一个格子中。如果发生碰撞，则实验被视为失败。注意：若两个机器人从相邻格子相向移动，并最终互换位置，这**不算作碰撞**。\n\n若所有已激活的机器人能在场地上无限长时间内持续移动而不发生碰撞，则实验视为**成功完成**。实验的结果定义为：**被激活机器人的数量**。\n\n请你编写一个程序，帮助学生根据场地描述及初始放置的机器人位置，确定实验可能达到的最大结果；若有需要，还要指出应当激活哪些机器人以及在什么时刻激活，以达到这一最优结果。", "inputFormat": "第一行包含三个整数 $n$、$m$ 和 $g$，其中：\n\n- $n, m$ —— 场地的行数（从北到南）与列数（从西到东），满足 $1 \\le n, m \\le 1000$；\n- $g$ —— 一个标志变量，取值为 $1$ 或 $0$。若 $g = 1$，则要求输出具体的机器人激活方案；若 $g = 0$，则仅需输出最大结果。\n\n接下来 $n$ 行，每行包含 $m$ 个字符，描述场地格子的颜色及初始是否有机器人。颜色由一个字母表示移动方向：  \n- **N** 或 **n** 表示北；  \n- **S** 或 **s** 表示南；  \n- **E** 或 **e** 表示东；  \n- **W** 或 **w** 表示西。  \n\n若该格子初始放置了机器人，则对应字母为大写；否则为小写。", "outputFormat": "输出的第一行包含一个整数 $k$ —— 实验中可被激活的机器人最大数量。\n\n如果输入中 $g = 1$，则在接下来的 $k$ 行中，每行输出三个整数 $r, c, t$：  \n- $r$ 表示行号（从北到南，$1 \\le r \\le n$）；  \n- $c$ 表示列号（从西到东，$1 \\le c \\le m$）；  \n- $t$ 表示激活该机器人的时刻（$1 \\le t \\le 10^9$）。\n\n若存在多种可达到最大结果的激活策略，输出任意一种均可。", "hint": "### 样例解释\n\n在第一个示例中，可以通过选择合适的时刻激活任意四个机器人来实现最大结果。例如，位于格子 $(1, 1)$ 和 $(3, 1)$ 的机器人不能同时被激活。由于本测试中 $g = 0$，无需给出具体的激活方案。\n\n在第二个示例中，给出的答案并非唯一。\n\n在第三个示例中，位于格子 $(4, 1)$ 与 $(4, 3)$ 的机器人被激活后，可以在格子 $(4, 2)$ 与 $(4, 3)$ 之间无限次交换位置，而不会发生碰撞。\n\n### 数据范围\n\n| 子任务编号 | 分值 | $n, m$ | $g$ | 其他条件 | 必须通过的子任务 |\n|:----------:|:----:|:------:|:--:|:---------:|:----------------:|\n| 1 | 11 | $1 \\le n, m \\le 10$ | $g = 0$ | 每个格子中初始均有机器人 |  |\n| 2 | 13 | $1 \\le n, m \\le 100$ | $g = 0$ | 每个格子中初始均有机器人 | 1 |\n| 3 | 13 | $1 \\le n, m \\le 100$ | $g = 0$ | 无额外条件 | 1, 2 |\n| 4 | 23 | $1 \\le n, m \\le 100$ | $g = 1$ | 无额外条件 | 1–3 |\n| 5 | 17 | $1 \\le n, m \\le 1000$ | $g = 0$ | 无额外条件 | 1–3 |\n| 6 | 23 | $1 \\le n, m \\le 1000$ | $g = 1$ | 无额外条件 | 1–5 |\n\n翻译由 ChatGPT-5 完成", "locale": "zh-CN"}}}
{"pid": "P14207", "type": "P", "difficulty": 5, "samples": [["3 2 0\n1 5\n2 3\n4 5\n2 2 10\n3 6 5", "50"], ["2 1 100\n6 5\n100 4\n5 100 2000", "9400"], ["3 3 10\n1 1\n10 100\n20 10\n2 1000 1\n11 50 50\n17 50 2", "2441"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "线段树", "树状数组", "ROI（俄罗斯）"], "title": "[ROI 2016 Day1] 捕捞，还是不捕捞？", "background": "**译自 [ROI 2016](http://neerc.ifmo.ru/school/archive/2015-2016.html) Day1 T3.** ***[Ловить или не ловить](http://neerc.ifmo.ru/school/archive/2015-2016/ru-olymp-roi-2016-day1.pdf)***", "description": "在卡马河上从事捕捞作业的渔船老板，决定在今年夏季对他们的业务进行优化。\n\n他们获得了一份季节性捕鱼许可证，允许他们在河道上的 $n$ 个指定点进行捕捞，这些点分别位于距离河口 $x_1, x_2, \\ldots, x_n$ 公里的位置。在第 $i$ 个捕捞点，最多可以捕捞 $a_i$ 吨鱼。\n\n捕获的鱼可以在沿河分布的 $m$ 个批发基地出售，这些基地分别位于距离河口 $y_1, y_2, \\ldots, y_m$ 公里的位置。其中，第 $j$ 个基地在本季最多可以购买 $b_j$ 吨鱼，并且以每吨 $c_j$ 卢布的价格收购。从河口到捕捞点和批发基地的距离均沿着河道方向测量。\n\n渔船从河口出发，并在季末返回河口。在整个季节中，渔船可以任意在河道上向上游或下游航行，并可在任意位置停下进行捕捞或销售。渔船的载重能力足够大，可以运输任意数量的鱼。当渔船从河口向上游$ $行驶（逆流而上）时，每行驶 $1$ 公里需要消耗价值 $p$ 卢布的燃料；当渔船向下游$ $行驶（顺流而下）时，则不消耗燃料。\n\n季末时的利润定义为出售鱼的总收入减去燃料的总花费。请编写一个程序，计算在该季节中可以获得的最大利润。", "inputFormat": "第一行包含三个整数 $n$, $m$, $p$——分别表示捕捞点的数量、批发基地的数量，以及燃料单价。满足约束：$1 \\le n, m \\le 500\\,000$；$0 \\le p \\le 10^9$。\n\n接下来的 $n$ 行中，每行包含两个整数 $x_i, a_i$，表示捕捞点距离河口的距离，以及该点可捕捞的最大鱼量：  \n$$\n0 < x_1 < x_2 < \\ldots < x_n \\le 10^9, \\quad 0 < a_i \\le 10^6.\n$$\n\n接下来的 $m$ 行中，每行包含三个整数 $y_j, b_j, c_j$，表示批发基地距离河口的距离、该基地最多可收购的鱼量以及每吨鱼的收购价：  \n$$\n0 < y_1 < y_2 < \\ldots < y_m \\le 10^9, \\quad 0 < b_j, c_j \\le 10^6.\n$$", "outputFormat": "输出一个整数——即最大可能获得的利润。", "hint": "### 样例解释\n\n在第二个样例中，最优策略如下：\n\n- 船只先逆流航行至距离河口 6 公里的捕捞点，燃料消耗为 $6 \\times 100 = 600$ 卢布，在此捕捞 5 吨鱼。 \n- 然后顺流航行 1 公里，到距离河口 5 公里的批发基地出售所有 5 吨鱼，每吨售价为 2000 卢布。  \n- 最后返回河口。总利润为 $5 \\times 2000 - 600 = 9400$ 卢布。\n\n### 数据范围\n\n| 子任务编号 | 分值 | $n, m$ | 附加条件 | 必须通过的子任务 |\n|:-----------:|:----:|:-------:|:----------:|:----------------:|\n| 1 | 16 | $1 \\le n, m \\le 50\\,000$ | $p = 0$ |  |\n| 2 | 9 | $1 \\le n, m \\le 50\\,000$ | $y_m < x_1$（即所有基地都在所有捕捞点的下游） | 1 |\n| 3 | 16 | $1 \\le n, m \\le 50\\,000$ | $x_n < y_1$（即所有捕捞点都在所有基地的下游） | 1 |\n| 4 | 11 | $1 \\le n, m \\le 1\\,000$ | 无额外条件 |  |\n| 5 | 9 | $1 \\le n, m \\le 6\\,000$ | 无额外条件 | 4 |\n| 6 | 20 | $1 \\le n, m \\le 50\\,000$ | 无额外条件 | 1–5 |\n| 7 | 6 | $1 \\le n, m \\le 200\\,000$ | 无额外条件 | 1–6 |\n| 8 | 7 | $1 \\le n, m \\le 320\\,000$ | 无额外条件 | 1–7 |\n| 9 | 6 | $1 \\le n, m \\le 500\\,000$ | 无额外条件 | 1–8 |\n\n翻译由 ChatGPT-5 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROI 2016 Day1] 捕捞，还是不捕捞？", "background": "**译自 [ROI 2016](http://neerc.ifmo.ru/school/archive/2015-2016.html) Day1 T3.** ***[Ловить или не ловить](http://neerc.ifmo.ru/school/archive/2015-2016/ru-olymp-roi-2016-day1.pdf)***", "description": "在卡马河上从事捕捞作业的渔船老板，决定在今年夏季对他们的业务进行优化。\n\n他们获得了一份季节性捕鱼许可证，允许他们在河道上的 $n$ 个指定点进行捕捞，这些点分别位于距离河口 $x_1, x_2, \\ldots, x_n$ 公里的位置。在第 $i$ 个捕捞点，最多可以捕捞 $a_i$ 吨鱼。\n\n捕获的鱼可以在沿河分布的 $m$ 个批发基地出售，这些基地分别位于距离河口 $y_1, y_2, \\ldots, y_m$ 公里的位置。其中，第 $j$ 个基地在本季最多可以购买 $b_j$ 吨鱼，并且以每吨 $c_j$ 卢布的价格收购。从河口到捕捞点和批发基地的距离均沿着河道方向测量。\n\n渔船从河口出发，并在季末返回河口。在整个季节中，渔船可以任意在河道上向上游或下游航行，并可在任意位置停下进行捕捞或销售。渔船的载重能力足够大，可以运输任意数量的鱼。当渔船从河口向上游$ $行驶（逆流而上）时，每行驶 $1$ 公里需要消耗价值 $p$ 卢布的燃料；当渔船向下游$ $行驶（顺流而下）时，则不消耗燃料。\n\n季末时的利润定义为出售鱼的总收入减去燃料的总花费。请编写一个程序，计算在该季节中可以获得的最大利润。", "inputFormat": "第一行包含三个整数 $n$, $m$, $p$——分别表示捕捞点的数量、批发基地的数量，以及燃料单价。满足约束：$1 \\le n, m \\le 500\\,000$；$0 \\le p \\le 10^9$。\n\n接下来的 $n$ 行中，每行包含两个整数 $x_i, a_i$，表示捕捞点距离河口的距离，以及该点可捕捞的最大鱼量：  \n$$\n0 < x_1 < x_2 < \\ldots < x_n \\le 10^9, \\quad 0 < a_i \\le 10^6.\n$$\n\n接下来的 $m$ 行中，每行包含三个整数 $y_j, b_j, c_j$，表示批发基地距离河口的距离、该基地最多可收购的鱼量以及每吨鱼的收购价：  \n$$\n0 < y_1 < y_2 < \\ldots < y_m \\le 10^9, \\quad 0 < b_j, c_j \\le 10^6.\n$$", "outputFormat": "输出一个整数——即最大可能获得的利润。", "hint": "### 样例解释\n\n在第二个样例中，最优策略如下：\n\n- 船只先逆流航行至距离河口 6 公里的捕捞点，燃料消耗为 $6 \\times 100 = 600$ 卢布，在此捕捞 5 吨鱼。 \n- 然后顺流航行 1 公里，到距离河口 5 公里的批发基地出售所有 5 吨鱼，每吨售价为 2000 卢布。  \n- 最后返回河口。总利润为 $5 \\times 2000 - 600 = 9400$ 卢布。\n\n### 数据范围\n\n| 子任务编号 | 分值 | $n, m$ | 附加条件 | 必须通过的子任务 |\n|:-----------:|:----:|:-------:|:----------:|:----------------:|\n| 1 | 16 | $1 \\le n, m \\le 50\\,000$ | $p = 0$ |  |\n| 2 | 9 | $1 \\le n, m \\le 50\\,000$ | $y_m < x_1$（即所有基地都在所有捕捞点的下游） | 1 |\n| 3 | 16 | $1 \\le n, m \\le 50\\,000$ | $x_n < y_1$（即所有捕捞点都在所有基地的下游） | 1 |\n| 4 | 11 | $1 \\le n, m \\le 1\\,000$ | 无额外条件 |  |\n| 5 | 9 | $1 \\le n, m \\le 6\\,000$ | 无额外条件 | 4 |\n| 6 | 20 | $1 \\le n, m \\le 50\\,000$ | 无额外条件 | 1–5 |\n| 7 | 6 | $1 \\le n, m \\le 200\\,000$ | 无额外条件 | 1–6 |\n| 8 | 7 | $1 \\le n, m \\le 320\\,000$ | 无额外条件 | 1–7 |\n| 9 | 6 | $1 \\le n, m \\le 500\\,000$ | 无额外条件 | 1–8 |\n\n翻译由 ChatGPT-5 完成", "locale": "zh-CN"}}}
{"pid": "P14208", "type": "P", "difficulty": 6, "samples": [["6 1\n3 1\n2 -1\n1 1\n1 -1\n1 1\n2 -1\n5 3", "3 8"], ["5 3\n1 1\n1 -2\n2 0\n2 1\n1 -1\n3 0\n3 5\n3 3", "1 6\n0 7\n0 6"], ["6 4\n1 2\n2 -2\n1 1\n1 -2\n4 1\n1 -1\n1 4\n3 4\n10 4\n7 4", "0 4\n1 9\n4 10\n1 10"], ["8 4\n1 -3\n2 0\n1 1\n2 0\n1 -3\n1 3\n1 2\n1 0\n2 -2\n6 -1\n6 4\n7 -4", "0 6\n4 9\n0 10\n6 9"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "ROI（俄罗斯）"], "title": "[ROI 2016 Day1] 人烟之山", "background": "**译自 [ROI 2016](http://neerc.ifmo.ru/school/archive/2015-2016.html) Day1 T4.** ***[Обитаемые горы](http://neerc.ifmo.ru/school/archive/2015-2016/ru-olymp-roi-2016-day1.pdf)***\n\n改编自 Arkadi Strugatsky 与 Boris Strugatsky 的科幻中篇《人烟之岛》。", "description": "不知名之父国的政$ $府计划在与洪提亚接壤的多山地区修建一座反弹道防御塔。\n\n该地区的一段山脉以一条折线表示，这条折线由 $n$ 个线段组成，依次连接 $n + 1$ 个顶点，这些顶点按 $x$ 坐标递增排列。顶点编号为 $0$ 到 $n$，线段编号为 $1$ 到 $n$，其中第 $i$ 个线段连接编号为 $i - 1$ 与 $i$ 的两个顶点。\n\n顶点编号 $0$ 位于点 $(0, 0)$。第 $i$ 个线段由其在水平轴上的投影长度 $d_i$ 与斜率 $k_i$ 给出。于是，若编号为 $i - 1$ 的顶点坐标为 $(x_{i-1}, y_{i-1})$，则第 $i$ 个顶点的坐标可按如下计算：$(x_{i-1} + d_i, y_{i-1} + k_i \\cdot d_i)$。最后一个顶点的 $y$ 坐标为 $0$，即 $y_n = 0$。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/fw6eac5p.png)\n:::\n\n若点 $A$ $(x_A, y_A)$ 到点 $B$ $(x_B, y_B)$ 的线段上**没有任何一点**位于折线**下方**（严格意义上），则称点 $A$ 从点 $B$ 是**直线可见**的。\n\n塔是一条垂直的非零长度线段，其下端点位于折线上。若塔的上端点处于某位公民的直线可见范围内，则该公民感到安全。\n\n设塔的上端点在 $(x, y)$。考虑两名侦察兵，他们从塔的下端点分别向西（$x$ 坐标减小方向）与向东（$x$ 坐标增大方向）出发。每名侦察兵沿着山脉表面奔跑，直到进一步移动会使塔的上端点离开其直线可见范围，或直到到达山脉的边界为止。\n\n政$ $府准备了 $m$ 种塔的位置方案，每个方案由两个整数 $(u_j, v_j)$ 表示——即塔的上端点坐标。要求编写程序，对每个方案分别确定两名侦察兵能跑到的点的 $x$ 坐标。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$（$1 \\leq n, m \\leq 400\\,000$）——折线的线段数量以及塔的位置方案数量。\n\n随后的输入约束取决于常数 $C$ 的取值，$C$ 可为 $10^4$ 或 $10^9$，具体由子任务决定（见评分表）。\n\n接下来的 $n$ 行中，每行包含两个整数 $d_i, k_i$（$1 \\le d_i \\le C$；$-C \\le k_i \\le C$）——第 $i$ 个线段在水平轴上的投影长度与斜率（$0 = x_0 < x_1 < \\cdots < x_i < \\cdots < x_n \\leq C$；$y_0 = y_n = 0$；$-C \\le y_i \\le C$）。\n\n接下来的 $m$ 行中，每行包含两个整数 $u_j, v_j$（$0 \\leq u_j \\leq C$，$-C \\leq v_j \\leq C$）——第 $j$ 个方案中塔的上端点坐标。", "outputFormat": "输出共 $m$ 行，每行包含两个整数 $l_j$ 与 $r_j$——分别为第 $j$ 个方案中向西和向东奔跑的侦察兵能到达的点的 $x$ 坐标。保证 $l_j$ 与 $r_j$ 都为整数。", "hint": "### 样例解释\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/g19b7mbw.png)\n\n样例 1 示意\n:::\n\n请注意，根据题目中的定义，线段 $(6, 2)$ 与 $(7, 1)$ 之间的所有点均处于塔的上端点的直线可见范围内。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/rg0e5ji2.png)\n\n样例 2 示意\n:::\n\n在该测试中，所有方案的塔的下端点都位于同一点。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/kwoq3rqt.png)\n\n样例 3 示意\n:::\n\n在该测试中，所有方案的塔的上端点都位于同一条水平直线上。请注意，塔的下端点可以位于山脉链的端点处。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/6rt0kqqc.png)\n\n样例 4 示意\n:::\n\n在第四个测试中说明，在不知名之父国，整条山脉链可能完全位于其两端点的高度之下。\n\n### 数据范围\n\n| 子任务编号 | 分值 | $n, m$ | $C$ | 其他限制 | 必须通过的子任务 |\n|:--:|:--:|:--:|:--:|:--:|:--:|\n| 1 | 9 | $1 \\le n, m \\le 100$ | $C = 10^4$ | $k_i = \\pm 1$ |  |\n| 2 | 9 | $1 \\le n, m \\le 100$ | $C = 10^4$ |  | 1 |\n| 3 | 10 | $1 \\le n, m \\le 3000$ | $C = 10^9$ |  | 1, 2 |\n| 4 | 11 | $1 \\le n, m \\le 100\\,000$ | $C = 10^9$ | $k_i = \\pm 1$ | 1 |\n| 5 | 11 | $1 \\le n, m \\le 100\\,000$ | $C = 10^9$ | 所有塔的下端点重合 |  |\n| 6 | 12 | $1 \\le n, m \\le 100\\,000$ | $C = 10^9$ | 所有塔的上端点共线于同一条水平直线上 |  |\n| 7 | 21 | $1 \\le n, m \\le 100\\,000$ | $C = 10^9$ |  | 1–6 |\n| 8 | 17 | $1 \\le n, m \\le 400\\,000$ | $C = 10^9$ |  | 1–7 |\n\n翻译由 ChatGPT-5 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROI 2016 Day1] 人烟之山", "background": "**译自 [ROI 2016](http://neerc.ifmo.ru/school/archive/2015-2016.html) Day1 T4.** ***[Обитаемые горы](http://neerc.ifmo.ru/school/archive/2015-2016/ru-olymp-roi-2016-day1.pdf)***\n\n改编自 Arkadi Strugatsky 与 Boris Strugatsky 的科幻中篇《人烟之岛》。", "description": "不知名之父国的政$ $府计划在与洪提亚接壤的多山地区修建一座反弹道防御塔。\n\n该地区的一段山脉以一条折线表示，这条折线由 $n$ 个线段组成，依次连接 $n + 1$ 个顶点，这些顶点按 $x$ 坐标递增排列。顶点编号为 $0$ 到 $n$，线段编号为 $1$ 到 $n$，其中第 $i$ 个线段连接编号为 $i - 1$ 与 $i$ 的两个顶点。\n\n顶点编号 $0$ 位于点 $(0, 0)$。第 $i$ 个线段由其在水平轴上的投影长度 $d_i$ 与斜率 $k_i$ 给出。于是，若编号为 $i - 1$ 的顶点坐标为 $(x_{i-1}, y_{i-1})$，则第 $i$ 个顶点的坐标可按如下计算：$(x_{i-1} + d_i, y_{i-1} + k_i \\cdot d_i)$。最后一个顶点的 $y$ 坐标为 $0$，即 $y_n = 0$。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/fw6eac5p.png)\n:::\n\n若点 $A$ $(x_A, y_A)$ 到点 $B$ $(x_B, y_B)$ 的线段上**没有任何一点**位于折线**下方**（严格意义上），则称点 $A$ 从点 $B$ 是**直线可见**的。\n\n塔是一条垂直的非零长度线段，其下端点位于折线上。若塔的上端点处于某位公民的直线可见范围内，则该公民感到安全。\n\n设塔的上端点在 $(x, y)$。考虑两名侦察兵，他们从塔的下端点分别向西（$x$ 坐标减小方向）与向东（$x$ 坐标增大方向）出发。每名侦察兵沿着山脉表面奔跑，直到进一步移动会使塔的上端点离开其直线可见范围，或直到到达山脉的边界为止。\n\n政$ $府准备了 $m$ 种塔的位置方案，每个方案由两个整数 $(u_j, v_j)$ 表示——即塔的上端点坐标。要求编写程序，对每个方案分别确定两名侦察兵能跑到的点的 $x$ 坐标。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$（$1 \\leq n, m \\leq 400\\,000$）——折线的线段数量以及塔的位置方案数量。\n\n随后的输入约束取决于常数 $C$ 的取值，$C$ 可为 $10^4$ 或 $10^9$，具体由子任务决定（见评分表）。\n\n接下来的 $n$ 行中，每行包含两个整数 $d_i, k_i$（$1 \\le d_i \\le C$；$-C \\le k_i \\le C$）——第 $i$ 个线段在水平轴上的投影长度与斜率（$0 = x_0 < x_1 < \\cdots < x_i < \\cdots < x_n \\leq C$；$y_0 = y_n = 0$；$-C \\le y_i \\le C$）。\n\n接下来的 $m$ 行中，每行包含两个整数 $u_j, v_j$（$0 \\leq u_j \\leq C$，$-C \\leq v_j \\leq C$）——第 $j$ 个方案中塔的上端点坐标。", "outputFormat": "输出共 $m$ 行，每行包含两个整数 $l_j$ 与 $r_j$——分别为第 $j$ 个方案中向西和向东奔跑的侦察兵能到达的点的 $x$ 坐标。保证 $l_j$ 与 $r_j$ 都为整数。", "hint": "### 样例解释\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/g19b7mbw.png)\n\n样例 1 示意\n:::\n\n请注意，根据题目中的定义，线段 $(6, 2)$ 与 $(7, 1)$ 之间的所有点均处于塔的上端点的直线可见范围内。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/rg0e5ji2.png)\n\n样例 2 示意\n:::\n\n在该测试中，所有方案的塔的下端点都位于同一点。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/kwoq3rqt.png)\n\n样例 3 示意\n:::\n\n在该测试中，所有方案的塔的上端点都位于同一条水平直线上。请注意，塔的下端点可以位于山脉链的端点处。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/6rt0kqqc.png)\n\n样例 4 示意\n:::\n\n在第四个测试中说明，在不知名之父国，整条山脉链可能完全位于其两端点的高度之下。\n\n### 数据范围\n\n| 子任务编号 | 分值 | $n, m$ | $C$ | 其他限制 | 必须通过的子任务 |\n|:--:|:--:|:--:|:--:|:--:|:--:|\n| 1 | 9 | $1 \\le n, m \\le 100$ | $C = 10^4$ | $k_i = \\pm 1$ |  |\n| 2 | 9 | $1 \\le n, m \\le 100$ | $C = 10^4$ |  | 1 |\n| 3 | 10 | $1 \\le n, m \\le 3000$ | $C = 10^9$ |  | 1, 2 |\n| 4 | 11 | $1 \\le n, m \\le 100\\,000$ | $C = 10^9$ | $k_i = \\pm 1$ | 1 |\n| 5 | 11 | $1 \\le n, m \\le 100\\,000$ | $C = 10^9$ | 所有塔的下端点重合 |  |\n| 6 | 12 | $1 \\le n, m \\le 100\\,000$ | $C = 10^9$ | 所有塔的上端点共线于同一条水平直线上 |  |\n| 7 | 21 | $1 \\le n, m \\le 100\\,000$ | $C = 10^9$ |  | 1–6 |\n| 8 | 17 | $1 \\le n, m \\le 400\\,000$ | $C = 10^9$ |  | 1–7 |\n\n翻译由 ChatGPT-5 完成", "locale": "zh-CN"}}}
{"pid": "P14209", "type": "P", "difficulty": 3, "samples": [["2 4\n1221\n1221", "2"], ["3 2\n22\n22\n22", "2"], ["3 3\n111\n121\n111", "3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "ROI（俄罗斯）"], "title": "[ROI 2016 Day2] 视频监控管理", "background": "**译自 [ROI 2016](http://neerc.ifmo.ru/school/archive/2015-2016.html) Day2 T1.** ***[Управление видеонаблюдением](http://neerc.ifmo.ru/school/archive/2015-2016/ru-olymp-roi-2016-day2.pdf)***", "description": "一家安保公司接到合同，负责守卫两栋建筑。每栋建筑中都安装了多台视频监控摄像机。\n\n安保室的一面墙上安装了一块矩形监控屏墙，由 $n$ 行组成，每行有 $m$ 个视频监视器。每个监视器显示的是来自两栋建筑之一的某个摄像头的画面。安保室配备了一个创新型控制面板，上面有四个按钮：“左移”、“右移”、“上移”和“下移”。\n\n按下“左移”按钮时，每个监视器上的画面会移动到其左侧相邻的监视器上；而每行中最左侧监视器上的画面会移动到该行最右侧的监视器上。\n\n类似地，“右移”、“上移”和“下移”按钮的功能如下：  \n- “右移”：每个监视器上的画面移动到其右侧相邻的监视器上；每行最右侧监视器上的画面会移动到该行最左侧的监视器上。  \n- “上移”：每个监视器上的画面移动到其上方的监视器上；最上方一行的监视器画面会移动到最下方一行的监视器上。  \n- “下移”：每个监视器上的画面移动到其下方的监视器上；最下方一行的监视器画面会移动到最上方一行的监视器上。\n\n若某个 $2 \\times 2$ 的监视器方块中的四个画面全部来自同一栋建筑，则称这个方块是**便于观察的**。通过控制面板上的按钮移动画面，便于观察的方块数量可能会发生变化。同一个监视器可以同时属于多个便于观察的方块。\n\n请你编写一个程序，计算通过操作控制面板所能获得的**便于观察的方块数量的最大值**。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$，分别表示监视器的行数和每行的监视器数量。  \n\n接下来的 $n$ 行描述从上到下的每一行监视器的情况。每一行包含 $m$ 个字符，描述该行从左到右的监视器来源：  \n- 字符 `'1'` 表示该监视器显示的是第一栋建筑的画面；  \n- 字符 `'2'` 表示该监视器显示的是第二栋建筑的画面。", "outputFormat": "输出一个整数——通过移动监视器画面可以获得的**最大便于观察的方块数量**。", "hint": "### 样例解释\n\n在第一个样例中，按下“右移”按钮后，左侧会形成一个由 `'1'` 组成的便于观察的方块，而右侧会形成一个由 `'2'` 组成的便于观察的方块。\n\n在第二个样例中，初始状态下屏幕上已经存在两个便于观察的方块。\n\n在第三个样例中，例如通过依次按下“右移”和“下移”按钮，可以得到三个由 `'1'` 组成的便于观察的方块。\n\n### 数据范围\n\n| 子任务编号 | 分值 | $n, m$ | 必须通过的子任务 |\n|:-----------:|:----:|:------:|:----------------:|\n| 1 | 37 | $2 \\le n, m \\le 50$ |  |\n| 2 | 28 | $2 \\le n, m \\le 300$ | 1 |\n| 3 | 35 | $2 \\le n, m \\le 1000$ | 1–2 |\n\n翻译由 ChatGPT-5 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROI 2016 Day2] 视频监控管理", "background": "**译自 [ROI 2016](http://neerc.ifmo.ru/school/archive/2015-2016.html) Day2 T1.** ***[Управление видеонаблюдением](http://neerc.ifmo.ru/school/archive/2015-2016/ru-olymp-roi-2016-day2.pdf)***", "description": "一家安保公司接到合同，负责守卫两栋建筑。每栋建筑中都安装了多台视频监控摄像机。\n\n安保室的一面墙上安装了一块矩形监控屏墙，由 $n$ 行组成，每行有 $m$ 个视频监视器。每个监视器显示的是来自两栋建筑之一的某个摄像头的画面。安保室配备了一个创新型控制面板，上面有四个按钮：“左移”、“右移”、“上移”和“下移”。\n\n按下“左移”按钮时，每个监视器上的画面会移动到其左侧相邻的监视器上；而每行中最左侧监视器上的画面会移动到该行最右侧的监视器上。\n\n类似地，“右移”、“上移”和“下移”按钮的功能如下：  \n- “右移”：每个监视器上的画面移动到其右侧相邻的监视器上；每行最右侧监视器上的画面会移动到该行最左侧的监视器上。  \n- “上移”：每个监视器上的画面移动到其上方的监视器上；最上方一行的监视器画面会移动到最下方一行的监视器上。  \n- “下移”：每个监视器上的画面移动到其下方的监视器上；最下方一行的监视器画面会移动到最上方一行的监视器上。\n\n若某个 $2 \\times 2$ 的监视器方块中的四个画面全部来自同一栋建筑，则称这个方块是**便于观察的**。通过控制面板上的按钮移动画面，便于观察的方块数量可能会发生变化。同一个监视器可以同时属于多个便于观察的方块。\n\n请你编写一个程序，计算通过操作控制面板所能获得的**便于观察的方块数量的最大值**。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$，分别表示监视器的行数和每行的监视器数量。  \n\n接下来的 $n$ 行描述从上到下的每一行监视器的情况。每一行包含 $m$ 个字符，描述该行从左到右的监视器来源：  \n- 字符 `'1'` 表示该监视器显示的是第一栋建筑的画面；  \n- 字符 `'2'` 表示该监视器显示的是第二栋建筑的画面。", "outputFormat": "输出一个整数——通过移动监视器画面可以获得的**最大便于观察的方块数量**。", "hint": "### 样例解释\n\n在第一个样例中，按下“右移”按钮后，左侧会形成一个由 `'1'` 组成的便于观察的方块，而右侧会形成一个由 `'2'` 组成的便于观察的方块。\n\n在第二个样例中，初始状态下屏幕上已经存在两个便于观察的方块。\n\n在第三个样例中，例如通过依次按下“右移”和“下移”按钮，可以得到三个由 `'1'` 组成的便于观察的方块。\n\n### 数据范围\n\n| 子任务编号 | 分值 | $n, m$ | 必须通过的子任务 |\n|:-----------:|:----:|:------:|:----------------:|\n| 1 | 37 | $2 \\le n, m \\le 50$ |  |\n| 2 | 28 | $2 \\le n, m \\le 300$ | 1 |\n| 3 | 35 | $2 \\le n, m \\le 1000$ | 1–2 |\n\n翻译由 ChatGPT-5 完成", "locale": "zh-CN"}}}
{"pid": "P14210", "type": "P", "difficulty": 4, "samples": [["2\n2", "? 1 2\nReady!\n2\n1 2"], ["3\n1\n2", "? 1 2\n? 1 3\nReady!\n2\n1 1 2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "二分", "交互题", "Special Judge", "ROI（俄罗斯）"], "title": "[ROI 2016 Day2] DNA 解码", "background": "**译自 [ROI 2016](http://neerc.ifmo.ru/school/archive/2015-2016.html) Day2 T2.** ***[Расшифровка ДНК](http://neerc.ifmo.ru/school/archive/2015-2016/ru-olymp-roi-2016-day2.pdf)***", "description": "**这是一个交互式题目。**\n\n在鞑靼斯坦共和国境内进行考古发掘时，科学家们发现了一种未知古生物的遗骸，这种动物生活在数百万年前的喀山附近。与所有生物一样，这种生物的 DNA 分子由核苷酸序列组成，但其中不同种类核苷酸的数量可能与现代生物不同。\n\n为了研究这一发现，科学家们制造了一种特殊的仪器，该仪器可以扫描 DNA 分子的核苷酸序列，并计算其中包含的不同种类核苷酸的数量。不幸的是，DNA 分子无法承受超过 $q$ 次扫描操作，之后就会被破坏。\n\n研究人员希望借助该仪器来确定 DNA 中存在的不同核苷酸的数量 $k$，并找出 DNA 中哪些位置含有相同的核苷酸。科学家们想把核苷酸序列用正整数序列表示为 $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le k$)，其中相同的数字表示相同的核苷酸，不同的数字表示不同的核苷酸。\n\n你需要编写一个程序，与测试系统（评测程序）交互，以确定核苷酸的不同种类数量 $k$，以及表示 DNA 核苷酸序列的数列。\n\n### 交互格式\n\n在程序开始时，系统会提供一个整数 $n$——DNA 分子的长度（$1 \\le n \\le 3000$）。对于每个测试，参数 $k$（不同核苷酸的数量，$1 < k \\le n$）和 $q$（最大允许的查询次数）都是固定的。保证给定的 $q$ 足以解决问题。\n\n这些参数不会直接告知你的程序；评测系统在生成数据时会确保 DNA 序列中存在 $k$ 种不同的核苷酸。\n\n如果你的程序进行了超过 $q$ 次查询，则会立即收到测试结果“Wrong Answer”（答案错误）。\n\n为了进行一次查询，你的程序应输出一行形如：\n\n> ? $i$ $j$\n\n其中 $i$ 与 $j$ 为两个正整数，表示要对 DNA 中第 $i$ 个到第 $j$ 个位置（包含两端）的片段进行扫描，系统将返回一个整数 $p$——该片段中不同核苷酸的种类数（$1 \\le i < j \\le n$）。\n\n评测系统会在查询结果所在的一行中输出该整数 $p$ 作为响应。\n\n当程序已经获得足够的信息来恢复整个 DNA 序列时，应输出三行内容：\n\n第一行输出：\n\n> Ready!\n\n第二行包含 $k$，第三行包含 $n$ 个整数 $a_1, a_2, \\ldots, a_n$（$1 \\le a_i \\le k$），表示推断出的核苷酸序列。相同的数字应代表相同的核苷酸，不同的数字代表不同的核苷酸。如果存在多个可能的正确序列，则可以输出任意一个。\n\n之后程序必须正常结束。", "inputFormat": "", "outputFormat": "", "hint": "### 样例解释\n\n在第一个样例中，$n = 2$。只需一次查询就能判断第一个核苷酸和第二个核苷酸是否相同。\n\n在第二个样例中，$n = 3$。第一次查询的结果表明前两个核苷酸相同；第二次查询的结果表明第三个核苷酸与前两个不同。因此有两种可能的正确答案：$1\\ 1\\ 2$ 或 $2\\ 2\\ 1$。\n\n请严格遵守输出格式。每次输出后必须打印一个换行符，并刷新输出缓冲区。为此，在不同编程语言中应使用以下方法：\n\n- 在 Pascal 或 Delphi 中使用 `flush(output)`；\n- 在 C/C++ 中使用 `fflush(stdout)` 或 `cout.flush()`；\n- 在 Python 中使用 `sys.stdout.flush()`；\n- 在 Java 中使用 `System.out.flush()`。\n\n### 数据范围\n\n| 子任务编号 | 分值 | 限制条件 | < | < |必须通过的子任务 |\n|:--:|:--:|:--:|:--:|:--:|:--:|\n|  | | $n$ | $k$ | $q$ |  |\n| 1 | 20 | $1 \\le n \\le 300$ | $1 \\le k \\le 2$ | $q = 72000$ |  |\n| 2 | 25 | $1 \\le n \\le 300$ | $1 \\le k \\le n$ | $q = 72000$ | 1 |\n| 3 | 25 | $1 \\le n \\le 3000$ | $1 \\le k \\le n$ | $q = 72000$ | 1 |\n| 4 | 15 | $1 \\le n \\le 3000$ | $1 \\le k \\le n$ | $q = 72000$ | 1–3 |\n| 5 | 15 | $1 \\le n \\le 3000$ | $1 \\le k \\le n$ | $q = 36000$ | 1–4 |\n\n翻译由 ChatGPT-5 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROI 2016 Day2] DNA 解码", "background": "**译自 [ROI 2016](http://neerc.ifmo.ru/school/archive/2015-2016.html) Day2 T2.** ***[Расшифровка ДНК](http://neerc.ifmo.ru/school/archive/2015-2016/ru-olymp-roi-2016-day2.pdf)***", "description": "**这是一个交互式题目。**\n\n在鞑靼斯坦共和国境内进行考古发掘时，科学家们发现了一种未知古生物的遗骸，这种动物生活在数百万年前的喀山附近。与所有生物一样，这种生物的 DNA 分子由核苷酸序列组成，但其中不同种类核苷酸的数量可能与现代生物不同。\n\n为了研究这一发现，科学家们制造了一种特殊的仪器，该仪器可以扫描 DNA 分子的核苷酸序列，并计算其中包含的不同种类核苷酸的数量。不幸的是，DNA 分子无法承受超过 $q$ 次扫描操作，之后就会被破坏。\n\n研究人员希望借助该仪器来确定 DNA 中存在的不同核苷酸的数量 $k$，并找出 DNA 中哪些位置含有相同的核苷酸。科学家们想把核苷酸序列用正整数序列表示为 $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le k$)，其中相同的数字表示相同的核苷酸，不同的数字表示不同的核苷酸。\n\n你需要编写一个程序，与测试系统（评测程序）交互，以确定核苷酸的不同种类数量 $k$，以及表示 DNA 核苷酸序列的数列。\n\n### 交互格式\n\n在程序开始时，系统会提供一个整数 $n$——DNA 分子的长度（$1 \\le n \\le 3000$）。对于每个测试，参数 $k$（不同核苷酸的数量，$1 < k \\le n$）和 $q$（最大允许的查询次数）都是固定的。保证给定的 $q$ 足以解决问题。\n\n这些参数不会直接告知你的程序；评测系统在生成数据时会确保 DNA 序列中存在 $k$ 种不同的核苷酸。\n\n如果你的程序进行了超过 $q$ 次查询，则会立即收到测试结果“Wrong Answer”（答案错误）。\n\n为了进行一次查询，你的程序应输出一行形如：\n\n> ? $i$ $j$\n\n其中 $i$ 与 $j$ 为两个正整数，表示要对 DNA 中第 $i$ 个到第 $j$ 个位置（包含两端）的片段进行扫描，系统将返回一个整数 $p$——该片段中不同核苷酸的种类数（$1 \\le i < j \\le n$）。\n\n评测系统会在查询结果所在的一行中输出该整数 $p$ 作为响应。\n\n当程序已经获得足够的信息来恢复整个 DNA 序列时，应输出三行内容：\n\n第一行输出：\n\n> Ready!\n\n第二行包含 $k$，第三行包含 $n$ 个整数 $a_1, a_2, \\ldots, a_n$（$1 \\le a_i \\le k$），表示推断出的核苷酸序列。相同的数字应代表相同的核苷酸，不同的数字代表不同的核苷酸。如果存在多个可能的正确序列，则可以输出任意一个。\n\n之后程序必须正常结束。", "inputFormat": "", "outputFormat": "", "hint": "### 样例解释\n\n在第一个样例中，$n = 2$。只需一次查询就能判断第一个核苷酸和第二个核苷酸是否相同。\n\n在第二个样例中，$n = 3$。第一次查询的结果表明前两个核苷酸相同；第二次查询的结果表明第三个核苷酸与前两个不同。因此有两种可能的正确答案：$1\\ 1\\ 2$ 或 $2\\ 2\\ 1$。\n\n请严格遵守输出格式。每次输出后必须打印一个换行符，并刷新输出缓冲区。为此，在不同编程语言中应使用以下方法：\n\n- 在 Pascal 或 Delphi 中使用 `flush(output)`；\n- 在 C/C++ 中使用 `fflush(stdout)` 或 `cout.flush()`；\n- 在 Python 中使用 `sys.stdout.flush()`；\n- 在 Java 中使用 `System.out.flush()`。\n\n### 数据范围\n\n| 子任务编号 | 分值 | 限制条件 | < | < |必须通过的子任务 |\n|:--:|:--:|:--:|:--:|:--:|:--:|\n|  | | $n$ | $k$ | $q$ |  |\n| 1 | 20 | $1 \\le n \\le 300$ | $1 \\le k \\le 2$ | $q = 72000$ |  |\n| 2 | 25 | $1 \\le n \\le 300$ | $1 \\le k \\le n$ | $q = 72000$ | 1 |\n| 3 | 25 | $1 \\le n \\le 3000$ | $1 \\le k \\le n$ | $q = 72000$ | 1 |\n| 4 | 15 | $1 \\le n \\le 3000$ | $1 \\le k \\le n$ | $q = 72000$ | 1–3 |\n| 5 | 15 | $1 \\le n \\le 3000$ | $1 \\le k \\le n$ | $q = 36000$ | 1–4 |\n\n翻译由 ChatGPT-5 完成", "locale": "zh-CN"}}}
{"pid": "P14211", "type": "P", "difficulty": 6, "samples": [["4 2\n1 2 2\n1 3\n1 4", "1\n2 1"], ["4 2\n1 2 3\n1 2\n3 4", "0\n1 2"], ["7 3\n1 2 2 4 5 5\n1 3\n3 7\n6 1", "2\n2 3"], ["4 3\n1 2 3\n1 4\n4 1\n1 4", "3\n2 1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "树上启发式合并", "Special Judge", "最近公共祖先 LCA", "ROI（俄罗斯）"], "title": "[ROI 2016 Day2] 快递服务", "background": "**译自 [ROI 2016](http://neerc.ifmo.ru/school/archive/2015-2016.html) Day2 T3.** ***[Курьерская служба](http://neerc.ifmo.ru/school/archive/2015-2016/ru-olymp-roi-2016-day2.pdf)***", "description": "在一家公司里有 $n$ 名员工，其中一人是董事。除了董事以外，每位员工都恰好有一位直属上级。\n\n每位员工都有自己明确的工作职责。如果员工 $a$ 需要完成员工 $b$ 的工作，就必须向员工 $b$ 发送申请。根据公司制度，申请只能在员工与其直属上级之间直接传递：要么由员工传给直属上级，要么由上级传给直属下属。申请会在员工之间逐级传递，直到抵达员工 $b$。\n\n为了减轻员工负担，公司雇佣了 $k$ 名快递员。第 $i$ 位快递员专门负责在员工 $a_i$ 与 $b_i$ 之间传递申请。当这两人中的一方需要将申请传递给另一方时，他会将申请交给快递员。快递员会按照公司制度依次传递申请，经过所有必要的中间员工，最终将其送达目标。在传递一份申请的过程中，快递员不会重复访问同一名员工。\n\n为了优化开支，公司决定找到一对路径重合度最高的快递员，解雇其中一人，并将其工作交由另一人承担。我们定义快递员对的**重合度**为：这两名快递员路径中共同包含的“员工与其直属上级之间的双向通路”的数量。\n\n请编写一个程序，找出重合度最大的两名快递员。", "inputFormat": "第一行包含两个整数 $n$ 和 $k$，分别表示员工人数与快递员人数（$2 \\le n, k \\le 2 \\cdot 10^5$）。员工编号为 $1$ 到 $n$，董事编号为 $1$。\n\n第二行包含 $n-1$ 个整数：$p_2, p_3, \\ldots, p_n$，表示除董事外每位员工的直属上级编号（$1 \\le p_i < i$）。\n\n接下来 $k$ 行，每行包含两个整数 $a_i$ 和 $b_i$，表示第 $i$ 位快递员负责的员工对（$1 \\le a_i, b_i \\le n$，且 $a_i \\ne b_i$）。可能有多个快递员负责同一对员工。", "outputFormat": "第一行输出一个整数——两名快递员的最大重合度。  \n\n第二行输出两个不同的整数，范围为 $1$ 到 $k$，表示一对重合度最大的快递员编号。如果存在多组最优答案，输出任意一组即可。", "hint": "### 样例解释\n\n在第一个样例中，有两名快递员：  \n- 第 1 名快递员负责在员工 1 与 3 之间传递申请。例如，从 1 传给 3 的过程中，申请先从 1 到 2，再从 2 到 3。  \n- 第 2 名快递员负责在员工 1 与 4 之间传递申请。例如，从 4 传给 1 的过程中，申请先从 4 到 2，再从 2 到 1。  \n\n两人路径的重合度为 1，因为他们都经过了员工 1（董事）与员工 2 之间的通路。\n\n在第二个样例中，两名快递员的路径没有交集，因此重合度为 0。\n\n在第三个样例中（见图示）：  \n- 第一名快递员路径为员工 1 → 3；  \n- 第二名快递员路径为员工 3 → 7；  \n- 第三名快递员路径为员工 6 → 1。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/eoxprxz4.png)\n:::\n\n其中：  \n- 第 1 与第 2 名快递员的路径重合在边 (2,3)；  \n- 第 1 与第 3 名快递员的路径重合在边 (1,2)；  \n- 第 2 与第 3 名快递员的路径重合在边 (2,4) 与 (4,5)。  \n\n因此，第 2 与第 3 名快递员的重合度最大，为 2。\n\n在第四个样例中，所有快递员都传递申请于董事与员工 4 之间，因此任意一对快递员的重合度均为 3。可输出任意一对。\n\n### 数据范围\n\n| 子任务编号 | 分值 | $n$ | $k$ | 附加限制 | 必须通过的子任务 |\n|:--:|:--:|:--:|:--:|:--:|:--:|\n| 1 | 29 | $2 \\le n \\le 100$ | $2 \\le k \\le 100$ | --- |  |\n| 2 | 12 | $2 \\le n \\le 4000$ | $2 \\le k \\le 1000$ | --- | 1 |\n| 3 | 7  | $2 \\le n \\le 10^5$ | $2 \\le k \\le 1000$ | --- | 1–2 |\n| 4 | 8  | $2 \\le n \\le 10^5$ | $2 \\le k \\le 5000$ | --- | 1–3 |\n| 5 | 10 | $2 \\le n \\le 10^5$ | $2 \\le k \\le 50\\,000$ | 任意员工到董事的路径长度不超过 20 |  |\n| 6 | 12 | $2 \\le n \\le 10^5$ | $2 \\le k \\le 50\\,000$ | 每位快递员都是重要快递员 |  |\n| 7 | 12 | $2 \\le n \\le 10^5$ | $2 \\le k \\le 50\\,000$ | --- | 1–6 |\n| 8 | 10 | $2 \\le n \\le 2 \\cdot 10^5$ | $2 \\le k \\le 2 \\cdot 10^5$ | --- | 1–7 |\n\n翻译由 ChatGPT-5 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROI 2016 Day2] 快递服务", "background": "**译自 [ROI 2016](http://neerc.ifmo.ru/school/archive/2015-2016.html) Day2 T3.** ***[Курьерская служба](http://neerc.ifmo.ru/school/archive/2015-2016/ru-olymp-roi-2016-day2.pdf)***", "description": "在一家公司里有 $n$ 名员工，其中一人是董事。除了董事以外，每位员工都恰好有一位直属上级。\n\n每位员工都有自己明确的工作职责。如果员工 $a$ 需要完成员工 $b$ 的工作，就必须向员工 $b$ 发送申请。根据公司制度，申请只能在员工与其直属上级之间直接传递：要么由员工传给直属上级，要么由上级传给直属下属。申请会在员工之间逐级传递，直到抵达员工 $b$。\n\n为了减轻员工负担，公司雇佣了 $k$ 名快递员。第 $i$ 位快递员专门负责在员工 $a_i$ 与 $b_i$ 之间传递申请。当这两人中的一方需要将申请传递给另一方时，他会将申请交给快递员。快递员会按照公司制度依次传递申请，经过所有必要的中间员工，最终将其送达目标。在传递一份申请的过程中，快递员不会重复访问同一名员工。\n\n为了优化开支，公司决定找到一对路径重合度最高的快递员，解雇其中一人，并将其工作交由另一人承担。我们定义快递员对的**重合度**为：这两名快递员路径中共同包含的“员工与其直属上级之间的双向通路”的数量。\n\n请编写一个程序，找出重合度最大的两名快递员。", "inputFormat": "第一行包含两个整数 $n$ 和 $k$，分别表示员工人数与快递员人数（$2 \\le n, k \\le 2 \\cdot 10^5$）。员工编号为 $1$ 到 $n$，董事编号为 $1$。\n\n第二行包含 $n-1$ 个整数：$p_2, p_3, \\ldots, p_n$，表示除董事外每位员工的直属上级编号（$1 \\le p_i < i$）。\n\n接下来 $k$ 行，每行包含两个整数 $a_i$ 和 $b_i$，表示第 $i$ 位快递员负责的员工对（$1 \\le a_i, b_i \\le n$，且 $a_i \\ne b_i$）。可能有多个快递员负责同一对员工。", "outputFormat": "第一行输出一个整数——两名快递员的最大重合度。  \n\n第二行输出两个不同的整数，范围为 $1$ 到 $k$，表示一对重合度最大的快递员编号。如果存在多组最优答案，输出任意一组即可。", "hint": "### 样例解释\n\n在第一个样例中，有两名快递员：  \n- 第 1 名快递员负责在员工 1 与 3 之间传递申请。例如，从 1 传给 3 的过程中，申请先从 1 到 2，再从 2 到 3。  \n- 第 2 名快递员负责在员工 1 与 4 之间传递申请。例如，从 4 传给 1 的过程中，申请先从 4 到 2，再从 2 到 1。  \n\n两人路径的重合度为 1，因为他们都经过了员工 1（董事）与员工 2 之间的通路。\n\n在第二个样例中，两名快递员的路径没有交集，因此重合度为 0。\n\n在第三个样例中（见图示）：  \n- 第一名快递员路径为员工 1 → 3；  \n- 第二名快递员路径为员工 3 → 7；  \n- 第三名快递员路径为员工 6 → 1。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/eoxprxz4.png)\n:::\n\n其中：  \n- 第 1 与第 2 名快递员的路径重合在边 (2,3)；  \n- 第 1 与第 3 名快递员的路径重合在边 (1,2)；  \n- 第 2 与第 3 名快递员的路径重合在边 (2,4) 与 (4,5)。  \n\n因此，第 2 与第 3 名快递员的重合度最大，为 2。\n\n在第四个样例中，所有快递员都传递申请于董事与员工 4 之间，因此任意一对快递员的重合度均为 3。可输出任意一对。\n\n### 数据范围\n\n| 子任务编号 | 分值 | $n$ | $k$ | 附加限制 | 必须通过的子任务 |\n|:--:|:--:|:--:|:--:|:--:|:--:|\n| 1 | 29 | $2 \\le n \\le 100$ | $2 \\le k \\le 100$ | --- |  |\n| 2 | 12 | $2 \\le n \\le 4000$ | $2 \\le k \\le 1000$ | --- | 1 |\n| 3 | 7  | $2 \\le n \\le 10^5$ | $2 \\le k \\le 1000$ | --- | 1–2 |\n| 4 | 8  | $2 \\le n \\le 10^5$ | $2 \\le k \\le 5000$ | --- | 1–3 |\n| 5 | 10 | $2 \\le n \\le 10^5$ | $2 \\le k \\le 50\\,000$ | 任意员工到董事的路径长度不超过 20 |  |\n| 6 | 12 | $2 \\le n \\le 10^5$ | $2 \\le k \\le 50\\,000$ | 每位快递员都是重要快递员 |  |\n| 7 | 12 | $2 \\le n \\le 10^5$ | $2 \\le k \\le 50\\,000$ | --- | 1–6 |\n| 8 | 10 | $2 \\le n \\le 2 \\cdot 10^5$ | $2 \\le k \\le 2 \\cdot 10^5$ | --- | 1–7 |\n\n翻译由 ChatGPT-5 完成", "locale": "zh-CN"}}}
{"pid": "P14212", "type": "P", "difficulty": 7, "samples": [["9 2 8\n000110100\n1 100\n1 11001", "4"], ["9 3 10\n010110101\n3 0101\n10 011\n2 100", "8"], ["3 1 3\n100\n1 101", "-1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "2016", "字典树 Trie", "后缀数组 SA", "根号分治", "ROI（俄罗斯）"], "title": "[ROI 2016 Day2] 二进制输入", "background": "**译自 [ROI 2016](http://neerc.ifmo.ru/school/archive/2015-2016.html) Day2 T4.** ***[Тренажёр «10_2-пальцевый набор»](http://neerc.ifmo.ru/school/archive/2015-2016/ru-olymp-roi-2016-day2.pdf)***", "description": "现代的机器人程序员必须掌握盲打的 $10_2$ 指法，用以输入只由字符 **0** 和 **1** 组成的二进制字符串。在专为已经熟练掌握 $10_2$ 指法的机器人设计的创新训练器中，提出了如下练习。\n\n屏幕上方显示一个由 0 和 1 组成的目标字符串。屏幕下方给出若干对 $(c_i, w_i)$，其中 $w_i$ 是一个二进制单词，$c_i$ 是其**代价**——表示每次在输入目标字符串时使用该单词所需的罚分。\n\n机器人需要将给定的目标字符串输入出来。它可以使用提供的二进制单词的**前缀**或**后缀**，并将它们依次拼接起来。同一个单词可以被使用任意多次。但每次使用该单词的前缀或后缀时，都会获得等于该单词代价 $c_i$ 的罚分。\n\n一个单词的**前缀**是从单词第一个字符开始的连续字符序列，一个单词的**后缀**是以单词最后一个字符结尾的连续字符序列。整个单词既是它的前缀，也是它的后缀。\n\n请编写一个程序，计算在使用所给单词的前缀和后缀拼接出目标字符串时，机器人所能获得的**最小总罚分**。若无法构造出目标字符串，则输出 $-1$。", "inputFormat": "输入的第一行包含三个整数 $m$、$n$ 和 $L$——分别表示目标字符串的长度、可使用的单词数量，以及这些单词长度的总和（$1 \\le m \\le 300\\,000$；$1 \\le n \\le 300\\,000$；$1 \\le L \\le 300\\,000$）。\n\n第二行包含目标字符串，由 $m$ 个字符组成，每个字符为 **0** 或 **1**。\n\n接下来的 $n$ 行中，每行描述一个可使用的二进制单词。首先给出该单词的罚分 $c_i$（$1 \\le c_i \\le 10^9$），然后是一个非空的二进制字符串 $w_i$（仅由 **0** 和 **1** 组成），二者以空格分隔。  \n\n每个单词的长度不超过 $l_{\\max}$，该值在不同子任务中有额外限制。", "outputFormat": "输出一个整数——输入目标字符串所需的最小罚分总和；如果无法通过给定的单词前缀或后缀组合出目标字符串，则输出 $-1$。", "hint": "### 样例解释\n\n在第一个样例中，可以按以下方式获得目标字符串：\n1. 使用第一个单词的后缀（长度为 2）；\n2. 再次使用第一个单词的后缀（长度为 1）；\n3. 使用第二个单词的前缀（长度为 3）；\n4. 最后使用第一个单词的完整形式。  \n\n总罚分为 4。\n\n### 评分说明\n\n下表列出了各子任务中对输入参数的附加限制。其中 $l_{\\text{max}}$ 表示提供给机器人的每个二进制单词的最大长度。\n\n| 子任务编号 | 分值 | $m$ | $n$ | $L$ | $c_i$ | $l_{\\text{max}}$ | 必须通过的子任务 |\n|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|\n| 1 | 20 | $m \\le 50$ | $n \\le 50$ | $L \\le 500$ | $c_i \\le 1000$ | $l_{\\text{max}} \\le 50$ | — |\n| 2 | 10 | $m \\le 5000$ | — | $L \\le 5000$ | — | $l_{\\text{max}} \\le 1000$ | 1 |\n| 3 | 8 | $m \\le 10\\,000$ | — | $L \\le 50\\,000$ | — | $l_{\\text{max}} \\le 1000$ | 1, 2 |\n| 4 | 8 | $m \\le 50\\,000$ | — | $L \\le 50\\,000$ | — | $l_{\\text{max}} \\le 2000$ | 1–3 |\n| 5 | 10 | $m \\le 50\\,000$ | $n \\le 20$ | $L \\le 50\\,000$ | — | — | — |\n| 6 | 5 | $m \\le 50\\,000$ | $n \\le 200$ | $L \\le 50\\,000$ | — | — | 5 |\n| 7 | 9 | $m \\le 50\\,000$ | — | $L \\le 50\\,000$ | $c_i = 1$ | — | — |\n| 8 | 5 | $m \\le 50\\,000$ | — | $L \\le 50\\,000$ | $c_i \\le 10$ | — | 7 |\n| 9 | 5 | $m \\le 50\\,000$ | — | $L \\le 50\\,000$ | $c_i \\le 100$ | — | 7, 8 |\n| 10 | 5 | $m \\le 50\\,000$ | — | $L \\le 50\\,000$ | — | — | 1–9 |\n| 11 | 5 | $m \\le 100\\,000$ | — | $L \\le 100\\,000$ | — | — | 1–10 |\n| 12 | 5 | $m \\le 200\\,000$ | — | $L \\le 200\\,000$ | — | — | 1–11 |\n| 13 | 5 | $m \\le 300\\,000$ | — | $L \\le 300\\,000$ | — | — | 1–12 |\n\n翻译由 ChatGPT-5 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROI 2016 Day2] 二进制输入", "background": "**译自 [ROI 2016](http://neerc.ifmo.ru/school/archive/2015-2016.html) Day2 T4.** ***[Тренажёр «10_2-пальцевый набор»](http://neerc.ifmo.ru/school/archive/2015-2016/ru-olymp-roi-2016-day2.pdf)***", "description": "现代的机器人程序员必须掌握盲打的 $10_2$ 指法，用以输入只由字符 **0** 和 **1** 组成的二进制字符串。在专为已经熟练掌握 $10_2$ 指法的机器人设计的创新训练器中，提出了如下练习。\n\n屏幕上方显示一个由 0 和 1 组成的目标字符串。屏幕下方给出若干对 $(c_i, w_i)$，其中 $w_i$ 是一个二进制单词，$c_i$ 是其**代价**——表示每次在输入目标字符串时使用该单词所需的罚分。\n\n机器人需要将给定的目标字符串输入出来。它可以使用提供的二进制单词的**前缀**或**后缀**，并将它们依次拼接起来。同一个单词可以被使用任意多次。但每次使用该单词的前缀或后缀时，都会获得等于该单词代价 $c_i$ 的罚分。\n\n一个单词的**前缀**是从单词第一个字符开始的连续字符序列，一个单词的**后缀**是以单词最后一个字符结尾的连续字符序列。整个单词既是它的前缀，也是它的后缀。\n\n请编写一个程序，计算在使用所给单词的前缀和后缀拼接出目标字符串时，机器人所能获得的**最小总罚分**。若无法构造出目标字符串，则输出 $-1$。", "inputFormat": "输入的第一行包含三个整数 $m$、$n$ 和 $L$——分别表示目标字符串的长度、可使用的单词数量，以及这些单词长度的总和（$1 \\le m \\le 300\\,000$；$1 \\le n \\le 300\\,000$；$1 \\le L \\le 300\\,000$）。\n\n第二行包含目标字符串，由 $m$ 个字符组成，每个字符为 **0** 或 **1**。\n\n接下来的 $n$ 行中，每行描述一个可使用的二进制单词。首先给出该单词的罚分 $c_i$（$1 \\le c_i \\le 10^9$），然后是一个非空的二进制字符串 $w_i$（仅由 **0** 和 **1** 组成），二者以空格分隔。  \n\n每个单词的长度不超过 $l_{\\max}$，该值在不同子任务中有额外限制。", "outputFormat": "输出一个整数——输入目标字符串所需的最小罚分总和；如果无法通过给定的单词前缀或后缀组合出目标字符串，则输出 $-1$。", "hint": "### 样例解释\n\n在第一个样例中，可以按以下方式获得目标字符串：\n1. 使用第一个单词的后缀（长度为 2）；\n2. 再次使用第一个单词的后缀（长度为 1）；\n3. 使用第二个单词的前缀（长度为 3）；\n4. 最后使用第一个单词的完整形式。  \n\n总罚分为 4。\n\n### 评分说明\n\n下表列出了各子任务中对输入参数的附加限制。其中 $l_{\\text{max}}$ 表示提供给机器人的每个二进制单词的最大长度。\n\n| 子任务编号 | 分值 | $m$ | $n$ | $L$ | $c_i$ | $l_{\\text{max}}$ | 必须通过的子任务 |\n|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|\n| 1 | 20 | $m \\le 50$ | $n \\le 50$ | $L \\le 500$ | $c_i \\le 1000$ | $l_{\\text{max}} \\le 50$ | — |\n| 2 | 10 | $m \\le 5000$ | — | $L \\le 5000$ | — | $l_{\\text{max}} \\le 1000$ | 1 |\n| 3 | 8 | $m \\le 10\\,000$ | — | $L \\le 50\\,000$ | — | $l_{\\text{max}} \\le 1000$ | 1, 2 |\n| 4 | 8 | $m \\le 50\\,000$ | — | $L \\le 50\\,000$ | — | $l_{\\text{max}} \\le 2000$ | 1–3 |\n| 5 | 10 | $m \\le 50\\,000$ | $n \\le 20$ | $L \\le 50\\,000$ | — | — | — |\n| 6 | 5 | $m \\le 50\\,000$ | $n \\le 200$ | $L \\le 50\\,000$ | — | — | 5 |\n| 7 | 9 | $m \\le 50\\,000$ | — | $L \\le 50\\,000$ | $c_i = 1$ | — | — |\n| 8 | 5 | $m \\le 50\\,000$ | — | $L \\le 50\\,000$ | $c_i \\le 10$ | — | 7 |\n| 9 | 5 | $m \\le 50\\,000$ | — | $L \\le 50\\,000$ | $c_i \\le 100$ | — | 7, 8 |\n| 10 | 5 | $m \\le 50\\,000$ | — | $L \\le 50\\,000$ | — | — | 1–9 |\n| 11 | 5 | $m \\le 100\\,000$ | — | $L \\le 100\\,000$ | — | — | 1–10 |\n| 12 | 5 | $m \\le 200\\,000$ | — | $L \\le 200\\,000$ | — | — | 1–11 |\n| 13 | 5 | $m \\le 300\\,000$ | — | $L \\le 300\\,000$ | — | — | 1–12 |\n\n翻译由 ChatGPT-5 完成", "locale": "zh-CN"}}}
{"pid": "P14213", "type": "P", "difficulty": 4, "samples": [["6 \n1 2 \n3 2 \n2 3 \n2 5 \n4 4 \n6 3 \n4 \n2 2 4 4 \n2 2 6 5 \n3 3 5 6 \n5 1 6 6 ", "3 \n4 \n0 \n1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["2010", "二分", "离散化", "COI（克罗地亚）"], "title": "[COI 2010] 橡树 / HRASTOVI", "background": "译自 [COI 2010 T1](https://hsin.hr/hio2010/zadaci/)。", "description": "我们计划在橡树林中修建一条旅游步道。树林可视为一个平面，其中有 $N$ 个点代表橡树。\n\n步道是一个边与坐标轴平行的矩形。如果矩形的边**经过**某棵橡树的坐标，则那棵树必须被砍掉；矩形内部的树不需要砍。\n\n林业部秘书 Ljubo 热爱自然且想选择需要砍树最少的方案，所以他要求旅游部提供 $P$ 个可能的矩形步道方案，并且从中做出选择。  \n\n所以，请你写程序计算处每个矩形步道需要砍掉的树木数量。", "inputFormat": "第一行一个整数 $N$ $(1 \\le N \\le 300\\ 000)$，代表橡树的数目。\n\n接下来 $N$ 行每行两个整数 $X_i, Y_i$ $(1 \\le X_i, Y_i \\le 10^9)$，代表一棵橡树的坐标。每个格点最多只会有一棵树。\n\n接下来一行一个整数 $P$ $(1 \\le P \\le 100\\ 000)$，表示矩形步道的数目。\n\n接下来的 $P$ 行每行四个整数 $X_1, Y_1, X_2, Y_2$ $(1 \\le X_1 < X_2 \\le 10^9, 1 \\le Y_₁ < Y_₂ \\le 10^9)$，表示矩形的左下角和右上角坐标。", "outputFormat": "输出 $P$ 行，一行一个整数，按照顺序表示每一个矩形步道需要砍掉的树木个数。", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/5qnlhcph.png)\n\n对于 $30\\%$ 的数据，有 $1 \\le X_1 < X_2 \\le 10^3, 1\\le Y_1 < Y_2 \\le 10^3$。\n\n对于 $60\\%$ 的数据，有 $1 \\le X_1 < X_2 \\le 10^6, 1\\le Y_1 < Y_2 \\le 10^6$。\n\n对于全部数据，有 $1 \\le X_1 < X_2 \\le 10^9, 1 \\le Y_₁ < Y_₂ \\le 10^9$，$1 \\le N \\le 300\\ 000$，$1 \\le P \\le 100\\ 000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COI 2010] 橡树 / HRASTOVI", "background": "译自 [COI 2010 T1](https://hsin.hr/hio2010/zadaci/)。", "description": "我们计划在橡树林中修建一条旅游步道。树林可视为一个平面，其中有 $N$ 个点代表橡树。\n\n步道是一个边与坐标轴平行的矩形。如果矩形的边**经过**某棵橡树的坐标，则那棵树必须被砍掉；矩形内部的树不需要砍。\n\n林业部秘书 Ljubo 热爱自然且想选择需要砍树最少的方案，所以他要求旅游部提供 $P$ 个可能的矩形步道方案，并且从中做出选择。  \n\n所以，请你写程序计算处每个矩形步道需要砍掉的树木数量。", "inputFormat": "第一行一个整数 $N$ $(1 \\le N \\le 300\\ 000)$，代表橡树的数目。\n\n接下来 $N$ 行每行两个整数 $X_i, Y_i$ $(1 \\le X_i, Y_i \\le 10^9)$，代表一棵橡树的坐标。每个格点最多只会有一棵树。\n\n接下来一行一个整数 $P$ $(1 \\le P \\le 100\\ 000)$，表示矩形步道的数目。\n\n接下来的 $P$ 行每行四个整数 $X_1, Y_1, X_2, Y_2$ $(1 \\le X_1 < X_2 \\le 10^9, 1 \\le Y_₁ < Y_₂ \\le 10^9)$，表示矩形的左下角和右上角坐标。", "outputFormat": "输出 $P$ 行，一行一个整数，按照顺序表示每一个矩形步道需要砍掉的树木个数。", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/5qnlhcph.png)\n\n对于 $30\\%$ 的数据，有 $1 \\le X_1 < X_2 \\le 10^3, 1\\le Y_1 < Y_2 \\le 10^3$。\n\n对于 $60\\%$ 的数据，有 $1 \\le X_1 < X_2 \\le 10^6, 1\\le Y_1 < Y_2 \\le 10^6$。\n\n对于全部数据，有 $1 \\le X_1 < X_2 \\le 10^9, 1 \\le Y_₁ < Y_₂ \\le 10^9$，$1 \\le N \\le 300\\ 000$，$1 \\le P \\le 100\\ 000$。", "locale": "zh-CN"}}}
{"pid": "P14214", "type": "P", "difficulty": 4, "samples": [["5 3 1", "3 5"], ["5 3 2", "5 4"], ["5 4 5", "3 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["模拟", "数学", "2010", "COI（克罗地亚）"], "title": "[COI 2010] 圆圈 / KOLO", "background": "译自 [COI 2010 T2](https://hsin.hr/hio2010/zadaci/)。", "description": "年轻数学家聚会时常玩的一个游戏叫“素数圆圈”。游戏中有编号 $1$ 到 $N$ 的数学家站成一个大圆。\n\n开始游戏前，我们画有 $N−1$ 个圆圈和 $1$ 个正方形，正方形中站的是玩家 $1$，圆圈中站着从玩家 $2$ 开始的其他人，他们逆时针排成大圆，面向中间。\n\n游戏进行 $K$ 轮。在第 $i$ 轮中，方格中的人跳起来说“到我了！”，然后连续 $p_k$ 次与他右边的人交换位置，其中 $p_k$ 是第 $k$ 个素数。\n\n例如 $N=5, K=3$ 时：\n第 $1, 2, 3$ 轮按素数 $2, 3, 5$ 次交换。\n\n第一轮：\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/shxqtnw6.png)\n:::\n\n第二轮：\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/zq6l5uq4.png)\n:::\n\n第三轮：\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/pf17t193.png)\n:::\n\n\n写一个程序，给定 $N, K, A$，输出最后编号为 $A$ 的玩家左右两侧邻居的编号。", "inputFormat": "输入一行包含三个整数 $N,K,A$ $(1 \\le A \\le N)$，代表玩家的个数、轮数，以及指定查询的玩家。", "outputFormat": "输出一行两个整数，表示游戏结束后编号为 $A$ 的玩家右侧和左侧相邻的玩家编号。", "hint": "对于 $25\\%$ 的数据，有 $3 \\le N \\le 1\\ 000, 1 \\le K \\le 1\\ 000$。\n\n对于另外 $25\\%$ 的数据，有 $3 \\le N \\le 1\\ 000, 1 \\le K \\le 50\\ 000$。\n\n对于另外 $25\\%$ 的数据，有 $3 \\le N \\le 50\\ 000, 1 \\le K \\le 50\\ 000$。\n\n对于 $100\\%$ 的数据，有 $3 \\le N \\le 5\\ 000\\ 000, 1 \\le K \\le 500\\ 000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COI 2010] 圆圈 / KOLO", "background": "译自 [COI 2010 T2](https://hsin.hr/hio2010/zadaci/)。", "description": "年轻数学家聚会时常玩的一个游戏叫“素数圆圈”。游戏中有编号 $1$ 到 $N$ 的数学家站成一个大圆。\n\n开始游戏前，我们画有 $N−1$ 个圆圈和 $1$ 个正方形，正方形中站的是玩家 $1$，圆圈中站着从玩家 $2$ 开始的其他人，他们逆时针排成大圆，面向中间。\n\n游戏进行 $K$ 轮。在第 $i$ 轮中，方格中的人跳起来说“到我了！”，然后连续 $p_k$ 次与他右边的人交换位置，其中 $p_k$ 是第 $k$ 个素数。\n\n例如 $N=5, K=3$ 时：\n第 $1, 2, 3$ 轮按素数 $2, 3, 5$ 次交换。\n\n第一轮：\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/shxqtnw6.png)\n:::\n\n第二轮：\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/zq6l5uq4.png)\n:::\n\n第三轮：\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/pf17t193.png)\n:::\n\n\n写一个程序，给定 $N, K, A$，输出最后编号为 $A$ 的玩家左右两侧邻居的编号。", "inputFormat": "输入一行包含三个整数 $N,K,A$ $(1 \\le A \\le N)$，代表玩家的个数、轮数，以及指定查询的玩家。", "outputFormat": "输出一行两个整数，表示游戏结束后编号为 $A$ 的玩家右侧和左侧相邻的玩家编号。", "hint": "对于 $25\\%$ 的数据，有 $3 \\le N \\le 1\\ 000, 1 \\le K \\le 1\\ 000$。\n\n对于另外 $25\\%$ 的数据，有 $3 \\le N \\le 1\\ 000, 1 \\le K \\le 50\\ 000$。\n\n对于另外 $25\\%$ 的数据，有 $3 \\le N \\le 50\\ 000, 1 \\le K \\le 50\\ 000$。\n\n对于 $100\\%$ 的数据，有 $3 \\le N \\le 5\\ 000\\ 000, 1 \\le K \\le 500\\ 000$。", "locale": "zh-CN"}}}
{"pid": "P14215", "type": "P", "difficulty": 4, "samples": [["3\nadam \nkain 1 \nabel 1 ", "64"], ["12 \nanton \nana 1 \nluka 1 \nmia 2 \ntea 3 \njakov 3 \nsemiramida 5 \ndominik 5 \nanamarija 4 \neustahije 4 \nlovro 2 \nlovro 11", "371"]], "limits": {"time": [700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["模拟", "2010", "COI（克罗地亚）"], "title": "[COI 2010] 家族 / LOZA", "background": "译自 [COI 2010 T3](https://hsin.hr/hio2010/zadaci/)。", "description": "南极的科学家发现了一种新生物！他们获取了一个样本到实验室进行繁殖。\n\n他们很快注意到这种生物经常繁殖而且是单亲繁殖的。但每个个体最多繁殖两次，之后就会失去繁殖能力。\n\n实验室中这种生物的个体数量迅速增加，需要绘制一份家谱。\n\n他们打算把家谱画成如下的一棵树：\n\n家谱以字符图形式表示，名字写在用符号 `-`、`|` 和 `o` 组成一个框内。框的上下边的中点用 `+` 标出。如果框的长度是偶数，那么 `+` 会标在两个中间位置的靠左一个。\n\n:::align{center}\n```\no--+--o    o----+----o    o-+--o \n|anton|    |anamarija|    |pero| \no--+--o    o----+----o    o-+--o\n```\n:::\n\n这些框会用一些边连起来。一组边可以将两个或多个盒子的 `+` 符号给连起来，父代的框在子代的上方。框和边都不能互相重叠。\n\n:::align{center}\n```\n+        +              + \n|        |              | \no    o---o---o    o-----o-----o \n|    |       |    |           | \n+    +       +    +           + \n```\n:::\n\n如果一个父代生物只有一个子代，那么我们用最左侧的点到点的边把他们连起来。如果有两个子代，那么我们用有分支的边，**年长的子代生物在左侧，年幼的在右侧**。\n\n分支的边可以在水平方向上无限伸长，但是要保证左右两侧的 `-` 字符是一样多的，但是**不能竖直伸长**。\n\n别着急，你不用把这棵树真的画出来。你只需要求出来最少需要多少个字符就可以画出这样的树。**不计空格**，只计算 `-`、`|`、`+`、`o` 和它们的名字所需要的字符。", "inputFormat": "第一行一个整数 $N$ $(1 \\le N \\le 300\\ 000)$，表示实验室中的生物总数。\n\n生物按照出生的顺序从 $1$ 到 $N$ 编号，最年长的是 $1$，最年幼的是 $N$。\n\n接下来的 $N$ 行按照编号顺序给出了一个生物的信息。每一个生物都有如下两个信息：\n\n- 名字：一个由不超过 $20$ 个小写英文字母组成的字符串。\n- 亲代：一个整数，表示该生物的亲代的编号（第一个生物没有输入这个信息）。", "outputFormat": "一行一个整数，表示最少需要多少个字符可以画下家谱。", "hint": "```\n   o-+--o \n   |adam| \n   o-+--o \n     | \n  o--o--o \n  |     | \no-+--oo-+--o \n|kain||abel| \no-+--oo-+--o\n```\n\n```\n                             o--+--o \n                             |anton| \n                             o--+--o \n                                | \n                   o------------o------------o \n                   |                         | \n                 o-+-o                     o-+--o \n                 |ana|                     |luka| \n                 o-+-o                     o-+--o \n                   |                         | \n           o-------o-------o              o--o--o \n           |               |              |     | \n         o-+-o          o--+--o         o-+-oo--+--o \n         |mia|          |lovro|         |tea||jakov| \n         o-+-o          o--+--o         o-+-oo--+--o \n           |               |              | \n     o-----o-----o         o        o-----o-----o \n     |           |         |        |           | \no----+----o o----+----o o--+--oo----+-----o o---+---o \n|anamarija| |eustahije| |lovro||semiramida| |dominik| \no----+----o o----+----o o--+--oo----+-----o o---+---o\n```\n\n可以数出字符数分别是 $64$ 和 $371$ 个。\n\n对于 $50\\%$ 的数据，有 $N < 300$。\n\n对于 $75\\%$ 的数据，有 $N < 3000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COI 2010] 家族 / LOZA", "background": "译自 [COI 2010 T3](https://hsin.hr/hio2010/zadaci/)。", "description": "南极的科学家发现了一种新生物！他们获取了一个样本到实验室进行繁殖。\n\n他们很快注意到这种生物经常繁殖而且是单亲繁殖的。但每个个体最多繁殖两次，之后就会失去繁殖能力。\n\n实验室中这种生物的个体数量迅速增加，需要绘制一份家谱。\n\n他们打算把家谱画成如下的一棵树：\n\n家谱以字符图形式表示，名字写在用符号 `-`、`|` 和 `o` 组成一个框内。框的上下边的中点用 `+` 标出。如果框的长度是偶数，那么 `+` 会标在两个中间位置的靠左一个。\n\n:::align{center}\n```\no--+--o    o----+----o    o-+--o \n|anton|    |anamarija|    |pero| \no--+--o    o----+----o    o-+--o\n```\n:::\n\n这些框会用一些边连起来。一组边可以将两个或多个盒子的 `+` 符号给连起来，父代的框在子代的上方。框和边都不能互相重叠。\n\n:::align{center}\n```\n+        +              + \n|        |              | \no    o---o---o    o-----o-----o \n|    |       |    |           | \n+    +       +    +           + \n```\n:::\n\n如果一个父代生物只有一个子代，那么我们用最左侧的点到点的边把他们连起来。如果有两个子代，那么我们用有分支的边，**年长的子代生物在左侧，年幼的在右侧**。\n\n分支的边可以在水平方向上无限伸长，但是要保证左右两侧的 `-` 字符是一样多的，但是**不能竖直伸长**。\n\n别着急，你不用把这棵树真的画出来。你只需要求出来最少需要多少个字符就可以画出这样的树。**不计空格**，只计算 `-`、`|`、`+`、`o` 和它们的名字所需要的字符。", "inputFormat": "第一行一个整数 $N$ $(1 \\le N \\le 300\\ 000)$，表示实验室中的生物总数。\n\n生物按照出生的顺序从 $1$ 到 $N$ 编号，最年长的是 $1$，最年幼的是 $N$。\n\n接下来的 $N$ 行按照编号顺序给出了一个生物的信息。每一个生物都有如下两个信息：\n\n- 名字：一个由不超过 $20$ 个小写英文字母组成的字符串。\n- 亲代：一个整数，表示该生物的亲代的编号（第一个生物没有输入这个信息）。", "outputFormat": "一行一个整数，表示最少需要多少个字符可以画下家谱。", "hint": "```\n   o-+--o \n   |adam| \n   o-+--o \n     | \n  o--o--o \n  |     | \no-+--oo-+--o \n|kain||abel| \no-+--oo-+--o\n```\n\n```\n                             o--+--o \n                             |anton| \n                             o--+--o \n                                | \n                   o------------o------------o \n                   |                         | \n                 o-+-o                     o-+--o \n                 |ana|                     |luka| \n                 o-+-o                     o-+--o \n                   |                         | \n           o-------o-------o              o--o--o \n           |               |              |     | \n         o-+-o          o--+--o         o-+-oo--+--o \n         |mia|          |lovro|         |tea||jakov| \n         o-+-o          o--+--o         o-+-oo--+--o \n           |               |              | \n     o-----o-----o         o        o-----o-----o \n     |           |         |        |           | \no----+----o o----+----o o--+--oo----+-----o o---+---o \n|anamarija| |eustahije| |lovro||semiramida| |dominik| \no----+----o o----+----o o--+--oo----+-----o o---+---o\n```\n\n可以数出字符数分别是 $64$ 和 $371$ 个。\n\n对于 $50\\%$ 的数据，有 $N < 300$。\n\n对于 $75\\%$ 的数据，有 $N < 3000$。", "locale": "zh-CN"}}}
{"pid": "P14216", "type": "P", "difficulty": 5, "samples": [["3 3\n###\nx.x\n#.#\n1\n\n2\n\n1\n\n2\n", "\n\n\n\n\n1 R\n\n2 U\n\n2 L\n\n0"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["2010", "交互题", "Special Judge", "Ad-hoc", "COI（克罗地亚）"], "title": "[COI 2010] 机器人 / ROBOTI", "background": "译自 [COI 2010 T4](https://hsin.hr/hio2010/zadaci/)。", "description": "**本题为交互题。**\n\n两个机器人在仓库中迷路了。他们的编号为 $1$ 和 $2$。仓库是一个拥有 $R$ 行 $C$ 列的网格，每个格子可能是障碍或者空地。机器人用广播来遥控，每条广播包含两部分信息：\n\n- `robot`：一个整数 $1$ 或者 $2$，表示我们操纵的机器人。\n- `direction`：一个字符 `U`、`D`、`L` 或者 `R`，代表我们要机器人移动的方向（上、下、左、右）。\n\n如果目的地是一个障碍、另一个机器人、或者在仓库的外面，机器人留在原地什么都不会发生。否则机器人会移动到目的地内。\n\n两个机器人都配备了 GPS 设备，但是由于故障我们只能得知两个机器人之间的**曼哈顿距离**。如果机器人的位置分别是 $(r_1, c_1)$ 和 $(r_2, c_2)$，他们的曼哈顿距离即为 $\\lvert r_1 - r_2 \\rvert + \\lvert c_1 - c_2 \\rvert$。\n\n每一个指令不管结果如何，我们唯一能知道的就是两个机器人的曼哈顿距离。\n\n机器人处于仓库中两个不同的空地上。写一个程序，可以输出一段指令让两个机器人能够分别到达两个特别的出口。\n\n保证仓库内所有的空地是联通的。", "inputFormat": "在与机器人交互前，先有一些输入内容。\n\n第一行两个整数 $R, C$ $(2 \\le R, C \\le 200)$，表示仓库的行数和列数。\n\n接下来 $R$ 行，每行 $C$ 个字符，每一个都是 `.`、`#` 或 `x` 中的一种。`.` 表示空地，`#` 表示障碍，`x` 表示两个出口中的一个。保证一定恰好有两个 `x` 字符。\n\n接下来的一行表示起始的曼哈顿距离。\n\n每当你输出一行指令之后，会有新的一行输入，表示新的曼哈顿距离。", "outputFormat": "当开始交互的时候，每一次你可以向标准输出输出一行指令，形如 `robot direction`。行末需要有一个换行符。每一次输出完之后，你需要刷新缓冲区。而后你将从标准输入得到新的曼哈顿距离。\n\n当你进行完所有的操作之后，输出一行一个字符 `0`，然后**退出你的程序并返回 $0$**。", "hint": "对于 $40\\%$ 的数据，网格中没有障碍。\n\n对于 $80\\%$ 的数据，$R, C \\le 50$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COI 2010] 机器人 / ROBOTI", "background": "译自 [COI 2010 T4](https://hsin.hr/hio2010/zadaci/)。", "description": "**本题为交互题。**\n\n两个机器人在仓库中迷路了。他们的编号为 $1$ 和 $2$。仓库是一个拥有 $R$ 行 $C$ 列的网格，每个格子可能是障碍或者空地。机器人用广播来遥控，每条广播包含两部分信息：\n\n- `robot`：一个整数 $1$ 或者 $2$，表示我们操纵的机器人。\n- `direction`：一个字符 `U`、`D`、`L` 或者 `R`，代表我们要机器人移动的方向（上、下、左、右）。\n\n如果目的地是一个障碍、另一个机器人、或者在仓库的外面，机器人留在原地什么都不会发生。否则机器人会移动到目的地内。\n\n两个机器人都配备了 GPS 设备，但是由于故障我们只能得知两个机器人之间的**曼哈顿距离**。如果机器人的位置分别是 $(r_1, c_1)$ 和 $(r_2, c_2)$，他们的曼哈顿距离即为 $\\lvert r_1 - r_2 \\rvert + \\lvert c_1 - c_2 \\rvert$。\n\n每一个指令不管结果如何，我们唯一能知道的就是两个机器人的曼哈顿距离。\n\n机器人处于仓库中两个不同的空地上。写一个程序，可以输出一段指令让两个机器人能够分别到达两个特别的出口。\n\n保证仓库内所有的空地是联通的。", "inputFormat": "在与机器人交互前，先有一些输入内容。\n\n第一行两个整数 $R, C$ $(2 \\le R, C \\le 200)$，表示仓库的行数和列数。\n\n接下来 $R$ 行，每行 $C$ 个字符，每一个都是 `.`、`#` 或 `x` 中的一种。`.` 表示空地，`#` 表示障碍，`x` 表示两个出口中的一个。保证一定恰好有两个 `x` 字符。\n\n接下来的一行表示起始的曼哈顿距离。\n\n每当你输出一行指令之后，会有新的一行输入，表示新的曼哈顿距离。", "outputFormat": "当开始交互的时候，每一次你可以向标准输出输出一行指令，形如 `robot direction`。行末需要有一个换行符。每一次输出完之后，你需要刷新缓冲区。而后你将从标准输入得到新的曼哈顿距离。\n\n当你进行完所有的操作之后，输出一行一个字符 `0`，然后**退出你的程序并返回 $0$**。", "hint": "对于 $40\\%$ 的数据，网格中没有障碍。\n\n对于 $80\\%$ 的数据，$R, C \\le 50$。", "locale": "zh-CN"}}}
{"pid": "P14217", "type": "P", "difficulty": 3, "samples": [["5\n3 4 5\n5 1 3 -1 -1\n2 -1 5 -1 5\n3 3 -1 -1 4\n2 3 10\n10000 5 0 -1\n1 10 10 10\n2 3 10\n10 1 2 3\n100 4 5 6\n2 3 10\n100 1 2 3\n10 4 5 6\n2 3 10000\n100 -1 -1 -1\n1 -1 -1 -1", "Yes\n1 3 5 4\n0 5 0 5\n3 3 2 4\nNo\nYes\n1 2 3\n4 5 6\nNo\nYes\n2024 5 26\n11 45 14"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "Special Judge", "ICPC", "昆明"], "title": "[ICPC 2024 Kunming I] 两星级竞赛", "background": "", "description": "教育专家们出于某种原因，准备对 $n$ 项竞赛进行评级。专家们已经决定了每项竞赛的评级结果，其中第 $i$ 项竞赛被评为 $s_i$ 星级竞赛。\n\n据说每项竞赛都会依据 $m$ 种属性进行评级，其中第 $i$ 项竞赛的第 $j$ 种属性记为 $p_{i, j}$，每种属性的取值范围从 $0$ 到 $k$（含两端）。一项竞赛的分数是其所有 $m$ 种属性的总和。也就是说，令 $v_i$ 表示第 $i$ 项竞赛的分数，我们有 $v_i = \\sum\\limits_{j=1}^m p_{i, j}$。\n\n如果一项星级更高的赛事有更高的分数，看起来会比较自然。专家们要求，对于任意两项竞赛 $1 \\le i, j \\le n$，若 $s_i > s_j$，则必须有 $v_i > v_j$。不幸的是，专家们忘了采集一些竞赛部分（甚至全部）属性的数据。作为专家们的助手，您被要求填充这些不存在的属性值，使得上述限制条件对任意两项竞赛都成立。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数，对于每组测试数据：\n\n第一行输入三个整数 $n$，$m$ 和 $k$（$2 \\le n \\le 4 \\times 10^5$，$1 \\le m \\le 4 \\times 10^5$，$n \\times m \\le 4 \\times 10^5$，$1 \\le k \\le 10^9$）表示竞赛的数量，每项竞赛有几种属性，以及每种属性取值的上限。\n\n对于接下来 $n$ 行，第 $i$ 行首先输入一个整数 $s_i$（$1 \\le s_i \\le 10^9$）表示第 $i$ 项竞赛被评定的星级。接下来输入 $m$ 个整数 $p_{i, 1}, p_{i, 2}, \\cdots, p_{i, m}$（$-1 \\le p_{i, j} \\le k$）。若 $p_{i, j} = -1$ 则第 $i$ 项竞赛的第 $j$ 种属性值不存在，您需要填充该属性值；否则若 $p_{i, j} \\ge 0$ 则第 $i$ 项竞赛的第 $j$ 种属性值已被给定，您不应该更改它。\n\n保证所有数据 $n \\times m$ 之和不超过 $4 \\times 10^5$。", "outputFormat": "对于每组数据：\n\n如果可以填充所有不存在的属性值并满足限制条件，首先输出一行 $\\texttt{Yes}$。接下来输出 $n$ 行，第 $i$ 行包含 $m$ 个由单个空格分隔的整数 $q_{i, 1}, q_{i, 2}, \\cdots, q_{i, m}$（$0 \\le q_{i, j} \\le k$），表示完成填充之后的第 $i$ 项竞赛的 $m$ 种属性值。若 $p_{i, j} = -1$，那么 $q_{i, j}$ 就是您填充的值；否则若 $p_{i, j} \\ge 0$，那么 $q_{i, j} = p_{i, j}$。如果有多种答案，您可以输出任意一种。\n\n如果无法满足限制条件，仅需输出一行 $\\texttt{No}$。", "hint": "对于第二组样例数据，即使我们将唯一的 $-1$ 填入最大的可能值 $10$，第一项竞赛的分数也只有 $15$ 分，并不大于第二项竞赛的分数 $30$ 分。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 Kunming I] 两星级竞赛", "background": "", "description": "教育专家们出于某种原因，准备对 $n$ 项竞赛进行评级。专家们已经决定了每项竞赛的评级结果，其中第 $i$ 项竞赛被评为 $s_i$ 星级竞赛。\n\n据说每项竞赛都会依据 $m$ 种属性进行评级，其中第 $i$ 项竞赛的第 $j$ 种属性记为 $p_{i, j}$，每种属性的取值范围从 $0$ 到 $k$（含两端）。一项竞赛的分数是其所有 $m$ 种属性的总和。也就是说，令 $v_i$ 表示第 $i$ 项竞赛的分数，我们有 $v_i = \\sum\\limits_{j=1}^m p_{i, j}$。\n\n如果一项星级更高的赛事有更高的分数，看起来会比较自然。专家们要求，对于任意两项竞赛 $1 \\le i, j \\le n$，若 $s_i > s_j$，则必须有 $v_i > v_j$。不幸的是，专家们忘了采集一些竞赛部分（甚至全部）属性的数据。作为专家们的助手，您被要求填充这些不存在的属性值，使得上述限制条件对任意两项竞赛都成立。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数，对于每组测试数据：\n\n第一行输入三个整数 $n$，$m$ 和 $k$（$2 \\le n \\le 4 \\times 10^5$，$1 \\le m \\le 4 \\times 10^5$，$n \\times m \\le 4 \\times 10^5$，$1 \\le k \\le 10^9$）表示竞赛的数量，每项竞赛有几种属性，以及每种属性取值的上限。\n\n对于接下来 $n$ 行，第 $i$ 行首先输入一个整数 $s_i$（$1 \\le s_i \\le 10^9$）表示第 $i$ 项竞赛被评定的星级。接下来输入 $m$ 个整数 $p_{i, 1}, p_{i, 2}, \\cdots, p_{i, m}$（$-1 \\le p_{i, j} \\le k$）。若 $p_{i, j} = -1$ 则第 $i$ 项竞赛的第 $j$ 种属性值不存在，您需要填充该属性值；否则若 $p_{i, j} \\ge 0$ 则第 $i$ 项竞赛的第 $j$ 种属性值已被给定，您不应该更改它。\n\n保证所有数据 $n \\times m$ 之和不超过 $4 \\times 10^5$。", "outputFormat": "对于每组数据：\n\n如果可以填充所有不存在的属性值并满足限制条件，首先输出一行 $\\texttt{Yes}$。接下来输出 $n$ 行，第 $i$ 行包含 $m$ 个由单个空格分隔的整数 $q_{i, 1}, q_{i, 2}, \\cdots, q_{i, m}$（$0 \\le q_{i, j} \\le k$），表示完成填充之后的第 $i$ 项竞赛的 $m$ 种属性值。若 $p_{i, j} = -1$，那么 $q_{i, j}$ 就是您填充的值；否则若 $p_{i, j} \\ge 0$，那么 $q_{i, j} = p_{i, j}$。如果有多种答案，您可以输出任意一种。\n\n如果无法满足限制条件，仅需输出一行 $\\texttt{No}$。", "hint": "对于第二组样例数据，即使我们将唯一的 $-1$ 填入最大的可能值 $10$，第一项竞赛的分数也只有 $15$ 分，并不大于第二项竞赛的分数 $30$ 分。", "locale": "zh-CN"}}}
