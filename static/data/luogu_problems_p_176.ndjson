{"pid": "P4559", "type": "P", "difficulty": 6, "samples": [["5 5\n1 5 7 6 2\n1 5 2\n1 5 3\n1 3 9\n2 4 2\n3 5 5", "5\n4\n17\n9\n3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "线段树", "各省省选", "递归", "江苏", "可持久化线段树"], "title": "[JSOI2018] 列队", "background": "", "description": "作为一名大学生，九条可怜在去年参加了她人生中的最后一次军训。\n\n军训中的一个重要项目是练习列队，为了训练学生，教官给每一个学生分配了一个休息位置。每次训练开始前，所有学生都在各自的休息位置休息，但是当教官发出集合命令后，被点到的学生必须要到指定位置集合。\n\n为了简化问题，我们把休息位置和集合位置抽象成一根数轴。一共有 $n$ 个学生，第 $i$ 个学生的休息位置是 $a_i$。每一次命令，教官会指定一个区间 $[l,r]$ 和集合点 $K$ ，所有编号在 $[l,r]$ 内的学生都必须赶到集合点列队。在列队时，每一个学生需要选择 $[K,K+r-l]$ 中的一个整数坐标站定且不能有任何两个学生选择的坐标相同。学生从坐标 $x$ 跑到坐标 $y$ 需要耗费体力 $\\vert y-x \\vert$ 。\n\n在一天的训练中，教官一共发布了 $m$ 条命令 $(l,r,K)$ ，现在你需要计算对于每一条命令，在所有可能的列队方案中，消耗的体力值总和最小是多少。\n\n以下是对题意的一些补充：\n\n1.    任何两条命令是无关的，即在一条集合命令结束后，所有学生都会回到自己的休息位置，然后教官才会发出下一条命令。\n    \n2.    在集合的时候，可能有编号不在 $[l,r]$ 内的学生处在区间 $[K,K+r-l]$ 中，这时他会自己跑开，且跑动的距离不记在消耗的体力值总和中。\n\n", "inputFormat": "第一行输入两个整数 $n,m$。\n\n第二行 $n$ 个整数 $a_i$ 表示学生的休息位置。保证学生休息的位置两两不同。\n\n接下来 $m$ 行每行三个整数 $l,r,K$ 表示一条命令。\n", "outputFormat": "对于每一条命令输出一行一个整数表示最小的体力值总和。", "hint": "**样例 1 解释**\n\n\n在第一条命令中，五名学生依次跑到 $[2,5,4,6,3]$，则总代价为 $|2-1|+|5-5|+|4-7|+|6-6|+|3-2|=5$。\n    \n在第二条命令中，五名学生依次跑到 $[4,5,7,6,3]$，则总代价为 $|4-1|+|5-5|+|7-7|+|6-6|+|3-2|=4$。\n    \n在第三条命令中，三名学生依次跑到 $[11,10,9]$，则总代价为 $|11-1|+|10-5|+|9-7|=17$。\n    \n在第四条命令中，三名学生依次跑到 $[4,2,3]$，则总代价为 $|4-5|+|2-7|+|3-6|=9$。\n    \n在第五条命令中，三名学生依次跑到 $[7,6,5]$，则总代价为 $|7-7|+|6-6|+|5-2|=3$。\n\n**数据范围**\n\n对于 $10\\%$ 的数据，$n,m \\leq 10$；\n\n对于 $40\\%$ 的数据，$n,m \\leq 10^3$；\n\n对于 $70\\%$ 的数据，$n,m \\leq 10^5$；\n\n对于 $100\\%$ 的数据，$n,m \\leq 5 \\times 10^5,1 \\leq a_i,K \\leq 10^6$。\n\n对于 $100\\%$ 的数据，学生休息的位置两两不同。\n", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2018] Lineup", "background": "", "description": "As a university student, Jiutiao Kelian (pinyin) took part in the last military training of her life last year.\n\nAn important task in the training is practicing lineups. To train the students, the instructor assigns each student a rest position. Before each training session starts, all students rest at their own rest positions. When the instructor gives the gathering command, the selected students must gather at the specified location.\n\nTo simplify the problem, we model the rest positions and meeting positions as a number line. There are $n$ students, and the rest position of the $i$-th student is $a_i$. For each command, the instructor specifies an interval $[l, r]$ and a meeting point $K$. All students whose indices are in $[l, r]$ must rush to the meeting point to line up. During the lineup, each student must choose an integer coordinate in $[K, K + r - l]$ to stand on, and no two students may choose the same coordinate. If a student runs from coordinate $x$ to coordinate $y$, the stamina cost is $\\vert y - x \\vert$.\n\nDuring one day of training, the instructor issues $m$ commands $(l, r, K)$. For each command, you need to compute the minimum possible total stamina cost over all valid lineup assignments.\n\nAdditional clarifications:\n1. Any two commands are independent. That is, after one gathering command ends, all students return to their rest positions before the instructor issues the next command.\n2. During gathering, there may be students whose indices are not in $[l, r]$ but are located within $[K, K + r - l]$. They will move away on their own, and their movement distance is not counted in the total stamina cost.", "inputFormat": "The first line contains two integers $n, m$.\n\nThe second line contains $n$ integers $a_i$ representing the rest positions of the students. All rest positions are pairwise distinct.\n\nEach of the next $m$ lines contains three integers $l, r, K$ describing a command.", "outputFormat": "For each command, output one line with a single integer, the minimum total stamina cost.", "hint": "$\\,\\boldsymbol{\\text{Explanation for Sample 1}}$\n\nIn the first command, the five students run to $[2,5,4,6,3]$ respectively; the total cost is $|2-1|+|5-5|+|4-7|+|6-6|+|3-2|=5$.\n\nIn the second command, the five students run to $[4,5,7,6,3]$ respectively; the total cost is $|4-1|+|5-5|+|7-7|+|6-6|+|3-2|=4$.\n\nIn the third command, the three students run to $[11,10,9]$ respectively; the total cost is $|11-1|+|10-5|+|9-7|=17$.\n\nIn the fourth command, the three students run to $[4,2,3]$ respectively; the total cost is $|4-5|+|2-7|+|3-6|=9$.\n\nIn the fifth command, the three students run to $[7,6,5]$ respectively; the total cost is $|7-7|+|6-6|+|5-2|=3$.\n\n$\\,\\boldsymbol{\\text{Constraints}}$\n\nFor $10\\%$ of the testdata, $n, m \\leq 10$.\n\nFor $40\\%$ of the testdata, $n, m \\leq 10^3$.\n\nFor $70\\%$ of the testdata, $n, m \\leq 10^5$.\n\nFor $100\\%$ of the testdata, $n, m \\leq 5 \\times 10^5$, $1 \\leq a_i, K \\leq 10^6$.\n\nFor $100\\%$ of the testdata, the students’ rest positions are pairwise distinct.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2018] 列队", "background": "", "description": "作为一名大学生，九条可怜在去年参加了她人生中的最后一次军训。\n\n军训中的一个重要项目是练习列队，为了训练学生，教官给每一个学生分配了一个休息位置。每次训练开始前，所有学生都在各自的休息位置休息，但是当教官发出集合命令后，被点到的学生必须要到指定位置集合。\n\n为了简化问题，我们把休息位置和集合位置抽象成一根数轴。一共有 $n$ 个学生，第 $i$ 个学生的休息位置是 $a_i$。每一次命令，教官会指定一个区间 $[l,r]$ 和集合点 $K$ ，所有编号在 $[l,r]$ 内的学生都必须赶到集合点列队。在列队时，每一个学生需要选择 $[K,K+r-l]$ 中的一个整数坐标站定且不能有任何两个学生选择的坐标相同。学生从坐标 $x$ 跑到坐标 $y$ 需要耗费体力 $\\vert y-x \\vert$ 。\n\n在一天的训练中，教官一共发布了 $m$ 条命令 $(l,r,K)$ ，现在你需要计算对于每一条命令，在所有可能的列队方案中，消耗的体力值总和最小是多少。\n\n以下是对题意的一些补充：\n\n1.    任何两条命令是无关的，即在一条集合命令结束后，所有学生都会回到自己的休息位置，然后教官才会发出下一条命令。\n    \n2.    在集合的时候，可能有编号不在 $[l,r]$ 内的学生处在区间 $[K,K+r-l]$ 中，这时他会自己跑开，且跑动的距离不记在消耗的体力值总和中。\n\n", "inputFormat": "第一行输入两个整数 $n,m$。\n\n第二行 $n$ 个整数 $a_i$ 表示学生的休息位置。保证学生休息的位置两两不同。\n\n接下来 $m$ 行每行三个整数 $l,r,K$ 表示一条命令。\n", "outputFormat": "对于每一条命令输出一行一个整数表示最小的体力值总和。", "hint": "**样例 1 解释**\n\n\n在第一条命令中，五名学生依次跑到 $[2,5,4,6,3]$，则总代价为 $|2-1|+|5-5|+|4-7|+|6-6|+|3-2|=5$。\n    \n在第二条命令中，五名学生依次跑到 $[4,5,7,6,3]$，则总代价为 $|4-1|+|5-5|+|7-7|+|6-6|+|3-2|=4$。\n    \n在第三条命令中，三名学生依次跑到 $[11,10,9]$，则总代价为 $|11-1|+|10-5|+|9-7|=17$。\n    \n在第四条命令中，三名学生依次跑到 $[4,2,3]$，则总代价为 $|4-5|+|2-7|+|3-6|=9$。\n    \n在第五条命令中，三名学生依次跑到 $[7,6,5]$，则总代价为 $|7-7|+|6-6|+|5-2|=3$。\n\n**数据范围**\n\n对于 $10\\%$ 的数据，$n,m \\leq 10$；\n\n对于 $40\\%$ 的数据，$n,m \\leq 10^3$；\n\n对于 $70\\%$ 的数据，$n,m \\leq 10^5$；\n\n对于 $100\\%$ 的数据，$n,m \\leq 5 \\times 10^5,1 \\leq a_i,K \\leq 10^6$。\n\n对于 $100\\%$ 的数据，学生休息的位置两两不同。\n", "locale": "zh-CN"}}}
{"pid": "P4560", "type": "P", "difficulty": 5, "samples": [["10 3\n1 3 4 91220\n1 5 9 48623\n2 3 5 39412\n", "0\n0\n0\n39412\n39412\n39412\n48623\n48623\n48623\n48623\n"], ["10 6\n1 1 8 4\n2 4 9 1\n2 3 6 5\n1 0 5 3\n1 2 2 5\n2 6 7 0\n", "3\n4\n5\n4\n3\n3\n0\n0\n1\n0\n"]], "limits": {"time": [3001, 3001, 3001, 3001, 3001, 3001, 3001, 3001, 3001, 3001, 3001, 3001, 3001, 3001, 3001], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2014", "线段树", "IOI"], "title": "[IOI 2014] Wall 砖墙", "background": "原题为交互试题，但在此请提交**完整程序**。", "description": "给定一个长度为 $n$ 且初始值全为 $0$ 的序列。你需要支持以下两种操作：\n\n- Add $L, R, h$：将序列 $[L, R]$ 内所有值小于 $h$ 的元素都赋为 $h$，此时不改变高度大于 $h$ 的元素值\n- Remove $L, R, h$：将序列 $[L, R]$ 内所有值大于 $h$ 的元素都赋为 $h$，此时不改变高度小于 $h$ 的元素值\n\n你需要输出进行 $k$ 次上述操作之后的序列。", "inputFormat": "输入的第一行包含两个正整数 $n, k$，分别表示序列中元素的个数以及操作数量，注意：**序列下标编号为 $0$ ~ $n-1$**。\n\n接下来 $k$ 行每行包含 $4$ 个整数 $t, L, R, h$，若 $t = 1$ 则表明为 Add 操作，若 $t = 2$ 则表明为 Remove 操作。 $L, R, h$ 的含义见题目描述。", "outputFormat": "输出包含 $n$ 行，每行包含 $1$ 个整数。第 $i$ 行的整数表示 $k$ 次操作之后序列中编号为 $i - 1$ 的元素的值。", "hint": "- 子任务#1（8分）：满足 $1 \\leq n \\leq 10 000, 1 \\leq k \\leq 5 000$；\n- 子任务#2（24分）：满足 $1 \\leq n \\leq 100 000, 1 \\leq k \\leq 500 000$，全部增加操作均在全部移除操作之前；\n- 子任务#3（29分）：满足 $1 \\leq n \\leq 100 000, 1 \\leq k \\leq 500 000$；\n- 子任务#4（39分）：满足 $1 \\leq n \\leq 2 000 000, 1 \\leq k \\leq 500 000$。\n\n所有操作的高度 $h$ 满足 $0 \\leq h \\leq 100 000$。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2014] Wall", "background": "The original problem was interactive, but here please submit a complete program.", "description": "You are given a sequence of length $n$ with all initial values equal to $0$. You need to support the following two operations:\n\n- Add $L, R, h$: For all elements in $[L, R]$ that are less than $h$, set them to $h$. Do not change elements whose height is greater than $h$.\n- Remove $L, R, h$: For all elements in $[L, R]$ that are greater than $h$, set them to $h$. Do not change elements whose height is less than $h$.\n\nYou need to output the sequence after performing $k$ operations.", "inputFormat": "The first line contains two positive integers $n, k$, representing the number of elements in the sequence and the number of operations. Note: indices are numbered from $0$ to $n - 1$.\n\nEach of the next $k$ lines contains $4$ integers $t, L, R, h$. If $t = 1$, it denotes an Add operation; if $t = 2$, it denotes a Remove operation. The meanings of $L, R, h$ are as described above.", "outputFormat": "Output $n$ lines. The integer on the $i$-th line is the value of the element with index $i - 1$ after all $k$ operations.", "hint": "- Subtask #1 (8 points): $1 \\leq n \\leq 10\\,000$, $1 \\leq k \\leq 5\\,000$.\n- Subtask #2 (24 points): $1 \\leq n \\leq 100\\,000$, $1 \\leq k \\leq 500\\,000$, all Add operations appear before all Remove operations.\n- Subtask #3 (29 points): $1 \\leq n \\leq 100\\,000$, $1 \\leq k \\leq 500\\,000$.\n- Subtask #4 (39 points): $1 \\leq n \\leq 2\\,000\\,000$, $1 \\leq k \\leq 500\\,000$.\n\nConstraints: For all operations, the height $h$ satisfies $0 \\leq h \\leq 100\\,000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2014] Wall 砖墙", "background": "原题为交互试题，但在此请提交**完整程序**。", "description": "给定一个长度为 $n$ 且初始值全为 $0$ 的序列。你需要支持以下两种操作：\n\n- Add $L, R, h$：将序列 $[L, R]$ 内所有值小于 $h$ 的元素都赋为 $h$，此时不改变高度大于 $h$ 的元素值\n- Remove $L, R, h$：将序列 $[L, R]$ 内所有值大于 $h$ 的元素都赋为 $h$，此时不改变高度小于 $h$ 的元素值\n\n你需要输出进行 $k$ 次上述操作之后的序列。", "inputFormat": "输入的第一行包含两个正整数 $n, k$，分别表示序列中元素的个数以及操作数量，注意：**序列下标编号为 $0$ ~ $n-1$**。\n\n接下来 $k$ 行每行包含 $4$ 个整数 $t, L, R, h$，若 $t = 1$ 则表明为 Add 操作，若 $t = 2$ 则表明为 Remove 操作。 $L, R, h$ 的含义见题目描述。", "outputFormat": "输出包含 $n$ 行，每行包含 $1$ 个整数。第 $i$ 行的整数表示 $k$ 次操作之后序列中编号为 $i - 1$ 的元素的值。", "hint": "- 子任务#1（8分）：满足 $1 \\leq n \\leq 10 000, 1 \\leq k \\leq 5 000$；\n- 子任务#2（24分）：满足 $1 \\leq n \\leq 100 000, 1 \\leq k \\leq 500 000$，全部增加操作均在全部移除操作之前；\n- 子任务#3（29分）：满足 $1 \\leq n \\leq 100 000, 1 \\leq k \\leq 500 000$；\n- 子任务#4（39分）：满足 $1 \\leq n \\leq 2 000 000, 1 \\leq k \\leq 500 000$。\n\n所有操作的高度 $h$ 满足 $0 \\leq h \\leq 100 000$。", "locale": "zh-CN"}}}
{"pid": "P4561", "type": "P", "difficulty": 6, "samples": [["2\n3 3 1 2\n1 3 4\n3 3 5 7\n1 3 4", "180\n720\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "贪心", "2018", "各省省选", "江西", "期望"], "title": "[JXOI2018] 排序问题", "background": "九条可怜是一个热爱思考的女孩子。", "description": "\n\n九条可怜最近正在研究各种排序的性质，她发现了一种很有趣的排序方法： Gobo sort ！\n\nGobo sort 的算法描述大致如下：\n\n- 假设我们要对一个大小为 $n$ 的数列 $a$ 排序。\n- 等概率随机生成一个大小为 $n$ 的排列 $p$ 。\n- 构造一个大小为 $n$ 的数列 $b$ 满足 $b_i=a_{p_i}$ ，检查 $b$ 是否有序，如果 $b$ 已经有序了就结束算法，并返回 $b$ ，不然返回步骤 2。\n\n\n显然这个算法的期望时间复杂度是 $O(n\\times n!)$ 的，但是九条可怜惊奇的发现，利用量子的神奇性质，在量子系统中，可以把这个算法的时间复杂度优化到线性。\n\n九条可怜对这个排序算法进行了进一步研究，她发现如果一个序列满足一些性质，那么 Gobo sort 会很快计算出正确的结果。为了量化这个速度，她定义 Gobo sort 的执行轮数是步骤 2 的执行次数。\n\n于是她就想到了这么一个问题：\n\n现在有一个长度为 $n$ 的序列 $x$ ，九条可怜会在这个序列后面加入 $m$ 个元素，每个元素是 $[l,r]$ 内的正整数。 她希望新的长度为 $n+m$ 的序列执行 Gobo sort 的期望执行轮数尽量的多。她希望得到这个最多的期望轮数。\n\n九条可怜很聪明，她很快就算出了答案，她希望和你核对一下，由于这个期望轮数实在是太大了，于是她只要求你输出对 $998244353$ 取模的结果。", "inputFormat": "第一行输入一个整数 $T$，表示数据组数。\n\n接下来 $2 \\times T$ 行描述了 $T$ 组数据。\n\n每组数据分成两行，第 1 行有四个正整数 $n,m,l,r$ ，表示数列的长度和加入数字的个数和加入数字的范围。\n第 2 行有 $n$ 个正整数，第 $i$ 个表示 $x_i$ 。", "outputFormat": "输出 $T$ 个整数，表示答案。\n", "hint": "###样例解释\n\n对于第一组数据，我们可以添加 $\\{1,2,2\\}$ 到序列的最末尾，使得这个序列变成 `1 3 4 1 2 2` ，那么进行一轮的成功概率是 $\\frac{1}{180}$ ，因此期望需要 $180$ 轮。\n\n对于第二组数据，我们可以添加 $\\{5,6,7\\}$ 到序列的最末尾，使得这个序列变成 `1 3 4 5 6 7` ，那么进行一轮的成功概率是 $\\frac{1}{720}$ ，因此期望需要 $720$ 轮。\n\n### 数据范围\n\n对于 30% 的数据， $T\\leq 10 , n,m,l,r\\leq 8$。  \n对于 50% 的数据， $T\\leq 300,n,m,l,r,a_i\\leq 300$ 。  \n对于 60% 的数据， $\\sum{r-l+1}\\leq 10^7$ 。  \n对于 70% 的数据， $\\sum{n} \\leq 2\\times 10^5$ 。  \n对于 90% 的数据， $m\\leq 2\\times 10^5$。  \n对于 100% 的数据， $T\\leq 10^5,n\\leq 2\\times 10^5,m\\leq 10^7,1\\leq l\\leq r\\leq 10^9$ ， $1\\leq a_i\\leq 10^9,\\sum{n}\\leq 2\\times 10^6$ 。", "locale": "zh-CN", "translations": {"en": {"title": "[JXOI2018] Sorting Problem", "background": "Kujou Karen is a girl who loves thinking.", "description": "Kujou Karen has recently been studying the properties of various sorting algorithms, and she discovered a very interesting sorting method: Gobo sort!\n\nThe algorithm of Gobo sort is roughly as follows:\n- Suppose we want to sort a sequence $a$ of size $n$.\n- Randomly and uniformly generate a permutation $p$ of size $n$.\n- Construct a sequence $b$ of size $n$ such that $b_i = a_{p_i}$, check whether $b$ is sorted. If $b$ is already sorted, end the algorithm and return $b$; otherwise, go back to step 2.\n\nObviously, the expected time complexity of this algorithm is $O(n \\times n!)$. However, to her surprise, by using the magic of quantum mechanics, in a quantum system this algorithm can be optimized to linear time.\n\nKujou Karen studied this sorting algorithm further and found that if a sequence satisfies certain properties, Gobo sort will quickly compute the correct result. To quantify this speed, she defines the number of rounds of Gobo sort as the number of times step 2 is executed.\n\nThen she came up with the following problem:\n\nNow there is a sequence $x$ of length $n$. Kujou Karen will append $m$ elements to the end of this sequence, each element being a positive integer in $[l, r]$. She wants the expected number of rounds for Gobo sort on the new sequence of length $n + m$ to be as large as possible. She wants to obtain this maximum expected number of rounds.\n\nKujou Karen is very smart and quickly computed the answer. She wants to check it with you. Since this expected number is too large, she only asks you to output the result modulo $998244353$.", "inputFormat": "The first line contains an integer $T$, the number of test cases.\n\nThe next $2 \\times T$ lines describe the $T$ test cases.\n\nEach test case consists of two lines. The first line contains four positive integers $n, m, l, r$, representing the length of the sequence, the number of added numbers, and the range of the added numbers. The second line contains $n$ positive integers; the $i$-th is $x_i$.", "outputFormat": "Output $T$ integers, the answers.", "hint": "### Sample Explanation\n\nFor the first test case, we can append $\\{1, 2, 2\\}$ to the end of the sequence, making it `1 3 4 1 2 2`. Then the success probability in one round is $\\frac{1}{180}$, so the expected number of rounds is $180$.\n\nFor the second test case, we can append $\\{5, 6, 7\\}$ to the end of the sequence, making it `1 3 4 5 6 7`. Then the success probability in one round is $\\frac{1}{720}$, so the expected number of rounds is $720$.\n\n### Constraints\n\n- For 30% of the testdata, $T \\leq 10$, $n, m, l, r \\leq 8$.\n- For 50% of the testdata, $T \\leq 300$, $n, m, l, r, a_i \\leq 300$.\n- For 60% of the testdata, $\\sum (r - l + 1) \\leq 10^7$.\n- For 70% of the testdata, $\\sum n \\leq 2 \\times 10^5$.\n- For 90% of the testdata, $m \\leq 2 \\times 10^5$.\n- For 100% of the testdata, $T \\leq 10^5$, $n \\leq 2 \\times 10^5$, $m \\leq 10^7$, $1 \\leq l \\leq r \\leq 10^9$, $1 \\leq a_i \\leq 10^9$, $\\sum n \\leq 2 \\times 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JXOI2018] 排序问题", "background": "九条可怜是一个热爱思考的女孩子。", "description": "\n\n九条可怜最近正在研究各种排序的性质，她发现了一种很有趣的排序方法： Gobo sort ！\n\nGobo sort 的算法描述大致如下：\n\n- 假设我们要对一个大小为 $n$ 的数列 $a$ 排序。\n- 等概率随机生成一个大小为 $n$ 的排列 $p$ 。\n- 构造一个大小为 $n$ 的数列 $b$ 满足 $b_i=a_{p_i}$ ，检查 $b$ 是否有序，如果 $b$ 已经有序了就结束算法，并返回 $b$ ，不然返回步骤 2。\n\n\n显然这个算法的期望时间复杂度是 $O(n\\times n!)$ 的，但是九条可怜惊奇的发现，利用量子的神奇性质，在量子系统中，可以把这个算法的时间复杂度优化到线性。\n\n九条可怜对这个排序算法进行了进一步研究，她发现如果一个序列满足一些性质，那么 Gobo sort 会很快计算出正确的结果。为了量化这个速度，她定义 Gobo sort 的执行轮数是步骤 2 的执行次数。\n\n于是她就想到了这么一个问题：\n\n现在有一个长度为 $n$ 的序列 $x$ ，九条可怜会在这个序列后面加入 $m$ 个元素，每个元素是 $[l,r]$ 内的正整数。 她希望新的长度为 $n+m$ 的序列执行 Gobo sort 的期望执行轮数尽量的多。她希望得到这个最多的期望轮数。\n\n九条可怜很聪明，她很快就算出了答案，她希望和你核对一下，由于这个期望轮数实在是太大了，于是她只要求你输出对 $998244353$ 取模的结果。", "inputFormat": "第一行输入一个整数 $T$，表示数据组数。\n\n接下来 $2 \\times T$ 行描述了 $T$ 组数据。\n\n每组数据分成两行，第 1 行有四个正整数 $n,m,l,r$ ，表示数列的长度和加入数字的个数和加入数字的范围。\n第 2 行有 $n$ 个正整数，第 $i$ 个表示 $x_i$ 。", "outputFormat": "输出 $T$ 个整数，表示答案。\n", "hint": "###样例解释\n\n对于第一组数据，我们可以添加 $\\{1,2,2\\}$ 到序列的最末尾，使得这个序列变成 `1 3 4 1 2 2` ，那么进行一轮的成功概率是 $\\frac{1}{180}$ ，因此期望需要 $180$ 轮。\n\n对于第二组数据，我们可以添加 $\\{5,6,7\\}$ 到序列的最末尾，使得这个序列变成 `1 3 4 5 6 7` ，那么进行一轮的成功概率是 $\\frac{1}{720}$ ，因此期望需要 $720$ 轮。\n\n### 数据范围\n\n对于 30% 的数据， $T\\leq 10 , n,m,l,r\\leq 8$。  \n对于 50% 的数据， $T\\leq 300,n,m,l,r,a_i\\leq 300$ 。  \n对于 60% 的数据， $\\sum{r-l+1}\\leq 10^7$ 。  \n对于 70% 的数据， $\\sum{n} \\leq 2\\times 10^5$ 。  \n对于 90% 的数据， $m\\leq 2\\times 10^5$。  \n对于 100% 的数据， $T\\leq 10^5,n\\leq 2\\times 10^5,m\\leq 10^7,1\\leq l\\leq r\\leq 10^9$ ， $1\\leq a_i\\leq 10^9,\\sum{n}\\leq 2\\times 10^6$ 。", "locale": "zh-CN"}}}
{"pid": "P4562", "type": "P", "difficulty": 5, "samples": [["2 4", "16\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "2018", "各省省选", "江西", "组合数学", "期望"], "title": "[JXOI2018] 游戏", "background": "九条可怜是一个富有的女孩子。", "description": "她长大以后创业了，开了一个公司。 但是管理公司是一个很累人的活，员工们经常背着可怜偷懒，可怜需要时不时对办公室进行检查。\n\n可怜公司有 $n$ 个办公室，办公室编号是 $l$ 到 $l+n-1$ ，可怜会事先制定一个顺序，按照这个顺序依次检查办公室。一开始的时候，所有办公室的员工都在偷懒，当她检查完编号是 $i$ 的办公室时候，这个办公室的员工会认真工作，并且这个办公室的员工通知所有办公室编号是 $i$ 的倍数的办公室，通知他们老板来了，让他们认真工作。因此，可怜检查完第 $i$ 个办公室的时候，所有编号是 $i$ 的倍数(包括 $i$ )的办公室的员工会认真工作。\n\n可怜发现了员工们通风报信的行为，她发现，对于每种不同的顺序 $p$ ，都存在一个最小的 $t(p)$ ，使得可怜按照这个顺序检查完前 $t(p)$ 个办公室之后，所有的办公室都会开始认真工作。她把这个 $t(p)$ 定义为 $p$ 的检查时间。\n\n可怜想知道所有 $t(p)$ 的和。\n\n但是这个结果可能很大，她想知道和对 $10^9+7$ 取模后的结果。", "inputFormat": "第一行输入两个整数 $l,r$ 表示编号范围，题目中的 $n$ 就是 $r-l+1$ 。", "outputFormat": "一个整数，表示所有 $t(p)$ 的和。", "hint": "### 样例解释\n\n考虑所有办公室被检查的相对顺序:\n\n{2 3 4} ,时间是 2 。\n{3 2 4} ,时间是 2 。\n{4 2 3} ,时间是 3 。\n{4 3 2} ,时间是 3 。\n{2 4 3} ,时间是 3 。\n{3 4 2} ,时间是 3 。\n\n和是 $16$ 。\n\n### 数据范围\n\n对于 20% 的数据，$r-l+1\\leq 8$。  \n对于另 10% 的数据，$l=1$。  \n对于另 10% 的数据，$l=2$。  \n对于另 30% 的数据，$l\\leq 200$。  \n对于 100% 的数据，$1\\leq l\\leq r\\leq 10^7$。", "locale": "zh-CN", "translations": {"en": {"title": "[JXOI2018] Game", "background": "Jiutiao Kelian (pinyin) is a wealthy girl.", "description": "After growing up, she started a business and founded a company. However, managing a company is exhausting. Employees often slack off behind Kelian’s back, so she has to inspect the offices from time to time.\n\nKelian’s company has $n$ offices, numbered from $l$ to $l + n - 1$. Kelian will decide an order in advance and inspect the offices one by one according to this order. At the beginning, all employees in all offices are slacking off. When she finishes inspecting the office with number $i$, the employees in that office start to work hard, and they also notify all offices whose numbers are multiples of $i$ to let them know the boss is here and start working. Therefore, after she finishes inspecting office $i$, all offices whose numbers are multiples of $i$ (including $i$ itself) will have their employees working hard.\n\nKelian discovered this behavior of passing along the message. She found that for every different order $p$, there exists a smallest $t(p)$ such that after she finishes inspecting the first $t(p)$ offices according to this order, all offices will have started working hard. She defines this $t(p)$ as the inspection time of $p$.\n\nKelian wants to know the sum of all $t(p)$.\n\nSince the result can be large, she wants the sum modulo $10^9 + 7$.", "inputFormat": "The first line contains two integers $l, r$ indicating the numbering range. In the problem, $n$ is $r - l + 1$.", "outputFormat": "Output a single integer, the sum of all $t(p)$.", "hint": "Sample Explanation\n\nConsider all relative orders in which the offices are inspected:\n\n{2, 3, 4}, the time is 2.  \n{3, 2, 4}, the time is 2.  \n{4, 2, 3}, the time is 3.  \n{4, 3, 2}, the time is 3.  \n{2, 4, 3}, the time is 3.  \n{3, 4, 2}, the time is 3.\n\nThe sum is $16$.\n\nConstraints\n\n- For 20% of the testdata, $r - l + 1 \\leq 8$.\n- For another 10% of the testdata, $l = 1$.\n- For another 10% of the testdata, $l = 2$.\n- For another 30% of the testdata, $l \\leq 200$.\n- For 100% of the testdata, $1 \\leq l \\leq r \\leq 10^7$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JXOI2018] 游戏", "background": "九条可怜是一个富有的女孩子。", "description": "她长大以后创业了，开了一个公司。 但是管理公司是一个很累人的活，员工们经常背着可怜偷懒，可怜需要时不时对办公室进行检查。\n\n可怜公司有 $n$ 个办公室，办公室编号是 $l$ 到 $l+n-1$ ，可怜会事先制定一个顺序，按照这个顺序依次检查办公室。一开始的时候，所有办公室的员工都在偷懒，当她检查完编号是 $i$ 的办公室时候，这个办公室的员工会认真工作，并且这个办公室的员工通知所有办公室编号是 $i$ 的倍数的办公室，通知他们老板来了，让他们认真工作。因此，可怜检查完第 $i$ 个办公室的时候，所有编号是 $i$ 的倍数(包括 $i$ )的办公室的员工会认真工作。\n\n可怜发现了员工们通风报信的行为，她发现，对于每种不同的顺序 $p$ ，都存在一个最小的 $t(p)$ ，使得可怜按照这个顺序检查完前 $t(p)$ 个办公室之后，所有的办公室都会开始认真工作。她把这个 $t(p)$ 定义为 $p$ 的检查时间。\n\n可怜想知道所有 $t(p)$ 的和。\n\n但是这个结果可能很大，她想知道和对 $10^9+7$ 取模后的结果。", "inputFormat": "第一行输入两个整数 $l,r$ 表示编号范围，题目中的 $n$ 就是 $r-l+1$ 。", "outputFormat": "一个整数，表示所有 $t(p)$ 的和。", "hint": "### 样例解释\n\n考虑所有办公室被检查的相对顺序:\n\n{2 3 4} ,时间是 2 。\n{3 2 4} ,时间是 2 。\n{4 2 3} ,时间是 3 。\n{4 3 2} ,时间是 3 。\n{2 4 3} ,时间是 3 。\n{3 4 2} ,时间是 3 。\n\n和是 $16$ 。\n\n### 数据范围\n\n对于 20% 的数据，$r-l+1\\leq 8$。  \n对于另 10% 的数据，$l=1$。  \n对于另 10% 的数据，$l=2$。  \n对于另 30% 的数据，$l\\leq 200$。  \n对于 100% 的数据，$1\\leq l\\leq r\\leq 10^7$。", "locale": "zh-CN"}}}
{"pid": "P4563", "type": "P", "difficulty": 6, "samples": [["3\n2 3 1", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "2018", "各省省选", "区间 DP", "江西"], "title": "[JXOI2018] 守卫", "background": "九条可怜是一个热爱运动的女孩子。", "description": "这一天她去爬山，她的父亲为了她的安全，雇了一些保镖，让他们固定地呆在在山的某些位置，来实时监视九条可怜，从而保护她。\n\n具体来说，一座山可以描述为一条折线，折线的下方是岩石。这条折线有 $n$ 个折点，每个折点上有一个亭子，第 $i$ 个折点的坐标是 $(i,h_i)$ 。九条可怜只可能会在亭子处玩耍，那些保镖也只会在亭子处监视可怜。\n\n由于技术方面的原因，一个保镖只能监视所有他能看得到的，横坐标不超过他所在位置的亭子。我们称一个保镖能看到一个亭子 $p$ ，当且仅当他所在的亭子 $q$ 和 $p$ 的连线不经过任何一块岩石。特别地，如果这条连线恰好经过了除了 $p,q$ 以外的亭子，那么我们认为保镖看不到可怜。\n\n雇佣保镖是一件很费钱的事情，可怜的父亲希望保镖越少越好。\n\n可怜的父亲还希望得到详尽的雇佣保镖的方案，他知道有些亭子可能正在维修，他想对所有的 $1\\leq l\\leq r\\leq n$ 计算：如果事先已知了只有区间 $[l,r]$ 的亭子可以用来玩耍（和监视），那么最少需要多少个保镖，才能让 $[l,r]$ 中的每一个亭子都被监视到。\n\n可怜的父亲已经得到了一个结果，他希望和你核实他的结果是否正确。", "inputFormat": "第一行输入一个整数 $n$ 表示亭子的数目。\n\n接下来一行 $n$ 个整数，第 $i$ 个整数 $h_i$ 表示第 $i$ 个亭子的坐标是 $(i,h_i)$。", "outputFormat": "对所有的 $1\\leq l\\leq r\\leq n$ 计算：如果事先已知了可怜只会在 $[l,r]$ 这个区间的亭子里面玩耍，那么最少需要多少个保镖，才能让 $[l,r]$ 中的每一个亭子都被监视到。由于输出量太大，可怜的父亲只要你输出所有 $[l,r]$ 的答案的异或即可。\n", "hint": "### 样例解释\n\n如果 $r-l+1\\leq 2$，那么答案显然是 $1$。\n\n如果 $l=1$，$r=n$，那么答案是 $2$，需要安排两个保镖在 $(2,3),(3,1)$ 两个位置监视可怜。\n\n### 数据范围与提示\n\n对于 $30\\%$ 的数据，$n\\leq 20$。  \n对于 $70\\%$ 的数据，$n\\leq 500$。  \n对于 $100\\%$ 的数据，$n\\leq 5000$，$1\\leq h_i\\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[JXOI2018] Guards", "background": "Jiutiao Kelian is a girl who loves sports.", "description": "On this day she goes mountain climbing. For her safety, her father hires some bodyguards to stay fixed at certain positions on the mountain to monitor Jiutiao Kelian in real time and thus protect her.\n\nSpecifically, a mountain can be described as a polyline, and the area below the polyline is rock. This polyline has $n$ vertices, and there is a pavilion at each vertex. The $i$-th vertex has coordinates $(i, h_i)$. Jiutiao Kelian can only play at pavilions, and the bodyguards also only monitor at pavilions.\n\nDue to technical reasons, a guard can only monitor all pavilions he can see whose x-coordinate does not exceed his own position. We say a guard can see a pavilion $p$ if and only if the segment connecting his own pavilion $q$ and $p$ does not pass through any rock. In particular, if this segment happens to pass exactly through any pavilion other than $p$ and $q$, then we consider that the guard cannot see Kelian.\n\nHiring guards is expensive, so Kelian’s father wants as few guards as possible.\n\nKelian’s father also wants a detailed hiring plan. He knows some pavilions may be under maintenance. He wants to compute, for all $1 \\le l \\le r \\le n$: if it is known in advance that only the pavilions in the interval $[l, r]$ can be used for playing (and monitoring), what is the minimum number of guards needed so that every pavilion in $[l, r]$ is monitored.\n\nKelian’s father has already obtained a result, and he hopes you can verify whether his result is correct.", "inputFormat": "The first line contains an integer $n$ denoting the number of pavilions.\n\nThe second line contains $n$ integers, where the $i$-th integer $h_i$ means the $i$-th pavilion is at $(i, h_i)$.", "outputFormat": "For all $1 \\le l \\le r \\le n$, compute the minimum number of guards needed if it is known in advance that Kelian will only play at pavilions in $[l, r]$, so that every pavilion in $[l, r]$ is monitored. Since the output would be too large, Kelian’s father only asks you to output the XOR of the answers for all $[l, r]$.", "hint": "Sample Explanation:\n- If $r - l + 1 \\le 2$, the answer is $1$.\n- If $l = 1$, $r = n$, then the answer is $2$, and two guards are needed at $(2,3)$ and $(3,1)$ to monitor Kelian.\n\nConstraints:\n- For $30\\%$ of the testdata, $n \\le 20$.\n- For $70\\%$ of the testdata, $n \\le 500$.\n- For $100\\%$ of the testdata, $n \\le 5000$, $1 \\le h_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JXOI2018] 守卫", "background": "九条可怜是一个热爱运动的女孩子。", "description": "这一天她去爬山，她的父亲为了她的安全，雇了一些保镖，让他们固定地呆在在山的某些位置，来实时监视九条可怜，从而保护她。\n\n具体来说，一座山可以描述为一条折线，折线的下方是岩石。这条折线有 $n$ 个折点，每个折点上有一个亭子，第 $i$ 个折点的坐标是 $(i,h_i)$ 。九条可怜只可能会在亭子处玩耍，那些保镖也只会在亭子处监视可怜。\n\n由于技术方面的原因，一个保镖只能监视所有他能看得到的，横坐标不超过他所在位置的亭子。我们称一个保镖能看到一个亭子 $p$ ，当且仅当他所在的亭子 $q$ 和 $p$ 的连线不经过任何一块岩石。特别地，如果这条连线恰好经过了除了 $p,q$ 以外的亭子，那么我们认为保镖看不到可怜。\n\n雇佣保镖是一件很费钱的事情，可怜的父亲希望保镖越少越好。\n\n可怜的父亲还希望得到详尽的雇佣保镖的方案，他知道有些亭子可能正在维修，他想对所有的 $1\\leq l\\leq r\\leq n$ 计算：如果事先已知了只有区间 $[l,r]$ 的亭子可以用来玩耍（和监视），那么最少需要多少个保镖，才能让 $[l,r]$ 中的每一个亭子都被监视到。\n\n可怜的父亲已经得到了一个结果，他希望和你核实他的结果是否正确。", "inputFormat": "第一行输入一个整数 $n$ 表示亭子的数目。\n\n接下来一行 $n$ 个整数，第 $i$ 个整数 $h_i$ 表示第 $i$ 个亭子的坐标是 $(i,h_i)$。", "outputFormat": "对所有的 $1\\leq l\\leq r\\leq n$ 计算：如果事先已知了可怜只会在 $[l,r]$ 这个区间的亭子里面玩耍，那么最少需要多少个保镖，才能让 $[l,r]$ 中的每一个亭子都被监视到。由于输出量太大，可怜的父亲只要你输出所有 $[l,r]$ 的答案的异或即可。\n", "hint": "### 样例解释\n\n如果 $r-l+1\\leq 2$，那么答案显然是 $1$。\n\n如果 $l=1$，$r=n$，那么答案是 $2$，需要安排两个保镖在 $(2,3),(3,1)$ 两个位置监视可怜。\n\n### 数据范围与提示\n\n对于 $30\\%$ 的数据，$n\\leq 20$。  \n对于 $70\\%$ 的数据，$n\\leq 500$。  \n对于 $100\\%$ 的数据，$n\\leq 5000$，$1\\leq h_i\\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4564", "type": "P", "difficulty": 6, "samples": [["3\n1 2 3\n6\n0 2 1 1\n1 1 2\n0 2 1 1\n0 3 1 1\n1 1 2\n1 3 1 2 3", "1\n0\n499122177 0 499122177\n1 0 2\n"], ["3\n1 1 1\n4\n0 2 1 2\n1 2 1 2\n0 3 2 3\n1 3 1 2 3", "249561089 748683265\n804141285 887328314 305019108\n1 499122177 332748118\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "2018", "O2优化", "枚举", "期望", "CTSC/CTS"], "title": "[CTSC2018] 假面", "background": "\n针针是绿绿的好朋友。", "description": "针针喜欢玩一款叫做 DotA (**D**efense **o**f **t**he **A**lgorithm) 的游戏，在这个游戏中，针针会操纵自己的英雄与队友一起对抗另一支队伍。\n针针在 DotA 中最喜欢使用的英雄叫做假面（Faceless），该英雄有 $2$ 个技能：\n\n- 锁定：对一名指定的敌方单位使用，以 $p$ 的概率对该单位造成 $1$ 点伤害（使其减少 $1$ 点生命值）。\n- 结界：在一片区域施放结界，让该区域内的所有其他单位无法动弹。\n在游戏中，如果一个单位的生命值降至 $0$ 或 $0$ 以下，那么该单位就会死亡。\n\n针针操纵假面的水平一般，因此他决定勤加练习。现在有 $n$ 个敌方单位（编号从 $1$ 至 $n$），编号为 $i$ 的敌方单位有 $h_i$ 点生命值。\n\n针针已经安排好了练习的计划，他会按顺序施放 $Q$ 个技能：\n\n- 对于锁定技能：针针会指定一个敌方单位 $id$ ，并对它施放。由于决定概率系数 $p$ 的因素很多，因此每次的 $p$ 都不一定相同。\n特别地，如果该敌方单位已经死亡，那么该技能不会造成任何效果。\n- 对于结界技能：针针会希望对 $k$ 个指定的敌方单位施放，但由于针针并不擅长施放该技能，因此他只能命中恰好 $1$ 个敌方单位。命中每个存活的敌方单位的概率是相等的（也就是说已经死亡的敌方单位不会有任何影响）。\n特别地，如果这 $k$ 个敌方单位均已死亡，那么该技能同样不会命中任何敌方单位。\n\n现在，围观针针进行练习的绿绿想知道：\n\n1. 对于针针施放的每个结界技能，它命中各敌人的概率分别是多少。\n2. 在针针的所有技能施放完毕后，所有敌方单位剩余生命值的期望分别是多少。\n\n由于绿绿还要围观针针训练，所以请你帮他解决这两个问题。\n\n为了防止精度误差，对于所有需要输出的数值，请输出其在模 $998244353$ 意义下的值。\n\n由于结界为假面的终极技能，因此针针施放该技能的次数不会太多。具体请见”子任务“。", "inputFormat": "第 $1$ 行为 $1$ 个正整数 $n$ ，表示敌方单位的数量。  \n第 $2$ 行为 $n$ 个正整数 $m_1,\\cdots , m_n$，依次表示各敌方单位的初始生命值。  \n第 $3$ 行为 $1$ 个非负整数 $Q$ ，表示针针施放技能的数量。  \n第 $4$ 行至第 $Q + 3$ 行，每行描述一个技能，第 $i + 3$ 行描述第 $i$ 个技能。\n\n每行的开头为一个整数 $op$ ，表示该技能的种类。  \n如果 $op = 0$ ，则表示锁定技能。并在此后跟随着 $3$ 个正整数 $id , u , v$ ，表示技能施放的目标为 $id$ ，技能命中的概率为 $p = \\frac{u}{v}$ 。（保证 $1\\le id \\le n , 0 < u \\le v < 998244353$ ）  \n如果 $op = 1$ ，则表示结界技能。并在此后跟随着 $1$ 个正整数 $k$ 表示技能施放的目标数量，随后还有额外的 $k$ 个数 $id_1,\\cdots,id_k$ 描述技能施放的所有目标。（保证所有 $1 \\le id_i \\le n$ 互不相同） 对于每一行，如果行内包含多个数，则用单个空格将它们隔开。", "outputFormat": "输出包括 $C + 1$ 行（其中 $C$ 为结界技能的数量）：\n\n前 $C$ 行依次对应每个结界技能，对于每行：\n\n输出 $k$ 个数，第 $i$ 个数表示结界命中敌方单位 $id_i$ 的概率。   \n第 $C + 1$ 行输出 $n$ 个数，第 $i$ 个数表示在所有技能施放完毕后，敌方单位 $i$ 剩余生命值的期望值。  \n\n对于每一行，如果行内包含多个数，则用单个空格将它们隔开。\n\n对于所有数值，请输出它们对 $998244353$ 取模的结果：即设答案化为最简分式后的形式为 $\\frac{a}{b}$ ，其中 $a$ 和 $b$ 的互质。输出整数 $x$ 使得 $bx \\equiv a\\bmod 998244353$ 且 $0 \\le x < 998244353$ 。（可以证明这样的整数 $x$ 是唯一的）\n", "hint": "### 样例解释 1\n针针按顺序施放如下技能：\n\n1. 对敌方单位 $2$ 施放技能锁定：以 $1$ 的概率对其造成 $1$ 点伤害。此时 $2$ 号敌方单位必定剩余 $1$ 点生命值。\n2. 对敌方单位 $2$ 施放技能结界：（由于 $2$ 号敌方单位尚存活，）必定命中 $2$ 号单位。\n3. 对敌方单位 $2$ 施放技能锁定：以 $1$ 的概率对其造成 $1$ 点伤害。\n4. 对敌方单位 $3$ 施放技能锁定：以 $1$ 的概率对其造成 $1$ 点伤害。此时三个敌方单位的生命值一定分别为 $1, 0 ,2$ ，敌方单位 $2$ 一定死亡。\n5. 对敌方单位 $2$ 施放技能结界：（由于 $2$ 号敌方单位已死亡，）必定不命中任何单位。\n6. 对敌方单位 $1, 2, 3$ 施放技能结界：命中敌方单位 $1, 3$ 的概率是相等的，即各 $\\frac{1}{2}$ 。 最终，三个敌方单位的剩余生命值一定为 $1 , 0 , 2$ 。\n\n### 样例解释 2\n对于各结界技能的分析：\n\n1. 第 $1$ 个结界（目标为敌方单位 $1,2$ ）：\n- $2$ 号敌方单位存活的概率为 $\\frac{1}{2}$ ， $1$ 号敌方单位必定存活。\n- 如果 $2$ 号敌方单位存活，那么结界命中 $1 , 2$ 的概率相等，均为 $\\frac{1}{2}$ ；如果 $2$ 号敌方单位死亡，那么结界必定命中 $1$ 号敌方单位。\n- 因此：命中 $1$ 号敌方单位的概率为 $\\frac{1}{2} \\times 1 + \\frac{1}{2} \\times \\frac{1}{2} = \\frac{3}{4}$ ；命中 $2$ 号敌方单位的概率为 $\\frac{1}{2} \\times 0 + \\frac{1}{2} \\times \\frac{1}{2} = \\frac{1}{4}$ 。\n2. 第 $2$ 个结界（目标为敌方单位 $1, 2, 3$ ）：\n- 三个敌方单位存活的概率分别为 $1, \\frac{1}{2} , \\frac{1}{3}$ 。\n- $1 , 2 , 3$ 同时存活的概率为 $\\frac{1}{6}$ ；只有 $1, 2$ 存活的概率为 $\\frac{1}{3}$ ；只有 $1 , 3$ 存活的概率为 $\\frac{1}{6}$ ；只有 $1$ 存活的概率为 $\\frac{1}{3}$ 。\n- 因此：命中 $1$ 号敌方单位的概率为 $\\frac{1}{6} \\times \\frac{1}{3} + (\\frac{1}{3}+\\frac{1}{6}) \\times \\frac{1}{2}+ \\frac{1}{3} \\times 1 = \\frac{23}{36}$ ；命中 $2$ 号敌方单位的概率为 $\\frac{1}{6} \\times \\frac{1}{3} + \\frac{1}{3} \\times \\frac{1}{2} = \\frac{2}{9}$ ；命中 $3$ 号敌方单位的概率为 $\\frac{1}{6} \\times \\frac{1}{3} + \\frac{1}{6} \\times \\frac{1}{2} = \\frac{5}{36}$ 。 最终，三个敌方单位的剩余生命值的期望值为 $1 , \\frac{1}{2} , \\frac{1}{3}$ 。\n\n\n### 数据范围\n\n我们记 $C$ 为结界技能的数量。\n\n测试点编号|n=|Q=|C=|u,v|其他限制\n-|-|-|-|-|-\n1|5|21|6|u<v|无\n2|60|199992|500|u<v|所有 p 均相等\n3|60|23|6|u<v|所有m_i =1\n4|60|199994|500|u<v|无\n5|60|199995|500|u<v|无\n6|60|199996|0|u<v|无\n7|60|199997|500|u=v|无\n8|200|199998|1000|u<v|无\n9|200|199999|1000|u<v|无\n10|200|200000|1000|u<v|无\n\n对于所有测试点，保证 $n \\le 200 , Q \\le 200000 , C \\le 1000 , m_i \\le 100$ 。\n\n提示\n\nQ 的个位可以帮助你快速确定测试点的编号。\n测试点顺序可能与难度无关。\n\n感谢 @和泉正宗 提供题面 ", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2018] Faceless", "background": "Zhenzhen is Lvlv’s good friend.", "description": "Zhenzhen likes to play a game called DotA (Defense of the Algorithm). In this game, Zhenzhen controls his hero and fights alongside teammates against another team.\nZhenzhen’s favorite hero in DotA is called “Faceless,” and this hero has $2$ skills:\n\n- Lock: Cast on a specified enemy unit, dealing $1$ point of damage (reducing its health by $1$) with probability $p$.\n- Barrier: Cast on an area to trap all other units in that area so they cannot move.\nIn the game, if a unit’s health drops to $0$ or below, that unit dies.\n\nZhenzhen is not very skilled at controlling Faceless, so he decides to practice diligently. There are $n$ enemy units (numbered from $1$ to $n$), and the enemy unit numbered $i$ has $m_i$ health points.\n\nZhenzhen has arranged a practice plan in which he will cast $Q$ skills in order:\n\n- For the Lock skill: Zhenzhen specifies an enemy unit $id$ and casts it on that unit. Since many factors determine the probability parameter $p$, the value of $p$ may be different each time.\nIn particular, if the specified enemy unit is already dead, then this skill has no effect.\n- For the Barrier skill: Zhenzhen intends to cast it on $k$ specified enemy units, but since he is not good at casting this skill, he can hit exactly $1$ enemy unit. The probability of hitting each living enemy unit is equal (i.e., already dead enemy units have no effect).\nIn particular, if all $k$ specified enemy units are already dead, then this skill also does not hit any unit.\n\nNow, Lvlv, who is watching Zhenzhen practice, wants to know:\n\n1. For each Barrier skill that Zhenzhen casts, what is the probability that it hits each enemy, respectively.\n2. After all of Zhenzhen’s skills have been cast, what is the expected remaining health of each enemy unit.\n\nTo prevent precision errors, for all numerical outputs, please output their values modulo $998244353$.\n\nSince Barrier is Faceless’s ultimate skill, the number of times Zhenzhen casts it will not be too many. See Constraints.", "inputFormat": "The $1$-st line contains $1$ positive integer $n$, the number of enemy units.\nThe $2$-nd line contains $n$ positive integers $m_1, \\cdots, m_n$, representing the initial health of each enemy unit in order.\nThe $3$-rd line contains $1$ non-negative integer $Q$, the number of skills Zhenzhen will cast.\nThe $4$-th to the $(Q + 3)$-rd lines each describe one skill; the $(i + 3)$-rd line describes the $i$-th skill.\n\nEach line begins with an integer $op$, indicating the type of the skill.\nIf $op = 0$, it indicates the Lock skill. This is followed by $3$ positive integers $id, u, v$, meaning the target is $id$, and the hit probability is $p = \\frac{u}{v}$. (Guaranteed that $1 \\le id \\le n$, $0 < u \\le v < 998244353$.)\nIf $op = 1$, it indicates the Barrier skill. This is followed by $1$ positive integer $k$ indicating the number of targets, then an additional $k$ numbers $id_1, \\cdots, id_k$ describing all the targets of this skill. (Guaranteed that all $1 \\le id_i \\le n$ are pairwise distinct.)\nWithin each line, if there are multiple numbers, separate them with a single space.", "outputFormat": "Output $C + 1$ lines (where $C$ is the number of Barrier skills):\n\nFor the first $C$ lines, corresponding to each Barrier skill in order:\nOutput $k$ numbers. The $i$-th number is the probability that the Barrier hits enemy unit $id_i$.\n\nOn the $(C + 1)$-st line, output $n$ numbers. The $i$-th number is the expected remaining health of enemy unit $i$ after all skills have been cast.\n\nWithin each line, if there are multiple numbers, separate them with a single space.\n\nFor all numerical values, output them modulo $998244353$: that is, suppose the answer in reduced fraction form is $\\frac{a}{b}$ with $\\gcd(a, b) = 1$. Output the integer $x$ such that $b x \\equiv a \\bmod 998244353$ and $0 \\le x < 998244353$. (It can be proven that such an integer $x$ is unique.)", "hint": "Sample Explanation 1\nZhenzhen casts the following skills in order:\n\n1. Cast Lock on enemy unit $2$: deals $1$ damage with probability $1$. At this moment, enemy unit $2$ must have $1$ health remaining.\n2. Cast Barrier on enemy unit $2$: (since enemy unit $2$ is still alive,) it must hit unit $2$.\n3. Cast Lock on enemy unit $2$: deals $1$ damage with probability $1$.\n4. Cast Lock on enemy unit $3$: deals $1$ damage with probability $1$. Now the three enemy units’ health values must be $1, 0, 2$ respectively, and enemy unit $2$ must be dead.\n5. Cast Barrier on enemy unit $2$: (since enemy unit $2$ is dead,) it must hit no unit.\n6. Cast Barrier on enemy units $1, 2, 3$: the probabilities of hitting enemy units $1$ and $3$ are equal, i.e., each $\\frac{1}{2}$. Finally, the remaining health of the three enemy units must be $1, 0, 2$.\n\nSample Explanation 2\nAnalysis for each Barrier skill:\n\n1. The $1$-st Barrier (targets enemy units $1, 2$):\n- The probability that enemy unit $2$ is alive is $\\frac{1}{2}$, and enemy unit $1$ must be alive.\n- If enemy unit $2$ is alive, then the probabilities of Barrier hitting $1$ and $2$ are equal, both $\\frac{1}{2}$; if enemy unit $2$ is dead, then Barrier must hit enemy unit $1$.\n- Therefore: the probability of hitting enemy unit $1$ is $\\frac{1}{2} \\times 1 + \\frac{1}{2} \\times \\frac{1}{2} = \\frac{3}{4}$; the probability of hitting enemy unit $2$ is $\\frac{1}{2} \\times 0 + \\frac{1}{2} \\times \\frac{1}{2} = \\frac{1}{4}$.\n2. The $2$-nd Barrier (targets enemy units $1, 2, 3$):\n- The probabilities that the three enemy units are alive are $1, \\frac{1}{2}, \\frac{1}{3}$, respectively.\n- The probability that $1, 2, 3$ are all alive is $\\frac{1}{6}$; the probability that only $1, 2$ are alive is $\\frac{1}{3}$; the probability that only $1, 3$ are alive is $\\frac{1}{6}$; the probability that only $1$ is alive is $\\frac{1}{3}$.\n- Therefore: the probability of hitting enemy unit $1$ is $\\frac{1}{6} \\times \\frac{1}{3} + (\\frac{1}{3} + \\frac{1}{6}) \\times \\frac{1}{2} + \\frac{1}{3} \\times 1 = \\frac{23}{36}$; the probability of hitting enemy unit $2$ is $\\frac{1}{6} \\times \\frac{1}{3} + \\frac{1}{3} \\times \\frac{1}{2} = \\frac{2}{9}$; the probability of hitting enemy unit $3$ is $\\frac{1}{6} \\times \\frac{1}{3} + \\frac{1}{6} \\times \\frac{1}{2} = \\frac{5}{36}$. Finally, the expected remaining health of the three enemy units is $1, \\frac{1}{2}, \\frac{1}{3}$.\n\nConstraints\n\nLet $C$ be the number of Barrier skills.\n\nTest point id|n =|Q =|C =|u, v|Other constraints\n-|-|-|-|-|-\n1|5|21|6|u < v|None\n2|60|199992|500|u < v|All $p$ are equal\n3|60|23|6|u < v|All $m_i = 1$\n4|60|199994|500|u < v|None\n5|60|199995|500|u < v|None\n6|60|199996|0|u < v|None\n7|60|199997|500|u = v|None\n8|200|199998|1000|u < v|None\n9|200|199999|1000|u < v|None\n10|200|200000|1000|u < v|None\n\nFor all test points, it is guaranteed that $n \\le 200$, $Q \\le 200000$, $C \\le 1000$, $m_i \\le 100$.\n\nHint\n\nThe units digit of $Q$ can help you quickly determine the test point id.\nThe test point order may not correlate with difficulty.\n\nThanks to @和泉正宗 for providing the statement.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2018] 假面", "background": "\n针针是绿绿的好朋友。", "description": "针针喜欢玩一款叫做 DotA (**D**efense **o**f **t**he **A**lgorithm) 的游戏，在这个游戏中，针针会操纵自己的英雄与队友一起对抗另一支队伍。\n针针在 DotA 中最喜欢使用的英雄叫做假面（Faceless），该英雄有 $2$ 个技能：\n\n- 锁定：对一名指定的敌方单位使用，以 $p$ 的概率对该单位造成 $1$ 点伤害（使其减少 $1$ 点生命值）。\n- 结界：在一片区域施放结界，让该区域内的所有其他单位无法动弹。\n在游戏中，如果一个单位的生命值降至 $0$ 或 $0$ 以下，那么该单位就会死亡。\n\n针针操纵假面的水平一般，因此他决定勤加练习。现在有 $n$ 个敌方单位（编号从 $1$ 至 $n$），编号为 $i$ 的敌方单位有 $h_i$ 点生命值。\n\n针针已经安排好了练习的计划，他会按顺序施放 $Q$ 个技能：\n\n- 对于锁定技能：针针会指定一个敌方单位 $id$ ，并对它施放。由于决定概率系数 $p$ 的因素很多，因此每次的 $p$ 都不一定相同。\n特别地，如果该敌方单位已经死亡，那么该技能不会造成任何效果。\n- 对于结界技能：针针会希望对 $k$ 个指定的敌方单位施放，但由于针针并不擅长施放该技能，因此他只能命中恰好 $1$ 个敌方单位。命中每个存活的敌方单位的概率是相等的（也就是说已经死亡的敌方单位不会有任何影响）。\n特别地，如果这 $k$ 个敌方单位均已死亡，那么该技能同样不会命中任何敌方单位。\n\n现在，围观针针进行练习的绿绿想知道：\n\n1. 对于针针施放的每个结界技能，它命中各敌人的概率分别是多少。\n2. 在针针的所有技能施放完毕后，所有敌方单位剩余生命值的期望分别是多少。\n\n由于绿绿还要围观针针训练，所以请你帮他解决这两个问题。\n\n为了防止精度误差，对于所有需要输出的数值，请输出其在模 $998244353$ 意义下的值。\n\n由于结界为假面的终极技能，因此针针施放该技能的次数不会太多。具体请见”子任务“。", "inputFormat": "第 $1$ 行为 $1$ 个正整数 $n$ ，表示敌方单位的数量。  \n第 $2$ 行为 $n$ 个正整数 $m_1,\\cdots , m_n$，依次表示各敌方单位的初始生命值。  \n第 $3$ 行为 $1$ 个非负整数 $Q$ ，表示针针施放技能的数量。  \n第 $4$ 行至第 $Q + 3$ 行，每行描述一个技能，第 $i + 3$ 行描述第 $i$ 个技能。\n\n每行的开头为一个整数 $op$ ，表示该技能的种类。  \n如果 $op = 0$ ，则表示锁定技能。并在此后跟随着 $3$ 个正整数 $id , u , v$ ，表示技能施放的目标为 $id$ ，技能命中的概率为 $p = \\frac{u}{v}$ 。（保证 $1\\le id \\le n , 0 < u \\le v < 998244353$ ）  \n如果 $op = 1$ ，则表示结界技能。并在此后跟随着 $1$ 个正整数 $k$ 表示技能施放的目标数量，随后还有额外的 $k$ 个数 $id_1,\\cdots,id_k$ 描述技能施放的所有目标。（保证所有 $1 \\le id_i \\le n$ 互不相同） 对于每一行，如果行内包含多个数，则用单个空格将它们隔开。", "outputFormat": "输出包括 $C + 1$ 行（其中 $C$ 为结界技能的数量）：\n\n前 $C$ 行依次对应每个结界技能，对于每行：\n\n输出 $k$ 个数，第 $i$ 个数表示结界命中敌方单位 $id_i$ 的概率。   \n第 $C + 1$ 行输出 $n$ 个数，第 $i$ 个数表示在所有技能施放完毕后，敌方单位 $i$ 剩余生命值的期望值。  \n\n对于每一行，如果行内包含多个数，则用单个空格将它们隔开。\n\n对于所有数值，请输出它们对 $998244353$ 取模的结果：即设答案化为最简分式后的形式为 $\\frac{a}{b}$ ，其中 $a$ 和 $b$ 的互质。输出整数 $x$ 使得 $bx \\equiv a\\bmod 998244353$ 且 $0 \\le x < 998244353$ 。（可以证明这样的整数 $x$ 是唯一的）\n", "hint": "### 样例解释 1\n针针按顺序施放如下技能：\n\n1. 对敌方单位 $2$ 施放技能锁定：以 $1$ 的概率对其造成 $1$ 点伤害。此时 $2$ 号敌方单位必定剩余 $1$ 点生命值。\n2. 对敌方单位 $2$ 施放技能结界：（由于 $2$ 号敌方单位尚存活，）必定命中 $2$ 号单位。\n3. 对敌方单位 $2$ 施放技能锁定：以 $1$ 的概率对其造成 $1$ 点伤害。\n4. 对敌方单位 $3$ 施放技能锁定：以 $1$ 的概率对其造成 $1$ 点伤害。此时三个敌方单位的生命值一定分别为 $1, 0 ,2$ ，敌方单位 $2$ 一定死亡。\n5. 对敌方单位 $2$ 施放技能结界：（由于 $2$ 号敌方单位已死亡，）必定不命中任何单位。\n6. 对敌方单位 $1, 2, 3$ 施放技能结界：命中敌方单位 $1, 3$ 的概率是相等的，即各 $\\frac{1}{2}$ 。 最终，三个敌方单位的剩余生命值一定为 $1 , 0 , 2$ 。\n\n### 样例解释 2\n对于各结界技能的分析：\n\n1. 第 $1$ 个结界（目标为敌方单位 $1,2$ ）：\n- $2$ 号敌方单位存活的概率为 $\\frac{1}{2}$ ， $1$ 号敌方单位必定存活。\n- 如果 $2$ 号敌方单位存活，那么结界命中 $1 , 2$ 的概率相等，均为 $\\frac{1}{2}$ ；如果 $2$ 号敌方单位死亡，那么结界必定命中 $1$ 号敌方单位。\n- 因此：命中 $1$ 号敌方单位的概率为 $\\frac{1}{2} \\times 1 + \\frac{1}{2} \\times \\frac{1}{2} = \\frac{3}{4}$ ；命中 $2$ 号敌方单位的概率为 $\\frac{1}{2} \\times 0 + \\frac{1}{2} \\times \\frac{1}{2} = \\frac{1}{4}$ 。\n2. 第 $2$ 个结界（目标为敌方单位 $1, 2, 3$ ）：\n- 三个敌方单位存活的概率分别为 $1, \\frac{1}{2} , \\frac{1}{3}$ 。\n- $1 , 2 , 3$ 同时存活的概率为 $\\frac{1}{6}$ ；只有 $1, 2$ 存活的概率为 $\\frac{1}{3}$ ；只有 $1 , 3$ 存活的概率为 $\\frac{1}{6}$ ；只有 $1$ 存活的概率为 $\\frac{1}{3}$ 。\n- 因此：命中 $1$ 号敌方单位的概率为 $\\frac{1}{6} \\times \\frac{1}{3} + (\\frac{1}{3}+\\frac{1}{6}) \\times \\frac{1}{2}+ \\frac{1}{3} \\times 1 = \\frac{23}{36}$ ；命中 $2$ 号敌方单位的概率为 $\\frac{1}{6} \\times \\frac{1}{3} + \\frac{1}{3} \\times \\frac{1}{2} = \\frac{2}{9}$ ；命中 $3$ 号敌方单位的概率为 $\\frac{1}{6} \\times \\frac{1}{3} + \\frac{1}{6} \\times \\frac{1}{2} = \\frac{5}{36}$ 。 最终，三个敌方单位的剩余生命值的期望值为 $1 , \\frac{1}{2} , \\frac{1}{3}$ 。\n\n\n### 数据范围\n\n我们记 $C$ 为结界技能的数量。\n\n测试点编号|n=|Q=|C=|u,v|其他限制\n-|-|-|-|-|-\n1|5|21|6|u<v|无\n2|60|199992|500|u<v|所有 p 均相等\n3|60|23|6|u<v|所有m_i =1\n4|60|199994|500|u<v|无\n5|60|199995|500|u<v|无\n6|60|199996|0|u<v|无\n7|60|199997|500|u=v|无\n8|200|199998|1000|u<v|无\n9|200|199999|1000|u<v|无\n10|200|200000|1000|u<v|无\n\n对于所有测试点，保证 $n \\le 200 , Q \\le 200000 , C \\le 1000 , m_i \\le 100$ 。\n\n提示\n\nQ 的个位可以帮助你快速确定测试点的编号。\n测试点顺序可能与难度无关。\n\n感谢 @和泉正宗 提供题面 ", "locale": "zh-CN"}}}
{"pid": "P4565", "type": "P", "difficulty": 7, "samples": [["6\n1 2 2\n1 3 0\n2 4 1\n2 5 -7\n3 6 0\n1 2 -1\n2 3 -1\n2 5 3\n2 6 -2\n3 4 8", "5\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "线段树", "O2优化", "分治", "最近公共祖先 LCA", "CTSC/CTS"], "title": "[CTSC2018] 暴力写挂", "background": "", "description": "temporaryDO 是一个很菜的 OIer。在 4 月，他在省队选拔赛的考场上见到了《林克卡特树》一题，其中 $k = 0$ 的部分分是求树 $T$ 上的最长链。可怜的 temporaryDO 并不会做这道题，他在考场上抓猫耳挠猫腮都想不出一点思路。\n\n这时，善良的板板出现在了空中，他的身上发出璀璨却柔和的光芒，荡漾在考场上。“题目并不难。” 板板说。那充满磁性的声音，让 temporaryDO 全身充满了力量。\n\n他决定：写一个枚举点对求 LCA 算距离的 $k = 0$ 的 $O(n^2 \\log n)$ 的部分分程序！于是， temporaryDO 选择以 $1$ 为根，建立了求 LCA 的树链剖分结构，然后写了二重 for 循环枚举点对。\n\n然而，菜菜的 temporaryDO 不小心开小了数组，于是数组越界到了一片神秘的内存区域。但恰好的是，那片内存区域存储的区域恰好是另一棵树 $T'$ 。这样一来，程序并没有 RE ，但他求 $x$ 和 $y$ 的距离的时候，计算的是 \n\n$$ \\mathrm{depth}(x) + \\mathrm{depth}(y) -  ({\\mathrm{depth}(\\mathrm{LCA}(x,y))}+{\\mathrm{depth'}(\\mathrm{LCA'}(x,y))})$$\n\n\n\n最后程序会输出每一对点对 $i, j$（$i \\le j$） 的如上定义的“距离” 的最大值。\ntemporaryDO 的程序在评测时光荣地爆零了。但他并不服气，他决定花好几天把自己的程序跑出来。请你根据 $T$ 和 $T'$ 帮帮可怜的 temporaryDO 求出他程序的输出。", "inputFormat": "第一行包含一个整数 $n$ ，表示树上的节点个数。\n\n第 $2$ 到第 $n$ 行，每行三个整数 $x , y , v$ ，表示 $T$ 中存在一条从 $x$ 到 $y$ 的边，其长度为 $v$。\n\n第 $n + 1$ 到第 $2n-1$ 行 ，每行三个整数 $x , y , v$ ，表示 $T'$ 中存在一条从 $x$ 到 $y$ 的边，其长度为 $v$。", "outputFormat": "输出一行一个整数，表示 temporaryDO 的程序的输出。\n", "hint": "### 样例解释 1\n点对 $(3, 4)$ 的距离计算为 $3 + 0 - (0 + (-2)) = 5$ 。\n\n### 数据范围\n对于所有数据， $1\\le n \\le 366666$，$|v| \\le 2017011328$ 。 详细数据范围见下表，表格中的“无” 表示无特殊限制。\n\n测试点编号|$n \\le$|$v$|$T$ 是一条链|$T'$ 是一条链\n-|-|-|-|-\n$1$|$36$|$=1$|否|否\n$2$|$366$|$=1$|否|否\n$3$|$1388$|$>0$|否|否\n$4$|$1999$|$>0$|否|否\n$5$|$2666$|$>0$|否|否\n$6$|$5666$|无|否|否\n$7$|$8666$|无|否|否\n$8$|$11111$|无|否|否\n$9$|$12345$|无|否|否\n$10$|$366666$|$>0$|是|是\n$11$|$366666$|无|是|是\n$12\\sim 13$|$366666$|$>0$|是|否\n$14$|$366666$|无|是|否\n$15\\sim 16$|$366666$|$>0$|否|是\n$17$|$366666$|无|否|是\n$18\\sim 20$|$366666$|无|否|否\n\n$\\mathrm{depth}(p)$ 和 $\\mathrm{depth'}(p)$ 分别表示树 $T$，$T'$ 中点 $1$ 到点 $p$ 的距离，这里规定，距离指的是经过的边的边权总和，其中 $\\mathrm{depth}(1) = 0$。\n\n$\\mathrm{LCA}(x, y)$ 和 $\\mathrm{LCA'}(x, y)$ 分别表示树 $T$，$T'$ 中点 $x$ 与点 $y$ 的最近公共祖先，即在从 $x$ 到 $y$ 的最短路径上的距离根**经过边数最少**的点。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2018] Bugged Brute Force", "background": "", "description": "temporaryDO is a very weak OIer. In April, during the provincial team qualifier, he saw the problem “Link-Cut Tree.” The partial score for $k = 0$ asks for the longest path on tree $T$. Poor temporaryDO didn’t know how to solve it; even after scratching his head, he couldn’t come up with any idea.\n\nAt that moment, the kind Banban appeared in the air, radiating a brilliant yet gentle light that rippled across the exam hall. “The problem isn’t hard,” Banban said. That magnetic voice filled temporaryDO with strength.\n\nHe decided to write an $O(n^2 \\log n)$ partial-solution program for $k = 0$ that enumerates pairs and uses LCA to compute distances. So temporaryDO chose $1$ as the root, built a heavy-light decomposition structure for LCA, and then wrote a double for loop to enumerate pairs.\n\nHowever, clumsy temporaryDO accidentally allocated an array too small, causing an out-of-bounds access into a mysterious memory region. Coincidentally, that region happened to store another tree $T'$. As a result, the program did not RE, but when computing the distance between $x$ and $y$, it calculated\n\n$$ \\mathrm{depth}(x) + \\mathrm{depth}(y) -  ({\\mathrm{depth}(\\mathrm{LCA}(x,y))}+{\\mathrm{depth'}(\\mathrm{LCA'}(x,y))})$$\n\nFinally, the program outputs the maximum of the above-defined “distance” over all pairs $i, j$ with $i \\le j$. temporaryDO’s program gloriously scored zero during evaluation. Unconvinced, he decided to spend several days reproducing his program’s output. Given $T$ and $T'$, please help the poor temporaryDO compute what his program outputs.", "inputFormat": "The first line contains an integer $n$, the number of nodes in the tree.\n\nLines $2$ to $n$ each contain three integers $x, y, v$, indicating that in $T$ there is an edge between $x$ and $y$ with length $v$.\n\nLines $n + 1$ to $2n - 1$ each contain three integers $x, y, v$, indicating that in $T'$ there is an edge between $x$ and $y$ with length $v$.", "outputFormat": "Output a single integer on one line: the output of temporaryDO’s program.", "hint": "Sample explanation 1  \nFor the pair $(3, 4)$, the distance is computed as $3 + 0 - (0 + (-2)) = 5$.\n\nConstraints  \nFor all testdata, $1 \\le n \\le 366666$, $|v| \\le 2017011328$. Detailed constraints are shown in the table below; in the table, “无” means no special restriction.\n\n测试点编号|$n \\le$|$v$|$T$ is a path|$T'$ is a path\n-|-|-|-|-\n$1$|$36$|$=1$|No|No\n$2$|$366$|$=1$|No|No\n$3$|$1388$|$>0$|No|No\n$4$|$1999$|$>0$|No|No\n$5$|$2666$|$>0$|No|No\n$6$|$5666$|none|No|No\n$7$|$8666$|none|No|No\n$8$|$11111$|none|No|No\n$9$|$12345$|none|No|No\n$10$|$366666$|$>0$|Yes|Yes\n$11$|$366666$|none|Yes|Yes\n$12\\sim 13$|$366666$|$>0$|Yes|No\n$14$|$366666$|none|Yes|No\n$15\\sim 16$|$366666$|$>0$|No|Yes\n$17$|$366666$|none|No|Yes\n$18\\sim 20$|$366666$|none|No|No\n\n$\\mathrm{depth}(p)$ and $\\mathrm{depth'}(p)$ denote the distances from node $1$ to node $p$ in trees $T$ and $T'$ respectively. Here, distance means the sum of edge weights along the path, and $\\mathrm{depth}(1) = 0$.\n\n$\\mathrm{LCA}(x, y)$ and $\\mathrm{LCA'}(x, y)$ denote, in $T$ and $T'$ respectively, the lowest common ancestor of nodes $x$ and $y$, i.e., the point on the shortest path from $x$ to $y$ that has the fewest edges from the root.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2018] 暴力写挂", "background": "", "description": "temporaryDO 是一个很菜的 OIer。在 4 月，他在省队选拔赛的考场上见到了《林克卡特树》一题，其中 $k = 0$ 的部分分是求树 $T$ 上的最长链。可怜的 temporaryDO 并不会做这道题，他在考场上抓猫耳挠猫腮都想不出一点思路。\n\n这时，善良的板板出现在了空中，他的身上发出璀璨却柔和的光芒，荡漾在考场上。“题目并不难。” 板板说。那充满磁性的声音，让 temporaryDO 全身充满了力量。\n\n他决定：写一个枚举点对求 LCA 算距离的 $k = 0$ 的 $O(n^2 \\log n)$ 的部分分程序！于是， temporaryDO 选择以 $1$ 为根，建立了求 LCA 的树链剖分结构，然后写了二重 for 循环枚举点对。\n\n然而，菜菜的 temporaryDO 不小心开小了数组，于是数组越界到了一片神秘的内存区域。但恰好的是，那片内存区域存储的区域恰好是另一棵树 $T'$ 。这样一来，程序并没有 RE ，但他求 $x$ 和 $y$ 的距离的时候，计算的是 \n\n$$ \\mathrm{depth}(x) + \\mathrm{depth}(y) -  ({\\mathrm{depth}(\\mathrm{LCA}(x,y))}+{\\mathrm{depth'}(\\mathrm{LCA'}(x,y))})$$\n\n\n\n最后程序会输出每一对点对 $i, j$（$i \\le j$） 的如上定义的“距离” 的最大值。\ntemporaryDO 的程序在评测时光荣地爆零了。但他并不服气，他决定花好几天把自己的程序跑出来。请你根据 $T$ 和 $T'$ 帮帮可怜的 temporaryDO 求出他程序的输出。", "inputFormat": "第一行包含一个整数 $n$ ，表示树上的节点个数。\n\n第 $2$ 到第 $n$ 行，每行三个整数 $x , y , v$ ，表示 $T$ 中存在一条从 $x$ 到 $y$ 的边，其长度为 $v$。\n\n第 $n + 1$ 到第 $2n-1$ 行 ，每行三个整数 $x , y , v$ ，表示 $T'$ 中存在一条从 $x$ 到 $y$ 的边，其长度为 $v$。", "outputFormat": "输出一行一个整数，表示 temporaryDO 的程序的输出。\n", "hint": "### 样例解释 1\n点对 $(3, 4)$ 的距离计算为 $3 + 0 - (0 + (-2)) = 5$ 。\n\n### 数据范围\n对于所有数据， $1\\le n \\le 366666$，$|v| \\le 2017011328$ 。 详细数据范围见下表，表格中的“无” 表示无特殊限制。\n\n测试点编号|$n \\le$|$v$|$T$ 是一条链|$T'$ 是一条链\n-|-|-|-|-\n$1$|$36$|$=1$|否|否\n$2$|$366$|$=1$|否|否\n$3$|$1388$|$>0$|否|否\n$4$|$1999$|$>0$|否|否\n$5$|$2666$|$>0$|否|否\n$6$|$5666$|无|否|否\n$7$|$8666$|无|否|否\n$8$|$11111$|无|否|否\n$9$|$12345$|无|否|否\n$10$|$366666$|$>0$|是|是\n$11$|$366666$|无|是|是\n$12\\sim 13$|$366666$|$>0$|是|否\n$14$|$366666$|无|是|否\n$15\\sim 16$|$366666$|$>0$|否|是\n$17$|$366666$|无|否|是\n$18\\sim 20$|$366666$|无|否|否\n\n$\\mathrm{depth}(p)$ 和 $\\mathrm{depth'}(p)$ 分别表示树 $T$，$T'$ 中点 $1$ 到点 $p$ 的距离，这里规定，距离指的是经过的边的边权总和，其中 $\\mathrm{depth}(1) = 0$。\n\n$\\mathrm{LCA}(x, y)$ 和 $\\mathrm{LCA'}(x, y)$ 分别表示树 $T$，$T'$ 中点 $x$ 与点 $y$ 的最近公共祖先，即在从 $x$ 到 $y$ 的最短路径上的距离根**经过边数最少**的点。", "locale": "zh-CN"}}}
{"pid": "P4566", "type": "P", "difficulty": 7, "samples": [["1 3\n1 1 3", "2\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "2018", "O2优化", "分治", "排列组合", "快速傅里叶变换 FFT", "CTSC/CTS"], "title": "[CTSC2018] 青蕈领主", "background": "“也许，我的生命也已经如同风中残烛了吧。”小绿如是说。", "description": "小绿同学因为微积分这门课，对“连续”这一概念产生了浓厚的兴趣。小绿打算把连续的概念放到由整数构成的序列上，他定义一个长度为 $m$ 的整数序列是连续的，当且仅当这个序列中的最大值与最小值的差，不超过$m-1$。例如 $\\{1,3,2\\}$ 是连续的，而 $\\{1,3\\}$ 不是连续的。\n\n某天，小绿的顶头上司板老大，给了小绿 $T$ 个长度为 $n$ 的排列。小绿拿到之后十分欢喜，他求出了每个排列的每个区间是否是他所定义的“连续”的。然而，小绿觉得被别的“连续”区间包含住的“连续”区间不够优秀，于是对于每个排列的所有右端点相同的“连续”区间，他只记录下了长度最长的那个“连续”区间的长度。也就是说，对于板老大给他的每一个排列，他都只记录下了在这个排列中，对于每一个 $1 \\le i \\le n$，右端点为 $i$ 的最长“连续”区间的长度 $L_i$。显然这个长度最少为 $1$，因为所有长度为 $1$ 的整数序列都是连续的。\n\n做完这一切后，小绿爬上绿色床，美美地做了一个绿色的梦。\n\n可是第二天醒来之后，小绿惊讶的发现板老大给他的所有排列都不见了，只剩下他记录下来的 $T$ 组信息。小绿知道自己在劫难逃，但是作为一个好奇的青年，他还是想知道：对于每一组信息，有多少个和信息符合的长度为 $n$ 的排列。\n\n由于小绿已经放弃治疗了，你只需要告诉他每一个答案对 $998244353$ 取模的结果。\n\n我们并不保证一定存在至少一个符合信息的排列，因为小绿也是人，他也有可能犯错。", "inputFormat": "输入的第一行包含两个整数 $T,n$，分别表示板老大给小绿的排列个数、以及每个排列的长度。\n\n接下来 $T$ 行，每行描述一组信息，包含 $n$ 个正整数，第 $i$ 组信息的从左往右第 $j$ 个整数 $L_{i,j}$ 表示第 $i$ 个排列中右端点为第 $j$ 个数的最长“连续”区间的长度。\n\n对于每一行，如果行内包含多个数，则用单个空格将它们隔开。", "outputFormat": "对于每组信息，输出一行一个整数表示可能的排列个数对 $998244353$ 取模的结果。由于是计算机帮你算，所以我们不给你犯错的机会。\n", "hint": "### 数据规模\n\n测试点编号|$n\\le$|$T\\le$|特殊性质\n-|-|-|-\n1~2|10|1|无\n3~4|10|100|无\n5|300|1|$L_{i,j}=j$\n6|300|1|$L_{i,j}=1$ 且 $j<n$\n7~8|300|100|无\n9|1000|1|$L_{i,j}=1$ 且 $j<n$\n10~12|1000|100|无\n13~16|5000|100|无\n17~20|50000|100|无\n\n对于所有测试数据，$1 \\le T \\le 100,1 \\le N \\le 50000,1 \\le L_{i,j} \\le j$。  \n本题部分测试点的输入规模较大，请注意读入效率。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2018] Qingxun Lord", "background": "\"Maybe my life is already like a candle flickering in the wind.\" said Xiao Lü.", "description": "Because of a calculus course, Xiao Lü has become very interested in the concept of \"continuity\". He plans to bring the concept of continuity to sequences of integers. He defines an integer sequence of length $m$ to be continuous if and only if the difference between the maximum and minimum elements in the sequence does not exceed $m-1$. For example, $\\{1,3,2\\}$ is continuous, while $\\{1,3\\}$ is not.\n\nOne day, Xiao Lü’s direct supervisor, Boss Ban, gave him $T$ permutations of length $n$. Delighted, Xiao Lü determined, for each permutation, whether each interval is \"continuous\" as he defined. However, he felt that \"continuous\" intervals contained within other \"continuous\" intervals were not good enough. Therefore, for all \"continuous\" intervals in each permutation with the same right endpoint, he recorded only the length of the longest such \"continuous\" interval. In other words, for each permutation given by Boss Ban, he recorded for each $1 \\le i \\le n$ the length $L_i$ of the longest \"continuous\" interval whose right endpoint is $i$. Clearly, this length is at least $1$, because all integer sequences of length $1$ are continuous.\n\nAfter finishing all this, Xiao Lü climbed onto his green bed and had a lovely green dream.\n\nBut when he woke up the next day, he was shocked to find that all the permutations Boss Ban had given him were gone, leaving only the $T$ recorded sets of information. Knowing he was doomed, yet being a curious young man, he still wanted to know: for each set of information, how many length-$n$ permutations are consistent with it?\n\nSince Xiao Lü has already given up on treatment, you only need to tell him each answer modulo $998244353$.\n\nWe do not guarantee that there exists at least one permutation consistent with the information, because Xiao Lü is human and can make mistakes.", "inputFormat": "The first line contains two integers $T, n$, representing the number of permutations Boss Ban gave and the length of each permutation.\n\nThe next $T$ lines each describe one set of information and contain $n$ positive integers. In the $i$-th set, the $j$-th integer from left to right $L_{i,j}$ denotes, in the $i$-th permutation, the length of the longest \"continuous\" interval whose right endpoint is the $j$-th position.\n\nWithin each line, if there are multiple numbers, they are separated by a single space.", "outputFormat": "For each set of information, output a single integer on its own line representing the number of possible permutations modulo $998244353$. Since the computer is doing the calculation, we will not give you a chance to make a mistake.", "hint": "### Constraints\n\n测试点编号|$n\\le$|$T\\le$|特殊性质\n-|-|-|-\n1~2|10|1|None\n3~4|10|100|None\n5|300|1|$L_{i,j}=j$\n6|300|1|$L_{i,j}=1$ 且 $j<n$\n7~8|300|100|None\n9|1000|1|$L_{i,j}=1$ 且 $j<n$\n10~12|1000|100|None\n13~16|5000|100|None\n17~20|50000|100|None\n\nFor all testdata, $1 \\le T \\le 100, 1 \\le n \\le 50000, 1 \\le L_{i,j} \\le j$.  \nSome test points have large input size; please be mindful of input speed.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2018] 青蕈领主", "background": "“也许，我的生命也已经如同风中残烛了吧。”小绿如是说。", "description": "小绿同学因为微积分这门课，对“连续”这一概念产生了浓厚的兴趣。小绿打算把连续的概念放到由整数构成的序列上，他定义一个长度为 $m$ 的整数序列是连续的，当且仅当这个序列中的最大值与最小值的差，不超过$m-1$。例如 $\\{1,3,2\\}$ 是连续的，而 $\\{1,3\\}$ 不是连续的。\n\n某天，小绿的顶头上司板老大，给了小绿 $T$ 个长度为 $n$ 的排列。小绿拿到之后十分欢喜，他求出了每个排列的每个区间是否是他所定义的“连续”的。然而，小绿觉得被别的“连续”区间包含住的“连续”区间不够优秀，于是对于每个排列的所有右端点相同的“连续”区间，他只记录下了长度最长的那个“连续”区间的长度。也就是说，对于板老大给他的每一个排列，他都只记录下了在这个排列中，对于每一个 $1 \\le i \\le n$，右端点为 $i$ 的最长“连续”区间的长度 $L_i$。显然这个长度最少为 $1$，因为所有长度为 $1$ 的整数序列都是连续的。\n\n做完这一切后，小绿爬上绿色床，美美地做了一个绿色的梦。\n\n可是第二天醒来之后，小绿惊讶的发现板老大给他的所有排列都不见了，只剩下他记录下来的 $T$ 组信息。小绿知道自己在劫难逃，但是作为一个好奇的青年，他还是想知道：对于每一组信息，有多少个和信息符合的长度为 $n$ 的排列。\n\n由于小绿已经放弃治疗了，你只需要告诉他每一个答案对 $998244353$ 取模的结果。\n\n我们并不保证一定存在至少一个符合信息的排列，因为小绿也是人，他也有可能犯错。", "inputFormat": "输入的第一行包含两个整数 $T,n$，分别表示板老大给小绿的排列个数、以及每个排列的长度。\n\n接下来 $T$ 行，每行描述一组信息，包含 $n$ 个正整数，第 $i$ 组信息的从左往右第 $j$ 个整数 $L_{i,j}$ 表示第 $i$ 个排列中右端点为第 $j$ 个数的最长“连续”区间的长度。\n\n对于每一行，如果行内包含多个数，则用单个空格将它们隔开。", "outputFormat": "对于每组信息，输出一行一个整数表示可能的排列个数对 $998244353$ 取模的结果。由于是计算机帮你算，所以我们不给你犯错的机会。\n", "hint": "### 数据规模\n\n测试点编号|$n\\le$|$T\\le$|特殊性质\n-|-|-|-\n1~2|10|1|无\n3~4|10|100|无\n5|300|1|$L_{i,j}=j$\n6|300|1|$L_{i,j}=1$ 且 $j<n$\n7~8|300|100|无\n9|1000|1|$L_{i,j}=1$ 且 $j<n$\n10~12|1000|100|无\n13~16|5000|100|无\n17~20|50000|100|无\n\n对于所有测试数据，$1 \\le T \\le 100,1 \\le N \\le 50000,1 \\le L_{i,j} \\le j$。  \n本题部分测试点的输入规模较大，请注意读入效率。", "locale": "zh-CN"}}}
{"pid": "P4567", "type": "P", "difficulty": 6, "samples": [["10\nInsert 13\nBalanced eert\nMove 2\nDelete 5\nNext\nInsert 7\n editor\nMove 0\nGet\nMove 11\nRotate 4\nGet", "B\nt"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "各省省选", "平衡树", "安徽"], "title": "[AHOI2006] 文本编辑器", "background": null, "description": "这些日子，可可不和卡卡一起玩了，原来可可正废寝忘食的想做一个简单而高效的文本编辑器。你能帮助他吗？为了明确任务目标，可可对“文本编辑器”做了一个抽象的定义： \n\n- `Move k`：将光标移动到第 $k$ 个字符之后，如果 $k=0$，将光标移到文本第一个字符之前。\n- `Insert n (换行) S`：在光标后插入长度为 $n$ 的字符串 $S$，光标位置不变，$n \\ge 1$。\n- `Delete n`：删除光标后的 $n$ 个字符，光标位置不变，$n \\ge 1$。\n- `Rotate n`：反转光标后的 $n$ 个字符，光标位置不变，$n \\ge 1$。\n- `Get`：输出光标后的一个字符，光标位置不变。\n- `Prev`：光标前移一个字符。\n- `Next`：光标后移一个字符。\n\n\n下面是几个定义：\n\n- 文本：由 $0$ 个或多个字符构成的序列。这些字符的 ASCII 码在闭区间 $[32, 126]$ 内或**为换行符**，也就是说，这些字符均为可见字符或空格**或换行符**。\n- 光标：在一段文本中用于指示位置的标记，可以位于文本的第一个字符之前，文本的最后一个字符之后或文本的某两个相邻字符之间。\n- 文本编辑器：为一个可以对一段文本和该文本中的一个光标进行如下七条操作的程序。如果这段文本为空，我们就说这个文本编辑器是空的。 \n\n编写一个程序：\n1. 建立一个空的文本编辑器。\n2. 从输入文件中读入一些操作指令并执行。\n3. 对所有执行过的 `Get` 操作，将指定的内容写入输出文件。", "inputFormat": "输入文件中第一行是指令条数 $N$，以下是需要执行的 $N$ 个操作。除了回车符之外，输入文件的所有字符的 ASCII 码都在闭区间 $[32, 126]$ 内。且行尾没有空格。", "outputFormat": "依次对应输入文件中每条 `Get` 指令的输出，不得有任何多余的字符。**注意：如果 `Get` 指令的输出是换行符，则无需额外换行。**", "hint": "对输入数据我们有如下假定：\n1. `MOVE` 操作不超过 $5\\times 10^4$ 个，`INSERT`, `DELETE` 和 `ROTATE` 操作作的总个数不超过 $6\\times 10^3$，`GET` 操作不超过 $2\\times 10^4$ 个，`PREV` 和 `NEXT` 操作的总个数不超过 $2\\times 10^4$。\n2.  所有 `INSERT` 插入的字符数之和不超过 $2M$（$1M=2^{20}$)。\n3. `DELETE` 操作、`ROTATE` 操作和 `GET` 操作执行时光标后必然有足够的字符。`MOVE`、`PREV`、`NEXT` 操作不会把光标移动到非法位置。\n4. 输入文件没有错误。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2006] Text Editor", "background": "", "description": "These days, Keke is not playing with Kaka, because Keke is obsessed with making a simple and efficient text editor. Can you help him? To clarify the goal, Keke gives an abstract definition of a \"text editor\":\n\n- `Move k`: Move the cursor to the position after the $k$-th character. If $k = 0$, move the cursor to the position before the first character of the text.\n- `Insert n (newline) S`: Insert a string $S$ of length $n$ after the cursor, without moving the cursor. Here $n \\ge 1$.\n- `Delete n`: Delete the $n$ characters after the cursor, without moving the cursor. Here $n \\ge 1$.\n- `Rotate n`: Reverse the $n$ characters after the cursor, without moving the cursor. Here $n \\ge 1$.\n- `Get`: Output the one character after the cursor, without moving the cursor.\n- `Prev`: Move the cursor one character to the left.\n- `Next`: Move the cursor one character to the right.\n\nDefinitions:\n\n- Text: A sequence of $0$ or more characters. Each character’s ASCII code is in the closed interval $[32, 126]$ or is a newline character. That is, characters are all visible characters or spaces, or newlines.\n- Cursor: A marker indicating a position in a text. It can be before the first character, after the last character, or between two adjacent characters.\n- Text editor: A program that performs the above seven operations on a piece of text and a cursor within it. If the text is empty, we say the text editor is empty.\n\nWrite a program to:\n1. Create an empty text editor.\n2. Read a sequence of operation commands from the input file and execute them.\n3. For every executed `Get` operation, write the specified content to the output file.", "inputFormat": "The first line of the input file contains the number of commands $N$. The following lines contain the $N$ operations to execute. Except for newline characters, all characters in the input file have ASCII codes in the closed interval $[32, 126]$. There are no trailing spaces at the end of lines.", "outputFormat": "Output the results corresponding to each `Get` command in the input file, in order, with no extra characters. Note: If the output of a `Get` command is a newline character, no additional newline is needed.", "hint": "For the input, we make the following assumptions:\n1. The number of `MOVE` operations does not exceed $5 \\times 10^4$, the total number of `INSERT`, `DELETE`, and `ROTATE` operations does not exceed $6 \\times 10^3$, the number of `GET` operations does not exceed $2 \\times 10^4$, and the total number of `PREV` and `NEXT` operations does not exceed $2 \\times 10^4$.\n2. The total number of characters inserted by all `INSERT` operations does not exceed $2M$ (where $1M = 2^{20}$).\n3. When executing `DELETE`, `ROTATE`, and `GET`, there are always enough characters after the cursor. `MOVE`, `PREV`, and `NEXT` will not move the cursor to an invalid position.\n4. The input file has no errors.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2006] 文本编辑器", "background": null, "description": "这些日子，可可不和卡卡一起玩了，原来可可正废寝忘食的想做一个简单而高效的文本编辑器。你能帮助他吗？为了明确任务目标，可可对“文本编辑器”做了一个抽象的定义： \n\n- `Move k`：将光标移动到第 $k$ 个字符之后，如果 $k=0$，将光标移到文本第一个字符之前。\n- `Insert n (换行) S`：在光标后插入长度为 $n$ 的字符串 $S$，光标位置不变，$n \\ge 1$。\n- `Delete n`：删除光标后的 $n$ 个字符，光标位置不变，$n \\ge 1$。\n- `Rotate n`：反转光标后的 $n$ 个字符，光标位置不变，$n \\ge 1$。\n- `Get`：输出光标后的一个字符，光标位置不变。\n- `Prev`：光标前移一个字符。\n- `Next`：光标后移一个字符。\n\n\n下面是几个定义：\n\n- 文本：由 $0$ 个或多个字符构成的序列。这些字符的 ASCII 码在闭区间 $[32, 126]$ 内或**为换行符**，也就是说，这些字符均为可见字符或空格**或换行符**。\n- 光标：在一段文本中用于指示位置的标记，可以位于文本的第一个字符之前，文本的最后一个字符之后或文本的某两个相邻字符之间。\n- 文本编辑器：为一个可以对一段文本和该文本中的一个光标进行如下七条操作的程序。如果这段文本为空，我们就说这个文本编辑器是空的。 \n\n编写一个程序：\n1. 建立一个空的文本编辑器。\n2. 从输入文件中读入一些操作指令并执行。\n3. 对所有执行过的 `Get` 操作，将指定的内容写入输出文件。", "inputFormat": "输入文件中第一行是指令条数 $N$，以下是需要执行的 $N$ 个操作。除了回车符之外，输入文件的所有字符的 ASCII 码都在闭区间 $[32, 126]$ 内。且行尾没有空格。", "outputFormat": "依次对应输入文件中每条 `Get` 指令的输出，不得有任何多余的字符。**注意：如果 `Get` 指令的输出是换行符，则无需额外换行。**", "hint": "对输入数据我们有如下假定：\n1. `MOVE` 操作不超过 $5\\times 10^4$ 个，`INSERT`, `DELETE` 和 `ROTATE` 操作作的总个数不超过 $6\\times 10^3$，`GET` 操作不超过 $2\\times 10^4$ 个，`PREV` 和 `NEXT` 操作的总个数不超过 $2\\times 10^4$。\n2.  所有 `INSERT` 插入的字符数之和不超过 $2M$（$1M=2^{20}$)。\n3. `DELETE` 操作、`ROTATE` 操作和 `GET` 操作执行时光标后必然有足够的字符。`MOVE`、`PREV`、`NEXT` 操作不会把光标移动到非法位置。\n4. 输入文件没有错误。", "locale": "zh-CN"}}}
{"pid": "P4568", "type": "P", "difficulty": 4, "samples": [["5 6 1\n0 4\n0 1 5\n1 2 5\n2 3 5\n3 4 5\n2 3 3\n0 2 100", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "各省省选", "吉林", "最短路"], "title": "[JLOI2011] 飞行路线", "background": "", "description": "Alice 和 Bob 现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在 $n$ 个城市设有业务，设这些城市分别标记为 $0$ 到 $n-1$，一共有 $m$ 种航线，每种航线连接两个城市，并且航线有一定的价格。\n\nAlice 和 Bob 现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多 $k$ 种航线上搭乘飞机。那么 Alice 和 Bob 这次出行最少花费多少？", "inputFormat": "第一行三个整数 $n,m,k$，分别表示城市数，航线数和免费乘坐次数。\n\n接下来一行两个整数 $s,t$，分别表示他们出行的起点城市编号和终点城市编号。\n\n接下来 $m$ 行，每行三个整数 $a,b,c$，表示存在一种航线，能从城市 $a$ 到达城市 $b$，或从城市 $b$ 到达城市 $a$，价格为 $c$。", "outputFormat": "输出一行一个整数，为最少花费。", "hint": "#### 数据规模与约定\n\n对于 $30\\%$ 的数据，$2 \\le n \\le 50$，$1 \\le m \\le 300$，$k=0$。\n\n对于 $50\\%$ 的数据，$2 \\le n \\le 600$，$1 \\le m \\le 6\\times10^3$，$0 \\le k \\le 1$。\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 10^4$，$1 \\le m \\le 5\\times 10^4$，$0 \\le k \\le 10$，$0\\le s,t,a,b < n$，$a\\ne b$，$0\\le c\\le 10^3$。\n\n另外存在一组 hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "[JLOI2011] Flight Routes", "background": "", "description": "Alice and Bob are going to travel by plane, and they chose a relatively cheap airline. This airline operates in $n$ cities, labeled $0$ to $n-1$, and there are $m$ routes. Each route connects two cities and has a certain price.\n\nAlice and Bob need to travel from one city to another along these routes, and they may transfer. The airline offers a discount for this trip: they can take flights on at most $k$ routes for free. What is the minimum total cost for their trip?", "inputFormat": "The first line contains three integers $n, m, k$, representing the number of cities, the number of routes, and the maximum number of free rides, respectively.\n\nThe next line contains two integers $s, t$, representing the starting city and the destination city.\n\nThe next $m$ lines each contain three integers $a, b, c$, indicating that there is a bidirectional route between cities $a$ and $b$ with price $c$.", "outputFormat": "Output a single integer on one line, which is the minimum total cost.", "hint": "#### Constraints\n\nFor $30\\%$ of the testdata, $2 \\le n \\le 50$, $1 \\le m \\le 300$, $k=0$.\n\nFor $50\\%$ of the testdata, $2 \\le n \\le 600$, $1 \\le m \\le 6\\times10^3$, $0 \\le k \\le 1$.\n\nFor $100\\%$ of the testdata, $2 \\le n \\le 10^4$, $1 \\le m \\le 5\\times 10^4$, $0 \\le k \\le 10$, $0 \\le s,t,a,b < n$, $a \\ne b$, $0 \\le c \\le 10^3$.\n\nThere is also a set of hack testdata.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JLOI2011] 飞行路线", "background": "", "description": "Alice 和 Bob 现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在 $n$ 个城市设有业务，设这些城市分别标记为 $0$ 到 $n-1$，一共有 $m$ 种航线，每种航线连接两个城市，并且航线有一定的价格。\n\nAlice 和 Bob 现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多 $k$ 种航线上搭乘飞机。那么 Alice 和 Bob 这次出行最少花费多少？", "inputFormat": "第一行三个整数 $n,m,k$，分别表示城市数，航线数和免费乘坐次数。\n\n接下来一行两个整数 $s,t$，分别表示他们出行的起点城市编号和终点城市编号。\n\n接下来 $m$ 行，每行三个整数 $a,b,c$，表示存在一种航线，能从城市 $a$ 到达城市 $b$，或从城市 $b$ 到达城市 $a$，价格为 $c$。", "outputFormat": "输出一行一个整数，为最少花费。", "hint": "#### 数据规模与约定\n\n对于 $30\\%$ 的数据，$2 \\le n \\le 50$，$1 \\le m \\le 300$，$k=0$。\n\n对于 $50\\%$ 的数据，$2 \\le n \\le 600$，$1 \\le m \\le 6\\times10^3$，$0 \\le k \\le 1$。\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 10^4$，$1 \\le m \\le 5\\times 10^4$，$0 \\le k \\le 10$，$0\\le s,t,a,b < n$，$a\\ne b$，$0\\le c\\le 10^3$。\n\n另外存在一组 hack 数据。", "locale": "zh-CN"}}}
{"pid": "P4569", "type": "P", "difficulty": 6, "samples": [["2 4 2\naa\nabb", "0.75\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串", "2011", "北京", "Special Judge", "矩阵乘法", "AC 自动机"], "title": "[BJWC2011] 禁忌", "background": "", "description": "Magic Land上的人们总是提起那个传说：他们的祖先John在那个东方岛屿帮助Koishi与其姐姐Satori最终战平。而后，Koishi恢复了读心的能力……\n\n如今，在John已经成为传说的时代，再次造访那座岛屿的人们却发现Koishi遇到了新麻烦。\n\n这次她遇到了Flandre Scarlet——她拥有可以使用禁忌魔法而不会受到伤害的能力。\n\n为了说明什么是禁忌魔法及其伤害，引入以下概念：\n\n1. 字母集$A$上的每个非空字符串对应了一个魔法。其中$A$是包含了前alphabet个小写字母的集合。\n2. 有一个集合$T$，包含了$N$个字母集$A$上的字符串。$T$中的每一串称为一个禁忌串（Taboo string）\n3. 一个魔法，或等价地，其对应的串$s$因为包含禁忌而对使用者造成的伤害按以下方式确定：把$s$分割成若干段，考虑其中是禁忌串的段的数目，不同的分割可能会有不同的数目，其最大值就是这个伤害。\n\n由于拥有了读心的能力，Koishi总是随机地使用Flandre Scarlet的魔法，可以确定的是，她的魔法正好对应字母集$A$上所有长度为$len$的串。\n\n但是，Flandre Scarlet所使用的一些魔法是带有禁忌的，由于其自身特性，她可以使用禁忌魔法而不受到伤害，而Koishi就不同了。可怜的Koishi每一次使用对方的魔法都面临着受到禁忌伤害的威胁。\n\n你现在需要计算的是如果Koishi使用对方的每一个魔法的概率是均等的，那么每一次随机使用魔法所受到的禁忌伤害的期望值是多少。", "inputFormat": "第一行包含三个正整数 $N$、$len$、$alphabet$。  \n接下来$N$行，每行包含一个串$T_i$，表示禁忌串。", "outputFormat": "一个非负实数，表示所受到禁忌伤害的期望值。你的答案需要保证绝对误差不超过 $10^{-6}$。", "hint": "【样例1解释】\n一共有$2^4 = 16$种不同的魔法。\n\n需要注意的是“aabb”的禁忌伤害是1而不是2。\n\n### 数据范围\n\n有不少于40%的数据中：$N = 1$。  \n100%的数据中$N ≤ 5$，$len ≤10^9$，$1 ≤ alphabet ≤ 26$。  \n数据保证每个串$T_i$的长度不超过$15$，并且不是空串。  \n数据保证每个$T_i$均仅含有前$alphabet$个小写字母。  \n数据保证集合$T$中没有相同的元素，即对任意不同的$i$和$j$，有$T_i \\neq T_j$。", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2011] Taboo", "background": "", "description": "People in Magic Land always mention the legend: their ancestor John helped Koishi and her elder sister Satori on that eastern island, and they ultimately fought to a draw. After that, Koishi recovered her mind-reading ability...\n\nNow, in an age when John has become a legend, people who revisit that island find that Koishi has run into new trouble.\n\nThis time she encounters Flandre Scarlet — she has the ability to use taboo magic without being harmed.\n\nTo explain what taboo magic is and how it causes damage, we introduce the following concepts:\n\n1. Every non-empty string over an alphabet $A$ corresponds to a spell. Here $A$ is the set containing the first $alphabet$ lowercase letters.\n2. There is a set $T$ that contains $N$ strings over the alphabet $A$. Each string in $T$ is called a taboo string (taboo string).\n3. A spell, or equivalently its corresponding string $s$, causes damage to the user due to taboos as follows: partition $s$ into several segments, and consider the number of segments that are taboo strings. Different partitions may yield different counts; the maximum count is the damage.\n\nBecause she can read minds, Koishi always uses Flandre Scarlet’s spells at random. Concretely, her spells correspond exactly to all strings of length $len$ over the alphabet $A$.\n\nHowever, some of Flandre Scarlet’s spells are taboo. Due to her special nature, she can use taboo magic without taking damage, but Koishi cannot. Poor Koishi faces the threat of taboo damage every time she uses one of Flandre’s spells.\n\nYou need to compute the expected taboo damage when Koishi picks each of Flandre’s spells with equal probability, i.e., uniformly over all length-$len$ strings over $A$.", "inputFormat": "The first line contains three positive integers $N$, $len$, $alphabet$.  \nThe next $N$ lines each contain a string $T_i$, representing a taboo string.", "outputFormat": "Output a non-negative real number, the expected taboo damage. Your answer must have an absolute error not exceeding $10^{-6}$.", "hint": "[Explanation for Sample 1]  \nThere are $2^4 = 16$ different spells.\n\nNote that the taboo damage of \"aabb\" is 1 rather than 2.\n\nConstraints\n\n- In at least 40% of the testdata: $N = 1$.\n- For 100% of the testdata: $N \\le 5$, $len \\le 10^9$, $1 \\le alphabet \\le 26$.\n- The testdata guarantees that the length of each string $T_i$ does not exceed $15$, and is non-empty.\n- The testdata guarantees that each $T_i$ contains only the first $alphabet$ lowercase letters.\n- The testdata guarantees that the set $T$ has no duplicate elements; that is, for any distinct $i$ and $j$, $T_i \\ne T_j$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2011] 禁忌", "background": "", "description": "Magic Land上的人们总是提起那个传说：他们的祖先John在那个东方岛屿帮助Koishi与其姐姐Satori最终战平。而后，Koishi恢复了读心的能力……\n\n如今，在John已经成为传说的时代，再次造访那座岛屿的人们却发现Koishi遇到了新麻烦。\n\n这次她遇到了Flandre Scarlet——她拥有可以使用禁忌魔法而不会受到伤害的能力。\n\n为了说明什么是禁忌魔法及其伤害，引入以下概念：\n\n1. 字母集$A$上的每个非空字符串对应了一个魔法。其中$A$是包含了前alphabet个小写字母的集合。\n2. 有一个集合$T$，包含了$N$个字母集$A$上的字符串。$T$中的每一串称为一个禁忌串（Taboo string）\n3. 一个魔法，或等价地，其对应的串$s$因为包含禁忌而对使用者造成的伤害按以下方式确定：把$s$分割成若干段，考虑其中是禁忌串的段的数目，不同的分割可能会有不同的数目，其最大值就是这个伤害。\n\n由于拥有了读心的能力，Koishi总是随机地使用Flandre Scarlet的魔法，可以确定的是，她的魔法正好对应字母集$A$上所有长度为$len$的串。\n\n但是，Flandre Scarlet所使用的一些魔法是带有禁忌的，由于其自身特性，她可以使用禁忌魔法而不受到伤害，而Koishi就不同了。可怜的Koishi每一次使用对方的魔法都面临着受到禁忌伤害的威胁。\n\n你现在需要计算的是如果Koishi使用对方的每一个魔法的概率是均等的，那么每一次随机使用魔法所受到的禁忌伤害的期望值是多少。", "inputFormat": "第一行包含三个正整数 $N$、$len$、$alphabet$。  \n接下来$N$行，每行包含一个串$T_i$，表示禁忌串。", "outputFormat": "一个非负实数，表示所受到禁忌伤害的期望值。你的答案需要保证绝对误差不超过 $10^{-6}$。", "hint": "【样例1解释】\n一共有$2^4 = 16$种不同的魔法。\n\n需要注意的是“aabb”的禁忌伤害是1而不是2。\n\n### 数据范围\n\n有不少于40%的数据中：$N = 1$。  \n100%的数据中$N ≤ 5$，$len ≤10^9$，$1 ≤ alphabet ≤ 26$。  \n数据保证每个串$T_i$的长度不超过$15$，并且不是空串。  \n数据保证每个$T_i$均仅含有前$alphabet$个小写字母。  \n数据保证集合$T$中没有相同的元素，即对任意不同的$i$和$j$，有$T_i \\neq T_j$。", "locale": "zh-CN"}}}
{"pid": "P4570", "type": "P", "difficulty": 5, "samples": [["3 \n1 10 \n2 20 \n3 30", "50"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2011", "北京", "线性基"], "title": "[BJWC2011] 元素", "background": "", "description": "相传，在远古时期，位于西方大陆的 Magic Land 上，人们已经掌握了用魔法矿石炼制法杖的技术。那时人们就认识到，一个法杖的法力取决于使用的矿石。\n\n一般地，矿石越多则法力越强，但物极必反：有时，人们为了获取更强的法力而使用了很多矿石，却在炼制过程中发现魔法矿石全部消失了，从而无法炼制出法杖，这个现象被称为“魔法抵消” 。特别地，如果在炼制过程中使用超过一块同一种矿石，那么一定会发生“魔法抵消”。后来，随着人们认知水平的提高，这个现象得到了很好的解释。经过了大量的实验后，著名法师 Dmitri 发现：如果给现在发现的每一种矿石进行合理的编号（编号为正整数，称为该矿石的元素序号），那么，一个矿石组合会产生“魔法抵消”当且仅当存在一个非空子集，那些矿石的元素序号按位异或起来为零（如果你不清楚什么是异或，请参见下一页的名词解释 ）。\n\n例如，使用两个同样的矿石必将发生“魔法抵消”，因为这两种矿石的元素序号相同，异或起来为零。并且人们有了测定魔力的有效途径，已经知道了：合成出来的法杖的魔力等于每一种矿石的法力之和。人们已经测定了现今发现的所有矿石的法力值，并且通过实验推算出每一种矿石的元素序号。 \n\n现在，给定你以上的矿石信息，请你来计算一下当时可以炼制出的法杖最多有多大的魔力。", "inputFormat": "第一行包含一个正整数 $N$，表示矿石的种类数。\n\n接下来 $N$ 行，每行两个正整数$\\mathrm{Number}_i$ 和 $\\mathrm{Magic}_i$，表示这种矿石的元素序号和魔力值。", "outputFormat": "仅包含一行，一个整数代表最大的魔力值。", "hint": "### 样例解释\n\n由于有“魔法抵消”这一事实，每一种矿石最多使用一块。 \n\n如果使用全部三种矿石，由于三者的元素序号异或起来：$1\\ \\mathrm{xor}\\ 2\\ \\mathrm{xor}\\ 3 = 0$ ，则会发生魔法抵消，得不到法杖。 \n\n可以发现，最佳方案是选择后两种矿石，法力为 $20+30=50$。 \n\n### 数据范围\n\n对于全部的数据：$1\\leq N \\leq 1000$，$1\\leq \\mathrm{Number}_i \\le 10^{18}$，$1\\leq \\mathrm{Magic}_i \\le 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2011] Elements", "background": "", "description": "It is said that in ancient times, on the western continent, Magic Land, people had already mastered the technique of forging staffs from magic ores. People then realized that the power of a staff depended on the ores used.\n\nIn general, the more ores used, the stronger the power; but too much of anything backfires: sometimes people used many ores in pursuit of greater power, only to find during forging that all the magic ores disappeared, making it impossible to forge a staff. This phenomenon is called \"magic cancellation.\" In particular, if more than one ore of the same type is used during forging, \"magic cancellation\" will certainly occur. Later, as understanding improved, this phenomenon was well explained. After many experiments, the renowned mage Dmitri discovered: if we assign a reasonable numbering to each currently known ore type (the numbers are positive integers, called the element index of the ore), then a multiset of ores will produce \"magic cancellation\" if and only if there exists a non-empty subset whose element indices XOR to zero (if you are not familiar with XOR, please see the glossary on the next page).\n\nFor example, using two identical ores will definitely cause \"magic cancellation,\" because the element indices of these two ores are the same and XOR to zero. Moreover, people found an effective way to measure magic power, and it is known that the magic power of the synthesized staff equals the sum of the magic power of each ore used. The magic power values of all currently known ores have been measured, and the element index of each ore has been inferred through experiments.\n\nNow, given the above information about the ores, please compute the maximum possible magic power of a staff that could be forged.", "inputFormat": "The first line contains a positive integer $N$, representing the number of ore types.\n\nThe next $N$ lines each contain two positive integers $\\mathrm{Number}_i$ and $\\mathrm{Magic}_i$, representing the element index and magic power value of this ore type.", "outputFormat": "Output a single line with one integer representing the maximum magic power.", "hint": "### Sample Explanation\n\nDue to the fact of \"magic cancellation,\" at most one ore of each type can be used.\n\nIf all three types of ores are used, since their element indices XOR to $1\\ \\mathrm{xor}\\ 2\\ \\mathrm{xor}\\ 3 = 0$, magic cancellation will occur and no staff can be obtained.\n\nIt can be seen that the optimal plan is to choose the last two types of ores, with magic power $20+30=50$.\n\n### Constraints\n\nFor all testdata: $1 \\leq N \\leq 1000$, $1 \\leq \\mathrm{Number}_i \\le 10^{18}$, $1 \\leq \\mathrm{Magic}_i \\le 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2011] 元素", "background": "", "description": "相传，在远古时期，位于西方大陆的 Magic Land 上，人们已经掌握了用魔法矿石炼制法杖的技术。那时人们就认识到，一个法杖的法力取决于使用的矿石。\n\n一般地，矿石越多则法力越强，但物极必反：有时，人们为了获取更强的法力而使用了很多矿石，却在炼制过程中发现魔法矿石全部消失了，从而无法炼制出法杖，这个现象被称为“魔法抵消” 。特别地，如果在炼制过程中使用超过一块同一种矿石，那么一定会发生“魔法抵消”。后来，随着人们认知水平的提高，这个现象得到了很好的解释。经过了大量的实验后，著名法师 Dmitri 发现：如果给现在发现的每一种矿石进行合理的编号（编号为正整数，称为该矿石的元素序号），那么，一个矿石组合会产生“魔法抵消”当且仅当存在一个非空子集，那些矿石的元素序号按位异或起来为零（如果你不清楚什么是异或，请参见下一页的名词解释 ）。\n\n例如，使用两个同样的矿石必将发生“魔法抵消”，因为这两种矿石的元素序号相同，异或起来为零。并且人们有了测定魔力的有效途径，已经知道了：合成出来的法杖的魔力等于每一种矿石的法力之和。人们已经测定了现今发现的所有矿石的法力值，并且通过实验推算出每一种矿石的元素序号。 \n\n现在，给定你以上的矿石信息，请你来计算一下当时可以炼制出的法杖最多有多大的魔力。", "inputFormat": "第一行包含一个正整数 $N$，表示矿石的种类数。\n\n接下来 $N$ 行，每行两个正整数$\\mathrm{Number}_i$ 和 $\\mathrm{Magic}_i$，表示这种矿石的元素序号和魔力值。", "outputFormat": "仅包含一行，一个整数代表最大的魔力值。", "hint": "### 样例解释\n\n由于有“魔法抵消”这一事实，每一种矿石最多使用一块。 \n\n如果使用全部三种矿石，由于三者的元素序号异或起来：$1\\ \\mathrm{xor}\\ 2\\ \\mathrm{xor}\\ 3 = 0$ ，则会发生魔法抵消，得不到法杖。 \n\n可以发现，最佳方案是选择后两种矿石，法力为 $20+30=50$。 \n\n### 数据范围\n\n对于全部的数据：$1\\leq N \\leq 1000$，$1\\leq \\mathrm{Number}_i \\le 10^{18}$，$1\\leq \\mathrm{Magic}_i \\le 10^4$。", "locale": "zh-CN"}}}
{"pid": "P4571", "type": "P", "difficulty": 5, "samples": [["3 2\n3\n4\n4", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "各省省选", "江苏"], "title": "[JSOI2009] 瓶子和燃料", "background": "", "description": "jyy 一直想着尽快回地球，可惜他飞船的燃料不够了。有一天他又去向火星人要燃料，这次火星人答应了，要 jyy 用飞船上的瓶子来换。jyy 的飞船上共有 $N$ 个瓶子（$1 \\leq N \\leq 1000$），经过协商，火星人只要其中的 $K$ 个。 \n\njyy 将 $K$ 个瓶子交给火星人之后，火星人用它们装一些燃料给 jyy。所有的瓶子都没有刻度，只在瓶口标注了容量，第 $i$ 个瓶子的容量为 $V _ i$（$V _ i$ 为整数，并且满足 $1 \\leq V _ i \\leq 10 ^ 9$） 。火星人比较吝啬，他们并不会把所有的瓶子都装满燃料。他们拿到瓶子后，会跑到燃料库里鼓捣一通，弄出一小点燃料来交差。jyy 当然知道他们会来这一手，于是事先了解了火星人鼓捣的具体内容。\n\n火星人在燃料库里只会做如下的 $3$ 种操作：\n\n1. 将某个瓶子装满燃料；\n2. 将某个瓶子中的燃料全部倒回燃料库；\n3. 将燃料从瓶子 $a$ 倒向瓶子 $b$，直到瓶子 $b$ 满或者瓶子 $a$ 空。燃料倾倒过程中的损耗可以忽略。\n\n火星人拿出的燃料，当然是这些操作能得到的最小正体积。jyy 知道，对于不同的瓶子组合，火星人可能会被迫给出不同体积的燃料。jyy 希望找到最优的瓶子组合，使得火星人给出尽量多的燃料。", "inputFormat": "第一行为两个整数 $N,K$。  \n第 $2 \\sim N$ 行，每行一个整数，第 $i+1$ 行的整数为 $V _ i$。", "outputFormat": "仅一行一个整数，表示火星人给出燃料的最大值。", "hint": "选择第 $2$ 个瓶子和第 $3$ 个瓶子，火星人被迫会给出 $4$ 体积的容量。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2009] Bottles and Fuel", "background": "", "description": "jyy has always wanted to return to Earth as soon as possible, but unfortunately his spaceship does not have enough fuel. One day he went to ask the Martians for fuel again. This time the Martians agreed, asking jyy to trade with the bottles on his spaceship. There are $N$ bottles on jyy's spaceship ($1 \\leq N \\leq 1000$), and after negotiation, the Martians only want $K$ of them.\n\nAfter jyy gives $K$ bottles to the Martians, they use them to fill some fuel for jyy. None of the bottles have graduation marks; only the capacity is labeled at the mouth. The capacity of the $i$-th bottle is $V _ i$ ($V _ i$ is an integer and satisfies $1 \\leq V _ i \\leq 10 ^ 9$). The Martians are stingy and will not fill all bottles to the brim. After they take the bottles, they will fiddle around in the fuel depot and produce a tiny amount of fuel just to get by. jyy certainly knows this trick, so he learned in advance exactly what the Martians do.\n\nIn the fuel depot, the Martians only perform the following $3$ types of operations:\n1. Fill some bottle completely with fuel;\n2. Pour all the fuel in some bottle back into the depot;\n3. Pour fuel from bottle $a$ into bottle $b$ until bottle $b$ is full or bottle $a$ is empty. Loss during the pouring process can be ignored.\n\nThe fuel they hand over is, of course, the smallest positive volume obtainable by these operations. jyy knows that for different choices of bottles, the Martians might be forced to give different volumes of fuel. jyy wants to find the optimal set of bottles so that the Martians are forced to give as much fuel as possible.", "inputFormat": "The first line contains two integers $N, K$.\nThe next $N$ lines each contain one integer; the integer on the $(i+1)$-th line is $V _ i$.", "outputFormat": "Output a single integer on one line, representing the maximum amount of fuel the Martians will be forced to give.", "hint": "Choose the 2nd and 3rd bottles; the Martians will be forced to give a volume of 4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2009] 瓶子和燃料", "background": "", "description": "jyy 一直想着尽快回地球，可惜他飞船的燃料不够了。有一天他又去向火星人要燃料，这次火星人答应了，要 jyy 用飞船上的瓶子来换。jyy 的飞船上共有 $N$ 个瓶子（$1 \\leq N \\leq 1000$），经过协商，火星人只要其中的 $K$ 个。 \n\njyy 将 $K$ 个瓶子交给火星人之后，火星人用它们装一些燃料给 jyy。所有的瓶子都没有刻度，只在瓶口标注了容量，第 $i$ 个瓶子的容量为 $V _ i$（$V _ i$ 为整数，并且满足 $1 \\leq V _ i \\leq 10 ^ 9$） 。火星人比较吝啬，他们并不会把所有的瓶子都装满燃料。他们拿到瓶子后，会跑到燃料库里鼓捣一通，弄出一小点燃料来交差。jyy 当然知道他们会来这一手，于是事先了解了火星人鼓捣的具体内容。\n\n火星人在燃料库里只会做如下的 $3$ 种操作：\n\n1. 将某个瓶子装满燃料；\n2. 将某个瓶子中的燃料全部倒回燃料库；\n3. 将燃料从瓶子 $a$ 倒向瓶子 $b$，直到瓶子 $b$ 满或者瓶子 $a$ 空。燃料倾倒过程中的损耗可以忽略。\n\n火星人拿出的燃料，当然是这些操作能得到的最小正体积。jyy 知道，对于不同的瓶子组合，火星人可能会被迫给出不同体积的燃料。jyy 希望找到最优的瓶子组合，使得火星人给出尽量多的燃料。", "inputFormat": "第一行为两个整数 $N,K$。  \n第 $2 \\sim N$ 行，每行一个整数，第 $i+1$ 行的整数为 $V _ i$。", "outputFormat": "仅一行一个整数，表示火星人给出燃料的最大值。", "hint": "选择第 $2$ 个瓶子和第 $3$ 个瓶子，火星人被迫会给出 $4$ 体积的容量。", "locale": "zh-CN"}}}
{"pid": "P4572", "type": "P", "difficulty": 6, "samples": [["7\n1 2\n1 3\n2 5\n2 6\n7 2\n4 1", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2013", "各省省选", "江苏"], "title": "[JSOI2013] 哈利波特与死亡圣器", "background": "", "description": "伏地魔的黑暗势力控制了魔法部与霍格沃茨魔法学校之后，哈利与罗恩、赫敏不得不逃亡在外，隐形遁迹。为了完成校长邓布利多的遗命，一直在暗中寻机销毁伏地魔魂器的哈利，意外地获悉如果他们能够拥有传说中的三件死亡圣器，伏地魔将必死无疑。\n\n在凤凰社成员的帮助下，哈利一行人重新掌控了霍格沃茨。然而此举激怒了伏地魔，他很快率领大批食死徒和黑暗生物向霍格沃茨进军。麦格教授紧急疏散了霍格沃茨的学生，并开始了守卫霍格沃茨的战斗。\n\n霍格沃茨魔法学校的主要建筑共有 $n$ 处，我们编号为 $1$ 到 $n$，这些建筑间由魔法道路连接，整体呈树状分布，即任意两个建筑间有且仅有一条路径相连（路径可以是一条或多条道路组成）。霍格沃茨历经多年风雨，每个建筑自身有许多保护魔法，比如“石墩触动咒”、“降敌陷阱咒”、“统统加护咒”等，只需有人前往施用咒语即能保卫建筑。\n\n现在，伏地魔大军已经到达 $1$ 号建筑——学校大门，凤凰社成员也已经在大门迎战，并且已经启用了大门的保护魔法。然而伏地魔大军势力壮大，保护魔法只能延缓大军的进攻锋芒，他们仍能用一个小时攻克一个建筑，随后整个大军便随机前往与之相邻的另一个建筑（兵贵神速，大军移动过程不需要时间；兵法无常，他们有可能前往已经攻克的建筑）。\n\n目前除了 $1$ 号建筑，其他建筑的保护魔法都尚未被启用，凤凰社决定派出一些成员去其他建筑施用咒语来启动保护魔法。每个凤凰社成员可以瞬间达到任意一个建筑，并用一个小时完成对该建筑保护魔法的启用，之后可以再前往其他的建筑。他们的任务是，保证不论伏地魔大军如何行动，大军所到建筑的保护魔法都已经启用。为了集中更多力量直接打击伏地魔大军，凤凰社希望派出施用咒语的成员数尽可能少。\n\n请你计算，至少需要派出多少位成员。\n\n注：\n\n- 伏地魔大军到达 $1$ 号建筑开始攻击的同时，凤凰社派出成员去其他建筑施咒。\n\n- 当大军攻克某个建筑后，凤凰社成员可以在知道大军下一个小时去哪个建筑的情况下，再决定他们去哪些建筑施咒。这个过程也不需要时间。\n\n- 已经启用过保护魔法的建筑无需再施咒，即便大军攻克该建筑以后某个时候又回到这个建筑，大军也会在这个建筑持续攻击一个小时后再离开。", "inputFormat": "第一行一个整数 $n$，表示建筑的数量。\n\n接下来 $n-1$ 行，每行两个整数 $u,v$，表示建筑 $u$ 和建筑 $v$ 之间有一条魔法道路。\n", "outputFormat": "一行一个整数，表示最少需要派出施用咒语的成员数。", "hint": "### 数据范围\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 3\\times 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JSOI2013] 哈利波特与死亡圣器", "background": "", "description": "伏地魔的黑暗势力控制了魔法部与霍格沃茨魔法学校之后，哈利与罗恩、赫敏不得不逃亡在外，隐形遁迹。为了完成校长邓布利多的遗命，一直在暗中寻机销毁伏地魔魂器的哈利，意外地获悉如果他们能够拥有传说中的三件死亡圣器，伏地魔将必死无疑。\n\n在凤凰社成员的帮助下，哈利一行人重新掌控了霍格沃茨。然而此举激怒了伏地魔，他很快率领大批食死徒和黑暗生物向霍格沃茨进军。麦格教授紧急疏散了霍格沃茨的学生，并开始了守卫霍格沃茨的战斗。\n\n霍格沃茨魔法学校的主要建筑共有 $n$ 处，我们编号为 $1$ 到 $n$，这些建筑间由魔法道路连接，整体呈树状分布，即任意两个建筑间有且仅有一条路径相连（路径可以是一条或多条道路组成）。霍格沃茨历经多年风雨，每个建筑自身有许多保护魔法，比如“石墩触动咒”、“降敌陷阱咒”、“统统加护咒”等，只需有人前往施用咒语即能保卫建筑。\n\n现在，伏地魔大军已经到达 $1$ 号建筑——学校大门，凤凰社成员也已经在大门迎战，并且已经启用了大门的保护魔法。然而伏地魔大军势力壮大，保护魔法只能延缓大军的进攻锋芒，他们仍能用一个小时攻克一个建筑，随后整个大军便随机前往与之相邻的另一个建筑（兵贵神速，大军移动过程不需要时间；兵法无常，他们有可能前往已经攻克的建筑）。\n\n目前除了 $1$ 号建筑，其他建筑的保护魔法都尚未被启用，凤凰社决定派出一些成员去其他建筑施用咒语来启动保护魔法。每个凤凰社成员可以瞬间达到任意一个建筑，并用一个小时完成对该建筑保护魔法的启用，之后可以再前往其他的建筑。他们的任务是，保证不论伏地魔大军如何行动，大军所到建筑的保护魔法都已经启用。为了集中更多力量直接打击伏地魔大军，凤凰社希望派出施用咒语的成员数尽可能少。\n\n请你计算，至少需要派出多少位成员。\n\n注：\n\n- 伏地魔大军到达 $1$ 号建筑开始攻击的同时，凤凰社派出成员去其他建筑施咒。\n\n- 当大军攻克某个建筑后，凤凰社成员可以在知道大军下一个小时去哪个建筑的情况下，再决定他们去哪些建筑施咒。这个过程也不需要时间。\n\n- 已经启用过保护魔法的建筑无需再施咒，即便大军攻克该建筑以后某个时候又回到这个建筑，大军也会在这个建筑持续攻击一个小时后再离开。", "inputFormat": "第一行一个整数 $n$，表示建筑的数量。\n\n接下来 $n-1$ 行，每行两个整数 $u,v$，表示建筑 $u$ 和建筑 $v$ 之间有一条魔法道路。\n", "outputFormat": "一行一个整数，表示最少需要派出施用咒语的成员数。", "hint": "### 数据范围\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 3\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P4573", "type": "P", "difficulty": 5, "samples": [["> < < < > <\nv ^ v v ^ v ^ ^ v\n< < < > < <\nv ^ v ^ v v ^ ^ v\n< < < < > >\n< > > > < >\nv v ^ ^ v ^ ^ v v\n< > > < > >\n^ v v v ^ v v ^ v\n> < < > > >\n< > > > > <\nv v v v ^ ^ ^ ^ ^\n> < < < < <\n^ ^ ^ ^ ^ v v v ^\n> > < > < <", "5 3 9 4 6 8 2 1 7\n2 4 8 1 9 7 3 5 6\n1 6 7 2 3 5 9 8 4\n6 8 1 7 4 2 5 9 3\n3 7 5 9 1 6 8 4 2\n9 2 4 5 8 3 7 6 1\n7 9 6 8 2 1 4 3 5\n4 1 2 3 5 9 6 7 8\n8 5 3 6 7 4 1 2 9"], ["< > > < > <\nv v ^ ^ v v ^ ^ ^\n< < > < > <\n^ ^ ^ v ^ ^ ^ v v\n< < < < > > \n> < > > > >\nv ^ ^ ^ ^ v v v ^\n> > > > < >\nv v ^ v ^ v ^ v ^\n> < < > > > \n< < < < > <\nv ^ v v v v ^ ^ v\n< > > < < >\n^ v v v ^ v ^ v v\n< > < > < >", "4 9 1 7 3 6 5 2 8\n2 3 7 8 1 5 6 4 9\n5 6 8 2 4 9 7 3 1\n9 1 3 6 5 4 8 7 2\n8 5 4 9 7 2 1 6 3\n7 2 6 3 8 1 9 5 4\n3 4 9 5 6 8 2 1 7\n1 8 5 4 2 7 3 9 6\n6 7 2 1 9 3 4 8 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2013", "重庆", "各省省选", "枚举", "深度优先搜索 DFS"], "title": "[CQOI2013] 新数独", "background": "", "description": "下面是一个没有数字，只有大小关系（没错，那些尖角都是“大于符号”）！的数独：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wm5lvhj6.png)\n\n除了大小关系外（注意相邻格子不能相同），还需要满足通常的数独规则：\n\n * 每个格子都是 $1\\sim 9$ 的数字；\n * 每行都是 $1 \\sim 9$ 的排列；\n * 每列都是 $1 \\sim 9$ 的排列；\n * 每个 $3\\times 3$ 的子矩阵（上图中用粗线隔开，一共有 $3\\times 3$ 个这样的子矩阵）都是 $1\\sim 9$ 的排列。\n \n 如下图所示，是上述提到的数独的唯一一种填法：\n \n ![](https://cdn.luogu.com.cn/upload/image_hosting/73a6a29i.png)\n \n 为了美观，每个 $3\\times 3$ 子矩阵的**所有 $12$ 对**相邻格子的大小关系都将给出。", "inputFormat": "一共 $15$ 行，包含一个新数独的实例。第 $1,3,5,6,8,10,11,13,15$ 行包含左右方向的符号（< 和 >），其余行包含上下方向的符号（^ 和 v）", "outputFormat": "包含 $9$ 行，每行 $9$ 个 $1\\sim 9$ 的数字，以空格隔开。输入保证唯一解。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2013] New Sudoku", "background": "", "description": "Below is a Sudoku with no digits, only inequality relations (yes, those chevrons are all \"greater-than\" signs):\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wm5lvhj6.png)\n\nBesides the inequality relations (note that adjacent cells cannot be equal), it must also satisfy the usual Sudoku rules:\n- Each cell is a digit from $1 \\sim 9$.\n- Each row is a permutation of $1 \\sim 9$.\n- Each column is a permutation of $1 \\sim 9$.\n- Each $3 \\times 3$ subgrid (separated by bold lines in the figure above; there are $3 \\times 3$ such subgrids) is a permutation of $1 \\sim 9$.\n \nAs shown below, there is exactly one way to fill the Sudoku above:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/73a6a29i.png)\n\nFor neatness, for each $3 \\times 3$ subgrid, the inequality relations for **all $12$ pairs** of adjacent cells will be given.", "inputFormat": "There are $15$ lines in total, describing one instance of the new Sudoku. Lines $1, 3, 5, 6, 8, 10, 11, 13, 15$ contain left-right symbols (< and >), and the other lines contain up-down symbols (^ and v).", "outputFormat": "Output $9$ lines, each containing $9$ digits from $1 \\sim 9$, separated by spaces. The input guarantees a unique solution.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2013] 新数独", "background": "", "description": "下面是一个没有数字，只有大小关系（没错，那些尖角都是“大于符号”）！的数独：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wm5lvhj6.png)\n\n除了大小关系外（注意相邻格子不能相同），还需要满足通常的数独规则：\n\n * 每个格子都是 $1\\sim 9$ 的数字；\n * 每行都是 $1 \\sim 9$ 的排列；\n * 每列都是 $1 \\sim 9$ 的排列；\n * 每个 $3\\times 3$ 的子矩阵（上图中用粗线隔开，一共有 $3\\times 3$ 个这样的子矩阵）都是 $1\\sim 9$ 的排列。\n \n 如下图所示，是上述提到的数独的唯一一种填法：\n \n ![](https://cdn.luogu.com.cn/upload/image_hosting/73a6a29i.png)\n \n 为了美观，每个 $3\\times 3$ 子矩阵的**所有 $12$ 对**相邻格子的大小关系都将给出。", "inputFormat": "一共 $15$ 行，包含一个新数独的实例。第 $1,3,5,6,8,10,11,13,15$ 行包含左右方向的符号（< 和 >），其余行包含上下方向的符号（^ 和 v）", "outputFormat": "包含 $9$ 行，每行 $9$ 个 $1\\sim 9$ 的数字，以空格隔开。输入保证唯一解。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4574", "type": "P", "difficulty": 5, "samples": [["7 6 9", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2013", "重庆", "各省省选", "枚举", "进制"], "title": "[CQOI2013] 二进制A+B", "background": null, "description": "输入三个整数 $a, b, c$，把它们写成无前导 $0$ 的二进制整数。\n\n比如 $a=7, b=6, c=9$，写成二进制为 $a=(111)_2, b=(110)_2, c=(1001)_2$。\n\n接下来以位数最多的为基准，其他整数在前面添加前导 $0$，使得 $a, b, c$ 拥有相同的位数。比如在刚才的例子中，添加完前导 $0$ 后为 $a=(0111)_2, b=(0110)_2, c=(1001)_2$。\n\n最后，把 $a, b, c$ 的各位进行重排，得到 $a', b', c'$，使得 $a'+b'=c'$。比如在刚才的例子中，可以这样重排：$a'=(0111)_2, b'=(0011)_2, c'=(1010)_2$。\n\n你的任务是让 $c'$ 最小。如果无解，输出 $-1$。", "inputFormat": "输入仅一行，包含三个整数 $a, b, c$。", "outputFormat": "输出仅一行，为 $c'$ 的最小值。", "hint": "对于所有的测试数据，$a,b,c \\le 2^{30}$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2013] Binary A+B", "background": "", "description": "You are given three integers $a, b, c$ and write them as binary integers without leading zeros.\n\nFor example, when $a=7, b=6, c=9$, their binary forms are $a=(111)_2, b=(110)_2, c=(1001)_2$.\n\nNext, pad the shorter ones with leading zeros so that $a, b, c$ have the same number of bits as the longest one. In the example above, after padding we get $a=(0111)_2, b=(0110)_2, c=(1001)_2$.\n\nFinally, rearrange the bits of $a, b, c$ to obtain $a', b', c'$ such that $a' + b' = c'$. In the example above, one possible rearrangement is $a'=(0111)_2, b'=(0011)_2, c'=(1010)_2$.\n\nYour task is to make $c'$ as small as possible. If there is no solution, output $-1$.", "inputFormat": "The input contains a single line with three integers $a, b, c$.", "outputFormat": "Output a single line with the minimum value of $c'$.", "hint": "For all testdata, $a,b,c \\le 2^{30}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2013] 二进制A+B", "background": null, "description": "输入三个整数 $a, b, c$，把它们写成无前导 $0$ 的二进制整数。\n\n比如 $a=7, b=6, c=9$，写成二进制为 $a=(111)_2, b=(110)_2, c=(1001)_2$。\n\n接下来以位数最多的为基准，其他整数在前面添加前导 $0$，使得 $a, b, c$ 拥有相同的位数。比如在刚才的例子中，添加完前导 $0$ 后为 $a=(0111)_2, b=(0110)_2, c=(1001)_2$。\n\n最后，把 $a, b, c$ 的各位进行重排，得到 $a', b', c'$，使得 $a'+b'=c'$。比如在刚才的例子中，可以这样重排：$a'=(0111)_2, b'=(0011)_2, c'=(1010)_2$。\n\n你的任务是让 $c'$ 最小。如果无解，输出 $-1$。", "inputFormat": "输入仅一行，包含三个整数 $a, b, c$。", "outputFormat": "输出仅一行，为 $c'$ 的最小值。", "hint": "对于所有的测试数据，$a,b,c \\le 2^{30}$。", "locale": "zh-CN"}}}
{"pid": "P4575", "type": "P", "difficulty": 4, "samples": [["4\n2\n1\n0 1\n5\n0\n4\n3\n0 1\n2 1\n2 3\n3\n9\n0 1\n0 2\n1 2\n1 0\n2 0\n2 1\n0 0\n1 1\n2 2", "Yes\nYes\nNo\nYes"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2013", "重庆", "各省省选"], "title": "[CQOI2013] 图的逆变换", "background": "", "description": "给一个 $n$ 结点 $m$ 条边的有向图 $D$，可以这样构造图 $E$：给 $D$ 的每条边 $(u,v)$，在 $E$ 中建立一个点 $uv$，然后对于 $D$ 中的两条边 $(u,v)$ 和 $(v,w)$，在 $E$ 中从 $uv$ 向 $vw$ 连一条有向边。$E$ 中不含有其他点和边。\n\n输入 $E$，你的任务是判断是否存在相应的 $D$。\n\n注意，$D$ 可以有重边和自环。", "inputFormat": "第一行包含测试数据个数 $T$（$T\\leq 10$）。\n\n对于每组数据：\n\n第一行一个整数 $m$（$0\\le m\\le300$），表示 $D$ 的边数（即 $E$ 的点数）。\n\n第二行一个整数 $k$，表示 $E$ 的边数。\n\n以下 $k$ 行每行两个整数 $x, y$，表示 $E$ 中有一条有向边 $(x,y)$。$E$ 中的点编号为 $0\\sim m-1$。", "outputFormat": "对于每组数据输出一行。如果存在，输出 `Yes`，否则输出 `No`。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2013] Inverse Transformation of a Graph", "background": "", "description": "Given a directed graph $D$ with $n$ vertices and $m$ edges, construct a graph $E$ as follows: for each edge $(u,v)$ in $D$, create a vertex $uv$ in $E$; then for any two edges $(u,v)$ and $(v,w)$ in $D$, add a directed edge from $uv$ to $vw$ in $E$. No other vertices or edges exist in $E$.\n\nGiven $E$, your task is to determine whether there exists a corresponding $D$.\n\nNote that $D$ may have parallel edges and self-loops.", "inputFormat": "The first line contains the number of test cases $T$ ($T\\leq 10$).\n\nFor each test case:\n\nThe first line contains an integer $m$ ($0\\le m\\le 300$), the number of edges in $D$ (i.e., the number of vertices in $E$).\n\nThe second line contains an integer $k$, the number of edges in $E$.\n\nEach of the following $k$ lines contains two integers $x, y$, indicating that there is a directed edge $(x,y)$ in $E$. The vertices in $E$ are numbered from $0$ to $m-1$.", "outputFormat": "For each test case, output one line. If it exists, output `Yes`; otherwise, output `No`.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2013] 图的逆变换", "background": "", "description": "给一个 $n$ 结点 $m$ 条边的有向图 $D$，可以这样构造图 $E$：给 $D$ 的每条边 $(u,v)$，在 $E$ 中建立一个点 $uv$，然后对于 $D$ 中的两条边 $(u,v)$ 和 $(v,w)$，在 $E$ 中从 $uv$ 向 $vw$ 连一条有向边。$E$ 中不含有其他点和边。\n\n输入 $E$，你的任务是判断是否存在相应的 $D$。\n\n注意，$D$ 可以有重边和自环。", "inputFormat": "第一行包含测试数据个数 $T$（$T\\leq 10$）。\n\n对于每组数据：\n\n第一行一个整数 $m$（$0\\le m\\le300$），表示 $D$ 的边数（即 $E$ 的点数）。\n\n第二行一个整数 $k$，表示 $E$ 的边数。\n\n以下 $k$ 行每行两个整数 $x, y$，表示 $E$ 中有一条有向边 $(x,y)$。$E$ 中的点编号为 $0\\sim m-1$。", "outputFormat": "对于每组数据输出一行。如果存在，输出 `Yes`，否则输出 `No`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4576", "type": "P", "difficulty": 4, "samples": [["2 1 1 2 2", "BLACK 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "博弈论", "2013", "重庆", "各省省选"], "title": "[CQOI2013] 棋盘游戏", "background": null, "description": "一个 $n \\times n$（$ n \\ge 2 $）棋盘上有黑白棋子各一枚。游戏者 A 和 B 轮流移动棋子，A 先走。\n\n * A 的移动规则：只能移动白棋子。可以往上下左右四个方向之一移动一格。\n \n * B 的移动规则：只能移动黑棋子。可以往上下左右四个方向之一移动一格或者两格。\n \n和通常的“吃子”规则一样，当某游戏者把自己的棋子移动到对方棋子所在的格子时，他就赢了。\n\n两个游戏者都很聪明，当可以获胜时会尽快获胜，只能输掉的时候会尽量拖延时间。你的任务是判断谁会赢，需要多少回合。\n\n\n比如 $n=2$，白棋子在 $(1,1)$，黑棋子在 $(2,2)$，那么虽然 A 有两种走法，第二个回合B总能取胜。", "inputFormat": "仅一行，包含五个整数 $n$, $r_1$, $c_1$, $r_2$, $c_2$，即棋盘大小和棋子位置。\n\n白色棋子在 $(r_1,c_1)$，黑色棋子在 $(r_2,c_2)$ $(1 \\le r_1,c_1,r_2,c_2 \\le n)$。黑白棋子的位置保证不相同。", "outputFormat": "仅一行，即游戏结果。\n\n如果 A 获胜，输出 `WHITE x`;\n\n如果 B 获胜，输出 `BLACK x`;\n\n如果二者都没有必胜策略,输出 `DRAW`。\n\n其中 $x$ 表示移动的步数。", "hint": "对于 $100\\%$ 的数据，$n \\le 20$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2013] Chessboard Game", "background": "", "description": "On an $n \\times n$ ($n \\ge 2$) board, there is one white piece and one black piece. Players A and B move alternately, with A moving first.\n\n- A’s move rule: A can only move the white piece. It can move exactly one square in one of the four orthogonal directions (up, down, left, right).\n- B’s move rule: B can only move the black piece. It can move either one or two squares in one of the four orthogonal directions (up, down, left, right).\n\nAs in the usual “capture” rule, when a player moves their piece onto the square occupied by the opponent’s piece, they win.\n\nBoth players are smart: when a win is possible, they will win as soon as possible; when they can only lose, they will delay as much as possible. Your task is to determine who will win and in how many moves.\n\nFor example, when $n=2$, the white piece is at $(1,1)$ and the black piece is at $(2,2)$. Although A has two legal moves, B can always win on the second move.", "inputFormat": "A single line containing five integers $n$, $r_1$, $c_1$, $r_2$, $c_2$, representing the board size and the positions of the pieces.\n\nThe white piece is at $(r_1,c_1)$, and the black piece is at $(r_2,c_2)$ $(1 \\le r_1,c_1,r_2,c_2 \\le n)$. The positions of the white and black pieces are guaranteed to be different.", "outputFormat": "Output a single line: the game result.\n\nIf A wins, output `WHITE x`.\n\nIf B wins, output `BLACK x`.\n\nIf neither player has a forced win, output `DRAW`.\n\nHere $x$ is the number of moves.", "hint": "For 100% of the testdata, $n \\le 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2013] 棋盘游戏", "background": null, "description": "一个 $n \\times n$（$ n \\ge 2 $）棋盘上有黑白棋子各一枚。游戏者 A 和 B 轮流移动棋子，A 先走。\n\n * A 的移动规则：只能移动白棋子。可以往上下左右四个方向之一移动一格。\n \n * B 的移动规则：只能移动黑棋子。可以往上下左右四个方向之一移动一格或者两格。\n \n和通常的“吃子”规则一样，当某游戏者把自己的棋子移动到对方棋子所在的格子时，他就赢了。\n\n两个游戏者都很聪明，当可以获胜时会尽快获胜，只能输掉的时候会尽量拖延时间。你的任务是判断谁会赢，需要多少回合。\n\n\n比如 $n=2$，白棋子在 $(1,1)$，黑棋子在 $(2,2)$，那么虽然 A 有两种走法，第二个回合B总能取胜。", "inputFormat": "仅一行，包含五个整数 $n$, $r_1$, $c_1$, $r_2$, $c_2$，即棋盘大小和棋子位置。\n\n白色棋子在 $(r_1,c_1)$，黑色棋子在 $(r_2,c_2)$ $(1 \\le r_1,c_1,r_2,c_2 \\le n)$。黑白棋子的位置保证不相同。", "outputFormat": "仅一行，即游戏结果。\n\n如果 A 获胜，输出 `WHITE x`;\n\n如果 B 获胜，输出 `BLACK x`;\n\n如果二者都没有必胜策略,输出 `DRAW`。\n\n其中 $x$ 表示移动的步数。", "hint": "对于 $100\\%$ 的数据，$n \\le 20$。", "locale": "zh-CN"}}}
{"pid": "P4577", "type": "P", "difficulty": 6, "samples": [["6\n2 5 1 3 5 4\n1\n1\n2\n2\n4", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2018", "线段树", "各省省选", "福建", "树形 DP", "差分", "线段树合并", "启发式合并"], "title": "[FJOI2018] 领导集团问题", "background": null, "description": "一个公司的组织领导架构可以用一棵领导树来表示。公司的每个成员对应于树中一个结点 $v_i$，且每个成员都有相应的级别 $w_i$。越高层的领导，其级别值 $w_i$ 越小。树中任何两个结点之间有边相连，则表示与结点相应的两个成员属于同一部门。领导集团问题就是根据公司的领导树确定公司的最大部门。换句话说，也就是在领导树中寻找最大的部门结点子集，使得的结点 $v_i$ 和 $v_j$，如果 $v_i$ 是 $v_j$ 的子孙结点，则 $w_i \\ge w_j$。\n\n编程任务：对于任意对于给定的领导树，计算出领导树中最大的部门结点子集。", "inputFormat": "第一行有一个正整数 $n$，表示领导树的结点数。\n\n接下来的一行中有 $n$ 个整数。第 $i$ 个数表示 $w_i$。\n\n再接下来的 $n-1$ 行中，第 $i$ 行有一个整数 $v_i$ 表示 $v_i$ 是 $i+1$ 的双亲结点。", "outputFormat": "输出找到的最大的部门的成员数。", "hint": "对于 $10\\%$ 的数据，$n\\le 20$；\n\n对于 $40\\%$ 的数据，$n\\le 2000$；\n\n对于 $100\\%$ 的数据，$1\\le n\\le 2\\times 10 ^ 5$，$0 < w_i \\le 10 ^ 9$。", "locale": "zh-CN", "translations": {"en": {"title": "[FJOI2018] Leadership Group Problem", "background": "", "description": "A company’s leadership structure can be represented by a leadership tree. Each company member corresponds to a node $v_i$ in the tree, and each member has a corresponding level $w_i$. The higher the leader is in the hierarchy, the smaller their level value $w_i$ is. If there is an edge between any two nodes in the tree, it means the two corresponding members belong to the same department.\n\nThe leadership group problem is to determine the company’s largest department based on the leadership tree. In other words, we need to find the largest subset of nodes in the leadership tree such that for any nodes $v_i$ and $v_j$, if $v_i$ is a descendant of $v_j$, then $w_i \\ge w_j$.\n\nProgramming task: For any given leadership tree, compute the size of the largest valid department node subset in the leadership tree.", "inputFormat": "The first line contains a positive integer $n$, denoting the number of nodes in the leadership tree.\n\nThe next line contains $n$ integers. The $i$-th number denotes $w_i$.\n\nIn the following $n - 1$ lines, the $i$-th line contains an integer $v_i$, meaning that $v_i$ is the parent of node $i + 1$.", "outputFormat": "Output the number of members in the largest department found.", "hint": "For $10\\%$ of the testdata, $n \\le 20$.\n\nFor $40\\%$ of the testdata, $n \\le 2000$.\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 2 \\times 10 ^ 5$, $0 < w_i \\le 10 ^ 9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[FJOI2018] 领导集团问题", "background": null, "description": "一个公司的组织领导架构可以用一棵领导树来表示。公司的每个成员对应于树中一个结点 $v_i$，且每个成员都有相应的级别 $w_i$。越高层的领导，其级别值 $w_i$ 越小。树中任何两个结点之间有边相连，则表示与结点相应的两个成员属于同一部门。领导集团问题就是根据公司的领导树确定公司的最大部门。换句话说，也就是在领导树中寻找最大的部门结点子集，使得的结点 $v_i$ 和 $v_j$，如果 $v_i$ 是 $v_j$ 的子孙结点，则 $w_i \\ge w_j$。\n\n编程任务：对于任意对于给定的领导树，计算出领导树中最大的部门结点子集。", "inputFormat": "第一行有一个正整数 $n$，表示领导树的结点数。\n\n接下来的一行中有 $n$ 个整数。第 $i$ 个数表示 $w_i$。\n\n再接下来的 $n-1$ 行中，第 $i$ 行有一个整数 $v_i$ 表示 $v_i$ 是 $i+1$ 的双亲结点。", "outputFormat": "输出找到的最大的部门的成员数。", "hint": "对于 $10\\%$ 的数据，$n\\le 20$；\n\n对于 $40\\%$ 的数据，$n\\le 2000$；\n\n对于 $100\\%$ 的数据，$1\\le n\\le 2\\times 10 ^ 5$，$0 < w_i \\le 10 ^ 9$。", "locale": "zh-CN"}}}
{"pid": "P4578", "type": "P", "difficulty": 5, "samples": [["2\n2 2 4\n1 1 0\n1 2 0\n2 1 2\n2 2 2\n2 2 4\n1 1 0\n1 2 0\n2 1 2\n2 2 1", "Yes\nNo"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["图论", "2018", "各省省选", "福建", "枚举", "差分约束"], "title": "[FJOI2018] 所罗门王的宝藏", "background": "", "description": "据古代传说记载，所罗门王既是智慧的代表，又是财富的象征。他建立了强大而富有的国家，聚集了大批的黄金象牙和钻石，并把这些价值连城的珍宝藏在一个神秘的地方，这就是世人瞩目的“所罗门王的宝藏”。多少个世纪以来，人们一直在寻找这批早已失落的古代文明宝藏，寻找盛产黄金和钻石的宝地。曾经追寻所罗门王宝藏的冒险者们都一去不回，至今没人解开这个谜题。亨利男爵在一次幸运的旅途中意外地得到了三百年前一位葡萄牙贵族留下的写在羊皮卷上的所罗门王的藏宝图和一本寻宝秘籍。在这张藏宝图的诱惑下，亨利男爵邀请约翰上校和勇敢的猎象人夸特曼开始了寻找埋葬在黑暗地底的所罗门王宝藏的艰险历程。他们横穿渺无边际的沙漠和浓荫蔽日的原始森林，越过汹涌澎湃的激流险滩，翻越高耸入云的峻岭雪山，饱尝沙漠的酷热和冰雪严寒，在藏宝图的指引下来到非洲一个原始的神秘国度库库安纳。这里有残酷的人殉制度，有一个拥有一千个妻室的独眼暴君特瓦拉，有像兀鹫一般丑恶诡诈老而不死的女巫加古尔，还有美丽聪慧的绝代佳人弗拉塔。在这片陌生而又险象环生的土地上三位寻宝英雄历尽艰辛，终于在绝代佳人弗拉塔的帮助下在海底深处找到了珍藏这批价值连城宝藏的巨大的藏宝洞。然而在女巫加古尔的精心策划下，一场灭顶之灾正在悄悄逼近。\n\n藏宝洞的洞门十分坚固且洞门紧闭，如果不知道开启洞门的秘密是无法打开藏宝洞的洞门。在藏宝洞的洞门一侧有一个奇怪的矩形密码阵列。根据寻宝秘籍的记载，在密码阵列每行的左侧和每列的顶端都有一颗红宝石按钮。每个按钮都可以向左或向右转动。每向左转动一次按钮，相应的行或列中数字都增 $1$。每向右转动一次按钮，相应的行或列中数字都减 $1$。在矩形密码阵列的若干特定位置镶嵌着绿宝石。只有当所有绿宝石位置的数字与藏宝图记载的密码完全相同，紧闭的洞门就会自动缓缓打开。女巫加古尔早已得知开门的秘密。为了阻止寻宝者打开洞门，女巫加古尔为开门的密码阵列设置了全 $0$ 的初始状态。试图打开洞门的寻宝者如果不能迅速转动按钮使所有绿宝石位置的数字与藏宝图记载的密码完全相同，就会自动启动藏宝洞玄妙的暗器机关，使寻宝者遭到灭顶攻击而死于非命。\n\n您能帮助三位寻宝英雄顺利打开藏宝洞的洞门吗？\n\n编程任务：对于给定的密码阵列，找到获得正确密码的红宝石按钮的转动序列。\n", "inputFormat": "输入的第一行中有一个正整数 $T (T \\le 5)$ 表示有 $T$ 组数据。每组数据的第一行有 $3$ 个正整数 $n,m$ 和 $k$，表示洞门密码阵列共有 $n$ 行和 $m$ 列，$0<n,m,k \\le 1000$。各行从上到下依次编号为 $1,2,\\ldots,n$；各列从左到右依次编号为 $1,2,\\ldots,m$ 。接下来的 $k$ 行中每行有三个整数 $x,y,c$，分别表示第 $k$ 个绿宝石在密码阵列中的位置和密码，$x$ 为行号 $y$ 为列号，$c$ 为该位置处的密码。", "outputFormat": "对于每组数据，用一行输出 ``Yes`` 或者 ``No``。输出 ``Yes`` 表示存在获得正确密码的红宝石按钮的转动序列。输出 ``No`` 则表示无法找到获得正确密码的红宝石按钮的转动序列。", "hint": "对于 $100\\%$ 的数据，$1 \\le n, m, k \\le 1000$，$k \\le n \\times m$，$|c| \\le 1,000,000$。", "locale": "zh-CN", "translations": {"en": {"title": "[FJOI2018] King Solomon's Treasure", "background": "", "description": "According to ancient legend, King Solomon stood for wisdom and wealth. He built a powerful and prosperous nation, amassed vast quantities of gold, ivory, and diamonds, and hid these priceless treasures in a mysterious place known as “King Solomon’s Treasure.” For centuries, people have searched for this lost treasure of ancient civilization, seeking the fabled land rich in gold and diamonds. Adventurers who pursued King Solomon’s treasure never returned, and to this day no one has solved the riddle. On a fortunate journey, Baron Henry unexpectedly obtained a treasure map of King Solomon left by a Portuguese noble three hundred years ago, written on parchment, along with a treasure-hunting manual. Tempted by the map, Baron Henry invited Colonel John and the brave elephant hunter Quatermain to begin a perilous quest for King Solomon’s treasure buried in the dark depths underground. They crossed boundless deserts and dense primeval forests, passed roaring rapids, climbed towering snowy peaks, and endured scorching heat and bitter cold. Guided by the map, they arrived at Kukuana, a mysterious and primitive land in Africa. There were cruel human sacrifices, a one-eyed tyrant Twala with a thousand wives, an old and crafty witch Gagool as ugly as a vulture, and a beautiful and intelligent lady named Foulata. In this unfamiliar and perilous land, the three treasure hunters endured countless hardships and, with Foulata’s help, finally found a vast treasure cave in the depths beneath the sea where the priceless treasure was hidden. However, under the witch Gagool’s careful plotting, disaster was quietly approaching.\n\nThe door of the treasure cave is strong and tightly shut. Without knowing the secret to opening it, the door cannot be opened. Next to the door is a strange rectangular password grid. According to the treasure-hunting manual, there is a ruby button on the left of each row and at the top of each column of the grid. Each button can be turned to the left or to the right. Each time a button is turned to the left, all numbers in the corresponding row or column increase by $1$. Each time a button is turned to the right, all numbers in the corresponding row or column decrease by $1$. Some positions in the grid are inlaid with emeralds. Only when the numbers at all emerald positions exactly match the password recorded on the map will the tightly shut door slowly open. The witch Gagool already knows the secret of opening the door. To stop the treasure hunters, she set the initial state of the grid to all $0$s. If the treasure hunters cannot quickly turn the buttons so that all emerald positions match the password exactly, a hidden mechanism will be triggered, causing a deadly attack.\n\nCan you help the three treasure hunters open the door of the treasure cave?\n\nProgramming task: For the given password grid, determine whether there exists a sequence of ruby button rotations that yields the correct password at all emerald positions.", "inputFormat": "The first line contains a positive integer $T$ ($T \\le 5$), indicating there are $T$ test cases. For each test case, the first line contains $3$ positive integers $n$, $m$, and $k$, meaning the grid has $n$ rows and $m$ columns, with $0 < n, m, k \\le 1000$. Rows are numbered $1, 2, \\ldots, n$ from top to bottom; columns are numbered $1, 2, \\ldots, m$ from left to right. The next $k$ lines each contain three integers $x$, $y$, $c$, indicating the position and required password value of an emerald in the grid: $x$ is the row index, $y$ is the column index, and $c$ is the required value at that position.", "outputFormat": "For each test case, output one line: ``Yes`` if there exists a sequence of ruby button rotations that yields the correct password, or ``No`` if it is impossible.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\le n, m, k \\le 1000$, $k \\le n \\times m$, $|c| \\le 1,000,000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[FJOI2018] 所罗门王的宝藏", "background": "", "description": "据古代传说记载，所罗门王既是智慧的代表，又是财富的象征。他建立了强大而富有的国家，聚集了大批的黄金象牙和钻石，并把这些价值连城的珍宝藏在一个神秘的地方，这就是世人瞩目的“所罗门王的宝藏”。多少个世纪以来，人们一直在寻找这批早已失落的古代文明宝藏，寻找盛产黄金和钻石的宝地。曾经追寻所罗门王宝藏的冒险者们都一去不回，至今没人解开这个谜题。亨利男爵在一次幸运的旅途中意外地得到了三百年前一位葡萄牙贵族留下的写在羊皮卷上的所罗门王的藏宝图和一本寻宝秘籍。在这张藏宝图的诱惑下，亨利男爵邀请约翰上校和勇敢的猎象人夸特曼开始了寻找埋葬在黑暗地底的所罗门王宝藏的艰险历程。他们横穿渺无边际的沙漠和浓荫蔽日的原始森林，越过汹涌澎湃的激流险滩，翻越高耸入云的峻岭雪山，饱尝沙漠的酷热和冰雪严寒，在藏宝图的指引下来到非洲一个原始的神秘国度库库安纳。这里有残酷的人殉制度，有一个拥有一千个妻室的独眼暴君特瓦拉，有像兀鹫一般丑恶诡诈老而不死的女巫加古尔，还有美丽聪慧的绝代佳人弗拉塔。在这片陌生而又险象环生的土地上三位寻宝英雄历尽艰辛，终于在绝代佳人弗拉塔的帮助下在海底深处找到了珍藏这批价值连城宝藏的巨大的藏宝洞。然而在女巫加古尔的精心策划下，一场灭顶之灾正在悄悄逼近。\n\n藏宝洞的洞门十分坚固且洞门紧闭，如果不知道开启洞门的秘密是无法打开藏宝洞的洞门。在藏宝洞的洞门一侧有一个奇怪的矩形密码阵列。根据寻宝秘籍的记载，在密码阵列每行的左侧和每列的顶端都有一颗红宝石按钮。每个按钮都可以向左或向右转动。每向左转动一次按钮，相应的行或列中数字都增 $1$。每向右转动一次按钮，相应的行或列中数字都减 $1$。在矩形密码阵列的若干特定位置镶嵌着绿宝石。只有当所有绿宝石位置的数字与藏宝图记载的密码完全相同，紧闭的洞门就会自动缓缓打开。女巫加古尔早已得知开门的秘密。为了阻止寻宝者打开洞门，女巫加古尔为开门的密码阵列设置了全 $0$ 的初始状态。试图打开洞门的寻宝者如果不能迅速转动按钮使所有绿宝石位置的数字与藏宝图记载的密码完全相同，就会自动启动藏宝洞玄妙的暗器机关，使寻宝者遭到灭顶攻击而死于非命。\n\n您能帮助三位寻宝英雄顺利打开藏宝洞的洞门吗？\n\n编程任务：对于给定的密码阵列，找到获得正确密码的红宝石按钮的转动序列。\n", "inputFormat": "输入的第一行中有一个正整数 $T (T \\le 5)$ 表示有 $T$ 组数据。每组数据的第一行有 $3$ 个正整数 $n,m$ 和 $k$，表示洞门密码阵列共有 $n$ 行和 $m$ 列，$0<n,m,k \\le 1000$。各行从上到下依次编号为 $1,2,\\ldots,n$；各列从左到右依次编号为 $1,2,\\ldots,m$ 。接下来的 $k$ 行中每行有三个整数 $x,y,c$，分别表示第 $k$ 个绿宝石在密码阵列中的位置和密码，$x$ 为行号 $y$ 为列号，$c$ 为该位置处的密码。", "outputFormat": "对于每组数据，用一行输出 ``Yes`` 或者 ``No``。输出 ``Yes`` 表示存在获得正确密码的红宝石按钮的转动序列。输出 ``No`` 则表示无法找到获得正确密码的红宝石按钮的转动序列。", "hint": "对于 $100\\%$ 的数据，$1 \\le n, m, k \\le 1000$，$k \\le n \\times m$，$|c| \\le 1,000,000$。", "locale": "zh-CN"}}}
