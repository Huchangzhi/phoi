{"pid": "P4659", "type": "P", "difficulty": 5, "samples": [["3 2\n1 0 2 1\n1 0 2 0\n1 1 2 1", "0\n1"], ["2 1\n1 0 1 0\n1 1 1 1", "IMPOSSIBLE"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000, 96000]}, "tags": ["2008", "Special Judge", "BalticOI（波罗的海）"], "title": "[BalticOI 2008] 阀门 (Day1)", "background": null, "description": "成为码农多年的你，已经厌倦了码农生活。你决定跳槽，去做一些不一样的事情。\n\n正在寻找下一份工作的你，被一份水产养殖的工作吸引住了。“太酷了！”并且，鱼是很好的生物。所以你毫不犹豫地去应聘了。幸运的是，你成功拿到了 Offer。今天是你工作的第一天。你的老板已经给你分配了任务：分隔两个蓄水池。\n\n你手上的操作指南告诉了你如下信息：\n\n这两个蓄水池之间有一些管道连通，每个管道有两个阀门。当两个阀门同时开启时，这个管道就处于开启状态，反之处于关闭状态。阀门用开关控制。同一个开关会控制一些阀门，但是每一个阀门都只被一个开关控制。有可能一个管道上的两个阀门被同一个开关控制，也可能有开关不控制任何阀门。 \n\n![0](https://i.loli.net/2018/02/19/5a8ac86221c4b.png)\n\n开关以以下两种方式控制阀门：\n- 当开关闭合时阀门打开，当开关断开时阀门关闭；\n- 当开关闭合时阀门关闭，当开关断开时阀门打开。\n\n玩了一会儿开关之后你突然意识到你的编程经历会十分有用。给出每个阀门被哪个开关所控制，判断是否可能关闭所有管道，如果可以，找出这种合法配置下每一个开关的状态。", "inputFormat": "标准输入的第一行包含两个整数 $n$ 和 $m$，分别表示管道数和开关数。开关被从 $1$ 到 $m$ 标号。\n\n接下来的 $n$ 行描述管道，一行用四个整数 $a,s_a,b,s_b$ 描述一个管道，$a,b$ 代表控制该管道的开关（$1\\le a,b\\le m$）。$s_a$ 和 $s_b$ 为 $0$ 或 $1$，并与描述中的操作模式相符，$s_i=0$ 表示当且仅当开关 $i$ 断开时阀门关闭，$s_i=1$ 表示当且仅当开关 $i$ 闭合时阀门关闭。", "outputFormat": "如果有可能关闭所有管道，标准输出应包含 $m$ 行，如果开关 $i$ 断开，第 $i$ 行应输出 $0$，如果开关 $i$ 闭合，第 $i$ 行应输出 $1$。如果有很多可能的答案，你的程序可以输出任意一种。\n\n如果不可能关闭所有管道，你的程序应输出一行，包含一个单词 ``IMPOSSIBLE``。", "hint": "#### 数据范围\n\n对于 $30\\%$ 的数据，$n\\le 40$，$m\\le 20$。\n\n对于所有数据，$1\\le n\\le 2.5\\times 10^5$，$1\\le m\\le 5\\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2008] Valves (Day1)", "background": "", "description": "After being a programmer for many years, you have gotten tired of the programmer’s life. You decide to change jobs and do something different.\n\nWhile looking for your next job, you are attracted by a job in aquaculture. “So cool!” And fish are great creatures. So you apply without hesitation. Luckily, you get an offer. Today is your first day at work. Your boss has assigned you a task: separate two water reservoirs.\n\nThe manual you have tells you the following information:\n\nThere are some pipes connecting the two reservoirs. Each pipe has two valves. A pipe is open when both valves are open at the same time; otherwise it is closed. Valves are controlled by switches. The same switch controls some valves, but each valve is controlled by exactly one switch. It is possible that the two valves on a pipe are controlled by the same switch, and it is also possible that some switches control no valves.\n\n![0](https://i.loli.net/2018/02/19/5a8ac86221c4b.png)\n\nA switch controls a valve in one of the following two ways:\n- When the switch is closed, the valve opens; when the switch is open, the valve closes.\n- When the switch is closed, the valve closes; when the switch is open, the valve opens.\n\nAfter playing with the switches for a while, you suddenly realize that your programming experience will be very useful. Given which switch controls each valve, determine whether it is possible to close all pipes. If it is, find the state of every switch in such a valid configuration.", "inputFormat": "The first line of standard input contains two integers $n$ and $m$, representing the number of pipes and the number of switches. The switches are numbered from $1$ to $m$.\n\nThe next $n$ lines describe the pipes. Each line contains four integers $a, s_a, b, s_b$ describing one pipe. $a, b$ are the switches controlling the pipe ($1 \\le a, b \\le m$). $s_a$ and $s_b$ are $0$ or $1$ and correspond to the control modes in the description: $s_i = 0$ means the valve is closed if and only if switch $i$ is open, and $s_i = 1$ means the valve is closed if and only if switch $i$ is closed.", "outputFormat": "If it is possible to close all pipes, standard output should contain $m$ lines. If switch $i$ is open, the $i$-th line should output $0$; if switch $i$ is closed, the $i$-th line should output $1$. If there are many possible answers, your program may output any one of them.\n\nIf it is impossible to close all pipes, your program should output one line containing the word ``IMPOSSIBLE``.", "hint": "#### Constraints\n\nFor $30\\%$ of the testdata, $n \\le 40$, $m \\le 20$.\n\nFor all testdata, $1 \\le n \\le 2.5 \\times 10^5$, $1 \\le m \\le 5 \\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2008] 阀门 (Day1)", "background": null, "description": "成为码农多年的你，已经厌倦了码农生活。你决定跳槽，去做一些不一样的事情。\n\n正在寻找下一份工作的你，被一份水产养殖的工作吸引住了。“太酷了！”并且，鱼是很好的生物。所以你毫不犹豫地去应聘了。幸运的是，你成功拿到了 Offer。今天是你工作的第一天。你的老板已经给你分配了任务：分隔两个蓄水池。\n\n你手上的操作指南告诉了你如下信息：\n\n这两个蓄水池之间有一些管道连通，每个管道有两个阀门。当两个阀门同时开启时，这个管道就处于开启状态，反之处于关闭状态。阀门用开关控制。同一个开关会控制一些阀门，但是每一个阀门都只被一个开关控制。有可能一个管道上的两个阀门被同一个开关控制，也可能有开关不控制任何阀门。 \n\n![0](https://i.loli.net/2018/02/19/5a8ac86221c4b.png)\n\n开关以以下两种方式控制阀门：\n- 当开关闭合时阀门打开，当开关断开时阀门关闭；\n- 当开关闭合时阀门关闭，当开关断开时阀门打开。\n\n玩了一会儿开关之后你突然意识到你的编程经历会十分有用。给出每个阀门被哪个开关所控制，判断是否可能关闭所有管道，如果可以，找出这种合法配置下每一个开关的状态。", "inputFormat": "标准输入的第一行包含两个整数 $n$ 和 $m$，分别表示管道数和开关数。开关被从 $1$ 到 $m$ 标号。\n\n接下来的 $n$ 行描述管道，一行用四个整数 $a,s_a,b,s_b$ 描述一个管道，$a,b$ 代表控制该管道的开关（$1\\le a,b\\le m$）。$s_a$ 和 $s_b$ 为 $0$ 或 $1$，并与描述中的操作模式相符，$s_i=0$ 表示当且仅当开关 $i$ 断开时阀门关闭，$s_i=1$ 表示当且仅当开关 $i$ 闭合时阀门关闭。", "outputFormat": "如果有可能关闭所有管道，标准输出应包含 $m$ 行，如果开关 $i$ 断开，第 $i$ 行应输出 $0$，如果开关 $i$ 闭合，第 $i$ 行应输出 $1$。如果有很多可能的答案，你的程序可以输出任意一种。\n\n如果不可能关闭所有管道，你的程序应输出一行，包含一个单词 ``IMPOSSIBLE``。", "hint": "#### 数据范围\n\n对于 $30\\%$ 的数据，$n\\le 40$，$m\\le 20$。\n\n对于所有数据，$1\\le n\\le 2.5\\times 10^5$，$1\\le m\\le 5\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P4660", "type": "P", "difficulty": 6, "samples": [["4\n0 7 1 6\n1 5 0 6", "2\n8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2008", "Special Judge", "BalticOI（波罗的海）"], "title": "[BalticOI 2008] 手套 (Day2)", "background": null, "description": "化学教授名曰“酸雨”。在他家黑暗的地下室，有两个装有手套的抽屉，一个抽屉装左手手套，另一个装右手手套。每个抽屉中有 $n$ 种不同颜色的手套。教授知道在每个抽屉中，每种颜色的手套数目（在不同抽屉中，相同颜色的手套数目可能不同）。保证他能够找到同色的一副手套。\n\n只有教授带相同颜色的一副手套时试验才可能会成功（与哪种颜色无关），所以在每次试验开始之前他都要去地下室从抽屉中拿手套，并且希望至少有一副一样颜色的手套。但是地下室太黑了，不出地下室就不可能分辨出任何手套的颜色。教授讨厌去地下室超过一次，同时也讨厌拿一堆手套回实验室（以防没有相同颜色的手套）。\n\n#### 任务\n\n写一个程序能够：\n- 从标准输入中读取颜色种数和每种颜色手套的数目；\n- 计算在确保拿出的手套中有一副颜色相同的手套的情况下需要取出手套的最小数目（需要明确指出从每个抽屉中取出手套的确切数目）；\n- 将结果写到标准输出。", "inputFormat": "标准输入的第一行包含一个正整数 $n$，描述不同的颜色种数。颜色从 $1$ 到 $n$ 编号。\n\n输入第二行包含 $n$ 个非负整数 $a_1,a_2,\\cdots ,a_n$，$a_i$ 表示在装左手手套的抽屉中第 $i$ 种颜色手套的数目。\n\n输入第三行包含 $n$ 个非负整数 $b_1,b_2,\\cdots ,b_n$，$b_i$ 表示在装右手手套的抽屉中第 $i$ 种颜色手套的数目。", "outputFormat": "标准输出第一行包含单独一个整数，表示从装左手手套抽屉中取出的手套数。第二行包含单独一个整数，表示从装右手手套抽屉中取出的手套数。这两个数的总和应尽量小。\n\n如果有多种正确答案，你的程序可以输出任意一组。", "hint": "对于 $40\\%$ 的数据，$n\\le 4$，$a_i,b_i\\le 10$。 \n\n对于全部数据，$1\\le n\\le 20$，$0\\le a_i,b_i\\le 10^8$。", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2008] Gloves (Day2)", "background": "", "description": "A chemistry professor named “Acid Rain” has a dark basement with two drawers of gloves: one drawer contains left-hand gloves, and the other contains right-hand gloves. Each drawer has gloves in $n$ different colors. The professor knows how many gloves of each color are in each drawer (the counts for the same color may differ between the two drawers). It is guaranteed that he can find at least one pair of gloves of the same color.\n\nAn experiment can succeed only if the professor wears a pair of gloves of the same color (the color does not matter). Therefore, before each experiment he goes to the basement to take gloves from the drawers, hoping to get at least one same-colored pair. However, the basement is so dark that he cannot distinguish the colors of any gloves unless he leaves the basement. The professor hates going to the basement more than once, and also hates bringing a large pile of gloves back to the lab (in case there is no same-colored pair).\n\n#### Task\n\nWrite a program that:\n- reads from standard input the number of colors and the number of gloves of each color;\n- computes the minimum total number of gloves that must be taken to guarantee that among the taken gloves there is at least one pair of the same color (and you must specify the exact number of gloves taken from each drawer);\n- writes the result to standard output.", "inputFormat": "The first line of standard input contains a positive integer $n$, the number of different colors. The colors are numbered from $1$ to $n$.\n\nThe second line contains $n$ non-negative integers $a_1,a_2,\\cdots ,a_n$, where $a_i$ is the number of gloves of color $i$ in the left-hand glove drawer.\n\nThe third line contains $n$ non-negative integers $b_1,b_2,\\cdots ,b_n$, where $b_i$ is the number of gloves of color $i$ in the right-hand glove drawer.", "outputFormat": "The first line of standard output contains a single integer: the number of gloves taken from the left-hand glove drawer. The second line contains a single integer: the number of gloves taken from the right-hand glove drawer. The sum of these two numbers should be as small as possible.\n\nIf there are multiple correct answers, your program may output any one of them.", "hint": "For $40\\%$ of the testdata, $n\\le 4$ and $a_i,b_i\\le 10$.\n\nFor all testdata, $1\\le n\\le 20$ and $0\\le a_i,b_i\\le 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2008] 手套 (Day2)", "background": null, "description": "化学教授名曰“酸雨”。在他家黑暗的地下室，有两个装有手套的抽屉，一个抽屉装左手手套，另一个装右手手套。每个抽屉中有 $n$ 种不同颜色的手套。教授知道在每个抽屉中，每种颜色的手套数目（在不同抽屉中，相同颜色的手套数目可能不同）。保证他能够找到同色的一副手套。\n\n只有教授带相同颜色的一副手套时试验才可能会成功（与哪种颜色无关），所以在每次试验开始之前他都要去地下室从抽屉中拿手套，并且希望至少有一副一样颜色的手套。但是地下室太黑了，不出地下室就不可能分辨出任何手套的颜色。教授讨厌去地下室超过一次，同时也讨厌拿一堆手套回实验室（以防没有相同颜色的手套）。\n\n#### 任务\n\n写一个程序能够：\n- 从标准输入中读取颜色种数和每种颜色手套的数目；\n- 计算在确保拿出的手套中有一副颜色相同的手套的情况下需要取出手套的最小数目（需要明确指出从每个抽屉中取出手套的确切数目）；\n- 将结果写到标准输出。", "inputFormat": "标准输入的第一行包含一个正整数 $n$，描述不同的颜色种数。颜色从 $1$ 到 $n$ 编号。\n\n输入第二行包含 $n$ 个非负整数 $a_1,a_2,\\cdots ,a_n$，$a_i$ 表示在装左手手套的抽屉中第 $i$ 种颜色手套的数目。\n\n输入第三行包含 $n$ 个非负整数 $b_1,b_2,\\cdots ,b_n$，$b_i$ 表示在装右手手套的抽屉中第 $i$ 种颜色手套的数目。", "outputFormat": "标准输出第一行包含单独一个整数，表示从装左手手套抽屉中取出的手套数。第二行包含单独一个整数，表示从装右手手套抽屉中取出的手套数。这两个数的总和应尽量小。\n\n如果有多种正确答案，你的程序可以输出任意一组。", "hint": "对于 $40\\%$ 的数据，$n\\le 4$，$a_i,b_i\\le 10$。 \n\n对于全部数据，$1\\le n\\le 20$，$0\\le a_i,b_i\\le 10^8$。", "locale": "zh-CN"}}}
{"pid": "P4661", "type": "P", "difficulty": 4, "samples": [["7 8 2 1\n0 0 2 6 1 1 0 0\n1 4 4 4 4 4 3 0\n2 4 4 4 4 4 3 0\n1 4 4 4 8 4 4 0\n0 3 4 4 4 4 4 3\n0 1 1 3 4 4 3 0\n0 0 0 1 2 1 2 0", "31"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["2008", "二分", "枚举", "BalticOI（波罗的海）"], "title": "[BalticOI 2008] 网格 (Day2)", "background": null, "description": "Byteland 国的地图是一个大小为 $n\\times m$ 的网格（$n$ 是垂直方向长度，$m$ 是水平方向长度）。标记分隔的水平线被叫做平行线，并编号为 $0$ 到 $n$，标记分隔的垂直线被叫做子午线，并编号为 $0$ 到 $m$。\n\n在 Byteland 国，天气预报是一个十分严肃的话题，对于每个单元格，准备天气预报需要一定时间来计算。由于地形条件和其他因素，不同的单元格有着不同的计算时间。直到目前为止，预报系统还是会依次处理每一个单元格，所以完成预报天气需要花费的时间为计算所有单元的时间。\n\n你被要求设计一个可以在多进程处理器上运行的新系统，为了共享处理器的计算能力，Byteland 国要被 $r$ 条平行线和 $s$ 条子午线划分为 $(r+1)\\times (s+1)$ 个矩形。每个线程会依次处理一个矩形内部的单元格，这样的话对于一个矩形区域的计算时间，就为矩形区域内单元格计算时间之和。完成预报的计算时间是一个处理器上计算时间的最大值。\n\n你的任务是找到对于选择 $r$ 条平行线和 $s$ 条子午线分隔后最小的计算时间。\n\n#### 任务\n\n写一个程序能够：\n- 从标准输入读取 Byteland 的地图，要求的平行线和子午线条数以及每个单元格的处理时间；\n- 找到完成预报的最小计算时间；\n- 输出这个值到标准输出。", "inputFormat": "第一行包含四个正整数 $n,m,r,s$，由一个空格隔开。\n\n接下来 $n$ 行包含每一个单元格的计算时间 $c_{i,j}$。第 $i+1$ 行的第 $j$ 个数表示位于第 $i-1$ 和第 $i$ 条平行线，第 $j-1$ 和第 $j$ 条子午线之间的单元格需要的计算时间。", "outputFormat": "输出一行一个整数，表示最优的计算时间。", "hint": "#### 样例解释\n\n![0](https://i.loli.net/2018/02/19/5a8ae8ca02cbb.png)\n\n第二条和第四条平行线，第四条子午线把整个国家分为六个矩形，计算时间为 $21, 13, 27, 27, 17, 31$，所以完成预报的计算时间为 $31$。\n\n#### 数据范围\n\n对于 $40\\%$ 的数据，$n\\le 10,m\\le 10$。\n\n对于全部数据，$1\\le r<n\\le 18$，$1\\le s<m\\le 18$，$1\\le i\\le n$，$1\\le j\\le m$，$0\\le c_{i,j}\\le 2\\times 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2008] Grid (Day2)", "background": "", "description": "The map of the country of Byteland is a grid of size $n \\times m$ ($n$ is the vertical length and $m$ is the horizontal length). The labeled separating horizontal lines are called parallels and are numbered from $0$ to $n$. The labeled separating vertical lines are called meridians and are numbered from $0$ to $m$.\n\nIn Byteland, weather forecasting is a very serious topic. For each cell, preparing the forecast takes some time to compute. Due to terrain conditions and other factors, different cells require different computation times. Up to now, the forecasting system processes each cell one by one, so the total time to finish forecasting is the sum of the times for all cells.\n\nYou are asked to design a new system that can run on a multi-process processor. To share the processor's computing power, Byteland will be divided by $r$ parallels and $s$ meridians into $(r+1) \\times (s+1)$ rectangles. Each thread will process the cells inside one rectangle in order. Then, the computation time for a rectangle is the sum of the computation times of all cells inside that rectangle. The total time to finish the forecast is the maximum computation time among all processors.\n\nYour task is to find the minimum possible total time after choosing $r$ parallels and $s$ meridians to split the grid.\n\n#### Task\n\nWrite a program that:\n- reads from standard input the map of Byteland, the required numbers of parallels and meridians, and the processing time of each cell;\n- finds the minimum total time to finish the forecast;\n- outputs this value to standard output.", "inputFormat": "The first line contains four positive integers $n, m, r, s$, separated by a single space.\n\nThe next $n$ lines contain the computation time $c_{i,j}$ for each cell. The $j$-th number on line $i+1$ represents the time needed for the cell between the $(i-1)$-th and $i$-th parallels and between the $(j-1)$-th and $j$-th meridians.", "outputFormat": "Output one line with one integer, which is the optimal computation time.", "hint": "#### Sample Explanation\n\n![0](https://i.loli.net/2018/02/19/5a8ae8ca02cbb.png)\n\nThe 2nd and 4th parallels and the 4th meridian divide the whole country into six rectangles, with computation times $21, 13, 27, 27, 17, 31$, so the total time to finish the forecast is $31$.\n\n#### Constraints\n\nFor $40\\%$ of the testdata, $n \\le 10, m \\le 10$.\n\nFor all testdata, $1 \\le r < n \\le 18$, $1 \\le s < m \\le 18$, $1 \\le i \\le n$, $1 \\le j \\le m$, $0 \\le c_{i,j} \\le 2 \\times 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2008] 网格 (Day2)", "background": null, "description": "Byteland 国的地图是一个大小为 $n\\times m$ 的网格（$n$ 是垂直方向长度，$m$ 是水平方向长度）。标记分隔的水平线被叫做平行线，并编号为 $0$ 到 $n$，标记分隔的垂直线被叫做子午线，并编号为 $0$ 到 $m$。\n\n在 Byteland 国，天气预报是一个十分严肃的话题，对于每个单元格，准备天气预报需要一定时间来计算。由于地形条件和其他因素，不同的单元格有着不同的计算时间。直到目前为止，预报系统还是会依次处理每一个单元格，所以完成预报天气需要花费的时间为计算所有单元的时间。\n\n你被要求设计一个可以在多进程处理器上运行的新系统，为了共享处理器的计算能力，Byteland 国要被 $r$ 条平行线和 $s$ 条子午线划分为 $(r+1)\\times (s+1)$ 个矩形。每个线程会依次处理一个矩形内部的单元格，这样的话对于一个矩形区域的计算时间，就为矩形区域内单元格计算时间之和。完成预报的计算时间是一个处理器上计算时间的最大值。\n\n你的任务是找到对于选择 $r$ 条平行线和 $s$ 条子午线分隔后最小的计算时间。\n\n#### 任务\n\n写一个程序能够：\n- 从标准输入读取 Byteland 的地图，要求的平行线和子午线条数以及每个单元格的处理时间；\n- 找到完成预报的最小计算时间；\n- 输出这个值到标准输出。", "inputFormat": "第一行包含四个正整数 $n,m,r,s$，由一个空格隔开。\n\n接下来 $n$ 行包含每一个单元格的计算时间 $c_{i,j}$。第 $i+1$ 行的第 $j$ 个数表示位于第 $i-1$ 和第 $i$ 条平行线，第 $j-1$ 和第 $j$ 条子午线之间的单元格需要的计算时间。", "outputFormat": "输出一行一个整数，表示最优的计算时间。", "hint": "#### 样例解释\n\n![0](https://i.loli.net/2018/02/19/5a8ae8ca02cbb.png)\n\n第二条和第四条平行线，第四条子午线把整个国家分为六个矩形，计算时间为 $21, 13, 27, 27, 17, 31$，所以完成预报的计算时间为 $31$。\n\n#### 数据范围\n\n对于 $40\\%$ 的数据，$n\\le 10,m\\le 10$。\n\n对于全部数据，$1\\le r<n\\le 18$，$1\\le s<m\\le 18$，$1\\le i\\le n$，$1\\le j\\le m$，$0\\le c_{i,j}\\le 2\\times 10^6$。", "locale": "zh-CN"}}}
{"pid": "P4662", "type": "P", "difficulty": 6, "samples": [["5 6\n5 3\n2\n4\n8\n3\n10\n1 5\n1 2\n2 4\n4 5\n2 3\n3 4", "1 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["2008", "Special Judge", "最小割", "BalticOI（波罗的海）"], "title": "[BalticOI 2008] 黑手党 (Day0)", "background": null, "description": "Byteland 国警方收到了一条匿名举报，其中说当地黑帮老大正计划一次从港口到郊区仓库的运输。警方知道运输的时间并且知道运输需要用到国家的高速公路网。\n\n高速公路网包含双向的高速公路段，每个路段直接连着两个不同的收费站。一个收费站可能与很多其他的收费站相连。汽车只能通过收费站进入或离开高速公路网。据所知，黑帮会距港口边最近的收费站进入高速公路，从距仓库最近的收费站离开（不会在出高速后重新进入）。特警组位于选定的收费站处。当运输车辆进入被监控的收费站时，它就会被警察抓住。\n\n从这个角度看，最简单的办法就是在每个收费站处都安排特警班。然而，控制一个收费站需要特定的费用，每个收费站费用不同。警方想要让花费最小，所以他们需要制定一个收费站的最小控制集，这个集合满足两个条件：\n- 所有从港口到仓库的交通必须至少经过集合中的一个收费站；\n- 监控这些收费站的费用（即监控每一个收费站费用之和）最小。\n\n你可以假设使用高速公路可以从港口到仓库。\n\n#### 任务\n\n写一个程序能够：\n\n- 从标准输入中读取高速公路网，监控代价和运输的起点和终点；\n- 找到收费站的最小控制集；\n- 输出这个集合到标准输出。", "inputFormat": "标准输入的第一行包含两个整数 $n$ 和 $m$，表示收费站的总数和公路段的总数。收费站按 $1$ 到 $n$ 标号。\n\n第二行包含两个整数 $a$ 和 $b$，分别表示距港口和仓库最近的两个收费站编号。\n\n接下来 $n$ 行表示控制费用，第 $i+2$ 行包含一个整数，表示第 $i$ 个收费站的控制费用 $c_i$。\n\n接下来 $m$ 行表示高速公路网，第 $j+n+2$ 行包含两个整数 $x_j$ 和 $y_j$，表示在 $x_j$ 和 $y_j$ 收费站之间有一条公路段相连。每一条高速公路段只出现一次。", "outputFormat": "唯一的一行输出应包含最小控制集中收费站的编号，以递增顺序输出，用一个空格分隔。\n\n如果有多于一个最小控制集，你的程序可以输出任意一个。", "hint": "#### 样例解释\n\n![0](https://i.loli.net/2018/02/19/5a8af2c2ef8d7.gif)\n\n这张图片显示了高速公路网中收费站的编号（在左上角）和控制费用。$1$ 号和 $4$ 号收费站组成了最小控制集，总控制费用为 $5$。\n\n#### 数据范围\n\n对于 $40\\%$ 的测试数据，$n\\le 20$。\n\n对于全部数据，$1\\le n\\le 200$，$1\\le m\\le 2\\times 10^4$，$1\\le a,b\\le n$，$a\\not= b$，$1\\le c_i\\le 10^7$，$1\\le x_j<y_j\\le n$。", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2008] Mafia (Day0)", "background": "", "description": "The police in Byteland received an anonymous report saying that the local mafia boss is planning a transport from the port to a warehouse in the suburbs. The police know the time of the transport, and they know that the transport will use the country's highway network.\n\nThe highway network consists of bidirectional highway segments, and each segment directly connects two different toll stations. A toll station may be connected to many other toll stations. Cars can enter or leave the highway network only through toll stations. It is known that the mafia will enter the highway at the toll station closest to the port and leave at the toll station closest to the warehouse (they will not re-enter the highway after leaving). A special police unit will be stationed at selected toll stations. When the transport vehicle enters a monitored toll station, it will be caught by the police.\n\nFrom this point of view, the simplest way is to station a police unit at every toll station. However, controlling a toll station requires a certain cost, and the costs differ between stations. The police want the minimum total cost, so they need to determine a minimum control set of toll stations that satisfies two conditions:\n\n- Every route from the port to the warehouse must pass through at least one toll station in the set.\n- The total monitoring cost of these toll stations (i.e., the sum of the costs of all toll stations in the set) is minimal.\n\nYou may assume that it is possible to travel from the port to the warehouse using the highway network.\n\n#### Task\n\nWrite a program that:\n\n- reads the highway network, monitoring costs, and the start and end points of the transport from standard input;\n- finds a minimum control set of toll stations;\n- outputs this set to standard output.", "inputFormat": "The first line of standard input contains two integers $n$ and $m$, representing the total number of toll stations and the total number of highway segments. Toll stations are numbered from $1$ to $n$.\n\nThe second line contains two integers $a$ and $b$, representing the indices of the toll stations closest to the port and the warehouse, respectively.\n\nThe next $n$ lines describe the control costs. Line $i+2$ contains one integer, representing the control cost $c_i$ of toll station $i$.\n\nThe next $m$ lines describe the highway network. Line $j+n+2$ contains two integers $x_j$ and $y_j$, meaning there is a highway segment connecting toll stations $x_j$ and $y_j$. Each highway segment appears only once.", "outputFormat": "The only line of output should contain the indices of the toll stations in the minimum control set, in increasing order, separated by one space.\n\nIf there is more than one minimum control set, your program may output any one of them.", "hint": "#### Sample Explanation\n\n![0](https://i.loli.net/2018/02/19/5a8af2c2ef8d7.gif)\n\nThis image shows the toll station indices (in the top-left corner) and the control costs in the highway network. Toll stations $1$ and $4$ form a minimum control set, with a total control cost of $5$.\n\n#### Constraints\n\nFor $40\\%$ of the testdata, $n\\le 20$.\n\nFor all testdata, $1\\le n\\le 200$, $1\\le m\\le 2\\times 10^4$, $1\\le a,b\\le n$, $a\\not= b$, $1\\le c_i\\le 10^7$, $1\\le x_j<y_j\\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2008] 黑手党 (Day0)", "background": null, "description": "Byteland 国警方收到了一条匿名举报，其中说当地黑帮老大正计划一次从港口到郊区仓库的运输。警方知道运输的时间并且知道运输需要用到国家的高速公路网。\n\n高速公路网包含双向的高速公路段，每个路段直接连着两个不同的收费站。一个收费站可能与很多其他的收费站相连。汽车只能通过收费站进入或离开高速公路网。据所知，黑帮会距港口边最近的收费站进入高速公路，从距仓库最近的收费站离开（不会在出高速后重新进入）。特警组位于选定的收费站处。当运输车辆进入被监控的收费站时，它就会被警察抓住。\n\n从这个角度看，最简单的办法就是在每个收费站处都安排特警班。然而，控制一个收费站需要特定的费用，每个收费站费用不同。警方想要让花费最小，所以他们需要制定一个收费站的最小控制集，这个集合满足两个条件：\n- 所有从港口到仓库的交通必须至少经过集合中的一个收费站；\n- 监控这些收费站的费用（即监控每一个收费站费用之和）最小。\n\n你可以假设使用高速公路可以从港口到仓库。\n\n#### 任务\n\n写一个程序能够：\n\n- 从标准输入中读取高速公路网，监控代价和运输的起点和终点；\n- 找到收费站的最小控制集；\n- 输出这个集合到标准输出。", "inputFormat": "标准输入的第一行包含两个整数 $n$ 和 $m$，表示收费站的总数和公路段的总数。收费站按 $1$ 到 $n$ 标号。\n\n第二行包含两个整数 $a$ 和 $b$，分别表示距港口和仓库最近的两个收费站编号。\n\n接下来 $n$ 行表示控制费用，第 $i+2$ 行包含一个整数，表示第 $i$ 个收费站的控制费用 $c_i$。\n\n接下来 $m$ 行表示高速公路网，第 $j+n+2$ 行包含两个整数 $x_j$ 和 $y_j$，表示在 $x_j$ 和 $y_j$ 收费站之间有一条公路段相连。每一条高速公路段只出现一次。", "outputFormat": "唯一的一行输出应包含最小控制集中收费站的编号，以递增顺序输出，用一个空格分隔。\n\n如果有多于一个最小控制集，你的程序可以输出任意一个。", "hint": "#### 样例解释\n\n![0](https://i.loli.net/2018/02/19/5a8af2c2ef8d7.gif)\n\n这张图片显示了高速公路网中收费站的编号（在左上角）和控制费用。$1$ 号和 $4$ 号收费站组成了最小控制集，总控制费用为 $5$。\n\n#### 数据范围\n\n对于 $40\\%$ 的测试数据，$n\\le 20$。\n\n对于全部数据，$1\\le n\\le 200$，$1\\le m\\le 2\\times 10^4$，$1\\le a,b\\le n$，$a\\not= b$，$1\\le c_i\\le 10^7$，$1\\le x_j<y_j\\le n$。", "locale": "zh-CN"}}}
{"pid": "P4663", "type": "P", "difficulty": 6, "samples": [["3 2 5", "XIX"], ["3 2 7", "NO SUCH STONE"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["2008", "BalticOI（波罗的海）"], "title": "[BalticOI 2008] 魔法石 (Day1)", "background": null, "description": "知名的石头 $\\text{Xi-n-k}$ 只能在 Wonderland 中找到，这样的石头只是一种碑文只有字母 ``X`` 和 ``I`` 的花岗岩板。每个石板包含 $n$ 个字母。每个石板上有不超过 $k$ 个位置 ``X`` 和 ``I`` 相邻。\n\n石板的顶部和底部不是固定的，所以石头可以旋转，变为倒立状态。例如下面这两个图片描述的是一样的石头。 \n\n![0](https://i.loli.net/2018/02/20/5a8ba0ad731f2.png)\n\n【看同样石头的两种方式。这种石头的种类是 $\\text{Xi-8-3}$，也是 $\\text{Xi-8-4}$（当然也可以是 $\\text{Xi-8-}k$，$k \\ge 3$）。】\n\n现在 Wonderland 中任意两块魔法石都不是一样的，即两块石头都没有相同的碑文（注意旋转 $180^\\circ$ 是允许的）。\n\n如果可以以两种不同方式（用旋转 $180^\\circ$ 的方式）读一块石头的碑文，那么对于这块石头，碑文的正规阅读方式被定义为两种阅读方式字典序小的那种。\n\n如果一块石头的碑文是对称的，即旋转 $180^\\circ$ 并不改变碑文，那么对于这块石头，碑文的的正规阅读方式被定义为这种独一无二的阅读方式。\n\n例如：有六种 $\\text{Xi-3-2}$ 魔法石，它们的正规阅读方式以字典序写出为：``III``，``IIX``，``IXI``，``IXX``，``XIX`` 和 ``XXX``。\n\nAlice 是一个研究 Wonderland 的魔法石的专家。她想要创建一个 $\\text{Xi-n-k}$ 魔法石的正规阅读方式字典（对于一些特定的 $n$ 和 $k$）。对于给出的 $i$，在字典中第 $i$ 个位置应该是什么碑文呢？\n\n##### 任务\n\n写一个程序能够：\n- 从标准输入中读取数字 $n$，$k$，$i$；\n- 判定对于 $\\text{Xi-n-k}$ 魔法石，第 $i$ 个正规阅读方式（按字典序）；\n- 输出结果到标准输出。", "inputFormat": "标准输入只有一行，包含三个整数 $n,k,i$，用一个空格分开。", "outputFormat": "标准输出只有一行，应该包含 $\\text{Xi-n-k}$ 魔法石，第 $i$ 个正规阅读方式（按字典序）。\n\n如果 $\\text{Xi-n-k}$ 魔法石的数量比 $i$ 小，那么只输出一行一个短语 ``NO SUCH STONE``。", "hint": "#### 数据范围与提示\n\n对于全部数据，$0\\le k<n\\le 60$，$0<i<10^{18}$。\n\n#### 说明\n\n注：我们说 $\\text{A}$ 的碑文字典序比 $\\text{B}$ 小（假设 $\\text{A}$ 和 $\\text{B}$ 的碑文长度相同），当且仅当在第一个碑文不同的位置 $\\text{A}$ 包含 ``I`` 且 $\\text{B}$ 包含 ``X``。", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2008] Magic Stone (Day1)", "background": "", "description": "The famous stone $\\text{Xi-n-k}$ can only be found in Wonderland. Such a stone is a granite slab engraved with an inscription consisting only of the letters `X` and `I`. Each slab contains $n$ letters. On each slab, there are at most $k$ positions where `X` and `I` are adjacent.\n\nThe top and bottom of a slab are not fixed, so the stone can be rotated and become upside down. For example, the following two pictures describe the same stone.\n\n![0](https://i.loli.net/2018/02/20/5a8ba0ad731f2.png)\n\n【Two ways to view the same stone. This stone is of type $\\text{Xi-8-3}$, and also $\\text{Xi-8-4}$ (of course it can also be $\\text{Xi-8-}k$, $k \\ge 3$).】\n\nNow, in Wonderland, no two magic stones are the same, meaning that no two stones have the same inscription (note that a $180^\\circ$ rotation is considered the same).\n\nIf a stone’s inscription can be read in two different ways (by rotating it $180^\\circ$), then the standard way to read the inscription is defined as the lexicographically smaller of the two readings.\n\nIf a stone’s inscription is symmetric, meaning that rotating it $180^\\circ$ does not change the inscription, then the standard way to read the inscription is defined as this unique reading.\n\nFor example, there are six kinds of $\\text{Xi-3-2}$ magic stones. Their standard readings, written in lexicographical order, are: `III`, `IIX`, `IXI`, `IXX`, `XIX`, and `XXX`.\n\nAlice is an expert in studying magic stones in Wonderland. She wants to create a dictionary of standard readings of $\\text{Xi-n-k}$ magic stones (for some given $n$ and $k$). For a given $i$, what inscription should be at position $i$ in this dictionary?\n\n##### Task\n\nWrite a program that:\n- reads integers $n$, $k$, $i$ from standard input;\n- determines the $i$-th standard reading (in lexicographical order) among $\\text{Xi-n-k}$ magic stones;\n- outputs the result to standard output.", "inputFormat": "The standard input contains only one line with three integers $n,k,i$, separated by a single space.", "outputFormat": "The standard output contains only one line, which should be the $i$-th standard reading (in lexicographical order) of $\\text{Xi-n-k}$ magic stones.\n\nIf the number of $\\text{Xi-n-k}$ magic stones is smaller than $i$, output one line with the phrase `NO SUCH STONE`.", "hint": "#### Constraints and Hints\n\nFor all data, $0\\le k<n\\le 60$, $0<i<10^{18}$.\n\n#### Notes\n\nNote: We say the inscription of $\\text{A}$ is lexicographically smaller than that of $\\text{B}$ (assuming they have the same length) if and only if at the first position where they differ, $\\text{A}$ contains `I` and $\\text{B}$ contains `X`.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2008] 魔法石 (Day1)", "background": null, "description": "知名的石头 $\\text{Xi-n-k}$ 只能在 Wonderland 中找到，这样的石头只是一种碑文只有字母 ``X`` 和 ``I`` 的花岗岩板。每个石板包含 $n$ 个字母。每个石板上有不超过 $k$ 个位置 ``X`` 和 ``I`` 相邻。\n\n石板的顶部和底部不是固定的，所以石头可以旋转，变为倒立状态。例如下面这两个图片描述的是一样的石头。 \n\n![0](https://i.loli.net/2018/02/20/5a8ba0ad731f2.png)\n\n【看同样石头的两种方式。这种石头的种类是 $\\text{Xi-8-3}$，也是 $\\text{Xi-8-4}$（当然也可以是 $\\text{Xi-8-}k$，$k \\ge 3$）。】\n\n现在 Wonderland 中任意两块魔法石都不是一样的，即两块石头都没有相同的碑文（注意旋转 $180^\\circ$ 是允许的）。\n\n如果可以以两种不同方式（用旋转 $180^\\circ$ 的方式）读一块石头的碑文，那么对于这块石头，碑文的正规阅读方式被定义为两种阅读方式字典序小的那种。\n\n如果一块石头的碑文是对称的，即旋转 $180^\\circ$ 并不改变碑文，那么对于这块石头，碑文的的正规阅读方式被定义为这种独一无二的阅读方式。\n\n例如：有六种 $\\text{Xi-3-2}$ 魔法石，它们的正规阅读方式以字典序写出为：``III``，``IIX``，``IXI``，``IXX``，``XIX`` 和 ``XXX``。\n\nAlice 是一个研究 Wonderland 的魔法石的专家。她想要创建一个 $\\text{Xi-n-k}$ 魔法石的正规阅读方式字典（对于一些特定的 $n$ 和 $k$）。对于给出的 $i$，在字典中第 $i$ 个位置应该是什么碑文呢？\n\n##### 任务\n\n写一个程序能够：\n- 从标准输入中读取数字 $n$，$k$，$i$；\n- 判定对于 $\\text{Xi-n-k}$ 魔法石，第 $i$ 个正规阅读方式（按字典序）；\n- 输出结果到标准输出。", "inputFormat": "标准输入只有一行，包含三个整数 $n,k,i$，用一个空格分开。", "outputFormat": "标准输出只有一行，应该包含 $\\text{Xi-n-k}$ 魔法石，第 $i$ 个正规阅读方式（按字典序）。\n\n如果 $\\text{Xi-n-k}$ 魔法石的数量比 $i$ 小，那么只输出一行一个短语 ``NO SUCH STONE``。", "hint": "#### 数据范围与提示\n\n对于全部数据，$0\\le k<n\\le 60$，$0<i<10^{18}$。\n\n#### 说明\n\n注：我们说 $\\text{A}$ 的碑文字典序比 $\\text{B}$ 小（假设 $\\text{A}$ 和 $\\text{B}$ 的碑文长度相同），当且仅当在第一个碑文不同的位置 $\\text{A}$ 包含 ``I`` 且 $\\text{B}$ 包含 ``X``。", "locale": "zh-CN"}}}
{"pid": "P4664", "type": "P", "difficulty": 5, "samples": [["4\n1 3 2 4", "2\n2 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["2008", "Special Judge", "背包 DP", "BalticOI（波罗的海）"], "title": "[BalticOI 2008] 选举 (Day2)", "background": null, "description": "Byteland 国的居民最近一直为议会选举投票。现在，当结果公布的时候，党派不得不决定联合组建政党。 \n\n每个党派都会获得议会中的一定席位。联合政党由这些党派中的一部分组成，他们在议会中的席位数之和**严格大于**总席位数的一半。对于联合政党来说，席位越多越好。\n\n一个**过剩**的联合政党是指联合政党中的一个党派被移出后，剩余的政党在国会中仍有过半数的席位。\n\n#### 任务\n\n请写一个程序能够：\n- 读取选举结果；\n- 找到一个在议会中有着**最大可能席位数**且**不过剩**的联合政党；\n- 输出这个联合政党的描述。", "inputFormat": "标准输入的第一行包含一个整数 $n$，表示参加选举的党派数。党派被从 $1$ 到 $n$ 编号。\n\n第二行包含 $n$ 个非负整数 $a_1,\\dots,a_n$，被一个空格隔开，第 $i$ 个整数 $a_i$ 是第 $i$ 个党派获得的席位数。你可以假设国会中的中的总席位数为小于等于 $10^5$ 的正整数。", "outputFormat": "标准输出的第一行应该包含一个整数 $k$，表示无过剩且在议会中有着最大可能席位数的联合政党中含有的党派数。\n\n第二行应该包含 $k$ 个被单个空格隔开的不同整数，表示组成联合政党的党派编号。\n\n如果有不止一个联合政党可以满足要求，你可以输出任意一个。党派的编号可以以任意顺序输出。", "hint": "对于 $40\\%$ 的数据，$n\\le 20$。\n\n对于全部数据，$1\\le n\\le 300$。", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2008] Elections (Day2)", "background": null, "description": "The citizens of Byteland have recently been voting in the parliamentary elections. Now, when the results have been published, the parties have to decide on a coalition to form the government.\n\nEach party received a certain number of seats in the parliament. The coalition must be a subset of the parties such that together they have strictly more than half of all the seats in the parliament. It is desirable for the coalition to have as many seats as possible, to ensure they can still pass their proposed laws even if a few of their members are absent from a parliament session. A coalition is called redundant if one of its parties can be removed with the remaining ones still having more than half of the seats in the parliament. Of course, such a removable party would effectively have no power — the other members of the coalition would be able to force the laws regardless of its opinion.\n\n#### Task\n\nWrite a program that:\n- reads the election results from the standard input,\n- finds a non-redundant coalition that has the maximal possible number of seats in the parliament,\n- writes the description of this coalition to the standard output.", "inputFormat": "The first line of the standard input contains one integer $n\\ (1\\le n\\le 300)$ — the number of parties that participated in the elections. The parties are numbered from $1$ to $n$.\n\nThe second line contains n nonnegative integers $a_1,\\dots,a_n$, separated by single spaces, where $a_i$ is the number of seats received by the $i$-th party. You may assume that the total number of seats in the parliament will be positive and lower or equal to $100000$.\n\nAdditionally, in test cases worth $40\\%$ of points, the number of parties will not exceed $20$.", "outputFormat": "The first line of the standard output should contain one integer $k$ — the number of parties in a non-redundant coalition which has the maximal number of seats.\n\nThe second line should contain $k$ distinct integers separated by single spaces — the numbers of parties that form the coalition.\n\nIf there are several non-redundant coalitions with the maximal number of seats, you may output any of them. The member parties can be listed in any order.", "hint": "Resource: Baltic Olympiad in Informatics 2008.", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2008] 选举 (Day2)", "background": null, "description": "Byteland 国的居民最近一直为议会选举投票。现在，当结果公布的时候，党派不得不决定联合组建政党。 \n\n每个党派都会获得议会中的一定席位。联合政党由这些党派中的一部分组成，他们在议会中的席位数之和**严格大于**总席位数的一半。对于联合政党来说，席位越多越好。\n\n一个**过剩**的联合政党是指联合政党中的一个党派被移出后，剩余的政党在国会中仍有过半数的席位。\n\n#### 任务\n\n请写一个程序能够：\n- 读取选举结果；\n- 找到一个在议会中有着**最大可能席位数**且**不过剩**的联合政党；\n- 输出这个联合政党的描述。", "inputFormat": "标准输入的第一行包含一个整数 $n$，表示参加选举的党派数。党派被从 $1$ 到 $n$ 编号。\n\n第二行包含 $n$ 个非负整数 $a_1,\\dots,a_n$，被一个空格隔开，第 $i$ 个整数 $a_i$ 是第 $i$ 个党派获得的席位数。你可以假设国会中的中的总席位数为小于等于 $10^5$ 的正整数。", "outputFormat": "标准输出的第一行应该包含一个整数 $k$，表示无过剩且在议会中有着最大可能席位数的联合政党中含有的党派数。\n\n第二行应该包含 $k$ 个被单个空格隔开的不同整数，表示组成联合政党的党派编号。\n\n如果有不止一个联合政党可以满足要求，你可以输出任意一个。党派的编号可以以任意顺序输出。", "hint": "对于 $40\\%$ 的数据，$n\\le 20$。\n\n对于全部数据，$1\\le n\\le 300$。", "locale": "zh-CN"}}}
{"pid": "P4665", "type": "P", "difficulty": 5, "samples": [["6\n1 2\n2 3\n2 4\n5 4\n6 4", "2\n1 5\n3 6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["图论", "贪心", "2015", "Special Judge", "构造", "BalticOI（波罗的海）"], "title": "[BalticOI 2015] Network", "background": "", "description": "The government of Byteland has decided that it is time to connect their little country to the Internet, so that all citizens can participate in programming competitions and watch videos of cute cats. When it was time to build the network backbone of the country, they assigned the company Internet Optimists Inc. with connecting all the $N$ computers of Byteland. The connections were made as direct links between pairs of computers in such a way that any pair of computers are connected by a sequence of links.\n\nByteland is not a rich country by any means, so to minimize costs the network topology was built in the form of a tree (i.e. there are exactly $N-1$ direct links between computers). Far too late, it was realised that this solution suffers from a serious drawback. If just a single link is broken, the computers of Byteland will be partitioned so that some computers cannot communicate with each other! To improve the reliability of Byteland's network, it was decided that it should at least tolerate if a single link is broken. Your task is to help Internet Optimists Inc. to improve the network in a cheapest way. Given the network topology of Byteland (i.e. which $N-1$ pairs of computers are connected by direct links), find the minimum number of links that need to be added so that the network will still be connected if any single link is broken.", "inputFormat": "The first line of input contains a positive integer $N$ ( $N \\geq 3$ ) , the number of computers in Byteland. For simplicity, all computers are numbered from $1$ to $N$. Each of the following $N-1$ lines contains a pair of integers $a$ and $b$ ( $1\\leq a,b \\leq n,a \\ne b$ ) that describes a direct link between computers $a$ and $b$.", "outputFormat": "In the first line of output your program should write an integer $k$, the minimal number of links that should be added to the network. In each of the following $k$ lines your program should write a pair of integers $a$ and $b$ ( $1\\leq a,b \\leq n,a \\ne b$ ) that denote the numbers of computers that should be connected by a link. The links can be written in any order. If there is more than one solution, your program should output any one of them.", "hint": "$3 \\le N \\le 500000$", "locale": "en", "translations": {"en": {"title": "[BalticOI 2015] Network", "background": "", "description": "The government of Byteland has decided that it is time to connect their little country to the Internet, so that all citizens can participate in programming competitions and watch videos of cute cats. When it was time to build the network backbone of the country, they assigned the company Internet Optimists Inc. with connecting all the $N$ computers of Byteland. The connections were made as direct links between pairs of computers in such a way that any pair of computers are connected by a sequence of links.\n\nByteland is not a rich country by any means, so to minimize costs the network topology was built in the form of a tree (i.e. there are exactly $N-1$ direct links between computers). Far too late, it was realised that this solution suffers from a serious drawback. If just a single link is broken, the computers of Byteland will be partitioned so that some computers cannot communicate with each other! To improve the reliability of Byteland's network, it was decided that it should at least tolerate if a single link is broken. Your task is to help Internet Optimists Inc. to improve the network in a cheapest way. Given the network topology of Byteland (i.e. which $N-1$ pairs of computers are connected by direct links), find the minimum number of links that need to be added so that the network will still be connected if any single link is broken.", "inputFormat": "The first line of input contains a positive integer $N$ ( $N \\geq 3$ ) , the number of computers in Byteland. For simplicity, all computers are numbered from $1$ to $N$. Each of the following $N-1$ lines contains a pair of integers $a$ and $b$ ( $1\\leq a,b \\leq n,a \\ne b$ ) that describes a direct link between computers $a$ and $b$.", "outputFormat": "In the first line of output your program should write an integer $k$, the minimal number of links that should be added to the network. In each of the following $k$ lines your program should write a pair of integers $a$ and $b$ ( $1\\leq a,b \\leq n,a \\ne b$ ) that denote the numbers of computers that should be connected by a link. The links can be written in any order. If there is more than one solution, your program should output any one of them.", "hint": "$3 \\le N \\le 500000$", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2015] Network", "background": "", "description": "拜特朗政$ $府已经决定，现在是时候将他们的小国家与互联网连接起来，以便所有公民都能参加节目比赛，观看可爱猫的视频。当是时候建设这个国家的网络骨干时，他们给互联网乐观主义者公司分配了连接所有 $N$ 个拜特兰德的电脑。这些连接是作为计算机对之间的直接连接，使任何一对计算机都通过一系列的链接连接起来。\n\n拜特朗是一个发展中国家，因此，为了将成本降到最低，网络拓扑是以树的形式构建的(即有 $N-1$ 个计算机之间的直接连接)。为时已晚，人们意识到这一解决方案存在严重缺陷。如果只有一个链接断了，那么拜特兰德的计算机就会被分割，这样一些计算机就不能互相通信了！为了提高拜特朗网络的可靠性，人们决定至少要容忍单个链路中断。你的任务是帮助互联网乐观主义者公司以最便宜的方式改进网络。给出了拜特朗的网络拓扑(即 $N-1$ 个计算机对是通过直接链接连接的)，找到需要添加的最少数量的链接，以便如果任何单个链接中断，网络仍将被连接。", "inputFormat": "输入的第一行包含一个正整数 $N(N\\geq 3)$，表示拜特兰德的计算机数量。为了简单起见，所有的计算机都是从 $1$ 到 $N$。以下 $N-1$ 行包含一对整数。$a$ 和 $b(1≤a, b≤n, a\\neq b)$，它描述计算机之间的直接链接 $a$ 和 $b$。", "outputFormat": "在输出的第一行只有一个整数k，表示应该添加到网络中的最少链接数量。在下列每一项中都有对整数 $a$ 和 $b(1\\leq a ,b\\leq n,a\\neq b)$ 表示应该通过链接连接的计算机数量。链接可以按任何顺序写入。如果有一个以上的解决方案，您的程序应该输出其中的任何一个。", "hint": "$3 \\le N \\le 500000$。", "locale": "zh-CN"}}}
{"pid": "P4666", "type": "P", "difficulty": 6, "samples": [["5 7\n1 3 2 5 2\nF 2 1\nC 3 6\nF 2 3\nC 6 8\nF 2 1\nF 2 2\nC 3 5", "3\n0\n5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2011", "线段树", "平衡树", "BalticOI（波罗的海）"], "title": "[BalticOI 2011] Growing Trees (Day1)", "background": "", "description": "For fertilizing the trees he has several bottles of MegaBoostFertilizer, which, when treated on trees, causes them to grow one centimeter up instantly. Every bottle has a limited capacity $c_i$​​ , which determines the number of trees it can be applied to. Moreover, for each bottle there is a minimal height $h_i$ of trees, which can be treated with it. Since Egon wants to have all his trees as big as possible, he always applies the fertilizer to the $c_i$​​ smallest trees chosen from the trees that are at least $h_i$​​ centimeters high.\n\nWhen Egon computes statistics about trees he has to determine the number of trees whose height is in some given interval. Egon is quite busy working in the garden, so he asked you to write a program, that given the list of his tasks, computes the statistics for him. ", "inputFormat": "The first line of the standard input contains two integers $N$ and $M$ denoting the number of trees in Egon’s garden and the number of his tasks. The second line contains a sequence of $N$ integers fromthe range $[1,N]$ describing the initial heights of the trees in centimeters. The following $M$ lines describe the tasks in chronological order. Each of those lines begins with a character $t_i$ $(t_i=F \\ or \\ C)$, which describes the type of the task.\n\nIf $t_i=F$ then two integers $c_i$​​ and $h_i$ follow. Such a line means that Egon applies a bottle of MegaBoostFertilizer to the $c_i$ smallest trees among those trees that are at least $h_i$​​ centimeters high. When there are less than $c_i$​​ trees of sufficient height, he applies the fertilizer to all such trees and discards the bottle with some fertilizer remaining.\n\nIf $t_i=C$ then two integers $\\min_i$​​ and $\\max_i$​​ follow. They denote that Egon has to compute the number of trees whose height $H$ is between $\\min_i$ and $\\max_i$​​ centimeters $(\\min_i \\le H \\le \\max_i)$. ", "outputFormat": "For every task of type C, output one line containing the number of apple trees that have the required height. The order of the results should conform to the order of type C tasks in the input.", "hint": "$1 \\le N,M \\le 10^5,1 \\le c \\le N,0 \\le h \\le 10^9,1 \\le min \\le max \\le 10^9$。", "locale": "en", "translations": {"en": {"title": "[BalticOI 2011] Growing Trees (Day1)", "background": "", "description": "For fertilizing the trees he has several bottles of MegaBoostFertilizer, which, when treated on trees, causes them to grow one centimeter up instantly. Every bottle has a limited capacity $c_i$​​ , which determines the number of trees it can be applied to. Moreover, for each bottle there is a minimal height $h_i$ of trees, which can be treated with it. Since Egon wants to have all his trees as big as possible, he always applies the fertilizer to the $c_i$​​ smallest trees chosen from the trees that are at least $h_i$​​ centimeters high.\n\nWhen Egon computes statistics about trees he has to determine the number of trees whose height is in some given interval. Egon is quite busy working in the garden, so he asked you to write a program, that given the list of his tasks, computes the statistics for him. ", "inputFormat": "The first line of the standard input contains two integers $N$ and $M$ denoting the number of trees in Egon’s garden and the number of his tasks. The second line contains a sequence of $N$ integers fromthe range $[1,N]$ describing the initial heights of the trees in centimeters. The following $M$ lines describe the tasks in chronological order. Each of those lines begins with a character $t_i$ $(t_i=F \\ or \\ C)$, which describes the type of the task.\n\nIf $t_i=F$ then two integers $c_i$​​ and $h_i$ follow. Such a line means that Egon applies a bottle of MegaBoostFertilizer to the $c_i$ smallest trees among those trees that are at least $h_i$​​ centimeters high. When there are less than $c_i$​​ trees of sufficient height, he applies the fertilizer to all such trees and discards the bottle with some fertilizer remaining.\n\nIf $t_i=C$ then two integers $\\min_i$​​ and $\\max_i$​​ follow. They denote that Egon has to compute the number of trees whose height $H$ is between $\\min_i$ and $\\max_i$​​ centimeters $(\\min_i \\le H \\le \\max_i)$. ", "outputFormat": "For every task of type C, output one line containing the number of apple trees that have the required height. The order of the results should conform to the order of type C tasks in the input.", "hint": "$1 \\le N,M \\le 10^5,1 \\le c \\le N,0 \\le h \\le 10^9,1 \\le min \\le max \\le 10^9$。", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2011] Growing Trees (Day1)", "background": "", "description": "给出一个长度为 $N$ 的数组 $a$，数组中每个数的取值范围均为 $[1,N]$（没说互不相同）。\n接下来有 $M$ 组操作，操作分为两种：\n1. $\\texttt{F}\\:\\:c\\:\\:h$  \n将满足 $a[i] \\ge h$ 的所有 $a[i]$ 中最小的 $c$ 个数都 $+1$；\n2. $\\texttt{C}\\:\\:max\\:\\:min$  \n输出满足 $min \\le a[i] \\le max$ 的 $a[i]$ 的个数。", "inputFormat": "第一行有两个整数 $N$ 和 $M$。    \n第二行有 $N$ 个整数，表示数组 $a$。  \n在接下来的 $M$ 行中，每行有一组操作。", "outputFormat": "对于每组 $\\texttt{C}\\:\\:max\\:\\:min$ 操作输出一行，每行一个整数，表示满足 $min \\le a[i] \\le max$ 的 $a[i]$ 的个数。\n\n\n翻译提供者：Planet6174", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4667", "type": "P", "difficulty": 4, "samples": [["3 5\n\\\\/\\\\\n\\\\///\n/\\\\\\\\", "1"]], "limits": {"time": [150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "线段树", "广度优先搜索 BFS", "优先队列", "最短路", "BalticOI（波罗的海）"], "title": "[BalticOI 2011] Switch the Lamp On 电路维修 (Day1)", "background": "", "description": "Casper is designing an electronic circuit on a $N \\times M$ rectangular grid plate. There are $N \\times M$ square tiles that are aligned to the grid on the plate. Two (out of four) opposite corners of each tile are connected by a wire.\n\nA power source is connected to the top left corner of the plate. A lamp is connected to the bottom right corner of the plate. The lamp is on only if there is a path of wires connecting power source to lamp. In order to switch the lamp on, any number of tiles can be turned by 90° (in both directions).\n\n![0](http://ruanx.pw/bzojch/file/2346_0.jpg)\n\nIn the picture above the lamp is off. If any one of the tiles in the second column from the right is turned by 90° , power source and lamp get connected, and the lamp is on.\n\nWrite a program to find out the minimal number of tiles that have to be turned by 90° to switch the lamp on.", "inputFormat": "The first line of input contains two integer numbers $N$ and $M$, the dimensions of the plate. In each of the following $N$ lines there are $M$ symbols – either \\ or / – which indicate the direction of the wire connecting the opposite vertices of the corresponding tile.", "outputFormat": "There must be exactly one line of output. If it is possible to switch the lamp on, this line must contain only one integer number: the minimal number of tiles that have to be turned to switch on the lamp. If it is not possible, output the string: ``NO SOLUTION``", "hint": "对于 $40\\%$ 的数据，$1 \\le N \\le 4$，$1 \\le M \\le 5$。\n\n对于所有数据，$1 \\le N,M \\le 500$。", "locale": "en", "translations": {"en": {"title": "[BalticOI 2011] Switch the Lamp On 电路维修 (Day1)", "background": "", "description": "Casper is designing an electronic circuit on a $N \\times M$ rectangular grid plate. There are $N \\times M$ square tiles that are aligned to the grid on the plate. Two (out of four) opposite corners of each tile are connected by a wire.\n\nA power source is connected to the top left corner of the plate. A lamp is connected to the bottom right corner of the plate. The lamp is on only if there is a path of wires connecting power source to lamp. In order to switch the lamp on, any number of tiles can be turned by 90° (in both directions).\n\n![0](http://ruanx.pw/bzojch/file/2346_0.jpg)\n\nIn the picture above the lamp is off. If any one of the tiles in the second column from the right is turned by 90° , power source and lamp get connected, and the lamp is on.\n\nWrite a program to find out the minimal number of tiles that have to be turned by 90° to switch the lamp on.", "inputFormat": "The first line of input contains two integer numbers $N$ and $M$, the dimensions of the plate. In each of the following $N$ lines there are $M$ symbols – either \\ or / – which indicate the direction of the wire connecting the opposite vertices of the corresponding tile.", "outputFormat": "There must be exactly one line of output. If it is possible to switch the lamp on, this line must contain only one integer number: the minimal number of tiles that have to be turned to switch on the lamp. If it is not possible, output the string: ``NO SOLUTION``", "hint": "对于 $40\\%$ 的数据，$1 \\le N \\le 4$，$1 \\le M \\le 5$。\n\n对于所有数据，$1 \\le N,M \\le 500$。", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2011] Switch the Lamp On (Day1)", "background": null, "description": "Casper 在一个 $N\\times M$ 的电路板上设计电路。有一种正方形的电路元件，在它的两组相对顶点中，有一组会用导线连接起来，另一组则不会。有 $N\\times M$ 个这样的元件，你想将其排列成 $N$ 行，每行 $M$ 个。 电源连接到板的左上角。灯连接到板的右下角。只有在电源和灯之间有一条电线连接的情况下，灯才会亮着。为了打开灯，任何数量的电路元件都可以转动 90°（两个方向）。\n\n![](https://cdn.luogu.com.cn/upload/pic/1286.png)\n\n![](https://cdn.luogu.com.cn/upload/pic/1285.png)\n\n在上面的图片中，灯是关着的。如果从右往左数第二列的任何一个电路元件被旋转 90°，电源和灯都会连接，灯被打开。现在请你编写一个程序，求出最小需要旋转多少电路元件。", "inputFormat": "输入的第一行包含两个整数 $N$ 和 $M$，表示电路板的尺寸。 在以下 $N$ 行中，每一行有 $M$ 个符号 `\\` 或 `/`，表示连接对应电路元件对角线的导线的方向。", "outputFormat": "如果可以打开灯，那么输出只包含一个整数，表示最少转动电路元件的数量。\n\n如果不可能打开灯，输出 `NO SOLUTION`。", "hint": "对于 $40\\%$ 的数据，$1 \\le N \\le 4$，$1 \\le M \\le 5$。\n\n对于所有数据，$1 \\le N,M \\le 500$。", "locale": "zh-CN"}}}
{"pid": "P4668", "type": "P", "difficulty": 4, "samples": [["5 7\nY.....V\n..I....\n..IIIII\n.......\n...T...", "YES"], ["5 7\nY....V.\n..I....\n..IIIII\n.......\n...T...", "NO"], ["2 3\n.YT\nVII", "NO"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["搜索", "2011", "BalticOI（波罗的海）"], "title": "[BalticOI 2011] Treasures and Vikings (Day1)", "background": "", "description": "You have a treasure map that is arranged into a $N \\times M$ grid. A grid square may be either sea or part of an island. In addition, the map shows the treasure and an enemy Viking ship that occupies one (sea) square. Finally, for convenience you have also drawn your own position.\n\nNow you must set up a fixed route to get the treasure. The route must start at your position, end at the treasure, and consist of a sequence of moves. In each move, you can go only to an (horizontally or vertically) adjacent square that is not part of an island. But beware: The Viking ship might follow you, using the same kind of moves! After each of your moves according to your route, the Viking ship may move or not. Your move and the Vikings’ reaction together is called a round.\n\nAfter every round, the following checks are made:\n\n-    If you are in line with the Viking ship (you are in the same vertical or horizontal line as the Viking ship with only sea between the Viking ship and you), you are dead.\n-    If you aren’t dead and at the treasure-spot, you get the treasure.\n\nWrite a program that decides whether it is possible to set up a fixed route in advance such that you can get the treasure by following this route and will not get killed by the Vikings – no matter how the Viking ship moves.", "inputFormat": "The first line of input contains two integers $N$ and $M$, the dimensions of the map. Each of the following $N$ lines contain $M$ characters. Each character describes a square in the map, and is either ``.`` (sea), ``I`` (part of an island), ``V`` (the Viking ship), ``Y`` (your position), or ``T`` (the treasure). Each of ``V``, ``Y``, and ``T`` will occur exactly once.", "outputFormat": "The only line of the output must contain the string ``YES``, if it is possible to set up a route to get the treasure, or ``NO`` otherwise.", "hint": "**Sample Explanation 1**\n\nThe route is:go down for three times,go right for three times too,go down at last.\n\n**数据范围**\n\n对于 $50\\%$ 的数据，$1 \\le N,M \\le 200$。\n\n对于所有数据，$1 \\le N,M \\le 700$。", "locale": "en", "translations": {"en": {"title": "[BalticOI 2011] Treasures and Vikings (Day1)", "background": "", "description": "You have a treasure map that is arranged into a $N \\times M$ grid. A grid square may be either sea or part of an island. In addition, the map shows the treasure and an enemy Viking ship that occupies one (sea) square. Finally, for convenience you have also drawn your own position.\n\nNow you must set up a fixed route to get the treasure. The route must start at your position, end at the treasure, and consist of a sequence of moves. In each move, you can go only to an (horizontally or vertically) adjacent square that is not part of an island. But beware: The Viking ship might follow you, using the same kind of moves! After each of your moves according to your route, the Viking ship may move or not. Your move and the Vikings’ reaction together is called a round.\n\nAfter every round, the following checks are made:\n\n-    If you are in line with the Viking ship (you are in the same vertical or horizontal line as the Viking ship with only sea between the Viking ship and you), you are dead.\n-    If you aren’t dead and at the treasure-spot, you get the treasure.\n\nWrite a program that decides whether it is possible to set up a fixed route in advance such that you can get the treasure by following this route and will not get killed by the Vikings – no matter how the Viking ship moves.", "inputFormat": "The first line of input contains two integers $N$ and $M$, the dimensions of the map. Each of the following $N$ lines contain $M$ characters. Each character describes a square in the map, and is either ``.`` (sea), ``I`` (part of an island), ``V`` (the Viking ship), ``Y`` (your position), or ``T`` (the treasure). Each of ``V``, ``Y``, and ``T`` will occur exactly once.", "outputFormat": "The only line of the output must contain the string ``YES``, if it is possible to set up a route to get the treasure, or ``NO`` otherwise.", "hint": "**Sample Explanation 1**\n\nThe route is:go down for three times,go right for three times too,go down at last.\n\n**数据范围**\n\n对于 $50\\%$ 的数据，$1 \\le N,M \\le 200$。\n\n对于所有数据，$1 \\le N,M \\le 700$。", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2011] Treasures and Vikings (Day1)", "background": "", "description": "你有一张藏宝图，这张地图被划分为一个 $N \\times M$ 的网格。一个网格可能是海洋或者是岛屿的一部分。此外，地图上标出了宝藏和占据一个（海洋）方格的敌方维京船。最后，为了方便起见，你还标出了你自己的位置。\n\n现在你必须设置一条固定的路线去获得宝藏。路线必须从你的起始位置开始，以宝藏为终点，并由一系列移动组成。在每次移动中，你只能移动到一个（水平或垂直）相邻的非岛屿方格。但要小心：维京船可能会跟随你，使用相同的移动方式！在你按照路线进行每次移动后，维京船可能会移动也可能不动。你的移动和维京船的反应合称为一轮。\n\n在每轮之后，进行以下检查：\n\n- 如果你与维京船在同一条直线上（你与维京船在同一垂直或水平线上，并且中间只有海洋），你就死了。\n- 如果你没有死并且在宝藏点上，你就获得了宝藏。\n\n编写一个程序来决定是否可以提前设置一条固定路线，使你可以通过这条路线获得宝藏，并且不会被维京人杀死——无论维京船如何移动。", "inputFormat": "输入的第一行包含两个整数 $N$ 和 $M$，表示地图的尺寸。接下来的 $N$ 行中的每一行包含 $M$ 个字符。每个字符描述地图上的一个方格，可以是 ``.``（海洋）、``I``（岛屿的一部分）、``V``（维京船）、``Y``（你的位置）或 ``T``（宝藏）。``V``、``Y`` 和 ``T`` 各出现一次。", "outputFormat": "输出的唯一一行必须包含字符串 ``YES``，如果可以设置一条路线来获得宝藏；否则输出 ``NO``。", "hint": "**样例解释 1**\n\n路线是：向下走三次，向右走三次，最后再向下走一次。\n\n**数据范围**\n\n对于 $50\\%$ 的数据，$1 \\le N,M \\le 200$。\n\n对于所有数据，$1 \\le N,M \\le 700$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4669", "type": "P", "difficulty": 5, "samples": [["9 1 1", "8"], ["6 1 2", "8"], ["6 2 1", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "贪心", "2011", "枚举", "BalticOI（波罗的海）"], "title": "[BalticOI 2011] Meetings (Day2)", "background": "", "description": "The Society for Saving the World has called their $N$ members to an emergency congress to finally agree on a plan for saving the world. To reach a common decision in any meeting at the congress, the meeting participants proceed as follows:\n\n1.    Each of them has a proposal and takes $P$ minutes to present it to the others.\n\n2.    After all participants have made their presentations, they vote for the best proposal, which takes $V$ minutes.\n\nFor example, if each proposal takes one minute $(P = 1)$ and voting also takes one minute $(V = 1)$, a meeting with $100$ participants would reach a decision in $101$ minutes. To speed up the overall decision-making process, the participants of the congress have decided to split into groups and work in parallel. Each group selects the best proposal among themselves using the procedure described above. Then the representatives of the groups meet and pick the final plan among the proposals voted best in each group. For example, if the $100$ participants would split into two groups of $40$ and $60$, respectively, the process could work as follows (again, $P = V = 1$):\n\n-    the larger group takes $61$ minutes to select their best proposal;\n-    the smaller group takes $41$ minutes to do the same and then has to wait for the larger group to finish;\n-    then the two representatives of the groups meet and spend $2$ minutes presenting to each other and $1$ minute to vote.\n\nThe total time spent is thus $61 + 2 + 1 = 64$ minutes. But the groups might further divide themselves into subgroups and sometimes it could be useful to split into more than two groups. As a special case, a subgroup of $1$ member can decide in no time, as there is no need to present one’s own proposal to oneself. Write a program that, given presentation and voting times $P$ and $V$ , computes the minimal time needed for the $N$ participants of the congress to reach a common decision, assuming they organize their meetings and groups optimally.", "inputFormat": "The first and only line of input contains the three integers $N, P,$ and $V$ : $N$ is the number of participants of the congress, $P$ is the presentation time (in minutes), and $V$ is the voting time (in minutes).", "outputFormat": "The first and only line of output should contain the integer $M$, the minimal number of minutes needed for the congress to reach a decision.", "hint": "**Sample Explanation 1**\n\nIn sample 1,the nine people should be divided into 3 groups.There should be 3 people in each group.\n\n**数据范围**\n\n对于 $40\\%$ 的数据，$1 \\le N \\le 5000$。\n\n对于 $70\\%$ 的数据，$1 \\le N \\le 5 \\times 10^4$。\n\n对于所有数据，$1 \\le N \\le 10^{15},1 \\le P,V \\le 1000$。 ", "locale": "en", "translations": {"en": {"title": "[BalticOI 2011] Meetings (Day2)", "background": "", "description": "The Society for Saving the World has called their $N$ members to an emergency congress to finally agree on a plan for saving the world. To reach a common decision in any meeting at the congress, the meeting participants proceed as follows:\n\n1.    Each of them has a proposal and takes $P$ minutes to present it to the others.\n\n2.    After all participants have made their presentations, they vote for the best proposal, which takes $V$ minutes.\n\nFor example, if each proposal takes one minute $(P = 1)$ and voting also takes one minute $(V = 1)$, a meeting with $100$ participants would reach a decision in $101$ minutes. To speed up the overall decision-making process, the participants of the congress have decided to split into groups and work in parallel. Each group selects the best proposal among themselves using the procedure described above. Then the representatives of the groups meet and pick the final plan among the proposals voted best in each group. For example, if the $100$ participants would split into two groups of $40$ and $60$, respectively, the process could work as follows (again, $P = V = 1$):\n\n-    the larger group takes $61$ minutes to select their best proposal;\n-    the smaller group takes $41$ minutes to do the same and then has to wait for the larger group to finish;\n-    then the two representatives of the groups meet and spend $2$ minutes presenting to each other and $1$ minute to vote.\n\nThe total time spent is thus $61 + 2 + 1 = 64$ minutes. But the groups might further divide themselves into subgroups and sometimes it could be useful to split into more than two groups. As a special case, a subgroup of $1$ member can decide in no time, as there is no need to present one’s own proposal to oneself. Write a program that, given presentation and voting times $P$ and $V$ , computes the minimal time needed for the $N$ participants of the congress to reach a common decision, assuming they organize their meetings and groups optimally.", "inputFormat": "The first and only line of input contains the three integers $N, P,$ and $V$ : $N$ is the number of participants of the congress, $P$ is the presentation time (in minutes), and $V$ is the voting time (in minutes).", "outputFormat": "The first and only line of output should contain the integer $M$, the minimal number of minutes needed for the congress to reach a decision.", "hint": "**Sample Explanation 1**\n\nIn sample 1,the nine people should be divided into 3 groups.There should be 3 people in each group.\n\n**数据范围**\n\n对于 $40\\%$ 的数据，$1 \\le N \\le 5000$。\n\n对于 $70\\%$ 的数据，$1 \\le N \\le 5 \\times 10^4$。\n\n对于所有数据，$1 \\le N \\le 10^{15},1 \\le P,V \\le 1000$。 ", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2011] Meetings (Day2)", "background": "", "description": "拯救世界协会召集了他们的 $N$ 名成员参加紧急会议，以最终商定一个拯救世界的计划。为了在会议上达成共识，参与者按如下步骤进行：\n\n1. 每个人都有一个提案，并花费 $P$ 分钟向其他人展示。\n2. 在所有参与者完成展示后，他们会投票选出最佳提案，这需要 $V$ 分钟。\n\n例如，如果每个提案需要一分钟（$P = 1$），投票也需要一分钟（$V = 1$），那么有 $100$ 名参与者的会议将在 $101$ 分钟内达成决议。为了加快整体决策过程，会议的参与者决定分成小组并行工作。每个小组使用上述程序选出自己的最佳提案。然后，各小组的代表会面，从每个小组投票选出的最佳提案中选出最终计划。例如，如果 $100$ 名参与者分成两个小组，分别为 $40$ 人和 $60$ 人，过程可能如下（同样，$P = V = 1$）：\n\n- 较大组花费 $61$ 分钟选出他们的最佳提案；\n- 较小组花费 $41$ 分钟做同样的事情，然后必须等待较大组完成；\n- 然后两个小组的代表会面，花费 $2$ 分钟互相展示，$1$ 分钟投票。\n\n因此，总共花费的时间是 $61 + 2 + 1 = 64$ 分钟。但小组可能会进一步分成子小组，有时分成两个以上的小组可能更有用。作为一个特例，一个成员的小组可以立即做出决定，因为不需要向自己展示自己的提案。编写一个程序，给定展示和投票时间 $P$ 和 $V$，计算出会议的 $N$ 名参与者在最优组织会议和小组情况下达成共识所需的最少时间。", "inputFormat": "输入的第一行也是唯一一行包含三个整数 $N, P, V$：$N$ 是会议的参与者人数，$P$ 是展示时间（以分钟为单位），$V$ 是投票时间（以分钟为单位）。", "outputFormat": "输出的第一行也是唯一一行应包含整数 $M$，即会议达成决议所需的最少分钟数。", "hint": "**样例解释 1**\n\n在样例 1 中，九个人应分成 3 组。每组应有 3 个人。\n\n**数据范围**\n\n对于 $40\\%$ 的数据，$1 \\le N \\le 5000$。\n\n对于 $70\\%$ 的数据，$1 \\le N \\le 5 \\times 10^4$。\n\n对于所有数据，$1 \\le N \\le 10^{15},1 \\le P,V \\le 1000$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4670", "type": "P", "difficulty": 3, "samples": [["2\n2 1", "0"], ["5\n1 1 1 1 1", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "BalticOI（波罗的海）"], "title": "[BalticOI 2011] Plagiarism (Day2)", "background": "", "description": "The participants of the World Programming Competition submitted $N$ solution files $f_1 ,...,f_N$ to the grading system. Before accepting the results as final, the jury would like to rule out any possibility of plagiarism. They have a program that takes two files and compares them to decide if they are too similar to each other.\n\nHowever, the number of files is rather big and it would take too much time to compare all pairs. On the other hand, many pairs could be quickly eliminated based on the fact that the file sizes are too different.\n\nMore precisely, the jury decided to fully skip comparing every pair where the size of the smaller file is less than 90% of the size of the larger one. So, the comparison program has to examine only those distinct pairs of files $(f_i, f_j)$ where $i≠j, size(f_i) \\le size(f_j)$ and $size(f_i) \\ge 0.9 \\times size(f_j)$.\n\nWrite a program that computes the number of pairs of files that will have to be examined.", "inputFormat": "The first line of input contains the integer $N$, the number of solution files submitted. The second line contains $N$ integers $size(f_1),\\cdots,size(f_N)$, each showing the size of one file.", "outputFormat": "The first and only line of output must contain one integer, the number of pairs of files that will have to be examined.", "hint": "对于 $50\\%$ 的数据，$1 \\le N \\le 2000$。\n\n对于所有数据，$1 \\le N \\le 10^5,1 \\le f_i \\le 10^8$。", "locale": "en", "translations": {"en": {"title": "[BalticOI 2011] Plagiarism (Day2)", "background": "", "description": "The participants of the World Programming Competition submitted $N$ solution files $f_1 ,...,f_N$ to the grading system. Before accepting the results as final, the jury would like to rule out any possibility of plagiarism. They have a program that takes two files and compares them to decide if they are too similar to each other.\n\nHowever, the number of files is rather big and it would take too much time to compare all pairs. On the other hand, many pairs could be quickly eliminated based on the fact that the file sizes are too different.\n\nMore precisely, the jury decided to fully skip comparing every pair where the size of the smaller file is less than 90% of the size of the larger one. So, the comparison program has to examine only those distinct pairs of files $(f_i, f_j)$ where $i≠j, size(f_i) \\le size(f_j)$ and $size(f_i) \\ge 0.9 \\times size(f_j)$.\n\nWrite a program that computes the number of pairs of files that will have to be examined.", "inputFormat": "The first line of input contains the integer $N$, the number of solution files submitted. The second line contains $N$ integers $size(f_1),\\cdots,size(f_N)$, each showing the size of one file.", "outputFormat": "The first and only line of output must contain one integer, the number of pairs of files that will have to be examined.", "hint": "对于 $50\\%$ 的数据，$1 \\le N \\le 2000$。\n\n对于所有数据，$1 \\le N \\le 10^5,1 \\le f_i \\le 10^8$。", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2011] Plagiarism (Day2)", "background": null, "description": "世界编程竞赛的参与者向评分系统提交了 $N$ 个解决方案文件 $f_1 ,...,f_N$。在接受结果为最终结果之前，评审团希望排除任何抄袭的可能性。他们有一个程序，可以将两个文件进行比较，以决定它们是否过于相似。然而，文件的数量相当大，比较所有对将花费太多时间。另一方面，许多对可以基于文件大小差异过大而快速排除。更确切地说，评审团决定完全跳过比较每一对，其中较小文件的大小小于较大文件大小的 90%。因此，比较程序只需检查那些不同的文件对 $(f_i, f_j)$，其中 $i \n\\ne j, size(f_i) \\le size(f_j)$ 且 $size(f_i) \\ge 0.9 \\times size(f_j)$。编写一个程序来计算需要检查的文件对的数量。", "inputFormat": "输入的第一行包含整数 $N$，表示提交的解决方案文件的数量。第二行包含 $N$ 个整数 $size(f_1),\\cdots,size(f_N)$，每个整数表示一个文件的大小。", "outputFormat": "输出的第一行且唯一一行必须包含一个整数，即需要检查的文件对的数量。", "hint": "对于 $50\\%$ 的数据，$1 \\le N \\le 2000$。对于所有数据，$1 \\le N \\le 10^5,1 \\le f_i \\le 10^8$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4671", "type": "P", "difficulty": 3, "samples": [["3\n5 1\n2 4\n1 1", "10.0"], ["5\n0 0\n-2 2\n-2 -1\n2 -2\n2 0", "12.5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "2011", "Special Judge", "BalticOI（波罗的海）"], "title": "[BalticOI 2011] Polygon (Day2)", "background": "", "description": "A simple polygon with $N$ vertices is drawn on an infinite rectangular grid. For such a polygon, only neighboring edges touch at their common vertex; no other of its edges intersect or touch. All vertices of the polygon lie on grid points, i.e., vertices have integer coordinates.\n\nYour task is to find the total length of grid line segments which lie strictly inside the given polygon (these line segments are highlighted in the drawings below).", "inputFormat": "The first line of input contains a single integer $N$, the number of vertices of the polygon. Each of the following $N$ lines contains two integers $x$ and $y$, the coordinates of one vertex. The vertices are given either in clockwise or counterclockwise order. All vertices are distinct, but more than two consecutive vertices may lie on a line.", "outputFormat": "The only line of output must contain a decimal number: the total length of grid line segments which lie strictly inside the given polygon.", "hint": "**Sample Explanation 1**\n\nThe length of horizontal lines is $\\frac{4}{3} + \\frac{8}{3} = 4$. The length of vertical lines is $3 + 2 + 1 = 6$. The total length is $4 + 6 = 10$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3hnegtvj.png)\n\n**Sample Explanation 2**\n\nThe length of horizontal lines is $1+2+4 = 7$. The length of vertical lines is $\\frac{9}{4}+\\frac{3}{2}+\\frac{7}{4} = 5.5$. The total length is $7 + 5.5 = 12.5$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8can7qby.png)\n\n**数据范围**\n\n对于 $50\\%$ 的数据，多边形所有的边均在网格线上。\n\n对于所有数据，$3 \\le N \\le 10^5,-5 \\times 10^8 \\le x,y \\le 5 \\times 10^8$。", "locale": "en", "translations": {"en": {"title": "[BalticOI 2011] Polygon (Day2)", "background": "", "description": "A simple polygon with $N$ vertices is drawn on an infinite rectangular grid. For such a polygon, only neighboring edges touch at their common vertex; no other of its edges intersect or touch. All vertices of the polygon lie on grid points, i.e., vertices have integer coordinates.\n\nYour task is to find the total length of grid line segments which lie strictly inside the given polygon (these line segments are highlighted in the drawings below).", "inputFormat": "The first line of input contains a single integer $N$, the number of vertices of the polygon. Each of the following $N$ lines contains two integers $x$ and $y$, the coordinates of one vertex. The vertices are given either in clockwise or counterclockwise order. All vertices are distinct, but more than two consecutive vertices may lie on a line.", "outputFormat": "The only line of output must contain a decimal number: the total length of grid line segments which lie strictly inside the given polygon.", "hint": "**Sample Explanation 1**\n\nThe length of horizontal lines is $\\frac{4}{3} + \\frac{8}{3} = 4$. The length of vertical lines is $3 + 2 + 1 = 6$. The total length is $4 + 6 = 10$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3hnegtvj.png)\n\n**Sample Explanation 2**\n\nThe length of horizontal lines is $1+2+4 = 7$. The length of vertical lines is $\\frac{9}{4}+\\frac{3}{2}+\\frac{7}{4} = 5.5$. The total length is $7 + 5.5 = 12.5$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8can7qby.png)\n\n**数据范围**\n\n对于 $50\\%$ 的数据，多边形所有的边均在网格线上。\n\n对于所有数据，$3 \\le N \\le 10^5,-5 \\times 10^8 \\le x,y \\le 5 \\times 10^8$。", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2011] Polygon (Day2)", "background": null, "description": "在一个无限的矩形网格上画了一个有 $N$ 个顶点的简单多边形。对于这样的多边形，只有相邻的边在它们的公共顶点处相接；没有其他边相交或接触。多边形的所有顶点都位于网格点上，即顶点具有整数坐标。\n\n你的任务是找到严格位于给定多边形内部的网格线段的总长度（这些线段在下面的图中被高亮显示）。", "inputFormat": "输入的第一行包含一个整数 $N$，表示多边形的顶点数。接下来的 $N$ 行中的每一行包含两个整数 $x$ 和 $y$，表示一个顶点的坐标。顶点按顺时针或逆时针顺序给出。所有顶点都是不同的，但可能有多个连续的顶点位于一条线上。", "outputFormat": "输出的唯一一行必须包含一个小数：严格位于给定多边形内部的网格线段的总长度。", "hint": "**样例解释 1**\n\n水平线的长度是 $\\frac{4}{3} + \\frac{8}{3} = 4$。垂直线的长度是 $3 + 2 + 1 = 6$。总长度是 $4 + 6 = 10$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3hnegtvj.png)\n\n**样例解释 2**\n\n水平线的长度是 $1+2+4 = 7$。垂直线的长度是 $\\frac{9}{4}+\\frac{3}{2}+\\frac{7}{4} = 5.5$。总长度是 $7 + 5.5 = 12.5$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8can7qby.png)\n\n**数据范围**\n\n对于 $50\\%$ 的数据，多边形的所有边均在网格线上。\n\n对于所有数据，$3 \\le N \\le 10^5,-5 \\times 10^8 \\le x,y \\le 5 \\times 10^8$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4672", "type": "P", "difficulty": 7, "samples": [["7 7\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 1", "NO"], ["6 6\n1 2\n2 3\n2 4\n3 5\n4 5\n5 6", "YES"], ["22 28\n13 8\n8 1\n1 22\n1 12\n1 14\n13 18\n13 4\n4 20\n20 7\n13 15\n15 3\n15 9\n9 16\n9 19\n22 5\n12 5\n14 5\n5 11\n11 6\n18 6\n7 10\n10 17\n17 6\n3 21\n21 6\n16 2\n19 2\n2 21", "YES"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2011", "BalticOI（波罗的海）"], "title": "[BalticOI 2011] Tree Mirroring (Day2)", "background": "", "description": "Let $T$ be a rooted tree (a connected undirected acylic graph), and let $S$ be a perfect copy of $T$. Construct a new graph by taking the union of $T$ and $S$, and merging the corresponding leaf nodes (but never the root). We call such a graph a tree-mirrored graph.", "inputFormat": "The first line of input contains two integers $N$ and $M$, the number of vertices and edges of a graph $G$. The vertices in $G$ are labeled from $1$ to $N$. The following $M$ lines describe the edges. Each such line contains two integers $x$ and $y(x≠y;1 \\le x,y \\le N)$, describing one edge. There will be at most one edge between any pair of vertices.", "outputFormat": "The first and only line of output should contain the string ``YES`` if the graph $G$ is a tree-mirrored graph, and ``NO`` otherwise.", "hint": "对于 $30\\%$ 的数据，$3 \\le N,M \\le 300$。\n\n对于 $60\\%$ 的数据，$3 \\le N,M \\le 3500$。\n\n对于所有数据，$3 \\le N,M \\le 10^5$。", "locale": "en", "translations": {"en": {"title": "[BalticOI 2011] Tree Mirroring (Day2)", "background": "", "description": "Let $T$ be a rooted tree (a connected undirected acylic graph), and let $S$ be a perfect copy of $T$. Construct a new graph by taking the union of $T$ and $S$, and merging the corresponding leaf nodes (but never the root). We call such a graph a tree-mirrored graph.", "inputFormat": "The first line of input contains two integers $N$ and $M$, the number of vertices and edges of a graph $G$. The vertices in $G$ are labeled from $1$ to $N$. The following $M$ lines describe the edges. Each such line contains two integers $x$ and $y(x≠y;1 \\le x,y \\le N)$, describing one edge. There will be at most one edge between any pair of vertices.", "outputFormat": "The first and only line of output should contain the string ``YES`` if the graph $G$ is a tree-mirrored graph, and ``NO`` otherwise.", "hint": "对于 $30\\%$ 的数据，$3 \\le N,M \\le 300$。\n\n对于 $60\\%$ 的数据，$3 \\le N,M \\le 3500$。\n\n对于所有数据，$3 \\le N,M \\le 10^5$。", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2011] Tree Mirroring (Day2)", "background": null, "description": "对于一棵树 $T$，并复制一棵与 $T$ 同构的树 $S$。构造一个新的图 $T'$，新图 $T'$ 通过合并 $T$ 和 $S$ 中相应的非根叶节点得到。我们称这样的图为树之镜像图。\n\n给定一个图 $G$，你需要判断 $G$ 是否是树之镜像图。", "inputFormat": "输入的第一行包含两个整数 $N$ 和 $M$，表示图 $G$ 的顶点和边数。\n\n接下来有 $M$ 行，每一行包含两个正整数 $x$ 和 $y$（$x \\neq y$ 且 $1 \\leq x,y \\leq n$）表示顶点 $x$ 和 $y$ 之间有一条边。保证没有重边。", "outputFormat": "输出只有一行，判断图 $G$ 是否是一个树之镜像图，是输出 `YES`，否则输出 `NO`。\n\nTranslated by @找寻", "hint": null, "locale": "zh-CN"}}}
{"pid": "P4673", "type": "P", "difficulty": 4, "samples": [["3 6 2 100\n1 3 10 20 30 40\n3 2 32 35 95 95\n1 1 1 1 7 8\n1 3 8 8 9 9\n2 2 98 98 99 99\n1 2 0 0 99 101", "32"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2005", "拓扑排序", "BalticOI（波罗的海）"], "title": "[BalticOI 2005] Bus Trip (Day2)", "background": null, "description": "有 $N$ 座城镇，和城镇之间的 $M$ 条单向直达的巴士线路（没有中间停靠站）。城镇从 $1$ 到 $N$ 标号。一个旅行者在 $0$ 时刻位于 $1$ 号城镇，想要到达 $P$ 号城镇。他将乘坐巴士在 $T$ 时刻到达 $P$ 号城镇。如果他早到了，他必须等待。\n\n对于任意一个巴士线路 $i$，我们知道其中的出发地城镇 $s_i$ 和目的地城镇 $t_i$。我们也同样知道 $i$ 的出发时间和到达时间，但仅仅是近似值：我们知道巴士离开出发地城镇 $s_i$ 在时间范围 $[a_i, b_i]$ 内，且到达目的地城镇 $t_i$ 在时间范围 $[c_i, d_i]$ 内（端点值包括在内）。\n\n旅行者不喜欢等待，因此他要寻找一个旅行计划使得最大等待时间尽量小，同时保证绝对不会错过计划中的任何一辆巴士（意思是，每次他换乘巴士，他需要下车的巴士的最晚到达时间不会迟于他需要搭乘的下一辆巴士的最早出发时间）。\n\n当计算等待时间时，我们必须假设最早可能到达的时间和最晚可能发车的时间。\n\n编写一个程序，帮助旅行者寻找一个合适的计划。", "inputFormat": "第一行包含整数 $N,M,P,T$，含义见题目描述。\n\n接下来 $M$ 行描述了巴士线路。每行包含整数 $s_i, t_i, a_i, b_i, c_i, d_i$，其中 $s_i$ 和 $t_i$ 是巴士线路 $i$ 的出发地和目的地，$a_i, b_i, c_i, d_i$ 描述了出发和到达时间。", "outputFormat": "仅一行，包含对于最合适的可能的旅行计划的最大的可能的总等待时间。如果不可能保证在 $T$ 时刻到达城镇 $P$，这一行应当包含 `-1`。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\leq P \\leq N \\leq 5\\times 10^4$，$1 \\leq M \\leq 10^5$，$0 \\leq T \\leq 10^9$，$1 \\leq s_i,t_i \\leq N$，$0 \\leq a_i \\leq b_i < c_i \\leq d_i \\leq 10^9$。\n\n#### 说明\n\n翻译自 [BalticOI 2005 Day2 B Bus Trip](https://boi.cses.fi/files/boi2005_day2.pdf)。", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2005] Bus Trip (Day2)", "background": "", "description": "There are $N$ towns and $M$ one-way direct bus routes between the towns (with no intermediate stops). The towns are numbered from $1$ to $N$. A traveler is in town $1$ at time $0$ and wants to reach town $P$. He will arrive at town $P$ at time $T$ by taking buses. If he arrives earlier, he must wait.\n\nFor each bus route $i$, we know its starting town $s_i$ and destination town $t_i$. We also know its departure and arrival times, but only approximately: we know the bus leaves the starting town $s_i$ within the time interval $[a_i, b_i]$, and arrives at the destination town $t_i$ within the time interval $[c_i, d_i]$ (endpoints included).\n\nThe traveler dislikes waiting, so he wants to find a travel plan that minimizes the maximum waiting time, while also guaranteeing that he will never miss any bus in the plan (that is, each time he transfers, the latest possible arrival time of the bus he gets off is not later than the earliest possible departure time of the next bus he needs to take).\n\nWhen computing waiting time, we must assume the earliest possible arrival time and the latest possible departure time.\n\nWrite a program to help the traveler find a suitable plan.", "inputFormat": "The first line contains integers $N, M, P, T$, as described above.\n\nThe next $M$ lines describe the bus routes. Each line contains integers $s_i, t_i, a_i, b_i, c_i, d_i$, where $s_i$ and $t_i$ are the starting town and destination of route $i$, and $a_i, b_i, c_i, d_i$ describe the departure and arrival times.", "outputFormat": "Output one line containing the maximum possible total waiting time for the best possible travel plan. If it is impossible to guarantee arrival at town $P$ at time $T$, this line should contain `-1`.", "hint": "#### Constraints\n\nFor $100\\%$ of the testdata, $1 \\leq P \\leq N \\leq 5\\times 10^4$, $1 \\leq M \\leq 10^5$, $0 \\leq T \\leq 10^9$, $1 \\leq s_i, t_i \\leq N$, $0 \\leq a_i \\leq b_i < c_i \\leq d_i \\leq 10^9$.\n\n#### Notes\n\nTranslated from [BalticOI 2005 Day2 B Bus Trip](https://boi.cses.fi/files/boi2005_day2.pdf)。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2005] Bus Trip (Day2)", "background": null, "description": "有 $N$ 座城镇，和城镇之间的 $M$ 条单向直达的巴士线路（没有中间停靠站）。城镇从 $1$ 到 $N$ 标号。一个旅行者在 $0$ 时刻位于 $1$ 号城镇，想要到达 $P$ 号城镇。他将乘坐巴士在 $T$ 时刻到达 $P$ 号城镇。如果他早到了，他必须等待。\n\n对于任意一个巴士线路 $i$，我们知道其中的出发地城镇 $s_i$ 和目的地城镇 $t_i$。我们也同样知道 $i$ 的出发时间和到达时间，但仅仅是近似值：我们知道巴士离开出发地城镇 $s_i$ 在时间范围 $[a_i, b_i]$ 内，且到达目的地城镇 $t_i$ 在时间范围 $[c_i, d_i]$ 内（端点值包括在内）。\n\n旅行者不喜欢等待，因此他要寻找一个旅行计划使得最大等待时间尽量小，同时保证绝对不会错过计划中的任何一辆巴士（意思是，每次他换乘巴士，他需要下车的巴士的最晚到达时间不会迟于他需要搭乘的下一辆巴士的最早出发时间）。\n\n当计算等待时间时，我们必须假设最早可能到达的时间和最晚可能发车的时间。\n\n编写一个程序，帮助旅行者寻找一个合适的计划。", "inputFormat": "第一行包含整数 $N,M,P,T$，含义见题目描述。\n\n接下来 $M$ 行描述了巴士线路。每行包含整数 $s_i, t_i, a_i, b_i, c_i, d_i$，其中 $s_i$ 和 $t_i$ 是巴士线路 $i$ 的出发地和目的地，$a_i, b_i, c_i, d_i$ 描述了出发和到达时间。", "outputFormat": "仅一行，包含对于最合适的可能的旅行计划的最大的可能的总等待时间。如果不可能保证在 $T$ 时刻到达城镇 $P$，这一行应当包含 `-1`。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\leq P \\leq N \\leq 5\\times 10^4$，$1 \\leq M \\leq 10^5$，$0 \\leq T \\leq 10^9$，$1 \\leq s_i,t_i \\leq N$，$0 \\leq a_i \\leq b_i < c_i \\leq d_i \\leq 10^9$。\n\n#### 说明\n\n翻译自 [BalticOI 2005 Day2 B Bus Trip](https://boi.cses.fi/files/boi2005_day2.pdf)。", "locale": "zh-CN"}}}
{"pid": "P4674", "type": "P", "difficulty": 5, "samples": [["4\n1 4\n3 1 3 4\n2 1 2\n1 3\n", "8"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2016", "O2优化", "BalticOI（波罗的海）"], "title": "[BalticOI 2016] Bosses (day1)", "background": "", "description": "A company of $n$ employees is due for a restructuring. In the resulting hierarchy,represented as a rooted tree, every node will be the boss of its children.\n\nEach employee has a list of bosses they will accept. In addition, all employees mustbe assigned a salary. The salary must be a positive integer, and the salary of eachboss must be larger than the sum of salaries of their immediate subordinates.\n\nYour task is to structure the company so that all above conditions hold, and the sumof all the salaries is as small as possible.", "inputFormat": "The first input line contains an integer $n$ : the number of employees. The employees are numbered $1,2,...,n$\n\n.After this, the input contains $n$ lines that describe the preferences of the employees.The $i$th such line contains an integer $k_i$ , followed by a list of $k_i$ integers. The list consists of all employees that the $i$th employee accepts as their boss.", "outputFormat": "You should output the lowest total salary among all valid restructurings. You can assume that at least one solution exists.", "hint": "### Subtask 1 (22 points)\n\n- $2\\leq n \\leq 10$\n\n- $\\sum^n_{i=1}k_i\\leq 20$\n\n### Subtask 2 (45 points)\n\n- $2\\leq n \\leq 100$\n\n- $\\sum^n_{i=1}k_i\\leq 200$\n\n### Subtask 3 (33 points)\n\n- $2\\leq n \\leq 5000$\n\n- $\\sum^n_{i=1}k_i\\leq 10000$", "locale": "en", "translations": {"en": {"title": "[BalticOI 2016] Bosses (day1)", "background": "", "description": "A company of $n$ employees is due for a restructuring. In the resulting hierarchy,represented as a rooted tree, every node will be the boss of its children.\n\nEach employee has a list of bosses they will accept. In addition, all employees mustbe assigned a salary. The salary must be a positive integer, and the salary of eachboss must be larger than the sum of salaries of their immediate subordinates.\n\nYour task is to structure the company so that all above conditions hold, and the sumof all the salaries is as small as possible.", "inputFormat": "The first input line contains an integer $n$ : the number of employees. The employees are numbered $1,2,...,n$\n\n.After this, the input contains $n$ lines that describe the preferences of the employees.The $i$th such line contains an integer $k_i$ , followed by a list of $k_i$ integers. The list consists of all employees that the $i$th employee accepts as their boss.", "outputFormat": "You should output the lowest total salary among all valid restructurings. You can assume that at least one solution exists.", "hint": "### Subtask 1 (22 points)\n\n- $2\\leq n \\leq 10$\n\n- $\\sum^n_{i=1}k_i\\leq 20$\n\n### Subtask 2 (45 points)\n\n- $2\\leq n \\leq 100$\n\n- $\\sum^n_{i=1}k_i\\leq 200$\n\n### Subtask 3 (33 points)\n\n- $2\\leq n \\leq 5000$\n\n- $\\sum^n_{i=1}k_i\\leq 10000$", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2016] Bosses (day1)", "background": null, "description": "[BalticOI 2016 Day1]上司们\n\n\n一家有 $n$ 名员工的公司将进行重组。在重组后的层级结构中（表示为一棵有根树），每个节点将作为其子节点的上司。\n\n每位员工都有一个可以接受的上司列表。此外，所有员工都必须被分配一个薪水。薪水必须是一个正整数，并且每位上司的薪水必须大于其直接下属薪水之和。\n\n你的任务是安排公司的结构，以确保满足上述所有条件，并且所有员工的薪水总和尽可能小。", "inputFormat": "第一行输入包含一个整数 $n$ ，表示员工数量。员工编号为 $1, 2, \\dots, n$。（$n\\leq 5000$）\n\n接下来的 $n$ 行描述每个员工的上司偏好。第 $i$ 行包含一个整数 $k_i$，后跟一个 $k_i$ 整数的列表。该列表包括第 $i$ 位员工可以接受的所有上司的编号。", "outputFormat": "你需要输出所有符合条件的重组方案中，最低的薪水总和。可以假设至少存在一种可行方案。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P4675", "type": "P", "difficulty": 5, "samples": [["5 3\n16 11\n11 8 1\n6 10 1\n7 3 2\n10 4 1\n15 5 1\n1 1\n2 2\n2 1\n", "1234\n2\n14\n"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2016", "O2优化", "BalticOI（波罗的海）"], "title": "[BalticOI 2016] Park (day1)", "background": "", "description": "In the capital of Byteland, there is a fenced park whose area is a rectangle. The trees and the visitors in the park are represented as circles.\n\nThere are four entrances in the park, one in each corner (1 = bottom-left, 2 =bottom-right, 3 = top-right, 4 = top-left). The visitors can enter and exit the park only through the entrances.\n\nVisitors can enter and exit the park when they touch both sides of a corner of the corresponding entrance. Visitors can move freely in the park, but they cannot overlap any of the trees or the fence.\n\nYour task is to calculate for each visitor, given the entrance they will enter the park,through which entrances they can exit the park.", "inputFormat": "The first input line contains two integers $w$ and $h$ : the number of trees in the park and the number of visitors.\n\nThe second input line contains two integers $w$ and $h$ : the width and the height of the park area. The bottom-left corner is $(0,0)$, and the top-right corner is $(w,h)$.\n\nAfter this, there are  lines that describe the trees. Each line contains three integers, $x,y$ and $r$ : the center of the tree is $(x,y)$ and its radius is $r$. The trees do not overlap each other or the fence.\n\nFinally, there are $m$ lines that describe the visitors. Each line contains two integers $r$ and $e$ : the radius of the visitor and the entrance they will enter the park.\n\nIn addition, no tree overlaps a square area of $2k\\times2k$ in each corner, where $k$ is the radius of the largest visitor.", "outputFormat": "You should output for each visitor a single line containing the entrances through which they can exit the park, in sorted order without spaces in between.", "hint": "Two objects touch if they have one common point. Two objects overlap if they have more than one common point.\n\n## 样例解释\n\nThe following figure shows the entrance areas and possible routes for each visitor:\n\n![](https://cdn.luogu.com.cn/upload/pic/20869.png)\n\n## Subtasks\n\nIn all subtasks $4k\\leq w,h\\leq10^9$ where $k$ is the radius of the largest visitor.\n\n### Subtask 1 (27 points)\n\n- $1\\leq n\\leq2000$\n\n- $m=1$\n\n### Subtask 2 (31 points)\n\n- $1\\leq n\\leq200$\n\n- $1\\leq m\\leq10^5$\n\n### Subtask 3 (42 points)\n\n- $1\\leq n\\leq2000$\n\n- $1\\leq m\\leq10^5$\n", "locale": "en", "translations": {"en": {"title": "[BalticOI 2016] Park (day1)", "background": "", "description": "In the capital of Byteland, there is a fenced park whose area is a rectangle. The trees and the visitors in the park are represented as circles.\n\nThere are four entrances in the park, one in each corner (1 = bottom-left, 2 =bottom-right, 3 = top-right, 4 = top-left). The visitors can enter and exit the park only through the entrances.\n\nVisitors can enter and exit the park when they touch both sides of a corner of the corresponding entrance. Visitors can move freely in the park, but they cannot overlap any of the trees or the fence.\n\nYour task is to calculate for each visitor, given the entrance they will enter the park,through which entrances they can exit the park.", "inputFormat": "The first input line contains two integers $w$ and $h$ : the number of trees in the park and the number of visitors.\n\nThe second input line contains two integers $w$ and $h$ : the width and the height of the park area. The bottom-left corner is $(0,0)$, and the top-right corner is $(w,h)$.\n\nAfter this, there are  lines that describe the trees. Each line contains three integers, $x,y$ and $r$ : the center of the tree is $(x,y)$ and its radius is $r$. The trees do not overlap each other or the fence.\n\nFinally, there are $m$ lines that describe the visitors. Each line contains two integers $r$ and $e$ : the radius of the visitor and the entrance they will enter the park.\n\nIn addition, no tree overlaps a square area of $2k\\times2k$ in each corner, where $k$ is the radius of the largest visitor.", "outputFormat": "You should output for each visitor a single line containing the entrances through which they can exit the park, in sorted order without spaces in between.", "hint": "Two objects touch if they have one common point. Two objects overlap if they have more than one common point.\n\n## 样例解释\n\nThe following figure shows the entrance areas and possible routes for each visitor:\n\n![](https://cdn.luogu.com.cn/upload/pic/20869.png)\n\n## Subtasks\n\nIn all subtasks $4k\\leq w,h\\leq10^9$ where $k$ is the radius of the largest visitor.\n\n### Subtask 1 (27 points)\n\n- $1\\leq n\\leq2000$\n\n- $m=1$\n\n### Subtask 2 (31 points)\n\n- $1\\leq n\\leq200$\n\n- $1\\leq m\\leq10^5$\n\n### Subtask 3 (42 points)\n\n- $1\\leq n\\leq2000$\n\n- $1\\leq m\\leq10^5$\n", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2016] Park (day1)", "background": "", "description": "在 Byteland 的首都，有一个以围墙包裹的矩形公园，其中以圆形表示游客和树。  \n公园里有四个入口，分别在四个角落（$1, 2, 3, 4$ 分别对应左下、右下、右上、左上）。游客只能从入口进出。  \n游客可以在他们与公园的两邻边相切的时候进出对应的入口。游客可以在公园里自由活动但不允许与树重叠。  \n你的任务是为每个游客计算，给定他们进入公园的入口，他们可以从哪个入口离开公园。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$，分别为树的个数和游客的个数。  \n第二行包含两个整数 $w$ 和 $h$，公园的左下角在 $(0,0)$，右上角在 $(w,h)$。  \n接下来 $n$ 行，每行三个整数 $x,y$ 和 $r$，表示有一棵圆心在 $(x,y)$ 且半径为 $r$ 的树。保证树与树之间不会互相重叠。  \n接下来 $m$ 行，每行两个整数 $r$ 和 $e$，表示有一个半径为 $r$ 的游客从入口 $e$ 进入。  \n此外，保证没有树会与每个角落的一个大小为 $2k^2$ 的方形区域重叠，$k$ 表示最大的游客半径。", "outputFormat": "对于每个游客，输出没有空格的一行，表示该游客可以从这几个入口离开，按照升序排列。", "hint": "两个物体有重叠定义为它们不止一个公共点。\n\n下图展示了每个游客的入口和可能的路线：\n\n![](https://i.loli.net/2018/08/11/5b6e30c4b5a35.png)\n\n对于每个子任务，$4k \\leq w,h \\leq 10^9$，$k$表示最大的游客半径。\n\n|子任务|分数|数据范围|\n|:-:|:-:|-|\n|1|27|$1 \\leq n \\leq 2000,m=1$|\n|2|31|$1 \\leq n \\leq 200,1 \\leq m \\leq 10^5$|\n|3|42|$1 \\leq n \\leq 2000,1 \\leq m \\leq 10^5$|\n\n由 @I_love_him52 提供翻译", "locale": "zh-CN"}}}
{"pid": "P4676", "type": "P", "difficulty": 5, "samples": [["2 3\n0 -2 1 1\n-1 0 1 0\n1 2 1 2\n", "74\n9\n14\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500], "memory": [256000, 256000, 256000, 256000, 256000]}, "tags": ["2016", "BalticOI（波罗的海）"], "title": "[BalticOI 2016] Spiral (day1)", "background": "", "description": "A grid of size $(2n+1)\\times(2n+1)$ has been constructed as follows. Number $1$ has been placed in the center square, number $2$ has been placed to the right of it, and the following numbers have been placed along the spiral counterclockwise.\n\nYour task is to calculate answers for $q$ queries where the sum of numbers in an rectangular region in the grid is requested (modulo $10^9+7$). For example, in the following grid $n=2$ and the sum of numbers in the gray region is $74$ :\n\n![](https://cdn.luogu.com.cn/upload/pic/20871.png)", "inputFormat": "The first input line contains two integers $n$ and $q$ : the size of the grid and the number of queries.\n\nAfter this, there are $q$ lines, each containing four integers $x_1, y_1, x_2$  and $y_2$ ($-n\\leq x_1\\leq x_2\\leq n, -n\\leq y_1\\leq y_2\\leq n$). This means that you should calculate the sum of numbers in a rectangular region with corners $(x_1,y_1)$ and $(x_2,y_2)$.", "outputFormat": "You should output the answer for each query (modulo $10^9+7$).\n", "hint": "## Subtasks\n\nIn all subtasks $1\\leq q\\leq100$.\n\n### Subtask 1 (12 points)\n\n- $1\\leq n\\leq1000$\n\n### Subtask 2 (15 points)\n\n- $1\\leq n\\leq10^9$\n\n- $x_1=x_2$ and $y_1=y_2$\n\n### Subtask 3 (17 points)\n\n- $1\\leq n\\leq10^5$\n\n### Subtask 4 (31 points)\n\n- $1\\leq n\\leq10^9$\n\n- $x_1=y_1=1$\n\n### Subtask 5 (25 points)\n\n- $1\\leq n\\leq10^9$\n", "locale": "en", "translations": {"en": {"title": "[BalticOI 2016] Spiral (day1)", "background": "", "description": "A grid of size $(2n+1)\\times(2n+1)$ has been constructed as follows. Number $1$ has been placed in the center square, number $2$ has been placed to the right of it, and the following numbers have been placed along the spiral counterclockwise.\n\nYour task is to calculate answers for $q$ queries where the sum of numbers in an rectangular region in the grid is requested (modulo $10^9+7$). For example, in the following grid $n=2$ and the sum of numbers in the gray region is $74$ :\n\n![](https://cdn.luogu.com.cn/upload/pic/20871.png)", "inputFormat": "The first input line contains two integers $n$ and $q$ : the size of the grid and the number of queries.\n\nAfter this, there are $q$ lines, each containing four integers $x_1, y_1, x_2$  and $y_2$ ($-n\\leq x_1\\leq x_2\\leq n, -n\\leq y_1\\leq y_2\\leq n$). This means that you should calculate the sum of numbers in a rectangular region with corners $(x_1,y_1)$ and $(x_2,y_2)$.", "outputFormat": "You should output the answer for each query (modulo $10^9+7$).\n", "hint": "## Subtasks\n\nIn all subtasks $1\\leq q\\leq100$.\n\n### Subtask 1 (12 points)\n\n- $1\\leq n\\leq1000$\n\n### Subtask 2 (15 points)\n\n- $1\\leq n\\leq10^9$\n\n- $x_1=x_2$ and $y_1=y_2$\n\n### Subtask 3 (17 points)\n\n- $1\\leq n\\leq10^5$\n\n### Subtask 4 (31 points)\n\n- $1\\leq n\\leq10^9$\n\n- $x_1=y_1=1$\n\n### Subtask 5 (25 points)\n\n- $1\\leq n\\leq10^9$\n", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2016] Spiral (day1)", "background": null, "description": "[BalticOI 2016 Day1]螺旋\n\n\n一个矩阵的大小为 $(2n+1)\\times (2n+1)$，我们们通过下述方法填数：数字 $1$ 在中心，数字 $2$ 在其右，其他数字依次按照逆时针螺旋摆放。\n\n你的任务是对于 $q$ 个询问，计算出一个给定子矩阵所有数字的和对 $(10^9+7)$ 取余的结果。比如以下 $n=2$ 的矩阵，灰色区域的数字之和为 $74$：\n\n![](https://i.loli.net/2018/08/11/5b6e3ead24175.png)", "inputFormat": "第一行，两个整数 $n$ 和 $q$，分别表示矩阵的大小和询问的个数。\n\n接下来 $q$ 行，每行四个整数 $x_1,y_1,x_2$ 和 $y_2$ $(-n \\leq x_1 \\leq x_2 \\leq n,$ $-n \\leq y_1 \\leq y_2 \\leq n)$。这表示你需要计算一个对角为 $(x_1,y_1)$ 和 $(x_2,y_2)$ 的子矩阵的数字之和。", "outputFormat": "对于每个询问，输出一行表示答案（对 $10^9+7$ 取余）。\n\n由 @I_love_him52 提供翻译", "hint": "#### Subtask 1 (12 points)\n\n- $1 \\leq n \\leq 1000$\n\n#### Subtask 2 (15 points)\n\n- $1 \\leq n \\leq 10^9$\n\n- $x_1 = x_2$ and $y_1 = y_2$\n\n#### Subtask 3 (17 points)\n\n- $1 \\leq n \\leq 10^5$\n\n#### Subtask 4 (31 points)\n\n- $1 \\leq n \\leq 10^9$\n\n- $x_1 = y_1 = 1$\n\n#### Subtask 5 (25 points)\n\n- $1 \\leq n \\leq 10^9$\n\n对于 $100 \\%$ 数据，$1 \\leq q \\leq 100$，$1 \\leq n \\leq 10^9$，$-n \\leq x_1 \\leq x_2 \\leq n$，$-n \\leq y_1 \\leq y_2 \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P4677", "type": "P", "difficulty": 4, "samples": [["10 2\n3 1 3 1 1 1 1 1 3", "18"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "前缀和"], "title": "山区建小学", "background": "", "description": "政府在某山区修建了一条道路，恰好穿越总共 $n$ 个村庄的每个村庄一次，没有回路或交叉，任意两个村庄只能通过这条路来往。已知任意两个相邻的村庄之间的距离为 $d_i$（$d_i$ 为正整数），其中，$0<i<n$。为了提高山区的文化素质，政府又决定从 $n$ 个村中选择 $m$ 个村建小学。请根据给定的 $n$、$m$ 以及所有相邻村庄的距离，选择在哪些村庄建小学，才使得所有村到最近小学的距离总和最小，计算最小值。", "inputFormat": "第一行为 $n$ 和 $m$，其间用空格间隔。\n\n第二行为 $n-1$ 个整数，依次表示从一端到另一端的相邻村庄的距离，整数之间以空格间隔。\n\n例如\n\n```\n10 3\n2 4 6 5 2 4 3 1 3\n```\n\n表示在 $10$ 个村庄中建 $3$ 所学校。第 $1$ 个村庄与第 $2$ 个村庄距离为 $2$，第 $2$ 个村庄与第 $3$ 个村庄距离为 $4$，第 $3$ 个村庄与第 $4$ 个村庄距离为 $6$，...，第 $9$ 个村庄到第 $10$ 个村庄的距离为 $3$。", "outputFormat": "各村庄到最近学校的距离之和的最小值。", "hint": "$1 \\le m \\le n < 500$，$1 \\le d_i \\le 100$。", "locale": "zh-CN", "translations": {"en": {"title": "Building Primary Schools in Mountainous Areas", "background": "", "description": "The government has built a single road in a mountainous area that passes through each of the $n$ villages exactly once, with no cycles or intersections. Any two villages can communicate only along this road. The distance between any two adjacent villages is $d_i$ (each $d_i$ is a positive integer), where $1 \\le i < n$. To improve education in the area, the government will choose $m$ out of the $n$ villages to build primary schools. Given $n$, $m$, and the distances between all adjacent villages, decide in which villages to build the primary schools so that the sum of distances from all villages to their nearest primary school is minimized, and compute this minimum value.", "inputFormat": "The first line contains $n$ and $m$, separated by a space.\nThe second line contains $n-1$ integers, in order from one end to the other, representing the distances between adjacent villages, separated by spaces.\n\nFor example\n\n```\n10 3\n2 4 6 5 2 4 3 1 3\n```\n\nmeans building $3$ primary schools among $10$ villages. The distance between village $1$ and village $2$ is $2$, between village $2$ and village $3$ is $4$, between village $3$ and village $4$ is $6$, ..., and between village $9$ and village $10$ is $3$.", "outputFormat": "Output the minimal sum of distances from all villages to their nearest primary school.", "hint": "$1 \\le m \\le n < 500$, $1 \\le d_i \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "山区建小学", "background": "", "description": "政府在某山区修建了一条道路，恰好穿越总共 $n$ 个村庄的每个村庄一次，没有回路或交叉，任意两个村庄只能通过这条路来往。已知任意两个相邻的村庄之间的距离为 $d_i$（$d_i$ 为正整数），其中，$0<i<n$。为了提高山区的文化素质，政府又决定从 $n$ 个村中选择 $m$ 个村建小学。请根据给定的 $n$、$m$ 以及所有相邻村庄的距离，选择在哪些村庄建小学，才使得所有村到最近小学的距离总和最小，计算最小值。", "inputFormat": "第一行为 $n$ 和 $m$，其间用空格间隔。\n\n第二行为 $n-1$ 个整数，依次表示从一端到另一端的相邻村庄的距离，整数之间以空格间隔。\n\n例如\n\n```\n10 3\n2 4 6 5 2 4 3 1 3\n```\n\n表示在 $10$ 个村庄中建 $3$ 所学校。第 $1$ 个村庄与第 $2$ 个村庄距离为 $2$，第 $2$ 个村庄与第 $3$ 个村庄距离为 $4$，第 $3$ 个村庄与第 $4$ 个村庄距离为 $6$，...，第 $9$ 个村庄到第 $10$ 个村庄的距离为 $3$。", "outputFormat": "各村庄到最近学校的距离之和的最小值。", "hint": "$1 \\le m \\le n < 500$，$1 \\le d_i \\le 100$。", "locale": "zh-CN"}}}
{"pid": "P4678", "type": "P", "difficulty": 5, "samples": [["4\n2 2\n2 1\n2 0\n1 1", "10\n10\n9\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "2018", "离散化", "福建", "排列组合", "前缀和"], "title": "[FJWC2018] 全排列", "background": "", "description": "定义两个长为 $n$ 的排列 $A$ 与 $B$ 相似：若 $\\forall i$，满足 $C(A, A_i) = C(B, B_i)$。其中 $C(P, x)$ 为满足 $P_j < x$ $(1 \\leqslant j \\leqslant n)$ 的 $j$ 的数目。\n\n对于两个长为 $n$ 的排列 $P_1, P_2$，定义函数 $F(P_1, P_2)$ 等于满足 $P_1[l \\ldots r]$ 相似于 $P_2[l \\ldots r]$ $(1 \\leqslant l \\leqslant r \\leqslant n)$ 并且 $P_1[l \\ldots r]$ 包含不超过 $E$ 个逆序对的数对 $(l, r)$ 的数目。\n\n现在请你求出：对 $P_1, P_2$ 分别取遍所有 $1 \\sim n$ 的排列后所有 $F(P_1, P_2)$ 的和。", "inputFormat": "第一行一个整数 $T$ 表示数据组数。\n\n接下来 $T$ 行，每行包含两个非负整数 $n, E$。", "outputFormat": "对于每组数据，输出一行一个整数表示答案模 $10^9 + 7$。", "hint": "对于 $50\\%$ 的数据，$T \\leqslant 10^4, n \\leqslant 10, E \\leqslant 50$。\n\n对于 $80\\%$ 的数据，$T \\leqslant 10^4, n \\leqslant 50, E \\leqslant 10^6$。\n\n对于 $100\\%$ 的数据，$T \\leqslant 10^4, n \\leqslant 500, E \\leqslant 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[FJWC2018] Full Permutation", "background": "", "description": "Define two permutations $A$ and $B$ of length $n$ to be similar if, for all $i$, $C(A, A_i) = C(B, B_i)$ holds. Here, $C(P, x)$ is the number of indices $j$ such that $P_j < x$ $(1 \\leqslant j \\leqslant n)$.\n\nFor two permutations $P_1, P_2$ of length $n$, define the function $F(P_1, P_2)$ as the number of pairs $(l, r)$ such that $P_1[l \\ldots r]$ is similar to $P_2[l \\ldots r]$ $(1 \\leqslant l \\leqslant r \\leqslant n)$, and $P_1[l \\ldots r]$ contains no more than $E$ inversion pairs.\n\nNow you need to compute: after letting $P_1$ and $P_2$ range over all permutations of $1 \\sim n$, the sum of all $F(P_1, P_2)$.", "inputFormat": "The first line contains an integer $T$, which denotes the number of test cases.\n\nThe next $T$ lines each contain two non-negative integers $n, E$.", "outputFormat": "For each test case, output one integer per line, which is the answer modulo $10^9 + 7$.", "hint": "For $50\\%$ of the testdata, $T \\leqslant 10^4, n \\leqslant 10, E \\leqslant 50$.\n\nFor $80\\%$ of the testdata, $T \\leqslant 10^4, n \\leqslant 50, E \\leqslant 10^6$.\n\nFor $100\\%$ of the testdata, $T \\leqslant 10^4, n \\leqslant 500, E \\leqslant 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[FJWC2018] 全排列", "background": "", "description": "定义两个长为 $n$ 的排列 $A$ 与 $B$ 相似：若 $\\forall i$，满足 $C(A, A_i) = C(B, B_i)$。其中 $C(P, x)$ 为满足 $P_j < x$ $(1 \\leqslant j \\leqslant n)$ 的 $j$ 的数目。\n\n对于两个长为 $n$ 的排列 $P_1, P_2$，定义函数 $F(P_1, P_2)$ 等于满足 $P_1[l \\ldots r]$ 相似于 $P_2[l \\ldots r]$ $(1 \\leqslant l \\leqslant r \\leqslant n)$ 并且 $P_1[l \\ldots r]$ 包含不超过 $E$ 个逆序对的数对 $(l, r)$ 的数目。\n\n现在请你求出：对 $P_1, P_2$ 分别取遍所有 $1 \\sim n$ 的排列后所有 $F(P_1, P_2)$ 的和。", "inputFormat": "第一行一个整数 $T$ 表示数据组数。\n\n接下来 $T$ 行，每行包含两个非负整数 $n, E$。", "outputFormat": "对于每组数据，输出一行一个整数表示答案模 $10^9 + 7$。", "hint": "对于 $50\\%$ 的数据，$T \\leqslant 10^4, n \\leqslant 10, E \\leqslant 50$。\n\n对于 $80\\%$ 的数据，$T \\leqslant 10^4, n \\leqslant 50, E \\leqslant 10^6$。\n\n对于 $100\\%$ 的数据，$T \\leqslant 10^4, n \\leqslant 500, E \\leqslant 10^6$。", "locale": "zh-CN"}}}
