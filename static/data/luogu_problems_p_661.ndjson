{"pid": "P14401", "type": "P", "difficulty": 5, "samples": [["4\n2 2\n1 4\n1 3\n3 1", "4"], ["4\n2 2\n1 6\n1 3\n3 1", "5"], ["4\n2 2\n1 3\n4 2\n3 3", "4"], ["3\n2 1\n3 1\n1 1", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "2016", "JOISC/JOIST（日本）"], "title": "[JOISC 2016] 电报 / Telegraph", "background": null, "description": "JOI 诸岛是漂浮在太平洋上的一个小型群岛国家。JOI 诸岛共有 $N$ 个岛屿，编号从 1 到 $N$。\n\n在 JOI 诸岛，岛屿之间的通信主要依靠无线电波进行。每个岛屿都配备了一台发射机和一台接收机。发射机可以向所有方向发送无线电波，但接收机只能接收来自特定方向的无线电波。因此，通过调整接收机的方向，可以改变它能接收来自哪个岛屿的无线电波。\n\n目前，岛屿 $i$（$1 \\le i \\le N$）的接收机能够接收来自岛屿 $A_i$（$A_i \\ne i$）的无线电波。此外，调整岛屿 $i$ 的接收机方向所需的成本为 $C_i$，与调整后的方向无关。\n\nJOI 诸岛正在开展一项公共服务——电报服务。当岛屿 $i$（$1 \\le i \\le N$）的无线电波能够被岛屿 $j$（$1 \\le j \\le N, j \\ne i$）的接收机接收时，岛屿 $i$ 可以通过无线电通信向岛屿 $j$ 发送电报。此外，电报可以通过若干岛屿中转发送。也就是说，当岛屿 $i$、岛屿 $j$、岛屿 $k$（$1 \\le i, j, k \\le N$，且 $i, j, k$ 互不相同）之间满足：岛屿 $i$ 可向岛屿 $j$ 发送电报，岛屿 $j$ 可向岛屿 $k$ 发送电报时，岛屿 $i$ 也可向岛屿 $k$ 发送电报。不允许使用无线电通信以外的方式发送电报。\n\n作为 JOI 诸岛的通信大臣，你希望实现从任意岛屿向任意其他岛屿发送电报的目标。为此，可能需要调整若干岛屿接收机的方向。调整若干岛屿接收机方向所需的总成本，是各岛屿调整接收机方向所需成本的总和。\n\n请计算为了实现从任意岛屿向任意其他岛屿发送电报的目标所需的最小成本。\n\n**题目**\n\n给定 JOI 诸岛的岛屿数量，以及每个岛屿接收机的相关信息，编写程序求出为了实现从任意岛屿向任意其他岛屿发送电报的目标所需的最小成本。", "inputFormat": "从标准输入读取以下数据：\n\n- 第 1 行包含一个整数 $N$。这表示 JOI 诸岛共有 $N$ 个岛屿。\n- 接下来的 $N$ 行中，第 $i$ 行（$1 \\le i \\le N$）包含两个整数 $A_i$ 和 $C_i$，以空格分隔。这表示岛屿 $i$ 的接收机当前可以接收来自岛屿 $A_i$ 的无线电波，且调整其方向所需的成本为 $C_i$。", "outputFormat": "在标准输出中，输出一行，表示为了实现从任意岛屿向任意其他岛屿发送电报所需的最小成本。", "hint": "### 样例解释\n\n对于样例 1，将岛屿 2 的接收机方向调整为可接收来自岛屿 4 的无线电波。此时，即可实现从任意岛屿向任意其他岛屿发送电报，所需成本为 4。无论怎样调整接收机方向，成本都不可能低于 4，因此输出 4。\n\n对于样例 2，首先，将岛屿 1 的接收机方向调整为可接收来自岛屿 4 的无线电波；接着，将岛屿 3 的接收机方向调整为可接收来自岛屿 2 的无线电波。此时，即可实现从任意岛屿向任意其他岛屿发送电报，所需成本为 $2 + 3 = 5$。无论怎样调整接收机方向，成本都不可能低于 5，因此输出 5。\n\n对于样例 3，只需调整岛屿 1 和岛屿 3 的接收机方向即可。\n\n对于样例 4，无需调整任何岛屿的接收机方向。\n\n### 限制\n\n所有输入数据均满足以下条件：\n\n- $2 \\le N \\le 10^5$。\n- $1 \\le A_i \\le N$（$1 \\le i \\le N$）。\n- $A_i \\ne i$（$1 \\le i \\le N$）。\n- $1 \\le C_i \\le 10^9$（$1 \\le i \\le N$）。\n\n### 子任务\n\n**子任务 1 [10 分]**\n\n- 满足 $N \\le 10$。\n\n**子任务 2 [30 分]**\n\n- 满足 $N \\le 15$。\n\n**子任务 3 [30 分]**\n\n- 满足 $N \\le 3000$。\n\n**子任务 4 [30 分]**\n\n无额外限制。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2016] 电报 / Telegraph", "background": null, "description": "JOI 诸岛是漂浮在太平洋上的一个小型群岛国家。JOI 诸岛共有 $N$ 个岛屿，编号从 1 到 $N$。\n\n在 JOI 诸岛，岛屿之间的通信主要依靠无线电波进行。每个岛屿都配备了一台发射机和一台接收机。发射机可以向所有方向发送无线电波，但接收机只能接收来自特定方向的无线电波。因此，通过调整接收机的方向，可以改变它能接收来自哪个岛屿的无线电波。\n\n目前，岛屿 $i$（$1 \\le i \\le N$）的接收机能够接收来自岛屿 $A_i$（$A_i \\ne i$）的无线电波。此外，调整岛屿 $i$ 的接收机方向所需的成本为 $C_i$，与调整后的方向无关。\n\nJOI 诸岛正在开展一项公共服务——电报服务。当岛屿 $i$（$1 \\le i \\le N$）的无线电波能够被岛屿 $j$（$1 \\le j \\le N, j \\ne i$）的接收机接收时，岛屿 $i$ 可以通过无线电通信向岛屿 $j$ 发送电报。此外，电报可以通过若干岛屿中转发送。也就是说，当岛屿 $i$、岛屿 $j$、岛屿 $k$（$1 \\le i, j, k \\le N$，且 $i, j, k$ 互不相同）之间满足：岛屿 $i$ 可向岛屿 $j$ 发送电报，岛屿 $j$ 可向岛屿 $k$ 发送电报时，岛屿 $i$ 也可向岛屿 $k$ 发送电报。不允许使用无线电通信以外的方式发送电报。\n\n作为 JOI 诸岛的通信大臣，你希望实现从任意岛屿向任意其他岛屿发送电报的目标。为此，可能需要调整若干岛屿接收机的方向。调整若干岛屿接收机方向所需的总成本，是各岛屿调整接收机方向所需成本的总和。\n\n请计算为了实现从任意岛屿向任意其他岛屿发送电报的目标所需的最小成本。\n\n**题目**\n\n给定 JOI 诸岛的岛屿数量，以及每个岛屿接收机的相关信息，编写程序求出为了实现从任意岛屿向任意其他岛屿发送电报的目标所需的最小成本。", "inputFormat": "从标准输入读取以下数据：\n\n- 第 1 行包含一个整数 $N$。这表示 JOI 诸岛共有 $N$ 个岛屿。\n- 接下来的 $N$ 行中，第 $i$ 行（$1 \\le i \\le N$）包含两个整数 $A_i$ 和 $C_i$，以空格分隔。这表示岛屿 $i$ 的接收机当前可以接收来自岛屿 $A_i$ 的无线电波，且调整其方向所需的成本为 $C_i$。", "outputFormat": "在标准输出中，输出一行，表示为了实现从任意岛屿向任意其他岛屿发送电报所需的最小成本。", "hint": "### 样例解释\n\n对于样例 1，将岛屿 2 的接收机方向调整为可接收来自岛屿 4 的无线电波。此时，即可实现从任意岛屿向任意其他岛屿发送电报，所需成本为 4。无论怎样调整接收机方向，成本都不可能低于 4，因此输出 4。\n\n对于样例 2，首先，将岛屿 1 的接收机方向调整为可接收来自岛屿 4 的无线电波；接着，将岛屿 3 的接收机方向调整为可接收来自岛屿 2 的无线电波。此时，即可实现从任意岛屿向任意其他岛屿发送电报，所需成本为 $2 + 3 = 5$。无论怎样调整接收机方向，成本都不可能低于 5，因此输出 5。\n\n对于样例 3，只需调整岛屿 1 和岛屿 3 的接收机方向即可。\n\n对于样例 4，无需调整任何岛屿的接收机方向。\n\n### 限制\n\n所有输入数据均满足以下条件：\n\n- $2 \\le N \\le 10^5$。\n- $1 \\le A_i \\le N$（$1 \\le i \\le N$）。\n- $A_i \\ne i$（$1 \\le i \\le N$）。\n- $1 \\le C_i \\le 10^9$（$1 \\le i \\le N$）。\n\n### 子任务\n\n**子任务 1 [10 分]**\n\n- 满足 $N \\le 10$。\n\n**子任务 2 [30 分]**\n\n- 满足 $N \\le 15$。\n\n**子任务 3 [30 分]**\n\n- 满足 $N \\le 3000$。\n\n**子任务 4 [30 分]**\n\n无额外限制。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN"}}}
{"pid": "P14402", "type": "P", "difficulty": 6, "samples": [["5 5\n#####\n#...#\n#...#\n#...#\n#####\n2 2\n3 3", "4"], ["8 6\n######\n#..#.#\n##...#\n#....#\n#.#..#\n#....#\n##...#\n######\n4 3\n6 4", "5"], ["5 5\n#####\n#.#.#\n#.#.#\n#.#.#\n#####\n2 2\n4 4", "-1"], ["3 3\n###\n#.#\n###\n2 2\n2 2", "0"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["图论", "贪心", "2016", "图论建模", "最短路", "JOISC/JOIST（日本）"], "title": "[JOISC 2016] 危险的滑冰 / Dangerous Skating", "background": null, "description": "JOI 君喜欢在大自然中广阔的溜冰场上滑冰。\n\n溜冰场是一个南北方向有 $R$ 行、东西方向有 $C$ 列的长方形网格。我们用 $(r, c)$ 表示第 $r$ 行、第 $c$ 列的格子。每个格子要么是 JOI 君可以通行的，要么是布满冰块、无法通行的。此外，溜冰场外围的所有格子都布满冰块，JOI 君无法滑出溜冰场外。也就是说，格子 $(i, 1)$、$(i, C)$（$1 \\le i \\le R$）以及格子 $(1, j)$、$(R, j)$（$1 \\le j \\le C$）上均有冰块。\n\nJOI 君并不擅长滑冰。当他滑行时，只能朝东、西、南、北四个方向中的一个方向滑行，从当前所在的格子出发，一直滑到前方遇到冰块为止才停下。从滑行开始到停下为止算作一次移动。若相邻格子上有冰块，则不能朝该方向移动。\n\n某日，JOI 君正在滑冰，突然发现：每当他完成一次移动，移动的起点会产生冰块。继续在这样状态下滑冰是非常危险的，因此 JOI 君希望尽快从溜冰场中脱身。\n\nJOI 君当前位于格子 $(r_1, c_1)$。为了安全脱身，他必须在出口格子 $(r_2, c_2)$ 停下。请编写程序，计算从当前位置出发，至少需要多少次移动才能安全抵达出口格子。根据溜冰场的状态和 JOI 君的当前位置，有时他可能无论如何移动都无法抵达出口格子。请注意：即使 JOI 君在移动途中经过了出口格子，但若未在该格子停下，则不能视为成功脱身。\n\n**题目**\n\n给定溜冰场上冰块的分布、JOI 君的当前位置以及出口格子的位置，编写程序判断 JOI 君是否能从当前位置出发并最终停在出口格子上；若可以，则求出所需的最小移动次数。", "inputFormat": "从标准输入读取以下数据：\n\n- 第 1 行包含两个整数 $R$ 和 $C$，以空格分隔。这表示溜冰场南北方向有 $R$ 行，东西方向有 $C$ 列。\n- 接下来的 $R$ 行中，每行包含一个由 $C$ 个字符组成的字符串。每个字符为 '.' 或 '#' 中的一个。第 $r$ 行（$1 \\le r \\le R$）从左数第 $c$ 个字符（$1 \\le c \\le C$）表示溜冰场格子 $(r, c)$ 的初始状态：若该字符为 '.'，表示该格子可通行；若该字符为 '#'，表示该格子有冰块，不可通行。\n- 接下来一行包含两个整数 $r_1$ 和 $c_1$，以空格分隔。这表示 JOI 君的当前位置是格子 $(r_1, c_1)$。\n- 再接下来一行包含两个整数 $r_2$ 和 $c_2$，以空格分隔。这表示溜冰场的出口位于格子 $(r_2, c_2)$。", "outputFormat": "在标准输出中，输出一行整数，表示 JOI 君从当前位置出发并最终停在出口格子所需的最小移动次数。如果无论怎样移动都无法在出口格子停下，则输出 -1。", "hint": "### 样例解释\n\n在输入样例 1 中，溜冰场的初始状态如下所示。标有白色方块的格子表示冰块，标有 'J' 的格子表示 JOI 君的当前位置，标有 'E' 的格子表示出口。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/z9wyx6vz.png)\n:::\n\n首先，若 JOI 君向东移动，溜冰场的状态将变为如下：\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/91p8sc7y.png)\n:::\n\n此后，JOI 君依次向西、向南、向北移动，即可在总共 4 次移动后于出口处停下。无法在 3 次或更少的移动内抵达出口，因此应输出 4。\n\n在输入样例 4 中，JOI 君的当前位置即为出口格子，因此所需的移动次数为 0。\n\n### 数据范围\n\n所有输入数据均满足以下条件：\n\n- $3 \\le R \\le 1000$。\n- $3 \\le C \\le 1000$。\n- $1 \\le r_1 \\le R$。\n- $1 \\le c_1 \\le C$。\n- $1 \\le r_2 \\le R$。\n- $1 \\le c_2 \\le C$。\n- 溜冰场外围的所有格子均布满冰块。即，格子 $(i, 1)$、$(i, C)$（$1 \\le i \\le R$）以及格子 $(1, j)$、$(R, j)$（$1 \\le j \\le C$）上均有冰块。\n- 格子 $(r_1, c_1)$ 和格子 $(r_2, c_2)$ 上没有冰块。\n\n### 子任务\n\n**子任务 1 [13 分]**\n\n满足以下条件：\n\n- $R \\le 10$。\n- $C \\le 10$。\n- 若 JOI 君能从当前位置出发并最终停在出口格子，则所需的移动次数不超过 10 次。\n\n**子任务 2 [65 分]**\n\n满足以下条件：\n\n- $R \\le 200$。\n- $C \\le 200$。\n\n**子任务 3 [22 分]**\n\n无额外限制。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2016] 危险的滑冰 / Dangerous Skating", "background": null, "description": "JOI 君喜欢在大自然中广阔的溜冰场上滑冰。\n\n溜冰场是一个南北方向有 $R$ 行、东西方向有 $C$ 列的长方形网格。我们用 $(r, c)$ 表示第 $r$ 行、第 $c$ 列的格子。每个格子要么是 JOI 君可以通行的，要么是布满冰块、无法通行的。此外，溜冰场外围的所有格子都布满冰块，JOI 君无法滑出溜冰场外。也就是说，格子 $(i, 1)$、$(i, C)$（$1 \\le i \\le R$）以及格子 $(1, j)$、$(R, j)$（$1 \\le j \\le C$）上均有冰块。\n\nJOI 君并不擅长滑冰。当他滑行时，只能朝东、西、南、北四个方向中的一个方向滑行，从当前所在的格子出发，一直滑到前方遇到冰块为止才停下。从滑行开始到停下为止算作一次移动。若相邻格子上有冰块，则不能朝该方向移动。\n\n某日，JOI 君正在滑冰，突然发现：每当他完成一次移动，移动的起点会产生冰块。继续在这样状态下滑冰是非常危险的，因此 JOI 君希望尽快从溜冰场中脱身。\n\nJOI 君当前位于格子 $(r_1, c_1)$。为了安全脱身，他必须在出口格子 $(r_2, c_2)$ 停下。请编写程序，计算从当前位置出发，至少需要多少次移动才能安全抵达出口格子。根据溜冰场的状态和 JOI 君的当前位置，有时他可能无论如何移动都无法抵达出口格子。请注意：即使 JOI 君在移动途中经过了出口格子，但若未在该格子停下，则不能视为成功脱身。\n\n**题目**\n\n给定溜冰场上冰块的分布、JOI 君的当前位置以及出口格子的位置，编写程序判断 JOI 君是否能从当前位置出发并最终停在出口格子上；若可以，则求出所需的最小移动次数。", "inputFormat": "从标准输入读取以下数据：\n\n- 第 1 行包含两个整数 $R$ 和 $C$，以空格分隔。这表示溜冰场南北方向有 $R$ 行，东西方向有 $C$ 列。\n- 接下来的 $R$ 行中，每行包含一个由 $C$ 个字符组成的字符串。每个字符为 '.' 或 '#' 中的一个。第 $r$ 行（$1 \\le r \\le R$）从左数第 $c$ 个字符（$1 \\le c \\le C$）表示溜冰场格子 $(r, c)$ 的初始状态：若该字符为 '.'，表示该格子可通行；若该字符为 '#'，表示该格子有冰块，不可通行。\n- 接下来一行包含两个整数 $r_1$ 和 $c_1$，以空格分隔。这表示 JOI 君的当前位置是格子 $(r_1, c_1)$。\n- 再接下来一行包含两个整数 $r_2$ 和 $c_2$，以空格分隔。这表示溜冰场的出口位于格子 $(r_2, c_2)$。", "outputFormat": "在标准输出中，输出一行整数，表示 JOI 君从当前位置出发并最终停在出口格子所需的最小移动次数。如果无论怎样移动都无法在出口格子停下，则输出 -1。", "hint": "### 样例解释\n\n在输入样例 1 中，溜冰场的初始状态如下所示。标有白色方块的格子表示冰块，标有 'J' 的格子表示 JOI 君的当前位置，标有 'E' 的格子表示出口。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/z9wyx6vz.png)\n:::\n\n首先，若 JOI 君向东移动，溜冰场的状态将变为如下：\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/91p8sc7y.png)\n:::\n\n此后，JOI 君依次向西、向南、向北移动，即可在总共 4 次移动后于出口处停下。无法在 3 次或更少的移动内抵达出口，因此应输出 4。\n\n在输入样例 4 中，JOI 君的当前位置即为出口格子，因此所需的移动次数为 0。\n\n### 数据范围\n\n所有输入数据均满足以下条件：\n\n- $3 \\le R \\le 1000$。\n- $3 \\le C \\le 1000$。\n- $1 \\le r_1 \\le R$。\n- $1 \\le c_1 \\le C$。\n- $1 \\le r_2 \\le R$。\n- $1 \\le c_2 \\le C$。\n- 溜冰场外围的所有格子均布满冰块。即，格子 $(i, 1)$、$(i, C)$（$1 \\le i \\le R$）以及格子 $(1, j)$、$(R, j)$（$1 \\le j \\le C$）上均有冰块。\n- 格子 $(r_1, c_1)$ 和格子 $(r_2, c_2)$ 上没有冰块。\n\n### 子任务\n\n**子任务 1 [13 分]**\n\n满足以下条件：\n\n- $R \\le 10$。\n- $C \\le 10$。\n- 若 JOI 君能从当前位置出发并最终停在出口格子，则所需的移动次数不超过 10 次。\n\n**子任务 2 [65 分]**\n\n满足以下条件：\n\n- $R \\le 200$。\n- $C \\le 200$。\n\n**子任务 3 [22 分]**\n\n无额外限制。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN"}}}
{"pid": "P14404", "type": "P", "difficulty": 6, "samples": [[" 3\n 3 500\n 2 200\n 1 100\n 1 1000\n 3 700\n 3 400", " 1"], [" 3\n 3 3\n 3 2\n 1 1\n 3 4\n 3 2\n 1 1", "0"], [" 6\n 1 70\n 4 50\n 1 30\n 2 20\n 1 10\n 3 0\n 6 100\n 2 90\n 1 80\n 2 60\n 4 40\n 1 10", "3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "2016", "线段树", "二分图", "JOISC/JOIST（日本）"], "title": "[JOISC 2016] 最差的记者 2 / Worst Reporter 2", "background": "", "description": "当时是 21XX 年，竞技编程已被广泛认可为一项脑力运动，常在电视、新闻等媒体中被报道。\n\n你是一名 JOI 新闻社的记者，负责撰写关于竞技编程的报道。\n\n昨天，一场由 $N$ 名选手参加的国际性竞技编程比赛已成功举办。关于这场比赛，你获得了以下信息：\n\n- 与国际信息学奥林匹克等赛事类似，本次比赛有若干国家的选手参与。每个国家被分配一个从 $1$ 到 $N$ 的编号，一个国家可能派出多名选手参赛，也可能没有选手参赛。\n- 本次比赛的竞赛时长为 5 小时。\n- 比赛过程中，选手获得的分数不会被减少。\n- 比赛开始 2 小时后，不存在同分的选手。此时的排名表中，第 $i$ 位（$1 \\le i \\le N$）的选手来自国家 $A_i$，其得分为 $B_i$。\n- 比赛结束时，同样不存在同分的选手。比赛结束时的排名表中，第 $i$ 位（$1 \\le i \\le N$）的选手来自国家 $C_i$，其得分为 $D_i$。\n\n然而，在撰写报道的过程中，你发现排名表中的选手出身国信息存在不一致。选手的出身国信息可能在比赛中被错误地表示了，但选手的得分是正确的。\n\n因此，你决定通过尽可能少的修正，推测出与排名表信息不矛盾的情况（例如，同一选手的出身国在比赛中发生了变化，或选手的得分在比赛中被错误减少等）。换句话说，你希望通过修改 $2N$ 个值 $A_1, \\dots, A_N, C_1, \\dots, C_N$ 中尽可能少的位置，使得以下条件成立：\n\n- 存在一个 $1, 2, \\dots, N$ 的排列 $x_1, x_2, \\dots, x_N$，使得对每个 $i = 1, 2, \\dots, N$，均有 $A_i = C_{x_i}$ 且 $B_i \\le D_{x_i}$。\n\n你被要求，根据所给信息，计算至少需要修改多少个位置。\n\n**题目**\n\n给定参赛选手数量、比赛开始 2 小时后的排名表与比赛结束时的排名表信息，编写一个程序，求出使排名表信息无矛盾所需的最少出身国信息修改位置数。", "inputFormat": "从标准输入读取以下数据：\n\n- 第 1 行包含一个整数 $N$，表示共有 $N$ 名选手参加了比赛。\n- 接下来的 $N$ 行中，第 $i$ 行（$1 \\le i \\le N$）包含两个以空格分隔的整数 $A_i$ 和 $B_i$，表示在比赛开始 2 小时后的排名表中，第 $i$ 位选手被标注为来自国家 $A_i$，其得分为 $B_i$。\n- 再接下来的 $N$ 行中，第 $i$ 行（$1 \\le i \\le N$）包含两个以空格分隔的整数 $C_i$ 和 $D_i$，表示在比赛结束时的排名表中，第 $i$ 位选手被标注为来自国家 $C_i$，其得分为 $D_i$。\n", "outputFormat": "向标准输出输出一行，包含一个整数，表示为使排名表无矛盾所需的最少出身国信息修改位置数。\n", "hint": "### 数据范围\n\n所有输入数据均满足以下条件：\n\n- $2 \\le N \\le 200\\,000$。\n- $1 \\le A_i \\le N$（$1 \\le i \\le N$）。\n- $0 \\le B_i \\le 1\\,000\\,000\\,000$（$1 \\le i \\le N$）。\n- $B_i > B_{i+1}$（$1 \\le i \\le N - 1$）。\n- $1 \\le C_i \\le N$（$1 \\le i \\le N$）。\n- $0 \\le D_i \\le 1\\,000\\,000\\,000$（$1 \\le i \\le N$）。\n- $D_i > D_{i+1}$（$1 \\le i \\le N - 1$）。\n- 通过修改 $A_1, \\dots, A_N, C_1, \\dots, C_N$ 中的若干位置，可以使排名表达到无矛盾状态。\n\n### 子任务\n\n**子任务 1 [15 分]**\n\n- 满足 $N \\le 16$。\n\n**子任务 2 [15 分]**\n\n- 满足 $N \\le 50$。\n\n**子任务 3 [30 分]**\n\n- 满足 $N \\le 5000$。\n\n**子任务 4 [40 分]**\n\n无额外限制。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2016] 最差的记者 2 / Worst Reporter 2", "background": "", "description": "当时是 21XX 年，竞技编程已被广泛认可为一项脑力运动，常在电视、新闻等媒体中被报道。\n\n你是一名 JOI 新闻社的记者，负责撰写关于竞技编程的报道。\n\n昨天，一场由 $N$ 名选手参加的国际性竞技编程比赛已成功举办。关于这场比赛，你获得了以下信息：\n\n- 与国际信息学奥林匹克等赛事类似，本次比赛有若干国家的选手参与。每个国家被分配一个从 $1$ 到 $N$ 的编号，一个国家可能派出多名选手参赛，也可能没有选手参赛。\n- 本次比赛的竞赛时长为 5 小时。\n- 比赛过程中，选手获得的分数不会被减少。\n- 比赛开始 2 小时后，不存在同分的选手。此时的排名表中，第 $i$ 位（$1 \\le i \\le N$）的选手来自国家 $A_i$，其得分为 $B_i$。\n- 比赛结束时，同样不存在同分的选手。比赛结束时的排名表中，第 $i$ 位（$1 \\le i \\le N$）的选手来自国家 $C_i$，其得分为 $D_i$。\n\n然而，在撰写报道的过程中，你发现排名表中的选手出身国信息存在不一致。选手的出身国信息可能在比赛中被错误地表示了，但选手的得分是正确的。\n\n因此，你决定通过尽可能少的修正，推测出与排名表信息不矛盾的情况（例如，同一选手的出身国在比赛中发生了变化，或选手的得分在比赛中被错误减少等）。换句话说，你希望通过修改 $2N$ 个值 $A_1, \\dots, A_N, C_1, \\dots, C_N$ 中尽可能少的位置，使得以下条件成立：\n\n- 存在一个 $1, 2, \\dots, N$ 的排列 $x_1, x_2, \\dots, x_N$，使得对每个 $i = 1, 2, \\dots, N$，均有 $A_i = C_{x_i}$ 且 $B_i \\le D_{x_i}$。\n\n你被要求，根据所给信息，计算至少需要修改多少个位置。\n\n**题目**\n\n给定参赛选手数量、比赛开始 2 小时后的排名表与比赛结束时的排名表信息，编写一个程序，求出使排名表信息无矛盾所需的最少出身国信息修改位置数。", "inputFormat": "从标准输入读取以下数据：\n\n- 第 1 行包含一个整数 $N$，表示共有 $N$ 名选手参加了比赛。\n- 接下来的 $N$ 行中，第 $i$ 行（$1 \\le i \\le N$）包含两个以空格分隔的整数 $A_i$ 和 $B_i$，表示在比赛开始 2 小时后的排名表中，第 $i$ 位选手被标注为来自国家 $A_i$，其得分为 $B_i$。\n- 再接下来的 $N$ 行中，第 $i$ 行（$1 \\le i \\le N$）包含两个以空格分隔的整数 $C_i$ 和 $D_i$，表示在比赛结束时的排名表中，第 $i$ 位选手被标注为来自国家 $C_i$，其得分为 $D_i$。\n", "outputFormat": "向标准输出输出一行，包含一个整数，表示为使排名表无矛盾所需的最少出身国信息修改位置数。\n", "hint": "### 数据范围\n\n所有输入数据均满足以下条件：\n\n- $2 \\le N \\le 200\\,000$。\n- $1 \\le A_i \\le N$（$1 \\le i \\le N$）。\n- $0 \\le B_i \\le 1\\,000\\,000\\,000$（$1 \\le i \\le N$）。\n- $B_i > B_{i+1}$（$1 \\le i \\le N - 1$）。\n- $1 \\le C_i \\le N$（$1 \\le i \\le N$）。\n- $0 \\le D_i \\le 1\\,000\\,000\\,000$（$1 \\le i \\le N$）。\n- $D_i > D_{i+1}$（$1 \\le i \\le N - 1$）。\n- 通过修改 $A_1, \\dots, A_N, C_1, \\dots, C_N$ 中的若干位置，可以使排名表达到无矛盾状态。\n\n### 子任务\n\n**子任务 1 [15 分]**\n\n- 满足 $N \\le 16$。\n\n**子任务 2 [15 分]**\n\n- 满足 $N \\le 50$。\n\n**子任务 3 [30 分]**\n\n- 满足 $N \\le 5000$。\n\n**子任务 4 [40 分]**\n\n无额外限制。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN"}}}
{"pid": "P14405", "type": "P", "difficulty": 4, "samples": [["2 18\ncopypaste\n4\n3 6 8\n1 5 2\n4 12 1\n17 18 0", "ac"], ["6 100\njjooii\n3\n5 6 2\n4 6 1\n1 2 3", "joioji"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2015", "JOISC/JOIST（日本）"], "title": "[JOISC 2015] 复制粘贴 2 / Copy and Paste 2", "background": "", "description": "文本编辑器最重要的功能之一是复制与粘贴（复写・贴付）。JOI 公司正在开发一种能极高速处理复制与粘贴操作的文本编辑器。作为 JOI 公司的优秀程序员，你被委以核心复制与粘贴处理模块的测试任务。由于 JOI 公司的命运悬系于此，你必须编写一个精确且高速的程序。\n\n具体任务如下：初始时，文件内容为字符串 $ S $。随后，将执行 $ N $ 次复制与粘贴操作。第 $ i $ 次操作的含义是：从位置 $ A_i $ 到位置 $ B_i $ 的子串被复制，并将复制得到的子串插入到原字符串的位置 $ C_i $ 处。这里，“位置 $ x $”指从字符串开头起第 $ x $ 个字符之后的位置（位置 0 表示字符串开头）。例如，对于字符串 `copypaste`，位置 6 表示字符 ‘a’ 与 ‘s’ 之间；位置 9 表示字符 ‘e’ 之后，即字符串末尾。但需注意，若操作后字符串长度超过 $ M $，则从字符串右端开始依次删除字符，直至长度恰好为 $ M $。\n\n你的任务是：为编辑器的测试，编写程序，预测在执行 $ N $ 次操作后，所得字符串的前 $ K $ 个字符。\n\n### 题目\n\n给定整数 $ K $、字符串长度上限 $ M $、初始字符串 $ S $、操作次数 $ N $，以及 $ N $ 次复制与粘贴操作的指令，编写程序，求出操作后字符串的前 $ K $ 个字符。", "inputFormat": "从标准输入读取以下数据：\n\n- 第 1 行：包含两个整数 $ K $、$ M $，以空格分隔。其中 $ K $ 表示需输出的字符数，$ M $ 表示字符串长度的上限。\n- 第 2 行：包含字符串 $ S $，表示初始字符串。\n- 第 3 行：包含整数 $ N $，表示操作次数。\n- 接下来的 $ N $ 行中，第 $ i $ 行（$ 1 \\le i \\le N $）包含三个整数 $ A_i $、$ B_i $、$ C_i $，以空格分隔。表示第 $ i $ 次操作是将从位置 $ A_i $ 到位置 $ B_i $ 的子串复制，并插入到位置 $ C_i $ 处。", "outputFormat": "在标准输出中，输出执行 $ N $ 次操作后所得字符串的前 $ K $ 个字符，占一行。\n", "hint": "### 样例 1 解释\n\n在这个例子中，$N = 4$ 次复制与粘贴操作按如下方式进行：\n\n- 初始字符串为 `copypaste`。\n- 第 1 次操作中，从位置 3 到位置 6 的子串 `ypa` 被复制，并在位置 8 插入粘贴，得到字符串 `copypastypae`。\n- 第 2 次操作中，从位置 1 到位置 5 的子串 `opyp` 被复制，并在位置 2 插入粘贴，得到字符串 `coopyppypastypae`。\n- 第 3 次操作中，从位置 4 到位置 12 的子串 `yppypast` 被复制，并在位置 1 插入粘贴，得到字符串 `cyppypastooypyppypastypae`，但由于长度超过 $M = 18$，因此从右端开始删除字符，最终得到字符串 `cyppypastooypyppypa`。\n- 第 4 次操作中，从位置 17 到位置 18 的子串 `a` 被复制，并在位置 0 插入粘贴，得到字符串 `acypypastooypyppypa`，但由于长度超过 $M = 18$，因此从右端开始删除字符，最终得到字符串 `acypypastooypyppyp`。\n\n因此，操作后字符串 `acypypastooypyppyp` 的前 $K = 2$ 个字符为 `ac`，输出该结果。\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $ 1 \\le K \\le 200 $。\n- $ 1 \\le M \\le 1\\,000\\,000\\,000 $。\n- 字符串 $ S $ 中的每个字符均为小写英文字母（‘a’–‘z’）。\n- $ K \\le (S \\text{ 的长度}) \\le \\min\\{M,\\ 200\\,000\\} $。\n- $ 1 \\le N \\le 200\\,000 $。\n- 设第 $ i $ 次操作前字符串的长度为 $ L_i $，则满足 $ 0 \\le A_i < B_i \\le L_i $ 且 $ 0 \\le C_i \\le L_i $（$ 1 \\le i \\le N $）。\n\n### 子任务\n\n#### 子任务 1 [10 分]\n\n满足以下条件：\n\n- $ M \\le 2\\,000 $。\n- $ N \\le 2\\,000 $。\n\n#### 子任务 2 [90 分]\n\n无额外限制。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2015] 复制粘贴 2 / Copy and Paste 2", "background": "", "description": "文本编辑器最重要的功能之一是复制与粘贴（复写・贴付）。JOI 公司正在开发一种能极高速处理复制与粘贴操作的文本编辑器。作为 JOI 公司的优秀程序员，你被委以核心复制与粘贴处理模块的测试任务。由于 JOI 公司的命运悬系于此，你必须编写一个精确且高速的程序。\n\n具体任务如下：初始时，文件内容为字符串 $ S $。随后，将执行 $ N $ 次复制与粘贴操作。第 $ i $ 次操作的含义是：从位置 $ A_i $ 到位置 $ B_i $ 的子串被复制，并将复制得到的子串插入到原字符串的位置 $ C_i $ 处。这里，“位置 $ x $”指从字符串开头起第 $ x $ 个字符之后的位置（位置 0 表示字符串开头）。例如，对于字符串 `copypaste`，位置 6 表示字符 ‘a’ 与 ‘s’ 之间；位置 9 表示字符 ‘e’ 之后，即字符串末尾。但需注意，若操作后字符串长度超过 $ M $，则从字符串右端开始依次删除字符，直至长度恰好为 $ M $。\n\n你的任务是：为编辑器的测试，编写程序，预测在执行 $ N $ 次操作后，所得字符串的前 $ K $ 个字符。\n\n### 题目\n\n给定整数 $ K $、字符串长度上限 $ M $、初始字符串 $ S $、操作次数 $ N $，以及 $ N $ 次复制与粘贴操作的指令，编写程序，求出操作后字符串的前 $ K $ 个字符。", "inputFormat": "从标准输入读取以下数据：\n\n- 第 1 行：包含两个整数 $ K $、$ M $，以空格分隔。其中 $ K $ 表示需输出的字符数，$ M $ 表示字符串长度的上限。\n- 第 2 行：包含字符串 $ S $，表示初始字符串。\n- 第 3 行：包含整数 $ N $，表示操作次数。\n- 接下来的 $ N $ 行中，第 $ i $ 行（$ 1 \\le i \\le N $）包含三个整数 $ A_i $、$ B_i $、$ C_i $，以空格分隔。表示第 $ i $ 次操作是将从位置 $ A_i $ 到位置 $ B_i $ 的子串复制，并插入到位置 $ C_i $ 处。", "outputFormat": "在标准输出中，输出执行 $ N $ 次操作后所得字符串的前 $ K $ 个字符，占一行。\n", "hint": "### 样例 1 解释\n\n在这个例子中，$N = 4$ 次复制与粘贴操作按如下方式进行：\n\n- 初始字符串为 `copypaste`。\n- 第 1 次操作中，从位置 3 到位置 6 的子串 `ypa` 被复制，并在位置 8 插入粘贴，得到字符串 `copypastypae`。\n- 第 2 次操作中，从位置 1 到位置 5 的子串 `opyp` 被复制，并在位置 2 插入粘贴，得到字符串 `coopyppypastypae`。\n- 第 3 次操作中，从位置 4 到位置 12 的子串 `yppypast` 被复制，并在位置 1 插入粘贴，得到字符串 `cyppypastooypyppypastypae`，但由于长度超过 $M = 18$，因此从右端开始删除字符，最终得到字符串 `cyppypastooypyppypa`。\n- 第 4 次操作中，从位置 17 到位置 18 的子串 `a` 被复制，并在位置 0 插入粘贴，得到字符串 `acypypastooypyppypa`，但由于长度超过 $M = 18$，因此从右端开始删除字符，最终得到字符串 `acypypastooypyppyp`。\n\n因此，操作后字符串 `acypypastooypyppyp` 的前 $K = 2$ 个字符为 `ac`，输出该结果。\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $ 1 \\le K \\le 200 $。\n- $ 1 \\le M \\le 1\\,000\\,000\\,000 $。\n- 字符串 $ S $ 中的每个字符均为小写英文字母（‘a’–‘z’）。\n- $ K \\le (S \\text{ 的长度}) \\le \\min\\{M,\\ 200\\,000\\} $。\n- $ 1 \\le N \\le 200\\,000 $。\n- 设第 $ i $ 次操作前字符串的长度为 $ L_i $，则满足 $ 0 \\le A_i < B_i \\le L_i $ 且 $ 0 \\le C_i \\le L_i $（$ 1 \\le i \\le N $）。\n\n### 子任务\n\n#### 子任务 1 [10 分]\n\n满足以下条件：\n\n- $ M \\le 2\\,000 $。\n- $ N \\le 2\\,000 $。\n\n#### 子任务 2 [90 分]\n\n无额外限制。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN"}}}
{"pid": "P14406", "type": "P", "difficulty": 3, "samples": [["1\nIJOI", "0"], ["2\nJJOIJJOJOIOJOOOI", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "递归", "前缀和", "JOISC/JOIST（日本）"], "title": "[JOISC 2015] 愉快的标志设计 / En-JOI-able Logo Design", "background": "", "description": "K 理事长计划为日本信息奥林匹克（JOI）选手设计一款支持用的周边商品的标志。某天，K 理事长想到，可以将字符 ‘J’、‘O’、‘I’ 按顺序排列组成一个环形标志。这个设计蕴含着希望 JOI 的参与者能够享受（enjoy）竞赛的寓意。\n\n以下是对整数 $k \\geq 0$ 定义的“级别 $k$ 的 JOI 序列”：\n\n- 级别 0 的 JOI 序列是由 ‘J’、‘O’、‘I’ 中任意一个字符组成的长度为 1 的字符串。\n- 级别 $k+1$ 的 JOI 序列是一个长度为 $4^{k+1}$ 的字符串，其结构如下：前 $4^k$ 个字符全部为 ‘J’，接下来的 $4^k$ 个字符全部为 ‘O’，再接下来的 $4^k$ 个字符全部为 ‘I’，最后的 $4^k$ 个字符构成一个级别 $k$ 的 JOI 序列。\n\n现在，K 理事长手中有一张纸上写有 $4^K$ 个字符，这些字符呈环形排列，每个字符是 ‘J’、‘O’、‘I’ 中的一个。K 理事长希望通过修改其中一些字符，使得从某个字符开始按顺时针方向读取整个环形字符串时，能形成一个级别 $K$ 的 JOI 序列。在此过程中，他希望修改的字符数量尽可能少。\n\n### 题目\n\n给定一个长度为 $4^K$ 的字符串，该字符串呈环形排列。编写程序，求出从某个字符开始按顺时针方向读取整个字符串时，使其变为级别 $K$ 的 JOI 序列所需的最少修改字符数。", "inputFormat": "从标准输入读取以下数据：\n\n- 第 1 行包含一个整数 $K$，表示纸上有 $4^K$ 个字符呈环形排列。\n- 第 2 行包含一个由字符 ‘J’、‘O’、‘I’ 组成的长度为 $4^K$ 的字符串，表示纸上环形排列的字符序列。\n", "outputFormat": "在标准输出中，输出 K 理事长需要修改的最少字符数，占一行。\n", "hint": "### 样例 1 解释\n\n字符形成的环如下图所示：\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/v8gbc8v5.png)\n:::\n\n以 J 为起点顺时针读取一周，形成的字符串为 JOII，这是一个级别为 1 的 JOI 列。K 理事长没必要替换字符，所以输出 0。\n\n### 样例 2 解释\n\n字符形成的环如下图所示，这里需要替换 7 个字符。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/x8gjn0hs.png)\n:::\n\n从画圈的字符开始读取这个字符环一周，得到 JJJJOOOOIIIIJOIJ 字符串，这是一个级别为 2 的 JOI 列，并且是替换次数最少的情况，因此输出 7。\n\n### 数据范围\n\n所有输入数据均满足以下条件：\n\n- $1 \\leq K \\leq 10$。\n\n### 子任务\n\n#### 子任务 1 [30 分]\n\n- $K \\leq 5$。\n\n#### 子任务 2 [70 分]\n\n无额外限制。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2015] 愉快的标志设计 / En-JOI-able Logo Design", "background": "", "description": "K 理事长计划为日本信息奥林匹克（JOI）选手设计一款支持用的周边商品的标志。某天，K 理事长想到，可以将字符 ‘J’、‘O’、‘I’ 按顺序排列组成一个环形标志。这个设计蕴含着希望 JOI 的参与者能够享受（enjoy）竞赛的寓意。\n\n以下是对整数 $k \\geq 0$ 定义的“级别 $k$ 的 JOI 序列”：\n\n- 级别 0 的 JOI 序列是由 ‘J’、‘O’、‘I’ 中任意一个字符组成的长度为 1 的字符串。\n- 级别 $k+1$ 的 JOI 序列是一个长度为 $4^{k+1}$ 的字符串，其结构如下：前 $4^k$ 个字符全部为 ‘J’，接下来的 $4^k$ 个字符全部为 ‘O’，再接下来的 $4^k$ 个字符全部为 ‘I’，最后的 $4^k$ 个字符构成一个级别 $k$ 的 JOI 序列。\n\n现在，K 理事长手中有一张纸上写有 $4^K$ 个字符，这些字符呈环形排列，每个字符是 ‘J’、‘O’、‘I’ 中的一个。K 理事长希望通过修改其中一些字符，使得从某个字符开始按顺时针方向读取整个环形字符串时，能形成一个级别 $K$ 的 JOI 序列。在此过程中，他希望修改的字符数量尽可能少。\n\n### 题目\n\n给定一个长度为 $4^K$ 的字符串，该字符串呈环形排列。编写程序，求出从某个字符开始按顺时针方向读取整个字符串时，使其变为级别 $K$ 的 JOI 序列所需的最少修改字符数。", "inputFormat": "从标准输入读取以下数据：\n\n- 第 1 行包含一个整数 $K$，表示纸上有 $4^K$ 个字符呈环形排列。\n- 第 2 行包含一个由字符 ‘J’、‘O’、‘I’ 组成的长度为 $4^K$ 的字符串，表示纸上环形排列的字符序列。\n", "outputFormat": "在标准输出中，输出 K 理事长需要修改的最少字符数，占一行。\n", "hint": "### 样例 1 解释\n\n字符形成的环如下图所示：\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/v8gbc8v5.png)\n:::\n\n以 J 为起点顺时针读取一周，形成的字符串为 JOII，这是一个级别为 1 的 JOI 列。K 理事长没必要替换字符，所以输出 0。\n\n### 样例 2 解释\n\n字符形成的环如下图所示，这里需要替换 7 个字符。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/x8gjn0hs.png)\n:::\n\n从画圈的字符开始读取这个字符环一周，得到 JJJJOOOOIIIIJOIJ 字符串，这是一个级别为 2 的 JOI 列，并且是替换次数最少的情况，因此输出 7。\n\n### 数据范围\n\n所有输入数据均满足以下条件：\n\n- $1 \\leq K \\leq 10$。\n\n### 子任务\n\n#### 子任务 1 [30 分]\n\n- $K \\leq 5$。\n\n#### 子任务 2 [70 分]\n\n无额外限制。\n", "locale": "zh-CN"}}}
{"pid": "P14407", "type": "P", "difficulty": 6, "samples": [["7\n22 60 30\n46 40 30\n36 100 50\n11 140 120\n38 120 20\n24 90 60\n53 50 20", "320"], ["5\n18 150 180\n18 380 250\n18 140 170\n17 180 900\n14 150 520", "1000"], ["8\n52 156 59\n15 166 185\n16 122 115\n24 161 154\n44 252 678\n32 225 557\n44 155 254\n59 57 253", "854"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2015", "线段树", "JOISC/JOIST（日本）"], "title": "[JOISC 2015] 有趣的家庭菜园 2 / Growing Vegetables is Fun 2", "background": null, "description": "家庭菜园的专家 JOI 君，每年都会在自己的园圃中种植一种名为 IOI 草的植物。冬季时，他播种 IOI 草的种子，春季时种子发芽并生长至固定高度。到了秋季，一些 IOI 草会结出美丽的果实，而未结果的 IOI 草则会在冬季枯萎。\n\nJOI 君的园圃被划分为 $N$ 个东西方向排列的区域，从西到东第 $i$ 个区域（$1 \\le i \\le N$）种植着 IOI 草 $i$。IOI 草 $i$ 在春季会生长至高度 $H_i$，之后不再生长。如果 IOI 草 $i$ 结出了果实，则在秋季可以以 $P_i$ 日元的价格出售；若未结果，则其商业价值为零。\n\n到了春季，观察园圃情况的 JOI 君决定拔除部分 IOI 草，以最大化通过拔除所得的收益。拔除 IOI 草 $i$（$1 \\le i \\le N$）需要花费 $C_i$ 日元。被拔除的 IOI 草会枯死，且只能在春季拔除，夏季或秋季均不可拔除。\n\nIOI 草是一种在夏季需要大量阳光的植物。对于某个区域内种植的 IOI 草，如果在其左侧（编号更小的区域）和右侧（编号更大的区域）都存在比它更高（高度大于 $H_i$）的 IOI 草，则该 IOI 草在秋季无法结果。换句话说，IOI 草 $i$（$1 \\le i \\le N$）在秋季能结果的条件是：在夏季阶段，区域 $1$ 至区域 $i-1$ 中没有比 IOI 草 $i$ 更高的 IOI 草，或区域 $i+1$ 至区域 $N$ 中没有比 IOI 草 $i$ 更高的 IOI 草。\n\nJOI 君的收益等于所有结果 IOI 草的出售价格总和减去拔除所有 IOI 草所花费的总费用。问题是：JOI 君最多可以获得多少收益？\n\n### 题目\n\n给定 JOI 君的园圃信息及种植的 IOI 草信息，编写程序求出 JOI 君能获得的最大收益。", "inputFormat": "从标准输入读入以下数据：\n\n- 第一行包含一个整数 $N$，表示 JOI 君园圃的区域数量。\n- 接下来的 $N$ 行，第 $i$ 行（$1 \\le i \\le N$）包含三个整数 $H_i, P_i, C_i$，以空格分隔。这表示 IOI 草 $i$ 在春季生长至高度 $H_i$，秋季结果时的售价为 $P_i$ 日元，拔除它需要花费 $C_i$ 日元。", "outputFormat": "在标准输出上，输出 JOI 君的最大收益，以一个整数形式输出在一行中。", "hint": "### 样例 1 解释\n\n考虑 IOI 草 2 和 IOI 草 7 被拔去的情况。剩下的 IOI 草如下表所示：\n\n考虑拔除 IOI 草 2 和 IOI 草 7 之后的状态。剩余的 IOI 草如下表所示：\n\n| IOI 草的编号 | 1   | 3   | 4   | 5   | 6   |\n|:------------:|:---:|:---:|:---:|:---:|:---:|\n| IOI 草的高度 | 22  | 36  | 11  | 38  | 24  |\n| 秋季是否结果 | ○   | ○   | ×   | ○   | ○   |\n\nIOI 草 1、IOI 草 3、IOI 草 5、IOI 草 6 的出售价格分别为 60 日元、100 日元、120 日元、90 日元。拔除 IOI 草 2 和 IOI 草 7 的费用分别为 30 日元和 20 日元。JOI 君的收益为 $60 + 100 + 120 + 90 - 30 - 20 = 320$ 日元，此值即为最大值。\n\n\n### 数据范围\n\n所有输入数据均满足以下条件：\n\n- $3 \\le N \\le 100000$\n- $1 \\le H_i \\le 1000000000$（$1 \\le i \\le N$）\n- $1 \\le P_i \\le 1000000000$（$1 \\le i \\le N$）\n- $1 \\le C_i \\le 1000000000$（$1 \\le i \\le N$）\n\n### 子任务\n\n#### 子任务 1 [10 分]\n\n- $N \\le 20$\n\n#### 子任务 2 [10 分]\n\n- $N \\le 300$\n\n#### 子任务 3 [10 分]\n\n- $N \\le 5000$\n\n#### 子任务 4 [50 分]\n\n- $H_i \\ne H_j$（$1 \\le i < j \\le N$）\n\n#### 子任务 5 [20 分]\n\n- 无额外限制\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2015] 有趣的家庭菜园 2 / Growing Vegetables is Fun 2", "background": null, "description": "家庭菜园的专家 JOI 君，每年都会在自己的园圃中种植一种名为 IOI 草的植物。冬季时，他播种 IOI 草的种子，春季时种子发芽并生长至固定高度。到了秋季，一些 IOI 草会结出美丽的果实，而未结果的 IOI 草则会在冬季枯萎。\n\nJOI 君的园圃被划分为 $N$ 个东西方向排列的区域，从西到东第 $i$ 个区域（$1 \\le i \\le N$）种植着 IOI 草 $i$。IOI 草 $i$ 在春季会生长至高度 $H_i$，之后不再生长。如果 IOI 草 $i$ 结出了果实，则在秋季可以以 $P_i$ 日元的价格出售；若未结果，则其商业价值为零。\n\n到了春季，观察园圃情况的 JOI 君决定拔除部分 IOI 草，以最大化通过拔除所得的收益。拔除 IOI 草 $i$（$1 \\le i \\le N$）需要花费 $C_i$ 日元。被拔除的 IOI 草会枯死，且只能在春季拔除，夏季或秋季均不可拔除。\n\nIOI 草是一种在夏季需要大量阳光的植物。对于某个区域内种植的 IOI 草，如果在其左侧（编号更小的区域）和右侧（编号更大的区域）都存在比它更高（高度大于 $H_i$）的 IOI 草，则该 IOI 草在秋季无法结果。换句话说，IOI 草 $i$（$1 \\le i \\le N$）在秋季能结果的条件是：在夏季阶段，区域 $1$ 至区域 $i-1$ 中没有比 IOI 草 $i$ 更高的 IOI 草，或区域 $i+1$ 至区域 $N$ 中没有比 IOI 草 $i$ 更高的 IOI 草。\n\nJOI 君的收益等于所有结果 IOI 草的出售价格总和减去拔除所有 IOI 草所花费的总费用。问题是：JOI 君最多可以获得多少收益？\n\n### 题目\n\n给定 JOI 君的园圃信息及种植的 IOI 草信息，编写程序求出 JOI 君能获得的最大收益。", "inputFormat": "从标准输入读入以下数据：\n\n- 第一行包含一个整数 $N$，表示 JOI 君园圃的区域数量。\n- 接下来的 $N$ 行，第 $i$ 行（$1 \\le i \\le N$）包含三个整数 $H_i, P_i, C_i$，以空格分隔。这表示 IOI 草 $i$ 在春季生长至高度 $H_i$，秋季结果时的售价为 $P_i$ 日元，拔除它需要花费 $C_i$ 日元。", "outputFormat": "在标准输出上，输出 JOI 君的最大收益，以一个整数形式输出在一行中。", "hint": "### 样例 1 解释\n\n考虑 IOI 草 2 和 IOI 草 7 被拔去的情况。剩下的 IOI 草如下表所示：\n\n考虑拔除 IOI 草 2 和 IOI 草 7 之后的状态。剩余的 IOI 草如下表所示：\n\n| IOI 草的编号 | 1   | 3   | 4   | 5   | 6   |\n|:------------:|:---:|:---:|:---:|:---:|:---:|\n| IOI 草的高度 | 22  | 36  | 11  | 38  | 24  |\n| 秋季是否结果 | ○   | ○   | ×   | ○   | ○   |\n\nIOI 草 1、IOI 草 3、IOI 草 5、IOI 草 6 的出售价格分别为 60 日元、100 日元、120 日元、90 日元。拔除 IOI 草 2 和 IOI 草 7 的费用分别为 30 日元和 20 日元。JOI 君的收益为 $60 + 100 + 120 + 90 - 30 - 20 = 320$ 日元，此值即为最大值。\n\n\n### 数据范围\n\n所有输入数据均满足以下条件：\n\n- $3 \\le N \\le 100000$\n- $1 \\le H_i \\le 1000000000$（$1 \\le i \\le N$）\n- $1 \\le P_i \\le 1000000000$（$1 \\le i \\le N$）\n- $1 \\le C_i \\le 1000000000$（$1 \\le i \\le N$）\n\n### 子任务\n\n#### 子任务 1 [10 分]\n\n- $N \\le 20$\n\n#### 子任务 2 [10 分]\n\n- $N \\le 300$\n\n#### 子任务 3 [10 分]\n\n- $N \\le 5000$\n\n#### 子任务 4 [50 分]\n\n- $H_i \\ne H_j$（$1 \\le i < j \\le N$）\n\n#### 子任务 5 [20 分]\n\n- 无额外限制\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN"}}}
{"pid": "P14408", "type": "P", "difficulty": 6, "samples": [["1 2 3 4 5\n3\n2 3\n2 6\n4 10", "12"], ["1 1 1 1 1\n1\n1 1", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "最短路", "差分", "JOISC/JOIST（日本）"], "title": "[JOISC 2015] IOIOI 卡牌占卜 / IOIOI Cards", "background": null, "description": "K 理事长喜欢占卜，总是进行各种各样的占卜。今天，他使用了正面写有 ‘I’、背面写有 ‘O’ 的卡片，来占卜今年 IOI 日本代表队的表现。\n\n占卜的方法如下：\n\n1. 首先，确定正整数 $A, B, C, D, E$。\n2. 将 $A + B + C + D + E$ 张卡片横向排列成一行。排列方式为：从左开始，前 $A$ 张为正面，接着 $B$ 张为背面，接着 $C$ 张为正面，接着 $D$ 张为背面，最后 $E$ 张为正面。这样排列后，从左到右依次会出现 $A$ 个 ‘I’、$B$ 个 ‘O’、$C$ 个 ‘I’、$D$ 个 ‘O’、$E$ 个 ‘I’。\n3. 从预先确定的 $N$ 种操作中选择一种或多种，按任意顺序执行。允许对同一种操作执行多次。第 $i$ 种（$1 \\le i \\le N$）操作定义为：“将从左数第 $L_i$ 张到第 $R_i$ 张卡片的所有正反面翻转”。翻转一张卡片需要 1 秒钟，因此执行第 $i$ 种操作需要 $R_i - L_i + 1$ 秒。\n4. 操作结束后，若所有卡片都为正面，则占卜成功。\n\n为了尽可能减少实际翻转卡片的次数，K 理事长在实际占卜前，希望先判断是否有可能使占卜成功。如果可以成功，他还希望求出使占卜成功所需的最少时间。\n\n### 题目\n\n给定卡片的初始排列信息和预先确定的操作信息，编写程序判断是否可以使占卜成功；如果可以，求出使占卜成功所需的最少时间。", "inputFormat": "从标准输入读入以下数据：\n\n- 第一行包含五个整数 $A, B, C, D, E$，以空格分隔。这表示占卜开始时，从左到右依次排列 $A$ 张正面、$B$ 张背面、$C$ 张正面、$D$ 张背面、$E$ 张正面的卡片。\n- 第二行包含一个整数 $N$，表示预先确定的操作种类数。\n- 接下来的 $N$ 行，第 $i$ 行（$1 \\le i \\le N$）包含两个整数 $L_i, R_i$，以空格分隔。这表示第 $i$ 种操作为“将从左数第 $L_i$ 张到第 $R_i$ 张卡片的所有正反面翻转”。", "outputFormat": "如果可以使占卜成功，则在标准输出上输出一行，表示使占卜成功所需的最少时间的整数；否则，输出 $-1$。", "hint": "### 样例 1 解释\n\n最初的卡片序列为 IOOIIIOOOOIIIII； 先进行第二个操作，卡片序列变为 IIIOOOOOOOIIIII，花费 5 秒； 再进行第三个操作，卡片序列变为 IIIIIIIIIIII，这个操作花费 7 秒，一共花费 12 秒。 可以证明，12 秒为占卜的最小耗时，因此输出 12。\n\n### 数据范围\n\n所有输入数据均满足以下条件：\n\n- $1 \\le A \\le 100000$\n- $1 \\le B \\le 100000$\n- $1 \\le C \\le 100000$\n- $1 \\le D \\le 100000$\n- $1 \\le E \\le 100000$\n- $1 \\le N \\le 100000$\n- $1 \\le L_i \\le R_i \\le A + B + C + D + E$（$1 \\le i \\le N$）\n\n### 子任务\n\n#### 子任务 1 [15 分]\n\n- $N \\le 10$\n\n#### 子任务 2 [50 分]\n\n满足以下条件：\n\n- $1 \\le A \\le 50$\n- $1 \\le B \\le 50$\n- $1 \\le C \\le 50$\n- $1 \\le D \\le 50$\n- $1 \\le E \\le 50$\n\n#### 子任务 3 [35 分]\n\n- 无额外限制\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2015] IOIOI 卡牌占卜 / IOIOI Cards", "background": null, "description": "K 理事长喜欢占卜，总是进行各种各样的占卜。今天，他使用了正面写有 ‘I’、背面写有 ‘O’ 的卡片，来占卜今年 IOI 日本代表队的表现。\n\n占卜的方法如下：\n\n1. 首先，确定正整数 $A, B, C, D, E$。\n2. 将 $A + B + C + D + E$ 张卡片横向排列成一行。排列方式为：从左开始，前 $A$ 张为正面，接着 $B$ 张为背面，接着 $C$ 张为正面，接着 $D$ 张为背面，最后 $E$ 张为正面。这样排列后，从左到右依次会出现 $A$ 个 ‘I’、$B$ 个 ‘O’、$C$ 个 ‘I’、$D$ 个 ‘O’、$E$ 个 ‘I’。\n3. 从预先确定的 $N$ 种操作中选择一种或多种，按任意顺序执行。允许对同一种操作执行多次。第 $i$ 种（$1 \\le i \\le N$）操作定义为：“将从左数第 $L_i$ 张到第 $R_i$ 张卡片的所有正反面翻转”。翻转一张卡片需要 1 秒钟，因此执行第 $i$ 种操作需要 $R_i - L_i + 1$ 秒。\n4. 操作结束后，若所有卡片都为正面，则占卜成功。\n\n为了尽可能减少实际翻转卡片的次数，K 理事长在实际占卜前，希望先判断是否有可能使占卜成功。如果可以成功，他还希望求出使占卜成功所需的最少时间。\n\n### 题目\n\n给定卡片的初始排列信息和预先确定的操作信息，编写程序判断是否可以使占卜成功；如果可以，求出使占卜成功所需的最少时间。", "inputFormat": "从标准输入读入以下数据：\n\n- 第一行包含五个整数 $A, B, C, D, E$，以空格分隔。这表示占卜开始时，从左到右依次排列 $A$ 张正面、$B$ 张背面、$C$ 张正面、$D$ 张背面、$E$ 张正面的卡片。\n- 第二行包含一个整数 $N$，表示预先确定的操作种类数。\n- 接下来的 $N$ 行，第 $i$ 行（$1 \\le i \\le N$）包含两个整数 $L_i, R_i$，以空格分隔。这表示第 $i$ 种操作为“将从左数第 $L_i$ 张到第 $R_i$ 张卡片的所有正反面翻转”。", "outputFormat": "如果可以使占卜成功，则在标准输出上输出一行，表示使占卜成功所需的最少时间的整数；否则，输出 $-1$。", "hint": "### 样例 1 解释\n\n最初的卡片序列为 IOOIIIOOOOIIIII； 先进行第二个操作，卡片序列变为 IIIOOOOOOOIIIII，花费 5 秒； 再进行第三个操作，卡片序列变为 IIIIIIIIIIII，这个操作花费 7 秒，一共花费 12 秒。 可以证明，12 秒为占卜的最小耗时，因此输出 12。\n\n### 数据范围\n\n所有输入数据均满足以下条件：\n\n- $1 \\le A \\le 100000$\n- $1 \\le B \\le 100000$\n- $1 \\le C \\le 100000$\n- $1 \\le D \\le 100000$\n- $1 \\le E \\le 100000$\n- $1 \\le N \\le 100000$\n- $1 \\le L_i \\le R_i \\le A + B + C + D + E$（$1 \\le i \\le N$）\n\n### 子任务\n\n#### 子任务 1 [15 分]\n\n- $N \\le 10$\n\n#### 子任务 2 [50 分]\n\n满足以下条件：\n\n- $1 \\le A \\le 50$\n- $1 \\le B \\le 50$\n- $1 \\le C \\le 50$\n- $1 \\le D \\le 50$\n- $1 \\le E \\le 50$\n\n#### 子任务 3 [35 分]\n\n- 无额外限制\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN"}}}
{"pid": "P14409", "type": "P", "difficulty": 4, "samples": [["4\n1\n1\n2", "5"], ["8\n1\n1\n2\n1\n2\n3\n1", "15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "组合数学", "JOISC/JOIST（日本）"], "title": "[JOISC 2015] 建筑装饰 3 / Building 3", "background": "", "description": "国际信息学奥林匹克竞赛将在日本举行，为了欢迎来自世界各地的选手，决定从机场到住宿设施沿途的高层建筑进行装饰。为此，委托了一位著名设计师进行设计。设计师表示，装饰所用的建筑高度必须从机场附近到住宿设施附近依次递增，即若将建筑高度记为 $h_1, h_2, h_3, \\dots$，则必须满足 $h_1 < h_2 < h_3 < \\cdots$。\n\n为了尽可能多地装饰建筑，JOI 君被委任选择用于装饰的建筑。建筑所有者提出“我拥有的建筑必须被用于装饰”，同时还可能提出“我希望我拥有的建筑在所有被用于装饰的建筑中，离住宿设施最近”的无理要求。\n\n从机场到住宿设施的大道沿途共有 $N$ 栋建筑，将离机场最近的第 $i$ 栋建筑记为建筑 $i$（$1 \\le i \\le N$）。所有建筑的高度各不相同。JOI 君为了应对各种可能的要求，预先计算了“若选择建筑 $i$ 用于装饰，且在所有被用于装饰的建筑中，建筑 $i$ 离住宿设施最近，则最多可选择的建筑数量为 $A_i$”这一信息，并将整数序列 $A_1, A_2, \\dots, A_N$ 提交给信息学奥林匹克日本委员会的 K 理事长。\n\n然而，K 理事长收到的备忘录上，实际上只写有长度为 $N-1$ 的整数序列 $B_1, B_2, \\dots, B_{N-1}$，并未包含 $A_i$ 的完整信息。由于 K 理事长不知道建筑高度，因此无法直接计算 $A_i$ 的值。\n\nK 理事长认为 JOI 君可能只漏写了一个数字。假设整数序列 $A_1, A_2, \\dots, A_N$ 是由建筑高度决定的，那么从该序列中删除一个元素后，得到的序列恰好是 $B_1, B_2, \\dots, B_{N-1}$ 的情况有多少种？\n\n需要注意的是，JOI 君也可能写错了其他内容，因此根据 $B_1, B_2, \\dots, B_{N-1}$ 的值，可能不存在这样的序列，也可能存在多个。\n\n### 题目\n\n给定长度为 $N-1$ 的整数序列 $B_1, B_2, \\dots, B_{N-1}$，求出有多少种可能的整数序列 $A_1, A_2, \\dots, A_N$，使得从中删除一个元素后，得到的序列恰好是 $B_1, B_2, \\dots, B_{N-1}$。\n", "inputFormat": "从标准输入读入以下数据：\n\n- 第一行包含一个整数 $N$，表示从机场到住宿设施沿途共有 $N$ 栋建筑。\n- 接下来的 $N-1$ 行，第 $j$ 行（$1 \\le j \\le N-1$）包含一个整数 $B_j$，表示 K 理事长收到的备忘录中整数序列的第 $j$ 个值。\n", "outputFormat": "在标准输出上输出一行，表示在所有可能的整数序列 $A_1, A_2, \\dots, A_N$ 中，删除一个元素后能恰好得到整数序列 $B_1, B_2, \\dots, B_{N-1}$ 的序列个数。\n", "hint": "### 样例 1 解释\n\n从机场到住宿设施沿途共有 4 栋建筑。记建筑 $i$ 的高度为 $H_i$。\n\n对于整数序列 $A_1, A_2, A_3, A_4$，由于建筑高度的不同，可能产生多种情况。其中，从该序列中删除一个元素后，得到整数序列 $1, 2$ 的情况共有以下 5 种：\n\n- 整数序列 $1, 2, 1, 2$。例如，当 $H_2 > H_4 > H_1 > H_3$ 时，$A_1 = 1$，$A_2 = 2$，$A_3 = 1$，$A_4 = 2$；又例如，当 $H_2 > H_1 > H_4 > H_3$ 时，同样有 $A_1 = 1$，$A_2 = 2$，$A_3 = 1$，$A_4 = 2$。\n- 整数序列 $1, 1, 2, 3$。例如，当 $H_4 > H_3 > H_1 > H_2$ 时，$A_1 = 1$，$A_2 = 1$，$A_3 = 2$，$A_4 = 3$。\n- 整数序列 $1, 1, 2, 1$。例如，当 $H_3 > H_1 > H_2 > H_4$ 时，$A_1 = 1$，$A_2 = 1$，$A_3 = 2$，$A_4 = 1$。\n- 整数序列 $1, 1, 2, 2$。例如，当 $H_3 > H_4 > H_1 > H_2$ 时，$A_1 = 1$，$A_2 = 1$，$A_3 = 2$，$A_4 = 2$。\n- 整数序列 $1, 1, 1, 2$。例如，当 $H_4 > H_1 > H_2 > H_3$ 时，$A_1 = 1$，$A_2 = 1$，$A_3 = 1$，$A_4 = 2$。\n\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $2 \\le N \\le 1000000$\n- $1 \\le B_j \\le N$（$1 \\le j \\le N-1$）\n\n### 子任务\n\n#### 子任务 1 [10 分]\n\n- $N \\le 8$\n\n#### 子任务 2 [30 分]\n\n- $N \\le 300$\n\n#### 子任务 3 [60 分]\n\n无额外限制。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2015] 建筑装饰 3 / Building 3", "background": "", "description": "国际信息学奥林匹克竞赛将在日本举行，为了欢迎来自世界各地的选手，决定从机场到住宿设施沿途的高层建筑进行装饰。为此，委托了一位著名设计师进行设计。设计师表示，装饰所用的建筑高度必须从机场附近到住宿设施附近依次递增，即若将建筑高度记为 $h_1, h_2, h_3, \\dots$，则必须满足 $h_1 < h_2 < h_3 < \\cdots$。\n\n为了尽可能多地装饰建筑，JOI 君被委任选择用于装饰的建筑。建筑所有者提出“我拥有的建筑必须被用于装饰”，同时还可能提出“我希望我拥有的建筑在所有被用于装饰的建筑中，离住宿设施最近”的无理要求。\n\n从机场到住宿设施的大道沿途共有 $N$ 栋建筑，将离机场最近的第 $i$ 栋建筑记为建筑 $i$（$1 \\le i \\le N$）。所有建筑的高度各不相同。JOI 君为了应对各种可能的要求，预先计算了“若选择建筑 $i$ 用于装饰，且在所有被用于装饰的建筑中，建筑 $i$ 离住宿设施最近，则最多可选择的建筑数量为 $A_i$”这一信息，并将整数序列 $A_1, A_2, \\dots, A_N$ 提交给信息学奥林匹克日本委员会的 K 理事长。\n\n然而，K 理事长收到的备忘录上，实际上只写有长度为 $N-1$ 的整数序列 $B_1, B_2, \\dots, B_{N-1}$，并未包含 $A_i$ 的完整信息。由于 K 理事长不知道建筑高度，因此无法直接计算 $A_i$ 的值。\n\nK 理事长认为 JOI 君可能只漏写了一个数字。假设整数序列 $A_1, A_2, \\dots, A_N$ 是由建筑高度决定的，那么从该序列中删除一个元素后，得到的序列恰好是 $B_1, B_2, \\dots, B_{N-1}$ 的情况有多少种？\n\n需要注意的是，JOI 君也可能写错了其他内容，因此根据 $B_1, B_2, \\dots, B_{N-1}$ 的值，可能不存在这样的序列，也可能存在多个。\n\n### 题目\n\n给定长度为 $N-1$ 的整数序列 $B_1, B_2, \\dots, B_{N-1}$，求出有多少种可能的整数序列 $A_1, A_2, \\dots, A_N$，使得从中删除一个元素后，得到的序列恰好是 $B_1, B_2, \\dots, B_{N-1}$。\n", "inputFormat": "从标准输入读入以下数据：\n\n- 第一行包含一个整数 $N$，表示从机场到住宿设施沿途共有 $N$ 栋建筑。\n- 接下来的 $N-1$ 行，第 $j$ 行（$1 \\le j \\le N-1$）包含一个整数 $B_j$，表示 K 理事长收到的备忘录中整数序列的第 $j$ 个值。\n", "outputFormat": "在标准输出上输出一行，表示在所有可能的整数序列 $A_1, A_2, \\dots, A_N$ 中，删除一个元素后能恰好得到整数序列 $B_1, B_2, \\dots, B_{N-1}$ 的序列个数。\n", "hint": "### 样例 1 解释\n\n从机场到住宿设施沿途共有 4 栋建筑。记建筑 $i$ 的高度为 $H_i$。\n\n对于整数序列 $A_1, A_2, A_3, A_4$，由于建筑高度的不同，可能产生多种情况。其中，从该序列中删除一个元素后，得到整数序列 $1, 2$ 的情况共有以下 5 种：\n\n- 整数序列 $1, 2, 1, 2$。例如，当 $H_2 > H_4 > H_1 > H_3$ 时，$A_1 = 1$，$A_2 = 2$，$A_3 = 1$，$A_4 = 2$；又例如，当 $H_2 > H_1 > H_4 > H_3$ 时，同样有 $A_1 = 1$，$A_2 = 2$，$A_3 = 1$，$A_4 = 2$。\n- 整数序列 $1, 1, 2, 3$。例如，当 $H_4 > H_3 > H_1 > H_2$ 时，$A_1 = 1$，$A_2 = 1$，$A_3 = 2$，$A_4 = 3$。\n- 整数序列 $1, 1, 2, 1$。例如，当 $H_3 > H_1 > H_2 > H_4$ 时，$A_1 = 1$，$A_2 = 1$，$A_3 = 2$，$A_4 = 1$。\n- 整数序列 $1, 1, 2, 2$。例如，当 $H_3 > H_4 > H_1 > H_2$ 时，$A_1 = 1$，$A_2 = 1$，$A_3 = 2$，$A_4 = 2$。\n- 整数序列 $1, 1, 1, 2$。例如，当 $H_4 > H_1 > H_2 > H_3$ 时，$A_1 = 1$，$A_2 = 1$，$A_3 = 1$，$A_4 = 2$。\n\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $2 \\le N \\le 1000000$\n- $1 \\le B_j \\le N$（$1 \\le j \\le N-1$）\n\n### 子任务\n\n#### 子任务 1 [10 分]\n\n- $N \\le 8$\n\n#### 子任务 2 [30 分]\n\n- $N \\le 300$\n\n#### 子任务 3 [60 分]\n\n无额外限制。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN"}}}
{"pid": "P14410", "type": "P", "difficulty": 6, "samples": [["4 20 2\n3 11\n5 15\n6 10\n12 18", "13"], ["20 100000 8\n29930 89724\n56133 70462\n28063 78568\n32483 64351\n9410 20176\n55809 62944\n32450 85190\n73536 73966\n20452 78868\n45458 63484\n8286 47425\n76018 81622\n16736 49308\n85383 94641\n25100 40002\n22158 22821\n23508 41781\n61709 98882\n58110 78431\n28448 89247", "72454"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2015", "树形 DP", "JOISC/JOIST（日本）"], "title": "[JOISC 2015] 钥匙 / Keys", "background": "", "description": "你知道 Just Odd Inventions 公司吗？该公司的业务是“仅仅奇妙的发明（just odd inventions）”，在此简称为 JOI 公司。\n\nJOI 公司有 $N$ 名员工，编号从 1 到 $N$。所有员工在时刻 0 到时刻 $M$ 之间工作，时刻 0 和时刻 $M$ 时，所有员工必须在公司内部。\n\n今天，巧合的是，每位员工恰好外出一次。员工 $i$（$1 \\le i \\le N$）在时刻 $S_i$ 离开公司，在时刻 $T_i$ 返回公司。没有任何两名员工在同一时刻进出公司。\n\nJOI 公司入口处有一扇大门，员工只能通过这扇门进出公司。门上装有锁，锁可以处于开启或关闭状态。公司内部人员可以自由开关锁，但公司外部人员只能由持有钥匙的人开关锁。在时刻 0，门锁处于关闭状态。\n\n每位员工在返回公司时，必须能够进入公司。也就是说，对于任意员工 $i$（$1 \\le i \\le N$），必须满足：员工 $i$ 持有钥匙，或者在时刻 $T_i$ 时门锁处于开启状态，二者至少满足其一。当员工返回公司时，以及持有钥匙的员工离开公司时，可以选择是否关闭门锁。没有钥匙的员工离开公司时，不允许关闭门锁。\n\nJOI 公司的社长决定将钥匙交给 $K$ 名员工。为了避免钥匙丢失，员工之间不能互相传递钥匙。此外，JOI 公司的社长重视工作效率，因此员工除了自己进出公司时，不得随意开关门锁。\n\n出于安全考虑，社长希望在工作时间 $M$ 内，门锁关闭的总时间尽可能长。\n\n### 题目\n\n给定员工的进出时间信息，以及被授予钥匙的员工数量 $K$，编写一个程序，求在合理管理门锁开关的情况下，门锁在工作时间 $M$ 内关闭的总时间的最大值。", "inputFormat": "从标准输入读入以下数据：\n\n- 第一行包含三个整数 $N, M, K$，以空格分隔。表示 JOI 公司有 $N$ 名员工，所有员工在时刻 0 到时刻 $M$ 之间工作，其中 $K$ 名员工将被授予钥匙。\n- 接下来的 $N$ 行，第 $i$ 行（$1 \\le i \\le N$）包含两个整数 $S_i, T_i$，以空格分隔。表示员工 $i$ 在时刻 $S_i$ 离开公司，在时刻 $T_i$ 返回公司。\n", "outputFormat": "在标准输出上，输出一行，表示在工作时间 $M$ 内，通过合理管理门锁开关，门锁关闭的总时间的最大值。\n", "hint": "在该输入输出示例中，JOI 公司有 4 名员工，其中 2 名员工被授予钥匙。若将钥匙交给员工 2 和员工 4，并按以下方式操作，则门锁关闭的总时间为 13：\n\n- 时刻 0，门锁处于关闭状态。\n- 时刻 3，员工 1 离开公司。由于员工 1 未持有钥匙，无法关闭门锁。\n- 时刻 5，员工 2 离开公司，并关闭门锁。\n- 时刻 6，员工 3 离开公司。由于员工 3 未持有钥匙，无法关闭门锁。\n- 时刻 10，员工 3 返回公司，门锁保持开启状态。\n- 时刻 11，员工 1 返回公司，并关闭门锁。\n- 时刻 12，员工 4 离开公司，并关闭门锁。\n- 时刻 15，员工 2 返回公司，并关闭门锁。\n- 时刻 18，员工 4 返回公司，并关闭门锁。\n- 时刻 20 之前，门锁一直处于关闭状态。\n\n门锁关闭的总时间无法超过 13，因此输出 13。\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le N \\le 2000$\n- $1 \\le M \\le 1000000000$\n- $1 \\le K < N$\n- $0 < S_i < T_i < M$（$1 \\le i \\le N$）\n- 对任意 $i, j$（$1 \\le i \\le N, 1 \\le j \\le N, i \\ne j$），满足 $S_i \\ne S_j, S_i \\ne T_j, T_i \\ne T_j$\n\n### 子任务\n\n#### 子任务 1 [10 分]\n\n- $N \\le 20$\n- $M \\le 1000000$\n\n#### 子任务 2 [90 分]\n\n无额外限制。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2015] 钥匙 / Keys", "background": "", "description": "你知道 Just Odd Inventions 公司吗？该公司的业务是“仅仅奇妙的发明（just odd inventions）”，在此简称为 JOI 公司。\n\nJOI 公司有 $N$ 名员工，编号从 1 到 $N$。所有员工在时刻 0 到时刻 $M$ 之间工作，时刻 0 和时刻 $M$ 时，所有员工必须在公司内部。\n\n今天，巧合的是，每位员工恰好外出一次。员工 $i$（$1 \\le i \\le N$）在时刻 $S_i$ 离开公司，在时刻 $T_i$ 返回公司。没有任何两名员工在同一时刻进出公司。\n\nJOI 公司入口处有一扇大门，员工只能通过这扇门进出公司。门上装有锁，锁可以处于开启或关闭状态。公司内部人员可以自由开关锁，但公司外部人员只能由持有钥匙的人开关锁。在时刻 0，门锁处于关闭状态。\n\n每位员工在返回公司时，必须能够进入公司。也就是说，对于任意员工 $i$（$1 \\le i \\le N$），必须满足：员工 $i$ 持有钥匙，或者在时刻 $T_i$ 时门锁处于开启状态，二者至少满足其一。当员工返回公司时，以及持有钥匙的员工离开公司时，可以选择是否关闭门锁。没有钥匙的员工离开公司时，不允许关闭门锁。\n\nJOI 公司的社长决定将钥匙交给 $K$ 名员工。为了避免钥匙丢失，员工之间不能互相传递钥匙。此外，JOI 公司的社长重视工作效率，因此员工除了自己进出公司时，不得随意开关门锁。\n\n出于安全考虑，社长希望在工作时间 $M$ 内，门锁关闭的总时间尽可能长。\n\n### 题目\n\n给定员工的进出时间信息，以及被授予钥匙的员工数量 $K$，编写一个程序，求在合理管理门锁开关的情况下，门锁在工作时间 $M$ 内关闭的总时间的最大值。", "inputFormat": "从标准输入读入以下数据：\n\n- 第一行包含三个整数 $N, M, K$，以空格分隔。表示 JOI 公司有 $N$ 名员工，所有员工在时刻 0 到时刻 $M$ 之间工作，其中 $K$ 名员工将被授予钥匙。\n- 接下来的 $N$ 行，第 $i$ 行（$1 \\le i \\le N$）包含两个整数 $S_i, T_i$，以空格分隔。表示员工 $i$ 在时刻 $S_i$ 离开公司，在时刻 $T_i$ 返回公司。\n", "outputFormat": "在标准输出上，输出一行，表示在工作时间 $M$ 内，通过合理管理门锁开关，门锁关闭的总时间的最大值。\n", "hint": "在该输入输出示例中，JOI 公司有 4 名员工，其中 2 名员工被授予钥匙。若将钥匙交给员工 2 和员工 4，并按以下方式操作，则门锁关闭的总时间为 13：\n\n- 时刻 0，门锁处于关闭状态。\n- 时刻 3，员工 1 离开公司。由于员工 1 未持有钥匙，无法关闭门锁。\n- 时刻 5，员工 2 离开公司，并关闭门锁。\n- 时刻 6，员工 3 离开公司。由于员工 3 未持有钥匙，无法关闭门锁。\n- 时刻 10，员工 3 返回公司，门锁保持开启状态。\n- 时刻 11，员工 1 返回公司，并关闭门锁。\n- 时刻 12，员工 4 离开公司，并关闭门锁。\n- 时刻 15，员工 2 返回公司，并关闭门锁。\n- 时刻 18，员工 4 返回公司，并关闭门锁。\n- 时刻 20 之前，门锁一直处于关闭状态。\n\n门锁关闭的总时间无法超过 13，因此输出 13。\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le N \\le 2000$\n- $1 \\le M \\le 1000000000$\n- $1 \\le K < N$\n- $0 < S_i < T_i < M$（$1 \\le i \\le N$）\n- 对任意 $i, j$（$1 \\le i \\le N, 1 \\le j \\le N, i \\ne j$），满足 $S_i \\ne S_j, S_i \\ne T_j, T_i \\ne T_j$\n\n### 子任务\n\n#### 子任务 1 [10 分]\n\n- $N \\le 20$\n- $M \\le 1000000$\n\n#### 子任务 2 [90 分]\n\n无额外限制。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN"}}}
{"pid": "P14411", "type": "P", "difficulty": 5, "samples": [["3 7\n1 1 2\n2 2 1\n2 2 3\n1 2 1\n2 1 2\n1 2 3\n2 1 3", "1\n-1\n0\n1"], ["6 8\n1 1 3\n1 6 1\n1 2 5\n2 3 6\n1 3 6\n1 4 1\n2 4 3\n2 2 5", "2\n1\n1"], ["7 11\n1 5 1\n1 6 2\n1 1 3\n1 3 5\n1 5 7\n1 4 5\n1 4 1\n2 1 3\n2 3 7\n2 4 3\n2 5 6", "0\n1\n0\n-1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "线段树", "并查集", "树链剖分", "JOISC/JOIST（日本）"], "title": "[JOISC 2015] 道路建设 / Road Development", "background": "", "description": "IOI 国由 $N$ 个城市组成，这些城市编号为 $1, 2, \\dots, N$。JOI 教授对 IOI 国道路网络建设的过程产生了兴趣。\n\nJOI 教授查阅了有关 IOI 国历史的资料，发现以下事实：\n\n- IOI 国的城市自建国以来至今保持不变。IOI 国建国初期没有任何连接城市的道路。\n- 在 IOI 国建国 $i$ 年后（$1 \\le i \\le Q$），制定了改善城市 $A_i$ 与城市 $B_i$ 之间交通状况的计划。\n- 制定的改善计划中，部分计划得以实施，而部分计划则未实施而被放弃。\n- 哪些计划被实施，哪些被放弃，从资料中可以明确得知。\n- 所有被实施的改善计划均在一年内完成。\n\n此外，从其他文献中得知，城市 $A_i$ 与城市 $B_i$ 之间交通状况的改善计划具有以下特点：\n\n- 若在计划制定时，无法通过已建成的道路从城市 $A_i$ 移动到城市 $B_i$，则新建一条连接城市 $A_i$ 与城市 $B_i$ 的双向道路。新建的道路为未铺设路面的道路。\n- 若在计划制定时，可以通过已建成的道路从城市 $A_i$ 移动到城市 $B_i$，则在所有可能的路径中，选择使用道路数量最少的路径，并将该路径中包含的所有未铺设路面的道路铺设路面。若存在多条使用道路数量最少的路径，则对所有这些路径中的未铺设路面道路进行统一铺设。已铺设路面的道路不会再次铺设。\n\nJOI 教授为进一步调查，针对那些未实施而被放弃的改善计划，计算若仅这些计划被追加实施，每个计划中将铺设多少条道路。\n\n### 题目\n\n给定 IOI 国交通状况的改善计划及其实施情况，编写一个程序，对每个未实施而被放弃的改善计划，计算若该计划被实施，则将铺设多少条道路。", "inputFormat": "从标准输入读入以下数据：\n\n- 第一行包含两个整数 $N, Q$，以空格分隔。表示 IOI 国有 $N$ 个城市，JOI 教授关注了从建国起 $Q$ 年间的交通改善计划。\n- 接下来的 $Q$ 行，第 $i$ 行（$1 \\le i \\le Q$）包含三个整数 $T_i, A_i, B_i$，以空格分隔。整数 $T_i$ 表示在建国 $i$ 年后制定的改善计划的实施状态：当 $T_i = 1$ 时表示该计划已实施，当 $T_i = 2$ 时表示该计划未实施而被放弃。整数 $A_i, B_i$ 表示在建国 $i$ 年后，制定了改善城市 $A_i$ 与城市 $B_i$ 之间交通状况的计划。\n", "outputFormat": "在标准输出上，对每个未实施而被放弃的改善计划，输出一行，表示若该计划被实施，则将铺设的道路数量。但若实施该计划会导致新建一条道路，则输出 $-1$。\n", "hint": "### 样例 1 解释\n\n在该输入示例中，IOI 国的交通改善计划执行情况如下：\n\n- IOI 国有 3 个城市，建国初期没有任何连接这些城市的道路。\n- 建国 1 年后，实施了城市 1 与城市 2 之间交通状况的改善计划。此时无法通过已建成的道路从城市 1 移动到城市 2，因此该计划导致新建了一条连接这两个城市的道路。\n- 建国 2 年后，制定了城市 2 与城市 1 之间交通状况的改善计划，但未实施而被放弃。此时可以通过 1 条已建成的道路从城市 2 移动到城市 1，且该道路尚未铺设路面，因此对该改善计划对应的输出为 1。\n- 建国 3 年后，制定了城市 2 与城市 3 之间交通状况的改善计划，但未实施而被放弃。此时无法通过已建成的道路从城市 2 移动到城市 3，因此对该改善计划对应的输出为 -1。\n- 建国 4 年后，实施了城市 2 与城市 1 之间交通状况的改善计划。此时可以通过已建成的道路从城市 2 移动到城市 1，因此该计划导致将连接这两个城市的道路铺设路面。\n- 建国 5 年后，制定了城市 1 与城市 2 之间交通状况的改善计划，但未实施而被放弃。此时可以通过 1 条已建成的道路从城市 1 移动到城市 2，且该道路已铺设路面，因此对该改善计划对应的输出为 0。\n- 建国 6 年后，实施了城市 2 与城市 3 之间交通状况的改善计划。此时无法通过已建成的道路从城市 2 移动到城市 3，因此该计划导致新建了一条连接这两个城市的道路。\n- 建国 7 年后，制定了城市 1 与城市 3 之间交通状况的改善计划，但未实施而被放弃。此时可以通过 2 条已建成的道路从城市 1 移动到城市 3，其中仅 1 条道路未铺设路面，因此对该改善计划对应的输出为 1。\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $2 \\le N \\le 100000$\n- $1 \\le Q \\le 300000$\n- $1 \\le T_i \\le 2$（$1 \\le i \\le Q$）\n- $1 \\le A_i \\le N$（$1 \\le i \\le Q$）\n- $1 \\le B_i \\le N$（$1 \\le i \\le Q$）\n- $A_i \\ne B_i$（$1 \\le i \\le Q$）\n\n### 子任务\n\n#### 子任务 1 [10 分]\n\n满足以下条件：\n\n- $N \\le 1000$\n- $Q \\le 3000$\n\n#### 子任务 2 [25 分]\n\n- 存在整数 $P$（$1 \\le P \\le Q-1$），满足 $T_i = 1$（$1 \\le i \\le P$）且 $T_i = 2$（$P+1 \\le i \\le Q$）。\n\n#### 子任务 3 [25 分]\n\n- 对所有满足 $T_i = 1$ 的 $i$（$1 \\le i \\le Q$），以下任一条件成立：\n  - 在实施建国 $i$ 年后的改善计划之前，无法通过已建成的道路从城市 $A_i$ 移动到城市 $B_i$。\n  - 在实施建国 $i$ 年后的改善计划之前，可以通过已建成的道路中不超过 200 条道路从城市 $A_i$ 移动到城市 $B_i$。\n\n#### 子任务 4 [25 分]\n\n- 满足 $T_i = 2$ 的 $i$（$1 \\le i \\le Q$）的数量不超过 200。\n\n#### 子任务 5 [15 分]\n\n无额外限制。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2015] 道路建设 / Road Development", "background": "", "description": "IOI 国由 $N$ 个城市组成，这些城市编号为 $1, 2, \\dots, N$。JOI 教授对 IOI 国道路网络建设的过程产生了兴趣。\n\nJOI 教授查阅了有关 IOI 国历史的资料，发现以下事实：\n\n- IOI 国的城市自建国以来至今保持不变。IOI 国建国初期没有任何连接城市的道路。\n- 在 IOI 国建国 $i$ 年后（$1 \\le i \\le Q$），制定了改善城市 $A_i$ 与城市 $B_i$ 之间交通状况的计划。\n- 制定的改善计划中，部分计划得以实施，而部分计划则未实施而被放弃。\n- 哪些计划被实施，哪些被放弃，从资料中可以明确得知。\n- 所有被实施的改善计划均在一年内完成。\n\n此外，从其他文献中得知，城市 $A_i$ 与城市 $B_i$ 之间交通状况的改善计划具有以下特点：\n\n- 若在计划制定时，无法通过已建成的道路从城市 $A_i$ 移动到城市 $B_i$，则新建一条连接城市 $A_i$ 与城市 $B_i$ 的双向道路。新建的道路为未铺设路面的道路。\n- 若在计划制定时，可以通过已建成的道路从城市 $A_i$ 移动到城市 $B_i$，则在所有可能的路径中，选择使用道路数量最少的路径，并将该路径中包含的所有未铺设路面的道路铺设路面。若存在多条使用道路数量最少的路径，则对所有这些路径中的未铺设路面道路进行统一铺设。已铺设路面的道路不会再次铺设。\n\nJOI 教授为进一步调查，针对那些未实施而被放弃的改善计划，计算若仅这些计划被追加实施，每个计划中将铺设多少条道路。\n\n### 题目\n\n给定 IOI 国交通状况的改善计划及其实施情况，编写一个程序，对每个未实施而被放弃的改善计划，计算若该计划被实施，则将铺设多少条道路。", "inputFormat": "从标准输入读入以下数据：\n\n- 第一行包含两个整数 $N, Q$，以空格分隔。表示 IOI 国有 $N$ 个城市，JOI 教授关注了从建国起 $Q$ 年间的交通改善计划。\n- 接下来的 $Q$ 行，第 $i$ 行（$1 \\le i \\le Q$）包含三个整数 $T_i, A_i, B_i$，以空格分隔。整数 $T_i$ 表示在建国 $i$ 年后制定的改善计划的实施状态：当 $T_i = 1$ 时表示该计划已实施，当 $T_i = 2$ 时表示该计划未实施而被放弃。整数 $A_i, B_i$ 表示在建国 $i$ 年后，制定了改善城市 $A_i$ 与城市 $B_i$ 之间交通状况的计划。\n", "outputFormat": "在标准输出上，对每个未实施而被放弃的改善计划，输出一行，表示若该计划被实施，则将铺设的道路数量。但若实施该计划会导致新建一条道路，则输出 $-1$。\n", "hint": "### 样例 1 解释\n\n在该输入示例中，IOI 国的交通改善计划执行情况如下：\n\n- IOI 国有 3 个城市，建国初期没有任何连接这些城市的道路。\n- 建国 1 年后，实施了城市 1 与城市 2 之间交通状况的改善计划。此时无法通过已建成的道路从城市 1 移动到城市 2，因此该计划导致新建了一条连接这两个城市的道路。\n- 建国 2 年后，制定了城市 2 与城市 1 之间交通状况的改善计划，但未实施而被放弃。此时可以通过 1 条已建成的道路从城市 2 移动到城市 1，且该道路尚未铺设路面，因此对该改善计划对应的输出为 1。\n- 建国 3 年后，制定了城市 2 与城市 3 之间交通状况的改善计划，但未实施而被放弃。此时无法通过已建成的道路从城市 2 移动到城市 3，因此对该改善计划对应的输出为 -1。\n- 建国 4 年后，实施了城市 2 与城市 1 之间交通状况的改善计划。此时可以通过已建成的道路从城市 2 移动到城市 1，因此该计划导致将连接这两个城市的道路铺设路面。\n- 建国 5 年后，制定了城市 1 与城市 2 之间交通状况的改善计划，但未实施而被放弃。此时可以通过 1 条已建成的道路从城市 1 移动到城市 2，且该道路已铺设路面，因此对该改善计划对应的输出为 0。\n- 建国 6 年后，实施了城市 2 与城市 3 之间交通状况的改善计划。此时无法通过已建成的道路从城市 2 移动到城市 3，因此该计划导致新建了一条连接这两个城市的道路。\n- 建国 7 年后，制定了城市 1 与城市 3 之间交通状况的改善计划，但未实施而被放弃。此时可以通过 2 条已建成的道路从城市 1 移动到城市 3，其中仅 1 条道路未铺设路面，因此对该改善计划对应的输出为 1。\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $2 \\le N \\le 100000$\n- $1 \\le Q \\le 300000$\n- $1 \\le T_i \\le 2$（$1 \\le i \\le Q$）\n- $1 \\le A_i \\le N$（$1 \\le i \\le Q$）\n- $1 \\le B_i \\le N$（$1 \\le i \\le Q$）\n- $A_i \\ne B_i$（$1 \\le i \\le Q$）\n\n### 子任务\n\n#### 子任务 1 [10 分]\n\n满足以下条件：\n\n- $N \\le 1000$\n- $Q \\le 3000$\n\n#### 子任务 2 [25 分]\n\n- 存在整数 $P$（$1 \\le P \\le Q-1$），满足 $T_i = 1$（$1 \\le i \\le P$）且 $T_i = 2$（$P+1 \\le i \\le Q$）。\n\n#### 子任务 3 [25 分]\n\n- 对所有满足 $T_i = 1$ 的 $i$（$1 \\le i \\le Q$），以下任一条件成立：\n  - 在实施建国 $i$ 年后的改善计划之前，无法通过已建成的道路从城市 $A_i$ 移动到城市 $B_i$。\n  - 在实施建国 $i$ 年后的改善计划之前，可以通过已建成的道路中不超过 200 条道路从城市 $A_i$ 移动到城市 $B_i$。\n\n#### 子任务 4 [25 分]\n\n- 满足 $T_i = 2$ 的 $i$（$1 \\le i \\le Q$）的数量不超过 200。\n\n#### 子任务 5 [15 分]\n\n无额外限制。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN"}}}
{"pid": "P14412", "type": "P", "difficulty": 6, "samples": [["12 26\n26\n17\n17\n17\n1\n26\n1\n17\n19\n20\n1\n14\n", "8"], ["4 3\n1\n2\n3\n2", "3"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "JOISC/JOIST（日本）"], "title": "[JOISC 2015] AAQQZ", "background": null, "description": "2015 年的国际信息学奥林匹克竞赛在哈萨克斯坦举行。哈萨克斯坦的“哈萨克”在字母表中可拼写为“QAZAQ”，这是一个回文。得知此事的 JOI 君对回文产生了兴趣，于是决定从他看到的文本中构造回文。\n\nJOI 君看到的是一个长度为 $N$ 的字符串。每个字符对应一个从 1 到 $C$ 的整数，将字符串的字符替换为整数后得到数列 $S = (S_1, S_2, \\dots, S_N)$。从数列 $S$ 的第 $i$ 项到第 $j$ 项（$1 \\le i \\le j \\le N$）取出的子序列 $(S_i, S_{i+1}, \\dots, S_j)$ 称为片段 $(i, j)$。若将片段 $(i, j)$ 前后翻转后和原来相等，即 $(S_i, S_{i+1}, \\dots, S_j) = (S_j, S_{j-1}, \\dots, S_i)$ 时，称该片段为回文。\n\nJOI 君通过以下操作构造回文：\n\n1. 首先，选择一个片段。设所选片段为 $T$。\n2. 将片段 $T$ 升序排序，得到 $T'$。\n3. 在数列 $S$ 中，将片段 $T$ 替换为 $T'$，得到新数列 $S'$。具体而言，若 JOI 君选择片段 $(i, j)$，则将 $S_i, S_{i+1}, \\dots, S_j$ 升序排序，得到 $T'_i \\le T'_{i+1} \\le \\dots \\le T'_j$，并令 $S' = (S_1, S_2, \\dots, S_{i-1}, T'_i, T'_{i+1}, \\dots, T'_j, S_{j+1}, \\dots, S_N)$。\n4. 然后，在 $S'$ 中寻找回文片段。\n\nJOI 君希望通过此操作构造尽可能长的回文。\n\n给定 JOI 君看到的字符串对应的数列 $S$，求 JOI 君能够构造出的回文的最大长度。", "inputFormat": "从标准输入读入以下数据：\n\n- 第一行包含两个整数 $N, C$，以空格分隔。$N$ 表示 JOI 君看到的字符串长度，$C$ 表示字符对应整数的上限。\n- 接下来的 $N$ 行，每行包含一个整数 $S_i$（$1 \\le i \\le N$），表示数列 $S$ 的第 $i$ 项。", "outputFormat": "在标准输出上，输出一个整数，表示 JOI 君能够构造出的回文的最大长度。", "hint": "### 样例 1 解释\n\n在该输入示例中，$N = 12$，$C = 26$，数列 $S = (26, 17, 17, 17, 1, 26, 1, 17, 19, 20, 1, 14)$。若对子串 $(4, 8)$ 进行升序排序，则得到 $S' = (26, 17, 17, 1, 1, 17, 17, 26, 19, 20, 1, 14)$，此时子串 $(1, 8)$ 构成回文。该回文的长度为 8，即为最长可能长度。\n\n### 样例 2 解释\n\n在该输入示例中，$S = (1, 2, 3, 2)$。若对片段 $(1, 1)$ 进行升序排序，则得到 $S' = (1, 2, 3, 2)$。此时 $S$ 与 $S'$ 相同。在 $S'$ 中，子串 $(2, 4)$ 构成回文。该回文的长度为 3，即为最长可能长度。\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le N \\le 3000$\n- $1 \\le C \\le 3000$\n- $1 \\le S_i \\le C$（$1 \\le i \\le N$）\n\n### 子任务\n\n#### 子任务 1 [10 分]\n\n满足以下条件：\n\n- $N \\le 50$\n- $C \\le 50$\n\n#### 子任务 2 [90 分]\n\n无额外限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2015] AAQQZ", "background": null, "description": "2015 年的国际信息学奥林匹克竞赛在哈萨克斯坦举行。哈萨克斯坦的“哈萨克”在字母表中可拼写为“QAZAQ”，这是一个回文。得知此事的 JOI 君对回文产生了兴趣，于是决定从他看到的文本中构造回文。\n\nJOI 君看到的是一个长度为 $N$ 的字符串。每个字符对应一个从 1 到 $C$ 的整数，将字符串的字符替换为整数后得到数列 $S = (S_1, S_2, \\dots, S_N)$。从数列 $S$ 的第 $i$ 项到第 $j$ 项（$1 \\le i \\le j \\le N$）取出的子序列 $(S_i, S_{i+1}, \\dots, S_j)$ 称为片段 $(i, j)$。若将片段 $(i, j)$ 前后翻转后和原来相等，即 $(S_i, S_{i+1}, \\dots, S_j) = (S_j, S_{j-1}, \\dots, S_i)$ 时，称该片段为回文。\n\nJOI 君通过以下操作构造回文：\n\n1. 首先，选择一个片段。设所选片段为 $T$。\n2. 将片段 $T$ 升序排序，得到 $T'$。\n3. 在数列 $S$ 中，将片段 $T$ 替换为 $T'$，得到新数列 $S'$。具体而言，若 JOI 君选择片段 $(i, j)$，则将 $S_i, S_{i+1}, \\dots, S_j$ 升序排序，得到 $T'_i \\le T'_{i+1} \\le \\dots \\le T'_j$，并令 $S' = (S_1, S_2, \\dots, S_{i-1}, T'_i, T'_{i+1}, \\dots, T'_j, S_{j+1}, \\dots, S_N)$。\n4. 然后，在 $S'$ 中寻找回文片段。\n\nJOI 君希望通过此操作构造尽可能长的回文。\n\n给定 JOI 君看到的字符串对应的数列 $S$，求 JOI 君能够构造出的回文的最大长度。", "inputFormat": "从标准输入读入以下数据：\n\n- 第一行包含两个整数 $N, C$，以空格分隔。$N$ 表示 JOI 君看到的字符串长度，$C$ 表示字符对应整数的上限。\n- 接下来的 $N$ 行，每行包含一个整数 $S_i$（$1 \\le i \\le N$），表示数列 $S$ 的第 $i$ 项。", "outputFormat": "在标准输出上，输出一个整数，表示 JOI 君能够构造出的回文的最大长度。", "hint": "### 样例 1 解释\n\n在该输入示例中，$N = 12$，$C = 26$，数列 $S = (26, 17, 17, 17, 1, 26, 1, 17, 19, 20, 1, 14)$。若对子串 $(4, 8)$ 进行升序排序，则得到 $S' = (26, 17, 17, 1, 1, 17, 17, 26, 19, 20, 1, 14)$，此时子串 $(1, 8)$ 构成回文。该回文的长度为 8，即为最长可能长度。\n\n### 样例 2 解释\n\n在该输入示例中，$S = (1, 2, 3, 2)$。若对片段 $(1, 1)$ 进行升序排序，则得到 $S' = (1, 2, 3, 2)$。此时 $S$ 与 $S'$ 相同。在 $S'$ 中，子串 $(2, 4)$ 构成回文。该回文的长度为 3，即为最长可能长度。\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le N \\le 3000$\n- $1 \\le C \\le 3000$\n- $1 \\le S_i \\le C$（$1 \\le i \\le N$）\n\n### 子任务\n\n#### 子任务 1 [10 分]\n\n满足以下条件：\n\n- $N \\le 50$\n- $C \\le 50$\n\n#### 子任务 2 [90 分]\n\n无额外限制。", "locale": "zh-CN"}}}
{"pid": "P14413", "type": "P", "difficulty": 5, "samples": [["5\n1 3 2\n4 2 9\n1 4 6\n2 3 3\n2 2 1", "15"], ["8\n11 5 31\n2 8 19\n2 9 2\n11 8 45\n4 8 22\n4 2 23\n6 9 58\n6 2 5\n", "160"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720, 1310720]}, "tags": ["动态规划 DP", "2015", "JOISC/JOIST（日本）"], "title": "[JOISC 2015] 有趣的卡牌游戏 / Card Game Is Great Fun", "background": null, "description": "安娜与朋友布鲁诺玩过卡牌游戏，但两人对双人游戏感到厌倦，于是她设计了一款可单人游玩的卡牌游戏。\n\n游戏开始时，有 $N$ 张不同颜色的卡牌排成一行，每张卡牌上写有一个整数。每张卡牌的颜色用整数表示，每张卡牌也有一个固定的价值。在游戏开始时，从队列前端起第 $i$ 张卡牌（$1 \\le i \\le N$）的颜色为 $C_i$，写在上面的整数为 $A_i$，其价值为 $V_i$。\n\n游戏通过从卡牌序列中逐张选取卡牌并将其加入牌堆来进行。初始时牌堆为空，从该状态开始，安娜重复以下操作：\n\n- **操作**：从卡牌序列的前端选择第 1 张或第 3 张卡牌。但若操作前牌堆中已有卡牌，则只能从序列中选择一张与牌堆最上方卡牌颜色相同，或写有相同整数的卡牌。选出的卡牌从序列中移除，并添加到牌堆的最上方。\n\n当无法再选择任何卡牌时，游戏结束。游戏结束时，牌堆中所有卡牌的价值之和即为安娜的得分。\n\n问：在此游戏中，安娜能够获得的最大得分是多少？\n\n### 题目\n\n给定游戏开始时排列的卡牌信息，编写程序求出安娜在该游戏中可能获得的最大得分。", "inputFormat": "从标准输入读入以下数据：\n\n- 第一行包含一个整数 $N$，表示游戏开始时排列的卡牌数量。\n- 接下来的 $N$ 行中，第 $i$ 行（$1 \\le i \\le N$）包含三个整数 $C_i, A_i, V_i$，以空格分隔。这表示在游戏开始时，从队列前端起第 $i$ 张卡牌的颜色为 $C_i$，写在上面的整数为 $A_i$，其价值为 $V_i$。", "outputFormat": "在标准输出上，输出一个整数，表示安娜在该游戏中能够获得的最大得分。", "hint": "### 样例 1 解释\n\n将颜色为 $c$、写有整数 $a$、价值为 $v$ 的卡牌记作 $(c, a, v)$。\n\n通过以下操作，安娜可以获得最大得分：\n\n1. 选取序列前端第 1 张卡牌 $(1, 3, 2)$，将其加入牌堆，获得 2 分。\n2. 选取序列前端第 3 张卡牌 $(2, 3, 3)$，将其加入牌堆，获得 3 分。\n3. 选取序列前端第 3 张卡牌 $(2, 2, 1)$，将其加入牌堆，获得 1 分。\n4. 选取序列前端第 1 张卡牌 $(4, 2, 9)$，将其加入牌堆，获得 9 分。\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le N \\le 500$\n- $1 \\le C_i \\le 500$（$1 \\le i \\le N$）\n- $1 \\le A_i \\le 500$（$1 \\le i \\le N$）\n- $1 \\le V_i \\le 1000000$（$1 \\le i \\le N$）\n\n### 子任务\n\n#### 子任务 1 [10 分]\n\n满足以下条件：\n\n- $N \\le 20$\n\n#### 子任务 2 [15 分]\n\n满足以下条件：\n\n- $N \\le 50$\n\n#### 子任务 3 [75 分]\n\n无额外限制。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2015] 有趣的卡牌游戏 / Card Game Is Great Fun", "background": null, "description": "安娜与朋友布鲁诺玩过卡牌游戏，但两人对双人游戏感到厌倦，于是她设计了一款可单人游玩的卡牌游戏。\n\n游戏开始时，有 $N$ 张不同颜色的卡牌排成一行，每张卡牌上写有一个整数。每张卡牌的颜色用整数表示，每张卡牌也有一个固定的价值。在游戏开始时，从队列前端起第 $i$ 张卡牌（$1 \\le i \\le N$）的颜色为 $C_i$，写在上面的整数为 $A_i$，其价值为 $V_i$。\n\n游戏通过从卡牌序列中逐张选取卡牌并将其加入牌堆来进行。初始时牌堆为空，从该状态开始，安娜重复以下操作：\n\n- **操作**：从卡牌序列的前端选择第 1 张或第 3 张卡牌。但若操作前牌堆中已有卡牌，则只能从序列中选择一张与牌堆最上方卡牌颜色相同，或写有相同整数的卡牌。选出的卡牌从序列中移除，并添加到牌堆的最上方。\n\n当无法再选择任何卡牌时，游戏结束。游戏结束时，牌堆中所有卡牌的价值之和即为安娜的得分。\n\n问：在此游戏中，安娜能够获得的最大得分是多少？\n\n### 题目\n\n给定游戏开始时排列的卡牌信息，编写程序求出安娜在该游戏中可能获得的最大得分。", "inputFormat": "从标准输入读入以下数据：\n\n- 第一行包含一个整数 $N$，表示游戏开始时排列的卡牌数量。\n- 接下来的 $N$ 行中，第 $i$ 行（$1 \\le i \\le N$）包含三个整数 $C_i, A_i, V_i$，以空格分隔。这表示在游戏开始时，从队列前端起第 $i$ 张卡牌的颜色为 $C_i$，写在上面的整数为 $A_i$，其价值为 $V_i$。", "outputFormat": "在标准输出上，输出一个整数，表示安娜在该游戏中能够获得的最大得分。", "hint": "### 样例 1 解释\n\n将颜色为 $c$、写有整数 $a$、价值为 $v$ 的卡牌记作 $(c, a, v)$。\n\n通过以下操作，安娜可以获得最大得分：\n\n1. 选取序列前端第 1 张卡牌 $(1, 3, 2)$，将其加入牌堆，获得 2 分。\n2. 选取序列前端第 3 张卡牌 $(2, 3, 3)$，将其加入牌堆，获得 3 分。\n3. 选取序列前端第 3 张卡牌 $(2, 2, 1)$，将其加入牌堆，获得 1 分。\n4. 选取序列前端第 1 张卡牌 $(4, 2, 9)$，将其加入牌堆，获得 9 分。\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le N \\le 500$\n- $1 \\le C_i \\le 500$（$1 \\le i \\le N$）\n- $1 \\le A_i \\le 500$（$1 \\le i \\le N$）\n- $1 \\le V_i \\le 1000000$（$1 \\le i \\le N$）\n\n### 子任务\n\n#### 子任务 1 [10 分]\n\n满足以下条件：\n\n- $N \\le 20$\n\n#### 子任务 2 [15 分]\n\n满足以下条件：\n\n- $N \\le 50$\n\n#### 子任务 3 [75 分]\n\n无额外限制。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN"}}}
{"pid": "P14415", "type": "P", "difficulty": 5, "samples": [["3 5 2\n1 2 3\n1 2 1\n2 3 4\n2 3 6\n1 3 2\n", "1\n0\n2\n1\n2"], ["3 6 5\n1 2 1\n1 2 2\n2 3 3\n2 3 4\n3 1 5\n3 1 6", "4\n3\n2\n1\n2\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "二分", "并查集", "生成树", "JOISC/JOIST（日本）"], "title": "[JOISC 2015] 遗产继承 / Inheritance", "background": "", "description": "IOI 国所有铁路的拥有者、大富豪 JOI 先生已经去世。根据遗嘱，铁路将被分割并继承。\n\nIOI 国有 $N$ 个城市，以及连接这些城市的 $M$ 条铁路。城市编号为 1 到 $N$，铁路编号为 1 到 $M$。第 $i$ 条铁路连接城市 $A_i$ 和城市 $B_i$，为双向线路，每年可产生 $C_i$ 日元的收益。由于乘客数量和票价各异，$C_1, \\dots, C_M$ 各不相同。可能存在多条铁路连接同一对城市。\n\n遗嘱中规定了铁路分割继承的方法如下：\n\n- 铁路将由 JOI 先生的 $K$ 个子女继承。子女按年龄从高到低依次编号为 1 到 $K$。\n- 每个子女继承若干条铁路（可能为 0 条）。\n- 首先，从 $M$ 条铁路中，子女 1 选择若干条作为自己的继承部分；接着，从剩余铁路中，子女 2 决定自己的继承部分；依此类推，$K$ 个子女依次决定继承部分。\n- 任何子女都不能继承已被更年长子女继承的铁路。即，若铁路 $i$ 已被子女 $j$ 继承，则任何更年轻的子女 $k$（$k > j$）均不能继承该铁路。\n- 任何子女在选择继承部分时，必须确保所选铁路不构成环路。即，若存在一条由铁路 $i_1, i_2, \\dots, i_m$（其中 $i_1, i_2, \\dots, i_m$ 互不相同）组成的路径，使得从某个城市出发，经过这些铁路后能返回原城市，则任何子女均不能独自继承所有这些铁路。\n- 未被任何子女继承的铁路将捐赠给 IOI 国。\n\n每个子女都像其父亲一样贪婪，希望自己的继承部分的年收益总和尽可能大。已证明，对于每个子女，存在唯一一种选择方式，使其继承部分的年收益总和达到最大值。请确定每条铁路由谁继承。\n\n### 题目\n\n给定 IOI 国铁路的信息和 JOI 先生子女的人数，编写程序求出每条铁路由谁继承。", "inputFormat": "从标准输入读取以下内容：\n\n- 第一行包含三个整数 $N, M, K$，以空格分隔。这表示 IOI 国有 $N$ 个城市和 $M$ 条铁路，JOI 先生有 $K$ 个子女。\n- 接下来的 $M$ 行中，第 $i$ 行（$1 \\le i \\le M$）包含三个整数 $A_i, B_i, C_i$，以空格分隔。这表示第 $i$ 条铁路连接城市 $A_i$ 和城市 $B_i$（双向），年收益为 $C_i$ 日元。\n", "outputFormat": "输出共 $M$ 行。第 $i$ 行（$1 \\le i \\le M$）输出继承第 $i$ 条铁路的子女编号。若该铁路被捐赠给 IOI 国，则输出 0。\n", "hint": "### 样例 1 解释\n\n- **子女 1** 从铁路 1, 2, 3, 4, 5 中选择铁路 1 和 4 进行继承。此时继承铁路的年收益总和为 $3 + 6 = 9$ 日元，这是最大值。\n- **子女 2** 从剩余铁路 2, 3, 5 中选择铁路 3 和 5 进行继承。此时继承铁路的年收益总和为 $4 + 2 = 6$ 日元，这是最大值。\n- 剩余铁路 2 将捐赠给 IOI 国。\n\n### 样例 2 解释\n\n继承铁路的数量可能因子女而异。可能存在完全没有继承任何铁路的子女。\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $2 \\le N \\le 1000$\n- $1 \\le M \\le 300000$\n- $1 \\le K \\le 10000$\n- $1 \\le A_i \\le N$, $1 \\le B_i \\le N$（$1 \\le i \\le M$）\n- $A_i \\ne B_i$（$1 \\le i \\le M$）\n- $1 \\le C_i \\le 1000000000$（$1 \\le i \\le M$）\n- $C_i \\ne C_j$（$1 \\le i < j \\le M$）\n\n### 子任务\n\n**子任务 1 [15 分]**\n\n- $K \\le 10$\n\n**子任务 2 [85 分]**\n\n无额外限制。\n\n翻译由 Qwen3-235B 完成\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2015] 遗产继承 / Inheritance", "background": "", "description": "IOI 国所有铁路的拥有者、大富豪 JOI 先生已经去世。根据遗嘱，铁路将被分割并继承。\n\nIOI 国有 $N$ 个城市，以及连接这些城市的 $M$ 条铁路。城市编号为 1 到 $N$，铁路编号为 1 到 $M$。第 $i$ 条铁路连接城市 $A_i$ 和城市 $B_i$，为双向线路，每年可产生 $C_i$ 日元的收益。由于乘客数量和票价各异，$C_1, \\dots, C_M$ 各不相同。可能存在多条铁路连接同一对城市。\n\n遗嘱中规定了铁路分割继承的方法如下：\n\n- 铁路将由 JOI 先生的 $K$ 个子女继承。子女按年龄从高到低依次编号为 1 到 $K$。\n- 每个子女继承若干条铁路（可能为 0 条）。\n- 首先，从 $M$ 条铁路中，子女 1 选择若干条作为自己的继承部分；接着，从剩余铁路中，子女 2 决定自己的继承部分；依此类推，$K$ 个子女依次决定继承部分。\n- 任何子女都不能继承已被更年长子女继承的铁路。即，若铁路 $i$ 已被子女 $j$ 继承，则任何更年轻的子女 $k$（$k > j$）均不能继承该铁路。\n- 任何子女在选择继承部分时，必须确保所选铁路不构成环路。即，若存在一条由铁路 $i_1, i_2, \\dots, i_m$（其中 $i_1, i_2, \\dots, i_m$ 互不相同）组成的路径，使得从某个城市出发，经过这些铁路后能返回原城市，则任何子女均不能独自继承所有这些铁路。\n- 未被任何子女继承的铁路将捐赠给 IOI 国。\n\n每个子女都像其父亲一样贪婪，希望自己的继承部分的年收益总和尽可能大。已证明，对于每个子女，存在唯一一种选择方式，使其继承部分的年收益总和达到最大值。请确定每条铁路由谁继承。\n\n### 题目\n\n给定 IOI 国铁路的信息和 JOI 先生子女的人数，编写程序求出每条铁路由谁继承。", "inputFormat": "从标准输入读取以下内容：\n\n- 第一行包含三个整数 $N, M, K$，以空格分隔。这表示 IOI 国有 $N$ 个城市和 $M$ 条铁路，JOI 先生有 $K$ 个子女。\n- 接下来的 $M$ 行中，第 $i$ 行（$1 \\le i \\le M$）包含三个整数 $A_i, B_i, C_i$，以空格分隔。这表示第 $i$ 条铁路连接城市 $A_i$ 和城市 $B_i$（双向），年收益为 $C_i$ 日元。\n", "outputFormat": "输出共 $M$ 行。第 $i$ 行（$1 \\le i \\le M$）输出继承第 $i$ 条铁路的子女编号。若该铁路被捐赠给 IOI 国，则输出 0。\n", "hint": "### 样例 1 解释\n\n- **子女 1** 从铁路 1, 2, 3, 4, 5 中选择铁路 1 和 4 进行继承。此时继承铁路的年收益总和为 $3 + 6 = 9$ 日元，这是最大值。\n- **子女 2** 从剩余铁路 2, 3, 5 中选择铁路 3 和 5 进行继承。此时继承铁路的年收益总和为 $4 + 2 = 6$ 日元，这是最大值。\n- 剩余铁路 2 将捐赠给 IOI 国。\n\n### 样例 2 解释\n\n继承铁路的数量可能因子女而异。可能存在完全没有继承任何铁路的子女。\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $2 \\le N \\le 1000$\n- $1 \\le M \\le 300000$\n- $1 \\le K \\le 10000$\n- $1 \\le A_i \\le N$, $1 \\le B_i \\le N$（$1 \\le i \\le M$）\n- $A_i \\ne B_i$（$1 \\le i \\le M$）\n- $1 \\le C_i \\le 1000000000$（$1 \\le i \\le M$）\n- $C_i \\ne C_j$（$1 \\le i < j \\le M$）\n\n### 子任务\n\n**子任务 1 [15 分]**\n\n- $K \\le 10$\n\n**子任务 2 [85 分]**\n\n无额外限制。\n\n翻译由 Qwen3-235B 完成\n", "locale": "zh-CN"}}}
{"pid": "P14416", "type": "P", "difficulty": 6, "samples": [["4 1\n<>[]", ""]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "交互题", "Special Judge", "JOISC/JOIST（日本）"], "title": "[JOISC 2015] 有限记忆 / Limited Memory", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/3005)", "description": "JOI 酱被选为了日本代表去参加国际信息学奥林匹克竞赛。为了提高信息处理速度，日本国际信息学奥林匹克竞赛委员会的 K 理事长提出了一个课题。\n\nK 理事长在纸上写下了一个字符串 $ S $，仅由 `<`，`>`，`[` 和 `]` 组成，但是 JOI 酱不知道字符串具体是什么。JOI 酱会被告知字符串的长度，他的课题是判断字符串 $ S $ 是不是一个合法字符串。合法字符串的定义如下：\n\n+ 空字符串（长度为 $ 0 $ 的字符串）是合法字符串。\n+ 假设 $ x $ 是一个合法字符串，那么 `<`$x$`>` 也是合法字符串。\n+ 假设 $ x $ 是一个合法字符串，那么 `[`$x$`]` 也是合法字符串。\n+ 假设 $ x $ 和 $ y $ 都是合法字符串，那么 $xy$ 也是合法字符串。\n\n例如 `<>[]` 和 `[<>]<>` 都是合法字符串，而 `><` 和 `[<]>` 都不是合法字符串。\n\n每天的中午，JOI 酱可以给 K 理事长打一个电话。电话里，JOI 酱可以指定一个整数 $ I $，K 理事长会告诉他字符串 $ S $ 的第 $ I $ 个字符。\n\n现在 JOI 酱有一个限制：不能用其它东西记录这个课题相关的笔记。JOI 酱每天晚上 $22$  点睡觉，早上 $6$ 点起床。在睡眠中，她只能在脑中记下 $ 22 $ 比特的信息。更准确的说，她会在睡前把一个 $0$ 到 $ 2^{22}-1 $ 的整数记在脑内，然后第二天醒来根据这个整数来做决策。由于字符串长度是一开始就被告知的，JOI 酱是一直知道这个信息的。\n\nJOI 酱每天睡前可以记住一个整数，或者发邮件告诉 K 理事长字符串 $ S $ 是不是一个合法字符串。在后者的情况下，这个课题就结束了，K 理事长会判定你是否完成了这个课题。注意，邮件必须在课题开始后 $ 15000 $ 天内发给 K 理事长，不然你就算没有完成这个课题。\n\n### 题目\n\n实现 JOI 酱的策略，编写一个程序，能够正确解决上述课题。\n\n### 实现细节\n\n你需要实现一个过程来确定字符串是否正确。你不需要引入外部头文件，但是你应当声明函数 `char Get(int I);`。\n\n程序需要实现以下过程。\n\n+ `int Memory(int N, int M)`\n  + 参数 $ N $ 表示字符串 $ S $ 的长度。\n  + 参数 $ M $ 表示上一天睡前记下的整数，在课题一开始的时候 $ M = 0 $。\n  + 在这个函数里必须恰好调用一次 `Get` 函数。\n  + 函数的返回值必须是一个 $ 0 $ 到 $ 2^{22} - 1 $ 的整数，或者 $ -1 $，或者 $ -2 $。如果返回值不在这些数里面，那么你的程序会被判为 `Wrong Answer [1]`。\n    + 返回值是 $ 0 $ 到 $ 2^{22} - 1 $ 的整数的话，表示这是睡前记下的数字。\n    + 返回值是 $ -1 $ 的话，表示用邮件回答 $ S $ 是一个合法字符串。\n    + 返回值是 $ -2 $ 的话，表示用邮件回答 $ S $ 不是一个合法字符串。\n  + 这个函数应该理论上只依赖 $ N $，$ M $ 和 `Get` 的返回值进行决策。在实际评测过程中这个函数会被调用 $ 2^{22} \\times 4$ 次，更详细的信息请参考「评分的顺序」。\n\n此外，程序中可以调用如下函数。\n\n+ `char Get(int I)`\n  + 这个函数只能在调用 `Memory` 函数的时候被调用一次，如果调用了不止一次，你的程序会被判为 `Wrong Answer [2]`。\n  + 参数 $ I $ 是一个 $ 1 $ 到 $ N $ 的整数，不满足此条件时，会被判为 `Wrong Answer [3]`。\n  + 返回值是 $ S $ 的第 $ I $ 个字符。\n\n### 评分的顺序\n\n每个测试文件会包含多组测试数据，每组测试数据对应的字符串 $ S $ 的长度 $ N $ 是一样的。评测过程如下，如果一旦被判定为了 `Wrong Answer`，你的程序会立刻被终止。\n\n+ 在给出参数 $ N $，$ M $ 和 `Get` 的返回值的情况下，检查函数 `Memory` 的行为。也就是说对于满足 $ 0 \\le M \\le 2^{22} - 1 $ 的整数 $ M $，做如下操作：\n  + 对于每个在 `<`，`>`，`[` 和 `]` 的字符 $c$，会执行如下操作：把 $ N $ 和 $ M $ 作为参数传给 `Memory` 函数，当 `Get` 被调用的时候，把 $c$ 返回出去。用 $ m(M, c) $ 表示函数 `Memory` 的返回值。\n  + 上述操作会调用 $ 4 $ 次 `Memory` 函数，需要检测 `Get` 的调用是否一致。如果 `Get` 被调用了，那么这 $ 4 $ 次传给 `Get` 的参数 `I` 必须一样。如果 `Get` 没有被调用，那么这 $ 4 $ 次 `Memory` 的返回值必须要一样。不满足此条件时，会被判为 `Wrong Answer [4]`。当 `Get` 被调用的时候，我们令 $ i(M) $ 表示 $ I $ 的值（如果没有被调用 $i(M)=1$）。\n\n+ 对于每组数组里的字符串 $ S $，如下操作会被用来模拟课题描述\n  + 一开始 $ M = 0 $。\n  + 重复执行如下操作：\n    + 令 $ c $ 是 $ S $ 的第 $ i(M) $ 个字符。\n    + 把 $ M $ 换为 $ m(M, c) $。\n    + $ M = -1 $ 或者 $ M = -2 $的情况下，跳出这个循环，进入下个流程。\n    + 如果循环了超过 $ 15000 $ 次，你的程序会被判为 `Wrong Answer [5]`。\n  + 如果是以下某个情况，你的程序会被判为 `Wrong Answer [6]`。\n    + $ S $ 是一个合法字符串，但是 $ M = -2 $。\n    + $ S $ 不是一个合法字符串，但是 $ M = -1 $。\n\n+ 你的程序被认为是正确的。\n\n### 编译与运行方法\n\n「附加文件」中提供了 `memory.h`、`grader-simple.c`、`grader-simple.cpp`、`grader-strict.c` 和 `grader-strict.cpp` 五个文件。若你编写的程序名称为 `memory.c` 或 `memory.cpp`，请运行以下命令来编译：\n\n+ C 语言： \n  + `gcc -std=c11 -O2 -o grader-simple grader-simple.c memory.c -lm`\n  + `gcc -std=c11 -O2 -o grader-strict grader-strict.c memory.c -lm`\n+ C++ 语言： \n  + `g++ -std=c++14 -O2 -o grader-simple grader-simple.cpp memory.cpp`\n  + `g++ -std=c++14 -O2 -o grader-strict grader-strict.cpp memory.cpp`\n\n当命令成功时，会产生一个可执行文件 `grader-simple` 或者 `grader-strict`。\n\n注意实际评测时的程序与下发的样例评测程序并不相同。实际的 `memory.h` 函数实现将通过标准输入/输出与单独运行的交互器进行交互。\n\n#### 样例程序评测概要\n\n`grader-simple` 不会模拟「评分的顺序」的第一步，但是会模拟课题的操作，具体可以参考「样例交互」。`grader-strict` 会严格按照「评分的顺序」执行。两者在输出上会有如下的不同：\n\n+ `grader-simple` 不会输出 `Wrong Answer [4]`，因为它并没有模拟这个操作\n+ `grader-simple` 和 `grader-strict` 不会输出 `Wrong Answer [6]`，但是会输出 $M$ 的值。", "inputFormat": "`grader-simple` 和 `grader-strict` 将从标准输入读入以下数据。\n\n+ 第一行包含两个整数 $ N $ 和 $ Q $ ($0 \\le Q \\le 2^{31} - 1$)，表示字符串 $ S $ 的长度和测试数据组数。\n+ 接下来 $ Q $ 行，每行包含一个长度为 $ N $ 的字符串 $ S $。", "outputFormat": "如果评测程序正常结束，`grader-simple` 和 `grader-strict` 将向标准输出输出以下信息。\n\n+ 程序正常结束的话，会输出 $ M $ 的值。\n+ 运行过程中被判为错误时，以 `Wrong Answer [x]` 的格式报告并退出。", "hint": "### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le S$ 的长度 $\\le 100$\n- $S$ 的每个字符是 '<', '>', '[', ']' 中的一个。\n\n### 子任务\n\n**子任务 1 [10 分]**\n\n- $1 \\le S$ 的长度 $\\le 8$\n\n**子任务 2 [10 分]**\n\n- $1 \\le S$ 的长度 $\\le 14$\n\n**子任务 3 [5 分]**\n\n- $1 \\le S$ 的长度 $\\le 24$\n\n**子任务 4 [5 分]**\n\n- $1 \\le S$ 的长度 $\\le 30$\n\n**子任务 5 [10 分]**\n\n- $S$ 的每个字符是 '<' 或 '>' 中的一个。\n\n**子任务 6 [60 分]**\n\n无额外限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2015] 有限记忆 / Limited Memory", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/3005)", "description": "JOI 酱被选为了日本代表去参加国际信息学奥林匹克竞赛。为了提高信息处理速度，日本国际信息学奥林匹克竞赛委员会的 K 理事长提出了一个课题。\n\nK 理事长在纸上写下了一个字符串 $ S $，仅由 `<`，`>`，`[` 和 `]` 组成，但是 JOI 酱不知道字符串具体是什么。JOI 酱会被告知字符串的长度，他的课题是判断字符串 $ S $ 是不是一个合法字符串。合法字符串的定义如下：\n\n+ 空字符串（长度为 $ 0 $ 的字符串）是合法字符串。\n+ 假设 $ x $ 是一个合法字符串，那么 `<`$x$`>` 也是合法字符串。\n+ 假设 $ x $ 是一个合法字符串，那么 `[`$x$`]` 也是合法字符串。\n+ 假设 $ x $ 和 $ y $ 都是合法字符串，那么 $xy$ 也是合法字符串。\n\n例如 `<>[]` 和 `[<>]<>` 都是合法字符串，而 `><` 和 `[<]>` 都不是合法字符串。\n\n每天的中午，JOI 酱可以给 K 理事长打一个电话。电话里，JOI 酱可以指定一个整数 $ I $，K 理事长会告诉他字符串 $ S $ 的第 $ I $ 个字符。\n\n现在 JOI 酱有一个限制：不能用其它东西记录这个课题相关的笔记。JOI 酱每天晚上 $22$  点睡觉，早上 $6$ 点起床。在睡眠中，她只能在脑中记下 $ 22 $ 比特的信息。更准确的说，她会在睡前把一个 $0$ 到 $ 2^{22}-1 $ 的整数记在脑内，然后第二天醒来根据这个整数来做决策。由于字符串长度是一开始就被告知的，JOI 酱是一直知道这个信息的。\n\nJOI 酱每天睡前可以记住一个整数，或者发邮件告诉 K 理事长字符串 $ S $ 是不是一个合法字符串。在后者的情况下，这个课题就结束了，K 理事长会判定你是否完成了这个课题。注意，邮件必须在课题开始后 $ 15000 $ 天内发给 K 理事长，不然你就算没有完成这个课题。\n\n### 题目\n\n实现 JOI 酱的策略，编写一个程序，能够正确解决上述课题。\n\n### 实现细节\n\n你需要实现一个过程来确定字符串是否正确。你不需要引入外部头文件，但是你应当声明函数 `char Get(int I);`。\n\n程序需要实现以下过程。\n\n+ `int Memory(int N, int M)`\n  + 参数 $ N $ 表示字符串 $ S $ 的长度。\n  + 参数 $ M $ 表示上一天睡前记下的整数，在课题一开始的时候 $ M = 0 $。\n  + 在这个函数里必须恰好调用一次 `Get` 函数。\n  + 函数的返回值必须是一个 $ 0 $ 到 $ 2^{22} - 1 $ 的整数，或者 $ -1 $，或者 $ -2 $。如果返回值不在这些数里面，那么你的程序会被判为 `Wrong Answer [1]`。\n    + 返回值是 $ 0 $ 到 $ 2^{22} - 1 $ 的整数的话，表示这是睡前记下的数字。\n    + 返回值是 $ -1 $ 的话，表示用邮件回答 $ S $ 是一个合法字符串。\n    + 返回值是 $ -2 $ 的话，表示用邮件回答 $ S $ 不是一个合法字符串。\n  + 这个函数应该理论上只依赖 $ N $，$ M $ 和 `Get` 的返回值进行决策。在实际评测过程中这个函数会被调用 $ 2^{22} \\times 4$ 次，更详细的信息请参考「评分的顺序」。\n\n此外，程序中可以调用如下函数。\n\n+ `char Get(int I)`\n  + 这个函数只能在调用 `Memory` 函数的时候被调用一次，如果调用了不止一次，你的程序会被判为 `Wrong Answer [2]`。\n  + 参数 $ I $ 是一个 $ 1 $ 到 $ N $ 的整数，不满足此条件时，会被判为 `Wrong Answer [3]`。\n  + 返回值是 $ S $ 的第 $ I $ 个字符。\n\n### 评分的顺序\n\n每个测试文件会包含多组测试数据，每组测试数据对应的字符串 $ S $ 的长度 $ N $ 是一样的。评测过程如下，如果一旦被判定为了 `Wrong Answer`，你的程序会立刻被终止。\n\n+ 在给出参数 $ N $，$ M $ 和 `Get` 的返回值的情况下，检查函数 `Memory` 的行为。也就是说对于满足 $ 0 \\le M \\le 2^{22} - 1 $ 的整数 $ M $，做如下操作：\n  + 对于每个在 `<`，`>`，`[` 和 `]` 的字符 $c$，会执行如下操作：把 $ N $ 和 $ M $ 作为参数传给 `Memory` 函数，当 `Get` 被调用的时候，把 $c$ 返回出去。用 $ m(M, c) $ 表示函数 `Memory` 的返回值。\n  + 上述操作会调用 $ 4 $ 次 `Memory` 函数，需要检测 `Get` 的调用是否一致。如果 `Get` 被调用了，那么这 $ 4 $ 次传给 `Get` 的参数 `I` 必须一样。如果 `Get` 没有被调用，那么这 $ 4 $ 次 `Memory` 的返回值必须要一样。不满足此条件时，会被判为 `Wrong Answer [4]`。当 `Get` 被调用的时候，我们令 $ i(M) $ 表示 $ I $ 的值（如果没有被调用 $i(M)=1$）。\n\n+ 对于每组数组里的字符串 $ S $，如下操作会被用来模拟课题描述\n  + 一开始 $ M = 0 $。\n  + 重复执行如下操作：\n    + 令 $ c $ 是 $ S $ 的第 $ i(M) $ 个字符。\n    + 把 $ M $ 换为 $ m(M, c) $。\n    + $ M = -1 $ 或者 $ M = -2 $的情况下，跳出这个循环，进入下个流程。\n    + 如果循环了超过 $ 15000 $ 次，你的程序会被判为 `Wrong Answer [5]`。\n  + 如果是以下某个情况，你的程序会被判为 `Wrong Answer [6]`。\n    + $ S $ 是一个合法字符串，但是 $ M = -2 $。\n    + $ S $ 不是一个合法字符串，但是 $ M = -1 $。\n\n+ 你的程序被认为是正确的。\n\n### 编译与运行方法\n\n「附加文件」中提供了 `memory.h`、`grader-simple.c`、`grader-simple.cpp`、`grader-strict.c` 和 `grader-strict.cpp` 五个文件。若你编写的程序名称为 `memory.c` 或 `memory.cpp`，请运行以下命令来编译：\n\n+ C 语言： \n  + `gcc -std=c11 -O2 -o grader-simple grader-simple.c memory.c -lm`\n  + `gcc -std=c11 -O2 -o grader-strict grader-strict.c memory.c -lm`\n+ C++ 语言： \n  + `g++ -std=c++14 -O2 -o grader-simple grader-simple.cpp memory.cpp`\n  + `g++ -std=c++14 -O2 -o grader-strict grader-strict.cpp memory.cpp`\n\n当命令成功时，会产生一个可执行文件 `grader-simple` 或者 `grader-strict`。\n\n注意实际评测时的程序与下发的样例评测程序并不相同。实际的 `memory.h` 函数实现将通过标准输入/输出与单独运行的交互器进行交互。\n\n#### 样例程序评测概要\n\n`grader-simple` 不会模拟「评分的顺序」的第一步，但是会模拟课题的操作，具体可以参考「样例交互」。`grader-strict` 会严格按照「评分的顺序」执行。两者在输出上会有如下的不同：\n\n+ `grader-simple` 不会输出 `Wrong Answer [4]`，因为它并没有模拟这个操作\n+ `grader-simple` 和 `grader-strict` 不会输出 `Wrong Answer [6]`，但是会输出 $M$ 的值。", "inputFormat": "`grader-simple` 和 `grader-strict` 将从标准输入读入以下数据。\n\n+ 第一行包含两个整数 $ N $ 和 $ Q $ ($0 \\le Q \\le 2^{31} - 1$)，表示字符串 $ S $ 的长度和测试数据组数。\n+ 接下来 $ Q $ 行，每行包含一个长度为 $ N $ 的字符串 $ S $。", "outputFormat": "如果评测程序正常结束，`grader-simple` 和 `grader-strict` 将向标准输出输出以下信息。\n\n+ 程序正常结束的话，会输出 $ M $ 的值。\n+ 运行过程中被判为错误时，以 `Wrong Answer [x]` 的格式报告并退出。", "hint": "### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le S$ 的长度 $\\le 100$\n- $S$ 的每个字符是 '<', '>', '[', ']' 中的一个。\n\n### 子任务\n\n**子任务 1 [10 分]**\n\n- $1 \\le S$ 的长度 $\\le 8$\n\n**子任务 2 [10 分]**\n\n- $1 \\le S$ 的长度 $\\le 14$\n\n**子任务 3 [5 分]**\n\n- $1 \\le S$ 的长度 $\\le 24$\n\n**子任务 4 [5 分]**\n\n- $1 \\le S$ 的长度 $\\le 30$\n\n**子任务 5 [10 分]**\n\n- $S$ 的每个字符是 '<' 或 '>' 中的一个。\n\n**子任务 6 [60 分]**\n\n无额外限制。", "locale": "zh-CN"}}}
{"pid": "P14417", "type": "P", "difficulty": 6, "samples": [["4 4\n0 3\n4 4\n2 7\n8 11\n6\n4\n3\n8", "5\n10\n1\n7"], ["7 11\n12 39\n22 23\n5 38\n6 47\n10 43\n0 50\n18 46\n38\n19\n15\n1\n12\n29\n29\n0\n6\n40\n6", "34\n178\n13\n6\n18\n0\n36"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "整体二分", "JOISC/JOIST（日本）"], "title": "[JOISC 2015] 防壁 / Walls", "background": "", "description": "你获得了 JOI 社开发的一款电视游戏软件。这是一款相当不错的游戏，你每天都在愉快地游玩。\n\n某天，游戏中出现了一个被称为“**激光**”的关卡。这个关卡极其困难，即使是优秀的玩家也只能以极低的概率通关。在多次挑战这个关卡的过程中，你意识到，如果能做出快速判断，或许就有机会通关，于是你开始思考编写程序来应对这个关卡。\n\n“激光”关卡的舞台是一个设置了 $N$ 个屏障的矩形区域。舞台被划分为 $1 \\times 1$ 的正方形格子，每个格子由非负整数 $x, y$ 表示为 $(x, y)$。其中 $(0, 0)$ 是左下角的格子，$(x, y)$ 表示从 $(0, 0)$ 向右移动 $x$ 格、向上移动 $y$ 格到达的格子。\n\n关卡开始时，敌人出现并发动攻击。敌人会连续发动 $M$ 次攻击。第 $j$ 次攻击时，敌人会从格子 $(P_j, N+1)$ 向格子 $(P_j, 0)$ 发射激光。\n\n每个屏障占据若干个 $y$ 坐标相同的格子，形成一个宽度为 $B_i - A_i + 1$、高度为 1 的长方形。屏障 $i$（$1 \\le i \\le N$）在关卡开始时占据从格子 $(A_i, i)$ 到格子 $(B_i, i)$ 的区域。在敌人第一次攻击前，以及每次攻击之间的间隙，你可以随时将任意一个屏障向左或向右移动一格。每次移动只能将一个屏障向右移动一格，或向左移动一格。\n\n激光碰到屏障时威力会减弱。通过移动屏障，使得激光碰到所有屏障，从而将激光的威力降至最低。\n\n你的目标是：在该关卡中，使屏障移动的总次数尽可能少。\n\n### 题目\n\n给定关卡开始时每个屏障的位置，以及每次敌人攻击的位置。当移动屏障使得激光碰到所有屏障时，求每个屏障移动次数的最小值。", "inputFormat": "从标准输入读取以下数据：\n\n- 第一行包含两个整数 $N$ 和 $M$，以空格分隔。这表示该关卡中有 $N$ 个屏障，敌人将发动 $M$ 次攻击。\n- 接下来的 $N$ 行中，第 $i$ 行（$1 \\le i \\le N$）包含两个整数 $A_i$ 和 $B_i$，以空格分隔。这表示在关卡开始时，屏障 $i$ 被放置在从格子 $(A_i, i)$ 到格子 $(B_i, i)$ 的位置。\n- 接下来的 $M$ 行中，第 $j$ 行（$1 \\le j \\le M$）包含一个整数 $P_j$。这表示在第 $j$ 次攻击时，敌人会从格子 $(P_j, N+1)$ 向格子 $(P_j, 0)$ 立即发射激光。\n", "outputFormat": "向标准输出输出 $N$ 行。第 $i$ 行（$1 \\le i \\le N$）输出屏障 $i$ 移动次数的最小值。\n", "hint": "### 样例 1 解释\n\n对于该输入，一种使屏障移动次数最小的移动方式如下：\n\n- 在第 1 次攻击前，将屏障 1 向右移动 3 次，屏障 2 向右移动 2 次，屏障 3 保持不动，屏障 4 向左移动 2 次。\n- 在第 2 次攻击前，屏障 1 保持不动，屏障 2 向左移动 2 次，屏障 3 保持不动，屏障 4 向左移动 2 次。\n- 在第 3 次攻击前，屏障 1 保持不动，屏障 2 向左移动 1 次，屏障 3 保持不动，屏障 4 向左移动 1 次。\n- 在第 4 次攻击前，屏障 1 向右移动 2 次，屏障 2 向右移动 5 次，屏障 3 向右移动 1 次，屏障 4 向右移动 2 次。\n\n按照这种移动方式，屏障 1 移动 5 次，屏障 2 移动 10 次，屏障 3 移动 1 次，屏障 4 移动 7 次。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/mp72luaf.png)\n\n图片来自于 [LibreOJ](https://loj.ac/p/3006)。\n:::\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le N \\le 200000$\n- $1 \\le M \\le 200000$\n- $0 \\le A_i \\le B_i \\le 1000000000$（$1 \\le i \\le N$）\n- $0 \\le P_j \\le 1000000000$（$1 \\le j \\le M$）\n\n### 子任务\n\n**子任务 1 [10 分]**\n\n- $N = 1$\n\n**子任务 2 [45 分]**\n\n- $A_i = 0$（$1 \\le i \\le N$）\n\n**子任务 3 [45 分]**\n\n无额外限制。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2015] 防壁 / Walls", "background": "", "description": "你获得了 JOI 社开发的一款电视游戏软件。这是一款相当不错的游戏，你每天都在愉快地游玩。\n\n某天，游戏中出现了一个被称为“**激光**”的关卡。这个关卡极其困难，即使是优秀的玩家也只能以极低的概率通关。在多次挑战这个关卡的过程中，你意识到，如果能做出快速判断，或许就有机会通关，于是你开始思考编写程序来应对这个关卡。\n\n“激光”关卡的舞台是一个设置了 $N$ 个屏障的矩形区域。舞台被划分为 $1 \\times 1$ 的正方形格子，每个格子由非负整数 $x, y$ 表示为 $(x, y)$。其中 $(0, 0)$ 是左下角的格子，$(x, y)$ 表示从 $(0, 0)$ 向右移动 $x$ 格、向上移动 $y$ 格到达的格子。\n\n关卡开始时，敌人出现并发动攻击。敌人会连续发动 $M$ 次攻击。第 $j$ 次攻击时，敌人会从格子 $(P_j, N+1)$ 向格子 $(P_j, 0)$ 发射激光。\n\n每个屏障占据若干个 $y$ 坐标相同的格子，形成一个宽度为 $B_i - A_i + 1$、高度为 1 的长方形。屏障 $i$（$1 \\le i \\le N$）在关卡开始时占据从格子 $(A_i, i)$ 到格子 $(B_i, i)$ 的区域。在敌人第一次攻击前，以及每次攻击之间的间隙，你可以随时将任意一个屏障向左或向右移动一格。每次移动只能将一个屏障向右移动一格，或向左移动一格。\n\n激光碰到屏障时威力会减弱。通过移动屏障，使得激光碰到所有屏障，从而将激光的威力降至最低。\n\n你的目标是：在该关卡中，使屏障移动的总次数尽可能少。\n\n### 题目\n\n给定关卡开始时每个屏障的位置，以及每次敌人攻击的位置。当移动屏障使得激光碰到所有屏障时，求每个屏障移动次数的最小值。", "inputFormat": "从标准输入读取以下数据：\n\n- 第一行包含两个整数 $N$ 和 $M$，以空格分隔。这表示该关卡中有 $N$ 个屏障，敌人将发动 $M$ 次攻击。\n- 接下来的 $N$ 行中，第 $i$ 行（$1 \\le i \\le N$）包含两个整数 $A_i$ 和 $B_i$，以空格分隔。这表示在关卡开始时，屏障 $i$ 被放置在从格子 $(A_i, i)$ 到格子 $(B_i, i)$ 的位置。\n- 接下来的 $M$ 行中，第 $j$ 行（$1 \\le j \\le M$）包含一个整数 $P_j$。这表示在第 $j$ 次攻击时，敌人会从格子 $(P_j, N+1)$ 向格子 $(P_j, 0)$ 立即发射激光。\n", "outputFormat": "向标准输出输出 $N$ 行。第 $i$ 行（$1 \\le i \\le N$）输出屏障 $i$ 移动次数的最小值。\n", "hint": "### 样例 1 解释\n\n对于该输入，一种使屏障移动次数最小的移动方式如下：\n\n- 在第 1 次攻击前，将屏障 1 向右移动 3 次，屏障 2 向右移动 2 次，屏障 3 保持不动，屏障 4 向左移动 2 次。\n- 在第 2 次攻击前，屏障 1 保持不动，屏障 2 向左移动 2 次，屏障 3 保持不动，屏障 4 向左移动 2 次。\n- 在第 3 次攻击前，屏障 1 保持不动，屏障 2 向左移动 1 次，屏障 3 保持不动，屏障 4 向左移动 1 次。\n- 在第 4 次攻击前，屏障 1 向右移动 2 次，屏障 2 向右移动 5 次，屏障 3 向右移动 1 次，屏障 4 向右移动 2 次。\n\n按照这种移动方式，屏障 1 移动 5 次，屏障 2 移动 10 次，屏障 3 移动 1 次，屏障 4 移动 7 次。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/mp72luaf.png)\n\n图片来自于 [LibreOJ](https://loj.ac/p/3006)。\n:::\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le N \\le 200000$\n- $1 \\le M \\le 200000$\n- $0 \\le A_i \\le B_i \\le 1000000000$（$1 \\le i \\le N$）\n- $0 \\le P_j \\le 1000000000$（$1 \\le j \\le M$）\n\n### 子任务\n\n**子任务 1 [10 分]**\n\n- $N = 1$\n\n**子任务 2 [45 分]**\n\n- $A_i = 0$（$1 \\le i \\le N$）\n\n**子任务 3 [45 分]**\n\n无额外限制。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN"}}}
{"pid": "P14418", "type": "P", "difficulty": 4, "samples": [["5 6\n1 2 10 25\n1 2 12 30\n2 5 26 50\n1 5 5 20\n1 4 30 40\n4 5 50 70\n4\n10\n30\n60\n100", "-1\n5\n10\n30"], ["3 8\n1 2 1 5\n1 3 0 1\n1 3 2 8\n2 3 2 3\n2 3 3 4\n2 3 4 5\n2 3 5 6\n2 3 6 7\n6\n3\n4\n5\n6\n7\n8", "0\n0\n0\n1\n1\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "2014", "JOISC/JOIST（日本）"], "title": "[JOISC 2014] 巴士走读 / Bus", "background": "", "description": "大学生 JOI 君乘坐公交车上下学。JOI 君的家和他所就读的大学都位于 IOI 市内。IOI 市共有 $N$ 个公交站，编号从 $1$ 到 $N$。JOI 君家最近的公交站是公交站 $1$，大学最近的公交站是公交站 $N$。\n\nIOI 市内运行的公交车共有 $M$ 辆，每辆公交车每天仅运行一次，按照预定时刻从指定的公交站出发，并在预定时刻到达指定的公交站。不存在每天多次运行的公交车。JOI 君在途中不能从一辆公交车换乘到另一辆公交车。\n\nJOI 君每天乘坐一辆或多辆公交车前往大学。JOI 君换乘公交车所需的时间可以忽略不计。换句话说，只要在某个时刻有公交车从当前所在的公交站出发，他就可以换乘该车，前提是该车的发车时刻或更早之前他已经到达该公交站。此外，他可以多次利用同一公交站。\n\n在上述条件下，JOI 君希望知道，每天从家出发后，是否能在上课前抵达大学。但大学每天第一节课的开始时间各不相同。已知在接下来的 $Q$ 天里，每天为了赶上第一节课，他最晚必须在公交站 $N$ 到达。对于每一天，JOI 君想知道，最晚何时必须从公交站 $1$ 出发，才能赶上当天的课程。\n\n**题目**\n\n给定公交车运行的相关信息，以及接下来 $Q$ 天中每天为了赶上课程必须到达公交站 $N$ 的最晚时间，对于每一天，求出 JOI 君最晚必须在何时从公交站 $1$ 出发才能赶上当天的课程。\n", "inputFormat": "从标准输入读取以下输入数据：\n\n- 第 $1$ 行包含两个整数 $N$ 和 $M$，以空格分隔，表示 IOI 市内共有 $N$ 个公交站，有 $M$ 辆公交车运行。\n- 接下来的 $M$ 行中，第 $i$ 行（$1 \\le i \\le M$）包含四个整数 $A_i$、$B_i$、$X_i$、$Y_i$（满足 $1 \\le A_i \\le N$，$1 \\le B_i \\le N$，$A_i \\ne B_i$），以空格分隔。这表示第 $i$ 辆公交车在时刻 $X_i$ 从公交站 $A_i$ 出发，在时刻 $Y_i$ 到达公交站 $B_i$。其中，时刻是以午夜 $0$ 点起经过的毫秒数表示的。\n- 下一行包含一个整数 $Q$，表示给出“必须在公交站 $N$ 到达”的日期共有 $Q$ 天。\n- 接下来的 $Q$ 行中，第 $j$ 行（$1 \\le j \\le Q$）包含一个整数 $L_j$，表示在第 $j$ 天，必须在时刻 $L_j$ 之前到达公交站 $N$。\n", "outputFormat": "向标准输出输出 $Q$ 行。第 $j$ 行（$1 \\le j \\le Q$）应输出一个整数，表示在第 $j$ 天，JOI 君最晚必须在何时到达公交站 $1$ 才能赶上当天的课程。如果无论如何都无法在上课前抵达大学，则输出 $-1$。", "hint": "### 样例 1 解释\n\n无法在时刻 $10$ 前到达公交站 $5$。\n\n为了在时刻 $30$ 前到达，只需在时刻 $5$ 乘坐第 $4$ 辆公交车。\n\n为了在时刻 $60$ 前到达，可以按以下方式操作：\n\n- 在时刻 $10$ 乘坐第 $1$ 辆公交车。\n- 在时刻 $25$ 到达公交站 $2$，等待 $1$ 毫秒后换乘第 $3$ 辆公交车。\n- 在时刻 $50$ 到达公交站 $5$。\n\n为了在时刻 $100$ 前到达，可以按以下方式操作：\n\n- 在时刻 $30$ 乘坐第 $5$ 辆公交车。\n- 在时刻 $40$ 到达公交站 $4$，等待 $10$ 毫秒后换乘第 $6$ 辆公交车。\n- 在时刻 $70$ 到达公交站 $5$。\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $2 \\le N \\le 100\\,000$。\n- $1 \\le M \\le 300\\,000$。\n- $0 \\le X_i < Y_i < 86\\,400\\,000\\ (= 24 \\times 60 \\times 60 \\times 1000)$（$1 \\le i \\le M$）。\n- $1 \\le Q \\le 100\\,000$。\n- $0 \\le L_j < 86\\,400\\,000\\ (= 24 \\times 60 \\times 60 \\times 1000)$（$1 \\le j \\le Q$）。\n\n### 子任务\n\n**子任务 1 [20 分]**\n\n满足以下条件：\n\n- $N \\le 2000$。\n- $M \\le 2000$。\n- $Q = 1$。\n\n**子任务 2 [15 分]**\n\n满足以下条件：\n\n- $N \\le 2000$。\n- $M \\le 2000$。\n\n**子任务 3 [15 分]**\n\n满足以下条件：\n\n- $Q = 1$。\n\n**子任务 4 [50 分]**\n\n无额外限制。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2014] 巴士走读 / Bus", "background": "", "description": "大学生 JOI 君乘坐公交车上下学。JOI 君的家和他所就读的大学都位于 IOI 市内。IOI 市共有 $N$ 个公交站，编号从 $1$ 到 $N$。JOI 君家最近的公交站是公交站 $1$，大学最近的公交站是公交站 $N$。\n\nIOI 市内运行的公交车共有 $M$ 辆，每辆公交车每天仅运行一次，按照预定时刻从指定的公交站出发，并在预定时刻到达指定的公交站。不存在每天多次运行的公交车。JOI 君在途中不能从一辆公交车换乘到另一辆公交车。\n\nJOI 君每天乘坐一辆或多辆公交车前往大学。JOI 君换乘公交车所需的时间可以忽略不计。换句话说，只要在某个时刻有公交车从当前所在的公交站出发，他就可以换乘该车，前提是该车的发车时刻或更早之前他已经到达该公交站。此外，他可以多次利用同一公交站。\n\n在上述条件下，JOI 君希望知道，每天从家出发后，是否能在上课前抵达大学。但大学每天第一节课的开始时间各不相同。已知在接下来的 $Q$ 天里，每天为了赶上第一节课，他最晚必须在公交站 $N$ 到达。对于每一天，JOI 君想知道，最晚何时必须从公交站 $1$ 出发，才能赶上当天的课程。\n\n**题目**\n\n给定公交车运行的相关信息，以及接下来 $Q$ 天中每天为了赶上课程必须到达公交站 $N$ 的最晚时间，对于每一天，求出 JOI 君最晚必须在何时从公交站 $1$ 出发才能赶上当天的课程。\n", "inputFormat": "从标准输入读取以下输入数据：\n\n- 第 $1$ 行包含两个整数 $N$ 和 $M$，以空格分隔，表示 IOI 市内共有 $N$ 个公交站，有 $M$ 辆公交车运行。\n- 接下来的 $M$ 行中，第 $i$ 行（$1 \\le i \\le M$）包含四个整数 $A_i$、$B_i$、$X_i$、$Y_i$（满足 $1 \\le A_i \\le N$，$1 \\le B_i \\le N$，$A_i \\ne B_i$），以空格分隔。这表示第 $i$ 辆公交车在时刻 $X_i$ 从公交站 $A_i$ 出发，在时刻 $Y_i$ 到达公交站 $B_i$。其中，时刻是以午夜 $0$ 点起经过的毫秒数表示的。\n- 下一行包含一个整数 $Q$，表示给出“必须在公交站 $N$ 到达”的日期共有 $Q$ 天。\n- 接下来的 $Q$ 行中，第 $j$ 行（$1 \\le j \\le Q$）包含一个整数 $L_j$，表示在第 $j$ 天，必须在时刻 $L_j$ 之前到达公交站 $N$。\n", "outputFormat": "向标准输出输出 $Q$ 行。第 $j$ 行（$1 \\le j \\le Q$）应输出一个整数，表示在第 $j$ 天，JOI 君最晚必须在何时到达公交站 $1$ 才能赶上当天的课程。如果无论如何都无法在上课前抵达大学，则输出 $-1$。", "hint": "### 样例 1 解释\n\n无法在时刻 $10$ 前到达公交站 $5$。\n\n为了在时刻 $30$ 前到达，只需在时刻 $5$ 乘坐第 $4$ 辆公交车。\n\n为了在时刻 $60$ 前到达，可以按以下方式操作：\n\n- 在时刻 $10$ 乘坐第 $1$ 辆公交车。\n- 在时刻 $25$ 到达公交站 $2$，等待 $1$ 毫秒后换乘第 $3$ 辆公交车。\n- 在时刻 $50$ 到达公交站 $5$。\n\n为了在时刻 $100$ 前到达，可以按以下方式操作：\n\n- 在时刻 $30$ 乘坐第 $5$ 辆公交车。\n- 在时刻 $40$ 到达公交站 $4$，等待 $10$ 毫秒后换乘第 $6$ 辆公交车。\n- 在时刻 $70$ 到达公交站 $5$。\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $2 \\le N \\le 100\\,000$。\n- $1 \\le M \\le 300\\,000$。\n- $0 \\le X_i < Y_i < 86\\,400\\,000\\ (= 24 \\times 60 \\times 60 \\times 1000)$（$1 \\le i \\le M$）。\n- $1 \\le Q \\le 100\\,000$。\n- $0 \\le L_j < 86\\,400\\,000\\ (= 24 \\times 60 \\times 60 \\times 1000)$（$1 \\le j \\le Q$）。\n\n### 子任务\n\n**子任务 1 [20 分]**\n\n满足以下条件：\n\n- $N \\le 2000$。\n- $M \\le 2000$。\n- $Q = 1$。\n\n**子任务 2 [15 分]**\n\n满足以下条件：\n\n- $N \\le 2000$。\n- $M \\le 2000$。\n\n**子任务 3 [15 分]**\n\n满足以下条件：\n\n- $Q = 1$。\n\n**子任务 4 [50 分]**\n\n无额外限制。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN"}}}
{"pid": "P14419", "type": "P", "difficulty": 4, "samples": [["6\n2\n8\n4\n5\n3\n6", "3"], ["5\n4\n4\n2\n4\n4", "2"], ["4\n1\n3\n4\n2", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "树状数组", "JOISC/JOIST（日本）"], "title": "[JOISC 2014] 有趣的家庭菜园 / Growing Vegetables is Fun", "background": "", "description": "热爱家庭园艺的 JOI 君每年都会在自家的田地里种植一种名为 IOI 草的植物。JOI 君的田地被划分为东西方向排列的 $N$ 个区域，从西侧开始依次编号为 $1$ 至 $N$。每块区域种植一株 IOI 草，共 $N$ 株。第 $i$ 块区域种植的 IOI 草在春季会长到高度 $h_i$，此后便不再生长。\n\n春天，JOI 君去查看田地时，发现 IOI 草的布局与预想不同。由于 IOI 草是喜光植物，若某块区域种植的 IOI 草，在编号比它小的区域或编号比它大的区域中，存在比它更高的 IOI 草，则该草会在夏季来临前枯萎。换言之，为了确保所有 IOI 草都不枯萎，必须满足以下条件：\n\n- 对于所有满足 $2 \\le i \\le N - 1$ 的整数 $i$，以下两个条件中至少有一个成立：\n  - 对于所有满足 $1 \\le j \\le i - 1$ 的整数 $j$，有 $h_j \\le h_i$。\n  - 对于所有满足 $i + 1 \\le k \\le N$ 的整数 $k$，有 $h_k \\le h_i$。\n\n由于 IOI 草价值昂贵，且植株高大、枝叶纤细，JOI 君一次只能交换相邻的两株 IOI 草。也就是说，一次操作中，JOI 君可任意选择区域 $i$（$1 \\le i \\le N - 1$），并交换区域 $i$ 和区域 $i + 1$ 的 IOI 草。由于夏季将至，枯萎风险升高，JOI 君希望知道使所有 IOI 草都不枯萎所需的最少操作次数。\n\n**问题**\n\n当给定 JOI 君田地的区域数量，以及每株 IOI 草的高度信息时，请编写程序，求出为使所有 IOI 草都不枯萎所需的最少交换次数。", "inputFormat": "从标准输入读取以下数据：\n\n- 第 $1$ 行包含一个整数 $N$，表示 JOI 君田地的区域数量。\n- 接下来的 $N$ 行包含关于 IOI 草高度的信息。其中第 $i$ 行（$1 \\le i \\le N$）包含一个整数 $D_i$，表示在区域 $i$ 种植的 IOI 草在春季时的高度。\n", "outputFormat": "向标准输出输出一行，包含一个整数，表示使所有 IOI 草都不枯萎所需的最少操作次数。\n", "hint": "### 样例 1 解释\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/a0pyjigx.png)\n\n配图来自 [LibreOJ](https://loj.ac/p/2873)\n:::\n\n### 数据范围\n\n所有输入数据均满足以下条件：\n\n- $3 \\le N \\le 300000$。\n- $1 \\le D_i \\le 1000000000$。\n\n### 子任务\n\n**子任务 1 [10 分]**\n\n- 满足 $N \\le 8$。\n\n**子任务 2 [20 分]**\n\n- 满足 $N \\le 20$。\n\n**子任务 3 [15 分]**\n\n- 满足 $N \\le 5000$。\n\n**子任务 4 [55 分]**\n\n无额外限制。\n\n翻译由 Qwen3-235B 完成\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2014] 有趣的家庭菜园 / Growing Vegetables is Fun", "background": "", "description": "热爱家庭园艺的 JOI 君每年都会在自家的田地里种植一种名为 IOI 草的植物。JOI 君的田地被划分为东西方向排列的 $N$ 个区域，从西侧开始依次编号为 $1$ 至 $N$。每块区域种植一株 IOI 草，共 $N$ 株。第 $i$ 块区域种植的 IOI 草在春季会长到高度 $h_i$，此后便不再生长。\n\n春天，JOI 君去查看田地时，发现 IOI 草的布局与预想不同。由于 IOI 草是喜光植物，若某块区域种植的 IOI 草，在编号比它小的区域或编号比它大的区域中，存在比它更高的 IOI 草，则该草会在夏季来临前枯萎。换言之，为了确保所有 IOI 草都不枯萎，必须满足以下条件：\n\n- 对于所有满足 $2 \\le i \\le N - 1$ 的整数 $i$，以下两个条件中至少有一个成立：\n  - 对于所有满足 $1 \\le j \\le i - 1$ 的整数 $j$，有 $h_j \\le h_i$。\n  - 对于所有满足 $i + 1 \\le k \\le N$ 的整数 $k$，有 $h_k \\le h_i$。\n\n由于 IOI 草价值昂贵，且植株高大、枝叶纤细，JOI 君一次只能交换相邻的两株 IOI 草。也就是说，一次操作中，JOI 君可任意选择区域 $i$（$1 \\le i \\le N - 1$），并交换区域 $i$ 和区域 $i + 1$ 的 IOI 草。由于夏季将至，枯萎风险升高，JOI 君希望知道使所有 IOI 草都不枯萎所需的最少操作次数。\n\n**问题**\n\n当给定 JOI 君田地的区域数量，以及每株 IOI 草的高度信息时，请编写程序，求出为使所有 IOI 草都不枯萎所需的最少交换次数。", "inputFormat": "从标准输入读取以下数据：\n\n- 第 $1$ 行包含一个整数 $N$，表示 JOI 君田地的区域数量。\n- 接下来的 $N$ 行包含关于 IOI 草高度的信息。其中第 $i$ 行（$1 \\le i \\le N$）包含一个整数 $D_i$，表示在区域 $i$ 种植的 IOI 草在春季时的高度。\n", "outputFormat": "向标准输出输出一行，包含一个整数，表示使所有 IOI 草都不枯萎所需的最少操作次数。\n", "hint": "### 样例 1 解释\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/a0pyjigx.png)\n\n配图来自 [LibreOJ](https://loj.ac/p/2873)\n:::\n\n### 数据范围\n\n所有输入数据均满足以下条件：\n\n- $3 \\le N \\le 300000$。\n- $1 \\le D_i \\le 1000000000$。\n\n### 子任务\n\n**子任务 1 [10 分]**\n\n- 满足 $N \\le 8$。\n\n**子任务 2 [20 分]**\n\n- 满足 $N \\le 20$。\n\n**子任务 3 [15 分]**\n\n- 满足 $N \\le 5000$。\n\n**子任务 4 [55 分]**\n\n无额外限制。\n\n翻译由 Qwen3-235B 完成\n", "locale": "zh-CN"}}}
{"pid": "P14420", "type": "P", "difficulty": 6, "samples": [["5 5\n9 8 7 8 9\n1 2\n3 4\n4 4\n1 4\n2 4", "9\n8\n8\n16\n16"], ["8 4\n9 9 19 9 9 15 9 19\n1 4\n4 6\n3 5\n5 8", "27\n18\n19\n19"], ["12 15\n15 9 3 15 9 3 3 8 16 9 3 17\n2 7\n2 5\n2 2\n1 12\n4 12\n3 6\n11 12\n1 7\n2 6\n3 5\n3 10\n7 10\n1 4\n4 8\n4 8", "18\n18\n9\n30\n18\n15\n17\n30\n18\n15\n18\n16\n30\n15\n15"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "莫队", "JOISC/JOIST（日本）"], "title": "[JOISC 2014] 历史的研究 / Historical Research", "background": "", "description": "作为研究 IOI 国历史的先驱者，乔伊教授获得了一本据称由古代 IOI 国居民所写的日记。乔伊教授计划通过分析这本日记来研究古代 IOI 国的生活，因此决定调查日记中记录的事件。\n\n日记中记录了连续 $N$ 天内每天发生的事件，每个事件被分类为若干种类型之一。第 $i$ 天（$1 \\le i \\le N$）发生的事件类型由整数 $X_i$ 表示，$X_i$ 的值越大，表示该事件的规模越大。\n\n乔伊教授决定按以下方法分析日记：\n\n1. 从日记的 $N$ 天中选择一个连续的若干天作为分析区间。\n2. 对于事件类型 $t$，其“重要度”定义为 $t \\times$（该区间内类型 $t$ 的事件数量）。\n3. 对所有事件类型分别计算重要度，并求出其中的最大值。\n\n你被乔伊教授委派编写一个用于分析的程序。该程序需在给定分析区间的情况下，能够求出重要度的最大值。\n\n**问题**\n\n当给定日记中 $N$ 天内每天的事件类型，以及表示日记中区间的 $Q$ 个查询时，请编写程序，对每个查询求出对应区间内事件重要度的最大值。", "inputFormat": "从标准输入读取以下数据：\n\n- 第 $1$ 行包含两个整数 $N$ 和 $Q$，以空格分隔。这表示日记共有 $N$ 天，且给出 $Q$ 个查询。\n- 下一行包含 $N$ 个整数 $X_1, \\dots, X_N$，以空格分隔，其中 $X_i$（$1 \\le i \\le N$）表示第 $i$ 天发生的事件类型。\n- 接下来的 $Q$ 行中，第 $j$ 行（$1 \\le j \\le Q$）包含两个整数 $A_j$ 和 $B_j$（$1 \\le A_j \\le B_j \\le N$），以空格分隔，表示第 $j$ 个查询对应的区间为从第 $A_j$ 天到第 $B_j$ 天。\n", "outputFormat": "向标准输出输出 $Q$ 行。第 $j$ 行（$1 \\le j \\le Q$）输出一个整数，表示第 $j$ 个查询对应区间内事件重要度的最大值。\n", "hint": "### 样例 1 解释\n\n- 此日记共持续 5 天，日记中记录的事件类型仅为 7、8、9 之一。\n- 从第 1 天到第 2 天，事件类型 7 的重要度为 $7 \\times 0 = 0$，事件类型 8 的重要度为 $8 \\times 1 = 8$，事件类型 9 的重要度为 $9 \\times 1 = 9$，因此三者中的最大值为 9。\n- 从第 3 天到第 4 天，事件类型 7 的重要度为 $7 \\times 1 = 7$，事件类型 8 的重要度为 $8 \\times 1 = 8$，事件类型 9 的重要度为 $9 \\times 0 = 0$，因此三者中的最大值为 8。\n- 在第 4 天，事件类型 7 的重要度为 $7 \\times 0 = 0$，事件类型 8 的重要度为 $8 \\times 1 = 8$，事件类型 9 的重要度为 $9 \\times 0 = 0$，因此三者中的最大值为 8。\n- 从第 1 天到第 4 天，事件类型 7 的重要度为 $7 \\times 1 = 7$，事件类型 8 的重要度为 $8 \\times 2 = 16$，事件类型 9 的重要度为 $9 \\times 1 = 9$，因此三者中的最大值为 16。\n- 从第 2 天到第 4 天，事件类型 7 的重要度为 $7 \\times 1 = 7$，事件类型 8 的重要度为 $8 \\times 2 = 16$，事件类型 9 的重要度为 $9 \\times 0 = 0$，因此三者中的最大值为 16。\n\n### 限制\n\n所有输入数据均满足以下条件：\n\n- $1 \\le N \\le 100000$。\n- $1 \\le Q \\le 100000$。\n- $1 \\le X_i \\le 1000000000$（$1 \\le i \\le N$）。\n\n### 子任务\n\n**子任务 1 [5 分]**\n\n满足以下条件：\n\n- $N \\le 100$。\n- $Q \\le 100$。\n\n**子任务 2 [10 分]**\n\n满足以下条件：\n\n- $N \\le 5000$。\n- $Q \\le 5000$。\n\n**子任务 3 [25 分]**\n\n不存在满足 $A_i \\le A_j \\le B_j \\le B_i$ 的 $i, j$（其中 $1 \\le i \\le Q$，$1 \\le j \\le Q$，且 $i \\ne j$）。\n\n**子任务 4 [60 分]**\n\n无额外限制。\n\n翻译由 Qwen3-235B 完成\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2014] 历史的研究 / Historical Research", "background": "", "description": "作为研究 IOI 国历史的先驱者，乔伊教授获得了一本据称由古代 IOI 国居民所写的日记。乔伊教授计划通过分析这本日记来研究古代 IOI 国的生活，因此决定调查日记中记录的事件。\n\n日记中记录了连续 $N$ 天内每天发生的事件，每个事件被分类为若干种类型之一。第 $i$ 天（$1 \\le i \\le N$）发生的事件类型由整数 $X_i$ 表示，$X_i$ 的值越大，表示该事件的规模越大。\n\n乔伊教授决定按以下方法分析日记：\n\n1. 从日记的 $N$ 天中选择一个连续的若干天作为分析区间。\n2. 对于事件类型 $t$，其“重要度”定义为 $t \\times$（该区间内类型 $t$ 的事件数量）。\n3. 对所有事件类型分别计算重要度，并求出其中的最大值。\n\n你被乔伊教授委派编写一个用于分析的程序。该程序需在给定分析区间的情况下，能够求出重要度的最大值。\n\n**问题**\n\n当给定日记中 $N$ 天内每天的事件类型，以及表示日记中区间的 $Q$ 个查询时，请编写程序，对每个查询求出对应区间内事件重要度的最大值。", "inputFormat": "从标准输入读取以下数据：\n\n- 第 $1$ 行包含两个整数 $N$ 和 $Q$，以空格分隔。这表示日记共有 $N$ 天，且给出 $Q$ 个查询。\n- 下一行包含 $N$ 个整数 $X_1, \\dots, X_N$，以空格分隔，其中 $X_i$（$1 \\le i \\le N$）表示第 $i$ 天发生的事件类型。\n- 接下来的 $Q$ 行中，第 $j$ 行（$1 \\le j \\le Q$）包含两个整数 $A_j$ 和 $B_j$（$1 \\le A_j \\le B_j \\le N$），以空格分隔，表示第 $j$ 个查询对应的区间为从第 $A_j$ 天到第 $B_j$ 天。\n", "outputFormat": "向标准输出输出 $Q$ 行。第 $j$ 行（$1 \\le j \\le Q$）输出一个整数，表示第 $j$ 个查询对应区间内事件重要度的最大值。\n", "hint": "### 样例 1 解释\n\n- 此日记共持续 5 天，日记中记录的事件类型仅为 7、8、9 之一。\n- 从第 1 天到第 2 天，事件类型 7 的重要度为 $7 \\times 0 = 0$，事件类型 8 的重要度为 $8 \\times 1 = 8$，事件类型 9 的重要度为 $9 \\times 1 = 9$，因此三者中的最大值为 9。\n- 从第 3 天到第 4 天，事件类型 7 的重要度为 $7 \\times 1 = 7$，事件类型 8 的重要度为 $8 \\times 1 = 8$，事件类型 9 的重要度为 $9 \\times 0 = 0$，因此三者中的最大值为 8。\n- 在第 4 天，事件类型 7 的重要度为 $7 \\times 0 = 0$，事件类型 8 的重要度为 $8 \\times 1 = 8$，事件类型 9 的重要度为 $9 \\times 0 = 0$，因此三者中的最大值为 8。\n- 从第 1 天到第 4 天，事件类型 7 的重要度为 $7 \\times 1 = 7$，事件类型 8 的重要度为 $8 \\times 2 = 16$，事件类型 9 的重要度为 $9 \\times 1 = 9$，因此三者中的最大值为 16。\n- 从第 2 天到第 4 天，事件类型 7 的重要度为 $7 \\times 1 = 7$，事件类型 8 的重要度为 $8 \\times 2 = 16$，事件类型 9 的重要度为 $9 \\times 0 = 0$，因此三者中的最大值为 16。\n\n### 限制\n\n所有输入数据均满足以下条件：\n\n- $1 \\le N \\le 100000$。\n- $1 \\le Q \\le 100000$。\n- $1 \\le X_i \\le 1000000000$（$1 \\le i \\le N$）。\n\n### 子任务\n\n**子任务 1 [5 分]**\n\n满足以下条件：\n\n- $N \\le 100$。\n- $Q \\le 100$。\n\n**子任务 2 [10 分]**\n\n满足以下条件：\n\n- $N \\le 5000$。\n- $Q \\le 5000$。\n\n**子任务 3 [25 分]**\n\n不存在满足 $A_i \\le A_j \\le B_j \\le B_i$ 的 $i, j$（其中 $1 \\le i \\le Q$，$1 \\le j \\le Q$，且 $i \\ne j$）。\n\n**子任务 4 [60 分]**\n\n无额外限制。\n\n翻译由 Qwen3-235B 完成\n", "locale": "zh-CN"}}}
{"pid": "P14421", "type": "P", "difficulty": 3, "samples": [["3 1\n1\n2\n0", ""]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "交互题", "Special Judge", "JOISC/JOIST（日本）"], "title": "[JOISC 2014] 拉面比较 / Ramen", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/2875)。", "description": "**题目译自 JOISC 2014 Day1 T4「[ラーメンの食べ比べ](https://www.ioi-jp.org/camp/2014/2014-sp-tasks/2014-sp-d1.pdf)」**\n\nJOI 君和 IOI 酱都喜欢吃拉面。JOI 君喜欢吃清汤拉面，而 IOI 酱喜欢吃浓汤拉面，在 JOI 君和 IOI 酱居住的城镇里，共有 $N$ 家拉面馆，编号为 $0$ 到 $N-1$。\n\n我们不知道每家拉面馆卖的是清汤拉面还是浓汤拉面，因此，JOI 君和 IOI 酱决定去附近的一些拉面馆寻找最好吃的清汤和浓汤拉面。\n\nJOI 君和 IOI 酱到附近的拉面馆，分别确定两家拉面馆拉面的**浓厚度**，浓厚度是一个大于等于 $0$ 小于等于 $N-1$ 的整数，每家面馆拉面的浓厚度两两不同。JOI 君和 IOI 酱每天每人去一家拉面馆，通过品尝味道，可以比较出两家拉面馆哪一家浓厚度更高。\n\n出于健康因素考虑，JOI 君和 IOI 酱最多吃 $600$ 天拉面。\n\n给出城镇里拉面馆数 $N$，在最多吃 $600$ 天拉面的情况下，确定浓厚度最高的拉面馆和浓厚度最低的拉面馆。\n\n### 实现细节\n\n你需要实现一个程序，在给出城镇里拉面馆数 $N$，在最多吃 $600$ 天拉面的情况下，确定浓厚度最高的拉面馆和浓厚度最低的拉面馆。\n\n~~该程序必须在开头引入库 `ramen.h`。~~\n\n该程序不应引入任何外部头文件，需要声明定义以下两个函数：\n\n```cpp\nint Compare(int X, int Y);\nvoid Answer(int X, int Y);\n```\n\n该程序必须实现以下过程：\n\n```c\nvoid Ramen(int N)\n```\n  - 对于每个测试用例，该函数仅调用一次，参数 $N$ 是城镇上拉面馆的数量；\n  - 只允许通过调用 `Compare` 函数确定两家店浓厚度的大小关系，只允许通过调用 `Answer` 函数给出浓厚度最高的拉面馆和浓厚度最低的拉面馆。\n\n可以在程序中调用以下函数：\n```c\nint Compare(int X, int Y)\n```\n  - 在比较两家面馆 $\\texttt{X,Y}$ 的浓厚度时调用此函数，$\\texttt{X,Y}$ 是大于等于 $0$ 且小于等于 $N-1$ 的整数，如果不满足以上条件，会被判为 **Wrong Answer [1]**，程序结束；\n  - 如果拉面馆 $\\texttt{X}$ 的浓厚度大于 $\\texttt{Y}$，则函数返回 $1$，否则返回 $-1$；\n  - 如果 `Compare` 函数调用次数超过 $600$，会被判为 **Wrong Answer [2]**，程序结束。\n\n`Ramen` 函数必须调用 `Answer` 函数来结束，如果 `Ramen` 没有调用 `Answer`，会被判为 **Wrong Answer [3]**。\n\n```c\nvoid Answer(int X, int Y)\n```\n  - 这个函数用来回答哪家拉面馆的浓厚度最低与哪家拉面馆浓厚度最高。参数 $\\texttt{X}$ 表示拉面馆 $\\texttt{X}$ 的浓厚度最低，参数 $\\texttt{Y}$ 表示拉面馆 $\\texttt{Y}$ 的浓厚度最高。$\\texttt{X,Y}$ 都大于等于 $0$ 且小于等于 $N-1$，如果不满足条件会被判为 **Wrong Answer [4]**；\n  - 可以保证，与调用 `Compare` 的结果一致的答案是唯一的，如果 $\\texttt{X,Y}$ 与答案不一致，则会被判为 **Wrong Answer [5]**，一致则会被判为 **Accepted**；\n  - 调用此函数后，程序结束。\n\n### 注意\n\n在评分时，只要你的回答与调用 `Compare` 的结果不一致，都会被判为 **Wrong Answer [5]**。\n\n在评分时，一些测试点可能会根据之前 `Compare` 的调用情况修改返回值，但是 `Compare` 的返回值与之前 `Compare` 的调用结果不矛盾。\n\n### 编译与运行方法\n\n「附加文件」中提供了 `ramen.h`、`grader.c` 和 `grader.cpp` 三个文件。若你编写的程序名称为 `ramen.c` 或 `ramen.cpp`，请运行以下命令来编译：\n* C 语言\n```sh\ngcc -O2 -lm -o grader grader.c ramen.c\n```\n* C++ 语言\n```sh\ng++ -O2 -o grader grader.cpp ramen.cpp\n```\n\n当命令成功时，会产生一个可执行文件 `grader`。\n\n注意实际评测时的程序与下发的样例评测程序并不相同。实际的 `ramen.h` 函数实现将通过标准输入/输出与单独运行的交互器进行交互。", "inputFormat": "样例评测程序将从标准输入读入以下数据：\n- 第一行两个整数 $N,T$，用一个空格隔开。$N$ 表示拉面馆数，评测程序只会处理 $T=1$ 的数据；\n- 接下来 $N$ 行，第 $i+1$ 行表示拉面馆 $i$ 的浓厚度 $A_i$。", "outputFormat": "样例评测程序将向标准输出输出以下信息。\n\n* 判为正确时，输出 `Accepted`；\n* 运行过程中被判为错误时，以 `Wrong Answer [x]` 的格式报告并退出。\n\n程序执行过程中违反了多种限制时，只会报告其中的一种。\n\n注意，如果样例中 $A_X=0,A_Y=N-1$，调用了 `Answer(X, Y)`，即使应当是 **Wrong Answer [5]** 的情况，测评程序也会判定 **Accepted**。请注意，下发的 `grader` 与实际测评时使用的不同。", "hint": "### 样例交互\n|调用函数|返回值|\n|:-:|:-:|\n|`Compare(0, 1)`|-1|\n|`Compare(0, 2)`|1|\n|`Answer(2, 1)`|测评程序结束|\n\n对于全部数据，$1\\le N\\le 400$。\n\n详细子任务分数与附加限制见下表。\n\n|Subtask|附加限制|分数|\n|:-:|:-:|:-:|\n|$1$|$N\\le 30$|$20$|\n|$2$|$N\\le 300$|$30$|\n|$3$|无附加限制|$50$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2014] 拉面比较 / Ramen", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/2875)。", "description": "**题目译自 JOISC 2014 Day1 T4「[ラーメンの食べ比べ](https://www.ioi-jp.org/camp/2014/2014-sp-tasks/2014-sp-d1.pdf)」**\n\nJOI 君和 IOI 酱都喜欢吃拉面。JOI 君喜欢吃清汤拉面，而 IOI 酱喜欢吃浓汤拉面，在 JOI 君和 IOI 酱居住的城镇里，共有 $N$ 家拉面馆，编号为 $0$ 到 $N-1$。\n\n我们不知道每家拉面馆卖的是清汤拉面还是浓汤拉面，因此，JOI 君和 IOI 酱决定去附近的一些拉面馆寻找最好吃的清汤和浓汤拉面。\n\nJOI 君和 IOI 酱到附近的拉面馆，分别确定两家拉面馆拉面的**浓厚度**，浓厚度是一个大于等于 $0$ 小于等于 $N-1$ 的整数，每家面馆拉面的浓厚度两两不同。JOI 君和 IOI 酱每天每人去一家拉面馆，通过品尝味道，可以比较出两家拉面馆哪一家浓厚度更高。\n\n出于健康因素考虑，JOI 君和 IOI 酱最多吃 $600$ 天拉面。\n\n给出城镇里拉面馆数 $N$，在最多吃 $600$ 天拉面的情况下，确定浓厚度最高的拉面馆和浓厚度最低的拉面馆。\n\n### 实现细节\n\n你需要实现一个程序，在给出城镇里拉面馆数 $N$，在最多吃 $600$ 天拉面的情况下，确定浓厚度最高的拉面馆和浓厚度最低的拉面馆。\n\n~~该程序必须在开头引入库 `ramen.h`。~~\n\n该程序不应引入任何外部头文件，需要声明定义以下两个函数：\n\n```cpp\nint Compare(int X, int Y);\nvoid Answer(int X, int Y);\n```\n\n该程序必须实现以下过程：\n\n```c\nvoid Ramen(int N)\n```\n  - 对于每个测试用例，该函数仅调用一次，参数 $N$ 是城镇上拉面馆的数量；\n  - 只允许通过调用 `Compare` 函数确定两家店浓厚度的大小关系，只允许通过调用 `Answer` 函数给出浓厚度最高的拉面馆和浓厚度最低的拉面馆。\n\n可以在程序中调用以下函数：\n```c\nint Compare(int X, int Y)\n```\n  - 在比较两家面馆 $\\texttt{X,Y}$ 的浓厚度时调用此函数，$\\texttt{X,Y}$ 是大于等于 $0$ 且小于等于 $N-1$ 的整数，如果不满足以上条件，会被判为 **Wrong Answer [1]**，程序结束；\n  - 如果拉面馆 $\\texttt{X}$ 的浓厚度大于 $\\texttt{Y}$，则函数返回 $1$，否则返回 $-1$；\n  - 如果 `Compare` 函数调用次数超过 $600$，会被判为 **Wrong Answer [2]**，程序结束。\n\n`Ramen` 函数必须调用 `Answer` 函数来结束，如果 `Ramen` 没有调用 `Answer`，会被判为 **Wrong Answer [3]**。\n\n```c\nvoid Answer(int X, int Y)\n```\n  - 这个函数用来回答哪家拉面馆的浓厚度最低与哪家拉面馆浓厚度最高。参数 $\\texttt{X}$ 表示拉面馆 $\\texttt{X}$ 的浓厚度最低，参数 $\\texttt{Y}$ 表示拉面馆 $\\texttt{Y}$ 的浓厚度最高。$\\texttt{X,Y}$ 都大于等于 $0$ 且小于等于 $N-1$，如果不满足条件会被判为 **Wrong Answer [4]**；\n  - 可以保证，与调用 `Compare` 的结果一致的答案是唯一的，如果 $\\texttt{X,Y}$ 与答案不一致，则会被判为 **Wrong Answer [5]**，一致则会被判为 **Accepted**；\n  - 调用此函数后，程序结束。\n\n### 注意\n\n在评分时，只要你的回答与调用 `Compare` 的结果不一致，都会被判为 **Wrong Answer [5]**。\n\n在评分时，一些测试点可能会根据之前 `Compare` 的调用情况修改返回值，但是 `Compare` 的返回值与之前 `Compare` 的调用结果不矛盾。\n\n### 编译与运行方法\n\n「附加文件」中提供了 `ramen.h`、`grader.c` 和 `grader.cpp` 三个文件。若你编写的程序名称为 `ramen.c` 或 `ramen.cpp`，请运行以下命令来编译：\n* C 语言\n```sh\ngcc -O2 -lm -o grader grader.c ramen.c\n```\n* C++ 语言\n```sh\ng++ -O2 -o grader grader.cpp ramen.cpp\n```\n\n当命令成功时，会产生一个可执行文件 `grader`。\n\n注意实际评测时的程序与下发的样例评测程序并不相同。实际的 `ramen.h` 函数实现将通过标准输入/输出与单独运行的交互器进行交互。", "inputFormat": "样例评测程序将从标准输入读入以下数据：\n- 第一行两个整数 $N,T$，用一个空格隔开。$N$ 表示拉面馆数，评测程序只会处理 $T=1$ 的数据；\n- 接下来 $N$ 行，第 $i+1$ 行表示拉面馆 $i$ 的浓厚度 $A_i$。", "outputFormat": "样例评测程序将向标准输出输出以下信息。\n\n* 判为正确时，输出 `Accepted`；\n* 运行过程中被判为错误时，以 `Wrong Answer [x]` 的格式报告并退出。\n\n程序执行过程中违反了多种限制时，只会报告其中的一种。\n\n注意，如果样例中 $A_X=0,A_Y=N-1$，调用了 `Answer(X, Y)`，即使应当是 **Wrong Answer [5]** 的情况，测评程序也会判定 **Accepted**。请注意，下发的 `grader` 与实际测评时使用的不同。", "hint": "### 样例交互\n|调用函数|返回值|\n|:-:|:-:|\n|`Compare(0, 1)`|-1|\n|`Compare(0, 2)`|1|\n|`Answer(2, 1)`|测评程序结束|\n\n对于全部数据，$1\\le N\\le 400$。\n\n详细子任务分数与附加限制见下表。\n\n|Subtask|附加限制|分数|\n|:-:|:-:|:-:|\n|$1$|$N\\le 30$|$20$|\n|$2$|$N\\le 300$|$30$|\n|$3$|无附加限制|$50$|", "locale": "zh-CN"}}}
{"pid": "P14422", "type": "P", "difficulty": 5, "samples": [["5 5 4 4\n.....\n..##.\n.#...\n..#..\n.....\n1 1\n4 2\n3 3\n2 5\n1 2\n2 4\n1 3\n3 4", "3\n4\n4\n2"], ["5 5 3 2\n...#.\n..#..\n#....\n.##..\n...#.\n1 3\n5 2\n1 5\n1 2\n1 3", "-1\n7"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "倍增", "广度优先搜索 BFS", "生成树", "JOISC/JOIST（日本）"], "title": "[JOISC 2014] 水壶 / Water Bottle", "background": "翻译来自于 https://loj.ac/p/2876", "description": "JOI 君所居住的 IOI 市以一年四季都十分炎热著称。\n\nIOI 市被分成 $H$ 行，每行包含 $W$ 块区域。每个区域都是建筑物、原野、墙壁之一。\n\nIOI 市有 $P$ 个区域是建筑物，坐标分别为 $(A_1,B_1),(A_2,B_2),\\dots,(A_P,B_P)$。\n\nJOI 君只能进入建筑物与原野，而且每次只能走到相邻的区域中，且不能移动到市外。\n\nJOI 君因为各种各样的事情，必须在各个建筑物之间往返。虽然建筑物中的冷气设备非常好，但原野上太阳非常毒辣，因此在原野上每走过一个区域都需要 1 升水。此外，原野上没有诸如自动售货机、饮水处之类的东西，因此 IOI 市的市民一般都携带水壶出行。大小为 $x$ 的水壶最多可以装 $x$ 升水，建筑物里有自来水可以将水壶装满。\n\n由于携带大水壶是一件很困难的事情，因此 JOI 君决定携带尽量小的水壶移动。因此，为了随时能在建筑物之间移动，请你帮他写一个程序来计算最少需要多大的水壶。\n\n现在给出 IOI 市的地图和 $Q$ 个询问，第 $i$ 个询问包含两个整数 $S_i,T_i$，对于每个询问，请输出：要从建筑物 $S_i$ 移动到 $T_i$，至少需要多大的水壶？\n\n**题目**  \n\n给定 IOI 市的地图及 $Q$ 个查询。第 $i$ 个查询（$1 \\le i \\le Q$）要求计算“在建筑物 $S_i$ 与 $T_i$ 之间移动所需的最小水壶容量”。请编写程序，对每个查询给出答案。", "inputFormat": "从标准输入读取以下数据。\n\n- 第一行四个空格分隔的整数 $H,W,P,Q$。\n- 接下来 $H$ 行，第 $i$ 行有一个长度为 $W$ 的字符串，每个字符都是 `.` 或 `#` 之一，`.` 表示这个位置是建筑物或原野，`#` 表示这个位置是墙壁。\n- 接下来 $P$ 行描述 IOI 市每个建筑物的位置，第 $i$ 行有两个空格分隔的整数 $A_i$ 和 $B_i$ ，表示第 $i$ 个建筑物的位置在第 $A_i$ 行第 $B_i$ 列。保证这个位置在地图中是 `.`。\n- 接下来 $Q$ 行，第 $i$ 行有两个空格分隔的整数 $S_i ,T_i$。", "outputFormat": "输出 $Q$ 行，第 $i$ 行一个整数，表示要从建筑物 $S_i$ 移动到 $T_i$，至少需要多大的水壶。\n\n如果无法到达，输出 `-1`。如果不需要经过原野就能到达，输出 `0`。", "hint": "### 样例 1 解释\n\n在此输入中，IOI 市的地图如下图所示。标有黑色方块的格子表示墙壁，标有数字的格子表示对应编号的建筑物，空白格子表示草地。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/627u1vct.png)\n:::\n\n例如，考虑从建筑物 2 移动到建筑物 4。此时，如果不经过其他建筑物，最优的路径是经过左图中用点标出的格子，这样经过的草地格子数最少，需要容量为 $6$ 的水壶。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/my31ocjd.png)\n:::\n\n然而，如果像右图所示那样，在移动过程中经过建筑物 1，则从建筑物 2 到建筑物 1 的移动过程中经过 $3$ 个草地格子，从建筑物 1 到建筑物 4 的移动过程中经过 $4$ 个草地格子，因此可以使用容量为 $4$ 的水壶完成移动。此外，无法使用容量小于 $4$ 的水壶完成移动。\n\n\n### 数据范围\n\n所有的输入数据满足以下条件：\n\n- $1 \\leq H \\leq 2000$。\n- $1 \\leq W \\leq 2000$。\n- $2 \\leq P \\leq 200\\ 000$。\n- $1 \\leq Q \\leq 200\\ 000$。\n- $1 \\leq A_j \\leq H$（$1 \\leq j \\leq P$）。\n- $1 \\leq B_j \\leq W$（$1 \\leq j \\leq P$）。\n- $(A_i, B_i) \\neq (A_j, B_j)$（$1 \\leq i < j \\leq P$）。\n- $1 \\leq S_i < T_i \\leq P$（$1 \\leq i \\leq Q$）。\n\n### 子任务\n\n**子任务 1 [10 分]**\n\n满足以下条件：\n\n- $H \\leq 200$。\n- $W \\leq 200$。\n- $P \\leq 200$。\n\n**子任务 2 [30 分]**\n\n满足以下条件：\n\n- $P \\leq 5\\ 000$。\n- $Q = 1$。\n\n**子任务 3 [30 分]**\n\n满足以下条件：\n\n- $P \\leq 5\\ 000$。\n- $Q \\leq 10\\ 000$。\n\n**子任务 4 [30 分]**\n\n没有额外的限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2014] 水壶 / Water Bottle", "background": "翻译来自于 https://loj.ac/p/2876", "description": "JOI 君所居住的 IOI 市以一年四季都十分炎热著称。\n\nIOI 市被分成 $H$ 行，每行包含 $W$ 块区域。每个区域都是建筑物、原野、墙壁之一。\n\nIOI 市有 $P$ 个区域是建筑物，坐标分别为 $(A_1,B_1),(A_2,B_2),\\dots,(A_P,B_P)$。\n\nJOI 君只能进入建筑物与原野，而且每次只能走到相邻的区域中，且不能移动到市外。\n\nJOI 君因为各种各样的事情，必须在各个建筑物之间往返。虽然建筑物中的冷气设备非常好，但原野上太阳非常毒辣，因此在原野上每走过一个区域都需要 1 升水。此外，原野上没有诸如自动售货机、饮水处之类的东西，因此 IOI 市的市民一般都携带水壶出行。大小为 $x$ 的水壶最多可以装 $x$ 升水，建筑物里有自来水可以将水壶装满。\n\n由于携带大水壶是一件很困难的事情，因此 JOI 君决定携带尽量小的水壶移动。因此，为了随时能在建筑物之间移动，请你帮他写一个程序来计算最少需要多大的水壶。\n\n现在给出 IOI 市的地图和 $Q$ 个询问，第 $i$ 个询问包含两个整数 $S_i,T_i$，对于每个询问，请输出：要从建筑物 $S_i$ 移动到 $T_i$，至少需要多大的水壶？\n\n**题目**  \n\n给定 IOI 市的地图及 $Q$ 个查询。第 $i$ 个查询（$1 \\le i \\le Q$）要求计算“在建筑物 $S_i$ 与 $T_i$ 之间移动所需的最小水壶容量”。请编写程序，对每个查询给出答案。", "inputFormat": "从标准输入读取以下数据。\n\n- 第一行四个空格分隔的整数 $H,W,P,Q$。\n- 接下来 $H$ 行，第 $i$ 行有一个长度为 $W$ 的字符串，每个字符都是 `.` 或 `#` 之一，`.` 表示这个位置是建筑物或原野，`#` 表示这个位置是墙壁。\n- 接下来 $P$ 行描述 IOI 市每个建筑物的位置，第 $i$ 行有两个空格分隔的整数 $A_i$ 和 $B_i$ ，表示第 $i$ 个建筑物的位置在第 $A_i$ 行第 $B_i$ 列。保证这个位置在地图中是 `.`。\n- 接下来 $Q$ 行，第 $i$ 行有两个空格分隔的整数 $S_i ,T_i$。", "outputFormat": "输出 $Q$ 行，第 $i$ 行一个整数，表示要从建筑物 $S_i$ 移动到 $T_i$，至少需要多大的水壶。\n\n如果无法到达，输出 `-1`。如果不需要经过原野就能到达，输出 `0`。", "hint": "### 样例 1 解释\n\n在此输入中，IOI 市的地图如下图所示。标有黑色方块的格子表示墙壁，标有数字的格子表示对应编号的建筑物，空白格子表示草地。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/627u1vct.png)\n:::\n\n例如，考虑从建筑物 2 移动到建筑物 4。此时，如果不经过其他建筑物，最优的路径是经过左图中用点标出的格子，这样经过的草地格子数最少，需要容量为 $6$ 的水壶。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/my31ocjd.png)\n:::\n\n然而，如果像右图所示那样，在移动过程中经过建筑物 1，则从建筑物 2 到建筑物 1 的移动过程中经过 $3$ 个草地格子，从建筑物 1 到建筑物 4 的移动过程中经过 $4$ 个草地格子，因此可以使用容量为 $4$ 的水壶完成移动。此外，无法使用容量小于 $4$ 的水壶完成移动。\n\n\n### 数据范围\n\n所有的输入数据满足以下条件：\n\n- $1 \\leq H \\leq 2000$。\n- $1 \\leq W \\leq 2000$。\n- $2 \\leq P \\leq 200\\ 000$。\n- $1 \\leq Q \\leq 200\\ 000$。\n- $1 \\leq A_j \\leq H$（$1 \\leq j \\leq P$）。\n- $1 \\leq B_j \\leq W$（$1 \\leq j \\leq P$）。\n- $(A_i, B_i) \\neq (A_j, B_j)$（$1 \\leq i < j \\leq P$）。\n- $1 \\leq S_i < T_i \\leq P$（$1 \\leq i \\leq Q$）。\n\n### 子任务\n\n**子任务 1 [10 分]**\n\n满足以下条件：\n\n- $H \\leq 200$。\n- $W \\leq 200$。\n- $P \\leq 200$。\n\n**子任务 2 [30 分]**\n\n满足以下条件：\n\n- $P \\leq 5\\ 000$。\n- $Q = 1$。\n\n**子任务 3 [30 分]**\n\n满足以下条件：\n\n- $P \\leq 5\\ 000$。\n- $Q \\leq 10\\ 000$。\n\n**子任务 4 [30 分]**\n\n没有额外的限制。", "locale": "zh-CN"}}}
