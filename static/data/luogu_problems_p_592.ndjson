{"pid": "P13015", "type": "P", "difficulty": 2, "samples": [["4\n1 5 6 3", "10"], ["8\n0 2 5 6 4 3 3 4", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2025", "背包 DP", "GESP"], "title": "[GESP202506 六级] 学习小组", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1186>", "description": "\n\n班主任计划将班级里的 $ n $ 名同学划分为若干个学习小组，每名同学都需要分入某一个学习小组中。观察发现，如果一个学习小组中恰好包含 $ k $ 名同学，则该学习小组的讨论积极度为 $ a_k $。\n\n给定讨论积极度 $ a_1, a_2, \\ldots, a_n $，请你计算将这 $ n $ 名同学划分为学习小组的所有可能方案中，讨论积极度之和的最大值。\n", "inputFormat": "\n第一行，一个正整数 $ n $，表示班级人数。\n\n第二行，$ n $ 个非负整数 $ a_1, a_2, \\ldots, a_n $，表示不同人数学习小组的讨论积极度。\n", "outputFormat": "\n输出共一行，一个整数，表示所有划分方案中，学习小组讨论积极度之和的最大值。", "hint": "对于 $40\\%$ 的测试点，保证 $1\\le n\\le 10$。\n\n对于所有测试点，保证 $1\\le n\\le 1000$，$0\\le a_i\\le 10^4$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GESP202506 六级] 学习小组", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1186>", "description": "\n\n班主任计划将班级里的 $ n $ 名同学划分为若干个学习小组，每名同学都需要分入某一个学习小组中。观察发现，如果一个学习小组中恰好包含 $ k $ 名同学，则该学习小组的讨论积极度为 $ a_k $。\n\n给定讨论积极度 $ a_1, a_2, \\ldots, a_n $，请你计算将这 $ n $ 名同学划分为学习小组的所有可能方案中，讨论积极度之和的最大值。\n", "inputFormat": "\n第一行，一个正整数 $ n $，表示班级人数。\n\n第二行，$ n $ 个非负整数 $ a_1, a_2, \\ldots, a_n $，表示不同人数学习小组的讨论积极度。\n", "outputFormat": "\n输出共一行，一个整数，表示所有划分方案中，学习小组讨论积极度之和的最大值。", "hint": "对于 $40\\%$ 的测试点，保证 $1\\le n\\le 10$。\n\n对于所有测试点，保证 $1\\le n\\le 1000$，$0\\le a_i\\le 10^4$。", "locale": "zh-CN"}}}
{"pid": "P13016", "type": "P", "difficulty": 3, "samples": [["3\n1 3\n2 5\n4 8", "1\n2\n1"], ["1\n120 650", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "2025", "数论", "最近公共祖先 LCA", "GESP"], "title": "[GESP202506 六级] 最大因数", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1186>", "description": "\n\n给定一棵有 $10^9$ 个结点的有根树，这些结点依次以 $1, 2, \\dots, 10^9$ 编号，根结点的编号为 $1$。对于编号为 $k$（$2 \\leq k \\leq 10^9$）的结点，其父结点的编号为 $k$ 的因数中除 $k$ 以外最大的因数。\n\n现在有 $q$ 组询问，第 $i$（$1 \\leq i \\leq q$）组询问给定 $x_i, y_i$，请你求出编号分别为 $x_i, y_i$ 的两个结点在这棵树上的距离。两个结点之间的距离是连接这两个结点的简单路径所包含的边数。\n", "inputFormat": "\n第一行，一个正整数 $q$，表示询问组数。\n\n接下来 $q$ 行，每行两个正整数 $x_i, y_i$，表示询问结点的编号。", "outputFormat": "\n输出共 $q$ 行，每行一个整数，表示结点 $x_i, y_i$ 之间的距离。", "hint": "\n对于 $60\\%$ 的测试点，保证 $1 \\leq x_i, y_i \\leq 1000$。\n\n对于所有测试点，保证 $1 \\leq q \\leq 1000$，$1 \\leq x_i, y_i \\leq 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GESP202506 六级] 最大因数", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1186>", "description": "\n\n给定一棵有 $10^9$ 个结点的有根树，这些结点依次以 $1, 2, \\dots, 10^9$ 编号，根结点的编号为 $1$。对于编号为 $k$（$2 \\leq k \\leq 10^9$）的结点，其父结点的编号为 $k$ 的因数中除 $k$ 以外最大的因数。\n\n现在有 $q$ 组询问，第 $i$（$1 \\leq i \\leq q$）组询问给定 $x_i, y_i$，请你求出编号分别为 $x_i, y_i$ 的两个结点在这棵树上的距离。两个结点之间的距离是连接这两个结点的简单路径所包含的边数。\n", "inputFormat": "\n第一行，一个正整数 $q$，表示询问组数。\n\n接下来 $q$ 行，每行两个正整数 $x_i, y_i$，表示询问结点的编号。", "outputFormat": "\n输出共 $q$ 行，每行一个整数，表示结点 $x_i, y_i$ 之间的距离。", "hint": "\n对于 $60\\%$ 的测试点，保证 $1 \\leq x_i, y_i \\leq 1000$。\n\n对于所有测试点，保证 $1 \\leq q \\leq 1000$，$1 \\leq x_i, y_i \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P13017", "type": "P", "difficulty": 3, "samples": [["5 4\n1 2\n2 3\n3 1\n4 5", "3"], ["5 10\n1 2\n1 3\n1 4\n1 5\n2 3\n2 4\n2 5\n3 4\n3 5\n4 5", "30"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "2025", "组合数学", "GESP"], "title": "[GESP202506 七级] 线图", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1187>", "description": "给定由 $n$ 个结点与 $m$ 条边构成的简单无向图 $G$，结点依次以 $1,2,\\dots,n$ 编号。简单无向图意味着 $G$ 中不包含重边与自环。$G$ 的**线图** $L(G)$ 通过以下方式构建：\n\n- 初始时线图 $L(G)$ 为空。\n\n- 对于无向图 $G$ 中的一条边，在线图 $L(G)$ 中加入与之对应的一个结点。\n\n- 对于无向图 $G$ 中两条不同的边 $(u_1,v_1),(u_2,v_2)$，若存在 $G$ 中的结点同时连接这两条边（即 $u_1,v_1$ 之一与 $u_2,v_2$ 之一相同），则在线图 $L(G)$ 中加入一条无向边，连接 $(u_1,v_1),(u_2,v_2)$ 在线图中对应的结点。\n\n请你求出线图 $L(G)$ 中所包含的无向边的数量。", "inputFormat": "第一行，两个正整数 $n,m$，分别表示无向图 $G$ 中的结点数和边数。\n\n接下来 $m$ 行，每行两个正整数 $u_i,v_i$，表示 $G$ 中连接 $u_i,v_i$ 的一条无向边。", "outputFormat": "输出共一行，一个整数，表示线图 $L(G)$ 中所包含的无向边的数量。", "hint": "**【样例解释 #1】**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/72ffa0a3.png)\n\n**【数据范围】**\n\n对于 $60\\%$ 的测试点，保证 $1 \\le n \\le 500$，$1 \\le m \\le 500$。\n\n对于所有测试点，保证 $1 \\le n \\le 10^5$，$1 \\le m \\le 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GESP202506 七级] 线图", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1187>", "description": "给定由 $n$ 个结点与 $m$ 条边构成的简单无向图 $G$，结点依次以 $1,2,\\dots,n$ 编号。简单无向图意味着 $G$ 中不包含重边与自环。$G$ 的**线图** $L(G)$ 通过以下方式构建：\n\n- 初始时线图 $L(G)$ 为空。\n\n- 对于无向图 $G$ 中的一条边，在线图 $L(G)$ 中加入与之对应的一个结点。\n\n- 对于无向图 $G$ 中两条不同的边 $(u_1,v_1),(u_2,v_2)$，若存在 $G$ 中的结点同时连接这两条边（即 $u_1,v_1$ 之一与 $u_2,v_2$ 之一相同），则在线图 $L(G)$ 中加入一条无向边，连接 $(u_1,v_1),(u_2,v_2)$ 在线图中对应的结点。\n\n请你求出线图 $L(G)$ 中所包含的无向边的数量。", "inputFormat": "第一行，两个正整数 $n,m$，分别表示无向图 $G$ 中的结点数和边数。\n\n接下来 $m$ 行，每行两个正整数 $u_i,v_i$，表示 $G$ 中连接 $u_i,v_i$ 的一条无向边。", "outputFormat": "输出共一行，一个整数，表示线图 $L(G)$ 中所包含的无向边的数量。", "hint": "**【样例解释 #1】**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/72ffa0a3.png)\n\n**【数据范围】**\n\n对于 $60\\%$ 的测试点，保证 $1 \\le n \\le 500$，$1 \\le m \\le 500$。\n\n对于所有测试点，保证 $1 \\le n \\le 10^5$，$1 \\le m \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P13018", "type": "P", "difficulty": 3, "samples": [["3\n1 2\n2 4\n3 2", "8"], ["5\n1 1\n2 3\n6 1\n8 2\n5 7\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2025", "背包 DP", "GESP"], "title": "[GESP202506 七级] 调味平衡", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1187>", "description": "小 A 准备了 $n$ 种食材用来制作料理，这些食材依次以 $1,2,\\dots,n$ 编号，第 $i$ 种食材的酸度为 $a_i$，甜度为 $b_i$。对于每种食材，小 A 可以选择将其放入料理，或者不放入料理。料理的酸度 $A$ 为放入食材的酸度之和，甜度 $B$ 为放入食材的甜度之和。如果料理的酸度和甜度相等，那么料理的调味是**平衡的**。\n\n过于清淡的料理并不好吃，因此小 A 想在满足料理调味平衡的前提下，合理选择食材，最大化料理的酸度与甜度之和。你能帮他求出在调味平衡的前提下，料理酸度与甜度之和的最大值吗？\n", "inputFormat": "第一行，一个正整数 $n$，表示食材种类数量。\n\n接下来 $n$ 行，每行两个正整数 $a_i,b_i$，表示食材的酸度和甜度。", "outputFormat": "输出共一行，一个整数，表示在调味平衡的前提下，料理酸度与甜度之和的最大值。", "hint": "对于 $40\\%$ 的测试点，保证 $1 \\le n \\le 10$，$1 \\le a_i,b_i \\le 10$。\n\n对于另外 $20\\%$ 的测试点，保证 $1 \\le n \\le 50$，$1 \\le a_i,b_i \\le 10$。\n\n对于所有测试点，保证 $1 \\le n \\le 100$，$1 \\le a_i,b_i \\le 500$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GESP202506 七级] 调味平衡", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1187>", "description": "小 A 准备了 $n$ 种食材用来制作料理，这些食材依次以 $1,2,\\dots,n$ 编号，第 $i$ 种食材的酸度为 $a_i$，甜度为 $b_i$。对于每种食材，小 A 可以选择将其放入料理，或者不放入料理。料理的酸度 $A$ 为放入食材的酸度之和，甜度 $B$ 为放入食材的甜度之和。如果料理的酸度和甜度相等，那么料理的调味是**平衡的**。\n\n过于清淡的料理并不好吃，因此小 A 想在满足料理调味平衡的前提下，合理选择食材，最大化料理的酸度与甜度之和。你能帮他求出在调味平衡的前提下，料理酸度与甜度之和的最大值吗？\n", "inputFormat": "第一行，一个正整数 $n$，表示食材种类数量。\n\n接下来 $n$ 行，每行两个正整数 $a_i,b_i$，表示食材的酸度和甜度。", "outputFormat": "输出共一行，一个整数，表示在调味平衡的前提下，料理酸度与甜度之和的最大值。", "hint": "对于 $40\\%$ 的测试点，保证 $1 \\le n \\le 10$，$1 \\le a_i,b_i \\le 10$。\n\n对于另外 $20\\%$ 的测试点，保证 $1 \\le n \\le 50$，$1 \\le a_i,b_i \\le 10$。\n\n对于所有测试点，保证 $1 \\le n \\le 100$，$1 \\le a_i,b_i \\le 500$。", "locale": "zh-CN"}}}
{"pid": "P13019", "type": "P", "difficulty": 4, "samples": [["5 4\n1 1 2 2\n3 3\n1 -1 -1\n2 5\n1 -1 1 -1 1\n5 8\n1 1 1 -1 -1 -1 -1 -1\n5 3\n-1 -1 1", "4\n1\n4\n2"], ["8 3\n5 4 2 1 3 6 6\n8 1\n8\n8 2\n8 -8\n8 3\n8 -8 8", "1\n7\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["倍增", "2025", "最近公共祖先 LCA", "GESP"], "title": "[GESP202506 八级] 树上旅行", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1188>", "description": "\n\n给定一棵有 $ n $ 个结点的 **有根树**，结点依次以 $1,2,\\dots,n$ 编号，其中根结点的编号为 $1$。\n\n小 A 计划在这棵有根树上进行 $q$ 次旅行。在第 $i$ 次旅行中，小 A 首先选定结点 $s_i$ 作为起点，并移动若干次。移动分为以下两种：\n\n1. 移动至当前结点的父结点。特殊地，如果当前位于根结点，则不进行移动。\n2. 移动至当前结点的所有子结点中**编号最小**的结点。特殊地，如果当前位于叶子结点，则不进行移动。\n\n由于移动次数可能很大，对于第 $i$ 次旅行，旅行中的移动以 $k_i$ 个不为零的整数构成的序列 $a_{i,1}, a_{i,2}, \\dots, a_{i,k_i}$ 表示。对 $a_{i,j}$，若 $a_{i,j} > 0$ 则代表进行 $a_{i,j}$ 次第一种移动；若 $a_{i,j} < 0$ 则代表进行 $-a_{i,j}$ 次第二种移动。根据给出的序列从左至右完成所有移动后，小 A 所在的结点即是旅行的**终点**。\n\n给定每次旅行的起点与移动序列，请你求出旅行终点的结点编号。\n", "inputFormat": "\n\n第一行，两个正整数 $n, q$，分别表示有根树的结点数量，以及旅行次数。\n\n第二行，$n-1$ 个整数 $p_2, p_3, \\dots, p_n$，其中 $p_i$ 表示结点 $i$ 的父结点编号。\n\n接下来 $2q$ 行中的第 $2i-1$ 行（$1 \\leq i \\leq q$）包含两个正整数 $s_i, k_i$，分别表示第 $i$ 次旅行的起点编号，以及移动序列的长度。第 $2i$ 行包含 $k_i$ 个整数 $a_{i,1}, a_{i,2}, \\dots, a_{i,k_i}$，表示移动序列。", "outputFormat": "\n输出共 $q$ 行，第 $i$ 行包含一个整数，表示第 $i$ 次旅行终点的结点编号。", "hint": "\n\n| 子任务编号 | 测试点占比 | $n$ | $q$ | $\\sum k_i$ | 特殊性质 |\n|:-:|:-:|:-:|:-:|:-:|:-:|\n| $1$          | $20\\%$         | $\\leq 100$ | $\\leq 100$ | $\\leq 1000$ | 保证 $a_{i,j}$ 为 $1$ 或 $-1$ |\n| $2$          | $20\\%$         | $\\leq 10^4$ | $\\leq 10^4$ | $\\leq 4 \\times 10^4$ | 仅包含第一种移动 |\n| $3$          | $20\\%$         | $\\leq 10^4$ | $\\leq 10^4$ | $\\leq 4 \\times 10^4$ | 仅包含第二种移动 |\n| $4$          | $40\\%$         | $\\leq 10^5$ | $\\leq 2 \\times 10^4$ | $\\leq 10^5$ | - |\n\n对于所有测试点，保证：\n\n- $1 \\leq n \\leq 10^5$\n- $1 \\leq q \\leq 2 \\times 10^4$\n- $1 \\leq p_i \\leq n$\n- $1 \\leq s_i \\leq n$\n- $k_i \\geq 1$ 且 $\\sum k_i \\leq 10^5$\n- $1 \\leq |a_{i,j}| \\leq n$\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GESP202506 八级] 树上旅行", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1188>", "description": "\n\n给定一棵有 $ n $ 个结点的 **有根树**，结点依次以 $1,2,\\dots,n$ 编号，其中根结点的编号为 $1$。\n\n小 A 计划在这棵有根树上进行 $q$ 次旅行。在第 $i$ 次旅行中，小 A 首先选定结点 $s_i$ 作为起点，并移动若干次。移动分为以下两种：\n\n1. 移动至当前结点的父结点。特殊地，如果当前位于根结点，则不进行移动。\n2. 移动至当前结点的所有子结点中**编号最小**的结点。特殊地，如果当前位于叶子结点，则不进行移动。\n\n由于移动次数可能很大，对于第 $i$ 次旅行，旅行中的移动以 $k_i$ 个不为零的整数构成的序列 $a_{i,1}, a_{i,2}, \\dots, a_{i,k_i}$ 表示。对 $a_{i,j}$，若 $a_{i,j} > 0$ 则代表进行 $a_{i,j}$ 次第一种移动；若 $a_{i,j} < 0$ 则代表进行 $-a_{i,j}$ 次第二种移动。根据给出的序列从左至右完成所有移动后，小 A 所在的结点即是旅行的**终点**。\n\n给定每次旅行的起点与移动序列，请你求出旅行终点的结点编号。\n", "inputFormat": "\n\n第一行，两个正整数 $n, q$，分别表示有根树的结点数量，以及旅行次数。\n\n第二行，$n-1$ 个整数 $p_2, p_3, \\dots, p_n$，其中 $p_i$ 表示结点 $i$ 的父结点编号。\n\n接下来 $2q$ 行中的第 $2i-1$ 行（$1 \\leq i \\leq q$）包含两个正整数 $s_i, k_i$，分别表示第 $i$ 次旅行的起点编号，以及移动序列的长度。第 $2i$ 行包含 $k_i$ 个整数 $a_{i,1}, a_{i,2}, \\dots, a_{i,k_i}$，表示移动序列。", "outputFormat": "\n输出共 $q$ 行，第 $i$ 行包含一个整数，表示第 $i$ 次旅行终点的结点编号。", "hint": "\n\n| 子任务编号 | 测试点占比 | $n$ | $q$ | $\\sum k_i$ | 特殊性质 |\n|:-:|:-:|:-:|:-:|:-:|:-:|\n| $1$          | $20\\%$         | $\\leq 100$ | $\\leq 100$ | $\\leq 1000$ | 保证 $a_{i,j}$ 为 $1$ 或 $-1$ |\n| $2$          | $20\\%$         | $\\leq 10^4$ | $\\leq 10^4$ | $\\leq 4 \\times 10^4$ | 仅包含第一种移动 |\n| $3$          | $20\\%$         | $\\leq 10^4$ | $\\leq 10^4$ | $\\leq 4 \\times 10^4$ | 仅包含第二种移动 |\n| $4$          | $40\\%$         | $\\leq 10^5$ | $\\leq 2 \\times 10^4$ | $\\leq 10^5$ | - |\n\n对于所有测试点，保证：\n\n- $1 \\leq n \\leq 10^5$\n- $1 \\leq q \\leq 2 \\times 10^4$\n- $1 \\leq p_i \\leq n$\n- $1 \\leq s_i \\leq n$\n- $k_i \\geq 1$ 且 $\\sum k_i \\leq 10^5$\n- $1 \\leq |a_{i,j}| \\leq n$\n", "locale": "zh-CN"}}}
{"pid": "P13020", "type": "P", "difficulty": 4, "samples": [["4\n1 2\n2 3\n3 4", "6"], ["8\n1 2\n1 3\n1 4\n2 5\n2 6\n3 7\n3 8", "112"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "树形 DP", "树论", "组合数学", "GESP"], "title": "[GESP202506 八级] 遍历计数", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1188>", "description": "给定一棵有 $n$ 个结点的树 $T$，结点依次以 $1,2,\\dots,n$ 标号。树 $T$ 的深度优先遍历序可由以下过程得到：\n\n1. 选定深度优先遍历的起点 $s$（$1 \\leq s \\leq n$），当前位置结点即是起点。\n2. 若当前结点存在未被遍历的相邻结点 $u$ 则遍历 $u$，也即令当前位置结点为 $u$ 并重复这一步；否则回溯。\n3. 按照遍历结点的顺序依次写下结点编号，即可得到一组深度优先遍历序。\n\n第一步中起点的选择是任意的，并且第二步中遍历相邻结点的顺序也是任意的，因此对于同一棵树 $T$ 可能有多组不同的深度优先遍历序。请你求出树 $T$ 有多少组不同的深度优先遍历序。由于答案可能很大，你只需要求出答案对 $10^9$ 取模之后的结果。", "inputFormat": "第一行，一个整数 $n$，表示树 $T$ 的结点数。\n\n接下来 $n-1$ 行，每行两个正整数 $u_i, v_i$，表示树 $T$ 中的一条连接结点 $u_i, v_i$ 的边。", "outputFormat": "输出一行，一个整数，表示树 $T$ 的不同的深度优先遍历序数量对 $10^9$ 取模的结果。", "hint": "对于 $40\\%$ 的测试点，保证 $1 \\leq n \\leq 8$。\n\n对于另外 $20\\%$ 的测试点，保证给定的树是一条链。\n\n对于所有测试点，保证 $1 \\leq n \\leq 10^5$。\n\n在洛谷上，只有通过了 Subtask0、Subtask1 和 Subtask2 后，才能获得第三个 Subtask 的分数。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GESP202506 八级] 遍历计数", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1188>", "description": "给定一棵有 $n$ 个结点的树 $T$，结点依次以 $1,2,\\dots,n$ 标号。树 $T$ 的深度优先遍历序可由以下过程得到：\n\n1. 选定深度优先遍历的起点 $s$（$1 \\leq s \\leq n$），当前位置结点即是起点。\n2. 若当前结点存在未被遍历的相邻结点 $u$ 则遍历 $u$，也即令当前位置结点为 $u$ 并重复这一步；否则回溯。\n3. 按照遍历结点的顺序依次写下结点编号，即可得到一组深度优先遍历序。\n\n第一步中起点的选择是任意的，并且第二步中遍历相邻结点的顺序也是任意的，因此对于同一棵树 $T$ 可能有多组不同的深度优先遍历序。请你求出树 $T$ 有多少组不同的深度优先遍历序。由于答案可能很大，你只需要求出答案对 $10^9$ 取模之后的结果。", "inputFormat": "第一行，一个整数 $n$，表示树 $T$ 的结点数。\n\n接下来 $n-1$ 行，每行两个正整数 $u_i, v_i$，表示树 $T$ 中的一条连接结点 $u_i, v_i$ 的边。", "outputFormat": "输出一行，一个整数，表示树 $T$ 的不同的深度优先遍历序数量对 $10^9$ 取模的结果。", "hint": "对于 $40\\%$ 的测试点，保证 $1 \\leq n \\leq 8$。\n\n对于另外 $20\\%$ 的测试点，保证给定的树是一条链。\n\n对于所有测试点，保证 $1 \\leq n \\leq 10^5$。\n\n在洛谷上，只有通过了 Subtask0、Subtask1 和 Subtask2 后，才能获得第三个 Subtask 的分数。", "locale": "zh-CN"}}}
{"pid": "P13021", "type": "P", "difficulty": 2, "samples": [["3\n4\n4 2 1 3\n2\n1 2\n7\n7 6 5 4 3 2 1", "Case #1: 6\nCase #2: 1\nCase #3: 12"]], "limits": {"time": [10000, 10000], "memory": [1048576, 1048576]}, "tags": ["模拟", "2021", "Google Code Jam"], "title": "[GCJ 2021 Qualification] Reversort", "background": "", "description": "**Note: The main parts of the statements of the problems \"Reversort\" and \"Reversort Engineering\" are identical, except for the last paragraph. The problems can otherwise be solved independently.**\n\nReversort is an algorithm to sort a list of distinct integers in increasing order. The algorithm is based on the \"Reverse\" operation. Each application of this operation reverses the order of some contiguous part of the list.\n\nThe pseudocode of the algorithm is the following:\n\n```\nReversort(L):\n  for i := 1 to length(L) - 1\n    j := position with the minimum value in L between i and length(L), inclusive\n    Reverse(L[i..j])\n```\n\nAfter $i-1$ iterations, the positions $1, 2, \\ldots, i-1$ of the list contain the $i-1$ smallest elements of $L$, in increasing order. During the $i$-th iteration, the process reverses the sublist going from the $i$-th position to the current position of the $i$-th minimum element. That makes the $i$-th minimum element end up in the $i$-th position.\n\nFor example, for a list with 4 elements, the algorithm would perform 3 iterations. Here is how it would process $L = [4, 2, 1, 3]$:\n\n1. $i = 1$, $j = 3 \\longrightarrow L = [1, 2, 4, 3]$\n2. $i = 2$, $j = 2 \\longrightarrow L = [1, 2, 4, 3]$\n3. $i = 3$, $j = 4 \\longrightarrow L = [1, 2, 3, 4]$\n\nThe most expensive part of executing the algorithm on our architecture is the Reverse operation. Therefore, our measure for the cost of each iteration is simply the length of the sublist passed to Reverse, that is, the value $j - i + 1$. The cost of the whole algorithm is the sum of the costs of each iteration.\n\nIn the example above, the iterations cost 3, 1, and 2, in that order, for a total of 6.\n\nGiven the initial list, compute the cost of executing Reversort on it.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of 2 lines. The first line contains a single integer $\\mathbf{N}$, representing the number of elements in the input list. The second line contains $\\mathbf{N}$ distinct integers $\\mathbf{L}_{1}, \\mathbf{L}_{2}, \\ldots, \\mathbf{L}_{\\mathbf{N}}$, representing the elements of the input list $L$, in order.", "outputFormat": "For each test case, output one line containing Case #$x$: $y$, where $x$ is the test case number (starting from 1) and $y$ is the total cost of executing Reversort on the list given as input.", "hint": "**Sample Explanation**\n\nSample Case #1 is described in the statement above.\n\nIn Sample Case #2, there is a single iteration, in which Reverse is applied to a sublist of size 1. Therefore, the total cost is 1.\n\nIn Sample Case #3, the first iteration reverses the full list, for a cost of 7. After that, the list is already sorted, but there are 5 more iterations, each of which contributes a cost of 1.\n\n**Limits**\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{N} \\leq 100$.\n- $1 \\leq \\mathbf{L}_{i} \\leq N$, for all $i$.\n- $\\mathbf{L}_{i} \\neq \\mathbf{L}_{j}$, for all $i \\neq j$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 Qualification] Reversort", "background": "", "description": "**Note: The main parts of the statements of the problems \"Reversort\" and \"Reversort Engineering\" are identical, except for the last paragraph. The problems can otherwise be solved independently.**\n\nReversort is an algorithm to sort a list of distinct integers in increasing order. The algorithm is based on the \"Reverse\" operation. Each application of this operation reverses the order of some contiguous part of the list.\n\nThe pseudocode of the algorithm is the following:\n\n```\nReversort(L):\n  for i := 1 to length(L) - 1\n    j := position with the minimum value in L between i and length(L), inclusive\n    Reverse(L[i..j])\n```\n\nAfter $i-1$ iterations, the positions $1, 2, \\ldots, i-1$ of the list contain the $i-1$ smallest elements of $L$, in increasing order. During the $i$-th iteration, the process reverses the sublist going from the $i$-th position to the current position of the $i$-th minimum element. That makes the $i$-th minimum element end up in the $i$-th position.\n\nFor example, for a list with 4 elements, the algorithm would perform 3 iterations. Here is how it would process $L = [4, 2, 1, 3]$:\n\n1. $i = 1$, $j = 3 \\longrightarrow L = [1, 2, 4, 3]$\n2. $i = 2$, $j = 2 \\longrightarrow L = [1, 2, 4, 3]$\n3. $i = 3$, $j = 4 \\longrightarrow L = [1, 2, 3, 4]$\n\nThe most expensive part of executing the algorithm on our architecture is the Reverse operation. Therefore, our measure for the cost of each iteration is simply the length of the sublist passed to Reverse, that is, the value $j - i + 1$. The cost of the whole algorithm is the sum of the costs of each iteration.\n\nIn the example above, the iterations cost 3, 1, and 2, in that order, for a total of 6.\n\nGiven the initial list, compute the cost of executing Reversort on it.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of 2 lines. The first line contains a single integer $\\mathbf{N}$, representing the number of elements in the input list. The second line contains $\\mathbf{N}$ distinct integers $\\mathbf{L}_{1}, \\mathbf{L}_{2}, \\ldots, \\mathbf{L}_{\\mathbf{N}}$, representing the elements of the input list $L$, in order.", "outputFormat": "For each test case, output one line containing Case #$x$: $y$, where $x$ is the test case number (starting from 1) and $y$ is the total cost of executing Reversort on the list given as input.", "hint": "**Sample Explanation**\n\nSample Case #1 is described in the statement above.\n\nIn Sample Case #2, there is a single iteration, in which Reverse is applied to a sublist of size 1. Therefore, the total cost is 1.\n\nIn Sample Case #3, the first iteration reverses the full list, for a cost of 7. After that, the list is already sorted, but there are 5 more iterations, each of which contributes a cost of 1.\n\n**Limits**\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{N} \\leq 100$.\n- $1 \\leq \\mathbf{L}_{i} \\leq N$, for all $i$.\n- $\\mathbf{L}_{i} \\neq \\mathbf{L}_{j}$, for all $i \\neq j$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 Qualification] Reversort", "background": "", "description": "**注意：问题 \"Reversort\" 和 \"Reversort Engineering\" 的题目描述主体部分相同，仅最后一段不同。这两个问题可以独立解决。**\n\nReversort 是一种用于将**互不相同**的整数列表按升序排序的算法。该算法基于 \"Reverse\" 操作，每次应用该操作会反转列表中某个连续部分的顺序。\n\n算法的伪代码如下：\n\n```\nReversort(L):\n  for i := 1 to length(L) - 1\n    j := position with the minimum value in L between i and length(L), inclusive\n    Reverse(L[i..j])\n```\n\n经过 $i-1$ 次迭代后，列表的第 $1, 2, \\ldots, i-1$ 个位置将包含 $L$ 中前 $i-1$ 小的元素，并按升序排列。在第 $i$ 次迭代中，算法会反转从第 $i$ 个位置到当前第 $i$ 小元素所在位置的子列表。这将使第 $i$ 小的元素最终位于第 $i$ 个位置。\n\n例如，对于一个包含 4 个元素的列表，算法将执行 3 次迭代。以下是处理 $L = [4, 2, 1, 3]$ 的过程：\n\n1. $i = 1$，$j = 3 \\longrightarrow L = [1, 2, 4, 3]$\n2. $i = 2$，$j = 2 \\longrightarrow L = [1, 2, 4, 3]$\n3. $i = 3$，$j = 4 \\longrightarrow L = [1, 2, 3, 4]$\n\n在我们的架构中，执行该算法最耗时的部分是 Reverse 操作。因此，我们衡量每次迭代成本的标准仅仅是传递给 Reverse 的子列表长度，即 $j - i + 1$。整个算法的成本是每次迭代成本的总和。\n\n在上述示例中，迭代成本依次为 3、1 和 2，总成本为 6。\n\n给定初始列表，计算执行 Reversort 的成本。", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。接下来是 $\\mathbf{T}$ 个测试用例。每个测试用例包含 2 行。第一行包含一个整数 $\\mathbf{N}$，表示输入列表的元素数量。第二行包含 $\\mathbf{N}$ 个**互不相同**的整数 $\\mathbf{L}_{1}, \\mathbf{L}_{2}, \\ldots, \\mathbf{L}_{\\mathbf{N}}$，按顺序表示输入列表 $L$ 的元素。\n", "outputFormat": "对于每个测试用例，输出一行 \"Case #$x$: $y$\"，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是对给定列表执行 Reversort 的总成本。\n", "hint": "**样例解释**\n\n样例 #1 已在题目描述中说明。\n\n在样例 #2 中，仅有一次迭代，Reverse 操作应用于长度为 1 的子列表，因此总成本为 1。\n\n在样例 #3 中，第一次迭代反转了整个列表，成本为 7。此后列表已排序，但仍有 5 次迭代，每次成本为 1。\n\n**数据范围**\n\n**测试集 1（7 分，可见判定结果）**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $2 \\leq \\mathbf{N} \\leq 100$。\n- $1 \\leq \\mathbf{L}_{i} \\leq N$，对所有 $i$ 成立。\n- $\\mathbf{L}_{i} \\neq \\mathbf{L}_{j}$，对所有 $i \\neq j$ 成立。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13022", "type": "P", "difficulty": 3, "samples": [["4\n2 3 CJ?CC?\n4 2 CJCJ\n1 3 C?J\n2 5 ??J???", "Case #1: 5\nCase #2: 10\nCase #3: 1\nCase #4: 0"], ["1\n2 -5 ??JJ??", "Case #1: -8"]], "limits": {"time": [10000, 10000, 10000, 10000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2021", "Google Code Jam"], "title": "[GCJ 2021 Qualification] Moons and Umbrellas", "background": "", "description": "Cody-Jamal is working on his latest piece of abstract art: a mural consisting of a row of waning moons and closed umbrellas. Unfortunately, greedy copyright trolls are claiming that waning moons look like an uppercase C and closed umbrellas look like a J, and they have a copyright on CJ and JC. Therefore, for each time CJ appears in the mural, Cody-Jamal must pay $\\mathbf{X}$, and for each time JC appears in the mural, he must pay $\\mathbf{Y}$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sqo2l8si.png)\n\nCody-Jamal is unwilling to let them compromise his art, so he will not change anything already painted. He decided, however, that the empty spaces he still has could be filled strategically, to minimize the copyright expenses.\n\nFor example, if `CJ?CC?` represents the current state of the mural, with `C` representing a waning moon, `J` representing a closed umbrella, and `?` representing a space that still needs to be painted with either a waning moon or a closed umbrella, he could finish the mural as `CJCCCC`, `CJCCCJ`, `CJJCCC`, or `CJJCCJ`. The first and third options would require paying $\\mathbf{X} + \\mathbf{Y}$ in copyrights, while the second and fourth would require paying $2 \\cdot \\mathbf{X} + \\mathbf{Y}$.\n\nGiven the costs $\\mathbf{X}$ and $\\mathbf{Y}$ and a string representing the current state of the mural, how much does Cody-Jamal need to pay in copyrights if he finishes his mural in a way that minimizes that cost?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line contains two integers $\\mathbf{X}$ and $\\mathbf{Y}$ and a string $\\mathbf{S}$ representing the two costs and the current state of the mural, respectively.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum cost that Cody-Jamal needs to pay in copyrights for a finished mural.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one explained in the problem statement. The minimum cost is $\\mathbf{X} + \\mathbf{Y} = 2 + 3 = 5$.\n\nIn Sample Case #2, Cody-Jamal is already finished, so he does not have a choice. There are two `CJ`s and one `JC` in his mural.\n\nIn Sample Case #3, substituting either `C` or `J` results in one `CJ` either from the second and third characters or the first and second characters, respectively.\n\nIn Sample Case #4, Cody-Jamal can finish his mural with all Js. Since that contains no instance of `CJ` nor `JC`, it yields no copyright cost.\n\nThe following additional sample 2 fits the limits of Test Set 3. It will not be run against your submitted solutions.\n\nIn Sample Case #1 for Test Set 3, Cody-Jamal can finish his mural optimally as `JCJJCC` or `JCJJJC`. Either way, there is one `CJ` and two `JC`s in his mural.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- Each character of $\\mathbf{S}$ is either $\\mathbf{c}$, $\\mathbf{J}$, or $\\mathbf{?}$.\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{S} \\leq 10$.\n- $1 \\leq \\mathbf{X} \\leq 100$.\n- $1 \\leq \\mathbf{Y} \\leq 100$.\n\n**Test Set 2 (11 Pts, Visible Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{S} \\leq 1000$.\n- $1 \\leq \\mathbf{X} \\leq 100$.\n- $1 \\leq \\mathbf{Y} \\leq 100$.\n\n**Extra credit!**\n\nWhat if some copyright holders could pay Cody-Jamal for the advertisement instead of being paid? Cody-Jamal getting paid is represented by a negative cost.\n\n**Test Set 3 (1 Pts, Hidden Verdict)**\n\n- $1 < $ the length of $\\mathbf{S} < 1000$.\n- $-100 \\leq \\mathbf{X} \\leq 100$.\n- $-100 \\leq \\mathbf{Y} \\leq 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 Qualification] Moons and Umbrellas", "background": "", "description": "Cody-Jamal is working on his latest piece of abstract art: a mural consisting of a row of waning moons and closed umbrellas. Unfortunately, greedy copyright trolls are claiming that waning moons look like an uppercase C and closed umbrellas look like a J, and they have a copyright on CJ and JC. Therefore, for each time CJ appears in the mural, Cody-Jamal must pay $\\mathbf{X}$, and for each time JC appears in the mural, he must pay $\\mathbf{Y}$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sqo2l8si.png)\n\nCody-Jamal is unwilling to let them compromise his art, so he will not change anything already painted. He decided, however, that the empty spaces he still has could be filled strategically, to minimize the copyright expenses.\n\nFor example, if `CJ?CC?` represents the current state of the mural, with `C` representing a waning moon, `J` representing a closed umbrella, and `?` representing a space that still needs to be painted with either a waning moon or a closed umbrella, he could finish the mural as `CJCCCC`, `CJCCCJ`, `CJJCCC`, or `CJJCCJ`. The first and third options would require paying $\\mathbf{X} + \\mathbf{Y}$ in copyrights, while the second and fourth would require paying $2 \\cdot \\mathbf{X} + \\mathbf{Y}$.\n\nGiven the costs $\\mathbf{X}$ and $\\mathbf{Y}$ and a string representing the current state of the mural, how much does Cody-Jamal need to pay in copyrights if he finishes his mural in a way that minimizes that cost?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line contains two integers $\\mathbf{X}$ and $\\mathbf{Y}$ and a string $\\mathbf{S}$ representing the two costs and the current state of the mural, respectively.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum cost that Cody-Jamal needs to pay in copyrights for a finished mural.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one explained in the problem statement. The minimum cost is $\\mathbf{X} + \\mathbf{Y} = 2 + 3 = 5$.\n\nIn Sample Case #2, Cody-Jamal is already finished, so he does not have a choice. There are two `CJ`s and one `JC` in his mural.\n\nIn Sample Case #3, substituting either `C` or `J` results in one `CJ` either from the second and third characters or the first and second characters, respectively.\n\nIn Sample Case #4, Cody-Jamal can finish his mural with all Js. Since that contains no instance of `CJ` nor `JC`, it yields no copyright cost.\n\nThe following additional sample 2 fits the limits of Test Set 3. It will not be run against your submitted solutions.\n\nIn Sample Case #1 for Test Set 3, Cody-Jamal can finish his mural optimally as `JCJJCC` or `JCJJJC`. Either way, there is one `CJ` and two `JC`s in his mural.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- Each character of $\\mathbf{S}$ is either $\\mathbf{c}$, $\\mathbf{J}$, or $\\mathbf{?}$.\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{S} \\leq 10$.\n- $1 \\leq \\mathbf{X} \\leq 100$.\n- $1 \\leq \\mathbf{Y} \\leq 100$.\n\n**Test Set 2 (11 Pts, Visible Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{S} \\leq 1000$.\n- $1 \\leq \\mathbf{X} \\leq 100$.\n- $1 \\leq \\mathbf{Y} \\leq 100$.\n\n**Extra credit!**\n\nWhat if some copyright holders could pay Cody-Jamal for the advertisement instead of being paid? Cody-Jamal getting paid is represented by a negative cost.\n\n**Test Set 3 (1 Pts, Hidden Verdict)**\n\n- $1 < $ the length of $\\mathbf{S} < 1000$.\n- $-100 \\leq \\mathbf{X} \\leq 100$.\n- $-100 \\leq \\mathbf{Y} \\leq 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 Qualification] Moons and Umbrellas", "background": null, "description": "Cody-Jamal 正在创作他最新的抽象艺术作品：一幅由一排渐亏的月亮和闭合的雨伞组成的壁画。不幸的是，贪婪的版权流氓声称渐亏的月亮看起来像大写字母 C，而闭合的雨伞看起来像字母 J，并且他们拥有 CJ 和 JC 的版权。因此，每当壁画中出现 CJ 时，Cody-Jamal 必须支付 $\\mathbf{X}$，而出现 JC 时则需支付 $\\mathbf{Y}$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sqo2l8si.png)\n\nCody-Jamal 不愿让他们破坏自己的艺术，因此不会更改已经画好的部分。但他决定，可以通过策略性地填充尚未完成的空白部分来最小化版权费用。\n\n例如，如果 `CJ?CC?` 表示壁画的当前状态，其中 `C` 代表渐亏的月亮，`J` 代表闭合的雨伞，而 `?` 代表需要填充为渐亏月亮或闭合雨伞的空白部分。他可以将壁画完成为 `CJCCCC`、`CJCCCJ`、`CJJCCC` 或 `CJJCCJ`。第一种和第三种选择需要支付 $\\mathbf{X} + \\mathbf{Y}$ 的版权费用，而第二种和第四种则需要支付 $2 \\cdot \\mathbf{X} + \\mathbf{Y}$。\n\n给定费用 $\\mathbf{X}$ 和 $\\mathbf{Y}$ 以及一个表示壁画当前状态的字符串，如果 Cody-Jamal 以最小化成本的方式完成壁画，他需要支付多少版权费用？", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。接下来是 $\\mathbf{T}$ 行。每行包含两个整数 $\\mathbf{X}$ 和 $\\mathbf{Y}$ 以及一个字符串 $\\mathbf{S}$，分别表示两项费用和壁画的当前状态。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是 Cody-Jamal 在完成壁画后需要支付的最小版权费用。", "hint": "**样例解释**\n\n样例 #1 是题目描述中解释的情况。最小费用为 $\\mathbf{X} + \\mathbf{Y} = 2 + 3 = 5$。\n\n在样例 #2 中，Cody-Jamal 已经完成了壁画，因此无法选择。壁画中有两个 `CJ` 和一个 `JC`。\n\n在样例 #3 中，无论是将 `?` 替换为 `C` 还是 `J`，都会在第二和第三个字符或第一和第二个字符之间形成一个 `CJ`。\n\n在样例 #4 中，Cody-Jamal 可以将壁画全部填充为 `J`。由于这既不包含 `CJ` 也不包含 `JC`，因此不需要支付版权费用。\n\n以下附加样例 2 符合测试集 3 的限制，但不会在提交的解决方案中运行。\n\n在测试集 3 的样例 #1 中，Cody-Jamal 可以最优地将壁画完成为 `JCJJCC` 或 `JCJJJC`。无论哪种方式，壁画中都有一个 `CJ` 和两个 `JC`。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $\\mathbf{S}$ 中的每个字符为 $\\mathbf{C}$、$\\mathbf{J}$ 或 $\\mathbf{?}$。\n\n**测试集 1（5 分，可见判定结果）**\n\n- $1 \\leq \\mathbf{S}$ 的长度 $\\leq 10$。\n- $1 \\leq \\mathbf{X} \\leq 100$。\n- $1 \\leq \\mathbf{Y} \\leq 100$。\n\n**测试集 2（11 分，可见判定结果）**\n\n- $1 \\leq \\mathbf{S}$ 的长度 $\\leq 1000$。\n- $1 \\leq \\mathbf{X} \\leq 100$。\n- $1 \\leq \\mathbf{Y} \\leq 100$。\n\n**额外奖励！**\n\n如果某些版权持有者反而会支付 Cody-Jamal 广告费而不是向他收费呢？Cody-Jamal 获得报酬的情况用负成本表示。\n\n**测试集 3（1 分，隐藏判定结果）**\n\n- $1 < \\mathbf{S}$ 的长度 $< 1000$。\n- $-100 \\leq \\mathbf{X} \\leq 100$。\n- $-100 \\leq \\mathbf{Y} \\leq 100$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13023", "type": "P", "difficulty": 3, "samples": [["5\n4 6\n2 1\n7 12\n7 2\n2 1000", "Case #1: 4 2 1 3\nCase #2: 1 2\nCase #3: 7 6 5 4 3 2 1\nCase #4: IMPOSSIBLE\nCase #5: IMPOSSIBLE"]], "limits": {"time": [10000, 10000, 10000], "memory": [1048576, 1048576, 1048576]}, "tags": ["贪心", "2021", "Special Judge", "Google Code Jam"], "title": "[GCJ 2021 Qualification] Reversort Engineering", "background": "", "description": "**Note: The main parts of the statements of the problems \"Reversort\" and \"Reversort Engineering\" are identical, except for the last paragraph. The problems can otherwise be solved independently.**\n\nReversort is an algorithm to sort a list of distinct integers in increasing order. The algorithm is based on the \"Reverse\" operation. Each application of this operation reverses the order of some contiguous part of the list.\n\nThe pseudocode of the algorithm is the following:\n\n```\nReversort(L):\n  for i := 1 to length(L) - 1\n    j := position with the minimum value in L between i and length(L), inclusive\n    Reverse(L[i..j])\n```\n\nAfter $i - 1$ iterations, the positions $1$, $2$, $\\ldots$, $i - 1$ of the list contain the $i - 1$ smallest elements of $L$, in increasing order. During the $i$-th iteration, the process reverses the sublist going from the $i$-th position to the current position of the $i$-th minimum element. That makes the $i$-th minimum element end up in the $i$-th position.\n\nFor example, for a list with $4$ elements, the algorithm would perform $3$ iterations. Here is how it would process $L = [4, 2, 1, 3]$:\n\n1. $i = 1$, $j = 3 \\longrightarrow L = [1, 2, 4, 3]$\n2. $i = 2$, $j = 2 \\longrightarrow L = [1, 2, 4, 3]$\n3. $i = 3$, $j = 4 \\longrightarrow L = [1, 2, 3, 4]$\n\nThe most expensive part of executing the algorithm on our architecture is the Reverse operation. Therefore, our measure for the cost of each iteration is simply the length of the sublist passed to Reverse, that is, the value $j - i + 1$. The cost of the whole algorithm is the sum of the costs of each iteration.\n\nIn the example above, the iterations cost $3$, $1$, and $2$, in that order, for a total of $6$.\n\nYou are given a size $N$ and a cost $C$. Find a list of $N$ distinct integers between $1$ and $N$ such that the cost of applying Reversort to it is exactly $C$, or say that there is no such list.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line describes a test case with two integers $\\mathbf{N}$ and $\\mathbf{C}$, the size of the wanted list and the desired cost, respectively.\n", "outputFormat": "For each test case, if there is no list of size $\\mathbf{N}$ such that applying Reversort to it costs exactly $\\mathbf{C}$, output one line containing Case #$x$: IMPOSSIBLE, where $x$ is the test case number (starting from 1). Otherwise, output one line containing Case #$x$: $y_1$ $y_2$ $\\ldots$ $y_{\\mathbf{N}}$, where $x$ is the test case number (starting from 1) and each $y_i$ is a distinct integer between 1 and $\\mathbf{N}$, representing the $i$-th element of one such possible list.\n\nIf there are multiple solutions, you may output any one of them.", "hint": "**Sample Explanation**\n\nSample Case #1 is described in the statement above.\n\nIn Sample Case #2, the algorithm runs for only one iteration on the proposed output. In that iteration, reverse is applied to a sublist of size 1, therefore, its cost is 1.\n\nIn Sample Case #3, the first iteration reverses the full list, for a cost of 7. After that, the list is already sorted, but there are 5 more iterations, each of which contributes a cost of 1. Another valid output would be 7 5 4 3 2 1 6. For that output, the first iteration has a cost of 6, the last one has a cost of 2, and all others have a cost of 1.\n\nIn Sample Case #4, Reversort will necessarily perform 6 iterations, each of which will have a cost of at least 1, so there is no way the total cost can be as low as required.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{C} \\leq 1000$.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 7$.\n\n**Test Set 2 (11 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 Qualification] Reversort Engineering", "background": "", "description": "**Note: The main parts of the statements of the problems \"Reversort\" and \"Reversort Engineering\" are identical, except for the last paragraph. The problems can otherwise be solved independently.**\n\nReversort is an algorithm to sort a list of distinct integers in increasing order. The algorithm is based on the \"Reverse\" operation. Each application of this operation reverses the order of some contiguous part of the list.\n\nThe pseudocode of the algorithm is the following:\n\n```\nReversort(L):\n  for i := 1 to length(L) - 1\n    j := position with the minimum value in L between i and length(L), inclusive\n    Reverse(L[i..j])\n```\n\nAfter $i - 1$ iterations, the positions $1$, $2$, $\\ldots$, $i - 1$ of the list contain the $i - 1$ smallest elements of $L$, in increasing order. During the $i$-th iteration, the process reverses the sublist going from the $i$-th position to the current position of the $i$-th minimum element. That makes the $i$-th minimum element end up in the $i$-th position.\n\nFor example, for a list with $4$ elements, the algorithm would perform $3$ iterations. Here is how it would process $L = [4, 2, 1, 3]$:\n\n1. $i = 1$, $j = 3 \\longrightarrow L = [1, 2, 4, 3]$\n2. $i = 2$, $j = 2 \\longrightarrow L = [1, 2, 4, 3]$\n3. $i = 3$, $j = 4 \\longrightarrow L = [1, 2, 3, 4]$\n\nThe most expensive part of executing the algorithm on our architecture is the Reverse operation. Therefore, our measure for the cost of each iteration is simply the length of the sublist passed to Reverse, that is, the value $j - i + 1$. The cost of the whole algorithm is the sum of the costs of each iteration.\n\nIn the example above, the iterations cost $3$, $1$, and $2$, in that order, for a total of $6$.\n\nYou are given a size $N$ and a cost $C$. Find a list of $N$ distinct integers between $1$ and $N$ such that the cost of applying Reversort to it is exactly $C$, or say that there is no such list.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line describes a test case with two integers $\\mathbf{N}$ and $\\mathbf{C}$, the size of the wanted list and the desired cost, respectively.\n", "outputFormat": "For each test case, if there is no list of size $\\mathbf{N}$ such that applying Reversort to it costs exactly $\\mathbf{C}$, output one line containing Case #$x$: IMPOSSIBLE, where $x$ is the test case number (starting from 1). Otherwise, output one line containing Case #$x$: $y_1$ $y_2$ $\\ldots$ $y_{\\mathbf{N}}$, where $x$ is the test case number (starting from 1) and each $y_i$ is a distinct integer between 1 and $\\mathbf{N}$, representing the $i$-th element of one such possible list.\n\nIf there are multiple solutions, you may output any one of them.", "hint": "**Sample Explanation**\n\nSample Case #1 is described in the statement above.\n\nIn Sample Case #2, the algorithm runs for only one iteration on the proposed output. In that iteration, reverse is applied to a sublist of size 1, therefore, its cost is 1.\n\nIn Sample Case #3, the first iteration reverses the full list, for a cost of 7. After that, the list is already sorted, but there are 5 more iterations, each of which contributes a cost of 1. Another valid output would be 7 5 4 3 2 1 6. For that output, the first iteration has a cost of 6, the last one has a cost of 2, and all others have a cost of 1.\n\nIn Sample Case #4, Reversort will necessarily perform 6 iterations, each of which will have a cost of at least 1, so there is no way the total cost can be as low as required.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{C} \\leq 1000$.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 7$.\n\n**Test Set 2 (11 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 Qualification] Reversort Engineering", "background": "", "description": "**注意：问题 \"Reversort\" 和 \"Reversort Engineering\" 的题目描述主体部分相同，仅最后一段不同。这两个问题可以独立解决。**\n\nReversort 是一种用于将**互不相同**的整数列表按升序排序的算法。该算法基于 \"Reverse\" 操作，每次应用该操作会反转列表中某个连续部分的顺序。\n\n算法的伪代码如下：\n\n```\nReversort(L):\n  for i := 1 to length(L) - 1\n    j := position with the minimum value in L between i and length(L), inclusive\n    Reverse(L[i..j])\n```\n\n经过 $i - 1$ 次迭代后，列表的第 $1$, $2$, $\\ldots$, $i - 1$ 个位置将包含 $L$ 中前 $i - 1$ 小的元素，并按升序排列。在第 $i$ 次迭代中，算法会反转从第 $i$ 个位置到当前第 $i$ 小元素所在位置的子列表。这将使第 $i$ 小的元素最终位于第 $i$ 个位置。\n\n例如，对于一个包含 $4$ 个元素的列表，算法将执行 $3$ 次迭代。以下是处理 $L = [4, 2, 1, 3]$ 的过程：\n\n1. $i = 1$, $j = 3 \\longrightarrow L = [1, 2, 4, 3]$\n2. $i = 2$, $j = 2 \\longrightarrow L = [1, 2, 4, 3]$\n3. $i = 3$, $j = 4 \\longrightarrow L = [1, 2, 3, 4]$\n\n在我们的架构中，执行该算法最耗时的部分是 Reverse 操作。因此，我们衡量每次迭代成本的标准仅仅是传递给 Reverse 的子列表长度，即 $j - i + 1$。整个算法的成本是每次迭代成本的总和。\n\n在上述示例中，迭代成本依次为 $3$、$1$ 和 $2$，总成本为 $6$。\n\n现在给定列表大小 $N$ 和目标成本 $C$。请找出一个由 $1$ 到 $N$ 的 $N$ 个不同整数组成的列表，使得对其应用 Reversort 的成本恰好为 $C$，或者判定这样的列表不存在。\n", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。接下来是 $\\mathbf{T}$ 行。每行描述一个测试用例，包含两个整数 $\\mathbf{N}$ 和 $\\mathbf{C}$，分别表示目标列表的大小和期望成本。\n", "outputFormat": "对于每个测试用例，如果不存在大小为 $\\mathbf{N}$ 且应用 Reversort 后成本恰好为 $\\mathbf{C}$ 的列表，则输出一行 Case #$x$: IMPOSSIBLE，其中 $x$ 是测试用例编号（从 1 开始）。否则，输出一行 Case #$x$: $y_1$ $y_2$ $\\ldots$ $y_{\\mathbf{N}}$，其中 $x$ 是测试用例编号（从 1 开始），每个 $y_i$ 是 $1$ 到 $\\mathbf{N}$ 之间的不同整数，表示一个可能列表的第 $i$ 个元素。\n\n如果存在多个解，可以输出其中任意一个。", "hint": "**样例解释**\n\n样例 #1 已在题目描述中说明。\n\n在样例 #2 中，算法在所提出的输出上仅运行一次迭代。在该次迭代中，reverse 操作应用于长度为 1 的子列表，因此其成本为 1。\n\n在样例 #3 中，第一次迭代反转了整个列表，成本为 7。此后列表已排序，但仍有 5 次迭代，每次成本为 1。另一个有效输出是 7 5 4 3 2 1 6。对于该输出，第一次迭代的成本为 6，最后一次的成本为 2，其余每次的成本为 1。\n\n在样例 #4 中，Reversort 必然执行 6 次迭代，每次迭代的成本至少为 1，因此无法达到要求的低总成本。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{C} \\leq 1000$。\n\n**测试集 1（7 分，可见判定结果）**\n\n- $2 \\leq \\mathbf{N} \\leq 7$。\n\n**测试集 2（11 分，可见判定结果）**\n\n- $2 \\leq \\mathbf{N} \\leq 100$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13024", "type": "P", "difficulty": 5, "samples": [["2 5 600\n\n2\n\n3\n\n4\n\n1\n\n3\n\n4\n\n5\n\n1", "\n1 2 3\n\n4 2 3\n\n5 4 3\n\n5 4 3 2 1\n\n1 2 3\n\n2 3 4\n\n3 4 5\n\n1 3 5 4 2"]], "limits": {"time": [40000, 40000, 40000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2021", "三分", "交互题", "Special Judge", "Google Code Jam"], "title": "[GCJ 2021 Qualification] Median Sort", "background": "", "description": "You want to sort $\\mathbf{N}$ distinct items, $x_1$, $x_2$, $\\ldots$, $x_{\\mathbf{N}}$. Unfortunately, you do not have a way of comparing two of these items. You only have a way to, given three of them, find out which one is the median, that is, which one is neither the minimum nor the maximum among the three.\n\nFor example, suppose $\\mathbf{N} = 5$ and you know that:\n\n* $x_1$ is the median of $\\{x_1, x_2, x_3\\}$\n* $x_2$ is the median of $\\{x_2, x_3, x_4\\}$\n* $x_3$ is the median of $\\{x_3, x_4, x_5\\}$\n\nThen, it is guaranteed that the sorted order of the elements is either $x_4, x_2, x_1, x_3, x_5$ or its reverse $x_5, x_3, x_1, x_2, x_4$. Notice that by knowing only medians, it is impossible to distinguish the order of any list from its reverse, since the median question has the same result for any three elements in both cases.\n\nYour program will have to find the order of $\\mathbf{T}$ lists of $\\mathbf{N}$ elements using at most $\\mathbf{Q}$ median questions in total (or $\\mathbf{Q}/\\mathbf{T}$ queries per list on average). In each case, finding either the right order or its reverse is considered correct. The order for each case is generated uniformly at random from all possible orders, and independently of any other information.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, the judge will send you a single line containing three integers $\\mathbf{T}$, $\\mathbf{N}$, and $\\mathbf{Q}$: the number of test cases, the number of elements to sort within each test case, and the total number of questions you are allowed across all test cases, respectively. Then, you must process $\\mathbf{T}$ test cases. Each test case consists of a series of question exchanges plus an additional exchange to provide the answer.\n\nFor a question exchange, your program must print a single line containing three distinct integers $i$, $j$, $k$ all between 1 and $\\mathbf{N}$, inclusive, which corresponds to asking the judge \"which element is the median of the set $\\{x_i, x_j, x_k\\}$?\" The judge will respond with a single line containing a single integer $\\mathbf{L}$, meaning that the median of that set is $x_{\\mathbf{L}}$ ($\\mathbf{L}$ is always equal to one of $i$, $j$, or $k$). If you try to perform a $(\\mathbf{Q} + 1)$-th question exchange, the judge will simply output -1.\n\nOnce you are ready to state the result, print a line containing $\\mathbf{N}$ integers representing the indices of the elements in sorted or reverse sorted order. The judge will respond with a single integer 1 if your answer is correct or -1 if it is not. After receiving the judge's answer for the $\\mathbf{T}$-th case, your program must finish in time in order to not receive a Time Limit Exceeded error. In addition, if you print additional information after receiving the result for the $\\mathbf{T}$-th case, you will get a Wrong Answer judgment.\n\nIf the judge receives an invalidly formatted line or invalid values from your program at any moment, the judge will print a single number -1. After the judge prints -1 for any of the reasons explained above, it will not print any further output. If your program continues to wait for the judge after receiving a -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "You can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our interactive runner for that. For more information, read the instructions in comments in that file, and also check out the Interactive Problems section of the FAQ.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $\\mathbf{T} = 100$.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- $\\mathbf{N} = 10$.\n- $\\mathbf{Q} = 300 \\cdot \\mathbf{T}$.\n\n**Test Set 2 (11 Pts, Visible Verdict)**\n\n- $\\mathbf{N} = 50$.\n- $\\mathbf{Q} = 300 \\cdot \\mathbf{T}$.\n\n**Test Set 3 (10 Pts, Hidden Verdict)**\n\n- $\\mathbf{N} = 50$.\n- $\\mathbf{Q} = 170 \\cdot \\mathbf{T}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 Qualification] Median Sort", "background": "", "description": "You want to sort $\\mathbf{N}$ distinct items, $x_1$, $x_2$, $\\ldots$, $x_{\\mathbf{N}}$. Unfortunately, you do not have a way of comparing two of these items. You only have a way to, given three of them, find out which one is the median, that is, which one is neither the minimum nor the maximum among the three.\n\nFor example, suppose $\\mathbf{N} = 5$ and you know that:\n\n* $x_1$ is the median of $\\{x_1, x_2, x_3\\}$\n* $x_2$ is the median of $\\{x_2, x_3, x_4\\}$\n* $x_3$ is the median of $\\{x_3, x_4, x_5\\}$\n\nThen, it is guaranteed that the sorted order of the elements is either $x_4, x_2, x_1, x_3, x_5$ or its reverse $x_5, x_3, x_1, x_2, x_4$. Notice that by knowing only medians, it is impossible to distinguish the order of any list from its reverse, since the median question has the same result for any three elements in both cases.\n\nYour program will have to find the order of $\\mathbf{T}$ lists of $\\mathbf{N}$ elements using at most $\\mathbf{Q}$ median questions in total (or $\\mathbf{Q}/\\mathbf{T}$ queries per list on average). In each case, finding either the right order or its reverse is considered correct. The order for each case is generated uniformly at random from all possible orders, and independently of any other information.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, the judge will send you a single line containing three integers $\\mathbf{T}$, $\\mathbf{N}$, and $\\mathbf{Q}$: the number of test cases, the number of elements to sort within each test case, and the total number of questions you are allowed across all test cases, respectively. Then, you must process $\\mathbf{T}$ test cases. Each test case consists of a series of question exchanges plus an additional exchange to provide the answer.\n\nFor a question exchange, your program must print a single line containing three distinct integers $i$, $j$, $k$ all between 1 and $\\mathbf{N}$, inclusive, which corresponds to asking the judge \"which element is the median of the set $\\{x_i, x_j, x_k\\}$?\" The judge will respond with a single line containing a single integer $\\mathbf{L}$, meaning that the median of that set is $x_{\\mathbf{L}}$ ($\\mathbf{L}$ is always equal to one of $i$, $j$, or $k$). If you try to perform a $(\\mathbf{Q} + 1)$-th question exchange, the judge will simply output -1.\n\nOnce you are ready to state the result, print a line containing $\\mathbf{N}$ integers representing the indices of the elements in sorted or reverse sorted order. The judge will respond with a single integer 1 if your answer is correct or -1 if it is not. After receiving the judge's answer for the $\\mathbf{T}$-th case, your program must finish in time in order to not receive a Time Limit Exceeded error. In addition, if you print additional information after receiving the result for the $\\mathbf{T}$-th case, you will get a Wrong Answer judgment.\n\nIf the judge receives an invalidly formatted line or invalid values from your program at any moment, the judge will print a single number -1. After the judge prints -1 for any of the reasons explained above, it will not print any further output. If your program continues to wait for the judge after receiving a -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "You can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our interactive runner for that. For more information, read the instructions in comments in that file, and also check out the Interactive Problems section of the FAQ.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $\\mathbf{T} = 100$.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- $\\mathbf{N} = 10$.\n- $\\mathbf{Q} = 300 \\cdot \\mathbf{T}$.\n\n**Test Set 2 (11 Pts, Visible Verdict)**\n\n- $\\mathbf{N} = 50$.\n- $\\mathbf{Q} = 300 \\cdot \\mathbf{T}$.\n\n**Test Set 3 (10 Pts, Hidden Verdict)**\n\n- $\\mathbf{N} = 50$.\n- $\\mathbf{Q} = 170 \\cdot \\mathbf{T}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 Qualification] Median Sort", "background": "", "description": "你需要对 $\\mathbf{N}$ 个互不相同的元素 $x_1$, $x_2$, $\\ldots$, $x_{\\mathbf{N}}$ 进行排序。但遗憾的是，你无法直接比较任意两个元素。你只能通过一种方式：给定三个元素，找出其中的中位数（即既不是最小值也不是最大值的那个元素）。\n\n例如，假设 $\\mathbf{N} = 5$，并且你知道：\n* $x_1$ 是 $\\{x_1, x_2, x_3\\}$ 的中位数\n* $x_2$ 是 $\\{x_2, x_3, x_4\\}$ 的中位数\n* $x_3$ 是 $\\{x_3, x_4, x_5\\}$ 的中位数\n\n那么可以确定，元素的排序结果要么是 $x_4, x_2, x_1, x_3, x_5$，要么是其逆序 $x_5, x_3, x_1, x_2, x_4$。注意，仅通过中位数信息无法区分一个列表与其逆序，因为对于任意三个元素，中位数的结果在这两种情况下是相同的。\n\n你的程序需要在最多 $\\mathbf{Q}$ 次中位数询问的总次数内（平均每个列表 $\\mathbf{Q}/\\mathbf{T}$ 次询问），找出 $\\mathbf{T}$ 个 $\\mathbf{N}$ 元素列表的顺序。对于每个测试用例，只要给出的顺序是正确的或其逆序，都被认为是正确答案。每个测试用例的顺序是从所有可能顺序中均匀随机生成的，且与其他信息无关。\n\n### 交互协议\n\n这是一个交互式问题。\n\n初始时，评测机将发送一行包含三个整数 $\\mathbf{T}$、$\\mathbf{N}$ 和 $\\mathbf{Q}$：分别表示测试用例的数量、每个测试用例中需要排序的元素数量，以及允许在所有测试用例中进行的总询问次数。然后，你需要处理 $\\mathbf{T}$ 个测试用例。每个测试用例包含一系列询问交互以及一个额外的回答交互。\n\n对于询问交互，你的程序需要输出一行包含三个介于 1 和 $\\mathbf{N}$ 之间的不同整数 $i$、$j$、$k$，表示询问评测机\"集合 $\\{x_i, x_j, x_k\\}$ 的中位数是哪个元素？\"。评测机将回复一个整数 $\\mathbf{L}$，表示该集合的中位数是 $x_{\\mathbf{L}}$（$\\mathbf{L}$ 总是等于 $i$、$j$ 或 $k$ 之一）。如果你尝试进行第 $(\\mathbf{Q} + 1)$ 次询问，评测机将输出 -1。\n\n当你准备好提交结果时，输出一行包含 $\\mathbf{N}$ 个整数，表示元素按升序或降序排列的索引。评测机将回复一个整数 1 表示答案正确，或 -1 表示错误。在接收到第 $\\mathbf{T}$ 个测试用例的评测结果后，你的程序必须及时结束以避免超时错误。此外，如果在接收到第 $\\mathbf{T}$ 个测试用例的结果后继续输出，将被判为错误答案。\n\n如果评测机在任何时候接收到格式错误或无效的值，它将输出 -1。在输出 -1 后，评测机将不再输出任何内容。如果你的程序在接收到 -1 后继续等待评测机输出，将会因超时而收到 Time Limit Exceeded 错误。注意，确保程序及时退出以避免超时错误是你的责任。如果内存超出限制或程序运行时出错，将收到相应的判定结果。", "inputFormat": "参见交互协议。", "outputFormat": "参见交互协议。", "hint": "你可以使用此测试工具在本地或我们的平台上进行测试。要在本地测试，你需要同时运行工具和你的代码；可以使用我们的[交互式运行器](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)。更多信息请参阅该文件注释中的说明，并查看 FAQ 的交互式问题部分。\n\n测试工具的说明包含在工具的注释中。我们建议你添加自己的测试用例。请注意，尽管测试工具旨在模拟评测系统，但它**并非**真实的评测系统，行为可能有所不同。\n\n**数据范围**\n\n- $\\mathbf{T} = 100$。\n\n**测试集 1（7 分，可见判定结果）**\n\n- $\\mathbf{N} = 10$。\n- $\\mathbf{Q} = 300 \\cdot \\mathbf{T}$。\n\n**测试集 2（11 分，可见判定结果）**\n\n- $\\mathbf{N} = 50$。\n- $\\mathbf{Q} = 300 \\cdot \\mathbf{T}$。\n\n**测试集 3（10 分，隐藏判定结果）**\n\n- $\\mathbf{N} = 50$。\n- $\\mathbf{Q} = 170 \\cdot \\mathbf{T}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13025", "type": "P", "difficulty": 5, "samples": [["Use the download button above to view the full sample input.", "Use the download button above to view the full sample input."]], "limits": {"time": [60000, 60000], "memory": [1048576, 1048576]}, "tags": ["2021", "Special Judge", "概率论", "Google Code Jam"], "title": "[GCJ 2021 Qualification] Cheating Detection", "background": "", "description": "100 players are competing in a 10000-question trivia tournament; the players are numbered from 1 to 100. Player $i$ has a skill level of $S_i$ and question $j$ has a difficulty level of $Q_j$. Each skill level and each question difficulty are chosen uniformly at random from the range $[-3.00, 3.00]$, and independently of all other choices. For example, a player can have a skill level of 2.47853 and a question can have a difficulty level of -1.4172.\n\nWhen player $i$ tries to answer question $j$, the probability that they answer it correctly is $f(S_i - Q_j)$, where $f$ is the sigmoid function:\n\n$$f(x) = \\frac{1}{1 + e^{-x}}$$\n\nwhere $e$ is Euler's number (approximately 2.718...), the mathematical constant. Notice that $0 < f(x) < 1$ for all $x$, so $f(S_i - Q_j)$ is always a valid probability. Each of these answer attempts is chosen at random independently of all other choices.\n\nThere is one exception: exactly one of the players is a cheater! The cheater is chosen uniformly at random from among all players, and independently of all other choices. The cheater behaves as follows: before answering each question, they flip a fair coin. If it comes up heads, they do not cheat and the rules work as normal. If it comes up tails, they secretly look up the answer on the Internet and answer the question correctly. Formally, they decide whether to cheat at random with 0.5 probability for each question, independently of all other choices.\n\nThe results of a tournament consist of only the per-question results (correct or incorrect) for each player. Apart from the general description above, you do not know anything about the skill levels of the players or the difficulties of the questions.\n\nYou must correctly identify the cheater in at least $\\mathbf{P}$ percent of the test cases. That is, you must succeed in at least $\\mathbf{P} \\cdot \\mathbf{T}/100$ out of $\\mathbf{T}$ cases.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. The second line of the input gives the percentage of test cases, $\\mathbf{P}$, that you must answer correctly for your solution to be considered correct. $\\mathbf{T}$ test cases follow. Each case consists of 100 lines of 10000 characters each. The $j$-th character on the $i$-th line is $1$ if the $i$-th player answered the $j$-th question correctly, or $0$ if they answered it incorrectly.", "outputFormat": "For each test case, output one line containing Case #$x$: $y$, where $x$ is the test case number (starting from 1) and $y$ is the number of the cheater (with player numbers starting from 1).", "hint": "**Sample Explanation**\n\nNotice that the sample input uses $\\mathbf{T} = 1$ and $\\mathbf{P} = 0$ and therefore does not meet the limits of any test set. The sample output for it is the actual cheater.\n\n**Limits**\n\n- $\\mathbf{T} = 50$.\n\n**Test Set 1 (11 Pts, Visible Verdict)**\n\n- $\\mathbf{P} = 10$.\n\n**Test Set 2 (20 Pts, Visible Verdict)**\n\n- $\\mathbf{P} = 86$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 Qualification] Cheating Detection", "background": "", "description": "100 players are competing in a 10000-question trivia tournament; the players are numbered from 1 to 100. Player $i$ has a skill level of $S_i$ and question $j$ has a difficulty level of $Q_j$. Each skill level and each question difficulty are chosen uniformly at random from the range $[-3.00, 3.00]$, and independently of all other choices. For example, a player can have a skill level of 2.47853 and a question can have a difficulty level of -1.4172.\n\nWhen player $i$ tries to answer question $j$, the probability that they answer it correctly is $f(S_i - Q_j)$, where $f$ is the sigmoid function:\n\n$$f(x) = \\frac{1}{1 + e^{-x}}$$\n\nwhere $e$ is Euler's number (approximately 2.718...), the mathematical constant. Notice that $0 < f(x) < 1$ for all $x$, so $f(S_i - Q_j)$ is always a valid probability. Each of these answer attempts is chosen at random independently of all other choices.\n\nThere is one exception: exactly one of the players is a cheater! The cheater is chosen uniformly at random from among all players, and independently of all other choices. The cheater behaves as follows: before answering each question, they flip a fair coin. If it comes up heads, they do not cheat and the rules work as normal. If it comes up tails, they secretly look up the answer on the Internet and answer the question correctly. Formally, they decide whether to cheat at random with 0.5 probability for each question, independently of all other choices.\n\nThe results of a tournament consist of only the per-question results (correct or incorrect) for each player. Apart from the general description above, you do not know anything about the skill levels of the players or the difficulties of the questions.\n\nYou must correctly identify the cheater in at least $\\mathbf{P}$ percent of the test cases. That is, you must succeed in at least $\\mathbf{P} \\cdot \\mathbf{T}/100$ out of $\\mathbf{T}$ cases.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. The second line of the input gives the percentage of test cases, $\\mathbf{P}$, that you must answer correctly for your solution to be considered correct. $\\mathbf{T}$ test cases follow. Each case consists of 100 lines of 10000 characters each. The $j$-th character on the $i$-th line is $1$ if the $i$-th player answered the $j$-th question correctly, or $0$ if they answered it incorrectly.", "outputFormat": "For each test case, output one line containing Case #$x$: $y$, where $x$ is the test case number (starting from 1) and $y$ is the number of the cheater (with player numbers starting from 1).", "hint": "**Sample Explanation**\n\nNotice that the sample input uses $\\mathbf{T} = 1$ and $\\mathbf{P} = 0$ and therefore does not meet the limits of any test set. The sample output for it is the actual cheater.\n\n**Limits**\n\n- $\\mathbf{T} = 50$.\n\n**Test Set 1 (11 Pts, Visible Verdict)**\n\n- $\\mathbf{P} = 10$.\n\n**Test Set 2 (20 Pts, Visible Verdict)**\n\n- $\\mathbf{P} = 86$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 Qualification] Cheating Detection", "background": "", "description": "100 名玩家正在参加一场包含 10000 道问题的问答锦标赛，玩家编号为 1 至 100。玩家 $i$ 拥有技能值 $S_i$，问题 $j$ 拥有难度值 $Q_j$。每个技能值和难度值都是从 $[-3.00, 3.00]$ 范围内均匀随机且独立选取的。例如，某个玩家的技能值可能是 2.47853，而某个问题的难度值可能是 -1.4172。\n\n当玩家 $i$ 尝试回答问题 $j$ 时，其答对的概率为 $f(S_i - Q_j)$，其中 $f$ 是 sigmoid 函数：\n$$f(x) = \\frac{1}{1 + e^{-x}}$$\n这里 $e$ 是自然对数的底（约 2.718...）。注意到对所有 $x$ 都有 $0 < f(x) < 1$，因此 $f(S_i - Q_j)$ 始终是有效的概率值。所有答题行为都是随机且独立进行的。\n\n但有一个例外：这些玩家中**恰好有一个是作弊者**！作弊者是从所有玩家中均匀随机选出的，且与其他选择独立。作弊者的行为如下：在回答每个问题前，他们会抛一枚公平硬币。如果结果为正面，则不作弊并正常答题；如果为反面，则会秘密查阅正确答案并确保答对。形式化地说，他们对每个问题以 0.5 的概率独立决定是否作弊。\n\n锦标赛的结果仅包含每位玩家对每道题目的答题结果（正确或错误）。除了上述描述外，你无法获知任何关于玩家技能值或问题难度的具体信息。\n\n你需要在至少 $\\mathbf{P}$% 的测试用例中正确识别作弊者。也就是说，在 $\\mathbf{T}$ 个测试用例中，你至少要正确判断 $\\mathbf{P} \\cdot \\mathbf{T}/100$ 个。\n", "inputFormat": "输入的第一行给出测试用例数量 $\\mathbf{T}$。第二行给出通过测试所需的正确率 $\\mathbf{P}$。随后是 $\\mathbf{T}$ 个测试用例，每个用例包含 100 行，每行 10000 个字符。第 $i$ 行的第 $j$ 个字符为 $1$ 表示第 $i$ 名玩家答对了第 $j$ 题，为 $0$ 表示答错。\n", "outputFormat": "对于每个测试用例，输出一行 Case #$x$: $y$，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是作弊者的编号（玩家编号从 1 开始）。\n", "hint": "**样例说明**\n\n注意样例输入使用 $\\mathbf{T} = 1$ 和 $\\mathbf{P} = 0$，因此不满足任何测试集的限制条件。其样例输出展示了实际的作弊者编号。\n\n**数据范围**\n\n- $\\mathbf{T} = 50$\n\n**测试集 1（11 分，可见判定）**\n\n- $\\mathbf{P} = 10$\n\n**测试集 2（20 分，可见判定）**\n\n- $\\mathbf{P} = 86$\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13026", "type": "P", "difficulty": 3, "samples": [["4\n3\n100 7 10\n2\n10 10\n3\n4 19 1\n3\n1 2 3", "Case #1: 4\nCase #2: 1\nCase #3: 2\nCase #4: 0"]], "limits": {"time": [10000, 10000, 10000], "memory": [1048576, 1048576, 1048576]}, "tags": ["贪心", "2021", "Google Code Jam"], "title": "[GCJ 2021 #1A] Append Sort\t", "background": "", "description": "We have a list of integers $X_1, X_2, \\ldots, X_N$. We would like them to be in strictly increasing order, but unfortunately, we cannot reorder them. This means that usual sorting algorithms will not work.\n\nOur only option is to change them by appending digits $0$ through $9$ to their right (in base $10$). For example, if one of the integers is $10$, you can turn it into $100$ or $109$ with a single append operation, or into $1034$ with two operations (as seen in the image below).\n\nGiven the current list, what is the minimum number of single digit append operations that are necessary for the list to be in strictly increasing order?\n\nFor example, if the list is $100, 7, 10$, we can use $4$ total operations to make it into a sorted list, as the following image shows.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x5uxrlzd.png)", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case is described in two lines. The first line of a test case contains a single integer $\\mathbf{N}$, the number of integers in the list. The second line contains $\\mathbf{N}$ integers $\\mathbf{X}_1, \\mathbf{X}_2, \\ldots, \\mathbf{X}_\\mathbf{N}$, the members of the list.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of single digit append operations needed for the list to be in strictly increasing order.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the input is the same as in the example given in the problem statement. As the image shows, the list can be turned into a sorted list with 4 operations. Notice that the last two integers need to end up with at least 3 digits (requiring at least 3 append operations in total). If all of the final numbers had exactly three digits, the second would be larger than the third because it starts with a 7 instead of a 1. This means we cannot do it with fewer than 4 operations.\n\nIn Sample Case #2, notice that the list needs to be in strictly increasing order, so we have to do at least one operation. In this case, any valid append operation to the second integer works.\n\nIn Sample Case #3, we can use two append operations to get the list to 4, 19, 193.\n\nIn Sample Case #4, the given list is already in strictly increasing order, so no operations are necessary.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\n**Test Set 1 (12 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 3$.\n- $1 \\leq \\mathbf{X}_i \\leq 100$, for all $i$.\n\n**Test Set 2 (14 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 100$.\n- $1 \\leq \\mathbf{X}_i \\leq 10^9$, for all $i$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #1A] Append Sort\t", "background": "", "description": "We have a list of integers $X_1, X_2, \\ldots, X_N$. We would like them to be in strictly increasing order, but unfortunately, we cannot reorder them. This means that usual sorting algorithms will not work.\n\nOur only option is to change them by appending digits $0$ through $9$ to their right (in base $10$). For example, if one of the integers is $10$, you can turn it into $100$ or $109$ with a single append operation, or into $1034$ with two operations (as seen in the image below).\n\nGiven the current list, what is the minimum number of single digit append operations that are necessary for the list to be in strictly increasing order?\n\nFor example, if the list is $100, 7, 10$, we can use $4$ total operations to make it into a sorted list, as the following image shows.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x5uxrlzd.png)", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case is described in two lines. The first line of a test case contains a single integer $\\mathbf{N}$, the number of integers in the list. The second line contains $\\mathbf{N}$ integers $\\mathbf{X}_1, \\mathbf{X}_2, \\ldots, \\mathbf{X}_\\mathbf{N}$, the members of the list.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of single digit append operations needed for the list to be in strictly increasing order.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the input is the same as in the example given in the problem statement. As the image shows, the list can be turned into a sorted list with 4 operations. Notice that the last two integers need to end up with at least 3 digits (requiring at least 3 append operations in total). If all of the final numbers had exactly three digits, the second would be larger than the third because it starts with a 7 instead of a 1. This means we cannot do it with fewer than 4 operations.\n\nIn Sample Case #2, notice that the list needs to be in strictly increasing order, so we have to do at least one operation. In this case, any valid append operation to the second integer works.\n\nIn Sample Case #3, we can use two append operations to get the list to 4, 19, 193.\n\nIn Sample Case #4, the given list is already in strictly increasing order, so no operations are necessary.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\n**Test Set 1 (12 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 3$.\n- $1 \\leq \\mathbf{X}_i \\leq 100$, for all $i$.\n\n**Test Set 2 (14 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 100$.\n- $1 \\leq \\mathbf{X}_i \\leq 10^9$, for all $i$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #1A] Append Sort", "background": "", "description": "我们有一个整数列表 $X_1, X_2, \\ldots, X_N$。我们希望它们能按**严格递增**的顺序排列，但遗憾的是不能直接重新排序。这意味着常规的排序算法无法使用。\n\n我们唯一的操作是在这些数字的右侧（十进制下）追加数字 $0$ 到 $9$。例如，若某数字是 $10$，通过一次追加操作可以变为 $100$ 或 $109$，通过两次操作可变为 $1034$（如下图所示）。\n\n给定当前列表，至少需要进行多少次单数字追加操作才能使列表严格递增？\n\n例如，对于列表 $100, 7, 10$，可通过 $4$ 次操作将其变为有序列表，如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x5uxrlzd.png)", "inputFormat": "输入的第一行给出测试用例数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例由两行描述：第一行包含一个整数 $\\mathbf{N}$，表示列表中的数字数量；第二行包含 $\\mathbf{N}$ 个整数 $\\mathbf{X}_1, \\mathbf{X}_2, \\ldots, \\mathbf{X}_\\mathbf{N}$，即列表成员。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为使列表严格递增所需的最少单数字追加操作次数。\n", "hint": "**样例解释**\n\n在样例 #1 中，输入与题目描述中的示例相同。如图所示，需 $4$ 次操作使列表有序。注意最后两个数字最终至少需要 $3$ 位数字（共需至少 $3$ 次追加操作）。若所有数字最终均为 $3$ 位，由于第二个数字以 $7$ 开头而第三个以 $1$ 开头，第二个数字仍会大于第三个，因此无法用少于 $4$ 次操作完成。\n\n在样例 #2 中，由于要求严格递增，必须至少进行 $1$ 次操作。此处对第二个数字追加任意有效数字均可。\n\n在样例 #3 中，可通过 $2$ 次操作将列表变为 $4, 19, 193$。\n\n在样例 #4 中，列表已严格递增，无需操作。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n\n**测试集 1（12 分，可见判定）**\n\n- $2 \\leq \\mathbf{N} \\leq 3$。\n- $1 \\leq \\mathbf{X}_i \\leq 100$（对所有 $i$）。\n\n**测试集 2（14 分，可见判定）**\n\n- $2 \\leq \\mathbf{N} \\leq 100$。\n- $1 \\leq \\mathbf{X}_i \\leq 10^9$（对所有 $i$）。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13027", "type": "P", "difficulty": 4, "samples": [["4\n5\n2 2\n3 1\n5 2\n7 1\n11 1\n1\n17 2\n2\n2 2\n3 1\n1\n2 7", "Case #1: 25\nCase #2: 17\nCase #3: 0\nCase #4: 8"]], "limits": {"time": [45000, 45000, 45000, 45000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "2021", "数论", "枚举", "Google Code Jam"], "title": "[GCJ 2021 #1A] Prime Time", "background": "", "description": "You are playing a new solitaire game called Prime Time. You are given a deck of cards, and each card has a prime number written on it. Multiple cards may have the same number.\n\nYour goal is to divide the cards into two groups in such a way that the sum of the numbers in the first group is equal to the product of the numbers in the second group. Each card must belong to exactly one of the two groups, and each group must contain at least one card. The sum or product of a group that consists of a single card is simply the number on that card.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n1zowb5r.png)\n\nFor example, in the image above, the left group has cards whose sum is $25$ and the right group has cards whose product is $25$. Therefore, this is a valid split into groups.\n\nYour score is the sum of the numbers in the first group (which is equal to the product of the numbers in the second group), or $0$ if you cannot split the cards this way at all. What is the maximum score you can achieve?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of each test case contains a single integer $\\mathbf{M}$, representing the number of distinct prime numbers in your deck. Each of the next $\\mathbf{M}$ lines contains two values: $\\mathbf{P}_i$ and $\\mathbf{N}_i$, representing that you have exactly $\\mathbf{N}_i$ cards with the prime $\\mathbf{P}_i$ written on them.\n\nNote that the total number of cards in your deck is the sum of all $\\mathbf{N}_i$s.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum score you can achieve.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the optimal split is: $11 + 2 + 7 + 3 + 2 = 5 \\cdot 5$. Another split is also possible: $5 + 7 + 3 + 2 + 5 = 11 \\cdot 2$, but it gives a lower score.\n\nIn Sample Case #2, note that cards with the same number can be placed in different groups.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{M} \\leq 95$. (Note that there are exactly 95 distinct primes between 2 and 499)\n- $2 \\leq \\mathbf{P}_i \\leq 499$, for all $i$.\n- Each $\\mathbf{P}_i$ is prime.\n- $\\mathbf{P}_i < \\mathbf{P}_{i+1}$, for all $i$. (The primes are given in strictly increasing order)\n- $1 \\leq \\mathbf{N}_i$, for all $i$.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N}_1 + \\mathbf{N}_2 + \\cdots + \\mathbf{N}_\\mathbf{M} \\leq 10$.\n\n**Test Set 2 (13 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N}_1 + \\mathbf{N}_2 + \\cdots + \\mathbf{N}_\\mathbf{M} \\leq 100$.\n\n**Test Set 3 (15 Pts, Hidden Verdict)**\n\n- $2 \\leq \\mathbf{N}_1 + \\mathbf{N}_2 + \\cdots + \\mathbf{N}_\\mathbf{M} \\leq 10^{15}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #1A] Prime Time", "background": "", "description": "You are playing a new solitaire game called Prime Time. You are given a deck of cards, and each card has a prime number written on it. Multiple cards may have the same number.\n\nYour goal is to divide the cards into two groups in such a way that the sum of the numbers in the first group is equal to the product of the numbers in the second group. Each card must belong to exactly one of the two groups, and each group must contain at least one card. The sum or product of a group that consists of a single card is simply the number on that card.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n1zowb5r.png)\n\nFor example, in the image above, the left group has cards whose sum is $25$ and the right group has cards whose product is $25$. Therefore, this is a valid split into groups.\n\nYour score is the sum of the numbers in the first group (which is equal to the product of the numbers in the second group), or $0$ if you cannot split the cards this way at all. What is the maximum score you can achieve?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of each test case contains a single integer $\\mathbf{M}$, representing the number of distinct prime numbers in your deck. Each of the next $\\mathbf{M}$ lines contains two values: $\\mathbf{P}_i$ and $\\mathbf{N}_i$, representing that you have exactly $\\mathbf{N}_i$ cards with the prime $\\mathbf{P}_i$ written on them.\n\nNote that the total number of cards in your deck is the sum of all $\\mathbf{N}_i$s.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum score you can achieve.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the optimal split is: $11 + 2 + 7 + 3 + 2 = 5 \\cdot 5$. Another split is also possible: $5 + 7 + 3 + 2 + 5 = 11 \\cdot 2$, but it gives a lower score.\n\nIn Sample Case #2, note that cards with the same number can be placed in different groups.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{M} \\leq 95$. (Note that there are exactly 95 distinct primes between 2 and 499)\n- $2 \\leq \\mathbf{P}_i \\leq 499$, for all $i$.\n- Each $\\mathbf{P}_i$ is prime.\n- $\\mathbf{P}_i < \\mathbf{P}_{i+1}$, for all $i$. (The primes are given in strictly increasing order)\n- $1 \\leq \\mathbf{N}_i$, for all $i$.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N}_1 + \\mathbf{N}_2 + \\cdots + \\mathbf{N}_\\mathbf{M} \\leq 10$.\n\n**Test Set 2 (13 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N}_1 + \\mathbf{N}_2 + \\cdots + \\mathbf{N}_\\mathbf{M} \\leq 100$.\n\n**Test Set 3 (15 Pts, Hidden Verdict)**\n\n- $2 \\leq \\mathbf{N}_1 + \\mathbf{N}_2 + \\cdots + \\mathbf{N}_\\mathbf{M} \\leq 10^{15}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #1A] Prime Time", "background": "", "description": "你正在玩一款名为**质数时刻**的新单人纸牌游戏。你有一副卡牌，每张牌上写有一个质数，不同牌可能写有相同的数字。\n\n游戏目标是将所有卡牌分成两组：第一组卡牌上的数字之和等于第二组卡牌上的数字之积。每张牌必须属于其中一组，且每组至少包含一张牌。若某组仅有一张牌，则该组的和或积即为该牌上的数字。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n1zowb5r.png)\n\n例如上图中，左侧卡牌数字之和为 $25$，右侧卡牌数字之积也为 $25$，因此这是一个有效的分组方案。\n\n你的得分等于第一组数字之和（即第二组数字之积），若无法完成这样的分组则得分为 $0$。你能获得的最高得分是多少？\n", "inputFormat": "输入第一行包含测试用例数量 $\\mathbf{T}$。随后每个测试用例包含：\n- 第一行：整数 $\\mathbf{M}$，表示牌堆中不同质数的种类数\n- 接下来 $\\mathbf{M}$ 行：每行两个数 $\\mathbf{P}_i$ 和 $\\mathbf{N}_i$，表示有 $\\mathbf{N}_i$ 张数字为 $\\mathbf{P}_i$ 的卡牌\n\n注意牌堆总卡牌数为所有 $\\mathbf{N}_i$ 之和。", "outputFormat": "对每个测试用例，输出 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为可获得的最大得分。\n", "hint": "**样例解释**\n\n在样例 #1 中，最优分组为 $11 + 2 + 7 + 3 + 2 = 5 \\cdot 5$。另一可行分组 $5 + 7 + 3 + 2 + 5 = 11 \\cdot 2$ 得分较低。\n\n在样例 #2 中，注意相同数字的卡牌可以分到不同组。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$\n- $1 \\leq \\mathbf{M} \\leq 95$（在 2 至 499 之间的质数共 95 个）\n- $2 \\leq \\mathbf{P}_i \\leq 499$（均为质数）\n- $\\mathbf{P}_i < \\mathbf{P}_{i+1}$（质数按严格递增顺序给出）\n- $1 \\leq \\mathbf{N}_i$\n\n**测试集 1（7 分，可见判定）**\n- 总卡牌数 $2 \\leq \\sum \\mathbf{N}_i \\leq 10$\n\n**测试集 2（13 分，可见判定）**\n- 总卡牌数 $2 \\leq \\sum \\mathbf{N}_i \\leq 100$\n\n**测试集 3（15 分，隐藏判定）**\n- 总卡牌数 $2 \\leq \\sum \\mathbf{N}_i \\leq 10^{15}$\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13028", "type": "P", "difficulty": 5, "samples": [["4\n1 3\nFFT 3\n1 3\nFFT 2\n2 6\nFFTTTF 2\nFTFTFT 4\n2 2\nFF 1\nTT 1", "Case #1: FFT 3/1\nCase #2: FFT 2/1\nCase #3: FTFFFT 4/1\nCase #4: TF 1/1"], ["1\n3 120\nFFTFFFTFFFTTTTTTTFTFFFFFFTTTFTFFFTFTFFTTFTFFTFFTTTFTFTFFTFTFTTFFFFTFTFFFFTTTFTTFTTTTFFFTTFFFFFTTFFTFFTFFTTTFFFFTTFFTFTTF 55\nFFFTFFTTFFFFTFTFFTFFFTTTTTTFFFTTTFTTTTFFTFTTTFTTFFTTTFTFFFFTFFTTFFTTFTTFFTFTFFTFTTFTFTFFTTTFFTFTFTTFFTFTFTFTTFFTFFFTFTFT 62\nFFFTFTTFFFFFTFTFTTTTTTFFTTFTFFFTFFTTTTTTFFFTTTFFFTTFTFFFFFFTFTTFFTFTTTFTTTTFTTFFFFTFFTTFTFFTTTTTTFTFFFFFTTFFTFTFTFFTTTTT 64", "Case #1: FFFTFTTTFFFFTFTFFTFTTTTTTTFFFFTTTFTTTTFFTFTTTTTFFFTFTFTFFFFTFFTTFTFTFTTTTTFFTFFFFFFFFTTFTTTTTTFTTTTFFFFTFTFTTFTFFFFTTTFT 189154508532118369075350624633/2901503505434414233388602018"]], "limits": {"time": [30000, 30000, 30000, 30000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2021", "Special Judge", "组合数学", "期望", "Google Code Jam"], "title": "[GCJ 2021 #1A] Hacked Exam", "background": "", "description": "There is an exam with $\\mathbf{Q}$ true or false questions. The correct answer to each question is either $\\mathsf{T}$ or $\\mathsf{F}$. Each student taking the exam selects either $\\mathsf{T}$ or $\\mathsf{F}$ for each question, and the student's score is the number of questions they answer correctly.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jwf5pdvs.png)\n\nThere are $\\mathbf{N}$ students who have already taken this exam. For each of those students, you know the answers they gave to each question and their final score. Assuming that any sequence of answers that is consistent with all of those students' scores has the same probability of being the correct sequence of answers, you want to maximize your own expected score. Determine what that expected score is and how to answer the questions so that you achieve it.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of each test case contains two integers $\\mathbf{N}$ and $\\mathbf{Q}$: the number of students and the number of questions, respectively. Each of the next $\\mathbf{N}$ lines contains a string $\\mathbf{A}_i$ and an integer $\\mathbf{S}_i$: the $i$-th student's answers and their score, respectively. The $j$-th character of $\\mathbf{A}_i$ is either $\\mathsf{T}$ or $\\mathsf{F}$, representing the answer the $i$-th student gave to the $j$-th question.", "outputFormat": "For each test case, output one line containing `Case #x: y z/w`, where $x$ is the test case number (starting from 1), $y$ is a string representing a sequence of answers that yields the maximum expected score (in the same format as the input), and $\\frac{z}{w}$ is the maximum expected score as an irreducible fraction (that is, $w$ must be positive and of minimum possible value).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, given that the score for $\\mathsf{FFT}$ is 3, the sequence of correct answers must be $\\mathsf{FFT}$.\n\nIn Sample Case #2, given that the score for $\\mathsf{FFT}$ is 2, the sequence of correct answers is $\\mathsf{FFF}$, $\\mathsf{FTT}$, or $\\mathsf{TFT}$, each with probability $\\frac{1}{3}$. Your best strategy is to answer $\\mathsf{FFT}$, to achieve the expected score of $\\frac{1}{3} \\times 2 + \\frac{1}{3} \\times 2 + \\frac{1}{3} \\times 2 = 2$.\n\nIn Sample Case #3, there are other answers that also achieve an expected score of 4, like $\\mathsf{FTFTFT}$.\n\nIn Sample Case #4, one of the questions' answer is $\\mathsf{T}$ and the other one is $\\mathsf{F}$, but you do not know which is which. Answering $\\mathsf{TF}$ or $\\mathsf{FT}$ scores you 2 with probability $\\frac{1}{2}$ and 0 with probability $\\frac{1}{2}$, yielding an expected score of 1. Answering $\\mathsf{FF}$ or $\\mathsf{TT}$ guarantees a score of 1. Since any sequence of answers gives the same expected score, you can output any of them.\n\nSample 2 fits the limits of Test Set 3. It will not be run against your submitted solutions.\n\nIn the Sample Case for Test Set 3, you can get an expected score over 65, which is higher than the actual score of any of the other students. Notice that both the numerator and denominator of the expected score can be significantly larger than $2^{64}$ (the numerator in this case actually exceeds $2^{97}$).\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 2021$.\n- The length of $\\mathbf{A}_{\\mathbf{i}}=\\mathbf{Q}$, for all $i$.\n- Each character of $\\mathbf{A}_{\\mathbf{i}}$ is an uppercase $\\mathsf{T}$ or an uppercase $\\mathsf{F}$, for all $i$.\n- $0 \\leq \\mathbf{S}_{\\mathbf{i}} \\leq \\mathbf{Q}$, for all $i$.\n- There exists at least one sequence of correct answers consistent with the input.\n\n**Test Set 1 (8 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 2$.\n- $1 \\leq \\mathbf{Q} \\leq 10$.\n\n**Test Set 2 (6 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 2$.\n- $1 \\leq \\mathbf{Q} \\leq 40$.\n\n**Test Set 3 (25 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 3$.\n- $1 \\leq \\mathbf{Q} \\leq 120$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #1A] Hacked Exam", "background": "", "description": "There is an exam with $\\mathbf{Q}$ true or false questions. The correct answer to each question is either $\\mathsf{T}$ or $\\mathsf{F}$. Each student taking the exam selects either $\\mathsf{T}$ or $\\mathsf{F}$ for each question, and the student's score is the number of questions they answer correctly.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jwf5pdvs.png)\n\nThere are $\\mathbf{N}$ students who have already taken this exam. For each of those students, you know the answers they gave to each question and their final score. Assuming that any sequence of answers that is consistent with all of those students' scores has the same probability of being the correct sequence of answers, you want to maximize your own expected score. Determine what that expected score is and how to answer the questions so that you achieve it.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of each test case contains two integers $\\mathbf{N}$ and $\\mathbf{Q}$: the number of students and the number of questions, respectively. Each of the next $\\mathbf{N}$ lines contains a string $\\mathbf{A}_i$ and an integer $\\mathbf{S}_i$: the $i$-th student's answers and their score, respectively. The $j$-th character of $\\mathbf{A}_i$ is either $\\mathsf{T}$ or $\\mathsf{F}$, representing the answer the $i$-th student gave to the $j$-th question.", "outputFormat": "For each test case, output one line containing `Case #x: y z/w`, where $x$ is the test case number (starting from 1), $y$ is a string representing a sequence of answers that yields the maximum expected score (in the same format as the input), and $\\frac{z}{w}$ is the maximum expected score as an irreducible fraction (that is, $w$ must be positive and of minimum possible value).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, given that the score for $\\mathsf{FFT}$ is 3, the sequence of correct answers must be $\\mathsf{FFT}$.\n\nIn Sample Case #2, given that the score for $\\mathsf{FFT}$ is 2, the sequence of correct answers is $\\mathsf{FFF}$, $\\mathsf{FTT}$, or $\\mathsf{TFT}$, each with probability $\\frac{1}{3}$. Your best strategy is to answer $\\mathsf{FFT}$, to achieve the expected score of $\\frac{1}{3} \\times 2 + \\frac{1}{3} \\times 2 + \\frac{1}{3} \\times 2 = 2$.\n\nIn Sample Case #3, there are other answers that also achieve an expected score of 4, like $\\mathsf{FTFTFT}$.\n\nIn Sample Case #4, one of the questions' answer is $\\mathsf{T}$ and the other one is $\\mathsf{F}$, but you do not know which is which. Answering $\\mathsf{TF}$ or $\\mathsf{FT}$ scores you 2 with probability $\\frac{1}{2}$ and 0 with probability $\\frac{1}{2}$, yielding an expected score of 1. Answering $\\mathsf{FF}$ or $\\mathsf{TT}$ guarantees a score of 1. Since any sequence of answers gives the same expected score, you can output any of them.\n\nSample 2 fits the limits of Test Set 3. It will not be run against your submitted solutions.\n\nIn the Sample Case for Test Set 3, you can get an expected score over 65, which is higher than the actual score of any of the other students. Notice that both the numerator and denominator of the expected score can be significantly larger than $2^{64}$ (the numerator in this case actually exceeds $2^{97}$).\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 2021$.\n- The length of $\\mathbf{A}_{\\mathbf{i}}=\\mathbf{Q}$, for all $i$.\n- Each character of $\\mathbf{A}_{\\mathbf{i}}$ is an uppercase $\\mathsf{T}$ or an uppercase $\\mathsf{F}$, for all $i$.\n- $0 \\leq \\mathbf{S}_{\\mathbf{i}} \\leq \\mathbf{Q}$, for all $i$.\n- There exists at least one sequence of correct answers consistent with the input.\n\n**Test Set 1 (8 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 2$.\n- $1 \\leq \\mathbf{Q} \\leq 10$.\n\n**Test Set 2 (6 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 2$.\n- $1 \\leq \\mathbf{Q} \\leq 40$.\n\n**Test Set 3 (25 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 3$.\n- $1 \\leq \\mathbf{Q} \\leq 120$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #1A] Hacked Exam", "background": "", "description": "一场考试包含 $\\mathbf{Q}$ 道判断题，每道题的正确答案是 $\\mathsf{T}$ 或 $\\mathsf{F}$。每位考生为每道题选择 $\\mathsf{T}$ 或 $\\mathsf{F}$，其得分是答对的题数。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jwf5pdvs.png)\n\n已有 $\\mathbf{N}$ 名学生参加了这场考试。对于每名学生，你知道他们的答案和最终得分。假设所有与学生得分一致的正确答案序列出现的概率相同，你需要最大化自己的期望得分。请确定该期望得分，并给出能达到该得分的答题方案。", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含两个整数 $\\mathbf{N}$ 和 $\\mathbf{Q}$：分别表示学生人数和题目数量。接下来的 $\\mathbf{N}$ 行，每行包含一个字符串 $\\mathbf{A}_i$ 和一个整数 $\\mathbf{S}_i$：分别表示第 $i$ 名学生的答案和得分。$\\mathbf{A}_i$ 的第 $j$ 个字符是 $\\mathsf{T}$ 或 $\\mathsf{F}$，表示第 $i$ 名学生第 $j$ 道题的答案。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y z/w`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是一个字符串，表示能获得最大期望得分的答案序列（格式与输入相同），$\\frac{z}{w}$ 是最大期望得分的最简分数形式（即 $w$ 必须为正且最小）。\n", "hint": "**样例解释**\n\n在样例 #1 中，由于 $\\mathsf{FFT}$ 的得分为 3，正确答案序列必须是 $\\mathsf{FFT}$。\n\n在样例 #2 中，由于 $\\mathsf{FFT}$ 的得分为 2，正确答案序列可能是 $\\mathsf{FFF}$、$\\mathsf{FTT}$ 或 $\\mathsf{TFT}$，每种概率为 $\\frac{1}{3}$。最佳策略是回答 $\\mathsf{FFT}$，期望得分为 $\\frac{1}{3} \\times 2 + \\frac{1}{3} \\times 2 + \\frac{1}{3} \\times 2 = 2$。\n\n在样例 #3 中，其他答案（如 $\\mathsf{FTFTFT}$）也能达到期望得分 4。\n\n在样例 #4 中，一道题的答案是 $\\mathsf{T}$，另一道是 $\\mathsf{F}$，但无法确定顺序。回答 $\\mathsf{TF}$ 或 $\\mathsf{FT}$ 有 $\\frac{1}{2}$ 概率得 2 分，$\\frac{1}{2}$ 概率得 0 分，期望得分为 1。回答 $\\mathsf{FF}$ 或 $\\mathsf{TT}$ 保证得 1 分。由于所有答案序列的期望得分相同，可以输出任意一个。\n\n样例 2 符合测试集 3 的限制。它不会用于测试你的提交。\n\n在测试集 3 的样例中，你可以获得超过 65 的期望得分，高于其他学生的实际得分。注意，期望分数的分子和分母可能远大于 $2^{64}$（此样例的分子实际超过 $2^{97}$）。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 2021$。\n- 对于所有 $i$，$\\mathbf{A}_{\\mathbf{i}}$ 的长度为 $\\mathbf{Q}$。\n- 对于所有 $i$，$\\mathbf{A}_{\\mathbf{i}}$ 的每个字符是大写 $\\mathsf{T}$ 或 $\\mathsf{F}$。\n- 对于所有 $i$，$0 \\leq \\mathbf{S}_{\\mathbf{i}} \\leq \\mathbf{Q}$。\n- 输入至少存在一个一致的正确答案序列。\n\n**测试集 1（8 分，可见评测结果）**\n\n- $1 \\leq \\mathbf{N} \\leq 2$。\n- $1 \\leq \\mathbf{Q} \\leq 10$。\n\n**测试集 2（6 分，隐藏评测结果）**\n\n- $1 \\leq \\mathbf{N} \\leq 2$。\n- $1 \\leq \\mathbf{Q} \\leq 40$。\n\n**测试集 3（25 分，隐藏评测结果）**\n\n- $1 \\leq \\mathbf{N} \\leq 3$。\n- $1 \\leq \\mathbf{Q} \\leq 120$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13029", "type": "P", "difficulty": 4, "samples": [["3\n0 0 0\n0 21600000000000 23400000000000\n1476000000000 2160000000000 3723000000000", "Case #1: 0 0 0 0\nCase #2: 6 30 0 0\nCase #3: 1 2 3 0"], ["3\n5400000000000 5400000000000 5400000000000\n10800000000000 32400000000000 34200000000000\n23076000000000 23760000000000 25323000000000", "Case #1: 0 0 0 0\nCase #2: 0 30 0 0\nCase #3: 1 2 3 0"], ["1\n0 11 719", "Case #1: 0 0 0 1"]], "limits": {"time": [30000, 30000, 30000, 30000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "2021", "Special Judge", "Google Code Jam"], "title": "[GCJ 2021 #1B] Broken Clock", "background": "", "description": "Emmett found an old clock in his attic. The clock is a circle with 3 hands that attach to the center and rotate clockwise at constant speeds. They are called the $hours$ $hand$, the $minutes$ $hand$ and the $seconds$ $hand$. At midnight, all hands point up. The hours hand completes a full revolution in 12 hours, the minutes hand completes a full revolution in 1 hour, and the seconds hand completes a full revolution in 1 minute. 1 hour is equal to 60 minutes, 1 minute is equal to 60 seconds, and 1 second is equal to $10^{9}$ nanoseconds.\n\nFor example, the clock depicted below is showing that the time is exactly 6 hours and 30 minutes after midnight. The hours hand (short black) is halfway between 6 and 7 (completed 6.5/12 of a revolution), the minutes hand (long black) is pointing straight down because it has completed exactly 6 and a half full revolutions and the seconds hand (red) is pointing straight up because it has completed an integer number of full revolutions.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/h3nslzqx.png)\n\nUnfortunately, the hands are broken, so they all look identical and there is no way to know which hand is which. The clock in the picture above, with its hands broken, would look like this.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4m1446he.png)\n\nEmmett does know that the time was strictly before noon, that is, strictly less than 12 hours after midnight. Emmett has taken a picture of the clock. Given that picture (represented by the angles of the hands relative to a single arbitrary axis), figure out what time it could correspond to.\n\nNotice that Emmett has already figured out a viable orientation of the clock in some cases (Test Set 1) and has managed to narrow down the possible times to a whole integer number of seconds (Test Sets 1 and 2) or nanoseconds (Test Set 3). Please see the limits sections for more details.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line describes a test case and contains three integers $\\mathbf{A}$, $\\mathbf{B}$, and $\\mathbf{C}$: the angles of each hand, relative to an arbitrary axis and given in ticks in the clockwise direction. 1 tick is equal to $1 / 12 \\times 10^{-10}$ degrees. This means that the hours hand rotates exactly 1 tick each nanosecond, the minutes hand rotates exactly 12 ticks each nanosecond and the seconds hand rotates exactly 720 ticks each nanosecond.\n", "outputFormat": "For each test case, output one line containing `Case #x: h m s n`, where $x$ is the test case number (starting from 1) and $h, m, s$, and $n$ are integers: $h$ is the number of full hours since midnight (between 0 and 11, inclusive), $m$ is the number of full minutes since the last full hour (between 0 and 59, inclusive), $s$ is the number of full seconds since the last full minute (between 0 and 59, inclusive) and $n$ is the number of full nanoseconds since the last full second (between 0 and $10^{9}-1$, inclusive).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, all hands point up (as in the first picture below) which happens only exactly at midnight (as in the second picture below).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ac9ropk5.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/oc7u48j6.png)\n\nSample Case #2 is the one pictured in the main part of the statement. The angles of the hands in degrees are 0, 180 and 195. These angles can correspond to 6h 30m 0s without rotating the clock, as the pictures in the main part of the statement show. Notice however, that at 0h 30m 0s (pictured below), the clock looks the same but rotated 180 degrees.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j5ktfcq2.png)\n\nEven in Test Set 1, 0h 30m 0s would be a valid answer. The limit only says that there is one valid time that does not require rotating the clock, but times that work with rotation are also valid answers.\n\nIn Sample Case #3, the input represents the clock in the first picture below and the given output happens when interpreting the clock as in the second picture below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x2hzcknb.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/u6758coa.png)\n\nSample Test Set 2 fits the limits of Test Set 2. It will not be run against your submitted solutions.\n\nSample Cases in this test set are the same as in the previous one, but the clock is rotated by $45$, $90$, and $180$ degrees clockwise respectively, as shown below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/srt7xazp.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/5b9o5qf6.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/2pz53ap7.png)\n\nSample Test Set 3 fits the limits of Test Set 3. It will not be run against your submitted solutions.\n\nAs explained above, 1 nanosecond after midnight the hands are moved by 1, 12, and 720 ticks, respectively. If the clock is also rotated counter-clockwise by 1 tick, the hand angles are exactly the ones given in the input.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $0 \\leq \\mathbf{A} \\leq \\mathbf{B} \\leq \\mathbf{C} < 360 \\times 12 \\times 10^{10}$.\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- There is a time $t$ that corresponds to the input such that:\n  - $t$ is an integer number of seconds after midnight.\n  - $t$ can be read from the input clock without rotating it.\n\n**Test Set 2 (6 Pts, Visible Verdict)**\n\n- There is a time that corresponds to the input and is an integer number of seconds after midnight.\n\n**Test Set 3 (19 Pts, Visible Verdict)**\n\n- There is a time that corresponds to the input and is an integer number of nanoseconds after midnight.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #1B] Broken Clock", "background": "", "description": "Emmett found an old clock in his attic. The clock is a circle with 3 hands that attach to the center and rotate clockwise at constant speeds. They are called the $hours$ $hand$, the $minutes$ $hand$ and the $seconds$ $hand$. At midnight, all hands point up. The hours hand completes a full revolution in 12 hours, the minutes hand completes a full revolution in 1 hour, and the seconds hand completes a full revolution in 1 minute. 1 hour is equal to 60 minutes, 1 minute is equal to 60 seconds, and 1 second is equal to $10^{9}$ nanoseconds.\n\nFor example, the clock depicted below is showing that the time is exactly 6 hours and 30 minutes after midnight. The hours hand (short black) is halfway between 6 and 7 (completed 6.5/12 of a revolution), the minutes hand (long black) is pointing straight down because it has completed exactly 6 and a half full revolutions and the seconds hand (red) is pointing straight up because it has completed an integer number of full revolutions.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/h3nslzqx.png)\n\nUnfortunately, the hands are broken, so they all look identical and there is no way to know which hand is which. The clock in the picture above, with its hands broken, would look like this.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4m1446he.png)\n\nEmmett does know that the time was strictly before noon, that is, strictly less than 12 hours after midnight. Emmett has taken a picture of the clock. Given that picture (represented by the angles of the hands relative to a single arbitrary axis), figure out what time it could correspond to.\n\nNotice that Emmett has already figured out a viable orientation of the clock in some cases (Test Set 1) and has managed to narrow down the possible times to a whole integer number of seconds (Test Sets 1 and 2) or nanoseconds (Test Set 3). Please see the limits sections for more details.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line describes a test case and contains three integers $\\mathbf{A}$, $\\mathbf{B}$, and $\\mathbf{C}$: the angles of each hand, relative to an arbitrary axis and given in ticks in the clockwise direction. 1 tick is equal to $1 / 12 \\times 10^{-10}$ degrees. This means that the hours hand rotates exactly 1 tick each nanosecond, the minutes hand rotates exactly 12 ticks each nanosecond and the seconds hand rotates exactly 720 ticks each nanosecond.\n", "outputFormat": "For each test case, output one line containing `Case #x: h m s n`, where $x$ is the test case number (starting from 1) and $h, m, s$, and $n$ are integers: $h$ is the number of full hours since midnight (between 0 and 11, inclusive), $m$ is the number of full minutes since the last full hour (between 0 and 59, inclusive), $s$ is the number of full seconds since the last full minute (between 0 and 59, inclusive) and $n$ is the number of full nanoseconds since the last full second (between 0 and $10^{9}-1$, inclusive).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, all hands point up (as in the first picture below) which happens only exactly at midnight (as in the second picture below).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ac9ropk5.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/oc7u48j6.png)\n\nSample Case #2 is the one pictured in the main part of the statement. The angles of the hands in degrees are 0, 180 and 195. These angles can correspond to 6h 30m 0s without rotating the clock, as the pictures in the main part of the statement show. Notice however, that at 0h 30m 0s (pictured below), the clock looks the same but rotated 180 degrees.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j5ktfcq2.png)\n\nEven in Test Set 1, 0h 30m 0s would be a valid answer. The limit only says that there is one valid time that does not require rotating the clock, but times that work with rotation are also valid answers.\n\nIn Sample Case #3, the input represents the clock in the first picture below and the given output happens when interpreting the clock as in the second picture below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x2hzcknb.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/u6758coa.png)\n\nSample Test Set 2 fits the limits of Test Set 2. It will not be run against your submitted solutions.\n\nSample Cases in this test set are the same as in the previous one, but the clock is rotated by $45$, $90$, and $180$ degrees clockwise respectively, as shown below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/srt7xazp.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/5b9o5qf6.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/2pz53ap7.png)\n\nSample Test Set 3 fits the limits of Test Set 3. It will not be run against your submitted solutions.\n\nAs explained above, 1 nanosecond after midnight the hands are moved by 1, 12, and 720 ticks, respectively. If the clock is also rotated counter-clockwise by 1 tick, the hand angles are exactly the ones given in the input.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $0 \\leq \\mathbf{A} \\leq \\mathbf{B} \\leq \\mathbf{C} < 360 \\times 12 \\times 10^{10}$.\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- There is a time $t$ that corresponds to the input such that:\n  - $t$ is an integer number of seconds after midnight.\n  - $t$ can be read from the input clock without rotating it.\n\n**Test Set 2 (6 Pts, Visible Verdict)**\n\n- There is a time that corresponds to the input and is an integer number of seconds after midnight.\n\n**Test Set 3 (19 Pts, Visible Verdict)**\n\n- There is a time that corresponds to the input and is an integer number of nanoseconds after midnight.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #1B] Broken Clock", "background": "", "description": "Emmett 在他的阁楼里发现了一个旧时钟。这个时钟是一个圆形，带有 3 根指针，它们连接在中心并以恒定速度顺时针旋转。这三根指针分别称为**时针**、**分针**和**秒针**。在午夜时分，所有指针都指向正上方。时针每 12 小时旋转一圈，分针每小时旋转一圈，秒针每分钟旋转一圈。1 小时等于 60 分钟，1 分钟等于 60 秒，1 秒等于 $10^{9}$ 纳秒。\n\n例如，下图所示的时钟表示的时间恰好是午夜后 6 小时 30 分钟。时针（黑色短针）位于 6 和 7 之间（完成了 6.5/12 圈），分针（黑色长针）指向正下方，因为它完成了恰好 6.5 圈，而秒针（红色）指向正上方，因为它完成了整数圈。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/h3nslzqx.png)\n\n不幸的是，这些指针已经损坏，因此它们看起来完全相同，无法区分哪根指针是哪根。上图中的时钟在指针损坏后看起来像这样。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4m1446he.png)\n\nEmmett 知道时间严格在中午之前，即严格小于午夜后 12 小时。Emmett 拍摄了一张时钟的照片。给定这张照片（用指针相对于某个任意轴的角度表示），请找出它可能对应的时间。\n\n注意，在某些情况下（测试集 1），Emmett 已经找到了时钟的可行方向，并将可能的时间范围缩小到整数秒（测试集 1 和 2）或纳秒（测试集 3）。更多细节请参阅数据范围部分。", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 行，每行描述一个测试用例，包含三个整数 $\\mathbf{A}$、$\\mathbf{B}$ 和 $\\mathbf{C}$：分别表示每根指针相对于某个任意轴的角度，以顺时针方向的“滴答”为单位。1 滴答等于 $1 / 12 \\times 10^{-10}$ 度。这意味着时针每纳秒旋转恰好 1 滴答，分针每纳秒旋转恰好 12 滴答，秒针每纳秒旋转恰好 720 滴答。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: h m s n`，其中 $x$ 是测试用例编号（从 1 开始），$h$、$m$、$s$ 和 $n$ 是整数：$h$ 表示午夜后的整小时数（0 到 11 之间，包括 0 和 11），$m$ 表示上一整小时后的整分钟数（0 到 59 之间），$s$ 表示上一整分钟后的整秒数（0 到 59 之间），$n$ 表示上一整秒后的整纳秒数（0 到 $10^{9}-1$ 之间）。\n", "hint": "**样例解释**\n\n在样例 #1 中，所有指针指向正上方（如下第一张图），这仅在午夜时分发生（如下第二张图）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ac9ropk5.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/oc7u48j6.png)\n\n样例 #2 是题目描述中展示的时钟。指针的角度分别为 0、180 和 195 度。这些角度可以对应 6 小时 30 分 0 秒（无需旋转时钟），如题目描述中的图片所示。但请注意，在 0 小时 30 分 0 秒时（如下第三张图），时钟看起来相同，只是旋转了 180 度。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j5ktfcq2.png)\n\n即使在测试集 1 中，0 小时 30 分 0 秒也是一个有效答案。题目限制仅说明存在一个无需旋转时钟的有效时间，但旋转后的时间也是有效答案。\n\n在样例 #3 中，输入表示第一张图中的时钟，而给定的输出对应于第二张图的解释。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x2hzcknb.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/u6758coa.png)\n\n样例测试集 2 符合测试集 2 的限制。它不会用于测试你的提交。\n\n此测试集中的样例与上一个相同，但时钟分别顺时针旋转了 45、90 和 180 度，如下所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/srt7xazp.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/5b9o5qf6.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/2pz53ap7.png)\n\n样例测试集 3 符合测试集 3 的限制。它不会用于测试你的提交。\n\n如上所述，午夜后 1 纳秒，指针分别移动了 1、12 和 720 滴答。如果时钟还逆时针旋转了 1 滴答，指针的角度恰好与输入一致。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $0 \\leq \\mathbf{A} \\leq \\mathbf{B} \\leq \\mathbf{C} < 360 \\times 12 \\times 10^{10}$。\n\n**测试集 1（5 分，可见评测结果）**\n\n- 存在一个时间 $t$ 与输入对应，满足：\n  - $t$ 是午夜后的整数秒。\n  - $t$ 可以从输入时钟直接读取，无需旋转。\n\n**测试集 2（6 分，可见评测结果）**\n\n- 存在一个时间与输入对应，且是午夜后的整数秒。\n\n**测试集 3（19 分，可见评测结果）**\n\n- 存在一个时间与输入对应，且是午夜后的整数纳秒。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13030", "type": "P", "difficulty": 4, "samples": [["3\n2 1 2\n1 2\n5 1 2\n2 0 0 0 1\n3 1 2\n1 1 1", "Case #1: 4\nCase #2: 6\nCase #3: 5"], ["3\n3 2 4\n1 1 1\n3 2 4\n1 0 1\n5 2 5\n1 0 0 0 1", "Case #1: IMPOSSIBLE\nCase #2: 5\nCase #3: 10"]], "limits": {"time": [30000, 30000, 30000], "memory": [1048576, 1048576, 1048576]}, "tags": ["数学", "贪心", "2021", "数论", "Bézout 定理", "Google Code Jam"], "title": "[GCJ 2021 #1B] Subtransmutation", "background": "", "description": "As the most skilled alchemist in your country, you were summoned yet again because powers beyond science were needed to satisfy your country's leader's ever increasing greed for rare metals.\n\nEach metal is represented by a positive integer. You need to create $\\mathbf{U}_{1}$ units of metal 1, $\\mathbf{U}_{2}$ units of metal 2, … and $\\mathbf{U}_{\\mathrm{N}}$ units of metal $\\mathrm{N}$. Metals $\\mathrm{N}+1, \\mathrm{~N}+2, \\ldots$ do exist, but you are not required to create any specific amount of them. You are allowed to create excess amounts of any metal, which can just be discarded.\n\nUnfortunately, budget cuts have left you only the materials for a simple alchemy spell. For some fixed numbers $\\mathbf{A}$ and $\\mathbf{B}$, with $\\mathbf{A}<\\mathbf{B}$, you can take one unit of metal $i$ and destroy it to create one unit of metal $(i-\\mathbf{A})$ and one unit of metal $(i-\\mathbf{B})$. If either of those integers is not positive, that specific unit is not created. In particular, if $i \\leq \\mathbf{A}$, the spell simply destroys the unit and creates nothing. If $\\mathbf{A}<i \\leq \\mathbf{B}$ the spell destroys the unit and creates only a single unit of metal $(i-\\mathbf{A})$.\n\nYou have been assigned an expert miner to assist you. The expert miner can fetch a single unit of any metal you want. From that unit, you can use your spell to create other metals and then use the spell on the resulting metals to create even more units. The picture below shows a single unit of metal 4 being converted into one unit of metal 1 and two units of metal 2 using two spells with $\\mathbf{A}=1$ and $\\mathbf{B}=2$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/imhnu3zr.png)\n\nMetals represented by larger integers are heavier and more difficult to handle, so you want to ask the expert miner for a single unit of metal represented by the smallest possible integer that is sufficient to complete your task, or say that there is no such metal.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines. The first line of a test case contains three integers $\\mathbf{N}, \\mathbf{A}$, and $\\mathbf{B}$, representing the largest metal number that you are required to create, and the two values that define the available spell as described above, respectively. The second line of a test case contains $\\mathbf{N}$ integers $\\mathbf{U}_{1}, \\mathbf{U}_{2}, \\ldots, \\mathbf{U}_{\\mathbf{N}}$, representing the required units of metals $1,2, \\ldots, \\mathbf{N}$, respectively.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is IMPOSSIBLE if it is not possible to create all required units starting from a single unit of metal. Otherwise, $y$ is the smallest integer that represents a metal such that one unit of it is sufficient to create all the required units of metal.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, we require one unit of metal 1 and two units of metal 2. If we start with a single unit of metal 3, then applying the spell once will give us one unit of metal 1 and one unit of metal 2. There is no way to get an additional unit of metal 2. Similarly, starting with a single unit of metals 1 or 2 is not sufficient. However, a single unit of metal 4 is sufficient as is demonstrated in the picture in the main part of the statement.\n\nIn Sample Case #2, we can start with a single unit of metal 6 and apply the following operations:\n\n* Apply spell on 6: $\\{6\\} \\longrightarrow\\{4,5\\}$.\n* Apply spell on 4: $\\{4,5\\} \\longrightarrow\\{2,3,5\\}$.\n* Apply spell on 2: $\\{2,3,5\\} \\longrightarrow\\{1,3,5\\}$.\n* Apply spell on 3: $\\{1,3,5\\} \\longrightarrow\\{1,1,2,5\\}$.\n\nNote that even though we have an extra unit of metal 2 , this solution is valid.\n\nIn Sample Case #3, we can start with a single unit of metal 5 and apply the following operations:\n\n* Apply spell on 5: $\\{5\\} \\longrightarrow\\{3,4\\}$.\n* Apply spell on 4: $\\{3,4\\} \\longrightarrow\\{2,3,3\\}$.\n* Apply spell on 2: $\\{2,3,3\\} \\longrightarrow\\{1,3,3\\}$.\n* Apply spell on 3: $\\{1,3,3\\} \\longrightarrow\\{1,1,2,3\\}$.\n\nThere are other ways to apply spells which also work but they all require starting with a single unit of metal 5 or higher.\n\nSample Test Set 2 fits the limits of Test Set 2. It will not be run against your submitted solutions.\n\nIn the first Sample Case for Test Set 2, it is impossible to start with a single unit of any metal and apply the spell with $\\mathbf{A}=2$ and $\\mathbf{B}=4$ several times and be left with one unit of metals $1,2$ and $3$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{N} \\leq 20$.\n- $0 \\leq \\mathbf{U}_{\\mathbf{i}} \\leq 20$, for all $i$.\n- $1 \\leq \\mathbf{U}_{\\mathbf{N}}$.\n- $2 \\leq \\mathbf{U}_{1}+\\mathbf{U}_{2}+\\cdots+\\mathbf{U}_{\\mathbf{N}}$.\n\n**Test Set 1 (13 Pts, Visible Verdict)**\n\n- $\\mathbf{A}=1$.\n- $\\mathbf{B}=2$.\n\n**Test Set 2 (18 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{A}<\\mathbf{B} \\leq 20$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #1B] Subtransmutation", "background": "", "description": "As the most skilled alchemist in your country, you were summoned yet again because powers beyond science were needed to satisfy your country's leader's ever increasing greed for rare metals.\n\nEach metal is represented by a positive integer. You need to create $\\mathbf{U}_{1}$ units of metal 1, $\\mathbf{U}_{2}$ units of metal 2, … and $\\mathbf{U}_{\\mathrm{N}}$ units of metal $\\mathrm{N}$. Metals $\\mathrm{N}+1, \\mathrm{~N}+2, \\ldots$ do exist, but you are not required to create any specific amount of them. You are allowed to create excess amounts of any metal, which can just be discarded.\n\nUnfortunately, budget cuts have left you only the materials for a simple alchemy spell. For some fixed numbers $\\mathbf{A}$ and $\\mathbf{B}$, with $\\mathbf{A}<\\mathbf{B}$, you can take one unit of metal $i$ and destroy it to create one unit of metal $(i-\\mathbf{A})$ and one unit of metal $(i-\\mathbf{B})$. If either of those integers is not positive, that specific unit is not created. In particular, if $i \\leq \\mathbf{A}$, the spell simply destroys the unit and creates nothing. If $\\mathbf{A}<i \\leq \\mathbf{B}$ the spell destroys the unit and creates only a single unit of metal $(i-\\mathbf{A})$.\n\nYou have been assigned an expert miner to assist you. The expert miner can fetch a single unit of any metal you want. From that unit, you can use your spell to create other metals and then use the spell on the resulting metals to create even more units. The picture below shows a single unit of metal 4 being converted into one unit of metal 1 and two units of metal 2 using two spells with $\\mathbf{A}=1$ and $\\mathbf{B}=2$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/imhnu3zr.png)\n\nMetals represented by larger integers are heavier and more difficult to handle, so you want to ask the expert miner for a single unit of metal represented by the smallest possible integer that is sufficient to complete your task, or say that there is no such metal.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines. The first line of a test case contains three integers $\\mathbf{N}, \\mathbf{A}$, and $\\mathbf{B}$, representing the largest metal number that you are required to create, and the two values that define the available spell as described above, respectively. The second line of a test case contains $\\mathbf{N}$ integers $\\mathbf{U}_{1}, \\mathbf{U}_{2}, \\ldots, \\mathbf{U}_{\\mathbf{N}}$, representing the required units of metals $1,2, \\ldots, \\mathbf{N}$, respectively.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is IMPOSSIBLE if it is not possible to create all required units starting from a single unit of metal. Otherwise, $y$ is the smallest integer that represents a metal such that one unit of it is sufficient to create all the required units of metal.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, we require one unit of metal 1 and two units of metal 2. If we start with a single unit of metal 3, then applying the spell once will give us one unit of metal 1 and one unit of metal 2. There is no way to get an additional unit of metal 2. Similarly, starting with a single unit of metals 1 or 2 is not sufficient. However, a single unit of metal 4 is sufficient as is demonstrated in the picture in the main part of the statement.\n\nIn Sample Case #2, we can start with a single unit of metal 6 and apply the following operations:\n\n* Apply spell on 6: $\\{6\\} \\longrightarrow\\{4,5\\}$.\n* Apply spell on 4: $\\{4,5\\} \\longrightarrow\\{2,3,5\\}$.\n* Apply spell on 2: $\\{2,3,5\\} \\longrightarrow\\{1,3,5\\}$.\n* Apply spell on 3: $\\{1,3,5\\} \\longrightarrow\\{1,1,2,5\\}$.\n\nNote that even though we have an extra unit of metal 2 , this solution is valid.\n\nIn Sample Case #3, we can start with a single unit of metal 5 and apply the following operations:\n\n* Apply spell on 5: $\\{5\\} \\longrightarrow\\{3,4\\}$.\n* Apply spell on 4: $\\{3,4\\} \\longrightarrow\\{2,3,3\\}$.\n* Apply spell on 2: $\\{2,3,3\\} \\longrightarrow\\{1,3,3\\}$.\n* Apply spell on 3: $\\{1,3,3\\} \\longrightarrow\\{1,1,2,3\\}$.\n\nThere are other ways to apply spells which also work but they all require starting with a single unit of metal 5 or higher.\n\nSample Test Set 2 fits the limits of Test Set 2. It will not be run against your submitted solutions.\n\nIn the first Sample Case for Test Set 2, it is impossible to start with a single unit of any metal and apply the spell with $\\mathbf{A}=2$ and $\\mathbf{B}=4$ several times and be left with one unit of metals $1,2$ and $3$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{N} \\leq 20$.\n- $0 \\leq \\mathbf{U}_{\\mathbf{i}} \\leq 20$, for all $i$.\n- $1 \\leq \\mathbf{U}_{\\mathbf{N}}$.\n- $2 \\leq \\mathbf{U}_{1}+\\mathbf{U}_{2}+\\cdots+\\mathbf{U}_{\\mathbf{N}}$.\n\n**Test Set 1 (13 Pts, Visible Verdict)**\n\n- $\\mathbf{A}=1$.\n- $\\mathbf{B}=2$.\n\n**Test Set 2 (18 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{A}<\\mathbf{B} \\leq 20$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #1B] Subtransmutation", "background": "", "description": "作为国内最顶尖的炼金术士，你再次被征召，因为需要超越科学的力量来满足国家领袖对稀有金属日益增长的贪婪需求。\n\n每种金属用一个正整数表示。你需要制造 $\\mathbf{U}_{1}$ 个单位的 1 号金属，$\\mathbf{U}_{2}$ 个单位的 2 号金属，……，以及 $\\mathbf{U}_{\\mathrm{N}}$ 个单位的 $\\mathrm{N}$ 号金属。$\\mathrm{N}+1$, $\\mathrm{N}+2$, …… 号金属也存在，但你不需要制造特定数量的它们。你可以制造任何金属的过量单位，这些多余的金属可以直接丢弃。\n\n不幸的是，预算削减让你只剩下施展一个简单炼金法术的材料。对于固定的数字 $\\mathbf{A}$ 和 $\\mathbf{B}$（$\\mathbf{A}<\\mathbf{B}$），你可以消耗 1 个单位的 $i$ 号金属，将其分解为 1 个单位的 $(i-\\mathbf{A})$ 号金属和 1 个单位的 $(i-\\mathbf{B})$ 号金属。如果其中某个整数不是正数，则不会生成对应的单位。特别地，如果 $i \\leq \\mathbf{A}$，这个法术只会销毁该单位而不生成任何金属。如果 $\\mathbf{A}<i \\leq \\mathbf{B}$，法术会销毁该单位并只生成 1 个单位的 $(i-\\mathbf{A})$ 号金属。\n\n你被指派了一位专家矿工协助。专家矿工可以为你开采任意一种金属的 1 个单位。你可以从这个单位出发，使用你的法术制造其他金属，然后再对生成的金属施用该法术来制造更多单位。下图展示了在 $\\mathbf{A}=1$ 和 $\\mathbf{B}=2$ 时，1 个单位的 4 号金属通过两次法术转化为 1 个单位的 1 号金属和 2 个单位的 2 号金属的过程。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/imhnu3zr.png)\n\n数值越大的金属越重且越难处理，因此你希望向专家矿工请求数值尽可能小的金属单位来完成你的任务，或者指出这是不可能实现的。", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例包含两行：\n- 第一行包含三个整数 $\\mathbf{N}$、$\\mathbf{A}$ 和 $\\mathbf{B}$，分别表示你需要制造的金属的最大编号，以及定义可用法术的两个参数。\n- 第二行包含 $\\mathbf{N}$ 个整数 $\\mathbf{U}_{1}, \\mathbf{U}_{2}, \\ldots, \\mathbf{U}_{\\mathbf{N}}$，表示对 1 号、2 号、……、$\\mathbf{N}$ 号金属的需求量。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是 IMPOSSIBLE（如果无法从 1 个单位的某种金属开始制造所有所需金属），否则 $y$ 是最小的金属编号，使得从它的 1 个单位出发可以制造所有所需金属。\n", "hint": "**样例解释**\n\n在样例 #1 中，我们需要 1 个单位的 1 号金属和 2 个单位的 2 号金属。如果从 1 个单位的 3 号金属开始，施用一次法术会得到 1 个单位的 1 号金属和 1 个单位的 2 号金属，无法再获得额外的 2 号金属。类似地，从 1 号或 2 号金属开始也不够。但如题目描述中的图示所示，从 4 号金属开始可以满足需求。\n\n在样例 #2 中，我们可以从 1 个单位的 6 号金属开始，进行以下操作：\n* 对 6 施法：$\\{6\\} \\to \\{4,5\\}$\n* 对 4 施法：$\\{4,5\\} \\to \\{2,3,5\\}$\n* 对 2 施法：$\\{2,3,5\\} \\to \\{1,3,5\\}$\n* 对 3 施法：$\\{1,3,5\\} \\to \\{1,1,2,5\\}$\n\n虽然会多出 2 号金属，但这个解是有效的。\n\n在样例 #3 中，我们可以从 5 号金属开始：\n* 对 5 施法：$\\{5\\} \\to \\{3,4\\}$\n* 对 4 施法：$\\{3,4\\} \\to \\{2,3,3\\}$\n* 对 2 施法：$\\{2,3,3\\} \\to \\{1,3,3\\}$\n* 对 3 施法：$\\{1,3,3\\} \\to \\{1,1,2,3\\}$\n\n其他操作方式也可以满足需求，但都需要从 5 号或更高编号的金属开始。\n\n样例测试集 2 符合测试集 2 的限制。它不会用于测试你的提交。\n\n在测试集 2 的第一个样例中，无法从任何金属的 1 个单位出发，通过 $\\mathbf{A}=2$、$\\mathbf{B}=4$ 的法术操作得到 1 个单位的 1 号、2 号和 3 号金属。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$\n- $1 \\leq \\mathbf{N} \\leq 20$\n- 对所有 $i$，$0 \\leq \\mathbf{U}_{\\mathbf{i}} \\leq 20$\n- $1 \\leq \\mathbf{U}_{\\mathbf{N}}$\n- $2 \\leq \\mathbf{U}_{1}+\\mathbf{U}_{2}+\\cdots+\\mathbf{U}_{\\mathbf{N}}$\n\n**测试集 1（13 分，可见评测结果）**\n- $\\mathbf{A}=1$\n- $\\mathbf{B}=2$\n\n**测试集 2（18 分，隐藏评测结果）**\n- $1 \\leq \\mathbf{A}<\\mathbf{B} \\leq 20$\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13031", "type": "P", "difficulty": 5, "samples": [["2 3 3 1500\n3\n\n2\n\n5\n\n4\n\n1\n\n6\n\n3\n\n9\n\n0", "\n\n1\n\n1\n\n2\n\n2\n\n1\n\n3\n\n2\n\n3\n\n3"]], "limits": {"time": [60000, 60000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "贪心", "2021", "交互题", "Special Judge", "概率论", "Google Code Jam"], "title": "[GCJ 2021 #1B] Digit Blocks", "background": "", "description": "You are going to build $N$ towers of $B$ cubic blocks each, one block at a time. Towers are built bottom-up: the $i$-th block to be placed in a tower ends up as the $i$-th from the bottom. You need to decide where to place each block before getting to see any of the upcoming blocks, and once placed, blocks cannot be moved.\n\nEach block has a single decimal digit printed on it, and towers are built such that the faces with digits are all facing the front. The font is such that blocks cannot be rotated to obtain a different digit (for example, a block with a 6 on it cannot be rotated to obtain a block with a 9 on it, nor vice versa).\n\nFor example, suppose $N = 3$ and $B = 3$ and you currently have towers as shown in Picture 1. If a block with a 6 shows up next, you have two options: either place it on top of the tower with only two blocks (as shown in Picture 2) or start the third tower (as shown in Picture 3). Note that you cannot put it on top of the first tower since the first tower already has $B$ blocks.\n\n\nAfter the building is done, we read the $B$ digit integer printed on the front of each tower from the top to the bottom (that is, the digit on the last block placed on a tower is the most significant digit). Notice that these integers may have any number of leading zeroes. Then, we add those $N$ integers together to obtain the score of our building operation.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/47a718u8.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/c8lwc9qg.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/wdg8ljcv.png)\n\nFor example, in Picture 4 below, the integers read on each tower, from left to right, are $123$, $345$, and $96$. The score of that building operation would be $123 + 345 + 96 = 564$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6aiwqzwm.png)\n\nThe digit for each block is generated uniformly at random, and independently of any other information. In order for your solution to be judged correct, the sum of its scores over all $\\textbf{T}$ test cases must be at least $\\textbf{P}$.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially the judge will send you a single line containing four integers $\\textbf{T}$, $\\textbf{N}$, $\\textbf{B}$, and $\\textbf{P}$: the number of test cases, the number of towers, the number of blocks in each tower, and the minimum total score you need to reach to pass this test set.\n\nThen, you must process $\\textbf{T}$ test cases. Each test case consists of $\\textbf{N} \\times \\textbf{B}$ exchanges. Each exchange corresponds to placing one block. Within each exchange, the judge will first print a line containing a single integer $\\textbf{D}$ representing the digit printed on the block you need to place. You need to respond with a single line containing a single integer $\\textbf{i}$, the number (between $1$ and $\\textbf{N}$) of the tower you want to place that block on.\n\nAfter the last exchange of each test case except the last one, the judge will immediately start the next test case. After the last exchange of the last test case, the judge will print an additional line containing a single integer: $1$ if your total score is at least $\\textbf{P}$ or $-1$ if it is not.\n\nIf the judge receives an invalidly formatted line, an invalid tower number, or the number of a tower that already contains $\\textbf{B}$ blocks from your program, the judge will print a single number $-1$. After the judge prints $-1$ for any of the reasons explained above, it will not print any further output. If your program continues to wait for the judge after receiving a $-1$, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.\n\nYou can assume that the digit for each block is generated uniformly at random, and independently for each digit, for each test case and for each submission. Therefore even if you submit exactly the same code twice, the judge could use different random digits.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Explanation**\n\nIn the sample, we are now at the state shown in Picture 4 (sum = 564).\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our interactive runner for that.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $\\textbf{T} = 50$.\n- $\\textbf{N} = 20$.\n- $\\textbf{B} = 15$.\n- $\\textbf{D}$ is a decimal digit between $0$ and $9$.\n\n**Test Set 1 (16 Pts, Visible Verdict)**\n\n$\\textbf{P} = 860939810732536850$ (approximately $8.6 \\times 10^{17}$).\n\nNote that this boundary is chosen as approximately $90\\%$ of $\\textbf{T} \\times S$, where $S = 19131995794056374.42\\dots$ (approximately $1.9 \\times 10^{16}$) is the highest possible expected score that a solution to this problem can achieve on one test case given unbounded running time.\n\nThe exact value of $S$ as defined above can be found in lines 13 and 14 of the local testing tool.\n\n**Test Set 2 (21 Pts, Visible Verdict)**\n\n$\\textbf{P} = 937467793908762347$ (approximately $9.37 \\times 10^{17}$).\n\nNote that this boundary is chosen as approximately $98\\%$ of $\\textbf{T} \\times S$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #1B] Digit Blocks", "background": "", "description": "You are going to build $N$ towers of $B$ cubic blocks each, one block at a time. Towers are built bottom-up: the $i$-th block to be placed in a tower ends up as the $i$-th from the bottom. You need to decide where to place each block before getting to see any of the upcoming blocks, and once placed, blocks cannot be moved.\n\nEach block has a single decimal digit printed on it, and towers are built such that the faces with digits are all facing the front. The font is such that blocks cannot be rotated to obtain a different digit (for example, a block with a 6 on it cannot be rotated to obtain a block with a 9 on it, nor vice versa).\n\nFor example, suppose $N = 3$ and $B = 3$ and you currently have towers as shown in Picture 1. If a block with a 6 shows up next, you have two options: either place it on top of the tower with only two blocks (as shown in Picture 2) or start the third tower (as shown in Picture 3). Note that you cannot put it on top of the first tower since the first tower already has $B$ blocks.\n\n\nAfter the building is done, we read the $B$ digit integer printed on the front of each tower from the top to the bottom (that is, the digit on the last block placed on a tower is the most significant digit). Notice that these integers may have any number of leading zeroes. Then, we add those $N$ integers together to obtain the score of our building operation.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/47a718u8.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/c8lwc9qg.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/wdg8ljcv.png)\n\nFor example, in Picture 4 below, the integers read on each tower, from left to right, are $123$, $345$, and $96$. The score of that building operation would be $123 + 345 + 96 = 564$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6aiwqzwm.png)\n\nThe digit for each block is generated uniformly at random, and independently of any other information. In order for your solution to be judged correct, the sum of its scores over all $\\textbf{T}$ test cases must be at least $\\textbf{P}$.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially the judge will send you a single line containing four integers $\\textbf{T}$, $\\textbf{N}$, $\\textbf{B}$, and $\\textbf{P}$: the number of test cases, the number of towers, the number of blocks in each tower, and the minimum total score you need to reach to pass this test set.\n\nThen, you must process $\\textbf{T}$ test cases. Each test case consists of $\\textbf{N} \\times \\textbf{B}$ exchanges. Each exchange corresponds to placing one block. Within each exchange, the judge will first print a line containing a single integer $\\textbf{D}$ representing the digit printed on the block you need to place. You need to respond with a single line containing a single integer $\\textbf{i}$, the number (between $1$ and $\\textbf{N}$) of the tower you want to place that block on.\n\nAfter the last exchange of each test case except the last one, the judge will immediately start the next test case. After the last exchange of the last test case, the judge will print an additional line containing a single integer: $1$ if your total score is at least $\\textbf{P}$ or $-1$ if it is not.\n\nIf the judge receives an invalidly formatted line, an invalid tower number, or the number of a tower that already contains $\\textbf{B}$ blocks from your program, the judge will print a single number $-1$. After the judge prints $-1$ for any of the reasons explained above, it will not print any further output. If your program continues to wait for the judge after receiving a $-1$, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.\n\nYou can assume that the digit for each block is generated uniformly at random, and independently for each digit, for each test case and for each submission. Therefore even if you submit exactly the same code twice, the judge could use different random digits.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Explanation**\n\nIn the sample, we are now at the state shown in Picture 4 (sum = 564).\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our interactive runner for that.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $\\textbf{T} = 50$.\n- $\\textbf{N} = 20$.\n- $\\textbf{B} = 15$.\n- $\\textbf{D}$ is a decimal digit between $0$ and $9$.\n\n**Test Set 1 (16 Pts, Visible Verdict)**\n\n$\\textbf{P} = 860939810732536850$ (approximately $8.6 \\times 10^{17}$).\n\nNote that this boundary is chosen as approximately $90\\%$ of $\\textbf{T} \\times S$, where $S = 19131995794056374.42\\dots$ (approximately $1.9 \\times 10^{16}$) is the highest possible expected score that a solution to this problem can achieve on one test case given unbounded running time.\n\nThe exact value of $S$ as defined above can be found in lines 13 and 14 of the local testing tool.\n\n**Test Set 2 (21 Pts, Visible Verdict)**\n\n$\\textbf{P} = 937467793908762347$ (approximately $9.37 \\times 10^{17}$).\n\nNote that this boundary is chosen as approximately $98\\%$ of $\\textbf{T} \\times S$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #1B] Digit Blocks", "background": "", "description": "你将建造 $N$ 座塔，每座塔由 $B$ 块立方体积木组成，每次放置一块积木。塔的建造是从下往上进行的：第 $i$ 块被放置到某座塔中的积木最终会成为该塔从下往上数的第 $i$ 块。你需要在看到后续积木之前决定每块积木的放置位置，且一旦放置就不能移动。\n\n每块积木上印有一个十进制数字，塔的建造会确保所有数字面朝前。积木的字体设计使得无法通过旋转获得不同的数字（例如，印有 6 的积木不能通过旋转变成 9，反之亦然）。\n\n例如，假设 $N = 3$ 且 $B = 3$，当前塔的状态如图 1 所示。如果下一块积木的数字是 6，你有两种选择：要么将其放在只有两块积木的塔上（如图 2），要么开始建造第三座塔（如图 3）。注意不能将其放在第一座塔上，因为第一座塔已经有 $B$ 块积木。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/47a718u8.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/c8lwc9qg.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/wdg8ljcv.png)\n\n建造完成后，我们从每座塔的顶端到底端读取数字（即最后放置的积木数字是最高位），得到一个 $B$ 位整数。注意这些整数可能有任意前导零。然后，将这 $N$ 个整数相加，得到建造操作的分数。\n\n例如，在图 4 中，从左到右的塔分别读作 $123$、$345$ 和 $96$，得分为 $123 + 345 + 96 = 564$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6aiwqzwm.png)\n\n每块积木的数字是独立且均匀随机生成的。为了使你的答案被判为正确，所有 $\\mathbf{T}$ 个测试用例的总分必须至少达到 $\\mathbf{P}$。\n\n### 交互协议\n\n这是一个交互问题。\n\n最初评测机会发送一行包含四个整数 $\\mathbf{T}$、$\\mathbf{N}$、$\\mathbf{B}$ 和 $\\mathbf{P}$：测试用例数量、塔的数量、每座塔的积木数，以及通过测试集所需的最低总分。\n\n然后，你需要处理 $\\mathbf{T}$ 个测试用例。每个测试用例包含 $\\mathbf{N} \\times \\mathbf{B}$ 次交互。每次交互对应放置一块积木。在每次交互中：\n1. 评测机输出一行，包含一个整数 $\\mathbf{D}$，表示当前积木的数字。\n2. 你需要输出一行，包含一个整数 $\\mathbf{i}$（$1 \\leq \\mathbf{i} \\leq \\mathbf{N}$），表示要将积木放置到第几座塔。\n\n在最后一个测试用例的最后一次交互后，评测机会额外输出一行：\n- 如果总分 $\\geq \\mathbf{P}$，输出 $1$；\n- 否则输出 $-1$。\n\n如果评测机收到的交互内容格式错误、塔编号无效，或尝试将积木放到已满的塔上，它会输出 $-1$ 并终止交互。如果程序在收到 $-1$ 后仍继续等待输入，会导致超时错误（TLE）。注意：程序需要及时退出以避免 TLE，否则会被判为错误答案。\n\n可以假设每个积木的数字是独立且均匀随机生成的，因此即使完全相同的代码提交两次，评测机也可能生成不同的随机数字。", "inputFormat": "参见交互协议。", "outputFormat": "参见交互协议。", "hint": "**样例解释**\n\n样例中的状态对应图 4（总分 = 564）。\n\n你可以使用本地测试工具调试代码。测试工具会模拟评测机的行为，但**并非真实评测系统**，可能在某些细节上存在差异。\n\n**数据范围**\n\n- $\\mathbf{T} = 50$\n- $\\mathbf{N} = 20$\n- $\\mathbf{B} = 15$\n- $\\mathbf{D}$ 是 $0$ 到 $9$ 的十进制数字\n\n**测试集 1（16 分，可见评测结果）**\n\n$\\mathbf{P} = 860939810732536850$（约 $8.6 \\times 10^{17}$）。\n\n该边界约为理论最高期望分数（$S \\approx 1.9 \\times 10^{16}$）的 $90\\% \\times \\mathbf{T}$。精确的 $S$ 值可在测试工具代码的第 13-14 行找到。\n\n**测试集 2（21 分，可见评测结果）**\n\n$\\mathbf{P} = 937467793908762347$（约 $9.37 \\times 10^{17}$）。\n\n该边界约为理论最高期望分数的 $98\\% \\times \\mathbf{T}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13032", "type": "P", "difficulty": 3, "samples": [["4\n3 10\n1 3 7\n4 10\n4 1 7 3\n4 3\n1 2 3 2\n4 4\n1 2 4 2", "Case #1: 0.5\nCase #2: 0.4\nCase #3: 0.0\nCase #4: 0.25"]], "limits": {"time": [1000, 1000, 1000], "memory": [1048576, 1048576, 1048576]}, "tags": ["数学", "贪心", "2021", "Special Judge", "排序", "Google Code Jam"], "title": "[GCJ 2021 #1C] Closest Pick", "background": "", "description": "You are entering a raffle for a lifetime supply of pancakes. $\\textbf{N}$ tickets have already been sold. Each ticket contains a single integer between $1$ and $\\textbf{K}$, inclusive. Different tickets are allowed to contain the same integer. You know exactly which numbers are on all of the tickets already sold and would like to maximize your odds of winning by purchasing two tickets (possibly with the same integer on them). You are allowed to choose which integers between $1$ and $\\textbf{K}$, inclusive, are on the two tickets.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dzt1cd5t.png)\n\nYou know you are the last customer, so after you purchase your tickets, no more tickets will be purchased. Then, an integer $c$ between $1$ and $\\textbf{K}$, inclusive, is chosen uniformly at random. If one of your tickets is strictly closer to $c$ than all other tickets or if both of your tickets are the same distance to $c$ and strictly closer than all other tickets, then you win the raffle. Otherwise, you do not win the raffle.\n\nGiven the integers on the $\\textbf{N}$ tickets purchased so far, what is the maximum probability of winning the raffle you can achieve by choosing the integers on your two tickets optimally?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\textbf{T}$. $\\textbf{T}$ test cases follow. Each test case consists of two lines. The first line of a test case contains two integers $\\textbf{N}$ and $\\textbf{K}$: the number of tickets already sold and the limit of the range of integers to pick from, respectively. The second line contains $\\textbf{N}$ integers $\\textbf{P}_1, \\textbf{P}_2, \\ldots, \\textbf{P}_\\textbf{N}$, representing the integers on the tickets that have already been purchased.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from $1$) and $y$ is the maximum win probability you can achieve if you choose your tickets optimally. $y$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer. See the FAQ for an explanation of what that means, and what formats of real numbers we accept.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, you can purchase tickets with the integers $4$ and $8$ on them and then win if $4$, $5$, $8$, $9$, or $10$ are chosen giving you $\\frac{5}{10} = 0.5$ probability of winning. Purchasing tickets with the integers $6$ and $8$ on them also yields a $0.5$ probability of winning, but no combination yields more.\n\nIn Sample Case #2, $6$ and $8$ is a possible optimal pair of tickets, which wins when $c$ is one of $6$, $8$, $9$, or $10$. Note that the integers on the tickets are not necessarily given in sorted order.\n\nIn Sample Case #3, every possible $c$ is at distance $0$ from an already purchased ticket, so you cannot win regardless of your choices.\n\nIn Sample Case #4, if you pick $3$ for at least one of your tickets, you win on $c = 3$, for $\\frac{1}{4} = 0.25$ win probability. There is no way to win when $c$ is any other integer, so that is the best you can do.\n\n**Limits**\n\n- $1 \\leq \\textbf{T} \\leq 100$.\n- $1 \\leq \\textbf{N} \\leq 30$.\n- $1 \\leq \\textbf{P}_i \\leq \\textbf{K}$, for all $i$.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- $1 \\leq \\textbf{K} \\leq 30$.\n\n**Test Set 2 (16 Pts, Visible Verdict)**\n\n- $1 \\leq \\textbf{K} \\leq 10^9$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #1C] Closest Pick", "background": "", "description": "You are entering a raffle for a lifetime supply of pancakes. $\\textbf{N}$ tickets have already been sold. Each ticket contains a single integer between $1$ and $\\textbf{K}$, inclusive. Different tickets are allowed to contain the same integer. You know exactly which numbers are on all of the tickets already sold and would like to maximize your odds of winning by purchasing two tickets (possibly with the same integer on them). You are allowed to choose which integers between $1$ and $\\textbf{K}$, inclusive, are on the two tickets.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dzt1cd5t.png)\n\nYou know you are the last customer, so after you purchase your tickets, no more tickets will be purchased. Then, an integer $c$ between $1$ and $\\textbf{K}$, inclusive, is chosen uniformly at random. If one of your tickets is strictly closer to $c$ than all other tickets or if both of your tickets are the same distance to $c$ and strictly closer than all other tickets, then you win the raffle. Otherwise, you do not win the raffle.\n\nGiven the integers on the $\\textbf{N}$ tickets purchased so far, what is the maximum probability of winning the raffle you can achieve by choosing the integers on your two tickets optimally?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\textbf{T}$. $\\textbf{T}$ test cases follow. Each test case consists of two lines. The first line of a test case contains two integers $\\textbf{N}$ and $\\textbf{K}$: the number of tickets already sold and the limit of the range of integers to pick from, respectively. The second line contains $\\textbf{N}$ integers $\\textbf{P}_1, \\textbf{P}_2, \\ldots, \\textbf{P}_\\textbf{N}$, representing the integers on the tickets that have already been purchased.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from $1$) and $y$ is the maximum win probability you can achieve if you choose your tickets optimally. $y$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer. See the FAQ for an explanation of what that means, and what formats of real numbers we accept.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, you can purchase tickets with the integers $4$ and $8$ on them and then win if $4$, $5$, $8$, $9$, or $10$ are chosen giving you $\\frac{5}{10} = 0.5$ probability of winning. Purchasing tickets with the integers $6$ and $8$ on them also yields a $0.5$ probability of winning, but no combination yields more.\n\nIn Sample Case #2, $6$ and $8$ is a possible optimal pair of tickets, which wins when $c$ is one of $6$, $8$, $9$, or $10$. Note that the integers on the tickets are not necessarily given in sorted order.\n\nIn Sample Case #3, every possible $c$ is at distance $0$ from an already purchased ticket, so you cannot win regardless of your choices.\n\nIn Sample Case #4, if you pick $3$ for at least one of your tickets, you win on $c = 3$, for $\\frac{1}{4} = 0.25$ win probability. There is no way to win when $c$ is any other integer, so that is the best you can do.\n\n**Limits**\n\n- $1 \\leq \\textbf{T} \\leq 100$.\n- $1 \\leq \\textbf{N} \\leq 30$.\n- $1 \\leq \\textbf{P}_i \\leq \\textbf{K}$, for all $i$.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- $1 \\leq \\textbf{K} \\leq 30$.\n\n**Test Set 2 (16 Pts, Visible Verdict)**\n\n- $1 \\leq \\textbf{K} \\leq 10^9$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #1C] Closest Pick", "background": "", "description": "你正在参加一场抽奖活动，奖品是终身免费煎饼。已有 $\\textbf{N}$ 张彩票售出。每张彩票包含一个 $1$ 到 $\\textbf{K}$ 之间的整数（含端点）。不同的彩票可以包含相同的整数。你确切知道所有已售出彩票上的数字，并希望通过购买两张彩票（可以包含相同的整数）来最大化中奖概率。你可以自由选择 $1$ 到 $\\textbf{K}$ 之间的任意整数作为这两张彩票的数字。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dzt1cd5t.png)\n\n你知道自己是最后一位顾客，因此在你购买彩票后，不会再有任何彩票售出。接着，系统会均匀随机选择一个 $1$ 到 $\\textbf{K}$ 之间的整数 $c$（含端点）。如果满足以下条件之一，你将赢得抽奖：\n- 你的一张彩票到 $c$ 的距离严格小于其他所有彩票；\n- 你的两张彩票到 $c$ 的距离相同，且严格小于其他所有彩票。\n\n否则，你将不会赢得抽奖。\n\n给定已售出的 $\\textbf{N}$ 张彩票上的整数，通过最优选择你的两张彩票上的整数，你能够达到的最大中奖概率是多少？", "inputFormat": "输入的第一行包含测试用例的数量 $\\textbf{T}$。随后是 $\\textbf{T}$ 个测试用例。每个测试用例包含两行：第一行是两个整数 $\\textbf{N}$ 和 $\\textbf{K}$，分别表示已售出的彩票数量和可选整数的上限；第二行包含 $\\textbf{N}$ 个整数 $\\textbf{P}_1, \\textbf{P}_2, \\ldots, \\textbf{P}_\\textbf{N}$，表示已售出彩票上的整数。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是你通过最优选择彩票能够达到的最大中奖概率。$y$ 的答案将被认为是正确的，如果其绝对误差或相对误差不超过 $10^{-6}$。关于误差范围的解释及可接受的实数格式，请参考 FAQ。\n", "hint": "**样例解释**\n\n在样例 #1 中，你可以购买数字为 $4$ 和 $8$ 的彩票。当 $c$ 为 $4$、$5$、$8$、$9$ 或 $10$ 时，你将赢得抽奖，中奖概率为 $\\frac{5}{10} = 0.5$。购买数字为 $6$ 和 $8$ 的彩票也能达到 $0.5$ 的中奖概率，但没有其他组合能超过这一概率。\n\n在样例 #2 中，$6$ 和 $8$ 是一个可能的最优组合，当 $c$ 为 $6$、$8$、$9$ 或 $10$ 时，你将赢得抽奖。注意，已售出彩票上的数字不一定按升序排列。\n\n在样例 #3 中，所有可能的 $c$ 都与至少一张已售出的彩票距离为 $0$，因此无论你如何选择彩票，都无法赢得抽奖。\n\n在样例 #4 中，如果你至少选择一张数字为 $3$ 的彩票，你将在 $c = 3$ 时赢得抽奖，中奖概率为 $\\frac{1}{4} = 0.25$。对于其他整数 $c$，你无法获胜，因此这是你能达到的最佳概率。\n\n**数据范围**\n\n- $1 \\leq \\textbf{T} \\leq 100$。\n- $1 \\leq \\textbf{N} \\leq 30$。\n- 对于所有 $i$，$1 \\leq \\textbf{P}_i \\leq \\textbf{K}$。\n\n**测试集 1（9 分，可见判定）**\n\n- $1 \\leq \\textbf{K} \\leq 30$。\n\n**测试集 2（16 分，可见判定）**\n\n- $1 \\leq \\textbf{K} \\leq 10^9$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13033", "type": "P", "difficulty": 5, "samples": [["4\n2020\n2021\n68000\n101", "Case #1: 2021\nCase #2: 2122\nCase #3: 78910\nCase #4: 123"]], "limits": {"time": [30000, 30000, 30000], "memory": [1048576, 1048576, 1048576]}, "tags": ["数学", "二分", "2021", "Google Code Jam"], "title": "[GCJ 2021 #1C] Roaring Years", "background": "", "description": "Something is happening in 2021 that has not happened in over a century. 2021, like 1920 before it, is a roaring year. A year represented by a positive integer $y$ is roaring if the decimal writing (without leading zeroes) of $y$ is the concatenation of the decimal writing (without leading zeroes) of two or more distinct consecutive positive integers, in increasing order. In this case, 2021 is a roaring year because it is the concatenation of 20 and 21.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/k37unt4l.png)\n\nOther examples of roaring years are 12, 789, 910, 1234, and 9899100. 2020 was not roaring because the only list of two or more positive integers that concatenate into 2020 is $[20, 20]$, and it is not made of consecutive integers. Similarly, there are only three lists for 2019: $[20, 1, 9]$, $[201, 9]$, and $[20, 19]$. The first two are not made of consecutive integers, while the third does not have the integers in increasing order. Thus, 2019 was also not roaring. As a final example, 778 was not a roaring year because $[7, 78]$ and $[77, 8]$ are not made up of consecutive integers and $[7, 7, 8]$ is not made up of distinct integers.\n\nGiven the current year (which may or may not be roaring), find what the next roaring year is going to be.", "inputFormat": "The first line of the input gives the number of test cases, $\\textbf{T}$. $\\textbf{T}$ lines follow. Each line represents a test case and contains a single integer $\\textbf{Y}$, the current year.\n", "outputFormat": "For each test case, output one line containing `Case #x: z`, where $x$ is the test case number (starting from 1) and $z$ is the first year strictly after $\\textbf{Y}$ that is roaring.", "hint": "**Sample Explanation**\n\nNotice in the last Sample Case that 102 is not a roaring year because $[10, 2]$ is not a list of consecutive integers and you cannot write 2 with a leading zero to use $[1, 02]$.\n\n**Limits**\n\n- $1 \\leq \\textbf{T} \\leq 100$.\n\n**Test Set 1 (15 Pts, Visible Verdict)**\n\n- $1 \\leq \\textbf{Y} \\leq 10^6$.\n\n**Test Set 2 (20 Pts, Hidden Verdict)**\n\n- $1 \\leq \\textbf{Y} \\leq 10^{18}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #1C] Roaring Years", "background": "", "description": "Something is happening in 2021 that has not happened in over a century. 2021, like 1920 before it, is a roaring year. A year represented by a positive integer $y$ is roaring if the decimal writing (without leading zeroes) of $y$ is the concatenation of the decimal writing (without leading zeroes) of two or more distinct consecutive positive integers, in increasing order. In this case, 2021 is a roaring year because it is the concatenation of 20 and 21.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/k37unt4l.png)\n\nOther examples of roaring years are 12, 789, 910, 1234, and 9899100. 2020 was not roaring because the only list of two or more positive integers that concatenate into 2020 is $[20, 20]$, and it is not made of consecutive integers. Similarly, there are only three lists for 2019: $[20, 1, 9]$, $[201, 9]$, and $[20, 19]$. The first two are not made of consecutive integers, while the third does not have the integers in increasing order. Thus, 2019 was also not roaring. As a final example, 778 was not a roaring year because $[7, 78]$ and $[77, 8]$ are not made up of consecutive integers and $[7, 7, 8]$ is not made up of distinct integers.\n\nGiven the current year (which may or may not be roaring), find what the next roaring year is going to be.", "inputFormat": "The first line of the input gives the number of test cases, $\\textbf{T}$. $\\textbf{T}$ lines follow. Each line represents a test case and contains a single integer $\\textbf{Y}$, the current year.\n", "outputFormat": "For each test case, output one line containing `Case #x: z`, where $x$ is the test case number (starting from 1) and $z$ is the first year strictly after $\\textbf{Y}$ that is roaring.", "hint": "**Sample Explanation**\n\nNotice in the last Sample Case that 102 is not a roaring year because $[10, 2]$ is not a list of consecutive integers and you cannot write 2 with a leading zero to use $[1, 02]$.\n\n**Limits**\n\n- $1 \\leq \\textbf{T} \\leq 100$.\n\n**Test Set 1 (15 Pts, Visible Verdict)**\n\n- $1 \\leq \\textbf{Y} \\leq 10^6$.\n\n**Test Set 2 (20 Pts, Hidden Verdict)**\n\n- $1 \\leq \\textbf{Y} \\leq 10^{18}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #1C] Roaring Years", "background": "", "description": "2021 年正在发生一件百年未遇的事情。与 1920 年一样，2021 年也是一个**咆哮年份**。一个正整数 $y$ 所代表的年份被称为咆哮年份，当且仅当 $y$ 的十进制表示（不含前导零）是两个或更多个不同的连续正整数的十进制表示（不含前导零）按递增顺序连接而成。在这个定义下，2021 是一个咆哮年份，因为它是 20 和 21 的连接。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/k37unt4l.png)\n\n其他咆哮年份的例子包括 12（1 和 2）、789（7、8、9）、910（9 和 10）、1234（1、2、3、4）以及 9899100（9899 和 100）。2020 不是咆哮年份，因为唯一能连接成 2020 的两个或多个正整数列表是 $[20, 20]$，而它们不是连续的整数。类似地，2019 只有三种可能的分解方式：$[20, 1, 9]$、$[201, 9]$ 和 $[20, 19]$。前两种不是连续整数，而第三种虽然连续但不是严格递增的，因此 2019 也不是咆哮年份。再举个例子，778 不是咆哮年份，因为 $[7, 78]$ 和 $[77, 8]$ 不是连续的整数，而 $[7, 7, 8]$ 中的数字不唯一。\n\n给定当前年份（可能是咆哮年份，也可能不是），找出下一个咆哮年份。", "inputFormat": "输入的第一行包含测试用例的数量 $\\textbf{T}$。随后是 $\\textbf{T}$ 行，每行一个测试用例，包含一个整数 $\\textbf{Y}$，表示当前年份。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: z`，其中 $x$ 是测试用例编号（从 1 开始），$z$ 是严格大于 $\\textbf{Y}$ 的第一个咆哮年份。\n", "hint": "**样例解释**\n\n注意最后一个样例，102 不是咆哮年份，因为 $[10, 2]$ 不是连续整数，且不能将 2 写作 $02$（带前导零）来构造 $[1, 02]$。\n\n**数据范围**\n\n- $1 \\leq \\textbf{T} \\leq 100$。\n\n**测试集 1（15 分，可见判定）**\n\n- $1 \\leq \\textbf{Y} \\leq 10^6$。\n\n**测试集 2（20 分，隐藏判定）**\n\n- $1 \\leq \\textbf{Y} \\leq 10^{18}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13034", "type": "P", "difficulty": 6, "samples": [["6\n10001 111\n1011 111\n1010 1011\n0 1\n0 101\n1101011 1101011", "Case #1: 4\nCase #2: 3\nCase #3: 2\nCase #4: 1\nCase #5: IMPOSSIBLE\nCase #6: 0"]], "limits": {"time": [10000, 10000, 10000], "memory": [1048576, 1048576, 1048576]}, "tags": ["图论", "2021", "KMP 算法", "Google Code Jam"], "title": "[GCJ 2021 #1C] Double or NOTing", "background": "", "description": "You are given a starting non-negative integer $\\textbf{S}$ and an ending non-negative integer $\\textbf{E}$. Both $\\textbf{S}$ and $\\textbf{E}$ are given by their binary representation (that is, they are given written in base 2). Your goal is to transform $\\textbf{S}$ into $\\textbf{E}$. The following two operations are available to you:\n\n- Double your current value.\n- Take the bitwise NOT of your current value. The binary representation of your current value is taken without unnecessary leading zeroes, and any unnecessary leading zeroes produced by the operation are dropped. (The only necessary leading zero is the one in the representation of 0).\n\nFor example, by using the double operation, 6 becomes 12, 0 becomes 0, and 10 becomes 20. By using the NOT operation, 0 becomes 1, 1 becomes 0, $3 = 11_2$ becomes 0, $14 = 1110_2$ becomes 1, $10 = 1010_2$ becomes $5 = 101_2$, and $5 = 101_2$ becomes $2 = 10_2$. ($X_2$ means the integer whose binary representation is $X$).\n\nYou can use these operations as many times as you want in any order. For example, you can transform $\\textbf{S} = 10001_2$ to $\\textbf{E} = 111_2$ using the NOT operation first, then using the double operation twice, and then another NOT operation:\n\n$$10001_2 \\xrightarrow{\\text{NOT}} 1110_2 \\xrightarrow{\\times2} 11100_2 \\xrightarrow{\\times2} 111000_2 \\xrightarrow{\\text{NOT}} 111_2.$$\n\nDetermine the smallest number of operations needed to complete the transformation, or say it is impossible to do so.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\textbf{T}$. $\\textbf{T}$ test cases follow. Each consists of a single line containing two strings $\\textbf{S}$ and $\\textbf{E}$, the binary representations of the starting and ending integers, respectively.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is IMPOSSIBLE if there is no way to transform $\\textbf{S}$ into $\\textbf{E}$ using the two operations. Otherwise, $y$ is the smallest number of operations needed to transform $\\textbf{S}$ into $\\textbf{E}$.", "hint": "**Sample Explanation**\n\nSample Case #1 is the example shown in the main part of the statement.\n\nThese are possible optimal ways of solving Sample Cases #2, #3, and #4, respectively:\n\n$$1011_2 \\xrightarrow{\\text{NOT}} 100_2 \\xrightarrow{\\times2} 1000_2 \\xrightarrow{\\text{NOT}} 111_2,$$\n\n$$1010_2 \\xrightarrow{\\times2} 10100_2 \\xrightarrow{\\text{NOT}} 1011_2,$$ \n\nand\n\n$$0_2 \\xrightarrow{\\text{NOT}} 1_2.$$\n\nIn Sample Case #5, it is not possible to get from $0_2$ to $101_2$ with any sequence of operations.\n\nIn Sample Case #6, we do not need to perform any operations because $\\textbf{S} = \\textbf{E}$.\n\n**Limits**\n\n- $1 \\leq \\textbf{T} \\leq 100$.\n- Each character of $\\textbf{S}$ is either 0 or 1.\n- The first digit of $\\textbf{S}$ can be 0 only if the length of $\\textbf{S}$ is 1.\n- Each character of $\\textbf{E}$ is either 0 or 1.\n- The first digit of $\\textbf{E}$ can be 0 only if the length of $\\textbf{E}$ is 1.\n\n**Test Set 1 (14 Pts, Visible Verdict)**\n\n- $1 \\leq \\text{the length of } \\textbf{S} \\leq 8$.\n- $1 \\leq \\text{the length of } \\textbf{E} \\leq 8$.\n\n**Test Set 2 (26 Pts, Hidden Verdict)**\n\n- $1 \\leq \\text{the length of } \\textbf{S} \\leq 100$.\n- $1 \\leq \\text{the length of } \\textbf{E} \\leq 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #1C] Double or NOTing", "background": "", "description": "You are given a starting non-negative integer $\\textbf{S}$ and an ending non-negative integer $\\textbf{E}$. Both $\\textbf{S}$ and $\\textbf{E}$ are given by their binary representation (that is, they are given written in base 2). Your goal is to transform $\\textbf{S}$ into $\\textbf{E}$. The following two operations are available to you:\n\n- Double your current value.\n- Take the bitwise NOT of your current value. The binary representation of your current value is taken without unnecessary leading zeroes, and any unnecessary leading zeroes produced by the operation are dropped. (The only necessary leading zero is the one in the representation of 0).\n\nFor example, by using the double operation, 6 becomes 12, 0 becomes 0, and 10 becomes 20. By using the NOT operation, 0 becomes 1, 1 becomes 0, $3 = 11_2$ becomes 0, $14 = 1110_2$ becomes 1, $10 = 1010_2$ becomes $5 = 101_2$, and $5 = 101_2$ becomes $2 = 10_2$. ($X_2$ means the integer whose binary representation is $X$).\n\nYou can use these operations as many times as you want in any order. For example, you can transform $\\textbf{S} = 10001_2$ to $\\textbf{E} = 111_2$ using the NOT operation first, then using the double operation twice, and then another NOT operation:\n\n$$10001_2 \\xrightarrow{\\text{NOT}} 1110_2 \\xrightarrow{\\times2} 11100_2 \\xrightarrow{\\times2} 111000_2 \\xrightarrow{\\text{NOT}} 111_2.$$\n\nDetermine the smallest number of operations needed to complete the transformation, or say it is impossible to do so.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\textbf{T}$. $\\textbf{T}$ test cases follow. Each consists of a single line containing two strings $\\textbf{S}$ and $\\textbf{E}$, the binary representations of the starting and ending integers, respectively.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is IMPOSSIBLE if there is no way to transform $\\textbf{S}$ into $\\textbf{E}$ using the two operations. Otherwise, $y$ is the smallest number of operations needed to transform $\\textbf{S}$ into $\\textbf{E}$.", "hint": "**Sample Explanation**\n\nSample Case #1 is the example shown in the main part of the statement.\n\nThese are possible optimal ways of solving Sample Cases #2, #3, and #4, respectively:\n\n$$1011_2 \\xrightarrow{\\text{NOT}} 100_2 \\xrightarrow{\\times2} 1000_2 \\xrightarrow{\\text{NOT}} 111_2,$$\n\n$$1010_2 \\xrightarrow{\\times2} 10100_2 \\xrightarrow{\\text{NOT}} 1011_2,$$ \n\nand\n\n$$0_2 \\xrightarrow{\\text{NOT}} 1_2.$$\n\nIn Sample Case #5, it is not possible to get from $0_2$ to $101_2$ with any sequence of operations.\n\nIn Sample Case #6, we do not need to perform any operations because $\\textbf{S} = \\textbf{E}$.\n\n**Limits**\n\n- $1 \\leq \\textbf{T} \\leq 100$.\n- Each character of $\\textbf{S}$ is either 0 or 1.\n- The first digit of $\\textbf{S}$ can be 0 only if the length of $\\textbf{S}$ is 1.\n- Each character of $\\textbf{E}$ is either 0 or 1.\n- The first digit of $\\textbf{E}$ can be 0 only if the length of $\\textbf{E}$ is 1.\n\n**Test Set 1 (14 Pts, Visible Verdict)**\n\n- $1 \\leq \\text{the length of } \\textbf{S} \\leq 8$.\n- $1 \\leq \\text{the length of } \\textbf{E} \\leq 8$.\n\n**Test Set 2 (26 Pts, Hidden Verdict)**\n\n- $1 \\leq \\text{the length of } \\textbf{S} \\leq 100$.\n- $1 \\leq \\text{the length of } \\textbf{E} \\leq 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #1C] Double or NOTing", "background": "", "description": "给定一个起始非负整数 $\\textbf{S}$ 和一个目标非负整数 $\\textbf{E}$。$\\textbf{S}$ 和 $\\textbf{E}$ 都以二进制形式给出（即以 2 为基数的表示）。你的目标是通过以下两种操作将 $\\textbf{S}$ 转换为 $\\textbf{E}$：\n\n1. **双倍操作**：将当前值乘以 2。\n2. **取反操作**：对当前值进行按位取反。当前值的二进制表示不包含不必要的前导零，且操作后产生的不必要前导零将被移除。（唯一必要的前导零是表示 0 时的那个零）。\n\n例如：\n- 双倍操作：6 变为 12，0 保持为 0，10 变为 20。\n- 取反操作：0 变为 1，1 变为 0，$3 = 11_2$ 变为 0，$14 = 1110_2$ 变为 1，$10 = 1010_2$ 变为 $5 = 101_2$，$5 = 101_2$ 变为 $2 = 10_2$。（$X_2$ 表示二进制表示为 $X$ 的整数）。\n\n你可以按任意顺序、任意次数使用这两种操作。例如，可以通过先取反，再两次双倍，最后再取反，将 $\\textbf{S} = 10001_2$ 转换为 $\\textbf{E} = 111_2$：\n\n$$10001_2 \\xrightarrow{\\text{取反}} 1110_2 \\xrightarrow{\\times2} 11100_2 \\xrightarrow{\\times2} 111000_2 \\xrightarrow{\\text{取反}} 111_2.$$\n\n你的任务是确定完成转换所需的最少操作次数，或者判定转换**不可能**。", "inputFormat": "输入的第一行是测试用例的数量 $\\textbf{T}$。接下来是 $\\textbf{T}$ 个测试用例，每个测试用例占一行，包含两个字符串 $\\textbf{S}$ 和 $\\textbf{E}$，分别表示起始整数和目标整数的二进制形式。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是 `IMPOSSIBLE`（如果无法通过操作将 $\\textbf{S}$ 转换为 $\\textbf{E}$），否则 $y$ 是所需的最少操作次数。\n", "hint": "**样例解释**\n\n样例 #1 是题目描述中给出的示例。\n\n以下是样例 #2、#3 和 #4 的可能最优解法：\n\n$$1011_2 \\xrightarrow{\\text{取反}} 100_2 \\xrightarrow{\\times2} 1000_2 \\xrightarrow{\\text{取反}} 111_2,$$\n\n$$1010_2 \\xrightarrow{\\times2} 10100_2 \\xrightarrow{\\text{取反}} 1011_2,$$\n\n$$0_2 \\xrightarrow{\\text{取反}} 1_2.$$\n\n在样例 #5 中，无法通过任何操作序列将 $0_2$ 转换为 $101_2$。\n\n在样例 #6 中，$\\textbf{S} = \\textbf{E}$，因此无需任何操作。\n\n**数据范围**\n\n- $1 \\leq \\textbf{T} \\leq 100$。\n- $\\textbf{S}$ 的每个字符是 0 或 1。\n- $\\textbf{S}$ 的首字符可以是 0，仅当 $\\textbf{S}$ 的长度为 1 时。\n- $\\textbf{E}$ 的每个字符是 0 或 1。\n- $\\textbf{E}$ 的首字符可以是 0，仅当 $\\textbf{E}$ 的长度为 1 时。\n\n**测试集 1（14 分，可见判定）**\n\n- $1 \\leq \\text{\\textbf{S} 的长度} \\leq 8$。\n- $1 \\leq \\text{\\textbf{E} 的长度} \\leq 8$。\n\n**测试集 2（26 分，隐藏判定）**\n\n- $1 \\leq \\text{\\textbf{S} 的长度} \\leq 100$。\n- $1 \\leq \\text{\\textbf{E} 的长度} \\leq 100$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
