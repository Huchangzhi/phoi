{"pid": "P12772", "type": "P", "difficulty": 0, "samples": [["4 5\n1 10 0 11 3", "2"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "POI（波兰）"], "title": "[POI 2018/2019 R1] 俱乐部成员 2 Club members 2", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/4918)。", "description": "**题目译自 [XXVI Olimpiada Informatyczna – I etap](https://sio2.mimuw.edu.pl/c/oi26-1/dashboard/) [Klubowicze 2](https://sio2.mimuw.edu.pl/c/oi26-1/p/klu/)**\n\n我们再次来到了字节克讨论俱乐部。这个俱乐部有 $2^{n}$ 名成员，每人都对 $n$ 个基本问题表达了自己的看法。这些问题的具体内容不重要，只需知道每个问题都有两种答案可选。每个人的看法可以用一串二进制位表示，转化为十进制后是 $0$ 到 $2^{n}-1$ 之间的整数。而且，俱乐部里没有两人的看法完全相同。\n\n今天，俱乐部又一次聚会，$m$ 名成员到场，每人已在传统圆桌旁选好了座位。现在，他们要讨论一个万众期待的非常重要的话题。为了充分准备，大家决定分成两个小组，先在组内讨论。为了避免混乱，每个小组必须由圆桌上连续座位的成员组成。同时，为了讨论的全面性，每个小组需涵盖所有观点，也就是说，对于每个基本问题及其两种答案，如果一组里有人持某种看法，另一组里也必须有人持同样看法。\n\n请你写一个程序，算出可以将这些成员分成两个小组的方法有多少种。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $m$ $(n \\geq 2, m \\geq 3)$，分别表示基本问题的数量和参加聚会的成员人数。\n\n第二行包含 $m$ 个互不相同的整数，范围在 $0$ 到 $2^{n}-1$ 之间，按圆桌顺序表示每位成员的看法。", "outputFormat": "输出一个整数，表示将成员分成满足条件的两个小组的方法的数量。", "hint": "**样例 1 解释**\n\n有两种正确分组方式：$1 10 \\mid 0 11 3$ 和 $3 1 10 \\mid 0 11$。\n\n**附加样例**\n\n1. $n=5, m=6$，答案为 $4$； \n2. 一个小样例，答案为 $0$；\n3. $n=20, m=2^{n}$，成员按升序排列，答案很大。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$      | $n \\leq 15, m \\leq \\min(2^{n}, 100)$ | $15$   |\n| $2$      | $n \\leq 15, m \\leq \\min(2^{n}, 5000)$ | $20$   |\n| $3$      | $n \\leq 30, m \\leq \\min(2^{n}, 100000)$ | $45$   |\n| $4$      | $n \\leq 30, m \\leq \\min(2^{n}, 2000000)$ | $20$   |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2018/2019 R1] 俱乐部成员 2 Club members 2", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/4918)。", "description": "**题目译自 [XXVI Olimpiada Informatyczna – I etap](https://sio2.mimuw.edu.pl/c/oi26-1/dashboard/) [Klubowicze 2](https://sio2.mimuw.edu.pl/c/oi26-1/p/klu/)**\n\n我们再次来到了字节克讨论俱乐部。这个俱乐部有 $2^{n}$ 名成员，每人都对 $n$ 个基本问题表达了自己的看法。这些问题的具体内容不重要，只需知道每个问题都有两种答案可选。每个人的看法可以用一串二进制位表示，转化为十进制后是 $0$ 到 $2^{n}-1$ 之间的整数。而且，俱乐部里没有两人的看法完全相同。\n\n今天，俱乐部又一次聚会，$m$ 名成员到场，每人已在传统圆桌旁选好了座位。现在，他们要讨论一个万众期待的非常重要的话题。为了充分准备，大家决定分成两个小组，先在组内讨论。为了避免混乱，每个小组必须由圆桌上连续座位的成员组成。同时，为了讨论的全面性，每个小组需涵盖所有观点，也就是说，对于每个基本问题及其两种答案，如果一组里有人持某种看法，另一组里也必须有人持同样看法。\n\n请你写一个程序，算出可以将这些成员分成两个小组的方法有多少种。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $m$ $(n \\geq 2, m \\geq 3)$，分别表示基本问题的数量和参加聚会的成员人数。\n\n第二行包含 $m$ 个互不相同的整数，范围在 $0$ 到 $2^{n}-1$ 之间，按圆桌顺序表示每位成员的看法。", "outputFormat": "输出一个整数，表示将成员分成满足条件的两个小组的方法的数量。", "hint": "**样例 1 解释**\n\n有两种正确分组方式：$1 10 \\mid 0 11 3$ 和 $3 1 10 \\mid 0 11$。\n\n**附加样例**\n\n1. $n=5, m=6$，答案为 $4$； \n2. 一个小样例，答案为 $0$；\n3. $n=20, m=2^{n}$，成员按升序排列，答案很大。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$      | $n \\leq 15, m \\leq \\min(2^{n}, 100)$ | $15$   |\n| $2$      | $n \\leq 15, m \\leq \\min(2^{n}, 5000)$ | $20$   |\n| $3$      | $n \\leq 30, m \\leq \\min(2^{n}, 100000)$ | $45$   |\n| $4$      | $n \\leq 30, m \\leq \\min(2^{n}, 2000000)$ | $20$   |", "locale": "zh-CN"}}}
{"pid": "P12773", "type": "P", "difficulty": 0, "samples": [["ACTAGG\nGATCA", "ACA"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "POI（波兰）", "Special Judge"], "title": "[POI 2018/2019 R1] 马虎 Nonchalance", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/4919)。", "description": "**题目译自 [XXVI Olimpiada Informatyczna – I etap](https://sio2.mimuw.edu.pl/c/oi26-1/dashboard/) [Niedbałość](https://sio2.mimuw.edu.pl/c/oi26-1/p/nie/)**\n\nBajtazar 先生是 Bajtocji 第 $2^{8}-1$ 高中的生物老师。他给 Bajtek 和同学们布置了一道遗传学作业：找出两个基因型之间的最大亲缘关系。也就是说，你得找到这两个基因型中都包含的最长氨基酸序列（不一定连续）。Bajtek 他们很清楚，这任务烦琐得要命，更别提懒惰的 Bajtazar 先生居然会花时间检查。他们从学长那儿听说，这位老师检查作业很马虎——他只看你给的序列能不能在某处再加一个氨基酸，还保持是两个基因型的子序列。如果加不进去，你就能拿满分。\n\n假设基因型是只由字母 $\\texttt{A}$、$\\texttt{C}$、$\\texttt{G}$、$\\texttt{T}$ 组成的序列。设 $S = (s_{1}, \\ldots, s_{n})$ 和 $T = (t_{1}, \\ldots, t_{m})$ 是给定的两个基因型，长度分别为 $n$ 和 $m$。要拿满分，你需要给出一个序列 $W = (w_{1}, \\ldots, w_{k})$，它既是 $S$ 的子序列，也是 $T$ 的子序列，而且不存在任何长度为 $k+1$ 的序列 $W^{\\prime}$，包含 $W$ 作为子序列，同时还是 $S$ 和 $T$ 的子序列。\n\n请你帮 Bajtek 和他的小伙伴们拿到最高分。", "inputFormat": "输入第一行是一个长度为 $n$ 的基因型，用大写字母 $\\texttt{A}$、$\\texttt{T}$、$\\texttt{C}$、$\\texttt{G}$ 表示。\n\n第二行是另一个长度为 $m$ 的基因型，格式相同。", "outputFormat": "输出一行，用 $\\texttt{A}$、$\\texttt{C}$、$\\texttt{G}$、$\\texttt{T}$ 字母组成一个**不可扩展**的序列，作为输入中两个基因型的亲缘证据。如果有多个正确答案，你的程序可以输出任意一个。\n\n保证答案始终存在且非空。", "hint": "**样例 1 解释**\n\n`ATA` 和 `G` 也是合法的输出。\n\n**附加样例**\n\n1. $n=m=7$，基因型只有字母 $\\texttt{A}$ 和 $\\texttt{T}$；  \n2. $n=100, m=10000$，第一个基因型是第二个的子序列；  \n3. $n=m=1000000$，第一个基因型的氨基酸按字母顺序排列。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$      | $n, m \\leq 12$              | $10$   |\n| $2$      | $n, m \\leq 100$             | $10$   |\n| $3$      | $n, m \\leq 1000$            | $10$   |\n| $4$      | $n, m \\leq 50000$           | $20$   |\n| $5$      | $n, m \\leq 1000000$，基因型仅包含 $\\texttt{A}$ 和 $\\texttt{T}$ | $20$   |\n| $6$      | $n, m \\leq 1000000$         | $30$   |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2018/2019 R1] 马虎 Nonchalance", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/4919)。", "description": "**题目译自 [XXVI Olimpiada Informatyczna – I etap](https://sio2.mimuw.edu.pl/c/oi26-1/dashboard/) [Niedbałość](https://sio2.mimuw.edu.pl/c/oi26-1/p/nie/)**\n\nBajtazar 先生是 Bajtocji 第 $2^{8}-1$ 高中的生物老师。他给 Bajtek 和同学们布置了一道遗传学作业：找出两个基因型之间的最大亲缘关系。也就是说，你得找到这两个基因型中都包含的最长氨基酸序列（不一定连续）。Bajtek 他们很清楚，这任务烦琐得要命，更别提懒惰的 Bajtazar 先生居然会花时间检查。他们从学长那儿听说，这位老师检查作业很马虎——他只看你给的序列能不能在某处再加一个氨基酸，还保持是两个基因型的子序列。如果加不进去，你就能拿满分。\n\n假设基因型是只由字母 $\\texttt{A}$、$\\texttt{C}$、$\\texttt{G}$、$\\texttt{T}$ 组成的序列。设 $S = (s_{1}, \\ldots, s_{n})$ 和 $T = (t_{1}, \\ldots, t_{m})$ 是给定的两个基因型，长度分别为 $n$ 和 $m$。要拿满分，你需要给出一个序列 $W = (w_{1}, \\ldots, w_{k})$，它既是 $S$ 的子序列，也是 $T$ 的子序列，而且不存在任何长度为 $k+1$ 的序列 $W^{\\prime}$，包含 $W$ 作为子序列，同时还是 $S$ 和 $T$ 的子序列。\n\n请你帮 Bajtek 和他的小伙伴们拿到最高分。", "inputFormat": "输入第一行是一个长度为 $n$ 的基因型，用大写字母 $\\texttt{A}$、$\\texttt{T}$、$\\texttt{C}$、$\\texttt{G}$ 表示。\n\n第二行是另一个长度为 $m$ 的基因型，格式相同。", "outputFormat": "输出一行，用 $\\texttt{A}$、$\\texttt{C}$、$\\texttt{G}$、$\\texttt{T}$ 字母组成一个**不可扩展**的序列，作为输入中两个基因型的亲缘证据。如果有多个正确答案，你的程序可以输出任意一个。\n\n保证答案始终存在且非空。", "hint": "**样例 1 解释**\n\n`ATA` 和 `G` 也是合法的输出。\n\n**附加样例**\n\n1. $n=m=7$，基因型只有字母 $\\texttt{A}$ 和 $\\texttt{T}$；  \n2. $n=100, m=10000$，第一个基因型是第二个的子序列；  \n3. $n=m=1000000$，第一个基因型的氨基酸按字母顺序排列。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$      | $n, m \\leq 12$              | $10$   |\n| $2$      | $n, m \\leq 100$             | $10$   |\n| $3$      | $n, m \\leq 1000$            | $10$   |\n| $4$      | $n, m \\leq 50000$           | $20$   |\n| $5$      | $n, m \\leq 1000000$，基因型仅包含 $\\texttt{A}$ 和 $\\texttt{T}$ | $20$   |\n| $6$      | $n, m \\leq 1000000$         | $30$   |", "locale": "zh-CN"}}}
{"pid": "P12774", "type": "P", "difficulty": 0, "samples": [["1\n6 4\n0 1 2 3 4 5\n3 1 3 6", "3"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2019", "POI（波兰）"], "title": "[POI 2018/2019 R1] 一对项链 Pair of necklaces", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/4920)。", "description": "**题目译自 [XXVI Olimpiada Informatyczna – I etap](https://sio2.mimuw.edu.pl/c/oi26-1/dashboard/) [Para naszyjników](https://sio2.mimuw.edu.pl/c/oi26-1/p/par/)**\n\nBajtazar 最近在字节城开了家珠宝店。他刚接到一个特别的订单：一位客户给了他两条由各种宝石串成的链子，要求打造一对项链。客户提出了几个条件：\n- 两条项链长度必须完全相同；\n- 一条来自第一条链子，另一条来自第二条；\n- 每条项链必须是从链子上连续的一段；\n- 第一条项链的宝石总价值与第二条的宝石总价值必须有相同的奇偶性；\n- 在所有可能的项链中，挑出最长的。\n\n这种要求也只有在字节城才能见到！\n\n请你帮 Bajtazar 完成这个订单，写一个程序，找出给定链子中最长可能的项链长度。", "inputFormat": "输入的第一行是一个自然数 $q$ $(1 \\leq q \\leq 20000)$，表示测试数据组数。接下来是每组测试数据的描述。\n\n每个测试数据占三行：  \n- 第一行包含两个整数 $n$ 和 $m$ $(1 \\leq n, m \\leq 100000)$，表示第一条和第二条链子的宝石数量；  \n- 第二行是 $n$ 个整数（范围 $0$ 到 $10^{9}$），表示第一条链子上各宝石的价值；  \n- 第三行是 $m$ 个整数（范围 $0$ 到 $10^{9}$），表示第二条链子上各宝石的价值。  \n\n每个测试中，所有测试数据的 $n$ 和 $m$ 之和不超过 $20000000$。", "outputFormat": "对于每组测试数据，按输入顺序输出一行，包含一个整数，表示满足客户要求的最长项链长度。", "hint": "**样例 1 解释**\n\n最长的项链由 3 个宝石组成。例如，可以从第一条链子取 $2, 3, 4$（总价值 $9$，奇数），从第二条链子取 $3, 1, 3$（总价值 $7$，奇数）。\n\n**附加样例**\n\n1. $q=1, n=m=10$，第一条链子宝石价值全是 $1$，第二条全是 $0$；  \n2. $q=1, n=m=1000$，第一条链子宝石价值按 $1, 0, 3, 5, 2, 1$ 循环，第二条全是 $2$；  \n3. $q=1, n=100000, m=99999$，第一条链子全是 $100$，第二条混入一个 $99$。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$      | $n, m \\leq 1000$，每个测试点最有 $10$ 个 $n, m > 100$ 的数据 | $15$   |\n| $2$      | $n \\leq 1000$，每个测试点最多有 $30$ 个 $n > 100$ 的数据 | $10$   |\n| $3$      | 宝石价值随机生成            | $10$   |\n| $4$      | $n = m$                     | $15$   |\n| $5$      | 无附加限制                  | $50$   |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2018/2019 R1] 一对项链 Pair of necklaces", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/4920)。", "description": "**题目译自 [XXVI Olimpiada Informatyczna – I etap](https://sio2.mimuw.edu.pl/c/oi26-1/dashboard/) [Para naszyjników](https://sio2.mimuw.edu.pl/c/oi26-1/p/par/)**\n\nBajtazar 最近在字节城开了家珠宝店。他刚接到一个特别的订单：一位客户给了他两条由各种宝石串成的链子，要求打造一对项链。客户提出了几个条件：\n- 两条项链长度必须完全相同；\n- 一条来自第一条链子，另一条来自第二条；\n- 每条项链必须是从链子上连续的一段；\n- 第一条项链的宝石总价值与第二条的宝石总价值必须有相同的奇偶性；\n- 在所有可能的项链中，挑出最长的。\n\n这种要求也只有在字节城才能见到！\n\n请你帮 Bajtazar 完成这个订单，写一个程序，找出给定链子中最长可能的项链长度。", "inputFormat": "输入的第一行是一个自然数 $q$ $(1 \\leq q \\leq 20000)$，表示测试数据组数。接下来是每组测试数据的描述。\n\n每个测试数据占三行：  \n- 第一行包含两个整数 $n$ 和 $m$ $(1 \\leq n, m \\leq 100000)$，表示第一条和第二条链子的宝石数量；  \n- 第二行是 $n$ 个整数（范围 $0$ 到 $10^{9}$），表示第一条链子上各宝石的价值；  \n- 第三行是 $m$ 个整数（范围 $0$ 到 $10^{9}$），表示第二条链子上各宝石的价值。  \n\n每个测试中，所有测试数据的 $n$ 和 $m$ 之和不超过 $20000000$。", "outputFormat": "对于每组测试数据，按输入顺序输出一行，包含一个整数，表示满足客户要求的最长项链长度。", "hint": "**样例 1 解释**\n\n最长的项链由 3 个宝石组成。例如，可以从第一条链子取 $2, 3, 4$（总价值 $9$，奇数），从第二条链子取 $3, 1, 3$（总价值 $7$，奇数）。\n\n**附加样例**\n\n1. $q=1, n=m=10$，第一条链子宝石价值全是 $1$，第二条全是 $0$；  \n2. $q=1, n=m=1000$，第一条链子宝石价值按 $1, 0, 3, 5, 2, 1$ 循环，第二条全是 $2$；  \n3. $q=1, n=100000, m=99999$，第一条链子全是 $100$，第二条混入一个 $99$。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$      | $n, m \\leq 1000$，每个测试点最有 $10$ 个 $n, m > 100$ 的数据 | $15$   |\n| $2$      | $n \\leq 1000$，每个测试点最多有 $30$ 个 $n > 100$ 的数据 | $10$   |\n| $3$      | 宝石价值随机生成            | $10$   |\n| $4$      | $n = m$                     | $15$   |\n| $5$      | 无附加限制                  | $50$   |", "locale": "zh-CN"}}}
{"pid": "P12775", "type": "P", "difficulty": 6, "samples": [["5\n7\n10\n42\n15\n512", "ioi\nMmmmm\nERRATA\n0000FF\nR3GuLaM1N"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "POI（波兰）", "Special Judge", "随机化", "Ad-hoc"], "title": "[POI 2018/2019 R1] 子序列 Subsequences", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/4921)。", "description": "**题目译自 [XXVI Olimpiada Informatyczna – I etap](https://sio2.mimuw.edu.pl/c/oi26-1/dashboard/) [Podciągi](https://sio2.mimuw.edu.pl/c/oi26-1/p/pod/)**\n\n请你写一个程序，对于给定的自然数 $n$，生成一个不太长、字符种类不多的字符串，使它正好有 $n$ 个不同的子序列。\n\n具体来说，假设字符串 $w$ 由字符 $w_{1}, w_{2}, \\ldots, w_{m}$ 组成。它的子序列是指形如 $w_{i_{1}} w_{i_{2}} \\ldots w_{i_{k}}$ 的任意字符串，其中 $0 \\leq k \\leq m$ 且 $1 \\leq i_{1} < i_{2} < \\ldots < i_{k} \\leq m$。特别地，空字符串（长度为 $0$）也是 $w$ 的子序列。两个子序列若表示的字符串不同，就视为不同。例如，字符串 `ioi` 有 $7$ 个不同子序列：空字符串以及 `i`、`o`、`ii`、`io`、`oi`、`ioi`。注意，单字符子序列 `i` 在 `ioi` 中出现了两次，但只统计一次。", "inputFormat": "输入的第一行是一个自然数 $q$ $(1 \\leq q \\leq 10000)$，表示输入数据组数。\n\n接下来的 $q$ 行，每行一个自然数 $n$ $(2 \\leq n \\leq 10^{18})$，表示你生成的字符串需要有的不同子序列数量（包括空子序列）。", "outputFormat": "输出 $q$ 行，每行对应一组输入数据的答案。每行是一个字符串，最多包含 $1000$ 个字符，可以使用数字以及英文大小写字母（这些字符在比较子序列时互不相同）。该字符串需恰好有 $n$ 个不同子序列。\n\n若有多个正确答案，输出任意一个即可。\n\n若无满足条件的答案，输出 `!`。", "hint": "详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$      | 每个 $n$ 的质因数分解之和不超过 $300$ | $20$   |\n| $2$      | 每个 $n$ 是两个 $2$ 的幂之差          | $10$   |\n| $3$      | $n$ 的二进制不以 `01` 或 `010` 结尾，且无相邻 `0` | $10$   |\n| $4$      | $n \\leq 10^{6}$，随机生成           | $20$   |\n| $5$      | $n \\leq 10^{18}$，随机生成          | $30$   |\n| $6$      | $n \\leq 10^{18}$，非随机生成        | $10$   |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2018/2019 R1] 子序列 Subsequences", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/4921)。", "description": "**题目译自 [XXVI Olimpiada Informatyczna – I etap](https://sio2.mimuw.edu.pl/c/oi26-1/dashboard/) [Podciągi](https://sio2.mimuw.edu.pl/c/oi26-1/p/pod/)**\n\n请你写一个程序，对于给定的自然数 $n$，生成一个不太长、字符种类不多的字符串，使它正好有 $n$ 个不同的子序列。\n\n具体来说，假设字符串 $w$ 由字符 $w_{1}, w_{2}, \\ldots, w_{m}$ 组成。它的子序列是指形如 $w_{i_{1}} w_{i_{2}} \\ldots w_{i_{k}}$ 的任意字符串，其中 $0 \\leq k \\leq m$ 且 $1 \\leq i_{1} < i_{2} < \\ldots < i_{k} \\leq m$。特别地，空字符串（长度为 $0$）也是 $w$ 的子序列。两个子序列若表示的字符串不同，就视为不同。例如，字符串 `ioi` 有 $7$ 个不同子序列：空字符串以及 `i`、`o`、`ii`、`io`、`oi`、`ioi`。注意，单字符子序列 `i` 在 `ioi` 中出现了两次，但只统计一次。", "inputFormat": "输入的第一行是一个自然数 $q$ $(1 \\leq q \\leq 10000)$，表示输入数据组数。\n\n接下来的 $q$ 行，每行一个自然数 $n$ $(2 \\leq n \\leq 10^{18})$，表示你生成的字符串需要有的不同子序列数量（包括空子序列）。", "outputFormat": "输出 $q$ 行，每行对应一组输入数据的答案。每行是一个字符串，最多包含 $1000$ 个字符，可以使用数字以及英文大小写字母（这些字符在比较子序列时互不相同）。该字符串需恰好有 $n$ 个不同子序列。\n\n若有多个正确答案，输出任意一个即可。\n\n若无满足条件的答案，输出 `!`。", "hint": "详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$      | 每个 $n$ 的质因数分解之和不超过 $300$ | $20$   |\n| $2$      | 每个 $n$ 是两个 $2$ 的幂之差          | $10$   |\n| $3$      | $n$ 的二进制不以 `01` 或 `010` 结尾，且无相邻 `0` | $10$   |\n| $4$      | $n \\leq 10^{6}$，随机生成           | $20$   |\n| $5$      | $n \\leq 10^{18}$，随机生成          | $30$   |\n| $6$      | $n \\leq 10^{18}$，非随机生成        | $10$   |", "locale": "zh-CN"}}}
{"pid": "P12776", "type": "P", "difficulty": 0, "samples": [["4 28\n2 3 1 2\n3 2", "2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "POI（波兰）"], "title": "[POI 2018/2019 R1] 小机器人 Robby the little robot", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/4922)。", "description": "**题目译自 [XXVI Olimpiada Informatyczna – I etap](https://sio2.mimuw.edu.pl/c/oi26-1/dashboard/) [Robocik](https://sio2.mimuw.edu.pl/c/oi26-1/p/rob/)**\n\n想象一个带有直角坐标系的平面。在坐标 $(0,0)$ 处，有一个朝北（即 $y$ 坐标增大的方向）的小机器人等着你的指令。你可以通过一个命令序列 $d_{1}, d_{2}, \\ldots, d_{n}$ 来编程控制它。启动后，机器人会按顺序执行动作：第 $i$ $(i \\geq 1)$ 次移动时，它会向前走 $d_{((i-1) \\bmod n)+1}$ 个单位，然后向右转 $90^\\circ$。\n\n机器人有块电池，能支持它运行 $t$ 秒。无论是移动一个单位还是转 $90^\\circ$，都耗时 $1$ 秒。\n\n请你写一个程序，算出在电池耗尽前，机器人会在指定点 $(x, y)$ 上出现多少次。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $t$ $(1 \\leq n \\leq 100000, t \\geq 1)$，分别表示命令序列的长度和电池运行时间。\n\n第二行包含 $n$ 个整数 $d_{1}, \\ldots, d_{n}$ $(1 \\leq d_{i} \\leq 10^{9})$，表示命令序列中的移动距离。\n\n第三行包含两个整数 $x$ 和 $y$ $(-10^{9} \\leq x, y \\leq 10^{9})$，表示我们要查询的点的坐标。", "outputFormat": "输出一个整数，表示机器人到达点 $(x, y)$ 的次数。如果它在时间 $0$ 或 $t$ 时位于该点，也要计入。", "hint": "**样例 1 解释**\n\n机器人会在启动后的第 $6$ 秒和第 $22$ 秒到达点 $(3,2)$。其路径如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/le8akpzi.png)\n\n**附加样例**\n\n1. 跟样例相同，但 $t=21$；  \n2. $n=1$ 的样例；  \n3. 大型螺旋样例，$d_{i}=i, n=31, t=\\frac{10^{18}-1}{3}$。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$      | $t \\leq 10^{6}$             | $10$   |\n| $2$      | $t \\leq 10^{12}, 10^{6} \\leq d_{i}$ | $30$   |\n| $3$      | $t \\leq 10^{18}$            | $60$   |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2018/2019 R1] 小机器人 Robby the little robot", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/4922)。", "description": "**题目译自 [XXVI Olimpiada Informatyczna – I etap](https://sio2.mimuw.edu.pl/c/oi26-1/dashboard/) [Robocik](https://sio2.mimuw.edu.pl/c/oi26-1/p/rob/)**\n\n想象一个带有直角坐标系的平面。在坐标 $(0,0)$ 处，有一个朝北（即 $y$ 坐标增大的方向）的小机器人等着你的指令。你可以通过一个命令序列 $d_{1}, d_{2}, \\ldots, d_{n}$ 来编程控制它。启动后，机器人会按顺序执行动作：第 $i$ $(i \\geq 1)$ 次移动时，它会向前走 $d_{((i-1) \\bmod n)+1}$ 个单位，然后向右转 $90^\\circ$。\n\n机器人有块电池，能支持它运行 $t$ 秒。无论是移动一个单位还是转 $90^\\circ$，都耗时 $1$ 秒。\n\n请你写一个程序，算出在电池耗尽前，机器人会在指定点 $(x, y)$ 上出现多少次。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $t$ $(1 \\leq n \\leq 100000, t \\geq 1)$，分别表示命令序列的长度和电池运行时间。\n\n第二行包含 $n$ 个整数 $d_{1}, \\ldots, d_{n}$ $(1 \\leq d_{i} \\leq 10^{9})$，表示命令序列中的移动距离。\n\n第三行包含两个整数 $x$ 和 $y$ $(-10^{9} \\leq x, y \\leq 10^{9})$，表示我们要查询的点的坐标。", "outputFormat": "输出一个整数，表示机器人到达点 $(x, y)$ 的次数。如果它在时间 $0$ 或 $t$ 时位于该点，也要计入。", "hint": "**样例 1 解释**\n\n机器人会在启动后的第 $6$ 秒和第 $22$ 秒到达点 $(3,2)$。其路径如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/le8akpzi.png)\n\n**附加样例**\n\n1. 跟样例相同，但 $t=21$；  \n2. $n=1$ 的样例；  \n3. 大型螺旋样例，$d_{i}=i, n=31, t=\\frac{10^{18}-1}{3}$。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$      | $t \\leq 10^{6}$             | $10$   |\n| $2$      | $t \\leq 10^{12}, 10^{6} \\leq d_{i}$ | $30$   |\n| $3$      | $t \\leq 10^{18}$            | $60$   |", "locale": "zh-CN"}}}
{"pid": "P12777", "type": "P", "difficulty": 7, "samples": [["2\n5 3 3\n0 1 1 0 3\n1 2 3 4 5\n0 1 1 0 2\n2 4 5\n5 3 2\n0 1 1 2 3\n1 2 3 4 5\n0 1 1 2 2\n2 4 5\n", "9\n8\n"], ["1\n13 13 3\n0 1 2 3 3 4 4 5 5 6 7 8 9\n1 3 5 7 7 10 10 10 10 13 13 13 13\n0 1 1 1 1 2 2 2 2 2 2 2 2\n1 2 3 4 5 6 7 8 9 10 11 12 13\n", "22\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2025", "洛谷原创", "背包 DP", "树形 DP"], "title": "理解 加强版", "background": "> 「浅村同学对于我……」\\\n「**理解得太深了。**」\\\n——绫濑沙季", "description": "沙季正在用悠太推荐的方法做现代文阅读练习。\n\n有 $n$ 个历史事件，编号为 $1$ 至 $n$，其中每个历史事件可能有一个编号比它更小的前置事件，也可能没有。形式化地，对于事件 $i$，用 $p_i$ 表示其前置事件的编号，满足 $p_i<i$，若 $p_i=0$ 则表示它没有前置事件。\n\n沙季有两种方式记起一个历史事件：回想和联想。如果她进行回想，那么她可以花费 $r_u$ 时间，直接记起任意一个历史事件 $u$；如果她进行联想，那么她可以选择任意一个已经记起来的事件 $u$，并花费 $t_v$ 时间记起一个满足 $p_v=u$ 的事件 $v$。\n\n但是她的脑容量有限，因此她最多只能同时记起 $k$ 个事件。她已经记起来的事件可以选择在任意时刻忘记，忘记事件不需要花费时间。**她可以再次记起曾经忘记过的事件。**\n\n现在，她有 $m$ 道阅读题，解决其中的第 $i$ 道题需要她记起事件 $x_i$，她可以在记起事件 $x_i$ 的时候立刻解决第 $i$ 道题目，花费的时间忽略不计。她想要知道她至少需要花费多少时间才能解决所有题目。", "inputFormat": "第一行输入一个整数 $T$ 表示数据组数。\n\n对于每组数据，第一行输入三个整数 $n,m,k$ 表示历史事件数量，阅读题的数量和她最多能够同时记起的事件数量。\n\n第二行输入 $n$ 个整数，表示 $p_1,\\dots,p_n$。\n\n第三行输入 $n$ 个整数，表示 $r_1,\\dots,r_n$。\n\n第四行输入 $n$ 个整数，表示 $t_1,\\dots,t_n$。保证 $p_i=0$ 时有 $t_i=0$。\n\n第五行输入 $m$ 个整数，表示 $x_1,\\dots,x_m$。", "outputFormat": "对于每组数据，输出一行一个整数，表示为了解决所有问题至少需要花费的总时间。", "hint": "对于所有数据，满足 $1\\le T\\le30$，$1\\le n,m\\le5000$，$1\\le k\\le5$，$0\\le p_i<i$，$0\\le r_i,t_i\\le10^9$，$1\\le x_i\\le n$。", "locale": "zh-CN", "translations": {"en": {"title": "Understand (Hard version)", "background": "> \"Asamura-kun, you...\"\\\n\"**--You understand me too well.**\"\\\n--Saki Ayase", "description": "Saki is practicing modern literature reading conprehension using the method recommended by Yuta.\n\nThere are $n$ historical events, numbered from $1$ to $n$, where each event may have a prerequisite event with a smaller number, or it may have none. Formally, for event $i$, let $p_i$ denote the number of its prerequisite event, satisfying $p_i < i$. If $p_i = 0$, it means the event has no prerequisite.\n\nSaki has two ways to recall a historical event: recollection and association. If she recollects, she can spend $r_u$ time to recall event $u$. If she associates, she can choose any event $u$ that she has already recalled and spend $t_v$ time to recall an event $v$ where $p_v = u$.\n\nHowever, her brain capacity is limited, so she can only recall up to $k$ events simultaneously. She can choose to forget any event she has already recalled at any moment, and forgetting an event does not take any time. **She can recall the events she has previously forgotten.**\n\nNow, she has $m$ reading questions, and the $i$-th question requires her to recall event $x_i$. She can solve the $i$-th problem immediately upon recalling event $x_i$, and the time taken is negligible. She wants to know the minimum amount of time she needs to spend to solve all the questions.", "inputFormat": "The first line contains an integer $T$, denoting the number of test cases.\n\nFor each test case, the first line contains three integers, $n,m$ and $k$, representing the number of historical events, the number of reading questions, respectively and the number of events that she can recall at the same time.\n\nThe second line is consisted of $n$ integers representing $p_1,\\dots,p_n$.\n\nThe third line is consisted of $n$ integers representing $r_1,\\dots,r_n$.\n\nThe fourth line is consisted of $n$ integers representing $t_1,\\dots,t_n$. It is guaranteed that when $p_i=0$, $t_i=0$.\n\nThe fifth line is consisted of $m$ integers representing $x_1,\\dots,x_m$.", "outputFormat": "For each test case, output a single integer on a line indicating the minimum amount of time she needs to spend to solve all the questions.", "hint": "For all of the testdata, $1\\le T\\le30$, $1\\le n,m\\le5000$, $1\\le k\\le5$, $0\\le p_i<i$, $0\\le r_i,t_i\\le10^9$, $1\\le x_i\\le n$.", "locale": "en"}, "zh-CN": {"title": "理解 加强版", "background": "> 「浅村同学对于我……」\\\n「**理解得太深了。**」\\\n——绫濑沙季", "description": "沙季正在用悠太推荐的方法做现代文阅读练习。\n\n有 $n$ 个历史事件，编号为 $1$ 至 $n$，其中每个历史事件可能有一个编号比它更小的前置事件，也可能没有。形式化地，对于事件 $i$，用 $p_i$ 表示其前置事件的编号，满足 $p_i<i$，若 $p_i=0$ 则表示它没有前置事件。\n\n沙季有两种方式记起一个历史事件：回想和联想。如果她进行回想，那么她可以花费 $r_u$ 时间，直接记起任意一个历史事件 $u$；如果她进行联想，那么她可以选择任意一个已经记起来的事件 $u$，并花费 $t_v$ 时间记起一个满足 $p_v=u$ 的事件 $v$。\n\n但是她的脑容量有限，因此她最多只能同时记起 $k$ 个事件。她已经记起来的事件可以选择在任意时刻忘记，忘记事件不需要花费时间。**她可以再次记起曾经忘记过的事件。**\n\n现在，她有 $m$ 道阅读题，解决其中的第 $i$ 道题需要她记起事件 $x_i$，她可以在记起事件 $x_i$ 的时候立刻解决第 $i$ 道题目，花费的时间忽略不计。她想要知道她至少需要花费多少时间才能解决所有题目。", "inputFormat": "第一行输入一个整数 $T$ 表示数据组数。\n\n对于每组数据，第一行输入三个整数 $n,m,k$ 表示历史事件数量，阅读题的数量和她最多能够同时记起的事件数量。\n\n第二行输入 $n$ 个整数，表示 $p_1,\\dots,p_n$。\n\n第三行输入 $n$ 个整数，表示 $r_1,\\dots,r_n$。\n\n第四行输入 $n$ 个整数，表示 $t_1,\\dots,t_n$。保证 $p_i=0$ 时有 $t_i=0$。\n\n第五行输入 $m$ 个整数，表示 $x_1,\\dots,x_m$。", "outputFormat": "对于每组数据，输出一行一个整数，表示为了解决所有问题至少需要花费的总时间。", "hint": "对于所有数据，满足 $1\\le T\\le30$，$1\\le n,m\\le5000$，$1\\le k\\le5$，$0\\le p_i<i$，$0\\le r_i,t_i\\le10^9$，$1\\le x_i\\le n$。", "locale": "zh-CN"}}}
{"pid": "P12778", "type": "P", "difficulty": 2, "samples": [["6\n50 100 50 50 100 50", "3"], ["5\n1 2 3 2 1", "3"], ["5\n3 2 1 2 3", "5"], ["10\n1 20 100 1 20 20 100 100 20 20", "5"], ["5\n10 60 100 30 10", "4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2024", "ICPC", "横浜"], "title": "[ICPC 2024 Yokohama R] Ribbon on the Christmas Present", "background": "译自 [ICPC 2024 Yokohama Regional Contest](https://icpc.jp/2024/)。", "description": "你正在准备一条彩带，用于装饰圣诞礼物盒。你计划将这条最初为白色的彩带染色，以制作出不同红色深浅的条纹图案。彩带由若干节组成，每一节都应按计划染色。\n\n你希望用最少的染色步骤来准备这条彩带。彩带上连续的几节可以用同一种红色深浅一步染色。已经染有某种红色深浅的彩带节可以用更深色调的染料进行套染；它会被染成那种更深的色调。然而，不允许用更浅的色调进行套染。由于彩带最初是白色的，所有节都必须至少染色一次。\n\n$$\n\\fcolorbox{black}{CCCCCC}{\\textcolor{black}{\\textsf{\\,50\\,}}}\n\\fcolorbox{black}{111111}{\\textcolor{white}{\\textsf{100}}}\n\\fcolorbox{black}{CCCCCC}{\\textcolor{black}{\\textsf{\\,50\\,}}}\n\\fcolorbox{black}{CCCCCC}{\\textcolor{black}{\\textsf{\\,50\\,}}}\n\\fcolorbox{black}{111111}{\\textcolor{white}{\\textsf{100}}}\n\\fcolorbox{black}{CCCCCC}{\\textcolor{black}{\\textsf{\\,50\\,}}}\n$$\n\n上图展示了样例 $1$ 的图案。彩带有六节，节中的数字表示要染的颜色深浅级别。数字越大表示颜色越深。这可以通过三个染色步骤完成：\n1. 用深浅级别为 $50$ 的红色染料染整条彩带；\n2. 然后用深浅级别为 $100$ 的更深色染料染左起第二节；\n3. 用深浅级别为 $100$ 的染料染第五节。\n\n编写一个程序，计算制作计划条纹图案所需的最少染色步骤数。", "inputFormat": "\n仅一组数据，格式如下所示：\n\n> $n$\\\n> $d_1$ $d_2$ $\\cdot \\cdot \\cdot$ $d_n$\n\n每个测试点以一个整数 $n$ ($1 \\le n \\le 100$) 开始，表示彩带的节数。第二行包含 $n$ 个整数，$d_1,d_2,\\ldots ,d_n$，描述了这 $n$ 节彩带计划的深浅级别。其中，$d_i$ 表示第 $i$ 节彩带计划的深浅级别，其值介于 $1$ 和 $100$ 之间（含两端），数值越大表示颜色越深。", "outputFormat": "输出一行一个整数，表示制作计划条纹图案所需的最少染色步骤数。\n", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 Yokohama R] Ribbon on the Christmas Present", "background": "译自 [ICPC 2024 Yokohama Regional Contest](https://icpc.jp/2024/)。", "description": "你正在准备一条彩带，用于装饰圣诞礼物盒。你计划将这条最初为白色的彩带染色，以制作出不同红色深浅的条纹图案。彩带由若干节组成，每一节都应按计划染色。\n\n你希望用最少的染色步骤来准备这条彩带。彩带上连续的几节可以用同一种红色深浅一步染色。已经染有某种红色深浅的彩带节可以用更深色调的染料进行套染；它会被染成那种更深的色调。然而，不允许用更浅的色调进行套染。由于彩带最初是白色的，所有节都必须至少染色一次。\n\n$$\n\\fcolorbox{black}{CCCCCC}{\\textcolor{black}{\\textsf{\\,50\\,}}}\n\\fcolorbox{black}{111111}{\\textcolor{white}{\\textsf{100}}}\n\\fcolorbox{black}{CCCCCC}{\\textcolor{black}{\\textsf{\\,50\\,}}}\n\\fcolorbox{black}{CCCCCC}{\\textcolor{black}{\\textsf{\\,50\\,}}}\n\\fcolorbox{black}{111111}{\\textcolor{white}{\\textsf{100}}}\n\\fcolorbox{black}{CCCCCC}{\\textcolor{black}{\\textsf{\\,50\\,}}}\n$$\n\n上图展示了样例 $1$ 的图案。彩带有六节，节中的数字表示要染的颜色深浅级别。数字越大表示颜色越深。这可以通过三个染色步骤完成：\n1. 用深浅级别为 $50$ 的红色染料染整条彩带；\n2. 然后用深浅级别为 $100$ 的更深色染料染左起第二节；\n3. 用深浅级别为 $100$ 的染料染第五节。\n\n编写一个程序，计算制作计划条纹图案所需的最少染色步骤数。", "inputFormat": "\n仅一组数据，格式如下所示：\n\n> $n$\\\n> $d_1$ $d_2$ $\\cdot \\cdot \\cdot$ $d_n$\n\n每个测试点以一个整数 $n$ ($1 \\le n \\le 100$) 开始，表示彩带的节数。第二行包含 $n$ 个整数，$d_1,d_2,\\ldots ,d_n$，描述了这 $n$ 节彩带计划的深浅级别。其中，$d_i$ 表示第 $i$ 节彩带计划的深浅级别，其值介于 $1$ 和 $100$ 之间（含两端），数值越大表示颜色越深。", "outputFormat": "输出一行一个整数，表示制作计划条纹图案所需的最少染色步骤数。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12779", "type": "P", "difficulty": 3, "samples": [["10 13", "10"], ["11 15", "12"], ["11 20", "16"], ["1 1000000000000000000", "1"], ["9876543210 9876543210", "9876543210"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2024", "ICPC", "横浜"], "title": "[ICPC 2024 Yokohama R] The Sparsest Number in Between", "background": "译自 [ICPC 2024 Yokohama Regional Contest](https://icpc.jp/2024/)。", "description": "\n给定一对正整数 $a,b$（$a \\le b$）。在 $a$ 和 $b$ 之间（包括 $a$ 和 $b$）的整数中，你的任务是找到最**稀疏**的一个，即其二进制表示中 $\\texttt{1}$ 的数量最少的一个。如果存在两个或更多这样的整数，你应该找到其中最小的一个。\n\n例如，假设 $a = 10$ 且 $b = 13$。 $a$ 和 $b$ 之间（包括 $a$ 和 $b$）的整数是 $10$、$11$、$12$ 和 $13$，它们的二进制表示分别为 $\\texttt{1010},\\texttt{1011},\\texttt{1100}$ 和 $\\texttt{1101}$。因此，在这种情况下，答案是 $10$，因为 $10$ 和 $12$ 的二进制表示中 $1$ 的数量最少，并且 $10$ 小于 $12$。\n", "inputFormat": "\n仅一组数据，格式如下所示：\n\n\n> $a$ $b$\n\n其中，$a,b$ ($a \\le b$) 是介于 $1$ 和 $10^{18}$ 之间（包括 $1$ 和 $10^{18}$）的整数。", "outputFormat": "\n输出一行一个整数，表示 $a$ 和 $b$ 之间（包括 $a$ 和 $b$）最稀疏整数中最小的一个。\n", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 Yokohama R] The Sparsest Number in Between", "background": "译自 [ICPC 2024 Yokohama Regional Contest](https://icpc.jp/2024/)。", "description": "\n给定一对正整数 $a,b$（$a \\le b$）。在 $a$ 和 $b$ 之间（包括 $a$ 和 $b$）的整数中，你的任务是找到最**稀疏**的一个，即其二进制表示中 $\\texttt{1}$ 的数量最少的一个。如果存在两个或更多这样的整数，你应该找到其中最小的一个。\n\n例如，假设 $a = 10$ 且 $b = 13$。 $a$ 和 $b$ 之间（包括 $a$ 和 $b$）的整数是 $10$、$11$、$12$ 和 $13$，它们的二进制表示分别为 $\\texttt{1010},\\texttt{1011},\\texttt{1100}$ 和 $\\texttt{1101}$。因此，在这种情况下，答案是 $10$，因为 $10$ 和 $12$ 的二进制表示中 $1$ 的数量最少，并且 $10$ 小于 $12$。\n", "inputFormat": "\n仅一组数据，格式如下所示：\n\n\n> $a$ $b$\n\n其中，$a,b$ ($a \\le b$) 是介于 $1$ 和 $10^{18}$ 之间（包括 $1$ 和 $10^{18}$）的整数。", "outputFormat": "\n输出一行一个整数，表示 $a$ 和 $b$ 之间（包括 $a$ 和 $b$）最稀疏整数中最小的一个。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12780", "type": "P", "difficulty": 3, "samples": [["3 3\n1 2 3\n1 2 2\n2 3 3\n1 3 4", "16"], ["5 7\n2 6 7 7 10\n1 5 8\n1 4 6\n3 4 9\n2 3 6\n2 4 7\n1 3 4\n4 5 4", "210"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2024", "ICPC", "横浜"], "title": "[ICPC 2024 Yokohama R] Omnes Viae Yokohamam Ducunt?", "background": "译自 [ICPC 2024 Yokohama Regional Contest](https://icpc.jp/2024/)。", "description": " 「Omnes viae Romam ducunt」是古老的拉丁谚语，意为「条条大路通罗马」。人们仍然期望一个国家的所有地区都能通往首都。\n\n神奈川王国拥有许多城市，包括首都横滨。王国交通部目前正计划修建一个高速公路网络，连接所有这些城市。\n\n有许多候选的高速公路路段，每个路段都直接连接两个城市。高速公路网络是从候选路段中选出的一组高速公路路段。高速公路网络需要满足以下要求:\n\n- 网络中的所有城市都应通过高速公路路段直接或间接连接；\n- 为了节省预算，应选择最少数量的路段。换句话说，高速公路网络不应是冗余的；连接任意一对城市的路径都应该是唯一的。\n\n在有限的预算下，高速公路网络应能抵御自然灾害。重点放在与首都横滨之间的可达性上。由于路网没有预留冗余，当一个路段因自然灾害而无法使用时，一些城市将无法从横滨到达。\n\n我们希望最小化**总风险严重度**，其定义如下。\n\n王国中的城市拥有不同的人口和经济规模，基于此，这些城市被赋予了特定的**重要度**。给定一个高速公路网络，网络中单个路段因自然灾害而遭受的**损失**定义为，这个路段无法通过时，从横滨无法到达的城市的重要性值之和。\n\n我们评估了所有候选路段的**脆弱度**。一个路段的**风险严重度**，定义为**损失**与**脆弱度**之积。网络的**总风险严重度**，估算为网络中所有路段的**风险严重度**之和。\n\n你的任务是通过适当设计高速公路网络来确定最小的总风险严重程度。", "inputFormat": "\n仅一组数据，格式如下所示：\n\n> $n$ $m$\\\n> $p_1$ $\\dots$ $p_n$\\\n> $u_1$ $v_1$ $q_1$\\\n> $\\dots$\\\n> $u_m$ $v_m$ $q_m$\n\n前两个整数 $n,m$（$2 \\le n \\le 10^5$, $1 \\le m \\le 3 \\times 10^5$）分别描述了城市数量和高速公路路段候选数量。城市编号从 $1$ 到 $n$，其中横滨编号为 $1$。第二行包含 $n$ 个整数 $p_1, \\dots, p_n$，其中每个 $p_i$（$1 \\le p_i \\le 1000$）代表分配给编号为 $i$ 的城市的重要度。\n\n接下来的 $m$ 行描述了候选高速公路路段。它们的第 $j$ 行包含三个整数 $u_j$, $v_j$ 和 $q_j$ ($1 \\le u_j < v_j \\le n$, $1 \\le q_j \\le 10^6$)，表示连接编号为 $u_j$ 和 $v_j$ 的城市的候选路段脆弱度为 $q_j$。\n\n每对 $(u_j,v_j)$ 在输入中最多出现一次。保证可以使用其中一些路段设计一个或多个连接所有城市的高速公路网络。", "outputFormat": "输出一行一个整数，即最小的可能总风险严重程度。\n", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 Yokohama R] Omnes Viae Yokohamam Ducunt?", "background": "译自 [ICPC 2024 Yokohama Regional Contest](https://icpc.jp/2024/)。", "description": " 「Omnes viae Romam ducunt」是古老的拉丁谚语，意为「条条大路通罗马」。人们仍然期望一个国家的所有地区都能通往首都。\n\n神奈川王国拥有许多城市，包括首都横滨。王国交通部目前正计划修建一个高速公路网络，连接所有这些城市。\n\n有许多候选的高速公路路段，每个路段都直接连接两个城市。高速公路网络是从候选路段中选出的一组高速公路路段。高速公路网络需要满足以下要求:\n\n- 网络中的所有城市都应通过高速公路路段直接或间接连接；\n- 为了节省预算，应选择最少数量的路段。换句话说，高速公路网络不应是冗余的；连接任意一对城市的路径都应该是唯一的。\n\n在有限的预算下，高速公路网络应能抵御自然灾害。重点放在与首都横滨之间的可达性上。由于路网没有预留冗余，当一个路段因自然灾害而无法使用时，一些城市将无法从横滨到达。\n\n我们希望最小化**总风险严重度**，其定义如下。\n\n王国中的城市拥有不同的人口和经济规模，基于此，这些城市被赋予了特定的**重要度**。给定一个高速公路网络，网络中单个路段因自然灾害而遭受的**损失**定义为，这个路段无法通过时，从横滨无法到达的城市的重要性值之和。\n\n我们评估了所有候选路段的**脆弱度**。一个路段的**风险严重度**，定义为**损失**与**脆弱度**之积。网络的**总风险严重度**，估算为网络中所有路段的**风险严重度**之和。\n\n你的任务是通过适当设计高速公路网络来确定最小的总风险严重程度。", "inputFormat": "\n仅一组数据，格式如下所示：\n\n> $n$ $m$\\\n> $p_1$ $\\dots$ $p_n$\\\n> $u_1$ $v_1$ $q_1$\\\n> $\\dots$\\\n> $u_m$ $v_m$ $q_m$\n\n前两个整数 $n,m$（$2 \\le n \\le 10^5$, $1 \\le m \\le 3 \\times 10^5$）分别描述了城市数量和高速公路路段候选数量。城市编号从 $1$ 到 $n$，其中横滨编号为 $1$。第二行包含 $n$ 个整数 $p_1, \\dots, p_n$，其中每个 $p_i$（$1 \\le p_i \\le 1000$）代表分配给编号为 $i$ 的城市的重要度。\n\n接下来的 $m$ 行描述了候选高速公路路段。它们的第 $j$ 行包含三个整数 $u_j$, $v_j$ 和 $q_j$ ($1 \\le u_j < v_j \\le n$, $1 \\le q_j \\le 10^6$)，表示连接编号为 $u_j$ 和 $v_j$ 的城市的候选路段脆弱度为 $q_j$。\n\n每对 $(u_j,v_j)$ 在输入中最多出现一次。保证可以使用其中一些路段设计一个或多个连接所有城市的高速公路网络。", "outputFormat": "输出一行一个整数，即最小的可能总风险严重程度。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12781", "type": "P", "difficulty": 5, "samples": [["((1(11))1)\n((11)(11))", "1"], ["(1(11))\n(1(11))", "2"], ["(((11)(11))((11)1))\n((1(11))(1(1(11))))", "3"], ["((11)(((1(11))1)((11)1)))\n(1(((11)((11)(11)))(11)))", "4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2024", "ICPC", "横浜"], "title": "[ICPC 2024 Yokohama R] Tree Generators", "background": "译自 [ICPC 2024 Yokohama Regional Contest](https://icpc.jp/2024/)。", "description": "\n国际解析竞赛的一道题引起了你的注意。  \n\n给定两个表达式作为输入，每个表达式表示生成一棵树的过程。  生成过程是随机化的，这意味着每次执行该过程可能生成不同的树。你需要计算两个表达式各自可能生成的树的交集的大小。  \n\n表达式的语法如下：\n\n$$\n\nE ::= \\texttt{‘1’} \\operatorname{|} \\texttt{‘(’}E \\, E \\texttt{‘)’}\n$$\n\n根据以下过程，从一个表达式生成一棵树。  \n- 表达式 $\\texttt{1}$ 生成一棵仅包含一个标号为 $1$ 的节点的树。  \n- 对于两个表达式 $E_1$ 和 $E_2$，表达式 $(E_1E_2)$ 按如下方式生成一棵树：  \n    1. 从 $E_1$ 生成一棵拥有 $n_1$ 个节点的树 $T_1$，并从 $E_2$ 生成一棵拥有 $n_2$ 个节点的树 $T_2$。  \n    2. 将 $T_2$ 中所有节点的标号都加上 $n_1$。  \n    3. 随机地各从 $T_1$ 和 $T_2$ 中选取一个节点，连接它们形成一条边，从而构造出一棵标号为 $1$ 到 $(n_1 + n_2)$ 的树，该树即为 $(E_1E_2)$ 生成的树。  \n\n例如，表达式 $\\texttt{(11)}$ 只能生成下图中最左边的树，而 $\\texttt{(1(11))}$ 可以生成其余两棵树。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vfvtfsqc.png)\n\n相同的树可能由不同的表达式生成。中间的那棵树也可以由 $\\texttt{((11)1)}$ 生成。  \n\n对于给定的两个长度相同的表达式，计算它们都能生成的树的数量。注意，它们生成的树节点数总是相同的。如果存在两个数 $i$ 和 $j$，使得在一棵树中标号 $i$ 和 $j$ 的节点之间有一条边，而在另一棵树中没有，则这两棵树被视为不同。  \n", "inputFormat": "\n输入共两行，每行一个表达式串。两个字符串长度相同，范围在 $1$ 到 $7\\times10^5$（含两端）之间，且符合上述语法。  \n", "outputFormat": "\n输出两个表达式都能生成的树的数量，对 $998\\,244\\,353$ 取模。  ", "hint": "\n对于样例 $1$，可生成的树如下图所示。上排六棵对应第一个表达式，下排四棵对应第二个表达式。仅每行最左边的那棵树可由两者共同生成。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kr00s3nn.png)\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 Yokohama R] Tree Generators", "background": "译自 [ICPC 2024 Yokohama Regional Contest](https://icpc.jp/2024/)。", "description": "\n国际解析竞赛的一道题引起了你的注意。  \n\n给定两个表达式作为输入，每个表达式表示生成一棵树的过程。  生成过程是随机化的，这意味着每次执行该过程可能生成不同的树。你需要计算两个表达式各自可能生成的树的交集的大小。  \n\n表达式的语法如下：\n\n$$\n\nE ::= \\texttt{‘1’} \\operatorname{|} \\texttt{‘(’}E \\, E \\texttt{‘)’}\n$$\n\n根据以下过程，从一个表达式生成一棵树。  \n- 表达式 $\\texttt{1}$ 生成一棵仅包含一个标号为 $1$ 的节点的树。  \n- 对于两个表达式 $E_1$ 和 $E_2$，表达式 $(E_1E_2)$ 按如下方式生成一棵树：  \n    1. 从 $E_1$ 生成一棵拥有 $n_1$ 个节点的树 $T_1$，并从 $E_2$ 生成一棵拥有 $n_2$ 个节点的树 $T_2$。  \n    2. 将 $T_2$ 中所有节点的标号都加上 $n_1$。  \n    3. 随机地各从 $T_1$ 和 $T_2$ 中选取一个节点，连接它们形成一条边，从而构造出一棵标号为 $1$ 到 $(n_1 + n_2)$ 的树，该树即为 $(E_1E_2)$ 生成的树。  \n\n例如，表达式 $\\texttt{(11)}$ 只能生成下图中最左边的树，而 $\\texttt{(1(11))}$ 可以生成其余两棵树。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vfvtfsqc.png)\n\n相同的树可能由不同的表达式生成。中间的那棵树也可以由 $\\texttt{((11)1)}$ 生成。  \n\n对于给定的两个长度相同的表达式，计算它们都能生成的树的数量。注意，它们生成的树节点数总是相同的。如果存在两个数 $i$ 和 $j$，使得在一棵树中标号 $i$ 和 $j$ 的节点之间有一条边，而在另一棵树中没有，则这两棵树被视为不同。  \n", "inputFormat": "\n输入共两行，每行一个表达式串。两个字符串长度相同，范围在 $1$ 到 $7\\times10^5$（含两端）之间，且符合上述语法。  \n", "outputFormat": "\n输出两个表达式都能生成的树的数量，对 $998\\,244\\,353$ 取模。  ", "hint": "\n对于样例 $1$，可生成的树如下图所示。上排六棵对应第一个表达式，下排四棵对应第二个表达式。仅每行最左边的那棵树可由两者共同生成。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kr00s3nn.png)\n\n", "locale": "zh-CN"}}}
{"pid": "P12782", "type": "P", "difficulty": 3, "samples": [["6 8\n3.......\n#....P..\n#....#.2\n#.###*#+\n##-....#\n..1...4#", "12"], ["4 3\n.4.\n./P\n9*.\n.#7", "15"], ["5 11\n8...8.....8\n#.###...###\n#.#...P.#..\n#**##-*+/##\n.4...3.0..1", "2024"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["模拟", "2024", "ICPC", "横浜"], "title": "[ICPC 2024 Yokohama R] E-Circuit Is Now on Sale!", "background": "译自 [ICPC 2024 Yokohama Regional Contest](https://icpc.jp/2024/)。", "description": "您是否在为您的孩子寻找数学教育工具？然后，不妨试试这款神奇的产品 E-circuit？这是学习二维几何、逻辑和算术的最佳玩具！\n\nE-circuit 由一个带有多个方块的网格空间组成，这些方块称为单元。每个单元都可以完美地契合在网格的一个方格中。它们具有若干输入和/或输出端子，用于传递整数值。当若干单元在网格中被恰当地放置时，它们会构成一棵表示数学公式的树。单元具有不同的功能，每种功能由下列单个字符表示：\n\n- 数字（$\\texttt{0}$ 到 $\\texttt{9}$）：这些单元有一个输出端子。它们将该数字所表示的整数值发送到它的输出端子。  \n- 连接器（$\\texttt{\\#}$）：这些单元有一个输入端子和一个输出端子。它们接收来自输入端子的整数值，并不做任何改动地将该值发送到输出端子。  \n- 运算符（$\\texttt{+}$，$\\texttt{-}$，$\\texttt{*}$，$\\texttt{/}$）：这些单元有两个输入端子和一个输出端子，对从输入端接收的值进行以下计算，并将结果发送到输出端子。  \n  - $\\texttt{+}$ 运算符计算两个输入值之和。  \n  - $\\texttt{-}$ 运算符计算两个输入值之差，用较大值减去较小值。  \n  - $\\texttt{*}$ 运算符计算两个输入值之积。  \n  - $\\texttt{/}$ 运算符计算两个输入值之商，用较大值除以较小值，若有小数则截断。  \n- 打印机（$\\texttt{P}$）：打印机有一个输入端子，并显示其输入的值。网格中恰好应有一个打印机单元。\n\n如果两个单元所在的格子共用一条边，则称它们相邻。当两个单元放置在相邻的格子中时，它们会通过一个单元的输出端子和另一个单元的输入端子相连。\n\n现在给定一个恰当放置的单元配置，其中所有单元构成一棵表示数学公式的树。此类放置的形式化描述将在「输入」部分给出。\n\n你的任务是计算该配置下打印机所显示的值。", "inputFormat": "仅一组数据，格式如下所示：\n\n\n> $n$ $m$\\\n> $x_{1,1}$ $\\cdots$ $x_{1,m}$\\\n> $\\vdots$\\\n> $x_{n,1}$  $\\cdots$ $x_{n,m}$\n\n第一行的两个整数 $n$ 和 $m$（$1 \\le n \\le 50$，$1 \\le m \\le 50$）表示网格为 $n \\times m$ 的矩阵。接下来的 $n$ 行描述单元的放置情况。字符 $x_{i,j}$ （$1 \\le i \\le n$, $1 \\le j \\le m$）指定位于从上往下第 $i$ 行、从左往右第 $j$ 列的格子中的单元。每个字符要么表示题目中描述的单元功能，要么是字符 $\\texttt{.}$（点），表示该格子为空。\n\n保证单元放置恰当，即：\n\n- 每个单元的相邻单元数等于其输入端子和输出端子总数；  \n- 所有单元的输入端子总数等于输出端子总数；  \n- 所有单元都属于打印机树：当且仅当一个单元是打印机或与另一个属于打印机树的单元相邻时，该单元才属于打印机树。\n\n还保证 $\\texttt{/}$ 运算符的输入值不为零，并且没有单元的输出值超过 $10^{18}$。", "outputFormat": "输出一行，即打印机显示的值。", "hint": null, "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 Yokohama R] E-Circuit Is Now on Sale!", "background": "译自 [ICPC 2024 Yokohama Regional Contest](https://icpc.jp/2024/)。", "description": "您是否在为您的孩子寻找数学教育工具？然后，不妨试试这款神奇的产品 E-circuit？这是学习二维几何、逻辑和算术的最佳玩具！\n\nE-circuit 由一个带有多个方块的网格空间组成，这些方块称为单元。每个单元都可以完美地契合在网格的一个方格中。它们具有若干输入和/或输出端子，用于传递整数值。当若干单元在网格中被恰当地放置时，它们会构成一棵表示数学公式的树。单元具有不同的功能，每种功能由下列单个字符表示：\n\n- 数字（$\\texttt{0}$ 到 $\\texttt{9}$）：这些单元有一个输出端子。它们将该数字所表示的整数值发送到它的输出端子。  \n- 连接器（$\\texttt{\\#}$）：这些单元有一个输入端子和一个输出端子。它们接收来自输入端子的整数值，并不做任何改动地将该值发送到输出端子。  \n- 运算符（$\\texttt{+}$，$\\texttt{-}$，$\\texttt{*}$，$\\texttt{/}$）：这些单元有两个输入端子和一个输出端子，对从输入端接收的值进行以下计算，并将结果发送到输出端子。  \n  - $\\texttt{+}$ 运算符计算两个输入值之和。  \n  - $\\texttt{-}$ 运算符计算两个输入值之差，用较大值减去较小值。  \n  - $\\texttt{*}$ 运算符计算两个输入值之积。  \n  - $\\texttt{/}$ 运算符计算两个输入值之商，用较大值除以较小值，若有小数则截断。  \n- 打印机（$\\texttt{P}$）：打印机有一个输入端子，并显示其输入的值。网格中恰好应有一个打印机单元。\n\n如果两个单元所在的格子共用一条边，则称它们相邻。当两个单元放置在相邻的格子中时，它们会通过一个单元的输出端子和另一个单元的输入端子相连。\n\n现在给定一个恰当放置的单元配置，其中所有单元构成一棵表示数学公式的树。此类放置的形式化描述将在「输入」部分给出。\n\n你的任务是计算该配置下打印机所显示的值。", "inputFormat": "仅一组数据，格式如下所示：\n\n\n> $n$ $m$\\\n> $x_{1,1}$ $\\cdots$ $x_{1,m}$\\\n> $\\vdots$\\\n> $x_{n,1}$  $\\cdots$ $x_{n,m}$\n\n第一行的两个整数 $n$ 和 $m$（$1 \\le n \\le 50$，$1 \\le m \\le 50$）表示网格为 $n \\times m$ 的矩阵。接下来的 $n$ 行描述单元的放置情况。字符 $x_{i,j}$ （$1 \\le i \\le n$, $1 \\le j \\le m$）指定位于从上往下第 $i$ 行、从左往右第 $j$ 列的格子中的单元。每个字符要么表示题目中描述的单元功能，要么是字符 $\\texttt{.}$（点），表示该格子为空。\n\n保证单元放置恰当，即：\n\n- 每个单元的相邻单元数等于其输入端子和输出端子总数；  \n- 所有单元的输入端子总数等于输出端子总数；  \n- 所有单元都属于打印机树：当且仅当一个单元是打印机或与另一个属于打印机树的单元相邻时，该单元才属于打印机树。\n\n还保证 $\\texttt{/}$ 运算符的输入值不为零，并且没有单元的输出值超过 $10^{18}$。", "outputFormat": "输出一行，即打印机显示的值。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P12783", "type": "P", "difficulty": 6, "samples": [["1 1 2", "2.850438562747845"], ["10 10 10", "22.360679774997898"], ["100 2 3", "101.0503923792481"], ["2 3 5 ", "7.093659140387279"], ["84 41 51", "124.582755157578"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2024", "Special Judge", "ICPC", "横浜"], "title": "[ICPC 2024 Yokohama R] The Farthest Point", "background": "译自 [ICPC 2024 Yokohama Regional Contest](https://icpc.jp/2024/)。", "description": "\n一只蚂蚁位于一个长方体的顶点之一，记作**起始顶点**。长方体（rectangular cuboid）是一个所有面均为矩形的六面体。对于这只蚂蚁而言，长方体的表面就构成了它的整个「世界」。\n\n\n现在我们想知道：在长方体表面上，哪个点对于蚂蚁来说距离起始顶点最远。你可能会认为，**对角顶点**（即起始顶点的空间对角线的另一端顶点）就是最远的点。然而，对角顶点并不一定是最远的。\n\n\n例如，对于一个尺寸为 $1 \\times 1 \\times 2$ 的长方体，其任一顶点到对角顶点的表面距离为 $\\sqrt{8}$。而实际上，最远点到起始顶点的距离为 $\\sqrt{\\tfrac{65}{8}}$（见下图）。\n\n> ![](https://cdn.luogu.com.cn/upload/image_hosting/6psav7dk.png)\n> （$1\\times 1\\times 2$ 的长方体，和长方体的展开图）\n  \n现在给出长方体的边长尺寸。请编写一个程序，计算起始顶点到最远点的距离。\n", "inputFormat": "\n仅一组数据，格式如下所示：\n\n> $a$ $b$ $c$\n\n正整数 $a,b,c$ 表示长方体尺寸为 $a\\times b\\times c$。保证 $1\\le a,b,c\\le 100$。\n", "outputFormat": "输出一行一个实数，表示起始顶点到最远点的距离。相对误差不应大于 $10^{-9}$。\n", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 Yokohama R] The Farthest Point", "background": "译自 [ICPC 2024 Yokohama Regional Contest](https://icpc.jp/2024/)。", "description": "\n一只蚂蚁位于一个长方体的顶点之一，记作**起始顶点**。长方体（rectangular cuboid）是一个所有面均为矩形的六面体。对于这只蚂蚁而言，长方体的表面就构成了它的整个「世界」。\n\n\n现在我们想知道：在长方体表面上，哪个点对于蚂蚁来说距离起始顶点最远。你可能会认为，**对角顶点**（即起始顶点的空间对角线的另一端顶点）就是最远的点。然而，对角顶点并不一定是最远的。\n\n\n例如，对于一个尺寸为 $1 \\times 1 \\times 2$ 的长方体，其任一顶点到对角顶点的表面距离为 $\\sqrt{8}$。而实际上，最远点到起始顶点的距离为 $\\sqrt{\\tfrac{65}{8}}$（见下图）。\n\n> ![](https://cdn.luogu.com.cn/upload/image_hosting/6psav7dk.png)\n> （$1\\times 1\\times 2$ 的长方体，和长方体的展开图）\n  \n现在给出长方体的边长尺寸。请编写一个程序，计算起始顶点到最远点的距离。\n", "inputFormat": "\n仅一组数据，格式如下所示：\n\n> $a$ $b$ $c$\n\n正整数 $a,b,c$ 表示长方体尺寸为 $a\\times b\\times c$。保证 $1\\le a,b,c\\le 100$。\n", "outputFormat": "输出一行一个实数，表示起始顶点到最远点的距离。相对误差不应大于 $10^{-9}$。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12784", "type": "P", "difficulty": 6, "samples": [["2\n\n^\n\n.\n\n<\n\n^\n\nG", "\n^\n\n<\n\nv\n\n<\n\n^"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2024", "交互题", "Special Judge", "ICPC", "横浜"], "title": "[ICPC 2024 Yokohama R] Beyond the Former Explorer", "background": "译自 [ICPC 2024 Yokohama Regional Contest](https://icpc.jp/2024/)。", "description": "**这是一道交互题。**\n\n你正站在一片区域的正中心，该区域被划分为南北走向和东西走向的网格单元。一份巨大的宝藏隐藏在其中一个单元内。  \n\nJohn Belzoni——著名的宝藏猎人 Giovanni Battista Belzoni 的后裔——实际上已发现了这份宝藏。不幸的是，他在成功挖出宝藏前因中暑去世；他似乎花了过长的时间在这片区域徘徊。  \n\nJohn 的探索从你当前站立的区域中心单元出发。他通向宝藏的所有足迹都留在了这片区域，但只有抵达某个单元才能识别该单元上的足迹。某一单元上的足迹指示了他下一步前往四个相邻网格单元中的哪一个。 已知 John 不会重复访问同一网格单元。你在中心单元看到一个足迹，表明 **John 的第一步是向北**。\n\n区域中存在恰好一个宝藏单元，只有站在该单元时你才能识别它。  \n\n下图展示了区域的一种可能情形。John 的足迹在单元中以箭头标识。宝藏单元标记为 $\\texttt{G}$。阴影单元是你的初始位置。  \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bakj14ug.png)\n\n你的任务是在有限**步**内找到宝藏。每一步中，你需决定朝北、西、南、东四个方向之一移动，并进入该方向的相邻单元。当你移动到该单元时，可能发现宝藏、John 的足迹，或者空无一物。你无需追随 John 的足迹。与 John 的路线不同，你可以重复访问同一单元。无论你如何探索，John 的足迹始终保持不变。  \n\n\n### 实现细节\n\n交互开始时，你需从标准输入读取一个整数 $n$（$1 \\leq n \\leq 2000$），后接换行符。整数 $n$ 表示区域被划分为 $(2n + 1) \\times (2n + 1)$ 的网格单元。你的初始位置从西向东第 $n+1$ 列、从北向南第 $n+1$ 行的单元。读入整数 $n$ 后，你即可开始探索。  \n\n每步，你向标准输出发送表示移动方向的单个字符：  \n- `^`（插入符）表示向北；\n- `<`（小于号）表示向西；\n- `v`（小写字母 $\\texttt{v}$）表示向南；\n- `>`（大于号）表示向东。\n\n字符后需附加换行符。  \n\n作为回答，你将收到一个表示抵达单元内容的字符，后接换行符：  \n\n- `G`：该单元有宝藏；\n- `^`, `<`, `v`, `>`：John 的足迹分别指示北、西、南、东；\n- `.`（点号）：既无宝藏也无足迹。\n\n当你发现宝藏（即收到 `G`）时，交互立即终止，你的程序必须退出。 **你需在 $\\bf{30000}$ 步内抵达宝藏单元**。尽管追随 John 的足迹必能找到宝藏，但步数可能超过 $30000$。 \n\n以下情况将被判为 $\\text{Wrong Answer}$：  \n\n- 程序输出格式无效；\n- 指定了移出网格的方向；\n- 找到宝藏后仍有额外输出；\n- 未在 $30000$ 步内抵达宝藏单元。\n\n区域的布局（宝藏位置与 John 的足迹）在交互前已固定，在交互过程中不会改变。  \n\n**在每次移动后，你都需要换行并刷新缓冲区**。例如：\n\n- $\\texttt{C++}$ 中的 `cout.flush()`。\n", "inputFormat": "见「实现细节」。", "outputFormat": "见「实现细节」。", "hint": "样例如「题目描述」中的图所示。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 Yokohama R] Beyond the Former Explorer", "background": "译自 [ICPC 2024 Yokohama Regional Contest](https://icpc.jp/2024/)。", "description": "**这是一道交互题。**\n\n你正站在一片区域的正中心，该区域被划分为南北走向和东西走向的网格单元。一份巨大的宝藏隐藏在其中一个单元内。  \n\nJohn Belzoni——著名的宝藏猎人 Giovanni Battista Belzoni 的后裔——实际上已发现了这份宝藏。不幸的是，他在成功挖出宝藏前因中暑去世；他似乎花了过长的时间在这片区域徘徊。  \n\nJohn 的探索从你当前站立的区域中心单元出发。他通向宝藏的所有足迹都留在了这片区域，但只有抵达某个单元才能识别该单元上的足迹。某一单元上的足迹指示了他下一步前往四个相邻网格单元中的哪一个。 已知 John 不会重复访问同一网格单元。你在中心单元看到一个足迹，表明 **John 的第一步是向北**。\n\n区域中存在恰好一个宝藏单元，只有站在该单元时你才能识别它。  \n\n下图展示了区域的一种可能情形。John 的足迹在单元中以箭头标识。宝藏单元标记为 $\\texttt{G}$。阴影单元是你的初始位置。  \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bakj14ug.png)\n\n你的任务是在有限**步**内找到宝藏。每一步中，你需决定朝北、西、南、东四个方向之一移动，并进入该方向的相邻单元。当你移动到该单元时，可能发现宝藏、John 的足迹，或者空无一物。你无需追随 John 的足迹。与 John 的路线不同，你可以重复访问同一单元。无论你如何探索，John 的足迹始终保持不变。  \n\n\n### 实现细节\n\n交互开始时，你需从标准输入读取一个整数 $n$（$1 \\leq n \\leq 2000$），后接换行符。整数 $n$ 表示区域被划分为 $(2n + 1) \\times (2n + 1)$ 的网格单元。你的初始位置从西向东第 $n+1$ 列、从北向南第 $n+1$ 行的单元。读入整数 $n$ 后，你即可开始探索。  \n\n每步，你向标准输出发送表示移动方向的单个字符：  \n- `^`（插入符）表示向北；\n- `<`（小于号）表示向西；\n- `v`（小写字母 $\\texttt{v}$）表示向南；\n- `>`（大于号）表示向东。\n\n字符后需附加换行符。  \n\n作为回答，你将收到一个表示抵达单元内容的字符，后接换行符：  \n\n- `G`：该单元有宝藏；\n- `^`, `<`, `v`, `>`：John 的足迹分别指示北、西、南、东；\n- `.`（点号）：既无宝藏也无足迹。\n\n当你发现宝藏（即收到 `G`）时，交互立即终止，你的程序必须退出。 **你需在 $\\bf{30000}$ 步内抵达宝藏单元**。尽管追随 John 的足迹必能找到宝藏，但步数可能超过 $30000$。 \n\n以下情况将被判为 $\\text{Wrong Answer}$：  \n\n- 程序输出格式无效；\n- 指定了移出网格的方向；\n- 找到宝藏后仍有额外输出；\n- 未在 $30000$ 步内抵达宝藏单元。\n\n区域的布局（宝藏位置与 John 的足迹）在交互前已固定，在交互过程中不会改变。  \n\n**在每次移动后，你都需要换行并刷新缓冲区**。例如：\n\n- $\\texttt{C++}$ 中的 `cout.flush()`。\n", "inputFormat": "见「实现细节」。", "outputFormat": "见「实现细节」。", "hint": "样例如「题目描述」中的图所示。", "locale": "zh-CN"}}}
{"pid": "P12785", "type": "P", "difficulty": 7, "samples": [["3 3\n#######\n#.....#\n#.#.###\n#.#...#\n#.#.#.#\n#.....#\n#######", "Yes\n#######\n#.....#\n#.#####\n#.#...#\n#.###.#\n#.....#\n#######"], ["3 3\n#######\n#.....#\n###.###\n###...#\n###.#.#\n#.....#\n#######", "Yes\n#######\n#.....#\n###.###\n###...#\n#####.#\n#.....#\n#######"], ["3 3\n#######\n#.....#\n#.###.#\n#.###.#\n#.###.#\n#.....#\n#######", "No"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2024", "Special Judge", "ICPC", "横浜"], "title": "[ICPC 2024 Yokohama R] Remodeling the Dungeon 2", "background": "译自 [ICPC 2024 Yokohama Regional Contest](https://icpc.jp/2024/)。", "description": "\n\n_Icpca_ 王国的女王平静地居住在一座城堡中。一天，她决定重造城堡的地牢。  \n\n地牢是一个由方形单元格组成的矩形网格。部分单元格是可进入的房间，而其他则是不可进入的管道空间。所有相邻单元格之间都被一堵墙隔开。某些相邻房间之间的墙上安装了用于通行的门。地牢中任意一对房间都可以通过这些门连通。  \n\n女王希望重造地牢，使得任意一对房间之间仅存在唯一路径。此外，任意两个都只有一扇门的房间应通过一条经过偶数扇门的路径相连。 由于成本限制，重造时只能封锁部分（可能为零扇）门。  \n\n你的任务是找到一种满足女王要求的地牢重造方案。  \n", "inputFormat": "\n仅一组数据，格式如下所示：\n \n>$h$ $w$\n> $c_{1,1}$ $c_{1,2}$ $\\cdots$ $c_{1,2w+1}$\\\n> $c_{2,1}$ $c_{2,2}$ $\\cdots$ $c_{2,2w+1}$\\\n> $\\vdots$\\\n> $c_{2h+1,1}$ $c_{2h+1,2}$ $\\cdots$ $c_{2h+1,2w+1}$\n>\n\n两个整数 $h$ 和 $w$ 表示地牢大小为 $h \\times w$（$1 \\leq h,w \\leq 400$）。  \n每个字符 $c_{i,j}$（$1 \\leq i \\leq 2h+1$, $1 \\leq j \\leq 2w+1$）为 `.` 或 `#`，其含义如下：  \n\n- 当 $i$ 和 $j$ 均为偶数时，$c_{i,j}$ 表示位于地牢第 $(i/2)$ 行（北向南）、第 $(j/2)$ 列（西向东）的单元格，记作单元格 $(i/2, j/2)$。若为 `.` 则是房间，若为 `#` 则是管道空间。  \n- 当 $i$ 为奇数且 $j$ 为偶数时，表示一堵墙。若 $i=1$ 或 $i=2h+1$，则为地牢外墙（始终为 `#`）。否则 $c_{i,j}$ 表示单元格 $((i−1)/2, j/2)$ 和 $((i+1)/2, j/2)$ 之间的墙。若为 `.` 则该墙有门，若为 `#` 则无门（门仅存在于两个房间之间的墙上）。  \n- 当 $i$ 为偶数且 $j$ 为奇数时，同样表示一堵墙。若 $j=1$ 或 $j=2w+1$，则为地牢外墙（始终为 `#`）。否则 $c_{i,j}$ 表示单元格 $(i/2, (j−1)/2)$ 和 $(i/2, (j+1)/2)$ 之间的墙。若为 `.` 则该墙有门，若为 `#` 则无门（门仅存在于两个房间之间的墙上）。  \n- 当 $i$ 和 $j$ 均为奇数时，$c_{i,j}$ 始终为 `#`，对应墙体的交叉点。  \n\n数据保证地牢中至少有一个房间，且任意一对房间存在连通路径。  ", "outputFormat": "\n若无法按要求重造地牢，输出 $\\texttt{No}$。否则第一行输出 $\\texttt{Yes}$，接着按输入格式输出重造后的地牢配置（若有多种可能配置，输出任意一种即可）。\n\n", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 Yokohama R] Remodeling the Dungeon 2", "background": "译自 [ICPC 2024 Yokohama Regional Contest](https://icpc.jp/2024/)。", "description": "\n\n_Icpca_ 王国的女王平静地居住在一座城堡中。一天，她决定重造城堡的地牢。  \n\n地牢是一个由方形单元格组成的矩形网格。部分单元格是可进入的房间，而其他则是不可进入的管道空间。所有相邻单元格之间都被一堵墙隔开。某些相邻房间之间的墙上安装了用于通行的门。地牢中任意一对房间都可以通过这些门连通。  \n\n女王希望重造地牢，使得任意一对房间之间仅存在唯一路径。此外，任意两个都只有一扇门的房间应通过一条经过偶数扇门的路径相连。 由于成本限制，重造时只能封锁部分（可能为零扇）门。  \n\n你的任务是找到一种满足女王要求的地牢重造方案。  \n", "inputFormat": "\n仅一组数据，格式如下所示：\n \n>$h$ $w$\n> $c_{1,1}$ $c_{1,2}$ $\\cdots$ $c_{1,2w+1}$\\\n> $c_{2,1}$ $c_{2,2}$ $\\cdots$ $c_{2,2w+1}$\\\n> $\\vdots$\\\n> $c_{2h+1,1}$ $c_{2h+1,2}$ $\\cdots$ $c_{2h+1,2w+1}$\n>\n\n两个整数 $h$ 和 $w$ 表示地牢大小为 $h \\times w$（$1 \\leq h,w \\leq 400$）。  \n每个字符 $c_{i,j}$（$1 \\leq i \\leq 2h+1$, $1 \\leq j \\leq 2w+1$）为 `.` 或 `#`，其含义如下：  \n\n- 当 $i$ 和 $j$ 均为偶数时，$c_{i,j}$ 表示位于地牢第 $(i/2)$ 行（北向南）、第 $(j/2)$ 列（西向东）的单元格，记作单元格 $(i/2, j/2)$。若为 `.` 则是房间，若为 `#` 则是管道空间。  \n- 当 $i$ 为奇数且 $j$ 为偶数时，表示一堵墙。若 $i=1$ 或 $i=2h+1$，则为地牢外墙（始终为 `#`）。否则 $c_{i,j}$ 表示单元格 $((i−1)/2, j/2)$ 和 $((i+1)/2, j/2)$ 之间的墙。若为 `.` 则该墙有门，若为 `#` 则无门（门仅存在于两个房间之间的墙上）。  \n- 当 $i$ 为偶数且 $j$ 为奇数时，同样表示一堵墙。若 $j=1$ 或 $j=2w+1$，则为地牢外墙（始终为 `#`）。否则 $c_{i,j}$ 表示单元格 $(i/2, (j−1)/2)$ 和 $(i/2, (j+1)/2)$ 之间的墙。若为 `.` 则该墙有门，若为 `#` 则无门（门仅存在于两个房间之间的墙上）。  \n- 当 $i$ 和 $j$ 均为奇数时，$c_{i,j}$ 始终为 `#`，对应墙体的交叉点。  \n\n数据保证地牢中至少有一个房间，且任意一对房间存在连通路径。  ", "outputFormat": "\n若无法按要求重造地牢，输出 $\\texttt{No}$。否则第一行输出 $\\texttt{Yes}$，接着按输入格式输出重造后的地牢配置（若有多种可能配置，输出任意一种即可）。\n\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12786", "type": "P", "difficulty": 5, "samples": [["6\n10 20 30 40 50 60\n3\n1 6\n2 5\n4 5", "30\n20\n10"], ["10\n13 2 35 4 13 2 5 1 7 4\n5\n1 4\n4 10\n3 8\n3 9\n1 10", "2\n4\n5\n7\n13"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["数学", "2024", "ICPC", "离线处理", "横浜"], "title": "[ICPC 2024 Yokohama R] Greatest of the Greatest Common Divisors", "background": "译自 [ICPC 2024 Yokohama Regional Contest](https://icpc.jp/2024/)。", "description": "\n\n\n给定一个整数序列和该序列上的若干区间。这些区间由其最左位置和最右位置指定。一个包含 $k$ 个整数的区间具有 $k(k - 1)/2$ 个位于不同位置的数对，每个数对有其最大公约数。 对于每个给定的区间，找出所有这些最大公约数中最大的一个。  \n\n例如，当序列为 $(a_1, \\ldots, a_6) = (10, 20, 30, 40, 50, 60)$，且询问区间为整个序列时，需要考虑以下 $15$ 个位于不同位置 $x$ 和 $y$ 的两个整数组成的数对及其最大公约数：\n\n\n| $x$ | $1$ | $1$ | $1$ | $1$ | $1$ | $2$ | $2$ | $2$ | $2$ | $3$ | $3$ | $\\textbf{3}$ | $4$ | $4$ | $5$ |\n| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |:-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | \n| $y$ | $2$ | $3$ | $4$ | $5$ | $6$ | $3$ | $4$ | $5$ | $6$ | $4$ | $5$ | $\\textbf{6}$ | $5$ | $6$ | $6$ |\n| $a_x$ | $10$ | $10$ | $10$ | $10$ | $10$ | $20$ | $20$ | $20$ | $20$ | $30$ | $30$ | $\\textbf{30}$ | $40$ | $40$ | $50$ |\n| $a_y$ | $20$ | $30$ | $40$ | $50$ | $60$ | $30$ | $40$ | $50$ | $60$ | $40$ | $50$ | $\\textbf{60}$ | $50$ | $60$ | $60$ |\n| $\\gcd(a_x,a_y)$ | $10$ | $10$ | $10$ | $10$ | $10$ | $10$ | $20$ | $10$ | $20$ | $10$ | $10$ | $\\textbf{30}$ | $10$ | $20$ | $10$ |  \n\n在此例中，这 $15$ 个数对的最大公约数中的最大值为 $\\gcd(30, 60) = 30$。  ", "inputFormat": "\n仅一组数据，格式如下所示：\n\n> $n$\\\n> $a_1$ $\\cdots$ $a_n$\\\n> $q$\\\n> $l_1$ $r_1$\\\n> $\\cdots$\\\n> $l_q$ $r_q$\n\n第一行包含一个整数 $n$，表示给定序列中整数的个数，满足 $2 \\leq n \\leq 10^5$。第二行包含 $n$ 个正整数 $a_1$ 到 $a_n$，指定该序列。其中每个数均不超过 $10^5$。  \n\n第三行包含一个正整数 $q$，指定要考虑的序列区间数量，其值不超过 $10^5$。  随后是 $q$ 行，每行指定序列中一个要考虑的区间。其中第 $i$ 行包含两个整数 $l_i$ 和 $r_i$ $(1 \\leq l_i < r_i \\leq n)$，指定序列中从 $a_{l_i}$ 到 $a_{r_i}$ 的区间。  \n", "outputFormat": "\n输出 $q$ 行，其中第 $i$ 行应包含在 $l_i$ 和 $r_i$ 指定的区间内所有数对的最大公约数中的最大值。  \n", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 Yokohama R] Greatest of the Greatest Common Divisors", "background": "译自 [ICPC 2024 Yokohama Regional Contest](https://icpc.jp/2024/)。", "description": "\n\n\n给定一个整数序列和该序列上的若干区间。这些区间由其最左位置和最右位置指定。一个包含 $k$ 个整数的区间具有 $k(k - 1)/2$ 个位于不同位置的数对，每个数对有其最大公约数。 对于每个给定的区间，找出所有这些最大公约数中最大的一个。  \n\n例如，当序列为 $(a_1, \\ldots, a_6) = (10, 20, 30, 40, 50, 60)$，且询问区间为整个序列时，需要考虑以下 $15$ 个位于不同位置 $x$ 和 $y$ 的两个整数组成的数对及其最大公约数：\n\n\n| $x$ | $1$ | $1$ | $1$ | $1$ | $1$ | $2$ | $2$ | $2$ | $2$ | $3$ | $3$ | $\\textbf{3}$ | $4$ | $4$ | $5$ |\n| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |:-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | \n| $y$ | $2$ | $3$ | $4$ | $5$ | $6$ | $3$ | $4$ | $5$ | $6$ | $4$ | $5$ | $\\textbf{6}$ | $5$ | $6$ | $6$ |\n| $a_x$ | $10$ | $10$ | $10$ | $10$ | $10$ | $20$ | $20$ | $20$ | $20$ | $30$ | $30$ | $\\textbf{30}$ | $40$ | $40$ | $50$ |\n| $a_y$ | $20$ | $30$ | $40$ | $50$ | $60$ | $30$ | $40$ | $50$ | $60$ | $40$ | $50$ | $\\textbf{60}$ | $50$ | $60$ | $60$ |\n| $\\gcd(a_x,a_y)$ | $10$ | $10$ | $10$ | $10$ | $10$ | $10$ | $20$ | $10$ | $20$ | $10$ | $10$ | $\\textbf{30}$ | $10$ | $20$ | $10$ |  \n\n在此例中，这 $15$ 个数对的最大公约数中的最大值为 $\\gcd(30, 60) = 30$。  ", "inputFormat": "\n仅一组数据，格式如下所示：\n\n> $n$\\\n> $a_1$ $\\cdots$ $a_n$\\\n> $q$\\\n> $l_1$ $r_1$\\\n> $\\cdots$\\\n> $l_q$ $r_q$\n\n第一行包含一个整数 $n$，表示给定序列中整数的个数，满足 $2 \\leq n \\leq 10^5$。第二行包含 $n$ 个正整数 $a_1$ 到 $a_n$，指定该序列。其中每个数均不超过 $10^5$。  \n\n第三行包含一个正整数 $q$，指定要考虑的序列区间数量，其值不超过 $10^5$。  随后是 $q$ 行，每行指定序列中一个要考虑的区间。其中第 $i$ 行包含两个整数 $l_i$ 和 $r_i$ $(1 \\leq l_i < r_i \\leq n)$，指定序列中从 $a_{l_i}$ 到 $a_{r_i}$ 的区间。  \n", "outputFormat": "\n输出 $q$ 行，其中第 $i$ 行应包含在 $l_i$ 和 $r_i$ 指定的区间内所有数对的最大公约数中的最大值。  \n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12787", "type": "P", "difficulty": 7, "samples": [["3 10 5000\n10 2000 3000\n10 4000 6000\n10 7000 8000", "1 2"], ["2 10 5000\n7 4500 5500\n12 3500 6000", "4 5"], ["3 1 4159\n1 1 1\n1 100 100\n1 10000 10000", "0 1"], ["6 12345 6789\n2718 2818 2845\n9045 2353 6028\n7471 3526 6249\n7757 2470 9369\n9959 5749 6696\n7627 7240 7663", "23901191037 67820000"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2024", "ICPC", "横浜"], "title": "[ICPC 2024 Yokohama R] Mixing Solutions", "background": "译自 [ICPC 2024 Yokohama Regional Contest](https://icpc.jp/2024/)。", "description": "\n我们来准备一个使用化学物质横滨黄（Yokohama Yellow），简称 YY 的实验。你有一些装有 YY 水溶液的容器。虽然 YY 在每种溶液中都均匀溶解，但不同容器中的浓度可能不同。你将从一些容器中取出任意量的溶液，并将它们混合以制备具有预定总量的新溶液。\n\n理想情况下，混合溶液应包含目标量的 YY，但存在一个问题。虽然每个容器中溶液的确切量是已知的，但每种溶液中 YY 的量只保证落在某个范围内。由于这种不确定性，很难使混合溶液中 YY 的量与目标量精确匹配。尽管如此，你可以确保误差（与目标量的差值）永远不会超过某个限制。\n\n更精确地说，设混合溶液中 YY 的目标量和实际量分别为 $y_t$ 毫克和 $y_a$ 毫克。给定从容器中取出的溶液量，$y_a$ 保证落在某个范围内。当 $y_a$ 在此范围内变化时，最大误差定义为 $|y_a - y_t|$ 的最大值。\n\n求最大误差的最小值，条件是你可以在每个容器中取出任意部分的溶液，只要它们的总量等于预定总量。\n", "inputFormat": "\n仅一组数据，格式如下所示：\n\n\n> $n$ $s$ $c$\\\n> $a_1$ $l_1$ $r_1$\\\n> $\\vdots$\\\n> $a_n$ $l_n$ $r_n$\n\n第一行包含三个整数 $n$、$s$ 和 $c$，满足 $1 \\le n \\le 1000$，$1 \\le s \\le 10^5$ 和 $0 \\le c \\le M$，其中 $M = 10^4$ 在此及下文中均如此。这里，$n$ 表示 YY 溶液容器的数量。混合溶液的预定总量为 $s$ 毫克，YY 的目标量为 $\\frac{c}{M} s$ 毫克。接下来的 $n$ 行中的第 $i$ 行包含三个整数 $a_i$、$l_i$ 和 $r_i$，满足 $1 \\le a_i \\le 10^5$ 和 $0 \\le l_i \\le r_i \\le M$。这些整数表示第 $i$ 个容器有 $a_i$ 毫克溶液，并且其中 YY 的量保证在 $\\frac{l_i}{M} a_i$ 毫克和 $\\frac{r_i}{M} a_i$ 毫克之间（包括两端）。它们满足 $\\sum_{i=1}^n a_i \\ge s$。", "outputFormat": "\n最大误差的最小值可以被证明是一个有理数。将该值表示为不可约分数 $p/q$，其中 $q > 0$，输出一行两个整数 $p,q$，以空格分隔。\n\n", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 Yokohama R] Mixing Solutions", "background": "译自 [ICPC 2024 Yokohama Regional Contest](https://icpc.jp/2024/)。", "description": "\n我们来准备一个使用化学物质横滨黄（Yokohama Yellow），简称 YY 的实验。你有一些装有 YY 水溶液的容器。虽然 YY 在每种溶液中都均匀溶解，但不同容器中的浓度可能不同。你将从一些容器中取出任意量的溶液，并将它们混合以制备具有预定总量的新溶液。\n\n理想情况下，混合溶液应包含目标量的 YY，但存在一个问题。虽然每个容器中溶液的确切量是已知的，但每种溶液中 YY 的量只保证落在某个范围内。由于这种不确定性，很难使混合溶液中 YY 的量与目标量精确匹配。尽管如此，你可以确保误差（与目标量的差值）永远不会超过某个限制。\n\n更精确地说，设混合溶液中 YY 的目标量和实际量分别为 $y_t$ 毫克和 $y_a$ 毫克。给定从容器中取出的溶液量，$y_a$ 保证落在某个范围内。当 $y_a$ 在此范围内变化时，最大误差定义为 $|y_a - y_t|$ 的最大值。\n\n求最大误差的最小值，条件是你可以在每个容器中取出任意部分的溶液，只要它们的总量等于预定总量。\n", "inputFormat": "\n仅一组数据，格式如下所示：\n\n\n> $n$ $s$ $c$\\\n> $a_1$ $l_1$ $r_1$\\\n> $\\vdots$\\\n> $a_n$ $l_n$ $r_n$\n\n第一行包含三个整数 $n$、$s$ 和 $c$，满足 $1 \\le n \\le 1000$，$1 \\le s \\le 10^5$ 和 $0 \\le c \\le M$，其中 $M = 10^4$ 在此及下文中均如此。这里，$n$ 表示 YY 溶液容器的数量。混合溶液的预定总量为 $s$ 毫克，YY 的目标量为 $\\frac{c}{M} s$ 毫克。接下来的 $n$ 行中的第 $i$ 行包含三个整数 $a_i$、$l_i$ 和 $r_i$，满足 $1 \\le a_i \\le 10^5$ 和 $0 \\le l_i \\le r_i \\le M$。这些整数表示第 $i$ 个容器有 $a_i$ 毫克溶液，并且其中 YY 的量保证在 $\\frac{l_i}{M} a_i$ 毫克和 $\\frac{r_i}{M} a_i$ 毫克之间（包括两端）。它们满足 $\\sum_{i=1}^n a_i \\ge s$。", "outputFormat": "\n最大误差的最小值可以被证明是一个有理数。将该值表示为不可约分数 $p/q$，其中 $q > 0$，输出一行两个整数 $p,q$，以空格分隔。\n\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12788", "type": "P", "difficulty": 4, "samples": [["4 3\nNNY\nYYN\nYNY\nNYY", "2 3"], ["3 6\nNNNYYY\nYYNYYN\nYYYNNN", "1 3"], ["6 5\nNNNNN\nYNNNY\nYYNNN\nYYNNN\nNYYNY\nNNYYY", "3 6"], ["3 3\nYNN\nNYN\nNNY", "No"], ["4 4\nNYNN\nYNYY\nYNYN\nNNYY", "1 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2024", "ICPC", "横浜"], "title": "[ICPC 2024 Yokohama R] Scheduling Two Meetings", "background": "译自 [ICPC 2024 Yokohama Regional Contest](https://icpc.jp/2024/)。", "description": "你是今年国际大学生知识竞赛（International Collegiate Quiz Contes, ICQC）的首席评委。你希望举行两次评委会议，以准备竞赛的题目集。你提出了会议的备选日程，并且所有评委都针对每个时间段回答了他们是会现场参加会议还是通过视频会议工具远程参加。 \n\n你必须选择一对两个不同的时间段，以便每位评委都至少现场参加两次会议中的一次。 当存在多解时，你希望选择一个现场参加两次会议的评委人数最多的解。若仍有多解，则优先选择第一次会议时间较早的解。如果第一次会议的时间段相同，仍然剩下多个解，则应选择第二次会议时间最早的解。", "inputFormat": "\n仅一组数据，格式如下所示：\n\n> $n$ $m$\\\n> $a_{1,1}$ $\\dots$ $a_{1,m}$\\\n> $\\dots$\\\n> $a_{n,1}$ $\\dots$ $a_{n,m}$\n\n第一行两个整数 $n$ 和 $m$。第一个整数 $n$ ($2 \\le n \\le 2 \\times 10^5$) 是备选时间段的数量。这里，备选时间段从 $1$ 到 $n$ 编号，较小的数字表示较早的时间段。第二个整数 $m$ ($2 \\le m \\le 20$) 是评委的数量。\n\n接下来 $n$ 行，$a_{i,j}$ 要么是字符 $\\texttt{Y}$，表示第 $j$ 位评委在第 $i$ 个备选时间段现场参加会议，要么是字符 $\\texttt{N}$，表示远程参加。\n", "outputFormat": "\n输出一行，包含最优先选择的两个时间段编号，用一个空格分隔，较早的时间段在前。若无解，输出 $\\texttt{No}$。\n\n", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 Yokohama R] Scheduling Two Meetings", "background": "译自 [ICPC 2024 Yokohama Regional Contest](https://icpc.jp/2024/)。", "description": "你是今年国际大学生知识竞赛（International Collegiate Quiz Contes, ICQC）的首席评委。你希望举行两次评委会议，以准备竞赛的题目集。你提出了会议的备选日程，并且所有评委都针对每个时间段回答了他们是会现场参加会议还是通过视频会议工具远程参加。 \n\n你必须选择一对两个不同的时间段，以便每位评委都至少现场参加两次会议中的一次。 当存在多解时，你希望选择一个现场参加两次会议的评委人数最多的解。若仍有多解，则优先选择第一次会议时间较早的解。如果第一次会议的时间段相同，仍然剩下多个解，则应选择第二次会议时间最早的解。", "inputFormat": "\n仅一组数据，格式如下所示：\n\n> $n$ $m$\\\n> $a_{1,1}$ $\\dots$ $a_{1,m}$\\\n> $\\dots$\\\n> $a_{n,1}$ $\\dots$ $a_{n,m}$\n\n第一行两个整数 $n$ 和 $m$。第一个整数 $n$ ($2 \\le n \\le 2 \\times 10^5$) 是备选时间段的数量。这里，备选时间段从 $1$ 到 $n$ 编号，较小的数字表示较早的时间段。第二个整数 $m$ ($2 \\le m \\le 20$) 是评委的数量。\n\n接下来 $n$ 行，$a_{i,j}$ 要么是字符 $\\texttt{Y}$，表示第 $j$ 位评委在第 $i$ 个备选时间段现场参加会议，要么是字符 $\\texttt{N}$，表示远程参加。\n", "outputFormat": "\n输出一行，包含最优先选择的两个时间段编号，用一个空格分隔，较早的时间段在前。若无解，输出 $\\texttt{No}$。\n\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12789", "type": "P", "difficulty": 6, "samples": [["5 5 1\n2 2 2 4 4", "2"], ["5 5 1\n12 2 2 4 4", "3"], ["5 20000 10000\n5000 10000 15000 5000 25000", "2"], ["9 5 3\n4 2 2 1 1 4 3 2 1", "2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2024", "ICPC", "横浜"], "title": "[ICPC 2024 Yokohama R] Peculiar Protocol", "background": "译自 [ICPC 2024 Yokohama Regional Contest](https://icpc.jp/2024/)。", "description": "_Icpca_ 王国在婚礼仪式上有一个特殊的规矩：礼金的数额必须是某个固定数量的倍数加上一个固定的额外数额。当固定数量是 $d$ 且固定额外数额是 $r$ 时，合规的礼金数额是 $k \\times d + r$，其中 $k$ 是任意非负整数乘数。\n\n最初，你有一叠 $n$ 张钞票。每次你参加婚礼仪式时，你会从当前钞票堆中取出一部分连续的钞票作为礼物，其总和为一个合规的数额，即 $d$ 的倍数加上额外的 $r$。如果没有连续的一段的钞票总和合规，你就不能再参加婚礼仪式了。取出后，剩余的钞票会被挤压形成一叠，并保持它们的相对顺序。形成的钞票堆中可能仍有总和达到该数额的部分，这允许你参加更多的仪式。\n\n你的礼金预计会提升你的社会声誉。由于额外数额 $r$ 被认为是强制性的，乘数 $k$ 被认为是重要的。你在参加的每次仪式中，声誉都会按 $k$ 的比例提升。\n例如，假设 $d = 5$ 且 $r = 1$，你拥有的钞票面值按顺序堆叠为 $2,2,2,4,4$。当你参加婚礼仪式时，有两种可能的方式可以给出合规的礼金。\n- 给出由最上面三张钞票组成的礼金，总计为 $2 + 2 + 2 = 6 = 1 \\times d + r$。取出它们后，你剩下两张面值为 4 和 4 的钞票。你剩余的钞票堆中没有连续的部分总和达到合规的数额。因此，你不能再参加婚礼仪式了。\n- 给出由第三张和第四张钞票组成的礼金，总计为 $2 + 4 = 6 = 1 \\times d + r$。取出它们后，你剩下三张面值依次为 $2,2,4$ 的钞票。你可以参加另一场婚礼仪式，因为第二张和第三张钞票的总和为 $2 + 4 = 6 = 1 \\times d + r$，这是合规的。\n\n在这个例子中，第二种方式可以通过参加两次仪式来最大化你的社会声誉，因为乘数总和为 $1 + 1 = 2$，这达到了最大可能值。\n\n相比之下，如果第一张钞票的面值是 12，在一次仪式中给出前三张钞票后，你就无法参加更多仪式了。然而，这会最大化你的社会声誉，因为乘数总和为 $3$，这达到了最大可能值。\n\n计算你在婚礼仪式上礼金乘数的最大可能总和。你可以假设你有很多未婚的亲戚和朋友，只要你能给出合规的礼金，你就可以参加任意数量的婚礼仪式。", "inputFormat": "\n仅一组数据，格式如下所示：\n\n> $n$ $d$ $r$\\\n> $a_1$ $\\cdots$ $a_n$\n\n第一行，三个整数 $n,d,r$。整数 $n$（$1 \\le n \\le 500$）是你拥有的钞票数量。整数 $d$ 和 $r$（$2 \\le d \\le 10^8$，$0 \\le r < d$）表示特殊规矩的参数。第二行有 $n$ 个整数， $a_1, \\ldots, a_n$。其中，$a_i$（$0 \\le a_i \\le 10^8$）表示从顶部数第 $i$ 张钞票的面值。", "outputFormat": "\n\n输出一行，包含你在婚礼仪式上礼金乘数的最大可能总和。\n\n", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2024 Yokohama R] Peculiar Protocol", "background": "译自 [ICPC 2024 Yokohama Regional Contest](https://icpc.jp/2024/)。", "description": "_Icpca_ 王国在婚礼仪式上有一个特殊的规矩：礼金的数额必须是某个固定数量的倍数加上一个固定的额外数额。当固定数量是 $d$ 且固定额外数额是 $r$ 时，合规的礼金数额是 $k \\times d + r$，其中 $k$ 是任意非负整数乘数。\n\n最初，你有一叠 $n$ 张钞票。每次你参加婚礼仪式时，你会从当前钞票堆中取出一部分连续的钞票作为礼物，其总和为一个合规的数额，即 $d$ 的倍数加上额外的 $r$。如果没有连续的一段的钞票总和合规，你就不能再参加婚礼仪式了。取出后，剩余的钞票会被挤压形成一叠，并保持它们的相对顺序。形成的钞票堆中可能仍有总和达到该数额的部分，这允许你参加更多的仪式。\n\n你的礼金预计会提升你的社会声誉。由于额外数额 $r$ 被认为是强制性的，乘数 $k$ 被认为是重要的。你在参加的每次仪式中，声誉都会按 $k$ 的比例提升。\n例如，假设 $d = 5$ 且 $r = 1$，你拥有的钞票面值按顺序堆叠为 $2,2,2,4,4$。当你参加婚礼仪式时，有两种可能的方式可以给出合规的礼金。\n- 给出由最上面三张钞票组成的礼金，总计为 $2 + 2 + 2 = 6 = 1 \\times d + r$。取出它们后，你剩下两张面值为 4 和 4 的钞票。你剩余的钞票堆中没有连续的部分总和达到合规的数额。因此，你不能再参加婚礼仪式了。\n- 给出由第三张和第四张钞票组成的礼金，总计为 $2 + 4 = 6 = 1 \\times d + r$。取出它们后，你剩下三张面值依次为 $2,2,4$ 的钞票。你可以参加另一场婚礼仪式，因为第二张和第三张钞票的总和为 $2 + 4 = 6 = 1 \\times d + r$，这是合规的。\n\n在这个例子中，第二种方式可以通过参加两次仪式来最大化你的社会声誉，因为乘数总和为 $1 + 1 = 2$，这达到了最大可能值。\n\n相比之下，如果第一张钞票的面值是 12，在一次仪式中给出前三张钞票后，你就无法参加更多仪式了。然而，这会最大化你的社会声誉，因为乘数总和为 $3$，这达到了最大可能值。\n\n计算你在婚礼仪式上礼金乘数的最大可能总和。你可以假设你有很多未婚的亲戚和朋友，只要你能给出合规的礼金，你就可以参加任意数量的婚礼仪式。", "inputFormat": "\n仅一组数据，格式如下所示：\n\n> $n$ $d$ $r$\\\n> $a_1$ $\\cdots$ $a_n$\n\n第一行，三个整数 $n,d,r$。整数 $n$（$1 \\le n \\le 500$）是你拥有的钞票数量。整数 $d$ 和 $r$（$2 \\le d \\le 10^8$，$0 \\le r < d$）表示特殊规矩的参数。第二行有 $n$ 个整数， $a_1, \\ldots, a_n$。其中，$a_i$（$0 \\le a_i \\le 10^8$）表示从顶部数第 $i$ 张钞票的面值。", "outputFormat": "\n\n输出一行，包含你在婚礼仪式上礼金乘数的最大可能总和。\n\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12790", "type": "P", "difficulty": 5, "samples": [["4\n2\n2 1\n3\n1 2 3\n4\n2 1 4 3\n5\n5 1 4 2 3", "Impossible\nPossible\n3 1 2\n2 3 1\nPossible\n3 4 2 1\n3 4 2 1\nPossible\n4 1 2 5 3\n3 1 4 5 2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["模拟", "图论", "2022", "Special Judge", "置换", "随机化", "构造", "ICPC", "Ad-hoc", "NERC/NEERC"], "title": "[NERC 2022] Amazing Trick", "background": "", "description": "Alice is a magician and she creates a new trick. She has $n$ cards with different numbers from $1$ to $n$ written on them. First, she asks an audience member to shuffle the deck and put cards in a row. Let's say the $i$-th card from the left has the number $a_i$ on it. \n\nThen Alice picks two permutations $p$ and $q$. There is a restriction on $p$ and $q$ --- $\\textbf{permutations can't have fixed points}$. Which means $\\forall i: p_i \\ne i\\ and\\ q_i \\ne i$.\n\nAfter permutations are chosen, Alice shuffles the cards according to them. Now the $i$-th card from the left is the card $a[p[q[i]]$. The trick is considered successful if $i$-th card from the left has the number $i$ on it after the shuffles.\n\nHelp Alice pick the permutations $p$ and $q$ or say it is not possible for the specific starting permutation $a$. ", "inputFormat": "The first line of the input contains the number of tests $t$ ($1 \\leq t \\leq 10^5$). \n\nEach test is described in two lines. The first line contains one integer $n$ --- the number of cards ($1 \\leq n \\leq 10^5$). The second line contains $n$ integers $a_i$ --- the initial permutation of the cards ($1 \\leq a_i \\leq n$; $\\forall i \\neq j: a_i \\neq a_j$). \n\nIt is guaranteed that the sum of $n$ over all tests does not exceed $10^5$.", "outputFormat": "Print the answer for each test case in the same order the cases appear in the input.\n\nFor each test case, print $\\tt{Impossible}$ in a single line, if no solution exists.\n\nOtherwise, print $\\tt{Possible}$ in the first line, and in the following two lines print permutations $p$ and $q$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2022] Amazing Trick", "background": "", "description": "Alice is a magician and she creates a new trick. She has $n$ cards with different numbers from $1$ to $n$ written on them. First, she asks an audience member to shuffle the deck and put cards in a row. Let's say the $i$-th card from the left has the number $a_i$ on it. \n\nThen Alice picks two permutations $p$ and $q$. There is a restriction on $p$ and $q$ --- $\\textbf{permutations can't have fixed points}$. Which means $\\forall i: p_i \\ne i\\ and\\ q_i \\ne i$.\n\nAfter permutations are chosen, Alice shuffles the cards according to them. Now the $i$-th card from the left is the card $a[p[q[i]]$. The trick is considered successful if $i$-th card from the left has the number $i$ on it after the shuffles.\n\nHelp Alice pick the permutations $p$ and $q$ or say it is not possible for the specific starting permutation $a$. ", "inputFormat": "The first line of the input contains the number of tests $t$ ($1 \\leq t \\leq 10^5$). \n\nEach test is described in two lines. The first line contains one integer $n$ --- the number of cards ($1 \\leq n \\leq 10^5$). The second line contains $n$ integers $a_i$ --- the initial permutation of the cards ($1 \\leq a_i \\leq n$; $\\forall i \\neq j: a_i \\neq a_j$). \n\nIt is guaranteed that the sum of $n$ over all tests does not exceed $10^5$.", "outputFormat": "Print the answer for each test case in the same order the cases appear in the input.\n\nFor each test case, print $\\tt{Impossible}$ in a single line, if no solution exists.\n\nOtherwise, print $\\tt{Possible}$ in the first line, and in the following two lines print permutations $p$ and $q$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2022] Amazing Trick", "background": "", "description": "Alice 是一位魔术师，她创造了一个新魔术。她有 $n$ 张卡片，上面分别写着从 $1$ 到 $n$ 的不同数字。首先，她请一位观众洗牌，并将卡片排成一行。我们设从左数第 $i$ 张卡片上的数字是 $a_i$。\n\n然后 Alice 选择两个排列 $p$ 和 $q$。对于 $p$ 和 $q$ 有一个限制——**排列不能有不动点**。这意味着 $\\forall i: p_i \\ne i$ 且 $q_i \\ne i$。\n\n在选定排列后，Alice 会根据它们来洗牌。现在，从左数第 $i$ 张卡片变成了 $a[p[q[i]]]$。如果经过洗牌后，从左数第 $i$ 张卡片上的数字恰好是 $i$，那么这个魔术就被认为是成功的。\n\n请帮助 Alice 挑选出排列 $p$ 和 $q$，或者在对于给定的初始排列 $a$ 无解时指出这一点。", "inputFormat": "输入的第一行包含测试数据的组数 $t$ ($1 \\leq t \\leq 10^5$)。\n\n每组测试数据由两行描述。第一行包含一个整数 $n$——卡片的数量 ($1 \\leq n \\leq 10^5$)。第二行包含 $n$ 个整数 $a_i$——卡片的初始排列 ($1 \\leq a_i \\leq n$; $\\forall i \\neq j: a_i \\neq a_j$)。\n\n保证所有测试数据中 $n$ 的总和不超过 $10^5$。", "outputFormat": "对于每组测试数据，请按照它们在输入中出现的顺序输出答案。\n\n对于每组测试数据，如果无解，则在单独的一行中输出 $\\tt{Impossible}$。\n\n否则，在第一行输出 $\\tt{Possible}$，并在接下来的两行中分别输出排列 $p$ 和 $q$。", "hint": "翻译由 gemini2.5pro 完成", "locale": "zh-CN"}}}
{"pid": "P12791", "type": "P", "difficulty": 5, "samples": [["3 50\n1 2 3    1 2 3    3 2 1    1 2 3\n3 2 1    1 2 3    1 2 3    1 2 3\n1 2 3    3 2 1    1 2 3    3 2 1\n1 2 3    3 2 1    1 2 3    3 2 1\n1 2 3    1 2 3    3 2 1    1 2 3\n3 2 1    1 2 3    3 2 1    1 2 3\n1 2 3    3 2 1    1 2 3    1 2 3\n1 2 3    1 2 3    3 2 1    1 2 3\n3 2 1    3 2 1    1 2 3    3 2 1\n1 2 3    3 2 1    3 2 1    1 2 3\n1 2 3    3 2 1    1 2 3    3 2 1\n3 2 1    3 2 1    1 2 3    1 2 3\n3 2 1    3 2 1    ", "2 -1 2"], ["5 60\n2 4 3 5 1    1 5 2 4 3    1 5 2 4 3\n1 5 2 4 3    1 5 3 4 2    1 5 3 4 2\n1 5 3 4 2    1 5 3 4 2    1 5 3 4 2\n3 4 2 5 1    2 4 3 5 1    1 5 2 4 3\n3 4 2 5 1    2 4 3 5 1    2 4 3 5 1\n1 5 2 4 3    3 4 2 5 1    3 4 2 5 1\n1 5 2 4 3    2 4 3 5 1    1 5 2 4 3\n1 5 3 4 2    3 4 2 5 1    1 5 3 4 2\n1 5 2 4 3    1 5 3 4 2    1 5 2 4 3\n2 4 3 5 1    2 4 3 5 1    2 4 3 5 1\n2 4 3 5 1    2 4 3 5 1    1 5 2 4 3\n1 5 3 4 2    1 5 2 4 3    3 4 2 5 1\n1 5 3 4 2    3 4 2 5 1    3 4 2 5 1\n1 5 2 4 3    2 4 3 5 1    1 5 2 4 3\n1 5 3 4 2    2 4 3 5 1    2 4 3 5 1\n1 5 2 4 3    1 5 2 4 3    1 5 2 4 3\n1 5 2 4 3    1 5 2 4 3    3 4 2 5 1\n3 4 2 5 1    3 4 2 5 1    1 5 2 4 3\n1 5 3 4 2    1 5 3 4 2    2 4 3 5 1\n3 4 2 5 1    1 5 2 4 3    3 4 2 5 1", "5 4 4 5 -1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2022] BinCoin", "background": "", "description": "There are $n$ employees in the BinCoin company numbered from $1$ to $n$. The subordination structure in this company is a rooted tree. In other words:\n- There is one CEO in the company --- the main boss.\n- Each other employee has exactly one direct superior.\n- There are no cycles in the subordination structure.\n  \nMoreover, due to the inexplicable love of the CEO of BinCoin for all the binary stuff, the subordination structure in the company is a $\\textbf{binary}$ rooted tree. That means each employee is directly superior to exactly zero or two other employees.\n\nIn the CEO's opinion, working in this company is almost as dangerous as in mines. So, employees should sign the waiver of claims sometimes. This process happens in the following way. Initially, CEO takes the journal, then recursively the following procedure is performed:\n\n- If an employee that holds the journal does not have any subordinates, they sign the waiver in the journal and give it back to their superior. The procedure stops if that was the CEO, who has no superior.\n- Otherwise\n  - they choose one of two of their direct subordinates uniformly at random and give the journal to one of them;\n  - when they get the journal back, they sign it;\n  - and then they give it to another direct subordinate;\n  - when they get it back again, they give it back to their superior. The procedure stops if that was the CEO, who has no superior.\n\nAll random choices are independent.\n\nOne day, the CEO realized that they could not remember the subordination tree. Fortunately, they have the journal with $k$ records. Each record is a sequence of employees in the order they've signed in a journal.\n\nHelp CEO restore the subordination tree.", "inputFormat": "The first line contains two integers $n$ and $k$ --- the number of employees and the number of records in the journal ($1 \\le n \\le 999$; $50 \\le k \\le 100$).\n\nEach of the next $k$ lines contains a permutation of integers from $1$ to $n$ --- the order of employees in the corresponding record.\n\nIt is guaranteed that the input was obtained as described in the statement with a real random choice.", "outputFormat": "Output $n$ integers $p_i$. If $i$ is a CEO, then $p_i$ should be $-1$. Otherwise, $p_i$ should be the index of the direct superior of $i$-th employee.\n\nYour output should correspond to a binary rooted tree. If there are several trees satisfying the input, you can output any one of them.", "hint": "In order to fit on the page, several consecutive lines in the examples were joined into one. The real inputs follow the input description.", "locale": "en", "translations": {"en": {"title": "[NERC 2022] BinCoin", "background": "", "description": "There are $n$ employees in the BinCoin company numbered from $1$ to $n$. The subordination structure in this company is a rooted tree. In other words:\n- There is one CEO in the company --- the main boss.\n- Each other employee has exactly one direct superior.\n- There are no cycles in the subordination structure.\n  \nMoreover, due to the inexplicable love of the CEO of BinCoin for all the binary stuff, the subordination structure in the company is a $\\textbf{binary}$ rooted tree. That means each employee is directly superior to exactly zero or two other employees.\n\nIn the CEO's opinion, working in this company is almost as dangerous as in mines. So, employees should sign the waiver of claims sometimes. This process happens in the following way. Initially, CEO takes the journal, then recursively the following procedure is performed:\n\n- If an employee that holds the journal does not have any subordinates, they sign the waiver in the journal and give it back to their superior. The procedure stops if that was the CEO, who has no superior.\n- Otherwise\n  - they choose one of two of their direct subordinates uniformly at random and give the journal to one of them;\n  - when they get the journal back, they sign it;\n  - and then they give it to another direct subordinate;\n  - when they get it back again, they give it back to their superior. The procedure stops if that was the CEO, who has no superior.\n\nAll random choices are independent.\n\nOne day, the CEO realized that they could not remember the subordination tree. Fortunately, they have the journal with $k$ records. Each record is a sequence of employees in the order they've signed in a journal.\n\nHelp CEO restore the subordination tree.", "inputFormat": "The first line contains two integers $n$ and $k$ --- the number of employees and the number of records in the journal ($1 \\le n \\le 999$; $50 \\le k \\le 100$).\n\nEach of the next $k$ lines contains a permutation of integers from $1$ to $n$ --- the order of employees in the corresponding record.\n\nIt is guaranteed that the input was obtained as described in the statement with a real random choice.", "outputFormat": "Output $n$ integers $p_i$. If $i$ is a CEO, then $p_i$ should be $-1$. Otherwise, $p_i$ should be the index of the direct superior of $i$-th employee.\n\nYour output should correspond to a binary rooted tree. If there are several trees satisfying the input, you can output any one of them.", "hint": "In order to fit on the page, several consecutive lines in the examples were joined into one. The real inputs follow the input description.", "locale": "en"}, "zh-CN": {"title": "[NERC 2022] BinCoin", "background": "", "description": "在 BinCoin 公司有 $n$ 名员工，编号从 $1$ 到 $n$。这家公司的隶属关系结构是一棵有根树。换句话说：\n- 公司中有一位 CEO——即最高领导。\n- 其他每位员工都恰好有一位直接上级。\n- 隶属关系结构中没有环。\n\n此外，由于 BinCoin 的 CEO 对所有二进制的东西有着莫名的喜爱，公司的隶属关系结构是一棵**二叉**有根树。这意味着每位员工要么是零位、要么是两位其他员工的直接上级。\n\n在 CEO 看来，在这家公司工作几乎和在矿山里一样危险。因此，员工们有时需要签署免责声明。这个过程按以下方式进行。首先，CEO 拿起记录本，然后递归地执行以下流程：\n\n- 如果持有记录本的员工没有任何下属，他们会在记录本上签名，然后将其交还给他们的上级。如果该员工是 CEO（他没有上级），则流程结束。\n- 否则\n  - 他们从两名直接下属中随机均匀地选择一位，并将记录本交给他；\n  - 当他们收回记录本时，他们自己签名；\n  - 然后他们将记录本交给另一位直接下属；\n  - 当他们再次收回记录本时，他们将其交还给他们的上级。如果该员工是 CEO（他没有上级），则流程结束。\n\n所有的随机选择都是独立的。\n\n一天，CEO 发现他们记不起隶属关系树了。幸运的是，他们有那个记录本，上面有 $k$ 条记录。每条记录都是一个员工序列，表示他们在记录本上签名的顺序。\n\n请帮助 CEO 恢复这棵隶属关系树。", "inputFormat": "第一行包含两个整数 $n$ 和 $k$——员工数量和记录本中的记录数量 ($1 \\le n \\le 999$; $50 \\le k \\le 100$)。\n\n接下来的 $k$ 行，每行包含一个从 $1$ 到 $n$ 的整数排列——表示相应记录中员工的签名顺序。\n\n保证输入数据是在所述的真实随机选择下生成的。", "outputFormat": "输出 $n$ 个整数 $p_i$。如果员工 $i$ 是 CEO，那么 $p_i$ 应为 $-1$。否则，$p_i$ 应为员工 $i$ 的直接上级的编号。\n\n你的输出应对应一棵二叉有根树。如果有多棵树满足输入条件，你可以输出任意一棵。", "hint": "为了适应页面大小，样例中的几行连续的输入被合并到了一行。真实的输入遵循输入格式描述。\n\n翻译由 gemini2.5pro 完成", "locale": "zh-CN"}}}
