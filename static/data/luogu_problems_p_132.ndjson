{"pid": "P3675", "type": "P", "difficulty": 0, "samples": [["4 233 1 1 2\n3 3 1 1\n5 2 1 -1", "m 1\ng 45\n（仅为一种可能输出）"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["洛谷原创", "提交答案", "Special Judge", "模拟退火", "遗传算法", "背包 DP", "洛谷月赛"], "title": "小清新提交答案题", "background": null, "description": "这是一道提交答案题。\n\n\n相信大家都玩过黄金矿工这款游戏吧！不过如果没有玩过建议**赛后**再玩。\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4469.png) \n\n这道题与原游戏**有一些不同**，请仔细阅读规则。\n\n\n将矿区抽象为一个 $2s \\times s$ 的矩形，以左上角作为坐标原点，向右为 $x$ 轴正方向，向下为 $y$ 轴正方向，建立平面直角坐标系。\n\n\n矿工开始在 $(s,0)$，矿工可以在 $x$ 轴一部分：原点与 $(2s,0)$ 的连线（线段）上随意移动。\n\n\n把矿区中的黄金等物品抽象为坐标系中此矩形内一个个不相交的圆，每个圆有一个价值，可正可负。\n\n\n这里我们将抓取的过程抽象为以矿工为一端射出一条射线，如果不与任何圆相交（相切不算），那么这次抓取是无效的；否则矿工将会抓取到相交的圆中最早碰到的一个（较近的交点与矿工距离最近的一个圆）。\n\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s966cayn.png)\n\n\n黄金矿工这款游戏的目的是在规定时间上抓取价值尽量高的物品。\n\n\n移动与抓取都需要时间，移动 $1$ 单位距离需要花费 $k_1$ 的时间，将一次有效抓取的距离定义为抓取到的圆与射线较近的交点与矿工的距离，有效抓取每 $1$ 单位距离需要花费 $k_2$ 的时间（无效抓取将会被忽略）。\n\n\n你将要操纵这位矿工，给出移动和抓取指令，使得获取的价值尽量大。如果某次操作后你所用的总时间超过了规定时限，这次及以后操作将会被忽略。详细格式可见输出描述。\n\n\n**由于矿工比较懒，矿工只接受 $2n$ 次操作（$n$ 为圆的个数，无论是否是无效抓取），多余操作将被忽略。**\n\n\n判定时的 eps 为 $10^{-7}$。若你射出的射线与圆两交点的距离不超过该 eps，那么将不会判定为相交。若你的用时与时限的差不超过 eps，那么也不会被判定为超过时限。\n\n\n由于这是提交答案题，我们会提供输入数据、评分参数和 checker 下载，链接在最后。", "inputFormat": "第一行五个数 $s,t,k_1,k_2,n$，$s,k_1,k_2$ 的含义见题面，$t$ 为规定时限，$n$ 为圆的个数。\n\n\n以下 $n$ 行每行四个数 $x_i,y_i,r_i,v_i$，分别表示编号为 $i$ 的圆圆心 $x$ 坐标、圆心 $y$ 坐标、半径和价值。\n\n\n$n$ 和 $v_i$ 一定为整数，其余量可能为实数。", "outputFormat": "若干行，表示你的操作。\n\n\n每行开头一个字符为 `m` 或 `g`，然后一个空格。（`m`：move，`g`：grab）\n\n\n如果字符是 `m`，接下来应该接一个实数 $p(0 \\leq p \\leq 2s)$，表示将矿工移动到 $(p,0)$。\n\n\n如果字符是 `g`，接下来应该接一个实数 $a(0.2 \\leq a \\leq 179.8)$，表示抓取的射线与 $x$ 轴正方向夹角为 $a^{\\circ}$。\n\n\n**这两个实数建议保留 $10$ 位小数。**\n\n\n超过时限和超过 $2n$ 次的操作将被忽略。如果在输出文件中包含不合法信息该点可能会直接被判为 $0$ 分。", "hint": "#### 样例解释\n\n\n开始矿工在 $(4,0)$，移动到 $(1,0)$，花费 $3$ 时间。\n\n\n如图，矿工发射出一条射线，抓取到第一个圆，获取到 $1$ 价值，花费 $2\\sqrt{2}$ 时间。\n\n\n当然这不是花费时间最小的解，存在其他解。\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4318.png) \n\n#### 评分标准\n\n\n对于每个点，如果你的输出不符合输出格式，得 $0$ 分。\n\n\n否则，假设你获得的价值为 $a$，每个点有三个评分参数，标准答案 $b$、一个实数 $w$、一个 $0$ 或 $1$ 的整数 $f$。\n\n\n若 $a<0$ ，你将获得 $0$ 分。\n\n\n若 $a>b$，你将获得 $10+f$ 分（这意味着部分点你可能会获得 $11$ 分）。\n\n\n否则你将获得 $\\lfloor 10(\\frac{a}{b})^w\\rfloor$ 分。（$\\lfloor x \\rfloor$ 表示不大于 $x$ 的最大整数）\n\n\n#### 如何测试和提交\n\n\n下载下发文件（见附件），里面有 mine1.in ~ mine10.in、mine1.ans ~ mine10.ans 和 checker.cpp、checker\\_win32.exe、tester.bat、testlib.h，**in、ans 和 checker.cpp 与洛谷上实际测试使用的完全相同**。windows 以外的系统，可以自行编译 checker.cpp。\n\n\n测试时在同一目录下放置 mine1.out ~ mine10.out，对于 windows 用户，运行 tester.bat，会自动调用 checker\\_win32.exe 返回每个点的结果。对于其它系统的用户，手动调用 `checker mine1.in mine1.out mine1.ans` 即可返回第一个点的评测结果，其它点同理。\n\n\nchecker 会返回形如 `points 0.9 Your ans is aaa, done bbb attempts, time used ccc, ddd remained` 的结果，表示这个点你可以获得 $9$ 分，你得到的价值是 aaa，成功进行了开始 bbb 个操作，用了 ccc 的时间，剩下 ddd 的时间。如果剩下的时间为负，表示最后一个（没有成功执行的）操作超时了。\n\n\n提交时可以直接将 mine1.out ~ mine10.out 打包上传，一个一个点输入提交亦可。", "locale": "zh-CN", "translations": {"en": {"title": "A \"Xiao Qingxin\" Output-Only Problem", "background": "", "description": "This is an output-only problem.\n\nI believe most of you have played the game Gold Miner. If you have not, it is recommended to try it after the contest.\n\n![](https://cdn.luogu.com.cn/upload/pic/4469.png)\n\nThis problem is a bit different from the original game. Please read the rules carefully.\n\nAbstract the mining area as a rectangle of size $2s \\times s$. Take the upper-left corner as the origin, the positive $x$-axis to the right, and the positive $y$-axis downward, forming a Cartesian coordinate system.\n\nThe miner starts at $(s, 0)$. The miner can move freely along part of the $x$-axis: the line segment from the origin to $(2s, 0)$.\n\nAbstract gold and other items in the mining area as pairwise disjoint circles within this rectangle, each circle having a value, which may be positive or negative.\n\nWe abstract a grab as shooting a ray with the miner at one end. If the ray does not intersect any circle (tangency does not count), then the grab is invalid; otherwise, the miner will grab the first circle hit along the ray (i.e., the circle whose nearer intersection point with the ray has the smallest distance to the miner).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s966cayn.png)\n\nThe goal of Gold Miner is to grab items with as high a total value as possible within the time limit.\n\nBoth moving and grabbing take time. Moving 1 unit of distance costs $k_1$ time. Define the distance of a successful grab as the distance from the miner to the nearer intersection point between the ray and the grabbed circle; each unit of this distance costs $k_2$ time for a valid grab (invalid grabs are ignored for time cost).\n\nYou will control the miner by issuing move and grab commands to maximize the total value obtained. If after some operation your total time exceeds the time limit, that operation and all subsequent operations will be ignored. See the Output Format for details.\n\nBecause the miner is lazy, he accepts only $2n$ operations ($n$ is the number of circles, regardless of whether grabs are invalid). Extra operations will be ignored.\n\nThe judging eps is $10^{-7}$. If the distance between the two intersection points of your ray and a circle does not exceed this eps, it will not be considered an intersection. If the difference between your time used and the time limit does not exceed eps, it will not be considered as exceeding the time limit.\n\nSince this is an output-only problem, we will provide the input data, scoring parameters, and the checker for download. See the link at the end.", "inputFormat": "The first line contains five numbers $s, t, k_1, k_2, n$. The meanings of $s, k_1, k_2$ are as above; $t$ is the time limit; $n$ is the number of circles.\n\nEach of the next $n$ lines contains four numbers $x_i, y_i, r_i, v_i$, representing the $x$-coordinate of the center, the $y$-coordinate of the center, the radius, and the value of the circle with index $i$.\n\n$n$ and $v_i$ are integers; the other quantities may be real numbers.", "outputFormat": "Several lines, each describing one of your operations.\n\nEach line starts with a character `m` or `g`, followed by a space. (`m`: move, `g`: grab)\n\nIf the character is `m`, it should be followed by a real number $p$ ($0 \\leq p \\leq 2s$), meaning move the miner to $(p, 0)$.\n\nIf the character is `g`, it should be followed by a real number $a$ ($0.2 \\leq a \\leq 179.8$), meaning the grab ray makes an angle of $a^\\circ$ with the positive $x$-axis.\n\nIt is recommended to keep 10 decimal places for these two real numbers.\n\nOperations that exceed the time limit and operations beyond $2n$ will be ignored. If your output file contains illegal information, this test may be judged as 0 points.", "hint": "#### Sample Explanation\n\nThe miner starts at $(4, 0)$, moves to $(1, 0)$, costing time $3$.\n\nAs shown, the miner shoots a ray, grabs the first circle hit, gains value $1$, costing time $2\\sqrt{2}$.\n\nOf course, this is not the minimum-time solution; other solutions exist.\n\n![](https://cdn.luogu.com.cn/upload/pic/4318.png)\n\n#### Scoring\n\nFor each test, if your output does not conform to the output format, you get 0 points.\n\nOtherwise, suppose your total value is $a$. Each test has three scoring parameters: the standard answer $b$, a real number $w$, and an integer $f \\in \\{0, 1\\}$.\n\nIf $a < 0$, you get 0 points.\n\nIf $a > b$, you get $10 + f$ points (this means you may get 11 points on some tests).\n\nOtherwise, you get $\\lfloor 10 (\\frac{a}{b})^w \\rfloor$ points. (Here $\\lfloor x \\rfloor$ is the greatest integer not exceeding $x$.)\n\n#### How to Test and Submit\n\nDownload the provided files (see attachments). They include mine1.in ~ mine10.in, mine1.ans ~ mine10.ans, and checker.cpp, checker_win32.exe, tester.bat, testlib.h. The in, ans, and checker.cpp are exactly the same as those actually used on Luogu. For systems other than Windows, you can compile checker.cpp yourself.\n\nFor testing, put mine1.out ~ mine10.out in the same directory. For Windows users, run tester.bat, which will automatically invoke checker_win32.exe and return the result for each test. For other systems, manually run `checker mine1.in mine1.out mine1.ans` to get the result for the first test; similarly for the others.\n\nThe checker will return a message like `points 0.9 Your ans is aaa, done bbb attempts, time used ccc, ddd remained`, meaning you can get 9 points on this test; your obtained value is aaa; you successfully executed the first bbb operations; time used is ccc; and ddd time remains. If the remaining time is negative, it means the last operation (which did not successfully execute) exceeded the time limit.\n\nWhen submitting, you can directly pack and upload mine1.out ~ mine10.out, or submit outputs for each test one by one.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小清新提交答案题", "background": null, "description": "这是一道提交答案题。\n\n\n相信大家都玩过黄金矿工这款游戏吧！不过如果没有玩过建议**赛后**再玩。\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4469.png) \n\n这道题与原游戏**有一些不同**，请仔细阅读规则。\n\n\n将矿区抽象为一个 $2s \\times s$ 的矩形，以左上角作为坐标原点，向右为 $x$ 轴正方向，向下为 $y$ 轴正方向，建立平面直角坐标系。\n\n\n矿工开始在 $(s,0)$，矿工可以在 $x$ 轴一部分：原点与 $(2s,0)$ 的连线（线段）上随意移动。\n\n\n把矿区中的黄金等物品抽象为坐标系中此矩形内一个个不相交的圆，每个圆有一个价值，可正可负。\n\n\n这里我们将抓取的过程抽象为以矿工为一端射出一条射线，如果不与任何圆相交（相切不算），那么这次抓取是无效的；否则矿工将会抓取到相交的圆中最早碰到的一个（较近的交点与矿工距离最近的一个圆）。\n\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s966cayn.png)\n\n\n黄金矿工这款游戏的目的是在规定时间上抓取价值尽量高的物品。\n\n\n移动与抓取都需要时间，移动 $1$ 单位距离需要花费 $k_1$ 的时间，将一次有效抓取的距离定义为抓取到的圆与射线较近的交点与矿工的距离，有效抓取每 $1$ 单位距离需要花费 $k_2$ 的时间（无效抓取将会被忽略）。\n\n\n你将要操纵这位矿工，给出移动和抓取指令，使得获取的价值尽量大。如果某次操作后你所用的总时间超过了规定时限，这次及以后操作将会被忽略。详细格式可见输出描述。\n\n\n**由于矿工比较懒，矿工只接受 $2n$ 次操作（$n$ 为圆的个数，无论是否是无效抓取），多余操作将被忽略。**\n\n\n判定时的 eps 为 $10^{-7}$。若你射出的射线与圆两交点的距离不超过该 eps，那么将不会判定为相交。若你的用时与时限的差不超过 eps，那么也不会被判定为超过时限。\n\n\n由于这是提交答案题，我们会提供输入数据、评分参数和 checker 下载，链接在最后。", "inputFormat": "第一行五个数 $s,t,k_1,k_2,n$，$s,k_1,k_2$ 的含义见题面，$t$ 为规定时限，$n$ 为圆的个数。\n\n\n以下 $n$ 行每行四个数 $x_i,y_i,r_i,v_i$，分别表示编号为 $i$ 的圆圆心 $x$ 坐标、圆心 $y$ 坐标、半径和价值。\n\n\n$n$ 和 $v_i$ 一定为整数，其余量可能为实数。", "outputFormat": "若干行，表示你的操作。\n\n\n每行开头一个字符为 `m` 或 `g`，然后一个空格。（`m`：move，`g`：grab）\n\n\n如果字符是 `m`，接下来应该接一个实数 $p(0 \\leq p \\leq 2s)$，表示将矿工移动到 $(p,0)$。\n\n\n如果字符是 `g`，接下来应该接一个实数 $a(0.2 \\leq a \\leq 179.8)$，表示抓取的射线与 $x$ 轴正方向夹角为 $a^{\\circ}$。\n\n\n**这两个实数建议保留 $10$ 位小数。**\n\n\n超过时限和超过 $2n$ 次的操作将被忽略。如果在输出文件中包含不合法信息该点可能会直接被判为 $0$ 分。", "hint": "#### 样例解释\n\n\n开始矿工在 $(4,0)$，移动到 $(1,0)$，花费 $3$ 时间。\n\n\n如图，矿工发射出一条射线，抓取到第一个圆，获取到 $1$ 价值，花费 $2\\sqrt{2}$ 时间。\n\n\n当然这不是花费时间最小的解，存在其他解。\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4318.png) \n\n#### 评分标准\n\n\n对于每个点，如果你的输出不符合输出格式，得 $0$ 分。\n\n\n否则，假设你获得的价值为 $a$，每个点有三个评分参数，标准答案 $b$、一个实数 $w$、一个 $0$ 或 $1$ 的整数 $f$。\n\n\n若 $a<0$ ，你将获得 $0$ 分。\n\n\n若 $a>b$，你将获得 $10+f$ 分（这意味着部分点你可能会获得 $11$ 分）。\n\n\n否则你将获得 $\\lfloor 10(\\frac{a}{b})^w\\rfloor$ 分。（$\\lfloor x \\rfloor$ 表示不大于 $x$ 的最大整数）\n\n\n#### 如何测试和提交\n\n\n下载下发文件（见附件），里面有 mine1.in ~ mine10.in、mine1.ans ~ mine10.ans 和 checker.cpp、checker\\_win32.exe、tester.bat、testlib.h，**in、ans 和 checker.cpp 与洛谷上实际测试使用的完全相同**。windows 以外的系统，可以自行编译 checker.cpp。\n\n\n测试时在同一目录下放置 mine1.out ~ mine10.out，对于 windows 用户，运行 tester.bat，会自动调用 checker\\_win32.exe 返回每个点的结果。对于其它系统的用户，手动调用 `checker mine1.in mine1.out mine1.ans` 即可返回第一个点的评测结果，其它点同理。\n\n\nchecker 会返回形如 `points 0.9 Your ans is aaa, done bbb attempts, time used ccc, ddd remained` 的结果，表示这个点你可以获得 $9$ 分，你得到的价值是 aaa，成功进行了开始 bbb 个操作，用了 ccc 的时间，剩下 ddd 的时间。如果剩下的时间为负，表示最后一个（没有成功执行的）操作超时了。\n\n\n提交时可以直接将 mine1.out ~ mine10.out 打包上传，一个一个点输入提交亦可。", "locale": "zh-CN"}}}
{"pid": "P3676", "type": "P", "difficulty": 6, "samples": [["4 5\n1 2\n2 3\n2 4\n4 3 2 1\n2 2\n1 1 3\n2 3\n1 2 4\n2 4", "121\n140\n194"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["点分治", "洛谷原创", "O2优化", "树链剖分", "动态树 LCT", "洛谷月赛"], "title": "小清新数据结构题", "background": "**本题时限 2s，内存限制 250M。**", "description": "在很久很久以前，有一棵 $n$ 个点的树，每个点有一个点权。\n\n现在有 $q$ 次操作，每次操作是修改一个点的点权或指定一个点，询问以这个点为根时每棵子树点权和的平方和。\n\n（题目不是很好懂，没看太懂的可以看看样例解释）", "inputFormat": "第一行两个整数 $n,q$。\n\n接下来 $n-1$ 行每行两个整数 $a$ 和 $b$，表示树中 $a$ 与 $b$ 之间有一条边，保证给出的边不会重复。\n\n接下来一行 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个点的点权。\n\n接下来 $q$ 行每行两或三个数，如果第一个数为 $1$，那么接下来有两个数 $x$ 和 $y$，表示将第 $x$ 个点的点权修改为 $y$，如果第一个数为 $2$，那么接下来有一个数 $x$，表示询问以 $x$ 为根时每棵子树点权和的平方和。", "outputFormat": "对于每个询问输出答案。", "hint": "##### 样例解释\n\n这是一个菊花图，$2$ 与 $1,3,4$ 间有边。\n\n一开始每个点点权分别为 $4,3,2,1$。\n\n第一个询问以 $2$ 为根，$1,3,4$ 子树中都只有本身一个点，$2$ 子树中有所有点，那么 $1,3,4$ 子树中的点权和就分别是自己的点权 $4,2,1$，$2$ 子树中的点权和就是 $4+3+2+1=10$，$4^2+2^2+1^1+10^2=121$。\n\n接下来将第一个点点权修改为 $3$，每个点点权分别为 $3,3,2,1$。\n\n第二个询问以 $3$ 为根，$1,4$ 子树中只有自己，$2$ 子树中有 $1,2,4,3$ 子树中有所有点，$1,4$ 子树点权和就是自己的点权 $3,1$，$2$ 子树点权和就是 $3+3+1=7$，$3$ 子树点权和为 $3+3+2+1=9$，$3^2+1^2+7^2+9^2=140$。\n\n接下来把第二个点点权修改为 $4$，每个点点权分别为 $3,4,2,1$。\n\n第三个询问以 $4$ 为根，$1,3$ 子树点权和就是 $3$ 和 $2$，$2$ 子树点权和就是 $3+4+2=9$，$4$ 子树点权和为 $3+4+2+1=10$，$3^2+2^2+9^2+10^2=194$。\n\n##### 数据范围\n\n对于 $10\\%$ 的数据，$n,q \\leq 2000$。\n\n对于 $40\\%$ 的数据，$n,q \\leq 6\\times 10^4$。\n\n对于另外 $30\\%$ 的数据，保证每次询问的根都为 $1$。\n\n对于 $100\\%$ 的数据，$1 \\leq n,q \\leq 2\\times 10^5$，$-10 \\leq$ 输入的每个点权 $\\leq 10$。\n\n建议使用输入优化，~~虽然标程没加读入优化也能过。~~", "locale": "zh-CN", "translations": {"en": {"title": "A Simple and Neat Data Structure Problem", "background": "Time limit: 2 s, memory limit: 256 MB.", "description": "Long long ago, there was a tree with $n$ nodes, and each node had a weight.\n\nThere are $q$ operations. Each operation either modifies the weight of a node or, given a node, asks for the sum of squares of the subtree weight sums when this node is taken as the root.\n\n(If this statement is not very clear, please refer to the sample explanation.)", "inputFormat": "The first line contains two integers $n, q$.\n\nThe next $n - 1$ lines each contain two integers $a$ and $b$, indicating there is an edge between $a$ and $b$ in the tree. It is guaranteed that no edges are duplicated.\n\nThe next line contains $n$ integers, where the $i$-th integer is the weight of node $i$.\n\nThe next $q$ lines each contain two or three numbers. If the first number is $1$, then there are two more numbers $x$ and $y$, meaning the weight of node $x$ is modified to $y$. If the first number is $2$, then there is one more number $x$, meaning you should query the sum of squares of the subtree weight sums when $x$ is the root.", "outputFormat": "For each query, output the answer.", "hint": "Sample explanation:\n\nThis is a star graph, with edges between $2$ and $1, 3, 4$.\n\nInitially, the node weights are $4, 3, 2, 1$.\n\nFor the first query with root $2$, the subtrees of $1, 3, 4$ each contain only themselves, and the subtree of $2$ contains all nodes. Therefore, the subtree weight sums of $1, 3, 4$ are their own weights $4, 2, 1$, and the subtree weight sum of $2$ is $4 + 3 + 2 + 1 = 10$. Thus $4^2 + 2^2 + 1^2 + 10^2 = 121$.\n\nNext, modify the weight of node $1$ to $3$, so the node weights become $3, 3, 2, 1$.\n\nFor the second query with root $3$, the subtrees of $1$ and $4$ each contain only themselves; the subtree of $2$ contains $1, 2, 4$; and the subtree of $3$ contains all nodes. The subtree weight sums are $3, 1, 7, 9$, so $3^2 + 1^2 + 7^2 + 9^2 = 140$.\n\nNext, modify the weight of node $2$ to $4$, so the node weights become $3, 4, 2, 1$.\n\nFor the third query with root $4$, the subtree weight sums of $1$ and $3$ are $3$ and $2$, the subtree weight sum of $2$ is $3 + 4 + 2 = 9$, and the subtree weight sum of $4$ is $3 + 4 + 2 + 1 = 10$. Thus $3^2 + 2^2 + 9^2 + 10^2 = 194$.\n\nConstraints:\n- For 10% of the testdata, $n, q \\leq 2000$.\n- For 40% of the testdata, $n, q \\leq 6 \\times 10^4$.\n- For another 30% of the testdata, the root in every query is $1$.\n- For 100% of the testdata, $1 \\leq n, q \\leq 2 \\times 10^5$, and each input node weight satisfies $-10 \\leq \\text{weight} \\leq 10$.\n\nIt is recommended to use fast I/O, although the official solution without fast I/O can also pass.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小清新数据结构题", "background": "**本题时限 2s，内存限制 250M。**", "description": "在很久很久以前，有一棵 $n$ 个点的树，每个点有一个点权。\n\n现在有 $q$ 次操作，每次操作是修改一个点的点权或指定一个点，询问以这个点为根时每棵子树点权和的平方和。\n\n（题目不是很好懂，没看太懂的可以看看样例解释）", "inputFormat": "第一行两个整数 $n,q$。\n\n接下来 $n-1$ 行每行两个整数 $a$ 和 $b$，表示树中 $a$ 与 $b$ 之间有一条边，保证给出的边不会重复。\n\n接下来一行 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个点的点权。\n\n接下来 $q$ 行每行两或三个数，如果第一个数为 $1$，那么接下来有两个数 $x$ 和 $y$，表示将第 $x$ 个点的点权修改为 $y$，如果第一个数为 $2$，那么接下来有一个数 $x$，表示询问以 $x$ 为根时每棵子树点权和的平方和。", "outputFormat": "对于每个询问输出答案。", "hint": "##### 样例解释\n\n这是一个菊花图，$2$ 与 $1,3,4$ 间有边。\n\n一开始每个点点权分别为 $4,3,2,1$。\n\n第一个询问以 $2$ 为根，$1,3,4$ 子树中都只有本身一个点，$2$ 子树中有所有点，那么 $1,3,4$ 子树中的点权和就分别是自己的点权 $4,2,1$，$2$ 子树中的点权和就是 $4+3+2+1=10$，$4^2+2^2+1^1+10^2=121$。\n\n接下来将第一个点点权修改为 $3$，每个点点权分别为 $3,3,2,1$。\n\n第二个询问以 $3$ 为根，$1,4$ 子树中只有自己，$2$ 子树中有 $1,2,4,3$ 子树中有所有点，$1,4$ 子树点权和就是自己的点权 $3,1$，$2$ 子树点权和就是 $3+3+1=7$，$3$ 子树点权和为 $3+3+2+1=9$，$3^2+1^2+7^2+9^2=140$。\n\n接下来把第二个点点权修改为 $4$，每个点点权分别为 $3,4,2,1$。\n\n第三个询问以 $4$ 为根，$1,3$ 子树点权和就是 $3$ 和 $2$，$2$ 子树点权和就是 $3+4+2=9$，$4$ 子树点权和为 $3+4+2+1=10$，$3^2+2^2+9^2+10^2=194$。\n\n##### 数据范围\n\n对于 $10\\%$ 的数据，$n,q \\leq 2000$。\n\n对于 $40\\%$ 的数据，$n,q \\leq 6\\times 10^4$。\n\n对于另外 $30\\%$ 的数据，保证每次询问的根都为 $1$。\n\n对于 $100\\%$ 的数据，$1 \\leq n,q \\leq 2\\times 10^5$，$-10 \\leq$ 输入的每个点权 $\\leq 10$。\n\n建议使用输入优化，~~虽然标程没加读入优化也能过。~~", "locale": "zh-CN"}}}
{"pid": "P3677", "type": "P", "difficulty": 5, "samples": [["111001000111\n", "2\n3 9\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "贪心", "2016", "Special Judge", "构造", "ICPC", "CERC"], "title": "[CERC2016] 关键的膝盖 Key Knocking", "background": "", "description": "Goran正在从他的膝盖手术中恢复，并正在试验用于存储的智能卡加密密钥。在这个问题中，一个密钥是指一个长度为3n的二进制序列，其中n是正整数。序列的每一位从左往右依次被编号为1到3n。一个密钥的权值是指相邻位不同的位置个数再加上1。比如：“000”的权值是1，“011010100”的权值是7。\n\n\n他发现他可以发送小型脉冲电流来修改智能卡的电路，从而修改密钥。确切地说，他可以不断进行下面的操作：选择任意两个相邻的位，然后同时取反它们。比如他可以通过一次操作把“000”修改为“110”。\n\n\n给定一个长度为3n的密钥，请操作不超过n次，将其修改为一个权值不少于2n的密钥。你可以认为合法解必然存在。\n", "inputFormat": "包含一行一个01序列，表示初始密钥，保证长度一定为3n，且1<=n<=100000。\n", "outputFormat": "第一行包含一个整数m，表示操作的次数，你需要保证0<=m<=n。\n\n第二行包含m个正整数a\\_1,a\\_2,...,a\\_m(1<=a\\_i<n)，依次表示每次翻转第a\\_i和第(a\\_i)+1位。\n\n如果初始密钥的权值已经不小于2n，你可以仅输出一行一个整数0。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[CERC2016] Key Knocking", "background": "", "description": "Goran is recovering from knee surgery and is experimenting with smart card encryption keys for storage. In this problem, a key is a binary sequence of length $3n$, where $n$ is a positive integer. The bits of the sequence are numbered from left to right as $1$ to $3n$. The weight of a key is defined as the number of positions where adjacent bits differ, plus $1$. For example, the weight of \"000\" is $1$, and the weight of \"011010100\" is $7$.\n\nHe finds that he can send small current pulses to modify the circuits of the smart card, thereby modifying the key. Specifically, he can repeatedly perform the following operation: choose any two adjacent bits and flip them both. For example, he can change \"000\" to \"110\" in one operation.\n\nGiven a key of length $3n$, perform at most $n$ operations to transform it into a key with weight at least $2n$. You may assume that a valid solution always exists.", "inputFormat": "One line containing a binary string representing the initial key. Its length is exactly $3n$, where $1 \\le n \\le 100000$.", "outputFormat": "The first line contains an integer $m$ denoting the number of operations, with $0 \\le m \\le n$.\n\nThe second line contains $m$ positive integers $a_1, a_2, \\ldots, a_m$ ($1 \\le a_i < 3n$), in order indicating that in the $i$-th operation you flip bits at positions $a_i$ and $a_i + 1$.\n\nIf the initial key already has weight at least $2n$, you may output a single line containing the integer $0$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC2016] 关键的膝盖 Key Knocking", "background": "", "description": "Goran正在从他的膝盖手术中恢复，并正在试验用于存储的智能卡加密密钥。在这个问题中，一个密钥是指一个长度为3n的二进制序列，其中n是正整数。序列的每一位从左往右依次被编号为1到3n。一个密钥的权值是指相邻位不同的位置个数再加上1。比如：“000”的权值是1，“011010100”的权值是7。\n\n\n他发现他可以发送小型脉冲电流来修改智能卡的电路，从而修改密钥。确切地说，他可以不断进行下面的操作：选择任意两个相邻的位，然后同时取反它们。比如他可以通过一次操作把“000”修改为“110”。\n\n\n给定一个长度为3n的密钥，请操作不超过n次，将其修改为一个权值不少于2n的密钥。你可以认为合法解必然存在。\n", "inputFormat": "包含一行一个01序列，表示初始密钥，保证长度一定为3n，且1<=n<=100000。\n", "outputFormat": "第一行包含一个整数m，表示操作的次数，你需要保证0<=m<=n。\n\n第二行包含m个正整数a\\_1,a\\_2,...,a\\_m(1<=a\\_i<n)，依次表示每次翻转第a\\_i和第(a\\_i)+1位。\n\n如果初始密钥的权值已经不小于2n，你可以仅输出一行一个整数0。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3678", "type": "P", "difficulty": 4, "samples": [["11 16\n################\n#....#++++#+...#\n#....#++.+#+...#\n#....#.++.#++.+#\n#....#....#++++#\n################\n#....#.+..#++++#\n#..++#.+..#++.+#\n#+...#....#.++.#\n#+...#..++#....#\n################", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2016", "哈希 hashing", "ICPC", "CERC"], "title": "[CERC2016] 外观分析 Appearance Analysis", "background": "", "description": "你在萨格勒布拍摄了一张电气工程与计算机“C”楼的照片，它的尺寸相同的窗户整齐地排列在行列上。一些窗户上画着美妙的图案，你现在正在尝试分析有多少本质不同的创意画。\n\n\n我们用一个r行c列的矩形格子图来描述一张照片。每个窗户都占据了一个矩形区域，并且所有窗户都有着相同的尺寸。一个窗户里的每个格子要么是空白的（用“.”表示），要么是被画过的（用“+”表示）。两个窗户的图案被认为是相同的，当且仅当其中有一个窗户旋转90度、180度、270度或360度后，放在另一个窗户上会完全匹配（包括边框）。当比较图案时，我们不允许翻转窗户。\n\n\n所有窗户都规则地分布在行列中，窗户之间的边框用一格“#”字符表示。确切地说，在上下相邻的两个窗户之间，有恰好一行“#”字符，同时在第一行窗户之上或者最后一行窗户之下，也有恰好一行“#”字符。同理，在左右相邻的两个窗户之间，有恰好一列“#”字符，同时在第一列窗户之左或者最后一列窗户之右，也有恰好一列“#”字符。窗户的行数与列数是任意的，窗户的长宽也是任意的，不一定是正方形。但是，每个窗户至少占据一个格子，而且所有窗户的尺寸都是相同的。\n\n\n请统计有多少本质不同的创意画。\n", "inputFormat": "第一行包含两个正整数r,c(3<=r,c<=111)，分别表示照片的行数和列数。\n\n接下来r行，每行c个字符，分别表示照片的每一行。\n", "outputFormat": "输出一行一个整数，即本质不同的创意画的数量。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[CERC2016] Appearance Analysis", "background": "", "description": "You took a photo in Zagreb of the \"C\" building of Electrical Engineering and Computing, where same-sized windows are neatly arranged in rows and columns. Some windows contain beautiful designs, and you are trying to analyze how many essentially different creative drawings there are.\n\nWe describe a photo using a rectangular grid with $r$ rows and $c$ columns. Each window occupies a rectangular region, and all windows have the same dimensions. In a window, each cell is either blank (denoted by \".\") or painted (denoted by \"+\"). Two windows are considered to have the same design if and only if, after rotating one window by $90^\\circ$, $180^\\circ$, $270^\\circ$, or $360^\\circ$, it matches the other exactly (including borders). Flipping windows is not allowed when comparing designs.\n\nAll windows are regularly placed in rows and columns, and the borders between windows are represented by the character \"#\". Specifically, between two vertically adjacent windows there is exactly one row of \"#\" characters, and there is also exactly one row of \"#\" characters above the first row of windows and below the last row of windows. Similarly, between two horizontally adjacent windows there is exactly one column of \"#\" characters, and there is also exactly one column of \"#\" characters to the left of the first column of windows and to the right of the last column of windows. The numbers of window rows and window columns are arbitrary, and the window width and height are arbitrary; windows are not necessarily square. However, each window occupies at least one cell, and all windows have the same size.\n\nPlease count how many essentially different creative drawings there are.", "inputFormat": "The first line contains two positive integers $r, c$ ($3 \\le r, c \\le 111$), the numbers of rows and columns of the photo.\n\nEach of the next $r$ lines contains $c$ characters, describing the photo.", "outputFormat": "Output a single integer, the number of essentially different creative drawings.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC2016] 外观分析 Appearance Analysis", "background": "", "description": "你在萨格勒布拍摄了一张电气工程与计算机“C”楼的照片，它的尺寸相同的窗户整齐地排列在行列上。一些窗户上画着美妙的图案，你现在正在尝试分析有多少本质不同的创意画。\n\n\n我们用一个r行c列的矩形格子图来描述一张照片。每个窗户都占据了一个矩形区域，并且所有窗户都有着相同的尺寸。一个窗户里的每个格子要么是空白的（用“.”表示），要么是被画过的（用“+”表示）。两个窗户的图案被认为是相同的，当且仅当其中有一个窗户旋转90度、180度、270度或360度后，放在另一个窗户上会完全匹配（包括边框）。当比较图案时，我们不允许翻转窗户。\n\n\n所有窗户都规则地分布在行列中，窗户之间的边框用一格“#”字符表示。确切地说，在上下相邻的两个窗户之间，有恰好一行“#”字符，同时在第一行窗户之上或者最后一行窗户之下，也有恰好一行“#”字符。同理，在左右相邻的两个窗户之间，有恰好一列“#”字符，同时在第一列窗户之左或者最后一列窗户之右，也有恰好一列“#”字符。窗户的行数与列数是任意的，窗户的长宽也是任意的，不一定是正方形。但是，每个窗户至少占据一个格子，而且所有窗户的尺寸都是相同的。\n\n\n请统计有多少本质不同的创意画。\n", "inputFormat": "第一行包含两个正整数r,c(3<=r,c<=111)，分别表示照片的行数和列数。\n\n接下来r行，每行c个字符，分别表示照片的每一行。\n", "outputFormat": "输出一行一个整数，即本质不同的创意画的数量。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3679", "type": "P", "difficulty": 6, "samples": [["3 3\n010\n111\n010\n1 2 3\n8 5 13\n21\n", "3\n"], ["3 2\n01\n11\n10\n1 2 3\n4 5\n8\n", "13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "ICPC", "CERC"], "title": "[CERC2016] 二分毯 Bipartite Blanket", "background": "", "description": "在二分图中，所有点被划分成了两个不相交的集合 $A$ 和 $B$，每条边都恰好连接着某个 $A$ 和某个 $B$。一个匹配是一个边集，满足没有任何两条边有相同的端点。我们称一个匹配 $M$ 覆盖了点集 $V$ 当且仅当 $V$ 中的每个点都是 $M$ 中至少一条边的端点。\n\n\n给定一个二分图，每个点有一个正整数权值。定义一个点集的权值为其中所有点的权值之和。\n\n\n给定一个参数 $t$，请统计有多少点集 $V$，满足 $V$ 的权值不小于 $t$，且 $V$ 被至少一个匹配 $M$ 覆盖。\n", "inputFormat": "第一行包含两个正整数 $n,m$，分别表示 $A$ 集合的点数和 $B$ 集合的点数。\n\n接下来 $n$ 行，每行 $m$ 个 01 字符，其中第 $i$ 行第 $j$ 列为 $1$ 表示 $A_i$ 和 $B_j$ 之间有一条边。\n\n接下来一行包含 $n$ 个正整数 $v_1,v_2,\\cdots,v_n$，分别表示 $A$ 中每个点的权值。\n\n接下来一行包含 $m$ 个正整数 $w_1,w_2,\\cdots,w_m$，分别表示 $B$ 中每个点的权值。\n\n最后一行包含一个正整数 $t$，表示参数 $t$。\n", "outputFormat": "输出一行一个整数，即满足条件的点集个数。\n", "hint": "$1\\leq n,m\\leq 20$，$1\\leq v_i,w_i\\leq 10^7$，$1\\leq t\\leq 4\\times 10^8$。", "locale": "zh-CN", "translations": {"en": {"title": "[CERC2016] Bipartite Blanket", "background": "", "description": "In a bipartite graph, all vertices are split into two disjoint sets $A$ and $B$, and every edge connects some vertex in $A$ to some vertex in $B$. A matching is a set of edges such that no two edges share an endpoint. We say a matching $M$ covers a vertex set $V$ if and only if every vertex in $V$ is an endpoint of at least one edge in $M$.\n\nGiven a bipartite graph where each vertex has a positive integer weight, define the weight of a vertex set as the sum of the weights of its vertices.\n\nGiven a parameter $t$, count how many vertex sets $V$ satisfy that the weight of $V$ is at least $t$, and $V$ is covered by at least one matching $M$.", "inputFormat": "The first line contains two positive integers $n, m$, denoting the number of vertices in set $A$ and set $B$, respectively.\n\nThe next $n$ lines each contain $m$ binary characters '0' or '1'. In the $i$-th row and the $j$-th column, a $1$ indicates there is an edge between $A_i$ and $B_j$.\n\nThe next line contains $n$ positive integers $v_1, v_2, \\cdots, v_n$, denoting the weight of each vertex in $A$.\n\nThe next line contains $m$ positive integers $w_1, w_2, \\cdots, w_m$, denoting the weight of each vertex in $B$.\n\nThe last line contains a positive integer $t$, representing the parameter $t$.", "outputFormat": "Output a single integer on one line, the number of vertex sets that satisfy the condition.", "hint": "$1 \\leq n, m \\leq 20$, $1 \\leq v_i, w_i \\leq 10^7$, $1 \\leq t \\leq 4 \\times 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC2016] 二分毯 Bipartite Blanket", "background": "", "description": "在二分图中，所有点被划分成了两个不相交的集合 $A$ 和 $B$，每条边都恰好连接着某个 $A$ 和某个 $B$。一个匹配是一个边集，满足没有任何两条边有相同的端点。我们称一个匹配 $M$ 覆盖了点集 $V$ 当且仅当 $V$ 中的每个点都是 $M$ 中至少一条边的端点。\n\n\n给定一个二分图，每个点有一个正整数权值。定义一个点集的权值为其中所有点的权值之和。\n\n\n给定一个参数 $t$，请统计有多少点集 $V$，满足 $V$ 的权值不小于 $t$，且 $V$ 被至少一个匹配 $M$ 覆盖。\n", "inputFormat": "第一行包含两个正整数 $n,m$，分别表示 $A$ 集合的点数和 $B$ 集合的点数。\n\n接下来 $n$ 行，每行 $m$ 个 01 字符，其中第 $i$ 行第 $j$ 列为 $1$ 表示 $A_i$ 和 $B_j$ 之间有一条边。\n\n接下来一行包含 $n$ 个正整数 $v_1,v_2,\\cdots,v_n$，分别表示 $A$ 中每个点的权值。\n\n接下来一行包含 $m$ 个正整数 $w_1,w_2,\\cdots,w_m$，分别表示 $B$ 中每个点的权值。\n\n最后一行包含一个正整数 $t$，表示参数 $t$。\n", "outputFormat": "输出一行一个整数，即满足条件的点集个数。\n", "hint": "$1\\leq n,m\\leq 20$，$1\\leq v_i,w_i\\leq 10^7$，$1\\leq t\\leq 4\\times 10^8$。", "locale": "zh-CN"}}}
{"pid": "P3680", "type": "P", "difficulty": 6, "samples": [["4\nTSTC", "9.088434417\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "数学", "计算几何", "2016", "Special Judge", "凸包", "ICPC", "CERC"], "title": "[CERC2016] 凸轮廓线 Convex Contour", "background": "", "description": "一些几何图形整齐地在一个网格图上从左往右排成一列。它们占据了连续的一段横行，每个位置恰好一个几何图形。每个图形是以下的三种之一：\n\n\n1. 一个恰好充满单个格子的正方形。\n\n\n2. 一个内切于单个格子的圆。\n\n\n3. 一个底边与格子重合的等边三角形。\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4685.png) \n\n已知每个格子的边长都为 $1$，请求出这些几何图形的凸包的周长。", "inputFormat": "第一行包含一个正整数 $n$，表示几何图形的个数。\n\n第二行包含 $n$ 个字符，从左往右依次表示每个图形，`S` 表示正方形，`C` 表示圆形，`T` 表示等边三角形。\n", "outputFormat": "输出一行一个实数，即凸包的周长。与答案的绝对或相对误差不超过 $10^{-6}$ 时被认为是正确的。", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 20$。", "locale": "zh-CN", "translations": {"en": {"title": "[CERC2016] Convex Contour", "background": "", "description": "Some geometric figures are arranged neatly from left to right in a single row on a square grid. They occupy a consecutive segment of one row, with exactly one figure in each cell. Each figure is one of the following three:\n\n1. A square that exactly fills a single cell.\n2. A circle inscribed in a single cell.\n3. An equilateral triangle whose base coincides with the bottom edge of the cell.\n\n![](https://cdn.luogu.com.cn/upload/pic/4685.png)\n\nThe side length of each cell is $1$. Compute the perimeter of the convex hull of these figures.", "inputFormat": "The first line contains a positive integer $n$, the number of figures.\n\nThe second line contains $n$ characters, describing each figure from left to right: `S` denotes a square, `C` denotes a circle, and `T` denotes an equilateral triangle.", "outputFormat": "Output a single real number, the perimeter of the convex hull. Your answer will be accepted if the absolute or relative error does not exceed $10^{-6}$.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC2016] 凸轮廓线 Convex Contour", "background": "", "description": "一些几何图形整齐地在一个网格图上从左往右排成一列。它们占据了连续的一段横行，每个位置恰好一个几何图形。每个图形是以下的三种之一：\n\n\n1. 一个恰好充满单个格子的正方形。\n\n\n2. 一个内切于单个格子的圆。\n\n\n3. 一个底边与格子重合的等边三角形。\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4685.png) \n\n已知每个格子的边长都为 $1$，请求出这些几何图形的凸包的周长。", "inputFormat": "第一行包含一个正整数 $n$，表示几何图形的个数。\n\n第二行包含 $n$ 个字符，从左往右依次表示每个图形，`S` 表示正方形，`C` 表示圆形，`T` 表示等边三角形。\n", "outputFormat": "输出一行一个实数，即凸包的周长。与答案的绝对或相对误差不超过 $10^{-6}$ 时被认为是正确的。", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 20$。", "locale": "zh-CN"}}}
{"pid": "P3681", "type": "P", "difficulty": 6, "samples": [["6\n1 6 5 4 3 2", "1 1 D 6\n2 1 D 6\n3 1 D 6\n4 1 D 6\n5 1 D 6\n6 1 R 6\n6 2 R 6\n6 3 R 6\n6 4 R 6\n6 5 R 5\n6 5 R 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "Special Judge", "ICPC", "CERC"], "title": "[CERC2016] 舞动的盘子 Dancing Disks", "background": null, "description": "Luka 非常擅长解决汉诺塔问题，他发明了一种类似汉诺塔的使用盘子和柱子的游戏。这个游戏有 $n$ 个不同大小的盘子以及 $36$ 根柱子。盘子按照大小从小到大依次被编号为 $1$ 到 $n$。柱子形成了 $6$ 行 $6$ 列的矩阵，从上到下每行依次被编号为 $1$ 到 $6$，从左到右每列依次被编号为1到 $6$。\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4686.png) \n\n游戏一开始，$n$ 个盘子都被堆叠在左上角坐标为 $(1,1)$ 的柱子上。对于每一次操作，玩家可以选择一个柱子，取出最顶上若干个盘子，然后选择右边或者下面的某个柱子，将取出的盘子全部堆叠在其顶上（不会翻转顺序）。游戏的目标是把所有盘子都移动到 $(6,6)$ ，且自底向上大小依次递减。\n\n\n给定游戏的初始局面，请找到任意一组玩通关的方法。数据保证解必定存在。", "inputFormat": "第一行包含一个正整数 $n(1\\le n\\le 40000)$，表示盘子的数目。\n\n第二行包含 $n$ 个正整数 $d_1,d_2,\\cdots,d_n(1\\le d_i\\le n)$，自底向上表示 $(1,1)$ 柱子上每个盘子的编号。\n\n输入数据保证不存在两个盘子的编号相同。", "outputFormat": "输出 $m$ 行，$m$ 表示你的解中游戏操作的次数。\n\n其中第 $i$ 行包含 $4$ 个参数 $r_i,c_i,p_i,n_i$，表示第 $i$ 步操作，即你选择了 $(r_i,c_i)$ 最上方的 $n_i(n_i\\ge1)$ 个盘子，然后往 $p_i$ 方向移动。\n\n如果向右移动，那么 $p_i$ 为 `R`；如果向下移动，那么 $p_i$ 为 `D`。\n\n若有多组方案，输出任意一组。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[CERC2016] Dancing Disks", "background": "", "description": "Luka is very good at solving the Tower of Hanoi problem, and he invented a similar game that uses disks and pegs. The game has $n$ disks of different sizes and $36$ pegs. The disks are numbered from $1$ to $n$ from smallest to largest. The pegs form a $6 \\times 6$ grid: rows are numbered $1$ to $6$ from top to bottom, and columns are numbered $1$ to $6$ from left to right.\n\n![](https://cdn.luogu.com.cn/upload/pic/4686.png)\n\nAt the beginning, all $n$ disks are stacked on the peg at $(1,1)$. In each move, you may choose a peg, take the top several disks, then choose some peg to its right in the same row or some peg below it in the same column, and place all the taken disks on top of that peg (their order is preserved; they are not reversed). The goal is to move all disks to $(6,6)$, with strictly decreasing sizes from bottom to top.\n\nGiven the initial configuration, find any sequence of moves that completes the game. It is guaranteed that a solution exists.", "inputFormat": "The first line contains a positive integer $n$ ($1 \\le n \\le 40000$), the number of disks.\n\nThe second line contains $n$ positive integers $d_1, d_2, \\cdots, d_n$ ($1 \\le d_i \\le n$), listing from bottom to top the labels of the disks on the peg at $(1,1)$.\n\nIt is guaranteed that no two disks have the same label.", "outputFormat": "Output $m$ lines, where $m$ is the number of moves in your solution.\n\nIn the $i$-th line, output $4$ items $r_i, c_i, p_i, n_i$, meaning that in the $i$-th move you choose the top $n_i$ ($n_i \\ge 1$) disks from $(r_i, c_i)$ and move them in direction $p_i$.\n\nIf you move to the right, then $p_i$ is `R`; if you move downward, then $p_i$ is `D`.\n\nIf there are multiple valid solutions, output any one.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC2016] 舞动的盘子 Dancing Disks", "background": null, "description": "Luka 非常擅长解决汉诺塔问题，他发明了一种类似汉诺塔的使用盘子和柱子的游戏。这个游戏有 $n$ 个不同大小的盘子以及 $36$ 根柱子。盘子按照大小从小到大依次被编号为 $1$ 到 $n$。柱子形成了 $6$ 行 $6$ 列的矩阵，从上到下每行依次被编号为 $1$ 到 $6$，从左到右每列依次被编号为1到 $6$。\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4686.png) \n\n游戏一开始，$n$ 个盘子都被堆叠在左上角坐标为 $(1,1)$ 的柱子上。对于每一次操作，玩家可以选择一个柱子，取出最顶上若干个盘子，然后选择右边或者下面的某个柱子，将取出的盘子全部堆叠在其顶上（不会翻转顺序）。游戏的目标是把所有盘子都移动到 $(6,6)$ ，且自底向上大小依次递减。\n\n\n给定游戏的初始局面，请找到任意一组玩通关的方法。数据保证解必定存在。", "inputFormat": "第一行包含一个正整数 $n(1\\le n\\le 40000)$，表示盘子的数目。\n\n第二行包含 $n$ 个正整数 $d_1,d_2,\\cdots,d_n(1\\le d_i\\le n)$，自底向上表示 $(1,1)$ 柱子上每个盘子的编号。\n\n输入数据保证不存在两个盘子的编号相同。", "outputFormat": "输出 $m$ 行，$m$ 表示你的解中游戏操作的次数。\n\n其中第 $i$ 行包含 $4$ 个参数 $r_i,c_i,p_i,n_i$，表示第 $i$ 步操作，即你选择了 $(r_i,c_i)$ 最上方的 $n_i(n_i\\ge1)$ 个盘子，然后往 $p_i$ 方向移动。\n\n如果向右移动，那么 $p_i$ 为 `R`；如果向下移动，那么 $p_i$ 为 `D`。\n\n若有多组方案，输出任意一组。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3682", "type": "P", "difficulty": 5, "samples": [["7\n3 5 4 0 7 0 0\n3 5 0 6 7 0 0\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2016", "ICPC", "CERC"], "title": "[CERC2016] 自由的套娃 Free Figurines", "background": null, "description": "俄罗斯套娃是一些尺寸递增的木制雕像，它们可以嵌套在一起。每个套娃可以放进一个更大的套娃，也可以被放入一个更小的套娃。每个套娃内部最多只能直接嵌套一个套娃，但是那个套娃内部还可以继续嵌套。\n\n\n给定 $n$ 个尺寸互不相同的套娃，按尺寸从小到大依次编号为 $1$ 到 $n$。如果套娃 $a$ 被直接嵌入套娃 $b$，那么我们称 $b$ 是 $a$ 的父亲，如果一个套娃没有父亲，那么我们称它是自由的。一组镶嵌方案可以用每个套娃的父亲来表示。\n\n\n我们可以每步可以做以下两种操作中的任意一种：\n\n\n1. 把一个自由的套娃直接嵌入一个更大的没有被放入东西的套娃。\n\n\n2. 选择一个不自由的套娃，将其从其父亲中取出。\n\n\n给定初始局面，请计算达到目标局面的最小的操作步数。", "inputFormat": "第一行包含一个正整数 $n(1 \\le n \\le 100000)$，表示套娃的个数。\n\n第二行包含 $n$ 个整数 $p_1,p_2,...,p_n(0 \\le p_i \\le n)$，依次表示初始局面中每个套娃的父亲，$0$ 表示自由套娃。\n\n第三行包含 $n$ 个整数 $q_1,q_2,...,q_n(0 \\le q_i \\le n)$，依次表示目标局面中每个套娃的父亲，$0$ 表示自由套娃。\n\n输入数据保证初始局面和目标局面均合法。", "outputFormat": "输出一行一个整数，即最小操作步数。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[CERC2016] Free Figurines", "background": "", "description": "Russian nesting dolls are wooden figurines of strictly increasing sizes that can be nested inside one another. Each figurine can be put into a larger figurine, and can itself contain a smaller figurine. At most one figurine can be directly nested inside any figurine, but that inner figurine can itself contain another, and so on.\n\nGiven $n$ figurines with distinct sizes, they are numbered $1$ to $n$ in increasing order of size. If figurine $a$ is directly nested inside figurine $b$, then we say $b$ is the parent of $a$. If a figurine has no parent, we say it is free. A nesting configuration can be represented by specifying the parent of each figurine.\n\nIn each step, you may perform exactly one of the following two operations:\n\n1. Take a free figurine and directly place it into a larger figurine that currently contains nothing.\n2. Choose a figurine that is not free (i.e., has a parent) and remove it from its parent.\n\nGiven the initial configuration, compute the minimum number of steps to reach the target configuration.", "inputFormat": "The first line contains a positive integer $n(1 \\le n \\le 100000)$, the number of figurines.\n\nThe second line contains $n$ integers $p_1,p_2,...,p_n(0 \\le p_i \\le n)$, giving the parent of each figurine in the initial configuration, where $0$ denotes a free figurine.\n\nThe third line contains $n$ integers $q_1,q_2,...,q_n(0 \\le q_i \\le n)$, giving the parent of each figurine in the target configuration, where $0$ denotes a free figurine.\n\nThe input guarantees that both the initial and the target configurations are valid.", "outputFormat": "Output a single integer, the minimum number of operations.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC2016] 自由的套娃 Free Figurines", "background": null, "description": "俄罗斯套娃是一些尺寸递增的木制雕像，它们可以嵌套在一起。每个套娃可以放进一个更大的套娃，也可以被放入一个更小的套娃。每个套娃内部最多只能直接嵌套一个套娃，但是那个套娃内部还可以继续嵌套。\n\n\n给定 $n$ 个尺寸互不相同的套娃，按尺寸从小到大依次编号为 $1$ 到 $n$。如果套娃 $a$ 被直接嵌入套娃 $b$，那么我们称 $b$ 是 $a$ 的父亲，如果一个套娃没有父亲，那么我们称它是自由的。一组镶嵌方案可以用每个套娃的父亲来表示。\n\n\n我们可以每步可以做以下两种操作中的任意一种：\n\n\n1. 把一个自由的套娃直接嵌入一个更大的没有被放入东西的套娃。\n\n\n2. 选择一个不自由的套娃，将其从其父亲中取出。\n\n\n给定初始局面，请计算达到目标局面的最小的操作步数。", "inputFormat": "第一行包含一个正整数 $n(1 \\le n \\le 100000)$，表示套娃的个数。\n\n第二行包含 $n$ 个整数 $p_1,p_2,...,p_n(0 \\le p_i \\le n)$，依次表示初始局面中每个套娃的父亲，$0$ 表示自由套娃。\n\n第三行包含 $n$ 个整数 $q_1,q_2,...,q_n(0 \\le q_i \\le n)$，依次表示目标局面中每个套娃的父亲，$0$ 表示自由套娃。\n\n输入数据保证初始局面和目标局面均合法。", "outputFormat": "输出一行一个整数，即最小操作步数。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3683", "type": "P", "difficulty": 7, "samples": [["3 8\n1 1\n5 1\n5 4\n3 4\n3 8\n0 8\n0 5\n1 5\n4 2 3 5 7", "32\n30\n26\n24\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "ICPC", "CERC"], "title": "[CERC2016] 地理哈希网格 Geohash Grid", "background": "", "description": "“地理哈希”是一个将二维平面坐标编码为整数的过程，这将为数据库中地理数据的存储和查询带来方便。在这个问题中，一个地图是一个建立在标准二维笛卡尔坐标系上的2^n行2^n列的矩形网格，越往右x坐标越大，越往上y坐标越大。一个地图格子是一个单位正方形，满足其左下角的点的坐标为(x,y)，其中0<=x,y<2^n。\n\n\n在2^n行2^n列的地图上一共有2^(2n)个格子。对于一个格子c，它的地理哈希值h(c)是一个2n位的非负二进制整数。从最高位开始考虑整个地图，然后重复下面两个步骤n次，即可得到c的地理哈希值h(c)：\n\n\n1.把地图分成左右两个面积相等的区域，如果格子c在左半边，那么这一位是0，否则是1。然后将考虑范围缩小到c所在的那半边地图。\n\n\n2.把地图分成上下两个面积相等的区域，如果格子c在下半边，那么这一位是0，否则是1。然后将考虑范围缩小到c所在的那半边地图。\n\n\n一个“地理哈希区间”[a,b]表示所有哈希值在[a,b]之间的格子。通常应用中，我们会用一些地理哈希区间去近似表示地图。给定一个格子集合C，以及一个正整数t，那么C的最优t近似是指使用不超过t个地理哈希区间，覆盖住所有C中的格子（覆盖其它格子是允许的），同时满足覆盖住的区域的面积最小。\n\n\n给定一个地图以及一个格子集合C，C用一个边平行于坐标轴的简单多边形来表示。然后给定q个询问t\\_1,t\\_2,...,t\\_q，对于每个询问t\\_k，你需要求出C的最优t\\_k近似覆盖住的区域的面积。\n", "inputFormat": "第一行包含一个正整数n(1<=n<=30)，表示地图的尺寸的以2为底的对数。\n\n第二行包含一个正整数m(4<=m<=200)，表示多边形顶点的个数。\n\n接下来m行，每行两个整数x\\_i,y\\_i(0<=x\\_i,y\\_i<=2^n)，按逆时针依次表示多边形每个顶点的坐标。\n\n输入数据保证多边形不自交，边平行于坐标轴，且不存在相邻两条边是平行的。\n\n接下来一行包含一个正整数q(1<=q<=100000)，表示询问的个数。\n\n接下来q行，每行一个正整数t\\_1,t\\_2,...,t\\_q(1<=t\\_i<=10^9)，依次表示每个询问。\n", "outputFormat": "输出q行，每行一个正整数，依次回答每个询问。\n", "hint": " ![](https://cdn.luogu.com.cn/upload/pic/4687.png) \n\n区间[3,29]、[33,33]和[36,37]组成最优3近似，其覆盖住的总面积为30。\n", "locale": "zh-CN", "translations": {"en": {"title": "[CERC2016] Geohash Grid", "background": "", "description": "A \"geohash\" encodes 2D planar coordinates into integers, which facilitates storing and querying geographic data in databases. In this problem, a map is a $2^n \\times 2^n$ rectangular grid built on the standard 2D Cartesian coordinate system, where $x$ increases to the right and $y$ increases upward. A map cell is a unit square whose lower-left corner has integer coordinates $(x, y)$, where $0 \\le x, y < 2^n$.\n\nThere are $2^{2n}$ cells on the $2^n \\times 2^n$ map. For a cell $c$, its geohash value $h(c)$ is a non-negative $2n$-bit binary integer. Starting from the most significant bit and considering the entire map, repeat the following two steps $n$ times to obtain $h(c)$:\n\n1. Split the map into left and right regions of equal area. If cell $c$ lies in the left half, this bit is $0$; otherwise it is $1$. Then restrict the scope to the half that contains $c$.\n2. Split the map into bottom and top regions of equal area. If cell $c$ lies in the bottom half, this bit is $0$; otherwise it is $1$. Then restrict the scope to the half that contains $c$.\n\nA \"geohash interval\" $[a, b]$ denotes all cells whose hash values lie in $[a, b]$ (inclusive). In practice, we approximate a set on the map using a few geohash intervals. Given a set of cells $C$ and a positive integer $t$, the optimal $t$-approximation of $C$ is to use at most $t$ geohash intervals to cover all cells in $C$ (covering other cells is allowed) while minimizing the total covered area.\n\nYou are given a map and a cell set $C$, where $C$ is represented by a simple polygon whose edges are parallel to the coordinate axes. Then you are given $q$ queries $t_1, t_2, \\ldots, t_q$. For each query $t_k$, you need to output the area of the optimal $t_k$-approximation that covers $C$.", "inputFormat": "The first line contains a positive integer $n$ $(1 \\le n \\le 30)$, the base-2 logarithm of the map size.\n\nThe second line contains a positive integer $m$ $(4 \\le m \\le 200)$, the number of polygon vertices.\n\nEach of the next $m$ lines contains two integers $x_i, y_i$ $(0 \\le x_i, y_i \\le 2^n)$, giving the coordinates of the polygon’s vertices in counterclockwise order.\n\nThe input guarantees that the polygon is simple, its edges are parallel to the coordinate axes, and no two consecutive edges are parallel.\n\nThe next line contains a positive integer $q$ $(1 \\le q \\le 100000)$, the number of queries.\n\nEach of the next $q$ lines contains a positive integer $t_i$ $(1 \\le t_i \\le 10^9)$, the parameter of a query.", "outputFormat": "Output $q$ lines. For each query, output a single positive integer: the answer to that query.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/4687.png)\n\nThe intervals $[3, 29]$, $[33, 33]$, and $[36, 37]$ form an optimal $3$-approximation, whose total covered area is $30$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC2016] 地理哈希网格 Geohash Grid", "background": "", "description": "“地理哈希”是一个将二维平面坐标编码为整数的过程，这将为数据库中地理数据的存储和查询带来方便。在这个问题中，一个地图是一个建立在标准二维笛卡尔坐标系上的2^n行2^n列的矩形网格，越往右x坐标越大，越往上y坐标越大。一个地图格子是一个单位正方形，满足其左下角的点的坐标为(x,y)，其中0<=x,y<2^n。\n\n\n在2^n行2^n列的地图上一共有2^(2n)个格子。对于一个格子c，它的地理哈希值h(c)是一个2n位的非负二进制整数。从最高位开始考虑整个地图，然后重复下面两个步骤n次，即可得到c的地理哈希值h(c)：\n\n\n1.把地图分成左右两个面积相等的区域，如果格子c在左半边，那么这一位是0，否则是1。然后将考虑范围缩小到c所在的那半边地图。\n\n\n2.把地图分成上下两个面积相等的区域，如果格子c在下半边，那么这一位是0，否则是1。然后将考虑范围缩小到c所在的那半边地图。\n\n\n一个“地理哈希区间”[a,b]表示所有哈希值在[a,b]之间的格子。通常应用中，我们会用一些地理哈希区间去近似表示地图。给定一个格子集合C，以及一个正整数t，那么C的最优t近似是指使用不超过t个地理哈希区间，覆盖住所有C中的格子（覆盖其它格子是允许的），同时满足覆盖住的区域的面积最小。\n\n\n给定一个地图以及一个格子集合C，C用一个边平行于坐标轴的简单多边形来表示。然后给定q个询问t\\_1,t\\_2,...,t\\_q，对于每个询问t\\_k，你需要求出C的最优t\\_k近似覆盖住的区域的面积。\n", "inputFormat": "第一行包含一个正整数n(1<=n<=30)，表示地图的尺寸的以2为底的对数。\n\n第二行包含一个正整数m(4<=m<=200)，表示多边形顶点的个数。\n\n接下来m行，每行两个整数x\\_i,y\\_i(0<=x\\_i,y\\_i<=2^n)，按逆时针依次表示多边形每个顶点的坐标。\n\n输入数据保证多边形不自交，边平行于坐标轴，且不存在相邻两条边是平行的。\n\n接下来一行包含一个正整数q(1<=q<=100000)，表示询问的个数。\n\n接下来q行，每行一个正整数t\\_1,t\\_2,...,t\\_q(1<=t\\_i<=10^9)，依次表示每个询问。\n", "outputFormat": "输出q行，每行一个正整数，依次回答每个询问。\n", "hint": " ![](https://cdn.luogu.com.cn/upload/pic/4687.png) \n\n区间[3,29]、[33,33]和[36,37]组成最优3近似，其覆盖住的总面积为30。\n", "locale": "zh-CN"}}}
{"pid": "P3684", "type": "P", "difficulty": 6, "samples": [["7\n.....#.\n...#.#.\n....#..\n....###\n....#..\n#......\n.......\n5\n2 5 5 2\n2 5 3 6\n2 2 6 3\n2 2 6 6\n1 1 7 7", "1\n0\n3\n1\n1"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2016", "Kruskal 重构树", "广度优先搜索 BFS", "生成树", "树链剖分", "ICPC", "CERC"], "title": "[CERC2016] 机棚障碍 Hangar Hurdles", "background": "", "description": "你正在评估一些关于一个巨型飞机仓库的建设计划。飞机仓库的地面可以表示为 $n$ 行 $n$ 列的网格图，其中每个格子要么是空的，要么有障碍物。行从上到下依次被编号为 $1$ 到 $n$，列从左到右依次被编号为 $1$ 到 $n$。\n\n存放飞机零件的大型集装箱能在飞机仓库的地面上自由移动是很重要的。我们可以将每个集装箱看作一个以某个格子为中心的边平行于坐标轴的正方形。对于一个奇数 $k$，一个尺寸为 $k$ 的集装箱是一个包含 $k$ 行 $k$ 列的正方形。一个集装箱的坐标为其中心格子的坐标。集装箱可以向上下左右移动，但不能碰到障碍物，且不能移出仓库的边界。\n\n给定 $q$ 对格子 $A_k$ 和 $B_k$，对于每对格子，请找到能从 $A_k$ 移动到 $B_k$ 的集装箱的最大尺寸，注意这个尺寸也要是一个奇数。", "inputFormat": "第一行包含一个正整数 $n$（$2\\le n \\le 1000$），表示仓库的尺寸。\n\n接下来 $n$ 行，每行 $n$ 个字符，描述整个仓库，其中 `.` 表示空格子，`#` 表示障碍物。\n\n接下来一行包含一个正整数 $q$（$1\\le q\\le 300000$），表示询问的个数。\n\n接下来 $q$ 行，每行四个正整数 $A_x,A_y,B_x,B_y$（$1\\le A_x,A_y,B_x,B_y\\le n$），分别表示 $A$ 和 $B$ 的坐标。\n\n输入数据保证 $A$ 和 $B$ 是不同的空格子。", "outputFormat": "输出 $q$ 行，每行一个整数，对于每个询问输出最大尺寸，如果不存在解，那么输出 $0$。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[CERC2016] Hangar Hurdles", "background": "", "description": "You are evaluating construction plans for a giant airplane hangar. The hangar floor can be represented as an $n \\times n$ grid, where each cell is either empty or contains an obstacle. Rows are numbered from $1$ to $n$ from top to bottom, and columns are numbered from $1$ to $n$ from left to right.\n\nIt is important that large containers for storing airplane parts can move freely on the floor. Each container can be seen as an axis-aligned square centered at some cell. For an odd integer $k$, a container of size $k$ is a square covering $k$ rows and $k$ columns. The coordinate of a container is the coordinate of its center cell. A container can move up, down, left, or right, but it cannot touch obstacles and cannot move outside the hangar boundary.\n\nGiven $q$ pairs of cells $A_k$ and $B_k$, for each pair, find the maximum size (also an odd integer) of a container that can move from $A_k$ to $B_k$.", "inputFormat": "The first line contains a positive integer $n$ ($2 \\le n \\le 1000$), the size of the hangar.\n\nThe next $n$ lines each contain $n$ characters describing the hangar, where `.` denotes an empty cell and `#` denotes an obstacle.\n\nThe next line contains a positive integer $q$ ($1 \\le q \\le 300000$), the number of queries.\n\nEach of the next $q$ lines contains four positive integers $A_x, A_y, B_x, B_y$ ($1 \\le A_x, A_y, B_x, B_y \\le n$), the coordinates of $A$ and $B$.\n\nIt is guaranteed that $A$ and $B$ are distinct empty cells.", "outputFormat": "Output $q$ lines, each with one integer. For each query, output the maximum size. If no solution exists, output $0$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC2016] 机棚障碍 Hangar Hurdles", "background": "", "description": "你正在评估一些关于一个巨型飞机仓库的建设计划。飞机仓库的地面可以表示为 $n$ 行 $n$ 列的网格图，其中每个格子要么是空的，要么有障碍物。行从上到下依次被编号为 $1$ 到 $n$，列从左到右依次被编号为 $1$ 到 $n$。\n\n存放飞机零件的大型集装箱能在飞机仓库的地面上自由移动是很重要的。我们可以将每个集装箱看作一个以某个格子为中心的边平行于坐标轴的正方形。对于一个奇数 $k$，一个尺寸为 $k$ 的集装箱是一个包含 $k$ 行 $k$ 列的正方形。一个集装箱的坐标为其中心格子的坐标。集装箱可以向上下左右移动，但不能碰到障碍物，且不能移出仓库的边界。\n\n给定 $q$ 对格子 $A_k$ 和 $B_k$，对于每对格子，请找到能从 $A_k$ 移动到 $B_k$ 的集装箱的最大尺寸，注意这个尺寸也要是一个奇数。", "inputFormat": "第一行包含一个正整数 $n$（$2\\le n \\le 1000$），表示仓库的尺寸。\n\n接下来 $n$ 行，每行 $n$ 个字符，描述整个仓库，其中 `.` 表示空格子，`#` 表示障碍物。\n\n接下来一行包含一个正整数 $q$（$1\\le q\\le 300000$），表示询问的个数。\n\n接下来 $q$ 行，每行四个正整数 $A_x,A_y,B_x,B_y$（$1\\le A_x,A_y,B_x,B_y\\le n$），分别表示 $A$ 和 $B$ 的坐标。\n\n输入数据保证 $A$ 和 $B$ 是不同的空格子。", "outputFormat": "输出 $q$ 行，每行一个整数，对于每个询问输出最大尺寸，如果不存在解，那么输出 $0$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3685", "type": "P", "difficulty": 7, "samples": [["5\n1 2 0\n3 4 0\n1 4 3 0\n3 1 4 2 0\n1 2 4 3 0", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2016", "ICPC", "CERC"], "title": "[CERC2016] 不可见的整数 Invisible Integers", "background": "", "description": "《隐形的整数》是一个简单的猜数游戏。在这个游戏中，给定n个提示，玩家将尝试去猜一个仅包含自然数1到9的数字序列，满足所有n个提示。每个提示是一个包含若干互不相同的1到9之间的整数序列，它是这样生成的：\n\n\n1.随机选择一个序列中的位置作为起点。\n\n\n2.随机选择任意一个方向，左或者右。\n\n\n3.从起点开始沿着选定的方向走，遍历完这个方向的每个数字，将每个数字第一次出现的顺序记录下来。\n\n\n请找到长度最短的满足所有n个提示的序列。\n", "inputFormat": "第一行包含一个正整数n(1<=n<=10)，表示提示的个数。\n\n接下来n行，每行若干个互不相同的1到9之间的整数，依次表示每个提示，每一行以0为终止。\n", "outputFormat": "输出一行一个整数，即最短长度，若无解则输出-1。\n", "hint": "一个可行的序列是(1,2,1,4,1,3,4)。\n\n对于提示序列(1,2)，可以选择位置3，然后往左走。\n\n对于提示序列(3,4)，可以选择位置6，然后往右走。\n\n对于提示序列(1,4,3)，可以选择位置3，然后往右走。\n\n对于提示序列(3,1,4,2)，可以选择位置6，然后往左走。\n\n对于提示序列(1,2,4,3)，可以选择位置1，然后往右走。\n", "locale": "zh-CN", "translations": {"en": {"title": "[CERC2016] Invisible Integers", "background": "", "description": "“Invisible Integers” is a simple number-guessing game. In this game, given $n$ hints, the player tries to guess a sequence consisting only of the digits 1 to 9, such that all $n$ hints are satisfied. Each hint is a sequence of pairwise distinct integers between 1 and 9, generated as follows:\n\n1. Randomly choose a position in the sequence as the starting point.\n2. Randomly choose a direction, either left or right.\n3. Starting from the chosen position and moving along the chosen direction to the end, record, in order, the first time each digit is seen.\n\nFind a sequence of minimum length that satisfies all $n$ hints.", "inputFormat": "The first line contains a positive integer $n$ ($1 \\le n \\le 10$), the number of hints.\n\nEach of the next $n$ lines contains a hint: several pairwise distinct integers between 1 and 9, terminated by a 0.", "outputFormat": "Output a single integer: the minimum possible length. If there is no solution, output $-1$.", "hint": "One feasible sequence is (1, 2, 1, 4, 1, 3, 4).\n\nFor the hint (1, 2), you can choose position 3 and then walk to the left.\n\nFor the hint (3, 4), you can choose position 6 and then walk to the right.\n\nFor the hint (1, 4, 3), you can choose position 3 and then walk to the right.\n\nFor the hint (3, 1, 4, 2), you can choose position 6 and then walk to the left.\n\nFor the hint (1, 2, 4, 3), you can choose position 1 and then walk to the right.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC2016] 不可见的整数 Invisible Integers", "background": "", "description": "《隐形的整数》是一个简单的猜数游戏。在这个游戏中，给定n个提示，玩家将尝试去猜一个仅包含自然数1到9的数字序列，满足所有n个提示。每个提示是一个包含若干互不相同的1到9之间的整数序列，它是这样生成的：\n\n\n1.随机选择一个序列中的位置作为起点。\n\n\n2.随机选择任意一个方向，左或者右。\n\n\n3.从起点开始沿着选定的方向走，遍历完这个方向的每个数字，将每个数字第一次出现的顺序记录下来。\n\n\n请找到长度最短的满足所有n个提示的序列。\n", "inputFormat": "第一行包含一个正整数n(1<=n<=10)，表示提示的个数。\n\n接下来n行，每行若干个互不相同的1到9之间的整数，依次表示每个提示，每一行以0为终止。\n", "outputFormat": "输出一行一个整数，即最短长度，若无解则输出-1。\n", "hint": "一个可行的序列是(1,2,1,4,1,3,4)。\n\n对于提示序列(1,2)，可以选择位置3，然后往左走。\n\n对于提示序列(3,4)，可以选择位置6，然后往右走。\n\n对于提示序列(1,4,3)，可以选择位置3，然后往右走。\n\n对于提示序列(3,1,4,2)，可以选择位置6，然后往左走。\n\n对于提示序列(1,2,4,3)，可以选择位置1，然后往右走。\n", "locale": "zh-CN"}}}
{"pid": "P3686", "type": "P", "difficulty": 5, "samples": [["2 5\n1 2 1 2 1\n4\n1 2 R 6\n1 2 O 3\n2 1 O 3\n1 2 R 5", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "贪心", "2016", "哈希 hashing", "ICPC", "CERC"], "title": "[CERC2016] 爵士之旅 Jazz Journey", "background": "", "description": "Ivan 正在为他的爵士乐队计划一场规模盛大的欧洲巡演。在欧洲一共有 $n$ 个城市，编号依次为 $1 \\sim n$。Ivan 计划举办 $d$ 场演出，分别在城市 $a_1$，$a_2$，$\\dots$，$a_d$，并且严格遵循这个顺序，而且不会在同一个城市连续巡演两次（即 $a_i \\ne a_{i+1}$），但在整个过程中，他可能在一个城市巡演多次。最终，他一定会回到开始的城市进行巡演（即 $a_1 = a_d$）。\n\n\nIvan 每次总是选择搭乘一趟从 $a_i$ 到 $a_{i+1}$ 的直达航班。然而，他希望变得聪明一些，尽量节省机票的开支。你也知道，机票的价格取决于供给和需求，比如一张单程票可能会比相同目的地的双程票还要贵。\n\n\n一共有两种可以购买的机票：\n\n\n1.从 $a$ 到 $b$ 的单程票，每张只能从 $a$ 飞到 $b$ 一次，但不能从 $b$ 飞到 $a$。\n\n\n2.从a到b的双程票，只需购买一张，就能从 $a$ 飞到 $b$ 一次，然后从 $b$ 飞回 $a$ 一次，但先从 $b$ 飞回 $a$ 是不允许的。当然，你也可以选择从 $a$ 飞到 $b$ 之后就再也不返回 $a$。\n\n\n给定可以购买的机票集合，每种机票都是无限量供应的。请帮助 Ivan 找到一种最省钱的方案。你可以认为合法方案必然存在。", "inputFormat": "第一行包含两个正整数 $n$,$d$($2 \\le n,d \\le 3 \\times 10^5$)，分别表示城市的个数和巡演的次数。\n\n第二行包含 $d$ 个正整数 $a_1,a_2,\\dots,a_d$($1 \\le a_i \\le n,a_i \\ne a_{i+1},a_1 = a_d$)，依次表示巡演计划中每一场所在的城市。\n\n接下来一行包含一个正整数 $m$($3 \\le m \\le 3 \\times 10^5$)，表示机票的种类数。\n\n接下来 $m$ 行，每行首先是两个正整数 $s_i,d_i$($1 \\le s_i,d_i \\le n,s_i \\ne d_i$)，分别表示起点与终点；接下来一个字符 $t_i$，表示机票的类型，其中“O”表示单程票，“R”表示双程票；最后是一个正整数 $p_i$($1 \\le p_i \\le 10^9$)，表示票价。", "outputFormat": "输出一行一个整数，即完成巡演所需支付的最小机票总费用。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[CERC2016] Jazz Journey", "background": "", "description": "Ivan is planning a grand European tour for his jazz band. There are $n$ cities in Europe, labeled $1 \\sim n$. Ivan plans to hold $d$ concerts in cities $a_1, a_2, \\dots, a_d$ in this exact order, and he will never perform in the same city twice in a row (that is, $a_i \\ne a_{i+1}$). However, over the whole tour, he may visit the same city multiple times. In the end, he will return to the starting city to perform (that is, $a_1 = a_d$).\n\nEach time, Ivan takes a direct flight from $a_i$ to $a_{i+1}$. He wants to be smart and minimize the total cost of tickets. As you know, prices depend on supply and demand: for example, a one-way ticket might even be more expensive than a round-trip ticket for the same pair of cities.\n\nThere are two types of tickets available:\n\n1. A one-way ticket from $a$ to $b$, which allows exactly one flight from $a$ to $b$, but not from $b$ to $a$.\n\n2. A round-trip ticket from $a$ to $b$: buying one allows one flight from $a$ to $b$, and then one flight from $b$ back to $a$, but you are not allowed to use it in the reverse order. Of course, you may choose not to fly back after going from $a$ to $b$.\n\nYou are given the set of available tickets, with unlimited supply of each type. Please help Ivan find the minimum possible total cost. You may assume that at least one valid plan exists.", "inputFormat": "The first line contains two positive integers $n, d$ ($2 \\le n, d \\le 3 \\times 10^5$), the number of cities and the number of concerts.\n\nThe second line contains $d$ positive integers $a_1, a_2, \\dots, a_d$ ($1 \\le a_i \\le n, a_i \\ne a_{i+1}, a_1 = a_d$), indicating the city of each concert in order.\n\nThe next line contains a positive integer $m$ ($3 \\le m \\le 3 \\times 10^5$), the number of ticket types.\n\nEach of the next $m$ lines contains two positive integers $s_i, d_i$ ($1 \\le s_i, d_i \\le n, s_i \\ne d_i$), the start and end cities; followed by a character $t_i$ indicating the ticket type, where \"O\" means a one-way ticket and \"R\" means a round-trip ticket; and finally a positive integer $p_i$ ($1 \\le p_i \\le 10^9$), the ticket price.", "outputFormat": "Output a single integer: the minimum total ticket cost to complete the tour.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC2016] 爵士之旅 Jazz Journey", "background": "", "description": "Ivan 正在为他的爵士乐队计划一场规模盛大的欧洲巡演。在欧洲一共有 $n$ 个城市，编号依次为 $1 \\sim n$。Ivan 计划举办 $d$ 场演出，分别在城市 $a_1$，$a_2$，$\\dots$，$a_d$，并且严格遵循这个顺序，而且不会在同一个城市连续巡演两次（即 $a_i \\ne a_{i+1}$），但在整个过程中，他可能在一个城市巡演多次。最终，他一定会回到开始的城市进行巡演（即 $a_1 = a_d$）。\n\n\nIvan 每次总是选择搭乘一趟从 $a_i$ 到 $a_{i+1}$ 的直达航班。然而，他希望变得聪明一些，尽量节省机票的开支。你也知道，机票的价格取决于供给和需求，比如一张单程票可能会比相同目的地的双程票还要贵。\n\n\n一共有两种可以购买的机票：\n\n\n1.从 $a$ 到 $b$ 的单程票，每张只能从 $a$ 飞到 $b$ 一次，但不能从 $b$ 飞到 $a$。\n\n\n2.从a到b的双程票，只需购买一张，就能从 $a$ 飞到 $b$ 一次，然后从 $b$ 飞回 $a$ 一次，但先从 $b$ 飞回 $a$ 是不允许的。当然，你也可以选择从 $a$ 飞到 $b$ 之后就再也不返回 $a$。\n\n\n给定可以购买的机票集合，每种机票都是无限量供应的。请帮助 Ivan 找到一种最省钱的方案。你可以认为合法方案必然存在。", "inputFormat": "第一行包含两个正整数 $n$,$d$($2 \\le n,d \\le 3 \\times 10^5$)，分别表示城市的个数和巡演的次数。\n\n第二行包含 $d$ 个正整数 $a_1,a_2,\\dots,a_d$($1 \\le a_i \\le n,a_i \\ne a_{i+1},a_1 = a_d$)，依次表示巡演计划中每一场所在的城市。\n\n接下来一行包含一个正整数 $m$($3 \\le m \\le 3 \\times 10^5$)，表示机票的种类数。\n\n接下来 $m$ 行，每行首先是两个正整数 $s_i,d_i$($1 \\le s_i,d_i \\le n,s_i \\ne d_i$)，分别表示起点与终点；接下来一个字符 $t_i$，表示机票的类型，其中“O”表示单程票，“R”表示双程票；最后是一个正整数 $p_i$($1 \\le p_i \\le 10^9$)，表示票价。", "outputFormat": "输出一行一个整数，即完成巡演所需支付的最小机票总费用。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3687", "type": "P", "difficulty": 6, "samples": [["2\n3 2\n1 2\n1 3\n5 4\n1 2\n2 3\n2 4\n1 5", "2\n8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "各省省选", "浙江", "O2优化", "枚举", "仙人掌"], "title": "[ZJOI2017] 仙人掌", "background": null, "description": "如果一个**无自环无重边无向连通图**的任意一条边最多属于一个简单环，我们就称之为仙人掌。所谓简单环即不经过重复的结点的环。\n\n ![](https://cdn.luogu.com.cn/upload/pic/4742.png) \n\n现在九条可怜手上有一张**无自环无重边的无向连通图**，但是她觉得这张图中的边数太少了，所以她想要在图上连上一些新的边。同时为了方便的存储这张无向图，图中的边数又不能太多。经过权衡，她想要加边后得到的图为一棵仙人掌。\n\n不难发现合法的加边方案有很多，可怜想要知道总共有多少不同的加边方案。\n\n两个加边方案是不同的当且仅当一个方案中存在一条另一个方案中没有的边。", "inputFormat": "多组数据，第一行输入一个整数 $T$ 表示数据组数。\n\n每组数据第一行输入两个整数 $n,m$，表示图中的点数与边数。\n\n接下来 m 行，每行两个整数 $u,v(1\\le u,v\\le n,u\\ne v)$ 表示图中的一条边。保证输入的图联通且没有自环与重边。", "outputFormat": "对于每组数据，输出一个整数表示方案数，当然方案数可能很大，请对 $998244353$ 取模后输出。", "hint": "**样例说明**\n\n对于第一组样例合法加边的方案有 $\\{\\},\\{(2,3)\\}$，共 $2$ 种。\n\n**数据范围**\n\n![](https://cdn.luogu.com.cn/upload/pic/4743.png)", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2017] Cactus", "background": "", "description": "If, in an undirected connected graph with no self-loops and no multiple edges, every edge belongs to at most one simple cycle, we call it a cactus. A simple cycle is a cycle that does not pass through any vertex more than once.\n\n![](https://cdn.luogu.com.cn/upload/pic/4742.png)\n\nNow Jiutiao Kelian has an undirected connected graph with no self-loops and no multiple edges, but she thinks the graph has too few edges, so she wants to add some new edges to it. Meanwhile, to store this undirected graph conveniently, the number of edges should not be too large. After weighing these factors, she wants the graph obtained after adding edges to be a cactus.\n\nIt is not hard to see that there are many valid ways to add edges. She wants to know how many different ways there are in total.\n\nTwo ways of adding edges are different if and only if there exists an edge that is in one way but not in the other.", "inputFormat": "Multiple test cases. The first line contains an integer $T$ denoting the number of test cases.\n\nFor each test case, the first line contains two integers $n, m$, denoting the number of vertices and the number of edges.\n\nThen $m$ lines follow. Each line contains two integers $u, v$ ($1 \\le u, v \\le n, u \\ne v$) describing an edge. It is guaranteed that the input graph is connected and has no self-loops or multiple edges.", "outputFormat": "For each test case, output one integer denoting the number of valid ways. Since the answer may be large, output it modulo $998244353$.", "hint": "Sample explanation.\n\nFor the first sample, the valid ways are $\\{\\}, \\{(2,3)\\}$, for a total of $2$.\n\nConstraints\n\n![](https://cdn.luogu.com.cn/upload/pic/4743.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2017] 仙人掌", "background": null, "description": "如果一个**无自环无重边无向连通图**的任意一条边最多属于一个简单环，我们就称之为仙人掌。所谓简单环即不经过重复的结点的环。\n\n ![](https://cdn.luogu.com.cn/upload/pic/4742.png) \n\n现在九条可怜手上有一张**无自环无重边的无向连通图**，但是她觉得这张图中的边数太少了，所以她想要在图上连上一些新的边。同时为了方便的存储这张无向图，图中的边数又不能太多。经过权衡，她想要加边后得到的图为一棵仙人掌。\n\n不难发现合法的加边方案有很多，可怜想要知道总共有多少不同的加边方案。\n\n两个加边方案是不同的当且仅当一个方案中存在一条另一个方案中没有的边。", "inputFormat": "多组数据，第一行输入一个整数 $T$ 表示数据组数。\n\n每组数据第一行输入两个整数 $n,m$，表示图中的点数与边数。\n\n接下来 m 行，每行两个整数 $u,v(1\\le u,v\\le n,u\\ne v)$ 表示图中的一条边。保证输入的图联通且没有自环与重边。", "outputFormat": "对于每组数据，输出一个整数表示方案数，当然方案数可能很大，请对 $998244353$ 取模后输出。", "hint": "**样例说明**\n\n对于第一组样例合法加边的方案有 $\\{\\},\\{(2,3)\\}$，共 $2$ 种。\n\n**数据范围**\n\n![](https://cdn.luogu.com.cn/upload/pic/4743.png)", "locale": "zh-CN"}}}
{"pid": "P3688", "type": "P", "difficulty": 6, "samples": [["5 5\n1 3 3\n2 3 5\n2 4 5\n1 1 3\n2 2 5", "1\n0\n665496236"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "线段树", "各省省选", "树状数组", "浙江"], "title": "[ZJOI2017] 树状数组", "background": "", "description": "漆黑的晚上，九条可怜躺在床上辗转反侧。难以入眠的她想起了若干年前她的一次悲惨的 OI 比赛经历。那是一道基础的树状数组题。\n\n给出一个长度为 $n$ 的数组 $A$，初始值都为 $0$，接下来进行 $m$ 次操作，操作有两种：\n\n* $1\\ x$，表示将 $A_x$  变成 $(A_x + 1) \\bmod 2$。\n* $2\\ l\\ r$，表示询问 $(\\sum_{i=l}^r A_i) \\bmod 2$。\n\n尽管那个时候的可怜非常的 simple，但是她还是发现这题可以用树状数组做。当时非常 young 的她写了如下的算法：\n\n![](https://cdn.luogu.com.cn/upload/pic/4744.png)\n\n其中 $\\mathrm{lowbit}(x)$ 表示数字 $x$ **最低**的非 $0$ 二进制位，例如 $\\text{lowbit}(5) = 1, \\text{lowbit}(12) = 4$。进行第一类操作的时候就调用 $\\mathrm{Add}(x)$，第二类操作的时候答案就是 $\\mathrm{Query}(l, r)$。\n\n如果你对树状数组比较熟悉，不难发现可怜把树状数组写错了：**$\\text{Add}$ 和 $\\text{Find}$ 中 $x$  变化的方向反了**。因此这个程序在最终测试时华丽的爆 0 了。\n\n然而奇怪的是，在当时，这个程序通过了出题人给出的大样例——这也是可怜没有进行对拍的原因。\n\n现在，可怜想要算一下，这个程序回答对每一个询问的概率是多少，这样她就可以再次的感受到自己是一个多么非的人了。然而时间已经过去了很多年，即使是可怜也没有办法完全回忆起当时的大样例。幸运的是，她回忆起了大部分内容，唯一遗忘的是每一次第一类操作的 $x$ 的值，因此她假定这次操作的 $x$ 是在 $[l_i, r_i]$  范围内**等概率随机**的。\n\n具体来说，可怜给出了一个长度为 $n$ 的数组 $A$，初始为 $0$，接下来进行了 $m$ 次操作：\n\n* $1\\ l\\ r$，表示在区间 $[l, r]$ 中等概率选取一个 $x$ 并执行 $\\text{Add}(x)$ 。\n\n* $2\\ l\\ r$，表示询问执行 $\\text{Query}(l, r)$ 得到的结果是正确的概率是多少。", "inputFormat": "第一行输入两个整数 $n,m$。\n\n接下来 $m$ 行每行描述一个操作，格式如题目中所示。\n", "outputFormat": "对于每组询问，输出一个整数表示答案。如果答案化为最简分数后形如 $\\frac x y$，那么你只需要输出 $x\\times y^{-1} \\bmod 998244353$ 后的值（即输出答案模 $998244353$）。", "hint": "#### 样例说明\n\n在进行完 $\\mathrm{Add}(3)$ 之后，$A$ 数组变成了 $[0, 1, 1, 0, 0]$。所以前两次询问可怜的程序答案都是 $1$，因此第一次询问可怜一定正确，第二次询问可怜一定错误。\n\n#### 数据范围\n\n| 测试点编号 |        $n$         |              $m$               |      其他约定      |\n| :--------: | :----------------: | :----------------------------: | :----------------: |\n|    $1$     |      $\\le 5$       |            $\\le 10$            |         无         |\n|    $2$     |      $\\le 50$      |      $\\le 50$      |         无         |\n|    $3$     |      $\\le 50$      |      $\\le 50$      |         无         |\n|    $4$     | $\\le 3\\times 10^3$ | $\\le 3\\times 10^3$ |         无         |\n|    $5$     | $\\le 3\\times 10^3$ | $\\le 3\\times 10^3$ |         无         |\n|    $6$     |       $10^5$       |       $10^5$       | 所有询问都在修改后 |\n|    $7$     |       $10^5$       |       $10^5$       | 所有询问都在修改后 |\n|    $8$     |       $10^5$       |       $10^5$       |         无         |\n|    $9$     |       $10^5$       |       $10^5$       |         无         |\n|    $10$    |       $10^5$       |       $10^5$       |         无         |\n\n\n对于 $100\\%$ 的数据，保证 $1\\leq l\\leq r\\leq n$。\n\n更新：2018/05/13 @larryzhong 提供了 5 组强的数据。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2017] Binary Indexed Tree", "background": "", "description": "On a dark night, Kurousagi Kotori tossed and turned in bed. Unable to sleep, she remembered a tragic OI contest experience years ago. It was a basic Binary Indexed Tree problem.\n\nGiven an array $A$ of length $n$, initially all $0$, perform $m$ operations of two types:\n\n- $1\\ x$: set $A_x$ to $(A_x + 1) \\bmod 2$.\n- $2\\ l\\ r$: ask for $(\\sum_{i=l}^r A_i) \\bmod 2$.\n\nAlthough Kotori was quite simple back then, she still noticed that this problem could be solved using a Binary Indexed Tree. When she was very young, she wrote the following algorithm:\n\n![](https://cdn.luogu.com.cn/upload/pic/4744.png)\n\nHere $\\mathrm{lowbit}(x)$ denotes the lowest nonzero binary bit of number $x$, e.g., $\\text{lowbit}(5) = 1, \\text{lowbit}(12) = 4$. For the first type of operation she calls $\\mathrm{Add}(x)$, and for the second type the answer is $\\mathrm{Query}(l, r)$.\n\nIf you are familiar with Binary Indexed Trees, it is not hard to see that Kotori wrote it incorrectly: the direction in which $x$ changes in $\\text{Add}$ and $\\text{Find}$ is reversed. Therefore, this program spectacularly got a score of $0$ in the final test.\n\nStrangely, at that time, this program passed the large sample test provided by the problem setter—this is also why Kotori did not conduct stress testing.\n\nNow, Kotori wants to compute the probability that this program answers each query correctly, so she can once again feel how “fei” she was. However, many years have passed, and even Kotori cannot fully remember the large sample. Fortunately, she recalls most of it; the only thing she forgot is the value of $x$ for each type 1 operation, so she assumes that $x$ is chosen uniformly at random from the range $[l_i, r_i]$ for that operation.\n\nSpecifically, Kotori gives an array $A$ of length $n$, initially $0$, and then performs $m$ operations:\n\n- $1\\ l\\ r$: uniformly at random pick an $x$ in the interval $[l, r]$ and execute $\\text{Add}(x)$.\n- $2\\ l\\ r$: ask for the probability that executing $\\text{Query}(l, r)$ yields the correct result.", "inputFormat": "The first line contains two integers $n, m$.\n\nEach of the next $m$ lines describes one operation in the format specified above.", "outputFormat": "For each query, output one integer representing the answer. If the simplified fraction of the answer is $\\frac x y$, you only need to output the value of $x \\times y^{-1} \\bmod 998244353$ (that is, output the answer modulo $998244353$).", "hint": "- Sample Explanation:\n\n  After performing $\\mathrm{Add}(3)$, the array $A$ becomes $[0, 1, 1, 0, 0]$. Therefore, the program’s answers for the first two queries are both $1$. Hence, the first query is certainly correct, and the second query is certainly incorrect.\n\n- Constraints:\n\n  - Test point 1: $n \\le 5$, $m \\le 10$, no additional constraints.\n  - Test point 2: $n \\le 50$, $m \\le 50$, no additional constraints.\n  - Test point 3: $n \\le 50$, $m \\le 50$, no additional constraints.\n  - Test point 4: $n \\le 3 \\times 10^3$, $m \\le 3 \\times 10^3$, no additional constraints.\n  - Test point 5: $n \\le 3 \\times 10^3$, $m \\le 3 \\times 10^3$, no additional constraints.\n  - Test point 6: $n = 10^5$, $m = 10^5$, all queries occur after updates.\n  - Test point 7: $n = 10^5$, $m = 10^5$, all queries occur after updates.\n  - Test point 8: $n = 10^5$, $m = 10^5$, no additional constraints.\n  - Test point 9: $n = 10^5$, $m = 10^5$, no additional constraints.\n  - Test point 10: $n = 10^5$, $m = 10^5$, no additional constraints.\n\n  For $100\\%$ of the testdata, it is guaranteed that $1 \\le l \\le r \\le n$.\n\n  Update: 2018/05/13 @larryzhong provided 5 stronger testdata sets.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2017] 树状数组", "background": "", "description": "漆黑的晚上，九条可怜躺在床上辗转反侧。难以入眠的她想起了若干年前她的一次悲惨的 OI 比赛经历。那是一道基础的树状数组题。\n\n给出一个长度为 $n$ 的数组 $A$，初始值都为 $0$，接下来进行 $m$ 次操作，操作有两种：\n\n* $1\\ x$，表示将 $A_x$  变成 $(A_x + 1) \\bmod 2$。\n* $2\\ l\\ r$，表示询问 $(\\sum_{i=l}^r A_i) \\bmod 2$。\n\n尽管那个时候的可怜非常的 simple，但是她还是发现这题可以用树状数组做。当时非常 young 的她写了如下的算法：\n\n![](https://cdn.luogu.com.cn/upload/pic/4744.png)\n\n其中 $\\mathrm{lowbit}(x)$ 表示数字 $x$ **最低**的非 $0$ 二进制位，例如 $\\text{lowbit}(5) = 1, \\text{lowbit}(12) = 4$。进行第一类操作的时候就调用 $\\mathrm{Add}(x)$，第二类操作的时候答案就是 $\\mathrm{Query}(l, r)$。\n\n如果你对树状数组比较熟悉，不难发现可怜把树状数组写错了：**$\\text{Add}$ 和 $\\text{Find}$ 中 $x$  变化的方向反了**。因此这个程序在最终测试时华丽的爆 0 了。\n\n然而奇怪的是，在当时，这个程序通过了出题人给出的大样例——这也是可怜没有进行对拍的原因。\n\n现在，可怜想要算一下，这个程序回答对每一个询问的概率是多少，这样她就可以再次的感受到自己是一个多么非的人了。然而时间已经过去了很多年，即使是可怜也没有办法完全回忆起当时的大样例。幸运的是，她回忆起了大部分内容，唯一遗忘的是每一次第一类操作的 $x$ 的值，因此她假定这次操作的 $x$ 是在 $[l_i, r_i]$  范围内**等概率随机**的。\n\n具体来说，可怜给出了一个长度为 $n$ 的数组 $A$，初始为 $0$，接下来进行了 $m$ 次操作：\n\n* $1\\ l\\ r$，表示在区间 $[l, r]$ 中等概率选取一个 $x$ 并执行 $\\text{Add}(x)$ 。\n\n* $2\\ l\\ r$，表示询问执行 $\\text{Query}(l, r)$ 得到的结果是正确的概率是多少。", "inputFormat": "第一行输入两个整数 $n,m$。\n\n接下来 $m$ 行每行描述一个操作，格式如题目中所示。\n", "outputFormat": "对于每组询问，输出一个整数表示答案。如果答案化为最简分数后形如 $\\frac x y$，那么你只需要输出 $x\\times y^{-1} \\bmod 998244353$ 后的值（即输出答案模 $998244353$）。", "hint": "#### 样例说明\n\n在进行完 $\\mathrm{Add}(3)$ 之后，$A$ 数组变成了 $[0, 1, 1, 0, 0]$。所以前两次询问可怜的程序答案都是 $1$，因此第一次询问可怜一定正确，第二次询问可怜一定错误。\n\n#### 数据范围\n\n| 测试点编号 |        $n$         |              $m$               |      其他约定      |\n| :--------: | :----------------: | :----------------------------: | :----------------: |\n|    $1$     |      $\\le 5$       |            $\\le 10$            |         无         |\n|    $2$     |      $\\le 50$      |      $\\le 50$      |         无         |\n|    $3$     |      $\\le 50$      |      $\\le 50$      |         无         |\n|    $4$     | $\\le 3\\times 10^3$ | $\\le 3\\times 10^3$ |         无         |\n|    $5$     | $\\le 3\\times 10^3$ | $\\le 3\\times 10^3$ |         无         |\n|    $6$     |       $10^5$       |       $10^5$       | 所有询问都在修改后 |\n|    $7$     |       $10^5$       |       $10^5$       | 所有询问都在修改后 |\n|    $8$     |       $10^5$       |       $10^5$       |         无         |\n|    $9$     |       $10^5$       |       $10^5$       |         无         |\n|    $10$    |       $10^5$       |       $10^5$       |         无         |\n\n\n对于 $100\\%$ 的数据，保证 $1\\leq l\\leq r\\leq n$。\n\n更新：2018/05/13 @larryzhong 提供了 5 组强的数据。", "locale": "zh-CN"}}}
{"pid": "P3689", "type": "P", "difficulty": 7, "samples": [["1\n3 3 2 1 10\n1011\n01", "2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "各省省选", "浙江", "O2优化"], "title": "[ZJOI2017] 多项式", "background": "", "description": "九条可怜最近研究了一下多项式在系数模 2 意义下的性质。她发现可以用多项式在模 2 意义下的乘法得到一个很长的字符串：\n\n对于一个 $n$ 次的系数为 0 或 1 的多项式 $f\\left ( x \\right )$，我们在模 2 意义下计算 $g\\left ( x \\right ) = f\\left ( x \\right )^{m}$，则\n\n$g\\left ( x \\right )$ 为一个 $nm$ 次的多项式，它有 $nm + 1$ 个系数，将这些系数从**高位到低位**写下来，就可以得到一个长度为 $nm + 1$ 的 01 字符串。\n\n例如对于多项式 $f\\left ( x \\right ) = x^{3} + x + 1$，计算 $g\\left( x \\right ) = f\\left( x \\right)^{3} = x^{9} + x^{7} + x^{6} + x^{5} + x^{2} + x^{1} + 1 $，这样我们得到了一个长度为 10 的字符串 1011100111。\n\n现在可怜有一个次数为 $n$ 的多项式 $f\\left( x \\right )$，整数 $m$, $L$, $R$ 以及一个长度为 $K$ 的 01 串 $t$。令 $s$为 $f\\left( x \\right )^{m}$得到的字符串， $s\\left[L, R\\right]$ 为 $s$ 的第 $L$ 个字符到第 $R$ 个字符，可怜想要知道 $t$ 在 $s\\left[L, R\\right]$中出现了多少次。\n", "inputFormat": "第一行输入一个整数 T 表示数据组数。\n\n每组数据第一行输入五个整数 $n, m, K, L, R$。\n\n第二行输入一个长度为 $n + 1$ 的 01 串表示多项式 $f\\left( x \\right )$ 的系数，其中第 $i$ 位表示 $f\\left( x \\right )$ 的第 $n − i + 1$ 次系数。\n\n第三行输入一个长度为 $K$ 的字符串表示字符串 $t$。\n", "outputFormat": "对于每组数据输出一个整数表示答案。\n", "hint": "**时空限制**\n\n时间限制3s，空间限制512M\n\n**数据范围**\n\n![](https://cdn.luogu.com.cn/upload/pic/4746.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2017] Polynomial", "background": "", "description": "Kotori Itsuka recently studied the properties of polynomials with coefficients modulo 2. She found that one can obtain a very long string using multiplication of polynomials modulo 2:\n\nFor an $n$-degree polynomial $f\\left( x \\right)$ with coefficients 0 or 1, we compute $g\\left( x \\right) = f\\left( x \\right)^{m}$ modulo 2. Then $g\\left( x \\right)$ is an $nm$-degree polynomial with $nm + 1$ coefficients. Writing these coefficients from the highest degree to the lowest degree gives a 01 string of length $nm + 1$.\n\nFor example, for the polynomial $f\\left( x \\right) = x^{3} + x + 1$, we compute $g\\left( x \\right) = f\\left( x \\right)^{3} = x^{9} + x^{7} + x^{6} + x^{5} + x^{2} + x^{1} + 1$, thus we obtain a string of length 10: 1011100111.\n\nNow given a polynomial $f\\left( x \\right)$ of degree $n$, integers $m$, $L$, $R$, and a 01 string $t$ of length $K$. Let $s$ be the string obtained from $f\\left( x \\right)^{m}$, and let $s\\left[ L, R \\right]$ denote the substring from the $L$-th character to the $R$-th character of $s$. Kotori wants to know how many times $t$ appears in $s\\left[ L, R \\right]$.", "inputFormat": "The first line contains an integer $T$ denoting the number of test cases.\n\nFor each test case, the first line contains five integers $n, m, K, L, R$.\n\nThe second line contains a 01 string of length $n + 1$ representing the coefficients of the polynomial $f\\left( x \\right)$. The $i$-th character represents the coefficient of degree $n - i + 1$ of $f\\left( x \\right)$.\n\nThe third line contains a string of length $K$ representing the string $t$.", "outputFormat": "For each test case, output a single integer denoting the answer.", "hint": "Time and Space Limit\n\nTime limit: 3 s, Memory limit: 512 MB.\n\nConstraints\n\n![](https://cdn.luogu.com.cn/upload/pic/4746.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2017] 多项式", "background": "", "description": "九条可怜最近研究了一下多项式在系数模 2 意义下的性质。她发现可以用多项式在模 2 意义下的乘法得到一个很长的字符串：\n\n对于一个 $n$ 次的系数为 0 或 1 的多项式 $f\\left ( x \\right )$，我们在模 2 意义下计算 $g\\left ( x \\right ) = f\\left ( x \\right )^{m}$，则\n\n$g\\left ( x \\right )$ 为一个 $nm$ 次的多项式，它有 $nm + 1$ 个系数，将这些系数从**高位到低位**写下来，就可以得到一个长度为 $nm + 1$ 的 01 字符串。\n\n例如对于多项式 $f\\left ( x \\right ) = x^{3} + x + 1$，计算 $g\\left( x \\right ) = f\\left( x \\right)^{3} = x^{9} + x^{7} + x^{6} + x^{5} + x^{2} + x^{1} + 1 $，这样我们得到了一个长度为 10 的字符串 1011100111。\n\n现在可怜有一个次数为 $n$ 的多项式 $f\\left( x \\right )$，整数 $m$, $L$, $R$ 以及一个长度为 $K$ 的 01 串 $t$。令 $s$为 $f\\left( x \\right )^{m}$得到的字符串， $s\\left[L, R\\right]$ 为 $s$ 的第 $L$ 个字符到第 $R$ 个字符，可怜想要知道 $t$ 在 $s\\left[L, R\\right]$中出现了多少次。\n", "inputFormat": "第一行输入一个整数 T 表示数据组数。\n\n每组数据第一行输入五个整数 $n, m, K, L, R$。\n\n第二行输入一个长度为 $n + 1$ 的 01 串表示多项式 $f\\left( x \\right )$ 的系数，其中第 $i$ 位表示 $f\\left( x \\right )$ 的第 $n − i + 1$ 次系数。\n\n第三行输入一个长度为 $K$ 的字符串表示字符串 $t$。\n", "outputFormat": "对于每组数据输出一个整数表示答案。\n", "hint": "**时空限制**\n\n时间限制3s，空间限制512M\n\n**数据范围**\n\n![](https://cdn.luogu.com.cn/upload/pic/4746.png)\n", "locale": "zh-CN"}}}
{"pid": "P3690", "type": "P", "difficulty": 6, "samples": [["3 3 \n1\n2\n3\n1 1 2\n0 1 2 \n0 1 1", "3\n1\n"], ["5 14\n114\n514\n19\n19\n810\n1 1 2\n0 1 2\n2 1 2\n1 1 2\n1 2 3\n2 1 3\n1 1 3\n1 4 5\n1 2 5\n0 3 5\n0 3 4\n3 5 233333\n0 1 5\n0 2 5\n", "624\n315\n296\n232709\n232823\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["O2优化", "树链剖分", "动态树 LCT", "模板题"], "title": "【模板】动态树（LCT）", "background": "", "description": "给定 $n$ 个点以及每个点的权值，要你处理接下来的 $m$ 个操作。  \n操作有四种，操作从 $0$ 到 $3$ 编号。点从 $1$ 到 $n$ 编号。\n\n\n- `0 x y` 代表询问从 $x$ 到 $y$ 的路径上的点的权值的 $\\text{xor}$ 和。保证 $x$ 到 $y$ 是联通的。\n- `1 x y` 代表连接 $x$ 到 $y$，若 $x$ 到 $y$ 已经联通则无需连接。\n- `2 x y` 代表删除边 $(x,y)$，不保证边 $(x,y)$ 存在。\n- `3 x y` 代表将点 $x$ 上的权值变成 $y$。\n", "inputFormat": "第一行两个整数，分别为 $n$ 和 $m$，代表点数和操作数。\n\n接下来 $n$ 行，每行一个整数，第 $(i + 1)$ 行的整数 $a_i$ 表示节点 $i$ 的权值。\n\n接下来 $m$ 行，每行三个整数，分别代表操作类型和操作所需的量。\n", "outputFormat": "对于每一个 $0$ 号操作，你须输出一行一个整数，表示 $x$ 到 $y$ 的路径上点权的 $\\text{xor}$ 和。\n", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证：\n- $1 \\leq n \\leq 10^5$，$1 \\leq m \\leq 3 \\times 10^5$，$1 \\leq a_i \\leq 10^9$。\n- 对于操作 $0, 1, 2$，保证 $1 \\leq x, y \\leq n$。\n- 对于操作 $3$，保证 $1 \\leq x \\leq n$，$1 \\leq y \\leq 10^9$。\n", "locale": "zh-CN", "translations": {"en": {"title": "【Template】Dynamic Tree (LCT)", "background": "", "description": "Given $n$ nodes and each node’s weight, you need to process the next $m$ operations.  \nThere are four types of operations, numbered from $0$ to $3$. Nodes are numbered from $1$ to $n$.\n\n- `0 x y` asks for the $\\text{xor}$ sum of the weights of the nodes on the path from $x$ to $y$. It is guaranteed that $x$ and $y$ are connected.\n- `1 x y` connects $x$ to $y$. If $x$ and $y$ are already connected, do nothing.\n- `2 x y` deletes the edge $(x, y)$. The existence of edge $(x, y)$ is not guaranteed.\n- `3 x y` sets the weight of node $x$ to $y$.", "inputFormat": "The first line contains two integers $n$ and $m$, representing the number of nodes and the number of operations.\n\nThe next $n$ lines each contain one integer. On the $(i + 1)$-th line, the integer $a_i$ denotes the weight of node $i$.\n\nThe next $m$ lines each contain three integers, representing the operation type and its parameters.", "outputFormat": "For each operation of type $0$, output one line with one integer, the $\\text{xor}$ sum of the node weights on the path from $x$ to $y$.", "hint": "Constraints and Conventions\n\nFor all testdata, it is guaranteed that:\n- $1 \\leq n \\leq 10^5$, $1 \\leq m \\leq 3 \\times 10^5$, $1 \\leq a_i \\leq 10^9$.\n- For operations $0, 1, 2$, it holds that $1 \\leq x, y \\leq n$.\n- For operation $3$, it holds that $1 \\leq x \\leq n$, $1 \\leq y \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】动态树（LCT）", "background": "", "description": "给定 $n$ 个点以及每个点的权值，要你处理接下来的 $m$ 个操作。  \n操作有四种，操作从 $0$ 到 $3$ 编号。点从 $1$ 到 $n$ 编号。\n\n\n- `0 x y` 代表询问从 $x$ 到 $y$ 的路径上的点的权值的 $\\text{xor}$ 和。保证 $x$ 到 $y$ 是联通的。\n- `1 x y` 代表连接 $x$ 到 $y$，若 $x$ 到 $y$ 已经联通则无需连接。\n- `2 x y` 代表删除边 $(x,y)$，不保证边 $(x,y)$ 存在。\n- `3 x y` 代表将点 $x$ 上的权值变成 $y$。\n", "inputFormat": "第一行两个整数，分别为 $n$ 和 $m$，代表点数和操作数。\n\n接下来 $n$ 行，每行一个整数，第 $(i + 1)$ 行的整数 $a_i$ 表示节点 $i$ 的权值。\n\n接下来 $m$ 行，每行三个整数，分别代表操作类型和操作所需的量。\n", "outputFormat": "对于每一个 $0$ 号操作，你须输出一行一个整数，表示 $x$ 到 $y$ 的路径上点权的 $\\text{xor}$ 和。\n", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证：\n- $1 \\leq n \\leq 10^5$，$1 \\leq m \\leq 3 \\times 10^5$，$1 \\leq a_i \\leq 10^9$。\n- 对于操作 $0, 1, 2$，保证 $1 \\leq x, y \\leq n$。\n- 对于操作 $3$，保证 $1 \\leq x \\leq n$，$1 \\leq y \\leq 10^9$。\n", "locale": "zh-CN"}}}
{"pid": "P3691", "type": "P", "difficulty": 3, "samples": [["4 4 0\n3.000 4.000 1\n3.000 3.000 -1\n8.000 3.000 -1\n8.000 4.000 1\n100.000 100.000\n0.000 0.000\n3.141 5.926\n0.618 1.618", "1\n-1\n1\n-1"]], "limits": {"time": [2000, 1000, 1000, 1000, 1000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["洛谷原创", "Special Judge", "随机化"], "title": "妖精大战争", "background": " ![](https://cdn.luogu.com.cn/upload/pic/4726.png) \n\n琪露诺一如既往忙碌地生活着。\n\n某天，在外出时她的家被人破坏了。\n\n损坏的家插着一面奇怪的旗。\n\n旗上画着似曾相识的几个妖精的图案。\n\n狂怒的琪露诺对旗的主人贴出了宣战告示。\n\n就这样，妖精们的大战争开始了。\n\n(摘自《妖精大战争》manual)\n", "description": "三月精 Sunny Milk, Lunar Child, Star Sapphire 为了让冰之妖精琪露诺加入她们的恶作剧计划，破坏了琪露诺的房子。琪露诺当然不会就此罢休，于是她找到了三月精准备进行复仇，复仇的方式是进行一场弹幕对决。 在Normal 难度下，Star Sapphire 在此次对战中不会出场，因此只有 Sunny Milk, Lunar Child两只妖精出场和琪露诺对决了。\n\n在一张符卡中，Sunny Milk 和 Lunar Child 发射的弹幕几乎填满了整个 $100\\times 100$ 的正方形战斗场地，并且恰好可以被一条静止不动，非垂直的直线划分成两部分，其中直线上方的部分是 Sunny Milk 发射的日光弹幕，直线下方的部分是 Lunar Child 发射的月光弹幕。\n\n琪露诺是最强的妖精，但她面对两只妖精密集的弹幕也会有些紧张。在她的干劲快要被消磨完时，琪露诺忽然发现，如果能用两种不同的策略来对付两种弹幕，获胜的希望将会大大增加。因此，她想知道一些关键的位置会出现什么弹幕。\n\n不幸的是，琪露诺无法判断出分界线在哪里，她只知道当前在战斗场地中每个弹幕的位置，和这个弹幕是月光弹幕还是日光弹幕。在极少情况下(至多 $0.1\\%$)，琪露诺可能会错误识别弹幕的类型，因为它们实在太像了。琪露诺想要了解的是，对于接下来可能出现弹幕的位置，如果出现了弹幕，它是月光弹幕还是日光弹幕。你能帮帮她吗？\n", "inputFormat": "第一行三个正整数 $n,m,x$。分别表示当前场地上弹幕的数量，和琪露诺想要了解情况的位置的数量，$x$ 表示当前是第几个测试点。\n\n接下来 $n$ 行，每行两个实数 $x,y$ 和一个整数 $k$，用空格隔开。表示在 $(x,y)$ 有一个种类为 $k$ 的弹幕，$k=1$ 为日光弹幕，$k=-1$ 为月光弹幕。\n\n接下来 $m$ 行，每行两个实数 $x,y$，表示琪露诺想知道这个位置如果出现弹幕，会出现什么类型的弹幕。", "outputFormat": "$m$ 行，每行一个整数 $1$ 或者 $-1$，对应每个询问的结果。\n\n$1$ 为日光弹幕，$-1$ 为月光弹幕。", "hint": "【样例解释】\n\n注：该数据因量过小，信息量不足而不合法，可能会发生无法得到准确答案的情况。因此仅供理解题意使用，不可用来测试程序。\n\n观察输入数据，我们发现当 $y=3$ 时，都是月光弹幕 $,y=4$ 时，都是日光弹幕。可以猜想直线在 $y=3 \\sim y=4$ 之间。\n\n因此对于四个询问分别回答 $1,-1,1,-1$。\n\n【数据范围和提示】\n\n单个弹幕的面积可视为 $0$。\n\n若询问的位置恰好落在分界线上，当做在分界线的下方处理。\n\n本题有 SpecialJudge。\n\n- 对于第 $1$ 个测试点：\n\n$N=100000$，$m=100000$。\n\n若你输出的答案中，正确回答的询问数量大于等于总询问数量的 $30\\%$，则可以获得该测试点的全部分数，否则得 $0$ 分。\n\n- 对于第 $2 \\sim 5$ 个测试点：\n\n$n=1000$，$m=1000$。\n\n若你输出的答案中，正确回答的询问数量大于等于总询问数量的 $60\\%$，则可以获得该测试点的全部分数，否则得 $0$ 分。\n\n- 对于第 $6 \\sim 7$ 个测试点，\n\n$n=100000$，$m=100000$。\n\n若你输出的答案中，正确回答的询问数量大于等于总询问数量的 $70\\%$，则可以获得该测试点的全部分数，否则得 $0$ 分。\n\n- 对于第 $8 \\sim 10$ 个测试点，\n\n$n=100000$，$m=100000$。\n\n若你输出的答案中，正确回答的询问数量大于等于总询问数量的 $80\\%$，则可以获得该测试点的全部分数，否则得 $0$ 分。\n\n- 对于 $100\\%$ 的数据：\n\n$0.000 \\le x,y \\le 100.000$。\n\n所有输入的实数均保留 $3$ 位小数。\n\n保证输入数据有合法的解能够满足题目要求的判定准确率。\n\n评测时限：对于测试点 $2 \\sim 5,$ 时限为 $1s$，其他测试点时限为 $2s$。", "locale": "zh-CN", "translations": {"en": {"title": "Fairy Wars", "background": "![](https://cdn.luogu.com.cn/upload/pic/4726.png)\n\nCirno lives a busy life as always.\n\nOne day, while she was out, her home was destroyed.\n\nA strange flag was planted in the ruins.\n\nThe flag showed patterns of a few familiar fairies.\n\nEnraged, Cirno posted a declaration of war against the owner of the flag.\n\nAnd thus, the great war of the fairies began.\n\n(Excerpted from the Fairy Wars manual.)", "description": "The Three Fairies of Light Sunny Milk, Lunar Child, and Star Sapphire destroyed the ice fairy Cirno’s house to lure her into their prank plan. Of course, Cirno would not let it go. She found the Three Fairies to take revenge, in the form of a danmaku duel. On Normal difficulty, Star Sapphire does not appear in this duel, so only Sunny Milk and Lunar Child face off against Cirno.\n\nIn one spell card, the danmaku fired by Sunny Milk and Lunar Child almost fills the entire $100\\times 100$ square battlefield, and can be exactly divided into two parts by a stationary, non-vertical straight line. The region above the line is Sunny Milk’s sunlight danmaku, and the region below the line is Lunar Child’s moonlight danmaku.\n\nCirno is the strongest fairy, but even she gets nervous in the face of dense danmaku from two fairies. Just as her motivation is about to run out, she realizes that if she can use two different strategies for the two kinds of danmaku, her chances of winning will greatly increase. Therefore, she wants to know what kind of danmaku will appear at some key positions.\n\nUnfortunately, Cirno cannot determine where the separating line is. She only knows the current positions of every danmaku on the battlefield and whether each one is moonlight or sunlight. In rare cases (at most $0.1\\%$), Cirno may misidentify the type of danmaku because they look so similar. What Cirno wants to know is: for positions where danmaku may appear next, if danmaku does appear, will it be moonlight or sunlight? Can you help her?", "inputFormat": "The first line contains three positive integers $n, m, x$, denoting the number of danmaku currently on the field, the number of positions Cirno wants to query, and that $x$ is the index of the current test point.\n\nThe next $n$ lines each contain two real numbers $x,y$ and an integer $k$, separated by spaces. This means there is a danmaku of type $k$ at $(x,y)$. Here $k=1$ represents sunlight danmaku, and $k=-1$ represents moonlight danmaku.\n\nThe next $m$ lines each contain two real numbers $x,y$, representing positions where Cirno wants to know what type of danmaku would appear if danmaku appears there.", "outputFormat": "Output $m$ lines, each containing one integer $1$ or $-1$, corresponding to the result for each query.\n\n$1$ means sunlight danmaku, and $-1$ means moonlight danmaku.", "hint": "[Sample explanation]\n\nNote: This testdata is invalid due to being too small and lacking sufficient information to determine an accurate answer. It is only for understanding the problem statement and should not be used to test your program.\n\nFrom the input, we observe that when $y=3$, they are all moonlight danmaku, and when $y=4$, they are all sunlight danmaku. We may guess that the separating line lies between $y=3 \\sim y=4$.\n\nTherefore, for the four queries, answer $1,-1,1,-1$ respectively.\n\n[Constraints and notes]\n\n- The area of a single danmaku can be considered $0$.\n- If a query position lies exactly on the separating line, treat it as being below the line.\n- This problem uses a Special Judge.\n\n- For test point $1$:\n\n$n=100000$, $m=100000$.\n\nIf the number of correctly answered queries in your output is at least $30\\%$ of all queries, you will receive full score for this test point; otherwise, $0$ points.\n\n- For test points $2 \\sim 5$:\n\n$n=1000$, $m=1000$.\n\nIf the number of correctly answered queries in your output is at least $60\\%$ of all queries, you will receive full score for this test point; otherwise, $0$ points.\n\n- For test points $6 \\sim 7$:\n\n$n=100000$, $m=100000$.\n\nIf the number of correctly answered queries in your output is at least $70\\%$ of all queries, you will receive full score for this test point; otherwise, $0$ points.\n\n- For test points $8 \\sim 10$:\n\n$n=100000$, $m=100000$.\n\nIf the number of correctly answered queries in your output is at least $80\\%$ of all queries, you will receive full score for this test point; otherwise, $0$ points.\n\n- For $100\\%$ of the testdata:\n\n$0.000 \\le x,y \\le 100.000$.\n\nAll input real numbers have exactly $3$ decimal places.\n\nIt is guaranteed that the input has a valid solution that can meet the required accuracy thresholds.\n\nTime limit: for test points $2 \\sim 5$, the limit is $1\\ \\mathrm{s}$; for the other test points, the limit is $2\\ \\mathrm{s}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "妖精大战争", "background": " ![](https://cdn.luogu.com.cn/upload/pic/4726.png) \n\n琪露诺一如既往忙碌地生活着。\n\n某天，在外出时她的家被人破坏了。\n\n损坏的家插着一面奇怪的旗。\n\n旗上画着似曾相识的几个妖精的图案。\n\n狂怒的琪露诺对旗的主人贴出了宣战告示。\n\n就这样，妖精们的大战争开始了。\n\n(摘自《妖精大战争》manual)\n", "description": "三月精 Sunny Milk, Lunar Child, Star Sapphire 为了让冰之妖精琪露诺加入她们的恶作剧计划，破坏了琪露诺的房子。琪露诺当然不会就此罢休，于是她找到了三月精准备进行复仇，复仇的方式是进行一场弹幕对决。 在Normal 难度下，Star Sapphire 在此次对战中不会出场，因此只有 Sunny Milk, Lunar Child两只妖精出场和琪露诺对决了。\n\n在一张符卡中，Sunny Milk 和 Lunar Child 发射的弹幕几乎填满了整个 $100\\times 100$ 的正方形战斗场地，并且恰好可以被一条静止不动，非垂直的直线划分成两部分，其中直线上方的部分是 Sunny Milk 发射的日光弹幕，直线下方的部分是 Lunar Child 发射的月光弹幕。\n\n琪露诺是最强的妖精，但她面对两只妖精密集的弹幕也会有些紧张。在她的干劲快要被消磨完时，琪露诺忽然发现，如果能用两种不同的策略来对付两种弹幕，获胜的希望将会大大增加。因此，她想知道一些关键的位置会出现什么弹幕。\n\n不幸的是，琪露诺无法判断出分界线在哪里，她只知道当前在战斗场地中每个弹幕的位置，和这个弹幕是月光弹幕还是日光弹幕。在极少情况下(至多 $0.1\\%$)，琪露诺可能会错误识别弹幕的类型，因为它们实在太像了。琪露诺想要了解的是，对于接下来可能出现弹幕的位置，如果出现了弹幕，它是月光弹幕还是日光弹幕。你能帮帮她吗？\n", "inputFormat": "第一行三个正整数 $n,m,x$。分别表示当前场地上弹幕的数量，和琪露诺想要了解情况的位置的数量，$x$ 表示当前是第几个测试点。\n\n接下来 $n$ 行，每行两个实数 $x,y$ 和一个整数 $k$，用空格隔开。表示在 $(x,y)$ 有一个种类为 $k$ 的弹幕，$k=1$ 为日光弹幕，$k=-1$ 为月光弹幕。\n\n接下来 $m$ 行，每行两个实数 $x,y$，表示琪露诺想知道这个位置如果出现弹幕，会出现什么类型的弹幕。", "outputFormat": "$m$ 行，每行一个整数 $1$ 或者 $-1$，对应每个询问的结果。\n\n$1$ 为日光弹幕，$-1$ 为月光弹幕。", "hint": "【样例解释】\n\n注：该数据因量过小，信息量不足而不合法，可能会发生无法得到准确答案的情况。因此仅供理解题意使用，不可用来测试程序。\n\n观察输入数据，我们发现当 $y=3$ 时，都是月光弹幕 $,y=4$ 时，都是日光弹幕。可以猜想直线在 $y=3 \\sim y=4$ 之间。\n\n因此对于四个询问分别回答 $1,-1,1,-1$。\n\n【数据范围和提示】\n\n单个弹幕的面积可视为 $0$。\n\n若询问的位置恰好落在分界线上，当做在分界线的下方处理。\n\n本题有 SpecialJudge。\n\n- 对于第 $1$ 个测试点：\n\n$N=100000$，$m=100000$。\n\n若你输出的答案中，正确回答的询问数量大于等于总询问数量的 $30\\%$，则可以获得该测试点的全部分数，否则得 $0$ 分。\n\n- 对于第 $2 \\sim 5$ 个测试点：\n\n$n=1000$，$m=1000$。\n\n若你输出的答案中，正确回答的询问数量大于等于总询问数量的 $60\\%$，则可以获得该测试点的全部分数，否则得 $0$ 分。\n\n- 对于第 $6 \\sim 7$ 个测试点，\n\n$n=100000$，$m=100000$。\n\n若你输出的答案中，正确回答的询问数量大于等于总询问数量的 $70\\%$，则可以获得该测试点的全部分数，否则得 $0$ 分。\n\n- 对于第 $8 \\sim 10$ 个测试点，\n\n$n=100000$，$m=100000$。\n\n若你输出的答案中，正确回答的询问数量大于等于总询问数量的 $80\\%$，则可以获得该测试点的全部分数，否则得 $0$ 分。\n\n- 对于 $100\\%$ 的数据：\n\n$0.000 \\le x,y \\le 100.000$。\n\n所有输入的实数均保留 $3$ 位小数。\n\n保证输入数据有合法的解能够满足题目要求的判定准确率。\n\n评测时限：对于测试点 $2 \\sim 5,$ 时限为 $1s$，其他测试点时限为 $2s$。", "locale": "zh-CN"}}}
{"pid": "P3692", "type": "P", "difficulty": 2, "samples": [["2 5\nABCAD\n0000000011111111\n01\n1000\n0010\n0100\n1000\n0010\n1001001001001001\n01\n0001\n1010\n0111\n1111\n0000", "ID: 255\nType Correct\n40.0\n\nWrong ID"], ["3 3\nABC\n0000000000000000\n01\n1111\n0001\n0100\n0000000000000010\n10\n1000\n0100\n0010\n0000000000000011\n11\n0001\n0000\n0010\n", "Wrong ID\n\nID: 2\nType Correct\n100.0\n\nID: 3\nType Incorrect\n33.3\n"], ["5 31\nACAACCDDBBDADDCBCACCDBCAACAAAAC\n0000101111000001\n10\n1000\n0010\n1000\n1111\n0010\n0010\n0001\n0001\n0100\n0100\n0001\n1000\n0001\n0001\n0010\n1111\n0010\n1000\n0010\n0010\n0001\n0100\n1111\n1000\n1000\n0010\n1000\n0100\n1000\n1000\n0010\n0000010101001111\n10\n1000\n0010\n1000\n1000\n0010\n0010\n0001\n0001\n0100\n0100\n0001\n1000\n0001\n0001\n0010\n0100\n1000\n1000\n0000\n0010\n0001\n0100\n0010\n1000\n1000\n0010\n1000\n1000\n0000\n0000\n0010\n0001110001100110\n11\n1000\n0010\n1000\n1000\n0010\n0010\n0001\n0001\n0100\n0100\n0001\n1000\n0010\n0100\n0010\n0100\n0010\n0100\n0010\n0010\n0001\n0100\n0010\n1000\n1000\n0010\n1000\n1111\n1000\n1000\n0010\n0001001111110001\n10\n1010\n0010\n1000\n1000\n0010\n0010\n0001\n0001\n0100\n0100\n0010\n1000\n0001\n0001\n0010\n0100\n0010\n1000\n0010\n0010\n0001\n0100\n0010\n1000\n1000\n0010\n1000\n1000\n1000\n1000\n0010\n0001110010000100\n10\n1000\n0010\n1000\n1000\n0000\n0010\n0001\n0001\n0100\n0100\n0001\n1000\n0001\n0001\n0001\n0100\n0010\n1000\n0010\n0010\n0001\n0100\n0010\n1000\n1000\n0010\n1000\n1000\n0000\n1000\n0001\n", "ID: 3009\nType Incorrect\n87.1\n\nID: 1359\nType Incorrect\n87.1\n\nID: 7270\nType Incorrect\n87.1\n\nID: 5105\nType Incorrect\n93.5\n\nID: 7300\nType Correct\n87.1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串", "洛谷原创", "进制"], "title": "夏幻的考试", "background": "夏之幻是软件工程系的大神，学校把举办考试的任务交给她了。", "description": "某大学软工专业要举办一场笔试，学生们要在机读答题卡上填写答案来进行答题。学校把机读卡识别任务交给了夏之幻，但是这套系统的需求太复杂了，她还要做自己的其他项(you)目(xi)，所以她想让你来帮忙实现一部分功能。\n\n试卷分卷头，单选题两部分。\n\n夏幻大神已经写好了识别程序，因此卷头和答案将直接以数字信息的形式呈现给你，你要实现下面几个功能:\n\n需要处理 $T$ 张试卷，按顺序检查下列选项。\n\n1.检查考号的填写是否准确。\n\n输入信息的格式:\n\n一行，一个 $16$ 位无符号二进制数id。表示考生的考号为id，正确的考号范围在十进制下是 $1 \\sim 10000$。\n\n如果考号有错误，输出一行 `Wrong ID` 并结束对这张试卷的处理(剩下两个选项的数据依然要读入，但不输出任何内容)。如果考号正确，输出一行,`ID: `+ 一个整数，表示考号的十进制形式。\n\n无需考虑考号是否重复，只要在范围内均为正确。\n\n2.检查试卷类型是否正确。\n\n输入信息格式:\n\n一行，两个整数，中间无分隔，只能是 $0$ 或者 $1$。第一个整数表示试卷类型A是否被涂黑($0$ 表示未涂黑，$1$ 表示涂黑)，第二个整数表示试卷类型B是否涂黑。其实试卷类型可以由二进制考号的最后一位得到，$0$ 表示A卷，$1$ 表示B卷，你只需要检查考生填涂的是否正确。\n\n如果考生将试卷类型正确填涂(填涂且只填涂了正确的那一项)，输出一行 `Type Correct`，否则输出一行 `Type Incorrect`。无论试卷类型是否填涂正确，你还需要接着处理这张试卷。\n\n3.给单选题打分。\n\n单选题的数量 $n$ 和标准答案将会在录入第一张试卷前给出。\n\n考生答案的输入格式:\n\n$n$ 行，每行 $4$ 个整数，中间无分隔。每个整数是 $0$ 或 $1$。\n\n按顺序分别代表 $A,B,C,D$ 是否被涂黑($0$ 表示未涂黑，$1$ 表示涂黑)。考生回答正确当且仅当该题正确答案的位置被涂黑，且错误答案的位置未被涂黑。\n\n输出一行，一个四舍五入到小数点后 $1$ 位的浮点数，表示考生的得分，满分为 $100$ 分，每个题的分数相同。", "inputFormat": "第一行两个整数 $T$、$n$，空格分开，含义见题目描述。\n\n接下来一行一个字符串 $s$，长度为 $n$，每个字符是大写字母 $A,B,C,D$ 中的一个，第 $i$ 个字符表示单选题 $i$ 的答案。\n\n接下来 $T \\times (n+2)$ 行含有 $T$ 组信息，表示每张试卷的内容，格式见题目描述。", "outputFormat": "对于每张试卷，输出评判结果，格式见题目描述。两张试卷的评判结果之间空一行。", "hint": "对于100%的数据\n\n$1 \\le T \\le 1000$\n\n$1 \\le n \\le 50$\n\n注意:\n\n1.请在最后一个试卷处理完后也加上一个换行\n\n2.由于win系统和linux系统换行的不同，建议不要使用scanf读入char", "locale": "zh-CN", "translations": {"en": {"title": "Xia Huan's Exam", "background": "Xia Huan is a guru in the Software Engineering department, and the school has assigned her to organize an exam.", "description": "A university's Software Engineering program is holding a written test. Students fill answers on a machine-readable answer sheet. The school assigned the recognition task to Xia Huan, but the system requirements are too complex and she also has other projects to work on, so she wants you to help implement part of the functionality.\n\nThe paper has two parts: the header and single-choice questions.\n\nXia Huan has already written the recognition program, so the header and answers will be provided directly as numeric information. You need to implement the following features:\n\nYou need to process $T$ papers and check the following items in order.\n\n1. Check whether the examinee ID is filled in correctly.\n\nInput format:\nOne line: a 16-bit unsigned binary number id. The examinee's ID is id, and the correct ID range in decimal is $1 \\sim 10000$.\n\nIf the ID is invalid, output one line `Wrong ID` and stop processing this paper (you still need to read the remaining two parts' input for this paper, but do not output anything else). If the ID is valid, output one line: `ID: ` + an integer, which is the decimal form of the ID.\n\nYou do not need to consider whether IDs are duplicated; as long as the value is within the range, it is considered valid.\n\n2. Check whether the paper type is filled in correctly.\n\nInput format:\nOne line: two digits with no separator, each must be $0$ or $1$. The first digit indicates whether paper type A is bubbled ($0$ means not bubbled, $1$ means bubbled), and the second digit indicates whether paper type B is bubbled. In fact, the paper type can be determined by the last bit of the binary ID: $0$ means type A, $1$ means type B. You only need to check whether the student filled it correctly.\n\nIf the student filled the paper type correctly (bubbled, and only bubbled, the correct one), output one line `Type Correct`; otherwise, output one line `Type Incorrect`. Regardless of correctness, you must continue processing this paper.\n\n3. Score the single-choice questions.\n\nThe number of single-choice questions $n$ and the answer key will be provided before entering the first paper.\n\nCandidate answers input format:\n$n$ lines, each with 4 digits and no separator. Each digit is $0$ or $1$.\n\nIn order, they represent whether $A, B, C, D$ are bubbled ($0$ means not bubbled, $1$ means bubbled). A student's answer to a question is correct if and only if the correct option is bubbled and all incorrect options are not bubbled.\n\nOutput one line: a floating-point number rounded to 1 decimal place, representing the student's score. The full score is $100$, and each question has the same weight.", "inputFormat": "The first line contains two integers $T$ and $n$, separated by a space, as described above.\n\nThe next line contains a string $s$ of length $n$. Each character is one of the uppercase letters $A, B, C, D$, and the $i$-th character is the answer to single-choice question $i$.\n\nThen the next $T \\times (n+2)$ lines contain $T$ groups of information, representing the content of each paper, with the format as described above.", "outputFormat": "For each paper, output the judgment results as described. Insert one blank line between the results of two papers.", "hint": "For 100% of the testdata\n\n$1 \\le T \\le 1000$\n\n$1 \\le n \\le 50$\n\nNotes:\n1. Please also add a newline after processing the last paper.\n2. Due to differences in line endings between Windows and Linux, it is recommended not to use scanf to read char.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "夏幻的考试", "background": "夏之幻是软件工程系的大神，学校把举办考试的任务交给她了。", "description": "某大学软工专业要举办一场笔试，学生们要在机读答题卡上填写答案来进行答题。学校把机读卡识别任务交给了夏之幻，但是这套系统的需求太复杂了，她还要做自己的其他项(you)目(xi)，所以她想让你来帮忙实现一部分功能。\n\n试卷分卷头，单选题两部分。\n\n夏幻大神已经写好了识别程序，因此卷头和答案将直接以数字信息的形式呈现给你，你要实现下面几个功能:\n\n需要处理 $T$ 张试卷，按顺序检查下列选项。\n\n1.检查考号的填写是否准确。\n\n输入信息的格式:\n\n一行，一个 $16$ 位无符号二进制数id。表示考生的考号为id，正确的考号范围在十进制下是 $1 \\sim 10000$。\n\n如果考号有错误，输出一行 `Wrong ID` 并结束对这张试卷的处理(剩下两个选项的数据依然要读入，但不输出任何内容)。如果考号正确，输出一行,`ID: `+ 一个整数，表示考号的十进制形式。\n\n无需考虑考号是否重复，只要在范围内均为正确。\n\n2.检查试卷类型是否正确。\n\n输入信息格式:\n\n一行，两个整数，中间无分隔，只能是 $0$ 或者 $1$。第一个整数表示试卷类型A是否被涂黑($0$ 表示未涂黑，$1$ 表示涂黑)，第二个整数表示试卷类型B是否涂黑。其实试卷类型可以由二进制考号的最后一位得到，$0$ 表示A卷，$1$ 表示B卷，你只需要检查考生填涂的是否正确。\n\n如果考生将试卷类型正确填涂(填涂且只填涂了正确的那一项)，输出一行 `Type Correct`，否则输出一行 `Type Incorrect`。无论试卷类型是否填涂正确，你还需要接着处理这张试卷。\n\n3.给单选题打分。\n\n单选题的数量 $n$ 和标准答案将会在录入第一张试卷前给出。\n\n考生答案的输入格式:\n\n$n$ 行，每行 $4$ 个整数，中间无分隔。每个整数是 $0$ 或 $1$。\n\n按顺序分别代表 $A,B,C,D$ 是否被涂黑($0$ 表示未涂黑，$1$ 表示涂黑)。考生回答正确当且仅当该题正确答案的位置被涂黑，且错误答案的位置未被涂黑。\n\n输出一行，一个四舍五入到小数点后 $1$ 位的浮点数，表示考生的得分，满分为 $100$ 分，每个题的分数相同。", "inputFormat": "第一行两个整数 $T$、$n$，空格分开，含义见题目描述。\n\n接下来一行一个字符串 $s$，长度为 $n$，每个字符是大写字母 $A,B,C,D$ 中的一个，第 $i$ 个字符表示单选题 $i$ 的答案。\n\n接下来 $T \\times (n+2)$ 行含有 $T$ 组信息，表示每张试卷的内容，格式见题目描述。", "outputFormat": "对于每张试卷，输出评判结果，格式见题目描述。两张试卷的评判结果之间空一行。", "hint": "对于100%的数据\n\n$1 \\le T \\le 1000$\n\n$1 \\le n \\le 50$\n\n注意:\n\n1.请在最后一个试卷处理完后也加上一个换行\n\n2.由于win系统和linux系统换行的不同，建议不要使用scanf读入char", "locale": "zh-CN"}}}
{"pid": "P3693", "type": "P", "difficulty": 6, "samples": [["8\n10\n4 0 4 4\n63\nICE_BARRAGE 2 1 1 3\nICE_BARRAGE 0 1 3 1\nMAKE_ICE_BLOCK\nPUT_ICE_BLOCK 3 2 0\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 2 0 6 7\nICE_BARRAGE 3 0 6 7\nICE_BARRAGE 4 0 6 7\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nMAKE_ICE_BLOCK\nPUT_ICE_BLOCK 4 0 1\nPUT_ICE_BLOCK 4 0 0\nPUT_ICE_BLOCK 4 0 1\nPUT_ICE_BLOCK 3 0 1\nREMOVE_ICE_BLOCK 4 0 1\nPUT_ICE_BLOCK 4 2 0\nPUT_ICE_BLOCK 6 1 0\nPUT_ICE_BLOCK 4 3 0\nPUT_ICE_BLOCK 5 3 0\nPUT_ICE_BLOCK 6 3 0\nPUT_ICE_BLOCK 7 3 0\nICE_BARRAGE 0 1 4 7\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nMAKE_ICE_BLOCK\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nMAKE_ICE_BLOCK\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nMAKE_ICE_BLOCK\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nMAKE_ICE_BLOCK\nREMOVE_ICE_BLOCK 6 1 0\nPUT_ICE_BLOCK 5 0 0\nPUT_ICE_BLOCK 6 0 0\nPUT_ICE_BLOCK 7 0 0\nPUT_ICE_BLOCK 7 1 0\nPUT_ICE_BLOCK 7 2 0\nPUT_ICE_BLOCK 4 0 1\nPUT_ICE_BLOCK 5 0 1\nPUT_ICE_BLOCK 6 0 1\nPUT_ICE_BLOCK 7 0 1\nPUT_ICE_BLOCK 7 1 1\nPUT_ICE_BLOCK 7 2 1\nPUT_ICE_BLOCK 7 3 1\nPUT_ICE_BLOCK 6 3 1\nPUT_ICE_BLOCK 5 3 1\nPUT_ICE_BLOCK 4 3 1\nPUT_ICE_BLOCK 4 2 1\nMAKE_ROOF\n", "CIRNO FREEZED 2 BLOCK(S)\nCIRNO FREEZED 2 BLOCK(S)\nCIRNO MADE 0 ICE BLOCK(S),NOW SHE HAS 0 ICE BLOCK(S)\nCIRNO HAS NO ICE_BLOCK\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 7 BLOCK(S)\nCIRNO FREEZED 7 BLOCK(S)\nCIRNO FREEZED 0 BLOCK(S)\nCIRNO MADE 8 ICE BLOCK(S),NOW SHE HAS 8 ICE BLOCK(S)\nBAKA CIRNO,CAN'T PUT HERE\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 7 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 6 ICE_BLOCK(S)\nCIRNO MISSED THE PLACE\nCIRNO REMOVED AN ICE_BLOCK,AND 1 BLOCK(S) ARE BROKEN\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 5 ICE_BLOCK(S)\nCIRNO PUT AN ICE_BLOCK INSIDE THE HOUSE\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 3 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 2 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 1 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 0 ICE_BLOCK(S)\nCIRNO FREEZED 6 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 7 BLOCK(S)\nCIRNO MADE 8 ICE BLOCK(S),NOW SHE HAS 8 ICE BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO MADE 8 ICE BLOCK(S),NOW SHE HAS 16 ICE BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO MADE 8 ICE BLOCK(S),NOW SHE HAS 24 ICE BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO MADE 8 ICE BLOCK(S),NOW SHE HAS 32 ICE BLOCK(S)\nCIRNO REMOVED AN ICE_BLOCK\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 32 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 31 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 30 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 29 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 28 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 27 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 26 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 25 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 24 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 23 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 22 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 21 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 20 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 19 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 18 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 17 ICE_BLOCK(S)\n0 ICE_BLOCK(S) INSIDE THE HOUSE NEED TO BE REMOVED\n0 ICE_BLOCK(S) OUTSIDE THE HOUSE NEED TO BE REMOVED\nGOOD JOB CIRNO,SUCCESSFULLY BUILT THE HOUSE\nDOOR IS OK\nWALL IS OK\nCORNER IS OK\nCIRNO FINALLY HAS 1 ICE_BLOCK(S)\nCIRNO IS PERFECT!\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "洛谷原创", "枚举", "广度优先搜索 BFS", "连通块"], "title": "琪露诺的冰雪小屋", "background": "琪露诺有一片正方形的雪地，她想在上面盖一栋小冰屋。", "description": "琪露诺偶然间得到了一片 $N\\times N$ 大小的正方形的雪地，她想在上面盖一栋冰雪小屋。\n\n但调皮的⑨才不会认真地收集冰块呢，她要在这片土地上使用冰雪弹幕来制造冰砖，然后一块一块地搭起一个房子。\n\n琪露诺制造冰砖的方式是这样的：她会站在某个方格上，然后向上，下，左，右，左上，左下，右上，右下这八个方向之一发射强力的冰雪弹幕，弹幕能影响到该方向一条直线上一定的距离以内的所有方格。\n\n地面的每个方格都有一个冷冻度，初始为 $0$。被冰雪弹幕影响一次，冷冻度 $+1$，冷冻度的上限为 $4$。\n\n在发射弹幕的间隙中，琪露诺会来到所有冷冻度为 $4$ 的格子，把那里的雪堆到一起，制作一个冰砖（大小为 $1\\times1\\times1$ 方格），并且将冷冻度重新归零。\n\n琪露诺会拿着这些冰砖来盖房子。这个房子的长度、宽度和坐落位置她在一开始就已经规划好了，但她并不愿意提早确定房子的高度。\n\n琪露诺是这样计划的：这个房子外观上看起来是一个长方体。\n\n她会先盖起这个房子的四面墙（厚度为 $1$ 个方格），并在贴近地面的位置（废话）留一个宽度和高度分别为 $1$ 和 $2$ 的空位不放冰砖，作为房门。（显然，门无法开在墙的拐角处，但可以紧贴拐角）。\n\n在她喜欢的时候，她会结束四面墙的建造，并一次性在墙顶部盖上一个厚度为 $1$ 方格的屋顶，使房子成为一个空心有顶的长方体。\n\n计划已经非常充分了，但琪露诺还是不放心，所以她想请你帮她写一个程序，来随时提醒着她别出什么差错。这个程序需要具备的功能将在下文详细介绍。\n\n----------------------\n雪地由 $N$ 行 $N$ 列，$N\\times N$ 个方格组成。（下标从 $0$ 开始，也就是说，存在第 $0$ 行第 $0$ 列，但不存在第 $N$ 行第 $N$ 列）每个方格都有一个冷冻度,范围 $[0,4]$，初始为 $0$。注意，空间是三维的，而冷冻度只是地面的属性。\n\n琪露诺想将房子的左上角放在第 $H_R$ 行，$H_C$ 列（外墙也是房子的一部分，因此左上角位置不应该是房子的内部,而是外墙,并且是墙的拐角）。\n\n这个房子的长度（平行于每列）是 $H_X$，宽度（平行于每行）是 $H_Y$，包含墙。保证房子所占空间不会超出雪地的范围。\n\n除了最后搭建屋顶，琪露诺只会在高度 $[0,H_M-1]$ 放置冰砖。\n\n一开始，琪露诺一个冰砖也没有。\n在以下的介绍中，我们用俯视图来作示意：\n```plain\n0000\n0000\n4x90\n0x01\n```\n数字代表当前该格子的冷冻度。如果位置紧贴地面（高度为 $0$）的地方放上了冰砖，那么用字母 $x$ 表示。\n\n如果紧贴地面的位置没有冰砖，但是位置正上方的高空存在冰砖，那么仍然用数字表示地面的冷冻度，但这个数字会增加 $5$。即如果在示意图中看到了一个数字 $t\\ge5$，表示该位置地面是空的，但高处有冰砖，且地面的冷冻度为 $t-5$。\n\n第一个操作：`ICE_BARRAGE R C D S`  \n---------------\n表示琪露诺站在第 $R$ 行 $C$ 列的位置，朝着方向 $D$ 发射了一个强度为 $S$ 的弹幕。  \n$R,C,D,S\\in\\Z,0\\le D\\le7,0\\le R,C,S<N$。  \n方向编号 $0$ 表示上 $(R-1,C)$，$1$ 表示左上 $(R-1,C-1)$，   \n$2$ 表示左 $(R,C-1)$，$3$ 表示左下 $(R+1,C-1)$，  \n$4$ 表示下 $(R+1,C)$，$5$ 表示右下 $(R+1,C+1)$，  \n$6$ 表示右 $(R,C+1)$，$7$ 表示右上 $(R-1,C+1)$。  \n强度为 $S$ 的弹幕，可以使“处在发射方向直线上，距离琪露诺不超过 $S$ 格的所有格子（包括她站的格子）”的冷冻度都 $+1$。有以下几种特殊情况：\n\n1. 如果某个格子冷冻度为 $4$，那么该格子冷冻度不变。\n2. 如果弹幕所经路途上，有一个位置的地面上（高度为 $0$）已经放了冰砖（就是弹幕撞上了琪露诺已经盖了一半的房子），那么弹幕将被阻挡，无法影响到冰砖所在的格子以及冰砖后面被挡住的格子。\n3. 弹幕超出雪地的部分忽略不计。\n\n对于这个操作，需要如下输出一行：`CIRNO FREEZED k BLOCK(S)`  \n如果这个弹幕将某个方格的冷冻度成功增加了 $1$，那么认为这个弹幕冻住了该方格。\n\n`k` 表示这个弹幕总共冻住了多少方格。\n\n如图：发射弹幕前地图如下：\n```plain\n00000\n00000\n00000\n000x0\n00000\n```\n执行操作 `ICE_BARRAGE 1 1 5 4`，地图变为：\n```plain\n00000\n01000\n00100\n000x0\n00000\n```\n输出：`CIRNO FREEZED 2 BLOCK(S)`  \n解释：琪露诺站在第一行第一列，面对右下角发射了一个强度为 $4$ 的弹幕，但弹幕被 `x` 所阻挡，只能影响到 `x` 之前的格子。\n\n第二个操作：`MAKE_ICE_BLOCK`  \n-------------------------\n琪露诺走遍地图上所有冷冻度为 $4$ 的方格，每个方格可以收集一个冰砖，然后将它们的冷冻度归零。 \n\n对于这个操作，你需要给出如下输出一行：`CIRNO MADE x ICE BLOCK(S),NOW SHE HAS y ICE BLOCK(S)`  \n表示琪露诺制造了 $x$ 个冰砖，目前她有 $y$ 个冰砖。  \n比如琪露诺一开始有 $0$ 个冰砖，并且状态如下：\n```plain\n0xxx\n0x4x\n0x9x\n0400\n```\n执行操作 `MAKE_ICE_BLOCK` 后变为\n```plain\n0xxx\n0x0x\n0x5x\n0000\n```\n输出：`CIRNO MADE 3 ICE BLOCK(S),NOW SHE HAS 3 ICE BLOCK(S)`  \n在这个示例中，房子已经完成了一部分，`x` 表示墙，`9` 这个位置地面没有冰砖，但高处有（可以猜出是门）。房间内唯一一块空地、门的位置，以及房间外的一个位置的冷冻度都达到了 $4$，因此可以收集到 $3$ 块冰砖，收集后将三个位置冷冻度都归零。\n\n第三个操作：`PUT_ICE_BLOCK R C H` \n-----------------\n表示在第 $R$ 行，第 $C$ 列，高度为 $H$ 的地方放一个冰砖。$0\\le R,C<N,0\\le H<H_M$。\n\n贴近地面的位置高度为 $0$。如果冰砖放置成功，那么琪露诺库存的冰砖数量将减 $1$。\n\n如果放置的位置贴近地面，该位置冷冻度立即归 $0$。\n\n有以下几种情况，序号越小优先级越高，并且只能满足一种情况。\n\n如果满足 $1$ 的话就忽视后面的，不满足 $1$ 的前提下才可能满足 $2\\cdots\\cdots$ 以此类推。\n\n1. 琪露诺目前没有任何冰砖，无法放置。这种情况下你需要输出：`CIRNO HAS NO ICE_BLOCK`\n2. 冰砖将放在半空中，无法依附其他任何冰砖，或者目标位置已有冰砖了。  \n这种情况下你需要输出一行：`BAKA CIRNO,CAN'T PUT HERE`，并无视此次操作，不做任何工作。\n3. 冰砖放在了规划建造房子的区域之外，即\n$R<H_R$ 或 $R>H_R+H_x-1$  \n或 $C<H_C$ 或 $C>H_C+H_Y-1$。请输出一行：`CIRNO MISSED THE PLACE`  \n尽管琪露诺放错了地方，但你并不能阻止她放置这个冰砖。  \n4. 冰砖留在了房子的内部，本应留空的地方被占用了，即  \n$H_R+1\\le R\\le H_R+H_X-2$ 且 $H_C+1\\le C\\le H_C+H_Y-2$  \n在屋顶的高度固定下来前，我们将所有满足上式的情况都认为是放在了房屋内部。  \n请输出一行：`CIRNO PUT AN ICE_BLOCK INSIDE THE HOUSE`  \n尽管琪露诺放错了地方，但你并不能阻止她放置这个冰砖。\n5. 冰砖放在了正确的位置（不必考虑是否堵住了留给门的地方）  \n请输出一行：`CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS x ICE_BLOCK(S)`  \n`x` 表示放过这块冰砖后琪露诺剩余的冰砖。\n\n第四个操作：`REMOVE_ICE_BLOCK R C H` \n---------\n表示取走第 $R$ 行，第 $C$ 列，高度为 $H$ 处的冰砖。  \n有以下几种情况，序号越小优先级越高，并且只能满足一种情况。\n\n如果满足 $1$ 的话就忽视后面的，不满足 $1$ 的前提下才可能满足 $2\\cdots\\cdots$ 以此类推。\n\n1. 目标位置没有冰砖，输出一行：`BAKA CIRNO,THERE IS NO ICE_BLOCK`\n2. 目标位置有冰砖，并且在这个冰砖被移走后，至少有一个冰砖形成了一个悬空的块。  \n如下面的“侧视图”，`x` 表示冰砖，`0` 表示空位。\n```plain\nxxxx\nx000\nx000\nx000\n```\n$\\ \\ $在移走左上角的冰砖后，第一行右边三个冰砖没有了依靠，形成了一个悬空的连通块，就属于这种情况。  \n$\\ \\ $这个冰砖将成功移走，琪露诺的冰砖库存将会 $+1$。并且所有的悬空连通块都会掉下来摔碎并消失  \n$\\ \\ $（既不会进入冰砖库存，也不会在地面上留有任何痕迹）。  \n$\\ \\ $输出一行：`CIRNO REMOVED AN ICE_BLOCK,AND k BLOCK(S) ARE BROKEN`，`k` 表示摔碎的冰砖数量。  \n3. 琪露诺挪走了冰砖，并且其他冰砖不受任何影响。    \n$\\ \\ \\ $琪露诺的冰砖库存 $+1$，输出一行：`CIRNO REMOVED AN ICE_BLOCK`\n    \n第五个操作：`MAKE_ROOF` \n--------\n这个操作只会出现一次，并且只会作为最后一个操作。  \n这个操作表明琪露诺已经完成了冰雪小屋的四墙，只剩屋顶了！  \n\n一般情况下，琪露诺将放置最后的 $H_X\\times H_Y$ 个冰砖，把它们放置在墙壁最高的高度 $+1$ 的那一层，  \n形成一个屋顶。然后她移除所有多余的冰砖，接下来补好所有残缺的墙壁。\n\n你需要按顺序来执行整个过程，一旦遇到某种用 $\\bullet$ 标识的特殊情况，则执行完该情况后退出流程。\n\n在特殊情况之间所描述的均为一般情况，只要之前没有因为满足某种特殊情况而退出流程，均认为满足了一般情况。\n\n首先，琪露诺将会一次性放置最多 $H_X\\times H_Y$ 个冰砖来建造屋顶。\n\n为什么是最多呢？请注意一点：如果之前错误放置在房子内部的冰砖恰好充当了屋顶的一部分，那么就不用在这个位置再放冰砖了。并且，所有比屋顶高的冰砖在之后将视为错误放置在了房子外部。\n\n注意，放屋顶的时候可能会触及到高度为 $H_M$ 的那个平面。\n\n建造屋顶前后将会碰到两种特殊情况：\n- 琪露诺剩余的冰砖不足以建造屋顶。输出一行：`SORRY CIRNO,NOT ENOUGH ICE_BLOCK(S) TO MAKE ROOF`\n- 墙壁的最高高度小于 $2$ 个方格，或者内部有效空间小于两个方格。  \n墙壁所在的一圈不算内部空间。计算内部有效空间时请忽视错误放置的冰砖，因为它们将来要被移除。  \n输出一行：`SORRY CIRNO,HOUSE IS TOO SMALL`\n\n（特殊情况结束）\n\n此后，我们认为琪露诺已经造好了屋顶，接下来该移除所有多余冰砖了。在移除过程中，琪露诺会尽可能让更少的冰砖摔碎。如果墙壁上某个冰砖因为移走了多余的冰砖而将要摔碎，那么她会先拆掉墙壁上的那个冰砖，然后在填补墙壁残缺时重新补回来（显然，这种行为不会影响到墙壁有无残缺的定性，但可以少损失一个冰砖）。她不会故意拆掉一个处在墙壁上且不会摔碎的冰砖。  \n输出两行：  \n`K1 ICE_BLOCK(S) INSIDE THE HOUSE NEED TO BE REMOVED`  \n`K2 ICE_BLOCK(S) OUTSIDE THE HOUSE NEED TO BE REMOVED`  \n`K1`表示房子内部错误放置的冰砖数量，`K2`表示房子外部错误放置的冰砖数量。\n\n将有可能遭遇一种特殊情况：\n- 琪露诺移除了所有多余的冰砖，但在移除过程中，屋顶塌陷了。  \n输出一行：`SORRY CIRNO,HOUSE IS BROKEN WHEN REMOVING BLOCKS`\n\n（特殊情况结束）\n\n此后，我们认为琪露诺已经移除了所有多余的冰砖，接下来该填补墙壁的残缺了。\n\n墙壁有残缺的定义是：除了宽为 $1$，高为 $2$ 的门以外，\n在房子内部看外面还能看到其他缺口。\n\n如果某个空位将来要作为门的一部分，则不属于残缺。并且房子只能有一个门。\n\n如果墙壁没有残缺，则不要填补，否则需要填补。你需要记下墙壁是否有残缺，之后会用到。\n\n填补的策略是：使用尽可能少的冰砖，在正确的位置填补墙壁，使房屋的状态不满足墙壁有残缺的定义（即不能放置多余的冰砖，通过遮挡视线来达到目的）。在此定义下，**大多数**情况我们无需考虑四角的柱子是否完整，因为在房间里看不到。\n\n将有可能遭遇一种特殊情况：\n- 琪露诺剩余的冰砖不足以填补墙壁的残缺。  \n输出一行：`SORRY CIRNO,NOT ENOUGH ICE_BLOCKS TO FIX THE WALL`\n\n（特殊情况结束）\n\n此后，我们认为房子被成功建成了，这时你需要输出几行内容来对房子进行评价。\n\n首先输出这么一行来庆祝房子的建成：`GOOD JOB CIRNO,SUCCESSFULLY BUILT THE HOUSE`  \n1. 在贴近地面的位置找不到一个宽度为 $1$，高度为 $2$ 的位置留给门。  \n\t输出一行：`HOUSE HAS NO DOOR`，然后琪露诺会尽可能利用墙壁上的残缺来开一个门。  \n    否则，输出一行：`DOOR IS OK`\n2. 接下来输出一行表示填补之前墙壁的完整程度  \n\t2.1. 在之前的记录中，墙壁不完整而需要修补。输出：`WALL NEED TO BE FIXED`  \n    2.2. 在之前的记录中，墙壁完整而无需修补。输出：`WALL IS OK`  \n3. 接下来一行表示四角的完整程度。  \n\t如果四个角的柱子有不完整的地方，就输出：`CORNER NEED TO BE FIXED`  \n    在这种情况下，如果琪露诺剩余的冰砖足够修复拐角的空缺，那么她直接会修复这个空缺。  \n    如果不够的话，她会再多收集几个冰砖，数量恰好修复这个空缺，然后修复这个空缺。  \n    否则，输出：`CORNER IS OK`\n    \n接下来，输出一行：`CIRNO FINALLY HAS k ICE_BLOCK(S)`  \n`k` 表示琪露诺最后剩余的冰砖的数量。\n\n最后，如果在之前的记录中，墙壁完整无缺，没有一个位置需要填补。房子内外都无任何多余的方块，没有一个位置需要移除。没有出现房子没门的情况，房子四角的柱子也在造屋顶前完全造好，而不是通过修补完善的。并且门恰好开在了某面墙的正中央（如果长度为偶数，中间的两个都算），输出一行：   \n`CIRNO IS PERFECT!`", "inputFormat": "第一行一个正整数 $N$，表示雪地的大小。\n\n第二行一个正整数 $H_M$，表示琪露诺放置方块的最大高度。\n\n第三行四个正整数 $H_R,H_C,H_X,H_Y$，表示房子左上角位置的行列坐标，房子的长度以及宽度。\n\n第四行一个正整数 $M$，表示操作的数量。\n\n接下来 $M$ 行，每行表示一个操作，输入格式见题目描述。", "outputFormat": "在题目描述中已经介绍。", "hint": "共分为 $6$ 个 **Subtask**，每个 **Subtask** 的数据都满足一定条件，并且同时满足序号更大的 **Subtask** 的条件。  \n如 **Subtask #0** 同时满足 **Subtask #0~5** 的条件。  \n每一个 **Subtask** 的得分取所有测试点的最低分。\n\n**Subtask #0** $20\\%$  \n琪露诺只想玩玩冰雪弹幕，她不会放置任何冰砖，也不会盖房子(即只有操作一和操作二)。  \n\n\n**Subtask #1** $10\\%$  \n琪露诺不会移除已经放置的冰砖。\n\n**Subtask #2** $20\\%$  \n琪露诺很有信心，她将在没有 `MAKE_ROOF` 的情况下建造她的冰屋(这种情况下，放置方块的高度仍然会小于 $H_M$ 且没有 `MAKE_ROOF` 操作)。\n\n**Subtask #3** $20\\%$  \n琪露诺在移除方块时会谨慎考虑,不会造成任何冰砖摔落。`MAKE_ROOF` 操作移除多余冰砖时，也不会造成屋顶塌陷。\n\n**Subtask #4** $20\\%$  \n琪露诺不喜欢把门开到四角的柱子旁边(数据保证在所有可能作为门的墙壁空缺中，有一种可能使得门不紧贴四角的柱子)。 \n\n**Subtask #5** $10\\%$  \n$4\\le N\\le 16$，$5\\le H_M\\le 20$，$10\\le M\\le 10^3$，保证不属于冰屋范围内的所有空地至多构成一个连通块。\n\n注意：判断墙壁是否有残缺时，候选的开门位如果被方块堵住，在当时还未被清空。\"能看到残缺\"以当时的情况作为判断依据。", "locale": "zh-CN", "translations": {"en": {"title": "Cirno’s Little Ice House", "background": "Cirno has a square snowy field, and she wants to build a small igloo on it.", "description": "Cirno happens to get a square snowy field of size $N \\times N$, and she wants to build an ice house on it.\n\nBut the mischievous ⑨ won’t seriously collect ice blocks; instead, she will use ice barrages on this land to make ice blocks and then stack them one by one to build a house.\n\nCirno makes ice blocks as follows: she stands on some cell, then fires a powerful ice barrage in one of the eight directions: up, down, left, right, up-left, down-left, up-right, down-right. The barrage affects all cells along that straight line within a certain distance.\n\nEach ground cell has a freezing level, initially $0$. When a cell is affected once by an ice barrage, its freezing level increases by $1$, capped at $4$.\n\nBetween shots, Cirno visits all cells whose freezing level is $4$, gathers the snow there to make one ice block (size $1 \\times 1 \\times 1$), and resets their freezing levels to $0$.\n\nCirno will use these ice blocks to build the house. She has already planned the house’s length, width, and placement at the start, but she is unwilling to decide the house’s height in advance.\n\nCirno’s plan: the house should look like a rectangular cuboid.\n\nShe will first build the four walls (thickness $1$ cell), and near the ground (of course) leave a $1$-wide and $2$-high opening as a door. (Obviously, the door cannot be at a wall corner, but it can be adjacent to a corner.)\n\nWhenever she likes, she will stop building the walls and put a $1$-thick roof over the top in one go, making the house a hollow, roofed cuboid.\n\nThe plan is well prepared, yet Cirno still wants your help to write a program to remind her not to mess up. The required features of this program are described below.\n\n----------------------\nThe field consists of $N$ rows and $N$ columns, $N \\times N$ cells in total. (Indexing starts from $0$, i.e., row $0$ and column $0$ exist, while row $N$ and column $N$ do not.) Each cell has a freezing level in $[0,4]$, initially $0$. Note that space is three-dimensional, while the freezing level is an attribute of the ground.\n\nCirno wants to place the top-left corner of the house at row $H_R$, column $H_C$ (the outer wall is part of the house, so the top-left corner is not inside the house; it is on the outer wall and is the corner of the wall).\n\nThe house’s length (parallel to columns) is $H_X$, and its width (parallel to rows) is $H_Y$, including the walls. It is guaranteed that the house stays within the field.\n\nExcept for placing the final roof, Cirno will only place ice blocks at heights in $[0, H_M - 1]$.\n\nInitially, Cirno has no ice blocks.\nIn the following illustrations, we use a top-down view:\n```plain\n0000\n0000\n4x90\n0x01\n```\nNumbers represent the current freezing level of a ground cell. If an ice block is placed at ground level (height $0$), we mark it by the letter x.\n\nIf there is no ice block at ground level, but there is an ice block somewhere directly above that position, we still use a number to indicate the ground freezing level, but add $5$ to it. That is, if you see a number $t \\ge 5$, it means the ground is empty, but there is an ice block above, and the ground freezing level is $t - 5$.\n\nFirst operation: ICE_BARRAGE R C D S  \n---------------\nCirno stands at row $R$, column $C$, and fires a barrage of strength $S$ toward direction $D$.  \n$R, C, D, S \\in \\Z, 0 \\le D \\le 7, 0 \\le R, C, S < N$.  \nDirection indices: $0$ means up $(R-1, C)$, $1$ means up-left $(R-1, C-1)$,  \n$2$ means left $(R, C-1)$, $3$ means down-left $(R+1, C-1)$,  \n$4$ means down $(R+1, C)$, $5$ means down-right $(R+1, C+1)$,  \n$6$ means right $(R, C+1)$, $7$ means up-right $(R-1, C+1)$.  \nA barrage of strength $S$ increases by $1$ the freezing level of every cell “on the shooting line in that direction, within distance at most $S$ from Cirno (including the cell she stands on).” Special cases:\n\n1. If a cell’s freezing level is $4$, it does not change.\n2. If the barrage path encounters an ice block placed on the ground (height $0$) at some position (i.e., the barrage hits a partially built house), the barrage is blocked and cannot affect that cell or any cells behind it.\n3. Any portion of the barrage outside the field is ignored.\n\nFor this operation, output one line: CIRNO FREEZED k BLOCK(S)  \nIf this barrage successfully increases a cell’s freezing level by $1$, we say the barrage has frozen that cell.\n\nk is the total number of cells frozen by this barrage.\n\nExample: Before firing, the map is:\n```plain\n00000\n00000\n00000\n000x0\n00000\n```\nAfter executing ICE_BARRAGE 1 1 5 4, the map becomes:\n```plain\n00000\n01000\n00100\n000x0\n00000\n```\nOutput: CIRNO FREEZED 2 BLOCK(S)  \nExplanation: Cirno stands at row $1$, column $1$, fires a barrage of strength $4$ toward down-right, but it is blocked by x and only affects cells before x.\n\nSecond operation: MAKE_ICE_BLOCK  \n-------------------------\nCirno traverses all cells with freezing level $4$, gathers one ice block from each, and resets their freezing levels to $0$.\n\nFor this operation, output one line: CIRNO MADE x ICE BLOCK(S),NOW SHE HAS y ICE BLOCK(S)  \nThis means Cirno made x ice blocks and now has y ice blocks.  \nFor example, Cirno initially has $0$ ice blocks, and the map is:\n```plain\n0xxx\n0x4x\n0x9x\n0400\n```\nAfter executing MAKE_ICE_BLOCK, it becomes:\n```plain\n0xxx\n0x0x\n0x5x\n0000\n```\nOutput: CIRNO MADE 3 ICE BLOCK(S),NOW SHE HAS 3 ICE BLOCK(S)  \nIn this example, part of the house is already built, x denotes walls, and the 9 indicates that the ground at that position is empty but there is an ice block above (you can guess it’s the door). The only empty cell inside the room, the door position, and one position outside the room have freezing level $4$, so $3$ ice blocks can be collected. After collecting, these three cells are reset to $0$.\n\nThird operation: PUT_ICE_BLOCK R C H \n-----------------\nPlace an ice block at row $R$, column $C$, height $H$. $0 \\le R, C < N, 0 \\le H < H_M$.\n\nGround level is height $0$. If placement succeeds, Cirno’s stock decreases by $1$.\n\nIf the block is placed at ground level, the cell’s freezing level is immediately reset to $0$.\n\nThere are several cases; smaller indices have higher priority, and exactly one case applies.\n\nOnly if case 1 is not satisfied can case 2 be considered, and so on.\n\n1. Cirno currently has no ice blocks and cannot place one. Output: CIRNO HAS NO ICE_BLOCK\n2. The ice block would be floating in the air, not attached to any other ice block, or the target position is already occupied.  \nIn this case, output one line: BAKA CIRNO,CAN'T PUT HERE, and ignore this operation entirely.\n3. The ice block is placed outside the planned house area, i.e.,\n$R < H_R$ or $R > H_R + H_X - 1$  \nor $C < H_C$ or $C > H_C + H_Y - 1$. Output one line: CIRNO MISSED THE PLACE  \nEven though Cirno misplaced the block, you cannot stop her from placing it.\n4. The ice block is placed inside the house, occupying a space that should be kept empty, i.e.,  \n$H_R + 1 \\le R \\le H_R + H_X - 2$ and $H_C + 1 \\le C \\le H_C + H_Y - 2$  \nBefore the roof height is finalized, we consider all positions satisfying the above as inside the house.  \nOutput one line: CIRNO PUT AN ICE_BLOCK INSIDE THE HOUSE  \nEven though Cirno misplaced the block, you cannot stop her from placing it.\n5. The ice block is placed at a correct position (ignore whether it blocks the reserved door space).  \nOutput one line: CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS x ICE_BLOCK(S)  \nx is the remaining number of ice blocks after placing this one.\n\nFourth operation: REMOVE_ICE_BLOCK R C H \n---------\nRemove the ice block at row $R$, column $C$, height $H$.  \nThere are several cases; smaller indices have higher priority, and exactly one case applies.\n\nOnly if case 1 is not satisfied can case 2 be considered, and so on.\n\n1. There is no ice block at the target position. Output: BAKA CIRNO,THERE IS NO ICE_BLOCK\n2. There is an ice block at the target position, and after removing it, at least one connected component of ice blocks becomes floating.  \nAs in the following “side view,” x denotes an ice block and 0 denotes empty:\n```plain\nxxxx\nx000\nx000\nx000\n```\nAfter removing the top-left ice block, the three blocks to its right in the top row lose support and form a floating connected component, which belongs to this case.  \nThis ice block is successfully removed, Cirno’s stock increases by $1$, and all floating connected components fall and shatter, disappearing completely  \n(neither added to the stock nor leaving any trace on the ground).  \nOutput: CIRNO REMOVED AN ICE_BLOCK,AND k BLOCK(S) ARE BROKEN, where k is the number of shattered blocks.\n3. Cirno removes the ice block and no other block is affected.  \nCirno’s stock increases by $1$. Output: CIRNO REMOVED AN ICE_BLOCK\n\nFifth operation: MAKE_ROOF \n--------\nThis operation appears exactly once and only as the last operation.  \nIt indicates that Cirno has finished the four walls and only the roof remains!\n\nIn the general case, Cirno places the final $H_X \\times H_Y$ ice blocks at the layer one unit above the highest height of the walls to form a roof. Then she removes all excessive blocks and repairs any defects in the walls.\n\nYou must execute the entire process in order. As soon as one of the special cases marked with • occurs, finish that special case and then terminate the process.\n\nEverything described between special cases is the general case, and is assumed to occur unless a special case has already caused an early exit.\n\nFirst, Cirno will place at most $H_X \\times H_Y$ ice blocks at once to build the roof.\n\nWhy “at most”? Note that if previously misplaced blocks inside the house happen to serve as part of the roof, then no additional block is needed at those positions. Also, any blocks above the roof will later be treated as misplaced outside the house.\n\nNote: while placing the roof, the plane at height $H_M$ might be touched.\n\nTwo special cases may occur before or after building the roof:\n- Cirno does not have enough ice blocks to build the roof. Output: SORRY CIRNO,NOT ENOUGH ICE_BLOCK(S) TO MAKE ROOF\n- The highest wall height is less than $2$ cells, or the interior usable space is less than two cells.  \nThe ring occupied by the walls is not counted as interior space. When computing interior usable space, ignore misplaced blocks because they will be removed later.  \nOutput: SORRY CIRNO,HOUSE IS TOO SMALL\n\n(Special cases end.)\n\nAfter this, assume Cirno has built the roof. Next, remove all excessive blocks. During removal, Cirno will try to minimize the number of blocks that shatter. If some wall block would shatter as a consequence of removing excessive blocks, she will first take down that wall block and then restore it when repairing the wall (clearly, this does not change whether the wall has defects, but it saves a block). She will not deliberately remove a wall block that would not shatter.  \nOutput two lines:  \nK1 ICE_BLOCK(S) INSIDE THE HOUSE NEED TO BE REMOVED  \nK2 ICE_BLOCK(S) OUTSIDE THE HOUSE NEED TO BE REMOVED  \nK1 is the number of misplaced blocks inside the house; K2 is the number outside the house.\n\nOne special case may occur:\n- Cirno removes all excessive blocks, but the roof collapses during removal.  \nOutput: SORRY CIRNO,HOUSE IS BROKEN WHEN REMOVING BLOCKS\n\n(Special cases end.)\n\nAfter this, assume all excessive blocks have been removed. Next, repair any defects in the walls.\n\nDefinition of having wall defects: excluding the $1$-wide and $2$-high door, if from inside the house you can still see the outside through other openings, then the wall has defects.\n\nIf an empty spot is intended to be part of the door, it is not a defect. The house can have only one door.\n\nIf the walls have no defects, do not repair; otherwise, repair. You must record whether the walls had defects; this will be used later.\n\nRepair strategy: use as few blocks as possible, at correct positions, to make the house no longer meet the definition of having wall defects (i.e., do not place extra blocks just to block line of sight). Under this definition, in most cases we can ignore the completeness of the four corner pillars because they are not visible from inside the room.\n\nOne special case may occur:\n- Cirno does not have enough ice blocks to fix the wall defects.  \nOutput: SORRY CIRNO,NOT ENOUGH ICE_BLOCKS TO FIX THE WALL\n\n(Special cases end.)\n\nAfter this, assume the house has been successfully built. You must output several lines to evaluate the house.\n\nFirst, celebrate the completion: GOOD JOB CIRNO,SUCCESSFULLY BUILT THE HOUSE  \n1. If at ground level no $1$-wide and $2$-high opening can be reserved for the door,  \n\toutput: HOUSE HAS NO DOOR, and then Cirno will try to utilize wall defects to open a door.  \n    Otherwise, output: DOOR IS OK\n2. Next, output one line describing the wall’s completeness before repairs:  \n\t2.1. If the earlier record says the wall was incomplete and needed repairs, output: WALL NEED TO BE FIXED  \n    2.2. If the earlier record says the wall was complete and needed no repairs, output: WALL IS OK\n3. Next, one line about the completeness of the four corners.  \n\tIf any of the four corner pillars is incomplete, output: CORNER NEED TO BE FIXED  \n    In this case, if Cirno has enough blocks to fix the corner gaps, she will fix them immediately.  \n    If not, she will collect just enough additional blocks and then fix the gaps.  \n    Otherwise, output: CORNER IS OK\n    \nFinally, output: CIRNO FINALLY HAS k ICE_BLOCK(S)  \nk is the number of ice blocks Cirno has in the end.\n\nLastly, if the earlier record shows the walls were flawless with no positions to repair, there were no extra blocks either inside or outside the house with no positions to remove, no “house has no door” situation occurred, the four corners were fully built before making the roof (not completed via later repairs), and the door is exactly at the center of some wall (if even length, either of the two middle positions counts), then output:  \nCIRNO IS PERFECT!", "inputFormat": "The first line contains a positive integer $N$, the size of the field.\n\nThe second line contains a positive integer $H_M$, the maximum height at which Cirno may place blocks.\n\nThe third line contains four positive integers $H_R, H_C, H_X, H_Y$, the row and column of the top-left corner of the house, and the house’s length and width.\n\nThe fourth line contains a positive integer $M$, the number of operations.\n\nThe next $M$ lines each contain one operation; see the Description for formats.", "outputFormat": "As described in the problem statement.", "hint": "There are $6$ Subtasks. Each Subtask’s testdata satisfies certain conditions and also satisfies those of all Subtasks with larger indices.  \nFor example, Subtask #0 also satisfies the conditions of Subtasks #0–5.  \nEach Subtask’s score is the minimum across all its test points.\n\nSubtask #0 20%  \nCirno only wants to play with ice barrages. She will not place any ice blocks and will not build the house (i.e., only operations 1 and 2).\n\nSubtask #1 10%  \nCirno will not remove already placed ice blocks.\n\nSubtask #2 20%  \nCirno is confident; she will build her igloo without MAKE_ROOF (in this case, the placement heights are still less than $H_M$, and there is no MAKE_ROOF operation).\n\nSubtask #3 20%  \nCirno will be cautious when removing blocks and will not cause any ice blocks to fall. During MAKE_ROOF, removing excessive blocks will not cause the roof to collapse.\n\nSubtask #4 20%  \nCirno dislikes placing the door next to a corner pillar (the testdata guarantees that among all possible wall openings for the door, there exists an option where the door is not adjacent to a corner pillar).\n\nSubtask #5 10%  \n$4 \\le N \\le 16$, $5 \\le H_M \\le 20$, $10 \\le M \\le 10^3$, and all empty ground cells outside the house area form at most one connected component.\n\nNote: When judging whether the wall has defects, if a candidate door opening is blocked by a block at that time, it is still considered blocked. “Can see the defect” is judged based on the state at that moment.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "琪露诺的冰雪小屋", "background": "琪露诺有一片正方形的雪地，她想在上面盖一栋小冰屋。", "description": "琪露诺偶然间得到了一片 $N\\times N$ 大小的正方形的雪地，她想在上面盖一栋冰雪小屋。\n\n但调皮的⑨才不会认真地收集冰块呢，她要在这片土地上使用冰雪弹幕来制造冰砖，然后一块一块地搭起一个房子。\n\n琪露诺制造冰砖的方式是这样的：她会站在某个方格上，然后向上，下，左，右，左上，左下，右上，右下这八个方向之一发射强力的冰雪弹幕，弹幕能影响到该方向一条直线上一定的距离以内的所有方格。\n\n地面的每个方格都有一个冷冻度，初始为 $0$。被冰雪弹幕影响一次，冷冻度 $+1$，冷冻度的上限为 $4$。\n\n在发射弹幕的间隙中，琪露诺会来到所有冷冻度为 $4$ 的格子，把那里的雪堆到一起，制作一个冰砖（大小为 $1\\times1\\times1$ 方格），并且将冷冻度重新归零。\n\n琪露诺会拿着这些冰砖来盖房子。这个房子的长度、宽度和坐落位置她在一开始就已经规划好了，但她并不愿意提早确定房子的高度。\n\n琪露诺是这样计划的：这个房子外观上看起来是一个长方体。\n\n她会先盖起这个房子的四面墙（厚度为 $1$ 个方格），并在贴近地面的位置（废话）留一个宽度和高度分别为 $1$ 和 $2$ 的空位不放冰砖，作为房门。（显然，门无法开在墙的拐角处，但可以紧贴拐角）。\n\n在她喜欢的时候，她会结束四面墙的建造，并一次性在墙顶部盖上一个厚度为 $1$ 方格的屋顶，使房子成为一个空心有顶的长方体。\n\n计划已经非常充分了，但琪露诺还是不放心，所以她想请你帮她写一个程序，来随时提醒着她别出什么差错。这个程序需要具备的功能将在下文详细介绍。\n\n----------------------\n雪地由 $N$ 行 $N$ 列，$N\\times N$ 个方格组成。（下标从 $0$ 开始，也就是说，存在第 $0$ 行第 $0$ 列，但不存在第 $N$ 行第 $N$ 列）每个方格都有一个冷冻度,范围 $[0,4]$，初始为 $0$。注意，空间是三维的，而冷冻度只是地面的属性。\n\n琪露诺想将房子的左上角放在第 $H_R$ 行，$H_C$ 列（外墙也是房子的一部分，因此左上角位置不应该是房子的内部,而是外墙,并且是墙的拐角）。\n\n这个房子的长度（平行于每列）是 $H_X$，宽度（平行于每行）是 $H_Y$，包含墙。保证房子所占空间不会超出雪地的范围。\n\n除了最后搭建屋顶，琪露诺只会在高度 $[0,H_M-1]$ 放置冰砖。\n\n一开始，琪露诺一个冰砖也没有。\n在以下的介绍中，我们用俯视图来作示意：\n```plain\n0000\n0000\n4x90\n0x01\n```\n数字代表当前该格子的冷冻度。如果位置紧贴地面（高度为 $0$）的地方放上了冰砖，那么用字母 $x$ 表示。\n\n如果紧贴地面的位置没有冰砖，但是位置正上方的高空存在冰砖，那么仍然用数字表示地面的冷冻度，但这个数字会增加 $5$。即如果在示意图中看到了一个数字 $t\\ge5$，表示该位置地面是空的，但高处有冰砖，且地面的冷冻度为 $t-5$。\n\n第一个操作：`ICE_BARRAGE R C D S`  \n---------------\n表示琪露诺站在第 $R$ 行 $C$ 列的位置，朝着方向 $D$ 发射了一个强度为 $S$ 的弹幕。  \n$R,C,D,S\\in\\Z,0\\le D\\le7,0\\le R,C,S<N$。  \n方向编号 $0$ 表示上 $(R-1,C)$，$1$ 表示左上 $(R-1,C-1)$，   \n$2$ 表示左 $(R,C-1)$，$3$ 表示左下 $(R+1,C-1)$，  \n$4$ 表示下 $(R+1,C)$，$5$ 表示右下 $(R+1,C+1)$，  \n$6$ 表示右 $(R,C+1)$，$7$ 表示右上 $(R-1,C+1)$。  \n强度为 $S$ 的弹幕，可以使“处在发射方向直线上，距离琪露诺不超过 $S$ 格的所有格子（包括她站的格子）”的冷冻度都 $+1$。有以下几种特殊情况：\n\n1. 如果某个格子冷冻度为 $4$，那么该格子冷冻度不变。\n2. 如果弹幕所经路途上，有一个位置的地面上（高度为 $0$）已经放了冰砖（就是弹幕撞上了琪露诺已经盖了一半的房子），那么弹幕将被阻挡，无法影响到冰砖所在的格子以及冰砖后面被挡住的格子。\n3. 弹幕超出雪地的部分忽略不计。\n\n对于这个操作，需要如下输出一行：`CIRNO FREEZED k BLOCK(S)`  \n如果这个弹幕将某个方格的冷冻度成功增加了 $1$，那么认为这个弹幕冻住了该方格。\n\n`k` 表示这个弹幕总共冻住了多少方格。\n\n如图：发射弹幕前地图如下：\n```plain\n00000\n00000\n00000\n000x0\n00000\n```\n执行操作 `ICE_BARRAGE 1 1 5 4`，地图变为：\n```plain\n00000\n01000\n00100\n000x0\n00000\n```\n输出：`CIRNO FREEZED 2 BLOCK(S)`  \n解释：琪露诺站在第一行第一列，面对右下角发射了一个强度为 $4$ 的弹幕，但弹幕被 `x` 所阻挡，只能影响到 `x` 之前的格子。\n\n第二个操作：`MAKE_ICE_BLOCK`  \n-------------------------\n琪露诺走遍地图上所有冷冻度为 $4$ 的方格，每个方格可以收集一个冰砖，然后将它们的冷冻度归零。 \n\n对于这个操作，你需要给出如下输出一行：`CIRNO MADE x ICE BLOCK(S),NOW SHE HAS y ICE BLOCK(S)`  \n表示琪露诺制造了 $x$ 个冰砖，目前她有 $y$ 个冰砖。  \n比如琪露诺一开始有 $0$ 个冰砖，并且状态如下：\n```plain\n0xxx\n0x4x\n0x9x\n0400\n```\n执行操作 `MAKE_ICE_BLOCK` 后变为\n```plain\n0xxx\n0x0x\n0x5x\n0000\n```\n输出：`CIRNO MADE 3 ICE BLOCK(S),NOW SHE HAS 3 ICE BLOCK(S)`  \n在这个示例中，房子已经完成了一部分，`x` 表示墙，`9` 这个位置地面没有冰砖，但高处有（可以猜出是门）。房间内唯一一块空地、门的位置，以及房间外的一个位置的冷冻度都达到了 $4$，因此可以收集到 $3$ 块冰砖，收集后将三个位置冷冻度都归零。\n\n第三个操作：`PUT_ICE_BLOCK R C H` \n-----------------\n表示在第 $R$ 行，第 $C$ 列，高度为 $H$ 的地方放一个冰砖。$0\\le R,C<N,0\\le H<H_M$。\n\n贴近地面的位置高度为 $0$。如果冰砖放置成功，那么琪露诺库存的冰砖数量将减 $1$。\n\n如果放置的位置贴近地面，该位置冷冻度立即归 $0$。\n\n有以下几种情况，序号越小优先级越高，并且只能满足一种情况。\n\n如果满足 $1$ 的话就忽视后面的，不满足 $1$ 的前提下才可能满足 $2\\cdots\\cdots$ 以此类推。\n\n1. 琪露诺目前没有任何冰砖，无法放置。这种情况下你需要输出：`CIRNO HAS NO ICE_BLOCK`\n2. 冰砖将放在半空中，无法依附其他任何冰砖，或者目标位置已有冰砖了。  \n这种情况下你需要输出一行：`BAKA CIRNO,CAN'T PUT HERE`，并无视此次操作，不做任何工作。\n3. 冰砖放在了规划建造房子的区域之外，即\n$R<H_R$ 或 $R>H_R+H_x-1$  \n或 $C<H_C$ 或 $C>H_C+H_Y-1$。请输出一行：`CIRNO MISSED THE PLACE`  \n尽管琪露诺放错了地方，但你并不能阻止她放置这个冰砖。  \n4. 冰砖留在了房子的内部，本应留空的地方被占用了，即  \n$H_R+1\\le R\\le H_R+H_X-2$ 且 $H_C+1\\le C\\le H_C+H_Y-2$  \n在屋顶的高度固定下来前，我们将所有满足上式的情况都认为是放在了房屋内部。  \n请输出一行：`CIRNO PUT AN ICE_BLOCK INSIDE THE HOUSE`  \n尽管琪露诺放错了地方，但你并不能阻止她放置这个冰砖。\n5. 冰砖放在了正确的位置（不必考虑是否堵住了留给门的地方）  \n请输出一行：`CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS x ICE_BLOCK(S)`  \n`x` 表示放过这块冰砖后琪露诺剩余的冰砖。\n\n第四个操作：`REMOVE_ICE_BLOCK R C H` \n---------\n表示取走第 $R$ 行，第 $C$ 列，高度为 $H$ 处的冰砖。  \n有以下几种情况，序号越小优先级越高，并且只能满足一种情况。\n\n如果满足 $1$ 的话就忽视后面的，不满足 $1$ 的前提下才可能满足 $2\\cdots\\cdots$ 以此类推。\n\n1. 目标位置没有冰砖，输出一行：`BAKA CIRNO,THERE IS NO ICE_BLOCK`\n2. 目标位置有冰砖，并且在这个冰砖被移走后，至少有一个冰砖形成了一个悬空的块。  \n如下面的“侧视图”，`x` 表示冰砖，`0` 表示空位。\n```plain\nxxxx\nx000\nx000\nx000\n```\n$\\ \\ $在移走左上角的冰砖后，第一行右边三个冰砖没有了依靠，形成了一个悬空的连通块，就属于这种情况。  \n$\\ \\ $这个冰砖将成功移走，琪露诺的冰砖库存将会 $+1$。并且所有的悬空连通块都会掉下来摔碎并消失  \n$\\ \\ $（既不会进入冰砖库存，也不会在地面上留有任何痕迹）。  \n$\\ \\ $输出一行：`CIRNO REMOVED AN ICE_BLOCK,AND k BLOCK(S) ARE BROKEN`，`k` 表示摔碎的冰砖数量。  \n3. 琪露诺挪走了冰砖，并且其他冰砖不受任何影响。    \n$\\ \\ \\ $琪露诺的冰砖库存 $+1$，输出一行：`CIRNO REMOVED AN ICE_BLOCK`\n    \n第五个操作：`MAKE_ROOF` \n--------\n这个操作只会出现一次，并且只会作为最后一个操作。  \n这个操作表明琪露诺已经完成了冰雪小屋的四墙，只剩屋顶了！  \n\n一般情况下，琪露诺将放置最后的 $H_X\\times H_Y$ 个冰砖，把它们放置在墙壁最高的高度 $+1$ 的那一层，  \n形成一个屋顶。然后她移除所有多余的冰砖，接下来补好所有残缺的墙壁。\n\n你需要按顺序来执行整个过程，一旦遇到某种用 $\\bullet$ 标识的特殊情况，则执行完该情况后退出流程。\n\n在特殊情况之间所描述的均为一般情况，只要之前没有因为满足某种特殊情况而退出流程，均认为满足了一般情况。\n\n首先，琪露诺将会一次性放置最多 $H_X\\times H_Y$ 个冰砖来建造屋顶。\n\n为什么是最多呢？请注意一点：如果之前错误放置在房子内部的冰砖恰好充当了屋顶的一部分，那么就不用在这个位置再放冰砖了。并且，所有比屋顶高的冰砖在之后将视为错误放置在了房子外部。\n\n注意，放屋顶的时候可能会触及到高度为 $H_M$ 的那个平面。\n\n建造屋顶前后将会碰到两种特殊情况：\n- 琪露诺剩余的冰砖不足以建造屋顶。输出一行：`SORRY CIRNO,NOT ENOUGH ICE_BLOCK(S) TO MAKE ROOF`\n- 墙壁的最高高度小于 $2$ 个方格，或者内部有效空间小于两个方格。  \n墙壁所在的一圈不算内部空间。计算内部有效空间时请忽视错误放置的冰砖，因为它们将来要被移除。  \n输出一行：`SORRY CIRNO,HOUSE IS TOO SMALL`\n\n（特殊情况结束）\n\n此后，我们认为琪露诺已经造好了屋顶，接下来该移除所有多余冰砖了。在移除过程中，琪露诺会尽可能让更少的冰砖摔碎。如果墙壁上某个冰砖因为移走了多余的冰砖而将要摔碎，那么她会先拆掉墙壁上的那个冰砖，然后在填补墙壁残缺时重新补回来（显然，这种行为不会影响到墙壁有无残缺的定性，但可以少损失一个冰砖）。她不会故意拆掉一个处在墙壁上且不会摔碎的冰砖。  \n输出两行：  \n`K1 ICE_BLOCK(S) INSIDE THE HOUSE NEED TO BE REMOVED`  \n`K2 ICE_BLOCK(S) OUTSIDE THE HOUSE NEED TO BE REMOVED`  \n`K1`表示房子内部错误放置的冰砖数量，`K2`表示房子外部错误放置的冰砖数量。\n\n将有可能遭遇一种特殊情况：\n- 琪露诺移除了所有多余的冰砖，但在移除过程中，屋顶塌陷了。  \n输出一行：`SORRY CIRNO,HOUSE IS BROKEN WHEN REMOVING BLOCKS`\n\n（特殊情况结束）\n\n此后，我们认为琪露诺已经移除了所有多余的冰砖，接下来该填补墙壁的残缺了。\n\n墙壁有残缺的定义是：除了宽为 $1$，高为 $2$ 的门以外，\n在房子内部看外面还能看到其他缺口。\n\n如果某个空位将来要作为门的一部分，则不属于残缺。并且房子只能有一个门。\n\n如果墙壁没有残缺，则不要填补，否则需要填补。你需要记下墙壁是否有残缺，之后会用到。\n\n填补的策略是：使用尽可能少的冰砖，在正确的位置填补墙壁，使房屋的状态不满足墙壁有残缺的定义（即不能放置多余的冰砖，通过遮挡视线来达到目的）。在此定义下，**大多数**情况我们无需考虑四角的柱子是否完整，因为在房间里看不到。\n\n将有可能遭遇一种特殊情况：\n- 琪露诺剩余的冰砖不足以填补墙壁的残缺。  \n输出一行：`SORRY CIRNO,NOT ENOUGH ICE_BLOCKS TO FIX THE WALL`\n\n（特殊情况结束）\n\n此后，我们认为房子被成功建成了，这时你需要输出几行内容来对房子进行评价。\n\n首先输出这么一行来庆祝房子的建成：`GOOD JOB CIRNO,SUCCESSFULLY BUILT THE HOUSE`  \n1. 在贴近地面的位置找不到一个宽度为 $1$，高度为 $2$ 的位置留给门。  \n\t输出一行：`HOUSE HAS NO DOOR`，然后琪露诺会尽可能利用墙壁上的残缺来开一个门。  \n    否则，输出一行：`DOOR IS OK`\n2. 接下来输出一行表示填补之前墙壁的完整程度  \n\t2.1. 在之前的记录中，墙壁不完整而需要修补。输出：`WALL NEED TO BE FIXED`  \n    2.2. 在之前的记录中，墙壁完整而无需修补。输出：`WALL IS OK`  \n3. 接下来一行表示四角的完整程度。  \n\t如果四个角的柱子有不完整的地方，就输出：`CORNER NEED TO BE FIXED`  \n    在这种情况下，如果琪露诺剩余的冰砖足够修复拐角的空缺，那么她直接会修复这个空缺。  \n    如果不够的话，她会再多收集几个冰砖，数量恰好修复这个空缺，然后修复这个空缺。  \n    否则，输出：`CORNER IS OK`\n    \n接下来，输出一行：`CIRNO FINALLY HAS k ICE_BLOCK(S)`  \n`k` 表示琪露诺最后剩余的冰砖的数量。\n\n最后，如果在之前的记录中，墙壁完整无缺，没有一个位置需要填补。房子内外都无任何多余的方块，没有一个位置需要移除。没有出现房子没门的情况，房子四角的柱子也在造屋顶前完全造好，而不是通过修补完善的。并且门恰好开在了某面墙的正中央（如果长度为偶数，中间的两个都算），输出一行：   \n`CIRNO IS PERFECT!`", "inputFormat": "第一行一个正整数 $N$，表示雪地的大小。\n\n第二行一个正整数 $H_M$，表示琪露诺放置方块的最大高度。\n\n第三行四个正整数 $H_R,H_C,H_X,H_Y$，表示房子左上角位置的行列坐标，房子的长度以及宽度。\n\n第四行一个正整数 $M$，表示操作的数量。\n\n接下来 $M$ 行，每行表示一个操作，输入格式见题目描述。", "outputFormat": "在题目描述中已经介绍。", "hint": "共分为 $6$ 个 **Subtask**，每个 **Subtask** 的数据都满足一定条件，并且同时满足序号更大的 **Subtask** 的条件。  \n如 **Subtask #0** 同时满足 **Subtask #0~5** 的条件。  \n每一个 **Subtask** 的得分取所有测试点的最低分。\n\n**Subtask #0** $20\\%$  \n琪露诺只想玩玩冰雪弹幕，她不会放置任何冰砖，也不会盖房子(即只有操作一和操作二)。  \n\n\n**Subtask #1** $10\\%$  \n琪露诺不会移除已经放置的冰砖。\n\n**Subtask #2** $20\\%$  \n琪露诺很有信心，她将在没有 `MAKE_ROOF` 的情况下建造她的冰屋(这种情况下，放置方块的高度仍然会小于 $H_M$ 且没有 `MAKE_ROOF` 操作)。\n\n**Subtask #3** $20\\%$  \n琪露诺在移除方块时会谨慎考虑,不会造成任何冰砖摔落。`MAKE_ROOF` 操作移除多余冰砖时，也不会造成屋顶塌陷。\n\n**Subtask #4** $20\\%$  \n琪露诺不喜欢把门开到四角的柱子旁边(数据保证在所有可能作为门的墙壁空缺中，有一种可能使得门不紧贴四角的柱子)。 \n\n**Subtask #5** $10\\%$  \n$4\\le N\\le 16$，$5\\le H_M\\le 20$，$10\\le M\\le 10^3$，保证不属于冰屋范围内的所有空地至多构成一个连通块。\n\n注意：判断墙壁是否有残缺时，候选的开门位如果被方块堵住，在当时还未被清空。\"能看到残缺\"以当时的情况作为判断依据。", "locale": "zh-CN"}}}
{"pid": "P3694", "type": "P", "difficulty": 5, "samples": [["12 4\n1\n3\n2\n4\n2\n1\n2\n3\n1\n1\n3\n4", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["枚举", "前缀和", "洛谷月赛", "状压 DP"], "title": "邦邦的大合唱站队", "background": "BanG Dream! 里的所有偶像乐队要一起大合唱，不过在排队上出了一些问题。", "description": "$N$ 个偶像排成一列，他们来自 $M$ 个不同的乐队。每个团队至少有一个偶像。\n\n现在要求重新安排队列，使来自同一乐队的偶像连续的站在一起。重新安排的办法是，让若干偶像出列（剩下的偶像不动），然后让出列的偶像一个个归队到原来的空位，归队的位置任意。\n\n请问最少让多少偶像出列？", "inputFormat": "第一行 $2$ 个整数 $N,M$。\n\n接下来 $N$ 行，每行一个整数 $a_i(1\\le a_i \\le M)$，表示队列中第 $i$ 个偶像的团队编号。", "outputFormat": "一个整数，表示答案。", "hint": "【样例解释】\n\n```cpp\n1  3   √\n3  3\n2  3   √\n4  4\n2  4   √\n1  2   √\n2  2\n3  2   √\n1  1\n1  1\n3  1   √\n4  1   √\n```\n【数据规模】\n\n对于 $20\\%$ 的数据，$N\\le 20, M=2$；\n\n对于 $40\\%$ 的数据，$N\\le 100, M\\le 4$；\n\n对于 $70\\%$ 的数据，$N\\le 2000, M\\le 10$；\n\n对于全部数据，$1\\le N\\le 10^5, M\\le 20$。", "locale": "zh-CN", "translations": {"en": {"title": "BanG Dream!'s Mass Chorus Lineup", "background": "All idol bands in BanG Dream! are going to sing a chorus together, but there are some issues with the lineup.", "description": "There are $N$ idols standing in a line, coming from $M$ different bands. Each band has at least one idol.\n\nWe want to rearrange the line so that idols from the same band stand together contiguously. The way to rearrange is: let some idols leave the line (the remaining idols do not move), then let the removed idols return one by one to fill the vacated positions; they may return to any empty positions.\n\nWhat is the minimum number of idols that must leave the line?", "inputFormat": "The first line contains $2$ integers $N$ and $M$.\n\nThen there are $N$ lines, each containing an integer $a_i(1\\le a_i \\le M)$, representing the band ID of the $i$-th idol in the line.", "outputFormat": "Output a single integer, the answer.", "hint": "Sample explanation:\n\n```cpp\n1  3   √\n3  3\n2  3   √\n4  4\n2  4   √\n1  2   √\n2  2\n3  2   √\n1  1\n1  1\n3  1   √\n4  1   √\n```\n\nConstraints:\n\n- For $20\\%$ of the testdata, $N\\le 20, M=2$.\n- For $40\\%$ of the testdata, $N\\le 100, M\\le 4$.\n- For $70\\%$ of the testdata, $N\\le 2000, M\\le 10$.\n- For all testdata, $1\\le N\\le 10^5, M\\le 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "邦邦的大合唱站队", "background": "BanG Dream! 里的所有偶像乐队要一起大合唱，不过在排队上出了一些问题。", "description": "$N$ 个偶像排成一列，他们来自 $M$ 个不同的乐队。每个团队至少有一个偶像。\n\n现在要求重新安排队列，使来自同一乐队的偶像连续的站在一起。重新安排的办法是，让若干偶像出列（剩下的偶像不动），然后让出列的偶像一个个归队到原来的空位，归队的位置任意。\n\n请问最少让多少偶像出列？", "inputFormat": "第一行 $2$ 个整数 $N,M$。\n\n接下来 $N$ 行，每行一个整数 $a_i(1\\le a_i \\le M)$，表示队列中第 $i$ 个偶像的团队编号。", "outputFormat": "一个整数，表示答案。", "hint": "【样例解释】\n\n```cpp\n1  3   √\n3  3\n2  3   √\n4  4\n2  4   √\n1  2   √\n2  2\n3  2   √\n1  1\n1  1\n3  1   √\n4  1   √\n```\n【数据规模】\n\n对于 $20\\%$ 的数据，$N\\le 20, M=2$；\n\n对于 $40\\%$ 的数据，$N\\le 100, M\\le 4$；\n\n对于 $70\\%$ 的数据，$N\\le 2000, M\\le 10$；\n\n对于全部数据，$1\\le N\\le 10^5, M\\le 20$。", "locale": "zh-CN"}}}
