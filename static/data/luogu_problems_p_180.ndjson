{"pid": "P4639", "type": "P", "difficulty": 6, "samples": [["0 100 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\nADD A B\nIF A < 220 GOTO LINE 2\nPRINT A", "300"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "各省省选", "上海", "提交答案"], "title": "[SHOI2011] 编译优化", "background": " ", "description": "就像 PASCAL 语言和 C/C++ 语言一样， SH 语言也是一种编程语言。 SH 语言共有 $26$ 个寄存器，用大写拉丁字母 A, B, … , Z 表示。 SH 语言的程序中，第一行依次是这 $26$ 个寄存器的初始值，用空格分隔。程序的第二行起，每一行都是一条命令。 SH 语言有三种命令，如下表所示（在格式这一列中，用下划线代替实际语言中的一个空格）。\n\n-    ``ADD``命令 格式：``ADD_R1_R2``  功能：将寄存器 R2 的值加到寄存器 R1 上。 限制：无。\n\n-    ``GOTO`` 命令 格式：``IF _R_ < _I1_ GOTO _LINE_ I2`` 功能：如果寄存器 R 的值小于立即数 I1 ，则跳转至第 I2 （ $\\ge 2$ ）行，否则继续执行下一行。限制：至多出现一次，且只可能出现在第 I2 行之后。\n\n-    ``PRINT`` 命令 格式：``PRINT_R`` 功能：打印寄存器 R 的值。限制：出现且仅出现在最后一行。\n\n现给定一个 SH 语言的程序，请输出 ``PRINT`` 命令打印的值。", "inputFormat": "每个输入文件都是一个 SH 语言的程序。输入文件保证：所有寄存器的初始值以及 ``GOTO`` 命令中出现的立即数，均为不超过 $2^{63}-1$ 的非负整数，但程序执行过程中寄存器的值不限于此。", "outputFormat": "每个输出文件只有一行，包含一个整数，即 ``PRINT`` 命令所打印的值。", "hint": "在每个测试点，如果您的输出与标准答案完全一致，您将能得到该测试点的全部分数；否则，您将在该测试点得 $0$ 分。\n\n本题为提交答案题，所有的 $10$ 个输入文件 ``compiler1.in ~ compiler10.in`` 都已存放在题目背景的下载链接中。对于每个输入文件，您需要分别给出相应的输出文件 ``compiler1.out ~ compiler10.out``。\n\n注意：您只需提交输出文件而无需提交任何程序。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2011] Compiler Optimization", "background": "", "description": "Just like the PASCAL language and the C/C++ language, the SH language is also a programming language. The SH language has $26$ registers, represented by uppercase Latin letters A, B, … , Z. In an SH program, the first line contains the initial values of these $26$ registers in order, separated by spaces. Starting from the second line, each line is one instruction. The SH language has three kinds of instructions, as shown in the table below (in the “Format” column, underscores are used to represent a single space in the actual language).\n\n- The ``ADD`` instruction. Format: ``ADD_R1_R2``. Function: add the value of register R2 to register R1. Restriction: none.\n\n- The ``GOTO`` instruction. Format: ``IF _R_ < _I1_ GOTO _LINE_ I2``. Function: if the value of register R is less than the immediate value I1, then jump to line I2 ( $\\ge 2$ ); otherwise, continue to execute the next line. Restriction: it appears at most once, and it can only appear after line I2.\n\n- The ``PRINT`` instruction. Format: ``PRINT_R``. Function: print the value of register R. Restriction: it appears and only appears on the last line.\n\nGiven an SH program, output the value printed by the ``PRINT`` instruction.", "inputFormat": "Each input file is an SH program. The input guarantees that all initial register values and the immediate values appearing in the ``GOTO`` instruction are non-negative integers not exceeding $2^{63}-1$, but during program execution, register values are not limited to this range.", "outputFormat": "Each output file contains only one line with one integer, which is the value printed by the ``PRINT`` instruction.", "hint": "For each test point, if your output is exactly the same as the standard answer, you will get full score for that test point; otherwise, you will get $0$ points for that test point.\n\nThis is an output-only problem. All $10$ input files ``compiler1.in ~ compiler10.in`` have been provided in the download link in the “Background” section. For each input file, you need to provide the corresponding output file ``compiler1.out ~ compiler10.out``.\n\nNote: You only need to submit the output files, and you do not need to submit any program.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2011] 编译优化", "background": " ", "description": "就像 PASCAL 语言和 C/C++ 语言一样， SH 语言也是一种编程语言。 SH 语言共有 $26$ 个寄存器，用大写拉丁字母 A, B, … , Z 表示。 SH 语言的程序中，第一行依次是这 $26$ 个寄存器的初始值，用空格分隔。程序的第二行起，每一行都是一条命令。 SH 语言有三种命令，如下表所示（在格式这一列中，用下划线代替实际语言中的一个空格）。\n\n-    ``ADD``命令 格式：``ADD_R1_R2``  功能：将寄存器 R2 的值加到寄存器 R1 上。 限制：无。\n\n-    ``GOTO`` 命令 格式：``IF _R_ < _I1_ GOTO _LINE_ I2`` 功能：如果寄存器 R 的值小于立即数 I1 ，则跳转至第 I2 （ $\\ge 2$ ）行，否则继续执行下一行。限制：至多出现一次，且只可能出现在第 I2 行之后。\n\n-    ``PRINT`` 命令 格式：``PRINT_R`` 功能：打印寄存器 R 的值。限制：出现且仅出现在最后一行。\n\n现给定一个 SH 语言的程序，请输出 ``PRINT`` 命令打印的值。", "inputFormat": "每个输入文件都是一个 SH 语言的程序。输入文件保证：所有寄存器的初始值以及 ``GOTO`` 命令中出现的立即数，均为不超过 $2^{63}-1$ 的非负整数，但程序执行过程中寄存器的值不限于此。", "outputFormat": "每个输出文件只有一行，包含一个整数，即 ``PRINT`` 命令所打印的值。", "hint": "在每个测试点，如果您的输出与标准答案完全一致，您将能得到该测试点的全部分数；否则，您将在该测试点得 $0$ 分。\n\n本题为提交答案题，所有的 $10$ 个输入文件 ``compiler1.in ~ compiler10.in`` 都已存放在题目背景的下载链接中。对于每个输入文件，您需要分别给出相应的输出文件 ``compiler1.out ~ compiler10.out``。\n\n注意：您只需提交输出文件而无需提交任何程序。", "locale": "zh-CN"}}}
{"pid": "P4640", "type": "P", "difficulty": 6, "samples": [["2 1 10 13\n3", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2008", "北京"], "title": "[BJWC2008] 王之财宝", "background": "", "description": "《基尔伽美修》是人类历史上第一部英雄史诗，两河流域最杰出的文学作品之一。作品讲述了基尔伽美修一生的传奇故事。在动画Fate/stay night中，基尔伽美修与亚瑟王等传说中的英雄人物一起出现在了现实世界，展开了一场惊天地、泣鬼神的战斗。在记载于12块泥板的史诗中，基尔伽美修与同伴安吉杜一起降伏了森林的守护者——神兽洪芭芭，成为地上最强的王者，同时将世间所有财宝收归手中。王之财宝(Gate of Babylon)成为Fate中金皮卡（基尔伽美修的外号…）炫耀的资本……\n\n一天金皮卡突发奇想：如果从自己无尽的财宝里面，随便抽不超过M件宝具出来砸死敌人的话。一共有多少种搭配方法呢？假设金皮卡一共有N种不同类型的宝具，大部分类型的宝具都有无限多，但其中T种超级神器的数量是有限的。设第i种超级神器的数量不超过$B_i$件。若相同类型的宝具数量相同，则认为是相同的搭配方案。\n\n金皮卡知道方案数会很大，从小数学成绩就好的他挑选了一个质数P，请你帮他计算一下方案数模P后的余数。注意，一件也不选也是一种方案。", "inputFormat": "第一行包含4个整数，分别为N，T，M，P\n\n之后T行，每行一个整数，代表$B_i$\n\n$N,M≤10^9$，$P≤10^5$，$B_i≤10^9$\n\n$0≤T≤N$，$M>0$，$B_i>0$，$T≤15$", "outputFormat": "仅包含一个整数，即方案数模P后的余数。", "hint": "只有一种超级神器，数量不超过3\n\n当不选择超级神器时，另一种宝具可以挑选0到10件，共11种方案\n\n当选择1件神器出来时，另一种宝具可以挑选0到9件，共10种方案\n\n当挑选2件神器时，共9种方案\n\n挑选3件神器时，共8种方案\n\n一共有11+10+9+8=38种方案，$38\\bmod13=12$，于是答案等于12", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2008] The King's Treasure", "background": "", "description": "The Epic of Gilgamesh is the first heroic epic in human history and one of the greatest literary works of Mesopotamia. It tells the legendary life story of Gilgamesh. In the anime Fate/stay night, Gilgamesh appears in the real world together with legendary heroes such as King Arthur, and a world-shaking battle begins. In the epic recorded on 12 clay tablets, Gilgamesh and his companion Enkidu subdue the guardian of the forest—the divine beast Humbaba—becoming the strongest king on earth, and at the same time taking all the treasures of the world for themselves. The “Gate of Babylon” becomes the capital that “Kinpika” (Gilgamesh’s nickname...) uses to show off in Fate...\n\nOne day, Kinpika suddenly has an idea: if he randomly takes out at most $M$ treasures from his endless collection to smash enemies to death, how many different ways of matching are there in total? Suppose Kinpika has $N$ different types of treasures. Most types have an unlimited quantity, but among them there are $T$ types of “super divine artifacts” whose quantities are limited. Let the quantity of the $i$-th super divine artifact be at most $B_i$. If the numbers of treasures of each type are the same, then they are considered the same matching plan.\n\nKinpika knows the number of plans will be very large. Since he has always been good at math, he chooses a prime number $P$. Please help him compute the remainder of the number of plans modulo $P$. Note that selecting none is also a valid plan.", "inputFormat": "The first line contains four integers: $N$, $T$, $M$, $P$.\n\nThe next $T$ lines each contain one integer, representing $B_i$.\n\nConstraints: $N, M \\le 10^9$, $P \\le 10^5$, $B_i \\le 10^9$, $0 \\le T \\le N$, $M > 0$, $B_i > 0$, $T \\le 15$.", "outputFormat": "Output only one integer, the remainder of the number of plans modulo $P$.", "hint": "There is only one super divine artifact, with quantity at most 3.\n\nWhen not selecting the super divine artifact, the other type of treasure can be selected from 0 to 10 items, for a total of 11 plans.\n\nWhen selecting 1 artifact, the other type of treasure can be selected from 0 to 9 items, for a total of 10 plans.\n\nWhen selecting 2 artifacts, there are 9 plans in total.\n\nWhen selecting 3 artifacts, there are 8 plans in total.\n\nIn total there are $11 + 10 + 9 + 8 = 38$ plans, and $38 \\bmod 13 = 12$, so the answer is 12.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2008] 王之财宝", "background": "", "description": "《基尔伽美修》是人类历史上第一部英雄史诗，两河流域最杰出的文学作品之一。作品讲述了基尔伽美修一生的传奇故事。在动画Fate/stay night中，基尔伽美修与亚瑟王等传说中的英雄人物一起出现在了现实世界，展开了一场惊天地、泣鬼神的战斗。在记载于12块泥板的史诗中，基尔伽美修与同伴安吉杜一起降伏了森林的守护者——神兽洪芭芭，成为地上最强的王者，同时将世间所有财宝收归手中。王之财宝(Gate of Babylon)成为Fate中金皮卡（基尔伽美修的外号…）炫耀的资本……\n\n一天金皮卡突发奇想：如果从自己无尽的财宝里面，随便抽不超过M件宝具出来砸死敌人的话。一共有多少种搭配方法呢？假设金皮卡一共有N种不同类型的宝具，大部分类型的宝具都有无限多，但其中T种超级神器的数量是有限的。设第i种超级神器的数量不超过$B_i$件。若相同类型的宝具数量相同，则认为是相同的搭配方案。\n\n金皮卡知道方案数会很大，从小数学成绩就好的他挑选了一个质数P，请你帮他计算一下方案数模P后的余数。注意，一件也不选也是一种方案。", "inputFormat": "第一行包含4个整数，分别为N，T，M，P\n\n之后T行，每行一个整数，代表$B_i$\n\n$N,M≤10^9$，$P≤10^5$，$B_i≤10^9$\n\n$0≤T≤N$，$M>0$，$B_i>0$，$T≤15$", "outputFormat": "仅包含一个整数，即方案数模P后的余数。", "hint": "只有一种超级神器，数量不超过3\n\n当不选择超级神器时，另一种宝具可以挑选0到10件，共11种方案\n\n当选择1件神器出来时，另一种宝具可以挑选0到9件，共10种方案\n\n当挑选2件神器时，共9种方案\n\n挑选3件神器时，共8种方案\n\n一共有11+10+9+8=38种方案，$38\\bmod13=12$，于是答案等于12", "locale": "zh-CN"}}}
{"pid": "P4641", "type": "P", "difficulty": 5, "samples": [["3 5\n1\n2\n4\nQ 1\nQ 2\nA 1\nQ 1\nQ 2", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2008", "北京"], "title": "[BJWC2008] 序列", "background": "", "description": "对一个长度为$N$的序列$\\{a_n\\}(a_i\\in[0,2^{16}-1])$，进行如下两种，共计$M$个操作：\n\n1. `A x`$(x\\ge0)$：$a_i=a_i+x\\mod2^{16}$\n\n2. `Q i`：询问$Card\\{k\\mid(a_k\\;\\&\\;2^i)>0,1\\le k\\le N,k\\in\\mathbb{Z}\\}$的结果\n\n其中$\\&$运算符为相当于C/C++中的`&`或Pascal中的`and`\n\n给定初始序列和操作序列，请你模拟操作过程，并计算所有$Q$操作的相应的结果的和。", "inputFormat": "输入文件的第一行包含两个以空格分隔的整数，分别代表$N,M$\n\n接下来的$N$行每行包含一个整数，代表初始序列\n\n接下来的$M$行，每行描述一个操作，格式如题目中所述", "outputFormat": "输出文件包含一个整数，表示所有$Q$操作的结果的和\n", "hint": "初始序列为$1\\;2\\;4$\n\n`Q 1`：仅$a_2=2$满足$(a_k\\;\\&\\;2^i)>0$，该$Q$操作的结果为$1$\n\n`Q 2`：仅$a_3=4$满足$(a_k\\;\\&\\;2^i)>0$，该$Q$操作的结果为$1$\n\n`A 1`：原序列变为$2\\;3\\;5$\n\n`Q 1`：仅$a_1=2,a_2=3$满足$(a_k\\;\\&\\;2^i)>0$，该$Q$操作的结果为$2$\n\n`Q 2`：仅$a_3=5$满足$(a_k\\;\\&\\;2^i)>0$，该$Q$操作的结果为$1$\n\n$1+1+2+1=5$，所以最终结果为5\n\n$30\\%$的数据满足$1\\le N\\le100,1\\le M\\le1000$\n\n$100\\%$的数据满足$1\\le N,M\\le10^5$", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2008] Sequence", "background": "", "description": "For a sequence $\\{a_n\\}$ of length $N$ $(a_i \\in [0, 2^{16} - 1])$, perform the following two types of operations, for a total of $M$ operations:\n\n1. `A x` $(x \\ge 0)$: $a_i = a_i + x \\mod 2^{16}$.\n\n2. `Q i`: Query the value of $Card\\{k \\mid (a_k\\;\\&\\;2^i) > 0, 1 \\le k \\le N, k \\in \\mathbb{Z}\\}$.\n\nHere, the $\\&$ operator is the same as `&` in C/C++ or `and` in Pascal.\n\nGiven the initial sequence and the list of operations, simulate the process and compute the sum of the results of all `Q` operations.", "inputFormat": "The first line contains two integers $N, M$ separated by spaces, representing $N$ and $M$.\n\nThe next $N$ lines each contain one integer, representing the initial sequence.\n\nThe next $M$ lines each describe one operation, in the format stated in the description.", "outputFormat": "Output one integer, representing the sum of the results of all `Q` operations.", "hint": "The initial sequence is $1\\;2\\;4$.\n\n`Q 1`: Only $a_2 = 2$ satisfies $(a_k\\;\\&\\;2^i) > 0$, so the result of this `Q` operation is $1$.\n\n`Q 2`: Only $a_3 = 4$ satisfies $(a_k\\;\\&\\;2^i) > 0$, so the result of this `Q` operation is $1$.\n\n`A 1`: The original sequence becomes $2\\;3\\;5$.\n\n`Q 1`: Only $a_1 = 2, a_2 = 3$ satisfy $(a_k\\;\\&\\;2^i) > 0$, so the result of this `Q` operation is $2$.\n\n`Q 2`: Only $a_3 = 5$ satisfies $(a_k\\;\\&\\;2^i) > 0$, so the result of this `Q` operation is $1$.\n\n$1 + 1 + 2 + 1 = 5$, so the final result is $5$.\n\nConstraints:\n\n$30\\%$ of the testdata satisfy $1 \\le N \\le 100, 1 \\le M \\le 1000$.\n\n$100\\%$ of the testdata satisfy $1 \\le N, M \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2008] 序列", "background": "", "description": "对一个长度为$N$的序列$\\{a_n\\}(a_i\\in[0,2^{16}-1])$，进行如下两种，共计$M$个操作：\n\n1. `A x`$(x\\ge0)$：$a_i=a_i+x\\mod2^{16}$\n\n2. `Q i`：询问$Card\\{k\\mid(a_k\\;\\&\\;2^i)>0,1\\le k\\le N,k\\in\\mathbb{Z}\\}$的结果\n\n其中$\\&$运算符为相当于C/C++中的`&`或Pascal中的`and`\n\n给定初始序列和操作序列，请你模拟操作过程，并计算所有$Q$操作的相应的结果的和。", "inputFormat": "输入文件的第一行包含两个以空格分隔的整数，分别代表$N,M$\n\n接下来的$N$行每行包含一个整数，代表初始序列\n\n接下来的$M$行，每行描述一个操作，格式如题目中所述", "outputFormat": "输出文件包含一个整数，表示所有$Q$操作的结果的和\n", "hint": "初始序列为$1\\;2\\;4$\n\n`Q 1`：仅$a_2=2$满足$(a_k\\;\\&\\;2^i)>0$，该$Q$操作的结果为$1$\n\n`Q 2`：仅$a_3=4$满足$(a_k\\;\\&\\;2^i)>0$，该$Q$操作的结果为$1$\n\n`A 1`：原序列变为$2\\;3\\;5$\n\n`Q 1`：仅$a_1=2,a_2=3$满足$(a_k\\;\\&\\;2^i)>0$，该$Q$操作的结果为$2$\n\n`Q 2`：仅$a_3=5$满足$(a_k\\;\\&\\;2^i)>0$，该$Q$操作的结果为$1$\n\n$1+1+2+1=5$，所以最终结果为5\n\n$30\\%$的数据满足$1\\le N\\le100,1\\le M\\le1000$\n\n$100\\%$的数据满足$1\\le N,M\\le10^5$", "locale": "zh-CN"}}}
{"pid": "P4642", "type": "P", "difficulty": 7, "samples": [["1 2\n100 100 10\n3 3\n99 100", "0.30000\nIMPOSSIBLE"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2008", "北京", "线性规划", "半平面交"], "title": "[BJWC2008] 方程", "background": "", "description": "给定$3\\times N$个正整数\n\n$A_1,A_2...A_n$\n\n$B_1,B_2...B_n$\n\n$C_1,C_2...C_n$\n\n另给定$M$对正整数$S_i,T_i$对于每一对$S_i,T_i$\n\n求下列方程组的一组非负实数解\n\n$A_1X_1+A_2X_2+...+A_nX_n=S_i$\n\n$B_1X_1+B_2X_2+...+B_nX_n=T_i$\n\n使得$C_1X_1+C_2X_2+...+C_nX_n$最大", "inputFormat": "第一行两个整数代表$N,M$\n \n接下来$N$行每行三个正整数$A_i,B_i,C_i$\n\n$N\\leq 10^5$, $M \\leq 10^4$\n\n$1\\le A_i,B_i,C_i,S_i,T_i\\le1000000$", "outputFormat": "输出为$M$行，第$i$行代表$S_i,T_i$\n\n如果方程无解输出`IMPOSSIBLE`\n\n否则输出一个实数保留五位小数，代表对应的最大值。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2008] Equation", "background": "", "description": "You are given $3 \\times N$ positive integers:\n\n$A_1, A_2...A_n$\n\n$B_1, B_2...B_n$\n\n$C_1, C_2...C_n$\n\nYou are also given $M$ pairs of positive integers $S_i, T_i$. For each pair $S_i, T_i$, find a set of non-negative real solutions to the following system of equations:\n\n$A_1X_1 + A_2X_2 + ... + A_nX_n = S_i$\n\n$B_1X_1 + B_2X_2 + ... + B_nX_n = T_i$\n\nsuch that $C_1X_1 + C_2X_2 + ... + C_nX_n$ is maximized.", "inputFormat": "The first line contains two integers $N, M$.\n\nThe next $N$ lines each contain three positive integers $A_i, B_i, C_i$.\n\nConstraints: $N \\leq 10^5$, $M \\leq 10^4$.\n\n$1 \\le A_i, B_i, C_i, S_i, T_i \\le 1000000$.", "outputFormat": "Output $M$ lines. The $i$-th line corresponds to $S_i, T_i$.\n\nIf the system has no solution, output `IMPOSSIBLE`.\n\nOtherwise, output a real number rounded to five decimal places, representing the corresponding maximum value.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2008] 方程", "background": "", "description": "给定$3\\times N$个正整数\n\n$A_1,A_2...A_n$\n\n$B_1,B_2...B_n$\n\n$C_1,C_2...C_n$\n\n另给定$M$对正整数$S_i,T_i$对于每一对$S_i,T_i$\n\n求下列方程组的一组非负实数解\n\n$A_1X_1+A_2X_2+...+A_nX_n=S_i$\n\n$B_1X_1+B_2X_2+...+B_nX_n=T_i$\n\n使得$C_1X_1+C_2X_2+...+C_nX_n$最大", "inputFormat": "第一行两个整数代表$N,M$\n \n接下来$N$行每行三个正整数$A_i,B_i,C_i$\n\n$N\\leq 10^5$, $M \\leq 10^4$\n\n$1\\le A_i,B_i,C_i,S_i,T_i\\le1000000$", "outputFormat": "输出为$M$行，第$i$行代表$S_i,T_i$\n\n如果方程无解输出`IMPOSSIBLE`\n\n否则输出一个实数保留五位小数，代表对应的最大值。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4643", "type": "P", "difficulty": 5, "samples": [["4 4\n6\n4\n-1\n-2\n1 2 1\n2 3 6\n3 4 3\n1 4 5", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["集训队互测"], "title": "[国家集训队] 阿狸和桃子的游戏", "background": null, "description": "阿狸和桃子正在玩一个游戏，游戏是在一个带权图 $G=(V,E)$ 上进行的，设节点权值为 $w(v)$，边权为 $c(e)$。游戏规则是这样的：\n\n1. 阿狸和桃子轮流将图中的顶点染色，阿狸会将顶点染成红色，桃子会将顶点染成粉色。已经被染过色的点不能再染了，而且每一轮都必须给一个且仅一个顶点染色。\n\n2. 为了保证公平性，节点的个数 $N$ 为偶数。\n\n3. 经过 $\\frac{N}{2}$ 轮游戏之后，两人都得到了一个顶点集合。对于顶点集合 $S$，得分计算方式为\n\n$$\\sum_{v \\in S}w(v) + \\sum_{e=(u,v)\\in E \\land u,v\\in S}c(e)$$\n\n由于阿狸石头剪子布输给了桃子，所以桃子先染色。两人都想要使自己的分数比对方多，且多得越多越好。如果两人都是采用最优策略的，求最终桃子的分数减去阿狸的分数。", "inputFormat": "输入第一行包含两个正整数 $N$ 和 $M$，分别表示图 $G$ 的节点数和边数，保证 $N$ 一定是偶数。\n\n接下来 $N+M$ 行。\n\n前 $N$ 行，每行一个整数 $w$，其中第 $k$ 行为节点 $k$ 的权值。\n\n后 $M$ 行，每行三个用空格隔开的整数 $a,b,c$，表示一条连接节点 $a$ 和节点 $b$ 的边，权值为 $c$。", "outputFormat": "输出仅包含一个整数，为桃子的得分减去阿狸的得分。", "hint": "数据规模和约定：\n\n对于 $40\\%$ 的数据，$1 \\le N \\le 16$。\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10000$，$1 \\le M \\le 100000$，$-10000 \\le w , c \\le 10000$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTT] Ali and Peach's Game", "background": "", "description": "Ali and Peach are playing a game on a weighted graph $G=(V,E)$. Let the weight of a vertex be $w(v)$, and the weight of an edge be $c(e)$. The rules are:\n\n1. Ali and Peach take turns coloring vertices in the graph. Ali colors a vertex red, and Peach colors a vertex pink. A vertex that has already been colored cannot be colored again, and in each turn, exactly one vertex must be colored.\n\n2. To ensure fairness, the number of vertices $N$ is even.\n\n3. After $\\frac{N}{2}$ rounds, each player obtains a set of vertices. For a vertex set $S$, the score is\n\n$$\\sum_{v \\in S}w(v) + \\sum_{e=(u,v)\\in E \\land u,v\\in S}c(e)$$\n\nSince Ali lost Rock-Paper-Scissors to Peach, Peach colors first. Both players want their own score to exceed the other’s, and the larger the difference, the better. Assuming both players use optimal strategies, find the final value of Peach’s score minus Ali’s score.", "inputFormat": "The first line contains two positive integers $N$ and $M$, representing the number of vertices and edges of the graph $G$, where $N$ is guaranteed to be even.\n\nThe next $N+M$ lines follow.\n\nThe first $N$ lines each contain one integer $w$. The $k$-th of these lines gives the weight of vertex $k$.\n\nThe next $M$ lines each contain three integers $a,b,c$ separated by spaces, describing an edge between vertices $a$ and $b$ with weight $c$.", "outputFormat": "Output exactly one integer, which is Peach’s score minus Ali’s score.", "hint": "Constraints and notes:\n\nFor $40\\%$ of the testdata, $1 \\le N \\le 16$.\n\nFor $100\\%$ of the testdata, $1 \\le N \\le 10000$, $1 \\le M \\le 100000$, $-10000 \\le w , c \\le 10000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[国家集训队] 阿狸和桃子的游戏", "background": null, "description": "阿狸和桃子正在玩一个游戏，游戏是在一个带权图 $G=(V,E)$ 上进行的，设节点权值为 $w(v)$，边权为 $c(e)$。游戏规则是这样的：\n\n1. 阿狸和桃子轮流将图中的顶点染色，阿狸会将顶点染成红色，桃子会将顶点染成粉色。已经被染过色的点不能再染了，而且每一轮都必须给一个且仅一个顶点染色。\n\n2. 为了保证公平性，节点的个数 $N$ 为偶数。\n\n3. 经过 $\\frac{N}{2}$ 轮游戏之后，两人都得到了一个顶点集合。对于顶点集合 $S$，得分计算方式为\n\n$$\\sum_{v \\in S}w(v) + \\sum_{e=(u,v)\\in E \\land u,v\\in S}c(e)$$\n\n由于阿狸石头剪子布输给了桃子，所以桃子先染色。两人都想要使自己的分数比对方多，且多得越多越好。如果两人都是采用最优策略的，求最终桃子的分数减去阿狸的分数。", "inputFormat": "输入第一行包含两个正整数 $N$ 和 $M$，分别表示图 $G$ 的节点数和边数，保证 $N$ 一定是偶数。\n\n接下来 $N+M$ 行。\n\n前 $N$ 行，每行一个整数 $w$，其中第 $k$ 行为节点 $k$ 的权值。\n\n后 $M$ 行，每行三个用空格隔开的整数 $a,b,c$，表示一条连接节点 $a$ 和节点 $b$ 的边，权值为 $c$。", "outputFormat": "输出仅包含一个整数，为桃子的得分减去阿狸的得分。", "hint": "数据规模和约定：\n\n对于 $40\\%$ 的数据，$1 \\le N \\le 16$。\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10000$，$1 \\le M \\le 100000$，$-10000 \\le w , c \\le 10000$。", "locale": "zh-CN"}}}
{"pid": "P4644", "type": "P", "difficulty": 5, "samples": [["3 0 4\n0 2 3\n3 4 2\n0 0 1", "5"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [64512, 64512, 64512, 64512, 64512, 64512, 64512, 64512, 64512, 64512, 64512]}, "tags": ["动态规划 DP", "递推", "2005", "线段树", "USACO", "排序", "队列"], "title": "[USACO05DEC] Cleaning Shifts S", "background": "", "description": "约翰的奶牛们从小娇生惯养，她们无法容忍牛棚里的任何脏东西。约翰发现，如果要使这群有洁癖的奶牛满意，他不得不雇佣她们中的一些来清扫牛棚，约翰的奶牛中有 $ N(1 \\leq N \\leq 10000) $ 头愿意通过清扫牛棚来挣一些零花钱。\n\n由于在某个时段中奶牛们会在牛棚里随时随地地乱扔垃圾，自然地，她们要求在这段时间里，无论什么时候至少要有一头奶牛正在打扫。需要打扫的时段从某一天的第 $ M $ 秒开始，到第 $ E $ 秒结束 $ (0 \\leq M \\leq E \\leq 86399) $。注意这里的秒是指时间段而不是时间点，也就是说，每天需要打扫的总时间是 $ E-M+1 $ 秒。\n\n约翰已经从每头牛那里得到了她们愿意接受的工作计划：对于某一头牛，她每天都愿意在笫 $ T_1 \\ldots T_2 $ 秒的时间段内工作 $ (M \\leq T_1 \\leq T_2 \\leq E) $ ，所要求的报酬是 $ S $ 美元 $ (0 \\leq S \\leq 500000) $。与需打扫时段的描述一样，如果一头奶牛愿意工作的时段是每天的第 $ 10 \\ldots 20 $ 秒，那她总共工作的时间是 $ 11 $ 秒，而不是 $ 10 $ 秒。\n\n约翰一旦决定雇佣某一头奶牛，就必须付给她全额的工资，而不能只让她工作一段时间，然后再按这段时间在她愿意工作的总时间中所占的百分比来决定她的工资。现在请你帮约翰决定该雇佣哪些奶牛以保持牛棚的清洁，当然，在能让奶牛们满意的前提下，约翰希望使总花费尽量小。", "inputFormat": "第 $ 1 $ 行： $ 3 $ 个正整数 $ N,M,E $ 。\n\n第 $ 2 $ 到 $ N+1 $ 行：第 $ i+1 $ 行给出了编号为 $ i $ 的奶牛的工作计划，即 $ 3 $ 个正整数 $ T_1,T_2,S $ 。", "outputFormat": "输出一个整数，表示约翰需要为牛棚清理工作支付的最少费用。如果清理工作不可能完成，那么输出 $ -1 $ 。", "hint": "约翰有 $ 3 $ 头牛，牛棚在第 $ 0 $ 秒到第 $ 4 $ 秒之间需要打扫。 约翰雇佣前两头牛清扫牛棚，可以只花 $ 5 $ 美元就完成一整天的清扫。\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO05DEC] Cleaning Shifts S", "background": "", "description": "John’s cows have been spoiled since childhood, and they cannot tolerate any dirt in the barn. John finds that, to satisfy these clean-freak cows, he has to hire some of them to clean the barn. Among John’s cows, there are $ N(1 \\leq N \\leq 10000) $ cows who are willing to earn some pocket money by cleaning.\n\nDuring a certain time period, the cows will litter in the barn at any time and anywhere. Naturally, they require that, throughout this period, at least one cow must be cleaning at all times. The required cleaning period starts at the $ M $-th second of a day and ends at the $ E $-th second $ (0 \\leq M \\leq E \\leq 86399) $. Note that “seconds” here refer to time intervals rather than time points. In other words, the total time that must be covered each day is $ E - M + 1 $ seconds.\n\nJohn has obtained from each cow the work schedule she is willing to accept: for a given cow, she is willing to work every day during the interval from the $ T_1 $-th second to the $ T_2 $-th second $ (M \\leq T_1 \\leq T_2 \\leq E) $, and she asks for a payment of $ S $ dollars $ (0 \\leq S \\leq 500000) $. As with the required cleaning period, if a cow is willing to work from the 10-th to the 20-th second each day, then her total working time is 11 seconds, not 10 seconds.\n\nOnce John decides to hire a cow, he must pay her the full wage. He cannot hire her for only part of her available time and then pay a fraction based on how much of her available time she actually worked. Please help John decide which cows to hire to keep the barn clean. Of course, while keeping the cows satisfied, John wants the total cost to be as small as possible.", "inputFormat": "Line 1: Three positive integers $ N, M, E $.\n\nLines 2 to $ N + 1 $: Line $ i + 1 $ gives the work schedule of cow $ i $, i.e. three positive integers $ T_1, T_2, S $.", "outputFormat": "Output one integer, the minimum total cost John needs to pay for cleaning the barn. If it is impossible to complete the cleaning, output $ -1 $.", "hint": "John has 3 cows, and the barn needs to be cleaned from the 0-th second to the 4-th second. John can hire the first two cows and complete a whole day of cleaning with only 5 dollars.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO05DEC] Cleaning Shifts S", "background": "", "description": "约翰的奶牛们从小娇生惯养，她们无法容忍牛棚里的任何脏东西。约翰发现，如果要使这群有洁癖的奶牛满意，他不得不雇佣她们中的一些来清扫牛棚，约翰的奶牛中有 $ N(1 \\leq N \\leq 10000) $ 头愿意通过清扫牛棚来挣一些零花钱。\n\n由于在某个时段中奶牛们会在牛棚里随时随地地乱扔垃圾，自然地，她们要求在这段时间里，无论什么时候至少要有一头奶牛正在打扫。需要打扫的时段从某一天的第 $ M $ 秒开始，到第 $ E $ 秒结束 $ (0 \\leq M \\leq E \\leq 86399) $。注意这里的秒是指时间段而不是时间点，也就是说，每天需要打扫的总时间是 $ E-M+1 $ 秒。\n\n约翰已经从每头牛那里得到了她们愿意接受的工作计划：对于某一头牛，她每天都愿意在笫 $ T_1 \\ldots T_2 $ 秒的时间段内工作 $ (M \\leq T_1 \\leq T_2 \\leq E) $ ，所要求的报酬是 $ S $ 美元 $ (0 \\leq S \\leq 500000) $。与需打扫时段的描述一样，如果一头奶牛愿意工作的时段是每天的第 $ 10 \\ldots 20 $ 秒，那她总共工作的时间是 $ 11 $ 秒，而不是 $ 10 $ 秒。\n\n约翰一旦决定雇佣某一头奶牛，就必须付给她全额的工资，而不能只让她工作一段时间，然后再按这段时间在她愿意工作的总时间中所占的百分比来决定她的工资。现在请你帮约翰决定该雇佣哪些奶牛以保持牛棚的清洁，当然，在能让奶牛们满意的前提下，约翰希望使总花费尽量小。", "inputFormat": "第 $ 1 $ 行： $ 3 $ 个正整数 $ N,M,E $ 。\n\n第 $ 2 $ 到 $ N+1 $ 行：第 $ i+1 $ 行给出了编号为 $ i $ 的奶牛的工作计划，即 $ 3 $ 个正整数 $ T_1,T_2,S $ 。", "outputFormat": "输出一个整数，表示约翰需要为牛棚清理工作支付的最少费用。如果清理工作不可能完成，那么输出 $ -1 $ 。", "hint": "约翰有 $ 3 $ 头牛，牛棚在第 $ 0 $ 秒到第 $ 4 $ 秒之间需要打扫。 约翰雇佣前两头牛清扫牛棚，可以只花 $ 5 $ 美元就完成一整天的清扫。\n", "locale": "zh-CN"}}}
{"pid": "P4645", "type": "P", "difficulty": 4, "samples": [["6 7\n1 3\n1 4\n3 2\n4 2\n5 6\n6 5\n3 4", "3"], ["6 8\n1 3\n1 4\n3 2\n4 2\n5 6\n6 5\n3 4\n4 3", "inf"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2006", "广度优先搜索 BFS", "强连通分量", "COCI（克罗地亚）"], "title": "[COCI 2006/2007 #3] BICIKLI", "background": "一场自行车比赛将要在一个遥远的地方上举行。", "description": "这个地方有 $n$ 个城镇，从 $1\\sim n$ 编号，其中有 $m$ 条**单向**道路连接它们。比赛将在 $1$ 号城镇开始并在 $2$ 号城镇结束。\n\n主办方想知道，一共有多少条不同的路线？", "inputFormat": "输入第一行为两个整数 $n,m$，意义如题目描述所示。\n\n接下来的 $m$ 行，每行两个整数 $a,b$，描述一条从 $a$ 到 $b$ 的道路。\n\n两个城镇间可以有多条道路。", "outputFormat": "输出不同的路线的数量。\n\n如果有无数条不同的路线，则输出 `inf`。\n\n否则输出路线数对 $10^9$ 取模的结果。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1\\le n\\leq 5\\times 10 ^ 4$，$1\\leq m\\le 10^5$。\n\n#### 说明\n\n**题目译自 [COCI2006-2007](https://hsin.hr/coci/archive/2006_2007/) [CONTEST #3](https://hsin.hr/coci/archive/2006_2007/contest3_tasks.pdf) *T5 BICIKLI***\n\n感谢 @[ShineEternal](https://www.luogu.com.cn/user/45475) 提供的翻译。", "locale": "zh-CN", "translations": {"en": {"title": "[COCI 2006/2007 #3] BICIKLI", "background": "A bicycle race is going to be held in a remote place.", "description": "There are $n$ towns in this place, numbered from $1$ to $n$, and there are $m$ **directed** roads connecting them. The race starts in town $1$ and ends in town $2$.\n\nThe organizers want to know how many different routes there are in total.", "inputFormat": "The first line contains two integers $n, m$, with the meanings described above.\n\nThe next $m$ lines each contain two integers $a, b$, describing a road from $a$ to $b$.\n\nThere may be multiple roads between two towns.", "outputFormat": "Output the number of different routes.\n\nIf there are infinitely many different routes, output `inf`.\n\nOtherwise, output the result modulo $10^9$.", "hint": "#### Constraints\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 5 \\times 10^4$, $1 \\le m \\le 10^5$.\n\n#### Notes\n\n**Translated from [COCI2006-2007](https://hsin.hr/coci/archive/2006_2007/) [CONTEST #3](https://hsin.hr/coci/archive/2006_2007/contest3_tasks.pdf) *T5 BICIKLI*.**\n\nThanks to @[ShineEternal](https://www.luogu.com.cn/user/45475) for providing the translation.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[COCI 2006/2007 #3] BICIKLI", "background": "一场自行车比赛将要在一个遥远的地方上举行。", "description": "这个地方有 $n$ 个城镇，从 $1\\sim n$ 编号，其中有 $m$ 条**单向**道路连接它们。比赛将在 $1$ 号城镇开始并在 $2$ 号城镇结束。\n\n主办方想知道，一共有多少条不同的路线？", "inputFormat": "输入第一行为两个整数 $n,m$，意义如题目描述所示。\n\n接下来的 $m$ 行，每行两个整数 $a,b$，描述一条从 $a$ 到 $b$ 的道路。\n\n两个城镇间可以有多条道路。", "outputFormat": "输出不同的路线的数量。\n\n如果有无数条不同的路线，则输出 `inf`。\n\n否则输出路线数对 $10^9$ 取模的结果。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1\\le n\\leq 5\\times 10 ^ 4$，$1\\leq m\\le 10^5$。\n\n#### 说明\n\n**题目译自 [COCI2006-2007](https://hsin.hr/coci/archive/2006_2007/) [CONTEST #3](https://hsin.hr/coci/archive/2006_2007/contest3_tasks.pdf) *T5 BICIKLI***\n\n感谢 @[ShineEternal](https://www.luogu.com.cn/user/45475) 提供的翻译。", "locale": "zh-CN"}}}
{"pid": "P4646", "type": "P", "difficulty": 6, "samples": [["15 \n1 1 \n8 1 \n4 2 \n7 2 \n2 3 \n4 3 \n6 3 \n2 5 \n4 5 \n6 5 \n4 6 \n7 6 \n1 8 \n4 8 \n8 8 \n17 \n1 2 \n2 15 \n15 14 \n14 13 \n13 1 \n14 11 \n11 12 \n12 4 \n4 3 \n3 6 \n6 5 \n5 8 \n8 9 \n9 11 \n9 10 \n10 7 \n7 6 ", "4 \n6 \n15 \n16 \n17 "]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2007", "IOI", "Special Judge"], "title": "[IOI 2007] flood 洪水", "background": "", "description": "1964年的一场灾难性的洪水冲毁了萨格勒布城。洪水袭来时许多建筑的墙被彻底冲毁。在这个题目中，给定了城市在洪水来袭前的简化模型，你的任务是确定洪水过后哪些墙没有被冲毁。\n\n简化模型由平面上的$N$个点和$W$堵墙构成。每堵墙连接两个点，没有任何一堵墙通过其它点。模型具有如下性质：\n\n- 不存在两堵墙相交或者重合的情况，但是两堵墙可以在端点相连；\n- 每堵墙或者平行于坐标系的横轴，或者平行于坐标系的纵轴。\n\n最开始，整个坐标平面都是干的。在零时刻，洪水将城市的外围淹没（城市的外围是指没有被墙围起来的区域）。一个小时之后，所有一边是水，一边是空气的墙在水的压力下都会倒塌。于是洪水又会吞没那些没有被完好的墙围住的区域。接下来又有一些墙面临一边是水一边是空气，将要被洪水冲毁的局面。又过了一个小时，这些墙也被冲毁了。这样的过程不断重复，直到洪水淹没整个城市。\n\n下图给出了洪水侵袭过程的一个例子。\n\n![](https://cdn.luogu.com.cn/upload/pic/20664.png )\n\n给定$N$个点的坐标和连接这些点的$W$堵墙的描述，编程确定洪水过后，哪些墙会被留下来。 ", "inputFormat": "输入的第一行包含一个整数$N(2 \\leq N \\leq 100 000)$, 表示平面上的点的个数。 接下来的$N$行每行包含两个整数$X$和$Y$（都是$0$到$1 000 000$之间（包括$0$和$1 000 000$）的整数），表示点的坐标。所有点按照它们被给出的顺序编号为$1$到$N$。没有两个点在同一位置上。 接下来一行包含一个整数$W(1 \\leq W \\leq 2N)$，表示墙的数目。 接下来$W$行每行包含两个不同的整数$A$和$B(1 \\leq A \\leq N, 1 \\leq B \\leq N)$，表示在洪水到来前，有一堵墙连接$A$和$B$。这些墙按照它们被给出的顺序编号为$1$到$W$。", "outputFormat": "输出的第一行包含一个整数$K$，表示洪水过后留下的墙的数目。\n\n接下来的$K$行包含留下的墙的序号，每行一个，序号可以以任意顺序输出。", "hint": "这个样例对应前页图中的例子。\n\n有40分的测试点，所有坐标小于等于$500$。\n\n在上面的测试点和另外15分的测试点中，点的个数不超过$500$个。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2007] flood Flood", "background": "", "description": "A catastrophic flood in 1964 destroyed the city of Zagreb. When the flood arrived, the walls of many buildings were completely destroyed. In this problem, you are given a simplified model of the city before the flood, and your task is to determine which walls were not destroyed after the flood.\n\nThe simplified model consists of $N$ points on the plane and $W$ walls. Each wall connects two points, and no wall passes through any other point. The model has the following properties:\n\n- No two walls intersect or overlap, but two walls may share an endpoint.\n- Each wall is either parallel to the $x$-axis or parallel to the $y$-axis.\n\nAt the beginning, the entire coordinate plane is dry. At time $0$, the flood inundates the outside of the city (the outside means the region not enclosed by walls). After one hour, every wall that has water on one side and air on the other side will collapse due to the water pressure. Then the flood will inundate those regions that are not enclosed by intact walls. Next, some walls again have water on one side and air on the other and are about to be destroyed. After another hour, these walls also collapse. This process repeats until the flood inundates the whole city.\n\nThe figure below shows an example of the flooding process.\n\n![](https://cdn.luogu.com.cn/upload/pic/20664.png )\n\nGiven the coordinates of the $N$ points and the descriptions of the $W$ walls connecting these points, write a program to determine which walls remain after the flood.", "inputFormat": "The first line contains an integer $N(2 \\leq N \\leq 100 000)$, the number of points on the plane. The next $N$ lines each contain two integers $X$ and $Y$ (both integers between $0$ and $1 000 000$ (inclusive)), giving the coordinates of a point. All points are numbered from $1$ to $N$ in the order they are given. No two points share the same position. The next line contains an integer $W(1 \\leq W \\leq 2N)$, the number of walls. The next $W$ lines each contain two different integers $A$ and $B(1 \\leq A \\leq N, 1 \\leq B \\leq N)$, meaning that before the flood there is a wall connecting $A$ and $B$. These walls are numbered from $1$ to $W$ in the order they are given.", "outputFormat": "The first line contains an integer $K$, the number of walls that remain after the flood.\n\nThe next $K$ lines contain the indices of the remaining walls, one per line. The indices may be output in any order.", "hint": "This sample corresponds to the example in the figure on the previous page.\n\nFor $40$ points of testdata, all coordinates are at most $500$.\n\nIn the above testdata and another $15$ points of testdata, the number of points does not exceed $500$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2007] flood 洪水", "background": "", "description": "1964年的一场灾难性的洪水冲毁了萨格勒布城。洪水袭来时许多建筑的墙被彻底冲毁。在这个题目中，给定了城市在洪水来袭前的简化模型，你的任务是确定洪水过后哪些墙没有被冲毁。\n\n简化模型由平面上的$N$个点和$W$堵墙构成。每堵墙连接两个点，没有任何一堵墙通过其它点。模型具有如下性质：\n\n- 不存在两堵墙相交或者重合的情况，但是两堵墙可以在端点相连；\n- 每堵墙或者平行于坐标系的横轴，或者平行于坐标系的纵轴。\n\n最开始，整个坐标平面都是干的。在零时刻，洪水将城市的外围淹没（城市的外围是指没有被墙围起来的区域）。一个小时之后，所有一边是水，一边是空气的墙在水的压力下都会倒塌。于是洪水又会吞没那些没有被完好的墙围住的区域。接下来又有一些墙面临一边是水一边是空气，将要被洪水冲毁的局面。又过了一个小时，这些墙也被冲毁了。这样的过程不断重复，直到洪水淹没整个城市。\n\n下图给出了洪水侵袭过程的一个例子。\n\n![](https://cdn.luogu.com.cn/upload/pic/20664.png )\n\n给定$N$个点的坐标和连接这些点的$W$堵墙的描述，编程确定洪水过后，哪些墙会被留下来。 ", "inputFormat": "输入的第一行包含一个整数$N(2 \\leq N \\leq 100 000)$, 表示平面上的点的个数。 接下来的$N$行每行包含两个整数$X$和$Y$（都是$0$到$1 000 000$之间（包括$0$和$1 000 000$）的整数），表示点的坐标。所有点按照它们被给出的顺序编号为$1$到$N$。没有两个点在同一位置上。 接下来一行包含一个整数$W(1 \\leq W \\leq 2N)$，表示墙的数目。 接下来$W$行每行包含两个不同的整数$A$和$B(1 \\leq A \\leq N, 1 \\leq B \\leq N)$，表示在洪水到来前，有一堵墙连接$A$和$B$。这些墙按照它们被给出的顺序编号为$1$到$W$。", "outputFormat": "输出的第一行包含一个整数$K$，表示洪水过后留下的墙的数目。\n\n接下来的$K$行包含留下的墙的序号，每行一个，序号可以以任意顺序输出。", "hint": "这个样例对应前页图中的例子。\n\n有40分的测试点，所有坐标小于等于$500$。\n\n在上面的测试点和另外15分的测试点中，点的个数不超过$500$个。", "locale": "zh-CN"}}}
{"pid": "P4647", "type": "P", "difficulty": 6, "samples": [["6 \n3 2 \n5 3 \n4 1 \n2 1 \n4 3 \n3 2 ", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2007", "IOI"], "title": "[IOI 2007] sails 船帆", "background": "", "description": "让我们来建造一艘新的海盗船。船上有 N个旗杆，每根旗杆被分成单位长度的小节。旗杆的长度等于它被分成的小节的数目。每根旗杆上会挂一些帆，每张帆正好占据旗杆上的一个小节。在一根旗杆上的帆可以任意排布在不同的小节中，但是每个小节上至多能挂一张帆。\n\n在风中，帆的不同排布方式会产生不同的推动力。靠近船头的帆比它后面的相同高度上的帆获得的推动力少，换句话说，靠近船头的帆的推动力由于受它后面相同高度的帆的影响而打了折扣。对于任意一张帆，它的推动力折扣等于在它后面并且和它在同一高度的帆的数目。\n\n所有帆的任意一种位置组合的推动力折扣总和等于在该位置下所有帆的推动力折扣的总和。\n\n![](https://cdn.luogu.com.cn/upload/pic/20670.png )\n\n这条船上有6个旗杆，从前（图上的左边）到后的高度分别是3，5，4，2，4和3。图中所示的帆的位置组合的总推动力折扣是10。上图给出了每张帆自己的推动力折扣。\n\n给定N个旗杆的高度和每个旗杆上挂的帆的数目，写一个程序求出所有位置组合中的可能达到的最小的总推动力折扣。 ", "inputFormat": "第一行包含一个整数$N(2 \\leq N \\leq 100 000)$，表示旗杆的数目。 接下来的N行每行包含两个整数$H$和$K(1 \\leq H \\leq 100 000, 1 \\leq K \\leq H)$，分别表示对应旗杆的高度及其上的帆的数目。旗杆按照从船头到船尾的顺序给出。 ", "outputFormat": "输出包含一个整数，表示可以达到的最小的总推动力折扣。\n\n注意：计算和输出结果时使用64位整数类型（在C/C++中用```long long```, 在Pascal中用```int64```）。", "hint": "这个样例数据和上页中图示的样例相同。\n\n在 25 分的测试数据中，帆的不同位置组合的总数目不超过 $1,000,000$ 。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2007] sails Sails", "background": "", "description": "Let us build a new pirate ship. There are $N$ masts on the ship. Each mast is divided into unit-length sections. The length of a mast equals the number of sections it is divided into. Some sails are hung on each mast, and each sail occupies exactly one section of the mast. On a single mast, the sails can be arranged arbitrarily among different sections, but each section can have at most one sail.\n\nIn the wind, different arrangements of sails produce different propulsive forces. A sail closer to the bow produces less propulsive force than a sail behind it at the same height. In other words, the propulsive force of a sail closer to the bow is discounted because of the sails behind it at the same height. For any sail, its propulsive force discount equals the number of sails that are behind it and at the same height.\n\nThe total propulsive force discount of an arrangement equals the sum of the propulsive force discounts of all sails under that arrangement.\n\n![](https://cdn.luogu.com.cn/upload/pic/20670.png )\n\nThis ship has 6 masts. From front (left in the figure) to back, their heights are 3, 5, 4, 2, 4, and 3. The total propulsive force discount of the sail arrangement shown in the figure is 10. The figure also gives the propulsive force discount of each individual sail.\n\nGiven the heights of the $N$ masts and the number of sails hung on each mast, write a program to find the minimum possible total propulsive force discount among all arrangements.", "inputFormat": "The first line contains an integer $N(2 \\leq N \\leq 100 000)$, the number of masts. The next $N$ lines each contain two integers $H$ and $K(1 \\leq H \\leq 100 000, 1 \\leq K \\leq H)$, representing the height of the corresponding mast and the number of sails on it. The masts are given in order from the bow to the stern.", "outputFormat": "Output one integer, the minimum total propulsive force discount that can be achieved.\n\nNote: Use a 64-bit integer type when computing and outputting the result (```long long``` in C/C++, ```int64``` in Pascal).", "hint": "This sample testdata is the same as the sample shown in the figure on the previous page.\n\nIn the testdata worth 25 points, the total number of different sail arrangements does not exceed $1,000,000$ .\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2007] sails 船帆", "background": "", "description": "让我们来建造一艘新的海盗船。船上有 N个旗杆，每根旗杆被分成单位长度的小节。旗杆的长度等于它被分成的小节的数目。每根旗杆上会挂一些帆，每张帆正好占据旗杆上的一个小节。在一根旗杆上的帆可以任意排布在不同的小节中，但是每个小节上至多能挂一张帆。\n\n在风中，帆的不同排布方式会产生不同的推动力。靠近船头的帆比它后面的相同高度上的帆获得的推动力少，换句话说，靠近船头的帆的推动力由于受它后面相同高度的帆的影响而打了折扣。对于任意一张帆，它的推动力折扣等于在它后面并且和它在同一高度的帆的数目。\n\n所有帆的任意一种位置组合的推动力折扣总和等于在该位置下所有帆的推动力折扣的总和。\n\n![](https://cdn.luogu.com.cn/upload/pic/20670.png )\n\n这条船上有6个旗杆，从前（图上的左边）到后的高度分别是3，5，4，2，4和3。图中所示的帆的位置组合的总推动力折扣是10。上图给出了每张帆自己的推动力折扣。\n\n给定N个旗杆的高度和每个旗杆上挂的帆的数目，写一个程序求出所有位置组合中的可能达到的最小的总推动力折扣。 ", "inputFormat": "第一行包含一个整数$N(2 \\leq N \\leq 100 000)$，表示旗杆的数目。 接下来的N行每行包含两个整数$H$和$K(1 \\leq H \\leq 100 000, 1 \\leq K \\leq H)$，分别表示对应旗杆的高度及其上的帆的数目。旗杆按照从船头到船尾的顺序给出。 ", "outputFormat": "输出包含一个整数，表示可以达到的最小的总推动力折扣。\n\n注意：计算和输出结果时使用64位整数类型（在C/C++中用```long long```, 在Pascal中用```int64```）。", "hint": "这个样例数据和上页中图示的样例相同。\n\n在 25 分的测试数据中，帆的不同位置组合的总数目不超过 $1,000,000$ 。", "locale": "zh-CN"}}}
{"pid": "P4648", "type": "P", "difficulty": 6, "samples": [["1 6 5 100 \n25 \n50 \n50 \n10 \n20 \n23 ", "4"], ["2 5 4 10 \n5 2 \n7 2 \n8 4 \n6 5 \n4 4 ", "8"], ["3 8 10 20 \n10 10 10 \n10 10 20 \n10 20 10 \n10 20 20 \n20 10 10 \n20 10 20 \n20 20 10 \n20 20 20 ", "12"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000, 150000]}, "tags": ["2007", "树状数组", "IOI", "枚举", "前缀和"], "title": "[IOI 2007] pairs 动物对数", "background": "", "description": "Mirko 和 Slavko 正在玩动物玩具的游戏。 首先，他们要在下图给出的三种玩具模板中选择一种。三种模板分别由一维、二维和三维的网格点（在图中用圆圈表示）组成。 \n\n![](https://cdn.luogu.com.cn/upload/pic/20672.png )\n\n接下来Mirko 把 $N$ 个小动物玩具放到选中的模板的网格点上。\n\n动物玩具可以走一步到达与它相邻的网格点上（在图中相邻的点之间有一条小短线相连）。两个网格点之间的距离定义为**从一个网格点到另一个网格点所需要移动的最小步数**。\n\n如果两个动物之间的距离小于等于$D$，则它们之间可以互相听见。Slavko 的任务是计算在模板上有多少对动物可以互相听得见。\n\n给定模板的类型、所有动物的位置以及数字$D$，写一个程序计算有多少对动物可以互相听得见。 ", "inputFormat": "输入的第一行按顺序给出四个整数： \n- 模板类型 $B (1 \\leq B \\leq 3)$; \n- 玩具动物的数目 $N (1 \\leq N \\leq 100 000)$; \n- 动物之间可以互相听得见的最大距离$D (1 \\leq D \\leq 100 000 000)$; \n- 模板的大小 $M$ ( 即在输入中允许的最大的坐标值):  当 $B=1$ 时, $M$ 最大是 $75 000 000$. 当 $B=2$时, $M$ 最大是 $75 000$. 当 $B=3$时, $M$ 最大是 $75$.\n\n接下来的$N$ 行每行包含$B$ 个整数，整数之间用空格隔开，表示一个动物玩具的坐标。坐标的取值范围是$1$ 到 $M$ ( 包括$M$ )。\n\n每个网格点可以同时包含多个动物玩具。 ", "outputFormat": "输出应该包括一个整数，表示可以互相听得见的玩具动物的对数。\n\n注意：使用64 位整数类型计算和输出结果 (在 C/C++ 中用```long long```, 在Pascal 中用```int64``` ) 。 ", "hint": "在30分的测试数据中, 动物数目 $N$ 最多是 $1 000$。\n\n如果成功通过了某一种模板（一维、二维或者三维）的全部测试数据，将会得到至少30分。\n\n对于input 1的解释： 假设动物按给出的顺序编号为$1$到$6$。$4$对互相能够听得到的动物分别是:\n- 1-5 ( 距离是5)\n- 1-6 ( 距离是2)\n- 2-3 ( 距离是0)\n- 5-6 ( 距离是3)\n\n对于input 2 的解释：$8$对动物分别是:\n- 1-2 ( 距离是2)\n- 1-4 ( 距离是4)\n- 1-5 ( 距离是3)\n- 2-3 ( 距离是3)\n- 2-4 ( 距离是4)\n- 3-4 ( 距离是3)\n- 3-5 ( 距离是4)\n- 4-5 ( 距离是3)", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2007] pairs Animal Pairs Count.", "background": "", "description": "Mirko and Slavko are playing a game with animal toys. First, they choose one of the three toy templates shown in the figure below. The three templates are made of 1D, 2D, and 3D grid points (shown as circles in the figure).\n\n![](https://cdn.luogu.com.cn/upload/pic/20672.png )\n\nNext, Mirko places $N$ small animal toys onto the grid points of the chosen template.\n\nAn animal toy can move one step to a grid point adjacent to it (in the figure, adjacent points are connected by a short line). The distance between two grid points is defined as **the minimum number of steps needed to move from one grid point to the other**.\n\nIf the distance between two animals is less than or equal to $D$, then they can hear each other. Slavko’s task is to count how many pairs of animals on the template can hear each other.\n\nGiven the template type, the positions of all animals, and the number $D$, write a program to compute how many pairs of animal toys can hear each other.", "inputFormat": "The first line of input contains four integers in order:\n- Template type $B (1 \\leq B \\leq 3)$;\n- Number of animal toys $N (1 \\leq N \\leq 100 000)$;\n- Maximum distance at which two animals can hear each other $D (1 \\leq D \\leq 100 000 000)$;\n- Template size $M$ (i.e., the maximum coordinate value allowed in the input): when $B=1$, the maximum $M$ is $75 000 000$; when $B=2$, the maximum $M$ is $75 000$; when $B=3$, the maximum $M$ is $75$.\n\nThe next $N$ lines each contain $B$ integers separated by spaces, representing the coordinates of an animal toy. Each coordinate ranges from $1$ to $M$ (including $M$).\n\nEach grid point may contain multiple animal toys at the same time.", "outputFormat": "Output one integer, the number of pairs of animal toys that can hear each other.\n\nNote: use a 64-bit integer type to compute and output the result (use ```long long``` in C/C++, and ```int64``` in Pascal).", "hint": "In the testdata worth 30 points, the number of animals $N$ is at most $1 000$.\n\nIf you pass all testdata for any one template type (1D, 2D, or 3D), you will get at least 30 points.\n\nExplanation for input 1: Suppose the animals are numbered from $1$ to $6$ in the given order. The $4$ pairs of animals that can hear each other are:\n- 1-5 (distance is 5)\n- 1-6 (distance is 2)\n- 2-3 (distance is 0)\n- 5-6 (distance is 3)\n\nExplanation for input 2: The $8$ pairs of animals are:\n- 1-2 (distance is 2)\n- 1-4 (distance is 4)\n- 1-5 (distance is 3)\n- 2-3 (distance is 3)\n- 2-4 (distance is 4)\n- 3-4 (distance is 3)\n- 3-5 (distance is 4)\n- 4-5 (distance is 3)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2007] pairs 动物对数", "background": "", "description": "Mirko 和 Slavko 正在玩动物玩具的游戏。 首先，他们要在下图给出的三种玩具模板中选择一种。三种模板分别由一维、二维和三维的网格点（在图中用圆圈表示）组成。 \n\n![](https://cdn.luogu.com.cn/upload/pic/20672.png )\n\n接下来Mirko 把 $N$ 个小动物玩具放到选中的模板的网格点上。\n\n动物玩具可以走一步到达与它相邻的网格点上（在图中相邻的点之间有一条小短线相连）。两个网格点之间的距离定义为**从一个网格点到另一个网格点所需要移动的最小步数**。\n\n如果两个动物之间的距离小于等于$D$，则它们之间可以互相听见。Slavko 的任务是计算在模板上有多少对动物可以互相听得见。\n\n给定模板的类型、所有动物的位置以及数字$D$，写一个程序计算有多少对动物可以互相听得见。 ", "inputFormat": "输入的第一行按顺序给出四个整数： \n- 模板类型 $B (1 \\leq B \\leq 3)$; \n- 玩具动物的数目 $N (1 \\leq N \\leq 100 000)$; \n- 动物之间可以互相听得见的最大距离$D (1 \\leq D \\leq 100 000 000)$; \n- 模板的大小 $M$ ( 即在输入中允许的最大的坐标值):  当 $B=1$ 时, $M$ 最大是 $75 000 000$. 当 $B=2$时, $M$ 最大是 $75 000$. 当 $B=3$时, $M$ 最大是 $75$.\n\n接下来的$N$ 行每行包含$B$ 个整数，整数之间用空格隔开，表示一个动物玩具的坐标。坐标的取值范围是$1$ 到 $M$ ( 包括$M$ )。\n\n每个网格点可以同时包含多个动物玩具。 ", "outputFormat": "输出应该包括一个整数，表示可以互相听得见的玩具动物的对数。\n\n注意：使用64 位整数类型计算和输出结果 (在 C/C++ 中用```long long```, 在Pascal 中用```int64``` ) 。 ", "hint": "在30分的测试数据中, 动物数目 $N$ 最多是 $1 000$。\n\n如果成功通过了某一种模板（一维、二维或者三维）的全部测试数据，将会得到至少30分。\n\n对于input 1的解释： 假设动物按给出的顺序编号为$1$到$6$。$4$对互相能够听得到的动物分别是:\n- 1-5 ( 距离是5)\n- 1-6 ( 距离是2)\n- 2-3 ( 距离是0)\n- 5-6 ( 距离是3)\n\n对于input 2 的解释：$8$对动物分别是:\n- 1-2 ( 距离是2)\n- 1-4 ( 距离是4)\n- 1-5 ( 距离是3)\n- 2-3 ( 距离是3)\n- 2-4 ( 距离是4)\n- 3-4 ( 距离是3)\n- 3-5 ( 距离是4)\n- 4-5 ( 距离是3)", "locale": "zh-CN"}}}
{"pid": "P4649", "type": "P", "difficulty": 6, "samples": [["5 8 \n2 1 0 \n3 2 0 \n4 3 0 \n5 4 0 \n1 3 2 \n3 5 2 \n2 4 5 \n2 5 1 ", "5"], ["9 14 \n1 2 0 \n1 3 0 \n2 3 14 \n2 6 15 \n3 4 0 \n3 5 0 \n3 6 12 \n3 7 13 \n4 6 10 \n5 6 0 \n5 7 0 \n5 8 0 \n6 9 11 \n8 9 0 ", "48"]], "limits": {"time": [300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["动态规划 DP", "2007", "IOI", "树形 DP", "仙人掌", "最近公共祖先 LCA", "状压 DP"], "title": "[IOI 2007] training 训练路径 ", "background": "", "description": "马克(Mirko)和斯拉夫克(Slavko)正在为克罗地亚举办的每年一次的双人骑车马拉松赛而紧张训练。他们需要选择一条训练路径。\n\n他们国家有$N$个城市和$M$条道路。每条道路连接两个城市。这些道路中恰好有$N-1$条是铺设好的道路，其余道路是未经铺设的土路。幸运的是，每两个城市之间都存在一条由铺设好的道路组成的通路。换句话说，这$N$个城市和$N-1$条铺设好的道路构成一个树状结构。\n\n此外，每个城市最多是$10$条道路的端点。\n\n一条训练路径由某个城市开始，途经一些道路后在原来起始的城市结束。因为马克和斯拉夫克喜欢去看新城市，所以他们制定了一条规则：绝不中途穿越已经去过的城市，并且绝不在相同的道路上骑行两次（不管方向是否相同）。训练路径可以从任何一个城市开始，并且不需要访问所有城市。\n\n显然，坐在后座的骑行者更为轻松，因为坐在前面的可以为他挡风。为此，马克和斯拉夫克在每个城市都要调换位置。为了保证他们的训练强度相同，他们要选择一条具有偶数条道路的路径。\n\n马克和斯拉夫克的竞争者决定在某些未经铺设的土路上设置路障，使得他们两人不可能找到满足上述要求的训练路径。已知在每条土路上设置路障都有一个费用值（一个正整数），并且竞争者不能在铺设好的道路上设置路障。\n\n给定城市和道路网的描述，写一个程序计算出为了使得满足上述要求的训练路径不存在，而需要的设置路障的最小总费用。", "inputFormat": "输入的第一行包含两个整数$N$和$M$，（$2\\leq N\\leq 1000$，$N-1\\leq M\\leq5000$），分别表示城市和道路的个数。 接下来的$M$行每行包含$3$个整数$A, B$和$C$（$1\\leq A\\leq N, 1\\leq B\\leq N, 0\\leq C\\leq10 000$）, 用来描述一条道路。$A$和$B$是不同的整数，表示由这条道路直接相连的两个城市。对于铺设好的道路$C$是$0$；对于土路，$C$是在该条路上设置路障所需的费用值。 每个城市最多是$10$条道路的端点。任意两个城市都不会有多于一条直接相连的道路。 ", "outputFormat": "输出包含一个整数，表示求出的最小总费用。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/20676.png )\n\n第一个样例中道路与城市的布置。已被铺设好的道路以粗边显示。\n\n![](https://cdn.luogu.com.cn/upload/pic/20677.png )\n\n共有5种可能的路线。如果边1-3、3-5和2-5被封锁，则两人将会不能使用5种路线的任何一种。封锁这三条边的代价是5。\n\n只封锁两条边，像是2-4和2-5，也是可以的，但这样会导致较高的代价，6。\n\n在前30分的测试数据中，铺设好的道路会形成一条链。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2007] training Training Route.", "background": "", "description": "Mirko and Slavko are training hard for the annual two-person cycling marathon held in Croatia. They need to choose a training route.\n\nTheir country has $N$ cities and $M$ roads. Each road connects two cities. Among these roads, exactly $N-1$ are paved roads, and the remaining roads are unpaved dirt roads. Luckily, for every pair of cities, there exists a path consisting only of paved roads. In other words, the $N$ cities and the $N-1$ paved roads form a tree.\n\nAlso, each city is an endpoint of at most $10$ roads.\n\nA training route starts from some city, goes through some roads, and ends at the same city where it started. Since Mirko and Slavko like to see new cities, they made a rule: they never pass through a city that they have already visited, and they never ride along the same road twice (no matter which direction). The training route can start from any city, and it does not need to visit all cities.\n\nObviously, the rider sitting in the back has it easier, because the rider in front blocks the wind. Therefore, Mirko and Slavko swap positions in every city. To make sure their training intensity is the same, they want to choose a route with an even number of roads.\n\nMirko and Slavko’s competitors decide to place roadblocks on some unpaved dirt roads, so that the two of them cannot find any training route that satisfies the requirements above. It is known that placing a roadblock on each dirt road has a cost (a positive integer), and the competitors cannot place roadblocks on paved roads.\n\nGiven the description of the cities and roads, write a program to compute the minimum total cost of placing roadblocks so that no training route satisfying the requirements above exists.", "inputFormat": "The first line contains two integers $N$ and $M$ ($2\\leq N\\leq 1000$, $N-1\\leq M\\leq5000$), the numbers of cities and roads. The next $M$ lines each contain three integers $A, B$ and $C$ ($1\\leq A\\leq N, 1\\leq B\\leq N, 0\\leq C\\leq10 000$), describing a road. $A$ and $B$ are different integers and represent the two cities directly connected by this road. For a paved road, $C$ is $0$; for a dirt road, $C$ is the cost to place a roadblock on this road. Each city is an endpoint of at most $10$ roads. There is at most one road directly connecting any pair of cities.", "outputFormat": "Output one integer, the minimum total cost.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/20676.png )\n\nThe layout of roads and cities in the first sample. Paved roads are shown with thick edges.\n\n![](https://cdn.luogu.com.cn/upload/pic/20677.png )\n\nThere are 5 possible routes in total. If edges 1-3, 3-5, and 2-5 are blocked, then they cannot use any of the 5 routes. The cost of blocking these three edges is 5.\n\nBlocking only two edges, such as 2-4 and 2-5, is also possible, but it leads to a higher cost, 6.\n\nIn the first 30 points of testdata, the paved roads form a chain.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2007] training 训练路径 ", "background": "", "description": "马克(Mirko)和斯拉夫克(Slavko)正在为克罗地亚举办的每年一次的双人骑车马拉松赛而紧张训练。他们需要选择一条训练路径。\n\n他们国家有$N$个城市和$M$条道路。每条道路连接两个城市。这些道路中恰好有$N-1$条是铺设好的道路，其余道路是未经铺设的土路。幸运的是，每两个城市之间都存在一条由铺设好的道路组成的通路。换句话说，这$N$个城市和$N-1$条铺设好的道路构成一个树状结构。\n\n此外，每个城市最多是$10$条道路的端点。\n\n一条训练路径由某个城市开始，途经一些道路后在原来起始的城市结束。因为马克和斯拉夫克喜欢去看新城市，所以他们制定了一条规则：绝不中途穿越已经去过的城市，并且绝不在相同的道路上骑行两次（不管方向是否相同）。训练路径可以从任何一个城市开始，并且不需要访问所有城市。\n\n显然，坐在后座的骑行者更为轻松，因为坐在前面的可以为他挡风。为此，马克和斯拉夫克在每个城市都要调换位置。为了保证他们的训练强度相同，他们要选择一条具有偶数条道路的路径。\n\n马克和斯拉夫克的竞争者决定在某些未经铺设的土路上设置路障，使得他们两人不可能找到满足上述要求的训练路径。已知在每条土路上设置路障都有一个费用值（一个正整数），并且竞争者不能在铺设好的道路上设置路障。\n\n给定城市和道路网的描述，写一个程序计算出为了使得满足上述要求的训练路径不存在，而需要的设置路障的最小总费用。", "inputFormat": "输入的第一行包含两个整数$N$和$M$，（$2\\leq N\\leq 1000$，$N-1\\leq M\\leq5000$），分别表示城市和道路的个数。 接下来的$M$行每行包含$3$个整数$A, B$和$C$（$1\\leq A\\leq N, 1\\leq B\\leq N, 0\\leq C\\leq10 000$）, 用来描述一条道路。$A$和$B$是不同的整数，表示由这条道路直接相连的两个城市。对于铺设好的道路$C$是$0$；对于土路，$C$是在该条路上设置路障所需的费用值。 每个城市最多是$10$条道路的端点。任意两个城市都不会有多于一条直接相连的道路。 ", "outputFormat": "输出包含一个整数，表示求出的最小总费用。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/20676.png )\n\n第一个样例中道路与城市的布置。已被铺设好的道路以粗边显示。\n\n![](https://cdn.luogu.com.cn/upload/pic/20677.png )\n\n共有5种可能的路线。如果边1-3、3-5和2-5被封锁，则两人将会不能使用5种路线的任何一种。封锁这三条边的代价是5。\n\n只封锁两条边，像是2-4和2-5，也是可以的，但这样会导致较高的代价，6。\n\n在前30分的测试数据中，铺设好的道路会形成一条链。", "locale": "zh-CN"}}}
{"pid": "P4650", "type": "P", "difficulty": 4, "samples": [["4 2\n1 2 2 3\n", "2 3 1 2"], ["5 3\n2 1 3 0 3\n", "3 3 0 1 2"], ["6 4\n0 2 5 2 0 1\n", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "Special Judge", "COCI（克罗地亚）"], "title": "[COCI 2017/2018 #5] Karte", "background": "", "description": "有$N$ 张牌叠在一起，第 $i$ 张牌上，有一个数字 $a_i$ 表示它下面**至少**有 $a_i$ 张牌上的信息是错误的，若它下面确实有至少 $a_i$ 张牌的信息是错误的，那这张牌的信息就是正确的，否则这张牌的信息就是错误的。（我们认为最下面的牌的后面有 $0$ 张错误的）\n\n现在需要你重新调整牌的顺序，使得正好有 $K$ 张牌上的信息是错误的。", "inputFormat": "第一行两个正整数 $N$ 和 $K$ $( 1 ≤ N≤ 5×10^5,0 ≤ K≤ N )$表示牌的张数和要求的错误信息的个数。\n接下来 $N$ 行，每行一个数，表示对应的 $a_i$ $(0 ≤ a_i≤ 5×10^5 )$", "outputFormat": "如果调整方案不存在，输出$-1$。否则输出由顶部到底部 $N$ 张牌对应的 $a_i$，若有多种方案，输出任意一种即可。", "hint": "$30\\%$的数据 $N≤ 16$。\n\n另有$40\\%$的数据 $N≤ 2000$。\n\n**样例 2 说明：**\n\n第 $5$ 张牌上写的是$2$，但是其后面只有 $0$ 张错误，所以它是错误的。\n\n第 $4$ 张牌上写的是$1$，其后面有 $1$ 张错误（第五张），所以它是正确的。\n\n第 $3$ 张牌上写的是$0$，其后面有 $1$ 张错误（第五张），所以它是正确的。\n\n第 $2$ 张牌上写的是$3$，但是其后面只有 $1$ 张错误（第五张），所以它是错误的。\n\n第 $1$ 张牌上写的是$3$，但是其后面只有 $2$ 张错误（第五张，第二张），所以它是错误的。\n\n因此总共有 $3$ 张是错误的。", "locale": "zh-CN", "translations": {"en": {"title": "[COCI 2017/2018 #5] Karte", "background": "", "description": "There are $N$ cards stacked together. On the $i$-th card, there is a number $a_i$, meaning that **at least** $a_i$ cards below it have incorrect information. If there are indeed at least $a_i$ cards below it with incorrect information, then the information on this card is correct; otherwise, the information on this card is incorrect. (We consider that below the bottom card there are $0$ incorrect cards.)\n\nNow you need to rearrange the order of the cards so that exactly $K$ cards have incorrect information.", "inputFormat": "The first line contains two positive integers $N$ and $K$ $(1 \\le N \\le 5 \\times 10^5, 0 \\le K \\le N)$, representing the number of cards and the required number of incorrect pieces of information.\n\nThe next $N$ lines each contain one number, representing the corresponding $a_i$ $(0 \\le a_i \\le 5 \\times 10^5)$.", "outputFormat": "If no rearrangement exists, output $-1$. Otherwise, output the $a_i$ of the $N$ cards from top to bottom. If there are multiple solutions, output any one.", "hint": "For $30\\%$ of the testdata, $N \\le 16$.\n\nFor another $40\\%$ of the testdata, $N \\le 2000$.\n\n**Explanation of Sample 2:**\n\nThe $5$-th card shows $2$, but there are only $0$ incorrect cards below it, so it is incorrect.\n\nThe $4$-th card shows $1$. There is $1$ incorrect card below it (the $5$-th), so it is correct.\n\nThe $3$-th card shows $0$. There is $1$ incorrect card below it (the $5$-th), so it is correct.\n\nThe $2$-th card shows $3$, but there is only $1$ incorrect card below it (the $5$-th), so it is incorrect.\n\nThe $1$-st card shows $3$, but there are only $2$ incorrect cards below it (the $5$-th and the $2$-nd), so it is incorrect.\n\nTherefore, there are $3$ incorrect cards in total.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[COCI 2017/2018 #5] Karte", "background": "", "description": "有$N$ 张牌叠在一起，第 $i$ 张牌上，有一个数字 $a_i$ 表示它下面**至少**有 $a_i$ 张牌上的信息是错误的，若它下面确实有至少 $a_i$ 张牌的信息是错误的，那这张牌的信息就是正确的，否则这张牌的信息就是错误的。（我们认为最下面的牌的后面有 $0$ 张错误的）\n\n现在需要你重新调整牌的顺序，使得正好有 $K$ 张牌上的信息是错误的。", "inputFormat": "第一行两个正整数 $N$ 和 $K$ $( 1 ≤ N≤ 5×10^5,0 ≤ K≤ N )$表示牌的张数和要求的错误信息的个数。\n接下来 $N$ 行，每行一个数，表示对应的 $a_i$ $(0 ≤ a_i≤ 5×10^5 )$", "outputFormat": "如果调整方案不存在，输出$-1$。否则输出由顶部到底部 $N$ 张牌对应的 $a_i$，若有多种方案，输出任意一种即可。", "hint": "$30\\%$的数据 $N≤ 16$。\n\n另有$40\\%$的数据 $N≤ 2000$。\n\n**样例 2 说明：**\n\n第 $5$ 张牌上写的是$2$，但是其后面只有 $0$ 张错误，所以它是错误的。\n\n第 $4$ 张牌上写的是$1$，其后面有 $1$ 张错误（第五张），所以它是正确的。\n\n第 $3$ 张牌上写的是$0$，其后面有 $1$ 张错误（第五张），所以它是正确的。\n\n第 $2$ 张牌上写的是$3$，但是其后面只有 $1$ 张错误（第五张），所以它是错误的。\n\n第 $1$ 张牌上写的是$3$，但是其后面只有 $2$ 张错误（第五张，第二张），所以它是错误的。\n\n因此总共有 $3$ 张是错误的。", "locale": "zh-CN"}}}
{"pid": "P4651", "type": "P", "difficulty": 4, "samples": [["2 1\n0 0 2 1\nbb\nnwwnw\nbn", "6"], ["5 4\n0 2 5 2\nnnbnn\nnnnwwbwnnnn\nnbbbn\nnnwbwwbwwnn\nbwwww\nnnbwbbwwbnn\nnwwwn\nnnnnbwbbnnn\nnnwnn", "22"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "2005", "最短路", "BalticOI（波罗的海）"], "title": "[BalticOI 2005] Maze (Day1)", "background": null, "description": "给出一个平行四边形的长与高。给出入口与出口，对于四边形的每条边都有三种可能：黑色、白色、无色。你要找出一条路径，走过的边黑白交替，且长度最短。", "inputFormat": "第一行给出平行四边形的长与高，且值在 $[1,500]$。\n\n第二行给出入口，出口坐标。\n\n下面的字符矩阵代表这个平行四边形每条边的颜色，`n` 表示无色，`w` 表示白色，`b` 表示黑色。", "outputFormat": "输出路径的最短长度。", "hint": "对于第一个数据:\n\n$(0, 0) \\rightarrow (1, 0) \\rightarrow (0, 1) \\rightarrow (1, 1) \\rightarrow (1, 0) \\rightarrow(2, 0) \\rightarrow (2, 1)$\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/a7qxcn67.png)  \n\n对于第二个数据:\n\n$(0, 2) \\rightarrow (1, 2) \\rightarrow (1, 1) \\rightarrow (2, 1) \\rightarrow (2, 0) \\rightarrow \\\\\n(3, 0) \\rightarrow (3, 1) \\rightarrow (3, 2) \\rightarrow (4, 1) \\rightarrow (3, 1) \\rightarrow \\\\\n(3, 0) \\rightarrow (2, 0) \\rightarrow (2, 1) \\rightarrow (1, 1) \\rightarrow (1, 2) \\rightarrow \\\\\n(1, 3) \\rightarrow (2, 3) \\rightarrow (2, 4) \\rightarrow (3, 4) \\rightarrow (3, 3) \\rightarrow \\\\\n(4, 3) \\rightarrow (4, 2) \\rightarrow (5, 2)$\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8d0gue8n.png)", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2005] Maze (Day1)", "background": "", "description": "You are given the length and height of a parallelogram. You are also given the coordinates of the entrance and the exit. For each side (edge) of the quadrilateral, there are three possible states: black, white, or colorless. You need to find a shortest path such that the colors of the edges you traverse alternate between black and white.", "inputFormat": "The first line gives the length and height of the parallelogram, with values in $[1,500]$.\n\nThe second line gives the coordinates of the entrance and the exit.\n\nThe following character matrix represents the color of each edge of this parallelogram: `n` means colorless, `w` means white, and `b` means black.", "outputFormat": "Output the shortest length of the path.", "hint": "For the first testdata:\n\n$(0, 0) \\rightarrow (1, 0) \\rightarrow (0, 1) \\rightarrow (1, 1) \\rightarrow (1, 0) \\rightarrow(2, 0) \\rightarrow (2, 1)$\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/a7qxcn67.png)  \n\nFor the second testdata:\n\n$(0, 2) \\rightarrow (1, 2) \\rightarrow (1, 1) \\rightarrow (2, 1) \\rightarrow (2, 0) \\rightarrow \\\\\n(3, 0) \\rightarrow (3, 1) \\rightarrow (3, 2) \\rightarrow (4, 1) \\rightarrow (3, 1) \\rightarrow \\\\\n(3, 0) \\rightarrow (2, 0) \\rightarrow (2, 1) \\rightarrow (1, 1) \\rightarrow (1, 2) \\rightarrow \\\\\n(1, 3) \\rightarrow (2, 3) \\rightarrow (2, 4) \\rightarrow (3, 4) \\rightarrow (3, 3) \\rightarrow \\\\\n(4, 3) \\rightarrow (4, 2) \\rightarrow (5, 2)$\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8d0gue8n.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2005] Maze (Day1)", "background": null, "description": "给出一个平行四边形的长与高。给出入口与出口，对于四边形的每条边都有三种可能：黑色、白色、无色。你要找出一条路径，走过的边黑白交替，且长度最短。", "inputFormat": "第一行给出平行四边形的长与高，且值在 $[1,500]$。\n\n第二行给出入口，出口坐标。\n\n下面的字符矩阵代表这个平行四边形每条边的颜色，`n` 表示无色，`w` 表示白色，`b` 表示黑色。", "outputFormat": "输出路径的最短长度。", "hint": "对于第一个数据:\n\n$(0, 0) \\rightarrow (1, 0) \\rightarrow (0, 1) \\rightarrow (1, 1) \\rightarrow (1, 0) \\rightarrow(2, 0) \\rightarrow (2, 1)$\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/a7qxcn67.png)  \n\n对于第二个数据:\n\n$(0, 2) \\rightarrow (1, 2) \\rightarrow (1, 1) \\rightarrow (2, 1) \\rightarrow (2, 0) \\rightarrow \\\\\n(3, 0) \\rightarrow (3, 1) \\rightarrow (3, 2) \\rightarrow (4, 1) \\rightarrow (3, 1) \\rightarrow \\\\\n(3, 0) \\rightarrow (2, 0) \\rightarrow (2, 1) \\rightarrow (1, 1) \\rightarrow (1, 2) \\rightarrow \\\\\n(1, 3) \\rightarrow (2, 3) \\rightarrow (2, 4) \\rightarrow (3, 4) \\rightarrow (3, 3) \\rightarrow \\\\\n(4, 3) \\rightarrow (4, 2) \\rightarrow (5, 2)$\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8d0gue8n.png)", "locale": "zh-CN"}}}
{"pid": "P4652", "type": "P", "difficulty": 6, "samples": [["5 6\n1 2\n1 2\n4 3\n2 3\n1 3\n5 1\n2\n4 5\n1 3", "BBRBBL"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["图论", "2017", "CEOI（中欧）", "Tarjan", "双连通分量"], "title": "[CEOI 2017] One-Way Streets", "background": "", "description": "给定一张 $n$ 个点 $m$ 条边的无向图，现在想要把这张图定向。\n\n有 $p$ 个限制条件，每个条件形如 $(x_i,y_i)$，表示在新的有向图当中，$x_i$ 要能够沿着一些边走到 $y_i$​​。\n\n现在请你求出，每条边的方向是否能够唯一确定。同时请给出这些能够唯一确定的边的方向。\n\n数据保证有解。", "inputFormat": "第一行两个空格隔开的正整数 $n,m$ 。\n\n接下来 $m$ 行，每行两个空格隔开的正整数 $a_i,b_i$​​，表示 $a_i,b_i$​​ 之间有一条边。\n\n接下来一行一个整数 $p$，表示限制条件的个数。\n\n接下来 $p$ 行，每行两个空格隔开的正整数 $x_i,y_i$，描述一个 $(x_i,y_i)$ 的限制条件。", "outputFormat": "输出一行一个长度为 $m$ 的字符串，表示每条边的答案：\n\n-    若第 $i$ 条边必须得要是 $a_i$​​ 指向 $b_i$ 的，那么这个字符串的第 $i$ 个字符应当为 ``R``；\n\n-    若第 $i$ 条边必须得要是 $b_i$​​ 指向 $a_i$​​ 的，那么这个字符串的第 $i$ 个字符应当为 ``L``；\n\n-    否则，若第 $i$ 条边的方向无法唯一确定，那么这个字符串的第 $i$ 个字符应当为 ``B``。\n", "hint": "对于所有测试点，有 $1\\le n,m,p\\le 100\\ 000;1\\le a_i,b_i,x_i,y_i\\le n$。", "locale": "zh-CN", "translations": {"en": {"title": "[CEOI 2017] One-Way Streets", "background": "", "description": "You are given an undirected graph with $n$ vertices and $m$ edges. Now you want to orient this graph.\n\nThere are $p$ constraints. Each constraint is of the form $(x_i, y_i)$, meaning that in the new directed graph, $x_i$ must be able to reach $y_i$ by following some directed edges.\n\nPlease determine whether the direction of each edge can be uniquely determined. Also output the direction of those edges whose directions are uniquely determined.\n\nIt is guaranteed that a solution exists.", "inputFormat": "The first line contains two positive integers $n, m$ separated by spaces.\n\nThe next $m$ lines each contain two positive integers $a_i, b_i$ separated by spaces, indicating that there is an edge between $a_i$ and $b_i$.\n\nThe next line contains one integer $p$, the number of constraints.\n\nThe next $p$ lines each contain two positive integers $x_i, y_i$ separated by spaces, describing a constraint $(x_i, y_i)$.", "outputFormat": "Output one line containing a string of length $m$, representing the answer for each edge:\n\n- If the $i$-th edge must be directed from $a_i$ to $b_i$, then the $i$-th character should be `R`.\n\n- If the $i$-th edge must be directed from $b_i$ to $a_i$, then the $i$-th character should be `L`.\n\n- Otherwise, if the direction of the $i$-th edge cannot be uniquely determined, then the $i$-th character should be `B`.", "hint": "Constraints: for all testdata, $1 \\le n, m, p \\le 100\\,000$; $1 \\le a_i, b_i, x_i, y_i \\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CEOI 2017] One-Way Streets", "background": "", "description": "给定一张 $n$ 个点 $m$ 条边的无向图，现在想要把这张图定向。\n\n有 $p$ 个限制条件，每个条件形如 $(x_i,y_i)$，表示在新的有向图当中，$x_i$ 要能够沿着一些边走到 $y_i$​​。\n\n现在请你求出，每条边的方向是否能够唯一确定。同时请给出这些能够唯一确定的边的方向。\n\n数据保证有解。", "inputFormat": "第一行两个空格隔开的正整数 $n,m$ 。\n\n接下来 $m$ 行，每行两个空格隔开的正整数 $a_i,b_i$​​，表示 $a_i,b_i$​​ 之间有一条边。\n\n接下来一行一个整数 $p$，表示限制条件的个数。\n\n接下来 $p$ 行，每行两个空格隔开的正整数 $x_i,y_i$，描述一个 $(x_i,y_i)$ 的限制条件。", "outputFormat": "输出一行一个长度为 $m$ 的字符串，表示每条边的答案：\n\n-    若第 $i$ 条边必须得要是 $a_i$​​ 指向 $b_i$ 的，那么这个字符串的第 $i$ 个字符应当为 ``R``；\n\n-    若第 $i$ 条边必须得要是 $b_i$​​ 指向 $a_i$​​ 的，那么这个字符串的第 $i$ 个字符应当为 ``L``；\n\n-    否则，若第 $i$ 条边的方向无法唯一确定，那么这个字符串的第 $i$ 个字符应当为 ``B``。\n", "hint": "对于所有测试点，有 $1\\le n,m,p\\le 100\\ 000;1\\le a_i,b_i,x_i,y_i\\le n$。", "locale": "zh-CN"}}}
{"pid": "P4653", "type": "P", "difficulty": 3, "samples": [["4\n1.4 3.7\n1.2 2\n1.6 1.4\n1.9 1.5", "0.5000"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["贪心", "2017", "二分", "三分", "排序", "CEOI（中欧）", "前缀和", "双指针 two-pointer"], "title": "[CEOI 2017] Sure Bet", "background": null, "description": "现在有 $n$ 个 A 类灯泡和 $n$ 个 B 类灯泡，每个灯泡都有各自的权值。\n\n我们将这些灯泡分为 $n$ 组，每组包含一个来自 A 类的灯泡和一个来自 B 类的灯泡。\n\n你可以从中选取任意个灯泡，每选取一个灯泡需要花费 $1$ 的代价。\n\n在你选取完之后，系统会随机在 A 类和 B 类中选择一个类型，并点亮那一类的所有灯泡。你选取的每个点亮的灯泡会给你带来等于它权值的收益。\n\n现在请你合理选取灯泡，以最大化可能的最小收益。你只需要求出来这个收益即可。", "inputFormat": "第一行一个正整数 $n$ ，表示灯泡的组数。\n\n接下来 $n$ 行每行两个空格隔开的实数 $A_i,B_i$。分别表示属于这组的 A 灯泡和 B 灯泡的权值。输入的实数不会超过四位小数。", "outputFormat": "输出最大化的最小可能收益，请输出到小数点后恰好四位。", "hint": "**样例解释**\n\n最优策略是选择第一组的 B 灯泡和第三组的 A 灯泡和第四组的 A 灯泡：\n\n- 如果 B 类灯泡被点亮，收益是 $3.7-3=0.7$。\n- 如果 A 类灯泡被点亮，收益是 $1.6+1.9-3=0.5$ 。\n\n最小可能收益是 $0.5$。\n\n**数据范围**\n\n对于所有测试点，有 $1.0\\le A_i,B_i\\le 1000.0$，$0\\le n\\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[CEOI 2017] Sure Bet", "background": null, "description": "Luck is a fundamental part of betting. Some people improve their chances and earnings by having good knowledge of what they are betting on. We will take a different approach.\n\nVarious bookmakers offer different *odds* or quotas for the same outcome. (An *odds* of $x$ means that if you bet 1 euro and predict the outcome correctly, you get $x$ euros back. If you predict the outcome incorrectly, you of course get nothing back. Note that you pay 1 euro regardless of the outcome.) What if you could be certain of making a profit by cleverly placing several bets? You would want to make this guaranteed profit as large as possible.\n\nThe event we want to bet on has two possible outcomes. There are $n$ bookmakers that offer different odds. Let us denote the odds offered by the $i$-th bookmaker for the first outcome with $a_i$, and the odds offered for the second outcome with $b_i$. You can place a bet on any subset of the offered odds. You can even bet on both outcomes at the same bookmaker. However, all bets have to be exactly 1 euro and you cannot bet on the same outcome with the same bookmaker multiple times.\n\nIn case of the first outcome, you will receive $a_i$ euros from every bookmaker $i$ with whom you placed a bet on the first outcome. Similarly, in case of the second outcome, you will receive $b_i$ euros from all eligible bookmakers. Of course in both cases, you already paid 1 euro for every bet you placed.\n\nWhat is the largest *guaranteed* profit (i.e. regardless of the outcome) if you place your bets optimally?", "inputFormat": "The first line contains the number of bookmakers, $n$. The following $n$ lines describe the odds offered by each bookmaker with two space-separated real numbers $a_i$ and $b_i$ - the odds for the first and second outcome offered by the $i$-th bookmaker. The odds will be given to at most 4 decimal places.", "outputFormat": "Output the maximum guaranteed profit rounded to exactly 4 decimal places.", "hint": "#### Comment\n\nThe optimal betting strategy consists of betting on the second outcome with the first bookmaker and on the first outcome with the third and fourth bookmaker. In case of the first outcome, we will earn $1.6 + 1.9 − 3 = 0.5$ and in case of the second outcome $3.7 − 3 = 0.7$. So we’re guaranteed 0.5 euros regardless of the outcome.\n\n\n#### Constraints\n\n- $1.0 \\le a_i, b_i \\le 1000.0$\n- $1 \\le n \\le 100\\ 000$\n##### Subtask 1 (20 points)\n- $n \\le 10$\n##### Subtask 2 (40 points)\n- $n \\le 1\\ 000$\n##### Subtask 3 (40 points)\n- no additional constraints", "locale": "en"}, "zh-CN": {"title": "[CEOI 2017] Sure Bet", "background": null, "description": "现在有 $n$ 个 A 类灯泡和 $n$ 个 B 类灯泡，每个灯泡都有各自的权值。\n\n我们将这些灯泡分为 $n$ 组，每组包含一个来自 A 类的灯泡和一个来自 B 类的灯泡。\n\n你可以从中选取任意个灯泡，每选取一个灯泡需要花费 $1$ 的代价。\n\n在你选取完之后，系统会随机在 A 类和 B 类中选择一个类型，并点亮那一类的所有灯泡。你选取的每个点亮的灯泡会给你带来等于它权值的收益。\n\n现在请你合理选取灯泡，以最大化可能的最小收益。你只需要求出来这个收益即可。", "inputFormat": "第一行一个正整数 $n$ ，表示灯泡的组数。\n\n接下来 $n$ 行每行两个空格隔开的实数 $A_i,B_i$。分别表示属于这组的 A 灯泡和 B 灯泡的权值。输入的实数不会超过四位小数。", "outputFormat": "输出最大化的最小可能收益，请输出到小数点后恰好四位。", "hint": "**样例解释**\n\n最优策略是选择第一组的 B 灯泡和第三组的 A 灯泡和第四组的 A 灯泡：\n\n- 如果 B 类灯泡被点亮，收益是 $3.7-3=0.7$。\n- 如果 A 类灯泡被点亮，收益是 $1.6+1.9-3=0.5$ 。\n\n最小可能收益是 $0.5$。\n\n**数据范围**\n\n对于所有测试点，有 $1.0\\le A_i,B_i\\le 1000.0$，$0\\le n\\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P4654", "type": "P", "difficulty": 6, "samples": [["10 1 4\n1 2\n2 3\n2 4\n3 9\n3 5\n4 7\n4 6\n6 8\n7 10", "4"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2017", "二分", "CEOI（中欧）", "树形 DP"], "title": "[CEOI 2017] Mousetrap", "background": "", "description": "有一个有 $n$ 个房间和 $n-1$ 条走廊的迷宫，保证任意两个房间可以通过走廊互相到达，换句话说，这个迷宫的结构是一棵树。\n\n一个老鼠被放进了迷宫，迷宫的管理者决定和老鼠做个游戏。\n\n一开始，有一个房间被放置了陷阱，老鼠出现在另一个房间。老鼠可以通过走廊到达别的房间，但是会弄脏它经过的走廊。老鼠不愿意通过脏的走廊。\n\n每个时刻，管理者可以进行一次操作：堵住一条走廊使得老鼠不能通过，或者擦干净一条走廊使得老鼠可以通过。然后老鼠会通过一条干净的并且没被堵住的走廊到达另一个房间。只有在没有这样的走廊的情况下，老鼠才不会动。一开始所有走廊都是干净的。管理者不能疏通已经被堵住的走廊。\n\n现在管理者希望通过尽量少的操作将老鼠赶到有陷阱的房间，而老鼠则希望管理者的操作数尽量多。请计算双方都采取最优策略的情况下管理者需要的操作数量。\n\n注意：管理者可以选择在一些时刻不操作。", "inputFormat": "第一行三个空格隔开的正整数数 $n,t,m$。分别代表房间的个数，陷阱房的编号和老鼠起始房间的编号。\n\n接下来 $n-1$ 行，每行两个空格隔开的整数 $a_i,b_i$​​，表示有一条走廊连接编号为 $a_i$ 和 $b_i$​​ 的房间。", "outputFormat": "输出一行包含一个整数，表示双方都采取最优策略的情况下，管理者需要的操作数量。", "hint": "**样例解释**\n\n-    管理者先堵住房间 $4$ 和 $7$ 之间的走廊。\n-    老鼠走到房间 $6$。房间 $4$ 和 $6$ 之间的走廊现在是脏的。\n-    管理者堵住房间 $6$ 和 $8$ 之间的走廊。\n-    老鼠不能动。\n-    管理者清理房间 $4$ 和 $6$ 之间的走廊，房间 $4$ 和 $6$ 之间的走廊现在是干净的。\n-    老鼠走到房间 $4$，房间 $4$ 和 $6$ 之间的走廊现在是脏的。\n-    管理者堵住房间 $2$ 和 $3$ 之间的走廊。\n-    老鼠走到房间 $2$，房间 $2$ 和 $4$ 之间的走廊现在是脏的。\n-    管理者不进行操作。\n-    老鼠走到房间 $1$。\n\n这个过程中管理者总共进行了 $4$ 次操作。\n\n**数据范围**\n\n对于所有的数据，$1 \\le n \\le 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[CEOI 2017] Mousetrap", "background": "", "description": "There is a maze with $n$ rooms and $n-1$ corridors. It is guaranteed that any two rooms are connected by corridors; in other words, the maze structure is a tree.\n\nA mouse is put into the maze, and the maze manager decides to play a game with the mouse.\n\nAt the beginning, one room contains a trap, and the mouse appears in another room. The mouse can move to other rooms through corridors, but it will dirty every corridor it passes through. The mouse does not want to go through dirty corridors.\n\nAt each moment, the manager may perform one operation: block a corridor so that the mouse cannot pass through it, or clean a corridor so that the mouse can pass through it. Then the mouse will move through one corridor that is clean and not blocked to another room. Only if there is no such corridor will the mouse stay still. Initially, all corridors are clean. The manager cannot unblock a corridor once it has been blocked.\n\nNow the manager wants to drive the mouse into the room with the trap using as few operations as possible, while the mouse wants the manager to use as many operations as possible. Compute the number of operations the manager needs when both sides play optimally.\n\nNote: The manager may choose to do nothing at some moments.", "inputFormat": "The first line contains three space-separated positive integers $n,t,m$, representing the number of rooms, the index of the trap room, and the index of the mouse’s starting room.\n\nThe next $n-1$ lines each contain two space-separated integers $a_i,b_i$, meaning there is a corridor connecting rooms $a_i$ and $b_i$.", "outputFormat": "Output one line containing one integer, indicating the number of operations the manager needs when both sides play optimally.", "hint": "**Sample Explanation**\n\n- The manager first blocks the corridor between rooms $4$ and $7$.\n- The mouse moves to room $6$. The corridor between rooms $4$ and $6$ is now dirty.\n- The manager blocks the corridor between rooms $6$ and $8$.\n- The mouse cannot move.\n- The manager cleans the corridor between rooms $4$ and $6$. The corridor between rooms $4$ and $6$ is now clean.\n- The mouse moves to room $4$. The corridor between rooms $4$ and $6$ is now dirty.\n- The manager blocks the corridor between rooms $2$ and $3$.\n- The mouse moves to room $2$. The corridor between rooms $2$ and $4$ is now dirty.\n- The manager performs no operation.\n- The mouse moves to room $1$.\n\nIn this process, the manager performed a total of $4$ operations.\n\n**Constraints**\n\nFor all testdata, $1 \\le n \\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CEOI 2017] Mousetrap", "background": "", "description": "有一个有 $n$ 个房间和 $n-1$ 条走廊的迷宫，保证任意两个房间可以通过走廊互相到达，换句话说，这个迷宫的结构是一棵树。\n\n一个老鼠被放进了迷宫，迷宫的管理者决定和老鼠做个游戏。\n\n一开始，有一个房间被放置了陷阱，老鼠出现在另一个房间。老鼠可以通过走廊到达别的房间，但是会弄脏它经过的走廊。老鼠不愿意通过脏的走廊。\n\n每个时刻，管理者可以进行一次操作：堵住一条走廊使得老鼠不能通过，或者擦干净一条走廊使得老鼠可以通过。然后老鼠会通过一条干净的并且没被堵住的走廊到达另一个房间。只有在没有这样的走廊的情况下，老鼠才不会动。一开始所有走廊都是干净的。管理者不能疏通已经被堵住的走廊。\n\n现在管理者希望通过尽量少的操作将老鼠赶到有陷阱的房间，而老鼠则希望管理者的操作数尽量多。请计算双方都采取最优策略的情况下管理者需要的操作数量。\n\n注意：管理者可以选择在一些时刻不操作。", "inputFormat": "第一行三个空格隔开的正整数数 $n,t,m$。分别代表房间的个数，陷阱房的编号和老鼠起始房间的编号。\n\n接下来 $n-1$ 行，每行两个空格隔开的整数 $a_i,b_i$​​，表示有一条走廊连接编号为 $a_i$ 和 $b_i$​​ 的房间。", "outputFormat": "输出一行包含一个整数，表示双方都采取最优策略的情况下，管理者需要的操作数量。", "hint": "**样例解释**\n\n-    管理者先堵住房间 $4$ 和 $7$ 之间的走廊。\n-    老鼠走到房间 $6$。房间 $4$ 和 $6$ 之间的走廊现在是脏的。\n-    管理者堵住房间 $6$ 和 $8$ 之间的走廊。\n-    老鼠不能动。\n-    管理者清理房间 $4$ 和 $6$ 之间的走廊，房间 $4$ 和 $6$ 之间的走廊现在是干净的。\n-    老鼠走到房间 $4$，房间 $4$ 和 $6$ 之间的走廊现在是脏的。\n-    管理者堵住房间 $2$ 和 $3$ 之间的走廊。\n-    老鼠走到房间 $2$，房间 $2$ 和 $4$ 之间的走廊现在是脏的。\n-    管理者不进行操作。\n-    老鼠走到房间 $1$。\n\n这个过程中管理者总共进行了 $4$ 次操作。\n\n**数据范围**\n\n对于所有的数据，$1 \\le n \\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P4655", "type": "P", "difficulty": 6, "samples": [["6\n3 8 7 1 6 6\n0 -1 9 1 2 0", "17"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2017", "线段树", "cdq 分治", "CEOI（中欧）", "斜率优化", "李超线段树"], "title": "[CEOI 2017] Building Bridges", "background": "", "description": "有 $n$ 根柱子依次排列，每根柱子都有一个高度。第 $i$ 根柱子的高度为 $h_i$。\n\n现在想要建造若干座桥，如果一座桥架在第 $i$ 根柱子和第 $j$ 根柱子之间，那么需要 $(h_i-h_j)^2$​​ 的代价。\n\n在造桥前，所有用不到的柱子都会被拆除，因为他们会干扰造桥进程。第 $i$ 根柱子被拆除的代价为 $w_i$，注意 $w_i$ 不一定非负，因为可能政府希望拆除某些柱子。\n\n现在政府想要知道，通过桥梁把第 $1$ 根柱子和第 $n$ 根柱子连接的最小代价。注意桥梁不能在端点以外的任何地方相交。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个空格隔开的整数，依次表示 $h_1,h_2,\\cdots,h_n$​​。\n\n第三行 $n$ 个空格隔开的整数，依次表示 $w_1,w_2,\\cdots,w_n$​​。", "outputFormat": "输出一行一个整数表示最小代价，注意最小代价不一定是正数。", "hint": "对于 $100\\%$ 的数据，有 $2\\le n\\le 10^5;0\\le h_i,\\vert w_i\\vert\\le 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[CEOI 2017] Building Bridges", "background": "", "description": "There are $n$ pillars arranged in order, and each pillar has a height. The height of the $i$-th pillar is $h_i$.\n\nNow we want to build several bridges. If a bridge is built between the $i$-th pillar and the $j$-th pillar, it costs $(h_i-h_j)^2$.\n\nBefore building bridges, all pillars that are not used will be demolished, because they would interfere with the construction process. The cost to demolish the $i$-th pillar is $w_i$. Note that $w_i$ is not necessarily non-negative, because the government may want some pillars to be demolished.\n\nNow the government wants to know the minimum total cost to connect pillar $1$ and pillar $n$ using bridges. Note that bridges cannot intersect anywhere other than at their endpoints.", "inputFormat": "The first line contains a positive integer $n$.\n\nThe second line contains $n$ space-separated integers, which are $h_1,h_2,\\cdots,h_n$ in order.\n\nThe third line contains $n$ space-separated integers, which are $w_1,w_2,\\cdots,w_n$ in order.", "outputFormat": "Output one line with one integer, the minimum total cost. Note that the minimum total cost is not necessarily positive.", "hint": "For $100\\%$ of the testdata, $2\\le n\\le 10^5;0\\le h_i,\\vert w_i\\vert\\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CEOI 2017] Building Bridges", "background": "", "description": "有 $n$ 根柱子依次排列，每根柱子都有一个高度。第 $i$ 根柱子的高度为 $h_i$。\n\n现在想要建造若干座桥，如果一座桥架在第 $i$ 根柱子和第 $j$ 根柱子之间，那么需要 $(h_i-h_j)^2$​​ 的代价。\n\n在造桥前，所有用不到的柱子都会被拆除，因为他们会干扰造桥进程。第 $i$ 根柱子被拆除的代价为 $w_i$，注意 $w_i$ 不一定非负，因为可能政府希望拆除某些柱子。\n\n现在政府想要知道，通过桥梁把第 $1$ 根柱子和第 $n$ 根柱子连接的最小代价。注意桥梁不能在端点以外的任何地方相交。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个空格隔开的整数，依次表示 $h_1,h_2,\\cdots,h_n$​​。\n\n第三行 $n$ 个空格隔开的整数，依次表示 $w_1,w_2,\\cdots,w_n$​​。", "outputFormat": "输出一行一个整数表示最小代价，注意最小代价不一定是正数。", "hint": "对于 $100\\%$ 的数据，有 $2\\le n\\le 10^5;0\\le h_i,\\vert w_i\\vert\\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P4656", "type": "P", "difficulty": 4, "samples": [["4\nbonobo\ndeleted\nracecar\nracecars", "3\n5\n7\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2017", "CEOI（中欧）", "哈希 hashing"], "title": "[CEOI 2017] Palindromic Partitions", "background": "", "description": "给出一个只包含小写字母字符串，要求你将它划分成尽可能多的小块，使得这些小块构成回文串。\n\n例如：对于字符串 ``abcab``，将他分成 ``ab`` ``c`` ``ab`` 或者 ``abcab`` 就是构成回文串的划分方法，``abc`` ``ab`` 则不是。", "inputFormat": "第一行输入一个整数 $T$ 表示数据组数。\n\n接下来的 $T$ 行，每行输入一个字符串，代表你需要处理的字符串，保证该字符串只包含小写字母。", "outputFormat": "输出 $T$ 行，对于每个输入的字符串，输出一行包含一个整数 $x$，表示该字符串最多能分解成 $x$ 个小块，使得这些小块构成回文串。", "hint": "对于 $100\\%$ 的数据，有 $1\\le T\\le 10$。设 $L$ 为单个字符串的长度，则 $1\\le L\\le 10^6$​​。", "locale": "zh-CN", "translations": {"en": {"title": "[CEOI 2017] Palindromic Partitions", "background": "", "description": "You are given a string containing only lowercase letters. You need to partition it into as many blocks as possible, such that these blocks form a palindrome string.\n\nFor example, for the string `abcab`, partitioning it into `ab` `c` `ab` or just `abcab` is a valid way to make the blocks form a palindrome, while `abc` `ab` is not.", "inputFormat": "The first line contains an integer $T$, indicating the number of test cases.\n\nThe next $T$ lines each contain a string, representing the string you need to process. It is guaranteed that the string contains only lowercase letters.", "outputFormat": "Output $T$ lines. For each input string, output one line containing an integer $x$, indicating the maximum number of blocks the string can be partitioned into, such that these blocks form a palindrome.", "hint": "For $100\\%$ of the testdata, $1 \\le T \\le 10$. Let $L$ be the length of a single string, then $1 \\le L \\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CEOI 2017] Palindromic Partitions", "background": "", "description": "给出一个只包含小写字母字符串，要求你将它划分成尽可能多的小块，使得这些小块构成回文串。\n\n例如：对于字符串 ``abcab``，将他分成 ``ab`` ``c`` ``ab`` 或者 ``abcab`` 就是构成回文串的划分方法，``abc`` ``ab`` 则不是。", "inputFormat": "第一行输入一个整数 $T$ 表示数据组数。\n\n接下来的 $T$ 行，每行输入一个字符串，代表你需要处理的字符串，保证该字符串只包含小写字母。", "outputFormat": "输出 $T$ 行，对于每个输入的字符串，输出一行包含一个整数 $x$，表示该字符串最多能分解成 $x$ 个小块，使得这些小块构成回文串。", "hint": "对于 $100\\%$ 的数据，有 $1\\le T\\le 10$。设 $L$ 为单个字符串的长度，则 $1\\le L\\le 10^6$​​。", "locale": "zh-CN"}}}
{"pid": "P4657", "type": "P", "difficulty": 6, "samples": [["12 2\n2 3 3 8 1 5 6 7 8 3 5 4\n2 1\n2 7\n3 4\n4 7\n7 6\n5 6\n6 8\n6 9\n7 10\n10 11\n10 12", "36"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2017", "CEOI（中欧）"], "title": "[CEOI 2017] Chase", "background": "", "description": "在逃亡者的面前有一个迷宫，这个迷宫由 $n$ 个房间和 $n-1$ 条双向走廊构成，每条走廊会链接不同的两个房间，所有的房间都可以通过走廊互相到达。换句话说，这是一棵树。\n\n逃亡者会选择一个房间进入迷宫，走过若干条走廊并走出迷宫，但他永远不会走重复的走廊。\n\n在第 $i$ 个房间里，有 $F_i$​​ 个铁球，每当一个人经过这个房间时，他就会受到铁球的阻挡。逃亡者手里有 $V$ 个磁铁，当他到达一个房间时，他可以选择丢下一个磁铁（也可以不丢），将与这个房间相邻的所有房间里的铁球吸引到这个房间。这个过程如下：\n\n1.    逃亡者进入房间。\n2.    逃亡者丢下磁铁。\n3.    逃亡者走出房间。\n4.    铁球被吸引到这个房间。\n\n注意逃亡者只会受到这个房间原有的铁球的阻拦，而不会受到被吸引的铁球的阻挡。\n\n在逃亡者走出迷宫后，追逐者将会沿着逃亡者走过的路径穿过迷宫，他会碰到这条路径上所有的铁球。\n\n请帮助逃亡者选择一条路径，使得追逐者遇到的铁球数量减去逃亡者遇到的铁球数量最大化。\n", "inputFormat": "第一行两个空格隔开的整数整数 $n$ 和 $V$。\n第二行 $n$ 个空格隔开的整数表示 $F_i$​​。\n之后的 $n-1$ 行，每行两个空格隔开的整数 $x$ 和 $y$，表示有一条走廊连接编号为 $x$ 和编号为 $y$ 的房间。", "outputFormat": "输出一个整数表示最优情况下追逐者遇到的铁球数量减去逃亡者遇到的铁球数量。", "hint": "**样例解释**\n\n有一个最优方案如下：\n\n-    从 $6$ 号房间进入迷宫并丢下第一个磁铁，他遇到了 $5$ 个铁球，这个时候 $6$ 号房间会有 $27$ 个铁球，而 $5$ 号，$7$ 号，$8$ 号，$9$ 号房间都没有铁球。\n-    走到 $7$ 号房间丢下第二个磁铁并走出迷宫，他遇到了 $0$ 个铁球，这个时候 $7$ 号房间会有 $41$ 个铁球，而 $2$ 号，$4$ 号，$6$ 号，$10$ 号房间会没有铁球。\n\n在这个过程中，逃亡者会遇到 $5$ 个铁球而追逐者会遇到 $41$ 个铁球。\n\n**数据范围**\n\n对于 $100\\%$ 的数据，有 $1\\le n\\le 10^5;0\\le V\\le 100;0\\le F_i\\le 10^9$​​。", "locale": "zh-CN", "translations": {"en": {"title": "[CEOI 2017] Chase", "background": "", "description": "In front of the fugitive there is a maze. The maze consists of $n$ rooms and $n-1$ bidirectional corridors. Each corridor connects two different rooms, and all rooms are reachable from each other through the corridors. In other words, it is a tree.\n\nThe fugitive will choose a room to enter the maze, walk through some corridors, and then leave the maze, but he will never walk through the same corridor twice.\n\nIn room $i$, there are $F_i$ iron balls. Whenever someone passes through this room, they will be blocked by the iron balls. The fugitive has $V$ magnets. When he arrives at a room, he may choose to drop one magnet (or not). This will pull all iron balls from every room adjacent to this room into this room. The process is as follows:\n\n1. The fugitive enters the room.\n2. The fugitive drops a magnet.\n3. The fugitive leaves the room.\n4. The iron balls are pulled into this room.\n\nNote that the fugitive is only blocked by the iron balls originally in this room, and will not be blocked by the iron balls pulled into this room.\n\nAfter the fugitive leaves the maze, the pursuer will go through the maze along the path taken by the fugitive, and he will encounter all iron balls on this path.\n\nPlease help the fugitive choose a path to maximize: (number of iron balls encountered by the pursuer) minus (number of iron balls encountered by the fugitive).", "inputFormat": "The first line contains two space-separated integers $n$ and $V$.\n\nThe second line contains $n$ space-separated integers representing $F_i$.\n\nThen follow $n-1$ lines. Each line contains two space-separated integers $x$ and $y$, indicating that there is a corridor connecting room $x$ and room $y$.", "outputFormat": "Output one integer, representing the maximum possible value of (number of iron balls encountered by the pursuer) minus (number of iron balls encountered by the fugitive) in the optimal case.", "hint": "**Sample Explanation**\n\nOne optimal plan is as follows:\n\n- Enter the maze from room $6$ and drop the first magnet. He encounters $5$ iron balls. At this time, room $6$ will have $27$ iron balls, while rooms $5$, $7$, $8$, and $9$ will have no iron balls.\n- Walk to room $7$, drop the second magnet, and leave the maze. He encounters $0$ iron balls. At this time, room $7$ will have $41$ iron balls, while rooms $2$, $4$, $6$, and $10$ will have no iron balls.\n\nIn this process, the fugitive encounters $5$ iron balls, while the pursuer encounters $41$ iron balls.\n\n**Constraints**\n\nFor $100\\%$ of the testdata, $1\\le n\\le 10^5;0\\le V\\le 100;0\\le F_i\\le 10^9$​​。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CEOI 2017] Chase", "background": "", "description": "在逃亡者的面前有一个迷宫，这个迷宫由 $n$ 个房间和 $n-1$ 条双向走廊构成，每条走廊会链接不同的两个房间，所有的房间都可以通过走廊互相到达。换句话说，这是一棵树。\n\n逃亡者会选择一个房间进入迷宫，走过若干条走廊并走出迷宫，但他永远不会走重复的走廊。\n\n在第 $i$ 个房间里，有 $F_i$​​ 个铁球，每当一个人经过这个房间时，他就会受到铁球的阻挡。逃亡者手里有 $V$ 个磁铁，当他到达一个房间时，他可以选择丢下一个磁铁（也可以不丢），将与这个房间相邻的所有房间里的铁球吸引到这个房间。这个过程如下：\n\n1.    逃亡者进入房间。\n2.    逃亡者丢下磁铁。\n3.    逃亡者走出房间。\n4.    铁球被吸引到这个房间。\n\n注意逃亡者只会受到这个房间原有的铁球的阻拦，而不会受到被吸引的铁球的阻挡。\n\n在逃亡者走出迷宫后，追逐者将会沿着逃亡者走过的路径穿过迷宫，他会碰到这条路径上所有的铁球。\n\n请帮助逃亡者选择一条路径，使得追逐者遇到的铁球数量减去逃亡者遇到的铁球数量最大化。\n", "inputFormat": "第一行两个空格隔开的整数整数 $n$ 和 $V$。\n第二行 $n$ 个空格隔开的整数表示 $F_i$​​。\n之后的 $n-1$ 行，每行两个空格隔开的整数 $x$ 和 $y$，表示有一条走廊连接编号为 $x$ 和编号为 $y$ 的房间。", "outputFormat": "输出一个整数表示最优情况下追逐者遇到的铁球数量减去逃亡者遇到的铁球数量。", "hint": "**样例解释**\n\n有一个最优方案如下：\n\n-    从 $6$ 号房间进入迷宫并丢下第一个磁铁，他遇到了 $5$ 个铁球，这个时候 $6$ 号房间会有 $27$ 个铁球，而 $5$ 号，$7$ 号，$8$ 号，$9$ 号房间都没有铁球。\n-    走到 $7$ 号房间丢下第二个磁铁并走出迷宫，他遇到了 $0$ 个铁球，这个时候 $7$ 号房间会有 $41$ 个铁球，而 $2$ 号，$4$ 号，$6$ 号，$10$ 号房间会没有铁球。\n\n在这个过程中，逃亡者会遇到 $5$ 个铁球而追逐者会遇到 $41$ 个铁球。\n\n**数据范围**\n\n对于 $100\\%$ 的数据，有 $1\\le n\\le 10^5;0\\le V\\le 100;0\\le F_i\\le 10^9$​​。", "locale": "zh-CN"}}}
{"pid": "P4658", "type": "P", "difficulty": 5, "samples": [["2\n4\nA...\n.#..\n....\n...B\n4\nA...\n....\n..#.\n...B", "B\nA"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000]}, "tags": ["2008", "BalticOI（波罗的海）"], "title": "[BalticOI 2008] 游戏 (Day1)", "background": null, "description": "玩家 $\\text{A}$ 和玩家 $\\text{B}$，在一个 $n\\times n$ 的正方形方格板上玩游戏。方格板上的方格要么是白的，要么是黑的。游戏只在白色区域上进行，黑色区域是禁区。初始时，每位玩家的起点上，会放置一个棋子。保证两人起点不同。\n\n玩家交替移动，玩家 $\\text{A}$ 先移动。每次移动，玩家会将他的棋子移动到相邻的白色方格中。如果玩家将棋子移动到对方现在的位置，玩家可以再移动一步，以越过对手。注意在这种情况下，第二步移动的方向可以与第一步移动的不同。\n\n这个游戏的目标是玩家的棋子首先到达对方的起点，先到者为胜。即使玩家的最后一步包含两次移动，并且他只是越过了对手的起点（如果对手现在在起点），这个玩家也获得胜利。\n\n给出方格板的布局和两个玩家的起点，判定哪个玩家有必胜策略（如果对手不管怎样移动，一个玩家能获得胜利，就称一个玩家有必胜策略）。", "inputFormat": "标准输入的第一行包含一个正整数 $t$（$1\\le t\\le 10$），表示测试数据的组数。在此之后为 $t$ 组测试数据。每一组测试数据格式如下：\n\n这组数据的第一行是一个正整数 $n$（$2\\le n\\le 300$），表示方格的边长，之后的每一行包含 $n$ 个字符（字符之间无空格）。每个字符是 ``.``（一个白色方格），``#``（一个黑色方格），``A``（$\\text{A}$ 的起点）和 ``B``（$\\text{B}$ 的起点）的其中之一。\n\n保证在两人的起点间存在一条白色方格的通路。", "outputFormat": "对于每组数据，输出一行到标准输出，包含一个字符 ``A`` 或 ``B``，表示有着必胜策略的玩家。", "hint": "#### 样例解释\n\n对于第一组数据： \n\n![0](https://i.loli.net/2018/02/19/5a8ab4a17e247.gif)\n\n如果 $\\text{A}$ 在前三次移动中移动到方格最右边，$\\text{B}$ 将在前三次移动中向上移动。因此，在第三次移动中玩家 $\\text{B}$ 将会到达 $\\text{A}$ 的方块所在方格，并且给 $\\text{B}$ 一次额外的移动机会。因此，$\\text{B}$ 会首先到达 $\\text{A}$ 的起点并且赢得游戏。\n\n对于第二组数据： \n\n![1](https://i.loli.net/2018/02/19/5a8ab4a17e132.gif)\n\n$\\text{A}$ 可以先向右移动一次，再向下移动一次。然后，$\\text{A}$ 可以由 $\\text{B}$ 的前两次移动决定他向下或向右移动来回避 $\\text{B}$。这样的话 $\\text{A}$ 会首先到达 $\\text{B}$ 的起点，因此赢得比赛。事实上我们已经证明了 $\\text{A}$ 有必胜策略。\n\n#### 数据范围\n\n对于 $40\\%$ 的数据，$n\\le 40$。\n\n对于 $60\\%$ 的数据，$n\\le 150$。\n\n对于所有数据，$2\\le n\\le 300$。", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2008] Game (Day 1)", "background": "", "description": "Player $\\text{A}$ and player $\\text{B}$ play a game on an $n \\times n$ square grid. Each cell on the board is either white or black. The game is played only on the white cells; black cells are forbidden. Initially, each player has one piece placed at their own starting cell. It is guaranteed that the two starting cells are different.\n\nThe players move alternately, with player $\\text{A}$ moving first. In each move, a player moves their piece to an adjacent white cell. If a player moves their piece onto the cell currently occupied by the opponent, the player may move one more step to jump over the opponent. Note that in this case, the direction of the second step may be different from the first step.\n\nThe goal of the game is to be the first player whose piece reaches the opponent’s starting cell. Even if the player’s last move consists of two steps and they only jump over the opponent’s starting cell (if the opponent is currently on that starting cell), the player still wins.\n\nGiven the board layout and the two players’ starting positions, determine which player has a winning strategy (a player has a winning strategy if they can win no matter how the opponent moves).", "inputFormat": "The first line of standard input contains a positive integer $t$ ($1 \\le t \\le 10$), the number of test cases. Then follow $t$ test cases. Each test case is given as follows:\n\nThe first line of a test case contains a positive integer $n$ ($2 \\le n \\le 300$), the side length of the grid. Each of the next $n$ lines contains $n$ characters (with no spaces). Each character is one of ``.`` (a white cell), ``#`` (a black cell), ``A`` (the starting cell of $\\text{A}$), and ``B`` (the starting cell of $\\text{B}$).\n\nIt is guaranteed that there exists a path of white cells between the two starting cells.", "outputFormat": "For each test case, output one line to standard output containing one character, ``A`` or ``B``, indicating the player who has a winning strategy.", "hint": "#### Sample Explanation\n\nFor the first test case:\n\n![0](https://i.loli.net/2018/02/19/5a8ab4a17e247.gif)\n\nIf $\\text{A}$ moves to the right edge of the grid within the first three moves, then $\\text{B}$ will move upward within the first three moves. Therefore, on the third move, player $\\text{B}$ will reach the cell where $\\text{A}$ is and gain an extra move. Thus, $\\text{B}$ will reach $\\text{A}$’s starting cell first and win the game.\n\nFor the second test case:\n\n![1](https://i.loli.net/2018/02/19/5a8ab4a17e132.gif)\n\n$\\text{A}$ can first move one step to the right and then one step down. After that, $\\text{A}$ can decide whether to move down or right based on $\\text{B}$’s first two moves, so as to avoid $\\text{B}$. In this way, $\\text{A}$ will reach $\\text{B}$’s starting cell first and win the game. In fact, we have already proven that $\\text{A}$ has a winning strategy.\n\n#### Constraints\n\nFor $40\\%$ of the testdata, $n \\le 40$.\n\nFor $60\\%$ of the testdata, $n \\le 150$.\n\nFor all testdata, $2 \\le n \\le 300$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2008] 游戏 (Day1)", "background": null, "description": "玩家 $\\text{A}$ 和玩家 $\\text{B}$，在一个 $n\\times n$ 的正方形方格板上玩游戏。方格板上的方格要么是白的，要么是黑的。游戏只在白色区域上进行，黑色区域是禁区。初始时，每位玩家的起点上，会放置一个棋子。保证两人起点不同。\n\n玩家交替移动，玩家 $\\text{A}$ 先移动。每次移动，玩家会将他的棋子移动到相邻的白色方格中。如果玩家将棋子移动到对方现在的位置，玩家可以再移动一步，以越过对手。注意在这种情况下，第二步移动的方向可以与第一步移动的不同。\n\n这个游戏的目标是玩家的棋子首先到达对方的起点，先到者为胜。即使玩家的最后一步包含两次移动，并且他只是越过了对手的起点（如果对手现在在起点），这个玩家也获得胜利。\n\n给出方格板的布局和两个玩家的起点，判定哪个玩家有必胜策略（如果对手不管怎样移动，一个玩家能获得胜利，就称一个玩家有必胜策略）。", "inputFormat": "标准输入的第一行包含一个正整数 $t$（$1\\le t\\le 10$），表示测试数据的组数。在此之后为 $t$ 组测试数据。每一组测试数据格式如下：\n\n这组数据的第一行是一个正整数 $n$（$2\\le n\\le 300$），表示方格的边长，之后的每一行包含 $n$ 个字符（字符之间无空格）。每个字符是 ``.``（一个白色方格），``#``（一个黑色方格），``A``（$\\text{A}$ 的起点）和 ``B``（$\\text{B}$ 的起点）的其中之一。\n\n保证在两人的起点间存在一条白色方格的通路。", "outputFormat": "对于每组数据，输出一行到标准输出，包含一个字符 ``A`` 或 ``B``，表示有着必胜策略的玩家。", "hint": "#### 样例解释\n\n对于第一组数据： \n\n![0](https://i.loli.net/2018/02/19/5a8ab4a17e247.gif)\n\n如果 $\\text{A}$ 在前三次移动中移动到方格最右边，$\\text{B}$ 将在前三次移动中向上移动。因此，在第三次移动中玩家 $\\text{B}$ 将会到达 $\\text{A}$ 的方块所在方格，并且给 $\\text{B}$ 一次额外的移动机会。因此，$\\text{B}$ 会首先到达 $\\text{A}$ 的起点并且赢得游戏。\n\n对于第二组数据： \n\n![1](https://i.loli.net/2018/02/19/5a8ab4a17e132.gif)\n\n$\\text{A}$ 可以先向右移动一次，再向下移动一次。然后，$\\text{A}$ 可以由 $\\text{B}$ 的前两次移动决定他向下或向右移动来回避 $\\text{B}$。这样的话 $\\text{A}$ 会首先到达 $\\text{B}$ 的起点，因此赢得比赛。事实上我们已经证明了 $\\text{A}$ 有必胜策略。\n\n#### 数据范围\n\n对于 $40\\%$ 的数据，$n\\le 40$。\n\n对于 $60\\%$ 的数据，$n\\le 150$。\n\n对于所有数据，$2\\le n\\le 300$。", "locale": "zh-CN"}}}
