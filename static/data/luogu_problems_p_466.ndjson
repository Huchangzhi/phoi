{"pid": "P10452", "type": "P", "difficulty": 2, "samples": [["4\n6 2 9 1", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "排序"], "title": "货仓选址", "background": null, "description": "在一条数轴上有 $N$ 家商店，它们的坐标分别为 $A_1 \\sim A_N$。\n\n现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。\n\n为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。", "inputFormat": "第一行输入整数 $N$。\n\n第二行 $N$ 个整数 $A_1 \\sim A_N$。", "outputFormat": "输出一个整数，表示距离之和的最小值。", "hint": "数据保证，$1 \\le N \\le 10^5$，$0 \\le A_i \\le 40000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "货仓选址", "background": null, "description": "在一条数轴上有 $N$ 家商店，它们的坐标分别为 $A_1 \\sim A_N$。\n\n现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。\n\n为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。", "inputFormat": "第一行输入整数 $N$。\n\n第二行 $N$ 个整数 $A_1 \\sim A_N$。", "outputFormat": "输出一个整数，表示距离之和的最小值。", "hint": "数据保证，$1 \\le N \\le 10^5$，$0 \\le A_i \\le 40000$。", "locale": "zh-CN"}}}
{"pid": "P10453", "type": "P", "difficulty": 5, "samples": [["2 3 4\n1 3\n2 1\n2 2\n2 3", "row 1"], ["3 3 3\n1 3\n2 2\n2 3", "both 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "前缀和"], "title": "七夕祭", "background": "", "description": "七夕节因牛郎织女的传说而被扣上了「情人节」的帽子。\n\n于是 TYVJ 今年举办了一次线下七夕祭。\n\nVani 同学今年成功邀请到了 cl 同学陪他来共度七夕，于是他们决定去 TYVJ 七夕祭游玩。\n\nTYVJ 七夕祭和 11 区的夏祭的形式很像。\n\n矩形的祭典会场由 $N$ 排 $M$ 列共计 $N \\times M$ 个摊点组成。\n\n虽然摊点种类繁多，不过 cl 只对其中的一部分摊点感兴趣，比如章鱼烧、苹果糖、棉花糖、射的屋……什么的。\n\nVani 预先联系了七夕祭的负责人 zhq，希望能够通过恰当地布置会场，使得各行中 cl 感兴趣的摊点数一样多，并且各列中 cl 感兴趣的摊点数也一样多。\n\n不过 zhq 告诉 Vani，摊点已经随意布置完毕了，如果想满足 cl 的要求，唯一的调整方式就是交换两个相邻的摊点。\n\n两个摊点相邻，当且仅当他们处在同一行或者同一列的相邻位置上。\n\n由于 zhq 率领的 TYVJ 开发小组成功地扭曲了空间，每一行或每一列的第一个位置和最后一个位置也算作相邻。\n\n现在 Vani 想知道他的两个要求最多能满足多少个。\n\n在此前提下，至少需要交换多少次摊点。", "inputFormat": "第一行包含三个整数 $N$ 和 $M$ 和 $T$，$T$ 表示 cl 对多少个摊点感兴趣。\n\n接下来 $T$ 行，每行两个整数 $x, y$，表示 cl 对处在第 $x$ 行第 $y$ 列的摊点感兴趣。\n", "outputFormat": "首先输出一个字符串。\n\n如果能满足 Vani 的全部两个要求，输出 `both`；\n\n如果通过调整只能使得各行中 cl 感兴趣的摊点数一样多，输出 `row`；\n\n如果只能使各列中 cl 感兴趣的摊点数一样多，输出 `column`；\n\n如果均不能满足，输出 `impossible`。\n\n如果输出的字符串不是 `impossible`， 接下来输出最小交换次数，与字符串之间用一个空格隔开。", "hint": "对于 $30\\%$ 的数据，$N,M \\le 100$。\n\n对于 $70\\%$ 的数据，$N,M \\le 1000$。\n\n对于 $100\\%$ 的数据，$1 \\le N,M \\le 100000$，$0 \\le T \\le \\min(N\\times M,100000)$，$1 \\le x \\le N$，$1 \\le y \\le M$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "七夕祭", "background": "", "description": "七夕节因牛郎织女的传说而被扣上了「情人节」的帽子。\n\n于是 TYVJ 今年举办了一次线下七夕祭。\n\nVani 同学今年成功邀请到了 cl 同学陪他来共度七夕，于是他们决定去 TYVJ 七夕祭游玩。\n\nTYVJ 七夕祭和 11 区的夏祭的形式很像。\n\n矩形的祭典会场由 $N$ 排 $M$ 列共计 $N \\times M$ 个摊点组成。\n\n虽然摊点种类繁多，不过 cl 只对其中的一部分摊点感兴趣，比如章鱼烧、苹果糖、棉花糖、射的屋……什么的。\n\nVani 预先联系了七夕祭的负责人 zhq，希望能够通过恰当地布置会场，使得各行中 cl 感兴趣的摊点数一样多，并且各列中 cl 感兴趣的摊点数也一样多。\n\n不过 zhq 告诉 Vani，摊点已经随意布置完毕了，如果想满足 cl 的要求，唯一的调整方式就是交换两个相邻的摊点。\n\n两个摊点相邻，当且仅当他们处在同一行或者同一列的相邻位置上。\n\n由于 zhq 率领的 TYVJ 开发小组成功地扭曲了空间，每一行或每一列的第一个位置和最后一个位置也算作相邻。\n\n现在 Vani 想知道他的两个要求最多能满足多少个。\n\n在此前提下，至少需要交换多少次摊点。", "inputFormat": "第一行包含三个整数 $N$ 和 $M$ 和 $T$，$T$ 表示 cl 对多少个摊点感兴趣。\n\n接下来 $T$ 行，每行两个整数 $x, y$，表示 cl 对处在第 $x$ 行第 $y$ 列的摊点感兴趣。\n", "outputFormat": "首先输出一个字符串。\n\n如果能满足 Vani 的全部两个要求，输出 `both`；\n\n如果通过调整只能使得各行中 cl 感兴趣的摊点数一样多，输出 `row`；\n\n如果只能使各列中 cl 感兴趣的摊点数一样多，输出 `column`；\n\n如果均不能满足，输出 `impossible`。\n\n如果输出的字符串不是 `impossible`， 接下来输出最小交换次数，与字符串之间用一个空格隔开。", "hint": "对于 $30\\%$ 的数据，$N,M \\le 100$。\n\n对于 $70\\%$ 的数据，$N,M \\le 1000$。\n\n对于 $100\\%$ 的数据，$1 \\le N,M \\le 100000$，$0 \\le T \\le \\min(N\\times M,100000)$，$1 \\le x \\le N$，$1 \\le y \\le M$。", "locale": "zh-CN"}}}
{"pid": "P10454", "type": "P", "difficulty": 5, "samples": [["3\n1 2 3\n0 4 6\n7 5 8\n1 2 3\n4 5 6\n7 8 0\n1\n0\n0", "TAK\nTAK"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["树状数组", "排序"], "title": "奇数码问题", "background": "", "description": "你一定玩过八数码游戏，它实际上是在一个 $3 \\times 3$ 的网格中进行的，$1$ 个空格和 $1 \\sim 8$ 这 $8$ 个数字恰好不重不漏地分布在这 $3 \\times 3$ 的网格中。\n\n例如：\n\n    5 2 8\n    1 3 _\n    4 6 7\n    \n\n在游戏过程中，可以把空格与其上、下、左、右四个方向之一的数字交换（如果存在）。\n\n例如在上例中，空格可与左、上、下面的数字交换，分别变成：\n\n    5 2 8       5 2 _      5 2 8\n    1 _ 3       1 3 8      1 3 7\n    4 6 7       4 6 7      4 6 _\n    \n\n奇数码游戏是它的一个扩展，在一个 $n \\times n$ 的网格中进行，其中 $n$ 为奇数，$1$ 个空格和 $1 \\sim n^2-1$ 这 $n^2-1$ 个数恰好不重不漏地分布在 $n \\times n$ 的网格中。\n\n空格移动的规则与八数码游戏相同，实际上，八数码就是一个 $n=3$ 的奇数码游戏。\n\n现在给定两个奇数码游戏的局面，请判断是否存在一种移动空格的方式，使得其中一个局面可以变化到另一个局面。", "inputFormat": "多组数据，对于每组数据：\n\n第 $1$ 行输入一个整数 $n$，$n$ 为奇数。\n\n接下来 $n$ 行每行 $n$ 个整数，表示第一个局面。\n\n再接下来 $n$ 行每行 $n$ 个整数，表示第二个局面。\n\n局面中每个整数都是 $0 \\sim n^2-1$ 之一，其中用 $0$ 代表空格，其余数值与奇数码游戏中的意义相同，保证这些整数的分布不重不漏。", "outputFormat": "对于每组数据，若两个局面可达，输出 `TAK`，否则输出 `NIE`。\n", "hint": "$1 \\le n < 500$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "奇数码问题", "background": "", "description": "你一定玩过八数码游戏，它实际上是在一个 $3 \\times 3$ 的网格中进行的，$1$ 个空格和 $1 \\sim 8$ 这 $8$ 个数字恰好不重不漏地分布在这 $3 \\times 3$ 的网格中。\n\n例如：\n\n    5 2 8\n    1 3 _\n    4 6 7\n    \n\n在游戏过程中，可以把空格与其上、下、左、右四个方向之一的数字交换（如果存在）。\n\n例如在上例中，空格可与左、上、下面的数字交换，分别变成：\n\n    5 2 8       5 2 _      5 2 8\n    1 _ 3       1 3 8      1 3 7\n    4 6 7       4 6 7      4 6 _\n    \n\n奇数码游戏是它的一个扩展，在一个 $n \\times n$ 的网格中进行，其中 $n$ 为奇数，$1$ 个空格和 $1 \\sim n^2-1$ 这 $n^2-1$ 个数恰好不重不漏地分布在 $n \\times n$ 的网格中。\n\n空格移动的规则与八数码游戏相同，实际上，八数码就是一个 $n=3$ 的奇数码游戏。\n\n现在给定两个奇数码游戏的局面，请判断是否存在一种移动空格的方式，使得其中一个局面可以变化到另一个局面。", "inputFormat": "多组数据，对于每组数据：\n\n第 $1$ 行输入一个整数 $n$，$n$ 为奇数。\n\n接下来 $n$ 行每行 $n$ 个整数，表示第一个局面。\n\n再接下来 $n$ 行每行 $n$ 个整数，表示第二个局面。\n\n局面中每个整数都是 $0 \\sim n^2-1$ 之一，其中用 $0$ 代表空格，其余数值与奇数码游戏中的意义相同，保证这些整数的分布不重不漏。", "outputFormat": "对于每组数据，若两个局面可达，输出 `TAK`，否则输出 `NIE`。\n", "hint": "$1 \\le n < 500$", "locale": "zh-CN"}}}
{"pid": "P10455", "type": "P", "difficulty": 5, "samples": [["2\n5 1 49\n8 2 1 7 9\n5 1 64\n8 2 1 7 9", "2\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "倍增"], "title": "Genius Acm", "background": "", "description": "Advanced CPU Manufacturer (ACM) is one of the best CPU manufacturers in the world. 每天，该公司生产 $n$ 台 CPU 并销售到世界各地。\n\nACM 公司的质检部门会对生产出的 CPU 进行成组测试，对一组（若干个）CPU 进行测试的方法如下：\n\n1. 随机从该组 CPU 中选取 $m$ 对（即 $2m$ 台），若总数不足 $2m$ 台，则选取尽量多对。\n\n2. 对于每一对 CPU，测量它们之间的 Relative Performance Difference (RPD)，并把第 $i$ 对的 RPD 记为 $D_i$。RPD 的计算方法在后面给出。\n\n3. 该组 CPU 的 Sqared Performance Difference (SPD） 由以下公式给出：\n\n$SPD=\\sum _i D^2_i$\n\n\n4. 该组 CPU 通过质检，当且仅当 $SPD \\le k,$ 其中 $k$ 是给定常数。\n\nACM 公司生产的 CPU 性能很好，而质检部门制定的标准更是过于严格。通常他们把 $n$ 台 CPU 作为一整组进行测试，这导致一些性能良好的 CPU 无法通过测试，生产部门对此颇有微词。作为质检部门的领导，小 S 在不更改质检测试流程的前提下，想出了这样一个主意：如果能够把 $n$ 台 CPU 恰当地分成连续的若干段，使得每段 CPU 都能够通过成组测试，就可以解决当下的问题。\n\n现在，小 S 已经知道了 $n$ 台各自的性能表现 $P_1,\\cdots ,P_n$，两台 CPU 的 RPD 被定义为它们性能表现的差的绝对值。请你帮忙计算一下，至少把这些 CPU 分成多少段，才能使得每一段都能通过成组测试。", "inputFormat": "每个测试点包含多组数据，第一行整数 $T$ 给出数据组数。\n\n对于每组数据，第一行三个整数 $n,m,k$，第二行 $n$ 个整数 $P_1,\\cdots ,P_n$。", "outputFormat": "对于每组数据，输出一个整表示答案。", "hint": "对于 $20 \\%$ 的数据，$1 \\leq n \\leq 10^2$ 。  \n对于 $40 \\%$ 的数据， $1 \\leq n \\leq 10^3$ 。  \n对于另外 $10 \\%$ 的数据，$k=0$ 。  \n对于另外 $10 \\%$ 的数据，$0 \\leq k \\leq 1$ 。  \n对于另外 $10 \\%$ 的数据， $m=1$ 。  \n对于另外 $10 \\%$ 的数据，$1 \\leq m \\leq 2$ 。  \n对于 $90 \\%$ 的数据，$0 \\leq k \\leq 10^{12}$ 。  \n对于 $100 \\%$ 的数据，$T \\leq 12,1 \\leq n, m \\leq 5 \\cdot 10^5, 0 \\leq k \\leq 10^{18}, 0 \\leq P_i \\leq 2^{20}$ 。  ", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Genius Acm", "background": "", "description": "Advanced CPU Manufacturer (ACM) is one of the best CPU manufacturers in the world. 每天，该公司生产 $n$ 台 CPU 并销售到世界各地。\n\nACM 公司的质检部门会对生产出的 CPU 进行成组测试，对一组（若干个）CPU 进行测试的方法如下：\n\n1. 随机从该组 CPU 中选取 $m$ 对（即 $2m$ 台），若总数不足 $2m$ 台，则选取尽量多对。\n\n2. 对于每一对 CPU，测量它们之间的 Relative Performance Difference (RPD)，并把第 $i$ 对的 RPD 记为 $D_i$。RPD 的计算方法在后面给出。\n\n3. 该组 CPU 的 Sqared Performance Difference (SPD） 由以下公式给出：\n\n$SPD=\\sum _i D^2_i$\n\n\n4. 该组 CPU 通过质检，当且仅当 $SPD \\le k,$ 其中 $k$ 是给定常数。\n\nACM 公司生产的 CPU 性能很好，而质检部门制定的标准更是过于严格。通常他们把 $n$ 台 CPU 作为一整组进行测试，这导致一些性能良好的 CPU 无法通过测试，生产部门对此颇有微词。作为质检部门的领导，小 S 在不更改质检测试流程的前提下，想出了这样一个主意：如果能够把 $n$ 台 CPU 恰当地分成连续的若干段，使得每段 CPU 都能够通过成组测试，就可以解决当下的问题。\n\n现在，小 S 已经知道了 $n$ 台各自的性能表现 $P_1,\\cdots ,P_n$，两台 CPU 的 RPD 被定义为它们性能表现的差的绝对值。请你帮忙计算一下，至少把这些 CPU 分成多少段，才能使得每一段都能通过成组测试。", "inputFormat": "每个测试点包含多组数据，第一行整数 $T$ 给出数据组数。\n\n对于每组数据，第一行三个整数 $n,m,k$，第二行 $n$ 个整数 $P_1,\\cdots ,P_n$。", "outputFormat": "对于每组数据，输出一个整表示答案。", "hint": "对于 $20 \\%$ 的数据，$1 \\leq n \\leq 10^2$ 。  \n对于 $40 \\%$ 的数据， $1 \\leq n \\leq 10^3$ 。  \n对于另外 $10 \\%$ 的数据，$k=0$ 。  \n对于另外 $10 \\%$ 的数据，$0 \\leq k \\leq 1$ 。  \n对于另外 $10 \\%$ 的数据， $m=1$ 。  \n对于另外 $10 \\%$ 的数据，$1 \\leq m \\leq 2$ 。  \n对于 $90 \\%$ 的数据，$0 \\leq k \\leq 10^{12}$ 。  \n对于 $100 \\%$ 的数据，$T \\leq 12,1 \\leq n, m \\leq 5 \\cdot 10^5, 0 \\leq k \\leq 10^{18}, 0 \\leq P_i \\leq 2^{20}$ 。  ", "locale": "zh-CN"}}}
{"pid": "P10456", "type": "P", "difficulty": 4, "samples": [["-+--\n----\n----\n-+--", "6 \n1 1 \n1 3 \n1 4 \n4 1 \n4 3 \n4 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2004", "Special Judge", "ICPC"], "title": "The Pilots Brothers' refrigerator", "background": "", "description": "The game “The Pilots Brothers: following the stripy elephant” has a quest where a player needs to open a refrigerator.\n\nThere are $16$ handles on the refrigerator door. Every handle can be in one of two states: open or closed. The refrigerator is open only when all handles are open. The handles are represented as a matrix $4\\times4$. You can change the state of a handle in any location $[i, j] (1 \\leq i, j \\leq 4)$. However, this also changes states of all handles in row $i$ and all handles in column $j$.\n\nThe task is to determine the minimum number of handle switching necessary to open the refrigerator.", "inputFormat": "The input contains four lines. Each of the four lines contains four characters describing the initial state of appropriate handles. A symbol “+” means that the handle is in closed state, whereas the symbol “−” means “open”. At least one of the handles is initially closed.", "outputFormat": "The first line of the input contains $N$ – the minimum number of switching. The rest $N$ lines describe switching sequence. Each of the lines contains a row number and a column number of the matrix separated by one or more spaces. If there are several solutions, you may give any one of them.", "hint": "", "locale": "en", "translations": {"en": {"title": "The Pilots Brothers' refrigerator", "background": "", "description": "The game “The Pilots Brothers: following the stripy elephant” has a quest where a player needs to open a refrigerator.\n\nThere are $16$ handles on the refrigerator door. Every handle can be in one of two states: open or closed. The refrigerator is open only when all handles are open. The handles are represented as a matrix $4\\times4$. You can change the state of a handle in any location $[i, j] (1 \\leq i, j \\leq 4)$. However, this also changes states of all handles in row $i$ and all handles in column $j$.\n\nThe task is to determine the minimum number of handle switching necessary to open the refrigerator.", "inputFormat": "The input contains four lines. Each of the four lines contains four characters describing the initial state of appropriate handles. A symbol “+” means that the handle is in closed state, whereas the symbol “−” means “open”. At least one of the handles is initially closed.", "outputFormat": "The first line of the input contains $N$ – the minimum number of switching. The rest $N$ lines describe switching sequence. Each of the lines contains a row number and a column number of the matrix separated by one or more spaces. If there are several solutions, you may give any one of them.", "hint": "", "locale": "en"}, "zh-CN": {"title": "The Pilots Brothers' refrigerator", "background": "", "description": "游戏《飞行员兄弟：追寻条纹大象》中有一个任务，玩家需要打开一个冰箱。\n\n冰箱门上有 $16$ 个手柄。每个手柄可以处于两种状态之一：打开或关闭。只有当所有手柄都打开时，冰箱才会打开。手柄被表示为一个 $4\\times4$ 的矩阵。你可以改变任何位置 $[i, j] (1 \\leq i, j \\leq 4)$ 处手柄的状态。但是，这也会改变第 $i$ 行和第 $j$ 列中所有手柄的状态。\n\n任务是确定打开冰箱所需的最小切换次数。", "inputFormat": "输入包含四行。每一行都包含四个字符，描述相应手柄的初始状态。符号 “+” 表示手柄处于关闭状态，而符号 “−” 表示 “打开”状态。至少有一个手柄最初是关闭的。", "outputFormat": "输入的第一行包含 $N$ - 最小切换次数。接下来的 $N$ 行描述切换序列。每行包含一个矩阵的行号和列号，用一个或多个空格分隔开。如果存在多个解决方案，则可以提供任何一个解决方案。\n\n翻译来自于：ChatGPT。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10457", "type": "P", "difficulty": 2, "samples": [["8 5 A A\nK 5 3 2\n9 6 0 6\n3 4 3 4\n3 4 4 5\n5 6 7 6\n8 7 7 7\n9 9 8 8\n9 0 0 0\nK J J J\nQ A Q K\nJ Q 2 2\nA K Q 2", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "队列"], "title": "占卜DIY", "background": null, "description": "lyd 学会了使用扑克 DIY 占卜。方法如下：一副去掉大小王的扑克共 $52$ 张，打乱后均分为 $13$ 堆，编号 $1\\sim 13$，每堆 $4$ 张，其中第 $13$ 堆称作“生命牌”，也就是说你有 $4$ 条命。这里边，$4$ 张 $K$ 被称作死神。\n\n初始状态下，所有的牌背面朝上扣下。\n\n流程如下：\n\n- 抽取生命牌中的最上面一张（第一张）。\n- 把这张牌翻开，正面朝上，放到牌上的数字所对应编号的堆的最上边。（例如抽到 $2$，正面朝上放到第 $2$ 堆牌最上面，又比如抽到 $J$，放到第 $11$ 堆牌最上边，注意是正面朝上放）\n- 从刚放了牌的那一堆最底下（最后一张）抽取一张牌，重复第 $2$ 步。（例如你上次抽了 $2$，放到了第二堆顶部，现在抽第二堆最后一张发现是 $8$，又放到第 $8$ 堆顶部……）\n- 在抽牌过程中如果抽到 $K$，则称死了一条命，就扔掉 $K$ 再从第 $1$ 步开始。\n- 当发现四条命都死了以后，统计现在每堆牌上边正面朝上的牌的数目，只要同一数字的牌出现 $4$ 张正面朝上的牌（比如 $4$ 个 $A$），则称“开了一对”，当然 $4$ 个 $K$ 是不算的。\n- 统计一共开了多少对，开了 $0$ 对称作“极凶”，$1\\sim 2$ 对为“大凶”，$3$ 对为“凶”，$4\\sim 5$ 对为“小凶”，$6$ 对为“中庸”，$7\\sim 8$ 对“小吉”，$9$ 对为“吉”，$10\\sim11$ 对为“大吉”，$12$ 对为“满堂开花，极吉”。\n\n如果还不明白，请参考样例。", "inputFormat": "一共 $13$ 行，为每堆牌的具体牌是什么（不区分花色只区分数字），每堆输入的顺序为从上到下。\n\n为了便于读入，用 $0$ 代表 $10$。", "outputFormat": "输出一共开了多少对。", "hint": "注解：第一条命死后前 $12$ 堆牌变成了这个样子：\n```\nA A A 8\nK 5 3 2\n3 9 6 0\n4 4 3 4\n5 5 3 4\n6 6 5 6\n7 7 7 7 \n8 8 8 9\n9 9 0 0\n0 K J J\nJ Q A Q//抽到这里的K死掉了\nJ Q 2 2\n```\n第二条命由于 $K$ 在生命牌中，所以直接死掉，不变。\n\n第三条命死后前 $12$ 堆牌变成了这个样子：\n```\nA A A A\n2 2 2 K\n3 3 3 3\n4 4 4 4\n5 5 5 5\n6 6 6 6\n7 7 7 7 \n8 8 8 8\n9 9 9 9\n0 0 0 0//抽到这里的K死掉了\nJ J J Q\nQ Q J Q\n```\n第四条命死后前 $12$ 堆牌变成了这个样子：\n```\nA A A A\n2 2 2 2//抽到这里的K死掉了\n3 3 3 3\n4 4 4 4\n5 5 5 5\n6 6 6 6\n7 7 7 7 \n8 8 8 8\n9 9 9 9\n0 0 0 0\nJ J J Q\nQ Q J Q\n```\n最后发现在所有已经正面朝上的牌中，$A\\ 2\\ 3\\ 4\\ 5\\ 6\\ 7\\ 8\\ 10$ 这 $9$ 对牌“开”了，（注意，第 $9$ 堆牌中的最后一张虽然也是 $9$，但是并没有被翻开！所以不能算）因此输出 $9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "占卜DIY", "background": null, "description": "lyd 学会了使用扑克 DIY 占卜。方法如下：一副去掉大小王的扑克共 $52$ 张，打乱后均分为 $13$ 堆，编号 $1\\sim 13$，每堆 $4$ 张，其中第 $13$ 堆称作“生命牌”，也就是说你有 $4$ 条命。这里边，$4$ 张 $K$ 被称作死神。\n\n初始状态下，所有的牌背面朝上扣下。\n\n流程如下：\n\n- 抽取生命牌中的最上面一张（第一张）。\n- 把这张牌翻开，正面朝上，放到牌上的数字所对应编号的堆的最上边。（例如抽到 $2$，正面朝上放到第 $2$ 堆牌最上面，又比如抽到 $J$，放到第 $11$ 堆牌最上边，注意是正面朝上放）\n- 从刚放了牌的那一堆最底下（最后一张）抽取一张牌，重复第 $2$ 步。（例如你上次抽了 $2$，放到了第二堆顶部，现在抽第二堆最后一张发现是 $8$，又放到第 $8$ 堆顶部……）\n- 在抽牌过程中如果抽到 $K$，则称死了一条命，就扔掉 $K$ 再从第 $1$ 步开始。\n- 当发现四条命都死了以后，统计现在每堆牌上边正面朝上的牌的数目，只要同一数字的牌出现 $4$ 张正面朝上的牌（比如 $4$ 个 $A$），则称“开了一对”，当然 $4$ 个 $K$ 是不算的。\n- 统计一共开了多少对，开了 $0$ 对称作“极凶”，$1\\sim 2$ 对为“大凶”，$3$ 对为“凶”，$4\\sim 5$ 对为“小凶”，$6$ 对为“中庸”，$7\\sim 8$ 对“小吉”，$9$ 对为“吉”，$10\\sim11$ 对为“大吉”，$12$ 对为“满堂开花，极吉”。\n\n如果还不明白，请参考样例。", "inputFormat": "一共 $13$ 行，为每堆牌的具体牌是什么（不区分花色只区分数字），每堆输入的顺序为从上到下。\n\n为了便于读入，用 $0$ 代表 $10$。", "outputFormat": "输出一共开了多少对。", "hint": "注解：第一条命死后前 $12$ 堆牌变成了这个样子：\n```\nA A A 8\nK 5 3 2\n3 9 6 0\n4 4 3 4\n5 5 3 4\n6 6 5 6\n7 7 7 7 \n8 8 8 9\n9 9 0 0\n0 K J J\nJ Q A Q//抽到这里的K死掉了\nJ Q 2 2\n```\n第二条命由于 $K$ 在生命牌中，所以直接死掉，不变。\n\n第三条命死后前 $12$ 堆牌变成了这个样子：\n```\nA A A A\n2 2 2 K\n3 3 3 3\n4 4 4 4\n5 5 5 5\n6 6 6 6\n7 7 7 7 \n8 8 8 8\n9 9 9 9\n0 0 0 0//抽到这里的K死掉了\nJ J J Q\nQ Q J Q\n```\n第四条命死后前 $12$ 堆牌变成了这个样子：\n```\nA A A A\n2 2 2 2//抽到这里的K死掉了\n3 3 3 3\n4 4 4 4\n5 5 5 5\n6 6 6 6\n7 7 7 7 \n8 8 8 8\n9 9 9 9\n0 0 0 0\nJ J J Q\nQ Q J Q\n```\n最后发现在所有已经正面朝上的牌中，$A\\ 2\\ 3\\ 4\\ 5\\ 6\\ 7\\ 8\\ 10$ 这 $9$ 对牌“开”了，（注意，第 $9$ 堆牌中的最后一张虽然也是 $9$，但是并没有被翻开！所以不能算）因此输出 $9$。", "locale": "zh-CN"}}}
{"pid": "P10458", "type": "P", "difficulty": 2, "samples": [["1\n2\n3 \n4 \n-1", "X\n-\nX X\n X \nX X\n-\nX X   X X\n X     X \nX X   X X\n   X X   \n    X    \n   X X   \nX X   X X\n X     X \nX X   X X\n-\nX X   X X         X X   X X\n X     X           X     X \nX X   X X         X X   X X\n   X X               X X   \n    X                 X    \n   X X               X X   \nX X   X X         X X   X X\n X     X           X     X \nX X   X X         X X   X X\n         X X   X X         \n          X     X          \n         X X   X X         \n            X X            \n             X             \n            X X            \n         X X   X X         \n          X     X          \n         X X   X X         \nX X   X X         X X   X X\n X     X           X     X \nX X   X X         X X   X X\n   X X               X X   \n    X                 X    \n   X X               X X   \nX X   X X         X X   X X\n X     X           X     X \nX X   X X         X X   X X\n-\n"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["递归"], "title": "Fractal", "background": "", "description": "A fractal is an object or quantity that displays self-similarity, in a somewhat technical sense, on all scales. The object need not exhibit exactly the same structure at all scales, but the same \"type\" of structures must appear on all scales.\n\nA box fractal is defined as below :\n\n-  A box fractal of degree $1$ is simply X\n-  A box fractal of degree $2$ is\n```\nX X\n X\nX X\n```\n- If using $B(n - 1)$ to represent the box fractal of degree $n - 1$, then a box fractal of degree $n$ is defined recursively as following\n```\nB(n - 1) B(n - 1)\n     B(n - 1)\nB(n - 1) B(n - 1)\n```\nYour task is to draw a box fractal of degree $n$.", "inputFormat": "The input consists of several test cases. Each line of the input contains a positive integer $n$ which is no greater than $7$. The last line of input is a negative integer $-1$ indicating the end of input.", "outputFormat": "For each test case, output the box fractal using the 'X' notation. Please notice that 'X' is an uppercase letter. Print a line with only a single dash after each test case.", "hint": "", "locale": "en", "translations": {"en": {"title": "Fractal", "background": "", "description": "A fractal is an object or quantity that displays self-similarity, in a somewhat technical sense, on all scales. The object need not exhibit exactly the same structure at all scales, but the same \"type\" of structures must appear on all scales.\n\nA box fractal is defined as below :\n\n-  A box fractal of degree $1$ is simply X\n-  A box fractal of degree $2$ is\n```\nX X\n X\nX X\n```\n- If using $B(n - 1)$ to represent the box fractal of degree $n - 1$, then a box fractal of degree $n$ is defined recursively as following\n```\nB(n - 1) B(n - 1)\n     B(n - 1)\nB(n - 1) B(n - 1)\n```\nYour task is to draw a box fractal of degree $n$.", "inputFormat": "The input consists of several test cases. Each line of the input contains a positive integer $n$ which is no greater than $7$. The last line of input is a negative integer $-1$ indicating the end of input.", "outputFormat": "For each test case, output the box fractal using the 'X' notation. Please notice that 'X' is an uppercase letter. Print a line with only a single dash after each test case.", "hint": "", "locale": "en"}, "zh-CN": {"title": "Fractal", "background": "", "description": "分形是在各种尺度上以某种技术意义上显示自相似性的对象或数量。对象不需要在所有尺度上展现完全相同的结构，但在所有尺度上必须出现相同的“类型”结构。\n\n盒子分形定义如下：\n\n- 度为 $1$ 的盒子分形简单地是 X\n- 度为 $2$ 的盒子分形是\n```\nX X\n X\nX X\n```\n- 如果用 $B(n - 1)$ 表示度为 $n - 1$ 的盒子分形，那么度为 $n$ 的盒子分形可以递归地定义如下\n```\nB(n - 1) B(n - 1)\n     B(n - 1)\nB(n - 1) B(n - 1)\n```\n你的任务是绘制度为 $n$ 的盒子分形。", "inputFormat": "输入包含多个测试用例。输入的每一行包含一个不大于 $7$ 的正整数 $n$。输入的最后一行是一个负整数 $-1$，表示输入的结束。", "outputFormat": "对于每个测试用例，使用 'X' 符号输出盒子分形。请注意，'X' 是一个大写字母。在每个测试用例之后打印一行仅包含单个破折号。\n\n翻译来自于：ChatGPT。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10459", "type": "P", "difficulty": 7, "samples": [["2\n4 \n0 0 \n0 1 \n1 0 \n1 1 \n2 2 \n2 3 \n3 2 \n3 3 \n4 \n0 0 \n0 0 \n0 0 \n0 0 \n0 0 \n0 0 \n0 0 \n0 0", "1.414\n0.000"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["计算几何", "分治", "凸包"], "title": "Raid", "background": "", "description": "After successive failures in the battles against the Union, the Empire retreated to its last stronghold. Depending on its powerful defense system, the Empire repelled the six waves of Union's attack. After several sleepless nights of thinking, Arthur, General of the Union, noticed that the only weakness of the defense system was its energy supply. The system was charged by $N$ nuclear power stations and breaking down any of them would disable the system.\n\nThe general soon started a raid to the stations by $N$ special agents who were paradroped into the stronghold. Unfortunately they failed to land at the expected positions due to the attack by the Empire Air Force. As an experienced general, Arthur soon realized that he needed to rearrange the plan. The first thing he wants to know now is that which agent is the nearest to any power station. Could you, the chief officer, help the general to calculate the minimum distance between an agent and a station?\n", "inputFormat": "The first line is a integer T representing the number of test cases.\n\nEach test case begins with an integer $N (1 \\leq N \\leq 100000)$.\n\nThe next $N$ lines describe the positions of the stations. Each line consists of two integers $X (0 \\leq X \\leq 10^9)$ and $Y (0 \\leq Y \\leq 10^9)$ indicating the positions of the station.\n\nThe next following N lines describe the positions of the agents. Each line consists of two integers $X (0 \\leq X \\leq 10^9)$ and $Y (0 \\leq Y \\leq 10^9)$ indicating the positions of the agent.", "outputFormat": "For each test case output the minimum distance with precision of three decimal placed in a separate line.", "hint": "", "locale": "en", "translations": {"en": {"title": "Raid", "background": "", "description": "After successive failures in the battles against the Union, the Empire retreated to its last stronghold. Depending on its powerful defense system, the Empire repelled the six waves of Union's attack. After several sleepless nights of thinking, Arthur, General of the Union, noticed that the only weakness of the defense system was its energy supply. The system was charged by $N$ nuclear power stations and breaking down any of them would disable the system.\n\nThe general soon started a raid to the stations by $N$ special agents who were paradroped into the stronghold. Unfortunately they failed to land at the expected positions due to the attack by the Empire Air Force. As an experienced general, Arthur soon realized that he needed to rearrange the plan. The first thing he wants to know now is that which agent is the nearest to any power station. Could you, the chief officer, help the general to calculate the minimum distance between an agent and a station?\n", "inputFormat": "The first line is a integer T representing the number of test cases.\n\nEach test case begins with an integer $N (1 \\leq N \\leq 100000)$.\n\nThe next $N$ lines describe the positions of the stations. Each line consists of two integers $X (0 \\leq X \\leq 10^9)$ and $Y (0 \\leq Y \\leq 10^9)$ indicating the positions of the station.\n\nThe next following N lines describe the positions of the agents. Each line consists of two integers $X (0 \\leq X \\leq 10^9)$ and $Y (0 \\leq Y \\leq 10^9)$ indicating the positions of the agent.", "outputFormat": "For each test case output the minimum distance with precision of three decimal placed in a separate line.", "hint": "", "locale": "en"}, "zh-CN": {"title": "Raid", "background": "《算法竞赛进阶指南》给出参考代码可以在本题获得 Subtask1 中的 44 分，在部分边界条件 $n=1,2$ 下会失分。该参考代码会被特意构造的数据卡掉，无法通过所有测试点。", "description": "在连续的对抗联盟失败后，帝国撤退到了最后的要塞。依靠其强大的防御系统，帝国击退了联盟的六波攻击。经过几个不眠之夜的思考，联盟将军亚瑟注意到防御系统唯一的弱点是其能源供应。该系统由 $N$ 个核电站供电，破坏其中任何一个都会使系统失效。\n\n将军很快派出了 $N$ 名特工突袭这些电站，他们被空投到了要塞内。不幸的是，由于帝国空军的袭击，他们未能着陆到预期的位置。作为一名经验丰富的将军，亚瑟很快意识到他需要重新安排计划。他现在想知道的第一件事是，哪个特工距离任何一个电站最近。作为首席官员，你能帮助将军计算特工与电站之间的最小距离吗？", "inputFormat": "第一行是一个整数 $T(1\\leq T\\leq 10^5)$，表示测试用例的数量。\n\n每个测试用例以一个整数 $N (1 \\leq N \\leq 10^5)$ 开始。\n\n接下来的 $N$ 行描述了电站的位置。每行包含两个整数 $X (0 \\leq X \\leq 10^9)$ 和 $Y (0 \\leq Y \\leq 10^9)$，表示电站的位置。\n\n接下来的 $N$ 行描述了特工的位置。每行包含两个整数 $X (0 \\leq X \\leq 10^9)$ 和 $Y (0 \\leq Y \\leq 10^9)$，表示特工的位置。\n\n保证在一个测试点中，$\\sum N\\leq 10^5$。", "outputFormat": "对于每个测试用例，输出距离最小值，保留三位小数，单独占一行。", "hint": "翻译来自 ChatGPT。", "locale": "zh-CN"}}}
{"pid": "P10460", "type": "P", "difficulty": 3, "samples": [["3\n2\n1 10 1 \n2 10 1 \n2\n1 10 1 \n1 10 1 \n4\n1 10 1 \n4 4 1 \n1 5 1 \n6 10 1\n", "1 1\nThere's no weakness. \n4 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["二分", "前缀和", "位运算"], "title": "防线", "background": "", "description": "lsp 学习数学竞赛的时候受尽了同仁们的鄙视，终于有一天……受尽屈辱的 lsp 黑化成为了黑暗英雄 Lord lsp。就如同中二漫画的情节一样，Lord lsp 打算毁掉这个世界。数学竞赛界的精英 lqr 打算阻止 Lord lsp 的阴谋，于是她集合了一支由数学竞赛选手组成的超级行动队。由于队员们个个都智商超群，很快，行动队便来到了 Lord lsp 的黑暗城堡的下方。\n\n但是，同样强大的 Lord lsp 在城堡周围布置了一条“不可越过”的坚固防线。防线由很多防具组成，这些防具分成了 $N$ 组。我们可以认为防线是一维的，那么每一组防具都分布在防线的某一段上，并且同一组防具是等距离排列的。也就是说，我们可以用三个整数 $S$，$E$ 和 $D$ 来描述一组防具，即这一组防具布置在防线的 $S,S + D,S + 2D，\\dots，S + KD$（$K\\in \\Z，S + KD\\leq E，S + (K + 1)D>E$） 位置上。\n\n黑化的 Lord lsp 设计的防线极其精良。如果防线的某个位置有偶数个防具，那么这个位置就是毫无破绽的（包括这个位置一个防具也没有的情况，因为 $0$ 也是偶数）。只有有奇数个防具的位置有破绽，但是整条防线上也最多只有一个位置有奇数个防具。作为行动队的队长，lqr 要找到防线的破绽以策划下一步的行动。但是，由于防具的数量太多，她实在是不能看出哪里有破绽。作为 lqr 可以信任的学弟学们，你们要帮助她解决这个问题。", "inputFormat": "输入文件的第一行是一个整数 $T$，表示有 $T$ 组互相独立的测试数据。 \n\n每组数据的第一行是一个整数 $N$。\n\n之后 $N$ 行，每行三个整数 $S_i$，$E_i$，$D_i$，代表第 $i$ 组防具的三个参数。", "outputFormat": "对于每组测试数据，如果防线没有破绽，即所有的位置都有偶数个防具，输出一行 `There's no weakness.`。\n\n否则在一行内输出两个空格分隔的整数 $P$ 和 $C$，表示在位置 $P$ 有 $C$ 个防具。当然 $C$ 应该是一个奇数。", "hint": "对于 $30\\%$ 的数据，满足防具总数不多于 $10  ^ {7}$。\n\n对于 $100\\%$ 的数据，满足防具总数不多于 $10  ^ {8}$，$S_{i}\\le E_{i} $，$1\\le T \\le 5$，$N \\le 200000$，$0 \\le S_{i}$ ，$E_{i}$ ，$D_{i} \\le 2^{31} - 1$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "防线", "background": "", "description": "lsp 学习数学竞赛的时候受尽了同仁们的鄙视，终于有一天……受尽屈辱的 lsp 黑化成为了黑暗英雄 Lord lsp。就如同中二漫画的情节一样，Lord lsp 打算毁掉这个世界。数学竞赛界的精英 lqr 打算阻止 Lord lsp 的阴谋，于是她集合了一支由数学竞赛选手组成的超级行动队。由于队员们个个都智商超群，很快，行动队便来到了 Lord lsp 的黑暗城堡的下方。\n\n但是，同样强大的 Lord lsp 在城堡周围布置了一条“不可越过”的坚固防线。防线由很多防具组成，这些防具分成了 $N$ 组。我们可以认为防线是一维的，那么每一组防具都分布在防线的某一段上，并且同一组防具是等距离排列的。也就是说，我们可以用三个整数 $S$，$E$ 和 $D$ 来描述一组防具，即这一组防具布置在防线的 $S,S + D,S + 2D，\\dots，S + KD$（$K\\in \\Z，S + KD\\leq E，S + (K + 1)D>E$） 位置上。\n\n黑化的 Lord lsp 设计的防线极其精良。如果防线的某个位置有偶数个防具，那么这个位置就是毫无破绽的（包括这个位置一个防具也没有的情况，因为 $0$ 也是偶数）。只有有奇数个防具的位置有破绽，但是整条防线上也最多只有一个位置有奇数个防具。作为行动队的队长，lqr 要找到防线的破绽以策划下一步的行动。但是，由于防具的数量太多，她实在是不能看出哪里有破绽。作为 lqr 可以信任的学弟学们，你们要帮助她解决这个问题。", "inputFormat": "输入文件的第一行是一个整数 $T$，表示有 $T$ 组互相独立的测试数据。 \n\n每组数据的第一行是一个整数 $N$。\n\n之后 $N$ 行，每行三个整数 $S_i$，$E_i$，$D_i$，代表第 $i$ 组防具的三个参数。", "outputFormat": "对于每组测试数据，如果防线没有破绽，即所有的位置都有偶数个防具，输出一行 `There's no weakness.`。\n\n否则在一行内输出两个空格分隔的整数 $P$ 和 $C$，表示在位置 $P$ 有 $C$ 个防具。当然 $C$ 应该是一个奇数。", "hint": "对于 $30\\%$ 的数据，满足防具总数不多于 $10  ^ {7}$。\n\n对于 $100\\%$ 的数据，满足防具总数不多于 $10  ^ {8}$，$S_{i}\\le E_{i} $，$1\\le T \\le 5$，$N \\le 200000$，$0 \\le S_{i}$ ，$E_{i}$ ，$D_{i} \\le 2^{31} - 1$。", "locale": "zh-CN"}}}
{"pid": "P10461", "type": "P", "difficulty": 7, "samples": [["2\n0 1 2 3\n2 1 1", "2 1 2 7"], ["4\n0 8 3 2 7 3 9 0 0 1 8 2 3 7 0 2\n1 0 4 8 2", "1 0 0 192 0 448 168 8824 0 0 0 536 0 248 520 26560 "]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["快速沃尔什变换 FWT", "快速莫比乌斯变换 FMT", "集合幂级数，子集卷积", "模板题"], "title": "【模板】多项式复合集合幂级数", "background": "", "description": "给定一个集合幂级数 $F(x)$ 和一个多项式 $G(x)$，保证 $[x^{\\varnothing}]F(x)=0$。定义 $x$ 的乘法为子集卷积，你需要对 $S\\subseteq\\{1,2,\\cdots,n\\}$ 求出 $[x^S]G(F(x))$ 对 $998244353$ 取模后的值。\n\n如果你仍不清楚题意，可以阅读题面最后的提示部分。", "inputFormat": "第一行一个正整数 $n$。\n\n接下来一行 $2^n$ 个非负整数，第 $i$ 个整数表示 $[x^S]F(x)$，其中 $a\\in S$ 当且仅当 $(i-1)$ 二进制下从低到高第 $a$ 位为 $1$。\n\n接下来一行 $n+1$ 个非负整数，第 $i$ 个整数表示 $[x^{i-1}]G(x)$。", "outputFormat": "输出一行 $2^n$ 个非负整数，第 $i$ 个整数表示 $[x^S]G(F(x))$ 对 $998244353$ 取模后的值，其中 $a\\in S$ 当且仅当 $(i-1)$ 二进制下从低到高第 $a$ 位为 $1$。", "hint": "#### 【数据范围】\n\n对于所有数据，保证 $1\\le n\\le 20$，$[x^S]F(x),[x^n]G(x)\\in[0,998244353)\\cap\\mathbb Z$。\n\n本题有 $20$ 个测试点，第 $i$ 个测试点满足 $n=i$。\n\n#### 【提示】\n\n假设 $F(x)=\\displaystyle \\sum_S f_Sx^S$，那么 $[x^S]F(x)=f_S$。\n\n在本题中，$x$ 的乘法被定义为子集卷积，即：\n$$x^S\\cdot x^T=\\begin{cases}0&S\\cap T\\neq\\varnothing\\\\x^{S\\cup T}&\\text{otherwise}\\end{cases}$$\n\n**请注意内存访问连续性带来的效率差异。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "【模板】多项式复合集合幂级数", "background": "", "description": "给定一个集合幂级数 $F(x)$ 和一个多项式 $G(x)$，保证 $[x^{\\varnothing}]F(x)=0$。定义 $x$ 的乘法为子集卷积，你需要对 $S\\subseteq\\{1,2,\\cdots,n\\}$ 求出 $[x^S]G(F(x))$ 对 $998244353$ 取模后的值。\n\n如果你仍不清楚题意，可以阅读题面最后的提示部分。", "inputFormat": "第一行一个正整数 $n$。\n\n接下来一行 $2^n$ 个非负整数，第 $i$ 个整数表示 $[x^S]F(x)$，其中 $a\\in S$ 当且仅当 $(i-1)$ 二进制下从低到高第 $a$ 位为 $1$。\n\n接下来一行 $n+1$ 个非负整数，第 $i$ 个整数表示 $[x^{i-1}]G(x)$。", "outputFormat": "输出一行 $2^n$ 个非负整数，第 $i$ 个整数表示 $[x^S]G(F(x))$ 对 $998244353$ 取模后的值，其中 $a\\in S$ 当且仅当 $(i-1)$ 二进制下从低到高第 $a$ 位为 $1$。", "hint": "#### 【数据范围】\n\n对于所有数据，保证 $1\\le n\\le 20$，$[x^S]F(x),[x^n]G(x)\\in[0,998244353)\\cap\\mathbb Z$。\n\n本题有 $20$ 个测试点，第 $i$ 个测试点满足 $n=i$。\n\n#### 【提示】\n\n假设 $F(x)=\\displaystyle \\sum_S f_Sx^S$，那么 $[x^S]F(x)=f_S$。\n\n在本题中，$x$ 的乘法被定义为子集卷积，即：\n$$x^S\\cdot x^T=\\begin{cases}0&S\\cap T\\neq\\varnothing\\\\x^{S\\cup T}&\\text{otherwise}\\end{cases}$$\n\n**请注意内存访问连续性带来的效率差异。**", "locale": "zh-CN"}}}
{"pid": "P10462", "type": "P", "difficulty": 2, "samples": [["8\n62 2 abcdefghiz\n10 16 1234567890123456789012345678901234567890\n16 35 3A0C92075C0DBF3B8ACBC5F96CE3F0AD2\n35 23 333YMHOUE8JPLT7OX6K9FYCQ8A\n23 49 946B9AA02MI37E3D3MMJ4G7BL2F05\n49 61 1VbDkSIMJL3JjRgAdlUfcaWj\n61 5 dl9MDSWqwHjDnToKcsWE1S\n5 10 42104444441001414401221302402201233340311104212022133030", "62 abcdefghiz\n2 11011100000100010111110010010110011111001001100011010010001\n\n10 1234567890123456789012345678901234567890\n16 3A0C92075C0DBF3B8ACBC5F96CE3F0AD2\n\n16 3A0C92075C0DBF3B8ACBC5F96CE3F0AD2\n35 333YMHOUE8JPLT7OX6K9FYCQ8A\n\n35 333YMHOUE8JPLT7OX6K9FYCQ8A\n23 946B9AA02MI37E3D3MMJ4G7BL2F05\n\n23 946B9AA02MI37E3D3MMJ4G7BL2F05\n49 1VbDkSIMJL3JjRgAdlUfcaWj\n\n49 1VbDkSIMJL3JjRgAdlUfcaWj\n61 dl9MDSWqwHjDnToKcsWE1S\n\n61 dl9MDSWqwHjDnToKcsWE1S\n5 42104444441001414401221302402201233340311104212022133030\n\n5 42104444441001414401221302402201233340311104212022133030\n10 1234567890123456789012345678901234567890"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["模拟", "2002", "ICPC"], "title": "Number Base Conversion", "background": "", "description": "Write a program to convert numbers in one base to numbers in a second base. There are $62$ different digits:\n\n$\\{ 0\\sim 9, A\\sim Z,a\\sim z \\}$\n\nHINT: If you make a sequence of base conversions using the output of one conversion as the input to the next, when you get back to the original base, you should get the original number.\n", "inputFormat": "The first line of input contains a single positive integer. This is the number of lines that follow. Each of the following lines will have a (decimal) input base followed by a (decimal) output base followed by a number expressed in the input base. Both the input base and the output base will be in the range from $2$ to $62$. That is (in decimal) $A = 10, B = 11, \\dots, Z = 35, a = 36, b = 37, \\dots, z = 61$ ($0\\sim 9$ have their usual meanings).", "outputFormat": "The output of the program should consist of three lines of output for each base conversion performed. The first line should be the input base in decimal followed by a space then the input number (as given expressed in the input base). The second output line should be the output base followed by a space then the input number (as expressed in the output base). The third output line is blank.", "hint": "题目保证 $1\\le T\\le 100$，要转换的数字是不超过 $10^{110}$ 的自然数。", "locale": "en", "translations": {"en": {"title": "Number Base Conversion", "background": "", "description": "Write a program to convert numbers in one base to numbers in a second base. There are $62$ different digits:\n\n$\\{ 0\\sim 9, A\\sim Z,a\\sim z \\}$\n\nHINT: If you make a sequence of base conversions using the output of one conversion as the input to the next, when you get back to the original base, you should get the original number.\n", "inputFormat": "The first line of input contains a single positive integer. This is the number of lines that follow. Each of the following lines will have a (decimal) input base followed by a (decimal) output base followed by a number expressed in the input base. Both the input base and the output base will be in the range from $2$ to $62$. That is (in decimal) $A = 10, B = 11, \\dots, Z = 35, a = 36, b = 37, \\dots, z = 61$ ($0\\sim 9$ have their usual meanings).", "outputFormat": "The output of the program should consist of three lines of output for each base conversion performed. The first line should be the input base in decimal followed by a space then the input number (as given expressed in the input base). The second output line should be the output base followed by a space then the input number (as expressed in the output base). The third output line is blank.", "hint": "题目保证 $1\\le T\\le 100$，要转换的数字是不超过 $10^{110}$ 的自然数。", "locale": "en"}, "zh-CN": {"title": "Number Base Conversion", "background": "", "description": "编写一个程序，将一个进制中的数字转换为另一个进制中的数字。有 $62$ 个不同的数字：\n\n${ 0\\sim 9, A\\sim Z,a\\sim z }$\n\n提示：如果你连续进行一系列的进制转换，将一个转换的输出作为下一个转换的输入，当你回到原始的进制时，你应该得到原始的数字。", "inputFormat": "输入的第一行包含一个正整数，表示接下来有多少行输入。接下来的每一行都包含一个输入进制（十进制表示）和一个输出进制（十进制表示），然后是以输入进制表示的数字。输入进制和输出进制都将在 $2$ 到 $62$ 的范围内。也就是说（十进制表示）$A = 10, B = 11, \\dots, Z = 35, a = 36, b = 37, \\dots, z = 61$，（$0\\sim 9$ 的意思与平常一样）。", "outputFormat": "程序的输出应该包括每次进制转换的三行输出。第一行应该是以十进制表示的输入进制，然后是一个空格，接着是以输入进制表示的输入数字。第二行输出是输出进制，然后是一个空格，接着是以输出进制表示的输入数字。第三行输出是空白行。\n\n翻译来自于：ChatGPT。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10463", "type": "P", "difficulty": 5, "samples": [["5 5\n1 3 5 7 9\nQ 1 5\nC 1 5 1\nQ 1 5\nC 3 3 6\nQ 2 4", "1\n2\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "最大公约数 gcd"], "title": "Interval GCD", "background": null, "description": "给定一个长度为 $N$ 的数列 $a$，以及 $M$ 条指令，每条指令可能是以下两种之一：\n\n1. `C l r d`，表示把 $a_l,a_{l+1},…,a_r$ 都加上 $d$。\n2. `Q l r`，表示询问 $a_l,a_{l+1},…,a_r$ 的最大公约数（$\\gcd$）。\n\n对于每个询问，输出一个整数表示答案。", "inputFormat": "第一行两个整数 $N,M$。\n\n第二行 $N$ 个整数，分别表示 $a_1,a_2,\\dots,a_N$。\n\n接下来 $M$ 行表示 $M$ 条指令，每条指令的格式如题目描述所示。", "outputFormat": "对于每个询问，输出一个整数表示答案，每个答案占一行。", "hint": "对于 $100\\%$ 的测试数据，$N \\le 5\\times10^5$，$M \\le 10^5$，$1 \\le a_i \\le 10^{18}$，$|d| \\le 10^{18}$，保证数据在计算过程中不会超过 long long 范围。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Interval GCD", "background": null, "description": "给定一个长度为 $N$ 的数列 $a$，以及 $M$ 条指令，每条指令可能是以下两种之一：\n\n1. `C l r d`，表示把 $a_l,a_{l+1},…,a_r$ 都加上 $d$。\n2. `Q l r`，表示询问 $a_l,a_{l+1},…,a_r$ 的最大公约数（$\\gcd$）。\n\n对于每个询问，输出一个整数表示答案。", "inputFormat": "第一行两个整数 $N,M$。\n\n第二行 $N$ 个整数，分别表示 $a_1,a_2,\\dots,a_N$。\n\n接下来 $M$ 行表示 $M$ 条指令，每条指令的格式如题目描述所示。", "outputFormat": "对于每个询问，输出一个整数表示答案，每个答案占一行。", "hint": "对于 $100\\%$ 的测试数据，$N \\le 5\\times10^5$，$M \\le 10^5$，$1 \\le a_i \\le 10^{18}$，$|d| \\le 10^{18}$，保证数据在计算过程中不会超过 long long 范围。", "locale": "zh-CN"}}}
{"pid": "P10464", "type": "P", "difficulty": 3, "samples": [["1 2 \n100 3 \n100 2 \n100 1", "1 50004"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心"], "title": "Task", "background": "", "description": "Today the company has $m$ tasks to complete. The $i-$th task need $x_i$ minutes to complete. Meanwhile, this task has a difficulty level $y_i$. The machine whose level below this task’s level $y_i$ cannot complete this task. If the company completes this task, they will get $(500\\times x_i+2\\times y_i)$ dollars.\n\nThe company has $n$ machines. Each machine has a maximum working time and a level. If the time for the task is more than the maximum working time of the machine, the machine can not complete this task. Each machine can only complete a task one day. Each task can only be completed by one machine.\n\nThe company hopes to maximize the number of the tasks which they can complete today. If there are multiple solutions, they hopes to make the money maximum.", "inputFormat": "The input contains several test cases.\n\nThe first line contains two integers $N$ and $M$. $N$ is the number of the machines.M is the number of tasks $(1 \\leq N \\leq 100000, 1\\leq M\\leq 100000)$.\n\nThe following $N$ lines each contains two integers $x_i(0<x_i<1440),y_i(0\\leq yi\\leq 100)$. $x_i$ is the maximum time the machine can work. $y_i$ is the level of the machine. \n\nThe following $M$ lines each contains two integers $x_i(0<x_i<1440),y_i(0\\leq y_i\\leq 100)$. $x_i$ is the time we need to complete the task. $y_i$ is the level of the task.", "outputFormat": "For each test case, output two integers, the maximum number of the tasks which the company can complete today and the money they will get.", "hint": "", "locale": "en", "translations": {"en": {"title": "Task", "background": "", "description": "Today the company has $m$ tasks to complete. The $i-$th task need $x_i$ minutes to complete. Meanwhile, this task has a difficulty level $y_i$. The machine whose level below this task’s level $y_i$ cannot complete this task. If the company completes this task, they will get $(500\\times x_i+2\\times y_i)$ dollars.\n\nThe company has $n$ machines. Each machine has a maximum working time and a level. If the time for the task is more than the maximum working time of the machine, the machine can not complete this task. Each machine can only complete a task one day. Each task can only be completed by one machine.\n\nThe company hopes to maximize the number of the tasks which they can complete today. If there are multiple solutions, they hopes to make the money maximum.", "inputFormat": "The input contains several test cases.\n\nThe first line contains two integers $N$ and $M$. $N$ is the number of the machines.M is the number of tasks $(1 \\leq N \\leq 100000, 1\\leq M\\leq 100000)$.\n\nThe following $N$ lines each contains two integers $x_i(0<x_i<1440),y_i(0\\leq yi\\leq 100)$. $x_i$ is the maximum time the machine can work. $y_i$ is the level of the machine. \n\nThe following $M$ lines each contains two integers $x_i(0<x_i<1440),y_i(0\\leq y_i\\leq 100)$. $x_i$ is the time we need to complete the task. $y_i$ is the level of the task.", "outputFormat": "For each test case, output two integers, the maximum number of the tasks which the company can complete today and the money they will get.", "hint": "", "locale": "en"}, "zh-CN": {"title": "Task", "background": "", "description": "今天公司有 $m$ 项任务要完成。第 $i$ 项任务需要 $x_i$ 分钟来完成。同时，这个任务有一个困难级别 $y_i$。级别低于该任务级别 $y_i$ 的机器无法完成这项任务。如果公司完成了这项任务，他们将获得 $(500\\times x_i+2\\times y_i)$ 美元。\n\n公司有 $n$ 台机器。每台机器都有最大工作时间和一个级别。如果任务的时间超过机器的最大工作时间，则该机器无法完成这个任务。每台机器一天只能完成一项任务。每项任务只能由一台机器完成。\n\n公司希望最大化今天他们可以完成的任务数量。如果存在多个解决方案，他们希望使收益最大化。", "inputFormat": "第一行包含两个整数 $N$ 和 $M$。$N$ 是机器的数量。$M$ 是任务的数量 $(1 \\leq N \\leq 100000, 1\\leq M\\leq 100000)$。\n\n接下来的 $N$ 行每行包含两个整数 $x_i(0<x_i<1440),y_i(0\\leq y_i\\leq 100)$。$x_i$ 是机器可以工作的最长时间。$y_i$ 是机器的级别。\n\n接下来的 $M$ 行每行包含两个整数 $x_i(0<x_i<1440),y_i(0\\leq y_i\\leq 100)$。$x_i$ 是完成任务所需的时间。$y_i$ 是任务的级别。", "outputFormat": "对于每个测试用例，输出两个整数，分别是公司今天可以完成的最大任务数量和他们将获得的收益。\n\n翻译来自于：ChatGPT。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10465", "type": "P", "difficulty": 5, "samples": [["6\n3\n6\n0\n9\n6\n3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["Ad-hoc"], "title": "双端队列", "background": "", "description": "Sherry 现在碰到了一个棘手的问题，有 $N(1 \\le N \\le 200000)$ 个整数需要排序。\n\nSherry 手头能用的工具就是若干个双端队列。\n\n她从 $1$ 到 $N$ 需要依次处理这 $N$ 个数，对于每个数，Sherry 能做以下两件事：\n\n1．新建一个双端队列，并将当前数作为这个队列中的唯一的数；\n\n2．将当前数放入已有的队列的头之前或者尾之后。\n\n对所有的数处理完成之后，Sherry 将这些队列按一定的顺序连接起来后就可以得到一个非降的序列。\n\n请你求出最少需要多少个双端序列。", "inputFormat": "第一行输入整数 $N$，代表整数的个数。\n\n接下来 $N$ 行，每行包括一个整数 $D_i$，代表所需处理的整数。", "outputFormat": "输出一个整数，代表最少需要的双端队列数。\n", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "双端队列", "background": "", "description": "Sherry 现在碰到了一个棘手的问题，有 $N(1 \\le N \\le 200000)$ 个整数需要排序。\n\nSherry 手头能用的工具就是若干个双端队列。\n\n她从 $1$ 到 $N$ 需要依次处理这 $N$ 个数，对于每个数，Sherry 能做以下两件事：\n\n1．新建一个双端队列，并将当前数作为这个队列中的唯一的数；\n\n2．将当前数放入已有的队列的头之前或者尾之后。\n\n对所有的数处理完成之后，Sherry 将这些队列按一定的顺序连接起来后就可以得到一个非降的序列。\n\n请你求出最少需要多少个双端序列。", "inputFormat": "第一行输入整数 $N$，代表整数的个数。\n\n接下来 $N$ 行，每行包括一个整数 $D_i$，代表所需处理的整数。", "outputFormat": "输出一个整数，代表最少需要的双端队列数。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10466", "type": "P", "difficulty": 3, "samples": [["3\n1 5 3", "4 1\n2 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["链表"], "title": "邻值查找", "background": "", "description": "给定一个长度为 $n$ 的序列 $A$，$A$ 中的数各不相同。\n\n对于 $A$ 中的每一个数 $A_i$，求：\n\n$\\min_{1 \\le j <i}|A_i-A_j|$\n\n以及令上式取到最小值的 $j$（记为 $P_i$）。若最小值点不唯一，则选择使 $A_j$ 较小的那个。", "inputFormat": "第一行输入整数 $n$，代表序列长度。\n\n第二行输入 $n$ 个整数 $A_1 \\sim A_n$，代表序列的具体数值，数值之间用空格隔开。", "outputFormat": "输出共 $n-1$ 行，每行输出两个整数，数值之间用空格隔开。\n\n分别表示当 $i$ 取 $2 \\sim n$ 时，对应的 $\\min_{1 \\le j <i}|A_i-A_j|$ 和 $P_i$ 的值。", "hint": "对于 $30\\%$ 的数据 $n \\le 100$。\n\n对于 $70\\%$ 的数据 $n \\le 10^4$。\n\n对于 $100\\%$ 的数据 $n \\le 10^5,|A_i| \\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "邻值查找", "background": "", "description": "给定一个长度为 $n$ 的序列 $A$，$A$ 中的数各不相同。\n\n对于 $A$ 中的每一个数 $A_i$，求：\n\n$\\min_{1 \\le j <i}|A_i-A_j|$\n\n以及令上式取到最小值的 $j$（记为 $P_i$）。若最小值点不唯一，则选择使 $A_j$ 较小的那个。", "inputFormat": "第一行输入整数 $n$，代表序列长度。\n\n第二行输入 $n$ 个整数 $A_1 \\sim A_n$，代表序列的具体数值，数值之间用空格隔开。", "outputFormat": "输出共 $n-1$ 行，每行输出两个整数，数值之间用空格隔开。\n\n分别表示当 $i$ 取 $2 \\sim n$ 时，对应的 $\\min_{1 \\le j <i}|A_i-A_j|$ 和 $P_i$ 的值。", "hint": "对于 $30\\%$ 的数据 $n \\le 100$。\n\n对于 $70\\%$ 的数据 $n \\le 10^4$。\n\n对于 $100\\%$ 的数据 $n \\le 10^5,|A_i| \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P10467", "type": "P", "difficulty": 3, "samples": [["2 \n1 2 3 4 5 6 \n4 3 2 1 6 5", "Twin snowflakes found."]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2007", "CCC（加拿大）", "哈希 hashing"], "title": "[CCC 2007] Snowflake Snow Snowflakes", "background": "", "description": "You may have heard that no two snowflakes are alike. Your task is to write a program to determine whether this is really true. Your program will read information about a collection of snowflakes, and search for a pair that may be identical. Each snowflake has six arms. For each snowflake, your program will be provided with a measurement of the length of each of the six arms. Any pair of snowflakes which have the same lengths of corresponding arms should be flagged by your program as possibly identical.", "inputFormat": "The first line of input will contain a single integer $n$, $0 < n \\le 100000$ , the number of snowflakes to follow. This will be followed by $n$ lines, each describing a snowflake. Each snowflake will be described by a line containing six integers (each integer is at least $0$ and less than $10000000$) , the lengths of the arms of the snow ake. The lengths of the arms will be given in order around the snowflake (either clockwise or counterclockwise), but they may begin with any of the six arms. For example, the same snowflake could be described as $1 2 3 4 5 6$ or $4 3 2 1 6 5$ . ", "outputFormat": "If all of the snowflakes are distinct, your program should print the message:\n\n`No two snowflakes are alike.`\n\nIf there is a pair of possibly identical snow akes, your program should print the message:\n\n`Twin snowflakes found.`", "hint": "", "locale": "en", "translations": {"en": {"title": "[CCC 2007] Snowflake Snow Snowflakes", "background": "", "description": "You may have heard that no two snowflakes are alike. Your task is to write a program to determine whether this is really true. Your program will read information about a collection of snowflakes, and search for a pair that may be identical. Each snowflake has six arms. For each snowflake, your program will be provided with a measurement of the length of each of the six arms. Any pair of snowflakes which have the same lengths of corresponding arms should be flagged by your program as possibly identical.", "inputFormat": "The first line of input will contain a single integer $n$, $0 < n \\le 100000$ , the number of snowflakes to follow. This will be followed by $n$ lines, each describing a snowflake. Each snowflake will be described by a line containing six integers (each integer is at least $0$ and less than $10000000$) , the lengths of the arms of the snow ake. The lengths of the arms will be given in order around the snowflake (either clockwise or counterclockwise), but they may begin with any of the six arms. For example, the same snowflake could be described as $1 2 3 4 5 6$ or $4 3 2 1 6 5$ . ", "outputFormat": "If all of the snowflakes are distinct, your program should print the message:\n\n`No two snowflakes are alike.`\n\nIf there is a pair of possibly identical snow akes, your program should print the message:\n\n`Twin snowflakes found.`", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CCC 2007] Snowflake Snow Snowflakes", "background": "", "description": "你可能听说过没有两片雪花是相同的。你的任务是编写一个程序来确定这是否真的是正确的。你的程序将读取关于一组雪花的信息，并搜索可能相同的一对雪花。每片雪花有六条“角”。对于每片雪花，你的程序将提供每条角的长度测量。任何一对长度对应的角相同的雪花都应该被你的程序标记为可能相同。", "inputFormat": "输入的第一行包含一个整数 $n$，$0 < n \\le 100000$，表示接下来的雪花数量。接下来的 $n$ 行描述每片雪花。每片雪花由包含六个整数的一行描述（每个整数至少为 $0$ 且小于 $10000000$），表示雪花的六条角的长度。角的长度将按顺序围绕着雪花给出（顺时针或逆时针），但它们可以从六个角中的任何一条开始。例如，同一片雪花可以描述为 $1\\ 2\\ 3\\ 4\\ 5\\ 6$ 或 $4\\ 3\\ 2\\ 1\\ 6\\ 5$。", "outputFormat": "如果所有的雪花都是不同的，你的程序应该打印消息：\n\n`No two snowflakes are alike.`\n\n如果有一对可能相同的雪花，你的程序应该打印消息：\n\n`Twin snowflakes found.`\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10468", "type": "P", "difficulty": 3, "samples": [["aabbaabb\n3\n1 3 5 7\n1 3 6 8\n1 2 1 2", "Yes\nNo\nYes"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["哈希 hashing"], "title": "兔子与兔子", "background": null, "description": "很久很久以前，森林里住着一群兔子。\n\n有一天，兔子们想要研究自己的 DNA 序列。\n\n我们首先选取一个好长好长的 DNA 序列（小兔子是外星生物，DNA 序列可能包含 $26$ 个小写英文字母）。\n\n然后我们每次选择两个区间，询问如果用两个区间里的 DNA 序列分别生产出来两只兔子，这两个兔子是否一模一样。\n\n注意两个兔子一模一样只可能是他们的 DNA 序列一模一样。", "inputFormat": "第一行输入一个 DNA 字符串 $S$。\n\n第二行一个数字 $m$，表示 $m$ 次询问。\n\n接下来 $m$ 行，每行四个数字 $l_1, r_1, l_2, r_2$，分别表示此次询问的两个区间，注意字符串的位置从 $1$ 开始编号。", "outputFormat": "对于每次询问，输出一行表示结果。\n\n如果两只兔子完全相同输出 `Yes`，否则输出 `No`（注意大小写）。", "hint": "数据保证，$1 \\le |S|,m \\le 10^6$。其中，$|S|$ 为字符串 $S$ 的长度。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "兔子与兔子", "background": null, "description": "很久很久以前，森林里住着一群兔子。\n\n有一天，兔子们想要研究自己的 DNA 序列。\n\n我们首先选取一个好长好长的 DNA 序列（小兔子是外星生物，DNA 序列可能包含 $26$ 个小写英文字母）。\n\n然后我们每次选择两个区间，询问如果用两个区间里的 DNA 序列分别生产出来两只兔子，这两个兔子是否一模一样。\n\n注意两个兔子一模一样只可能是他们的 DNA 序列一模一样。", "inputFormat": "第一行输入一个 DNA 字符串 $S$。\n\n第二行一个数字 $m$，表示 $m$ 次询问。\n\n接下来 $m$ 行，每行四个数字 $l_1, r_1, l_2, r_2$，分别表示此次询问的两个区间，注意字符串的位置从 $1$ 开始编号。", "outputFormat": "对于每次询问，输出一行表示结果。\n\n如果两只兔子完全相同输出 `Yes`，否则输出 `No`（注意大小写）。", "hint": "数据保证，$1 \\le |S|,m \\le 10^6$。其中，$|S|$ 为字符串 $S$ 的长度。", "locale": "zh-CN"}}}
{"pid": "P10469", "type": "P", "difficulty": 4, "samples": [["ponoiiipoi", "9 4 5 6 2 8 3 1 7 0\n0 1 2 1 0 0 2 1 0 2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "倍增", "二分", "排序", "哈希 hashing"], "title": "后缀数组", "background": "", "description": "后缀数组 (SA) 是一种重要的数据结构，通常使用倍增或者 DC3 算法实现，这超出了我们的讨论范围。\n\n在本题中，我们希望使用快排、Hash 与二分实现一个简单的 $O(n\\log^2n)$ 的后缀数组求法。\n\n详细地说，给定一个长度为 $n$ 的字符串 $S$（下标 $0 \\sim n-1$），我们可以用整数 $k(0 \\le k < n)$ 表示字符串 $S$ 的后缀 $S(k \\sim n-1)$。\n\n把字符串 $S$ 的所有后缀按照字典序排列，排名为 $i$ 的后缀记为 SA[i]。\n\n额外地，我们考虑排名为 $i$ 的后缀与排名为 $i-1$ 的后缀，把二者的最长公共前缀的长度记为 Height[i]。\n\n我们的任务就是求出 SA 与 Height 这两个数组。", "inputFormat": "输入一个字符串，其长度不超过 $30$ 万。\n\n字符串由小写字母构成。", "outputFormat": "第一行为数组 SA，相邻两个整数用 $1$ 个空格隔开。\n\n第二行为数组 Height，相邻两个整数用 $1$ 个空格隔开，我们规定 Height[1]=0。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "后缀数组", "background": "", "description": "后缀数组 (SA) 是一种重要的数据结构，通常使用倍增或者 DC3 算法实现，这超出了我们的讨论范围。\n\n在本题中，我们希望使用快排、Hash 与二分实现一个简单的 $O(n\\log^2n)$ 的后缀数组求法。\n\n详细地说，给定一个长度为 $n$ 的字符串 $S$（下标 $0 \\sim n-1$），我们可以用整数 $k(0 \\le k < n)$ 表示字符串 $S$ 的后缀 $S(k \\sim n-1)$。\n\n把字符串 $S$ 的所有后缀按照字典序排列，排名为 $i$ 的后缀记为 SA[i]。\n\n额外地，我们考虑排名为 $i$ 的后缀与排名为 $i-1$ 的后缀，把二者的最长公共前缀的长度记为 Height[i]。\n\n我们的任务就是求出 SA 与 Height 这两个数组。", "inputFormat": "输入一个字符串，其长度不超过 $30$ 万。\n\n字符串由小写字母构成。", "outputFormat": "第一行为数组 SA，相邻两个整数用 $1$ 个空格隔开。\n\n第二行为数组 Height，相邻两个整数用 $1$ 个空格隔开，我们规定 Height[1]=0。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10470", "type": "P", "difficulty": 3, "samples": [["3 2\nab\nbc\nabc\nabc\nefg", "2\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["字典树 Trie"], "title": "前缀统计", "background": null, "description": "给定 $N$ 个字符串 $S_1,S_2,\\cdots,S_N$，接下来进行 $M$ 次询问，每次询问给定一个字符串 $T$，求 $S_1 \\sim S_N$ 中有多少个字符串是 $T$ 的前缀。\n\n输入字符串的总长度不超过 $10^6$，仅包含小写字母。", "inputFormat": "第一行输入两个整数 $N,M$。\n\n接下来 $N$ 行每行输入一个字符串 $S_i$。\n\n接下来 $M$ 行每行一个字符串 $T$ 用以询问。", "outputFormat": "对于每个询问，输出一个整数表示答案。\n\n每个答案占一行。", "hint": "数据范围满足 $1 \\le N,M \\le 10^5$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "前缀统计", "background": null, "description": "给定 $N$ 个字符串 $S_1,S_2,\\cdots,S_N$，接下来进行 $M$ 次询问，每次询问给定一个字符串 $T$，求 $S_1 \\sim S_N$ 中有多少个字符串是 $T$ 的前缀。\n\n输入字符串的总长度不超过 $10^6$，仅包含小写字母。", "inputFormat": "第一行输入两个整数 $N,M$。\n\n接下来 $N$ 行每行输入一个字符串 $S_i$。\n\n接下来 $M$ 行每行一个字符串 $T$ 用以询问。", "outputFormat": "对于每个询问，输出一个整数表示答案。\n\n每个答案占一行。", "hint": "数据范围满足 $1 \\le N,M \\le 10^5$", "locale": "zh-CN"}}}
{"pid": "P10471", "type": "P", "difficulty": 3, "samples": [["3\n1 2 3", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["字典树 Trie"], "title": "最大异或对 The XOR Largest Pair", "background": null, "description": "给定 $N$ 个整数 $A_1.A_2, \\cdots, A_N$ 中选出两个进行异或计算，得到的结果最大是多少？", "inputFormat": "第一行一个整数 $N$，第二行 $N$ 个整数 $A_1.A_2, \\cdots, A_N$。", "outputFormat": "一个整数表示答案。", "hint": "对于所有测试数据，$1 \\le N \\le 10^5$，保证 $0\\le A_i<2^{31}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "最大异或对 The XOR Largest Pair", "background": null, "description": "给定 $N$ 个整数 $A_1.A_2, \\cdots, A_N$ 中选出两个进行异或计算，得到的结果最大是多少？", "inputFormat": "第一行一个整数 $N$，第二行 $N$ 个整数 $A_1.A_2, \\cdots, A_N$。", "outputFormat": "一个整数表示答案。", "hint": "对于所有测试数据，$1 \\le N \\le 10^5$，保证 $0\\le A_i<2^{31}$。", "locale": "zh-CN"}}}
