{"pid": "P12935", "type": "P", "difficulty": 3, "samples": [["BBWWBB", "3"], ["BWWB", "0"], ["BBWBB", "0"], ["OOOWWW", "0"], ["WWWOOOOOOWWW", "7"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "ICPC", "NERC/NEERC"], "title": "[NERC 2019] Balls of Buma", "background": "", "description": "Balph is learning to play a game called Buma. In this game, he is given a row of colored balls. He has to choose the color of one new ball and the place to insert it (between two balls, or to the left of all the balls, or to the right of all the balls).\n\nWhen the ball is inserted the following happens repeatedly: if some segment of balls of the same color became longer as a result of a previous action and its length became at least $3$, then all the balls of this segment are eliminated. \n\nConsider, for example, a row of balls $\\tt{AAABBBWWBB}$. Suppose Balph chooses a ball of color $\\tt{W}$ and the place to insert it after the sixth ball, i.e. to the left of the two $\\tt{W}$ s. After Balph inserts this ball, the balls of color $\\tt{W}$ are eliminated, since this segment was made longer and has length $3$ now, so the row becomes $\\texttt{AAABBBBB}$. The balls of color $\\tt{B}$ are eliminated now, because the segment of balls of color $\\tt{B}$ became longer and has length $5$ now. Thus, the row becomes $\\texttt{AAA}$. However, none of the balls are eliminated now, because there is no elongated segment.\n\nHelp Balph count the number of possible ways to choose a color of a new ball and a place to insert it that leads to the elimination of all the balls.", "inputFormat": "The only line contains a non-empty string of uppercase English letters of length at most $3 \\cdot 10^5$. Each letter represents a ball with the corresponding color.", "outputFormat": "Output the number of ways to choose a color and a position of a new ball in order to eliminate all the balls.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2019] Balls of Buma", "background": "", "description": "Balph is learning to play a game called Buma. In this game, he is given a row of colored balls. He has to choose the color of one new ball and the place to insert it (between two balls, or to the left of all the balls, or to the right of all the balls).\n\nWhen the ball is inserted the following happens repeatedly: if some segment of balls of the same color became longer as a result of a previous action and its length became at least $3$, then all the balls of this segment are eliminated. \n\nConsider, for example, a row of balls $\\tt{AAABBBWWBB}$. Suppose Balph chooses a ball of color $\\tt{W}$ and the place to insert it after the sixth ball, i.e. to the left of the two $\\tt{W}$ s. After Balph inserts this ball, the balls of color $\\tt{W}$ are eliminated, since this segment was made longer and has length $3$ now, so the row becomes $\\texttt{AAABBBBB}$. The balls of color $\\tt{B}$ are eliminated now, because the segment of balls of color $\\tt{B}$ became longer and has length $5$ now. Thus, the row becomes $\\texttt{AAA}$. However, none of the balls are eliminated now, because there is no elongated segment.\n\nHelp Balph count the number of possible ways to choose a color of a new ball and a place to insert it that leads to the elimination of all the balls.", "inputFormat": "The only line contains a non-empty string of uppercase English letters of length at most $3 \\cdot 10^5$. Each letter represents a ball with the corresponding color.", "outputFormat": "Output the number of ways to choose a color and a position of a new ball in order to eliminate all the balls.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2019] Balls of Buma", "background": "", "description": "Balph 正在学习玩一款名为 Buma 的游戏。在这个游戏中，他会得到一排彩色球。他需要选择一个新球的颜色以及插入的位置（在两个球之间、所有球的左侧或所有球的右侧）。\n\n当球被插入后，以下情况会反复发生：如果某个颜色相同的球段由于之前的操作变长，并且其长度达到至少 $3$，那么该球段的所有球都会被消除。\n\n例如，考虑一排球 $\\tt{AAABBBWWBB}$。假设 Balph 选择了一个颜色为 $\\tt{W}$ 的球，并将其插入到第六个球之后，即两个 $\\tt{W}$ 的左侧。在 Balph 插入这个球后，$\\tt{W}$ 颜色的球段变长，长度变为 $3$，因此这些球会被消除，此时球排变为 $\\texttt{AAABBBBB}$。接着，$\\tt{B}$ 颜色的球段变长，长度变为 $5$，因此这些球也会被消除，球排变为 $\\texttt{AAA}$。此时没有球段再被拉长，因此消除过程结束。\n\n请帮助 Balph 计算有多少种选择新球颜色和插入位置的方式，可以导致所有球被消除。", "inputFormat": "仅一行，包含一个长度不超过 $3 \\cdot 10^5$ 的非空字符串，由大写英文字母组成。每个字母代表一个对应颜色的球。\n", "outputFormat": "输出选择新球颜色和插入位置的方式数，使得所有球被消除。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12936", "type": "P", "difficulty": 7, "samples": [["5\n2 2 3 2 1", "4\n2 1 2\n2 2 3\n2 3 1\n3 3 4 5"], ["4\n3 3 2 2", "-1"], ["6\n1 2 1 1 2 1", "-1"], ["15\n1 4 3 2 2 2 2 2 4 4 2 2 2 2 2", "3\n9 1 2 3 4 5 6 7 8 3\n7 2 9 10 11 12 13 10\n5 2 14 9 15 10"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2019] Cactus Revenge", "background": "", "description": "NE(E)RC featured a number of problems in previous years about cactuses --- connected undirected graphs in which every edge belongs to at most one simple cycle. Intuitively, a $\\textit{cactus}$ is a generalization of a tree where some cycles are allowed. The traditional cactus that was initially used in NEERC 2005 problem is given on the second picture in the Examples section.\n\nYou are given $n$ integers $d_1, d_2, \\ldots, d_n$. Construct any cactus with $n$ vertices such that vertex $i$ has degree $d_i$ (i.e. exactly $d_i$ incident edges), or determine that no such cactus exists. Parallel edges and loops are not allowed.", "inputFormat": "The first line contains a single integer $n$ ($2 \\le n \\le 2\\,000$) --- the number of vertices in the cactus.\n\nThe second line contains $n$ integers $d_1, d_2, \\ldots, d_n$ ($1 \\le d_i \\le n-1$) --- the desired vertex degrees.", "outputFormat": "If it's impossible to construct a cactus satisfying the conditions, output a single integer $-1$.\n\nOtherwise, by tradition, output the constructed cactus as a set of edge-distinct paths.\n\nIn the first line output an integer $m$ --- the number of such paths. Each of the following $m$ lines should contain a path in the graph. A path should start with an integer $k_i$ ($k_i \\ge 2$) followed by $k_i$ integers from $1$ to $n$. These $k_i$ integers should represent consecutive vertices of this path. Adjacent vertices in the path should be distinct. The path can visit the same vertex multiple times, but every edge of the cactus should be traversed exactly once in the whole output. ", "hint": "**Sample 1**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bsskq1wa.png)\n\n**Sample 4**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/et4kgcwn.png)\n\nBoth in the second and the third example, there exist graphs that satisfy the given conditions but none of them are cactuses.", "locale": "en", "translations": {"en": {"title": "[NERC 2019] Cactus Revenge", "background": "", "description": "NE(E)RC featured a number of problems in previous years about cactuses --- connected undirected graphs in which every edge belongs to at most one simple cycle. Intuitively, a $\\textit{cactus}$ is a generalization of a tree where some cycles are allowed. The traditional cactus that was initially used in NEERC 2005 problem is given on the second picture in the Examples section.\n\nYou are given $n$ integers $d_1, d_2, \\ldots, d_n$. Construct any cactus with $n$ vertices such that vertex $i$ has degree $d_i$ (i.e. exactly $d_i$ incident edges), or determine that no such cactus exists. Parallel edges and loops are not allowed.", "inputFormat": "The first line contains a single integer $n$ ($2 \\le n \\le 2\\,000$) --- the number of vertices in the cactus.\n\nThe second line contains $n$ integers $d_1, d_2, \\ldots, d_n$ ($1 \\le d_i \\le n-1$) --- the desired vertex degrees.", "outputFormat": "If it's impossible to construct a cactus satisfying the conditions, output a single integer $-1$.\n\nOtherwise, by tradition, output the constructed cactus as a set of edge-distinct paths.\n\nIn the first line output an integer $m$ --- the number of such paths. Each of the following $m$ lines should contain a path in the graph. A path should start with an integer $k_i$ ($k_i \\ge 2$) followed by $k_i$ integers from $1$ to $n$. These $k_i$ integers should represent consecutive vertices of this path. Adjacent vertices in the path should be distinct. The path can visit the same vertex multiple times, but every edge of the cactus should be traversed exactly once in the whole output. ", "hint": "**Sample 1**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bsskq1wa.png)\n\n**Sample 4**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/et4kgcwn.png)\n\nBoth in the second and the third example, there exist graphs that satisfy the given conditions but none of them are cactuses.", "locale": "en"}, "zh-CN": {"title": "[NERC 2019] Cactus Revenge", "background": "", "description": "在往年的 NE(E)RC 竞赛中，曾多次出现关于仙人掌（cactus）的问题——这是一种连通无向图，其中每条边最多属于一个简单环。直观地说，仙人掌是树的推广，允许存在某些环。NEERC 2005 年题目中使用的传统仙人掌示例见样例部分的第二张图。\n\n给定 $n$ 个整数 $d_1, d_2, \\ldots, d_n$。请构造一个具有 $n$ 个顶点的仙人掌，使得顶点 $i$ 的度数为 $d_i$（即恰好有 $d_i$ 条相连的边），或者判定这样的仙人掌不存在。图中不允许出现平行边或自环。", "inputFormat": "第一行包含一个整数 $n$（$2 \\le n \\le 2\\,000$）——仙人掌的顶点数。\n\n第二行包含 $n$ 个整数 $d_1, d_2, \\ldots, d_n$（$1 \\le d_i \\le n-1$）——每个顶点期望的度数。\n", "outputFormat": "如果无法构造满足条件的仙人掌，输出一个整数 $-1$。\n\n否则，按照传统方式，将构造的仙人掌以边不重复的路径集合形式输出。\n\n第一行输出一个整数 $m$——路径的数量。接下来的 $m$ 行，每行描述一条路径。路径应以一个整数 $k_i$（$k_i \\ge 2$）开头，后跟 $k_i$ 个 $1$ 到 $n$ 的整数。这些整数表示路径中连续的顶点。路径中相邻顶点必须不同。路径可以多次访问同一顶点，但仙人掌的每条边在整个输出中必须恰好被遍历一次。\n", "hint": "**样例 1**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bsskq1wa.png)\n\n**样例 4**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/et4kgcwn.png)\n\n在第二个和第三个样例中，虽然存在满足给定度数的图，但它们都不是仙人掌。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12937", "type": "P", "difficulty": 6, "samples": [["3\n1 1 1\n1 0 1\n1 1 1\n1 1 1\n0 0 0\n1 0 1", "Possible\n1 1 1\n2\n3 2\n1 3"], ["2\n1 1 1\n0 0 1\n1 1 1\n1 1 0", "Impossible"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2019] DevOps Best Practices", "background": "", "description": "Daisy is a senior software engineer at RainyDay, LLC. She has just implemented three new features in their product: the first feature makes their product work, the second one makes their product fast, and the third one makes their product correct.\nThe company encourages at least some testing of new features, so Daisy appointed her intern Demid to write some tests for the new features.\n\nInterestingly enough, these three features pass all the tests on Demid's development server, which has index 1, but might fail the tests on some other servers.\n\nAfter Demid has completed this task, Daisy appointed you to deploy these three features to all $n$~servers of your company. For every feature $f$ and every server $s$, Daisy told you whether she wants the feature $f$ to be deployed on the server $s$. If she wants it to be deployed, it must be done even if the feature $f$ fails the tests on the server $s$. If she does not want it to be deployed, you may not deploy it there.\n\nYour company has two important instruments for the deployment of new features to servers: Continuous Deployment (CD) and Continuous Testing (CT). CD can be established between several pairs of servers, forming a directed graph. CT can be set up on some set of servers.\n\nIf CD is configured from the server $s_1$ to the server $s_2$ then every time $s_1$ receives a new feature $f$ the system starts the following deployment process of $f$ to $s_2$:\n\n- If the feature $f$ is already deployed on the server $s_2$, then nothing is done.\n- Otherwise, if CT is not set up on the server $s_1$, then the server $s_1$ just deploys the feature $f$ to the server $s_2$ without any testing.\n- Otherwise, the server $s_1$ runs tests for the feature $f$. If the tests fail on the server $s_1$, nothing is done. If the tests pass, then the server $s_1$ deploys the feature $f$ to the server $s_2$. \n\nYou are to configure the CD/CT system, and after that Demid will deploy all three features on his development server. Your CD/CT system must deploy each feature exactly to the set of servers that Daisy wants.\n\nYour company does not have a lot of computing resources, so you can establish CD from one server to another at most $264$ times.", "inputFormat": "The first line contains integer $n$ ($2 \\le n \\le 256$) --- the number of servers in your company.\n\nNext $n$ lines contain three integers each. The $j$-th integer in the $i$-th line is $1$ if Daisy wants the $j$-th feature to be deployed to the $i$-th server, or $0$ otherwise.\n\nNext $n$ lines contain three integers each. The $j$-th integer in the $i$-th line is $1$ if tests pass for the $j$-th feature on the $i$-th server, or $0$ otherwise.\n\nDemid's development server has index $1$. It is guaranteed that Daisy wants all three features to be deployed to the server number 1, and all three features pass their tests on the server number 1.", "outputFormat": "If it is impossible to configure CD/CT system with CD being set up between at most $264$ pairs of servers, then output the single line  $\\texttt{Impossible}$.\n\nOtherwise, the first line of the output must contain the line $\\texttt{Possible}$.\n\nNext line must contain $n$ space-separated integers --- the configuration of CT. The $i$-th integer should be $1$ if you set up CT on the $i$-th server, or $0$ otherwise.\n\nNext line must contain the integer $m$ ($0 \\le m \\le 264$) --- the number of CD pairs you want to set up.\n\nEach of the next $m$ lines must describe CD configuration, each line with two integers $s_i$ and $t_i$ ($1 \\le s_i, t_i \\le n$; $s_i \\ne t_i$), establishing automated deployment of new features from the server $s_i$ to the server $t_i$.", "hint": "CD/CT system for the first sample test is shown below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/stnjo553.png)", "locale": "en", "translations": {"en": {"title": "[NERC 2019] DevOps Best Practices", "background": "", "description": "Daisy is a senior software engineer at RainyDay, LLC. She has just implemented three new features in their product: the first feature makes their product work, the second one makes their product fast, and the third one makes their product correct.\nThe company encourages at least some testing of new features, so Daisy appointed her intern Demid to write some tests for the new features.\n\nInterestingly enough, these three features pass all the tests on Demid's development server, which has index 1, but might fail the tests on some other servers.\n\nAfter Demid has completed this task, Daisy appointed you to deploy these three features to all $n$~servers of your company. For every feature $f$ and every server $s$, Daisy told you whether she wants the feature $f$ to be deployed on the server $s$. If she wants it to be deployed, it must be done even if the feature $f$ fails the tests on the server $s$. If she does not want it to be deployed, you may not deploy it there.\n\nYour company has two important instruments for the deployment of new features to servers: Continuous Deployment (CD) and Continuous Testing (CT). CD can be established between several pairs of servers, forming a directed graph. CT can be set up on some set of servers.\n\nIf CD is configured from the server $s_1$ to the server $s_2$ then every time $s_1$ receives a new feature $f$ the system starts the following deployment process of $f$ to $s_2$:\n\n- If the feature $f$ is already deployed on the server $s_2$, then nothing is done.\n- Otherwise, if CT is not set up on the server $s_1$, then the server $s_1$ just deploys the feature $f$ to the server $s_2$ without any testing.\n- Otherwise, the server $s_1$ runs tests for the feature $f$. If the tests fail on the server $s_1$, nothing is done. If the tests pass, then the server $s_1$ deploys the feature $f$ to the server $s_2$. \n\nYou are to configure the CD/CT system, and after that Demid will deploy all three features on his development server. Your CD/CT system must deploy each feature exactly to the set of servers that Daisy wants.\n\nYour company does not have a lot of computing resources, so you can establish CD from one server to another at most $264$ times.", "inputFormat": "The first line contains integer $n$ ($2 \\le n \\le 256$) --- the number of servers in your company.\n\nNext $n$ lines contain three integers each. The $j$-th integer in the $i$-th line is $1$ if Daisy wants the $j$-th feature to be deployed to the $i$-th server, or $0$ otherwise.\n\nNext $n$ lines contain three integers each. The $j$-th integer in the $i$-th line is $1$ if tests pass for the $j$-th feature on the $i$-th server, or $0$ otherwise.\n\nDemid's development server has index $1$. It is guaranteed that Daisy wants all three features to be deployed to the server number 1, and all three features pass their tests on the server number 1.", "outputFormat": "If it is impossible to configure CD/CT system with CD being set up between at most $264$ pairs of servers, then output the single line  $\\texttt{Impossible}$.\n\nOtherwise, the first line of the output must contain the line $\\texttt{Possible}$.\n\nNext line must contain $n$ space-separated integers --- the configuration of CT. The $i$-th integer should be $1$ if you set up CT on the $i$-th server, or $0$ otherwise.\n\nNext line must contain the integer $m$ ($0 \\le m \\le 264$) --- the number of CD pairs you want to set up.\n\nEach of the next $m$ lines must describe CD configuration, each line with two integers $s_i$ and $t_i$ ($1 \\le s_i, t_i \\le n$; $s_i \\ne t_i$), establishing automated deployment of new features from the server $s_i$ to the server $t_i$.", "hint": "CD/CT system for the first sample test is shown below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/stnjo553.png)", "locale": "en"}, "zh-CN": {"title": "[NERC 2019] DevOps Best Practices", "background": "", "description": "**Daisy** 是 RainyDay 公司的一名高级软件工程师。她刚刚为产品实现了三个新功能：第一个功能使产品能够运行，第二个功能使产品运行得更快，第三个功能使产品运行得更正确。公司鼓励对新功能进行至少一些测试，因此 Daisy 指派她的实习生 **Demid** 为这些新功能编写测试用例。\n\n有趣的是，这三个功能在 Demid 的开发服务器（编号为 1）上通过了所有测试，但在其他某些服务器上可能会测试失败。\n\nDemid 完成任务后，Daisy 指派你将这三个功能部署到公司的所有 $n$ 台服务器上。对于每个功能 $f$ 和每台服务器 $s$，Daisy 会告诉你她是否希望将功能 $f$ 部署到服务器 $s$ 上。如果她希望部署，即使功能 $f$ 在服务器 $s$ 上测试失败也必须部署；如果她不希望部署，则不能部署。\n\n公司有两种重要的部署工具：持续部署（CD）和持续测试（CT）。CD 可以在多对服务器之间建立有向图形式的连接，而 CT 可以配置在某些服务器上。\n\n如果从服务器 $s_1$ 到服务器 $s_2$ 配置了 CD，那么每当 $s_1$ 接收到新功能 $f$ 时，系统会启动以下部署流程将 $f$ 部署到 $s_2$：\n\n1. 如果功能 $f$ 已经部署在服务器 $s_2$ 上，则不进行任何操作。\n2. 否则，如果服务器 $s_1$ 未配置 CT，则 $s_1$ 会直接将功能 $f$ 部署到 $s_2$，不进行测试。\n3. 否则，服务器 $s_1$ 会对功能 $f$ 运行测试。如果测试失败，则不进行任何操作；如果测试通过，则将功能 $f$ 部署到 $s_2$。\n\n你需要配置 CD/CT 系统，之后 Demid 会将所有三个功能部署到他的开发服务器上。你的 CD/CT 系统必须确保每个功能仅被部署到 Daisy 指定的服务器集合。\n\n由于公司计算资源有限，你最多只能建立 $264$ 条 CD 连接。", "inputFormat": "第一行包含一个整数 $n$（$2 \\le n \\le 256$）——公司服务器的数量。\n\n接下来的 $n$ 行，每行包含三个整数。第 $i$ 行的第 $j$ 个整数为 $1$ 表示 Daisy 希望将第 $j$ 个功能部署到第 $i$ 台服务器，否则为 $0$。\n\n再接下来的 $n$ 行，每行包含三个整数。第 $i$ 行的第 $j$ 个整数为 $1$ 表示第 $j$ 个功能在第 $i$ 台服务器上测试通过，否则为 $0$。\n\nDemid 的开发服务器编号为 $1$。数据保证 Daisy 希望将所有三个功能部署到服务器 1，且所有三个功能在服务器 1 上测试通过。", "outputFormat": "如果无法在最多建立 $264$ 条 CD 连接的情况下配置 CD/CT 系统，则输出一行 `Impossible`。\n\n否则，输出的第一行应为 `Possible`。\n\n第二行应包含 $n$ 个用空格分隔的整数——CT 的配置。第 $i$ 个整数为 $1$ 表示你在第 $i$ 台服务器上设置了 CT，否则为 $0$。\n\n第三行应包含一个整数 $m$（$0 \\le m \\le 264$）——你设置的 CD 连接数量。\n\n接下来的 $m$ 行，每行描述一条 CD 连接，包含两个整数 $s_i$ 和 $t_i$（$1 \\le s_i, t_i \\le n$；$s_i \\ne t_i$），表示从服务器 $s_i$ 到服务器 $t_i$ 建立了自动部署通道。", "hint": "第一个样例测试的 CD/CT 系统配置如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/stnjo553.png)\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12938", "type": "P", "difficulty": 4, "samples": [["5 3\n6 3 4 2 8\n3 7 5 6 7\n5 2 4 7 9", "2\n3 1"], ["2 1\n1 1", "0"], ["3 3\n2 3 8\n4 2 9\n3 1 7", "3\n1 2 3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2019", "Special Judge", "枚举", "排序", "ICPC", "NERC/NEERC"], "title": "[NERC 2019] Elections", "background": "", "description": "Byteburg Senate elections are coming. Usually \"United Byteland\", the ruling Byteland party, takes all the seats in the Senate to ensure stability and sustainable development. But this year there is one opposition candidate in one of the constituencies. Even one opposition member can disturb the stability in the Senate, so the head of the Party asks you to ensure that the opposition candidate will not be elected.\n\nThere are $n$ candidates, numbered from 1 to $n$. Candidate $n$ is the opposition candidate. There are $m$ polling stations in the constituency, numbered from 1 to $m$. You know the number of votes cast for each candidate at each polling station. The only thing you can do to prevent the election of the opposition candidate is to cancel the election results at some polling stations. The opposition candidate will be elected if the sum of the votes cast in their favor at all non-canceled stations will be **strictly greater** than the analogous sum for every other candidate. \n\nYour task is to prevent the election of the opposition candidate by canceling the election results at the minimal possible number of polling stations. Notice that solution always exists, because if you cancel the elections at all polling stations, the number of votes for each candidate will be 0, and the opposition candidate will not be elected.", "inputFormat": "The first line of the input contains two integers $n$ and $m$ ($2\\le n\\le 100$; $1\\le m \\le 100$) --- the number of candidates and the number of polling stations. The next $m$ lines contain the election results at each polling station with $n$ numbers on each line. In the $i$-th line the $j$-th number is $a_{i,j}$ --- the number of votes cast for the candidate $j$ at the station $i$ ($0\\le a_{i,j} \\le 1\\,000$).", "outputFormat": "In the first line output integer $k$ --- the minimal number of the polling stations in which you need to cancel the election results. In the second line output $k$ integers --- the indices of canceled polling stations, in any order. If there are multiple ways to cancel results at $k$ stations, output any one of them.", "hint": "In the first example, the candidates from 1 to 5 received 14, 12, 13, 15, and 24 votes correspondingly. The opposition candidate has the most votes. However, if you cancel the election results at the first and the third polling stations, then only the result from the second polling station remains and the vote sums become 3, 7, 5, 6, and 7, without the opposition candidate being in the lead anymore. ", "locale": "en", "translations": {"en": {"title": "[NERC 2019] Elections", "background": "", "description": "Byteburg Senate elections are coming. Usually \"United Byteland\", the ruling Byteland party, takes all the seats in the Senate to ensure stability and sustainable development. But this year there is one opposition candidate in one of the constituencies. Even one opposition member can disturb the stability in the Senate, so the head of the Party asks you to ensure that the opposition candidate will not be elected.\n\nThere are $n$ candidates, numbered from 1 to $n$. Candidate $n$ is the opposition candidate. There are $m$ polling stations in the constituency, numbered from 1 to $m$. You know the number of votes cast for each candidate at each polling station. The only thing you can do to prevent the election of the opposition candidate is to cancel the election results at some polling stations. The opposition candidate will be elected if the sum of the votes cast in their favor at all non-canceled stations will be **strictly greater** than the analogous sum for every other candidate. \n\nYour task is to prevent the election of the opposition candidate by canceling the election results at the minimal possible number of polling stations. Notice that solution always exists, because if you cancel the elections at all polling stations, the number of votes for each candidate will be 0, and the opposition candidate will not be elected.", "inputFormat": "The first line of the input contains two integers $n$ and $m$ ($2\\le n\\le 100$; $1\\le m \\le 100$) --- the number of candidates and the number of polling stations. The next $m$ lines contain the election results at each polling station with $n$ numbers on each line. In the $i$-th line the $j$-th number is $a_{i,j}$ --- the number of votes cast for the candidate $j$ at the station $i$ ($0\\le a_{i,j} \\le 1\\,000$).", "outputFormat": "In the first line output integer $k$ --- the minimal number of the polling stations in which you need to cancel the election results. In the second line output $k$ integers --- the indices of canceled polling stations, in any order. If there are multiple ways to cancel results at $k$ stations, output any one of them.", "hint": "In the first example, the candidates from 1 to 5 received 14, 12, 13, 15, and 24 votes correspondingly. The opposition candidate has the most votes. However, if you cancel the election results at the first and the third polling stations, then only the result from the second polling station remains and the vote sums become 3, 7, 5, 6, and 7, without the opposition candidate being in the lead anymore. ", "locale": "en"}, "zh-CN": {"title": "[NERC 2019] Elections", "background": "", "description": "Byteland 参议院选举即将到来。通常情况下，执政党“联合 Byteland”会占据参议院所有席位以确保稳定和可持续发展。但今年有一个选区出现了一名反对派候选人。即使只有一名反对派成员也可能扰乱参议院的稳定，因此党首要求你确保这名反对派候选人不会当选。\n\n共有 $n$ 名候选人，编号从 1 到 $n$。候选人 $n$ 是反对派候选人。该选区有 $m$ 个投票站，编号从 1 到 $m$。你已知每个投票站中每位候选人的得票数。为了防止反对派候选人当选，你唯一能做的就是取消部分投票站的选举结果。如果反对派候选人在所有未被取消的投票站中获得的**总票数严格大于**其他每位候选人的总票数，则该候选人将当选。\n\n你的任务是通过取消尽可能少数量的投票站的选举结果，阻止反对派候选人当选。注意，解决方案一定存在，因为如果取消所有投票站的选举结果，每位候选人的得票数将为 0，反对派候选人将不会当选。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $m$（$2 \\le n \\le 100$；$1 \\le m \\le 100$）——候选人数量和投票站数量。接下来的 $m$ 行包含每个投票站的选举结果，每行有 $n$ 个数字。第 $i$ 行的第 $j$ 个数字是 $a_{i,j}$——投票站 $i$ 中候选人 $j$ 的得票数（$0 \\le a_{i,j} \\le 1\\,000$）。\n", "outputFormat": "第一行输出整数 $k$——需要取消选举结果的投票站的最小数量。第二行输出 $k$ 个整数——被取消的投票站的编号，顺序任意。如果有多种取消 $k$ 个投票站的方案，输出其中任意一种即可。\n", "hint": "在第一个示例中，编号 1 至 5 的候选人分别获得了 14、12、13、15 和 24 票。反对派候选人的票数最多。然而，如果取消第一个和第三个投票站的选举结果，则仅保留第二个投票站的结果，此时总票数变为 3、7、5、6 和 7，反对派候选人不再领先。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12939", "type": "P", "difficulty": 6, "samples": [["4 5 4 2\n1 3 3 4\n7 8", "Yes\n1 5\n1 6\n2 7\n6 3\n3 7\n9 4\n3 8\n4 8"], ["4 3 3 1\n3 2 2\n6", "No"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "Special Judge", "ICPC", "Prüfer 序列", "NERC/NEERC"], "title": "[NERC 2019] Foolprüf Security", "background": "", "description": "Alice and Bob obtained a map of the secret underground facility. The facility consists of $n$ $\\emph{security units}$ and $m$ $\\emph{chemical labs}$, connected by bidirectional tunnels. The map of this facility forms a $\\emph{tree}$: there are exactly $n + m - 1$ tunnels, and there are no cycles. Vertices corresponding to security units have numbers from $1$ to $n$, chemical labs have numbers from $n+1$ to $n+m$. Each tunnel connects a security unit to a chemical lab; there are no tunnels between two security units or two chemical labs.\n\nIn case Alice or Bob gets captured, they decided to split the map into two pieces. To do that, they calculated the $\\emph{Prüfer code}$ of the tree. Alice then saved some of the numbers between $1$ and $n$ to her data storage in the same order as they go in the original code, and Bob saved some of the numbers from $n+1$ to $n+m$ to his storage in the same way.\n\nA Prüfer code of a tree on $k$ vertices is a sequence of $k - 2$ integers from $1$ to $k$, constructed as follows. Find the leaf (a vertex with degree one) with the smallest label, remove it from the tree, then print the label of its only neighbor. Repeat this $k - 3$ more times, until only one edge remains. The printed sequence of $k - 2$ vertex labels is the Prüfer code.\n\nAlice and Bob safely returned and they are ready to combine their data to restore the original map. They could make a mistake during the backup, meaning no such map exists. Alice and Bob need your help to restore any possible map of the facility consistent with the collected data, so that both Alice's and Bob's parts are subsequences of the Prüfer code of the map.", "inputFormat": "The first line of the input contains four integers $n$, $m$, $k_a$, and $k_b$ ($2 \\le n, m \\le 10^5$; $1 \\le k_a, k_b$; $k_a + k_b \\le n + m - 2$).\nThe second line contains $k_a$ integers $a_1, a_2, \\ldots, a_{k_a}$ ($1 \\le a_i \\le n$) --- Alice's part of the map.\nThe third line contains $k_b$ integers $b_1, b_2, \\ldots, b_{k_b}$ ($n + 1 \\le b_i \\le n + m$) --- Bob's part of the map.", "outputFormat": "If there's no such map, print $\\tt{No}$.\n\nOtherwise, print $\\tt{Yes}$ on the first line, followed by $n + m - 1$ lines describing the possible facility map. Each line should contain two integers $u_i$ and $v_i$ --- the security unit and the chemical lab connected by the $i$-th tunnel of the facility.", "hint": "The Prüfer code of the tree in the first example is $(\\underline{7}, \\mathbf{1}, 6, \\mathbf{3}, \\mathbf{3}, \\underline{8}, \\mathbf{4})$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6z6yk20m.png)", "locale": "en", "translations": {"en": {"title": "[NERC 2019] Foolprüf Security", "background": "", "description": "Alice and Bob obtained a map of the secret underground facility. The facility consists of $n$ $\\emph{security units}$ and $m$ $\\emph{chemical labs}$, connected by bidirectional tunnels. The map of this facility forms a $\\emph{tree}$: there are exactly $n + m - 1$ tunnels, and there are no cycles. Vertices corresponding to security units have numbers from $1$ to $n$, chemical labs have numbers from $n+1$ to $n+m$. Each tunnel connects a security unit to a chemical lab; there are no tunnels between two security units or two chemical labs.\n\nIn case Alice or Bob gets captured, they decided to split the map into two pieces. To do that, they calculated the $\\emph{Prüfer code}$ of the tree. Alice then saved some of the numbers between $1$ and $n$ to her data storage in the same order as they go in the original code, and Bob saved some of the numbers from $n+1$ to $n+m$ to his storage in the same way.\n\nA Prüfer code of a tree on $k$ vertices is a sequence of $k - 2$ integers from $1$ to $k$, constructed as follows. Find the leaf (a vertex with degree one) with the smallest label, remove it from the tree, then print the label of its only neighbor. Repeat this $k - 3$ more times, until only one edge remains. The printed sequence of $k - 2$ vertex labels is the Prüfer code.\n\nAlice and Bob safely returned and they are ready to combine their data to restore the original map. They could make a mistake during the backup, meaning no such map exists. Alice and Bob need your help to restore any possible map of the facility consistent with the collected data, so that both Alice's and Bob's parts are subsequences of the Prüfer code of the map.", "inputFormat": "The first line of the input contains four integers $n$, $m$, $k_a$, and $k_b$ ($2 \\le n, m \\le 10^5$; $1 \\le k_a, k_b$; $k_a + k_b \\le n + m - 2$).\nThe second line contains $k_a$ integers $a_1, a_2, \\ldots, a_{k_a}$ ($1 \\le a_i \\le n$) --- Alice's part of the map.\nThe third line contains $k_b$ integers $b_1, b_2, \\ldots, b_{k_b}$ ($n + 1 \\le b_i \\le n + m$) --- Bob's part of the map.", "outputFormat": "If there's no such map, print $\\tt{No}$.\n\nOtherwise, print $\\tt{Yes}$ on the first line, followed by $n + m - 1$ lines describing the possible facility map. Each line should contain two integers $u_i$ and $v_i$ --- the security unit and the chemical lab connected by the $i$-th tunnel of the facility.", "hint": "The Prüfer code of the tree in the first example is $(\\underline{7}, \\mathbf{1}, 6, \\mathbf{3}, \\mathbf{3}, \\underline{8}, \\mathbf{4})$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6z6yk20m.png)", "locale": "en"}, "zh-CN": {"title": "[NERC 2019] Foolprüf Security", "background": "", "description": "Alice 和 Bob 获得了一份秘密地下设施的地图。该设施由 $n$ 个**安全单元**和 $m$ 个**化学实验室**组成，通过双向隧道连接。该设施的地图构成一棵**树**：共有 $n + m - 1$ 条隧道，且不存在环路。安全单元对应的顶点编号为 $1$ 至 $n$，化学实验室的编号为 $n+1$ 至 $n+m$。每条隧道连接一个安全单元和一个化学实验室；不存在连接两个安全单元或两个化学实验室的隧道。\n\n为了防止 Alice 或 Bob 被捕，他们决定将地图分成两部分。为此，他们计算了这棵树的 **Prüfer 编码**。Alice 随后将原始编码中 $1$ 至 $n$ 的部分数字按顺序保存到她的数据存储中，Bob 则保存了 $n+1$ 至 $n+m$ 的部分数字，同样按原始编码的顺序存储。\n\n一棵 $k$ 个顶点的树的 Prüfer 编码是一个长度为 $k - 2$ 的序列，其中每个数字的取值范围是 $1$ 至 $k$，构造方式如下：找到标号最小的叶子节点（度数为 1 的顶点），将其从树中移除，并记录其唯一邻居的标号。重复此过程 $k - 3$ 次，直到只剩一条边。记录的 $k - 2$ 个顶点标号序列即为 Prüfer 编码。\n\nAlice 和 Bob 安全返回后，准备将他们的数据合并以恢复原始地图。但他们在备份时可能出错，导致不存在符合条件的地图。他们需要你的帮助来恢复任意一种可能的地图，使得 Alice 和 Bob 保存的部分都是该地图 Prüfer 编码的子序列。\n", "inputFormat": "输入的第一行包含四个整数 $n$、$m$、$k_a$ 和 $k_b$（$2 \\le n, m \\le 10^5$；$1 \\le k_a, k_b$；$k_a + k_b \\le n + m - 2$）。  \n第二行包含 $k_a$ 个整数 $a_1, a_2, \\ldots, a_{k_a}$（$1 \\le a_i \\le n$）——Alice 保存的地图部分。  \n第三行包含 $k_b$ 个整数 $b_1, b_2, \\ldots, b_{k_b}$（$n + 1 \\le b_i \\le n + m$）——Bob 保存的地图部分。\n", "outputFormat": "如果不存在符合条件的地图，输出 $\\tt{No}$。\n\n否则，第一行输出 $\\tt{Yes}$，随后输出 $n + m - 1$ 行描述可能的地图。每行包含两个整数 $u_i$ 和 $v_i$，表示设施的第 $i$ 条隧道连接的安全单元和化学实验室。\n", "hint": "第一个示例中树的 Prüfer 编码为 $(\\underline{7}, \\mathbf{1}, 6, \\mathbf{3}, \\mathbf{3}, \\underline{8}, \\mathbf{4})$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6z6yk20m.png)\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12940", "type": "P", "difficulty": 7, "samples": [["2 20\n25 100", "47.50000000000000000"], ["4 30\n60 50 60 80", "171.25000000000000000"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2019] Game Relics", "background": "", "description": "Esports is a form of competitive sports using video games. \nDota 2 is one of the most popular competitive video games in Esports. Recently, a new video game Dota 3 was released. In Dota 3 a player can buy some relics for their hero. Relics are counters that track hero's actions and statistics in a game.\n\nGloria likes to play Dota 3, so she wants to buy all $n$ available relics for her favorite hero.\n\nRelics can be bought using an in-game currency called shards. Each relic has its own price --- $c_i$ shards for the $i$-th relic. A player can buy a relic using one of the following options:\n- Pay $c_i$ shards to buy the $i$-th relic;\n- Pay $x$ shards and randomly get one of all $n$ relics. The probability of getting a relic is the same for all $n$ relics. If a duplicate relic is received, then the relic is recycled and $\\frac{x}{2}$ shards are given back to the player.\n\nGloria wants to buy all $n$ relics. Help her minimize the expected number of shards she spends to buy all the relics.", "inputFormat": "The first line contains two integers $n$ and $x$ ($1 \\le n \\le 100$; $1 \\le x \\le 10\\,000$) --- the number of relics and the cost to receive a random relic.\n\nThe second line consists of $n$ integers $c_1, c_2, \\ldots, c_n$ ($x \\le c_i \\le 10\\,000$; $\\sum{c_i} \\le 10\\,000$) --- the prices of $n$ relics.", "outputFormat": "Print a single real number --- the minimum expected number of shards that Gloria must spend to buy all the relics.\n\nThe absolute or relative error should not exceed $10^{-9}$.", "hint": "In the first example, the optimal strategy is to randomly get one of the two relics paying $20$ shards. Then there are two scenarios. \n\nThe first one happens if Gloria receives the first relic. Then she keeps getting random relics until she obtains the second relic. The expected number of shards to spend in this scenario is $20 + 30 = 50$.\n\nIn the second scenario, Gloria initially gets the second relic. Then it is better to buy the first relic for $25$ shards, so the expected number of shards to spend in this scenario is $20 + 25 = 45$.\n\nThus, the expected number of shards to spend is $\\frac{50 + 45}{2} = 47.5$.", "locale": "en", "translations": {"en": {"title": "[NERC 2019] Game Relics", "background": "", "description": "Esports is a form of competitive sports using video games. \nDota 2 is one of the most popular competitive video games in Esports. Recently, a new video game Dota 3 was released. In Dota 3 a player can buy some relics for their hero. Relics are counters that track hero's actions and statistics in a game.\n\nGloria likes to play Dota 3, so she wants to buy all $n$ available relics for her favorite hero.\n\nRelics can be bought using an in-game currency called shards. Each relic has its own price --- $c_i$ shards for the $i$-th relic. A player can buy a relic using one of the following options:\n- Pay $c_i$ shards to buy the $i$-th relic;\n- Pay $x$ shards and randomly get one of all $n$ relics. The probability of getting a relic is the same for all $n$ relics. If a duplicate relic is received, then the relic is recycled and $\\frac{x}{2}$ shards are given back to the player.\n\nGloria wants to buy all $n$ relics. Help her minimize the expected number of shards she spends to buy all the relics.", "inputFormat": "The first line contains two integers $n$ and $x$ ($1 \\le n \\le 100$; $1 \\le x \\le 10\\,000$) --- the number of relics and the cost to receive a random relic.\n\nThe second line consists of $n$ integers $c_1, c_2, \\ldots, c_n$ ($x \\le c_i \\le 10\\,000$; $\\sum{c_i} \\le 10\\,000$) --- the prices of $n$ relics.", "outputFormat": "Print a single real number --- the minimum expected number of shards that Gloria must spend to buy all the relics.\n\nThe absolute or relative error should not exceed $10^{-9}$.", "hint": "In the first example, the optimal strategy is to randomly get one of the two relics paying $20$ shards. Then there are two scenarios. \n\nThe first one happens if Gloria receives the first relic. Then she keeps getting random relics until she obtains the second relic. The expected number of shards to spend in this scenario is $20 + 30 = 50$.\n\nIn the second scenario, Gloria initially gets the second relic. Then it is better to buy the first relic for $25$ shards, so the expected number of shards to spend in this scenario is $20 + 25 = 45$.\n\nThus, the expected number of shards to spend is $\\frac{50 + 45}{2} = 47.5$.", "locale": "en"}, "zh-CN": {"title": "[NERC 2019] Game Relics", "background": "", "description": "电子竞技是一种使用电子游戏进行的竞技运动。Dota 2 是电子竞技中最受欢迎的竞技游戏之一。最近，一款新游戏 Dota 3 发布了。在 Dota 3 中，玩家可以为自己的英雄购买一些**圣物**。圣物是用于追踪英雄在游戏中行为和统计数据的计数器。\n\nGloria 喜欢玩 Dota 3，因此她想为她最喜欢的英雄购买所有 $n$ 件可用的圣物。\n\n圣物可以使用游戏内货币\"碎片\"购买。每件圣物都有自己的价格——第 $i$ 件圣物需要 $c_i$ 碎片。玩家可以通过以下两种方式购买圣物：\n- 支付 $c_i$ 碎片直接购买第 $i$ 件圣物；\n- 支付 $x$ 碎片随机获得所有 $n$ 件圣物中的一件。每件圣物被获得的概率相同。如果获得重复的圣物，则该圣物会被回收，并返还 $\\frac{x}{2}$ 碎片给玩家。\n\nGloria 想要购买所有 $n$ 件圣物。请帮助她最小化购买所有圣物所需的期望碎片数量。", "inputFormat": "第一行包含两个整数 $n$ 和 $x$（$1 \\le n \\le 100$；$1 \\le x \\le 10\\,000$）——圣物的数量和随机获取一件圣物的花费。\n\n第二行包含 $n$ 个整数 $c_1, c_2, \\ldots, c_n$（$x \\le c_i \\le 10\\,000$；$\\sum{c_i} \\le 10\\,000$）——$n$ 件圣物的价格。\n", "outputFormat": "输出一个实数——Gloria 购买所有圣物所需的最小期望碎片数量。\n\n绝对误差或相对误差不应超过 $10^{-9}$。", "hint": "在第一个示例中，最优策略是先花费 $20$ 碎片随机获取两件圣物中的一件。之后会出现两种情况：\n\n第一种情况是 Gloria 获得了第一件圣物。然后她需要继续随机获取圣物，直到获得第二件圣物。这种情况下的期望花费是 $20 + 30 = 50$ 碎片。\n\n第二种情况是 Gloria 一开始就获得了第二件圣物。这时最好直接花费 $25$ 碎片购买第一件圣物，因此这种情况下的期望花费是 $20 + 25 = 45$ 碎片。\n\n因此，总的期望花费为 $\\frac{50 + 45}{2} = 47.5$ 碎片。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12941", "type": "P", "difficulty": 7, "samples": [["5\n3\n1 3 2\n3\n1 2 3\n1\n1\n10\n6 10 4 2 7 9 5 8 3 1\n10\n2 4 6 9 1 8 10 5 3 7", "1 3 2\n10 20 10\n1\n2 3 4 5 3 1 3 5 4 2\n1 2 3 4 5 6 7 8 9 10"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2019] Help BerLine", "background": "", "description": "Very soon, the new cell phone services provider \"BerLine\" will begin its work in Berland!\n\nThe start of customer service is planned along the main street of the capital. There are $n$ base stations that are already installed. They are located one after another along the main street in the order from the $1$-st to the $n$-th from left to right. \n\nCurrently, all these base stations are turned off. They will be turned on one by one, one base station per day, according to some permutation $p = [p_1, p_2, \\dots, p_n]$ ($ 1 \\le p_i \\le n$), where $p_i$ is the index of a base station that will be turned on on the $i$-th day. Thus, it will take $n$ days to turn on all base stations.\n\nEach base station is characterized by its operating frequency $f_i$ --- an integer between $1$ and $24$, inclusive.\n\nThere is an important requirement for operating frequencies of base stations. Consider an arbitrary moment in time. For any phone owner, if we consider all base stations turned on in the access area of their phone, then in this set of base stations there should be at least one whose operating frequency is unique among the frequencies of these stations. Since the power of the phone and the position are not known in advance, this means that for any nonempty subsegment of turned on base stations, at least one of them has to have the operating frequency that is unique among the stations of this subsegment.\n\nFor example, let's take a look at a case of $n = 7$, all $n$ stations are turned on, and their frequencies are equal to $f = [1, 2, 1, 3, 1, 2, 1]$. Consider any subsegment of the base stations --- there is a base station with a unique frequency within this subsegment. However, if $f = [1, 2, 1, 2, 3, 2, 1]$, then there is no unique frequency on the segment $[1, 2, 1, 2]$ from the index $1$ to the index $4$, inclusive.\n\nYour task is to assign a frequency from $1$ to $24$ to each of $n$ base stations in such a way that the frequency requirement is met at every moment. Remember that the base stations are turned on in the order of the given permutation $p$.", "inputFormat": "The first line of the input contains an integer $t$ ($1 \\le t \\le 50$)~--- the number of test cases in the input. Then $t$ test case descriptions follow.\n\nThe first line of a test case contains an integer $n$ ($ 1 \\le n \\le 8\\,500$) --- the number of \"BerLine\" base stations.\n\nThe following line contains $n$ distinct integers $p_1, p_2, \\dots, p_n$ ($1 \\le p_i \\le n$) --- the order in which the base stations are turned on, i.e. on the $i$-th day the base station with the index $p_i$ is turned on.\n\nIt is guaranteed that a correct answer exists for all test cases in the input.", "outputFormat": "The first line of the input contains an integer $t$ ($1 \\le t \\le 50$)~--- the number of test cases in the input. Then $t$ test case descriptions follow.\n\nThe first line of a test case contains an integer $n$ ($ 1 \\le n \\le 8\\,500$) --- the number of \"BerLine\" base stations.\n\nThe following line contains $n$ distinct integers $p_1, p_2, \\dots, p_n$ ($1 \\le p_i \\le n$) --- the order in which the base stations are turned on, i.e. on the $i$-th day the base station with the index $p_i$ is turned on.\n\nIt is guaranteed that a correct answer exists for all test cases in the input.", "hint": "In the first test case $n = 3$ and $p = [1, 3, 2]$. The base stations can be assigned frequencies $[1, 3, 2]$.\n\n- Day 1: only the base station $1$ is turned on, its frequency is $1$.\n- Day 2: the base stations $1$ and $3$ are turned on, their frequencies are $[1, 2]$.\n- Day 3: all base stations are turned on, their frequencies are $[1, 3, 2]$ (in the direction along the street).\n\nOn each day, each nonempty subsegment of turned on base stations has a base station with a unique frequency among this subsegment. It can be shown that three distinct frequencies are necessary in this test case.", "locale": "en", "translations": {"en": {"title": "[NERC 2019] Help BerLine", "background": "", "description": "Very soon, the new cell phone services provider \"BerLine\" will begin its work in Berland!\n\nThe start of customer service is planned along the main street of the capital. There are $n$ base stations that are already installed. They are located one after another along the main street in the order from the $1$-st to the $n$-th from left to right. \n\nCurrently, all these base stations are turned off. They will be turned on one by one, one base station per day, according to some permutation $p = [p_1, p_2, \\dots, p_n]$ ($ 1 \\le p_i \\le n$), where $p_i$ is the index of a base station that will be turned on on the $i$-th day. Thus, it will take $n$ days to turn on all base stations.\n\nEach base station is characterized by its operating frequency $f_i$ --- an integer between $1$ and $24$, inclusive.\n\nThere is an important requirement for operating frequencies of base stations. Consider an arbitrary moment in time. For any phone owner, if we consider all base stations turned on in the access area of their phone, then in this set of base stations there should be at least one whose operating frequency is unique among the frequencies of these stations. Since the power of the phone and the position are not known in advance, this means that for any nonempty subsegment of turned on base stations, at least one of them has to have the operating frequency that is unique among the stations of this subsegment.\n\nFor example, let's take a look at a case of $n = 7$, all $n$ stations are turned on, and their frequencies are equal to $f = [1, 2, 1, 3, 1, 2, 1]$. Consider any subsegment of the base stations --- there is a base station with a unique frequency within this subsegment. However, if $f = [1, 2, 1, 2, 3, 2, 1]$, then there is no unique frequency on the segment $[1, 2, 1, 2]$ from the index $1$ to the index $4$, inclusive.\n\nYour task is to assign a frequency from $1$ to $24$ to each of $n$ base stations in such a way that the frequency requirement is met at every moment. Remember that the base stations are turned on in the order of the given permutation $p$.", "inputFormat": "The first line of the input contains an integer $t$ ($1 \\le t \\le 50$)~--- the number of test cases in the input. Then $t$ test case descriptions follow.\n\nThe first line of a test case contains an integer $n$ ($ 1 \\le n \\le 8\\,500$) --- the number of \"BerLine\" base stations.\n\nThe following line contains $n$ distinct integers $p_1, p_2, \\dots, p_n$ ($1 \\le p_i \\le n$) --- the order in which the base stations are turned on, i.e. on the $i$-th day the base station with the index $p_i$ is turned on.\n\nIt is guaranteed that a correct answer exists for all test cases in the input.", "outputFormat": "The first line of the input contains an integer $t$ ($1 \\le t \\le 50$)~--- the number of test cases in the input. Then $t$ test case descriptions follow.\n\nThe first line of a test case contains an integer $n$ ($ 1 \\le n \\le 8\\,500$) --- the number of \"BerLine\" base stations.\n\nThe following line contains $n$ distinct integers $p_1, p_2, \\dots, p_n$ ($1 \\le p_i \\le n$) --- the order in which the base stations are turned on, i.e. on the $i$-th day the base station with the index $p_i$ is turned on.\n\nIt is guaranteed that a correct answer exists for all test cases in the input.", "hint": "In the first test case $n = 3$ and $p = [1, 3, 2]$. The base stations can be assigned frequencies $[1, 3, 2]$.\n\n- Day 1: only the base station $1$ is turned on, its frequency is $1$.\n- Day 2: the base stations $1$ and $3$ are turned on, their frequencies are $[1, 2]$.\n- Day 3: all base stations are turned on, their frequencies are $[1, 3, 2]$ (in the direction along the street).\n\nOn each day, each nonempty subsegment of turned on base stations has a base station with a unique frequency among this subsegment. It can be shown that three distinct frequencies are necessary in this test case.", "locale": "en"}, "zh-CN": {"title": "[NERC 2019] Help BerLine", "background": "", "description": "很快，新的手机服务提供商 **BerLine** 将在 Berland 开始运营！\n\n客户服务的启动计划沿着首都的主街进行。已经有 $n$ 个基站安装完毕，它们沿着主街从左到右依次排列，编号从 $1$ 到 $n$。\n\n目前，所有这些基站都处于关闭状态。它们将按照某个排列 $p = [p_1, p_2, \\dots, p_n]$（$1 \\le p_i \\le n$）依次开启，每天开启一个基站，其中 $p_i$ 表示第 $i$ 天开启的基站编号。因此，开启所有基站需要 $n$ 天时间。\n\n每个基站都有一个工作频率 $f_i$ —— 这是一个介于 $1$ 到 $24$ 之间的整数。\n\n对于基站的工作频率有一个重要要求：考虑任意时刻，对于任何手机用户，如果查看其手机信号覆盖范围内所有已开启的基站，那么在这些基站中至少有一个的工作频率在该组基站中是唯一的。由于手机的信号强度和用户位置事先未知，这意味着对于任何非空的已开启基站子段，其中至少有一个基站的工作频率在该子段中是唯一的。\n\n例如，假设 $n = 7$，所有基站都已开启，且其频率为 $f = [1, 2, 1, 3, 1, 2, 1]$。对于任意子段，该子段内都存在一个频率唯一的基站。但如果 $f = [1, 2, 1, 2, 3, 2, 1]$，则子段 $[1, 2, 1, 2]$（从第 $1$ 个到第 $4$ 个基站）中没有频率是唯一的。\n\n你的任务是为每个基站分配一个 $1$ 到 $24$ 之间的频率，使得在任意时刻（按照给定排列 $p$ 开启基站的过程中）都满足上述频率要求。", "inputFormat": "输入的第一行包含一个整数 $t$（$1 \\le t \\le 50$）—— 测试用例的数量。接下来是 $t$ 个测试用例的描述。\n\n每个测试用例的第一行包含一个整数 $n$（$1 \\le n \\le 8\\,500$）—— **BerLine** 基站的数量。\n\n第二行包含 $n$ 个不同的整数 $p_1, p_2, \\dots, p_n$（$1 \\le p_i \\le n$）—— 基站开启的顺序，即第 $i$ 天开启编号为 $p_i$ 的基站。\n\n保证所有测试用例都存在正确的解。", "outputFormat": "对于每个测试用例，输出一行 $n$ 个整数 $f_1, f_2, \\dots, f_n$（$1 \\le f_i \\le 24$）—— 分配给每个基站的工作频率。如果有多个解，输出任意一个即可。\n", "hint": "在第一个测试用例中，$n = 3$，$p = [1, 3, 2]$。可以给基站分配频率 $[1, 3, 2]$。\n\n- 第 1 天：只有基站 $1$ 开启，其频率为 $1$。\n- 第 2 天：基站 $1$ 和 $3$ 开启，频率为 $[1, 2]$。\n- 第 3 天：所有基站开启，频率为 $[1, 3, 2]$（沿街道方向排列）。\n\n在每一天，任何非空的已开启基站子段中都有一个频率唯一的基站。可以证明，在这个测试用例中必须使用三个不同的频率。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12942", "type": "P", "difficulty": 6, "samples": [["2\n3\n\n>\n\n<\n\n>\n\n<\n\n>\n\n>\n\n3\n\n<\n\n<\n\n<\n\n>\n\n>\n", "\n\n? 1 3\n\n? 4 2\n\n? 4 5\n\n? 6 5\n\n? 3 4\n\n? 5 6\n\n!\n\n? 3 4\n\n? 4 2\n\n? 5 3\n\n? 6 4\n\n? 3 1\n\n!"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "交互题", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2019] Intriguing Selection", "background": "", "description": "$\\emph{This is an interactive problem.}$\n\nYou are the head coach of a chess club. The club has $2n$ players, each player has some $\\emph{strength}$ which can be represented by a number, and all those numbers are distinct. The strengths of the players are not known to you.\n\nYou need to select $n$ players who would represent your club in the upcoming championship. Naturally, you want to select $n$ players with the highest strengths.\n\nYou can organize matches between the players to do that. In every match, you pick two players, they play some games, and you learn which one of the two has higher strength. You can wait for the outcome of a match before deciding who will participate in the next one.\n\nHowever, you do not want to know $\\emph{exactly}$ how those $n$ players compare between themselves, as that would make the championship itself less $\\emph{intriguing}$. More formally, you must reach a state where there is exactly one way to choose $n$ players with the highest strengths that is consistent with the outcomes of the matches you organized, but there must be at least two possible orderings of those $n$ players by strength that are consistent with the outcomes of the matches you organized.\n\n### Interaction Protocol\n\nYour program has to process multiple test cases in one run. First, it should read the integer $t$ ($t \\ge 1$) --- the number of test cases. Then, it should process the test cases one by one.\n\nIn each test case, your program should start by reading the integer $n$ ($3 \\le n \\le 100$) --- the number of players to select out of $2n$ players. The sum of squares of the values of $n$ over all test cases does not exceed $10\\,000$.\n\nThen your program can organize matches zero or more times. To organize a match, your program should print a match description formatted as $\\tt{?\\ i\\ j}$ --- a question mark followed by two distinct numbers of players participating in the match. The players are numbered from 1 to $2n$, inclusive. Remember to flush the output after printing the match description. Then your program should read the match outcome --- it will be either the greater-than character ($\\tt{>}$), if the first player in the match description has higher strength, or the less-than character ($\\tt{<}$), if the second player in the match description has higher strength.\n\nYour program can organize at most $4n^2$ matches. After it is done organizing matches, it should print the exclamation mark ($\\tt{!}$) and continue to the next test case, or exit gracefully if this was the last test case. Remember to flush the output after printing the exclamation mark.\n\nThere must be exactly one way to choose $n$ players with the highest strength that is consistent with the outcomes of the matches you organized, but there must be at least two possible orderings of those $n$ players by their strength that are consistent with the outcomes of the matches you organized.\n\nThe judging program picks some distinct numbers as the strengths of all players before your program starts organizing matches and uses them to answer the requests.", "inputFormat": "See Interaction Protocol", "outputFormat": "See Interaction Protocol", "hint": "In the example, the players in the first test case are sorted by strength in decreasing order. From the matches in the example output, we can deduce that players 1, 2, and 3 have the highest strength, but we do not know how the player 1 compares to the player 2.", "locale": "en", "translations": {"en": {"title": "[NERC 2019] Intriguing Selection", "background": "", "description": "$\\emph{This is an interactive problem.}$\n\nYou are the head coach of a chess club. The club has $2n$ players, each player has some $\\emph{strength}$ which can be represented by a number, and all those numbers are distinct. The strengths of the players are not known to you.\n\nYou need to select $n$ players who would represent your club in the upcoming championship. Naturally, you want to select $n$ players with the highest strengths.\n\nYou can organize matches between the players to do that. In every match, you pick two players, they play some games, and you learn which one of the two has higher strength. You can wait for the outcome of a match before deciding who will participate in the next one.\n\nHowever, you do not want to know $\\emph{exactly}$ how those $n$ players compare between themselves, as that would make the championship itself less $\\emph{intriguing}$. More formally, you must reach a state where there is exactly one way to choose $n$ players with the highest strengths that is consistent with the outcomes of the matches you organized, but there must be at least two possible orderings of those $n$ players by strength that are consistent with the outcomes of the matches you organized.\n\n### Interaction Protocol\n\nYour program has to process multiple test cases in one run. First, it should read the integer $t$ ($t \\ge 1$) --- the number of test cases. Then, it should process the test cases one by one.\n\nIn each test case, your program should start by reading the integer $n$ ($3 \\le n \\le 100$) --- the number of players to select out of $2n$ players. The sum of squares of the values of $n$ over all test cases does not exceed $10\\,000$.\n\nThen your program can organize matches zero or more times. To organize a match, your program should print a match description formatted as $\\tt{?\\ i\\ j}$ --- a question mark followed by two distinct numbers of players participating in the match. The players are numbered from 1 to $2n$, inclusive. Remember to flush the output after printing the match description. Then your program should read the match outcome --- it will be either the greater-than character ($\\tt{>}$), if the first player in the match description has higher strength, or the less-than character ($\\tt{<}$), if the second player in the match description has higher strength.\n\nYour program can organize at most $4n^2$ matches. After it is done organizing matches, it should print the exclamation mark ($\\tt{!}$) and continue to the next test case, or exit gracefully if this was the last test case. Remember to flush the output after printing the exclamation mark.\n\nThere must be exactly one way to choose $n$ players with the highest strength that is consistent with the outcomes of the matches you organized, but there must be at least two possible orderings of those $n$ players by their strength that are consistent with the outcomes of the matches you organized.\n\nThe judging program picks some distinct numbers as the strengths of all players before your program starts organizing matches and uses them to answer the requests.", "inputFormat": "See Interaction Protocol", "outputFormat": "See Interaction Protocol", "hint": "In the example, the players in the first test case are sorted by strength in decreasing order. From the matches in the example output, we can deduce that players 1, 2, and 3 have the highest strength, but we do not know how the player 1 compares to the player 2.", "locale": "en"}, "zh-CN": {"title": "[NERC 2019] Intriguing Selection", "background": "", "description": "**这是一道交互题。**\n\n你是一家国际象棋俱乐部的总教练。俱乐部共有 $2n$ 名选手，每位选手都有一个独特的**实力值**（用数字表示），但这些实力值对你来说是未知的。\n\n你需要从中选出 $n$ 名选手代表俱乐部参加即将到来的锦标赛。自然，你希望选出实力最强的 $n$ 名选手。\n\n为此，你可以组织选手之间的比赛。每场比赛你需要选择两名选手进行对决，之后你会知道两人中谁的实力更强。你可以根据比赛结果来决定下一场比赛的参与者。\n\n但你不希望**完全**了解这 $n$ 名选手之间的具体实力排名，因为那样会让锦标赛本身变得不够**引人入胜**。更正式地说，你需要达到这样一种状态：根据已进行的比赛结果，恰好存在一种方式可以选出实力最强的 $n$ 名选手，但同时这些选手之间至少存在两种不同的实力排名顺序与比赛结果一致。\n\n### 交互协议\n\n你的程序需要处理多个测试用例。首先读取整数 $t$（$t \\ge 1$）表示测试用例数量，然后依次处理每个测试用例。\n\n在每个测试用例中：\n1. 首先读取整数 $n$（$3 \\le n \\le 100$），表示需要从 $2n$ 名选手中选出 $n$ 名。所有测试用例的 $n$ 的平方和不超过 $10\\,000$。\n2. 然后可以组织若干场比赛。要组织比赛，需要输出格式为 `? i j` 的指令（问号后跟两个不同的选手编号）。选手编号为 $1$ 到 $2n$。输出后需要刷新输出缓冲区。\n3. 之后读取比赛结果：`>` 表示第一个选手更强，`<` 表示第二个选手更强。\n4. 最多可以组织 $4n^2$ 场比赛。结束后输出 `!` 并处理下一个测试用例（或结束程序）。输出 `!` 后也需要刷新输出缓冲区。\n\n最终必须满足：\n- 根据比赛结果，恰好有一种方式可以选出实力最强的 $n$ 名选手\n- 但这些选手之间至少存在两种可能的实力排名顺序与比赛结果一致\n\n评测系统会在程序开始前为所有选手分配不同的实力值，并根据这些值回答比赛结果。", "inputFormat": "参见交互协议。", "outputFormat": "参见交互协议。", "hint": "在第一个测试用例中，选手按实力降序排列。根据示例中的比赛结果可以确定选手 1、2、3 是最强的三人，但我们无法确定选手 1 和 2 之间的具体强弱关系。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12943", "type": "P", "difficulty": 4, "samples": [["3\n11\n1 5 1 5 1 5 1 1 1 1 5\n6\n1 2 2 2 2 1\n5\n4 3 3 1 2", "3\n3\n4"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "ICPC", "NERC/NEERC"], "title": "[NERC 2019] Just Arrange the Icons", "background": "", "description": "BerPhone X is almost ready for release with $n$ applications being preinstalled on the phone. A $\\textit{category}$ of an application characterizes a genre or a theme of this application (like \"game\", \"business\", or \"education\"). The categories are given as integers between $1$ and $n$, inclusive; the $i$-th application has category $c_i$. \n\nYou can choose $m$ --- the number of screens and $s$ --- the size of each screen. You need to fit all $n$ icons of the applications (one icon representing one application) meeting the following requirements:\n\n- On each screen, all the icons must belong to applications of the same category (but different screens can contain icons of applications of the same category);\n- Each screen must be either completely filled with icons (the number of icons on the screen is equal to $s$) or almost filled with icons (the number of icons is equal to $s-1$).\n\nYour task is to find the minimal possible number of screens $m$.", "inputFormat": "The first line contains an integer $t$ ($1 \\le t \\le 10\\,000$) --- the number of test cases in the input. Then $t$ test cases follow.\n\nThe first line of each test case contains an integer $n$ ($1 \\le n \\le 2\\cdot10^6$) --- the number of the icons. The second line contains $n$ integers $c_1, c_2, \\dots, c_n$ ($1 \\le c_i \\le n$), where $c_i$ is the category of the $i$-th application.\n\nIt is guaranteed that the sum of the values of $n$ for all test cases in the input does not exceed $2\\cdot 10^6$.", "outputFormat": "Print $t$ integers --- the answers to the given test cases in the order they follow in the input. The answer to a test case is an integer $m$ --- the minimum number of screens on which all $n$ icons can be placed satisfying the given requirements.", "hint": "In the first test case of the example, all the icons can be placed on three screens of size $4$: a screen with $4$ icons of the category $1$, a screen with $3$ icons of the category $1$, and a screen with $4$ icons of the category $5$.", "locale": "en", "translations": {"en": {"title": "[NERC 2019] Just Arrange the Icons", "background": "", "description": "BerPhone X is almost ready for release with $n$ applications being preinstalled on the phone. A $\\textit{category}$ of an application characterizes a genre or a theme of this application (like \"game\", \"business\", or \"education\"). The categories are given as integers between $1$ and $n$, inclusive; the $i$-th application has category $c_i$. \n\nYou can choose $m$ --- the number of screens and $s$ --- the size of each screen. You need to fit all $n$ icons of the applications (one icon representing one application) meeting the following requirements:\n\n- On each screen, all the icons must belong to applications of the same category (but different screens can contain icons of applications of the same category);\n- Each screen must be either completely filled with icons (the number of icons on the screen is equal to $s$) or almost filled with icons (the number of icons is equal to $s-1$).\n\nYour task is to find the minimal possible number of screens $m$.", "inputFormat": "The first line contains an integer $t$ ($1 \\le t \\le 10\\,000$) --- the number of test cases in the input. Then $t$ test cases follow.\n\nThe first line of each test case contains an integer $n$ ($1 \\le n \\le 2\\cdot10^6$) --- the number of the icons. The second line contains $n$ integers $c_1, c_2, \\dots, c_n$ ($1 \\le c_i \\le n$), where $c_i$ is the category of the $i$-th application.\n\nIt is guaranteed that the sum of the values of $n$ for all test cases in the input does not exceed $2\\cdot 10^6$.", "outputFormat": "Print $t$ integers --- the answers to the given test cases in the order they follow in the input. The answer to a test case is an integer $m$ --- the minimum number of screens on which all $n$ icons can be placed satisfying the given requirements.", "hint": "In the first test case of the example, all the icons can be placed on three screens of size $4$: a screen with $4$ icons of the category $1$, a screen with $3$ icons of the category $1$, and a screen with $4$ icons of the category $5$.", "locale": "en"}, "zh-CN": {"title": "[NERC 2019] Just Arrange the Icons", "background": "", "description": "BerPhone X 即将发布，手机预装了 $n$ 个应用程序。每个应用程序都有一个**类别**，用于描述该应用的类型或主题（如\"游戏\"、\"商业\"或\"教育\"）。类别用 $1$ 到 $n$ 之间的整数表示，第 $i$ 个应用程序的类别为 $c_i$。\n\n你需要选择两个参数：\n- $m$ —— 屏幕数量\n- $s$ —— 每个屏幕的容量\n\n要求将所有 $n$ 个应用图标（每个图标代表一个应用）按照以下规则排列：\n\n1. 同一屏幕上的所有图标必须属于同一类别的应用（不同屏幕可以包含同一类别的图标）；\n2. 每个屏幕必须要么完全填满图标（图标数量等于 $s$），要么几乎填满（图标数量等于 $s-1$）。\n\n你的任务是找出满足条件的最小屏幕数量 $m$。", "inputFormat": "第一行包含一个整数 $t$（$1 \\le t \\le 10\\,000$）—— 测试用例的数量。随后是 $t$ 个测试用例。\n\n每个测试用例的第一行包含一个整数 $n$（$1 \\le n \\le 2 \\cdot 10^6$）—— 图标数量。第二行包含 $n$ 个整数 $c_1, c_2, \\dots, c_n$（$1 \\le c_i \\le n$），其中 $c_i$ 表示第 $i$ 个应用的类别。\n\n保证所有测试用例的 $n$ 之和不超过 $2 \\cdot 10^6$。", "outputFormat": "输出 $t$ 个整数 —— 按输入顺序给出每个测试用例的答案。每个答案是一个整数 $m$，表示满足条件所需的最小屏幕数量。\n", "hint": "在第一个测试用例中，所有图标可以排列在 3 个容量为 4 的屏幕上：\n- 1 个屏幕放置 4 个类别 1 的图标\n- 1 个屏幕放置 3 个类别 1 的图标\n- 1 个屏幕放置 4 个类别 5 的图标\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12944", "type": "P", "difficulty": 0, "samples": [["3\n1\n11\n123456", "0\n1\n127"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "ICPC", "NERC/NEERC"], "title": "[NERC 2019] Key Storage", "background": "", "description": "Karl is developing a key storage service. Each user has a positive integer key.\n\nKarl knows that storing keys in plain text is bad practice. So, instead of storing a key, he decided to store a fingerprint of a key. However, using some existing fingerprint algorithm looked too boring to him, so he invented his own one.\n\nKarl's fingerprint is calculated by the following process: divide the given integer by 2, then divide the result by 3, then divide the result by 4, and so on, until we get a result that equals zero (we are speaking about integer division each time). \nThe fingerprint is defined as the multiset of the remainders of these divisions. \n\nFor example, this is how Karl's fingerprint algorithm is applied to the key 11: 11 divided by 2 has remainder 1 and result 5, then 5 divided by 3 has remainder 2 and result 1, and 1 divided by 4 has remainder 1 and result 0. Thus, the key 11 produces the sequence of remainders $[1, 2, 1]$ and has the fingerprint multiset $\\{1, 1, 2\\}$.\n\nKsenia wants to prove that Karl's fingerprint algorithm is not very good. For example, she found that both keys 178800 and 123456 produce the fingerprint of $\\{0, 0, 0, 0, 2, 3, 3, 4\\}$. Thus, users are at risk of fingerprint collision with some commonly used and easy to guess keys like 123456.\n\nKsenia wants to make her words more persuasive. She wants to calculate the number of other keys that have the same fingerprint as the keys in the given list of some commonly used keys. Your task is to help her.", "inputFormat": "The first line contains an integer $t$ ($1 \\le t \\le 50\\,000$) --- the number of commonly used keys to examine. \nEach of the next $t$ lines contains one integer $k_i$ ($1 \\le k_i \\le 10^{18}$) --- the key itself. ", "outputFormat": "For each of the keys print one integer --- the number of other keys that have the same fingerprint. ", "hint": "The other key with the same fingerprint as 11 is 15. 15 produces a sequence of remainders $[1, 1, 2]$. So both numbers have the fingerprint multiset $\\{1, 1, 2\\}$.", "locale": "en", "translations": {"en": {"title": "[NERC 2019] Key Storage", "background": "", "description": "Karl is developing a key storage service. Each user has a positive integer key.\n\nKarl knows that storing keys in plain text is bad practice. So, instead of storing a key, he decided to store a fingerprint of a key. However, using some existing fingerprint algorithm looked too boring to him, so he invented his own one.\n\nKarl's fingerprint is calculated by the following process: divide the given integer by 2, then divide the result by 3, then divide the result by 4, and so on, until we get a result that equals zero (we are speaking about integer division each time). \nThe fingerprint is defined as the multiset of the remainders of these divisions. \n\nFor example, this is how Karl's fingerprint algorithm is applied to the key 11: 11 divided by 2 has remainder 1 and result 5, then 5 divided by 3 has remainder 2 and result 1, and 1 divided by 4 has remainder 1 and result 0. Thus, the key 11 produces the sequence of remainders $[1, 2, 1]$ and has the fingerprint multiset $\\{1, 1, 2\\}$.\n\nKsenia wants to prove that Karl's fingerprint algorithm is not very good. For example, she found that both keys 178800 and 123456 produce the fingerprint of $\\{0, 0, 0, 0, 2, 3, 3, 4\\}$. Thus, users are at risk of fingerprint collision with some commonly used and easy to guess keys like 123456.\n\nKsenia wants to make her words more persuasive. She wants to calculate the number of other keys that have the same fingerprint as the keys in the given list of some commonly used keys. Your task is to help her.", "inputFormat": "The first line contains an integer $t$ ($1 \\le t \\le 50\\,000$) --- the number of commonly used keys to examine. \nEach of the next $t$ lines contains one integer $k_i$ ($1 \\le k_i \\le 10^{18}$) --- the key itself. ", "outputFormat": "For each of the keys print one integer --- the number of other keys that have the same fingerprint. ", "hint": "The other key with the same fingerprint as 11 is 15. 15 produces a sequence of remainders $[1, 1, 2]$. So both numbers have the fingerprint multiset $\\{1, 1, 2\\}$.", "locale": "en"}, "zh-CN": {"title": "[NERC 2019] Key Storage", "background": "", "description": "Karl 正在开发一个密钥存储服务。每个用户都有一个正整数密钥。\n\nKarl 知道明文存储密钥是不安全的做法。因此，他决定不直接存储密钥，而是存储密钥的**指纹**。不过他觉得使用现有的指纹算法太无聊了，于是自己发明了一种新的算法。\n\nKarl 的指纹算法计算过程如下：\n1. 将给定的整数除以 2（整数除法）\n2. 将结果除以 3\n3. 继续除以 4\n4. 依此类推，直到结果为 0\n指纹定义为这些除法运算产生的余数组成的**多重集**。\n\n例如，对密钥 11 应用该算法：\n- 11 ÷ 2 = 5 余 1\n- 5 ÷ 3 = 1 余 2\n- 1 ÷ 4 = 0 余 1\n因此密钥 11 产生的余数序列是 $[1, 2, 1]$，指纹多重集为 $\\{1, 1, 2\\}$。\n\nKsenia 想证明 Karl 的指纹算法并不完善。例如她发现密钥 178800 和 123456 都会产生相同的指纹 $\\{0, 0, 0, 0, 2, 3, 3, 4\\}$。这意味着像 123456 这样常用且容易猜测的密钥可能会与其他密钥产生指纹冲突。\n\nKsenia 想用更有说服力的数据来证明这一点。她需要计算与给定常用密钥列表中的密钥具有相同指纹的其他密钥数量。你的任务就是帮助她完成这个计算。", "inputFormat": "第一行包含一个整数 $t$（$1 \\le t \\le 50\\,000$）—— 需要检查的常用密钥数量。\n接下来的 $t$ 行，每行包含一个整数 $k_i$（$1 \\le k_i \\le 10^{18}$）—— 密钥值。\n", "outputFormat": "对于每个密钥，输出一个整数 —— 与该密钥具有相同指纹的其他密钥数量。\n", "hint": "与密钥 11 具有相同指纹的另一个密钥是 15。15 产生的余数序列是 $[1, 1, 2]$，因此这两个密钥的指纹多重集都是 $\\{1, 1, 2\\}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12945", "type": "P", "difficulty": 4, "samples": [["3 2 2\nabcdef", "af\nbc\ned"], ["2 3 1\nabcabc", "aab\nbcc"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2019] Lexicography", "background": "", "description": "Lucy likes letters. She studied the definition of the lexicographical order at school and plays with it.\n\nAt first, she tried to construct the lexicographically smallest word out of given letters. It was so easy! Then she tried to build multiple words and minimize one of them. This was much harder!\n\nFormally, Lucy wants to make $n$ words of length $l$ each out of the given $n \\cdot l$ letters, so that the $k$-th of them in the lexicographic order is lexicographically as small as possible.", "inputFormat": "The first line contains three integers $n$, $l$, and $k$ ($1\\le k \\le n \\le 1\\,000$; $1 \\le l \\le 1\\,000$) --- the total number of words, the length of each word, and the index of the word Lucy wants to minimize.\n\nThe next line contains a string of $n \\cdot l$ lowercase letters of the English alphabet.", "outputFormat": "Output $n$ words of $l$ letters each, one per line, using the letters from the input. Words must be sorted in the lexicographic order, and the $k$-th of them must be lexicographically as small as possible. If there are multiple answers with the smallest $k$-th word, output any of them.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2019] Lexicography", "background": "", "description": "Lucy likes letters. She studied the definition of the lexicographical order at school and plays with it.\n\nAt first, she tried to construct the lexicographically smallest word out of given letters. It was so easy! Then she tried to build multiple words and minimize one of them. This was much harder!\n\nFormally, Lucy wants to make $n$ words of length $l$ each out of the given $n \\cdot l$ letters, so that the $k$-th of them in the lexicographic order is lexicographically as small as possible.", "inputFormat": "The first line contains three integers $n$, $l$, and $k$ ($1\\le k \\le n \\le 1\\,000$; $1 \\le l \\le 1\\,000$) --- the total number of words, the length of each word, and the index of the word Lucy wants to minimize.\n\nThe next line contains a string of $n \\cdot l$ lowercase letters of the English alphabet.", "outputFormat": "Output $n$ words of $l$ letters each, one per line, using the letters from the input. Words must be sorted in the lexicographic order, and the $k$-th of them must be lexicographically as small as possible. If there are multiple answers with the smallest $k$-th word, output any of them.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2019] Lexicography", "background": "", "description": "Lucy 喜欢字母。她在学校学习了字典序的定义，并经常用它来做游戏。\n\n起初，她尝试用给定的字母构造字典序最小的单词。这很简单！然后她尝试构造多个单词，并最小化其中某一个单词的字典序。这就难多了！\n\n具体来说，Lucy 希望用给定的 $n \\cdot l$ 个字母构造 $n$ 个长度为 $l$ 的单词，使得这些单词按字典序排列时，第 $k$ 个单词的字典序尽可能小。\n", "inputFormat": "第一行包含三个整数 $n$、$l$ 和 $k$（$1 \\le k \\le n \\le 1\\,000$；$1 \\le l \\le 1\\,000$）—— 单词总数、每个单词的长度，以及 Lucy 想要最小化的单词序号。\n\n第二行包含一个由 $n \\cdot l$ 个小写英文字母组成的字符串。", "outputFormat": "输出 $n$ 个长度为 $l$ 的单词，每个单词占一行，使用输入中的字母。这些单词必须按字典序排列，且其中第 $k$ 个单词的字典序要尽可能小。如果有多个解都能使第 $k$ 个单词字典序最小，输出其中任意一个即可。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12946", "type": "P", "difficulty": 2, "samples": [["2\n0 1 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\n4\nABC\nBC\nBCD\nCDE\n0 1 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\n3\nCDE\nDEF\nEFG", "Case #1: NO\nCase #2: YES"]], "limits": {"time": [20000, 20000, 20000], "memory": [2097152, 2097152, 2097152]}, "tags": ["字符串", "2023", "哈希 hashing", "Google Code Jam"], "title": "[GCJ Farewell Round #1] Colliding Encoding", "background": "", "description": "Alan just had his first cryptography class in school today. He decided to apply what he learned and come up with his own cipher. He will map each English letter from `A` to `Z` to a decimal digit $0$ through $9$. He will then try to encode each word to a string consisting of decimal digits by replacing each letter in the word with its mapped digit.\n\nIn his excitement, Alan failed to notice that there are $26$ letters in the English alphabet and only $10$ decimal digits. As a result, there might be collisions, that is, pairs of different words whose encoding is the same.\n\nGiven a list of $N$ words that Alan wants to encode and the mapping that he uses, can you find out if there would be any collisions between words on the list?", "inputFormat": "The first line of the input gives the number of test cases, T. T test cases follow.\n\nThe first line of each test case contains 26 decimal digits (integers between 0 and 9, inclusive) $D_A$, $D_B$, …, $D_Z$, representing the mapping that Alan uses. A letter $\\alpha$ is mapped to digit $D_\\alpha$.\n\nThe second line of each test case contains N, the number of words Alan will encode.\n\nThe $i$-th of the last N lines contains a string $S_i$, representing the $i$-th word Alan will encode.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either `YES`, if there is at least one pair of different words from the list whose encoding coincides, and NO otherwise.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the mapping for A is 0, for B is 1, for C is 2, for D is 3, and for E is 3. With this mapping, ABC is encoded as 012, BC is encoded as 12, BCD as 123, and CDE as 233. Since all of these encodings are distinct, there are no collisions.\n\nIn Sample Case #2, the mapping for C is 2, for D is 3, for E is 3, for F is 3, and for G is 3. With this mapping, CDE is encoded as 233, DEF as 333, and EFG as 333. Since the encoding for DEF and EFG is the same, there is a collision.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $0 \\leq \\mathbf{D}_{\\alpha} \\leq 9$, for all $\\alpha$.\n- $1 \\leq$ the length of $\\mathbf{S}_{i} \\leq 10$, for all $i$.\n- Each character of $\\mathbf{S}_{i}$ is an uppercase English letter A through Z, for all $i$.\n- $\\mathbf{S}_{i} \\neq \\mathbf{S}_{j}$, for all $i \\neq j$.\n\n**Test Set 1 (4Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 100$.\n\n**Test Set 2 (10Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 6 \\times 10^{4}$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #1] Colliding Encoding", "background": "", "description": "Alan just had his first cryptography class in school today. He decided to apply what he learned and come up with his own cipher. He will map each English letter from `A` to `Z` to a decimal digit $0$ through $9$. He will then try to encode each word to a string consisting of decimal digits by replacing each letter in the word with its mapped digit.\n\nIn his excitement, Alan failed to notice that there are $26$ letters in the English alphabet and only $10$ decimal digits. As a result, there might be collisions, that is, pairs of different words whose encoding is the same.\n\nGiven a list of $N$ words that Alan wants to encode and the mapping that he uses, can you find out if there would be any collisions between words on the list?", "inputFormat": "The first line of the input gives the number of test cases, T. T test cases follow.\n\nThe first line of each test case contains 26 decimal digits (integers between 0 and 9, inclusive) $D_A$, $D_B$, …, $D_Z$, representing the mapping that Alan uses. A letter $\\alpha$ is mapped to digit $D_\\alpha$.\n\nThe second line of each test case contains N, the number of words Alan will encode.\n\nThe $i$-th of the last N lines contains a string $S_i$, representing the $i$-th word Alan will encode.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either `YES`, if there is at least one pair of different words from the list whose encoding coincides, and NO otherwise.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the mapping for A is 0, for B is 1, for C is 2, for D is 3, and for E is 3. With this mapping, ABC is encoded as 012, BC is encoded as 12, BCD as 123, and CDE as 233. Since all of these encodings are distinct, there are no collisions.\n\nIn Sample Case #2, the mapping for C is 2, for D is 3, for E is 3, for F is 3, and for G is 3. With this mapping, CDE is encoded as 233, DEF as 333, and EFG as 333. Since the encoding for DEF and EFG is the same, there is a collision.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $0 \\leq \\mathbf{D}_{\\alpha} \\leq 9$, for all $\\alpha$.\n- $1 \\leq$ the length of $\\mathbf{S}_{i} \\leq 10$, for all $i$.\n- Each character of $\\mathbf{S}_{i}$ is an uppercase English letter A through Z, for all $i$.\n- $\\mathbf{S}_{i} \\neq \\mathbf{S}_{j}$, for all $i \\neq j$.\n\n**Test Set 1 (4Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 100$.\n\n**Test Set 2 (10Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 6 \\times 10^{4}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #1] Colliding Encoding", "background": "", "description": "**Alan** 今天在学校上了第一节密码学课程。他决定运用所学知识，设计自己的加密方式。他计划将字母 `A` 到 `Z` 分别映射到十进制数字 $0$ 到 $9$。然后，他会将每个单词中的字母替换为对应的数字，从而将单词编码为一个由数字组成的字符串。\n\n由于过于兴奋，**Alan** 没有注意到英文字母共有 $26$ 个，而十进制数字只有 $10$ 个。因此，可能会出现**碰撞**，即不同的单词被编码为相同的字符串。\n\n给定 **Alan** 想要编码的 $N$ 个单词及其使用的映射规则，请判断列表中是否存在至少一对单词会发生碰撞。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。随后是 $T$ 个测试用例。\n\n每个测试用例的第一行包含 $26$ 个十进制数字（$0$ 到 $9$ 的整数）$D_A$, $D_B$, …, $D_Z$，表示 **Alan** 使用的映射规则。字母 $\\alpha$ 被映射为数字 $D_\\alpha$。\n\n每个测试用例的第二行包含一个整数 $N$，表示 **Alan** 需要编码的单词数量。\n\n接下来的 $N$ 行中，第 $i$ 行包含一个字符串 $S_i$，表示 **Alan** 要编码的第 $i$ 个单词。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 为 `YES`（如果列表中至少存在一对不同单词的编码相同）或 `NO`（否则）。\n", "hint": "**样例解释**\n\n在样例 #1 中，`A` 映射为 $0$，`B` 为 $1$，`C` 为 $2$，`D` 为 $3$，`E` 为 $3$。此时，`ABC` 编码为 $012$，`BC` 为 $12$，`BCD` 为 $123$，`CDE` 为 $233$。由于所有编码均不同，因此没有碰撞。\n\n在样例 #2 中，`C` 映射为 $2$，`D` 为 $3$，`E` 为 $3$，`F` 为 $3$，`G` 为 $3$。此时，`CDE` 编码为 $233$，`DEF` 和 `EFG` 均为 $333$。由于 `DEF` 和 `EFG` 的编码相同，因此存在碰撞。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 对于所有 $\\alpha$，$0 \\leq \\mathbf{D}_{\\alpha} \\leq 9$。\n- 对于所有 $i$，$1 \\leq \\mathbf{S}_{i}$ 的长度 $\\leq 10$。\n- 对于所有 $i$，$\\mathbf{S}_{i}$ 的每个字符均为大写字母 `A` 到 `Z`。\n- 对于所有 $i \\neq j$，$\\mathbf{S}_{i} \\neq \\mathbf{S}_{j}$。\n\n**测试集 1（4 分，可见判定）**\n\n- $1 \\leq \\mathbf{N} \\leq 100$。\n\n**测试集 2（10 分，可见判定）**\n\n- $1 \\leq \\mathbf{N} \\leq 6 \\times 10^{4}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12947", "type": "P", "difficulty": 2, "samples": [["3\n10 3 3\n2 7 9\n10 2 3\n2 7 9\n10 2 4\n2 3 7 9", "Case #1: 2\nCase #2: IMPOSSIBLE\nCase #3: 4"]], "limits": {"time": [10000, 10000, 10000], "memory": [2097152, 2097152, 2097152]}, "tags": ["贪心", "2023", "Google Code Jam"], "title": "[GCJ Farewell Round #1] Illumination Optimization", "background": "", "description": "Onyaomale is leading a project to exchange the lightbulbs from street lights along a freeway from incandescent ones to LED lightbulbs that are both more energy-efficient and powerful. She started by taking all the old incandescent lightbulbs out, and is now focused on installing the new LED ones. Because the new lightbulbs are more powerful, Onyaomale thinks it is possible that some street lights are not necessary and she can save even more energy by not using them.\n\nWe model the freeway as a straight line measuring $\\mathbf{M}$ meters that goes from west to east. The $x$-th meter is a point that is $x$ meters to the east of the western end of the freeway. If a street light is located at the $x$-th meter, and a lightbulb with an illumination radius of $\\mathbf{R}$ meters is installed on it, then the street light illuminates the segment of freeway starting at the $\\max(0, x - \\mathbf{R})$-th meter and ending at the $\\min(\\mathbf{M}, x + \\mathbf{R})$-th meter, inclusive. Onyaomale needs to install lightbulbs in such a way that every point of the freeway is illuminated by at least one of them. Notice that this includes illuminating points that are not an integer number of meters away from the freeway endpoints. Street lights that are left without a lightbulb do not illuminate anything.\n\nGiven the length of the freeway in meters $\\mathbf{M}$, the illumination radius of the new lightbulbs $\\mathbf{R}$ and the locations of all street lights, find the minimum number of lightbulbs Onyaomale needs to install to illuminate the whole freeway, or report that it is impossible to do so.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines. The first line contains three integers $\\mathbf{M}$, $\\mathbf{R}$, and $\\mathbf{N}$: the length, in meters, of the freeway, the illumination radius, in meters, of the lightbulbs and the number of street lights, respectively. The second line of a test case contains $\\mathbf{N}$ sorted integers $\\mathbf{X}_1$, $\\mathbf{X}_2$, $\\ldots$, $\\mathbf{X}_\\mathbf{N}$ representing the meters of the freeway where street lights are located.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of lightbulbs Onyaomale needs to install to illuminate the whole freeway, if it is possible. If there is no way to illuminate the entire freeway using the current street lights, $y$ should be IMPOSSIBLE instead.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, Onyaomale can illuminate the entire freeway by placing bulbs in the western-most and middle street lights only, leaving the eastern-most one unused. With these two lights covering $[0,5]$ and $[4,10]$, the entire freeway $([0,10])$ is illuminated.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jbc1t6nr.png)\n\nIn Sample Case #2, Onyaomale has the same configuration as in Sample Case #1, but with weaker lightbulbs. In this case, there is no way for her to illuminate the entire freeway. In particular, even if all the street lights are lit, the middle point between the $4$-th and $5$-th meters would still not be illuminated.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ruj47i6y.png)\n\nFor Sample Case #3 Onyaomale has an additional street light at the $3$-th meter, compared to Sample Case #2, while all other conditions are the same. In this case, installing a lightbulb in every street light is the only way to have the entire freeway illuminated.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/090hfaye.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100.$\n- $1 \\leq \\mathbf{M} \\leq 10^{9}.$\n- $1 \\leq \\mathbf{R} \\leq 10^{9}.$\n- $0 \\leq \\mathbf{X}_{1}.$\n- $\\mathbf{X}_{i} < \\mathbf{X}_{i+1}, \\text{ for all } i.$\n- $\\mathbf{X}_{\\mathbf{N}} \\leq \\mathbf{M}.$\n\n**Test Set 1 (4Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10.$\n\n**Test Set 2 (10Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10^{5}.$\n", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #1] Illumination Optimization", "background": "", "description": "Onyaomale is leading a project to exchange the lightbulbs from street lights along a freeway from incandescent ones to LED lightbulbs that are both more energy-efficient and powerful. She started by taking all the old incandescent lightbulbs out, and is now focused on installing the new LED ones. Because the new lightbulbs are more powerful, Onyaomale thinks it is possible that some street lights are not necessary and she can save even more energy by not using them.\n\nWe model the freeway as a straight line measuring $\\mathbf{M}$ meters that goes from west to east. The $x$-th meter is a point that is $x$ meters to the east of the western end of the freeway. If a street light is located at the $x$-th meter, and a lightbulb with an illumination radius of $\\mathbf{R}$ meters is installed on it, then the street light illuminates the segment of freeway starting at the $\\max(0, x - \\mathbf{R})$-th meter and ending at the $\\min(\\mathbf{M}, x + \\mathbf{R})$-th meter, inclusive. Onyaomale needs to install lightbulbs in such a way that every point of the freeway is illuminated by at least one of them. Notice that this includes illuminating points that are not an integer number of meters away from the freeway endpoints. Street lights that are left without a lightbulb do not illuminate anything.\n\nGiven the length of the freeway in meters $\\mathbf{M}$, the illumination radius of the new lightbulbs $\\mathbf{R}$ and the locations of all street lights, find the minimum number of lightbulbs Onyaomale needs to install to illuminate the whole freeway, or report that it is impossible to do so.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines. The first line contains three integers $\\mathbf{M}$, $\\mathbf{R}$, and $\\mathbf{N}$: the length, in meters, of the freeway, the illumination radius, in meters, of the lightbulbs and the number of street lights, respectively. The second line of a test case contains $\\mathbf{N}$ sorted integers $\\mathbf{X}_1$, $\\mathbf{X}_2$, $\\ldots$, $\\mathbf{X}_\\mathbf{N}$ representing the meters of the freeway where street lights are located.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of lightbulbs Onyaomale needs to install to illuminate the whole freeway, if it is possible. If there is no way to illuminate the entire freeway using the current street lights, $y$ should be IMPOSSIBLE instead.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, Onyaomale can illuminate the entire freeway by placing bulbs in the western-most and middle street lights only, leaving the eastern-most one unused. With these two lights covering $[0,5]$ and $[4,10]$, the entire freeway $([0,10])$ is illuminated.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jbc1t6nr.png)\n\nIn Sample Case #2, Onyaomale has the same configuration as in Sample Case #1, but with weaker lightbulbs. In this case, there is no way for her to illuminate the entire freeway. In particular, even if all the street lights are lit, the middle point between the $4$-th and $5$-th meters would still not be illuminated.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ruj47i6y.png)\n\nFor Sample Case #3 Onyaomale has an additional street light at the $3$-th meter, compared to Sample Case #2, while all other conditions are the same. In this case, installing a lightbulb in every street light is the only way to have the entire freeway illuminated.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/090hfaye.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100.$\n- $1 \\leq \\mathbf{M} \\leq 10^{9}.$\n- $1 \\leq \\mathbf{R} \\leq 10^{9}.$\n- $0 \\leq \\mathbf{X}_{1}.$\n- $\\mathbf{X}_{i} < \\mathbf{X}_{i+1}, \\text{ for all } i.$\n- $\\mathbf{X}_{\\mathbf{N}} \\leq \\mathbf{M}.$\n\n**Test Set 1 (4Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10.$\n\n**Test Set 2 (10Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10^{5}.$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #1] Illumination Optimization", "background": "", "description": "**Onyaomale** 正在领导一个项目，将高速公路沿线路灯的白炽灯泡更换为更节能且亮度更高的 LED 灯泡。她已将所有旧白炽灯泡拆除，现在专注于安装新的 LED 灯泡。由于新灯泡亮度更高，**Onyaomale** 认为部分路灯可能不再必要，通过停用这些路灯可以进一步节省能源。\n\n我们将高速公路建模为一条从西向东延伸、长度为 $\\mathbf{M}$ 米的直线。第 $x$ 米表示距离高速公路西端 $x$ 米的点。如果一盏路灯位于第 $x$ 米处，并安装了照明半径为 $\\mathbf{R}$ 米的灯泡，则该路灯会照亮从第 $\\max(0, x - \\mathbf{R})$ 米到第 $\\min(\\mathbf{M}, x + \\mathbf{R})$ 米（含端点）的高速公路段。**Onyaomale** 需要以最少数量的灯泡安装方案，确保高速公路的每个点都被至少一盏灯照亮。注意，这包括非整米距离的点。未安装灯泡的路灯不会照亮任何区域。\n\n给定高速公路的长度 $\\mathbf{M}$、新灯泡的照明半径 $\\mathbf{R}$ 以及所有路灯的位置，求 **Onyaomale** 需要安装的最少灯泡数量以满足全路段照明需求。如果无法实现全路段照明，则报告不可能。\n", "inputFormat": "输入的第一行包含测试用例数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例包含两行：第一行是三个整数 $\\mathbf{M}$、$\\mathbf{R}$ 和 $\\mathbf{N}$，分别表示高速公路长度（米）、灯泡照明半径（米）和路灯数量；第二行包含 $\\mathbf{N}$ 个按升序排列的整数 $\\mathbf{X}_1, \\mathbf{X}_2, \\ldots, \\mathbf{X}_\\mathbf{N}$，表示路灯所在的位置（米）。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为最少需要安装的灯泡数量。如果无法实现全路段照明，则 $y$ 为 `IMPOSSIBLE`。\n", "hint": "**样例解释**\n\n在样例 #1 中，**Onyaomale** 只需在最西侧和中间的路灯上安装灯泡，无需使用最东侧的灯。这两个灯泡分别覆盖 $[0,5]$ 和 $[4,10]$，因此整个高速公路 $[0,10]$ 均被照亮。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jbc1t6nr.png)\n\n在样例 #2 中，配置与样例 #1 相同，但灯泡照明半径更小。此时无法实现全路段照明。即使所有路灯均点亮，第 $4$ 米与第 $5$ 米之间的中点仍未被覆盖。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ruj47i6y.png)\n\n在样例 #3 中，相比样例 #2 新增了一盏位于第 $3$ 米的路灯。此时必须为所有路灯安装灯泡才能实现全路段照明。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/090hfaye.png)\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{M} \\leq 10^{9}$。\n- $1 \\leq \\mathbf{R} \\leq 10^{9}$。\n- $0 \\leq \\mathbf{X}_{1}$。\n- 对所有 $i$，满足 $\\mathbf{X}_{i} < \\mathbf{X}_{i+1}$。\n- $\\mathbf{X}_{\\mathbf{N}} \\leq \\mathbf{M}$。\n\n**测试集 1（4 分，可见判定）**\n\n- $1 \\leq \\mathbf{N} \\leq 10$。\n\n**测试集 2（10 分，可见判定）**\n\n- $1 \\leq \\mathbf{N} \\leq 10^{5}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12948", "type": "P", "difficulty": 3, "samples": [["2\n4\n3 8 8 2\n5\n3 8 2 2 8", "Case #1: 3 8 2\nCase #2: IMPOSSIBLE"]], "limits": {"time": [20000, 20000, 20000], "memory": [2097152, 2097152, 2097152]}, "tags": ["2023", "Google Code Jam"], "title": "[GCJ Farewell Round #1] Rainbow Sort", "background": "", "description": "Your friend Charles gives you a challenge. He puts $\\mathbf{N}$ cards on a table and arranges them in a line in an order that he chooses. Each card has a single color, and each color can be on one or more cards.\n\nCharles then asks you to write a positive integer on each card without altering his chosen order such that:\n\n1. The integers you write appear in non-decreasing order when cards are read from left to right.\n2. Cards of the same color have the same integer written on them.\n3. Cards of different colors have different integers written on them.\n\nFinally, Charles wants you to order the colors in increasing order of written integer. For example, if blue cards have a 2, red cards have a 5, and green cards have a 3, the color order would be blue, green, red.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow.\n\nEach test case begins with a line containing the integer $\\mathbf{N}$. The next line contains $\\mathbf{N}$ integers, $\\mathbf{S}_1$, $\\mathbf{S}_2$, $\\ldots$, $\\mathbf{S}_\\mathbf{N}$, where $\\mathbf{S}_i$ represents the color of the $i$-th card from the left.", "outputFormat": "For each test case, output one line containing Case #x: y, where $x$ is the test case number (starting from 1) and $y$ is the set of colors, once each, listed in the requested order. If it is impossible to write integers in the given cards while adhering to all the rules, $y$ must be IMPOSSIBLE instead.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are 3 different colors on 4 cards. One possible solution is to write the following integers, in order: 1, 2, 2, and 3. Notice that the same integer (2) is written on both cards of color 8. Then, the order of the colors is 3, 8, 2.\n\nIn Sample Case #2, let $c_8$ and $c_2$ be the integers written in cards of color 8 and 2, respectively. If $c_2 > c_8$ then the rightmost two cards would not have their integers in non-decreasing order. If $c_2 < c_8$ that would happen to the second and third card from the left. Finally, $c_8 = c_2$ is forbidden by one of the rules. Therefore, there is no valid way of writing the integers in this case.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100.$\n- $1 \\leq \\mathbf{S}_{i} \\leq 10^{5}, \\text{ for all } i.$\n\n**Test Set 1 (4Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10.$\n\n**Test Set 2 (10Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10^{5}.$\n", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #1] Rainbow Sort", "background": "", "description": "Your friend Charles gives you a challenge. He puts $\\mathbf{N}$ cards on a table and arranges them in a line in an order that he chooses. Each card has a single color, and each color can be on one or more cards.\n\nCharles then asks you to write a positive integer on each card without altering his chosen order such that:\n\n1. The integers you write appear in non-decreasing order when cards are read from left to right.\n2. Cards of the same color have the same integer written on them.\n3. Cards of different colors have different integers written on them.\n\nFinally, Charles wants you to order the colors in increasing order of written integer. For example, if blue cards have a 2, red cards have a 5, and green cards have a 3, the color order would be blue, green, red.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow.\n\nEach test case begins with a line containing the integer $\\mathbf{N}$. The next line contains $\\mathbf{N}$ integers, $\\mathbf{S}_1$, $\\mathbf{S}_2$, $\\ldots$, $\\mathbf{S}_\\mathbf{N}$, where $\\mathbf{S}_i$ represents the color of the $i$-th card from the left.", "outputFormat": "For each test case, output one line containing Case #x: y, where $x$ is the test case number (starting from 1) and $y$ is the set of colors, once each, listed in the requested order. If it is impossible to write integers in the given cards while adhering to all the rules, $y$ must be IMPOSSIBLE instead.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are 3 different colors on 4 cards. One possible solution is to write the following integers, in order: 1, 2, 2, and 3. Notice that the same integer (2) is written on both cards of color 8. Then, the order of the colors is 3, 8, 2.\n\nIn Sample Case #2, let $c_8$ and $c_2$ be the integers written in cards of color 8 and 2, respectively. If $c_2 > c_8$ then the rightmost two cards would not have their integers in non-decreasing order. If $c_2 < c_8$ that would happen to the second and third card from the left. Finally, $c_8 = c_2$ is forbidden by one of the rules. Therefore, there is no valid way of writing the integers in this case.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100.$\n- $1 \\leq \\mathbf{S}_{i} \\leq 10^{5}, \\text{ for all } i.$\n\n**Test Set 1 (4Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10.$\n\n**Test Set 2 (10Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10^{5}.$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #1] Rainbow Sort", "background": "", "description": "你的朋友 **Charles** 给你出了一个挑战。他在桌上排列了 $\\mathbf{N}$ 张卡片，并按他选择的顺序排成一条直线。每张卡片有一种颜色，同一种颜色可能出现在多张卡片上。\n\n**Charles** 要求你在不改变他原有排列顺序的前提下，为每张卡片写上一个正整数，满足以下条件：\n\n1. 当从左到右阅读卡片时，卡片上的数字必须是非递减的。\n2. 相同颜色的卡片必须写上相同的数字。\n3. 不同颜色的卡片必须写上不同的数字。\n\n最后，**Charles** 希望你按照数字从小到大的顺序排列这些颜色。例如，如果蓝色卡片写的是 2，红色卡片写的是 5，绿色卡片写的是 3，那么颜色顺序应为蓝色、绿色、红色。", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。\n\n每个测试用例的第一行包含一个整数 $\\mathbf{N}$。接下来一行包含 $\\mathbf{N}$ 个整数 $\\mathbf{S}_1, \\mathbf{S}_2, \\ldots, \\mathbf{S}_\\mathbf{N}$，其中 $\\mathbf{S}_i$ 表示从左数第 $i$ 张卡片的颜色。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是按要求顺序排列的颜色集合（每个颜色仅出现一次）。如果无法在满足所有规则的情况下为卡片写上数字，则 $y$ 应为 `IMPOSSIBLE`。\n", "hint": "**样例解释**\n\n在样例 #1 中，4 张卡片共有 3 种不同颜色。一种可行的解决方案是按顺序写上以下数字：1、2、2、3。注意颜色为 8 的两张卡片都写上了相同的数字 2。因此，颜色的顺序为 3、8、2。\n\n在样例 #2 中，设 $c_8$ 和 $c_2$ 分别为颜色 8 和 2 的卡片上写的数字。如果 $c_2 > c_8$，那么最右侧的两张卡片上的数字将不是非递减的；如果 $c_2 < c_8$，则左侧第二和第三张卡片会出现同样的问题；而 $c_8 = c_2$ 又违反了规则之一。因此，这种情况下没有有效的解决方案。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 对于所有 $i$，$1 \\leq \\mathbf{S}_{i} \\leq 10^{5}$。\n\n**测试集 1（4 分，可见判定）**\n- $1 \\leq \\mathbf{N} \\leq 10$。\n\n**测试集 2（10 分，可见判定）**\n- $1 \\leq \\mathbf{N} \\leq 10^{5}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12949", "type": "P", "difficulty": 3, "samples": [["2\n5\n31", "Case #1: E\nCase #2: C"]], "limits": {"time": [20000, 20000, 20000], "memory": [2097152, 2097152, 2097152]}, "tags": ["数学", "倍增", "二分", "2023", "Google Code Jam"], "title": "[GCJ Farewell Round #1] ASCII Art", "background": "", "description": "Cody-Jamal has heard about generative artificial intelligence producing art. He is excited about the new art opportunities, but also worried about human-created art being displaced. He thought a good compromise would be to use computers to create art that humans simply cannot.\n\nSince Cody-Jamal is just beginning at computer-generated art, he started simple. He wants to create an immense string that shows the English alphabet in a doubly-repeated way, to represent its ubiquity and permanence.\n\nCody-Jamal wrote the following program:\n\n```python\nfor i = 1 to 1e100:\n    for letter = A to Z:\n        print letter i times\n```\n\nHere $1 \\mathrm{e} 100$ represents the integer $10^{100}$. For example:\n\n* When $i=1$, the program prints $\\mathrm{ABCD} \\ldots . . \\mathrm{XYZ}$.\n* When $i=2$, the program prints $\\mathrm{AABBCC} \\ldots \\mathrm{XXYYZZ}$.\n* When $i=3$, the program prints $\\mathrm{AAABBBCCC} \\ldots \\mathrm{XXXYYYZZZ}$.\n\nOf course, Cody-Jamal's program takes a long time to finish. Can you help him know what the $\\mathbf{N}$-th printed letter will be without waiting for it to be printed?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of a single line with an integer $\\mathbf{N}$.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the $\\mathbf{N}$-th character printed by Cody-Jamal's program.", "hint": "**Sample Explanation**\n\nThe first 35 letters printed by Cody-Jamal's program are ABCDEFGHIJKLMNOPQRSTUVWXYZAABBCCDDE… Therefore, the 5th printed character is E and the 31st is C.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\nTest Set 1 (9 Pts, Visible Verdict)\n\n- $1 \\leq \\mathbf{N} \\leq 10^{6}$.\n\nTest Set 2 (20 Pts, Visible Verdict)\n\n- $1 \\leq \\mathbf{N} \\leq 10^{12}$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #1] ASCII Art", "background": "", "description": "Cody-Jamal has heard about generative artificial intelligence producing art. He is excited about the new art opportunities, but also worried about human-created art being displaced. He thought a good compromise would be to use computers to create art that humans simply cannot.\n\nSince Cody-Jamal is just beginning at computer-generated art, he started simple. He wants to create an immense string that shows the English alphabet in a doubly-repeated way, to represent its ubiquity and permanence.\n\nCody-Jamal wrote the following program:\n\n```python\nfor i = 1 to 1e100:\n    for letter = A to Z:\n        print letter i times\n```\n\nHere $1 \\mathrm{e} 100$ represents the integer $10^{100}$. For example:\n\n* When $i=1$, the program prints $\\mathrm{ABCD} \\ldots . . \\mathrm{XYZ}$.\n* When $i=2$, the program prints $\\mathrm{AABBCC} \\ldots \\mathrm{XXYYZZ}$.\n* When $i=3$, the program prints $\\mathrm{AAABBBCCC} \\ldots \\mathrm{XXXYYYZZZ}$.\n\nOf course, Cody-Jamal's program takes a long time to finish. Can you help him know what the $\\mathbf{N}$-th printed letter will be without waiting for it to be printed?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of a single line with an integer $\\mathbf{N}$.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the $\\mathbf{N}$-th character printed by Cody-Jamal's program.", "hint": "**Sample Explanation**\n\nThe first 35 letters printed by Cody-Jamal's program are ABCDEFGHIJKLMNOPQRSTUVWXYZAABBCCDDE… Therefore, the 5th printed character is E and the 31st is C.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\nTest Set 1 (9 Pts, Visible Verdict)\n\n- $1 \\leq \\mathbf{N} \\leq 10^{6}$.\n\nTest Set 2 (20 Pts, Visible Verdict)\n\n- $1 \\leq \\mathbf{N} \\leq 10^{12}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #1] ASCII Art", "background": "", "description": "**Cody-Jamal** 听说了生成式人工智能创作艺术的事情。他对这种新的艺术创作方式感到兴奋，但同时也担心人类创作的艺术会被取代。他认为一个很好的折衷方案是利用计算机来创作人类无法完成的艺术作品。\n\n由于 **Cody-Jamal** 刚刚开始接触计算机生成艺术，他决定从简单的开始。他想创建一个巨大的字符串，以双重重复的方式展示英文字母，以表现字母的普遍性和永恒性。\n\n**Cody-Jamal** 编写了以下程序：\n\n```\nfor i = 1 to 1e100:\n    for letter = A to Z:\n        print letter i times\n```\n\n这里 $1 \\mathrm{e} 100$ 表示整数 $10^{100}$。例如：\n\n* 当 $i=1$ 时，程序会输出 $\\mathrm{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$（26 个字母各出现 1 次）\n* 当 $i=2$ 时，程序会输出 $\\mathrm{AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTTUUVVWWXXYYZZ}$（26 个字母各出现 2 次）\n* 当 $i=3$ 时，程序会输出 $\\mathrm{AAABBBCCCDDDEEEFFFGGGHHHIIIJJJKKKLLLMMMNNNOOOPPPQQQRRRSSSTTTUUUVVVWWWXXXYYYZZZ}$（26 个字母各出现 3 次）\n\n显然，**Cody-Jamal** 的这个程序需要运行极其漫长的时间。你能在不实际运行程序的情况下，直接计算出程序输出的第 $\\mathbf{N}$ 个字符是什么吗？", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$（$1 \\leq \\mathbf{T} \\leq 100$）。随后是 $\\mathbf{T}$ 个测试用例，每个测试用例单独占一行，包含一个整数 $\\mathbf{N}$（$1 \\leq \\mathbf{N} \\leq 10^{12}$）。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是程序输出的第 $\\mathbf{N}$ 个字母（大写）。\n", "hint": "程序输出的字符序列开始部分为：\n- $i=1$: A(1), B(2), C(3), D(4), E(5),..., Z(26)\n- $i=2$: A(27-28), B(29-30), C(31-32),..., Z(78)\n- ...\n\n因此：\n- 第 5 个字符是 E\n- 第 31 个字符是 C（位于第二轮的 C 部分）\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$\n\n**测试集 1（9 分，可见判定）**\n- $1 \\leq \\mathbf{N} \\leq 10^{6}$\n\n**测试集 2（20 分，可见判定）**\n- $1 \\leq \\mathbf{N} \\leq 10^{12}$\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12950", "type": "P", "difficulty": 3, "samples": [["3\nPRSSP\nRRRRRRR\nRSPRPSPRS", "Case #1: 2\nCase #2: 4\nCase #3: 0"]], "limits": {"time": [10000, 10000, 10000], "memory": [2097152, 2097152, 2097152]}, "tags": ["动态规划 DP", "贪心", "2023", "Google Code Jam"], "title": "[GCJ Farewell Round #1] Untie", "background": "", "description": "A group of people are sitting in a circle, playing a special version of rock, paper, scissors. In this game, each person chooses rock, paper, or scissors in secret and then everyone reveals their choice to everyone else. Each person then compares their selection to their two neighbors, and can win, lose, or tie against each of them independently. The only way to tie is when both people make the same choice.\n\nYou want to make it so that no game is a tie. For each player, you can let them keep their choice, or you can ask them to change to any of the other two options (you choose to which one). What is the minimum number of people you need to request a change from to ensure that there are no ties between neighbors after those changes are made?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line represents a test case and contains a string $\\mathbf{C}$. The $i$-th character of $\\mathbf{C}$ represents the original choice of the $i$-th person in clockwise order using an uppercase $\\mathbf{R}$ to mean rock, an uppercase $\\mathbf{P}$ to mean paper, and an uppercase $\\mathbf{S}$ to mean scissors.\n", "outputFormat": "For each test case, output one line containing Case # $x: y$, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of changes that are required such that no two neighbors end up with the same choice.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there is a pair of neighbors that both chose paper (the first and last character of the input) and another pair that both chose scissors. Therefore, we need at least two changes. One way of doing it with two changes is to change the leftmost paper to scissors and the rightmost scissors to rock, to obtain SRSRP.\n\nIn Sample Case #2, all 7 participants chose rock. If we change at most 3 selections, there will be at least 4 remaining rocks, and at least two of them will be neighbors. Therefore, the minimum number of changes is at least 4. One way to achieve exactly 4 is to get PRSRPRS.\n\nIn Sample Case #3, no pair of neighbors tied, so no changes are needed.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- Each character of $\\mathbf{C}$ is either an uppercase $\\mathbf{R}$, an uppercase $\\mathbf{P}$, or an uppercase $\\mathbf{s}$.\n\nTest Set 1 (9 Pts, Visible Verdict)\n\n- $3 \\leq$ the length of $\\mathbf{C} \\leq 10$.\n\nTest Set 2 (20 Pts, Visible Verdict)\n\n- $3 \\leq$ the length of $\\mathbf{C} \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #1] Untie", "background": "", "description": "A group of people are sitting in a circle, playing a special version of rock, paper, scissors. In this game, each person chooses rock, paper, or scissors in secret and then everyone reveals their choice to everyone else. Each person then compares their selection to their two neighbors, and can win, lose, or tie against each of them independently. The only way to tie is when both people make the same choice.\n\nYou want to make it so that no game is a tie. For each player, you can let them keep their choice, or you can ask them to change to any of the other two options (you choose to which one). What is the minimum number of people you need to request a change from to ensure that there are no ties between neighbors after those changes are made?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line represents a test case and contains a string $\\mathbf{C}$. The $i$-th character of $\\mathbf{C}$ represents the original choice of the $i$-th person in clockwise order using an uppercase $\\mathbf{R}$ to mean rock, an uppercase $\\mathbf{P}$ to mean paper, and an uppercase $\\mathbf{S}$ to mean scissors.\n", "outputFormat": "For each test case, output one line containing Case # $x: y$, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of changes that are required such that no two neighbors end up with the same choice.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there is a pair of neighbors that both chose paper (the first and last character of the input) and another pair that both chose scissors. Therefore, we need at least two changes. One way of doing it with two changes is to change the leftmost paper to scissors and the rightmost scissors to rock, to obtain SRSRP.\n\nIn Sample Case #2, all 7 participants chose rock. If we change at most 3 selections, there will be at least 4 remaining rocks, and at least two of them will be neighbors. Therefore, the minimum number of changes is at least 4. One way to achieve exactly 4 is to get PRSRPRS.\n\nIn Sample Case #3, no pair of neighbors tied, so no changes are needed.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- Each character of $\\mathbf{C}$ is either an uppercase $\\mathbf{R}$, an uppercase $\\mathbf{P}$, or an uppercase $\\mathbf{s}$.\n\nTest Set 1 (9 Pts, Visible Verdict)\n\n- $3 \\leq$ the length of $\\mathbf{C} \\leq 10$.\n\nTest Set 2 (20 Pts, Visible Verdict)\n\n- $3 \\leq$ the length of $\\mathbf{C} \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #1] Untie", "background": "", "description": "一群人围坐成一圈，正在玩一个特殊版本的石头剪刀布游戏。在这个游戏中，每个人秘密选择石头、布或剪刀，然后所有人同时向其他人展示自己的选择。每个人会将自己的选择与左右两位邻居进行比较，可能分别对每位邻居获胜、落败或平局。只有当两人选择相同时才会出现平局。\n\n你希望调整游戏结果，使得没有任何相邻两人出现平局。对于每位玩家，你可以选择保留其原有选择，或者要求他们更改为另外两个选项中的任意一个（由你决定改为哪个）。为了确保在调整后所有相邻玩家的选择都不相同，最少需要改变多少人的选择？", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 行，每行表示一个测试用例，包含一个字符串 $\\mathbf{C}$。$\\mathbf{C}$ 的第 $i$ 个字符表示顺时针方向第 $i$ 个人的初始选择，其中大写字母 $\\mathbf{R}$ 表示石头，$\\mathbf{P}$ 表示布，$\\mathbf{S}$ 表示剪刀。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是为了确保相邻玩家最终选择不同所需的最少改变次数。\n", "hint": "**样例解释**\n\n在样例 #1 中，存在一对相邻玩家都选择布（输入的首尾字符），以及另一对相邻玩家都选择剪刀。因此至少需要两次改变。其中一种实现方式是：将最左侧的布改为剪刀，最右侧的剪刀改为石头，得到 SRSRP。\n\n在样例 #2 中，所有 7 位参与者都选择了石头。如果最多改变 3 次选择，那么至少会剩下 4 个石头，其中至少有两个是相邻的。因此最少需要改变 4 次。其中一种实现方式是得到 PRSRPRS。\n\n在样例 #3 中，没有任何相邻玩家出现平局，因此不需要改变。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $\\mathbf{C}$ 的每个字符都是大写字母 $\\mathbf{R}$、$\\mathbf{P}$ 或 $\\mathbf{S}$。\n\n**测试集 1（9 分，可见判定）**\n- $3 \\leq \\mathbf{C}$ 的长度 $\\leq 10$。\n\n**测试集 2（20 分，可见判定）**\n- $3 \\leq \\mathbf{C}$ 的长度 $\\leq 1000$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12951", "type": "P", "difficulty": 3, "samples": [["3\n5\n30 50 40 20 10\n1 2 4 5\n5\n20 20 80 10 10\n1 4 2 5\n4\n90 10 10 10\n1 4 1 4", "Case #1: 120\nCase #2: 100\nCase #3: 90"]], "limits": {"time": [30000, 30000, 30000], "memory": [2097152, 2097152, 2097152]}, "tags": ["贪心", "2023", "前缀和", "Google Code Jam"], "title": "[GCJ Farewell Round #2] Collecting Pancakes", "background": "", "description": "Alice and Bob both have a sweet tooth, and they are going to play a game to collect pancakes. There are $\\mathbf{N}$ pancake stacks lined up on the table labeled from 1 to $\\mathbf{N}$. The $i$-th stack has exactly $\\mathbf{A}_{i}$ pancakes. Alice and Bob are going to collect pancakes by alternating turns claiming full stacks. For the first turn, Alice must choose a stack labeled between $\\mathbf{L}_{\\mathrm{a}}$ and $\\mathbf{R}_{\\mathrm{a}}$, inclusive, and claim it. Then, Bob must choose a stack labeled between $\\mathbf{L}_{\\mathrm{b}}$ and $\\mathbf{R}_{\\mathrm{b}}$, inclusive, and different from the one chosen by Alice, and claim it.\n\nIn subsequent turns, each of them must choose an unclaimed stack that is adjacent to a stack they claimed themselves before. That is, for Alice to claim stack $i$ on one of her turns other than the first, she must have claimed either stack $i-1$ or stack $i+1$ in one of her previous turns. The same is true for Bob. If at some point there is no valid choice for either player, they skip that turn and claim no stack.\n\nThe game ends when every stack is claimed. At that point, Alice collects all pancakes from all stacks she claimed, and Bob collects all pancakes in all stacks he claimed.\n\nAlice wants to get as many pancakes as possible for herself, and Bob wants to get as many pancakes as possible for himself. Can you help Alice find out the maximum number of pancakes she can collect if they both play optimally?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of three lines.\n\nThe first line of each test case contains an integer $\\mathbf{N}$, representing the number of pancake stacks.\n\nThe second line contains $\\mathbf{N}$ integers $\\mathbf{A}_{1}, \\mathbf{A}_{2}, \\ldots, \\mathbf{A}_{\\mathbf{N}}$, where $\\mathbf{A}_{i}$ denotes the number of pancakes in stack $i$.\n\nThe third line contains 4 integers $\\mathbf{L}_{\\mathrm{a}}, \\mathbf{R}_{\\mathrm{a}}, \\mathbf{L}_{\\mathrm{b}}$, and $\\mathbf{R}_{\\mathrm{b}}$, the inclusive ranges of pancake stack labels Alice and Bob can choose for their first turn, respectively.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of pancakes Alice can collect after playing the game optimally.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are 5 pancake stacks with 30, 50, 40, 20, 10 pancakes in them. Alice can choose the first or second stack at the beginning of the game, and Bob can choose the fourth or fifth stack to begin with. One way in which they both play optimally is:\n\n1. At the beginning, Alice claims stack 2, then Bob claims stack 4.\n2. Alice claims stack 3 in her second turn, then Bob claims stack 5 in his second turn.\n3. Alice claims stack 1 in her third turn, then the game ends because all stacks have been claimed.\n\nAt the end of the game, Alice claimed stacks 1, 2, and 3 and Bob claimed stacks 4 and 5. The number of pancakes Alice collects is $30 + 50 + 40 = 120$.\n\nIn Sample Case #2, one way of optimal play is:\n\n1. At the beginning, Alice claims stack 3, then Bob claims stack 2.\n2. Alice claims stack 4 in her second turn, then Bob claims stack 1 in his second turn.\n3. Alice claims stack 5 in her third turn, then the game ends because all stacks have been claimed.\n\nThe number of pancakes Alice collects is $80 + 10 + 10 = 100$.\n\nIn Sample Case #3, both can claim any stack in their first turn. Since stack 1 is more valuable than everything else combined, Alice claims it before Bob does. Then, Bob can claim stack 2, making Alice have to skip all her subsequent turns. Alice still finishes with 90 pancakes and Bob with just 30.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{A}_{i} \\leq 10^{9}$, for all $i$.\n- $1 \\leq \\mathbf{L}_{\\mathrm{a}} \\leq \\mathbf{R}_{\\mathrm{a}} \\leq \\mathbf{N}$\n- $1 \\leq \\mathbf{L}_{\\mathrm{b}} \\leq \\mathbf{R}_{\\mathrm{b}} \\leq \\mathbf{N}$\n- It is not the case that $\\mathbf{L}_{\\mathrm{a}} \\leq \\mathbf{L}_{\\mathrm{b}}=\\mathbf{R}_{\\mathrm{b}} \\leq \\mathbf{R}_{\\mathrm{a}}$. (Bob is guaranteed to be able to pick a stack for his first turn regardless of Alice's choice.)\n\n**Test Set 1 (4 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 100$.\n\n**Test Set 2 (10 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 10^{5}$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #2] Collecting Pancakes", "background": "", "description": "Alice and Bob both have a sweet tooth, and they are going to play a game to collect pancakes. There are $\\mathbf{N}$ pancake stacks lined up on the table labeled from 1 to $\\mathbf{N}$. The $i$-th stack has exactly $\\mathbf{A}_{i}$ pancakes. Alice and Bob are going to collect pancakes by alternating turns claiming full stacks. For the first turn, Alice must choose a stack labeled between $\\mathbf{L}_{\\mathrm{a}}$ and $\\mathbf{R}_{\\mathrm{a}}$, inclusive, and claim it. Then, Bob must choose a stack labeled between $\\mathbf{L}_{\\mathrm{b}}$ and $\\mathbf{R}_{\\mathrm{b}}$, inclusive, and different from the one chosen by Alice, and claim it.\n\nIn subsequent turns, each of them must choose an unclaimed stack that is adjacent to a stack they claimed themselves before. That is, for Alice to claim stack $i$ on one of her turns other than the first, she must have claimed either stack $i-1$ or stack $i+1$ in one of her previous turns. The same is true for Bob. If at some point there is no valid choice for either player, they skip that turn and claim no stack.\n\nThe game ends when every stack is claimed. At that point, Alice collects all pancakes from all stacks she claimed, and Bob collects all pancakes in all stacks he claimed.\n\nAlice wants to get as many pancakes as possible for herself, and Bob wants to get as many pancakes as possible for himself. Can you help Alice find out the maximum number of pancakes she can collect if they both play optimally?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of three lines.\n\nThe first line of each test case contains an integer $\\mathbf{N}$, representing the number of pancake stacks.\n\nThe second line contains $\\mathbf{N}$ integers $\\mathbf{A}_{1}, \\mathbf{A}_{2}, \\ldots, \\mathbf{A}_{\\mathbf{N}}$, where $\\mathbf{A}_{i}$ denotes the number of pancakes in stack $i$.\n\nThe third line contains 4 integers $\\mathbf{L}_{\\mathrm{a}}, \\mathbf{R}_{\\mathrm{a}}, \\mathbf{L}_{\\mathrm{b}}$, and $\\mathbf{R}_{\\mathrm{b}}$, the inclusive ranges of pancake stack labels Alice and Bob can choose for their first turn, respectively.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of pancakes Alice can collect after playing the game optimally.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are 5 pancake stacks with 30, 50, 40, 20, 10 pancakes in them. Alice can choose the first or second stack at the beginning of the game, and Bob can choose the fourth or fifth stack to begin with. One way in which they both play optimally is:\n\n1. At the beginning, Alice claims stack 2, then Bob claims stack 4.\n2. Alice claims stack 3 in her second turn, then Bob claims stack 5 in his second turn.\n3. Alice claims stack 1 in her third turn, then the game ends because all stacks have been claimed.\n\nAt the end of the game, Alice claimed stacks 1, 2, and 3 and Bob claimed stacks 4 and 5. The number of pancakes Alice collects is $30 + 50 + 40 = 120$.\n\nIn Sample Case #2, one way of optimal play is:\n\n1. At the beginning, Alice claims stack 3, then Bob claims stack 2.\n2. Alice claims stack 4 in her second turn, then Bob claims stack 1 in his second turn.\n3. Alice claims stack 5 in her third turn, then the game ends because all stacks have been claimed.\n\nThe number of pancakes Alice collects is $80 + 10 + 10 = 100$.\n\nIn Sample Case #3, both can claim any stack in their first turn. Since stack 1 is more valuable than everything else combined, Alice claims it before Bob does. Then, Bob can claim stack 2, making Alice have to skip all her subsequent turns. Alice still finishes with 90 pancakes and Bob with just 30.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{A}_{i} \\leq 10^{9}$, for all $i$.\n- $1 \\leq \\mathbf{L}_{\\mathrm{a}} \\leq \\mathbf{R}_{\\mathrm{a}} \\leq \\mathbf{N}$\n- $1 \\leq \\mathbf{L}_{\\mathrm{b}} \\leq \\mathbf{R}_{\\mathrm{b}} \\leq \\mathbf{N}$\n- It is not the case that $\\mathbf{L}_{\\mathrm{a}} \\leq \\mathbf{L}_{\\mathrm{b}}=\\mathbf{R}_{\\mathrm{b}} \\leq \\mathbf{R}_{\\mathrm{a}}$. (Bob is guaranteed to be able to pick a stack for his first turn regardless of Alice's choice.)\n\n**Test Set 1 (4 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 100$.\n\n**Test Set 2 (10 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 10^{5}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #2] Collecting Pancakes", "background": "", "description": "**Alice** 和 **Bob** 都喜欢吃甜食，他们准备玩一个收集煎饼的游戏。桌上有 $\\mathbf{N}$ 叠煎饼排成一列，编号从 1 到 $\\mathbf{N}$。第 $i$ 叠煎饼恰好有 $\\mathbf{A}_{i}$ 个。**Alice** 和 **Bob** 将轮流选择整叠煎饼来收集。第一回合，**Alice** 必须选择一个编号在 $[\\mathbf{L}_{\\mathrm{a}}, \\mathbf{R}_{\\mathrm{a}}]$ 范围内的煎饼叠并收集它。接着，**Bob** 必须选择一个编号在 $[\\mathbf{L}_{\\mathrm{b}}, \\mathbf{R}_{\\mathrm{b}}]$ 范围内且不同于 **Alice** 所选叠的煎饼叠并收集它。\n\n在后续回合中，每个人都必须选择一个未被收集且与之前自己收集过的叠相邻的煎饼叠。也就是说，**Alice** 在非首回合选择第 $i$ 叠时，她必须在此前的某个回合中收集过第 $i-1$ 叠或第 $i+1$ 叠。**Bob** 也遵循同样的规则。如果在某一回合中某位玩家没有合法选择，则该玩家跳过此回合，不收集任何煎饼叠。\n\n游戏在所有煎饼叠都被收集时结束。此时，**Alice** 将获得她收集的所有叠中的煎饼总数，**Bob** 则获得他收集的所有叠中的煎饼总数。\n\n**Alice** 希望自己获得的煎饼尽可能多，而 **Bob** 则希望自己获得的煎饼尽可能多。在双方都采取最优策略的情况下，你能帮 **Alice** 计算出她最多能获得多少煎饼吗？\n", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例，每个测试用例包含三行。\n\n每个测试用例的第一行包含一个整数 $\\mathbf{N}$，表示煎饼叠的数量。\n\n第二行包含 $\\mathbf{N}$ 个整数 $\\mathbf{A}_{1}, \\mathbf{A}_{2}, \\ldots, \\mathbf{A}_{\\mathbf{N}}$，其中 $\\mathbf{A}_{i}$ 表示第 $i$ 叠煎饼的数量。\n\n第三行包含 4 个整数 $\\mathbf{L}_{\\mathrm{a}}, \\mathbf{R}_{\\mathrm{a}}, \\mathbf{L}_{\\mathrm{b}}, \\mathbf{R}_{\\mathrm{b}}$，分别表示 **Alice** 和 **Bob** 首回合可选煎饼叠编号的闭区间范围。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是 **Alice** 在双方最优策略下能获得的最大煎饼数量。\n", "hint": "**样例解释**\n\n在样例 #1 中，5 叠煎饼的数量分别为 30、50、40、20、10。**Alice** 首回合可选择第 1 或第 2 叠，**Bob** 首回合可选择第 4 或第 5 叠。双方的一种最优策略如下：\n\n1. **Alice** 首回合选择第 2 叠，**Bob** 选择第 4 叠。\n2. **Alice** 第二回合选择第 3 叠，**Bob** 选择第 5 叠。\n3. **Alice** 第三回合选择第 1 叠，游戏结束。\n\n最终 **Alice** 收集了第 1、2、3 叠，获得 $30 + 50 + 40 = 120$ 个煎饼。\n\n在样例 #2 中，一种最优策略为：\n\n1. **Alice** 首回合选择第 3 叠，**Bob** 选择第 2 叠。\n2. **Alice** 第二回合选择第 4 叠，**Bob** 选择第 1 叠。\n3. **Alice** 第三回合选择第 5 叠，游戏结束。\n\n**Alice** 共获得 $80 + 10 + 10 = 100$ 个煎饼。\n\n在样例 #3 中，双方首回合可选择任意叠。由于第 1 叠的价值超过其他叠的总和，**Alice** 会优先选择它。接着 **Bob** 只能选择第 2 叠，导致 **Alice** 后续无法操作。最终 **Alice** 获得 90 个煎饼，**Bob** 仅获得 30 个。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 对所有 $i$，$1 \\leq \\mathbf{A}_{i} \\leq 10^{9}$。\n- $1 \\leq \\mathbf{L}_{\\mathrm{a}} \\leq \\mathbf{R}_{\\mathrm{a}} \\leq \\mathbf{N}$。\n- $1 \\leq \\mathbf{L}_{\\mathrm{b}} \\leq \\mathbf{R}_{\\mathrm{b}} \\leq \\mathbf{N}$。\n- 保证不存在 $\\mathbf{L}_{\\mathrm{a}} \\leq \\mathbf{L}_{\\mathrm{b}}=\\mathbf{R}_{\\mathrm{b}} \\leq \\mathbf{R}_{\\mathrm{a}}$ 的情况（即 **Bob** 首回合总能选择合法叠）。\n\n**测试集 1（4 分，可见判定）**\n- $2 \\leq \\mathbf{N} \\leq 100$。\n\n**测试集 2（10 分，可见判定）**\n- $2 \\leq \\mathbf{N} \\leq 10^{5}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12952", "type": "P", "difficulty": 4, "samples": [["3\n5 5 4\n1 4 5 5 4\n3 4 2\n3 4 3\n2 4 2\n1 4", "Case #1: 3\nCase #2: 0\nCase #3: IMPOSSIBLE"]], "limits": {"time": [5000, 5000, 5000], "memory": [2097152, 2097152, 2097152]}, "tags": ["数学", "2023", "扩展欧几里德算法", "Google Code Jam"], "title": "[GCJ Farewell Round #2] Intruder Outsmarting", "background": "", "description": "Amiria is a cautious internet user, and as such, she is setting up two-factor authentication for her accounts. She is using a special type of security key as an extra precaution to outsmart any intruders that may want to take it. Amiria's security key requires a code to activate. To enter the code, one must place it on wheels with numbers, similar to code padlocks.\n\nAmiria's security key has a sequence of $\\mathbf{W}$ wheels. Each wheel has the numbers 1 through $\\mathbf{N}$ printed in order. By one wheel rotation, the user can move the currently shown integer either to the next or the previous integer. Numbers on the wheel wrap around. This means the number after $\\mathbf{N}$ is 1 and the number before 1 is $\\mathbf{N}$.\n\nThere is no hidden password. To activate Amiria's security key, a person needs to move the wheels such that the sequence of numbers shown is palindromic. That is, the sequence of numbers is the same when read from left to right and from right to left. To slow down intruders, Amiria rigged the security key such that the wheels only rotate in increments of $\\mathbf{D}$. That is, on a move, a wheel that is currently showing $x$ can be made to show $x - \\mathbf{D}$ or $x + \\mathbf{D}$, applying the proper wraparound. That is, if $x - \\mathbf{D} < 1$ the actual number shown after the operation is $x - \\mathbf{D} + \\mathbf{N}$, and if $x + \\mathbf{D} > \\mathbf{N}$ the actual number shown is $x + \\mathbf{D} - \\mathbf{N}$.\n\nAmiria wants to check how much this system would slow down an intruder trying to use her security key. Given the number of wheels and the number currently shown on each wheel, find the minimum number of operations needed to make the sequence of shown numbers palindromic, or report that it is impossible to do so.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines. The first line of a test case contains 3 integers $\\mathbf{W}$, $\\mathbf{N}$, and $\\mathbf{D}$: the number of wheels in Amiria's security key, the number of integers shown in each of those wheels, and the fixed increment that Amiria rigged for every wheel. The second line of a test case contains $\\mathbf{W}$ integers $\\mathbf{X}_{1}, \\mathbf{X}_{2}, \\ldots, \\mathbf{X}_{\\mathbf{W}}$, where $\\mathbf{X}_{i}$ is the number currently shown in the $i$-th wheel from left to right.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of operations needed to make the sequence of shown numbers palindromic. If there is no way to make the sequence of shown numbers palindromic through the allowed operations, $y$ must be IMPOSSIBLE instead.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the sequence can be made $5 \\ 4 \\ 5 \\ 4 \\ 5$, which is palindromic, with 3 operations by using one addition operation on the first and fourth wheels, and one subtraction operation on the fifth wheel. There is no way to make the sequence palindromic with fewer moves.\n\nIn Sample Case #2 the sequence is already palindromic, so we do not need any operations.\n\nIn Sample Case #3, both numbers would need to be equal for the sequence to be palindromic. Since wheel values can only move by 2 and both current numbers have different parity, that cannot be done.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{D} \\leq \\mathbf{N}-1$.\n- $1 \\leq \\mathbf{X}_{\\mathbf{i}} \\leq \\mathbf{N}$, for all $i$.\n\n**Test Set 1 (4 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{W} \\leq 5$.\n- $2 \\leq \\mathbf{N} \\leq 5$.\n\n**Test Set 2 (10 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{W} \\leq 1000$.\n- $2 \\leq \\mathbf{N} \\leq 10^{9}$.\n", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #2] Intruder Outsmarting", "background": "", "description": "Amiria is a cautious internet user, and as such, she is setting up two-factor authentication for her accounts. She is using a special type of security key as an extra precaution to outsmart any intruders that may want to take it. Amiria's security key requires a code to activate. To enter the code, one must place it on wheels with numbers, similar to code padlocks.\n\nAmiria's security key has a sequence of $\\mathbf{W}$ wheels. Each wheel has the numbers 1 through $\\mathbf{N}$ printed in order. By one wheel rotation, the user can move the currently shown integer either to the next or the previous integer. Numbers on the wheel wrap around. This means the number after $\\mathbf{N}$ is 1 and the number before 1 is $\\mathbf{N}$.\n\nThere is no hidden password. To activate Amiria's security key, a person needs to move the wheels such that the sequence of numbers shown is palindromic. That is, the sequence of numbers is the same when read from left to right and from right to left. To slow down intruders, Amiria rigged the security key such that the wheels only rotate in increments of $\\mathbf{D}$. That is, on a move, a wheel that is currently showing $x$ can be made to show $x - \\mathbf{D}$ or $x + \\mathbf{D}$, applying the proper wraparound. That is, if $x - \\mathbf{D} < 1$ the actual number shown after the operation is $x - \\mathbf{D} + \\mathbf{N}$, and if $x + \\mathbf{D} > \\mathbf{N}$ the actual number shown is $x + \\mathbf{D} - \\mathbf{N}$.\n\nAmiria wants to check how much this system would slow down an intruder trying to use her security key. Given the number of wheels and the number currently shown on each wheel, find the minimum number of operations needed to make the sequence of shown numbers palindromic, or report that it is impossible to do so.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines. The first line of a test case contains 3 integers $\\mathbf{W}$, $\\mathbf{N}$, and $\\mathbf{D}$: the number of wheels in Amiria's security key, the number of integers shown in each of those wheels, and the fixed increment that Amiria rigged for every wheel. The second line of a test case contains $\\mathbf{W}$ integers $\\mathbf{X}_{1}, \\mathbf{X}_{2}, \\ldots, \\mathbf{X}_{\\mathbf{W}}$, where $\\mathbf{X}_{i}$ is the number currently shown in the $i$-th wheel from left to right.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of operations needed to make the sequence of shown numbers palindromic. If there is no way to make the sequence of shown numbers palindromic through the allowed operations, $y$ must be IMPOSSIBLE instead.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the sequence can be made $5 \\ 4 \\ 5 \\ 4 \\ 5$, which is palindromic, with 3 operations by using one addition operation on the first and fourth wheels, and one subtraction operation on the fifth wheel. There is no way to make the sequence palindromic with fewer moves.\n\nIn Sample Case #2 the sequence is already palindromic, so we do not need any operations.\n\nIn Sample Case #3, both numbers would need to be equal for the sequence to be palindromic. Since wheel values can only move by 2 and both current numbers have different parity, that cannot be done.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{D} \\leq \\mathbf{N}-1$.\n- $1 \\leq \\mathbf{X}_{\\mathbf{i}} \\leq \\mathbf{N}$, for all $i$.\n\n**Test Set 1 (4 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{W} \\leq 5$.\n- $2 \\leq \\mathbf{N} \\leq 5$.\n\n**Test Set 2 (10 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{W} \\leq 1000$.\n- $2 \\leq \\mathbf{N} \\leq 10^{9}$.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #2] Intruder Outsmarting", "background": "", "description": "**Amiria** 是一个谨慎的互联网用户，因此她正在为账户设置双重认证。她使用一种特殊的安全密钥作为额外防护，以智胜那些可能想要窃取它的入侵者。**Amiria** 的安全密钥需要一个激活码。要输入这个激活码，必须将其放置在带有数字的转轮上，类似于密码挂锁。\n\n**Amiria** 的安全密钥由 $\\mathbf{W}$ 个转轮组成。每个转轮上按顺序印有数字 1 到 $\\mathbf{N}$。通过一次转轮旋转，用户可以将当前显示的数字移动到下一个或上一个数字。转轮上的数字是循环的，这意味着 $\\mathbf{N}$ 的下一个数字是 1，而 1 的前一个数字是 $\\mathbf{N}$。\n\n这里没有隐藏密码。要激活 **Amiria** 的安全密钥，需要调整转轮，使得显示的数字序列是回文的。也就是说，数字序列从左到右和从右到左读起来是一样的。为了减慢入侵者的速度，**Amiria** 对安全密钥进行了设置，使得转轮只能以 $\\mathbf{D}$ 的增量旋转。也就是说，在一次操作中，当前显示数字 $x$ 的转轮可以调整为显示 $x - \\mathbf{D}$ 或 $x + \\mathbf{D}$，并应用适当的循环调整。具体来说，如果 $x - \\mathbf{D} < 1$，则操作后实际显示的数字是 $x - \\mathbf{D} + \\mathbf{N}$；如果 $x + \\mathbf{D} > \\mathbf{N}$，则实际显示的数字是 $x + \\mathbf{D} - \\mathbf{N}$。\n\n**Amiria** 想检查这个系统会如何减慢试图使用她安全密钥的入侵者。给定转轮的数量和每个转轮当前显示的数字，找到使显示的数字序列成为回文所需的最少操作次数，或者报告这是不可能的。\n", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例包含两行。测试用例的第一行包含 3 个整数 $\\mathbf{W}$、$\\mathbf{N}$ 和 $\\mathbf{D}$：分别表示 **Amiria** 安全密钥中的转轮数量、每个转轮上显示的数字数量，以及 **Amiria** 设置的固定增量。测试用例的第二行包含 $\\mathbf{W}$ 个整数 $\\mathbf{X}_{1}, \\mathbf{X}_{2}, \\ldots, \\mathbf{X}_{\\mathbf{W}}$，其中 $\\mathbf{X}_{i}$ 是从左到右第 $i$ 个转轮当前显示的数字。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是使显示的数字序列成为回文所需的最少操作次数。如果无法通过允许的操作使数字序列成为回文，则 $y$ 应为 `IMPOSSIBLE`。\n", "hint": "**样例解释**\n\n在样例 #1 中，可以通过 3 次操作将序列调整为 $5 \\ 4 \\ 5 \\ 4 \\ 5$，这是一个回文序列。具体操作为：对第一个和第四个转轮进行一次加法操作，对第五个转轮进行一次减法操作。无法用更少的操作使序列成为回文。\n\n在样例 #2 中，序列已经是回文的，因此不需要任何操作。\n\n在样例 #3 中，要使序列成为回文，两个数字必须相同。由于转轮只能以 2 的增量移动，而当前两个数字的奇偶性不同，因此无法实现。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{D} \\leq \\mathbf{N}-1$。\n- 对所有 $i$，$1 \\leq \\mathbf{X}_{i} \\leq \\mathbf{N}$。\n\n**测试集 1（4 分，可见判定）**\n- $2 \\leq \\mathbf{W} \\leq 5$。\n- $2 \\leq \\mathbf{N} \\leq 5$。\n\n**测试集 2（10 分，可见判定）**\n- $2 \\leq \\mathbf{W} \\leq 1000$。\n- $2 \\leq \\mathbf{N} \\leq 10^{9}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12953", "type": "P", "difficulty": 3, "samples": [["2\n3 2\n1 2 3\n6 4\n2 7 11 19 5 3", "Case #1: 2 1 2\nCase #2: 4 4 4 4 3 4"]], "limits": {"time": [20000, 20000, 20000], "memory": [2097152, 2097152, 2097152]}, "tags": ["递推", "二分", "2023", "Google Code Jam"], "title": "[GCJ Farewell Round #2] Spacious Sets", "background": "", "description": "Ada and John are best friends. Since they are getting bored, Ada asks John to solve a puzzle for her.\n\nA set $S$ is considered *spacious* if the absolute difference between each pair of distinct elements of $S$ is at least $\\mathbf{K}$, that is, $|x - y| \\geq \\mathbf{K}$ for all $x, y \\in S$, with $x \\neq y$.\n\nAda has a list of distinct integers $\\mathbf{A}$ of size $\\mathbf{N}$, and an integer $\\mathbf{K}$. For each $\\mathbf{A}_i$, she asks John to find the maximum size of a set $S_i$ made of elements from $\\mathbf{A}$, such that $S_i$ contains $\\mathbf{A}_i$ and is spacious.\n\nNote: The sets $S_i$ do not need to be made of consecutive elements from the list.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of each test case contains two integers $\\mathbf{N}$ and $\\mathbf{K}$. The next line contains $\\mathbf{N}$ integers $\\mathbf{A}_1 \\mathbf{A}_2 \\ldots \\mathbf{A}_{\\mathbf{N}}$.\n", "outputFormat": "For each test case, output one line containing Case # $x$: $y_1 \\ y_2 \\ldots \\ y_{\\mathbf{N}}$, where $x$ is the test case number (starting from 1) and $y_i$ is the maximum size of a spacious set of elements from $\\mathbf{A}$ that contains $\\mathbf{A}_i$.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, a spacious set cannot contain $1$ and $2$, nor it can contain $2$ and $3$. That implies that $S_2 = \\{2\\}$ and using $S_1 = S_3 = \\{1, 3\\}$ makes them of maximum size.\n\nIn Sample Case #2, possible sets of maximum size are:\n\n* $S_1 = S_2 = S_3 = S_4 = \\{2, 7, 11, 19\\}$,\n* $S_5 = \\{11, 19, 5\\}$, and\n* $S_6 = \\{7, 11, 19, 3\\}$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $-10^9 \\leq \\mathbf{A}_i \\leq 10^9$, for all $i$.\n- $\\mathbf{A}_i \\neq \\mathbf{A}_j$, for all $i \\neq j$.\n\n**Test Set 1 (4 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10$.\n- $1 \\leq \\mathbf{K} \\leq 100$.\n\n**Test Set 2 (10 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{K} \\leq 10^9$.\n\nFor at most 15 cases:\n\n- $1 \\leq \\mathbf{N} \\leq 10^5$.\n\nFor the remaining cases:\n\n- $1 \\leq \\mathbf{N} \\leq 10^3$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #2] Spacious Sets", "background": "", "description": "Ada and John are best friends. Since they are getting bored, Ada asks John to solve a puzzle for her.\n\nA set $S$ is considered *spacious* if the absolute difference between each pair of distinct elements of $S$ is at least $\\mathbf{K}$, that is, $|x - y| \\geq \\mathbf{K}$ for all $x, y \\in S$, with $x \\neq y$.\n\nAda has a list of distinct integers $\\mathbf{A}$ of size $\\mathbf{N}$, and an integer $\\mathbf{K}$. For each $\\mathbf{A}_i$, she asks John to find the maximum size of a set $S_i$ made of elements from $\\mathbf{A}$, such that $S_i$ contains $\\mathbf{A}_i$ and is spacious.\n\nNote: The sets $S_i$ do not need to be made of consecutive elements from the list.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of each test case contains two integers $\\mathbf{N}$ and $\\mathbf{K}$. The next line contains $\\mathbf{N}$ integers $\\mathbf{A}_1 \\mathbf{A}_2 \\ldots \\mathbf{A}_{\\mathbf{N}}$.\n", "outputFormat": "For each test case, output one line containing Case # $x$: $y_1 \\ y_2 \\ldots \\ y_{\\mathbf{N}}$, where $x$ is the test case number (starting from 1) and $y_i$ is the maximum size of a spacious set of elements from $\\mathbf{A}$ that contains $\\mathbf{A}_i$.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, a spacious set cannot contain $1$ and $2$, nor it can contain $2$ and $3$. That implies that $S_2 = \\{2\\}$ and using $S_1 = S_3 = \\{1, 3\\}$ makes them of maximum size.\n\nIn Sample Case #2, possible sets of maximum size are:\n\n* $S_1 = S_2 = S_3 = S_4 = \\{2, 7, 11, 19\\}$,\n* $S_5 = \\{11, 19, 5\\}$, and\n* $S_6 = \\{7, 11, 19, 3\\}$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $-10^9 \\leq \\mathbf{A}_i \\leq 10^9$, for all $i$.\n- $\\mathbf{A}_i \\neq \\mathbf{A}_j$, for all $i \\neq j$.\n\n**Test Set 1 (4 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10$.\n- $1 \\leq \\mathbf{K} \\leq 100$.\n\n**Test Set 2 (10 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{K} \\leq 10^9$.\n\nFor at most 15 cases:\n\n- $1 \\leq \\mathbf{N} \\leq 10^5$.\n\nFor the remaining cases:\n\n- $1 \\leq \\mathbf{N} \\leq 10^3$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #2] Spacious Sets", "background": "", "description": "**Ada** 和 **John** 是最好的朋友。由于他们感到无聊，**Ada** 让 **John** 为她解决一个谜题。\n\n一个集合 $S$ 被称为 **宽松的**，如果其中任意两个不同元素的绝对差至少为 $\\mathbf{K}$，即对于所有 $x, y \\in S$ 且 $x \\neq y$，都有 $|x - y| \\geq \\mathbf{K}$。\n\n**Ada** 有一个包含 $\\mathbf{N}$ 个不同整数的列表 $\\mathbf{A}$ 和一个整数 $\\mathbf{K}$。对于每个 $\\mathbf{A}_i$，她要求 **John** 找出由 $\\mathbf{A}$ 中元素构成的最大尺寸的集合 $S_i$，使得 $S_i$ 包含 $\\mathbf{A}_i$ 并且是宽松的。\n\n注意：集合 $S_i$ 不需要由列表中连续的元素构成。", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含两个整数 $\\mathbf{N}$ 和 $\\mathbf{K}$。第二行包含 $\\mathbf{N}$ 个整数 $\\mathbf{A}_1 \\mathbf{A}_2 \\ldots \\mathbf{A}_{\\mathbf{N}}$。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y_1 y_2 ... y_N`，其中 $x$ 是测试用例编号（从 1 开始），$y_i$ 是包含 $\\mathbf{A}_i$ 的最大宽松集合的尺寸。", "hint": "**样例解释**\n\n在样例 #1 中，一个宽松集合不能同时包含 1 和 2，也不能同时包含 2 和 3。这意味着 $S_2 = \\{2\\}$，而使用 $S_1 = S_3 = \\{1, 3\\}$ 可以使它们的尺寸最大化。\n\n在样例 #2 中，可能的尺寸最大集合为：\n\n* $S_1 = S_2 = S_3 = S_4 = \\{2, 7, 11, 19\\}$，\n* $S_5 = \\{11, 19, 5\\}$，\n* $S_6 = \\{7, 11, 19, 3\\}$。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 对所有 $i$，$-10^9 \\leq \\mathbf{A}_i \\leq 10^9$。\n- 对所有 $i \\neq j$，$\\mathbf{A}_i \\neq \\mathbf{A}_j$。\n\n**测试集 1（4 分，可见判定）**\n- $1 \\leq \\mathbf{N} \\leq 10$。\n- $1 \\leq \\mathbf{K} \\leq 100$。\n\n**测试集 2（10 分，可见判定）**\n- $1 \\leq \\mathbf{K} \\leq 10^9$。\n\n对于最多 15 个测试用例：\n- $1 \\leq \\mathbf{N} \\leq 10^5$。\n\n对于其余测试用例：\n- $1 \\leq \\mathbf{N} \\leq 10^3$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12954", "type": "P", "difficulty": 5, "samples": [["4\n4 3\n3\n1 2 3\n2\n1 4\n3\n4 1 3\n4 4\n2\n1 2\n2\n3 4\n2\n3 2\n2\n4 1\n4 3\n2\n1 2\n2\n3 4\n2\n3 2\n4 3\n2\n1 2\n2\n3 4\n4\n4 1 2 3", "Case #1: 1\nCase #2: 0\nCase #3: 3\nCase #4: 1"]], "limits": {"time": [40000, 40000, 40000], "memory": [2097152, 2097152, 2097152]}, "tags": ["2023", "图论建模", "Tarjan", "双连通分量", "Google Code Jam"], "title": "[GCJ Farewell Round #2] Railroad Maintenance", "background": "", "description": "You are in charge of the maintenance of a railroad network. The network consists of $\\mathbf{N}$ stations and $\\mathbf{L}$ train lines. Each train line serves a fixed list of stations bidirectionally (trains turn around in the first and last stations of the list). Transfers from one line to another in a station are possible, which means a trip in the network from station $a$ to station $b$ is possible if there is a list of train lines such that the first one serves station $a$, the last one serves station $b$, and for any consecutive pair of train lines in the list there is at least one station that they both serve.\n\nThe easiest way to do maintenance is to shut down entire lines, one at a time. However, some train lines may be essential. A train line is essential if removing it would make at least one trip between a pair of stations not possible.\n\nGiven the list of existing train lines, calculate how many of them are essential.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing two integers $\\mathbf{N}$ and $\\mathbf{L}$: the number of stations and train lines in the network. Then, $\\mathbf{L}$ groups of 2 lines follow. The first line of the $i$-th group contains a single integer $\\mathbf{K}_i$ the number of stations served by the $i$-th train line. The second line of the $i$-th group contains $\\mathbf{K}_i$ integers $\\mathbf{S}_{i,1}, \\mathbf{S}_{i,2}, \\ldots, \\mathbf{S}_{i,\\mathbf{K}_i}$ representing the stations served by the $i$-th train line.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of train lines that are essential.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the first train line is essential because it is the only one serving station $2$. Since shutting any other line down would not make travel between at least one pair of stations impossible, they are not essential.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hstw804z.png)\n\nIn Sample Case #2, no line is essential.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/iodjuwf1.png)\n\nSample Case #3 is similar to Sample Case #2, but missing the last train line. That makes all remaining train lines essential.\n\nIn Sample Case #4, the last train line is essential as there is no way to go from station $1$ to station $4$ without it. As in Sample Case #1, since this train line already connects every station, no other line is essential.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xcha3btp.png)\n\n**Sample Explanation**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{K}_i \\leq \\mathbf{N}$ for all $i$.\n- $1 \\leq \\mathbf{S}_{i,j} \\leq \\mathbf{N}$, for all $i, j$.\n- $\\mathbf{S}_{i,j} \\neq \\mathbf{S}_{i,j'}$, for all $i, j, j'$ such that $j \\neq j'$ (Each train line serves a station at most once).\n\nThe trip between all pairs of stations is possible as per the definition above when no train line is shut down.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 100$.\n- $1 \\leq \\mathbf{L} \\leq 100$.\n- $\\mathbf{K}_1 + \\mathbf{K}_2 + \\cdots + \\mathbf{K}_\\mathbf{L} \\leq 200$.\n\n**Test Set 2 (20 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 10^5$.\n- $1 \\leq \\mathbf{L} \\leq 10^5$.\n- $\\mathbf{K}_1 + \\mathbf{K}_2 + \\cdots + \\mathbf{K}_\\mathbf{L} \\leq 2 \\times 10^5$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #2] Railroad Maintenance", "background": "", "description": "You are in charge of the maintenance of a railroad network. The network consists of $\\mathbf{N}$ stations and $\\mathbf{L}$ train lines. Each train line serves a fixed list of stations bidirectionally (trains turn around in the first and last stations of the list). Transfers from one line to another in a station are possible, which means a trip in the network from station $a$ to station $b$ is possible if there is a list of train lines such that the first one serves station $a$, the last one serves station $b$, and for any consecutive pair of train lines in the list there is at least one station that they both serve.\n\nThe easiest way to do maintenance is to shut down entire lines, one at a time. However, some train lines may be essential. A train line is essential if removing it would make at least one trip between a pair of stations not possible.\n\nGiven the list of existing train lines, calculate how many of them are essential.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing two integers $\\mathbf{N}$ and $\\mathbf{L}$: the number of stations and train lines in the network. Then, $\\mathbf{L}$ groups of 2 lines follow. The first line of the $i$-th group contains a single integer $\\mathbf{K}_i$ the number of stations served by the $i$-th train line. The second line of the $i$-th group contains $\\mathbf{K}_i$ integers $\\mathbf{S}_{i,1}, \\mathbf{S}_{i,2}, \\ldots, \\mathbf{S}_{i,\\mathbf{K}_i}$ representing the stations served by the $i$-th train line.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of train lines that are essential.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the first train line is essential because it is the only one serving station $2$. Since shutting any other line down would not make travel between at least one pair of stations impossible, they are not essential.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hstw804z.png)\n\nIn Sample Case #2, no line is essential.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/iodjuwf1.png)\n\nSample Case #3 is similar to Sample Case #2, but missing the last train line. That makes all remaining train lines essential.\n\nIn Sample Case #4, the last train line is essential as there is no way to go from station $1$ to station $4$ without it. As in Sample Case #1, since this train line already connects every station, no other line is essential.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xcha3btp.png)\n\n**Sample Explanation**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{K}_i \\leq \\mathbf{N}$ for all $i$.\n- $1 \\leq \\mathbf{S}_{i,j} \\leq \\mathbf{N}$, for all $i, j$.\n- $\\mathbf{S}_{i,j} \\neq \\mathbf{S}_{i,j'}$, for all $i, j, j'$ such that $j \\neq j'$ (Each train line serves a station at most once).\n\nThe trip between all pairs of stations is possible as per the definition above when no train line is shut down.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 100$.\n- $1 \\leq \\mathbf{L} \\leq 100$.\n- $\\mathbf{K}_1 + \\mathbf{K}_2 + \\cdots + \\mathbf{K}_\\mathbf{L} \\leq 200$.\n\n**Test Set 2 (20 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 10^5$.\n- $1 \\leq \\mathbf{L} \\leq 10^5$.\n- $\\mathbf{K}_1 + \\mathbf{K}_2 + \\cdots + \\mathbf{K}_\\mathbf{L} \\leq 2 \\times 10^5$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #2] Railroad Maintenance", "background": "", "description": "你负责一个铁路网络的维护工作。该网络由 $\\mathbf{N}$ 个车站和 $\\mathbf{L}$ 条铁路线组成。每条铁路线双向服务于一个固定的车站列表（列车在列表的第一个和最后一个车站调头）。在一个车站可以从一条线路换乘到另一条线路，这意味着从车站 $a$ 到车站 $b$ 的行程是可行的，如果存在一个铁路线列表，其中第一条线路服务于车站 $a$，最后一条线路服务于车站 $b$，并且对于列表中任意两条相邻的铁路线，至少存在一个车站同时被这两条线路服务。\n\n最简单的维护方式是每次关闭整条铁路线。然而，有些铁路线可能是**关键线路**。一条铁路线是关键线路，如果移除它后会导致至少一对车站之间的行程变得不可能。\n\n给定现有的铁路线列表，计算其中有多少条是关键线路。", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例以一行包含两个整数 $\\mathbf{N}$ 和 $\\mathbf{L}$ 开始：分别表示网络中的车站数量和铁路线数量。接着是 $\\mathbf{L}$ 组数据，每组包含 2 行。第 $i$ 组的第一行包含一个整数 $\\mathbf{K}_i$，表示第 $i$ 条铁路线服务的车站数量。第 $i$ 组的第二行包含 $\\mathbf{K}_i$ 个整数 $\\mathbf{S}_{i,1}, \\mathbf{S}_{i,2}, \\ldots, \\mathbf{S}_{i,\\mathbf{K}_i}$，表示第 $i$ 条铁路线服务的车站。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是关键铁路线的数量。\n", "hint": "**样例解释**\n\n在样例 #1 中，第一条铁路线是关键线路，因为它是唯一服务于车站 $2$ 的线路。由于关闭其他任何线路都不会导致至少一对车站之间的行程变得不可能，因此它们不是关键线路。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hstw804z.png)\n\n在样例 #2 中，没有关键线路。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/iodjuwf1.png)\n\n样例 #3 与样例 #2 类似，但缺少最后一条铁路线。这使得剩余的所有铁路线都成为关键线路。\n\n在样例 #4 中，最后一条铁路线是关键线路，因为没有它就无法从车站 $1$ 到达车站 $4$。与样例 #1 类似，由于这条铁路线已经连接了所有车站，其他线路都不是关键线路。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xcha3btp.png)\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 对所有 $i$，$2 \\leq \\mathbf{K}_i \\leq \\mathbf{N}$。\n- 对所有 $i, j$，$1 \\leq \\mathbf{S}_{i,j} \\leq \\mathbf{N}$。\n- 对所有 $i, j, j'$ 且 $j \\neq j'$，$\\mathbf{S}_{i,j} \\neq \\mathbf{S}_{i,j'}$（每条铁路线中每个车站最多出现一次）。\n\n根据上述定义，当没有铁路线被关闭时，所有车站对之间的行程都是可行的。\n\n**测试集 1（9 分，可见判定）**\n- $2 \\leq \\mathbf{N} \\leq 100$。\n- $1 \\leq \\mathbf{L} \\leq 100$。\n- $\\mathbf{K}_1 + \\mathbf{K}_2 + \\cdots + \\mathbf{K}_\\mathbf{L} \\leq 200$。\n\n**测试集 2（20 分，可见判定）**\n- $2 \\leq \\mathbf{N} \\leq 10^5$。\n- $1 \\leq \\mathbf{L} \\leq 10^5$。\n- $\\mathbf{K}_1 + \\mathbf{K}_2 + \\cdots + \\mathbf{K}_\\mathbf{L} \\leq 2 \\times 10^5$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
