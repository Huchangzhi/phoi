{"pid": "P11244", "type": "P", "difficulty": 4, "samples": [["5 3 6\n1 3 2 5 6\n2 7 8 2 2\n3 5 3 4 8\n2 1 5\n1 1 2\n2 2 4\n1 1 3\n1 2 1\n2 2 3", "6\n7\n2\n"], ["6 5 20\n5 14 13 1 15 17\n7 7 19 3 8 6\n16 13 13 6 14 2\n12 5 4 17 12 3\n19 19 4 6 3 3\n2 5 3\n1 4 3\n2 1 1\n1 2 5\n2 4 6\n2 2 2\n1 4 2\n1 2 4\n2 1 1\n2 3 3\n2 3 3\n1 4 2\n1 4 1\n2 3 5\n1 3 4\n1 4 1\n1 1 4\n1 5 1\n2 2 4\n2 4 2\n", "4\n5\n12\n3\n5\n13\n13\n16\n6\n14\n"]], "limits": {"time": [900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "暴力数据结构", "洛谷原创", "O2优化", "枚举", "排序", "洛谷月赛"], "title": "吻秋", "background": "[English statement](https://www.luogu.com.cn/problem/U500140). **You must submit your code at the Chinese version of the statement.**\n\n秋雨刚刚亲吻过大地，白云便卷起赤橙黄绿青蓝紫。\n\n波长在可见光范围内自由落体，让蒸腾的水汽都带上了递进的旋律。\n\n渐变色模糊的印象总被晴天匆匆带过，但往往反常的极差让我们更加记忆犹新。\n\n所以有序，真的最优吗？", "description": "小 C 有 $m$ 个整数序列 $a_1\\dots a_m$，每个序列的长度都为 $n$。\n\n小 C 想要把自己的序列按照整数大小排序。于是小 C 有 $q$ 次操作，每次操作：\n\n- 要么，小 C 给出 $x, y\\ (x \\neq y)$，他想把 $a_x, a_y$ 拼接在一起形成长度为 $2n$ 的序列 $b$，将 $b$ 升序排序后取 $b_1\\dots b_n$ 作为新的 $a_x$，$b_{n+1}\\dots b_{2n}$ 作为新的 $a_y$；\n- 要么，小 C 给出 $i, j$，细心的小 C 想要询问你，经过前面的若干次操作后，$a_{i,j}$ 的值，你需要准确回答他的问题。", "inputFormat": "第一行，三个整数 $n, m, q$。\n\n接下来 $m$ 行，每行 $n$ 个整数，第 $i$ 行 $j$ 个整数表示 $a_{i,j}$。\n\n接下来 $q$ 行，每行三个整数，描述一次操作或询问。其格式为下述两种之一：\n\n- $\\verb!1 x y!$ 表示对 $a_x, a_y$ 进行排序，其中 $1 \\leq x \\neq y \\leq m$；\n- $\\verb!2 i j!$ 表示查询 $a_{i,j}$，其中 $1 \\leq i \\leq m$，$1 \\leq j \\leq n$。", "outputFormat": "对于每组询问，一行一个整数，表示答案。", "hint": "### 数据规模与约定\n\n**本题采用捆绑测试和子任务依赖**。\n\n因为最后两个 Subtask 的极限输入数据大小分别达到 18MB、50MB 以上，C++ 选手可以选择使用下面的 **快速输入输出模板**：\n\n```cpp\nnamespace FastIO {\n\tchar buf[1 << 21], *p1 = buf, *p2 = buf;\n#define getchar() (p1 == p2 && (p1 = buf, p2 = (p1 + fread(buf, 1, 1 << 21, stdin))) == p1 ? EOF : *p1++)\n\ttemplate <typename T> inline T read() { T x = 0, w = 0; char ch = getchar(); while (ch < '0' || ch > '9') w |= (ch == '-'), ch = getchar(); while ('0' <= ch && ch <= '9') x = x * 10 + (ch ^ '0'), ch = getchar(); return w ? -x : x; }\n\ttemplate <typename T> inline void write(T x) { if (!x) return; write<T>(x / 10), putchar((x % 10) ^ '0'); }\n\ttemplate <typename T> inline void print(T x) { if (x > 0) write<T>(x); else if (x < 0) putchar('-'), write<T>(-x); else putchar('0'); }\n\ttemplate <typename T> inline void print(T x, char en) { print<T>(x), putchar(en); }\n}; using namespace FastIO;\n#undef getchar()\n```\n\n**不保证除了 C++ 以外的语言一定能够通过，但保证对于 C++ 语言有充足的时限。**\n\n---\n\n- Subtask 0（0 pts）：样例。\n- Subtask 1（9 pts）：$n \\leq 10^4$，$q \\leq 3000$。依赖于子任务 $0$。\n- Subtask 2（23 pts）：$q \\leq 3000$。依赖于子任务 $0, 1$。\n- Subtask 3（20 pts）：$m \\leq 5$，$q \\leq 4\\times 10^5$。依赖于子任务 $0$。\n- Subtask 4（28 pts）：$q \\leq 4\\times 10^5$。依赖于子任务 $0 \\sim 3$。\n- Subtask 5（20 pts）：无特殊限制。依赖于子任务 $0 \\sim 4$。\n\n对于所有数据，满足 $1 \\leq n\\cdot m \\leq 2\\times 10^6$，$1 \\leq m \\leq 20$，$1 \\leq q \\leq 5\\times 10^6$，$1 \\leq a_{i,j} \\leq 10^7$；对于操作或询问，$1 \\leq x \\neq y \\leq m$，$1 \\leq i \\leq m$，$1 \\leq j \\leq n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "吻秋", "background": "[English statement](https://www.luogu.com.cn/problem/U500140). **You must submit your code at the Chinese version of the statement.**\n\n秋雨刚刚亲吻过大地，白云便卷起赤橙黄绿青蓝紫。\n\n波长在可见光范围内自由落体，让蒸腾的水汽都带上了递进的旋律。\n\n渐变色模糊的印象总被晴天匆匆带过，但往往反常的极差让我们更加记忆犹新。\n\n所以有序，真的最优吗？", "description": "小 C 有 $m$ 个整数序列 $a_1\\dots a_m$，每个序列的长度都为 $n$。\n\n小 C 想要把自己的序列按照整数大小排序。于是小 C 有 $q$ 次操作，每次操作：\n\n- 要么，小 C 给出 $x, y\\ (x \\neq y)$，他想把 $a_x, a_y$ 拼接在一起形成长度为 $2n$ 的序列 $b$，将 $b$ 升序排序后取 $b_1\\dots b_n$ 作为新的 $a_x$，$b_{n+1}\\dots b_{2n}$ 作为新的 $a_y$；\n- 要么，小 C 给出 $i, j$，细心的小 C 想要询问你，经过前面的若干次操作后，$a_{i,j}$ 的值，你需要准确回答他的问题。", "inputFormat": "第一行，三个整数 $n, m, q$。\n\n接下来 $m$ 行，每行 $n$ 个整数，第 $i$ 行 $j$ 个整数表示 $a_{i,j}$。\n\n接下来 $q$ 行，每行三个整数，描述一次操作或询问。其格式为下述两种之一：\n\n- $\\verb!1 x y!$ 表示对 $a_x, a_y$ 进行排序，其中 $1 \\leq x \\neq y \\leq m$；\n- $\\verb!2 i j!$ 表示查询 $a_{i,j}$，其中 $1 \\leq i \\leq m$，$1 \\leq j \\leq n$。", "outputFormat": "对于每组询问，一行一个整数，表示答案。", "hint": "### 数据规模与约定\n\n**本题采用捆绑测试和子任务依赖**。\n\n因为最后两个 Subtask 的极限输入数据大小分别达到 18MB、50MB 以上，C++ 选手可以选择使用下面的 **快速输入输出模板**：\n\n```cpp\nnamespace FastIO {\n\tchar buf[1 << 21], *p1 = buf, *p2 = buf;\n#define getchar() (p1 == p2 && (p1 = buf, p2 = (p1 + fread(buf, 1, 1 << 21, stdin))) == p1 ? EOF : *p1++)\n\ttemplate <typename T> inline T read() { T x = 0, w = 0; char ch = getchar(); while (ch < '0' || ch > '9') w |= (ch == '-'), ch = getchar(); while ('0' <= ch && ch <= '9') x = x * 10 + (ch ^ '0'), ch = getchar(); return w ? -x : x; }\n\ttemplate <typename T> inline void write(T x) { if (!x) return; write<T>(x / 10), putchar((x % 10) ^ '0'); }\n\ttemplate <typename T> inline void print(T x) { if (x > 0) write<T>(x); else if (x < 0) putchar('-'), write<T>(-x); else putchar('0'); }\n\ttemplate <typename T> inline void print(T x, char en) { print<T>(x), putchar(en); }\n}; using namespace FastIO;\n#undef getchar()\n```\n\n**不保证除了 C++ 以外的语言一定能够通过，但保证对于 C++ 语言有充足的时限。**\n\n---\n\n- Subtask 0（0 pts）：样例。\n- Subtask 1（9 pts）：$n \\leq 10^4$，$q \\leq 3000$。依赖于子任务 $0$。\n- Subtask 2（23 pts）：$q \\leq 3000$。依赖于子任务 $0, 1$。\n- Subtask 3（20 pts）：$m \\leq 5$，$q \\leq 4\\times 10^5$。依赖于子任务 $0$。\n- Subtask 4（28 pts）：$q \\leq 4\\times 10^5$。依赖于子任务 $0 \\sim 3$。\n- Subtask 5（20 pts）：无特殊限制。依赖于子任务 $0 \\sim 4$。\n\n对于所有数据，满足 $1 \\leq n\\cdot m \\leq 2\\times 10^6$，$1 \\leq m \\leq 20$，$1 \\leq q \\leq 5\\times 10^6$，$1 \\leq a_{i,j} \\leq 10^7$；对于操作或询问，$1 \\leq x \\neq y \\leq m$，$1 \\leq i \\leq m$，$1 \\leq j \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P11245", "type": "P", "difficulty": 6, "samples": [["5\n1 2 3 5\n3 3 4 6\n5 6 11 13\n10 15 33 22\n10 13 11 11", "No\nYes\nNo\nYes\nNo"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "洛谷原创", "Special Judge", "O2优化", "构造", "洛谷月赛"], "title": "残雪", "background": "[English statement](https://www.luogu.com.cn/problem/U500139). **You must submit your code at the Chinese version of the statement.**\n\n如果我再和你走在同一条路上的话，我也会把远方的星星讲过无限的话再跟你说一遍吧。\n\n你微笑着把竖起的手指放在嘴角，似乎是在暗示我，原来你就是远方的 Polestar 罢了。\n\n令人伤感的事情是，这个世界上没有了小王子，也没有了去年今日的那位飞行员。\n\n试问闲愁都几许？一川烟草，满城风絮，梅子黄时雨。\n\n![](https://pic.imgdb.cn/item/670fd597d29ded1a8c604148.png)", "description": "给出集合 $S$。我们定义一个 $\\tt 01$ 串 $t$ 是不好的，当且仅当存在 $k \\in S$，使得 $t$ 包含一个长度为 $2k$ 的子串 $t'$，且 $t'$ 恰好包含 $k$ 个 $\\tt 0$ 和 $k$ 个 $\\tt 1$。对立地，一个 $\\tt 01$ 串如果不是不好的，那么它就是好的。\n\n小 Y 有 $q$ 组询问，每次给出 $L, R, m, n$，表示 $S = \\{x \\in \\N_+ \\mid L \\leq x \\leq R\\}$，判断是否存在一个好的字符串 $t$ 满足 $t$ 恰好包含 $m$ 个 $\\tt 0$ 和 $n$ 个 $\\tt 1$。", "inputFormat": "第一行，一个整数 $q$，表示询问个数。对于每组询问：\n\n- 仅一行，四个整数 $L, R, m, n$。", "outputFormat": "输出共 $q$ 行。对于每组询问，一行一个字符串 `Yes` 或 `No` 表示你的答案：你应当输出 `Yes`，当且仅当你对小 Y 的问题的回答是肯定的。\n\n本题中字符串大小写不敏感，即 `yEs`、`yes`、`Yes`、`YES` 等都被认为是 `Yes`；`No` 同理。", "hint": "### 样例解释\n\n- 对于第一组数据，因为包含 $\\tt 0, 1$ 但 $L = 1$，所以一定不合法。\n- 对于第二组数据，存在 $t = \\tt 0011111100$。容易证明这是合法的。\n- 对于第三组数据，事实确实如此。\n- 对于其它数据，暂时不能给你一个明确的答复。\n\n### 数据规模与约定\n\n**本题采用捆绑测试和子任务依赖。**\n\n- Subtask 0（0 pts）：样例。\n- Subtask 1（13 pts）：$q \\leq 10^3$，$n + m \\leq 14$，$R \\leq 14$。\n- Subtask 2（20 pts）：$\\sum \\max(n, m, L, R) \\leq 5\\times 10^3 + 5$。依赖于子任务 $0$。\n- Subtask 3（13 pts）：$\\sum \\max(n, m, L, R) \\leq 10^7 + 100$。依赖于子任务 $0 \\sim 2$。\n- Subtask 4（13 pts）：$L = R$。\n- Subtask 5（41 pts）：无特殊限制。依赖于子任务 $0 \\sim 4$。\n\n对于所有数据，保证 $1 \\leq q \\leq 10^5$，$1 \\leq L \\leq R \\leq 10^{18}$，$0 \\leq n, m \\leq 10^{18}$，$n + m \\geq 1$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "残雪", "background": "[English statement](https://www.luogu.com.cn/problem/U500139). **You must submit your code at the Chinese version of the statement.**\n\n如果我再和你走在同一条路上的话，我也会把远方的星星讲过无限的话再跟你说一遍吧。\n\n你微笑着把竖起的手指放在嘴角，似乎是在暗示我，原来你就是远方的 Polestar 罢了。\n\n令人伤感的事情是，这个世界上没有了小王子，也没有了去年今日的那位飞行员。\n\n试问闲愁都几许？一川烟草，满城风絮，梅子黄时雨。\n\n![](https://pic.imgdb.cn/item/670fd597d29ded1a8c604148.png)", "description": "给出集合 $S$。我们定义一个 $\\tt 01$ 串 $t$ 是不好的，当且仅当存在 $k \\in S$，使得 $t$ 包含一个长度为 $2k$ 的子串 $t'$，且 $t'$ 恰好包含 $k$ 个 $\\tt 0$ 和 $k$ 个 $\\tt 1$。对立地，一个 $\\tt 01$ 串如果不是不好的，那么它就是好的。\n\n小 Y 有 $q$ 组询问，每次给出 $L, R, m, n$，表示 $S = \\{x \\in \\N_+ \\mid L \\leq x \\leq R\\}$，判断是否存在一个好的字符串 $t$ 满足 $t$ 恰好包含 $m$ 个 $\\tt 0$ 和 $n$ 个 $\\tt 1$。", "inputFormat": "第一行，一个整数 $q$，表示询问个数。对于每组询问：\n\n- 仅一行，四个整数 $L, R, m, n$。", "outputFormat": "输出共 $q$ 行。对于每组询问，一行一个字符串 `Yes` 或 `No` 表示你的答案：你应当输出 `Yes`，当且仅当你对小 Y 的问题的回答是肯定的。\n\n本题中字符串大小写不敏感，即 `yEs`、`yes`、`Yes`、`YES` 等都被认为是 `Yes`；`No` 同理。", "hint": "### 样例解释\n\n- 对于第一组数据，因为包含 $\\tt 0, 1$ 但 $L = 1$，所以一定不合法。\n- 对于第二组数据，存在 $t = \\tt 0011111100$。容易证明这是合法的。\n- 对于第三组数据，事实确实如此。\n- 对于其它数据，暂时不能给你一个明确的答复。\n\n### 数据规模与约定\n\n**本题采用捆绑测试和子任务依赖。**\n\n- Subtask 0（0 pts）：样例。\n- Subtask 1（13 pts）：$q \\leq 10^3$，$n + m \\leq 14$，$R \\leq 14$。\n- Subtask 2（20 pts）：$\\sum \\max(n, m, L, R) \\leq 5\\times 10^3 + 5$。依赖于子任务 $0$。\n- Subtask 3（13 pts）：$\\sum \\max(n, m, L, R) \\leq 10^7 + 100$。依赖于子任务 $0 \\sim 2$。\n- Subtask 4（13 pts）：$L = R$。\n- Subtask 5（41 pts）：无特殊限制。依赖于子任务 $0 \\sim 4$。\n\n对于所有数据，保证 $1 \\leq q \\leq 10^5$，$1 \\leq L \\leq R \\leq 10^{18}$，$0 \\leq n, m \\leq 10^{18}$，$n + m \\geq 1$。", "locale": "zh-CN"}}}
{"pid": "P11246", "type": "P", "difficulty": 2, "samples": [["18\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2024", "GESP"], "title": "[GESP202409 六级] 小杨和整数拆分", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1162>", "description": "小杨有一个正整数 $n$，小杨想将它拆分成若干完全平方数的和，同时小杨希望拆分的数量越少越好。\n\n编程计算总和为 $n$ 的完全平方数的最小数量。", "inputFormat": "输入只有一行一个正整数 $n$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "### 数据规模与约定\n\n对全部的测试数据，保证 $1 \\leq n \\leq 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GESP202409 六级] 小杨和整数拆分", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1162>", "description": "小杨有一个正整数 $n$，小杨想将它拆分成若干完全平方数的和，同时小杨希望拆分的数量越少越好。\n\n编程计算总和为 $n$ 的完全平方数的最小数量。", "inputFormat": "输入只有一行一个正整数 $n$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "### 数据规模与约定\n\n对全部的测试数据，保证 $1 \\leq n \\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P11247", "type": "P", "difficulty": 3, "samples": [["3 5 10\n1 1 2 3 3\n9 1 10 10 1", "4"], ["2 4 10\n1 1 1 2\n1 2 7 10", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2024", "GESP"], "title": "[GESP202409 六级] 算法学习", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1162>", "description": "小杨计划学习 $m$ 种算法，为此他找了 $n$ 道题目来帮助自己学习，每道题目最多学习一次。\n\n小杨对于 $m$ 种算法的初始掌握程度均为 $0$。第 $i$ 道题目有对应的知识点 $a_i$，即学习第 $i$ 道题目可以令小杨对第 $a_i$ 种算法的掌握程度提高 $b_i$。小杨的学习目标是对于 $m$ 种算法的掌握程度均至少为 $k$。\n\n小杨认为连续学习两道相同知识点的题目是不好的，小杨想请你编写程序帮他计算出他最少需要学习多少道题目才能使得他在完成学习目标的同时避免连续学习两道相同知识点的题目。", "inputFormat": "第一行三个正整数 $m, n, k$，代表算法种类数，题目数和目标掌握程度。  \n第二行 $n$ 个正整数 $a_1, a_2, ..., a_n$，代表每道题目的知识点。  \n第三行 $n$ 个正整数 $b_1, b_2, ..., b_n$，代表每道题目提升的掌握程度。", "outputFormat": "输出一个整数，代表小杨最少需要学习题目的数量，如果不存在满足条件的方案，输出 -1。", "hint": "### 样例 1 解释\n\n一种最优学习顺序为第一道题，第三道题，第四道题，第二道题。\n\n### 数据规模与约定\n\n| 子任务编号 | 数据点占比 | $m$ | $n$ | $b_i$ | $k$ |\n| :-: | :-: | :-: | :-: | :-: | :-: |\n| $1$ | $30\\%$ | $2$ | $\\leq 9$ | $\\leq 10$ | $\\leq 10$ |\n| $2$ | $30\\%$ | $\\leq 9$ | $\\leq 9$ | $\\leq 10$ | $\\leq 10$ |\n| $3$ | $40\\%$ | $\\leq 10^5$ | $\\leq 10^5$ | $\\leq 10^5$ | $\\leq 10^5$ |\n\n对于全部数据，保证有 $1 \\leq m, n, b_i, k \\leq 10^5$，$1 \\leq a_i \\leq m$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GESP202409 六级] 算法学习", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1162>", "description": "小杨计划学习 $m$ 种算法，为此他找了 $n$ 道题目来帮助自己学习，每道题目最多学习一次。\n\n小杨对于 $m$ 种算法的初始掌握程度均为 $0$。第 $i$ 道题目有对应的知识点 $a_i$，即学习第 $i$ 道题目可以令小杨对第 $a_i$ 种算法的掌握程度提高 $b_i$。小杨的学习目标是对于 $m$ 种算法的掌握程度均至少为 $k$。\n\n小杨认为连续学习两道相同知识点的题目是不好的，小杨想请你编写程序帮他计算出他最少需要学习多少道题目才能使得他在完成学习目标的同时避免连续学习两道相同知识点的题目。", "inputFormat": "第一行三个正整数 $m, n, k$，代表算法种类数，题目数和目标掌握程度。  \n第二行 $n$ 个正整数 $a_1, a_2, ..., a_n$，代表每道题目的知识点。  \n第三行 $n$ 个正整数 $b_1, b_2, ..., b_n$，代表每道题目提升的掌握程度。", "outputFormat": "输出一个整数，代表小杨最少需要学习题目的数量，如果不存在满足条件的方案，输出 -1。", "hint": "### 样例 1 解释\n\n一种最优学习顺序为第一道题，第三道题，第四道题，第二道题。\n\n### 数据规模与约定\n\n| 子任务编号 | 数据点占比 | $m$ | $n$ | $b_i$ | $k$ |\n| :-: | :-: | :-: | :-: | :-: | :-: |\n| $1$ | $30\\%$ | $2$ | $\\leq 9$ | $\\leq 10$ | $\\leq 10$ |\n| $2$ | $30\\%$ | $\\leq 9$ | $\\leq 9$ | $\\leq 10$ | $\\leq 10$ |\n| $3$ | $40\\%$ | $\\leq 10^5$ | $\\leq 10^5$ | $\\leq 10^5$ | $\\leq 10^5$ |\n\n对于全部数据，保证有 $1 \\leq m, n, b_i, k \\leq 10^5$，$1 \\leq a_i \\leq m$。", "locale": "zh-CN"}}}
{"pid": "P11248", "type": "P", "difficulty": 2, "samples": [["2\n3 3 1\n000\n111\n01?\n3 3 1\n000\n?0?\n01?\n", "4\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2024", "GESP"], "title": "[GESP202409 七级] 矩阵移动", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1163>", "description": "小杨有一个 $n \\times m$ 的矩阵，仅包含 `01?` 三种字符。矩阵的行从上到下编号依次为 $1,2,\\dots, n$，列从左到右编号依次为 $1, 2, \\dots, m$。小杨开始在矩阵的左上角 $(1,1)$，小杨只能向下或者向右移动，最终到达右下角 $(n, m)$ 时停止，在移动的过程中每经过一个字符 `1` 得分会增加一分（包括起点和终点），经过其它字符则分数不变。小杨的初始分数为 $0$ 分。\n\n小杨可以将矩阵中不超过 $x$ 个字符 `?` 变为字符  `1`。小杨在修改矩阵后，会以最优的策略从左上角移动到右下角。他想知道自己最多能获得多少分。", "inputFormat": "第一行包含一个正整数 $t$，代表测试用例组数，接下来是 $t$ 组测试用例。对于每组测试用例，一共 $n + 1$ 行。\n\n第一行包含三个正整数 $n, m, x$，含义如题面所示。  \n之后 $n$ 行，每行一个长度为 $m$ 的仅含 `01?` 的字符串。", "outputFormat": "对于每组测试用例，输出一行一个整数，代表最优策略下小杨的得分最多是多少。", "hint": "### 样例 1 解释\n\n对于第二组测试用例，将 $(2,1)$ 或者 $(3,3)$ 变为 $1$ 均是最优策略。\n\n### 数据规模与约定\n\n| 子任务编号 | 数据点占比 | $t$ | $n,m$ | $x$ |\n| :-: | :-: | :-: | :-: | :-: |\n| $1$ | $30\\%$ | $\\leq 5$ | $\\le 10$ | $=1$ |\n| $2$ | $30\\%$ | $\\le 10$ | $\\le 500$ | $\\le 30$ |\n| $3$ | $40\\%$ | $\\le 10$ | $\\le 500$ | $\\le 300$ |\n\n对全部的测试数据，保证 $1 \\leq t \\leq 10$，$1 \\leq n,m \\leq 500$，$1 \\leq x \\leq 300$，保证所有测试用例 $n \\times m$ 的总和不超过 $2.5 \\times 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GESP202409 七级] 矩阵移动", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1163>", "description": "小杨有一个 $n \\times m$ 的矩阵，仅包含 `01?` 三种字符。矩阵的行从上到下编号依次为 $1,2,\\dots, n$，列从左到右编号依次为 $1, 2, \\dots, m$。小杨开始在矩阵的左上角 $(1,1)$，小杨只能向下或者向右移动，最终到达右下角 $(n, m)$ 时停止，在移动的过程中每经过一个字符 `1` 得分会增加一分（包括起点和终点），经过其它字符则分数不变。小杨的初始分数为 $0$ 分。\n\n小杨可以将矩阵中不超过 $x$ 个字符 `?` 变为字符  `1`。小杨在修改矩阵后，会以最优的策略从左上角移动到右下角。他想知道自己最多能获得多少分。", "inputFormat": "第一行包含一个正整数 $t$，代表测试用例组数，接下来是 $t$ 组测试用例。对于每组测试用例，一共 $n + 1$ 行。\n\n第一行包含三个正整数 $n, m, x$，含义如题面所示。  \n之后 $n$ 行，每行一个长度为 $m$ 的仅含 `01?` 的字符串。", "outputFormat": "对于每组测试用例，输出一行一个整数，代表最优策略下小杨的得分最多是多少。", "hint": "### 样例 1 解释\n\n对于第二组测试用例，将 $(2,1)$ 或者 $(3,3)$ 变为 $1$ 均是最优策略。\n\n### 数据规模与约定\n\n| 子任务编号 | 数据点占比 | $t$ | $n,m$ | $x$ |\n| :-: | :-: | :-: | :-: | :-: |\n| $1$ | $30\\%$ | $\\leq 5$ | $\\le 10$ | $=1$ |\n| $2$ | $30\\%$ | $\\le 10$ | $\\le 500$ | $\\le 30$ |\n| $3$ | $40\\%$ | $\\le 10$ | $\\le 500$ | $\\le 300$ |\n\n对全部的测试数据，保证 $1 \\leq t \\leq 10$，$1 \\leq n,m \\leq 500$，$1 \\leq x \\leq 300$，保证所有测试用例 $n \\times m$ 的总和不超过 $2.5 \\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P11249", "type": "P", "difficulty": 3, "samples": [["2\n5\n0 1 0 1 0\n1 2\n1 3\n3 4\n3 5\n5\n1 1 1 1 1\n1 2\n1 3\n3 4\n3 5\n", "Yes\nNo\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "2024", "深度优先搜索 DFS", "树形 DP", "树的遍历", "GESP"], "title": "[GESP202409 七级] 小杨寻宝", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1163>", "description": "小杨有一棵包含 $n$ 个节点的树，树上的一些节点放置有宝物。\n\n小杨可以任意选择一个节点作为起点并在树上移动，但是小杨只能经过每条边至多一次，当小杨经过一条边后，这条边就会消失。小杨每经过一个放置有宝物的节点就会取得该宝物。\n\n小杨想请你帮他判断自己能否成功取得所有宝物。", "inputFormat": "\n**本题单个测试点内有多组测试数据**。输入第一行包含一个正整数 $t$，代表测试用例组数。  \n接下来是 $t$ 组测试用例。对于每组测试用例，一共 $n+1$ 行。\n\n第一行包含一个正整数 $n$，代表树的节点数。  \n第二行包含 $n$ 个非负整数 $a_1, a_2, \\dots a_n$，其中如果 $a_i = 1$，则节点 $i$ 放置有宝物；若 $a_i = 0$，则节点 $i$ 没有宝物。  \n之后 $n - 1$ 行，每行包含两个正整数 $x_i, y_i$，代表存在一条连接节点 $x_i$ 和 $y_i$ 的边。\n", "outputFormat": "\n对于每组测试数据，如果小杨能成功取得所有宝物，输出 Yes，否则输出 No。", "hint": "\n### 样例 1 解释\n\n对于第一组测试用例，小杨从节点 $2$ 出发，按照 $2-1-3-4$ 的顺序即可成功取得所有宝物。\n\n### 数据规模与约定\n\n| 子任务编号 | 数据点占比 | $t$ | $n$ |\n| :-: | :-: | :-: | :-: |\n| $1$ | $20\\%$ | $\\leq 10$ | $\\leq 5$ |\n| $2$ | $20\\%$ | $\\leq 10$ | $\\leq 10^3$ |\n| $3$ | $60\\%$ | $\\leq 10$ | $\\leq 10^5$ |\n\n对全部的测试点，保证 $1 \\leq t \\leq 10$，$1 \\leq n \\leq 10^5$，$0 \\leq a_i \\leq 1$，且保证树上至少有一个点放置有宝物。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GESP202409 七级] 小杨寻宝", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1163>", "description": "小杨有一棵包含 $n$ 个节点的树，树上的一些节点放置有宝物。\n\n小杨可以任意选择一个节点作为起点并在树上移动，但是小杨只能经过每条边至多一次，当小杨经过一条边后，这条边就会消失。小杨每经过一个放置有宝物的节点就会取得该宝物。\n\n小杨想请你帮他判断自己能否成功取得所有宝物。", "inputFormat": "\n**本题单个测试点内有多组测试数据**。输入第一行包含一个正整数 $t$，代表测试用例组数。  \n接下来是 $t$ 组测试用例。对于每组测试用例，一共 $n+1$ 行。\n\n第一行包含一个正整数 $n$，代表树的节点数。  \n第二行包含 $n$ 个非负整数 $a_1, a_2, \\dots a_n$，其中如果 $a_i = 1$，则节点 $i$ 放置有宝物；若 $a_i = 0$，则节点 $i$ 没有宝物。  \n之后 $n - 1$ 行，每行包含两个正整数 $x_i, y_i$，代表存在一条连接节点 $x_i$ 和 $y_i$ 的边。\n", "outputFormat": "\n对于每组测试数据，如果小杨能成功取得所有宝物，输出 Yes，否则输出 No。", "hint": "\n### 样例 1 解释\n\n对于第一组测试用例，小杨从节点 $2$ 出发，按照 $2-1-3-4$ 的顺序即可成功取得所有宝物。\n\n### 数据规模与约定\n\n| 子任务编号 | 数据点占比 | $t$ | $n$ |\n| :-: | :-: | :-: | :-: |\n| $1$ | $20\\%$ | $\\leq 10$ | $\\leq 5$ |\n| $2$ | $20\\%$ | $\\leq 10$ | $\\leq 10^3$ |\n| $3$ | $60\\%$ | $\\leq 10$ | $\\leq 10^5$ |\n\n对全部的测试点，保证 $1 \\leq t \\leq 10$，$1 \\leq n \\leq 10^5$，$0 \\leq a_i \\leq 1$，且保证树上至少有一个点放置有宝物。", "locale": "zh-CN"}}}
{"pid": "P11250", "type": "P", "difficulty": 3, "samples": [["2\n5 6 2\n5 1 5", "120\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "组合数学", "排列组合", "GESP"], "title": "[GESP202409 八级] 手套配对", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1164>", "description": "小杨有 $n$ 对不同的手套，每对手套由左右各一只组成。\n\n小杨想知道从中取出 $m$ 只手套，$m$ 只手套恰好包含 $k$ 对手套的情况有多少种。\n\n小杨认为两种取出的情况不同，当且仅当两种情况取出的手套中存在不同的手套（同一对手套的左右手也视为不同的手套）。", "inputFormat": "**本题单个测试点内有多组测试数据**。\n\n第一行包含一个正整数 $t$，代表测试用例组数。\n\n接下来是 $t$ 组测试用例。对于每组测试用例，一共一行。\n\n第一行包含三个正整数 $n,m,k$，代表手套数量，取出的手套数和目标对数。", "outputFormat": "对于每组测试数据，输出一个整数，代表可能的情况数量对 $10^9+7$ 取模的结果。", "hint": "::cute-table{tuack}\n\n| 子任务 | 占比 | $t$ | $n$ | $m$ | $k$ |\n| :-: | :-: | :-: | :-: | :-: | :-: |\n| $1$ | $30\\%$ | $\\leq 5$ | $\\leq 1000$ | $\\le 3$ | $=1$ |\n| $2$ | $30\\%$ | $\\leq 5$ | $\\leq 5$ | $\\leq 10$ | $\\leq 5$ |\n| $3$ | $40\\%$ | $\\leq 10^5$ | $\\leq 1000$ | $\\leq 2000$ | $\\leq 2000$ |\n\n对全部的测试数据，保证 $1 \\leq t \\leq 10^5,1 \\leq n \\leq 1000,1 \\leq m \\leq 2 \\times n,1 \\leq k \\leq n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GESP202409 八级] 手套配对", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1164>", "description": "小杨有 $n$ 对不同的手套，每对手套由左右各一只组成。\n\n小杨想知道从中取出 $m$ 只手套，$m$ 只手套恰好包含 $k$ 对手套的情况有多少种。\n\n小杨认为两种取出的情况不同，当且仅当两种情况取出的手套中存在不同的手套（同一对手套的左右手也视为不同的手套）。", "inputFormat": "**本题单个测试点内有多组测试数据**。\n\n第一行包含一个正整数 $t$，代表测试用例组数。\n\n接下来是 $t$ 组测试用例。对于每组测试用例，一共一行。\n\n第一行包含三个正整数 $n,m,k$，代表手套数量，取出的手套数和目标对数。", "outputFormat": "对于每组测试数据，输出一个整数，代表可能的情况数量对 $10^9+7$ 取模的结果。", "hint": "::cute-table{tuack}\n\n| 子任务 | 占比 | $t$ | $n$ | $m$ | $k$ |\n| :-: | :-: | :-: | :-: | :-: | :-: |\n| $1$ | $30\\%$ | $\\leq 5$ | $\\leq 1000$ | $\\le 3$ | $=1$ |\n| $2$ | $30\\%$ | $\\leq 5$ | $\\leq 5$ | $\\leq 10$ | $\\leq 5$ |\n| $3$ | $40\\%$ | $\\leq 10^5$ | $\\leq 1000$ | $\\leq 2000$ | $\\leq 2000$ |\n\n对全部的测试数据，保证 $1 \\leq t \\leq 10^5,1 \\leq n \\leq 1000,1 \\leq m \\leq 2 \\times n,1 \\leq k \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P11251", "type": "P", "difficulty": 3, "samples": [["5\n1 0 0 1 0\n1 2\n3 5\n4 3\n1 3", "4"], ["5\n0 0 0 0 0\n1 2\n2 3\n3 4\n4 5", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2024", "GESP"], "title": "[GESP202409 八级] 美丽路径", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1164>", "description": "小杨有一棵包含 $n$ 个节点的树，节点从 $1$ 到 $n$ 编号，并且每个节点要么是白色，要么是黑色。\n\n对于树上的一条简单路径（不经过重复节点的路径），小杨认为它是**美丽**的当且仅当路径上相邻节点的颜色均不相同。例如下图，其中节点 $1$ 和节点 $4$ 是黑色，其余节点是白色，路径 $2-1-3-4$ 是美丽路径，而路径 $2-1-3-5$ 不是美丽路径（相邻节点 $3$ 和 $5$ 颜色相同）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zyz3v6jo.png)\n\n对于树上的一条简单路径，小杨认为它的长度是路径包含节点的数量。小杨想知道**最长的美丽路径**的长度是多少。", "inputFormat": "第一行包含一个正整数 $n$，代表节点数量。\n\n第二行包含 $n$ 个整数 $c_1,c_2,\\dots,c_n$，代表每个节点的颜色，如果 $c_i=0$，代表节点 $i$ 为白色，如果 $c_i=1$，代表节点 $i$ 为黑色。\n\n之后 $n-1$ 行，每行包含两个正整数 $u_i,v_i$，代表存在一条连接节点 $u_i$ 和节点 $v_i$ 的边。", "outputFormat": "输出一个整数，代表最长美丽路径的长度。", "hint": "| 子任务编号 | 数据点占比 | $n$ | 特殊条件 |\n| :-: | :-: | :-: | :-: |\n| $1$ | $30\\%$ | $\\leq 1000$ | 树的形态是一条链 |\n| $2$ | $30\\%$ | $\\leq 1000$ |  |\n| $3$ | $40\\%$ | $\\leq 10^5$ |  |\n\n对于全部数据，保证有 $1 \\leq n \\leq 10^5,0 \\leq c_i \\leq 1$，同时保证给出的数据构成一棵树。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GESP202409 八级] 美丽路径", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1164>", "description": "小杨有一棵包含 $n$ 个节点的树，节点从 $1$ 到 $n$ 编号，并且每个节点要么是白色，要么是黑色。\n\n对于树上的一条简单路径（不经过重复节点的路径），小杨认为它是**美丽**的当且仅当路径上相邻节点的颜色均不相同。例如下图，其中节点 $1$ 和节点 $4$ 是黑色，其余节点是白色，路径 $2-1-3-4$ 是美丽路径，而路径 $2-1-3-5$ 不是美丽路径（相邻节点 $3$ 和 $5$ 颜色相同）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zyz3v6jo.png)\n\n对于树上的一条简单路径，小杨认为它的长度是路径包含节点的数量。小杨想知道**最长的美丽路径**的长度是多少。", "inputFormat": "第一行包含一个正整数 $n$，代表节点数量。\n\n第二行包含 $n$ 个整数 $c_1,c_2,\\dots,c_n$，代表每个节点的颜色，如果 $c_i=0$，代表节点 $i$ 为白色，如果 $c_i=1$，代表节点 $i$ 为黑色。\n\n之后 $n-1$ 行，每行包含两个正整数 $u_i,v_i$，代表存在一条连接节点 $u_i$ 和节点 $v_i$ 的边。", "outputFormat": "输出一个整数，代表最长美丽路径的长度。", "hint": "| 子任务编号 | 数据点占比 | $n$ | 特殊条件 |\n| :-: | :-: | :-: | :-: |\n| $1$ | $30\\%$ | $\\leq 1000$ | 树的形态是一条链 |\n| $2$ | $30\\%$ | $\\leq 1000$ |  |\n| $3$ | $40\\%$ | $\\leq 10^5$ |  |\n\n对于全部数据，保证有 $1 \\leq n \\leq 10^5,0 \\leq c_i \\leq 1$，同时保证给出的数据构成一棵树。", "locale": "zh-CN"}}}
{"pid": "P11252", "type": "P", "difficulty": 6, "samples": [["4\n0 2", "1\n4\n0 1\n0 2\n0 3\n4 2\n2\n4\n4 0\n3 4\n2 3\n2 1\n1\n0 2 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["图论", "2024", "交互题", "Special Judge", "KOI（韩国）"], "title": "[KTSC 2024 R2] 岛屿", "background": "**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include<vector>\n#include<array>\nvoid construct_two_trees(int N, std::vector<int> U, std::vector<int> V);\nint add_vertex(int a, int b, int c);\nvoid report(std::vector<std::array<int, 2>> tree);\n```", "description": "**题目译自 [2024년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2024/)  T1 「[섬](https://assets.ioikorea.kr/ioitst/2024/2/island/island_statement.pdf)」**\n\nIOI 国建立在一个正 $N$ 边形的岛屿上。每个顶点代表一个区域，这些区域按顺时针方向依次编号为 $0, 1, \\cdots, N-1$。IOI 国的道路网络由以下两种道路组成：\n\n- **海滨道路**：海滨道路连接正 $N$ 边形相邻顶点对应的区域，共有 $N$ 条道路。也就是说，对于所有 $i$ $(0 \\leq i \\leq N-2)$，存在连接 $i$ 区域和 $i+1$ 区域的道路，并且存在连接 $N-1$ 区域和 0 区域的道路。\n- **内陆道路**：内陆道路连接不直接相邻的两个区域，共有 $N-3$ 条道路。这些道路除了端点外不相交，即它们对应于正 $N$ 边形中不相交的 $N-3$ 条对角线。\n\n对于连接 $K$ 个区域的道路网络，如果道路集合 $T$ 满足以下条件，则称 $T$ 为一棵树：\n\n- $|T|=K-1$\n- 仅使用 $T$ 中的道路可以在所有区域之间通行。\n\n树在连接所有区域的运输中起着重要作用。如果在一棵树的道路无法使用时，仍有另一棵树可以使用，这将大大提高稳定性。因此，如果道路网络中存在两棵树 $T_1$ 和 $T_2$，且 $T_1 \\cap T_2 = \\emptyset$，即没有任何道路重叠，则称该道路网络为良好道路网络。\n\nIOI 国计划通过以下方式建设新的区域和道路，以构建良好道路网络：\n\n- **区域建设**：对于区域 $a, b, c$，如果存在连接 $a$ 和 $b$、$b$ 和 $c$、$c$ 和 $a$ 的道路，则在这三个区域形成的三角形的内心处建立一个新区域 $d$，并连接 $a$ 和 $d$、$b$ 和 $d$、$c$ 和 $d$。新区域 $d$ 的编号从 $N$ 开始依次递增。对于相同的三个区域，不能进行多次区域建设，即每次建设使用的区域集合 $\\{a, b, c\\}$ 必须不同。\n\nIOI 国可以进行多次区域建设，但希望通过尽可能少的建设次数，构建出没有重叠道路的两棵树的良好道路网络。请注意，良好道路网络不仅包括原有的 $N$ 个区域，还包括新建的区域。你需要帮助 IOI 国解决这个道路网络问题。即使没有最小化建设次数，也可以获得部分分数。\n\n你需要实现以下函数：\n\n```cpp\nvoid construct_two_trees(int N, std::vector<int> U, std::vector<int> V);\n```\n\n- `U, V`：大小为 $N-3$ 的整数数组。对于所有 $i$ $(0 \\leq i \\leq N-4)$，存在连接 $U[i]$ 和 $V[i]$ 的内陆道路。\n- 该函数只会被调用一次，你需要在该函数内调用后续定义的 `add_vertex` 函数进行区域建设，并找到不共享道路的两棵树，然后调用 `report` 函数报告结果。\n\n```cpp\nint add_vertex(int a, int b, int c);\n```\n\n- 该函数表示在区域 $a, b, c$ 之间进行区域建设。\n- 在调用该函数之前，区域 $a, b, c$ 中任意两个区域必须直接相连。\n- 对于相同的三个区域，不能多次调用该函数，即每次建设使用的区域集合 $\\{a, b, c\\}$ 必须不同。\n- 该函数返回新建区域的编号。即，当该函数第 $j$ 次执行时，返回 $N-1+j$。\n- 在调用 `report` 函数后，不应再调用该函数。\n\n```cpp\nvoid report(std::vector<std::array<int, 2>> tree);\n```\n\n- 该函数用于报告找到的树。\n- 在 `construct_two_trees` 函数中，所有 `add_vertex` 函数调用结束后，必须准确调用两次该函数。\n- 参数 `tree` 的每个元素是一个包含两区域编号的数组 `std::array<int, 2>`。区域编号的顺序无关紧要。\n- 两次调用 `report(T1), report(T2)` 时，$T_1$ 和 $T_2$ 不应共享道路，并且每棵树的道路应能连接所有区域，包括新建区域。\n", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N$\n- 第 $2+i$ $(0 \\leq i \\leq N-4)$ 行：$U[i]\\,V[i]$\n", "outputFormat": "示例评测程序按以下格式输出：\n\n每次调用 `report` 函数时，评测程序输出：\n\n- 第 $1$ 行：整数 $k$，表示第 $k$ 次调用 `report` 函数。\n- 第 $2$ 行：树的道路数量 $M$\n- 第 $2+i$ $(1 \\leq i \\leq M)$ 行：树的第 $i$ 条道路的两个端点编号 $A[i]\\,B[i]$\n\n在 `construct_two_trees` 函数执行完毕后，评测程序输出 `add_vertex` 函数的调用信息：\n\n- 第 $1$ 行：`add_vertex` 函数的总调用次数 $K$\n- 第 $1+i$ $(1 \\leq i \\leq K)$ 行：`add_vertex` 函数第 $i$ 次调用的参数 $A[i]\\,B[i]\\,C[i]$", "hint": "对于所有输入数据，满足：\n\n- $3 \\leq N \\leq 2\\cdot 10^5$\n- 对于所有 $i$ $(0 \\leq i \\leq N-4)$：\n  - $0 \\leq U[i], V[i] \\leq N-1$\n  - $U[i] \\neq V[i]$\n- 给定的 $U$ 和 $V$ 满足内陆道路的条件。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :-: | :-: | :-: |\n| $1$ | $6$ | $N \\leq 5$ |\n| $2$ | $8$ | 存在一个区域与除自己外的所有区域直接相连 |\n| $3$ | $14$ | 初始状态下，对于所有可能的区域对 $(a, b, c)$，连接这三个区域的三条道路中至少有一条是海滨道路 |\n| $4$ | $21$ | $N \\leq 5000$ |\n| $5$ | $51$ | 无附加限制 |\n\n当 `construct_two_trees` 函数正确解决了问题时，如果 `add_vertex` 的调用次数大于最小值但不超过 $N$，则可以获得 $40\\%$ 的分数。如果 `add_vertex` 的调用次数超过 $N$，则无法获得分数。可以证明，在给定限制条件下，可以通过不超过 $N$ 次调用 `add_vertex` 构建良好道路网络。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KTSC 2024 R2] 岛屿", "background": "**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include<vector>\n#include<array>\nvoid construct_two_trees(int N, std::vector<int> U, std::vector<int> V);\nint add_vertex(int a, int b, int c);\nvoid report(std::vector<std::array<int, 2>> tree);\n```", "description": "**题目译自 [2024년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2024/)  T1 「[섬](https://assets.ioikorea.kr/ioitst/2024/2/island/island_statement.pdf)」**\n\nIOI 国建立在一个正 $N$ 边形的岛屿上。每个顶点代表一个区域，这些区域按顺时针方向依次编号为 $0, 1, \\cdots, N-1$。IOI 国的道路网络由以下两种道路组成：\n\n- **海滨道路**：海滨道路连接正 $N$ 边形相邻顶点对应的区域，共有 $N$ 条道路。也就是说，对于所有 $i$ $(0 \\leq i \\leq N-2)$，存在连接 $i$ 区域和 $i+1$ 区域的道路，并且存在连接 $N-1$ 区域和 0 区域的道路。\n- **内陆道路**：内陆道路连接不直接相邻的两个区域，共有 $N-3$ 条道路。这些道路除了端点外不相交，即它们对应于正 $N$ 边形中不相交的 $N-3$ 条对角线。\n\n对于连接 $K$ 个区域的道路网络，如果道路集合 $T$ 满足以下条件，则称 $T$ 为一棵树：\n\n- $|T|=K-1$\n- 仅使用 $T$ 中的道路可以在所有区域之间通行。\n\n树在连接所有区域的运输中起着重要作用。如果在一棵树的道路无法使用时，仍有另一棵树可以使用，这将大大提高稳定性。因此，如果道路网络中存在两棵树 $T_1$ 和 $T_2$，且 $T_1 \\cap T_2 = \\emptyset$，即没有任何道路重叠，则称该道路网络为良好道路网络。\n\nIOI 国计划通过以下方式建设新的区域和道路，以构建良好道路网络：\n\n- **区域建设**：对于区域 $a, b, c$，如果存在连接 $a$ 和 $b$、$b$ 和 $c$、$c$ 和 $a$ 的道路，则在这三个区域形成的三角形的内心处建立一个新区域 $d$，并连接 $a$ 和 $d$、$b$ 和 $d$、$c$ 和 $d$。新区域 $d$ 的编号从 $N$ 开始依次递增。对于相同的三个区域，不能进行多次区域建设，即每次建设使用的区域集合 $\\{a, b, c\\}$ 必须不同。\n\nIOI 国可以进行多次区域建设，但希望通过尽可能少的建设次数，构建出没有重叠道路的两棵树的良好道路网络。请注意，良好道路网络不仅包括原有的 $N$ 个区域，还包括新建的区域。你需要帮助 IOI 国解决这个道路网络问题。即使没有最小化建设次数，也可以获得部分分数。\n\n你需要实现以下函数：\n\n```cpp\nvoid construct_two_trees(int N, std::vector<int> U, std::vector<int> V);\n```\n\n- `U, V`：大小为 $N-3$ 的整数数组。对于所有 $i$ $(0 \\leq i \\leq N-4)$，存在连接 $U[i]$ 和 $V[i]$ 的内陆道路。\n- 该函数只会被调用一次，你需要在该函数内调用后续定义的 `add_vertex` 函数进行区域建设，并找到不共享道路的两棵树，然后调用 `report` 函数报告结果。\n\n```cpp\nint add_vertex(int a, int b, int c);\n```\n\n- 该函数表示在区域 $a, b, c$ 之间进行区域建设。\n- 在调用该函数之前，区域 $a, b, c$ 中任意两个区域必须直接相连。\n- 对于相同的三个区域，不能多次调用该函数，即每次建设使用的区域集合 $\\{a, b, c\\}$ 必须不同。\n- 该函数返回新建区域的编号。即，当该函数第 $j$ 次执行时，返回 $N-1+j$。\n- 在调用 `report` 函数后，不应再调用该函数。\n\n```cpp\nvoid report(std::vector<std::array<int, 2>> tree);\n```\n\n- 该函数用于报告找到的树。\n- 在 `construct_two_trees` 函数中，所有 `add_vertex` 函数调用结束后，必须准确调用两次该函数。\n- 参数 `tree` 的每个元素是一个包含两区域编号的数组 `std::array<int, 2>`。区域编号的顺序无关紧要。\n- 两次调用 `report(T1), report(T2)` 时，$T_1$ 和 $T_2$ 不应共享道路，并且每棵树的道路应能连接所有区域，包括新建区域。\n", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N$\n- 第 $2+i$ $(0 \\leq i \\leq N-4)$ 行：$U[i]\\,V[i]$\n", "outputFormat": "示例评测程序按以下格式输出：\n\n每次调用 `report` 函数时，评测程序输出：\n\n- 第 $1$ 行：整数 $k$，表示第 $k$ 次调用 `report` 函数。\n- 第 $2$ 行：树的道路数量 $M$\n- 第 $2+i$ $(1 \\leq i \\leq M)$ 行：树的第 $i$ 条道路的两个端点编号 $A[i]\\,B[i]$\n\n在 `construct_two_trees` 函数执行完毕后，评测程序输出 `add_vertex` 函数的调用信息：\n\n- 第 $1$ 行：`add_vertex` 函数的总调用次数 $K$\n- 第 $1+i$ $(1 \\leq i \\leq K)$ 行：`add_vertex` 函数第 $i$ 次调用的参数 $A[i]\\,B[i]\\,C[i]$", "hint": "对于所有输入数据，满足：\n\n- $3 \\leq N \\leq 2\\cdot 10^5$\n- 对于所有 $i$ $(0 \\leq i \\leq N-4)$：\n  - $0 \\leq U[i], V[i] \\leq N-1$\n  - $U[i] \\neq V[i]$\n- 给定的 $U$ 和 $V$ 满足内陆道路的条件。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :-: | :-: | :-: |\n| $1$ | $6$ | $N \\leq 5$ |\n| $2$ | $8$ | 存在一个区域与除自己外的所有区域直接相连 |\n| $3$ | $14$ | 初始状态下，对于所有可能的区域对 $(a, b, c)$，连接这三个区域的三条道路中至少有一条是海滨道路 |\n| $4$ | $21$ | $N \\leq 5000$ |\n| $5$ | $51$ | 无附加限制 |\n\n当 `construct_two_trees` 函数正确解决了问题时，如果 `add_vertex` 的调用次数大于最小值但不超过 $N$，则可以获得 $40\\%$ 的分数。如果 `add_vertex` 的调用次数超过 $N$，则无法获得分数。可以证明，在给定限制条件下，可以通过不超过 $N$ 次调用 `add_vertex` 构建良好道路网络。", "locale": "zh-CN"}}}
{"pid": "P11253", "type": "P", "difficulty": 4, "samples": [["5 1 ", "34"], ["100 100", "523011929"], ["10000000 10000000", "686183373"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "广东", "O2优化"], "title": "[GDKOI2023 普及组] 小学生数学题", "background": "", "description": "Moon 是一名小学生，在做作业时遇到了这样一个问题，对于给定正整数 $n,k$，求出下面表达式的值：\n\n$$\\sum_{i=1}^n \\frac{i!}{i^k}$$\n\n其中 $i!$ 表示 $i$ 的阶乘运算，即 $i!=1\\times 2\\times 3\\times 4...\\times i$。这个式子太难了，所以 Moon 希望得到你的帮助。但是因为 Moon 只学过整数运算，还没有学过实数运算，所以希望你可以帮助他求出这个式子在模 $998244353$ 意义下的值。也就是说，如果最终的结果假如化简成为最简分数 $\\frac{p}{q}$，只需要输出 $p\\times q^{-1} \\bmod 998244353$ 即可，其中 $q^{-1}$ 为 $q$ 在模 $998244353$ 下的逆元。", "inputFormat": "第一行两个整数 $n,k$。", "outputFormat": "一行，一个整数，代表模 $998244353$ 意义下的答案。", "hint": "### 样例解释\n\n样例 $1$ 中，因为 $\\frac{i!}{i}=(i-1)!$，所以原式等价于 $\\sum_{i=1}^5 (i-1)!=34$。\n\n### 数据范围\n\n对于所有的数据，有 $1\\le n,k\\le 2 \\times 10^7$；\n\n对于 $30 \\%$ 的数据，有 $k=1$；\n\n对于另外 $30\\%$ 的数据，有 $1\\le k \\le 3$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GDKOI2023 普及组] 小学生数学题", "background": "", "description": "Moon 是一名小学生，在做作业时遇到了这样一个问题，对于给定正整数 $n,k$，求出下面表达式的值：\n\n$$\\sum_{i=1}^n \\frac{i!}{i^k}$$\n\n其中 $i!$ 表示 $i$ 的阶乘运算，即 $i!=1\\times 2\\times 3\\times 4...\\times i$。这个式子太难了，所以 Moon 希望得到你的帮助。但是因为 Moon 只学过整数运算，还没有学过实数运算，所以希望你可以帮助他求出这个式子在模 $998244353$ 意义下的值。也就是说，如果最终的结果假如化简成为最简分数 $\\frac{p}{q}$，只需要输出 $p\\times q^{-1} \\bmod 998244353$ 即可，其中 $q^{-1}$ 为 $q$ 在模 $998244353$ 下的逆元。", "inputFormat": "第一行两个整数 $n,k$。", "outputFormat": "一行，一个整数，代表模 $998244353$ 意义下的答案。", "hint": "### 样例解释\n\n样例 $1$ 中，因为 $\\frac{i!}{i}=(i-1)!$，所以原式等价于 $\\sum_{i=1}^5 (i-1)!=34$。\n\n### 数据范围\n\n对于所有的数据，有 $1\\le n,k\\le 2 \\times 10^7$；\n\n对于 $30 \\%$ 的数据，有 $k=1$；\n\n对于另外 $30\\%$ 的数据，有 $1\\le k \\le 3$。", "locale": "zh-CN"}}}
{"pid": "P11254", "type": "P", "difficulty": 3, "samples": [["10 10\n5\n4 5\n5\n7 10\n6 10\n5 9\n4 9\n4 10", "29"], ["见/example/macaron/下的 macaron1.in", "见/example/macaron/下的 macaron1.out"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2023", "广东", "O2优化"], "title": "[GDKOI2023 普及组] Macaron", "background": "", "description": "给出 $n\\times m$ 的一块二维平面作为 Nana 的家，左上角墙角为 $(0, 0)$ ，右下角墙角为 $(n + 1, m + 1)$。其中\n家里有 $k$ 个家具，每个家具会占其中一个点，题目将会给出每个家具的坐标。\n\n马卡龙是一只扫地机器人，半径为 $r$ 的圆形的它可以向上下左右四个方向移动，移动前后必须保持圆心在整点上，并且不能穿过家具或外墙进行打扫，即身躯不可以与家具或墙壁有重合部分（允许相切）。它初始圆心位置为 $(x_s, y_s)$ ，将会从此出发，打扫它能到达的区域。\n\n马卡龙想知道自己可以打扫到多大面积。你只需要告诉马卡龙，它出发后它的圆心可以到达的平面内的\n整点数量。\n\n对了，你只用将答案告诉马卡龙就够了，不需要告诉 Nana ，因为马卡龙不希望伤心的 Nana 会为这些\n琐事烦心。", "inputFormat": "第一行有两个整数 $n, m$ ，表示 Nana 的家的大小。\n\n第二行有一个整数 $r^2$ ，表示马卡龙半径的平方。\n\n第三行有两个整数 $x_s, y_s$ ，表示马卡龙出发的位置，保证在其初始位置上，马卡龙不会与家具有重合部\n分。\n\n第四行有一个整数 $k$，接下来 $k$ 行里每行给出两个整数 $x, y$ ，表示其中一个家具的坐标。", "outputFormat": "仅一个整数 $ans$ ，表示答案。", "hint": "### 数据范围\n\n对所有数据满足 $0 \\le k \\le n \\times  m，1 \\le r \\le \\min(\\lfloor \\frac{n}{2} \\rfloor , \\lfloor \\frac{m}{2} \\rfloor)$；\n\n其中有 $30\\%$ 的数据点满足 $1 \\le n, m \\le 100$;\n\n剩下 $70\\%$ 的数据点满足 $1 \\le n, m \\le 1000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GDKOI2023 普及组] Macaron", "background": "", "description": "给出 $n\\times m$ 的一块二维平面作为 Nana 的家，左上角墙角为 $(0, 0)$ ，右下角墙角为 $(n + 1, m + 1)$。其中\n家里有 $k$ 个家具，每个家具会占其中一个点，题目将会给出每个家具的坐标。\n\n马卡龙是一只扫地机器人，半径为 $r$ 的圆形的它可以向上下左右四个方向移动，移动前后必须保持圆心在整点上，并且不能穿过家具或外墙进行打扫，即身躯不可以与家具或墙壁有重合部分（允许相切）。它初始圆心位置为 $(x_s, y_s)$ ，将会从此出发，打扫它能到达的区域。\n\n马卡龙想知道自己可以打扫到多大面积。你只需要告诉马卡龙，它出发后它的圆心可以到达的平面内的\n整点数量。\n\n对了，你只用将答案告诉马卡龙就够了，不需要告诉 Nana ，因为马卡龙不希望伤心的 Nana 会为这些\n琐事烦心。", "inputFormat": "第一行有两个整数 $n, m$ ，表示 Nana 的家的大小。\n\n第二行有一个整数 $r^2$ ，表示马卡龙半径的平方。\n\n第三行有两个整数 $x_s, y_s$ ，表示马卡龙出发的位置，保证在其初始位置上，马卡龙不会与家具有重合部\n分。\n\n第四行有一个整数 $k$，接下来 $k$ 行里每行给出两个整数 $x, y$ ，表示其中一个家具的坐标。", "outputFormat": "仅一个整数 $ans$ ，表示答案。", "hint": "### 数据范围\n\n对所有数据满足 $0 \\le k \\le n \\times  m，1 \\le r \\le \\min(\\lfloor \\frac{n}{2} \\rfloor , \\lfloor \\frac{m}{2} \\rfloor)$；\n\n其中有 $30\\%$ 的数据点满足 $1 \\le n, m \\le 100$;\n\n剩下 $70\\%$ 的数据点满足 $1 \\le n, m \\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P11255", "type": "P", "difficulty": 5, "samples": [["4 4 1 1 5\n-3 2 \n4 1 \n0 4 \n2 3 \n-4\n1\n-2 \n0", "2\n3\n2\n3"], ["见/example/rain/下的 rain1.in ", "见/example/rain/下的 rain1.out"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "线段树", "树状数组", "2023", "广东", "cdq 分治", "O2优化", "动态规划优化"], "title": "[GDKOI2023 普及组] 淋雨", "background": "", "description": "Moon 发现自己来到了一个二维平面上，但是自己只能在 $y=0$ 的直线上以不超过 $v_c \\space m/s$ 的速度行走（可以折返来回行走）。这个时候天空开始下了倾盆大雨，一共有 $n$ 个雨滴，第 $i(1 \\le i \\le n)$ 个雨滴以 $v_g\\space  m/s$ 的\n速度从 $(x_i, y_i)$ 开始匀速下落，同时开始刮起了速度为 $v_w \\space m/s$，方向为 $x$ 轴正方向的大风, 可以认为每个雨滴在水平方向上有了和风速一样的速度, 以及风不会影响人的行走速度。\n\nMoon 非常喜欢淋雨，为了简单起见把每个雨滴和 Moon 都视为是一个点，只有某个雨滴到达 $x$ 轴的位\n置的同时，Moon 也正好在这个位置上，Moon 才可以被这个雨滴淋到。现在给出 $q$ 个询问，第 $i(1 \\le i \\le q)$\n次询问给出一个初始位置 $(s_i, 0)$，Moon 想知道自己从 $(s_i, 0)$ 出发，在整个运动过程中，最多可以被多少个\n雨滴淋到呢？", "inputFormat": "第一行五个整数 $n, q, v_g , v_w, v_c$；\n\n接下来 $n$ 行每行两个整数 $x_i, y_i$；\n\n再接下来 $q$ 行每行一个整数 $s_i$。", "outputFormat": "对于每个询问输出一行一个整数，表示 Moon 最多可以被淋到的雨滴数量。", "hint": "### 数据范围\n\n对于所有的数据，有 $1 \\le n, q \\le 10^5, 1 \\le v_w, v_g , v_c, y_i \\le 10^6, −10^6 \\le x_i, s_i \\le 10^6$；\n\n对于 $30\\%$ 的数据，有 $1 \\le n, q \\le 100$；\n\n对于另外 $30\\%$ 的数据，有 $1 \\le q \\le 5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GDKOI2023 普及组] 淋雨", "background": "", "description": "Moon 发现自己来到了一个二维平面上，但是自己只能在 $y=0$ 的直线上以不超过 $v_c \\space m/s$ 的速度行走（可以折返来回行走）。这个时候天空开始下了倾盆大雨，一共有 $n$ 个雨滴，第 $i(1 \\le i \\le n)$ 个雨滴以 $v_g\\space  m/s$ 的\n速度从 $(x_i, y_i)$ 开始匀速下落，同时开始刮起了速度为 $v_w \\space m/s$，方向为 $x$ 轴正方向的大风, 可以认为每个雨滴在水平方向上有了和风速一样的速度, 以及风不会影响人的行走速度。\n\nMoon 非常喜欢淋雨，为了简单起见把每个雨滴和 Moon 都视为是一个点，只有某个雨滴到达 $x$ 轴的位\n置的同时，Moon 也正好在这个位置上，Moon 才可以被这个雨滴淋到。现在给出 $q$ 个询问，第 $i(1 \\le i \\le q)$\n次询问给出一个初始位置 $(s_i, 0)$，Moon 想知道自己从 $(s_i, 0)$ 出发，在整个运动过程中，最多可以被多少个\n雨滴淋到呢？", "inputFormat": "第一行五个整数 $n, q, v_g , v_w, v_c$；\n\n接下来 $n$ 行每行两个整数 $x_i, y_i$；\n\n再接下来 $q$ 行每行一个整数 $s_i$。", "outputFormat": "对于每个询问输出一行一个整数，表示 Moon 最多可以被淋到的雨滴数量。", "hint": "### 数据范围\n\n对于所有的数据，有 $1 \\le n, q \\le 10^5, 1 \\le v_w, v_g , v_c, y_i \\le 10^6, −10^6 \\le x_i, s_i \\le 10^6$；\n\n对于 $30\\%$ 的数据，有 $1 \\le n, q \\le 100$；\n\n对于另外 $30\\%$ 的数据，有 $1 \\le q \\le 5$。", "locale": "zh-CN"}}}
{"pid": "P11256", "type": "P", "difficulty": 6, "samples": [["1\n5 6\n2 1 4 3 5", "2"], ["见/example/permutation/下的\npermutation1.in", "见/example/permutation/下的\npermutation1.out"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "广东", "O2优化"], "title": "[GDKOI2023 普及组] 置换", "background": "", "description": "Moon 最近在玩一款名为 Shadowverse 的卡牌游戏，在非常有趣的游戏过程中，Moon 想到这样一个关于洗牌的问题。假设当前牌堆中有 $n$ 张牌，第 $i$ 张牌的标号为 $i$，我们定义一种洗牌方式是一个排列 $X=\\{x_1, x_2, ..., x_n\\}$, 也就是把牌堆中第 $i$ 张位置的牌变成第 $x_i$ 张。那么假设现在 Moon 按照 $X$ 的洗牌方式洗了 $k$ 次牌，不妨设最终得到了一个排列 $Y =\\{y_1, y_2, ..., y_n\\}$，$y_i$ 表示洗完牌后第 $i$ 张牌的标号。Moon 希望你可以帮助他算出有多少合法的洗牌方式 $X$，满足洗了 $K$ 次后变成排列 $Y$ ，由于答案可能很大，所以你只需要输出对 $998244353$ 取模的答案即可。\n\n形式化而言，考虑对于排列 $P=\\{p_1, p_2, ..., p_n\\}$ 和排列 $Q=\\{q_1, q_2, ..., q_n\\}$, 定义这两个排列的乘积:\n\n$$ P \\times Q = \\{q_{p1} , q_{p2} , ..., q_{pn} \\}$$\n\n而排列 $X$ 的 $k$ 次幂 $X^k$ 为 $k$ 个排列 $X$ 的乘积，现在考虑给定排列 $Y$ 和正整数 $k$, 求满足方程 $X^k = Y$ 的排列 $X$ 的数量，对 $998244353$ 取模。", "inputFormat": "第一行是一个整数 $T$ 表示测试数据组数。\n\n每组数据包括两行，第一行两个正整数 $n,k$，分别表示排列 $X$ 和 $Y$ 的长度、洗了 $k$ 次牌。\n\n第二行是 $n$ 个 $1$ 到 $n$ 内互不相同的正整数 $\\{y_1, y_2, ..., y_n\\}$，表示排列 $Y$ 。", "outputFormat": "$T$ 行，每行一个整数, 表示合法的洗牌方式的数量，对 $998244353$ 取模。", "hint": "### 样例解释\n\n样例中，$X=[3,4,2,1,5]$ 或者 $[4,3,1,2,5]$, 共两个合法排列。\n\n### 数据范围\n\n对于所有的数据，有 $1 \\le n \\le 3000, 1 \\le k \\le 10^6, 1 \\le T \\le 10$；\n\n对于 $20\\%$ 的数据，有 $1 \\le n, k \\le 8$；\n\n对于另外 $10\\%$ 的数据，仅保证 $1 \\le n \\le 8$；\n\n对于另外 $30\\%$ 的数据，仅保证 $1 \\le n \\le 50$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GDKOI2023 普及组] 置换", "background": "", "description": "Moon 最近在玩一款名为 Shadowverse 的卡牌游戏，在非常有趣的游戏过程中，Moon 想到这样一个关于洗牌的问题。假设当前牌堆中有 $n$ 张牌，第 $i$ 张牌的标号为 $i$，我们定义一种洗牌方式是一个排列 $X=\\{x_1, x_2, ..., x_n\\}$, 也就是把牌堆中第 $i$ 张位置的牌变成第 $x_i$ 张。那么假设现在 Moon 按照 $X$ 的洗牌方式洗了 $k$ 次牌，不妨设最终得到了一个排列 $Y =\\{y_1, y_2, ..., y_n\\}$，$y_i$ 表示洗完牌后第 $i$ 张牌的标号。Moon 希望你可以帮助他算出有多少合法的洗牌方式 $X$，满足洗了 $K$ 次后变成排列 $Y$ ，由于答案可能很大，所以你只需要输出对 $998244353$ 取模的答案即可。\n\n形式化而言，考虑对于排列 $P=\\{p_1, p_2, ..., p_n\\}$ 和排列 $Q=\\{q_1, q_2, ..., q_n\\}$, 定义这两个排列的乘积:\n\n$$ P \\times Q = \\{q_{p1} , q_{p2} , ..., q_{pn} \\}$$\n\n而排列 $X$ 的 $k$ 次幂 $X^k$ 为 $k$ 个排列 $X$ 的乘积，现在考虑给定排列 $Y$ 和正整数 $k$, 求满足方程 $X^k = Y$ 的排列 $X$ 的数量，对 $998244353$ 取模。", "inputFormat": "第一行是一个整数 $T$ 表示测试数据组数。\n\n每组数据包括两行，第一行两个正整数 $n,k$，分别表示排列 $X$ 和 $Y$ 的长度、洗了 $k$ 次牌。\n\n第二行是 $n$ 个 $1$ 到 $n$ 内互不相同的正整数 $\\{y_1, y_2, ..., y_n\\}$，表示排列 $Y$ 。", "outputFormat": "$T$ 行，每行一个整数, 表示合法的洗牌方式的数量，对 $998244353$ 取模。", "hint": "### 样例解释\n\n样例中，$X=[3,4,2,1,5]$ 或者 $[4,3,1,2,5]$, 共两个合法排列。\n\n### 数据范围\n\n对于所有的数据，有 $1 \\le n \\le 3000, 1 \\le k \\le 10^6, 1 \\le T \\le 10$；\n\n对于 $20\\%$ 的数据，有 $1 \\le n, k \\le 8$；\n\n对于另外 $10\\%$ 的数据，仅保证 $1 \\le n \\le 8$；\n\n对于另外 $30\\%$ 的数据，仅保证 $1 \\le n \\le 50$。", "locale": "zh-CN"}}}
{"pid": "P11257", "type": "P", "difficulty": 3, "samples": [["4 10\n0123456789ABCDEF 00:10\n0000000000ABCDEF 08:11\n0123456789ABCDEF 00:15\n0000000000ABCDEF 00:11", "2"], ["3 60\n0123456789ABCDEF 13:00\n0000000000000000 14:00\n0123456789ABCDEF 12:30", "1"], ["见/example/switch/下的 switch1.in ", "见/example/switch/下的 switch1.out"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "广东", "O2优化"], "title": "[GDKOI2023 普及组] 交换机", "background": "", "description": "Moon 正在准备计算机网络的开学考，复习到了有关交换机的知识。交换机具有令人惊奇的特性那就是它的表是自动、动态和自治地建立的，即没有来自网络管理员或来自配置协议的任何干预。换句话说，交换机是自学习的。这种能力大概是通过如下方式实现的:\n\n1) 交换机表初始为空。\n2) 对于在每个接口接收到的每个数据帧，该交换机在其表中存储数据帧的源 $\\text{MAC}$ 地址。\n3) 如果在一段时间 (称为老化期) 后，交换机没有接收到含有某个源 $\\text{MAC}$  地址的数据帧，就会在表中删除这个源 $\\text{MAC}$  地址。\n\n现在给出了某天中一个交换机所有收到的数据帧（每一个数据帧包含一个源 $\\text{MAC}$  地址，以及该数据帧的到达时间），请你帮助 Moon 算出在这一天中，这个交换机的表最少需要多少项，才可以使得这天所有数据帧的信息可以存储下来。**注意为了简单起见，每个时间点先进行删除操作再进行插入操作。**\n\n简单来说，需要维护一个字符串集合 $S$，有若干次插入操作，每次插入操作包含一个字符串以及一个有效时间区间（区间长度为定值），需要求出所有时间内，字符串集合 $S$ 大小的最大值。", "inputFormat": "第一行两个整数 $n，k$，分别表示数据帧的个数，以及老化期时间（单位：分钟）。\n\n接下来 $n$ 行，每行两个字符串 $s_1, s_2$，表示数据帧包含的源地址帧，以及到达时间，其中 $s_1$ 是一个 MAC\n地址，包含 $12$ 个 $16$ 进制数，$s_2$ 的格式为 $a:b$，其中 $0 \\le a \\le 23, 0 \\le b \\le 59$，表示该数据帧在 $a$ 时 $b$ 分钟 $0$ 秒到达交换机，并且 $a, b$ 不足 $10$ 的数字前面要补充一个零。", "outputFormat": "一行，一个整数，代表答案。", "hint": "### 样例解释\n\n样例 $1$ 中，时刻 $00:11$ 分表项中有 $2$ 个源 $\\text{MAC}$ 地址 $\\text{0123456789ABC}$ 和 $\\text{0000000000ABCDEF}$，所以至\n少需要表项大小至少为 $2$，可以证明这是最少需要的表项大小。\n\n### 数据范围\n\n对于所有的数据，有 $1 \\le n \\le 10^5, 1 \\le k \\le 1440$；\n\n对于 $50\\%$ 的数据，有 $1 \\le n \\le 500$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GDKOI2023 普及组] 交换机", "background": "", "description": "Moon 正在准备计算机网络的开学考，复习到了有关交换机的知识。交换机具有令人惊奇的特性那就是它的表是自动、动态和自治地建立的，即没有来自网络管理员或来自配置协议的任何干预。换句话说，交换机是自学习的。这种能力大概是通过如下方式实现的:\n\n1) 交换机表初始为空。\n2) 对于在每个接口接收到的每个数据帧，该交换机在其表中存储数据帧的源 $\\text{MAC}$ 地址。\n3) 如果在一段时间 (称为老化期) 后，交换机没有接收到含有某个源 $\\text{MAC}$  地址的数据帧，就会在表中删除这个源 $\\text{MAC}$  地址。\n\n现在给出了某天中一个交换机所有收到的数据帧（每一个数据帧包含一个源 $\\text{MAC}$  地址，以及该数据帧的到达时间），请你帮助 Moon 算出在这一天中，这个交换机的表最少需要多少项，才可以使得这天所有数据帧的信息可以存储下来。**注意为了简单起见，每个时间点先进行删除操作再进行插入操作。**\n\n简单来说，需要维护一个字符串集合 $S$，有若干次插入操作，每次插入操作包含一个字符串以及一个有效时间区间（区间长度为定值），需要求出所有时间内，字符串集合 $S$ 大小的最大值。", "inputFormat": "第一行两个整数 $n，k$，分别表示数据帧的个数，以及老化期时间（单位：分钟）。\n\n接下来 $n$ 行，每行两个字符串 $s_1, s_2$，表示数据帧包含的源地址帧，以及到达时间，其中 $s_1$ 是一个 MAC\n地址，包含 $12$ 个 $16$ 进制数，$s_2$ 的格式为 $a:b$，其中 $0 \\le a \\le 23, 0 \\le b \\le 59$，表示该数据帧在 $a$ 时 $b$ 分钟 $0$ 秒到达交换机，并且 $a, b$ 不足 $10$ 的数字前面要补充一个零。", "outputFormat": "一行，一个整数，代表答案。", "hint": "### 样例解释\n\n样例 $1$ 中，时刻 $00:11$ 分表项中有 $2$ 个源 $\\text{MAC}$ 地址 $\\text{0123456789ABC}$ 和 $\\text{0000000000ABCDEF}$，所以至\n少需要表项大小至少为 $2$，可以证明这是最少需要的表项大小。\n\n### 数据范围\n\n对于所有的数据，有 $1 \\le n \\le 10^5, 1 \\le k \\le 1440$；\n\n对于 $50\\%$ 的数据，有 $1 \\le n \\le 500$。", "locale": "zh-CN"}}}
{"pid": "P11258", "type": "P", "difficulty": 5, "samples": [["6\n3\n", "12"], ["1000\n1000", "32561"], ["100000\n10000", "10099799"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "广东", "O2优化"], "title": "[GDKOI2023 普及组]  城市建设", "background": "", "description": "现在有 $N$ 个城市分别位于 $1, 2, ..., N$ 号节点上。作为城市的管理者小明希望花最小的代价把这 $N$ 个城\n市联通起来。联通城市的花费主要分为下面两种。\n\n第一种：建设道路，在 $a$ 号城市和 $b$ 号城市之间建设道路将会花费 $|a - b|$ 的代价；\n\n第二种：设置管理城市，对于一个城市 $X$ 可以使用 $C$ 的代价将其升级为管理城市；\n\n在保证每条道路至少联结一个管理城市，以及非管理城市只能连接一条边的前提下，小明想知道他最少\n能用多少的代价使所有城市联通。", "inputFormat": "第一行一个正整数 $N$，表示城市数量；\n\n第二行一个整数 $C$，表示设置管理城市的代价。", "outputFormat": "一行，一个整数，表示小明使城市联通的最小代价。", "hint": "### 样例解释\n\n以 $2, 5$ 分别为管理城市，并联结 $(1, 2), (2, 3), (2, 5), (4, 5), (5, 6)$ 共五条边时取得最小代价;\n\n也可以以 $3$ 或 $4$ 作为管理城市，并联结其余所有点，此时也取得最小代价。\n\n### 数据范围\n\n对于 $20\\%$ 的数据，$1 \\le N \\le 20$;\n\n对于 $40\\%$ 的数据，$1 \\le N \\le 10^3$;\n\n对于另外 $20\\%$ 的数据，$1 ≤ N ≤ 10^5, 0 \\le C \\le 10^4$;\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10^9, 0 \\le C \\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GDKOI2023 普及组]  城市建设", "background": "", "description": "现在有 $N$ 个城市分别位于 $1, 2, ..., N$ 号节点上。作为城市的管理者小明希望花最小的代价把这 $N$ 个城\n市联通起来。联通城市的花费主要分为下面两种。\n\n第一种：建设道路，在 $a$ 号城市和 $b$ 号城市之间建设道路将会花费 $|a - b|$ 的代价；\n\n第二种：设置管理城市，对于一个城市 $X$ 可以使用 $C$ 的代价将其升级为管理城市；\n\n在保证每条道路至少联结一个管理城市，以及非管理城市只能连接一条边的前提下，小明想知道他最少\n能用多少的代价使所有城市联通。", "inputFormat": "第一行一个正整数 $N$，表示城市数量；\n\n第二行一个整数 $C$，表示设置管理城市的代价。", "outputFormat": "一行，一个整数，表示小明使城市联通的最小代价。", "hint": "### 样例解释\n\n以 $2, 5$ 分别为管理城市，并联结 $(1, 2), (2, 3), (2, 5), (4, 5), (5, 6)$ 共五条边时取得最小代价;\n\n也可以以 $3$ 或 $4$ 作为管理城市，并联结其余所有点，此时也取得最小代价。\n\n### 数据范围\n\n对于 $20\\%$ 的数据，$1 \\le N \\le 20$;\n\n对于 $40\\%$ 的数据，$1 \\le N \\le 10^3$;\n\n对于另外 $20\\%$ 的数据，$1 ≤ N ≤ 10^5, 0 \\le C \\le 10^4$;\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10^9, 0 \\le C \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P11259", "type": "P", "difficulty": 5, "samples": [["5\n-2 -3 4 -5 1\n1 2\n1 3\n2 4\n2 5", "10"], ["见/example/starfish/下", "见/example/starfish/下"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "广东", "O2优化"], "title": "[GDKOI2023 普及组] 海星", "background": "", "description": "小明想去海底抓海星, 海底是一个树状的结构，而海星就藏在里面。\n\n给定一棵 $n$ 个点的树，分别标号为 $1, 2, 3, ..., n$, 且对应的点权记为 $p_i$。\n\n定义海星为其中的花子图，不妨设其中心节点标号为 $O$, 边缘节点标号为 $a_1, a_2, ..., a_t$ (其中边缘节点必\n定直接与中心节点相连，同时花子图至少由一个中心节点和一个边缘节点构成)。此时记海星的价值为 $|p_O -\n\\sum p_{a_i} |$。\n\n小明想知道他最多能抓到价值总和为多少的海星。（可以同时抓很多只海星，但是任意两个海星之间点的\n交集必须为空）\n\n补充定义:\n\n**花图: 直径小于等于三的联通图，其中度数最大的节点为中心节点，其余节点为边缘节点（可知任意的边\n缘节点度数为一）**\n\n**示例：最小的花图，是 $(G,V)=({1,2},{(1,2)})$，仅由两个节点和联结它们的一条边构成。**", "inputFormat": "第一行，一个正整数 $n$，表示树的大小；\n\n第 $2$ 行，$n$ 个整数，表示 $p_i$；\n\n第 $3 ∼ n + 1$ 行，每行 $2$ 个整数 $a, b$，分别表示 $a$ 号节点与 $b$ 号节点之间有一条边。", "outputFormat": "一行，一个整数，表示小明能抓到的最大海星的价值总和。", "hint": "### 样例解释\n\n一个合法的方案是，小明抓了两个海星，第一个海星的中心节点为 $1$，边缘节点为 $3$，价值为 $6$；第二个\n海星的中心节点为 $2$，边缘节点为 $5$，价值为 $4$，此时得到最大总价值 $10$。\n\n### 数据范围\n\n$(1)$ 对于 $10\\%$ 的数据，保证数据形成一个花图。\n\n$(2)$ 对于 $20\\%$ 的数据，保证数据形成一条链。\n\n$(3)$ 对于 $20\\%$ 的数据，保证数据相邻节点乘积恒负。\n\n$(4)$ 对于 $20\\%$ 的数据，保证数据形成一颗以 1 为根节点的二叉树。\n\n$(5)$ 对于 $30\\%$ 的数据，无特殊限制。\n\n对于所有数据 $1 \\le a, b \\le n \\le 10^5$，$-10^9 \\leq p_i \\leq 10^8$。\n\n下发样例中编号为 $i, i + 5$ 的数据对应序号为 $i$ 的限制条件. $i \\in \\{1, 2, 3, 4, 5\\}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GDKOI2023 普及组] 海星", "background": "", "description": "小明想去海底抓海星, 海底是一个树状的结构，而海星就藏在里面。\n\n给定一棵 $n$ 个点的树，分别标号为 $1, 2, 3, ..., n$, 且对应的点权记为 $p_i$。\n\n定义海星为其中的花子图，不妨设其中心节点标号为 $O$, 边缘节点标号为 $a_1, a_2, ..., a_t$ (其中边缘节点必\n定直接与中心节点相连，同时花子图至少由一个中心节点和一个边缘节点构成)。此时记海星的价值为 $|p_O -\n\\sum p_{a_i} |$。\n\n小明想知道他最多能抓到价值总和为多少的海星。（可以同时抓很多只海星，但是任意两个海星之间点的\n交集必须为空）\n\n补充定义:\n\n**花图: 直径小于等于三的联通图，其中度数最大的节点为中心节点，其余节点为边缘节点（可知任意的边\n缘节点度数为一）**\n\n**示例：最小的花图，是 $(G,V)=({1,2},{(1,2)})$，仅由两个节点和联结它们的一条边构成。**", "inputFormat": "第一行，一个正整数 $n$，表示树的大小；\n\n第 $2$ 行，$n$ 个整数，表示 $p_i$；\n\n第 $3 ∼ n + 1$ 行，每行 $2$ 个整数 $a, b$，分别表示 $a$ 号节点与 $b$ 号节点之间有一条边。", "outputFormat": "一行，一个整数，表示小明能抓到的最大海星的价值总和。", "hint": "### 样例解释\n\n一个合法的方案是，小明抓了两个海星，第一个海星的中心节点为 $1$，边缘节点为 $3$，价值为 $6$；第二个\n海星的中心节点为 $2$，边缘节点为 $5$，价值为 $4$，此时得到最大总价值 $10$。\n\n### 数据范围\n\n$(1)$ 对于 $10\\%$ 的数据，保证数据形成一个花图。\n\n$(2)$ 对于 $20\\%$ 的数据，保证数据形成一条链。\n\n$(3)$ 对于 $20\\%$ 的数据，保证数据相邻节点乘积恒负。\n\n$(4)$ 对于 $20\\%$ 的数据，保证数据形成一颗以 1 为根节点的二叉树。\n\n$(5)$ 对于 $30\\%$ 的数据，无特殊限制。\n\n对于所有数据 $1 \\le a, b \\le n \\le 10^5$，$-10^9 \\leq p_i \\leq 10^8$。\n\n下发样例中编号为 $i, i + 5$ 的数据对应序号为 $i$ 的限制条件. $i \\in \\{1, 2, 3, 4, 5\\}$。", "locale": "zh-CN"}}}
{"pid": "P11260", "type": "P", "difficulty": 5, "samples": [["5 8 2\n3 4 6\n2 1 6\n1 4 8\n1 2 10\n2 3 4\n3 4 5\n4 5 4\n2 4 6", "21\n19\n20"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2023", "广东", "O2优化"], "title": "[GDKOI2023 普及组]  Himitsu", "background": "省略了一些不必要的图片。", "description": "Lily 忘不掉小时候临别前与 Nana 一起出逃的夜晚，两人为了探索宇宙的真相而沿着铁路轨道前行，望见从天际线涌出的大鱼浮在夜空里。从那以后 Lily 便未曾停止过钻研宇宙的秘密。\n\n秘密啊，总是会有那么一两个的。以浮起的大鱼为典型，Lily 所在的世界发生了 $n$ 件关于宇宙的重大事件。阴谋诡计，完全犯罪，宇宙的暗物质，事件与事件之间看似互不相干，但 Lily 每天阅读着关于宇宙的书籍，从书籍最后一页总结出 $m$ 段解读，每段解读都能将其中某两件事件联系起来。\n\n大人们希望 Lily 揭露部分已经得到的解读，使所有发生的事件都能被串联起来。但是 Lily 清楚，如果这些解读暴露，班里大概有一半的同学会开始计划着出逃——秘密的揭露都是需要 Lily 付出代价的，假设每一段解读的揭露需要付出的代价可以被量化，第 $i$ 段解读的揭露需要付出的代价为整数值 $w_i$ 。Lily 需要付出的总代价为，在确保解读们能将所有事件联系起来的前提下，Lily 所揭露的所有解读的代价之和。\n\nLily 知道，其中有 $k$ 段解读是关于世界真理的关键解读，是承载着 $70$ 亿的秘密，这些解读被透露的数量将直接决定着人类延续的可能性。人们议论纷纷，说着或许只有这两个孩子才能拯救世界，$70$ 亿人所凝聚的正义将 $2$ 人的自由剥夺，迫切地想要知道 Lily 给出的答案。\n\n你想要知道，对于 $0$ 到 $k$ 中所有整数 $i$ ，Lily 透露了一部分解读，能将所有事件联系起来，且其中正好\n有 $i$ 个关键解读的前提下，Lily 需要付出的最小总代价。\n\n“我不明白啊”，Lily 这样的哭了。她会坚守着秘密，按照约定等待着与 Nana 再会的那一刻。", "inputFormat": "第一行有三个整数 $n, m, k$ ，分别表示事件数量，解读总数和关键解读的数量。\n\n紧接着 $m$ 行每行有三个整数 $u, v, w$ ，分别表示一种能将事件 $u$ 与事件 $v$ 联系起来的解读，但是这解读的揭露需要付出 $ w$ 的代价。\n\n这 $m$ 行中前 $k$ 行表示 Lily 所知道的关键解读。", "outputFormat": "$k + 1$ 行每行有一个整数 $ans$ 。其中第 $i$ 行整数 $ans_i$ 表示揭露正好 $i − 1$ 个关键解读的。\n\n数据保证在所有关键解读都不揭露的情况下，剩余的解读能将所有事件联系在一起。", "hint": "### 数据范围\n\n$1 \\le u, v \\le n, 1 \\le w \\le 10^9$；\n\n对于 $30\\%$ 的数据满足 $1 \\le n \\le 100, 1 \\le m \\le 400, 1 \\le k \\le 5$；\n\n对于另外 $30\\%$ 的数据满足 $1 \\le n \\le 10000, 1 \\le m \\le 1000000, 1 \\le k \\le 20$；\n\n对于剩下 $40\\%$ 的数据满足 $1 \\le n \\le 10000, 1 \\le m \\le 1000000, 1 \\le k \\le 50$。\n\n赛题被启用的时候，小小的行星上已经有 $80$ 亿人了。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GDKOI2023 普及组]  Himitsu", "background": "省略了一些不必要的图片。", "description": "Lily 忘不掉小时候临别前与 Nana 一起出逃的夜晚，两人为了探索宇宙的真相而沿着铁路轨道前行，望见从天际线涌出的大鱼浮在夜空里。从那以后 Lily 便未曾停止过钻研宇宙的秘密。\n\n秘密啊，总是会有那么一两个的。以浮起的大鱼为典型，Lily 所在的世界发生了 $n$ 件关于宇宙的重大事件。阴谋诡计，完全犯罪，宇宙的暗物质，事件与事件之间看似互不相干，但 Lily 每天阅读着关于宇宙的书籍，从书籍最后一页总结出 $m$ 段解读，每段解读都能将其中某两件事件联系起来。\n\n大人们希望 Lily 揭露部分已经得到的解读，使所有发生的事件都能被串联起来。但是 Lily 清楚，如果这些解读暴露，班里大概有一半的同学会开始计划着出逃——秘密的揭露都是需要 Lily 付出代价的，假设每一段解读的揭露需要付出的代价可以被量化，第 $i$ 段解读的揭露需要付出的代价为整数值 $w_i$ 。Lily 需要付出的总代价为，在确保解读们能将所有事件联系起来的前提下，Lily 所揭露的所有解读的代价之和。\n\nLily 知道，其中有 $k$ 段解读是关于世界真理的关键解读，是承载着 $70$ 亿的秘密，这些解读被透露的数量将直接决定着人类延续的可能性。人们议论纷纷，说着或许只有这两个孩子才能拯救世界，$70$ 亿人所凝聚的正义将 $2$ 人的自由剥夺，迫切地想要知道 Lily 给出的答案。\n\n你想要知道，对于 $0$ 到 $k$ 中所有整数 $i$ ，Lily 透露了一部分解读，能将所有事件联系起来，且其中正好\n有 $i$ 个关键解读的前提下，Lily 需要付出的最小总代价。\n\n“我不明白啊”，Lily 这样的哭了。她会坚守着秘密，按照约定等待着与 Nana 再会的那一刻。", "inputFormat": "第一行有三个整数 $n, m, k$ ，分别表示事件数量，解读总数和关键解读的数量。\n\n紧接着 $m$ 行每行有三个整数 $u, v, w$ ，分别表示一种能将事件 $u$ 与事件 $v$ 联系起来的解读，但是这解读的揭露需要付出 $ w$ 的代价。\n\n这 $m$ 行中前 $k$ 行表示 Lily 所知道的关键解读。", "outputFormat": "$k + 1$ 行每行有一个整数 $ans$ 。其中第 $i$ 行整数 $ans_i$ 表示揭露正好 $i − 1$ 个关键解读的。\n\n数据保证在所有关键解读都不揭露的情况下，剩余的解读能将所有事件联系在一起。", "hint": "### 数据范围\n\n$1 \\le u, v \\le n, 1 \\le w \\le 10^9$；\n\n对于 $30\\%$ 的数据满足 $1 \\le n \\le 100, 1 \\le m \\le 400, 1 \\le k \\le 5$；\n\n对于另外 $30\\%$ 的数据满足 $1 \\le n \\le 10000, 1 \\le m \\le 1000000, 1 \\le k \\le 20$；\n\n对于剩下 $40\\%$ 的数据满足 $1 \\le n \\le 10000, 1 \\le m \\le 1000000, 1 \\le k \\le 50$。\n\n赛题被启用的时候，小小的行星上已经有 $80$ 亿人了。", "locale": "zh-CN"}}}
{"pid": "P11261", "type": "P", "difficulty": 5, "samples": [["6 9\n1 4 4 5 2 3", "3"], ["10 5\n3 6 1 3 2 1 5 3 4 2", "31"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["2018", "分治", "笛卡尔树", "COTS（克罗地亚）"], "title": "[COTS 2018] 直方图 Histogram", "background": "\n译自 [Izborne Pripreme 2018 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2018/) D1T1。$\\texttt{1s,1G}$。", "description": "\n\n给定笛卡尔坐标系中的直方图，宽度为 $n$，第 $i$ 格的高度为 $h_i$。也就是说，对于 $\\forall 1\\le i\\le n$，第 $i$ 格所占矩形的顶点坐标分别为 $(i-1,0),(i,0),(i-1,h_i),(i,h_i)$。\n\n给定正整数 $p$，求出满足以下条件的矩形的数量：\n\n- 矩形的四个顶点的坐标均为整数；\n- 矩形有一条边在 $x$ 轴上；\n- 矩形完全位于直方图内部（可以与边界相切）；\n- 矩形的面积至少为 $p$。", "inputFormat": "\n第一行，两个正整数 $n,p$。\n\n第二行，$n$ 个正整数 $h_1,h_2,\\ldots,h_n$。", "outputFormat": "\n输出一行一个整数，表示答案。", "hint": "#### 样例解释\n\n样例一解释：\n![](https://cdn.luogu.com.cn/upload/image_hosting/mzxlfq5x.png)\n\n#### 数据范围\n\n对于 $100\\%$ 的数据，保证：\n\n- $1\\le n\\le 10^5$；\n- $1\\le p\\le 10^{14}$；\n- $1\\le h_i\\le 10^{9}$。\n\n\n| 子任务编号 | $n\\le $ |  $p$ | $h_i\\le$   | 得分 |  \n| :--: | :--: | :--: | :--: |  :--: |    \n| $ 1 $    | $ 3\\, 000 $    |  $\\le 10^{12}$ | $ 10^9$ | $ 10 $   |  \n| $ 2 $    | $ 10^5 $   |  $\\le 10^8$ | $1\\, 000$ | $ 15 $   |  \n| $ 3 $    | $ 10^5$ | $=1$ | $10^9$  | $ 15 $   |  \n| $ 4 $    | $ 10^5$ | $\\le 10^5$ | $10^9$ | $  25 $   |  \n| $ 5 $    | $ 10^5$  |  $\\le 10^{14}$ | $10^9$ | $ 35 $   |  \n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COTS 2018] 直方图 Histogram", "background": "\n译自 [Izborne Pripreme 2018 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2018/) D1T1。$\\texttt{1s,1G}$。", "description": "\n\n给定笛卡尔坐标系中的直方图，宽度为 $n$，第 $i$ 格的高度为 $h_i$。也就是说，对于 $\\forall 1\\le i\\le n$，第 $i$ 格所占矩形的顶点坐标分别为 $(i-1,0),(i,0),(i-1,h_i),(i,h_i)$。\n\n给定正整数 $p$，求出满足以下条件的矩形的数量：\n\n- 矩形的四个顶点的坐标均为整数；\n- 矩形有一条边在 $x$ 轴上；\n- 矩形完全位于直方图内部（可以与边界相切）；\n- 矩形的面积至少为 $p$。", "inputFormat": "\n第一行，两个正整数 $n,p$。\n\n第二行，$n$ 个正整数 $h_1,h_2,\\ldots,h_n$。", "outputFormat": "\n输出一行一个整数，表示答案。", "hint": "#### 样例解释\n\n样例一解释：\n![](https://cdn.luogu.com.cn/upload/image_hosting/mzxlfq5x.png)\n\n#### 数据范围\n\n对于 $100\\%$ 的数据，保证：\n\n- $1\\le n\\le 10^5$；\n- $1\\le p\\le 10^{14}$；\n- $1\\le h_i\\le 10^{9}$。\n\n\n| 子任务编号 | $n\\le $ |  $p$ | $h_i\\le$   | 得分 |  \n| :--: | :--: | :--: | :--: |  :--: |    \n| $ 1 $    | $ 3\\, 000 $    |  $\\le 10^{12}$ | $ 10^9$ | $ 10 $   |  \n| $ 2 $    | $ 10^5 $   |  $\\le 10^8$ | $1\\, 000$ | $ 15 $   |  \n| $ 3 $    | $ 10^5$ | $=1$ | $10^9$  | $ 15 $   |  \n| $ 4 $    | $ 10^5$ | $\\le 10^5$ | $10^9$ | $  25 $   |  \n| $ 5 $    | $ 10^5$  |  $\\le 10^{14}$ | $10^9$ | $ 35 $   |  \n", "locale": "zh-CN"}}}
{"pid": "P11262", "type": "P", "difficulty": 5, "samples": [["6 4\n1 3 2 3 1 2\n1 1 2 2\n2 3 3 4\n2 3 4 5\n1 3 2 4", "DA\nNE\nDA\nDA"], ["10 5\n3 3 3 1 2 2 1 2 2 1\n2 3 5 6\n9 10 5 6\n5 6 4 5\n5 8 3 6\n3 7 5 9", "NE\nDA\nDA\nDA\nNE"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["2018", "莫队", "线段树", "可持久化线段树", "哈希 hashing", "COTS（克罗地亚）"], "title": "[COTS 2018] 题日 Zapatak", "background": "\n译自 [Izborne Pripreme 2018 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2018/) D1T2。$\\texttt{1s,1G}$。\n\n关于题目名：原文如此（「题目」的克罗地亚语是「zadatak」）。", "description": "\n定义长度均为 $k$ 的数列 $[a_1,a_2,\\ldots,a_k]$ 和 $[b_1,b_2,\\ldots,b_k]$ **几乎相等**，当且仅当存在**恰好一个** $1\\le p\\le k$，使得 $a_p\\neq b_p$。\n\n定义长度均为 $k$ 的数列 $[a_1,a_2,\\ldots,a_k]$ 和 $[b_1,b_2,\\ldots,b_k]$ **相似**，当且仅当可以通过重排使得 $a,b$ **几乎相等**。\n\n给定长度为 $n$ 的数列 $[a_1,a_2,\\ldots,a_n]$。$m$ 次询问，每次询问给定 $l_1,r_1,l_2,r_2$，问 $[a_{l_1},a_{{l_1}+1},\\ldots,a_{r_1}]$ 与 $[a_{l_2},a_{{l_2}+1},\\ldots,a_{r_2}]$ 是否相似。", "inputFormat": "\n第一行，两个正整数 $n,m$。\n\n第二行，$n$ 个非负整数 $a_1,a_2,\\ldots,a_n$。\n\n接下来 $m$ 行，每行四个正整数 $l_1,r_1,l_2,r_2$，描述一次询问。保证 $r_1-l_1=r_2-l_2$。\n", "outputFormat": "\n对于每个询问，输出一行：\n\n如果答案为是的话，输出 $\\texttt{DA}$（克罗地亚语「是」）；\n\n否则输出 $\\texttt{NE}$（克罗地亚语「否」）。", "hint": "\n\n对于 $100\\%$ 的数据，保证：\n\n- $1\\le n,m\\le 10^5$；\n- $0\\le a_i\\le 10^9$；\n- $1\\le l_1\\le r_1\\le n$，$1\\le l_2\\le r_2\\le n$；\n- $r_1-l_1=r_2-l_2$。\n\n\n| 子任务编号 | $n\\le $ |  $m\\le $ | $a_i\\le$   | 得分 |  \n| :--: | :--: | :--: | :--: |  :--: |    \n| $ 1 $    | $ 1\\, 000 $    |  $1\\, 000$ | $ 10^9$ | $ 10 $   |  \n| $ 2 $    | $ 5\\times 10^4 $   |  $5\\times 10^4$ | $30$ | $ 15 $   |  \n| $ 3 $    | $ 10^5$ | $10^4$ | $10^9$  | $ 30 $   |  \n| $ 4 $    | $ 10^5$ | $10^5$ | $10^9$ | $  45 $   |    \n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COTS 2018] 题日 Zapatak", "background": "\n译自 [Izborne Pripreme 2018 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2018/) D1T2。$\\texttt{1s,1G}$。\n\n关于题目名：原文如此（「题目」的克罗地亚语是「zadatak」）。", "description": "\n定义长度均为 $k$ 的数列 $[a_1,a_2,\\ldots,a_k]$ 和 $[b_1,b_2,\\ldots,b_k]$ **几乎相等**，当且仅当存在**恰好一个** $1\\le p\\le k$，使得 $a_p\\neq b_p$。\n\n定义长度均为 $k$ 的数列 $[a_1,a_2,\\ldots,a_k]$ 和 $[b_1,b_2,\\ldots,b_k]$ **相似**，当且仅当可以通过重排使得 $a,b$ **几乎相等**。\n\n给定长度为 $n$ 的数列 $[a_1,a_2,\\ldots,a_n]$。$m$ 次询问，每次询问给定 $l_1,r_1,l_2,r_2$，问 $[a_{l_1},a_{{l_1}+1},\\ldots,a_{r_1}]$ 与 $[a_{l_2},a_{{l_2}+1},\\ldots,a_{r_2}]$ 是否相似。", "inputFormat": "\n第一行，两个正整数 $n,m$。\n\n第二行，$n$ 个非负整数 $a_1,a_2,\\ldots,a_n$。\n\n接下来 $m$ 行，每行四个正整数 $l_1,r_1,l_2,r_2$，描述一次询问。保证 $r_1-l_1=r_2-l_2$。\n", "outputFormat": "\n对于每个询问，输出一行：\n\n如果答案为是的话，输出 $\\texttt{DA}$（克罗地亚语「是」）；\n\n否则输出 $\\texttt{NE}$（克罗地亚语「否」）。", "hint": "\n\n对于 $100\\%$ 的数据，保证：\n\n- $1\\le n,m\\le 10^5$；\n- $0\\le a_i\\le 10^9$；\n- $1\\le l_1\\le r_1\\le n$，$1\\le l_2\\le r_2\\le n$；\n- $r_1-l_1=r_2-l_2$。\n\n\n| 子任务编号 | $n\\le $ |  $m\\le $ | $a_i\\le$   | 得分 |  \n| :--: | :--: | :--: | :--: |  :--: |    \n| $ 1 $    | $ 1\\, 000 $    |  $1\\, 000$ | $ 10^9$ | $ 10 $   |  \n| $ 2 $    | $ 5\\times 10^4 $   |  $5\\times 10^4$ | $30$ | $ 15 $   |  \n| $ 3 $    | $ 10^5$ | $10^4$ | $10^9$  | $ 30 $   |  \n| $ 4 $    | $ 10^5$ | $10^5$ | $10^9$ | $  45 $   |    \n", "locale": "zh-CN"}}}
{"pid": "P11263", "type": "P", "difficulty": 7, "samples": [["4 6 4\n-----+\n----++\n--++++\n-+++++", "2364"], ["3 3 2\n--+\n--+\n-++", "2"], ["2 3 2\n---\n+++", "0"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["2018", "COTS（克罗地亚）"], "title": "[COTS 2018] 仲裁 Arbitraža", "background": "\n\n译自 [Izborne Pripreme 2018 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2018/) D2T1。$\\texttt{10s,1G}$。\n", "description": "\nA 国和 B 国正在划分一块 $n\\times m$ 的矩形土地。\n\n显然，这块土地上有 $(n-1)$ 条水平线和 $(m-1)$ 条垂直线。\n\n给这 $(n+m-2)$ 条线分配 $[1,k]$ 间的整数。定义一个格子的**权值**为在它左/上方的线上整数之和减去在它右/下方的线上整数之和。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l5bb8lab.png)\n\n给定每个格子权值的要求（要求这个格子的权值 $\\lt 0$ 或者 $\\gt 0$）。在 $k^{n+m-2}$ 种分配整数的方案中，求出有多少个方案符合要求。\n\n只需要输出答案对 $(10^9+7)$ 取模后得到的结果。", "inputFormat": "\n第一行，三个正整数 $n,m,k$。\n\n接下来一个 $n\\times m$ 的矩阵，里面的元素不是 $\\texttt{+}$ 就是 $\\texttt{-}$，表示每个格子权值符号的要求。", "outputFormat": "输出一行一个整数，表示答案。\n", "hint": "\n对于 $100\\%$ 的数据，保证 $1\\le n,m,k\\le 80$。\n\n\n| 子任务编号 | $n$ |  $m $ | $k\\le$   | 特殊性质 |  得分 |  \n| :--: | :--: | :--: | :--: |  :--: |  :--: |\n| $ 1 $    | $ \\le 10 $    |  $\\le 10$ | $ 4$ |  | $ 10 $   |   |\n| $ 2 $    | $ \\le 80 $   |  $=1$ | $80$ | | $ 10 $   |\n| $ 3 $    | $\\le20$ | $\\le 20$ | $20$  |  | $ 10 $   |  \n| $ 4 $    | $\\le40$ | $\\le 40$ | $40$ |   |$  20 $   |   \n| $ 5 $    | $\\le79$ | $=n+1$ | $80$ |  A |$  20 $   |   \n| $ 6 $    | $\\le 80$ | $\\le 80$ | $80$ |  |$  30 $   |   \n\n\n特殊性质 A：$(i,j)$ 要求为 $\\texttt{+}$，当且仅当 $i+j\\ge m+1$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COTS 2018] 仲裁 Arbitraža", "background": "\n\n译自 [Izborne Pripreme 2018 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2018/) D2T1。$\\texttt{10s,1G}$。\n", "description": "\nA 国和 B 国正在划分一块 $n\\times m$ 的矩形土地。\n\n显然，这块土地上有 $(n-1)$ 条水平线和 $(m-1)$ 条垂直线。\n\n给这 $(n+m-2)$ 条线分配 $[1,k]$ 间的整数。定义一个格子的**权值**为在它左/上方的线上整数之和减去在它右/下方的线上整数之和。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l5bb8lab.png)\n\n给定每个格子权值的要求（要求这个格子的权值 $\\lt 0$ 或者 $\\gt 0$）。在 $k^{n+m-2}$ 种分配整数的方案中，求出有多少个方案符合要求。\n\n只需要输出答案对 $(10^9+7)$ 取模后得到的结果。", "inputFormat": "\n第一行，三个正整数 $n,m,k$。\n\n接下来一个 $n\\times m$ 的矩阵，里面的元素不是 $\\texttt{+}$ 就是 $\\texttt{-}$，表示每个格子权值符号的要求。", "outputFormat": "输出一行一个整数，表示答案。\n", "hint": "\n对于 $100\\%$ 的数据，保证 $1\\le n,m,k\\le 80$。\n\n\n| 子任务编号 | $n$ |  $m $ | $k\\le$   | 特殊性质 |  得分 |  \n| :--: | :--: | :--: | :--: |  :--: |  :--: |\n| $ 1 $    | $ \\le 10 $    |  $\\le 10$ | $ 4$ |  | $ 10 $   |   |\n| $ 2 $    | $ \\le 80 $   |  $=1$ | $80$ | | $ 10 $   |\n| $ 3 $    | $\\le20$ | $\\le 20$ | $20$  |  | $ 10 $   |  \n| $ 4 $    | $\\le40$ | $\\le 40$ | $40$ |   |$  20 $   |   \n| $ 5 $    | $\\le79$ | $=n+1$ | $80$ |  A |$  20 $   |   \n| $ 6 $    | $\\le 80$ | $\\le 80$ | $80$ |  |$  30 $   |   \n\n\n特殊性质 A：$(i,j)$ 要求为 $\\texttt{+}$，当且仅当 $i+j\\ge m+1$。", "locale": "zh-CN"}}}
