{"pid": "P4199", "type": "P", "difficulty": 6, "samples": [["abaabaa", "14"], ["aaabbbaaa", "44"], ["aaaaaaaa", "53"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2013", "枚举", "快速傅里叶变换 FFT", "湖北"], "title": "万径人踪灭", "background": "保先生是个好司机，总是开车带学生们上山玩。但是保先生去年开了最后一趟车后，由于一些奇奇怪怪的原因转行了。半年间，再也没有从这条路上山的人了。\n\n当 VFleaKing 再次来到这座山玩的时候，发现已经没有往日的来来往往的游人了。算了，过去保先生还在的时候，来山上玩的人，也不全是来欣赏山上的风景的。", "description": "如果机房马上要关门了，或者你急着要走，请直接跳到第六个自然段。\n\nVFleaKing 注意到了这条上山下山的土路，有些地方能欣赏到美景，有些地方则不能。把上山的道路每 $10$ cm 分为一小段，则对于每一小段，用 `a` 表示能欣赏到美景，用 `b` 表示不能欣赏到美景，就能得到一个只含 `a`、`b` 的字符串 $s$。当然由于下山和上山是一条路，所以下山的道路的字符串就是将上山的道路的字符串反过来。\n\n设上山字符串长度为 $n$，每个字符依次为 $s_1, s_2 .…, s_n$。在上山和下山的路上，VFleaKing 会选择某些小段查看旁边的景色，其他时间低头走路。即 VFleaKing 会选择 $k$ 个小段 $x_1, x_2 …x_k$，且 $k >0$，$1\\le x_1<x_2<…<x_k\\le n$，VFleaKing 上山和下山的过程中会在这些地方查看景色。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/t9qpo3f9.png)\n\nVFleaKing 希望，上山下山时看到的美景的情况相同。也就是说，VFleaKing 上山时是否看到了美景的情况是： $s_{x_1},s_{x_2},\\cdots,s_{x_k}$ 记为字符序列 $T_1$，下山时是否看到了美景的情况是：$s_{x_k},s_{x_{k-1}},\\cdots,s_{x_1}$ 记为字符序列 $T_2$。VFleaKing 希望 $T_1=T_2$。\n\nVFleaKing 还希望，上山下山时查看景色的间隔相等。也就是说，上山时查看景色的间隔为：$x_2-x_1,x_3-x_2,x_k-x_{k-1}$，记为数列 $P_1$。下山时查看景色的间隔为：$x_k-x_{k-1},x_{k-1}-x_{k-2},…,x_2-x_1$，记为数列 $P_2$。VFleaKing 希望 $P_1=P_2$。\n\nVFleaKing 觉得，如果第一次查看景色和最后一次查看景色这段时间里，没有一次低头看路他就会摔倒。也就是说，如果对于所有 $1\\le i\\le k$ 都有$x_i=x_1+i- 1$，VFleaKing 就会摔倒，VFleaKing不希望发生这样的情况。\n\n就是要在一个只含 `a`、`b` 的字符串中选取一个子序列，使得:\n\n1. 位置和字符都关于某条对称轴对称。\n2. 不能是连续的一段。\n\n以 $s = \\texttt{\"abaaaaabbabbabaa\"}$ 为例。如果我们用符号 $[a_1, a_2,…,a_k]$ 表示一个序列，那么 $[1,4]$ 就是一个合法的序列 $x$，$[5,8,10,12,15]$ 也是，$[4,5,8,9,10,11,12,15,16]$ 也是。但是 $[1,2]$ 不满足 VFleaKing 第一个希望和第三个希望，所以不是。$[1,2,4]$ 不满足第二个希望，所以不是。$[9,10,11]$ 不满足第三个希望，所以不是。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6849dqla.png)\n\n给你字符串 $s$，现在 VFleaKing 想知道，有多少个合法的 $x$。答案可能很大，VFleaKing 想知道对 $1000000007$ 取模的值。", "inputFormat": "一行，一个只包含 `a`、`b` 的两种字符的字符串。", "outputFormat": "一行，一个非负整数表示问题的答案。", "hint": "## 样例解释\n\n### 样例解释 1\n\n$14$ 个方案分别是：\n\n- $[1,3]$，$[1,4]$，$[2,5]$，$[1,6]$，$[3,6]$，$[4,6]$，$[1,7]$，$[3,7]$，$[4,7]$；\n- $[1,4,7]$，$[3,5,7]$；\n- $[1,3,4,6]$，$[1,2,5,6]$，$[3,4,6,7]$。\n\n### 样例解释 2\n\n我已经想到了一个绝妙的解释，可惜方案太多，写不下了。\n\n### 样例解释 3\n\n我已经想到了一个绝妙的解释，可惜方案太多，写不下了。\n\n## 数据范围\n\n- 其中 $10\\%$ 的数据，字符串仅包含字母 `a` 或字母 `b`。\n- 另有 $20\\%$ 的数据，$n\\le 1000$。\n- 另有 $20\\%$ 的数据，要么 `a` 的个数不超过 $10$，要么 `a` 的个数不超过 $10$。\n- 另有 $10\\%$ 的数据，$n\\le 10000$。\n- 对于 $100\\%$ 的数据，$n \\le 100000$。\n\n## 来源\n\n- 2013 湖北互测 week1\n- bzoj 3160\n- 信息学奥赛之数学一本通\n- stong9070 整理\n\n", "locale": "zh-CN", "translations": {"en": {"title": "All Paths Deserted", "background": "Mr. Bao is a good driver who always drove students up the mountain for fun. But after his last trip last year, for some strange reasons, he changed careers. For half a year, no one has gone up the mountain along this road.\n\nWhen VFleaKing came back to this mountain, he found that the usual crowds of tourists were gone. Well, even when Mr. Bao was still around, not everyone coming to the mountain was there to enjoy the scenery.", "description": "If the computer room is about to close, or you are in a hurry, please skip directly to the sixth paragraph.\n\nVFleaKing noticed that along the dirt road going up and down the mountain, some places offer beautiful views while others do not. Divide the uphill road into segments of $10$ cm each. For every segment, use `a` to indicate that a nice view can be enjoyed, and `b` to indicate that it cannot. Then you get a string $s$ containing only `a` and `b`. Since going downhill uses the same road, the string for the downhill road is the reverse of the uphill string.\n\nLet the uphill string have length $n$, with characters $s_1, s_2, \\ldots, s_n$ in order. On the way up and down, VFleaKing will choose certain segments to look at the scenery, and keep his head down the rest of the time. That is, VFleaKing chooses $k$ segments $x_1, x_2, \\ldots, x_k$, where $k > 0$ and $1 \\le x_1 < x_2 < \\cdots < x_k \\le n$, and he will look at the scenery at these positions both uphill and downhill.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/t9qpo3f9.png)\n\nVFleaKing wants the results of seeing scenery to be the same uphill and downhill. That is, the sequence of whether he sees scenery uphill is $s_{x_1}, s_{x_2}, \\cdots, s_{x_k}$, denoted by $T_1$, and the sequence downhill is $s_{x_k}, s_{x_{k-1}}, \\cdots, s_{x_1}$, denoted by $T_2$. VFleaKing wants $T_1 = T_2$.\n\nVFleaKing also wants the intervals between these checks to be equal uphill and downhill. That is, the uphill intervals are $x_2 - x_1, x_3 - x_2, \\ldots, x_k - x_{k-1}$, denoted by $P_1$. The downhill intervals are $x_k - x_{k-1}, x_{k-1} - x_{k-2}, \\ldots, x_2 - x_1$, denoted by $P_2$. VFleaKing wants $P_1 = P_2$.\n\nVFleaKing thinks that if, between the first and the last time he looks at the scenery, there is not a single moment when he keeps his head down, he will fall. That is, if for all $1 \\le i \\le k$ we have $x_i = x_1 + i - 1$, then VFleaKing will fall, and he does not want this to happen.\n\nIn short, select a subsequence from a string containing only `a` and `b` such that:\n\n1. Both positions and characters are symmetric about some axis.\n2. It is not a contiguous segment.\n\nTake $s = \\texttt{\"abaaaaabbabbabaa\"}$ as an example. If we use $[a_1, a_2, \\ldots, a_k]$ to denote a sequence, then $[1, 4]$ is a valid sequence $x$, $[5, 8, 10, 12, 15]$ is also valid, and $[4, 5, 8, 9, 10, 11, 12, 15, 16]$ is also valid. However, $[1, 2]$ does not satisfy VFleaKing’s first and third wishes, so it is not valid. $[1, 2, 4]$ does not satisfy the second wish, so it is not valid. $[9, 10, 11]$ does not satisfy the third wish, so it is not valid.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6849dqla.png)\n\nGiven the string $s$, VFleaKing wants to know how many valid sequences $x$ there are. The answer can be large; please output it modulo $1000000007$.", "inputFormat": "One line, a string containing only the two characters `a` and `b`.", "outputFormat": "One line, a non-negative integer representing the answer.", "hint": "Sample Explanation 1\n\nThere are $14$ valid sequences:\n\n- $[1, 3]$, $[1, 4]$, $[2, 5]$, $[1, 6]$, $[3, 6]$, $[4, 6]$, $[1, 7]$, $[3, 7]$, $[4, 7]$;\n- $[1, 4, 7]$, $[3, 5, 7]$;\n- $[1, 3, 4, 6]$, $[1, 2, 5, 6]$, $[3, 4, 6, 7]$.\n\nSample Explanation 2\n\nI have come up with a brilliant explanation, but there are too many cases to fit here.\n\nSample Explanation 3\n\nI have come up with a brilliant explanation, but there are too many cases to fit here.\n\nConstraints\n\n- For $10\\%$ of the testdata, the string contains only the letter `a` or only the letter `b`.\n- For another $20\\%$ of the testdata, $n \\le 1000$.\n- For another $20\\%$ of the testdata, either the number of `a` does not exceed $10$, or the number of `b` does not exceed $10$.\n- For another $10\\%$ of the testdata, $n \\le 10000$.\n- For $100\\%$ of the testdata, $n \\le 100000$.\n\nSource\n\n- 2013 Hubei Mutual Test week 1\n- bzoj 3160\n- A Mathematical Textbook for the Informatics Olympiad\n- Compiled by stong9070\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "万径人踪灭", "background": "保先生是个好司机，总是开车带学生们上山玩。但是保先生去年开了最后一趟车后，由于一些奇奇怪怪的原因转行了。半年间，再也没有从这条路上山的人了。\n\n当 VFleaKing 再次来到这座山玩的时候，发现已经没有往日的来来往往的游人了。算了，过去保先生还在的时候，来山上玩的人，也不全是来欣赏山上的风景的。", "description": "如果机房马上要关门了，或者你急着要走，请直接跳到第六个自然段。\n\nVFleaKing 注意到了这条上山下山的土路，有些地方能欣赏到美景，有些地方则不能。把上山的道路每 $10$ cm 分为一小段，则对于每一小段，用 `a` 表示能欣赏到美景，用 `b` 表示不能欣赏到美景，就能得到一个只含 `a`、`b` 的字符串 $s$。当然由于下山和上山是一条路，所以下山的道路的字符串就是将上山的道路的字符串反过来。\n\n设上山字符串长度为 $n$，每个字符依次为 $s_1, s_2 .…, s_n$。在上山和下山的路上，VFleaKing 会选择某些小段查看旁边的景色，其他时间低头走路。即 VFleaKing 会选择 $k$ 个小段 $x_1, x_2 …x_k$，且 $k >0$，$1\\le x_1<x_2<…<x_k\\le n$，VFleaKing 上山和下山的过程中会在这些地方查看景色。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/t9qpo3f9.png)\n\nVFleaKing 希望，上山下山时看到的美景的情况相同。也就是说，VFleaKing 上山时是否看到了美景的情况是： $s_{x_1},s_{x_2},\\cdots,s_{x_k}$ 记为字符序列 $T_1$，下山时是否看到了美景的情况是：$s_{x_k},s_{x_{k-1}},\\cdots,s_{x_1}$ 记为字符序列 $T_2$。VFleaKing 希望 $T_1=T_2$。\n\nVFleaKing 还希望，上山下山时查看景色的间隔相等。也就是说，上山时查看景色的间隔为：$x_2-x_1,x_3-x_2,x_k-x_{k-1}$，记为数列 $P_1$。下山时查看景色的间隔为：$x_k-x_{k-1},x_{k-1}-x_{k-2},…,x_2-x_1$，记为数列 $P_2$。VFleaKing 希望 $P_1=P_2$。\n\nVFleaKing 觉得，如果第一次查看景色和最后一次查看景色这段时间里，没有一次低头看路他就会摔倒。也就是说，如果对于所有 $1\\le i\\le k$ 都有$x_i=x_1+i- 1$，VFleaKing 就会摔倒，VFleaKing不希望发生这样的情况。\n\n就是要在一个只含 `a`、`b` 的字符串中选取一个子序列，使得:\n\n1. 位置和字符都关于某条对称轴对称。\n2. 不能是连续的一段。\n\n以 $s = \\texttt{\"abaaaaabbabbabaa\"}$ 为例。如果我们用符号 $[a_1, a_2,…,a_k]$ 表示一个序列，那么 $[1,4]$ 就是一个合法的序列 $x$，$[5,8,10,12,15]$ 也是，$[4,5,8,9,10,11,12,15,16]$ 也是。但是 $[1,2]$ 不满足 VFleaKing 第一个希望和第三个希望，所以不是。$[1,2,4]$ 不满足第二个希望，所以不是。$[9,10,11]$ 不满足第三个希望，所以不是。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6849dqla.png)\n\n给你字符串 $s$，现在 VFleaKing 想知道，有多少个合法的 $x$。答案可能很大，VFleaKing 想知道对 $1000000007$ 取模的值。", "inputFormat": "一行，一个只包含 `a`、`b` 的两种字符的字符串。", "outputFormat": "一行，一个非负整数表示问题的答案。", "hint": "## 样例解释\n\n### 样例解释 1\n\n$14$ 个方案分别是：\n\n- $[1,3]$，$[1,4]$，$[2,5]$，$[1,6]$，$[3,6]$，$[4,6]$，$[1,7]$，$[3,7]$，$[4,7]$；\n- $[1,4,7]$，$[3,5,7]$；\n- $[1,3,4,6]$，$[1,2,5,6]$，$[3,4,6,7]$。\n\n### 样例解释 2\n\n我已经想到了一个绝妙的解释，可惜方案太多，写不下了。\n\n### 样例解释 3\n\n我已经想到了一个绝妙的解释，可惜方案太多，写不下了。\n\n## 数据范围\n\n- 其中 $10\\%$ 的数据，字符串仅包含字母 `a` 或字母 `b`。\n- 另有 $20\\%$ 的数据，$n\\le 1000$。\n- 另有 $20\\%$ 的数据，要么 `a` 的个数不超过 $10$，要么 `a` 的个数不超过 $10$。\n- 另有 $10\\%$ 的数据，$n\\le 10000$。\n- 对于 $100\\%$ 的数据，$n \\le 100000$。\n\n## 来源\n\n- 2013 湖北互测 week1\n- bzoj 3160\n- 信息学奥赛之数学一本通\n- stong9070 整理\n\n", "locale": "zh-CN"}}}
{"pid": "P4200", "type": "P", "difficulty": 6, "samples": [["5\n1 1 1\n3 1 2\n4 4 4\n2 0 1\n2 2 3\n5\n1 1 2\n2 4 4\n2 4 3\n3 0 1\n5 0 1", "3\n4\n6\n8\n8"], ["5\n1803632939 1051911108 963670239\n296082233 384714041 782958792\n1706221977 1051911108 963670239\n1890039364 -1429456864 794782986\n1152753107 1932597483 1442217530\n10\n3 -1429456864 794782986\n2 -1429456864 794782986\n4 -1429456864 794782986\n4 2062723523 -411953943\n5 -1429456864 794782986\n4 1051911108 963670239\n4 1051911108 963670239\n1 1051911108 963670239\n1 1051911108 963670239\n5 -1429456864 794782986", "1890039364\n3780078728\n3780078728\n3607265878\n3412443954"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2013", "平衡树", "湖北"], "title": "千山鸟飞绝", "background": "", "description": "话说有一天 doyouloveme 和 vfleaking 到山里玩。谁知 doyouloveme 刚刚进山，所有的鸟儿竟被他的神犇气场给惊得全部飞走了。vfleaking 顿时膜拜不已。\n\n这时鸟王用鸟语说道：「!@#\\$%…?」，安抚了一下众鸟的情绪。鸟王生性好斗，作出了一个决定：要排鸟布阵把刚才吓到它们的人类赶出山去。\n\n每只鸟都有一个编号，都有一个威武值。每秒钟鸟王都会发一个命令，编号为 $v$ 的鸟飞到 $(x,y)$ 去（坐标系原点是山顶，坐标单位为鸟爪）。鸟飞得很快，一秒之内就飞到了，可以看作是瞬间移动。如果编号为 $v$ 的鸟和编号为 $u$ 的鸟某一时刻处在同一位置，它们就会互相鼓励，增加各自的士气值和团结值。一只鸟的士气值等于此刻与它处在同一位置的鸟中的威武值的最大值，团结值等于此刻与它处在同一位置的鸟的只数。如果每一时刻都没有鸟与它处在同一位置，则士气值和团结值都为 $0$。要注意自己不能鼓励自己，计算士气值和团结值时不能算上自己。\n\n$t$ 秒钟后，doyouloveme 目测出了现在每只鸟的战斗力，于是感叹了一句：「不妙，我们得走了。」\n\n正所谓团结的鸟儿一个顶俩，所以 doyouloveme 这样描述战斗力：一只鸟战斗力值等于它在 $0$ 到 $t$ 秒中士气值的最大值与团结值的最大值的乘积。注意不是乘积的最大值，而是最大值的乘积。\n\nvfleaking 很想知道现在每只鸟的战斗力，但是他当然不会啦，于是他把这个任务交给了你来完成。\n", "inputFormat": "第一行一个整数 $n$，代表鸟的只数。（鸟王那家伙你可以完全忽视掉）\n\n接下来 $n$ 行，每行三个整数 $w,x,y$ 描述每只鸟的威武值和初始坐标。第 $i+1$ 行描述编号为i的鸟。\n\n接下来一行有一个整数 $t$，代表经过时间 $t$ 秒。\n\n接下来 $t$ 行，每行三个整数 $v,x,y$ 描述鸟王每秒的命令。\n", "outputFormat": "一共 $n$ 行，每行一个数，代表每只鸟的战斗力。", "hint": "对于 $100\\%$ 的数据，$1≤n≤30000$，$0≤t≤300000$，坐标为整数，均在 $[-2^{31},2^{31})$ 内。\n\n威武值为不超过 $2^{31}-1$ 的非负整数。", "locale": "zh-CN", "translations": {"en": {"title": "Across a Thousand Mountains, No Birds in Flight", "background": "", "description": "One day, doyouloveme and vfleaking went to play in the mountains. As soon as doyouloveme entered, all the birds were startled by his \"shen niu\" (shen niu, divine-cow, slang for an awesome person) aura and flew away. vfleaking immediately bowed in awe.\n\nThen the bird king said in birdspeak: 「!@#\\$%…?」, calming the flock. Being naturally combative, the bird king made a decision: line up the birds in formation to drive the humans who had just scared them out of the mountains.\n\nEach bird has an ID and a might value. Every second, the bird king issues a command: the bird with ID $v$ flies to $(x, y)$ (the origin of the coordinate system is the mountain peak, and the unit of length is a bird claw). Birds fly very fast and arrive within the same second; you can think of it as teleportation. If at any moment the bird with ID $v$ and the bird with ID $u$ are at the same position, they encourage each other, increasing their morale value and unity value. A bird’s morale value at that moment is the maximum might value among the birds at the same position as it at that moment, and its unity value is the number of birds at the same position as it at that moment. If at every moment no bird is at the same position as it, then both the morale value and the unity value are $0$. Note that a bird cannot encourage itself; when computing morale and unity, do not include itself.\n\nAfter $t$ seconds, doyouloveme eyeballed the current combat power of each bird and sighed, “Not good, we have to go.”\n\nAs the saying goes, united birds count for two, so doyouloveme describes combat power like this: a bird’s combat power equals the product of its maximum morale value over seconds $0$ to $t$ and its maximum unity value over seconds $0$ to $t$. Note: it is not the maximum of the product, but the product of the maxima.\n\nvfleaking wants to know the combat power of every bird, but of course he can’t compute it, so he’s handed the task to you.", "inputFormat": "The first line contains an integer $n$, the number of birds. (You can completely ignore that fellow, the bird king.)\n\nThe next $n$ lines each contain three integers $w, x, y$, describing each bird’s might value and initial coordinates. Line $i + 1$ describes the bird with ID $i$.\n\nThe next line contains an integer $t$, the number of seconds that have elapsed.\n\nThe next $t$ lines each contain three integers $v, x, y$, describing the bird king’s command for each second.", "outputFormat": "Output $n$ lines. Each line contains one number: the combat power of the corresponding bird.", "hint": "Constraints:\n\n- For $100\\%$ of the testdata, $1 \\le n \\le 30000$, $0 \\le t \\le 300000$. Coordinates are integers and lie in $[-2^{31}, 2^{31})$.\n- Might values are non-negative integers not exceeding $2^{31} - 1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "千山鸟飞绝", "background": "", "description": "话说有一天 doyouloveme 和 vfleaking 到山里玩。谁知 doyouloveme 刚刚进山，所有的鸟儿竟被他的神犇气场给惊得全部飞走了。vfleaking 顿时膜拜不已。\n\n这时鸟王用鸟语说道：「!@#\\$%…?」，安抚了一下众鸟的情绪。鸟王生性好斗，作出了一个决定：要排鸟布阵把刚才吓到它们的人类赶出山去。\n\n每只鸟都有一个编号，都有一个威武值。每秒钟鸟王都会发一个命令，编号为 $v$ 的鸟飞到 $(x,y)$ 去（坐标系原点是山顶，坐标单位为鸟爪）。鸟飞得很快，一秒之内就飞到了，可以看作是瞬间移动。如果编号为 $v$ 的鸟和编号为 $u$ 的鸟某一时刻处在同一位置，它们就会互相鼓励，增加各自的士气值和团结值。一只鸟的士气值等于此刻与它处在同一位置的鸟中的威武值的最大值，团结值等于此刻与它处在同一位置的鸟的只数。如果每一时刻都没有鸟与它处在同一位置，则士气值和团结值都为 $0$。要注意自己不能鼓励自己，计算士气值和团结值时不能算上自己。\n\n$t$ 秒钟后，doyouloveme 目测出了现在每只鸟的战斗力，于是感叹了一句：「不妙，我们得走了。」\n\n正所谓团结的鸟儿一个顶俩，所以 doyouloveme 这样描述战斗力：一只鸟战斗力值等于它在 $0$ 到 $t$ 秒中士气值的最大值与团结值的最大值的乘积。注意不是乘积的最大值，而是最大值的乘积。\n\nvfleaking 很想知道现在每只鸟的战斗力，但是他当然不会啦，于是他把这个任务交给了你来完成。\n", "inputFormat": "第一行一个整数 $n$，代表鸟的只数。（鸟王那家伙你可以完全忽视掉）\n\n接下来 $n$ 行，每行三个整数 $w,x,y$ 描述每只鸟的威武值和初始坐标。第 $i+1$ 行描述编号为i的鸟。\n\n接下来一行有一个整数 $t$，代表经过时间 $t$ 秒。\n\n接下来 $t$ 行，每行三个整数 $v,x,y$ 描述鸟王每秒的命令。\n", "outputFormat": "一共 $n$ 行，每行一个数，代表每只鸟的战斗力。", "hint": "对于 $100\\%$ 的数据，$1≤n≤30000$，$0≤t≤300000$，坐标为整数，均在 $[-2^{31},2^{31})$ 内。\n\n威武值为不超过 $2^{31}-1$ 的非负整数。", "locale": "zh-CN"}}}
{"pid": "P4201", "type": "P", "difficulty": 5, "samples": [["5 4 100 \n1 2 \n4 5 \n1 3 \n4 1", "1 \n10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "NOI"], "title": "[NOI2008] 设计路线", "background": "", "description": "Z 国坐落于遥远而又神奇的东方半岛上，在小 Z 的统治时代公路成为这里主要的交通手段。Z 国共有 $N$ 座城市，一些城市之间由双向的公路所连接。非常神奇的是 Z 国的每个城市所处的经度都不相同，并且最多只和一个位于它东边的城市直接通过公路相连。Z 国的首都是 Z 国政治经济文化旅游的中心，每天都有成千上万的人从 Z 国的其他城市涌向首都。\n\n为了使 Z 国的交通更加便利顺畅，小 Z 决定在 Z 国的公路系统中确定若干条规划路线，将其中的公路全部改建为铁路。\n\n我们定义每条规划路线为一个长度大于 $1$ 的城市序列，每个城市在该序列中最多出现一次，序列中相邻的城市之间由公路直接相连（待改建为铁路）。并且，每个城市最多只能出现在一条规划路线中，也就是说，任意两条规划路线不能有公共部分。\n\n当然在一般情况下是不可能将所有的公路修建为铁路的，因此从有些城市出发去往首都依然需要通过乘坐长途汽车，而长途汽车只往返于公路连接的相邻的城市之间，因此从某个城市出发可能需要不断地换乘长途汽车和火车才能到达首都。\n\n我们定义一个城市的“不便利值”为从它出发到首都需要乘坐的长途汽车的次数，而 Z 国的交通系统的“不便利值”为所有城市的不便利值的最大值，很明显首都的“不便利值”为 $0$。小 Z 想知道如何确定规划路线修建铁路使得 Z 国的交通系统的“不便利值”最小，以及有多少种不同的规划路线的选择方案使得“不便利值”达到最小。当然方案总数可能非常大，小 Z 只关心这个天文数字 $\\bmod\\ Q$ 后的值。\n\n注意：规划路线 $1-2-3$ 和规划路线 $3-2-1$ 是等价的，即将一条规划路线翻转，依然认为是等价的。两个方案不同当且仅当其中一个方案中存在一条规划路线不属于另一个方案。\n\n", "inputFormat": "第一行包含三个正整数 $N,M,Q$，其中 $N$ 表示城市个数， $M$ 表示公路总数，$N$ 个城市从 $1 \\sim N$ 编号，其中编号为 $1$ 的是首都。$Q$ 表示上文提到的设计路线的方法总数的模数。\n\n接下来 $M$ 行，每行两个不同的整数 $a_i,b_i(1 \\le a_i,b_i \\le N)$，表示有一条公路连接城市 $a_i$ 和城市 $b_i$。\n\n输入数据保证一条公路只出现一次。", "outputFormat": "应包含两行。\n\n第 $1$ 行为一个整数，表示最小的“不便利值”。\n\n第 $2$ 行为一个整数，表示使“不便利值”达到最小时不同的设计路线的方法总数 $\\bmod\\ Q$ 的值。\n\n如果某个城市无法到达首都，则输出两行 $-1$。", "hint": "对于 $20 \\%$ 的数据，$1 \\le N,M \\le 10$。\n\n对于 $50 \\%$ 的数据，$1 \\le N,M \\le 200$。\n\n对于 $60 \\%$ 的数据，$1 \\le N,M \\le 5000$。\n\n对于 $100 \\%$ 的数据，$1 \\le N,M \\le 10 ^ 5$，$1 \\le Q \\le 1.2 \\times 10 ^ 8$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2008] Designing Routes", "background": "", "description": "Country Z lies on a distant and magical eastern peninsula. During the reign of Xiao Z, highways became the main mode of transportation. There are $N$ cities in Country Z, and some pairs of cities are connected by bidirectional highways. Remarkably, each city has a unique longitude, and each city is directly connected by highway to at most one city located to its east. The capital is the political, economic, cultural, and tourism center of Country Z, and every day thousands of people flow into the capital from other cities.\n\nTo make transportation more convenient and efficient, Xiao Z decides to designate several planned routes in the highway system and rebuild all highways on these routes into railways.\n\nWe define each planned route as a city sequence of length strictly greater than $1$, where each city appears at most once in the sequence, and each pair of adjacent cities in the sequence is directly connected by a highway (to be rebuilt into railway). Moreover, each city can appear in at most one planned route, i.e., any two planned routes must be vertex-disjoint.\n\nOf course, in general it is impossible to rebuild all highways into railways, so traveling from some cities to the capital still requires taking long-distance buses. Long-distance buses only run between adjacent cities that are connected by a highway, so starting from a given city, one may need to alternate between taking buses and trains to reach the capital.\n\nWe define the “inconvenience value” of a city as the number of times one must take a long-distance bus to reach the capital from that city. The “inconvenience value” of the transportation system is the maximum inconvenience value over all cities. Clearly, the capital’s inconvenience value is $0$. Xiao Z wants to know how to choose planned routes to minimize the system’s inconvenience value, and how many different choices of planned routes achieve this minimum. Since the total number of plans may be huge, Xiao Z only cares about this astronomical number modulo $Q$.\n\nNote: A planned route $1-2-3$ is equivalent to $3-2-1$, i.e., reversing a planned route is considered the same. Two plans are different if and only if there exists a planned route that appears in one plan but not in the other.", "inputFormat": "The first line contains three positive integers $N, M, Q$, where $N$ is the number of cities, $M$ is the number of highways, and the cities are numbered from $1$ to $N$, with city $1$ being the capital. $Q$ is the modulus mentioned above for the number of route-design methods.\n\nEach of the next $M$ lines contains two distinct integers $a_i, b_i$ ($1 \\le a_i, b_i \\le N$), indicating that there is a highway connecting city $a_i$ and city $b_i$.\n\nThe input guarantees that each highway appears exactly once.", "outputFormat": "Output two lines.\n\nThe first line contains one integer: the minimal “inconvenience value.”\n\nThe second line contains one integer: the number of different route-design methods that achieve the minimal “inconvenience value,” modulo $Q$.\n\nIf some city cannot reach the capital, output two lines, each containing $-1$.", "hint": "For $20\\%$ of the testdata, $1 \\le N, M \\le 10$.\n\nFor $50\\%$ of the testdata, $1 \\le N, M \\le 200$.\n\nFor $60\\%$ of the testdata, $1 \\le N, M \\le 5000$.\n\nFor $100\\%$ of the testdata, $1 \\le N, M \\le 10^5$, $1 \\le Q \\le 1.2 \\times 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2008] 设计路线", "background": "", "description": "Z 国坐落于遥远而又神奇的东方半岛上，在小 Z 的统治时代公路成为这里主要的交通手段。Z 国共有 $N$ 座城市，一些城市之间由双向的公路所连接。非常神奇的是 Z 国的每个城市所处的经度都不相同，并且最多只和一个位于它东边的城市直接通过公路相连。Z 国的首都是 Z 国政治经济文化旅游的中心，每天都有成千上万的人从 Z 国的其他城市涌向首都。\n\n为了使 Z 国的交通更加便利顺畅，小 Z 决定在 Z 国的公路系统中确定若干条规划路线，将其中的公路全部改建为铁路。\n\n我们定义每条规划路线为一个长度大于 $1$ 的城市序列，每个城市在该序列中最多出现一次，序列中相邻的城市之间由公路直接相连（待改建为铁路）。并且，每个城市最多只能出现在一条规划路线中，也就是说，任意两条规划路线不能有公共部分。\n\n当然在一般情况下是不可能将所有的公路修建为铁路的，因此从有些城市出发去往首都依然需要通过乘坐长途汽车，而长途汽车只往返于公路连接的相邻的城市之间，因此从某个城市出发可能需要不断地换乘长途汽车和火车才能到达首都。\n\n我们定义一个城市的“不便利值”为从它出发到首都需要乘坐的长途汽车的次数，而 Z 国的交通系统的“不便利值”为所有城市的不便利值的最大值，很明显首都的“不便利值”为 $0$。小 Z 想知道如何确定规划路线修建铁路使得 Z 国的交通系统的“不便利值”最小，以及有多少种不同的规划路线的选择方案使得“不便利值”达到最小。当然方案总数可能非常大，小 Z 只关心这个天文数字 $\\bmod\\ Q$ 后的值。\n\n注意：规划路线 $1-2-3$ 和规划路线 $3-2-1$ 是等价的，即将一条规划路线翻转，依然认为是等价的。两个方案不同当且仅当其中一个方案中存在一条规划路线不属于另一个方案。\n\n", "inputFormat": "第一行包含三个正整数 $N,M,Q$，其中 $N$ 表示城市个数， $M$ 表示公路总数，$N$ 个城市从 $1 \\sim N$ 编号，其中编号为 $1$ 的是首都。$Q$ 表示上文提到的设计路线的方法总数的模数。\n\n接下来 $M$ 行，每行两个不同的整数 $a_i,b_i(1 \\le a_i,b_i \\le N)$，表示有一条公路连接城市 $a_i$ 和城市 $b_i$。\n\n输入数据保证一条公路只出现一次。", "outputFormat": "应包含两行。\n\n第 $1$ 行为一个整数，表示最小的“不便利值”。\n\n第 $2$ 行为一个整数，表示使“不便利值”达到最小时不同的设计路线的方法总数 $\\bmod\\ Q$ 的值。\n\n如果某个城市无法到达首都，则输出两行 $-1$。", "hint": "对于 $20 \\%$ 的数据，$1 \\le N,M \\le 10$。\n\n对于 $50 \\%$ 的数据，$1 \\le N,M \\le 200$。\n\n对于 $60 \\%$ 的数据，$1 \\le N,M \\le 5000$。\n\n对于 $100 \\%$ 的数据，$1 \\le N,M \\le 10 ^ 5$，$1 \\le Q \\le 1.2 \\times 10 ^ 8$。", "locale": "zh-CN"}}}
{"pid": "P4202", "type": "P", "difficulty": 7, "samples": [["4 1 0.5  \n2 3 1 3 \n10.0 10.0 10.0 10.0", "30.00 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "NOI"], "title": "[NOI2008] 奥运物流", "background": "", "description": "2008 北京奥运会即将开幕，举国上下都在为这一盛事做好准备。为了高效率、 成功地举办奥运会，对物流系统进行规划是必不可少的。\n\n物流系统由若干物流基站组成，以 $1$ 到 $n$ 进行编号。每个物流基站 $i$ 都有且仅有一个后继基站 $S_i$，而可以有多个前驱基站。基站 $i$ 中需要继续运输的物资都将被运往后继基站 $S_i$，显然一个物流基站的后继基站不能是其本身。编号为 $1$ 的 物流基站称为控制基站，从任何物流基站都可将物资运往控制基站。注意控制基站也有后继基站，以便在需要时进行物资的流通。在物流系统中，高可靠性与低成本是主要设计目的。对于基站 $i$，我们定义其“可靠性” $R(i)$ 如下： \n设物流基站 $i$ 有 $w$ 个前驱基站 $P_1,P_2,\\cdots,P_w$，即这些基站以 $i$ 为后继基站，则基 站 $i$ 的可靠性 $R(i)$ 满足下式： \n$$R(i)=C_i+k \\sum_{j=1}^{w}R(P_j).$$\n\n其中 $C_i$ 和 $k$ 都是常实数且恒为正，且有 $k$ 小于 $1$。\n\n整个系统的可靠性与控制基站的可靠性正相关，我们的目标是通过修改物流系统，即更改某些基站的后继基站，使得控制基站的可靠性 $R(1)$ 尽量大。但由于经费限制，最多只能修改 $m$ 个基站的后继基站，并且，控制基站的后继基站不可被修改。因而我们所面临的问题就是，如何修改不超过 $m$ 个基站的后继，使得控制基站的可靠性 $R(1)$ 最大化。\n", "inputFormat": "第一行包含两个整数与一个实数，$n,m,k$。其中 $n$ 表示基站数目，$m$ 表示最多可修改的后继基站数目，$k$ 分别为可靠性定义中的常数。\n\n第二行包含 $n$ 个整数，分别是 $S_1,S_2\\cdots,S_n$，即每一个基站的后继基站编号。\n\n第三行包含 $n$ 个正实数，分别是 $C_1,C_2\\cdots,C_n$，为可靠性定义中的常数。", "outputFormat": "仅包含一个实数，为可得到的最大 $R(1)$。精确到小数点两位。", "hint": "【样例说明】 \n原有物流系统如左图所示，$4$ 个物流基站的可靠性依次为 $22.8571,21.4286,25.7143,10$。\n\n最优方案为将 $2$ 号基站的后继基站改为 $1$ 号。\n\n此时 $4$ 个基站的可靠性依次为 $30,25,15,10$。\n本题的数据，具有如下分布： \n\n测试数据编号| $n$ | $m$\n:-:|:-:|:-:\n$1$|$\\leq6$| $\\leq6$\n$2$|$\\leq12$|$\\leq12$\n$3$|$\\leq60$|$0$\n$4$|$\\leq60$|$1$\n$5$|$\\leq 60$|$N-2$\n$6,7,8,9,10$|$\\leq60$|$\\leq60$\n\n 对于所有的数据，满足 $m \\leq n \\leq 60$，$C_i \\leq 10^6$，$0.3 \\leq k < 1$，请使用双精度实数，无需考虑由此带来的误差。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2008] Olympic Logistics", "background": "", "description": "The 2008 Beijing Olympic Games are about to open, and the whole country is preparing for this grand event. To hold the Games efficiently and successfully, it is essential to plan the logistics system.\n\nThe logistics system consists of several logistics base stations, numbered from $1$ to $n$. Each logistics base station $i$ has exactly one successor station $S_i$, and may have multiple predecessor stations. All goods at station $i$ that need to continue transportation will be sent to its successor station $S_i$. Obviously, a station cannot be its own successor. Station $1$ is called the control station, and goods can be sent from any station to the control station. Note that the control station also has a successor station, so that circulation is possible when needed. In the logistics system, high reliability and low cost are the main design goals. For station $i$, we define its “reliability” $R(i)$ as follows:\nSuppose station $i$ has $w$ predecessor stations $P_1, P_2, \\cdots, P_w$, i.e., these stations take $i$ as their successor station, then the reliability $R(i)$ of station $i$ satisfies:\n$$R(i)=C_i+k \\sum_{j=1}^{w}R(P_j).$$\n\nHere $C_i$ and $k$ are fixed positive real numbers, and $k$ is less than $1$.\n\nThe overall system reliability is positively correlated with the reliability of the control station. Our goal is to modify the logistics system—i.e., change the successors of some stations—so that the reliability $R(1)$ of the control station is as large as possible. Due to budget constraints, at most $m$ stations’ successors can be modified, and the successor of the control station cannot be modified. Therefore, the problem is: how to modify the successors of no more than $m$ stations to maximize the reliability $R(1)$ of the control station.", "inputFormat": "The first line contains two integers and a real number, $n, m, k$. Here $n$ is the number of stations, $m$ is the maximum number of successor changes allowed, and $k$ is the constant in the reliability definition.\n\nThe second line contains $n$ integers, $S_1, S_2 \\cdots S_n$, the successor station index of each station.\n\nThe third line contains $n$ positive real numbers, $C_1, C_2 \\cdots C_n$, the constants in the reliability definition.", "outputFormat": "Output a single real number: the maximum achievable $R(1)$. Round to two decimal places.", "hint": "[Sample explanation]\nIn the original logistics system (as shown in the left figure), the reliabilities of the $4$ stations are $22.8571, 21.4286, 25.7143, 10$ in order.\n\nThe optimal plan is to change the successor of station $2$ to station $1$.\n\nThen the reliabilities of the $4$ stations become $30, 25, 15, 10$ in order.\nThe testdata is distributed as follows:\n\n测试数据编号| $n$ | $m$\n:-:|:-:|:-:\n$1$|$\\leq 6$|$\\leq 6$\n$2$|$\\leq 12$|$\\leq 12$\n$3$|$\\leq 60$|$0$\n$4$|$\\leq 60$|$1$\n$5$|$\\leq 60$|$n-2$\n$6, 7, 8, 9, 10$|$\\leq 60$|$\\leq 60$\n\nFor all testdata, $m \\leq n \\leq 60$, $C_i \\leq 10^6$, $0.3 \\leq k < 1$. Please use double-precision floating-point numbers; you do not need to worry about the error introduced.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2008] 奥运物流", "background": "", "description": "2008 北京奥运会即将开幕，举国上下都在为这一盛事做好准备。为了高效率、 成功地举办奥运会，对物流系统进行规划是必不可少的。\n\n物流系统由若干物流基站组成，以 $1$ 到 $n$ 进行编号。每个物流基站 $i$ 都有且仅有一个后继基站 $S_i$，而可以有多个前驱基站。基站 $i$ 中需要继续运输的物资都将被运往后继基站 $S_i$，显然一个物流基站的后继基站不能是其本身。编号为 $1$ 的 物流基站称为控制基站，从任何物流基站都可将物资运往控制基站。注意控制基站也有后继基站，以便在需要时进行物资的流通。在物流系统中，高可靠性与低成本是主要设计目的。对于基站 $i$，我们定义其“可靠性” $R(i)$ 如下： \n设物流基站 $i$ 有 $w$ 个前驱基站 $P_1,P_2,\\cdots,P_w$，即这些基站以 $i$ 为后继基站，则基 站 $i$ 的可靠性 $R(i)$ 满足下式： \n$$R(i)=C_i+k \\sum_{j=1}^{w}R(P_j).$$\n\n其中 $C_i$ 和 $k$ 都是常实数且恒为正，且有 $k$ 小于 $1$。\n\n整个系统的可靠性与控制基站的可靠性正相关，我们的目标是通过修改物流系统，即更改某些基站的后继基站，使得控制基站的可靠性 $R(1)$ 尽量大。但由于经费限制，最多只能修改 $m$ 个基站的后继基站，并且，控制基站的后继基站不可被修改。因而我们所面临的问题就是，如何修改不超过 $m$ 个基站的后继，使得控制基站的可靠性 $R(1)$ 最大化。\n", "inputFormat": "第一行包含两个整数与一个实数，$n,m,k$。其中 $n$ 表示基站数目，$m$ 表示最多可修改的后继基站数目，$k$ 分别为可靠性定义中的常数。\n\n第二行包含 $n$ 个整数，分别是 $S_1,S_2\\cdots,S_n$，即每一个基站的后继基站编号。\n\n第三行包含 $n$ 个正实数，分别是 $C_1,C_2\\cdots,C_n$，为可靠性定义中的常数。", "outputFormat": "仅包含一个实数，为可得到的最大 $R(1)$。精确到小数点两位。", "hint": "【样例说明】 \n原有物流系统如左图所示，$4$ 个物流基站的可靠性依次为 $22.8571,21.4286,25.7143,10$。\n\n最优方案为将 $2$ 号基站的后继基站改为 $1$ 号。\n\n此时 $4$ 个基站的可靠性依次为 $30,25,15,10$。\n本题的数据，具有如下分布： \n\n测试数据编号| $n$ | $m$\n:-:|:-:|:-:\n$1$|$\\leq6$| $\\leq6$\n$2$|$\\leq12$|$\\leq12$\n$3$|$\\leq60$|$0$\n$4$|$\\leq60$|$1$\n$5$|$\\leq 60$|$N-2$\n$6,7,8,9,10$|$\\leq60$|$\\leq60$\n\n 对于所有的数据，满足 $m \\leq n \\leq 60$，$C_i \\leq 10^6$，$0.3 \\leq k < 1$，请使用双精度实数，无需考虑由此带来的误差。", "locale": "zh-CN"}}}
{"pid": "P4203", "type": "P", "difficulty": 6, "samples": [["10 10 \n1 0 10 1 3 -1 \n2 1 0 0 \n2 11 0 10 \n2 11 0 9 \n1 11 13 4 7 1 \n2 13 9 9 \n2 13 10 10 \n3 100 13 \n3 1999999999 10 \n1 2000000000 10 0 1 1", "1 \n1 \n0 \n2 \n1 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "NOI"], "title": "[NOI2008] 糖果雨", "background": "", "description": "有一个美丽的童话：在天空的尽头有一个\"糖果国\"，这里大到摩天大厦，小 到小花小草都是用糖果建造而成的。更加神奇的是，天空中飘满了五颜六色的糖 果云，很快糖果雨密密麻麻从天而落，红色的是草莓糖，黄色的是柠檬糖，绿色 的是薄荷糖，黑色的是巧克力糖……这时糖果国的小朋友们便会拿出大大小小的 口袋来接天空中落下的糖果，拿回去与朋友们一起分享。\n\n对糖果情有独钟的小 Z 憧憬着能够来到这样一个童话的国度。所谓日有所 思，夜有所梦，这天晚上小 Z 梦见自己来到了\"糖果国\"。他惊喜地发现，任何时 候天空中所有的云朵颜色都不相同，不同颜色的云朵在不断地落下相应颜色的糖 果。更加有趣的是所有的云朵都在做着匀速往返运动，不妨想象天空是有边界的， 而所有的云朵恰好在两个边界之间做着往返运动。每一个单位时间云朵向左或向 右运动一个单位，当云朵的左界碰到天空的左界，它会改变方向向右运动；当云 朵完全移出了天空的右界，它会改变方向向左运动。\n\n我们不妨把天空想象为一个平面直角坐标系，而云朵则抽象为线段(线段可 能退化为点)： \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hsdveny3.png)\n\n如上图，不妨设天空的左界为 0，右界为 len。图中共有 5 片云朵，其中标 号为 1 的云朵恰好改变方向向右运动，标号为 2 的云朵恰好改变方向向左运动。\n\n忽略云朵的纵坐标，它们在运动过程中不会相互影响。\n\n小 Z 发现天空中会不断出现一些云朵(某个时刻从某个初始位置开始朝某个 方向运动)，而有的云朵运动到一定时刻就会从天空中消失，而在运动的过程中 糖果在不断地下落。小 Z 决定拿很多口袋来接糖果，口袋容量是无限的，但袋 口大小却是有限的。例如在时刻 T 小 Z 拿一个横坐标范围为[L, R]的口袋来接糖 果，如果[L, R]存在一个位置 x，该位置有某种颜色的糖果落下，则认为该口袋可 接到此种颜色的糖果。极端情况下，袋口区间可能是一个点，譬如[0,0]、[1,1]，但仍然可以接到相应位置的糖果。通常可以接到的糖果总数会很大，因而小 Z 想知道每一次(即拿出口袋的一瞬间)他的口袋可以接到多少种不同颜色的糖果。\n\n糖果下落的时间忽略不计。", "inputFormat": "输入文件第一行有两个正整数 n, len，分别表示事件总数以及天空 的“边界”。\n\n    接下来 n 行每行描述一个事件，所有的事件按照输入顺序依次发生。每行的 第一个数 k（k = 1，2，3）分别表示事件的类型，分别对应三种事件：插入事件， 询问事件以及删除事件。输入格式如下： \n\n事件类型|输入格式|说明 \n-|-|-\n插入事件 (天空中出现了一片 云朵)|`1 Ti Ci Li Ri Di`|时刻 Ti，天空中出现了一片 坐标范围为[Li, Ri]，颜色为 Ci的 云朵，初始的时候云朵运动方向 为向左(Di = -1)或向右(Di = 1)。满足 0 ≤ Li ≤ Ri ≤ len，Di = -1 或 1。数据保证任何时刻空中不 会出现两片颜色相同的云朵。\n询问事件 (询问一个口袋可以 接到多少种不同颜 色的糖果)|`2 Ti Li Ri` |时刻 Ti，小 Z 用一个坐标范 围为[Li, Ri]的大口袋去接糖果， 询问可以接到多少种不同的糖 果。满足 0 ≤ Li ≤ Ri ≤ len。\n删除事件 (天空中一片云朵消 失了)|`3 Ti Ci` |时刻 Ti，颜色为 Ci的云朵从 天空消失中。数据保证当前天空 中一定存在一片颜色为 Ci的云 朵。", "outputFormat": "对于每一个询问事件，输出中应包含相应的一行，为该次询 问的答案，即口袋可以接到多少种不同的糖果。", "hint": "【样例说明】 \n\n共 10 个事件，包括 3 个插入事件，5 个询问事件以及 2 个删除事件。\n\n时刻 0，天空中出现一片颜色为 10 的云朵，初始位置为[1, 3]，方向向左。\n\n时刻 1，范围为[0, 0]的口袋可以接到颜色为 10 的糖果(云朵位置为[0, 2])。\n\n 时刻11，范围为[0,10]的口袋可以接到颜色为10的糖果(云朵位置为[10, 12])。\n 时刻 11，范围为[0, 9]的口袋不能接到颜色为 10 的糖果(云朵位置为[10, 12])。\n 时刻 11, 天空中出现一片颜色为 13 的云朵, 初始位置为[4, 7], 方向向右。\n\n时刻 13，范围为[9, 9]的口袋可以接到颜色为 10(云朵的位置为[8, 10])和颜色 为 13(云朵的位置为[6, 9])两种不同的糖果。\n\n时刻 13，范围为[10, 10]的口袋仅仅可以接到颜色为 10 的一种糖果(云朵的位 置为[8, 10])，而不可以接到颜色为 13 的糖果(云朵的位置为[6, 9]),。\n\n时刻 100, 颜色为 13 的云朵从天空中消失。\n\n时刻 1999999999，颜色为 10 的云朵从天空中消失。\n\n时刻 2000000000，天空中又出现一片颜色为 10 的云朵，初始位置为[0, 1]， 方向向右。\n\n【数据范围】\n\n对于所有的数据，0 ≤ Ti ≤ 2000000000，1 ≤ Ci ≤ 1000000。\n\n数据保证{Ti}为非递减序列即 T1 ≤ T2 ≤ … ≤ Tn-1 ≤ Tn。\n\n对于所有的插入事件，令 Pi = Ri – Li，即 Pi表示每片云朵的长度。\n\n\n数据编号|n|len|Pi|数据编号|n|len|Pi\n-|-|-|-|-|-|-|-\n1|20|10|≤len|6|150000|1000|≤3\n2|200|100|≤len|7|200000|1000|≤3\n3|2000|1000|≤len|8|100000|1000|≤len\n4|100000|10|≤len|9|150000|1000|≤len\n5|100000|100|≤2|10|200000|1000|≤len\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2008] Candy Rain", "background": "", "description": "There is a beautiful fairy tale: at the end of the sky lies a “Candy Kingdom,” where everything from skyscrapers to tiny flowers and grass is made of candy. Even more magical, the sky is filled with colorful candy clouds, and soon a dense candy rain falls from above: red for strawberry candy, yellow for lemon candy, green for mint candy, black for chocolate candy… At these times, the children of the Candy Kingdom take out bags of all sizes to catch the candies falling from the sky and bring them back to share with their friends.\n\nZ, who loves candies, dreams of visiting such a fairy-tale land. As the saying goes, what you think about during the day comes to you in your dreams at night. One night, Z dreamed that he arrived at the “Candy Kingdom.” To his surprise, at any moment, all clouds in the sky have distinct colors, and each cloud keeps dropping candies of its own color. Even more interestingly, all clouds are moving back and forth at a uniform speed. Imagine the sky has boundaries, and all clouds perform back-and-forth motion exactly between the two boundaries. In each unit of time, a cloud moves one unit to the left or right. When the left edge of a cloud touches the left boundary of the sky, it reverses direction and moves right; when the cloud has completely moved out beyond the right boundary of the sky, it reverses direction and moves left.\n\nWe can imagine the sky as a 2D Cartesian plane, and each cloud as a line segment (possibly degenerated to a point):\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hsdveny3.png)\n\nAs shown above, let the left boundary of the sky be 0 and the right boundary be $len$. There are 5 clouds in total. The cloud labeled 1 is just reversing to move right, and the cloud labeled 2 is just reversing to move left.\n\nIgnore the vertical coordinates of clouds; they do not affect each other during motion.\n\nZ notices that clouds may appear in the sky over time (starting at some initial position and moving in some direction), and some clouds may disappear after some time, while candies keep falling during their motion. Z decides to use many bags to catch candies. Each bag has infinite capacity but a finite opening width. For example, at time $T$, if Z uses a bag covering the $x$-coordinate interval $[L, R]$ to catch candies, and if there exists a position $x \\in [L, R]$ where candies of some color are falling at that instant, then the bag is considered to be able to catch candies of that color. In extreme cases, the interval of the bag opening may degenerate to a point, such as $[0, 0]$ or $[1, 1]$, but it can still catch candies at the corresponding position. Since the total number of candies that can be caught is usually very large, Z wants to know, at each moment he takes out a bag (i.e., at the instant of querying), how many distinct colors of candies his bag can catch.\n\nThe falling time of candies is negligible.", "inputFormat": "The first line contains two positive integers $n$, $len$, denoting the total number of events and the sky’s “boundary.”\n\nThen there are $n$ lines, each describing an event. All events occur in the order given. The first number $k$ on each line ($k \\in \\{1, 2, 3\\}$) denotes the event type: insertion, query, or deletion. The formats are as follows:\n\nEvent type|Input format|Explanation\n-|-|-\nInsertion (a cloud appears in the sky)|`1 Ti Ci Li Ri Di`|At time $T_i$, a cloud appears with coordinate range $[L_i, R_i]$, color $C_i$, and initial direction left ($D_i = -1$) or right ($D_i = 1$). It holds that $0 \\le L_i \\le R_i \\le len$, $D_i \\in \\{-1, 1\\}$. It is guaranteed that at any moment, there will not be two clouds with the same color in the sky.\nQuery (ask how many distinct colors a bag can catch)|`2 Ti Li Ri`|At time $T_i$, Z uses a bag covering the interval $[L_i, R_i]$ to catch candies and asks how many distinct colors can be caught. It holds that $0 \\le L_i \\le R_i \\le len$.\nDeletion (a cloud disappears from the sky)|`3 Ti Ci`|At time $T_i$, the cloud of color $C_i$ disappears from the sky. It is guaranteed that there is currently a cloud of color $C_i$ in the sky.\n\n$T_i$ are in non-decreasing order.", "outputFormat": "For each query event, output exactly one line containing the answer to that query, i.e., the number of distinct colors of candies the bag can catch.", "hint": "[Sample Explanation]\n\nThere are 10 events in total: 3 insertions, 5 queries, and 2 deletions.\n\nAt time 0, a cloud of color 10 appears with initial position $[1, 3]$ and direction left.\n\nAt time 1, a bag with range $[0, 0]$ can catch color 10 (the cloud is at $[0, 2]$).\n\nAt time 11, a bag with range $[0, 10]$ can catch color 10 (the cloud is at $[10, 12]$).\nAt time 11, a bag with range $[0, 9]$ cannot catch color 10 (the cloud is at $[10, 12]$).\nAt time 11, a cloud of color 13 appears with initial position $[4, 7]$ and direction right.\n\nAt time 13, a bag with range $[9, 9]$ can catch two different colors: 10 (the cloud is at $[8, 10]$) and 13 (the cloud is at $[6, 9]$).\n\nAt time 13, a bag with range $[10, 10]$ can catch only color 10 (the cloud is at $[8, 10]$), and cannot catch color 13 (the cloud is at $[6, 9]$).\n\nAt time 100, the cloud of color 13 disappears.\n\nAt time 1999999999, the cloud of color 10 disappears.\n\nAt time 2000000000, another cloud of color 10 appears with initial position $[0, 1]$ and direction right.\n\nConstraints\n\nFor all data, $0 \\le T_i \\le 2000000000$, $1 \\le C_i \\le 1000000$. The sequence $\\{T_i\\}$ is non-decreasing, i.e., $T_1 \\le T_2 \\le \\dots \\le T_{n-1} \\le T_n$.\n\nFor all insertion events, let $P_i = R_i - L_i$, i.e., $P_i$ denotes the length of each cloud.\n\nData ID|$n$|$len$|$P_i$\n-|-|-|-\n1|20|10|$\\le len$\n2|200|100|$\\le len$\n3|2000|1000|$\\le len$\n4|100000|10|$\\le len$\n5|100000|100|$\\le 2$\n6|150000|1000|$\\le 3$\n7|200000|1000|$\\le 3$\n8|100000|1000|$\\le len$\n9|150000|1000|$\\le len$\n10|200000|1000|$\\le len$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2008] 糖果雨", "background": "", "description": "有一个美丽的童话：在天空的尽头有一个\"糖果国\"，这里大到摩天大厦，小 到小花小草都是用糖果建造而成的。更加神奇的是，天空中飘满了五颜六色的糖 果云，很快糖果雨密密麻麻从天而落，红色的是草莓糖，黄色的是柠檬糖，绿色 的是薄荷糖，黑色的是巧克力糖……这时糖果国的小朋友们便会拿出大大小小的 口袋来接天空中落下的糖果，拿回去与朋友们一起分享。\n\n对糖果情有独钟的小 Z 憧憬着能够来到这样一个童话的国度。所谓日有所 思，夜有所梦，这天晚上小 Z 梦见自己来到了\"糖果国\"。他惊喜地发现，任何时 候天空中所有的云朵颜色都不相同，不同颜色的云朵在不断地落下相应颜色的糖 果。更加有趣的是所有的云朵都在做着匀速往返运动，不妨想象天空是有边界的， 而所有的云朵恰好在两个边界之间做着往返运动。每一个单位时间云朵向左或向 右运动一个单位，当云朵的左界碰到天空的左界，它会改变方向向右运动；当云 朵完全移出了天空的右界，它会改变方向向左运动。\n\n我们不妨把天空想象为一个平面直角坐标系，而云朵则抽象为线段(线段可 能退化为点)： \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hsdveny3.png)\n\n如上图，不妨设天空的左界为 0，右界为 len。图中共有 5 片云朵，其中标 号为 1 的云朵恰好改变方向向右运动，标号为 2 的云朵恰好改变方向向左运动。\n\n忽略云朵的纵坐标，它们在运动过程中不会相互影响。\n\n小 Z 发现天空中会不断出现一些云朵(某个时刻从某个初始位置开始朝某个 方向运动)，而有的云朵运动到一定时刻就会从天空中消失，而在运动的过程中 糖果在不断地下落。小 Z 决定拿很多口袋来接糖果，口袋容量是无限的，但袋 口大小却是有限的。例如在时刻 T 小 Z 拿一个横坐标范围为[L, R]的口袋来接糖 果，如果[L, R]存在一个位置 x，该位置有某种颜色的糖果落下，则认为该口袋可 接到此种颜色的糖果。极端情况下，袋口区间可能是一个点，譬如[0,0]、[1,1]，但仍然可以接到相应位置的糖果。通常可以接到的糖果总数会很大，因而小 Z 想知道每一次(即拿出口袋的一瞬间)他的口袋可以接到多少种不同颜色的糖果。\n\n糖果下落的时间忽略不计。", "inputFormat": "输入文件第一行有两个正整数 n, len，分别表示事件总数以及天空 的“边界”。\n\n    接下来 n 行每行描述一个事件，所有的事件按照输入顺序依次发生。每行的 第一个数 k（k = 1，2，3）分别表示事件的类型，分别对应三种事件：插入事件， 询问事件以及删除事件。输入格式如下： \n\n事件类型|输入格式|说明 \n-|-|-\n插入事件 (天空中出现了一片 云朵)|`1 Ti Ci Li Ri Di`|时刻 Ti，天空中出现了一片 坐标范围为[Li, Ri]，颜色为 Ci的 云朵，初始的时候云朵运动方向 为向左(Di = -1)或向右(Di = 1)。满足 0 ≤ Li ≤ Ri ≤ len，Di = -1 或 1。数据保证任何时刻空中不 会出现两片颜色相同的云朵。\n询问事件 (询问一个口袋可以 接到多少种不同颜 色的糖果)|`2 Ti Li Ri` |时刻 Ti，小 Z 用一个坐标范 围为[Li, Ri]的大口袋去接糖果， 询问可以接到多少种不同的糖 果。满足 0 ≤ Li ≤ Ri ≤ len。\n删除事件 (天空中一片云朵消 失了)|`3 Ti Ci` |时刻 Ti，颜色为 Ci的云朵从 天空消失中。数据保证当前天空 中一定存在一片颜色为 Ci的云 朵。", "outputFormat": "对于每一个询问事件，输出中应包含相应的一行，为该次询 问的答案，即口袋可以接到多少种不同的糖果。", "hint": "【样例说明】 \n\n共 10 个事件，包括 3 个插入事件，5 个询问事件以及 2 个删除事件。\n\n时刻 0，天空中出现一片颜色为 10 的云朵，初始位置为[1, 3]，方向向左。\n\n时刻 1，范围为[0, 0]的口袋可以接到颜色为 10 的糖果(云朵位置为[0, 2])。\n\n 时刻11，范围为[0,10]的口袋可以接到颜色为10的糖果(云朵位置为[10, 12])。\n 时刻 11，范围为[0, 9]的口袋不能接到颜色为 10 的糖果(云朵位置为[10, 12])。\n 时刻 11, 天空中出现一片颜色为 13 的云朵, 初始位置为[4, 7], 方向向右。\n\n时刻 13，范围为[9, 9]的口袋可以接到颜色为 10(云朵的位置为[8, 10])和颜色 为 13(云朵的位置为[6, 9])两种不同的糖果。\n\n时刻 13，范围为[10, 10]的口袋仅仅可以接到颜色为 10 的一种糖果(云朵的位 置为[8, 10])，而不可以接到颜色为 13 的糖果(云朵的位置为[6, 9]),。\n\n时刻 100, 颜色为 13 的云朵从天空中消失。\n\n时刻 1999999999，颜色为 10 的云朵从天空中消失。\n\n时刻 2000000000，天空中又出现一片颜色为 10 的云朵，初始位置为[0, 1]， 方向向右。\n\n【数据范围】\n\n对于所有的数据，0 ≤ Ti ≤ 2000000000，1 ≤ Ci ≤ 1000000。\n\n数据保证{Ti}为非递减序列即 T1 ≤ T2 ≤ … ≤ Tn-1 ≤ Tn。\n\n对于所有的插入事件，令 Pi = Ri – Li，即 Pi表示每片云朵的长度。\n\n\n数据编号|n|len|Pi|数据编号|n|len|Pi\n-|-|-|-|-|-|-|-\n1|20|10|≤len|6|150000|1000|≤3\n2|200|100|≤len|7|200000|1000|≤3\n3|2000|1000|≤len|8|100000|1000|≤len\n4|100000|10|≤len|9|150000|1000|≤len\n5|100000|100|≤2|10|200000|1000|≤len\n", "locale": "zh-CN"}}}
{"pid": "P4204", "type": "P", "difficulty": 6, "samples": [["2 3 1\n1 1\n1 1\n2 2\n3 1\n", "1/12\n"], ["3 1 2\n1 1 1\n5 1\n", "1/3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["高精度", "2006", "NOI", "排序"], "title": "[NOI2006] 神奇口袋", "background": "", "description": "Pòlya 获得了一个奇妙的口袋，上面写着人类难以理解的符号。Pòlya 看得入了迷，冥思苦想，发现了一个神奇的模型（被后人称为 Pòlya 模型)。为了生动地讲授这个神奇的模型，他带着学生们做了一个虚拟游戏：游戏开始时，袋中装入 $a_1$ 个颜色为 $1$ 的球，$a_2$ 个颜色为 $2$ 的球，……，$a_t$ 个颜色为 $t$ 的球，其中 $a_i \\in \\mathbb Z^+$（$1 \\le i \\le t$）。\n\n游戏开始后，每次严格进行如下的操作：\n\n从袋中随机的抽出一个小球（袋中所有小球被抽中的概率相等），Pòlya 独自观察这个小球的颜色后将其放回，然后再把 $d$ 个与其颜色相同的小球放到口袋中。\n\n设 $c_i$ 表示第 $i$ 次抽出的小球的颜色（$1 \\le C_i \\le t$），一个游戏过程将会产生一个颜色序列（$c_1, c_2, \\ldots, c_n, \\ldots$）。Pòlya 把游戏开始时 $t$ 种颜色的小球每一种的个数 $a_1, a_2, \\ldots, a_t$ 告诉了所有学生。然后他问学生：一次游戏过程产生的颜色序列满足下列条件的概率有多大？ \n\n$$c_{x_1}=y_1, c_{x_2}=y_2, \\ldots, c_{x_n}=y_n$$\n\n其中 $0 < x_1 < x_2 < \\cdots < x_n$，$1 \\le y_i \\le t$。换句话说，已知 $(t, n, d, a_1, a_2, \\ldots, a_t, x_1, y_1, x_2, y_2, \\ldots, x_n, y_n)$，你要回答有多大的可能性会发生下面的事件：“对所有 $k$（$1 \\le k \\le n$），第 $x_k$ 次抽出的球的颜色为 $y_k$”。", "inputFormat": "第一行有三个正整数 $t, n, d$；\n\n第二行有 $t$ 个正整数 $a_1, a_2, \\ldots, a_t$，表示游戏开始时口袋里 $t$ 种颜色的球，每种球的个数。\n\n以下 $n$ 行，每行有两个正整数 $x_i, y_i$，表示第 $x_i$ 次抽出颜色为的 $y_i$ 球。", "outputFormat": "要求用分数形式输出（显然此概率为有理数）。输出文件包含一行，格式为：`分子/分母`。同时要求输出最简形式（分子分母互质）。特别的，概率为 $0$ 应输出 `0/1`，概率为 $1$ 应输出 `1/1`。", "hint": "**【样例解释 #1】**\n\n初始时，两种颜色球数分别为 $(1, 1)$，取出色号为 $1$ 的球的概率为 $1/2$；第二次取球之前，两种颜色球数分别为 $(2, 1)$，取出色号为 $2$ 的球的概率为 $1/3$；第三次取球之前，两种颜色球数分别为 $(2, 2)$，取出色号为 $1$ 的球的概率为 $1/2$，所以三次取球的总概率为 $1/12$。\n\n**【数据规模和约定】**\n\n对于 $100 \\%$ 的数据，$1 \\le t, n \\le 1000$，$1 \\le a_k, d \\le 10$，$1 \\le x_1 < x_2 < \\cdots < x_n \\le 10000$，$1 \\le y_k \\le t$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2006] Magical Pocket", "background": "", "description": "Pòlya obtained a marvelous pocket inscribed with symbols beyond human understanding. Fascinated, he pondered and discovered a magical model (later called the \"Pòlya model\"). To vividly teach this model, he had his students play a virtual game: at the beginning, put $a_1$ balls of color $1$, $a_2$ balls of color $2$, …, and $a_t$ balls of color $t$ into the bag, where $a_i \\in \\mathbb Z^+$ ($1 \\le i \\le t$).\n\nAfter the game starts, repeat the following operation strictly each time:\n\nRandomly draw one ball from the bag (all balls in the bag are equally likely to be drawn), Pòlya observes the color of this ball and puts it back, then adds $d$ more balls of the same color into the pocket.\n\nLet $c_i$ be the color of the ball drawn on the $i$-th draw ($1 \\le c_i \\le t$). A single game run produces a color sequence $(c_1, c_2, \\ldots, c_n, \\ldots)$. Pòlya tells all students the initial counts of balls of the $t$ colors, namely $a_1, a_2, \\ldots, a_t$. Then he asks the students: what is the probability that a single run produces a color sequence satisfying\n\n$$c_{x_1}=y_1, c_{x_2}=y_2, \\ldots, c_{x_n}=y_n \\, ?$$\n\nHere $0 < x_1 < x_2 < \\cdots < x_n$, and $1 \\le y_i \\le t$. In other words, given $(t, n, d, a_1, a_2, \\ldots, a_t, x_1, y_1, x_2, y_2, \\ldots, x_n, y_n)$, you need to answer the probability of the following event: “for all $k$ ($1 \\le k \\le n$), the color of the $x_k$-th draw is $y_k$.”", "inputFormat": "- The first line contains three positive integers $t, n, d$.\n- The second line contains $t$ positive integers $a_1, a_2, \\ldots, a_t$, representing the number of balls of each of the $t$ colors at the beginning of the game.\n- Each of the next $n$ lines contains two positive integers $x_i, y_i$, indicating that on the $x_i$-th draw the color is $y_i$.", "outputFormat": "Output the probability as a fraction (this probability is clearly rational). The output contains one line in the format: numerator/denominator. It must be in lowest terms (the numerator and denominator are coprime). In particular, if the probability is $0$, output 0/1; if the probability is $1$, output 1/1.", "hint": "[Sample Explanation #1]\n\nInitially, the counts of the two colors are $(1, 1)$, so the probability of drawing a ball of color $1$ is $1/2$. Before the second draw, the counts become $(2, 1)$, so the probability of drawing a ball of color $2$ is $1/3$. Before the third draw, the counts become $(2, 2)$, so the probability of drawing a ball of color $1$ is $1/2$. Therefore, the total probability of the three draws is $1/12$.\n\nConstraints\n\nFor $100\\%$ of the testdata, $1 \\le t, n \\le 1000$, $1 \\le a_k, d \\le 10$, $1 \\le x_1 < x_2 < \\cdots < x_n \\le 10000$, $1 \\le y_k \\le t$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2006] 神奇口袋", "background": "", "description": "Pòlya 获得了一个奇妙的口袋，上面写着人类难以理解的符号。Pòlya 看得入了迷，冥思苦想，发现了一个神奇的模型（被后人称为 Pòlya 模型)。为了生动地讲授这个神奇的模型，他带着学生们做了一个虚拟游戏：游戏开始时，袋中装入 $a_1$ 个颜色为 $1$ 的球，$a_2$ 个颜色为 $2$ 的球，……，$a_t$ 个颜色为 $t$ 的球，其中 $a_i \\in \\mathbb Z^+$（$1 \\le i \\le t$）。\n\n游戏开始后，每次严格进行如下的操作：\n\n从袋中随机的抽出一个小球（袋中所有小球被抽中的概率相等），Pòlya 独自观察这个小球的颜色后将其放回，然后再把 $d$ 个与其颜色相同的小球放到口袋中。\n\n设 $c_i$ 表示第 $i$ 次抽出的小球的颜色（$1 \\le C_i \\le t$），一个游戏过程将会产生一个颜色序列（$c_1, c_2, \\ldots, c_n, \\ldots$）。Pòlya 把游戏开始时 $t$ 种颜色的小球每一种的个数 $a_1, a_2, \\ldots, a_t$ 告诉了所有学生。然后他问学生：一次游戏过程产生的颜色序列满足下列条件的概率有多大？ \n\n$$c_{x_1}=y_1, c_{x_2}=y_2, \\ldots, c_{x_n}=y_n$$\n\n其中 $0 < x_1 < x_2 < \\cdots < x_n$，$1 \\le y_i \\le t$。换句话说，已知 $(t, n, d, a_1, a_2, \\ldots, a_t, x_1, y_1, x_2, y_2, \\ldots, x_n, y_n)$，你要回答有多大的可能性会发生下面的事件：“对所有 $k$（$1 \\le k \\le n$），第 $x_k$ 次抽出的球的颜色为 $y_k$”。", "inputFormat": "第一行有三个正整数 $t, n, d$；\n\n第二行有 $t$ 个正整数 $a_1, a_2, \\ldots, a_t$，表示游戏开始时口袋里 $t$ 种颜色的球，每种球的个数。\n\n以下 $n$ 行，每行有两个正整数 $x_i, y_i$，表示第 $x_i$ 次抽出颜色为的 $y_i$ 球。", "outputFormat": "要求用分数形式输出（显然此概率为有理数）。输出文件包含一行，格式为：`分子/分母`。同时要求输出最简形式（分子分母互质）。特别的，概率为 $0$ 应输出 `0/1`，概率为 $1$ 应输出 `1/1`。", "hint": "**【样例解释 #1】**\n\n初始时，两种颜色球数分别为 $(1, 1)$，取出色号为 $1$ 的球的概率为 $1/2$；第二次取球之前，两种颜色球数分别为 $(2, 1)$，取出色号为 $2$ 的球的概率为 $1/3$；第三次取球之前，两种颜色球数分别为 $(2, 2)$，取出色号为 $1$ 的球的概率为 $1/2$，所以三次取球的总概率为 $1/12$。\n\n**【数据规模和约定】**\n\n对于 $100 \\%$ 的数据，$1 \\le t, n \\le 1000$，$1 \\le a_k, d \\le 10$，$1 \\le x_1 < x_2 < \\cdots < x_n \\le 10000$，$1 \\le y_k \\le t$。", "locale": "zh-CN"}}}
{"pid": "P4205", "type": "P", "difficulty": 6, "samples": [[".\n..\n...\n....\n.....\n.....C\n...CCC.\nEEEHH...\nE.HHH....\nE.........", "B\nBK\nBKK\nBJKK\nJJJDD\nGJGDDC\nGGGCCCI\nEEEHHIIA\nELHHHIAAF\nELLLLIFFFF"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2005", "NOI", "枚举", "剪枝", "Dancing Links"], "title": "[NOI2005] 智慧珠游戏", "background": "", "description": "智慧珠游戏拼盘由一个三角形盘件和 12 个形态各异的零件组成。拼盘的盘 件如图 1 所示\n![](https://cdn.luogu.com.cn/upload/pic/13767.png)\n![](https://cdn.luogu.com.cn/upload/pic/13768.png)\n![](https://cdn.luogu.com.cn/upload/pic/13769.png)\n对 于 由珠子构成的零件，可以放到盘件的任一位置，条件是能有地方放，且 尺寸合适，所有的零件都允许旋转(0º、90º、180º、270º)和翻转(水平、竖直)。\n \n \n现给出一个盘件的初始布局，求一种可行的智慧珠摆放方案，使所有的零件 都能放进盘件中。 ", "inputFormat": "文件中包含初始的盘件描述，一共有 10 行，第 i 行有 i 个字符。如果第 i 行 的第 j 个字符是字母”A”至”L”中的一个，则表示第 i 行第 j 列的格子上已经放了 零件，零件的编号为对应的字母。如果第 i 行的第 j 个字符是”.”，则表示第 i 行 第 j 列的格子上没有放零件。\n输入保证预放的零件已摆放在盘件中。", "outputFormat": "如果能找到解，向输出文件打印 10 行，为放完全部 12 个零件后的布局。其 中，第 i 行应包含 i 个字符，第 i 行的第 j 个字符表示第 i 行第 j 列的格子上放的 是哪个零件。 如果无解，输出单独的一个字符串‘No solution’(不要引号，请注意大小写)。\n 所有的数据保证最多只有一组解", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2005] Smart Beads Game", "background": "", "description": "The Smart Beads puzzle consists of a triangular board and 12 distinct pieces. The board is shown in Figure 1.\n![](https://cdn.luogu.com.cn/upload/pic/13767.png)\n![](https://cdn.luogu.com.cn/upload/pic/13768.png)\n![](https://cdn.luogu.com.cn/upload/pic/13769.png)\nEach piece, made of beads, can be placed at any position on the board as long as it fits and there is space for it. All pieces may be rotated by 0°, 90°, 180°, or 270°, and may be flipped horizontally or vertically.\nGiven an initial layout of the board, find a valid arrangement that places all 12 pieces on the board.", "inputFormat": "The file contains the initial board description in 10 lines. The i-th line has i characters.\nIf the j-th character of the i-th line is a letter 'A' to 'L', then the cell at row i and column j is already occupied by a piece whose ID is that letter. If the j-th character is '.', then the cell at row i and column j is empty.\nThe input guarantees that all pre-placed pieces are legally placed on the board.", "outputFormat": "If a solution exists, print 10 lines describing the layout after placing all 12 pieces. The i-th line should contain i characters, and the j-th character of the i-th line indicates which piece occupies that cell.\nIf there is no solution, print the single string No solution (without quotes, case-sensitive).\nAll testdata guarantee that there is at most one solution.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2005] 智慧珠游戏", "background": "", "description": "智慧珠游戏拼盘由一个三角形盘件和 12 个形态各异的零件组成。拼盘的盘 件如图 1 所示\n![](https://cdn.luogu.com.cn/upload/pic/13767.png)\n![](https://cdn.luogu.com.cn/upload/pic/13768.png)\n![](https://cdn.luogu.com.cn/upload/pic/13769.png)\n对 于 由珠子构成的零件，可以放到盘件的任一位置，条件是能有地方放，且 尺寸合适，所有的零件都允许旋转(0º、90º、180º、270º)和翻转(水平、竖直)。\n \n \n现给出一个盘件的初始布局，求一种可行的智慧珠摆放方案，使所有的零件 都能放进盘件中。 ", "inputFormat": "文件中包含初始的盘件描述，一共有 10 行，第 i 行有 i 个字符。如果第 i 行 的第 j 个字符是字母”A”至”L”中的一个，则表示第 i 行第 j 列的格子上已经放了 零件，零件的编号为对应的字母。如果第 i 行的第 j 个字符是”.”，则表示第 i 行 第 j 列的格子上没有放零件。\n输入保证预放的零件已摆放在盘件中。", "outputFormat": "如果能找到解，向输出文件打印 10 行，为放完全部 12 个零件后的布局。其 中，第 i 行应包含 i 个字符，第 i 行的第 j 个字符表示第 i 行第 j 列的格子上放的 是哪个零件。 如果无解，输出单独的一个字符串‘No solution’(不要引号，请注意大小写)。\n 所有的数据保证最多只有一组解", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4206", "type": "P", "difficulty": 5, "samples": [["4 3 \n1 4 \n1 2 \n2 3 \n3 4", "1.500 \n"], ["9 9 \n9 3 \n1 2 \n2 3 \n3 4 \n4 5 \n3 6 \n4 6 \n4 7 \n7 8 \n8 9", "2.167"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2005", "NOI", "广度优先搜索 BFS", "深度优先搜索 DFS", "记忆化搜索", "期望"], "title": "[NOI2005] 聪聪与可可", "background": "", "description": "在一个魔法森林里，住着一只聪明的小猫聪聪和一只可爱的小老鼠可可。虽然灰姑娘非常喜欢她们俩，但是，聪聪终究是一只猫，而可可终究是一只老鼠，同样不变的是，聪聪成天想着要吃掉可可。\n\n一天，聪聪意外得到了一台非常有用的机器，据说是叫 GPS，对可可能准确的定位。有了这台机器，聪聪要吃可可就易如反掌了。于是，聪聪准备马上出发，去找可可。而可怜的可可还不知道大难即将临头，仍在森林里无忧无虑的玩耍。小兔子乖乖听到这件事，马上向灰姑娘报告。灰姑娘决定尽快阻止聪聪，拯救可可，可她不知道还有没有足够的时间。\n\n整个森林可以认为是一个无向图，图中有 $N$ 个美丽的景点，景点从 $1$ 至 $N$ 编号。小动物们都只在景点休息、玩耍。在景点之间有一些路连接。\n\n当聪聪得到 GPS 时，可可正在景点 $M$（$M \\le N$）处。以后的每个时间单位，可可都会选择去相邻的景点（可能有多个）中的一个或停留在原景点不动。而去这些地方所发生的概率是相等的。假设有 $P$ 个景点与景点 $M$ 相邻，它们分别是景点 $R$、景点 $S$、……、景点 $Q$，在时刻 $T$ 可可处在景点 $M$，则在 $(T+1)$ 时刻，可可有 $1/(1 +P)$ 的可能在景点 $R$，有 $1/(1 +P)$ 的可能在景点 $S$，……，有 $1/(1 +P)$ 的可能在景点 $Q$，还有$1/(1 +P)$的可能停在景点 $M$。\n\n我们知道，聪聪是很聪明的，所以，当她在景点 $C$ 时，她会选一个更靠近可可的景点，如果这样的景点有多个，她会选一个标号最小的景点。由于聪聪太想吃掉可可了，如果走完第一步以后仍然没吃到可可，她还可以在本段时间内再向可可走近一步。\n\n在每个时间单位，假设聪聪先走，可可后走。在某一时刻，若聪聪和可可位于同一个景点，则可怜的可可就被吃掉了。\n\n灰姑娘想知道，平均情况下，聪聪几步就可能吃到可可。而你需要帮助灰姑娘尽快的找到答案。", "inputFormat": "数据的第 1 行为两个整数 $N$ 和 $E$，以空格分隔，分别表示森林中的景点数和连接相邻景点的路的条数。\n\n第 2 行包含两个整数 $C$ 和 $M$，以空格分隔，分别表示初始时聪聪和可可所在的景点的编号。\n\n接下来 E 行，每行两个整数，第 $i+2$ 行的两个整数 $A_i$ 和 $B_i$ 表示景点 $A_i$ 和景点 $B_i$ 之间有一条路。所有的路都是无向的，即：如果能从 A 走到 B，就可以从 B 走到 A。\n\n输入保证任何两个景点之间不会有多于一条路直接相连，且聪聪和可可之间必有路直接或间接的相连。", "outputFormat": "输出 1 个实数，四舍五入保留三位小数，表示平均多少个时间单位后聪聪会把可可吃掉。", "hint": "【样例说明 1】 \n\n开始时，聪聪和可可分别在景点 1 和景点 4。 \n\n第一个时刻，聪聪先走，她向更靠近可可(景点 4)的景点走动，走到景点 2， 然后走到景点 3；假定忽略走路所花时间。 \n\n可可后走，有两种可能： 第一种是走到景点 3，这样聪聪和可可到达同一个景点，可可被吃掉，步数为 $1$，概率为$0.5$。\n \n第二种是停在景点 4，不被吃掉。概率为 $0.5$。\n\n到第二个时刻，聪聪向更靠近可可(景点 4)的景点走动，只需要走一步即和 可可在同一景点。因此这种情况下聪聪会在两步吃掉可可。 所以平均的步数是 $1\\times 1/2 + 2\\times 1/2 =1.5$ 步。\n\n【样例说明 2】\n\n森林如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8uiq0ltc.png)\n\n对于 50%的数据，$1≤N≤50$。  \n对于所有的数据，$1≤N,E≤1000$。 ", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2005] Congcong and Keke", "background": "", "description": "In a magical forest, there live a clever kitten Congcong and a cute little mouse Keke. Although Cinderella likes both of them very much, Congcong is still a cat and Keke is still a mouse, and one thing never changes: Congcong is always thinking about eating Keke.\n\nOne day, Congcong accidentally obtained a very useful device called a GPS, which can accurately locate Keke. With this device, it becomes easy for Congcong to catch Keke. So Congcong plans to set off immediately to find Keke. Poor Keke, unaware of the looming danger, is still playing in the forest without a care. Little Bunny \"Guai Guai\" hears about this and reports to Cinderella at once. Cinderella decides to stop Congcong as soon as possible to save Keke, but she does not know whether there is still enough time.\n\nThe entire forest can be regarded as an undirected graph with $N$ beautiful spots, numbered from $1$ to $N$. The little animals only rest and play at the spots. There are some roads connecting pairs of spots.\n\nWhen Congcong gets the GPS, Keke is at spot $M$ ($M \\le N$). In each subsequent time unit, Keke will choose one of the adjacent spots (possibly multiple) or stay at the current spot. The probabilities of these choices are equal. Suppose there are $P$ spots adjacent to spot $M$, namely spots $R$, $S$, …, $Q$. If at time $T$ Keke is at spot $M$, then at time $(T+1)$ Keke has a $1/(1 +P)$ chance to be at spot $R$, a $1/(1 +P)$ chance to be at spot $S$, …, a $1/(1 +P)$ chance to be at spot $Q$, and a $1/(1 +P)$ chance to remain at spot $M$.\n\nWe know Congcong is very smart, so when she is at spot $C$, she will choose an adjacent spot that is closer to Keke. If there are multiple such spots, she chooses the one with the smallest index. Because Congcong is eager to eat Keke, if she still has not caught Keke after taking the first step, she can take one more step toward Keke within the same time unit. Assume the time spent walking is ignored.\n\nIn each time unit, Congcong moves first and Keke moves afterward. At any time, if Congcong and Keke are at the same spot, then poor Keke is eaten.\n\nCinderella wants to know, on average, how many time units it will take for Congcong to eat Keke. You need to help Cinderella find the answer as quickly as possible.", "inputFormat": "The first line contains two integers $N$ and $E$, separated by a space, representing the number of spots in the forest and the number of roads connecting adjacent spots.\n\nThe second line contains two integers $C$ and $M$, separated by a space, representing the initial spots of Congcong and Keke, respectively.\n\nThe next $E$ lines each contain two integers. On line $i+2$, the two integers $A_i$ and $B_i$ indicate that there is a road between spots $A_i$ and $B_i$. All roads are undirected, i.e., if one can go from $A$ to $B$, then one can also go from $B$ to $A$.\n\nThe input guarantees that there is no more than one direct road between any pair of spots, and that there is a path (direct or indirect) between Congcong and Keke.", "outputFormat": "Output one real number, rounded to three decimal places, representing the expected number of time units after which Congcong will eat Keke.", "hint": "Sample Explanation 1:\n\nInitially, Congcong and Keke are at spots 1 and 4, respectively.\n\nAt the first time unit, Congcong moves first. She moves toward Keke (spot 4), going to spot 2, then to spot 3; assume the time spent walking is ignored.\n\nKeke then moves, with two possibilities: The first is moving to spot 3, in which case Congcong and Keke are at the same spot, Keke is eaten, the number of time units is $1$, and the probability is $0.5$. The second is staying at spot 4, not being eaten, with probability $0.5$.\n\nAt the second time unit, Congcong moves toward Keke (spot 4) and needs only one step to reach the same spot as Keke. Therefore, in this case, Congcong will eat Keke in two time units. Hence the expected number of time units is $1\\times 1/2 + 2\\times 1/2 =1.5$.\n\nSample Explanation 2:\n\nThe forest is shown below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8uiq0ltc.png)\n\nFor 50% of the testdata, $1≤N≤50$.\nFor all testdata, $1≤N,E≤1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2005] 聪聪与可可", "background": "", "description": "在一个魔法森林里，住着一只聪明的小猫聪聪和一只可爱的小老鼠可可。虽然灰姑娘非常喜欢她们俩，但是，聪聪终究是一只猫，而可可终究是一只老鼠，同样不变的是，聪聪成天想着要吃掉可可。\n\n一天，聪聪意外得到了一台非常有用的机器，据说是叫 GPS，对可可能准确的定位。有了这台机器，聪聪要吃可可就易如反掌了。于是，聪聪准备马上出发，去找可可。而可怜的可可还不知道大难即将临头，仍在森林里无忧无虑的玩耍。小兔子乖乖听到这件事，马上向灰姑娘报告。灰姑娘决定尽快阻止聪聪，拯救可可，可她不知道还有没有足够的时间。\n\n整个森林可以认为是一个无向图，图中有 $N$ 个美丽的景点，景点从 $1$ 至 $N$ 编号。小动物们都只在景点休息、玩耍。在景点之间有一些路连接。\n\n当聪聪得到 GPS 时，可可正在景点 $M$（$M \\le N$）处。以后的每个时间单位，可可都会选择去相邻的景点（可能有多个）中的一个或停留在原景点不动。而去这些地方所发生的概率是相等的。假设有 $P$ 个景点与景点 $M$ 相邻，它们分别是景点 $R$、景点 $S$、……、景点 $Q$，在时刻 $T$ 可可处在景点 $M$，则在 $(T+1)$ 时刻，可可有 $1/(1 +P)$ 的可能在景点 $R$，有 $1/(1 +P)$ 的可能在景点 $S$，……，有 $1/(1 +P)$ 的可能在景点 $Q$，还有$1/(1 +P)$的可能停在景点 $M$。\n\n我们知道，聪聪是很聪明的，所以，当她在景点 $C$ 时，她会选一个更靠近可可的景点，如果这样的景点有多个，她会选一个标号最小的景点。由于聪聪太想吃掉可可了，如果走完第一步以后仍然没吃到可可，她还可以在本段时间内再向可可走近一步。\n\n在每个时间单位，假设聪聪先走，可可后走。在某一时刻，若聪聪和可可位于同一个景点，则可怜的可可就被吃掉了。\n\n灰姑娘想知道，平均情况下，聪聪几步就可能吃到可可。而你需要帮助灰姑娘尽快的找到答案。", "inputFormat": "数据的第 1 行为两个整数 $N$ 和 $E$，以空格分隔，分别表示森林中的景点数和连接相邻景点的路的条数。\n\n第 2 行包含两个整数 $C$ 和 $M$，以空格分隔，分别表示初始时聪聪和可可所在的景点的编号。\n\n接下来 E 行，每行两个整数，第 $i+2$ 行的两个整数 $A_i$ 和 $B_i$ 表示景点 $A_i$ 和景点 $B_i$ 之间有一条路。所有的路都是无向的，即：如果能从 A 走到 B，就可以从 B 走到 A。\n\n输入保证任何两个景点之间不会有多于一条路直接相连，且聪聪和可可之间必有路直接或间接的相连。", "outputFormat": "输出 1 个实数，四舍五入保留三位小数，表示平均多少个时间单位后聪聪会把可可吃掉。", "hint": "【样例说明 1】 \n\n开始时，聪聪和可可分别在景点 1 和景点 4。 \n\n第一个时刻，聪聪先走，她向更靠近可可(景点 4)的景点走动，走到景点 2， 然后走到景点 3；假定忽略走路所花时间。 \n\n可可后走，有两种可能： 第一种是走到景点 3，这样聪聪和可可到达同一个景点，可可被吃掉，步数为 $1$，概率为$0.5$。\n \n第二种是停在景点 4，不被吃掉。概率为 $0.5$。\n\n到第二个时刻，聪聪向更靠近可可(景点 4)的景点走动，只需要走一步即和 可可在同一景点。因此这种情况下聪聪会在两步吃掉可可。 所以平均的步数是 $1\\times 1/2 + 2\\times 1/2 =1.5$ 步。\n\n【样例说明 2】\n\n森林如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8uiq0ltc.png)\n\n对于 50%的数据，$1≤N≤50$。  \n对于所有的数据，$1≤N,E≤1000$。 ", "locale": "zh-CN"}}}
{"pid": "P4207", "type": "P", "difficulty": 7, "samples": [["2  0.7853981633 \n10.0  10.00  10.00 \n4.00  5.00", "171.97"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2005", "递归", "NOI", "积分"], "title": "[NOI2005] 月下柠檬树", "background": "", "description": "李哲非常非常喜欢柠檬树，特别是在静静的夜晚，当天空中有一弯明月温柔地照亮地面上的景物时，他必会悠闲地坐在他亲手植下的那棵柠檬树旁，独自思索着人生的哲理。\n\n李哲是一个喜爱思考的孩子，当他看到在月光的照射下柠檬树投在地面上的影子是如此的清晰，马上想到了一个问题：树影的面积是多大呢？\n\n李哲知道，直接测量面积是很难的，他想用几何的方法算，因为他对这棵柠檬树的形状了解得非常清楚，而且想好了简化的方法。\n\n李哲将整棵柠檬树分成了 $n$ 层，由下向上依次将层编号为 $1,2,...,n$。从第 $1$ 到 $n-1$ 层，每层都是一个圆台型，第 $n$ 层(最上面一层)是圆锥型。对于圆台型， 其上下底面都是水平的圆。对于相邻的两个圆台，上层的下底面和下层的上底面重合。第 $n$ 层(最上面一层)圆锥的底面就是第 $n-1$ 层圆台的上底面。所有的底面 的圆心(包括树顶)处在同一条与地面垂直的直线上。李哲知道每一层的高度为 $h_1,h_2,...,h_n$，第 $1$ 层圆台的下底面距地面的高度为 $h_0$，以及每层的下底面的圆的半径 $r_1,r_2,...,r_n$。李哲用熟知的方法测出了月亮的光线与地面的夹角为 $\\mathrm{alpha}$。\n\n![](https://cdn.luogu.com.cn/upload/pic/13770.png)\n\n为了便于计算，假设月亮的光线是平行光，且地面是水平的，在计算时忽略树干所产生的影子。李哲当然会算了，但是他希望你也来练练手。", "inputFormat": "第一行包含一个整数 $n$ 和一个实数 $\\mathrm{alpha}$，表示柠檬树的层数和月亮 的光线与地面夹角（单位为弧度）。\n\n第二行包含 $n+1$ 个实数 $h_0,h_1,h_2,...,h_n$ 表示树离地的高度和每层的高度。\n\n第三行包含 $n$ 个实数 $r_1,r_2,...,r_n$ 表示柠檬树每层下底面的圆的半径。\n\n同一行相邻的两个数之间用一个空格分隔。\n\n输入的所有实数的小数点后可能包含一至十位有效数字。", "outputFormat": "输出一个实数，表示树影的面积，四舍五入保留两位小数。", "hint": "对于 $10 \\%$ 的数据，$n \\leq 1$；\n\n对于 $30 \\%$ 的数据，$n \\leq 2$；\n\n对于 $60 \\%$ 的数据，$n \\leq 20$；\n\n对于 $100 \\%$ 的数据，$1 \\leq n \\leq 500$，$0.3 < \\mathrm{alpha} < \\frac{\\pi}{2}$，$0 < h_i \\leq 100$，$0 < r_i \\leq 100$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2005] Lemon Tree Under the Moonlight", "background": "", "description": "Li Zhe really loves lemon trees, especially on quiet nights when a crescent moon gently illuminates the ground. He always sits leisurely by the lemon tree he planted himself, pondering the philosophy of life.\n\nLi Zhe likes thinking. When he sees the lemon tree casting a sharp shadow on the ground under the moonlight, he immediately comes up with a question: what is the area of the tree’s shadow?\n\nHe knows that directly measuring the area is hard. He wants to compute it geometrically, because he understands the shape of this lemon tree very well and has a plan to simplify it.\n\nLi Zhe divides the whole lemon tree into $n$ layers, numbered from bottom to top as $1, 2, \\ldots, n$. From layer $1$ to layer $n-1$, each layer is a conical frustum, and layer $n$ (the topmost layer) is a cone. For a conical frustum, its top and bottom faces are horizontal circles. For two adjacent frustums, the lower base of the upper layer coincides with the upper base of the lower layer. The base of the cone in layer $n$ (the topmost layer) is exactly the upper base of the frustum in layer $n-1$. The centers of all circular bases (including the tree top) lie on a straight line perpendicular to the ground. Li Zhe knows the height of each layer $h_1, h_2, \\ldots, h_n$, the height of the lower base of the first frustum above the ground $h_0$, and the radius of the lower circular base of each layer $r_1, r_2, \\ldots, r_n$. Using a familiar method, he measured the angle between the moonlight rays and the ground to be $\\mathrm{alpha}$.\n\n![](https://cdn.luogu.com.cn/upload/pic/13770.png)\n\nFor convenience, assume the moonlight rays are parallel, the ground is horizontal, and ignore the shadow cast by the trunk. Of course Li Zhe can compute it, but he hopes you will give it a try too.", "inputFormat": "The first line contains an integer $n$ and a real number $\\mathrm{alpha}$, representing the number of layers of the lemon tree and the angle between the moonlight rays and the ground (in radians).\n\nThe second line contains $n+1$ real numbers $h_0, h_1, h_2, \\ldots, h_n$ representing the tree’s height above the ground and the height of each layer.\n\nThe third line contains $n$ real numbers $r_1, r_2, \\ldots, r_n$ representing the radius of the lower circular base of each layer of the lemon tree.\n\nAdjacent numbers on the same line are separated by a single space.\n\nAll real numbers in the input may have between 1 and 10 digits after the decimal point.", "outputFormat": "Output a single real number: the area of the tree’s shadow, rounded to two decimal places.", "hint": "For $10\\%$ of the testdata, $n \\leq 1$.\n\nFor $30\\%$ of the testdata, $n \\leq 2$.\n\nFor $60\\%$ of the testdata, $n \\leq 20$.\n\nFor $100\\%$ of the testdata, $1 \\leq n \\leq 500$, $0.3 < \\mathrm{alpha} < \\frac{\\pi}{2}$, $0 < h_i \\leq 100$, $0 < r_i \\leq 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2005] 月下柠檬树", "background": "", "description": "李哲非常非常喜欢柠檬树，特别是在静静的夜晚，当天空中有一弯明月温柔地照亮地面上的景物时，他必会悠闲地坐在他亲手植下的那棵柠檬树旁，独自思索着人生的哲理。\n\n李哲是一个喜爱思考的孩子，当他看到在月光的照射下柠檬树投在地面上的影子是如此的清晰，马上想到了一个问题：树影的面积是多大呢？\n\n李哲知道，直接测量面积是很难的，他想用几何的方法算，因为他对这棵柠檬树的形状了解得非常清楚，而且想好了简化的方法。\n\n李哲将整棵柠檬树分成了 $n$ 层，由下向上依次将层编号为 $1,2,...,n$。从第 $1$ 到 $n-1$ 层，每层都是一个圆台型，第 $n$ 层(最上面一层)是圆锥型。对于圆台型， 其上下底面都是水平的圆。对于相邻的两个圆台，上层的下底面和下层的上底面重合。第 $n$ 层(最上面一层)圆锥的底面就是第 $n-1$ 层圆台的上底面。所有的底面 的圆心(包括树顶)处在同一条与地面垂直的直线上。李哲知道每一层的高度为 $h_1,h_2,...,h_n$，第 $1$ 层圆台的下底面距地面的高度为 $h_0$，以及每层的下底面的圆的半径 $r_1,r_2,...,r_n$。李哲用熟知的方法测出了月亮的光线与地面的夹角为 $\\mathrm{alpha}$。\n\n![](https://cdn.luogu.com.cn/upload/pic/13770.png)\n\n为了便于计算，假设月亮的光线是平行光，且地面是水平的，在计算时忽略树干所产生的影子。李哲当然会算了，但是他希望你也来练练手。", "inputFormat": "第一行包含一个整数 $n$ 和一个实数 $\\mathrm{alpha}$，表示柠檬树的层数和月亮 的光线与地面夹角（单位为弧度）。\n\n第二行包含 $n+1$ 个实数 $h_0,h_1,h_2,...,h_n$ 表示树离地的高度和每层的高度。\n\n第三行包含 $n$ 个实数 $r_1,r_2,...,r_n$ 表示柠檬树每层下底面的圆的半径。\n\n同一行相邻的两个数之间用一个空格分隔。\n\n输入的所有实数的小数点后可能包含一至十位有效数字。", "outputFormat": "输出一个实数，表示树影的面积，四舍五入保留两位小数。", "hint": "对于 $10 \\%$ 的数据，$n \\leq 1$；\n\n对于 $30 \\%$ 的数据，$n \\leq 2$；\n\n对于 $60 \\%$ 的数据，$n \\leq 20$；\n\n对于 $100 \\%$ 的数据，$1 \\leq n \\leq 500$，$0.3 < \\mathrm{alpha} < \\frac{\\pi}{2}$，$0 < h_i \\leq 100$，$0 < r_i \\leq 100$。", "locale": "zh-CN"}}}
{"pid": "P4208", "type": "P", "difficulty": 6, "samples": [["4 6\n1 2 1\n1 3 1\n1 4 1\n2 3 2\n2 4 1\n3 4 1", "8\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "各省省选", "矩阵树定理", "江苏"], "title": "[JSOI2008] 最小生成树计数", "background": "", "description": "现在给出了一个简单无向加权图。你不满足于求出这个图的最小生成树，而希望知道这个图中有多少个不同的最小生成树。（如果两棵最小生成树中至少有一条边不同，则这两个最小生成树就是不同的）。由于不同的最小生成树可能很多，所以你只需要输出方案数对 $31011$ 的模就可以了。", "inputFormat": "第一行包含两个数，$n$ 和 $m$，其中 $1 \\le n \\le 100$，$1 \\le m \\le 1000$，表示该无向图的节点数和边数。每个节点用 $1 \\sim n$ 的整数编号。\n\n接下来的 $m$ 行，每行包含两个整数：$a,b,c$，表示节点 $a,b$ 之间的边的权值为 $c$，其中 $1 \\le c \\le 10^9$。\n\n数据保证不会出现自回边和重边。注意：具有相同权值的边不会超过 $10$ 条。", "outputFormat": "输出不同的最小生成树有多少个。你只需要输出数量对 $31011$ 的模就可以了。", "hint": "### 数据范围及约定\n\n对于全部数据，$1 \\le n \\le 100$，$1 \\le m \\le 1000$，$1\\leq c_i\\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2008] Counting Minimum Spanning Trees", "background": "", "description": "You are given a simple undirected weighted graph. You are not satisfied with finding just one minimum spanning tree (MST); instead, you want to know how many different MSTs the graph has. Two MSTs are considered different if they differ by at least one edge. Since the number of different MSTs can be large, you only need to output the count modulo $31011$.", "inputFormat": "The first line contains two integers $n$ and $m$, where $1 \\le n \\le 100$, $1 \\le m \\le 1000$, representing the number of nodes and edges of the undirected graph. Nodes are numbered from $1$ to $n$.\n\nThe next $m$ lines each contain three integers $a, b, c$, indicating that there is an edge between nodes $a$ and $b$ with weight $c$, where $1 \\le c \\le 10^9$.\n\nIt is guaranteed that there are no self-loops or multiple edges. Note: For any fixed weight, there are at most $10$ edges with that weight.", "outputFormat": "Output the number of different minimum spanning trees. You only need to output the count modulo $31011$.", "hint": "### Constraints and Conventions\n\nFor all testdata, $1 \\le n \\le 100$, $1 \\le m \\le 1000$, $1 \\le c_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2008] 最小生成树计数", "background": "", "description": "现在给出了一个简单无向加权图。你不满足于求出这个图的最小生成树，而希望知道这个图中有多少个不同的最小生成树。（如果两棵最小生成树中至少有一条边不同，则这两个最小生成树就是不同的）。由于不同的最小生成树可能很多，所以你只需要输出方案数对 $31011$ 的模就可以了。", "inputFormat": "第一行包含两个数，$n$ 和 $m$，其中 $1 \\le n \\le 100$，$1 \\le m \\le 1000$，表示该无向图的节点数和边数。每个节点用 $1 \\sim n$ 的整数编号。\n\n接下来的 $m$ 行，每行包含两个整数：$a,b,c$，表示节点 $a,b$ 之间的边的权值为 $c$，其中 $1 \\le c \\le 10^9$。\n\n数据保证不会出现自回边和重边。注意：具有相同权值的边不会超过 $10$ 条。", "outputFormat": "输出不同的最小生成树有多少个。你只需要输出数量对 $31011$ 的模就可以了。", "hint": "### 数据范围及约定\n\n对于全部数据，$1 \\le n \\le 100$，$1 \\le m \\le 1000$，$1\\leq c_i\\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4209", "type": "P", "difficulty": 6, "samples": [["3 3 1\n1 2 3\n3 2 1\n111\n111\n111", "-2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["网络流", "费用流"], "title": "学习小组", "background": "", "description": "共有 $n$ 个学生，$m$ 个学习小组，每个学生只愿意参加其中的一些学习小组，且一个学生最多参加 $k$ 个学习小组。每个学生参加学习小组财务处都收一定的手续费，不同的学习小组有不同的手续费。若有 $a$ 个学生参加第 $i$ 个学习小组，财务处支付奖励 $C_i \\times a^2$ 元。在参与学生（而不是每个学习小组的人数总和）尽量多的情况下，求财务处最少要支出多少钱。", "inputFormat": "\n输入有若干行，第一行有三个用空格隔开的正整数 $n,m,k$。\n\n接下来的一行有 $m$ 个正整数，表示每个 $C_i$。\n\n第三行有 $m$ 个正整数，表示参加每个学习小组需要交的手续费 $F_i$。\n\n再接下来有一个 $n$ 行 $m$ 列的矩阵，表若第 $i$ 行 $j$ 列的数字是 $1$，则表示第 $i$ 个学生愿意参加第 $j$ 个学习小组，若为 $0$，则为不愿意。", "outputFormat": "输出只有一个整数，为最小的支出。", "hint": "对于 $100\\%$ 的数据，$0＜n\\le 100，0＜m≤90，0＜k\\le m，0＜C_i\\le 10，0＜F_i\\le 100。$", "locale": "zh-CN", "translations": {"en": {"title": "Study Groups", "background": "", "description": "There are $n$ students and $m$ study groups. Each student is willing to join only some of the study groups, and any student can join at most $k$ study groups. For each student participating in a study group, the finance office charges a handling fee; different study groups have different fees. If $a$ students join the $i$-th study group, the finance office pays a reward of $C_i \\times a^2$ yuan. Subject to making the number of participating students (i.e., the number of distinct students, not the sum over all groups) as large as possible, find the minimum amount of money the finance office must spend.", "inputFormat": "The input consists of multiple lines. The first line contains three positive integers $n, m, k$ separated by spaces.\n\nThe next line contains $m$ positive integers, the values of $C_i$.\n\nThe third line contains $m$ positive integers, the handling fees $F_i$ required to join each study group.\n\nThen follows an $n$-by-$m$ matrix. If the number at row $i$, column $j$ is 1, then the $i$-th student is willing to join the $j$-th study group; if it is 0, then the student is unwilling.", "outputFormat": "Output a single integer: the minimum expenditure.", "hint": "For $100\\%$ of the testdata, $0 < n \\le 100$, $0 < m \\le 90$, $0 < k \\le m$, $0 < C_i \\le 10$, $0 < F_i \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "学习小组", "background": "", "description": "共有 $n$ 个学生，$m$ 个学习小组，每个学生只愿意参加其中的一些学习小组，且一个学生最多参加 $k$ 个学习小组。每个学生参加学习小组财务处都收一定的手续费，不同的学习小组有不同的手续费。若有 $a$ 个学生参加第 $i$ 个学习小组，财务处支付奖励 $C_i \\times a^2$ 元。在参与学生（而不是每个学习小组的人数总和）尽量多的情况下，求财务处最少要支出多少钱。", "inputFormat": "\n输入有若干行，第一行有三个用空格隔开的正整数 $n,m,k$。\n\n接下来的一行有 $m$ 个正整数，表示每个 $C_i$。\n\n第三行有 $m$ 个正整数，表示参加每个学习小组需要交的手续费 $F_i$。\n\n再接下来有一个 $n$ 行 $m$ 列的矩阵，表若第 $i$ 行 $j$ 列的数字是 $1$，则表示第 $i$ 个学生愿意参加第 $j$ 个学习小组，若为 $0$，则为不愿意。", "outputFormat": "输出只有一个整数，为最小的支出。", "hint": "对于 $100\\%$ 的数据，$0＜n\\le 100，0＜m≤90，0＜k\\le m，0＜C_i\\le 10，0＜F_i\\le 100。$", "locale": "zh-CN"}}}
{"pid": "P4210", "type": "P", "difficulty": 6, "samples": [["3 3 \n8 \n9 \n1 2 2 6 2 \n2 3 8 5 7 \n1 3 9 4 1", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["网络流"], "title": "土地划分", "background": "", "description": "$Y$ 国有 $N$ 座城市，并且有 $M$ 条双向公路将这些城市连接起来，并且任意两个城市至少有一条路径可以互达。$Y$ 国的国王去世之后，他的两个儿子 A 和 B 都想成为新的国王，但他们都想让这个国家更加安定，不会用武力解决问题。于是他们想将这个国家分成两个小国家 A 国和 B 国。现在，A 拥有 $1$ 号城市，B 拥有 $N$ 号城市，其他的城市还尚未确定归属哪边（划分之后的国家内部城市可以不连通）。由于大家都想让国家变得更好，而某些城市的人民愿意国王的 A 儿子作为他们的领袖，而某些城市更看好 B，而为了交通的便捷，如果划分后的公路连接两个同一个国家的城市，那么更利于城市之间的交流。于是大臣们设计了一种对土地划分的评分机制，具体如下：对于城市 $i$，如果它划分给 A 国，将得到 $\\mathit{VA}_i$ 的得分；划分给 B 国，将得到 $\\mathit{VB}_i$ 的得分。对于一条公路 $i$，如果它连接两个 A 国的城市，将得到 $\\mathit{EA}_i$ 的得分；连接两个 B 国的城市，将得到 $\\mathit{EB}_i$ 的得分；否则，这条公路将失去意义，将扣除 $\\mathit{EC}_i$ 的得分。现请你找到最优的土地划分，使得这种它的评分最高。", "inputFormat": "第一行包含两个整数 $N$，$M$，含义如问题描述所示。接下来一行 $N-2$ 个非负整数，表示 $\\mathit{VA}_2,\\mathit{VA}_3,\\cdots,\\mathit{VA}_{N-1}$。接下来一行 $N-2$ 个非负整数，表示 $\\mathit{VB}_2,\\mathit{VB}_3,\\cdots,\\mathit{VB}_{N-1}$。接下来 $M$ 行，每行五个非负整数描述一条公路：$X,Y,\\mathit{EA}_i,\\mathit{EB}_i,\\mathit{EC}_i$，含义如问题描述所示。", "outputFormat": "输出有且仅有一个整数，表示最高评分。", "hint": "对于全部数据，$n \\le 10^4$，$m \\le 4\\times 10^4$。\n\n保证运算过程中及最终结果不超过 $32$ 位带符号整数类型的表示范围。\n", "locale": "zh-CN", "translations": {"en": {"title": "Land Division", "background": "", "description": "Country Y has $N$ cities and $M$ bidirectional roads connecting them, and any two cities are connected by at least one path. After the death of the king of Country Y, his two sons A and B both wish to become the new king, but they both want greater stability and will not use force. They decide to divide the country into two smaller countries: Country A and Country B. Currently, A owns city $1$, and B owns city $N$. The ownership of the other cities has not yet been determined (after the division, the cities within the same country do not need to be connected).\n\nSince everyone wants the country to prosper, some cities prefer the king’s son A as their leader, while others favor B. For transportation convenience, if a road connects two cities within the same country after the division, it is more beneficial for intercity communication. Therefore, the ministers designed a scoring mechanism for the land division, as follows:\n\nFor city $i$, if it is assigned to Country A, it yields a score of $\\mathit{VA}_i$; if it is assigned to Country B, it yields a score of $\\mathit{VB}_i$. For a road $i$, if it connects two cities in Country A, it yields a score of $\\mathit{EA}_i$; if it connects two cities in Country B, it yields a score of $\\mathit{EB}_i$; otherwise, the road becomes useless and incurs a penalty of $\\mathit{EC}_i$.\n\nPlease find the optimal land division that maximizes the total score.", "inputFormat": "The first line contains two integers $N$, $M$, as described above.  \nThe next line contains $N - 2$ non-negative integers, representing $\\mathit{VA}_2,\\mathit{VA}_3,\\cdots,\\mathit{VA}_{N-1}$.  \nThe next line contains $N - 2$ non-negative integers, representing $\\mathit{VB}_2,\\mathit{VB}_3,\\cdots,\\mathit{VB}_{N-1}$.  \nThe next $M$ lines each contain five non-negative integers describing a road: $X, Y, \\mathit{EA}_i, \\mathit{EB}_i, \\mathit{EC}_i$, with meanings as described above.", "outputFormat": "Output exactly one integer, the maximum score.", "hint": "Constraints: $N \\le 10^4$, $M \\le 4 \\times 10^4$.\n\nIt is guaranteed that all intermediate values and the final result fit within the range of a 32-bit signed integer.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "土地划分", "background": "", "description": "$Y$ 国有 $N$ 座城市，并且有 $M$ 条双向公路将这些城市连接起来，并且任意两个城市至少有一条路径可以互达。$Y$ 国的国王去世之后，他的两个儿子 A 和 B 都想成为新的国王，但他们都想让这个国家更加安定，不会用武力解决问题。于是他们想将这个国家分成两个小国家 A 国和 B 国。现在，A 拥有 $1$ 号城市，B 拥有 $N$ 号城市，其他的城市还尚未确定归属哪边（划分之后的国家内部城市可以不连通）。由于大家都想让国家变得更好，而某些城市的人民愿意国王的 A 儿子作为他们的领袖，而某些城市更看好 B，而为了交通的便捷，如果划分后的公路连接两个同一个国家的城市，那么更利于城市之间的交流。于是大臣们设计了一种对土地划分的评分机制，具体如下：对于城市 $i$，如果它划分给 A 国，将得到 $\\mathit{VA}_i$ 的得分；划分给 B 国，将得到 $\\mathit{VB}_i$ 的得分。对于一条公路 $i$，如果它连接两个 A 国的城市，将得到 $\\mathit{EA}_i$ 的得分；连接两个 B 国的城市，将得到 $\\mathit{EB}_i$ 的得分；否则，这条公路将失去意义，将扣除 $\\mathit{EC}_i$ 的得分。现请你找到最优的土地划分，使得这种它的评分最高。", "inputFormat": "第一行包含两个整数 $N$，$M$，含义如问题描述所示。接下来一行 $N-2$ 个非负整数，表示 $\\mathit{VA}_2,\\mathit{VA}_3,\\cdots,\\mathit{VA}_{N-1}$。接下来一行 $N-2$ 个非负整数，表示 $\\mathit{VB}_2,\\mathit{VB}_3,\\cdots,\\mathit{VB}_{N-1}$。接下来 $M$ 行，每行五个非负整数描述一条公路：$X,Y,\\mathit{EA}_i,\\mathit{EB}_i,\\mathit{EC}_i$，含义如问题描述所示。", "outputFormat": "输出有且仅有一个整数，表示最高评分。", "hint": "对于全部数据，$n \\le 10^4$，$m \\le 4\\times 10^4$。\n\n保证运算过程中及最终结果不超过 $32$ 位带符号整数类型的表示范围。\n", "locale": "zh-CN"}}}
{"pid": "P4211", "type": "P", "difficulty": 6, "samples": [["5 2\n0\n0\n1\n1\n1 4 3\n1 4 2", "8\n5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "线段树", "各省省选", "辽宁", "最近公共祖先 LCA", "树链剖分", "差分", "离线处理"], "title": "[LNOI2014] LCA", "background": "", "description": "给出一个 $n$ 个节点的有根树（编号为 $0$ 到 $n-1$，根节点为 $0$）。\n\n一个点的深度定义为这个节点到根的距离 $+1$。 \n\n设 $dep[i]$ 表示点 $i$ 的深度，$\\operatorname{LCA}(i, j)$ 表示 $i$ 与 $j$ 的最近公共祖先。 \n\n有 $m$ 次询问，每次询问给出 $l, r, z$，求 $\\sum_{i=l}^r dep[\\operatorname{LCA}(i,z)]$ 。", "inputFormat": "第一行 $2$ 个整数，$n, m$。\n\n接下来 $n-1$ 行，分别表示点 $1$ 到点 $n-1$ 的父节点编号。\n\n接下来 $m$ 行，每行 $3$ 个整数，$l, r, z$。", "outputFormat": "输出 $m$ 行，每行表示一个询问的答案。每个答案对 $201314$ 取模输出。", "hint": "### 数据范围及约定\n\n- 对于 $20\\%$ 的数据，$n\\le 10000,m\\le 10000$；\n- 对于 $40\\%$ 的数据，$n\\le 20000,m\\le 20000$；\n- 对于 $60\\%$ 的数据，$n\\le 30000,m\\le 30000$；\n- 对于 $80\\%$ 的数据，$n\\le 40000,m\\le 40000$；\n- 对于 $100\\%$ 的数据，$1\\le n\\le 50000,1\\le m\\le 50000$。", "locale": "zh-CN", "translations": {"en": {"title": "[LNOI2014] LCA", "background": "", "description": "You are given a rooted tree with $n$ nodes (numbered from $0$ to $n - 1$), with root $0$.\n\nThe depth of a node is defined as its distance to the root $+1$.\n\nLet $dep[i]$ denote the depth of node $i$, and let $\\operatorname{LCA}(i, j)$ denote the lowest common ancestor of $i$ and $j$.\n\nThere are $m$ queries. For each query with given $l, r, z$, compute $\\sum_{i=l}^{r} dep[\\operatorname{LCA}(i, z)]$.", "inputFormat": "- The first line contains $2$ integers $n, m$.\n- The next $n - 1$ lines give parent indices: for each $i$ from $1$ to $n - 1$, the $i$-th of these lines contains the parent of node $i$.\n- The next $m$ lines each contain $3$ integers $l, r, z$.", "outputFormat": "Output $m$ lines. Each line contains the answer for one query, taken modulo $201314$.", "hint": "Constraints\n\n- For $20\\%$ of the testdata, $n \\le 10000$, $m \\le 10000$.\n- For $40\\%$ of the testdata, $n \\le 20000$, $m \\le 20000$.\n- For $60\\%$ of the testdata, $n \\le 30000$, $m \\le 30000$.\n- For $80\\%$ of the testdata, $n \\le 40000$, $m \\le 40000$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 50000$, $1 \\le m \\le 50000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[LNOI2014] LCA", "background": "", "description": "给出一个 $n$ 个节点的有根树（编号为 $0$ 到 $n-1$，根节点为 $0$）。\n\n一个点的深度定义为这个节点到根的距离 $+1$。 \n\n设 $dep[i]$ 表示点 $i$ 的深度，$\\operatorname{LCA}(i, j)$ 表示 $i$ 与 $j$ 的最近公共祖先。 \n\n有 $m$ 次询问，每次询问给出 $l, r, z$，求 $\\sum_{i=l}^r dep[\\operatorname{LCA}(i,z)]$ 。", "inputFormat": "第一行 $2$ 个整数，$n, m$。\n\n接下来 $n-1$ 行，分别表示点 $1$ 到点 $n-1$ 的父节点编号。\n\n接下来 $m$ 行，每行 $3$ 个整数，$l, r, z$。", "outputFormat": "输出 $m$ 行，每行表示一个询问的答案。每个答案对 $201314$ 取模输出。", "hint": "### 数据范围及约定\n\n- 对于 $20\\%$ 的数据，$n\\le 10000,m\\le 10000$；\n- 对于 $40\\%$ 的数据，$n\\le 20000,m\\le 20000$；\n- 对于 $60\\%$ 的数据，$n\\le 30000,m\\le 30000$；\n- 对于 $80\\%$ 的数据，$n\\le 40000,m\\le 40000$；\n- 对于 $100\\%$ 的数据，$1\\le n\\le 50000,1\\le m\\le 50000$。", "locale": "zh-CN"}}}
{"pid": "P4212", "type": "P", "difficulty": 5, "samples": [["4\n1 2\n2 3\n3 1\n1 4", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "枚举", "随机化", "状压 DP"], "title": "外太空旅行", "background": "", "description": "在人类的触角伸向银河系的边缘之际，普通人上太空旅行已经变得稀松平常了。某理科试验班有 $n$ 个人，现在班主任要从中选出尽量多的人去参加一次太空旅行活动。\n可是 $n$ 名同学并不是和平相处的。有的人，比如小 A 和小 B 整天狼狈为奸，是好朋友；但还有的人，比如（政治敏感）和（政治敏感）就水火不相容。这 $n$ 名同学，由于是理科生，都非常的理性，所以“朋友的朋友就是朋友”和“敌人的朋友就是敌人”这两句话对这些同学无效。换句话说，有可能小 A 和小 B 是朋友，小 B 和小 C 是朋友，但是小 A 和小 C 两人势如水火。  \n任意两个人之间要不就是敌人，要不就是朋友。  \n因为在太空船上发生人员斗殴事件是很恶劣也很危险的，因此选出来参加旅行活动的同学必须互相之间都是朋友。你的任务就是确定最多可以选多少人参加旅行。", "inputFormat": "第一行一个整数 $n(1 \\le n \\le 50)$。所有的同学按照 $1 \\sim n$ 编号。  \n接下来若干行，每行两个用空格隔开的整数 $a, b(1 \\le a,b \\le n)$，表示 $a$ 和 $b$ 是朋友。\n注意：如果一个数对 $(x,y)$（或者 $(y,x)$）没有在文件中出现，那么编号为 $x$ 和 $y$ 的两个同学就是敌人。", "outputFormat": "一个数，即最多可以选多少人参加活动。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Outer Space Travel", "background": "", "description": "As humanity reaches the edge of the Milky Way, it has become commonplace for ordinary people to travel to space. In a science experimental class, there are $n$ people, and the homeroom teacher wants to select as many of them as possible to go on a space trip.\n\nHowever, the $n$ students do not all get along. Some people, such as Xiao A and Xiao B, are always together and are good friends; but others, such as (politically sensitive) and (politically sensitive), are incompatible. These $n$ students, being science students, are very rational, so the two statements “a friend of a friend is a friend” and “an enemy’s friend is an enemy” do not hold for them. In other words, it is possible that Xiao A and Xiao B are friends, Xiao B and Xiao C are friends, but Xiao A and Xiao C are sworn enemies.\n\nFor any two people, they are either enemies or friends. Because fights on a spaceship are very bad and dangerous, the selected students must be pairwise friends. Your task is to determine the maximum number of people who can be selected to participate.", "inputFormat": "The first line contains an integer $n$ ($1 \\le n \\le 50$). All students are numbered 1 to $n$.  \nThen follow several lines, each containing two space-separated integers $a$, $b$ ($1 \\le a, b \\le n$), indicating that $a$ and $b$ are friends.  \nNote: If a pair $(x, y)$ (or $(y, x)$) does not appear in the file, then students $x$ and $y$ are enemies.", "outputFormat": "A single integer, the maximum number of students that can be selected.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "外太空旅行", "background": "", "description": "在人类的触角伸向银河系的边缘之际，普通人上太空旅行已经变得稀松平常了。某理科试验班有 $n$ 个人，现在班主任要从中选出尽量多的人去参加一次太空旅行活动。\n可是 $n$ 名同学并不是和平相处的。有的人，比如小 A 和小 B 整天狼狈为奸，是好朋友；但还有的人，比如（政治敏感）和（政治敏感）就水火不相容。这 $n$ 名同学，由于是理科生，都非常的理性，所以“朋友的朋友就是朋友”和“敌人的朋友就是敌人”这两句话对这些同学无效。换句话说，有可能小 A 和小 B 是朋友，小 B 和小 C 是朋友，但是小 A 和小 C 两人势如水火。  \n任意两个人之间要不就是敌人，要不就是朋友。  \n因为在太空船上发生人员斗殴事件是很恶劣也很危险的，因此选出来参加旅行活动的同学必须互相之间都是朋友。你的任务就是确定最多可以选多少人参加旅行。", "inputFormat": "第一行一个整数 $n(1 \\le n \\le 50)$。所有的同学按照 $1 \\sim n$ 编号。  \n接下来若干行，每行两个用空格隔开的整数 $a, b(1 \\le a,b \\le n)$，表示 $a$ 和 $b$ 是朋友。\n注意：如果一个数对 $(x,y)$（或者 $(y,x)$）没有在文件中出现，那么编号为 $x$ 和 $y$ 的两个同学就是敌人。", "outputFormat": "一个数，即最多可以选多少人参加活动。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4213", "type": "P", "difficulty": 6, "samples": [["6\n1\n2\n8\n13\n30\n2333", "1 1\n2 0\n22 -2\n58 -3\n278 -3\n1655470 2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "杜教筛", "模板题"], "title": "【模板】杜教筛", "background": "", "description": "给定一个正整数 $n$，求\n\n$$ans_1=\\sum_{i=1}^n\\varphi(i)$$\n\n$$ans_2=\\sum_{i=1}^n \\mu(i)$$", "inputFormat": "**本题单测试点内有多组数据**。\n\n输入的第一行为一个整数，表示数据组数 $T$。\n\n接下来 $T$ 行，每行一个整数 $n$，表示一组询问。", "outputFormat": "对于每组询问，输出一行两个整数，分别代表 $ans_1$ 和 $ans_2$。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq T \\leq 10$，$1 \\leq n \\lt 2^{31}$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Du Jiao Sieve", "background": "", "description": "Given a positive integer $n$, compute\n\n$$ans_1=\\sum_{i=1}^n\\varphi(i)$$\n\n$$ans_2=\\sum_{i=1}^n \\mu(i)$$", "inputFormat": "**This problem contains multiple test cases within a single test file.**\n\nThe first line contains an integer, denoting the number of test cases $T$.\n\nThen $T$ lines follow, each containing an integer $n$, representing one query.", "outputFormat": "For each query, output two integers in one line, representing $ans_1$ and $ans_2$.", "hint": "#### Constraints\n\nFor all test cases, it is guaranteed that $1 \\leq T \\leq 10$, $1 \\leq n \\lt 2^{31}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】杜教筛", "background": "", "description": "给定一个正整数 $n$，求\n\n$$ans_1=\\sum_{i=1}^n\\varphi(i)$$\n\n$$ans_2=\\sum_{i=1}^n \\mu(i)$$", "inputFormat": "**本题单测试点内有多组数据**。\n\n输入的第一行为一个整数，表示数据组数 $T$。\n\n接下来 $T$ 行，每行一个整数 $n$，表示一组询问。", "outputFormat": "对于每组询问，输出一行两个整数，分别代表 $ans_1$ 和 $ans_2$。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq T \\leq 10$，$1 \\leq n \\lt 2^{31}$。", "locale": "zh-CN"}}}
{"pid": "P4214", "type": "P", "difficulty": 6, "samples": [["6 8\n1 3\n2 3\n4 1\n5 6\n2 6\n5 1\n6 4\n5 3", "36"]], "limits": {"time": [7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "Tarjan", "双连通分量", "最小割", "ICPC", "CERC"], "title": "[CERC2015] Juice Junctions", "background": "", "description": "你被雇佣升级一个旧果汁加工厂的橙汁运输系统。系统有管道和节点构成。每条管道都是双向的，且每条管道的流量都是 $1$ 升每秒。管道可能连接节点，每个节点最多可以连接 $3$ 条管道。节点的流量是无限的。节点用整数 $1$ 到 $n$ 来表示。在升级系统之前，你需要对现有系统进行分析。对于两个不同节点 $s$ 和 $t$，$s-t$ 的流量被定义为：当 $s$ 为源点，$t$ 为汇点，从 $s$ 能流向 $t$ 的最大流量。\n\n以下面的第一组样例数据为例，$1-6$ 的流量为 $3$，$1-2$ 的流量为 $2$。\n\n计算每一对满足 $a<b$ 的节点 $a-b$ 的流量的和。", "inputFormat": "第一行包括 $2$ 个整数 $n$ 和 $m$（$2\\leq n\\leq 3\\times 10^3$，$0\\leq m\\leq 4500$），表示节点数和管道数。\n\n接下来 $m$ 行，每行包括两个相异整数 $a,b$（$1\\leq a,b\\leq n$），表示一条管道连接节点 $a,b$。\n\n每个节点最多连接 $3$ 条管道，每对节点最多被一条管道连接。", "outputFormat": "输出一个整数——每对满足 $a<b$ 的节点 $a-b$ 的流量之和。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[CERC2015] Juice Junctions", "background": "", "description": "You are hired to upgrade an old juice factory’s orange juice transport system. The system consists of pipes and nodes. Each pipe is bidirectional, and each pipe has a flow rate of $1$ liter per second. Pipes connect nodes, and each node can be connected to at most $3$ pipes. Nodes have infinite capacity. Nodes are labeled by integers $1$ through $n$. Before the upgrade, you need to analyze the existing system. For two distinct nodes $s$ and $t$, the $s$–$t$ flow is defined as the maximum flow from $s$ to $t$ when $s$ is the source and $t$ is the sink.\n\nIn the first sample below, the flow from $1$ to $6$ is $3$, and the flow from $1$ to $2$ is $2$.\n\nCompute the sum of $a$–$b$ flows over all pairs of nodes with $a < b$.", "inputFormat": "The first line contains $2$ integers $n$ and $m$ ($2\\leq n\\leq 3\\times 10^3$, $0\\leq m\\leq 4500$), denoting the number of nodes and the number of pipes.\n\nEach of the next $m$ lines contains two distinct integers $a,b$ ($1\\leq a,b\\leq n$), indicating that there is a pipe connecting nodes $a$ and $b$.\n\nEach node is incident to at most $3$ pipes, and there is at most one pipe between any pair of nodes.", "outputFormat": "Output a single integer: the sum of $a$–$b$ flows over all pairs with $a<b$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC2015] Juice Junctions", "background": "", "description": "你被雇佣升级一个旧果汁加工厂的橙汁运输系统。系统有管道和节点构成。每条管道都是双向的，且每条管道的流量都是 $1$ 升每秒。管道可能连接节点，每个节点最多可以连接 $3$ 条管道。节点的流量是无限的。节点用整数 $1$ 到 $n$ 来表示。在升级系统之前，你需要对现有系统进行分析。对于两个不同节点 $s$ 和 $t$，$s-t$ 的流量被定义为：当 $s$ 为源点，$t$ 为汇点，从 $s$ 能流向 $t$ 的最大流量。\n\n以下面的第一组样例数据为例，$1-6$ 的流量为 $3$，$1-2$ 的流量为 $2$。\n\n计算每一对满足 $a<b$ 的节点 $a-b$ 的流量的和。", "inputFormat": "第一行包括 $2$ 个整数 $n$ 和 $m$（$2\\leq n\\leq 3\\times 10^3$，$0\\leq m\\leq 4500$），表示节点数和管道数。\n\n接下来 $m$ 行，每行包括两个相异整数 $a,b$（$1\\leq a,b\\leq n$），表示一条管道连接节点 $a,b$。\n\n每个节点最多连接 $3$ 条管道，每对节点最多被一条管道连接。", "outputFormat": "输出一个整数——每对满足 $a<b$ 的节点 $a-b$ 的流量之和。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4215", "type": "P", "difficulty": 6, "samples": [["5 3\n1 1 1 1 1\n5 5\n2 2\n1 3\n5 \n4 \n2 \n5 \n2 \n3", "0 \n1 \n1 \n2 \n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["线段树"], "title": "踩气球", "background": null, "description": "六一儿童节到了，SHUXK 被迫陪着 $m$ 个熊孩子玩一个无聊的游戏：有 $n$ 个盒子从左到右排成一排，第 $i$ 个盒子里装着 $a_i$ 个气球。\n\nSHUXK 要进行 $Q$ 次操作，每次从某一个盒子里拿出一个没被踩爆的气球，然后熊孩子们就会立刻把它踩爆。\n\n这 $m$ 个熊孩子每个人都指定了一个盒子区间 $[l_i,r_i]$。如果某一个时刻，一个熊孩子发现自己选定的盒子区间 $[l_i,r_i]$ 中的所有气球都已经被踩爆了，他就会非常高兴（显然之后他一直会很高兴）。\n\n为了不辜负将自己的任务强行塞给 SHUXK 的那个人的期望，SHUXK 想向你询问：\n\n- 他每次操作过后会有多少个熊孩子很高兴。", "inputFormat": "第一行包含两个正整数 $n$ 和 $m$，分别表示盒子和熊孩子的个数。\n\n第二行包含 $n$ 个正整数 $a_i$（$1 \\le a_i \\le 10^5$），表示每个盒子里气球的数量。\n\n以下 $m$ 行每行包含两个正整数 $l_i,r_i$（$1 \\le l_i \\le r_i \\le n$），分别表示每一个熊孩子指定的区间。\n\n以下一行包含一个正整数 $Q$，表示 SHUXK 操作的次数。\n\n以下 $Q$ 行每行包含一个正整数 $x$，表示这次操作是从第 $x$ 个盒子里拿气球。为了体现在线，我们对输入的 $x$ 进行了加密。\n\n假设输入的正整数是 $\\hat{x}$，那么真正的 $x=(\\hat{x}+\\mathit{lastans}-1)\\bmod n+1$。其中 $\\mathit{lastans}$ 为上一次询问的答案。对于第一个询问，$\\mathit{lastans}=0$。", "outputFormat": "包含 $Q$ 行，每行输出一个整数，表示 SHUXK 一次操作后询问的答案。答案的顺序应与输入数据的顺序保持一致。", "hint": "### 数据范围及约定\n\n对于全部数据，$1\\le n \\le 10^5$，$1\\le m \\le 10^5$，$1\\le Q \\le 10^5$。\n\n输入数据保证 $1 \\le \\hat{x} \\le 10^9$，且第 $x$ 个盒子中有尚未被踩爆的气球。", "locale": "zh-CN", "translations": {"en": {"title": "Popping Balloons", "background": "", "description": "Children’s Day has arrived, and SHUXK is forced to play a boring game with $m$ kids: there are $n$ boxes lined up from left to right, and the $i$-th box contains $a_i$ balloons.\n\nSHUXK will perform $Q$ operations. In each operation, he takes one unpopped balloon from some box, and the kids immediately pop it.\n\nEach of the $m$ kids has specified an interval of boxes $[l_i, r_i]$. If at any moment a kid finds that all balloons in their chosen interval $[l_i, r_i]$ have been popped, they become very happy (and will remain happy thereafter).\n\nTo live up to the expectations of the person who dumped this task on SHUXK, he asks you:\n\n- After each operation, how many kids are happy?", "inputFormat": "The first line contains two positive integers $n$ and $m$, the numbers of boxes and kids, respectively.\n\nThe second line contains $n$ positive integers $a_i$ ($1 \\le a_i \\le 10^5$), the number of balloons in each box.\n\nEach of the following $m$ lines contains two positive integers $l_i, r_i$ ($1 \\le l_i \\le r_i \\le n$), the interval specified by each kid.\n\nThe next line contains a positive integer $Q$, the number of operations SHUXK performs.\n\nEach of the following $Q$ lines contains a positive integer $x$, indicating that this operation takes a balloon from the $x$-th box. To enforce online queries, the input $x$ is encrypted.\n\nLet the given positive integer be $\\hat{x}$; then the real $x=(\\hat{x}+\\mathit{lastans}-1)\\bmod n+1$, where $\\mathit{lastans}$ is the answer to the previous query. For the first query, $\\mathit{lastans}=0$.", "outputFormat": "Output $Q$ lines. Each line should contain one integer, the answer to SHUXK’s question after a single operation. The answers must be in the same order as the input queries.", "hint": "Constraints and Conventions\n\nFor all data, $1 \\le n \\le 10^5$, $1 \\le m \\le 10^5$, $1 \\le Q \\le 10^5$.\n\nThe testdata guarantees $1 \\le \\hat{x} \\le 10^9$, and that the $x$-th box always has at least one unpopped balloon.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "踩气球", "background": null, "description": "六一儿童节到了，SHUXK 被迫陪着 $m$ 个熊孩子玩一个无聊的游戏：有 $n$ 个盒子从左到右排成一排，第 $i$ 个盒子里装着 $a_i$ 个气球。\n\nSHUXK 要进行 $Q$ 次操作，每次从某一个盒子里拿出一个没被踩爆的气球，然后熊孩子们就会立刻把它踩爆。\n\n这 $m$ 个熊孩子每个人都指定了一个盒子区间 $[l_i,r_i]$。如果某一个时刻，一个熊孩子发现自己选定的盒子区间 $[l_i,r_i]$ 中的所有气球都已经被踩爆了，他就会非常高兴（显然之后他一直会很高兴）。\n\n为了不辜负将自己的任务强行塞给 SHUXK 的那个人的期望，SHUXK 想向你询问：\n\n- 他每次操作过后会有多少个熊孩子很高兴。", "inputFormat": "第一行包含两个正整数 $n$ 和 $m$，分别表示盒子和熊孩子的个数。\n\n第二行包含 $n$ 个正整数 $a_i$（$1 \\le a_i \\le 10^5$），表示每个盒子里气球的数量。\n\n以下 $m$ 行每行包含两个正整数 $l_i,r_i$（$1 \\le l_i \\le r_i \\le n$），分别表示每一个熊孩子指定的区间。\n\n以下一行包含一个正整数 $Q$，表示 SHUXK 操作的次数。\n\n以下 $Q$ 行每行包含一个正整数 $x$，表示这次操作是从第 $x$ 个盒子里拿气球。为了体现在线，我们对输入的 $x$ 进行了加密。\n\n假设输入的正整数是 $\\hat{x}$，那么真正的 $x=(\\hat{x}+\\mathit{lastans}-1)\\bmod n+1$。其中 $\\mathit{lastans}$ 为上一次询问的答案。对于第一个询问，$\\mathit{lastans}=0$。", "outputFormat": "包含 $Q$ 行，每行输出一个整数，表示 SHUXK 一次操作后询问的答案。答案的顺序应与输入数据的顺序保持一致。", "hint": "### 数据范围及约定\n\n对于全部数据，$1\\le n \\le 10^5$，$1\\le m \\le 10^5$，$1\\le Q \\le 10^5$。\n\n输入数据保证 $1 \\le \\hat{x} \\le 10^9$，且第 $x$ 个盒子中有尚未被踩爆的气球。", "locale": "zh-CN"}}}
{"pid": "P4216", "type": "P", "difficulty": 6, "samples": [["7\n0 1 1 2 2 3 3 \n6\n1 4 7 0\n2 1\n2 4\n2 7\n1 4 7 1\n1 4 7 3", "5 0\n5 2\n5 1"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2015", "四川", "线段树", "各省省选", "平衡树", "树链剖分", "可持久化线段树"], "title": "[SCOI2015] 情报传递", "background": null, "description": "奈特公司是一个巨大的情报公司，它有着庞大的情报网络。情报网络中共有 $n$ 名情报员。每名情报员可能有若干名 (可能没有) 下线，除 $1$ 名大头目外其余 $n-1$ 名情报员有且仅有 $1$ 名上线。奈特公司纪律森严，每名情报员只能与自己的上、下线联系，同时，情报网络中任意两名情报员一定能够通过情报网络传递情报。\n\n奈特公司每天会派发以下两种任务中的一个任务：\n\n1. 搜集情报：指派 $T$ 号情报员搜集情报；\n2. 传递情报：将一条情报从 $X$ 号情报员传递给 $Y$ 号情报员。\n\n情报员最初处于潜伏阶段，他们是相对安全的，我们认为此时所有情报员的危险值为 $0$；一旦某个情报员开始搜集情报，他的危险值就会持续增加，每天增加 $1$ 点危险值 (开始搜集情报的当天危险值仍为 $0$，第 $2$ 天危险值为 $1$，第 $3$ 天危险值为 $2$，以此类推)。传递情报并不会使情报员的危险值增加。\n\n为了保证传递情报的过程相对安全，每条情报都有一个风险控制值 $C$。奈特公司认为，参与传递这条情报的所有情报员中，危险值大于 $C$ 的情报员将对该条情报构成威胁。现在，奈特公司希望知道，对于每个传递情报任务，参与传递的情报员有多少个，其中对该条情报构成威胁的情报员有多少个。", "inputFormat": "第一行包含一个正整数 $n$，表示情报员个数。\n笫二行包含 $n$ 个非负整数，其中第 $i$ 个整数 $P_i$ 表示 $i$ 号情报员上线的编号。特别地，若 $P_i=0$，表示 $i$ 号情报员是大头目。\n第三行包含一个正整数 $q$，表示奈特公司将派发 $q$ 个任务 (每天一个)。\n\n随后 $q$ 行，依次描述 $q$ 个任务。每行首先有一个正整数 $k$。\n\n- 若 $k=1$，表示任务是传递情报，随后有三个正整数 $X_i$、$Y_i$、$C_i$，依次表示传递情报的起点、终点和风险控制值。\n- 若 $k=2$，表示任务是搜集情报，随后有 $1$ 个正整数 $T_i$，表示搜集情报的情报员编号。", "outputFormat": "对于每个传递情报任务输出一行，包含两个整数，分别是参与传递情报的情报员个数和对该条情报构成威胁的情报员个数。", "hint": "样例解释：\n\n对于 $3$ 个传递情报任务，都是经过 $5$ 名情报员，分别是 $4$ 号、$2$ 号、$1$ 号、$3$ 号和 $7$ 号。\n\n- 第 $1$ 个任务，所有情报员 (危险值为 $0$) 都不对情报构成威胁；\n- 第 $2$ 个任务，有 $2$ 名情报员对情报构成威胁，分别是 $1$ 号情报员 (危险值为 $3$) 和 $4$ 号情报员 (危险值为 $2$)，$7$ 号情报员 (危险值为 $1$) 并不构成威胁；\n- 第 $3$ 个任务，只有 $1$ 名情报员对情报构成威胁。\n\n数据范围：\n\n$n\\leqslant 2\\times 10^5,Q\\leqslant 2\\times 10^5,0\\le P_i,C_i\\leqslant N,1\\leqslant T_i,X_i,Y_i\\leqslant n$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2015] Intelligence Transmission", "background": "", "description": "Knight Company is a huge intelligence organization with a vast intelligence network. There are $n$ agents in the network. Each agent may have several (possibly none) subordinates. Except for one boss, each of the remaining $n-1$ agents has exactly one supervisor. The company has strict discipline: each agent may contact only their own supervisor and subordinates. Meanwhile, any two agents can pass intelligence through the network.\n\nEach day, the company assigns exactly one of the following two tasks:\n\n1. Collect intelligence: designate agent $T$ to start collecting intelligence.\n2. Transmit intelligence: transmit a piece of intelligence from agent $X$ to agent $Y$.\n\nInitially, all agents are in a dormant stage and are relatively safe; we consider their danger values to be $0$. Once an agent starts collecting intelligence, their danger value keeps increasing by $1$ per day (on the starting day, the danger value is still $0$; on the 2nd day it is $1$; on the 3rd day it is $2$; and so on). Transmission tasks do not increase any agent’s danger value.\n\nTo ensure safety during transmission, each piece of intelligence has a risk control value $C$. Among all agents who participate in transmitting this piece (i.e., those on the unique path between $X$ and $Y$, inclusive), any agent whose danger value is greater than $C$ is considered a threat to this piece.\n\nFor every transmission task, determine how many agents participate in the transmission and how many of them constitute a threat to this piece.", "inputFormat": "- The first line contains a positive integer $n$, the number of agents.\n- The second line contains $n$ non-negative integers. The $i$-th integer $P_i$ denotes the supervisor of agent $i$. In particular, if $P_i = 0$, agent $i$ is the boss.\n- The third line contains a positive integer $q$, the number of tasks (one per day).\n- The next $q$ lines each describe a task. Each line starts with a positive integer $k$:\n  - If $k = 1$, it is a transmission task, followed by three positive integers $X_i$, $Y_i$, $C_i$, denoting the start, the end, and the risk control value, respectively.\n  - If $k = 2$, it is a collection task, followed by one positive integer $T_i$, the agent who starts collecting intelligence.", "outputFormat": "For each transmission task, output one line containing two integers: the number of participating agents and the number of agents who constitute a threat to this piece of intelligence.", "hint": "Sample explanation:\n\nFor the $3$ transmission tasks, each passes through $5$ agents, namely $4$, $2$, $1$, $3$, and $7$.\n\n- In the 1st task, all agents (danger value $0$) do not constitute a threat.\n- In the 2nd task, there are $2$ threatening agents: agent $1$ (danger value $3$) and agent $4$ (danger value $2$). Agent $7$ (danger value $1$) is not a threat.\n- In the 3rd task, only $1$ agent is a threat.\n\nConstraints:\n\n$n \\le 2 \\times 10^5$, $q \\le 2 \\times 10^5$, $0 \\le P_i, C_i \\le n$, $1 \\le T_i, X_i, Y_i \\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2015] 情报传递", "background": null, "description": "奈特公司是一个巨大的情报公司，它有着庞大的情报网络。情报网络中共有 $n$ 名情报员。每名情报员可能有若干名 (可能没有) 下线，除 $1$ 名大头目外其余 $n-1$ 名情报员有且仅有 $1$ 名上线。奈特公司纪律森严，每名情报员只能与自己的上、下线联系，同时，情报网络中任意两名情报员一定能够通过情报网络传递情报。\n\n奈特公司每天会派发以下两种任务中的一个任务：\n\n1. 搜集情报：指派 $T$ 号情报员搜集情报；\n2. 传递情报：将一条情报从 $X$ 号情报员传递给 $Y$ 号情报员。\n\n情报员最初处于潜伏阶段，他们是相对安全的，我们认为此时所有情报员的危险值为 $0$；一旦某个情报员开始搜集情报，他的危险值就会持续增加，每天增加 $1$ 点危险值 (开始搜集情报的当天危险值仍为 $0$，第 $2$ 天危险值为 $1$，第 $3$ 天危险值为 $2$，以此类推)。传递情报并不会使情报员的危险值增加。\n\n为了保证传递情报的过程相对安全，每条情报都有一个风险控制值 $C$。奈特公司认为，参与传递这条情报的所有情报员中，危险值大于 $C$ 的情报员将对该条情报构成威胁。现在，奈特公司希望知道，对于每个传递情报任务，参与传递的情报员有多少个，其中对该条情报构成威胁的情报员有多少个。", "inputFormat": "第一行包含一个正整数 $n$，表示情报员个数。\n笫二行包含 $n$ 个非负整数，其中第 $i$ 个整数 $P_i$ 表示 $i$ 号情报员上线的编号。特别地，若 $P_i=0$，表示 $i$ 号情报员是大头目。\n第三行包含一个正整数 $q$，表示奈特公司将派发 $q$ 个任务 (每天一个)。\n\n随后 $q$ 行，依次描述 $q$ 个任务。每行首先有一个正整数 $k$。\n\n- 若 $k=1$，表示任务是传递情报，随后有三个正整数 $X_i$、$Y_i$、$C_i$，依次表示传递情报的起点、终点和风险控制值。\n- 若 $k=2$，表示任务是搜集情报，随后有 $1$ 个正整数 $T_i$，表示搜集情报的情报员编号。", "outputFormat": "对于每个传递情报任务输出一行，包含两个整数，分别是参与传递情报的情报员个数和对该条情报构成威胁的情报员个数。", "hint": "样例解释：\n\n对于 $3$ 个传递情报任务，都是经过 $5$ 名情报员，分别是 $4$ 号、$2$ 号、$1$ 号、$3$ 号和 $7$ 号。\n\n- 第 $1$ 个任务，所有情报员 (危险值为 $0$) 都不对情报构成威胁；\n- 第 $2$ 个任务，有 $2$ 名情报员对情报构成威胁，分别是 $1$ 号情报员 (危险值为 $3$) 和 $4$ 号情报员 (危险值为 $2$)，$7$ 号情报员 (危险值为 $1$) 并不构成威胁；\n- 第 $3$ 个任务，只有 $1$ 名情报员对情报构成威胁。\n\n数据范围：\n\n$n\\leqslant 2\\times 10^5,Q\\leqslant 2\\times 10^5,0\\le P_i,C_i\\leqslant N,1\\leqslant T_i,X_i,Y_i\\leqslant n$。", "locale": "zh-CN"}}}
{"pid": "P4217", "type": "P", "difficulty": 7, "samples": [["4\n3 2 1 2\n2 5 2 2\n5 1 5 5\n1 2 1\n5 3 3", "30"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2010", "线段树", "模拟费用流", "CTSC/CTS"], "title": "[CTSC2010] 产品销售", "background": "", "description": "A 公司正在热销某计算机产品，作为 A 公司 CEO 的小 A 打算为接下来连续的 $N$ 个销售季度制定一份具体的生产和销售方案。 已知第 $i$ 个销售季度该产品的订购量为 $D_i$，在第 $i$ 个季度，A 公司会通过如下几种方式来解决用户的订购需求：\n\n- 在第 $i$ 个季度生产新的产品来销售。\n- 若在第 $i$ 个季度以前库存还有多余的产品，则可以直接在第 $i$ 个季度销售（注意第一个季度之前没有任何库存产品）。\n- 在第 $i$ 个季度可以不完成全部的订购需求，而将未完成的订购需求推迟，归入到下一个季度 $(i + 1)$ 的产品订购需求中。\n\nA 公司需要考虑以下几种耗费： 生产新产品的成本耗费、库存产品的额外储存耗费以及推迟订购需求而需要赔偿给用户的损失费。另外由于劳力和资源的限制，每个销售季度能够生产新产品的数量是有限的，各季度的耗费和可以生产的产品上限数也不尽相同，具体如下：\n\n- 在第 $i$ 个季度最多可以生产 $U_i$ 件新的产品，每一件的成本为 $P_i$。\n- 第 $i$ 个季度保存下来的产品，可以用于以后季度的销售。对于每一件产品，若从第 $i$ 季度保存到第 $i + 1$ 季度， 需要额外支付 $M_i$ 的存储费用（注意产品保存到下个季度后可能再次库存）。\n- 对于第 $i$ 个季度需要推迟而归入到下一个季度订购需求的每一件产品，A 公司需要赔偿给用户损失费 $C_i$（注意延迟到下个季度可能再次被延迟, 费用按后面季度的延迟费用计）。\n\n在第 $N$ 个季度结束后， A 公司必须解决之前所有的用户订单。可以保证， A公司能够生产的产品总数不会低于总订购量， 也就是说一定存在一组生产和销售方案使得满足所有的用户订购需求。小 A 想知道如何来安排产品的生产和销售，使得在满足所有订购需求的前提下公司总的耗费最小。", "inputFormat": "输入文件 $\\tt{product.in}$ 第一行是一个正整数 $N$，表示有 $N$ 个销售季度。\n\n第二行有 $N$ 个非负整数 $D_1,D_2,\\ldots,D_N$，表示第 $i$ 个季度的订购量。\n\n第三行有 $N$ 个非负整数 $U_1,U_2, \\ldots, U_N$，表示第 $i$ 个季度最多可以生产的新的产品数。\n\n第四行有 $N$ 个非负整数 $P_1, P_2, \\ldots, P_N$，表示第 $i$ 个季度生产一件新产品的成本。\n\n第五行有 $N - 1$ 个非负整数 $M_1, M_2,\\ldots,M_{N-1}$，表示将一件产品从第 $i$ 个季度保存到第 $i +1$ 个季度所需要的额外的耗费。\n\n第六行有 $N-1$ 个非负整数 $C_1, C_2, \\ldots, C_{N-1}$，表示一件产品的订购需求在第 $i$ 个季度没有完成而归入到第 $i +1$ 个季度的订购量中，需要赔偿给用户的损失费。", "outputFormat": "输出文件 $\\tt{product.out}$ 仅包含一个非负整数，表示公司的最小总耗费。", "hint": "【样例说明】\n\n第一个季度生产 $2$ 件产品，第二个季度生产 $5$ 件产品，第三个季度不生产产品，第四个季度生产 $1$ 件产品，成本为 $2 * 5 + 5 * 1 + 0 * 5 + 1 * 5 = 20$。\n\n因为第一个季度最多只能生产 $2$ 件产品，无法满足 $3$ 件的订购量，因此将 $1$件产品的订购量推迟到第二个季度，赔偿给用户的损失费为 $5$。\n\n第二个季度由于第一个季度推迟了一件产品的订购需求， 因而订购量变为 $3$。该季度生产了 $5$ 件产品，剩下的 $2$ 件保存下来。第三个季度直接销售库存的产品，再多出来的 $1$ 件产品继续储存到第四个季度，加上第四个季度生产了 $1$ 件产品，因此满足了所有订单需求。总的储存费用为 $2 * 2 + 1 * 1 = 5$。\n\n总的费用为 $20 + 5 + 5 = 30$。\n\n【数据规模】\n\n对于 $30\\%$的数据， $N \\leq 1,000$。\n\n对于 $100\\%$的数据， $1 \\leq N \\leq 100,000$， $1 \\leq D_i, U_i, P_i, M_i,C_i \\leq  10,000$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2010] Product Sales", "background": "", "description": "Company A is seeing strong sales of a certain computer product. As the CEO of Company A, Xiao A plans to make a detailed production and sales plan for the next consecutive $N$ sales quarters. It is known that in the $i$-th sales quarter the order quantity is $D_i$. In quarter $i$, Company A may meet the orders in the following ways:\n- Produce new products in quarter $i$ to sell.\n- If there is remaining inventory before quarter $i$, it can be sold directly in quarter $i$ (note that there is no inventory before the first quarter).\n- In quarter $i$, it is allowed to leave part of the orders unfilled and postpone them, merging them into the order quantity of the next quarter $(i + 1)$.\n\nCompany A needs to consider the following costs: the production cost for new products, the additional storage cost for inventory, and the compensation paid to users for delayed orders. Moreover, due to labor and resource limitations, the number of new products that can be produced in each sales quarter is limited, and both the costs and production upper bounds differ by quarter, as follows:\n- In quarter $i$, at most $U_i$ new units can be produced, and the cost per unit is $P_i$.\n- Products kept at the end of quarter $i$ for use in later quarters incur a storage fee: for each unit kept from quarter $i$ to quarter $i + 1$, an extra fee of $M_i$ must be paid (note that once kept to the next quarter, the product may remain in inventory again).\n- For each unit postponed from quarter $i$ and merged into the next quarter’s order quantity, Company A must compensate users $C_i$ (note that an order postponed to the next quarter may be postponed again, and the fee is charged according to the later quarter’s delay fee).\n\nBy the end of quarter $N$, Company A must have fulfilled all user orders. It is guaranteed that the total number of units the company can produce is not less than the total order quantity; that is, there exists at least one production and sales plan that satisfies all orders. Xiao A wants to know how to arrange production and sales so that, while satisfying all orders, the total cost is minimized.", "inputFormat": "The first line of the input file $\\tt{product.in}$ contains a positive integer $N$, the number of sales quarters.\n\nThe second line contains $N$ non-negative integers $D_1, D_2, \\ldots, D_N$, where $D_i$ is the order quantity in quarter $i$.\n\nThe third line contains $N$ non-negative integers $U_1, U_2, \\ldots, U_N$, where $U_i$ is the maximum number of new units that can be produced in quarter $i$.\n\nThe fourth line contains $N$ non-negative integers $P_1, P_2, \\ldots, P_N$, where $P_i$ is the per-unit production cost in quarter $i$.\n\nThe fifth line contains $N - 1$ non-negative integers $M_1, M_2, \\ldots, M_{N-1}$, where $M_i$ is the additional storage fee to keep one unit from quarter $i$ to quarter $i + 1$.\n\nThe sixth line contains $N - 1$ non-negative integers $C_1, C_2, \\ldots, C_{N-1}$, where $C_i$ is the compensation paid if one unit’s order is not fulfilled in quarter $i$ and is merged into the order quantity of quarter $i + 1$.", "outputFormat": "The output file $\\tt{product.out}$ contains a single non-negative integer, the minimal total cost.", "hint": "Sample Explanation:\n\nIn the first quarter, produce $2$ units. In the second quarter, produce $5$ units. In the third quarter, produce no units. In the fourth quarter, produce $1$ unit. The production cost is $2 * 5 + 5 * 1 + 0 * 5 + 1 * 5 = 20$.\n\nSince at most $2$ units can be produced in the first quarter, the $3$-unit order cannot be fully met; thus $1$ unit is postponed to the second quarter, incurring a compensation of $5$.\n\nIn the second quarter, because $1$ unit was postponed from the first quarter, the order quantity becomes $3$. This quarter produces $5$ units, leaving $2$ units in inventory. In the third quarter, sell directly from inventory; the extra $1$ unit is further stored to the fourth quarter. Together with producing $1$ unit in the fourth quarter, all orders are satisfied. The total storage cost is $2 * 2 + 1 * 1 = 5$.\n\nThe total cost is $20 + 5 + 5 = 30$.\n\nConstraints:\n\n- For $30\\%$ of the testdata, $N \\leq 1{,}000$.\n- For $100\\%$ of the testdata, $1 \\leq N \\leq 100{,}000$, $1 \\leq D_i, U_i, P_i, M_i, C_i \\leq 10{,}000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2010] 产品销售", "background": "", "description": "A 公司正在热销某计算机产品，作为 A 公司 CEO 的小 A 打算为接下来连续的 $N$ 个销售季度制定一份具体的生产和销售方案。 已知第 $i$ 个销售季度该产品的订购量为 $D_i$，在第 $i$ 个季度，A 公司会通过如下几种方式来解决用户的订购需求：\n\n- 在第 $i$ 个季度生产新的产品来销售。\n- 若在第 $i$ 个季度以前库存还有多余的产品，则可以直接在第 $i$ 个季度销售（注意第一个季度之前没有任何库存产品）。\n- 在第 $i$ 个季度可以不完成全部的订购需求，而将未完成的订购需求推迟，归入到下一个季度 $(i + 1)$ 的产品订购需求中。\n\nA 公司需要考虑以下几种耗费： 生产新产品的成本耗费、库存产品的额外储存耗费以及推迟订购需求而需要赔偿给用户的损失费。另外由于劳力和资源的限制，每个销售季度能够生产新产品的数量是有限的，各季度的耗费和可以生产的产品上限数也不尽相同，具体如下：\n\n- 在第 $i$ 个季度最多可以生产 $U_i$ 件新的产品，每一件的成本为 $P_i$。\n- 第 $i$ 个季度保存下来的产品，可以用于以后季度的销售。对于每一件产品，若从第 $i$ 季度保存到第 $i + 1$ 季度， 需要额外支付 $M_i$ 的存储费用（注意产品保存到下个季度后可能再次库存）。\n- 对于第 $i$ 个季度需要推迟而归入到下一个季度订购需求的每一件产品，A 公司需要赔偿给用户损失费 $C_i$（注意延迟到下个季度可能再次被延迟, 费用按后面季度的延迟费用计）。\n\n在第 $N$ 个季度结束后， A 公司必须解决之前所有的用户订单。可以保证， A公司能够生产的产品总数不会低于总订购量， 也就是说一定存在一组生产和销售方案使得满足所有的用户订购需求。小 A 想知道如何来安排产品的生产和销售，使得在满足所有订购需求的前提下公司总的耗费最小。", "inputFormat": "输入文件 $\\tt{product.in}$ 第一行是一个正整数 $N$，表示有 $N$ 个销售季度。\n\n第二行有 $N$ 个非负整数 $D_1,D_2,\\ldots,D_N$，表示第 $i$ 个季度的订购量。\n\n第三行有 $N$ 个非负整数 $U_1,U_2, \\ldots, U_N$，表示第 $i$ 个季度最多可以生产的新的产品数。\n\n第四行有 $N$ 个非负整数 $P_1, P_2, \\ldots, P_N$，表示第 $i$ 个季度生产一件新产品的成本。\n\n第五行有 $N - 1$ 个非负整数 $M_1, M_2,\\ldots,M_{N-1}$，表示将一件产品从第 $i$ 个季度保存到第 $i +1$ 个季度所需要的额外的耗费。\n\n第六行有 $N-1$ 个非负整数 $C_1, C_2, \\ldots, C_{N-1}$，表示一件产品的订购需求在第 $i$ 个季度没有完成而归入到第 $i +1$ 个季度的订购量中，需要赔偿给用户的损失费。", "outputFormat": "输出文件 $\\tt{product.out}$ 仅包含一个非负整数，表示公司的最小总耗费。", "hint": "【样例说明】\n\n第一个季度生产 $2$ 件产品，第二个季度生产 $5$ 件产品，第三个季度不生产产品，第四个季度生产 $1$ 件产品，成本为 $2 * 5 + 5 * 1 + 0 * 5 + 1 * 5 = 20$。\n\n因为第一个季度最多只能生产 $2$ 件产品，无法满足 $3$ 件的订购量，因此将 $1$件产品的订购量推迟到第二个季度，赔偿给用户的损失费为 $5$。\n\n第二个季度由于第一个季度推迟了一件产品的订购需求， 因而订购量变为 $3$。该季度生产了 $5$ 件产品，剩下的 $2$ 件保存下来。第三个季度直接销售库存的产品，再多出来的 $1$ 件产品继续储存到第四个季度，加上第四个季度生产了 $1$ 件产品，因此满足了所有订单需求。总的储存费用为 $2 * 2 + 1 * 1 = 5$。\n\n总的费用为 $20 + 5 + 5 = 30$。\n\n【数据规模】\n\n对于 $30\\%$的数据， $N \\leq 1,000$。\n\n对于 $100\\%$的数据， $1 \\leq N \\leq 100,000$， $1 \\leq D_i, U_i, P_i, M_i,C_i \\leq  10,000$。", "locale": "zh-CN"}}}
{"pid": "P4218", "type": "P", "difficulty": 7, "samples": [["3 5\n1 2\n1 3\naab\nabaab", "15"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "2010", "枚举", "分治", "后缀树", "CTSC/CTS"], "title": "[CTSC2010] 珠宝商", "background": "", "description": "Louis.PS 是一名精明的珠宝商，他出售的项链构造独特，很大程度上是因为他的制作方法与众不同。每次 Louis.PS 到达某个国家后，他会选择一条路径去遍历该国的城市。在到达一个城市后，他会使用在这个城市流行的材料制作一颗珠子，并按照城市被访问的顺序将珠子串联做成项链，为了使制作出来的项链不会因为城市之间的竞争而影响销量，路径中同一个城市不会重复出现（因为如果项链中 $A$ 城市的材料比 $B$ 城市的材料使用的多，则项链在 $B$ 城市的宣传可能会受到影响）。经过多年对消费者的调查，Louis.PS 已经掌握了判断一条项链吸引消费者程度的方法，具体来说，Louis.PS 经过调查得出了受消费者欢迎的项链的特征，并基于此制作了一个长项链（Louis.PS 称之为特征项链）。对于一条待售的项链，这条项链在特征项链里出现的次数越多，这条项链就越受消费者欢迎。\n\n考虑到现实情况的复杂性，我们对条件做出适当的简化。对于每个国家，在某些城市间存在道路直接相连，对于两个不同的城市，有且仅有一条路径连接这两个城市（即国家是连通的，且不存在一个环）。对于每个城市，我们用一个小写字母来表示在这个城市流行的材料类型。这样，我们就可以用一个仅包含小写字母的字符串来表示一条项链，我们将特征项链所对应的字符串称作特征字符串，设为 $\\mathit{EigenString}[1\\ldots M]$，$M$ 为特征项链的长度。对于一条项链，假设其对应字符串为 $P[1\\ldots L]$，$L$ 为这条项链的长度。如果存在一个正整数 $K$，使 $\\mathit{EigenString}[K\\ldots K+L-1]=P[1\\ldots L]$，称这条项链在特征项链中出现了一次。满足上述条件的正整数 $K$ 的个数即为这条项链在特征项链的出现次数，记为 $\\mathit{Popularity}(P)$。\n\nLouis.PS 使用数学中的期望概念来评价一个国家是否适合珠宝的采集,对于一个包含 $N$ 个城市的国家，令 $\\mathit{Str}_{u,v}$ 表示沿着从 $u$ 开始,至 $v$ 结束的路径所得到的项链的对应字符串。（$\\mathit{Str}_{u,v}$ 与 $\\mathit{Str}_{v,u}$ 表示的串一般不相同），则\n\n$$\n\\mathit{Expectation}=\\frac{\\sum_{u,v}{\\mathit{Popularity}(\\mathit{Str}_{u,v})}}{N^2}\n$$\n\n对于如下的例子（图中实线表示两端点的国家有直接道路相连）：\n\n$N=3$，所流行的材料类型分别为 $\\tt{a,a,b}$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9zkwho64.png)\n\n$$\n\\mathit{Expectation}=\\frac{3+1+2+1+3+1+1+1+2}{9}=\\frac53\n$$\n\n对于一个国家，Louis.PS 想知道其 $\\mathit{Expectation}$ 的值，但苦于计算期望的工作量太大。作为珠宝店的学徒，你当然不愿放过难得在老板面前展示自己的机会。", "inputFormat": "输入第一行包含两个整数 $N,M$，表示城市个数及特征项链长度。\n\n接下来的 $N-1$ 行，每行两个整数 $x,y$，表示城市 $x$ 与城市 $y$ 有直接道路相连。城市由 $1\\sim N$ 进行编号。\n\n接下来的一行，包含一个长度为 $N$，仅包含小写字母的字符串，第 $i$ 位的字符表示在城市 $i$ 流行的原料类型。\n\n最后一行，包含一个长度为 $M$，仅包含小写字母的字符串， 表示特征字符串。", "outputFormat": "输出仅包含一个整数，为 $N^2\\times\\mathit{Expectation}$。", "hint": "有 $20\\%$ 的数据，满足 $M \\leq 1000$；\n\n有 $40\\%$ 的数据，满足ܰ $N \\leq 8000, M \\leq 50000$；\n\n对于 $100\\%$ 的数据，$N,M \\leq 50000$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2010] Jeweler", "background": "", "description": "Louis.PS is a shrewd jeweler whose necklaces have a unique construction, largely because his production method is different. Each time Louis.PS arrives in a country, he chooses a path to traverse the cities of that country. Upon arriving at a city, he makes a bead using the material popular in that city, and strings the beads together in the order the cities are visited to make a necklace. To prevent competition between cities from affecting sales, the path never visits the same city twice (because if the material from city $A$ is used more than that from city $B$ in the necklace, promotion in city $B$ may be affected). After years of consumer research, Louis.PS has learned how to judge how attractive a necklace is to consumers. Specifically, he has identified the features of popular necklaces and, based on this, has created a long necklace (which he calls the feature necklace). For a necklace for sale, the more times it appears in the feature necklace, the more popular it is.\n\nTo simplify the complex reality, we make the following assumptions. In each country, some cities are directly connected by roads; for any two distinct cities, there is exactly one path connecting them (i.e., the country is connected and has no cycle). For each city, we use a lowercase letter to denote the material type popular in that city. Thus, we can represent a necklace by a string containing only lowercase letters. We call the string corresponding to the feature necklace the feature string, denoted as $\\mathit{EigenString}[1\\ldots M]$, where $M$ is the length of the feature necklace. For a necklace, suppose its corresponding string is $P[1\\ldots L]$, where $L$ is the length of this necklace. If there exists a positive integer $K$ such that $\\mathit{EigenString}[K\\ldots K+L-1]=P[1\\ldots L]$, we say this necklace appears once in the feature necklace. The number of such positive integers $K$ is the occurrence count of this necklace in the feature necklace, denoted as $\\mathit{Popularity}(P)$.\n\nLouis.PS uses the mathematical concept of expectation to evaluate whether a country is suitable for material collection. For a country with $N$ cities, let $\\mathit{Str}_{u,v}$ denote the string corresponding to the necklace obtained along the path starting at $u$ and ending at $v$ (in general, $\\mathit{Str}_{u,v}$ and $\\mathit{Str}_{v,u}$ are different). Then\n$$\n\\mathit{Expectation}=\\frac{\\sum_{u,v}{\\mathit{Popularity}(\\mathit{Str}_{u,v})}}{N^2}\n$$\n\nFor the following example (solid lines in the figure indicate that the endpoints are directly connected by a road):\n\n$N=3$, and the popular material types are $\\tt{a,a,b}$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9zkwho64.png)\n\n$$\n\\mathit{Expectation}=\\frac{3+1+2+1+3+1+1+1+2}{9}=\\frac53\n$$\n\nFor a given country, Louis.PS wants to know the value of $\\mathit{Expectation}$, but the computation workload is large. As the apprentice, you certainly would not miss the chance to impress your boss.", "inputFormat": "The first line contains two integers $N, M$, the number of cities and the length of the feature necklace.\n\nThe next $N-1$ lines each contain two integers $x, y$, indicating that city $x$ and city $y$ are directly connected by a road. Cities are numbered from 1 to $N$.\n\nThe next line contains a string of length $N$ consisting only of lowercase letters. The $i$-th character indicates the material type popular in city $i$.\n\nThe last line contains a string of length $M$ consisting only of lowercase letters, denoting the feature string.", "outputFormat": "Output a single integer, which is $N^2 \\times \\mathit{Expectation}$.", "hint": "- 20% of the testdata satisfy $M \\leq 1000$.\n- 40% of the testdata satisfy $N \\leq 8000, M \\leq 50000$.\n- For 100% of the testdata, $N, M \\leq 50000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2010] 珠宝商", "background": "", "description": "Louis.PS 是一名精明的珠宝商，他出售的项链构造独特，很大程度上是因为他的制作方法与众不同。每次 Louis.PS 到达某个国家后，他会选择一条路径去遍历该国的城市。在到达一个城市后，他会使用在这个城市流行的材料制作一颗珠子，并按照城市被访问的顺序将珠子串联做成项链，为了使制作出来的项链不会因为城市之间的竞争而影响销量，路径中同一个城市不会重复出现（因为如果项链中 $A$ 城市的材料比 $B$ 城市的材料使用的多，则项链在 $B$ 城市的宣传可能会受到影响）。经过多年对消费者的调查，Louis.PS 已经掌握了判断一条项链吸引消费者程度的方法，具体来说，Louis.PS 经过调查得出了受消费者欢迎的项链的特征，并基于此制作了一个长项链（Louis.PS 称之为特征项链）。对于一条待售的项链，这条项链在特征项链里出现的次数越多，这条项链就越受消费者欢迎。\n\n考虑到现实情况的复杂性，我们对条件做出适当的简化。对于每个国家，在某些城市间存在道路直接相连，对于两个不同的城市，有且仅有一条路径连接这两个城市（即国家是连通的，且不存在一个环）。对于每个城市，我们用一个小写字母来表示在这个城市流行的材料类型。这样，我们就可以用一个仅包含小写字母的字符串来表示一条项链，我们将特征项链所对应的字符串称作特征字符串，设为 $\\mathit{EigenString}[1\\ldots M]$，$M$ 为特征项链的长度。对于一条项链，假设其对应字符串为 $P[1\\ldots L]$，$L$ 为这条项链的长度。如果存在一个正整数 $K$，使 $\\mathit{EigenString}[K\\ldots K+L-1]=P[1\\ldots L]$，称这条项链在特征项链中出现了一次。满足上述条件的正整数 $K$ 的个数即为这条项链在特征项链的出现次数，记为 $\\mathit{Popularity}(P)$。\n\nLouis.PS 使用数学中的期望概念来评价一个国家是否适合珠宝的采集,对于一个包含 $N$ 个城市的国家，令 $\\mathit{Str}_{u,v}$ 表示沿着从 $u$ 开始,至 $v$ 结束的路径所得到的项链的对应字符串。（$\\mathit{Str}_{u,v}$ 与 $\\mathit{Str}_{v,u}$ 表示的串一般不相同），则\n\n$$\n\\mathit{Expectation}=\\frac{\\sum_{u,v}{\\mathit{Popularity}(\\mathit{Str}_{u,v})}}{N^2}\n$$\n\n对于如下的例子（图中实线表示两端点的国家有直接道路相连）：\n\n$N=3$，所流行的材料类型分别为 $\\tt{a,a,b}$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9zkwho64.png)\n\n$$\n\\mathit{Expectation}=\\frac{3+1+2+1+3+1+1+1+2}{9}=\\frac53\n$$\n\n对于一个国家，Louis.PS 想知道其 $\\mathit{Expectation}$ 的值，但苦于计算期望的工作量太大。作为珠宝店的学徒，你当然不愿放过难得在老板面前展示自己的机会。", "inputFormat": "输入第一行包含两个整数 $N,M$，表示城市个数及特征项链长度。\n\n接下来的 $N-1$ 行，每行两个整数 $x,y$，表示城市 $x$ 与城市 $y$ 有直接道路相连。城市由 $1\\sim N$ 进行编号。\n\n接下来的一行，包含一个长度为 $N$，仅包含小写字母的字符串，第 $i$ 位的字符表示在城市 $i$ 流行的原料类型。\n\n最后一行，包含一个长度为 $M$，仅包含小写字母的字符串， 表示特征字符串。", "outputFormat": "输出仅包含一个整数，为 $N^2\\times\\mathit{Expectation}$。", "hint": "有 $20\\%$ 的数据，满足 $M \\leq 1000$；\n\n有 $40\\%$ 的数据，满足ܰ $N \\leq 8000, M \\leq 50000$；\n\n对于 $100\\%$ 的数据，$N,M \\leq 50000$。", "locale": "zh-CN"}}}
