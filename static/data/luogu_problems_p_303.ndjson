{"pid": "P7130", "type": "P", "difficulty": 6, "samples": [["3\n1 2 3\n1 2\n1 3", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2020"], "title": "「RdOI R1」平衡常数(balance)", "background": "", "description": "给定一棵以 $1$ 为根的点带权有根树 $G=(V,E)$，第 $i$ 个节点的权值记为 \n $w_i$，以 $i$ 为根的子树的点集记为 $V_i$，求一个点集 $V'\\subseteq V$，满足以下条件：\n\n- $\\forall i$，都有 $|V_i \\cap V'| \\le \\lfloor \\frac{|V_i|}{2} \\rfloor$\n\n- 最大化 $\\sum _{i \\in V'} w_i$\n\n输出 $\\sum _{i\\in V'} w_i$ 即可，也就是选取的点的权值和。", "inputFormat": "第一行为一个正整数 $n$。\n\n第二行为 $n$ 个正整数 $w_i$。\n\n接下来 $n-1$ 行每行为两个整数 $u,v$，表示第 $i$ 条边的两个端点。", "outputFormat": "输出只有一行，为你所求得的最大总和。", "hint": "【数据范围】\n\n| 测试点编号 | $n\\leq$ | $w_i\\leq$ | 特殊性质 |\n| - | - | - | - |\n| $1\\sim2$ | $10$ | $10^3$ | |\n| $3\\sim 5$ | $2 \\times 10^3$ | $10^3$ | |\n| $6\\sim12$ | $10^5$ | $10^3$ | |\n| $13\\sim16$ | $5 \\times 10^5$ | $10^9$ | $v=u+1$ |\n| $17\\sim25$ | $5 \\times 10^5$ | $10^9$ | |\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 5 \\times 10^5$，$0 < w_i \\leq 10^9$，$1 \\leq u,v \\leq n$。\n\n---\n\n【说明/提示】\n\n- Idea From : LCuter\n\n---\n\n【文件读入读出】**（模拟，提交代码时不需使用）**\n\n- 文件名：`balance.cpp`\n- 读入文件名：`balance.in`\n- 读出文件名：`balance.out`", "locale": "zh-CN", "translations": {"en": {"title": "\"RdOI R1\" Balance Constant (balance).", "background": "", "description": "Given a rooted weighted tree $G=(V,E)$ with root $1$, the weight of node $i$ is denoted by $w_i$. Let the set of nodes in the subtree rooted at $i$ be $V_i$. Find a node set $V'\\subseteq V$ that satisfies the following conditions:\n\n- For all $i$, $|V_i \\cap V'| \\le \\lfloor \\frac{|V_i|}{2} \\rfloor$.\n\n- Maximize $\\sum _{i \\in V'} w_i$.\n\nYou only need to output $\\sum _{i\\in V'} w_i$, i.e., the sum of the weights of the selected nodes.", "inputFormat": "The first line contains a positive integer $n$.\n\nThe second line contains $n$ positive integers $w_i$.\n\nThe next $n-1$ lines each contain two integers $u,v$, representing the two endpoints of an edge.", "outputFormat": "Output a single line containing the maximum total sum you computed.", "hint": "Constraints\n\n| Test Point ID | $n\\leq$ | $w_i\\leq$ | Special Property |\n| - | - | - | - |\n| $1\\sim2$ | $10$ | $10^3$ | |\n| $3\\sim 5$ | $2 \\times 10^3$ | $10^3$ | |\n| $6\\sim12$ | $10^5$ | $10^3$ | |\n| $13\\sim16$ | $5 \\times 10^5$ | $10^9$ | $v=u+1$ |\n| $17\\sim25$ | $5 \\times 10^5$ | $10^9$ | |\n\nFor $100\\%$ of the testdata, $1 \\leq n \\leq 5 \\times 10^5$, $0 < w_i \\leq 10^9$, $1 \\leq u,v \\leq n$.\n\n---\n\nNotes / Hints\n\n- Idea From: LCuter.\n\n---\n\nFile Input/Output **(simulation, not needed when submitting code)**\n\n- File name: `balance.cpp`.\n- Input file name: `balance.in`.\n- Output file name: `balance.out`.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "「RdOI R1」平衡常数(balance)", "background": "", "description": "给定一棵以 $1$ 为根的点带权有根树 $G=(V,E)$，第 $i$ 个节点的权值记为 \n $w_i$，以 $i$ 为根的子树的点集记为 $V_i$，求一个点集 $V'\\subseteq V$，满足以下条件：\n\n- $\\forall i$，都有 $|V_i \\cap V'| \\le \\lfloor \\frac{|V_i|}{2} \\rfloor$\n\n- 最大化 $\\sum _{i \\in V'} w_i$\n\n输出 $\\sum _{i\\in V'} w_i$ 即可，也就是选取的点的权值和。", "inputFormat": "第一行为一个正整数 $n$。\n\n第二行为 $n$ 个正整数 $w_i$。\n\n接下来 $n-1$ 行每行为两个整数 $u,v$，表示第 $i$ 条边的两个端点。", "outputFormat": "输出只有一行，为你所求得的最大总和。", "hint": "【数据范围】\n\n| 测试点编号 | $n\\leq$ | $w_i\\leq$ | 特殊性质 |\n| - | - | - | - |\n| $1\\sim2$ | $10$ | $10^3$ | |\n| $3\\sim 5$ | $2 \\times 10^3$ | $10^3$ | |\n| $6\\sim12$ | $10^5$ | $10^3$ | |\n| $13\\sim16$ | $5 \\times 10^5$ | $10^9$ | $v=u+1$ |\n| $17\\sim25$ | $5 \\times 10^5$ | $10^9$ | |\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 5 \\times 10^5$，$0 < w_i \\leq 10^9$，$1 \\leq u,v \\leq n$。\n\n---\n\n【说明/提示】\n\n- Idea From : LCuter\n\n---\n\n【文件读入读出】**（模拟，提交代码时不需使用）**\n\n- 文件名：`balance.cpp`\n- 读入文件名：`balance.in`\n- 读出文件名：`balance.out`", "locale": "zh-CN"}}}
{"pid": "P7131", "type": "P", "difficulty": 6, "samples": [["3 3\n2 1 2\n1 1 1\nq 100 1 3\nm 2 2 0\nq 100 1 3", "27\n13"], ["见附件中的 turn-big-sample1.in", "见附件中的 turn-big-sample1.out"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2020"], "title": "「RdOI R1」变换(turn)", "background": "", "description": "有 $n$ 个变换，其中第 $i$ 个有两个属性值 $p_i$ 和 $q_i$，当这个变换作用到 $x$ 时，$x$ 将会变成 $f_i(x),f_i(x)$ 的定义为：\n\n$$f_i(x)=\\left\\lfloor\\dfrac{x}{p_i}\\right\\rfloor+q_i$$\n\n给定 $m$ 条操作，操作分两种：\n\n**修改**操作可以修改某个变换的属性值；\n\n**查询**操作将会给定 $x$ 以及两个序号 $s$ 和 $t$，你需要计算并输出：\n\n$$f_{t}(f_{t-1}(\\cdots f_{s+1}(f_{s}(x))))$$", "inputFormat": "第一行：两个正整数表示 $n$ 和 $m$。\n\n第二行：$n$ 个整数，表示 $p_1,p_2,\\cdots,p_n$。\n\n第三行：$n$ 个整数，表示 $q_1,q_2,\\cdots,q_n$。\n\n接下来 $m$ 行，每行表示一个操作：\n\n修改 操作以字母 `m` 开头，后接三个参数 $i,p',q'$，表示将第 $i$ 个变换的属性值修改成 $p',q'$。保证任何时候属性都满足 $1\\leq p_i\\leq 1000, 0\\leq q_i\\leq 1000$。\n\n查询 操作以字母 `q` 开头，后接三个参数 $x,s,t$，意义见题面，保证 $s\\leq t, 0\\leq x\\leq 10^6$。", "outputFormat": "对每个询问操作，输出一个整数，表示所求的答案，以换行分隔。", "hint": "【数据范围】\n\n- 对于 $20\\%$ 的数据，$1 \\le n \\le 10^3,1 \\le m \\le 10^4$。\n- 对于另外 $30\\%$ 的数据，$1 \\le n \\le 10^4,1 \\le m \\le 10^5$。\n- 对于 $100\\%$ 的数据，$1 \\le n \\le 10^5,1 \\le m \\le 2 \\times 10^5$。\n\n---\n\n【文件读入读出】**（模拟，提交代码时不需使用）**\n\n- 文件名：`turn.cpp`\n- 读入文件名：`turn.in`\n- 读出文件名：`turn.out`", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「RdOI R1」变换(turn)", "background": "", "description": "有 $n$ 个变换，其中第 $i$ 个有两个属性值 $p_i$ 和 $q_i$，当这个变换作用到 $x$ 时，$x$ 将会变成 $f_i(x),f_i(x)$ 的定义为：\n\n$$f_i(x)=\\left\\lfloor\\dfrac{x}{p_i}\\right\\rfloor+q_i$$\n\n给定 $m$ 条操作，操作分两种：\n\n**修改**操作可以修改某个变换的属性值；\n\n**查询**操作将会给定 $x$ 以及两个序号 $s$ 和 $t$，你需要计算并输出：\n\n$$f_{t}(f_{t-1}(\\cdots f_{s+1}(f_{s}(x))))$$", "inputFormat": "第一行：两个正整数表示 $n$ 和 $m$。\n\n第二行：$n$ 个整数，表示 $p_1,p_2,\\cdots,p_n$。\n\n第三行：$n$ 个整数，表示 $q_1,q_2,\\cdots,q_n$。\n\n接下来 $m$ 行，每行表示一个操作：\n\n修改 操作以字母 `m` 开头，后接三个参数 $i,p',q'$，表示将第 $i$ 个变换的属性值修改成 $p',q'$。保证任何时候属性都满足 $1\\leq p_i\\leq 1000, 0\\leq q_i\\leq 1000$。\n\n查询 操作以字母 `q` 开头，后接三个参数 $x,s,t$，意义见题面，保证 $s\\leq t, 0\\leq x\\leq 10^6$。", "outputFormat": "对每个询问操作，输出一个整数，表示所求的答案，以换行分隔。", "hint": "【数据范围】\n\n- 对于 $20\\%$ 的数据，$1 \\le n \\le 10^3,1 \\le m \\le 10^4$。\n- 对于另外 $30\\%$ 的数据，$1 \\le n \\le 10^4,1 \\le m \\le 10^5$。\n- 对于 $100\\%$ 的数据，$1 \\le n \\le 10^5,1 \\le m \\le 2 \\times 10^5$。\n\n---\n\n【文件读入读出】**（模拟，提交代码时不需使用）**\n\n- 文件名：`turn.cpp`\n- 读入文件名：`turn.in`\n- 读出文件名：`turn.out`", "locale": "zh-CN"}}}
{"pid": "P7132", "type": "P", "difficulty": 4, "samples": [["3 3\n3 1 1 ", "59"], ["10 13\n12 13 1 4 5 9 7 0 3 8 ", "851695394"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["O2优化"], "title": "小 L 的零食", "background": "小 L 很喜欢吃零食。", "description": "**提交时自动开启 O2 优化**。\n\n小 L 现在想把一些零食放在一个盒子里。但是零食没放稳就会摔坏，所以小 L 希望求出**有多少种稳定的堆放零食的方法**。\n\n零食都可以抽象成一个 $1\\times1$ 的正方形，而盒子的底部可以看成长度为 $n$ 的一维线段。准确地说，零食被分为 $n$ 堆，从左到右地放在盒子里面，依次记为第 $1,2,\\ldots,n$ 堆。我们认为每一堆的高度 $h_i$ 是这一堆零食的数量，且任意一堆都可以不包含任何零食。\n\n我们定义第 $i$ 堆零食是稳定的，当且仅当：\n\n- $h_i\\le m$，即这一堆零食高度不超过 $m$。\n- 在满足上一条的同时，满足以下两条之一或同时满足：\n  - $i=1$ 或 $i=n$，此时有一侧是盒子内壁所以这一堆不会倒下；\n  - $\\color{red}\\max\\{h_{i-1},h_{i+1}\\}\\ge h_i-d_i$，此时它两侧的两堆零食有一堆足够高可以支撑这一堆不倒下。\n\n我们定义一种稳定的堆放零食的方法，是一个长度为 $n$ 的 $h_i$ 的序列，满足按这个序列堆放出来的零食每一堆都是稳定的。\n\n显然盒子里最多放下 $n\\times m$ 个零食，我们认为小 L 的零食数量不少于 $n\\times m$，并且不必将所有零食全部放进盒子。额外地，我们认为**每一个零食都是完全一样的**。", "inputFormat": "总共包括 $2$ 行。\n\n第一行包含两个正整数 $n,m$。\n\n第二行包含 $n$ 个整数 $d_1,d_2\\ldots,d_n$，意义如【题目描述】中红色部分所示。\n\n每行的两个数字间由单个空格隔开，数据在 Windows 下生成。**行末不保证没有多余空格**。", "outputFormat": "一行一个整数，表示有多少种稳定的堆放零食的方法，**结果对 $998244353$ 取模**。", "hint": "本题采用如下计分策略：    \n**subtask $1$**（#$1\\sim{}$#$8$）：$10\\%$，$n,m\\le5$；  \n**subtask $2$**（#$9\\sim{}$#$12$）：$30\\%$，$n,m\\le5\\times10^2$；  \n**subtask $3$**（#$13\\sim{}$#$16$）：$20\\%$，$n,m\\le3\\times10^3$；  \n**subtask $4$**（#$17\\sim{}$#$24$）：$40\\%$，$n,m\\le7\\times10^3$。  \n对于 $100\\%$ 的数据：$1\\le n,m\\le7\\times10^3$，$0\\le d_i\\le m$。**你必须通过一个 subtask 内所有测试点，才被认为通过该 subtask。**\n\n**本题开启子任务依赖。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "小 L 的零食", "background": "小 L 很喜欢吃零食。", "description": "**提交时自动开启 O2 优化**。\n\n小 L 现在想把一些零食放在一个盒子里。但是零食没放稳就会摔坏，所以小 L 希望求出**有多少种稳定的堆放零食的方法**。\n\n零食都可以抽象成一个 $1\\times1$ 的正方形，而盒子的底部可以看成长度为 $n$ 的一维线段。准确地说，零食被分为 $n$ 堆，从左到右地放在盒子里面，依次记为第 $1,2,\\ldots,n$ 堆。我们认为每一堆的高度 $h_i$ 是这一堆零食的数量，且任意一堆都可以不包含任何零食。\n\n我们定义第 $i$ 堆零食是稳定的，当且仅当：\n\n- $h_i\\le m$，即这一堆零食高度不超过 $m$。\n- 在满足上一条的同时，满足以下两条之一或同时满足：\n  - $i=1$ 或 $i=n$，此时有一侧是盒子内壁所以这一堆不会倒下；\n  - $\\color{red}\\max\\{h_{i-1},h_{i+1}\\}\\ge h_i-d_i$，此时它两侧的两堆零食有一堆足够高可以支撑这一堆不倒下。\n\n我们定义一种稳定的堆放零食的方法，是一个长度为 $n$ 的 $h_i$ 的序列，满足按这个序列堆放出来的零食每一堆都是稳定的。\n\n显然盒子里最多放下 $n\\times m$ 个零食，我们认为小 L 的零食数量不少于 $n\\times m$，并且不必将所有零食全部放进盒子。额外地，我们认为**每一个零食都是完全一样的**。", "inputFormat": "总共包括 $2$ 行。\n\n第一行包含两个正整数 $n,m$。\n\n第二行包含 $n$ 个整数 $d_1,d_2\\ldots,d_n$，意义如【题目描述】中红色部分所示。\n\n每行的两个数字间由单个空格隔开，数据在 Windows 下生成。**行末不保证没有多余空格**。", "outputFormat": "一行一个整数，表示有多少种稳定的堆放零食的方法，**结果对 $998244353$ 取模**。", "hint": "本题采用如下计分策略：    \n**subtask $1$**（#$1\\sim{}$#$8$）：$10\\%$，$n,m\\le5$；  \n**subtask $2$**（#$9\\sim{}$#$12$）：$30\\%$，$n,m\\le5\\times10^2$；  \n**subtask $3$**（#$13\\sim{}$#$16$）：$20\\%$，$n,m\\le3\\times10^3$；  \n**subtask $4$**（#$17\\sim{}$#$24$）：$40\\%$，$n,m\\le7\\times10^3$。  \n对于 $100\\%$ 的数据：$1\\le n,m\\le7\\times10^3$，$0\\le d_i\\le m$。**你必须通过一个 subtask 内所有测试点，才被认为通过该 subtask。**\n\n**本题开启子任务依赖。**", "locale": "zh-CN"}}}
{"pid": "P7133", "type": "P", "difficulty": 4, "samples": [["5 2\n1 0\n1 1\n2 2\n-1 2\n-2 -1\n-1 1\n-1 2", "4\n5"], ["见下发文件 ex_star2.in", "见下发文件 ex_star2.out"], ["见下发文件 ex_star3.in", "见下发文件 ex_star3.out"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["模拟", "二分", "排序"], "title": "小 P 的星空", "background": "\n\n>星依云渚溅溅，露零玉液涓涓，宝砌哀兰剪剪。碧天如练，光摇北斗阑干。\n>\n>—— 【元】孟昉《天净沙 · 星依云渚溅溅》\n\n小 P 漫步于星空之下。\n\n“摘下星星送给你，你就是我的全世界”。\n\n“今夜，我不关心人类，我只想你”。", "description": "将星空看作一个平面直角坐标系，小 P 所在的位置为 $(0,0)$，即坐标原点。天上共有 $n$ 颗星星，第 $i$ 颗星星的坐标为 $(x_i,y_i)$。\n\n小 P 最初面向点 $(1,0)$，然后小 P 会进行 $m$ 次原地转动，第 $i$ 次转动后会面向点 $(u_i,v_i)$。\n\n他可以选择逆时针转动或顺时针转动，当面向此次旋转最终将要面向的方向时，此次转动立即停止。\n\n他相信，在转动过程中，越多的星星出现在他正前方，他【数据删除】。\n\n小 P 想知道，每一次转动过程中他最多可以让多少星星出现在他正前方（包括转动初始方向和结束方向正前方看到的星星）。", "inputFormat": "总共包括 $n+m+1$ 行。\n\n第一行包含两个正整数 $n,m$，分别表示星星颗数和转动次数。\n\n接下来的 $n$ 行，每行两个整数 $x_i,y_i$。\n\n接下来的 $m$ 行，每行两个整数 $u_i,v_i$，意义如【题目描述】中所述。\n\n每行的两个数字间由单个空格隔开，数据为 Linux 格式，行末保证没有多余空格。", "outputFormat": "$m$ 行，每行一个整数。第 $i$ 行的整数表示第 $i$ 次转动的答案。", "hint": "样例1示意图如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/h2t5eu1a.png)\n\n橙色点为星星，绿色点小 P 第一次的转动位置。第一次转动，从 $(1,0)$ 转到 $(-1,1)$。若顺时针转动(蓝色区域，包括边界)，$(1,0)$, $(-2,-1)$，共计 $2$ 颗星星；而逆时针转动(绿色区域，包括边界)，$(1,0)$, $(1,1)$,$(2,2)$,$(-1,2)$，共计 $4$ 颗星星。\n\n第二次转动，从 $(-1,1)$ 转到 $(-1,2)$，逆时针转动，$5$ 颗星星都会在转动过程中出现在小 P 正前方。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b22go7at.png)\n\n除测试点 $24$ 和 $25$ 外，其他测试点保证所有坐标的绝对值 $\\le 1000$。\n\n对于前 $12$ 个测试点，保证原点到任意星星形成的射线上没有其他星星。\n\n除 $23,25$ 测试点外，对于所有编号为奇数的测试点，保证小 P 初始面向方向和每次转动目标方向上没有任何星星。\n\n除 $22,24$ 测试点外，对于所有编号为偶数的测试点，保证小 P 初始面向方向和每次转动目标方向上至少有一颗星星。\n\n对于 $100\\%$ 的数据，保证星星的坐标互不相同，保证坐标不会出现 $(0,0)$，保证不会出现转动初始方向等于结束方向。\n\n样例 $3$ 满足偶数测试点的限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "小 P 的星空", "background": "\n\n>星依云渚溅溅，露零玉液涓涓，宝砌哀兰剪剪。碧天如练，光摇北斗阑干。\n>\n>—— 【元】孟昉《天净沙 · 星依云渚溅溅》\n\n小 P 漫步于星空之下。\n\n“摘下星星送给你，你就是我的全世界”。\n\n“今夜，我不关心人类，我只想你”。", "description": "将星空看作一个平面直角坐标系，小 P 所在的位置为 $(0,0)$，即坐标原点。天上共有 $n$ 颗星星，第 $i$ 颗星星的坐标为 $(x_i,y_i)$。\n\n小 P 最初面向点 $(1,0)$，然后小 P 会进行 $m$ 次原地转动，第 $i$ 次转动后会面向点 $(u_i,v_i)$。\n\n他可以选择逆时针转动或顺时针转动，当面向此次旋转最终将要面向的方向时，此次转动立即停止。\n\n他相信，在转动过程中，越多的星星出现在他正前方，他【数据删除】。\n\n小 P 想知道，每一次转动过程中他最多可以让多少星星出现在他正前方（包括转动初始方向和结束方向正前方看到的星星）。", "inputFormat": "总共包括 $n+m+1$ 行。\n\n第一行包含两个正整数 $n,m$，分别表示星星颗数和转动次数。\n\n接下来的 $n$ 行，每行两个整数 $x_i,y_i$。\n\n接下来的 $m$ 行，每行两个整数 $u_i,v_i$，意义如【题目描述】中所述。\n\n每行的两个数字间由单个空格隔开，数据为 Linux 格式，行末保证没有多余空格。", "outputFormat": "$m$ 行，每行一个整数。第 $i$ 行的整数表示第 $i$ 次转动的答案。", "hint": "样例1示意图如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/h2t5eu1a.png)\n\n橙色点为星星，绿色点小 P 第一次的转动位置。第一次转动，从 $(1,0)$ 转到 $(-1,1)$。若顺时针转动(蓝色区域，包括边界)，$(1,0)$, $(-2,-1)$，共计 $2$ 颗星星；而逆时针转动(绿色区域，包括边界)，$(1,0)$, $(1,1)$,$(2,2)$,$(-1,2)$，共计 $4$ 颗星星。\n\n第二次转动，从 $(-1,1)$ 转到 $(-1,2)$，逆时针转动，$5$ 颗星星都会在转动过程中出现在小 P 正前方。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b22go7at.png)\n\n除测试点 $24$ 和 $25$ 外，其他测试点保证所有坐标的绝对值 $\\le 1000$。\n\n对于前 $12$ 个测试点，保证原点到任意星星形成的射线上没有其他星星。\n\n除 $23,25$ 测试点外，对于所有编号为奇数的测试点，保证小 P 初始面向方向和每次转动目标方向上没有任何星星。\n\n除 $22,24$ 测试点外，对于所有编号为偶数的测试点，保证小 P 初始面向方向和每次转动目标方向上至少有一颗星星。\n\n对于 $100\\%$ 的数据，保证星星的坐标互不相同，保证坐标不会出现 $(0,0)$，保证不会出现转动初始方向等于结束方向。\n\n样例 $3$ 满足偶数测试点的限制。", "locale": "zh-CN"}}}
{"pid": "P7134", "type": "P", "difficulty": 6, "samples": [["10 9\n4 3 2 1 9 6 8 8 1 3 \n0 4 8 3 10 9\n1 1 3 2 973874498\n0 10 10 5 9 6\n1 7 9 3 738164087\n1 1 10 1 694888198\n0 2 2 4 7 7\n0 1 6 1 3 3\n1 1 10 3 868703567\n1 4 9 3 545789338\n", "525"]], "limits": {"time": [1000, 1000, 1000, 1500, 1500, 1500, 1500, 3500, 3500, 12000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["O2优化"], "title": "小 H 的序列", "background": "小 H 有一个序列。", "description": "**提交时自动开启 O2 优化。**\n\n小 H 想让你维护一个长为 $n$ 序列 $a_1,a_2,\\ldots,a_n$，要求支持\n\n- 修改操作：将所有满足$i\\in[l,r]$且$u\\le a_i\\le v$的$a_i$的值修改为$w$；\n- 查询操作：求出$\\sum_{i=l}^ra_i^t\\bmod k$。", "inputFormat": "总共包括 $m+2$ 行。\n\n第一行包含两个正整数 $n,m$，分别表示序列长度和操作次数。\n\n第二行包含 $n$ 个正整数 $a_1,a_2\\ldots,a_n$，表示最初的序列。\n\n接下来的 $m$ 行，每行由一个数 $o$ 开头，表示操作类型。\n\n- 如果 $o=0$，表示修改操作，紧接着给出五个正整数 $l,r,u,v,w$；\n- 如果 $o=1$，表示查询操作，紧接着给出四个正整数 $l,r,t,k$，意义如【题目描述】中所述。\n\n每行的两个数字间由单个空格隔开，数据在 Windows 下生成。**行末不保证没有多余空格**。", "outputFormat": "一行一个整数，表示所有查询操作的答案的异或和（如果没有查询操作输出一个数 $0$）。", "hint": "输入的所有数字均为正整数。  \n设存在数据范围 $\\mathrm{randmax}$，满足 $n,m,a_i,w\\le\\mathrm{randmax},1\\le l\\le r\\le n,1\\le u\\le v\\le \\mathrm{randmax},1\\le t,k\\le10^9$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wt8vfeho.png)\n\n保证数据除 $n,m$ 以及测试点 $4,5$ 的 $t$ 外随机，各变量意义如【题目描述】中所述。\n\n由于本题输入量较大及为了省下不必要的评测耗时，请注意输入优化。在此给出以下模板（`c++`语言）：\n\n```cpp\n/* ---- read() & rlong() - begin ---- */\n#define gc() (p0==p1&&(p1=(p0=buf)+fread(buf,1,1048576,stdin),p0==p1)?EOF:*p0++)\nchar buf[1048576],*p0,*p1;\ninline int read() {\n\tint r=0; char c=gc(); while (c<48||c>57) c=gc();\n\twhile (c>47&&c<58) {r=(r<<3)+(r<<1)+(c^48); c=gc();} return r;\n}\n#undef gc\n/* ---- read() & rlong() -- end ----- */\n```\n\n调用`read()`函数会从输入中读入一个`int`型整数，注意该模板不能处理负数，调试时请使用文件输入。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "小 H 的序列", "background": "小 H 有一个序列。", "description": "**提交时自动开启 O2 优化。**\n\n小 H 想让你维护一个长为 $n$ 序列 $a_1,a_2,\\ldots,a_n$，要求支持\n\n- 修改操作：将所有满足$i\\in[l,r]$且$u\\le a_i\\le v$的$a_i$的值修改为$w$；\n- 查询操作：求出$\\sum_{i=l}^ra_i^t\\bmod k$。", "inputFormat": "总共包括 $m+2$ 行。\n\n第一行包含两个正整数 $n,m$，分别表示序列长度和操作次数。\n\n第二行包含 $n$ 个正整数 $a_1,a_2\\ldots,a_n$，表示最初的序列。\n\n接下来的 $m$ 行，每行由一个数 $o$ 开头，表示操作类型。\n\n- 如果 $o=0$，表示修改操作，紧接着给出五个正整数 $l,r,u,v,w$；\n- 如果 $o=1$，表示查询操作，紧接着给出四个正整数 $l,r,t,k$，意义如【题目描述】中所述。\n\n每行的两个数字间由单个空格隔开，数据在 Windows 下生成。**行末不保证没有多余空格**。", "outputFormat": "一行一个整数，表示所有查询操作的答案的异或和（如果没有查询操作输出一个数 $0$）。", "hint": "输入的所有数字均为正整数。  \n设存在数据范围 $\\mathrm{randmax}$，满足 $n,m,a_i,w\\le\\mathrm{randmax},1\\le l\\le r\\le n,1\\le u\\le v\\le \\mathrm{randmax},1\\le t,k\\le10^9$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wt8vfeho.png)\n\n保证数据除 $n,m$ 以及测试点 $4,5$ 的 $t$ 外随机，各变量意义如【题目描述】中所述。\n\n由于本题输入量较大及为了省下不必要的评测耗时，请注意输入优化。在此给出以下模板（`c++`语言）：\n\n```cpp\n/* ---- read() & rlong() - begin ---- */\n#define gc() (p0==p1&&(p1=(p0=buf)+fread(buf,1,1048576,stdin),p0==p1)?EOF:*p0++)\nchar buf[1048576],*p0,*p1;\ninline int read() {\n\tint r=0; char c=gc(); while (c<48||c>57) c=gc();\n\twhile (c>47&&c<58) {r=(r<<3)+(r<<1)+(c^48); c=gc();} return r;\n}\n#undef gc\n/* ---- read() & rlong() -- end ----- */\n```\n\n调用`read()`函数会从输入中读入一个`int`型整数，注意该模板不能处理负数，调试时请使用文件输入。", "locale": "zh-CN"}}}
{"pid": "P7135", "type": "P", "difficulty": 5, "samples": [], "limits": {"time": [1000], "memory": [262144]}, "tags": ["搜索", "贪心", "交互题", "Special Judge", "博弈树"], "title": "小 B 的面包", "background": "本题是一道**函数式交互题**。\n\n小 B 获得了很多面包，小 Y 很愤怒，他想抢夺面包。\n\n小 Y 提出要和小 B 玩一个有趣的游戏，如果小 B 输了，小 B 就要被抢走所有面包。\n\n小 B 还要到【数据删除】江边散步，所以他把这个任务交给了你。\n\n聪明的你能帮小 B 守卫他宝贵的面包吗？", "description": "**本题建议使用 `c++` 语言编程**。\n\n小 Y 把 $9$ 个面包依次放在了桌子上，第 $i$ 个面包的质量为 $i$。\n\n小 Y 与你轮流选取面包，谁选取的面包中，任意三个面包的总质量先恰好达到 $15$，谁就获胜，另外一方则落败。**每个面包只能取一次，一个人取了某个面包后另一个人就不能再选取了，选取面包后不能再放回**。\n\n如果最后面包全部选取完后双方未均达到，则为平局。\n\n---\n\n本题中，你需要且只需要实现以下三个函数（可以在其中调用或访问你的自写函数或全局变量）：\n\n```cpp\nextern \"C\" int choose(int x);\nextern \"C\" void init();\nextern \"C\" void newgame(bool f);\n/* 注意以上三个函数之前的 extern \"C\" 不可省略 */\n```\n\n评测时，交互库将首先调用一次你所实现的 `init()` 函数。`init()` 函数的作用为方便你最开始初始化，之后不会再次调用，如果你不需要初始化也请加入 `extern \"C\" void init() {}`。\n\n接下来交互库会调用你所实现的 `newgame(bool f)` 函数，交互库调用 `newgame(bool f)` 函数表示开始一场新游戏，传入的 `f` 若等于 $1$ 表示是由交互库先选择，否则由你先选择。\n\n接下来交互库将会不断调用你实现的 `choose(int x)` 函数，传入的 $x$ 表示小 Y 选取了第 $x$ 个面包，此函数运行结束后你需要返回一个整数 $y(1 \\le y \\le 9)$，表示你选取了第 $y$ 个面包，即：\n\n```cpp\nextern \"C\" int choose(int x) { /*x为交互库选取的面包 */\n    /* 你的代码 */\n    return y; /* y为你选取的面包 */\n}\n```\n\n特别地，当传入的 $x=0$ 时，表示是由你先选取面包。如果你 `choose(int x)` 函数返回了不合法的值，该场游戏立即结束，且结果为交互库获胜。\n\n不停调用 `choose(int x)` 函数直到某一方胜利或平局，即该场游戏结束。接着，交互库又会调用 `newgame(bool f)` 函数，开始一场新游戏。交互库一共会调用 $1800$ 次 `newgame(bool f)` 函数，表示进行 $1800$ 场游戏。\n\n详细可查看`template_game.cpp`。\n\n---\n\n在附加文件中，有以下一个文件：\n\n`template_game.cpp`——你将在其中实现上述三个函数，内含详细注释，也包括交互库参考代码，请仔细阅读，**建议在此基础上答题**。\n\n本地可直接在 IDE 中编译。", "inputFormat": "无", "outputFormat": "对于本地交互库，**交互库**最后会输出两行：\n\n第一行两个数 $w,d$ ，分别表示你获胜的场数和平局的场数；\n\n第二行为你的得分。", "hint": "**保证交互库采用完全随机选取策略，即每次均会从未选取的面包中等概率选取一个面包**\n\n$1800$ 场游戏中，有 $600$ 场是由你的程序先选取，有 $1200$ 场是由交互库先选取。\n\n具体来说，对于第 $i$ 场游戏，若 $i \\bmod 3 =0$ ，则由你的程序先选取，否则由交互库先选取。\n\n本题首先会受到和传统题相同的限制，例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制等会导致相应测试点得 $0$ 分等。\n\n你只能访问自己定义的和交互库给出的变量及其对应的内存空间，尝试访问其他空间将可能导致编译错误或运行错误。\n\n**本题只有一个测试点，你的得分按如下规定判定：**\n\n设你程序获胜了 $x$ 场，平局为 $y$ 场，你最终的得分用计分函数 $f(x,y)$ 表示为：\n\n$$\nf(x,y)=\\lfloor (\\frac{x+y}{6}-200) \\cdot \\min((\\frac{x}{x + y})^2+0.2,1) \\rfloor\n$$\n\n最低得分为 $0$ 分。\n\n**实际评测的交互库与下发的不相同，选手的程序应不依赖于交互库实现**。\n\n详细可查看`template_game.cpp`。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "小 B 的面包", "background": "本题是一道**函数式交互题**。\n\n小 B 获得了很多面包，小 Y 很愤怒，他想抢夺面包。\n\n小 Y 提出要和小 B 玩一个有趣的游戏，如果小 B 输了，小 B 就要被抢走所有面包。\n\n小 B 还要到【数据删除】江边散步，所以他把这个任务交给了你。\n\n聪明的你能帮小 B 守卫他宝贵的面包吗？", "description": "**本题建议使用 `c++` 语言编程**。\n\n小 Y 把 $9$ 个面包依次放在了桌子上，第 $i$ 个面包的质量为 $i$。\n\n小 Y 与你轮流选取面包，谁选取的面包中，任意三个面包的总质量先恰好达到 $15$，谁就获胜，另外一方则落败。**每个面包只能取一次，一个人取了某个面包后另一个人就不能再选取了，选取面包后不能再放回**。\n\n如果最后面包全部选取完后双方未均达到，则为平局。\n\n---\n\n本题中，你需要且只需要实现以下三个函数（可以在其中调用或访问你的自写函数或全局变量）：\n\n```cpp\nextern \"C\" int choose(int x);\nextern \"C\" void init();\nextern \"C\" void newgame(bool f);\n/* 注意以上三个函数之前的 extern \"C\" 不可省略 */\n```\n\n评测时，交互库将首先调用一次你所实现的 `init()` 函数。`init()` 函数的作用为方便你最开始初始化，之后不会再次调用，如果你不需要初始化也请加入 `extern \"C\" void init() {}`。\n\n接下来交互库会调用你所实现的 `newgame(bool f)` 函数，交互库调用 `newgame(bool f)` 函数表示开始一场新游戏，传入的 `f` 若等于 $1$ 表示是由交互库先选择，否则由你先选择。\n\n接下来交互库将会不断调用你实现的 `choose(int x)` 函数，传入的 $x$ 表示小 Y 选取了第 $x$ 个面包，此函数运行结束后你需要返回一个整数 $y(1 \\le y \\le 9)$，表示你选取了第 $y$ 个面包，即：\n\n```cpp\nextern \"C\" int choose(int x) { /*x为交互库选取的面包 */\n    /* 你的代码 */\n    return y; /* y为你选取的面包 */\n}\n```\n\n特别地，当传入的 $x=0$ 时，表示是由你先选取面包。如果你 `choose(int x)` 函数返回了不合法的值，该场游戏立即结束，且结果为交互库获胜。\n\n不停调用 `choose(int x)` 函数直到某一方胜利或平局，即该场游戏结束。接着，交互库又会调用 `newgame(bool f)` 函数，开始一场新游戏。交互库一共会调用 $1800$ 次 `newgame(bool f)` 函数，表示进行 $1800$ 场游戏。\n\n详细可查看`template_game.cpp`。\n\n---\n\n在附加文件中，有以下一个文件：\n\n`template_game.cpp`——你将在其中实现上述三个函数，内含详细注释，也包括交互库参考代码，请仔细阅读，**建议在此基础上答题**。\n\n本地可直接在 IDE 中编译。", "inputFormat": "无", "outputFormat": "对于本地交互库，**交互库**最后会输出两行：\n\n第一行两个数 $w,d$ ，分别表示你获胜的场数和平局的场数；\n\n第二行为你的得分。", "hint": "**保证交互库采用完全随机选取策略，即每次均会从未选取的面包中等概率选取一个面包**\n\n$1800$ 场游戏中，有 $600$ 场是由你的程序先选取，有 $1200$ 场是由交互库先选取。\n\n具体来说，对于第 $i$ 场游戏，若 $i \\bmod 3 =0$ ，则由你的程序先选取，否则由交互库先选取。\n\n本题首先会受到和传统题相同的限制，例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制等会导致相应测试点得 $0$ 分等。\n\n你只能访问自己定义的和交互库给出的变量及其对应的内存空间，尝试访问其他空间将可能导致编译错误或运行错误。\n\n**本题只有一个测试点，你的得分按如下规定判定：**\n\n设你程序获胜了 $x$ 场，平局为 $y$ 场，你最终的得分用计分函数 $f(x,y)$ 表示为：\n\n$$\nf(x,y)=\\lfloor (\\frac{x+y}{6}-200) \\cdot \\min((\\frac{x}{x + y})^2+0.2,1) \\rfloor\n$$\n\n最低得分为 $0$ 分。\n\n**实际评测的交互库与下发的不相同，选手的程序应不依赖于交互库实现**。\n\n详细可查看`template_game.cpp`。", "locale": "zh-CN"}}}
{"pid": "P7136", "type": "P", "difficulty": 6, "samples": [["3 3 1\n2 2 2 2\n", "64\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "THUPC"], "title": "[THUPC 2021 初赛] 方格游戏", "background": "", "description": "小 F 和小 H 在玩游戏。今天，他们在一个 $N\\times M$ 的棋盘上玩游戏。小 H 想考考小 F 的数学能力，但小 F 天生数学就不好，所以想请你帮忙。为了加大难度，小 $H$ 会在棋盘里面加入 $P$ 个矩形障碍物。每个矩形障碍物用 $U$、$D$、$L$、$R$ 来表示，即在第 $U$ 行到第 $D$ 行以及在第 $L$ 列到第 $R$ 列之间的所有格子都变成了障碍物。小 H 保证所有矩形障碍物互不相交，并且所有非障碍物格子之间都能够直接或者间接互达，若两个非障碍物格子有公共边，那么它们直接互达并且它们的距离为 $1$。\n\n现在每一局游戏中，小 F 在棋盘中挑选一个非障碍物格子 $X$，小 H 也挑另外一个非障碍物格子 $Y$，这一局游戏 $(X,Y)$ 的得分就是 $X$ 到 $Y$ 的最短路径。小 F 需要计算出所有可能的游戏中的得分和，答案模 $1,000,000,007$。注意两局游戏中只要挑选的两个格子相同则视为同一局游戏，即 $(X, Y)$ 等同于 $(Y,X)$。", "inputFormat": "第一行三个整数 $N$（$1 \\le N \\le 1,000,000,000$），$M$（$1 \\le M \\le 1,000,000,000$），$P$（$0 \\le P \\le 100,000$）。  \n接下来有 $P$ 行，每行四个正整数，$U_i, D_i$（$1 < U_i \\le D_i < N$），$L_i, R_i$（$1 < L_i \\le R_i < M$），表示第 $i$ 个矩形障碍物。对于任意两个不同的矩形障碍物 $i$ 和 $j$，都满足 $D_i + 1 < U_j$ 或者 $D_j + 1 < U_i$，以及 $R_i + 1 < L_j$ 或者 $R_j + 1 < L_i$。", "outputFormat": "只有一行一个正整数，即所有游戏的得分和模 $1,000,000,007$。", "hint": "**【样例解释 #1】**\n\n距离为 $1$ 的有 $8$ 种。  \n距离为 $2$ 的有 $8$ 种。  \n距离为 $3$ 的有 $8$ 种。  \n距离为 $4$ 的有 $4$ 种。  \n总共得分为 $64$。\n\n**【题目来源】**\n\n来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。\n\n题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2021 初赛] 方格游戏", "background": "", "description": "小 F 和小 H 在玩游戏。今天，他们在一个 $N\\times M$ 的棋盘上玩游戏。小 H 想考考小 F 的数学能力，但小 F 天生数学就不好，所以想请你帮忙。为了加大难度，小 $H$ 会在棋盘里面加入 $P$ 个矩形障碍物。每个矩形障碍物用 $U$、$D$、$L$、$R$ 来表示，即在第 $U$ 行到第 $D$ 行以及在第 $L$ 列到第 $R$ 列之间的所有格子都变成了障碍物。小 H 保证所有矩形障碍物互不相交，并且所有非障碍物格子之间都能够直接或者间接互达，若两个非障碍物格子有公共边，那么它们直接互达并且它们的距离为 $1$。\n\n现在每一局游戏中，小 F 在棋盘中挑选一个非障碍物格子 $X$，小 H 也挑另外一个非障碍物格子 $Y$，这一局游戏 $(X,Y)$ 的得分就是 $X$ 到 $Y$ 的最短路径。小 F 需要计算出所有可能的游戏中的得分和，答案模 $1,000,000,007$。注意两局游戏中只要挑选的两个格子相同则视为同一局游戏，即 $(X, Y)$ 等同于 $(Y,X)$。", "inputFormat": "第一行三个整数 $N$（$1 \\le N \\le 1,000,000,000$），$M$（$1 \\le M \\le 1,000,000,000$），$P$（$0 \\le P \\le 100,000$）。  \n接下来有 $P$ 行，每行四个正整数，$U_i, D_i$（$1 < U_i \\le D_i < N$），$L_i, R_i$（$1 < L_i \\le R_i < M$），表示第 $i$ 个矩形障碍物。对于任意两个不同的矩形障碍物 $i$ 和 $j$，都满足 $D_i + 1 < U_j$ 或者 $D_j + 1 < U_i$，以及 $R_i + 1 < L_j$ 或者 $R_j + 1 < L_i$。", "outputFormat": "只有一行一个正整数，即所有游戏的得分和模 $1,000,000,007$。", "hint": "**【样例解释 #1】**\n\n距离为 $1$ 的有 $8$ 种。  \n距离为 $2$ 的有 $8$ 种。  \n距离为 $3$ 的有 $8$ 种。  \n距离为 $4$ 的有 $4$ 种。  \n总共得分为 $64$。\n\n**【题目来源】**\n\n来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。\n\n题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。", "locale": "zh-CN"}}}
{"pid": "P7137", "type": "P", "difficulty": 5, "samples": [["4 3\n4 3 2 1\n", "5.250000\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "Special Judge", "THUPC"], "title": "[THUPC 2021 初赛] 切切糕", "background": "", "description": "Kiana 喜欢吃甜点，某天她从商店中买回来 $N$ 块切糕与 Tinytree 共同分享，其中第 $i$ 块切糕的大小用一个数 $A_i$ 来表示。\n\n因为每块切糕的风味都不同，所以 Kiana 和 Tinytree 决定将每块切糕都切成两份，两人各选一份品尝。但切切糕是一个自古以来的大难题，经过商议，Kiana 打算执刀来切切糕，而 Tinytree 有 $M$ 次“优先选糕权”，可以获得一些切糕切开后的优先选择权，具体来说，两人按照如下流程进行操作：\n\n步骤一：Kiana 从还没切的切糕中按自己的想法选一块出来，并将其切成两份，其中**每份切糕的大小可以是任意正实数，也可以是 $\\mathbf{0}$，且两份切糕的大小之和与切之前的大小相同**。\n\n步骤二：Tinytree 观察完 Kiana 切出的两份切糕大小后，如果还有“优先选糕权”次数剩余，则可以决定是否消耗 $1$ 次“优先选糕权”来进行优先选择。\n\n步骤三：如果 Tinytree 选择使用“优先选糕权”，则她可以从两份切糕中任选一份，另一份则归 Kiana，如果 Tinytree 选择不使用或者已经用完了 $M$ 次“优先选糕权”，则 Kiana 从两份切糕中任选一份，另一份则归 Tinytree，然后两人回到步骤一，直到所有的切糕都切完。\n\n假设 Kiana 和 Tinytree 都足够聪明，在自己可以操作时总是想办法**让自己最终获得的切糕总大小尽可能大**，且开始切第一块切糕之前 $N$ 块切糕的大小是两人都已知的，“优先选糕权”不要求全部用完。现在 Kiana 想知道，自己能获得的切糕总大小是多少，由于 Kiana 自己不会算，所以希望你能够帮助她。", "inputFormat": "第一行包含两个正整数 $N$ 和 $M$（$1 \\le M \\le N \\le 2500$），分别表示切糕的总数和 Tinytree 初始时“优先选糕权”的次数。  \n第二行包含 $N$ 个正整数，其中第 $i$ 个数 $A_i$（$1 \\le A_i \\le 50000$）表示第 $i$ 块切糕的大小。", "outputFormat": "输出共一行，包含一个实数，表示**Kiana 最终能获得的切糕总大小**，所有输出精确到小数点后六位。", "hint": "**【样例解释 #1】**\n\n在这个样例中总共有 $4$ 块切糕，大小分别为 $4,3,2,1$，Tinytree 的“优先选糕权”一共有三次，两人可以按照如下顺序和方式来分配切糕：\n\n第一块：Kiana 选择大小为 $3$ 的切糕，将其切成大小为 $1.25$ 和 $1.75$ 的两部分，Tinytree 使用一次“优先选糕权”选走 $1.75$ 的部分，Kiana 目前总共获得大小 $1.25$ 的切糕。\n\n第二块：Kiana 选择大小为 $1$ 的切糕，将其切成大小为 $0$ 和 $1$ 的两部分，Tinytree 不使用“优先选糕权”，Kiana 独得此糕，目前总共获得大小 $2.25$ 的切糕。\n\n第三块：Kiana 选择大小为 $2$ 的切糕，将其切成大小为 $1$ 和 $1$ 的两部分，Tinytree 使用一次“优先选糕权”选走 $1$ 的部分，Kiana 目前总共获得大小 $3.25$ 的切糕。\n\n第四块：Kiana 选择大小为 $4$ 的切糕，将其切成大小为 $2$ 和 $2$ 的两部分，Tinytree 使用一次“优先选糕权”选走 $2$ 的部分，Kiana 目前总共获得大小 $5.25$ 的切糕。\n\n综上所述，该样例输出 $5.250000$，且可以证明在这个方案中如果任意一人改变自己的策略，其获得的切糕总大小不可能变得更大。\n\n**【题目来源】**\n\n来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。\n\n题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2021 初赛] 切切糕", "background": "", "description": "Kiana 喜欢吃甜点，某天她从商店中买回来 $N$ 块切糕与 Tinytree 共同分享，其中第 $i$ 块切糕的大小用一个数 $A_i$ 来表示。\n\n因为每块切糕的风味都不同，所以 Kiana 和 Tinytree 决定将每块切糕都切成两份，两人各选一份品尝。但切切糕是一个自古以来的大难题，经过商议，Kiana 打算执刀来切切糕，而 Tinytree 有 $M$ 次“优先选糕权”，可以获得一些切糕切开后的优先选择权，具体来说，两人按照如下流程进行操作：\n\n步骤一：Kiana 从还没切的切糕中按自己的想法选一块出来，并将其切成两份，其中**每份切糕的大小可以是任意正实数，也可以是 $\\mathbf{0}$，且两份切糕的大小之和与切之前的大小相同**。\n\n步骤二：Tinytree 观察完 Kiana 切出的两份切糕大小后，如果还有“优先选糕权”次数剩余，则可以决定是否消耗 $1$ 次“优先选糕权”来进行优先选择。\n\n步骤三：如果 Tinytree 选择使用“优先选糕权”，则她可以从两份切糕中任选一份，另一份则归 Kiana，如果 Tinytree 选择不使用或者已经用完了 $M$ 次“优先选糕权”，则 Kiana 从两份切糕中任选一份，另一份则归 Tinytree，然后两人回到步骤一，直到所有的切糕都切完。\n\n假设 Kiana 和 Tinytree 都足够聪明，在自己可以操作时总是想办法**让自己最终获得的切糕总大小尽可能大**，且开始切第一块切糕之前 $N$ 块切糕的大小是两人都已知的，“优先选糕权”不要求全部用完。现在 Kiana 想知道，自己能获得的切糕总大小是多少，由于 Kiana 自己不会算，所以希望你能够帮助她。", "inputFormat": "第一行包含两个正整数 $N$ 和 $M$（$1 \\le M \\le N \\le 2500$），分别表示切糕的总数和 Tinytree 初始时“优先选糕权”的次数。  \n第二行包含 $N$ 个正整数，其中第 $i$ 个数 $A_i$（$1 \\le A_i \\le 50000$）表示第 $i$ 块切糕的大小。", "outputFormat": "输出共一行，包含一个实数，表示**Kiana 最终能获得的切糕总大小**，所有输出精确到小数点后六位。", "hint": "**【样例解释 #1】**\n\n在这个样例中总共有 $4$ 块切糕，大小分别为 $4,3,2,1$，Tinytree 的“优先选糕权”一共有三次，两人可以按照如下顺序和方式来分配切糕：\n\n第一块：Kiana 选择大小为 $3$ 的切糕，将其切成大小为 $1.25$ 和 $1.75$ 的两部分，Tinytree 使用一次“优先选糕权”选走 $1.75$ 的部分，Kiana 目前总共获得大小 $1.25$ 的切糕。\n\n第二块：Kiana 选择大小为 $1$ 的切糕，将其切成大小为 $0$ 和 $1$ 的两部分，Tinytree 不使用“优先选糕权”，Kiana 独得此糕，目前总共获得大小 $2.25$ 的切糕。\n\n第三块：Kiana 选择大小为 $2$ 的切糕，将其切成大小为 $1$ 和 $1$ 的两部分，Tinytree 使用一次“优先选糕权”选走 $1$ 的部分，Kiana 目前总共获得大小 $3.25$ 的切糕。\n\n第四块：Kiana 选择大小为 $4$ 的切糕，将其切成大小为 $2$ 和 $2$ 的两部分，Tinytree 使用一次“优先选糕权”选走 $2$ 的部分，Kiana 目前总共获得大小 $5.25$ 的切糕。\n\n综上所述，该样例输出 $5.250000$，且可以证明在这个方案中如果任意一人改变自己的策略，其获得的切糕总大小不可能变得更大。\n\n**【题目来源】**\n\n来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。\n\n题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。", "locale": "zh-CN"}}}
{"pid": "P7138", "type": "P", "difficulty": 7, "samples": [["2 2 4\n3\n2.571 0.514 + 2.571 -0.514 +\n-2.571 0.514 + -2.571 -0.514 +\n0.514 2.571 + -0.514 2.571 +\n0.514 -2.571 + -0.514 -2.571 +\n2.118 -2.118 -\n1.051 1.051 +\n-0.468 1.870 +\n-1.870 -0.468 +\n", "Passer\nSafe\nGoodbye\nSafe\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "THUPC"], "title": "[THUPC 2021 初赛] 非欧几何", "background": "", "description": "ustze 喜欢几何，他认为几何是数学竞赛中最简单的一环，在征服了数学以后，ustze 决定将自己的天赋带到计算几何中，并与传统的欧氏几何展开较量。\n\n作为欧氏几何的捍卫者，Tinytree 在三维空间中建立了一个**球心在原点、半径为** $\\boldsymbol R$ **的球面**，其中坐标为 $(0,0,R)$ 的点称为北极点，显然北极点处于球面上。Tinytree 回忆在欧氏几何中，三点可以唯一确定空间中的一个圆，因此 Tinytree 在球面上确定了 $N$ 个点对，其中每个点对和北极点一起就确定了一个球面上的圆，我们保证这些圆的**半径严格小于** $\\boldsymbol R$，因此每个圆会将球面分成面积不相等的两部分，我们**称球面上面积较小的部分是该圆的内部，面积较大的部分是该圆的外部**，而这 $N$ 个圆的内部受到 Tinytree 的保护，**它们的并构成安全区域**。\n\n作为非欧几何的狂热者，ustze 认为球面上的圆其实是“直线”，他在球面上确定了 $M$ 个点对，其中每个点对和北极点一起也确定了一个球面上的圆，这些圆的**半径也是严格小于** $\\boldsymbol R$ 的，这 $M$ 个圆的内部受到 ustze 的威慑，**它们的并构成危险区域**。\n\n正当 Tinytree 和 ustze 对峙时，球面上一般路过一个 Kiana，她见到这幅景象十分害怕，开始在球面上东躲西藏。现在 Kiana 初步确定了 $T$ 个球面上的点，她想知道这些点是否在安全区域或危险区域中，以便自己跑路，由于 Kiana 自己不会算，所以希望你能够帮助她。", "inputFormat": "第一行包含三个正整数 $N, M$ 和 $T$（$1 \\le N, M \\le 5000$，$1 \\le T \\le 1.5 \\times {10}^5$），分别表示 Tinytree 确定的点对数、ustze 确定的点对数和 Kiana 确定的跑路点数。\n\n第二行包含一个正整数 $R$（$1 \\le R \\le {10}^3$），表示球面的半径大小。\n\n接下来 $N$ 行，第 $i$ 行依次输入 $A_i, B_i, X_i, C_i, D_i, Y_i$（$1 \\le |A_i|, |B_i|, |C_i|, |D_i| \\le R$，$1 \\le A_i^2 + B_i^2, C_i^2 + D_i^2 \\le R^2$），其中 $A_i, B_i$ 表示 Tinytree 确定的第 $i$ 个点对中第一个点的横坐标和纵坐标，而 $X_i$ 为 `+` 表示第一个点的竖坐标大于 $0$，为 `-` 表示第一个点的竖坐标小于 $0$，如果竖坐标等于 $0$ 则 $X_i$ 是在 `+` 和 `-` 中随机选择的，$C_i, D_i$ 表示 Tinytree 确定的第 $i$ 个点对中第二个点的横坐标和纵坐标，$Y_i$ 表示竖坐标的正负，含义与 $X_i$ 相同。\n\n接下来 $M$ 行，第 $j$ 行依次输入 $A_j, B_j, X_j, C_j, D_j, Y_j$（$1 \\le |A_j|, |B_j|, |C_j|, |D_j| \\le R$，$1 \\le A_j^2 + B_j^2, C_j^2 + D_j^2 \\le R^2$），表示 ustze 确定的第 $j$ 个点对坐标，点的表示方式与之前相同。\n\n接下来 $T$ 行，第 $k$ 行包含两个实数 $A_k, B_k$（$1 \\le |A_k|, |B_k| \\le R$，$1 \\le A_k^2 + B_k^2 \\le R^2$）和一个字符 $X_k$，表示 Kiana 确定的第 $k$ 个跑路点，点的表示方式与之前相同。\n\n数据保证合法，且输入中没有两个点是相同的，所有实数保留到小数点后三位，**Kiana 的跑路点和任意一个给定圆周的最小直线距离不小于** $\\boldsymbol{{10}^{-6}}$。", "outputFormat": "输出共 $T$ 行，每行包含一个字符串，若 Kiana 的第 $k$ 个跑路点在安全区域中则在第 $k$ 行输出 `Safe`，如果不在安全区域中但也不在危险区域中则在第 $k$ 行输出 `Passer`，如果不在安全区域中且在危险区域中则在第 $k$ 行输出 `Goodbye`（所有输出不含引号）。", "hint": "在三维空间中，我们可以用一个有序的实数三元组 $(x, y, z)$ 来描述一个点的位置，其中 $x, y, z$ 分别称作这个点的横坐标、纵坐标和竖坐标。\n\n三维空间中一个球心在 $(x_0, y_0, z_0)$、半径为 $R$ 的球面是指空间中所有满足 $(x - x_0)^2 + (y - y_0)^2 + (z - z_0)^2 = R^2$ 的点 $(x, y, z)$ 构成的点集，对于该球面上给定的两个不同点 $(x_1, y_1, z_1), (x_2, y_2, z_2)$，如果它们不是一对对踵点（两个点是对踵点当且仅当它们之间的距离为 $2 R$），则它们和球心不在同一直线上，这三个点唯一确定了一个平面，这个平面与球面的交线被这两个点分成了两个部分，其中较短部分的长度称为这两点在该球面上的距离，如果这两个点是对踵点，则定义它们之间的距离为 $\\pi R$，球面上的一个圆指到球面上某点的球面距离等于一个常数的球面上的点的集合，可以证明球面上的任意三个不同点唯一确定了一个球面上的圆。\n\n**【题目来源】**\n\n来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。\n\n题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2021 初赛] 非欧几何", "background": "", "description": "ustze 喜欢几何，他认为几何是数学竞赛中最简单的一环，在征服了数学以后，ustze 决定将自己的天赋带到计算几何中，并与传统的欧氏几何展开较量。\n\n作为欧氏几何的捍卫者，Tinytree 在三维空间中建立了一个**球心在原点、半径为** $\\boldsymbol R$ **的球面**，其中坐标为 $(0,0,R)$ 的点称为北极点，显然北极点处于球面上。Tinytree 回忆在欧氏几何中，三点可以唯一确定空间中的一个圆，因此 Tinytree 在球面上确定了 $N$ 个点对，其中每个点对和北极点一起就确定了一个球面上的圆，我们保证这些圆的**半径严格小于** $\\boldsymbol R$，因此每个圆会将球面分成面积不相等的两部分，我们**称球面上面积较小的部分是该圆的内部，面积较大的部分是该圆的外部**，而这 $N$ 个圆的内部受到 Tinytree 的保护，**它们的并构成安全区域**。\n\n作为非欧几何的狂热者，ustze 认为球面上的圆其实是“直线”，他在球面上确定了 $M$ 个点对，其中每个点对和北极点一起也确定了一个球面上的圆，这些圆的**半径也是严格小于** $\\boldsymbol R$ 的，这 $M$ 个圆的内部受到 ustze 的威慑，**它们的并构成危险区域**。\n\n正当 Tinytree 和 ustze 对峙时，球面上一般路过一个 Kiana，她见到这幅景象十分害怕，开始在球面上东躲西藏。现在 Kiana 初步确定了 $T$ 个球面上的点，她想知道这些点是否在安全区域或危险区域中，以便自己跑路，由于 Kiana 自己不会算，所以希望你能够帮助她。", "inputFormat": "第一行包含三个正整数 $N, M$ 和 $T$（$1 \\le N, M \\le 5000$，$1 \\le T \\le 1.5 \\times {10}^5$），分别表示 Tinytree 确定的点对数、ustze 确定的点对数和 Kiana 确定的跑路点数。\n\n第二行包含一个正整数 $R$（$1 \\le R \\le {10}^3$），表示球面的半径大小。\n\n接下来 $N$ 行，第 $i$ 行依次输入 $A_i, B_i, X_i, C_i, D_i, Y_i$（$1 \\le |A_i|, |B_i|, |C_i|, |D_i| \\le R$，$1 \\le A_i^2 + B_i^2, C_i^2 + D_i^2 \\le R^2$），其中 $A_i, B_i$ 表示 Tinytree 确定的第 $i$ 个点对中第一个点的横坐标和纵坐标，而 $X_i$ 为 `+` 表示第一个点的竖坐标大于 $0$，为 `-` 表示第一个点的竖坐标小于 $0$，如果竖坐标等于 $0$ 则 $X_i$ 是在 `+` 和 `-` 中随机选择的，$C_i, D_i$ 表示 Tinytree 确定的第 $i$ 个点对中第二个点的横坐标和纵坐标，$Y_i$ 表示竖坐标的正负，含义与 $X_i$ 相同。\n\n接下来 $M$ 行，第 $j$ 行依次输入 $A_j, B_j, X_j, C_j, D_j, Y_j$（$1 \\le |A_j|, |B_j|, |C_j|, |D_j| \\le R$，$1 \\le A_j^2 + B_j^2, C_j^2 + D_j^2 \\le R^2$），表示 ustze 确定的第 $j$ 个点对坐标，点的表示方式与之前相同。\n\n接下来 $T$ 行，第 $k$ 行包含两个实数 $A_k, B_k$（$1 \\le |A_k|, |B_k| \\le R$，$1 \\le A_k^2 + B_k^2 \\le R^2$）和一个字符 $X_k$，表示 Kiana 确定的第 $k$ 个跑路点，点的表示方式与之前相同。\n\n数据保证合法，且输入中没有两个点是相同的，所有实数保留到小数点后三位，**Kiana 的跑路点和任意一个给定圆周的最小直线距离不小于** $\\boldsymbol{{10}^{-6}}$。", "outputFormat": "输出共 $T$ 行，每行包含一个字符串，若 Kiana 的第 $k$ 个跑路点在安全区域中则在第 $k$ 行输出 `Safe`，如果不在安全区域中但也不在危险区域中则在第 $k$ 行输出 `Passer`，如果不在安全区域中且在危险区域中则在第 $k$ 行输出 `Goodbye`（所有输出不含引号）。", "hint": "在三维空间中，我们可以用一个有序的实数三元组 $(x, y, z)$ 来描述一个点的位置，其中 $x, y, z$ 分别称作这个点的横坐标、纵坐标和竖坐标。\n\n三维空间中一个球心在 $(x_0, y_0, z_0)$、半径为 $R$ 的球面是指空间中所有满足 $(x - x_0)^2 + (y - y_0)^2 + (z - z_0)^2 = R^2$ 的点 $(x, y, z)$ 构成的点集，对于该球面上给定的两个不同点 $(x_1, y_1, z_1), (x_2, y_2, z_2)$，如果它们不是一对对踵点（两个点是对踵点当且仅当它们之间的距离为 $2 R$），则它们和球心不在同一直线上，这三个点唯一确定了一个平面，这个平面与球面的交线被这两个点分成了两个部分，其中较短部分的长度称为这两点在该球面上的距离，如果这两个点是对踵点，则定义它们之间的距离为 $\\pi R$，球面上的一个圆指到球面上某点的球面距离等于一个常数的球面上的点的集合，可以证明球面上的任意三个不同点唯一确定了一个球面上的圆。\n\n**【题目来源】**\n\n来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。\n\n题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。", "locale": "zh-CN"}}}
{"pid": "P7140", "type": "P", "difficulty": 5, "samples": [["5\n2 2 1 2 1\n4\n1 5 4\n2 2 1\n2 1 1\n1 5 5\n", "2\n22\n24\n1\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2021", "THUPC"], "title": "[THUPC 2021 初赛] 区间矩阵乘法", "background": "", "description": "给定长度为 $n$ 的序列 $a_1, a_2, \\dots, a_n$；共 $m$ 组询问，每次询问给出 $d,p_1,p_2$，求\n\n$$ \\sum_{i=0}^{d-1} \\sum_{j=0}^{d-1} \\sum_{k=0}^{d-1} a_{p_1+d\\cdot i+j} a_{p_2 + d\\cdot j + k} $$", "inputFormat": "输入的第一行包含一个数 $n$。  \n之后一行 $n$ 个数，表示 $a$ 这个序列。  \n之后一行一个数 $m$。  \n之后 $m$ 行，每行三个数 $d, p_1, p_2$ 表示一次询问。\n\n$1 \\le n, m, a_i \\le 2 \\times {10}^5$，所有数值为 $[1,{10}^9]$ 以内的整数，询问保证 $a$ 的下标在 $[1,n]$ 内。", "outputFormat": "输出共 $m$ 行，表示每个询问对应的答案，答案对 $2^{32}$ 取模。", "hint": "**【题目来源】**\n\n来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。\n\n题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2021 初赛] 区间矩阵乘法", "background": "", "description": "给定长度为 $n$ 的序列 $a_1, a_2, \\dots, a_n$；共 $m$ 组询问，每次询问给出 $d,p_1,p_2$，求\n\n$$ \\sum_{i=0}^{d-1} \\sum_{j=0}^{d-1} \\sum_{k=0}^{d-1} a_{p_1+d\\cdot i+j} a_{p_2 + d\\cdot j + k} $$", "inputFormat": "输入的第一行包含一个数 $n$。  \n之后一行 $n$ 个数，表示 $a$ 这个序列。  \n之后一行一个数 $m$。  \n之后 $m$ 行，每行三个数 $d, p_1, p_2$ 表示一次询问。\n\n$1 \\le n, m, a_i \\le 2 \\times {10}^5$，所有数值为 $[1,{10}^9]$ 以内的整数，询问保证 $a$ 的下标在 $[1,n]$ 内。", "outputFormat": "输出共 $m$ 行，表示每个询问对应的答案，答案对 $2^{32}$ 取模。", "hint": "**【题目来源】**\n\n来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。\n\n题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。", "locale": "zh-CN"}}}
{"pid": "P7141", "type": "P", "difficulty": 6, "samples": [["3 4\n2 1 2 1\n", "Yes\n1010\n0101\n1010\n"], ["3 4\n2 3 3 3\n", "No\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "Special Judge", "THUPC"], "title": "[THUPC 2021 初赛] 棋盘", "background": "", "description": "有一个 $n$ 行 $m$ 列的棋盘，共有 $n m$ 个格子。请你在格子内放入棋子（每个格子可以放入至多一个棋子），使得对于所有 $1 \\le i \\le m$，第 $i$ 列里恰好包含 $a_i$ 个棋子。另外，棋盘上的任意两颗棋子都不能边相邻。\n\n请判断是否存在一种合法方案。如果存在，请输出任意一个合法方案。", "inputFormat": "输入的第一行包含两个正整数 $n, m$，保证 $n \\le 300, m \\le 300$。  \n输入的第二行包含 $m$ 个非负整数 $a_1, a_2, \\ldots , a_m$，保证 $0 \\le a_i \\le n$。", "outputFormat": "如果无解，输出一个字符串 `No`。  \n如果有解，第一行输出一个字符串 `Yes`，接下来 $n$ 行每行输出一个长度为 $m$ 的字符串，表示你构造的棋盘方案。其中 `0` 表示空格，`1` 表示放入棋子的格子。", "hint": "**【题目来源】**\n\n来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。\n\n题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2021 初赛] 棋盘", "background": "", "description": "有一个 $n$ 行 $m$ 列的棋盘，共有 $n m$ 个格子。请你在格子内放入棋子（每个格子可以放入至多一个棋子），使得对于所有 $1 \\le i \\le m$，第 $i$ 列里恰好包含 $a_i$ 个棋子。另外，棋盘上的任意两颗棋子都不能边相邻。\n\n请判断是否存在一种合法方案。如果存在，请输出任意一个合法方案。", "inputFormat": "输入的第一行包含两个正整数 $n, m$，保证 $n \\le 300, m \\le 300$。  \n输入的第二行包含 $m$ 个非负整数 $a_1, a_2, \\ldots , a_m$，保证 $0 \\le a_i \\le n$。", "outputFormat": "如果无解，输出一个字符串 `No`。  \n如果有解，第一行输出一个字符串 `Yes`，接下来 $n$ 行每行输出一个长度为 $m$ 的字符串，表示你构造的棋盘方案。其中 `0` 表示空格，`1` 表示放入棋子的格子。", "hint": "**【题目来源】**\n\n来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。\n\n题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。", "locale": "zh-CN"}}}
{"pid": "P7142", "type": "P", "difficulty": 6, "samples": [["3 1\n1 2 1 2\n2 1 1 2\n1 3 1 3\n3 1 2 3\n2 3 3 4\n3 2 2 5\n", "166374059\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "THUPC", "状压 DP"], "title": "[THUPC 2021 初赛] 密集子图", "background": "", "description": "有一天，魔法师小 L 看到了一个有向完全图。\n\n图中所有边的长度都是 $1$，且所有边都是白色的。\n\n现在小 L 要对这个图施展魔法，图中每条有向边分别都有一定概率变成黑色。\n\n小 L 认为一个图是“密集的”，当且仅当只经过黑色边时，点 $1$ 到其余所有点的最短路径长度都不超过 $k$（特别地，若两个点不连通则它们之间最短路径的长度视为 $+ \\infty$）。\n\n小 L 想要知道，此时这个有向完全图有多大的概率是“密集的”呢？请你输出此概率对 $998,244,353$ 取模的结果。", "inputFormat": "第一行两个正整数 $n$（$2 \\le n \\le 12)$，$k$（$1 \\le k \\le n - 1$）。  \n接下来 $n \\times (n - 1)$ 行，每行 $4$ 个正整数 $x, y, p, q$，表示点 $x$ 到点 $y$ 的有向边变成黑色的概率为 $\\frac{p}{q}$。保证 $1 \\le x \\le n$，$1 \\le y \\le n$，$x \\ne y$，$0 \\le p \\le q < 998,244,353$，$q > 0$，每组合法的 $(x, y)$ 恰好出现一次。", "outputFormat": "一行一个整数表示答案。", "hint": "**【样例解释 #1】**\n\n这个有向完全图是“密集的”，当且仅当点 $1$ 到点 $2$ 的有向边和点 $1$ 到点 $3$ 的有向边同时变成黑色，这种情况出现的概率 $= \\frac{1}{2} \\times \\frac{1}{3} = \\frac{1}{6}$，$\\frac{1}{6} \\bmod 998,244,353 = 6^{998,244,351} \\bmod 998,244,353 = 166,374,059$。\n\n**【题目来源】**\n\n来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。\n\n题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2021 初赛] 密集子图", "background": "", "description": "有一天，魔法师小 L 看到了一个有向完全图。\n\n图中所有边的长度都是 $1$，且所有边都是白色的。\n\n现在小 L 要对这个图施展魔法，图中每条有向边分别都有一定概率变成黑色。\n\n小 L 认为一个图是“密集的”，当且仅当只经过黑色边时，点 $1$ 到其余所有点的最短路径长度都不超过 $k$（特别地，若两个点不连通则它们之间最短路径的长度视为 $+ \\infty$）。\n\n小 L 想要知道，此时这个有向完全图有多大的概率是“密集的”呢？请你输出此概率对 $998,244,353$ 取模的结果。", "inputFormat": "第一行两个正整数 $n$（$2 \\le n \\le 12)$，$k$（$1 \\le k \\le n - 1$）。  \n接下来 $n \\times (n - 1)$ 行，每行 $4$ 个正整数 $x, y, p, q$，表示点 $x$ 到点 $y$ 的有向边变成黑色的概率为 $\\frac{p}{q}$。保证 $1 \\le x \\le n$，$1 \\le y \\le n$，$x \\ne y$，$0 \\le p \\le q < 998,244,353$，$q > 0$，每组合法的 $(x, y)$ 恰好出现一次。", "outputFormat": "一行一个整数表示答案。", "hint": "**【样例解释 #1】**\n\n这个有向完全图是“密集的”，当且仅当点 $1$ 到点 $2$ 的有向边和点 $1$ 到点 $3$ 的有向边同时变成黑色，这种情况出现的概率 $= \\frac{1}{2} \\times \\frac{1}{3} = \\frac{1}{6}$，$\\frac{1}{6} \\bmod 998,244,353 = 6^{998,244,351} \\bmod 998,244,353 = 166,374,059$。\n\n**【题目来源】**\n\n来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。\n\n题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。", "locale": "zh-CN"}}}
{"pid": "P7143", "type": "P", "difficulty": 5, "samples": [["1\n3\n", "7\n"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["2021", "THUPC"], "title": "[THUPC 2021 初赛] 线段树", "background": "", "description": "线段树是小 L 最喜欢的数据结构，它能高效地解决许多实际问题。\n\n给定一个正整数 $n$，小 L 构建出一棵下标属于整数区间 $[1, n]$ 的线段树：\n\n- 初始线段树只有一个结点 $[1, n]$。\n- 对于结点 $[L, R]$，若 $L < R$，则令 $mid = \\left[ \\frac{L + R}{2} \\right]$（$[x]$ 表示不超过 $x$ 的最大整数），小 L 对这个结点建出两个子结点 $[L, mid]$、$[mid + 1, R]$。\n\n小 L 定义了一个函数 $cover(a, b)$（$1 \\le a \\le b \\le n$），表示用若干个线段树结点不重不漏地覆盖区间 $[a, b]$，则使用的线段树结点个数的最小值。\n\n小 L 尝试使用这棵线段树解决某个复杂问题，并想要粗略地评估这棵线段树的性能。\n\n具体来说，区间 $[1, n]$ 有 $\\frac{n (n + 1)}{2}$ 个不同的子区间，如果小 L 从这 $\\frac{n (n + 1)}{2}$ 个子区间中等概率随机地选取一个，将其记为 $[A, B]$，则小 L 认为 $cover(A, B)$ 的期望值可用于评估此线段树的性能。\n\n小 L 想请你帮他计算出 $cover(A, B)$ 的期望值与 $\\frac{n (n + 1)}{2}$ 的乘积对 $1, 000, 000, 007$ 取模的结果，可以发现此结果一定是一个整数。", "inputFormat": "第一行一个正整数 $T$（$1 \\le T \\le 1000$）表示数据组数。  \n接下来 $T$ 行，其中第 $i$（$1 \\le i \\le T$）行一个正整数 $n$（$1 \\le n \\le {10}^{18}$）表示第 $i$ 组数据。", "outputFormat": "$T$ 行，第 $i$（$1 \\le i \\le T$）行一个整数表示第 i 组数据的答案。", "hint": "**【样例解释 #1】**\n\n$cover(1, 1) = 1$，$cover(2, 2) = 1$，$cover(3, 3) = 1$，$cover(1, 2) = 1$，$cover(2, 3) = 2$，$cover(1, 3) = 1$，故 $cover(A, B)$ 的期望 $= \\frac{1 + 1 + 1 + 1 + 2 + 1}{6} = \\frac{7}{6}$。\n\n**【题目来源】**\n\n来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。\n\n题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2021 初赛] 线段树", "background": "", "description": "线段树是小 L 最喜欢的数据结构，它能高效地解决许多实际问题。\n\n给定一个正整数 $n$，小 L 构建出一棵下标属于整数区间 $[1, n]$ 的线段树：\n\n- 初始线段树只有一个结点 $[1, n]$。\n- 对于结点 $[L, R]$，若 $L < R$，则令 $mid = \\left[ \\frac{L + R}{2} \\right]$（$[x]$ 表示不超过 $x$ 的最大整数），小 L 对这个结点建出两个子结点 $[L, mid]$、$[mid + 1, R]$。\n\n小 L 定义了一个函数 $cover(a, b)$（$1 \\le a \\le b \\le n$），表示用若干个线段树结点不重不漏地覆盖区间 $[a, b]$，则使用的线段树结点个数的最小值。\n\n小 L 尝试使用这棵线段树解决某个复杂问题，并想要粗略地评估这棵线段树的性能。\n\n具体来说，区间 $[1, n]$ 有 $\\frac{n (n + 1)}{2}$ 个不同的子区间，如果小 L 从这 $\\frac{n (n + 1)}{2}$ 个子区间中等概率随机地选取一个，将其记为 $[A, B]$，则小 L 认为 $cover(A, B)$ 的期望值可用于评估此线段树的性能。\n\n小 L 想请你帮他计算出 $cover(A, B)$ 的期望值与 $\\frac{n (n + 1)}{2}$ 的乘积对 $1, 000, 000, 007$ 取模的结果，可以发现此结果一定是一个整数。", "inputFormat": "第一行一个正整数 $T$（$1 \\le T \\le 1000$）表示数据组数。  \n接下来 $T$ 行，其中第 $i$（$1 \\le i \\le T$）行一个正整数 $n$（$1 \\le n \\le {10}^{18}$）表示第 $i$ 组数据。", "outputFormat": "$T$ 行，第 $i$（$1 \\le i \\le T$）行一个整数表示第 i 组数据的答案。", "hint": "**【样例解释 #1】**\n\n$cover(1, 1) = 1$，$cover(2, 2) = 1$，$cover(3, 3) = 1$，$cover(1, 2) = 1$，$cover(2, 3) = 2$，$cover(1, 3) = 1$，故 $cover(A, B)$ 的期望 $= \\frac{1 + 1 + 1 + 1 + 2 + 1}{6} = \\frac{7}{6}$。\n\n**【题目来源】**\n\n来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。\n\n题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。", "locale": "zh-CN"}}}
{"pid": "P7144", "type": "P", "difficulty": 6, "samples": [["1 5\n1 1\n0\n0\n0 1\n", "0.500000000\n"], ["1 4\n5 14\n1 1\n1 1\n1 0\n", "0.041879441\n"]], "limits": {"time": [20000, 20000, 20000, 20000, 20000, 20000], "memory": [2048000, 2048000, 2048000, 2048000, 2048000, 2048000]}, "tags": ["模拟", "2021", "Special Judge", "THUPC"], "title": "[THUPC 2021 初赛] 狗蛋和二五仔", "background": "**那女孩对我说**  \n**代价为十辆铲车**", "description": "小 E 喜欢和老师变换着花样玩牌。最近，他们又发明了一种叫做“狗蛋和二五仔”的玩法。\n\n规则是这样的：\n\n游戏开始时小 E 和老师各有 $30$ 点体力值，手上各有 $2$ 张牌。所有的牌是完全相同的。每个玩家的面前都可以放置牌，开始时双方面前没有任何牌。\n\n双方轮流进行操作。玩家在每个自己的回合开始时先抽一张牌。“抽一张牌”的操作指的是，如果手上的牌的数量小于 $3$ 张，则再抓一张牌放在手上；如果手上恰好有 $3$ 张牌，则不能再抓牌。操作分为 $4$ 种类型。\n\n- 技能。让自己的体力值 $- 2$，然后抽一张牌。\n- 攻击。具体地，玩家可以选择一张放在自己面前的**本回合还未攻击过**的牌，选择对方面前的一张牌同归于尽，或者选择一张放在自己面前的**本回合还未攻击过**的牌，让对方的体力值 $- 3$。如果是后者，则将这张选择的牌标记为已攻击。\n- 打牌。如果你面前的牌的数量小于 $4$ 张，且手上有牌才能进行此操作。先进行下面的过程 $3$ 次：\n  - 随机选择一个角色，让它的体力值 $- 1$。这个角色可以是自己、对方或者某一方面前的一张牌。如果双方场上的牌一共有 $k$ 张，那么选择到任何一个角色的概率为 $\\frac{1}{k + 2}$。如果该角色是一张牌且体力值变为了 $0$，那么将它摧毁；如果该角色是一个玩家且体力值变为了 $0$，那么该玩家直接输掉游戏。\n  \n  在进行完 $3$ 次后将手上的一张牌放在自己面前。牌的体力值为 $2$。这张牌在本回合中被认为已攻击过。\n- 结束回合，接下来轮到对方的回合。\n\n一回合中，玩家可以进行多次操作，但是技能和打牌的操作次数**之和**不能超过 $O$。除了结束回合，这些操作没有顺序限制，比如你可以先打一张牌，然后使用技能，然后再打一张牌。在结束回合之前，玩家需要进行至少一次任意的操作才能结束回合。\n\n在任何时刻如果有玩家的体力值小于或等于 $0$，那么该玩家输掉游戏。\n\n游戏进行了几个回合后，现在轮到了小 E 的回合开始前。小 E 想让你帮他分析，如果双方都采用最优策略，那么现在自己赢的概率是多少。", "inputFormat": "第一行一个正整数 $T, O$，分别表示数据组数和每回合中技能和打牌的操作次数上限。  \n对于每组数据，第一行两个正整数 $E, S$，分别表示小 E 和老师现在的体力值。保证 $1 \\le E, S \\le 20$。  \n第二行一个非负整数 $c$，然后跟着 $c$ 个正整数 $a_1, \\ldots , a_c$，表示老师面前有 $c$ 张牌，它们的体力值分别为 $a_1, \\ldots , a_c$。保证 $0 \\le c \\le 4$，$1 \\le a_i \\le 2$。  \n第三行一个非负整数 $p$，然后跟着 $p$ 个正整数 $e_1, \\ldots , e_p$，表示小 E 面前有 $p$ 张牌，\n它们的体力值分别为 $e_1, \\ldots , e_p$。保证 $0 \\le p \\le 4$，$1 \\le e_i \\le 2$。  \n第四行两个 $[0, 3]$ 之间的非负整数，分别表示老师和小 E 的手牌数。  \n在你到来之前老师可能作了弊，你不需要判断输入的情况是否真的是游戏进行了几个回合后的情况。", "outputFormat": "对于每组数据输出一行一个实数，表示小 E 在双方采用最优决策时获胜的概率。你的输出的和标准答案的绝对误差不超过 ${10}^{-6}$ 时算作正确。", "hint": "**【样例解释 #1】**\n\n回合开始，小 E 抽一张牌。此时小 E 手上有 $2$ 张牌，老师手上没有牌，双方的面前都没有牌。双方的体力值均为 $1$。这时，最优策略下，小 E 不能使用技能，因为使用后会因为自己的体力值小于等于 $0$ 而输掉游戏；小 E 不能攻击，因为自己面前没有牌；小 E 也不能结束回合，因为本回合他还没有进行任何操作。所以小 E 的最优策略是打一张牌，这时会随机选到小 E 或者老师中的一个角色，让他体力值 $- 1$ 然后输掉游戏。所以小 E 的获胜概率为 $0.5$。\n\n**【子任务】**\n\n保证 $1\\le T\\le 351493,3\\le O \\le 5$ 。\n\n**【后记】**\n\n最后小 E 还是战胜了老师。\n\n**“老师你术士玩多了就知道怎么玩了，你打得还不够多。”**\n\n**“吹牛现在都流行这么吹的吗？兄弟你知道我术士多少胜场嘛，啊？我跟你说全世界没有一个人术士比我胜场多的。”**\n\n**【题目来源】**\n\n来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。\n\n题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2021 初赛] 狗蛋和二五仔", "background": "**那女孩对我说**  \n**代价为十辆铲车**", "description": "小 E 喜欢和老师变换着花样玩牌。最近，他们又发明了一种叫做“狗蛋和二五仔”的玩法。\n\n规则是这样的：\n\n游戏开始时小 E 和老师各有 $30$ 点体力值，手上各有 $2$ 张牌。所有的牌是完全相同的。每个玩家的面前都可以放置牌，开始时双方面前没有任何牌。\n\n双方轮流进行操作。玩家在每个自己的回合开始时先抽一张牌。“抽一张牌”的操作指的是，如果手上的牌的数量小于 $3$ 张，则再抓一张牌放在手上；如果手上恰好有 $3$ 张牌，则不能再抓牌。操作分为 $4$ 种类型。\n\n- 技能。让自己的体力值 $- 2$，然后抽一张牌。\n- 攻击。具体地，玩家可以选择一张放在自己面前的**本回合还未攻击过**的牌，选择对方面前的一张牌同归于尽，或者选择一张放在自己面前的**本回合还未攻击过**的牌，让对方的体力值 $- 3$。如果是后者，则将这张选择的牌标记为已攻击。\n- 打牌。如果你面前的牌的数量小于 $4$ 张，且手上有牌才能进行此操作。先进行下面的过程 $3$ 次：\n  - 随机选择一个角色，让它的体力值 $- 1$。这个角色可以是自己、对方或者某一方面前的一张牌。如果双方场上的牌一共有 $k$ 张，那么选择到任何一个角色的概率为 $\\frac{1}{k + 2}$。如果该角色是一张牌且体力值变为了 $0$，那么将它摧毁；如果该角色是一个玩家且体力值变为了 $0$，那么该玩家直接输掉游戏。\n  \n  在进行完 $3$ 次后将手上的一张牌放在自己面前。牌的体力值为 $2$。这张牌在本回合中被认为已攻击过。\n- 结束回合，接下来轮到对方的回合。\n\n一回合中，玩家可以进行多次操作，但是技能和打牌的操作次数**之和**不能超过 $O$。除了结束回合，这些操作没有顺序限制，比如你可以先打一张牌，然后使用技能，然后再打一张牌。在结束回合之前，玩家需要进行至少一次任意的操作才能结束回合。\n\n在任何时刻如果有玩家的体力值小于或等于 $0$，那么该玩家输掉游戏。\n\n游戏进行了几个回合后，现在轮到了小 E 的回合开始前。小 E 想让你帮他分析，如果双方都采用最优策略，那么现在自己赢的概率是多少。", "inputFormat": "第一行一个正整数 $T, O$，分别表示数据组数和每回合中技能和打牌的操作次数上限。  \n对于每组数据，第一行两个正整数 $E, S$，分别表示小 E 和老师现在的体力值。保证 $1 \\le E, S \\le 20$。  \n第二行一个非负整数 $c$，然后跟着 $c$ 个正整数 $a_1, \\ldots , a_c$，表示老师面前有 $c$ 张牌，它们的体力值分别为 $a_1, \\ldots , a_c$。保证 $0 \\le c \\le 4$，$1 \\le a_i \\le 2$。  \n第三行一个非负整数 $p$，然后跟着 $p$ 个正整数 $e_1, \\ldots , e_p$，表示小 E 面前有 $p$ 张牌，\n它们的体力值分别为 $e_1, \\ldots , e_p$。保证 $0 \\le p \\le 4$，$1 \\le e_i \\le 2$。  \n第四行两个 $[0, 3]$ 之间的非负整数，分别表示老师和小 E 的手牌数。  \n在你到来之前老师可能作了弊，你不需要判断输入的情况是否真的是游戏进行了几个回合后的情况。", "outputFormat": "对于每组数据输出一行一个实数，表示小 E 在双方采用最优决策时获胜的概率。你的输出的和标准答案的绝对误差不超过 ${10}^{-6}$ 时算作正确。", "hint": "**【样例解释 #1】**\n\n回合开始，小 E 抽一张牌。此时小 E 手上有 $2$ 张牌，老师手上没有牌，双方的面前都没有牌。双方的体力值均为 $1$。这时，最优策略下，小 E 不能使用技能，因为使用后会因为自己的体力值小于等于 $0$ 而输掉游戏；小 E 不能攻击，因为自己面前没有牌；小 E 也不能结束回合，因为本回合他还没有进行任何操作。所以小 E 的最优策略是打一张牌，这时会随机选到小 E 或者老师中的一个角色，让他体力值 $- 1$ 然后输掉游戏。所以小 E 的获胜概率为 $0.5$。\n\n**【子任务】**\n\n保证 $1\\le T\\le 351493,3\\le O \\le 5$ 。\n\n**【后记】**\n\n最后小 E 还是战胜了老师。\n\n**“老师你术士玩多了就知道怎么玩了，你打得还不够多。”**\n\n**“吹牛现在都流行这么吹的吗？兄弟你知道我术士多少胜场嘛，啊？我跟你说全世界没有一个人术士比我胜场多的。”**\n\n**【题目来源】**\n\n来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。\n\n题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。", "locale": "zh-CN"}}}
{"pid": "P7145", "type": "P", "difficulty": 5, "samples": [["4 2\n", "2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2021", "THUPC"], "title": "[THUPC 2021 初赛] 合法序列", "background": "", "description": "对于一个长度为 $n$ 的 $\\text{0-1}$ 序列 $s$，我们将它的位从左到右、从零开始编号，记为 $s_0, s_1, \\ldots , s_{n-1}$。\n\n给定一个正整数 $k$，从 $s$ 中取出某个长度为 $k$ 的子段。将这个子段解释为一个左侧为高位、右侧为低位的 $k$ 位二进制数，记为 $t$，则有 $0 \\le t < 2^k$。\n\n$s$ 有 $n - k + 1$ 个长度为 $k$ 的子段，如果对于其中的每一个子段，如上解释为二进制数 $t$ 后，$s$ 的编号为 $t$ 的位（即 $s_t$）都是 $1$，则说 $s$ 是合法的。保证 $2^k \\le n$，即 $t$ 作为 $s$ 的下标不会越界。\n\n给定 $n, k$，求合法的 $s$ 的数量。由于方案数可能较大，只需给出方案数模 $998, 244, 353$ 的结果作为答案。", "inputFormat": "输入有一行，包含两个用空格隔开的正整数 $n, k$。\n\n保证 $1 \\le k \\le 4$，$2^k \\le n \\le 500$。", "outputFormat": "输出一行，包含一个非负整数，即合法方案数模 $998, 244, 353$ 的结果。", "hint": "**【样例解释 #1】**\n\n有两个满足要求的序列：$0, 1, 1, 1$ 和 $1, 1, 1, 1$。\n\n**【题目来源】**\n\n来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。\n\n题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2021 初赛] 合法序列", "background": "", "description": "对于一个长度为 $n$ 的 $\\text{0-1}$ 序列 $s$，我们将它的位从左到右、从零开始编号，记为 $s_0, s_1, \\ldots , s_{n-1}$。\n\n给定一个正整数 $k$，从 $s$ 中取出某个长度为 $k$ 的子段。将这个子段解释为一个左侧为高位、右侧为低位的 $k$ 位二进制数，记为 $t$，则有 $0 \\le t < 2^k$。\n\n$s$ 有 $n - k + 1$ 个长度为 $k$ 的子段，如果对于其中的每一个子段，如上解释为二进制数 $t$ 后，$s$ 的编号为 $t$ 的位（即 $s_t$）都是 $1$，则说 $s$ 是合法的。保证 $2^k \\le n$，即 $t$ 作为 $s$ 的下标不会越界。\n\n给定 $n, k$，求合法的 $s$ 的数量。由于方案数可能较大，只需给出方案数模 $998, 244, 353$ 的结果作为答案。", "inputFormat": "输入有一行，包含两个用空格隔开的正整数 $n, k$。\n\n保证 $1 \\le k \\le 4$，$2^k \\le n \\le 500$。", "outputFormat": "输出一行，包含一个非负整数，即合法方案数模 $998, 244, 353$ 的结果。", "hint": "**【样例解释 #1】**\n\n有两个满足要求的序列：$0, 1, 1, 1$ 和 $1, 1, 1, 1$。\n\n**【题目来源】**\n\n来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。\n\n题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。", "locale": "zh-CN"}}}
{"pid": "P7146", "type": "P", "difficulty": 6, "samples": [["10 5 1 2 3 4\n", "3909327860\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "THUPC"], "title": "[THUPC 2021 初赛] 独立", "background": "feecle6418 备注：可以认为本题的数据是随机生成的。", "description": "给定一张 $n$ 个点 $m$ 条边的无向图。\n\n对于 $\\{1, 2, \\ldots , n\\}$ 的某个子集 $A$，$A$ 的分数为：\n\n1. 初始分数为 $0$；\n2. 对于所有 $i \\in A$，分数加 $a_i$；\n3. 对于所有边 $(u, v, k)$（代表从 $u$ 到 $v$ 值为 $k$ 的边）满足 $u \\in A$ 并且 $v \\in A$，分数减 $k$；\n\n现在请你计算出所有的 $A$ 中，分数最高是多少。", "inputFormat": "令 $q = 101$，$b = 137$，$p = 1, 000, 000, 007$。\n\n第一行包含六个整数 $n, m, x_0, y_0, a_0, z_0$（$1 \\le n \\le 100000$，$0 \\le m \\le \\frac n2$，$0 \\le x_0, y_0, a_0, z_0 < P$）。\n\n对于 $1 \\le i \\le n$，有 $a_i = (q \\times a_{i - 1} + b) \\bmod p$。\n\n对于 $1 \\le i \\le m$, 有 $x_i = (q \\times x_{i − 1} + b) \\bmod p$，$y_i = (q \\times y_{i − 1} + b) \\bmod p$，$z_i = (q \\times z_{i − 1} + b) \\bmod p$。对于每一组 $(x_i, y_i, z_i)$ 描述了一条连接 $(x_i \\bmod n) + 1, (y_i \\bmod n) + 1$ 的值为 $z_i$ 的边，如果 $x_i = y_i$ 或者之前出现过连接 $x_i$ 和 $y_i$ 的边，则忽视这条边（即这条边不存在）。", "outputFormat": "输出一行一个整数表示最高分数。", "hint": "**【题目来源】**\n\n来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。\n\n题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2021 初赛] 独立", "background": "feecle6418 备注：可以认为本题的数据是随机生成的。", "description": "给定一张 $n$ 个点 $m$ 条边的无向图。\n\n对于 $\\{1, 2, \\ldots , n\\}$ 的某个子集 $A$，$A$ 的分数为：\n\n1. 初始分数为 $0$；\n2. 对于所有 $i \\in A$，分数加 $a_i$；\n3. 对于所有边 $(u, v, k)$（代表从 $u$ 到 $v$ 值为 $k$ 的边）满足 $u \\in A$ 并且 $v \\in A$，分数减 $k$；\n\n现在请你计算出所有的 $A$ 中，分数最高是多少。", "inputFormat": "令 $q = 101$，$b = 137$，$p = 1, 000, 000, 007$。\n\n第一行包含六个整数 $n, m, x_0, y_0, a_0, z_0$（$1 \\le n \\le 100000$，$0 \\le m \\le \\frac n2$，$0 \\le x_0, y_0, a_0, z_0 < P$）。\n\n对于 $1 \\le i \\le n$，有 $a_i = (q \\times a_{i - 1} + b) \\bmod p$。\n\n对于 $1 \\le i \\le m$, 有 $x_i = (q \\times x_{i − 1} + b) \\bmod p$，$y_i = (q \\times y_{i − 1} + b) \\bmod p$，$z_i = (q \\times z_{i − 1} + b) \\bmod p$。对于每一组 $(x_i, y_i, z_i)$ 描述了一条连接 $(x_i \\bmod n) + 1, (y_i \\bmod n) + 1$ 的值为 $z_i$ 的边，如果 $x_i = y_i$ 或者之前出现过连接 $x_i$ 和 $y_i$ 的边，则忽视这条边（即这条边不存在）。", "outputFormat": "输出一行一个整数表示最高分数。", "hint": "**【题目来源】**\n\n来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。\n\n题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。", "locale": "zh-CN"}}}
{"pid": "P7147", "type": "P", "difficulty": 6, "samples": [["8M\nZ\nE\n9P\n3P\n9S\n5P\nW\n3M\n8P\nDOUBLE\n5P\nZ\n2P\n3M\n8S\n2S\n5P\n5M\nE\n6M\n9S\n6P\n5S\n7M\n4S\n3S\n6M\n3S\n2M\n9M\n5S\nZ\n7P\n5P\n8M\n3M\nF\n7M\n2S\nN\n4P\n3S\nS\nPASS\n1P\n6S\n3P\n9P\n9S\n4M\n8P\nN\nZ\nN\n5M\nDOUBLE\nREVERSE\nS\n3P\n4M\n4S\n1S\nPASS\n4P\n6S\n7S\n7P\n6S\n9M\nREVERSE\n3P\n7P\nDOUBLE\nB\n9P\n4S\n5S\n7S\n7S\n7P\n6S\n9S\nB\n9M\nS\nF\n2P\n1P\nPASS\n9P\nDOUBLE\n4P\nPASS\n5S\n2M\n2P\n6P\nW\n1M\n8S\nREVERSE\n8M\n6M\n5M\nF\n4M\nF\n8P\n2S\n1M\n2M\n3M\n7M\n3S\nB\n7S\n1S\nREVERSE\n8P\n6M\n4S\n2M\nB\n1M\nS\n6P\n5M\nW\n7M\n2S\n8S\n8M\n1S\n4P\nE\n4M\n9M\n1M\n8S\n1S\n1P\n2P\n1P\nW\n6P\nN\nE\n", "A IN 8M\nB IN Z\nC IN E\nD IN 9P\nA IN 3P\nB IN 9S\nC IN 5P\nD IN W\nA IN 3M\nB IN 8P\nC IN DOUBLE\nD IN 5P\nA IN Z\nB IN 2P\nC IN 3M\nD IN 8S\nA IN 2S\nB IN 5P\nC IN 5M\nD IN E\nA IN 6M\nB IN 9S\nC IN 6P\nD IN 5S\nA IN 7M\nB IN 4S\nC IN 3S\nD IN 6M\nA IN 3S\nB IN 2M\nC IN 9M\nD IN 5S\nA IN Z\nB IN 7P\nC IN 5P\nD IN 8M\nA IN 3M\nB IN F\nC IN 7M\nD IN 2S\nA IN N\nB IN 4P\nC IN 3S\nD IN S\nA IN PASS\nB IN 1P\nC IN 6S\nD IN 3P\nA IN 9P\nB IN 9S\nC IN 4M\nD IN 8P\nA IN N\nA OUT PASS B\nC IN Z\nC OUT DOUBLE\nC IN N\nC OUT Z\nA PONG Z Z Z\nA OUT 9P\nB CHOW 7P 8P 9P\nB OUT Z\nC IN 5M\nC OUT N\nA PONG N N N\nA OUT 3P\nB CHOW 3P 4P 5P\nB OUT F\nC IN DOUBLE\nC OUT DOUBLE\nC IN REVERSE\nC OUT REVERSE\nB IN S\nB OUT S\nA IN 3P\nA OUT 3P\nD IN 4M\nD OUT W\nC IN 4S\nC OUT E\nB IN 1S\nB OUT 4S\nA RON\nA WIN\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2021", "THUPC"], "title": "[THUPC 2021 初赛] 麻将模拟器", "background": "", "description": "麻将是一种休闲的四人博弈游戏。你的任务是写一个模拟器来模拟一局游戏的进程。\n\n接下来将详细介绍游戏规则和每个玩家的决策。注意：为了实现方便和使游戏更加有趣味，这里介绍的规则和主流的几种麻将规则均略有不同。\n\n**基础规则：**\n\n- 一副麻将由 $148$ 张牌组成，其中包含 $37$ 种不同的牌，每种各 $4$ 张。\n- 这 $37$ 种牌分别是：一万到九万（`1M ~ 9M`）、一筒到九筒（`1P ~ 9P`）、一索到九索（`1S ~ 9S`）、东（`E`）、南（`S`）、西（`W`）、北（`N`）、白（`B`）、发（`F`）、中（`Z`），以及 $3$ 种特殊牌：跳过（`PASS`），反向（`REVERSE`），双重回合（`DOUBLE`）。\n- 游戏共有 $4$ 名玩家，不妨称其为 `A`，`B`，`C`，`D`。\n- 游戏开始前，将 $148$ 张牌随机洗乱后摆成一排，称为牌堆。此后玩家摸牌一定是从牌堆中摸取最靠前的一张牌。\n- 从 `A` 开始按照 `ABCDABCD...` 的顺序，每人依次从牌堆中摸一张牌，直到每人都有 $13$ 张牌，这些牌组成每个玩家的手牌。\n- 再从 `A` 开始按照 `ABCDABCD...` 的顺序，依次进入每人的回合：\n- 在一个回合中，玩家先摸一张牌进入自己的手牌，再从自己的手牌中打出一张牌。\n- 依次进行直到有人和牌或者无牌可摸时游戏结束。\n\n**特殊牌：**\n\n- 跳过（`PASS`）：在出牌时打出这张牌，可以指定一名玩家，跳过他的下一个回合。\n- 反向（`REVERSE`）：在出牌时打出这张牌，反转进行回合的顺序，即由 `ABCDABCD...` 变为 `ADCBADCB...` 或由 `ADCBADCB...` 变为 `ABCDABCD...`。出牌后即按照反转后的顺序，从出牌者原先的上家开始进行回合。\n- 双重回合（`DOUBLE`）：在出牌时打出这张牌，该名玩家立即进入一个额外的回合。\n\n**牌型：**&#8203;有如下 $3$ 种牌型：\n\n- 顺子：$3$ 张数字连续的万，或 $3$ 张数字连续的筒，或 $3$ 张数字连续的索，如 `4P 5P 6P`。\n- 刻子：$3$ 张完全一样的非特殊牌，如 `B B B`。\n- 对子：$2$ 张完全一样的非特殊牌，如 `9M 9M`。\n\n**吃、碰：**\n\n- 当一名玩家打出一张非特殊牌时，其他玩家可以进行吃或碰：\n- 吃（`CHOW`）：当打出的这张牌跟自己的手牌中的某两张牌能组成一个顺子时，可以将手牌中能与之组成顺子的其余两张牌取出，与这张牌一起摆在旁边。\n- **注意只有上一名出牌玩家的下家（按当前顺序原本应在下一个进行回合的玩家）才能吃。**\n- 碰（`PONG`）：当打出的这张牌跟自己的手牌中的某两张牌能组成一个刻子时，可以将手牌中能与之组成刻子的其余两张牌取出，与这张牌一起摆在旁边。\n- 碰没有吃的上述限制，任意其他玩家都能碰。\n- 如果既有玩家能吃又有玩家能碰，则碰优先于吃。\n- 吃（或碰）不是强制性的，也就是说玩家满足吃（或碰）的条件时，可以选择不吃（或碰）。\n- 吃和碰统称为副露。为方便起见，不将副露视为手牌的一部分。\n- 在任意一名玩家吃（或碰）后，跳过从上一名出牌的玩家到这名玩家之间的所有玩家的回合，直接从当前玩家开始进行新的回合。但该玩家在这一回合中**跳过摸牌直接出牌**，在下一回合（如果没有吃碰的话）恢复正常。\n- **注意在本规则中不能杠。**\n\n**胡牌规则：**\n\n- 称一名玩家的牌能和，当且仅当满足如下条件：\n  - 牌数为 $14 - 3 n$，其中 $n$ 为该玩家副露（即吃碰）的个数；\n  - 这些牌中无特殊牌；\n  -  这些牌能够被分成 $(5 - n)$ 组，其中 $(4 - n)$ 组均为 $3$ 张且均为顺子或刻子，其余一组为 $2$ 张且为对子。\n- **注意本规则中不支持七对子、十三幺、全不靠等特殊的和牌规则。**\n- 另外，定义一组包含 $13 - 3 n$ 张牌的手牌的和牌距离为最小的 $x$，使得向这些牌中加入特定的 $x$ 张牌，再去掉 $x - 1$ 张手牌后，每种牌仍不超过 $4$ 张且能和。\n- 定义一组包含 $14 - 3 n$ 张牌的手牌的和牌距离为最小的 $x$，使得向这些牌中加入特定的 $x$ 张牌，再去掉 $x$ 张手牌后，每种牌仍不超过 $4$ 张且能和。\n- 特别地，一手能和的牌的和牌距离为 $0$；和牌距离为 $1$ 的牌称为听牌。\n- 注意这里的“**每种牌仍不超过** $\\boldsymbol{4}$ **张**”的限制：如果一手牌是 `1M 1M 1M 1M` 且副露数为 $3$，再向其中加入一张 `1M` 就能和，但是由于有 $5$ 张 `1M` 所以是不被允许的，故不认为其和牌距离为 $1$。\n- 但如果一手牌是 `1M` 且副露数为 $4$，但是曾进行过一次 `1M 1M 1M` 的碰，仍然认为其和牌距离为 $1$（虽然缺的这张 `1M` 永远也等不到）。\n\n**终局：**\n\n- 荣和（`RON`）：当一名玩家出牌后，某名其他玩家的手牌加上这张牌能和，则称这名玩家荣和。荣和优先于吃碰。\n- 如果有多名玩家同时达到荣和的标准，规定只有从上一名出牌玩家开始，沿回合进行顺序的第一名能荣和的玩家才能荣和，其余玩家荣和不了，称这种情况为截和。\n- 自摸（`SELFDRAWN`）：一名玩家摸牌后其手牌能和，称这名玩家自摸。\n- 一旦有一名玩家荣和或自摸，游戏立即结束，该名玩家胜利。\n- 如果某名玩家摸牌时发现牌堆中已经无牌可摸，游戏立即结束，称此种情况为流局。\n\n**出牌策略：**&#8203;每名玩家的出牌策略相同且固定：\n\n- 出牌时，若手里有特殊牌一定会优先出，且如果有多种特殊牌，按照 `PASS`、`REVERSE`、`DOUBLE` 的优先顺序；出的 `PASS` 一定指定下家。\n- 出牌时若手里没有特殊牌，则会对于每一种可能的出牌方法计算出完牌后的和牌距离，选择和牌距离最小的一种方案。如果有并列最小，按照 `Z`，`F`，`B`，`N`，`W`，`S`，`E`，`9S`，`8S`，……，`1S`，`9P`，……，`1P`，`9M`，……，`1M` 的优先顺序出牌。\n- 同一个人能吃且能碰时，优先考虑碰；因为每种牌只有 $4$ 张所以不会有两名玩家同时可以碰的情况；当且仅当吃（或碰）后能使得和牌距离严格减小才会去吃（或碰）；如果有多种吃的方案使得和牌距离严格减小，优先选择数字较大的方案。\n-  能荣和一定荣和（除非被截和），能自摸一定自摸，不会拒和（能和时故意选择不和）。", "inputFormat": "输入共 $148$ 行，按照牌堆从前到后的顺序输入每一张牌。  \n每行输入一个字符串表示这一张牌。  \n用 `1M`，`2M`，……，`9M` 代表万，`1P`，`2P`，……，`9P` 代表筒，`1S`，`2S`，……，`9S` 代表索，`E`，`S`，`W`，`N`，`B`，`F`，`Z` 分别代表东、南、西、北、白、发、中，`PASS` 代表跳过，`REVERSE` 表示反向，`DOUBLE` 表示双重回合。", "outputFormat": "按照如下几条规则进行输出：\n\n- 当任意一名玩家摸牌时（**包括游戏最开始的摸牌**），输出一行：  \n  `x IN y`  \n  其中 `x` 为玩家名称，`y` 为摸到的牌。\n- 当任意一名玩家出牌时，如果出的牌不是 `PASS`，输出一行：  \n  `x OUT y`  \n  其中 `x` 为玩家名称，`y` 为出的牌。  \n  如果出的牌是 `PASS`，应当输出一行：  \n  `x OUT PASS z`  \n  其中 `z` 为 `PASS` 指定的对象。\n- 当任意一名玩家吃时，输出一行：  \n  `x CHOW y1 y2 y3`  \n  其中 `x` 为玩家名称，`y1`，`y2`，`y3` 为吃涉及到的 $3$ 张牌，按数字递增的顺序输出。\n- 当任意一名玩家碰时，输出一行：  \n  `x PONG y1 y2 y3`  \n  其中 `x` 为玩家名称，`y1`，`y2`，`y3` 为碰涉及到的 $3$ 张牌，根据碰的规则，`y1`，`y2`，`y3` 应相同。\n- 当任意一名玩家荣和时，输出一行：  \n  `x RON`  \n  其中 `x` 为玩家名称。\n- 当任意一名玩家自摸时，输出一行：  \n  `x SELFDRAWN`  \n  其中 `x` 为玩家名称。\n- 游戏的最后，如果某名玩家获得胜利，输出一行：  \n  `x WIN`  \n  其中 `x` 为玩家名称。  \n  如果出现流局，输出一行：  \n  `DRAW`\n\n**需要特别注意的是，输入输出中出现的英文字母均为大写。**", "hint": "**【题目来源】**\n\n来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。\n\n题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2021 初赛] 麻将模拟器", "background": "", "description": "麻将是一种休闲的四人博弈游戏。你的任务是写一个模拟器来模拟一局游戏的进程。\n\n接下来将详细介绍游戏规则和每个玩家的决策。注意：为了实现方便和使游戏更加有趣味，这里介绍的规则和主流的几种麻将规则均略有不同。\n\n**基础规则：**\n\n- 一副麻将由 $148$ 张牌组成，其中包含 $37$ 种不同的牌，每种各 $4$ 张。\n- 这 $37$ 种牌分别是：一万到九万（`1M ~ 9M`）、一筒到九筒（`1P ~ 9P`）、一索到九索（`1S ~ 9S`）、东（`E`）、南（`S`）、西（`W`）、北（`N`）、白（`B`）、发（`F`）、中（`Z`），以及 $3$ 种特殊牌：跳过（`PASS`），反向（`REVERSE`），双重回合（`DOUBLE`）。\n- 游戏共有 $4$ 名玩家，不妨称其为 `A`，`B`，`C`，`D`。\n- 游戏开始前，将 $148$ 张牌随机洗乱后摆成一排，称为牌堆。此后玩家摸牌一定是从牌堆中摸取最靠前的一张牌。\n- 从 `A` 开始按照 `ABCDABCD...` 的顺序，每人依次从牌堆中摸一张牌，直到每人都有 $13$ 张牌，这些牌组成每个玩家的手牌。\n- 再从 `A` 开始按照 `ABCDABCD...` 的顺序，依次进入每人的回合：\n- 在一个回合中，玩家先摸一张牌进入自己的手牌，再从自己的手牌中打出一张牌。\n- 依次进行直到有人和牌或者无牌可摸时游戏结束。\n\n**特殊牌：**\n\n- 跳过（`PASS`）：在出牌时打出这张牌，可以指定一名玩家，跳过他的下一个回合。\n- 反向（`REVERSE`）：在出牌时打出这张牌，反转进行回合的顺序，即由 `ABCDABCD...` 变为 `ADCBADCB...` 或由 `ADCBADCB...` 变为 `ABCDABCD...`。出牌后即按照反转后的顺序，从出牌者原先的上家开始进行回合。\n- 双重回合（`DOUBLE`）：在出牌时打出这张牌，该名玩家立即进入一个额外的回合。\n\n**牌型：**&#8203;有如下 $3$ 种牌型：\n\n- 顺子：$3$ 张数字连续的万，或 $3$ 张数字连续的筒，或 $3$ 张数字连续的索，如 `4P 5P 6P`。\n- 刻子：$3$ 张完全一样的非特殊牌，如 `B B B`。\n- 对子：$2$ 张完全一样的非特殊牌，如 `9M 9M`。\n\n**吃、碰：**\n\n- 当一名玩家打出一张非特殊牌时，其他玩家可以进行吃或碰：\n- 吃（`CHOW`）：当打出的这张牌跟自己的手牌中的某两张牌能组成一个顺子时，可以将手牌中能与之组成顺子的其余两张牌取出，与这张牌一起摆在旁边。\n- **注意只有上一名出牌玩家的下家（按当前顺序原本应在下一个进行回合的玩家）才能吃。**\n- 碰（`PONG`）：当打出的这张牌跟自己的手牌中的某两张牌能组成一个刻子时，可以将手牌中能与之组成刻子的其余两张牌取出，与这张牌一起摆在旁边。\n- 碰没有吃的上述限制，任意其他玩家都能碰。\n- 如果既有玩家能吃又有玩家能碰，则碰优先于吃。\n- 吃（或碰）不是强制性的，也就是说玩家满足吃（或碰）的条件时，可以选择不吃（或碰）。\n- 吃和碰统称为副露。为方便起见，不将副露视为手牌的一部分。\n- 在任意一名玩家吃（或碰）后，跳过从上一名出牌的玩家到这名玩家之间的所有玩家的回合，直接从当前玩家开始进行新的回合。但该玩家在这一回合中**跳过摸牌直接出牌**，在下一回合（如果没有吃碰的话）恢复正常。\n- **注意在本规则中不能杠。**\n\n**胡牌规则：**\n\n- 称一名玩家的牌能和，当且仅当满足如下条件：\n  - 牌数为 $14 - 3 n$，其中 $n$ 为该玩家副露（即吃碰）的个数；\n  - 这些牌中无特殊牌；\n  -  这些牌能够被分成 $(5 - n)$ 组，其中 $(4 - n)$ 组均为 $3$ 张且均为顺子或刻子，其余一组为 $2$ 张且为对子。\n- **注意本规则中不支持七对子、十三幺、全不靠等特殊的和牌规则。**\n- 另外，定义一组包含 $13 - 3 n$ 张牌的手牌的和牌距离为最小的 $x$，使得向这些牌中加入特定的 $x$ 张牌，再去掉 $x - 1$ 张手牌后，每种牌仍不超过 $4$ 张且能和。\n- 定义一组包含 $14 - 3 n$ 张牌的手牌的和牌距离为最小的 $x$，使得向这些牌中加入特定的 $x$ 张牌，再去掉 $x$ 张手牌后，每种牌仍不超过 $4$ 张且能和。\n- 特别地，一手能和的牌的和牌距离为 $0$；和牌距离为 $1$ 的牌称为听牌。\n- 注意这里的“**每种牌仍不超过** $\\boldsymbol{4}$ **张**”的限制：如果一手牌是 `1M 1M 1M 1M` 且副露数为 $3$，再向其中加入一张 `1M` 就能和，但是由于有 $5$ 张 `1M` 所以是不被允许的，故不认为其和牌距离为 $1$。\n- 但如果一手牌是 `1M` 且副露数为 $4$，但是曾进行过一次 `1M 1M 1M` 的碰，仍然认为其和牌距离为 $1$（虽然缺的这张 `1M` 永远也等不到）。\n\n**终局：**\n\n- 荣和（`RON`）：当一名玩家出牌后，某名其他玩家的手牌加上这张牌能和，则称这名玩家荣和。荣和优先于吃碰。\n- 如果有多名玩家同时达到荣和的标准，规定只有从上一名出牌玩家开始，沿回合进行顺序的第一名能荣和的玩家才能荣和，其余玩家荣和不了，称这种情况为截和。\n- 自摸（`SELFDRAWN`）：一名玩家摸牌后其手牌能和，称这名玩家自摸。\n- 一旦有一名玩家荣和或自摸，游戏立即结束，该名玩家胜利。\n- 如果某名玩家摸牌时发现牌堆中已经无牌可摸，游戏立即结束，称此种情况为流局。\n\n**出牌策略：**&#8203;每名玩家的出牌策略相同且固定：\n\n- 出牌时，若手里有特殊牌一定会优先出，且如果有多种特殊牌，按照 `PASS`、`REVERSE`、`DOUBLE` 的优先顺序；出的 `PASS` 一定指定下家。\n- 出牌时若手里没有特殊牌，则会对于每一种可能的出牌方法计算出完牌后的和牌距离，选择和牌距离最小的一种方案。如果有并列最小，按照 `Z`，`F`，`B`，`N`，`W`，`S`，`E`，`9S`，`8S`，……，`1S`，`9P`，……，`1P`，`9M`，……，`1M` 的优先顺序出牌。\n- 同一个人能吃且能碰时，优先考虑碰；因为每种牌只有 $4$ 张所以不会有两名玩家同时可以碰的情况；当且仅当吃（或碰）后能使得和牌距离严格减小才会去吃（或碰）；如果有多种吃的方案使得和牌距离严格减小，优先选择数字较大的方案。\n-  能荣和一定荣和（除非被截和），能自摸一定自摸，不会拒和（能和时故意选择不和）。", "inputFormat": "输入共 $148$ 行，按照牌堆从前到后的顺序输入每一张牌。  \n每行输入一个字符串表示这一张牌。  \n用 `1M`，`2M`，……，`9M` 代表万，`1P`，`2P`，……，`9P` 代表筒，`1S`，`2S`，……，`9S` 代表索，`E`，`S`，`W`，`N`，`B`，`F`，`Z` 分别代表东、南、西、北、白、发、中，`PASS` 代表跳过，`REVERSE` 表示反向，`DOUBLE` 表示双重回合。", "outputFormat": "按照如下几条规则进行输出：\n\n- 当任意一名玩家摸牌时（**包括游戏最开始的摸牌**），输出一行：  \n  `x IN y`  \n  其中 `x` 为玩家名称，`y` 为摸到的牌。\n- 当任意一名玩家出牌时，如果出的牌不是 `PASS`，输出一行：  \n  `x OUT y`  \n  其中 `x` 为玩家名称，`y` 为出的牌。  \n  如果出的牌是 `PASS`，应当输出一行：  \n  `x OUT PASS z`  \n  其中 `z` 为 `PASS` 指定的对象。\n- 当任意一名玩家吃时，输出一行：  \n  `x CHOW y1 y2 y3`  \n  其中 `x` 为玩家名称，`y1`，`y2`，`y3` 为吃涉及到的 $3$ 张牌，按数字递增的顺序输出。\n- 当任意一名玩家碰时，输出一行：  \n  `x PONG y1 y2 y3`  \n  其中 `x` 为玩家名称，`y1`，`y2`，`y3` 为碰涉及到的 $3$ 张牌，根据碰的规则，`y1`，`y2`，`y3` 应相同。\n- 当任意一名玩家荣和时，输出一行：  \n  `x RON`  \n  其中 `x` 为玩家名称。\n- 当任意一名玩家自摸时，输出一行：  \n  `x SELFDRAWN`  \n  其中 `x` 为玩家名称。\n- 游戏的最后，如果某名玩家获得胜利，输出一行：  \n  `x WIN`  \n  其中 `x` 为玩家名称。  \n  如果出现流局，输出一行：  \n  `DRAW`\n\n**需要特别注意的是，输入输出中出现的英文字母均为大写。**", "hint": "**【题目来源】**\n\n来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。\n\n题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。", "locale": "zh-CN"}}}
{"pid": "P7148", "type": "P", "difficulty": 3, "samples": [["4\n1 2\n1 3\n1 4", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "贪心", "2020", "USACO", "O2优化"], "title": "[USACO20DEC] Cowntagion S", "background": "", "description": "Farmer John 和他的农民团队为了控制牛传染病 COWVID-19 在他们农场间的传播而夜以继日地工作。\n\n他们共同监控着 $N$ 个农场（$1≤N≤10^5$），编号为 $1…N$。农场间由 $N−1$ 条道路连接，使得每个农场都可以从农场 $1$ 出发经过一些道路到达。\n\n很不幸，农场 $1$ 中的一头奶牛的 COWVID-19 检测呈阳性。暂时这个农场的其他奶牛以及其他农场的所有奶牛都还没有染上疾病。然而，根据这个疾病通过接触传播的特性，Farmer John 推测每一天都会有以下不利的事件之一发生：\n\n(1) 在一个农场内，「超级传播者」导致该农场感染 COWVID-19 的奶牛数量翻倍；或者\n\n(2) 一头感染 COWVID-19 的奶牛从一个农场沿道路去往了一个相邻的农场。\n\nFarmer John 担心疫情会很快爆发。请帮助 Farmer John 求出每个农场内均有至少一头奶牛感染疾病所需经过的最小天数。 ", "inputFormat": "输入的第一行包含一个整数 $N$。以下 $N−1$ 行每行包含两个空格分隔的整数 $a$ 和 $b$，表示一条农场 $a$ 与 $b$ 之间的道路。$a$ 和 $b$ 均在 $1…N$ 范围内。 ", "outputFormat": "输出疫情爆发至所有农场所需经过的最小天数。", "hint": "该样例对应的一个可能的事件序列如下：农场 $1$ 内染病的奶牛数量翻倍再翻倍，使得两天后农场 $1$ 内有 $4$ 头染病的奶牛。在此后 $3$ 天，分别有一头染病的奶牛从农场 $1$ 去往农场 $2$、$3$ 和 $4$。$5$ 天过后每个农场均有至少 $1$ 头染病的奶牛。\n\n\n - 测试点 1-4 中，每个农场均直接与农场 $1$ 相连（除农场 $1$ 外）。\n - 测试点 5-7 中，农场 $2…N$ 均至多与两条道路相连。\n - 测试点 8-15 没有额外限制。\n\n供题：Dhruv Rohatgi ", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO20DEC] Cowntagion S", "background": "", "description": "Farmer John 和他的农民团队为了控制牛传染病 COWVID-19 在他们农场间的传播而夜以继日地工作。\n\n他们共同监控着 $N$ 个农场（$1≤N≤10^5$），编号为 $1…N$。农场间由 $N−1$ 条道路连接，使得每个农场都可以从农场 $1$ 出发经过一些道路到达。\n\n很不幸，农场 $1$ 中的一头奶牛的 COWVID-19 检测呈阳性。暂时这个农场的其他奶牛以及其他农场的所有奶牛都还没有染上疾病。然而，根据这个疾病通过接触传播的特性，Farmer John 推测每一天都会有以下不利的事件之一发生：\n\n(1) 在一个农场内，「超级传播者」导致该农场感染 COWVID-19 的奶牛数量翻倍；或者\n\n(2) 一头感染 COWVID-19 的奶牛从一个农场沿道路去往了一个相邻的农场。\n\nFarmer John 担心疫情会很快爆发。请帮助 Farmer John 求出每个农场内均有至少一头奶牛感染疾病所需经过的最小天数。 ", "inputFormat": "输入的第一行包含一个整数 $N$。以下 $N−1$ 行每行包含两个空格分隔的整数 $a$ 和 $b$，表示一条农场 $a$ 与 $b$ 之间的道路。$a$ 和 $b$ 均在 $1…N$ 范围内。 ", "outputFormat": "输出疫情爆发至所有农场所需经过的最小天数。", "hint": "该样例对应的一个可能的事件序列如下：农场 $1$ 内染病的奶牛数量翻倍再翻倍，使得两天后农场 $1$ 内有 $4$ 头染病的奶牛。在此后 $3$ 天，分别有一头染病的奶牛从农场 $1$ 去往农场 $2$、$3$ 和 $4$。$5$ 天过后每个农场均有至少 $1$ 头染病的奶牛。\n\n\n - 测试点 1-4 中，每个农场均直接与农场 $1$ 相连（除农场 $1$ 外）。\n - 测试点 5-7 中，农场 $2…N$ 均至多与两条道路相连。\n - 测试点 8-15 没有额外限制。\n\n供题：Dhruv Rohatgi ", "locale": "zh-CN"}}}
{"pid": "P7149", "type": "P", "difficulty": 4, "samples": [["4\n0 2\n1 0\n2 3\n3 5", "13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "USACO", "离散化", "O2优化", "排序", "前缀和"], "title": "[USACO20DEC] Rectangular Pasture S", "background": "", "description": "Farmer John 最大的牧草地可以被看作是一个由方格组成的巨大的二维方阵（想象一个巨大的棋盘）。现在，有 $N$ 头奶牛正占据某些方格（$1≤N≤2500$）。\n\nFarmer John 想要建造一个可以包围一块矩形区域的栅栏；这个矩形必须四边与 $x$ 轴和 $y$ 轴平行，最少包含一个方格。请帮助他求出他可以包围在这样的区域内的不同的奶牛子集的数量。注意空集应当被计算为答案之一。 ", "inputFormat": "输入的第一行包含一个整数 $N$。以下 $N$ 行每行包含两个空格分隔的整数，表示一头奶牛所在方格的坐标 $(x,y)$。所有 $x$ 坐标各不相同，所有 $y$ 坐标各不相同。所有 $x$ 与 $y$ 的值均在 $0…10^9$ 范围内。 ", "outputFormat": " 输出 FJ 可以包围的奶牛的子集数量。可以证明这个数量可以用 64 位有符号整数型存储（例如 C/C++ 中的long long）。 ", "hint": "共有 $2^4$ 个子集。FJ 不能建造一个栅栏仅包围奶牛 $1$、$2$、$4$，或仅包围奶牛 $2$、$4$，或仅包围奶牛 $1$、$4$，所以答案为 $2^4-3=16-3=13$。 \n\n - 测试点 2-3 满足 $N≤20$。\n - 测试点 4-6 满足 $N≤100$。\n - 测试点 7-12 满足 $N≤500$。\n - 测试点 13-20 没有额外限制。\n\n供题：Benjamin Qi ", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO20DEC] Rectangular Pasture S", "background": "", "description": "Farmer John 最大的牧草地可以被看作是一个由方格组成的巨大的二维方阵（想象一个巨大的棋盘）。现在，有 $N$ 头奶牛正占据某些方格（$1≤N≤2500$）。\n\nFarmer John 想要建造一个可以包围一块矩形区域的栅栏；这个矩形必须四边与 $x$ 轴和 $y$ 轴平行，最少包含一个方格。请帮助他求出他可以包围在这样的区域内的不同的奶牛子集的数量。注意空集应当被计算为答案之一。 ", "inputFormat": "输入的第一行包含一个整数 $N$。以下 $N$ 行每行包含两个空格分隔的整数，表示一头奶牛所在方格的坐标 $(x,y)$。所有 $x$ 坐标各不相同，所有 $y$ 坐标各不相同。所有 $x$ 与 $y$ 的值均在 $0…10^9$ 范围内。 ", "outputFormat": " 输出 FJ 可以包围的奶牛的子集数量。可以证明这个数量可以用 64 位有符号整数型存储（例如 C/C++ 中的long long）。 ", "hint": "共有 $2^4$ 个子集。FJ 不能建造一个栅栏仅包围奶牛 $1$、$2$、$4$，或仅包围奶牛 $2$、$4$，或仅包围奶牛 $1$、$4$，所以答案为 $2^4-3=16-3=13$。 \n\n - 测试点 2-3 满足 $N≤20$。\n - 测试点 4-6 满足 $N≤100$。\n - 测试点 7-12 满足 $N≤500$。\n - 测试点 13-20 没有额外限制。\n\n供题：Benjamin Qi ", "locale": "zh-CN"}}}
{"pid": "P7150", "type": "P", "difficulty": 4, "samples": [["6\nE 3 5\nN 5 3\nE 4 6\nE 10 4\nN 11 1\nE 9 2", "0\n0\n1\n2\n1\n0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "2020", "USACO", "并查集", "O2优化", "排序"], "title": "[USACO20DEC] Stuck in a Rut S", "background": "", "description": "Farmer John 最近扩大了他的农场，从奶牛们的角度看来这个农场相当于是无限大了！奶牛们将农场上放牧的区域想作是一个由正方形方格组成的无限大二维方阵，每个方格中均有美味的草（将每个方格看作是棋盘上的一个方格）。Farmer John 的 $N$ 头奶牛（$1≤N≤1000$）初始时位于不同的方格中，一部分朝向北面，一部分朝向东面。\n\n每一小时，每头奶牛会执行以下二者之一：\n\n - 如果她当前所在的方格里的草已经被其他奶牛吃掉了，则她会停下（并从这个时刻开始一直保持停止）。\n - 吃完她当前所在的方格中的所有草，并向她朝向的方向移动一个方格。\n\n经过一段时间，每头奶牛的身后会留下一条被啃秃了的轨迹。\n\n如果两头奶牛在一次移动中移动到了同一个有草的方格，她们会分享这个方格中的草，并在下一个小时继续沿她们朝向的方向移动。\n\n当 Farmer John 看到停止吃草的奶牛时会不高兴，他想要知道谁该为他停止吃草的奶牛受到责备。如果奶牛 $b$\n停在了之前奶牛 $a$ 吃过草的一个方格，我们就称奶牛 $a$ 阻碍了奶牛 $b$。进一步地，如果奶牛 $a$ 阻碍了奶牛 $b$ 且奶牛 $b$ 阻碍了奶牛 $c$，我们认为奶牛 $a$ 也阻碍了奶牛 $c$（也就是说，「阻碍」关系具有传递性）。每头奶牛受到责备的程度与这头奶牛阻碍的奶牛数量一致。请计算每头奶牛受到责备的数量——也就是说，每头奶牛阻碍的奶牛数量。 ", "inputFormat": "输入的第一行包含 $N$。以下 $N$ 行，每行描述一头奶牛的起始位置，包含一个字符 N（表示朝向北面） 或 E（表示朝向东面），以及两个非负整数 $x$ 和 $y$（$0≤x≤10^9$，$0≤y≤10^9$）表示方格的坐标。所有 $x$ 坐标各不相同，所有 $y$ 坐标各不相同。\n\n为了使方向和坐标尽可能明确，如果一头奶牛位于方格 $(x,y)$ 并向北移动，她会到达方格 $(x,y+1)$。如果她向东移动，她会到达方格 $(x+1,y)$。 ", "outputFormat": "输出 $N$ 行。输出的第 $i$ 行包含输入中的第 $i$ 头奶牛受到的责备的数量。 ", "hint": "在这个样例中，奶牛 3 阻碍了奶牛 2，奶牛 4 阻碍了奶牛 5，奶牛 5 阻碍了奶牛 6。根据传递性，奶牛 4 也阻碍了奶牛 6。 \n\n - 测试点 2-5 中，所有坐标不超过 $2000$。\n - 测试点 6-10 没有额外限制。\n\n供题：Brian Dean ", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO20DEC] Stuck in a Rut S", "background": "", "description": "Farmer John 最近扩大了他的农场，从奶牛们的角度看来这个农场相当于是无限大了！奶牛们将农场上放牧的区域想作是一个由正方形方格组成的无限大二维方阵，每个方格中均有美味的草（将每个方格看作是棋盘上的一个方格）。Farmer John 的 $N$ 头奶牛（$1≤N≤1000$）初始时位于不同的方格中，一部分朝向北面，一部分朝向东面。\n\n每一小时，每头奶牛会执行以下二者之一：\n\n - 如果她当前所在的方格里的草已经被其他奶牛吃掉了，则她会停下（并从这个时刻开始一直保持停止）。\n - 吃完她当前所在的方格中的所有草，并向她朝向的方向移动一个方格。\n\n经过一段时间，每头奶牛的身后会留下一条被啃秃了的轨迹。\n\n如果两头奶牛在一次移动中移动到了同一个有草的方格，她们会分享这个方格中的草，并在下一个小时继续沿她们朝向的方向移动。\n\n当 Farmer John 看到停止吃草的奶牛时会不高兴，他想要知道谁该为他停止吃草的奶牛受到责备。如果奶牛 $b$\n停在了之前奶牛 $a$ 吃过草的一个方格，我们就称奶牛 $a$ 阻碍了奶牛 $b$。进一步地，如果奶牛 $a$ 阻碍了奶牛 $b$ 且奶牛 $b$ 阻碍了奶牛 $c$，我们认为奶牛 $a$ 也阻碍了奶牛 $c$（也就是说，「阻碍」关系具有传递性）。每头奶牛受到责备的程度与这头奶牛阻碍的奶牛数量一致。请计算每头奶牛受到责备的数量——也就是说，每头奶牛阻碍的奶牛数量。 ", "inputFormat": "输入的第一行包含 $N$。以下 $N$ 行，每行描述一头奶牛的起始位置，包含一个字符 N（表示朝向北面） 或 E（表示朝向东面），以及两个非负整数 $x$ 和 $y$（$0≤x≤10^9$，$0≤y≤10^9$）表示方格的坐标。所有 $x$ 坐标各不相同，所有 $y$ 坐标各不相同。\n\n为了使方向和坐标尽可能明确，如果一头奶牛位于方格 $(x,y)$ 并向北移动，她会到达方格 $(x,y+1)$。如果她向东移动，她会到达方格 $(x+1,y)$。 ", "outputFormat": "输出 $N$ 行。输出的第 $i$ 行包含输入中的第 $i$ 头奶牛受到的责备的数量。 ", "hint": "在这个样例中，奶牛 3 阻碍了奶牛 2，奶牛 4 阻碍了奶牛 5，奶牛 5 阻碍了奶牛 6。根据传递性，奶牛 4 也阻碍了奶牛 6。 \n\n - 测试点 2-5 中，所有坐标不超过 $2000$。\n - 测试点 6-10 没有额外限制。\n\n供题：Brian Dean ", "locale": "zh-CN"}}}
