{"pid": "P4619", "type": "P", "difficulty": 7, "samples": [["5\n10 10 10\n100 100 100\n1000 1000 1000\n10000 10000 10000\n100000 100000 100000", "11536\n51103588\n165949340\n19234764\n176764584"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "各省省选", "山东", "O2优化", "枚举", "剪枝", "莫比乌斯反演"], "title": "[SDOI2018] 旧试题", "background": " - Input file: divsum.in\n - Output file: divsum.out\n - Time limit: 5 seconds\n - Memory limit: 512 megabytes\n \n （注：此处文件输入输出为比赛时要求，在洛谷提交时采用标准输入输出即可。）", "description": "时光匆匆，转眼间又是一年省选季……\n\n这是小 $Q$ 同学第二次参加省队选拔赛。今年，小 $Q$ 痛定思痛，不再冒险偷取试题，而是通过练习旧试题提升个人实力。可是旧试题太多了，小 $Q$ 没日没夜地做题，却看不到前方的光明在哪里。\n\n一天，因做题过度而疲惫入睡的小 $Q$ 梦到自己在考场上遇到了一道好像做过的题目，却怎么也想不起曾经自己是怎么解决它的，直到醒来还心有余悸。\n\n小 $Q$ 眉头一皱，感觉事情不妙，于是他找到了你，希望你能教他解决这道题目。小 $Q$ 依稀记得题目要计算如下表达式的值。\n\n$$\n(\\sum_{i=1}^{A}\\sum_{j=1}^{B}\\sum_{k=1}^{C}d(ijk))\\bmod (10^9+7)\n$$\n\n其中 $d(ijk)$ 表示 $i × j × k$ 的约数个数。", "inputFormat": "第一行包含一个正整数 $T$，表示有 $T$ 组测试数据。\n\n接下来 $T$ 行，每行描述一组测试数据，包含三个整数 $A, B$ 和 $C$，含义见题目描述。", "outputFormat": "对于每组测试数据，输出一行，包含一个整数，表示所求表达式的值。", "hint": "对于 $30$ 分的数据，$1 ≤ A, B, C ≤ 5000$。\n\n对于 $100$ 分的数据，$1 ≤ T ≤ 10, 1 ≤ A, B, C ≤ 10^5, 1 ≤ \\sum{\\max(A, B, C)} ≤ 2 \\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2018] Old Problem", "background": "- Input file: divsum.in  \n- Output file: divsum.out  \n- Time limit: 5 seconds  \n- Memory limit: 512 megabytes  \n\n(Note: The file input/output above was required during the contest. On Luogu, please use standard input/output.)", "description": "Time flies, and it is the NOI Qualifier season again...\n\nThis is student $Q$'s second time taking the provincial team selection contest. This year, after learning a hard lesson, student $Q$ no longer takes the risk of stealing problems, but instead improves personal skills by practicing old problems. However, there are too many old problems. Student $Q$ works on them day and night, yet still cannot see where the light ahead is.\n\nOne day, exhausted from doing too many problems, student $Q$ fell asleep and dreamed that, in the exam room, he encountered a problem that seemed familiar, but he could not remember how he had solved it before. Even after waking up, he was still frightened.\n\nStudent $Q$ frowned, feeling that something was wrong, so he came to you and hoped you could teach him how to solve this problem. Student $Q$ vaguely remembered that the task was to compute the value of the following expression:\n\n$$\n(\\sum_{i=1}^{A}\\sum_{j=1}^{B}\\sum_{k=1}^{C}d(ijk))\\bmod (10^9+7)\n$$\n\nHere, $d(ijk)$ denotes the number of divisors of $i \\times j \\times k$.", "inputFormat": "The first line contains a positive integer $T$, meaning there are $T$ groups of testdata.\n\nThe next $T$ lines each describe one group of testdata, containing three integers $A, B,$ and $C$, with meanings as described above.", "outputFormat": "For each group of testdata, output one line containing one integer, which is the value of the required expression.", "hint": "For the testdata worth $30$ points, $1 \\le A, B, C \\le 5000$.\n\nFor the testdata worth $100$ points, $1 \\le T \\le 10$, $1 \\le A, B, C \\le 10^5$, and $1 \\le \\sum \\max(A, B, C) \\le 2 \\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2018] 旧试题", "background": " - Input file: divsum.in\n - Output file: divsum.out\n - Time limit: 5 seconds\n - Memory limit: 512 megabytes\n \n （注：此处文件输入输出为比赛时要求，在洛谷提交时采用标准输入输出即可。）", "description": "时光匆匆，转眼间又是一年省选季……\n\n这是小 $Q$ 同学第二次参加省队选拔赛。今年，小 $Q$ 痛定思痛，不再冒险偷取试题，而是通过练习旧试题提升个人实力。可是旧试题太多了，小 $Q$ 没日没夜地做题，却看不到前方的光明在哪里。\n\n一天，因做题过度而疲惫入睡的小 $Q$ 梦到自己在考场上遇到了一道好像做过的题目，却怎么也想不起曾经自己是怎么解决它的，直到醒来还心有余悸。\n\n小 $Q$ 眉头一皱，感觉事情不妙，于是他找到了你，希望你能教他解决这道题目。小 $Q$ 依稀记得题目要计算如下表达式的值。\n\n$$\n(\\sum_{i=1}^{A}\\sum_{j=1}^{B}\\sum_{k=1}^{C}d(ijk))\\bmod (10^9+7)\n$$\n\n其中 $d(ijk)$ 表示 $i × j × k$ 的约数个数。", "inputFormat": "第一行包含一个正整数 $T$，表示有 $T$ 组测试数据。\n\n接下来 $T$ 行，每行描述一组测试数据，包含三个整数 $A, B$ 和 $C$，含义见题目描述。", "outputFormat": "对于每组测试数据，输出一行，包含一个整数，表示所求表达式的值。", "hint": "对于 $30$ 分的数据，$1 ≤ A, B, C ≤ 5000$。\n\n对于 $100$ 分的数据，$1 ≤ T ≤ 10, 1 ≤ A, B, C ≤ 10^5, 1 ≤ \\sum{\\max(A, B, C)} ≤ 2 \\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P4620", "type": "P", "difficulty": 6, "samples": [["2\n3 1 2 3 11111 22222 33333 1 1\n1 5\n2 3\n3 6\n7 2 3 7 11111 22222 33333 1 1\n6 9\n4 5\n3 7\n5 2\n2 4\n1 7\n9 6", "3\n14"]], "limits": {"time": [10000, 10000, 10000], "memory": [512000, 512000, 512000]}, "tags": ["动态规划 DP", "2018", "各省省选", "山东", "O2优化", "树形 DP"], "title": "[SDOI2018] 荣誉称号", "background": " - Input file: title.in\n - Output file: title.out\n - Time limit: 10 seconds\n - Memory limit: 512 megabytes", "description": "休闲游戏玩家小 $Q$ 不仅在算法竞赛方面取得了优异的成绩，还在一款收集钻石的游戏中排名很高。\n\n这款游戏一共有 $n$ 种不同类别的钻石，编号依次为 $1$ 到 $n$。小 $Q$ 已经玩了这款游戏很久了，对于第\n$i$ 种钻石，他已经收集到了 $a_i$ 个。这款游戏最大的亮点就是，钻石只有一种获得途径，那就是从商城中购买。具体来说，第 $i$ 种钻石的单价为 $b_i$ 点券。为了鼓励玩家充值，每种钻石都没有数量上限，只要肯充钱，就可以拥有任意多的钻石。但是这款游戏并没有开发 “丢弃道具” 功能，因此小 $Q$ 不能通过丢弃钻石去完成任务。\n\n最近这款游戏推出了一个限时成就任务，完成任务的玩家可以获得荣誉称号，而完成任务条件则是：\n给定正整数 $k$ 和 $m$，对于任意一个整数 $x (x\\ge 2^k)$，$a_{x}+a_{\\lfloor\\frac{x}{2}\\rfloor}+a_{\\lfloor\\frac{x}{4}\\rfloor}+a_{\\lfloor\\frac{x}{8}\\rfloor}+...+a_{\\lfloor\\frac{x}{2^k}\\rfloor}$ 都要是 $m$的倍数。\n\n高玩小 $Q$ 当然想完成这个限时成就任务，但是在充钱之前他想知道他究竟需要多少点券才能完成这个任务。请写一个程序帮助小 $Q$ 计算最少需要的点券数量。", "inputFormat": "第一行包含一个正整数 $T$，表示测试数据的组数。\n\n每组数据第一行包含 $9$ 个正整数 $n, k, m, p, SA, SB, SC, A, B$，其中 $n$ 表示钻石种类数，$k, m$ 表示任\n务条件。\n\n为了在某种程度上减少输入量，$a[]$ 和 $b[]$ 由以下代码生成：\n```\nunsigned int SA, SB, SC;int p, A, B;\nunsigned int rng61(){\n\tSA ^= SA << 16;\n\tSA ^= SA >> 5;\n\tSA ^= SA << 1;\n\tunsigned int t = SA;\n\tSA = SB;\n\tSB = SC;\n\tSC ^= t ^ SA;\n\treturn SC;\n}\nvoid gen(){\n\tscanf(\"%d%d%d%d%u%u%u%d%d\", &n, &k, &m, &p, &SA, &SB, &SC, &A, &B);\n\tfor(int i = 1; i <= p; i++)scanf(\"%d%d\", &a[i], &b[i]);\n\tfor(int i = p + 1; i <= n; i++){\n\t\ta[i] = rng61() % A + 1;\n\t\tb[i] = rng61() % B + 1;\n\t}\n}\n```", "outputFormat": "对于每组数据，输出一行一个整数，即最少需要的点券数量。", "hint": " - $1 ≤ T ≤ 10$，\n - $1 ≤ k ≤ 10$ 且 $2^k ≤ n$，\n - $ 1 ≤ p ≤ min(n, 100000)$，$10000 ≤ SA, SB, SC ≤ 1000000$，\n - $ 1 ≤ A, B, ai, bi ≤ 10^7$。\n\n子任务 $1$（$30$ 分）：满足 $1 ≤ n ≤ 1000$ 且 $m = 2$。\n\n子任务 $2$（$40$ 分）：满足 $1 ≤ n ≤ 10^5$ 且 $m ≤ 200$。\n\n子任务 $3$（$30$ 分）：满足 $1 ≤ n ≤ 10^7$ 且 $m ≤ 200$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2018] Honorary Title", "background": "- Input file: title.in  \n- Output file: title.out  \n- Time limit: 10 seconds.  \n- Memory limit: 512 megabytes.", "description": "Casual game player $Q$ has not only achieved excellent results in algorithm contests, but also ranks very high in a diamond-collecting game.\n\nThis game has $n$ different types of diamonds, numbered from $1$ to $n$. Player $Q$ has played this game for a long time. For type $i$, he has already collected $a_i$ diamonds. The biggest feature of this game is that there is only one way to obtain diamonds: buying them from the shop. Specifically, the unit price of type $i$ is $b_i$ coupons. To encourage players to spend money, there is no quantity limit for any type of diamond: as long as you are willing to pay, you can have as many diamonds as you want. However, the game does not have a “discard item” feature, so $Q$ cannot discard diamonds to complete the task.\n\nRecently, the game launched a limited-time achievement task. Players who complete it can get an honorary title. The completion condition is:\n\nGiven positive integers $k$ and $m$, for any integer $x \\ (x\\ge 2^k)$, the value  \n$a_{x}+a_{\\lfloor\\frac{x}{2}\\rfloor}+a_{\\lfloor\\frac{x}{4}\\rfloor}+a_{\\lfloor\\frac{x}{8}\\rfloor}+...+a_{\\lfloor\\frac{x}{2^k}\\rfloor}$  \nmust be a multiple of $m$.\n\nOf course, skilled player $Q$ wants to complete this limited-time achievement task, but before spending money he wants to know how many coupons he needs to complete it. Please write a program to help $Q$ compute the minimum number of coupons required.", "inputFormat": "The first line contains a positive integer $T$, the number of test cases.\n\nFor each test case, the first line contains $9$ positive integers $n, k, m, p, SA, SB, SC, A, B$, where $n$ is the number of diamond types, and $k, m$ are the task conditions.\n\nTo reduce the input size to some extent, arrays $a[]$ and $b[]$ are generated by the following code:\n```\nunsigned int SA, SB, SC;int p, A, B;\nunsigned int rng61(){\n\tSA ^= SA << 16;\n\tSA ^= SA >> 5;\n\tSA ^= SA << 1;\n\tunsigned int t = SA;\n\tSA = SB;\n\tSB = SC;\n\tSC ^= t ^ SA;\n\treturn SC;\n}\nvoid gen(){\n\tscanf(\"%d%d%d%d%u%u%u%d%d\", &n, &k, &m, &p, &SA, &SB, &SC, &A, &B);\n\tfor(int i = 1; i <= p; i++)scanf(\"%d%d\", &a[i], &b[i]);\n\tfor(int i = p + 1; i <= n; i++){\n\t\ta[i] = rng61() % A + 1;\n\t\tb[i] = rng61() % B + 1;\n\t}\n}\n```", "outputFormat": "For each test case, output one integer per line, the minimum number of coupons required.", "hint": "- $1 ≤ T ≤ 10$.  \n- $1 ≤ k ≤ 10$ and $2^k ≤ n$.  \n- $1 ≤ p ≤ min(n, 100000)$, $10000 ≤ SA, SB, SC ≤ 1000000$.  \n- $1 ≤ A, B, ai, bi ≤ 10^7$.  \n\nConstraints:\n\nSubtask 1 ($30$ points): $1 ≤ n ≤ 1000$ and $m = 2$.  \n\nSubtask 2 ($40$ points): $1 ≤ n ≤ 10^5$ and $m ≤ 200$.  \n\nSubtask 3 ($30$ points): $1 ≤ n ≤ 10^7$ and $m ≤ 200$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2018] 荣誉称号", "background": " - Input file: title.in\n - Output file: title.out\n - Time limit: 10 seconds\n - Memory limit: 512 megabytes", "description": "休闲游戏玩家小 $Q$ 不仅在算法竞赛方面取得了优异的成绩，还在一款收集钻石的游戏中排名很高。\n\n这款游戏一共有 $n$ 种不同类别的钻石，编号依次为 $1$ 到 $n$。小 $Q$ 已经玩了这款游戏很久了，对于第\n$i$ 种钻石，他已经收集到了 $a_i$ 个。这款游戏最大的亮点就是，钻石只有一种获得途径，那就是从商城中购买。具体来说，第 $i$ 种钻石的单价为 $b_i$ 点券。为了鼓励玩家充值，每种钻石都没有数量上限，只要肯充钱，就可以拥有任意多的钻石。但是这款游戏并没有开发 “丢弃道具” 功能，因此小 $Q$ 不能通过丢弃钻石去完成任务。\n\n最近这款游戏推出了一个限时成就任务，完成任务的玩家可以获得荣誉称号，而完成任务条件则是：\n给定正整数 $k$ 和 $m$，对于任意一个整数 $x (x\\ge 2^k)$，$a_{x}+a_{\\lfloor\\frac{x}{2}\\rfloor}+a_{\\lfloor\\frac{x}{4}\\rfloor}+a_{\\lfloor\\frac{x}{8}\\rfloor}+...+a_{\\lfloor\\frac{x}{2^k}\\rfloor}$ 都要是 $m$的倍数。\n\n高玩小 $Q$ 当然想完成这个限时成就任务，但是在充钱之前他想知道他究竟需要多少点券才能完成这个任务。请写一个程序帮助小 $Q$ 计算最少需要的点券数量。", "inputFormat": "第一行包含一个正整数 $T$，表示测试数据的组数。\n\n每组数据第一行包含 $9$ 个正整数 $n, k, m, p, SA, SB, SC, A, B$，其中 $n$ 表示钻石种类数，$k, m$ 表示任\n务条件。\n\n为了在某种程度上减少输入量，$a[]$ 和 $b[]$ 由以下代码生成：\n```\nunsigned int SA, SB, SC;int p, A, B;\nunsigned int rng61(){\n\tSA ^= SA << 16;\n\tSA ^= SA >> 5;\n\tSA ^= SA << 1;\n\tunsigned int t = SA;\n\tSA = SB;\n\tSB = SC;\n\tSC ^= t ^ SA;\n\treturn SC;\n}\nvoid gen(){\n\tscanf(\"%d%d%d%d%u%u%u%d%d\", &n, &k, &m, &p, &SA, &SB, &SC, &A, &B);\n\tfor(int i = 1; i <= p; i++)scanf(\"%d%d\", &a[i], &b[i]);\n\tfor(int i = p + 1; i <= n; i++){\n\t\ta[i] = rng61() % A + 1;\n\t\tb[i] = rng61() % B + 1;\n\t}\n}\n```", "outputFormat": "对于每组数据，输出一行一个整数，即最少需要的点券数量。", "hint": " - $1 ≤ T ≤ 10$，\n - $1 ≤ k ≤ 10$ 且 $2^k ≤ n$，\n - $ 1 ≤ p ≤ min(n, 100000)$，$10000 ≤ SA, SB, SC ≤ 1000000$，\n - $ 1 ≤ A, B, ai, bi ≤ 10^7$。\n\n子任务 $1$（$30$ 分）：满足 $1 ≤ n ≤ 1000$ 且 $m = 2$。\n\n子任务 $2$（$40$ 分）：满足 $1 ≤ n ≤ 10^5$ 且 $m ≤ 200$。\n\n子任务 $3$（$30$ 分）：满足 $1 ≤ n ≤ 10^7$ 且 $m ≤ 200$。", "locale": "zh-CN"}}}
{"pid": "P4621", "type": "P", "difficulty": 6, "samples": [["3 3 1\n2 2\n1 1 R\n010\n000\n000", "3"], ["3 4 2\n2 2\n3 4 R\n2327\n6009\n2112\n3 2 R\n1310\n2101\n1301", "8"], ["4 4 3\n4 3\n1 1 U\n1001\n0240\n3322\n2327\n1 3 L\n9521\n2390\n3020\n2421\n2 2 D\n3397\n2013\n1102\n7302", "296"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["2012", "COCI（克罗地亚）"], "title": "[COCI 2012/2013 #6] BAKTERIJE", "background": "", "description": "一个 $N$ 行，$M$ 列的矩形区域，行从上到下从 $1$ 到 $N$ 编号，列从左到右从 $1$ 到 $M$ 编号，有 $K$ 个细菌被放在这些单元格内，每个细菌都有自己的方向和运动规则。规则如下：读取自己在这个单元格的数字 $X$，顺时针转 $90^{\\circ}$ $X$ 次，如果它面对矩形边界，则转 $180^{\\circ}$，最后进入自己面向的单元格。我们放置一个陷阱在某一单元格，当所有细菌同时进入陷阱时，陷阱被激活，细菌会在一秒内被消灭。\n\n给定所有信息，求什么时候所有细菌被消灭。", "inputFormat": "第一行三个正整数 $N, M, K$。\n\n接下来一行，两个数 $x, y$ 表示在 $x$ 行 $y$ 列处有一个陷阱。\n\n接下来依次描述每一个细菌：\n- 首先是一行两个数 $X,Y$ 和一个字母 $C$，分别表示行列坐标和它的方向，`U` 表示上，`D` 表示下，`L` 表示左，`R` 表示右。\n- 接下来一个矩阵，表示这个细菌在这个每一个单元格上的$X$，$0\\leq X\\leq 9$。", "outputFormat": "一行一个数，表示细菌被杀死的最后时间，如果无法全部消灭则输出 $-1$。", "hint": "$3\\leq N\\leq 50$，$3\\leq M \\leq 50$，$1\\leq K\\leq 5$。", "locale": "zh-CN", "translations": {"en": {"title": "[COCI 2012/2013 #6] BAKTERIJE", "background": "", "description": "There is a rectangular area with $N$ rows and $M$ columns. Rows are numbered from $1$ to $N$ from top to bottom, and columns are numbered from $1$ to $M$ from left to right. There are $K$ bacteria placed in these cells. Each bacterium has its own direction and movement rules.\n\nThe rules are as follows: it reads the digit $X$ in its current cell, then turns clockwise by $90^{\\circ}$ exactly $X$ times. If it is facing the boundary of the rectangle, it turns $180^{\\circ}$. Finally, it moves into the cell it is facing.\n\nWe place a trap in one cell. When all bacteria enter the trap at the same time, the trap is activated, and the bacteria will be destroyed within one second.\n\nGiven all information, determine when all bacteria are destroyed.", "inputFormat": "The first line contains three positive integers $N, M, K$.\n\nThe next line contains two integers $x, y$, meaning there is a trap at row $x$, column $y$.\n\nThen each bacterium is described in order:\n- First, one line contains two integers $X, Y$ and one letter $C$, representing its row and column coordinates and its direction. `U` means up, `D` means down, `L` means left, and `R` means right.\n- Next is a matrix giving the value $X$ for this bacterium in every cell, with $0\\leq X\\leq 9$.", "outputFormat": "Output one integer on one line: the last time when the bacteria are killed. If it is impossible to destroy all of them, output $-1$.", "hint": "Constraints: $3\\leq N\\leq 50$, $3\\leq M \\leq 50$, $1\\leq K\\leq 5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[COCI 2012/2013 #6] BAKTERIJE", "background": "", "description": "一个 $N$ 行，$M$ 列的矩形区域，行从上到下从 $1$ 到 $N$ 编号，列从左到右从 $1$ 到 $M$ 编号，有 $K$ 个细菌被放在这些单元格内，每个细菌都有自己的方向和运动规则。规则如下：读取自己在这个单元格的数字 $X$，顺时针转 $90^{\\circ}$ $X$ 次，如果它面对矩形边界，则转 $180^{\\circ}$，最后进入自己面向的单元格。我们放置一个陷阱在某一单元格，当所有细菌同时进入陷阱时，陷阱被激活，细菌会在一秒内被消灭。\n\n给定所有信息，求什么时候所有细菌被消灭。", "inputFormat": "第一行三个正整数 $N, M, K$。\n\n接下来一行，两个数 $x, y$ 表示在 $x$ 行 $y$ 列处有一个陷阱。\n\n接下来依次描述每一个细菌：\n- 首先是一行两个数 $X,Y$ 和一个字母 $C$，分别表示行列坐标和它的方向，`U` 表示上，`D` 表示下，`L` 表示左，`R` 表示右。\n- 接下来一个矩阵，表示这个细菌在这个每一个单元格上的$X$，$0\\leq X\\leq 9$。", "outputFormat": "一行一个数，表示细菌被杀死的最后时间，如果无法全部消灭则输出 $-1$。", "hint": "$3\\leq N\\leq 50$，$3\\leq M \\leq 50$，$1\\leq K\\leq 5$。", "locale": "zh-CN"}}}
{"pid": "P4622", "type": "P", "difficulty": 4, "samples": [["3\n-1 2 -1", "0"], ["3\n-1 -1 -1", "2"], ["6\n-1 -1 -1 2 -1 -1", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["动态规划 DP", "2012", "COCI（克罗地亚）"], "title": "[COCI 2012/2013 #6] JEDAN", "background": "COCI", "description": "有$N$个数排成一行(数值代表高度)，最初所有的数都为零，你可以选择连续的一段等高的数，将它们都增加$1$(除了开头和结尾那个数)如下图表示了两次操作:\n\n![](https://cdn.luogu.com.cn/upload/pic/19412.png)\n\n现在有一些数字看不清了，我们用$-1$表示，请你根据留下的数字，推出有多少\n种可能的方案。使得留下的数字正好满足上面的操作方法。\n", "inputFormat": "第一行一个正整数$N$表示数的个数。\n接下来一行$N$个数，依次表示每一个数的大小，$-1$表示看不清楚，你可以用任\n意满足条件的数代替。第$i$个数用$h_i$表示", "outputFormat": "一个数，表示所有可能的方案对$1000000007$ 求余的值。", "hint": "- $(1≤N≤10000)$\n- $(-1 ≤ h_i ≤10 000)$", "locale": "zh-CN", "translations": {"en": {"title": "[COCI 2012/2013 #6] JEDAN", "background": "COCI", "description": "There are $N$ numbers in a row (their values represent heights). Initially, all numbers are zero. You may choose a continuous segment of numbers with the same height, and increase all of them by $1$ (except the first and last numbers of the segment). The figure below shows two operations:\n\n![](https://cdn.luogu.com.cn/upload/pic/19412.png)\n\nNow, some numbers cannot be seen clearly, and we use $-1$ to represent them. Based on the remaining numbers, determine how many possible valid arrays there are such that the visible numbers fit exactly the operation rules above.", "inputFormat": "The first line contains a positive integer $N$, the number of numbers.  \nThe next line contains $N$ integers, representing the height of each number in order. A value of $-1$ means it cannot be seen clearly; you may replace it with any number that satisfies the conditions. Let the $i$-th number be $h_i$.", "outputFormat": "Output one integer: the number of all possible valid arrays modulo $1000000007$.", "hint": "- $(1 \\le N \\le 10000)$.\n- $(-1 \\le h_i \\le 10000)$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[COCI 2012/2013 #6] JEDAN", "background": "COCI", "description": "有$N$个数排成一行(数值代表高度)，最初所有的数都为零，你可以选择连续的一段等高的数，将它们都增加$1$(除了开头和结尾那个数)如下图表示了两次操作:\n\n![](https://cdn.luogu.com.cn/upload/pic/19412.png)\n\n现在有一些数字看不清了，我们用$-1$表示，请你根据留下的数字，推出有多少\n种可能的方案。使得留下的数字正好满足上面的操作方法。\n", "inputFormat": "第一行一个正整数$N$表示数的个数。\n接下来一行$N$个数，依次表示每一个数的大小，$-1$表示看不清楚，你可以用任\n意满足条件的数代替。第$i$个数用$h_i$表示", "outputFormat": "一个数，表示所有可能的方案对$1000000007$ 求余的值。", "hint": "- $(1≤N≤10000)$\n- $(-1 ≤ h_i ≤10 000)$", "locale": "zh-CN"}}}
{"pid": "P4623", "type": "P", "difficulty": 2, "samples": [["3\n1 0 0 2 2 2\n1 3 3 5 4 0\n5 4 4 5 4 4\n4\nx = 4\nx = 1\ny = 3\ny = 1", "0\n1\n1\n2"], ["4\n2 7 6 0 0 5\n7 1 7 10 11 11\n5 10 2 9 6 8\n1 9 10 10 4 1\n4\ny = 6\nx = 2\nx = 4\nx = 9", "3\n2\n3\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["2012", "前缀和", "差分", "COCI（克罗地亚）"], "title": "[COCI 2012/2013 #6] BUREK", "background": "COCI", "description": "给定 $N$ 个三角形，和 $M$ 条直线，直线要么平行于 $x$ 轴，要么平行于 $y$ 轴，问这 $M$ 条直线分别穿过多少个三角形。\n\n**（一条直线穿过一个三角形，当且仅当这条直线可以将这个三角形分成两个面积均大于零的多边形）。**", "inputFormat": "输入的第一行包含一个正整数 $N$，表示三角形的个数。\n\n接下来 $N$ 行，每行三个坐标 $(x_1,y_1)$，$(x_2,y_2)$，$(x_3,y_3)$ 表示三个点，且这三点不共线，描述一个三角形。所有坐标均为非负整数，三角形可以重叠。\n\n接下来一行包含一个正整数 $M$，表示直线的条数。\n\n接下来 $M$ 行，每行一个字符串 `x = c` 或 `y = c`（注意等号两边的空格），描述一条直线。其中 `c` 为非负整数。", "outputFormat": "对于每一条直线输出一个整数，表示它穿过的三角形的个数。", "hint": "**【数据范围】**\n\n对于 $40 \\%$ 的数据，$M \\le 300$；\n\n另有 $40 \\%$ 的数据，所有三角形的坐标 $< 1000$；\n\n对于 $100 \\%$ 的数据，$2 \\le N,M \\le 10^5$，$0 \\le x_1,y_1,x_2,y_2,x_3,y_3 < 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[COCI 2012/2013 #6] BUREK", "background": "COCI", "description": "Given $N$ triangles and $M$ lines. Each line is either parallel to the $x$ axis or parallel to the $y$ axis. For each of the $M$ lines, find how many triangles it passes through.\n\n**(A line passes through a triangle if and only if the line can split the triangle into two polygons whose areas are both greater than zero.)**", "inputFormat": "The first line contains a positive integer $N$, the number of triangles.\n\nThe next $N$ lines each contain three coordinates $(x_1,y_1)$, $(x_2,y_2)$, $(x_3,y_3)$, representing three points. These three points are not collinear and form a triangle. All coordinates are non-negative integers, and triangles may overlap.\n\nThe next line contains a positive integer $M$, the number of lines.\n\nThe next $M$ lines each contain a string `x = c` or `y = c` (note the spaces on both sides of the equals sign), describing a line. Here `c` is a non-negative integer.", "outputFormat": "For each line, output one integer, the number of triangles it passes through.", "hint": "**Constraints**\n\nFor $40\\%$ of the testdata, $M \\le 300$.\n\nFor another $40\\%$ of the testdata, all triangle coordinates are $< 1000$.\n\nFor $100\\%$ of the testdata, $2 \\le N,M \\le 10^5$, and $0 \\le x_1,y_1,x_2,y_2,x_3,y_3 < 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[COCI 2012/2013 #6] BUREK", "background": "COCI", "description": "给定 $N$ 个三角形，和 $M$ 条直线，直线要么平行于 $x$ 轴，要么平行于 $y$ 轴，问这 $M$ 条直线分别穿过多少个三角形。\n\n**（一条直线穿过一个三角形，当且仅当这条直线可以将这个三角形分成两个面积均大于零的多边形）。**", "inputFormat": "输入的第一行包含一个正整数 $N$，表示三角形的个数。\n\n接下来 $N$ 行，每行三个坐标 $(x_1,y_1)$，$(x_2,y_2)$，$(x_3,y_3)$ 表示三个点，且这三点不共线，描述一个三角形。所有坐标均为非负整数，三角形可以重叠。\n\n接下来一行包含一个正整数 $M$，表示直线的条数。\n\n接下来 $M$ 行，每行一个字符串 `x = c` 或 `y = c`（注意等号两边的空格），描述一条直线。其中 `c` 为非负整数。", "outputFormat": "对于每一条直线输出一个整数，表示它穿过的三角形的个数。", "hint": "**【数据范围】**\n\n对于 $40 \\%$ 的数据，$M \\le 300$；\n\n另有 $40 \\%$ 的数据，所有三角形的坐标 $< 1000$；\n\n对于 $100 \\%$ 的数据，$2 \\le N,M \\le 10^5$，$0 \\le x_1,y_1,x_2,y_2,x_3,y_3 < 10^6$。", "locale": "zh-CN"}}}
{"pid": "P4624", "type": "P", "difficulty": 6, "samples": [["10 9 18 150 0", "40"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["搜索", "2000", "剪枝", "CTSC/CTS"], "title": "[CTSC2000] 采矿【测试数据有误】", "background": "一架人类的航天飞机将人类基地建在了一个荒芜的星球上。面对紧缺的能源，他们只能在最短的时间内用 $\\text{SCV}$ （一种智能机器人）采集必须的矿藏。对于这个艰巨的任务，他们希望得到编程高手们的帮助。", "description": "在这个星球上，有着两种不同的矿。一种被称为“冰矿”，是一种类似 $\\text{H}_{2}\\text{O}$ 的凝固物的蓝色高能矿藏。另一种被称为“气矿”，是四氯化碳的一种异态形式。\n\n人类通过这两种矿的提炼，获得可供生存的能源。 $\\text{SCV}$ 是一种唯一可以采集这两种矿的智能机器人。他们每采集一次冰矿需要花费 $t_{1}$ 的时间，每采集一次气矿需要花费 $t_{2}$ 的时间。采集结束后，将得到 $8$ 个冰矿或者 $8$ 个气矿单位。**每一次 $\\text{SCV}$ 只能采集冰矿或者是气矿中的一种**。\n\n $\\text{SCV}$ 可以通过主基地制造。每制造一个 $\\text{SCV}$ ，主基地将花费 $50$ 单位的冰矿。而主基地由于制造能力有限，在同一时间只能制造**一个** $\\text{SCV}$ 。制造一个 $\\text{SCV}$ 需要 $t_{3}$ 的时间。\n\n在开始时，人类拥有 $50$ 个单位的冰矿和 $4$ 个 $\\text{SCV}$ 。他们需要采集到 $p_{1}$ 单位的冰矿和 $p_{2}$ 单位的气矿。请计算出他们需要的**最短时间**。", "inputFormat": "输入文件只有一行，依次为 $t_{1}$ , $t_{2}$ , $t_{3}$ , $p_{1}$ , $p_{2}$ ，每两个数字之间有一个空格。", "outputFormat": "输出文件只包含一个数字，表示可以达到目标的最少时间。", "hint": "$1 \\leq t_{1},t_{2},t_{3} \\leq 18$，$0 \\leq p_{1},p_{2} \\leq 150$。数据从合法数据中随机均匀选取。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CTSC2000] 采矿【测试数据有误】", "background": "一架人类的航天飞机将人类基地建在了一个荒芜的星球上。面对紧缺的能源，他们只能在最短的时间内用 $\\text{SCV}$ （一种智能机器人）采集必须的矿藏。对于这个艰巨的任务，他们希望得到编程高手们的帮助。", "description": "在这个星球上，有着两种不同的矿。一种被称为“冰矿”，是一种类似 $\\text{H}_{2}\\text{O}$ 的凝固物的蓝色高能矿藏。另一种被称为“气矿”，是四氯化碳的一种异态形式。\n\n人类通过这两种矿的提炼，获得可供生存的能源。 $\\text{SCV}$ 是一种唯一可以采集这两种矿的智能机器人。他们每采集一次冰矿需要花费 $t_{1}$ 的时间，每采集一次气矿需要花费 $t_{2}$ 的时间。采集结束后，将得到 $8$ 个冰矿或者 $8$ 个气矿单位。**每一次 $\\text{SCV}$ 只能采集冰矿或者是气矿中的一种**。\n\n $\\text{SCV}$ 可以通过主基地制造。每制造一个 $\\text{SCV}$ ，主基地将花费 $50$ 单位的冰矿。而主基地由于制造能力有限，在同一时间只能制造**一个** $\\text{SCV}$ 。制造一个 $\\text{SCV}$ 需要 $t_{3}$ 的时间。\n\n在开始时，人类拥有 $50$ 个单位的冰矿和 $4$ 个 $\\text{SCV}$ 。他们需要采集到 $p_{1}$ 单位的冰矿和 $p_{2}$ 单位的气矿。请计算出他们需要的**最短时间**。", "inputFormat": "输入文件只有一行，依次为 $t_{1}$ , $t_{2}$ , $t_{3}$ , $p_{1}$ , $p_{2}$ ，每两个数字之间有一个空格。", "outputFormat": "输出文件只包含一个数字，表示可以达到目标的最少时间。", "hint": "$1 \\leq t_{1},t_{2},t_{3} \\leq 18$，$0 \\leq p_{1},p_{2} \\leq 150$。数据从合法数据中随机均匀选取。", "locale": "zh-CN"}}}
{"pid": "P4625", "type": "P", "difficulty": 0, "samples": [["6\n1 2\n2 3\n4 5\n5 6\n2 5", "3\n2\n3"], ["12\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n2 8\n3 9\n4 10\n5 11\n6 12", "6\n2\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "各省省选", "上海", "Special Judge"], "title": "[SHOI2009] 巴士路线", "background": "", "description": "OItown周围有n个小村庄。村庄与村庄之间有公路，每一条公路连接两个村庄。因为这些村庄并不富裕，所以，当初建公路时，这些公路只是恰好将这些村庄连通，也就是说任意从一个村庄沿着公路走到另一个村庄的方式都是唯一的。于是，有时两个很近的村庄之间要走很长的路。所以，村民们就希望能开通这些公路上的公共交通路线，方便大家的出行。\n\n巴士运营公司采纳了这个意见。同时，巴士公司认为这些巴士线路必须满足下述条件：\n\n1.每条巴士线路的起点和终点都在村庄内，巴士开行的线路都沿着公路；\n\n2.每条公路都要有巴士线路覆盖，这样村民们的出行就只需要换成巴士车就行了；\n\n3.每条公路只被一条巴士线路覆盖，且只被覆盖一次，否则巴士公司觉得在成本上不划算；\n\n4.巴士线路的总数应当最少，这样才能方便管理。\n\n例如，如果6个村庄之间的5条公路是这样的：\n\n![](https://cdn.luogu.com.cn/upload/pic/19772.png)\n\n那么这样的3条巴士线路就能满足上面的条件：1-2-3，2-4，5-4-6。\n\n不过，居民们自然认为“巴士换乘”是不方便的，因此他们希望从一个村庄乘车去另一个村庄的路上换乘次数的最大值尽可能少。例如上面这个线路安排中，从村庄1到村庄6需要换成2次，是最大的换乘次数。\n\n另一方面，巴士公司认为，一条公交线路越长意味着，一旦巴士车发生故障，受影响耽误时间的乘客就越多。所以巴士公司希望，最长的一条线路尽可能短。所谓短，就是途经的村庄少。\n\n现在，这个巴士线路设计的任务交给了参加SHTSC的你，你当然要同时考虑上面两方面的因素，所以，你必须计算出：(1)换乘次数的最大值最小可能值(2)最长的线路途经村庄数的最小可能值。", "inputFormat": "输入数据的第一行是一个整数n，表示村庄的数目。\n\n接下去每行有两个整数x、y，分别描述一条公路，表示村庄x、y之间有一条公路。\n\n输入文件保证，每条公路只会被描述一次。", "outputFormat": "输出文件有三行：\n\n第一行是一个整数，表示公交线路安排中包含的路线数。\n\n第二行是一个整数，表示换乘次数的最大值的最小可能值。\n\n第三行是一个整数，表示最长的线路途经村庄数的最小可能值。", "hint": "如果你的输出的第一行与标准答案相等，你能得2分。\n\n如果你的输出的第二行与标准答案相等，你能得4分。\n\n如果你的输出的第三行与标准答案相等，你能得4分。\n\n对于70%的数据：n<=300\n对于100%的数据：n<=$10^5$", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2009] Bus Routes", "background": "", "description": "There are $n$ small villages around OItown. There are roads between villages, and each road connects two villages. Because these villages are not wealthy, when the roads were built, they were built just enough to make all villages connected. That is, for any two villages, there is a unique way to walk from one to the other along the roads. Therefore, sometimes two villages that are very close still require a long walk along the roads. So the villagers hope to open public transport routes on these roads to make travel more convenient.\n\nThe bus operating company accepted this suggestion. At the same time, the company requires that the bus routes must satisfy the following conditions:\n\n1. The start and end points of each bus route are in villages, and the bus runs along the roads.\n2. Every road must be covered by some bus route, so that villagers only need to switch to taking buses.\n3. Each road is covered by exactly one bus route, and is covered only once. Otherwise, the company thinks it is not cost-effective.\n4. The total number of bus routes should be as small as possible, to make management easier.\n\nFor example, if the $5$ roads among $6$ villages are like this:\n\n![](https://cdn.luogu.com.cn/upload/pic/19772.png)\n\nThen the following $3$ bus routes can satisfy the conditions above: $1-2-3$, $2-4$, $5-4-6$.\n\nHowever, the residents naturally think that “bus transfers” are inconvenient, so they hope that the maximum number of transfers needed when traveling from one village to another is as small as possible. For example, in the route arrangement above, going from village $1$ to village $6$ requires $2$ transfers, which is the maximum number of transfers.\n\nOn the other hand, the bus company believes that a longer bus route means that if a bus breaks down, more passengers will be affected and delayed. Therefore, the company hopes that the longest route is as short as possible. “Short” means it passes through fewer villages.\n\nNow the task of designing the bus routes is given to you, a contestant of SHTSC. You must consider both factors above, so you need to compute:\n(1) the minimum possible value of the maximum number of transfers.\n(2) the minimum possible value of the number of villages passed through by the longest route.", "inputFormat": "The first line of the input contains an integer $n$, the number of villages.\n\nEach of the following lines contains two integers $x$ and $y$, describing a road, meaning there is a road between villages $x$ and $y$.\n\nThe input guarantees that each road is described only once.", "outputFormat": "The output has three lines:\n\nThe first line contains an integer, the number of routes in the bus route arrangement.\n\nThe second line contains an integer, the minimum possible value of the maximum number of transfers.\n\nThe third line contains an integer, the minimum possible value of the number of villages passed through by the longest route.", "hint": "If the first line of your output is the same as the standard answer, you can get $2$ points.\n\nIf the second line of your output is the same as the standard answer, you can get $4$ points.\n\nIf the third line of your output is the same as the standard answer, you can get $4$ points.\n\nConstraints:\n\nFor $70\\%$ of the testdata: $n \\le 300$.\nFor $100\\%$ of the testdata: $n \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2009] 巴士路线", "background": "", "description": "OItown周围有n个小村庄。村庄与村庄之间有公路，每一条公路连接两个村庄。因为这些村庄并不富裕，所以，当初建公路时，这些公路只是恰好将这些村庄连通，也就是说任意从一个村庄沿着公路走到另一个村庄的方式都是唯一的。于是，有时两个很近的村庄之间要走很长的路。所以，村民们就希望能开通这些公路上的公共交通路线，方便大家的出行。\n\n巴士运营公司采纳了这个意见。同时，巴士公司认为这些巴士线路必须满足下述条件：\n\n1.每条巴士线路的起点和终点都在村庄内，巴士开行的线路都沿着公路；\n\n2.每条公路都要有巴士线路覆盖，这样村民们的出行就只需要换成巴士车就行了；\n\n3.每条公路只被一条巴士线路覆盖，且只被覆盖一次，否则巴士公司觉得在成本上不划算；\n\n4.巴士线路的总数应当最少，这样才能方便管理。\n\n例如，如果6个村庄之间的5条公路是这样的：\n\n![](https://cdn.luogu.com.cn/upload/pic/19772.png)\n\n那么这样的3条巴士线路就能满足上面的条件：1-2-3，2-4，5-4-6。\n\n不过，居民们自然认为“巴士换乘”是不方便的，因此他们希望从一个村庄乘车去另一个村庄的路上换乘次数的最大值尽可能少。例如上面这个线路安排中，从村庄1到村庄6需要换成2次，是最大的换乘次数。\n\n另一方面，巴士公司认为，一条公交线路越长意味着，一旦巴士车发生故障，受影响耽误时间的乘客就越多。所以巴士公司希望，最长的一条线路尽可能短。所谓短，就是途经的村庄少。\n\n现在，这个巴士线路设计的任务交给了参加SHTSC的你，你当然要同时考虑上面两方面的因素，所以，你必须计算出：(1)换乘次数的最大值最小可能值(2)最长的线路途经村庄数的最小可能值。", "inputFormat": "输入数据的第一行是一个整数n，表示村庄的数目。\n\n接下去每行有两个整数x、y，分别描述一条公路，表示村庄x、y之间有一条公路。\n\n输入文件保证，每条公路只会被描述一次。", "outputFormat": "输出文件有三行：\n\n第一行是一个整数，表示公交线路安排中包含的路线数。\n\n第二行是一个整数，表示换乘次数的最大值的最小可能值。\n\n第三行是一个整数，表示最长的线路途经村庄数的最小可能值。", "hint": "如果你的输出的第一行与标准答案相等，你能得2分。\n\n如果你的输出的第二行与标准答案相等，你能得4分。\n\n如果你的输出的第三行与标准答案相等，你能得4分。\n\n对于70%的数据：n<=300\n对于100%的数据：n<=$10^5$", "locale": "zh-CN"}}}
{"pid": "P4626", "type": "P", "difficulty": 3, "samples": [["10", "2520"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "素数判断,质数,筛法", "bitset"], "title": "一道水题 II", "background": "", "description": "一天，szb 在上学的路上遇到了灰太狼。\n\n灰太狼：帮我们做出这道题就放了你。  \nszb：什么题？  \n灰太狼：求一个能被 $[1,n]$ 内所有数整除的最小数字，并对 $100000007$ 取模。  \nszb：这题太水了，就让我小弟来做好了。\n\n然后你就光荣的接受了这个任务。", "inputFormat": "一行一个数 $n$。", "outputFormat": "一行一个数 $ans$。", "hint": "$n \\le 10^8$", "locale": "zh-CN", "translations": {"en": {"title": "A Very Easy Problem II", "background": "", "description": "One day, on the way to school, szb met Grey Wolf.\n\nGrey Wolf: If you solve this problem for us, we will let you go.  \nszb: What problem?  \nGrey Wolf: Find the smallest number that is divisible by every number in $[1,n]$, and take it modulo $100000007$.  \nszb: This is too easy. I will have my little brother do it.\n\nThen you proudly accepted this task.", "inputFormat": "One line with one number $n$.", "outputFormat": "One line with one number $ans$.", "hint": "$n \\le 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "一道水题 II", "background": "", "description": "一天，szb 在上学的路上遇到了灰太狼。\n\n灰太狼：帮我们做出这道题就放了你。  \nszb：什么题？  \n灰太狼：求一个能被 $[1,n]$ 内所有数整除的最小数字，并对 $100000007$ 取模。  \nszb：这题太水了，就让我小弟来做好了。\n\n然后你就光荣的接受了这个任务。", "inputFormat": "一行一个数 $n$。", "outputFormat": "一行一个数 $ans$。", "hint": "$n \\le 10^8$", "locale": "zh-CN"}}}
{"pid": "P4627", "type": "P", "difficulty": 6, "samples": [["5\nLLLLB\n3\n1 3 6\n0 3 R\n1 3 6", "2\n1"], ["8\nLLLLBRRR\n7\n1 1 9\n1 4 7\n0 2 R\n1 1 9\n1 2 9\n0 7 B\n1 3 5", "4\n2\n1\n0\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "各省省选", "上海"], "title": "[SHOI2010] 滚动的正四面体", "background": "", "description": "正四面体总共有4个面，每个面都是一个正三角形。现在把它的一个面标记上字母A，如图 3中所示，A标记在底面上：\n\n![](https://cdn.luogu.com.cn/upload/pic/19848.png)\n\n一个正四面体的一次滚动显然有3个方向可以选择：向左（L）、向右（R）、向后（B）。如图 4所示：\n\n![](https://cdn.luogu.com.cn/upload/pic/19850.png)\n\n于是，这个正四面体的滚动过程就可以用一个只包含“L”“R”“B”的字符串来描述。\n\n初始时，正四面体的A面朝下，现在SECSA将给这个正四面体一串滚动指令——当然就是一个这样的字符串——让这个正四面体每秒滚动一下。也就是说，第1秒内正四面体A面朝下，第1秒末执行第一条指令，第2秒末执行第2条指令，依次类推，直至将整个指令串执行完毕。\n\n你的任务就是当SECSA询问你的时候告诉他：这个正四面体在第L秒到第R秒内A面有多少秒朝着地面。\n\n当然，SECSA可能因为对这个正四面体的滚动路径不满意，他随时会修改他的某一条指令。因此你的程序应该能执行下面两个操作：\n\n(1)接受SECSA修个第i条指令的信息\n\n(2)回答SECSA的“在第L秒到第R秒内A面有多少秒朝着地面”的询问\n\n例如，假如原指令串为“LLLLB”，那么第1、4、6秒内A面是朝下的。此时，如果SECSA向你询问第3秒到第6秒的情况，你就应该回答“2”。而SECSA将第3条指令修改为“R”的话，指令串就变成了“LLRLB”，那么正四面体就只有在第1、5秒内A面朝下了。如图 5所示：\n\n![](https://cdn.luogu.com.cn/upload/pic/19851.png)\n\n", "inputFormat": "输入文件的第一行是一个整数n，表示指令串中包含的指令条数。\n\n输入文件的第二行是一个字符串，共包含n个字符，每个字符是“L”“R”“B”之一，表示初始的指令串。\n\n输入文件的第三行是一个整数m，表示你的程序需要处理的操作总数。\n\n接下去m行，每行描述一个操作，为以下两种格式之一：\n\n(1)0 i c：表示把第i个操作改成c，c为“L”“R”“B”之一\n\n(2)1 L R：表示询问第L秒到第R秒内，A面有多少秒朝下\n\n输入文件保证：1<=i<=n，1<=L<=R<=n+1。", "outputFormat": "输出文件对于每一个询问操作依次输出你的程序给出的回答，每个回答为一个整数，占一行。", "hint": "第1个样例就是问题描述中的例子\n\n在第2个样例中，按照原指令“LLLLBRRR”，则第1、4、6、9秒内A面向下；按照第一次修改后的指令“LRLLBRRR”，则只有第1秒内A面向下；按照第二次修改后的指令“LRLLBRBR”，则第1、9秒内A面向下。\n\n1<=n<=60000\n\n1<=m<=150000", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2010] Rolling Regular Tetrahedron", "background": "", "description": "A regular tetrahedron has 4 faces, and each face is an equilateral triangle. Now mark one of its faces with the letter A. As shown in Figure 3, A is marked on the bottom face:\n\n![](https://cdn.luogu.com.cn/upload/pic/19848.png)\n\nIn one roll, a regular tetrahedron clearly has 3 possible directions: left (L), right (R), and back (B). As shown in Figure 4:\n\n![](https://cdn.luogu.com.cn/upload/pic/19850.png)\n\nTherefore, the rolling process of this tetrahedron can be described by a string containing only “L”, “R”, and “B”.\n\nInitially, face A of the tetrahedron faces downward. Now SECSA will give this tetrahedron a sequence of rolling instructions—of course, such a string—and make the tetrahedron roll once per second. That is, during the 1st second, face A faces downward; at the end of the 1st second the first instruction is executed; at the end of the 2nd second the second instruction is executed; and so on, until the whole instruction string is executed.\n\nYour task is: when SECSA asks you, tell him how many seconds, from the L-th second to the R-th second, face A is facing the ground.\n\nOf course, SECSA may be dissatisfied with the rolling path of this tetrahedron, and he may modify any one instruction at any time. Therefore, your program should be able to perform the following two operations:\n\n(1) Accept SECSA’s modification of the i-th instruction.\n\n(2) Answer SECSA’s query: “From the L-th second to the R-th second, how many seconds is face A facing the ground?”\n\nFor example, suppose the original instruction string is “LLLLB”. Then during the 1st, 4th, and 6th seconds, face A is facing downward. At this time, if SECSA asks about the 3rd second to the 6th second, you should answer “2”. If SECSA changes the 3rd instruction to “R”, the instruction string becomes “LLRLB”, and then the tetrahedron is facing downward only during the 1st and 5th seconds. As shown in Figure 5:\n\n![](https://cdn.luogu.com.cn/upload/pic/19851.png)", "inputFormat": "The first line of the input file is an integer $n$, indicating the number of instructions in the instruction string.\n\nThe second line is a string containing $n$ characters. Each character is one of “L”, “R”, and “B”, representing the initial instruction string.\n\nThe third line is an integer $m$, indicating the total number of operations your program needs to process.\n\nIn the next $m$ lines, each line describes an operation in one of the following two formats:\n\n(1) `0 i c`: Change the $i$-th instruction to $c$, where $c$ is one of “L”, “R”, and “B”.\n\n(2) `1 L R`: Query how many seconds, from the $L$-th second to the $R$-th second, face A is facing downward.\n\nThe input guarantees: $1<=i<=n$, $1<=L<=R<=n+1$.", "outputFormat": "For each query operation, output your program’s answer in order. Each answer is an integer, one per line.", "hint": "The first sample is the example in the problem description.\n\nIn the second sample, with the original instructions “LLLLBRRR”, face A faces downward during the 1st, 4th, 6th, and 9th seconds. After the first modification, the instructions become “LRLLBRRR”, and then face A faces downward only during the 1st second. After the second modification, the instructions become “LRLLBRBR”, and then face A faces downward during the 1st and 9th seconds.\n\nConstraints:\n\n$1<=n<=60000$\n\n$1<=m<=150000$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2010] 滚动的正四面体", "background": "", "description": "正四面体总共有4个面，每个面都是一个正三角形。现在把它的一个面标记上字母A，如图 3中所示，A标记在底面上：\n\n![](https://cdn.luogu.com.cn/upload/pic/19848.png)\n\n一个正四面体的一次滚动显然有3个方向可以选择：向左（L）、向右（R）、向后（B）。如图 4所示：\n\n![](https://cdn.luogu.com.cn/upload/pic/19850.png)\n\n于是，这个正四面体的滚动过程就可以用一个只包含“L”“R”“B”的字符串来描述。\n\n初始时，正四面体的A面朝下，现在SECSA将给这个正四面体一串滚动指令——当然就是一个这样的字符串——让这个正四面体每秒滚动一下。也就是说，第1秒内正四面体A面朝下，第1秒末执行第一条指令，第2秒末执行第2条指令，依次类推，直至将整个指令串执行完毕。\n\n你的任务就是当SECSA询问你的时候告诉他：这个正四面体在第L秒到第R秒内A面有多少秒朝着地面。\n\n当然，SECSA可能因为对这个正四面体的滚动路径不满意，他随时会修改他的某一条指令。因此你的程序应该能执行下面两个操作：\n\n(1)接受SECSA修个第i条指令的信息\n\n(2)回答SECSA的“在第L秒到第R秒内A面有多少秒朝着地面”的询问\n\n例如，假如原指令串为“LLLLB”，那么第1、4、6秒内A面是朝下的。此时，如果SECSA向你询问第3秒到第6秒的情况，你就应该回答“2”。而SECSA将第3条指令修改为“R”的话，指令串就变成了“LLRLB”，那么正四面体就只有在第1、5秒内A面朝下了。如图 5所示：\n\n![](https://cdn.luogu.com.cn/upload/pic/19851.png)\n\n", "inputFormat": "输入文件的第一行是一个整数n，表示指令串中包含的指令条数。\n\n输入文件的第二行是一个字符串，共包含n个字符，每个字符是“L”“R”“B”之一，表示初始的指令串。\n\n输入文件的第三行是一个整数m，表示你的程序需要处理的操作总数。\n\n接下去m行，每行描述一个操作，为以下两种格式之一：\n\n(1)0 i c：表示把第i个操作改成c，c为“L”“R”“B”之一\n\n(2)1 L R：表示询问第L秒到第R秒内，A面有多少秒朝下\n\n输入文件保证：1<=i<=n，1<=L<=R<=n+1。", "outputFormat": "输出文件对于每一个询问操作依次输出你的程序给出的回答，每个回答为一个整数，占一行。", "hint": "第1个样例就是问题描述中的例子\n\n在第2个样例中，按照原指令“LLLLBRRR”，则第1、4、6、9秒内A面向下；按照第一次修改后的指令“LRLLBRRR”，则只有第1秒内A面向下；按照第二次修改后的指令“LRLLBRBR”，则第1、9秒内A面向下。\n\n1<=n<=60000\n\n1<=m<=150000", "locale": "zh-CN"}}}
{"pid": "P4628", "type": "P", "difficulty": 0, "samples": [["5 4\n1 2\n1 3\n1 4\n1 5", "12"], ["5 7\n1 2\n1 3\n1 4\n2 3\n2 4\n5 3\n5 4", "2"], ["4 6\n1 2\n2 3\n2 3\n3 4\n4 1\n4 1", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "各省省选", "上海"], "title": "[SHOI2010] 电脑网络", "background": "", "description": "SHOI 的领队为了方便大家交流，决定在大家集训的机房里建立起一个局域网络。现在的机房里一共有 $n$ 台电脑终端，SHOI 的领队使用了 $m$ 条网线去建立这个局域网，每条网线都把某两台电脑连接起来使得它们可以双向通信。现在这个网络是连通的，也就是说，任意两台电脑之间都可以直接的或间接的通信。\n\n为了在整个备战过程中，确保所有学生之间通过这个电脑网络的交流，SHOI 的领队想要知道：“如果某台电脑 $\\texttt{A}\n$ 因故障关机的同时某一条网线 $\\texttt{L}$（并非连接在 $\\texttt{A}$ 上的）被切断，那么，除了 $\\texttt{A}$ 以外的其他电脑能否保持相互通信？”\n\n于是，SHOI 的领队需要你计算这个局域网络的“不稳定程度”。不稳定程度是指：通过从网络中移除一台电脑且切断一条网线（这条网线不连接在这台电脑上）使得整个网络中的其他电脑之间通讯不完全连通的不同方案的总数。\n", "inputFormat": "输入文件的第一行有两个正整数 $n$、$m$，分别表示网络中的电脑终端的数量以及用来连接电脑的网线数量。\n\n接下来 $m$ 行每行有两个整数 $x$、$y$ 来描述一条网线，表示这条网线连接了编号为 $x$、$y$ 的电脑，且 $x$ 不等于 $y$。\n\n输入文件保证，这个电脑网络初始时是连通的。\n", "outputFormat": "输出文件只有一行，这行只有一个整数，即为通过从网络中移除一台电脑且切断一条网线使得整个网络不连通的不同方案总数。\n", "hint": "- $1 \\leq n \\leq 2 \\times 10^3$；\n- $1 \\leq m \\leq 2 \\times 10^5$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2010] Computer Network", "background": "", "description": "The leader of SHOI, in order to make it easier for everyone to communicate, decided to build a local area network (LAN) in the computer room where they are training. There are $n$ computer terminals in the room. The leader used $m$ network cables to build this LAN. Each cable connects two computers so that they can communicate in both directions. The network is now connected, meaning that any two computers can communicate directly or indirectly.\n\nTo ensure that all students can keep communicating through this computer network during the whole preparation period, the leader wants to know: “If some computer $\\texttt{A}$ shuts down due to a failure, and at the same time some cable $\\texttt{L}$ (which is not connected to $\\texttt{A}$) is cut, can the other computers (except $\\texttt{A}$) still remain mutually connected?”\n\nTherefore, the leader needs you to compute the “instability” of this LAN. The instability is defined as: the total number of different ways to remove one computer from the network and cut one cable (and this cable is not incident to that computer), such that the remaining computers in the network are not fully connected (i.e., communication among them is not completely connected).", "inputFormat": "The first line of the input contains two positive integers $n$ and $m$, representing the number of computer terminals in the network and the number of cables used to connect them.\n\nIn the next $m$ lines, each line contains two integers $x$ and $y$ describing a cable, meaning that this cable connects computers numbered $x$ and $y$, and $x \\neq y$.\n\nThe input guarantees that the network is connected initially.", "outputFormat": "Output one line containing one integer: the total number of different ways to remove one computer and cut one cable that make the network disconnected.", "hint": "- $1 \\leq n \\leq 2 \\times 10^3$;\n- $1 \\leq m \\leq 2 \\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2010] 电脑网络", "background": "", "description": "SHOI 的领队为了方便大家交流，决定在大家集训的机房里建立起一个局域网络。现在的机房里一共有 $n$ 台电脑终端，SHOI 的领队使用了 $m$ 条网线去建立这个局域网，每条网线都把某两台电脑连接起来使得它们可以双向通信。现在这个网络是连通的，也就是说，任意两台电脑之间都可以直接的或间接的通信。\n\n为了在整个备战过程中，确保所有学生之间通过这个电脑网络的交流，SHOI 的领队想要知道：“如果某台电脑 $\\texttt{A}\n$ 因故障关机的同时某一条网线 $\\texttt{L}$（并非连接在 $\\texttt{A}$ 上的）被切断，那么，除了 $\\texttt{A}$ 以外的其他电脑能否保持相互通信？”\n\n于是，SHOI 的领队需要你计算这个局域网络的“不稳定程度”。不稳定程度是指：通过从网络中移除一台电脑且切断一条网线（这条网线不连接在这台电脑上）使得整个网络中的其他电脑之间通讯不完全连通的不同方案的总数。\n", "inputFormat": "输入文件的第一行有两个正整数 $n$、$m$，分别表示网络中的电脑终端的数量以及用来连接电脑的网线数量。\n\n接下来 $m$ 行每行有两个整数 $x$、$y$ 来描述一条网线，表示这条网线连接了编号为 $x$、$y$ 的电脑，且 $x$ 不等于 $y$。\n\n输入文件保证，这个电脑网络初始时是连通的。\n", "outputFormat": "输出文件只有一行，这行只有一个整数，即为通过从网络中移除一台电脑且切断一条网线使得整个网络不连通的不同方案总数。\n", "hint": "- $1 \\leq n \\leq 2 \\times 10^3$；\n- $1 \\leq m \\leq 2 \\times 10^5$。\n", "locale": "zh-CN"}}}
{"pid": "P4629", "type": "P", "difficulty": 6, "samples": [["5\n1 1 1 1 1\n1 1 1 1 1\n1 2\n2 3\n3 4\n4 5", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2015", "各省省选", "上海"], "title": "[SHOI2015] 聚变反应炉", "background": "", "description": "曾经发明了零件组装机的发明家 SHTSC 又公开了他的新发明：聚变反应炉——一种可以产生大量清洁能量的神秘装置。\n\n众所周知，利用核聚变产生的能量有两个难点：一是控制核聚变反应的反应强度，二是使用较少的能量激发聚变反应。而 SHTSC 已经完美解决了第一个问题。一个聚变反应炉由若干个相连的聚变块组成，为了能够使得聚变反应可控，SHTSC 保证任意两个聚能块都可以通过相互之间的链接到达，并且没有一个聚能块可以不重复经过一个链接回到它自己。\n\n但是第二个问题 SHTSC 还没有完全解决。在他设计的聚变反应炉当中，每个聚变块都需要一定的初始能量 $d_i$ 来进行激发，不过 SHTSC 不需要手动激发所有聚变块，这是因为一旦一个聚变块被激发，则会向与其直接相连的所有还未被激发的聚变块传送 $c_i$ 个单位的能量。这样后被触发的聚变块可以以更低的初始能量来激发，甚至可能不需要额外的外界能量就可自行激发，从而降低了总激发能量的消耗。现在给出了一个聚变反应炉，求至少要多少能量才能激发所有聚变块。", "inputFormat": "第一行一个整数 $n$，表示共有 $n$ 个聚能块，由 $1$ 至 $n$ 编号。  \n\n第二行 $n$ 个整数，依次表示 $d_i$。  \n\n第三行 $n$ 个整数，依次表示 $c_i$。  \n\n以下 $n - 1$ 行每行两个整数 $u, v$，表示编号为 $u$ 和 $v$ 的聚能块是相连的。", "outputFormat": "一行一个整数，表示至少需要多少个单位的能量才能激发所有聚变块。", "hint": "| Case # | $\\max\\{c_i\\}$ | $n$ | 附加限制 |\n|:---:|:---:|:---:|:---:|\n| 1 | $= 1$ | $\\leq 10$ | $c_i = 1$ |\n| 2 | $= 1$ | $\\leq 100$ | $c_i = 1$ |\n| 3 | $= 1$ | $\\leq 200$ | $c_i = 1$ |\n| 4 | $= 0$ | $\\leq 10$ | - |\n| 5 | $= 1$ | $\\leq 200$ | $c_i = 1$ |\n| 6 | $= 1$ | $\\leq 200$ | - |\n| 7 | $= 1$ | $\\leq 100000$ | $c_i = 1$ |\n| 8 | $= 0$ | $\\leq 100000$ | - |\n| 9 | $= 1$ | $\\leq 100000$ | - |\n| 10 | $= 1$ | $\\leq 100000$ | - |\n| 11 | $\\leq 5$ | $\\leq 20$ | - |\n| 12 | $\\leq 5$ | $\\leq 20$ | $c_i$ 均相等 |\n| 13 | $\\leq 5$ | $\\leq 200$ | - |\n| 14 | $\\leq 5$ | $\\leq 200$ | $c_i$ 均相等 |\n| 15 | $\\leq 5$ | $\\leq 200$ | - |\n| 16 | $\\leq 5$ | $\\leq 200$ | - |\n| 17 | $\\leq 5$ | $\\leq 2000$ | $c_i$ 均相等 |\n| 18 | $\\leq 5$ | $\\leq 2000$ | - |\n| 19 | $\\leq 5$ | $\\leq 2000$ | - |\n| 20 | $\\leq 5$ | $\\leq 2000$ | - |\n\n对于所有数据，保证 $1 \\le d_i, \\sum d_i \\le {10}^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2015] Fusion Reactor", "background": "", "description": "The inventor SHTSC, who once created the parts assembler, has now revealed his new invention: a fusion reactor—a mysterious device that can produce a large amount of clean energy.\n\nAs is well known, there are two difficulties in harnessing energy from nuclear fusion: one is controlling the intensity of the fusion reaction, and the other is activating the fusion reaction using as little energy as possible. SHTSC has perfectly solved the first problem. A fusion reactor consists of several interconnected fusion blocks. To ensure controllability, SHTSC guarantees that any two fusion blocks can reach each other via links, and no fusion block can return to itself without repeating an edge. In other words, the links form a tree.\n\nHowever, the second problem is not fully solved. In his design, each fusion block requires a certain initial energy $d_i$ to be activated. Nevertheless, SHTSC does not need to activate all blocks manually, because once a fusion block is activated, it sends $c_i$ units of energy to all directly connected fusion blocks that have not yet been activated. In this way, fusion blocks activated later can be activated with lower initial energy, or even without any additional external energy, thereby reducing the total activation energy. Given a fusion reactor, find the minimum amount of energy required to activate all fusion blocks.", "inputFormat": "The first line contains an integer $n$, indicating that there are $n$ fusion blocks, numbered $1$ to $n$.  \nThe second line contains $n$ integers, representing $d_i$ in order.  \nThe third line contains $n$ integers, representing $c_i$ in order.  \nEach of the following $n - 1$ lines contains two integers $u, v$, indicating that fusion blocks $u$ and $v$ are connected.", "outputFormat": "Output a single integer on one line, indicating the minimum number of energy units required to activate all fusion blocks.", "hint": "| Case # | $\\max\\{c_i\\}$ | $n$ | Additional constraints |\n|:---:|:---:|:---:|:---:|\n| 1 | $= 1$ | $\\leq 10$ | $c_i = 1$ |\n| 2 | $= 1$ | $\\leq 100$ | $c_i = 1$ |\n| 3 | $= 1$ | $\\leq 200$ | $c_i = 1$ |\n| 4 | $= 0$ | $\\leq 10$ | - |\n| 5 | $= 1$ | $\\leq 200$ | $c_i = 1$ |\n| 6 | $= 1$ | $\\leq 200$ | - |\n| 7 | $= 1$ | $\\leq 100000$ | $c_i = 1$ |\n| 8 | $= 0$ | $\\leq 100000$ | - |\n| 9 | $= 1$ | $\\leq 100000$ | - |\n| 10 | $= 1$ | $\\leq 100000$ | - |\n| 11 | $\\leq 5$ | $\\leq 20$ | - |\n| 12 | $\\leq 5$ | $\\leq 20$ | $c_i$ are all equal |\n| 13 | $\\leq 5$ | $\\leq 200$ | - |\n| 14 | $\\leq 5$ | $\\leq 200$ | $c_i$ are all equal |\n| 15 | $\\leq 5$ | $\\leq 200$ | - |\n| 16 | $\\leq 5$ | $\\leq 200$ | - |\n| 17 | $\\leq 5$ | $\\leq 2000$ | $c_i$ are all equal |\n| 18 | $\\leq 5$ | $\\leq 2000$ | - |\n| 19 | $\\leq 5$ | $\\leq 2000$ | - |\n| 20 | $\\leq 5$ | $\\leq 2000$ | - |\n\nFor all testdata, it is guaranteed that $1 \\le d_i, \\sum d_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2015] 聚变反应炉", "background": "", "description": "曾经发明了零件组装机的发明家 SHTSC 又公开了他的新发明：聚变反应炉——一种可以产生大量清洁能量的神秘装置。\n\n众所周知，利用核聚变产生的能量有两个难点：一是控制核聚变反应的反应强度，二是使用较少的能量激发聚变反应。而 SHTSC 已经完美解决了第一个问题。一个聚变反应炉由若干个相连的聚变块组成，为了能够使得聚变反应可控，SHTSC 保证任意两个聚能块都可以通过相互之间的链接到达，并且没有一个聚能块可以不重复经过一个链接回到它自己。\n\n但是第二个问题 SHTSC 还没有完全解决。在他设计的聚变反应炉当中，每个聚变块都需要一定的初始能量 $d_i$ 来进行激发，不过 SHTSC 不需要手动激发所有聚变块，这是因为一旦一个聚变块被激发，则会向与其直接相连的所有还未被激发的聚变块传送 $c_i$ 个单位的能量。这样后被触发的聚变块可以以更低的初始能量来激发，甚至可能不需要额外的外界能量就可自行激发，从而降低了总激发能量的消耗。现在给出了一个聚变反应炉，求至少要多少能量才能激发所有聚变块。", "inputFormat": "第一行一个整数 $n$，表示共有 $n$ 个聚能块，由 $1$ 至 $n$ 编号。  \n\n第二行 $n$ 个整数，依次表示 $d_i$。  \n\n第三行 $n$ 个整数，依次表示 $c_i$。  \n\n以下 $n - 1$ 行每行两个整数 $u, v$，表示编号为 $u$ 和 $v$ 的聚能块是相连的。", "outputFormat": "一行一个整数，表示至少需要多少个单位的能量才能激发所有聚变块。", "hint": "| Case # | $\\max\\{c_i\\}$ | $n$ | 附加限制 |\n|:---:|:---:|:---:|:---:|\n| 1 | $= 1$ | $\\leq 10$ | $c_i = 1$ |\n| 2 | $= 1$ | $\\leq 100$ | $c_i = 1$ |\n| 3 | $= 1$ | $\\leq 200$ | $c_i = 1$ |\n| 4 | $= 0$ | $\\leq 10$ | - |\n| 5 | $= 1$ | $\\leq 200$ | $c_i = 1$ |\n| 6 | $= 1$ | $\\leq 200$ | - |\n| 7 | $= 1$ | $\\leq 100000$ | $c_i = 1$ |\n| 8 | $= 0$ | $\\leq 100000$ | - |\n| 9 | $= 1$ | $\\leq 100000$ | - |\n| 10 | $= 1$ | $\\leq 100000$ | - |\n| 11 | $\\leq 5$ | $\\leq 20$ | - |\n| 12 | $\\leq 5$ | $\\leq 20$ | $c_i$ 均相等 |\n| 13 | $\\leq 5$ | $\\leq 200$ | - |\n| 14 | $\\leq 5$ | $\\leq 200$ | $c_i$ 均相等 |\n| 15 | $\\leq 5$ | $\\leq 200$ | - |\n| 16 | $\\leq 5$ | $\\leq 200$ | - |\n| 17 | $\\leq 5$ | $\\leq 2000$ | $c_i$ 均相等 |\n| 18 | $\\leq 5$ | $\\leq 2000$ | - |\n| 19 | $\\leq 5$ | $\\leq 2000$ | - |\n| 20 | $\\leq 5$ | $\\leq 2000$ | - |\n\n对于所有数据，保证 $1 \\le d_i, \\sum d_i \\le {10}^9$。", "locale": "zh-CN"}}}
{"pid": "P4630", "type": "P", "difficulty": 6, "samples": [["4 3\n1 2\n2 3\n3 4\n", "8\n"], ["4 4\n1 2\n2 3\n3 4\n4 2\n", "14\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "APIO", "双连通分量", "圆方树"], "title": "[APIO2018] 铁人两项", "background": "", "description": "比特镇的路网由 $m$ 条双向道路连接的 $n$ 个交叉路口组成。\n\n最近，比特镇获得了一场铁人两项锦标赛的主办权。这场比赛共有两段赛程：选手先完成一段长跑赛程，然后骑自行车完成第二段赛程。\n\n比赛的路线要按照如下方法规划：\n\n1. 先选择三个两两互不相同的路口 $s$、$c$ 和 $f$，分别作为比赛的起点、切换点（运动员在长跑到达这个点后，骑自行车前往终点）、终点。\n2. 选择一条从 $s$ 出发，经过 $c$ 最终到达 $f$ 的路径。考虑到安全因素，选择的路径经过同一个点至多一次。\n\n在规划路径之前，镇长想请你帮忙计算，总共有多少种不同的选取 $s$、$c$ 和 $f$ 的方案，使得在第 $2$ 步中至少能设计出一条满足要求的路径。\n", "inputFormat": "第一行包含两个整数 $n$ 和 $m$，分别表示交叉路口和双向道路的数量。\n\n接下来 $m$ 行，每行两个整数 $v_i, u_i$。表示存在一条双向道路连接交叉路口 $v_i, u_i$（$1 \\le v_i, u_i \\le n$，$v_i \\neq u_i$）。\n\n保证任意两个交叉路口之间，至多被一条双向道路直接连接。", "outputFormat": "输出一行，包括一个整数，表示能满足要求的不同的选取 $s$、$c$ 和 $f$ 的方案数。", "hint": "**提示**\n\n在第一个样例中，有以下 $8$ 种不同的选择 $(s, c, f)$ 的方案：\n\n- $(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4), (3, 2, 1)$；\n- $(4, 2, 1), (4, 3, 1), (4, 3, 2)$。\n\n在第二个样例中，有以下 $14$ 种不同的选择 $(s, c, f)$ 的方案：\n\n- $(1, 2, 3), (1, 2, 4), (1, 3, 4), (1, 4, 3), (2, 3, 4)$；\n- $(2, 4, 3), (3, 2, 1), (3, 2, 4), (3, 4, 1), (3, 4, 2)$；\n- $(4, 2, 1), (4, 2, 3), (4, 3, 1), (4, 3, 2)$。\n\n**子任务**\n\n- Subtask 1（points: $5$）：$n \\leq 10$，$m \\leq 100$。\n- Subtask 2（points: $11$）：$n \\leq 50$，$m \\leq 100$。\n- Subtask 3（points: $8$）：$n \\leq 100000$，每个交叉路口至多作为两条双向道路的端点。\n- Subtask 4（points: $10$）：$n \\leq 1000$，在路网中不存在环（存在环是指存在一个长度为 $k$（$k \\ge 3$）的交叉路口序列 $v_1, v_2, \\ldots, v_k$，序列中的路口编号两两不同，且对于 $i$ 从 $1$ 到 $k - 1$，有一条双向道路直接连接路口 $v_i$ 和 $v_{i+1}$，且有一条双向道路直接连接路口 $v_k$ 和 $v_1$）。\n- Subtask 5（points: $13$）：$n \\leq 100000$，在路网中不存在环。\n- Subtask 6（points: $15$）：$n \\leq 1000$，对于每个交叉路口，至多被一个环包含。\n- Subtask 7（points: $20$）：$n \\leq 100000$，对于每个交叉路口，至多被一个环包含。\n- Subtask 8（points: $8$）：$n \\leq 1000$，$m \\leq 2000$。\n- Subtask 9（points: $10$）：$n \\leq 100000$，$m \\leq 200000$。", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2018] Triathlon", "background": "", "description": "Bit Town’s road network consists of $n$ intersections connected by $m$ bidirectional roads.\n\nRecently, Bit Town obtained the right to host a triathlon championship. The race has two stages: contestants first complete a long-distance running stage, and then ride a bicycle to complete the second stage.\n\nThe race route must be planned as follows:\n\n1. First, choose three pairwise distinct intersections $s$, $c$, and $f$, as the start point, the transition point (after reaching this point during the running stage, athletes ride a bicycle to the finish), and the finish point.\n2. Choose a path that starts from $s$, passes through $c$, and finally reaches $f$. For safety reasons, the chosen path visits each intersection at most once.\n\nBefore planning the route, the mayor wants you to help compute how many different ways there are to choose $s$, $c$, and $f$, such that in step 2 there is at least one path that satisfies the requirement.", "inputFormat": "The first line contains two integers $n$ and $m$, representing the number of intersections and the number of bidirectional roads.\n\nThe next $m$ lines each contain two integers $v_i, u_i$, indicating that there is a bidirectional road directly connecting intersections $v_i$ and $u_i$ ($1 \\le v_i, u_i \\le n$, $v_i \\neq u_i$).\n\nIt is guaranteed that any two intersections are directly connected by at most one bidirectional road.", "outputFormat": "Output one line containing one integer, the number of different ways to choose $s$, $c$, and $f$ that satisfy the requirement.", "hint": "**Hint**\n\nIn the first sample, there are the following $8$ different choices of $(s, c, f)$:\n\n- $(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4), (3, 2, 1)$;\n- $(4, 2, 1), (4, 3, 1), (4, 3, 2)$.\n\nIn the second sample, there are the following $14$ different choices of $(s, c, f)$:\n\n- $(1, 2, 3), (1, 2, 4), (1, 3, 4), (1, 4, 3), (2, 3, 4)$;\n- $(2, 4, 3), (3, 2, 1), (3, 2, 4), (3, 4, 1), (3, 4, 2)$;\n- $(4, 2, 1), (4, 2, 3), (4, 3, 1), (4, 3, 2)$.\n\n**Subtasks**\n\n- Subtask 1 (points: $5$): $n \\leq 10$, $m \\leq 100$.\n- Subtask 2 (points: $11$): $n \\leq 50$, $m \\leq 100$.\n- Subtask 3 (points: $8$): $n \\leq 100000$, each intersection is an endpoint of at most two bidirectional roads.\n- Subtask 4 (points: $10$): $n \\leq 1000$, there are no cycles in the road network (a cycle means that there exists a sequence of intersections of length $k$ ($k \\ge 3$), $v_1, v_2, \\ldots, v_k$, where all intersection labels in the sequence are pairwise distinct, and for $i$ from $1$ to $k - 1$ there is a bidirectional road directly connecting $v_i$ and $v_{i+1}$, and there is also a bidirectional road directly connecting $v_k$ and $v_1$).\n- Subtask 5 (points: $13$): $n \\leq 100000$, there are no cycles in the road network.\n- Subtask 6 (points: $15$): $n \\leq 1000$, each intersection belongs to at most one cycle.\n- Subtask 7 (points: $20$): $n \\leq 100000$, each intersection belongs to at most one cycle.\n- Subtask 8 (points: $8$): $n \\leq 1000$, $m \\leq 2000$.\n- Subtask 9 (points: $10$): $n \\leq 100000$, $m \\leq 200000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2018] 铁人两项", "background": "", "description": "比特镇的路网由 $m$ 条双向道路连接的 $n$ 个交叉路口组成。\n\n最近，比特镇获得了一场铁人两项锦标赛的主办权。这场比赛共有两段赛程：选手先完成一段长跑赛程，然后骑自行车完成第二段赛程。\n\n比赛的路线要按照如下方法规划：\n\n1. 先选择三个两两互不相同的路口 $s$、$c$ 和 $f$，分别作为比赛的起点、切换点（运动员在长跑到达这个点后，骑自行车前往终点）、终点。\n2. 选择一条从 $s$ 出发，经过 $c$ 最终到达 $f$ 的路径。考虑到安全因素，选择的路径经过同一个点至多一次。\n\n在规划路径之前，镇长想请你帮忙计算，总共有多少种不同的选取 $s$、$c$ 和 $f$ 的方案，使得在第 $2$ 步中至少能设计出一条满足要求的路径。\n", "inputFormat": "第一行包含两个整数 $n$ 和 $m$，分别表示交叉路口和双向道路的数量。\n\n接下来 $m$ 行，每行两个整数 $v_i, u_i$。表示存在一条双向道路连接交叉路口 $v_i, u_i$（$1 \\le v_i, u_i \\le n$，$v_i \\neq u_i$）。\n\n保证任意两个交叉路口之间，至多被一条双向道路直接连接。", "outputFormat": "输出一行，包括一个整数，表示能满足要求的不同的选取 $s$、$c$ 和 $f$ 的方案数。", "hint": "**提示**\n\n在第一个样例中，有以下 $8$ 种不同的选择 $(s, c, f)$ 的方案：\n\n- $(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4), (3, 2, 1)$；\n- $(4, 2, 1), (4, 3, 1), (4, 3, 2)$。\n\n在第二个样例中，有以下 $14$ 种不同的选择 $(s, c, f)$ 的方案：\n\n- $(1, 2, 3), (1, 2, 4), (1, 3, 4), (1, 4, 3), (2, 3, 4)$；\n- $(2, 4, 3), (3, 2, 1), (3, 2, 4), (3, 4, 1), (3, 4, 2)$；\n- $(4, 2, 1), (4, 2, 3), (4, 3, 1), (4, 3, 2)$。\n\n**子任务**\n\n- Subtask 1（points: $5$）：$n \\leq 10$，$m \\leq 100$。\n- Subtask 2（points: $11$）：$n \\leq 50$，$m \\leq 100$。\n- Subtask 3（points: $8$）：$n \\leq 100000$，每个交叉路口至多作为两条双向道路的端点。\n- Subtask 4（points: $10$）：$n \\leq 1000$，在路网中不存在环（存在环是指存在一个长度为 $k$（$k \\ge 3$）的交叉路口序列 $v_1, v_2, \\ldots, v_k$，序列中的路口编号两两不同，且对于 $i$ 从 $1$ 到 $k - 1$，有一条双向道路直接连接路口 $v_i$ 和 $v_{i+1}$，且有一条双向道路直接连接路口 $v_k$ 和 $v_1$）。\n- Subtask 5（points: $13$）：$n \\leq 100000$，在路网中不存在环。\n- Subtask 6（points: $15$）：$n \\leq 1000$，对于每个交叉路口，至多被一个环包含。\n- Subtask 7（points: $20$）：$n \\leq 100000$，对于每个交叉路口，至多被一个环包含。\n- Subtask 8（points: $8$）：$n \\leq 1000$，$m \\leq 2000$。\n- Subtask 9（points: $10$）：$n \\leq 100000$，$m \\leq 200000$。", "locale": "zh-CN"}}}
{"pid": "P4631", "type": "P", "difficulty": 7, "samples": [["11\n9 9 2\n13 2 1\n11 8 2\n3 3 2\n3 12 1\n12 14 1\n9 8 5\n2 8 2\n5 2 1\n14 4 2\n14 14 1\n", "7 2 7 4 5 6 7 7 4 7 6"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["搜索", "2018", "APIO", "剪枝"], "title": "[APIO2018] 选圆圈", "background": "", "description": "在平面上，有 $n$ 个圆，记为 $c_1, c_2,...,c_n$ 。我们尝试对这些圆运行这个算法：\n\n1. 找到这些圆中半径最大的。如果有多个半径最大的圆，选择编号最小的。记为 $c_i$。\n2. 删除 $c_i$ 及与其有交集的所有圆。两个圆有交集当且仅当平面上存在一个点，这个点同时在这两个圆的圆周上或圆内。（原文直译：如果平面上存在一个点被这两个圆所包含，我们称这两个圆有交集。一个点被一个圆包含，当且仅当它位于圆内或圆周上。）\n3. 重复上面两个步骤直到所有的圆都被删除。\n\n![QQ20180525194902.png](https://cdn.luogu.com.cn/upload/pic/19974.png)\n\n当 $c_i$ 被删除时，若循环中第 $1$ 步选择的圆是 $c_j$，我们说 $c_i$ 被 $c_j$ 删除。对于每个圆，求出它是被哪一个圆删除的。", "inputFormat": "第一行包含一个整数 $n$，表示开始时平面上圆的数量。\n\n接下来 $n$ 行，每行包含三个整数 $x_i, y_i, r_i$ 依次描述圆 $c_i$ 圆心的 $x$ 坐标、$y$ 坐标和它的半径。", "outputFormat": "输出一行，包含 $n$ 个整数 $a_1, a_2, ..., a_n$，其中 $a_i$ 表示圆 $c_i$ 是被圆 $c_{a_i}$ 删除的。", "hint": "**提示**\n\n题目描述中的图片对应了样例一中的情形。\n\n**子任务**\n\n- Subtask 1(points: $7$): $n \\leq 5000$\n- Subtask 2(points: $12$): $n \\leq 3 × 10^5$，对于所有的圆 $y_i = 0$\n- Subtask 3(points: $15$): $n \\leq 3 × 10^5$，每个圆最多和一个其他圆有交集\n- Subtask 4(points: $23$): $n \\leq 3 × 10^5$，所有的圆半径相同\n- Subtask 5(points: $30$): $n \\leq 10^5$\n- Subtask 6(points: $13$): $n \\leq 3 × 10^5$\n\n所有数据均满足：$-10^9 ≤ x_i, y_i ≤ 10^9, 1 ≤ r_i ≤ 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2018] Choosing Circles", "background": "", "description": "On a plane, there are $n$ circles, denoted by $c_1, c_2, ..., c_n$. We try to run the following algorithm on these circles:\n\n1. Find the circle with the largest radius. If there are multiple circles with the largest radius, choose the one with the smallest index. Denote it as $c_i$.\n2. Delete $c_i$ and all circles that intersect with it. Two circles intersect if and only if there exists a point on the plane that lies inside or on the boundary of both circles. (Literal translation of the original: If there exists a point on the plane that is contained by both circles, we say these two circles intersect. A point is contained by a circle if and only if it lies inside the circle or on its boundary.)\n3. Repeat the above two steps until all circles are deleted.\n\n![QQ20180525194902.png](https://cdn.luogu.com.cn/upload/pic/19974.png)\n\nWhen $c_i$ is deleted, if the circle chosen in Step 1 of that iteration is $c_j$, we say that $c_i$ is deleted by $c_j$. For each circle, find which circle deletes it.", "inputFormat": "The first line contains an integer $n$, indicating the number of circles on the plane initially.\n\nThe next $n$ lines each contain three integers $x_i, y_i, r_i$, describing the $x$ coordinate, the $y$ coordinate of the center of circle $c_i$, and its radius, respectively.", "outputFormat": "Output one line containing $n$ integers $a_1, a_2, ..., a_n$, where $a_i$ means that circle $c_i$ is deleted by circle $c_{a_i}$.", "hint": "**Hint**\n\nThe picture in the statement corresponds to the situation in Sample 1.\n\n**Subtasks**\n\n- Subtask 1(points: $7$): $n \\leq 5000$.\n- Subtask 2(points: $12$): $n \\leq 3 × 10^5$, and for all circles $y_i = 0$.\n- Subtask 3(points: $15$): $n \\leq 3 × 10^5$, and each circle intersects with at most one other circle.\n- Subtask 4(points: $23$): $n \\leq 3 × 10^5$, and all circles have the same radius.\n- Subtask 5(points: $30$): $n \\leq 10^5$.\n- Subtask 6(points: $13$): $n \\leq 3 × 10^5$.\n\nAll testdata satisfy: $-10^9 ≤ x_i, y_i ≤ 10^9, 1 ≤ r_i ≤ 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2018] 选圆圈", "background": "", "description": "在平面上，有 $n$ 个圆，记为 $c_1, c_2,...,c_n$ 。我们尝试对这些圆运行这个算法：\n\n1. 找到这些圆中半径最大的。如果有多个半径最大的圆，选择编号最小的。记为 $c_i$。\n2. 删除 $c_i$ 及与其有交集的所有圆。两个圆有交集当且仅当平面上存在一个点，这个点同时在这两个圆的圆周上或圆内。（原文直译：如果平面上存在一个点被这两个圆所包含，我们称这两个圆有交集。一个点被一个圆包含，当且仅当它位于圆内或圆周上。）\n3. 重复上面两个步骤直到所有的圆都被删除。\n\n![QQ20180525194902.png](https://cdn.luogu.com.cn/upload/pic/19974.png)\n\n当 $c_i$ 被删除时，若循环中第 $1$ 步选择的圆是 $c_j$，我们说 $c_i$ 被 $c_j$ 删除。对于每个圆，求出它是被哪一个圆删除的。", "inputFormat": "第一行包含一个整数 $n$，表示开始时平面上圆的数量。\n\n接下来 $n$ 行，每行包含三个整数 $x_i, y_i, r_i$ 依次描述圆 $c_i$ 圆心的 $x$ 坐标、$y$ 坐标和它的半径。", "outputFormat": "输出一行，包含 $n$ 个整数 $a_1, a_2, ..., a_n$，其中 $a_i$ 表示圆 $c_i$ 是被圆 $c_{a_i}$ 删除的。", "hint": "**提示**\n\n题目描述中的图片对应了样例一中的情形。\n\n**子任务**\n\n- Subtask 1(points: $7$): $n \\leq 5000$\n- Subtask 2(points: $12$): $n \\leq 3 × 10^5$，对于所有的圆 $y_i = 0$\n- Subtask 3(points: $15$): $n \\leq 3 × 10^5$，每个圆最多和一个其他圆有交集\n- Subtask 4(points: $23$): $n \\leq 3 × 10^5$，所有的圆半径相同\n- Subtask 5(points: $30$): $n \\leq 10^5$\n- Subtask 6(points: $13$): $n \\leq 3 × 10^5$\n\n所有数据均满足：$-10^9 ≤ x_i, y_i ≤ 10^9, 1 ≤ r_i ≤ 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4632", "type": "P", "difficulty": 7, "samples": [["4 2 4\n3 1 1 10\n9 2 2 4\n7 2 5 7\n4 1 8 10\n5 3\n5 6\n5 9\n1 10\n", "4\n2\n-1\n-1\n"], ["2 1 3\n1 1 1 4\n1 1 2 6\n1 3\n1 5\n1 7", "0\n0\n-1\n"], ["1 1 1\n100000000 1 1 1\n1 1\n", "99999999\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "线段树", "二分", "离散化", "APIO"], "title": "[APIO2018] 新家", "background": "**警告！滥用本题评测者封号！请勿多次重复提交！**", "description": "五福街是一条笔直的道路，这条道路可以看成一个数轴，街上每个建筑物的坐标都可以用一个整数来表示。小明是一位时光旅行者，他知道在这条街上，在过去现在和未来共有 $n$ 个商店出现。第 $i$ 个商店可以使用四个整数 $x_i, t_i, a_i, b_i$ 描述，它们分别表示：商店的坐标、商店的类型、商店开业的年份、商店关闭的年份。\n\n小明希望通过时光旅行，选择一个合适的时间，住在五福街上的某个地方。他给出了一份他可能选择的列表，上面包括了 $q$ 个询问，每个询问用二元组 （坐标，时间）表示。第 $i$ 对二元组用两个整数 $l_i, y_i$ 描述，分别表示选择的地点 $l_i$ 和年份 $y_i$。\n\n现在，他想计算出在这些时间和地点居住的生活质量。他定义居住的不方便指数为：在居住的年份，离居住点最远的商店类型到居住点的距离。类型 $t$ 的商店到居住点的距离定义为：在指定的年份，类型 $t$ 的所有营业的商店中，到居住点距离最近的一家到居住点的距离。我们说编号为 $i$ 的商店在第 $y$ 年在营业当且仅当 $a_i \\le y \\le b_i$。注意，在某些年份中，可能在五福街上并非所有 $k$ 种类型的商店都有至少一家在营业。在这种情况下，不方便指数定义为 $-1$。\n\n你的任务是帮助小明求出每对（坐标，时间）二元组居住的不方便指数。", "inputFormat": "第一行包含三个整数 $n, k$ 和 $q$ ，分别表示商店的数量、商店类型的数量和（坐标，时间）二元组的数量。$(1 \\leq n, q \\le 3×10^5, 1 \\le k \\le n)$。\n\n接下来 $n$ 行，每行包含四个整数 $x_i, t_i, a_i$ 和 $b_i$ 用于描述一家商店，意义如题面所述 $(1 \\le x_i, a_i, b_i \\le 10^8, 1 \\le t_i \\le k, a_i \\le b_i)$。\n\n接下来 $q$ 行，每行包含两个整数 $l_i$ 和 $y_i$ ，表示一组（坐标，时间）查询$(1 \\le l_i, y_i \\le 10^8)$。", "outputFormat": "输出一行，包含 $q$ 个整数，依次表示对于 $q$ 组（坐标，时间）询问求出的结果。", "hint": "**提示**\n\n在第一个样例中，有 4 家商店，共 2 种类型，还有 4 个询问。\n\n- 对于第一个询问：小明在第 3 年住在坐标为 5 的地方。这一年中，编号为 1 和 2 的商店在营业，到编号为 1 的商店的距离为 2 ，到编号为 2 的商店距离为 4 ，所以最大距离为 $4$。\n- 对于第二个询问：小明在第 6 年住在坐标为 5 的地方。这一年中，编号为 1 和 3 的商店在营业，到编号为 1 的商店的距离为 2 ，到编号为 3 的商店距离为 2 ，所以最大距离为 $2$。\n- 对于第三个询问：小明在第 9 年住在坐标为 5 的地方。这一年中，编号为 1 和 4 的商店在营业，它们的类型都为 1，没有类型为 2 的商店在营业，所以答案为  $-1$。\n- 同样的情况出现在第四个询问中。\n\n在第二个样例中，有 2 家商店，共 1 种类型，还有三个询问。 两家商店的类型都是 1 。在所有的询问中，小明均住在坐标为 1 的地方。 在前两个询问中，至少有一个商店在营业，所以答案为 $0$，在第三个询问中，两个商店都不在营业，所以答案为 $-1$。\n\n在第三个样例中，有 1 家商店和 1 个询问，两者之间的距离是 $99999999$。\n\n\n**子任务**\n\n- Subtask 1 (points: $5$): $n, q \\leq 400$\n- Subtask 2 (points: $7$): $n, q \\leq 6 \\times 10^4, k \\leq 400$\n- Subtask 3 (points: $10$): $n, q \\leq 3 \\times 10^5$，对于所有的商店 $a_i = 1, b_i = 10^8$\n- Subtask 4 (points: $23$): $n, q \\leq 3 \\times 10^5$，对于所有的商店 $a_i = 1$\n- Subtask 5 (points: $35$): $n, q \\leq 6 \\times 10^4$\n- Subtask 6 (points: $20$): $n, q \\leq 3 \\times 10^5$", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2018] New Home", "background": "**Warning! Abusing the judge for this problem will result in your account being banned! Do not submit repeatedly many times!**", "description": "Wufu Street is a straight road. It can be seen as a number line, and the coordinate of each building on the street can be represented by an integer. Xiaoming is a time traveler. He knows that on this street, there are $n$ shops that appear in the past, present, and future. The $i$-th shop can be described by four integers $x_i, t_i, a_i, b_i$, which represent: the shop’s coordinate, the shop’s type, the year it opens, and the year it closes.\n\nXiaoming wants to time travel to choose a suitable time and live somewhere on Wufu Street. He provides a list of possible choices containing $q$ queries, and each query is represented by a pair (coordinate, time). The $i$-th pair is described by two integers $l_i, y_i$, representing the chosen location $l_i$ and the year $y_i$.\n\nNow, he wants to compute the quality of life for living at these times and locations. He defines the inconvenience index of living as: in the year of living, the distance from the living point to the shop type that is farthest away. The distance from shops of type $t$ to the living point is defined as: in the specified year, among all open shops of type $t$, the distance from the living point to the nearest one. We say shop $i$ is open in year $y$ if and only if $a_i \\le y \\le b_i$. Note that in some years, not all of the $k$ types of shops may have at least one shop open on Wufu Street. In this case, the inconvenience index is defined as $-1$.\n\nYour task is to help Xiaoming compute the inconvenience index for each (coordinate, time) pair.", "inputFormat": "The first line contains three integers $n, k, q$, representing the number of shops, the number of shop types, and the number of (coordinate, time) pairs. $(1 \\leq n, q \\le 3\\times 10^5, 1 \\le k \\le n)$.\n\nThe next $n$ lines each contain four integers $x_i, t_i, a_i, b_i$ describing a shop, with meanings as stated above. $(1 \\le x_i, a_i, b_i \\le 10^8, 1 \\le t_i \\le k, a_i \\le b_i)$.\n\nThe next $q$ lines each contain two integers $l_i, y_i$, representing a (coordinate, time) query. $(1 \\le l_i, y_i \\le 10^8)$.", "outputFormat": "Output one line containing $q$ integers, in order, representing the answers for the $q$ (coordinate, time) queries.", "hint": "**Hint**\n\nIn the first sample, there are 4 shops, 2 types, and 4 queries.\n\n- For the first query: Xiaoming lives at coordinate 5 in year 3. In this year, shops 1 and 2 are open. The distance to shop 1 is 2, and the distance to shop 2 is 4, so the maximum distance is $4$.\n- For the second query: Xiaoming lives at coordinate 5 in year 6. In this year, shops 1 and 3 are open. The distance to shop 1 is 2, and the distance to shop 3 is 2, so the maximum distance is $2$.\n- For the third query: Xiaoming lives at coordinate 5 in year 9. In this year, shops 1 and 4 are open. Both are type 1, and there is no open shop of type 2, so the answer is $-1$.\n- The same situation occurs in the fourth query.\n\nIn the second sample, there are 2 shops, 1 type, and 3 queries. Both shops are type 1. In all queries, Xiaoming lives at coordinate 1. In the first two queries, at least one shop is open, so the answer is $0$. In the third query, neither shop is open, so the answer is $-1$.\n\nIn the third sample, there is 1 shop and 1 query, and the distance between them is $99999999$.\n\n**Subtasks**\n\n- Subtask 1 (points: $5$): $n, q \\leq 400$.\n- Subtask 2 (points: $7$): $n, q \\leq 6 \\times 10^4, k \\leq 400$.\n- Subtask 3 (points: $10$): $n, q \\leq 3 \\times 10^5$, and for all shops $a_i = 1, b_i = 10^8$.\n- Subtask 4 (points: $23$): $n, q \\leq 3 \\times 10^5$, and for all shops $a_i = 1$.\n- Subtask 5 (points: $35$): $n, q \\leq 6 \\times 10^4$.\n- Subtask 6 (points: $20$): $n, q \\leq 3 \\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2018] 新家", "background": "**警告！滥用本题评测者封号！请勿多次重复提交！**", "description": "五福街是一条笔直的道路，这条道路可以看成一个数轴，街上每个建筑物的坐标都可以用一个整数来表示。小明是一位时光旅行者，他知道在这条街上，在过去现在和未来共有 $n$ 个商店出现。第 $i$ 个商店可以使用四个整数 $x_i, t_i, a_i, b_i$ 描述，它们分别表示：商店的坐标、商店的类型、商店开业的年份、商店关闭的年份。\n\n小明希望通过时光旅行，选择一个合适的时间，住在五福街上的某个地方。他给出了一份他可能选择的列表，上面包括了 $q$ 个询问，每个询问用二元组 （坐标，时间）表示。第 $i$ 对二元组用两个整数 $l_i, y_i$ 描述，分别表示选择的地点 $l_i$ 和年份 $y_i$。\n\n现在，他想计算出在这些时间和地点居住的生活质量。他定义居住的不方便指数为：在居住的年份，离居住点最远的商店类型到居住点的距离。类型 $t$ 的商店到居住点的距离定义为：在指定的年份，类型 $t$ 的所有营业的商店中，到居住点距离最近的一家到居住点的距离。我们说编号为 $i$ 的商店在第 $y$ 年在营业当且仅当 $a_i \\le y \\le b_i$。注意，在某些年份中，可能在五福街上并非所有 $k$ 种类型的商店都有至少一家在营业。在这种情况下，不方便指数定义为 $-1$。\n\n你的任务是帮助小明求出每对（坐标，时间）二元组居住的不方便指数。", "inputFormat": "第一行包含三个整数 $n, k$ 和 $q$ ，分别表示商店的数量、商店类型的数量和（坐标，时间）二元组的数量。$(1 \\leq n, q \\le 3×10^5, 1 \\le k \\le n)$。\n\n接下来 $n$ 行，每行包含四个整数 $x_i, t_i, a_i$ 和 $b_i$ 用于描述一家商店，意义如题面所述 $(1 \\le x_i, a_i, b_i \\le 10^8, 1 \\le t_i \\le k, a_i \\le b_i)$。\n\n接下来 $q$ 行，每行包含两个整数 $l_i$ 和 $y_i$ ，表示一组（坐标，时间）查询$(1 \\le l_i, y_i \\le 10^8)$。", "outputFormat": "输出一行，包含 $q$ 个整数，依次表示对于 $q$ 组（坐标，时间）询问求出的结果。", "hint": "**提示**\n\n在第一个样例中，有 4 家商店，共 2 种类型，还有 4 个询问。\n\n- 对于第一个询问：小明在第 3 年住在坐标为 5 的地方。这一年中，编号为 1 和 2 的商店在营业，到编号为 1 的商店的距离为 2 ，到编号为 2 的商店距离为 4 ，所以最大距离为 $4$。\n- 对于第二个询问：小明在第 6 年住在坐标为 5 的地方。这一年中，编号为 1 和 3 的商店在营业，到编号为 1 的商店的距离为 2 ，到编号为 3 的商店距离为 2 ，所以最大距离为 $2$。\n- 对于第三个询问：小明在第 9 年住在坐标为 5 的地方。这一年中，编号为 1 和 4 的商店在营业，它们的类型都为 1，没有类型为 2 的商店在营业，所以答案为  $-1$。\n- 同样的情况出现在第四个询问中。\n\n在第二个样例中，有 2 家商店，共 1 种类型，还有三个询问。 两家商店的类型都是 1 。在所有的询问中，小明均住在坐标为 1 的地方。 在前两个询问中，至少有一个商店在营业，所以答案为 $0$，在第三个询问中，两个商店都不在营业，所以答案为 $-1$。\n\n在第三个样例中，有 1 家商店和 1 个询问，两者之间的距离是 $99999999$。\n\n\n**子任务**\n\n- Subtask 1 (points: $5$): $n, q \\leq 400$\n- Subtask 2 (points: $7$): $n, q \\leq 6 \\times 10^4, k \\leq 400$\n- Subtask 3 (points: $10$): $n, q \\leq 3 \\times 10^5$，对于所有的商店 $a_i = 1, b_i = 10^8$\n- Subtask 4 (points: $23$): $n, q \\leq 3 \\times 10^5$，对于所有的商店 $a_i = 1$\n- Subtask 5 (points: $35$): $n, q \\leq 6 \\times 10^4$\n- Subtask 6 (points: $20$): $n, q \\leq 3 \\times 10^5$", "locale": "zh-CN"}}}
{"pid": "P4633", "type": "P", "difficulty": 6, "samples": [["3\n4 0 0 10 10\n4 3 4 6 8\n4 1 1 2 2", "2"], ["6\n4 1 0 17 12\n16 10 4 16 11 2 4 8 2 3 3 2 1 16 3 15 2\n8 8 10 3 5 12 8 11 6\n6 10 9 15 10 9 7\n4 4 6 7 9\n4 6 8 5 7", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2004", "POI（波兰）", "扫描线"], "title": "[POI 2004] WYS", "background": "虽然题目名比较毒瘤，但这确实是一个简单题。", "description": "给 $n$ 个互不相交的多边形，这些多边形的边均平行或垂直于坐标轴。定义多边形 $i$ 的深度 $d_i$ 为 $\\max\\{d_j\\}+1$，其中多边形 $j$ 包含多边形 $i$。特别的，若一个多边形不被任何多边形包含，则其深度为 $1$。求深度最大的多边形的深度。", "inputFormat": "第一行一个正整数 $n$。\n\n接下来每行描述一个多边形。首先给出一个偶数 $k$ $(4 \\leqslant k \\leqslant 10000)$，接下来包含 $k$ 个整数: $x_1,x_2,\\cdots,x_k$ $(0 \\leqslant x_i \\leqslant 10^8)$。这些点的坐标分别为 $(x_1, x_2), (x_3, x2), (x_3, x4), (x_5, x_4),\\cdots,(x_{k-1}, x_k), (x_1, x_k)$。他们按照逆时针顺序构成多边形。", "outputFormat": "输出一个整数表示最大深度。", "hint": "对于 $100\\%$ 的数据，$n \\leqslant 40000, \\sum k \\leqslant 200000$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2004] WYS", "background": "Although the title is a bit nasty, this is indeed a simple problem.", "description": "You are given $n$ pairwise disjoint polygons. All edges of these polygons are parallel or perpendicular to the coordinate axes. Define the depth $d_i$ of polygon $i$ as $\\max\\{d_j\\}+1$, where polygon $j$ contains polygon $i$. In particular, if a polygon is not contained in any other polygon, then its depth is $1$. Find the depth of the polygon with the maximum depth.", "inputFormat": "The first line contains a positive integer $n$.\n\nEach of the following lines describes one polygon. First, an even integer $k$ $(4 \\leqslant k \\leqslant 10000)$ is given, followed by $k$ integers: $x_1,x_2,\\cdots,x_k$ $(0 \\leqslant x_i \\leqslant 10^8)$. The coordinates of the points are $(x_1, x_2), (x_3, x_2), (x_3, x_4), (x_5, x_4),\\cdots,(x_{k-1}, x_k), (x_1, x_k)$. They form the polygon in counterclockwise order.", "outputFormat": "Output one integer, the maximum depth.", "hint": "For $100\\%$ of the testdata, $n \\leqslant 40000, \\sum k \\leqslant 200000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2004] WYS", "background": "虽然题目名比较毒瘤，但这确实是一个简单题。", "description": "给 $n$ 个互不相交的多边形，这些多边形的边均平行或垂直于坐标轴。定义多边形 $i$ 的深度 $d_i$ 为 $\\max\\{d_j\\}+1$，其中多边形 $j$ 包含多边形 $i$。特别的，若一个多边形不被任何多边形包含，则其深度为 $1$。求深度最大的多边形的深度。", "inputFormat": "第一行一个正整数 $n$。\n\n接下来每行描述一个多边形。首先给出一个偶数 $k$ $(4 \\leqslant k \\leqslant 10000)$，接下来包含 $k$ 个整数: $x_1,x_2,\\cdots,x_k$ $(0 \\leqslant x_i \\leqslant 10^8)$。这些点的坐标分别为 $(x_1, x_2), (x_3, x2), (x_3, x4), (x_5, x_4),\\cdots,(x_{k-1}, x_k), (x_1, x_k)$。他们按照逆时针顺序构成多边形。", "outputFormat": "输出一个整数表示最大深度。", "hint": "对于 $100\\%$ 的数据，$n \\leqslant 40000, \\sum k \\leqslant 200000$。", "locale": "zh-CN"}}}
{"pid": "P4634", "type": "P", "difficulty": 5, "samples": [["2 1\n2000\n4\n1/1 TO 1/2 1\n2/1 TO 2/2 1\n3/1 TO 3/2 1\n3/1 TO 3/3 1\n1", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2000", "CTSC/CTS"], "title": "[CTSC2000] 快乐的蜜月", "background": "位于某个旅游胜地的一家宾馆里，有一个房间是总统套房。由于总统套房价格昂贵，因此常常无人光临。宾馆的经理为了创收，决定将总统套房改建为专门为新婚夫妇服务的蜜月房。宾馆经理不仅大幅度降低了蜜月房的价位，而且还对不同身份的顾客制定了不同的价位，以吸引不同身份、不同消费水平的游客。比如对于来订蜜月房的国内来宾、海外旅客、港澳台同胞等，区别收取费用。宾馆经理的举措获得了不同凡响的效果。由于蜜月房环境幽雅，服务周到，因此生意红火。", "description": "宾馆经理在每年年底都会收到第二年的所有蜜月房预订单。每张预订单包括以下几个必要的信息：**到达日期、离去日期和顾客身份**。\n\n由于宾馆**只有一间蜜月房，只能同时接待一对新婚夫妇**。因此并不是所有的预订要求都能得到满足。\n\n当一些预订要求**在时间上发生了重叠**的时候，我们就称这些预订要求发生了冲突。\n\n对于那些不与任何其他预订要求发生冲突的预订单，它们**必然会被接受**。因为这对宾馆和顾客双方面来说都是件好事。\n\n而对于发生冲突的预订要求，宾馆经理则**必须拒绝其中的一部分**，以保证宾馆有秩序地运转。\n\n显然，对于同一时间内发生冲突的预定要求，宾馆经理**最多只能接受其中的一个**。经理也有可能**拒绝同一时间段内的所有预定要求**，因为这样可以避免顾客间发生争执。\n\n经理在做出决策后，需要将整个计划公布于众，以示公平。这是一个必须慎重的决定，因为它牵涉到诸多方面的因素。经理首先考虑的当然是利润问题。他必然希望获得尽可能多的收入。可是宾馆在获得经济效益的同时，同时也应该兼顾到社会效益，不能太惟利是图，还必须照顾到顾客们的感情。如果宾馆经理单从最大获利角度出发来决定接受或拒绝顾客的预订要求的话，就会引起人们的不满。\n\n经理有一个学过市场营销学的顾问。顾问告诉经理，可以采取一种折中的做法，放弃牟利最大的方案，而采纳获利第 $k$ 大的方案。他还通过精确的市场分析，找到了 $k$ 的最佳取值点，告诉了宾馆经理。\n\n\n现在请你帮助宾馆经理，从一大堆预订要求中，在上述原则下寻找到获利第 $k$ 大的方案。宾馆经理将根据此方案来决定接受和拒绝哪些预订要求。\n\n\n当然，可能有若干种方案的获利是一样大的。这时候，它们同属于获利第 $i$ 大的方案而不区分看待。例如，假如有 $3$ 种方案的收入同时为 $3$ ，有 $2$ 种方案的收入为 $2$ ，则收入为 $3$ 的方案都属于获利最大，收入为 $2$ 的方案都属于获利第二大。依次类推。\n\n假设所有的住、离店登记都在中午 $12$ 点进行。", "inputFormat": "输入文件的第一行是两个数，$k$ 和 $t$ 。其中 $k$ 表示需要选择获利第 $k$ 大的方案； $t$ 表示顾客的身份共划分为 $t$ 类。\n\n第二行是一个数 $y$ ，表示下一年的年份。\n\n第三行是一个数 $r$ ，表示共有 $r$ 个预订要求。\n\n以下 $r$ 行每行是一个预订要求，格式为：`m1/d1 TO m2/d2 id`；\n\n其中 $m_1,d_1$ 和 $m_2,d_2$ 分别表示到达和离去日期。 $id$ 是一个整数 （$1 \\leq id \\leq t$） ，用来标识预订顾客的身份。\n\n最后 $t$ 行每行为一个整数 $P_{i}$ ($1 \\leq i \\leq t$）表示蜜月房对于身份代号为 $i$ 的顾客的日收费标准。\n\n例：某对顾客于 $6$ 月 $1$ 日到达， $6$ 月 $3$ 日离去，对他们的日收费标准为 $m$ 元/天，则他们共住店两天，需付钱 $2m$ 元。", "outputFormat": "输出文件仅包含一个整数 $p$ ，表示在获利第 $k$ 大的方案下，宾馆的年度总收入额。如果获利第 $k$ 大的方案不存在，则输出 $-1$ 。", "hint": "数据范围：\n\n$1 \\leq k \\leq 100$ ，$1 \\leq t \\leq 100$，$0 \\leq r \\leq 20000$，$1 \\leq P_{i} \\leq 32767$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CTSC2000] 快乐的蜜月", "background": "位于某个旅游胜地的一家宾馆里，有一个房间是总统套房。由于总统套房价格昂贵，因此常常无人光临。宾馆的经理为了创收，决定将总统套房改建为专门为新婚夫妇服务的蜜月房。宾馆经理不仅大幅度降低了蜜月房的价位，而且还对不同身份的顾客制定了不同的价位，以吸引不同身份、不同消费水平的游客。比如对于来订蜜月房的国内来宾、海外旅客、港澳台同胞等，区别收取费用。宾馆经理的举措获得了不同凡响的效果。由于蜜月房环境幽雅，服务周到，因此生意红火。", "description": "宾馆经理在每年年底都会收到第二年的所有蜜月房预订单。每张预订单包括以下几个必要的信息：**到达日期、离去日期和顾客身份**。\n\n由于宾馆**只有一间蜜月房，只能同时接待一对新婚夫妇**。因此并不是所有的预订要求都能得到满足。\n\n当一些预订要求**在时间上发生了重叠**的时候，我们就称这些预订要求发生了冲突。\n\n对于那些不与任何其他预订要求发生冲突的预订单，它们**必然会被接受**。因为这对宾馆和顾客双方面来说都是件好事。\n\n而对于发生冲突的预订要求，宾馆经理则**必须拒绝其中的一部分**，以保证宾馆有秩序地运转。\n\n显然，对于同一时间内发生冲突的预定要求，宾馆经理**最多只能接受其中的一个**。经理也有可能**拒绝同一时间段内的所有预定要求**，因为这样可以避免顾客间发生争执。\n\n经理在做出决策后，需要将整个计划公布于众，以示公平。这是一个必须慎重的决定，因为它牵涉到诸多方面的因素。经理首先考虑的当然是利润问题。他必然希望获得尽可能多的收入。可是宾馆在获得经济效益的同时，同时也应该兼顾到社会效益，不能太惟利是图，还必须照顾到顾客们的感情。如果宾馆经理单从最大获利角度出发来决定接受或拒绝顾客的预订要求的话，就会引起人们的不满。\n\n经理有一个学过市场营销学的顾问。顾问告诉经理，可以采取一种折中的做法，放弃牟利最大的方案，而采纳获利第 $k$ 大的方案。他还通过精确的市场分析，找到了 $k$ 的最佳取值点，告诉了宾馆经理。\n\n\n现在请你帮助宾馆经理，从一大堆预订要求中，在上述原则下寻找到获利第 $k$ 大的方案。宾馆经理将根据此方案来决定接受和拒绝哪些预订要求。\n\n\n当然，可能有若干种方案的获利是一样大的。这时候，它们同属于获利第 $i$ 大的方案而不区分看待。例如，假如有 $3$ 种方案的收入同时为 $3$ ，有 $2$ 种方案的收入为 $2$ ，则收入为 $3$ 的方案都属于获利最大，收入为 $2$ 的方案都属于获利第二大。依次类推。\n\n假设所有的住、离店登记都在中午 $12$ 点进行。", "inputFormat": "输入文件的第一行是两个数，$k$ 和 $t$ 。其中 $k$ 表示需要选择获利第 $k$ 大的方案； $t$ 表示顾客的身份共划分为 $t$ 类。\n\n第二行是一个数 $y$ ，表示下一年的年份。\n\n第三行是一个数 $r$ ，表示共有 $r$ 个预订要求。\n\n以下 $r$ 行每行是一个预订要求，格式为：`m1/d1 TO m2/d2 id`；\n\n其中 $m_1,d_1$ 和 $m_2,d_2$ 分别表示到达和离去日期。 $id$ 是一个整数 （$1 \\leq id \\leq t$） ，用来标识预订顾客的身份。\n\n最后 $t$ 行每行为一个整数 $P_{i}$ ($1 \\leq i \\leq t$）表示蜜月房对于身份代号为 $i$ 的顾客的日收费标准。\n\n例：某对顾客于 $6$ 月 $1$ 日到达， $6$ 月 $3$ 日离去，对他们的日收费标准为 $m$ 元/天，则他们共住店两天，需付钱 $2m$ 元。", "outputFormat": "输出文件仅包含一个整数 $p$ ，表示在获利第 $k$ 大的方案下，宾馆的年度总收入额。如果获利第 $k$ 大的方案不存在，则输出 $-1$ 。", "hint": "数据范围：\n\n$1 \\leq k \\leq 100$ ，$1 \\leq t \\leq 100$，$0 \\leq r \\leq 20000$，$1 \\leq P_{i} \\leq 32767$", "locale": "zh-CN"}}}
{"pid": "P4635", "type": "P", "difficulty": 6, "samples": [["7 3 7\n2\n5\n3\n0\n3\n1\n2\n1 1 4 3\n1 4 7 4\n2 1 7", "2"], ["5 5 2\n1\n0\n0\n1\n0\n2 1 4\n2 1 5\n1 3 5 1\n2 1 4\n2 1 3", "1\n2\n2\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "各省省选", "树状数组", "上海", "差分"], "title": "[SHOI2011] 改进代码", "background": "", "description": " PP 写了两段对数组进行操作的代码。\n\n对于 Pascal 选手，两段代码分别如下： \n\n```\nprocedure operate1(l, r, c : longint);\nvar\n    i : longint;\nbegin\n    for i := l to r do\n        a[i] := (a[i] + c) mod p;\nend;\n\nprocedure operate2(l, r : longint);\nvar\n    i, cnt : longint;\nbegin\n    cnt := 0;\n    for i := l to r - 1 do\n        if a[i] > a[i + 1]\n            then cnt := cnt + 1;\n    writeln(cnt);\nend;\n```\n\n对于 C / C++ 选手，两段代码分别如下：\n\n```cpp\nvoid operate1(int l, int r, int c)\n{\n    int i;\n    for (i = l; i <= r; ++i)\n        a[i] = (a[i] + c) % p;\n}\n\nvoid operate2(int l, int r)\n{\n    int i, cnt = 0;\n    for (i = l; i < r; ++i)\n        if (a[i] > a[i + 1])\n            ++ cnt;\n    printf(\"%d\\n\", cnt);\n}\n```\n\n于是，主程序就可以通过调用这两个子程序对数组 $a_i$​​ 进行操作，下面是示例代码。\n\n对于 Pascal 选手，代码如下：\n\n```\nbegin\n    operate1(1, 4, 3);\n    operate1(4, 7, 4);\n    operate2(1, 7);\nend.\n```\n\n对于 C / C++ 选手，代码如下：\n\n```\nint main()\n{\n    operate1(1, 4, 3);\n    operate1(4, 7, 4);\n    operate2(1, 7);\n}\n```\n\n但是 QQ 觉得 PP 的程序效率太低了，他想请你优化 PP 的代码。即，对于一段只包含 ``operate1`` 、 ``operate2`` 两种语句的主程序以及运行之前数组 $a_i$​​ 的初始值，请你计算出他的输出。", "inputFormat": "输入的第一行包含 $3$ 个整数 $n,m,p$ 。其中 $n$ 是操作中 $l,r$ 的上界， $m$ 是主程序中的语句数， $p$ 是程序中的常数 $p$ 的值。\n\n接下去 $n$ 行每行一个整数，依次是 $a_1,a_2,…,a_n$ 的初始化的值。输入保证这些值都在 $0,1,…,p-1$ 之中。\n\n接下去 $m$ 行每行依次描述主程序的一行代码。每一行的格式为下面两者之一：\n\n-    ``1 l r c`` : 表示代码 ``operate1(l, r, c);`` 。\n\n-    ``2 l r`` : 表示代码 ``operate2(l, r);`` 。\n\n", "outputFormat": "输出即为输入对应的程序的输出。", "hint": "**数据范围与提示**\n\n测试点 $1$：$n \\le 1000,m \\le 2000$。\n\n测试点 $2 \\sim 3$：$n \\le 100000$,$m \\le 200000$,$c \\le 1$,$a_i \\le 100000$,$p>500000$。\n\n测试点 $4$：$n \\le 100000,m \\le 200000,l=1,r=n$。\n\n测试点 $5 \\sim 6$：$n \\le 100000,m \\le 200000$ 且对于所有 ``operate1`` 的参数都有 $l=1,r=n$。\n\n测试点 $7 \\sim 10$：$n \\le 100000,m \\le 200000$。\n\n保证 $1 \\le l \\le r \\le n,0 \\le c \\le 10^8,p \\le 10^6$​​.", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2011] Improved Code", "background": "", "description": "PP wrote two pieces of code to operate on an array.\n\nFor Pascal users, the two procedures are as follows:\n\n```\nprocedure operate1(l, r, c : longint);\nvar\n    i : longint;\nbegin\n    for i := l to r do\n        a[i] := (a[i] + c) mod p;\nend;\n\nprocedure operate2(l, r : longint);\nvar\n    i, cnt : longint;\nbegin\n    cnt := 0;\n    for i := l to r - 1 do\n        if a[i] > a[i + 1]\n            then cnt := cnt + 1;\n    writeln(cnt);\nend;\n```\n\nFor C / C++ users, the two functions are as follows:\n\n```cpp\nvoid operate1(int l, int r, int c)\n{\n    int i;\n    for (i = l; i <= r; ++i)\n        a[i] = (a[i] + c) % p;\n}\n\nvoid operate2(int l, int r)\n{\n    int i, cnt = 0;\n    for (i = l; i < r; ++i)\n        if (a[i] > a[i + 1])\n            ++ cnt;\n    printf(\"%d\\n\", cnt);\n}\n```\n\nThen, the main program can operate on the array $a_i$ by calling these two subroutines. The following is sample code.\n\nFor Pascal users, the code is:\n\n```\nbegin\n    operate1(1, 4, 3);\n    operate1(4, 7, 4);\n    operate2(1, 7);\nend.\n```\n\nFor C / C++ users, the code is:\n\n```\nint main()\n{\n    operate1(1, 4, 3);\n    operate1(4, 7, 4);\n    operate2(1, 7);\n}\n```\n\nHowever, QQ thinks PP’s program is too slow, and he wants you to optimize PP’s code. That is, given a main program that contains only two kinds of statements, `operate1` and `operate2`, and the initial values of the array $a_i$ before running, please compute the output of the program.", "inputFormat": "The first line contains $3$ integers $n, m, p$. Here, $n$ is the upper bound of $l, r$ in the operations, $m$ is the number of statements in the main program, and $p$ is the value of the constant $p$ in the program.\n\nIn the next $n$ lines, each line contains one integer, which are the initial values of $a_1, a_2, \\ldots, a_n$ in order. The input guarantees that these values are all within $0, 1, \\ldots, p - 1$.\n\nIn the next $m$ lines, each line describes one line of code in the main program. Each line has one of the following two formats:\n\n- `1 l r c`: represents the statement `operate1(l, r, c);`.\n- `2 l r`: represents the statement `operate2(l, r);`.", "outputFormat": "Output the output produced by the program corresponding to the given input.", "hint": "**Constraints and notes**\n\nTest point $1$: $n \\le 1000, m \\le 2000$.\n\nTest points $2 \\sim 3$: $n \\le 100000$, $m \\le 200000$, $c \\le 1$, $a_i \\le 100000$, $p > 500000$.\n\nTest point $4$: $n \\le 100000, m \\le 200000, l = 1, r = n$.\n\nTest points $5 \\sim 6$: $n \\le 100000, m \\le 200000$, and for all `operate1` parameters, $l = 1, r = n$.\n\nTest points $7 \\sim 10$: $n \\le 100000, m \\le 200000$.\n\nIt is guaranteed that $1 \\le l \\le r \\le n$, $0 \\le c \\le 10^8$, $p \\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2011] 改进代码", "background": "", "description": " PP 写了两段对数组进行操作的代码。\n\n对于 Pascal 选手，两段代码分别如下： \n\n```\nprocedure operate1(l, r, c : longint);\nvar\n    i : longint;\nbegin\n    for i := l to r do\n        a[i] := (a[i] + c) mod p;\nend;\n\nprocedure operate2(l, r : longint);\nvar\n    i, cnt : longint;\nbegin\n    cnt := 0;\n    for i := l to r - 1 do\n        if a[i] > a[i + 1]\n            then cnt := cnt + 1;\n    writeln(cnt);\nend;\n```\n\n对于 C / C++ 选手，两段代码分别如下：\n\n```cpp\nvoid operate1(int l, int r, int c)\n{\n    int i;\n    for (i = l; i <= r; ++i)\n        a[i] = (a[i] + c) % p;\n}\n\nvoid operate2(int l, int r)\n{\n    int i, cnt = 0;\n    for (i = l; i < r; ++i)\n        if (a[i] > a[i + 1])\n            ++ cnt;\n    printf(\"%d\\n\", cnt);\n}\n```\n\n于是，主程序就可以通过调用这两个子程序对数组 $a_i$​​ 进行操作，下面是示例代码。\n\n对于 Pascal 选手，代码如下：\n\n```\nbegin\n    operate1(1, 4, 3);\n    operate1(4, 7, 4);\n    operate2(1, 7);\nend.\n```\n\n对于 C / C++ 选手，代码如下：\n\n```\nint main()\n{\n    operate1(1, 4, 3);\n    operate1(4, 7, 4);\n    operate2(1, 7);\n}\n```\n\n但是 QQ 觉得 PP 的程序效率太低了，他想请你优化 PP 的代码。即，对于一段只包含 ``operate1`` 、 ``operate2`` 两种语句的主程序以及运行之前数组 $a_i$​​ 的初始值，请你计算出他的输出。", "inputFormat": "输入的第一行包含 $3$ 个整数 $n,m,p$ 。其中 $n$ 是操作中 $l,r$ 的上界， $m$ 是主程序中的语句数， $p$ 是程序中的常数 $p$ 的值。\n\n接下去 $n$ 行每行一个整数，依次是 $a_1,a_2,…,a_n$ 的初始化的值。输入保证这些值都在 $0,1,…,p-1$ 之中。\n\n接下去 $m$ 行每行依次描述主程序的一行代码。每一行的格式为下面两者之一：\n\n-    ``1 l r c`` : 表示代码 ``operate1(l, r, c);`` 。\n\n-    ``2 l r`` : 表示代码 ``operate2(l, r);`` 。\n\n", "outputFormat": "输出即为输入对应的程序的输出。", "hint": "**数据范围与提示**\n\n测试点 $1$：$n \\le 1000,m \\le 2000$。\n\n测试点 $2 \\sim 3$：$n \\le 100000$,$m \\le 200000$,$c \\le 1$,$a_i \\le 100000$,$p>500000$。\n\n测试点 $4$：$n \\le 100000,m \\le 200000,l=1,r=n$。\n\n测试点 $5 \\sim 6$：$n \\le 100000,m \\le 200000$ 且对于所有 ``operate1`` 的参数都有 $l=1,r=n$。\n\n测试点 $7 \\sim 10$：$n \\le 100000,m \\le 200000$。\n\n保证 $1 \\le l \\le r \\le n,0 \\le c \\le 10^8,p \\le 10^6$​​.", "locale": "zh-CN"}}}
{"pid": "P4636", "type": "P", "difficulty": 6, "samples": [["6\n1 0\n2 0\n3 0\n3 2\n4 0\n5 0", "1.00"], ["6\n-2 -1\n-1 2\n1 2\n2 3\n3 3\n4 4", "0.86"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "各省省选", "上海"], "title": "[SHOI2011] 直线拟合", "background": "", "description": "平面上有 $n$ 个点 $v_i(x_i,y_i)$ 。求 $D(l)=\\max_{1\\le i\\le n} dis(v_i,l)$ 的最小可能值，其中变量 $l$ 是平面上的一条直线，函数 $dis(v_i,l)$ 表示直线 $l$ 与点 $v_i$ 之间的距离。", "inputFormat": "输入的第一行为一个正整数 $n$ 。接下来 $n$ 行，每行一对整数 $x_i , y_i$​​ ，用一个空格分隔，依次表示这 $n$ 个点的坐标，其中 $|x_i|,|y_i| \\le 10^8$ ，且不同的点不会重合。", "outputFormat": "输出只有一行，包含一个实数，即 $D(l)$ 的最小值，四舍五入到小数点后两位。", "hint": "**样例解释 1**\n\n样例 $1$ 中， 取到最小值时的直线 $l$ 为 $y=1$ 。\n\n**样例解释 2**\n\n样例 $2$ 中的 $6$ 个点，以及 $D(l)$ 取到最小值时的直线 $l$ 如图所示。\n\n![1](https://cdn.luogu.com.cn/upload/pic/20067.png)\n\n**数据范围与提示**\n\n测试点 $1$：$n=3$。\n\n测试点 $2 \\sim 4$：$3 \\le n \\le 100$。\n\n测试点 $5 \\sim 7$：$100 < n \\le 100000$ ，且输入文件如下生成：选定一条线段，每次先在该线段上等概率随机选择一个点，再取离该点最近的整点。\n\n测试点 $8 \\sim 10$：$3 < n \\le 100000$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2011] Line Fitting", "background": "", "description": "There are $n$ points $v_i(x_i, y_i)$ on the plane. Find the minimum possible value of $D(l)=\\max_{1\\le i\\le n} dis(v_i, l)$, where the variable $l$ is a line on the plane, and $dis(v_i, l)$ denotes the distance between the line $l$ and the point $v_i$.", "inputFormat": "The first line contains a positive integer $n$. The next $n$ lines each contain a pair of integers $x_i, y_i$, separated by a space, representing the coordinates of the $n$ points in order. Here $|x_i|, |y_i| \\le 10^8$, and no two points coincide.", "outputFormat": "Output a single line containing a real number, the minimum value of $D(l)$, rounded to two decimal places.", "hint": "**Sample Explanation 1**\n\nIn sample $1$, when the minimum is achieved, the line $l$ is $y=1$.\n\n**Sample Explanation 2**\n\nIn sample $2$, the $6$ points and the line $l$ when $D(l)$ reaches its minimum are shown in the figure.\n\n![1](https://cdn.luogu.com.cn/upload/pic/20067.png)\n\n**Constraints and Notes**\n\nTest case $1$: $n=3$.\n\nTest cases $2 \\sim 4$: $3 \\le n \\le 100$.\n\nTest cases $5 \\sim 7$: $100 < n \\le 100000$, and the input file is generated as follows: choose a line segment; each time, first pick a point uniformly at random on the segment, then take the lattice point closest to that point.\n\nTest cases $8 \\sim 10$: $3 < n \\le 100000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2011] 直线拟合", "background": "", "description": "平面上有 $n$ 个点 $v_i(x_i,y_i)$ 。求 $D(l)=\\max_{1\\le i\\le n} dis(v_i,l)$ 的最小可能值，其中变量 $l$ 是平面上的一条直线，函数 $dis(v_i,l)$ 表示直线 $l$ 与点 $v_i$ 之间的距离。", "inputFormat": "输入的第一行为一个正整数 $n$ 。接下来 $n$ 行，每行一对整数 $x_i , y_i$​​ ，用一个空格分隔，依次表示这 $n$ 个点的坐标，其中 $|x_i|,|y_i| \\le 10^8$ ，且不同的点不会重合。", "outputFormat": "输出只有一行，包含一个实数，即 $D(l)$ 的最小值，四舍五入到小数点后两位。", "hint": "**样例解释 1**\n\n样例 $1$ 中， 取到最小值时的直线 $l$ 为 $y=1$ 。\n\n**样例解释 2**\n\n样例 $2$ 中的 $6$ 个点，以及 $D(l)$ 取到最小值时的直线 $l$ 如图所示。\n\n![1](https://cdn.luogu.com.cn/upload/pic/20067.png)\n\n**数据范围与提示**\n\n测试点 $1$：$n=3$。\n\n测试点 $2 \\sim 4$：$3 \\le n \\le 100$。\n\n测试点 $5 \\sim 7$：$100 < n \\le 100000$ ，且输入文件如下生成：选定一条线段，每次先在该线段上等概率随机选择一个点，再取离该点最近的整点。\n\n测试点 $8 \\sim 10$：$3 < n \\le 100000$。", "locale": "zh-CN"}}}
{"pid": "P4637", "type": "P", "difficulty": 6, "samples": [["4\n0 1\n2 2\n8 7\n11 2", "2.3333"], ["3\n-10 10\n0 1\n10 10", "2.3333"], ["2\n1 10\n2 100", "1.0000\n"], ["9\n1 10\n2 10\n3 10\n4 10\n5 10\n6 10\n7 10\n8 10\n1000 2000", "1.8889"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "各省省选", "上海", "Special Judge", "强连通分量", "期望"], "title": "[SHOI2011] 扫雷机器人", "background": "", "description": "扫雷是陆军战场上一项重要的而危险的任务。为此， AL 军工厂专门研制了一种扫雷机器人。这种机器人是专门针对直线形雷阵设计的。所谓直线形雷阵，就是所有的地雷都埋在同一条直线上。例如图中黑点表示的雷阵就是直线形雷阵。\n\n![0](https://cdn.luogu.com.cn/upload/pic/20066.png)\n\nAL 军工厂生产的扫雷机器人的排雷方法只有一种，那就是安全引爆。每次，机器人在所有探测到的地雷中选择一颗引爆。被引爆的地雷会接连引爆不超过他的爆炸威力范围的其它地雷，这些被间接引爆的地雷还能引起进一步的连锁爆炸。例如图中，用一个圆的半径表示地雷的爆炸威力。如果引爆 $2$ 号雷， $1$ 、 $2$ 号雷都会爆炸；如果引爆 $3$ 号雷， $4$ 颗地雷全都会爆炸；而如果引爆 $4$ 号雷，那就只有它一颗爆炸。\n\n虽然是机器人，但引爆也是危险的。所以，扫雷机器人的订购人希望机器人能在实战中采取引爆次数尽可能少的炸毁所有地雷的排雷方案。于是 AL 军工厂想就此方面对机器人进行测试。为了评估机器人的表现， AL 军工厂打算事先计算出：在一个直线形雷阵（即输入的雷阵）中，如果随机进行引爆，完成排雷工作所需要引爆次数的期望；并将这个值与机器人的实际排雷方案相比较，来评估他的表现。\n\n所谓“随机进行引爆”是指，每次在所有没有被引爆的地雷中等概率的随机选择一个进行引爆。当这一次引爆引发的连环爆炸结束后，如果还有地雷没有被引爆，则重复上面的操作，直到所有地雷都被引爆为止。", "inputFormat": "输入的第一行是一个正整数 $n$，表示地雷的个数。\n\n接下去 $n$ 行，每行描述一颗地雷。其中，第 $i+1$ 行有两个整数 $x_i$ 和 $d_i$，分别是地雷的坐标和地雷的爆炸威力。也就是说，第 $i$ 号地雷的爆炸能直接进一步引爆第 $j$ 号地雷的条件是 $|x_i-x_j| \\le d$。\n\n输入保证： $|x_i| \\le 10^8$，$1 \\le d_i \\le 10^8$。", "outputFormat": "输出只有一行，包含一个实数，即为答案。四舍五入到小数点后四位。", "hint": "**提示**\n\n本题的试题目录下有 $10$ 个额外的输入样例文件 ``robot20111.in~robot201110.in`` ，以及它们对应的输出样例文件 ``robot20111.out~robot201110.out`` 。这些数据符合本题中关于数据规模的全部约定，但它们不是最终的测试数据。\n\n**[下载地址](https://pan.baidu.com/s/1Q5X52FMH38UYvmrEsVsEkA)**，密码：ypbv。\n\n**评分方式**\n\n在每个测试点，如果您的输出是 $YourAns$ ，而标准答案是 $StdAns$ ，那么：\n\n-    当 $ |YourAns-StdAns| \\le 0.0001$ 时，该测试点得 $10$ 分。\n\n-    当 $0.01 \\ge |YourAns-StdAns| > 0.0001$ 时，该测试点得 $6$ 分。\n\n-    当 $0.5 \\ge |YourAns-StdAns| > 0.01$ 时，该测试点得 $2$ 分。\n\n-    否则得 $0$ 分。\n\n**数据范围**\n\n测试点 $1$：$n \\le 20$。\n\n测试点 $2$：$n \\le 200$ ，且任意方案都保证引爆次数不超过 $20$。\n\n测试点 $3$：$n \\le 200$。\n\n测试点 $4 \\sim 5$：$n \\le 4000$ ，且任意方案都保证引爆次数不超过 $20$。\n\n测试点 $6 \\sim 10$：$n \\le 4000$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2011] Minesweeper Robot", "background": "", "description": "Minesweeping is an important and dangerous task on the army battlefield. For this purpose, the AL military factory specially developed a minesweeping robot. This robot is designed specifically for linear minefields. A so-called linear minefield means that all mines are buried on the same straight line. For example, in the figure, the minefield marked by black dots is a linear minefield.\n\n![0](https://cdn.luogu.com.cn/upload/pic/20066.png)\n\nThe AL military factory’s minesweeping robot has only one method to clear mines: safe detonation. Each time, the robot chooses one mine among all detected mines to detonate. The detonated mine will in turn detonate other mines that are within its blast range. These indirectly detonated mines can further cause chain explosions. For example, in the figure, a circle radius represents a mine’s blast range. If mine $2$ is detonated, mines $1$ and $2$ will explode; if mine $3$ is detonated, all $4$ mines will explode; but if mine $4$ is detonated, then only mine $4$ will explode.\n\nEven for a robot, detonation is dangerous. Therefore, the buyer hopes that in real combat the robot can use a clearing plan that destroys all mines with as few detonations as possible. So the AL military factory wants to test the robot on this aspect. To evaluate the robot’s performance, the AL military factory plans to compute in advance: in a linear minefield (i.e., the input minefield), if detonations are performed randomly, the expected number of detonations needed to finish clearing all mines. This value will then be compared with the robot’s actual clearing plan to evaluate its performance.\n\n“Random detonation” means that each time, one mine is chosen uniformly at random among all mines that have not been detonated, and then detonated. After the chain reaction caused by this detonation ends, if there are still mines that have not been detonated, repeat the above operation until all mines have been detonated.", "inputFormat": "The first line contains a positive integer $n$, the number of mines.\n\nThe next $n$ lines describe the mines in order of their positions, one mine per line. On line $i+1$, there are two integers $x_i$ and $d_i$, representing the coordinate of the mine and its blast power. That is, mine $i$ can directly detonate mine $j$ if $|x_i-x_j| \\le d_i$. The input guarantees: $|x_i| \\le 10^8$, $1 \\le d_i \\le 10^8$.", "outputFormat": "Output one line containing one real number, which is the answer. Round to four digits after the decimal point.", "hint": "**Hint**\n\nIn the problem directory, there are $10$ additional input sample files ``robot20111.in~robot201110.in`` and their corresponding output sample files ``robot20111.out~robot201110.out``. These files satisfy all constraints in this problem, but they are not the final testdata.\n\n**[Download link](https://pan.baidu.com/s/1Q5X52FMH38UYvmrEsVsEkA)**, password: ypbv.\n\n**Scoring**\n\nFor each test point, if your output is $YourAns$ and the standard answer is $StdAns$, then:\n\n- When $|YourAns-StdAns| \\le 0.0001$, you get $10$ points for that test point.\n- When $0.01 \\ge |YourAns-StdAns| > 0.0001$, you get $6$ points.\n- When $0.5 \\ge |YourAns-StdAns| > 0.01$, you get $2$ points.\n- Otherwise, you get $0$ points.\n\n**Constraints**\n\nTest point $1$: $n \\le 20$.\n\nTest point $2$: $n \\le 200$, and any strategy guarantees that the number of detonations does not exceed $20$.\n\nTest point $3$: $n \\le 200$.\n\nTest points $4 \\sim 5$: $n \\le 4000$, and any strategy guarantees that the number of detonations does not exceed $20$.\n\nTest points $6 \\sim 10$: $n \\le 4000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2011] 扫雷机器人", "background": "", "description": "扫雷是陆军战场上一项重要的而危险的任务。为此， AL 军工厂专门研制了一种扫雷机器人。这种机器人是专门针对直线形雷阵设计的。所谓直线形雷阵，就是所有的地雷都埋在同一条直线上。例如图中黑点表示的雷阵就是直线形雷阵。\n\n![0](https://cdn.luogu.com.cn/upload/pic/20066.png)\n\nAL 军工厂生产的扫雷机器人的排雷方法只有一种，那就是安全引爆。每次，机器人在所有探测到的地雷中选择一颗引爆。被引爆的地雷会接连引爆不超过他的爆炸威力范围的其它地雷，这些被间接引爆的地雷还能引起进一步的连锁爆炸。例如图中，用一个圆的半径表示地雷的爆炸威力。如果引爆 $2$ 号雷， $1$ 、 $2$ 号雷都会爆炸；如果引爆 $3$ 号雷， $4$ 颗地雷全都会爆炸；而如果引爆 $4$ 号雷，那就只有它一颗爆炸。\n\n虽然是机器人，但引爆也是危险的。所以，扫雷机器人的订购人希望机器人能在实战中采取引爆次数尽可能少的炸毁所有地雷的排雷方案。于是 AL 军工厂想就此方面对机器人进行测试。为了评估机器人的表现， AL 军工厂打算事先计算出：在一个直线形雷阵（即输入的雷阵）中，如果随机进行引爆，完成排雷工作所需要引爆次数的期望；并将这个值与机器人的实际排雷方案相比较，来评估他的表现。\n\n所谓“随机进行引爆”是指，每次在所有没有被引爆的地雷中等概率的随机选择一个进行引爆。当这一次引爆引发的连环爆炸结束后，如果还有地雷没有被引爆，则重复上面的操作，直到所有地雷都被引爆为止。", "inputFormat": "输入的第一行是一个正整数 $n$，表示地雷的个数。\n\n接下去 $n$ 行，每行描述一颗地雷。其中，第 $i+1$ 行有两个整数 $x_i$ 和 $d_i$，分别是地雷的坐标和地雷的爆炸威力。也就是说，第 $i$ 号地雷的爆炸能直接进一步引爆第 $j$ 号地雷的条件是 $|x_i-x_j| \\le d$。\n\n输入保证： $|x_i| \\le 10^8$，$1 \\le d_i \\le 10^8$。", "outputFormat": "输出只有一行，包含一个实数，即为答案。四舍五入到小数点后四位。", "hint": "**提示**\n\n本题的试题目录下有 $10$ 个额外的输入样例文件 ``robot20111.in~robot201110.in`` ，以及它们对应的输出样例文件 ``robot20111.out~robot201110.out`` 。这些数据符合本题中关于数据规模的全部约定，但它们不是最终的测试数据。\n\n**[下载地址](https://pan.baidu.com/s/1Q5X52FMH38UYvmrEsVsEkA)**，密码：ypbv。\n\n**评分方式**\n\n在每个测试点，如果您的输出是 $YourAns$ ，而标准答案是 $StdAns$ ，那么：\n\n-    当 $ |YourAns-StdAns| \\le 0.0001$ 时，该测试点得 $10$ 分。\n\n-    当 $0.01 \\ge |YourAns-StdAns| > 0.0001$ 时，该测试点得 $6$ 分。\n\n-    当 $0.5 \\ge |YourAns-StdAns| > 0.01$ 时，该测试点得 $2$ 分。\n\n-    否则得 $0$ 分。\n\n**数据范围**\n\n测试点 $1$：$n \\le 20$。\n\n测试点 $2$：$n \\le 200$ ，且任意方案都保证引爆次数不超过 $20$。\n\n测试点 $3$：$n \\le 200$。\n\n测试点 $4 \\sim 5$：$n \\le 4000$ ，且任意方案都保证引爆次数不超过 $20$。\n\n测试点 $6 \\sim 10$：$n \\le 4000$。", "locale": "zh-CN"}}}
{"pid": "P4638", "type": "P", "difficulty": 6, "samples": [["3 3\n3 1 10\n2 1 2 2\n2 1 3 3\n1 2 6", "7"], ["2 3\n2 3\n2 1 2 1\n1 2 2\n1 2 2", "5"], ["6 6\n6 3 2 0 1 3\n2 1 2 0\n1 3 3\n1 1 1\n2 2 3 8\n2 4 5 2\n2 4 6 6", "15"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "各省省选", "上海"], "title": "[SHOI2011] 银行家", "background": "", "description": "你在一家银行工作，任务是帮助客户取出他们存放在保险箱里的金币。\n\n银行里有 $m$ 个保险箱，你没有办法打开这些保险箱，因为钥匙都在客户的手里。一个客户可能有很多个保险箱的钥匙，一个保险箱的钥匙也可能被多个客户拥有。今天早上，经理已经告知，你需要按照顺序接待 $n$ 个客户（任何客户都不会同时到场），你也知道，第 $i$ 个客户会要求取走 $c_i$​​ 枚金币。每个客户来到银行的时候，会打开所有他能打开的保险箱，然后从中取走 $c_i$​​ 枚金币（任何金币都没有区别），如果这些保险箱里的金币数量不足 ，他会感到不高兴，在取走尽量多的金币之后，到你的经理那里去投诉你们银行的服务质量太差了。\n\n你当然不希望“上帝”的投诉让你丢了工作，于是想到了个补救的办法：虽然每个客户走的时候都会把保险箱重新关上，但是你可以在他取金币的时候，偷偷地调整被打开的保险箱里的金币数量，譬如说把 $1$ 号保险里多余的 $5$ 枚放到 $2$ 号里，这样说不定下个客户来的时候，就能取到更多的金币了。\n\n尽管有这样的方法，还是可能没法完成所有客户的要求。然而，你希望，尽量帮助客户取走更多的金币，这样才能消除他们的怒气，保住这份来之不易的工作和薪水。 ", "inputFormat": "第一行有两个正整数： $m$ 和 $n$ ， $m$ 表示保险柜的数量， $n$ 表示客户的数量。\n\n第二行有 $m$ 个非负正数，表示银行在开始营业前，第 $1$ 号保险柜到第 $m$ 号保险柜的金币数量。 接下来有 $n$ 行，按照前来银行的顺序，依次描述了每个客户的情况。每行的开始都是一个非负整数 $k$ ，接着有 $k$ 个 $1$ 到 $m$ 之间的整数 $a_1,a_2,…,a_k$ ，表示这个客户拥有 $a_1$​​ 号、 $a_2$ 号，直到 $a_k$​​ 号保险箱的钥匙。最后还有一个非负整数 $c_i$​​ ，表示他需要的金币数量。 输入保证所有出现在输入数据中的整数都不超过 $10000$ 。", "outputFormat": "输出只需要一个整数，表示所有客户可以取走的金币总数的最大值。\n输入保证答案不会超过 $100000$ 。 ", "hint": "### 数据范围\n\n测试点编号 .|n$\\le$ .|m$\\le$ .\n-|-|-\n1|30|100\n2|40|50\n3|100|400\n4|100|400\n5|100|400\n6|200|500\n7|300|500\n8|400|1500\n9|500|2000\n10|600|2500", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2011] Banker", "background": "", "description": "You work at a bank, and your job is to help customers withdraw the gold coins stored in their safe deposit boxes.\n\nThere are $m$ safe deposit boxes in the bank. You cannot open these boxes because the keys are held by the customers. A customer may have keys to many boxes, and a box may also have keys held by multiple customers. This morning, the manager told you that you must receive $n$ customers in order (no two customers will arrive at the same time). You also know that the $i$-th customer will ask to withdraw $c_i$ gold coins. When a customer arrives, they will open all the boxes they can open and take $c_i$ coins from them (all coins are identical). If the total number of coins in these boxes is not enough, they will be unhappy. After taking as many coins as possible, they will go to your manager to complain that the bank’s service is terrible.\n\nOf course, you do not want complaints to cost you your job, so you come up with a remedy: although each customer will close the boxes again when leaving, while they are taking coins, you can secretly adjust the numbers of coins in the opened boxes. For example, you can move the extra $5$ coins in box $1$ into box $2$, so that the next customer may be able to withdraw more coins.\n\nEven with this method, it may still be impossible to satisfy all customers’ requests. However, you want to help customers withdraw as many coins as possible in total, so as to reduce their anger and keep this hard-earned job and salary.", "inputFormat": "The first line contains two positive integers $m$ and $n$, where $m$ is the number of safe deposit boxes and $n$ is the number of customers.\n\nThe second line contains $m$ non-negative integers, representing the numbers of coins in boxes $1$ to $m$ before the bank opens. Then follow $n$ lines, describing each customer in the order they arrive. Each line starts with a non-negative integer $k$, followed by $k$ integers $a_1,a_2,\\ldots,a_k$ between $1$ and $m$, indicating that the customer has the keys to boxes $a_1$, $a_2$, up to $a_k$. Finally, there is a non-negative integer $c_i$, indicating the number of coins they need. The input guarantees that all integers appearing in the input data do not exceed $10000$.", "outputFormat": "Output one integer, the maximum possible total number of coins that all customers can withdraw. The input guarantees that the answer does not exceed $100000$.", "hint": "### Constraints\n\nTest point ID | $n \\le$ | $m \\le$\n-|-|-\n1 | 30 | 100\n2 | 40 | 50\n3 | 100 | 400\n4 | 100 | 400\n5 | 100 | 400\n6 | 200 | 500\n7 | 300 | 500\n8 | 400 | 1500\n9 | 500 | 2000\n10 | 600 | 2500\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2011] 银行家", "background": "", "description": "你在一家银行工作，任务是帮助客户取出他们存放在保险箱里的金币。\n\n银行里有 $m$ 个保险箱，你没有办法打开这些保险箱，因为钥匙都在客户的手里。一个客户可能有很多个保险箱的钥匙，一个保险箱的钥匙也可能被多个客户拥有。今天早上，经理已经告知，你需要按照顺序接待 $n$ 个客户（任何客户都不会同时到场），你也知道，第 $i$ 个客户会要求取走 $c_i$​​ 枚金币。每个客户来到银行的时候，会打开所有他能打开的保险箱，然后从中取走 $c_i$​​ 枚金币（任何金币都没有区别），如果这些保险箱里的金币数量不足 ，他会感到不高兴，在取走尽量多的金币之后，到你的经理那里去投诉你们银行的服务质量太差了。\n\n你当然不希望“上帝”的投诉让你丢了工作，于是想到了个补救的办法：虽然每个客户走的时候都会把保险箱重新关上，但是你可以在他取金币的时候，偷偷地调整被打开的保险箱里的金币数量，譬如说把 $1$ 号保险里多余的 $5$ 枚放到 $2$ 号里，这样说不定下个客户来的时候，就能取到更多的金币了。\n\n尽管有这样的方法，还是可能没法完成所有客户的要求。然而，你希望，尽量帮助客户取走更多的金币，这样才能消除他们的怒气，保住这份来之不易的工作和薪水。 ", "inputFormat": "第一行有两个正整数： $m$ 和 $n$ ， $m$ 表示保险柜的数量， $n$ 表示客户的数量。\n\n第二行有 $m$ 个非负正数，表示银行在开始营业前，第 $1$ 号保险柜到第 $m$ 号保险柜的金币数量。 接下来有 $n$ 行，按照前来银行的顺序，依次描述了每个客户的情况。每行的开始都是一个非负整数 $k$ ，接着有 $k$ 个 $1$ 到 $m$ 之间的整数 $a_1,a_2,…,a_k$ ，表示这个客户拥有 $a_1$​​ 号、 $a_2$ 号，直到 $a_k$​​ 号保险箱的钥匙。最后还有一个非负整数 $c_i$​​ ，表示他需要的金币数量。 输入保证所有出现在输入数据中的整数都不超过 $10000$ 。", "outputFormat": "输出只需要一个整数，表示所有客户可以取走的金币总数的最大值。\n输入保证答案不会超过 $100000$ 。 ", "hint": "### 数据范围\n\n测试点编号 .|n$\\le$ .|m$\\le$ .\n-|-|-\n1|30|100\n2|40|50\n3|100|400\n4|100|400\n5|100|400\n6|200|500\n7|300|500\n8|400|1500\n9|500|2000\n10|600|2500", "locale": "zh-CN"}}}
