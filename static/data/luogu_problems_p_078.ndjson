{"pid": "P2578", "type": "P", "difficulty": 5, "samples": [["2 3 0\n1 8 7\n5 4 6\n", "4\n2 3 0\n1 8 7\n5 4 6\n\n1 2 3\n5 8 0\n4 6 7\n\n1 2 3\n0 5 8\n4 6 7\n\n0 1 2\n4 5 3\n6 7 8\n\n0 1 2\n3 4 5\n6 7 8\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "各省省选", "浙江", "Special Judge", "广度优先搜索 BFS", "哈希 hashing"], "title": "[ZJOI2005] 九数码游戏", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/pic/1701.png)\n", "inputFormat": "输入文件中包含三行三列九个数，同行的相邻两数用空格隔开，表示初始状态每个方格上的数字。初始状态不会是目标状态。\n", "outputFormat": "如果目标状态无法达到，则输出“UNSOLVABLE”（引号不输出）。\n\n否则，第一行是一个整数S，表示最少的操作次数。接下来4 × (S + 1)行，每四行表示一个状态：前三行每行三个整数，相邻两数用空格隔开，表示每个方格上的数字，第四行是一个空行，作为分隔。第一个状态必须是初始状态，最后一个状态必须是目标状态。\n\n\n\n", "hint": "由@FlierKing提供SPJ\n", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2005] Nine-Digit Puzzle Game", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/pic/1701.png)", "inputFormat": "The input consists of nine integers arranged in three rows and three columns. In each row, adjacent integers are separated by a space, representing the number on each square in the initial state. The initial state will not be the goal state.", "outputFormat": "If the goal state is unreachable, output UNSOLVABLE (without quotes).\n\nOtherwise, the first line contains an integer $S$, the minimal number of moves. Then output $4 \\times (S + 1)$ lines. Every four lines represent one state: the first three lines each contain three integers separated by a space, representing the numbers on the squares; the fourth line is a blank line used as a separator. The first state must be the initial state, and the last state must be the goal state.", "hint": "SPJ provided by @FlierKing.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2005] 九数码游戏", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/pic/1701.png)\n", "inputFormat": "输入文件中包含三行三列九个数，同行的相邻两数用空格隔开，表示初始状态每个方格上的数字。初始状态不会是目标状态。\n", "outputFormat": "如果目标状态无法达到，则输出“UNSOLVABLE”（引号不输出）。\n\n否则，第一行是一个整数S，表示最少的操作次数。接下来4 × (S + 1)行，每四行表示一个状态：前三行每行三个整数，相邻两数用空格隔开，表示每个方格上的数字，第四行是一个空行，作为分隔。第一个状态必须是初始状态，最后一个状态必须是目标状态。\n\n\n\n", "hint": "由@FlierKing提供SPJ\n", "locale": "zh-CN"}}}
{"pid": "P2579", "type": "P", "difficulty": 5, "samples": [["6 8 1 5 3\r\n0 2\r\n2 1\r\n1 0\r\n0 5\r\n5 1\r\n1 4\r\n4 3\r\n3 5\r\n1\r\n3 0 5 1\r\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "各省省选", "浙江", "矩阵乘法", "构造"], "title": "[ZJOI2005] 沼泽鳄鱼", "background": "", "description": "潘塔纳尔沼泽地号称世界上最大的一块湿地，它地位于巴西中部马托格罗索州的南部地区。每当雨季来临，这里碧波荡漾、生机盎然，引来不少游客。\n\n为了让游玩更有情趣，人们在池塘的中央建设了几座石墩和石桥，每座石桥连接着两座石墩，且每两座石墩之间至多只有一座石桥。这个景点造好之后一直没敢对外开放，原因是池塘里有不少危险的食人鱼。\n\n豆豆先生酷爱冒险，他一听说这个消息，立马赶到了池塘，想做第一个在桥上旅游的人。虽说豆豆爱冒险，但也不敢拿自己的性命开玩笑，于是他开始了仔细的实地勘察，并得到了一些惊人的结论：食人鱼的行进路线有周期性，这个周期只可能是 $2$、$3$ 或者 $4$ 个单位时间。每个单位时间里，食人鱼可以从一个石墩游到另一个石墩。每到一个石墩，如果上面有人它就会实施攻击，否则继续它的周期运动。如果没有到石墩，它是不会攻击人的。\n\n借助先进的仪器，豆豆很快就摸清了所有食人鱼的运动规律，他要开始设计自己的行动路线了。每个单位时间里，他只可以沿着石桥从一个石墩走到另一个石墩，而不可以停在某座石墩上不动，因为站着不动还会有其它危险。如果豆豆和某条食人鱼在同一时刻到达了某座石墩，就会遭到食人鱼的袭击，他当然不希望发生这样的事情。\n\n现在豆豆已经选好了两座石墩 $\\mathrm{Start}$ 和 $\\mathrm{End}$，他想从 $\\mathrm{Start}$ 出发，经过 $K$ 个单位时间后恰好站在石墩 $\\mathrm{End}$ 上。假设石墩可以重复经过（包括 $\\mathrm{Start}$ 和 $\\mathrm{End}$），他想请你帮忙算算，这样的路线共有多少种（当然不能遭到食人鱼的攻击）。", "inputFormat": "输入文件共 $M + 2 + \\mathrm{NFish}$ 行。\n\n第一行包含五个正整数 $N,M,\\mathrm{Start},\\mathrm{End},K$，分别表示石墩数目、石桥数目、$\\mathrm{Start}$ 石墩和 $\\mathrm{End}$ 石墩的编号和一条路线所需的单位时间。石墩用 $0$ 到 $N-1$ 的整数编号。\n\n第 $2$ 到 $M + 1$ 行，给出石桥的相关信息。每行两个整数 $x$ 和 $y$，$0 \\leq x, y \\leq N-1$，表示这座石桥连接着编号为 $x$ 和 $y$ 的两座石墩。\n\n第 $M + 2$ 行是一个整数 $\\mathrm{NFish}$，表示食人鱼的数目。\n\n第 $M + 3$ 到 $M + 2 + \\mathrm{NFish}$ 行，每行给出一条食人鱼的相关信息。每行的第一个整数是 $T$，$T = 2,3$ 或 $4$，表示食人鱼的运动周期。接下来有 $T$ 个数，表示一个周期内食人鱼的行进路线。\n\n- 如果 $T=2$，接下来有 $2$ 个数 $P_0$ 和 $P_1$，食人鱼从 $P_0$ 到 $P_1$，从 $P_1$ 到 $P_0,\\ldots$；\n\n- 如果 $T=3$，接下来有 $3$ 个数 $P_0,P_1$ 和 $P_2$，食人鱼从 $P_0$ 到 $P_1$，从 $P_1$ 到 $P_2$，从 $P_2$ 到 $P_0,\\ldots$；\n\n- 如果 $T=4$，接下来有 $4$ 个数 $P_0,P_1,P_2$ 和 $P_3$，食人鱼从 $P_0$ 到 $P_1$，从 $P_1$ 到 $P_2$，从 $P_2$ 到 $P_3$，从 $P_3$ 到 $P_0,\\ldots$。\n\n豆豆出发的时候所有食人鱼都在自己路线上的 $P_0$ 位置，请放心，这个位置不会是 $\\mathrm{Start}$ 石墩。", "outputFormat": "输出路线的种数，因为这个数可能很大，你只要输出该数除以 $10000$ 的余数就行了。", "hint": "对于 $100 \\%$ 的数据，$1 \\leq N \\leq 50$，$1 \\leq K \\leq 2 \\times 10^9$，$1 \\leq \\mathrm{NFish} \\leq 20$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2005] Swamp Crocodiles", "background": "", "description": "The Pantanal wetland is known as the largest wetland in the world. It is located in the southern part of Mato Grosso do Sul in central Brazil. Every rainy season, waves sparkle and life flourishes here, attracting many tourists.\n\nTo make the visit more interesting, several stone piers and stone bridges were built in the middle of a pond. Each stone bridge connects two stone piers, and between any two stone piers there is at most one bridge. This attraction has never been opened to the public because there are many dangerous piranhas in the pond.\n\nMr. Doudou loves adventure. As soon as he heard the news, he hurried to the pond, wanting to be the first person to walk on the bridges. Although he is adventurous, he does not want to risk his life, so he conducted careful field research and reached some startling conclusions: the routes of the piranhas are periodic, and the period can only be $2$, $3$, or $4$ units of time. In each unit of time, a piranha can swim from one stone pier to another. Upon arriving at a stone pier, if there is someone on it, it will attack; otherwise, it continues its periodic movement. If it is not at a stone pier, it will not attack.\n\nWith advanced instruments, Doudou quickly figured out all the movement patterns of the piranhas, and he started planning his own route. In each unit of time, he can only walk along a bridge from one stone pier to another, and he is not allowed to stay on any pier without moving, because standing still also involves other dangers. If Doudou and a piranha arrive at the same stone pier at the same time, he will be attacked by the piranha, which he certainly wants to avoid.\n\nDoudou has selected two stone piers $\\mathrm{Start}$ and $\\mathrm{End}$. He wants to start from $\\mathrm{Start}$ and be standing on $\\mathrm{End}$ after exactly $K$ units of time. Assume that stone piers may be revisited (including $\\mathrm{Start}$ and $\\mathrm{End}$). He asks you to compute how many such routes exist (of course without being attacked by any piranha).", "inputFormat": "The input consists of $M + 2 + \\mathrm{NFish}$ lines.\n\nThe first line contains five positive integers $N, M, \\mathrm{Start}, \\mathrm{End}, K$, representing the number of stone piers, the number of stone bridges, the indices of $\\mathrm{Start}$ and $\\mathrm{End}$, and the required units of time for a route, respectively. Stone piers are numbered from $0$ to $N - 1$.\n\nLines $2$ to $M + 1$ give the information about the stone bridges. Each of these lines contains two integers $x$ and $y$, $0 \\leq x, y \\leq N - 1$, indicating that the bridge connects the piers numbered $x$ and $y$.\n\nLine $M + 2$ contains an integer $\\mathrm{NFish}$, the number of piranhas.\n\nLines $M + 3$ to $M + 2 + \\mathrm{NFish}$ each describe one piranha. The first integer is $T$, with $T = 2, 3$ or $4$, indicating the period of the piranha’s movement. Then follow $T$ numbers describing the route within one period.\n\n- If $T = 2$, the next $2$ numbers are $P_0$ and $P_1$: the piranha moves from $P_0$ to $P_1$, from $P_1$ to $P_0$, $\\ldots$.\n- If $T = 3$, the next $3$ numbers are $P_0, P_1$ and $P_2$: the piranha moves from $P_0$ to $P_1$, from $P_1$ to $P_2$, from $P_2$ to $P_0$, $\\ldots$.\n- If $T = 4$, the next $4$ numbers are $P_0, P_1, P_2$ and $P_3$: the piranha moves from $P_0$ to $P_1$, from $P_1$ to $P_2$, from $P_2$ to $P_3$, from $P_3$ to $P_0$, $\\ldots$.\n\nAt the time Doudou starts, all piranhas are at position $P_0$ on their routes. Rest assured, this position will not be the $\\mathrm{Start}$ pier.", "outputFormat": "Output the number of routes. Since this number may be large, output the remainder when it is divided by $10000$.", "hint": "For $100\\%$ of the testdata, $1 \\leq N \\leq 50$, $1 \\leq K \\leq 2 \\times 10^9$, $1 \\leq \\mathrm{NFish} \\leq 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2005] 沼泽鳄鱼", "background": "", "description": "潘塔纳尔沼泽地号称世界上最大的一块湿地，它地位于巴西中部马托格罗索州的南部地区。每当雨季来临，这里碧波荡漾、生机盎然，引来不少游客。\n\n为了让游玩更有情趣，人们在池塘的中央建设了几座石墩和石桥，每座石桥连接着两座石墩，且每两座石墩之间至多只有一座石桥。这个景点造好之后一直没敢对外开放，原因是池塘里有不少危险的食人鱼。\n\n豆豆先生酷爱冒险，他一听说这个消息，立马赶到了池塘，想做第一个在桥上旅游的人。虽说豆豆爱冒险，但也不敢拿自己的性命开玩笑，于是他开始了仔细的实地勘察，并得到了一些惊人的结论：食人鱼的行进路线有周期性，这个周期只可能是 $2$、$3$ 或者 $4$ 个单位时间。每个单位时间里，食人鱼可以从一个石墩游到另一个石墩。每到一个石墩，如果上面有人它就会实施攻击，否则继续它的周期运动。如果没有到石墩，它是不会攻击人的。\n\n借助先进的仪器，豆豆很快就摸清了所有食人鱼的运动规律，他要开始设计自己的行动路线了。每个单位时间里，他只可以沿着石桥从一个石墩走到另一个石墩，而不可以停在某座石墩上不动，因为站着不动还会有其它危险。如果豆豆和某条食人鱼在同一时刻到达了某座石墩，就会遭到食人鱼的袭击，他当然不希望发生这样的事情。\n\n现在豆豆已经选好了两座石墩 $\\mathrm{Start}$ 和 $\\mathrm{End}$，他想从 $\\mathrm{Start}$ 出发，经过 $K$ 个单位时间后恰好站在石墩 $\\mathrm{End}$ 上。假设石墩可以重复经过（包括 $\\mathrm{Start}$ 和 $\\mathrm{End}$），他想请你帮忙算算，这样的路线共有多少种（当然不能遭到食人鱼的攻击）。", "inputFormat": "输入文件共 $M + 2 + \\mathrm{NFish}$ 行。\n\n第一行包含五个正整数 $N,M,\\mathrm{Start},\\mathrm{End},K$，分别表示石墩数目、石桥数目、$\\mathrm{Start}$ 石墩和 $\\mathrm{End}$ 石墩的编号和一条路线所需的单位时间。石墩用 $0$ 到 $N-1$ 的整数编号。\n\n第 $2$ 到 $M + 1$ 行，给出石桥的相关信息。每行两个整数 $x$ 和 $y$，$0 \\leq x, y \\leq N-1$，表示这座石桥连接着编号为 $x$ 和 $y$ 的两座石墩。\n\n第 $M + 2$ 行是一个整数 $\\mathrm{NFish}$，表示食人鱼的数目。\n\n第 $M + 3$ 到 $M + 2 + \\mathrm{NFish}$ 行，每行给出一条食人鱼的相关信息。每行的第一个整数是 $T$，$T = 2,3$ 或 $4$，表示食人鱼的运动周期。接下来有 $T$ 个数，表示一个周期内食人鱼的行进路线。\n\n- 如果 $T=2$，接下来有 $2$ 个数 $P_0$ 和 $P_1$，食人鱼从 $P_0$ 到 $P_1$，从 $P_1$ 到 $P_0,\\ldots$；\n\n- 如果 $T=3$，接下来有 $3$ 个数 $P_0,P_1$ 和 $P_2$，食人鱼从 $P_0$ 到 $P_1$，从 $P_1$ 到 $P_2$，从 $P_2$ 到 $P_0,\\ldots$；\n\n- 如果 $T=4$，接下来有 $4$ 个数 $P_0,P_1,P_2$ 和 $P_3$，食人鱼从 $P_0$ 到 $P_1$，从 $P_1$ 到 $P_2$，从 $P_2$ 到 $P_3$，从 $P_3$ 到 $P_0,\\ldots$。\n\n豆豆出发的时候所有食人鱼都在自己路线上的 $P_0$ 位置，请放心，这个位置不会是 $\\mathrm{Start}$ 石墩。", "outputFormat": "输出路线的种数，因为这个数可能很大，你只要输出该数除以 $10000$ 的余数就行了。", "hint": "对于 $100 \\%$ 的数据，$1 \\leq N \\leq 50$，$1 \\leq K \\leq 2 \\times 10^9$，$1 \\leq \\mathrm{NFish} \\leq 20$。", "locale": "zh-CN"}}}
{"pid": "P2580", "type": "P", "difficulty": 3, "samples": [["5  \na\nb\nc\nad\nacd\n3\na\na\ne\n", "OK\nREPEAT\nWRONG\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串", "哈希 hashing", "字典树 Trie", "STL"], "title": "于是他错误的点名开始了", "background": "XS 中学化学竞赛组教练是一个酷爱炉石的人。\n\n他会一边搓炉石一边点名以至于有一天他连续点到了某个同学两次，然后正好被路过的校长发现了然后就是一顿欧拉欧拉欧拉（详情请见已结束比赛 CON900）。", "description": "这之后校长任命你为特派探员，每天记录他的点名。校长会提供化学竞赛学生的人数和名单，而你需要告诉校长他有没有点错名。（为什么不直接不让他玩炉石。）", "inputFormat": "第一行一个整数 $n$，表示班上人数。\n\n接下来 $n$ 行，每行一个字符串表示其名字（互不相同，且只含小写字母，长度不超过 $50$）。\n\n第 $n+2$ 行一个整数 $m$，表示教练报的名字个数。\n\n接下来 $m$ 行，每行一个字符串表示教练报的名字（只含小写字母，且长度不超过 $50$）。", "outputFormat": "对于每个教练报的名字，输出一行。\n\n如果该名字正确且是第一次出现，输出 `OK`，如果该名字错误，输出 `WRONG`，如果该名字正确但不是第一次出现，输出 `REPEAT`。", "hint": "- 对于 $40\\%$ 的数据，$n\\le 1000$，$m\\le 2000$。\n- 对于 $70\\%$ 的数据，$n\\le 10^4$，$m\\le 2\\times 10^4$。\n- 对于 $100\\%$ 的数据，$n\\le 10^4$，$m≤10^5$。\n\n---\n\n$\\text{upd 2022.7.30}$：新增加一组 Hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "And Thus His Mistaken Roll Call Began", "background": "The coach of the XS Middle School chemistry competition team is a big fan of Hearthstone. He plays Hearthstone while taking attendance, and one day he called the same student twice in a row. The principal happened to pass by, and then it was a round of \"ora ora ora\" (for details, see the ended contest CON900).", "description": "After that, the principal appointed you as a special agent to record his roll calls every day. The principal will provide the number of chemistry competition students and the roster, and you need to tell the principal whether he called the names correctly. (Why not just stop him from playing Hearthstone.)", "inputFormat": "The first line contains an integer $n$, the number of students in the class.  \nThe next $n$ lines each contain a string representing a name (all distinct, lowercase letters only, length no more than $50$).  \nThe $(n+2)$-th line contains an integer $m$, the number of names the coach called.  \nThe next $m$ lines each contain a string representing a name called by the coach (lowercase letters only, length no more than $50$).", "outputFormat": "For each name called by the coach, output one line.  \nIf the name is correct and appears for the first time, output `OK`. If the name is incorrect, output `WRONG`. If the name is correct but not the first time, output `REPEAT`.", "hint": "- For $40\\%$ of the testdata, $n \\le 1000$, $m \\le 2000$.\n- For $70\\%$ of the testdata, $n \\le 10^4$, $m \\le 2 \\times 10^4$.\n- For $100\\%$ of the testdata, $n \\le 10^4$, $m \\le 10^5$.\n\n---\n\n$\\text{upd 2022.7.30}$: A new set of Hack testdata was added.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "于是他错误的点名开始了", "background": "XS 中学化学竞赛组教练是一个酷爱炉石的人。\n\n他会一边搓炉石一边点名以至于有一天他连续点到了某个同学两次，然后正好被路过的校长发现了然后就是一顿欧拉欧拉欧拉（详情请见已结束比赛 CON900）。", "description": "这之后校长任命你为特派探员，每天记录他的点名。校长会提供化学竞赛学生的人数和名单，而你需要告诉校长他有没有点错名。（为什么不直接不让他玩炉石。）", "inputFormat": "第一行一个整数 $n$，表示班上人数。\n\n接下来 $n$ 行，每行一个字符串表示其名字（互不相同，且只含小写字母，长度不超过 $50$）。\n\n第 $n+2$ 行一个整数 $m$，表示教练报的名字个数。\n\n接下来 $m$ 行，每行一个字符串表示教练报的名字（只含小写字母，且长度不超过 $50$）。", "outputFormat": "对于每个教练报的名字，输出一行。\n\n如果该名字正确且是第一次出现，输出 `OK`，如果该名字错误，输出 `WRONG`，如果该名字正确但不是第一次出现，输出 `REPEAT`。", "hint": "- 对于 $40\\%$ 的数据，$n\\le 1000$，$m\\le 2000$。\n- 对于 $70\\%$ 的数据，$n\\le 10^4$，$m\\le 2\\times 10^4$。\n- 对于 $100\\%$ 的数据，$n\\le 10^4$，$m≤10^5$。\n\n---\n\n$\\text{upd 2022.7.30}$：新增加一组 Hack 数据。", "locale": "zh-CN"}}}
{"pid": "P2581", "type": "P", "difficulty": 5, "samples": [["6\nSAB\nSBC\nSAA\nACA\nBCC\nCBC\n3\nABBCAAABCA\nCCC\nBA", "3\n1\nNIE"]], "limits": {"time": [1000], "memory": [128000]}, "tags": ["2005", "各省省选", "浙江"], "title": "[ZJOI2005] Genotype", "background": "Genotype 是一个独特的基因串。", "description": "我们可以用大写英文字母 $A-Z$ 来描述 Genotype，每个字母就代表一个基因。\n\n规定一种「分裂」规则，由三个大写字母 $A_1A_2A_3$ 组成，代表 $A_1$ 可以「分裂」为 $A_2A_3$。\n\n现在给定 $n$ 个「分裂」规则和 $k$ 个 Genotype，判断这些 Genotype 是否能从一个特定的 **只包含大写字母 $S$ 的** 串通过「分裂」规则得到，如果可以的话输出特定的串的长度的最小值，如果不可以的话输出 `NIE`。", "inputFormat": "第一行一个整数 $n$ 代表「分裂」规则数。     \n接下来 $n$ 行每行三个大写字母 $A_1,A_2,A_3$ 代表一个「分裂」规则。         \n接下来一行一个整数 $k$ 代表给定的 Genotype 数。     \n接下来 $k$ 行每行若干个大写字母表示一个 Genotype。", "outputFormat": "$k$ 行：\n\n- 如果没有特定的串通过「分裂」规则得到这个 Genotype，输出 `NIE`。\n- 如果有特定的串通过「分裂」规则得到这个 Genotype，输出这个特定的串的最小长度。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le n,k \\le 2000$，Genotype 的长度最大为 $100$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2005] Genotype", "background": "Genotype is a unique gene string.", "description": "We can use uppercase English letters $A-Z$ to describe a Genotype, where each letter represents a gene.\n\nDefine a \"split\" rule as a triple of uppercase letters $A_1A_2A_3$, meaning $A_1$ can \"split\" into $A_2A_3$.\n\nGiven $n$ \"split\" rules and $k$ Genotypes, determine whether each Genotype can be obtained from a specific string that consists only of the uppercase letter $S$ by applying the \"split\" rules. If it is possible, output the minimal length of that specific string; otherwise, output `NIE`.", "inputFormat": "The first line contains an integer $n$, the number of \"split\" rules.  \nEach of the next $n$ lines contains three uppercase letters $A_1,A_2,A_3$ representing one \"split\" rule.  \nThe next line contains an integer $k$, the number of given Genotypes.  \nEach of the next $k$ lines contains a string of uppercase letters representing a Genotype.", "outputFormat": "$k$ lines:\n- If no such specific string can produce the Genotype via the \"split\" rules, output `NIE`.\n- If there is such a specific string, output the minimal length of that specific string.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, $1 \\le n,k \\le 2000$, and the maximum length of a Genotype is $100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2005] Genotype", "background": "Genotype 是一个独特的基因串。", "description": "我们可以用大写英文字母 $A-Z$ 来描述 Genotype，每个字母就代表一个基因。\n\n规定一种「分裂」规则，由三个大写字母 $A_1A_2A_3$ 组成，代表 $A_1$ 可以「分裂」为 $A_2A_3$。\n\n现在给定 $n$ 个「分裂」规则和 $k$ 个 Genotype，判断这些 Genotype 是否能从一个特定的 **只包含大写字母 $S$ 的** 串通过「分裂」规则得到，如果可以的话输出特定的串的长度的最小值，如果不可以的话输出 `NIE`。", "inputFormat": "第一行一个整数 $n$ 代表「分裂」规则数。     \n接下来 $n$ 行每行三个大写字母 $A_1,A_2,A_3$ 代表一个「分裂」规则。         \n接下来一行一个整数 $k$ 代表给定的 Genotype 数。     \n接下来 $k$ 行每行若干个大写字母表示一个 Genotype。", "outputFormat": "$k$ 行：\n\n- 如果没有特定的串通过「分裂」规则得到这个 Genotype，输出 `NIE`。\n- 如果有特定的串通过「分裂」规则得到这个 Genotype，输出这个特定的串的最小长度。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le n,k \\le 2000$，Genotype 的长度最大为 $100$。", "locale": "zh-CN"}}}
{"pid": "P2582", "type": "P", "difficulty": 5, "samples": [["5\n1 2 3 4 5", "1 1 1 1 1"], ["5\n2 3 4 5 1", "1 2 3 4 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2016", "洛谷原创", "洛谷月赛"], "title": "函数", "background": "Alice 和 Bob 玩游戏。", "description": "Alice 给出一个 $1$~$n$ 的排列表示一个函数 $y=f(x)$，即给出的第 $i$ 个数字即为 $f(i)$。  \n\n现在 Bob 需要给出一个字典序尽可能小的函数 $y=g(x)$，使得对于任意 $i$，$f(g(i))=g(f(i))$。", "inputFormat": "第一行一个整数 $n$。  \n\n第二行 $n$ 个整数，依次表示 $f(1),f(2) \\cdots f(n)$。", "outputFormat": "共一行，$n$ 个整数，依次表示 $g(1),g(2) \\cdots g(n)$。", "hint": "#### 【样例解释】\n#### 样例 1 说明\n- $g(f(1))=f(g(1))=1$。\n- $g(f(2))=f(g(2))=1$。\n- $g(f(3))=f(g(3))=1$。\n- $g(f(4))=f(g(4))=1$。\n- $g(f(5))=f(g(5))=1$。\n\n#### 样例 2 说明\n- $g(f(1))=f(g(1))=2$。\n- $g(f(2))=f(g(2))=3$。\n- $g(f(3))=f(g(3))=4$。\n- $g(f(4))=f(g(4))=5$。\n- $g(f(5))=f(g(5))=1$。\n\n---\n\n#### 【数据规模与约定】\n对于 $30\\%$ 的数据，$n \\le 5$。\n对于 $60\\%$ 的数据，$n \\le 10^3$。\n对于 $100\\%$ 的数据，$1 \\le n \\le 8 \\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Function", "background": "Alice and Bob play a game.", "description": "Alice gives a permutation of $1$ to $n$ representing a function $y=f(x)$, i.e., the $i$-th number given is $f(i)$.\n\nNow Bob needs to give a function $y=g(x)$ that is lexicographically as small as possible, such that for any $i$, $f(g(i))=g(f(i))$.", "inputFormat": "The first line contains an integer $n$.\nThe second line contains $n$ integers, representing $f(1), f(2) \\cdots f(n)$ in order.", "outputFormat": "Output one line containing $n$ integers, representing $g(1), g(2) \\cdots g(n)$ in order.", "hint": "Sample Explanation\nSample 1\n- $g(f(1))=f(g(1))=1$.\n- $g(f(2))=f(g(2))=1$.\n- $g(f(3))=f(g(3))=1$.\n- $g(f(4))=f(g(4))=1$.\n- $g(f(5))=f(g(5))=1$.\n\nSample 2\n- $g(f(1))=f(g(1))=2$.\n- $g(f(2))=f(g(2))=3$.\n- $g(f(3))=f(g(3))=4$.\n- $g(f(4))=f(g(4))=5$.\n- $g(f(5))=f(g(5))=1$.\n\nConstraints\n- For $30\\%$ of the testdata, $n \\le 5$.\n- For $60\\%$ of the testdata, $n \\le 10^3$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 8 \\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "函数", "background": "Alice 和 Bob 玩游戏。", "description": "Alice 给出一个 $1$~$n$ 的排列表示一个函数 $y=f(x)$，即给出的第 $i$ 个数字即为 $f(i)$。  \n\n现在 Bob 需要给出一个字典序尽可能小的函数 $y=g(x)$，使得对于任意 $i$，$f(g(i))=g(f(i))$。", "inputFormat": "第一行一个整数 $n$。  \n\n第二行 $n$ 个整数，依次表示 $f(1),f(2) \\cdots f(n)$。", "outputFormat": "共一行，$n$ 个整数，依次表示 $g(1),g(2) \\cdots g(n)$。", "hint": "#### 【样例解释】\n#### 样例 1 说明\n- $g(f(1))=f(g(1))=1$。\n- $g(f(2))=f(g(2))=1$。\n- $g(f(3))=f(g(3))=1$。\n- $g(f(4))=f(g(4))=1$。\n- $g(f(5))=f(g(5))=1$。\n\n#### 样例 2 说明\n- $g(f(1))=f(g(1))=2$。\n- $g(f(2))=f(g(2))=3$。\n- $g(f(3))=f(g(3))=4$。\n- $g(f(4))=f(g(4))=5$。\n- $g(f(5))=f(g(5))=1$。\n\n---\n\n#### 【数据规模与约定】\n对于 $30\\%$ 的数据，$n \\le 5$。\n对于 $60\\%$ 的数据，$n \\le 10^3$。\n对于 $100\\%$ 的数据，$1 \\le n \\le 8 \\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P2583", "type": "P", "difficulty": 5, "samples": [["4\n55\n5 10 15\n4\n0 5 10 20\n4\n0 5 10 15\n4\n18\n1 2 3\n5\n0 3 6 10 12\n6\n0 3 5 7 12 15\n2\n30\n20\n1\n20\n7\n1 3 5 7 11 13 17\n0\n", "Case Number 1: 5\nCase Number 2: 0\nCase Number 3: impossible\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2003", "枚举", "前缀和", "ICPC", "洛谷月赛", "WF"], "title": "[ICPC 2003 WF] 地铁间谍", "background": null, "description": "特工玛利亚被送到 S 市执行一个特别危险的任务。她需要利用地铁完成他的任务，S 市的地铁只有一条线路运行，所以并不复杂。\n\n玛利亚有一个任务，现在的时间为 $0$，她要从第一个站出发，并在最后一站的间谍碰头。玛利亚知道有一个强大的组织正在追踪她，她知道如果一直呆在一个车站，她会有很大的被抓的风险，躲在运行的列车中是比较安全的。所以，她决定尽可能地呆在运行的列车中，她只能往前或往后坐车。\n\n玛利亚为了能准时且安全的到达最后一个车站与对方碰头，需要知道在在车站最小等待时间总和的计划。你必须写一个程序，得到玛丽亚最短的等待时间。当然，到了终点站之后如果时间还没有到规定的时刻，她可以在车站里等着对方，只不过这个等待的时刻也是要算进去的。\n\n这个城市有 $n$ 个车站，编号是 $1\\sim n$，火车是这么移动的：从第一个车站开到最后一个车站。或者从最后一站发车然后开会来。火车在每特定两站之间行驶的时间是固定的，我们也可以忽略停车的时间，玛利亚的速度极快，所以他可以迅速上下车即使两辆车同时到站。", "inputFormat": "输入文件包含多组数据，每组数据都由 $7$ 行组成。\n\n- 第 $1$ 行一个正整数 $N\\ (2 \\le N \\le 50)$ 表示站的数量。\n- 第 $2$ 行一个正整数 $T\\ (0 \\le T \\le 2000)$ 表示需要的碰头时间。\n- 第 $3$ 行 $1\\sim n-1$ 个正整数 $t_i\\ (0<t_i<70)$ 表示两站之间列车的通过时间。\n- 第 $4$ 行一个整数 $M_1\\ (1 \\le M_1 \\le 50)$ 表示离开第一个车站的火车的数量。\n- 第 $5$ 行 $M_1$ 个正整数 $d_1,d_2,\\cdots,d_n\\ (0 \\le d \\le 250$，$d_i<d_i+1)$ 表示每一列火车离开第一站的时间。\n- 第 $6$ 行一个正整数 $M_2\\ (1 \\le M_2 \\le 50)$ 表示离开第 $N$ 站的火车的数量。\n- 第 $7$ 行 $M_2$ 个正整数：$e_1,e_2\\cdots e_{M_2}\\ (0 \\le e \\le 250$，$e_i<e_i+1)$ 表示每一列火车离开第 $N$ 站的时间。\n\n最后一行有一个整数 $0$。", "outputFormat": "对于每组数据，打印一行 $\\text{\\texttt{Case Number }\\textit{N}\\texttt{:}}$（$N$ 从 $1$ 开始）和一个整数表示总等待的最短时间或者一个单词 $\\verb!impossible!$ 如果玛丽亚不可能做到。\n\n可参考样例输出。", "hint": "### 样例 1 解释\n\n她 $0$ 分钟时上车，在 $3$ 号站下车，立刻坐上（$0$ 分始发）$15$ 分开的车回去，到 $2$ 号车站，立刻坐上（$20$ 分始发）$25$ 开的车到终点，$50$ 分到，还需要等待 $5$ 分钟。", "locale": "zh-CN", "translations": {"en": {"title": "[ICPC 2003 WF] Subway Spy", "background": "# Description\n\nAgent Maria has been sent to city S to carry out a particularly dangerous mission. She must use the subway to complete her task; city S has only one subway line in operation, so it is not complicated.\n\nThe current time is $0$. Maria starts from station $1$ and must meet the spy at the last station exactly at time $T$. She knows a powerful organization is tracking her. If she stays at a station, she faces a high risk of being caught; hiding in a moving train is safer. Therefore, she decides to stay on moving trains as much as possible, and she can ride only along the line in either direction (forward or backward).\n\nTo arrive at the last station on time and safely, Maria needs a plan that minimizes the total time she waits at stations. You must write a program to find Maria’s minimal total waiting time. Of course, if she arrives at the terminal earlier than the required time, she can wait at the station for the contact; this waiting time must also be counted.\n\nThere are $n$ stations, numbered $1 \\sim n$. Trains shuttle along the line: either from station $1$ to station $n$, or from station $n$ back to station $1$. The travel time between any two consecutive stations is fixed, dwell times can be ignored, and Maria is extremely fast, so she can board or alight instantly, even if two trains arrive simultaneously.", "description": "", "inputFormat": "", "outputFormat": "For each dataset, print one line $\\text{\\texttt{Case Number }\\textit{N}\\texttt{:}}$ (where $N$ starts from $1$) followed by an integer denoting the minimal total waiting time, or the word $\\verb!impossible!$ if Maria cannot accomplish the task.\n\nSee the sample output.", "hint": "Explanation for Sample 1:\n\nShe boards at minute $0$, gets off at station $3$, immediately takes the train that left at minute $0$ and departs at minute $15$ to go back, gets to station $2$, immediately takes the train that started at minute $20$ and departs at minute $25$ to the terminal, arrives at minute $50$, and then needs to wait $5$ minutes.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ICPC 2003 WF] 地铁间谍", "background": null, "description": "特工玛利亚被送到 S 市执行一个特别危险的任务。她需要利用地铁完成他的任务，S 市的地铁只有一条线路运行，所以并不复杂。\n\n玛利亚有一个任务，现在的时间为 $0$，她要从第一个站出发，并在最后一站的间谍碰头。玛利亚知道有一个强大的组织正在追踪她，她知道如果一直呆在一个车站，她会有很大的被抓的风险，躲在运行的列车中是比较安全的。所以，她决定尽可能地呆在运行的列车中，她只能往前或往后坐车。\n\n玛利亚为了能准时且安全的到达最后一个车站与对方碰头，需要知道在在车站最小等待时间总和的计划。你必须写一个程序，得到玛丽亚最短的等待时间。当然，到了终点站之后如果时间还没有到规定的时刻，她可以在车站里等着对方，只不过这个等待的时刻也是要算进去的。\n\n这个城市有 $n$ 个车站，编号是 $1\\sim n$，火车是这么移动的：从第一个车站开到最后一个车站。或者从最后一站发车然后开会来。火车在每特定两站之间行驶的时间是固定的，我们也可以忽略停车的时间，玛利亚的速度极快，所以他可以迅速上下车即使两辆车同时到站。", "inputFormat": "输入文件包含多组数据，每组数据都由 $7$ 行组成。\n\n- 第 $1$ 行一个正整数 $N\\ (2 \\le N \\le 50)$ 表示站的数量。\n- 第 $2$ 行一个正整数 $T\\ (0 \\le T \\le 2000)$ 表示需要的碰头时间。\n- 第 $3$ 行 $1\\sim n-1$ 个正整数 $t_i\\ (0<t_i<70)$ 表示两站之间列车的通过时间。\n- 第 $4$ 行一个整数 $M_1\\ (1 \\le M_1 \\le 50)$ 表示离开第一个车站的火车的数量。\n- 第 $5$ 行 $M_1$ 个正整数 $d_1,d_2,\\cdots,d_n\\ (0 \\le d \\le 250$，$d_i<d_i+1)$ 表示每一列火车离开第一站的时间。\n- 第 $6$ 行一个正整数 $M_2\\ (1 \\le M_2 \\le 50)$ 表示离开第 $N$ 站的火车的数量。\n- 第 $7$ 行 $M_2$ 个正整数：$e_1,e_2\\cdots e_{M_2}\\ (0 \\le e \\le 250$，$e_i<e_i+1)$ 表示每一列火车离开第 $N$ 站的时间。\n\n最后一行有一个整数 $0$。", "outputFormat": "对于每组数据，打印一行 $\\text{\\texttt{Case Number }\\textit{N}\\texttt{:}}$（$N$ 从 $1$ 开始）和一个整数表示总等待的最短时间或者一个单词 $\\verb!impossible!$ 如果玛丽亚不可能做到。\n\n可参考样例输出。", "hint": "### 样例 1 解释\n\n她 $0$ 分钟时上车，在 $3$ 号站下车，立刻坐上（$0$ 分始发）$15$ 分开的车回去，到 $2$ 号车站，立刻坐上（$20$ 分始发）$25$ 开的车到终点，$50$ 分到，还需要等待 $5$ 分钟。", "locale": "zh-CN"}}}
{"pid": "P2584", "type": "P", "difficulty": 5, "samples": [["20\n+ADAM 1000000\n+BOB 1000000 \n+TOM 2000000\n+CATHY 10000000\n?TOM \n?1\n+DAM 100000 \n+BOB 1200000\n+ADAM 900000 \n+FRANK 12340000 \n+LEO 9000000\n+KAINE 9000000 \n+GRACE 8000000 \n+WALT 9000000 \n+SANDY 8000000 \n+MICK 9000000 \n+JACK 7320000 \n?2 \n?5  \n?KAINE", "2\nCATHY TOM ADAM BOB\nCATHY LEO KAINE WALT MICK GRACE SANDY JACK TOM BOB\nWALT MICK GRACE SANDY JACK TOM BOB ADAM DAM\n4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "各省省选", "平衡树", "浙江", "O2优化", "哈希 hashing"], "title": "[ZJOI2006] GameZ游戏排名系统", "background": "", "description": "GameZ为他们最新推出的游戏开通了一个网站。世界各地的玩家都可以将自己的游戏得分上传到网站上。这样就可以看到自己在世界上的排名。得分越高，排名就越靠前。当两个玩家的名次相同时，先上传记录者优先。由于新游戏的火爆，网站服务器已经难堪重负。为此GameZ雇用了你来帮他们重新开发一套新的核心。\n\n排名系统通常要应付三种请求：上传一条新的得分记录、查询某个玩家的当前排名以及返回某个区段内的排名记录。当某个玩家上传自己最新的得分记录时，他原有的得分记录会被删除。为了减轻服务器负担，在返回某个区段内的排名记录时，最多返回 $10$ 条记录。\n", "inputFormat": "输入文件的第一行是一个整数 $n$ $( n \\ge 10 )$ 表示请求总数目。接下来n行每行包含了一个请求。请求的具体格式如下：\n\n``+Name Score`` 上传最新得分记录。``Name`` 表示玩家名字，由大写英文字母组成，不超过 $10$ 个字符。``Score`` 为最多 $10$ 位的正整数。\n\n``?Name`` 查询玩家排名。该玩家的得分记录必定已经在前面上传。\n\n``?Index`` 返回自第 ``Index`` 名开始的最多 $10$ 名玩家名字。``Index`` 必定合法，即不小于 $1$，也不大于当前有记录的玩家总数。\n\n\n", "outputFormat": "对于每条查询请求，在文件中输出相应结果。\n\n对于 ``?Name`` 格式的请求，应输出一个整数表示该玩家当前的排名。\n\n对于 ``?Index`` 格式的请求，应在一行中依次输出从第 ``Index`` 名开始的最多 $10$ 名玩家姓名，用一个空格分隔。\n", "hint": "20\n+ADAM 1000000     加入ADAM的得分记录\n\n+BOB 1000000       加入BOB的得分记录\n\n+TOM 2000000       加入TOM的得分记录\n\n+CATHY 10000000    加入CATHY的得分记录\n\n?TOM               输出TOM目前排名\n\n?1                  目前有记录的玩家总数为4，因此应输出第1名到第4名。\n\n+DAM 100000        加入DAM的得分记录\n\n+BOB 1200000       更新BOB的得分记录\n\n+ADAM 900000      更新ADAM的得分记录（即使比原来的差）\n\n+FRANK 12340000   加入FRANK的得分记录\n\n+LEO 9000000       加入LEO的得分记录\n\n+KAINE 9000000     加入KAINE的得分记录\n\n+GRACE 8000000    加入GRACE的得分记录\n\n+WALT 9000000      加入WALT的得分记录\n\n+SANDY 8000000    加入SANDY的得分记录\n\n+MICK 9000000      加入MICK的得分记录\n\n+JACK 7320000      加入JACK的得分记录\n\n?2                  目前有记录的玩家总数为12，因此应输出第2名到第11名。\n\n?5                  输出第5名到第13名。\n\n?KAINE             输出KAINE的排名\n\n输入文件总大小不超过 2M。\n\nNOTE：用 C++ 的 fstream 读大规模数据的效率较低", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2006] GameZ Game Ranking System", "background": "", "description": "GameZ launched a website for their latest game, where players around the world can upload their game scores to see their global rankings. Higher scores rank higher. If two players tie, the one who uploaded earlier ranks higher. Due to the game's popularity, the website servers are under heavy load. GameZ has hired you to redevelop a new core system.\n\nThe ranking system needs to handle three types of requests: upload a new score record, query a player's current rank, and return the ranking records within a certain range. When a player uploads their latest score, their previous record will be removed. To reduce server load, when returning ranking records within a range, return at most $10$ records.", "inputFormat": "The first line contains an integer $n$ ($n \\ge 10$), the total number of requests. Each of the next $n$ lines contains one request, in one of the following formats:\n\n``+Name Score`` Upload the latest score record. ``Name`` is the player's name, consisting of uppercase English letters, with length at most $10$ characters. ``Score`` is a positive integer with at most $10$ digits.\n\n``?Name`` Query the player's rank. This player's score record is guaranteed to have been uploaded before.\n\n``?Index`` Return at most $10$ player names starting from rank ``Index``. ``Index`` is guaranteed to be valid, i.e., it is at least $1$ and at most the current number of players with records.", "outputFormat": "For each query request, output the corresponding result.\n\nFor a ``?Name`` request, output a single integer representing the player's current rank.\n\nFor a ``?Index`` request, output in one line the names of at most $10$ players starting from rank ``Index``, separated by single spaces.", "hint": "20\n+ADAM 1000000     Add ADAM's score record.\n+BOB 1000000      Add BOB's score record.\n+TOM 2000000      Add TOM's score record.\n+CATHY 10000000   Add CATHY's score record.\n?TOM              Output TOM's current rank.\n?1                There are currently 4 players with records, so output ranks 1 to 4.\n+DAM 100000       Add DAM's score record.\n+BOB 1200000      Update BOB's score record.\n+ADAM 900000      Update ADAM's score record (even if it is worse than before).\n+FRANK 12340000   Add FRANK's score record.\n+LEO 9000000      Add LEO's score record.\n+KAINE 9000000    Add KAINE's score record.\n+GRACE 8000000    Add GRACE's score record.\n+WALT 9000000     Add WALT's score record.\n+SANDY 8000000    Add SANDY's score record.\n+MICK 9000000     Add MICK's score record.\n+JACK 7320000     Add JACK's score record.\n?2                There are currently 12 players with records, so output ranks 2 to 11.\n?5                Output ranks 5 to 13.\n?KAINE            Output KAINE's rank.\n\nThe total size of the input file does not exceed 2 MB.\n\nNOTE: Using C++ fstream to read large input is inefficient.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2006] GameZ游戏排名系统", "background": "", "description": "GameZ为他们最新推出的游戏开通了一个网站。世界各地的玩家都可以将自己的游戏得分上传到网站上。这样就可以看到自己在世界上的排名。得分越高，排名就越靠前。当两个玩家的名次相同时，先上传记录者优先。由于新游戏的火爆，网站服务器已经难堪重负。为此GameZ雇用了你来帮他们重新开发一套新的核心。\n\n排名系统通常要应付三种请求：上传一条新的得分记录、查询某个玩家的当前排名以及返回某个区段内的排名记录。当某个玩家上传自己最新的得分记录时，他原有的得分记录会被删除。为了减轻服务器负担，在返回某个区段内的排名记录时，最多返回 $10$ 条记录。\n", "inputFormat": "输入文件的第一行是一个整数 $n$ $( n \\ge 10 )$ 表示请求总数目。接下来n行每行包含了一个请求。请求的具体格式如下：\n\n``+Name Score`` 上传最新得分记录。``Name`` 表示玩家名字，由大写英文字母组成，不超过 $10$ 个字符。``Score`` 为最多 $10$ 位的正整数。\n\n``?Name`` 查询玩家排名。该玩家的得分记录必定已经在前面上传。\n\n``?Index`` 返回自第 ``Index`` 名开始的最多 $10$ 名玩家名字。``Index`` 必定合法，即不小于 $1$，也不大于当前有记录的玩家总数。\n\n\n", "outputFormat": "对于每条查询请求，在文件中输出相应结果。\n\n对于 ``?Name`` 格式的请求，应输出一个整数表示该玩家当前的排名。\n\n对于 ``?Index`` 格式的请求，应在一行中依次输出从第 ``Index`` 名开始的最多 $10$ 名玩家姓名，用一个空格分隔。\n", "hint": "20\n+ADAM 1000000     加入ADAM的得分记录\n\n+BOB 1000000       加入BOB的得分记录\n\n+TOM 2000000       加入TOM的得分记录\n\n+CATHY 10000000    加入CATHY的得分记录\n\n?TOM               输出TOM目前排名\n\n?1                  目前有记录的玩家总数为4，因此应输出第1名到第4名。\n\n+DAM 100000        加入DAM的得分记录\n\n+BOB 1200000       更新BOB的得分记录\n\n+ADAM 900000      更新ADAM的得分记录（即使比原来的差）\n\n+FRANK 12340000   加入FRANK的得分记录\n\n+LEO 9000000       加入LEO的得分记录\n\n+KAINE 9000000     加入KAINE的得分记录\n\n+GRACE 8000000    加入GRACE的得分记录\n\n+WALT 9000000      加入WALT的得分记录\n\n+SANDY 8000000    加入SANDY的得分记录\n\n+MICK 9000000      加入MICK的得分记录\n\n+JACK 7320000      加入JACK的得分记录\n\n?2                  目前有记录的玩家总数为12，因此应输出第2名到第11名。\n\n?5                  输出第5名到第13名。\n\n?KAINE             输出KAINE的排名\n\n输入文件总大小不超过 2M。\n\nNOTE：用 C++ 的 fstream 读大规模数据的效率较低", "locale": "zh-CN"}}}
{"pid": "P2585", "type": "P", "difficulty": 4, "samples": [["1122002010", "5 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "搜索", "2006", "各省省选", "浙江", "深度优先搜索 DFS", "树形 DP"], "title": "[ZJOI2006] 三色二叉树", "background": null, "description": "一棵二叉树可以按照如下规则表示成一个由 $0$、$1$、$2$ 组成的字符序列，我们称之为“二叉树序列 $S$”：\n\n$$S=\n\\begin{cases}\n0& \\text表示该树没有子节点\\\\\n1S_1& 表示该树有一个节点，S_1 为其子树的二叉树序列\\\\\n2S_1S_2& 表示该树有两个子节点，S_1 和 S_2 分别表示其两个子树的二叉树序列\n\\end{cases}$$\n\n例如，下图所表示的二叉树可以用二叉树序列 $S=\\texttt{21200110}$ 来表示。\n\n![haha.png](https://i.loli.net/2020/04/27/Ijw8ZEWCKH2rtJG.png)\n\n你的任务是要对一棵二叉树的节点进行染色。每个节点可以被染成红色、绿色或蓝色。并且，一个节点与其子节点的颜色必须不同，如果该节点有两个子节点，那么这两个子节点的颜色也必须不同。给定一颗二叉树的二叉树序列，请求出这棵树中**最多和最少**有多少个点能够被染成绿色。", "inputFormat": "输入只有一行一个字符串 $s$，表示二叉树序列。", "outputFormat": "输出只有一行，包含两个数，依次表示最多和最少有多少个点能够被染成绿色。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq |s| \\leq 5 \\times 10^5$，$s$ 中只含字符 `0` `1` `2`。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2006] Three-Color Binary Tree", "background": "", "description": "A binary tree can be represented as a character sequence consisting of $0$, $1$, and $2$ according to the following rules, which we call the \"binary tree sequence $S$\":\n\n$$\nS=\n\\begin{cases}\n0 & \\text{indicates that this node has no child} \\\\\n1S_1 & \\text{indicates that this node has one child, and } S_1 \\text{ is the binary tree sequence of its subtree} \\\\\n2S_1S_2 & \\text{indicates that this node has two children, where } S_1 \\text{ and } S_2 \\text{ are the binary tree sequences of its two subtrees}\n\\end{cases}\n$$\n\nFor example, the binary tree shown in the figure below can be represented by the binary tree sequence $S=\\texttt{21200110}$.\n\n![haha.png](https://i.loli.net/2020/04/27/Ijw8ZEWCKH2rtJG.png)\n\nYour task is to color the nodes of a binary tree. Each node can be colored red, green, or blue. A node must have a different color from each of its children, and if it has two children, then the two children must also have different colors. Given the binary tree sequence of a tree, determine the maximum and minimum number of nodes that can be colored green.", "inputFormat": "The input contains a single line with a string $s$, which represents the binary tree sequence.", "outputFormat": "Output a single line with two numbers, indicating the maximum and then the minimum number of nodes that can be colored green.", "hint": "Constraints\n\nFor all test points, it is guaranteed that $1 \\le |s| \\le 5 \\times 10^5$, and $s$ contains only the characters `0` `1` `2`.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2006] 三色二叉树", "background": null, "description": "一棵二叉树可以按照如下规则表示成一个由 $0$、$1$、$2$ 组成的字符序列，我们称之为“二叉树序列 $S$”：\n\n$$S=\n\\begin{cases}\n0& \\text表示该树没有子节点\\\\\n1S_1& 表示该树有一个节点，S_1 为其子树的二叉树序列\\\\\n2S_1S_2& 表示该树有两个子节点，S_1 和 S_2 分别表示其两个子树的二叉树序列\n\\end{cases}$$\n\n例如，下图所表示的二叉树可以用二叉树序列 $S=\\texttt{21200110}$ 来表示。\n\n![haha.png](https://i.loli.net/2020/04/27/Ijw8ZEWCKH2rtJG.png)\n\n你的任务是要对一棵二叉树的节点进行染色。每个节点可以被染成红色、绿色或蓝色。并且，一个节点与其子节点的颜色必须不同，如果该节点有两个子节点，那么这两个子节点的颜色也必须不同。给定一颗二叉树的二叉树序列，请求出这棵树中**最多和最少**有多少个点能够被染成绿色。", "inputFormat": "输入只有一行一个字符串 $s$，表示二叉树序列。", "outputFormat": "输出只有一行，包含两个数，依次表示最多和最少有多少个点能够被染成绿色。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq |s| \\leq 5 \\times 10^5$，$s$ 中只含字符 `0` `1` `2`。", "locale": "zh-CN"}}}
{"pid": "P2586", "type": "P", "difficulty": 6, "samples": [["3 5\n1 1 2\n2 2\n5\n", "The game is going on\n5\n5 1 3 1 4\n4 1 3 0 4\n3 1 3 0 3\n2 1 3 0 2\n1 1 4 0 1\n"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2008", "各省省选", "浙江"], "title": "[ZJOI2008] 杀蚂蚁", "background": "", "description": "最近，佳佳迷上了一款好玩的小游戏：antbuster。\n\n游戏规则非常简单：在一张地图上，左上角是蚂蚁窝，右下角是蛋糕，蚂蚁会源源不断地从窝里爬出来，试图把蛋糕搬回蚂蚁窝。而你的任务，就是用原始资金以及杀蚂蚁获得的奖金造防御塔，杀掉这些试图跟你抢蛋糕的蚂蚁~\n\n为了拿到尽可能高的分数，佳佳设计了很多种造塔的方案，但在尝试了其中的一小部分后，佳佳发现，这个游戏实在是太费时间了。为了节省时间，佳佳决定写个程序，对于每一种方案，模拟游戏进程，根据效果来判断方案的优劣。\n\n根据自己在游戏中积累的一些经验，以及上网搜到的一些参数，佳佳猜了蚂蚁爬行的算法，并且假设游戏中的蚂蚁也是按这个规则选择路线：\n\n1. 每一秒钟开始的时候，蚂蚁都在平面中的某个整点上。如果蚂蚁没有扛着蛋糕，它会在该点留下 $2$ 单位的信息素，否则它会留下 $5$ 单位的信息素。然后蚂蚁会在正北、正南、正东、正西四个方向中选择一个爬过去。\n\n2. 选择方向的规则是：首先，爬完一个单位长度后到达的那个点上，不能有其他蚂蚁或是防御塔，并且那个点不能是蚂蚁上一秒所在的点（除非上一个时刻蚂蚁就被卡住，且这个时刻它仍无法动），当然，蚂蚁也不会爬出地图的边界（我们定义这些点为不可达点）。如果此时有多个选择，蚂蚁会选择信息素最多的那个点爬过去。\n\n3. 如果此时仍有多种选择，蚂蚁先面向正东，如果正东不是可选择的某个方向，它会顺时针转 $90^\\degree$，再次判断，如果还不是，再顺时针旋转 $90^\\degree$，直到找到可以去的方向。\n\n4. 如果将每只蚂蚁在洞口出现的时间作为它的活动时间的第 $1$ 秒，那么每当这只蚂蚁的活动时间秒数为 $5$ 的倍数的时候，它先按规则 $1\\sim 3$ 确定一个方向，面对该方向后逆时针转 $90^\\degree$，若它沿当前方向会走到一个不可达点，它会不停地每次逆时针转 $90^\\degree$，直到它面对着一个可达的点，这样定下的方向才是蚂蚁最终要爬去的方向。\n\n5. 如果蚂蚁的四周都是不可达点，那么蚂蚁在这一秒内会选择停留在当前点。下一秒判断移动方向时，它上一秒所在点为其当前停留的点。\n\n6. 你可以认为蚂蚁在选定方向后，瞬间移动到它的目标点，这一秒钟剩下的时间里，它就停留在目标点。\n\n7. 蚂蚁按出生的顺序移动，出生得比较早的蚂蚁先移动。\n\n然后，是一些有关地图的信息：\n\n1. 每一秒，地图所有点上的信息素会损失 $1$ 单位，如果那个点上有信息素的话。\n\n2. 地图上某些地方是炮台。炮台的坐标在输入中给出。\n\n3. 地图的长、宽在输入中给出，对于 $n\\times m$ 的地图，它的左上角坐标为 $(0,0)$，右下角坐标为 $(n,m)$。蚂蚁洞的位置为 $(0,0)$，蛋糕的位置为 $(n,m)$。\n\n4. 你可以把蚂蚁看做一个直径为 $1$ 单位的圆，圆心位于蚂蚁所在的整点。\n\n5. 游戏开始时，地图上没有蚂蚁，每个点上的信息素含量均为 $0$。\n\n一些有关炮塔的信息：\n\n1. 炮塔被放置在地图上的整点处。\n\n2. 为了简单一些，我们认为这些炮塔都是激光塔。激光塔的射速是 $1$ 秒每次，它的攻击伤害为 $d$ 单位每次，攻击范围为 $r$。你可以认为每秒蚂蚁移动完毕后，塔才开始攻击。并且，只有当代表蚂蚁的圆的圆心与塔的直线距离不超过 $r$ 时，塔才算打得到那只蚂蚁。\n\n3. 如果一只蚂蚁扛着蛋糕，那么它会成为 target，也就是说，任何打得到它的塔的炮口都会对准它。如果蛋糕好好地呆在原位，那么每个塔都会挑离它最近的蚂蚁进行攻击，如果有多只蚂蚁，它会选出生较早的一只。如果有蚂蚁扛着蛋糕，但是不在某个塔的攻击范围内，这个塔会选择最近的蚂蚁进行攻击。\n\n4. 激光塔有个比较奇怪的特性：它在选定了打击目标后，只要目标在其射程内，塔到目标蚂蚁圆心的连线上的所有蚂蚁（这里“被打到”的判定变成了表示激光的线段与表示蚂蚁的圆有公共点）都会被打到并损 $d$ 格血，但激光不会穿透它的打击目标打到后面的蚂蚁。\n\n5. 尽管在真实游戏中，塔是可以升级的，但在这里我们认为塔的布局和等级就此定了下来，不再变动。\n\n再介绍一下蚂蚁窝：\n\n1. 如果地图上的蚂蚁不足 $6$ 只，并且洞口（即点 $(0,0)$）没有蚂蚁，那么窝中每秒会爬出一只蚂蚁，直到地图上的蚂蚁数为 $6$ 只。\n\n2. 刚出生的蚂蚁站在洞口。\n\n3. 每只蚂蚁有一个级别，级别决定了蚂蚁的血量，级别为 $k$ 的蚂蚁的血量为 $\\lfloor 4\\times 1.1^k\\rfloor$（$\\lfloor x\\rfloor$ 表示对 $x$ 下取整）。每被塔打一次，蚂蚁的血减少 $d$。注意，血量为 $0$ 的蚂蚁仍能精力充沛地四处乱爬，只有一只蚂蚁的血被打成负数时，它才算挂了。\n\n4. 蚂蚁的级别是这样算的：前 $6$ 只出生的蚂蚁是 $1$ 级，第 $7\\sim 12$ 只是 $2$级，依此类推第 $6k+1\\sim 6k+6$ 的等级是 $k+1(k\\in \\Bbb{N})$。\n\n最后给出关于蛋糕的介绍：\n\n1. 简单起见，你可以认为此时只剩最后一块蛋糕了。如果有蚂蚁走到蛋糕的位置，并且此时蛋糕没有被扛走，那么这只蚂蚁就扛上了蛋糕。蚂蚁被打死后蛋糕回到点 $(n,m)$。\n\n2. 如果一只扛着蛋糕的蚂蚁走到蚂蚁窝的位置，我们就认为蚂蚁成功抢到了蛋糕，游戏结束。这个回合不会对蚂蚁的年龄产生贡献。\n\n3. 蚂蚁扛上蛋糕时，血量会增加 $\\left\\lfloor\\dfrac{x}{2}\\right\\rfloor$（$x$ 表示蚂蚁出生时的血量），但不会超过蚂蚁的血量上限。\n\n整理一下 $1$ 秒钟内发生的事件：\n\n1. $1$ 秒的最初，如果地图上蚂蚁数不足 $6$，一只蚂蚁就会在洞口出生。\n\n2. 接着，蚂蚁们在自己所在点留下一些信息素后，考虑移动。先出生的蚂蚁先移动。\n\n3. 移动完毕后，如果有蚂蚁在蛋糕的位置上并且蛋糕没被拿走，它把蛋糕扛上，血量增加，并在这时被所有塔设成 target。\n\n4. 然后所有塔同时开始攻击。如果攻击结束后那只扛着蛋糕的蚂蚁挂了，蛋糕瞬间归位。扛着蛋糕的蚂蚁死后，蛋糕会在下一秒钟所有蚂蚁移动完之后再出现。下一秒钟出现在 $(n,m)$ 的蚂蚁才会获得蛋糕。\n\n5. 攻击结束后，如果发现扛蛋糕的蚂蚁没死并在窝的位置，就认为蚂蚁抢到了蛋糕，游戏也在此时结束。\n\n6. 最后，地图上所有点的信息素损失 $1$ 单位。所有蚂蚁的年龄加 $1$。漫长的 $1$ 秒到此结束。", "inputFormat": "输入的第一行是两个用空格隔开的正整数，$n,m$，分别表示了地图的长和宽。\n\n第二行是三个用空格隔开的整数，$s,d,r$，依次表示炮塔的个数、单次攻击伤害以及攻击范围。\n\n接下来 $s$ 行，每行两个用空格隔开的整数 $x,y$，描述了一个炮塔的位置。当然，蚂蚁窝的洞口以及蛋糕所在的位置上一定没有炮塔。\n\n最后一行是一个正整数 $t$，表示我们模拟游戏的前 $t$ 秒钟。", "outputFormat": "如果在第 $t$ 秒或之前蚂蚁抢到了蛋糕，输出一行 `Game over after x seconds`，其中 $x$ 为游戏结束的时间，否则输出 `The game is going on`。\n\n如果游戏在 $t$ 秒或之前结束，输出游戏结束时所有蚂蚁的信息，否则输出 $t$ 秒后所有蚂蚁的信息。格式如下：\n\n第一行是一个整数 $s$，表示此时活着的蚂蚁的总数。\n\n接下来 $s$ 行，每行五个整数，依次表示一只蚂蚁的年龄（单位为秒）、等级、当前血量，以及在地图上的位置 $(a,b)$。输出按蚂蚁的年龄递减排序。", "hint": "### 样例说明：\n\n$3\\times 5$ 的地图，有一个单次伤害为 $1$、攻击范围为 $2$ 的激光炮塔，它的位置为 $(2,2)$，模拟游戏的前 $5$ 秒。\n\n$5$ 秒内有 $5$ 只蚂蚁出生，都是向东爬行，其中第 $1\\sim 4$ 只在路过 $(0,2)$ 点时被激光塔射伤了 $1$ 格血。在第 $5$ 秒的时候，最早出生的蚂蚁按移动规则 $1\\sim 3$ 本来该向东移动，但由于规则 $4$ 的作用，它在发现向北和向西移动都会到达不可达点后，最终选择了向南移动。\n\n### 数据范围说明：\n\n对于 $100\\%$ 的数据，满足 $1\\leqslant n,m\\leqslant 8,s\\leqslant 20,t\\leqslant 2\\times 10^5,0\\leqslant d\\leqslant 10^4,0\\leqslant r\\leqslant 15$。（这里的 $s$ 指的是炮塔的总数）。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2008] Kill Ants", "background": "", "description": "Recently, Jiajia got hooked on a fun mini-game: antbuster.\n\nThe rules are simple: on a map, the top-left corner is the ant nest, and the bottom-right corner is the cake. Ants continuously crawl out of the nest, trying to carry the cake back to the nest. Your task is to use the initial funds and the bounty from killing ants to build defense towers to kill those ants that try to grab your cake.\n\nTo get the highest possible score, Jiajia designed many tower layouts. But after trying only a small fraction of them, Jiajia found the game too time-consuming. To save time, Jiajia decided to write a program to simulate each plan and evaluate it based on the results.\n\nBased on experience in the game and some parameters found online, Jiajia guessed the ants’ crawling algorithm and assumes the ants in the game choose their routes according to the following rules:\n\n1. At the start of each second, every ant is on some grid point in the plane. If an ant is not carrying the cake, it leaves $2$ units of pheromone at that point; otherwise, it leaves $5$ units. Then it chooses one direction among north, south, east, and west to crawl to.\n\n2. The direction selection rule is: first, the destination point reached after moving one unit must not be occupied by another ant or a tower, and that point cannot be the ant’s position from the previous second (unless the ant was stuck in the previous tick and still cannot move now). Of course, ants will not crawl outside the map (we define such points as unreachable). If there are multiple choices, the ant will choose the point with the highest pheromone.\n\n3. If there is still a tie, the ant first faces due east. If east is not among the selectable directions, it turns $90^\\degree$ clockwise and checks again; if still not, it continues turning $90^\\degree$ clockwise until it finds a valid direction.\n\n4. If we regard the time when each ant appears at the nest entrance as the first second of its life, then whenever the ant’s age in seconds is a multiple of $5$, it first determines a direction according to rules 1–3, then turns $90^\\degree$ counterclockwise from that facing. If moving along the current direction leads to an unreachable point, it keeps turning $90^\\degree$ counterclockwise each time until it faces a reachable point. The direction determined in this way is the final direction the ant will crawl.\n\n5. If all four neighboring points are unreachable, the ant will choose to stay at its current point for this second. When determining the movement direction next second, its previous position is its current resting point.\n\n6. You may assume that after choosing a direction, the ant instantly moves to its target point and then remains at the target point for the rest of the second.\n\n7. Ants move in their birth order. Earlier-born ants move first.\n\nNext, some information about the map:\n\n1. Each second, the pheromone value on every map point decreases by $1$ unit if it is positive.\n\n2. Some places on the map are towers. Tower coordinates are given in the input.\n\n3. The map’s length and width are given in the input. For an $n \\times m$ map, the top-left corner is $(0,0)$ and the bottom-right corner is $(n,m)$. The ant nest is at $(0,0)$ and the cake is at $(n,m)$.\n\n4. You can consider an ant as a circle of diameter $1$, with its center located at the grid point where the ant is.\n\n5. At the beginning of the game, there are no ants on the map, and the pheromone value at every point is $0$.\n\nSome information about towers:\n\n1. Towers are placed at grid points on the map.\n\n2. For simplicity, we assume all towers are laser towers. A laser tower fires once per second, deals $d$ damage per shot, and has attack range $r$. You may assume that towers only begin attacking after all ants have finished moving in that second. Moreover, a tower can hit an ant only if the distance from the tower to the center of the ant’s circle does not exceed $r$.\n\n3. If an ant is carrying the cake, it becomes the target. That is, any tower that can reach it will aim at it. If the cake remains at its original position, each tower will choose the nearest ant to attack; if there is a tie, it picks the earlier-born one. If there is a cake-carrying ant but it is outside a certain tower’s range, that tower chooses the nearest ant to attack.\n\n4. Laser towers have a peculiar property: once a target is selected, as long as the target is within range, all ants whose circles intersect the line segment from the tower to the target ant’s center (here, being “hit” is determined by whether the laser segment and the ant’s circle have an intersection) will be hit and lose $d$ HP. However, the laser will not penetrate through its target to hit ants behind it.\n\n5. Although towers can be upgraded in the actual game, here we assume the tower layout and levels are fixed and will not change.\n\nNow about the ant nest:\n\n1. If there are fewer than $6$ ants on the map and the nest entrance (i.e., point $(0,0)$) is unoccupied, one ant will crawl out each second until there are $6$ ants on the map.\n\n2. A newly born ant stands at the nest entrance.\n\n3. Each ant has a level, which determines its HP. An ant of level $k$ has HP $\\lfloor 4 \\times 1.1^k \\rfloor$ (where $\\lfloor x \\rfloor$ denotes the floor of $x$). Each time it is hit by a tower, its HP decreases by $d$. Note that an ant with HP equal to $0$ can still move around vigorously; only when an ant’s HP becomes negative is it considered dead.\n\n4. Ant levels are assigned as follows: the first $6$ ants are level $1$, ants $7 \\sim 12$ are level $2$, and so on. Ants numbered $6k+1 \\sim 6k+6$ have level $k+1$ ($k \\in \\Bbb{N}$).\n\nFinally, an introduction to the cake:\n\n1. For simplicity, assume there is only the last piece of cake left. If an ant reaches the cake’s position while the cake is not being carried, that ant picks up the cake. When an ant is killed, the cake returns to $(n,m)$.\n\n2. If an ant carrying the cake reaches the nest location, we consider the ant to have successfully stolen the cake, and the game ends. This tick does not contribute to the ant’s age.\n\n3. When an ant picks up the cake, its HP increases by $\\left\\lfloor \\dfrac{x}{2} \\right\\rfloor$ (where $x$ is the ant’s HP at birth), but does not exceed its maximum HP.\n\nTo sum up, what happens within one second:\n\n1. At the very beginning of the second, if there are fewer than $6$ ants on the map, one ant is born at the nest entrance.\n\n2. Then ants leave pheromones at their current points and decide their moves. Earlier-born ants move first.\n\n3. After movement, if an ant is at the cake’s position and the cake has not been taken, it picks up the cake, gains HP, and is set as the target by all towers at this moment.\n\n4. Then all towers attack simultaneously. If the ant carrying the cake dies after the attack, the cake instantly returns to its place. After the cake-carrying ant dies, the cake will reappear only after all ants have finished moving in the next second. Only ants that appear at $(n,m)$ in the next second can pick up the cake.\n\n5. After the attack, if the cake-carrying ant is alive and at the nest’s position, we consider the cake stolen and the game ends at this moment.\n\n6. Finally, the pheromone value on every map point decreases by $1$ unit. All ants’ ages increase by $1$. The long second ends here.", "inputFormat": "The first line contains two positive integers $n, m$, the map’s length and width, separated by a space.\n\nThe second line contains three integers $s, d, r$, denoting the number of towers, the damage per attack, and the attack range, respectively.\n\nThe next $s$ lines each contain two integers $x, y$, describing the position of a tower. Of course, there are no towers at the nest entrance or at the cake’s position.\n\nThe last line contains a positive integer $t$, indicating that we simulate the first $t$ seconds of the game.", "outputFormat": "If the cake is stolen by second $t$ or earlier, output a line `Game over after x seconds`, where $x$ is the time when the game ends; otherwise, output `The game is going on`.\n\nIf the game ends by second $t$ or earlier, output the information of all ants at the end of the game; otherwise, output the information of all ants after $t$ seconds. The format is as follows:\n\nThe first line is an integer $s$, the total number of ants alive at that time.\n\nThe next $s$ lines each contain five integers, representing an ant’s age (in seconds), level, current HP, and its position $(a,b)$ on the map, in that order. Output should be sorted by age in descending order.", "hint": "Sample explanation:\n\nOn a $3 \\times 5$ map, there is one laser tower with damage $1$ and attack range $2$, located at $(2,2)$. Simulate the first $5$ seconds of the game.\n\nWithin $5$ seconds, $5$ ants are born. They all crawl east. Among them, ants $1 \\sim 4$ are each hit for $1$ HP when passing through $(0,2)$ by the laser tower. In the $5$-th second, the earliest-born ant would have moved east according to movement rules 1–3, but due to rule 4, after finding that moving north or west would lead to unreachable points, it finally chooses to move south.\n\nConstraints:\n\nFor $100\\%$ of the testdata, $1 \\leqslant n,m \\leqslant 8$, $s \\leqslant 20$, $t \\leqslant 2 \\times 10^5$, $0 \\leqslant d \\leqslant 10^4$, $0 \\leqslant r \\leqslant 15$. (Here $s$ denotes the total number of towers.)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2008] 杀蚂蚁", "background": "", "description": "最近，佳佳迷上了一款好玩的小游戏：antbuster。\n\n游戏规则非常简单：在一张地图上，左上角是蚂蚁窝，右下角是蛋糕，蚂蚁会源源不断地从窝里爬出来，试图把蛋糕搬回蚂蚁窝。而你的任务，就是用原始资金以及杀蚂蚁获得的奖金造防御塔，杀掉这些试图跟你抢蛋糕的蚂蚁~\n\n为了拿到尽可能高的分数，佳佳设计了很多种造塔的方案，但在尝试了其中的一小部分后，佳佳发现，这个游戏实在是太费时间了。为了节省时间，佳佳决定写个程序，对于每一种方案，模拟游戏进程，根据效果来判断方案的优劣。\n\n根据自己在游戏中积累的一些经验，以及上网搜到的一些参数，佳佳猜了蚂蚁爬行的算法，并且假设游戏中的蚂蚁也是按这个规则选择路线：\n\n1. 每一秒钟开始的时候，蚂蚁都在平面中的某个整点上。如果蚂蚁没有扛着蛋糕，它会在该点留下 $2$ 单位的信息素，否则它会留下 $5$ 单位的信息素。然后蚂蚁会在正北、正南、正东、正西四个方向中选择一个爬过去。\n\n2. 选择方向的规则是：首先，爬完一个单位长度后到达的那个点上，不能有其他蚂蚁或是防御塔，并且那个点不能是蚂蚁上一秒所在的点（除非上一个时刻蚂蚁就被卡住，且这个时刻它仍无法动），当然，蚂蚁也不会爬出地图的边界（我们定义这些点为不可达点）。如果此时有多个选择，蚂蚁会选择信息素最多的那个点爬过去。\n\n3. 如果此时仍有多种选择，蚂蚁先面向正东，如果正东不是可选择的某个方向，它会顺时针转 $90^\\degree$，再次判断，如果还不是，再顺时针旋转 $90^\\degree$，直到找到可以去的方向。\n\n4. 如果将每只蚂蚁在洞口出现的时间作为它的活动时间的第 $1$ 秒，那么每当这只蚂蚁的活动时间秒数为 $5$ 的倍数的时候，它先按规则 $1\\sim 3$ 确定一个方向，面对该方向后逆时针转 $90^\\degree$，若它沿当前方向会走到一个不可达点，它会不停地每次逆时针转 $90^\\degree$，直到它面对着一个可达的点，这样定下的方向才是蚂蚁最终要爬去的方向。\n\n5. 如果蚂蚁的四周都是不可达点，那么蚂蚁在这一秒内会选择停留在当前点。下一秒判断移动方向时，它上一秒所在点为其当前停留的点。\n\n6. 你可以认为蚂蚁在选定方向后，瞬间移动到它的目标点，这一秒钟剩下的时间里，它就停留在目标点。\n\n7. 蚂蚁按出生的顺序移动，出生得比较早的蚂蚁先移动。\n\n然后，是一些有关地图的信息：\n\n1. 每一秒，地图所有点上的信息素会损失 $1$ 单位，如果那个点上有信息素的话。\n\n2. 地图上某些地方是炮台。炮台的坐标在输入中给出。\n\n3. 地图的长、宽在输入中给出，对于 $n\\times m$ 的地图，它的左上角坐标为 $(0,0)$，右下角坐标为 $(n,m)$。蚂蚁洞的位置为 $(0,0)$，蛋糕的位置为 $(n,m)$。\n\n4. 你可以把蚂蚁看做一个直径为 $1$ 单位的圆，圆心位于蚂蚁所在的整点。\n\n5. 游戏开始时，地图上没有蚂蚁，每个点上的信息素含量均为 $0$。\n\n一些有关炮塔的信息：\n\n1. 炮塔被放置在地图上的整点处。\n\n2. 为了简单一些，我们认为这些炮塔都是激光塔。激光塔的射速是 $1$ 秒每次，它的攻击伤害为 $d$ 单位每次，攻击范围为 $r$。你可以认为每秒蚂蚁移动完毕后，塔才开始攻击。并且，只有当代表蚂蚁的圆的圆心与塔的直线距离不超过 $r$ 时，塔才算打得到那只蚂蚁。\n\n3. 如果一只蚂蚁扛着蛋糕，那么它会成为 target，也就是说，任何打得到它的塔的炮口都会对准它。如果蛋糕好好地呆在原位，那么每个塔都会挑离它最近的蚂蚁进行攻击，如果有多只蚂蚁，它会选出生较早的一只。如果有蚂蚁扛着蛋糕，但是不在某个塔的攻击范围内，这个塔会选择最近的蚂蚁进行攻击。\n\n4. 激光塔有个比较奇怪的特性：它在选定了打击目标后，只要目标在其射程内，塔到目标蚂蚁圆心的连线上的所有蚂蚁（这里“被打到”的判定变成了表示激光的线段与表示蚂蚁的圆有公共点）都会被打到并损 $d$ 格血，但激光不会穿透它的打击目标打到后面的蚂蚁。\n\n5. 尽管在真实游戏中，塔是可以升级的，但在这里我们认为塔的布局和等级就此定了下来，不再变动。\n\n再介绍一下蚂蚁窝：\n\n1. 如果地图上的蚂蚁不足 $6$ 只，并且洞口（即点 $(0,0)$）没有蚂蚁，那么窝中每秒会爬出一只蚂蚁，直到地图上的蚂蚁数为 $6$ 只。\n\n2. 刚出生的蚂蚁站在洞口。\n\n3. 每只蚂蚁有一个级别，级别决定了蚂蚁的血量，级别为 $k$ 的蚂蚁的血量为 $\\lfloor 4\\times 1.1^k\\rfloor$（$\\lfloor x\\rfloor$ 表示对 $x$ 下取整）。每被塔打一次，蚂蚁的血减少 $d$。注意，血量为 $0$ 的蚂蚁仍能精力充沛地四处乱爬，只有一只蚂蚁的血被打成负数时，它才算挂了。\n\n4. 蚂蚁的级别是这样算的：前 $6$ 只出生的蚂蚁是 $1$ 级，第 $7\\sim 12$ 只是 $2$级，依此类推第 $6k+1\\sim 6k+6$ 的等级是 $k+1(k\\in \\Bbb{N})$。\n\n最后给出关于蛋糕的介绍：\n\n1. 简单起见，你可以认为此时只剩最后一块蛋糕了。如果有蚂蚁走到蛋糕的位置，并且此时蛋糕没有被扛走，那么这只蚂蚁就扛上了蛋糕。蚂蚁被打死后蛋糕回到点 $(n,m)$。\n\n2. 如果一只扛着蛋糕的蚂蚁走到蚂蚁窝的位置，我们就认为蚂蚁成功抢到了蛋糕，游戏结束。这个回合不会对蚂蚁的年龄产生贡献。\n\n3. 蚂蚁扛上蛋糕时，血量会增加 $\\left\\lfloor\\dfrac{x}{2}\\right\\rfloor$（$x$ 表示蚂蚁出生时的血量），但不会超过蚂蚁的血量上限。\n\n整理一下 $1$ 秒钟内发生的事件：\n\n1. $1$ 秒的最初，如果地图上蚂蚁数不足 $6$，一只蚂蚁就会在洞口出生。\n\n2. 接着，蚂蚁们在自己所在点留下一些信息素后，考虑移动。先出生的蚂蚁先移动。\n\n3. 移动完毕后，如果有蚂蚁在蛋糕的位置上并且蛋糕没被拿走，它把蛋糕扛上，血量增加，并在这时被所有塔设成 target。\n\n4. 然后所有塔同时开始攻击。如果攻击结束后那只扛着蛋糕的蚂蚁挂了，蛋糕瞬间归位。扛着蛋糕的蚂蚁死后，蛋糕会在下一秒钟所有蚂蚁移动完之后再出现。下一秒钟出现在 $(n,m)$ 的蚂蚁才会获得蛋糕。\n\n5. 攻击结束后，如果发现扛蛋糕的蚂蚁没死并在窝的位置，就认为蚂蚁抢到了蛋糕，游戏也在此时结束。\n\n6. 最后，地图上所有点的信息素损失 $1$ 单位。所有蚂蚁的年龄加 $1$。漫长的 $1$ 秒到此结束。", "inputFormat": "输入的第一行是两个用空格隔开的正整数，$n,m$，分别表示了地图的长和宽。\n\n第二行是三个用空格隔开的整数，$s,d,r$，依次表示炮塔的个数、单次攻击伤害以及攻击范围。\n\n接下来 $s$ 行，每行两个用空格隔开的整数 $x,y$，描述了一个炮塔的位置。当然，蚂蚁窝的洞口以及蛋糕所在的位置上一定没有炮塔。\n\n最后一行是一个正整数 $t$，表示我们模拟游戏的前 $t$ 秒钟。", "outputFormat": "如果在第 $t$ 秒或之前蚂蚁抢到了蛋糕，输出一行 `Game over after x seconds`，其中 $x$ 为游戏结束的时间，否则输出 `The game is going on`。\n\n如果游戏在 $t$ 秒或之前结束，输出游戏结束时所有蚂蚁的信息，否则输出 $t$ 秒后所有蚂蚁的信息。格式如下：\n\n第一行是一个整数 $s$，表示此时活着的蚂蚁的总数。\n\n接下来 $s$ 行，每行五个整数，依次表示一只蚂蚁的年龄（单位为秒）、等级、当前血量，以及在地图上的位置 $(a,b)$。输出按蚂蚁的年龄递减排序。", "hint": "### 样例说明：\n\n$3\\times 5$ 的地图，有一个单次伤害为 $1$、攻击范围为 $2$ 的激光炮塔，它的位置为 $(2,2)$，模拟游戏的前 $5$ 秒。\n\n$5$ 秒内有 $5$ 只蚂蚁出生，都是向东爬行，其中第 $1\\sim 4$ 只在路过 $(0,2)$ 点时被激光塔射伤了 $1$ 格血。在第 $5$ 秒的时候，最早出生的蚂蚁按移动规则 $1\\sim 3$ 本来该向东移动，但由于规则 $4$ 的作用，它在发现向北和向西移动都会到达不可达点后，最终选择了向南移动。\n\n### 数据范围说明：\n\n对于 $100\\%$ 的数据，满足 $1\\leqslant n,m\\leqslant 8,s\\leqslant 20,t\\leqslant 2\\times 10^5,0\\leqslant d\\leqslant 10^4,0\\leqslant r\\leqslant 15$。（这里的 $s$ 指的是炮塔的总数）。", "locale": "zh-CN"}}}
{"pid": "P2587", "type": "P", "difficulty": 4, "samples": [["2\n1\n3\n2\n4\n", "2 0"], ["6\n10000000\n10000000\n10000000\n10000000\n10000000\n10000000\n0\n0\n0\n0\n0\n0\n", "12 12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2008", "各省省选", "浙江"], "title": "[ZJOI2008] 泡泡堂", "background": "", "description": "第 XXXX 届 NOI 期间，为了加强各省选手之间的交流，组委会决定组织一场省际电子竞技大赛，每一个省的代表队由 $n$ 名选手组成，比赛的项目是老少咸宜的网络游戏泡泡堂。每一场比赛前，对阵双方的教练向组委会提交一份参赛选手的名单，决定了选手上场的顺序，一经确定，不得修改。比赛中，双方的一号选手，二号选手……，$n$ 号选手捉对厮杀，共进行 $n$ 场比赛。每胜一场比赛得 $2$ 分，平一场得 $1$ 分，输一场不得分。最终将双方的单场得分相加得出总分，总分高的队伍晋级(总分相同抽签决定)。\n\n作为浙江队的领队，你已经在事先将各省所有选手的泡泡堂水平了解的一清二楚，并将其用一个实力值来衡量。为简化问题，我们假定选手在游戏中完全不受任何外界因素干扰，即实力强的选手一定可以战胜实力弱的选手，而两个实力相同的选手一定会战平。由于完全不知道对手会使用何种策略来确定出场顺序，所以所有的队伍都采取了这样一种策略，就是完全随机决定出场顺序。\n\n当然你不想这样不明不白的进行比赛。你想事先了解一下在最好与最坏的情况下，浙江队最终分别能得到多少分。\n", "inputFormat": "输入文件的第一行为一个整数 $n$，表示每支代表队的人数。\n\n接下来 $n$ 行，每行一个整数，描述了 $n$ 位浙江队的选手的实力值。\n\n接下来 $n$ 行，每行一个整数，描述了你的对手的 $n$ 位选手的实力值。\n\n\n", "outputFormat": "输入文件中包括两个用空格隔开的整数，分别表示浙江队在最好与最坏的情况下分别能得多少分。不要在行末输出多余的空白字符。\n", "hint": "样例说明\n\n1：我们分别称 $4$ 位选手为 $A,B,C,D$ 。则可能出现以下 $4$ 种对战方式，最好情况下可得 $2$ 分，最坏情况下得 $0$ 分。\n\n| | 浙江 | ？？？ | 结果 | 浙江 | ？？？ | 结果 |  浙江 | ？？？ | 结果 | 浙江 | ？？？ | 结果 |\n| :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- |\n| 一号 | A | C | 负 | A | D | 负 | B | C | 胜 | B | D | 负 |\n| 二号 | B | D | 负 | B | C | 胜 | A | D | 负 | A | C | 负 |\n| 得分 |  |  | 0 |  |  | 2 |  |  | 2 |  |  | 0 |\n\n\n2：对手都是认真学习的好孩子，不会打游戏。无论如何排列出场顺序都无法改变被蹂躏的结果。浙江队总能取得全胜的结果。\n\n$20\\%$ 的数据中，$1\\leq n\\leq 10$；\n\n$40\\%$ 的数据中，$1\\leq n\\leq 100$；\n\n$60\\%$ 的数据中，$1\\leq n\\leq 1000$；\n\n$100\\%$ 的数据中，$1\\leq n\\leq 100000$，且所有选手的实力值在 $0$ 到 $10000000$ 之间。\n", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2008] Paopaotang", "background": "", "description": "During the XXXX-th NOI, to strengthen exchanges among provincial contestants, the organizers decided to hold an inter-provincial e-sports tournament. Each province’s team consists of $n$ players. The event is the popular online game Paopaotang. Before each match, both coaches submit a lineup that fixes the playing order; once submitted, it cannot be changed. In the match, the No. 1 players, No. 2 players, ..., No. $n$ players face off pairwise, for a total of $n$ games. A win yields $2$ points, a draw $1$ point, and a loss $0$ points. The total score is the sum of the single-game points; the team with the higher total advances (if the totals are equal, the winner is decided by drawing lots).\n\nAs the leader of Team Zhejiang, you have already learned the skill levels of all players from every province and measure each by a strength value. To simplify the problem, we assume players are not affected by any external factors: a stronger player always defeats a weaker player, and two players with equal strength always draw. Since the opponent’s strategy for choosing the order is completely unknown, all teams adopt the strategy of deciding the playing order completely at random.\n\nOf course, you do not want to compete without clarity. You want to know in advance, in the best and worst cases, how many points Team Zhejiang can obtain.", "inputFormat": "The first line contains an integer $n$, the number of players on each team.\n\nThe next $n$ lines each contain one integer, the strength values of the $n$ players on Team Zhejiang.\n\nThe following $n$ lines each contain one integer, the strength values of the opponent’s $n$ players.", "outputFormat": "Output two integers separated by a space, representing the best and the worst possible total points that Team Zhejiang can obtain. Do not output extra spaces at the end of the line.", "hint": "Sample explanation\n\n1: We name the $4$ players $A, B, C, D$. The following $4$ types of matchups may occur. In the best case, Zhejiang can get $2$ points; in the worst case, it gets $0$ points.\n\n| | Zhejiang | Opponent | Result | Zhejiang | Opponent | Result | Zhejiang | Opponent | Result | Zhejiang | Opponent | Result |\n| :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- |\n| No. 1 | A | C | Loss | A | D | Loss | B | C | Win | B | D | Loss |\n| No. 2 | B | D | Loss | B | C | Win | A | D | Loss | A | C | Loss |\n| Score |  |  | 0 |  |  | 2 |  |  | 2 |  |  | 0 |\n\n2: The opponents are all diligent students who do not play games. No matter how they arrange the order, they cannot change the outcome. Team Zhejiang always achieves a clean sweep.\n\nConstraints\n\n- For $20\\%$ of the testdata, $1 \\leq n \\leq 10$.\n- For $40\\%$ of the testdata, $1 \\leq n \\leq 100$.\n- For $60\\%$ of the testdata, $1 \\leq n \\leq 1000$.\n- For $100\\%$ of the testdata, $1 \\leq n \\leq 100000$, and all players’ strength values are between $0$ and $10000000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2008] 泡泡堂", "background": "", "description": "第 XXXX 届 NOI 期间，为了加强各省选手之间的交流，组委会决定组织一场省际电子竞技大赛，每一个省的代表队由 $n$ 名选手组成，比赛的项目是老少咸宜的网络游戏泡泡堂。每一场比赛前，对阵双方的教练向组委会提交一份参赛选手的名单，决定了选手上场的顺序，一经确定，不得修改。比赛中，双方的一号选手，二号选手……，$n$ 号选手捉对厮杀，共进行 $n$ 场比赛。每胜一场比赛得 $2$ 分，平一场得 $1$ 分，输一场不得分。最终将双方的单场得分相加得出总分，总分高的队伍晋级(总分相同抽签决定)。\n\n作为浙江队的领队，你已经在事先将各省所有选手的泡泡堂水平了解的一清二楚，并将其用一个实力值来衡量。为简化问题，我们假定选手在游戏中完全不受任何外界因素干扰，即实力强的选手一定可以战胜实力弱的选手，而两个实力相同的选手一定会战平。由于完全不知道对手会使用何种策略来确定出场顺序，所以所有的队伍都采取了这样一种策略，就是完全随机决定出场顺序。\n\n当然你不想这样不明不白的进行比赛。你想事先了解一下在最好与最坏的情况下，浙江队最终分别能得到多少分。\n", "inputFormat": "输入文件的第一行为一个整数 $n$，表示每支代表队的人数。\n\n接下来 $n$ 行，每行一个整数，描述了 $n$ 位浙江队的选手的实力值。\n\n接下来 $n$ 行，每行一个整数，描述了你的对手的 $n$ 位选手的实力值。\n\n\n", "outputFormat": "输入文件中包括两个用空格隔开的整数，分别表示浙江队在最好与最坏的情况下分别能得多少分。不要在行末输出多余的空白字符。\n", "hint": "样例说明\n\n1：我们分别称 $4$ 位选手为 $A,B,C,D$ 。则可能出现以下 $4$ 种对战方式，最好情况下可得 $2$ 分，最坏情况下得 $0$ 分。\n\n| | 浙江 | ？？？ | 结果 | 浙江 | ？？？ | 结果 |  浙江 | ？？？ | 结果 | 浙江 | ？？？ | 结果 |\n| :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- |\n| 一号 | A | C | 负 | A | D | 负 | B | C | 胜 | B | D | 负 |\n| 二号 | B | D | 负 | B | C | 胜 | A | D | 负 | A | C | 负 |\n| 得分 |  |  | 0 |  |  | 2 |  |  | 2 |  |  | 0 |\n\n\n2：对手都是认真学习的好孩子，不会打游戏。无论如何排列出场顺序都无法改变被蹂躏的结果。浙江队总能取得全胜的结果。\n\n$20\\%$ 的数据中，$1\\leq n\\leq 10$；\n\n$40\\%$ 的数据中，$1\\leq n\\leq 100$；\n\n$60\\%$ 的数据中，$1\\leq n\\leq 1000$；\n\n$100\\%$ 的数据中，$1\\leq n\\leq 100000$，且所有选手的实力值在 $0$ 到 $10000000$ 之间。\n", "locale": "zh-CN"}}}
{"pid": "P2588", "type": "P", "difficulty": 6, "samples": [["4 12\r\n3 2\r\n11 8\r\n12 17\r\n1 19\r\n0 0 10 0\r\n10 0 20 0\r\n20 0 20 10\r\n20 10 20 20\r\n20 20 10 20\r\n10 20 0 20\r\n0 20 0 10\r\n0 10 0 0\r\n10 0 10 10\r\n0 10 10 10\r\n20 10 10 10\r\n10 20 10 10\r\n", "2 2 4\r\n2 1 3\r\n2 2 4\r\n2 1 3\r\n"], ["4 16\r\n170 13\r\n24 88\r\n152 49\r\n110 130\r\n60 60 140 60\r\n140 60 140 140\r\n140 140 60 140\r\n60 140 60 60\r\n0 0 200 0\r\n200 0 200 200\r\n200 200 0 200\r\n0 200 0 0\r\n40 40 160 40\r\n160 40 160 160\r\n160 160 40 160\r\n40 160 40 40\r\n20 20 180 20\r\n180 20 180 180\r\n180 180 20 180\r\n20 180 20 20\r\n", "1 2\r\n2 1 3\r\n2 2 4\r\n1 3\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "计算几何", "2008", "各省省选", "浙江"], "title": "[ZJOI2008] Risk", "background": "", "description": "经过连续若干年的推广，Risk这个游戏已经风靡全国，成为大众喜闻乐见的重要娱乐方式。Risk这个游戏可以理解为一种简易的策略游戏，游戏者的目的是占领所有的土地。由于游戏规则的规定，只要两个国家相邻，就认为两个国家有交战的可能性。我们现在希望知道在当前的局面下，哪些国家之间有交战的可能性。注意，我们认为只有当两个国家的国界线有公共边的时候才认为相邻，若两个国家的领土只有公共点，则认为两个国家不相邻。\n\n每一个国家的边界由一系列线段组成，保证这个边界是一个简单多边形，即严格不自交。为了定位每个国家的位置，我们还给出每个国家最庞大的一支军队的位置，保证这个位置一定出现在某一个形内，而不是出现在某条边界上。\n", "inputFormat": "输入文件的第一行中包括两个整数n,m。分别表示地图上的国家数和描述国家的边界的线段的数量。1<=n<=600，1<=m<=4000。接下来n行，每行用一对数描述了某个国家的主力军队的坐标。接下来m行，每行有4个数x1,y1,x2,y2，（x1,y1）-(x2,y2)描述了一条国界线。所有点的坐标都是0-10000之间的整数。\n\n保证输入的所有线段至多只会在线段交点处相交。整张地图上有且仅有一块面积无限的空白区域不属于任何国家。每一条国界线两侧的区域或者隶属于两个不同的国家，或者分隔了一个国家与那块无穷大的空白区域。即保证一条国界线两侧的区域不同时属于同一个国家或是同时都是空白区域。所有封闭区域内部包含且仅包含一支主力军队，表示了该区域的归属。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1707.png) \n\n例如上图中第一行的数据是合法的。而第二行中的数据都是不合法的。左边的那幅图包含线段两侧都是空白区域；中间的图包含线段两侧区域同时属于同一个国家；右边的图中军队被布置在了国界线上，因此非法；此外若最右侧的图中若没有军队也是非法的。保证输入文件提供的数据都是合法的，你的程序不需要进行数据合法性的判定。\n", "outputFormat": "输出文件包括n行，每行第一个数字x表示有x个国家可能与这个国家交战，接着在同一行中升序输出x个整数，表示可能与这个国家交战的国家的编号。国家按输入中给出的顺序从1到n编号。注意数字间严格以一个空格隔开，并且不要在行末输出多余的空白字符。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2008] Risk", "background": "", "description": "After several consecutive years of promotion, the game Risk has become popular nationwide and is now a widely enjoyed form of entertainment. Risk can be understood as a simple strategy game in which the player’s goal is to occupy all territories. According to the rules, any two countries that are adjacent are considered to have a possibility of engaging in war. We now want to determine, under the current situation, which pairs of countries may go to war. Note that we consider two countries adjacent only when their borders share a common edge; if two countries’ territories touch only at a single point, they are considered non-adjacent.\n\nThe boundary of each country is composed of a sequence of line segments and is guaranteed to be a simple polygon, i.e., strictly non-self-intersecting. To locate each country, we also give the position of its largest army, which is guaranteed to lie strictly inside some region rather than on any boundary.", "inputFormat": "The first line contains two integers $n, m$, representing the number of countries on the map and the number of line segments that describe country borders, respectively. $1 \\le n \\le 600$, $1 \\le m \\le 4000$.\n\nThe next $n$ lines each contain a pair of numbers giving the coordinates of a country’s main army.\n\nThe next $m$ lines each contain four numbers $x_1, y_1, x_2, y_2$; the segment $(x_1, y_1)$–$(x_2, y_2)$ describes a border line. All point coordinates are integers between $0$ and $10000$ inclusive.\n\nIt is guaranteed that the input line segments intersect at most at discrete intersection points. There is exactly one unbounded blank region on the entire map that does not belong to any country. For every border line, the regions on its two sides either belong to two different countries, or separate a country from that unbounded blank region. In other words, no border line has the same country on both sides, and no border line has blank regions on both sides. Every bounded region contains exactly one main army inside it, indicating that region’s owner.\n\n ![](https://cdn.luogu.com.cn/upload/pic/1707.png) \n\nFor example, the first row in the figure above is valid. The data in the second row are all invalid: in the left image, both sides of a line segment are blank regions; in the middle image, both sides belong to the same country; in the right image, the army is placed on the border line, which is illegal; moreover, if the rightmost image had no army, that would also be illegal. The input is guaranteed to be valid; your program does not need to verify validity.", "outputFormat": "Output $n$ lines. In each line, the first number $x$ is the count of countries that may go to war with this country. Then, on the same line, output $x$ integers in ascending order, representing the indices of those countries. Countries are indexed $1$ to $n$ in the order they appear in the input. Separate numbers with exactly one space, and do not print extra spaces at the end of a line.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2008] Risk", "background": "", "description": "经过连续若干年的推广，Risk这个游戏已经风靡全国，成为大众喜闻乐见的重要娱乐方式。Risk这个游戏可以理解为一种简易的策略游戏，游戏者的目的是占领所有的土地。由于游戏规则的规定，只要两个国家相邻，就认为两个国家有交战的可能性。我们现在希望知道在当前的局面下，哪些国家之间有交战的可能性。注意，我们认为只有当两个国家的国界线有公共边的时候才认为相邻，若两个国家的领土只有公共点，则认为两个国家不相邻。\n\n每一个国家的边界由一系列线段组成，保证这个边界是一个简单多边形，即严格不自交。为了定位每个国家的位置，我们还给出每个国家最庞大的一支军队的位置，保证这个位置一定出现在某一个形内，而不是出现在某条边界上。\n", "inputFormat": "输入文件的第一行中包括两个整数n,m。分别表示地图上的国家数和描述国家的边界的线段的数量。1<=n<=600，1<=m<=4000。接下来n行，每行用一对数描述了某个国家的主力军队的坐标。接下来m行，每行有4个数x1,y1,x2,y2，（x1,y1）-(x2,y2)描述了一条国界线。所有点的坐标都是0-10000之间的整数。\n\n保证输入的所有线段至多只会在线段交点处相交。整张地图上有且仅有一块面积无限的空白区域不属于任何国家。每一条国界线两侧的区域或者隶属于两个不同的国家，或者分隔了一个国家与那块无穷大的空白区域。即保证一条国界线两侧的区域不同时属于同一个国家或是同时都是空白区域。所有封闭区域内部包含且仅包含一支主力军队，表示了该区域的归属。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1707.png) \n\n例如上图中第一行的数据是合法的。而第二行中的数据都是不合法的。左边的那幅图包含线段两侧都是空白区域；中间的图包含线段两侧区域同时属于同一个国家；右边的图中军队被布置在了国界线上，因此非法；此外若最右侧的图中若没有军队也是非法的。保证输入文件提供的数据都是合法的，你的程序不需要进行数据合法性的判定。\n", "outputFormat": "输出文件包括n行，每行第一个数字x表示有x个国家可能与这个国家交战，接着在同一行中升序输出x个整数，表示可能与这个国家交战的国家的编号。国家按输入中给出的顺序从1到n编号。注意数字间严格以一个空格隔开，并且不要在行末输出多余的空白字符。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2589", "type": "P", "difficulty": 5, "samples": [["3\r\n50 30 80\r\n35 25 70\r\n40 10 90", "55"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2006", "各省省选", "浙江", "枚举", "平面几何"], "title": "[ZJOI2006] 碗的叠放", "background": "", "description": "小H有n个碗需要放进橱柜，她希望将他们叠起来放置。你知道每个碗都是规则的圆柱体，并且都是上宽下窄，你已经测量出了每个碗的两个半径及高，请你帮小H找出一种叠放顺序，使得叠放出来的碗堆的高度尽量小，比如：\n\n![](https://cdn.luogu.com.cn/upload/pic/1706.png)\n", "inputFormat": "第一行一个整数n，表示碗的数目。以下n行，每行三个整数h，r1，r2。分别表示碗高及两个半径。其中r1<r2。\n", "outputFormat": "仅一个数，表示最小的高度。答案四舍五入取整。\n", "hint": "数据范围：100%数据满足n<=9。所有输入的数绝对值不超过1000。\n", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2006] Stacking Bowls", "background": "", "description": "Xiao H has $n$ bowls to put into a cupboard. She wants to stack them. Each bowl is a right circular frustum (wider at the top and narrower at the bottom). You have measured each bowl’s two radii and height. Please help Xiao H find a stacking order that minimizes the total height of the stack. For example:\n\n![](https://cdn.luogu.com.cn/upload/pic/1706.png)", "inputFormat": "The first line contains an integer $n$, the number of bowls. Each of the next $n$ lines contains three integers $h$, $r_1$, $r_2$, denoting the bowl’s height and its two radii, where $r_1 < r_2$.", "outputFormat": "Output a single number, the minimal height, rounded to the nearest integer.", "hint": "Constraints: 100% of the testdata satisfies $n \\le 9$. The absolute value of every input number does not exceed 1000.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2006] 碗的叠放", "background": "", "description": "小H有n个碗需要放进橱柜，她希望将他们叠起来放置。你知道每个碗都是规则的圆柱体，并且都是上宽下窄，你已经测量出了每个碗的两个半径及高，请你帮小H找出一种叠放顺序，使得叠放出来的碗堆的高度尽量小，比如：\n\n![](https://cdn.luogu.com.cn/upload/pic/1706.png)\n", "inputFormat": "第一行一个整数n，表示碗的数目。以下n行，每行三个整数h，r1，r2。分别表示碗高及两个半径。其中r1<r2。\n", "outputFormat": "仅一个数，表示最小的高度。答案四舍五入取整。\n", "hint": "数据范围：100%数据满足n<=9。所有输入的数绝对值不超过1000。\n", "locale": "zh-CN"}}}
{"pid": "P2590", "type": "P", "difficulty": 5, "samples": [["4\n1 2\n2 3\n4 1\n4 2 1 3\n12\nQMAX 3 4\nQMAX 3 3\nQMAX 3 2\nQMAX 2 3\nQSUM 3 4\nQSUM 2 1\nCHANGE 1 5\nQMAX 3 4\nCHANGE 3 6\nQMAX 3 4\nQMAX 2 4\nQSUM 3 4\n", "4\n1\n2\n2\n10\n6\n5\n6\n5\n16\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "线段树", "各省省选", "浙江", "树链剖分"], "title": "[ZJOI2008] 树的统计", "background": "", "description": "一棵树上有 $n$ 个节点，编号分别为 $1$ 到 $n$，每个节点都有一个权值 $w$。\n\n我们将以下面的形式来要求你对这棵树完成一些操作：\n\nI. `CHANGE u t` : 把结点 $u$ 的权值改为 $t$。\n\nII. `QMAX u v`: 询问从点 $u$ 到点 $v$ 的路径上的节点的最大权值。\n\nIII. `QSUM u v`: 询问从点 $u$ 到点 $v$ 的路径上的节点的权值和。\n\n注意：从点 $u$ 到点 $v$ 的路径上的节点包括 $u$ 和 $v$ 本身。", "inputFormat": "输入文件的第一行为一个整数 $n$，表示节点的个数。\n\n接下来 $n-1$ 行，每行 $2$ 个整数 $a$ 和 $b$，表示节点 $a$ 和节点 $b$ 之间有一条边相连。\n\n接下来一行 $n$ 个整数，第 $i$ 个整数 $w_i$ 表示节点 $i$ 的权值。\n\n接下来 $1$ 行，为一个整数 $q$，表示操作的总数。\n\n接下来 $q$ 行，每行一个操作，以 `CHANGE u t` 或者 `QMAX u v` 或者 `QSUM u v` 的形式给出。\n", "outputFormat": "对于每个 `QMAX` 或者 `QSUM` 的操作，每行输出一个整数表示要求输出的结果。", "hint": "对于 $100 \\%$ 的数据，保证 $1\\le n \\le 3\\times 10^4$，$0\\le q\\le 2\\times 10^5$。\n\n中途操作中保证每个节点的权值 $w$ 在 $-3\\times 10^4$ 到 $3\\times 10^4$ 之间。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2008] Statistics on a Tree", "background": "", "description": "There is a tree with $n$ nodes, numbered from $1$ to $n$, and each node has a weight $w$.\n\nYou are asked to perform the following operations on the tree:\n\nI. `CHANGE u t`: Set the weight of node $u$ to $t$.\n\nII. `QMAX u v`: Query the maximum weight among the nodes on the path from $u$ to $v$.\n\nIII. `QSUM u v`: Query the sum of the weights of the nodes on the path from $u$ to $v$.\n\nNote: The nodes on the path from $u$ to $v$ include $u$ and $v$ themselves.", "inputFormat": "The first line contains an integer $n$, the number of nodes.\n\nThe next $n-1$ lines each contain two integers $a$ and $b$, indicating that there is an edge between node $a$ and node $b$.\n\nThe next line contains $n$ integers, where the $i$-th integer $w_i$ is the weight of node $i$.\n\nThe next line contains an integer $q$, the total number of operations.\n\nThe next $q$ lines each contain one operation, given as `CHANGE u t`, `QMAX u v`, or `QSUM u v`.", "outputFormat": "For each `QMAX` or `QSUM` operation, output one integer on its own line representing the result.", "hint": "Constraints:\n\nFor $100\\%$ of the testdata, it is guaranteed that $1 \\le n \\le 3\\times 10^4$ and $0 \\le q \\le 2\\times 10^5$.\n\nThroughout the operations, each node’s weight $w$ is guaranteed to be between $-3\\times 10^4$ and $3\\times 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2008] 树的统计", "background": "", "description": "一棵树上有 $n$ 个节点，编号分别为 $1$ 到 $n$，每个节点都有一个权值 $w$。\n\n我们将以下面的形式来要求你对这棵树完成一些操作：\n\nI. `CHANGE u t` : 把结点 $u$ 的权值改为 $t$。\n\nII. `QMAX u v`: 询问从点 $u$ 到点 $v$ 的路径上的节点的最大权值。\n\nIII. `QSUM u v`: 询问从点 $u$ 到点 $v$ 的路径上的节点的权值和。\n\n注意：从点 $u$ 到点 $v$ 的路径上的节点包括 $u$ 和 $v$ 本身。", "inputFormat": "输入文件的第一行为一个整数 $n$，表示节点的个数。\n\n接下来 $n-1$ 行，每行 $2$ 个整数 $a$ 和 $b$，表示节点 $a$ 和节点 $b$ 之间有一条边相连。\n\n接下来一行 $n$ 个整数，第 $i$ 个整数 $w_i$ 表示节点 $i$ 的权值。\n\n接下来 $1$ 行，为一个整数 $q$，表示操作的总数。\n\n接下来 $q$ 行，每行一个操作，以 `CHANGE u t` 或者 `QMAX u v` 或者 `QSUM u v` 的形式给出。\n", "outputFormat": "对于每个 `QMAX` 或者 `QSUM` 的操作，每行输出一个整数表示要求输出的结果。", "hint": "对于 $100 \\%$ 的数据，保证 $1\\le n \\le 3\\times 10^4$，$0\\le q\\le 2\\times 10^5$。\n\n中途操作中保证每个节点的权值 $w$ 在 $-3\\times 10^4$ 到 $3\\times 10^4$ 之间。", "locale": "zh-CN"}}}
{"pid": "P2591", "type": "P", "difficulty": 5, "samples": [["1 1\r\n", "1\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2009", "各省省选", "浙江"], "title": "[ZJOI2009] 函数", "background": "", "description": "有 $N$ 个连续函数 $f_i(x)$，其中 $1\\le i\\le N$。如果对于任意不相等的 $i,j$ 满足 $1\\le i,j\\le N$，恰好存在一个 $x$ 使得 $f_i(x)=f_j(x)$，并且存在无穷多的 $x$ 使得 $f_i(x)<f_j(x)$，对于任意 $i,j,k$ 满足 $1\\le i < j < k\\le N$，不存在 $x$ 使得 $f_i(x)=f_j(x)=f_k(x)$，则称这 $N$ 个连续函数满足条件。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1708.png) \n\n如上左图就是 $3$ 个满足条件的函数，最左边从下往上依次为 $f_1,f_2,f_3$。右图中红色部分是这整个函数图像的最低层，我们称它为第一层。同理绿色部分称为第二层，蓝色部分称为第三层。注意到，右图中第一层左边一段属于 $f_1$，中间属于 $f_2$，最后属于 $f_3$。而第二层左边属于 $f_2$，接下来一段属于 $f_1$，再接下来一段属于 $f_3$，最后属于 $f_2$。因此，我们称第一层分为了三段，第二层分为了四段。同理第三层只分为了两段。求满足前面条件的 $N$ 个函数，第 $K$ 层最少能由多少段组成。", "inputFormat": "一行两个整数 $N,K$。", "outputFormat": "一行一个整数，表示 $N$ 个函数第 $K$ 层最少能由多少段组成。", "hint": "对于 $100\\%$ 的数据满足 $1\\le K\\le N\\le 100$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2009] Functions", "background": "", "description": "There are $N$ continuous functions $f_i(x)$, where $1 \\le i \\le N$. If for any unequal $i, j$ with $1 \\le i, j \\le N$, there exists exactly one $x$ such that $f_i(x) = f_j(x)$, and there exist infinitely many $x$ such that $f_i(x) < f_j(x)$, and for any $i, j, k$ with $1 \\le i < j < k \\le N$, there does not exist $x$ such that $f_i(x) = f_j(x) = f_k(x)$, then these $N$ continuous functions are said to satisfy the condition.\n\n![](https://cdn.luogu.com.cn/upload/pic/1708.png)\n\nAs shown in the left figure, there are $3$ functions that satisfy the condition; on the far left, from bottom to top, they are $f_1, f_2, f_3$. In the right figure, the red part is the lowest layer of the entire graph, which we call the first layer. Similarly, the green part is the second layer, and the blue part is the third layer. Note that, in the right figure, the left segment of the first layer belongs to $f_1$, the middle segment belongs to $f_2$, and the last segment belongs to $f_3$. For the second layer, the left segment belongs to $f_2$, the next segment belongs to $f_1$, the next segment belongs to $f_3$, and the last segment belongs to $f_2$. Therefore, we say the first layer is divided into three segments, and the second layer is divided into four segments. Similarly, the third layer is divided into only two segments. Given $N$ functions that satisfy the conditions above, find the minimum possible number of segments that the $K$-th layer can consist of.", "inputFormat": "One line containing two integers $N$, $K$.", "outputFormat": "One line containing a single integer: the minimum number of segments of the $K$-th layer among the $N$ functions.", "hint": "For $100\\%$ of the testdata, $1 \\le K \\le N \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2009] 函数", "background": "", "description": "有 $N$ 个连续函数 $f_i(x)$，其中 $1\\le i\\le N$。如果对于任意不相等的 $i,j$ 满足 $1\\le i,j\\le N$，恰好存在一个 $x$ 使得 $f_i(x)=f_j(x)$，并且存在无穷多的 $x$ 使得 $f_i(x)<f_j(x)$，对于任意 $i,j,k$ 满足 $1\\le i < j < k\\le N$，不存在 $x$ 使得 $f_i(x)=f_j(x)=f_k(x)$，则称这 $N$ 个连续函数满足条件。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1708.png) \n\n如上左图就是 $3$ 个满足条件的函数，最左边从下往上依次为 $f_1,f_2,f_3$。右图中红色部分是这整个函数图像的最低层，我们称它为第一层。同理绿色部分称为第二层，蓝色部分称为第三层。注意到，右图中第一层左边一段属于 $f_1$，中间属于 $f_2$，最后属于 $f_3$。而第二层左边属于 $f_2$，接下来一段属于 $f_1$，再接下来一段属于 $f_3$，最后属于 $f_2$。因此，我们称第一层分为了三段，第二层分为了四段。同理第三层只分为了两段。求满足前面条件的 $N$ 个函数，第 $K$ 层最少能由多少段组成。", "inputFormat": "一行两个整数 $N,K$。", "outputFormat": "一行一个整数，表示 $N$ 个函数第 $K$ 层最少能由多少段组成。", "hint": "对于 $100\\%$ 的数据满足 $1\\le K\\le N\\le 100$。\n", "locale": "zh-CN"}}}
{"pid": "P2592", "type": "P", "difficulty": 4, "samples": [["1 2 1", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2008", "各省省选", "浙江", "前缀和"], "title": "[ZJOI2008] 生日聚会", "background": null, "description": "今天是 hidadz 小朋友的生日，她邀请了许多朋友来参加她的生日 party。hidadz 带着朋友们来到花园中，打算坐成一排玩游戏。为了游戏不至于无聊，就座的方案应满足如下条件：\n\n对于任意连续的一段，男孩与女孩的数目之差不超过 $k$。\n\n很快，小朋友便找到了一种方案坐了下来开始游戏。hidadz 的好朋友 Susie 发现，这样的就座方案其实是很多的，所以大家很快就找到了一种，那么到底有多少种呢？热爱数学的 hidadz 和她的朋友们开始思考这个问题……\n\n假设参加 party 的人中共有 $n$ 个男孩与 $m$ 个女孩，你是否能解答 Susie 和 hidadz 的疑问呢？由于这个数目可能很多，他们只想知道这个数目除以 $12345678$ 的余数。", "inputFormat": "输入仅包含一行共 $3$ 个整数，分别为男孩数目 $n$，女孩数目$m$，常数 $k$。", "outputFormat": "输出应包含一行，为题中要求的答案。", "hint": "对于 $30\\%$ 的数据，$n,m\\le 20$；\n\n对于 $100\\%$ 的数据，$n,m\\le 150，k \\le 20$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2008] Birthday Party", "background": "", "description": "Today is hidadz’s birthday, and she has invited many friends to her birthday party. hidadz takes her friends to the garden, planning to sit in a row to play a game. To keep the game from being boring, the seating arrangement must satisfy the following condition:\n\nFor any consecutive segment, the absolute difference between the number of boys and the number of girls does not exceed $k$.\n\nSoon, the kids find one such arrangement and start the game. hidadz’s good friend Susie notices that there are actually many such seating arrangements, so since everyone can quickly find one, how many are there in total? The math-loving hidadz and her friends begin to think about this question.\n\nAssume there are $n$ boys and $m$ girls at the party. Can you answer Susie and hidadz’s question? Since this number can be large, they only want the remainder when it is divided by $12345678$.", "inputFormat": "The input contains a single line with $3$ integers: the number of boys $n$, the number of girls $m$, and the constant $k$.", "outputFormat": "Output a single line containing the required answer.", "hint": "For $30\\%$ of the testdata, $n, m \\le 20$.\n\nFor $100\\%$ of the testdata, $n, m \\le 150$, $k \\le 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2008] 生日聚会", "background": null, "description": "今天是 hidadz 小朋友的生日，她邀请了许多朋友来参加她的生日 party。hidadz 带着朋友们来到花园中，打算坐成一排玩游戏。为了游戏不至于无聊，就座的方案应满足如下条件：\n\n对于任意连续的一段，男孩与女孩的数目之差不超过 $k$。\n\n很快，小朋友便找到了一种方案坐了下来开始游戏。hidadz 的好朋友 Susie 发现，这样的就座方案其实是很多的，所以大家很快就找到了一种，那么到底有多少种呢？热爱数学的 hidadz 和她的朋友们开始思考这个问题……\n\n假设参加 party 的人中共有 $n$ 个男孩与 $m$ 个女孩，你是否能解答 Susie 和 hidadz 的疑问呢？由于这个数目可能很多，他们只想知道这个数目除以 $12345678$ 的余数。", "inputFormat": "输入仅包含一行共 $3$ 个整数，分别为男孩数目 $n$，女孩数目$m$，常数 $k$。", "outputFormat": "输出应包含一行，为题中要求的答案。", "hint": "对于 $30\\%$ 的数据，$n,m\\le 20$；\n\n对于 $100\\%$ 的数据，$n,m\\le 150，k \\le 20$。", "locale": "zh-CN"}}}
{"pid": "P2593", "type": "P", "difficulty": 5, "samples": [["3\r\n2 4 0 0 0 0 0 …… 0（一共98个0）\r\n2 4 2 0 0 0 0 …… 0（一共97个0）\r\n2 3 2 0 0 0 0 …… 0（一共97个0）", "Yes\r\nYes\r\nNo"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2006", "各省省选", "浙江", "哈希 hashing"], "title": "[ZJOI2006] 超级麻将", "background": null, "description": "很多人都知道玩麻将，当然也有人不知道，呵呵，不要紧，我在这里简要地介绍一下麻将规则：\n\n普通麻将有砣、索、万三种类型的牌，每种牌有 $1\\sim9$ 个数字，其中相同的牌每个有四张，例如 `1砣`\\~`9砣`，`1索`\\~`9索`，`1万`\\~`9万` 各有 $4$ 张，所以共 $36\\times 3=108$ 张牌。胡牌时每人有 $14$ 张牌，其中只要某人手里有若干句话（就是同种类型的牌连续三张或同种牌三张），另外再加上一对，即可胡牌。当然如果全是对，叫七小对，也可以胡牌。下图是连三张示例。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1709.png) \n\n要判断某人是否胡牌，显然一个弱智的算法就行了，某中学信息学小组超级麻将迷想了想，决定将普通麻将改造成超级麻将。\n\n所谓超级麻将没有了砣、索、万的区分，每种牌上的数字可以是 $1\\sim100$，而每种数字的牌各有 $100$ 张。另外特别自由的是，玩牌的人手里想拿多少张牌都可以，好刺激哦！\n\n刺激归刺激，但是拿多了怎么胡牌呢？\n\n超级麻将规定只要一个人手里拿的牌是若干句话（三个连续数字的牌各一张组成一句话，三张或者四张同样数字的牌也算一句话），再加上一对相同的牌，就算胡了。\n\n作为信息学竞赛选手的你，麻烦你给这位超级麻将迷编个程序，判断能否胡牌。", "inputFormat": "输入文件第一行一个整数 $N(N\\le 100)$，表示玩了N次超级麻将。\n\n接下来 $N$ 行，每行 $100$ 个数 $a_1 \\dots a_{100}$，描述每次玩牌手中各种牌的数量。$a_i$ 表示数字为i的牌有 $a_i$ 张。$(0\\le a_i\\le 100)$", "outputFormat": "输出 $N$ 行，若胡了则输出 `Yes`，否则输出 `No`，注意区分 `Yes`，`No` 的大小写！", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2006] Super Mahjong", "background": "", "description": "Many people know how to play Mahjong; of course, some do not. Don’t worry, here is a brief introduction to the rules.\n\nIn standard Mahjong, there are three suits: \"Tong\", \"Suo\", and \"Wan\". Each suit has numbers $1\\sim9$, and there are four copies of each identical tile. For example, `1Tong`\\~`9Tong`, `1Suo`\\~`9Suo`, and `1Wan`\\~`9Wan` each have $4$ copies, so there are $36\\times 3=108$ tiles in total. When someone wins, each player has $14$ tiles. A winning hand consists of several melds (either three consecutive tiles of the same suit, or three identical tiles), plus one pair. Of course, if the hand consists entirely of pairs, called “Seven Pairs”, it is also a winning hand. The figure below shows an example of three in sequence.\n\n ![](https://cdn.luogu.com.cn/upload/pic/1709.png) \n\nTo judge whether someone can win, an obviously naive algorithm would do. A Mahjong fanatic from a middle school informatics club thought about it and decided to modify standard Mahjong into Super Mahjong.\n\nIn Super Mahjong, there is no distinction between suits. The number on each tile can be $1\\sim100$, and there are $100$ copies of each number. What’s more, players are free to hold as many tiles as they like. Exciting!\n\nExciting as it is, how do you form a winning hand with many tiles?\n\nSuper Mahjong defines that a hand is winning if the tiles can be partitioned into several melds (one meld can be three consecutive numbers, one tile each; or three or four identical numbers also count as one meld), plus one pair of identical tiles.\n\nAs an informatics contestant, please write a program to determine whether the player can win.", "inputFormat": "The first line contains an integer $N(N\\le 100)$, indicating that Super Mahjong was played $N$ times.\n\nThe next $N$ lines each contain $100$ numbers $a_1 \\dots a_{100}$, describing the counts of each tile number in that round. $a_i$ means there are $a_i$ tiles with number $i$. $(0\\le a_i\\le 100)$", "outputFormat": "Output $N$ lines. Print `Yes` if it is a winning hand; otherwise print `No`. Note the case of `Yes` and `No`.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2006] 超级麻将", "background": null, "description": "很多人都知道玩麻将，当然也有人不知道，呵呵，不要紧，我在这里简要地介绍一下麻将规则：\n\n普通麻将有砣、索、万三种类型的牌，每种牌有 $1\\sim9$ 个数字，其中相同的牌每个有四张，例如 `1砣`\\~`9砣`，`1索`\\~`9索`，`1万`\\~`9万` 各有 $4$ 张，所以共 $36\\times 3=108$ 张牌。胡牌时每人有 $14$ 张牌，其中只要某人手里有若干句话（就是同种类型的牌连续三张或同种牌三张），另外再加上一对，即可胡牌。当然如果全是对，叫七小对，也可以胡牌。下图是连三张示例。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1709.png) \n\n要判断某人是否胡牌，显然一个弱智的算法就行了，某中学信息学小组超级麻将迷想了想，决定将普通麻将改造成超级麻将。\n\n所谓超级麻将没有了砣、索、万的区分，每种牌上的数字可以是 $1\\sim100$，而每种数字的牌各有 $100$ 张。另外特别自由的是，玩牌的人手里想拿多少张牌都可以，好刺激哦！\n\n刺激归刺激，但是拿多了怎么胡牌呢？\n\n超级麻将规定只要一个人手里拿的牌是若干句话（三个连续数字的牌各一张组成一句话，三张或者四张同样数字的牌也算一句话），再加上一对相同的牌，就算胡了。\n\n作为信息学竞赛选手的你，麻烦你给这位超级麻将迷编个程序，判断能否胡牌。", "inputFormat": "输入文件第一行一个整数 $N(N\\le 100)$，表示玩了N次超级麻将。\n\n接下来 $N$ 行，每行 $100$ 个数 $a_1 \\dots a_{100}$，描述每次玩牌手中各种牌的数量。$a_i$ 表示数字为i的牌有 $a_i$ 张。$(0\\le a_i\\le 100)$", "outputFormat": "输出 $N$ 行，若胡了则输出 `Yes`，否则输出 `No`，注意区分 `Yes`，`No` 的大小写！", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2594", "type": "P", "difficulty": 6, "samples": [["3\n2 3\nHHH\nHHH\n2 3\nHHH\nTTH\n2 1\nT\nH", "=_=\n-_-\n-_-"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "博弈论", "2009", "各省省选", "浙江", "SG 函数"], "title": "[ZJOI2009] 染色游戏", "background": null, "description": "一共 $n \\times m$ 个硬币，摆成 $n \\times m$ 的长方形。dongdong 和 xixi 玩一个游戏，每次可以选择一个连通块，并把其中的硬币全部翻转，但是需要满足存在一个硬币属于这个连通块并且所有其他硬币都在它的左上方(可以正左方也可以正上方)，并且这个硬币是从反面向上翻成正面向上。dongdong 和 xixi 轮流操作。如果某一方无法操作，那么他(她)就输了。dongdong 先进行第一步操作，假设双方都采用最优策略。问 dongdong 是否有必胜策略。", "inputFormat": "第一行一个数 $T$，表示他们一共玩 $T$ 局游戏。\n\n接下来是 $T$ 组游戏描述。每组游戏第一行两个数 $n,m$。\n\n接下来 $n$ 行每行 $m$ 个字符，第 $i$ 行第 $j$ 个字符如果是 `H` 表示第 $i$ 行第 $j$ 列的硬币是正面向上，否则是反面向上。第 $i$ 行 $j$ 列的左上方是指行不超过 $i$ 并且列不超过 $j$ 的区域。", "outputFormat": "对于每局游戏，输出一行。如果 dongdong 存在必胜策略则输出 `-_-` 否则输出 `=_=`（注意输出的都是半角符号，即三个符号 ASCII 码分别为 45,61,95)。", "hint": "对于 $40\\%$ 的数据，满足 $1 \\le n,m \\le 5$。\n\n对于 $100\\%$ 的数据，满足 $1 \\le n,m \\le 100，1 \\le T \\le 50$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2009] Coloring Game", "background": "", "description": "There are $n \\times m$ coins arranged in an $n \\times m$ rectangle. Dongdong and Xixi play a game. In each move, a player may choose a connected component and flip all coins in it, but the move must satisfy: there exists a coin in this component such that all other coins in the component are in its upper-left (including directly to its left or directly above), and this coin is flipped from tails-up to heads-up. Dongdong and Xixi take turns. If a player cannot move, he or she loses. Dongdong moves first. Assuming both play optimally, determine whether Dongdong has a winning strategy.", "inputFormat": "The first line contains a number $T$, the number of games they play.\n\nThen follow $T$ game descriptions. For each game, the first line contains two numbers $n, m$.\n\nThen there are $n$ lines, each with $m$ characters. In the $i$-th line, the $j$-th character is `H` if the coin at row $i$, column $j$ is heads-up; otherwise it is tails-up. The upper-left of cell $(i, j)$ refers to the region with row index not exceeding $i$ and column index not exceeding $j$.", "outputFormat": "For each game, output one line. If Dongdong has a winning strategy, output `-_-`; otherwise, output `=_=`. Note that these are half-width characters, i.e., the three characters have ASCII codes 45, 61, and 95.", "hint": "For $40\\%$ of the testdata, $1 \\le n,m \\le 5$.\n\nFor $100\\%$ of the testdata, $1 \\le n,m \\le 100, 1 \\le T \\le 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2009] 染色游戏", "background": null, "description": "一共 $n \\times m$ 个硬币，摆成 $n \\times m$ 的长方形。dongdong 和 xixi 玩一个游戏，每次可以选择一个连通块，并把其中的硬币全部翻转，但是需要满足存在一个硬币属于这个连通块并且所有其他硬币都在它的左上方(可以正左方也可以正上方)，并且这个硬币是从反面向上翻成正面向上。dongdong 和 xixi 轮流操作。如果某一方无法操作，那么他(她)就输了。dongdong 先进行第一步操作，假设双方都采用最优策略。问 dongdong 是否有必胜策略。", "inputFormat": "第一行一个数 $T$，表示他们一共玩 $T$ 局游戏。\n\n接下来是 $T$ 组游戏描述。每组游戏第一行两个数 $n,m$。\n\n接下来 $n$ 行每行 $m$ 个字符，第 $i$ 行第 $j$ 个字符如果是 `H` 表示第 $i$ 行第 $j$ 列的硬币是正面向上，否则是反面向上。第 $i$ 行 $j$ 列的左上方是指行不超过 $i$ 并且列不超过 $j$ 的区域。", "outputFormat": "对于每局游戏，输出一行。如果 dongdong 存在必胜策略则输出 `-_-` 否则输出 `=_=`（注意输出的都是半角符号，即三个符号 ASCII 码分别为 45,61,95)。", "hint": "对于 $40\\%$ 的数据，满足 $1 \\le n,m \\le 5$。\n\n对于 $100\\%$ 的数据，满足 $1 \\le n,m \\le 100，1 \\le T \\le 50$。", "locale": "zh-CN"}}}
{"pid": "P2595", "type": "P", "difficulty": 7, "samples": [["3 3\n...\n...\n...", "2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "各省省选", "浙江", "容斥原理", "状压 DP"], "title": "[ZJOI2009] 多米诺骨牌", "background": "", "description": "有一个 $n \\times m$ 的矩形表格，其中有一些位置有障碍。现在要在这个表格内放一些 $1 \\times 2$ 或者 $2 \\times 1$ 的多米诺骨牌，使得任何两个多米诺骨牌没有重叠部分，任何一个骨牌不能放到障碍上。并且满足任何相邻两行之间都有至少一个骨牌横跨，任何相邻两列之间也都至少有一个骨牌横跨。求有多少种不同的放置方法，注意你并不需要放满所有没有障碍的格子。\n", "inputFormat": "第一行两个整数 $n,m$。\n\n接下来 $n$ 行，每行 $m$ 个字符，表示这个矩形表格。其中字符 `x` 表示这个位置有障碍，字符 `.` 表示没有障碍。", "outputFormat": "一行一个整数，表示不同的放置方法数对 $19\\,901\\,013$ 取模的值。", "hint": "### 样例解释\n\n两种放置方法分别为：\n\n```plain\n112 411\n4.2 4.2\n433 332\n```\n\n注意这里的数字只用于区分骨牌，不同的排列并不代表不同的方案。\n\n### 数据范围\n\n- 对于 $40\\%$ 的数据，满足 $n,m \\leq 8$；\n- 对于 $90\\%$ 的数据，满足 $n,m \\leq 14$。\n- 对于 $100\\%$ 的数据，满足 $1 \\leq n,m \\leq 15$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2009] Dominoes", "background": "", "description": "There is an $n \\times m$ rectangular grid with some cells blocked by obstacles. You need to place some $1 \\times 2$ or $2 \\times 1$ dominoes on this grid so that any two dominoes do not overlap, and no domino covers an obstacle. Moreover, for every pair of adjacent rows, there must be at least one domino crossing them; similarly, for every pair of adjacent columns, there must be at least one domino crossing them. Find the number of different placement methods. Note that you do not need to cover all unobstructed cells.", "inputFormat": "The first line contains two integers $n, m$.\n\nThe next $n$ lines each contain $m$ characters describing the grid. Character `x` means the cell has an obstacle, and character `.` means the cell is empty.", "outputFormat": "Output a single integer: the number of different placements modulo $19\\,901\\,013$.", "hint": "Sample explanation:\n\nTwo valid placements are:\n\n```plain\n112 411\n4.2 4.2\n433 332\n```\n\nNote that the digits are only used to distinguish dominoes; different labelings do not represent different solutions.\n\nConstraints:\n- For $40\\%$ of the testdata, $n, m \\leq 8$.\n- For $90\\%$ of the testdata, $n, m \\leq 14$.\n- For $100\\%$ of the testdata, $1 \\leq n, m \\leq 15$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2009] 多米诺骨牌", "background": "", "description": "有一个 $n \\times m$ 的矩形表格，其中有一些位置有障碍。现在要在这个表格内放一些 $1 \\times 2$ 或者 $2 \\times 1$ 的多米诺骨牌，使得任何两个多米诺骨牌没有重叠部分，任何一个骨牌不能放到障碍上。并且满足任何相邻两行之间都有至少一个骨牌横跨，任何相邻两列之间也都至少有一个骨牌横跨。求有多少种不同的放置方法，注意你并不需要放满所有没有障碍的格子。\n", "inputFormat": "第一行两个整数 $n,m$。\n\n接下来 $n$ 行，每行 $m$ 个字符，表示这个矩形表格。其中字符 `x` 表示这个位置有障碍，字符 `.` 表示没有障碍。", "outputFormat": "一行一个整数，表示不同的放置方法数对 $19\\,901\\,013$ 取模的值。", "hint": "### 样例解释\n\n两种放置方法分别为：\n\n```plain\n112 411\n4.2 4.2\n433 332\n```\n\n注意这里的数字只用于区分骨牌，不同的排列并不代表不同的方案。\n\n### 数据范围\n\n- 对于 $40\\%$ 的数据，满足 $n,m \\leq 8$；\n- 对于 $90\\%$ 的数据，满足 $n,m \\leq 14$。\n- 对于 $100\\%$ 的数据，满足 $1 \\leq n,m \\leq 15$。", "locale": "zh-CN"}}}
{"pid": "P2596", "type": "P", "difficulty": 6, "samples": [["10 10\n1 3 2 7 5 8 10 4 9 6\nQuery 3\nTop 5\nAsk 6\nBottom 3\nAsk 3\nTop 6\nInsert 4 -1\nQuery 5\nQuery 2\nAsk 2\n", "2\n9\n9\n7\n5\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "各省省选", "平衡树", "浙江"], "title": "[ZJOI2006] 书架", "background": "", "description": "小 T 有一个很大的书柜。这个书柜的构造有些独特，即书柜里的书是从上至下堆放成一列。她用 $1$ 到 $n$ 的正整数给每本书都编了号。\n\n小 T 在看书的时候，每次取出一本书，看完后放回书柜然后再拿下一本。由于这些书太有吸引力了，所以她看完后常常会忘记原来是放在书柜的什么位置。不过小 T 的记忆力是非常好的，所以每次放书的时候至少能够将那本书放在拿出来时的位置附近，比如说她拿的时候这本书上面有 $x$ 本书，那么放回去时这本书上面就只可能有 $x-1$、$x$ 或 $x+1$ 本书。\n\n当然也有特殊情况，比如在看书的时候突然电话响了或者有朋友来访。这时候粗心的小 T 会随手把书放在书柜里所有书的最上面或者最下面，然后转身离开。\n\n久而久之，小 T 的书柜里的书的顺序就会越来越乱，找到特定的编号的书就变得越来越困难。于是她想请你帮她编写一个图书管理程序，处理她看书时的一些操作，以及回答她的两个提问：\n- 编号为 $x$ 的书在书柜的什么位置。\n- 从上到下第 $i$ 本书的编号是多少。\n", "inputFormat": "第一行有两个整数，分别表示书的个数 $n$ 以及命令条数 $m$。\n\n第二行有 $n$ 个整数，第 $i$ 个整数表示初始时从上向下书第 $i$ 本书的编号 $p_i$。\n\n接下来 $m$ 行，每行表示一个操作。每行初始时有一个字符串  $op$。\n\n- 若 $op$ 为 `Top`，则后有一个整数 $s$，表示把编号为 $s$ 的书放在最上面。\n- 若 $op$ 为 `Bottom`，则后有一个整数 $s$，表示把编号为 $s$ 的书放在最下面。\n- 若 $op$ 为 `Insert`，则后有两个整数 $s, t$，表示若编号为 $s$ 的书上面有 $x$ 本书，则放回这本书时他的上面有 $x + t$ 本书。\n- 若 $op$ 为 `Ask`，则后面有一个整数 $s$，表示询问编号为 $s$ 的书上面有几本书。\n- 若 $op$ 为 `Query`，则后面有一个整数 $s$，询问从上面起第 $s$ 本书的编号。", "outputFormat": "对于每次查询，输出一行一个整数表示答案。", "hint": "### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证：\n- $3 \\leq n, m \\leq 8 \\times 10^4$。\n- $p_i$ 是一个 $1 \\sim n$ 的排列。\n- $1 \\leq s \\leq n$，$-1 \\leq t \\leq 1$，$op$ 只可能是输入的五种字符串之一。\n- 当编号为 $s$ 的书上面没有书的时候，不会对它进行 `Insert s -1` 操作。\n- 当编号为 $s$ 的书下面没有书的时候，不会对它进行 `Insert s 1` 操作。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2006] Bookshelf", "background": "", "description": "Xiao T has a very large bookcase. Its structure is a bit special: the books in the bookcase are stacked in a single column from top to bottom. She labels each book with the positive integers from $1$ to $n$.\n\nWhen Xiao T reads, each time she takes out one book, and after finishing it, she puts it back into the bookcase and then takes the next one. Because the books are so attractive, she often forgets the exact position where the book was originally placed. However, Xiao T has a very good memory, so when she puts a book back, she can at least place it near where it was taken from. For example, if when she took the book there were $x$ books above it, then when putting it back, there can only be $x - 1$, $x$, or $x + 1$ books above it.\n\nOf course, there are special cases, such as when the phone rings or a friend visits while she is reading. At these times, the careless Xiao T may casually put the book at the very top or the very bottom of all the books in the bookcase, and then walk away.\n\nOver time, the order of the books in Xiao T’s bookcase becomes more and more chaotic, making it increasingly difficult to find a specific labeled book. So she asks you to write a library management program to process her operations while reading and answer two types of queries:\n- What is the position of the book with ID $x$ in the bookcase.\n- What is the ID of the $i$-th book from top to bottom.", "inputFormat": "The first line contains two integers, representing the number of books $n$ and the number of commands $m$.\n\nThe second line contains $n$ integers. The $i$-th integer $p_i$ is the ID of the $i$-th book from the top at the beginning.\n\nThen there are $m$ lines, each describing an operation. Each line starts with a string $op$.\n\n- If $op$ is `Top`, followed by an integer $s$, move the book with ID $s$ to the very top.\n- If $op$ is `Bottom`, followed by an integer $s$, move the book with ID $s$ to the very bottom.\n- If $op$ is `Insert`, followed by two integers $s, t$, then if there are $x$ books above the book with ID $s$, when putting it back there should be $x + t$ books above it.\n- If $op$ is `Ask`, followed by an integer $s$, ask how many books are above the book with ID $s$.\n- If $op$ is `Query`, followed by an integer $s$, ask for the ID of the $s$-th book from the top.", "outputFormat": "For each query, output a single integer on its own line as the answer.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that:\n- $3 \\leq n, m \\leq 8 \\times 10^4$.\n- $p_i$ is a permutation of $1$ to $n$.\n- $1 \\leq s \\leq n$, $-1 \\leq t \\leq 1$, and $op$ is one of the five strings above.\n- When there is no book above the book with ID $s$, the operation `Insert s -1` will not be performed.\n- When there is no book below the book with ID $s$, the operation `Insert s 1` will not be performed.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2006] 书架", "background": "", "description": "小 T 有一个很大的书柜。这个书柜的构造有些独特，即书柜里的书是从上至下堆放成一列。她用 $1$ 到 $n$ 的正整数给每本书都编了号。\n\n小 T 在看书的时候，每次取出一本书，看完后放回书柜然后再拿下一本。由于这些书太有吸引力了，所以她看完后常常会忘记原来是放在书柜的什么位置。不过小 T 的记忆力是非常好的，所以每次放书的时候至少能够将那本书放在拿出来时的位置附近，比如说她拿的时候这本书上面有 $x$ 本书，那么放回去时这本书上面就只可能有 $x-1$、$x$ 或 $x+1$ 本书。\n\n当然也有特殊情况，比如在看书的时候突然电话响了或者有朋友来访。这时候粗心的小 T 会随手把书放在书柜里所有书的最上面或者最下面，然后转身离开。\n\n久而久之，小 T 的书柜里的书的顺序就会越来越乱，找到特定的编号的书就变得越来越困难。于是她想请你帮她编写一个图书管理程序，处理她看书时的一些操作，以及回答她的两个提问：\n- 编号为 $x$ 的书在书柜的什么位置。\n- 从上到下第 $i$ 本书的编号是多少。\n", "inputFormat": "第一行有两个整数，分别表示书的个数 $n$ 以及命令条数 $m$。\n\n第二行有 $n$ 个整数，第 $i$ 个整数表示初始时从上向下书第 $i$ 本书的编号 $p_i$。\n\n接下来 $m$ 行，每行表示一个操作。每行初始时有一个字符串  $op$。\n\n- 若 $op$ 为 `Top`，则后有一个整数 $s$，表示把编号为 $s$ 的书放在最上面。\n- 若 $op$ 为 `Bottom`，则后有一个整数 $s$，表示把编号为 $s$ 的书放在最下面。\n- 若 $op$ 为 `Insert`，则后有两个整数 $s, t$，表示若编号为 $s$ 的书上面有 $x$ 本书，则放回这本书时他的上面有 $x + t$ 本书。\n- 若 $op$ 为 `Ask`，则后面有一个整数 $s$，表示询问编号为 $s$ 的书上面有几本书。\n- 若 $op$ 为 `Query`，则后面有一个整数 $s$，询问从上面起第 $s$ 本书的编号。", "outputFormat": "对于每次查询，输出一行一个整数表示答案。", "hint": "### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证：\n- $3 \\leq n, m \\leq 8 \\times 10^4$。\n- $p_i$ 是一个 $1 \\sim n$ 的排列。\n- $1 \\leq s \\leq n$，$-1 \\leq t \\leq 1$，$op$ 只可能是输入的五种字符串之一。\n- 当编号为 $s$ 的书上面没有书的时候，不会对它进行 `Insert s -1` 操作。\n- 当编号为 $s$ 的书下面没有书的时候，不会对它进行 `Insert s 1` 操作。", "locale": "zh-CN"}}}
{"pid": "P2597", "type": "P", "difficulty": 6, "samples": [["5\n0\n1 0\n1 0\n2 3 0\n2 0\n", "4\n1\n0\n0\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "倍增", "各省省选", "浙江", "O2优化", "拓扑排序", "最近公共祖先 LCA"], "title": "[ZJOI2012] 灾难", "background": "阿米巴是小强的好朋友。\n\n阿米巴和小强在草原上捉蚂蚱。小强突然想，如果蚂蚱被他们捉灭绝了，那么吃蚂蚱的小鸟就会饿死，而捕食小鸟的猛禽也会跟着灭绝，从而引发一系列的生态灾难。\n\n学过生物的阿米巴告诉小强，草原是一个极其稳定的生态系统。如果蚂蚱灭绝了，小鸟照样可以吃别的虫子，所以一个物种的灭绝并不一定会引发重大的灾难。", "description": "我们现在从专业一点的角度来看这个问题。我们用一种叫做食物网的有向图来描述生物之间的关系：\n\n- 一个食物网有 $n$ 个点，代表 $n$ 种生物，生物从 $1$ 到 $n$ 编号。\n- 如果生物 $x$ 可以吃生物 $y$，那么从 $y$ 向 $x$ 连一个有向边。\n- 这个图没有环。\n- 图中有一些点没有连出边，这些点代表的生物都是生产者，可以通过光合作用来生存。\n- 而有连出边的点代表的都是消费者，它们必须通过吃其他生物来生存。\n- 如果某个消费者的所有食物都灭绝了，它会跟着灭绝。\n\n我们定义一个生物在食物网中的“灾难值”为，如果它突然灭绝，那么会跟着一起灭绝的生物的种数。\n\n举个例子：在一个草场上，生物之间的关系如下\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oiw4lh97.png)\n\n如果小强和阿米巴把草原上所有的羊都给吓死了，那么狼会因为没有食物而灭绝，而小强和阿米巴可以通过吃牛、牛可以通过吃草来生存下去。所以，羊的灾难值是 $1$。但是，如果草突然灭绝，那么整个草原上的 $5$ 种生物都无法幸免，所以，草的灾难值是 $4$。\n\n给定一个食物网，你要求出每个生物的灾难值。", "inputFormat": "第一行有一个整数，表示食物网的结点个数 $n$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行若干个互不相同的整数，第 $(i + 1)$ 行的整数 $a_{i, j}$ 表示编号为 $i$ 的生物可以吃编号为 $a_{i, j}$ 的生物。每行结尾有一个整数 $0$ 表示本行结束。", "outputFormat": "输出 $n$ 行，每行一个整数，第 $i$ 行输出编号为 $i$ 的生物的灾难值。", "hint": "### 样例 1 解释\n\n样例输入描述了题目描述中举的例子。\n\n### 数据规模与约定\n\n- 对于 $50\\%$ 的数据，保证 $n \\leq 10^4$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 65534$，$1 \\leq a_{i, j} \\leq n$，输入的文件大小不超过 1 MB，且图上不存在环。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2012] Disaster", "background": "Amiba is Xiaoqiang’s good friend.\n\nAmiba and Xiaoqiang are catching grasshoppers on the prairie. Xiaoqiang suddenly thinks that if grasshoppers were caught to extinction, then the birds that eat grasshoppers would starve, and the raptors that prey on those birds would also go extinct, triggering a chain of ecological disasters.\n\nAmiba, who has studied biology, tells Xiaoqiang that the prairie is an extremely stable ecosystem. If grasshoppers go extinct, birds can still eat other insects, so the extinction of one species does not necessarily cause a major disaster.", "description": "Let’s look at this problem from a more professional perspective. We use a directed graph called a food web to describe the relationships between species:\n\n- A food web has $n$ vertices, representing $n$ species, numbered from $1$ to $n$.\n- If species $x$ can eat species $y$, then draw a directed edge from $y$ to $x$.\n- The graph has no cycles.\n- Some vertices have no outgoing edges; these are producers that can survive via photosynthesis.\n- Vertices with outgoing edges are consumers; they must survive by eating other species.\n- If all the foods of a consumer go extinct, it will go extinct as well.\n\nWe define the “disaster value” of a species in the food web as the number of species that would go extinct along with it if it suddenly went extinct.\n\nFor example: on a grassland, the relationships between species are as follows\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oiw4lh97.png)\n\nIf Xiaoqiang and Amiba scare all the sheep to death, then the wolves will go extinct due to lack of food, while Xiaoqiang and Amiba can survive by eating cows, and cows can survive by eating grass. Thus, the disaster value of sheep is $1$. However, if the grass suddenly went extinct, then all $5$ species on the grassland would be affected, so the disaster value of grass is $4$.\n\nGiven a food web, you are required to compute the disaster value for each species.", "inputFormat": "The first line contains an integer representing the number of vertices $n$ in the food web.\n\nFrom the $2$-nd to the $(n + 1)$-st line, each line contains several distinct integers. The $(i + 1)$-st line lists integers $a_{i, j}$ indicating that species $i$ can eat species $a_{i, j}$. Each line ends with an integer $0$ marking the end of that line.", "outputFormat": "Output $n$ lines, one integer per line. On the $i$-th line, output the disaster value of species $i$.", "hint": "### Sample 1 Explanation\n\nThe sample input describes the example in the problem statement.\n\n### Constraints\n\n- For $50\\%$ of the testdata, it is guaranteed that $n \\leq 10^4$.\n- For $100\\%$ of the testdata, it is guaranteed that $1 \\leq n \\leq 65534$, $1 \\leq a_{i, j} \\leq n$, the input file size does not exceed $1$ MB, and the graph has no cycles.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2012] 灾难", "background": "阿米巴是小强的好朋友。\n\n阿米巴和小强在草原上捉蚂蚱。小强突然想，如果蚂蚱被他们捉灭绝了，那么吃蚂蚱的小鸟就会饿死，而捕食小鸟的猛禽也会跟着灭绝，从而引发一系列的生态灾难。\n\n学过生物的阿米巴告诉小强，草原是一个极其稳定的生态系统。如果蚂蚱灭绝了，小鸟照样可以吃别的虫子，所以一个物种的灭绝并不一定会引发重大的灾难。", "description": "我们现在从专业一点的角度来看这个问题。我们用一种叫做食物网的有向图来描述生物之间的关系：\n\n- 一个食物网有 $n$ 个点，代表 $n$ 种生物，生物从 $1$ 到 $n$ 编号。\n- 如果生物 $x$ 可以吃生物 $y$，那么从 $y$ 向 $x$ 连一个有向边。\n- 这个图没有环。\n- 图中有一些点没有连出边，这些点代表的生物都是生产者，可以通过光合作用来生存。\n- 而有连出边的点代表的都是消费者，它们必须通过吃其他生物来生存。\n- 如果某个消费者的所有食物都灭绝了，它会跟着灭绝。\n\n我们定义一个生物在食物网中的“灾难值”为，如果它突然灭绝，那么会跟着一起灭绝的生物的种数。\n\n举个例子：在一个草场上，生物之间的关系如下\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oiw4lh97.png)\n\n如果小强和阿米巴把草原上所有的羊都给吓死了，那么狼会因为没有食物而灭绝，而小强和阿米巴可以通过吃牛、牛可以通过吃草来生存下去。所以，羊的灾难值是 $1$。但是，如果草突然灭绝，那么整个草原上的 $5$ 种生物都无法幸免，所以，草的灾难值是 $4$。\n\n给定一个食物网，你要求出每个生物的灾难值。", "inputFormat": "第一行有一个整数，表示食物网的结点个数 $n$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行若干个互不相同的整数，第 $(i + 1)$ 行的整数 $a_{i, j}$ 表示编号为 $i$ 的生物可以吃编号为 $a_{i, j}$ 的生物。每行结尾有一个整数 $0$ 表示本行结束。", "outputFormat": "输出 $n$ 行，每行一个整数，第 $i$ 行输出编号为 $i$ 的生物的灾难值。", "hint": "### 样例 1 解释\n\n样例输入描述了题目描述中举的例子。\n\n### 数据规模与约定\n\n- 对于 $50\\%$ 的数据，保证 $n \\leq 10^4$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 65534$，$1 \\leq a_{i, j} \\leq n$，输入的文件大小不超过 1 MB，且图上不存在环。", "locale": "zh-CN"}}}
