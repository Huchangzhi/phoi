{"pid": "P10066", "type": "P", "difficulty": 5, "samples": [["7 4\n3 2 2 2", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "CCO（加拿大）", "图论建模"], "title": "[CCO 2023] Binaria", "background": "", "description": "你被廉价通信组织（CCO）雇佣来研究一项突破性的通信技术：子消息和（SMS）。这个革命性的想法是这样的。\n\n给定一个长度为 $N$ 的二进制字符串和一个满足 $K \\leq N$ 的正整数 $K$，该字符串的 SMS 由 $N-K+1$ 个整数组成。序列中的第一个数是前 $K$ 位的和，第二个数是第 $2$ 位到第 $K+1$ 位的和，依此类推，最后一个数是第 $N-K+1$ 位到第 $N$ 位的和。\n\n例如，如果 $K=4$，那么二进制字符串 $110010$ 的 SMS 是 $2,2,1$。这是因为 $1+1+0+0=2,1+0+0+1=2$，以及 $0+0+1+0=1$。\n\n由于你是一个新手，你的工作不是从给定的 SMS 中找到原始的二进制字符串，而是找到可能形成这个 SMS 的二进制字符串的数量。", "inputFormat": "第一行包含两个用空格分隔的整数 $N$ 和 $K$。\n\n第二行包含 $N-K+1$ 个用空格分隔的整数，保证它至少是一个二进制字符串的 SMS。", "outputFormat": "输出 $T$ 对 $10^{6}+3$ 取模的结果，其中 $T$ 是等于与给定 SMS 对应的可能的二进制字符串的总数的正整数。", "hint": "长度为 $7$ 的可能的字符串有 $1011001$，$1101010$ 和 $1110011$。\n\n对于所有的数据，有 $1\\leq N\\leq 10^6$，$1 \\leq K \\leq N$。\n\n\n| 子任务编号 |\t分值\t| $N$ 的范围\t| $K$ 的范围 |\n| :-: |  :-: |  :-: |  :-: |\n|1\t|12\t|$1 \\leq N \\leq 10$|\t$K \\leq 3$|\n|2\t|12\t| $1 \\leq N \\leq 10$|无 |\n|3\t|16\t|$1 \\leq N \\leq 1000$\t|$K \\leq 10$|\n|4\t|16\t|$1 \\leq N \\leq 10^{6}$|\t$K \\leq 20$|\n|5\t|16\t| $1 \\leq N \\leq 10^{6}$| $K\\leq 3000$|\n|6\t|28\t|$1 \\leq N \\leq 10^{6}$|无|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CCO 2023] Binaria", "background": "", "description": "你被廉价通信组织（CCO）雇佣来研究一项突破性的通信技术：子消息和（SMS）。这个革命性的想法是这样的。\n\n给定一个长度为 $N$ 的二进制字符串和一个满足 $K \\leq N$ 的正整数 $K$，该字符串的 SMS 由 $N-K+1$ 个整数组成。序列中的第一个数是前 $K$ 位的和，第二个数是第 $2$ 位到第 $K+1$ 位的和，依此类推，最后一个数是第 $N-K+1$ 位到第 $N$ 位的和。\n\n例如，如果 $K=4$，那么二进制字符串 $110010$ 的 SMS 是 $2,2,1$。这是因为 $1+1+0+0=2,1+0+0+1=2$，以及 $0+0+1+0=1$。\n\n由于你是一个新手，你的工作不是从给定的 SMS 中找到原始的二进制字符串，而是找到可能形成这个 SMS 的二进制字符串的数量。", "inputFormat": "第一行包含两个用空格分隔的整数 $N$ 和 $K$。\n\n第二行包含 $N-K+1$ 个用空格分隔的整数，保证它至少是一个二进制字符串的 SMS。", "outputFormat": "输出 $T$ 对 $10^{6}+3$ 取模的结果，其中 $T$ 是等于与给定 SMS 对应的可能的二进制字符串的总数的正整数。", "hint": "长度为 $7$ 的可能的字符串有 $1011001$，$1101010$ 和 $1110011$。\n\n对于所有的数据，有 $1\\leq N\\leq 10^6$，$1 \\leq K \\leq N$。\n\n\n| 子任务编号 |\t分值\t| $N$ 的范围\t| $K$ 的范围 |\n| :-: |  :-: |  :-: |  :-: |\n|1\t|12\t|$1 \\leq N \\leq 10$|\t$K \\leq 3$|\n|2\t|12\t| $1 \\leq N \\leq 10$|无 |\n|3\t|16\t|$1 \\leq N \\leq 1000$\t|$K \\leq 10$|\n|4\t|16\t|$1 \\leq N \\leq 10^{6}$|\t$K \\leq 20$|\n|5\t|16\t| $1 \\leq N \\leq 10^{6}$| $K\\leq 3000$|\n|6\t|28\t|$1 \\leq N \\leq 10^{6}$|无|", "locale": "zh-CN"}}}
{"pid": "P10067", "type": "P", "difficulty": 5, "samples": [["8\n3 2 4 5 4 1 2 1", "14"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "2023", "CCO（加拿大）"], "title": "[CCO 2023] Real Mountains", "background": "", "description": "在你的帮助下，Rebecca 的风景照现在登上了她的杂志的最新一期的封面。然而，似乎有些读者对这张照片还不满意。特别是，他们似乎认为照片中的山是假的！\n\n为了简单起见，我们可以把这张照片描述为一个由 $N$ 列像素组成的序列。在第 $i$ 列，从底部开始的前 $h_{i}$ 个像素是山。她的读者只有在照片中包含一个山峰时，才会相信这是一座真正的山。也就是说，如果存在某个下标 $p$，满足 $1 \\leq p \\leq N$，使得 $h_{1} \\leq h_{2} \\leq \\cdots \\leq h_{p} \\geq \\cdots \\geq h_{N-1} \\geq h_{N}$。\n\n幸运的是，Rebecca 还可以付钱给她的编辑修改照片并重新印刷杂志。不过，她的倒霉的是，编辑们对他们的工作有一个非常奇怪的定价方案。Rebecca 唯一能编辑照片的方法是给她的编辑发送包含三个整数 $(i, j, k)$ 的电子邮件，满足 $1 \\leq i<j<k \\leq N$ 且 $h_{i}>h_{j}<h_{k}$。编辑们会在第 $j$ 列添加一个额外的山的像素（即 $h_{j}$ 增加 $1$），费用是 $h_{i}+h_{j}+h_{k}$。注意 $h_{j}$ 的变化可能会影响未来编辑的费用。\n\n为了取悦她的读者，Rebecca 想要编辑照片，让他们相信这里有一座真正的山。你能告诉她需要花费的最小费用吗？", "inputFormat": "第一行包含一个整数 $N$。\n\n第二行包含 $N$ 个用空格分隔的整数，表示 $h_{1}, h_{2}, \\ldots, h_{N}$。", "outputFormat": "输出 $T$ 对 $10^{6}+3$ 取模的结果，其中 $T$ 是 Rebecca 为了取悦她的读者而需要花费的最小费用。", "hint": "Rebecca 可以发送两封电子邮件，第一封包含三个整数 $(2,6,7)$，第二封包含三个整数 $(1,2,5)$。第一封电子邮件花费 $5$，使 $h_{6}$ 增加 $1$，而第二封电子邮件花费 $9$，使 $h_{2}$ 增加 $1$。\n\n最终照片中的 $h_{i}$ 值将是 $[3,3,4,5,4,2,2,1]$。\n\n对于所有的数据，有 $3\\leq N \\leq 10^6$，$1 \\leq h_{i} \\leq 10^{9}$。\n\n| 子任务编号|\t分值\t|$N$ 的范围\t|$h_{i}$ 的范围和限制|\n| :-:| :-:| :-:| :-:|\n|1|\t12|\t$ N \\leq 5000$\t|$1 \\leq h_{i} \\leq 100, \\exists p \\in [1,N], h_{1} \\geq h_{2} \\geq \\cdots \\geq h_{p} \\leq \\cdots \\leq h_{N-1} \\leq h_{N}$|\n|2|\t12\t|\t$ N \\leq 5000$\t|$1 \\leq h_{i} \\leq 100$|\n|3|\t12\t|\t$ N \\leq 5000$\t|$1 \\leq h_{i} \\leq 10^{6}$|\n|4|\t12\t|\t$ N \\leq 5000$\t|$1 \\leq h_{i} \\leq 10^{9}$|\n|5|\t16\t|$N \\leq 10^{6}$|\t$1 \\leq h_{i} \\leq 100$|\n|6|\t20\t|$ N \\leq 10^{6}$|$1 \\leq h_{i} \\leq 10^{6}$|\n|7|\t16\t|$ N \\leq 10^{6}$|$1 \\leq h_{i} \\leq 10^{9}$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CCO 2023] Real Mountains", "background": "", "description": "在你的帮助下，Rebecca 的风景照现在登上了她的杂志的最新一期的封面。然而，似乎有些读者对这张照片还不满意。特别是，他们似乎认为照片中的山是假的！\n\n为了简单起见，我们可以把这张照片描述为一个由 $N$ 列像素组成的序列。在第 $i$ 列，从底部开始的前 $h_{i}$ 个像素是山。她的读者只有在照片中包含一个山峰时，才会相信这是一座真正的山。也就是说，如果存在某个下标 $p$，满足 $1 \\leq p \\leq N$，使得 $h_{1} \\leq h_{2} \\leq \\cdots \\leq h_{p} \\geq \\cdots \\geq h_{N-1} \\geq h_{N}$。\n\n幸运的是，Rebecca 还可以付钱给她的编辑修改照片并重新印刷杂志。不过，她的倒霉的是，编辑们对他们的工作有一个非常奇怪的定价方案。Rebecca 唯一能编辑照片的方法是给她的编辑发送包含三个整数 $(i, j, k)$ 的电子邮件，满足 $1 \\leq i<j<k \\leq N$ 且 $h_{i}>h_{j}<h_{k}$。编辑们会在第 $j$ 列添加一个额外的山的像素（即 $h_{j}$ 增加 $1$），费用是 $h_{i}+h_{j}+h_{k}$。注意 $h_{j}$ 的变化可能会影响未来编辑的费用。\n\n为了取悦她的读者，Rebecca 想要编辑照片，让他们相信这里有一座真正的山。你能告诉她需要花费的最小费用吗？", "inputFormat": "第一行包含一个整数 $N$。\n\n第二行包含 $N$ 个用空格分隔的整数，表示 $h_{1}, h_{2}, \\ldots, h_{N}$。", "outputFormat": "输出 $T$ 对 $10^{6}+3$ 取模的结果，其中 $T$ 是 Rebecca 为了取悦她的读者而需要花费的最小费用。", "hint": "Rebecca 可以发送两封电子邮件，第一封包含三个整数 $(2,6,7)$，第二封包含三个整数 $(1,2,5)$。第一封电子邮件花费 $5$，使 $h_{6}$ 增加 $1$，而第二封电子邮件花费 $9$，使 $h_{2}$ 增加 $1$。\n\n最终照片中的 $h_{i}$ 值将是 $[3,3,4,5,4,2,2,1]$。\n\n对于所有的数据，有 $3\\leq N \\leq 10^6$，$1 \\leq h_{i} \\leq 10^{9}$。\n\n| 子任务编号|\t分值\t|$N$ 的范围\t|$h_{i}$ 的范围和限制|\n| :-:| :-:| :-:| :-:|\n|1|\t12|\t$ N \\leq 5000$\t|$1 \\leq h_{i} \\leq 100, \\exists p \\in [1,N], h_{1} \\geq h_{2} \\geq \\cdots \\geq h_{p} \\leq \\cdots \\leq h_{N-1} \\leq h_{N}$|\n|2|\t12\t|\t$ N \\leq 5000$\t|$1 \\leq h_{i} \\leq 100$|\n|3|\t12\t|\t$ N \\leq 5000$\t|$1 \\leq h_{i} \\leq 10^{6}$|\n|4|\t12\t|\t$ N \\leq 5000$\t|$1 \\leq h_{i} \\leq 10^{9}$|\n|5|\t16\t|$N \\leq 10^{6}$|\t$1 \\leq h_{i} \\leq 100$|\n|6|\t20\t|$ N \\leq 10^{6}$|$1 \\leq h_{i} \\leq 10^{6}$|\n|7|\t16\t|$ N \\leq 10^{6}$|$1 \\leq h_{i} \\leq 10^{9}$|", "locale": "zh-CN"}}}
{"pid": "P10068", "type": "P", "difficulty": 7, "samples": [["6\n-2 7 -1 -8 2 8", "3"], ["4\n1 -1 1 -1", "-1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "CCO（加拿大）"], "title": "[CCO 2023] Line Town", "background": "", "description": "线条小镇的 $N$ 个居民排成了一条线。最初，居民们从左到右沿着线的幸福值为 $h_{1}, h_{2}, \\ldots, h_{N}$。\n\n你是线条小镇的镇长，你正在实施你的名为「社区、糖果和组织」（CCO）的计划。因此，你拥有了交换居民位置的权力。在一次交换中，你可以让两个相邻的居民交换他们在线中的位置。但是，这次交换会导致两个居民的幸福值取反。\n\n你想要知道是否能进行一些交换，使得居民的幸福值从左到右按非递减的顺序排列。如果可能，需要的最少交换次数是多少。", "inputFormat": "第一行包含一个整数 $N$。\n\n第二行包含 $N$ 个整数 $h_{1}, \\ldots, h_{N}$，表示从左到右的居民的幸福值。", "outputFormat": "输出一行一个整数，表示最少的交换次数，如果任务不可能完成输出 $-1$。", "hint": "**样例解释 1**\n\n可以进行 3 次交换，如下所示：\n\n- 交换第 2 和第 3 个居民，幸福值变成了 $[-2,1,-7,-8,2,8]$。\n- 交换第 4 和第 5 个居民，幸福值变成了 $[-2,1,-7,-2,8,8]$。\n- 交换第 3 和第 4 个居民，幸福值变成了 $[-2,1,2,7,8,8]$。\n\n居民们现在按照要求的幸福值非递减的顺序排列了。没有比 3 次更少的交换次数可以得到非递减的排列。\n\n**样例解释 2**\n\n没有一系列的交换可以使居民按照幸福值非递减的顺序排列。\n\n对于所有的数据，有 $1\\leq N\\leq 5\\times 10^5，-10^{9} \\leq h_{i} \\leq 10^{9}$。\n\n- 额外限制 A：对于所有的 $i$，$\\left|h_{i}\\right| = 1$。\n- 额外限制 B：对于所有的 $i$，$\\left|h_{i}\\right| \\leq 1$。\n- 额外限制 C：对于所有的 $i \\neq j$，$\\left|h_{i}\\right| \\neq\\left|h_{j}\\right|$。\n\n子任务编号|\t分值|\t$N$ 的范围\t|额外限制|\n|:-:|:-:|:-:|:-:|\n| 1\t|12|\t$1 \\leq N \\leq 2000$ |A|\n|2\t|12\t|$1 \\leq N \\leq 5\\times 10^5$|A|\n|3\t|12|\t$1 \\leq N \\leq 2000$|B\t|\n|4\t|16\t|$1 \\leq N \\leq 5\\times 10^5$|B|\n|5\t|16\t|$1 \\leq N \\leq 2000$|\tC|\n|6\t|12\t|$1 \\leq N \\leq 5\\times 10^5$|C |\n|7|8\t|$1 \\leq N \\leq 2000$ |\t|\n|8|12\t|$1 \\leq N \\leq 5\\times 10^5$ |\t|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CCO 2023] Line Town", "background": "", "description": "线条小镇的 $N$ 个居民排成了一条线。最初，居民们从左到右沿着线的幸福值为 $h_{1}, h_{2}, \\ldots, h_{N}$。\n\n你是线条小镇的镇长，你正在实施你的名为「社区、糖果和组织」（CCO）的计划。因此，你拥有了交换居民位置的权力。在一次交换中，你可以让两个相邻的居民交换他们在线中的位置。但是，这次交换会导致两个居民的幸福值取反。\n\n你想要知道是否能进行一些交换，使得居民的幸福值从左到右按非递减的顺序排列。如果可能，需要的最少交换次数是多少。", "inputFormat": "第一行包含一个整数 $N$。\n\n第二行包含 $N$ 个整数 $h_{1}, \\ldots, h_{N}$，表示从左到右的居民的幸福值。", "outputFormat": "输出一行一个整数，表示最少的交换次数，如果任务不可能完成输出 $-1$。", "hint": "**样例解释 1**\n\n可以进行 3 次交换，如下所示：\n\n- 交换第 2 和第 3 个居民，幸福值变成了 $[-2,1,-7,-8,2,8]$。\n- 交换第 4 和第 5 个居民，幸福值变成了 $[-2,1,-7,-2,8,8]$。\n- 交换第 3 和第 4 个居民，幸福值变成了 $[-2,1,2,7,8,8]$。\n\n居民们现在按照要求的幸福值非递减的顺序排列了。没有比 3 次更少的交换次数可以得到非递减的排列。\n\n**样例解释 2**\n\n没有一系列的交换可以使居民按照幸福值非递减的顺序排列。\n\n对于所有的数据，有 $1\\leq N\\leq 5\\times 10^5，-10^{9} \\leq h_{i} \\leq 10^{9}$。\n\n- 额外限制 A：对于所有的 $i$，$\\left|h_{i}\\right| = 1$。\n- 额外限制 B：对于所有的 $i$，$\\left|h_{i}\\right| \\leq 1$。\n- 额外限制 C：对于所有的 $i \\neq j$，$\\left|h_{i}\\right| \\neq\\left|h_{j}\\right|$。\n\n子任务编号|\t分值|\t$N$ 的范围\t|额外限制|\n|:-:|:-:|:-:|:-:|\n| 1\t|12|\t$1 \\leq N \\leq 2000$ |A|\n|2\t|12\t|$1 \\leq N \\leq 5\\times 10^5$|A|\n|3\t|12|\t$1 \\leq N \\leq 2000$|B\t|\n|4\t|16\t|$1 \\leq N \\leq 5\\times 10^5$|B|\n|5\t|16\t|$1 \\leq N \\leq 2000$|\tC|\n|6\t|12\t|$1 \\leq N \\leq 5\\times 10^5$|C |\n|7|8\t|$1 \\leq N \\leq 2000$ |\t|\n|8|12\t|$1 \\leq N \\leq 5\\times 10^5$ |\t|", "locale": "zh-CN"}}}
{"pid": "P10069", "type": "P", "difficulty": 5, "samples": [["100110\n10", "2"], ["000\n00", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "2023", "CCO（加拿大）", "构造", "分类讨论"], "title": "[CCO 2023] Flip it and Stick it", "background": "", "description": "Finn 正在玩一款叫做「Flip it and Stick it」的游戏，简称为 FiSi。FiSi 是一款单人游戏，玩法是在两个由 0 和 1 组成的字符串 $S$ 和 $T$ 上进行操作。Finn 可以进行以下形式的操作：\n\n选择 $S$ 的一个子串并将其翻转，然后将字符串的各部分按照原来的顺序粘贴在一起，形成新的字符串 $S$。\n例如，Finn 可以取字符串 $S=101100$，取从第 2 位开始的子串 $011$（字符串的编号是从 $1$ 开始的），并在一次操作中创建字符串 $S=111000$。\n\n如果 $S$ 不包含 $T$ 作为子串，Finn 就赢得了游戏。你的任务是帮助 Finn 确定赢得游戏所需的最短操作序列的长度，或者告诉他游戏无法获胜。", "inputFormat": "第一行一个字符串 $S$。\n\n第二行一个字符串 $T$。", "outputFormat": "输出一行一个整数，表示如果能赢得游戏所需的最少操作次数，否则输出 $-1$。", "hint": "**样例解释 1**\n\nFinn 从字符串 $100110$ 开始。他无法通过一次操作后使得 $10$ 不为子串，但他可以在两次操作后做到。\n\n例如，他的第一次操作可以是翻转从第 4 位到第 6 位的子串（$110$），得到 $100011$。然后，他的第二次操作可以是翻转从第 1 位到第 4 位的子串（$1000$），得到 $000111$，它不包含 $10$ 作为子串。\n\n**样例解释 2**\n\n无论 Finn 进行多少次操作，字符串 $T$ 总会是 $S$ 的子串。\n\n对于所有的数据，有 $1 \\leq|S| \\leq 2\\times 10^5$，$1 \\leq|T| \\leq 3$。\n\n设 $|T|=l$。\n\n| 子任务编号 |\t分值\t| $l$ 的限制 |\n| :-:|:-:|:-:|\n|1|\t4|\t$l=1$|\n|2|\t12|\t$l=2, T_{1} \\neq T_{2}$|\n|3|\t16|\t$l=2$|\n|4|\t20|\t$l=3, T_{1} \\neq T_{3}$|\n|5|\t20|\t$l=3,T_{1} \\neq T_{2}$|\n|6|\t28|\t$l=3$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CCO 2023] Flip it and Stick it", "background": "", "description": "Finn 正在玩一款叫做「Flip it and Stick it」的游戏，简称为 FiSi。FiSi 是一款单人游戏，玩法是在两个由 0 和 1 组成的字符串 $S$ 和 $T$ 上进行操作。Finn 可以进行以下形式的操作：\n\n选择 $S$ 的一个子串并将其翻转，然后将字符串的各部分按照原来的顺序粘贴在一起，形成新的字符串 $S$。\n例如，Finn 可以取字符串 $S=101100$，取从第 2 位开始的子串 $011$（字符串的编号是从 $1$ 开始的），并在一次操作中创建字符串 $S=111000$。\n\n如果 $S$ 不包含 $T$ 作为子串，Finn 就赢得了游戏。你的任务是帮助 Finn 确定赢得游戏所需的最短操作序列的长度，或者告诉他游戏无法获胜。", "inputFormat": "第一行一个字符串 $S$。\n\n第二行一个字符串 $T$。", "outputFormat": "输出一行一个整数，表示如果能赢得游戏所需的最少操作次数，否则输出 $-1$。", "hint": "**样例解释 1**\n\nFinn 从字符串 $100110$ 开始。他无法通过一次操作后使得 $10$ 不为子串，但他可以在两次操作后做到。\n\n例如，他的第一次操作可以是翻转从第 4 位到第 6 位的子串（$110$），得到 $100011$。然后，他的第二次操作可以是翻转从第 1 位到第 4 位的子串（$1000$），得到 $000111$，它不包含 $10$ 作为子串。\n\n**样例解释 2**\n\n无论 Finn 进行多少次操作，字符串 $T$ 总会是 $S$ 的子串。\n\n对于所有的数据，有 $1 \\leq|S| \\leq 2\\times 10^5$，$1 \\leq|T| \\leq 3$。\n\n设 $|T|=l$。\n\n| 子任务编号 |\t分值\t| $l$ 的限制 |\n| :-:|:-:|:-:|\n|1|\t4|\t$l=1$|\n|2|\t12|\t$l=2, T_{1} \\neq T_{2}$|\n|3|\t16|\t$l=2$|\n|4|\t20|\t$l=3, T_{1} \\neq T_{3}$|\n|5|\t20|\t$l=3,T_{1} \\neq T_{2}$|\n|6|\t28|\t$l=3$|", "locale": "zh-CN"}}}
{"pid": "P10070", "type": "P", "difficulty": 7, "samples": [["4 1\n1 2\n1 3\n2 4\n3 1 4 1", "7\n2\n1 3"], ["5 2\n1 2\n1 3\n2 4\n2 5\n3 1 4 1 5", "14\n5\n1 4 5 2 3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "Special Judge", "CCO（加拿大）"], "title": "[CCO 2023] Travelling Trader", "background": "", "description": "一个商人想要在城市之间做生意，把货物从一个城市运到另一个城市来获得利润。有 $N$ 个城市，用 $1, \\ldots, N$ 表示。有 $N-1$ 条道路，每条道路连接两个城市，每条道路需要一天的时间来穿越。使用这些道路，可以从任何一个城市到达另一个城市。\n\n如果商人当前在第 $i$ 个城市并选择做生意，那么商人可以获得 $p_{i}$ 的利润，但是对于每个城市这个利润只能获得一次。商人从第 $1$ 个城市开始做生意，沿着道路访问城市，以最大化他们的总利润。但是如果商人太久没有获得利润，商人的老板会变得不高兴。具体地说，一旦商人连续超过 K 天没有获得利润，老板就会解雇商人。注意：无论商人是否在其中一个城市做生意，商人在相邻的城市之间移动都需要一天的时间。你需要求出商人可以获得的最大利润和能够获得这个利润的路线。\n\n求出商人能得到的可能的最大总利润，并构造一种方案。", "inputFormat": "第一行包含两个用空格分隔的整数 $N$ 和 $K$。\n\n接下来的 $N-1$ 行，每行包含两个用空格分隔的整数 $u_{i}$ 和 $v_{i}$，表示一条道路。\n\n最后一行包含 $N$ 个整数 $p_{1}, \\ldots, p_{N}$，表示选择在相应的城市做生意所给的利润。", "outputFormat": "第一行输出一个整数，表示可能的最大总利润。\n\n第二行输出一个整数 $M\\ (1 \\leq M \\leq N)$，表示在最优路线上商人做生意的城市的数量。\n\n第三行，输出 $M$ 个用空格分隔的整数 $x_{1}, \\ldots, x_{M}$，表示商人按顺序在最优路线上做生意的城市，从 $x_1=1$ 开始。\n\n如果有多个正确方案，你可以输出任何一个。", "hint": "**样例解释 1**\n\n在第 $1$ 天，商人从第 $1$ 个城市开始做生意，获得 $3$ 的利润。\n\n在第 $2$ 天，商人移动到第 $3$ 个城市，并在那里做生意，获得 $4$ 的利润。\n\n在第 $3$ 天，商人无法在被解雇之前到达另一个他们没有做过生意的城市，所以他们的总利润是 $7$。\n\n**样例解释 2**\n\n商人按照 $1,2,4,2,5,2,1,3$ 的顺序访问它们，可以在每个城市获得利润。\n\n注意，商人为了确保他们不会超过 $2$ 天没有获得利润，推迟了在第 $2$ 个城市做生意的时间。\n\n对于所有数据，有 $2 \\leq N \\leq 2\\times 10^5，1\\leq K\\le 3，1 \\leq u_{i}, v_{i} \\leq N，u_{i} \\neq v_{i}，1 \\leq p_{i} \\leq 10^{9}$。\n\n|子任务编号\t|分值|\t$N$ 的范围\t|$K$ 的范围|\n|:-:|:-:|:-:|:-:|\n|1\t|8\t|$2 \\leq N \\leq 2\\times 10^5$|\t$K=1$|\n|2\t|28\t|$2 \\leq N \\leq 200$|\t$K=2$|\n|3\t|12\t|$2 \\leq N \\leq 2000$|$K=2$|\n|4\t|16\t|$2 \\leq N \\leq 2\\times 10^5$|$K=2$|\n|5\t|16\t|$2 \\leq N \\leq 2000$|\t$K=3$|\n|6 | 20 | $2 \\leq N \\leq 2\\times 10^5$|$K=3$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CCO 2023] Travelling Trader", "background": "", "description": "一个商人想要在城市之间做生意，把货物从一个城市运到另一个城市来获得利润。有 $N$ 个城市，用 $1, \\ldots, N$ 表示。有 $N-1$ 条道路，每条道路连接两个城市，每条道路需要一天的时间来穿越。使用这些道路，可以从任何一个城市到达另一个城市。\n\n如果商人当前在第 $i$ 个城市并选择做生意，那么商人可以获得 $p_{i}$ 的利润，但是对于每个城市这个利润只能获得一次。商人从第 $1$ 个城市开始做生意，沿着道路访问城市，以最大化他们的总利润。但是如果商人太久没有获得利润，商人的老板会变得不高兴。具体地说，一旦商人连续超过 K 天没有获得利润，老板就会解雇商人。注意：无论商人是否在其中一个城市做生意，商人在相邻的城市之间移动都需要一天的时间。你需要求出商人可以获得的最大利润和能够获得这个利润的路线。\n\n求出商人能得到的可能的最大总利润，并构造一种方案。", "inputFormat": "第一行包含两个用空格分隔的整数 $N$ 和 $K$。\n\n接下来的 $N-1$ 行，每行包含两个用空格分隔的整数 $u_{i}$ 和 $v_{i}$，表示一条道路。\n\n最后一行包含 $N$ 个整数 $p_{1}, \\ldots, p_{N}$，表示选择在相应的城市做生意所给的利润。", "outputFormat": "第一行输出一个整数，表示可能的最大总利润。\n\n第二行输出一个整数 $M\\ (1 \\leq M \\leq N)$，表示在最优路线上商人做生意的城市的数量。\n\n第三行，输出 $M$ 个用空格分隔的整数 $x_{1}, \\ldots, x_{M}$，表示商人按顺序在最优路线上做生意的城市，从 $x_1=1$ 开始。\n\n如果有多个正确方案，你可以输出任何一个。", "hint": "**样例解释 1**\n\n在第 $1$ 天，商人从第 $1$ 个城市开始做生意，获得 $3$ 的利润。\n\n在第 $2$ 天，商人移动到第 $3$ 个城市，并在那里做生意，获得 $4$ 的利润。\n\n在第 $3$ 天，商人无法在被解雇之前到达另一个他们没有做过生意的城市，所以他们的总利润是 $7$。\n\n**样例解释 2**\n\n商人按照 $1,2,4,2,5,2,1,3$ 的顺序访问它们，可以在每个城市获得利润。\n\n注意，商人为了确保他们不会超过 $2$ 天没有获得利润，推迟了在第 $2$ 个城市做生意的时间。\n\n对于所有数据，有 $2 \\leq N \\leq 2\\times 10^5，1\\leq K\\le 3，1 \\leq u_{i}, v_{i} \\leq N，u_{i} \\neq v_{i}，1 \\leq p_{i} \\leq 10^{9}$。\n\n|子任务编号\t|分值|\t$N$ 的范围\t|$K$ 的范围|\n|:-:|:-:|:-:|:-:|\n|1\t|8\t|$2 \\leq N \\leq 2\\times 10^5$|\t$K=1$|\n|2\t|28\t|$2 \\leq N \\leq 200$|\t$K=2$|\n|3\t|12\t|$2 \\leq N \\leq 2000$|$K=2$|\n|4\t|16\t|$2 \\leq N \\leq 2\\times 10^5$|$K=2$|\n|5\t|16\t|$2 \\leq N \\leq 2000$|\t$K=3$|\n|6 | 20 | $2 \\leq N \\leq 2\\times 10^5$|$K=3$|", "locale": "zh-CN"}}}
{"pid": "P10071", "type": "P", "difficulty": 6, "samples": [["4 3\n3 1 4 1\n3 -3\n1 6\n2 1", "1\n3\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "CCO（加拿大）"], "title": "[CCO 2023] Triangle Collection", "background": "", "description": "Alice 有一些棍子。一开始，对于每个 $l=1, \\ldots, N$，她有 $c_{l}$ 根长度为 $l$ 的棍子。\n\nAlice 想用她的棍子做一些等腰三角形。一个等腰三角形由两根长度为 $l$ 的棍子和一根长度在 $1$ 和 $2 l-1$ 之间的棍子组成。注意，三根棍子的长度必须严格满足三角形不等式，等边三角形也是满足条件的。每根棍子最多只能在一个三角形里使用一次。Alice 想知道用她的棍子最多能做出多少等腰三角形。\n\n有 $Q$ 个事件改变了她拥有的棍子的数量。第 $i$ 个事件包含两个整数 $l_{i}$ 和 $d_{i}$，表示长度为 $l_{i}$ 的棍子的数量变化了 $d_{i}$。注意，$d_{i}$ 可以任意整数，但是 Alice 永远不会有负数或者超过 $10^{9}$ 根长度为 $l$ 的棍子。\n\n你需要求出在每个事件之后，Alice 用她的棍子最多能做出多少等腰三角形。", "inputFormat": "第一行包含两个用空格分隔的整数 $N$ 和 $Q$。\n\n第二行包含 $N$ 个用空格分隔的整数 $c_{1}, c_{2}, \\ldots, c_{N}$，表示 Alice 的开始时拥有的棍子。\n\n接下来的 $Q$ 行，每行包含两个用空格分隔的整数 $l_{i}$ 和 $d_{i}$，表示一个事件。\n\n保证在每个事件之前和之后，对于每个 $l=1, \\ldots, N$，长度为 $l$ 的棍子的数量都在 $0$ 和 $10^{9}$ 之间。", "outputFormat": "输出 $Q$ 行，每行包含一个整数，表示每个事件之后的答案。", "hint": "在第一个事件之后，Alice 可以用长度为 $ (1,1,1)$ 的棍子做一个三角形。\n\n在第二个事件之后，Alice 可以用长度为 $(1,1,1)$ 的棍子做三个三角形。\n\n在第三个事件之后，Alice 可以用长度为 $(1,1,1)$ 的棍子做三个三角形，并用长度为 $(2,2,3)$ 的棍子做一个三角形。\n\n对于所有的数据，有 $1 \\leq N, Q \\leq 2\\times 10^5$，$0 \\leq c_{i} \\leq 10^{9}$，$1 \\leq l_{i} \\leq N$，$-10^{9} \\leq d_{i} \\leq 10^{9}$。\n\n|子任务编号|\t分值|\tN, Q 的范围|\t额外限制|\n| :-: | :-: |:-:|:-:|\n|1|\t20|\t$1 \\leq N, Q \\leq 2000$|\t在所有时刻，总共最多有 $2000$ 根棍子。|\n|2|\t20|\t$1 \\leq N, Q \\leq 2000$|没有额外的限制|\n|3|\t20|\t$1 \\leq N, Q \\leq 2\\times 10^5$|\t在所有时刻，每种长度的棍子的数量只会是 $1,2,3$ |\n|4|\t20|\t$1 \\leq N, Q \\leq 2\\times 10^5$| $d_{i}=1,-1$ |\n|5|\t20| $1 \\leq N, Q \\leq 2\\times 10^5$|没有额外的限制|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CCO 2023] Triangle Collection", "background": "", "description": "Alice 有一些棍子。一开始，对于每个 $l=1, \\ldots, N$，她有 $c_{l}$ 根长度为 $l$ 的棍子。\n\nAlice 想用她的棍子做一些等腰三角形。一个等腰三角形由两根长度为 $l$ 的棍子和一根长度在 $1$ 和 $2 l-1$ 之间的棍子组成。注意，三根棍子的长度必须严格满足三角形不等式，等边三角形也是满足条件的。每根棍子最多只能在一个三角形里使用一次。Alice 想知道用她的棍子最多能做出多少等腰三角形。\n\n有 $Q$ 个事件改变了她拥有的棍子的数量。第 $i$ 个事件包含两个整数 $l_{i}$ 和 $d_{i}$，表示长度为 $l_{i}$ 的棍子的数量变化了 $d_{i}$。注意，$d_{i}$ 可以任意整数，但是 Alice 永远不会有负数或者超过 $10^{9}$ 根长度为 $l$ 的棍子。\n\n你需要求出在每个事件之后，Alice 用她的棍子最多能做出多少等腰三角形。", "inputFormat": "第一行包含两个用空格分隔的整数 $N$ 和 $Q$。\n\n第二行包含 $N$ 个用空格分隔的整数 $c_{1}, c_{2}, \\ldots, c_{N}$，表示 Alice 的开始时拥有的棍子。\n\n接下来的 $Q$ 行，每行包含两个用空格分隔的整数 $l_{i}$ 和 $d_{i}$，表示一个事件。\n\n保证在每个事件之前和之后，对于每个 $l=1, \\ldots, N$，长度为 $l$ 的棍子的数量都在 $0$ 和 $10^{9}$ 之间。", "outputFormat": "输出 $Q$ 行，每行包含一个整数，表示每个事件之后的答案。", "hint": "在第一个事件之后，Alice 可以用长度为 $ (1,1,1)$ 的棍子做一个三角形。\n\n在第二个事件之后，Alice 可以用长度为 $(1,1,1)$ 的棍子做三个三角形。\n\n在第三个事件之后，Alice 可以用长度为 $(1,1,1)$ 的棍子做三个三角形，并用长度为 $(2,2,3)$ 的棍子做一个三角形。\n\n对于所有的数据，有 $1 \\leq N, Q \\leq 2\\times 10^5$，$0 \\leq c_{i} \\leq 10^{9}$，$1 \\leq l_{i} \\leq N$，$-10^{9} \\leq d_{i} \\leq 10^{9}$。\n\n|子任务编号|\t分值|\tN, Q 的范围|\t额外限制|\n| :-: | :-: |:-:|:-:|\n|1|\t20|\t$1 \\leq N, Q \\leq 2000$|\t在所有时刻，总共最多有 $2000$ 根棍子。|\n|2|\t20|\t$1 \\leq N, Q \\leq 2000$|没有额外的限制|\n|3|\t20|\t$1 \\leq N, Q \\leq 2\\times 10^5$|\t在所有时刻，每种长度的棍子的数量只会是 $1,2,3$ |\n|4|\t20|\t$1 \\leq N, Q \\leq 2\\times 10^5$| $d_{i}=1,-1$ |\n|5|\t20| $1 \\leq N, Q \\leq 2\\times 10^5$|没有额外的限制|", "locale": "zh-CN"}}}
{"pid": "P10072", "type": "P", "difficulty": 4, "samples": [["3 4\n2 4 4", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "广东", "O2优化"], "title": "[GDKOI2024 普及组] 刷野 I", "background": "", "description": "Zayin 是一个与怪物战斗的巫师，这次他将面临 $n$ 个站成一排的怪物，其中第 $i$ 个怪物的生命值是 $a_i$。\n\nZayin 率先使用一种攻击方式攻击，攻击过后所有血量小于等于 $0$ 的怪物死亡。在 Zayin 攻击一次后，所有存活的怪物对 Zayin 造成 $1$ 点伤害。以上步骤不断循环，直到 Zayin 击杀所有怪物为止。\n\nZayin 一共有三种攻击方式：\n\n- 普通攻击: 消耗 $0$ 点能量值，选择一只怪物并使其血量减少一点。\n\n- 天音波: 消耗 $1$ 点能量值，选择一只怪物并使其血量减少两点。\n\n- 天雷破: 消耗 $1$ 点能量值，使所有怪物血量减少一点。\n\n现在 Zayin 一共有 $m$ 点能量，现在他想知道在最优的策略下，击败 $n$ 只怪物所损失的最少血量。", "inputFormat": "输入的第一行包含两个正整数 $n, m(1 \\leq n, m \\leq 10^5)$，$n$ 表示怪物的个数，$m$ 表示 Zayin 拥有的能量值。\n\n输入的第二行包含 $n$ 个非负整数 $a_1, a_2, \\dots, a_n(1 \\leq a_i \\leq 10^9)$，$a_i$ 表示第 $i$ 只怪物的血量。", "outputFormat": "一行一个整数表示答案。", "hint": "对于 $30\\%$ 的数据，$1 \\leq n, m \\leq 5$。\n\n对于另外 $15\\%$ 的数据，$m = 0$。\n\n对于另外 $15\\%$ 的数据，所有 $a_i$ 全部相等。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^5$，$0 \\leq m \\leq 10^5$，$1 \\leq a_i \\leq 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GDKOI2024 普及组] 刷野 I", "background": "", "description": "Zayin 是一个与怪物战斗的巫师，这次他将面临 $n$ 个站成一排的怪物，其中第 $i$ 个怪物的生命值是 $a_i$。\n\nZayin 率先使用一种攻击方式攻击，攻击过后所有血量小于等于 $0$ 的怪物死亡。在 Zayin 攻击一次后，所有存活的怪物对 Zayin 造成 $1$ 点伤害。以上步骤不断循环，直到 Zayin 击杀所有怪物为止。\n\nZayin 一共有三种攻击方式：\n\n- 普通攻击: 消耗 $0$ 点能量值，选择一只怪物并使其血量减少一点。\n\n- 天音波: 消耗 $1$ 点能量值，选择一只怪物并使其血量减少两点。\n\n- 天雷破: 消耗 $1$ 点能量值，使所有怪物血量减少一点。\n\n现在 Zayin 一共有 $m$ 点能量，现在他想知道在最优的策略下，击败 $n$ 只怪物所损失的最少血量。", "inputFormat": "输入的第一行包含两个正整数 $n, m(1 \\leq n, m \\leq 10^5)$，$n$ 表示怪物的个数，$m$ 表示 Zayin 拥有的能量值。\n\n输入的第二行包含 $n$ 个非负整数 $a_1, a_2, \\dots, a_n(1 \\leq a_i \\leq 10^9)$，$a_i$ 表示第 $i$ 只怪物的血量。", "outputFormat": "一行一个整数表示答案。", "hint": "对于 $30\\%$ 的数据，$1 \\leq n, m \\leq 5$。\n\n对于另外 $15\\%$ 的数据，$m = 0$。\n\n对于另外 $15\\%$ 的数据，所有 $a_i$ 全部相等。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^5$，$0 \\leq m \\leq 10^5$，$1 \\leq a_i \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P10073", "type": "P", "difficulty": 3, "samples": [["1 10\n19 9 12 5 10 7 16 15 17 12", "25\n1 2 3 4 5 6 7 8 9 10"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "广东", "Special Judge", "O2优化"], "title": "[GDKOI2024 普及组] 刷野 II", "background": "", "description": "Zayin 是一个与怪物战斗的巫师，这次他将面临 $n$ 个站成一排的怪物，其中第 $i$ 个怪物的生命值是 $a_i$。\n\nZayin 知道许多被压制的咒语，在这场战斗中，他决定使用一个名为” 闪电连击” 的咒语来一口气击败所有的怪物。让我们看看这个咒语是如何工作的。\n\n- 首先，Zayin 选择一个怪物 $i(1 \\leq i \\leq n)$ 以及咒语的初始力量 $x$。\n- 然后这个咒语会首先击中怪物 $i$，随后对于除第一个目标怪物外，Zayin 可以选择一个没有被该咒语击中过，并且与其中一个已经被击中的怪物相邻的怪物。\n- 第一个被击中的目标怪物会受到 $x$ 的伤害，第二个目标怪物会受到 $x-1$ 的伤害，第三个受到 $x-2$ 的伤害，以此类推。不难看出，每个怪物都会被击中恰好一次。\n\n如果一个怪物受到的伤害不低于其生命值，则视为死亡。\n\nZayin 想展示他作为一个高级巫师的能力，所以他希望在只使用一次咒语就能杀死所有怪物的前提下，使用最少的初始力量 $x$。\n\n现在你需要求出所需的最少的初始力量，并给出一个方案。如果有多个不同的方案，只需要给出任意一个就可以了。", "inputFormat": "第一行包含两个整数 $d, n$，表示测试点编号和怪物数。\n\n接下来一行 $n$ 个整数，第 $i$ 个整数 $a_i$ 表示第 $i$ 个怪物的血量。", "outputFormat": "第一行输出一个整数 $x$，表示最少的初始力量。\n\n接下来第二行输出 $n$ 个用空格分割的下标 $monster_i(1 \\leq i \\leq n)$，其中 $monster_i$ 表示第 $i$ 个击中的目标怪物。", "hint": "对于所有测试数据，保证 $1 \\leq n \\leq 5 \\times 10^6$\n，$1 \\leq a_i \\leq 10^9$。\n\n| 测试点编号 | $n\\leq$ |\n| :----------: | :----------: |\n| $1$ | $10$ |\n| $2$ | $20$ |\n| $3$ | $500$ |\n| $4$ | $5000$ |\n| $5$ | $5\\times 10^4$ |\n| $6,7$ | $5\\times 10^5$ |\n| $8,9,10$ | $5\\times 10^6$ |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GDKOI2024 普及组] 刷野 II", "background": "", "description": "Zayin 是一个与怪物战斗的巫师，这次他将面临 $n$ 个站成一排的怪物，其中第 $i$ 个怪物的生命值是 $a_i$。\n\nZayin 知道许多被压制的咒语，在这场战斗中，他决定使用一个名为” 闪电连击” 的咒语来一口气击败所有的怪物。让我们看看这个咒语是如何工作的。\n\n- 首先，Zayin 选择一个怪物 $i(1 \\leq i \\leq n)$ 以及咒语的初始力量 $x$。\n- 然后这个咒语会首先击中怪物 $i$，随后对于除第一个目标怪物外，Zayin 可以选择一个没有被该咒语击中过，并且与其中一个已经被击中的怪物相邻的怪物。\n- 第一个被击中的目标怪物会受到 $x$ 的伤害，第二个目标怪物会受到 $x-1$ 的伤害，第三个受到 $x-2$ 的伤害，以此类推。不难看出，每个怪物都会被击中恰好一次。\n\n如果一个怪物受到的伤害不低于其生命值，则视为死亡。\n\nZayin 想展示他作为一个高级巫师的能力，所以他希望在只使用一次咒语就能杀死所有怪物的前提下，使用最少的初始力量 $x$。\n\n现在你需要求出所需的最少的初始力量，并给出一个方案。如果有多个不同的方案，只需要给出任意一个就可以了。", "inputFormat": "第一行包含两个整数 $d, n$，表示测试点编号和怪物数。\n\n接下来一行 $n$ 个整数，第 $i$ 个整数 $a_i$ 表示第 $i$ 个怪物的血量。", "outputFormat": "第一行输出一个整数 $x$，表示最少的初始力量。\n\n接下来第二行输出 $n$ 个用空格分割的下标 $monster_i(1 \\leq i \\leq n)$，其中 $monster_i$ 表示第 $i$ 个击中的目标怪物。", "hint": "对于所有测试数据，保证 $1 \\leq n \\leq 5 \\times 10^6$\n，$1 \\leq a_i \\leq 10^9$。\n\n| 测试点编号 | $n\\leq$ |\n| :----------: | :----------: |\n| $1$ | $10$ |\n| $2$ | $20$ |\n| $3$ | $500$ |\n| $4$ | $5000$ |\n| $5$ | $5\\times 10^4$ |\n| $6,7$ | $5\\times 10^5$ |\n| $8,9,10$ | $5\\times 10^6$ |\n", "locale": "zh-CN"}}}
{"pid": "P10074", "type": "P", "difficulty": 6, "samples": [["2 1\n10 15", "15"], ["2 1\n10 30", "20"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "广东", "O2优化"], "title": "[GDKOI2024 普及组] 刷野 III", "background": "", "description": "Zayin 是一个与怪物战斗的巫师，这次他将面临 $n$ 个站成一排的怪物，其中第 $i$ 个怪物的生命值是 $a_i$。\n\n但是由于某种神秘原因，Zayin 并不能控制自己打到想打的怪物。具体来说, 存在一个长度为 $n$ 的排列 $p$，Zayin 每次攻击第 $i$ 只怪物时，实际上是在攻击第 $p_i$ 只怪物。\n\nZayin 每次可以选择一个 $[1, n]$ 的整数 $k$，让第 $p_k$ 只怪物的血量减少 $1$ 点，当某只怪物的血量小于等于 $0$ 时这只怪物死亡。\n\n然而 Zayin 并不知道这个排列 $p$ 具体是什么，也无法看到每个怪物剩余的具体血量，仅可以知道每次攻击完后怪物是否死亡。\n\n现在 Zayin 想知道，在他采取最优策略的情况下，最多需要攻击多少次，才可以杀死 $m$ 只怪物。", "inputFormat": "输入的第一行包含两个正整数 $n, m(1 \\leq m \\leq n \\leq 2000)$，$n$ 表示怪物的个数，$m$ 表示 Zayin 所需要击杀的怪物个数。\n\n输入的第二行包含 $n$ 个非负整数 $a_1, a_2, \\dots, a_n(1 \\leq a_i \\leq 10^9)$，$a_i$ 表示第 $i$ 只怪物的血量。", "outputFormat": "输出一个整数，最少的攻击次数。", "hint": "**【样例解释】**\n\n在第一个样例，Zayin 会一直攻击某一只怪物，直到怪物死亡。\n\n在第二个样例，Zayin 先攻击某一个怪物 $10$ 次，如果没有死亡，则说明攻击的是 $30$ 血的怪物。这时 Zayin 会选择攻击第二只怪物，攻击 $10$ 次后另一只怪物一定死亡，故最差需要 $20$ 次。\n\n**【数据范围】**\n\n对于 $10\\%$ 的数据，$1 \\leq n, m \\leq 5$。\n\n对于另外 $20\\%$ 的数据，所有 $a_i$ 全部相等。\n\n对于另外 $30\\%$ 的数据，$1 \\leq m \\leq n \\leq 500$。\n\n对于 $100\\%$ 的数据，$1 \\leq m \\leq n \\leq 2000$，$1 \\leq a_i \\leq 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GDKOI2024 普及组] 刷野 III", "background": "", "description": "Zayin 是一个与怪物战斗的巫师，这次他将面临 $n$ 个站成一排的怪物，其中第 $i$ 个怪物的生命值是 $a_i$。\n\n但是由于某种神秘原因，Zayin 并不能控制自己打到想打的怪物。具体来说, 存在一个长度为 $n$ 的排列 $p$，Zayin 每次攻击第 $i$ 只怪物时，实际上是在攻击第 $p_i$ 只怪物。\n\nZayin 每次可以选择一个 $[1, n]$ 的整数 $k$，让第 $p_k$ 只怪物的血量减少 $1$ 点，当某只怪物的血量小于等于 $0$ 时这只怪物死亡。\n\n然而 Zayin 并不知道这个排列 $p$ 具体是什么，也无法看到每个怪物剩余的具体血量，仅可以知道每次攻击完后怪物是否死亡。\n\n现在 Zayin 想知道，在他采取最优策略的情况下，最多需要攻击多少次，才可以杀死 $m$ 只怪物。", "inputFormat": "输入的第一行包含两个正整数 $n, m(1 \\leq m \\leq n \\leq 2000)$，$n$ 表示怪物的个数，$m$ 表示 Zayin 所需要击杀的怪物个数。\n\n输入的第二行包含 $n$ 个非负整数 $a_1, a_2, \\dots, a_n(1 \\leq a_i \\leq 10^9)$，$a_i$ 表示第 $i$ 只怪物的血量。", "outputFormat": "输出一个整数，最少的攻击次数。", "hint": "**【样例解释】**\n\n在第一个样例，Zayin 会一直攻击某一只怪物，直到怪物死亡。\n\n在第二个样例，Zayin 先攻击某一个怪物 $10$ 次，如果没有死亡，则说明攻击的是 $30$ 血的怪物。这时 Zayin 会选择攻击第二只怪物，攻击 $10$ 次后另一只怪物一定死亡，故最差需要 $20$ 次。\n\n**【数据范围】**\n\n对于 $10\\%$ 的数据，$1 \\leq n, m \\leq 5$。\n\n对于另外 $20\\%$ 的数据，所有 $a_i$ 全部相等。\n\n对于另外 $30\\%$ 的数据，$1 \\leq m \\leq n \\leq 500$。\n\n对于 $100\\%$ 的数据，$1 \\leq m \\leq n \\leq 2000$，$1 \\leq a_i \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P10075", "type": "P", "difficulty": 6, "samples": [["4 5\n1 2\n2 3\n3 4\n4 1\n2 4\n3\n1 5\n2 2 3\n2 1 2", "ymqOAO\nBob\nymqOAO"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "广东", "O2优化"], "title": "[GDKOI2024 普及组] 切割", "background": "", "description": "给定一张 $n$ 个点 $m$ 条边的无向连通图，**有**重边无自环。\n\nymqOAO 现在有 $k$ 个询问。每次询问如果删去图中的 $c_i$ 条边，剩下的图是否还是连通的。\n\n注意：询问之间是相互独立的，即一个询问的删边不会影响之后的询问。\n\n注解：\n- 连通图：一个图中任意两个顶点都有路径相连。", "inputFormat": "第一行输入三个整数 $n, m$。\n\n接下来 $m$ 行，每行包含两个正整数 $x_i, y_i$，表示第 $i$ 条边为 $x_i$ 与 $y_i$ 所连的边。\n\n接下来一行一个整数 $k$，表示询问的个数。\n\n接下来 $k$ 行，第 $i$ 行的第一个整数 $c_i$ 表示所切割的边的条数，接下来 $c_i(1 \\leq c_i \\leq 4)$ 个整数，表示所切割的边的编号，其中边的编号范围为 $[1, m]$。", "outputFormat": "对于每组询问，如果图不连通，则输出 `Bob`，否则输出 `ymqOAO`。（不包括引号）", "hint": "对于 $10\\%$ 的数据，$1 \\leq m, n, k \\leq 2000$。\n\n对于另外 $10\\%$ 的数据，$m = n-1$。\n\n对于另外 $10\\%$ 的数据，$c_i = 1$。\n\n对于 $60\\%$ 的数据，$1 \\leq m, n, k \\leq 10^5$。\n\n对于 $100\\%$ 的数据，$1 \\leq m, n, k \\leq 10^6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GDKOI2024 普及组] 切割", "background": "", "description": "给定一张 $n$ 个点 $m$ 条边的无向连通图，**有**重边无自环。\n\nymqOAO 现在有 $k$ 个询问。每次询问如果删去图中的 $c_i$ 条边，剩下的图是否还是连通的。\n\n注意：询问之间是相互独立的，即一个询问的删边不会影响之后的询问。\n\n注解：\n- 连通图：一个图中任意两个顶点都有路径相连。", "inputFormat": "第一行输入三个整数 $n, m$。\n\n接下来 $m$ 行，每行包含两个正整数 $x_i, y_i$，表示第 $i$ 条边为 $x_i$ 与 $y_i$ 所连的边。\n\n接下来一行一个整数 $k$，表示询问的个数。\n\n接下来 $k$ 行，第 $i$ 行的第一个整数 $c_i$ 表示所切割的边的条数，接下来 $c_i(1 \\leq c_i \\leq 4)$ 个整数，表示所切割的边的编号，其中边的编号范围为 $[1, m]$。", "outputFormat": "对于每组询问，如果图不连通，则输出 `Bob`，否则输出 `ymqOAO`。（不包括引号）", "hint": "对于 $10\\%$ 的数据，$1 \\leq m, n, k \\leq 2000$。\n\n对于另外 $10\\%$ 的数据，$m = n-1$。\n\n对于另外 $10\\%$ 的数据，$c_i = 1$。\n\n对于 $60\\%$ 的数据，$1 \\leq m, n, k \\leq 10^5$。\n\n对于 $100\\%$ 的数据，$1 \\leq m, n, k \\leq 10^6$。", "locale": "zh-CN"}}}
{"pid": "P10076", "type": "P", "difficulty": 3, "samples": [["1 2\n6 5\n2 3\n2 6\n2 1\n4 3\n5 1\n5 4 1 2\n6 4 4 3\n1 4 5 4\n5 2 1 4\n2 5 1 5\n4 5\n1 4\n3 4\n2 4\n4 2 2 3\n4 3 2 2\n4 3 3 3\n1 2 1 1\n1 2 1 2", "Ziyin\nZayin\nZayin\nZiyin\nZiyin\nZayin\nZayin\nZayin\nDraw\nZiyin"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "广东", "O2优化"], "title": "[GDKOI2024 普及组] 捉迷藏", "background": "", "description": "Zayin 和 Ziyin 正在玩有趣的捉迷藏游戏。\n\n该游戏在一颗具有 $n$ 个节点（编号从 $1$ 到 $n$）的树上进行。\n\n在游戏的开始，Zayin 在节点 $a$，而 Ziyin 在节点 $b$。他们轮流操作，Zayin 先移动。在每次移动中，Zayin\n能移动到距离当前所在点不超过 $da$ 的节点上，而 Ziyin 能移动到距离当前所在点不超过 $db$ 的节点上（注意\n可以保持在当前点不动）。\n\n当某次移动后，其中一人抓住了另外一人，即移动到了另外一人的节点上，则游戏结束，被抓住的人输掉游戏。\n\n当 Zayin 和 Ziyin 都按最优策略移动的话，谁会是最后赢家呢。\n\n注解：\n- 一颗具有 $n$ 个节点的树是指一个具有 $n$ 个节点，$n - 1$ 条边的连通无向图。\n- 树上两个节点的距离定义为连接该两点的最短路径所包含的边数。", "inputFormat": "每个测试点包含多个测试用例。\n\n第一行包含两个整数 $d, t$，表示测试点编号，和测试用例的数量。每个测试用例的描述如下。\n\n第一行包含两个整数 $n, q$ —— 分别为顶点数、询问数。\n\n接下来 $n-1$ 行每行包含两个整数 $u, v (1 \\leq u, v \\leq n, u \\neq v)$，表示顶点 $u$ 和 $v$ 之间具有一条直接相连的边，保证这些边形成一棵树。\n\n接下来 $q$ 行每行包含四个整数 $a, b, da, db(1 \\leq a, b, da, db \\leq n)$ 作为一次游戏，分别表示 Zayin 初始节点、Ziyin 初始节点、Zayin 最大移动距离、Ziyin 最大移动距离。", "outputFormat": "对于每个测试用例的每次游戏，输出一行 `Zayin` 或 `Ziyin` 表示最后赢家，特别地如果在 $10^{10^5}$ 轮内游\n戏没有仍结束，则输出 `Draw` 表示平局。\n", "hint": "保证所有测试用例的 $n$ 之和不超过 $10^6$，$q$ 之和不超过 $10^6$。\n\n| 数据点编号 | $\\sum n \\leq$ | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $10$ | 无 |\n| $2$ | $100$ | $q=1$ |\n| $3$ | $100$ | 无 |\n| $4$ | $10^4$ | $q=1$ |\n| $5$ | $10^4$ | 无 |\n| $6$ | $10^6$ | $q=1$ |\n| $7,8,9,10$ | $10^6$ | 无 |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GDKOI2024 普及组] 捉迷藏", "background": "", "description": "Zayin 和 Ziyin 正在玩有趣的捉迷藏游戏。\n\n该游戏在一颗具有 $n$ 个节点（编号从 $1$ 到 $n$）的树上进行。\n\n在游戏的开始，Zayin 在节点 $a$，而 Ziyin 在节点 $b$。他们轮流操作，Zayin 先移动。在每次移动中，Zayin\n能移动到距离当前所在点不超过 $da$ 的节点上，而 Ziyin 能移动到距离当前所在点不超过 $db$ 的节点上（注意\n可以保持在当前点不动）。\n\n当某次移动后，其中一人抓住了另外一人，即移动到了另外一人的节点上，则游戏结束，被抓住的人输掉游戏。\n\n当 Zayin 和 Ziyin 都按最优策略移动的话，谁会是最后赢家呢。\n\n注解：\n- 一颗具有 $n$ 个节点的树是指一个具有 $n$ 个节点，$n - 1$ 条边的连通无向图。\n- 树上两个节点的距离定义为连接该两点的最短路径所包含的边数。", "inputFormat": "每个测试点包含多个测试用例。\n\n第一行包含两个整数 $d, t$，表示测试点编号，和测试用例的数量。每个测试用例的描述如下。\n\n第一行包含两个整数 $n, q$ —— 分别为顶点数、询问数。\n\n接下来 $n-1$ 行每行包含两个整数 $u, v (1 \\leq u, v \\leq n, u \\neq v)$，表示顶点 $u$ 和 $v$ 之间具有一条直接相连的边，保证这些边形成一棵树。\n\n接下来 $q$ 行每行包含四个整数 $a, b, da, db(1 \\leq a, b, da, db \\leq n)$ 作为一次游戏，分别表示 Zayin 初始节点、Ziyin 初始节点、Zayin 最大移动距离、Ziyin 最大移动距离。", "outputFormat": "对于每个测试用例的每次游戏，输出一行 `Zayin` 或 `Ziyin` 表示最后赢家，特别地如果在 $10^{10^5}$ 轮内游\n戏没有仍结束，则输出 `Draw` 表示平局。\n", "hint": "保证所有测试用例的 $n$ 之和不超过 $10^6$，$q$ 之和不超过 $10^6$。\n\n| 数据点编号 | $\\sum n \\leq$ | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $10$ | 无 |\n| $2$ | $100$ | $q=1$ |\n| $3$ | $100$ | 无 |\n| $4$ | $10^4$ | $q=1$ |\n| $5$ | $10^4$ | 无 |\n| $6$ | $10^6$ | $q=1$ |\n| $7,8,9,10$ | $10^6$ | 无 |\n", "locale": "zh-CN"}}}
{"pid": "P10077", "type": "P", "difficulty": 4, "samples": [["1 10\n3 4 0 6 1 1 0 8 6 3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "广东", "O2优化"], "title": "[GDKOI2024 普及组] 读书", "background": "", "description": "Zayin 是一个热爱读书的学生。\n\n最近，Zayin 收到了一本有 $n$ 个章节的书，其中每个章节 $i$ 都有一个限制：她必须至少阅读了其他 $a_i$ 个\n章节，才能够获取足够的智慧来读懂该章节。\n\n每天，Zayin 都会从头到尾开始阅读这本书。对于她还不能读懂的章节（由于限制）或是已经阅读过的章节，Zayin 会在那天跳过它们。\n\n现在，Zayin 想要知道至少需要多少天才能阅读完所有的 $n$ 个章节。", "inputFormat": "第一行包含两个整数 $d, n$，表示测试点编号和章节数。\n\n第二行包含 $n$ 个整数 $a_i (0 \\leq a_i < n)$，表示限制。", "outputFormat": "输出一行包含一个整数，表示最少需要的天数。\n\n如果 Zayin 无法阅读完所有的 $n$ 个章节，输出 $-1$。", "hint": "**本题使用子任务捆绑测试。**\n\n对于所有测试数据，保证 $1 \\leq n \\leq 5 \\times 10^5\n, 0 \\leq a_i < n$。\n\n- Subtask 1（10%）：$1 ≤ n ≤ 10$，$d = 1$。\n- Subtask 2（10%）：$1 ≤ n ≤ 500$，$d = 2$。\n- Subtask 3（20%）：$1 ≤ n ≤ 5000$，$3 \\leq d \\leq 4$。\n- Subtask 4（20%）：$1 ≤ n ≤ 10^5$，$5 \\leq d \\leq 6$。\n- Subtask 5（40%）：$1 ≤ n ≤ 5 \\times 10^5$，$7 \\leq d \\leq 10$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GDKOI2024 普及组] 读书", "background": "", "description": "Zayin 是一个热爱读书的学生。\n\n最近，Zayin 收到了一本有 $n$ 个章节的书，其中每个章节 $i$ 都有一个限制：她必须至少阅读了其他 $a_i$ 个\n章节，才能够获取足够的智慧来读懂该章节。\n\n每天，Zayin 都会从头到尾开始阅读这本书。对于她还不能读懂的章节（由于限制）或是已经阅读过的章节，Zayin 会在那天跳过它们。\n\n现在，Zayin 想要知道至少需要多少天才能阅读完所有的 $n$ 个章节。", "inputFormat": "第一行包含两个整数 $d, n$，表示测试点编号和章节数。\n\n第二行包含 $n$ 个整数 $a_i (0 \\leq a_i < n)$，表示限制。", "outputFormat": "输出一行包含一个整数，表示最少需要的天数。\n\n如果 Zayin 无法阅读完所有的 $n$ 个章节，输出 $-1$。", "hint": "**本题使用子任务捆绑测试。**\n\n对于所有测试数据，保证 $1 \\leq n \\leq 5 \\times 10^5\n, 0 \\leq a_i < n$。\n\n- Subtask 1（10%）：$1 ≤ n ≤ 10$，$d = 1$。\n- Subtask 2（10%）：$1 ≤ n ≤ 500$，$d = 2$。\n- Subtask 3（20%）：$1 ≤ n ≤ 5000$，$3 \\leq d \\leq 4$。\n- Subtask 4（20%）：$1 ≤ n ≤ 10^5$，$5 \\leq d \\leq 6$。\n- Subtask 5（40%）：$1 ≤ n ≤ 5 \\times 10^5$，$7 \\leq d \\leq 10$。", "locale": "zh-CN"}}}
{"pid": "P10078", "type": "P", "difficulty": 5, "samples": [["5\n0 0\n2 0\n2 2\n0 2\n1 1", "11110"], ["3\n-2 0\n0 0\n2 0", "111"], ["7\n-7 -8\n5 -9\n1 -5\n9 -4\n-8 3\n-2 -3\n-4 -6", "1101110"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "广东", "O2优化"], "title": "[GDKOI2024 普及组] 正方形扩展", "background": "", "description": "现在，在笛卡尔坐标系（无限大二维平面）上有 $n$ 个种类互不相同的细菌，它们所在的坐标也互不相同。\n\n随着时间的增加，细菌们不断繁殖，以正方形的形状、用相同的正方形扩张速度，同时扩张自己的领地。\n\n具体来说对于任意时刻 $t$、平面上任意一点 $p$，假设该点 $p$ 上存在第 $i$ 种细菌，那么有以下两种情况：\n\n- 如果以点 $p$ 为中心的任意正方形都含有其他种类的细菌，则该点的细菌将不会扩张（可以称之为“接触抑制”）。\n\n- 如果存在一个以 $p$ 为中心的正方形不含有其他种类的细菌，则该点的细菌将会进行扩张。\n\n注意，扩展出去的同种细菌也具备一样的扩展能力。\n\n以下是一些简单的关于正方形扩展的例子：\n\n若初始时，平面只有唯一的一个细菌位于 $(0, 0)$，那么过一个单位时间后，这一类细菌将占领 $(1, 1) (1, -1) (-1, -1) (-1, 1)$ 围成的正方形。\n\n若初始时，平面有两个细菌分别位于 $(0, 0)$ 和 $(1, 0)$，那么最终 $(0.5, 0)$ 会成为他们领地的分界线，一开始位于 $(0, 0)$ 的细菌会占领 $(0.5, 0)$ 左侧的全部区域，位于 $(1, 0)$ 的细菌会占领 $(0.5, 0)$ 右侧的全部区域。\n\n现在询问对于第 $i$ 种细菌，询问其占领面积能否趋于无穷大。", "inputFormat": "第一行一个正整数 $n(1 \\leq n \\leq 10^6)$ 表示细菌母体的数量。\n\n接下来输入 $n$ 行，每行输入两个整数，表示点的坐标 $(x_i, y_i)$，即种类为 $i$ 的细菌母体的位置。", "outputFormat": "输出一个长度为 $n$ 的 $01$ 串，对于其中第 $i$ 个数字，$1$ 表示种类为 $i$ 的细菌的占领面积可以扩张到无穷大，$0$ 则表示最终面积有限。", "hint": "**【样例解释】**\n\n在第二个样例，点 $(0, 0)$ 最终拥有的领地是直线 $x = -1$ 与 $x = 1$ 夹的中间部分，面积趋于无穷大。\n\n**【数据范围】**\n\n对于 $25\\%$ 数据，$n \\leq 10^2$。\n\n对于 $50\\%$ 数据，$n \\leq 10^3$。\n\n对于 $75\\%$ 数据，$n \\leq 10^5$。\n\n对于 $100\\%$ 数据，$1\\leq n \\leq 10^6$，$-10^9 \\leq x_i, y_i \\leq 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GDKOI2024 普及组] 正方形扩展", "background": "", "description": "现在，在笛卡尔坐标系（无限大二维平面）上有 $n$ 个种类互不相同的细菌，它们所在的坐标也互不相同。\n\n随着时间的增加，细菌们不断繁殖，以正方形的形状、用相同的正方形扩张速度，同时扩张自己的领地。\n\n具体来说对于任意时刻 $t$、平面上任意一点 $p$，假设该点 $p$ 上存在第 $i$ 种细菌，那么有以下两种情况：\n\n- 如果以点 $p$ 为中心的任意正方形都含有其他种类的细菌，则该点的细菌将不会扩张（可以称之为“接触抑制”）。\n\n- 如果存在一个以 $p$ 为中心的正方形不含有其他种类的细菌，则该点的细菌将会进行扩张。\n\n注意，扩展出去的同种细菌也具备一样的扩展能力。\n\n以下是一些简单的关于正方形扩展的例子：\n\n若初始时，平面只有唯一的一个细菌位于 $(0, 0)$，那么过一个单位时间后，这一类细菌将占领 $(1, 1) (1, -1) (-1, -1) (-1, 1)$ 围成的正方形。\n\n若初始时，平面有两个细菌分别位于 $(0, 0)$ 和 $(1, 0)$，那么最终 $(0.5, 0)$ 会成为他们领地的分界线，一开始位于 $(0, 0)$ 的细菌会占领 $(0.5, 0)$ 左侧的全部区域，位于 $(1, 0)$ 的细菌会占领 $(0.5, 0)$ 右侧的全部区域。\n\n现在询问对于第 $i$ 种细菌，询问其占领面积能否趋于无穷大。", "inputFormat": "第一行一个正整数 $n(1 \\leq n \\leq 10^6)$ 表示细菌母体的数量。\n\n接下来输入 $n$ 行，每行输入两个整数，表示点的坐标 $(x_i, y_i)$，即种类为 $i$ 的细菌母体的位置。", "outputFormat": "输出一个长度为 $n$ 的 $01$ 串，对于其中第 $i$ 个数字，$1$ 表示种类为 $i$ 的细菌的占领面积可以扩张到无穷大，$0$ 则表示最终面积有限。", "hint": "**【样例解释】**\n\n在第二个样例，点 $(0, 0)$ 最终拥有的领地是直线 $x = -1$ 与 $x = 1$ 夹的中间部分，面积趋于无穷大。\n\n**【数据范围】**\n\n对于 $25\\%$ 数据，$n \\leq 10^2$。\n\n对于 $50\\%$ 数据，$n \\leq 10^3$。\n\n对于 $75\\%$ 数据，$n \\leq 10^5$。\n\n对于 $100\\%$ 数据，$1\\leq n \\leq 10^6$，$-10^9 \\leq x_i, y_i \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P10079", "type": "P", "difficulty": 6, "samples": [["2\n01\n1.2+2.1^3.2*4.2^(5.2*6.)2+7.", "243640717"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "广东", "O2优化"], "title": "[GDKOI2024 普及组] EX 中缀表达式", "background": "", "description": "Alice 最近学习了表达式，现在他想写一个属于自己的表达式计算器。\n\n规定：\n\n- 单个数字：由若干数字（至少一个）连续拼接，最后必须跟一个 `.` 字符（不含引号）。例如：`00123.` `0.` `789.` 都是合法的数字。\n- 单个操作符：由若干数字连续拼接，最后跟一个字符。\n- 操作符的字符：表示该操作符的操作。该字符必须是 `+`、`*`、`^` 之一，分别表示加法，乘法和乘方。特别约定 `0^0=1`。  \n例如：`000000789+`，`123^`，如果前面的数值合法，那么它们就都是合法的操作符。\n- 操作符的数字：表示该操作符的优先级，优先级的取值是 $[1, n]$ 之间的正整数，数字越大表示优先级越高。\n- 对于优先级相同的操作符，题目将给出一个长度为 $n$ 的 $01$ 串 $C$，用于说明对应优先级的操作符之间，是左结合还是右结合。  \n其中 $0$ 表示左结合，$1$ 表示右结合。  \n例如 $C=111011$，其中第 $4$ 个字符为 `0`，表示优先级为 $4$ 的操作符是左结合的。\n- 左结合：表示该运算符从左往右计算。下面给出左结合的例子：`1.4+2.4^3.4^4.` 等价于 `((1.4+2.)4^3.)4^4.`，其结果与 `((1+2)^3)^4` 相同\n- 右结合：表示该运算符从右往左运算。下面给出右结合的例子：`1.6+2.6^3.6^4.` 等价于 `1.6+(2.6^(3.6^4.))`，其结果与 `1+(2^(3^4))` 相同。\n- 中缀表达式：\n1. 单个数字是合法的中缀表达式。\n2. 若 A 是合法的中缀表达式，则 (A) 也是合法的中缀表达式。\n3. 若 A、B 均是合法的中缀表达式，c 是合法的单个操作符，则 AcB 也是合法的中缀表达式。\n4. 其余情况均不合法。\n\n现在给出一个长度为 $n$ 的 $01$ 串 $C$，用于说明，相同优先级的操作符之间，是左结合还是右结合。\n\n给出一个中缀表达式，判断该表达式是否合法，不合法则输出 `error`（不包括引号），合法则输出该表达式的值对 $998244353$ 取模的结果。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行一个长度为 $n$ 的 $01$ 串 $C$。\n\n第三行一个字符串 $S$，表示一个中缀表达式。\n\n保证表达式中不会存在空格。", "outputFormat": "若中缀表达式不合法则输出 `error`，否则输出该表达式的值对 $998244353$ 取模的结果。", "hint": "**【样例解释】**\n\n`243640717 = ((1+2)^(3*(4^((5*6)+7)))) mod 998244353`\n\n**【数据范围】**\n\n特殊性质 1：不会出现 ^ 字符。\n\n特殊性质 2：不会出现 + 和 * 字符。\n\n特殊性质 3：不会出现 ( 和 )。\n\n对于 $8\\%$ 的数据，$n = 1$，$1 \\leq |S| \\leq 100$，且满足特殊性质 $1$ 和特殊性质 $3$。\n\n对于另外 $8\\%$ 的数据，$n = 1$，$1 \\leq |S| \\leq 100$，且满足特殊性质 $1$。\n\n对于另外 $20\\%$ 的数据，$n = 1$，$1 \\leq |S| \\leq 100$，且满足特殊性质 $2$ 和特殊性质 $3$。\n\n对于另外 $24\\%$ 的数据，$n = 1$，$1 \\leq |S| \\leq 1000$,，且满足特殊性质 $2$。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 9$，$1 \\leq |S| \\leq 10000$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GDKOI2024 普及组] EX 中缀表达式", "background": "", "description": "Alice 最近学习了表达式，现在他想写一个属于自己的表达式计算器。\n\n规定：\n\n- 单个数字：由若干数字（至少一个）连续拼接，最后必须跟一个 `.` 字符（不含引号）。例如：`00123.` `0.` `789.` 都是合法的数字。\n- 单个操作符：由若干数字连续拼接，最后跟一个字符。\n- 操作符的字符：表示该操作符的操作。该字符必须是 `+`、`*`、`^` 之一，分别表示加法，乘法和乘方。特别约定 `0^0=1`。  \n例如：`000000789+`，`123^`，如果前面的数值合法，那么它们就都是合法的操作符。\n- 操作符的数字：表示该操作符的优先级，优先级的取值是 $[1, n]$ 之间的正整数，数字越大表示优先级越高。\n- 对于优先级相同的操作符，题目将给出一个长度为 $n$ 的 $01$ 串 $C$，用于说明对应优先级的操作符之间，是左结合还是右结合。  \n其中 $0$ 表示左结合，$1$ 表示右结合。  \n例如 $C=111011$，其中第 $4$ 个字符为 `0`，表示优先级为 $4$ 的操作符是左结合的。\n- 左结合：表示该运算符从左往右计算。下面给出左结合的例子：`1.4+2.4^3.4^4.` 等价于 `((1.4+2.)4^3.)4^4.`，其结果与 `((1+2)^3)^4` 相同\n- 右结合：表示该运算符从右往左运算。下面给出右结合的例子：`1.6+2.6^3.6^4.` 等价于 `1.6+(2.6^(3.6^4.))`，其结果与 `1+(2^(3^4))` 相同。\n- 中缀表达式：\n1. 单个数字是合法的中缀表达式。\n2. 若 A 是合法的中缀表达式，则 (A) 也是合法的中缀表达式。\n3. 若 A、B 均是合法的中缀表达式，c 是合法的单个操作符，则 AcB 也是合法的中缀表达式。\n4. 其余情况均不合法。\n\n现在给出一个长度为 $n$ 的 $01$ 串 $C$，用于说明，相同优先级的操作符之间，是左结合还是右结合。\n\n给出一个中缀表达式，判断该表达式是否合法，不合法则输出 `error`（不包括引号），合法则输出该表达式的值对 $998244353$ 取模的结果。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行一个长度为 $n$ 的 $01$ 串 $C$。\n\n第三行一个字符串 $S$，表示一个中缀表达式。\n\n保证表达式中不会存在空格。", "outputFormat": "若中缀表达式不合法则输出 `error`，否则输出该表达式的值对 $998244353$ 取模的结果。", "hint": "**【样例解释】**\n\n`243640717 = ((1+2)^(3*(4^((5*6)+7)))) mod 998244353`\n\n**【数据范围】**\n\n特殊性质 1：不会出现 ^ 字符。\n\n特殊性质 2：不会出现 + 和 * 字符。\n\n特殊性质 3：不会出现 ( 和 )。\n\n对于 $8\\%$ 的数据，$n = 1$，$1 \\leq |S| \\leq 100$，且满足特殊性质 $1$ 和特殊性质 $3$。\n\n对于另外 $8\\%$ 的数据，$n = 1$，$1 \\leq |S| \\leq 100$，且满足特殊性质 $1$。\n\n对于另外 $20\\%$ 的数据，$n = 1$，$1 \\leq |S| \\leq 100$，且满足特殊性质 $2$ 和特殊性质 $3$。\n\n对于另外 $24\\%$ 的数据，$n = 1$，$1 \\leq |S| \\leq 1000$,，且满足特殊性质 $2$。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 9$，$1 \\leq |S| \\leq 10000$。\n", "locale": "zh-CN"}}}
{"pid": "P10080", "type": "P", "difficulty": 6, "samples": [["2\n3 7\n3 6 1\n2 6 0\n2 5 1\n3 5 1\n1 6 1\n3 4 0\n1 5 1\n3 7\n1 6 1\n3 5 1\n2 5 1\n3 4 1\n1 5 0\n1 4 0\n2 6 0", "5 3 6\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "广东", "Special Judge", "O2优化", "广度优先搜索 BFS", "深度优先搜索 DFS", "二分图"], "title": "[GDKOI2024 提高组] 匹配", "background": "", "description": "给定一个 $2n$ 个点 $m$ 条边的二分图，左部点编号为 $1 \\sim n$，右部点编号为 $n + 1 \\sim 2n$。\n\n给定每条边为黑色或白色，你需要找到一个完美匹配，使得匹配里的黑色边数恰好为偶数。\n\n如果你对二分图的定义有疑问：\n\n- 二分图是一个无向图，点分为左右两部分，每部分各 $n$ 个点，每条边都连接两个属于不同部分的点。\n- 一个完美匹配是一个大小为 $n$ 的边的集合，使得每个点都恰好与集合里的一条边相连。", "inputFormat": "第一行一个正整数 $T$，表示数据组数。每组数据的格式如下：\n\n第一行两个正整数 $n, m$，表示图的点数和边数。接下来 $m$ 行，每行三个整数 $u_i, v_i, c_i(1 \\leq u_i \\leq n, n+1 \\leq v_i \\leq 2n, 0 \\leq c_i \\leq 1)$，表示一条连接 $u_i$, $v_i$ 的边，颜色为 $c_i$。$c_i = 0$ 表示白色，$c_i = 1$ 表示黑色。", "outputFormat": "对于每组数据：如果无解，输出一行 $-1$。否则，输出一行 $n$ 个正整数，表示你找到的完美匹配里每条边的编号。边按照输入顺序编号为 $1 \\sim m$。", "hint": "**【样例解释】**\n\n在第一组数据中，一个合法的完美匹配是 $(1, 6),(2, 5),(3, 4)$，且里面有恰好两条黑色边。\n\n在第二组数据中，虽然存在完美匹配，但每个完美匹配都有奇数条黑色边。\n\n**【数据范围】**\n\n**本题使用子任务捆绑测试。**\n\n对于所有数据，保证 $1 \\leq T \\leq 250$，$2 \\leq n,\\sum n \\leq 500$，$1 \\leq m \\leq n^2$。保证图中不存在重边，即对于 $i \\neq j$ 有 $(u_i, v_i)\\neq (u_j , v_j)$。\n\n- Subtask 1（20%）：$n ≤ 8$，$T ≤ 10$。\n- Subtask 2（20%）：$n ≤ 18$，$T ≤ 10$。\n- Subtask 3（20%）：$c_i$ 在 $\\{0, 1\\}$ 里独立均匀随机。\n- Subtask 4（40%）：无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GDKOI2024 提高组] 匹配", "background": "", "description": "给定一个 $2n$ 个点 $m$ 条边的二分图，左部点编号为 $1 \\sim n$，右部点编号为 $n + 1 \\sim 2n$。\n\n给定每条边为黑色或白色，你需要找到一个完美匹配，使得匹配里的黑色边数恰好为偶数。\n\n如果你对二分图的定义有疑问：\n\n- 二分图是一个无向图，点分为左右两部分，每部分各 $n$ 个点，每条边都连接两个属于不同部分的点。\n- 一个完美匹配是一个大小为 $n$ 的边的集合，使得每个点都恰好与集合里的一条边相连。", "inputFormat": "第一行一个正整数 $T$，表示数据组数。每组数据的格式如下：\n\n第一行两个正整数 $n, m$，表示图的点数和边数。接下来 $m$ 行，每行三个整数 $u_i, v_i, c_i(1 \\leq u_i \\leq n, n+1 \\leq v_i \\leq 2n, 0 \\leq c_i \\leq 1)$，表示一条连接 $u_i$, $v_i$ 的边，颜色为 $c_i$。$c_i = 0$ 表示白色，$c_i = 1$ 表示黑色。", "outputFormat": "对于每组数据：如果无解，输出一行 $-1$。否则，输出一行 $n$ 个正整数，表示你找到的完美匹配里每条边的编号。边按照输入顺序编号为 $1 \\sim m$。", "hint": "**【样例解释】**\n\n在第一组数据中，一个合法的完美匹配是 $(1, 6),(2, 5),(3, 4)$，且里面有恰好两条黑色边。\n\n在第二组数据中，虽然存在完美匹配，但每个完美匹配都有奇数条黑色边。\n\n**【数据范围】**\n\n**本题使用子任务捆绑测试。**\n\n对于所有数据，保证 $1 \\leq T \\leq 250$，$2 \\leq n,\\sum n \\leq 500$，$1 \\leq m \\leq n^2$。保证图中不存在重边，即对于 $i \\neq j$ 有 $(u_i, v_i)\\neq (u_j , v_j)$。\n\n- Subtask 1（20%）：$n ≤ 8$，$T ≤ 10$。\n- Subtask 2（20%）：$n ≤ 18$，$T ≤ 10$。\n- Subtask 3（20%）：$c_i$ 在 $\\{0, 1\\}$ 里独立均匀随机。\n- Subtask 4（40%）：无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P10081", "type": "P", "difficulty": 7, "samples": [["10 5 4\n1 9 10 7\n1 7 10 9\n2 3 10\n1 10 10 1\n2 5 10\n2 5\n1 1\n3 4\n1 3", "64\n0\n0\n36"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "广东", "O2优化", "分块", "扫描线"], "title": "[GDKOI2024 提高组] 新本格魔法少女", "background": "", "description": "给定一个长度 $n$ 的整数序列 $a_1,\\dots, a_n$；\n\n给定一个由 $m$ 次操作构成的操作序列，操作从 $1$ 开始编号，到 $m$ 结束。操作序列中包含修改操作和求和操作，修改操作给定 $l, r, v$，将 $a_l, a_{l+1}, \\dots, a_r$ 修改为 $v$，求和操作给定 $l,r$ ，查询 $\\sum \\limits_{i=l}^r a_i$。\n\n共 $q$ 次查询，每次查询给出 $L,R$ ，询问将序列 $a$ 初始化为 $0$ 后，依次进行操作序列中的第 $L, L+1, \\dots , R$ 次操作，每次求和操作的答案之和。", "inputFormat": "第一行三个整数 $n, m, q$；\n\n接下来 $m$ 行，每行 $1, l, r, v$ 或 $2, l, r$ 表示一次操作；\n\n接下来 $q$ 行，每行两个整数 $L, R$ 表示一次查询。\n", "outputFormat": "共 $q$ 行，每行一个整数，依次表示每次查询的答案。", "hint": "对所有数据，满足 $1 \\leq l \\leq r \\leq n$，$1 \\leq v \\leq n$，$1 \\leq L \\leq R \\leq m$，$1 \\leq n, m, q \\leq 5 \\times 10^5$。\n\n对 $10\\%$ 的数据，$n, m, q \\leq 10^2$。\n\n对另外 $20\\%$ 的数据，$n, m, q \\leq 5 \\times 10^3$。\n\n对另外 $10\\%$ 的数据，每次操作都是求和操作。\n\n对另外 $20\\%$ 的数据，每次查询满足 $L = 1$。\n\n对另外 $20\\%$ 的数据，$n, m, q \\leq 2 \\times 10^5$。\n\n对于其余数据，无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GDKOI2024 提高组] 新本格魔法少女", "background": "", "description": "给定一个长度 $n$ 的整数序列 $a_1,\\dots, a_n$；\n\n给定一个由 $m$ 次操作构成的操作序列，操作从 $1$ 开始编号，到 $m$ 结束。操作序列中包含修改操作和求和操作，修改操作给定 $l, r, v$，将 $a_l, a_{l+1}, \\dots, a_r$ 修改为 $v$，求和操作给定 $l,r$ ，查询 $\\sum \\limits_{i=l}^r a_i$。\n\n共 $q$ 次查询，每次查询给出 $L,R$ ，询问将序列 $a$ 初始化为 $0$ 后，依次进行操作序列中的第 $L, L+1, \\dots , R$ 次操作，每次求和操作的答案之和。", "inputFormat": "第一行三个整数 $n, m, q$；\n\n接下来 $m$ 行，每行 $1, l, r, v$ 或 $2, l, r$ 表示一次操作；\n\n接下来 $q$ 行，每行两个整数 $L, R$ 表示一次查询。\n", "outputFormat": "共 $q$ 行，每行一个整数，依次表示每次查询的答案。", "hint": "对所有数据，满足 $1 \\leq l \\leq r \\leq n$，$1 \\leq v \\leq n$，$1 \\leq L \\leq R \\leq m$，$1 \\leq n, m, q \\leq 5 \\times 10^5$。\n\n对 $10\\%$ 的数据，$n, m, q \\leq 10^2$。\n\n对另外 $20\\%$ 的数据，$n, m, q \\leq 5 \\times 10^3$。\n\n对另外 $10\\%$ 的数据，每次操作都是求和操作。\n\n对另外 $20\\%$ 的数据，每次查询满足 $L = 1$。\n\n对另外 $20\\%$ 的数据，$n, m, q \\leq 2 \\times 10^5$。\n\n对于其余数据，无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P10082", "type": "P", "difficulty": 7, "samples": [["3 1 1000000007", "6"], ["4 2 1000000007", "47"], ["20 24 1000000007", "901565358"], ["123 234 1000000009", "141754844"], ["1234 2345 1004535809", "576196526"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "广东", "O2优化"], "title": "[GDKOI2024 提高组] 鸡", "background": "", "description": "对于一个非负整数序列 $a$，定义它对应的独立集序列 $f(a)$：\n\n- 假设将 $a_i$ 改为 $0$，此时选出若干个两两不相邻的数使得它们的和最大，则 $f(a)_i$ 表示和的最大值。\n\n现在给定 $n, m$，求有多少个长度为 $b$ 的非负整数序列 $b$ 满足以下条件：\n\n- 存在至少一个长度为 $n$，值域为 $[0, m]$ 的非负整数序列 $a$ 使得 $f(a) = b$。\n\n答案对给定的质数 $\\textit{MOD}$ 取模。", "inputFormat": "共一行，三个数，表示 $n, m, \\textit{MOD}$。", "outputFormat": "共一行，一个数，表示答案。\n", "hint": "**本题使用子任务捆绑测试。**\n\n对于 $100\\%$ 的数据，$1 \\leq n, m \\leq 3 \\times 10^3$，$n \\geq 2$，$10^9 < \\textit{MOD} < 1.01 \\times 10^9$，$\\textit{MOD}$ 为质数。\n\n- Subtask 1（10%）：$n, m \\leq 5$。\n- Subtask 2（15%）：$n \\leq 300$，$m = 1$。\n- Subtask 3（25%）：$n \\leq 300$，$m ≤ 5$。\n- Subtask 4（20%）：$n, m \\leq 50$。\n- Subtask 5（15%）：$n, m \\leq 300$。\n- Subtask 6（15%）：无特殊限制。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GDKOI2024 提高组] 鸡", "background": "", "description": "对于一个非负整数序列 $a$，定义它对应的独立集序列 $f(a)$：\n\n- 假设将 $a_i$ 改为 $0$，此时选出若干个两两不相邻的数使得它们的和最大，则 $f(a)_i$ 表示和的最大值。\n\n现在给定 $n, m$，求有多少个长度为 $b$ 的非负整数序列 $b$ 满足以下条件：\n\n- 存在至少一个长度为 $n$，值域为 $[0, m]$ 的非负整数序列 $a$ 使得 $f(a) = b$。\n\n答案对给定的质数 $\\textit{MOD}$ 取模。", "inputFormat": "共一行，三个数，表示 $n, m, \\textit{MOD}$。", "outputFormat": "共一行，一个数，表示答案。\n", "hint": "**本题使用子任务捆绑测试。**\n\n对于 $100\\%$ 的数据，$1 \\leq n, m \\leq 3 \\times 10^3$，$n \\geq 2$，$10^9 < \\textit{MOD} < 1.01 \\times 10^9$，$\\textit{MOD}$ 为质数。\n\n- Subtask 1（10%）：$n, m \\leq 5$。\n- Subtask 2（15%）：$n \\leq 300$，$m = 1$。\n- Subtask 3（25%）：$n \\leq 300$，$m ≤ 5$。\n- Subtask 4（20%）：$n, m \\leq 50$。\n- Subtask 5（15%）：$n, m \\leq 300$。\n- Subtask 6（15%）：无特殊限制。\n", "locale": "zh-CN"}}}
{"pid": "P10083", "type": "P", "difficulty": 5, "samples": [["5 10\n9 10 10 0 2\n8 5 6 2 5", "4"], ["5 10\n8 1 6 4 10\n7 6 1 8 5", "5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "广东", "O2优化"], "title": "[GDKOI2024 提高组] 不休陀螺", "background": "", "description": "有 $n$ 张牌组成一个序列，每张牌用一个二元组 $(a_i\n, b_i)$ 表示，意味着打出这张牌需要消耗 $a_i$ 点费用，打出后可以获得 $b_i$ 点费用。\n\n接下来你可以选择一个区间 $[l, r]$ 将这个区间中的卡取出来作为你的卡组。\n\n开始时你的卡组会按照随机顺序排列并且你有 $E$ 点费用，然后你会依次从前往后打出这个排列中的卡。\n\n当你打完这个排列中的卡后你的卡组又会重新随机排列然后你再依次打出，直到你无法再打出下一张牌（当前费用小于下一张牌需要消耗的费用）时停止。\n\n如果一个卡组无论在什么情况下都能够无限打下去，我们则称这卡组可以“陀螺无限”。\n\n现在求有多少个区间组成的卡组能够“陀螺无限”。", "inputFormat": "第一行输入两个非负整数 $n, E$ 分别表示卡牌序列长度和初始能量值 $E(1 \\leq n \\leq 10^6, 0 \\leq E \\leq 10^9)$。\n\n接下来一行 $n$ 个非负整数 $a_i(0 \\leq a_i \\leq 10^9)$ 表示每张卡牌打出需要消耗的能量。\n\n接下来一行 $n$ 个非负整数 $b_i(0 \\leq b_i \\leq 10^9)$ 表示每张卡牌打出后能获得的能量。", "outputFormat": "输出一行一个整数表示有多少个区间组成的卡组能够“陀螺无限”。", "hint": "**本题使用子任务捆绑测试。**\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^6$，$0 \\leq E, a_i, b_i \\leq 10^9$。\n\n- Subtask 1（20%）：$1 \\leq n \\leq 5000$。\n- Subtask 2（10%）：$b_i \\geq a_i$。\n- Subtask 3（10%）：$E = 0$。\n- Subtask 4（10%）：$0 \\leq a_i, b_i \\leq 1$。\n- Subtask 5（20%）：$a_i \\times b_i = 0$。\n- Subtask 6（30%）：无特殊限制", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GDKOI2024 提高组] 不休陀螺", "background": "", "description": "有 $n$ 张牌组成一个序列，每张牌用一个二元组 $(a_i\n, b_i)$ 表示，意味着打出这张牌需要消耗 $a_i$ 点费用，打出后可以获得 $b_i$ 点费用。\n\n接下来你可以选择一个区间 $[l, r]$ 将这个区间中的卡取出来作为你的卡组。\n\n开始时你的卡组会按照随机顺序排列并且你有 $E$ 点费用，然后你会依次从前往后打出这个排列中的卡。\n\n当你打完这个排列中的卡后你的卡组又会重新随机排列然后你再依次打出，直到你无法再打出下一张牌（当前费用小于下一张牌需要消耗的费用）时停止。\n\n如果一个卡组无论在什么情况下都能够无限打下去，我们则称这卡组可以“陀螺无限”。\n\n现在求有多少个区间组成的卡组能够“陀螺无限”。", "inputFormat": "第一行输入两个非负整数 $n, E$ 分别表示卡牌序列长度和初始能量值 $E(1 \\leq n \\leq 10^6, 0 \\leq E \\leq 10^9)$。\n\n接下来一行 $n$ 个非负整数 $a_i(0 \\leq a_i \\leq 10^9)$ 表示每张卡牌打出需要消耗的能量。\n\n接下来一行 $n$ 个非负整数 $b_i(0 \\leq b_i \\leq 10^9)$ 表示每张卡牌打出后能获得的能量。", "outputFormat": "输出一行一个整数表示有多少个区间组成的卡组能够“陀螺无限”。", "hint": "**本题使用子任务捆绑测试。**\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^6$，$0 \\leq E, a_i, b_i \\leq 10^9$。\n\n- Subtask 1（20%）：$1 \\leq n \\leq 5000$。\n- Subtask 2（10%）：$b_i \\geq a_i$。\n- Subtask 3（10%）：$E = 0$。\n- Subtask 4（10%）：$0 \\leq a_i, b_i \\leq 1$。\n- Subtask 5（20%）：$a_i \\times b_i = 0$。\n- Subtask 6（30%）：无特殊限制", "locale": "zh-CN"}}}
{"pid": "P10084", "type": "P", "difficulty": 7, "samples": [["3\n5 0 0 2 1\n4 1 2 2 4\n8 3 2 4 6", "8\n1024\n527847872"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "广东", "O2优化"], "title": "[GDKOI2024 提高组] 计算", "background": "", "description": "定义 $F(x, a, b) = \\gcd(x^a - 1, x^b - 1) + 1, x > 0$。\n\n特别的，如果 $a = 0$ 或 $b = 0$，$F(x, a, b) = 0$。\n\n现在给出五个非负整数 $m, a, b, c, d$。\n\n令 $L = F(m, a, b) + 1$，$R = F(m, c, d)$。\n\n问集合 $\\{L, L + 1, L + 2, \\dots, R - 2, R - 1, R\\}$ 有多少个子集和是 $m$ 的倍数。\n\n由于答案可能很大，你只需要输出方案数对 $998244353$ 取模后的结果就可以了。\n\n**由于本题第三组数据有误，特别地，如果 $L > R$，输出 $1$ 即可。**", "inputFormat": "输入第一行为一个整数 $T$，表示数据组数。\n\n接下来一行 $T$ 行，每行五个非负整数 $m, a, b, c, d$。", "outputFormat": "对于每组数据，输出答案。", "hint": "**【样例解释】**\n\n经过计算可知 $L=1$，$R=5$，集合是 $1,2,3,4,5$，满足条件的子集和有以下 $8$ 个：\n\n$\\{\\}$，$\\{5\\}$，$\\{2, 3\\}$，$\\{1, 4\\}$，$\\{1, 2, 3, 4\\}$，$\\{2, 3, 5\\}$，$\\{1, 4, 5\\}$，$\\{1, 2, 3, 4, 5\\}$。\n\n**【数据范围】**\n\n::cute-table{tuack}\n\n| 测试点编号 | $m$ | $L,R$ | $a,b$ | $c,d$ | $T$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $=2$ | $L=1,R=2$| $=0$ | $\\leq 10$ | $\\leq 5$ | 无 |\n| $2$ | $\\leq 10$ |$L=1,R=m$ | ^ | ^ | ^ | ^ |\n| $3$ | $\\leq 5$ | $\\leq 10^3$ | $\\le 10$ | ^ | ^ | $1$ |\n| $4\\sim 6$ | $\\leq 20$ | $\\leq 2\\times 10^3$ | ^ | ^ | ^ | 无 |\n| $7$ | ^ | $\\leq 10^5$ | $\\leq 10^2$ | $\\leq 10^2$ | ^ | $2$ |\n| $8,9$ | $\\leq 80$ | $\\leq 10^9$ | ^ | ^ | ^ | 无 |\n| $10\\sim 13$ | $\\leq 2\\times 10^3$ | $\\leq 10^{18}$ | $\\leq 10^3$ | $\\leq 10^3$ | ^ | ^ |\n| $14\\sim 17$ | $\\leq 10^5$ | ^ | ^ | ^ | ^ | ^ |\n| $18\\sim 20$ | $\\leq 10^7$ | ^ | ^ | ^ | $\\leq 10^4$ | ^ |\n\n- 特殊性质 1：$R - L + 1 \\leq 20$；\n- 特殊性质 2：$R - L + 1 \\leq 2000$；\n\n对于全部数据，保证 $L < R$，$m > 0$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GDKOI2024 提高组] 计算", "background": "", "description": "定义 $F(x, a, b) = \\gcd(x^a - 1, x^b - 1) + 1, x > 0$。\n\n特别的，如果 $a = 0$ 或 $b = 0$，$F(x, a, b) = 0$。\n\n现在给出五个非负整数 $m, a, b, c, d$。\n\n令 $L = F(m, a, b) + 1$，$R = F(m, c, d)$。\n\n问集合 $\\{L, L + 1, L + 2, \\dots, R - 2, R - 1, R\\}$ 有多少个子集和是 $m$ 的倍数。\n\n由于答案可能很大，你只需要输出方案数对 $998244353$ 取模后的结果就可以了。\n\n**由于本题第三组数据有误，特别地，如果 $L > R$，输出 $1$ 即可。**", "inputFormat": "输入第一行为一个整数 $T$，表示数据组数。\n\n接下来一行 $T$ 行，每行五个非负整数 $m, a, b, c, d$。", "outputFormat": "对于每组数据，输出答案。", "hint": "**【样例解释】**\n\n经过计算可知 $L=1$，$R=5$，集合是 $1,2,3,4,5$，满足条件的子集和有以下 $8$ 个：\n\n$\\{\\}$，$\\{5\\}$，$\\{2, 3\\}$，$\\{1, 4\\}$，$\\{1, 2, 3, 4\\}$，$\\{2, 3, 5\\}$，$\\{1, 4, 5\\}$，$\\{1, 2, 3, 4, 5\\}$。\n\n**【数据范围】**\n\n::cute-table{tuack}\n\n| 测试点编号 | $m$ | $L,R$ | $a,b$ | $c,d$ | $T$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $=2$ | $L=1,R=2$| $=0$ | $\\leq 10$ | $\\leq 5$ | 无 |\n| $2$ | $\\leq 10$ |$L=1,R=m$ | ^ | ^ | ^ | ^ |\n| $3$ | $\\leq 5$ | $\\leq 10^3$ | $\\le 10$ | ^ | ^ | $1$ |\n| $4\\sim 6$ | $\\leq 20$ | $\\leq 2\\times 10^3$ | ^ | ^ | ^ | 无 |\n| $7$ | ^ | $\\leq 10^5$ | $\\leq 10^2$ | $\\leq 10^2$ | ^ | $2$ |\n| $8,9$ | $\\leq 80$ | $\\leq 10^9$ | ^ | ^ | ^ | 无 |\n| $10\\sim 13$ | $\\leq 2\\times 10^3$ | $\\leq 10^{18}$ | $\\leq 10^3$ | $\\leq 10^3$ | ^ | ^ |\n| $14\\sim 17$ | $\\leq 10^5$ | ^ | ^ | ^ | ^ | ^ |\n| $18\\sim 20$ | $\\leq 10^7$ | ^ | ^ | ^ | $\\leq 10^4$ | ^ |\n\n- 特殊性质 1：$R - L + 1 \\leq 20$；\n- 特殊性质 2：$R - L + 1 \\leq 2000$；\n\n对于全部数据，保证 $L < R$，$m > 0$。", "locale": "zh-CN"}}}
{"pid": "P10085", "type": "P", "difficulty": 6, "samples": [["2\n0 0 1 1\n1 0 1 0\n0 0 0 0\n1 1 1 0", "7\n0 0\n1 0\n1 3\n2 1\n3 1\n3 2\n3 3"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "广东", "Special Judge", "O2优化"], "title": "[GDKOI2024 提高组] 染色", "background": "", "description": "Alice 非常喜欢二进制，她认为事物只有和二进制有关才是美的。\n\n一天，她奇思妙想了一种图案，并打算在长宽都为 $2^n$ 的网格上画出她心中所想的图案。\n网格的格子只有黑色和白色两种，一开始都是白色。\n\n现在 Alice 规定一种绘画操作为：选定一个格子，使它自己和相邻上下左右的网格颜色反转，即原本黑色会变成白色，白色会变成黑色。\n\nAlice 还规定网格的第一行和最后一行相邻，第一列和最后一列也相邻。\n\n现在 Alice 希望你给出一个操作方案或告诉无解。如果有多个方案，输出任意一个即可。", "inputFormat": "第一行一个正整数 $n$。\n\n接下来一个 $2^n \\times 2^n$ 的矩阵，表示 Alice 所想的图案。其中 $0$ 表示白色，$1$ 表示黑色。", "outputFormat": "第一行一个数 $\\mathit{ans}$ 表示操作次数，或输出 $-1$ 表示无解。\n\n接下来 $\\mathit{ans}$ 行，每行一个坐标表示操作位置。其中每一维坐标范围均为 $[0, 2^n - 1]$。", "hint": "- 对于 $20\\%$ 的数据，$n = 2$。\n- 对于另外 $15\\%$ 的数据，$n = 4$。\n- 对于另外 $15\\%$ 的数据，$n = 7$。\n- 对于 $100\\%$ 的数据，$n \\leq 11$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GDKOI2024 提高组] 染色", "background": "", "description": "Alice 非常喜欢二进制，她认为事物只有和二进制有关才是美的。\n\n一天，她奇思妙想了一种图案，并打算在长宽都为 $2^n$ 的网格上画出她心中所想的图案。\n网格的格子只有黑色和白色两种，一开始都是白色。\n\n现在 Alice 规定一种绘画操作为：选定一个格子，使它自己和相邻上下左右的网格颜色反转，即原本黑色会变成白色，白色会变成黑色。\n\nAlice 还规定网格的第一行和最后一行相邻，第一列和最后一列也相邻。\n\n现在 Alice 希望你给出一个操作方案或告诉无解。如果有多个方案，输出任意一个即可。", "inputFormat": "第一行一个正整数 $n$。\n\n接下来一个 $2^n \\times 2^n$ 的矩阵，表示 Alice 所想的图案。其中 $0$ 表示白色，$1$ 表示黑色。", "outputFormat": "第一行一个数 $\\mathit{ans}$ 表示操作次数，或输出 $-1$ 表示无解。\n\n接下来 $\\mathit{ans}$ 行，每行一个坐标表示操作位置。其中每一维坐标范围均为 $[0, 2^n - 1]$。", "hint": "- 对于 $20\\%$ 的数据，$n = 2$。\n- 对于另外 $15\\%$ 的数据，$n = 4$。\n- 对于另外 $15\\%$ 的数据，$n = 7$。\n- 对于 $100\\%$ 的数据，$n \\leq 11$。", "locale": "zh-CN"}}}
