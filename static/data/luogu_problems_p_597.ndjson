{"pid": "P13115", "type": "P", "difficulty": 3, "samples": [["3\n3\n1 1\n1 2\n2 1\n4\n1 2\n2 4\n2 1\n4 2\n3\n1 2\n1 3\n2 3", "Case #1: 2\nCase #2: 2\nCase #3: 1"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["数学", "2019", "Google Code Jam"], "title": "[GCJ 2019 #2] New Elements: Part 1", "background": "", "description": "**The first two paragraphs (not counting this one) of this problem and \"New Elements: Part 2\" are identical. The problems can otherwise be solved independently; you do not need to read or solve one in order to read or solve the other.**\n\nMuriel is on the path to discovering two new elements that she has named Codium and Jamarium. She has not been able to isolate them yet, but she wants to start investigating some important properties, like their atomic weights, by indirect means. Since Muriel is working with a single isotope of Codium and a single isotope of Jamarium, their atomic weights are strictly positive integers.\n\nMuriel managed to create $\\mathbf{N}$ different molecules, each of which contains one or more atoms of Codium and one or more atoms of Jamarium, and no other elements. For each molecule, she knows how many atoms of each element are present in it. The molecular weight of a molecule is the sum of the atomic weights of all the atoms it contains.\n\nAs a first step towards figuring out exact molecular weights for the molecules and atomic weights for the two elements, Muriel wants to sort the molecules by strictly increasing molecular weight. To assess the difficulty of that task, she wants to know how many orders are valid considering only the information she has right now. An ordering of the molecules is considered valid if there exist values for the atomic weights of Codium and Jamarium such that the ordering is strictly increasing in molecular weight.\n\nTo give an example, we represent each molecule by the ordered pair of the number of atoms of Codium and Jamarium it contains. If Muriel has 3 molecules represented by $(1, 1)$, $(2, 1)$ and $(1, 2)$, there are two possible orderings that can be strictly increasing in molecular weight: $(1, 1)$, $(1, 2)$, $(2, 1)$ and $(1, 1)$, $(2, 1)$, $(1, 2)$. The first ordering is valid for any assignment of atomic weights in which Codium is the heaviest of the two elements, and the second is valid for any assignment in which Jamarium is the heaviest. The only case remaining is when both Codium and Jamarium have the same atomic weight, in which case $(1, 2)$ and $(2, 1)$ have the same molecular weight, so no strictly increasing ordering can be produced for that scenario.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of a test case contains a single integer $\\mathbf{N}$, the number of molecules. Each of the next $\\mathbf{N}$ lines describes a different molecule with two integers $\\mathbf{C_i}$ and $\\mathbf{J_i}$ that represent the number of Codium and Jamarium atoms in the i-th molecule, respectively.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the total number of valid orderings as defined above.", "hint": "**Sample Explanation**\n\nSample Case #1 is explained in the statement.\n\nIn Sample Case #2, the two valid orderings are $(1, 2)$, $(2, 1)$, $(2, 4)$, $(4, 2)$ and $(2, 1)$, $(1, 2)$, $(4, 2)$, $(2, 4)$. Notice that the ordering $(1, 2)$, $(2, 1)$, $(2, 4)$, $(4, 2)$, $(2, 4)$ is invalid because if $(1, 2)$ is strictly less heavy than $(2, 1)$, then $(2, 4)$, which is exactly twice as heavy as $(1, 2)$, must be strictly less heavy than $(4, 2)$, which is exactly twice as heavy as $(2, 1)$.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{C_i} \\leqslant 10^9$, for all i.\n- $1 \\leqslant \\mathbf{J_i} \\leqslant 10^9$, for all i.\n- $(\\mathbf{C_i}, \\mathbf{J_i}) \\neq (\\mathbf{C_j}, \\mathbf{J_j})$ for all $i \\neq j$. (All molecules are different.)\n\n**Test set 1 (8 Pts, Visible)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 6$.\n\n**Test set 2 (14 Pts, Hidden)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 300$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #2] New Elements: Part 1", "background": "", "description": "**The first two paragraphs (not counting this one) of this problem and \"New Elements: Part 2\" are identical. The problems can otherwise be solved independently; you do not need to read or solve one in order to read or solve the other.**\n\nMuriel is on the path to discovering two new elements that she has named Codium and Jamarium. She has not been able to isolate them yet, but she wants to start investigating some important properties, like their atomic weights, by indirect means. Since Muriel is working with a single isotope of Codium and a single isotope of Jamarium, their atomic weights are strictly positive integers.\n\nMuriel managed to create $\\mathbf{N}$ different molecules, each of which contains one or more atoms of Codium and one or more atoms of Jamarium, and no other elements. For each molecule, she knows how many atoms of each element are present in it. The molecular weight of a molecule is the sum of the atomic weights of all the atoms it contains.\n\nAs a first step towards figuring out exact molecular weights for the molecules and atomic weights for the two elements, Muriel wants to sort the molecules by strictly increasing molecular weight. To assess the difficulty of that task, she wants to know how many orders are valid considering only the information she has right now. An ordering of the molecules is considered valid if there exist values for the atomic weights of Codium and Jamarium such that the ordering is strictly increasing in molecular weight.\n\nTo give an example, we represent each molecule by the ordered pair of the number of atoms of Codium and Jamarium it contains. If Muriel has 3 molecules represented by $(1, 1)$, $(2, 1)$ and $(1, 2)$, there are two possible orderings that can be strictly increasing in molecular weight: $(1, 1)$, $(1, 2)$, $(2, 1)$ and $(1, 1)$, $(2, 1)$, $(1, 2)$. The first ordering is valid for any assignment of atomic weights in which Codium is the heaviest of the two elements, and the second is valid for any assignment in which Jamarium is the heaviest. The only case remaining is when both Codium and Jamarium have the same atomic weight, in which case $(1, 2)$ and $(2, 1)$ have the same molecular weight, so no strictly increasing ordering can be produced for that scenario.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of a test case contains a single integer $\\mathbf{N}$, the number of molecules. Each of the next $\\mathbf{N}$ lines describes a different molecule with two integers $\\mathbf{C_i}$ and $\\mathbf{J_i}$ that represent the number of Codium and Jamarium atoms in the i-th molecule, respectively.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the total number of valid orderings as defined above.", "hint": "**Sample Explanation**\n\nSample Case #1 is explained in the statement.\n\nIn Sample Case #2, the two valid orderings are $(1, 2)$, $(2, 1)$, $(2, 4)$, $(4, 2)$ and $(2, 1)$, $(1, 2)$, $(4, 2)$, $(2, 4)$. Notice that the ordering $(1, 2)$, $(2, 1)$, $(2, 4)$, $(4, 2)$, $(2, 4)$ is invalid because if $(1, 2)$ is strictly less heavy than $(2, 1)$, then $(2, 4)$, which is exactly twice as heavy as $(1, 2)$, must be strictly less heavy than $(4, 2)$, which is exactly twice as heavy as $(2, 1)$.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{C_i} \\leqslant 10^9$, for all i.\n- $1 \\leqslant \\mathbf{J_i} \\leqslant 10^9$, for all i.\n- $(\\mathbf{C_i}, \\mathbf{J_i}) \\neq (\\mathbf{C_j}, \\mathbf{J_j})$ for all $i \\neq j$. (All molecules are different.)\n\n**Test set 1 (8 Pts, Visible)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 6$.\n\n**Test set 2 (14 Pts, Hidden)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 300$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #2] New Elements: Part 1", "background": null, "description": "**本题的前两段（不包括本段）与“New Elements: Part 2”完全相同。除此之外，这两道题可以独立解决；你无需阅读或解决其中一道即可理解或解决另一道。**\n\nMuriel 正在探索两种新元素，并将它们命名为 Codium 和 Jamarium。她尚未能够分离出这两种元素，但她希望通过间接方法研究它们的一些重要性质，比如它们的原子量。由于 Muriel 只研究 Codium 和 Jamarium 的单一同位素，因此它们的原子量都是严格正整数。\n\nMuriel 成功合成了 $\\mathbf{N}$ 种不同的分子，每种分子都只包含一种或多种 Codium 原子和一种或多种 Jamarium 原子，不含其他元素。对于每种分子，她都知道其中包含的每种元素的原子数。分子的分子量等于其所含所有原子的原子量之和。\n\n为了进一步确定分子的精确分子量以及两种元素的原子量，Muriel 首先希望将这些分子按分子量严格递增的顺序排序。为了评估这个任务的难度，她想知道在当前信息下，有多少种排序方式是有效的。一个分子的排序被认为是有效的，当且仅当存在 Codium 和 Jamarium 的原子量的取值，使得该排序下分子的分子量严格递增。\n\n举个例子，我们用每个分子中 Codium 和 Jamarium 原子的数量对其进行表示。如果 Muriel 有 3 个分子，分别为 $(1, 1)$、$(2, 1)$ 和 $(1, 2)$，则有两种可能的排序可以使分子量严格递增：$(1, 1)$、$(1, 2)$、$(2, 1)$ 和 $(1, 1)$、$(2, 1)$、$(1, 2)$。第一种排序在 Codium 比 Jamarium 重时成立，第二种排序在 Jamarium 比 Codium 重时成立。剩下的唯一情况是 Codium 和 Jamarium 的原子量相等，此时 $(1, 2)$ 和 $(2, 1)$ 的分子量相等，因此无法得到严格递增的排序。", "inputFormat": "输入的第一行为测试用例数 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试数据。每组测试数据的第一行为一个整数 $\\mathbf{N}$，表示分子的数量。接下来的 $\\mathbf{N}$ 行，每行包含两个整数 $\\mathbf{C_i}$ 和 $\\mathbf{J_i}$，分别表示第 $i$ 个分子中 Codium 和 Jamarium 的原子数。", "outputFormat": "对于每组测试数据，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是满足条件的有效排序总数。", "hint": "**样例解释**\n\n样例 1 已在题目描述中解释。\n\n在样例 2 中，两种有效的排序分别为 $(1, 2)$、$(2, 1)$、$(2, 4)$、$(4, 2)$ 和 $(2, 1)$、$(1, 2)$、$(4, 2)$、$(2, 4)$。注意，排序 $(1, 2)$、$(2, 1)$、$(2, 4)$、$(4, 2)$、$(2, 4)$ 是无效的，因为如果 $(1, 2)$ 的分子量严格小于 $(2, 1)$，那么 $(2, 4)$（正好是 $(1, 2)$ 的两倍）也必须严格小于 $(4, 2)$（正好是 $(2, 1)$ 的两倍）。\n\n**数据范围**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$。\n- $1 \\leqslant \\mathbf{C_i} \\leqslant 10^9$，对所有 $i$。\n- $1 \\leqslant \\mathbf{J_i} \\leqslant 10^9$，对所有 $i$。\n- 对于所有 $i \\neq j$，$(\\mathbf{C_i}, \\mathbf{J_i}) \\neq (\\mathbf{C_j}, \\mathbf{J_j})$（所有分子都不同）。\n\n**测试点 1（8 分，可见）**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 6$。\n\n**测试点 2（14 分，隐藏）**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 300$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13116", "type": "P", "difficulty": 5, "samples": [["", ""]], "limits": {"time": [40000], "memory": [1048576]}, "tags": ["数学", "贪心", "2019", "交互题", "Special Judge", "Google Code Jam"], "title": "[GCJ 2019 #2] Pottery Lottery", "background": "", "description": "The Pottery Palace is going to run a lottery featuring some valuable vases by the artist Cody-Jamal. The lottery works as follows:\n\n* 100 people get to play in the lottery. Each player has a unique number between 1 and 100, and is given a single token with that number.\n* There are 20 empty clay vases on a table, numbered 1 through 20. The vases have narrow openings that are large enough to accept a token, but small enough that players cannot look inside to see the contents.\n* On the i-th day of the lottery, the player with token number i chooses a vase and puts their token in that vase. Since the vases are all identical (apart from their labels), every player will choose one uniformly at random and independently of all other players' choices.\n* On day 100, after player number 100 has inserted their token, the organizers shake the vases to determine how many tokens are inside each one. If there is exactly one vase that has fewer tokens than any other vase, then that one is the \"winning vase\". The organizers then pour out all of the tokens in that vase, and every player whose number is written on one of those poured-out tokens wins a vase! If multiple vases have the same minimal amount of tokens, nobody wins anything.\n\nYou have been hired to test the security of the lottery, and you will participate in some trial runs. The company will always assign you the number 100 — that is, you replace player 100.\n\nYou have found some ways to tamper with the lottery at night, but security is tight, so you can only do so much! Specifically, after each of the first 99 days of the lottery, you may do exactly one of the following:\n\n* forge a token with the player number of your choice (between 1 and 100, inclusive), and add it to a vase of your choice. You are a very good forger: if there is a winning vase, any forged tokens in that vase will cause the players with those numbers to win (with one exception; see below).\n* use a special camera to see the numbers on all of the tokens in one vase of your choice\n\nYou may perform different actions on different nights, and you may choose dynamically: you do not need to decide on all of your actions in advance.\n\nOn the 100th day, it is your turn to insert your token into a vase of your choice (you do not need to choose uniformly at random). You cannot perform any other actions on that day.\n\nYou know that if there is a winning vase with more than one token for the same player, it will be obvious that cheating has occurred and nobody will win. However, it does not matter if other vases contain more than one token for the same player because the organizers never see those tokens.\n\nYour goal is to be a winner in at least 90% of the test cases.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing a single integer $\\mathbf{T}$ indicating the number of test cases. Then, you need to process $\\mathbf{T}$ test cases.\n\nAt the start of a test case, the judge outputs one line with one integer: the number of the current day. (The judge starts on day 1, and on the i-th day, it prints i.) After your program reads the integer, it should write a line containing two integers $\\mathbf{V}$ and $\\mathbf{P}$, with $1 \\leq \\mathbf{V} \\leq 20$, and $0 \\leq \\mathbf{P} \\leq 100$. The judge will interpret these as follows:\n\n* If $1 \\leq \\mathbf{P} \\leq 100$, you put a token for player $\\mathbf{P}$ in vase $\\mathbf{V}$. The judge does not write anything back as a response.\n* If $\\mathbf{P} = 0$, you inspect the contents of vase $\\mathbf{V}$. The judge writes one line containing integers. The first integer is $\\mathbf{N}$, the number of tokens in vase $\\mathbf{V}$, and then there are $\\mathbf{N}$ more integers: the player numbers on each of the tokens, in non-decreasing order.\n\nNotice that on turn 100, you must put your own token in, so $\\mathbf{P}$ must be 100.\n\nRemember that on the i-th day, for $1 \\leq i \\leq 99$, the judge simulates the action of the i-th player, as described in the statement. This happens before your own action on that day.\n\nAfter you send your move for turn 100, your program should terminate if it was the last test case; otherwise, it should start reading data for the next test case. (Notice that the judge does not tell you whether you got each case correct or incorrect.) The judge will only check whether you have enough correct answers after you have attempted all $\\mathbf{T}$ test cases, so you should not stop early! For example, if you answer the first 225 out of 250 cases correctly and then exit, or provide malformed input, your solution will not be considered correct.\n\nIf your program outputs something illegal (e.g., gives an invalid value for $\\mathbf{P}$ or $\\mathbf{V}$, or tries to inspect a vase on turn 100), the judge will send one line containing -1 to your input stream, and it will not send any other output after that. If your program continues to wait for the judge after receiving -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the total memory is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\n```\n  t = readline_int()           // reads 250 into t\n  curr_day = readline_int()    // reads 1 (day 1)\n  printline 8 100 to stdout    // puts a token for player 100 into vase 8\n  flush stdout\n  curr_day = readline_int()    // reads 2 (day 2)\n  printline 8 99 to stdout     // puts a token for player 99 into vase 8\n  flush stdout\n  curr_day = readline_int()    // reads 3 (day 3)\n  printline 8 100 to stdout    // puts a token for player 100 into vase 8\n  flush stdout\n  curr_day = readline_int()    // reads 4 (day 4)\n  printline 20 7 to stdout     // puts a token for player 7 into vase 20\n  flush stdout\n  curr_day = readline_int()    // reads 5 (day 5)\n  printline 8 0 to stdout      // inspects vase 8\n  flush stdout\n  tokens = readline_int_list() // reads 5 2 5 99 100 100 (players 2 and 5\n                               //   happen to have chosen vase 8)\n  curr_day = readline_int()    // reads 6 (day 6)\n  printline 8 101 to stdout    // tries to add a token with a bad player number\n  flush stdout\n  curr_day = readline_int()    // reads -1 (judge has decided our solution is\n                               //   incorrect)\n  exit                         // exits to avoid an ambiguous TLE error\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n**Test set 1 (23 Pts, Visible)**\n\n- $\\mathbf{T} = 250$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #2] Pottery Lottery", "background": "", "description": "The Pottery Palace is going to run a lottery featuring some valuable vases by the artist Cody-Jamal. The lottery works as follows:\n\n* 100 people get to play in the lottery. Each player has a unique number between 1 and 100, and is given a single token with that number.\n* There are 20 empty clay vases on a table, numbered 1 through 20. The vases have narrow openings that are large enough to accept a token, but small enough that players cannot look inside to see the contents.\n* On the i-th day of the lottery, the player with token number i chooses a vase and puts their token in that vase. Since the vases are all identical (apart from their labels), every player will choose one uniformly at random and independently of all other players' choices.\n* On day 100, after player number 100 has inserted their token, the organizers shake the vases to determine how many tokens are inside each one. If there is exactly one vase that has fewer tokens than any other vase, then that one is the \"winning vase\". The organizers then pour out all of the tokens in that vase, and every player whose number is written on one of those poured-out tokens wins a vase! If multiple vases have the same minimal amount of tokens, nobody wins anything.\n\nYou have been hired to test the security of the lottery, and you will participate in some trial runs. The company will always assign you the number 100 — that is, you replace player 100.\n\nYou have found some ways to tamper with the lottery at night, but security is tight, so you can only do so much! Specifically, after each of the first 99 days of the lottery, you may do exactly one of the following:\n\n* forge a token with the player number of your choice (between 1 and 100, inclusive), and add it to a vase of your choice. You are a very good forger: if there is a winning vase, any forged tokens in that vase will cause the players with those numbers to win (with one exception; see below).\n* use a special camera to see the numbers on all of the tokens in one vase of your choice\n\nYou may perform different actions on different nights, and you may choose dynamically: you do not need to decide on all of your actions in advance.\n\nOn the 100th day, it is your turn to insert your token into a vase of your choice (you do not need to choose uniformly at random). You cannot perform any other actions on that day.\n\nYou know that if there is a winning vase with more than one token for the same player, it will be obvious that cheating has occurred and nobody will win. However, it does not matter if other vases contain more than one token for the same player because the organizers never see those tokens.\n\nYour goal is to be a winner in at least 90% of the test cases.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing a single integer $\\mathbf{T}$ indicating the number of test cases. Then, you need to process $\\mathbf{T}$ test cases.\n\nAt the start of a test case, the judge outputs one line with one integer: the number of the current day. (The judge starts on day 1, and on the i-th day, it prints i.) After your program reads the integer, it should write a line containing two integers $\\mathbf{V}$ and $\\mathbf{P}$, with $1 \\leq \\mathbf{V} \\leq 20$, and $0 \\leq \\mathbf{P} \\leq 100$. The judge will interpret these as follows:\n\n* If $1 \\leq \\mathbf{P} \\leq 100$, you put a token for player $\\mathbf{P}$ in vase $\\mathbf{V}$. The judge does not write anything back as a response.\n* If $\\mathbf{P} = 0$, you inspect the contents of vase $\\mathbf{V}$. The judge writes one line containing integers. The first integer is $\\mathbf{N}$, the number of tokens in vase $\\mathbf{V}$, and then there are $\\mathbf{N}$ more integers: the player numbers on each of the tokens, in non-decreasing order.\n\nNotice that on turn 100, you must put your own token in, so $\\mathbf{P}$ must be 100.\n\nRemember that on the i-th day, for $1 \\leq i \\leq 99$, the judge simulates the action of the i-th player, as described in the statement. This happens before your own action on that day.\n\nAfter you send your move for turn 100, your program should terminate if it was the last test case; otherwise, it should start reading data for the next test case. (Notice that the judge does not tell you whether you got each case correct or incorrect.) The judge will only check whether you have enough correct answers after you have attempted all $\\mathbf{T}$ test cases, so you should not stop early! For example, if you answer the first 225 out of 250 cases correctly and then exit, or provide malformed input, your solution will not be considered correct.\n\nIf your program outputs something illegal (e.g., gives an invalid value for $\\mathbf{P}$ or $\\mathbf{V}$, or tries to inspect a vase on turn 100), the judge will send one line containing -1 to your input stream, and it will not send any other output after that. If your program continues to wait for the judge after receiving -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the total memory is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\n```\n  t = readline_int()           // reads 250 into t\n  curr_day = readline_int()    // reads 1 (day 1)\n  printline 8 100 to stdout    // puts a token for player 100 into vase 8\n  flush stdout\n  curr_day = readline_int()    // reads 2 (day 2)\n  printline 8 99 to stdout     // puts a token for player 99 into vase 8\n  flush stdout\n  curr_day = readline_int()    // reads 3 (day 3)\n  printline 8 100 to stdout    // puts a token for player 100 into vase 8\n  flush stdout\n  curr_day = readline_int()    // reads 4 (day 4)\n  printline 20 7 to stdout     // puts a token for player 7 into vase 20\n  flush stdout\n  curr_day = readline_int()    // reads 5 (day 5)\n  printline 8 0 to stdout      // inspects vase 8\n  flush stdout\n  tokens = readline_int_list() // reads 5 2 5 99 100 100 (players 2 and 5\n                               //   happen to have chosen vase 8)\n  curr_day = readline_int()    // reads 6 (day 6)\n  printline 8 101 to stdout    // tries to add a token with a bad player number\n  flush stdout\n  curr_day = readline_int()    // reads -1 (judge has decided our solution is\n                               //   incorrect)\n  exit                         // exits to avoid an ambiguous TLE error\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n**Test set 1 (23 Pts, Visible)**\n\n- $\\mathbf{T} = 250$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #2] Pottery Lottery", "background": null, "description": "陶艺宫将举办一次抽奖活动，奖品是艺术家 Cody-Jamal 的一些珍贵花瓶。抽奖规则如下：\n\n- 有 100 人参与抽奖。每位玩家拥有一个唯一编号（1 到 100 之间），并获得一个带有该编号的代币。\n- 桌上有 20 个空陶瓷花瓶，编号为 1 到 20。花瓶的开口足够大，可以放入代币，但开口很窄，玩家无法看到里面的内容。\n- 在第 $i$ 天，编号为 $i$ 的玩家选择一个花瓶，并将自己的代币放入该花瓶。由于花瓶除了标签外完全相同，每位玩家都会独立且等概率地随机选择一个花瓶。\n- 第 100 天，在编号为 100 的玩家放入代币后，组织者会摇晃花瓶，统计每个花瓶中的代币数量。如果恰好有一个花瓶中的代币数量比其他所有花瓶都少，那么这个花瓶就是“中奖花瓶”。组织者会倒出中奖花瓶中的所有代币，代币编号对应的玩家都将获得一个花瓶！如果有多个花瓶的代币数量同为最少，则无人获奖。\n\n你被雇佣来测试抽奖的安全性，并将参与若干次试运行。公司总是会分配给你编号 100 —— 也就是说，你替代了编号为 100 的玩家。\n\n你发现了一些夜间篡改抽奖的方法，但安保很严，你能做的有限！具体来说，在前 99 天的每一天结束后，你可以执行以下两种操作之一：\n\n- 伪造一个任意玩家编号（1 到 100 之间）的代币，并将其放入任意一个花瓶。你的伪造技术非常高超：如果某个花瓶成为中奖花瓶，中奖花瓶中的伪造代币也会使对应编号的玩家获奖（有一个例外，见下文）。\n- 使用特殊相机查看某个花瓶内所有代币上的编号。\n\n你可以在不同的夜晚选择不同的操作，并且可以动态决定：不需要提前规划所有操作。\n\n第 100 天轮到你放入自己的代币，你可以选择任意一个花瓶（不需要随机选择）。当天你不能进行其他操作。\n\n你知道，如果中奖花瓶中存在同一玩家编号的多个代币，作弊行为会被发现，无人获奖。但其他花瓶中是否有重复编号的代币无关紧要，因为组织者不会查看那些花瓶。\n\n你的目标是在至少 90% 的测试用例中成为获奖者。\n\n### 交互协议\n\n这是一个交互题。\n\n最开始，你的程序应读取一行，包含一个整数 $\\mathbf{T}$，表示测试用例数量。然后，你需要处理 $\\mathbf{T}$ 个测试用例。\n\n每个测试用例开始时，评测器会输出一行，包含一个整数：当前天数（评测器从第 1 天开始，在第 $i$ 天输出 $i$）。你的程序读取该整数后，应输出一行，包含两个整数 $\\mathbf{V}$ 和 $\\mathbf{P}$，其中 $1 \\leq \\mathbf{V} \\leq 20$，$0 \\leq \\mathbf{P} \\leq 100$。评测器的解释如下：\n\n- 如果 $1 \\leq \\mathbf{P} \\leq 100$，你会将编号为 $\\mathbf{P}$ 的代币放入编号为 $\\mathbf{V}$ 的花瓶。评测器不会对此做出回应。\n- 如果 $\\mathbf{P} = 0$，你会查看编号为 $\\mathbf{V}$ 的花瓶内的内容。评测器会输出一行整数。第一个整数是 $\\mathbf{N}$，表示该花瓶内的代币数量，接下来有 $\\mathbf{N}$ 个整数，按非递减顺序给出每个代币上的玩家编号。\n\n注意，第 100 天你必须放入自己的代币，因此 $\\mathbf{P}$ 必须为 100。\n\n请记住，在第 $i$ 天（$1 \\leq i \\leq 99$），评测器会按照题目描述模拟第 $i$ 位玩家的操作，这发生在你当天的操作之前。\n\n在你第 100 天提交操作后，如果这是最后一个测试用例，你的程序应终止；否则，继续读取下一个测试用例的数据。（注意，评测器不会告知你每个用例是否正确。只有在你完成所有 $\\mathbf{T}$ 个测试用例后，评测器才会检查你是否答对足够多的用例，因此不要提前退出！例如，如果你答对了前 225 个用例中的 225 个然后退出，或者输出格式错误，你的解答将不被判为正确。）\n\n如果你的程序输出了非法内容（如 $\\mathbf{P}$ 或 $\\mathbf{V}$ 不合法，或在第 100 天尝试查看花瓶），评测器会向你的输入流发送一行 -1，之后不会再有任何输出。如果你的程序在收到 -1 后仍继续等待评测器，则会超时，导致 Time Limit Exceeded 错误。请确保你的程序能及时退出，以获得 Wrong Answer 判罚，而不是 TLE。若总内存超限或程序运行时出错，也会得到相应的判罚。", "inputFormat": "参见交互协议。", "outputFormat": "参见交互协议。", "hint": "**交互样例**\n\n```\n  t = readline_int()           // 读取 250 到 t\n  curr_day = readline_int()    // 读取 1（第 1 天）\n  printline 8 100 to stdout    // 将编号 100 的代币放入 8 号花瓶\n  flush stdout\n  curr_day = readline_int()    // 读取 2（第 2 天）\n  printline 8 99 to stdout     // 将编号 99 的代币放入 8 号花瓶\n  flush stdout\n  curr_day = readline_int()    // 读取 3（第 3 天）\n  printline 8 100 to stdout    // 将编号 100 的代币放入 8 号花瓶\n  flush stdout\n  curr_day = readline_int()    // 读取 4（第 4 天）\n  printline 20 7 to stdout     // 将编号 7 的代币放入 20 号花瓶\n  flush stdout\n  curr_day = readline_int()    // 读取 5（第 5 天）\n  printline 8 0 to stdout      // 查看 8 号花瓶\n  flush stdout\n  tokens = readline_int_list() // 读取 5 2 5 99 100 100（玩家 2 和 5\n                               //   恰好选择了 8 号花瓶）\n  curr_day = readline_int()    // 读取 6（第 6 天）\n  printline 8 101 to stdout    // 尝试放入非法编号的代币\n  flush stdout\n  curr_day = readline_int()    // 读取 -1（评测器判定解答错误）\n  exit                         // 退出，避免 TLE 错误\n```\n\n你可以使用本地测试工具在本地或平台上测试。若要在本地测试，需要让测试工具与你的代码并行运行；你可以使用我们的 [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)。更多信息请阅读该文件中的注释。\n\n测试工具的使用说明已包含在工具的注释中。我们鼓励你自行添加测试用例。请注意，虽然测试工具旨在模拟评测系统，但它**不是**真实的评测系统，行为可能有所不同。\n\n**数据范围**\n\n**测试点 1（23 分，可见）**\n\n- $\\mathbf{T} = 250$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13117", "type": "P", "difficulty": 6, "samples": [["3\n3\n1 1\n1 2\n2 1\n4\n1 2\n2 1\n4 2\n2 4\n3\n1 2\n1 3\n2 3", "Case #1: 2 1\nCase #2: IMPOSSIBLE\nCase #3: 1 1"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["数学", "2019", "二分", "Stern-Brocot 树", "Google Code Jam"], "title": "[GCJ 2019 #2] New Elements: Part 2", "background": "", "description": "**The first two paragraphs (not counting this one) of this problem and \"New Elements: Part 1\" are identical. The problems can otherwise be solved independently; you do not need to read or solve one in order to read or solve the other.**\n\nMuriel is on the path to discovering two new elements that she has named Codium and Jamarium. She has not been able to isolate them yet, but she wants to start investigating some important properties, like their atomic weights, by indirect means. Since Muriel is working with a single isotope of Codium and a single isotope of Jamarium, their atomic weights are strictly positive integers.\n\nMuriel managed to create $\\mathbf{N}$ different molecules, each of which contains one or more atoms of Codium and one or more atoms of Jamarium, and no other elements. For each molecule, she knows how many atoms of each element are present in it. The molecular weight of a molecule is the sum of the atomic weights of all the atoms it contains.\n\nAs a first step, Muriel sorted the molecules by strictly increasing molecular weight. Now she wants to find out possible integer values for the atomic weights of both Codium and Jamarium that are consistent with the ordering. Since she is aware there could be many consistent pairs of values, she wants one that minimizes the atomic weight of Codium. If there are multiple pairs in which Codium's atomic weight is minimum, she wants the one in which Jamarium's atomic weight is minimum.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of a test case contains a single integer $\\mathbf{N}$, the number of molecules. Each of the next $\\mathbf{N}$ lines describes a different molecule with two integers $\\mathbf{C_i}$ and $\\mathbf{J_i}$ that represent the number of Codium and Jamarium atoms in the i-th molecule, respectively. The molecules are given in strictly increasing order of molecular weight.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1), and $y$ is IMPOSSIBLE (in uppercase) if there is no pair of integer atomic weights that would make the order of the molecules strictly increasing in molecular weight. Otherwise, $y$ should be two integers $c\\ j$ where $c$ is the atomic weight of Codium and $j$ is the atomic weight of Jamarium, chosen according to the rules above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the difference between the last two molecules is having an extra atom of one element or the other. Given that the one having the extra Codium is heavier overall, we conclude that Codium must be heavier than Jamarium. The values 2 and 1 for the atomic weights of Codium and Jamarium make the molecular weights $1 \\times 2 + 1 \\times 1 = 3$, $1 \\times 2 + 2 \\times 1 = 4$, and $2 \\times 2 + 1 \\times 1 = 5$, respecting the strict ordering. Since Codium is heavier than Jamarium in this case, 2 is Codium's minimum atomic weight, and 1 is of course Jamarium's minimum atomic weight.\n\nLet $a$, $b$, $c$ and $d$ be the molecular weights of the molecules in Sample Case #2, in increasing order of molecular weight. By their atom contents, $d = 2 \\times a$ and $c = 2 \\times b$. It follows from $a < b$ that $d = 2 \\times a < 2 \\times b = c$, which means there is no pair of values for the atomic weights that would make the ordering strictly increasing.\n\nIn Sample Case #3, notice that the molecules happen to be sorted in strictly increasing order of total number of atoms. Therefore, assigning both elements an atomic weight of 1 makes the atomic weights be sorted in strictly increasing order.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{N} \\leq 10$.\n- $(\\mathbf{C_i}, \\mathbf{J_i}) \\neq (\\mathbf{C_j}, \\mathbf{J_j})$ for all $i \\neq j$. (All molecules are different.)\n\n**Test set 1 (10 Pts, Visible)**\n\n- $1 \\leq \\mathbf{C_i} \\leq 100$, for all $i$.\n- $1 \\leq \\mathbf{J_i} \\leq 100$, for all $i$.\n\n**Test set 2 (16 Pts, Hidden)**\n\n- $1 \\leq \\mathbf{C_i} \\leq 10^9$, for all $i$.\n- $1 \\leq \\mathbf{J_i} \\leq 10^9$, for all $i$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #2] New Elements: Part 2", "background": "", "description": "**The first two paragraphs (not counting this one) of this problem and \"New Elements: Part 1\" are identical. The problems can otherwise be solved independently; you do not need to read or solve one in order to read or solve the other.**\n\nMuriel is on the path to discovering two new elements that she has named Codium and Jamarium. She has not been able to isolate them yet, but she wants to start investigating some important properties, like their atomic weights, by indirect means. Since Muriel is working with a single isotope of Codium and a single isotope of Jamarium, their atomic weights are strictly positive integers.\n\nMuriel managed to create $\\mathbf{N}$ different molecules, each of which contains one or more atoms of Codium and one or more atoms of Jamarium, and no other elements. For each molecule, she knows how many atoms of each element are present in it. The molecular weight of a molecule is the sum of the atomic weights of all the atoms it contains.\n\nAs a first step, Muriel sorted the molecules by strictly increasing molecular weight. Now she wants to find out possible integer values for the atomic weights of both Codium and Jamarium that are consistent with the ordering. Since she is aware there could be many consistent pairs of values, she wants one that minimizes the atomic weight of Codium. If there are multiple pairs in which Codium's atomic weight is minimum, she wants the one in which Jamarium's atomic weight is minimum.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of a test case contains a single integer $\\mathbf{N}$, the number of molecules. Each of the next $\\mathbf{N}$ lines describes a different molecule with two integers $\\mathbf{C_i}$ and $\\mathbf{J_i}$ that represent the number of Codium and Jamarium atoms in the i-th molecule, respectively. The molecules are given in strictly increasing order of molecular weight.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1), and $y$ is IMPOSSIBLE (in uppercase) if there is no pair of integer atomic weights that would make the order of the molecules strictly increasing in molecular weight. Otherwise, $y$ should be two integers $c\\ j$ where $c$ is the atomic weight of Codium and $j$ is the atomic weight of Jamarium, chosen according to the rules above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the difference between the last two molecules is having an extra atom of one element or the other. Given that the one having the extra Codium is heavier overall, we conclude that Codium must be heavier than Jamarium. The values 2 and 1 for the atomic weights of Codium and Jamarium make the molecular weights $1 \\times 2 + 1 \\times 1 = 3$, $1 \\times 2 + 2 \\times 1 = 4$, and $2 \\times 2 + 1 \\times 1 = 5$, respecting the strict ordering. Since Codium is heavier than Jamarium in this case, 2 is Codium's minimum atomic weight, and 1 is of course Jamarium's minimum atomic weight.\n\nLet $a$, $b$, $c$ and $d$ be the molecular weights of the molecules in Sample Case #2, in increasing order of molecular weight. By their atom contents, $d = 2 \\times a$ and $c = 2 \\times b$. It follows from $a < b$ that $d = 2 \\times a < 2 \\times b = c$, which means there is no pair of values for the atomic weights that would make the ordering strictly increasing.\n\nIn Sample Case #3, notice that the molecules happen to be sorted in strictly increasing order of total number of atoms. Therefore, assigning both elements an atomic weight of 1 makes the atomic weights be sorted in strictly increasing order.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{N} \\leq 10$.\n- $(\\mathbf{C_i}, \\mathbf{J_i}) \\neq (\\mathbf{C_j}, \\mathbf{J_j})$ for all $i \\neq j$. (All molecules are different.)\n\n**Test set 1 (10 Pts, Visible)**\n\n- $1 \\leq \\mathbf{C_i} \\leq 100$, for all $i$.\n- $1 \\leq \\mathbf{J_i} \\leq 100$, for all $i$.\n\n**Test set 2 (16 Pts, Hidden)**\n\n- $1 \\leq \\mathbf{C_i} \\leq 10^9$, for all $i$.\n- $1 \\leq \\mathbf{J_i} \\leq 10^9$, for all $i$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #2] New Elements: Part 2", "background": null, "description": "**本题的前两段（不包括本段）与“New Elements: Part 1”完全相同。除此之外，两题可以独立解决；你无需阅读或解决其中一题才能理解或解决另一题。**\n\nMuriel 正在探索两种她命名为 Codium 和 Jamarium 的新元素。她尚未能将它们分离出来，但她希望通过间接方法研究它们的一些重要性质，比如它们的原子量。由于 Muriel 只研究 Codium 的单一同位素和 Jamarium 的单一同位素，它们的原子量都是严格正整数。\n\nMuriel 成功合成了 $\\mathbf{N}$ 种不同的分子，每种分子都包含至少一个 Codium 原子和至少一个 Jamarium 原子，且不含其他元素。对于每种分子，她都知道其中每种元素的原子数。分子的分子量等于其所含所有原子的原子量之和。\n\n作为第一步，Muriel 按照分子量严格递增的顺序对这些分子进行了排序。现在她想找出 Codium 和 Jamarium 的原子量的所有可能整数取值对，使其与分子的排序一致。由于她知道可能存在多个满足条件的取值对，她希望找到 Codium 原子量最小的那一组。如果有多组 Codium 原子量相同，则选择 Jamarium 原子量最小的那一组。", "inputFormat": "输入的第一行是测试用例数 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试数据。每组测试数据的第一行为一个整数 $\\mathbf{N}$，表示分子的数量。接下来的 $\\mathbf{N}$ 行，每行包含两个整数 $\\mathbf{C_i}$ 和 $\\mathbf{J_i}$，分别表示第 $i$ 个分子中 Codium 和 Jamarium 的原子数。分子按分子量严格递增的顺序给出。", "outputFormat": "对于每组测试数据，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 若不存在满足条件的原子量整数对，则输出大写的 IMPOSSIBLE；否则输出两个整数 $c\\ j$，分别为 Codium 和 Jamarium 的原子量，且需满足上述最小化规则。", "hint": "**样例解释**\n\n在样例 1 中，最后两个分子的区别在于多了一个元素的原子。由于多一个 Codium 的分子整体更重，可以推断 Codium 的原子量大于 Jamarium。取 Codium 和 Jamarium 的原子量分别为 2 和 1 时，分子的分子量分别为 $1 \\times 2 + 1 \\times 1 = 3$，$1 \\times 2 + 2 \\times 1 = 4$，$2 \\times 2 + 1 \\times 1 = 5$，满足严格递增的顺序。由于 Codium 更重，2 是 Codium 的最小原子量，1 是 Jamarium 的最小原子量。\n\n设样例 2 中分子的分子量依次为 $a$、$b$、$c$ 和 $d$。根据原子数，有 $d = 2 \\times a$ 且 $c = 2 \\times b$。由 $a < b$ 可得 $d = 2 \\times a < 2 \\times b = c$，这意味着不存在一组原子量能使分子的分子量严格递增。\n\n在样例 3 中，分子的原子总数恰好严格递增。因此，令两种元素的原子量都为 1，可以使分子的分子量严格递增。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $2 \\leq \\mathbf{N} \\leq 10$。\n- 对所有 $i \\neq j$，$(\\mathbf{C_i}, \\mathbf{J_i}) \\neq (\\mathbf{C_j}, \\mathbf{J_j})$（所有分子都不同）。\n\n**测试点 1（10 分，可见）**\n\n- 对所有 $i$，$1 \\leq \\mathbf{C_i} \\leq 100$。\n- 对所有 $i$，$1 \\leq \\mathbf{J_i} \\leq 100$。\n\n**测试点 2（16 分，隐藏）**\n\n- 对所有 $i$，$1 \\leq \\mathbf{C_i} \\leq 10^9$。\n- 对所有 $i$，$1 \\leq \\mathbf{J_i} \\leq 10^9$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13118", "type": "P", "difficulty": 6, "samples": [["3\n2\n1 2\n1 2\n1 0\n2\n1 2\n1 2\n0 0\n4\n2 4\n3 4\n2 4\n2 3\n10 10 10 10", "Case #1: UNBOUNDED\nCase #2: 0\nCase #3: 10"]], "limits": {"time": [20000, 20000, 20000, 20000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "图论", "2019", "拓扑排序", "强连通分量", "Google Code Jam"], "title": "[GCJ 2019 #2] Contransmutation", "background": "", "description": "Last year, we asked you to help us convert expensive metals into lead. (You do not need to know anything about the previous problem to solve this one.) But your country's leader is still greedy for more lead!\n\nThere are $\\mathbf{M}$ metals known in the world; lead is metal number 1 on your periodic table. Your country's leader has asked you to use the metals in the treasury to make as much lead as possible.\n\nFor each metal (including lead), you know exactly one formula that lets you destroy one gram of that metal and create one gram each of two metals. (It is best not to think too much about the principle of mass conservation!) Note that it is possible that the formula for the i-th metal might produce the i-th metal as one of the products. The formulas do not work with partial grams. However, you can use each formula as often as you would like (or not at all), as long as you have a gram of the required ingredient.\n\nIf you make optimal choices, what is the largest number of grams of lead you can end up with, or is it unbounded? If it is not unbounded: since the output can be a really big number, we only ask you to output the remainder of dividing the result by the prime $10^9+7$ (that is, $1000000007$).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line with an integer $\\mathbf{M}$: the number of metals known in the world. Then there are $\\mathbf{M}$ more lines with two integers $\\mathbf{R_{i1}}$ and $\\mathbf{R_{i2}}$ each; the i-th of these lines, counting starting from 1, indicates that you can destroy one gram of metal i to create one gram of metal $\\mathbf{R_{i1}}$ and one gram of metal $\\mathbf{R_{i2}}$. Finally, there is one line with $\\mathbf{M}$ integers $\\mathbf{G_1}$, $\\mathbf{G_2}$, ..., $\\mathbf{G_M}$; $\\mathbf{G_i}$ is the number of grams of metal i in the treasury. Lead is metal 1.\n", "outputFormat": "For each test case, output one line containing `Case #x: y` where $x$ is the test case number (starting from 1). If there is no bound on the maximum amount of lead that can be produced, $y$ must be UNBOUNDED. Otherwise, $y$ must be the largest amount of lead, in grams, that you can end up with, modulo the prime $10^9+7$ (that is, $1000000007$).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, you have one formula that turns 1 gram of lead into 1 gram of lead and 1 gram of the second metal, and another formula that turns 1 gram of the second metal into 1 gram of lead and 1 gram of the second metal. You can alternate between these formulas to produce as much of both metals as you want.\n\nSample Case #2 has the same formulas as Sample Case #1, but you have no metals to start with!\n\nIn Sample Case #3, none of the formulas help you produce more lead, so you cannot end up with more lead than you started with.\n\n**Limits**\n\n- $1 \\leq \\mathbf{R_{i1}} < \\mathbf{R_{i2}} \\leq \\mathbf{M}$, for all $i$.\n\n**Test set 1 (7 Pts, Visible)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{M} \\leq 10$.\n- $0 \\leq \\mathbf{G_i} \\leq 10$, for all $i$.\n\n**Test set 2 (16 Pts, Hidden)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{M} \\leq 100$.\n- $0 \\leq \\mathbf{G_i} \\leq 10^9$, for all $i$.\n\n**Test set 3 (6 Pts, Hidden)**\n\n- $1 \\leq \\mathbf{T} \\leq 5$.\n- $2 \\leq \\mathbf{M} \\leq 10^5$.\n- $0 \\leq \\mathbf{G_i} \\leq 10^9$, for all $i$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #2] Contransmutation", "background": "", "description": "Last year, we asked you to help us convert expensive metals into lead. (You do not need to know anything about the previous problem to solve this one.) But your country's leader is still greedy for more lead!\n\nThere are $\\mathbf{M}$ metals known in the world; lead is metal number 1 on your periodic table. Your country's leader has asked you to use the metals in the treasury to make as much lead as possible.\n\nFor each metal (including lead), you know exactly one formula that lets you destroy one gram of that metal and create one gram each of two metals. (It is best not to think too much about the principle of mass conservation!) Note that it is possible that the formula for the i-th metal might produce the i-th metal as one of the products. The formulas do not work with partial grams. However, you can use each formula as often as you would like (or not at all), as long as you have a gram of the required ingredient.\n\nIf you make optimal choices, what is the largest number of grams of lead you can end up with, or is it unbounded? If it is not unbounded: since the output can be a really big number, we only ask you to output the remainder of dividing the result by the prime $10^9+7$ (that is, $1000000007$).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line with an integer $\\mathbf{M}$: the number of metals known in the world. Then there are $\\mathbf{M}$ more lines with two integers $\\mathbf{R_{i1}}$ and $\\mathbf{R_{i2}}$ each; the i-th of these lines, counting starting from 1, indicates that you can destroy one gram of metal i to create one gram of metal $\\mathbf{R_{i1}}$ and one gram of metal $\\mathbf{R_{i2}}$. Finally, there is one line with $\\mathbf{M}$ integers $\\mathbf{G_1}$, $\\mathbf{G_2}$, ..., $\\mathbf{G_M}$; $\\mathbf{G_i}$ is the number of grams of metal i in the treasury. Lead is metal 1.\n", "outputFormat": "For each test case, output one line containing `Case #x: y` where $x$ is the test case number (starting from 1). If there is no bound on the maximum amount of lead that can be produced, $y$ must be UNBOUNDED. Otherwise, $y$ must be the largest amount of lead, in grams, that you can end up with, modulo the prime $10^9+7$ (that is, $1000000007$).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, you have one formula that turns 1 gram of lead into 1 gram of lead and 1 gram of the second metal, and another formula that turns 1 gram of the second metal into 1 gram of lead and 1 gram of the second metal. You can alternate between these formulas to produce as much of both metals as you want.\n\nSample Case #2 has the same formulas as Sample Case #1, but you have no metals to start with!\n\nIn Sample Case #3, none of the formulas help you produce more lead, so you cannot end up with more lead than you started with.\n\n**Limits**\n\n- $1 \\leq \\mathbf{R_{i1}} < \\mathbf{R_{i2}} \\leq \\mathbf{M}$, for all $i$.\n\n**Test set 1 (7 Pts, Visible)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{M} \\leq 10$.\n- $0 \\leq \\mathbf{G_i} \\leq 10$, for all $i$.\n\n**Test set 2 (16 Pts, Hidden)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{M} \\leq 100$.\n- $0 \\leq \\mathbf{G_i} \\leq 10^9$, for all $i$.\n\n**Test set 3 (6 Pts, Hidden)**\n\n- $1 \\leq \\mathbf{T} \\leq 5$.\n- $2 \\leq \\mathbf{M} \\leq 10^5$.\n- $0 \\leq \\mathbf{G_i} \\leq 10^9$, for all $i$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #2] Contransmutation", "background": null, "description": "去年，我们曾请你帮忙将昂贵的金属转化为铅。（你无需了解前一道题即可解答本题。）但你们国家的领导人依然贪婪地渴望获得更多的铅！\n\n世界上已知有 $\\mathbf{M}$ 种金属；在你的元素周期表上，铅是第 1 号金属。你们国家的领导人要求你利用国库中的金属，尽可能多地制造铅。\n\n对于每种金属（包括铅），你都知道恰好有一种配方，可以消耗 1 克该金属，并各生成 1 克另外两种金属。（关于质量守恒原理，最好不要深究！）注意，第 $i$ 种金属的配方可能会生成第 $i$ 种金属本身作为产物之一。配方不能对部分克数的金属起作用。然而，只要你拥有所需金属的 1 克，你可以任意多次（或不使用）使用每种配方。\n\n如果你做出最优选择，最终最多能获得多少克铅，或者说这个数量是否有限？如果答案有限，我们只要求你输出结果除以质数 $10^9+7$（即 $1000000007$）的余数。", "inputFormat": "输入的第一行是测试用例数 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试用例。每组测试用例首先有一行整数 $\\mathbf{M}$，表示已知的金属种类数。接下来有 $\\mathbf{M}$ 行，每行包含两个整数 $\\mathbf{R_{i1}}$ 和 $\\mathbf{R_{i2}}$；第 $i$ 行（从 1 开始计数）表示你可以消耗 1 克第 $i$ 种金属，生成 1 克第 $\\mathbf{R_{i1}}$ 种金属和 1 克第 $\\mathbf{R_{i2}}$ 种金属。最后一行包含 $\\mathbf{M}$ 个整数 $\\mathbf{G_1}, \\mathbf{G_2}, \\ldots, \\mathbf{G_M}$，其中 $\\mathbf{G_i}$ 表示国库中第 $i$ 种金属的克数。铅为第 1 号金属。", "outputFormat": "对于每组测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是你最终能获得的最大铅克数。如果最大铅克数没有上限，则 $y$ 必须为 UNBOUNDED。否则，$y$ 必须是你最终能获得的最大铅克数对质数 $10^9+7$（即 $1000000007$）取余的结果。", "hint": "**样例解释**\n\n在样例 1 中，你有一个配方可以将 1 克铅变为 1 克铅和 1 克第二种金属，另一个配方可以将 1 克第二种金属变为 1 克铅和 1 克第二种金属。你可以交替使用这两个配方，制造出任意多的两种金属。\n\n样例 2 的配方与样例 1 相同，但你一开始没有任何金属！\n\n样例 3 中，所有配方都无法帮助你制造更多的铅，因此你最终获得的铅不会超过初始拥有的数量。\n\n**数据范围**\n\n- 对所有 $i$，$1 \\leq \\mathbf{R_{i1}} < \\mathbf{R_{i2}} \\leq \\mathbf{M}$。\n\n**测试点 1（7 分，公开）**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $2 \\leq \\mathbf{M} \\leq 10$。\n- $0 \\leq \\mathbf{G_i} \\leq 10$。\n\n**测试点 2（16 分，隐藏）**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $2 \\leq \\mathbf{M} \\leq 100$。\n- $0 \\leq \\mathbf{G_i} \\leq 10^9$。\n\n**测试点 3（6 分，隐藏）**\n\n- $1 \\leq \\mathbf{T} \\leq 5$。\n- $2 \\leq \\mathbf{M} \\leq 10^5$。\n- $0 \\leq \\mathbf{G_i} \\leq 10^9$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13119", "type": "P", "difficulty": 5, "samples": [["", ""]], "limits": {"time": [50000, 50000, 50000], "memory": [1048576, 1048576, 1048576]}, "tags": ["博弈论", "2019", "交互题", "Special Judge", "SG 函数", "Google Code Jam"], "title": "[GCJ 2019 #3] Zillionim", "background": "", "description": "Zillionim is a turn-based game for two players. Initially, $10^{12}$ coins are arranged end-to-end in a single line, numbered from 1 to $10^{12}$ from left to right. During a turn, a player must select $10^{10}$ consecutive coins and remove them. Two coins that were not originally consecutive do not become consecutive even if all of the coins in between them are removed.\n\nOn their turn, a player makes a valid move if possible, and then it is their opponent's turn. If a player cannot make a valid move on their turn, they lose the game (and the opponent wins the game).\n\nBecause our engineers are still hard at work training our machine learning model to play Zillionim, we have created a simple AI that plays Zillionim by making random moves. The AI always gets the first turn. On each of the AI's turns, the AI determines all valid moves and chooses one of them uniformly at random.\n\nCan you beat this AI... at least most of the time?\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing two integers $\\mathbf{T}$, the number of test cases, and $\\mathbf{W}$, the minimum number of games you need to win for your solution to be considered correct. Then, you need to process $\\mathbf{T}$ test cases, each of which is a single game of Zillionim.\n\nEach test case is processed by making exchanges with the judge until one player wins the game. For each exchange, the judge first outputs a single line with a single integer $\\mathbf{P}$, to be interpreted as follows:\n\n* If $1 \\leq \\mathbf{P} \\leq 10^{12} - 10^{10} + 1$, then the AI has removed coins numbered $\\mathbf{P}$, $\\mathbf{P} + 1$, ..., $\\mathbf{P} + 10^{10} - 1$ and it is your turn. Note that this means there is at least one valid move remaining for you to play. The AI always plays a valid move.\n* If $\\mathbf{P} = -2$, your last move caused you to win the current game.\n* If $\\mathbf{P} = -3$, the AI has made a move that caused it to win the current game. Notice that in this case, the judge does not send you the AI's last move.\n* If $\\mathbf{P} = -1$, the last information you sent to the judge was malformed data or an invalid move (out of range or attempting to remove coins that were not there), meaning that you will get a Wrong Answer verdict for not playing correctly (more below).\n\nAfter receiving a positive integer $\\mathbf{P}$, you should send back a single line with a positive integer $\\mathbf{Q}$ ($1 \\leq \\mathbf{Q} \\leq 10^{12} - 10^{10} + 1$) representing that you are removing coins numbered $\\mathbf{Q}$, $\\mathbf{Q} + 1$, ..., $\\mathbf{Q} + 10^{10} - 1$. Each of these coins must not have been previously removed during the current game.\n\nAfter the judge sends a -2 or -3, if it was the last game, the judge will terminate and so should your program. Otherwise, the judge will proceed to send data corresponding to the first exchange of the next game. The judge will not check how many games you have won or lost until all games have been processed correctly. For example, if you win $\\mathbf{T} - 1$ games and then send malformed data during the last game, you will receive a Wrong Answer verdict, regardless of the value of $\\mathbf{W}$.\n\nAfter receiving a -1, your program should terminate to receive a Wrong Answer verdict. If your program continues to wait for the judge after receiving -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit normally and within the time limit to receive a Wrong Answer verdict instead of a Runtime Error or Time Limit Exceeded.\n\nThe seed for the random generator is predetermined (and is different) for each game. This means that two submissions that make the exact same sequence of moves in a given game will receive the exact same sequence of moves from the AI for that game. It also means the play of the AI in a game does not depend, even in the pseudo-random generation sense, on the plays made in previous games within the same test set.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\nFor simplicity, the following interaction uses 50 coins in total instead of $10^{12}$, and each move removes 10 consecutive coins instead of $10^{10}$. The rules are otherwise the same.\n\n```\n  t, w = readline_int_list()   // reads 500 into t and 300 into w\n  p = readline_int()           // reads 23 into p; this is the beginning of the first game. The\n                               //   AI has taken coins 23 through 32, inclusive.\n  printline 38 to stdout       // we decide to take coins 38 through 47, inclusive\n  flush stdout\n  p = readline_int()           // reads 3 into p. The AI has taken coins 3 through 12, inclusive.\n  printline 13 to stdout       // we decide to take coins 13 through 22, inclusive\n                               //  (and this is our only remaining move!)\n  flush stdout\n  p = readline_int()           // reads -2 into p. We won the first game since the AI had no move.\n  p = readline_int()           // reads 32 into p; this is the beginning of the second game. The\n                               //   AI has taken coins 32 through 41, inclusive.\n  printline 13 to stdout       // we decide to take coins 13 through 22, inclusive\n  flush stdout\n  p = readline_int()           // reads -3 into p. We don't know the AI's move, but it left us\n                               //   with no valid move, so we lost the second game.\n  p = readline_int()           // reads 10 into p; this is the beginning of the third game. The\n                               //   AI has taken coins 10 through 19, inclusive.\n  printline 0 to stdout        // we select an invalid index (coin numbering starts at 1!)\n  flush stdout\n  p = readline_int()           // reads -1 into p -- we have made a mistake!\n  exit                         // exits to avoid an ambiguous TLE error\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $\\mathbf{T} = 500$.\n- $-3 \\leq \\mathbf{P} \\leq 10^{12} - 10^{10} + 1$.\n- $\\mathbf{P} \\neq 0$.\n- $\\mathbf{P}$ represents a valid play or valid information about the game's status, as explained above.\n\n**Test set 1 (1 Pt, Visible)**\n\n- $\\mathbf{W} = 300$.\n\n**Test set 2 (5 Pts, Visible)**\n\n- $\\mathbf{W} = 475$.\n\n**Test set 3 (6 Pts, Visible)**\n\n- $\\mathbf{W} = 499$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #3] Zillionim", "background": "", "description": "Zillionim is a turn-based game for two players. Initially, $10^{12}$ coins are arranged end-to-end in a single line, numbered from 1 to $10^{12}$ from left to right. During a turn, a player must select $10^{10}$ consecutive coins and remove them. Two coins that were not originally consecutive do not become consecutive even if all of the coins in between them are removed.\n\nOn their turn, a player makes a valid move if possible, and then it is their opponent's turn. If a player cannot make a valid move on their turn, they lose the game (and the opponent wins the game).\n\nBecause our engineers are still hard at work training our machine learning model to play Zillionim, we have created a simple AI that plays Zillionim by making random moves. The AI always gets the first turn. On each of the AI's turns, the AI determines all valid moves and chooses one of them uniformly at random.\n\nCan you beat this AI... at least most of the time?\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing two integers $\\mathbf{T}$, the number of test cases, and $\\mathbf{W}$, the minimum number of games you need to win for your solution to be considered correct. Then, you need to process $\\mathbf{T}$ test cases, each of which is a single game of Zillionim.\n\nEach test case is processed by making exchanges with the judge until one player wins the game. For each exchange, the judge first outputs a single line with a single integer $\\mathbf{P}$, to be interpreted as follows:\n\n* If $1 \\leq \\mathbf{P} \\leq 10^{12} - 10^{10} + 1$, then the AI has removed coins numbered $\\mathbf{P}$, $\\mathbf{P} + 1$, ..., $\\mathbf{P} + 10^{10} - 1$ and it is your turn. Note that this means there is at least one valid move remaining for you to play. The AI always plays a valid move.\n* If $\\mathbf{P} = -2$, your last move caused you to win the current game.\n* If $\\mathbf{P} = -3$, the AI has made a move that caused it to win the current game. Notice that in this case, the judge does not send you the AI's last move.\n* If $\\mathbf{P} = -1$, the last information you sent to the judge was malformed data or an invalid move (out of range or attempting to remove coins that were not there), meaning that you will get a Wrong Answer verdict for not playing correctly (more below).\n\nAfter receiving a positive integer $\\mathbf{P}$, you should send back a single line with a positive integer $\\mathbf{Q}$ ($1 \\leq \\mathbf{Q} \\leq 10^{12} - 10^{10} + 1$) representing that you are removing coins numbered $\\mathbf{Q}$, $\\mathbf{Q} + 1$, ..., $\\mathbf{Q} + 10^{10} - 1$. Each of these coins must not have been previously removed during the current game.\n\nAfter the judge sends a -2 or -3, if it was the last game, the judge will terminate and so should your program. Otherwise, the judge will proceed to send data corresponding to the first exchange of the next game. The judge will not check how many games you have won or lost until all games have been processed correctly. For example, if you win $\\mathbf{T} - 1$ games and then send malformed data during the last game, you will receive a Wrong Answer verdict, regardless of the value of $\\mathbf{W}$.\n\nAfter receiving a -1, your program should terminate to receive a Wrong Answer verdict. If your program continues to wait for the judge after receiving -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit normally and within the time limit to receive a Wrong Answer verdict instead of a Runtime Error or Time Limit Exceeded.\n\nThe seed for the random generator is predetermined (and is different) for each game. This means that two submissions that make the exact same sequence of moves in a given game will receive the exact same sequence of moves from the AI for that game. It also means the play of the AI in a game does not depend, even in the pseudo-random generation sense, on the plays made in previous games within the same test set.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\nFor simplicity, the following interaction uses 50 coins in total instead of $10^{12}$, and each move removes 10 consecutive coins instead of $10^{10}$. The rules are otherwise the same.\n\n```\n  t, w = readline_int_list()   // reads 500 into t and 300 into w\n  p = readline_int()           // reads 23 into p; this is the beginning of the first game. The\n                               //   AI has taken coins 23 through 32, inclusive.\n  printline 38 to stdout       // we decide to take coins 38 through 47, inclusive\n  flush stdout\n  p = readline_int()           // reads 3 into p. The AI has taken coins 3 through 12, inclusive.\n  printline 13 to stdout       // we decide to take coins 13 through 22, inclusive\n                               //  (and this is our only remaining move!)\n  flush stdout\n  p = readline_int()           // reads -2 into p. We won the first game since the AI had no move.\n  p = readline_int()           // reads 32 into p; this is the beginning of the second game. The\n                               //   AI has taken coins 32 through 41, inclusive.\n  printline 13 to stdout       // we decide to take coins 13 through 22, inclusive\n  flush stdout\n  p = readline_int()           // reads -3 into p. We don't know the AI's move, but it left us\n                               //   with no valid move, so we lost the second game.\n  p = readline_int()           // reads 10 into p; this is the beginning of the third game. The\n                               //   AI has taken coins 10 through 19, inclusive.\n  printline 0 to stdout        // we select an invalid index (coin numbering starts at 1!)\n  flush stdout\n  p = readline_int()           // reads -1 into p -- we have made a mistake!\n  exit                         // exits to avoid an ambiguous TLE error\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $\\mathbf{T} = 500$.\n- $-3 \\leq \\mathbf{P} \\leq 10^{12} - 10^{10} + 1$.\n- $\\mathbf{P} \\neq 0$.\n- $\\mathbf{P}$ represents a valid play or valid information about the game's status, as explained above.\n\n**Test set 1 (1 Pt, Visible)**\n\n- $\\mathbf{W} = 300$.\n\n**Test set 2 (5 Pts, Visible)**\n\n- $\\mathbf{W} = 475$.\n\n**Test set 3 (6 Pts, Visible)**\n\n- $\\mathbf{W} = 499$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #3] Zillionim", "background": null, "description": "Zillionim 是一个由两名玩家轮流进行的回合制游戏。最初，$10^{12}$ 枚硬币首尾相连排成一行，从左到右编号为 $1$ 到 $10^{12}$。每一回合，玩家必须选择 $10^{10}$ 枚连续的硬币并将其移除。即使中间的硬币被移除，原本不相邻的两枚硬币也不会变得相邻。\n\n在自己的回合，玩家如果可以，则必须进行一次合法操作，然后轮到对手。如果某位玩家在自己的回合无法进行合法操作，则该玩家输掉本局游戏（对手获胜）。\n\n由于我们的工程师仍在努力训练我们的机器学习模型来玩 Zillionim，我们为 Zillionim 创建了一个简单的 AI，它会随机进行操作。AI 总是先手。在每次 AI 的回合，AI 会确定所有合法操作，并从中均匀随机选择一个。\n\n你能击败这个 AI 吗……至少大多数时候？\n\n### 交互协议\n\n本题为交互题。\n\n最开始，你的程序应读取一行包含两个整数 $\\mathbf{T}$（测试用例数量）和 $\\mathbf{W}$（你的解答被判为正确所需赢下的最少局数）。然后，你需要处理 $\\mathbf{T}$ 个测试用例，每个用例即为一局 Zillionim 游戏。\n\n每个测试用例通过与评测器的多轮交互进行，直到某一方获胜。每轮交互中，评测器首先输出一行，内容为一个整数 $\\mathbf{P}$，含义如下：\n\n- 如果 $1 \\leq \\mathbf{P} \\leq 10^{12} - 10^{10} + 1$，则表示 AI 移除了编号为 $\\mathbf{P}$ 到 $\\mathbf{P} + 10^{10} - 1$ 的硬币，现在轮到你。注意，这意味着你至少还有一个合法操作可以进行。AI 总是会进行合法操作。\n- 如果 $\\mathbf{P} = -2$，表示你上一次操作后赢得了本局游戏。\n- 如果 $\\mathbf{P} = -3$，表示 AI 上一次操作后赢得了本局游戏。注意此时评测器不会告知你 AI 的最后一步操作。\n- 如果 $\\mathbf{P} = -1$，表示你上一次发送给评测器的信息有误（数据格式错误、操作越界或试图移除已被移除的硬币），你将因未正确操作而被判为 Wrong Answer（见下文）。\n\n在收到正整数 $\\mathbf{P}$ 后，你应输出一行，内容为正整数 $\\mathbf{Q}$（$1 \\leq \\mathbf{Q} \\leq 10^{12} - 10^{10} + 1$），表示你要移除编号为 $\\mathbf{Q}$ 到 $\\mathbf{Q} + 10^{10} - 1$ 的硬币。你移除的这些硬币必须在当前局中尚未被移除。\n\n当评测器发送 $-2$ 或 $-3$ 后，如果这是最后一局，评测器会终止，你的程序也应随之终止。否则，评测器会继续发送下一局的首轮数据。在所有局都正确处理完毕前，评测器不会检查你赢了多少局。例如，如果你赢了 $\\mathbf{T} - 1$ 局，但在最后一局发送了错误数据，你将被判为 Wrong Answer，无论 $\\mathbf{W}$ 的值是多少。\n\n收到 $-1$ 后，你的程序应立即终止以获得 Wrong Answer 判定。如果收到 $-1$ 后仍继续等待评测器数据，你的程序将因超时被判为 Time Limit Exceeded。请注意，程序应自行正常退出，以获得 Wrong Answer 而不是 Runtime Error 或 Time Limit Exceeded。\n\n每一局的随机数种子是预先设定且互不相同的。这意味着，如果两份提交在同一局中做出完全相同的操作序列，将收到 AI 完全相同的操作序列。AI 在一局中的操作不会受到同一测试集内前几局操作的影响（即伪随机生成器的状态是独立的）。", "inputFormat": "见交互协议。", "outputFormat": "见交互协议。", "hint": "**交互样例**\n\n为简化说明，以下交互样例假设总共有 $50$ 枚硬币，每次移除 $10$ 枚连续硬币，其余规则与原题一致。\n\n```\n  t, w = readline_int_list()   // 读取 t=500, w=300\n  p = readline_int()           // 读取 p=23，表示第一局 AI 移除了 23~32 号硬币\n  printline 38 to stdout       // 我们选择移除 38~47 号硬币\n  flush stdout\n  p = readline_int()           // 读取 p=3，AI 移除了 3~12 号硬币\n  printline 13 to stdout       // 我们选择移除 13~22 号硬币（这是我们唯一剩下的合法操作）\n  flush stdout\n  p = readline_int()           // 读取 p=-2，表示我们赢了第一局\n  p = readline_int()           // 读取 p=32，第二局开始，AI 移除了 32~41 号硬币\n  printline 13 to stdout       // 我们选择移除 13~22 号硬币\n  flush stdout\n  p = readline_int()           // 读取 p=-3，AI 获胜，我们无法操作\n  p = readline_int()           // 读取 p=10，第三局开始，AI 移除了 10~19 号硬币\n  printline 0 to stdout        // 我们选择了非法下标（硬币编号从 1 开始！）\n  flush stdout\n  p = readline_int()           // 读取 p=-1，表示我们操作有误\n  exit                         // 立即退出，避免超时\n```\n\n你可以使用本题的测试工具在本地或平台上进行测试。若在本地测试，你需要让测试工具与自己的代码并行运行；可使用我们的 [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)。更多信息请阅读该文件中的注释。\n\n测试工具的使用说明已包含在工具文件的注释中。我们鼓励你自行添加测试用例。请注意，测试工具旨在模拟评测系统，但**并非**真实评测系统，可能存在行为差异。\n\n**数据范围**\n\n- $\\mathbf{T} = 500$。\n- $-3 \\leq \\mathbf{P} \\leq 10^{12} - 10^{10} + 1$。\n- $\\mathbf{P} \\neq 0$。\n- $\\mathbf{P}$ 表示一次合法操作或游戏状态信息，详见上文。\n\n**测试点 1（1 分，公开）**\n\n- $\\mathbf{W} = 300$。\n\n**测试点 2（5 分，公开）**\n\n- $\\mathbf{W} = 475$。\n\n**测试点 3（6 分，公开）**\n\n- $\\mathbf{W} = 499$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13120", "type": "P", "difficulty": 5, "samples": [["3\n3\n2 1 2\n5\n1 6 2 5 7\n4\n1000000000 1 1 1000000000", "Case #1: 1\nCase #2: 16\nCase #3: 999999991"]], "limits": {"time": [30000, 30000, 30000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2019", "单调栈", "Google Code Jam"], "title": "[GCJ 2019 #3] Pancake Pyramid", "background": "", "description": "You have just finished cooking for some diners at the Infinite House of Pancakes. There are $\\mathbf{S}$ stacks of pancakes in all, and you have arranged them in a line, such that the i-th stack from the left (counting starting from 1) has $\\mathbf{P}_\\mathbf{i}$ pancakes.\n\nYour supervisor was about to bring out the stacks to the customers, but then it occurred to her that a picture of the stacks might make for a good advertisement. However, she is worried that there might be too many stacks, so she intends to remove the $\\mathbf{L}$ leftmost stacks and the $\\mathbf{R}$ rightmost stacks, where $\\mathbf{L}$ and $\\mathbf{R}$ are nonnegative integers such that $\\mathbf{L} + \\mathbf{R} \\leq \\mathbf{S} - 3$. (Notice that at least 3 stacks of pancakes will remain after the removal.)\n\nYour supervisor also thinks the remaining stacks will look aesthetically pleasing if they have the pyramid property. A sequence of $\\mathbf{N}$ stacks of heights $\\mathbf{H}_1, \\mathbf{H}_2, \\ldots, \\mathbf{H}_\\mathbf{N}$ has the pyramid property if there exists an integer $\\mathbf{j}$ ($1 \\leq \\mathbf{j} \\leq \\mathbf{N}$) such that $\\mathbf{H}_1 \\leq \\mathbf{H}_2 \\leq \\ldots \\leq \\mathbf{H}_{\\mathbf{j}-1} \\leq \\mathbf{H}_\\mathbf{j}$ and $\\mathbf{H}_\\mathbf{j} \\geq \\mathbf{H}_{\\mathbf{j}+1} \\geq \\ldots \\geq \\mathbf{H}_{\\mathbf{N}-1} \\geq \\mathbf{H}_\\mathbf{N}$. (It is possible that this sequence might not look much like a typical \"pyramid\" — a group of stacks of the same size has the pyramid property, and so does a group in which the stack heights are nondecreasing from left to right, among other examples.)\n\nNote that the sequence of stacks remaining after your supervisor removes the $\\mathbf{L}$ leftmost and $\\mathbf{R}$ rightmost stacks might not yet have the pyramid property... but you can fix that by adding pancakes to one or more of the stacks! The pyramidification cost of a sequence of stacks is the minimum total number of pancakes that must be added to stacks to give the sequence the pyramid property.\n\nWhile your manager is carefully deciding which values of $\\mathbf{L}$ and $\\mathbf{R}$ to choose, you have started to wonder what the sum of the pyramidification costs over all valid choices of $\\mathbf{L}$ and $\\mathbf{R}$ is. Compute this sum, modulo the prime $10^9+7$ ($1000000007$).\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line containing one integer $\\mathbf{S}$: the number of stacks of pancakes. Then, there is one more line containing $\\mathbf{S}$ integers $\\mathbf{P}_1, \\mathbf{P}_2, \\ldots, \\mathbf{P}_\\mathbf{S}$. The i-th of these is the number of pancakes in the i-th stack from the left.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the sum of the pyramidification costs over all valid choices of $\\mathbf{L}$ and $\\mathbf{R}$, modulo the prime $10^9+7$ ($1000000007$).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, your supervisor must choose $\\mathbf{L} = 0$ and $\\mathbf{R} = 0$, so that is the only scenario you need to consider. The optimal strategy for that scenario is to add a single pancake to the middle stack. Although the resulting sequence of stacks looks flat, notice that it has the pyramid property; in fact, any index will work as the $\\mathbf{j}$ value.\n\nIn Sample Case #2, here are all possible choices of $\\mathbf{L}$ and $\\mathbf{R}$, the corresponding remaining stacks, and what you should do in each scenario.\n\n* $\\mathbf{L} = 0$, $\\mathbf{R} = 0$: $\\mathbf{H} = [1 \\ 6 \\ 2 \\ 5 \\ 7]$. The optimal solution is to add four pancakes to the third stack and one pancake to the fourth stack. Then we have $[1 \\ 6 \\ 6 \\ 6 \\ 7]$, which has the pyramid property with $\\mathbf{j} = 5$.\n* $\\mathbf{L} = 0$, $\\mathbf{R} = 1$: $\\mathbf{H} = [1 \\ 6 \\ 2 \\ 5]$. The optimal solution is to add three pancakes to the third stack. Then we have $[1 \\ 6 \\ 5 \\ 5]$, which has the pyramid property with $\\mathbf{j} = 2$.\n* $\\mathbf{L} = 0$, $\\mathbf{R} = 2$: $\\mathbf{H} = [1 \\ 6 \\ 2]$. This already has the pyramid property with $\\mathbf{j} = 2$.\n* $\\mathbf{L} = 1$, $\\mathbf{R} = 0$: $\\mathbf{H} = [6 \\ 2 \\ 5 \\ 7]$. The optimal solution is to add four pancakes to the second stack and one pancake to the third stack. Then we have $[6 \\ 6 \\ 6 \\ 7]$, which has the pyramid property with $\\mathbf{j} = 4$.\n* $\\mathbf{L} = 1$, $\\mathbf{R} = 1$: $\\mathbf{H} = [6 \\ 2 \\ 5]$. The optimal solution is to add three pancakes to the second stack. Then we have $[6 \\ 5 \\ 5]$, which has the pyramid property with $\\mathbf{j} = 1$.\n* $\\mathbf{L} = 2$, $\\mathbf{R} = 0$: $\\mathbf{H} = [2 \\ 5 \\ 7]$. This already has the pyramid property with $\\mathbf{j} = 3$.\n\nSo the answer is $(5 + 3 + 0 + 5 + 3 + 0)$ modulo $(10^9 + 7)$, which is $16$.\n\nIn Sample Case #3, we only need to add extra pancakes to create the pyramid property when $\\mathbf{L} = 0$ and $\\mathbf{R} = 0$. In that case, it is optimal to add $999999999$ pancakes to each of the second and third stacks. (We hope the diners are hungry!) So the answer is $(999999999 + 999999999)$ modulo $(10^9 + 7) = 999999991$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{P}_\\mathbf{i} \\leq 10^9$, for all $\\mathbf{i}$.\n\n**Test set 1 (5 Pts, Visible)**\n\n- $\\mathbf{S} = 3000$, for up to 20 test cases.\n- $3 \\leq \\mathbf{S} \\leq 500$, for all remaining cases.\n\n**Test set 2 (17 Pts, Hidden)**\n\n- $\\mathbf{S} = 10^6$, for up to 1 test case.\n- $\\mathbf{S} = 10^5$, for up to 3 test cases.\n- $3 \\leq \\mathbf{S} \\leq 10000$, for all remaining cases.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #3] Pancake Pyramid", "background": "", "description": "You have just finished cooking for some diners at the Infinite House of Pancakes. There are $\\mathbf{S}$ stacks of pancakes in all, and you have arranged them in a line, such that the i-th stack from the left (counting starting from 1) has $\\mathbf{P}_\\mathbf{i}$ pancakes.\n\nYour supervisor was about to bring out the stacks to the customers, but then it occurred to her that a picture of the stacks might make for a good advertisement. However, she is worried that there might be too many stacks, so she intends to remove the $\\mathbf{L}$ leftmost stacks and the $\\mathbf{R}$ rightmost stacks, where $\\mathbf{L}$ and $\\mathbf{R}$ are nonnegative integers such that $\\mathbf{L} + \\mathbf{R} \\leq \\mathbf{S} - 3$. (Notice that at least 3 stacks of pancakes will remain after the removal.)\n\nYour supervisor also thinks the remaining stacks will look aesthetically pleasing if they have the pyramid property. A sequence of $\\mathbf{N}$ stacks of heights $\\mathbf{H}_1, \\mathbf{H}_2, \\ldots, \\mathbf{H}_\\mathbf{N}$ has the pyramid property if there exists an integer $\\mathbf{j}$ ($1 \\leq \\mathbf{j} \\leq \\mathbf{N}$) such that $\\mathbf{H}_1 \\leq \\mathbf{H}_2 \\leq \\ldots \\leq \\mathbf{H}_{\\mathbf{j}-1} \\leq \\mathbf{H}_\\mathbf{j}$ and $\\mathbf{H}_\\mathbf{j} \\geq \\mathbf{H}_{\\mathbf{j}+1} \\geq \\ldots \\geq \\mathbf{H}_{\\mathbf{N}-1} \\geq \\mathbf{H}_\\mathbf{N}$. (It is possible that this sequence might not look much like a typical \"pyramid\" — a group of stacks of the same size has the pyramid property, and so does a group in which the stack heights are nondecreasing from left to right, among other examples.)\n\nNote that the sequence of stacks remaining after your supervisor removes the $\\mathbf{L}$ leftmost and $\\mathbf{R}$ rightmost stacks might not yet have the pyramid property... but you can fix that by adding pancakes to one or more of the stacks! The pyramidification cost of a sequence of stacks is the minimum total number of pancakes that must be added to stacks to give the sequence the pyramid property.\n\nWhile your manager is carefully deciding which values of $\\mathbf{L}$ and $\\mathbf{R}$ to choose, you have started to wonder what the sum of the pyramidification costs over all valid choices of $\\mathbf{L}$ and $\\mathbf{R}$ is. Compute this sum, modulo the prime $10^9+7$ ($1000000007$).\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line containing one integer $\\mathbf{S}$: the number of stacks of pancakes. Then, there is one more line containing $\\mathbf{S}$ integers $\\mathbf{P}_1, \\mathbf{P}_2, \\ldots, \\mathbf{P}_\\mathbf{S}$. The i-th of these is the number of pancakes in the i-th stack from the left.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the sum of the pyramidification costs over all valid choices of $\\mathbf{L}$ and $\\mathbf{R}$, modulo the prime $10^9+7$ ($1000000007$).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, your supervisor must choose $\\mathbf{L} = 0$ and $\\mathbf{R} = 0$, so that is the only scenario you need to consider. The optimal strategy for that scenario is to add a single pancake to the middle stack. Although the resulting sequence of stacks looks flat, notice that it has the pyramid property; in fact, any index will work as the $\\mathbf{j}$ value.\n\nIn Sample Case #2, here are all possible choices of $\\mathbf{L}$ and $\\mathbf{R}$, the corresponding remaining stacks, and what you should do in each scenario.\n\n* $\\mathbf{L} = 0$, $\\mathbf{R} = 0$: $\\mathbf{H} = [1 \\ 6 \\ 2 \\ 5 \\ 7]$. The optimal solution is to add four pancakes to the third stack and one pancake to the fourth stack. Then we have $[1 \\ 6 \\ 6 \\ 6 \\ 7]$, which has the pyramid property with $\\mathbf{j} = 5$.\n* $\\mathbf{L} = 0$, $\\mathbf{R} = 1$: $\\mathbf{H} = [1 \\ 6 \\ 2 \\ 5]$. The optimal solution is to add three pancakes to the third stack. Then we have $[1 \\ 6 \\ 5 \\ 5]$, which has the pyramid property with $\\mathbf{j} = 2$.\n* $\\mathbf{L} = 0$, $\\mathbf{R} = 2$: $\\mathbf{H} = [1 \\ 6 \\ 2]$. This already has the pyramid property with $\\mathbf{j} = 2$.\n* $\\mathbf{L} = 1$, $\\mathbf{R} = 0$: $\\mathbf{H} = [6 \\ 2 \\ 5 \\ 7]$. The optimal solution is to add four pancakes to the second stack and one pancake to the third stack. Then we have $[6 \\ 6 \\ 6 \\ 7]$, which has the pyramid property with $\\mathbf{j} = 4$.\n* $\\mathbf{L} = 1$, $\\mathbf{R} = 1$: $\\mathbf{H} = [6 \\ 2 \\ 5]$. The optimal solution is to add three pancakes to the second stack. Then we have $[6 \\ 5 \\ 5]$, which has the pyramid property with $\\mathbf{j} = 1$.\n* $\\mathbf{L} = 2$, $\\mathbf{R} = 0$: $\\mathbf{H} = [2 \\ 5 \\ 7]$. This already has the pyramid property with $\\mathbf{j} = 3$.\n\nSo the answer is $(5 + 3 + 0 + 5 + 3 + 0)$ modulo $(10^9 + 7)$, which is $16$.\n\nIn Sample Case #3, we only need to add extra pancakes to create the pyramid property when $\\mathbf{L} = 0$ and $\\mathbf{R} = 0$. In that case, it is optimal to add $999999999$ pancakes to each of the second and third stacks. (We hope the diners are hungry!) So the answer is $(999999999 + 999999999)$ modulo $(10^9 + 7) = 999999991$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{P}_\\mathbf{i} \\leq 10^9$, for all $\\mathbf{i}$.\n\n**Test set 1 (5 Pts, Visible)**\n\n- $\\mathbf{S} = 3000$, for up to 20 test cases.\n- $3 \\leq \\mathbf{S} \\leq 500$, for all remaining cases.\n\n**Test set 2 (17 Pts, Hidden)**\n\n- $\\mathbf{S} = 10^6$, for up to 1 test case.\n- $\\mathbf{S} = 10^5$, for up to 3 test cases.\n- $3 \\leq \\mathbf{S} \\leq 10000$, for all remaining cases.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #3] Pancake Pyramid", "background": null, "description": "你刚刚在“无限煎饼屋”为一些食客完成了烹饪。总共有 $S$ 堆煎饼，你将它们排成一行，第 $i$ 堆（从左到右，从 1 开始计数）有 $P_i$ 张煎饼。\n\n你的主管正准备把这些煎饼端给顾客，但她突然想到，给这些煎饼堆拍一张照片可能会成为很好的广告。不过，她担心煎饼堆太多，于是打算移除最左边的 $L$ 堆和最右边的 $R$ 堆，其中 $L$ 和 $R$ 是非负整数，满足 $L + R \\leq S - 3$。也就是说，移除后至少还会剩下 3 堆煎饼。\n\n你的主管还认为，剩下的煎饼堆如果满足“金字塔属性”会更美观。对于一组高度为 $H_1, H_2, \\ldots, H_N$ 的 $N$ 堆煎饼，如果存在一个整数 $j$（$1 \\leq j \\leq N$），使得 $H_1 \\leq H_2 \\leq \\ldots \\leq H_{j-1} \\leq H_j$ 且 $H_j \\geq H_{j+1} \\geq \\ldots \\geq H_{N-1} \\geq H_N$，那么这组煎饼堆就具有金字塔属性。（注意，这样的序列不一定看起来像传统的“金字塔”——比如所有堆高度相同的序列也满足金字塔属性，或者高度从左到右单调不减的序列也满足。）\n\n注意，经过移除 $L$ 个最左和 $R$ 个最右的煎饼堆后，剩下的序列可能还不满足金字塔属性……但你可以通过给某些堆添加煎饼来修正！一组煎饼堆的“金字塔化代价”定义为：使该序列满足金字塔属性所需添加的煎饼总数的最小值。\n\n当你的主管还在仔细考虑 $L$ 和 $R$ 的取值时，你开始思考：所有合法的 $L$ 和 $R$ 取值下，金字塔化代价之和是多少？请计算这个和，并对质数 $10^9+7$（$1000000007$）取模。", "inputFormat": "输入的第一行是测试用例数 $T$。接下来有 $T$ 组测试用例。每组测试用例的第一行为一个整数 $S$，表示煎饼堆的数量。接下来一行有 $S$ 个整数 $P_1, P_2, \\ldots, P_S$，第 $i$ 个数表示从左到右第 $i$ 堆煎饼的数量。", "outputFormat": "对于每组测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是所有合法 $L$ 和 $R$ 取值下金字塔化代价之和，对 $10^9+7$ 取模后的结果。", "hint": "**样例解释**\n\n在样例 1 中，你的主管只能选择 $L=0$ 且 $R=0$，所以只需考虑这一种情况。最优策略是给中间那一堆加一张煎饼。虽然最终序列看起来是平的，但它满足金字塔属性；实际上，任何一个位置都可以作为 $j$。\n\n在样例 2 中，所有可能的 $L$ 和 $R$ 取值、剩余的煎饼堆序列及最优操作如下：\n\n- $L=0$，$R=0$：$H=[1\\ 6\\ 2\\ 5\\ 7]$。最优解是给第三堆加 4 张煎饼，第四堆加 1 张煎饼，得到 $[1\\ 6\\ 6\\ 6\\ 7]$，此时 $j=5$。\n- $L=0$，$R=1$：$H=[1\\ 6\\ 2\\ 5]$。最优解是给第三堆加 3 张煎饼，得到 $[1\\ 6\\ 5\\ 5]$，此时 $j=2$。\n- $L=0$，$R=2$：$H=[1\\ 6\\ 2]$。本身就满足金字塔属性，$j=2$。\n- $L=1$，$R=0$：$H=[6\\ 2\\ 5\\ 7]$。最优解是给第二堆加 4 张煎饼，第三堆加 1 张煎饼，得到 $[6\\ 6\\ 6\\ 7]$，此时 $j=4$。\n- $L=1$，$R=1$：$H=[6\\ 2\\ 5]$。最优解是给第二堆加 3 张煎饼，得到 $[6\\ 5\\ 5]$，此时 $j=1$。\n- $L=2$，$R=0$：$H=[2\\ 5\\ 7]$。本身就满足金字塔属性，$j=3$。\n\n因此答案为 $(5 + 3 + 0 + 5 + 3 + 0)$ 对 $(10^9 + 7)$ 取模，即 $16$。\n\n在样例 3 中，只有 $L=0$ 且 $R=0$ 时需要额外加煎饼使其满足金字塔属性。在这种情况下，最优解是给第二堆和第三堆各加 $999999999$ 张煎饼。（希望食客们胃口够大！）所以答案为 $(999999999 + 999999999)$ 对 $(10^9 + 7)$ 取模，结果为 $999999991$。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- 对所有 $i$，$1 \\leq P_i \\leq 10^9$。\n\n**测试点 1（5 分，公开）**\n\n- $S = 3000$，最多 20 组测试用例。\n- 其余测试用例满足 $3 \\leq S \\leq 500$。\n\n**测试点 2（17 分，隐藏）**\n\n- $S = 10^6$，最多 1 组测试用例。\n- $S = 10^5$，最多 3 组测试用例。\n- 其余测试用例满足 $3 \\leq S \\leq 10000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13121", "type": "P", "difficulty": 6, "samples": [["3\n2 2\nAB\nBA\n2 3\nAAB\nABB\n3 4\nBBAA\nBABA\nBBAA", "Case #1: IMPOSSIBLE\nCase #2: POSSIBLE\n..\nCase #3: POSSIBLE\n//\\\n.//"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2019", "并查集", "Special Judge", "Google Code Jam"], "title": "[GCJ 2019 #3] Datacenter Duplex", "background": "", "description": "Two companies, Apricot Rules LLC and Banana Rocks Inc., are sharing the same datacenter. The datacenter is a matrix of $\\mathbf{R}$ rows and $\\mathbf{C}$ columns, with each cell containing a single server tower. Each tower contains intellectual property belonging to exactly one of the two companies.\n\nAt first, they built walls on the edges between cells assigned to different companies. This allowed orthogonally adjacent cells belonging to the same company to remain connected. Also, two cells $\\mathbf{x}$ and $\\mathbf{y}$ are considered connected if $\\mathbf{x}$ is connected to a cell that is, directly or indirectly, connected to $\\mathbf{y}$. With this definition, it was possible that two cells assigned to the same company were not connected, which was unacceptable.\n\nBoth companies agreed to build narrow hallways running through cell corners that allow two diagonally adjacent cells to be connected directly. Let us write $(\\mathbf{i}, \\mathbf{j})$ to represent the cell at row $\\mathbf{i}$ and column $\\mathbf{j}$. At most one narrow hallway can be built through any given vertex, which means either $(\\mathbf{i}, \\mathbf{j})$ and $(\\mathbf{i} + 1, \\mathbf{j} + 1)$ can be connected, or $(\\mathbf{i} + 1, \\mathbf{j})$ and $(\\mathbf{i}, \\mathbf{j} + 1)$ can be connected, or neither pair, but not both. Of course, only hallways between cells assigned to the same company can be built.\n\nGiven a matrix where each cell is labeled $\\mathbf{A}$ or $\\mathbf{B}$ depending on which company it is assigned to, find a way to add connections through diagonal adjacencies such that all $\\mathbf{A}$s are connected and all $\\mathbf{B}$s are connected.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case begins with one line containing two integers $\\mathbf{R}$ and $\\mathbf{C}$, the number of rows and columns of the matrix representing the datacenter. Then, there are $\\mathbf{R}$ more lines containing $\\mathbf{C}$ characters each. The $\\mathbf{j}$-th character on the $\\mathbf{i}$-th of these lines $\\mathbf{M}", "outputFormat": "For each test case, first output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is `IMPOSSIBLE` if there is no way to assign the diagonal connections such that the $\\mathbf{A}$ cells are connected and the $\\mathbf{B}$ cells are connected, or `POSSIBLE` otherwise. Then, if you output `POSSIBLE`, output $\\mathbf{R} - 1$ more lines of $\\mathbf{C} - 1$ characters each. These characters must correspond to a valid arrangement as described in the statement above. The $\\mathbf{j}$-th character of the $\\mathbf{i}$-th of those lines must be $\\backslash$ if cells $(\\mathbf{i}, \\mathbf{j})$ and $(\\mathbf{i} + 1, \\mathbf{j} + 1)$ are to be connected, / if cells $(\\mathbf{i} + 1, \\mathbf{j})$ and $(\\mathbf{i}, \\mathbf{j} + 1)$ are to be connected, or . if neither pair is to be connected.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the pair of A cells and the pair of B cells need to be connected, but since both connections would have to cross the same vertex, at most one of the connections can exist.\n\nIn Sample Case #2, the cells are already connected in the required way in the input, so no additional connections are necessary. Note that you can add unnecessary valid connections, so another valid answer would be `//`, but `\\.` would be wrong.\n\nIn Sample Case #3, there are also multiple solutions, one of which is displayed.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{C} \\leq 100$.\n- $\\mathbf{M}_{\\mathbf{i}, \\mathbf{j}}$ = uppercase A or uppercase B, for all $\\mathbf{i}$ and $\\mathbf{j}$.\n- $\\mathbf{M}_{\\mathbf{i}, \\mathbf{j}}$ = uppercase A for at least one pair of $\\mathbf{i}$ and $\\mathbf{j}$.\n- $\\mathbf{M}_{\\mathbf{i}, \\mathbf{j}}$ = uppercase B for at least one pair of $\\mathbf{i}$ and $\\mathbf{j}$.\n\n**Test set 1 (10 Pts, Visible)**\n\n- $2 \\leq \\mathbf{R} \\leq 4$.\n\n**Test set 2 (13 Pts, Hidden)**\n\n- $2 \\leq \\mathbf{R} \\leq 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #3] Datacenter Duplex", "background": "", "description": "Two companies, Apricot Rules LLC and Banana Rocks Inc., are sharing the same datacenter. The datacenter is a matrix of $\\mathbf{R}$ rows and $\\mathbf{C}$ columns, with each cell containing a single server tower. Each tower contains intellectual property belonging to exactly one of the two companies.\n\nAt first, they built walls on the edges between cells assigned to different companies. This allowed orthogonally adjacent cells belonging to the same company to remain connected. Also, two cells $\\mathbf{x}$ and $\\mathbf{y}$ are considered connected if $\\mathbf{x}$ is connected to a cell that is, directly or indirectly, connected to $\\mathbf{y}$. With this definition, it was possible that two cells assigned to the same company were not connected, which was unacceptable.\n\nBoth companies agreed to build narrow hallways running through cell corners that allow two diagonally adjacent cells to be connected directly. Let us write $(\\mathbf{i}, \\mathbf{j})$ to represent the cell at row $\\mathbf{i}$ and column $\\mathbf{j}$. At most one narrow hallway can be built through any given vertex, which means either $(\\mathbf{i}, \\mathbf{j})$ and $(\\mathbf{i} + 1, \\mathbf{j} + 1)$ can be connected, or $(\\mathbf{i} + 1, \\mathbf{j})$ and $(\\mathbf{i}, \\mathbf{j} + 1)$ can be connected, or neither pair, but not both. Of course, only hallways between cells assigned to the same company can be built.\n\nGiven a matrix where each cell is labeled $\\mathbf{A}$ or $\\mathbf{B}$ depending on which company it is assigned to, find a way to add connections through diagonal adjacencies such that all $\\mathbf{A}$s are connected and all $\\mathbf{B}$s are connected.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case begins with one line containing two integers $\\mathbf{R}$ and $\\mathbf{C}$, the number of rows and columns of the matrix representing the datacenter. Then, there are $\\mathbf{R}$ more lines containing $\\mathbf{C}$ characters each. The $\\mathbf{j}$-th character on the $\\mathbf{i}$-th of these lines $\\mathbf{M}", "outputFormat": "For each test case, first output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is `IMPOSSIBLE` if there is no way to assign the diagonal connections such that the $\\mathbf{A}$ cells are connected and the $\\mathbf{B}$ cells are connected, or `POSSIBLE` otherwise. Then, if you output `POSSIBLE`, output $\\mathbf{R} - 1$ more lines of $\\mathbf{C} - 1$ characters each. These characters must correspond to a valid arrangement as described in the statement above. The $\\mathbf{j}$-th character of the $\\mathbf{i}$-th of those lines must be $\\backslash$ if cells $(\\mathbf{i}, \\mathbf{j})$ and $(\\mathbf{i} + 1, \\mathbf{j} + 1)$ are to be connected, / if cells $(\\mathbf{i} + 1, \\mathbf{j})$ and $(\\mathbf{i}, \\mathbf{j} + 1)$ are to be connected, or . if neither pair is to be connected.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the pair of A cells and the pair of B cells need to be connected, but since both connections would have to cross the same vertex, at most one of the connections can exist.\n\nIn Sample Case #2, the cells are already connected in the required way in the input, so no additional connections are necessary. Note that you can add unnecessary valid connections, so another valid answer would be `//`, but `\\.` would be wrong.\n\nIn Sample Case #3, there are also multiple solutions, one of which is displayed.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{C} \\leq 100$.\n- $\\mathbf{M}_{\\mathbf{i}, \\mathbf{j}}$ = uppercase A or uppercase B, for all $\\mathbf{i}$ and $\\mathbf{j}$.\n- $\\mathbf{M}_{\\mathbf{i}, \\mathbf{j}}$ = uppercase A for at least one pair of $\\mathbf{i}$ and $\\mathbf{j}$.\n- $\\mathbf{M}_{\\mathbf{i}, \\mathbf{j}}$ = uppercase B for at least one pair of $\\mathbf{i}$ and $\\mathbf{j}$.\n\n**Test set 1 (10 Pts, Visible)**\n\n- $2 \\leq \\mathbf{R} \\leq 4$.\n\n**Test set 2 (13 Pts, Hidden)**\n\n- $2 \\leq \\mathbf{R} \\leq 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #3] Datacenter Duplex", "background": null, "description": "两家公司，Apricot Rules LLC 和 Banana Rocks Inc.，共用同一个数据中心。数据中心是一个 $\\mathbf{R}$ 行 $\\mathbf{C}$ 列的矩阵，每个格子里有一台服务器塔。每台服务器塔只属于其中一家公司。\n\n最初，他们在分配给不同公司的格子之间的边上建造了墙。这样，属于同一公司的正交相邻格子依然是连通的。同时，如果格子 $\\mathbf{x}$ 与格子 $\\mathbf{y}$ 之间存在直接或间接的连通路径，则认为 $\\mathbf{x}$ 和 $\\mathbf{y}$ 是连通的。根据这个定义，可能会出现同一公司分配的两个格子不连通的情况，这是不可接受的。\n\n两家公司同意在格子的顶点处修建狭窄的走廊，使得两个对角相邻的格子可以直接连通。我们用 $(\\mathbf{i}, \\mathbf{j})$ 表示第 $\\mathbf{i}$ 行第 $\\mathbf{j}$ 列的格子。每个顶点最多只能建一条狭窄的走廊，这意味着要么连接 $(\\mathbf{i}, \\mathbf{j})$ 和 $(\\mathbf{i} + 1, \\mathbf{j} + 1)$，要么连接 $(\\mathbf{i} + 1, \\mathbf{j})$ 和 $(\\mathbf{i}, \\mathbf{j} + 1)$，要么两者都不连，但不能同时连。当然，只有分配给同一公司的格子之间才能建走廊。\n\n给定一个矩阵，每个格子用 $\\mathbf{A}$ 或 $\\mathbf{B}$ 标记，表示分配给哪家公司。请你为每个测试用例设计一种对角连通方案，使得所有 $\\mathbf{A}$ 格子连通，所有 $\\mathbf{B}$ 格子连通。", "inputFormat": "第一行输入测试用例数 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试数据。每组测试数据第一行包含两个整数 $\\mathbf{R}$ 和 $\\mathbf{C}$，表示数据中心的行数和列数。接下来有 $\\mathbf{R}$ 行，每行包含 $\\mathbf{C}$ 个字符，表示矩阵 $\\mathbf{M}$。", "outputFormat": "对于每个测试用例，首先输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 若无法通过对角连通方案使所有 $\\mathbf{A}$ 格子连通且所有 $\\mathbf{B}$ 格子连通，则输出 `IMPOSSIBLE`，否则输出 `POSSIBLE`。如果输出 `POSSIBLE`，则接下来输出 $\\mathbf{R} - 1$ 行，每行 $\\mathbf{C} - 1$ 个字符，表示一种合法的对角连通方案。第 $\\mathbf{i}$ 行第 $\\mathbf{j}$ 个字符为 `\\` 表示连接 $(\\mathbf{i}, \\mathbf{j})$ 和 $(\\mathbf{i} + 1, \\mathbf{j} + 1)$，为 `/` 表示连接 $(\\mathbf{i} + 1, \\mathbf{j})$ 和 $(\\mathbf{i}, \\mathbf{j} + 1)$，为 `.` 表示两对都不连。", "hint": "**样例解释**\n\n在样例 1 中，A 格子和 B 格子都需要连通，但由于两条连通路径会交叉在同一个顶点，最多只能连通一对。\n\n在样例 2 中，输入中的格子已经满足连通要求，无需额外连通。注意你可以添加多余但合法的连通方案，因此 `//` 也是合法答案，但 `\\.` 就不合法。\n\n在样例 3 中，也有多种合法方案，样例给出其中一种。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $2 \\leq \\mathbf{C} \\leq 100$。\n- 对所有 $\\mathbf{i}, \\mathbf{j}$，$\\mathbf{M}_{\\mathbf{i}, \\mathbf{j}}$ 仅为大写字母 A 或 B。\n- 至少有一个格子为 A，至少有一个格子为 B。\n\n**测试点 1（10 分，公开）**\n\n- $2 \\leq \\mathbf{R} \\leq 4$。\n\n**测试点 2（13 分，隐藏）**\n\n- $2 \\leq \\mathbf{R} \\leq 100$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13122", "type": "P", "difficulty": 7, "samples": [["4\n4 2\n1 1\n1 2\n2 2\n2 1\n3 2\n1 1\n1 2\n2 1\n8 2\n1 3\n3 5\n5 5\n4 4\n7 3\n5 1\n4 2\n3 1\n8 2\n1 3\n3 5\n4 4\n5 5\n7 3\n5 1\n4 2\n3 1", "Case #1: POSSIBLE\n1/1 2/1 2/1 1/1\nCase #2: POSSIBLE\n1/1 1/1 3/2 3/2\nCase #3: IMPOSSIBLE\nCase #4: POSSIBLE\n1/1 3/1 7/1 3/1"], ["1\n10 8\n4 1\n3 1\n2 2\n2 3\n1 3\n1 4\n2 4\n3 3\n3 2\n4 2", "Case #1: POSSIBLE\n3/1 1/1 4/1 2/1\n3/1 1/1 3/1 2/1\n2/1 2/1 3/1 2/1\n2/1 2/1 3/1 3/1\n2/1 3/1 3/1 3/1\n2/1 3/1 2/1 4/1\n1/1 3/1 2/1 4/1"]], "limits": {"time": [60000, 60000, 60000], "memory": [1048576, 1048576, 1048576]}, "tags": ["计算几何", "2019", "Special Judge", "Google Code Jam"], "title": "[GCJ 2019 #3] Napkin Folding", "background": "", "description": "Chalk has been actively traveling the world with his friends taking pictures in all the coolest places. Most recently, he made his way to Europe, where he studied the history of [napkin folding](https://en.wikipedia.org/wiki/Napkin_folding). Ever since, Chalk has been collecting a wide variety of napkins to practice the art of napkin folding.\n\nChalk's napkins can be defined as [simple polygons](https://en.wikipedia.org/wiki/Simple_polygon). A simple polygon is a polygon in which no edges intersect except for adjacent edges which meet at their shared vertex. Each vertex of the polygon is on exactly two edges.\n\nChalk folds his napkins by first drawing a *folding pattern* on them. A folding pattern is a set of $\\mathbf{K}-1$ line segments which are drawn on the napkin. Each line segment connects two points with rational coordinates on the border of the polygon defining the napkin and is fully contained in the polygon. No two line segments in a folding pattern may touch or overlap, except possibly at common endpoints. A folding pattern of $\\mathbf{K}-1$ line segments splits the napkin into $\\mathbf{K}$ polygonal regions. Two points are in the same region if there exists some continuous line (not necessarily straight) between them which does not intersect any edge of the polygon or any line segment in the folding pattern — even at endpoints.\n\nChalk is only interested in *neat folding patterns*. A folding pattern is *neat* if any two regions that are adjacent to the same folding line segment $F$ are [symmetric](https://en.wikipedia.org/wiki/Symmetry) with respect to $F$. This means that folding the napkin along that line segment would result in the two regions lining up perfectly.\n\nThe following picture illustrates a neat folding pattern with $\\mathbf{K}=8$ regions.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ta6vzkcp.png)\n\nChalk has been successfully folding his collection of napkins using neat folding patterns. But he has some napkins in his collection that he has not been able to find a neat folding pattern for. For each of those napkins, Chalk needs your help to find a neat folding pattern with $\\mathbf{K}$ regions or determine that no such neat folding pattern exists.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing two integers $\\mathbf{N}$ and $\\mathbf{K}$: the number of points in the polygon defining Chalk's napkin and the number of regions to split the napkin into with a neat folding pattern containing $\\mathbf{K}-1$ line segments.\n\nThe polygon defining the napkin is represented as a list of the $\\mathbf{N}$ vertices, as encountered when traveling along the perimeter of the polygon in the clockwise direction, with the first vertex being chosen arbitrarily. The next $\\mathbf{N}$ lines represent that list. The $\\mathbf{i}$-th of these contains two integers $\\mathbf{X}_{\\mathbf{i}}$ and $\\mathbf{Y}_{\\mathbf{i}}$, indicating that the $\\mathbf{i}$-th point is located at $(\\mathbf{X}_{\\mathbf{i}}, \\mathbf{Y}_{\\mathbf{i}})$ in two-dimensional space.\n", "outputFormat": "For each test case, output one line containing Case #$x$: $y$, where $x$ is the test case number (starting from 1) and $y$ is `POSSIBLE` if it is possible to make a neat folding pattern with $\\mathbf{K}$ regions and `IMPOSSIBLE` otherwise.\n\nIf it is possible to make a neat folding pattern with $\\mathbf{K}$ regions, output $\\mathbf{K}-1$ more lines listing the segments of a neat folding pattern with $\\mathbf{K}$ regions, in any order. Each line should represent a different segment as $\\mathbf{A}_{\\mathbf{x}}$ $\\mathbf{A}_{\\mathbf{y}}$ $\\mathbf{B}_{\\mathbf{x}}$ $\\mathbf{B}_{\\mathbf{y}}$, where $(\\mathbf{A}_{\\mathbf{x}}, \\mathbf{A}_{\\mathbf{y}})$ and $(\\mathbf{B}_{\\mathbf{x}}, \\mathbf{B}_{\\mathbf{y}})$ are the two endpoints of the segment, in any order. Each of $\\mathbf{A}_{\\mathbf{x}}$, $\\mathbf{A}_{\\mathbf{y}}$, $\\mathbf{B}_{\\mathbf{x}}$, and $\\mathbf{B}_{\\mathbf{y}}$ should be in the form $\\mathbf{N}/\\mathbf{D}$ where $\\mathbf{N}$ and $\\mathbf{D}$ are positive integers (written with no leading zeroes) sharing no common prime factors, and representing the rational number $\\mathbf{N}/\\mathbf{D}$. There must be no whitespace between $\\mathbf{N}$ and /, or between / and $\\mathbf{D}$.", "hint": "**Sample Explanation**\n\nNote: Sample 2 is not valid for Test set 1. Only Sample 1 will be tested prior to running Test set 1 (the same way samples normally are). Moreover, Sample 2 will not be tested prior to running Test set 2.\n\nFor Sample Case #1, a neat folding pattern with $\\mathbf{K}=2$ can be drawn using any of the 4 dashed lines:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bm3282e7.png)\n\nFor Sample Case #2, a neat folding pattern with $\\mathbf{K}=2$ can be drawn as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hvx1riz3.png)\n\nFor Sample Case #3, there are no neat folding patterns:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/adkogxsq.png)\n\nFor Sample Case #4, there are two possible neat folding patterns with $\\mathbf{K}=2$:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j4v71qhu.png)\n\nFor the test set 2 sample case, a neat folding pattern with $\\mathbf{K}=8$ can be drawn as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vqrcukau.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $3 \\leq \\mathbf{N} \\leq 200$.\n- $1 \\leq \\mathbf{X}_{\\mathbf{i}} \\leq 1000$, for all $\\mathbf{i}$.\n- $1 \\leq \\mathbf{Y}_{\\mathbf{i}} \\leq 1000$, for all $\\mathbf{i}$.\n- The $\\mathbf{N}$ points are given in clockwise order.\n- No two adjacent edges of the polygon are collinear.\n- The polygon is a simple polygon with strictly positive area.\n- No two edges intersect except for adjacent edges at their shared endpoint.\n\n**Test set 1 (4 Pts, Visible)**\n\n- $\\mathbf{K}=2$.\n\n**Test set 2 (39 Pts, Hidden)**\n\n- $2 \\leq \\mathbf{K} \\leq 10$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #3] Napkin Folding", "background": "", "description": "Chalk has been actively traveling the world with his friends taking pictures in all the coolest places. Most recently, he made his way to Europe, where he studied the history of [napkin folding](https://en.wikipedia.org/wiki/Napkin_folding). Ever since, Chalk has been collecting a wide variety of napkins to practice the art of napkin folding.\n\nChalk's napkins can be defined as [simple polygons](https://en.wikipedia.org/wiki/Simple_polygon). A simple polygon is a polygon in which no edges intersect except for adjacent edges which meet at their shared vertex. Each vertex of the polygon is on exactly two edges.\n\nChalk folds his napkins by first drawing a *folding pattern* on them. A folding pattern is a set of $\\mathbf{K}-1$ line segments which are drawn on the napkin. Each line segment connects two points with rational coordinates on the border of the polygon defining the napkin and is fully contained in the polygon. No two line segments in a folding pattern may touch or overlap, except possibly at common endpoints. A folding pattern of $\\mathbf{K}-1$ line segments splits the napkin into $\\mathbf{K}$ polygonal regions. Two points are in the same region if there exists some continuous line (not necessarily straight) between them which does not intersect any edge of the polygon or any line segment in the folding pattern — even at endpoints.\n\nChalk is only interested in *neat folding patterns*. A folding pattern is *neat* if any two regions that are adjacent to the same folding line segment $F$ are [symmetric](https://en.wikipedia.org/wiki/Symmetry) with respect to $F$. This means that folding the napkin along that line segment would result in the two regions lining up perfectly.\n\nThe following picture illustrates a neat folding pattern with $\\mathbf{K}=8$ regions.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ta6vzkcp.png)\n\nChalk has been successfully folding his collection of napkins using neat folding patterns. But he has some napkins in his collection that he has not been able to find a neat folding pattern for. For each of those napkins, Chalk needs your help to find a neat folding pattern with $\\mathbf{K}$ regions or determine that no such neat folding pattern exists.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing two integers $\\mathbf{N}$ and $\\mathbf{K}$: the number of points in the polygon defining Chalk's napkin and the number of regions to split the napkin into with a neat folding pattern containing $\\mathbf{K}-1$ line segments.\n\nThe polygon defining the napkin is represented as a list of the $\\mathbf{N}$ vertices, as encountered when traveling along the perimeter of the polygon in the clockwise direction, with the first vertex being chosen arbitrarily. The next $\\mathbf{N}$ lines represent that list. The $\\mathbf{i}$-th of these contains two integers $\\mathbf{X}_{\\mathbf{i}}$ and $\\mathbf{Y}_{\\mathbf{i}}$, indicating that the $\\mathbf{i}$-th point is located at $(\\mathbf{X}_{\\mathbf{i}}, \\mathbf{Y}_{\\mathbf{i}})$ in two-dimensional space.\n", "outputFormat": "For each test case, output one line containing Case #$x$: $y$, where $x$ is the test case number (starting from 1) and $y$ is `POSSIBLE` if it is possible to make a neat folding pattern with $\\mathbf{K}$ regions and `IMPOSSIBLE` otherwise.\n\nIf it is possible to make a neat folding pattern with $\\mathbf{K}$ regions, output $\\mathbf{K}-1$ more lines listing the segments of a neat folding pattern with $\\mathbf{K}$ regions, in any order. Each line should represent a different segment as $\\mathbf{A}_{\\mathbf{x}}$ $\\mathbf{A}_{\\mathbf{y}}$ $\\mathbf{B}_{\\mathbf{x}}$ $\\mathbf{B}_{\\mathbf{y}}$, where $(\\mathbf{A}_{\\mathbf{x}}, \\mathbf{A}_{\\mathbf{y}})$ and $(\\mathbf{B}_{\\mathbf{x}}, \\mathbf{B}_{\\mathbf{y}})$ are the two endpoints of the segment, in any order. Each of $\\mathbf{A}_{\\mathbf{x}}$, $\\mathbf{A}_{\\mathbf{y}}$, $\\mathbf{B}_{\\mathbf{x}}$, and $\\mathbf{B}_{\\mathbf{y}}$ should be in the form $\\mathbf{N}/\\mathbf{D}$ where $\\mathbf{N}$ and $\\mathbf{D}$ are positive integers (written with no leading zeroes) sharing no common prime factors, and representing the rational number $\\mathbf{N}/\\mathbf{D}$. There must be no whitespace between $\\mathbf{N}$ and /, or between / and $\\mathbf{D}$.", "hint": "**Sample Explanation**\n\nNote: Sample 2 is not valid for Test set 1. Only Sample 1 will be tested prior to running Test set 1 (the same way samples normally are). Moreover, Sample 2 will not be tested prior to running Test set 2.\n\nFor Sample Case #1, a neat folding pattern with $\\mathbf{K}=2$ can be drawn using any of the 4 dashed lines:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bm3282e7.png)\n\nFor Sample Case #2, a neat folding pattern with $\\mathbf{K}=2$ can be drawn as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hvx1riz3.png)\n\nFor Sample Case #3, there are no neat folding patterns:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/adkogxsq.png)\n\nFor Sample Case #4, there are two possible neat folding patterns with $\\mathbf{K}=2$:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j4v71qhu.png)\n\nFor the test set 2 sample case, a neat folding pattern with $\\mathbf{K}=8$ can be drawn as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vqrcukau.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $3 \\leq \\mathbf{N} \\leq 200$.\n- $1 \\leq \\mathbf{X}_{\\mathbf{i}} \\leq 1000$, for all $\\mathbf{i}$.\n- $1 \\leq \\mathbf{Y}_{\\mathbf{i}} \\leq 1000$, for all $\\mathbf{i}$.\n- The $\\mathbf{N}$ points are given in clockwise order.\n- No two adjacent edges of the polygon are collinear.\n- The polygon is a simple polygon with strictly positive area.\n- No two edges intersect except for adjacent edges at their shared endpoint.\n\n**Test set 1 (4 Pts, Visible)**\n\n- $\\mathbf{K}=2$.\n\n**Test set 2 (39 Pts, Hidden)**\n\n- $2 \\leq \\mathbf{K} \\leq 10$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #3] Napkin Folding", "background": null, "description": "Chalk 一直在和朋友们积极地环游世界，在最酷的地方拍照。最近，他来到了欧洲，研究了[餐巾折叠](https://en.wikipedia.org/wiki/Napkin_folding)的历史。从那以后，Chalk 就开始收集各种各样的餐巾来练习餐巾折叠艺术。\n\nChalk 的餐巾可以被定义为[简单多边形](https://en.wikipedia.org/wiki/Simple_polygon)。简单多边形是指没有边相交（除了相邻边在公共顶点处相交）的多边形。多边形的每个顶点都恰好属于两条边。\n\nChalk 折叠餐巾时，首先会在餐巾上画出*折叠图案*。折叠图案是一组 $\\mathbf{K}-1$ 条线段，这些线段画在定义餐巾的多边形上。每条线段连接多边形边界上的两个有理数坐标点，并且完全位于多边形内部。折叠图案中的任意两条线段不能相交或重叠，除了可能在公共端点处。包含 $\\mathbf{K}-1$ 条线段的折叠图案会将餐巾分成 $\\mathbf{K}$ 个多边形区域。如果存在一条连续的路径（不一定是直线），连接两个点且不与多边形的任何边或折叠图案中的任何线段（即使是端点）相交，则这两个点属于同一区域。\n\nChalk 只对*整齐的折叠图案*感兴趣。折叠图案是*整齐*的，当且仅当与同一折叠线段 $F$ 相邻的任意两个区域关于 $F$ 对称。这意味着，如果沿着该线段折叠餐巾，这两个区域会完全重合。\n\n下图展示了一个包含 $\\mathbf{K}=8$ 个区域的整齐折叠图案。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ta6vzkcp.png)\n\nChalk 已经用整齐的折叠图案成功折叠了他的大部分餐巾。但他收藏中还有一些餐巾，始终找不到整齐的折叠图案。对于这些餐巾中的每一块，Chalk 需要你的帮助，找出一个包含 $\\mathbf{K}$ 个区域的整齐折叠图案，或者判断不存在这样的整齐折叠图案。", "inputFormat": "输入的第一行包含测试用例数 $\\mathbf{T}$。接下来是 $\\mathbf{T}$ 组测试数据。每组测试数据的第一行包含两个整数 $\\mathbf{N}$ 和 $\\mathbf{K}$，分别表示定义 Chalk 餐巾的多边形的顶点数和需要用整齐折叠图案分割出的区域数（即折叠图案包含 $\\mathbf{K}-1$ 条线段）。\n\n定义餐巾的多边形用一组 $\\mathbf{N}$ 个顶点表示，按顺时针方向沿多边形边界依次给出，起点任意。接下来的 $\\mathbf{N}$ 行表示该顶点列表。第 $\\mathbf{i}$ 行包含两个整数 $\\mathbf{X}_{\\mathbf{i}}$ 和 $\\mathbf{Y}_{\\mathbf{i}}$，表示第 $\\mathbf{i}$ 个点在二维平面上的坐标为 $(\\mathbf{X}_{\\mathbf{i}}, \\mathbf{Y}_{\\mathbf{i}})$。", "outputFormat": "对于每组测试数据，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 为 `POSSIBLE` 表示存在包含 $\\mathbf{K}$ 个区域的整齐折叠图案，`IMPOSSIBLE` 表示不存在。\n\n如果存在整齐折叠图案，将接着输出 $\\mathbf{K}-1$ 行，每行表示一条折叠线段，顺序任意。每行格式为 $\\mathbf{A}_{\\mathbf{x}}$ $\\mathbf{A}_{\\mathbf{y}}$ $\\mathbf{B}_{\\mathbf{x}}$ $\\mathbf{B}_{\\mathbf{y}}$，其中 $(\\mathbf{A}_{\\mathbf{x}}, \\mathbf{A}_{\\mathbf{y}})$ 和 $(\\mathbf{B}_{\\mathbf{x}}, \\mathbf{B}_{\\mathbf{y}})$ 是线段的两个端点，顺序任意。$\\mathbf{A}_{\\mathbf{x}}$、$\\mathbf{A}_{\\mathbf{y}}$、$\\mathbf{B}_{\\mathbf{x}}$、$\\mathbf{B}_{\\mathbf{y}}$ 都应为 $\\mathbf{N}/\\mathbf{D}$ 的形式，其中 $\\mathbf{N}$ 和 $\\mathbf{D}$ 是正整数（无前导零），且互质，表示有理数 $\\mathbf{N}/\\mathbf{D}$。$\\mathbf{N}$ 与 `/`、`/` 与 $\\mathbf{D}$ 之间不得有空格。", "hint": "**样例解释**\n\n注意：样例 2 不适用于测试集 1。只有样例 1 会在运行测试集 1 前被测试（与通常的样例测试方式一致）。此外，样例 2 不会在运行测试集 2 前被测试。\n\n对于样例 1，$\\mathbf{K}=2$ 时，可以用任意一条虚线画出整齐的折叠图案：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bm3282e7.png)\n\n对于样例 2，$\\mathbf{K}=2$ 时，可以如下画出整齐的折叠图案：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hvx1riz3.png)\n\n对于样例 3，没有整齐的折叠图案：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/adkogxsq.png)\n\n对于样例 4，存在两种可能的整齐折叠图案，$\\mathbf{K}=2$：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j4v71qhu.png)\n\n对于测试集 2 的样例，$\\mathbf{K}=8$ 时，可以如下画出整齐的折叠图案：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vqrcukau.png)\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $3 \\leq \\mathbf{N} \\leq 200$。\n- $1 \\leq \\mathbf{X}_{\\mathbf{i}} \\leq 1000$，对所有 $\\mathbf{i}$。\n- $1 \\leq \\mathbf{Y}_{\\mathbf{i}} \\leq 1000$，对所有 $\\mathbf{i}$。\n- 所有 $\\mathbf{N}$ 个点按顺时针顺序给出。\n- 多边形任意两条相邻边不共线。\n- 多边形为简单多边形，面积严格大于零。\n- 除了相邻边在公共端点处外，多边形任意两条边不相交。\n\n**测试集 1（4 分，公开）**\n\n- $\\mathbf{K}=2$。\n\n**测试集 2（39 分，隐藏）**\n\n- $2 \\leq \\mathbf{K} \\leq 10$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13123", "type": "P", "difficulty": 6, "samples": [["", ""]], "limits": {"time": [60000, 60000], "memory": [1048576, 1048576]}, "tags": ["数学", "2019", "二分", "交互题", "Special Judge", "Google Code Jam"], "title": "[GCJ 2019 Finals] Board Meeting [Can't Judge yet]", "background": "", "description": "Note that it is not necessary to know anything about the rules of chess to solve this problem.\n\nThere are $\\mathbf{N}$ kings on an infinite chessboard (two-dimensional grid), located in cells with coordinates $(\\mathbf{X}_{1}, \\mathbf{Y}_{1})$, $(\\mathbf{X}_{2}, \\mathbf{Y}_{2})$, ..., $(\\mathbf{X}_{\\mathbf{N}}, \\mathbf{Y}_{\\mathbf{N}})$. Both $\\mathbf{N}$ and the kings' coordinates are unknown to you. However, you do know the following things:\n\n- $\\mathbf{N}$ is at least 1 and at most $\\mathbf{N}_{\\text{max}}$.\n- No king's coordinates (X or Y) have an absolute value exceeding $\\mathbf{M}$.\n- The $\\mathbf{N}$ kings are located in $\\mathbf{N}$ different cells.\n\nThe kings want to meet in a single cell of the board. If some cell $(\\mathbf{X}, \\mathbf{Y})$ were to be chosen as the meeting cell, then in order to get there, the i-th king would use a number of moves equal to the maximum of the absolute values of the differences of coordinates between its cell and the meeting cell: $\\max(|\\mathbf{X}-\\mathbf{X}_{\\mathbf{i}}|, |\\mathbf{Y}-\\mathbf{Y}_{\\mathbf{i}}|)$. The total number of moves used by all kings is thus equal to the sum of those maximums over all values of $\\mathbf{i}$. Note that it is not relevant to this problem exactly how the kings move on the board — only the source and destination cells matter, and the number of moves can always be computed using the above formula.\n\nThis problem has two phases. In the first phase, you may repeatedly do the following: propose a meeting location $(\\mathbf{A}, \\mathbf{B})$ (with each of $\\mathbf{A}$ and $\\mathbf{B}$ between $-10 \\times \\mathbf{M}$ and $10 \\times \\mathbf{M}$, inclusive), and have the judge tell you the total number of moves the kings would use to get there — the sum (over all $\\mathbf{i}$) of $\\max(|\\mathbf{X}_{\\mathbf{i}}-\\mathbf{A}|, |\\mathbf{Y}_{\\mathbf{i}}-\\mathbf{B}|)$. You can have at most $\\mathbf{R}$ such exchanges with the judge, choosing your values of $\\mathbf{A}$ and $\\mathbf{B}$ each time. Note that the kings do not actually move, so their locations $(\\mathbf{X}_{\\mathbf{i}}, \\mathbf{Y}_{\\mathbf{i}})$ stay the same for all requests within one test case.\n\nIn the second phase, the roles are swapped: the judge gives you a meeting cell location $(\\mathbf{C}, \\mathbf{D})$ (with each of $\\mathbf{C}$ and $\\mathbf{D}$ between $-10 \\times \\mathbf{M}$ and $10 \\times \\mathbf{M}$, inclusive), and you must respond with the total number of moves the kings would use to get there, assuming that the kings are in the same locations as in the first phase. There are at most $\\mathbf{R}$ such exchanges, and you must correctly respond to all of the judge's requests.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing four integers $\\mathbf{T}$, $\\mathbf{N}_{\\text{max}}$, $\\mathbf{M}$ and $\\mathbf{R}$: the number of test cases, the maximum number of kings, the maximum absolute value for any coordinate for any king, and the maximum number of requests per phase, respectively. (Note that the values of $\\mathbf{M}$ and $\\mathbf{R}$ are fixed, and are provided as input only for convenience; see the Limits section for more details.) Then, you need to process $\\mathbf{T}$ test cases.\n\nIn each test case, there are two phases. In the first phase, the i-th exchange is as follows:\n\n- Your program sends one line containing two integers $\\mathbf{A}_{\\mathbf{i}}$ and $\\mathbf{B}_{\\mathbf{i}}$, representing the x and y coordinates of a cell.\n    - Both $\\mathbf{A}_{\\mathbf{i}}$ and $\\mathbf{B}_{\\mathbf{i}}$ must be between $-10 \\times \\mathbf{M}$ and $10 \\times \\mathbf{M}$, inclusive.\n- The judge responds with one line containing a single integer: the total number of moves the kings need to use to get from their unknown locations to your cell.\n\nYou may initiate at most $\\mathbf{R}$ such exchanges in this phase. If you make more than $\\mathbf{R}$ exchanges, or send a request that the judge can not parse or is out of bounds, the judge responds with one line with a single string $\\text{ERROR}$.\n\nTo end the first phase and switch to the second phase, you must send one line with the string $\\text{READY}$ (the case does not matter), to which the judge responds with the first request of the second phase.\n\nIn the second phase, the i-th exchange is as follows:\n\n- The judge sends one line containing two integers $\\mathbf{C}_{\\mathbf{i}}$ and $\\mathbf{D}_{\\mathbf{i}}$, representing the x and y coordinates of a cell.\n    - Each of $\\mathbf{C}_{\\mathbf{i}}$ and $\\mathbf{D}_{\\mathbf{i}}$ will be between $-10 \\times \\mathbf{M}$ and $10 \\times \\mathbf{M}$, inclusive.\n- Your program must respond with one line containing a single integer: the total number of moves the kings would need to use to get to the given cell.\n\nThe judge is guaranteed to send at least 1 and at most $\\mathbf{R}$ such requests. If you send an answer that is incorrect or unparseable, the judge responds with $\\text{ERROR}$ as described above. If you answer all of the requests correctly, the judge sends one line with a single string $\\text{DONE}$, at which point your program should initiate the next test case, or terminate with no error if all $\\mathbf{T}$ test cases have been handled.\n\nAfter the judge sends a line with $\\text{ERROR}$, it does not send any other output. If your program continues to wait for the judge after receiving $\\text{ERROR}$, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.\n\nThe number and location of the kings, as well as the number and positions of the requests that the judge sends during the second phases, are chosen before any exchanges occur.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\nNote that the following sample interaction is for test set 1, in which there is always exactly one king.\n\n```\n  // Suppose that the judge has decided that in the first test case, the king\n  // is at the coordinates (1, -2), and the requests will be (5, -1) and\n  // (7, 7).\n  t, nmax, m, r = readline_int_list()   // Reads 10 1 1000000 1000\n  // Our solution decides (for whatever reason) to check (3, 3) first.\n  printline 3 3 to stdout\n  flush stdout\n  result = readline_int()               // Reads 5\n  // Our solution now decides (for whatever reason) to check (2, 0).\n  printline 2 0 to stdout\n  flush stdout\n  result = readline_int()               // Reads 2\n  // Our solution concludes that the king is at (3, -2), which is consistent\n  // with the observed information so far, but unfortunately not correct.\n  // Our solution moves on to the request phase.\n  printline READY to stdout\n  request_line = readline()             // Reads 5 -1\n  printline 2 to stdout                 // Wrong answer!\n  request_line = readline()             // Reads ERROR\n  exit                                  // exits to avoid an ambiguous TLE error\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n~~Note that a program that just makes valid exchanges with the judge (and does no other processing) takes the following time in our environment: ~13 seconds for C++, ~24 seconds for Java, ~19 seconds for Python and Go.~~\n\n- $1 \\leq \\mathbf{T} \\leq 15$.\n- $\\mathbf{M} = 10^{6}$.\n- $-\\mathbf{M} \\leq \\mathbf{X}_{\\mathbf{i}} \\leq \\mathbf{M}$, for all $\\mathbf{i}$.\n- $-\\mathbf{M} \\leq \\mathbf{Y}_{\\mathbf{i}} \\leq \\mathbf{M}$, for all $\\mathbf{i}$.\n- The pairs $(\\mathbf{X}_{\\mathbf{i}}, \\mathbf{Y}_{\\mathbf{i}})$ are distinct.\n- $-10 \\times \\mathbf{M} \\leq \\mathbf{C}_{\\mathbf{i}} \\leq 10 \\times \\mathbf{M}$, for all $\\mathbf{i}$.\n- $-10 \\times \\mathbf{M} \\leq \\mathbf{D}_{\\mathbf{i}} \\leq 10 \\times \\mathbf{M}$, for all $\\mathbf{i}$.\n- $\\mathbf{R} = 1000$.\n\n**Test set 1 (5 Pts, Visible)**\n\n- $\\mathbf{N}_{\\text{max}} = 1$.\n\n**Test set 2 (22 Pts, Hidden)**\n\n- $\\mathbf{N}_{\\text{max}} = 10$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 Finals] Board Meeting [Can't Judge yet]", "background": "", "description": "Note that it is not necessary to know anything about the rules of chess to solve this problem.\n\nThere are $\\mathbf{N}$ kings on an infinite chessboard (two-dimensional grid), located in cells with coordinates $(\\mathbf{X}_{1}, \\mathbf{Y}_{1})$, $(\\mathbf{X}_{2}, \\mathbf{Y}_{2})$, ..., $(\\mathbf{X}_{\\mathbf{N}}, \\mathbf{Y}_{\\mathbf{N}})$. Both $\\mathbf{N}$ and the kings' coordinates are unknown to you. However, you do know the following things:\n\n- $\\mathbf{N}$ is at least 1 and at most $\\mathbf{N}_{\\text{max}}$.\n- No king's coordinates (X or Y) have an absolute value exceeding $\\mathbf{M}$.\n- The $\\mathbf{N}$ kings are located in $\\mathbf{N}$ different cells.\n\nThe kings want to meet in a single cell of the board. If some cell $(\\mathbf{X}, \\mathbf{Y})$ were to be chosen as the meeting cell, then in order to get there, the i-th king would use a number of moves equal to the maximum of the absolute values of the differences of coordinates between its cell and the meeting cell: $\\max(|\\mathbf{X}-\\mathbf{X}_{\\mathbf{i}}|, |\\mathbf{Y}-\\mathbf{Y}_{\\mathbf{i}}|)$. The total number of moves used by all kings is thus equal to the sum of those maximums over all values of $\\mathbf{i}$. Note that it is not relevant to this problem exactly how the kings move on the board — only the source and destination cells matter, and the number of moves can always be computed using the above formula.\n\nThis problem has two phases. In the first phase, you may repeatedly do the following: propose a meeting location $(\\mathbf{A}, \\mathbf{B})$ (with each of $\\mathbf{A}$ and $\\mathbf{B}$ between $-10 \\times \\mathbf{M}$ and $10 \\times \\mathbf{M}$, inclusive), and have the judge tell you the total number of moves the kings would use to get there — the sum (over all $\\mathbf{i}$) of $\\max(|\\mathbf{X}_{\\mathbf{i}}-\\mathbf{A}|, |\\mathbf{Y}_{\\mathbf{i}}-\\mathbf{B}|)$. You can have at most $\\mathbf{R}$ such exchanges with the judge, choosing your values of $\\mathbf{A}$ and $\\mathbf{B}$ each time. Note that the kings do not actually move, so their locations $(\\mathbf{X}_{\\mathbf{i}}, \\mathbf{Y}_{\\mathbf{i}})$ stay the same for all requests within one test case.\n\nIn the second phase, the roles are swapped: the judge gives you a meeting cell location $(\\mathbf{C}, \\mathbf{D})$ (with each of $\\mathbf{C}$ and $\\mathbf{D}$ between $-10 \\times \\mathbf{M}$ and $10 \\times \\mathbf{M}$, inclusive), and you must respond with the total number of moves the kings would use to get there, assuming that the kings are in the same locations as in the first phase. There are at most $\\mathbf{R}$ such exchanges, and you must correctly respond to all of the judge's requests.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing four integers $\\mathbf{T}$, $\\mathbf{N}_{\\text{max}}$, $\\mathbf{M}$ and $\\mathbf{R}$: the number of test cases, the maximum number of kings, the maximum absolute value for any coordinate for any king, and the maximum number of requests per phase, respectively. (Note that the values of $\\mathbf{M}$ and $\\mathbf{R}$ are fixed, and are provided as input only for convenience; see the Limits section for more details.) Then, you need to process $\\mathbf{T}$ test cases.\n\nIn each test case, there are two phases. In the first phase, the i-th exchange is as follows:\n\n- Your program sends one line containing two integers $\\mathbf{A}_{\\mathbf{i}}$ and $\\mathbf{B}_{\\mathbf{i}}$, representing the x and y coordinates of a cell.\n    - Both $\\mathbf{A}_{\\mathbf{i}}$ and $\\mathbf{B}_{\\mathbf{i}}$ must be between $-10 \\times \\mathbf{M}$ and $10 \\times \\mathbf{M}$, inclusive.\n- The judge responds with one line containing a single integer: the total number of moves the kings need to use to get from their unknown locations to your cell.\n\nYou may initiate at most $\\mathbf{R}$ such exchanges in this phase. If you make more than $\\mathbf{R}$ exchanges, or send a request that the judge can not parse or is out of bounds, the judge responds with one line with a single string $\\text{ERROR}$.\n\nTo end the first phase and switch to the second phase, you must send one line with the string $\\text{READY}$ (the case does not matter), to which the judge responds with the first request of the second phase.\n\nIn the second phase, the i-th exchange is as follows:\n\n- The judge sends one line containing two integers $\\mathbf{C}_{\\mathbf{i}}$ and $\\mathbf{D}_{\\mathbf{i}}$, representing the x and y coordinates of a cell.\n    - Each of $\\mathbf{C}_{\\mathbf{i}}$ and $\\mathbf{D}_{\\mathbf{i}}$ will be between $-10 \\times \\mathbf{M}$ and $10 \\times \\mathbf{M}$, inclusive.\n- Your program must respond with one line containing a single integer: the total number of moves the kings would need to use to get to the given cell.\n\nThe judge is guaranteed to send at least 1 and at most $\\mathbf{R}$ such requests. If you send an answer that is incorrect or unparseable, the judge responds with $\\text{ERROR}$ as described above. If you answer all of the requests correctly, the judge sends one line with a single string $\\text{DONE}$, at which point your program should initiate the next test case, or terminate with no error if all $\\mathbf{T}$ test cases have been handled.\n\nAfter the judge sends a line with $\\text{ERROR}$, it does not send any other output. If your program continues to wait for the judge after receiving $\\text{ERROR}$, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.\n\nThe number and location of the kings, as well as the number and positions of the requests that the judge sends during the second phases, are chosen before any exchanges occur.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\nNote that the following sample interaction is for test set 1, in which there is always exactly one king.\n\n```\n  // Suppose that the judge has decided that in the first test case, the king\n  // is at the coordinates (1, -2), and the requests will be (5, -1) and\n  // (7, 7).\n  t, nmax, m, r = readline_int_list()   // Reads 10 1 1000000 1000\n  // Our solution decides (for whatever reason) to check (3, 3) first.\n  printline 3 3 to stdout\n  flush stdout\n  result = readline_int()               // Reads 5\n  // Our solution now decides (for whatever reason) to check (2, 0).\n  printline 2 0 to stdout\n  flush stdout\n  result = readline_int()               // Reads 2\n  // Our solution concludes that the king is at (3, -2), which is consistent\n  // with the observed information so far, but unfortunately not correct.\n  // Our solution moves on to the request phase.\n  printline READY to stdout\n  request_line = readline()             // Reads 5 -1\n  printline 2 to stdout                 // Wrong answer!\n  request_line = readline()             // Reads ERROR\n  exit                                  // exits to avoid an ambiguous TLE error\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n~~Note that a program that just makes valid exchanges with the judge (and does no other processing) takes the following time in our environment: ~13 seconds for C++, ~24 seconds for Java, ~19 seconds for Python and Go.~~\n\n- $1 \\leq \\mathbf{T} \\leq 15$.\n- $\\mathbf{M} = 10^{6}$.\n- $-\\mathbf{M} \\leq \\mathbf{X}_{\\mathbf{i}} \\leq \\mathbf{M}$, for all $\\mathbf{i}$.\n- $-\\mathbf{M} \\leq \\mathbf{Y}_{\\mathbf{i}} \\leq \\mathbf{M}$, for all $\\mathbf{i}$.\n- The pairs $(\\mathbf{X}_{\\mathbf{i}}, \\mathbf{Y}_{\\mathbf{i}})$ are distinct.\n- $-10 \\times \\mathbf{M} \\leq \\mathbf{C}_{\\mathbf{i}} \\leq 10 \\times \\mathbf{M}$, for all $\\mathbf{i}$.\n- $-10 \\times \\mathbf{M} \\leq \\mathbf{D}_{\\mathbf{i}} \\leq 10 \\times \\mathbf{M}$, for all $\\mathbf{i}$.\n- $\\mathbf{R} = 1000$.\n\n**Test set 1 (5 Pts, Visible)**\n\n- $\\mathbf{N}_{\\text{max}} = 1$.\n\n**Test set 2 (22 Pts, Hidden)**\n\n- $\\mathbf{N}_{\\text{max}} = 10$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 Finals] Board Meeting [Can't Judge yet]", "background": null, "description": "注意，解决本题并不需要了解国际象棋的规则。\n\n在一个无限大的国际象棋棋盘（二维网格）上，有 $N$ 个国王，分别位于坐标 $(X_{1}, Y_{1})$，$(X_{2}, Y_{2})$，...，$(X_{N}, Y_{N})$。你并不知道 $N$ 以及这些国王的具体坐标，但你知道以下信息：\n\n- $N$ 至少为 $1$，至多为 $N_{\\text{max}}$。\n- 没有任何一个国王的坐标（$X$ 或 $Y$）的绝对值超过 $M$。\n- $N$ 个国王分别位于 $N$ 个不同的格子中。\n\n这些国王想要在棋盘上的某一个格子会合。如果选择某个格子 $(X, Y)$ 作为会合点，则第 $i$ 个国王到达该点所需的步数为其当前位置与会合点坐标差的绝对值的最大值：$\\max(|X-X_{i}|, |Y-Y_{i}|)$。所有国王到达会合点所需的总步数就是对所有 $i$ 的上述最大值之和。注意，本题并不关心国王具体如何移动——只关心起点和终点，以及步数的计算方式。\n\n本题分为两个阶段。在第一阶段，你可以多次进行如下操作：提出一个会合点 $(A, B)$（其中 $A$ 和 $B$ 均在 $-10 \\times M$ 到 $10 \\times M$ 之间，包括端点），裁判会告诉你所有国王到达该点所需的总步数——即对所有 $i$ 计算 $\\max(|X_{i}-A|, |Y_{i}-B|)$ 的和。你最多可以进行 $R$ 次这样的交互，每次可以自由选择 $A$ 和 $B$ 的值。注意，国王并不会真的移动，所以在同一测试用例的所有请求中，国王的位置 $(X_{i}, Y_{i})$ 都保持不变。\n\n在第二阶段，角色互换：裁判会给你一个会合点 $(C, D)$（其中 $C$ 和 $D$ 均在 $-10 \\times M$ 到 $10 \\times M$ 之间，包括端点），你需要回答所有国王到达该点所需的总步数，假设国王们的位置与第一阶段相同。裁判最多会发出 $R$ 个这样的请求，你需要全部正确回答。\n\n### 交互协议\n\n这是一个交互题。\n\n程序开始时，你需要读取一行，包含四个整数 $T$、$N_{\\text{max}}$、$M$ 和 $R$，分别表示测试用例数、国王数量的最大值、任意国王坐标的最大绝对值、每个阶段最多请求次数。（注意 $M$ 和 $R$ 的值是固定的，仅为方便输入，具体见限制部分。）然后，你需要依次处理 $T$ 个测试用例。\n\n每个测试用例包含两个阶段。在第一阶段，第 $i$ 次交互如下：\n\n- 你的程序输出一行，包含两个整数 $A_{i}$ 和 $B_{i}$，表示一个格子的 $x$ 和 $y$ 坐标。\n    - $A_{i}$ 和 $B_{i}$ 必须都在 $-10 \\times M$ 到 $10 \\times M$ 之间，包括端点。\n- 裁判回复一行，包含一个整数：所有国王从未知位置到你指定的格子所需的总步数。\n\n你在本阶段最多可以进行 $R$ 次这样的交互。如果你超过 $R$ 次，或者请求格式错误或越界，裁判会回复一行字符串 $\\text{ERROR}$。\n\n当你想结束第一阶段并进入第二阶段时，输出一行字符串 $\\text{READY}$（大小写不敏感），裁判会回复第二阶段的第一个请求。\n\n在第二阶段，第 $i$ 次交互如下：\n\n- 裁判输出一行，包含两个整数 $C_{i}$ 和 $D_{i}$，表示一个格子的 $x$ 和 $y$ 坐标。\n    - $C_{i}$ 和 $D_{i}$ 都在 $-10 \\times M$ 到 $10 \\times M$ 之间，包括端点。\n- 你的程序需要输出一行，包含一个整数：所有国王到达该点所需的总步数。\n\n裁判保证会发出至少 $1$ 次、至多 $R$ 次这样的请求。如果你的回答错误或格式不正确，裁判会回复 $\\text{ERROR}$。如果你全部回答正确，裁判会回复一行字符串 $\\text{DONE}$，此时你应开始下一个测试用例，或在所有 $T$ 个测试用例处理完毕后正常结束程序。\n\n如果裁判回复 $\\text{ERROR}$，则不会再有其他输出。如果你的程序在收到 $\\text{ERROR}$ 后继续等待裁判输出，将会超时（Time Limit Exceeded）。请确保你的程序在收到 $\\text{ERROR}$ 后及时退出，以便获得 Wrong Answer 而不是 TLE。如果超出内存限制或运行时错误，将会收到相应的判定。\n\n国王的数量和位置，以及第二阶段裁判发出的请求数量和位置，在所有交互开始前就已确定。", "inputFormat": "见交互协议。", "outputFormat": "见交互协议。", "hint": "**交互样例**\n\n注意，以下交互样例对应于测试集 1，其中总是只有一个国王。\n\n```\n  // 假设裁判决定第一个测试用例中，国王在坐标 (1, -2)，请求为 (5, -1) 和 (7, 7)。\n  t, nmax, m, r = readline_int_list()   // 读取 10 1 1000000 1000\n  // 我们的解法（无论出于什么原因）首先查询 (3, 3)。\n  printline 3 3 to stdout\n  flush stdout\n  result = readline_int()               // 读取 5\n  // 现在查询 (2, 0)。\n  printline 2 0 to stdout\n  flush stdout\n  result = readline_int()               // 读取 2\n  // 我们推断国王在 (3, -2)，这与已知信息一致，但实际上不正确。\n  // 进入请求阶段。\n  printline READY to stdout\n  request_line = readline()             // 读取 5 -1\n  printline 2 to stdout                 // 错误答案！\n  request_line = readline()             // 读取 ERROR\n  exit                                  // 退出，避免 TLE\n```\n\n你可以使用本地或平台提供的测试工具进行测试。若要在本地测试，需要让测试工具与你的代码并行运行；你可以使用我们的 [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)。更多信息请阅读该文件中的注释。\n\n测试工具的使用说明见工具内注释。建议你自行添加测试用例。请注意，测试工具仅用于模拟评测系统，**并非**真实评测系统，可能存在差异。\n\n**限制条件**\n\n~~仅进行合法交互的程序，在我们的环境下运行时间约为：C++ 13 秒，Java 24 秒，Python 和 Go 19 秒。~~\n\n- $1 \\leq T \\leq 15$。\n- $M = 10^{6}$。\n- $-\\mathbf{M} \\leq X_{i} \\leq \\mathbf{M}$，对所有 $i$。\n- $-\\mathbf{M} \\leq Y_{i} \\leq \\mathbf{M}$，对所有 $i$。\n- 所有 $(X_{i}, Y_{i})$ 均互不相同。\n- $-10 \\times M \\leq C_{i} \\leq 10 \\times M$，对所有 $i$。\n- $-10 \\times M \\leq D_{i} \\leq 10 \\times M$，对所有 $i$。\n- $R = 1000$。\n\n**测试集 1（5 分，可见）**\n\n- $N_{\\text{max}} = 1$。\n\n**测试集 2（22 分，隐藏）**\n\n- $N_{\\text{max}} = 10$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13124", "type": "P", "difficulty": 6, "samples": [["2\n20 450 4 3\n10 10 11\n17 4 1000\n999 998 997\n10 10 11\n20 450 5 5\n1 2 3 4 5\n2 3 4 5 1\n3 4 5 1 2\n4 5 1 2 3\n5 1 2 3 4", "Case #1:\n2\n3 1 2\n2 1 3\n0\n1 2\n2 2 1\n1 2\nCase #2:\n1\n5 1 2 3 4\n0\n1 1\n2 1 1\n3 1 1 1\n4 1 1 1 1"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2019", "Special Judge", "排序", "Ad-hoc", "Google Code Jam"], "title": "[GCJ 2019 Finals] Sorting Permutation Unit", "background": "", "description": "You may have heard of Google's Tensor Processing Units, which are used to build neural networks. However, there is one research area that is even deeper and more important than machine learning: sorting!\n\nWe are working on a special new chip called the Sorting Permutation Unit, which is very fast at applying permutations to arrays of integers. Formally, a permutation is an ordering of the first $\\mathbf{n}$ positive integers\n\n$$\\mathbf{p}_{1}, \\mathbf{p}_{2}, \\ldots, \\mathbf{p}_{\\mathbf{n}}$$\n\nand applying it to an array of $\\mathbf{n}$ integers\n\n$$\\mathbf{a}_{1}, \\mathbf{a}_{2}, \\ldots, \\mathbf{a}_{\\mathbf{n}}$$\n\nyields the new array\n\n$$\\mathbf{a}_{\\mathbf{p}_{1}}, \\mathbf{a}_{\\mathbf{p}_{2}}, \\ldots, \\mathbf{a}_{\\mathbf{p}_{\\mathbf{n}}}$$\n\nFor example, applying the permutation 3, 1, 2, 4 to the array 99, 234, 45, 800 would yield the new array 45, 99, 234, 800.\n\nHowever, permutations are expensive to represent in the hardware, so the unit can only have access to at most $\\mathbf{P}$ distinct permutations. We need your help figuring out what those permutations should be!\n\nGiven $\\mathbf{K}$ arrays of $\\mathbf{N}$ integers each, you must first specify up to $\\mathbf{P}$ permutations (of size $\\mathbf{N}$) of your choice. Then, for each of those $\\mathbf{K}$ input arrays, you must provide one sequence of up to $\\mathbf{S}$ instructions (each of which is a permutation from your specified set). When the instructions in this sequence are applied, in the given order, to the array, they must yield an array sorted in nondecreasing order. In each of your $\\mathbf{K}$ sequences of instructions, you may use each of your $\\mathbf{P}$ permutations zero or more times (not necessarily consecutively).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line with four integers $\\mathbf{P}$, $\\mathbf{S}$, $\\mathbf{K}$, and $\\mathbf{N}$: the maximum number of permutations allowed, the maximum number of instructions you are allowed to use to sort each array, the number of arrays, and the number of integers in each array. Then, there are $\\mathbf{K}$ more lines of $\\mathbf{N}$ integers $\\mathbf{A}_{\\mathbf{i}1}$, $\\mathbf{A}_{\\mathbf{i}2}$, ..., $\\mathbf{A}_{\\mathbf{iN}}$ each, where the j-th integer on the i-th line, $\\mathbf{A}_{\\mathbf{ij}}$, represents the j-th value of the i-th array.", "outputFormat": "For each test case, first output the following, in this order:\n\n* One line containing Case #x:, where $\\mathbf{x}$ is the test case number (starting from 1).\n* One line containing one integer $\\mathbf{P}'$, where $1 \\leq \\mathbf{P}' \\leq \\mathbf{P}$: the number of permutations you have chosen to use.\n* $\\mathbf{P}'$ lines, the i-th of which contains $\\mathbf{N}$ integers $\\mathbf{p}_{\\mathbf{i}1}$ $\\mathbf{p}_{\\mathbf{i}2}$ ... $\\mathbf{p}_{\\mathbf{iN}}$, where $\\mathbf{p}_{\\mathbf{ij}}$ is the j-th element of the i-th permutation.\n\nThen, output $\\mathbf{K}$ more lines. The i-th of these gives the instructions that you will apply to the i-th array given in the input. Each such line must begin with one integer $\\mathbf{S}'$, where $0 \\leq \\mathbf{S}' \\leq \\mathbf{S}$, and must continue with $\\mathbf{S}'$ integers $\\mathbf{X}_{1}$, $\\mathbf{X}_{2}$, ..., $\\mathbf{X}_{\\mathbf{S}'}$, where $1 \\leq \\mathbf{X}_{\\mathbf{k}} \\leq \\mathbf{P}'$ for all $\\mathbf{k}$. Here, $\\mathbf{X}_{\\mathbf{k}}$ represents that the k-th instruction you apply to the i-th array is the $\\mathbf{X}_{\\mathbf{k}}$-th permutation (counting starting from 1) in your list of permutations. These instructions must yield an array with the elements of the i-th input array, sorted in nondecreasing order.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, we can define up to $\\mathbf{P} = 20$ permutations. One viable strategy uses only these two:\n\n1. 3 1 2\n2. 2 1 3\n\nWe can handle the four arrays as follows:\n\n* 10 10 11: This is already sorted in nondecreasing order, so we do not need to do anything.\n* 17 4 1000: We can apply permutation #2 to yield 4 17 1000.\n* 999 998 997: One option is to first apply permutation #2 to turn the array into 998 999 997, then apply permutation #1 to turn the array into 997 998 999.\n* 10 10 11: This is the same as the first array. Applying permutation #2 also yields array sorted in nondecreasing order. (But we could have used the line 0 as we did before.)\n\nIn Sample Case #2, notice that we can use the same permutation instruction more than once on the same array, if desired.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 10$.\n- $\\mathbf{S} = 450$.\n- $1 \\leq \\mathbf{K} \\leq 30$.\n- $2 \\leq \\mathbf{N} \\leq 50$.\n- $1 \\leq \\mathbf{A}_{\\mathbf{ij}} \\leq 1000$, for all $\\mathbf{i}$ and $\\mathbf{j}$.\n\n**Test set 1 (5 Pts, Visible)**\n\n- $\\mathbf{P} = 20$.\n\n**Test set 2 (22 Pts, Hidden)**\n\n- $\\mathbf{P} = 5$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 Finals] Sorting Permutation Unit", "background": "", "description": "You may have heard of Google's Tensor Processing Units, which are used to build neural networks. However, there is one research area that is even deeper and more important than machine learning: sorting!\n\nWe are working on a special new chip called the Sorting Permutation Unit, which is very fast at applying permutations to arrays of integers. Formally, a permutation is an ordering of the first $\\mathbf{n}$ positive integers\n\n$$\\mathbf{p}_{1}, \\mathbf{p}_{2}, \\ldots, \\mathbf{p}_{\\mathbf{n}}$$\n\nand applying it to an array of $\\mathbf{n}$ integers\n\n$$\\mathbf{a}_{1}, \\mathbf{a}_{2}, \\ldots, \\mathbf{a}_{\\mathbf{n}}$$\n\nyields the new array\n\n$$\\mathbf{a}_{\\mathbf{p}_{1}}, \\mathbf{a}_{\\mathbf{p}_{2}}, \\ldots, \\mathbf{a}_{\\mathbf{p}_{\\mathbf{n}}}$$\n\nFor example, applying the permutation 3, 1, 2, 4 to the array 99, 234, 45, 800 would yield the new array 45, 99, 234, 800.\n\nHowever, permutations are expensive to represent in the hardware, so the unit can only have access to at most $\\mathbf{P}$ distinct permutations. We need your help figuring out what those permutations should be!\n\nGiven $\\mathbf{K}$ arrays of $\\mathbf{N}$ integers each, you must first specify up to $\\mathbf{P}$ permutations (of size $\\mathbf{N}$) of your choice. Then, for each of those $\\mathbf{K}$ input arrays, you must provide one sequence of up to $\\mathbf{S}$ instructions (each of which is a permutation from your specified set). When the instructions in this sequence are applied, in the given order, to the array, they must yield an array sorted in nondecreasing order. In each of your $\\mathbf{K}$ sequences of instructions, you may use each of your $\\mathbf{P}$ permutations zero or more times (not necessarily consecutively).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line with four integers $\\mathbf{P}$, $\\mathbf{S}$, $\\mathbf{K}$, and $\\mathbf{N}$: the maximum number of permutations allowed, the maximum number of instructions you are allowed to use to sort each array, the number of arrays, and the number of integers in each array. Then, there are $\\mathbf{K}$ more lines of $\\mathbf{N}$ integers $\\mathbf{A}_{\\mathbf{i}1}$, $\\mathbf{A}_{\\mathbf{i}2}$, ..., $\\mathbf{A}_{\\mathbf{iN}}$ each, where the j-th integer on the i-th line, $\\mathbf{A}_{\\mathbf{ij}}$, represents the j-th value of the i-th array.", "outputFormat": "For each test case, first output the following, in this order:\n\n* One line containing Case #x:, where $\\mathbf{x}$ is the test case number (starting from 1).\n* One line containing one integer $\\mathbf{P}'$, where $1 \\leq \\mathbf{P}' \\leq \\mathbf{P}$: the number of permutations you have chosen to use.\n* $\\mathbf{P}'$ lines, the i-th of which contains $\\mathbf{N}$ integers $\\mathbf{p}_{\\mathbf{i}1}$ $\\mathbf{p}_{\\mathbf{i}2}$ ... $\\mathbf{p}_{\\mathbf{iN}}$, where $\\mathbf{p}_{\\mathbf{ij}}$ is the j-th element of the i-th permutation.\n\nThen, output $\\mathbf{K}$ more lines. The i-th of these gives the instructions that you will apply to the i-th array given in the input. Each such line must begin with one integer $\\mathbf{S}'$, where $0 \\leq \\mathbf{S}' \\leq \\mathbf{S}$, and must continue with $\\mathbf{S}'$ integers $\\mathbf{X}_{1}$, $\\mathbf{X}_{2}$, ..., $\\mathbf{X}_{\\mathbf{S}'}$, where $1 \\leq \\mathbf{X}_{\\mathbf{k}} \\leq \\mathbf{P}'$ for all $\\mathbf{k}$. Here, $\\mathbf{X}_{\\mathbf{k}}$ represents that the k-th instruction you apply to the i-th array is the $\\mathbf{X}_{\\mathbf{k}}$-th permutation (counting starting from 1) in your list of permutations. These instructions must yield an array with the elements of the i-th input array, sorted in nondecreasing order.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, we can define up to $\\mathbf{P} = 20$ permutations. One viable strategy uses only these two:\n\n1. 3 1 2\n2. 2 1 3\n\nWe can handle the four arrays as follows:\n\n* 10 10 11: This is already sorted in nondecreasing order, so we do not need to do anything.\n* 17 4 1000: We can apply permutation #2 to yield 4 17 1000.\n* 999 998 997: One option is to first apply permutation #2 to turn the array into 998 999 997, then apply permutation #1 to turn the array into 997 998 999.\n* 10 10 11: This is the same as the first array. Applying permutation #2 also yields array sorted in nondecreasing order. (But we could have used the line 0 as we did before.)\n\nIn Sample Case #2, notice that we can use the same permutation instruction more than once on the same array, if desired.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 10$.\n- $\\mathbf{S} = 450$.\n- $1 \\leq \\mathbf{K} \\leq 30$.\n- $2 \\leq \\mathbf{N} \\leq 50$.\n- $1 \\leq \\mathbf{A}_{\\mathbf{ij}} \\leq 1000$, for all $\\mathbf{i}$ and $\\mathbf{j}$.\n\n**Test set 1 (5 Pts, Visible)**\n\n- $\\mathbf{P} = 20$.\n\n**Test set 2 (22 Pts, Hidden)**\n\n- $\\mathbf{P} = 5$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 Finals] Sorting Permutation Unit", "background": null, "description": "你可能听说过 Google 的张量处理单元（Tensor Processing Units），它们被用于构建神经网络。然而，有一个比机器学习更深奥、更重要的研究领域：排序！\n\n我们正在研发一种名为“排序置换单元”（Sorting Permutation Unit）的特殊芯片，它能非常快速地对整数数组应用置换。形式化地说，置换是对前 $n$ 个正整数的一种排列：\n\n$$\\mathbf{p}_{1}, \\mathbf{p}_{2}, \\ldots, \\mathbf{p}_{\\mathbf{n}}$$\n\n将其应用于一个包含 $n$ 个整数的数组\n\n$$\\mathbf{a}_{1}, \\mathbf{a}_{2}, \\ldots, \\mathbf{a}_{\\mathbf{n}}$$\n\n会得到新的数组\n\n$$\\mathbf{a}_{\\mathbf{p}_{1}}, \\mathbf{a}_{\\mathbf{p}_{2}}, \\ldots, \\mathbf{a}_{\\mathbf{p}_{\\mathbf{n}}}$$\n\n例如，将置换 3, 1, 2, 4 应用于数组 99, 234, 45, 800，会得到新数组 45, 99, 234, 800。\n\n然而，硬件中表示置换的代价很高，因此该单元最多只能使用 $\\mathbf{P}$ 个不同的置换。我们需要你的帮助，来确定这些置换应该是什么！\n\n给定 $\\mathbf{K}$ 个长度为 $\\mathbf{N}$ 的整数数组，你首先需要指定至多 $\\mathbf{P}$ 个你选择的置换（每个置换长度为 $\\mathbf{N}$）。然后，对于每一个输入数组，你需要给出一组最多包含 $\\mathbf{S}$ 条指令的序列（每条指令是你指定的置换之一）。当按顺序对该数组应用这些指令后，最终得到的数组必须是非递减有序的。在每个数组的指令序列中，你可以对每个置换使用零次或多次（不要求连续）。", "inputFormat": "输入的第一行是测试用例数 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试用例。每组测试用例的第一行为四个整数 $\\mathbf{P}$、$\\mathbf{S}$、$\\mathbf{K}$ 和 $\\mathbf{N}$，分别表示最多允许的置换数、对每个数组最多允许的指令数、数组的数量以及每个数组中的整数个数。接下来有 $\\mathbf{K}$ 行，每行包含 $\\mathbf{N}$ 个整数 $\\mathbf{A}_{\\mathbf{i}1}$、$\\mathbf{A}_{\\mathbf{i}2}$、...、$\\mathbf{A}_{\\mathbf{iN}}$，其中第 $i$ 行的第 $j$ 个整数 $\\mathbf{A}_{\\mathbf{ij}}$ 表示第 $i$ 个数组的第 $j$ 个值。", "outputFormat": "对于每个测试用例，按以下顺序输出：\n\n- 首先输出一行 `Case #x:`，其中 $x$ 是测试用例编号（从 1 开始）。\n- 输出一行一个整数 $\\mathbf{P}'$，表示你选择使用的置换数量，$1 \\leq \\mathbf{P}' \\leq \\mathbf{P}$。\n- 接下来输出 $\\mathbf{P}'$ 行，每行包含 $\\mathbf{N}$ 个整数 $\\mathbf{p}_{\\mathbf{i}1}$ $\\mathbf{p}_{\\mathbf{i}2}$ ... $\\mathbf{p}_{\\mathbf{iN}}$，表示第 $i$ 个置换的内容。\n\n然后，再输出 $\\mathbf{K}$ 行。第 $i$ 行表示你将应用于输入中第 $i$ 个数组的指令序列。每行首先是一个整数 $\\mathbf{S}'$，$0 \\leq \\mathbf{S}' \\leq \\mathbf{S}$，接着是 $\\mathbf{S}'$ 个整数 $\\mathbf{X}_{1}$、$\\mathbf{X}_{2}$、...、$\\mathbf{X}_{\\mathbf{S}'}$，其中 $1 \\leq \\mathbf{X}_{\\mathbf{k}} \\leq \\mathbf{P}'$。这里，$\\mathbf{X}_{\\mathbf{k}}$ 表示对第 $i$ 个数组应用的第 $k$ 条指令是你置换列表中第 $\\mathbf{X}_{\\mathbf{k}}$ 个置换（从 1 开始编号）。这些指令应用后，得到的数组必须是输入数组元素的非递减排列。", "hint": "**样例解释**\n\n在样例 1 中，我们最多可以定义 $\\mathbf{P} = 20$ 个置换。一种可行的策略只用到了以下两个：\n\n1. 3 1 2\n2. 2 1 3\n\n我们可以这样处理四个数组：\n\n- 10 10 11：已经是非递减有序，无需操作。\n- 17 4 1000：可以应用第 2 个置换，得到 4 17 1000。\n- 999 998 997：可以先应用第 2 个置换，得到 998 999 997，再应用第 1 个置换，得到 997 998 999。\n- 10 10 11：与第一个数组相同，也可以应用第 2 个置换得到有序数组（当然也可以直接输出 0）。\n\n在样例 2 中，注意同一个置换指令可以在同一个数组上多次使用。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 10$。\n- $\\mathbf{S} = 450$。\n- $1 \\leq \\mathbf{K} \\leq 30$。\n- $2 \\leq \\mathbf{N} \\leq 50$。\n- $1 \\leq \\mathbf{A}_{\\mathbf{ij}} \\leq 1000$，对于所有 $i$ 和 $j$。\n\n**测试点 1（5 分，可见）**\n\n- $\\mathbf{P} = 20$。\n\n**测试点 2（22 分，隐藏）**\n\n- $\\mathbf{P} = 5$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13125", "type": "P", "difficulty": 7, "samples": [["3\n1\n198\n1234567890", "Case #1: 1\nCase #2: 191 7\nCase #3: 672787276 94449 561686165"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["搜索", "数学", "2019", "Special Judge", "剪枝", "数位 DP", "Google Code Jam"], "title": "[GCJ 2019 Finals] Won't sum? Must now", "background": "", "description": "In 2016, it was shown that every positive integer can be written as the sum of three or fewer palindromic terms. For the purposes of this problem, a palindromic term is a string of digits (with no leading zeroes) that represents a positive integer and reads the same forward and backward.\n\nGiven a positive integer $\\mathbf{S}$, find $\\mathbf{K}$ palindromic terms that sum to $\\mathbf{S}$, such that $\\mathbf{K}$ is minimized.", "inputFormat": "The first line of input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow, each containing a positive integer $\\mathbf{S}$.\n", "outputFormat": "For each test case, output one line of the form Case #x: $A_1$ (if only one term is needed), Case #x: $A_1$ $A_2$ (if only two terms are needed), or Case #x: $A_1$ $A_2$ $A_3$ (if three terms are needed), where $x$ is the case number (counting starting from 1), each $A_i$ is a palindromic term (as described above), and the sum of the $A_i$s equals $\\mathbf{S}$.\n", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the input is already a palindrome.\n\nIn Sample Case #2, note that `99 99`, for example, would also be an acceptable answer. Even though there are multiple instances of 99, they count as separate terms, so this solution uses the same number of terms as 191 7.\n\nAlso note that `191 07`, `181 8 9`, `0110 88`, `101 97`, `7.0 191.0`, and `-202 4`, for example, would not be acceptable answers.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\n**Test set 1 (5 Pts, Visible)**\n\n- $1 \\leq \\mathbf{S} \\leq 10^{10}$.\n\n**Test set 2 (22 Pts, Hidden)**\n\n- $1 \\leq \\mathbf{S} \\leq 10^{40}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 Finals] Won't sum? Must now", "background": "", "description": "In 2016, it was shown that every positive integer can be written as the sum of three or fewer palindromic terms. For the purposes of this problem, a palindromic term is a string of digits (with no leading zeroes) that represents a positive integer and reads the same forward and backward.\n\nGiven a positive integer $\\mathbf{S}$, find $\\mathbf{K}$ palindromic terms that sum to $\\mathbf{S}$, such that $\\mathbf{K}$ is minimized.", "inputFormat": "The first line of input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow, each containing a positive integer $\\mathbf{S}$.\n", "outputFormat": "For each test case, output one line of the form Case #x: $A_1$ (if only one term is needed), Case #x: $A_1$ $A_2$ (if only two terms are needed), or Case #x: $A_1$ $A_2$ $A_3$ (if three terms are needed), where $x$ is the case number (counting starting from 1), each $A_i$ is a palindromic term (as described above), and the sum of the $A_i$s equals $\\mathbf{S}$.\n", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the input is already a palindrome.\n\nIn Sample Case #2, note that `99 99`, for example, would also be an acceptable answer. Even though there are multiple instances of 99, they count as separate terms, so this solution uses the same number of terms as 191 7.\n\nAlso note that `191 07`, `181 8 9`, `0110 88`, `101 97`, `7.0 191.0`, and `-202 4`, for example, would not be acceptable answers.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\n**Test set 1 (5 Pts, Visible)**\n\n- $1 \\leq \\mathbf{S} \\leq 10^{10}$.\n\n**Test set 2 (22 Pts, Hidden)**\n\n- $1 \\leq \\mathbf{S} \\leq 10^{40}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 Finals] Won't sum? Must now", "background": null, "description": "2016 年，有研究表明每个正整数都可以表示为不超过三个回文数之和。在本题中，回文数指的是没有前导零、正读和反读都相同的正整数。\n\n给定一个正整数 $\\mathbf{S}$，请找出 $\\mathbf{K}$ 个回文数，使它们的和等于 $\\mathbf{S}$，并且 $\\mathbf{K}$ 最小。", "inputFormat": "输入的第一行为测试用例数 $\\mathbf{T}$。接下来的 $\\mathbf{T}$ 行，每行包含一个正整数 $\\mathbf{S}$。", "outputFormat": "对于每个测试用例，输出一行，格式为 Case #x: $A_1$（如果只需要一个回文数）、Case #x: $A_1$ $A_2$（如果需要两个回文数），或 Case #x: $A_1$ $A_2$ $A_3$（如果需要三个回文数），其中 $x$ 为测试用例编号（从 1 开始），每个 $A_i$ 为一个回文数，且 $A_1 + A_2 + \\cdots + A_K = \\mathbf{S}$。", "hint": "**样例解释**\n\n在样例第 1 个用例中，输入本身就是回文数。\n\n在样例第 2 个用例中，`99 99` 也是一个可行答案。即使有多个 99，它们也算作不同的项，因此这个解法和 `191 7` 使用的项数相同。\n\n注意，`191 07`、`181 8 9`、`0110 88`、`101 97`、`7.0 191.0`、`-202 4` 等都不是可接受的答案。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n\n**测试点 1（5 分，可见）**\n\n- $1 \\leq \\mathbf{S} \\leq 10^{10}$。\n\n**测试点 2（22 分，隐藏）**\n\n- $1 \\leq \\mathbf{S} \\leq 10^{40}$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13126", "type": "P", "difficulty": 6, "samples": [["3\n2\n-1 -1\n-1 1\n1 1\n1 -1\n3\n1 2\n2 1\n2 3\n3 1\n3 3\n4 2\n3\n7 1\n1 1\n7 2\n5 5\n3 5\n1 2", "Case #1: 3 4 1 2\nCase #2: 6 5 4 3 2 1\nCase #3: 5 4 6 2 1 3"]], "limits": {"time": [20000, 20000, 60000], "memory": [1048576, 1048576, 1048576]}, "tags": ["计算几何", "2019", "分治", "Google Code Jam"], "title": "[GCJ 2019 Finals] Juggle Struggle: Part 1", "background": "", "description": "The first two paragraphs (not counting this one) of this problem and \"Juggle Struggle: Part 2\" are identical. The problems can otherwise be solved independently; you do not need to read or solve one in order to read or solve the other.\n\nAs manager of the Graceful Chainsaw Jugglers group, you have decided to spice the show up a bit. Instead of having each juggler individually juggle their own chainsaws, you want them to form pairs, with each pair throwing the chainsaws back and forth to each other. In this new performance, $2 \\times \\mathbf{N}$ jugglers will be on stage at the same time, arranged into $\\mathbf{N}$ pairs, with each juggler belonging to exactly one pair.\n\nYou think the show will be more impressive if the chainsaws being juggled by different pairs of jugglers are at risk of collision. Let the stage be a two-dimensional plane, and let the straight line segment in that plane that connects the positions of two jugglers in a pair be called the pair's juggling path. When two juggling paths intersect, we say the chainsaws juggled by those pairs are at risk of collision. We call the spatial positions and the pairings of the jugglers an arrangement. An arrangement is magnificent if every two pairs of jugglers' chainsaws are at risk of collision.\n\nAfter a lot of thinking and designing, you came up with a magnificent arrangement. You wrote down the positions of the jugglers on the stage and the pairings of the jugglers on a piece of paper. Unfortunately, a bad chainsaw throw cut the paper in half, and you have lost the half with the pairings. Since the stage decorations have already been designed based on the positions of the jugglers, those positions cannot be changed. The show's highly anticipated debut is a mere few hours away, so you need to find a magnificent arrangement that works! Given every juggler's position on a two-dimensional stage, find a pairing of them that yields a magnificent arrangement.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with one line containing a single integer $\\mathbf{N}$, the number of pairs of jugglers. Then, $2 \\times \\mathbf{N}$ lines follow. The i-th of these lines contains two integers $\\mathbf{X}_\\mathbf{i}$ and $\\mathbf{Y}_\\mathbf{i}$, representing the coordinates of the position of the i-th juggler.\n", "outputFormat": "For each test case, output one line containing Case #x: $j_1$ $j_2$ $\\dots$ $j_{2 \\times \\mathbf{N}}$, representing that jugglers $i$ and $j_i$ are to be paired together, for every $i$. Notice that $j_{j_i} = i$ for every $i$.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the jugglers' positions form a square. The only valid solution is to pair up jugglers 1 and 3, and pair up jugglers 2 and 4.\n\n**Limits**\n\n- $-10^9 \\leq \\mathbf{X}_\\mathbf{i} \\leq 10^9$, for all i.\n- $-10^9 \\leq \\mathbf{Y}_\\mathbf{i} \\leq 10^9$, for all i.\n- No three juggler positions are collinear. (Note that this also implies that no two jugglers are in the same position.)\n- There exists at least one way to pair the jugglers such that the resulting arrangement is magnificent.\n\n**Test set 1 (5 Pts, Visible)**\n\n- Time limit: 20 seconds.\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{N} \\leq 100$.\n\n**Test set 2 (30 Pts, Hidden)**\n\n- Time limit: 60 seconds.\n- $1 \\leq \\mathbf{T} \\leq 10$.\n- $2 \\leq \\mathbf{N} \\leq 10^5$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 Finals] Juggle Struggle: Part 1", "background": "", "description": "The first two paragraphs (not counting this one) of this problem and \"Juggle Struggle: Part 2\" are identical. The problems can otherwise be solved independently; you do not need to read or solve one in order to read or solve the other.\n\nAs manager of the Graceful Chainsaw Jugglers group, you have decided to spice the show up a bit. Instead of having each juggler individually juggle their own chainsaws, you want them to form pairs, with each pair throwing the chainsaws back and forth to each other. In this new performance, $2 \\times \\mathbf{N}$ jugglers will be on stage at the same time, arranged into $\\mathbf{N}$ pairs, with each juggler belonging to exactly one pair.\n\nYou think the show will be more impressive if the chainsaws being juggled by different pairs of jugglers are at risk of collision. Let the stage be a two-dimensional plane, and let the straight line segment in that plane that connects the positions of two jugglers in a pair be called the pair's juggling path. When two juggling paths intersect, we say the chainsaws juggled by those pairs are at risk of collision. We call the spatial positions and the pairings of the jugglers an arrangement. An arrangement is magnificent if every two pairs of jugglers' chainsaws are at risk of collision.\n\nAfter a lot of thinking and designing, you came up with a magnificent arrangement. You wrote down the positions of the jugglers on the stage and the pairings of the jugglers on a piece of paper. Unfortunately, a bad chainsaw throw cut the paper in half, and you have lost the half with the pairings. Since the stage decorations have already been designed based on the positions of the jugglers, those positions cannot be changed. The show's highly anticipated debut is a mere few hours away, so you need to find a magnificent arrangement that works! Given every juggler's position on a two-dimensional stage, find a pairing of them that yields a magnificent arrangement.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with one line containing a single integer $\\mathbf{N}$, the number of pairs of jugglers. Then, $2 \\times \\mathbf{N}$ lines follow. The i-th of these lines contains two integers $\\mathbf{X}_\\mathbf{i}$ and $\\mathbf{Y}_\\mathbf{i}$, representing the coordinates of the position of the i-th juggler.\n", "outputFormat": "For each test case, output one line containing Case #x: $j_1$ $j_2$ $\\dots$ $j_{2 \\times \\mathbf{N}}$, representing that jugglers $i$ and $j_i$ are to be paired together, for every $i$. Notice that $j_{j_i} = i$ for every $i$.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the jugglers' positions form a square. The only valid solution is to pair up jugglers 1 and 3, and pair up jugglers 2 and 4.\n\n**Limits**\n\n- $-10^9 \\leq \\mathbf{X}_\\mathbf{i} \\leq 10^9$, for all i.\n- $-10^9 \\leq \\mathbf{Y}_\\mathbf{i} \\leq 10^9$, for all i.\n- No three juggler positions are collinear. (Note that this also implies that no two jugglers are in the same position.)\n- There exists at least one way to pair the jugglers such that the resulting arrangement is magnificent.\n\n**Test set 1 (5 Pts, Visible)**\n\n- Time limit: 20 seconds.\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{N} \\leq 100$.\n\n**Test set 2 (30 Pts, Hidden)**\n\n- Time limit: 60 seconds.\n- $1 \\leq \\mathbf{T} \\leq 10$.\n- $2 \\leq \\mathbf{N} \\leq 10^5$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 Finals] Juggle Struggle: Part 1", "background": null, "description": "本题的前两段（不包括本段）与“Juggle Struggle: Part 2”完全相同。除此之外，这两道题可以独立解决；你无需阅读或解决其中一道题即可理解或解决另一道题。\n\n作为 Graceful Chainsaw Jugglers 团队的经理，你决定让表演更加精彩。你不再让每位杂技演员单独抛接自己的电锯，而是让他们两两组队，每对互相抛接电锯。在这种新表演中，将有 $2 \\times \\mathbf{N}$ 名杂技演员同时登台，被分为 $\\mathbf{N}$ 对，每位杂技演员恰好属于一对。\n\n你认为，如果不同对的杂技演员所抛接的电锯有相互碰撞的风险，表演会更加惊险。设舞台为一个二维平面，连接一对杂技演员位置的直线段称为该对的抛接路径。当两条抛接路径相交时，称这两对杂技演员的电锯存在碰撞风险。我们称杂技演员的空间位置及其配对方式为一种“安排”。如果每两对杂技演员的电锯都存在碰撞风险，则称该安排为“壮观的安排”。\n\n经过长时间的思考和设计，你想出了一个壮观的安排，并把杂技演员在舞台上的位置和配对方式记录在纸上。不幸的是，一次失误的电锯抛掷把纸张切成了两半，你丢失了记载配对方式的那一半。由于舞台布景已经根据杂技演员的位置设计好，这些位置无法更改。距离备受期待的首演只剩下几个小时，你需要重新找到一个壮观的安排！给定每位杂技演员在二维舞台上的位置，请找出一种配对方式，使得该安排是壮观的。", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例的数量。接下来有 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含一个整数 $\\mathbf{N}$，表示杂技演员对数。接下来的 $2 \\times \\mathbf{N}$ 行，每行包含两个整数 $\\mathbf{X}_\\mathbf{i}$ 和 $\\mathbf{Y}_\\mathbf{i}$，表示第 $i$ 位杂技演员的位置坐标。", "outputFormat": "对于每个测试用例，输出一行，格式为 Case #x: $j_1$ $j_2$ $\\dots$ $j_{2 \\times \\mathbf{N}}$，表示第 $i$ 位杂技演员应与第 $j_i$ 位杂技演员配对，对于每个 $i$ 都满足 $j_{j_i} = i$。", "hint": "**样例解释**\n\n在样例第 1 个测试用例中，杂技演员的位置构成一个正方形。唯一的有效方案是将第 1 位与第 3 位配对，第 2 位与第 4 位配对。\n\n**数据范围**\n\n- $-10^9 \\leq \\mathbf{X}_\\mathbf{i} \\leq 10^9$，对所有 $i$ 成立。\n- $-10^9 \\leq \\mathbf{Y}_\\mathbf{i} \\leq 10^9$，对所有 $i$ 成立。\n- 任意三位杂技演员的位置不共线。（这也意味着没有两位杂技演员处于同一位置。）\n- 至少存在一种配对方式，使得最终安排是壮观的。\n\n**测试点 1（5 分，公开）**\n\n- 时间限制：20 秒。\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $2 \\leq \\mathbf{N} \\leq 100$。\n\n**测试点 2（30 分，隐藏）**\n\n- 时间限制：60 秒。\n- $1 \\leq \\mathbf{T} \\leq 10$。\n- $2 \\leq \\mathbf{N} \\leq 10^5$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13127", "type": "P", "difficulty": 7, "samples": [["4\n2\n-1 -1 -1 1\n1 1 1 -1\n2\n-1 -1 1 1\n-1 1 1 -1\n4\n1 2 4 2\n2 1 3 1\n2 4 3 0\n3 3 2 3\n3\n1 1 2 2\n3 7 4 8\n8 3 9 3", "Case #1: 1 2\nCase #2: MAGNIFICENT\nCase #3: 1 2 4\nCase #4: 1 2 3"]], "limits": {"time": [20000, 20000, 45000], "memory": [1048576, 1048576, 1048576]}, "tags": ["计算几何", "2019", "凸包", "Google Code Jam"], "title": "[GCJ 2019 Finals] Juggle Struggle: Part 2", "background": "", "description": "The first two paragraphs (not counting this one) of this problem and \"Juggle Struggle: Part 1\" are identical. The problems can otherwise be solved independently; you do not need to read or solve one in order to read or solve the other.\n\nAs manager of the Graceful Chainsaw Jugglers group, you have decided to spice the show up a bit. Instead of having each juggler individually juggle their own chainsaws, you want them to form pairs, with each pair throwing the chainsaws back and forth to each other. In this new performance, $2 \\times \\mathbf{N}$ jugglers will be on stage at the same time, arranged into $\\mathbf{N}$ pairs, with each juggler belonging to exactly one pair.\n\nYou think the show will be more impressive if the chainsaws being juggled by different pairs of jugglers are at risk of collision. Let the stage be a two-dimensional plane, and let the straight line segment in that plane that connects the positions of two jugglers in a pair be called the pair's juggling path. When two juggling paths intersect, we say the chainsaws juggled by those pairs are at risk of collision. We call the spatial positions and the pairings of the jugglers an arrangement. An arrangement is magnificent if every two pairs of jugglers' chainsaws are at risk of collision. That is, for the arrangement to be magnificent, each of the $\\mathbf{N}$ juggling path segments must intersect each of the other $\\mathbf{N}-1$ juggling path segments (but these intersections do not necessarily all have to be in the same place).\n\nAfter some last minute fixes, you have what you think is a magnificent arrangement. Given the rush to put it together, you want to write a checker that can determine whether it is indeed magnificent. If it is not, then at most 25 juggler pairs fail to intersect every other pair. You want your checker to report a list of all those juggler pairs for inspection.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with one line containing a single integer $\\mathbf{N}$, the number of pairs of jugglers. Then, $\\mathbf{N}$ lines follow. The i-th of these lines contains four integers $\\mathbf{X}_\\mathbf{i}$, $\\mathbf{Y}_\\mathbf{i}$, $\\mathbf{X'}_\\mathbf{i}$, $\\mathbf{Y'}_\\mathbf{i}$. ($\\mathbf{X}_\\mathbf{i}$, $\\mathbf{Y}_\\mathbf{i}$) and ($\\mathbf{X'}_\\mathbf{i}$, $\\mathbf{Y'}_\\mathbf{i}$) are the coordinates of the positions of the two jugglers comprising the i-th juggler pair.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $y$ is uppercase MAGNIFICENT if the input represents a magnificent arrangement. Otherwise, $y$ should be a strictly increasing list of integers. Integer $i$ should be on that list if and only if the juggling path of the $i$-th juggler pair fails to intersect at least one other juggling path.", "hint": "**Sample Explanation**\n\n- In Sample Case #1, there are only two pairs, and their paths do not cross.\n- In Sample Case #2, the arrangement is magnificent: every pair's path crosses every other pair's path.\n- In Sample Case #3, only pair 3's path crosses every other pair's path.\n\n**Limits**\n\n- $-10^9 \\leq \\mathbf{X}_\\mathbf{i} \\leq 10^9$, for all $i$.\n- $-10^9 \\leq \\mathbf{Y}_\\mathbf{i} \\leq 10^9$, for all $i$.\n- $-10^9 \\leq \\mathbf{X'}_\\mathbf{i} \\leq 10^9$, for all $i$.\n- $-10^9 \\leq \\mathbf{Y'}_\\mathbf{i} \\leq 10^9$, for all $i$.\n- No three juggler positions are collinear. (Note that this also implies that no two jugglers are in the same position.)\n- For all but up to 25 pairs of jugglers, their juggling paths intersect all $\\mathbf{N} - 1$ other juggling paths.\n- Note: There may or may not exist a way to pair the jugglers such that the resulting arrangement is magnificent.\n\n**Test set 1 (5 Pts, Visible)**\n\n- Time limit: 20 seconds.\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{N} \\leq 100$.\n\n**Test set 2 (30 Pts, Hidden)**\n\n- Time limit: 45 seconds.\n- $1 \\leq \\mathbf{T} \\leq 13$.\n- $2 \\leq \\mathbf{N} \\leq 10^5$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 Finals] Juggle Struggle: Part 2", "background": "", "description": "The first two paragraphs (not counting this one) of this problem and \"Juggle Struggle: Part 1\" are identical. The problems can otherwise be solved independently; you do not need to read or solve one in order to read or solve the other.\n\nAs manager of the Graceful Chainsaw Jugglers group, you have decided to spice the show up a bit. Instead of having each juggler individually juggle their own chainsaws, you want them to form pairs, with each pair throwing the chainsaws back and forth to each other. In this new performance, $2 \\times \\mathbf{N}$ jugglers will be on stage at the same time, arranged into $\\mathbf{N}$ pairs, with each juggler belonging to exactly one pair.\n\nYou think the show will be more impressive if the chainsaws being juggled by different pairs of jugglers are at risk of collision. Let the stage be a two-dimensional plane, and let the straight line segment in that plane that connects the positions of two jugglers in a pair be called the pair's juggling path. When two juggling paths intersect, we say the chainsaws juggled by those pairs are at risk of collision. We call the spatial positions and the pairings of the jugglers an arrangement. An arrangement is magnificent if every two pairs of jugglers' chainsaws are at risk of collision. That is, for the arrangement to be magnificent, each of the $\\mathbf{N}$ juggling path segments must intersect each of the other $\\mathbf{N}-1$ juggling path segments (but these intersections do not necessarily all have to be in the same place).\n\nAfter some last minute fixes, you have what you think is a magnificent arrangement. Given the rush to put it together, you want to write a checker that can determine whether it is indeed magnificent. If it is not, then at most 25 juggler pairs fail to intersect every other pair. You want your checker to report a list of all those juggler pairs for inspection.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with one line containing a single integer $\\mathbf{N}$, the number of pairs of jugglers. Then, $\\mathbf{N}$ lines follow. The i-th of these lines contains four integers $\\mathbf{X}_\\mathbf{i}$, $\\mathbf{Y}_\\mathbf{i}$, $\\mathbf{X'}_\\mathbf{i}$, $\\mathbf{Y'}_\\mathbf{i}$. ($\\mathbf{X}_\\mathbf{i}$, $\\mathbf{Y}_\\mathbf{i}$) and ($\\mathbf{X'}_\\mathbf{i}$, $\\mathbf{Y'}_\\mathbf{i}$) are the coordinates of the positions of the two jugglers comprising the i-th juggler pair.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $y$ is uppercase MAGNIFICENT if the input represents a magnificent arrangement. Otherwise, $y$ should be a strictly increasing list of integers. Integer $i$ should be on that list if and only if the juggling path of the $i$-th juggler pair fails to intersect at least one other juggling path.", "hint": "**Sample Explanation**\n\n- In Sample Case #1, there are only two pairs, and their paths do not cross.\n- In Sample Case #2, the arrangement is magnificent: every pair's path crosses every other pair's path.\n- In Sample Case #3, only pair 3's path crosses every other pair's path.\n\n**Limits**\n\n- $-10^9 \\leq \\mathbf{X}_\\mathbf{i} \\leq 10^9$, for all $i$.\n- $-10^9 \\leq \\mathbf{Y}_\\mathbf{i} \\leq 10^9$, for all $i$.\n- $-10^9 \\leq \\mathbf{X'}_\\mathbf{i} \\leq 10^9$, for all $i$.\n- $-10^9 \\leq \\mathbf{Y'}_\\mathbf{i} \\leq 10^9$, for all $i$.\n- No three juggler positions are collinear. (Note that this also implies that no two jugglers are in the same position.)\n- For all but up to 25 pairs of jugglers, their juggling paths intersect all $\\mathbf{N} - 1$ other juggling paths.\n- Note: There may or may not exist a way to pair the jugglers such that the resulting arrangement is magnificent.\n\n**Test set 1 (5 Pts, Visible)**\n\n- Time limit: 20 seconds.\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{N} \\leq 100$.\n\n**Test set 2 (30 Pts, Hidden)**\n\n- Time limit: 45 seconds.\n- $1 \\leq \\mathbf{T} \\leq 13$.\n- $2 \\leq \\mathbf{N} \\leq 10^5$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 Finals] Juggle Struggle: Part 2", "background": null, "description": "本题的前两段（不包括本段）与“Juggle Struggle: Part 1”完全相同。除此之外，这两道题可以独立解决，你无需阅读或解决其中一道才能理解或解决另一道。\n\n作为 Graceful Chainsaw Jugglers 团队的经理，你决定让表演更加精彩。你不再让每个杂技演员单独抛接自己的电锯，而是让他们两两组队，每对互相抛接电锯。在新的表演中，$2 \\times \\mathbf{N}$ 名杂技演员将同时登台，分成 $\\mathbf{N}$ 对，每个杂技演员恰好属于一对。\n\n你认为，如果不同杂技演员对抛接的电锯有相互碰撞的风险，表演会更加惊险。设舞台为一个二维平面，将一对杂技演员的位置用一条直线段连接，称为该对的“抛接路径”。当两对杂技演员的抛接路径相交时，说明他们抛接的电锯存在碰撞风险。我们将杂技演员的空间位置和分组方式称为一种“安排”。如果每一对杂技演员的抛接路径都与其他每一对的抛接路径相交，则称该安排为“壮观的”。也就是说，要使安排壮观，$\\mathbf{N}$ 条抛接路径中的每一条都必须与其他 $\\mathbf{N}-1$ 条路径相交（这些交点不必都在同一位置）。\n\n经过最后的调整后，你认为你已经得到了一个壮观的安排。由于准备仓促，你希望编写一个检查程序，判断该安排是否真的壮观。如果不是，则最多有 25 对杂技演员的抛接路径未能与所有其他对的路径相交。你希望你的检查程序能列出所有这些未达标的杂技演员对，供进一步检查。", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例的数量。接下来有 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含一个整数 $\\mathbf{N}$，表示杂技演员对的数量。接下来的 $\\mathbf{N}$ 行，每行包含四个整数 $\\mathbf{X}_\\mathbf{i}$、$\\mathbf{Y}_\\mathbf{i}$、$\\mathbf{X'}_\\mathbf{i}$、$\\mathbf{Y'}_\\mathbf{i}$。其中 $(\\mathbf{X}_\\mathbf{i}, \\mathbf{Y}_\\mathbf{i})$ 和 $(\\mathbf{X'}_\\mathbf{i}, \\mathbf{Y'}_\\mathbf{i})$ 分别表示第 $i$ 对杂技演员两人的坐标。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y`，其中 $y$ 为大写单词 MAGNIFICENT，如果输入表示的是一个壮观的安排；否则，$y$ 应为一个严格递增的整数列表。整数 $i$ 应出现在该列表中，当且仅当第 $i$ 对杂技演员的抛接路径未能与至少一条其他抛接路径相交。", "hint": "**样例解释**\n\n- 样例 1 中只有两对杂技演员，他们的抛接路径没有相交。\n- 样例 2 中，所有对的抛接路径都两两相交，安排是壮观的。\n- 样例 3 中，只有第 3 对的抛接路径与所有其他对的路径都相交。\n\n**数据范围**\n\n- $-10^9 \\leq \\mathbf{X}_\\mathbf{i} \\leq 10^9$，对所有 $i$。\n- $-10^9 \\leq \\mathbf{Y}_\\mathbf{i} \\leq 10^9$，对所有 $i$。\n- $-10^9 \\leq \\mathbf{X'}_\\mathbf{i} \\leq 10^9$，对所有 $i$。\n- $-10^9 \\leq \\mathbf{Y'}_\\mathbf{i} \\leq 10^9$，对所有 $i$。\n- 不存在三点共线的情况。（这也意味着没有两名杂技演员处于同一位置。）\n- 除至多 25 对杂技演员外，其余所有对的抛接路径都与其他 $\\mathbf{N} - 1$ 条路径相交。\n- 注意：不一定存在一种分组方式能使安排壮观。\n\n**测试点 1（5 分，公开）**\n\n- 时间限制：20 秒。\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $2 \\leq \\mathbf{N} \\leq 100$。\n\n**测试点 2（30 分，隐藏）**\n\n- 时间限制：45 秒。\n- $1 \\leq \\mathbf{T} \\leq 13$。\n- $2 \\leq \\mathbf{N} \\leq 10^5$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13128", "type": "P", "difficulty": 6, "samples": [["5\n2 5\nN...#\n....M\n2 5\nN#...\n...#M\n5 5\nN..##\n#.###\n#...#\n##.##\n##..M\n5 5\n..N##\n#.###\n#...#\n##.##\n##..M\n3 3\n#M#\n###\n#N#", "Case #1: 4\nCase #2: 7\nCase #3: 5\nCase #4: 6\nCase #5: IMPOSSIBLE"]], "limits": {"time": [30000, 30000, 120000], "memory": [1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2019", "广度优先搜索 BFS", "Google Code Jam"], "title": "[GCJ 2019 Finals] Go To Considered Helpful", "background": "", "description": "Marlin is a fish who lost his son and is trying to find him. Fortunately, he ran into Cynthia, a turtle, as she swam around with her brothers, Wally and Seymour. Cynthia knows exactly where Marlin needs to go, and she can be very precise in giving directions. While Marlin is smart and can follow them perfectly, keeping track of a long list of directions can be problematic. Cynthia needs to find a way to make the list of directions short.\n\nMarlin lives in a matrix of $\\mathbf{R}$ rows and $\\mathbf{C}$ columns. Some cells of the matrix are dangerous and cannot be entered. Marlin and his son are currently in different non-dangerous cells. Marlin's son never moves to a different cell. Cynthia decided to give Marlin directions in the form of a program consisting of a list of instructions, each on a single line. Each instruction is of one of 5 types:\n\n* $\\mathbf{N}$: move one cell North (up),\n* $\\mathbf{S}$: move one cell South (down),\n* $\\mathbf{W}$: move one cell West (left),\n* $\\mathbf{E}$: move one cell East (right), and\n* $\\mathbf{G}(\\mathbf{i})$: jump to the i-th line of the instruction list (counting starting from 1).\n\nAfter executing a line with any of the first 4 instructions, Marlin jumps to the next line on the list if there is one. If there is no next line, Marlin just stands still forever.\n\nFor example, if Marlin were following the program\n\n1. $\\mathbf{N}$\n2. $\\mathbf{E}$\n3. $\\mathbf{G}(6)$\n4. $\\mathbf{S}$\n5. $\\mathbf{G}(1)$\n6. $\\mathbf{W}$\n7. $\\mathbf{G}(4)$\n\nhe would move North (line 1), then East (2), then jump to line 6 without physically moving (3), then move West (6), then jump to line 4 (7), then move South (4), then jump to line 1 (5), then move North (1), etc.\n\nIf at any point Marlin and his son are at the same cell, they will be reunited and Marlin will no longer follow any instructions. Cynthia the turtle wants to find out the smallest number of lines in a program that would get Marlin to the same cell as his son, without him ever going into a dangerous cell or moving outside of the matrix boundaries. All $\\mathbf{G}$ instructions must jump to existing lines in the program.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing $\\mathbf{R}$ and $\\mathbf{C}$, the number of rows and columns in the matrix. Then, $\\mathbf{R}$ lines follow containing a string of $\\mathbf{C}$ characters each. The $j$-th character of the $i$-th of these lines $\\mathbf{A}_{ij}$ represents the cell in the $i$-th row and $j$-th column of the matrix. The character is $\\#$ if the cell is dangerous, an uppercase $\\mathbf{M}$ if the cell is the one Marlin is currently at, an uppercase $\\mathbf{N}$ if the cell is the one Marlin's son is currently at and $\\mathbf{.}$ if the cell is an unoccupied non-dangerous cell.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is $\\text{IMPOSSIBLE}$ if there is no program that would get Marlin to his son under the conditions explained above, or the smallest number of instructions in such a program.", "hint": "**Sample Explanation**\n\nBelow are some shortest programs for each of the possible sample case.\n\n- Sample Case #1:\n```\n1: W\n2: N\n3: S\n4: G(1)\n```\nor\n```\n1: W\n2: N\n3: W\n4: G(3)\n```\n\n- Sample Case #2:\n```\n1: N\n2: W\n3: W\n4: S\n5: W\n6: W\n7: N\n```\n- Sample Case #3:\n```\n1: W\n2: W\n3: N\n4: N\n5: G(2)\n```\n- Sample Case #4:\n```\n1: W\n2: W\n3: N\n4: N\n5: E\n6: G(1)\n```\n\n**Sample Explanation**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $\\mathbf{A}_{ij}$ is either $\\#$, $\\mathbf{.}$, uppercase $\\mathbf{M}$ or uppercase $\\mathbf{N}$, for all $i$ and $j$.\n- $\\mathbf{A}_{ij} = \\mathbf{M}$ for exactly one pair of $i$ and $j$.\n- $\\mathbf{A}_{ij} = \\mathbf{N}$ for exactly one pair of $i$ and $j$.\n\n**Test set 1 (19 Pts, Visible)**\n\n- Time limit: 30 seconds.\n- $1 \\leq \\mathbf{R} \\leq 10$.\n- $1 \\leq \\mathbf{C} \\leq 10$.\n\n**Test set 2 (30 Pts, Hidden)**\n\n- Time limit: 120 seconds.\n- For at most 10 test cases:\n  - $1 \\leq \\mathbf{R} \\leq 100$.\n  - $1 \\leq \\mathbf{C} \\leq 100$.\n- For the remaining test cases:\n  - $1 \\leq \\mathbf{R} \\leq 50$.\n  - $1 \\leq \\mathbf{C} \\leq 50$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 Finals] Go To Considered Helpful", "background": "", "description": "Marlin is a fish who lost his son and is trying to find him. Fortunately, he ran into Cynthia, a turtle, as she swam around with her brothers, Wally and Seymour. Cynthia knows exactly where Marlin needs to go, and she can be very precise in giving directions. While Marlin is smart and can follow them perfectly, keeping track of a long list of directions can be problematic. Cynthia needs to find a way to make the list of directions short.\n\nMarlin lives in a matrix of $\\mathbf{R}$ rows and $\\mathbf{C}$ columns. Some cells of the matrix are dangerous and cannot be entered. Marlin and his son are currently in different non-dangerous cells. Marlin's son never moves to a different cell. Cynthia decided to give Marlin directions in the form of a program consisting of a list of instructions, each on a single line. Each instruction is of one of 5 types:\n\n* $\\mathbf{N}$: move one cell North (up),\n* $\\mathbf{S}$: move one cell South (down),\n* $\\mathbf{W}$: move one cell West (left),\n* $\\mathbf{E}$: move one cell East (right), and\n* $\\mathbf{G}(\\mathbf{i})$: jump to the i-th line of the instruction list (counting starting from 1).\n\nAfter executing a line with any of the first 4 instructions, Marlin jumps to the next line on the list if there is one. If there is no next line, Marlin just stands still forever.\n\nFor example, if Marlin were following the program\n\n1. $\\mathbf{N}$\n2. $\\mathbf{E}$\n3. $\\mathbf{G}(6)$\n4. $\\mathbf{S}$\n5. $\\mathbf{G}(1)$\n6. $\\mathbf{W}$\n7. $\\mathbf{G}(4)$\n\nhe would move North (line 1), then East (2), then jump to line 6 without physically moving (3), then move West (6), then jump to line 4 (7), then move South (4), then jump to line 1 (5), then move North (1), etc.\n\nIf at any point Marlin and his son are at the same cell, they will be reunited and Marlin will no longer follow any instructions. Cynthia the turtle wants to find out the smallest number of lines in a program that would get Marlin to the same cell as his son, without him ever going into a dangerous cell or moving outside of the matrix boundaries. All $\\mathbf{G}$ instructions must jump to existing lines in the program.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing $\\mathbf{R}$ and $\\mathbf{C}$, the number of rows and columns in the matrix. Then, $\\mathbf{R}$ lines follow containing a string of $\\mathbf{C}$ characters each. The $j$-th character of the $i$-th of these lines $\\mathbf{A}_{ij}$ represents the cell in the $i$-th row and $j$-th column of the matrix. The character is $\\#$ if the cell is dangerous, an uppercase $\\mathbf{M}$ if the cell is the one Marlin is currently at, an uppercase $\\mathbf{N}$ if the cell is the one Marlin's son is currently at and $\\mathbf{.}$ if the cell is an unoccupied non-dangerous cell.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is $\\text{IMPOSSIBLE}$ if there is no program that would get Marlin to his son under the conditions explained above, or the smallest number of instructions in such a program.", "hint": "**Sample Explanation**\n\nBelow are some shortest programs for each of the possible sample case.\n\n- Sample Case #1:\n```\n1: W\n2: N\n3: S\n4: G(1)\n```\nor\n```\n1: W\n2: N\n3: W\n4: G(3)\n```\n\n- Sample Case #2:\n```\n1: N\n2: W\n3: W\n4: S\n5: W\n6: W\n7: N\n```\n- Sample Case #3:\n```\n1: W\n2: W\n3: N\n4: N\n5: G(2)\n```\n- Sample Case #4:\n```\n1: W\n2: W\n3: N\n4: N\n5: E\n6: G(1)\n```\n\n**Sample Explanation**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $\\mathbf{A}_{ij}$ is either $\\#$, $\\mathbf{.}$, uppercase $\\mathbf{M}$ or uppercase $\\mathbf{N}$, for all $i$ and $j$.\n- $\\mathbf{A}_{ij} = \\mathbf{M}$ for exactly one pair of $i$ and $j$.\n- $\\mathbf{A}_{ij} = \\mathbf{N}$ for exactly one pair of $i$ and $j$.\n\n**Test set 1 (19 Pts, Visible)**\n\n- Time limit: 30 seconds.\n- $1 \\leq \\mathbf{R} \\leq 10$.\n- $1 \\leq \\mathbf{C} \\leq 10$.\n\n**Test set 2 (30 Pts, Hidden)**\n\n- Time limit: 120 seconds.\n- For at most 10 test cases:\n  - $1 \\leq \\mathbf{R} \\leq 100$.\n  - $1 \\leq \\mathbf{C} \\leq 100$.\n- For the remaining test cases:\n  - $1 \\leq \\mathbf{R} \\leq 50$.\n  - $1 \\leq \\mathbf{C} \\leq 50$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 Finals] Go To Considered Helpful", "background": null, "description": "Marlin 是一条丢失了儿子的鱼，正在努力寻找他的儿子。幸运的是，他遇到了正在和兄弟 Wally 与 Seymour 一起游泳的海龟 Cynthia。Cynthia 知道 Marlin 需要去哪里，并且她可以非常精确地给出指引。虽然 Marlin 很聪明，能够完美地按照指令行动，但要记住一长串指令还是很困难的。Cynthia 需要想办法让指令列表尽可能简短。\n\nMarlin 生活在一个有 $\\mathbf{R}$ 行 $\\mathbf{C}$ 列的矩阵中。矩阵中的某些格子是危险的，不能进入。Marlin 和他的儿子目前分别位于两个不同的非危险格子中。Marlin 的儿子不会移动。Cynthia 决定以程序的形式给 Marlin 指路，这个程序由若干条指令组成，每条指令占一行。每条指令有以下 5 种类型之一：\n\n- $\\mathbf{N}$：向北（上）移动一格，\n- $\\mathbf{S}$：向南（下）移动一格，\n- $\\mathbf{W}$：向西（左）移动一格，\n- $\\mathbf{E}$：向东（右）移动一格，\n- $\\mathbf{G}(\\mathbf{i})$：跳转到指令列表的第 $i$ 行（从 1 开始计数）。\n\n每当执行前 4 种指令中的任意一种后，如果还有下一行指令，Marlin 会跳到下一行继续执行。如果没有下一行指令，Marlin 就会原地停留，永远不再移动。\n\n例如，假如 Marlin 执行如下程序：\n\n1. $\\mathbf{N}$\n2. $\\mathbf{E}$\n3. $\\mathbf{G}(6)$\n4. $\\mathbf{S}$\n5. $\\mathbf{G}(1)$\n6. $\\mathbf{W}$\n7. $\\mathbf{G}(4)$\n\n他会先向北移动（第 1 行），然后向东移动（第 2 行），接着跳转到第 6 行（第 3 行），然后向西移动（第 6 行），再跳转到第 4 行（第 7 行），然后向南移动（第 4 行），再跳转到第 1 行（第 5 行），然后向北移动（第 1 行），如此循环往复。\n\n如果某一时刻 Marlin 和他的儿子处于同一个格子，他们就会团聚，Marlin 也会停止执行任何指令。海龟 Cynthia 想知道，能够让 Marlin 安全到达他儿子所在格子的最短程序需要多少行指令，且在此过程中 Marlin 不能进入危险格子，也不能走出矩阵边界。所有 $\\mathbf{G}$ 指令必须跳转到程序中已存在的行。", "inputFormat": "输入的第一行为测试用例数 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试数据。每组测试数据的第一行为两个整数 $\\mathbf{R}$ 和 $\\mathbf{C}$，表示矩阵的行数和列数。接下来有 $\\mathbf{R}$ 行，每行包含一个长度为 $\\mathbf{C}$ 的字符串。第 $i$ 行第 $j$ 列的字符 $\\mathbf{A}_{ij}$ 表示矩阵中第 $i$ 行第 $j$ 列的格子。若该格子为危险格子，则为字符 $\\#$；若为 Marlin 当前所在格子，则为大写字母 $\\mathbf{M}$；若为 Marlin 儿子当前所在格子，则为大写字母 $\\mathbf{N}$；若为未被占用的非危险格子，则为 $\\mathbf{.}$。", "outputFormat": "对于每组测试数据，输出一行，格式为 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为在上述条件下能让 Marlin 到达他儿子所在格子的最短程序所需的指令行数。如果不存在这样的程序，则输出 $\\text{IMPOSSIBLE}$。", "hint": "**样例说明**\n\n下面是每个样例的最短程序示例。\n\n- 样例 1：\n```\n1: W\n2: N\n3: S\n4: G(1)\n```\n或\n```\n1: W\n2: N\n3: W\n4: G(3)\n```\n\n- 样例 2：\n```\n1: N\n2: W\n3: W\n4: S\n5: W\n6: W\n7: N\n```\n- 样例 3：\n```\n1: W\n2: W\n3: N\n4: N\n5: G(2)\n```\n- 样例 4：\n```\n1: W\n2: W\n3: N\n4: N\n5: E\n6: G(1)\n```\n\n**样例解释**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 对所有 $i$ 和 $j$，$\\mathbf{A}_{ij}$ 只可能为 $\\#$、$\\mathbf{.}$、大写字母 $\\mathbf{M}$ 或大写字母 $\\mathbf{N}$。\n- 恰好有一对 $i$ 和 $j$ 使得 $\\mathbf{A}_{ij} = \\mathbf{M}$。\n- 恰好有一对 $i$ 和 $j$ 使得 $\\mathbf{A}_{ij} = \\mathbf{N}$。\n\n**测试点 1（19 分，公开）**\n\n- 时间限制：30 秒。\n- $1 \\leq \\mathbf{R} \\leq 10$。\n- $1 \\leq \\mathbf{C} \\leq 10$。\n\n**测试点 2（30 分，隐藏）**\n\n- 时间限制：120 秒。\n- 最多 10 个测试用例满足：\n  - $1 \\leq \\mathbf{R} \\leq 100$。\n  - $1 \\leq \\mathbf{C} \\leq 100$。\n- 其余测试用例满足：\n  - $1 \\leq \\mathbf{R} \\leq 50$。\n  - $1 \\leq \\mathbf{C} \\leq 50$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13129", "type": "P", "difficulty": 6, "samples": [["5 5\n1 2 2 3\n2 3\n1 4 3\n2 3\n2 4\n2 1", "0 0\n0 0\n3 2\n3 2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "O2优化", "Ynoi"], "title": "[Ynoi Easy Round 2019] 有马加奈", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/0xyttjqf.png)", "description": "对于一个节点 $i$ 存在二元组信息 $(a_i,b_i)$。\n\n给定大小为 $n$ 的树。初始化所有节点全为 $(0,0)$。根为 $1$。\n\n给定 $m$ 个操作。\n\n- $1 \\ x \\ c$ 设当前操作编号为 $z$，对于 $x$ 到根路径，路径上的所有节点 $i$ 的二元组信息，若 $a_i = c$ 那么令 $(a_i,b_i) \\leftarrow (c,b_i)$ 否则令 $(a_i,b_i) \\leftarrow (c,z)$。\n\n- $2 \\ x$ 查询 $(a_x,b_x)$。", "inputFormat": "第一行两个整数 $n,m$ 代表树的大小和操作个数。\n\n接下来一行 $n - 1$ 个数，第 $i$ 个数 $p_i$ 表示点 $i + 1$ 的父亲 $p_i$。\n\n接下来 $m$ 行，每行三个数或两个数代表操作。", "outputFormat": "对于每个询问，输出一行两个数表示答案。", "hint": "Idea：\nFutaRimeWoawaSete，Solution：\nFutaRimeWoawaSete，Code：\nFutaRimeWoawaSete，Data：\nFutaRimeWoawaSete\n\n#### 【数据范围】\n\n|    测试点    |         $n$          |         $m$         | 特殊性质 |\n| :----------: | :------------------: | :-----------------: | :------: |\n|  $1 \\sim 5$  | $\\leq \\times 10 ^ 5$ |    $\\leq 10 ^ 5$    |   $A$    |\n| $6 \\sim 10$  |    $\\leq 10 ^ 5$     |    $\\leq 10 ^ 5$    |   $B$    |\n| $11 \\sim 15$ |     $\\le 10 ^ 5$     | $\\le \\times 10 ^ 5$ |   $C$    |\n| $16 \\sim 20$ |      $\\le 10^6$      |    $\\leq 10 ^ 6$    |   $/$    |\n\n特殊性质 $A$：满足 $p_i$ 从 $[1,i - 1]$ 里随机选择。\n\n特殊性质 $B$：保证所有 $1$ 操作中 $c = 1$。\n\n特殊性质 $C$：保证 $p_i = i - 1$。\n\n所有数据保证 $n,q \\leq 10 ^ 6,x,c \\in [1,n]$。\n\n保证样例 $2,3,4,5$ 相应性质对应测试点 $1 \\sim 5,6 \\sim 10,11 \\sim 15,16 \\sim 20$ 且使用同一构造方式生成。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi Easy Round 2019] 有马加奈", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/0xyttjqf.png)", "description": "对于一个节点 $i$ 存在二元组信息 $(a_i,b_i)$。\n\n给定大小为 $n$ 的树。初始化所有节点全为 $(0,0)$。根为 $1$。\n\n给定 $m$ 个操作。\n\n- $1 \\ x \\ c$ 设当前操作编号为 $z$，对于 $x$ 到根路径，路径上的所有节点 $i$ 的二元组信息，若 $a_i = c$ 那么令 $(a_i,b_i) \\leftarrow (c,b_i)$ 否则令 $(a_i,b_i) \\leftarrow (c,z)$。\n\n- $2 \\ x$ 查询 $(a_x,b_x)$。", "inputFormat": "第一行两个整数 $n,m$ 代表树的大小和操作个数。\n\n接下来一行 $n - 1$ 个数，第 $i$ 个数 $p_i$ 表示点 $i + 1$ 的父亲 $p_i$。\n\n接下来 $m$ 行，每行三个数或两个数代表操作。", "outputFormat": "对于每个询问，输出一行两个数表示答案。", "hint": "Idea：\nFutaRimeWoawaSete，Solution：\nFutaRimeWoawaSete，Code：\nFutaRimeWoawaSete，Data：\nFutaRimeWoawaSete\n\n#### 【数据范围】\n\n|    测试点    |         $n$          |         $m$         | 特殊性质 |\n| :----------: | :------------------: | :-----------------: | :------: |\n|  $1 \\sim 5$  | $\\leq \\times 10 ^ 5$ |    $\\leq 10 ^ 5$    |   $A$    |\n| $6 \\sim 10$  |    $\\leq 10 ^ 5$     |    $\\leq 10 ^ 5$    |   $B$    |\n| $11 \\sim 15$ |     $\\le 10 ^ 5$     | $\\le \\times 10 ^ 5$ |   $C$    |\n| $16 \\sim 20$ |      $\\le 10^6$      |    $\\leq 10 ^ 6$    |   $/$    |\n\n特殊性质 $A$：满足 $p_i$ 从 $[1,i - 1]$ 里随机选择。\n\n特殊性质 $B$：保证所有 $1$ 操作中 $c = 1$。\n\n特殊性质 $C$：保证 $p_i = i - 1$。\n\n所有数据保证 $n,q \\leq 10 ^ 6,x,c \\in [1,n]$。\n\n保证样例 $2,3,4,5$ 相应性质对应测试点 $1 \\sim 5,6 \\sim 10,11 \\sim 15,16 \\sim 20$ 且使用同一构造方式生成。", "locale": "zh-CN"}}}
{"pid": "P13130", "type": "P", "difficulty": 7, "samples": [["10 30\n5 4 1 2 3 2 1 4 2 2\n2 1 1 5 3\n2 3 1 7 1\n2 9 1 7 1\n2 1 1 1 2\n2 1 1 10 1\n2 9 9 9 3\n1 3 10\n2 3 1 1 2\n1 1 8\n2 5 5 5 2\n2 1 1 1 2\n1 9 1\n2 6 5 5 2\n2 2 4 6 3\n2 7 1 5 1\n2 2 6 8 3\n2 2 1 9 3\n2 9 9 9 1\n1 2 4\n2 2 3 7 2\n1 6 3\n2 7 3 5 1\n1 2 5\n2 9 1 9 2\n2 2 3 7 2\n1 6 7\n1 2 6\n1 2 9\n2 2 1 7 1\n2 2 1 3 1", "1\n0\n0\n1\n0\n1\n0\n1\n1\n0\n0\n0\n0\n1\n0\n1\n0\n9\n4\n0\n0"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "O2优化", "Ynoi"], "title": "[Ynoi Easy Round 2019] 黑川赤音", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/9fvafeiq.png)", "description": "给定一个数组 $a$ 和 $n$ 个集合，初始第 $i$ 个集合里面只有一个元素 $i$，集合里面的每个元素对应了数组的一个下标。\n\n定义一个元素 $i$ 在集合 $S$ 中的相同数个数 $F(S,i)$ 为集合 $S$ 中元素 $j$ 的个数，满足 $a[i] = a[j]$。\n\n定义一个集合 $S$ 的 $k$-权值为：$\\forall i \\in S,\\forall j \\in S$，有多少方案 $(i,j)$ 满足 $F(S,i)+F(S,j) \\le k$，这里可以 $i=j$，并且 $(i,j)$ 与 $(j,i)$ 视为不同的方案。\n\n要进行 $m$ 次操作，操作有两种：\n\n``1 x y`` : 将 $y$ 集合里面所有元素都放入 $x$ 集合，之后将 $y$ 集合清空，操作保证 $x$ 集合和 $y$ 集合操作前非空。\n\n``2 x l r k`` : 查询 $x$ 集合保留在 $[l,r]$ 内的所有元素时的 $k$-权值，查询是独立的，不对集合进行改变。", "inputFormat": "第一行用空格隔开的两个数，表示 $n,m$。\n\n第二行包含 $n$ 个数，表示这个数组。\n\n之后 $m$ 行，每行格式如题目描述，表示一次操作。", "outputFormat": "对于每个 $2$ 操作，输出一行一个数，表示查询的答案。", "hint": "Idea：nzhtl1477，Solution：nzhtl1477，Code：nzhtl1477，Data：nzhtl1477\n\n对于 $10\\%$ 的数据，满足 $n,m \\le 100$\n\n对于另外 $20\\%$ 的数据，满足 $n,m \\le 10000$\n\n对于另外 $20\\%$ 的数据，查询的 $k$ 不变。\n\n对于 $100\\%$ 的数据，满足 $n \\le 10^5， m \\le 2 \\times 10^5$， $0 \\le a_i,k \\le m$，$1 \\le l \\le r \\le n$，$1 \\le x,y \\le n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi Easy Round 2019] 黑川赤音", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/9fvafeiq.png)", "description": "给定一个数组 $a$ 和 $n$ 个集合，初始第 $i$ 个集合里面只有一个元素 $i$，集合里面的每个元素对应了数组的一个下标。\n\n定义一个元素 $i$ 在集合 $S$ 中的相同数个数 $F(S,i)$ 为集合 $S$ 中元素 $j$ 的个数，满足 $a[i] = a[j]$。\n\n定义一个集合 $S$ 的 $k$-权值为：$\\forall i \\in S,\\forall j \\in S$，有多少方案 $(i,j)$ 满足 $F(S,i)+F(S,j) \\le k$，这里可以 $i=j$，并且 $(i,j)$ 与 $(j,i)$ 视为不同的方案。\n\n要进行 $m$ 次操作，操作有两种：\n\n``1 x y`` : 将 $y$ 集合里面所有元素都放入 $x$ 集合，之后将 $y$ 集合清空，操作保证 $x$ 集合和 $y$ 集合操作前非空。\n\n``2 x l r k`` : 查询 $x$ 集合保留在 $[l,r]$ 内的所有元素时的 $k$-权值，查询是独立的，不对集合进行改变。", "inputFormat": "第一行用空格隔开的两个数，表示 $n,m$。\n\n第二行包含 $n$ 个数，表示这个数组。\n\n之后 $m$ 行，每行格式如题目描述，表示一次操作。", "outputFormat": "对于每个 $2$ 操作，输出一行一个数，表示查询的答案。", "hint": "Idea：nzhtl1477，Solution：nzhtl1477，Code：nzhtl1477，Data：nzhtl1477\n\n对于 $10\\%$ 的数据，满足 $n,m \\le 100$\n\n对于另外 $20\\%$ 的数据，满足 $n,m \\le 10000$\n\n对于另外 $20\\%$ 的数据，查询的 $k$ 不变。\n\n对于 $100\\%$ 的数据，满足 $n \\le 10^5， m \\le 2 \\times 10^5$， $0 \\le a_i,k \\le m$，$1 \\le l \\le r \\le n$，$1 \\le x,y \\le n$。", "locale": "zh-CN"}}}
{"pid": "P13131", "type": "P", "difficulty": 7, "samples": [["5 4 3\n1 1 3 3\n5 2 2 3\n3 4 5\n2 0 7\n3 0 3", "3\n2\n1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "O2优化", "Ynoi"], "title": "[Ynoi Easy Round 2019] 神木辉", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/9w5w003j.png)", "description": "给定 $n$ 个顶点的树，顶点编号为 $1,\\dots,n$，给定长度 $n_0$ 的序列 $a_1,\\dots,a_{n_0}$，共 $m$ 次查询，每次查询给定 $l,r,x$，问树的顶点 $x$，依次向 $a_l,\\dots,a_r$ 移动一步，到达的顶点。\n\n若 $x=y$，则从顶点 $x$ 向 $y$ 移动一步到达 $x$，否则到达与 $x$ 在树上相邻且距离 $y$ 最近的位置。", "inputFormat": "第一行三个整数 $n,n_0,m$；\n\n接下来一行 $n-1$ 个整数依次表示 $f_2,\\dots,f_n$，其中 $f_i$ 是顶点 $i$ 的父亲，$1$ 为根；\n\n接下来一行 $n_0$ 个整数，依次表示 $a_1,\\dots,a_{n_0}$；\n\n接下来 $m$ 行，每行三个整数 $l\\oplus v,r\\oplus v,x\\oplus v$ 表示一次查询，其中 $v$ 是上次查询的答案（特别地，第一次查询时 $v=0$），$\\oplus$ 是按位异或。", "outputFormat": "共 $m$ 行，依次为每次查询的答案。", "hint": "Idea：Ynoi，Solution：ccz181078，Code：ccz181078，Data：ccz181078\n\n对 $100\\%$ 的数据，满足 $1\\le n,n_0,m\\le 10^5$；\n\n对于 $25%$ 的数据，满足 $n,n_0,m\\le 10^3$。\n\n对于 $25%$ 的数据，满足 $f_i=i-1$\n\n对于 $25%$ 的数据，满足 $f_i$ 在 $1,2,\\dots,i-1$ 中均匀随机选取。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi Easy Round 2019] 神木辉", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/9w5w003j.png)", "description": "给定 $n$ 个顶点的树，顶点编号为 $1,\\dots,n$，给定长度 $n_0$ 的序列 $a_1,\\dots,a_{n_0}$，共 $m$ 次查询，每次查询给定 $l,r,x$，问树的顶点 $x$，依次向 $a_l,\\dots,a_r$ 移动一步，到达的顶点。\n\n若 $x=y$，则从顶点 $x$ 向 $y$ 移动一步到达 $x$，否则到达与 $x$ 在树上相邻且距离 $y$ 最近的位置。", "inputFormat": "第一行三个整数 $n,n_0,m$；\n\n接下来一行 $n-1$ 个整数依次表示 $f_2,\\dots,f_n$，其中 $f_i$ 是顶点 $i$ 的父亲，$1$ 为根；\n\n接下来一行 $n_0$ 个整数，依次表示 $a_1,\\dots,a_{n_0}$；\n\n接下来 $m$ 行，每行三个整数 $l\\oplus v,r\\oplus v,x\\oplus v$ 表示一次查询，其中 $v$ 是上次查询的答案（特别地，第一次查询时 $v=0$），$\\oplus$ 是按位异或。", "outputFormat": "共 $m$ 行，依次为每次查询的答案。", "hint": "Idea：Ynoi，Solution：ccz181078，Code：ccz181078，Data：ccz181078\n\n对 $100\\%$ 的数据，满足 $1\\le n,n_0,m\\le 10^5$；\n\n对于 $25%$ 的数据，满足 $n,n_0,m\\le 10^3$。\n\n对于 $25%$ 的数据，满足 $f_i=i-1$\n\n对于 $25%$ 的数据，满足 $f_i$ 在 $1,2,\\dots,i-1$ 中均匀随机选取。", "locale": "zh-CN"}}}
{"pid": "P13132", "type": "P", "difficulty": 2, "samples": [["6\n1 CS\n2 CS\n1 SS\n6 SCCSSC\n2 CC\n3 CSCSS", "Case #1: 1\nCase #2: 0\nCase #3: IMPOSSIBLE\nCase #4: 2\nCase #5: 0\nCase #6: 5"]], "limits": {"time": [20000, 20000], "memory": [1048576, 1048576]}, "tags": ["字符串", "贪心", "2018", "Google Code Jam"], "title": "[GCJ 2018 Qualification] Saving The Universe Again", "background": "", "description": "An alien robot is threatening the universe, using a beam that will destroy all algorithms knowledge. We have to stop it!\n\nFortunately, we understand how the robot works. It starts off with a beam with a strength of 1, and it will run a program that is a series of instructions, which will be executed one at a time, in left to right order. Each instruction is of one of the following two types:\n\n- c (for \"charge\"): Double the beam's strength.\n- s (for \"shoot\"): Shoot the beam, doing damage equal to the beam's current strength.\n\nFor example, if the robot's program is sccssc, the robot will do the following when the program runs:\n\n- Shoot the beam, doing 1 damage.\n- Charge the beam, doubling the beam's strength to 2.\n- Charge the beam, doubling the beam's strength to 4.\n- Shoot the beam, doing 4 damage.\n- Shoot the beam, doing 4 damage.\n- Charge the beam, increasing the beam's strength to 8.\n\nIn that case, the program would do a total of $9$ damage.\n\nThe universe's top algorithmists have developed a shield that can withstand a maximum total of $\\mathbf D$ damage. But the robot's current program might do more damage than that when it runs.\n\nThe President of the Universe has volunteered to fly into space to hack the robot's program before the robot runs it. The only way the President can hack (without the robot noticing) is by swapping two adjacent instructions. For example, the President could hack the above program once by swapping the third and fourth instructions to make it scscsc. This would reduce the total damage to 7. Then, for example, the president could hack the program again to make it scsscc, reducing the damage to 5, and so on.\n\nTo prevent the robot from getting too suspicious, the President does not want to hack too many times. What is this smallest possible number of hacks which will ensure that the program does no more than $\\mathbf D$ total damage, if it is possible to do so?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each consists of one line containing an integer $\\mathbf{D}$ and a string $\\mathbf{P}$: the maximum total damage our shield can withstand, and the robot's program.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either the minimum number of hacks needed to accomplish the goal, or IMPOSSIBLE if it is not possible.", "hint": "**Sample Explanation**\n\nNote that the last three sample cases would not appear in test set 1.\n\nIn Sample Case #1, the President can swap the two instructions to reduce the total damage to 1, which the shield can withstand.\n\nIn Sample Case #2, the President does not need to hack the program at all, since the shield can already withstand the 2 total damage it will cause.\n\nIn Sample Case #3, the program will do more damage than the shield can withstand, and hacking will do nothing to change this. The universe is doomed.\n\nSample Case #4 uses the program described in the problem statement. The statement demonstrates one way to reduce the total damage to 5 using two hacks. It is not possible to reduce the damage to 6 or less by using only one hack; remember that the President can only swap adjacent instructions.\n\nIn Sample Case #5, the robot will never shoot, and so it will never do any damage. No hacking is required.\n\nIn Sample Case #6, five hacks are required. Notice that even if two hacks swap the instructions at the same two positions, they still count as separate hacks.\n\n**Limits**\n\n- $1 \\leq T \\leq 100.$\n- $1 \\leq D \\leq 10^9.$\n- $2 \\leq \\text{length of } P \\leq 30.$\n- Every character in $P$ is either $c$ or $s$.\n\n**Test set 1 (5 Pts,Visible)**\n\nThe robot's program contains either zero or one $c$ characters.\n\n**Test set 2 (10 Pts, Hidden)**\n\nNo additional restrictions to the Limits section.", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 Qualification] Saving The Universe Again", "background": "", "description": "An alien robot is threatening the universe, using a beam that will destroy all algorithms knowledge. We have to stop it!\n\nFortunately, we understand how the robot works. It starts off with a beam with a strength of 1, and it will run a program that is a series of instructions, which will be executed one at a time, in left to right order. Each instruction is of one of the following two types:\n\n- c (for \"charge\"): Double the beam's strength.\n- s (for \"shoot\"): Shoot the beam, doing damage equal to the beam's current strength.\n\nFor example, if the robot's program is sccssc, the robot will do the following when the program runs:\n\n- Shoot the beam, doing 1 damage.\n- Charge the beam, doubling the beam's strength to 2.\n- Charge the beam, doubling the beam's strength to 4.\n- Shoot the beam, doing 4 damage.\n- Shoot the beam, doing 4 damage.\n- Charge the beam, increasing the beam's strength to 8.\n\nIn that case, the program would do a total of $9$ damage.\n\nThe universe's top algorithmists have developed a shield that can withstand a maximum total of $\\mathbf D$ damage. But the robot's current program might do more damage than that when it runs.\n\nThe President of the Universe has volunteered to fly into space to hack the robot's program before the robot runs it. The only way the President can hack (without the robot noticing) is by swapping two adjacent instructions. For example, the President could hack the above program once by swapping the third and fourth instructions to make it scscsc. This would reduce the total damage to 7. Then, for example, the president could hack the program again to make it scsscc, reducing the damage to 5, and so on.\n\nTo prevent the robot from getting too suspicious, the President does not want to hack too many times. What is this smallest possible number of hacks which will ensure that the program does no more than $\\mathbf D$ total damage, if it is possible to do so?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each consists of one line containing an integer $\\mathbf{D}$ and a string $\\mathbf{P}$: the maximum total damage our shield can withstand, and the robot's program.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either the minimum number of hacks needed to accomplish the goal, or IMPOSSIBLE if it is not possible.", "hint": "**Sample Explanation**\n\nNote that the last three sample cases would not appear in test set 1.\n\nIn Sample Case #1, the President can swap the two instructions to reduce the total damage to 1, which the shield can withstand.\n\nIn Sample Case #2, the President does not need to hack the program at all, since the shield can already withstand the 2 total damage it will cause.\n\nIn Sample Case #3, the program will do more damage than the shield can withstand, and hacking will do nothing to change this. The universe is doomed.\n\nSample Case #4 uses the program described in the problem statement. The statement demonstrates one way to reduce the total damage to 5 using two hacks. It is not possible to reduce the damage to 6 or less by using only one hack; remember that the President can only swap adjacent instructions.\n\nIn Sample Case #5, the robot will never shoot, and so it will never do any damage. No hacking is required.\n\nIn Sample Case #6, five hacks are required. Notice that even if two hacks swap the instructions at the same two positions, they still count as separate hacks.\n\n**Limits**\n\n- $1 \\leq T \\leq 100.$\n- $1 \\leq D \\leq 10^9.$\n- $2 \\leq \\text{length of } P \\leq 30.$\n- Every character in $P$ is either $c$ or $s$.\n\n**Test set 1 (5 Pts,Visible)**\n\nThe robot's program contains either zero or one $c$ characters.\n\n**Test set 2 (10 Pts, Hidden)**\n\nNo additional restrictions to the Limits section.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 Qualification] Saving The Universe Again", "background": null, "description": "一个外星机器人正在威胁宇宙，它使用一束光束，能够摧毁所有的算法知识。我们必须阻止它！\n\n幸运的是，我们已经了解了机器人的工作方式。它一开始拥有强度为 $1$ 的光束，并将运行一个由一系列指令组成的程序，这些指令会按从左到右的顺序依次执行。每条指令有以下两种类型之一：\n\n- c（代表“充能”）：将光束的强度加倍。\n- s（代表“发射”）：发射光束，造成等于当前光束强度的伤害。\n\n例如，如果机器人的程序是 sccssc，当程序运行时，机器人会按如下方式执行：\n\n- 发射光束，造成 $1$ 点伤害。\n- 充能，将光束强度加倍至 $2$。\n- 充能，将光束强度加倍至 $4$。\n- 发射光束，造成 $4$ 点伤害。\n- 发射光束，造成 $4$ 点伤害。\n- 充能，将光束强度加倍至 $8$。\n\n在这种情况下，程序总共会造成 $9$ 点伤害。\n\n宇宙顶尖的算法专家们开发了一种护盾，最多可以承受 $\\mathbf D$ 点总伤害。但机器人的当前程序在运行时可能会造成超过这个数值的伤害。\n\n宇宙总统自愿飞入太空，在机器人运行程序之前对其进行黑客攻击。总统唯一能在不被机器人察觉的情况下进行的黑客手段，是交换两条相邻的指令。例如，总统可以通过交换上述程序的第三和第四条指令，将其变为 scscsc，这样总伤害就会降为 $7$。然后，总统还可以再次进行黑客操作，将程序变为 scsscc，总伤害降为 $5$，以此类推。\n\n为了避免引起机器人的怀疑，总统不希望进行太多次黑客操作。请问，最少需要多少次黑客操作，才能确保程序造成的总伤害不超过 $\\mathbf D$，如果无法做到，则输出 IMPOSSIBLE。", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试用例。每组测试用例包含一行，包括一个整数 $\\mathbf{D}$ 和一个字符串 $\\mathbf{P}$，分别表示护盾能承受的最大总伤害，以及机器人的程序。", "outputFormat": "对于每组测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是完成目标所需的最小黑客次数，或者如果无法实现则输出 IMPOSSIBLE。", "hint": "**样例解释**\n\n注意，最后三个样例不会出现在测试集 1 中。\n\n在样例 1 中，总统可以交换两条指令，将总伤害降为 $1$，护盾可以承受。\n\n在样例 2 中，总统无需进行任何黑客操作，因为程序造成的总伤害为 $2$，护盾可以承受。\n\n在样例 3 中，程序造成的伤害超过了护盾的承受能力，并且无论如何黑客都无法改变这一点。宇宙注定要毁灭。\n\n样例 4 使用了题目描述中的程序。题目中演示了一种通过两次黑客操作将总伤害降为 $5$ 的方法。仅用一次黑客操作无法将伤害降至 $6$ 或以下；请记住，总统只能交换相邻的指令。\n\n在样例 5 中，机器人永远不会发射，因此不会造成任何伤害，无需黑客操作。\n\n在样例 6 中，需要进行五次黑客操作。注意，即使两次黑客操作交换的是同一对位置的指令，也算作两次操作。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq D \\leq 10^9$。\n- $2 \\leq P$ 的长度 $\\leq 30$。\n- $P$ 中的每个字符都是 $c$ 或 $s$。\n\n**测试集 1（5 分，可见）**\n\n机器人的程序中最多只包含 $0$ 个或 $1$ 个 $c$ 字符。\n\n**测试集 2（10 分，隐藏）**\n\n无额外限制。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13133", "type": "P", "difficulty": 3, "samples": [["2\n5\n5 6 8 4 3\n3\n8 9 7", "Case #1: OK\nCase #2: 1"]], "limits": {"time": [10000, 20000], "memory": [1048576, 1048576]}, "tags": ["2018", "排序", "Google Code Jam"], "title": "[GCJ 2018 Qualification] Trouble Sort", "background": "", "description": "Deep in Code Jam's secret algorithm labs, we devote countless hours to wrestling with one of the most complex problems of our time: efficiently sorting a list of integers into non-decreasing order. We have taken a careful look at the classic bubble sort algorithm, and we are pleased to announce a new variant.\n\nThe basic operation of the standard bubble sort algorithm is to examine a pair of adjacent numbers, and reverse that pair if the left number is larger than the right number. But our algorithm examines a group of three adjacent numbers, and if the leftmost number is larger than the rightmost number, it reverses that entire group. Because our algorithm is a \"triplet bubble sort\", we have named it Trouble Sort for short.\n\n```\n  TroubleSort(L): // L is a 0-indexed list of integers\n    let done := false\n    while not done:\n      done = true\n      for i := 0; i < len(L)-2; i++:\n        if L[i] > L[i+2]:\n          done = false\n          reverse the sublist from L[i] to L[i+2], inclusive\n```\n\nFor example, for $L = 5 \\ 6 \\ 6 \\ 4 \\ 3$, Trouble Sort would proceed as follows:\n\n- First pass:\n    - inspect $5 \\ 6 \\ 6$, do nothing: $5 \\ 6 \\ 6 \\ 4 \\ 3$\n    - inspect $6 \\ 6 \\ 4$, see that $6 > 4$, reverse the triplet: $5 \\ 4 \\ 6 \\ 6 \\ 3$\n    - inspect $6 \\ 6 \\ 3$, see that $6 > 3$, reverse the triplet: $5 \\ 4 \\ 3 \\ 6 \\ 6$\n- Second pass:\n    - inspect $5 \\ 4 \\ 3$, see that $5 > 3$, reverse the triplet: $3 \\ 4 \\ 5 \\ 6 \\ 6$\n    - inspect $4 \\ 5 \\ 6$, do nothing: $3 \\ 4 \\ 5 \\ 6 \\ 6$\n    - inspect $5 \\ 6 \\ 6$, do nothing: $3 \\ 4 \\ 5 \\ 6 \\ 6$\n- Then the third pass inspects the three triplets and does nothing, so the algorithm terminates.\n\nWe were looking forward to presenting Trouble Sort at the Special Interest Group in Sorting conference in Hawaii, but one of our interns has just pointed out a problem: it is possible that Trouble Sort does not correctly sort the list! Consider the list $8 \\ 9 \\ 7$, for example.\n\nWe need your help with some further research. Given a list of $\\mathbf N$ integers, determine whether Trouble Sort will successfully sort the list into non-decreasing order. If it will not, find the index (counting starting from 0) of the first sorting error after the algorithm has finished: that is, the first value that is larger than the value that comes directly after it when the algorithm is done.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines: one line with an integer $\\mathbf{N}$, the number of values in the list, and then another line with $\\mathbf{N}$ integers $\\mathbf{V}_\\mathbf{i}$, the list of values.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is ok if Trouble Sort correctly sorts the list, or the index (counting starting from 0) of the first sorting error, as described above.", "hint": "**Sample Explanation**\n\nSample Case #1 is similar to the first one described in the problem statement. Trouble Sort correctly sorts this list, so the answer is OK.\n\nSample Case #2 is the second one described in the problem statement. Trouble Sort does not correctly sort this list, since it terminates with the list $7\\ 9\\ 8$. The $9$ is the first value in the list that is larger than the next value, so the index of the first sorting error is $1$.\n\n**Limits**\n\n- $1 \\leq T \\leq 100.$\n- $0 \\leq V_i \\leq 10^9,$ for all $i$.\n\n**Test set 1 (8 Pts, Visible)**\n\n- $3 \\leq N \\leq 100.$\n- Time limit (for the entire test set): 10 seconds.\n\n**Test set 2 (15 Pts, Hidden)**\n\n- $3 \\leq N \\leq 10^5.$\n- Time limit (for the entire test set): 20 seconds.\n\n**Special Note**\n\nNotice that test set 2 for this problem has a large amount of input, so using a non-buffered reader might lead to slower input reading. In addition, keep in mind that certain languages have a small input buffer size by default.", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 Qualification] Trouble Sort", "background": "", "description": "Deep in Code Jam's secret algorithm labs, we devote countless hours to wrestling with one of the most complex problems of our time: efficiently sorting a list of integers into non-decreasing order. We have taken a careful look at the classic bubble sort algorithm, and we are pleased to announce a new variant.\n\nThe basic operation of the standard bubble sort algorithm is to examine a pair of adjacent numbers, and reverse that pair if the left number is larger than the right number. But our algorithm examines a group of three adjacent numbers, and if the leftmost number is larger than the rightmost number, it reverses that entire group. Because our algorithm is a \"triplet bubble sort\", we have named it Trouble Sort for short.\n\n```\n  TroubleSort(L): // L is a 0-indexed list of integers\n    let done := false\n    while not done:\n      done = true\n      for i := 0; i < len(L)-2; i++:\n        if L[i] > L[i+2]:\n          done = false\n          reverse the sublist from L[i] to L[i+2], inclusive\n```\n\nFor example, for $L = 5 \\ 6 \\ 6 \\ 4 \\ 3$, Trouble Sort would proceed as follows:\n\n- First pass:\n    - inspect $5 \\ 6 \\ 6$, do nothing: $5 \\ 6 \\ 6 \\ 4 \\ 3$\n    - inspect $6 \\ 6 \\ 4$, see that $6 > 4$, reverse the triplet: $5 \\ 4 \\ 6 \\ 6 \\ 3$\n    - inspect $6 \\ 6 \\ 3$, see that $6 > 3$, reverse the triplet: $5 \\ 4 \\ 3 \\ 6 \\ 6$\n- Second pass:\n    - inspect $5 \\ 4 \\ 3$, see that $5 > 3$, reverse the triplet: $3 \\ 4 \\ 5 \\ 6 \\ 6$\n    - inspect $4 \\ 5 \\ 6$, do nothing: $3 \\ 4 \\ 5 \\ 6 \\ 6$\n    - inspect $5 \\ 6 \\ 6$, do nothing: $3 \\ 4 \\ 5 \\ 6 \\ 6$\n- Then the third pass inspects the three triplets and does nothing, so the algorithm terminates.\n\nWe were looking forward to presenting Trouble Sort at the Special Interest Group in Sorting conference in Hawaii, but one of our interns has just pointed out a problem: it is possible that Trouble Sort does not correctly sort the list! Consider the list $8 \\ 9 \\ 7$, for example.\n\nWe need your help with some further research. Given a list of $\\mathbf N$ integers, determine whether Trouble Sort will successfully sort the list into non-decreasing order. If it will not, find the index (counting starting from 0) of the first sorting error after the algorithm has finished: that is, the first value that is larger than the value that comes directly after it when the algorithm is done.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines: one line with an integer $\\mathbf{N}$, the number of values in the list, and then another line with $\\mathbf{N}$ integers $\\mathbf{V}_\\mathbf{i}$, the list of values.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is ok if Trouble Sort correctly sorts the list, or the index (counting starting from 0) of the first sorting error, as described above.", "hint": "**Sample Explanation**\n\nSample Case #1 is similar to the first one described in the problem statement. Trouble Sort correctly sorts this list, so the answer is OK.\n\nSample Case #2 is the second one described in the problem statement. Trouble Sort does not correctly sort this list, since it terminates with the list $7\\ 9\\ 8$. The $9$ is the first value in the list that is larger than the next value, so the index of the first sorting error is $1$.\n\n**Limits**\n\n- $1 \\leq T \\leq 100.$\n- $0 \\leq V_i \\leq 10^9,$ for all $i$.\n\n**Test set 1 (8 Pts, Visible)**\n\n- $3 \\leq N \\leq 100.$\n- Time limit (for the entire test set): 10 seconds.\n\n**Test set 2 (15 Pts, Hidden)**\n\n- $3 \\leq N \\leq 10^5.$\n- Time limit (for the entire test set): 20 seconds.\n\n**Special Note**\n\nNotice that test set 2 for this problem has a large amount of input, so using a non-buffered reader might lead to slower input reading. In addition, keep in mind that certain languages have a small input buffer size by default.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 Qualification] Trouble Sort", "background": null, "description": "在 Code Jam 的秘密算法实验室里，我们花费了无数小时，致力于解决当今最复杂的问题之一：高效地将一个整数序列按非递减顺序排序。我们仔细研究了经典的冒泡排序算法，并很高兴地宣布一种新变体。\n\n标准冒泡排序算法的基本操作是检查一对相邻的数字，如果左边的数字大于右边的数字，则交换这对数字。而我们的算法会检查一组三个相邻的数字，如果最左边的数字大于最右边的数字，就将整个三元组反转。由于我们的算法是“三元组冒泡排序”，我们将其简称为 Trouble Sort。\n\n```\n  TroubleSort(L): // L 是一个从 0 开始编号的整数列表\n    let done := false\n    while not done:\n      done = true\n      for i := 0; i < len(L)-2; i++:\n        if L[i] > L[i+2]:\n          done = false\n          reverse the sublist from L[i] to L[i+2], inclusive\n```\n\n例如，对于 $L = 5\\ 6\\ 6\\ 4\\ 3$，Trouble Sort 的执行过程如下：\n\n- 第一轮：\n    - 检查 $5\\ 6\\ 6$，无需操作：$5\\ 6\\ 6\\ 4\\ 3$\n    - 检查 $6\\ 6\\ 4$，发现 $6 > 4$，反转三元组：$5\\ 4\\ 6\\ 6\\ 3$\n    - 检查 $6\\ 6\\ 3$，发现 $6 > 3$，反转三元组：$5\\ 4\\ 3\\ 6\\ 6$\n- 第二轮：\n    - 检查 $5\\ 4\\ 3$，发现 $5 > 3$，反转三元组：$3\\ 4\\ 5\\ 6\\ 6$\n    - 检查 $4\\ 5\\ 6$，无需操作：$3\\ 4\\ 5\\ 6\\ 6$\n    - 检查 $5\\ 6\\ 6$，无需操作：$3\\ 4\\ 5\\ 6\\ 6$\n- 第三轮检查所有三元组均无需操作，算法终止。\n\n我们原本期待在夏威夷举办的排序特别兴趣小组会议上展示 Trouble Sort，但我们的一个实习生刚刚指出了一个问题：Trouble Sort 可能无法正确地对序列进行排序！例如，考虑序列 $8\\ 9\\ 7$。\n\n我们需要你的帮助来进一步研究。给定一个长度为 $\\mathbf N$ 的整数序列，判断 Trouble Sort 是否能将该序列正确地按非递减顺序排序。如果不能，请在算法结束后找出第一个排序错误的位置（从 0 开始计数）：即第一个比其后一个数大的数的下标。", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试数据。每组测试数据包含两行：第一行为一个整数 $\\mathbf{N}$，表示序列的长度，第二行为 $\\mathbf{N}$ 个整数 $\\mathbf{V}_\\mathbf{i}$，表示序列中的元素。", "outputFormat": "对于每组测试数据，输出一行，格式为 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为 ok（如果 Trouble Sort 能正确排序），或者为第一个排序错误的下标（从 0 开始计数），如上所述。", "hint": "**样例解释**\n\n样例 Case #1 与题目描述中的第一个例子类似。Trouble Sort 能正确排序该序列，因此输出 ok。\n\n样例 Case #2 是题目描述中的第二个例子。Trouble Sort 无法正确排序该序列，最终结果为 $7\\ 9\\ 8$。$9$ 是第一个比下一个数大的数，因此第一个排序错误的下标为 $1$。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- 对所有 $i$，$0 \\leq V_i \\leq 10^9$。\n\n**测试点 1（8 分，可见）**\n\n- $3 \\leq N \\leq 100$。\n- 整个测试点的时间限制：10 秒。\n\n**测试点 2（15 分，隐藏）**\n\n- $3 \\leq N \\leq 10^5$。\n- 整个测试点的时间限制：20 秒。\n\n**特别说明**\n\n注意，本题的测试点 2 输入量很大，因此使用非缓冲输入可能导致读取速度较慢。此外，请注意某些编程语言默认的输入缓冲区较小。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13134", "type": "P", "difficulty": 2, "samples": [["", ""]], "limits": {"time": [20000, 60000], "memory": [1048576, 1048576]}, "tags": ["2018", "交互题", "Special Judge", "概率论", "Google Code Jam"], "title": "[GCJ 2018 Qualification] Go, Gopher!", "background": "", "description": "The Code Jam team has just purchased an orchard that is a two-dimensional matrix of cells of unprepared soil, with $1000$ rows and $1000$ columns. We plan to use this orchard to grow a variety of trees — AVL, binary, red-black, splay, and so on — so we need to prepare some of the cells by digging holes:\n\n- In order to have enough trees to use for each year's tree problems, we need there to be at least $A$ prepared cells.\n- In order to care for our trees properly, the set of all prepared cells must form a single grid-aligned rectangle in which every cell within the rectangle is prepared.\n\nNote that the above also implies that none of the cells outside of that rectangle can be prepared. We want the orchard to look tidy!\n\nFor example, when $\\mathbf A=11$, although the eleven prepared cells in the left figure below form a $3 \\times 4$ rectangle (that is, with $3$ rows and $4$ columns), the cell in the center of the rectangle is not prepared. As a result, we have not yet completed preparing our orchard, since not every cell of the $3 \\times 4$ rectangle is prepared. However, after just preparing the center cell, the rectangle of size at least $11$ is fully filled, and the orchard is ready.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qetth289.png)\n\nSee below for another example. In this case, $\\mathbf{A}=6$. Note that the middle figure prepares a cell outside the $3\\times 2$ rectangle, so although the rightmost figure prepares a rectangle of size $6$, the entire set of the prepared cells does not form a rectangle (due to the extra cell on the left). As a result, the orchard is not ready.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/twco3tpd.png)\n\nDigging is hard work for humans, so we have borrowed the [Go gopher](https://blog.golang.org/gopher) from the [Google Go](https://golang.org/) team and trained it to help us out by preparing cells. We can deploy the gopher by giving it the coordinates of a target cell in the matrix that is not along any of the borders of the matrix. However, we have not yet perfected the gopher's training, so it will choose a cell uniformly at [(pseudo-)random](https://en.wikipedia.org/wiki/Pseudorandom_number_generator) from the $3\\times 3$ block of nine cells centered on the target cell, and then prepare the cell it has chosen. (If it chooses a cell that was already prepared, it will uselessly prepare it again.)\n\nWe can only deploy the gopher up to $1000$ times before it gets too tired to keep digging, so we need your help in figuring out how to deploy it strategically. When you deploy the gopher, you will be told which cell the gopher actually prepared, and you can take this information into account before deploying it again, if needed. Note that you do not have to declare the dimensions or location of a rectangle in advance.\n\n### Interactive Protocol\n\nThis problem is interactive, which means that the concepts of input and output are different than in standard Code Jam problems. You will interact with a separate process that both provides you with information and evaluates your responses. All information comes into your program via standard input; anything that you need to communicate should be sent via standard output. Remember that many programming languages buffer the output by default, so make sure your output actually goes out (for instance, by flushing the buffer) before blocking to wait for a response. See the FAQ for an explanation of what it means to flush the buffer. Anything your program sends through standard error is ignored, but it might consume some memory and be counted against your memory limit, so do not overflow it. To help you debug, a local testing tool script (in Python) is provided at the very end of the problem statement. In addition, sample solutions to a previous Code Jam interactive problem (in all of our supported languages) are provided in the analysis for Number Guessing.\n\nInitially, your program should read a single line containing a single integer $\\mathbf T$ indicating the number of test cases. Then, you need to process $\\mathbf T$ test cases.\n\nFor each test case, your program will read a single line containing a single integer $\\mathbf A$ indicating the minimum required prepared rectangular area. Then, your program will process up to $1000$ exchanges with our judge.\n\nFor each exchange, your program needs to use standard output to send a single line containing two integers $I$ and $J$: the row and column number you want to deploy the gopher to. The two integers must be between $2$ and $999$, and written in base-10 without leading zeroes. If your output format is wrong (e.g., out of bounds values), your program will fail, and the judge will send you a single line with $-1 -1$ which signals that your test has failed, and it will not send anything to your input stream after that. Otherwise, in response to your deployment, the judge will print a single line containing two integers $I'$ and $J'$ to your input stream, which your program must read through standard input.\n\nIf the last deployment caused the set of prepared cells to be a rectangle of area at least $\\mathbf A$, you will get $I' = J' = 0$, signaling the end of the test case. Otherwise, $I'$ and $J'$ are the row and column numbers of the cell that was actually prepared by the gopher, with $\\text{abs}(I'-I) \\leq 1$ and $\\text{abs}(J'-J) \\leq 1$. Then, you can start another exchange.\n\nIf your program gets something wrong (e.g. wrong output format, or out-of-bounds values), as mentioned above, the judge will send $I' = J' = -1$, and stop sending output to your input stream afterwards. If your program continues to wait for the judge after reading in $I' = J' = -1$, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive the appropriate verdict (Wrong Answer, Runtime Error, etc.) instead of a Time Limit Exceeded error. As usual, if the total time or memory is exceeded, or your program gets a runtime error, you will receive the appropriate verdict.\n\nIf the test case is solved within $1000$ deployments, you will receive the $I' = J' = 0$ message from the judge, as mentioned above, and then continue to solve the next test case. After $1000$ exchanges, if the test case is not solved, the judge will send the $I' = J' = -1$ message, and stop sending output to your input stream after.\n\nYou should not send additional information to the judge after solving all test cases. In other words, if your program keeps printing to standard output after receiving $I' = J' = 0$ message from the judge for the last test case, you will receive a Wrong Answer judgment.\n\nPlease be advised that for a given test case, the cells that the gopher will pick from each $3 \\times 3$ block are (pseudo-)random and independent of each other, but they are determined using the same seed each time for the same test case, so a solution that gives an incorrect result for a test case will do so consistently across all attempts for the same test case. We have also set different seeds for different test cases.\n", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\n```\n  t = readline_int()         // reads 2 into t\n  a = readline_int()         // reads 3 into a\n  printline 10 10 to stdout  // sends out cell 10 10 to prepare\n  flush stdout\n  x, y = readline_two_int()  // reads 10 11, since cell 10 11 is prepared\n  printline 10 10 to stdout  // sends out cell 10 10 again to prepare\n  flush stdout\n  x, y = readline_two_int()  // reads 10 10, since cell 10 10 is prepared\n  printline 10 12 to stdout  // sends out cell 10 12 to prepare\n  flush stdout\n  x, y = readline_two_int()  // reads 10 11, since cell 10 11 is prepared again\n  printline 10 10 to stdout  // sends out cell 10 10 to prepare\n  flush stdout\n  x, y = readline_two_int()  // reads 11 10, since cell 11 10 is prepared\n  printline 11 10 to stdout  // sends out cell 11 10 to prepare\n  flush stdout\n  x, y = readline_two_int()  // reads 0 0; since cell 11 11 is prepared, a rectangle of size 4\n```\n\nThe pseudocode above is the first half of a sample interaction for one test set. Suppose there are only two test cases in this test set. The pseudocode first reads the number of test cases into an integer $t$. Then the first test case begins. For the first test case, suppose $\\mathbf A$ is $3$ (although, in the real test sets, $\\mathbf A$ is always either $20$ or $200$). The pseudocode first reads the value of $\\mathbf A$ into an integer $a$, and outputs $10 \\ 10$ the location of the cell to prepare. By (pseudo-)random choice, the cell at location $10 \\ 11$ is prepared, so the code reads $10 \\ 11$ in response. Next, the code outputs cell $10 \\ 10$ again for preparation, and the gopher prepares $10 \\ 10$ this time. The code subsequently sends $10 \\ 12$ with the goal of finishing preparing a rectangle of size $3$, but only gets cell $10 \\ 11$ prepared again. $10 \\ 10$ is then sent out, and this time $11 \\ 10$ is prepared. Notice that although the prepared area is of size $3$, a rectangle has not been formed, so the preparation goes on. In the end, the pseudocode decides to try out cell $11 \\ 10$, and $0 \\ 0$ is sent back, which implies that cell $11 \\ 11$ has been prepared, completing a rectangle (or square, rather) or size $4$. As a result, the first test case is successfully solved.\n\n```\n  a = readline_int()         // reads 3 into a\n  printline 10 10 to stdout  // sends out cell 10 10 to prepare\n  x, y = readline_two_int()  // does not flush stdout; hangs on the judge\n```\n\nNow the pseudocode is ready for the second test case. It again first reads an integer $a = 3$ and decides to send cell $10\\ 10$ to prepare. However, this time, the code forgets to flush the stdout buffer! As a result, $10\\ 10$ is buffered and not sent to the judge. Both the judge and the code wait on each other, leading to a deadlock and eventually a Time Limit Exceeded error.\n\n```\n  a = readline_int()         // reads 3 into a\n  printline 1 1 to stdout    // sends out cell 1 1 to prepare\n  x, y = readline_two_int()  // reads -1 -1, since 1 is outside the range [2, 999]\n  printline 10 10 to stdout  // sends a cell location anyway\n  x, y = readline_two_int()  // hangs since the judge stops sending info to stdin\n```\n\nThe code above is another example. Suppose for the second test case, the code remembers to flush the output buffer, but sends out cell $1 \\ 1$ to prepare. Remember that the row and column of the chosen cell must both be in the range $[2, 999]$, so $1 \\ 1$ is illegal! As a result, the judge sends back $-1 \\ -1$. However, after reading $-1 \\ -1$ into $x$ and $y$, the code proceeds to send another cell location to the judge, and wait. Since there is nothing in the input stream (the judge has stopped sending info), the code hangs and will eventually receive a Time Limit Exceeded error.\n\nNote that if the code in the example above exits immediately after reading $-1 \\ -1$, it will receive a Wrong Answer instead:\n\n```\n  a = readline_int()         // reads 3 into a\n  printline 1 1 to stdout    // sends out cell 1 1 to prepare\n  x, y = readline_two_int()  // reads -1 -1, since 1 is outside the range [2, 999]\n  exit                       // receives a Wrong Answer judgment\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n$1 \\leqslant T \\leqslant 20$.\n\n**Test set 1 (10 Pts, Visible)**\n\n- $A=20$.\n- Time limit (for the entire test set): 20 seconds.\n\n**Test set 2 (20 Pts, Hidden)**\n\n- $A=200$.\n- Time limit (for the entire test set): 60 seconds.", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 Qualification] Go, Gopher!", "background": "", "description": "The Code Jam team has just purchased an orchard that is a two-dimensional matrix of cells of unprepared soil, with $1000$ rows and $1000$ columns. We plan to use this orchard to grow a variety of trees — AVL, binary, red-black, splay, and so on — so we need to prepare some of the cells by digging holes:\n\n- In order to have enough trees to use for each year's tree problems, we need there to be at least $A$ prepared cells.\n- In order to care for our trees properly, the set of all prepared cells must form a single grid-aligned rectangle in which every cell within the rectangle is prepared.\n\nNote that the above also implies that none of the cells outside of that rectangle can be prepared. We want the orchard to look tidy!\n\nFor example, when $\\mathbf A=11$, although the eleven prepared cells in the left figure below form a $3 \\times 4$ rectangle (that is, with $3$ rows and $4$ columns), the cell in the center of the rectangle is not prepared. As a result, we have not yet completed preparing our orchard, since not every cell of the $3 \\times 4$ rectangle is prepared. However, after just preparing the center cell, the rectangle of size at least $11$ is fully filled, and the orchard is ready.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qetth289.png)\n\nSee below for another example. In this case, $\\mathbf{A}=6$. Note that the middle figure prepares a cell outside the $3\\times 2$ rectangle, so although the rightmost figure prepares a rectangle of size $6$, the entire set of the prepared cells does not form a rectangle (due to the extra cell on the left). As a result, the orchard is not ready.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/twco3tpd.png)\n\nDigging is hard work for humans, so we have borrowed the [Go gopher](https://blog.golang.org/gopher) from the [Google Go](https://golang.org/) team and trained it to help us out by preparing cells. We can deploy the gopher by giving it the coordinates of a target cell in the matrix that is not along any of the borders of the matrix. However, we have not yet perfected the gopher's training, so it will choose a cell uniformly at [(pseudo-)random](https://en.wikipedia.org/wiki/Pseudorandom_number_generator) from the $3\\times 3$ block of nine cells centered on the target cell, and then prepare the cell it has chosen. (If it chooses a cell that was already prepared, it will uselessly prepare it again.)\n\nWe can only deploy the gopher up to $1000$ times before it gets too tired to keep digging, so we need your help in figuring out how to deploy it strategically. When you deploy the gopher, you will be told which cell the gopher actually prepared, and you can take this information into account before deploying it again, if needed. Note that you do not have to declare the dimensions or location of a rectangle in advance.\n\n### Interactive Protocol\n\nThis problem is interactive, which means that the concepts of input and output are different than in standard Code Jam problems. You will interact with a separate process that both provides you with information and evaluates your responses. All information comes into your program via standard input; anything that you need to communicate should be sent via standard output. Remember that many programming languages buffer the output by default, so make sure your output actually goes out (for instance, by flushing the buffer) before blocking to wait for a response. See the FAQ for an explanation of what it means to flush the buffer. Anything your program sends through standard error is ignored, but it might consume some memory and be counted against your memory limit, so do not overflow it. To help you debug, a local testing tool script (in Python) is provided at the very end of the problem statement. In addition, sample solutions to a previous Code Jam interactive problem (in all of our supported languages) are provided in the analysis for Number Guessing.\n\nInitially, your program should read a single line containing a single integer $\\mathbf T$ indicating the number of test cases. Then, you need to process $\\mathbf T$ test cases.\n\nFor each test case, your program will read a single line containing a single integer $\\mathbf A$ indicating the minimum required prepared rectangular area. Then, your program will process up to $1000$ exchanges with our judge.\n\nFor each exchange, your program needs to use standard output to send a single line containing two integers $I$ and $J$: the row and column number you want to deploy the gopher to. The two integers must be between $2$ and $999$, and written in base-10 without leading zeroes. If your output format is wrong (e.g., out of bounds values), your program will fail, and the judge will send you a single line with $-1 -1$ which signals that your test has failed, and it will not send anything to your input stream after that. Otherwise, in response to your deployment, the judge will print a single line containing two integers $I'$ and $J'$ to your input stream, which your program must read through standard input.\n\nIf the last deployment caused the set of prepared cells to be a rectangle of area at least $\\mathbf A$, you will get $I' = J' = 0$, signaling the end of the test case. Otherwise, $I'$ and $J'$ are the row and column numbers of the cell that was actually prepared by the gopher, with $\\text{abs}(I'-I) \\leq 1$ and $\\text{abs}(J'-J) \\leq 1$. Then, you can start another exchange.\n\nIf your program gets something wrong (e.g. wrong output format, or out-of-bounds values), as mentioned above, the judge will send $I' = J' = -1$, and stop sending output to your input stream afterwards. If your program continues to wait for the judge after reading in $I' = J' = -1$, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive the appropriate verdict (Wrong Answer, Runtime Error, etc.) instead of a Time Limit Exceeded error. As usual, if the total time or memory is exceeded, or your program gets a runtime error, you will receive the appropriate verdict.\n\nIf the test case is solved within $1000$ deployments, you will receive the $I' = J' = 0$ message from the judge, as mentioned above, and then continue to solve the next test case. After $1000$ exchanges, if the test case is not solved, the judge will send the $I' = J' = -1$ message, and stop sending output to your input stream after.\n\nYou should not send additional information to the judge after solving all test cases. In other words, if your program keeps printing to standard output after receiving $I' = J' = 0$ message from the judge for the last test case, you will receive a Wrong Answer judgment.\n\nPlease be advised that for a given test case, the cells that the gopher will pick from each $3 \\times 3$ block are (pseudo-)random and independent of each other, but they are determined using the same seed each time for the same test case, so a solution that gives an incorrect result for a test case will do so consistently across all attempts for the same test case. We have also set different seeds for different test cases.\n", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\n```\n  t = readline_int()         // reads 2 into t\n  a = readline_int()         // reads 3 into a\n  printline 10 10 to stdout  // sends out cell 10 10 to prepare\n  flush stdout\n  x, y = readline_two_int()  // reads 10 11, since cell 10 11 is prepared\n  printline 10 10 to stdout  // sends out cell 10 10 again to prepare\n  flush stdout\n  x, y = readline_two_int()  // reads 10 10, since cell 10 10 is prepared\n  printline 10 12 to stdout  // sends out cell 10 12 to prepare\n  flush stdout\n  x, y = readline_two_int()  // reads 10 11, since cell 10 11 is prepared again\n  printline 10 10 to stdout  // sends out cell 10 10 to prepare\n  flush stdout\n  x, y = readline_two_int()  // reads 11 10, since cell 11 10 is prepared\n  printline 11 10 to stdout  // sends out cell 11 10 to prepare\n  flush stdout\n  x, y = readline_two_int()  // reads 0 0; since cell 11 11 is prepared, a rectangle of size 4\n```\n\nThe pseudocode above is the first half of a sample interaction for one test set. Suppose there are only two test cases in this test set. The pseudocode first reads the number of test cases into an integer $t$. Then the first test case begins. For the first test case, suppose $\\mathbf A$ is $3$ (although, in the real test sets, $\\mathbf A$ is always either $20$ or $200$). The pseudocode first reads the value of $\\mathbf A$ into an integer $a$, and outputs $10 \\ 10$ the location of the cell to prepare. By (pseudo-)random choice, the cell at location $10 \\ 11$ is prepared, so the code reads $10 \\ 11$ in response. Next, the code outputs cell $10 \\ 10$ again for preparation, and the gopher prepares $10 \\ 10$ this time. The code subsequently sends $10 \\ 12$ with the goal of finishing preparing a rectangle of size $3$, but only gets cell $10 \\ 11$ prepared again. $10 \\ 10$ is then sent out, and this time $11 \\ 10$ is prepared. Notice that although the prepared area is of size $3$, a rectangle has not been formed, so the preparation goes on. In the end, the pseudocode decides to try out cell $11 \\ 10$, and $0 \\ 0$ is sent back, which implies that cell $11 \\ 11$ has been prepared, completing a rectangle (or square, rather) or size $4$. As a result, the first test case is successfully solved.\n\n```\n  a = readline_int()         // reads 3 into a\n  printline 10 10 to stdout  // sends out cell 10 10 to prepare\n  x, y = readline_two_int()  // does not flush stdout; hangs on the judge\n```\n\nNow the pseudocode is ready for the second test case. It again first reads an integer $a = 3$ and decides to send cell $10\\ 10$ to prepare. However, this time, the code forgets to flush the stdout buffer! As a result, $10\\ 10$ is buffered and not sent to the judge. Both the judge and the code wait on each other, leading to a deadlock and eventually a Time Limit Exceeded error.\n\n```\n  a = readline_int()         // reads 3 into a\n  printline 1 1 to stdout    // sends out cell 1 1 to prepare\n  x, y = readline_two_int()  // reads -1 -1, since 1 is outside the range [2, 999]\n  printline 10 10 to stdout  // sends a cell location anyway\n  x, y = readline_two_int()  // hangs since the judge stops sending info to stdin\n```\n\nThe code above is another example. Suppose for the second test case, the code remembers to flush the output buffer, but sends out cell $1 \\ 1$ to prepare. Remember that the row and column of the chosen cell must both be in the range $[2, 999]$, so $1 \\ 1$ is illegal! As a result, the judge sends back $-1 \\ -1$. However, after reading $-1 \\ -1$ into $x$ and $y$, the code proceeds to send another cell location to the judge, and wait. Since there is nothing in the input stream (the judge has stopped sending info), the code hangs and will eventually receive a Time Limit Exceeded error.\n\nNote that if the code in the example above exits immediately after reading $-1 \\ -1$, it will receive a Wrong Answer instead:\n\n```\n  a = readline_int()         // reads 3 into a\n  printline 1 1 to stdout    // sends out cell 1 1 to prepare\n  x, y = readline_two_int()  // reads -1 -1, since 1 is outside the range [2, 999]\n  exit                       // receives a Wrong Answer judgment\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n$1 \\leqslant T \\leqslant 20$.\n\n**Test set 1 (10 Pts, Visible)**\n\n- $A=20$.\n- Time limit (for the entire test set): 20 seconds.\n\n**Test set 2 (20 Pts, Hidden)**\n\n- $A=200$.\n- Time limit (for the entire test set): 60 seconds.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 Qualification] Go, Gopher!", "background": null, "description": "Code Jam 团队刚刚购买了一片果园，这片果园是一个 $1000$ 行 $1000$ 列的二维矩阵，每个格子都是未经准备的土壤。我们计划在这片果园里种植各种树木——AVL 树、二叉树、红黑树、伸展树等等——因此我们需要通过挖坑来准备一些格子：\n\n- 为了保证每年有足够的树用于树类题目，我们需要至少有 $A$ 个准备好的格子。\n- 为了便于照料树木，所有准备好的格子必须组成一个网格对齐的矩形，并且该矩形内的每一个格子都必须被准备好。\n\n注意，上述要求还意味着，矩形外的格子都不能被准备。我们希望果园看起来整洁！\n\n例如，当 $\\mathbf A=11$ 时，虽然下图左侧的 11 个准备好的格子组成了一个 $3 \\times 4$ 的矩形（即有 3 行 4 列），但该矩形中心的格子尚未准备好。因此，我们还没有完成果园的准备，因为 $3 \\times 4$ 矩形内并非每个格子都已准备好。然而，只需再准备中心的那个格子，面积至少为 11 的矩形就被完全填满，果园也就准备好了。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qetth289.png)\n\n下面是另一个例子。在这种情况下，$\\mathbf{A}=6$。注意，中间的图在 $3\\times 2$ 矩形之外准备了一个格子，因此虽然最右侧的图准备了一个面积为 6 的矩形，但所有准备好的格子并未组成一个矩形（因为左侧多了一个格子）。因此，果园还没有准备好。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/twco3tpd.png)\n\n挖坑对人类来说很辛苦，所以我们从 [Google Go](https://golang.org/) 团队借来了 [Go gopher](https://blog.golang.org/gopher)，并训练它来帮我们准备格子。我们可以通过给它一个目标格子的坐标来部署 gopher，但目标格子不能在矩阵的任意边界上。然而，我们的训练还不够完善，所以它会从以目标格子为中心的 $3\\times 3$ 区块的九个格子中，均匀地（伪）随机选择一个格子，然后准备它。（如果它选择了一个已经准备好的格子，它会无用地再准备一次。）\n\n我们最多只能部署 gopher $1000$ 次，否则它会太累而无法继续挖坑，所以我们需要你帮忙，制定一个策略来部署它。每次部署 gopher 后，你会被告知它实际准备了哪个格子，你可以据此决定下一步的部署。注意，你不需要提前声明矩形的尺寸或位置。\n\n### 交互协议\n\n本题为交互题，这意味着输入输出方式与标准 Code Jam 题目不同。你需要与一个独立的进程进行交互，该进程既向你提供信息，也会评判你的回答。所有信息都通过标准输入进入你的程序；你需要传达的信息应通过标准输出发送。请注意，许多编程语言默认会缓冲输出，因此在等待回应前，请确保你的输出已真正发送出去（例如，通过刷新缓冲区）。详见 FAQ 关于刷新缓冲区的说明。你通过标准错误输出的内容会被忽略，但可能会占用内存并计入内存限制，所以不要输出过多调试信息。为帮助你调试，题目末尾提供了本地测试工具脚本（Python 版）。此外，在 Number Guessing 的题解中还提供了所有支持语言的交互题样例代码。\n\n最开始，你的程序应读取一行，包含一个整数 $\\mathbf T$，表示测试用例的数量。然后，你需要处理 $\\mathbf T$ 个测试用例。\n\n对于每个测试用例，你的程序会读取一行，包含一个整数 $\\mathbf A$，表示所需准备的最小矩形面积。然后，你的程序最多可以与评测机进行 $1000$ 次交互。\n\n每次交互时，你需要通过标准输出发送一行，包含两个整数 $I$ 和 $J$，表示你希望部署 gopher 的行号和列号。两个整数都必须在 $2$ 到 $999$ 之间，且为十进制、无前导零。如果你的输出格式错误（如超出范围），你的程序会失败，评测机会返回一行 $-1 -1$，表示测试失败，之后不会再向你的输入流发送任何内容。否则，作为回应，评测机会向你的输入流输出一行，包含两个整数 $I'$ 和 $J'$，表示 gopher 实际准备的格子的行号和列号。\n\n如果上一次部署后，所有准备好的格子组成了一个面积至少为 $\\mathbf A$ 的矩形，你会收到 $I' = J' = 0$，表示该测试用例结束。否则，$I'$ 和 $J'$ 是 gopher 实际准备的格子的行号和列号，且满足 $\\text{abs}(I'-I) \\leq 1$ 且 $\\text{abs}(J'-J) \\leq 1$。然后，你可以开始下一次交互。\n\n如果你的程序出现错误（如输出格式错误或超出范围），如上所述，评测机会返回 $I' = J' = -1$，之后不会再向你的输入流发送任何内容。如果你的程序在读取到 $I' = J' = -1$ 后仍然等待评测机，则会超时，导致 Time Limit Exceeded 错误。请注意，你有责任让程序及时退出，以获得正确的评判结果（Wrong Answer、Runtime Error 等），而不是 Time Limit Exceeded。和往常一样，如果总时间或内存超限，或程序运行时出错，你会收到相应的评判结果。\n\n如果在 $1000$ 次部署内解决了测试用例，你会收到 $I' = J' = 0$ 的消息，然后继续解决下一个测试用例。如果 $1000$ 次交互后仍未解决该测试用例，评测机会返回 $I' = J' = -1$，之后不会再向你的输入流发送任何内容。\n\n在解决所有测试用例后，你不应再向评测机发送任何信息。换句话说，如果你在收到最后一个测试用例的 $I' = J' = 0$ 消息后仍继续向标准输出打印内容，你会收到 Wrong Answer 的评判。\n\n请注意，对于每个测试用例，gopher 从每个 $3 \\times 3$ 区块中选择格子的方式是（伪）随机且彼此独立的，但对于同一个测试用例，每次的随机种子是相同的，因此对于同一个测试用例，错误的解法会始终错误。不同测试用例的随机种子不同。", "inputFormat": "见交互协议。", "outputFormat": "见交互协议。", "hint": "**交互样例**\n\n```\n  t = readline_int()         // 读取 t=2\n  a = readline_int()         // 读取 a=3\n  printline 10 10 to stdout  // 输出 10 10，表示准备该格子\n  flush stdout\n  x, y = readline_two_int()  // 读取 10 11，表示实际准备了 10 11\n  printline 10 10 to stdout  // 再次输出 10 10\n  flush stdout\n  x, y = readline_two_int()  // 读取 10 10，实际准备了 10 10\n  printline 10 12 to stdout  // 输出 10 12\n  flush stdout\n  x, y = readline_two_int()  // 读取 10 11，再次准备了 10 11\n  printline 10 10 to stdout  // 输出 10 10\n  flush stdout\n  x, y = readline_two_int()  // 读取 11 10，实际准备了 11 10\n  printline 11 10 to stdout  // 输出 11 10\n  flush stdout\n  x, y = readline_two_int()  // 读取 0 0，表示 11 11 被准备好，形成了面积为 4 的矩形\n```\n\n上面的伪代码是某一测试组的前半部分交互样例。假设该测试组只有两个测试用例。伪代码首先读取测试用例数 $t$。然后开始第一个测试用例，假设 $\\mathbf A = 3$（实际测试组中 $\\mathbf A$ 只会是 $20$ 或 $200$）。伪代码首先读取 $a$，然后输出 $10\\ 10$，请求准备该格子。由于（伪）随机选择，$10\\ 11$ 被准备，于是读取 $10\\ 11$。接着再次请求 $10\\ 10$，这次 $10\\ 10$ 被准备。随后输出 $10\\ 12$，希望完成面积为 $3$ 的矩形，但只得到了 $10\\ 11$。再次请求 $10\\ 10$，这次 $11\\ 10$ 被准备。注意，虽然准备好的面积已达 $3$，但还未形成矩形，因此继续准备。最后尝试 $11\\ 10$，收到 $0\\ 0$，表示 $11\\ 11$ 被准备，完成了面积为 $4$ 的矩形（实际上是正方形）。因此，第一个测试用例成功解决。\n\n```\n  a = readline_int()         // 读取 a=3\n  printline 10 10 to stdout  // 输出 10 10\n  x, y = readline_two_int()  // 未刷新输出缓冲区，导致评测机阻塞\n```\n\n现在准备第二个测试用例。再次读取 $a=3$，并请求准备 $10\\ 10$。但这次忘记刷新输出缓冲区！结果 $10\\ 10$ 被缓冲，未发送给评测机。评测机和代码都在等待对方，最终导致超时。\n\n```\n  a = readline_int()         // 读取 a=3\n  printline 1 1 to stdout    // 输出 1 1\n  x, y = readline_two_int()  // 读取 -1 -1，因为 1 不在 [2, 999] 范围内\n  printline 10 10 to stdout  // 仍然输出\n  x, y = readline_two_int()  // 阻塞，因为评测机已停止发送信息\n```\n\n上面是另一个例子。假设第二个测试用例，代码记得刷新输出缓冲区，但输出了 $1\\ 1$。注意，行列号必须都在 $[2, 999]$ 范围内，所以 $1\\ 1$ 非法！评测机返回 $-1\\ -1$。但代码在读取到 $-1\\ -1$ 后仍然向评测机发送请求并等待，评测机已停止发送信息，最终导致超时。\n\n注意，如果上述代码在读取到 $-1\\ -1$ 后立即退出，则会收到 Wrong Answer：\n\n```\n  a = readline_int()         // 读取 a=3\n  printline 1 1 to stdout    // 输出 1 1\n  x, y = readline_two_int()  // 读取 -1 -1，因为 1 不在 [2, 999] 范围内\n  exit                       // 收到 Wrong Answer 评判\n```\n\n你可以使用本地测试工具在本地或平台上测试。要在本地测试，你需要让测试工具与你的代码并行运行；你可以使用我们的 [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)。更多信息请阅读该文件中的注释说明。\n\n测试工具的使用说明已包含在脚本注释中。建议你添加自己的测试用例。请注意，虽然测试工具旨在模拟评测系统，但它**不是**真正的评测系统，可能会有不同的表现。\n\n**数据范围**\n\n$1 \\leqslant T \\leqslant 20$。\n\n**测试点 1（10 分，可见）**\n\n- $A=20$。\n- 整个测试点的时间限制：20 秒。\n\n**测试点 2（20 分，隐藏）**\n\n- $A=200$。\n- 整个测试点的时间限制：60 秒。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
