{"pid": "P10472", "type": "P", "difficulty": 2, "samples": [["({({(({()}})}{())})})[){{{([)()((()]]}])[{)]}{[}{)", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "栈"], "title": "括号画家", "background": null, "description": "Candela 是一名漫画家，她有一个奇特的爱好，就是在纸上画括号。这一天，刚刚起床的 Candela 画了一排括号序列，其中包含小括号 `()`、中括号 `[]` 和大括号 `{}`，总长度为 $N$。这排随意绘制的括号序列显得杂乱无章，于是 Candela 定义了什么样的括号序列是美观的：\n\n1. 空的括号序列是美观的；\n2. 若括号序列 A 是美观的，则括号序列 `(A)`、`[A]`、`{A}` 也是美观的；\n3. 若括号序列 A、B 都是美观的，则括号序列 `AB` 也是美观的；\n\n例如 `[(){}]()` 是美观的括号序列，而 `)({)[}](` 则不是。\n\n现在 Candela 想在她绘制的括号序列中，找出其中连续的一段，满足这段子序列是美观的，并且长度尽量大。你能帮帮她吗？", "inputFormat": "第一行一个长度为 $N$ 的括号序列。", "outputFormat": "一个整数，表示最长的美观的连续子序列的长度。", "hint": "数据保证，$5\\leq N \\leq 10^4$，其中各个测试点的 $N$ 的大小分别为：$5,10,50,100,100,1000,1000,10000,10000,10000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "括号画家", "background": null, "description": "Candela 是一名漫画家，她有一个奇特的爱好，就是在纸上画括号。这一天，刚刚起床的 Candela 画了一排括号序列，其中包含小括号 `()`、中括号 `[]` 和大括号 `{}`，总长度为 $N$。这排随意绘制的括号序列显得杂乱无章，于是 Candela 定义了什么样的括号序列是美观的：\n\n1. 空的括号序列是美观的；\n2. 若括号序列 A 是美观的，则括号序列 `(A)`、`[A]`、`{A}` 也是美观的；\n3. 若括号序列 A、B 都是美观的，则括号序列 `AB` 也是美观的；\n\n例如 `[(){}]()` 是美观的括号序列，而 `)({)[}](` 则不是。\n\n现在 Candela 想在她绘制的括号序列中，找出其中连续的一段，满足这段子序列是美观的，并且长度尽量大。你能帮帮她吗？", "inputFormat": "第一行一个长度为 $N$ 的括号序列。", "outputFormat": "一个整数，表示最长的美观的连续子序列的长度。", "hint": "数据保证，$5\\leq N \\leq 10^4$，其中各个测试点的 $N$ 的大小分别为：$5,10,50,100,100,1000,1000,10000,10000,10000$。", "locale": "zh-CN"}}}
{"pid": "P10473", "type": "P", "difficulty": 4, "samples": [["(2+2)^(1+1)", "16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "O2优化", "栈"], "title": "表达式计算4", "background": "", "description": "给出一个表达式，其中运算符仅包含 +，-，*，/，^，要求求出表达式的最终值。\n\n数据可能会出现括号情况，还有可能出现多余括号情况。\n\n数据保证不会出现超过 int 范围的数据，数据可能会出现负数情况。", "inputFormat": "仅一行一个字符串，即为表达式。\n", "outputFormat": "仅一行，既为表达式算出的结果。", "hint": "表达式总长度不超过 $30$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "表达式计算4", "background": "", "description": "给出一个表达式，其中运算符仅包含 +，-，*，/，^，要求求出表达式的最终值。\n\n数据可能会出现括号情况，还有可能出现多余括号情况。\n\n数据保证不会出现超过 int 范围的数据，数据可能会出现负数情况。", "inputFormat": "仅一行一个字符串，即为表达式。\n", "outputFormat": "仅一行，既为表达式算出的结果。", "hint": "表达式总长度不超过 $30$。", "locale": "zh-CN"}}}
{"pid": "P10474", "type": "P", "difficulty": 4, "samples": [["3 3 2 2\n111\n000\n111\n3\n11\n00\n11\n11\n00\n11", "1\n0\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2011", "北京", "哈希 hashing", "ICPC"], "title": "[ICPC-Beijing 2011] Matrix 矩阵哈希", "background": null, "description": "给定一个 $M$ 行 $N$ 列的 $01$ 矩阵，以及 $Q$ 个 $A$ 行 $B$ 列的 $01$ 矩阵，你需要求出这 $Q$ 个矩阵哪些在原矩阵中出现过。 \n\n所谓 $01$ 矩阵，就是矩阵中所有元素不是 $0$ 就是 $1$。", "inputFormat": "输入文件的第一行为 $M,N,A,B$，参见题目描述。 \n\n接下来 $M$ 行，每行 $N$ 个字符，非 $0$ 即 $1$ ，描述原矩阵。 \n\n接下来一行为你要处理的询问数 $Q$。\n\n接下来 $Q$ 个矩阵，一共 $Q\\times A$ 行，每行 $B$ 个字符，描述 $Q$ 个 $01$ 矩阵。", "outputFormat": "你需要输出 $Q$ 行，每行为 $0$ 或者 $1$，表示这个矩阵是否出现过，$0$ 表示没有出现过，$1$ 表示出现过。", "hint": "对于 $100\\%$ 的实际测试数据，$1\\leq M,N \\leq 1000$，$Q = 1000$。 \n\n对于 $40\\%$ 的数据，$A = 1$。\n\n对于 $80\\%$ 的数据，$A \\leq 10$。\n\n对于 $100\\%$ 的数据，$A \\leq 100$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC-Beijing 2011] Matrix 矩阵哈希", "background": null, "description": "给定一个 $M$ 行 $N$ 列的 $01$ 矩阵，以及 $Q$ 个 $A$ 行 $B$ 列的 $01$ 矩阵，你需要求出这 $Q$ 个矩阵哪些在原矩阵中出现过。 \n\n所谓 $01$ 矩阵，就是矩阵中所有元素不是 $0$ 就是 $1$。", "inputFormat": "输入文件的第一行为 $M,N,A,B$，参见题目描述。 \n\n接下来 $M$ 行，每行 $N$ 个字符，非 $0$ 即 $1$ ，描述原矩阵。 \n\n接下来一行为你要处理的询问数 $Q$。\n\n接下来 $Q$ 个矩阵，一共 $Q\\times A$ 行，每行 $B$ 个字符，描述 $Q$ 个 $01$ 矩阵。", "outputFormat": "你需要输出 $Q$ 行，每行为 $0$ 或者 $1$，表示这个矩阵是否出现过，$0$ 表示没有出现过，$1$ 表示出现过。", "hint": "对于 $100\\%$ 的实际测试数据，$1\\leq M,N \\leq 1000$，$Q = 1000$。 \n\n对于 $40\\%$ 的数据，$A = 1$。\n\n对于 $80\\%$ 的数据，$A \\leq 10$。\n\n对于 $100\\%$ 的数据，$A \\leq 100$。", "locale": "zh-CN"}}}
{"pid": "P10475", "type": "P", "difficulty": 4, "samples": [["2 5 \nABABA \nABABA\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["USACO", "哈希 hashing", "KMP 算法"], "title": "[USACO03FALL] Milking Grid（数据加强版）", "background": "", "description": "Every morning when they are milked, the Farmer John's cows form a rectangular grid that is $R (1 \\leq R \\leq 10,000)$ rows by $C (1 \\leq C \\leq 75)$ columns. As we all know, Farmer John is quite the expert on cow behavior, and is currently writing a book about feeding behavior in cows. He notices that if each cow is labeled with an uppercase letter indicating its breed, the two-dimensional pattern formed by his cows during milking sometimes seems to be made from smaller repeating rectangular patterns.\n\nHelp FJ find the rectangular unit of smallest area that can be repetitively tiled to make up the entire milking grid. Note that the dimensions of the small rectangular unit do not necessarily need to divide evenly the dimensions of the entire milking grid, as indicated in the sample input below.", "inputFormat": "- Line $1$: Two space-separated integers: $R$ and $C$\n\n- Lines $2\\dots R+1$: The grid that the cows form, with an uppercase letter denoting each cow's breed. Each of the $R$ input lines has $C$ characters with no space or other intervening character.", "outputFormat": "- Line 1: The area of the smallest unit from which the grid is formed", "hint": "The entire milking grid can be constructed from repetitions of the pattern `AB`.", "locale": "en", "translations": {"en": {"title": "[USACO03FALL] Milking Grid（数据加强版）", "background": "", "description": "Every morning when they are milked, the Farmer John's cows form a rectangular grid that is $R (1 \\leq R \\leq 10,000)$ rows by $C (1 \\leq C \\leq 75)$ columns. As we all know, Farmer John is quite the expert on cow behavior, and is currently writing a book about feeding behavior in cows. He notices that if each cow is labeled with an uppercase letter indicating its breed, the two-dimensional pattern formed by his cows during milking sometimes seems to be made from smaller repeating rectangular patterns.\n\nHelp FJ find the rectangular unit of smallest area that can be repetitively tiled to make up the entire milking grid. Note that the dimensions of the small rectangular unit do not necessarily need to divide evenly the dimensions of the entire milking grid, as indicated in the sample input below.", "inputFormat": "- Line $1$: Two space-separated integers: $R$ and $C$\n\n- Lines $2\\dots R+1$: The grid that the cows form, with an uppercase letter denoting each cow's breed. Each of the $R$ input lines has $C$ characters with no space or other intervening character.", "outputFormat": "- Line 1: The area of the smallest unit from which the grid is formed", "hint": "The entire milking grid can be constructed from repetitions of the pattern `AB`.", "locale": "en"}, "zh-CN": {"title": "[USACO03FALL] Milking Grid（数据加强版）", "background": null, "description": "每天早上挤奶时，农夫约翰的奶牛们排成一个 $R (1 \\leq R \\leq 10,000)$ 行乘 $C (1 \\leq C \\leq 75)$ 列的矩形网格。众所周知，农夫约翰是一个相当擅长牛行为的专家，目前正在撰写一本关于奶牛饲养行为的书。他注意到，如果每头奶牛都标有一个表示其品种的大写字母，那么奶牛在挤奶时形成的二维图案有时似乎是由更小的重复矩形图案组成的。\n\n帮助农夫约翰找到可以重复铺设以组成整个挤奶网格的最小面积的矩形单元。请注意，小矩形单元的尺寸不一定需要完全整除整个挤奶网格的尺寸，如下面的示例输入所示。", "inputFormat": "- 第一行：两个用空格分隔的整数：$R$ 和 $C$。\n- 第 $2\\dots R+1$ 行：奶牛形成的网格，每个奶牛的品种用大写字母表示。每个 $R$ 输入行有 $C$ 个字符，没有空格或其他间隔字符。", "outputFormat": "第一行：形成网格的最小单位的面积。", "hint": "整个挤奶网格可以由图案 AB 的重复构建。\n\n翻译来自于：ChatGPT。", "locale": "zh-CN"}}}
{"pid": "P10476", "type": "P", "difficulty": 5, "samples": [["2234342423 \n2423223434", "Yes\n2234342423"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["哈希 hashing", "双指针 two-pointer"], "title": "Necklace", "background": "", "description": "有一天，袁同学绵了一条价值连城宝石项链，但是，一个严重的问题是，他竟然忘记了项链的主人是谁！在得知此事后，很多人向同学发来了很多邮件，都说项链是自己的，要求他归还（显然其中最多只有一个人说了真话）。袁同学要求每个人都写了一段关于自己项链的描述：\n\n项链上的宝石用数字 $0$ 至 $9$ 来表示。一个对于项链的表示就是从项链的某个宝石开始：顺指针绕一圈，沿途记下经过的宝石，比如如下项链：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/57501u19.png)\n\n它的可能的四种表示是 $0123$、$1230$、$2301$、$3012$。\n\n袁同学现在心急如焚，于是他找到了你，希望你能够编一个程序，判断两个给定的描述是否代表同一个项链（注意，项链是不会翻转的）。", "inputFormat": "输入文件只有两行，每行一个由 $0$ 至 $9$ 组成的字符串，描述一个项链的表示（保证项链的长度是相等的）。", "outputFormat": "如果两条项链不可能同构，那么输出 `No`，否则的话，第一行输出一个 `Yes` 第二行输出该项链的字典序最小的表示。", "hint": "设 $L =$ 项链长度，则 $1\\leq L \\leq 1000000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Necklace", "background": "", "description": "有一天，袁同学绵了一条价值连城宝石项链，但是，一个严重的问题是，他竟然忘记了项链的主人是谁！在得知此事后，很多人向同学发来了很多邮件，都说项链是自己的，要求他归还（显然其中最多只有一个人说了真话）。袁同学要求每个人都写了一段关于自己项链的描述：\n\n项链上的宝石用数字 $0$ 至 $9$ 来表示。一个对于项链的表示就是从项链的某个宝石开始：顺指针绕一圈，沿途记下经过的宝石，比如如下项链：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/57501u19.png)\n\n它的可能的四种表示是 $0123$、$1230$、$2301$、$3012$。\n\n袁同学现在心急如焚，于是他找到了你，希望你能够编一个程序，判断两个给定的描述是否代表同一个项链（注意，项链是不会翻转的）。", "inputFormat": "输入文件只有两行，每行一个由 $0$ 至 $9$ 组成的字符串，描述一个项链的表示（保证项链的长度是相等的）。", "outputFormat": "如果两条项链不可能同构，那么输出 `No`，否则的话，第一行输出一个 `Yes` 第二行输出该项链的字典序最小的表示。", "hint": "设 $L =$ 项链长度，则 $1\\leq L \\leq 1000000$。", "locale": "zh-CN"}}}
{"pid": "P10477", "type": "P", "difficulty": 3, "samples": [["2\n0010011101001011\n0100011011001011\n0100101100100111\n0011000111010101", "same\ndifferent"]], "limits": {"time": [1000, 1000], "memory": [524288, 524288]}, "tags": ["2003", "深度优先搜索 DFS", "图遍历", "树的遍历", "ICPC"], "title": "[NWERC 2003] Subway tree systems", "background": null, "description": "Some major cities have subway systems in the form of a tree, i.e. between any pair of stations, there is one and only one way of going by subway. Moreover, most of these cities have a unique central station. Imagine you are a tourist in one of these cities and you want to explore all of the subway system. You start at the central station and pick a subway line at random and jump aboard the subway car. Every time you arrive at a station, you pick one of the subway lines you have not yet travelled on. If there is none left to explore at your current station, you take the subway line back on which you first came to the station, until you eventually have travelled along all of the lines twice,once for each direction. At that point you are back at the central station. Afterwards, all you remember of the order of your exploration is whether you went further away from the central station or back towards it at any given time, i.e. you could encode your tour as a binary string, where 0 encodes taking a subway line getting you one station further away from the central station, and 1 encodes getting you one station closer to the central station.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/57sf9gvq.png)", "inputFormat": "On the first line of input is a single positive integer n, telling the number of test scenarios to follow.Each test scenario consists of two lines, each containing a string of the characters '0' and '1' of length at most 3000, both describing a correct exploration tour of a subway tree system.", "outputFormat": "exploration tours of the same subway tree system, or the text \"different\" if the two strings cannot be exploration tours of the same subway tree system.", "hint": null, "locale": "en", "translations": {"en": {"title": "[NWERC 2003] Subway tree systems", "background": null, "description": "Some major cities have subway systems in the form of a tree, i.e. between any pair of stations, there is one and only one way of going by subway. Moreover, most of these cities have a unique central station. Imagine you are a tourist in one of these cities and you want to explore all of the subway system. You start at the central station and pick a subway line at random and jump aboard the subway car. Every time you arrive at a station, you pick one of the subway lines you have not yet travelled on. If there is none left to explore at your current station, you take the subway line back on which you first came to the station, until you eventually have travelled along all of the lines twice,once for each direction. At that point you are back at the central station. Afterwards, all you remember of the order of your exploration is whether you went further away from the central station or back towards it at any given time, i.e. you could encode your tour as a binary string, where 0 encodes taking a subway line getting you one station further away from the central station, and 1 encodes getting you one station closer to the central station.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/57sf9gvq.png)", "inputFormat": "On the first line of input is a single positive integer n, telling the number of test scenarios to follow.Each test scenario consists of two lines, each containing a string of the characters '0' and '1' of length at most 3000, both describing a correct exploration tour of a subway tree system.", "outputFormat": "exploration tours of the same subway tree system, or the text \"different\" if the two strings cannot be exploration tours of the same subway tree system.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[NWERC 2003] Subway tree systems", "background": null, "description": "一些主要城市的地铁系统采用树状结构，即在任何两个车站之间，只有一条且仅有一条地铁线路。此外，大多数这些城市都有一个独特的中央车站。想象一下，你是这些城市中的一名游客，你想要探索整个地铁系统。你从中央车站出发，随机选择一条地铁线路，跳上地铁列车。每当你到达一个车站，你就会选择一条你尚未乘坐过的地铁线路。如果在当前车站没有其他要探索的地铁线路了，你就会乘坐第一次到达该车站的地铁线路返回，直到最终你沿着所有的线路都行驶了两次，即每个方向都行驶了一次。在那时，你回到了中央车站。之后，你所记得的探索顺序只是在任何给定时间是否向中央车站更远或更近，也就是说，你可以将你的旅程编码为一个二进制字符串，其中 0 表示乘坐一条地铁线路使你离中央车站更远一站，而 1 表示使你离中央车站更近一站。", "inputFormat": "输入的第一行是一个正整数 $n$，表示接下来要跟随的测试方案的数量。每个测试方案包括两行，每行包含一个长度最多为 $3000$ 的由字符 '0' 和 '1' 组成的字符串，描述了地铁树系统的正确探索旅程。", "outputFormat": "对于每个测试方案，如果两个字符串可以表示相同地铁树系统的探索旅程，则输出 \"same\"；如果两个字符串不能表示相同地铁树系统的探索旅程，则输出 \"different\"。\n\n翻译来自于：ChatGPT。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P10478", "type": "P", "difficulty": 5, "samples": [["5 2\n2 1 -2 3 -2", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "优先队列", "反悔贪心"], "title": "生日礼物", "background": "", "description": "ftiasch 18 岁生日的时候，lqp18_31 给她看了一个神奇的序列 $A _ 1$, $A _ 2$, ..., $A _ N$。 她被允许选择不超过 $M$ 个连续的部分作为自己的生日礼物。\n\n自然地，ftiasch 想要知道选择元素之和的最大值。你能帮助她吗?", "inputFormat": "第 1 行，两个整数 $N$ ($1 \\le  N \\le 10 ^ {5}$ ) 和 $M$ ($0 \\le M \\le 10 ^ 5$)，表示序列的长度和可以选择的部分。 \n\n第 2 行， $N$ 个整数 $A_1$, $A_2$, ..., $A_N$ ($0 \\le \\mid A_i\\mid \\le 10^4$)，表示序列。\n", "outputFormat": "一个整数，表示最大的和。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "生日礼物", "background": "", "description": "ftiasch 18 岁生日的时候，lqp18_31 给她看了一个神奇的序列 $A _ 1$, $A _ 2$, ..., $A _ N$。 她被允许选择不超过 $M$ 个连续的部分作为自己的生日礼物。\n\n自然地，ftiasch 想要知道选择元素之和的最大值。你能帮助她吗?", "inputFormat": "第 1 行，两个整数 $N$ ($1 \\le  N \\le 10 ^ {5}$ ) 和 $M$ ($0 \\le M \\le 10 ^ 5$)，表示序列的长度和可以选择的部分。 \n\n第 2 行， $N$ 个整数 $A_1$, $A_2$, ..., $A_N$ ($0 \\le \\mid A_i\\mid \\le 10^4$)，表示序列。\n", "outputFormat": "一个整数，表示最大的和。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10479", "type": "P", "difficulty": 3, "samples": [["6 2 5\naabcde\nab\n0\n1\n2\n3\n4", "4\n1\n1\n0\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "哈希 hashing"], "title": "匹配统计", "background": "", "description": "阿轩在纸上写了两个字符串，分别记为 $A$ 和 $B$。利用在数据结构与算法课上学到的知识，他很容易地求出了\"字符串 $A$ 从任意位置开始的后缀子串“与“字符串 $B$”匹配的长度。\n\n不过阿轩是一个勤学好问的同学，他向你提出了 $Q$ 个问题：在每个问题中，他给定你一个整数 $X$，请你告诉他有多少个位置，满足“字符串 $A$ 从该位置开始的后缀子串\"与 $B$ 匹配的长度恰好为 $X$。\n\n例如：A=aabcde，B=ab，则 $A$ 有 aabcde、abcde、bcde、cde、de、e 这 $6$ 个后缀子串，它们与 $B=ab$ 的匹配长度分别是 $1,2,0,0,0,0$。因此 $A$ 有 $4$ 个位置与 $B$ 的匹配长度恰好为 $0$，有 $1$ 个位置的匹配长度恰好为 $1$，有 $1$ 个位置的匹配长度恰好为 $2$。", "inputFormat": "第一行三个整数 $N,M,Q$，表示 $A$ 串长度、$B$ 串长度、问题个数。\n\n第二行是字符串 $A$，第三行是字符串 $B$。\n\n接下来 $Q$ 行每行 $1$ 个整数 $x$，表示一个问题。\n\n", "outputFormat": "共 $Q$ 行，依次表示每个问题的答案。", "hint": "数据保证，$1\\leq N,M,Q,X\\leq 200000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "匹配统计", "background": "", "description": "阿轩在纸上写了两个字符串，分别记为 $A$ 和 $B$。利用在数据结构与算法课上学到的知识，他很容易地求出了\"字符串 $A$ 从任意位置开始的后缀子串“与“字符串 $B$”匹配的长度。\n\n不过阿轩是一个勤学好问的同学，他向你提出了 $Q$ 个问题：在每个问题中，他给定你一个整数 $X$，请你告诉他有多少个位置，满足“字符串 $A$ 从该位置开始的后缀子串\"与 $B$ 匹配的长度恰好为 $X$。\n\n例如：A=aabcde，B=ab，则 $A$ 有 aabcde、abcde、bcde、cde、de、e 这 $6$ 个后缀子串，它们与 $B=ab$ 的匹配长度分别是 $1,2,0,0,0,0$。因此 $A$ 有 $4$ 个位置与 $B$ 的匹配长度恰好为 $0$，有 $1$ 个位置的匹配长度恰好为 $1$，有 $1$ 个位置的匹配长度恰好为 $2$。", "inputFormat": "第一行三个整数 $N,M,Q$，表示 $A$ 串长度、$B$ 串长度、问题个数。\n\n第二行是字符串 $A$，第三行是字符串 $B$。\n\n接下来 $Q$ 行每行 $1$ 个整数 $x$，表示一个问题。\n\n", "outputFormat": "共 $Q$ 行，依次表示每个问题的答案。", "hint": "数据保证，$1\\leq N,M,Q,X\\leq 200000$。", "locale": "zh-CN"}}}
{"pid": "P10480", "type": "P", "difficulty": 3, "samples": [["10 10\n3 8\n2 3\n2 5\n5 9\n5 9\n2 3\n3 9\n4 8\n2 10\n4 9", "1\n6\n3\n3\n2\n1\n1\n1\n1\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["拓扑排序", "位运算", "bitset"], "title": "可达性统计", "background": "", "description": "给定一张 $N$ 个点 $M$ 条边的有向无环图，分别统计从每个点出发能够到达的点的数量。", "inputFormat": "第一行两个整数 $N,M$，接下来 $M$ 行每行两个整数 $x,y$，表示从 $x$ 到 $y$ 的一条有向边。", "outputFormat": "输出共 $N$ 行，表示每个点能够到达的点的数量。", "hint": "测试数据满足 $1 \\le N,M \\le 30000$，$1 \\le x,y \\le N$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "可达性统计", "background": "", "description": "给定一张 $N$ 个点 $M$ 条边的有向无环图，分别统计从每个点出发能够到达的点的数量。", "inputFormat": "第一行两个整数 $N,M$，接下来 $M$ 行每行两个整数 $x,y$，表示从 $x$ 到 $y$ 的一条有向边。", "outputFormat": "输出共 $N$ 行，表示每个点能够到达的点的数量。", "hint": "测试数据满足 $1 \\le N,M \\le 30000$，$1 \\le x,y \\le N$。", "locale": "zh-CN"}}}
{"pid": "P10481", "type": "P", "difficulty": 4, "samples": [["1\n103000509\n002109400\n000704000\n300502006\n060000050\n700803004\n000401000\n009205800\n804000107\n", "143628579\n572139468\n986754231\n391542786\n468917352\n725863914\n237481695\n619275843\n854396127\n"]], "limits": {"time": [2000], "memory": [524288]}, "tags": ["2005", "Special Judge", "深度优先搜索 DFS", "Dancing Links", "ICPC", "SEERC"], "title": "[SEERC 2005] Sudoku", "background": null, "description": "Sudoku is a very simple task. A square table with 9 rows and 9 columns is divided to 9 smaller squares 3x3 as shown on the Figure. in some of the cells arewriten decimal digits ftom 1 to 9. The other cels are empty. The goal is to fill the empty cels with decimal digis from 1 to 9, one digit per cell, in such waythat in each rowy, in each column and in each marked 3x3 subsquare, allthe digits from 1 to 9 to appear. Write a program to solve a given Sudoku-task.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3zh25t4g.png)", "inputFormat": "The input data will start with the number ofthe test cases. For each test case,9 lines follow, corresponding to the rows ofthe table. On each line a string ofexactly 9 decimal digits is given, corresponding to the cells in this line. If a cell is empty it is represented by 0.", "outputFormat": "For each test case your program should print the solution in the same format as the input data. The empty cells have to be filled according to the rules. lf solutions is not unique, then the program may print any one of them.", "hint": null, "locale": "en", "translations": {"en": {"title": "[SEERC 2005] Sudoku", "background": null, "description": "Sudoku is a very simple task. A square table with 9 rows and 9 columns is divided to 9 smaller squares 3x3 as shown on the Figure. in some of the cells arewriten decimal digits ftom 1 to 9. The other cels are empty. The goal is to fill the empty cels with decimal digis from 1 to 9, one digit per cell, in such waythat in each rowy, in each column and in each marked 3x3 subsquare, allthe digits from 1 to 9 to appear. Write a program to solve a given Sudoku-task.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3zh25t4g.png)", "inputFormat": "The input data will start with the number ofthe test cases. For each test case,9 lines follow, corresponding to the rows ofthe table. On each line a string ofexactly 9 decimal digits is given, corresponding to the cells in this line. If a cell is empty it is represented by 0.", "outputFormat": "For each test case your program should print the solution in the same format as the input data. The empty cells have to be filled according to the rules. lf solutions is not unique, then the program may print any one of them.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[SEERC 2005] Sudoku", "background": null, "description": "数独是一个非常简单的任务。一个包含 9 行和 9 列的正方形表格被分成了 9 个小的 3x3 方块，如图所示。一些单元格中写有从 1 到 9 的十进制数字。其他单元格为空。目标是以从 1 到 9 的十进制数字填充空单元格，每个单元格一个数字，使得每行、每列和每个标记的 3x3 子方块中都出现从 1 到 9 的所有数字。编写一个程序来解决给定的数独任务。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3zh25t4g.png)", "inputFormat": "输入数据将以测试用例的数量开始。对于每个测试用例，将跟随 9 行，对应于表格的行。在每一行上，给出一个正好包含 9 个十进制数字的字符串，对应于该行中的单元格。如果一个单元格为空，则用 0 表示。", "outputFormat": "对于每个测试用例，你的程序应该以与输入数据相同的格式打印解决方案。空单元格必须按照规则填充。如果解不唯一，则程序可以打印其中任何一个。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": null, "locale": "zh-CN"}}}
{"pid": "P10482", "type": "P", "difficulty": 5, "samples": [[".2738..1..1...6735.......293.5692.8...........6.1745.364.......9518...7..8..6534.\n......52..8.4......3...9...5.1...6..2..7........3.....6...1..........7.4.......3.\nend", "527389416819426735436751829375692184194538267268174593643217958951843672782965341\n416837529982465371735129468571298643293746185864351297647913852359682714128574936"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["剪枝", "Dancing Links"], "title": "Sudoku 2", "background": "", "description": "In the game of Sudoku, you are given a large 9 × 9 grid divided into smaller 3 × 3 subgrids. For example,\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/acjiq3ud.png)\n\nGiven some of the numbers in the grid, your goal is to determine the remaining numbers such that the numbers 1 through 9 appear exactly once in (1) each of nine 3 × 3 subgrids, (2) each of the nine rows, and (3) each of the nine columns.", "inputFormat": "The input test file will contain multiple cases. Each test case consists of a single line containing 81 characters, which represent the 81 squares of the Sudoku grid, given one row at a time. Each character is either a digit (from 1 to 9) or a period (used to indicate an unfilled square). You may assume that each puzzle in the input will have exactly one solution. The end-of-file is denoted by a single line containing the word “end”.", "outputFormat": "For each test case, print a line representing the completed Sudoku puzzle.", "hint": "", "locale": "en", "translations": {"en": {"title": "Sudoku 2", "background": "", "description": "In the game of Sudoku, you are given a large 9 × 9 grid divided into smaller 3 × 3 subgrids. For example,\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/acjiq3ud.png)\n\nGiven some of the numbers in the grid, your goal is to determine the remaining numbers such that the numbers 1 through 9 appear exactly once in (1) each of nine 3 × 3 subgrids, (2) each of the nine rows, and (3) each of the nine columns.", "inputFormat": "The input test file will contain multiple cases. Each test case consists of a single line containing 81 characters, which represent the 81 squares of the Sudoku grid, given one row at a time. Each character is either a digit (from 1 to 9) or a period (used to indicate an unfilled square). You may assume that each puzzle in the input will have exactly one solution. The end-of-file is denoted by a single line containing the word “end”.", "outputFormat": "For each test case, print a line representing the completed Sudoku puzzle.", "hint": "", "locale": "en"}, "zh-CN": {"title": "Sudoku 2", "background": "", "description": "在数独游戏中，给定一个大的 9 × 9 网格，分成了较小的 3 × 3 子网格。例如，\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/acjiq3ud.png)\n\n在给定网格中的一些数字后，你的目标是确定剩余的数字，使得数字 1 到 9 恰好出现在以下位置：(1) 九个 3 × 3 子网格中的每一个，(2) 九行中的每一个，以及 (3) 九列中的每一个。", "inputFormat": "输入测试文件将包含多个案例。每个测试案例由一行组成，其中包含 81 个字符，这些字符代表数独网格的 81 个方格，逐行给出。每个字符可以是一个数字（从 1 到 9）或一个句点（用于表示未填充的方格）。你可以假设输入中的每个谜题都有唯一解。文件的结尾由一行包含单词“end”表示。", "outputFormat": "对于每个测试案例，打印一行表示完成的数独谜题。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10483", "type": "P", "difficulty": 2, "samples": [["5 1996\n1\n2\n1994\n12\n29", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["深度优先搜索 DFS"], "title": "小猫爬山", "background": "", "description": "Freda 和 rainbow 饲养了 $N(N\\le 18)$ 只小猫，这天，小猫们要去爬山。经历了千辛万苦，小猫们终于爬上了山顶，但是疲倦的它们再也不想徒步走下山了\n\nFreda 和 rainbow 只好花钱让它们坐索道下山。索道上的缆车最大承重量为 $W$，而 $N$ 只小猫的重量分别是 $C_1,C_2,\\dots C_N$。当然，每辆缆车上的小猫的重量之和不能超过 $W(1\\le C_i,W \\le 10^8)$。每租用一辆缆车，Freda 和 rainbow 就要付 $1$ 美元，所以他们想知道，最少需要付多少美元才能把这 $N$ 只小猫都运送下山？", "inputFormat": "第一行包含两个用空格隔开的整数，$N$ 和 $W$。\n接下来 $N$ 行每行一个整数，其中第 $i+1$ 行的整数表示第 $i$ 只小猫的重量 $C_i$。", "outputFormat": "输出一个整数，最少需要多少美元，也就是最少需要多少辆缆车。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "小猫爬山", "background": "", "description": "Freda 和 rainbow 饲养了 $N(N\\le 18)$ 只小猫，这天，小猫们要去爬山。经历了千辛万苦，小猫们终于爬上了山顶，但是疲倦的它们再也不想徒步走下山了\n\nFreda 和 rainbow 只好花钱让它们坐索道下山。索道上的缆车最大承重量为 $W$，而 $N$ 只小猫的重量分别是 $C_1,C_2,\\dots C_N$。当然，每辆缆车上的小猫的重量之和不能超过 $W(1\\le C_i,W \\le 10^8)$。每租用一辆缆车，Freda 和 rainbow 就要付 $1$ 美元，所以他们想知道，最少需要付多少美元才能把这 $N$ 只小猫都运送下山？", "inputFormat": "第一行包含两个用空格隔开的整数，$N$ 和 $W$。\n接下来 $N$ 行每行一个整数，其中第 $i+1$ 行的整数表示第 $i$ 只小猫的重量 $C_i$。", "outputFormat": "输出一个整数，最少需要多少美元，也就是最少需要多少辆缆车。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10484", "type": "P", "difficulty": 4, "samples": [["20 5\n7\n5\n4\n18\n1", "19"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["折半搜索 meet in the middle"], "title": "送礼物", "background": "", "description": "作为惩罚，GY 被遣送去帮助某神牛给女生送礼物 (GY：貌似是个好差事）但是在 GY 看到礼物之后，他就不这么认为了。某神牛有 $N$ 个礼物，且异常沉重，但是 GY 的力气也异常的大 (-_-b)，他一次可以搬动重量和在 $w$ 以下的任意多个物品。GY 希望一次搬掉尽量重的一些物品，请你告诉他在他的力气范围内一次性能搬动的最大重量是多少。", "inputFormat": "第一行两个整数，分别代表 $W$ 和 $N$。\n\n以后 $N$ 行，每行一个正整数表示 $G_i$。", "outputFormat": "仅一个整数，表示 GY 在他的力气范围内一次性能搬动的最大重量。", "hint": "对于所有测试数据，$1 \\le N \\le 46$, $1 \\le W,G[i] \\le 2^{31}-1$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "送礼物", "background": "", "description": "作为惩罚，GY 被遣送去帮助某神牛给女生送礼物 (GY：貌似是个好差事）但是在 GY 看到礼物之后，他就不这么认为了。某神牛有 $N$ 个礼物，且异常沉重，但是 GY 的力气也异常的大 (-_-b)，他一次可以搬动重量和在 $w$ 以下的任意多个物品。GY 希望一次搬掉尽量重的一些物品，请你告诉他在他的力气范围内一次性能搬动的最大重量是多少。", "inputFormat": "第一行两个整数，分别代表 $W$ 和 $N$。\n\n以后 $N$ 行，每行一个正整数表示 $G_i$。", "outputFormat": "仅一个整数，表示 GY 在他的力气范围内一次性能搬动的最大重量。", "hint": "对于所有测试数据，$1 \\le N \\le 46$, $1 \\le W,G[i] \\le 2^{31}-1$。", "locale": "zh-CN"}}}
{"pid": "P10485", "type": "P", "difficulty": 4, "samples": [["7 7\n#######\n#..X###\n#..##O#\n#....E#\n#....E#\n#.....#\n#######\n0 0", "10"]], "limits": {"time": [1000, 1000], "memory": [524288, 524288]}, "tags": ["广度优先搜索 BFS"], "title": "Bloxorz I", "background": "", "description": "Little Tom loves playing games. One day he downloads a little computer game called 'Bloxorz' which makes him excited. It's a game about rolling a box to a specific position on a special plane. Precisely, the plane, which is composed of several unit cells, is a rectangle shaped area. And the box, consisting of two perfectly aligned unit cube, may either lies down and occupies two neighbouring cells or stands up and occupies one single cell. One may move the box by picking one of the four edges of the box on the ground and rolling the box 90 degrees around that edge, which is counted as one move. There are three kinds of cells, rigid cells, easily broken cells and empty cells. A rigid cell can support full weight of the box, so it can be either one of the two cells that the box lies on or the cell that the box fully stands on. A easily broken cells can only support half the weight of the box, so it cannot be the only cell that the box stands on. An empty cell cannot support anything, so there cannot be any part of the box on that cell. The target of the game is to roll the box standing onto the only target cell on the plane with minimum moves.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0byqnwkj.png)\n\nThe box stands on a single cell\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q3gn2fd8.png)\n\nThe box lies on two neighbouring cells, horizontally\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9vtkwepc.png)\n\nThe box lies on two neighbouring cells, vertically\n\nAfter Little Tom passes several stages of the game, he finds it much harder than he expected. So he turns to your help.", "inputFormat": "Input contains multiple test cases. Each test case is one single stage of the game. It starts with two integers R and C(3 ≤ R, C ≤ 500) which stands for number of rows and columns of the plane. That follows the plane, which contains R lines and C characters for each line, with 'O' (Oh) for target cell, 'X' for initial position of the box, '.' for a rigid cell, '#' for a empty cell and 'E' for a easily broken cell. A test cases starts with two zeros ends the input.\n\nIt guarantees that\n\n- There's only one 'O' in a plane.\n- There's either one 'X' or neighbouring two 'X's in a plane.\n- The first(and last) row(and column) must be '#'(empty cell).\n- Cells covered by 'O' and 'X' are all rigid cells.", "outputFormat": "For each test cases output one line with the minimum number of moves or \"Impossible\" (without quote) when there's no way to achieve the target cell. 　", "hint": "", "locale": "en", "translations": {"en": {"title": "Bloxorz I", "background": "", "description": "Little Tom loves playing games. One day he downloads a little computer game called 'Bloxorz' which makes him excited. It's a game about rolling a box to a specific position on a special plane. Precisely, the plane, which is composed of several unit cells, is a rectangle shaped area. And the box, consisting of two perfectly aligned unit cube, may either lies down and occupies two neighbouring cells or stands up and occupies one single cell. One may move the box by picking one of the four edges of the box on the ground and rolling the box 90 degrees around that edge, which is counted as one move. There are three kinds of cells, rigid cells, easily broken cells and empty cells. A rigid cell can support full weight of the box, so it can be either one of the two cells that the box lies on or the cell that the box fully stands on. A easily broken cells can only support half the weight of the box, so it cannot be the only cell that the box stands on. An empty cell cannot support anything, so there cannot be any part of the box on that cell. The target of the game is to roll the box standing onto the only target cell on the plane with minimum moves.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0byqnwkj.png)\n\nThe box stands on a single cell\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q3gn2fd8.png)\n\nThe box lies on two neighbouring cells, horizontally\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9vtkwepc.png)\n\nThe box lies on two neighbouring cells, vertically\n\nAfter Little Tom passes several stages of the game, he finds it much harder than he expected. So he turns to your help.", "inputFormat": "Input contains multiple test cases. Each test case is one single stage of the game. It starts with two integers R and C(3 ≤ R, C ≤ 500) which stands for number of rows and columns of the plane. That follows the plane, which contains R lines and C characters for each line, with 'O' (Oh) for target cell, 'X' for initial position of the box, '.' for a rigid cell, '#' for a empty cell and 'E' for a easily broken cell. A test cases starts with two zeros ends the input.\n\nIt guarantees that\n\n- There's only one 'O' in a plane.\n- There's either one 'X' or neighbouring two 'X's in a plane.\n- The first(and last) row(and column) must be '#'(empty cell).\n- Cells covered by 'O' and 'X' are all rigid cells.", "outputFormat": "For each test cases output one line with the minimum number of moves or \"Impossible\" (without quote) when there's no way to achieve the target cell. 　", "hint": "", "locale": "en"}, "zh-CN": {"title": "Bloxorz I", "background": "小汤姆喜欢玩游戏。有一天，他下载了一个叫做“Bloxorz”的小电脑游戏，让他非常兴奋。", "description": "这是一个关于将一个方块滚动到特定位置的游戏。准确地说，这个平面由几个单位单元格组成，是一个矩形形状的区域。而方块由两个完美对齐的单位立方体组成，可以躺下并占据两个相邻的单元格，也可以站立并占据一个单独的单元格。\n\n你可以通过选择方块在地面上的四条边之一，并围绕该边旋转 90 度来移动方块，每次旋转算作一步。有三种类型的单元格，刚性单元格、易碎单元格和空单元格。\n\n- 刚性单元格可以支撑方块的全部重量，因此可以是方块所占据的两个单元格中的任意一个，也可以是方块完全站立在上面的单元格。\n- 易碎单元格只能支撑方块重量的一半，因此不能是方块完全站立在上面的唯一单元格。\n- 空单元格无法支撑任何东西，因此方块不可能部分位于该单元格上。\n\n游戏的目标是以最少的步数将站立的方块滚动到平面上唯一的目标单元格。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0byqnwkj.png)\n\n方块站在单个单元格上。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q3gn2fd8.png)\n\n方块横躺在两个相邻的单元格上。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9vtkwepc.png)\n\n方块纵躺在两个相邻的单元格上。\n\n在小汤姆通过游戏的几个阶段后，他发现比他预期的要难得多。因此，他求助于你的帮助。", "inputFormat": "**输入包含多个测试案例。**\n\n每个测试案例都是游戏的一个阶段。它以两个整数 $R$ 和 $C$ 开头，表示平面的行数和列数。\n\n接下来是平面，其中包含 $R$ 行和每行的 $C$ 个字符，其中 `O` 表示目标单元格，`X` 表示方块的初始位置，`.` 表示刚性单元格，`#` 表示空单元格，`E` 表示易碎单元格。一个测试案例以两个 `0` 结束输入。\n\n输入保证：\n\n- 平面上只有一个 `O`。\n- 平面上要么有一个 `X`，要么有相邻的两个 `X`。\n- 第一行（和最后一行）（以及第一列和最后一列）必须是 `#`（空单元格）。\n- `O` 和 `X` 覆盖的单元格都是刚性单元格。", "outputFormat": "对于每个测试案例，输出一行表示移动的最小次数，或在无法达到目标单元格时输出 `Impossible`。", "hint": "### 数据范围\n\n对于所有的数据：$3 ≤ R，C ≤ 500$。\n\n### 翻译\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "locale": "zh-CN"}}}
{"pid": "P10486", "type": "P", "difficulty": 3, "samples": [["1\nbasic_info\n4 3\nname sid grade\nFusu 001 1\nMaxmilite 002 2\nExpect2004 003 2\n2\nselect name from basic_info where grade=1\nselect sid,name from basic_info where grade=2\n", "Fusu\n002 Maxmilite\n003 Expect2004\n"], ["2\nbasic_info\n4 3\nname sid grade\nFusu 001 1\nMaxmilite 002 2\nExpect2004 003 2\nGPA\n2 2\nsid GPA\n001 77.88\n1\nselect GPA from GPA where sid=001\n", "77.88\n"], ["2\nshow_corner\n3 2\nh1 h2\n1 2\n1 2\nshow_corner2\n3 1\nh0\n1\n1\n2\nselect h1,h2 from show_corner where h1=1\nselect h0 from show_corner2 where h0=1\n", "1 2\n1 2\n1\n1\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2024", "语言月赛"], "title": "[入门赛 #25] sql", "background": "sql 是一种强大的数据库查询语言。在本题中，你需要实现一个部分功能的 sql 解析器。", "description": "一个数据库可以看作若干张二维表的合集。\n\n例如，一个学生信息管理系统的数据库可能会有如下两张二维表：\n\n`basic_info`：\n\n| name | sid | grade| \n| :-: | :-: | :-: |\n| Fusu | 001 | 1 |\n| Maxmilite| 002 | 2|\n| Expect2004 | 003 | 2 |\n\n`GPA`:\n\n| sid | GPA |\n| :-: | :-: |\n| 001 | 77.88|\n| 002| 99.9 |\n| 003| 99.7 |\n\n上述表的第一行称作**表头**，接下来每一行表示表的一组信息。例如，`basic_info` 的第二行表示存在一名学生的姓名（`name`）是 $\\texttt{Fusu}$，学号 (`sid`) 为 $\\texttt{001}$，年级（`grade`）为 $\\texttt{1}$\n\n一个正式的 sql 语言应该支持跨表查询，但是在本题中，你只需要支持在单个表内的查询。我们认为表内的一切属性都以字符串的形式给出。\n\n你需要支持如下格式的查询语句：\n\n```sql\nselect [columns] from [table_name] where [header]=x\n```\n\n上式中，`columns` 是若干个**表头**，`table_name` 是**表名**，`header` 是**表头**，$x$ 是给出的条件。它表示在 `table_name` 这个表里查询 `header` 这一列为 $x$ 的所有行的所有 `columns` 列里的信息。\n\n例如，如果对上述例子里的表执行如下语句：\n\n```sql\nselect name from basic_info where grade=1\n```\n表示在 `basic_info` 表里查询 `grade` 列为 $1$ 的所有行，并输出它们的 `name` 列，因此结果为：\n\n```plain\nFusu\n```\n\n如果执行\n\n```sql\nselect name,sid,grade from basic_info where grade=2\n```\n\n那么就找到 `basic_info` 表里所有 `grade` 为 `2` 的行，并依次输出它们的 `name`、`sid`、`grade`。结果为：\n\n```plain\nMaxmilite 002 2\nExpect2004 003 2\n```\n\n可以看到，`select` 语句的第一组参数 `columns` 可以是多个表头名称，此时应该按照 `columns` 给出的顺序输出每个对应的列信息。通过 `where` 后面的条件可以查询到多行满足要求的行时，应按照表的输入顺序（即从上到下）输出每行要求的信息。\n\n你需要实现这个 sql 语句解析器，给出 sql 查询结果。注意，我们保证了在查询语句里表名只有一个，且 `where` 后面的条件有且仅有一个等式。", "inputFormat": "输入的第一行是一个整数 $n$，表示数据库中表的个数。\n\n接下来依次给出每张表的信息：  \n第一行是一个字符串 `table_name`，表示表的名称。  \n第二行有两个整数 $x,y$，表示这张表的大小为 $x$ 行 $y$ 列。\n第三行有 $y$ 个字符串，表示这张表的表头。\n接下来 $x - 1$ 行，每行 $y$ 个字符串，给出这张表上每一行的信息。\n\n接下来是一个整数 $m$，表示 sql 语句的数量。\n\n接下来 $m$ 行，每行一个 sql 语句，格式一定是\n\n```sql\nselect [columns] from [table_name] where [header]=x\n```\n\n保证 `columns`、`table_name`、`header`、`x` 这四个参数内部没有空格。\n\n数据保证查询语句合法，即 `columns`、`table_name`、`header` 这三个参数所提供的表头、表名都是存在的，且给出的查询条件一定能找到至少一行符合，即查询结果非空。\n\n保证 `columns` 里没有重复的表头名。", "outputFormat": "对于每个查询，输出若干行，依次表示查询结果。\n\n一行查询结果里，如果有若干个列的信息要输出，输出字符串之间用一个空格隔开。", "hint": "### 样例 3 解释\n\n输入的表单可能有若干行是重复的，你无需对这些行做特殊处理，可以认为它们是不同的。每次查询需要输出所有符合要求的行。例如，在第一条 sql 中，`1 2` 这一行出现了两次且符合要求，因此输出了两次 `1 2`。\n\n### 数据规模与约定\n\n| 测试点编号 | 表的数量为 $1$ | 表头数量为 1 |  columns 里仅有一列表头 | \n| :-: | :-: | :-: | :-:|\n| 1, 2 | $\\checkmark$ | $\\checkmark$ | $\\checkmark$ |\n| 3, 4 | $\\checkmark$ | $\\times$ | $\\checkmark$ |\n| 5, 6 | $\\times$ | $\\checkmark$ |$\\checkmark$ |\n| 7, 8 | $\\times$ | $\\times$ | $\\checkmark$ |\n|9, 10 | $\\times$ | $\\times$ | $\\times$ |\n\n对全部的测试数据，保证：\n\n- $1 \\leq n \\leq 10$。\n- $1 \\leq x\\leq 100$，$1 \\leq y \\leq 10$。\n- $1 \\leq m \\leq 1000$。\n- 表头 `table_name` 长度不超过 $100$。\n- 表的内容和表头的字符串长度不超过 $10$，`columns` 的长度不超过 $100$。\n- 除了 `columns` 信息以外，输入的字符串均不含有逗号 `,`。\n- 输入字符串均为可见字符，ASCII 范围为 $33\\sim 126$（含两端），且不含符号 `=`。\n\n### 提示\n\n请注意大量数据输出对程序效率造成的影响，选择合适的输出方式，避免超时。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[入门赛 #25] sql", "background": "sql 是一种强大的数据库查询语言。在本题中，你需要实现一个部分功能的 sql 解析器。", "description": "一个数据库可以看作若干张二维表的合集。\n\n例如，一个学生信息管理系统的数据库可能会有如下两张二维表：\n\n`basic_info`：\n\n| name | sid | grade| \n| :-: | :-: | :-: |\n| Fusu | 001 | 1 |\n| Maxmilite| 002 | 2|\n| Expect2004 | 003 | 2 |\n\n`GPA`:\n\n| sid | GPA |\n| :-: | :-: |\n| 001 | 77.88|\n| 002| 99.9 |\n| 003| 99.7 |\n\n上述表的第一行称作**表头**，接下来每一行表示表的一组信息。例如，`basic_info` 的第二行表示存在一名学生的姓名（`name`）是 $\\texttt{Fusu}$，学号 (`sid`) 为 $\\texttt{001}$，年级（`grade`）为 $\\texttt{1}$\n\n一个正式的 sql 语言应该支持跨表查询，但是在本题中，你只需要支持在单个表内的查询。我们认为表内的一切属性都以字符串的形式给出。\n\n你需要支持如下格式的查询语句：\n\n```sql\nselect [columns] from [table_name] where [header]=x\n```\n\n上式中，`columns` 是若干个**表头**，`table_name` 是**表名**，`header` 是**表头**，$x$ 是给出的条件。它表示在 `table_name` 这个表里查询 `header` 这一列为 $x$ 的所有行的所有 `columns` 列里的信息。\n\n例如，如果对上述例子里的表执行如下语句：\n\n```sql\nselect name from basic_info where grade=1\n```\n表示在 `basic_info` 表里查询 `grade` 列为 $1$ 的所有行，并输出它们的 `name` 列，因此结果为：\n\n```plain\nFusu\n```\n\n如果执行\n\n```sql\nselect name,sid,grade from basic_info where grade=2\n```\n\n那么就找到 `basic_info` 表里所有 `grade` 为 `2` 的行，并依次输出它们的 `name`、`sid`、`grade`。结果为：\n\n```plain\nMaxmilite 002 2\nExpect2004 003 2\n```\n\n可以看到，`select` 语句的第一组参数 `columns` 可以是多个表头名称，此时应该按照 `columns` 给出的顺序输出每个对应的列信息。通过 `where` 后面的条件可以查询到多行满足要求的行时，应按照表的输入顺序（即从上到下）输出每行要求的信息。\n\n你需要实现这个 sql 语句解析器，给出 sql 查询结果。注意，我们保证了在查询语句里表名只有一个，且 `where` 后面的条件有且仅有一个等式。", "inputFormat": "输入的第一行是一个整数 $n$，表示数据库中表的个数。\n\n接下来依次给出每张表的信息：  \n第一行是一个字符串 `table_name`，表示表的名称。  \n第二行有两个整数 $x,y$，表示这张表的大小为 $x$ 行 $y$ 列。\n第三行有 $y$ 个字符串，表示这张表的表头。\n接下来 $x - 1$ 行，每行 $y$ 个字符串，给出这张表上每一行的信息。\n\n接下来是一个整数 $m$，表示 sql 语句的数量。\n\n接下来 $m$ 行，每行一个 sql 语句，格式一定是\n\n```sql\nselect [columns] from [table_name] where [header]=x\n```\n\n保证 `columns`、`table_name`、`header`、`x` 这四个参数内部没有空格。\n\n数据保证查询语句合法，即 `columns`、`table_name`、`header` 这三个参数所提供的表头、表名都是存在的，且给出的查询条件一定能找到至少一行符合，即查询结果非空。\n\n保证 `columns` 里没有重复的表头名。", "outputFormat": "对于每个查询，输出若干行，依次表示查询结果。\n\n一行查询结果里，如果有若干个列的信息要输出，输出字符串之间用一个空格隔开。", "hint": "### 样例 3 解释\n\n输入的表单可能有若干行是重复的，你无需对这些行做特殊处理，可以认为它们是不同的。每次查询需要输出所有符合要求的行。例如，在第一条 sql 中，`1 2` 这一行出现了两次且符合要求，因此输出了两次 `1 2`。\n\n### 数据规模与约定\n\n| 测试点编号 | 表的数量为 $1$ | 表头数量为 1 |  columns 里仅有一列表头 | \n| :-: | :-: | :-: | :-:|\n| 1, 2 | $\\checkmark$ | $\\checkmark$ | $\\checkmark$ |\n| 3, 4 | $\\checkmark$ | $\\times$ | $\\checkmark$ |\n| 5, 6 | $\\times$ | $\\checkmark$ |$\\checkmark$ |\n| 7, 8 | $\\times$ | $\\times$ | $\\checkmark$ |\n|9, 10 | $\\times$ | $\\times$ | $\\times$ |\n\n对全部的测试数据，保证：\n\n- $1 \\leq n \\leq 10$。\n- $1 \\leq x\\leq 100$，$1 \\leq y \\leq 10$。\n- $1 \\leq m \\leq 1000$。\n- 表头 `table_name` 长度不超过 $100$。\n- 表的内容和表头的字符串长度不超过 $10$，`columns` 的长度不超过 $100$。\n- 除了 `columns` 信息以外，输入的字符串均不含有逗号 `,`。\n- 输入字符串均为可见字符，ASCII 范围为 $33\\sim 126$（含两端），且不含符号 `=`。\n\n### 提示\n\n请注意大量数据输出对程序效率造成的影响，选择合适的输出方式，避免超时。", "locale": "zh-CN"}}}
{"pid": "P10487", "type": "P", "difficulty": 4, "samples": [["3\n5 6\nXXXXXX\nXZ..ZX\nXXXXXX\nM.G...\n......\n5 6\nXXXXXX\nXZZ..X\nXXXXXX\nM.....\n..G...\n10 10\n..........\n..X.......\n..M.X...X.\nX.........\n.X..X.X.X.\n.........X\n..XX....X.\nX....G...X\n...ZX.X...\n...Z..X..X", "1\n1\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["广度优先搜索 BFS"], "title": "Nightmare II", "background": "", "description": "Last night, little erriyue had a horrible nightmare. He dreamed that he and his girl friend were trapped in a big maze separately. More terribly, there are two ghosts in the maze. They will kill the people. Now little erriyue wants to know if he could find his girl friend before the ghosts find them.\n\nYou may suppose that little erriyue and his girl friend can move in 4 directions. In each second, little erriyue can move 3 steps and his girl friend can move 1 step. The ghosts are evil, every second they will divide into several parts to occupy the grids within 2 steps to them until they occupy the whole maze. You can suppose that at every second the ghosts divide firstly then the little erriyue and his girl friend start to move, and if little erriyue or his girl friend arrive at a grid with a ghost, they will die.\nNote: the new ghosts also can devide as the original ghost.", "inputFormat": "The input starts with an integer T, means the number of test cases.\n\nEach test case starts with a line contains two integers n and m, means the size of the maze. (1<n, m<800)\n\nThe next n lines describe the maze. Each line contains m characters. The characters may be:\n- ‘.’ denotes an empty place, all can walk on.\n- ‘X’ denotes a wall, only people can’t walk on.\n- ‘M’ denotes little erriyue\n- ‘G’ denotes the girl friend.\n- ‘Z’ denotes the ghosts.\n\nIt is guaranteed that will contain exactly one letter M, one letter G and two letters Z.", "outputFormat": "Output a single integer S in one line, denotes erriyue and his girlfriend will meet in the minimum time S if they can meet successfully, or output -1 denotes they failed to meet.", "hint": "", "locale": "en", "translations": {"en": {"title": "Nightmare II", "background": "", "description": "Last night, little erriyue had a horrible nightmare. He dreamed that he and his girl friend were trapped in a big maze separately. More terribly, there are two ghosts in the maze. They will kill the people. Now little erriyue wants to know if he could find his girl friend before the ghosts find them.\n\nYou may suppose that little erriyue and his girl friend can move in 4 directions. In each second, little erriyue can move 3 steps and his girl friend can move 1 step. The ghosts are evil, every second they will divide into several parts to occupy the grids within 2 steps to them until they occupy the whole maze. You can suppose that at every second the ghosts divide firstly then the little erriyue and his girl friend start to move, and if little erriyue or his girl friend arrive at a grid with a ghost, they will die.\nNote: the new ghosts also can devide as the original ghost.", "inputFormat": "The input starts with an integer T, means the number of test cases.\n\nEach test case starts with a line contains two integers n and m, means the size of the maze. (1<n, m<800)\n\nThe next n lines describe the maze. Each line contains m characters. The characters may be:\n- ‘.’ denotes an empty place, all can walk on.\n- ‘X’ denotes a wall, only people can’t walk on.\n- ‘M’ denotes little erriyue\n- ‘G’ denotes the girl friend.\n- ‘Z’ denotes the ghosts.\n\nIt is guaranteed that will contain exactly one letter M, one letter G and two letters Z.", "outputFormat": "Output a single integer S in one line, denotes erriyue and his girlfriend will meet in the minimum time S if they can meet successfully, or output -1 denotes they failed to meet.", "hint": "", "locale": "en"}, "zh-CN": {"title": "Nightmare II", "background": null, "description": "昨晚，小 erriyue 做了一个可怕的噩梦。他梦到自己和女朋友被困在一个大迷宫里。更可怕的是，迷宫里有两个鬼魂。它们会杀人。现在小 erriyue 想知道在鬼魂找到他们之前，他是否能找到他的女朋友。\n\n假设小 erriyue 和他的女朋友可以向四个方向移动。在每一秒中，小 erriyue 可以移动 $3$ 步，而他的女朋友只能移动 $1$ 步。鬼魂是邪恶的，每一秒它们都会分裂成几部分，占领距离它们两步以内的网格，直到它们占领整个迷宫。你可以假设在每一秒钟，鬼魂首先分裂，然后小 erriyue 和他的女朋友开始移动，如果小 erriyue 或者他的女朋友到达一个有鬼魂的网格，他们就会死亡。\n\n注意：新的鬼魂也可以像原来的鬼魂一样分裂。", "inputFormat": "输入以一个整数 $T(1 \\le T \\le 3)$ 开始，表示测试案例的数量。\n\n每个测试案例以一行开头，包含两个整数 $n$ 和 $m$，表示迷宫的大小。$(1 < n, m < 800)$\n\n接下来的 $n$ 行描述了迷宫。每行包含 $m$ 个字符。字符可能是：\n- `.` 表示空地，所有人都可以走。\n- `X` 表示墙，只有人类无法行走。\n- `M` 表示小 erriyue。\n- `G` 表示女朋友。\n- `Z` 表示鬼魂。\n\n保证迷宫中恰好有一个字母 `M`、一个字母 `G` 和两个字母 `Z`。", "outputFormat": "在一行中输出一个整数 $S$，表示如果他们能成功相遇，小 erriyue 和他的女朋友将在最短时间 $S$ 内相遇，或者输出 $-1$ 表示他们未能相遇。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": null, "locale": "zh-CN"}}}
{"pid": "P10488", "type": "P", "difficulty": 4, "samples": [["3\n6\n1 3 4 6 2 5\n5\n5 4 3 2 1\n10\n6 8 5 3 4 7 2 9 1 10", "2\n3\n5 or more"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["搜索", "2006", "广度优先搜索 BFS", "启发式迭代加深搜索 IDA*", "ICPC"], "title": "[BAPC 2006 资格赛] Booksort", "background": null, "description": "给定 $n$ 本书，编号为 $1 \\sim n$。\n\n在初始状态下，书是任意排列的。\n\n在每一次操作中，可以抽取其中连续的一段，再把这段插入到其他某个位置。\n\n我们的目标状态是把书按照 $1 \\sim n$ 的顺序依次排列。\n\n求最少需要多少次操作。", "inputFormat": "第一行包含整数 $T$，表示共有 $T$ 组测试数据。\n\n每组数据包含两行，第一行为整数 $n$，表示书的数量。\n\n第二行为 $n$ 个整数，表示 $1 \\sim n$ 的一种任意排列。\n\n同行数之间用空格隔开。", "outputFormat": "每组数据输出一个最少操作次数。\n\n如果最少操作次数大于或等于 $5$ 次，则输出 `5 or more`。\n\n每个结果占一行。", "hint": "$1 \\le n \\le 15$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BAPC 2006 资格赛] Booksort", "background": null, "description": "给定 $n$ 本书，编号为 $1 \\sim n$。\n\n在初始状态下，书是任意排列的。\n\n在每一次操作中，可以抽取其中连续的一段，再把这段插入到其他某个位置。\n\n我们的目标状态是把书按照 $1 \\sim n$ 的顺序依次排列。\n\n求最少需要多少次操作。", "inputFormat": "第一行包含整数 $T$，表示共有 $T$ 组测试数据。\n\n每组数据包含两行，第一行为整数 $n$，表示书的数量。\n\n第二行为 $n$ 个整数，表示 $1 \\sim n$ 的一种任意排列。\n\n同行数之间用空格隔开。", "outputFormat": "每组数据输出一个最少操作次数。\n\n如果最少操作次数大于或等于 $5$ 次，则输出 `5 or more`。\n\n每个结果占一行。", "hint": "$1 \\le n \\le 15$。", "locale": "zh-CN"}}}
{"pid": "P10489", "type": "P", "difficulty": 4, "samples": [["17\n0 3 5 13 13 15 21 26 27 29 37 39 39 45 51 52 53", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["IOI", "O2优化", "深度优先搜索 DFS", "剪枝", "迭代加深搜索"], "title": "[IOI 1994] The Buses", "background": "0x29 搜索 总结与练习", "description": "A man arrives at a bus stop at 12:00. He remains there during 12:00-12:59. The bus stop is used by a number of bus routes. The man notes the times of arriving buses. The times when buses arrive are given.\n\n-  Buses on the same route arrive at regular intervals from 12:00 to 12:59 throughout the entire hour.\n- Times are given in whole minutes from 0 to 59.\n- Each bus route stops at least 2 times.\n- The number of bus routes in the test examples will be <=17.\n- Buses from different routes may arrive at the same time.\n- Several bus routes can have the same time of first arrival and/or time interval. If two bus routes have the same starting time and interval, they are distinct and are both to be presented.\n\nFind the schedule with the fewest number of bus routes that must stop at the bus stop to satisfy the input data. For each bus route, output the starting time and the interval.\n", "inputFormat": "Your program is to read from standard input. The input contains a number n (n <= 300) telling how many arriving buses have been noted, followed by the arrival times in ascending order.", "outputFormat": "Your program is to write to standard output. The output contains one integer, which is the fewest number of bus routes.", "hint": "", "locale": "en", "translations": {"en": {"title": "[IOI 1994] The Buses", "background": "0x29 搜索 总结与练习", "description": "A man arrives at a bus stop at 12:00. He remains there during 12:00-12:59. The bus stop is used by a number of bus routes. The man notes the times of arriving buses. The times when buses arrive are given.\n\n-  Buses on the same route arrive at regular intervals from 12:00 to 12:59 throughout the entire hour.\n- Times are given in whole minutes from 0 to 59.\n- Each bus route stops at least 2 times.\n- The number of bus routes in the test examples will be <=17.\n- Buses from different routes may arrive at the same time.\n- Several bus routes can have the same time of first arrival and/or time interval. If two bus routes have the same starting time and interval, they are distinct and are both to be presented.\n\nFind the schedule with the fewest number of bus routes that must stop at the bus stop to satisfy the input data. For each bus route, output the starting time and the interval.\n", "inputFormat": "Your program is to read from standard input. The input contains a number n (n <= 300) telling how many arriving buses have been noted, followed by the arrival times in ascending order.", "outputFormat": "Your program is to write to standard output. The output contains one integer, which is the fewest number of bus routes.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[IOI 1994] The Buses", "background": "", "description": "一个人在 12:00 到达一个公交车站。他在 12:00 到 12:59 期间一直待在那里。这个公交车站被多条公交线路使用。这个人记录了公交车到达的时间。给出了公交车到达的时间。\n\n- 同一条路线的公交车在整个小时内从 12:00 到 12:59 以固定的时间间隔到达。\n- 时间以整分钟给出，从 0 到 59。\n- 每条公交线路至少停靠 2 次。\n- 测试示例中的公交线路数量将 $\\leq 17$。\n- 不同路线的公交车可能同时到达。\n- 几条公交线路的首次到达时间和/或时间间隔可能相同。如果两条公交线路的起始时间和间隔相同，则它们是不同的，并且都需要呈现。\n\n找出满足输入数据的必须停靠在公交车站的公交线路数量最少的时间表。对于每条公交线路，输出起始时间和间隔。", "inputFormat": "你的程序需要从标准输入中读取。输入包含一个数字 $n$（$n \\leq 300$），表示已经记录的到达公交车的数量，后跟按升序排列的到达时间。", "outputFormat": "你的程序需要写入标准输出。输出包含一个整数，即最少的公交线路数量。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10490", "type": "P", "difficulty": 3, "samples": [["5 \n3 5 2 4 1 \n0", "2"]], "limits": {"time": [2000], "memory": [524288]}, "tags": ["搜索", "O2优化", "深度优先搜索 DFS", "剪枝"], "title": "Missile Defence System", "background": "", "description": "To play against the threats of malicious countries nearby, Country R has updated their missile defence system. The new type system can bring down a series of missiles as long as they are coming in ascending order by altitude or descending order by altitude.\n\nGiven the heights of a sequence of coming missiles, the general wants to know how many sets of the new type systems are needed to bring down all of them.", "inputFormat": "The input consists of several test cases. The first line of each test case contains an integer $n (1 \\le n \\le 50)$. The next line contains n different integers indicating the heights.", "outputFormat": "For each test case output a single line containing the number of systems needed.For each test case output a single line containing the number of systems needed.", "hint": "Two sets of systems are needed for the sample. One brings down 3, 4 and the other brings down 5, 2, 1.", "locale": "en", "translations": {"en": {"title": "Missile Defence System", "background": "", "description": "To play against the threats of malicious countries nearby, Country R has updated their missile defence system. The new type system can bring down a series of missiles as long as they are coming in ascending order by altitude or descending order by altitude.\n\nGiven the heights of a sequence of coming missiles, the general wants to know how many sets of the new type systems are needed to bring down all of them.", "inputFormat": "The input consists of several test cases. The first line of each test case contains an integer $n (1 \\le n \\le 50)$. The next line contains n different integers indicating the heights.", "outputFormat": "For each test case output a single line containing the number of systems needed.For each test case output a single line containing the number of systems needed.", "hint": "Two sets of systems are needed for the sample. One brings down 3, 4 and the other brings down 5, 2, 1.", "locale": "en"}, "zh-CN": {"title": "Missile Defence System", "background": "", "description": "为了对抗附近恶意国家的威胁，R 国更新了他们的导弹防御系统。\n\n一套防御系统的导弹拦截高度要么一直严格单调上升要么一直严格单调下降。\n\n例如，一套系统先后拦截了高度为 $3$ 和高度为 $4$ 的两发导弹，那么接下来该系统就只能拦截高度大于 $4$ 的导弹。\n\n给定即将袭来的一系列导弹的高度，请你求出至少需要多少套防御系统，就可以将它们全部击落。", "inputFormat": "输入包含多组测试用例。\n\n对于每个测试用例，第一行包含整数 $n$，表示来袭导弹数量。\n\n第二行包含 $n$ 个不同的整数，表示每个导弹的高度。\n\n当输入测试用例 $n=0$ 时，表示输入终止，且该用例无需处理。", "outputFormat": "对于每个测试用例，输出一行，一个整数，表示所需的防御系统数量。", "hint": "#### 样例解释\n对于样例，需要两套系统。一套击落 $3,4$ 号导弹，另一套击落 $5,2,1$ 号导弹。\n\n#### 数据规模与约定\n$1 \\leq n \\leq 50$。", "locale": "zh-CN"}}}
{"pid": "P10491", "type": "P", "difficulty": 2, "samples": [["10 11\n..........\n....*.....\n..........\n...*.*....\n.......*..\n..*..*...H\n*.........\n...*...*..\n.K........\n...*.....*\n..*....*..", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2009", "USACO", "O2优化", "广度优先搜索 BFS"], "title": "[USACO09NOV] The Chivalrous Cow B", "background": "农民 John 有很多牛，他想交易其中一头被 Don 称为 The Knight 的牛。这头牛有一个独一无二的超能力，在农场里像 Knight 一样地跳（就是我们熟悉的象棋中马的走法）。虽然这头神奇的牛不能跳到树上和石头上，但是它可以在牧场上随意跳，我们把牧场用一个 $x,y$ 的坐标图来表示。", "description": "这头神奇的牛像其它牛一样喜欢吃草，给你一张地图，上面标注了 The Knight 的开始位置，树、灌木、石头以及其它障碍的位置，除此之外还有一捆草。现在你的任务是，确定 The Knight 要想吃到草，至少需要跳多少次。The Knight 的位置用 `K` 来标记，障碍的位置用 `*` 来标记，草的位置用 `H` 来标记。\n\n这里有一个地图的例子：\n```\n             11 | . . . . . . . . . .\n             10 | . . . . * . . . . . \n              9 | . . . . . . . . . . \n              8 | . . . * . * . . . . \n              7 | . . . . . . . * . . \n              6 | . . * . . * . . . H \n              5 | * . . . . . . . . . \n              4 | . . . * . . . * . . \n              3 | . K . . . . . . . . \n              2 | . . . * . . . . . * \n              1 | . . * . . . . * . . \n              0 ----------------------\n                                    1 \n                0 1 2 3 4 5 6 7 8 9 0 \n```\nThe Knight 可以按照下图中的 $A,B,C,D\\dots$ 这条路径用 $5$ 次跳到草的地方（有可能其它路线的长度也是 $5$）：\n```\n             11 | . . . . . . . . . .\n             10 | . . . . * . . . . .\n              9 | . . . . . . . . . .\n              8 | . . . * . * . . . .\n              7 | . . . . . . . * . .\n              6 | . . * . . * . . . F<\n              5 | * . B . . . . . . .\n              4 | . . . * C . . * E .\n              3 | .>A . . . . D . . .\n              2 | . . . * . . . . . *\n              1 | . . * . . . . * . .\n              0 ----------------------\n                                    1\n                0 1 2 3 4 5 6 7 8 9 0\n                ```", "inputFormat": "第一行：两个数，表示农场的列数（$\\le 150$）和行数 （$\\le 150$）。\n\n第二行：结尾：如题目描述的图。", "outputFormat": "一个数，表示跳跃的最小次数。", "hint": "Hint：这类问题可以用一个简单的先进先出表（队列）来解决。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO09NOV] The Chivalrous Cow B", "background": "农民 John 有很多牛，他想交易其中一头被 Don 称为 The Knight 的牛。这头牛有一个独一无二的超能力，在农场里像 Knight 一样地跳（就是我们熟悉的象棋中马的走法）。虽然这头神奇的牛不能跳到树上和石头上，但是它可以在牧场上随意跳，我们把牧场用一个 $x,y$ 的坐标图来表示。", "description": "这头神奇的牛像其它牛一样喜欢吃草，给你一张地图，上面标注了 The Knight 的开始位置，树、灌木、石头以及其它障碍的位置，除此之外还有一捆草。现在你的任务是，确定 The Knight 要想吃到草，至少需要跳多少次。The Knight 的位置用 `K` 来标记，障碍的位置用 `*` 来标记，草的位置用 `H` 来标记。\n\n这里有一个地图的例子：\n```\n             11 | . . . . . . . . . .\n             10 | . . . . * . . . . . \n              9 | . . . . . . . . . . \n              8 | . . . * . * . . . . \n              7 | . . . . . . . * . . \n              6 | . . * . . * . . . H \n              5 | * . . . . . . . . . \n              4 | . . . * . . . * . . \n              3 | . K . . . . . . . . \n              2 | . . . * . . . . . * \n              1 | . . * . . . . * . . \n              0 ----------------------\n                                    1 \n                0 1 2 3 4 5 6 7 8 9 0 \n```\nThe Knight 可以按照下图中的 $A,B,C,D\\dots$ 这条路径用 $5$ 次跳到草的地方（有可能其它路线的长度也是 $5$）：\n```\n             11 | . . . . . . . . . .\n             10 | . . . . * . . . . .\n              9 | . . . . . . . . . .\n              8 | . . . * . * . . . .\n              7 | . . . . . . . * . .\n              6 | . . * . . * . . . F<\n              5 | * . B . . . . . . .\n              4 | . . . * C . . * E .\n              3 | .>A . . . . D . . .\n              2 | . . . * . . . . . *\n              1 | . . * . . . . * . .\n              0 ----------------------\n                                    1\n                0 1 2 3 4 5 6 7 8 9 0\n                ```", "inputFormat": "第一行：两个数，表示农场的列数（$\\le 150$）和行数 （$\\le 150$）。\n\n第二行：结尾：如题目描述的图。", "outputFormat": "一个数，表示跳跃的最小次数。", "hint": "Hint：这类问题可以用一个简单的先进先出表（队列）来解决。", "locale": "zh-CN"}}}
