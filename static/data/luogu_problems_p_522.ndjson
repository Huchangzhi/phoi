{"pid": "P11588", "type": "P", "difficulty": 6, "samples": [["6\n-1 2 -3 3 -1 2\n", "6"], ["8\n-1 6 -3 -6 1 -1 3 6\n", "21\n"], ["15\n-7 -1 4 -1 2 6 -3 4 7 -5 6 -2 6 5 7\n", "1116\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "交互题", "KOI（韩国）"], "title": "[KTSC 2022 R2] 彩色括号序列", "background": "\n  \n**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <vector>\n\nint count(std::vector<int> P);\n```\n\n题目译自 [2022년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2022/) T2「 [알록달록한 괄호열](https://assets.ioikorea.kr/ioitst/2022/2/colorful/colorful_statement.pdf)」\n\n", "description": "括号序列是由两种字符 `(` 和 `)` 组成的字符串。好的括号序列可以通过以下规则构成：\n\n- 空字符串是好的括号序列。\n- 如果 $S$ 是好的括号序列，那么 $(S)$ 也是好的括号序列。在这种情况下，$S$ 两端的括号是配对的。\n- 如果 $S$ 和 $T$ 都是好的括号序列，那么 $ST$ 也是好的括号序列。\n\n彩色括号序列是指每个括号都被涂上特定颜色的括号序列。五彩缤纷的括号序列需要满足以下所有条件：\n\n- 忽略颜色，仅看括号的形式时是好的括号序列。\n- 所有相邻的两个括号颜色不同。\n- 所有配对的两个括号颜色不同。\n\n当从字符串 $S$ 中选出一个或多个字符按顺序排列成 $T$ 时，称可以从 $S$ 中选出 $T$。给定一个彩色括号序列，问可以从中选出多少个五彩缤纷的括号序列？即使括号形式相同，但只要颜色不同就算作不同情况；即使选取方式不同，但结果相同也只算作一种情况。\n\n你需要实现以下函数：\n\n`int count(vector<int> P)`\n\n- 该函数只会被调用一次。\n- `P`：表示彩色括号序列，$P[i]$ 表示第 $i$ 个括号的信息。$P[i] < 0$ 表示左括号，$P[i] > 0$ 表示右括号，$|P[i]|$ 的值表示颜色。\n- 该函数需要返回从给定彩色括号序列中可以选出的五彩缤纷括号序列的数量，并对 $1000000007$ 取模。\n\n注意，提交的代码中不应包含任何输入输出操作。", "inputFormat": "示例评测程序的输入格式如下：\n\n- 第 $1$ 行：$N$\n- 第 $2$ 行：$P[0]\\,P[1]\\,\\cdots\\,P[N-1]$", "outputFormat": "示例评测程序的输出格式如下：\n\n- 第 $1$ 行：`count` 函数返回的值。", "hint": "### 样例解释 #1\n用颜色 c 涂的括号 p 表示为 p。给定彩色括号序列 $\\underset{123312}{()()()}$，评测程序会调用如下函数：\n`count({-1,2,-3,3,-1,2})`\n\n可以选出的五彩缤纷括号序列有 $\\underset{12}{()},\\underset{13}{()},\\underset{32}{()},\\underset{1212}{()()},\\underset{1232}{()()},\\underset{1312}{()()}$ 共 $6$ 种。因此，调用的 `count` 函数应返回 $6$。\n\n从中选取特定字符串的方法有多种，在这个样例中，选取  \n $\\underset{12}{()}$ 的方法有 $3$ 种。\n \n### 样例解释 #2\n给定彩色括号序列 $(()())$，评测程序会调用如下函数：\n\n`count({1,6,-3,-6,1,-1,3,6})`\n\n可以选出的五彩缤纷括号序列有 $\\underset{13}{()},\\underset{16}{()},\\underset{31}{()},\\underset{36}{()},\\underset{61}{()},\\underset{63}{()},\\underset{1313}{(())},\\underset{1316}{(())},\\underset{1613}{(())},\\underset{1616}{(())},\\underset{1636}{(())},\\underset{3136}{(())},\\underset{3616}{(())},\\underset{3636}{(())},\\underset{1613}{()()},\\underset{1616}{()()},\\underset{1631}{()()},\\underset{1636}{()()},\\underset{163136}{()(())},\\underset{163616}{()(())},\\underset{163636}{()(())}$ 共 $21$ 种。因此，调用的 `count` 函数应返回 $21$。\n\n$\\underset{1336}{(())}$ 和 $\\underset{6136}{(())}$ 虽然括号序列是好的，但由于相邻两个括号颜色相同或配对括号颜色相同，因此不是五彩缤纷的括号序列。\n\n### 样例解释 #3\n给定彩色括号序列 $\\underset{714126347562657}{(()())())()()))}$，评测程序会调用如下函数：\n\n`count({-7,-1,4,-1,2,6,-3,4,7,-5,6,-2,6,5,7})`\n\n调用的 `count` 函数应返回 $1116$。\n\n### 数据范围\n对于所有输入数据，满足：\n\n- 用 $N$ 表示 $P$ 的长度，$1 \\leq N \\leq 700$\n- 对于所有 $i (0 \\leq i \\leq N-1)$，$1 \\leq |P[i]| \\leq N$\n\n详细子任务附加限制及分值如下表所示。\n\n| Subtask | 分值 | 约束 |\n| :----------: | :----------: | :----------: |\n|$1$|$5$|$N \\leq 20$|\n|$2$|$30$|$N \\leq 200$|\n|$3$|$27$|$N \\leq 500$。对于所有 $i (0 \\leq i \\leq N-1)$，$\\lvert P[i]\\rvert \\leq 20$|\n|$4$|$14$|对于所有 $i (0 \\leq i \\leq N-1)$，$\\lvert P[i]\\rvert \\leq 2$|\n|$5$|$24$|无附加限制|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KTSC 2022 R2] 彩色括号序列", "background": "\n  \n**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <vector>\n\nint count(std::vector<int> P);\n```\n\n题目译自 [2022년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2022/) T2「 [알록달록한 괄호열](https://assets.ioikorea.kr/ioitst/2022/2/colorful/colorful_statement.pdf)」\n\n", "description": "括号序列是由两种字符 `(` 和 `)` 组成的字符串。好的括号序列可以通过以下规则构成：\n\n- 空字符串是好的括号序列。\n- 如果 $S$ 是好的括号序列，那么 $(S)$ 也是好的括号序列。在这种情况下，$S$ 两端的括号是配对的。\n- 如果 $S$ 和 $T$ 都是好的括号序列，那么 $ST$ 也是好的括号序列。\n\n彩色括号序列是指每个括号都被涂上特定颜色的括号序列。五彩缤纷的括号序列需要满足以下所有条件：\n\n- 忽略颜色，仅看括号的形式时是好的括号序列。\n- 所有相邻的两个括号颜色不同。\n- 所有配对的两个括号颜色不同。\n\n当从字符串 $S$ 中选出一个或多个字符按顺序排列成 $T$ 时，称可以从 $S$ 中选出 $T$。给定一个彩色括号序列，问可以从中选出多少个五彩缤纷的括号序列？即使括号形式相同，但只要颜色不同就算作不同情况；即使选取方式不同，但结果相同也只算作一种情况。\n\n你需要实现以下函数：\n\n`int count(vector<int> P)`\n\n- 该函数只会被调用一次。\n- `P`：表示彩色括号序列，$P[i]$ 表示第 $i$ 个括号的信息。$P[i] < 0$ 表示左括号，$P[i] > 0$ 表示右括号，$|P[i]|$ 的值表示颜色。\n- 该函数需要返回从给定彩色括号序列中可以选出的五彩缤纷括号序列的数量，并对 $1000000007$ 取模。\n\n注意，提交的代码中不应包含任何输入输出操作。", "inputFormat": "示例评测程序的输入格式如下：\n\n- 第 $1$ 行：$N$\n- 第 $2$ 行：$P[0]\\,P[1]\\,\\cdots\\,P[N-1]$", "outputFormat": "示例评测程序的输出格式如下：\n\n- 第 $1$ 行：`count` 函数返回的值。", "hint": "### 样例解释 #1\n用颜色 c 涂的括号 p 表示为 p。给定彩色括号序列 $\\underset{123312}{()()()}$，评测程序会调用如下函数：\n`count({-1,2,-3,3,-1,2})`\n\n可以选出的五彩缤纷括号序列有 $\\underset{12}{()},\\underset{13}{()},\\underset{32}{()},\\underset{1212}{()()},\\underset{1232}{()()},\\underset{1312}{()()}$ 共 $6$ 种。因此，调用的 `count` 函数应返回 $6$。\n\n从中选取特定字符串的方法有多种，在这个样例中，选取  \n $\\underset{12}{()}$ 的方法有 $3$ 种。\n \n### 样例解释 #2\n给定彩色括号序列 $(()())$，评测程序会调用如下函数：\n\n`count({1,6,-3,-6,1,-1,3,6})`\n\n可以选出的五彩缤纷括号序列有 $\\underset{13}{()},\\underset{16}{()},\\underset{31}{()},\\underset{36}{()},\\underset{61}{()},\\underset{63}{()},\\underset{1313}{(())},\\underset{1316}{(())},\\underset{1613}{(())},\\underset{1616}{(())},\\underset{1636}{(())},\\underset{3136}{(())},\\underset{3616}{(())},\\underset{3636}{(())},\\underset{1613}{()()},\\underset{1616}{()()},\\underset{1631}{()()},\\underset{1636}{()()},\\underset{163136}{()(())},\\underset{163616}{()(())},\\underset{163636}{()(())}$ 共 $21$ 种。因此，调用的 `count` 函数应返回 $21$。\n\n$\\underset{1336}{(())}$ 和 $\\underset{6136}{(())}$ 虽然括号序列是好的，但由于相邻两个括号颜色相同或配对括号颜色相同，因此不是五彩缤纷的括号序列。\n\n### 样例解释 #3\n给定彩色括号序列 $\\underset{714126347562657}{(()())())()()))}$，评测程序会调用如下函数：\n\n`count({-7,-1,4,-1,2,6,-3,4,7,-5,6,-2,6,5,7})`\n\n调用的 `count` 函数应返回 $1116$。\n\n### 数据范围\n对于所有输入数据，满足：\n\n- 用 $N$ 表示 $P$ 的长度，$1 \\leq N \\leq 700$\n- 对于所有 $i (0 \\leq i \\leq N-1)$，$1 \\leq |P[i]| \\leq N$\n\n详细子任务附加限制及分值如下表所示。\n\n| Subtask | 分值 | 约束 |\n| :----------: | :----------: | :----------: |\n|$1$|$5$|$N \\leq 20$|\n|$2$|$30$|$N \\leq 200$|\n|$3$|$27$|$N \\leq 500$。对于所有 $i (0 \\leq i \\leq N-1)$，$\\lvert P[i]\\rvert \\leq 20$|\n|$4$|$14$|对于所有 $i (0 \\leq i \\leq N-1)$，$\\lvert P[i]\\rvert \\leq 2$|\n|$5$|$24$|无附加限制|", "locale": "zh-CN"}}}
{"pid": "P11589", "type": "P", "difficulty": 5, "samples": [["3 2\n1 2\n3 1\n", "0\n4\n8\n"], ["13 2\n1 2\n3 1\n", "0\n4\n8\n11\n13\n17\n18\n20\n24\n25\n27\n29\n30\n"], ["12 3\n5 1\n3 4\n0 6\n", "0\n6\n7\n12\n13\n16\n17\n18\n19\n20\n22\n23\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "交互题", "KOI（韩国）"], "title": "[KTSC 2022 R2] 寻找魔法珠", "background": "**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <vector>\n\nint count(std::vector<int> P);\n```\n\n题目译自 [2022년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2022/) T2「 [마법 구슬 찾기](https://assets.ioikorea.kr/ioitst/2022/2/marbles/marbles_statement.pdf)」\n\n", "description": "你有 $k+1$ 颗外观和质量完全相同的珠子，其中 $k$ 颗是普通珠子，$1$ 颗是魔法珠子。你需要找到这颗魔法珠子，才能进入魔法城堡。\n\n虽然无法通过肉眼区分魔法珠子和普通珠子，但你可以使用 $M (M \\geq 2)$ 个袋子来找到魔法珠子。袋子编号从 $0$ 到 $M-1$。\n\n找到魔法珠子的步骤如下：\n\n1. 将所有珠子分装到 $M$ 个袋子中。\n   - 每个袋子里必须有珠子，不能有空袋子。\n   - 袋子里只能装珠子，不能装其他袋子。\n2. 念咒语。\n3. 念咒语后：\n   - 不含魔法珠子的袋子里的珠子会全部消失。\n   - 含有魔法珠子的袋子里的珠子会因为魔法珠子的保护而不消失，但需要支付费用。若魔法珠子在第 $i$ 个袋子中，且该袋子里有 $j$ 颗珠子，则费用为 $A[i] \\times j + B[i] (A[i] \\geq 0, B[i] \\geq 1)$ 元。\n   \n魔法珠子永远不会消失，因此你可以重复上述步骤，直到只剩下魔法珠子。\n\n你需要制定一个策略，将珠子分装到袋子中，以最小化在最坏情况下找到魔法珠子的费用。也就是说，无论哪颗珠子是魔法珠子，总费用不超过 $w$ 元，找出最小的 $w$。\n\n请编写一个函数，解决 $0$ 到 $N-1$ 的所有 $k$ 的问题。\n\n你需要实现以下函数：\n\n`vector<long long> find_minimum_costs(int N, vector<int> A, vector<int> B);`\n\n- `N`：珠子的最大数量\n- `A, B`：长度为 $M$ 的数组。对于每个 $i (0 \\leq i \\leq M-1)$，若魔法珠子在第 $i$ 个袋子中，且该袋子里有 $j$ 颗珠子，则费用为 $A[i] \\times j + B[i]$ 元。\n- 该函数返回一个长度为 $N$ 的数组 $C$。对于每个 $k (0 \\leq k \\leq N-1)$，$C[k]$ 是在有 $k$ 颗普通珠子和 $1$ 颗魔法珠子的情况下，找到魔法珠子的最坏情况下的最小费用（单位：元）。\n\n注意，提交的代码中不应包含任何输入输出操作。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N\\,M$\n- 第 $2+i (0 \\leq i \\leq M-1)$ 行：$A[i]\\,B[i]$\n", "outputFormat": "示例评测程序的输出格式如下：\n\n- 第 $1+k (0 \\leq k \\leq N-1)$ 行：$C[k]$", "hint": "### 样例解释 #1\n考虑 $N=3, M=2, A=[1,3], B=[2,1]$ 的情况。\n\n评测程序将调用如下函数：\n\n`find_minimum_costs(3, {1,3}, {2,1});`\n\n当 $k=0$ 时，只有一颗珠子，即魔法珠子，因此费用为 $0$ 元。\n\n当 $k=1$ 时，可以将两颗珠子分别放入两个袋子。若魔法珠子在第 $0$ 个袋子中，费用为 $A[0] \\times 1 + B[0] = 1 \\times 1 + 2 = 3$ 元；若魔法珠子在第 $1$ 个袋子中，费用为 $A[1] \\times 1 + B[1] = 3 \\times 1 + 1 = 4$ 元。因此，最坏情况下费用为 $4$ 元。\n\n当 $k=2$ 时，可以采用以下策略。假设三颗珠子分别为 $X, Y, Z$。\n\n- 将 $X$ 和 $Z$ 放入第 $0$ 个袋子，将 $Y$ 放入第 $1$ 个袋子，然后念咒语。\n- 若魔法珠子在第 $0$ 个袋子中，费用为 $A[0] \\times 2 + B[0] = 1 \\times 2 + 2 = 4$ 元，剩下 $X$ 和 $Z$。然后将 $Z$ 放入第 $0$ 个袋子，将 $X$ 放入第 $1$ 个袋子，再次念咒语。\n   - 若魔法珠子在第 $0$ 个袋子中，费用为 $A[0] \\times 1 + B[0] = 1 \\times 1 + 2 = 3$ 元，剩下 $Z$。\n   - 若魔法珠子在第 $1$ 个袋子中，费用为 $A[1] \\times 1 + B[1] = 3 \\times 1 + 1 = 4$ 元，剩下 $X$。\n- 若魔法珠子在第 $1$ 个袋子中，费用为 $A[1] \\times 1 + B[1] = 3 \\times 1 + 1 = 4$ 元，剩下 $Y$。\n\n在这种策略下，若 $X$ 是魔法珠子，总费用为 $4 + 4 = 8$ 元；若 $Y$ 是魔法珠子，总费用为 $4$ 元；若 $Z$ 是魔法珠子，总费用为 $4 + 3 = 7$ 元。因此，最坏情况下费用为 $8$ 元。\n\n函数应返回 `[0,4,8]`。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KTSC 2022 R2] 寻找魔法珠", "background": "**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <vector>\n\nint count(std::vector<int> P);\n```\n\n题目译自 [2022년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2022/) T2「 [마법 구슬 찾기](https://assets.ioikorea.kr/ioitst/2022/2/marbles/marbles_statement.pdf)」\n\n", "description": "你有 $k+1$ 颗外观和质量完全相同的珠子，其中 $k$ 颗是普通珠子，$1$ 颗是魔法珠子。你需要找到这颗魔法珠子，才能进入魔法城堡。\n\n虽然无法通过肉眼区分魔法珠子和普通珠子，但你可以使用 $M (M \\geq 2)$ 个袋子来找到魔法珠子。袋子编号从 $0$ 到 $M-1$。\n\n找到魔法珠子的步骤如下：\n\n1. 将所有珠子分装到 $M$ 个袋子中。\n   - 每个袋子里必须有珠子，不能有空袋子。\n   - 袋子里只能装珠子，不能装其他袋子。\n2. 念咒语。\n3. 念咒语后：\n   - 不含魔法珠子的袋子里的珠子会全部消失。\n   - 含有魔法珠子的袋子里的珠子会因为魔法珠子的保护而不消失，但需要支付费用。若魔法珠子在第 $i$ 个袋子中，且该袋子里有 $j$ 颗珠子，则费用为 $A[i] \\times j + B[i] (A[i] \\geq 0, B[i] \\geq 1)$ 元。\n   \n魔法珠子永远不会消失，因此你可以重复上述步骤，直到只剩下魔法珠子。\n\n你需要制定一个策略，将珠子分装到袋子中，以最小化在最坏情况下找到魔法珠子的费用。也就是说，无论哪颗珠子是魔法珠子，总费用不超过 $w$ 元，找出最小的 $w$。\n\n请编写一个函数，解决 $0$ 到 $N-1$ 的所有 $k$ 的问题。\n\n你需要实现以下函数：\n\n`vector<long long> find_minimum_costs(int N, vector<int> A, vector<int> B);`\n\n- `N`：珠子的最大数量\n- `A, B`：长度为 $M$ 的数组。对于每个 $i (0 \\leq i \\leq M-1)$，若魔法珠子在第 $i$ 个袋子中，且该袋子里有 $j$ 颗珠子，则费用为 $A[i] \\times j + B[i]$ 元。\n- 该函数返回一个长度为 $N$ 的数组 $C$。对于每个 $k (0 \\leq k \\leq N-1)$，$C[k]$ 是在有 $k$ 颗普通珠子和 $1$ 颗魔法珠子的情况下，找到魔法珠子的最坏情况下的最小费用（单位：元）。\n\n注意，提交的代码中不应包含任何输入输出操作。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N\\,M$\n- 第 $2+i (0 \\leq i \\leq M-1)$ 行：$A[i]\\,B[i]$\n", "outputFormat": "示例评测程序的输出格式如下：\n\n- 第 $1+k (0 \\leq k \\leq N-1)$ 行：$C[k]$", "hint": "### 样例解释 #1\n考虑 $N=3, M=2, A=[1,3], B=[2,1]$ 的情况。\n\n评测程序将调用如下函数：\n\n`find_minimum_costs(3, {1,3}, {2,1});`\n\n当 $k=0$ 时，只有一颗珠子，即魔法珠子，因此费用为 $0$ 元。\n\n当 $k=1$ 时，可以将两颗珠子分别放入两个袋子。若魔法珠子在第 $0$ 个袋子中，费用为 $A[0] \\times 1 + B[0] = 1 \\times 1 + 2 = 3$ 元；若魔法珠子在第 $1$ 个袋子中，费用为 $A[1] \\times 1 + B[1] = 3 \\times 1 + 1 = 4$ 元。因此，最坏情况下费用为 $4$ 元。\n\n当 $k=2$ 时，可以采用以下策略。假设三颗珠子分别为 $X, Y, Z$。\n\n- 将 $X$ 和 $Z$ 放入第 $0$ 个袋子，将 $Y$ 放入第 $1$ 个袋子，然后念咒语。\n- 若魔法珠子在第 $0$ 个袋子中，费用为 $A[0] \\times 2 + B[0] = 1 \\times 2 + 2 = 4$ 元，剩下 $X$ 和 $Z$。然后将 $Z$ 放入第 $0$ 个袋子，将 $X$ 放入第 $1$ 个袋子，再次念咒语。\n   - 若魔法珠子在第 $0$ 个袋子中，费用为 $A[0] \\times 1 + B[0] = 1 \\times 1 + 2 = 3$ 元，剩下 $Z$。\n   - 若魔法珠子在第 $1$ 个袋子中，费用为 $A[1] \\times 1 + B[1] = 3 \\times 1 + 1 = 4$ 元，剩下 $X$。\n- 若魔法珠子在第 $1$ 个袋子中，费用为 $A[1] \\times 1 + B[1] = 3 \\times 1 + 1 = 4$ 元，剩下 $Y$。\n\n在这种策略下，若 $X$ 是魔法珠子，总费用为 $4 + 4 = 8$ 元；若 $Y$ 是魔法珠子，总费用为 $4$ 元；若 $Z$ 是魔法珠子，总费用为 $4 + 3 = 7$ 元。因此，最坏情况下费用为 $8$ 元。\n\n函数应返回 `[0,4,8]`。", "locale": "zh-CN"}}}
{"pid": "P11590", "type": "P", "difficulty": 7, "samples": [["4\n1 1 1 1\n2 2 1 1\n3 3 4 1\n4 4 4 1\n", "2\n"], ["10\n5 10 1 127\n7 9 1 130\n5 6 3 22\n8 10 2 60\n7 6 3 43\n9 6 2 23\n8 6 3 9\n5 8 2 27\n6 7 2 175\n8 9 2 57\n", "673\n"], ["10\n4 3 2 90\n1 3 4 122\n9 8 2 105\n5 10 2 106\n9 1 2 125\n8 1 4 72\n4 8 4 142\n9 6 4 78\n8 9 2 68\n4 10 4 99\n", "1007\n"], ["10\n8 8 1 38\n10 6 3 11\n1 4 1 150\n3 7 2 91\n5 3 4 30\n8 9 2 147\n5 1 4 164\n3 4 2 6\n4 1 3 104\n5 4 1 19\n", "593\n"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "交互题", "KOI（韩国）"], "title": "[KTSC 2022 R2] 安全系统", "background": "\n  \n  \n**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <vector>\n\nint max_level (std::vector<int> X, std::vector<int> Y, std::vector<int> D, std::vector<int> W);\n  \n```\n\n题目译自 [2022년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2022/) T2「 [보안 시스템](https://assets.ioikorea.kr/ioitst/2022/2/security/security_statement.pdf)」\n\n", "description": "KOI 国的机密设施可以表示为一个在坐标平面上的正方形，其左下角顶点为 $(0,0)$，右上角顶点为 $(N+1, N+1)$，边与坐标轴平行。正方形的每条边代表机密设施的外壁。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n0dm12u7.png)\n\n在机密设施内有 $N$ 个激光传感器，每个传感器从 $0$ 到 $N-1$ 编号。我们需要设计一个安全系统，通过这些激光传感器来检测入侵者。\n\n每个激光传感器可以表示为坐标平面上的一个点。当激光传感器启动时，它会向上（$+y$ 轴方向）、向右（$+x$ 轴方向）、向下（$-y$ 轴方向）或向左（$-x$ 轴方向）发射激光。激光会一直延伸到碰到墙壁为止，因此激光的路径可以表示为从传感器位置到墙壁上的某个点的线段。\n\n激光发射的方向用 $1$ 到 $4$ 表示。$1$ 表示向上，$2$ 表示向右，$3$ 表示向下，$4$ 表示向左。下图依次展示了激光传感器向 $1$、$2$、$3$、$4$ 方向发射激光的示例。黑点表示激光传感器，红线表示激光。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yvu8war4.png)\n\n第 $i (0 \\leq i \\leq N-1)$ 个激光传感器位于 $(X[i], Y[i])$，启动时会向 $D[i]$ 方向发射激光。不同的激光传感器位于不同的位置。$X[i]$ 和 $Y[i]$ 是 $1$ 到 $N$ 之间的整数。\n\n你可以自由决定每个激光传感器是否启动。但如果不同的激光传感器发射的激光相遇，会导致检测错误，因此激光不能相交，包括端点。下图展示了激光相交的示例，激光可以在一个点相交，也可以在一条线段上相交。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uidq4ybl.png)\n\n第 $i (0 \\leq i \\leq N-1)$ 个激光传感器的重要性为 $W[i]$，表示启动该传感器的贡献值。整个安全系统的安全级别是启动的激光传感器的贡献值之和。\n\n请编写一个函数，在确保激光不相交的前提下，决定哪些激光传感器启动，使得安全级别最大。\n\n你需要实现以下函数：\n\n`int max_level(vector<int> X, vector<int> Y, vector<int> D, vector<int> W);`\n\n- `X, Y, D, W`：长度为 $N$ 的整数数组。对于每个 $i (0 \\leq i \\leq N-1)$，第 $i$ 个激光传感器的坐标为 $(X[i], Y[i])$，启动时向 $D[i]$ 方向发射激光，重要性为 $W[i]$。\n- 该函数返回在确保激光不相交的前提下，最大可能的安全级别。\n\n注意，提交的代码中不应包含任何输入输出操作。", "inputFormat": "示例评测程序的输入格式如下：\n\n- 第 $1$ 行：$N$\n- 第 $2+i (0 \\leq i \\leq N-1)$ 行：$X[i]\\,Y[i]\\,D[i]\\,W[i]$\n", "outputFormat": "示例评测程序的输出格式如下：\n\n第 $1$ 行：`max_level` 函数返回的值。", "hint": "### 样例解释 #1\n\n考虑 $N=4, X=[1,2,3,4], Y=[1,2,3,4], D=[1,1,4,4], W=[1,1,1,1]$ 的情况。评测程序将调用如下函数：\n\n`max_level({1, 2, 3, 4}, {1, 2, 3, 4}, {1, 1, 4, 4}, {1, 1, 1, 1});`\n\n下图展示了机密设施、传感器和传感器发射的激光。启动 $0$ 号和 $1$ 号传感器，或启动 $2$ 号和 $3$ 号传感器，激光不会相交，安全级别为 $2$。没有比这更高的安全级别的方案。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/za9t7c8u.png)\n\n因此，函数应返回 `2`。\n\n### 数据范围\n对于所有输入数据，满足：\n\n- $1 \\leq N \\leq 1500$\n- 对于所有 $i (0 \\leq i \\leq N-1)$，$1 \\leq X[i], Y[i] \\leq N$\n- $D[i] \\in \\{1,2,3,4\\}$ (对于所有 $0 \\leq i \\leq N-1$)\n- 对于所有 $i (0 \\leq i \\leq N-1)$，$1 \\leq W[i] \\leq 10^5$\n- 每个传感器的位置都不同。\n\n详细子任务附加限制及分值如下表所示。\n\n| Subtask | 分值 | 约束 |\n| :----------: | :----------: | :----------: |\n|$1$|$5$|$N \\leq 18$|\n|$2$|$8$|$N \\leq 36$|\n|$3$|$21$|$N \\leq 100$|\n|$4$|$15$|$N \\leq 500$|\n|$5$|$11$|对于所有 $i (0 \\leq i \\leq N-1)$，$D[i] \\in \\{1,2,3\\}$|\n|$6$|$17$|对于所有 $i,j (0 \\leq i < j \\leq N-1)$，$X[i] \\neq X[j]$ 且 $Y[i] \\neq Y[j]$|\n|$7$|$23$|无附加限制|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KTSC 2022 R2] 安全系统", "background": "\n  \n  \n**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <vector>\n\nint max_level (std::vector<int> X, std::vector<int> Y, std::vector<int> D, std::vector<int> W);\n  \n```\n\n题目译自 [2022년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2022/) T2「 [보안 시스템](https://assets.ioikorea.kr/ioitst/2022/2/security/security_statement.pdf)」\n\n", "description": "KOI 国的机密设施可以表示为一个在坐标平面上的正方形，其左下角顶点为 $(0,0)$，右上角顶点为 $(N+1, N+1)$，边与坐标轴平行。正方形的每条边代表机密设施的外壁。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n0dm12u7.png)\n\n在机密设施内有 $N$ 个激光传感器，每个传感器从 $0$ 到 $N-1$ 编号。我们需要设计一个安全系统，通过这些激光传感器来检测入侵者。\n\n每个激光传感器可以表示为坐标平面上的一个点。当激光传感器启动时，它会向上（$+y$ 轴方向）、向右（$+x$ 轴方向）、向下（$-y$ 轴方向）或向左（$-x$ 轴方向）发射激光。激光会一直延伸到碰到墙壁为止，因此激光的路径可以表示为从传感器位置到墙壁上的某个点的线段。\n\n激光发射的方向用 $1$ 到 $4$ 表示。$1$ 表示向上，$2$ 表示向右，$3$ 表示向下，$4$ 表示向左。下图依次展示了激光传感器向 $1$、$2$、$3$、$4$ 方向发射激光的示例。黑点表示激光传感器，红线表示激光。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yvu8war4.png)\n\n第 $i (0 \\leq i \\leq N-1)$ 个激光传感器位于 $(X[i], Y[i])$，启动时会向 $D[i]$ 方向发射激光。不同的激光传感器位于不同的位置。$X[i]$ 和 $Y[i]$ 是 $1$ 到 $N$ 之间的整数。\n\n你可以自由决定每个激光传感器是否启动。但如果不同的激光传感器发射的激光相遇，会导致检测错误，因此激光不能相交，包括端点。下图展示了激光相交的示例，激光可以在一个点相交，也可以在一条线段上相交。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uidq4ybl.png)\n\n第 $i (0 \\leq i \\leq N-1)$ 个激光传感器的重要性为 $W[i]$，表示启动该传感器的贡献值。整个安全系统的安全级别是启动的激光传感器的贡献值之和。\n\n请编写一个函数，在确保激光不相交的前提下，决定哪些激光传感器启动，使得安全级别最大。\n\n你需要实现以下函数：\n\n`int max_level(vector<int> X, vector<int> Y, vector<int> D, vector<int> W);`\n\n- `X, Y, D, W`：长度为 $N$ 的整数数组。对于每个 $i (0 \\leq i \\leq N-1)$，第 $i$ 个激光传感器的坐标为 $(X[i], Y[i])$，启动时向 $D[i]$ 方向发射激光，重要性为 $W[i]$。\n- 该函数返回在确保激光不相交的前提下，最大可能的安全级别。\n\n注意，提交的代码中不应包含任何输入输出操作。", "inputFormat": "示例评测程序的输入格式如下：\n\n- 第 $1$ 行：$N$\n- 第 $2+i (0 \\leq i \\leq N-1)$ 行：$X[i]\\,Y[i]\\,D[i]\\,W[i]$\n", "outputFormat": "示例评测程序的输出格式如下：\n\n第 $1$ 行：`max_level` 函数返回的值。", "hint": "### 样例解释 #1\n\n考虑 $N=4, X=[1,2,3,4], Y=[1,2,3,4], D=[1,1,4,4], W=[1,1,1,1]$ 的情况。评测程序将调用如下函数：\n\n`max_level({1, 2, 3, 4}, {1, 2, 3, 4}, {1, 1, 4, 4}, {1, 1, 1, 1});`\n\n下图展示了机密设施、传感器和传感器发射的激光。启动 $0$ 号和 $1$ 号传感器，或启动 $2$ 号和 $3$ 号传感器，激光不会相交，安全级别为 $2$。没有比这更高的安全级别的方案。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/za9t7c8u.png)\n\n因此，函数应返回 `2`。\n\n### 数据范围\n对于所有输入数据，满足：\n\n- $1 \\leq N \\leq 1500$\n- 对于所有 $i (0 \\leq i \\leq N-1)$，$1 \\leq X[i], Y[i] \\leq N$\n- $D[i] \\in \\{1,2,3,4\\}$ (对于所有 $0 \\leq i \\leq N-1$)\n- 对于所有 $i (0 \\leq i \\leq N-1)$，$1 \\leq W[i] \\leq 10^5$\n- 每个传感器的位置都不同。\n\n详细子任务附加限制及分值如下表所示。\n\n| Subtask | 分值 | 约束 |\n| :----------: | :----------: | :----------: |\n|$1$|$5$|$N \\leq 18$|\n|$2$|$8$|$N \\leq 36$|\n|$3$|$21$|$N \\leq 100$|\n|$4$|$15$|$N \\leq 500$|\n|$5$|$11$|对于所有 $i (0 \\leq i \\leq N-1)$，$D[i] \\in \\{1,2,3\\}$|\n|$6$|$17$|对于所有 $i,j (0 \\leq i < j \\leq N-1)$，$X[i] \\neq X[j]$ 且 $Y[i] \\neq Y[j]$|\n|$7$|$23$|无附加限制|", "locale": "zh-CN"}}}
{"pid": "P11591", "type": "P", "difficulty": 4, "samples": [["9 6 4\n2 4 5 7\n1 2\n1 3\n1 8\n2 4\n3 4\n5 6", "1 1 1 1 -1 1 -1 2 -1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "2024", "广度优先搜索 BFS", "最短路", "NordicOI（北欧）"], "title": "[NordicOI 2024] Anime Shops", "background": "翻译自 [NordicOI 2024 A](https://cses.fi/495/task/A)。", "description": "有 $n$ 个城市和 $m$ 条连接了两个城市的双向道路。有 $k$ 个城市有动漫商店。\n\n对于每个城市，求出从这个城市出发到除自己以外的另一个有动漫商店的城市的最小距离。", "inputFormat": "第一行输入三个整数 $n,m,k$。\n\n第二行 $k$ 个整数，表示有动漫商店的城市的编号。\n\n接下来 $m$ 行，每行两个数 $a,b$，表示有一条连接城市 $a$ 和 $b$ 的道路。", "outputFormat": "输出一行 $n$ 个整数，其中第 $i$ 个数表示从城市 $i$ 出发到达另一个有动漫商店的城市的最小距离。如果没有这样的城市，输出 `-1`。", "hint": "本题采用捆绑测试。\n\n| 子任务 | 分值 | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $23$ | $1 \\le k \\le n \\le 1000$，$0 \\le m \\le 2000$ |\n| $2$ | $16$ | $1 \\le k \\le n \\le 10^5$，$m=n-1$，每条路连接城市 $i$ 和 $i+1$ |\n| $3$ | $61$ | $1 \\le k \\le n \\le 10^5$，$0 \\le m \\le 2 \\cdot 10^5$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NordicOI 2024] Anime Shops", "background": "翻译自 [NordicOI 2024 A](https://cses.fi/495/task/A)。", "description": "有 $n$ 个城市和 $m$ 条连接了两个城市的双向道路。有 $k$ 个城市有动漫商店。\n\n对于每个城市，求出从这个城市出发到除自己以外的另一个有动漫商店的城市的最小距离。", "inputFormat": "第一行输入三个整数 $n,m,k$。\n\n第二行 $k$ 个整数，表示有动漫商店的城市的编号。\n\n接下来 $m$ 行，每行两个数 $a,b$，表示有一条连接城市 $a$ 和 $b$ 的道路。", "outputFormat": "输出一行 $n$ 个整数，其中第 $i$ 个数表示从城市 $i$ 出发到达另一个有动漫商店的城市的最小距离。如果没有这样的城市，输出 `-1`。", "hint": "本题采用捆绑测试。\n\n| 子任务 | 分值 | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $23$ | $1 \\le k \\le n \\le 1000$，$0 \\le m \\le 2000$ |\n| $2$ | $16$ | $1 \\le k \\le n \\le 10^5$，$m=n-1$，每条路连接城市 $i$ 和 $i+1$ |\n| $3$ | $61$ | $1 \\le k \\le n \\le 10^5$，$0 \\le m \\le 2 \\cdot 10^5$ |", "locale": "zh-CN"}}}
{"pid": "P11592", "type": "P", "difficulty": 7, "samples": [["3\n4\n1 1 1 1\n4\n1 1 1 2\n5\n4 1 2 1 2", "YES\n1 1 1 1\nNO\nYES\n2 4 1 1 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "Special Judge", "NordicOI（北欧）"], "title": "[NordicOI 2024] Chair Game", "background": "翻译自 [NordicOI 2024 B](https://cses.fi/495/task/B)。", "description": "在一个游戏中，有 $n$ 名玩家和 $n$ 把椅子。所有椅子排列成一个圆，每个玩家坐在一把椅子上。\n\n在游戏中会有铃声响起。每把椅子上都有一个在 $1$ 到 $n$ 之间的整数 $s_i$，表示当铃声响起时，坐在这把椅子上的玩家需要顺时针移动 $s_i$ 步。如果铃声响起后每把椅子上恰有一名玩家，则称这个椅子的排列是合法的。\n\n给定所有椅子上的数，你需要判断是否可以将这些椅子重新排列使得其合法。如果可以，还需要给出一个方案。", "inputFormat": "本题多测。第一行一个整数 $t$ 表示测试数据组数。\n\n对于每组测试数据，第一行输入一个整数 $n$，第二行输入 $n$ 个整数 $s_1,s_2,\\dots,s_n$，表示椅子上的数。", "outputFormat": "对于每组数据，第一行输出一个为 `YES` 或 `NO` 的字符串，表示是否可以将这些椅子重新排列使得其合法。如果答案为 `YES`，第二行输出 $n$ 个数，表示一个合法的排列方案。如果有多个合法的方案，输出任意一个。", "hint": "对于所有数据：\n\n- $1 \\le t \\le 1000$\n- $1 \\le n \\le 100$\n- $1 \\le s_i \\le n$\n\n本题采用捆绑测试。\n\n| 子任务 | 分值 | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $8$ | $1\\le n\\le8$ |\n| $2$ | $5$ | 对于所有 $i\\ne j$，$s_i\\ne s_j$ |\n| $3$ | $4$ | $1\\le s_i\\le 2$ |\n| $4$ | $7$ | $1\\le s_i\\le 3$ |\n| $5$ | $12$ | $1\\le s_i\\le 4$ |\n| $6$ | $15$ | $1\\le s_i\\le 5$ |\n| $7$ | $20$ | $1\\le n\\le16$ |\n| $8$ | $29$ | 无 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NordicOI 2024] Chair Game", "background": "翻译自 [NordicOI 2024 B](https://cses.fi/495/task/B)。", "description": "在一个游戏中，有 $n$ 名玩家和 $n$ 把椅子。所有椅子排列成一个圆，每个玩家坐在一把椅子上。\n\n在游戏中会有铃声响起。每把椅子上都有一个在 $1$ 到 $n$ 之间的整数 $s_i$，表示当铃声响起时，坐在这把椅子上的玩家需要顺时针移动 $s_i$ 步。如果铃声响起后每把椅子上恰有一名玩家，则称这个椅子的排列是合法的。\n\n给定所有椅子上的数，你需要判断是否可以将这些椅子重新排列使得其合法。如果可以，还需要给出一个方案。", "inputFormat": "本题多测。第一行一个整数 $t$ 表示测试数据组数。\n\n对于每组测试数据，第一行输入一个整数 $n$，第二行输入 $n$ 个整数 $s_1,s_2,\\dots,s_n$，表示椅子上的数。", "outputFormat": "对于每组数据，第一行输出一个为 `YES` 或 `NO` 的字符串，表示是否可以将这些椅子重新排列使得其合法。如果答案为 `YES`，第二行输出 $n$ 个数，表示一个合法的排列方案。如果有多个合法的方案，输出任意一个。", "hint": "对于所有数据：\n\n- $1 \\le t \\le 1000$\n- $1 \\le n \\le 100$\n- $1 \\le s_i \\le n$\n\n本题采用捆绑测试。\n\n| 子任务 | 分值 | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $8$ | $1\\le n\\le8$ |\n| $2$ | $5$ | 对于所有 $i\\ne j$，$s_i\\ne s_j$ |\n| $3$ | $4$ | $1\\le s_i\\le 2$ |\n| $4$ | $7$ | $1\\le s_i\\le 3$ |\n| $5$ | $12$ | $1\\le s_i\\le 4$ |\n| $6$ | $15$ | $1\\le s_i\\le 5$ |\n| $7$ | $20$ | $1\\le n\\le16$ |\n| $8$ | $29$ | 无 |", "locale": "zh-CN"}}}
{"pid": "P11593", "type": "P", "difficulty": 6, "samples": [["3 4\n1 1 1 1\n1 3 6 1\n3 4 5 1", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "二分", "并查集", "2024", "Kruskal 重构树", "树形 DP", "NordicOI（北欧）"], "title": "[NordicOI 2024] Thin Ice", "background": "翻译自 [NordicOI 2024 C](https://cses.fi/495/task/C)。", "description": "Uolevi 在一个冻湖上，湖可以被分为 $n\\times m$ 的网格，每个格子上都有一个金币。\n\n每个格子有一个承受能力，即这个格子的冰上能承受的最大金币数量。\n\n每一步，Uolevi 可以向上、下、左或右移动一格，但不能超出 $n\\times m$ 的边界。如果 Uolevi 当前所在的格子上有金币，那么他可以把金币捡起来。\n\nUolevi 移动时，需要保证目标格子上的金币和自己身上的金币数量加起来不超过目标格子的承受能力。Uolevi 本身的重量可以忽略不计。\n\nUolevi 要收集湖上的金币，为此，他要从湖的边缘出发，到湖的边缘结束。他想知道他最多可以收集到几个金币。", "inputFormat": "第一行输入两个整数 $n,m$。\n\n接下来 $n$ 行，每行 $m$ 个数，每个位置的数 $d$ 表示湖上对应位置格子的承受能力。", "outputFormat": "输出 Uolevi 可以收集到的最大金币数量。", "hint": "### 样例解释：\n\nUolevi 可以从左上角开始，按以下方式移动：\n\n向下 $\\rightarrow$ 捡硬币 $\\rightarrow$ 向右 $\\rightarrow$ 捡硬币 $\\rightarrow$ 向下 $\\rightarrow$ 向左 $\\rightarrow$ 捡硬币 $\\rightarrow$ 向右 $\\rightarrow$ 捡硬币 $\\rightarrow$ 向右 $\\rightarrow$ 捡硬币\n\nUolevi 不可能收集到大于 $6$ 个金币，因为边缘所有格子的承受能力都小于等于 $5$。\n\n### 数据范围：\n\n本题采用捆绑测试。\n\n| 子任务 | 分值 | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $17$ | $1 \\le nm \\le 16,1 \\le d \\le 16$ |\n| $2$ | $12$ | $1 \\le nm \\le 2 \\cdot 10^5,1 \\le d \\le 5$ |\n| $3$ | $11$ | $n = 1, 1 \\le m \\le 100,1 \\le d \\le 100$ |\n| $4$ | $19$ | $n = 1, 1 \\le m \\le 2 \\cdot 10^5,1 \\le d \\le 2 \\cdot 10^5$ |\n| $5$ | $14$ | $1 \\le nm \\le 1000,1 \\le d \\le 1000$ |\n| $6$ | $27$ | $1 \\le nm \\le 2 \\cdot 10^5,1 \\le d \\le 2 \\cdot 10^5$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NordicOI 2024] Thin Ice", "background": "翻译自 [NordicOI 2024 C](https://cses.fi/495/task/C)。", "description": "Uolevi 在一个冻湖上，湖可以被分为 $n\\times m$ 的网格，每个格子上都有一个金币。\n\n每个格子有一个承受能力，即这个格子的冰上能承受的最大金币数量。\n\n每一步，Uolevi 可以向上、下、左或右移动一格，但不能超出 $n\\times m$ 的边界。如果 Uolevi 当前所在的格子上有金币，那么他可以把金币捡起来。\n\nUolevi 移动时，需要保证目标格子上的金币和自己身上的金币数量加起来不超过目标格子的承受能力。Uolevi 本身的重量可以忽略不计。\n\nUolevi 要收集湖上的金币，为此，他要从湖的边缘出发，到湖的边缘结束。他想知道他最多可以收集到几个金币。", "inputFormat": "第一行输入两个整数 $n,m$。\n\n接下来 $n$ 行，每行 $m$ 个数，每个位置的数 $d$ 表示湖上对应位置格子的承受能力。", "outputFormat": "输出 Uolevi 可以收集到的最大金币数量。", "hint": "### 样例解释：\n\nUolevi 可以从左上角开始，按以下方式移动：\n\n向下 $\\rightarrow$ 捡硬币 $\\rightarrow$ 向右 $\\rightarrow$ 捡硬币 $\\rightarrow$ 向下 $\\rightarrow$ 向左 $\\rightarrow$ 捡硬币 $\\rightarrow$ 向右 $\\rightarrow$ 捡硬币 $\\rightarrow$ 向右 $\\rightarrow$ 捡硬币\n\nUolevi 不可能收集到大于 $6$ 个金币，因为边缘所有格子的承受能力都小于等于 $5$。\n\n### 数据范围：\n\n本题采用捆绑测试。\n\n| 子任务 | 分值 | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $17$ | $1 \\le nm \\le 16,1 \\le d \\le 16$ |\n| $2$ | $12$ | $1 \\le nm \\le 2 \\cdot 10^5,1 \\le d \\le 5$ |\n| $3$ | $11$ | $n = 1, 1 \\le m \\le 100,1 \\le d \\le 100$ |\n| $4$ | $19$ | $n = 1, 1 \\le m \\le 2 \\cdot 10^5,1 \\le d \\le 2 \\cdot 10^5$ |\n| $5$ | $14$ | $1 \\le nm \\le 1000,1 \\le d \\le 1000$ |\n| $6$ | $27$ | $1 \\le nm \\le 2 \\cdot 10^5,1 \\le d \\le 2 \\cdot 10^5$ |", "locale": "zh-CN"}}}
{"pid": "P11594", "type": "P", "difficulty": 3, "samples": [["5 5 1 1\n....M\n.M...\n..S..\n.S...\n...M.", "1"], ["4 4 4 1\n....\n.M..\n..MM\n...S", "3"], ["1 8 5 2\nSM..MM.S", "2"], ["5 5 2 2\n....M\n.M...\n..S..\n.S...\n...M.", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "前缀和", "差分", "NOISG（新加坡）"], "title": "[NOISG 2018 Finals] Collecting Mushrooms", "background": "译自 [NOISG 2018 Finals A. Collecting Mushrooms](https://github.com/noisg/sg_noi_archive/tree/master/2018/tasks/collectmushrooms)。", "description": "螃蟹 Lim Li 在她的花园里打造了一个蘑菇种植园。这个蘑菇种植园可以看成一个 $R$ 行 $C$ 列的网格，其中每一格要么是空的，要么有一朵蘑菇，要么有一个洒水器。\n\n举个例子，一个 $R=5,C=5$ 的蘑菇种植园可能是长这样子的：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qqn2ssqx.png)\n\n一朵蘑菇和一个洒水器之间的距离被定义为它们的横坐标差的绝对值与纵坐标差的绝对值的较大值。换句话说，假设一朵蘑菇位于 $X_m$ 行 $Y_m$ 列，一个洒水器位于 $X_s$ 行 $Y_s$ 列，那么它们之间的距离为 $\\max(|X_m-X_s|,|Y_m-Y_s|)$。\n\n一个洒水器只能浇到距离自己不超过 $D$ 的蘑菇。下图展示了 $D=1$ 时洒水器可以浇到的区域：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sr5w3lov.png)\n\n一朵蘑菇如果可以被至少 $K$ 个洒水器浇到，则我们称它是**好蘑菇**。你需要帮 Lim Li 计数在她的蘑菇种植园里有多少朵**好蘑菇**。", "inputFormat": "第一行包含四个整数 $R,C,D,K$，含义如题意所述。\n\n接下来 $R$ 行，每行 $C$ 个字符，描述一个蘑菇种植园。每个字符表示一个格子：\n\n- `.` 表示一个空格子。\n- `M` 表示一个有一朵蘑菇的格子。\n- `S` 表示一个有一个洒水器的格子。", "outputFormat": "一行一个整数，表示**好蘑菇**的数量。", "hint": "### 样例 #1 解释\n\n所有洒水器可以浇到的距离范围都是 $1$，也就是每个洒水器都能且仅能洒到与自己八连通的格子。只有位于 $(2,2)$ 的蘑菇可以被浇到水。\n\n这组样例满足子任务 $3,4,6$。\n\n### 样例 #2 解释\n\n唯一的洒水器可以浇到的距离范围是 $4$，所以可以浇到所有蘑菇。\n\n这组样例满足子任务 $1,2,4,6$。\n\n### 样例 #3 解释\n\n所有蘑菇都需要被两头的洒水器浇到才能成为**好蘑菇**。因为洒水器可以浇到的距离范围都是 $5$，所以只有从左往右第二朵和第三朵蘑菇满足**好蘑菇**的要求。\n\n这组样例满足子任务 $4,5,6$。\n\n### 样例 #4 解释\n\n因为洒水器可以浇到的距离范围都是 $2$，所以只有位于 $(2,2)$ 和 $(5,4)$ 的蘑菇可以同时被两个洒水器浇到。\n\n这组样例满足子任务 $4,6$。\n\n### 子任务\n\n对于 $100\\%$ 的数据，$2\\le RC\\le 5\\times 10^5$，$1\\le D\\le \\max(R,C)$，$1\\le K\\le RC$。保证种植园中至少有一朵蘑菇和一个洒水器。\n\n| 子任务 | 得分 | 数据范围及特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $9$ | $1\\le R,C\\le 100$，$D=\\max(R,C)$，$K=1$ |\n| $2$ | $10$ | $1\\le R,C\\le 100$，$D=\\max(R,C)$ |\n| $3$ | $18$ | $1\\le R,C\\le 100$，$D=1$，$K=1$ |\n| $4$ | $23$ | $1\\le R,C\\le 500$，洒水器和蘑菇的数量均少于 $500$ |\n| $5$ | $19$ | $R=1$ |\n| $6$ | $21$ | 无特殊限制 |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2018 Finals] Collecting Mushrooms", "background": "译自 [NOISG 2018 Finals A. Collecting Mushrooms](https://github.com/noisg/sg_noi_archive/tree/master/2018/tasks/collectmushrooms)。", "description": "螃蟹 Lim Li 在她的花园里打造了一个蘑菇种植园。这个蘑菇种植园可以看成一个 $R$ 行 $C$ 列的网格，其中每一格要么是空的，要么有一朵蘑菇，要么有一个洒水器。\n\n举个例子，一个 $R=5,C=5$ 的蘑菇种植园可能是长这样子的：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qqn2ssqx.png)\n\n一朵蘑菇和一个洒水器之间的距离被定义为它们的横坐标差的绝对值与纵坐标差的绝对值的较大值。换句话说，假设一朵蘑菇位于 $X_m$ 行 $Y_m$ 列，一个洒水器位于 $X_s$ 行 $Y_s$ 列，那么它们之间的距离为 $\\max(|X_m-X_s|,|Y_m-Y_s|)$。\n\n一个洒水器只能浇到距离自己不超过 $D$ 的蘑菇。下图展示了 $D=1$ 时洒水器可以浇到的区域：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sr5w3lov.png)\n\n一朵蘑菇如果可以被至少 $K$ 个洒水器浇到，则我们称它是**好蘑菇**。你需要帮 Lim Li 计数在她的蘑菇种植园里有多少朵**好蘑菇**。", "inputFormat": "第一行包含四个整数 $R,C,D,K$，含义如题意所述。\n\n接下来 $R$ 行，每行 $C$ 个字符，描述一个蘑菇种植园。每个字符表示一个格子：\n\n- `.` 表示一个空格子。\n- `M` 表示一个有一朵蘑菇的格子。\n- `S` 表示一个有一个洒水器的格子。", "outputFormat": "一行一个整数，表示**好蘑菇**的数量。", "hint": "### 样例 #1 解释\n\n所有洒水器可以浇到的距离范围都是 $1$，也就是每个洒水器都能且仅能洒到与自己八连通的格子。只有位于 $(2,2)$ 的蘑菇可以被浇到水。\n\n这组样例满足子任务 $3,4,6$。\n\n### 样例 #2 解释\n\n唯一的洒水器可以浇到的距离范围是 $4$，所以可以浇到所有蘑菇。\n\n这组样例满足子任务 $1,2,4,6$。\n\n### 样例 #3 解释\n\n所有蘑菇都需要被两头的洒水器浇到才能成为**好蘑菇**。因为洒水器可以浇到的距离范围都是 $5$，所以只有从左往右第二朵和第三朵蘑菇满足**好蘑菇**的要求。\n\n这组样例满足子任务 $4,5,6$。\n\n### 样例 #4 解释\n\n因为洒水器可以浇到的距离范围都是 $2$，所以只有位于 $(2,2)$ 和 $(5,4)$ 的蘑菇可以同时被两个洒水器浇到。\n\n这组样例满足子任务 $4,6$。\n\n### 子任务\n\n对于 $100\\%$ 的数据，$2\\le RC\\le 5\\times 10^5$，$1\\le D\\le \\max(R,C)$，$1\\le K\\le RC$。保证种植园中至少有一朵蘑菇和一个洒水器。\n\n| 子任务 | 得分 | 数据范围及特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $9$ | $1\\le R,C\\le 100$，$D=\\max(R,C)$，$K=1$ |\n| $2$ | $10$ | $1\\le R,C\\le 100$，$D=\\max(R,C)$ |\n| $3$ | $18$ | $1\\le R,C\\le 100$，$D=1$，$K=1$ |\n| $4$ | $23$ | $1\\le R,C\\le 500$，洒水器和蘑菇的数量均少于 $500$ |\n| $5$ | $19$ | $R=1$ |\n| $6$ | $21$ | 无特殊限制 |\n", "locale": "zh-CN"}}}
{"pid": "P11595", "type": "P", "difficulty": 3, "samples": [["4 4 3\n1 2 2 2 3 0\n2 2 2 3 3 0\n3 1 3 3 3 0", "1 1 3 6"], ["4 8 3\n1 0 2 1 3 0\n3 1 3 2 3 0\n3 1 3 1 3 0", "2 5 11 17 23 29 35 41"], ["4 11 3\n1 0 2 0 3 0\n0 0 2 0 3 0\n0 0 0 0 3 0", "4 8 13 19 26 34 43 53 64 76 89"], ["8 8 8\n1 0 1 0 1 0 1 0 1 0 1 0 1 0 7 0\n2 0 2 0 2 0 2 0 2 0 2 0 2 0 7 0\n3 0 3 0 3 0 3 0 3 0 3 0 3 0 7 0\n4 0 4 0 4 0 4 0 4 0 4 0 4 0 7 0\n5 0 5 0 5 0 5 0 5 0 5 0 5 0 7 0\n6 0 6 0 6 0 6 0 6 0 6 0 6 0 7 0\n7 0 7 0 7 0 7 0 7 0 7 0 7 0 7 0", "960800 6702725 26746084 80092734 199948848 439388874 500000001 500000001"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2018", "NOISG（新加坡）"], "title": "[NOISG 2018 Finals] Journey", "background": "译自 [NOISG 2018 Finals B. Journey](https://github.com/noisg/sg_noi_archive/tree/master/2018/tasks/journey)。", "description": "Kuno 要从 A 市到 B 市旅行，但在路途中他可能会停下来休息。\n\n允许他停留的共有 $N$ 个城市，编号为 $0$ 到 $N-1$，其中 $0$ 号城市表示 A 市，$N-1$ 号城市表示 B 市，编号越大的城市距离 B 市越近。\n\n为了让旅行保持一定的效率，中途停留需要满足以下限制：\n\n- 第 $i$ 次停留的城市必须比第 $i-1$ 次离 B 市**严格**更近。特别地，我们认为第 $0$ 次停留的城市是 A 市。\n- 从 A 市出发，直到从 B 市结束停留离开，整个过程不能超过 $M$ 天。换句话说，我们不允许你在 A 市停留，但允许你在 B 市停留。\n\nKuno 在城市之间的移动和停留基于城市之间的航线和城市中的酒店系统。每个城市 $i$ 都存在 $H$ 条用 $(j,k)$ 表示的航线，表示你可以通过这条航线从城市 $i$ 前往城市 $j$，但是一旦使用这条航线，就必须在城市 $j$ 中停留不少于 $k$ 天。**特别地，每个城市都有一条直接前往 B 市的航线**。\n\n注意可能存在完全相同或起点终点相同的航线，此时你需要把它们视为**不同航线**。你应当忽略远离 B 市的航线。\n\n在飞机中度过的时间忽略不计。\n\n到达一个城市即算作在该城市停留，即使停留了 $0$ 天。\n\n你的任务是，对每一个 $d\\in[1,m]$，帮助 Kuno 计数他从 A 市出发到从 B 市结束停留返回花费 $d$ 天的方案数。特别地，若方案数超过 $5\\times 10^8$，你只需输出 $5\\times 10^8+1$。\n\n两个旅行方案不同当且仅当以下三条任意一条成立：\n\n1. 一个旅行方案中需要在城市 $i$ 停留，而另一个不用。\n2. 存在一个城市 $i$，使得两个旅行方案离开该城市的时间不同。**特别地，也包括从 B 市离开的时间不同**。\n3. 两个行程都从城市 $i$ 到城市 $j$，但使用的航线不同。\n\n例如，对于两个均为 A 市到 C 市，再从 C 市到 D 市，最后从 D 市到 B 市的旅行方案，如果一个是在第二天离开 C 市，另一个是在第三天离开 C 市，那么它们就是不同的方案。此外，如果输入中存在两条同样从 D 市前往 B 市的航线，即便出发时间和到达时间相同，也是不同的方案。\n\n如你仍无法完全理解题意，请阅读**样例解释**。", "inputFormat": "第一行包含三个整数 $N,M,H$，表示城市数量，旅行天数上限，和每个城市的航线数量。\n\n接下来的输入包含 $N-1$ 行，第 $i$ 行包含 $2H$ 个用空格分割的整数，每两个为一组 $(j,k)$，描述从城市 $i-1$ 出发的 $H$ 条航线。\n\n", "outputFormat": "输出 $m$ 个用空格隔开的整数，依次表示从 A 市出发直至从 B 市结束停留离开共花费恰好 $1,2,3,\\cdots ,m$ 天的旅行方案数。注意如果方案数超过 $5\\times 10^8$，则应输出 $5\\times 10^8+1$。", "hint": "### 样例 #1 解释\n\n样例 #1 输入描述了一个具有 $4$ 座城市，每个城市有 $3$ 条不同的航线出发的情况：\n\n| 出发城市 | 航线 $1$ 终点 | $\\text{Min.}$ | 航线 $2$ 终点 | $\\text{Min.}$ | 航线 $3$ 终点 | $\\text{Min.}$ |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| A 市 | 城市 $1$ | $2$ 天 | 城市 $2$ | $2$ 天 | B 市 | $0$ 天 |\n| 城市 $1$ | 城市 $2$ | $2$ 天 | 城市 $2$ | $3$ 天 | B 市 | $0$ 天 |\n| 城市 $2$ | B 市 | $1$ 天 | B 市 | $3$ 天 | B 市 | $0$ 天 |\n\n为了方便表格描述，我们用 $\\text{Min.}$ 表示了每条航线对目的地最少停留天数的要求。\n\n所有 $1$ 天的旅行方案如下；\n\n| 旅行方案 | 方案 |\n| :----------: | :----------: |\n| $1$ | 在第 $1$ 天从 A 市通过航线 $3$ 抵达 B 市，在 B 市停留 $0$ 天。 |\n\n所有 $2$ 天的旅行方案如下：\n\n| 旅行方案 | 方案 |\n| :----------: | :----------: |\n| $1$ | 在第 $1$ 天从 A 市通过航线 $3$ 抵达 B 市，在 B 市停留 $1$ 天。 |\n\n所有 $3$ 天的旅行方案如下：\n\n| 旅行方案 | 方案 |\n| :----------: | :----------: |\n| $1$ | 在第 $1$ 天从 A 市通过航线 $1$ 抵达城市 $1$，在城市 $1$ 停留 $2$ 天；在第 $3$ 天从城市 $1$ 通过航线 $3$ 抵达 B 市，在 B 市停留 $0$ 天。 |\n| $2$ | 在第 $1$ 天从 A 市通过航线 $2$ 抵达城市 $2$，在城市 $2$ 停留 $2$ 天；在第 $3$ 天从城市 $2$ 通过航线 $3$ 抵达 B 市，在 B 市停留 $0$ 天。 |\n| $3$ | 在第 $1$ 天从 A 市通过航线 $3$ 抵达 B 市，在 B 市停留 $2$ 天。 |\n\n所有 $4$ 天的旅行方案如下：\n\n| 旅行方案 | 方案 |\n| :----------: | :----------: |\n| $1$ | 在第 $1$ 天从 A 市通过航线 $1$ 抵达城市 $1$，在城市 $1$ 停留 $2$ 天；在第 $3$ 天从城市 $1$ 通过航线 $3$ 抵达 B 市，在 B 市停留 $1$ 天。 |\n| $2$ | 在第 $1$ 天从 A 市通过航线 $1$ 抵达城市 $1$，在城市 $1$ 停留 $3$ 天；在第 $4$ 天从城市 $1$ 通过航线 $3$ 抵达 B 市，在 B 市停留 $0$ 天。 |\n| $3$ | 在第 $1$ 天从 A 市通过航线 $2$ 抵达城市 $2$，在城市 $2$ 停留 $2$ 天；在第 $3$ 天从城市 $2$ 通过航线 $3$ 抵达 B 市，在 B 市停留 $1$ 天。 |\n| $4$ | 在第 $1$ 天从 A 市通过航线 $2$ 抵达城市 $2$，在城市 $2$ 停留 $3$ 天；在第 $4$ 天从城市 $2$ 通过航线 $3$ 抵达 B 市，在 B 市停留 $0$ 天。 |\n| $5$ | 在第 $1$ 天从 A 市通过航线 $2$ 抵达城市 $2$，在城市 $2$ 停留 $2$ 天；在第 $3$ 天从城市 $2$ 通过航线 $1$ 抵达 B 市，在 B 市停留 $1$ 天。 |\n| $6$ | 在第 $1$ 天从 A 市通过航线 $3$ 抵达 B 市，在 B 市停留 $3$ 天。 |\n\n### 样例 #2 解释\n\n这组样例中除 A 市外所有城市的出发航线均直接到达 B 市。它满足子任务 $1,3,4$。\n\n### 样例 #3 解释\n\n这组样例中所有的航线均不限制目的地最少停留天数。它满足子任务 $2,3,4$。\n\n### 样例 #4 解释\n\n注意若方案数超过 $5\\times 10^8$，你只需输出 $5\\times 10^8+1$。它满足子任务 $2,3,4$。\n\n### 子任务\n\n对于 $100\\%$ 的数据，$N\\le 10^4,M\\le 400,H\\le 100$，其余输入均在此范围下合法。\n\n| 子任务 | 得分 | 数据范围及特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $20$ | 除 A 市外所有城市的出发航线均直接到达 B 市，$N,M,H\\le 10$ |\n| $2$ | $23$ | 所有的航线均不限制目的地最少停留天数，$N,M,H\\le 20$ |\n| $3$ | $26$ | $N,M,H\\le 100$ |\n| $4$ | $31$ | 无特殊限制 |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2018 Finals] Journey", "background": "译自 [NOISG 2018 Finals B. Journey](https://github.com/noisg/sg_noi_archive/tree/master/2018/tasks/journey)。", "description": "Kuno 要从 A 市到 B 市旅行，但在路途中他可能会停下来休息。\n\n允许他停留的共有 $N$ 个城市，编号为 $0$ 到 $N-1$，其中 $0$ 号城市表示 A 市，$N-1$ 号城市表示 B 市，编号越大的城市距离 B 市越近。\n\n为了让旅行保持一定的效率，中途停留需要满足以下限制：\n\n- 第 $i$ 次停留的城市必须比第 $i-1$ 次离 B 市**严格**更近。特别地，我们认为第 $0$ 次停留的城市是 A 市。\n- 从 A 市出发，直到从 B 市结束停留离开，整个过程不能超过 $M$ 天。换句话说，我们不允许你在 A 市停留，但允许你在 B 市停留。\n\nKuno 在城市之间的移动和停留基于城市之间的航线和城市中的酒店系统。每个城市 $i$ 都存在 $H$ 条用 $(j,k)$ 表示的航线，表示你可以通过这条航线从城市 $i$ 前往城市 $j$，但是一旦使用这条航线，就必须在城市 $j$ 中停留不少于 $k$ 天。**特别地，每个城市都有一条直接前往 B 市的航线**。\n\n注意可能存在完全相同或起点终点相同的航线，此时你需要把它们视为**不同航线**。你应当忽略远离 B 市的航线。\n\n在飞机中度过的时间忽略不计。\n\n到达一个城市即算作在该城市停留，即使停留了 $0$ 天。\n\n你的任务是，对每一个 $d\\in[1,m]$，帮助 Kuno 计数他从 A 市出发到从 B 市结束停留返回花费 $d$ 天的方案数。特别地，若方案数超过 $5\\times 10^8$，你只需输出 $5\\times 10^8+1$。\n\n两个旅行方案不同当且仅当以下三条任意一条成立：\n\n1. 一个旅行方案中需要在城市 $i$ 停留，而另一个不用。\n2. 存在一个城市 $i$，使得两个旅行方案离开该城市的时间不同。**特别地，也包括从 B 市离开的时间不同**。\n3. 两个行程都从城市 $i$ 到城市 $j$，但使用的航线不同。\n\n例如，对于两个均为 A 市到 C 市，再从 C 市到 D 市，最后从 D 市到 B 市的旅行方案，如果一个是在第二天离开 C 市，另一个是在第三天离开 C 市，那么它们就是不同的方案。此外，如果输入中存在两条同样从 D 市前往 B 市的航线，即便出发时间和到达时间相同，也是不同的方案。\n\n如你仍无法完全理解题意，请阅读**样例解释**。", "inputFormat": "第一行包含三个整数 $N,M,H$，表示城市数量，旅行天数上限，和每个城市的航线数量。\n\n接下来的输入包含 $N-1$ 行，第 $i$ 行包含 $2H$ 个用空格分割的整数，每两个为一组 $(j,k)$，描述从城市 $i-1$ 出发的 $H$ 条航线。\n\n", "outputFormat": "输出 $m$ 个用空格隔开的整数，依次表示从 A 市出发直至从 B 市结束停留离开共花费恰好 $1,2,3,\\cdots ,m$ 天的旅行方案数。注意如果方案数超过 $5\\times 10^8$，则应输出 $5\\times 10^8+1$。", "hint": "### 样例 #1 解释\n\n样例 #1 输入描述了一个具有 $4$ 座城市，每个城市有 $3$ 条不同的航线出发的情况：\n\n| 出发城市 | 航线 $1$ 终点 | $\\text{Min.}$ | 航线 $2$ 终点 | $\\text{Min.}$ | 航线 $3$ 终点 | $\\text{Min.}$ |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| A 市 | 城市 $1$ | $2$ 天 | 城市 $2$ | $2$ 天 | B 市 | $0$ 天 |\n| 城市 $1$ | 城市 $2$ | $2$ 天 | 城市 $2$ | $3$ 天 | B 市 | $0$ 天 |\n| 城市 $2$ | B 市 | $1$ 天 | B 市 | $3$ 天 | B 市 | $0$ 天 |\n\n为了方便表格描述，我们用 $\\text{Min.}$ 表示了每条航线对目的地最少停留天数的要求。\n\n所有 $1$ 天的旅行方案如下；\n\n| 旅行方案 | 方案 |\n| :----------: | :----------: |\n| $1$ | 在第 $1$ 天从 A 市通过航线 $3$ 抵达 B 市，在 B 市停留 $0$ 天。 |\n\n所有 $2$ 天的旅行方案如下：\n\n| 旅行方案 | 方案 |\n| :----------: | :----------: |\n| $1$ | 在第 $1$ 天从 A 市通过航线 $3$ 抵达 B 市，在 B 市停留 $1$ 天。 |\n\n所有 $3$ 天的旅行方案如下：\n\n| 旅行方案 | 方案 |\n| :----------: | :----------: |\n| $1$ | 在第 $1$ 天从 A 市通过航线 $1$ 抵达城市 $1$，在城市 $1$ 停留 $2$ 天；在第 $3$ 天从城市 $1$ 通过航线 $3$ 抵达 B 市，在 B 市停留 $0$ 天。 |\n| $2$ | 在第 $1$ 天从 A 市通过航线 $2$ 抵达城市 $2$，在城市 $2$ 停留 $2$ 天；在第 $3$ 天从城市 $2$ 通过航线 $3$ 抵达 B 市，在 B 市停留 $0$ 天。 |\n| $3$ | 在第 $1$ 天从 A 市通过航线 $3$ 抵达 B 市，在 B 市停留 $2$ 天。 |\n\n所有 $4$ 天的旅行方案如下：\n\n| 旅行方案 | 方案 |\n| :----------: | :----------: |\n| $1$ | 在第 $1$ 天从 A 市通过航线 $1$ 抵达城市 $1$，在城市 $1$ 停留 $2$ 天；在第 $3$ 天从城市 $1$ 通过航线 $3$ 抵达 B 市，在 B 市停留 $1$ 天。 |\n| $2$ | 在第 $1$ 天从 A 市通过航线 $1$ 抵达城市 $1$，在城市 $1$ 停留 $3$ 天；在第 $4$ 天从城市 $1$ 通过航线 $3$ 抵达 B 市，在 B 市停留 $0$ 天。 |\n| $3$ | 在第 $1$ 天从 A 市通过航线 $2$ 抵达城市 $2$，在城市 $2$ 停留 $2$ 天；在第 $3$ 天从城市 $2$ 通过航线 $3$ 抵达 B 市，在 B 市停留 $1$ 天。 |\n| $4$ | 在第 $1$ 天从 A 市通过航线 $2$ 抵达城市 $2$，在城市 $2$ 停留 $3$ 天；在第 $4$ 天从城市 $2$ 通过航线 $3$ 抵达 B 市，在 B 市停留 $0$ 天。 |\n| $5$ | 在第 $1$ 天从 A 市通过航线 $2$ 抵达城市 $2$，在城市 $2$ 停留 $2$ 天；在第 $3$ 天从城市 $2$ 通过航线 $1$ 抵达 B 市，在 B 市停留 $1$ 天。 |\n| $6$ | 在第 $1$ 天从 A 市通过航线 $3$ 抵达 B 市，在 B 市停留 $3$ 天。 |\n\n### 样例 #2 解释\n\n这组样例中除 A 市外所有城市的出发航线均直接到达 B 市。它满足子任务 $1,3,4$。\n\n### 样例 #3 解释\n\n这组样例中所有的航线均不限制目的地最少停留天数。它满足子任务 $2,3,4$。\n\n### 样例 #4 解释\n\n注意若方案数超过 $5\\times 10^8$，你只需输出 $5\\times 10^8+1$。它满足子任务 $2,3,4$。\n\n### 子任务\n\n对于 $100\\%$ 的数据，$N\\le 10^4,M\\le 400,H\\le 100$，其余输入均在此范围下合法。\n\n| 子任务 | 得分 | 数据范围及特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $20$ | 除 A 市外所有城市的出发航线均直接到达 B 市，$N,M,H\\le 10$ |\n| $2$ | $23$ | 所有的航线均不限制目的地最少停留天数，$N,M,H\\le 20$ |\n| $3$ | $26$ | $N,M,H\\le 100$ |\n| $4$ | $31$ | 无特殊限制 |\n", "locale": "zh-CN"}}}
{"pid": "P11596", "type": "P", "difficulty": 3, "samples": [["2\n1 1\n2 1", "2"], ["2\n1 0\n2 1", "1"], ["4\n1 1\n3 2\n4 3\n5 1", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "O2优化", "NOISG（新加坡）"], "title": "[NOISG 2018 Finals] Lightning Rod", "background": "译自 [NOISG 2018 Finals C. Lightning Rod](https://github.com/noisg/sg_noi_archive/tree/master/2018/tasks/lightningrod)。", "description": "新加坡的城市天际线可以看成一个平面直角坐标系，第 $i$ 栋大楼的顶端是点 $(X_i,Y_i)$。\n\n一根避雷针可以安装在大楼的顶端上。它的保护区域为从该大楼顶端向左下方和右下方作两条与坐标轴呈 $45^\\circ$ 的射线所产生的 $\\frac{1}{4}$ 平面。所有顶端在该保护区域内或落在保护区域边缘上的大楼都可以被保护到。\n\n换句话说，若避雷针安装在大楼 $i$ 上，则所有且仅所有满足 $|X_i-X_j|\\le Y_i-Y_j$ 的大楼 $j$ 可以被该避雷针保护到。\n\n你的任务是找出最少的安装避雷针数量，使得所有大楼都可以被至少一根避雷针保护到。", "inputFormat": "第一行一个正整数 $N$，表示大楼的总数。\n\n接下来 $N$ 行每行两个正整数 $X_i,Y_i$，表示第 $i$ 栋大楼的顶端是 $(X_i,Y_i)$。**保证 $X_i$ 按照输入顺序单调不递减**。\n\n注意：本题输入量较大，请使用较快的输入方式。我们在下发文件中下发了三种语言实现的快速读入模板。", "outputFormat": "一行一个整数，表示最少的安装避雷针数量。", "hint": "### 样例 #1 解释\n\n所有大楼都需要安装避雷针。\n\n这组样例满足所有子任务。\n\n### 样例 #2 解释\n\n在大楼 $2$ 的顶端安装避雷针。\n\n这组样例满足子任务 $2$ 至 $7$。\n\n### 样例 #3 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/glq0s3hc.png)\n\n如图所示，在大楼 $1$ 和大楼 $3$ 的顶端安装避雷针。\n\n这组样例满足子任务 $3,4,5,7$。\n\n### 子任务\n\n对于 $100\\%$ 的数据，$2\\le N\\le 10^7$，$0\\le X_i,Y_i\\le 10^9$。\n\n| 子任务 | 得分 | $N$ | $X_i,Y_i$ |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $4$ | 无特殊限制 | $Y_i=1$ |\n| $2$ | $7$ | $=2$ | 无特殊限制 |\n| $3$ | $12$ | $\\le20$ | 无特殊限制 |\n| $4$ | $21$ | $\\le 2\\times 10^3$ | 无特殊限制 |\n| $5$ | $26$ | $\\le 2\\times 10^5$ | 无特殊限制 |\n| $6$ | $10$ | 无特殊限制 | $X_i=i,Y_i\\le 1$ |\n| $7$ | $20$ | 无特殊限制 | 无特殊限制 |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2018 Finals] Lightning Rod", "background": "译自 [NOISG 2018 Finals C. Lightning Rod](https://github.com/noisg/sg_noi_archive/tree/master/2018/tasks/lightningrod)。", "description": "新加坡的城市天际线可以看成一个平面直角坐标系，第 $i$ 栋大楼的顶端是点 $(X_i,Y_i)$。\n\n一根避雷针可以安装在大楼的顶端上。它的保护区域为从该大楼顶端向左下方和右下方作两条与坐标轴呈 $45^\\circ$ 的射线所产生的 $\\frac{1}{4}$ 平面。所有顶端在该保护区域内或落在保护区域边缘上的大楼都可以被保护到。\n\n换句话说，若避雷针安装在大楼 $i$ 上，则所有且仅所有满足 $|X_i-X_j|\\le Y_i-Y_j$ 的大楼 $j$ 可以被该避雷针保护到。\n\n你的任务是找出最少的安装避雷针数量，使得所有大楼都可以被至少一根避雷针保护到。", "inputFormat": "第一行一个正整数 $N$，表示大楼的总数。\n\n接下来 $N$ 行每行两个正整数 $X_i,Y_i$，表示第 $i$ 栋大楼的顶端是 $(X_i,Y_i)$。**保证 $X_i$ 按照输入顺序单调不递减**。\n\n注意：本题输入量较大，请使用较快的输入方式。我们在下发文件中下发了三种语言实现的快速读入模板。", "outputFormat": "一行一个整数，表示最少的安装避雷针数量。", "hint": "### 样例 #1 解释\n\n所有大楼都需要安装避雷针。\n\n这组样例满足所有子任务。\n\n### 样例 #2 解释\n\n在大楼 $2$ 的顶端安装避雷针。\n\n这组样例满足子任务 $2$ 至 $7$。\n\n### 样例 #3 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/glq0s3hc.png)\n\n如图所示，在大楼 $1$ 和大楼 $3$ 的顶端安装避雷针。\n\n这组样例满足子任务 $3,4,5,7$。\n\n### 子任务\n\n对于 $100\\%$ 的数据，$2\\le N\\le 10^7$，$0\\le X_i,Y_i\\le 10^9$。\n\n| 子任务 | 得分 | $N$ | $X_i,Y_i$ |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $4$ | 无特殊限制 | $Y_i=1$ |\n| $2$ | $7$ | $=2$ | 无特殊限制 |\n| $3$ | $12$ | $\\le20$ | 无特殊限制 |\n| $4$ | $21$ | $\\le 2\\times 10^3$ | 无特殊限制 |\n| $5$ | $26$ | $\\le 2\\times 10^5$ | 无特殊限制 |\n| $6$ | $10$ | 无特殊限制 | $X_i=i,Y_i\\le 1$ |\n| $7$ | $20$ | 无特殊限制 | 无特殊限制 |\n", "locale": "zh-CN"}}}
{"pid": "P11597", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "二分", "交互题", "Special Judge", "O2优化", "树链剖分", "NOISG（新加坡）"], "title": "[NOISG 2018 Finals] City Mapping【缺样例】", "background": "译自 [NOISG 2018 Finals D. City Mapping](https://github.com/noisg/sg_noi_archive/tree/master/2018/tasks/citymapping)。\n\n----------------\n\n当你在洛谷提交本题时，需要注意：\n\n- 本题仅支持 C++ 系列语言。\n- 你的代码中不应该包含头文件 `citymapping.h`。\n- 你的代码中应当有如下两行函数声明：\n\t```cpp\n\tlong long get_distance(int X, int Y);\n\tvoid find_roads(int N, int Q, int A[], int B[], int W[]);\n\t```\n    \n如遇评测问题，请联系搬题人。", "description": "**这是一道交互题。**\n\nSilvermill 市是一座有 $N$ 个路口和 $N-1$ 条道路的城市。其中道路的编号为 $0$ 到 $N-2$。\n\n第 $i$ 条道路双向连接了 $(A_i,B_i)$ 两个路口，从任意方向通过这条道路都需要花费 $W_i$ 分钟。保证任意两个路口之间都能通过道路互相到达。\n\n为了避免交通堵塞，Silvermill 市的**每个路口连接的道路不会超过 $3$ 条**。\n\n你的任务是画出 Silvermill 市的地图，也就是找出所有 $N-1$ 条道路的 $(A_i,B_i,W_i)$。\n\n为了达到这个目的，你可以询问市长至多 $Q$ 次从任意一个路口 $X$ 到任意一个路口 $Y$ 最少需要多少分钟。\n\n### 实现细节\n\n在本题中，**你不需要，也不应该实现主函数**。\n\n你需要实现如下函数：\n\n```cpp\nvoid find_roads(int N, int Q, int A[], int B[], int W[])\n```\n\n该函数包含两个输入参数和三个输出参数，将在评测时被运行恰好一次。输入参数为 $N,Q$，分别表示路口的数量和最大询问次数；输出参数为 $A,B,W$，你需要确定城市中的 $N-1$ 条道路，按题意中的含义以数组 $A,B,W$ 的形式返回。返回道路的顺序可以是任意的，同一道路端点的顺序也可以是任意的。\n\n注意数组的下标是从 $0$ 开始的。\n\n你可以调用下面的函数来完成任务：\n\n```cpp\nlong long get_distance(int X, int Y)\n```\n\n该函数将返回一个整数，表示从路口 $X$ 到路口 $Y$ 最少需要多少分钟。如果你调用此函数超过 $Q$ 次，或提供无效的路口编号作为参数，程序将立刻终止，你将得到 Wrong Answer 的评测状态。", "inputFormat": "示例测试程序如下方式读入数据：\n\n第一行三个整数 $N,Q,S$，分别表示路口的数量、最大询问次数和子任务编号。\n\n之后是 $N-1$ 行，每行三个整数 $(A_i,B_i,W_i)$，描述一条道路。", "outputFormat": "示例测试程序可能会产生的输出如下：\n\n- `Wrong Input Format`，意味着对示例测试程序的输入格式有误。\n- `Wrong Answer: Reported list of edges differ from actual.`，意味着你确定的道路与实际情况不符。\n- `Wrong Answer: get_distance() arguments out of range.`，意味着你在询问时提供了无效的路口编号作为参数。\n- `Wrong Answer: Too many calls to get_distance().`，意味着你超出了最大询问次数限制。\n- 包含两行信息，分别是 `Score: s%` 和 `Correct: x out of y queries used.`，意味着你获得了该测试点 $s\\%$ 的分数，最大询问次数为 $y$ 次，你使用了其中的 $x$ 次。", "hint": "### 调用示例\n\n我们考虑如下的城市地图，展示一种可能的函数调用过程。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/m7bz8mwi.png)\n\n假设此时最大询问次数 $Q=5\\times 10^5$。\n\n你的函数将这样被调用恰好一次：\n\n```cpp\nfind_roads(5, 500000, A, B, W);\n```\n\n其中 $A,B,W$ 是定义在测试程序中的数组。\n\n一种可能的交互过程如下：\n\n- `get_distance(5, 4) = 10`：`get_distance` 函数返回从路口 $5$ 到达路口 $4$ 的最少分钟数。路线 $5\\to 3\\to 4$ 是最短的，需要 $10$ 分钟。\n- `get_distance(2, 4) = 1`：`get_distance` 函数返回了从路口 $2$ 到达路口 $4$ 的最少分钟数。直接从 $2$ 走到 $4$ 是最短的，需要 $1$ 分钟。\n- `get_distance(1, 3) = 15`：`get_distance` 函数返回了从路口 $1$ 到达路口 $3$ 的最少分钟数。路线 $1\\to 4\\to 3$ 是最短的，需要 $15$ 分钟。\n- `get_distance(1, 2) = 9`：`get_distance` 函数返回了从路口 $1$ 到达路口 $2$ 的最少分钟数。路线 $1\\to 4\\to 2$ 是最短的，需要 $9$ 分钟。\n\n此时，我们假设你的 `find_roads` 函数认为自己已经掌握了足够的信息，可以推导出正确的地图，所以将 $A,B,W$ 数组分别赋值为 $A=[3,4,4,5],B=[4,1,2,3],W=[7,8,1,3]$，然后终止。\n\n这只是一种可能的答案，因为返回道路的顺序可以是任意的，同一道路端点的顺序也可以是任意的。\n\n### 子任务\n\n对于 $100\\%$ 的数据，$2\\le N\\le1000$，$1\\le A_i,B_i\\le N$，$1\\le W_i\\le 10^9$。\n\n| 子任务 | 得分 | $Q$ | 特殊性质及备注 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $9$ | $=5\\times 10^5$ | $W_i=1$ |\n| $2$ | $16$ | $=5\\times 10^5$ | 无特殊限制 |\n| $3$ | $13$ | $=12000$ | 每个路口最多连接两条道路，且 $W_i=1$ |\n| $4$ | $19$ | $=12000$ | 每个路口最多连接两条道路 |\n| $5$ | $43$ | $=25000$ | 无特殊限制，但有特殊的计分规则（请参阅**计分细则**） |\n\n### 计分细则\n\n子任务 $5$ 适用于以下的计分规则。你的得分依赖于你实现的函数询问的次数 $q$。\n\n- 如果 $q>25000$，你将获得 $0$ 分。\n- 如果 $12000<q\\le 25000$，你将获得 $10-10\\times \\frac{q-12000}{13000}$ 分。\n- 如果 $6500<q\\le 12000$，你将获得 $40-30\\times \\frac{q-6500}{5500}$ 分。\n- 如果 $q\\le 6500$，你将获得 $43$ 分。\n\n### 本地测试方式\n\n我们在附件中下发了示例测试程序 `grader.cpp`，头文件 `citymapping.h`，你所需完成的代码的示例 `citymapping.cpp`，以及编译文件 `compile.sh`。\n\n将这些文件置于同一文件夹下，使用 `compile.sh` 编译并运行生成的可执行文件，即可进行本地测试。\n\n下发的示例测试程序与提交后使用的测试程序有所不同。\n\n注意提交到洛谷上时有特殊的要求。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2018 Finals] City Mapping【缺样例】", "background": "译自 [NOISG 2018 Finals D. City Mapping](https://github.com/noisg/sg_noi_archive/tree/master/2018/tasks/citymapping)。\n\n----------------\n\n当你在洛谷提交本题时，需要注意：\n\n- 本题仅支持 C++ 系列语言。\n- 你的代码中不应该包含头文件 `citymapping.h`。\n- 你的代码中应当有如下两行函数声明：\n\t```cpp\n\tlong long get_distance(int X, int Y);\n\tvoid find_roads(int N, int Q, int A[], int B[], int W[]);\n\t```\n    \n如遇评测问题，请联系搬题人。", "description": "**这是一道交互题。**\n\nSilvermill 市是一座有 $N$ 个路口和 $N-1$ 条道路的城市。其中道路的编号为 $0$ 到 $N-2$。\n\n第 $i$ 条道路双向连接了 $(A_i,B_i)$ 两个路口，从任意方向通过这条道路都需要花费 $W_i$ 分钟。保证任意两个路口之间都能通过道路互相到达。\n\n为了避免交通堵塞，Silvermill 市的**每个路口连接的道路不会超过 $3$ 条**。\n\n你的任务是画出 Silvermill 市的地图，也就是找出所有 $N-1$ 条道路的 $(A_i,B_i,W_i)$。\n\n为了达到这个目的，你可以询问市长至多 $Q$ 次从任意一个路口 $X$ 到任意一个路口 $Y$ 最少需要多少分钟。\n\n### 实现细节\n\n在本题中，**你不需要，也不应该实现主函数**。\n\n你需要实现如下函数：\n\n```cpp\nvoid find_roads(int N, int Q, int A[], int B[], int W[])\n```\n\n该函数包含两个输入参数和三个输出参数，将在评测时被运行恰好一次。输入参数为 $N,Q$，分别表示路口的数量和最大询问次数；输出参数为 $A,B,W$，你需要确定城市中的 $N-1$ 条道路，按题意中的含义以数组 $A,B,W$ 的形式返回。返回道路的顺序可以是任意的，同一道路端点的顺序也可以是任意的。\n\n注意数组的下标是从 $0$ 开始的。\n\n你可以调用下面的函数来完成任务：\n\n```cpp\nlong long get_distance(int X, int Y)\n```\n\n该函数将返回一个整数，表示从路口 $X$ 到路口 $Y$ 最少需要多少分钟。如果你调用此函数超过 $Q$ 次，或提供无效的路口编号作为参数，程序将立刻终止，你将得到 Wrong Answer 的评测状态。", "inputFormat": "示例测试程序如下方式读入数据：\n\n第一行三个整数 $N,Q,S$，分别表示路口的数量、最大询问次数和子任务编号。\n\n之后是 $N-1$ 行，每行三个整数 $(A_i,B_i,W_i)$，描述一条道路。", "outputFormat": "示例测试程序可能会产生的输出如下：\n\n- `Wrong Input Format`，意味着对示例测试程序的输入格式有误。\n- `Wrong Answer: Reported list of edges differ from actual.`，意味着你确定的道路与实际情况不符。\n- `Wrong Answer: get_distance() arguments out of range.`，意味着你在询问时提供了无效的路口编号作为参数。\n- `Wrong Answer: Too many calls to get_distance().`，意味着你超出了最大询问次数限制。\n- 包含两行信息，分别是 `Score: s%` 和 `Correct: x out of y queries used.`，意味着你获得了该测试点 $s\\%$ 的分数，最大询问次数为 $y$ 次，你使用了其中的 $x$ 次。", "hint": "### 调用示例\n\n我们考虑如下的城市地图，展示一种可能的函数调用过程。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/m7bz8mwi.png)\n\n假设此时最大询问次数 $Q=5\\times 10^5$。\n\n你的函数将这样被调用恰好一次：\n\n```cpp\nfind_roads(5, 500000, A, B, W);\n```\n\n其中 $A,B,W$ 是定义在测试程序中的数组。\n\n一种可能的交互过程如下：\n\n- `get_distance(5, 4) = 10`：`get_distance` 函数返回从路口 $5$ 到达路口 $4$ 的最少分钟数。路线 $5\\to 3\\to 4$ 是最短的，需要 $10$ 分钟。\n- `get_distance(2, 4) = 1`：`get_distance` 函数返回了从路口 $2$ 到达路口 $4$ 的最少分钟数。直接从 $2$ 走到 $4$ 是最短的，需要 $1$ 分钟。\n- `get_distance(1, 3) = 15`：`get_distance` 函数返回了从路口 $1$ 到达路口 $3$ 的最少分钟数。路线 $1\\to 4\\to 3$ 是最短的，需要 $15$ 分钟。\n- `get_distance(1, 2) = 9`：`get_distance` 函数返回了从路口 $1$ 到达路口 $2$ 的最少分钟数。路线 $1\\to 4\\to 2$ 是最短的，需要 $9$ 分钟。\n\n此时，我们假设你的 `find_roads` 函数认为自己已经掌握了足够的信息，可以推导出正确的地图，所以将 $A,B,W$ 数组分别赋值为 $A=[3,4,4,5],B=[4,1,2,3],W=[7,8,1,3]$，然后终止。\n\n这只是一种可能的答案，因为返回道路的顺序可以是任意的，同一道路端点的顺序也可以是任意的。\n\n### 子任务\n\n对于 $100\\%$ 的数据，$2\\le N\\le1000$，$1\\le A_i,B_i\\le N$，$1\\le W_i\\le 10^9$。\n\n| 子任务 | 得分 | $Q$ | 特殊性质及备注 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $9$ | $=5\\times 10^5$ | $W_i=1$ |\n| $2$ | $16$ | $=5\\times 10^5$ | 无特殊限制 |\n| $3$ | $13$ | $=12000$ | 每个路口最多连接两条道路，且 $W_i=1$ |\n| $4$ | $19$ | $=12000$ | 每个路口最多连接两条道路 |\n| $5$ | $43$ | $=25000$ | 无特殊限制，但有特殊的计分规则（请参阅**计分细则**） |\n\n### 计分细则\n\n子任务 $5$ 适用于以下的计分规则。你的得分依赖于你实现的函数询问的次数 $q$。\n\n- 如果 $q>25000$，你将获得 $0$ 分。\n- 如果 $12000<q\\le 25000$，你将获得 $10-10\\times \\frac{q-12000}{13000}$ 分。\n- 如果 $6500<q\\le 12000$，你将获得 $40-30\\times \\frac{q-6500}{5500}$ 分。\n- 如果 $q\\le 6500$，你将获得 $43$ 分。\n\n### 本地测试方式\n\n我们在附件中下发了示例测试程序 `grader.cpp`，头文件 `citymapping.h`，你所需完成的代码的示例 `citymapping.cpp`，以及编译文件 `compile.sh`。\n\n将这些文件置于同一文件夹下，使用 `compile.sh` 编译并运行生成的可执行文件，即可进行本地测试。\n\n下发的示例测试程序与提交后使用的测试程序有所不同。\n\n注意提交到洛谷上时有特殊的要求。", "locale": "zh-CN"}}}
{"pid": "P11598", "type": "P", "difficulty": 6, "samples": [["6 1\n2 10 0 2 4 3", "10"], ["6 3\n2 10 2 6 4 3", "6"], ["4 1\n1 4 1 4", "4"], ["10 1\n10 9 8 7 6 5 4 3 2 1", "0"], ["3 0\n1 1 3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2018", "动态规划优化", "NOISG（新加坡）", "斜率维护技巧 slope trick"], "title": "[NOISG 2018 Finals] Safety", "background": "译自 [NOISG 2018 Finals E. Safety](https://github.com/noisg/sg_noi_archive/tree/master/2018/tasks/safety)。", "description": "小老鼠 Squeaky 最近开始欣赏视觉艺术，并尝试创作自己的艺术作品，在城里最负盛名的艺术节上展出！\n\n他的作品由若干发光柱组成，其中每个发光柱又都是由发光立方体堆砌而成的。\n\n具体来说，他的作品是排成一条直线的 $N$ 个发光柱，从左到右编号为 $1$ 到 $N$。其中第 $i$ 个发光柱的高度为 $S_i$，意味着它由 $S_i$ 个发光立方体堆砌而成。\n\n例如下图是 $N=20$ 时一种可能的作品：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qp61p4fu.png)\n\n然而，观众撞到不安全的展品将造成灾难性的后果。所以，安全委员会要求 Squeaky 保证作品的安全性。具体来说，作品安全当且仅当任意两个相邻发光柱的高度差不超过 $H$，即 $|S_i-S_{i+1}|\\le H,\\forall i\\in[1,N)$。\n\nSqueaky 的作品可能是不安全的，为了确保正常展出，他希望通过修改作品使其安全。\n\n他可以进行的修改只有两种：\n\n- 在发光柱 $k$ 上添加一个发光立方体，即 $S_k\\gets S_k+1$。\n- 从还有至少一个发光立方体的发光柱 $k$ 上移除一个发光立方体，即 $S_k\\gets S_k-1$。\n\n注意，即使一个发光柱没有发光立方体，我们也认为它依然存在于原来的位置。\n\n你的任务是帮助 Squeaky 确定至少需要多少次修改他的作品才能安全。", "inputFormat": "第一行包含两个整数 $N,H$，含义如题所述。\n\n接下来一行 $N$ 个整数，第 $i$ 个表示 $S_i$，即发光柱 $i$ 的初始高度。", "outputFormat": "一行一个整数，Squeaky 为了使他的作品安全需要的最少修改次数。", "hint": "### 样例 #1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/o2mb9wvh.png)\n\n如图所示，我们删去红色立方体，添加黄色立方体，通过修改 $10$ 次使 Squeaky 的作品安全：任意相邻的两个发光柱高度差都不超过 $H=1$。\n\n可以证明，不存在少于 $10$ 步的修改方法。\n\n这组样例满足子任务 $3$ 和子任务 $5$ 至 $9$。\n\n### 样例 #2 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9i4cjmny.png)\n\n如图所示，我们删去红色立方体，添加黄色立方体，通过修改 $6$ 次使 Squeaky 的作品安全。可以证明，不存在少于 $6$ 步的修改方法。\n\n这组样例满足子任务 $5$ 至 $9$。\n\n### 样例 #3 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/v83yezxt.png)\n\n如图所示，我们删去红色立方体，添加黄色立方体，通过修改 $4$ 次使 Squeaky 的作品安全。可以证明，不存在少于 $4$ 步的修改方法。\n\n这组样例满足子任务 $1$ 至 $3$ 和子任务 $5$ 至 $9$。\n\n### 样例 #4 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/narncyxs.png)\n\nSqueaky 的作品本来就是安全的，所以不需要进行修改。\n\n这组样例满足子任务 $3$ 和子任务 $5$ 至 $9$。\n\n### 样例 #5 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fo23a2wx.png)\n\n如图所示，我们删去红色立方体，通过修改 $2$ 次使 Squeaky 的作品安全。可以证明，不存在少于 $2$ 步的修改方法。\n\n这组样例满足所有子任务。\n\n### 子任务\n\n对于 $100\\%$ 的数据，$1\\le N\\le 2\\times 10^5$，$0\\le H\\le 10^9$，$0\\le S_i\\le 10^9$。\n\n| 子任务 | 得分 | 数据范围及特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $3$ | $N\\le 10$，$S_i\\le 4$ |\n| $2$ | $4$ | $N\\le 14$，$H\\le 1$，$S_i\\le 4$ |\n| $3$ | $9$ | $N\\le10$，$H\\le 2$ |\n| $4$ | $5$ | $H=0$ |\n| $5$ | $6$ | $N\\le 500$，$S_i\\le 400$ |\n| $6$ | $11$ | $N\\le 500$，$S_i\\le 5\\times 10^3$ |\n| $7$ | $11$ | $N\\le 5\\times 10^3$，$S_i\\le 5\\times 10^3$ |\n| $8$ | $22$ | $N\\le 5\\times 10^3$ |\n| $9$ | $29$ | 无特殊限制 |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2018 Finals] Safety", "background": "译自 [NOISG 2018 Finals E. Safety](https://github.com/noisg/sg_noi_archive/tree/master/2018/tasks/safety)。", "description": "小老鼠 Squeaky 最近开始欣赏视觉艺术，并尝试创作自己的艺术作品，在城里最负盛名的艺术节上展出！\n\n他的作品由若干发光柱组成，其中每个发光柱又都是由发光立方体堆砌而成的。\n\n具体来说，他的作品是排成一条直线的 $N$ 个发光柱，从左到右编号为 $1$ 到 $N$。其中第 $i$ 个发光柱的高度为 $S_i$，意味着它由 $S_i$ 个发光立方体堆砌而成。\n\n例如下图是 $N=20$ 时一种可能的作品：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qp61p4fu.png)\n\n然而，观众撞到不安全的展品将造成灾难性的后果。所以，安全委员会要求 Squeaky 保证作品的安全性。具体来说，作品安全当且仅当任意两个相邻发光柱的高度差不超过 $H$，即 $|S_i-S_{i+1}|\\le H,\\forall i\\in[1,N)$。\n\nSqueaky 的作品可能是不安全的，为了确保正常展出，他希望通过修改作品使其安全。\n\n他可以进行的修改只有两种：\n\n- 在发光柱 $k$ 上添加一个发光立方体，即 $S_k\\gets S_k+1$。\n- 从还有至少一个发光立方体的发光柱 $k$ 上移除一个发光立方体，即 $S_k\\gets S_k-1$。\n\n注意，即使一个发光柱没有发光立方体，我们也认为它依然存在于原来的位置。\n\n你的任务是帮助 Squeaky 确定至少需要多少次修改他的作品才能安全。", "inputFormat": "第一行包含两个整数 $N,H$，含义如题所述。\n\n接下来一行 $N$ 个整数，第 $i$ 个表示 $S_i$，即发光柱 $i$ 的初始高度。", "outputFormat": "一行一个整数，Squeaky 为了使他的作品安全需要的最少修改次数。", "hint": "### 样例 #1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/o2mb9wvh.png)\n\n如图所示，我们删去红色立方体，添加黄色立方体，通过修改 $10$ 次使 Squeaky 的作品安全：任意相邻的两个发光柱高度差都不超过 $H=1$。\n\n可以证明，不存在少于 $10$ 步的修改方法。\n\n这组样例满足子任务 $3$ 和子任务 $5$ 至 $9$。\n\n### 样例 #2 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9i4cjmny.png)\n\n如图所示，我们删去红色立方体，添加黄色立方体，通过修改 $6$ 次使 Squeaky 的作品安全。可以证明，不存在少于 $6$ 步的修改方法。\n\n这组样例满足子任务 $5$ 至 $9$。\n\n### 样例 #3 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/v83yezxt.png)\n\n如图所示，我们删去红色立方体，添加黄色立方体，通过修改 $4$ 次使 Squeaky 的作品安全。可以证明，不存在少于 $4$ 步的修改方法。\n\n这组样例满足子任务 $1$ 至 $3$ 和子任务 $5$ 至 $9$。\n\n### 样例 #4 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/narncyxs.png)\n\nSqueaky 的作品本来就是安全的，所以不需要进行修改。\n\n这组样例满足子任务 $3$ 和子任务 $5$ 至 $9$。\n\n### 样例 #5 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fo23a2wx.png)\n\n如图所示，我们删去红色立方体，通过修改 $2$ 次使 Squeaky 的作品安全。可以证明，不存在少于 $2$ 步的修改方法。\n\n这组样例满足所有子任务。\n\n### 子任务\n\n对于 $100\\%$ 的数据，$1\\le N\\le 2\\times 10^5$，$0\\le H\\le 10^9$，$0\\le S_i\\le 10^9$。\n\n| 子任务 | 得分 | 数据范围及特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $3$ | $N\\le 10$，$S_i\\le 4$ |\n| $2$ | $4$ | $N\\le 14$，$H\\le 1$，$S_i\\le 4$ |\n| $3$ | $9$ | $N\\le10$，$H\\le 2$ |\n| $4$ | $5$ | $H=0$ |\n| $5$ | $6$ | $N\\le 500$，$S_i\\le 400$ |\n| $6$ | $11$ | $N\\le 500$，$S_i\\le 5\\times 10^3$ |\n| $7$ | $11$ | $N\\le 5\\times 10^3$，$S_i\\le 5\\times 10^3$ |\n| $8$ | $22$ | $N\\le 5\\times 10^3$ |\n| $9$ | $29$ | 无特殊限制 |\n", "locale": "zh-CN"}}}
{"pid": "P11599", "type": "P", "difficulty": 1, "samples": [["10 3 4", "4"], ["10 3 2", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": [], "title": "『Fwb』神话の传播", "background": "", "description": "在遥远的北方，生活着一个叫夸父的巨人。在冰天雪地的北方，冬季的夜晚寒冷而漫长。一天晚上，夸父被冻得睡不着觉，他突发奇想：要是可以追上太阳，让太阳在人间多停留一段时间，那么人间就暖和多了。为了这个想法，他兴奋得一夜未眠。\n\n于是他设定了一个计划：如果现在与太阳之间的距离是 $n$，他一天追太阳 $x$ 的距离，那么需要 $\\lceil \\frac{n}{x}\\rceil$ 天就可以追上太阳。其中，$\\lceil a\\rceil$ 的意思是向上取整。\n\n夸父的体力值为 $k$，每追 $1$ 天，就会消耗 $1$ 的体力值。只有在 $k>0$ 时，夸父才可以完成这一天的路程。在追太阳的过程中，夸父也可以选择停下来休息，花费 $1$ 天的时间补充**原始** $k$ 的体力值。现在想知道，夸父最少要多少天，才能追上太阳。", "inputFormat": "输入共一行，包含三个正整数 $n,x,k$，分别表示与太阳的距离、一天可以前进的距离、夸父的体力值。", "outputFormat": "输出共一行，包含一个正整数，代表追上太阳所需的天数。", "hint": "#### 【样例 2 解释】\n\n- 第一天休息一天，剩余体力值为 $4$。\n- 第二天追 $3$ 的距离，离太阳距离为 $7$，剩余体力值为 $3$。\n- 第三天追 $3$ 的距离，离太阳距离为 $4$，剩余体力值为 $2$。\n- 第四天追 $3$ 的距离，离太阳距离为 $1$，剩余体力值为 $1$。\n- 第五天追 $3$ 的距离，追上了太阳，剩余体力值为 $0$。\n\n#### 【数据范围】\n\n对于 $10\\%$ 的数据，$n=x$。\n\n对于 $40\\%$ 的数据，$k>\\lceil\\frac{n}{x}\\rceil$。\n\n对于 $100\\%$ 的数据，$1\\le n,x,k\\le10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『Fwb』神话の传播", "background": "", "description": "在遥远的北方，生活着一个叫夸父的巨人。在冰天雪地的北方，冬季的夜晚寒冷而漫长。一天晚上，夸父被冻得睡不着觉，他突发奇想：要是可以追上太阳，让太阳在人间多停留一段时间，那么人间就暖和多了。为了这个想法，他兴奋得一夜未眠。\n\n于是他设定了一个计划：如果现在与太阳之间的距离是 $n$，他一天追太阳 $x$ 的距离，那么需要 $\\lceil \\frac{n}{x}\\rceil$ 天就可以追上太阳。其中，$\\lceil a\\rceil$ 的意思是向上取整。\n\n夸父的体力值为 $k$，每追 $1$ 天，就会消耗 $1$ 的体力值。只有在 $k>0$ 时，夸父才可以完成这一天的路程。在追太阳的过程中，夸父也可以选择停下来休息，花费 $1$ 天的时间补充**原始** $k$ 的体力值。现在想知道，夸父最少要多少天，才能追上太阳。", "inputFormat": "输入共一行，包含三个正整数 $n,x,k$，分别表示与太阳的距离、一天可以前进的距离、夸父的体力值。", "outputFormat": "输出共一行，包含一个正整数，代表追上太阳所需的天数。", "hint": "#### 【样例 2 解释】\n\n- 第一天休息一天，剩余体力值为 $4$。\n- 第二天追 $3$ 的距离，离太阳距离为 $7$，剩余体力值为 $3$。\n- 第三天追 $3$ 的距离，离太阳距离为 $4$，剩余体力值为 $2$。\n- 第四天追 $3$ 的距离，离太阳距离为 $1$，剩余体力值为 $1$。\n- 第五天追 $3$ 的距离，追上了太阳，剩余体力值为 $0$。\n\n#### 【数据范围】\n\n对于 $10\\%$ 的数据，$n=x$。\n\n对于 $40\\%$ 的数据，$k>\\lceil\\frac{n}{x}\\rceil$。\n\n对于 $100\\%$ 的数据，$1\\le n,x,k\\le10^5$。", "locale": "zh-CN"}}}
{"pid": "P11600", "type": "P", "difficulty": 2, "samples": [["5\n1 3 5 7 9", "5 2"], ["7\n10 13 19 301 304 307 3004", "1002 3"], ["3\n2 1000000 1234567", "1234567 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": [], "title": "『Fwb』流星の陨落", "background": "", "description": "流星雨来了！\n\n当然，这场流星雨确确实实是 Fwb 设计的。Fwb 在天空中放置了许多的流星，同时也在地面上放置了许多的烟花。当流星和烟花发生碰撞时，就会出现美丽而独特的风景。\n\n由于方便控制流星雨的发射，流星的发射是有规律的，这个发射的规律叫做流星间隔。我们把地面上烟花的摆放看作一个数轴，若流星间隔是 $k$，那么在 $i$ 位置发射一颗流星后，下一个发射流星的位置必须是 $i+k$。特殊的，第一个发射流星的位置**必须是** $1$。\n\n为了使流星雨好看，保证每一个烟花都会和流星碰撞，即每一个烟花的位置都会有流星发射。**但不保证每一个流星都有可碰撞的烟花**。为了尽可能减少资源消耗，发射的流星应在满足条件的前提下最少，现在想请你算出，发射的流星雨中最少有多少颗流星以及此时的流星间隔是多少。", "inputFormat": "输入的第一行包含一个正整数 $n$，代表地上共放置了 $n$ 个烟花。\n\n第二行共 $n$ 个正整数，代表烟花在数轴上的位置 $a_i$（保证 $a_i$ 递增）。默认最后一个烟花的位置为数轴的尽头，即保证在位置 $i$（$i>a_n$）不会再有流星发射。", "outputFormat": "输出共一行，包含两个正整数，分别表示流星雨中最少的流星数量以及此时的流星间隔。", "hint": "#### 【样例 1 解释】\n\n当流星间隔为 $2$ 时，流星会发射在 $[1,3,5,7,9]$ 的位置，恰好覆盖所有的烟花。此时发射的流星数量最少为 $5$。\n\n#### 【数据范围】\n\n对于所有的测试数据，保证：\n\n- $1\\le n\\le 10^5$。\n- 对于任意的 $i$（$1\\le i\\le n$），都有 $1\\le a_i\\le 10^9$。\n\n| 测试点 | $n=$ | $a_i\\le$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $1$ | $10$ | 无 |\n| $2$ | $10^5$ | $10^9$ | A |\n| $3,4$ | $10^5$ | $10^9$ | B |\n| $5,6,7$ | $10$ | $10^9$ | C |\n| $8,9,10$ | $10^5$ | $10^9$ | 无 |\n\n特殊性质 A：保证 $a_i=a_{i-1}+1$（$1<i\\le n$）。\n\n特殊性质 B：保证 $a_i-a_{i-1}=a_{i+1}-a_i$（$1<i<n$）。\n\n特殊性质 C：保证至少出现一次 $a_i-a_{i-1} \\le 10^4$（$2\\le i\\le n$）。\n\n**题目保证不出现 $n=1$ 且 $a_1=1$ 的情况。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『Fwb』流星の陨落", "background": "", "description": "流星雨来了！\n\n当然，这场流星雨确确实实是 Fwb 设计的。Fwb 在天空中放置了许多的流星，同时也在地面上放置了许多的烟花。当流星和烟花发生碰撞时，就会出现美丽而独特的风景。\n\n由于方便控制流星雨的发射，流星的发射是有规律的，这个发射的规律叫做流星间隔。我们把地面上烟花的摆放看作一个数轴，若流星间隔是 $k$，那么在 $i$ 位置发射一颗流星后，下一个发射流星的位置必须是 $i+k$。特殊的，第一个发射流星的位置**必须是** $1$。\n\n为了使流星雨好看，保证每一个烟花都会和流星碰撞，即每一个烟花的位置都会有流星发射。**但不保证每一个流星都有可碰撞的烟花**。为了尽可能减少资源消耗，发射的流星应在满足条件的前提下最少，现在想请你算出，发射的流星雨中最少有多少颗流星以及此时的流星间隔是多少。", "inputFormat": "输入的第一行包含一个正整数 $n$，代表地上共放置了 $n$ 个烟花。\n\n第二行共 $n$ 个正整数，代表烟花在数轴上的位置 $a_i$（保证 $a_i$ 递增）。默认最后一个烟花的位置为数轴的尽头，即保证在位置 $i$（$i>a_n$）不会再有流星发射。", "outputFormat": "输出共一行，包含两个正整数，分别表示流星雨中最少的流星数量以及此时的流星间隔。", "hint": "#### 【样例 1 解释】\n\n当流星间隔为 $2$ 时，流星会发射在 $[1,3,5,7,9]$ 的位置，恰好覆盖所有的烟花。此时发射的流星数量最少为 $5$。\n\n#### 【数据范围】\n\n对于所有的测试数据，保证：\n\n- $1\\le n\\le 10^5$。\n- 对于任意的 $i$（$1\\le i\\le n$），都有 $1\\le a_i\\le 10^9$。\n\n| 测试点 | $n=$ | $a_i\\le$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $1$ | $10$ | 无 |\n| $2$ | $10^5$ | $10^9$ | A |\n| $3,4$ | $10^5$ | $10^9$ | B |\n| $5,6,7$ | $10$ | $10^9$ | C |\n| $8,9,10$ | $10^5$ | $10^9$ | 无 |\n\n特殊性质 A：保证 $a_i=a_{i-1}+1$（$1<i\\le n$）。\n\n特殊性质 B：保证 $a_i-a_{i-1}=a_{i+1}-a_i$（$1<i<n$）。\n\n特殊性质 C：保证至少出现一次 $a_i-a_{i-1} \\le 10^4$（$2\\le i\\le n$）。\n\n**题目保证不出现 $n=1$ 且 $a_1=1$ 的情况。**", "locale": "zh-CN"}}}
{"pid": "P11601", "type": "P", "difficulty": 4, "samples": [["3 6\n1 2 3 4 2 1\n3\n0 1 3\n3 3 1\n1 4 5\n2\n1 4 2\n0 2 4\n2\n0 6 2\n2 4 2", "3 1 3 5\nWrong\nSafe"], ["2 3\n1 3 4\n3\n0 1 2\n2 3 2\n3 2 1\n1\n0 1 2", "Wrong\nWrong"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2025", "洛谷比赛"], "title": "『Fwb』狼人の杀戮", "background": "", "description": "Fwb 开始玩狼人杀了。\n\n这是一个游戏规则略有不同的简化版的狼人杀，若与现实中狼人杀规则不同，应以题目为准。开局共有 $n$（$n≥2$）位玩家，他们的身份共有以下几种：\n\n- 狼人：在天黑时可以进行选择一位非自己的玩家杀害，可以是其他狼人。\n- 平民：在天黑时只能闭眼睡觉，没有任何技能。\n- 猎人：若自己存活，在天黑时只能闭眼睡觉；若在此夜被杀死且未被解救，**必须**任意带走一位非自己玩家（带走意义即为杀死）。若带走玩家之后又被救活，则下一次被杀死依旧可以继续带走玩家，且此次带走依然成立。换句话说，带走玩家后再被救活也是合法的。\n- 女巫：在天黑时可以进行选择：用解药解救任意一个在今夜死亡的玩家（可以是自己），或用毒药毒死任意存活的玩家（不可以是自己）。特殊的，女巫可以在被杀死后对自己使用解药，但不可以进行其他技能操作。请注意，每一位女巫只有一次解药和一次毒药的机会，且**不可以在同一夜使用**。\n\n\n在黑夜中，将模拟**各种角色技能的进行**，有如下几种格式：\n\n- $0\\ id_1\\ id_2$：编号为 $id_1$ 的狼人决定将编号为 $id_2$ 的玩家杀害。\n- $1\\ id_1\\ id_2$：编号为 $id_1$ 的女巫决定将编号为 $id_2$ 的玩家毒死。\n- $2\\ id_1\\ id_2$：编号为 $id_1$ 的女巫决定将编号为 $id_2$ 的玩家救活。\n- $3\\ id_1\\ id_2$：编号为 $id_1$ 的猎人被杀死，决定带走编号为 $id_2$ 的玩家。\n\n\n在天亮后，将公布昨夜的**死亡情况**，有如下几种格式：\n\n- $x\\ id_1\\ id_2\\ ...\\ id_x$：共 $x$ 名编号分别为 $id_1\\ id_2\\ ...\\ id_x$ 的玩家在昨夜被杀害，每两个玩家编号之间用空格隔开。注意，$id_i$ 必须严格单调递增。\n- `Safe`：昨夜是平安夜，其中平安夜指没有人死亡即 $x=0$ 的夜晚。\n- `Wrong`：昨夜的角色技能输入有误。此夜晚将撤回全部操作。\n\n当出现以下情况时，认为昨夜的角色技能输入有误：\n\n- 编号为 $id$ 的玩家不存在。\n- 除女巫使用解药时，编号为 $id$ 的玩家已死亡。\n- **同一位**狼人、女巫在同一晚上多次使用技能。\n- 猎人未被杀死就使用技能。\n- 猎人在被杀死时带走多人。\n- 玩家使用了不属于自己的技能。\n- 女巫将解药用在了未死亡或非今夜死亡的人身上。\n- 狼人杀人、女巫使用毒药、猎人带走玩家时对自己使用技能。\n\n当一夜技能输入有误时，该夜的所有操作均不被执行。\n\n请注意，一个夜晚是有时间顺序的，这个时间顺序决定了输入的合法性。例如，在同一夜晚，女巫先对编号为 $id$ 的玩家使用解药，狼人再杀死编号为 $id$ 的玩家，然后夜晚结束，属于不合法输入。\n\n现在告诉你了在黑夜中，各种角色技能的进行。你需要判断昨夜的死亡情况。", "inputFormat": "**本题包含多组测试数据。**\n\n输入的第一行包含两个正整数 $t,n$，分别表示要求模拟这一局游戏进行的**前** $t$ 个夜晚的结果与玩家人数 $n$。\n\n第二行输入 $n$ 个正整数 $a_i$，表示各个玩家的角色。其中狼人用 $1$ 表示，平民用 $2$ 表示，猎人用 $3$ 表示，女巫用 $4$ 表示。\n\n接下来 $t$ 组数据，表示 $t$ 个夜晚，每个夜晚输入的格式如下：\n\n先输入一个正整数 $m$，代表这一夜发生的事件数量。\n\n接下来每 $m$ 行，每行包含 $3$ 个非负整数，输入格式详见【题目描述】中的**各种角色技能的进行**。默认玩家编号为 $1\\sim n$，保证 $id$ 在 $1\\sim 10^3$ 范围内。", "outputFormat": "输出共 $t$ 行。\n\n对于每一次输入的**各种角色技能的进行**，都输出相对应的死亡情况，输出格式详见【题目描述】中的**死亡情况**。", "hint": "**本题采用捆绑测试。**\n\n#### 【样例 1 解释】\n编号为 $1\\sim 6$ 的玩家的身份分别是：狼人、平民、猎人、女巫、平民、狼人。\n\n第一夜：\n\n- $1$ 号狼人杀死了 $3$ 号猎人。\n- $3$ 号猎人带走了 $1$ 号狼人。\n- $4$ 号女巫毒死了 $5$ 号平民。\n\n结果：$3$ 号猎人被 $1$ 号狼人杀死，$1$ 号狼人被 $3$ 号猎人带走，$5$ 号平民被 $4$ 号女巫毒死。此时仅有 $2$ 号平民、$4$ 号女巫和 $6$ 号狼人存活。\n\n第二夜：\n\n- $4$ 号女巫毒死了 $2$ 号平民。\n- $2$ 号狼人杀死了 $4$ 号女巫。\n\n结果：$2$ 号是平民且已经死亡，此回合不合法。此时仍有 $2$ 号平民、$4$ 号女巫和 $6$ 号狼人存活。\n\n第三夜：\n\n- $6$ 号狼人杀死了 $2$ 号平民。\n- $4$ 号女巫解救了 $2$ 号平民。\n\n结果：$2$ 号平民在被狼人杀死之后被女巫救活，今夜是平安夜。\n\n#### 【样例 2 解释】\n\n第一夜：猎人先被狼人杀死，女巫又救活了猎人，故猎人最终存活，无法带走其他玩家。\n\n第二夜：猎人被狼人杀死，没有人救活他，所以猎人必须带走一名玩家。\n\n#### 【数据范围】\n\n对于 $100\\%$ 的数据，$1\\le t\\le 10$，$2\\le n\\le 20$，$1\\le a_i\\le 4$，$1\\le m\\le 20$。\n\n| 子任务 | $1\\le t\\le$ | 分值 | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $5$ | $10$ | A、B |\n| $2$ | $5$ | $10$ | B |\n| $3$ | $5$ | $30$ | 无 |\n| $4$ | $10$ | $50$ | 无 |\n| $5$ | $10$ | $0$ | C |\n\n\n特殊性质 A：每一晚一定有人死亡。\n\n特殊性质 B：只存在狼人与平民，不存在输入不合法的情况。\n\n特殊性质 C：本子任务为 Hack 数据，不占分。\n\n**请注意，所有玩家被杀死即生效，而不是等待夜晚结束之后。特殊的，猎人仍有使用技能的权力。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『Fwb』狼人の杀戮", "background": "", "description": "Fwb 开始玩狼人杀了。\n\n这是一个游戏规则略有不同的简化版的狼人杀，若与现实中狼人杀规则不同，应以题目为准。开局共有 $n$（$n≥2$）位玩家，他们的身份共有以下几种：\n\n- 狼人：在天黑时可以进行选择一位非自己的玩家杀害，可以是其他狼人。\n- 平民：在天黑时只能闭眼睡觉，没有任何技能。\n- 猎人：若自己存活，在天黑时只能闭眼睡觉；若在此夜被杀死且未被解救，**必须**任意带走一位非自己玩家（带走意义即为杀死）。若带走玩家之后又被救活，则下一次被杀死依旧可以继续带走玩家，且此次带走依然成立。换句话说，带走玩家后再被救活也是合法的。\n- 女巫：在天黑时可以进行选择：用解药解救任意一个在今夜死亡的玩家（可以是自己），或用毒药毒死任意存活的玩家（不可以是自己）。特殊的，女巫可以在被杀死后对自己使用解药，但不可以进行其他技能操作。请注意，每一位女巫只有一次解药和一次毒药的机会，且**不可以在同一夜使用**。\n\n\n在黑夜中，将模拟**各种角色技能的进行**，有如下几种格式：\n\n- $0\\ id_1\\ id_2$：编号为 $id_1$ 的狼人决定将编号为 $id_2$ 的玩家杀害。\n- $1\\ id_1\\ id_2$：编号为 $id_1$ 的女巫决定将编号为 $id_2$ 的玩家毒死。\n- $2\\ id_1\\ id_2$：编号为 $id_1$ 的女巫决定将编号为 $id_2$ 的玩家救活。\n- $3\\ id_1\\ id_2$：编号为 $id_1$ 的猎人被杀死，决定带走编号为 $id_2$ 的玩家。\n\n\n在天亮后，将公布昨夜的**死亡情况**，有如下几种格式：\n\n- $x\\ id_1\\ id_2\\ ...\\ id_x$：共 $x$ 名编号分别为 $id_1\\ id_2\\ ...\\ id_x$ 的玩家在昨夜被杀害，每两个玩家编号之间用空格隔开。注意，$id_i$ 必须严格单调递增。\n- `Safe`：昨夜是平安夜，其中平安夜指没有人死亡即 $x=0$ 的夜晚。\n- `Wrong`：昨夜的角色技能输入有误。此夜晚将撤回全部操作。\n\n当出现以下情况时，认为昨夜的角色技能输入有误：\n\n- 编号为 $id$ 的玩家不存在。\n- 除女巫使用解药时，编号为 $id$ 的玩家已死亡。\n- **同一位**狼人、女巫在同一晚上多次使用技能。\n- 猎人未被杀死就使用技能。\n- 猎人在被杀死时带走多人。\n- 玩家使用了不属于自己的技能。\n- 女巫将解药用在了未死亡或非今夜死亡的人身上。\n- 狼人杀人、女巫使用毒药、猎人带走玩家时对自己使用技能。\n\n当一夜技能输入有误时，该夜的所有操作均不被执行。\n\n请注意，一个夜晚是有时间顺序的，这个时间顺序决定了输入的合法性。例如，在同一夜晚，女巫先对编号为 $id$ 的玩家使用解药，狼人再杀死编号为 $id$ 的玩家，然后夜晚结束，属于不合法输入。\n\n现在告诉你了在黑夜中，各种角色技能的进行。你需要判断昨夜的死亡情况。", "inputFormat": "**本题包含多组测试数据。**\n\n输入的第一行包含两个正整数 $t,n$，分别表示要求模拟这一局游戏进行的**前** $t$ 个夜晚的结果与玩家人数 $n$。\n\n第二行输入 $n$ 个正整数 $a_i$，表示各个玩家的角色。其中狼人用 $1$ 表示，平民用 $2$ 表示，猎人用 $3$ 表示，女巫用 $4$ 表示。\n\n接下来 $t$ 组数据，表示 $t$ 个夜晚，每个夜晚输入的格式如下：\n\n先输入一个正整数 $m$，代表这一夜发生的事件数量。\n\n接下来每 $m$ 行，每行包含 $3$ 个非负整数，输入格式详见【题目描述】中的**各种角色技能的进行**。默认玩家编号为 $1\\sim n$，保证 $id$ 在 $1\\sim 10^3$ 范围内。", "outputFormat": "输出共 $t$ 行。\n\n对于每一次输入的**各种角色技能的进行**，都输出相对应的死亡情况，输出格式详见【题目描述】中的**死亡情况**。", "hint": "**本题采用捆绑测试。**\n\n#### 【样例 1 解释】\n编号为 $1\\sim 6$ 的玩家的身份分别是：狼人、平民、猎人、女巫、平民、狼人。\n\n第一夜：\n\n- $1$ 号狼人杀死了 $3$ 号猎人。\n- $3$ 号猎人带走了 $1$ 号狼人。\n- $4$ 号女巫毒死了 $5$ 号平民。\n\n结果：$3$ 号猎人被 $1$ 号狼人杀死，$1$ 号狼人被 $3$ 号猎人带走，$5$ 号平民被 $4$ 号女巫毒死。此时仅有 $2$ 号平民、$4$ 号女巫和 $6$ 号狼人存活。\n\n第二夜：\n\n- $4$ 号女巫毒死了 $2$ 号平民。\n- $2$ 号狼人杀死了 $4$ 号女巫。\n\n结果：$2$ 号是平民且已经死亡，此回合不合法。此时仍有 $2$ 号平民、$4$ 号女巫和 $6$ 号狼人存活。\n\n第三夜：\n\n- $6$ 号狼人杀死了 $2$ 号平民。\n- $4$ 号女巫解救了 $2$ 号平民。\n\n结果：$2$ 号平民在被狼人杀死之后被女巫救活，今夜是平安夜。\n\n#### 【样例 2 解释】\n\n第一夜：猎人先被狼人杀死，女巫又救活了猎人，故猎人最终存活，无法带走其他玩家。\n\n第二夜：猎人被狼人杀死，没有人救活他，所以猎人必须带走一名玩家。\n\n#### 【数据范围】\n\n对于 $100\\%$ 的数据，$1\\le t\\le 10$，$2\\le n\\le 20$，$1\\le a_i\\le 4$，$1\\le m\\le 20$。\n\n| 子任务 | $1\\le t\\le$ | 分值 | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $5$ | $10$ | A、B |\n| $2$ | $5$ | $10$ | B |\n| $3$ | $5$ | $30$ | 无 |\n| $4$ | $10$ | $50$ | 无 |\n| $5$ | $10$ | $0$ | C |\n\n\n特殊性质 A：每一晚一定有人死亡。\n\n特殊性质 B：只存在狼人与平民，不存在输入不合法的情况。\n\n特殊性质 C：本子任务为 Hack 数据，不占分。\n\n**请注意，所有玩家被杀死即生效，而不是等待夜晚结束之后。特殊的，猎人仍有使用技能的权力。**", "locale": "zh-CN"}}}
{"pid": "P11602", "type": "P", "difficulty": 3, "samples": [["3\n5\n2\n3", "9\n2\n4"], ["6\n263\n749\n409\n761\n729\n382", "16760809\n1095216660441\n939524067\n1099510579161\n549755805658\n503316452"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "递推", "2025", "洛谷比赛"], "title": "『Fwb』黑巧の安排", "background": "", "description": "Fwb 可喜欢吃黑巧了。\n\nFwb 有一个专门用来装黑巧的盒子，但很不巧，今天盒子空了，Fwb 又该出去买点巧克力了。\n\n由于 Fwb 也知道吃多了巧克力对身体不好，所以他决定他买的巧克力必须只能吃 $a$ 天，且不能多也不能少。\n\nFwb 吃巧克力是有规律的：他会在第一天吃一块巧克力，在品尝到巧克力的美味后，第二天吃两块巧克力，第 $i$ 天吃 $2^{i-1}$ 块巧克力（$i>0$）。\n\n当剩余的巧克力不够一天吃的时候，Fwb 就会选择不吃；反之，当剩余的巧克力够一天吃的时候，Fwb 就一定会吃。\n\n若在第 $i$ 天吃完的巧克力之后仍剩余 $k$ 颗，且 $k<2^i$，则 Fwb 会在第 $i+1$ 天再次吃 $1$ 颗，在第 $i+2$ 天再次吃 $2$ 颗，以此类推。换句话说，当 $k<2^i$ 时，第 $i+m$ 天会吃 $2^{m-1}$ 颗。\n\n现在需要你求出，Fwb 在恰好吃 $a$ 天的前提下，最少需要购买多少颗巧克力。", "inputFormat": "**本题包含多组测试数据。**\n\n第一行输入一个正整数 $t$，表示数据组数。\n\n接下来 $t$ 行，每行包含一个正整数 $a$，代表 Fwb 购买的巧克力需要恰好吃 $a$ 天。", "outputFormat": "输出共 $t$ 行。对于每一个输入的 $a$，输出一个正整数代表 Fwb 至少需要购买的巧克力数量。", "hint": "#### 【样例 1 解释】\n\n第一次询问：要求恰好 $5$ 天吃完，则买 $9$ 颗巧克力。安排如下：\n\n- 第一天吃 $1$ 颗，剩余 $8$ 颗。\n- 第二天吃 $2$ 颗，剩余 $6$ 颗。\n- 第三天吃 $4$ 颗，剩余 $2$ 颗。\n- 不够 $8$ 颗，第四天只能再从 $1$ 颗吃起，剩余 $1$ 颗。\n- 不够 $2$ 颗，第五天只能再从 $1$ 颗吃起，吃 $1$ 颗，恰好吃完。\n\n可以证明，没有更优的安排。\n\n第二次询问：要求恰好两天吃完，买 $2$ 颗巧克力，每天 $1$ 颗即可。\n\n第三次询问：要求恰好三天吃完，买 $4$ 颗巧克力，每天分别吃 $1,2,1$ 颗。\n\n#### 【数据范围】\n\n对于 $30\\%$ 的数据，$1\\le a\\le 10$。\n\n对于 $100\\%$ 的数据，$1\\le t,a\\le 1000$。\n\n保证答案在 $long\\ long$ 范围内。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『Fwb』黑巧の安排", "background": "", "description": "Fwb 可喜欢吃黑巧了。\n\nFwb 有一个专门用来装黑巧的盒子，但很不巧，今天盒子空了，Fwb 又该出去买点巧克力了。\n\n由于 Fwb 也知道吃多了巧克力对身体不好，所以他决定他买的巧克力必须只能吃 $a$ 天，且不能多也不能少。\n\nFwb 吃巧克力是有规律的：他会在第一天吃一块巧克力，在品尝到巧克力的美味后，第二天吃两块巧克力，第 $i$ 天吃 $2^{i-1}$ 块巧克力（$i>0$）。\n\n当剩余的巧克力不够一天吃的时候，Fwb 就会选择不吃；反之，当剩余的巧克力够一天吃的时候，Fwb 就一定会吃。\n\n若在第 $i$ 天吃完的巧克力之后仍剩余 $k$ 颗，且 $k<2^i$，则 Fwb 会在第 $i+1$ 天再次吃 $1$ 颗，在第 $i+2$ 天再次吃 $2$ 颗，以此类推。换句话说，当 $k<2^i$ 时，第 $i+m$ 天会吃 $2^{m-1}$ 颗。\n\n现在需要你求出，Fwb 在恰好吃 $a$ 天的前提下，最少需要购买多少颗巧克力。", "inputFormat": "**本题包含多组测试数据。**\n\n第一行输入一个正整数 $t$，表示数据组数。\n\n接下来 $t$ 行，每行包含一个正整数 $a$，代表 Fwb 购买的巧克力需要恰好吃 $a$ 天。", "outputFormat": "输出共 $t$ 行。对于每一个输入的 $a$，输出一个正整数代表 Fwb 至少需要购买的巧克力数量。", "hint": "#### 【样例 1 解释】\n\n第一次询问：要求恰好 $5$ 天吃完，则买 $9$ 颗巧克力。安排如下：\n\n- 第一天吃 $1$ 颗，剩余 $8$ 颗。\n- 第二天吃 $2$ 颗，剩余 $6$ 颗。\n- 第三天吃 $4$ 颗，剩余 $2$ 颗。\n- 不够 $8$ 颗，第四天只能再从 $1$ 颗吃起，剩余 $1$ 颗。\n- 不够 $2$ 颗，第五天只能再从 $1$ 颗吃起，吃 $1$ 颗，恰好吃完。\n\n可以证明，没有更优的安排。\n\n第二次询问：要求恰好两天吃完，买 $2$ 颗巧克力，每天 $1$ 颗即可。\n\n第三次询问：要求恰好三天吃完，买 $4$ 颗巧克力，每天分别吃 $1,2,1$ 颗。\n\n#### 【数据范围】\n\n对于 $30\\%$ 的数据，$1\\le a\\le 10$。\n\n对于 $100\\%$ 的数据，$1\\le t,a\\le 1000$。\n\n保证答案在 $long\\ long$ 范围内。", "locale": "zh-CN"}}}
{"pid": "P11603", "type": "P", "difficulty": 2, "samples": [["2 1\n2 4 1 5", "5 1 4 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2016", "PA（波兰）"], "title": "[PA 2016] 洗牌 / Tasowanie", "background": "译自 [Potyczki Algorytmiczne 2016](https://sio2.mimuw.edu.pl/c/pa-2016-1/p/) R1 Tasowanie [B] (TAS)。\n", "description": "\n给定 $2^n$ 张牌，每张牌上写着一个正整数。第 $i$ 张牌上写着的正整数为 $a_i$。\n\n考虑如下的洗牌过程：\n\n- 若要洗的牌的数量为 $1$，则什么都不做。\n- 否则，设牌的数量为 $2^k$。\n    - 递归地洗第 $1\\sim 2^{k-1}$ 张牌，以及第 $2^{k-1}+1\\sim 2^k$ 张牌；\n    - 将洗过的第 $2^{k-1}+1\\sim 2^k$ 张牌放在洗过的第 $1\\sim 2^{k-1}$ 张牌前面。\n\n用以上的过程洗好第 $1\\sim 2^n$ 张牌称为**一次洗牌**。\n\n给定正整数 $t$。求出洗了 $t$ 次牌后，第 $1\\sim 2^n$ 张牌上写着的数字分别是什么。\n", "inputFormat": "\n第一行，两个正整数 $n,t$。\n\n第二行，$2^n$ 个正整数 $a_1,a_2,\\cdots,a_{2^n}$。", "outputFormat": "$2^n$ 个正整数，描述洗牌后每张牌上的数字。\n", "hint": "\n- $1\\le n\\le 20$；\n- $1\\le t,a_i\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2016] 洗牌 / Tasowanie", "background": "译自 [Potyczki Algorytmiczne 2016](https://sio2.mimuw.edu.pl/c/pa-2016-1/p/) R1 Tasowanie [B] (TAS)。\n", "description": "\n给定 $2^n$ 张牌，每张牌上写着一个正整数。第 $i$ 张牌上写着的正整数为 $a_i$。\n\n考虑如下的洗牌过程：\n\n- 若要洗的牌的数量为 $1$，则什么都不做。\n- 否则，设牌的数量为 $2^k$。\n    - 递归地洗第 $1\\sim 2^{k-1}$ 张牌，以及第 $2^{k-1}+1\\sim 2^k$ 张牌；\n    - 将洗过的第 $2^{k-1}+1\\sim 2^k$ 张牌放在洗过的第 $1\\sim 2^{k-1}$ 张牌前面。\n\n用以上的过程洗好第 $1\\sim 2^n$ 张牌称为**一次洗牌**。\n\n给定正整数 $t$。求出洗了 $t$ 次牌后，第 $1\\sim 2^n$ 张牌上写着的数字分别是什么。\n", "inputFormat": "\n第一行，两个正整数 $n,t$。\n\n第二行，$2^n$ 个正整数 $a_1,a_2,\\cdots,a_{2^n}$。", "outputFormat": "$2^n$ 个正整数，描述洗牌后每张牌上的数字。\n", "hint": "\n- $1\\le n\\le 20$；\n- $1\\le t,a_i\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P11604", "type": "P", "difficulty": 5, "samples": [["3\n5 5\n5 > 5\n1 > 5\n3 > 5\n4 > 5\n2 > 5\n2 2\n1 > 1\n1 > 2\n1 1\n1 < 1", "WYGRANA\nREMIS\nPRZEGRANA"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2016", "图论建模", "二分图", "Ad-hoc", "PA（波兰）"], "title": "[PA 2016] 卡牌 / Gra w karty", "background": "译自 [Potyczki Algorytmiczne 2016](https://sio2.mimuw.edu.pl/c/pa-2016-1/p/) R1 Gra w karty [A] (KAR)。$\\texttt{1s,256M}$。\n", "description": "\nAlice 和 Bob 各有 $n$ 张卡牌。每个人的卡牌都被编号为 $1\\sim n$。\n\n现在玩 $(n-1)$ 局游戏：每局游戏中，Alice 先弃掉 Bob 的一张牌，然后 Bob 再弃掉 Alice 的一张牌。\n\n最终两人都只剩下一张牌。\n\n有 $m$ 对关系，形如「若 Alice 最后剩下的牌为 $x$，Bob 最后剩下的牌为 $y$，则 Alice 胜/负 Bob」。特别地，未给出的关系为平局。\n\n若双方都用最优策略游戏，Alice 最终会胜/负 Bob 还是平局？\n\n「最佳策略」指的是：若有必胜策略，则选择必胜策略；否则若有平局策略，选择平局策略。", "inputFormat": "\n**本题单个测试点内有多组测试数据。**\n\n第一行，一个正整数 $T$。接下来描述 $T$ 组测试数据：\n\n每组数据第一行，两个整数 $n,m$。\n\n接下来 $m$ 行，每行两个正整数和一个字符 $x,w,y$，其中 $w\\in \\{\\texttt{<},\\texttt{>}\\}$，$x,y$ 为正整数。\n- 若 $w=\\texttt{>}$，则表示「若 Alice 最后剩下的牌为 $x$，Bob 最后剩下的牌为 $y$，则 Alice 胜 Bob」；\n- 若 $w=\\texttt{<}$，则表示「若 Alice 最后剩下的牌为 $x$，Bob 最后剩下的牌为 $y$，则 Alice 负 Bob」。\n\n保证不会出现自相矛盾的关系。\n", "outputFormat": "\n输出 $T$ 行，每行一个字符串：\n- 若 Alice 有必胜策略，输出 $\\texttt{WYGRANA}$；\n- 否则，若 Alice 有平局策略，输出 $\\texttt{REMIS}$；\n- 否则，输出 $\\texttt{PRZEGRANA}$。\n", "hint": "\n- $1\\le T\\le 20$；\n- $1\\le n\\le 10^5$；\n- $0\\le m\\le 2\\times 10^5$；\n- $1\\le x,y\\le n$；\n- $w\\in \\{\\texttt{<},\\texttt{>}\\}$。\n\n保证不会出现自相矛盾的关系，也不会重复给出一个关系。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2016] 卡牌 / Gra w karty", "background": "译自 [Potyczki Algorytmiczne 2016](https://sio2.mimuw.edu.pl/c/pa-2016-1/p/) R1 Gra w karty [A] (KAR)。$\\texttt{1s,256M}$。\n", "description": "\nAlice 和 Bob 各有 $n$ 张卡牌。每个人的卡牌都被编号为 $1\\sim n$。\n\n现在玩 $(n-1)$ 局游戏：每局游戏中，Alice 先弃掉 Bob 的一张牌，然后 Bob 再弃掉 Alice 的一张牌。\n\n最终两人都只剩下一张牌。\n\n有 $m$ 对关系，形如「若 Alice 最后剩下的牌为 $x$，Bob 最后剩下的牌为 $y$，则 Alice 胜/负 Bob」。特别地，未给出的关系为平局。\n\n若双方都用最优策略游戏，Alice 最终会胜/负 Bob 还是平局？\n\n「最佳策略」指的是：若有必胜策略，则选择必胜策略；否则若有平局策略，选择平局策略。", "inputFormat": "\n**本题单个测试点内有多组测试数据。**\n\n第一行，一个正整数 $T$。接下来描述 $T$ 组测试数据：\n\n每组数据第一行，两个整数 $n,m$。\n\n接下来 $m$ 行，每行两个正整数和一个字符 $x,w,y$，其中 $w\\in \\{\\texttt{<},\\texttt{>}\\}$，$x,y$ 为正整数。\n- 若 $w=\\texttt{>}$，则表示「若 Alice 最后剩下的牌为 $x$，Bob 最后剩下的牌为 $y$，则 Alice 胜 Bob」；\n- 若 $w=\\texttt{<}$，则表示「若 Alice 最后剩下的牌为 $x$，Bob 最后剩下的牌为 $y$，则 Alice 负 Bob」。\n\n保证不会出现自相矛盾的关系。\n", "outputFormat": "\n输出 $T$ 行，每行一个字符串：\n- 若 Alice 有必胜策略，输出 $\\texttt{WYGRANA}$；\n- 否则，若 Alice 有平局策略，输出 $\\texttt{REMIS}$；\n- 否则，输出 $\\texttt{PRZEGRANA}$。\n", "hint": "\n- $1\\le T\\le 20$；\n- $1\\le n\\le 10^5$；\n- $0\\le m\\le 2\\times 10^5$；\n- $1\\le x,y\\le n$；\n- $w\\in \\{\\texttt{<},\\texttt{>}\\}$。\n\n保证不会出现自相矛盾的关系，也不会重复给出一个关系。", "locale": "zh-CN"}}}
{"pid": "P11605", "type": "P", "difficulty": 3, "samples": [["2\n6\n10", "(1+1)*(1+1+1)\n1+1+1+1+1+1+1+1+1+1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "贪心", "2016", "递归", "Special Judge", "PA（波兰）"], "title": "[PA 2016] 运算 / Jedynki", "background": "译自 [Potyczki Algorytmiczne 2016](https://sio2.mimuw.edu.pl/c/pa-2016-1/p/) R2 Jedynki [B] (JED)。$\\texttt{1s,256M}$。\n", "description": "\n给定正整数 $k$。构造一个只包含 $\\texttt{1},\\texttt{+},\\texttt{*},\\texttt{(},\\texttt{)}$ 的**合法**表达式，满足：\n- 不存在两个相邻的 $1$；\n- $1$ 的数量最多为 $100$；\n- 表达式运算结果为 $k$。\n\n输出你构造的表达式，或者判断无解。\n\n我们给定合法表达式的形式化定义：\n\n- $\\texttt{1}$ 是合法表达式。\n- 若 $\\texttt{a},\\texttt{b}$ 是合法表达式，则 $\\texttt{a+b},\\texttt{a*b},\\texttt{(a+b)},\\texttt{(a*b)}$ 都是合法表达式。", "inputFormat": "\n**本题单个测试点内有多组测试数据。**\n\n第一行，一个正整数 $T$。接下来描述 $T$ 组测试数据：\n\n每组测试数据只有一行一个正整数 $k$。\n", "outputFormat": "\n输出 $T$ 行，每行一个字符串：\n- 若无解，输出 $\\texttt{NIE}$；\n- 否则输出你构造的表达式。", "hint": "\n- $1\\le T\\le 100$；\n- $1\\le k\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2016] 运算 / Jedynki", "background": "译自 [Potyczki Algorytmiczne 2016](https://sio2.mimuw.edu.pl/c/pa-2016-1/p/) R2 Jedynki [B] (JED)。$\\texttt{1s,256M}$。\n", "description": "\n给定正整数 $k$。构造一个只包含 $\\texttt{1},\\texttt{+},\\texttt{*},\\texttt{(},\\texttt{)}$ 的**合法**表达式，满足：\n- 不存在两个相邻的 $1$；\n- $1$ 的数量最多为 $100$；\n- 表达式运算结果为 $k$。\n\n输出你构造的表达式，或者判断无解。\n\n我们给定合法表达式的形式化定义：\n\n- $\\texttt{1}$ 是合法表达式。\n- 若 $\\texttt{a},\\texttt{b}$ 是合法表达式，则 $\\texttt{a+b},\\texttt{a*b},\\texttt{(a+b)},\\texttt{(a*b)}$ 都是合法表达式。", "inputFormat": "\n**本题单个测试点内有多组测试数据。**\n\n第一行，一个正整数 $T$。接下来描述 $T$ 组测试数据：\n\n每组测试数据只有一行一个正整数 $k$。\n", "outputFormat": "\n输出 $T$ 行，每行一个字符串：\n- 若无解，输出 $\\texttt{NIE}$；\n- 否则输出你构造的表达式。", "hint": "\n- $1\\le T\\le 100$；\n- $1\\le k\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P11606", "type": "P", "difficulty": 6, "samples": [["4 4\n4 1 T\n4 2 T\n3 2 N\n4 3 N", "0\n1\n1\n2"], ["2 2\n1 2 N\n2 1 N", "NIE"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "并查集", "递归", "Special Judge", "构造", "PA（波兰）"], "title": "[PA 2016] 构树 / Reorganizacja", "background": "译自 [Potyczki Algorytmiczne 2016](https://sio2.mimuw.edu.pl/c/pa-2016-1/p/) R2 Reorganizacja [A] (REO)。$\\texttt{1s,256M}$。\n", "description": "构造一棵 $n$ 个节点的有根树，满足 $m$ 条限制，形如「$x$ 必须是 $y$ 的祖先」或者「$x$ 必须不是 $y$ 的祖先」。\n", "inputFormat": "\n第一行，两个整数 $n,m$。\n\n接下来 $m$ 行，每行两个正整数和一个字符 $x,y,c$。其中 $x,y$ 为正整数，$c\\in \\{\\texttt{T},\\texttt{N}\\}$，$x\\neq y$。\n- 若 $c=\\texttt{T}$，表示 $y$ 必须是 $x$ 的祖先；\n- 否则，表示 $y$ 必须不是 $x$ 的祖先。\n\n保证不会重复给出同一条信息。", "outputFormat": "\n若无解，输出一行一个 $\\texttt{NIE}$；\n\n否则输出 $n$ 行，每行一个整数，表示 $i$ 号点的父亲。\n\n- 特别地，若 $i$ 是根，则规定其父亲为 $0$。", "hint": "\n\n- $1\\le n\\le 10^3$；\n- $0\\le m\\le \\min(n(n-1), 10^4)$；\n- $1\\le x,y\\le n$，$x\\neq y$。\n\n保证不会重复给出同一条信息。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2016] 构树 / Reorganizacja", "background": "译自 [Potyczki Algorytmiczne 2016](https://sio2.mimuw.edu.pl/c/pa-2016-1/p/) R2 Reorganizacja [A] (REO)。$\\texttt{1s,256M}$。\n", "description": "构造一棵 $n$ 个节点的有根树，满足 $m$ 条限制，形如「$x$ 必须是 $y$ 的祖先」或者「$x$ 必须不是 $y$ 的祖先」。\n", "inputFormat": "\n第一行，两个整数 $n,m$。\n\n接下来 $m$ 行，每行两个正整数和一个字符 $x,y,c$。其中 $x,y$ 为正整数，$c\\in \\{\\texttt{T},\\texttt{N}\\}$，$x\\neq y$。\n- 若 $c=\\texttt{T}$，表示 $y$ 必须是 $x$ 的祖先；\n- 否则，表示 $y$ 必须不是 $x$ 的祖先。\n\n保证不会重复给出同一条信息。", "outputFormat": "\n若无解，输出一行一个 $\\texttt{NIE}$；\n\n否则输出 $n$ 行，每行一个整数，表示 $i$ 号点的父亲。\n\n- 特别地，若 $i$ 是根，则规定其父亲为 $0$。", "hint": "\n\n- $1\\le n\\le 10^3$；\n- $0\\le m\\le \\min(n(n-1), 10^4)$；\n- $1\\le x,y\\le n$，$x\\neq y$。\n\n保证不会重复给出同一条信息。", "locale": "zh-CN"}}}
{"pid": "P11607", "type": "P", "difficulty": 5, "samples": [["2 200 2\n\n0\n\n1\n\n1", "\n? 0 0\n\n? 1 1\n\n? 2 2\n\n! 2 2"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2016", "二分", "交互题", "Special Judge", "PA（波兰）"], "title": "[PA 2016] 寻踪 / Ciepło-zimno", "background": "\n译自 [Potyczki Algorytmiczne 2016](https://sio2.mimuw.edu.pl/c/pa-2016-1/p/) R3 Ciepło-zimno [B] (CIE)。$\\texttt{1s,256M}$。\n\n原题为函数式交互题。为了方便不同语言的选手提交，改为 IO 交互题。\n\n特殊的内存限制是交互库的限制导致的，和解法没有关系。", "description": "\n**这是一道交互题。**\n\n给定正常数 $n,k,r$。\n\n$n$ 维空间中，有一个整点 $P(p_1,p_2,\\ldots,p_n)$，满足 $p_i\\in [0,r]$。\n\n你有 $k$ 次询问机会，第 $i$ 次询问给定一个整点 $V_i(v_{i,1},v_{i,2},\\ldots,v_{i,n})$，回答为「$\\operatorname{dist}(V_i,P)$ 是/否**严格**小于 $\\operatorname{dist}(V_{i-1},P)$」。**特别地**，$i=1$ 时，答案总为否。\n\n注意，这里的 $\\operatorname{dist}(A,B)$ 表示 $A,B$ 之间的 **Chebyshev 距离**。也就是，$\\displaystyle \\operatorname{dist}(A,B)=\\max_{1\\le i\\le n} |A_i-B_i|$，这里 $A_i$ 表示点 $A$ 坐标在第 $i$ 维上的分量。\n\n利用询问找到点 $P$。\n\n### 实现细节\n\n**注意：本题的 IO 量可能很大，请注意使用快速的 IO 方式。**\n\n读入三个正整数 $n,k,r$。然后开始交互：\n\n- $\\texttt{?}$ $v_{i,1}$ $v_{i,2}$ $\\ldots$ $v_{i,n}$：询问「$\\operatorname{dist}(V_i,P)$ 是/否**严格**小于 $\\operatorname{dist}(V_{i-1},P)$」。\n    - 回答为 $0$，表示答案为否；回答为 $1$，表示答案为是；回答为 $-1$，表示你的程序已经被判为 WA，请**立刻终止程序**。\n        - 特别地，如果这是第一次询问，则（如果询问合法的话）回答总为 $0$。\n    - 你需要保证 $v_{i,j}\\in [0,r]$，且 $v_{i,j}$ 为整数。\n    - 最多可以询问 $k$ 次。\n- $\\texttt{!}$ $p_{1}$ $p_{2}$ $\\ldots$ $p_{n}$：回答 $P$ 的位置。\n    - 回答后，你的程序需要立刻终止，不要输出多余内容。\n\n**每次询问或者回答之后，都要换行并刷新缓冲区。** 以下是一些例子：\n\n- C++：`fflush(stdout)`，`std::cout<<std::endl`；\n- Java：`System.out.flush()`；\n- Pascal：`flush(output)`；\n- Python：`sys.stdout.flush()`。", "inputFormat": "见【实现细节】。\n", "outputFormat": "见【实现细节】。\n", "hint": "\n\n- $1\\le n\\le 500$；\n- $k\\ge 100\\cdot n$；\n- $2\\le r\\le 10^9$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2016] 寻踪 / Ciepło-zimno", "background": "\n译自 [Potyczki Algorytmiczne 2016](https://sio2.mimuw.edu.pl/c/pa-2016-1/p/) R3 Ciepło-zimno [B] (CIE)。$\\texttt{1s,256M}$。\n\n原题为函数式交互题。为了方便不同语言的选手提交，改为 IO 交互题。\n\n特殊的内存限制是交互库的限制导致的，和解法没有关系。", "description": "\n**这是一道交互题。**\n\n给定正常数 $n,k,r$。\n\n$n$ 维空间中，有一个整点 $P(p_1,p_2,\\ldots,p_n)$，满足 $p_i\\in [0,r]$。\n\n你有 $k$ 次询问机会，第 $i$ 次询问给定一个整点 $V_i(v_{i,1},v_{i,2},\\ldots,v_{i,n})$，回答为「$\\operatorname{dist}(V_i,P)$ 是/否**严格**小于 $\\operatorname{dist}(V_{i-1},P)$」。**特别地**，$i=1$ 时，答案总为否。\n\n注意，这里的 $\\operatorname{dist}(A,B)$ 表示 $A,B$ 之间的 **Chebyshev 距离**。也就是，$\\displaystyle \\operatorname{dist}(A,B)=\\max_{1\\le i\\le n} |A_i-B_i|$，这里 $A_i$ 表示点 $A$ 坐标在第 $i$ 维上的分量。\n\n利用询问找到点 $P$。\n\n### 实现细节\n\n**注意：本题的 IO 量可能很大，请注意使用快速的 IO 方式。**\n\n读入三个正整数 $n,k,r$。然后开始交互：\n\n- $\\texttt{?}$ $v_{i,1}$ $v_{i,2}$ $\\ldots$ $v_{i,n}$：询问「$\\operatorname{dist}(V_i,P)$ 是/否**严格**小于 $\\operatorname{dist}(V_{i-1},P)$」。\n    - 回答为 $0$，表示答案为否；回答为 $1$，表示答案为是；回答为 $-1$，表示你的程序已经被判为 WA，请**立刻终止程序**。\n        - 特别地，如果这是第一次询问，则（如果询问合法的话）回答总为 $0$。\n    - 你需要保证 $v_{i,j}\\in [0,r]$，且 $v_{i,j}$ 为整数。\n    - 最多可以询问 $k$ 次。\n- $\\texttt{!}$ $p_{1}$ $p_{2}$ $\\ldots$ $p_{n}$：回答 $P$ 的位置。\n    - 回答后，你的程序需要立刻终止，不要输出多余内容。\n\n**每次询问或者回答之后，都要换行并刷新缓冲区。** 以下是一些例子：\n\n- C++：`fflush(stdout)`，`std::cout<<std::endl`；\n- Java：`System.out.flush()`；\n- Pascal：`flush(output)`；\n- Python：`sys.stdout.flush()`。", "inputFormat": "见【实现细节】。\n", "outputFormat": "见【实现细节】。\n", "hint": "\n\n- $1\\le n\\le 500$；\n- $k\\ge 100\\cdot n$；\n- $2\\le r\\le 10^9$。\n", "locale": "zh-CN"}}}
