{"pid": "P14359", "type": "P", "difficulty": 3, "samples": [["4 2\n2 1 0 3\n", "2"], ["4 3\n2 1 0 3", "2"], ["4 0\n2 1 0 3", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "贪心", "2025", "O2优化", "哈希 hashing", "前缀和", "位运算", "CSP-J 入门级"], "title": "[CSP-J 2025] 异或和", "background": null, "description": "小 R 有一个长度为 $n$ 的非负整数序列 $a_1, a_2, \\dots, a_n$。定义一个区间 $[l, r]$ ($1 \\leq l \\leq r \\leq n$) 的权值为 $a_l, a_{l+1}, \\dots, a_r$ 的二进制按位异或和，即 $a_l \\oplus a_{l+1} \\oplus \\dots \\oplus a_r$，其中 $\\oplus$ 表示二进制按位异或。\n\n小 X 给了小 R 一个非负整数 $k$。小 X 希望小 R 选择序列中尽可能多的**不相交**的区间，使得每个区间的权值均为 $k$。两个区间 $[l_1, r_1], [l_2, r_2]$ 相交当且仅当两个区间同时包含至少一个相同的下标，即存在 $1 \\leq i \\leq n$ 使得 $l_1 \\leq i \\leq r_1$ 且 $l_2 \\leq i \\leq r_2$。\n\n例如，对于序列 $[2, 1, 0, 3]$，若 $k = 2$，则小 R 可以选择区间 $[1, 1]$ 和区间 $[2, 4]$，权值分别为 $2$ 和 $1 \\oplus 0 \\oplus 3 = 2$；若 $k = 3$，则小 R 可以选择区间 $[1, 2]$ 和区间 $[4, 4]$，权值分别为 $1 \\oplus 2 = 3$ 和 $3$。\n\n你需要帮助小 R 求出他能选出的区间数量的最大值。", "inputFormat": "输入的第一行包含两个非负整数 $n, k$，分别表示小 R 的序列长度和小 X 给小 R 的非负整数。\n\n输入的第二行包含 $n$ 个非负整数 $a_1, a_2, \\dots, a_n$，表示小 R 的序列。", "outputFormat": "输出一行一个非负整数，表示小 R 能选出的区间数量的最大值。", "hint": "### 【样例 1 解释】\n\n小 R 可以选择区间 $[1, 1]$ 和区间 $[2, 4]$，异或和分别为 $2$ 和 $1 \\oplus 0 \\oplus 3 = 2$。可以证明，小 R 能选出的区间数量的最大值为 $2$。\n\n### 【样例 2 解释】\n\n小 R 可以选择区间 $[1, 2]$ 和区间 $[4, 4]$，异或和分别为 $1 \\oplus 2 = 3$ 和 $3$。可以证明，小 R 能选出的区间数量的最大值为 $2$。\n\n### 【样例 3 解释】\n\n小 R 可以选择区间 $[3, 3]$，异或和为 $0$。可以证明，小 R 能选出的区间数量的最大值为 $1$。注意：小 R 不能同时选择区间 $[3, 3]$ 和区间 $[1, 4]$，因为这两个区间同时包含下标 $3$。\n\n### 【样例 4】\n\n见选手目录下的 $xor/xor4.in$ 与 $xor/xor4.ans$。\n\n该样例满足测试点 $4, 5$ 的约束条件。\n\n### 【样例 5】\n\n见选手目录下的 $xor/xor5.in$ 与 $xor/xor5.ans$。\n\n该样例满足测试点 $9, 10$ 的约束条件。\n\n### 【样例 6】\n\n见选手目录下的 $xor/xor6.in$ 与 $xor/xor6.ans$。\n\n该样例满足测试点 $14, 15$ 的约束条件。\n\n### 【数据范围】\n\n对于所有测试数据，保证：\n- $1 \\leq n \\leq 5 \\times 10^5$, $0 \\leq k < 2^{20}$;\n- 对于所有 $1 \\leq i \\leq n$，均有 $0 \\leq a_i < 2^{20}$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n \\leq$ | $k$ | 特殊性质 |\n| :--: | :--: | :--: | :--: |\n| $1$ | $2$ | $=0$ | A |\n| $2$ | $10$ | $\\leq 1$ | B |\n| $3$ | $10^2$ | $=0$ | A |\n| $4, 5$ | ^ | $\\leq 1$ | B |\n| $6 \\sim 8$ | ^ | $\\leq 255$ | C |\n| $9, 10$ | $10^3$ | ^ | ^ |\n| $11, 12$ | ^ | $< 2^{20}$ | 无 |\n| $13$ | $2 \\times 10^5$ | $\\leq 1$ | B |\n| $14, 15$ | ^ | $\\leq 255$ | C |\n| $16$ | ^ | $< 2^{20}$ | 无 |\n| $17$ | $5 \\times 10^5$ | $\\leq 255$ | C |\n| $18 \\sim 20$ | ^ | $< 2^{20}$ | 无 |\n\n特殊性质 A: 对于所有 $1 \\leq i \\leq n$，均有 $a_i = 1$。\n\n特殊性质 B: 对于所有 $1 \\leq i \\leq n$，均有 $0 \\leq a_i \\leq 1$。\n\n特殊性质 C: 对于所有 $1 \\leq i \\leq n$，均有 $0 \\leq a_i \\leq 255$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-J 2025] 异或和", "background": null, "description": "小 R 有一个长度为 $n$ 的非负整数序列 $a_1, a_2, \\dots, a_n$。定义一个区间 $[l, r]$ ($1 \\leq l \\leq r \\leq n$) 的权值为 $a_l, a_{l+1}, \\dots, a_r$ 的二进制按位异或和，即 $a_l \\oplus a_{l+1} \\oplus \\dots \\oplus a_r$，其中 $\\oplus$ 表示二进制按位异或。\n\n小 X 给了小 R 一个非负整数 $k$。小 X 希望小 R 选择序列中尽可能多的**不相交**的区间，使得每个区间的权值均为 $k$。两个区间 $[l_1, r_1], [l_2, r_2]$ 相交当且仅当两个区间同时包含至少一个相同的下标，即存在 $1 \\leq i \\leq n$ 使得 $l_1 \\leq i \\leq r_1$ 且 $l_2 \\leq i \\leq r_2$。\n\n例如，对于序列 $[2, 1, 0, 3]$，若 $k = 2$，则小 R 可以选择区间 $[1, 1]$ 和区间 $[2, 4]$，权值分别为 $2$ 和 $1 \\oplus 0 \\oplus 3 = 2$；若 $k = 3$，则小 R 可以选择区间 $[1, 2]$ 和区间 $[4, 4]$，权值分别为 $1 \\oplus 2 = 3$ 和 $3$。\n\n你需要帮助小 R 求出他能选出的区间数量的最大值。", "inputFormat": "输入的第一行包含两个非负整数 $n, k$，分别表示小 R 的序列长度和小 X 给小 R 的非负整数。\n\n输入的第二行包含 $n$ 个非负整数 $a_1, a_2, \\dots, a_n$，表示小 R 的序列。", "outputFormat": "输出一行一个非负整数，表示小 R 能选出的区间数量的最大值。", "hint": "### 【样例 1 解释】\n\n小 R 可以选择区间 $[1, 1]$ 和区间 $[2, 4]$，异或和分别为 $2$ 和 $1 \\oplus 0 \\oplus 3 = 2$。可以证明，小 R 能选出的区间数量的最大值为 $2$。\n\n### 【样例 2 解释】\n\n小 R 可以选择区间 $[1, 2]$ 和区间 $[4, 4]$，异或和分别为 $1 \\oplus 2 = 3$ 和 $3$。可以证明，小 R 能选出的区间数量的最大值为 $2$。\n\n### 【样例 3 解释】\n\n小 R 可以选择区间 $[3, 3]$，异或和为 $0$。可以证明，小 R 能选出的区间数量的最大值为 $1$。注意：小 R 不能同时选择区间 $[3, 3]$ 和区间 $[1, 4]$，因为这两个区间同时包含下标 $3$。\n\n### 【样例 4】\n\n见选手目录下的 $xor/xor4.in$ 与 $xor/xor4.ans$。\n\n该样例满足测试点 $4, 5$ 的约束条件。\n\n### 【样例 5】\n\n见选手目录下的 $xor/xor5.in$ 与 $xor/xor5.ans$。\n\n该样例满足测试点 $9, 10$ 的约束条件。\n\n### 【样例 6】\n\n见选手目录下的 $xor/xor6.in$ 与 $xor/xor6.ans$。\n\n该样例满足测试点 $14, 15$ 的约束条件。\n\n### 【数据范围】\n\n对于所有测试数据，保证：\n- $1 \\leq n \\leq 5 \\times 10^5$, $0 \\leq k < 2^{20}$;\n- 对于所有 $1 \\leq i \\leq n$，均有 $0 \\leq a_i < 2^{20}$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n \\leq$ | $k$ | 特殊性质 |\n| :--: | :--: | :--: | :--: |\n| $1$ | $2$ | $=0$ | A |\n| $2$ | $10$ | $\\leq 1$ | B |\n| $3$ | $10^2$ | $=0$ | A |\n| $4, 5$ | ^ | $\\leq 1$ | B |\n| $6 \\sim 8$ | ^ | $\\leq 255$ | C |\n| $9, 10$ | $10^3$ | ^ | ^ |\n| $11, 12$ | ^ | $< 2^{20}$ | 无 |\n| $13$ | $2 \\times 10^5$ | $\\leq 1$ | B |\n| $14, 15$ | ^ | $\\leq 255$ | C |\n| $16$ | ^ | $< 2^{20}$ | 无 |\n| $17$ | $5 \\times 10^5$ | $\\leq 255$ | C |\n| $18 \\sim 20$ | ^ | $< 2^{20}$ | 无 |\n\n特殊性质 A: 对于所有 $1 \\leq i \\leq n$，均有 $a_i = 1$。\n\n特殊性质 B: 对于所有 $1 \\leq i \\leq n$，均有 $0 \\leq a_i \\leq 1$。\n\n特殊性质 C: 对于所有 $1 \\leq i \\leq n$，均有 $0 \\leq a_i \\leq 255$。", "locale": "zh-CN"}}}
{"pid": "P14360", "type": "P", "difficulty": 3, "samples": [["5\n1 2 3 4 5", "9"], ["5\n2 2 3 8 10", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2025", "O2优化", "背包 DP", "CSP-J 入门级"], "title": "[CSP-J 2025] 多边形", "background": "", "description": "小 R 喜欢玩小木棍。小 R 有 $n$ 根小木棍，第 $i$ ($1 \\leq i \\leq n$) 根小木棍的长度为 $a_i$。\n\n小 X 希望小 R 从这 $n$ 根小木棍中选出若干根小木棍，将它们按任意顺序首尾相连拼成一个多边形。小 R 并不知道小木棍能拼成多边形的条件，于是小 X 直接将条件告诉了他：对于长度分别为 $l_1, l_2, \\dots, l_m$ 的 $m$ 根小木棍，这 $m$ 根小木棍能拼成一个多边形当且仅当 $m \\geq 3$ 且所有小木棍的长度之和**大于**所有小木棍的长度最大值的两倍，即 $\\sum_{i=1}^{m} l_i > 2 \\times \\max_{i=1}^{m} l_i$。\n\n由于小 R 知道了小木棍能拼成多边形的条件，小 X 提出了一个更难的问题：有多少种选择小木棍的方案，使得选出的小木棍能够拼成一个多边形？你需要帮助小 R 求出选出的小木棍能够拼成一个多边形的方案数。两种方案不同当且仅当选择的小木棍的**下标集合不同**，即存在 $1 \\leq i \\leq n$，使得其中一种方案选择了第 $i$ 根小木棍，但另一种方案未选择。由于答案可能较大，你只需要求出答案对 $998,244,353$ 取模后的结果。", "inputFormat": "输入的第一行包含一个正整数 $n$，表示小 R 的小木棍的数量。\n\n输入的第二行包含 $n$ 个正整数 $a_1, a_2, \\dots, a_n$，表示小 R 的小木棍的长度。", "outputFormat": "输出一行一个非负整数，表示小 R 选出的小木棍能够拼成一个多边形的方案数对 $998,244,353$ 取模后的结果。", "hint": "### 【样例 1 解释】\n\n共有以下 $9$ 种选择小木棍的方案，使得选出的小木棍能够拼成一个多边形：\n1. 选择第 $2, 3, 4$ 根小木棍，长度之和为 $2 + 3 + 4 = 9$，长度最大值为 $4$;\n2. 选择第 $2, 4, 5$ 根小木棍，长度之和为 $2 + 4 + 5 = 11$，长度最大值为 $5$;\n3. 选择第 $3, 4, 5$ 根小木棍，长度之和为 $3 + 4 + 5 = 12$，长度最大值为 $5$;\n4. 选择第 $1, 2, 3, 4$ 根小木棍，长度之和为 $1 + 2 + 3 + 4 = 10$，长度最大值为 $4$;\n5. 选择第 $1, 2, 3, 5$ 根小木棍，长度之和为 $1 + 2 + 3 + 5 = 11$，长度最大值为 $5$;\n6. 选择第 $1, 2, 4, 5$ 根小木棍，长度之和为 $1 + 2 + 4 + 5 = 12$，长度最大值为 $5$;\n7. 选择第 $1, 3, 4, 5$ 根小木棍，长度之和为 $1 + 3 + 4 + 5 = 13$，长度最大值为 $5$;\n8. 选择第 $2, 3, 4, 5$ 根小木棍，长度之和为 $2 + 3 + 4 + 5 = 14$，长度最大值为 $5$;\n9. 选择第 $1, 2, 3, 4, 5$ 根小木棍，长度之和为 $1 + 2 + 3 + 4 + 5 = 15$，长度最大值为 $5$。\n\n### 【样例 2 解释】\n\n共有以下 $6$ 种选择小木棍的方案，使得选出的小木棍能够拼成一个多边形：\n1. 选择第 $1, 2, 3$ 根小木棍，长度之和为 $2 + 2 + 3 = 7$，长度最大值为 $3$;\n2. 选择第 $3, 4, 5$ 根小木棍，长度之和为 $3 + 8 + 10 = 21$，长度最大值为 $10$;\n3. 选择第 $1, 2, 4, 5$ 根小木棍，长度之和为 $2 + 2 + 8 + 10 = 22$，长度最大值为 $10$;\n4. 选择第 $1, 3, 4, 5$ 根小木棍，长度之和为 $2 + 3 + 8 + 10 = 23$，长度最大值为 $10$;\n5. 选择第 $2, 3, 4, 5$ 根小木棍，长度之和为 $2 + 3 + 8 + 10 = 23$，长度最大值为 $10$;\n6. 选择第 $1, 2, 3, 4, 5$ 根小木棍，长度之和为 $2 + 2 + 3 + 8 + 10 = 25$，长度最大值为 $10$。\n\n### 【样例 3】\n\n见选手目录下的 $\\textit{\\textbf{polygon/polygon3.in}}$ 与 $\\textit{\\textbf{polygon/polygon3.ans}}$。\n\n该样例满足测试点 $7 \\sim 10$ 的约束条件。\n\n### 【样例 4】\n\n见选手目录下的 $\\textit{\\textbf{polygon/polygon4.in}}$ 与 $\\textit{\\textbf{polygon/polygon4.ans}}$。\n\n该样例满足测试点 $11 \\sim 14$ 的约束条件。\n\n### 【子任务】\n\n对于所有测试数据，保证：\n- $3 \\leq n \\leq 5\\,000$;\n- 对于所有 $1 \\leq i \\leq n$，均有 $1 \\leq a_i \\leq 5\\,000$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n \\leq$ | $\\max_{i=1}^{n} a_i \\leq$ |\n| :--: | :--: | :--: |\n| $1 \\sim 3$ | $3$ | $10$ |\n| $4 \\sim 6$ | $10$ | $10^2$|\n| $7 \\sim 10$ | $20$ | ^ |\n| $11 \\sim 14$ | $500$ | ^ |\n| $15 \\sim 17$ | ^ | $1$ |\n| $18 \\sim 20$ | $5\\,000$ | ^ |\n| $21 \\sim 25$ | ^ | $5\\,000$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-J 2025] 多边形", "background": "", "description": "小 R 喜欢玩小木棍。小 R 有 $n$ 根小木棍，第 $i$ ($1 \\leq i \\leq n$) 根小木棍的长度为 $a_i$。\n\n小 X 希望小 R 从这 $n$ 根小木棍中选出若干根小木棍，将它们按任意顺序首尾相连拼成一个多边形。小 R 并不知道小木棍能拼成多边形的条件，于是小 X 直接将条件告诉了他：对于长度分别为 $l_1, l_2, \\dots, l_m$ 的 $m$ 根小木棍，这 $m$ 根小木棍能拼成一个多边形当且仅当 $m \\geq 3$ 且所有小木棍的长度之和**大于**所有小木棍的长度最大值的两倍，即 $\\sum_{i=1}^{m} l_i > 2 \\times \\max_{i=1}^{m} l_i$。\n\n由于小 R 知道了小木棍能拼成多边形的条件，小 X 提出了一个更难的问题：有多少种选择小木棍的方案，使得选出的小木棍能够拼成一个多边形？你需要帮助小 R 求出选出的小木棍能够拼成一个多边形的方案数。两种方案不同当且仅当选择的小木棍的**下标集合不同**，即存在 $1 \\leq i \\leq n$，使得其中一种方案选择了第 $i$ 根小木棍，但另一种方案未选择。由于答案可能较大，你只需要求出答案对 $998,244,353$ 取模后的结果。", "inputFormat": "输入的第一行包含一个正整数 $n$，表示小 R 的小木棍的数量。\n\n输入的第二行包含 $n$ 个正整数 $a_1, a_2, \\dots, a_n$，表示小 R 的小木棍的长度。", "outputFormat": "输出一行一个非负整数，表示小 R 选出的小木棍能够拼成一个多边形的方案数对 $998,244,353$ 取模后的结果。", "hint": "### 【样例 1 解释】\n\n共有以下 $9$ 种选择小木棍的方案，使得选出的小木棍能够拼成一个多边形：\n1. 选择第 $2, 3, 4$ 根小木棍，长度之和为 $2 + 3 + 4 = 9$，长度最大值为 $4$;\n2. 选择第 $2, 4, 5$ 根小木棍，长度之和为 $2 + 4 + 5 = 11$，长度最大值为 $5$;\n3. 选择第 $3, 4, 5$ 根小木棍，长度之和为 $3 + 4 + 5 = 12$，长度最大值为 $5$;\n4. 选择第 $1, 2, 3, 4$ 根小木棍，长度之和为 $1 + 2 + 3 + 4 = 10$，长度最大值为 $4$;\n5. 选择第 $1, 2, 3, 5$ 根小木棍，长度之和为 $1 + 2 + 3 + 5 = 11$，长度最大值为 $5$;\n6. 选择第 $1, 2, 4, 5$ 根小木棍，长度之和为 $1 + 2 + 4 + 5 = 12$，长度最大值为 $5$;\n7. 选择第 $1, 3, 4, 5$ 根小木棍，长度之和为 $1 + 3 + 4 + 5 = 13$，长度最大值为 $5$;\n8. 选择第 $2, 3, 4, 5$ 根小木棍，长度之和为 $2 + 3 + 4 + 5 = 14$，长度最大值为 $5$;\n9. 选择第 $1, 2, 3, 4, 5$ 根小木棍，长度之和为 $1 + 2 + 3 + 4 + 5 = 15$，长度最大值为 $5$。\n\n### 【样例 2 解释】\n\n共有以下 $6$ 种选择小木棍的方案，使得选出的小木棍能够拼成一个多边形：\n1. 选择第 $1, 2, 3$ 根小木棍，长度之和为 $2 + 2 + 3 = 7$，长度最大值为 $3$;\n2. 选择第 $3, 4, 5$ 根小木棍，长度之和为 $3 + 8 + 10 = 21$，长度最大值为 $10$;\n3. 选择第 $1, 2, 4, 5$ 根小木棍，长度之和为 $2 + 2 + 8 + 10 = 22$，长度最大值为 $10$;\n4. 选择第 $1, 3, 4, 5$ 根小木棍，长度之和为 $2 + 3 + 8 + 10 = 23$，长度最大值为 $10$;\n5. 选择第 $2, 3, 4, 5$ 根小木棍，长度之和为 $2 + 3 + 8 + 10 = 23$，长度最大值为 $10$;\n6. 选择第 $1, 2, 3, 4, 5$ 根小木棍，长度之和为 $2 + 2 + 3 + 8 + 10 = 25$，长度最大值为 $10$。\n\n### 【样例 3】\n\n见选手目录下的 $\\textit{\\textbf{polygon/polygon3.in}}$ 与 $\\textit{\\textbf{polygon/polygon3.ans}}$。\n\n该样例满足测试点 $7 \\sim 10$ 的约束条件。\n\n### 【样例 4】\n\n见选手目录下的 $\\textit{\\textbf{polygon/polygon4.in}}$ 与 $\\textit{\\textbf{polygon/polygon4.ans}}$。\n\n该样例满足测试点 $11 \\sim 14$ 的约束条件。\n\n### 【子任务】\n\n对于所有测试数据，保证：\n- $3 \\leq n \\leq 5\\,000$;\n- 对于所有 $1 \\leq i \\leq n$，均有 $1 \\leq a_i \\leq 5\\,000$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n \\leq$ | $\\max_{i=1}^{n} a_i \\leq$ |\n| :--: | :--: | :--: |\n| $1 \\sim 3$ | $3$ | $10$ |\n| $4 \\sim 6$ | $10$ | $10^2$|\n| $7 \\sim 10$ | $20$ | ^ |\n| $11 \\sim 14$ | $500$ | ^ |\n| $15 \\sim 17$ | ^ | $1$ |\n| $18 \\sim 20$ | $5\\,000$ | ^ |\n| $21 \\sim 25$ | ^ | $5\\,000$ |", "locale": "zh-CN"}}}
{"pid": "P14361", "type": "P", "difficulty": 3, "samples": [["3\n4\n4 2 1\n3 2 4\n5 3 4\n3 5 1\n4\n0 1 0\n0 1 0\n0 2 0\n0 2 0\n2\n10 9 8\n4 0 0", "18\n4\n13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2025", "O2优化", "排序", "CSP-S 提高级", "反悔贪心"], "title": "[CSP-S 2025] 社团招新", "background": "", "description": "小 L 是学校算法协会的成员。在今年的学校社团招新中，小 L 一共招收了 $n$ 个新成员，其中 $n$ 为**偶数**。现在小 L 希望将他们分到协会不同的部门。\n\n算法协会共设有三个部门，其中第 $i$ ($1 \\leq i \\leq n$) 个新成员对第 $j$ ($1 \\leq j \\leq 3$) 个部门的满意度为 $a_{i,j}$。定义一个分配方案的满意度为所有新成员对分配到的部门的满意度之和，也就是说，若将第 $i$ ($1 \\leq i \\leq n$) 个新成员分配到了第 $d_i \\in \\{1,2,3\\}$ 个部门，则该分配方案的满意度为 $\\sum_{i=1}^{n} a_{i,d_i}$。\n\n小 L 不希望某一个部门的新成员数量过多。具体地，他要求在分配方案中，不存在一个部门被分配多于 $\\frac{n}{2}$ 个新成员。你需要帮助小 L 求出，满足他要求的分配方案的满意度的最大值。", "inputFormat": "本题包含多组测试数据。\n\n输入的第一行包含一个正整数 $t$，表示测试数据组数。\n\n接下来依次输入每组测试数据，对于每组测试数据：\n\n- 第一行包含一个正整数 $n$，表示新成员的数量。\n- 第 $i+1$ ($1 \\leq i \\leq n$) 行包含三个非负整数 $a_{i,1}, a_{i,2}, a_{i,3}$，分别表示第 $i$ 个新成员对第 $1,2,3$ 个部门的满意度。", "outputFormat": "对于每组测试数据，输出一行一个非负整数，表示满足小 L 要求的分配方案的满意度的最大值。", "hint": "### 【样例 1 解释】\n\n该样例共包含三组测试数据。\n\n对于第一组测试数据，可以将四个新成员分别分配到第 $1,3,1,2$ 个部门，则三个部门的新成员数量分别为 $2,1,1$，均不超过 $\\frac{4}{2} = 2$，满意度为 $4 + 4 + 5 + 5 = 18$。\n\n对于第二组测试数据，可以将四个新成员分别分配到第 $1,1,2,2$ 个部门，则三个部门的新成员数量分别为 $2,2,0$，均不超过 $\\frac{4}{2} = 2$，满意度为 $0 + 0 + 2 + 2 = 4$。\n\n对于第三组测试数据，可以将两个新成员分别分配到第 $2,1$ 个部门，则三个部门的新成员数量分别为 $1,1,0$，均不超过 $\\frac{2}{2} = 1$，满意度为 $9 + 4 = 13$。\n\n### 【样例 2】\n\n见选手目录下的 $\\textbf{\\textit{club/club2.in}}$ 与 $\\textbf{\\textit{club/club2.ans}}$。\n\n该样例满足测试点 $3,4$ 的约束条件。\n\n### 【样例 3】\n\n见选手目录下的 $\\textbf{\\textit{club/club3.in}}$ 与 $\\textbf{\\textit{club/club3.ans}}$。\n\n该样例满足测试点 $5 \\sim 8$ 的约束条件。\n\n### 【样例 4】\n\n见选手目录下的 $\\textbf{\\textit{club/club4.in}}$ 与 $\\textbf{\\textit{club/club4.ans}}$。\n\n该样例满足测试点 $9$ 的约束条件。\n\n### 【样例 5】\n\n见选手目录下的 $\\textbf{\\textit{club/club5.in}}$ 与 $\\textbf{\\textit{club/club5.ans}}$。\n\n该样例满足测试点 $15,16$ 的约束条件。\n\n### 【数据范围】\n\n对于所有测试数据，保证：\n\n- $1 \\leq t \\leq 5$;\n- $2 \\leq n \\leq 10^5$，且 $n$ 为偶数;\n- 对于所有 $1 \\leq i \\leq n$，$1 \\leq j \\leq 3$，均有 $0 \\leq a_{i,j} \\leq 2 \\times 10^4$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n=$ | 特殊性质 |\n| :--: | :--: | :--: |\n| $1$ | $2$ | 无 |\n| $2$ | $4$ | ^ |\n| $3, 4$ | $10$ | ^ |\n| $5 \\sim 8$ | $30$ | ^ |\n| $9$ | $200$ | B |\n| $10, 11$ | ^ | 无 |\n| $12$ | $10^5$ | A |\n| $13, 14$ | ^ | B |\n| $15, 16$ | ^ | C |\n| $17 \\sim 20$ | ^ | 无 |\n\n\n特殊性质 A：对于所有 $1 \\leq i \\leq n$，均有 $a_{i,2} = a_{i,3} = 0$。\n\n特殊性质 B：对于所有 $1 \\leq i \\leq n$，均有 $a_{i,3} = 0$。\n\n特殊性质 C：对于所有 $1 \\leq i \\leq n$，$1 \\leq j \\leq 3$，$a_{i,j}$ 均在 $[0, 2 \\times 10^4]$ 中独立均匀随机生成。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-S 2025] 社团招新", "background": "", "description": "小 L 是学校算法协会的成员。在今年的学校社团招新中，小 L 一共招收了 $n$ 个新成员，其中 $n$ 为**偶数**。现在小 L 希望将他们分到协会不同的部门。\n\n算法协会共设有三个部门，其中第 $i$ ($1 \\leq i \\leq n$) 个新成员对第 $j$ ($1 \\leq j \\leq 3$) 个部门的满意度为 $a_{i,j}$。定义一个分配方案的满意度为所有新成员对分配到的部门的满意度之和，也就是说，若将第 $i$ ($1 \\leq i \\leq n$) 个新成员分配到了第 $d_i \\in \\{1,2,3\\}$ 个部门，则该分配方案的满意度为 $\\sum_{i=1}^{n} a_{i,d_i}$。\n\n小 L 不希望某一个部门的新成员数量过多。具体地，他要求在分配方案中，不存在一个部门被分配多于 $\\frac{n}{2}$ 个新成员。你需要帮助小 L 求出，满足他要求的分配方案的满意度的最大值。", "inputFormat": "本题包含多组测试数据。\n\n输入的第一行包含一个正整数 $t$，表示测试数据组数。\n\n接下来依次输入每组测试数据，对于每组测试数据：\n\n- 第一行包含一个正整数 $n$，表示新成员的数量。\n- 第 $i+1$ ($1 \\leq i \\leq n$) 行包含三个非负整数 $a_{i,1}, a_{i,2}, a_{i,3}$，分别表示第 $i$ 个新成员对第 $1,2,3$ 个部门的满意度。", "outputFormat": "对于每组测试数据，输出一行一个非负整数，表示满足小 L 要求的分配方案的满意度的最大值。", "hint": "### 【样例 1 解释】\n\n该样例共包含三组测试数据。\n\n对于第一组测试数据，可以将四个新成员分别分配到第 $1,3,1,2$ 个部门，则三个部门的新成员数量分别为 $2,1,1$，均不超过 $\\frac{4}{2} = 2$，满意度为 $4 + 4 + 5 + 5 = 18$。\n\n对于第二组测试数据，可以将四个新成员分别分配到第 $1,1,2,2$ 个部门，则三个部门的新成员数量分别为 $2,2,0$，均不超过 $\\frac{4}{2} = 2$，满意度为 $0 + 0 + 2 + 2 = 4$。\n\n对于第三组测试数据，可以将两个新成员分别分配到第 $2,1$ 个部门，则三个部门的新成员数量分别为 $1,1,0$，均不超过 $\\frac{2}{2} = 1$，满意度为 $9 + 4 = 13$。\n\n### 【样例 2】\n\n见选手目录下的 $\\textbf{\\textit{club/club2.in}}$ 与 $\\textbf{\\textit{club/club2.ans}}$。\n\n该样例满足测试点 $3,4$ 的约束条件。\n\n### 【样例 3】\n\n见选手目录下的 $\\textbf{\\textit{club/club3.in}}$ 与 $\\textbf{\\textit{club/club3.ans}}$。\n\n该样例满足测试点 $5 \\sim 8$ 的约束条件。\n\n### 【样例 4】\n\n见选手目录下的 $\\textbf{\\textit{club/club4.in}}$ 与 $\\textbf{\\textit{club/club4.ans}}$。\n\n该样例满足测试点 $9$ 的约束条件。\n\n### 【样例 5】\n\n见选手目录下的 $\\textbf{\\textit{club/club5.in}}$ 与 $\\textbf{\\textit{club/club5.ans}}$。\n\n该样例满足测试点 $15,16$ 的约束条件。\n\n### 【数据范围】\n\n对于所有测试数据，保证：\n\n- $1 \\leq t \\leq 5$;\n- $2 \\leq n \\leq 10^5$，且 $n$ 为偶数;\n- 对于所有 $1 \\leq i \\leq n$，$1 \\leq j \\leq 3$，均有 $0 \\leq a_{i,j} \\leq 2 \\times 10^4$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n=$ | 特殊性质 |\n| :--: | :--: | :--: |\n| $1$ | $2$ | 无 |\n| $2$ | $4$ | ^ |\n| $3, 4$ | $10$ | ^ |\n| $5 \\sim 8$ | $30$ | ^ |\n| $9$ | $200$ | B |\n| $10, 11$ | ^ | 无 |\n| $12$ | $10^5$ | A |\n| $13, 14$ | ^ | B |\n| $15, 16$ | ^ | C |\n| $17 \\sim 20$ | ^ | 无 |\n\n\n特殊性质 A：对于所有 $1 \\leq i \\leq n$，均有 $a_{i,2} = a_{i,3} = 0$。\n\n特殊性质 B：对于所有 $1 \\leq i \\leq n$，均有 $a_{i,3} = 0$。\n\n特殊性质 C：对于所有 $1 \\leq i \\leq n$，$1 \\leq j \\leq 3$，$a_{i,j}$ 均在 $[0, 2 \\times 10^4]$ 中独立均匀随机生成。", "locale": "zh-CN"}}}
{"pid": "P14362", "type": "P", "difficulty": 5, "samples": [["4 4 2\n1 4 6\n2 3 7\n4 2 5\n4 3 4\n1 1 8 2 4\n100 1 3 2 4", "13"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "2025", "O2优化", "生成树", "CSP-S 提高级"], "title": "[CSP-S 2025] 道路修复", "background": "由于评测机性能差异，本题时限提升 1 秒。", "description": "C 国的交通系统由 $n$ 座城市与 $m$ 条连接两座城市的双向道路构成，第 $i$ ($1 \\leq i \\leq m$) 条道路连接城市 $u_i$ 和 $v_i$。**任意两座城市都能通过若干条道路相互到达。**\n\n然而，近期由于一场大地震，所有 $m$ 条道路都被破坏了，修复第 $i$ ($1 \\leq i \\leq m$) 条道路的费用为 $w_i$。与此同时，C 国还有 $k$ 个准备进行城市化改造的乡镇。对于第 $j$ ($1 \\leq j \\leq k$) 个乡镇，C 国对其进行城市化改造的费用为 $c_j$。在城市化改造完第 $j$ ($1 \\leq j \\leq k$) 个乡镇后，可以在这个乡镇与原来的 $n$ 座城市间建造若干条道路，其中在它与第 $i$ ($1 \\leq i \\leq n$) 座城市间建造一条道路的费用为 $a_{j,i}$。C 国可以在这 $k$ 个乡镇中选择**任意多个**进行城市化改造，也可以不选择任何乡镇进行城市化改造。\n\n为尽快恢复城市间的交通，C 国政$ $府希望以最低的费用将**原有**的 $n$ 座城市两两连通，也即任意两座原有的城市都能通过若干条修复或新建造的道路相互到达。你需要帮助他们求出，将原有的 $n$ 座城市两两连通的最小费用。", "inputFormat": "输入的第一行包含三个非负整数 $n, m, k$，分别表示原有的城市数量、道路数量和准备进行城市化改造的乡镇数量。\n\n输入的第 $i+1$ ($1 \\leq i \\leq m$) 行包含三个非负整数 $u_i, v_i, w_i$，表示第 $i$ 条道路连接的两座城市与修复该道路的费用。\n\n输入的第 $j+m+1$ ($1 \\leq j \\leq k$) 行包含 $n+1$ 个非负整数 $c_j, a_{j,1}, a_{j,2}, \\ldots, a_{j,n}$，分别表示将第 $j$ 个乡镇进行城市化改造的费用与在该乡镇与原有的城市间建造道路的费用。", "outputFormat": "输出一行一个非负整数，表示将原有的 $n$ 座城市两两连通的最小费用。", "hint": "### 【样例 1 解释】\n\nC 国政$ $府可以选择修复第 $3$ 条和第 $4$ 条道路，然后将第 $1$ 个乡镇进行城市化改造，并建造它与第 $1,3$ 座城市间的道路，总费用为 $5 + 4 + 1 + 1 + 2 = 13$。可以证明，不存在比 $13$ 更小的费用能使原有的 $4$ 座城市两两连通。\n\n### 【样例 2】\n\n见选手目录下的 $\\textbf{\\textit{road/road2.in}}$ 与 $\\textbf{\\textit{road/road2.ans}}$。\n\n该样例满足测试点 $11,12$ 的约束条件。\n\n### 【样例 3】\n\n见选手目录下的 $\\textbf{\\textit{road/road3.in}}$ 与 $\\textbf{\\textit{road/road3.ans}}$。\n\n该样例满足测试点 $13,14$ 的约束条件。\n\n### 【样例 4】\n\n见选手目录下的 $\\textbf{\\textit{road/road4.in}}$ 与 $\\textbf{\\textit{road/road4.ans}}$。\n\n该样例满足测试点 $15,16$ 的约束条件。\n\n### 【数据范围】\n\n对于所有测试数据，保证：\n\n- $1 \\leq n \\leq 10^4$，$1 \\leq m \\leq 10^6$，$0 \\leq k \\leq 10$；\n- 对于所有 $1 \\leq i \\leq m$，均有 $1 \\leq u_i, v_i \\leq n$，$u_i \\neq v_i$ 且 $0 \\leq w_i \\leq 10^9$；\n- 对于所有 $1 \\leq j \\leq k$，均有 $0 \\leq c_j \\leq 10^9$；\n- 对于所有 $1 \\leq j \\leq k$，$1 \\leq i \\leq n$，均有 $0 \\leq a_{j,i} \\leq 10^9$；\n- 任意两座原有的城市都能通过若干条原有的道路相互到达。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n \\leq$ | $m \\leq$ | $k \\leq$ | 特殊性质 |\n| :--: | :--: | :--: | :--: | :--: |\n| $1 \\sim 4$ | $10^4$ | $10^6$ | $0$ | 无 |\n| $5, 6$ | $10^3$ | $10^5$ | $5$ | A |\n| $7, 8$ | ^ | ^ | ^ | 无 |\n| $9, 10$ | ^ | $10^6$ | ^ | A |\n| $11, 12$ | ^ | ^ | ^ | 无 |\n| $13, 14$ | ^ | ^ | $10$ | A |\n| $15, 16$ | ^ | ^ | ^ | 无 |\n| $17, 18$ | $10^4$ | ^ | $5$ | A |\n| $19, 20$ | ^ | ^ | ^ | 无 |\n| $21 \\sim 25$ | ^ | ^ | $10$ | ^ |\n\n特殊性质 A：对于所有 $1 \\leq j \\leq k$，均有 $c_j = 0$ 且均存在 $1 \\leq i \\leq n$ 满足 $a_{j,i} = 0$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-S 2025] 道路修复", "background": "由于评测机性能差异，本题时限提升 1 秒。", "description": "C 国的交通系统由 $n$ 座城市与 $m$ 条连接两座城市的双向道路构成，第 $i$ ($1 \\leq i \\leq m$) 条道路连接城市 $u_i$ 和 $v_i$。**任意两座城市都能通过若干条道路相互到达。**\n\n然而，近期由于一场大地震，所有 $m$ 条道路都被破坏了，修复第 $i$ ($1 \\leq i \\leq m$) 条道路的费用为 $w_i$。与此同时，C 国还有 $k$ 个准备进行城市化改造的乡镇。对于第 $j$ ($1 \\leq j \\leq k$) 个乡镇，C 国对其进行城市化改造的费用为 $c_j$。在城市化改造完第 $j$ ($1 \\leq j \\leq k$) 个乡镇后，可以在这个乡镇与原来的 $n$ 座城市间建造若干条道路，其中在它与第 $i$ ($1 \\leq i \\leq n$) 座城市间建造一条道路的费用为 $a_{j,i}$。C 国可以在这 $k$ 个乡镇中选择**任意多个**进行城市化改造，也可以不选择任何乡镇进行城市化改造。\n\n为尽快恢复城市间的交通，C 国政$ $府希望以最低的费用将**原有**的 $n$ 座城市两两连通，也即任意两座原有的城市都能通过若干条修复或新建造的道路相互到达。你需要帮助他们求出，将原有的 $n$ 座城市两两连通的最小费用。", "inputFormat": "输入的第一行包含三个非负整数 $n, m, k$，分别表示原有的城市数量、道路数量和准备进行城市化改造的乡镇数量。\n\n输入的第 $i+1$ ($1 \\leq i \\leq m$) 行包含三个非负整数 $u_i, v_i, w_i$，表示第 $i$ 条道路连接的两座城市与修复该道路的费用。\n\n输入的第 $j+m+1$ ($1 \\leq j \\leq k$) 行包含 $n+1$ 个非负整数 $c_j, a_{j,1}, a_{j,2}, \\ldots, a_{j,n}$，分别表示将第 $j$ 个乡镇进行城市化改造的费用与在该乡镇与原有的城市间建造道路的费用。", "outputFormat": "输出一行一个非负整数，表示将原有的 $n$ 座城市两两连通的最小费用。", "hint": "### 【样例 1 解释】\n\nC 国政$ $府可以选择修复第 $3$ 条和第 $4$ 条道路，然后将第 $1$ 个乡镇进行城市化改造，并建造它与第 $1,3$ 座城市间的道路，总费用为 $5 + 4 + 1 + 1 + 2 = 13$。可以证明，不存在比 $13$ 更小的费用能使原有的 $4$ 座城市两两连通。\n\n### 【样例 2】\n\n见选手目录下的 $\\textbf{\\textit{road/road2.in}}$ 与 $\\textbf{\\textit{road/road2.ans}}$。\n\n该样例满足测试点 $11,12$ 的约束条件。\n\n### 【样例 3】\n\n见选手目录下的 $\\textbf{\\textit{road/road3.in}}$ 与 $\\textbf{\\textit{road/road3.ans}}$。\n\n该样例满足测试点 $13,14$ 的约束条件。\n\n### 【样例 4】\n\n见选手目录下的 $\\textbf{\\textit{road/road4.in}}$ 与 $\\textbf{\\textit{road/road4.ans}}$。\n\n该样例满足测试点 $15,16$ 的约束条件。\n\n### 【数据范围】\n\n对于所有测试数据，保证：\n\n- $1 \\leq n \\leq 10^4$，$1 \\leq m \\leq 10^6$，$0 \\leq k \\leq 10$；\n- 对于所有 $1 \\leq i \\leq m$，均有 $1 \\leq u_i, v_i \\leq n$，$u_i \\neq v_i$ 且 $0 \\leq w_i \\leq 10^9$；\n- 对于所有 $1 \\leq j \\leq k$，均有 $0 \\leq c_j \\leq 10^9$；\n- 对于所有 $1 \\leq j \\leq k$，$1 \\leq i \\leq n$，均有 $0 \\leq a_{j,i} \\leq 10^9$；\n- 任意两座原有的城市都能通过若干条原有的道路相互到达。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n \\leq$ | $m \\leq$ | $k \\leq$ | 特殊性质 |\n| :--: | :--: | :--: | :--: | :--: |\n| $1 \\sim 4$ | $10^4$ | $10^6$ | $0$ | 无 |\n| $5, 6$ | $10^3$ | $10^5$ | $5$ | A |\n| $7, 8$ | ^ | ^ | ^ | 无 |\n| $9, 10$ | ^ | $10^6$ | ^ | A |\n| $11, 12$ | ^ | ^ | ^ | 无 |\n| $13, 14$ | ^ | ^ | $10$ | A |\n| $15, 16$ | ^ | ^ | ^ | 无 |\n| $17, 18$ | $10^4$ | ^ | $5$ | A |\n| $19, 20$ | ^ | ^ | ^ | 无 |\n| $21 \\sim 25$ | ^ | ^ | $10$ | ^ |\n\n特殊性质 A：对于所有 $1 \\leq j \\leq k$，均有 $c_j = 0$ 且均存在 $1 \\leq i \\leq n$ 满足 $a_{j,i} = 0$。", "locale": "zh-CN"}}}
{"pid": "P14363", "type": "P", "difficulty": 6, "samples": [["4 2\nxabcx xadex\nab cd\nbc de\naa bb\nxabcx xadex\naaaa bbbb", "2\n0"], ["3 4\na b\nb c\nc d\naa bb\naa b\na c\nb a", "0\n0\n0\n0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2025", "O2优化", "哈希 hashing", "扫描线", "字典树 Trie", "AC 自动机", "CSP-S 提高级"], "title": "[CSP-S 2025] 谐音替换", "background": "由于评测机性能差异，本题时限提升 1 秒。", "description": "小 W 是一名喜欢语言学的算法竞赛选手。在语言学中，谐音替换是指将原有的字词替换为读音相同或相近的字词。小 W 发现，谐音替换的过程可以用字符串来进行描述。具体地，小 W 将谐音替换定义为以下字符串问题：\n\n给定 $n$ 个字符串二元组，第 $i$ ($1 \\leq i \\leq n$) 个字符串二元组为 $(s_{i,1}, s_{i,2})$，满足 $|s_{i,1}| = |s_{i,2}|$，其中 $|s|$ 表示字符串 $s$ 的长度。\n\n对于字符串 $s$，定义 $s$ 的**替换**如下：\n\n- 对于 $s$ 的某个子串 $y$，若存在 $1 \\leq i \\leq n$ 满足 $y = s_{i,1}$，则将 $y$ 替换为 $y' = s_{i,2}$。具体地，设 $s = x + y + z$，其中 $x$ 和 $z$ 可以为空，“+” 表示字符串拼接，则 $s$ 的替换将得到字符串 $s' = x + y' + z$。\n\n小 W 提出了 $q$ 个问题，第 $j$ ($1 \\leq j \\leq q$) 个问题会给定两个**不同**的字符串 $t_{j,1}, t_{j,2}$，她想知道有多少种字符串 $t_{j,1}$ 的替换能够得到字符串 $t_{j,2}$。两种 $s$ 的替换不同当且仅当**子串 $y$ 的位置不同或用于替换的二元组 $(s_{i,1}, s_{i,2})$ 不同**，即 $x, z$ 不同或 $i$ 不同。你需要回答小 W 提出的所有问题。", "inputFormat": "输入的第一行包含两个正整数 $n, q$，分别表示字符串二元组的数量和小 W 提出的问题的数量。\n\n输入的第 $i+1$ ($1 \\leq i \\leq n$) 行包含两个字符串 $s_{i,1}, s_{i,2}$，表示第 $i$ 个字符串二元组。\n\n输入的第 $j+n+1$ ($1 \\leq j \\leq q$) 行包含两个字符串 $t_{j,1}, t_{j,2}$，表示小 W 提出的第 $j$ 个问题。", "outputFormat": "输出 $q$ 行，其中第 $j$ ($1 \\leq j \\leq q$) 行包含一个非负整数，表示替换后得到字符串 $t_{j,2}$ 的字符串 $t_{j,1}$ 的替换的数量。", "hint": "### 【样例 1 解释】\n\n对于小 W 的第一个询问，共有 $2$ 种 $t_{1,1}$ 的替换能够得到 $t_{1,2}$:\n\n1. 令 $x, z$ 均为空串，$y = \\texttt{xabcx}$, $i = 1$，则 $y' = \\texttt{xadex}$，替换后得到 $\\texttt{xadex}$；\n2. 令 $x = \\texttt{xa}$, $y = \\texttt{bc}$, $z = \\texttt{x}$, $i = 3$，则 $y' = \\texttt{de}$，替换后得到 $\\texttt{xadex}$。\n\n### 【样例 3】\n\n见选手目录下的 $replace/replace3.in$ 与 $replace/replace3.ans$。\n\n该样例满足测试点 11, 12 的约束条件。\n\n### 【样例 4】\n\n见选手目录下的 $replace/replace4.in$ 与 $replace/replace4.ans$。\n\n该样例满足测试点 15, 16 的约束条件。\n\n### 【数据范围】\n\n设 $L_1 = \\sum_{i=1}^{n} |s_{i,1}| + |s_{i,2}|$, $L_2 = \\sum_{j=1}^{q} |t_{j,1}| + |t_{j,2}|$。对于所有测试数据，保证:\n\n- $1 \\leq n, q \\leq 2 \\times 10^5$;\n- $2 \\leq L_1, L_2 \\leq 5 \\times 10^6$;\n- 对于所有 $1 \\leq i \\leq n$, $s_{i,1}, s_{i,2}$ 均仅包含小写英文字母，且 $|s_{i,1}| = |s_{i,2}|$;\n- 对于所有 $1 \\leq j \\leq q$, $t_{j,1}, t_{j,2}$ 均仅包含小写英文字母，且 $t_{j,1} \\neq t_{j,2}$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n, q \\leq$ | $L_1, L_2 \\leq$ | 特殊性质 |\n| :--: | :--: | :--: | :--: |\n| $1, 2$ | $10^2$ | $200$ | 无 |\n| $3 \\sim 5$ | $10^3$ | $2\\,000$ | ^ |\n| $6$ | ^ | $10^6$ | AB |\n| $7, 8$ | $10^4$ | ^ | A |\n| $9, 10$ | $2 \\times 10^5$ | ^ | B |\n| $11, 12$ | ^ | $2 \\times 10^6$ | 无 |\n| $13, 14$ | ^ | $5 \\times 10^6$ | A |\n| $15, 16$ | ^ | ^  | B |\n| $17 \\sim 20$ |^  | ^ | 无 |\n\n\n特殊性质 A：$q = 1$。\n\n特殊性质 B：定义字符串 $s$ 为**特别的**，当且仅当字符串 $s$ 仅包含字符 $a$ 和 $b$，且字符 $b$ 在 $s$ 中出现**恰好**一次。对于所有 $1 \\leq i \\leq n$, $s_{i,1}, s_{i,2}$ 均为特别的，且对于所有 $1 \\leq j \\leq q$, $t_{j,1}, t_{j,2}$ 均为特别的。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-S 2025] 谐音替换", "background": "由于评测机性能差异，本题时限提升 1 秒。", "description": "小 W 是一名喜欢语言学的算法竞赛选手。在语言学中，谐音替换是指将原有的字词替换为读音相同或相近的字词。小 W 发现，谐音替换的过程可以用字符串来进行描述。具体地，小 W 将谐音替换定义为以下字符串问题：\n\n给定 $n$ 个字符串二元组，第 $i$ ($1 \\leq i \\leq n$) 个字符串二元组为 $(s_{i,1}, s_{i,2})$，满足 $|s_{i,1}| = |s_{i,2}|$，其中 $|s|$ 表示字符串 $s$ 的长度。\n\n对于字符串 $s$，定义 $s$ 的**替换**如下：\n\n- 对于 $s$ 的某个子串 $y$，若存在 $1 \\leq i \\leq n$ 满足 $y = s_{i,1}$，则将 $y$ 替换为 $y' = s_{i,2}$。具体地，设 $s = x + y + z$，其中 $x$ 和 $z$ 可以为空，“+” 表示字符串拼接，则 $s$ 的替换将得到字符串 $s' = x + y' + z$。\n\n小 W 提出了 $q$ 个问题，第 $j$ ($1 \\leq j \\leq q$) 个问题会给定两个**不同**的字符串 $t_{j,1}, t_{j,2}$，她想知道有多少种字符串 $t_{j,1}$ 的替换能够得到字符串 $t_{j,2}$。两种 $s$ 的替换不同当且仅当**子串 $y$ 的位置不同或用于替换的二元组 $(s_{i,1}, s_{i,2})$ 不同**，即 $x, z$ 不同或 $i$ 不同。你需要回答小 W 提出的所有问题。", "inputFormat": "输入的第一行包含两个正整数 $n, q$，分别表示字符串二元组的数量和小 W 提出的问题的数量。\n\n输入的第 $i+1$ ($1 \\leq i \\leq n$) 行包含两个字符串 $s_{i,1}, s_{i,2}$，表示第 $i$ 个字符串二元组。\n\n输入的第 $j+n+1$ ($1 \\leq j \\leq q$) 行包含两个字符串 $t_{j,1}, t_{j,2}$，表示小 W 提出的第 $j$ 个问题。", "outputFormat": "输出 $q$ 行，其中第 $j$ ($1 \\leq j \\leq q$) 行包含一个非负整数，表示替换后得到字符串 $t_{j,2}$ 的字符串 $t_{j,1}$ 的替换的数量。", "hint": "### 【样例 1 解释】\n\n对于小 W 的第一个询问，共有 $2$ 种 $t_{1,1}$ 的替换能够得到 $t_{1,2}$:\n\n1. 令 $x, z$ 均为空串，$y = \\texttt{xabcx}$, $i = 1$，则 $y' = \\texttt{xadex}$，替换后得到 $\\texttt{xadex}$；\n2. 令 $x = \\texttt{xa}$, $y = \\texttt{bc}$, $z = \\texttt{x}$, $i = 3$，则 $y' = \\texttt{de}$，替换后得到 $\\texttt{xadex}$。\n\n### 【样例 3】\n\n见选手目录下的 $replace/replace3.in$ 与 $replace/replace3.ans$。\n\n该样例满足测试点 11, 12 的约束条件。\n\n### 【样例 4】\n\n见选手目录下的 $replace/replace4.in$ 与 $replace/replace4.ans$。\n\n该样例满足测试点 15, 16 的约束条件。\n\n### 【数据范围】\n\n设 $L_1 = \\sum_{i=1}^{n} |s_{i,1}| + |s_{i,2}|$, $L_2 = \\sum_{j=1}^{q} |t_{j,1}| + |t_{j,2}|$。对于所有测试数据，保证:\n\n- $1 \\leq n, q \\leq 2 \\times 10^5$;\n- $2 \\leq L_1, L_2 \\leq 5 \\times 10^6$;\n- 对于所有 $1 \\leq i \\leq n$, $s_{i,1}, s_{i,2}$ 均仅包含小写英文字母，且 $|s_{i,1}| = |s_{i,2}|$;\n- 对于所有 $1 \\leq j \\leq q$, $t_{j,1}, t_{j,2}$ 均仅包含小写英文字母，且 $t_{j,1} \\neq t_{j,2}$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n, q \\leq$ | $L_1, L_2 \\leq$ | 特殊性质 |\n| :--: | :--: | :--: | :--: |\n| $1, 2$ | $10^2$ | $200$ | 无 |\n| $3 \\sim 5$ | $10^3$ | $2\\,000$ | ^ |\n| $6$ | ^ | $10^6$ | AB |\n| $7, 8$ | $10^4$ | ^ | A |\n| $9, 10$ | $2 \\times 10^5$ | ^ | B |\n| $11, 12$ | ^ | $2 \\times 10^6$ | 无 |\n| $13, 14$ | ^ | $5 \\times 10^6$ | A |\n| $15, 16$ | ^ | ^  | B |\n| $17 \\sim 20$ |^  | ^ | 无 |\n\n\n特殊性质 A：$q = 1$。\n\n特殊性质 B：定义字符串 $s$ 为**特别的**，当且仅当字符串 $s$ 仅包含字符 $a$ 和 $b$，且字符 $b$ 在 $s$ 中出现**恰好**一次。对于所有 $1 \\leq i \\leq n$, $s_{i,1}, s_{i,2}$ 均为特别的，且对于所有 $1 \\leq j \\leq q$, $t_{j,1}, t_{j,2}$ 均为特别的。", "locale": "zh-CN"}}}
{"pid": "P14364", "type": "P", "difficulty": 6, "samples": [["3 2\n101\n1 1 2", "2"], ["10 5\n1101111011\n6 0 4 2 1 2 5 4 3 3", "2204128"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2025", "O2优化", "动态规划优化", "组合数学", "容斥原理", "CSP-S 提高级"], "title": "[CSP-S 2025] 员工招聘", "background": "由于评测机性能差异，本题时限提升 1 秒。\n", "description": "小 Z 和小 H 想要合伙开一家公司，共有 $n$ 人前来应聘，编号为 $1 \\sim n$。小 Z 和小 H 希望录用至少 $m$ 人。\n\n小 H 是面试官，将在接下来 $n$ 天每天面试一个人。小 Z 负责决定应聘人前来面试的顺序。具体地，小 Z 可以选择一个 $1 \\sim n$ 的排列 $p$，然后在第 $i$ ($1 \\leq i \\leq n$) 天通知编号为 $p_i$ 的人前来面试。\n\n小 H 准备了 $n$ 套难度不一的面试题。由于 $n$ 个前来应聘的人水平大致相同，因此对于同一套题，所有人的作答结果是一致的。具体地，第 $i$ ($1 \\leq i \\leq n$) 天的面试题的难度为 $s_i \\in \\{0,1\\}$，其中 $s_i = 0$ 表示这套题的难度较高，没有人能够做出；$s_i = 1$ 表示这套题的难度较低，所有人都能做出。小 H 会根据面试者的作答结果决定是否录用，即如果面试者没有做出面试题，则会拒绝，否则会录用。\n\n然而，每个人的耐心都有一定的上限，如果在他面试之前未录用的人数过多，则他会直接放弃参加面试。具体地，编号为 $i$ ($1 \\leq i \\leq n$) 的人的耐心上限可以用非负整数 $c_i$ 描述，若在他之前已经有**不少于** $c_i$ 人被拒绝或放弃参加面试，则他也将放弃参加面试。\n\n小 Z 想知道一共有多少种面试的顺序 $p$ 能够让他们录用至少 $m$ 人。你需要帮助小 Z 求出，能够录用至少 $m$ 人的排列 $p$ 的数量。由于答案可能较大，你只需要求出答案对 $998\\,244\\,353$ 取模后的结果。", "inputFormat": "输入的第一行包含两个正整数 $n, m$，分别表示前来应聘的人数和希望录用的人数。\n\n输入的第二行包含一个长度为 $n$ 的字符串 $s_1 \\dots s_n$，表示每一天的面试题的难度。\n\n输入的第三行包含 $n$ 个非负整数 $c_1, c_2, \\dots, c_n$，表示每个人的耐心上限。", "outputFormat": "输出一行一个非负整数，表示能够录用至少 $m$ 人的排列 $p$ 的数量对 $998\\,244\\,353$ 取模后的结果。", "hint": "### 【样例 1 解释】\n\n共有以下 2 种面试的顺序 $p$ 能够让小 Z 和小 H 录用至少 2 人:\n\n1. $p = [1,2,3]$, 依次录用编号为 1 的人和编号为 3 的人;\n2. $p = [2,1,3]$, 依次录用编号为 2 的人和编号为 3 的人。\n\n### 【样例 3】\n\n见选手目录下的 $\\textbf{\\textit{employ/employ3.in}}$ 与 $\\textbf{\\textit{employ/employ3.ans}}$。\n\n该样例满足测试点 6 ~ 8 的约束条件。\n\n### 【样例 4】\n\n见选手目录下的 $\\textbf{\\textit{employ/employ4.in}}$ 与 $\\textbf{\\textit{employ/employ4.ans}}$。\n\n该样例满足测试点 12 ~ 14 的约束条件。\n\n### 【样例 5】\n\n见选手目录下的 $\\textbf{\\textit{employ/employ5.in}}$ 与 $\\textbf{\\textit{employ/employ5.ans}}$。\n\n该样例满足测试点 18 ~ 21 的约束条件。\n\n### 【数据范围】\n\n对于所有测试数据，保证:\n- $1 \\leq m \\leq n \\leq 500$;\n- 对于所有 $1 \\leq i \\leq n$，均有 $s_i \\in \\{0,1\\}$;\n- 对于所有 $1 \\leq i \\leq n$，均有 $0 \\leq c_i \\leq n$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n \\leq$ | $m$ | 特殊性质 |\n| :--: | :--: | :--: | :--: |\n| $1,2$ | $10$ | $\\leq n$ | 无 |\n| $3 \\sim 5$ | $18$ |  ^ | ^ |\n| $6 \\sim 8$ | $10^2$ | ^ | A |\n| $9 \\sim 11$ | ^ | ^ | 无 |\n| $12 \\sim 14$ | $500$ | $=1$ | ^ |\n| $15$ | ^ | $=n$ | ^ |\n| $16,17$ | ^ | $\\leq n$ | A |\n| $18 \\sim 21$ | ^ | ^ | B |\n| $22 \\sim 25$ | ^ | ^ | 无 |\n\n\n特殊性质 A: 对于所有 $1 \\leq i \\leq n$，均有 $s_i = 1$。\n\n特殊性质 B: 在 $s_1, s_2, \\dots, s_n$ 中最多只有 18 个取值为 1，即 $\\sum_{i=1}^{n} s_i \\leq 18$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-S 2025] 员工招聘", "background": "由于评测机性能差异，本题时限提升 1 秒。\n", "description": "小 Z 和小 H 想要合伙开一家公司，共有 $n$ 人前来应聘，编号为 $1 \\sim n$。小 Z 和小 H 希望录用至少 $m$ 人。\n\n小 H 是面试官，将在接下来 $n$ 天每天面试一个人。小 Z 负责决定应聘人前来面试的顺序。具体地，小 Z 可以选择一个 $1 \\sim n$ 的排列 $p$，然后在第 $i$ ($1 \\leq i \\leq n$) 天通知编号为 $p_i$ 的人前来面试。\n\n小 H 准备了 $n$ 套难度不一的面试题。由于 $n$ 个前来应聘的人水平大致相同，因此对于同一套题，所有人的作答结果是一致的。具体地，第 $i$ ($1 \\leq i \\leq n$) 天的面试题的难度为 $s_i \\in \\{0,1\\}$，其中 $s_i = 0$ 表示这套题的难度较高，没有人能够做出；$s_i = 1$ 表示这套题的难度较低，所有人都能做出。小 H 会根据面试者的作答结果决定是否录用，即如果面试者没有做出面试题，则会拒绝，否则会录用。\n\n然而，每个人的耐心都有一定的上限，如果在他面试之前未录用的人数过多，则他会直接放弃参加面试。具体地，编号为 $i$ ($1 \\leq i \\leq n$) 的人的耐心上限可以用非负整数 $c_i$ 描述，若在他之前已经有**不少于** $c_i$ 人被拒绝或放弃参加面试，则他也将放弃参加面试。\n\n小 Z 想知道一共有多少种面试的顺序 $p$ 能够让他们录用至少 $m$ 人。你需要帮助小 Z 求出，能够录用至少 $m$ 人的排列 $p$ 的数量。由于答案可能较大，你只需要求出答案对 $998\\,244\\,353$ 取模后的结果。", "inputFormat": "输入的第一行包含两个正整数 $n, m$，分别表示前来应聘的人数和希望录用的人数。\n\n输入的第二行包含一个长度为 $n$ 的字符串 $s_1 \\dots s_n$，表示每一天的面试题的难度。\n\n输入的第三行包含 $n$ 个非负整数 $c_1, c_2, \\dots, c_n$，表示每个人的耐心上限。", "outputFormat": "输出一行一个非负整数，表示能够录用至少 $m$ 人的排列 $p$ 的数量对 $998\\,244\\,353$ 取模后的结果。", "hint": "### 【样例 1 解释】\n\n共有以下 2 种面试的顺序 $p$ 能够让小 Z 和小 H 录用至少 2 人:\n\n1. $p = [1,2,3]$, 依次录用编号为 1 的人和编号为 3 的人;\n2. $p = [2,1,3]$, 依次录用编号为 2 的人和编号为 3 的人。\n\n### 【样例 3】\n\n见选手目录下的 $\\textbf{\\textit{employ/employ3.in}}$ 与 $\\textbf{\\textit{employ/employ3.ans}}$。\n\n该样例满足测试点 6 ~ 8 的约束条件。\n\n### 【样例 4】\n\n见选手目录下的 $\\textbf{\\textit{employ/employ4.in}}$ 与 $\\textbf{\\textit{employ/employ4.ans}}$。\n\n该样例满足测试点 12 ~ 14 的约束条件。\n\n### 【样例 5】\n\n见选手目录下的 $\\textbf{\\textit{employ/employ5.in}}$ 与 $\\textbf{\\textit{employ/employ5.ans}}$。\n\n该样例满足测试点 18 ~ 21 的约束条件。\n\n### 【数据范围】\n\n对于所有测试数据，保证:\n- $1 \\leq m \\leq n \\leq 500$;\n- 对于所有 $1 \\leq i \\leq n$，均有 $s_i \\in \\{0,1\\}$;\n- 对于所有 $1 \\leq i \\leq n$，均有 $0 \\leq c_i \\leq n$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n \\leq$ | $m$ | 特殊性质 |\n| :--: | :--: | :--: | :--: |\n| $1,2$ | $10$ | $\\leq n$ | 无 |\n| $3 \\sim 5$ | $18$ |  ^ | ^ |\n| $6 \\sim 8$ | $10^2$ | ^ | A |\n| $9 \\sim 11$ | ^ | ^ | 无 |\n| $12 \\sim 14$ | $500$ | $=1$ | ^ |\n| $15$ | ^ | $=n$ | ^ |\n| $16,17$ | ^ | $\\leq n$ | A |\n| $18 \\sim 21$ | ^ | ^ | B |\n| $22 \\sim 25$ | ^ | ^ | 无 |\n\n\n特殊性质 A: 对于所有 $1 \\leq i \\leq n$，均有 $s_i = 1$。\n\n特殊性质 B: 在 $s_1, s_2, \\dots, s_n$ 中最多只有 18 个取值为 1，即 $\\sum_{i=1}^{n} s_i \\leq 18$。", "locale": "zh-CN"}}}
{"pid": "P14365", "type": "P", "difficulty": 6, "samples": [["5\n1 2 3 4 5\n1 2\n2 3\n2 4\n3 5", "0\n0\n0\n2"], ["10\n1 7 3 4 8 6 2 9 10 5\n1 2\n1 3\n2 4\n3 5\n2 6\n3 7\n4 8\n5 9\n6 10", "0\n0\n0\n1\n1\n0\n1\n2\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "树状数组", "颜色段均摊（珂朵莉树 ODT）", "树链剖分", "JOISC/JOIST（日本）"], "title": "[JOISC 2018] 高速公路建设 / Construction of Highway", "background": "", "description": "JOI 王国有 $N$ 个城市，编号从 $1$ 到 $N$。城市 $1$ 是首都。每个城市都有一个称为“活力值”的数值，城市 $i$（$1 \\le i \\le N$）的初始活力值为 $C_i$。\n\nJOI 王国中的道路是双向连接两个不同城市的。最初，JOI 王国中没有道路。你计划进行 $N-1$ 次道路建设。第 $j$ 次建设（$1 \\le j \\le N-1$）按以下方式进行：\n\n- 选定两个城市 $A_j$ 和 $B_j$，满足：仅使用当时已建成的道路，可以从城市 $1$ 到达城市 $A_j$，但无法从城市 $1$ 到达城市 $B_j$。\n- 你建设一条连接城市 $A_j$ 和城市 $B_j$ 的道路。此次建设的成本是满足以下条件的城市对 $(s, t)$ 的数量：\n\n  城市 $s$ 和城市 $t$ 位于从城市 $1$ 到城市 $A_j$ 的最短路径上，且当从城市 $1$ 前往城市 $A_j$ 时，先经过城市 $s$，再经过城市 $t$，且城市 $s$ 的活力值严格大于城市 $t$ 的活力值。\n\n  这里，位于城市 $1$ 和城市 $A_j$ 之间的路径上的城市包括城市 $1$ 和城市 $A_j$。注意，城市 $1$ 与城市 $A_j$ 之间的最短路径是唯一的。\n\n- 所有位于城市 $1$ 与城市 $A_j$ 之间路径上的城市的活力值，均更新为城市 $B_j$ 的活力值。\n\n你希望知道每次建设的成本。\n\n**任务**\n\n给定城市数据和道路建设方案，编写一个程序，计算每次建设的成本。", "inputFormat": "从标准输入读取以下数据：\n\n- 输入的第一行包含一个整数 $N$。这意味着 JOI 王国有 $N$ 个城市。\n- 输入的第二行包含 $N$ 个以空格分隔的整数 $C_1, C_2, \\cdots, C_N$。这意味着城市 $i$（$1 \\le i \\le N$）的初始活力值为 $C_i$。\n- 接下来的 $N-1$ 行中，第 $j$ 行（$1 \\le j \\le N-1$）包含两个以空格分隔的整数 $A_j, B_j$。这意味着在第 $j$ 次道路建设中，选定城市 $A_j$ 和城市 $B_j$。", "outputFormat": "向标准输出写入 $N-1$ 行。第 $j$ 行（$1 \\le j \\le N-1$）包含第 $j$ 次道路建设的成本。\n", "hint": "### 样例 1 解释\n\n在样例输入 1 中，建设过程如下：\n\n- 在第一次建设中，不存在满足条件的城市对 $(s, t)$，因此成本为 $0$。修建一条连接城市 $1$ 和城市 $2$ 的道路，城市 $1$ 的活力值更新为 $2$。\n- 在第二次建设中，同样不存在满足条件的城市对 $(s, t)$，因此成本为 $0$。修建一条连接城市 $2$ 和城市 $3$ 的道路，城市 $1$ 和城市 $2$ 的活力值均更新为 $3$。\n- 在第三次建设中，仍不存在满足条件的城市对 $(s, t)$，因此成本为 $0$。修建一条连接城市 $2$ 和城市 $4$ 的道路，城市 $1$ 和城市 $2$ 的活力值均更新为 $4$。\n- 在第四次建设中，有两个城市对 $(s, t) = (1,3), (2,3)$ 满足条件，因此成本为 $2$。修建一条连接城市 $3$ 和城市 $5$ 的道路，城市 $1$、城市 $2$ 和城市 $3$ 的活力值均更新为 $5$。\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le N \\le 100\\,000$。\n- $1 \\le C_i \\le 1\\,000\\,000\\,000$（$1 \\le i \\le N$）。\n- $1 \\le A_j \\le N$（$1 \\le j \\le N-1$）。\n- $1 \\le B_j \\le N$（$1 \\le j \\le N-1$）。\n- 在第 $j$ 次建设之前，仅使用已建成的道路，可以从城市 $1$ 到达城市 $A_j$，但无法从城市 $1$ 到达城市 $B_j$（$1 \\le j \\le N-1$）。\n\n### 子任务\n\n共有 3 个子任务。每个子任务的得分和附加约束如下：\n\n**子任务 1 [7 分]**\n\n- $N \\le 500$。\n\n**子任务 2 [9 分]**\n\n- $N \\le 4000$。\n\n**子任务 3 [84 分]**\n\n无额外约束。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2018] 高速公路建设 / Construction of Highway", "background": "", "description": "JOI 王国有 $N$ 个城市，编号从 $1$ 到 $N$。城市 $1$ 是首都。每个城市都有一个称为“活力值”的数值，城市 $i$（$1 \\le i \\le N$）的初始活力值为 $C_i$。\n\nJOI 王国中的道路是双向连接两个不同城市的。最初，JOI 王国中没有道路。你计划进行 $N-1$ 次道路建设。第 $j$ 次建设（$1 \\le j \\le N-1$）按以下方式进行：\n\n- 选定两个城市 $A_j$ 和 $B_j$，满足：仅使用当时已建成的道路，可以从城市 $1$ 到达城市 $A_j$，但无法从城市 $1$ 到达城市 $B_j$。\n- 你建设一条连接城市 $A_j$ 和城市 $B_j$ 的道路。此次建设的成本是满足以下条件的城市对 $(s, t)$ 的数量：\n\n  城市 $s$ 和城市 $t$ 位于从城市 $1$ 到城市 $A_j$ 的最短路径上，且当从城市 $1$ 前往城市 $A_j$ 时，先经过城市 $s$，再经过城市 $t$，且城市 $s$ 的活力值严格大于城市 $t$ 的活力值。\n\n  这里，位于城市 $1$ 和城市 $A_j$ 之间的路径上的城市包括城市 $1$ 和城市 $A_j$。注意，城市 $1$ 与城市 $A_j$ 之间的最短路径是唯一的。\n\n- 所有位于城市 $1$ 与城市 $A_j$ 之间路径上的城市的活力值，均更新为城市 $B_j$ 的活力值。\n\n你希望知道每次建设的成本。\n\n**任务**\n\n给定城市数据和道路建设方案，编写一个程序，计算每次建设的成本。", "inputFormat": "从标准输入读取以下数据：\n\n- 输入的第一行包含一个整数 $N$。这意味着 JOI 王国有 $N$ 个城市。\n- 输入的第二行包含 $N$ 个以空格分隔的整数 $C_1, C_2, \\cdots, C_N$。这意味着城市 $i$（$1 \\le i \\le N$）的初始活力值为 $C_i$。\n- 接下来的 $N-1$ 行中，第 $j$ 行（$1 \\le j \\le N-1$）包含两个以空格分隔的整数 $A_j, B_j$。这意味着在第 $j$ 次道路建设中，选定城市 $A_j$ 和城市 $B_j$。", "outputFormat": "向标准输出写入 $N-1$ 行。第 $j$ 行（$1 \\le j \\le N-1$）包含第 $j$ 次道路建设的成本。\n", "hint": "### 样例 1 解释\n\n在样例输入 1 中，建设过程如下：\n\n- 在第一次建设中，不存在满足条件的城市对 $(s, t)$，因此成本为 $0$。修建一条连接城市 $1$ 和城市 $2$ 的道路，城市 $1$ 的活力值更新为 $2$。\n- 在第二次建设中，同样不存在满足条件的城市对 $(s, t)$，因此成本为 $0$。修建一条连接城市 $2$ 和城市 $3$ 的道路，城市 $1$ 和城市 $2$ 的活力值均更新为 $3$。\n- 在第三次建设中，仍不存在满足条件的城市对 $(s, t)$，因此成本为 $0$。修建一条连接城市 $2$ 和城市 $4$ 的道路，城市 $1$ 和城市 $2$ 的活力值均更新为 $4$。\n- 在第四次建设中，有两个城市对 $(s, t) = (1,3), (2,3)$ 满足条件，因此成本为 $2$。修建一条连接城市 $3$ 和城市 $5$ 的道路，城市 $1$、城市 $2$ 和城市 $3$ 的活力值均更新为 $5$。\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le N \\le 100\\,000$。\n- $1 \\le C_i \\le 1\\,000\\,000\\,000$（$1 \\le i \\le N$）。\n- $1 \\le A_j \\le N$（$1 \\le j \\le N-1$）。\n- $1 \\le B_j \\le N$（$1 \\le j \\le N-1$）。\n- 在第 $j$ 次建设之前，仅使用已建成的道路，可以从城市 $1$ 到达城市 $A_j$，但无法从城市 $1$ 到达城市 $B_j$（$1 \\le j \\le N-1$）。\n\n### 子任务\n\n共有 3 个子任务。每个子任务的得分和附加约束如下：\n\n**子任务 1 [7 分]**\n\n- $N \\le 500$。\n\n**子任务 2 [9 分]**\n\n- $N \\le 4000$。\n\n**子任务 3 [84 分]**\n\n无额外约束。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN"}}}
{"pid": "P14366", "type": "P", "difficulty": 6, "samples": [["3 4\n-3 5 1 8\n-4 3 -4 6\n5 1 7 2", "29.0000000000"], ["1 2\n-3 -3 -3 -2", "16.0000000000"], ["4 3\n4 -1 3 4\n-4 2 -2 4\n-4 0 -5 6\n0 -6 5 -2\n", "14.1392801789"], ["10 80\n175 95 60 -146\n-106 57 18 185\n190 -68 177 -142\n84 -195 127 -179\n34 143 126 69\n-92 133 -190 80\n-157 -66 -119 -161\n-85 -124 129 -171\n141 181 175 175\n107 -38 150 148", "238.4778364511"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["计算几何", "2018", "Special Judge", "最短路", "JOISC/JOIST（日本）"], "title": "[JOISC 2018] 栅栏 / Fences", "background": "", "description": "JOI 先生在 IOI 国拥有一块很大的土地。IOI 国用一个坐标平面表示，其中 $X$ 轴与 $Y$ 轴互相垂直。坐标为 $x$、$y$ 的点记作 $(x, y)$。他的土地是 $X$ 坐标和 $Y$ 坐标均在 $-10^{100}$ 到 $10^{100}$（含端点）之间的区域。他在一块牧场上饲养奶牛，这块牧场是 $X$ 坐标和 $Y$ 坐标均在 $-S$ 到 $S$（含端点）之间的区域。\n\nJOI 先生决定用一些栅栏围住牧场，以防止奶牛逃出。栅栏由长度为正实数的线段表示。他将围住牧场，使得从牧场内任意一点出发，若不经过任何栅栏（包括栅栏的端点），则无法到达土地的外部。土地上已有一些栅栏，他可以利用这些栅栏来围住牧场。对于这些栅栏中的任意两段，若它们有公共点，则该点必为其中至少一段栅栏的端点。\n\nJOI 先生可以建造任意数量的新栅栏。新栅栏的长度和方向可以任意，只要它不穿过牧场内部或土地外部即可。他也可以建造一段沿着牧场边界的栅栏。建造一段长度为 $l$（$l > 0$）的新栅栏，其成本为 $l$。两段栅栏可能相交，一段栅栏的端点可能与另一段栅栏的端点重合，或一段栅栏的端点可能位于另一段栅栏上。\n\nJOI 先生希望以尽可能低的成本围住牧场。\n\n**任务**\n\n给定牧场的尺寸以及已建栅栏的数据，编写一个程序，计算围住牧场所需的最小总成本。", "inputFormat": "从标准输入读取以下数据：\n\n- 输入的第一行包含两个以空格分隔的整数 $N$ 和 $S$。这意味着牧场是 $X$ 坐标和 $Y$ 坐标均在 $-S$ 到 $S$（含端点）之间的区域，且 JOI 先生的土地上已建有 $N$ 段栅栏。\n- 接下来的 $N$ 行中，第 $i$ 行（$1 \\le i \\le N$）包含四个以空格分隔的整数 $A_i, B_i, C_i, D_i$。这意味着第 $i$ 段已建栅栏是连接点 $(A_i, B_i)$ 与点 $(C_i, D_i)$ 的线段。", "outputFormat": "向标准输出写入一行。输出应包含围住牧场所需的最小总成本。你可以在小数点后输出任意位数的数字，但你的输出与正确答案之间的绝对误差不得超过 $0.01$。\n", "hint": "### 样例 1 解释\n\n样例输入 1 中已建的栅栏如下面图片左侧所示。中心的虚线方框表示牧场的边界。\n\n右侧展示了围住该牧场的一种方式，其中细线段代表新建的栅栏。建造这些栅栏的成本为 $29$，这是可能的最小成本。在本样例输入中，除 $29.0000000000$ 外，输出 $29$ 或 $28.999$ 也被视为正确。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/4brmy3z5.png)\n:::\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le N \\le 100$。\n- $1 \\le S \\le 200$。\n- $-200 \\le A_i \\le 200$（$1 \\le i \\le N$）。\n- $-200 \\le B_i \\le 200$（$1 \\le i \\le N$）。\n- $-200 \\le C_i \\le 200$（$1 \\le i \\le N$）。\n- $-200 \\le D_i \\le 200$（$1 \\le i \\le N$）。\n- $(A_i, B_i) \\ne (C_i, D_i)$（$1 \\le i \\le N$）。\n- 输入中的任何栅栏都不会严格位于牧场内部。\n- 对于输入中任意两个不同的栅栏，若它们有公共点，则该点必为其中至少一个栅栏的端点。\n\n### 子任务\n\n共有 3 个子任务。每个子任务的得分和附加约束如下：\n\n**子任务 1 [18 分]**\n\n- $N = 1$。\n\n**子任务 2 [33 分]**\n\n- $N \\le 6$。\n\n**子任务 3 [49 分]**\n\n无额外约束。\n\n翻译由 Qwen3-235B 完成\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2018] 栅栏 / Fences", "background": "", "description": "JOI 先生在 IOI 国拥有一块很大的土地。IOI 国用一个坐标平面表示，其中 $X$ 轴与 $Y$ 轴互相垂直。坐标为 $x$、$y$ 的点记作 $(x, y)$。他的土地是 $X$ 坐标和 $Y$ 坐标均在 $-10^{100}$ 到 $10^{100}$（含端点）之间的区域。他在一块牧场上饲养奶牛，这块牧场是 $X$ 坐标和 $Y$ 坐标均在 $-S$ 到 $S$（含端点）之间的区域。\n\nJOI 先生决定用一些栅栏围住牧场，以防止奶牛逃出。栅栏由长度为正实数的线段表示。他将围住牧场，使得从牧场内任意一点出发，若不经过任何栅栏（包括栅栏的端点），则无法到达土地的外部。土地上已有一些栅栏，他可以利用这些栅栏来围住牧场。对于这些栅栏中的任意两段，若它们有公共点，则该点必为其中至少一段栅栏的端点。\n\nJOI 先生可以建造任意数量的新栅栏。新栅栏的长度和方向可以任意，只要它不穿过牧场内部或土地外部即可。他也可以建造一段沿着牧场边界的栅栏。建造一段长度为 $l$（$l > 0$）的新栅栏，其成本为 $l$。两段栅栏可能相交，一段栅栏的端点可能与另一段栅栏的端点重合，或一段栅栏的端点可能位于另一段栅栏上。\n\nJOI 先生希望以尽可能低的成本围住牧场。\n\n**任务**\n\n给定牧场的尺寸以及已建栅栏的数据，编写一个程序，计算围住牧场所需的最小总成本。", "inputFormat": "从标准输入读取以下数据：\n\n- 输入的第一行包含两个以空格分隔的整数 $N$ 和 $S$。这意味着牧场是 $X$ 坐标和 $Y$ 坐标均在 $-S$ 到 $S$（含端点）之间的区域，且 JOI 先生的土地上已建有 $N$ 段栅栏。\n- 接下来的 $N$ 行中，第 $i$ 行（$1 \\le i \\le N$）包含四个以空格分隔的整数 $A_i, B_i, C_i, D_i$。这意味着第 $i$ 段已建栅栏是连接点 $(A_i, B_i)$ 与点 $(C_i, D_i)$ 的线段。", "outputFormat": "向标准输出写入一行。输出应包含围住牧场所需的最小总成本。你可以在小数点后输出任意位数的数字，但你的输出与正确答案之间的绝对误差不得超过 $0.01$。\n", "hint": "### 样例 1 解释\n\n样例输入 1 中已建的栅栏如下面图片左侧所示。中心的虚线方框表示牧场的边界。\n\n右侧展示了围住该牧场的一种方式，其中细线段代表新建的栅栏。建造这些栅栏的成本为 $29$，这是可能的最小成本。在本样例输入中，除 $29.0000000000$ 外，输出 $29$ 或 $28.999$ 也被视为正确。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/4brmy3z5.png)\n:::\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le N \\le 100$。\n- $1 \\le S \\le 200$。\n- $-200 \\le A_i \\le 200$（$1 \\le i \\le N$）。\n- $-200 \\le B_i \\le 200$（$1 \\le i \\le N$）。\n- $-200 \\le C_i \\le 200$（$1 \\le i \\le N$）。\n- $-200 \\le D_i \\le 200$（$1 \\le i \\le N$）。\n- $(A_i, B_i) \\ne (C_i, D_i)$（$1 \\le i \\le N$）。\n- 输入中的任何栅栏都不会严格位于牧场内部。\n- 对于输入中任意两个不同的栅栏，若它们有公共点，则该点必为其中至少一个栅栏的端点。\n\n### 子任务\n\n共有 3 个子任务。每个子任务的得分和附加约束如下：\n\n**子任务 1 [18 分]**\n\n- $N = 1$。\n\n**子任务 2 [33 分]**\n\n- $N \\le 6$。\n\n**子任务 3 [49 分]**\n\n无额外约束。\n\n翻译由 Qwen3-235B 完成\n", "locale": "zh-CN"}}}
{"pid": "P14367", "type": "P", "difficulty": 5, "samples": [["1 2", "9"], ["4 3", "3252"], ["100 100", "561068619"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2018", "组合数学", "JOISC/JOIST（日本）"], "title": "[JOISC 2018] 帐篷 / Tents", "background": "", "description": "JOI 君经营着一个露营地。该露营地被划分为一个 $H$ 行 $W$ 列的矩形网格。行与东西方向平行，列与南北方向平行。从北往南第 $i$ 行、从东往西第 $j$ 列的区域称为区域 $(i, j)$。\n\nJOI 君打算在部分区域搭建帐篷。每个帐篷必须恰好占据一个区域，且任意两个帐篷不得占据同一区域。\n\n每个帐篷的入口朝向四个方向之一：北、南、东或西。露营地中所搭帐篷的入口方向必须满足以下条件：\n\n- 若两个区域 $(i_1, j)$ 和 $(i_2, j)$（其中 $1 \\le i_1 < i_2 \\le H$，$1 \\le j \\le W$）均被帐篷占据，则区域 $(i_1, j)$ 中帐篷的入口必须朝南，区域 $(i_2, j)$ 中帐篷的入口必须朝北。\n- 若两个区域 $(i, j_1)$ 和 $(i, j_2)$（其中 $1 \\le j_1 < j_2 \\le W$，$1 \\le i \\le H$）均被帐篷占据，则区域 $(i, j_1)$ 中帐篷的入口必须朝东，区域 $(i, j_2)$ 中帐篷的入口必须朝西。\n\nJOI 君对在露营地至少搭建一个帐篷的方案总数感到好奇。若存在某个区域，其帐篷状态（是否存在帐篷，或帐篷入口方向）在两种方案中不同，则这两种方案被视为不同。\n\n**任务**\n\n编写一个程序，计算满足题面所述条件的至少搭建一个帐篷的方案总数，对 $1\\,000\\,000\\,007$ 取模后的余数。", "inputFormat": "从标准输入读取以下数据：\n\n- 输入第一行包含两个整数 $H$ 和 $W$，表示 JOI 君经营的露营地被划分为 $H$ 行 $W$ 列。", "outputFormat": "向标准输出写入一行。输出应包含满足题面所述条件的至少搭建一个帐篷的方案总数，对 $1\\,000\\,000\\,007$ 取模后的余数。\n", "hint": "### 样例 1 解释\n\n如下图所示，共有 $9$ 种搭帐篷的方式。图中字母 $E,W,S,N$ 分别代表出入口朝向东、西、南、北的帐篷。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/lv06p2yd.png)\n:::\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le H \\le 3\\,000$。\n- $1 \\le W \\le 3\\,000$。\n\n### 子任务\n\n共有 2 个子任务。每个子任务的得分和附加约束如下：\n\n**子任务 1 [48 分]**\n\n- $1 \\le H \\le 300$。\n- $1 \\le W \\le 300$。\n\n**子任务 2 [52 分]**\n\n无额外约束。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2018] 帐篷 / Tents", "background": "", "description": "JOI 君经营着一个露营地。该露营地被划分为一个 $H$ 行 $W$ 列的矩形网格。行与东西方向平行，列与南北方向平行。从北往南第 $i$ 行、从东往西第 $j$ 列的区域称为区域 $(i, j)$。\n\nJOI 君打算在部分区域搭建帐篷。每个帐篷必须恰好占据一个区域，且任意两个帐篷不得占据同一区域。\n\n每个帐篷的入口朝向四个方向之一：北、南、东或西。露营地中所搭帐篷的入口方向必须满足以下条件：\n\n- 若两个区域 $(i_1, j)$ 和 $(i_2, j)$（其中 $1 \\le i_1 < i_2 \\le H$，$1 \\le j \\le W$）均被帐篷占据，则区域 $(i_1, j)$ 中帐篷的入口必须朝南，区域 $(i_2, j)$ 中帐篷的入口必须朝北。\n- 若两个区域 $(i, j_1)$ 和 $(i, j_2)$（其中 $1 \\le j_1 < j_2 \\le W$，$1 \\le i \\le H$）均被帐篷占据，则区域 $(i, j_1)$ 中帐篷的入口必须朝东，区域 $(i, j_2)$ 中帐篷的入口必须朝西。\n\nJOI 君对在露营地至少搭建一个帐篷的方案总数感到好奇。若存在某个区域，其帐篷状态（是否存在帐篷，或帐篷入口方向）在两种方案中不同，则这两种方案被视为不同。\n\n**任务**\n\n编写一个程序，计算满足题面所述条件的至少搭建一个帐篷的方案总数，对 $1\\,000\\,000\\,007$ 取模后的余数。", "inputFormat": "从标准输入读取以下数据：\n\n- 输入第一行包含两个整数 $H$ 和 $W$，表示 JOI 君经营的露营地被划分为 $H$ 行 $W$ 列。", "outputFormat": "向标准输出写入一行。输出应包含满足题面所述条件的至少搭建一个帐篷的方案总数，对 $1\\,000\\,000\\,007$ 取模后的余数。\n", "hint": "### 样例 1 解释\n\n如下图所示，共有 $9$ 种搭帐篷的方式。图中字母 $E,W,S,N$ 分别代表出入口朝向东、西、南、北的帐篷。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/lv06p2yd.png)\n:::\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le H \\le 3\\,000$。\n- $1 \\le W \\le 3\\,000$。\n\n### 子任务\n\n共有 2 个子任务。每个子任务的得分和附加约束如下：\n\n**子任务 1 [48 分]**\n\n- $1 \\le H \\le 300$。\n- $1 \\le W \\le 300$。\n\n**子任务 2 [52 分]**\n\n无额外约束。", "locale": "zh-CN"}}}
{"pid": "P14368", "type": "P", "difficulty": 6, "samples": [["3 2", "4"], ["10 5", "1310354"]], "limits": {"time": [600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "组合数学", "JOISC/JOIST（日本）"], "title": "[JOISC 2018] 修行 / Asceticism", "background": "", "description": "有一天，JOI 君得到了一台时光机。他决定前往 9 世纪的日本。在那里，他遇到了当时日本最著名的僧侣之一——空海。这位僧侣希望开发一种新的修行方式。\n\n他的修行方式如下：\n\n- 空海阅读一部包含 $N$ 句经文的经书。这些经文是有序的，他必须按顺序阅读。\n- 每句经文上标有一个介于 $1$ 到 $N$（含）之间的整数，且任意两句不同的经文所标数字不同。\n- 他必须在一天中被均分为 $N$ 个时间段的第 $i$ 个时间段内阅读标有整数 $i$（$1 \\le i \\le N$）的那句经文。每句经文都很短，因此他总能在每个时间段内读完一句经文。\n\n空海希望尽快读完整部经书。然而，他完成阅读所需的天数取决于经文上所标整数的排列方式。JOI 君被空海要求计算：在最优阅读策略下，有多少种整数分配方式能使空海恰好用 $K$ 天完成阅读。\n\n**任务**\n\n给定经文数量 $N$ 和整数 $K$，计算在最优阅读策略下，能使空海恰好用 $K$ 天完成阅读的整数分配方式的总数，结果对 $1\\,000\\,000\\,007$ 取模。", "inputFormat": "从标准输入读取以下数据：\n\n- 输入第一行包含两个整数 $N$ 和 $K$，以单个空格分隔。\n", "outputFormat": "输出在最优阅读策略下，能使空海恰好用 $K$ 天完成阅读的整数分配方式的总数，结果对 $1\\,000\\,000\\,007$ 取模。", "hint": "### 样例 1 解释\n\n共有 4 种整数分配方式，能使他恰好用 2 天完成阅读：\n\n- 第一句经文标有 $1$，第二句标有 $3$，最后一句标有 $2$。他在第一天阅读前两句经文（分别标有 $1$ 和 $3$），在第二天阅读最后一句经文（标有 $2$）。\n- 第一句经文标有 $2$，第二句标有 $1$，最后一句标有 $3$。\n- 第一句经文标有 $2$，第二句标有 $3$，最后一句标有 $1$。\n- 第一句经文标有 $3$，第二句标有 $1$，最后一句标有 $2$。\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le N \\le 100\\,000$。\n- $1 \\le K \\le N$。\n\n\n### 子任务\n\n共有 4 个子任务。每个子任务的得分和附加约束如下：\n\n**子任务 1 [4 分]**\n\n- $N \\le 10$。\n\n**子任务 2 [20 分]**\n\n- $N \\le 300$。\n\n**子任务 3 [25 分]**\n\n- $N \\le 3\\,000$。\n\n**子任务 4 [51 分]**\n\n无额外约束。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2018] 修行 / Asceticism", "background": "", "description": "有一天，JOI 君得到了一台时光机。他决定前往 9 世纪的日本。在那里，他遇到了当时日本最著名的僧侣之一——空海。这位僧侣希望开发一种新的修行方式。\n\n他的修行方式如下：\n\n- 空海阅读一部包含 $N$ 句经文的经书。这些经文是有序的，他必须按顺序阅读。\n- 每句经文上标有一个介于 $1$ 到 $N$（含）之间的整数，且任意两句不同的经文所标数字不同。\n- 他必须在一天中被均分为 $N$ 个时间段的第 $i$ 个时间段内阅读标有整数 $i$（$1 \\le i \\le N$）的那句经文。每句经文都很短，因此他总能在每个时间段内读完一句经文。\n\n空海希望尽快读完整部经书。然而，他完成阅读所需的天数取决于经文上所标整数的排列方式。JOI 君被空海要求计算：在最优阅读策略下，有多少种整数分配方式能使空海恰好用 $K$ 天完成阅读。\n\n**任务**\n\n给定经文数量 $N$ 和整数 $K$，计算在最优阅读策略下，能使空海恰好用 $K$ 天完成阅读的整数分配方式的总数，结果对 $1\\,000\\,000\\,007$ 取模。", "inputFormat": "从标准输入读取以下数据：\n\n- 输入第一行包含两个整数 $N$ 和 $K$，以单个空格分隔。\n", "outputFormat": "输出在最优阅读策略下，能使空海恰好用 $K$ 天完成阅读的整数分配方式的总数，结果对 $1\\,000\\,000\\,007$ 取模。", "hint": "### 样例 1 解释\n\n共有 4 种整数分配方式，能使他恰好用 2 天完成阅读：\n\n- 第一句经文标有 $1$，第二句标有 $3$，最后一句标有 $2$。他在第一天阅读前两句经文（分别标有 $1$ 和 $3$），在第二天阅读最后一句经文（标有 $2$）。\n- 第一句经文标有 $2$，第二句标有 $1$，最后一句标有 $3$。\n- 第一句经文标有 $2$，第二句标有 $3$，最后一句标有 $1$。\n- 第一句经文标有 $3$，第二句标有 $1$，最后一句标有 $2$。\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le N \\le 100\\,000$。\n- $1 \\le K \\le N$。\n\n\n### 子任务\n\n共有 4 个子任务。每个子任务的得分和附加约束如下：\n\n**子任务 1 [4 分]**\n\n- $N \\le 10$。\n\n**子任务 2 [20 分]**\n\n- $N \\le 300$。\n\n**子任务 3 [25 分]**\n\n- $N \\le 3\\,000$。\n\n**子任务 4 [51 分]**\n\n无额外约束。", "locale": "zh-CN"}}}
{"pid": "P14369", "type": "P", "difficulty": 6, "samples": [["", ""]], "limits": {"time": [20000, 20000, 20000, 20000, 20000, 20000], "memory": [524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "提交答案", "Special Judge", "爬山算法 Local search", "模拟退火", "JOISC/JOIST（日本）"], "title": "[JOISC 2018] 路网服务 / Road Service", "background": "", "description": "**这是一道提交答案题。如果希望直接提交答案的生成代码，请确保它不会运行超过 20 秒。**\n\nIOI 王国有 $N$ 座城市，编号从 $1$ 到 $N$。此外还有 $N - 1$ 条双向道路，编号从 $1$ 到 $N - 1$。第 $i$ 条道路连接第 $A_i$ 座城市和第 $B_i$ 座城市。任意两座城市之间均存在路径。\n\n两座城市之间的距离定义为连接它们的最少道路数。IOI 王国的总距离定义为所有不同城市对之间距离的总和。\n\nIOI 王国的国王计划修建 $K$ 条额外的道路，以减少总距离并提升便利性。\n\n你作为国王的助手，需帮助国王制定一个良好的修建方案。\n\n**任务**\n\n给定 IOI 王国现有道路的信息以及待修建道路的数量，输出一个修建 $K$ 条道路的方案。总距离越小，你获得的分数越高。", "inputFormat": "本任务共有 6 个输入。请从每个输入中读取以下数据：\n\n- 输入第一行包含三个以空格分隔的整数 $N$、$K$ 和 $W_0$。这表示 IOI 王国有 $N$ 座城市，国王计划修建 $K$ 条道路，$W_0$ 是评分参数。\n- 接下来的 $N - 1$ 行中，第 $i$ 行（$1 \\le i \\le N - 1$）包含两个整数 $A_i$ 和 $B_i$，表示第 $i$ 条道路连接的城市。", "outputFormat": "在提交文件中写入 $K$ 行。\n\n输出的第 $j$ 行包含两个整数 $X_j$、$Y_j$（$1 \\le X_j \\le N$，$1 \\le Y_j \\le N$），表示待修建道路所连接的两座城市。", "hint": "### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le N \\le 1000$。\n- $1 \\le A_i < B_i \\le N$（$1 \\le i \\le N - 1$）。\n- $(A_i, B_i) \\ne (A_k, B_k)$（$1 \\le i < k \\le N - 1$）。\n- 任意两座城市之间均存在路径。\n\n### 评分规则\n\n对于每个输入，你的得分按如下方式计算：\n\n若你的输出不符合格式要求，则得分为零分。否则，设按你的方案修建道路后，总距离为 $W$，该输入对应的满分为 $P$。我们定义：\n\n$$\nS = 1.0 - \\frac{W}{W_0}\n$$\n\n那么，你在此输入中获得的得分为：\n\n$$\n\\min(P, P \\times 20^S)\n$$\n\n本任务的总分为所有输入得分之和，四舍五入取最接近的整数。\n\n各输入数据对应的 $N$、$K$、$W_0$、$P$ 值如下表所示：\n\n| 输入数据 | $N$  | $K$  | $W_0$    | $P$ |\n|:--------:|:----:|:----:|:--------:|:---:|\n| $1$        | $20$   | $4$    | $512$      | $10$  |\n| $2$        | $1000$ | $100$  | $2650000$  | $18$  |\n| $3$        | $1000$ | $300$  | $1755000$  | $18$  |\n| $4$        | $1000$ | $100$  | $2900000$  | $18$  |\n| $5$        | $1000$ | $100$  | $2690000$  | $18$  |\n| $6$        | $1000$ | $300$  | $1745000$  | $18$  |\n\n翻译由 Qwen3-235B 完成。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2018] 路网服务 / Road Service", "background": "", "description": "**这是一道提交答案题。如果希望直接提交答案的生成代码，请确保它不会运行超过 20 秒。**\n\nIOI 王国有 $N$ 座城市，编号从 $1$ 到 $N$。此外还有 $N - 1$ 条双向道路，编号从 $1$ 到 $N - 1$。第 $i$ 条道路连接第 $A_i$ 座城市和第 $B_i$ 座城市。任意两座城市之间均存在路径。\n\n两座城市之间的距离定义为连接它们的最少道路数。IOI 王国的总距离定义为所有不同城市对之间距离的总和。\n\nIOI 王国的国王计划修建 $K$ 条额外的道路，以减少总距离并提升便利性。\n\n你作为国王的助手，需帮助国王制定一个良好的修建方案。\n\n**任务**\n\n给定 IOI 王国现有道路的信息以及待修建道路的数量，输出一个修建 $K$ 条道路的方案。总距离越小，你获得的分数越高。", "inputFormat": "本任务共有 6 个输入。请从每个输入中读取以下数据：\n\n- 输入第一行包含三个以空格分隔的整数 $N$、$K$ 和 $W_0$。这表示 IOI 王国有 $N$ 座城市，国王计划修建 $K$ 条道路，$W_0$ 是评分参数。\n- 接下来的 $N - 1$ 行中，第 $i$ 行（$1 \\le i \\le N - 1$）包含两个整数 $A_i$ 和 $B_i$，表示第 $i$ 条道路连接的城市。", "outputFormat": "在提交文件中写入 $K$ 行。\n\n输出的第 $j$ 行包含两个整数 $X_j$、$Y_j$（$1 \\le X_j \\le N$，$1 \\le Y_j \\le N$），表示待修建道路所连接的两座城市。", "hint": "### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le N \\le 1000$。\n- $1 \\le A_i < B_i \\le N$（$1 \\le i \\le N - 1$）。\n- $(A_i, B_i) \\ne (A_k, B_k)$（$1 \\le i < k \\le N - 1$）。\n- 任意两座城市之间均存在路径。\n\n### 评分规则\n\n对于每个输入，你的得分按如下方式计算：\n\n若你的输出不符合格式要求，则得分为零分。否则，设按你的方案修建道路后，总距离为 $W$，该输入对应的满分为 $P$。我们定义：\n\n$$\nS = 1.0 - \\frac{W}{W_0}\n$$\n\n那么，你在此输入中获得的得分为：\n\n$$\n\\min(P, P \\times 20^S)\n$$\n\n本任务的总分为所有输入得分之和，四舍五入取最接近的整数。\n\n各输入数据对应的 $N$、$K$、$W_0$、$P$ 值如下表所示：\n\n| 输入数据 | $N$  | $K$  | $W_0$    | $P$ |\n|:--------:|:----:|:----:|:--------:|:---:|\n| $1$        | $20$   | $4$    | $512$      | $10$  |\n| $2$        | $1000$ | $100$  | $2650000$  | $18$  |\n| $3$        | $1000$ | $300$  | $1755000$  | $18$  |\n| $4$        | $1000$ | $100$  | $2900000$  | $18$  |\n| $5$        | $1000$ | $100$  | $2690000$  | $18$  |\n| $6$        | $1000$ | $300$  | $1745000$  | $18$  |\n\n翻译由 Qwen3-235B 完成。", "locale": "zh-CN"}}}
{"pid": "P14370", "type": "P", "difficulty": 4, "samples": [["3 6\n2\n5\n3\n1 2 4\n2 2 4\n3 2 4\n4 2 4\n5 2 4\n6 2 4", "0\n1\n1\n2\n1\n2"], ["4 2\n1\n1\n1\n1\n2 1 4\n1 3 6", "2\n0"], ["6 6\n11\n36\n28\n80\n98\n66\n36 29 33\n190 171 210\n18 20 100\n1000 900 1100\n92 87 99\n200 100 300", "1\n6\n0\n5\n2\n7"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "2018", "JOISC/JOIST（日本）"], "title": "[JOISC 2018] 最差的记者 3 / Worst Reporter 3", "background": "", "description": "在 IOI 2018 的开幕式上，$N$ 名参赛者排成一列，该列由一条数轴表示。所有参赛者面向数轴的正方向前进。在时间 $0$ 时，第 $i$ 名参赛者（$1 \\le i \\le N$，从前向后计数）站在坐标 $-i$ 处。此外，旗手 IOI-chan 站在坐标 $0$ 处。\n\n每名参赛者都有一个称为 **迟滞值** 的参数。第 $i$ 名参赛者的 **迟滞值** 为 $D_i$。参赛者遵循以下规则：\n\n- 如果第 $i$ 名参赛者与他或她正前方的人（参赛者或 IOI-chan）之间的距离大于或等于 $D_i + 1$，则第 $i$ 名参赛者会移动到距离该人 $1$ 的位置。否则，第 $i$ 名参赛者不移动。\n\nIOI-chan 每单位时间沿数轴正方向移动距离 $1$。每当上述条件满足时，参赛者会立即移动。\n\n你作为记者负责报道开幕式。你本应拍照，但整场仪式期间你都睡着了。没办法——你决定作弊，先拍摄大厅的照片，再在照片上画出人物。\n\n为了避免被发现作弊，或为了估算画图所需的时间，你希望知道以下 $Q$ 个值：\n\n- 在时间 $T_j$（$1 \\le j \\le Q$）时，站在坐标区间 $[L_j, R_j]$（含端点）内的人数。\n\n**任务**\n\n给定每名参赛者的 **迟滞值** 以及 $Q$ 个问题的数据，编写一个程序，计算每个问题所满足条件的人数。", "inputFormat": "从标准输入读取以下数据：\n\n- 输入的第一行包含两个由空格分隔的整数 $N$ 和 $Q$。这表示共有 $N$ 名参赛者（不包括 IOI-chan），以及共有 $Q$ 个问题。\n- 接下来的 $N$ 行中，第 $i$ 行（$1 \\le i \\le N$）包含一个整数 $D_i$。这表示从队首数起的第 $i$ 名参赛者的 **迟滞值** 为 $D_i$。\n- 再接下来的 $Q$ 行中，第 $j$ 行（$1 \\le j \\le Q$）包含三个由空格分隔的整数 $T_j$、$L_j$ 和 $R_j$。这些值代表第 $j$ 个问题。\n", "outputFormat": "向标准输出写入 $Q$ 行。第 $j$ 行（$1 \\le j \\le Q$）应包含第 $j$ 个问题的答案。\n", "hint": "### 样例 1 解释\n\n在本示例输入中，参赛者与 IOI-chan 的移动过程如下。\n\n以下内容中，区间 $[L, R]$ 表示数轴上坐标介于 $L$ 与 $R$ 之间（含端点）的所有点的集合。\n\n- 在时间 $0$，IOI-chan 站在坐标 $0$ 处。第 1、2、3 名参赛者分别站在坐标 $-1$、$-2$ 和 $-3$ 处。\n- 在时间 $1$，IOI-chan 移动到坐标 $1$。无参赛者移动；第 1、2、3 名参赛者仍分别站在坐标 $-1$、$-2$ 和 $-3$ 处。由于区间 $[2, 4]$ 内无人，第一个问题的输出为 $0$。\n- 在时间 $2$，IOI-chan 移动到坐标 $2$。此时 IOI-chan 与第 1 名参赛者之间的距离为 $3$，因此第 1 名参赛者移动到坐标 $1$。第 1、2、3 名参赛者分别站在坐标 $1$、$-2$ 和 $-3$ 处。由于区间 $[2, 4]$ 内仅有 IOI-chan，第二个问题的输出为 $1$。\n- 在时间 $3$，IOI-chan 移动到坐标 $3$。无参赛者移动；第 1、2、3 名参赛者仍分别站在坐标 $1$、$-2$ 和 $-3$ 处。由于区间 $[2, 4]$ 内仅有 IOI-chan，第三个问题的输出为 $1$。\n- 在时间 $4$，IOI-chan 移动到坐标 $4$。此时 IOI-chan 与第 1 名参赛者之间的距离为 $3$，因此第 1 名参赛者移动到坐标 $3$。第 1、2、3 名参赛者分别站在坐标 $3$、$-2$ 和 $-3$ 处。由于区间 $[2, 4]$ 内有 IOI-chan 和第 1 名参赛者，第四个问题的输出为 $2$。\n- 在时间 $5$，IOI-chan 移动到坐标 $5$。无参赛者移动；第 1、2、3 名参赛者仍分别站在坐标 $3$、$-2$ 和 $-3$ 处。由于区间 $[2, 4]$ 内仅有第 1 名参赛者，第五个问题的输出为 $1$。\n- 在时间 $6$，IOI-chan 移动到坐标 $6$。此时 IOI-chan 与第 1 名参赛者之间的距离为 $3$，因此第 1 名参赛者移动到坐标 $5$。接着，第 1 名与第 2 名参赛者之间的距离变为 $7$，因此第 2 名参赛者移动到坐标 $4$。此外，第 2 名与第 3 名参赛者之间的距离也变为 $7$，因此第 3 名参赛者移动到坐标 $3$。第 1、2、3 名参赛者分别站在坐标 $5$、$4$ 和 $3$ 处。由于区间 $[2, 4]$ 内有第 2 名和第 3 名参赛者，第六个问题的输出为 $2$。\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le N \\le 500\\,000$。\n- $1 \\le Q \\le 500\\,000$。\n- $1 \\le D_i \\le 1\\,000\\,000\\,000$（$1 \\le i \\le N$）。\n- $1 \\le T_j \\le 1\\,000\\,000\\,000$（$1 \\le j \\le Q$）。\n- $1 \\le L_j \\le R_j \\le 1\\,000\\,000\\,000$（$1 \\le j \\le Q$）。\n\n### 子任务\n\n共有 3 个子任务。每个子任务的得分及附加约束如下：\n\n**子任务 1 [7 分]**\n\n- $D_i = 1$（$1 \\le i \\le N$）。\n\n**子任务 2 [12 分]**\n\n- $N \\le 1\\,000$。\n- $Q \\le 1\\,000$。\n- $T_j \\le 1\\,000$（$1 \\le j \\le Q$）。\n- $1 \\le L_j \\le R_j \\le 1\\,000$（$1 \\le j \\le Q$）。\n\n**子任务 3 [81 分]**\n\n无附加约束。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2018] 最差的记者 3 / Worst Reporter 3", "background": "", "description": "在 IOI 2018 的开幕式上，$N$ 名参赛者排成一列，该列由一条数轴表示。所有参赛者面向数轴的正方向前进。在时间 $0$ 时，第 $i$ 名参赛者（$1 \\le i \\le N$，从前向后计数）站在坐标 $-i$ 处。此外，旗手 IOI-chan 站在坐标 $0$ 处。\n\n每名参赛者都有一个称为 **迟滞值** 的参数。第 $i$ 名参赛者的 **迟滞值** 为 $D_i$。参赛者遵循以下规则：\n\n- 如果第 $i$ 名参赛者与他或她正前方的人（参赛者或 IOI-chan）之间的距离大于或等于 $D_i + 1$，则第 $i$ 名参赛者会移动到距离该人 $1$ 的位置。否则，第 $i$ 名参赛者不移动。\n\nIOI-chan 每单位时间沿数轴正方向移动距离 $1$。每当上述条件满足时，参赛者会立即移动。\n\n你作为记者负责报道开幕式。你本应拍照，但整场仪式期间你都睡着了。没办法——你决定作弊，先拍摄大厅的照片，再在照片上画出人物。\n\n为了避免被发现作弊，或为了估算画图所需的时间，你希望知道以下 $Q$ 个值：\n\n- 在时间 $T_j$（$1 \\le j \\le Q$）时，站在坐标区间 $[L_j, R_j]$（含端点）内的人数。\n\n**任务**\n\n给定每名参赛者的 **迟滞值** 以及 $Q$ 个问题的数据，编写一个程序，计算每个问题所满足条件的人数。", "inputFormat": "从标准输入读取以下数据：\n\n- 输入的第一行包含两个由空格分隔的整数 $N$ 和 $Q$。这表示共有 $N$ 名参赛者（不包括 IOI-chan），以及共有 $Q$ 个问题。\n- 接下来的 $N$ 行中，第 $i$ 行（$1 \\le i \\le N$）包含一个整数 $D_i$。这表示从队首数起的第 $i$ 名参赛者的 **迟滞值** 为 $D_i$。\n- 再接下来的 $Q$ 行中，第 $j$ 行（$1 \\le j \\le Q$）包含三个由空格分隔的整数 $T_j$、$L_j$ 和 $R_j$。这些值代表第 $j$ 个问题。\n", "outputFormat": "向标准输出写入 $Q$ 行。第 $j$ 行（$1 \\le j \\le Q$）应包含第 $j$ 个问题的答案。\n", "hint": "### 样例 1 解释\n\n在本示例输入中，参赛者与 IOI-chan 的移动过程如下。\n\n以下内容中，区间 $[L, R]$ 表示数轴上坐标介于 $L$ 与 $R$ 之间（含端点）的所有点的集合。\n\n- 在时间 $0$，IOI-chan 站在坐标 $0$ 处。第 1、2、3 名参赛者分别站在坐标 $-1$、$-2$ 和 $-3$ 处。\n- 在时间 $1$，IOI-chan 移动到坐标 $1$。无参赛者移动；第 1、2、3 名参赛者仍分别站在坐标 $-1$、$-2$ 和 $-3$ 处。由于区间 $[2, 4]$ 内无人，第一个问题的输出为 $0$。\n- 在时间 $2$，IOI-chan 移动到坐标 $2$。此时 IOI-chan 与第 1 名参赛者之间的距离为 $3$，因此第 1 名参赛者移动到坐标 $1$。第 1、2、3 名参赛者分别站在坐标 $1$、$-2$ 和 $-3$ 处。由于区间 $[2, 4]$ 内仅有 IOI-chan，第二个问题的输出为 $1$。\n- 在时间 $3$，IOI-chan 移动到坐标 $3$。无参赛者移动；第 1、2、3 名参赛者仍分别站在坐标 $1$、$-2$ 和 $-3$ 处。由于区间 $[2, 4]$ 内仅有 IOI-chan，第三个问题的输出为 $1$。\n- 在时间 $4$，IOI-chan 移动到坐标 $4$。此时 IOI-chan 与第 1 名参赛者之间的距离为 $3$，因此第 1 名参赛者移动到坐标 $3$。第 1、2、3 名参赛者分别站在坐标 $3$、$-2$ 和 $-3$ 处。由于区间 $[2, 4]$ 内有 IOI-chan 和第 1 名参赛者，第四个问题的输出为 $2$。\n- 在时间 $5$，IOI-chan 移动到坐标 $5$。无参赛者移动；第 1、2、3 名参赛者仍分别站在坐标 $3$、$-2$ 和 $-3$ 处。由于区间 $[2, 4]$ 内仅有第 1 名参赛者，第五个问题的输出为 $1$。\n- 在时间 $6$，IOI-chan 移动到坐标 $6$。此时 IOI-chan 与第 1 名参赛者之间的距离为 $3$，因此第 1 名参赛者移动到坐标 $5$。接着，第 1 名与第 2 名参赛者之间的距离变为 $7$，因此第 2 名参赛者移动到坐标 $4$。此外，第 2 名与第 3 名参赛者之间的距离也变为 $7$，因此第 3 名参赛者移动到坐标 $3$。第 1、2、3 名参赛者分别站在坐标 $5$、$4$ 和 $3$ 处。由于区间 $[2, 4]$ 内有第 2 名和第 3 名参赛者，第六个问题的输出为 $2$。\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le N \\le 500\\,000$。\n- $1 \\le Q \\le 500\\,000$。\n- $1 \\le D_i \\le 1\\,000\\,000\\,000$（$1 \\le i \\le N$）。\n- $1 \\le T_j \\le 1\\,000\\,000\\,000$（$1 \\le j \\le Q$）。\n- $1 \\le L_j \\le R_j \\le 1\\,000\\,000\\,000$（$1 \\le j \\le Q$）。\n\n### 子任务\n\n共有 3 个子任务。每个子任务的得分及附加约束如下：\n\n**子任务 1 [7 分]**\n\n- $D_i = 1$（$1 \\le i \\le N$）。\n\n**子任务 2 [12 分]**\n\n- $N \\le 1\\,000$。\n- $Q \\le 1\\,000$。\n- $T_j \\le 1\\,000$（$1 \\le j \\le Q$）。\n- $1 \\le L_j \\le R_j \\le 1\\,000$（$1 \\le j \\le Q$）。\n\n**子任务 3 [81 分]**\n\n无附加约束。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN"}}}
{"pid": "P14371", "type": "P", "difficulty": 6, "samples": [["", ""]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "交互题", "Special Judge", "通信题", "JOISC/JOIST（日本）"], "title": "[JOISC 2018] 航空路线图 / Airline Route Map", "background": "在洛谷上提交时，需要将两个文件合并成一个提交。\n\n**不要引入任何头文件**，并在文件头加入以下内容：\n\n```cpp\nvoid Alice(int N, int M, int A[], int B[] );\nvoid InitG(int V, int U );\nvoid MakeG(int pos, int C, int D );\nvoid Bob(int V, int U, int C[], int D[] );\nvoid InitMap(int N, int M );\nvoid MakeMap(int A, int B );\n```", "description": "Alice 居住在 JOI 王国。她计划邀请居住在 IOI 共和国的 Bob。在邀请他之前，她打算将 JOI 王国的航线地图发送给他。JOI 王国是一个由 $N$ 个岛屿组成的岛国，岛屿编号从 $0$ 到 $N-1$。JOI 王国内共有 $M$ 条航线。对于每个 $i$（$0 \\le i \\le M-1$），第 $(i+1)$ 条航线连接岛屿 $A_i$ 和岛屿 $B_i$，且为双向航线。任意两条航线不会连接相同的两个岛屿。她必须使用一台由 JOI 王国运营的特殊电报机。她可以通过该电报机发送一个无向图。然而，当她使用它时，顶点编号和边编号会被随机打乱。\n\n具体而言，信息的发送方式如下。设 $G$ 为 Alice 发送的图（令 $V$ 为图 $G$ 的顶点数，$U$ 为图 $G$ 的边数）：\n\n- Alice 指定图 $G$ 的边数 $V$ 和边数 $U$。然后，她将数字 $0, 1, \\ldots, V-1$ 分别分配给每个顶点，将数字 $0, 1, \\ldots, U-1$ 分别分配给每条边。\n- Alice 指定参数 $C_0, C_1, \\ldots, C_{U-1}$ 和 $D_0, D_1, \\ldots, D_{U-1}$。这些参数描述图 $G$ 的边，即对于每个 $j$（$0 \\le j \\le U-1$），图 $G$ 的第 $j$ 条边连接顶点 $C_j$ 和顶点 $D_j$。\n- 图 $G$ 的顶点编号由 JOI 王国打乱。首先，JOI 王国生成一个序列 $p[0], p[1], \\ldots, p[V-1]$，它是 $0, 1, \\ldots, V-1$ 的一个排列。然后，$C_0, C_1, \\ldots, C_{U-1}$ 被替换为 $p[C_0], p[C_1], \\ldots, p[C_{U-1}]$，而 $D_0, D_1, \\ldots, D_{U-1}$ 被替换为 $p[D_0], p[D_1], \\ldots, p[D_{U-1}]$。\n- 接着，图 $G$ 的边编号由 JOI 王国打乱。首先，JOI 王国生成一个序列 $q[0], q[1], \\ldots, q[U-1]$，它是 $0, 1, \\ldots, U-1$ 的一个排列。然后，$C_0, C_1, \\ldots, C_{U-1}$ 被替换为 $C_{q[0]}, C_{q[1]}, \\ldots, C_{q[U-1]}$，而 $D_0, D_1, \\ldots, D_{U-1}$ 被替换为 $D_{q[0]}, D_{q[1]}, \\ldots, D_{q[U-1]}$。\n- 以下数据被发送给 Bob：$V$ 和 $U$ 的值，以及参数 $C_0, C_1, \\ldots, C_{U-1}$ 和 $D_0, D_1, \\ldots, D_{U-1}$ 的最新值。\n\n请注意，使用这台电报机只能发送一个简单图。此处，“简单图”指不含重边和自环的图。\n\n换句话说，她可以发送一个满足以下条件的图：对于任意 $i, j$（$0 \\le i < j \\le U-1$），$(C_i, D_i) \\ne (C_j, D_j)$ 且 $(C_i, D_i) \\ne (D_j, C_j)$ 成立；同时，对于任意 $i$（$0 \\le i \\le U-1$），$C_i \\ne D_i$ 成立。\n\nAlice 希望使用顶点数最少的图，将 JOI 王国的航线地图发送给 Bob。\n\n**任务**\n\n为了帮助 Alice 与 Bob 之间的通信，请编写以下两个程序：\n\n- 给定 JOI 王国的岛屿数量 $N$、航线数量 $M$，以及表示 JOI 王国航线地图的序列 $A$、$B$，第一个程序应输出 Alice 发送的图 $G$ 的信息。\n- 给定 Bob 收到的图 $G$ 的信息，第二个程序应恢复 JOI 王国的航线地图。\n\n**实现细节**\n\n你需要提交两个文件。\n\n第一个文件为 `Alice.cpp`。该文件应输出 Alice 发送的图的信息。它应实现以下函数。程序应包含头文件 `Alicelib.h`。\n- `void Alice( int N, int M, int A[], int B[] )`\n\n  对于每个测试用例，该函数被调用一次。\n  - 参数 $N$ 是 JOI 王国的岛屿数量。\n  - 参数 $M$ 是 JOI 王国的航线数量。\n  - 参数 $A[]$、$B[]$ 是长度为 $M$ 的序列，用于描述 JOI 王国的航线地图。\n\n通过以下函数，函数 `Alice` 输出 Alice 发送的图 $G$ 的信息。\n\n- `void InitG( int V, int U )`\n\n  该函数指定图 $G$ 的顶点数和边数。\n  - 参数 $V$ 是图 $G$ 的顶点数。参数 $V$ 应为介于 $1$ 到 $1500$（含）之间的整数。若调用该函数时参数超出此范围，你的程序将被视为 **Wrong Answer [1]**。\n  - 参数 $U$ 是图 $G$ 的边数。参数 $U$ 应为介于 $0$ 到 $V(V-1)/2$（含）之间的整数。若调用该函数时参数超出此范围，你的程序将被视为 **Wrong Answer [2]**。\n\n- `void MakeG( int pos, int C, int D )`\n\n  该函数指定图 $G$ 的边。\n  - 参数 `pos` 是由本次调用指定的边的编号。参数 `pos` 应为介于 $0$ 到 $U-1$（含）之间的整数。若调用该函数时参数超出此范围，你的程序将被视为 **Wrong Answer [3]**。该函数对相同的参数 `pos` 不应被调用超过一次；若被多次调用，你的程序将被视为 **Wrong Answer [4]**。\n  - 参数 $C$ 和 $D$ 是图 $G$ 中边 `pos` 的两个顶点。$C$ 和 $D$ 应为介于 $0$ 到 $V-1$（含）之间的整数，且应满足 $C \\ne D$。若 $C$ 或 $D$ 不满足这些条件，你的程序将被视为 **Wrong Answer [5]**。此处，$U$ 和 $V$ 是由函数 `InitG` 指定的整数。\n\n在函数 `Alice` 中，调用函数 `InitG` 一次后，函数 `MakeG` 应被恰好调用 $U$ 次。若函数 `InitG` 被调用两次，你的程序将被视为 **Wrong Answer [6]**。若在调用函数 `InitG` 之前调用了函数 `MakeG`，你的程序将被视为 **Wrong Answer [7]**。若在函数 `Alice` 结束时未调用函数 `InitG`，或函数 `MakeG` 未被调用 $U$ 次，你的程序将被视为 **Wrong Answer [8]**。当函数 `Alice` 结束时，若 Alice 描述的图 $G$ 不是一个简单图，你的程序将被视为 **Wrong Answer [9]**。\n\n若对函数 `Alice` 的调用被视为 **Wrong Answer**，你的程序将立即终止。\n\n第二个文件为 `Bob.cpp`。该文件在给定 Bob 收到的图 $G$ 的信息后，输出 JOI 王国的航线地图。它应实现以下函数。程序应包含头文件 `Boblib.h`。\n\n- `void Bob( int V, int U, int C[], int D[] )`\n\n  对于每个测试用例，该函数被调用一次。\n  - 参数 $V$ 是图 $G$ 的顶点数。\n  - 参数 $U$ 是图 $G$ 的边数。\n  - 参数 $C[]$、$D[]$ 是长度为 $U$ 的序列，用于描述图 $G$ 的边。\n\n通过以下函数，函数 `Bob` 恢复 JOI 王国的航线地图，并输出航线地图的信息。\n\n- `void InitMap( int N, int M )`\n\n  该函数指定 JOI 王国的岛屿数量和航线数量。\n  - 参数 $N$ 是恢复出的 JOI 王国岛屿数量。$N$ 应为一个整数，且必须等于 JOI 王国实际的岛屿数量。若两者不相等，你的程序将被视为 **Wrong Answer [10]**。\n  - 参数 $M$ 是恢复出的 JOI 王国航线数量。$M$ 应为一个整数，且必须等于 JOI 王国实际的航线数量。若两者不相等，你的程序将被视为 **Wrong Answer [11]**。\n\n- `void MakeMap( int A, int B )`\n\n  该函数指定 JOI 王国的航线数量。\n  - 参数 $A$ 和 $B$ 表示存在一条连接岛屿 $A$ 与岛屿 $B$ 的航线。$A$ 和 $B$ 应为介于 $0$ 到 $N-1$（含）之间的整数，且应满足 $A \\ne B$。若 $A$ 或 $B$ 不满足这些条件，你的程序将被视为 **Wrong Answer [12]**。若在 JOI 王国中不存在连接岛屿 $A$ 与岛屿 $B$ 的航线，你的程序将被视为 **Wrong Answer [13]**。由该函数调用所描述的航线应与之前调用所描述的航线不同。当调用 `MakeMap( A, B )` 时，若此前已调用过 `MakeMap( A, B )` 或 `MakeMap( B, A )`，你的程序将被视为 **Wrong Answer [14]**。\n\n此处，$N$ 是由 `InitMap` 指定的整数值。\n\n在函数 `Bob` 中，调用函数 `InitMap` 一次后，函数 `MakeMap` 应被恰好调用 $M$ 次。若函数 `InitMap` 被调用两次，你的程序将被视为 **Wrong Answer [15]**。若在调用函数 `InitMap` 之前调用了函数 `MakeMap`，你的程序将被视为 **Wrong Answer [16]**。若在函数 `Bob` 结束时未调用函数 `InitMap`，或函数 `MakeMap` 未被调用 $M$ 次，你的程序将被视为 **Wrong Answer [17]**。此处，$M$ 是由 `InitMap` 指定的整数值。\n\n若对函数 `Bob` 的调用被视为 **Wrong Answer**，你的程序将立即终止。\n\n**评分流程**\n\n评分按以下方式进行。若你的程序被视为 **Wrong Answer**，它将立即终止。\n\n（1）调用一次函数 `Alice`，其参数描述 JOI 王国的航线地图信息。\n\n（2）设 $G$ 为由函数 `Alice` 指定的图。调用一次函数 `Bob`，其参数为图 $G$ 的顶点编号的随机重排和边编号的随机重排。\n\n（3）你的程序被评分。\n\n**重要提示**\n\n- 你的程序可以为内部使用实现其他函数，或使用全局变量。提交的文件将与评分器一起编译，并生成一个可执行文件。所有全局变量和内部函数应声明为 `static`，以避免与其他文件冲突。评分时，程序将作为两个独立进程（Alice 进程和 Bob 进程）运行。Alice 进程与 Bob 进程之间不能共享全局变量。\n\n- 你的程序不应使用标准输入和标准输出。你的程序不应通过任何方式与其他文件通信。但，你的程序可以向标准错误输出调试信息。\n\n**编译与测试运行**\n\n你可以从竞赛网页下载一个归档文件，其中包含用于测试你程序的样例评分器。该归档文件还包含你程序的一个样例源代码文件。\n\n样例评分器由一个源文件组成，即 `grader.cpp`。若你的程序为 `Alice.cpp` 和 `Bob.cpp`，为测试它们，你需要将这些文件（`grader.cpp`、`Alice.cpp`、`Bob.cpp`、`Alicelib.h` 和 `Boblib.h`）放入同一目录，并运行以下命令来编译你的程序：\n\n```\ng++ -std=c++14 -O2 -o grader grader.cpp Alice.cpp Bob.cpp\n```\n\n当编译成功后，将生成可执行文件 `grader`。\n\n请注意，实际评分器与样例评分器不同。样例评分器将以单个进程方式运行，它将从标准输入读取输入数据，并将结果写入标准输出。", "inputFormat": "样例评分器从标准输入读取以下数据。\n\n- 第一行包含两个以空格分隔的整数，表示 JOI 王国由 $N$ 个岛屿组成，且 JOI 王国共有 $M$ 条航线。\n- 接下来的 $M$ 行包含航线地图的信息。第 $(i+1)$ 行（其中 $0 \\le i \\le M-1$）包含两个以空格分隔的整数 $A_i$、$B_i$，它们描述 JOI 王国航线地图的信息。\n", "outputFormat": "当程序成功终止时，样例评分器将以下信息写入标准输出。（引号本身不会实际输出。）\n\n- 若你的程序被视为 **Wrong Answer**，样例评分器将以如下格式输出其类型：“Wrong Answer [1]”，然后终止。\n- 若对函数 `Alice` 和 `Bob` 的调用均未被视为 **Wrong Answer**，样例评分器将输出 “Accepted.”，并同时输出 $V$ 的值。\n\n若你的程序被视为多种类型的 **Wrong Answer**，样例评分器仅报告其中一种。", "hint": "### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le N \\le 1000$。\n- $0 \\le M \\le N(N-1)/2$。\n- $0 \\le A_i \\le N-1$（其中 $0 \\le i \\le M-1$）。\n- $0 \\le B_i \\le N-1$（其中 $0 \\le i \\le M-1$）。\n- $A_i \\ne B_i$（其中 $0 \\le i \\le M-1$）。\n- $(A_i, B_i) \\ne (A_j, B_j)$ 且 $(A_i, B_i) \\ne (B_j, A_j)$（其中 $0 \\le i < j \\le M-1$）。\n\n### 子任务\n\n共有 3 个子任务。每个子任务的得分和附加约束如下：\n\n**子任务 1 [22 分]**\n\n- $N \\le 10$。\n\n**子任务 2 [15 分]**\n\n- $N \\le 40$。\n\n**子任务 3 [63 分]**\n\n无附加约束。\n\n**评分规则**\n\n- 在子任务 1 或子任务 2 中，若你的程序解决了所有测试用例，你将获得满分。\n- 在子任务 3 中，若你的程序解决了所有测试用例，你的得分按以下方式计算。令 $ \\text{MaxDiff} $ 为 $ V - N $ 的最大值：\n\n  - 当 $ 101 \\le \\text{MaxDiff} $ 时，你的得分为 $ 0 $。\n  - 当 $ 21 \\le \\text{MaxDiff} \\le 100 $ 时，你的得分为 $ 13 + \\left\\lfloor \\dfrac{100 - \\text{MaxDiff}}{4} \\right\\rfloor $。此处，$ \\lfloor x \\rfloor $ 表示不超过 $ x $ 的最大整数。\n  - 当 $ 13 \\le \\text{MaxDiff} \\le 20 $ 时，你的得分为 $ 33 + (20 - \\text{MaxDiff}) \\times 3 $。\n  - 当 $ \\text{MaxDiff} \\le 12 $ 时，你的得分为 $ 63 $。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2018] 航空路线图 / Airline Route Map", "background": "在洛谷上提交时，需要将两个文件合并成一个提交。\n\n**不要引入任何头文件**，并在文件头加入以下内容：\n\n```cpp\nvoid Alice(int N, int M, int A[], int B[] );\nvoid InitG(int V, int U );\nvoid MakeG(int pos, int C, int D );\nvoid Bob(int V, int U, int C[], int D[] );\nvoid InitMap(int N, int M );\nvoid MakeMap(int A, int B );\n```", "description": "Alice 居住在 JOI 王国。她计划邀请居住在 IOI 共和国的 Bob。在邀请他之前，她打算将 JOI 王国的航线地图发送给他。JOI 王国是一个由 $N$ 个岛屿组成的岛国，岛屿编号从 $0$ 到 $N-1$。JOI 王国内共有 $M$ 条航线。对于每个 $i$（$0 \\le i \\le M-1$），第 $(i+1)$ 条航线连接岛屿 $A_i$ 和岛屿 $B_i$，且为双向航线。任意两条航线不会连接相同的两个岛屿。她必须使用一台由 JOI 王国运营的特殊电报机。她可以通过该电报机发送一个无向图。然而，当她使用它时，顶点编号和边编号会被随机打乱。\n\n具体而言，信息的发送方式如下。设 $G$ 为 Alice 发送的图（令 $V$ 为图 $G$ 的顶点数，$U$ 为图 $G$ 的边数）：\n\n- Alice 指定图 $G$ 的边数 $V$ 和边数 $U$。然后，她将数字 $0, 1, \\ldots, V-1$ 分别分配给每个顶点，将数字 $0, 1, \\ldots, U-1$ 分别分配给每条边。\n- Alice 指定参数 $C_0, C_1, \\ldots, C_{U-1}$ 和 $D_0, D_1, \\ldots, D_{U-1}$。这些参数描述图 $G$ 的边，即对于每个 $j$（$0 \\le j \\le U-1$），图 $G$ 的第 $j$ 条边连接顶点 $C_j$ 和顶点 $D_j$。\n- 图 $G$ 的顶点编号由 JOI 王国打乱。首先，JOI 王国生成一个序列 $p[0], p[1], \\ldots, p[V-1]$，它是 $0, 1, \\ldots, V-1$ 的一个排列。然后，$C_0, C_1, \\ldots, C_{U-1}$ 被替换为 $p[C_0], p[C_1], \\ldots, p[C_{U-1}]$，而 $D_0, D_1, \\ldots, D_{U-1}$ 被替换为 $p[D_0], p[D_1], \\ldots, p[D_{U-1}]$。\n- 接着，图 $G$ 的边编号由 JOI 王国打乱。首先，JOI 王国生成一个序列 $q[0], q[1], \\ldots, q[U-1]$，它是 $0, 1, \\ldots, U-1$ 的一个排列。然后，$C_0, C_1, \\ldots, C_{U-1}$ 被替换为 $C_{q[0]}, C_{q[1]}, \\ldots, C_{q[U-1]}$，而 $D_0, D_1, \\ldots, D_{U-1}$ 被替换为 $D_{q[0]}, D_{q[1]}, \\ldots, D_{q[U-1]}$。\n- 以下数据被发送给 Bob：$V$ 和 $U$ 的值，以及参数 $C_0, C_1, \\ldots, C_{U-1}$ 和 $D_0, D_1, \\ldots, D_{U-1}$ 的最新值。\n\n请注意，使用这台电报机只能发送一个简单图。此处，“简单图”指不含重边和自环的图。\n\n换句话说，她可以发送一个满足以下条件的图：对于任意 $i, j$（$0 \\le i < j \\le U-1$），$(C_i, D_i) \\ne (C_j, D_j)$ 且 $(C_i, D_i) \\ne (D_j, C_j)$ 成立；同时，对于任意 $i$（$0 \\le i \\le U-1$），$C_i \\ne D_i$ 成立。\n\nAlice 希望使用顶点数最少的图，将 JOI 王国的航线地图发送给 Bob。\n\n**任务**\n\n为了帮助 Alice 与 Bob 之间的通信，请编写以下两个程序：\n\n- 给定 JOI 王国的岛屿数量 $N$、航线数量 $M$，以及表示 JOI 王国航线地图的序列 $A$、$B$，第一个程序应输出 Alice 发送的图 $G$ 的信息。\n- 给定 Bob 收到的图 $G$ 的信息，第二个程序应恢复 JOI 王国的航线地图。\n\n**实现细节**\n\n你需要提交两个文件。\n\n第一个文件为 `Alice.cpp`。该文件应输出 Alice 发送的图的信息。它应实现以下函数。程序应包含头文件 `Alicelib.h`。\n- `void Alice( int N, int M, int A[], int B[] )`\n\n  对于每个测试用例，该函数被调用一次。\n  - 参数 $N$ 是 JOI 王国的岛屿数量。\n  - 参数 $M$ 是 JOI 王国的航线数量。\n  - 参数 $A[]$、$B[]$ 是长度为 $M$ 的序列，用于描述 JOI 王国的航线地图。\n\n通过以下函数，函数 `Alice` 输出 Alice 发送的图 $G$ 的信息。\n\n- `void InitG( int V, int U )`\n\n  该函数指定图 $G$ 的顶点数和边数。\n  - 参数 $V$ 是图 $G$ 的顶点数。参数 $V$ 应为介于 $1$ 到 $1500$（含）之间的整数。若调用该函数时参数超出此范围，你的程序将被视为 **Wrong Answer [1]**。\n  - 参数 $U$ 是图 $G$ 的边数。参数 $U$ 应为介于 $0$ 到 $V(V-1)/2$（含）之间的整数。若调用该函数时参数超出此范围，你的程序将被视为 **Wrong Answer [2]**。\n\n- `void MakeG( int pos, int C, int D )`\n\n  该函数指定图 $G$ 的边。\n  - 参数 `pos` 是由本次调用指定的边的编号。参数 `pos` 应为介于 $0$ 到 $U-1$（含）之间的整数。若调用该函数时参数超出此范围，你的程序将被视为 **Wrong Answer [3]**。该函数对相同的参数 `pos` 不应被调用超过一次；若被多次调用，你的程序将被视为 **Wrong Answer [4]**。\n  - 参数 $C$ 和 $D$ 是图 $G$ 中边 `pos` 的两个顶点。$C$ 和 $D$ 应为介于 $0$ 到 $V-1$（含）之间的整数，且应满足 $C \\ne D$。若 $C$ 或 $D$ 不满足这些条件，你的程序将被视为 **Wrong Answer [5]**。此处，$U$ 和 $V$ 是由函数 `InitG` 指定的整数。\n\n在函数 `Alice` 中，调用函数 `InitG` 一次后，函数 `MakeG` 应被恰好调用 $U$ 次。若函数 `InitG` 被调用两次，你的程序将被视为 **Wrong Answer [6]**。若在调用函数 `InitG` 之前调用了函数 `MakeG`，你的程序将被视为 **Wrong Answer [7]**。若在函数 `Alice` 结束时未调用函数 `InitG`，或函数 `MakeG` 未被调用 $U$ 次，你的程序将被视为 **Wrong Answer [8]**。当函数 `Alice` 结束时，若 Alice 描述的图 $G$ 不是一个简单图，你的程序将被视为 **Wrong Answer [9]**。\n\n若对函数 `Alice` 的调用被视为 **Wrong Answer**，你的程序将立即终止。\n\n第二个文件为 `Bob.cpp`。该文件在给定 Bob 收到的图 $G$ 的信息后，输出 JOI 王国的航线地图。它应实现以下函数。程序应包含头文件 `Boblib.h`。\n\n- `void Bob( int V, int U, int C[], int D[] )`\n\n  对于每个测试用例，该函数被调用一次。\n  - 参数 $V$ 是图 $G$ 的顶点数。\n  - 参数 $U$ 是图 $G$ 的边数。\n  - 参数 $C[]$、$D[]$ 是长度为 $U$ 的序列，用于描述图 $G$ 的边。\n\n通过以下函数，函数 `Bob` 恢复 JOI 王国的航线地图，并输出航线地图的信息。\n\n- `void InitMap( int N, int M )`\n\n  该函数指定 JOI 王国的岛屿数量和航线数量。\n  - 参数 $N$ 是恢复出的 JOI 王国岛屿数量。$N$ 应为一个整数，且必须等于 JOI 王国实际的岛屿数量。若两者不相等，你的程序将被视为 **Wrong Answer [10]**。\n  - 参数 $M$ 是恢复出的 JOI 王国航线数量。$M$ 应为一个整数，且必须等于 JOI 王国实际的航线数量。若两者不相等，你的程序将被视为 **Wrong Answer [11]**。\n\n- `void MakeMap( int A, int B )`\n\n  该函数指定 JOI 王国的航线数量。\n  - 参数 $A$ 和 $B$ 表示存在一条连接岛屿 $A$ 与岛屿 $B$ 的航线。$A$ 和 $B$ 应为介于 $0$ 到 $N-1$（含）之间的整数，且应满足 $A \\ne B$。若 $A$ 或 $B$ 不满足这些条件，你的程序将被视为 **Wrong Answer [12]**。若在 JOI 王国中不存在连接岛屿 $A$ 与岛屿 $B$ 的航线，你的程序将被视为 **Wrong Answer [13]**。由该函数调用所描述的航线应与之前调用所描述的航线不同。当调用 `MakeMap( A, B )` 时，若此前已调用过 `MakeMap( A, B )` 或 `MakeMap( B, A )`，你的程序将被视为 **Wrong Answer [14]**。\n\n此处，$N$ 是由 `InitMap` 指定的整数值。\n\n在函数 `Bob` 中，调用函数 `InitMap` 一次后，函数 `MakeMap` 应被恰好调用 $M$ 次。若函数 `InitMap` 被调用两次，你的程序将被视为 **Wrong Answer [15]**。若在调用函数 `InitMap` 之前调用了函数 `MakeMap`，你的程序将被视为 **Wrong Answer [16]**。若在函数 `Bob` 结束时未调用函数 `InitMap`，或函数 `MakeMap` 未被调用 $M$ 次，你的程序将被视为 **Wrong Answer [17]**。此处，$M$ 是由 `InitMap` 指定的整数值。\n\n若对函数 `Bob` 的调用被视为 **Wrong Answer**，你的程序将立即终止。\n\n**评分流程**\n\n评分按以下方式进行。若你的程序被视为 **Wrong Answer**，它将立即终止。\n\n（1）调用一次函数 `Alice`，其参数描述 JOI 王国的航线地图信息。\n\n（2）设 $G$ 为由函数 `Alice` 指定的图。调用一次函数 `Bob`，其参数为图 $G$ 的顶点编号的随机重排和边编号的随机重排。\n\n（3）你的程序被评分。\n\n**重要提示**\n\n- 你的程序可以为内部使用实现其他函数，或使用全局变量。提交的文件将与评分器一起编译，并生成一个可执行文件。所有全局变量和内部函数应声明为 `static`，以避免与其他文件冲突。评分时，程序将作为两个独立进程（Alice 进程和 Bob 进程）运行。Alice 进程与 Bob 进程之间不能共享全局变量。\n\n- 你的程序不应使用标准输入和标准输出。你的程序不应通过任何方式与其他文件通信。但，你的程序可以向标准错误输出调试信息。\n\n**编译与测试运行**\n\n你可以从竞赛网页下载一个归档文件，其中包含用于测试你程序的样例评分器。该归档文件还包含你程序的一个样例源代码文件。\n\n样例评分器由一个源文件组成，即 `grader.cpp`。若你的程序为 `Alice.cpp` 和 `Bob.cpp`，为测试它们，你需要将这些文件（`grader.cpp`、`Alice.cpp`、`Bob.cpp`、`Alicelib.h` 和 `Boblib.h`）放入同一目录，并运行以下命令来编译你的程序：\n\n```\ng++ -std=c++14 -O2 -o grader grader.cpp Alice.cpp Bob.cpp\n```\n\n当编译成功后，将生成可执行文件 `grader`。\n\n请注意，实际评分器与样例评分器不同。样例评分器将以单个进程方式运行，它将从标准输入读取输入数据，并将结果写入标准输出。", "inputFormat": "样例评分器从标准输入读取以下数据。\n\n- 第一行包含两个以空格分隔的整数，表示 JOI 王国由 $N$ 个岛屿组成，且 JOI 王国共有 $M$ 条航线。\n- 接下来的 $M$ 行包含航线地图的信息。第 $(i+1)$ 行（其中 $0 \\le i \\le M-1$）包含两个以空格分隔的整数 $A_i$、$B_i$，它们描述 JOI 王国航线地图的信息。\n", "outputFormat": "当程序成功终止时，样例评分器将以下信息写入标准输出。（引号本身不会实际输出。）\n\n- 若你的程序被视为 **Wrong Answer**，样例评分器将以如下格式输出其类型：“Wrong Answer [1]”，然后终止。\n- 若对函数 `Alice` 和 `Bob` 的调用均未被视为 **Wrong Answer**，样例评分器将输出 “Accepted.”，并同时输出 $V$ 的值。\n\n若你的程序被视为多种类型的 **Wrong Answer**，样例评分器仅报告其中一种。", "hint": "### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le N \\le 1000$。\n- $0 \\le M \\le N(N-1)/2$。\n- $0 \\le A_i \\le N-1$（其中 $0 \\le i \\le M-1$）。\n- $0 \\le B_i \\le N-1$（其中 $0 \\le i \\le M-1$）。\n- $A_i \\ne B_i$（其中 $0 \\le i \\le M-1$）。\n- $(A_i, B_i) \\ne (A_j, B_j)$ 且 $(A_i, B_i) \\ne (B_j, A_j)$（其中 $0 \\le i < j \\le M-1$）。\n\n### 子任务\n\n共有 3 个子任务。每个子任务的得分和附加约束如下：\n\n**子任务 1 [22 分]**\n\n- $N \\le 10$。\n\n**子任务 2 [15 分]**\n\n- $N \\le 40$。\n\n**子任务 3 [63 分]**\n\n无附加约束。\n\n**评分规则**\n\n- 在子任务 1 或子任务 2 中，若你的程序解决了所有测试用例，你将获得满分。\n- 在子任务 3 中，若你的程序解决了所有测试用例，你的得分按以下方式计算。令 $ \\text{MaxDiff} $ 为 $ V - N $ 的最大值：\n\n  - 当 $ 101 \\le \\text{MaxDiff} $ 时，你的得分为 $ 0 $。\n  - 当 $ 21 \\le \\text{MaxDiff} \\le 100 $ 时，你的得分为 $ 13 + \\left\\lfloor \\dfrac{100 - \\text{MaxDiff}}{4} \\right\\rfloor $。此处，$ \\lfloor x \\rfloor $ 表示不超过 $ x $ 的最大整数。\n  - 当 $ 13 \\le \\text{MaxDiff} \\le 20 $ 时，你的得分为 $ 33 + (20 - \\text{MaxDiff}) \\times 3 $。\n  - 当 $ \\text{MaxDiff} \\le 12 $ 时，你的得分为 $ 63 $。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN"}}}
{"pid": "P14372", "type": "P", "difficulty": 6, "samples": [["5 6 3\n1 2\n2 4\n3 4\n1 3\n3 5\n4 5\n4 1 1\n5 2 2 3\n2 3 1 4 5", "1\n3\n0"], ["12 17 10\n1 2\n2 3\n3 4\n1 5\n2 6\n3 7\n4 8\n5 6\n6 7\n7 8\n5 9\n6 10\n7 11\n8 12\n9 10\n10 11\n11 12\n6 3 1 7 12\n3 7 1 2 3 4 5 6 7\n11 3 1 3 5\n9 2 1 9\n8 4 1 2 3 4\n1 1 1\n12 0\n10 3 1 6 10\n11 8 2 3 5 6 7 9 10 11\n8 7 2 3 4 5 6 7 8", "1\n-1\n3\n1\n3\n-1\n5\n2\n4\n4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "根号分治", "JOISC/JOIST（日本）"], "title": "[JOISC 2018] 比太郎的聚会 / Bitaro's Party", "background": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/zzhx9edy.png)\n:::", "description": "有 $N$ 个海狸城镇，按高度从高到低编号为 $1$ 至 $N$。任意两个城镇的高度均不相同。有 $M$ 条单向运河连接两个不同的城镇。第 $i$ 条运河（$1 \\le i \\le M$）从城镇 $S_i$ 流向城镇 $E_i$。这些运河均从高处城镇流向低处城镇，你不能逆着水流方向移动。\n\n海狸 Bitaro 有 $N$ 个朋友，每个朋友分别居住在 $N$ 个城镇中的一个。\n\nBitaro 将举办 $Q$ 场派对，每场派对邀请他的朋友们参加。已知第 $j$ 场派对（$1 \\le j \\le Q$）中，有 $Y_j$ 位朋友因太忙而无法出席。第 $j$ 场派对在城镇 $T_j$ 举行，因此那些无法通过运河从自己所在城镇前往 $T_j$ 的朋友也无法参加。其余朋友则会前来参加派对。\n\n每位朋友都会通过运河前往派对所在的城镇。他们可能有多种路径可选。但由于 Bitaro 的朋友们喜爱运河，他们必须选择其中一条经过最多运河的路径。\n\nBitaro 想知道，使用最多运河路径的那位参与者会经过多少条运河。\n\n**任务**\n\n给定每场派对所在的城镇编号以及 $Q$ 场派对中各自忙碌的朋友列表，编写一个程序，计算使用最多运河路径的参与者所经过的运河数量。", "inputFormat": "从标准输入读取以下数据。\n\n- 输入的第一行包含三个以空格分隔的整数 $N$、$M$、$Q$。它们分别表示有 $N$ 个海狸城镇、$M$ 条运河，以及 Bitaro 将举办 $Q$ 场派对。\n- 接下来的 $M$ 行中，第 $i$ 行（$1 \\le i \\le M$）包含两个以空格分隔的整数 $S_i$ 和 $E_i$，表示第 $i$ 条运河从 $S_i$ 单向流向 $E_i$。\n- 接下来的 $Q$ 行中，第 $j$ 行（$1 \\le j \\le Q$）包含两个以空格分隔的整数 $T_j$、$Y_j$，以及 $Y_j$ 个以空格分隔的整数 $C_{j,1}, C_{j,2}, \\ldots, C_{j,Y_j}$。这表示第 $j$ 场派对在城镇 $T_j$ 举行，且居住在城镇 $C_{j,1}, C_{j,2}, \\ldots, C_{j,Y_j}$ 的朋友因忙碌而无法参加。", "outputFormat": "输出包含 $Q$ 行。第 $j$ 行（$1 \\le j \\le Q$）包含第 $j$ 场派对中，使用最多运河路径的参与者所经过的运河数量。若无人能参加第 $j$ 场派对，则第 $j$ 行输出 $-1$。", "hint": "### 样例 1 解释\n\n在参加第一场派对的朋友中（居住在城镇 $2$、$3$ 或 $4$ 的朋友），居住在城镇 $2$ 或 $3$ 的朋友会通过最多数量的运河前往派对所在的城镇 $4$，该数量为 $1$，因此输出 $1$。\n\n在参加第二场派对的朋友中（居住在城镇 $1$、$4$ 或 $5$ 的朋友），居住在城镇 $1$ 的朋友会通过最多数量的运河前往派对所在的城镇 $5$，该数量为 $3$，因此输出 $3$。\n\n居住在城镇 $2$ 的朋友是唯一参加第三场派对的人，他不经过任何运河，因此输出 $0$。\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le N \\le 100\\,000$。\n- $0 \\le M \\le 200\\,000$。\n- $1 \\le Q \\le 100\\,000$。\n- $1 \\le S_i < E_i \\le N$（其中 $1 \\le i \\le M$）。\n- $(S_i, E_i) \\ne (S_j, E_j)$（其中 $1 \\le i < j \\le M$）。\n- $1 \\le T_j \\le N$（其中 $1 \\le j \\le Q$）。\n- $0 \\le Y_j \\le N$（其中 $1 \\le j \\le Q$）。\n- $1 \\le C_{j,1} < C_{j,2} < \\cdots < C_{j,Y_j} \\le N$（其中 $1 \\le j \\le Q$）。\n- $Y_1 + Y_2 + \\cdots + Y_Q \\le 100\\,000$。\n\n### 子任务\n\n共有 3 个子任务。每个子任务的得分及附加约束如下：\n\n**子任务 1 [7 分]**\n\n- $N \\le 1000$。\n- $M \\le 2000$。\n- $Q = 1$。\n\n**子任务 2 [7 分]**\n\n- $Q = 1$。\n\n**子任务 3 [86 分]**\n\n无额外约束。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2018] 比太郎的聚会 / Bitaro's Party", "background": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/zzhx9edy.png)\n:::", "description": "有 $N$ 个海狸城镇，按高度从高到低编号为 $1$ 至 $N$。任意两个城镇的高度均不相同。有 $M$ 条单向运河连接两个不同的城镇。第 $i$ 条运河（$1 \\le i \\le M$）从城镇 $S_i$ 流向城镇 $E_i$。这些运河均从高处城镇流向低处城镇，你不能逆着水流方向移动。\n\n海狸 Bitaro 有 $N$ 个朋友，每个朋友分别居住在 $N$ 个城镇中的一个。\n\nBitaro 将举办 $Q$ 场派对，每场派对邀请他的朋友们参加。已知第 $j$ 场派对（$1 \\le j \\le Q$）中，有 $Y_j$ 位朋友因太忙而无法出席。第 $j$ 场派对在城镇 $T_j$ 举行，因此那些无法通过运河从自己所在城镇前往 $T_j$ 的朋友也无法参加。其余朋友则会前来参加派对。\n\n每位朋友都会通过运河前往派对所在的城镇。他们可能有多种路径可选。但由于 Bitaro 的朋友们喜爱运河，他们必须选择其中一条经过最多运河的路径。\n\nBitaro 想知道，使用最多运河路径的那位参与者会经过多少条运河。\n\n**任务**\n\n给定每场派对所在的城镇编号以及 $Q$ 场派对中各自忙碌的朋友列表，编写一个程序，计算使用最多运河路径的参与者所经过的运河数量。", "inputFormat": "从标准输入读取以下数据。\n\n- 输入的第一行包含三个以空格分隔的整数 $N$、$M$、$Q$。它们分别表示有 $N$ 个海狸城镇、$M$ 条运河，以及 Bitaro 将举办 $Q$ 场派对。\n- 接下来的 $M$ 行中，第 $i$ 行（$1 \\le i \\le M$）包含两个以空格分隔的整数 $S_i$ 和 $E_i$，表示第 $i$ 条运河从 $S_i$ 单向流向 $E_i$。\n- 接下来的 $Q$ 行中，第 $j$ 行（$1 \\le j \\le Q$）包含两个以空格分隔的整数 $T_j$、$Y_j$，以及 $Y_j$ 个以空格分隔的整数 $C_{j,1}, C_{j,2}, \\ldots, C_{j,Y_j}$。这表示第 $j$ 场派对在城镇 $T_j$ 举行，且居住在城镇 $C_{j,1}, C_{j,2}, \\ldots, C_{j,Y_j}$ 的朋友因忙碌而无法参加。", "outputFormat": "输出包含 $Q$ 行。第 $j$ 行（$1 \\le j \\le Q$）包含第 $j$ 场派对中，使用最多运河路径的参与者所经过的运河数量。若无人能参加第 $j$ 场派对，则第 $j$ 行输出 $-1$。", "hint": "### 样例 1 解释\n\n在参加第一场派对的朋友中（居住在城镇 $2$、$3$ 或 $4$ 的朋友），居住在城镇 $2$ 或 $3$ 的朋友会通过最多数量的运河前往派对所在的城镇 $4$，该数量为 $1$，因此输出 $1$。\n\n在参加第二场派对的朋友中（居住在城镇 $1$、$4$ 或 $5$ 的朋友），居住在城镇 $1$ 的朋友会通过最多数量的运河前往派对所在的城镇 $5$，该数量为 $3$，因此输出 $3$。\n\n居住在城镇 $2$ 的朋友是唯一参加第三场派对的人，他不经过任何运河，因此输出 $0$。\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le N \\le 100\\,000$。\n- $0 \\le M \\le 200\\,000$。\n- $1 \\le Q \\le 100\\,000$。\n- $1 \\le S_i < E_i \\le N$（其中 $1 \\le i \\le M$）。\n- $(S_i, E_i) \\ne (S_j, E_j)$（其中 $1 \\le i < j \\le M$）。\n- $1 \\le T_j \\le N$（其中 $1 \\le j \\le Q$）。\n- $0 \\le Y_j \\le N$（其中 $1 \\le j \\le Q$）。\n- $1 \\le C_{j,1} < C_{j,2} < \\cdots < C_{j,Y_j} \\le N$（其中 $1 \\le j \\le Q$）。\n- $Y_1 + Y_2 + \\cdots + Y_Q \\le 100\\,000$。\n\n### 子任务\n\n共有 3 个子任务。每个子任务的得分及附加约束如下：\n\n**子任务 1 [7 分]**\n\n- $N \\le 1000$。\n- $M \\le 2000$。\n- $Q = 1$。\n\n**子任务 2 [7 分]**\n\n- $Q = 1$。\n\n**子任务 3 [86 分]**\n\n无额外约束。", "locale": "zh-CN"}}}
{"pid": "P14373", "type": "P", "difficulty": 7, "samples": [["4\nx))x", "3"], ["10\nxx(xx()x(x", "45"], ["5\nx))x(", "0"], ["10\nxxxxxxxxxx", "684"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864]}, "tags": ["动态规划 DP", "2018", "动态规划优化", "JOISC/JOIST（日本）"], "title": "[JOISC 2018] 安全门 / Security Gate", "background": null, "description": "你听说过 Just Odd Inventions Co., Ltd. 吗？这家公司的业务是做“奇思妙想的发明”。我们姑且称它为 JOI 公司。\n\n为了防止机密信息泄露，JOI 公司的大门安装了一道安全门。任何人进出公司都必须通过这道门，且同一时间不可能有两人或以上同时通过。\n\n每当有人通过这道门时，系统会记录此人是进入还是离开公司。现在，JOI 公司的员工 IOI-kun 保留了某一天的门禁记录。该记录由字符串 $S$ 表示：若 $S$ 的第 $i$ 个字符为 ‘(’，则表示第 $i$ 个通过门的人是进入公司；若为 ‘)’，则表示第 $i$ 个通过门的人是离开公司。IOI-kun 知道，在这一天开始和结束时，公司内均无人。请注意，存在一些仅由 ‘(’ 和 ‘)’ 组成的字符串无法表示合法记录：例如，记录不能是 ‘)(’ 或 ‘((’，因为前者意味着公司内人数曾为负数，后者意味着在当天结束时公司内仍有人员。\n\n下一刻，IOI-kun 检查记录时，发现字符串 $S$ 已被传播至 JOI 公司的计算机病毒修改！经过调查，他推测修改过程如下：\n\n- 首先，$S$ 中的某一段连续子串被修改：对于该子串中的每个字符，若原字符为 ‘(’，则变为 ‘)’；若原字符为 ‘)’，则变为 ‘(’。我们将修改后的字符串记为 $S'$。被修改的子串长度可能为 0，即 $S = S'$。\n- 接着，$S'$ 中的 0 个或更多字符变为 ‘x’。我们将此次修改后的字符串记为 $S''$。\n\nIOI-kun 已不记得原始字符串 $S$，因此他试图从 $S''$ 恢复 $S$。为此，他首先希望统计所有可能成为 $S'$（注意不是 $S$，请小心）的字符串的数量。\n\n**任务**\n\n给定字符串 $S''$，编写一个程序，计算所有可能成为 $S'$ 的字符串的数量，结果对 $1\\,000\\,000\\,007$ 取模。", "inputFormat": "从标准输入读取以下数据：\n\n- 输入的第一行包含一个整数 $N$。这表示修改后的字符串 $S''$ 的长度为 $N$。\n- 输入的第二行包含一个字符串 $S''$，其中每个字符为 ‘(’、‘)’ 或 ‘x’。这表示修改后的字符串是 $S''$。", "outputFormat": "向标准输出写入一行。输出应包含所有可能成为 $S'$ 的字符串的数量，结果对 $1\\,000\\,000\\,007$ 取模。若不存在这样的字符串，输出 $0$。", "hint": "### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le N \\le 300$。\n\n### 子任务\n\n共有 5 个子任务。每个子任务的得分及附加约束如下：\n\n**子任务 1 [4 分]**\n\n- $N \\le 100$。\n- $S''$ 中 ‘x’ 的数量至多为 4。\n\n**子任务 2 [8 分]**\n\n- $N \\le 100$。\n- $S''$ 中 ‘x’ 的数量至多为 12。\n\n**子任务 3 [18 分]**\n\n- $N \\le 100$。\n- $S''$ 中 ‘x’ 的数量至多为 20。\n\n**子任务 4 [43 分]**\n\n- $N \\le 100$。\n\n**子任务 5 [27 分]**\n\n无额外约束。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2018] 安全门 / Security Gate", "background": null, "description": "你听说过 Just Odd Inventions Co., Ltd. 吗？这家公司的业务是做“奇思妙想的发明”。我们姑且称它为 JOI 公司。\n\n为了防止机密信息泄露，JOI 公司的大门安装了一道安全门。任何人进出公司都必须通过这道门，且同一时间不可能有两人或以上同时通过。\n\n每当有人通过这道门时，系统会记录此人是进入还是离开公司。现在，JOI 公司的员工 IOI-kun 保留了某一天的门禁记录。该记录由字符串 $S$ 表示：若 $S$ 的第 $i$ 个字符为 ‘(’，则表示第 $i$ 个通过门的人是进入公司；若为 ‘)’，则表示第 $i$ 个通过门的人是离开公司。IOI-kun 知道，在这一天开始和结束时，公司内均无人。请注意，存在一些仅由 ‘(’ 和 ‘)’ 组成的字符串无法表示合法记录：例如，记录不能是 ‘)(’ 或 ‘((’，因为前者意味着公司内人数曾为负数，后者意味着在当天结束时公司内仍有人员。\n\n下一刻，IOI-kun 检查记录时，发现字符串 $S$ 已被传播至 JOI 公司的计算机病毒修改！经过调查，他推测修改过程如下：\n\n- 首先，$S$ 中的某一段连续子串被修改：对于该子串中的每个字符，若原字符为 ‘(’，则变为 ‘)’；若原字符为 ‘)’，则变为 ‘(’。我们将修改后的字符串记为 $S'$。被修改的子串长度可能为 0，即 $S = S'$。\n- 接着，$S'$ 中的 0 个或更多字符变为 ‘x’。我们将此次修改后的字符串记为 $S''$。\n\nIOI-kun 已不记得原始字符串 $S$，因此他试图从 $S''$ 恢复 $S$。为此，他首先希望统计所有可能成为 $S'$（注意不是 $S$，请小心）的字符串的数量。\n\n**任务**\n\n给定字符串 $S''$，编写一个程序，计算所有可能成为 $S'$ 的字符串的数量，结果对 $1\\,000\\,000\\,007$ 取模。", "inputFormat": "从标准输入读取以下数据：\n\n- 输入的第一行包含一个整数 $N$。这表示修改后的字符串 $S''$ 的长度为 $N$。\n- 输入的第二行包含一个字符串 $S''$，其中每个字符为 ‘(’、‘)’ 或 ‘x’。这表示修改后的字符串是 $S''$。", "outputFormat": "向标准输出写入一行。输出应包含所有可能成为 $S'$ 的字符串的数量，结果对 $1\\,000\\,000\\,007$ 取模。若不存在这样的字符串，输出 $0$。", "hint": "### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le N \\le 300$。\n\n### 子任务\n\n共有 5 个子任务。每个子任务的得分及附加约束如下：\n\n**子任务 1 [4 分]**\n\n- $N \\le 100$。\n- $S''$ 中 ‘x’ 的数量至多为 4。\n\n**子任务 2 [8 分]**\n\n- $N \\le 100$。\n- $S''$ 中 ‘x’ 的数量至多为 12。\n\n**子任务 3 [18 分]**\n\n- $N \\le 100$。\n- $S''$ 中 ‘x’ 的数量至多为 20。\n\n**子任务 4 [43 分]**\n\n- $N \\le 100$。\n\n**子任务 5 [27 分]**\n\n无额外约束。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN"}}}
{"pid": "P14374", "type": "P", "difficulty": 5, "samples": [["5\n3\n5\n1\n7\n6", "7\n12\n10"], ["20\n623239331\n125587558\n908010226\n866053126\n389255266\n859393857\n596640443\n60521559\n11284043\n930138174\n936349374\n810093502\n521142682\n918991183\n743833745\n739411636\n276010057\n577098544\n551216812\n816623724", "936349374\n1855340557\n2763350783\n3622744640\n4439368364\n5243250666\n5982662302\n6605901633\n7183000177\n7309502029"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2018", "JOISC/JOIST（日本）", "反悔贪心"], "title": "[JOISC 2018] 糖果 / Candies", "background": "", "description": "桌上有 $N$ 颗糖果排成一排。每颗糖果都有一个称为 **美味值** 的值。从左数第 $i$ 颗糖果的美味值为 $A_i$（$1 \\le i \\le N$）。\n\nJOI-chan 决定吃掉其中一部分糖果。她希望最大化所吃糖果的美味值总和。\n\n然而，JOI-chan 认为仅贪心地选择糖果并不有趣，因此她制定了一条规则：她不能同时选择两颗相邻的糖果。\n\nJOI-chan 尚未决定要吃多少颗糖果，因此她想知道，对于每个 $j$（$1 \\le j \\le \\lceil \\frac{N}{2} \\rceil$），当她吃掉 $j$ 颗糖果时，所能获得的最大美味值总和是多少。这里 $\\lceil x \\rceil$ 表示不小于 $x$ 的最小整数。\n\n**任务**\n\n给定糖果数量和每颗糖果的美味值，编写一个程序，计算对于每个 $j$（$1 \\le j \\le \\lceil \\frac{N}{2} \\rceil$），当她吃掉 $j$ 颗糖果时，所能获得的最大美味值总和。\n", "inputFormat": "从标准输入读取以下数据：\n\n- 输入第一行包含一个整数 $N$。这表示桌上有 $N$ 颗糖果。\n- 接下来的 $N$ 行中，第 $i$ 行（$1 \\le i \\le N$）包含一个整数 $A_i$。这表示从左数第 $i$ 颗糖果的美味值为 $A_i$。\n", "outputFormat": "向标准输出写入 $\\lceil \\frac{N}{2} \\rceil$ 行。第 $j$ 行（$1 \\le j \\le \\lceil \\frac{N}{2} \\rceil$）输出当她吃掉 $j$ 颗糖果时所能获得的最大美味值总和。\n", "hint": "### 样例 1 解释\n\n在样例输入 1 中，共有 5 颗糖果，从左至右的美味值分别为 3、5、1、7、6。JOI-chan 应按如下方式吃糖果：\n\n- 当她吃 1 颗糖果时，她吃从左数第 4 颗糖果（美味值为 7）。\n- 当她吃 2 颗糖果时，她吃从左数第 2 颗和第 4 颗糖果（美味值为 5、7）。\n- 当她吃 3 颗糖果时，她吃从左数第 1 颗、第 3 颗和第 5 颗糖果（美味值为 3、1、6）。\n\n再次强调，她不能同时选择两颗相邻的糖果。例如，请记住当她吃 2 颗糖果时，她不能同时吃从左数第 4 颗和第 5 颗糖果（美味值为 7、6）。\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le N \\le 200\\,000$。\n- $1 \\le A_i \\le 1\\,000\\,000\\,000$（$1 \\le i \\le N$）。\n\n### 子任务\n\n共有 2 个子任务。每个子任务的得分及附加约束如下：\n\n**子任务 1 [8 分]**\n\n- $N \\le 2\\,000$。\n\n**子任务 2 [92 分]**\n\n无额外约束。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2018] 糖果 / Candies", "background": "", "description": "桌上有 $N$ 颗糖果排成一排。每颗糖果都有一个称为 **美味值** 的值。从左数第 $i$ 颗糖果的美味值为 $A_i$（$1 \\le i \\le N$）。\n\nJOI-chan 决定吃掉其中一部分糖果。她希望最大化所吃糖果的美味值总和。\n\n然而，JOI-chan 认为仅贪心地选择糖果并不有趣，因此她制定了一条规则：她不能同时选择两颗相邻的糖果。\n\nJOI-chan 尚未决定要吃多少颗糖果，因此她想知道，对于每个 $j$（$1 \\le j \\le \\lceil \\frac{N}{2} \\rceil$），当她吃掉 $j$ 颗糖果时，所能获得的最大美味值总和是多少。这里 $\\lceil x \\rceil$ 表示不小于 $x$ 的最小整数。\n\n**任务**\n\n给定糖果数量和每颗糖果的美味值，编写一个程序，计算对于每个 $j$（$1 \\le j \\le \\lceil \\frac{N}{2} \\rceil$），当她吃掉 $j$ 颗糖果时，所能获得的最大美味值总和。\n", "inputFormat": "从标准输入读取以下数据：\n\n- 输入第一行包含一个整数 $N$。这表示桌上有 $N$ 颗糖果。\n- 接下来的 $N$ 行中，第 $i$ 行（$1 \\le i \\le N$）包含一个整数 $A_i$。这表示从左数第 $i$ 颗糖果的美味值为 $A_i$。\n", "outputFormat": "向标准输出写入 $\\lceil \\frac{N}{2} \\rceil$ 行。第 $j$ 行（$1 \\le j \\le \\lceil \\frac{N}{2} \\rceil$）输出当她吃掉 $j$ 颗糖果时所能获得的最大美味值总和。\n", "hint": "### 样例 1 解释\n\n在样例输入 1 中，共有 5 颗糖果，从左至右的美味值分别为 3、5、1、7、6。JOI-chan 应按如下方式吃糖果：\n\n- 当她吃 1 颗糖果时，她吃从左数第 4 颗糖果（美味值为 7）。\n- 当她吃 2 颗糖果时，她吃从左数第 2 颗和第 4 颗糖果（美味值为 5、7）。\n- 当她吃 3 颗糖果时，她吃从左数第 1 颗、第 3 颗和第 5 颗糖果（美味值为 3、1、6）。\n\n再次强调，她不能同时选择两颗相邻的糖果。例如，请记住当她吃 2 颗糖果时，她不能同时吃从左数第 4 颗和第 5 颗糖果（美味值为 7、6）。\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $1 \\le N \\le 200\\,000$。\n- $1 \\le A_i \\le 1\\,000\\,000\\,000$（$1 \\le i \\le N$）。\n\n### 子任务\n\n共有 2 个子任务。每个子任务的得分及附加约束如下：\n\n**子任务 1 [8 分]**\n\n- $N \\le 2\\,000$。\n\n**子任务 2 [92 分]**\n\n无额外约束。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN"}}}
{"pid": "P14375", "type": "P", "difficulty": 5, "samples": [["5\n4\n2\n5\n3\n1", ""]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "二分", "交互题", "Special Judge", "分治", "随机化", "JOISC/JOIST（日本）"], "title": "[JOISC 2018] 图书馆 / Library", "background": "", "description": "数百年后，JOI 城市已成废墟。探险家 IOI-chan 正在探索曾经建造图书馆的区域。根据勘探结果，已知以下信息：\n\n- 图书馆的书架上共有 $N$ 本书。这些书从左到右排成一列。\n- 这 $N$ 本书编号为 $1$ 至 $N$。但书架上书籍的排列顺序可能与书的编号顺序不同。\n- 通过一次操作，可以一次性取走书架上连续放置的若干本书。\n\n不幸的是，IOI-chan 未能在图书馆中找到旧书。但她发现了一台管理图书馆书架操作的机器。如果我们指定一个或多个书的编号并向机器发送查询，机器会返回仅取走这些书所需的最少操作次数。\n\nIOI-chan 希望通过向机器发送查询来确定书架上书籍的排列顺序。然而，由于无论书籍顺序是正序还是倒序，机器返回的答案都相同，她无需指定书籍是从左到右还是从右到左排列。\n\n由于机器年代久远，她最多只能向机器发送 20000 次查询。\n\n**任务**\n\n编写一个程序，通过向机器发送最多 20000 次查询，确定书架上书籍的排列顺序。无需指定书籍是从左到右还是从右到左排列。\n\n### 实现细节\n\n你需要实现以下函数。程序应包含函数定义 `int Query(const std::vector<int>& M);` 和 `void Answer(const std::vector<int>& res);`。程序不应当引入外部头文件。请使用不低于 C++17 的语言版本提交代码。\n\n- `void Solve(int N)`\n\n  对于每个测试用例，该函数将被调用一次。\n\n  - 参数 $N$ 表示书架上书籍的数量 $N$。\n\n你的程序可以调用以下函数。\n\n- `int Query(const std::vector<int>& M)`\n\n  - 如果指定了一个或多个书的编号，该函数返回仅取走这些书所需的最少操作次数。\n\n  - 从书架上取走的书籍由参数 $M$ 指定，$M$ 是一个大小为 $N$ 的向量。对于每个 $i$（$1 \\le i \\le N$），若 $M[i-1] = 0$，则表示不取走第 $i$ 本书；若 $M[i-1] = 1$，则表示取走第 $i$ 本书。若 $M$ 的大小与 $N$ 不同，你的程序将被视为 **Wrong Answer [1]**。对于每个 $i$，$M[i-1]$ 的值应为 0 或 1。至少应存在一个 $i$（$1 \\le i \\le N$）满足 $M[i-1] = 1$。若以上两个条件中至少有一个未满足，你的程序将被视为 **Wrong Answer [2]**。若函数 `Query` 被调用超过 20000 次，你的程序将被视为 **Wrong Answer [3]**。\n\n- `void Answer(const std::vector<int>& res)`\n\n  - 使用此函数，你的程序应输出书架上书籍的排列顺序。无需指定书籍是从左到右还是从右到左排列。\n  - 参数 $res$ 是一个大小为 $N$ 的向量，用于描述书架上书籍的排列顺序。对于每个 $i$（$1 \\le i \\le N$），从左数第 $i$ 本书的编号为 $res[i-1]$。若 $res$ 的大小与 $N$ 不同，你的程序将被视为 **Wrong Answer [4]**。$res[i-1]$ 应为介于 1 和 $N$ 之间的整数（含端点）。若此条件未满足，你的程序将被视为 **Wrong Answer [5]**。此外，整数 $res[0], res[1], \\dots, res[N-1]$ 应互不相同。若此条件未满足，你的程序将被视为 **Wrong Answer [6]**。\n\n当函数 `Solve` 结束时，若调用函数 `Answer` 的次数不等于 1，你的程序将被视为 **Wrong Answer [7]**。\n\n若函数 `Solve` 所指定的书籍顺序与书架上实际的书籍顺序不同，你的程序将被视为 **Wrong Answer [8]**。无需指定书籍是从左到右还是从右到左排列。\n\n**重要提示**\n\n- 你的程序可以为内部使用实现其他函数，或使用全局变量。\n- 你的程序不应使用标准输入和标准输出。你的程序不应以任何方式与其他文件通信。但你的程序可以向标准错误输出调试信息。\n\n", "inputFormat": "从标准输入读取以下数据：\n\n- 第一行包含整数 $N$，表示书架上书籍的数量。\n- 接下来的 $N$ 行中，第 $i$ 行（$1 \\le i \\le N$）包含整数 $A_i$。这表示从左数第 $i$ 本书的编号为 $A_i$。\n", "outputFormat": "当程序成功终止时，样例评测器将以下信息写入标准输出。（引号实际不会输出。）\n\n- 若你的程序被视为正确，样例评测器将以如下格式输出调用函数 `Query` 的次数：“Accepted : 100.”\n- 若你的程序被视为 **Wrong Answer**，样例评测器将以如下格式输出其类型：“Wrong Answer [1].”\n\n若你的程序被视为多种类型的 **Wrong Answer**，样例评测器仅报告其中一种。", "hint": "### 样例 1 解释\n\n调用 `Query({1,1,1,0,0})` 得到 $2$。再调用 `Answer({4,2,5,3,1})`。\n\n在本题中，无需指定书籍是从左到右还是从右到左排列。因此，若你的程序调用 `Answer({1,3,5,2,4})`，且其参数顺序为逆序，仍被视为正确。\n\n### 数据范围\n\n所有输入数据满足以下条件。关于 $N$ 和 $A_i$ 的含义，请参见“样例评测器的输入”。\n\n- $1 \\le N \\le 1000$。\n- $1 \\le A_i \\le N$（$1 \\le i \\le N$）。\n- $A_i \\ne A_j$（$1 \\le i < j \\le N$）。\n\n### 子任务\n\n共有 2 个子任务。每个子任务的得分及额外约束如下：\n\n**子任务 1（19 分）**\n\n- $N \\le 200$。\n\n**子任务 2（81 分）**\n\n无额外约束。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2018] 图书馆 / Library", "background": "", "description": "数百年后，JOI 城市已成废墟。探险家 IOI-chan 正在探索曾经建造图书馆的区域。根据勘探结果，已知以下信息：\n\n- 图书馆的书架上共有 $N$ 本书。这些书从左到右排成一列。\n- 这 $N$ 本书编号为 $1$ 至 $N$。但书架上书籍的排列顺序可能与书的编号顺序不同。\n- 通过一次操作，可以一次性取走书架上连续放置的若干本书。\n\n不幸的是，IOI-chan 未能在图书馆中找到旧书。但她发现了一台管理图书馆书架操作的机器。如果我们指定一个或多个书的编号并向机器发送查询，机器会返回仅取走这些书所需的最少操作次数。\n\nIOI-chan 希望通过向机器发送查询来确定书架上书籍的排列顺序。然而，由于无论书籍顺序是正序还是倒序，机器返回的答案都相同，她无需指定书籍是从左到右还是从右到左排列。\n\n由于机器年代久远，她最多只能向机器发送 20000 次查询。\n\n**任务**\n\n编写一个程序，通过向机器发送最多 20000 次查询，确定书架上书籍的排列顺序。无需指定书籍是从左到右还是从右到左排列。\n\n### 实现细节\n\n你需要实现以下函数。程序应包含函数定义 `int Query(const std::vector<int>& M);` 和 `void Answer(const std::vector<int>& res);`。程序不应当引入外部头文件。请使用不低于 C++17 的语言版本提交代码。\n\n- `void Solve(int N)`\n\n  对于每个测试用例，该函数将被调用一次。\n\n  - 参数 $N$ 表示书架上书籍的数量 $N$。\n\n你的程序可以调用以下函数。\n\n- `int Query(const std::vector<int>& M)`\n\n  - 如果指定了一个或多个书的编号，该函数返回仅取走这些书所需的最少操作次数。\n\n  - 从书架上取走的书籍由参数 $M$ 指定，$M$ 是一个大小为 $N$ 的向量。对于每个 $i$（$1 \\le i \\le N$），若 $M[i-1] = 0$，则表示不取走第 $i$ 本书；若 $M[i-1] = 1$，则表示取走第 $i$ 本书。若 $M$ 的大小与 $N$ 不同，你的程序将被视为 **Wrong Answer [1]**。对于每个 $i$，$M[i-1]$ 的值应为 0 或 1。至少应存在一个 $i$（$1 \\le i \\le N$）满足 $M[i-1] = 1$。若以上两个条件中至少有一个未满足，你的程序将被视为 **Wrong Answer [2]**。若函数 `Query` 被调用超过 20000 次，你的程序将被视为 **Wrong Answer [3]**。\n\n- `void Answer(const std::vector<int>& res)`\n\n  - 使用此函数，你的程序应输出书架上书籍的排列顺序。无需指定书籍是从左到右还是从右到左排列。\n  - 参数 $res$ 是一个大小为 $N$ 的向量，用于描述书架上书籍的排列顺序。对于每个 $i$（$1 \\le i \\le N$），从左数第 $i$ 本书的编号为 $res[i-1]$。若 $res$ 的大小与 $N$ 不同，你的程序将被视为 **Wrong Answer [4]**。$res[i-1]$ 应为介于 1 和 $N$ 之间的整数（含端点）。若此条件未满足，你的程序将被视为 **Wrong Answer [5]**。此外，整数 $res[0], res[1], \\dots, res[N-1]$ 应互不相同。若此条件未满足，你的程序将被视为 **Wrong Answer [6]**。\n\n当函数 `Solve` 结束时，若调用函数 `Answer` 的次数不等于 1，你的程序将被视为 **Wrong Answer [7]**。\n\n若函数 `Solve` 所指定的书籍顺序与书架上实际的书籍顺序不同，你的程序将被视为 **Wrong Answer [8]**。无需指定书籍是从左到右还是从右到左排列。\n\n**重要提示**\n\n- 你的程序可以为内部使用实现其他函数，或使用全局变量。\n- 你的程序不应使用标准输入和标准输出。你的程序不应以任何方式与其他文件通信。但你的程序可以向标准错误输出调试信息。\n\n", "inputFormat": "从标准输入读取以下数据：\n\n- 第一行包含整数 $N$，表示书架上书籍的数量。\n- 接下来的 $N$ 行中，第 $i$ 行（$1 \\le i \\le N$）包含整数 $A_i$。这表示从左数第 $i$ 本书的编号为 $A_i$。\n", "outputFormat": "当程序成功终止时，样例评测器将以下信息写入标准输出。（引号实际不会输出。）\n\n- 若你的程序被视为正确，样例评测器将以如下格式输出调用函数 `Query` 的次数：“Accepted : 100.”\n- 若你的程序被视为 **Wrong Answer**，样例评测器将以如下格式输出其类型：“Wrong Answer [1].”\n\n若你的程序被视为多种类型的 **Wrong Answer**，样例评测器仅报告其中一种。", "hint": "### 样例 1 解释\n\n调用 `Query({1,1,1,0,0})` 得到 $2$。再调用 `Answer({4,2,5,3,1})`。\n\n在本题中，无需指定书籍是从左到右还是从右到左排列。因此，若你的程序调用 `Answer({1,3,5,2,4})`，且其参数顺序为逆序，仍被视为正确。\n\n### 数据范围\n\n所有输入数据满足以下条件。关于 $N$ 和 $A_i$ 的含义，请参见“样例评测器的输入”。\n\n- $1 \\le N \\le 1000$。\n- $1 \\le A_i \\le N$（$1 \\le i \\le N$）。\n- $A_i \\ne A_j$（$1 \\le i < j \\le N$）。\n\n### 子任务\n\n共有 2 个子任务。每个子任务的得分及额外约束如下：\n\n**子任务 1（19 分）**\n\n- $N \\le 200$。\n\n**子任务 2（81 分）**\n\n无额外约束。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN"}}}
{"pid": "P14376", "type": "P", "difficulty": 7, "samples": [["3 3 1 3\n1 2 1\n2 3 1\n1 3 1\n1\n2\n3\n3 1", "3"], ["4 4 4 3\n1 2 1\n2 3 1\n1 3 1\n1 4 1\n4\n1\n3\n3 4\n1 2\n3 2\n2 4", "5\n2\n3\n-1"], ["5 6 1 5\n1 2 8\n1 3 8\n1 4 8\n2 5 2\n3 4 6\n4 5 6\n2\n5\n1\n5\n3\n5 2", "38"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "线段树", "最短路", "JOISC/JOIST（日本）"], "title": "[JOISC 2018] 野猪 / Wild Boar", "background": "", "description": "JOI-kun 是一只生活在 IOI 森林中的野猪，森林中有 $N$ 个补给站和 $M$ 条道路。补给站编号为 $1$ 至 $N$。第 $i$ 条道路（$1 \\le i \\le M$）双向连接补给站 $A_i$ 和 $B_i$，JOI-kun 沿该道路往返任一方向均需耗时 $C_i$ 小时。从任意补给站出发，均可经由一条或多条道路抵达其他任意补给站。\n\nJOI-kun 不擅长掉头。他不能在道路中途掉头返回刚离开的补给站。此外，当他通过某条道路抵达一个补给站后，不能沿原路立即返回上一个补给站。\n\n每天，JOI-kun 根据 **补给计划** 在补给站供应食物。每日的补给计划由一个长度为 $L$ 的补给站序列 $X_1, X_2, \\ldots, X_L$ 组成。他从补给站 $X_1$ 开始供应，按顺序访问各补给站，最终在补给站 $X_L$ 结束供应。途中允许经过其他补给站。他可能多次在同一个补给站供应食物，但需满足对每个 $j$（$1 \\le j \\le L - 1$），有 $X_j \\ne X_{j+1}$。请注意，可能存在他无法执行的补给计划。\n\n初始时，JOI-kun 制定初始补给计划 $X_1, X_2, \\ldots, X_L$。在第 $k$ 天早晨（$1 \\le k \\le T$），他会将计划中第 $P_k$ 个值修改为 $Q_k$（即 $X_{P_k}$ 变为 $Q_k$），然后按新计划供应食物。修改后，对每个 $j$（$1 \\le j \\le L - 1$），仍满足 $X_j \\ne X_{j+1}$。\n\n对于 $T$ 天内每一天的补给计划，JOI-kun 希望判断他是否能够执行该计划；若可以执行，则求出按该计划供应食物所需的最短时间。\n\n**任务**\n\n给定 IOI 森林的数据和 JOI-kun 的补给计划，对于 $T$ 天内每一天的补给计划，编写一个程序，判断他是否能够执行该计划；若可以执行，则求出按该计划供应食物所需的最短时间。", "inputFormat": "从标准输入读取以下数据：\n\n- 输入第一行包含四个以空格分隔的整数 $N$、$M$、$T$ 和 $L$。这表示 IOI 森林中有 $N$ 个补给站和 $M$ 条道路，JOI-kun 考虑 $T$ 天的补给计划，且补给计划由长度为 $L$ 的序列构成。\n- 接下来的 $M$ 行中，第 $i$ 行（$1 \\le i \\le M$）包含三个以空格分隔的整数 $A_i$、$B_i$ 和 $C_i$。这表示第 $i$ 条道路双向连接补给站 $A_i$ 和 $B_i$，JOI-kun 沿该道路往返任一方向均需耗时 $C_i$ 小时。\n- 接下来的 $L$ 行中，第 $j$ 行（$1 \\le j \\le L$）包含一个整数 $X_j$。这表示初始补给计划为 $X_1, X_2, \\ldots, X_L$。\n- 接下来的 $T$ 行中，第 $k$ 行（$1 \\le k \\le T$）包含两个以空格分隔的整数 $P_k$ 和 $Q_k$。这表示 JOI-kun 将在第 $k$ 天早晨把补给计划中的第 $P_k$ 个值修改为 $Q_k$。", "outputFormat": "向标准输出写入 $T$ 行。第 $k$ 行（$1 \\le k \\le T$）应包含 $-1$，若他在第 $k$ 天无法执行补给计划；否则，输出他能够执行该计划所需的最短时间（单位：小时）。\n", "hint": "### 样例 1 解释\n\n在样例输入 1 中，初始补给计划为 1、2、3。JOI-kun 在第 1 天早晨将该补给计划的第 3 个值修改为 1。因此，第 1 天的补给计划为 1、2、1。\n\n首先，JOI-kun 在补给站 1 供应食物。接着，他使用第 1 条道路从补给站 1 前往补给站 2，并在补给站 2 供应食物。然后，他使用第 2 条道路从补给站 2 前往补给站 3。最后，他使用第 3 条道路从补给站 3 前往补给站 1，并在补给站 1 供应食物。如此执行补给计划共需 3 小时。由于这是可能的最短时间，输出 3。\n\n请注意，JOI-kun 不能按 1 → 2 → 1 的路径移动，因为他不能掉头。\n\n### 样例 2 解释\n\n在样例输入 2 中，第 1 天的补给计划为 4、1、4。首先，JOI-kun 在补给站 4 供应食物。接着，他使用第 4 条道路从补给站 4 前往补给站 1，并在补给站 1 供应食物。然后，他按顺序使用第 1、2、3、4 条道路，依次经过补给站 1 → 2 → 3 → 1 → 4，并在补给站 4 供应食物。此路径耗时最短。\n\n第 4 天的补给计划为 2、4、2。由于 JOI-kun 无法执行该计划，输出 -1。\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $2 \\le N \\le 2\\,000$。\n- $N - 1 \\le M \\le 2\\,000$。\n- $1 \\le T \\le 100\\,000$。\n- $2 \\le L \\le 100\\,000$。\n- $1 \\le A_i < B_i \\le N$（$1 \\le i \\le M$）。\n- $(A_i, B_i) \\ne (A_j, B_j)$（$1 \\le i < j \\le M$）。\n- 从任意补给站出发，均可经由一条或多条道路抵达其他任意补给站。\n- $1 \\le C_i \\le 1\\,000\\,000\\,000$（$1 \\le i \\le M$）。\n- $1 \\le X_j \\le N$（$1 \\le j \\le L$）。\n- $1 \\le P_k \\le L$（$1 \\le k \\le T$）。\n- $1 \\le Q_k \\le N$（$1 \\le k \\le T$）。\n- 对每个 $j$（$1 \\le j \\le L - 1$），有 $X_j \\ne X_{j+1}$。此外，在每次修改补给计划后，对每个 $j$（$1 \\le j \\le L - 1$），仍满足 $X_j \\ne X_{j+1}$。\n\n### 子任务\n\n共有 4 个子任务。每个子任务的得分及附加约束如下：\n\n**子任务 1 [12 分]**\n\n- $N \\le 10$。\n- $M \\le 10$。\n- $T = 1$。\n- $L \\le 10$。\n- $C_i \\le 10$（$1 \\le i \\le M$）。\n\n**子任务 2 [35 分]**\n\n- $N \\le 500$。\n- $M \\le 500$。\n- $T = 1$。\n\n**子任务 3 [15 分]**\n\n- $T = 1$。\n\n**子任务 4 [38 分]**\n\n无额外约束。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2018] 野猪 / Wild Boar", "background": "", "description": "JOI-kun 是一只生活在 IOI 森林中的野猪，森林中有 $N$ 个补给站和 $M$ 条道路。补给站编号为 $1$ 至 $N$。第 $i$ 条道路（$1 \\le i \\le M$）双向连接补给站 $A_i$ 和 $B_i$，JOI-kun 沿该道路往返任一方向均需耗时 $C_i$ 小时。从任意补给站出发，均可经由一条或多条道路抵达其他任意补给站。\n\nJOI-kun 不擅长掉头。他不能在道路中途掉头返回刚离开的补给站。此外，当他通过某条道路抵达一个补给站后，不能沿原路立即返回上一个补给站。\n\n每天，JOI-kun 根据 **补给计划** 在补给站供应食物。每日的补给计划由一个长度为 $L$ 的补给站序列 $X_1, X_2, \\ldots, X_L$ 组成。他从补给站 $X_1$ 开始供应，按顺序访问各补给站，最终在补给站 $X_L$ 结束供应。途中允许经过其他补给站。他可能多次在同一个补给站供应食物，但需满足对每个 $j$（$1 \\le j \\le L - 1$），有 $X_j \\ne X_{j+1}$。请注意，可能存在他无法执行的补给计划。\n\n初始时，JOI-kun 制定初始补给计划 $X_1, X_2, \\ldots, X_L$。在第 $k$ 天早晨（$1 \\le k \\le T$），他会将计划中第 $P_k$ 个值修改为 $Q_k$（即 $X_{P_k}$ 变为 $Q_k$），然后按新计划供应食物。修改后，对每个 $j$（$1 \\le j \\le L - 1$），仍满足 $X_j \\ne X_{j+1}$。\n\n对于 $T$ 天内每一天的补给计划，JOI-kun 希望判断他是否能够执行该计划；若可以执行，则求出按该计划供应食物所需的最短时间。\n\n**任务**\n\n给定 IOI 森林的数据和 JOI-kun 的补给计划，对于 $T$ 天内每一天的补给计划，编写一个程序，判断他是否能够执行该计划；若可以执行，则求出按该计划供应食物所需的最短时间。", "inputFormat": "从标准输入读取以下数据：\n\n- 输入第一行包含四个以空格分隔的整数 $N$、$M$、$T$ 和 $L$。这表示 IOI 森林中有 $N$ 个补给站和 $M$ 条道路，JOI-kun 考虑 $T$ 天的补给计划，且补给计划由长度为 $L$ 的序列构成。\n- 接下来的 $M$ 行中，第 $i$ 行（$1 \\le i \\le M$）包含三个以空格分隔的整数 $A_i$、$B_i$ 和 $C_i$。这表示第 $i$ 条道路双向连接补给站 $A_i$ 和 $B_i$，JOI-kun 沿该道路往返任一方向均需耗时 $C_i$ 小时。\n- 接下来的 $L$ 行中，第 $j$ 行（$1 \\le j \\le L$）包含一个整数 $X_j$。这表示初始补给计划为 $X_1, X_2, \\ldots, X_L$。\n- 接下来的 $T$ 行中，第 $k$ 行（$1 \\le k \\le T$）包含两个以空格分隔的整数 $P_k$ 和 $Q_k$。这表示 JOI-kun 将在第 $k$ 天早晨把补给计划中的第 $P_k$ 个值修改为 $Q_k$。", "outputFormat": "向标准输出写入 $T$ 行。第 $k$ 行（$1 \\le k \\le T$）应包含 $-1$，若他在第 $k$ 天无法执行补给计划；否则，输出他能够执行该计划所需的最短时间（单位：小时）。\n", "hint": "### 样例 1 解释\n\n在样例输入 1 中，初始补给计划为 1、2、3。JOI-kun 在第 1 天早晨将该补给计划的第 3 个值修改为 1。因此，第 1 天的补给计划为 1、2、1。\n\n首先，JOI-kun 在补给站 1 供应食物。接着，他使用第 1 条道路从补给站 1 前往补给站 2，并在补给站 2 供应食物。然后，他使用第 2 条道路从补给站 2 前往补给站 3。最后，他使用第 3 条道路从补给站 3 前往补给站 1，并在补给站 1 供应食物。如此执行补给计划共需 3 小时。由于这是可能的最短时间，输出 3。\n\n请注意，JOI-kun 不能按 1 → 2 → 1 的路径移动，因为他不能掉头。\n\n### 样例 2 解释\n\n在样例输入 2 中，第 1 天的补给计划为 4、1、4。首先，JOI-kun 在补给站 4 供应食物。接着，他使用第 4 条道路从补给站 4 前往补给站 1，并在补给站 1 供应食物。然后，他按顺序使用第 1、2、3、4 条道路，依次经过补给站 1 → 2 → 3 → 1 → 4，并在补给站 4 供应食物。此路径耗时最短。\n\n第 4 天的补给计划为 2、4、2。由于 JOI-kun 无法执行该计划，输出 -1。\n\n### 数据范围\n\n所有输入数据满足以下条件：\n\n- $2 \\le N \\le 2\\,000$。\n- $N - 1 \\le M \\le 2\\,000$。\n- $1 \\le T \\le 100\\,000$。\n- $2 \\le L \\le 100\\,000$。\n- $1 \\le A_i < B_i \\le N$（$1 \\le i \\le M$）。\n- $(A_i, B_i) \\ne (A_j, B_j)$（$1 \\le i < j \\le M$）。\n- 从任意补给站出发，均可经由一条或多条道路抵达其他任意补给站。\n- $1 \\le C_i \\le 1\\,000\\,000\\,000$（$1 \\le i \\le M$）。\n- $1 \\le X_j \\le N$（$1 \\le j \\le L$）。\n- $1 \\le P_k \\le L$（$1 \\le k \\le T$）。\n- $1 \\le Q_k \\le N$（$1 \\le k \\le T$）。\n- 对每个 $j$（$1 \\le j \\le L - 1$），有 $X_j \\ne X_{j+1}$。此外，在每次修改补给计划后，对每个 $j$（$1 \\le j \\le L - 1$），仍满足 $X_j \\ne X_{j+1}$。\n\n### 子任务\n\n共有 4 个子任务。每个子任务的得分及附加约束如下：\n\n**子任务 1 [12 分]**\n\n- $N \\le 10$。\n- $M \\le 10$。\n- $T = 1$。\n- $L \\le 10$。\n- $C_i \\le 10$（$1 \\le i \\le M$）。\n\n**子任务 2 [35 分]**\n\n- $N \\le 500$。\n- $M \\le 500$。\n- $T = 1$。\n\n**子任务 3 [15 分]**\n\n- $T = 1$。\n\n**子任务 4 [38 分]**\n\n无额外约束。\n\n翻译由 Qwen3-235B 完成", "locale": "zh-CN"}}}
{"pid": "P14377", "type": "P", "difficulty": 5, "samples": [["3 30\n2 3 7", "28"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192, 8192]}, "tags": ["搜索", "2017", "PA（波兰）"], "title": "[PA 2017] Iloczyn", "background": "译自 [PA 2017](https://sio2.mimuw.edu.pl/c/pa-2017-1/) R2T2。", "description": "给定一组素数 $p_{1}, p_{2}, \\ldots, p_{k}$。考虑一个正整数集合 $A$，其中每个数的素因子分解仅包含这些给定的素数。例如，如果给定的素数是 $2, 3, 7$，则集合 $A$ 为：\n\n$$\nA=\\{1, 2, 3, 4, 6, 7, 8, 9, 12, 14, 16, 18, 21, 24, 27, 28, 32, 36, 42, 48, 49, 54, 56, 63, 64, 72, 81, 84, 96, 98, \\ldots\\}\n$$\n\nJasio 在纸上写下了所有不超过 $N$ 的这种数字。请问他写下的最大数字是多少？", "inputFormat": "输入数据的第一行包含两个整数 $k, N (k \\geq 1, 1 \\leq N \\leq 10^{18})$，分别表示素数集合的大小和任务中的上限值。\n\n第二行包含 $k$ 个互不相同的素数 $p_{1}, \\ldots, p_{k} (2 \\leq p_{i} \\leq 100)$。", "outputFormat": "输出一行，包含一个自然数，表示集合 $A$ 中不超过 $N$ 的最大值。", "hint": "$k \\geq 1, 1 \\leq N \\leq 10^{18},2 \\leq p_{i} \\leq 100$。\n\n- 虽然题目没说，但在数据中，保证 $p_i$ 是升序的。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2017] Iloczyn", "background": "译自 [PA 2017](https://sio2.mimuw.edu.pl/c/pa-2017-1/) R2T2。", "description": "给定一组素数 $p_{1}, p_{2}, \\ldots, p_{k}$。考虑一个正整数集合 $A$，其中每个数的素因子分解仅包含这些给定的素数。例如，如果给定的素数是 $2, 3, 7$，则集合 $A$ 为：\n\n$$\nA=\\{1, 2, 3, 4, 6, 7, 8, 9, 12, 14, 16, 18, 21, 24, 27, 28, 32, 36, 42, 48, 49, 54, 56, 63, 64, 72, 81, 84, 96, 98, \\ldots\\}\n$$\n\nJasio 在纸上写下了所有不超过 $N$ 的这种数字。请问他写下的最大数字是多少？", "inputFormat": "输入数据的第一行包含两个整数 $k, N (k \\geq 1, 1 \\leq N \\leq 10^{18})$，分别表示素数集合的大小和任务中的上限值。\n\n第二行包含 $k$ 个互不相同的素数 $p_{1}, \\ldots, p_{k} (2 \\leq p_{i} \\leq 100)$。", "outputFormat": "输出一行，包含一个自然数，表示集合 $A$ 中不超过 $N$ 的最大值。", "hint": "$k \\geq 1, 1 \\leq N \\leq 10^{18},2 \\leq p_{i} \\leq 100$。\n\n- 虽然题目没说，但在数据中，保证 $p_i$ 是升序的。", "locale": "zh-CN"}}}
{"pid": "P14378", "type": "P", "difficulty": 5, "samples": [["5 4 5\n8 4 4 4 5\n1 1 2 1\n5 4 6 4\n4 8\n4 3\n4 5\n5 8\n1 2\n", "2\n3\n3\n3\n2\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "线段树", "O2优化", "ST 表", "梦熊比赛"], "title": "【MX-S9-T1】「LAOI-16」签到", "background": "> 有个地方真实存在，有着复眼能看到的色彩。\n>\n> 在人们无数次沉没里，怎么还有条船不远万里。", "description": "给定一个长度为 $n$ 的非负整数序列 $A_1, \\ldots, A_n$ 以及两个长度为 $k$ 的正整数序列 $B_1, \\ldots, B_k$ 和非负整数序列 $C_1, \\ldots, C_k$。\n\n你使用的 sʍopuᴉʍ 系统的画图软件有 $k$ 种颜色 $1\\sim k$。你需要为 $n$ 个元素都涂上一种颜色，使得颜色 $i$ 的出现次数恰好为 $B_i$。\n\n对于涂上了第 $i$ 种颜色的元素，值同时加上 $C_i$。\n\n经过上述操作后会得到新的序列 $A'$，你想知道序列 $A'$ 可能的最小极差是多少（极差的定义为整个序列的最大值减去最小值的值）。\n\n这实在太困难了，所以你的 sʍopuᴉʍ 系统共 $Q$ 次发生 UB 错误，把你的序列 $A$ 改掉了！第 $i$ 次会把 $A_{x_i}$ 改为 $v_i$。在你解决完问题后你会发现序列被修改了，所以你按下了 Ctrl+Z 撤销这次修改。\n\n但是这很有趣！你需要把每次修改后的答案输出。", "inputFormat": "第一行，三个正整数 $n,k,q$，含义见题目描述。\n\n第二行，$n$ 个非负整数 $A_1, \\ldots, A_n$。\n\n第三行，$k$ 个正整数 $B_1, \\ldots, B_k$。\n\n第四行，$k$ 个非负整数 $C_1, \\ldots, C_k$。\n\n接下来 $q$ 行，每行两个整数 $x_i, v_i$，表示将 $A_{x_i}$ 改为 $v_i$。修改之间独立。", "outputFormat": "共 $q$ 行，每行一个非负整数，表示修改后可能的最小极差。", "hint": "**【样例解释 #1】**\n\n- 第一次修改后序列为：$\\langle 8,4,4,8,5\\rangle$，可行的操作是 $\\langle 8{\\color{red}{{}+4}},4{\\color{red}{{}+6}},4{\\color{red}{{}+6}},8{\\color{red}{{}+4}},5{\\color{red}{{}+5}}\\rangle$，最小极差为 $8{\\color{red}{{}+4}}-(5{\\color{red}{{}+5}})=2$。\n\n- 第二次修改后序列为：$\\langle 8,4,4,3,5\\rangle$，可行的操作是 $\\langle 8{\\color{red}{{}+4}},4{\\color{red}{{}+6}},4{\\color{red}{{}+5}},3{\\color{red}{{}+6}},5{\\color{red}{{}+4}}\\rangle$，最小极差为 $8{\\color{red}{{}+4}}-(3{\\color{red}{{}+6}})=3$。\n\n- 第三次修改后序列为：$\\langle 8,4,4,5,5\\rangle$，可行的操作是 $\\langle 8{\\color{red}{{}+4}},4{\\color{red}{{}+6}},4{\\color{red}{{}+5}},5{\\color{red}{{}+4}},5{\\color{red}{{}+6}}\\rangle$，最小极差为 $8{\\color{red}{{}+4}}-(4{\\color{red}{{}+5}})=3$。\n\n- 第四次修改后序列为：$\\langle 8,4,4,4,8\\rangle$，可行的操作是 $\\langle 8{\\color{red}{{}+4}},4{\\color{red}{{}+6}},4{\\color{red}{{}+6}},4{\\color{red}{{}+5}},8{\\color{red}{{}+4}}\\rangle$，最小极差为 $8{\\color{red}{{}+4}}-(4{\\color{red}{{}+5}})=3$。\n\n- 第五次修改后序列为：$\\langle 2,4,4,4,5\\rangle$，可行的操作是 $\\langle 2{\\color{red}{{}+6}},4{\\color{red}{{}+6}},4{\\color{red}{{}+5}},4{\\color{red}{{}+4}},5{\\color{red}{{}+4}}\\rangle$，最小极差为 $4{\\color{red}{{}+6}}-(2{\\color{red}{{}+6}})=2$。\n\n**【样例 #2】**\n\n见选手目录下的 $\\textbf{\\textit{register/register2.in}}$ 与 $\\textbf{\\textit{register/register2.ans}}$。\n\n该样例满足测试点 $1$ 的约束条件。\n\n**【样例 #3】**\n\n见选手目录下的 $\\textbf{\\textit{register/register3.in}}$ 与 $\\textbf{\\textit{register/register3.ans}}$。\n\n该样例满足测试点 $2\\sim 5$ 的约束条件。\n\n**【样例 #4】**\n\n见选手目录下的 $\\textbf{\\textit{register/register4.in}}$ 与 $\\textbf{\\textit{register/register4.ans}}$。\n\n该样例满足测试点 $6\\sim 8$ 的约束条件。\n\n**【样例 #5】**\n\n见选手目录下的 $\\textbf{\\textit{register/register5.in}}$ 与 $\\textbf{\\textit{register/register5.ans}}$。\n\n该样例满足测试点 $9\\sim 11$ 的约束条件。\n\n**【样例 #6】**\n\n见选手目录下的 $\\textbf{\\textit{register/register6.in}}$ 与 $\\textbf{\\textit{register/register6.ans}}$。\n\n该样例满足测试点 $12\\sim 20$ 的约束条件。\n\n**【数据范围】**\n\n本题共 $20$ 个测试点，每个 $5$ 分。\n\n对于所有测试数据，保证：\n\n- $1\\le k\\le n\\le 5\\times 10^5$，$1\\le q\\le 5\\times 10^5$；\n- $1\\le x_i\\le n$；\n- $0\\le A_i,C_i,v_i \\le 5\\times 10^5$；\n- $1\\le B_i\\le 5\\times 10^5$；\n- $\\sum B_i=n$。\n\n::cute-table{tuack}\n\n|测试点编号|$n,k,q \\le$|特殊性质|\n|:--:|:--:|:--:|\n|$1$|$8$|A|\n|$2\\sim 5$|$2\\times 10^3$|无|\n|$6\\sim 8$|$5\\times 10^5$|B|\n|$9\\sim 11$|^|C|\n|$12\\sim 20$|^|无|\n\n特殊性质 A：$A_i,C_i,v_i\\le 8$。    \n特殊性质 B：$k=2$。    \n特殊性质 C：$C_i\\le 1$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "【MX-S9-T1】「LAOI-16」签到", "background": "> 有个地方真实存在，有着复眼能看到的色彩。\n>\n> 在人们无数次沉没里，怎么还有条船不远万里。", "description": "给定一个长度为 $n$ 的非负整数序列 $A_1, \\ldots, A_n$ 以及两个长度为 $k$ 的正整数序列 $B_1, \\ldots, B_k$ 和非负整数序列 $C_1, \\ldots, C_k$。\n\n你使用的 sʍopuᴉʍ 系统的画图软件有 $k$ 种颜色 $1\\sim k$。你需要为 $n$ 个元素都涂上一种颜色，使得颜色 $i$ 的出现次数恰好为 $B_i$。\n\n对于涂上了第 $i$ 种颜色的元素，值同时加上 $C_i$。\n\n经过上述操作后会得到新的序列 $A'$，你想知道序列 $A'$ 可能的最小极差是多少（极差的定义为整个序列的最大值减去最小值的值）。\n\n这实在太困难了，所以你的 sʍopuᴉʍ 系统共 $Q$ 次发生 UB 错误，把你的序列 $A$ 改掉了！第 $i$ 次会把 $A_{x_i}$ 改为 $v_i$。在你解决完问题后你会发现序列被修改了，所以你按下了 Ctrl+Z 撤销这次修改。\n\n但是这很有趣！你需要把每次修改后的答案输出。", "inputFormat": "第一行，三个正整数 $n,k,q$，含义见题目描述。\n\n第二行，$n$ 个非负整数 $A_1, \\ldots, A_n$。\n\n第三行，$k$ 个正整数 $B_1, \\ldots, B_k$。\n\n第四行，$k$ 个非负整数 $C_1, \\ldots, C_k$。\n\n接下来 $q$ 行，每行两个整数 $x_i, v_i$，表示将 $A_{x_i}$ 改为 $v_i$。修改之间独立。", "outputFormat": "共 $q$ 行，每行一个非负整数，表示修改后可能的最小极差。", "hint": "**【样例解释 #1】**\n\n- 第一次修改后序列为：$\\langle 8,4,4,8,5\\rangle$，可行的操作是 $\\langle 8{\\color{red}{{}+4}},4{\\color{red}{{}+6}},4{\\color{red}{{}+6}},8{\\color{red}{{}+4}},5{\\color{red}{{}+5}}\\rangle$，最小极差为 $8{\\color{red}{{}+4}}-(5{\\color{red}{{}+5}})=2$。\n\n- 第二次修改后序列为：$\\langle 8,4,4,3,5\\rangle$，可行的操作是 $\\langle 8{\\color{red}{{}+4}},4{\\color{red}{{}+6}},4{\\color{red}{{}+5}},3{\\color{red}{{}+6}},5{\\color{red}{{}+4}}\\rangle$，最小极差为 $8{\\color{red}{{}+4}}-(3{\\color{red}{{}+6}})=3$。\n\n- 第三次修改后序列为：$\\langle 8,4,4,5,5\\rangle$，可行的操作是 $\\langle 8{\\color{red}{{}+4}},4{\\color{red}{{}+6}},4{\\color{red}{{}+5}},5{\\color{red}{{}+4}},5{\\color{red}{{}+6}}\\rangle$，最小极差为 $8{\\color{red}{{}+4}}-(4{\\color{red}{{}+5}})=3$。\n\n- 第四次修改后序列为：$\\langle 8,4,4,4,8\\rangle$，可行的操作是 $\\langle 8{\\color{red}{{}+4}},4{\\color{red}{{}+6}},4{\\color{red}{{}+6}},4{\\color{red}{{}+5}},8{\\color{red}{{}+4}}\\rangle$，最小极差为 $8{\\color{red}{{}+4}}-(4{\\color{red}{{}+5}})=3$。\n\n- 第五次修改后序列为：$\\langle 2,4,4,4,5\\rangle$，可行的操作是 $\\langle 2{\\color{red}{{}+6}},4{\\color{red}{{}+6}},4{\\color{red}{{}+5}},4{\\color{red}{{}+4}},5{\\color{red}{{}+4}}\\rangle$，最小极差为 $4{\\color{red}{{}+6}}-(2{\\color{red}{{}+6}})=2$。\n\n**【样例 #2】**\n\n见选手目录下的 $\\textbf{\\textit{register/register2.in}}$ 与 $\\textbf{\\textit{register/register2.ans}}$。\n\n该样例满足测试点 $1$ 的约束条件。\n\n**【样例 #3】**\n\n见选手目录下的 $\\textbf{\\textit{register/register3.in}}$ 与 $\\textbf{\\textit{register/register3.ans}}$。\n\n该样例满足测试点 $2\\sim 5$ 的约束条件。\n\n**【样例 #4】**\n\n见选手目录下的 $\\textbf{\\textit{register/register4.in}}$ 与 $\\textbf{\\textit{register/register4.ans}}$。\n\n该样例满足测试点 $6\\sim 8$ 的约束条件。\n\n**【样例 #5】**\n\n见选手目录下的 $\\textbf{\\textit{register/register5.in}}$ 与 $\\textbf{\\textit{register/register5.ans}}$。\n\n该样例满足测试点 $9\\sim 11$ 的约束条件。\n\n**【样例 #6】**\n\n见选手目录下的 $\\textbf{\\textit{register/register6.in}}$ 与 $\\textbf{\\textit{register/register6.ans}}$。\n\n该样例满足测试点 $12\\sim 20$ 的约束条件。\n\n**【数据范围】**\n\n本题共 $20$ 个测试点，每个 $5$ 分。\n\n对于所有测试数据，保证：\n\n- $1\\le k\\le n\\le 5\\times 10^5$，$1\\le q\\le 5\\times 10^5$；\n- $1\\le x_i\\le n$；\n- $0\\le A_i,C_i,v_i \\le 5\\times 10^5$；\n- $1\\le B_i\\le 5\\times 10^5$；\n- $\\sum B_i=n$。\n\n::cute-table{tuack}\n\n|测试点编号|$n,k,q \\le$|特殊性质|\n|:--:|:--:|:--:|\n|$1$|$8$|A|\n|$2\\sim 5$|$2\\times 10^3$|无|\n|$6\\sim 8$|$5\\times 10^5$|B|\n|$9\\sim 11$|^|C|\n|$12\\sim 20$|^|无|\n\n特殊性质 A：$A_i,C_i,v_i\\le 8$。    \n特殊性质 B：$k=2$。    \n特殊性质 C：$C_i\\le 1$。", "locale": "zh-CN"}}}
