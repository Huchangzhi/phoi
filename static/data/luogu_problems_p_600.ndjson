{"pid": "P13175", "type": "P", "difficulty": 4, "samples": [["3\n20\n1\n123", "Case #1: 4\nCase #2: 1\nCase #3: 1"]], "limits": {"time": [5000, 15000], "memory": [1048576, 1048576]}, "tags": ["2017", "递归", "枚举", "Google Code Jam"], "title": "[GCJ 2017 #3] Googlements", "background": "", "description": "Chemists work with periodic table elements, but here at Code Jam, we have been using our advanced number smasher to study googlements. A googlement is a substance that can be represented by a string of at most nine digits. A googlement of length $L$ must contain only decimal digits in the range $0$ through $L$, inclusive, and it must contain at least one digit greater than $0$. Leading zeroes are allowed. For example, $103$ and $001$ are valid googlements of length $3$. $400$ (which contains a digit, $4$, greater than the length of the googlement, $3$) and $000$ (which contains no digit greater than 0) are not.\n\nAny valid googlement can appear in the world at any time, but it will eventually decay into another googlement in a deterministic way, as follows. For a googlement of length $L$, count the number of $1$s in the googlement (which could be $0$) and write down that value, then count the number of $2$s in the googlement (which could be $0$) and write down that value to the right of the previous value, and so on, until you finally count and write down the number of $L$s. The new string generated in this way represents the new googlement, and it will also have length $L$. It is even possible for a googlement to decay into itself!\n\nFor example, suppose that the googlement $0414$ has just appeared. This has one $1$, zero $2$s, zero $3$s, and two $4$s, so it will decay into the googlement $1002$. This has one $1$, one $2$, zero $3$s, and zero $4$s, so it will decay into $1100$, which will decay into $2000$, which will decay into $0100$, which will decay into $1000$, which will continuously decay into itself.\n\nYou have just observed a googlement $G$. This googlement might have just appeared in the world, or it might be the result of one or more decay steps. What is the total number of possible googlements it could have been when it originally appeared in the world?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each consists of one line with a string $G$, representing a googlement.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of different googlements that the observed googlement could have been when it first appeared in the world.", "hint": "**Sample Explanation**\n\nIn sample case #1, the googlement could have originally been $20$, or it could have decayed from $11$, which could have itself decayed from $12$ or $21$. Neither of the latter two could have been a product of decay. So there are four possibilities in total.\n\nIn sample case #2, the googlement must have originally been $1$, which is the only possible googlement of length $1$.\n\nIn sample case #3, the googlement must have been $123$; no other googlement could have decayed into it.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- Each digit in $G$ is a decimal digit between $0$ and the length of $G$, inclusive.\n- $G$ contains at least one non-zero digit.\n\n**Small dataset (3 Pts, Test Set 1 - Visible)**\n\n- Time limit: ~~20~~ 5 seconds.\n- $1 \\leq$ the length of G $\\leq 5$.\n\n**Large dataset (10 Pts, Test Set 2 - Hidden)**\n\n- Time limit: ~~60~~ 15 seconds.\n- $1 \\leq$ the length of G $\\leq 9$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #3] Googlements", "background": "", "description": "Chemists work with periodic table elements, but here at Code Jam, we have been using our advanced number smasher to study googlements. A googlement is a substance that can be represented by a string of at most nine digits. A googlement of length $L$ must contain only decimal digits in the range $0$ through $L$, inclusive, and it must contain at least one digit greater than $0$. Leading zeroes are allowed. For example, $103$ and $001$ are valid googlements of length $3$. $400$ (which contains a digit, $4$, greater than the length of the googlement, $3$) and $000$ (which contains no digit greater than 0) are not.\n\nAny valid googlement can appear in the world at any time, but it will eventually decay into another googlement in a deterministic way, as follows. For a googlement of length $L$, count the number of $1$s in the googlement (which could be $0$) and write down that value, then count the number of $2$s in the googlement (which could be $0$) and write down that value to the right of the previous value, and so on, until you finally count and write down the number of $L$s. The new string generated in this way represents the new googlement, and it will also have length $L$. It is even possible for a googlement to decay into itself!\n\nFor example, suppose that the googlement $0414$ has just appeared. This has one $1$, zero $2$s, zero $3$s, and two $4$s, so it will decay into the googlement $1002$. This has one $1$, one $2$, zero $3$s, and zero $4$s, so it will decay into $1100$, which will decay into $2000$, which will decay into $0100$, which will decay into $1000$, which will continuously decay into itself.\n\nYou have just observed a googlement $G$. This googlement might have just appeared in the world, or it might be the result of one or more decay steps. What is the total number of possible googlements it could have been when it originally appeared in the world?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each consists of one line with a string $G$, representing a googlement.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of different googlements that the observed googlement could have been when it first appeared in the world.", "hint": "**Sample Explanation**\n\nIn sample case #1, the googlement could have originally been $20$, or it could have decayed from $11$, which could have itself decayed from $12$ or $21$. Neither of the latter two could have been a product of decay. So there are four possibilities in total.\n\nIn sample case #2, the googlement must have originally been $1$, which is the only possible googlement of length $1$.\n\nIn sample case #3, the googlement must have been $123$; no other googlement could have decayed into it.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- Each digit in $G$ is a decimal digit between $0$ and the length of $G$, inclusive.\n- $G$ contains at least one non-zero digit.\n\n**Small dataset (3 Pts, Test Set 1 - Visible)**\n\n- Time limit: ~~20~~ 5 seconds.\n- $1 \\leq$ the length of G $\\leq 5$.\n\n**Large dataset (10 Pts, Test Set 2 - Hidden)**\n\n- Time limit: ~~60~~ 15 seconds.\n- $1 \\leq$ the length of G $\\leq 9$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #3] Googlements", "background": null, "description": "化学家研究元素周期表中的元素，而在 Code Jam，我们一直在用先进的数字粉碎机研究 googlement。googlement 是一种可以用最多九位数字表示的物质。长度为 $L$ 的 googlement 只能包含 $0$ 到 $L$（包含 $L$）之间的十进制数字，并且必须至少包含一个大于 $0$ 的数字。允许前导零。例如，$103$ 和 $001$ 是长度为 $3$ 的合法 googlement。$400$（包含了一个大于 googlement 长度 $3$ 的数字 $4$）和 $000$（没有任何大于 $0$ 的数字）都不是合法的 googlement。\n\n任何合法的 googlement 都可能在世界上随时出现，但最终会以确定性的方式衰变为另一个 googlement。具体规则如下：对于长度为 $L$ 的 googlement，统计其中 $1$ 的个数（可能为 $0$），并写下该值，然后统计 $2$ 的个数并写在前一个数字的右边，依此类推，直到统计并写下 $L$ 的个数。这样生成的新字符串就是新的 googlement，其长度同样为 $L$。有时 googlement 甚至可能衰变为自身！\n\n例如，假设 googlement $0414$ 刚刚出现。它包含一个 $1$，零个 $2$，零个 $3$，两个 $4$，因此会衰变为 googlement $1002$。$1002$ 包含一个 $1$，一个 $2$，零个 $3$，零个 $4$，因此会衰变为 $1100$，接着衰变为 $2000$，再衰变为 $0100$，再衰变为 $1000$，最后会不断地衰变为自身。\n\n你刚刚观察到了一个 googlement $G$。这个 googlement 可能是刚刚在世界上出现的，也可能是经过一次或多次衰变后的结果。请问，$G$ 最初在世界上出现时可能是哪几个不同的 googlement？请输出所有可能的数量。", "inputFormat": "第一行包含测试用例的数量 $T$。接下来有 $T$ 组测试数据，每组一行，包含一个字符串 $G$，表示一个 googlement。", "outputFormat": "对于每组测试数据，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是观察到的 googlement 最初可能的不同 googlement 的数量。", "hint": "**样例解释**\n\n样例 $1$ 中，googlement 最初可能是 $20$，也可能是由 $11$ 衰变而来，而 $11$ 又可能由 $12$ 或 $21$ 衰变而来。这两者都不可能是其他 googlement 衰变的结果。所以总共有四种可能。\n\n样例 $2$ 中，googlement 必须最初就是 $1$，这是唯一可能的长度为 $1$ 的 googlement。\n\n样例 $3$ 中，googlement 必须最初就是 $123$，没有其他 googlement 能够衰变为它。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $G$ 中每一位都是 $0$ 到 $G$ 的长度之间的十进制数字。\n- $G$ 至少包含一个非零数字。\n\n**小数据集（3 分，测试点 1 - 可见）**\n\n- 时间限制：~~20~~ 5 秒。\n- $1 \\leq G$ 的长度 $\\leq 5$。\n\n**大数据集（10 分，测试点 2 - 隐藏）**\n\n- 时间限制：~~60~~ 15 秒。\n- $1 \\leq G$ 的长度 $\\leq 9$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13176", "type": "P", "difficulty": 5, "samples": [["5\n2 2\n1 2\n2 1\n2 1\n1 2\n4 3\n1 2\n2 3\n3 1\n3 4\n1 2\n2 3\n3 1\n2 1\n3 3\n1 3\n2 3\n1 2", "Case #1: 1 1\nCase #2: IMPOSSIBLE\nCase #3: -1 -1 -1\nCase #4: 4 -4 -4 8\nCase #5: -1 1 1"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["搜索", "图论", "2017", "Special Judge", "生成树", "Google Code Jam"], "title": "[GCJ 2017 #3] Good News and Bad News", "background": "", "description": "You would like to get your $F$ friends to share some news. You know your friends well, so you know which of your friends can talk to which of your other friends. There are $P$ such one-way relationships, each of which is an ordered pair $(A_i, B_i)$ that means that friend $A_i$ can talk to friend $B_i$. It does not imply that friend $B_i$ can talk to friend $A_i$; however, another of the ordered pairs might make that true.\n\nFor every such existing ordered pair $(A_i, B_i)$, you want friend $A_i$ to deliver some news to friend $B_i$. In each case, this news will be represented by an integer value; the magnitude of the news is given by the absolute value, and the type of news (good or bad) is given by the sign. The integer cannot be 0 (or else there would be no news!), and its absolute value cannot be larger than $F^2$ (or else the news would be just *too* exciting!). These integer values may be different for different ordered pairs.\n\nBecause you are considerate of your friends' feelings, for each friend, the sum of the values of all news given *by* that friend must equal the sum of values of all news given *to* that friend. If no news is given by a friend, that sum is considered to be 0; if no news is given to a friend, that sum is considered to be 0.\n\nCan you find a set of news values for your friends to communicate such that these rules are obeyed, or determine that it is impossible?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each begins with one line with two integers $F$ and $P$: the number of friends, and the number of different ordered pairs of friends. Then, $P$ more lines follow; the $i$-th of these lines has two different integers $A_i$ and $B_i$ representing that friend $A_i$ can talk to friend $B_i$. Friends are numbered from 1 to $F$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either IMPOSSIBLE if there is no arrangement satisfying the rules above, or, if there is such an arrangement, $P$ integers, each of which is nonzero and lies inside $[-F^2, F^2]$. The $i$-th of those integers corresponds to the $i$-th ordered pair from the input, and represents the news value that the first friend in the ordered pair will communicate to the second. The full set of values must satisfy the conditions in the problem statement.\n\nIf there are multiple possible answers, you may output any of them.", "hint": "**Sample Explanation**\n\nThe sample output shows one possible set of valid answers. Other valid answers are possible.\n\nIn Sample Case #1, one acceptable arrangement is to have friend $1$ deliver news with value $1$ to friend $2$, and vice versa.\n\nIn Sample Case #2, whatever value of news friend $1$ gives to friend $2$, it must be nonzero. So, the sum of news values given to friend $2$ is not equal to zero. However, friend $2$ cannot give any news and so that value is $0$. Therefore, the sums of given and received news for friend $2$ cannot match, and the case is IMPOSSIBLE.\n\nIn Sample Case #3, each of friends $1, 2$, and $3$ can deliver news with value $-1$ to the one other friend they can talk to — an unfortunate circle of bad news! Note that there is a friend 4 who does not give or receive any news; this still obeys the rules.\n\nIn Sample Case #4, note that $-5\\ 5\\ 5\\ -10$ would not have been an acceptable answer, because there are $3$ friends, and $|-10| > 3^2$.\n\nIn Sample Case #5, note that the case cannot be solved without using at least one negative value.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq A_i \\leq F$, for all $i$.\n- $1 \\leq B_i \\leq F$, for all $i$.\n- $A_i \\neq B_i$, for all $i$. (A friend does not self-communicate.)\n- $(A_i, B_i) \\neq (A_j, B_j)$, for all $i \\neq j$. (No pair of friends is repeated within a test case in the same order.)\n\n**Small dataset (Test Set 1 - Visible)**\n\n- Time limit: ~~20~~ 5 seconds.\n- $2 \\leq F \\leq 4$.\n- $1 \\leq P \\leq 12$.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- Time limit: ~~40~~ 10 seconds.\n- $2 \\leq F \\leq 1000$.\n- $1 \\leq P \\leq 2000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #3] Good News and Bad News", "background": "", "description": "You would like to get your $F$ friends to share some news. You know your friends well, so you know which of your friends can talk to which of your other friends. There are $P$ such one-way relationships, each of which is an ordered pair $(A_i, B_i)$ that means that friend $A_i$ can talk to friend $B_i$. It does not imply that friend $B_i$ can talk to friend $A_i$; however, another of the ordered pairs might make that true.\n\nFor every such existing ordered pair $(A_i, B_i)$, you want friend $A_i$ to deliver some news to friend $B_i$. In each case, this news will be represented by an integer value; the magnitude of the news is given by the absolute value, and the type of news (good or bad) is given by the sign. The integer cannot be 0 (or else there would be no news!), and its absolute value cannot be larger than $F^2$ (or else the news would be just *too* exciting!). These integer values may be different for different ordered pairs.\n\nBecause you are considerate of your friends' feelings, for each friend, the sum of the values of all news given *by* that friend must equal the sum of values of all news given *to* that friend. If no news is given by a friend, that sum is considered to be 0; if no news is given to a friend, that sum is considered to be 0.\n\nCan you find a set of news values for your friends to communicate such that these rules are obeyed, or determine that it is impossible?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each begins with one line with two integers $F$ and $P$: the number of friends, and the number of different ordered pairs of friends. Then, $P$ more lines follow; the $i$-th of these lines has two different integers $A_i$ and $B_i$ representing that friend $A_i$ can talk to friend $B_i$. Friends are numbered from 1 to $F$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either IMPOSSIBLE if there is no arrangement satisfying the rules above, or, if there is such an arrangement, $P$ integers, each of which is nonzero and lies inside $[-F^2, F^2]$. The $i$-th of those integers corresponds to the $i$-th ordered pair from the input, and represents the news value that the first friend in the ordered pair will communicate to the second. The full set of values must satisfy the conditions in the problem statement.\n\nIf there are multiple possible answers, you may output any of them.", "hint": "**Sample Explanation**\n\nThe sample output shows one possible set of valid answers. Other valid answers are possible.\n\nIn Sample Case #1, one acceptable arrangement is to have friend $1$ deliver news with value $1$ to friend $2$, and vice versa.\n\nIn Sample Case #2, whatever value of news friend $1$ gives to friend $2$, it must be nonzero. So, the sum of news values given to friend $2$ is not equal to zero. However, friend $2$ cannot give any news and so that value is $0$. Therefore, the sums of given and received news for friend $2$ cannot match, and the case is IMPOSSIBLE.\n\nIn Sample Case #3, each of friends $1, 2$, and $3$ can deliver news with value $-1$ to the one other friend they can talk to — an unfortunate circle of bad news! Note that there is a friend 4 who does not give or receive any news; this still obeys the rules.\n\nIn Sample Case #4, note that $-5\\ 5\\ 5\\ -10$ would not have been an acceptable answer, because there are $3$ friends, and $|-10| > 3^2$.\n\nIn Sample Case #5, note that the case cannot be solved without using at least one negative value.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq A_i \\leq F$, for all $i$.\n- $1 \\leq B_i \\leq F$, for all $i$.\n- $A_i \\neq B_i$, for all $i$. (A friend does not self-communicate.)\n- $(A_i, B_i) \\neq (A_j, B_j)$, for all $i \\neq j$. (No pair of friends is repeated within a test case in the same order.)\n\n**Small dataset (Test Set 1 - Visible)**\n\n- Time limit: ~~20~~ 5 seconds.\n- $2 \\leq F \\leq 4$.\n- $1 \\leq P \\leq 12$.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- Time limit: ~~40~~ 10 seconds.\n- $2 \\leq F \\leq 1000$.\n- $1 \\leq P \\leq 2000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #3] Good News and Bad News", "background": null, "description": "你希望让你的 $F$ 个朋友之间互相传递一些消息。你非常了解你的朋友们，因此你知道哪些朋友可以和哪些其他朋友交流。共有 $P$ 个这样的单向关系，每个关系是一个有序对 $(A_i, B_i)$，表示朋友 $A_i$ 可以和朋友 $B_i$ 交流。这并不意味着朋友 $B_i$ 也可以和朋友 $A_i$ 交流；不过，另一个有序对可能会使得这种情况成立。\n\n对于每一个存在的有序对 $(A_i, B_i)$，你希望朋友 $A_i$ 向朋友 $B_i$ 传递一条消息。每条消息用一个整数值表示；消息的大小由其绝对值给出，消息的类型（好消息或坏消息）由其符号给出。整数不能为 $0$（否则就没有消息了！），并且其绝对值不能大于 $F^2$（否则消息就太激动人心了！）。这些整数值对于不同的有序对可以不同。\n\n因为你很关心朋友们的感受，对于每个朋友，所有由该朋友发出的消息的值之和，必须等于所有传递给该朋友的消息的值之和。如果某个朋友没有发出任何消息，则该和视为 $0$；如果某个朋友没有收到任何消息，该和也视为 $0$。\n\n你能否为你的朋友们找到一组满足上述规则的消息值，或者判断这是不可能的？", "inputFormat": "输入的第一行是测试用例数 $T$。接下来有 $T$ 组测试用例。每组测试用例的第一行为两个整数 $F$ 和 $P$，分别表示朋友的数量和不同的有序朋友对的数量。接下来的 $P$ 行，每行有两个不同的整数 $A_i$ 和 $B_i$，表示朋友 $A_i$ 可以和朋友 $B_i$ 交流。朋友编号从 $1$ 到 $F$。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 要么是 IMPOSSIBLE（如果不存在满足条件的方案），要么是 $P$ 个整数，每个都非零且在区间 $[-F^2, F^2]$ 内。这 $P$ 个整数中的第 $i$ 个对应输入中的第 $i$ 个有序对，表示第一个朋友向第二个朋友传递的消息值。所有消息值的集合必须满足题目中的所有条件。\n\n如果有多组可行解，你可以输出其中任意一组。", "hint": "**样例解释**\n\n样例输出展示了一组可行答案。其他可行答案也是允许的。\n\n在样例第 1 组中，一种可接受的方案是让朋友 $1$ 向朋友 $2$ 传递值为 $1$ 的消息，朋友 $2$ 向朋友 $1$ 传递值为 $1$ 的消息。\n\n在样例第 2 组中，无论朋友 $1$ 向朋友 $2$ 传递什么非零消息，朋友 $2$ 收到的消息之和都不是 $0$。但朋友 $2$ 无法向任何人传递消息，因此其发出的消息之和为 $0$。所以朋友 $2$ 发出和收到的消息之和无法相等，因此该组为 IMPOSSIBLE。\n\n在样例第 3 组中，朋友 $1, 2, 3$ 各自向能交流的朋友传递值为 $-1$ 的消息——形成了一个不幸的坏消息循环！注意，朋友 $4$ 既不发出也不接收任何消息，这同样满足规则。\n\n在样例第 4 组中，$-5\\ 5\\ 5\\ -10$ 不是一个可接受的答案，因为有 $3$ 个朋友，且 $|-10| > 3^2$。\n\n在样例第 5 组中，必须至少使用一个负值才能得到可行解。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- 对所有 $i$，$1 \\leq A_i \\leq F$。\n- 对所有 $i$，$1 \\leq B_i \\leq F$。\n- 对所有 $i$，$A_i \\neq B_i$。（朋友不会和自己交流。）\n- 对所有 $i \\neq j$，$(A_i, B_i) \\neq (A_j, B_j)$。（同一组测试用例中不会有重复的有序对。）\n\n**小数据集（测试集 1 - 可见）**\n\n- 时间限制：~~20~~ 5 秒。\n- $2 \\leq F \\leq 4$。\n- $1 \\leq P \\leq 12$。\n\n**大数据集（测试集 2 - 隐藏）**\n\n- 时间限制：~~40~~ 10 秒。\n- $2 \\leq F \\leq 1000$。\n- $1 \\leq P \\leq 2000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13177", "type": "P", "difficulty": 6, "samples": [["2\n2\n2 1 5\n2 0 3\n1 4 4\n1 6 3\n4\n3 0 24\n2 0 24\n4 0 24\n4 0 24\n2 0 24\n1 0 24\n3 0 24\n1 0 24", "Case #1: 32\nCase #2: 192"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2017", "并查集", "Google Code Jam"], "title": "[GCJ 2017 #3] Mountain Tour", "background": "", "description": "You are on top of Mount Everest, and you want to enjoy all the nice hiking trails that are up there. However, you know from past experience that climbing around on Mount Everest alone is bad — you might get lost in the dark! So you want to go on hikes at pre-arranged times with tour guides.\n\nThere are $\\mathbf{C}$ camps on the mountain (numbered 1 through $\\mathbf{C}$), and there are $2 \\times \\mathbf{C}$ one-way hiking tours (numbered 1 through $2 \\times \\mathbf{C}$). Each hiking tour starts at one camp and finishes at a different camp, and passes through no other camps in between. Mount Everest is sparsely populated, and business is slow; there are exactly 2 hiking tours departing from each camp, and exactly 2 hiking tours arriving at each camp.\n\nEach hiking tour runs daily. Tours 1 and 2 start at camp 1, tours 3 and 4 start at camp 2, and so on: in general, tour $2 \\times i - 1$ and tour $2 \\times i$ start at camp $i$. The $i$-th hiking tour ends at camp number $\\mathbf{E}_i$, leaves at hour $\\mathbf{L}_i$, and has a duration of exactly $\\mathbf{D}_i$ hours.\n\nIt is currently hour 0; the hours in a day are numbered 0 through 23. You are at camp number 1, and you want to do each of the hiking tours exactly once and end up back at camp number 1. You cannot travel between camps except via hiking tours. While you are in a camp, you may wait for any number of hours (including zero) before going on a hiking tour, but you can only start a hiking tour at the instant that it departs.\n\nAfter looking at the tour schedules, you have determined that it is definitely possible to achieve your goal, but you want to do it as fast as possible. If you plan your route optimally, how many hours will it take you to finish all of the tours?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line with an integer $\\mathbf{C}$: the number of camps. Then, $2 \\times \\mathbf{C}$ more lines follow. The $i$-th of these lines (counting starting from 1) represents one hiking tour starting at camp number $\\text{floor}((i + 1) / 2)$, and contains three integers $\\mathbf{E}_i$, $\\mathbf{L}_i$, and $\\mathbf{D}_i$, as described above. Note that this format guarantees that exactly two tours start at each camp.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of hours that it will take you to achieve your goal, as described above.", "hint": "In sample case #1, the optimal plan is as follows:\n\n- Wait at camp 1 for an hour, until it becomes hour 1.\n- Leave camp 1 at hour 1 to take the 5 hour hiking tour; arrive at camp 2 at hour 6.\n- Immediately leave camp 2 at hour 6 to take the 3 hour hiking tour; arrive at camp 1 at hour 9.\n- Wait at camp 1 for 15 hours, until it becomes hour 0 of the next day.\n- Leave camp 1 at hour 0 to take the 3 hour hiking tour; arrive at camp 2 at hour 3.\n- Wait at camp 2 for 1 hour, until it becomes hour 4.\n- Leave camp 2 at hour 4 to take the 4 hour hiking tour; arrive at camp 1 at hour 8.\n\nThis achieves the goal in 1 day and 8 hours, or 32 hours. Any other plan takes longer.\n\nIn sample case #2, all of the tours leave at the same time and are the same duration. After finishing any tour, you can immediately take another tour. If we number the tours from 1 to 8 in the order in which they appear in the test case, one optimal plan is: $1, 5, 4, 7, 6, 2, 3, 8$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{E}_i \\leq \\mathbf{C}$.\n- $\\mathbf{E}_i \\neq \\text{ceiling}(i / 2)$, for all $i$. (No hiking tour starts and ends at the same camp.)\n- $\\text{size of } \\{j : \\mathbf{E}_j = i\\} = 2$, for all $j$. (Exactly two tours end at each camp.)\n- $0 \\leq \\mathbf{L}_i \\leq 23$.\n- $1 \\leq \\mathbf{D}_i \\leq 1000$.\n- There is at least one route that starts and ends at camp 1 and includes each hiking tour exactly once.\n\n**Small dataset (6 Pts, Test Set 1 - Visible)**\n\n- $2 \\leq \\mathbf{C} \\leq 15$.\n\n**Large dataset (24 Pts, Test Set 2 - Hidden)**\n\n- $2 \\leq \\mathbf{C} \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #3] Mountain Tour", "background": "", "description": "You are on top of Mount Everest, and you want to enjoy all the nice hiking trails that are up there. However, you know from past experience that climbing around on Mount Everest alone is bad — you might get lost in the dark! So you want to go on hikes at pre-arranged times with tour guides.\n\nThere are $\\mathbf{C}$ camps on the mountain (numbered 1 through $\\mathbf{C}$), and there are $2 \\times \\mathbf{C}$ one-way hiking tours (numbered 1 through $2 \\times \\mathbf{C}$). Each hiking tour starts at one camp and finishes at a different camp, and passes through no other camps in between. Mount Everest is sparsely populated, and business is slow; there are exactly 2 hiking tours departing from each camp, and exactly 2 hiking tours arriving at each camp.\n\nEach hiking tour runs daily. Tours 1 and 2 start at camp 1, tours 3 and 4 start at camp 2, and so on: in general, tour $2 \\times i - 1$ and tour $2 \\times i$ start at camp $i$. The $i$-th hiking tour ends at camp number $\\mathbf{E}_i$, leaves at hour $\\mathbf{L}_i$, and has a duration of exactly $\\mathbf{D}_i$ hours.\n\nIt is currently hour 0; the hours in a day are numbered 0 through 23. You are at camp number 1, and you want to do each of the hiking tours exactly once and end up back at camp number 1. You cannot travel between camps except via hiking tours. While you are in a camp, you may wait for any number of hours (including zero) before going on a hiking tour, but you can only start a hiking tour at the instant that it departs.\n\nAfter looking at the tour schedules, you have determined that it is definitely possible to achieve your goal, but you want to do it as fast as possible. If you plan your route optimally, how many hours will it take you to finish all of the tours?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line with an integer $\\mathbf{C}$: the number of camps. Then, $2 \\times \\mathbf{C}$ more lines follow. The $i$-th of these lines (counting starting from 1) represents one hiking tour starting at camp number $\\text{floor}((i + 1) / 2)$, and contains three integers $\\mathbf{E}_i$, $\\mathbf{L}_i$, and $\\mathbf{D}_i$, as described above. Note that this format guarantees that exactly two tours start at each camp.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of hours that it will take you to achieve your goal, as described above.", "hint": "In sample case #1, the optimal plan is as follows:\n\n- Wait at camp 1 for an hour, until it becomes hour 1.\n- Leave camp 1 at hour 1 to take the 5 hour hiking tour; arrive at camp 2 at hour 6.\n- Immediately leave camp 2 at hour 6 to take the 3 hour hiking tour; arrive at camp 1 at hour 9.\n- Wait at camp 1 for 15 hours, until it becomes hour 0 of the next day.\n- Leave camp 1 at hour 0 to take the 3 hour hiking tour; arrive at camp 2 at hour 3.\n- Wait at camp 2 for 1 hour, until it becomes hour 4.\n- Leave camp 2 at hour 4 to take the 4 hour hiking tour; arrive at camp 1 at hour 8.\n\nThis achieves the goal in 1 day and 8 hours, or 32 hours. Any other plan takes longer.\n\nIn sample case #2, all of the tours leave at the same time and are the same duration. After finishing any tour, you can immediately take another tour. If we number the tours from 1 to 8 in the order in which they appear in the test case, one optimal plan is: $1, 5, 4, 7, 6, 2, 3, 8$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{E}_i \\leq \\mathbf{C}$.\n- $\\mathbf{E}_i \\neq \\text{ceiling}(i / 2)$, for all $i$. (No hiking tour starts and ends at the same camp.)\n- $\\text{size of } \\{j : \\mathbf{E}_j = i\\} = 2$, for all $j$. (Exactly two tours end at each camp.)\n- $0 \\leq \\mathbf{L}_i \\leq 23$.\n- $1 \\leq \\mathbf{D}_i \\leq 1000$.\n- There is at least one route that starts and ends at camp 1 and includes each hiking tour exactly once.\n\n**Small dataset (6 Pts, Test Set 1 - Visible)**\n\n- $2 \\leq \\mathbf{C} \\leq 15$.\n\n**Large dataset (24 Pts, Test Set 2 - Hidden)**\n\n- $2 \\leq \\mathbf{C} \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #3] Mountain Tour", "background": null, "description": "你现在位于珠穆朗玛峰顶，想要体验山顶上所有美丽的徒步路线。然而，根据以往的经验，你知道独自在珠穆朗玛峰上攀爬是很危险的——你可能会在黑暗中迷路！因此，你希望在预定的时间与导游一起参加徒步旅行。\n\n山上共有 $\\mathbf{C}$ 个营地（编号为 $1$ 到 $\\mathbf{C}$），共有 $2 \\times \\mathbf{C}$ 条单向徒步路线（编号为 $1$ 到 $2 \\times \\mathbf{C}$）。每条徒步路线从一个营地出发，终点为另一个不同的营地，中间不会经过其他营地。珠穆朗玛峰人烟稀少，生意也很冷清；每个营地恰好有 2 条徒步路线出发，也恰好有 2 条徒步路线到达。\n\n每条徒步路线每天都会运行。第 1 条和第 2 条路线从营地 1 出发，第 3 条和第 4 条路线从营地 2 出发，依此类推：一般来说，第 $2 \\times i - 1$ 条和第 $2 \\times i$ 条路线从营地 $i$ 出发。第 $i$ 条徒步路线终点为营地编号 $\\mathbf{E}_i$，出发时间为第 $\\mathbf{L}_i$ 小时，持续时间恰好为 $\\mathbf{D}_i$ 小时。\n\n现在是第 0 小时；一天中的小时编号为 $0$ 到 $23$。你位于营地 1，想要每条徒步路线都走一次，并最终回到营地 1。你不能通过其他方式在营地之间移动，只能乘坐徒步路线。在营地时，你可以等待任意小时数（包括 0），但只能在徒步路线出发的那一刻登上路线。\n\n在查看了所有路线的时间表后，你已经确定一定可以实现目标，但你希望用最短的时间完成。如果你合理规划路线，完成所有徒步路线所需的最短时间是多少小时？", "inputFormat": "输入的第一行是测试用例数 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试数据。每组测试数据的第一行为一个整数 $\\mathbf{C}$，表示营地数量。接下来有 $2 \\times \\mathbf{C}$ 行，第 $i$ 行（从 1 开始计数）描述一条徒步路线，其起点为营地编号 $\\text{floor}((i + 1) / 2)$，包含三个整数 $\\mathbf{E}_i$、$\\mathbf{L}_i$ 和 $\\mathbf{D}_i$，含义如上所述。注意，这种输入格式保证每个营地恰好有两条路线出发。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是完成所有路线所需的最短小时数。", "hint": "在样例 1 中，最优方案如下：\n\n- 在营地 1 等待 1 小时，直到第 1 小时。\n- 在第 1 小时从营地 1 出发，乘坐 5 小时的徒步路线，到达营地 2，此时为第 6 小时。\n- 立即在第 6 小时从营地 2 出发，乘坐 3 小时的徒步路线，到达营地 1，此时为第 9 小时。\n- 在营地 1 等待 15 小时，直到第二天的第 0 小时。\n- 在第 0 小时从营地 1 出发，乘坐 3 小时的徒步路线，到达营地 2，此时为第 3 小时。\n- 在营地 2 等待 1 小时，直到第 4 小时。\n- 在第 4 小时从营地 2 出发，乘坐 4 小时的徒步路线，到达营地 1，此时为第 8 小时。\n\n这样总共用时 1 天 8 小时，即 32 小时。任何其他方案都更慢。\n\n在样例 2 中，所有路线的出发时间和持续时间都相同。完成任意一条路线后，你都可以立即乘坐另一条路线。如果我们按输入顺序编号路线为 1 到 8，一种最优方案为：$1, 5, 4, 7, 6, 2, 3, 8$。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{E}_i \\leq \\mathbf{C}$。\n- 对所有 $i$，有 $\\mathbf{E}_i \\neq \\text{ceiling}(i / 2)$（没有路线起点和终点相同）。\n- 对所有 $j$，有 $\\text{size of } \\{j : \\mathbf{E}_j = i\\} = 2$（每个营地恰好有两条路线到达）。\n- $0 \\leq \\mathbf{L}_i \\leq 23$。\n- $1 \\leq \\mathbf{D}_i \\leq 1000$。\n- 至少存在一条从营地 1 出发、最终回到营地 1、且每条路线恰好走一次的路线。\n\n**小数据范围（6 分，测试点 1 - 可见）**\n\n- $2 \\leq \\mathbf{C} \\leq 15$。\n\n**大数据范围（24 分，测试点 2 - 隐藏）**\n\n- $2 \\leq \\mathbf{C} \\leq 1000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13178", "type": "P", "difficulty": 7, "samples": [["4\n2 3 2 2\n2 1 4\n1 2 7\n1 2 1 1000000000\n1 2 1000000000\n3 1 2 100\n1 1 1\n3 1 202\n2 2 2 2\n2 1 1\n2 2 4", "Case #1: 40\nCase #2: 999999986\nCase #3: IMPOSSIBLE\nCase #4: IMPOSSIBLE"]], "limits": {"time": [10000, 20000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2017", "Google Code Jam"], "title": "[GCJ 2017 #3] Slate Modern", "background": "", "description": "The prestigious Slate Modern gallery specializes in the latest art craze: grayscale paintings that follow very strict rules. Any painting in the gallery must be a grid with $\\mathbf{R}$ rows and $\\mathbf{C}$ columns. Each cell in the grid is painted with a color of a certain positive integer brightness value; to make sure the art is not too visually startling, the brightness values of any two cells that share an edge (not just a corner) must differ by no more than $\\mathbf{D}$ units.\n\nYour artist friend Cody-Jamal is working on a canvas for the gallery. Last night, he became inspired and filled in $\\mathbf{N}$ different particular cells with certain positive integer brightness values. You just told him about the gallery's rules today, and now he wants to know whether it is possible to fill in all of the remaining cells with positive integer brightness values and complete the painting without breaking the gallery's rules. If this is possible, he wants to make the sum of the brightness values as large as possible, to save his black paint. Can you help him find this sum or determine that the task is impossible? Since the output can be a really big number, we only ask you to output the remainder of dividing the result by the prime $10^9 + 7$ ($1000000007$).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case begins with one line with four integers: $\\mathbf{R}$, $\\mathbf{C}$, $\\mathbf{N}$, and $\\mathbf{D}$, as described above. Then, $\\mathbf{N}$ lines follow; the $i$-th of these has three integers $\\mathbf{R}_i$, $\\mathbf{C}_i$, and $\\mathbf{B}_i$, indicating that the cell in the $\\mathbf{R}_i$th row and $\\mathbf{C}_i$th column of the grid has brightness value $\\mathbf{B}_i$. The rows and columns of the grid are numbered starting from 1.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either IMPOSSIBLE if it is impossible to complete the picture, or else the value of the maximum possible sum of all brightness values modulo the prime $10^9 + 7$ ($1000000007$).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the optimal way to finish the painting is:\n\n```\n6 7 9\n4 6 8\n```\n\nand the sum is $40$.\n\nIn Sample Case #2, the optimal way to finish the painting is:\n```\n2000000000 1000000000\n```\n\nand the sum is $3000000000$; modulo $10^9 + 7$, it is $99999998$6.\n\nIn Sample Case #3, the task is impossible. No matter what value you choose for the cell in row $2$, it will be too different from at least one of the two neighboring filled-in cells.\n\nIn Sample Case #4, the two cells that Cody-Jamal filled in already have brightness values that are too far apart, so it is impossible to continue.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{N} \\leq 200$.\n- $1 \\leq \\mathbf{D} \\leq 10^9$.\n- $1 \\leq \\mathbf{R}_i \\leq \\mathbf{R}$, for all $i$. $1 \\leq \\mathbf{C}_i \\leq \\mathbf{C}$, for all $i$. $1 \\leq \\mathbf{B}_i \\leq 10^9$, for all $i$. (Note that the upper bound only applies to cells that Cody-Jamal already painted. You can assign brightness values larger than $10^9$ to other cells.)\n- $\\mathbf{N} < \\mathbf{R} \\times \\mathbf{C}$. (There is at least one empty cell.)\n- $\\mathbf{R}_i \\neq \\mathbf{R}_j$ and/or $\\mathbf{C}_i \\neq \\mathbf{C}_j$ for all $i \\neq j$. (All of the given cells are different cells in the grid.)\n\n**Small dataset (5 Pts, Test Set 1 - Visible)**\n\n- Time limit: ~~40~~ 10 seconds.\n- $1 \\leq \\mathbf{R} \\leq 200$.\n- $1 \\leq \\mathbf{C} \\leq 200$.\n\n**Large dataset (26 Pts, Test Set 2 - Hidden)**\n\n- Time limit: ~~80~~ 20 seconds.\n- $1 \\leq \\mathbf{R} \\leq 10^9$.\n- $1 \\leq \\mathbf{C} \\leq 10^9$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #3] Slate Modern", "background": "", "description": "The prestigious Slate Modern gallery specializes in the latest art craze: grayscale paintings that follow very strict rules. Any painting in the gallery must be a grid with $\\mathbf{R}$ rows and $\\mathbf{C}$ columns. Each cell in the grid is painted with a color of a certain positive integer brightness value; to make sure the art is not too visually startling, the brightness values of any two cells that share an edge (not just a corner) must differ by no more than $\\mathbf{D}$ units.\n\nYour artist friend Cody-Jamal is working on a canvas for the gallery. Last night, he became inspired and filled in $\\mathbf{N}$ different particular cells with certain positive integer brightness values. You just told him about the gallery's rules today, and now he wants to know whether it is possible to fill in all of the remaining cells with positive integer brightness values and complete the painting without breaking the gallery's rules. If this is possible, he wants to make the sum of the brightness values as large as possible, to save his black paint. Can you help him find this sum or determine that the task is impossible? Since the output can be a really big number, we only ask you to output the remainder of dividing the result by the prime $10^9 + 7$ ($1000000007$).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case begins with one line with four integers: $\\mathbf{R}$, $\\mathbf{C}$, $\\mathbf{N}$, and $\\mathbf{D}$, as described above. Then, $\\mathbf{N}$ lines follow; the $i$-th of these has three integers $\\mathbf{R}_i$, $\\mathbf{C}_i$, and $\\mathbf{B}_i$, indicating that the cell in the $\\mathbf{R}_i$th row and $\\mathbf{C}_i$th column of the grid has brightness value $\\mathbf{B}_i$. The rows and columns of the grid are numbered starting from 1.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either IMPOSSIBLE if it is impossible to complete the picture, or else the value of the maximum possible sum of all brightness values modulo the prime $10^9 + 7$ ($1000000007$).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the optimal way to finish the painting is:\n\n```\n6 7 9\n4 6 8\n```\n\nand the sum is $40$.\n\nIn Sample Case #2, the optimal way to finish the painting is:\n```\n2000000000 1000000000\n```\n\nand the sum is $3000000000$; modulo $10^9 + 7$, it is $99999998$6.\n\nIn Sample Case #3, the task is impossible. No matter what value you choose for the cell in row $2$, it will be too different from at least one of the two neighboring filled-in cells.\n\nIn Sample Case #4, the two cells that Cody-Jamal filled in already have brightness values that are too far apart, so it is impossible to continue.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{N} \\leq 200$.\n- $1 \\leq \\mathbf{D} \\leq 10^9$.\n- $1 \\leq \\mathbf{R}_i \\leq \\mathbf{R}$, for all $i$. $1 \\leq \\mathbf{C}_i \\leq \\mathbf{C}$, for all $i$. $1 \\leq \\mathbf{B}_i \\leq 10^9$, for all $i$. (Note that the upper bound only applies to cells that Cody-Jamal already painted. You can assign brightness values larger than $10^9$ to other cells.)\n- $\\mathbf{N} < \\mathbf{R} \\times \\mathbf{C}$. (There is at least one empty cell.)\n- $\\mathbf{R}_i \\neq \\mathbf{R}_j$ and/or $\\mathbf{C}_i \\neq \\mathbf{C}_j$ for all $i \\neq j$. (All of the given cells are different cells in the grid.)\n\n**Small dataset (5 Pts, Test Set 1 - Visible)**\n\n- Time limit: ~~40~~ 10 seconds.\n- $1 \\leq \\mathbf{R} \\leq 200$.\n- $1 \\leq \\mathbf{C} \\leq 200$.\n\n**Large dataset (26 Pts, Test Set 2 - Hidden)**\n\n- Time limit: ~~80~~ 20 seconds.\n- $1 \\leq \\mathbf{R} \\leq 10^9$.\n- $1 \\leq \\mathbf{C} \\leq 10^9$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #3] Slate Modern", "background": null, "description": "著名的 Slate Modern 画廊专注于最新的艺术潮流：遵循严格规则的灰度画作。画廊中的每一幅画都必须是一个有 $R$ 行 $C$ 列的网格。网格中的每个格子都被涂上一个正整数的亮度值；为了避免画面过于刺眼，任何两个有公共边（不仅仅是角）的格子的亮度值之差不能超过 $D$。\n\n你的艺术家朋友 Cody-Jamal 正在为画廊创作一幅画。昨晚，他灵感迸发，已经在 $N$ 个不同的特定格子里填入了某些正整数亮度值。你今天才告诉他画廊的规则，现在他想知道，是否有可能为剩下的所有格子填入正整数亮度值，并完成这幅画，同时不违反画廊的规则。如果可以，他希望所有亮度值的总和尽可能大，以节省黑色颜料。你能帮他求出这个最大可能的亮度总和，或者判断任务是否不可能完成吗？由于结果可能非常大，你只需要输出结果对质数 $10^9 + 7$（$1000000007$）取余后的值。", "inputFormat": "输入的第一行是测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行为四个整数：$R$、$C$、$N$ 和 $D$，含义如上所述。接下来的 $N$ 行，每行有三个整数 $R_i$、$C_i$ 和 $B_i$，表示第 $R_i$ 行第 $C_i$ 列的格子的亮度值为 $B_i$。网格的行和列编号均从 1 开始。", "outputFormat": "对于每组测试数据，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是最大可能的亮度总和对 $10^9 + 7$ 取余的结果；如果无法完成画作，则输出 `IMPOSSIBLE`。", "hint": "**样例解释**\n\n样例 1 中，最优的填法如下：\n\n```\n6 7 9\n4 6 8\n```\n\n总和为 $40$。\n\n样例 2 中，最优的填法如下：\n\n```\n2000000000 1000000000\n```\n\n总和为 $3000000000$；对 $10^9 + 7$ 取余后为 $999999986$。\n\n样例 3 中，任务无法完成。无论你为第 2 行的格子选择什么值，它与已填的相邻格子的亮度差都会超出允许范围。\n\n样例 4 中，Cody-Jamal 已经填入的两个格子的亮度值差距过大，因此无法继续完成画作。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq N \\leq 200$。\n- $1 \\leq D \\leq 10^9$。\n- $1 \\leq R_i \\leq R$，对于所有 $i$。$1 \\leq C_i \\leq C$，对于所有 $i$。$1 \\leq B_i \\leq 10^9$，对于所有 $i$。（注意，上界仅适用于 Cody-Jamal 已经填入的格子。你可以为其他格子分配大于 $10^9$ 的亮度值。）\n- $N < R \\times C$。（至少有一个空格子。）\n- 对于所有 $i \\neq j$，有 $R_i \\neq R_j$ 或 $C_i \\neq C_j$。（所有已知格子均不相同。）\n\n**小数据范围（5 分，测试点 1 - 可见）**\n\n- 时间限制：10 秒。\n- $1 \\leq R \\leq 200$。\n- $1 \\leq C \\leq 200$。\n\n**大数据范围（26 分，测试点 2 - 隐藏）**\n\n- 时间限制：20 秒。\n- $1 \\leq R \\leq 10^9$。\n- $1 \\leq C \\leq 10^9$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13179", "type": "P", "difficulty": 5, "samples": [["3\n4\n4 8 15 16 23 42\n8 6 7 5 30 9\n1 2 3 4 55 6\n2 10 18 36 54 86\n2\n1 2 3 4 5 6\n60 50 40 30 20 10\n3\n1 2 3 4 5 6\n1 2 3 4 5 6\n1 4 2 6 5 3", "Case #1: 4\nCase #2: 1\nCase #3: 3"]], "limits": {"time": [15000, 30000], "memory": [1048576, 1048576]}, "tags": ["2017", "二分图", "Google Code Jam"], "title": "[GCJ 2017 Finals] Dice Straight", "background": "", "description": "You have a special set of $N$ six-sided dice, each of which has six different positive integers on its faces. Different dice may have different numberings.\n\nYou want to arrange some or all of the dice in a row such that the faces on top form a straight (that is, they show consecutive integers). For each die, you can choose which face is on top.\n\nHow long is the longest straight that can be formed in this way?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with one line with $N$, the number of dice. Then, $N$ more lines follow; each of them has six positive integers $D_{ij}$. The $j$-th number on the $i$-th of these lines gives the number on the $j$-th face of the $i$-th die.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the length of the longest straight that can be formed.", "hint": "**Sample Explanation**\n\nIn sample case #1, a straight of length $4$ can be formed by taking the $2$ from the fourth die, the 3 from the third die, the $4$ from the first die, and the $5$ from the second die.\n\nIn sample case #2, there is no way to form a straight larger than the trivial straight of length $1$.\n\nIn sample case #3, you can take a $1$ from one die, a $2$ from another, and a $3$ from the remaining unused die. Notice that this case demonstrates that there can be multiple dice with the same set of values on their faces.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq D_{ij} \\leq 10^6$ for all $i, j$.\n\n**Small dataset (10 Pts, Test Set 1 - Visible)**\n\n- Time limit: ~~60~~ 15 seconds.\n- $1 \\leq N \\leq 100$.\n\n**Large dataset (15 Pts, Test Set 2 - Hidden)**\n\n- Time limit: ~~120~~ 30 seconds.\n- $1 \\leq N \\leq 50000$.\n- The sum of $N$ across all test cases $\\leq 200000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 Finals] Dice Straight", "background": "", "description": "You have a special set of $N$ six-sided dice, each of which has six different positive integers on its faces. Different dice may have different numberings.\n\nYou want to arrange some or all of the dice in a row such that the faces on top form a straight (that is, they show consecutive integers). For each die, you can choose which face is on top.\n\nHow long is the longest straight that can be formed in this way?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with one line with $N$, the number of dice. Then, $N$ more lines follow; each of them has six positive integers $D_{ij}$. The $j$-th number on the $i$-th of these lines gives the number on the $j$-th face of the $i$-th die.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the length of the longest straight that can be formed.", "hint": "**Sample Explanation**\n\nIn sample case #1, a straight of length $4$ can be formed by taking the $2$ from the fourth die, the 3 from the third die, the $4$ from the first die, and the $5$ from the second die.\n\nIn sample case #2, there is no way to form a straight larger than the trivial straight of length $1$.\n\nIn sample case #3, you can take a $1$ from one die, a $2$ from another, and a $3$ from the remaining unused die. Notice that this case demonstrates that there can be multiple dice with the same set of values on their faces.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq D_{ij} \\leq 10^6$ for all $i, j$.\n\n**Small dataset (10 Pts, Test Set 1 - Visible)**\n\n- Time limit: ~~60~~ 15 seconds.\n- $1 \\leq N \\leq 100$.\n\n**Large dataset (15 Pts, Test Set 2 - Hidden)**\n\n- Time limit: ~~120~~ 30 seconds.\n- $1 \\leq N \\leq 50000$.\n- The sum of $N$ across all test cases $\\leq 200000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 Finals] Dice Straight", "background": "", "description": "你有一组特殊的 $N$ 个六面骰子，每个骰子的六个面上都标有六个不同的正整数。不同的骰子，其面上的数字编号可能不同。\n\n你希望将部分或全部骰子排成一排，使得它们朝上的面所显示的数字能够组成一个顺子（即这些数字是连续的整数）。对于每个骰子，你可以自由选择哪一面朝上。\n\n你能组成的最长顺子的长度是多少？", "inputFormat": "输入的第一行给出测试用例的数量 $T$。接下来有 $T$ 组测试用例。每组测试用例的第一行为一个整数 $N$，表示骰子的数量。接下来的 $N$ 行中，每行有六个正整数 $D_{ij}$，表示第 $i$ 个骰子的第 $j$ 个面的数字。\n", "outputFormat": "对于每组测试用例，输出一行，内容为 `Case #x: y`，其中 $x$ 表示测试用例编号（从 1 开始），$y$ 表示能够组成的最长顺子的长度。\n", "hint": "**样例解释**\n\n在样例第 1 组中，可以通过选取第 4 个骰子的 $2$，第 3 个骰子的 $3$，第 1 个骰子的 $4$，以及第 2 个骰子的 $5$，组成一个长度为 $4$ 的顺子。\n\n在样例第 2 组中，无法组成长度大于 $1$ 的顺子，只能得到最基本的长度为 $1$ 的顺子。\n\n在样例第 3 组中，可以从一个骰子选 $1$，另一个骰子选 $2$，再从剩下的骰子选 $3$。注意，本组数据中有多个骰子的每个面上的数值完全相同。\n\n**限制条件**\n\n- $1 \\leq T \\leq 100$。\n- 对于所有 $i, j$，有 $1 \\leq D_{ij} \\leq 10^6$。\n\n**小数据集（10 分，测试集 1 - 可见）**\n\n- 时间限制：~~60~~ 15 秒。\n- $1 \\leq N \\leq 100$。\n\n**大数据集（15 分，测试集 2 - 隐藏）**\n\n- 时间限制：~~120~~ 30 秒。\n- $1 \\leq N \\leq 50000$。\n- 所有测试用例中 $N$ 的总和 $\\leq 200000$。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13180", "type": "P", "difficulty": 6, "samples": [["5\n1 2\n- 3\n* 2\n5 4\n+ 1\n- 2\n* 3\n/ -2\n1000 7\n* -1000\n* -1000\n* 1000\n* 1000\n* 1000\n* 1000\n* 1000\n-1 3\n- -1\n* 0\n/ -1\n0 1\n+ 0", "Case #1: -1 1\nCase #2: -3 2\nCase #3: 1000000000000000000000000 1\nCase #4: 1 1\nCase #5: 0 1"]], "limits": {"time": [15000, 30000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "贪心", "2017", "Google Code Jam"], "title": "[GCJ 2017 Finals] Operation", "background": "", "description": "Here at Code Jam, we love to play a game called \"Operation\". (No, it has nothing to do with surgery; why would you think that?) The game is played with cards, each card is labeled with a basic arithmetic operation (addition, subtraction, multiplication or division) $\\mathbf{O}_i$ and an integer right operand $\\mathbf{V}_i$ for that operation. For example, a card might say $+\\ 0$, or $-\\ -2$, or $/\\ -4$ — note that operands can be negative or zero, although a card with a division operation will never have 0 as an operand.\n\nIn each round of the game, a starting integer value $\\mathbf{S}$ is chosen, and a set of $\\mathbf{C}$ cards is laid out. The player must choose an order for the cards, using each card exactly once. After that, the operations are applied, in order, to the starting value $\\mathbf{S}$, and a final result is obtained.\n\nAlthough all of the operands on the cards are integers, the operations are executed on rational numbers. For instance, suppose that the initial value is $5$, and the cards are $+\\ 1, -\\ 2, *\\ 3$, and $/\\ -2$. If we put them in the order given above, the final result is $(5 + 1 - 2) * 3 / (-2) = -6$. Notice that the operations are performed in the order given by the cards, disregarding any operator precedence. On the other hand, if we choose the order $-\\ 2, /\\ -2, +\\ 1, *\\ 3$, the result is $((5 - 2) / (-2) + 1) * 3 = -3 / 2$. That example turns out to be the maximum possible value for this set of cards.\n\nGiven a set of cards, can you figure out the maximum possible final value that can be obtained? Please give the result as an irreducible fraction with a positive denominator.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case begins with one line with two integers $\\mathbf{S}$ and $\\mathbf{C}$: the starting value for the game, and the number of cards. Then, $\\mathbf{C}$ lines follow. The i-th of these lines represents one card, and contains one character $\\mathbf{O}_i$ representing the operation (which is either +, -, *, or /) and one integer $\\mathbf{V}_i$ representing the operand.\n", "outputFormat": "For each test case, output one line containing `Case #x: y z`, where $x$ is the test case number (starting from 1), and $y$ and $z$ are integers such that $y/z$ is the maximum possible final value of the game, $y$ and $z$ do not have common divisors other than $1$ and $-1$, and $z$ is strictly greater than $0$.", "hint": "**Sample Explanations**\n\nIn Sample Case #1, the optimal strategy is to play the $*\\ 2$ card before the $-\\ 3$ card, which yields a result of $-1$. The unique rational expression of this as specified in the problem is $-1\\ 1$.\n\nSample Case #2 is the one described in the third paragraph of the problem statement.\n\nIn Sample Case #3, we get the same answer regardless of the order in which we use the cards. Notice that the numerator of the answer is too large to fit in 64-bit integer.\n\nIn Sample Case #4, the largest result we can achieve is $1$. One way is: $/\\ -1, *\\ 0, -\\ -1$.\n\nIn Sample Case #5, note that the only valid representation of the answer is $0\\ 1$. $0\\ 2$ is invalid because it can be reduced. $0\\ -1$ is invalid because the denominator must be positive.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $-1000 \\leq S \\leq 1000$.\n- $O_i$ is one of $+, -, *$, or $/$, for all $i$.\n- $-1000 \\leq V_i \\leq 1000$, for all $i$.\n- If $O_i = /$, then $V_i \\neq 0$, for all $i$.\n\n**Small dataset (10 Pts, Test Set 1 - Visible)**\n\n- Time limit: ~~60~~ 15 seconds.\n- $1 \\leq C \\leq 15$.\n\n**Large dataset (20 Pts, Test Set 2 - Hidden)**\n\n- Time limit: ~~120~~ 30 seconds.\n- $1 \\leq C \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 Finals] Operation", "background": "", "description": "Here at Code Jam, we love to play a game called \"Operation\". (No, it has nothing to do with surgery; why would you think that?) The game is played with cards, each card is labeled with a basic arithmetic operation (addition, subtraction, multiplication or division) $\\mathbf{O}_i$ and an integer right operand $\\mathbf{V}_i$ for that operation. For example, a card might say $+\\ 0$, or $-\\ -2$, or $/\\ -4$ — note that operands can be negative or zero, although a card with a division operation will never have 0 as an operand.\n\nIn each round of the game, a starting integer value $\\mathbf{S}$ is chosen, and a set of $\\mathbf{C}$ cards is laid out. The player must choose an order for the cards, using each card exactly once. After that, the operations are applied, in order, to the starting value $\\mathbf{S}$, and a final result is obtained.\n\nAlthough all of the operands on the cards are integers, the operations are executed on rational numbers. For instance, suppose that the initial value is $5$, and the cards are $+\\ 1, -\\ 2, *\\ 3$, and $/\\ -2$. If we put them in the order given above, the final result is $(5 + 1 - 2) * 3 / (-2) = -6$. Notice that the operations are performed in the order given by the cards, disregarding any operator precedence. On the other hand, if we choose the order $-\\ 2, /\\ -2, +\\ 1, *\\ 3$, the result is $((5 - 2) / (-2) + 1) * 3 = -3 / 2$. That example turns out to be the maximum possible value for this set of cards.\n\nGiven a set of cards, can you figure out the maximum possible final value that can be obtained? Please give the result as an irreducible fraction with a positive denominator.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case begins with one line with two integers $\\mathbf{S}$ and $\\mathbf{C}$: the starting value for the game, and the number of cards. Then, $\\mathbf{C}$ lines follow. The i-th of these lines represents one card, and contains one character $\\mathbf{O}_i$ representing the operation (which is either +, -, *, or /) and one integer $\\mathbf{V}_i$ representing the operand.\n", "outputFormat": "For each test case, output one line containing `Case #x: y z`, where $x$ is the test case number (starting from 1), and $y$ and $z$ are integers such that $y/z$ is the maximum possible final value of the game, $y$ and $z$ do not have common divisors other than $1$ and $-1$, and $z$ is strictly greater than $0$.", "hint": "**Sample Explanations**\n\nIn Sample Case #1, the optimal strategy is to play the $*\\ 2$ card before the $-\\ 3$ card, which yields a result of $-1$. The unique rational expression of this as specified in the problem is $-1\\ 1$.\n\nSample Case #2 is the one described in the third paragraph of the problem statement.\n\nIn Sample Case #3, we get the same answer regardless of the order in which we use the cards. Notice that the numerator of the answer is too large to fit in 64-bit integer.\n\nIn Sample Case #4, the largest result we can achieve is $1$. One way is: $/\\ -1, *\\ 0, -\\ -1$.\n\nIn Sample Case #5, note that the only valid representation of the answer is $0\\ 1$. $0\\ 2$ is invalid because it can be reduced. $0\\ -1$ is invalid because the denominator must be positive.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $-1000 \\leq S \\leq 1000$.\n- $O_i$ is one of $+, -, *$, or $/$, for all $i$.\n- $-1000 \\leq V_i \\leq 1000$, for all $i$.\n- If $O_i = /$, then $V_i \\neq 0$, for all $i$.\n\n**Small dataset (10 Pts, Test Set 1 - Visible)**\n\n- Time limit: ~~60~~ 15 seconds.\n- $1 \\leq C \\leq 15$.\n\n**Large dataset (20 Pts, Test Set 2 - Hidden)**\n\n- Time limit: ~~120~~ 30 seconds.\n- $1 \\leq C \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 Finals] Operation", "background": "", "description": "在 Code Jam，我们非常喜欢玩一个叫做 **Operation** 的游戏。（不，这和外科手术没有任何关系；你为什么会这么想呢？）这个游戏是用卡牌来进行的，每张卡牌上都标有一个基本的算术运算（加法、减法、乘法或除法）$\\mathbf{O}_i$，以及该运算的右操作数 $\\mathbf{V}_i$，它是一个整数。例如，一张卡牌可能写着 $+\\ 0$，或者 $-\\ -2$，又或者 $/\\ -4$ —— 注意，操作数可以是负数，也可以是零，但带有除法操作的卡牌，其操作数绝不会是 $0$。\n\n每一轮游戏会选定一个初始整数值 $\\mathbf{S}$，并摆出一组 $\\mathbf{C}$ 张卡牌。玩家需要自行决定这些卡牌的出牌顺序，每张卡牌都必须且只能使用一次。之后，这些操作会按照卡牌顺序依次作用在起始值 $\\mathbf{S}$ 上，最终得到一个结果。\n\n虽然卡牌上的操作数都是整数，但实际运算是在有理数范围内执行的。例如，假设初始值为 $5$，卡牌分别为 $+\\ 1$、$-\\ 2$、$*\\ 3$ 和 $/\\ -2$。如果按照上述顺序出牌，最终结果是 $(5 + 1 - 2) * 3 / (-2) = -6$。注意，所有操作都严格按照卡牌顺序依次执行，不考虑运算符优先级。另一方面，如果你选择的顺序是 $-\\ 2$、$/\\ -2$、$+\\ 1$、$*\\ 3$，那么结果就是 $((5 - 2) / (-2) + 1) * 3 = -3 / 2$。这个例子中，这样的顺序实际上可以获得这一组卡牌能得到的最大值。\n\n给定一组卡牌，你能算出通过合理排序后，最终可能得到的最大结果吗？请将答案以最简分数形式输出，分母需为正数。", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试用例。每组测试用例的第一行为两个整数 $\\mathbf{S}$ 和 $\\mathbf{C}$，分别表示游戏的起始值和卡牌数量。接下来的 $\\mathbf{C}$ 行，每行描述一张卡牌，包括一个字符 $\\mathbf{O}_i$（表示操作类型，可能为 $+$、$-$、$*$ 或 $/$）和一个整数 $\\mathbf{V}_i$（表示操作数）。\n", "outputFormat": "对于每组测试用例，输出一行，内容为 `Case #x: y z`，其中 $x$ 表示测试用例编号（从 1 开始），$y$ 和 $z$ 是整数，满足 $y/z$ 是该组卡牌能获得的最大最终值，且 $y$ 和 $z$ 互质（除了 $1$ 和 $-1$ 以外没有公约数），并且 $z$ 必须严格大于 $0$。\n", "hint": "**样例解释**\n\n在样例第 1 组中，最优策略是先打出 $*\\ 2$ 卡牌，再打 $-\\ 3$ 卡牌，最终结果为 $-1$。按题目要求，最简分数表达为 $-1\\ 1$。\n\n样例第 2 组对应题面第三段的例子。\n\n样例第 3 组，无论卡牌顺序如何，答案都相同。注意，答案的分子大到无法用 64 位整数表示。\n\n样例第 4 组，最大结果为 $1$。一种可行顺序为：$/\\ -1$、$*\\ 0$、$-\\ -1$。\n\n样例第 5 组，唯一合法的答案为 $0\\ 1$。$0\\ 2$ 不合法，因为可以约分；$0\\ -1$ 也不合法，因为分母必须为正数。\n\n**限制条件**\n\n- $1 \\leq T \\leq 100$。\n- $-1000 \\leq S \\leq 1000$。\n- 对所有 $i$，$O_i$ 为 $+$、$-$、$*$ 或 $/$。\n- 对所有 $i$，$-1000 \\leq V_i \\leq 1000$。\n- 若 $O_i = /$，则 $V_i \\neq 0$。\n\n**小数据集（10 分，测试集 1 - 可见）**\n\n- 时间限制：~~60~~ 15 秒。\n- $1 \\leq C \\leq 15$。\n\n**大数据集（20 分，测试集 2 - 隐藏）**\n\n- 时间限制：~~120~~ 30 秒。\n- $1 \\leq C \\leq 1000$。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13181", "type": "P", "difficulty": 6, "samples": [["2\n3\n8", "Case #1: 3\n011\n101\n110\nCase #2: 4\n0111\n1001\n1001\n1110"]], "limits": {"time": [60000], "memory": [1048576]}, "tags": ["2017", "矩阵树定理", "Special Judge", "随机化", "构造", "行列式", "Google Code Jam"], "title": "[GCJ 2017 Finals] Spanning Planning", "background": "", "description": "A spanning tree of an undirected graph with $N$ nodes is a tree with $N-1$ edges that uses only edges from $N$ and includes all nodes in $N$.\n\nPlease construct a graph with at least $2$ nodes, and no more than $22$ nodes, such that the graph has exactly $K$ different spanning trees. (Two spanning trees are considered different if and only if the sets of edges that they use are different.) The graph must have at most one edge per pair of nodes, and must not contain a loop (an edge from a node to itself).\n\nIt is guaranteed that at least one such graph exists for every $K$ within the limits below.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each consists of one line with an integer $K$: the desired number of spanning trees.", "outputFormat": "For each test case, first output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1), and $y$ is the number of nodes in your graph. ($y$ must be between 2 and 22, inclusive.) Then, output $y$ more lines. The $i$-th of these lines represents the $i$-th node in the graph, and must contain exactly $y$ characters. The $j$-th character on the $i$-th line should be 1 if the $i$-th node and the $j$-th node are connected with an edge, and 0 otherwise. Note that this matrix will be symmetric and it will have all 0s along its main diagonal.\n\nIf multiple answers are possible, you may output any of them. Note that we guarantee that at least one valid answer exists for every $K$ within the limits below.", "hint": "**Sample Explanation**\n\nIn Case #1, the graph is a triangle, and removing any one edge creates a different spanning tree.\n\nIn Case #2, the available edges in our solution tree are $1-2$, $1-3$, $1-4$, $2-4$, and $3-4$. The eight different spanning trees are defined by these sets of edges:\n\n* $1-2$, $1-3$, $1-4$\n* $1-2$, $1-3$, $2-4$\n* $1-2$, $1-3$, $3-4$\n* $1-2$, $1-4$, $3-4$\n* $1-2$, $2-4$, $3-4$\n* $1-3$, $1-4$, $2-4$\n* $1-3$, $2-4$, $3-4$\n* $1-4$, $2-4$, $3-4$\n\n**Limits**\n\n- $1 \\leqslant T \\leqslant 300$.\n\n**Small dataset (30 Pts, Test Set 1 - Visible)**\n\n- $3 \\leqslant K \\leqslant 10000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 Finals] Spanning Planning", "background": "", "description": "A spanning tree of an undirected graph with $N$ nodes is a tree with $N-1$ edges that uses only edges from $N$ and includes all nodes in $N$.\n\nPlease construct a graph with at least $2$ nodes, and no more than $22$ nodes, such that the graph has exactly $K$ different spanning trees. (Two spanning trees are considered different if and only if the sets of edges that they use are different.) The graph must have at most one edge per pair of nodes, and must not contain a loop (an edge from a node to itself).\n\nIt is guaranteed that at least one such graph exists for every $K$ within the limits below.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each consists of one line with an integer $K$: the desired number of spanning trees.", "outputFormat": "For each test case, first output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1), and $y$ is the number of nodes in your graph. ($y$ must be between 2 and 22, inclusive.) Then, output $y$ more lines. The $i$-th of these lines represents the $i$-th node in the graph, and must contain exactly $y$ characters. The $j$-th character on the $i$-th line should be 1 if the $i$-th node and the $j$-th node are connected with an edge, and 0 otherwise. Note that this matrix will be symmetric and it will have all 0s along its main diagonal.\n\nIf multiple answers are possible, you may output any of them. Note that we guarantee that at least one valid answer exists for every $K$ within the limits below.", "hint": "**Sample Explanation**\n\nIn Case #1, the graph is a triangle, and removing any one edge creates a different spanning tree.\n\nIn Case #2, the available edges in our solution tree are $1-2$, $1-3$, $1-4$, $2-4$, and $3-4$. The eight different spanning trees are defined by these sets of edges:\n\n* $1-2$, $1-3$, $1-4$\n* $1-2$, $1-3$, $2-4$\n* $1-2$, $1-3$, $3-4$\n* $1-2$, $1-4$, $3-4$\n* $1-2$, $2-4$, $3-4$\n* $1-3$, $1-4$, $2-4$\n* $1-3$, $2-4$, $3-4$\n* $1-4$, $2-4$, $3-4$\n\n**Limits**\n\n- $1 \\leqslant T \\leqslant 300$.\n\n**Small dataset (30 Pts, Test Set 1 - Visible)**\n\n- $3 \\leqslant K \\leqslant 10000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 Finals] Spanning Planning", "background": "", "description": "一个无向图的生成树，是指在只使用该图已有边的前提下，包含所有 $N$ 个节点、且恰好有 $N-1$ 条边、并且是一棵树的子图。\n\n请你构造一个至少包含 $2$ 个节点、且不超过 $22$ 个节点的图，使得该图恰好有 $K$ 种不同的生成树。（当且仅当两棵生成树所用的边集合不同，这两棵生成树才被认为是不同的。）图中每对节点之间至多有一条边，且不得包含自环（即节点与自身相连的边）。\n\n保证对于下述范围内的每个 $K$，都至少存在一种满足条件的图。", "inputFormat": "输入的第一行包含一个整数 $T$，表示测试用例的数量。接下来有 $T$ 组测试用例，每组测试用例包含一行，内有一个整数 $K$，表示期望的生成树数量。\n", "outputFormat": "对于每个测试用例，首先输出一行 `Case #x: y`，其中 $x$ 表示测试用例编号（从 $1$ 开始），$y$ 表示你构造的图的节点数（$y$ 必须在 $2$ 到 $22$ 之间）。接下来输出 $y$ 行，每行 $y$ 个字符，表示该图的邻接矩阵。第 $i$ 行第 $j$ 列为 $1$，表示第 $i$ 个节点与第 $j$ 个节点之间有一条边；为 $0$，表示没有边。注意，该邻接矩阵是对称的，且主对角线上的元素均为 $0$。\n\n如果存在多种答案，你可以输出任意一种。保证对于下述范围内的每个 $K$，都至少存在一种合法解。\n", "hint": "**样例解释**\n\n在第 1 个用例中，图是一个三角形，去掉任意一条边都能得到一棵不同的生成树。\n\n在第 2 个用例中，解中的可用边为 $1-2$、$1-3$、$1-4$、$2-4$ 和 $3-4$。这 8 棵不同的生成树分别由如下边集定义：\n\n- $1-2$、$1-3$、$1-4$\n- $1-2$、$1-3$、$2-4$\n- $1-2$、$1-3$、$3-4$\n- $1-2$、$1-4$、$3-4$\n- $1-2$、$2-4$、$3-4$\n- $1-3$、$1-4$、$2-4$\n- $1-3$、$2-4$、$3-4$\n- $1-4$、$2-4$、$3-4$\n\n**限制条件**\n\n- $1 \\leqslant T \\leqslant 300$。\n\n**小数据集（30 分，测试集 1 - 可见）**\n\n- $3 \\leqslant K \\leqslant 10000$。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13182", "type": "P", "difficulty": 6, "samples": [["4\n3\n1 0 0\n0 1 0\n0 0 1\n8\n5 5 5\n5 -5 5\n-5 -5 5\n-5 5 5\n-5 5 -5\n-5 -5 -5\n5 -5 -5\n5 5 -5\n3\n1 0 0\n-1 1 0\n-1 -1 0\n5\n1 0 0\n-1 1 0\n2 0 0\n-2 2 0\n-1 -1 0", "Case #1: NO\nCase #2: YES\nCase #3: YES\nCase #4: YES"]], "limits": {"time": [15000, 75000], "memory": [1048576, 1048576]}, "tags": ["计算几何", "2017", "Google Code Jam"], "title": "[GCJ 2017 Finals] Omnicircumnavigation", "background": "", "description": "Intrepid globetrotter K, who may or may not be the author of this problem, has been traveling a lot lately. On one of her recent trips, she traveled from San Francisco to Frankfurt to Johannesburg to Abu Dhabi to Singapore to Tokyo and back to San Francisco. On this trip, she circumnavigated the Earth by traveling along a closed path that touches every meridian. In other words, for every possible longitude, there is at least one point along this path at that longitude.\n\nK is not sure that this trip qualifies as being super awesome, however, since it would also be possible to circumnavigate the Earth by flying to the North Pole and then walking around it, which does not seem to be particularly difficult (other than the part about flying to the North Pole). So she has decided to come up with a more generalized definition of circumnavigation. The new concept is called omn circumnavigation — a closed path around the Earth (which we assume to be a sphere) that is a circumnavigation regardless of where one places the poles. In other words, an omn icircumnavigation is a closed path on the surface of a sphere that touches every possible hemisphere. (Touching the edge of a hemisphere is sufficient.) Equivalently, an omnicircumnavigation intersects every possible great circle — a circle of greatest possible diameter on the surface of a sphere.\n\nYou are given a sequence of $\\mathbf{N}$ points on a sphere of radius $1$. You need to check whether a path connecting those points in order is an omn icircumnavigation. The path is formed by connecting each pair of successive points along the shortest possible surface route, and connecting the last point to the first one in the same way. No two successive points (including the pair of the last point and the first point) are collinear with the origin. (That is, they are not antipodes — polar opposites — and they do not represent the same point on the surface of the sphere.)", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line containing $\\mathbf{N}$, the number of cities visited by K. The next $\\mathbf{N}$ lines contain three integers $\\mathbf{X}_{\\mathbf{i}}, \\mathbf{Y}_{\\mathbf{i}}$ and $\\mathbf{Z}_{\\mathbf{i}}$ each. The $i$-th point in the list is given by the coordinates $\\left(\\mathbf{X}_{\\mathbf{i}} / \\operatorname{sqrt}\\left(\\mathbf{X}_{\\mathbf{i}}^{2}+\\mathbf{Y}_{\\mathbf{i}}^{2}+\\mathbf{Z}_{\\mathbf{i}}^{2}\\right), \\mathbf{Y}_{\\mathbf{i}} / \\operatorname{sqrt}\\left(\\mathbf{X}_{\\mathbf{i}}^{2}+\\mathbf{Y}_{\\mathbf{i}}^{2}+\\mathbf{Z}_{\\mathbf{i}}^{2}\\right), \\mathbf{Z}_{\\mathbf{i}} / \\operatorname{sqrt}\\left(\\mathbf{X}_{\\mathbf{i}}^{2}+\\mathbf{Y}_{\\mathbf{i}}^{2}+\\mathbf{Z}_{\\mathbf{i}}^{2}\\right)\\right)$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the case number and $y$ is either YES or NO depending on whether the route is an omnicircumnavigation or not.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the three points are the surface points of one octant of the sphere, and the path traces out that octant. There are many hemispheres that do not overlap that path at all.\n\nIn Sample Case #2, the eight points are the corners of a cube inscribed in the sphere; any hemisphere will contain at least some parts of that path. Note that dividing all values by 5 would produce an equivalent case (with the same set of points).\n\nIn Sample Case #3, the path is itself a great circle, and so every other great circle must intersect it somewhere.\n\nSample Case #4 uses the same three points as in Sample Case #3, except that the first two points are visited twice each. Note that a case may include multiple representations of the same point, and that a path may include the same points or connections more than once.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 200$.\n- $-10^{6} \\leqslant \\mathbf{X}_{\\mathbf{i}} \\leqslant 10^{6}$, for all $i$.\n- $-10^{6} \\leqslant \\mathbf{Y}_{\\mathbf{i}} \\leqslant 10^{6}$, for all $i$.\n- $-10^{6} \\leqslant \\mathbf{Z}_{\\mathbf{i}} \\leqslant 10^{6}$, for all $i$.\n- At least one of the values in $\\left(\\mathbf{X}_{\\mathbf{i}}, \\mathbf{Y}_{\\mathbf{i}}, \\mathbf{Z}_{\\mathbf{i}}\\right) \\neq 0$, for all i. For all i, j such that $(i+1=j)$ or $(i=\\mathbf{N}-1$ and $j=0)$, neither of $\\left(\\mathbf{X}_{\\mathbf{i}}, \\mathbf{Y}_{\\mathbf{i}}, \\mathbf{Z}_{\\mathbf{i}}\\right)$ and $\\left(\\mathbf{X}_{\\mathbf{j}}, \\mathbf{Y}_{\\mathbf{j}}, \\mathbf{Z}_{\\mathbf{j}}\\right)$ is an integer multiple of the other. (No two successive points, including the last and first, are antipodes or represent the same point on the sphere.)\n\n**Small dataset (Test Set 1 - Visible)**\n\n- Time limit: ~~60~~ 15 seconds.\n- $3 \\leqslant \\mathbf{N} \\leqslant 50$.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- Time limit: ~~300~~ 75 seconds.\n- $3 \\leqslant \\mathbf{N} \\leqslant 5000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 Finals] Omnicircumnavigation", "background": "", "description": "Intrepid globetrotter K, who may or may not be the author of this problem, has been traveling a lot lately. On one of her recent trips, she traveled from San Francisco to Frankfurt to Johannesburg to Abu Dhabi to Singapore to Tokyo and back to San Francisco. On this trip, she circumnavigated the Earth by traveling along a closed path that touches every meridian. In other words, for every possible longitude, there is at least one point along this path at that longitude.\n\nK is not sure that this trip qualifies as being super awesome, however, since it would also be possible to circumnavigate the Earth by flying to the North Pole and then walking around it, which does not seem to be particularly difficult (other than the part about flying to the North Pole). So she has decided to come up with a more generalized definition of circumnavigation. The new concept is called omn circumnavigation — a closed path around the Earth (which we assume to be a sphere) that is a circumnavigation regardless of where one places the poles. In other words, an omn icircumnavigation is a closed path on the surface of a sphere that touches every possible hemisphere. (Touching the edge of a hemisphere is sufficient.) Equivalently, an omnicircumnavigation intersects every possible great circle — a circle of greatest possible diameter on the surface of a sphere.\n\nYou are given a sequence of $\\mathbf{N}$ points on a sphere of radius $1$. You need to check whether a path connecting those points in order is an omn icircumnavigation. The path is formed by connecting each pair of successive points along the shortest possible surface route, and connecting the last point to the first one in the same way. No two successive points (including the pair of the last point and the first point) are collinear with the origin. (That is, they are not antipodes — polar opposites — and they do not represent the same point on the surface of the sphere.)", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line containing $\\mathbf{N}$, the number of cities visited by K. The next $\\mathbf{N}$ lines contain three integers $\\mathbf{X}_{\\mathbf{i}}, \\mathbf{Y}_{\\mathbf{i}}$ and $\\mathbf{Z}_{\\mathbf{i}}$ each. The $i$-th point in the list is given by the coordinates $\\left(\\mathbf{X}_{\\mathbf{i}} / \\operatorname{sqrt}\\left(\\mathbf{X}_{\\mathbf{i}}^{2}+\\mathbf{Y}_{\\mathbf{i}}^{2}+\\mathbf{Z}_{\\mathbf{i}}^{2}\\right), \\mathbf{Y}_{\\mathbf{i}} / \\operatorname{sqrt}\\left(\\mathbf{X}_{\\mathbf{i}}^{2}+\\mathbf{Y}_{\\mathbf{i}}^{2}+\\mathbf{Z}_{\\mathbf{i}}^{2}\\right), \\mathbf{Z}_{\\mathbf{i}} / \\operatorname{sqrt}\\left(\\mathbf{X}_{\\mathbf{i}}^{2}+\\mathbf{Y}_{\\mathbf{i}}^{2}+\\mathbf{Z}_{\\mathbf{i}}^{2}\\right)\\right)$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the case number and $y$ is either YES or NO depending on whether the route is an omnicircumnavigation or not.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the three points are the surface points of one octant of the sphere, and the path traces out that octant. There are many hemispheres that do not overlap that path at all.\n\nIn Sample Case #2, the eight points are the corners of a cube inscribed in the sphere; any hemisphere will contain at least some parts of that path. Note that dividing all values by 5 would produce an equivalent case (with the same set of points).\n\nIn Sample Case #3, the path is itself a great circle, and so every other great circle must intersect it somewhere.\n\nSample Case #4 uses the same three points as in Sample Case #3, except that the first two points are visited twice each. Note that a case may include multiple representations of the same point, and that a path may include the same points or connections more than once.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 200$.\n- $-10^{6} \\leqslant \\mathbf{X}_{\\mathbf{i}} \\leqslant 10^{6}$, for all $i$.\n- $-10^{6} \\leqslant \\mathbf{Y}_{\\mathbf{i}} \\leqslant 10^{6}$, for all $i$.\n- $-10^{6} \\leqslant \\mathbf{Z}_{\\mathbf{i}} \\leqslant 10^{6}$, for all $i$.\n- At least one of the values in $\\left(\\mathbf{X}_{\\mathbf{i}}, \\mathbf{Y}_{\\mathbf{i}}, \\mathbf{Z}_{\\mathbf{i}}\\right) \\neq 0$, for all i. For all i, j such that $(i+1=j)$ or $(i=\\mathbf{N}-1$ and $j=0)$, neither of $\\left(\\mathbf{X}_{\\mathbf{i}}, \\mathbf{Y}_{\\mathbf{i}}, \\mathbf{Z}_{\\mathbf{i}}\\right)$ and $\\left(\\mathbf{X}_{\\mathbf{j}}, \\mathbf{Y}_{\\mathbf{j}}, \\mathbf{Z}_{\\mathbf{j}}\\right)$ is an integer multiple of the other. (No two successive points, including the last and first, are antipodes or represent the same point on the sphere.)\n\n**Small dataset (Test Set 1 - Visible)**\n\n- Time limit: ~~60~~ 15 seconds.\n- $3 \\leqslant \\mathbf{N} \\leqslant 50$.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- Time limit: ~~300~~ 75 seconds.\n- $3 \\leqslant \\mathbf{N} \\leqslant 5000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 Finals] Omnicircumnavigation", "background": "", "description": "勇敢的环球旅行者 K（她也许就是本题的作者）最近频繁地旅行。在最近的一次旅途中，她从 San Francisco 出发，途经 Frankfurt、Johannesburg、Abu Dhabi、Singapore、Tokyo，最后又回到了 San Francisco。在这次旅行中，她沿着一条闭合路径环绕地球一周，并且这条路径经过了每一个子午线。换句话说，对于每一个可能的经度，这条路径上至少有一个点位于该经度。\n\n然而，K 并不确定这趟旅程是否真的称得上非常酷，因为实际上也可以通过飞到北极再围着北极走一圈来环绕地球，这似乎也并不特别困难（当然飞到北极本身除外）。于是她决定提出一个更广义的“环绕地球”的定义。这个新概念被称为 **omn icircumnavigation** —— 即无论如何放置地球的两极，这条闭合路径都能称为一次环绕地球。换句话说，**omn icircumnavigation** 是指地球表面上的一条闭合路径，它会经过每一个可能的半球。（只要碰到半球的边界也算经过。）等价地说，**omn icircumnavigation** 会与每一个可能的大圆（即球面上直径最大的圆）相交。\n\n现在给定球面上半径为 $1$ 的球上的一系列 $N$ 个点。你需要判断，依次连接这些点所形成的路径是否为一次 **omnicircumnavigation**。路径的构造方式是：依次将每对相邻点沿球面最短路径连接起来，并将最后一个点与第一个点也以同样方式连接。任意一对相邻点（包括最后一个点与第一个点）都不会与原点共线。（也就是说，它们不是对踵点——即球面上的正反两点——也不代表球面上的同一个点。）", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例的数量。接下来有 $\\mathbf{T}$ 组测试用例。每组测试用例的第一行为一个整数 $\\mathbf{N}$，表示 K 访问的城市数量。接下来的 $\\mathbf{N}$ 行，每行包含三个整数 $\\mathbf{X}_{\\mathbf{i}}, \\mathbf{Y}_{\\mathbf{i}}, \\mathbf{Z}_{\\mathbf{i}}$。列表中的第 $i$ 个点的坐标为 $\\left(\\mathbf{X}_{\\mathbf{i}} / \\operatorname{sqrt}\\left(\\mathbf{X}_{\\mathbf{i}}^{2}+\\mathbf{Y}_{\\mathbf{i}}^{2}+\\mathbf{Z}_{\\mathbf{i}}^{2}\\right),\\ \\mathbf{Y}_{\\mathbf{i}} / \\operatorname{sqrt}\\left(\\mathbf{X}_{\\mathbf{i}}^{2}+\\mathbf{Y}_{\\mathbf{i}}^{2}+\\mathbf{Z}_{\\mathbf{i}}^{2}\\right),\\ \\mathbf{Z}_{\\mathbf{i}} / \\operatorname{sqrt}\\left(\\mathbf{X}_{\\mathbf{i}}^{2}+\\mathbf{Y}_{\\mathbf{i}}^{2}+\\mathbf{Z}_{\\mathbf{i}}^{2}\\right)\\right)$。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 为测试用例编号，$y$ 为 `YES` 或 `NO`，表示该路径是否为一次 **omnicircumnavigation**。\n", "hint": "**样例解释**\n\n在样例第 1 组中，这三个点分别位于球面上同一个卦限的表面，路径刚好围成了这个卦限。实际上，有许多半球完全不与这条路径相交。\n\n在样例第 2 组中，这八个点是内切于球体的立方体的八个顶点；无论如何选取半球，至少都会与路径的某些部分相交。注意，如果将所有坐标除以 $5$，得到的情况是等价的（点的集合相同）。\n\n在样例第 3 组中，这条路径本身就是一个大圆，因此任意其他大圆都必定会与其有交点。\n\n样例第 4 组使用了与样例第 3 组相同的三个点，只是前两个点各出现了两次。注意，一个测试用例中可以多次出现同一个点，同一条路径也可以多次经过同一个点或连接。\n\n**限制条件**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 200$。\n- 对所有 $i$，$-10^{6} \\leqslant \\mathbf{X}_{\\mathbf{i}} \\leqslant 10^{6}$。\n- 对所有 $i$，$-10^{6} \\leqslant \\mathbf{Y}_{\\mathbf{i}} \\leqslant 10^{6}$。\n- 对所有 $i$，$-10^{6} \\leqslant \\mathbf{Z}_{\\mathbf{i}} \\leqslant 10^{6}$。\n- 对所有 $i$，$\\left(\\mathbf{X}_{\\mathbf{i}}, \\mathbf{Y}_{\\mathbf{i}}, \\mathbf{Z}_{\\mathbf{i}}\\right)$ 至少有一个值不为 $0$。对于所有 $i, j$ 满足 $(i+1 = j)$ 或 $(i = \\mathbf{N}-1$ 且 $j = 0)$，$\\left(\\mathbf{X}_{\\mathbf{i}}, \\mathbf{Y}_{\\mathbf{i}}, \\mathbf{Z}_{\\mathbf{i}}\\right)$ 和 $\\left(\\mathbf{X}_{\\mathbf{j}}, \\mathbf{Y}_{\\mathbf{j}}, \\mathbf{Z}_{\\mathbf{j}}\\right)$ 互不为整数倍关系。（任意一对相邻点，包括最后一个点和第一个点，都不是对踵点或球面上的同一个点。）\n\n**小数据集（测试集 1 - 可见）**\n\n- 时间限制：~~60~~ 15 秒。\n- $3 \\leqslant \\mathbf{N} \\leqslant 50$。\n\n**大数据集（测试集 2 - 隐藏）**\n\n- 时间限制：~~300~~ 75 秒。\n- $3 \\leqslant \\mathbf{N} \\leqslant 5000$。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13183", "type": "P", "difficulty": 7, "samples": [["5\n2 7 2 7 1\n2 6 4 7 4\n2 3 2 6 2\n2 4 2 10 2\n2 5 4 7 3\n2\n2 2\n0 2\n3 2\n4 1 3", "Case #1: POSSIBLE\nCase #2: IMPOSSIBLE"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["图论", "2017", "深度优先搜索 DFS", "图论建模", "Google Code Jam"], "title": "[GCJ 2017 Finals] Stack Management", "background": "", "description": "You are playing a solitaire game in which there are $\\mathbf{N}$ stacks of face-up cards, each of which initially has $\\mathbf{C}$ cards. Each card has a value and a suit, and no two cards in the game have the same value/suit combination.\n\nIn one move, you can do one of the following things:\n\n1. If there are two or more cards with the same suit that are on top of different stacks, you may remove the one of those cards with the smallest value from the game. (Whenever you remove the last card from a stack, the stack is still there — it just becomes empty.)\n2. If there is an empty stack, you may take a card from the top of any one of the non-empty stacks and place it on top of (i.e., as the only card in) that empty stack.\n\nYou win the game if you can make a sequence of moves such that eventually, each stack contains at most one card. Given a starting arrangement, determine whether it is possible to win the game.", "inputFormat": "The first line of the input gives the number $\\mathbf{P}$ of premade stacks that will be used in the test cases. Then, $\\mathbf{P}$ lines follow. The i-th of those lines begins with an integer $\\mathbf{C}_{\\mathbf{i}}$, the number of cards in the i-th of those premade stacks, and continues with $\\mathbf{C}_{\\mathbf{i}}$ ordered pairs of integers. The j-th of these ordered pairs has two integers $\\mathbf{V}_{\\mathbf{i j}}$ and $\\mathbf{S}_{\\mathbf{i j}}$, representing the value and suit of the j-th card from the top in the i-th premade stack.\n\nThen, there is another line with one integer $\\mathbf{T}$, the number of test cases. $\\mathbf{T}$ test cases follow. Each case begins with one line with two integers $\\mathbf{N}$ and $\\mathbf{C}$: the number of stacks, and the number of cards in each of those stacks. Then, there is one line with $\\mathbf{N}$ integers $\\mathbf{P}_{\\mathbf{i}}$, representing the indexes (starting from 0) of the test case's set of premade stacks.\n", "outputFormat": "For each test case, output one line containing Case #x: y, where $x$ is the test case number (starting from 1) and $y$ is POSSIBLE if it is possible to win the game, or IMPOSSIBLE otherwise.", "hint": "**Sample Explanation**\n\nIn sample case #1, there are two stacks, each of which has two cards. The first stack has a 7 of suit 2 on top and a 7 of suit 1 below that. The second stack has a 3 of suit 2 on top and a 6 of suit 2 below that.\n\nIt is possible to win the game as follows:\n\n* Remove the 3 of suit 2 from the second stack.\n* Remove the 6 of suit 2 from the second stack. This makes the second stack empty.\n* Move the 7 of suit 2 to the second stack. Then the win condition is satisfied: all stacks have at most one card.\n\nIn sample case #2, there are three stacks, each of which has two cards. It is not possible to win the game in this case; the only possible move is to remove the 5 of suit 4 on top of the third stack, and this does not open up any new moves.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $2 \\leq P \\leq 60000$.\n- $0 \\leq P_i < P$, for all $i$.\n- The $P_i$-th premade stack has exactly $C$ cards.\n- No two cards in a test case have the same value/suit combination.\n\n**Small dataset (10 Pts, Test Set 1 - Visible)**\n\n- $2 \\leq N \\leq 4$.\n- $2 \\leq C_i \\leq 13$, for all $i$.\n- $2 \\leq C \\leq 13$.\n- $1 \\leq V_{ij} \\leq 13$, for all $i$ and $j$.\n- $1 \\leq S_{ij} \\leq 4$, for all $i$ and $j$.\n\n**Large dataset (30 Pts, Test Set 2 - Hidden)**\n\n- $2 \\leq N \\leq 50000$.\n- $2 \\leq C_i \\leq 50000$, for all $i$.\n- $2 \\leq C \\leq 50000$.\n- $4 \\leq N \\times C \\leq 10^5$.\n- $1 \\leq V_{ij} \\leq 50000$, for all $i$ and $j$.\n- $1 \\leq S_{ij} \\leq 50000$, for all $i$ and $j$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 Finals] Stack Management", "background": "", "description": "You are playing a solitaire game in which there are $\\mathbf{N}$ stacks of face-up cards, each of which initially has $\\mathbf{C}$ cards. Each card has a value and a suit, and no two cards in the game have the same value/suit combination.\n\nIn one move, you can do one of the following things:\n\n1. If there are two or more cards with the same suit that are on top of different stacks, you may remove the one of those cards with the smallest value from the game. (Whenever you remove the last card from a stack, the stack is still there — it just becomes empty.)\n2. If there is an empty stack, you may take a card from the top of any one of the non-empty stacks and place it on top of (i.e., as the only card in) that empty stack.\n\nYou win the game if you can make a sequence of moves such that eventually, each stack contains at most one card. Given a starting arrangement, determine whether it is possible to win the game.", "inputFormat": "The first line of the input gives the number $\\mathbf{P}$ of premade stacks that will be used in the test cases. Then, $\\mathbf{P}$ lines follow. The i-th of those lines begins with an integer $\\mathbf{C}_{\\mathbf{i}}$, the number of cards in the i-th of those premade stacks, and continues with $\\mathbf{C}_{\\mathbf{i}}$ ordered pairs of integers. The j-th of these ordered pairs has two integers $\\mathbf{V}_{\\mathbf{i j}}$ and $\\mathbf{S}_{\\mathbf{i j}}$, representing the value and suit of the j-th card from the top in the i-th premade stack.\n\nThen, there is another line with one integer $\\mathbf{T}$, the number of test cases. $\\mathbf{T}$ test cases follow. Each case begins with one line with two integers $\\mathbf{N}$ and $\\mathbf{C}$: the number of stacks, and the number of cards in each of those stacks. Then, there is one line with $\\mathbf{N}$ integers $\\mathbf{P}_{\\mathbf{i}}$, representing the indexes (starting from 0) of the test case's set of premade stacks.\n", "outputFormat": "For each test case, output one line containing Case #x: y, where $x$ is the test case number (starting from 1) and $y$ is POSSIBLE if it is possible to win the game, or IMPOSSIBLE otherwise.", "hint": "**Sample Explanation**\n\nIn sample case #1, there are two stacks, each of which has two cards. The first stack has a 7 of suit 2 on top and a 7 of suit 1 below that. The second stack has a 3 of suit 2 on top and a 6 of suit 2 below that.\n\nIt is possible to win the game as follows:\n\n* Remove the 3 of suit 2 from the second stack.\n* Remove the 6 of suit 2 from the second stack. This makes the second stack empty.\n* Move the 7 of suit 2 to the second stack. Then the win condition is satisfied: all stacks have at most one card.\n\nIn sample case #2, there are three stacks, each of which has two cards. It is not possible to win the game in this case; the only possible move is to remove the 5 of suit 4 on top of the third stack, and this does not open up any new moves.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $2 \\leq P \\leq 60000$.\n- $0 \\leq P_i < P$, for all $i$.\n- The $P_i$-th premade stack has exactly $C$ cards.\n- No two cards in a test case have the same value/suit combination.\n\n**Small dataset (10 Pts, Test Set 1 - Visible)**\n\n- $2 \\leq N \\leq 4$.\n- $2 \\leq C_i \\leq 13$, for all $i$.\n- $2 \\leq C \\leq 13$.\n- $1 \\leq V_{ij} \\leq 13$, for all $i$ and $j$.\n- $1 \\leq S_{ij} \\leq 4$, for all $i$ and $j$.\n\n**Large dataset (30 Pts, Test Set 2 - Hidden)**\n\n- $2 \\leq N \\leq 50000$.\n- $2 \\leq C_i \\leq 50000$, for all $i$.\n- $2 \\leq C \\leq 50000$.\n- $4 \\leq N \\times C \\leq 10^5$.\n- $1 \\leq V_{ij} \\leq 50000$, for all $i$ and $j$.\n- $1 \\leq S_{ij} \\leq 50000$, for all $i$ and $j$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 Finals] Stack Management", "background": "", "description": "你正在玩一个单人纸牌游戏，桌面上有 $\\mathbf{N}$ 堆明面朝上的牌，第 $i$ 堆起始时有 $\\mathbf{C_i}$ 张牌。每张牌都有一个点数和值，以及一个花色，并且游戏中不存在两张点数与花色组合完全相同的牌。\n\n每一步，你可以进行以下两种操作之一：\n\n1. 如果有两张或更多花色相同的牌，且它们分别位于不同的牌堆顶端，你可以从这些牌中移除点数最小的那一张离开游戏。（当你移除某堆的最后一张牌时，该堆仍然存在，只是变为空堆。）\n2. 如果有空堆，你可以从任意一个非空堆顶取一张牌，放到任意一个空堆上（即此时该空堆变为只含这一张牌）。\n\n如果你能够通过一系列操作，最终使得每一堆牌最多只剩下一张牌，则你赢得了游戏。给定初始的牌堆排列，判断是否有可能赢得游戏。\n", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{P}$，表示起始牌堆的数量。接下来有 $\\mathbf{P}$ 行，每行描述一个起始牌堆。第 $i$ 行以一个整数 $\\mathbf{C}_i$ 开头，表示第 $i$ 个起始牌堆中的牌数，随后是 $\\mathbf{C}_i$ 个有序整数对。第 $j$ 个有序对为两个整数 $\\mathbf{V}_{ij}$ 和 $\\mathbf{S}_{ij}$，分别表示该堆自顶向下第 $j$ 张牌的点数和值与花色。\n\n接下来一行包含一个整数 $\\mathbf{T}$，表示测试用例数量。接下来有 $\\mathbf{T}$ 组测试用例。每组测试用例的第一行为两个整数 $\\mathbf{N}$ 和 $\\mathbf{C}$，分别表示牌堆数量和每堆的牌数。随后一行有 $\\mathbf{N}$ 个整数 $\\mathbf{P}_i$，表示该测试用例所选用的起始牌堆编号（从 $0$ 开始计数）。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 表示测试用例编号（从 $1$ 开始），$y$ 为 `POSSIBLE` 表示可以赢得游戏，或 `IMPOSSIBLE` 表示不可能赢得游戏。\n", "hint": "**样例解释**\n\n在样例第 1 组中，有两堆，每堆两张牌。第一堆顶端是点数为 $7$、花色为 $2$ 的牌，下方是点数为 $7$、花色为 $1$ 的牌。第二堆顶端是点数为 $3$、花色为 $2$ 的牌，下方是点数为 $6$、花色为 $2$ 的牌。\n\n可以按如下方式赢得游戏：\n\n- 移除第二堆顶端的 $3$（花色 $2$）。\n- 移除第二堆顶端的 $6$（花色 $2$）。此时第二堆为空。\n- 将第一堆顶端的 $7$（花色 $2$）移动到第二堆。此时每堆最多只剩一张牌，达到胜利条件。\n\n在样例第 2 组中，有三堆，每堆两张牌。在这种情况下无法赢得游戏；唯一的可行操作是移除第三堆顶端的 $5$（花色 $4$），但这并不会带来新的可行操作。\n\n**限制条件**\n\n- $1 \\leq T \\leq 100$。\n- $2 \\leq P \\leq 60000$。\n- 对所有 $i$，$0 \\leq P_i < P$。\n- 第 $P_i$ 个起始牌堆恰好有 $C$ 张牌。\n- 每个测试用例中不存在两张牌点数与花色组合完全相同的情况。\n\n**小数据集（10 分，测试集 1 - 可见）**\n\n- $2 \\leq N \\leq 4$。\n- 对所有 $i$，$2 \\leq C_i \\leq 13$。\n- $2 \\leq C \\leq 13$。\n- 对所有 $i, j$，$1 \\leq V_{ij} \\leq 13$。\n- 对所有 $i, j$，$1 \\leq S_{ij} \\leq 4$。\n\n**大数据集（30 分，测试集 2 - 隐藏）**\n\n- $2 \\leq N \\leq 50000$。\n- 对所有 $i$，$2 \\leq C_i \\leq 50000$。\n- $2 \\leq C \\leq 50000$。\n- $4 \\leq N \\times C \\leq 10^5$。\n- 对所有 $i, j$，$1 \\leq V_{ij} \\leq 50000$。\n- 对所有 $i, j$，$1 \\leq S_{ij} \\leq 50000$。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13184", "type": "P", "difficulty": 7, "samples": [["3\n1\n0 0 0\n0 4 0\n0 3 0\n2\n0 0 1\n0 0 11\n0 0 3\n0 0 0\n3\n0 0 0\n6 2 0\n6 0 0\n3 0 0\n6 1 0", "Case #1: IMPOSSIBLE\nCase #2: 3\nCase #3: 2"]], "limits": {"time": [45000, 90000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "图论", "2017", "矩阵加速", "Google Code Jam"], "title": "[GCJ 2017 Finals] Teleporters", "background": "", "description": "A short, short time into the future, in a nearby galaxy, you find yourself wanting to take a little trip and get away from the responsibilities of being Planet Thundera's only manufacturer of yarn. You decide to travel to Planet Care-a-Lot, the most relaxing planet there is. To travel, you are going to use the network of interstellar teleporters.\n\nA teleporter is a small machine floating around somewhere in space. You can use it remotely from any point in space, but, due to the conservation of teleportation distance principle, it can teleport you to any other point in space at exactly the same L1 distance from the teleporter as your L1 distance to it before the teleportation. The L1 distance between two points at coordinates $(x_0, y_0, z_0)$ and $(x_1, y_1, z_1)$ is given by $|x_0 - x_1| + |y_0 - y_1| + |z_0 - z_1|$. Unfortunately, your space jetpack is broken, so you cannot move around on your own; to travel, you can only use the teleporters. You start at Planet Thundera. You can use a teleporter to travel from Planet Thundera to a point $p_1$, then use another to get from $p_1$ to $p_2$, and so on. The last teleportation must take you exactly to Planet Care-a-Lot.\n\nGiven the locations in 3-dimensional space of both planets and all the available teleporters, find out if it is possible for you to make the trip using only teleporters. If the trip can be made, what is the minimum number of teleportations needed to get to your destination? (Even if two teleportations use the same teleporter, they still count as separate teleportations.)\n\nThe input is given as points with coordinates that are all integers that fall within a certain range. However, you are allowed to teleport to intermediate points with integer or non-integer coordinates, and there are no range restrictions on the points you can visit.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a single line with a single integer $\\mathbf{N}$, the number of teleporters available. Then, $\\mathbf{N}+2$ lines follow, each containing three integers $\\mathbf{X_i}$, $\\mathbf{Y_i}$, and $\\mathbf{Z_i}$. The first of these lines represents the coordinates of your home planet, Thundera. The second of these lines represents the coordinates of your destination planet, Care-A-Lot. Each of the remaining $\\mathbf{N}$ lines represents the coordinates of one of the teleporters.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is IMPOSSIBLE if it is not possible to get from Thundera to Care-A-Lot using only the available teleporters, or, if it is possible, an integer representing the minimum number of teleportations needed.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the only teleporter is exactly 3 units away from Thundera, and we can only use it to go to another position that is exactly 3 units away from the teleporter. From that position, we can still only reach other positions that are exactly 3 units away from the teleporter. Since Care-a-Lot is 1 unit away from the teleporter, we can never reach it.\n\nIn Sample Case #2, the optimal strategy is to first use the teleporter at $(0, 0, 3)$ to travel to $(0, 0, 5)$. Then, from there, use the teleporter at $(0, 0, 0)$ to travel to $(0, 0, -5)$. Finally, from there, use the teleporter at $(0, 0, 3)$ again to travel to $(0, 0, 11)$. Note that the two uses of the teleporter at $(0, 0, 3)$ cause us to travel different distances, because we are at different distances from the teleporter each time. Also note that the two uses of that teleporter count as two separate teleportations.\n\nIn Sample Case #3, the optimal strategy is to first use the teleporter at $(3, 0, 0)$ to travel to $(6, 0, 0)$. Then, from there, use the teleporter at $(6, 1, 0)$ to travel to $(6, 2, 0)$. Note that even though there was a teleporter at $(6, 0, 0)$, merely occupying the same point as a teleporter does not count as using it.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $(X_i, Y_i, Z_i) \\neq (X_j, Y_j, Z_j)$ for all $i \\neq j$. (No two described objects have the same coordinates.)\n\n**Small dataset (Test Set 1 - Visible)**\n\n- Time limit: ~~180~~ 45 seconds.\n- $1 \\leq N \\leq 100$.\n- $-10^3 \\leq X_i \\leq 10^3$, for all $i$.\n- $-10^3 \\leq Y_i \\leq 10^3$, for all $i$.\n- $-10^3 \\leq Z_i \\leq 10^3$, for all $i$.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- Time limit: ~~360~~ 90 seconds.\n- $1 \\leq N \\leq 150$.\n- $-10^{12} \\leq X_i \\leq 10^{12}$, for all $i$.\n- $-10^{12} \\leq Y_i \\leq 10^{12}$, for all $i$.\n- $-10^{12} \\leq Z_i \\leq 10^{12}$, for all $i$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 Finals] Teleporters", "background": "", "description": "A short, short time into the future, in a nearby galaxy, you find yourself wanting to take a little trip and get away from the responsibilities of being Planet Thundera's only manufacturer of yarn. You decide to travel to Planet Care-a-Lot, the most relaxing planet there is. To travel, you are going to use the network of interstellar teleporters.\n\nA teleporter is a small machine floating around somewhere in space. You can use it remotely from any point in space, but, due to the conservation of teleportation distance principle, it can teleport you to any other point in space at exactly the same L1 distance from the teleporter as your L1 distance to it before the teleportation. The L1 distance between two points at coordinates $(x_0, y_0, z_0)$ and $(x_1, y_1, z_1)$ is given by $|x_0 - x_1| + |y_0 - y_1| + |z_0 - z_1|$. Unfortunately, your space jetpack is broken, so you cannot move around on your own; to travel, you can only use the teleporters. You start at Planet Thundera. You can use a teleporter to travel from Planet Thundera to a point $p_1$, then use another to get from $p_1$ to $p_2$, and so on. The last teleportation must take you exactly to Planet Care-a-Lot.\n\nGiven the locations in 3-dimensional space of both planets and all the available teleporters, find out if it is possible for you to make the trip using only teleporters. If the trip can be made, what is the minimum number of teleportations needed to get to your destination? (Even if two teleportations use the same teleporter, they still count as separate teleportations.)\n\nThe input is given as points with coordinates that are all integers that fall within a certain range. However, you are allowed to teleport to intermediate points with integer or non-integer coordinates, and there are no range restrictions on the points you can visit.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a single line with a single integer $\\mathbf{N}$, the number of teleporters available. Then, $\\mathbf{N}+2$ lines follow, each containing three integers $\\mathbf{X_i}$, $\\mathbf{Y_i}$, and $\\mathbf{Z_i}$. The first of these lines represents the coordinates of your home planet, Thundera. The second of these lines represents the coordinates of your destination planet, Care-A-Lot. Each of the remaining $\\mathbf{N}$ lines represents the coordinates of one of the teleporters.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is IMPOSSIBLE if it is not possible to get from Thundera to Care-A-Lot using only the available teleporters, or, if it is possible, an integer representing the minimum number of teleportations needed.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the only teleporter is exactly 3 units away from Thundera, and we can only use it to go to another position that is exactly 3 units away from the teleporter. From that position, we can still only reach other positions that are exactly 3 units away from the teleporter. Since Care-a-Lot is 1 unit away from the teleporter, we can never reach it.\n\nIn Sample Case #2, the optimal strategy is to first use the teleporter at $(0, 0, 3)$ to travel to $(0, 0, 5)$. Then, from there, use the teleporter at $(0, 0, 0)$ to travel to $(0, 0, -5)$. Finally, from there, use the teleporter at $(0, 0, 3)$ again to travel to $(0, 0, 11)$. Note that the two uses of the teleporter at $(0, 0, 3)$ cause us to travel different distances, because we are at different distances from the teleporter each time. Also note that the two uses of that teleporter count as two separate teleportations.\n\nIn Sample Case #3, the optimal strategy is to first use the teleporter at $(3, 0, 0)$ to travel to $(6, 0, 0)$. Then, from there, use the teleporter at $(6, 1, 0)$ to travel to $(6, 2, 0)$. Note that even though there was a teleporter at $(6, 0, 0)$, merely occupying the same point as a teleporter does not count as using it.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $(X_i, Y_i, Z_i) \\neq (X_j, Y_j, Z_j)$ for all $i \\neq j$. (No two described objects have the same coordinates.)\n\n**Small dataset (Test Set 1 - Visible)**\n\n- Time limit: ~~180~~ 45 seconds.\n- $1 \\leq N \\leq 100$.\n- $-10^3 \\leq X_i \\leq 10^3$, for all $i$.\n- $-10^3 \\leq Y_i \\leq 10^3$, for all $i$.\n- $-10^3 \\leq Z_i \\leq 10^3$, for all $i$.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- Time limit: ~~360~~ 90 seconds.\n- $1 \\leq N \\leq 150$.\n- $-10^{12} \\leq X_i \\leq 10^{12}$, for all $i$.\n- $-10^{12} \\leq Y_i \\leq 10^{12}$, for all $i$.\n- $-10^{12} \\leq Z_i \\leq 10^{12}$, for all $i$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 Finals] Teleporters", "background": "", "description": "在不远的将来，位于附近星系的你，想要暂时远离作为 Thundera 星唯一纱线制造商的责任，打算去最让人放松的星球 Care-a-Lot 旅行。为此，你将使用星际传送器网络进行旅行。\n\n传送器是一台漂浮在太空中的小型机器。你可以在太空中的任意位置远程使用它，但由于“传送距离守恒原理”，它只能将你传送到距离该传送器 L1 距离与传送前你到该传送器的 L1 距离完全相同的另一个空间点。两个坐标为 $(x_0, y_0, z_0)$ 和 $(x_1, y_1, z_1)$ 的点之间的 L1 距离定义为 $|x_0 - x_1| + |y_0 - y_1| + |z_0 - z_1|$。不幸的是，你的太空喷气背包坏了，无法靠自身在太空中移动；你只能依靠传送器旅行。你从 Thundera 星出发，可以通过传送器从 Thundera 星传送到某点 $p_1$，再用另一个传送器从 $p_1$ 传送到 $p_2$，以此类推。最后一次传送必须恰好到达 Care-a-Lot 星。\n\n现给定两颗星球及所有可用传送器在三维空间中的坐标，问你是否能仅靠传送器完成这次旅行。如果可以，最少需要多少次传送？（即使两次传送用的是同一个传送器，也要算作两次传送。）\n\n输入给出的所有点坐标均为整数，且在一定范围内。但你可以被传送到中间的任意点（坐标可以是整数也可以是非整数），且你能到达的点的坐标没有范围限制。\n", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例的数量。接下来有 $\\mathbf{T}$ 组测试用例。每组测试用例的第一行为一个整数 $\\mathbf{N}$，表示可用传送器的数量。随后有 $\\mathbf{N}+2$ 行，每行三个整数 $\\mathbf{X_i}$、$\\mathbf{Y_i}$ 和 $\\mathbf{Z_i}$。第一行为你的家园 Thundera 星的坐标，第二行为目的地 Care-a-Lot 星的坐标，剩下的 $\\mathbf{N}$ 行每行表示一个传送器的坐标。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 表示测试用例编号（从 $1$ 开始），$y$ 若无法仅靠传送器从 Thundera 到达 Care-a-Lot，则输出 `IMPOSSIBLE`，否则输出一个整数，表示到达目的地所需的最少传送次数。\n", "hint": "**样例解释**\n\n在样例第 1 组中，唯一的传送器距离 Thundera 星恰好为 $3$，你只能被传送到距离该传送器恰好 $3$ 的其他点。从这些点出发，仍然只能到达距离传送器恰好 $3$ 的点。而 Care-a-Lot 星距离该传送器为 $1$，因此永远无法到达。\n\n在样例第 2 组中，最优策略是：首先用 $(0, 0, 3)$ 号传送器传送到 $(0, 0, 5)$，再用 $(0, 0, 0)$ 号传送器传送到 $(0, 0, -5)$，最后再次用 $(0, 0, 3)$ 号传送器传送到 $(0, 0, 11)$。注意，两次使用 $(0, 0, 3)$ 号传送器时实际传送的距离不同，因为两次出发点距离该传送器不同。另外，这两次操作都要计入传送次数。\n\n在样例第 3 组中，最优策略是：先用 $(3, 0, 0)$ 号传送器传送到 $(6, 0, 0)$，再用 $(6, 1, 0)$ 号传送器传送到 $(6, 2, 0)$。注意，虽然 $(6, 0, 0)$ 处也有一个传送器，但仅仅到达该点并不算使用了这个传送器。\n\n**限制条件**\n\n- $1 \\leq T \\leq 100$。\n- 对所有 $i \\neq j$，$(X_i, Y_i, Z_i) \\neq (X_j, Y_j, Z_j)$（任意两个对象的坐标都不相同）。\n\n**小数据集（测试集 1 - 可见）**\n\n- 时间限制：~~180~~ 45 秒。\n- $1 \\leq N \\leq 100$。\n- 对所有 $i$，$-10^3 \\leq X_i \\leq 10^3$。\n- 对所有 $i$，$-10^3 \\leq Y_i \\leq 10^3$。\n- 对所有 $i$，$-10^3 \\leq Z_i \\leq 10^3$。\n\n**大数据集（测试集 2 - 隐藏）**\n\n- 时间限制：~~360~~ 90 秒。\n- $1 \\leq N \\leq 150$。\n- 对所有 $i$，$-10^{12} \\leq X_i \\leq 10^{12}$。\n- 对所有 $i$，$-10^{12} \\leq Y_i \\leq 10^{12}$。\n- 对所有 $i$，$-10^{12} \\leq Z_i \\leq 10^{12}$。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13185", "type": "P", "difficulty": 2, "samples": [["5\n0\n1\n2\n11\n1692", "Case #1: INSOMNIA\nCase #2: 10\nCase #3: 90\nCase #4: 110\nCase #5: 5076"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["模拟", "2016", "Google Code Jam"], "title": "[GCJ 2016 Qualification] Counting Sheep", "background": "", "description": "Bleatrix Trotter the sheep has devised a strategy that helps her fall asleep faster. First, she picks a number $\\mathrm{N}$. Then she starts naming $\\mathrm{N}, 2 \\times \\mathrm{N}, 3 \\times \\mathrm{N}$, and so on. Whenever she names a number, she thinks about all of the digits in that number. She keeps track of which digits $(0,1,2,3,4,5,6,7,8$, and 9$)$ she has seen at least once so far as part of any number she has named. Once she has seen each of the ten digits at least once, she will fall asleep.\n\nBleatrix must start with $\\mathrm{N}$ and must always name $(i+1) \\times \\mathrm{N}$ directly after $i \\times \\mathrm{N}$. For example, suppose that Bleatrix picks $\\mathrm{N}=1692$. She would count as follows:\n\n- $\\mathrm{N}=1692$. Now she has seen the digits $1,2,6$, and $9$.\n- $2 \\mathrm{N}=3384$. Now she has seen the digits $1,2,3,4,6,8$, and $9$.\n- $3 \\mathrm{N}=5076$. Now she has seen all ten digits, and falls asleep.\n\nWhat is the last number that she will name before falling asleep? If she will count forever, print INSOMNIA instead.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. Each consists of one line with a single integer $\\mathrm{N}$, the number Bleatrix has chosen.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the last number that Bleatrix will name before falling asleep, according to the rules described in the statement.", "hint": "**Sample Explanation**\n\nIn Case #1, since $2 \\times 0=0,3 \\times 0=0$, and so on, Bleatrix will never see any digit other than $0$, and so she will count forever and never fall asleep. Poor sheep!\n\nIn Case #2, Bleatrix will name $1,2,3,4,5,6,7,8,9,10$. The $0$ will be the last digit needed, and so she will fall asleep after $10$.\n\nIn Case #3, Bleatrix will name $2,4,6 \\ldots$ and so on. She will not see the digit 9 in any number until $90$, at which point she will fall asleep. By that point, she will have already seen the digits $0,1,2,3,4,5$, $6,7$, and $8$, which will have appeared for the first time in the numbers $10,10,2,30,4,50,6,70$, and $8$, respectively.\n\nIn Case #4, Bleatrix will name $11,22,33,44,55,66,77,88,99,110$ and then fall asleep.\n\nCase #5 is the one described in the problem statement. Note that it would only show up in the Large dataset, and not in the Small dataset.\n\n**Limits**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$.\n\n**Small dataset (7 Pts, Test Set 1 - Visible)**\n\n- $0 \\leqslant \\mathrm{N} \\leqslant 200$.\n\n**Large dataset (8 Pts, Test Set 2 - Hidden)**\n\n- $0 \\leqslant \\mathrm{N} \\leqslant 10^{6}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2016 Qualification] Counting Sheep", "background": "", "description": "Bleatrix Trotter the sheep has devised a strategy that helps her fall asleep faster. First, she picks a number $\\mathrm{N}$. Then she starts naming $\\mathrm{N}, 2 \\times \\mathrm{N}, 3 \\times \\mathrm{N}$, and so on. Whenever she names a number, she thinks about all of the digits in that number. She keeps track of which digits $(0,1,2,3,4,5,6,7,8$, and 9$)$ she has seen at least once so far as part of any number she has named. Once she has seen each of the ten digits at least once, she will fall asleep.\n\nBleatrix must start with $\\mathrm{N}$ and must always name $(i+1) \\times \\mathrm{N}$ directly after $i \\times \\mathrm{N}$. For example, suppose that Bleatrix picks $\\mathrm{N}=1692$. She would count as follows:\n\n- $\\mathrm{N}=1692$. Now she has seen the digits $1,2,6$, and $9$.\n- $2 \\mathrm{N}=3384$. Now she has seen the digits $1,2,3,4,6,8$, and $9$.\n- $3 \\mathrm{N}=5076$. Now she has seen all ten digits, and falls asleep.\n\nWhat is the last number that she will name before falling asleep? If she will count forever, print INSOMNIA instead.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. Each consists of one line with a single integer $\\mathrm{N}$, the number Bleatrix has chosen.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the last number that Bleatrix will name before falling asleep, according to the rules described in the statement.", "hint": "**Sample Explanation**\n\nIn Case #1, since $2 \\times 0=0,3 \\times 0=0$, and so on, Bleatrix will never see any digit other than $0$, and so she will count forever and never fall asleep. Poor sheep!\n\nIn Case #2, Bleatrix will name $1,2,3,4,5,6,7,8,9,10$. The $0$ will be the last digit needed, and so she will fall asleep after $10$.\n\nIn Case #3, Bleatrix will name $2,4,6 \\ldots$ and so on. She will not see the digit 9 in any number until $90$, at which point she will fall asleep. By that point, she will have already seen the digits $0,1,2,3,4,5$, $6,7$, and $8$, which will have appeared for the first time in the numbers $10,10,2,30,4,50,6,70$, and $8$, respectively.\n\nIn Case #4, Bleatrix will name $11,22,33,44,55,66,77,88,99,110$ and then fall asleep.\n\nCase #5 is the one described in the problem statement. Note that it would only show up in the Large dataset, and not in the Small dataset.\n\n**Limits**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$.\n\n**Small dataset (7 Pts, Test Set 1 - Visible)**\n\n- $0 \\leqslant \\mathrm{N} \\leqslant 200$.\n\n**Large dataset (8 Pts, Test Set 2 - Hidden)**\n\n- $0 \\leqslant \\mathrm{N} \\leqslant 10^{6}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2016 Qualification] Counting Sheep", "background": "", "description": "Bleatrix Trotter 这只羊发明了一种能帮助她更快入睡的方法。首先，她会选取一个数字 $\\mathrm{N}$。然后，她依次念出 $\\mathrm{N}$、$2 \\times \\mathrm{N}$、$3 \\times \\mathrm{N}$，以此类推。每当她念出一个数字时，她会思考这个数字中所有出现过的数字。她会记录下自己已经见过哪些数字（$0,1,2,3,4,5,6,7,8,9$），无论这些数字在她念出的哪一个数字中出现过。只要她已经见到过全部十个数字中的每一个至少一次，她就会入睡。\n\nBleatrix 必须从 $\\mathrm{N}$ 开始，并且每次都要在念完 $i \\times \\mathrm{N}$ 后，直接念 $(i+1) \\times \\mathrm{N}$。例如，假设 Bleatrix 选择了 $\\mathrm{N} = 1692$，她的计数过程如下：\n\n- $\\mathrm{N} = 1692$。现在她已经见过数字 $1,2,6$ 和 $9$。\n- $2 \\mathrm{N} = 3384$。现在她已经见过数字 $1,2,3,4,6,8$ 和 $9$。\n- $3 \\mathrm{N} = 5076$。现在她已经见过全部十个数字，于是她入睡。\n\n她在入睡前最后念出的数字是多少？如果她会永远数下去，请输出 **INSOMNIA**。", "inputFormat": "输入的第一行包含测试用例数量 $\\mathrm{T}$。接下来有 $\\mathrm{T}$ 组测试用例，每组测试用例包含一行，一个整数 $\\mathrm{N}$，即 Bleatrix 选择的数字。\n", "outputFormat": "对于每组测试用例，输出一行 `Case #x: y`，其中 $x$ 表示测试用例编号（从 1 开始），$y$ 是按照题目描述 Bleatrix 入睡前最后念出的数字。\n", "hint": "**样例解释**\n\n在第 1 组中，由于 $2 \\times 0 = 0, 3 \\times 0 = 0$，以此类推，Bleatrix 除了 $0$ 以外永远不会见到其他数字，因此她会永远数下去，无法入睡。可怜的羊！\n\n在第 2 组中，Bleatrix 会依次念出 $1,2,3,4,5,6,7,8,9,10$。$0$ 是最后一个被见到的数字，因此她会在 $10$ 之后入睡。\n\n在第 3 组中，Bleatrix 会念出 $2,4,6,\\ldots$ 等等。在 $90$ 之前，她都不会见到数字 $9$，直到 $90$ 时才会见到，从而入睡。在此之前，她已经分别在 $10,10,2,30,4,50,6,70,8$ 这些数字中首次见到 $0,1,2,3,4,5,6,7,8$。\n\n在第 4 组中，Bleatrix 会依次念出 $11,22,33,44,55,66,77,88,99,110$，然后入睡。\n\n第 5 组就是题面描述中的例子。注意，这一组只会出现在大数据集，而不会出现在小数据集中。\n\n**限制条件**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$。\n\n**小数据集（7 分，测试集 1 - 可见）**\n\n- $0 \\leqslant \\mathrm{N} \\leqslant 200$。\n\n**大数据集（8 分，测试集 2 - 隐藏）**\n\n- $0 \\leqslant \\mathrm{N} \\leqslant 10^{6}$。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13186", "type": "P", "difficulty": 3, "samples": [["5\n-\n-+\n+-\n+++\n--+-", "Case #1: 1\nCase #2: 1\nCase #3: 2\nCase #4: 0\nCase #5: 3"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["数学", "2016", "Google Code Jam"], "title": "[GCJ 2016 Qualification] Revenge of the Pancakes", "background": "", "description": "The Infinite House of Pancakes has just introduced a new kind of pancake! It has a happy face made of chocolate chips on one side (the \"happy side\"), and nothing on the other side (the \"blank side\").\n\nYou are the head waiter on duty, and the kitchen has just given you a stack of pancakes to serve to a customer. Like any good pancake server, you have X-ray pancake vision, and you can see whether each pancake in the stack has the happy side up or the blank side up. You think the customer will be happiest if every pancake is happy side up when you serve them.\n\nYou know the following maneuver: carefully lift up some number of pancakes (possibly all of them) from the top of the stack, flip that entire group over, and then put the group back down on top of any pancakes that you did not lift up. When flipping a group of pancakes, you flip the entire group in one motion; you do not individually flip each pancake. Formally: if we number the pancakes $1,2$, ..., $N$ from top to bottom, you choose the top $i$ pancakes to flip. Then, after the flip, the stack is $i, i-1, \\ldots, 2,1, i+1, i+2, \\ldots, N$. Pancakes $1,2, \\ldots, i$ now have the opposite side up, whereas pancakes $i+1, i+2, \\ldots, N$ have the same side up that they had up before.\n\nFor example, let's denote the happy side as `+` and the blank side as `-`. Suppose that the stack, starting from the top, is `--+-`. One valid way to execute the maneuver would be to pick up the top three, flip the entire group, and put them back down on the remaining fourth pancake (which would stay where it is and remain unchanged). The new state of the stack would then be `-++-`. The other valid ways would be to pick up and flip the top one, the top two, or all four. It would not be valid to choose and flip the middle two or the bottom one, for example; you can only take some number off the top.\n\nYou will not serve the customer until every pancake is happy side up, but you don't want the pancakes to get cold, so you have to act fast! What is the smallest number of times you will need to execute the maneuver to get all the pancakes happy side up?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. Each consists of one line with a string $\\mathbf{S}$, each character of which is either `+` (which represents a pancake that is initially happy side up) or `-` (which represents a pancake that is initially blank side up). The string, when read left to right, represents the stack when viewed from top to bottom.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of times you will need to execute the maneuver to get all the pancakes happy side up.", "hint": "**Sample Explanation**\n\nIn Case #1, you only need to execute the maneuver once, flipping the first (and only) pancake.\n\nIn Case #2, you only need to execute the maneuver once, flipping only the first pancake.\n\nIn Case #3, you must execute the maneuver twice. One optimal solution is to flip only the first pancake, changing the stack to `--`, and then flip both pancakes, changing the stack to `++`. Notice that you cannot just flip the bottom pancake individually to get a one-move solution; every time you execute the maneuver, you must select a stack starting from the top.\n\nIn Case #4, all of the pancakes are already happy side up, so there is no need to do anything.\n\nIn Case #5, one valid solution is to first flip the entire stack of pancakes to get `+-`++, then flip the top pancake to get `--++`, then finally flip the top two pancakes to get `++++`.\n\n**Limits**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$.\n- Every character in $\\mathbf{S}$ is either `+` or `-`.\n\n**Small dataset (10 Pts, Test Set 1 - Visible)**\n\n- $1 \\leqslant$ length of $\\mathbf{S} \\leqslant 10$.\n\n**Large dataset (10 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leqslant$ length of $\\mathbf{S} \\leqslant 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2016 Qualification] Revenge of the Pancakes", "background": "", "description": "The Infinite House of Pancakes has just introduced a new kind of pancake! It has a happy face made of chocolate chips on one side (the \"happy side\"), and nothing on the other side (the \"blank side\").\n\nYou are the head waiter on duty, and the kitchen has just given you a stack of pancakes to serve to a customer. Like any good pancake server, you have X-ray pancake vision, and you can see whether each pancake in the stack has the happy side up or the blank side up. You think the customer will be happiest if every pancake is happy side up when you serve them.\n\nYou know the following maneuver: carefully lift up some number of pancakes (possibly all of them) from the top of the stack, flip that entire group over, and then put the group back down on top of any pancakes that you did not lift up. When flipping a group of pancakes, you flip the entire group in one motion; you do not individually flip each pancake. Formally: if we number the pancakes $1,2$, ..., $N$ from top to bottom, you choose the top $i$ pancakes to flip. Then, after the flip, the stack is $i, i-1, \\ldots, 2,1, i+1, i+2, \\ldots, N$. Pancakes $1,2, \\ldots, i$ now have the opposite side up, whereas pancakes $i+1, i+2, \\ldots, N$ have the same side up that they had up before.\n\nFor example, let's denote the happy side as `+` and the blank side as `-`. Suppose that the stack, starting from the top, is `--+-`. One valid way to execute the maneuver would be to pick up the top three, flip the entire group, and put them back down on the remaining fourth pancake (which would stay where it is and remain unchanged). The new state of the stack would then be `-++-`. The other valid ways would be to pick up and flip the top one, the top two, or all four. It would not be valid to choose and flip the middle two or the bottom one, for example; you can only take some number off the top.\n\nYou will not serve the customer until every pancake is happy side up, but you don't want the pancakes to get cold, so you have to act fast! What is the smallest number of times you will need to execute the maneuver to get all the pancakes happy side up?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. Each consists of one line with a string $\\mathbf{S}$, each character of which is either `+` (which represents a pancake that is initially happy side up) or `-` (which represents a pancake that is initially blank side up). The string, when read left to right, represents the stack when viewed from top to bottom.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of times you will need to execute the maneuver to get all the pancakes happy side up.", "hint": "**Sample Explanation**\n\nIn Case #1, you only need to execute the maneuver once, flipping the first (and only) pancake.\n\nIn Case #2, you only need to execute the maneuver once, flipping only the first pancake.\n\nIn Case #3, you must execute the maneuver twice. One optimal solution is to flip only the first pancake, changing the stack to `--`, and then flip both pancakes, changing the stack to `++`. Notice that you cannot just flip the bottom pancake individually to get a one-move solution; every time you execute the maneuver, you must select a stack starting from the top.\n\nIn Case #4, all of the pancakes are already happy side up, so there is no need to do anything.\n\nIn Case #5, one valid solution is to first flip the entire stack of pancakes to get `+-`++, then flip the top pancake to get `--++`, then finally flip the top two pancakes to get `++++`.\n\n**Limits**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$.\n- Every character in $\\mathbf{S}$ is either `+` or `-`.\n\n**Small dataset (10 Pts, Test Set 1 - Visible)**\n\n- $1 \\leqslant$ length of $\\mathbf{S} \\leqslant 10$.\n\n**Large dataset (10 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leqslant$ length of $\\mathbf{S} \\leqslant 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2016 Qualification] Revenge of the Pancakes", "background": "", "description": "无限煎饼屋刚刚推出了一种新型煎饼！煎饼的一面用巧克力豆装饰成了笑脸（称为“开心面”），另一面则什么都没有（称为“空白面”）。\n\n你是当班的首席服务员，厨房刚刚给你一摞煎饼，准备让你端给顾客。作为一名优秀的煎饼服务员，你拥有 X 光煎饼视力，可以看清堆中每一张煎饼朝上的是开心面还是空白面。你认为如果每一张煎饼在端给顾客时都是开心面朝上，顾客会最开心。\n\n你掌握如下操作：小心地从煎饼堆顶取出若干张（可能全部），将这一组整体翻面，然后再放回剩下的煎饼上方。翻动一组煎饼时，整个组会被整体翻转，而不是单独翻转每一张。形式化地说：如果我们将煎饼从上到下编号为 $1,2,\\ldots,N$，你可以选择翻转最上面的 $i$ 张。翻转后，堆的顺序变为 $i,i-1,\\ldots,2,1,i+1,i+2,\\ldots,N$。编号 $1,2,\\ldots,i$ 的煎饼现在朝上的面会变成原来的反面，而 $i+1,i+2,\\ldots,N$ 的煎饼则保持原状。\n\n例如，我们用 `+` 表示开心面朝上，用 `-` 表示空白面朝上。假设从顶到底的煎饼堆为 `--+-`。一种可行操作是取出最上面的三张，整体翻转后放回剩下的第四张上方（第四张保持不变）。此时堆的新状态为 `-++-`。其他合法操作包括只翻最上面的一张、最上面两张或全部四张。不合法的操作包括只翻中间两张或只翻最底下一张，因为你只能从顶部开始取若干张。\n\n只有当所有煎饼都是开心面朝上时，你才会端给顾客，但你不想让煎饼变冷，所以你必须尽快行动！请问，要让所有煎饼都变为开心面朝上，最少需要执行多少次上述操作？", "inputFormat": "输入的第一行包含一个整数 $\\mathrm{T}$，表示测试用例数量。接下来有 $\\mathrm{T}$ 组测试用例。每组测试用例包含一行字符串 $\\mathbf{S}$，其中每个字符为 `+`（表示该煎饼初始时为开心面朝上）或 `-`（表示该煎饼初始时为空白面朝上）。从左到右读字符串，表示从堆顶到底的煎饼顺序。\n", "outputFormat": "对于每组测试用例，输出一行 `Case #x: y`，其中 $x$ 表示测试用例编号（从 1 开始），$y$ 表示将所有煎饼翻为开心面朝上所需的最小操作次数。\n", "hint": "**样例解释**\n\n在第 1 组中，你只需操作一次，翻转唯一的一张煎饼。\n\n在第 2 组中，你只需操作一次，只翻转最上面的一张煎饼。\n\n在第 3 组中，你需要操作两次。最优解是先翻转最上面的一张，使堆变为 `--`，然后再翻转全部两张，使堆变为 `++`。注意你不能只翻最下面的一张来一步达成目标；每次操作都必须从顶部开始取连续若干张。\n\n在第 4 组中，所有煎饼已经全部开心面朝上，无需任何操作。\n\n在第 5 组中，一种可行方案是：先翻转全部煎饼，得到 `+-++`，再翻转最上面一张，得到 `--++`，最后翻转最上面两张，得到 `++++`。\n\n**限制条件**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$。\n- $\\mathbf{S}$ 中每个字符均为 `+` 或 `-`。\n\n**小数据集（10 分，测试集 1 - 可见）**\n\n- $1 \\leqslant$ $\\mathbf{S}$ 的长度 $\\leqslant 10$。\n\n**大数据集（10 分，测试集 2 - 隐藏）**\n\n- $1 \\leqslant$ $\\mathbf{S}$ 的长度 $\\leqslant 100$。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13187", "type": "P", "difficulty": 4, "samples": [["1\n6 3", "Case #1:\n100011 5 13 147 31 43 1121 73 77 629\n111111 21 26 105 1302 217 1032 513 13286 10101\n111001 3 88 5 1938 7 208 3 20 11"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["数学", "2016", "Special Judge", "Google Code Jam"], "title": "[GCJ 2016 Qualification] Coin Jam", "background": "", "description": "A jamcoin is a string of $\\mathrm{N} \\geqslant 2$ digits with the following properties:\n\n- Every digit is either $0$ or $1$.\n- The first digit is $1$ and the last digit is $1$.\n- If you interpret the string in any base between $2$ and $10$, inclusive, the resulting number is not prime.\n\nNot every string of $0$s and $1$s is a jamcoin. For example, $101$ is not a jamcoin; its interpretation in base $2$ is $5$, which is prime. But the string $1001$ is a jamcoin: in bases $2$ through $10$, its interpretation is $9, 28, 65, 126, 217, 344, 513, 730$, and $1001$, respectively, and none of those is prime.\n\nWe hear that there may be communities that use jamcoins as a form of currency. When sending someone a jamcoin, it is polite to prove that the jamcoin is legitimate by including a nontrivial divisor of that jamcoin's interpretation in each base from $2$ to $10$. (A nontrivial divisor for a positive integer $K$ is some positive integer other than 1 or $K$ that evenly divides $K$.) For convenience, these divisors must be expressed in base $10$.\n\nFor example, for the jamcoin $1001$ mentioned above, a possible set of nontrivial divisors for the base $2$ through 10 interpretations of the jamcoin would be: $3, 7, 5, 6, 31, 8, 27, 5$, and $77$, respectively.\n\nCan you produce $\\mathrm{J}$ different jamcoins of length $\\mathrm{N}$, along with proof that they are legitimate?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow; each consists of one line with two integers $\\mathrm{N}$ and $\\mathrm{J}$.\n", "outputFormat": "For each test case, output $\\mathrm{J}+1$ lines. The first line must consist of only `Case #x`:, where $x$ is the test case number (starting from 1). Each of the last $\\mathrm{J}$ lines must consist of a jamcoin of length $\\mathrm{N}$ followed by nine integers. The $i$-th of those nine integers (counting starting from 1) must be a nontrivial divisor of the jamcoin when the jamcoin is interpreted in base $i+1$.\n\nAll of these jamcoins must be different. You cannot submit the same jamcoin in two different lines, even if you use a different set of divisors each time.", "hint": "In this sample case, we have used very small values of $\\mathrm{N}$ and $\\mathrm{J}$ for ease of explanation. Note that this sample case would not appear in either the Small or Large datasets.\n\nThis is only one of multiple valid solutions. Other sets of jamcoins could have been used, and there are many other possible sets of nontrivial base $10$ divisors. Some notes:\n\n- 110111 could not have been included in the output because, for example, it is 337 if interpreted in base 3 $(1\\times 243 + 1\\times 81 + 0\\times 27 + 1\\times 9 + 1\\times 3 + 1\\times 1)$, and $337$ is prime.\n- 010101 could not have been included in the output even though 10101 is a jamcoin, because jamcoins begin with $1$.\n- 101010 could not have been included in the output, because jamcoins end with 1.\n- 110011 is another jamcoin that could have also been used in the output, but could not have been added to the end of this output, since the output must contain exactly $\\mathrm{J}$ examples.\n- For the first jamcoin in the sample output, the first number after 100011 could not have been either $1$ or $35$, because those are trivial divisors of $35$ (100011 in base $2$).\n\n**Limits**\n\n- $T = 1$. (There will be only one test case.)\n- It is guaranteed that at least $J$ distinct jamcoins of length $N$ exist.\n\n**Small dataset (10 Pts, Test Set 1 - Visible)**\n\n- $N = 16$.\n- $J = 50$.\n\n**Large dataset (20 Pts, Test Set 2 - Hidden)**\n\n- $N = 32$.\n- $J = 500$.\n\nNote that, unusually for a Code Jam problem, you already know the exact contents of each input file. For example, the Small dataset's input file will always be exactly these two lines:\n\n```\n1\n16 50\n```\n\nSo, you can consider doing some computation before actually downloading an input file and starting the clock.", "locale": "en", "translations": {"en": {"title": "[GCJ 2016 Qualification] Coin Jam", "background": "", "description": "A jamcoin is a string of $\\mathrm{N} \\geqslant 2$ digits with the following properties:\n\n- Every digit is either $0$ or $1$.\n- The first digit is $1$ and the last digit is $1$.\n- If you interpret the string in any base between $2$ and $10$, inclusive, the resulting number is not prime.\n\nNot every string of $0$s and $1$s is a jamcoin. For example, $101$ is not a jamcoin; its interpretation in base $2$ is $5$, which is prime. But the string $1001$ is a jamcoin: in bases $2$ through $10$, its interpretation is $9, 28, 65, 126, 217, 344, 513, 730$, and $1001$, respectively, and none of those is prime.\n\nWe hear that there may be communities that use jamcoins as a form of currency. When sending someone a jamcoin, it is polite to prove that the jamcoin is legitimate by including a nontrivial divisor of that jamcoin's interpretation in each base from $2$ to $10$. (A nontrivial divisor for a positive integer $K$ is some positive integer other than 1 or $K$ that evenly divides $K$.) For convenience, these divisors must be expressed in base $10$.\n\nFor example, for the jamcoin $1001$ mentioned above, a possible set of nontrivial divisors for the base $2$ through 10 interpretations of the jamcoin would be: $3, 7, 5, 6, 31, 8, 27, 5$, and $77$, respectively.\n\nCan you produce $\\mathrm{J}$ different jamcoins of length $\\mathrm{N}$, along with proof that they are legitimate?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow; each consists of one line with two integers $\\mathrm{N}$ and $\\mathrm{J}$.\n", "outputFormat": "For each test case, output $\\mathrm{J}+1$ lines. The first line must consist of only `Case #x`:, where $x$ is the test case number (starting from 1). Each of the last $\\mathrm{J}$ lines must consist of a jamcoin of length $\\mathrm{N}$ followed by nine integers. The $i$-th of those nine integers (counting starting from 1) must be a nontrivial divisor of the jamcoin when the jamcoin is interpreted in base $i+1$.\n\nAll of these jamcoins must be different. You cannot submit the same jamcoin in two different lines, even if you use a different set of divisors each time.", "hint": "In this sample case, we have used very small values of $\\mathrm{N}$ and $\\mathrm{J}$ for ease of explanation. Note that this sample case would not appear in either the Small or Large datasets.\n\nThis is only one of multiple valid solutions. Other sets of jamcoins could have been used, and there are many other possible sets of nontrivial base $10$ divisors. Some notes:\n\n- 110111 could not have been included in the output because, for example, it is 337 if interpreted in base 3 $(1\\times 243 + 1\\times 81 + 0\\times 27 + 1\\times 9 + 1\\times 3 + 1\\times 1)$, and $337$ is prime.\n- 010101 could not have been included in the output even though 10101 is a jamcoin, because jamcoins begin with $1$.\n- 101010 could not have been included in the output, because jamcoins end with 1.\n- 110011 is another jamcoin that could have also been used in the output, but could not have been added to the end of this output, since the output must contain exactly $\\mathrm{J}$ examples.\n- For the first jamcoin in the sample output, the first number after 100011 could not have been either $1$ or $35$, because those are trivial divisors of $35$ (100011 in base $2$).\n\n**Limits**\n\n- $T = 1$. (There will be only one test case.)\n- It is guaranteed that at least $J$ distinct jamcoins of length $N$ exist.\n\n**Small dataset (10 Pts, Test Set 1 - Visible)**\n\n- $N = 16$.\n- $J = 50$.\n\n**Large dataset (20 Pts, Test Set 2 - Hidden)**\n\n- $N = 32$.\n- $J = 500$.\n\nNote that, unusually for a Code Jam problem, you already know the exact contents of each input file. For example, the Small dataset's input file will always be exactly these two lines:\n\n```\n1\n16 50\n```\n\nSo, you can consider doing some computation before actually downloading an input file and starting the clock.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2016 Qualification] Coin Jam", "background": "", "description": "Jamcoin 是一种长度为 $\\mathrm{N}$（$\\mathrm{N} \\geqslant 2$）的二进制串，满足以下条件：\n\n- 每一位都是 $0$ 或 $1$。\n- 首位为 $1$，末位也为 $1$。\n- 无论将该串按 $2$ 到 $10$ 进制中的哪一种解释，所得的数都不是质数。\n\n并非所有由 $0$ 和 $1$ 组成的串都是 jamcoin。例如，$101$ 不是 jamcoin，因为它在 $2$ 进制下的数值是 $5$，而 $5$ 是质数。但 $1001$ 是 jamcoin：在 $2$ 到 $10$ 进制下分别对应 $9, 28, 65, 126, 217, 344, 513, 730, 1001$，其中每一个都不是质数。\n\n据说有些社区会用 jamcoin 作为货币。当你把 jamcoin 发送给别人时，礼貌的做法是为每个进制（$2$ 到 $10$）下 jamcoin 的数值都提供一个非平凡因子，以证明该 jamcoin 的合法性。（对于正整数 $K$，非平凡因子是指除了 $1$ 和 $K$ 之外的正整数因子。）为方便起见，这些因子需用 $10$ 进制表示。\n\n例如，前述 jamcoin $1001$，对于 $2$ 到 $10$ 进制的解释，可以选择的非平凡因子分别为：$3, 7, 5, 6, 31, 8, 27, 5, 77$。\n\n你能否生成 $\\mathrm{N}$ 位、互不相同的 $\\mathrm{J}$ 个 jamcoin，并且为每个 jamcoin 提供一组合法性证明？", "inputFormat": "输入的第一行是测试用例数量 $\\mathrm{T}$。接下来有 $\\mathrm{T}$ 组测试用例，每组一行，包含两个整数 $\\mathrm{N}$ 和 $\\mathrm{J}$。\n", "outputFormat": "对于每组测试用例，输出 $\\mathrm{J}+1$ 行。第一行只包含 `Case #x:`，其中 $x$ 是测试用例编号（从 $1$ 开始）。接下来的 $\\mathrm{J}$ 行，每行包含一个长度为 $\\mathrm{N}$ 的 jamcoin，后跟九个整数，第 $i$ 个整数（$i$ 从 $1$ 开始）为该 jamcoin 在 $i+1$ 进制下的一个非平凡因子。\n\n所有 jamcoin 必须互不相同。即使因子组不同，也不能输出相同的 jamcoin。", "hint": "在样例中，为了便于说明，$\\mathrm{N}$ 和 $\\mathrm{J}$ 取了很小的值。注意，这组样例不会出现在 Small 或 Large 数据集中。\n\n这只是众多合法解中的一种。你也可以用其他 jamcoin 及其因子组。补充说明：\n\n- $110111$ 不能作为输出，因为它在 $3$ 进制下为 $337$，而 $337$ 是质数。\n- $010101$ 虽然 $10101$ 是 jamcoin，但不能作为输出，因为 jamcoin 必须以 $1$ 开头。\n- $101010$ 也不能作为输出，因为 jamcoin 必须以 $1$ 结尾。\n- $110011$ 也是 jamcoin，可以出现在输出中，但由于输出必须恰好有 $\\mathrm{J}$ 个 jamcoin，不能再多输出。\n- 对于样例输出的第一个 jamcoin，后面的第一个数不能是 $1$ 或 $35$，因为这两者是 $35$（$100011$ 在 $2$ 进制下）的平凡因子。\n\n**限制条件**\n\n- $T = 1$。（只有一组测试数据。）\n- 保证存在至少 $J$ 个不同的长度为 $N$ 的 jamcoin。\n\n**小数据集（10 分，测试集 1 - 可见）**\n\n- $N = 16$。\n- $J = 50$。\n\n**大数据集（20 分，测试集 2 - 隐藏）**\n\n- $N = 32$。\n- $J = 500$。\n\n注意，这道题不同于一般的 Code Jam 题目，你已经提前知道每个输入文件的内容。例如，小数据集的输入文件永远如下：\n\n```\n1\n16 50\n```\n\n因此，你可以在真正下载输入文件和开始计时之前，提前做一些计算。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13188", "type": "P", "difficulty": 5, "samples": [["5\n2 3 2\n1 1 1\n2 1 1\n2 1 2\n3 2 3", "Case #1: 2\nCase #2: 1\nCase #3: IMPOSSIBLE\nCase #4: 1 2\nCase #5: 2 6"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["数学", "2016", "Special Judge", "Google Code Jam"], "title": "[GCJ 2016 Qualification] Fractiles", "background": "", "description": "Long ago, the Fractal civilization created artwork consisting of linear rows of tiles. They had two types of tile that they could use: gold (G) and lead (L).\n\nEach piece of Fractal artwork is based on two parameters: an original sequence of $\\mathbf{K}$ tiles, and a complexity $\\mathbf{C}$. For a given original sequence, the artwork with complexity 1 is just that original sequence, and the artwork with complexity $X+1$ consists of the artwork with complexity $X$, transformed as follows:\n\n- replace each $\\mathbf{L}$ tile in the complexity $X$ artwork with another copy of the original sequence\n- replace each $\\mathbf{G}$ tile in the complexity $X$ artwork with $K \\mathbf{G}$ tiles\n\nFor example, for an original sequence of `LGL`, the pieces of artwork with complexity 1 through 3 are:\n\n- $C = 1$: `LGL` (which is just the original sequence)\n- $C = 2$: `LGLGGGLGL`\n- $C = 3$: `LGLGGGLGLGGGGGGGGGLGLGGGLGL`\n\nHere's an illustration of how the artwork with complexity $2$ is generated from the artwork with complexity $1$:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9lp48fk9.png)\n\nYou have just discovered a piece of Fractal artwork, but the tiles are too dirty for you to tell what they are made of. Because you are an expert archaeologist familiar with the local Fractal culture, you know the values of $\\mathbf{K}$ and $\\mathbf{C}$ for the artwork, but you do not know the original sequence. Since gold is exciting, you would like to know whether there is at least one $\\mathbf{G}$ tile in the artwork. Your budget allows you to hire $\\mathbf{S}$ graduate students, each of whom can clean one tile of your choice (out of the $\\mathbf{K}^{\\mathbf{C}}$ tiles in the artwork) to see whether the tile is $\\mathbf{G}$ or $\\mathbf{L}$.\n\nIs it possible for you to choose a set of no more than $\\mathbf{S}$ specific tiles to clean, such that no matter what the original pattern was, you will be able to know for sure whether at least one $\\mathbf{G}$ tile is present in the artwork? If so, which tiles should you clean?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each consists of one line with three integers: $\\mathbf{K}, \\mathbf{C}$, and $\\mathbf{S}$.", "outputFormat": "For each test case, output one line containing `Case #x: y` where $\\mathbf{x}$ is the test case number (starting from 1) and $\\mathbf{y}$ is either $\\mathbf{I M P O S S I B L E}$ if no set of tiles will answer your question, or a list of between 1 and $\\mathbf{S}$ positive integers, which are the positions of the tiles that will answer your question. The tile positions are numbered from 1 for the leftmost tile to $\\mathbf{K}^{\\mathbf{C}}$ for the rightmost tile. Your chosen positions may be in any order, but they must all be different.\n\nIf there are multiple valid sets of tiles, you may output any of them.", "hint": "**Sample Explanation**\n\nNote: for some of these sample cases, other valid solutions exist.\n\nIn sample case #1, there are four possible original sequences: GG, GL, LG, and LL. They would produce the following artwork, respectively:\n\n- Original sequence GG: GGGGGGGG\n- Original sequence GL: GGGGGGGL\n- Original sequence LG: LGGGGGGG\n- Original sequence LL: LLLLLLLL\n\nOne valid solution is to just look at tile #2. If tile #2 turns out to be G, then you will know for sure the artwork contains at least one G. (You will not know whether the original sequence is GG, GL, or LG, but that doesn't matter.) If tile #2 turns out to be L, then you will know that the original sequence must be LL, so there are no Gs in the artwork. So 2 is a valid solution.\n\nOn the other hand, it would not be valid to just look at tile #1. If it turns out to be L, you will only know that the original sequence could have been either LG or LL. If the original sequence is LG, there is at least one G in the artwork, but if the original sequence is LL, there are no Gs. So 1 would not be a valid solution.\n\nNote that 1 2 is also a valid solution, because tile #2 already provides all the information you need. 1 2 3 is not a valid solution, because it uses too many tiles.\n\nIn sample case #2, the artwork must consist of only one tile: either G or L. Looking at that tile will trivially tell you whether or not the artwork has a G in it.\n\nIn sample case #3, which would not appear in the Small dataset, the artwork must be either GG, GL, LG, or LL. You can only look at one tile, and neither of them on its own is enough to answer the question. If you see L for tile #1, you will not know whether the artwork is LG or LL, so you will not know whether any Gs are present. If you see L for tile #2, you will not know whether the artwork is GL or LL, so you will not know whether any Gs are present.\n\nSample case #4 is like sample case #3, but with access to one more tile. Now you can just look at the entire artwork.\n\nIn sample case #5, there are eight possible original sequences, and they would produce the following artwork:\n\n- Original sequence GGG: GGGGGGGGG\n- Original sequence GGL: GGGGGGGGL\n- Original sequence GLG: GGGGLGGGG\n- Original sequence GLL: GGGGLLGLL\n- Original sequence LGG: LGGGGGGGG\n- Original sequence LGL: LGLGGGLGL\n- Original sequence LLG: LLGLLGGGG\n- Original sequence LLL: LLLLLLLLL\n\nOne valid solution is to look at tiles #2 and #6. If they both turn out to be Ls, the artwork must be all Ls. Otherwise, there must at least one G. Note that 1 2 would not be a valid solution, because even if those tiles both turn out to be Ls, that does not rule out an original sequence of LLG. 6 2 would be a valid solution, since the order of the positions in your solution does not matter.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{K} \\leq 100$.\n- $1 \\leq \\mathbf{C} \\leq 100$.\n- $\\mathbf{K}^{\\mathbf{C}} \\leq 10^{18}$.\n\n**Small dataset (10 Pts, Test Set 1 - Visible)**\n\n- $\\mathbf{S} = \\mathbf{K}$.\n\n**Large dataset (25 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leq \\mathbf{S} \\leq \\mathbf{K}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2016 Qualification] Fractiles", "background": "", "description": "Long ago, the Fractal civilization created artwork consisting of linear rows of tiles. They had two types of tile that they could use: gold (G) and lead (L).\n\nEach piece of Fractal artwork is based on two parameters: an original sequence of $\\mathbf{K}$ tiles, and a complexity $\\mathbf{C}$. For a given original sequence, the artwork with complexity 1 is just that original sequence, and the artwork with complexity $X+1$ consists of the artwork with complexity $X$, transformed as follows:\n\n- replace each $\\mathbf{L}$ tile in the complexity $X$ artwork with another copy of the original sequence\n- replace each $\\mathbf{G}$ tile in the complexity $X$ artwork with $K \\mathbf{G}$ tiles\n\nFor example, for an original sequence of `LGL`, the pieces of artwork with complexity 1 through 3 are:\n\n- $C = 1$: `LGL` (which is just the original sequence)\n- $C = 2$: `LGLGGGLGL`\n- $C = 3$: `LGLGGGLGLGGGGGGGGGLGLGGGLGL`\n\nHere's an illustration of how the artwork with complexity $2$ is generated from the artwork with complexity $1$:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9lp48fk9.png)\n\nYou have just discovered a piece of Fractal artwork, but the tiles are too dirty for you to tell what they are made of. Because you are an expert archaeologist familiar with the local Fractal culture, you know the values of $\\mathbf{K}$ and $\\mathbf{C}$ for the artwork, but you do not know the original sequence. Since gold is exciting, you would like to know whether there is at least one $\\mathbf{G}$ tile in the artwork. Your budget allows you to hire $\\mathbf{S}$ graduate students, each of whom can clean one tile of your choice (out of the $\\mathbf{K}^{\\mathbf{C}}$ tiles in the artwork) to see whether the tile is $\\mathbf{G}$ or $\\mathbf{L}$.\n\nIs it possible for you to choose a set of no more than $\\mathbf{S}$ specific tiles to clean, such that no matter what the original pattern was, you will be able to know for sure whether at least one $\\mathbf{G}$ tile is present in the artwork? If so, which tiles should you clean?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each consists of one line with three integers: $\\mathbf{K}, \\mathbf{C}$, and $\\mathbf{S}$.", "outputFormat": "For each test case, output one line containing `Case #x: y` where $\\mathbf{x}$ is the test case number (starting from 1) and $\\mathbf{y}$ is either $\\mathbf{I M P O S S I B L E}$ if no set of tiles will answer your question, or a list of between 1 and $\\mathbf{S}$ positive integers, which are the positions of the tiles that will answer your question. The tile positions are numbered from 1 for the leftmost tile to $\\mathbf{K}^{\\mathbf{C}}$ for the rightmost tile. Your chosen positions may be in any order, but they must all be different.\n\nIf there are multiple valid sets of tiles, you may output any of them.", "hint": "**Sample Explanation**\n\nNote: for some of these sample cases, other valid solutions exist.\n\nIn sample case #1, there are four possible original sequences: GG, GL, LG, and LL. They would produce the following artwork, respectively:\n\n- Original sequence GG: GGGGGGGG\n- Original sequence GL: GGGGGGGL\n- Original sequence LG: LGGGGGGG\n- Original sequence LL: LLLLLLLL\n\nOne valid solution is to just look at tile #2. If tile #2 turns out to be G, then you will know for sure the artwork contains at least one G. (You will not know whether the original sequence is GG, GL, or LG, but that doesn't matter.) If tile #2 turns out to be L, then you will know that the original sequence must be LL, so there are no Gs in the artwork. So 2 is a valid solution.\n\nOn the other hand, it would not be valid to just look at tile #1. If it turns out to be L, you will only know that the original sequence could have been either LG or LL. If the original sequence is LG, there is at least one G in the artwork, but if the original sequence is LL, there are no Gs. So 1 would not be a valid solution.\n\nNote that 1 2 is also a valid solution, because tile #2 already provides all the information you need. 1 2 3 is not a valid solution, because it uses too many tiles.\n\nIn sample case #2, the artwork must consist of only one tile: either G or L. Looking at that tile will trivially tell you whether or not the artwork has a G in it.\n\nIn sample case #3, which would not appear in the Small dataset, the artwork must be either GG, GL, LG, or LL. You can only look at one tile, and neither of them on its own is enough to answer the question. If you see L for tile #1, you will not know whether the artwork is LG or LL, so you will not know whether any Gs are present. If you see L for tile #2, you will not know whether the artwork is GL or LL, so you will not know whether any Gs are present.\n\nSample case #4 is like sample case #3, but with access to one more tile. Now you can just look at the entire artwork.\n\nIn sample case #5, there are eight possible original sequences, and they would produce the following artwork:\n\n- Original sequence GGG: GGGGGGGGG\n- Original sequence GGL: GGGGGGGGL\n- Original sequence GLG: GGGGLGGGG\n- Original sequence GLL: GGGGLLGLL\n- Original sequence LGG: LGGGGGGGG\n- Original sequence LGL: LGLGGGLGL\n- Original sequence LLG: LLGLLGGGG\n- Original sequence LLL: LLLLLLLLL\n\nOne valid solution is to look at tiles #2 and #6. If they both turn out to be Ls, the artwork must be all Ls. Otherwise, there must at least one G. Note that 1 2 would not be a valid solution, because even if those tiles both turn out to be Ls, that does not rule out an original sequence of LLG. 6 2 would be a valid solution, since the order of the positions in your solution does not matter.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{K} \\leq 100$.\n- $1 \\leq \\mathbf{C} \\leq 100$.\n- $\\mathbf{K}^{\\mathbf{C}} \\leq 10^{18}$.\n\n**Small dataset (10 Pts, Test Set 1 - Visible)**\n\n- $\\mathbf{S} = \\mathbf{K}$.\n\n**Large dataset (25 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leq \\mathbf{S} \\leq \\mathbf{K}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2016 Qualification] Fractiles", "background": "", "description": "很久以前，Fractal 文明创造了一种由线性排列的瓷砖组成的艺术品。他们有两种类型的瓷砖可用：金砖（G）和铅砖（L）。\n\n每件 Fractal 艺术品由两个参数决定：原始序列的长度 $\\mathbf{K}$，以及复杂度 $\\mathbf{C}$。对于一个给定的原始序列，复杂度为 $1$ 的艺术品就是原始序列本身，而复杂度为 $X+1$ 的艺术品则是将复杂度为 $X$ 的艺术品进行如下变换得到：\n\n- 将复杂度 $X$ 艺术品中的每一个 $\\mathbf{L}$ 替换为一份新的原始序列\n- 将复杂度 $X$ 艺术品中的每一个 $\\mathbf{G}$ 替换为 $K$ 个 $\\mathbf{G}$\n\n例如，若原始序列为 `LGL`，则复杂度 $1$ 到 $3$ 的艺术品分别为：\n\n- $C = 1$：`LGL`（即原始序列本身）\n- $C = 2$：`LGLGGGLGL`\n- $C = 3$：`LGLGGGLGLGGGGGGGGGLGLGGGLGL`\n\n下图展示了如何由复杂度 $1$ 的艺术品生成复杂度 $2$ 的艺术品：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9lp48fk9.png)\n\n你刚刚发现了一件 Fractal 艺术品，但瓷砖太脏了，无法分辨它们的材质。作为一名熟悉 Fractal 文化的考古专家，你知道这件艺术品的 $\\mathbf{K}$ 和 $\\mathbf{C}$，但不知道原始序列。由于金砖很珍贵，你想知道这件艺术品中是否至少有一块 $\\mathbf{G}$。你的预算允许你雇佣 $\\mathbf{S}$ 个研究生，每个人可以清理你指定的任意一块瓷砖（在总共 $\\mathbf{K}^{\\mathbf{C}}$ 块瓷砖中），以判断其材质是 $\\mathbf{G}$ 还是 $\\mathbf{L}$。\n\n你能否选择不超过 $\\mathbf{S}$ 块特定瓷砖进行清理，使得无论原始序列为何，你都能确定艺术品中是否至少存在一块 $\\mathbf{G}$？如果可以，你应该清理哪些瓷砖？", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例数。接下来有 $\\mathbf{T}$ 组测试用例，每组一行，包含三个整数：$\\mathbf{K}, \\mathbf{C}, \\mathbf{S}$。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 为测试用例编号（从 $1$ 开始），$y$ 若无论如何都无法确定答案，则为 $\\mathbf{IMPOSSIBLE}$；否则为 $1$ 到 $\\mathbf{S}$ 个正整数，表示需要清理的瓷砖编号（从左到右分别为 $1$ 到 $\\mathbf{K}^{\\mathbf{C}}$）。输出的编号顺序任意，但不得重复。\n\n如有多种合法方案，你可以输出任意一种。", "hint": "**样例解释**\n\n注意：部分样例存在其他合法解。\n\n在样例第 1 组中，原始序列可能为 GG、GL、LG、LL，分别生成如下艺术品：\n\n- GG：GGGGGGGG\n- GL：GGGGGGGL\n- LG：LGGGGGGG\n- LL：LLLLLLLL\n\n一个可行方案是只查看第 2 块瓷砖。如果第 2 块为 G，你就能确定艺术品中至少有一块 G（虽然不能确定原始序列是哪一个，但这无关紧要）。如果第 2 块为 L，则原始序列必为 LL，艺术品中没有 G。因此，2 是一个合法方案。\n\n另一方面，仅查看第 1 块是不合法的。如果它为 L，你无法区分原始序列是 LG 还是 LL。若为 LG，则艺术品中有 G；若为 LL，则没有。因此 1 不是合法方案。\n\n注意 1 2 也是合法方案，因为第 2 块已经足够提供全部信息。1 2 3 就不合法，因为使用的瓷砖数超过了限制。\n\n在样例第 2 组中，艺术品只有一块瓷砖：G 或 L。查看该瓷砖即可直接判断是否有 G。\n\n在样例第 3 组（不会出现在小数据集），艺术品可能为 GG、GL、LG、LL。你只能查看一块瓷砖，任意一块都无法完全确定答案。例如查看第 1 块为 L 时，无法区分 LG 和 LL，也就无法判断是否有 G。\n\n样例第 4 组与第 3 组类似，但你可以查看两块瓷砖。此时你可以直接查看全部艺术品。\n\n在样例第 5 组中，原始序列有 8 种可能，生成如下艺术品：\n\n- GGG：GGGGGGGGG\n- GGL：GGGGGGGGL\n- GLG：GGGGLGGGG\n- GLL：GGGGLLGLL\n- LGG：LGGGGGGGG\n- LGL：LGLGGGLGL\n- LLG：LLGLLGGGG\n- LLL：LLLLLLLLL\n\n一种可行方案是查看第 2 块和第 6 块。如果它们都是 L，则艺术品全为 L。否则至少有一块 G。注意 1 2 不是合法方案，因为若两块都是 L，原始序列可能为 LLG，此时艺术品中仍有 G。6 2 也是合法方案，顺序无关。\n\n**限制条件**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{K} \\leq 100$。\n- $1 \\leq \\mathbf{C} \\leq 100$。\n- $\\mathbf{K}^{\\mathbf{C}} \\leq 10^{18}$。\n\n**小数据集（10 分，测试集 1 - 可见）**\n\n- $\\mathbf{S} = \\mathbf{K}$。\n\n**大数据集（25 分，测试集 2 - 隐藏）**\n\n- $1 \\leq \\mathbf{S} \\leq \\mathbf{K}$。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13189", "type": "P", "difficulty": 2, "samples": [["7\nCAB\nJAM\nCODE\nABAAB\nCABCBBABC\nABCABCABC\nZXCASDQWE", "Case #1: CAB\nCase #2: MJA\nCase #3: OCDE\nCase #4: BBAAA\nCase #5: CCCABBBAB\nCase #6: CCCBAABAB\nCase #7: ZXCASDQWE"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2016", "Google Code Jam"], "title": "[GCJ 2016 #1A] The Last Word", "background": "", "description": "On the game show The Last Word, the host begins a round by showing the contestant a string $\\mathbf{S}$ of uppercase English letters. The contestant has a whiteboard which is initially blank. The host will then present the contestant with the letters of $\\mathbf{S}$, one by one, in the order in which they appear in $\\mathbf{S}$. When the host presents the first letter, the contestant writes it on the whiteboard; this counts as the first word in the game (even though it is only one letter long). After that, each time the host presents a letter, the contestant must write it at the beginning or the end of the word on the whiteboard before the host moves on to the next letter (or to the end of the game, if there are no more letters).\n\nFor example, for $\\mathbf{S} = \\text{CAB}$, after writing the word C on the whiteboard, the contestant could make one of the following four sets of choices:\n\n- put the A before C to form AC, then put the B before AC to form $\\text{BAC}$\n- put the A before C to form AC, then put the B after AC to form $\\text{ACB}$\n- put the A after C to form CA, then put the B before CA to form $\\text{BCA}$\n- put the A after C to form CA, then put the B after CA to form $\\text{CAB}$\n\nThe word is called the last word when the contestant finishes writing all of the letters from $\\mathbf{S}$, under the given rules. The contestant wins the game if their last word is the last of an alphabetically sorted list of all of the possible last words that could have been produced. For the example above, the winning last word is $\\text{CAB}$ (which happens to be the same as the original word). For a game with $\\mathbf{S} = \\text{JAM}$, the winning last word is $\\text{MJA}$.\n\nYou are the next contestant on this show, and the host has just showed you the string $\\mathbf{S}$. What's the winning last word that you should produce?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each consists of one line with a string $\\mathbf{S}$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the winning last word, as described in the statement.", "hint": "**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n\n**Small dataset (9 Pts, Test Set 1 - Visible)**\n\n- $1 \\leqslant \\text{length of } \\mathbf{S} \\leqslant 15$.\n\n**Large dataset (11 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leqslant \\text{length of } \\mathbf{S} \\leqslant 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2016 #1A] The Last Word", "background": "", "description": "On the game show The Last Word, the host begins a round by showing the contestant a string $\\mathbf{S}$ of uppercase English letters. The contestant has a whiteboard which is initially blank. The host will then present the contestant with the letters of $\\mathbf{S}$, one by one, in the order in which they appear in $\\mathbf{S}$. When the host presents the first letter, the contestant writes it on the whiteboard; this counts as the first word in the game (even though it is only one letter long). After that, each time the host presents a letter, the contestant must write it at the beginning or the end of the word on the whiteboard before the host moves on to the next letter (or to the end of the game, if there are no more letters).\n\nFor example, for $\\mathbf{S} = \\text{CAB}$, after writing the word C on the whiteboard, the contestant could make one of the following four sets of choices:\n\n- put the A before C to form AC, then put the B before AC to form $\\text{BAC}$\n- put the A before C to form AC, then put the B after AC to form $\\text{ACB}$\n- put the A after C to form CA, then put the B before CA to form $\\text{BCA}$\n- put the A after C to form CA, then put the B after CA to form $\\text{CAB}$\n\nThe word is called the last word when the contestant finishes writing all of the letters from $\\mathbf{S}$, under the given rules. The contestant wins the game if their last word is the last of an alphabetically sorted list of all of the possible last words that could have been produced. For the example above, the winning last word is $\\text{CAB}$ (which happens to be the same as the original word). For a game with $\\mathbf{S} = \\text{JAM}$, the winning last word is $\\text{MJA}$.\n\nYou are the next contestant on this show, and the host has just showed you the string $\\mathbf{S}$. What's the winning last word that you should produce?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each consists of one line with a string $\\mathbf{S}$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the winning last word, as described in the statement.", "hint": "**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n\n**Small dataset (9 Pts, Test Set 1 - Visible)**\n\n- $1 \\leqslant \\text{length of } \\mathbf{S} \\leqslant 15$.\n\n**Large dataset (11 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leqslant \\text{length of } \\mathbf{S} \\leqslant 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2016 #1A] The Last Word", "background": "", "description": "在综艺节目 **The Last Word** 中，主持人会在一轮游戏开始时向选手展示一个由大写英文字母组成的字符串 $\\mathbf{S}$。选手面前有一块最初为空的白板。接着，主持人会依次按照 $\\mathbf{S}$ 中的顺序，将每个字母逐一呈现给选手。当主持人给出第一个字母时，选手需要把它写在白板上；这时白板上的内容就构成了游戏中的第一个单词（虽然它只有一个字母）。之后，每当主持人给出一个新字母，选手必须选择将其写在当前白板单词的开头或末尾，然后主持人再给出下一个字母（或游戏结束，如果没有更多字母）。\n\n例如，对于 $\\mathbf{S} = \\text{CAB}$，选手在白板上写下 C 之后，可以有如下四种决策路径：\n\n- 将 A 写在 C 前面，得到 AC，再将 B 写在 AC 前面，得到 $\\text{BAC}$\n- 将 A 写在 C 前面，得到 AC，再将 B 写在 AC 后面，得到 $\\text{ACB}$\n- 将 A 写在 C 后面，得到 CA，再将 B 写在 CA 前面，得到 $\\text{BCA}$\n- 将 A 写在 C 后面，得到 CA，再将 B 写在 CA 后面，得到 $\\text{CAB}$\n\n当选手按规则写完 $\\mathbf{S}$ 的所有字母后，白板上的单词就称为 **last word**。如果选手最终得到的单词，在所有可能得到的 last word 的按字典序排序后的列表中排在最后，则选手获胜。对于上面的例子，获胜的 last word 是 $\\text{CAB}$（恰好与原始字符串相同）。对于 $\\mathbf{S} = \\text{JAM}$，获胜的 last word 是 $\\text{MJA}$。\n\n你是下一个参赛选手，主持人刚刚向你展示了字符串 $\\mathbf{S}$。请问，你应当如何操作，才能获得获胜的 last word？\n", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例数量。接下来有 $\\mathbf{T}$ 组测试用例，每组一行，一个字符串 $\\mathbf{S}$。\n", "outputFormat": "对于每组测试用例，输出一行 `Case #x: y`，其中 $x$ 表示测试用例编号（从 1 开始），$y$ 为你应当获得的获胜 last word。\n", "hint": "**限制条件**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$。\n\n**小数据集（9 分，测试集 1 - 可见）**\n\n- $1 \\leqslant \\mathbf{S}$ 的长度 $\\leqslant 15$。\n\n**大数据集（11 分，测试集 2 - 隐藏）**\n\n- $1 \\leqslant \\mathbf{S}$ 的长度 $\\leqslant 1000$。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13190", "type": "P", "difficulty": 3, "samples": [["1\n3\n1 2 3\n2 3 5\n3 5 6\n2 3 4\n1 2 3", "Case #1: 3 4 6"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["数学", "2016", "Google Code Jam"], "title": "[GCJ 2016 #1A] Rank and File", "background": "", "description": "When Sergeant Argus's army assembles for drilling, they stand in the shape of an $\\mathbf{N}$ by $\\mathbf{N}$ square grid, with exactly one soldier in each cell. Each soldier has a certain height.\n\nArgus believes that it is important to keep an eye on all of his soldiers at all times. Since he likes to look at the grid from the upper left, he requires that:\n\n- Within every row of the grid, the soldiers' heights must be in strictly increasing order, from left to right.\n- Within every column of the grid, the soldiers' heights must be in strictly increasing order, from top to bottom.\n\nAlthough no two soldiers in the same row or column may have the same height, it is possible for multiple soldiers in the grid to have the same height.\n\nSince soldiers sometimes train separately with their row or their column, Argus has asked you to make a report consisting of $2 \\times \\mathbf{N}$ lists of the soldiers' heights: one representing each row (in left-to-right order) and column (in top-to-bottom order). As you surveyed the soldiers, you only had small pieces of paper to write on, so you wrote each list on a separate piece of paper. However, on your way back to your office, you were startled by a loud bugle blast and you dropped all of the pieces of paper, and the wind blew one away before you could recover it! The other pieces of paper are now in no particular order, and you can't even remember which lists represent rows and which represent columns, since you didn't write that down.\n\nYou know that Argus will make you do hundreds of push-ups if you give him an incomplete report. Can you figure out what the missing list is?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each consists of one line with an integer $\\mathbf{N}$, followed by $2 \\times \\mathbf{N} - 1$ lines of $\\mathbf{N}$ integers each, representing the lists you have, as described in the statement. It is guaranteed that these lists represent all but one of the rows and columns from a valid grid, as described in the statement.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is a list of $\\mathbf{N}$ integers in strictly increasing order, representing the missing list.", "hint": "**Sample Explanation**\n\nIn the sample case, the arrangement must be either this:\n```\n1 2 3\n2 3 4\n3 5 6\n```\nor this:\n```\n1 2 3\n2 3 5\n3 4 6\n```\nIn either case, the missing list is `3 4 6`.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 50$.\n- $1 \\leqslant \\text{all heights} \\leqslant 2500$.\n- The integers on each line will be in strictly increasing order.\n- It is guaranteed that a unique valid answer exists.\n\n**Small dataset (14 Pts, Test Set 1 - Visible)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 10$.\n\n**Large dataset (21 Pts, Test Set 2 - Hidden)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 50$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2016 #1A] Rank and File", "background": "", "description": "When Sergeant Argus's army assembles for drilling, they stand in the shape of an $\\mathbf{N}$ by $\\mathbf{N}$ square grid, with exactly one soldier in each cell. Each soldier has a certain height.\n\nArgus believes that it is important to keep an eye on all of his soldiers at all times. Since he likes to look at the grid from the upper left, he requires that:\n\n- Within every row of the grid, the soldiers' heights must be in strictly increasing order, from left to right.\n- Within every column of the grid, the soldiers' heights must be in strictly increasing order, from top to bottom.\n\nAlthough no two soldiers in the same row or column may have the same height, it is possible for multiple soldiers in the grid to have the same height.\n\nSince soldiers sometimes train separately with their row or their column, Argus has asked you to make a report consisting of $2 \\times \\mathbf{N}$ lists of the soldiers' heights: one representing each row (in left-to-right order) and column (in top-to-bottom order). As you surveyed the soldiers, you only had small pieces of paper to write on, so you wrote each list on a separate piece of paper. However, on your way back to your office, you were startled by a loud bugle blast and you dropped all of the pieces of paper, and the wind blew one away before you could recover it! The other pieces of paper are now in no particular order, and you can't even remember which lists represent rows and which represent columns, since you didn't write that down.\n\nYou know that Argus will make you do hundreds of push-ups if you give him an incomplete report. Can you figure out what the missing list is?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each consists of one line with an integer $\\mathbf{N}$, followed by $2 \\times \\mathbf{N} - 1$ lines of $\\mathbf{N}$ integers each, representing the lists you have, as described in the statement. It is guaranteed that these lists represent all but one of the rows and columns from a valid grid, as described in the statement.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is a list of $\\mathbf{N}$ integers in strictly increasing order, representing the missing list.", "hint": "**Sample Explanation**\n\nIn the sample case, the arrangement must be either this:\n```\n1 2 3\n2 3 4\n3 5 6\n```\nor this:\n```\n1 2 3\n2 3 5\n3 4 6\n```\nIn either case, the missing list is `3 4 6`.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 50$.\n- $1 \\leqslant \\text{all heights} \\leqslant 2500$.\n- The integers on each line will be in strictly increasing order.\n- It is guaranteed that a unique valid answer exists.\n\n**Small dataset (14 Pts, Test Set 1 - Visible)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 10$.\n\n**Large dataset (21 Pts, Test Set 2 - Hidden)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 50$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2016 #1A] Rank and File", "background": "", "description": "当 Argus 军士的部队集合训练时，士兵们会站成一个 $\\mathbf{N} \\times \\mathbf{N}$ 的正方形网格，每个格子里恰好有一名士兵。每位士兵都有一个确定的身高。\n\nArgus 认为时刻关注每一位士兵非常重要。由于他喜欢从左上角观察整个方阵，他要求：\n\n- 在每一行内，士兵的身高必须从左到右严格递增。\n- 在每一列内，士兵的身高必须从上到下严格递增。\n\n虽然同一行或同一列内不能有身高相同的士兵，但整个网格中可以有多名士兵身高相同。\n\n由于士兵们有时会分别与自己所在的行或列进行训练，Argus 让你记录一份报告，内容包括 $2 \\times \\mathbf{N}$ 份士兵身高的列表：每一行（从左到右）和每一列（从上到下）各一份。当你巡视士兵时，你只能用很小的纸条记下每一份列表，因此每份列表都写在一张不同的纸条上。然而，在回办公室的路上，你被一声响亮的军号吓了一跳，所有纸条都掉在了地上，风把其中一张吹走了！剩下的纸条顺序已乱，你也不记得哪些是行、哪些是列，因为你没有记录这一点。\n\n你知道，如果你交给 Argus 的报告不完整，他一定会让你做上百个俯卧撑。你能否找出缺失的那一份列表？\n", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例的数量。接下来有 $\\mathbf{T}$ 组测试用例。每组测试用例的第一行为一个整数 $\\mathbf{N}$，接下来有 $2 \\times \\mathbf{N} - 1$ 行，每行包含 $\\mathbf{N}$ 个整数，表示你记录下的列表，如题面所述。保证这些列表恰好是某个合法网格中全部行和列中除一份之外的所有列表。\n", "outputFormat": "对于每组测试用例，输出一行 `Case #x: y`，其中 $x$ 表示测试用例编号（从 1 开始），$y$ 为缺失的那一份列表，包含 $\\mathbf{N}$ 个严格递增的整数。\n", "hint": "**样例解释**\n\n在样例中，可能的方阵为：\n```\n1 2 3\n2 3 4\n3 5 6\n```\n\n或\n```\n1 2 3\n2 3 5\n3 4 6\n```\n\n无论哪种情况，缺失的列表都是 `3 4 6`。\n\n**限制条件**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 50$。\n- $1 \\leqslant$ 所有身高 $\\leqslant 2500$。\n- 每行的整数均严格递增。\n- 保证存在唯一的合法解。\n\n**小数据集（14 分，测试集 1 - 可见）**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 10$。\n\n**大数据集（21 分，测试集 2 - 隐藏）**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 50$。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13191", "type": "P", "difficulty": 4, "samples": [["4\n4\n2 3 4 1\n4\n3 3 4 1\n4\n3 3 4 3\n10\n7 8 10 10 9 2 9 6 3 3", "Case #1: 4\nCase #2: 3\nCase #3: 3\nCase #4: 6"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["图论", "2016", "深度优先搜索 DFS", "Google Code Jam"], "title": "[GCJ 2016 #1A] BFFs", "background": "", "description": "You are a teacher at the brand new Little Coders kindergarten. You have $\\mathbf{N}$ kids in your class, and each one has a different student ID number from 1 through $\\mathbf{N}$. Every kid in your class has a single best friend forever (BFF), and you know who that BFF is for each kid. BFFs are not necessarily reciprocal -- that is, B being A's BFF does not imply that A is B's BFF.\n\nYour lesson plan for tomorrow includes an activity in which the participants must sit in a circle. You want to make the activity as successful as possible by building the largest possible circle of kids such that each kid in the circle is sitting directly next to their BFF, either to the left or to the right. Any kids not in the circle will watch the activity without participating.\n\nWhat is the greatest number of kids that can be in the circle?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines. The first line of a test case contains a single integer $\\mathbf{N}$, the total number of kids in the class. The second line of a test case contains $\\mathbf{N}$ integers $\\mathbf{F}_1$, $\\mathbf{F}_2$, ..., $\\mathbf{F}_\\mathbf{N}$, where $\\mathbf{F}_i$ is the student ID number of the BFF of the kid with student ID $i$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of kids in the group that can be arranged in a circle such that each kid in the circle is sitting next to his or her BFF.", "hint": "**Sample Explanation**\n\nIn sample case #4, the largest possible circle seats the following kids in the following order: `7 9 3 10 4 1`. (Any reflection or rotation of this circle would also work.) Note that the kid with student ID 1 is next to the kid with student ID 7, as required, because the list represents a circle.\n\n**Sample Explanation**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{F}_i \\leqslant \\mathbf{N}$, for all $i$.\n- $\\mathbf{F}_i \\neq i$, for all $i$. (No kid is their own BFF.)\n\n**Small dataset (16 Pts, Test Set 1 - Visible)**\n\n- $3 \\leqslant \\mathbf{N} \\leqslant 10$.\n\n**Large dataset (29 Pts, Test Set 2 - Hidden)**\n\n- $3 \\leqslant \\mathbf{N} \\leqslant 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2016 #1A] BFFs", "background": "", "description": "You are a teacher at the brand new Little Coders kindergarten. You have $\\mathbf{N}$ kids in your class, and each one has a different student ID number from 1 through $\\mathbf{N}$. Every kid in your class has a single best friend forever (BFF), and you know who that BFF is for each kid. BFFs are not necessarily reciprocal -- that is, B being A's BFF does not imply that A is B's BFF.\n\nYour lesson plan for tomorrow includes an activity in which the participants must sit in a circle. You want to make the activity as successful as possible by building the largest possible circle of kids such that each kid in the circle is sitting directly next to their BFF, either to the left or to the right. Any kids not in the circle will watch the activity without participating.\n\nWhat is the greatest number of kids that can be in the circle?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines. The first line of a test case contains a single integer $\\mathbf{N}$, the total number of kids in the class. The second line of a test case contains $\\mathbf{N}$ integers $\\mathbf{F}_1$, $\\mathbf{F}_2$, ..., $\\mathbf{F}_\\mathbf{N}$, where $\\mathbf{F}_i$ is the student ID number of the BFF of the kid with student ID $i$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of kids in the group that can be arranged in a circle such that each kid in the circle is sitting next to his or her BFF.", "hint": "**Sample Explanation**\n\nIn sample case #4, the largest possible circle seats the following kids in the following order: `7 9 3 10 4 1`. (Any reflection or rotation of this circle would also work.) Note that the kid with student ID 1 is next to the kid with student ID 7, as required, because the list represents a circle.\n\n**Sample Explanation**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{F}_i \\leqslant \\mathbf{N}$, for all $i$.\n- $\\mathbf{F}_i \\neq i$, for all $i$. (No kid is their own BFF.)\n\n**Small dataset (16 Pts, Test Set 1 - Visible)**\n\n- $3 \\leqslant \\mathbf{N} \\leqslant 10$.\n\n**Large dataset (29 Pts, Test Set 2 - Hidden)**\n\n- $3 \\leqslant \\mathbf{N} \\leqslant 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2016 #1A] BFFs", "background": "", "description": "你是一所新开的 Little Coders 幼儿园的老师。你的班级里有 $\\mathbf{N}$ 个孩子，每个孩子的学号从 $1$ 到 $\\mathbf{N}$，互不相同。班里的每个孩子都有一个唯一的“永远的最好的朋友”（BFF），你知道每个孩子的 BFF 是谁。BFF 关系不一定是互相的——也就是说，B 是 A 的 BFF，并不意味着 A 一定是 B 的 BFF。\n\n你的明天的教学计划中有一个活动，要求参与的孩子围成一个圆圈坐下。你希望活动尽可能成功，因此想让尽可能多的孩子围成一个圈，并且要求圈中的每个孩子都必须与自己的 BFF 紧邻（可以在左边，也可以在右边）。没有进入圈子的孩子则只能在一旁观摩。\n\n请问，最多可以有多少个孩子围成满足条件的圆圈？", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例数量。接下来有 $\\mathbf{T}$ 组测试用例。每组测试用例包含两行。第一行为一个整数 $\\mathbf{N}$，表示班级中孩子的总数。第二行为 $\\mathbf{N}$ 个整数 $\\mathbf{F}_1, \\mathbf{F}_2, \\ldots, \\mathbf{F}_\\mathbf{N}$，其中 $\\mathbf{F}_i$ 表示学号为 $i$ 的孩子的 BFF 的学号。\n", "outputFormat": "对于每组测试用例，输出一行 `Case #x: y`，其中 $x$ 表示测试用例编号（从 1 开始），$y$ 表示可以围成满足条件的最大孩子数。\n", "hint": "**样例解释**\n\n在样例第 4 组中，最大可能的圆圈可以让如下孩子按如下顺序围成一圈：`7 9 3 10 4 1`。（该圆圈的任意旋转或反转也都符合条件。）注意，学号为 1 的孩子与学号为 7 的孩子相邻，符合题目要求，因为该列表表示一个圆圈。\n\n**限制条件**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$。\n- 对所有 $i$，$1 \\leqslant \\mathbf{F}_i \\leqslant \\mathbf{N}$。\n- 对所有 $i$，$\\mathbf{F}_i \\neq i$（没有孩子把自己当作 BFF）。\n\n**小数据集（16 分，测试集 1 - 可见）**\n\n- $3 \\leqslant \\mathbf{N} \\leqslant 10$。\n\n**大数据集（29 分，测试集 2 - 隐藏）**\n\n- $3 \\leqslant \\mathbf{N} \\leqslant 1000$。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13192", "type": "P", "difficulty": 2, "samples": [["4\nOZONETOWER\nWEIGHFOXTOURIST\nOURNEONFOE\nETHER", "Case #1: 012\nCase #2: 2468\nCase #3: 114\nCase #4: 3"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2016", "Google Code Jam"], "title": "[GCJ 2016 #1B] Getting the Digits", "background": "", "description": "You just made a new friend at an international puzzle conference, and you asked for a way to keep in touch. You found the following note slipped under your hotel room door the next day:\n\n\"Salutations, new friend! I have replaced every digit of my phone number with its spelled-out uppercase English representation (\"ZERO\", \"ONE\", \"TWO\", \"THREE\", \"FOUR\", \"FIVE\", \"SIX\", \"SEVEN\", \"EIGHT\", \"NINE\" for the digits 0 through 9, in that order), and then reordered all of those letters in some way to produce a string $\\mathbf{S}$. It's up to you to use $\\mathbf{S}$ to figure out how many digits are in my phone number and what those digits are, but I will tell you that my phone number consists of those digits in nondecreasing order. Give me a call... if you can!\"\n\nYou would like to call your friend to tell him that this is an obnoxious way to give someone a phone number, but you need the phone number to do that! What is it?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each consists of one line with a string $\\mathbf{S}$ of uppercase English letters.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is a string of digits: the phone number.", "hint": "**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- A unique answer is guaranteed to exist.\n\n**Small dataset (11 Pts, Test Set 1 - Visible)**\n\n- $3 \\leqslant \\text{length of } \\mathbf{S} \\leqslant 20$.\n\n**Large dataset (12 Pts, Test Set 2 - Hidden)**\n\n- $3 \\leqslant \\text{length of } \\mathbf{S} \\leqslant 2000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2016 #1B] Getting the Digits", "background": "", "description": "You just made a new friend at an international puzzle conference, and you asked for a way to keep in touch. You found the following note slipped under your hotel room door the next day:\n\n\"Salutations, new friend! I have replaced every digit of my phone number with its spelled-out uppercase English representation (\"ZERO\", \"ONE\", \"TWO\", \"THREE\", \"FOUR\", \"FIVE\", \"SIX\", \"SEVEN\", \"EIGHT\", \"NINE\" for the digits 0 through 9, in that order), and then reordered all of those letters in some way to produce a string $\\mathbf{S}$. It's up to you to use $\\mathbf{S}$ to figure out how many digits are in my phone number and what those digits are, but I will tell you that my phone number consists of those digits in nondecreasing order. Give me a call... if you can!\"\n\nYou would like to call your friend to tell him that this is an obnoxious way to give someone a phone number, but you need the phone number to do that! What is it?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each consists of one line with a string $\\mathbf{S}$ of uppercase English letters.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is a string of digits: the phone number.", "hint": "**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- A unique answer is guaranteed to exist.\n\n**Small dataset (11 Pts, Test Set 1 - Visible)**\n\n- $3 \\leqslant \\text{length of } \\mathbf{S} \\leqslant 20$.\n\n**Large dataset (12 Pts, Test Set 2 - Hidden)**\n\n- $3 \\leqslant \\text{length of } \\mathbf{S} \\leqslant 2000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2016 #1B] Getting the Digits", "background": "", "description": "你刚刚在一次国际谜题大会上结识了一位新朋友，并向他要了联系方式。第二天，你发现有人将一张纸条塞到了你的酒店房门下：\n\n“致新朋友！我已经将我的电话号码中的每一个数字都替换成了其英文大写拼写（对于数字 $0$ 到 $9$，依次为 \"ZERO\", \"ONE\", \"TWO\", \"THREE\", \"FOUR\", \"FIVE\", \"SIX\", \"SEVEN\", \"EIGHT\", \"NINE\"），然后把所有这些字母重新打乱，得到一个字符串 $\\mathbf{S}$。你需要根据 $\\mathbf{S}$ 推断出我的电话号码的位数以及具体的数字，不过我会告诉你，我的电话号码中的数字是非递减排列的。祝你好运……如果你能打通的话！”\n\n你很想打电话告诉你的朋友，这种给联系方式的方式实在太让人抓狂了，但你得先把电话号码还原出来！那么，这个电话号码是多少？\n", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例数量。接下来有 $\\mathbf{T}$ 组测试用例，每组包含一行，由大写英文字母组成的字符串 $\\mathbf{S}$。\n", "outputFormat": "对于每组测试用例，输出一行 `Case #x: y`，其中 $x$ 表示测试用例编号（从 1 开始），$y$ 是还原出的电话号码数字串。\n", "hint": "**限制条件**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$。\n- 保证每组数据都有唯一解。\n\n**小数据集（11 分，测试集 1 - 可见）**\n\n- $3 \\leqslant \\mathbf{S}$ 的长度 $\\leqslant 20$。\n\n**大数据集（12 分，测试集 2 - 隐藏）**\n\n- $3 \\leqslant \\mathbf{S}$ 的长度 $\\leqslant 2000$。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13193", "type": "P", "difficulty": 4, "samples": [["4\n1? 2?\n?2? ??3\n? ?\n?5 ?0", "Case #1: 19 20\nCase #2: 023 023\nCase #3: 0 0\nCase #4: 05 00"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2016", "Google Code Jam"], "title": "[GCJ 2016 #1B] Close Match", "background": "", "description": "You are attending the most important game in sports history. The Oceania Coders are playing the Eurasia Jammers in the Centrifugal Bumble-Puppy world finals. Unfortunately, you were sleep deprived from all the anticipation, so you fell asleep during the game!\n\nThe scoreboard is currently displaying both scores, perhaps with one or more leading zeroes (because the scoreboard displays a fixed number of digits). While you were asleep, some of the lights on the scoreboard were damaged by strong ball hits, so one or more of the digits in one or both scores are not being displayed.\n\nYou think close games are more exciting, and you would like to imagine that the scores are as close as possible. Can you fill in all of the missing digits in a way that minimizes the absolute difference between the scores? If there is more than one way to attain the minimum absolute difference, choose the way that minimizes the Coders' score. If there is more than one way to attain the minimum absolute difference while also minimizing the Coders' score, choose the way that minimizes the Jammers' score.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ cases follow. Each case consists of one line with two non-empty strings $\\mathbf{C}$ and $\\mathbf{J}$ of the same length, composed only of decimal digits and question marks, representing the score as you see it for the Coders and the Jammers, respectively. There will be at least one question mark in each test case.\n", "outputFormat": "For each test case, output one line containing `Case #x: c j`, where $x$ is the test case number (starting from 1), $c$ is $\\mathbf{C}$ with the question marks replaced by digits, and $j$ is $\\mathbf{J}$ with the question marks replaced by digits, such that the absolute difference between the integers represented by $c$ and $j$ is minimized. If there are multiple solutions with the same absolute difference, use the one in which $c$ is minimized; if there are multiple solutions with the same absolute difference and the same value of $c$, use the one in which $j$ is minimized.", "hint": "**Sample Explanation**\n\nIn sample case #4, note that the answer cannot be 15 10; that minimizes the absolute difference, but does not minimize the Coders' score. Nor can the answer be 05 10; that minimizes the absolute difference and the Coders' score, but does not minimize the Jammers' score.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 200$.\n- $\\mathbf{C}$ and $\\mathbf{J}$ have the same length.\n\n**Small dataset (Test Set 1 - Visible)**\n\n- $1 \\leqslant \\text{the length of } \\mathbf{C} \\text{ and } \\mathbf{J} \\leqslant 3$.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- $1 \\leqslant \\text{the length of } \\mathbf{C} \\text{ and } \\mathbf{J} \\leqslant 18$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2016 #1B] Close Match", "background": "", "description": "You are attending the most important game in sports history. The Oceania Coders are playing the Eurasia Jammers in the Centrifugal Bumble-Puppy world finals. Unfortunately, you were sleep deprived from all the anticipation, so you fell asleep during the game!\n\nThe scoreboard is currently displaying both scores, perhaps with one or more leading zeroes (because the scoreboard displays a fixed number of digits). While you were asleep, some of the lights on the scoreboard were damaged by strong ball hits, so one or more of the digits in one or both scores are not being displayed.\n\nYou think close games are more exciting, and you would like to imagine that the scores are as close as possible. Can you fill in all of the missing digits in a way that minimizes the absolute difference between the scores? If there is more than one way to attain the minimum absolute difference, choose the way that minimizes the Coders' score. If there is more than one way to attain the minimum absolute difference while also minimizing the Coders' score, choose the way that minimizes the Jammers' score.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ cases follow. Each case consists of one line with two non-empty strings $\\mathbf{C}$ and $\\mathbf{J}$ of the same length, composed only of decimal digits and question marks, representing the score as you see it for the Coders and the Jammers, respectively. There will be at least one question mark in each test case.\n", "outputFormat": "For each test case, output one line containing `Case #x: c j`, where $x$ is the test case number (starting from 1), $c$ is $\\mathbf{C}$ with the question marks replaced by digits, and $j$ is $\\mathbf{J}$ with the question marks replaced by digits, such that the absolute difference between the integers represented by $c$ and $j$ is minimized. If there are multiple solutions with the same absolute difference, use the one in which $c$ is minimized; if there are multiple solutions with the same absolute difference and the same value of $c$, use the one in which $j$ is minimized.", "hint": "**Sample Explanation**\n\nIn sample case #4, note that the answer cannot be 15 10; that minimizes the absolute difference, but does not minimize the Coders' score. Nor can the answer be 05 10; that minimizes the absolute difference and the Coders' score, but does not minimize the Jammers' score.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 200$.\n- $\\mathbf{C}$ and $\\mathbf{J}$ have the same length.\n\n**Small dataset (Test Set 1 - Visible)**\n\n- $1 \\leqslant \\text{the length of } \\mathbf{C} \\text{ and } \\mathbf{J} \\leqslant 3$.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- $1 \\leqslant \\text{the length of } \\mathbf{C} \\text{ and } \\mathbf{J} \\leqslant 18$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2016 #1B] Close Match", "background": "", "description": "你正在观看体育史上最重要的一场比赛：Oceania Coders 队对阵 Eurasia Jammers 队，比赛场地为 Centrifugal Bumble-Puppy 世界总决赛。不幸的是，由于你因期待而彻夜难眠，比赛期间你竟然睡着了！\n\n现在计分牌上显示着双方的得分，可能带有一个或多个前导零（因为计分牌会显示固定位数的数字）。当你熟睡时，计分牌的一些灯泡被猛烈的球击坏了，因此一方或双方的得分中有一位或多位数字没有显示出来。\n\n你觉得比分接近的比赛最精彩，所以你希望能够想象出一个比分尽可能接近的场景。你能否用某种方式填补所有缺失的数字，使得两队分数的绝对差值最小？如果有多种方案可以达到最小绝对差值，请选择 Coders 队得分最小的方案；如果在 Coders 队得分也相同的情况下仍有多种方案，则选择 Jammers 队得分最小的方案。", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例数量。接下来有 $\\mathbf{T}$ 组测试用例。每组测试用例包含一行，包含两个非空字符串 $\\mathbf{C}$ 和 $\\mathbf{J}$，长度相同，仅由十进制数字和问号组成，分别表示你看到的 Coders 队和 Jammers 队的分数。每组测试用例中至少有一个问号。\n", "outputFormat": "对于每组测试用例，输出一行 `Case #x: c j`，其中 $x$ 为测试用例编号（从 1 开始），$c$ 是将 $\\mathbf{C}$ 中所有问号替换为数字后的结果，$j$ 是将 $\\mathbf{J}$ 中所有问号替换为数字后的结果，使得 $c$ 和 $j$ 所表示的整数的绝对差值最小。如果有多个解的绝对差值相同，选择 $c$ 最小的解；如果 $c$ 也相同，则选择 $j$ 最小的解。\n", "hint": "**样例解释**\n\n在样例第 4 组中，注意答案不能是 15 10；该方案虽然绝对差值最小，但 Coders 队得分不是最小的。也不能是 05 10；该方案虽然绝对差值和 Coders 队得分都最小，但 Jammers 队得分不是最小的。\n\n**限制条件**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 200$。\n- $\\mathbf{C}$ 和 $\\mathbf{J}$ 长度相同。\n\n**小数据集（测试集 1 - 可见）**\n\n- $1 \\leqslant \\mathbf{C}$ 和 $\\mathbf{J}$ 的长度 $\\leqslant 3$。\n\n**大数据集（测试集 2 - 隐藏）**\n\n- $1 \\leqslant \\mathbf{C}$ 和 $\\mathbf{J}$ 的长度 $\\leqslant 18$。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13194", "type": "P", "difficulty": 5, "samples": [["3\n3\nHYDROCARBON COMBUSTION\nQUAIL BEHAVIOR\nQUAIL COMBUSTION\n3\nCODE JAM\nSPACE JAM\nPEARL JAM\n2\nINTERGALACTIC PLANETARY\nPLANETARY INTERGALACTIC", "Case #1: 1\nCase #2: 0\nCase #3: 0"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["2016", "二分图", "Google Code Jam"], "title": "[GCJ 2016 #1B] Technobabble", "background": "", "description": "Every year, your professor posts a blank sign-up sheet for a prestigious scientific research conference on her door. If a student wants to give a lecture at the conference, they choose a two-word topic that is not already on the sheet and write it on the sheet. Once the deadline has passed, the professor has one of her grad students put the topics in a random order, to avoid biasing for or against students who signed up earlier. Then she presents the topics to you for review.\n\nSince the snacks at the conference are excellent, some students try to fake their way into the conference. They choose the first word of some topic already on the sheet and the second word of some topic already on the sheet, and combine them (putting the first word first, and the second word second) to create a new \"topic\" (as long as it isn't already on the sheet). Since your professor is open-minded, sometimes this strategy actually works!\n\nThe fakers are completely unoriginal and can't come up with any new first or second words on their own; they must use existing ones from the sheet. Moreover, they won't try to use an existing first word as their own second word (unless the word also already exists on the sheet as a second word), or vice versa.\n\nYou have a list of all $\\mathbf{N}$ of the submitted topics, in some arbitrary order; you don't know the order in which they were actually written on the sheet. What's the largest number of them that could have been faked?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each consists of one line with an integer $\\mathbf{N}$, followed by $\\mathbf{N}$ lines, each of which represents a different topic and has two strings of uppercase English letters: the two words of the topic, in order.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is an integer: the largest number of topics that could have possibly been faked.", "hint": "In sample case #1, one possibility is that the topics were added to the sheet in this order:\n```\nQUAIL BEHAVIOR (real)\nHYDROCARBON COMBUSTION (real)\nQUAIL COMBUSTION (fake)\n```\n\nThere is no scenario in which more than one of the topics can be fake.\n\nIn sample case #2, all of the topics must be real. Whatever order they were written in, at no point would it have been possible to use existing words to create a new topic that was not already on the list.\n\nIn sample case #3, neither topic can be fake. For example, if `INTERGALACTIC PLANETARY` had been the first and only topic written on the sheet, a faker could only have used `INTERGALACTIC` as the first word of a new topic and could only have used `PLANETARY` as the second word of a new topic... but the only topic that the faker could have formed would have been `INTERGALACTIC PLANETARY`, which would have been off limits since it was already on the sheet. So `PLANETARY INTERGALACTIC` must have also been a real topic.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\text{length of each word} \\leqslant 20$.\n- No topic is repeated within a case.\n\n**Small dataset (14 Pts, Test Set 1 - Visible)**\n\n- $1 \\leqslant \\mathbf{N} \\leqslant 16$.\n\n**Large dataset (30 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leqslant \\mathbf{N} \\leqslant 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2016 #1B] Technobabble", "background": "", "description": "Every year, your professor posts a blank sign-up sheet for a prestigious scientific research conference on her door. If a student wants to give a lecture at the conference, they choose a two-word topic that is not already on the sheet and write it on the sheet. Once the deadline has passed, the professor has one of her grad students put the topics in a random order, to avoid biasing for or against students who signed up earlier. Then she presents the topics to you for review.\n\nSince the snacks at the conference are excellent, some students try to fake their way into the conference. They choose the first word of some topic already on the sheet and the second word of some topic already on the sheet, and combine them (putting the first word first, and the second word second) to create a new \"topic\" (as long as it isn't already on the sheet). Since your professor is open-minded, sometimes this strategy actually works!\n\nThe fakers are completely unoriginal and can't come up with any new first or second words on their own; they must use existing ones from the sheet. Moreover, they won't try to use an existing first word as their own second word (unless the word also already exists on the sheet as a second word), or vice versa.\n\nYou have a list of all $\\mathbf{N}$ of the submitted topics, in some arbitrary order; you don't know the order in which they were actually written on the sheet. What's the largest number of them that could have been faked?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each consists of one line with an integer $\\mathbf{N}$, followed by $\\mathbf{N}$ lines, each of which represents a different topic and has two strings of uppercase English letters: the two words of the topic, in order.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is an integer: the largest number of topics that could have possibly been faked.", "hint": "In sample case #1, one possibility is that the topics were added to the sheet in this order:\n```\nQUAIL BEHAVIOR (real)\nHYDROCARBON COMBUSTION (real)\nQUAIL COMBUSTION (fake)\n```\n\nThere is no scenario in which more than one of the topics can be fake.\n\nIn sample case #2, all of the topics must be real. Whatever order they were written in, at no point would it have been possible to use existing words to create a new topic that was not already on the list.\n\nIn sample case #3, neither topic can be fake. For example, if `INTERGALACTIC PLANETARY` had been the first and only topic written on the sheet, a faker could only have used `INTERGALACTIC` as the first word of a new topic and could only have used `PLANETARY` as the second word of a new topic... but the only topic that the faker could have formed would have been `INTERGALACTIC PLANETARY`, which would have been off limits since it was already on the sheet. So `PLANETARY INTERGALACTIC` must have also been a real topic.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\text{length of each word} \\leqslant 20$.\n- No topic is repeated within a case.\n\n**Small dataset (14 Pts, Test Set 1 - Visible)**\n\n- $1 \\leqslant \\mathbf{N} \\leqslant 16$.\n\n**Large dataset (30 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leqslant \\mathbf{N} \\leqslant 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2016 #1B] Technobabble", "background": "", "description": "每年，你的教授都会在她的门上贴出一张空白的报名表，用于一个极具声望的科学研究会议。如果有学生想在会议上做报告，他们需要选择一个尚未被写在表上的“两词话题”，并把它写到表上。截止日期过后，教授会让她的一位研究生将这些话题随机排序，以避免对先报名或后报名的学生产生偏见。然后，她会把这些话题提交给你审核。\n\n由于会议上的点心非常美味，有些学生会试图“造假”混进会议。他们会选择表上已有话题中的某个首词，以及另一个话题的末词，将这两个词拼接（首词在前，末词在后）来创造一个新的“话题”（只要它还不在表上）。由于你的教授思想开放，这种策略有时真的能成功！\n\n这些造假者毫无原创性，无法自己想出新的首词或末词；他们只能用表上已经出现过的词。此外，他们不会把某个已作为首词出现的词用作自己的末词（除非该词也已经作为末词出现过），反之亦然。\n\n你拿到了一份包含所有 $\\mathbf{N}$ 个已提交话题的列表，顺序随机；你并不知道它们在表上的实际书写顺序。请你计算，最多有多少个话题可能是造假的？\n", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例数量。接下来有 $\\mathbf{T}$ 组测试用例。每组测试用例的第一行为一个整数 $\\mathbf{N}$，随后有 $\\mathbf{N}$ 行，每行包含两个大写英文字母字符串，依次为该话题的首词和末词。\n", "outputFormat": "对于每组测试用例，输出一行 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为可能为造假的话题数的最大值。\n", "hint": "在样例第 1 组中，一种可能的顺序是：\n```\nQUAIL BEHAVIOR（真实）\nHYDROCARBON COMBUSTION（真实）\nQUAIL COMBUSTION（造假）\n```\n\n无论如何安排顺序，都不可能让超过一个话题为造假。\n\n在样例第 2 组中，所有话题都必须是真实的。无论它们被写入表格的顺序如何，都无法在某一步用已有的词拼出一个新话题且不与已有话题重复。\n\n在样例第 3 组中，任何话题都不能为造假。例如，如果 `INTERGALACTIC PLANETARY` 是第一个且唯一写在表上的话题，造假者只能用 `INTERGALACTIC` 作为新话题的首词，`PLANETARY` 作为新话题的末词……但唯一能拼出的组合就是 `INTERGALACTIC PLANETARY`，而它已在表上，不能再用。因此 `PLANETARY INTERGALACTIC` 也必须是真实话题。\n\n**限制条件**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$。\n- 每个词的长度 $1 \\leqslant \\text{length} \\leqslant 20$。\n- 每组数据中无重复话题。\n\n**小数据集（14 分，测试集 1 - 可见）**\n\n- $1 \\leqslant \\mathbf{N} \\leqslant 16$。\n\n**大数据集（30 分，测试集 2 - 隐藏）**\n\n- $1 \\leqslant \\mathbf{N} \\leqslant 1000$。\n\n翻译由 GPT4.1 完成。", "locale": "zh-CN"}}}
