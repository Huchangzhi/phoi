{"pid": "P2558", "type": "P", "difficulty": 4, "samples": [["3 2", "3"], ["3 7", "13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "搜索", "2002", "各省省选", "安徽", "栈"], "title": "[AHOI2002] 网络传输", "background": "", "description": "在计算机网络中所有数据都是以二进制形式来传输的。但是在进行较大数据的传输时，直接使用该数的二进制形式加以传输则往往传输的位数过多。譬如要传输 $1024$ 就需要 $11$ 位二进制数。于是小可可提出了一种数据优化传输的设想，并打算对这一设想进行试验。\n\n该设想是：正整数的所有方幂以及任意多个互不相等的 $k$ 的方幂之和排成一个递增数列 $\\{a(k)n\\}$，例如当 $k=3$ 时，$\\{a(k)n\\}$ 的前 $7$ 项为 $1(=3^0)$ 、 $3(=3^1)$ 、 $4(=3^0+3^1)$ 、 $9(=3^2)$ 、 $10(=3^0+3^2)$ 、 $12(=3^1+3^2)$ 、 $13(=3^0+3^1+3^2)$。\n\n如果数 $d$ 是数列 $\\{a(k)n\\}$ 中的第 $p$ 项，则可以通过传送 $k$ 和 $p$ 这两个数来表示数 $d$。由于 $k$ 和 $p$ 这两个相对很小的数就可以表达出很大的数，因而理论上可以减少网络传输的位数。\n\n小可可现在请你编写程序把接收到的数 $k$ 和 $p$ 所代表的数 $d$ 计算出来。", "inputFormat": "文件中以一行的形式存放了两个正整数 $k$ 和 $p$，$1<k \\le 1024$，\n$1 \\le p \\le 1024$。", "outputFormat": "以一行的形式输出问题的解（解的位数不超过 $50$ 位）。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2002] Network Transmission", "background": "", "description": "In computer networks, all data are transmitted in binary form. However, when transmitting large data, directly sending its binary representation often requires too many bits. For example, transmitting $1024$ needs an $11$-bit binary number. Therefore, Xiao Keke proposed an idea for optimizing data transmission and plans to test it.\n\nThe idea is: arrange in increasing order the sequence $\\{a(k)_n\\}$ consisting of all positive integer powers of $k$, as well as sums of any number of pairwise distinct powers of $k$. For example, when $k = 3$, the first $7$ terms of $\\{a(k)_n\\}$ are $1(=3^0)$, $3(=3^1)$, $4(=3^0+3^1)$, $9(=3^2)$, $10(=3^0+3^2)$, $12(=3^1+3^2)$, $13(=3^0+3^1+3^2)$.\n\nIf a number $d$ is the $p$-th term of the sequence $\\{a(k)_n\\}$, then one can represent $d$ by transmitting the two numbers $k$ and $p$. Since the relatively small numbers $k$ and $p$ can represent a very large number, this can theoretically reduce the number of bits transmitted.\n\nNow Xiao Keke asks you to write a program to compute the number $d$ represented by the received $k$ and $p$.", "inputFormat": "A single line contains two positive integers $k$ and $p$, with $1 < k \\le 1024$, $1 \\le p \\le 1024$.", "outputFormat": "Output the answer in one line (the number of digits does not exceed $50$).", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2002] 网络传输", "background": "", "description": "在计算机网络中所有数据都是以二进制形式来传输的。但是在进行较大数据的传输时，直接使用该数的二进制形式加以传输则往往传输的位数过多。譬如要传输 $1024$ 就需要 $11$ 位二进制数。于是小可可提出了一种数据优化传输的设想，并打算对这一设想进行试验。\n\n该设想是：正整数的所有方幂以及任意多个互不相等的 $k$ 的方幂之和排成一个递增数列 $\\{a(k)n\\}$，例如当 $k=3$ 时，$\\{a(k)n\\}$ 的前 $7$ 项为 $1(=3^0)$ 、 $3(=3^1)$ 、 $4(=3^0+3^1)$ 、 $9(=3^2)$ 、 $10(=3^0+3^2)$ 、 $12(=3^1+3^2)$ 、 $13(=3^0+3^1+3^2)$。\n\n如果数 $d$ 是数列 $\\{a(k)n\\}$ 中的第 $p$ 项，则可以通过传送 $k$ 和 $p$ 这两个数来表示数 $d$。由于 $k$ 和 $p$ 这两个相对很小的数就可以表达出很大的数，因而理论上可以减少网络传输的位数。\n\n小可可现在请你编写程序把接收到的数 $k$ 和 $p$ 所代表的数 $d$ 计算出来。", "inputFormat": "文件中以一行的形式存放了两个正整数 $k$ 和 $p$，$1<k \\le 1024$，\n$1 \\le p \\le 1024$。", "outputFormat": "以一行的形式输出问题的解（解的位数不超过 $50$ 位）。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2559", "type": "P", "difficulty": 3, "samples": [["0 1 0 0 0 0 0\n1 4\n4\n1 2 1\n1 3 1\n2 4 2\n3 4 3", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2002", "各省省选", "安徽"], "title": "[AHOI2002] 哈利·波特与魔法石", "background": null, "description": "大年初三的那个晚上，小可可去电影院看了《哈利·波特与魔法石》，回到家坐在椅子上不一会儿就睡着了，并且梦见自己成了哈利·波特在充满了正义与邪恶的宇宙中执着地为了正义而战。  \n\n那天哈利·波特去拯救 Super Samuel 星球上的生灵。该星球上有七种不同的地形，依次分别是石子路、森林、草地、山地、雪地、沼泽和沙漠，用数字 $1\\sim7$ 来表示。任意两个城市之间都有至少一条道路，而且任意两个能够不经过别的城市而直接通达的城市 $i$ 和 $j$ 之间都只有一种地形 $t_{i,j}$。奇怪的是，在 Super Samuel 星球上哈利·波特穿越地形 $u$ 所需要的时间与该地形的区域大小无关，却与地形 $u$ 的区域中是否有魔法石有关。如果地形 $u$ 的区域中没有魔法石，哈利·波特要花费 $h_u$ 的时间才能穿越该区域，否则他只要花一半的时间就能穿越了。已知 $h_1=2, h_2=6, h_3=4, h_4=8, h_5=6, h_6=10, h_7=14$。\n\n- $s_u=1$ 表示地形 $u$ 的区域中有魔法石；\n- $s_u=0$ 表示地形 $u$ 的区域中没有魔法石。\n\n例如，如下图所示，有 $4$ 对可以直接通达的城市(城市 $1$ 与 $2$、$1$ 与 $3$、$2$ 与 $4$ 以及 $3$ 与 $4$)；$s_1=0, s_2=1, s_3=4, s_5=6, s_6=7$，即只有森林中有魔法石，因此穿越森林所花的时间是 $\\frac{6}{2}=3$，穿越石子路和草地的时间仍然是 $2$ 和 $4$。如果哈利·波特想从城市 $1$ 到达城市 $4$，则最快的路线是经过城市 $2$，这条路线需要的时间是 $2+3=5$。\n\n![graph](https://cdn.luogu.com.cn/upload/image_hosting/jepqly4c.png)\n\n哈利·波特总是忙于铲除邪恶、伸张正义，没有时间去寻找从起点城市到终点城市的路径。现在请你作为哈利·波特的助手编写程序来找到最快路线为哈利·波特腾出更多的时间来将正义事业进行到底。", "inputFormat": "第一行输入七个数，分别是 $S_1, S_2 ,\\dots, S_7$。\n\n第二行输入两个数，依次分别是起点城市 $i$ 和终点城市 $j$。\n\n第三行输入一个正整数 $c$（$c\\le10000$），随后的 $c$ 行中每行存放了一对能直接通达的城市的信息。能直接通达的城市的信息由三个数组成，依次分别是两个城市的编号和这两个城市之间的地形。城市的编号都是不超过 $100$ 的正整数，但是各个城市的编号未必连续。\n\n输入文件里同一行中相邻的两个数用一个空白字符隔开。", "outputFormat": "输出一行一个整数，表示起点城市 $i$ 与终点城市 $j$ 之间的最快路线所需要的时间。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2002] Harry Potter and the Sorcerer's Stone", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/pic/1681.png)", "inputFormat": "The first line of the input file contains seven numbers, namely $S_1, S_2, \\dots, S_7$. The second line contains two numbers: the starting city $i$ and the destination city $j$. The third line contains a positive integer $c$, with $c \\le 10000$, indicating that each of the following $c$ lines stores a pair of cities that are directly reachable from each other.\n\nThe information for a pair of directly reachable cities consists of three numbers: the indices of the two cities and the terrain type between these two cities. City indices are positive integers not exceeding $100$, but the indices are not necessarily continuous.\n\nOn the same line in the file, any two adjacent numbers are separated by a single whitespace character.", "outputFormat": "Output a single line with the time required by the fastest route between the starting city $i$ and the destination city $j$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2002] 哈利·波特与魔法石", "background": null, "description": "大年初三的那个晚上，小可可去电影院看了《哈利·波特与魔法石》，回到家坐在椅子上不一会儿就睡着了，并且梦见自己成了哈利·波特在充满了正义与邪恶的宇宙中执着地为了正义而战。  \n\n那天哈利·波特去拯救 Super Samuel 星球上的生灵。该星球上有七种不同的地形，依次分别是石子路、森林、草地、山地、雪地、沼泽和沙漠，用数字 $1\\sim7$ 来表示。任意两个城市之间都有至少一条道路，而且任意两个能够不经过别的城市而直接通达的城市 $i$ 和 $j$ 之间都只有一种地形 $t_{i,j}$。奇怪的是，在 Super Samuel 星球上哈利·波特穿越地形 $u$ 所需要的时间与该地形的区域大小无关，却与地形 $u$ 的区域中是否有魔法石有关。如果地形 $u$ 的区域中没有魔法石，哈利·波特要花费 $h_u$ 的时间才能穿越该区域，否则他只要花一半的时间就能穿越了。已知 $h_1=2, h_2=6, h_3=4, h_4=8, h_5=6, h_6=10, h_7=14$。\n\n- $s_u=1$ 表示地形 $u$ 的区域中有魔法石；\n- $s_u=0$ 表示地形 $u$ 的区域中没有魔法石。\n\n例如，如下图所示，有 $4$ 对可以直接通达的城市(城市 $1$ 与 $2$、$1$ 与 $3$、$2$ 与 $4$ 以及 $3$ 与 $4$)；$s_1=0, s_2=1, s_3=4, s_5=6, s_6=7$，即只有森林中有魔法石，因此穿越森林所花的时间是 $\\frac{6}{2}=3$，穿越石子路和草地的时间仍然是 $2$ 和 $4$。如果哈利·波特想从城市 $1$ 到达城市 $4$，则最快的路线是经过城市 $2$，这条路线需要的时间是 $2+3=5$。\n\n![graph](https://cdn.luogu.com.cn/upload/image_hosting/jepqly4c.png)\n\n哈利·波特总是忙于铲除邪恶、伸张正义，没有时间去寻找从起点城市到终点城市的路径。现在请你作为哈利·波特的助手编写程序来找到最快路线为哈利·波特腾出更多的时间来将正义事业进行到底。", "inputFormat": "第一行输入七个数，分别是 $S_1, S_2 ,\\dots, S_7$。\n\n第二行输入两个数，依次分别是起点城市 $i$ 和终点城市 $j$。\n\n第三行输入一个正整数 $c$（$c\\le10000$），随后的 $c$ 行中每行存放了一对能直接通达的城市的信息。能直接通达的城市的信息由三个数组成，依次分别是两个城市的编号和这两个城市之间的地形。城市的编号都是不超过 $100$ 的正整数，但是各个城市的编号未必连续。\n\n输入文件里同一行中相邻的两个数用一个空白字符隔开。", "outputFormat": "输出一行一个整数，表示起点城市 $i$ 与终点城市 $j$ 之间的最快路线所需要的时间。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2560", "type": "P", "difficulty": 4, "samples": [["3 2\n11000101\n10 10 5 6 3 2 1 2", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2002", "各省省选", "安徽"], "title": "[AHOI2002] Kitty猫基因突变", "background": "", "description": " ![](https://cdn.luogu.com.cn/upload/pic/1682.png) \n\n![](https://cdn.luogu.com.cn/upload/pic/1683.png)\n", "inputFormat": "![](https://cdn.luogu.com.cn/upload/pic/1684.png)\n", "outputFormat": "以一行的形式输出评价效果最好的突变方案的评价指标。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2002] Kitty Cat Gene Mutation", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/pic/1682.png) \n\n![](https://cdn.luogu.com.cn/upload/pic/1683.png)", "inputFormat": "![](https://cdn.luogu.com.cn/upload/pic/1684.png)", "outputFormat": "Output, in a single line, the evaluation metric of the mutation scheme with the best performance.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2002] Kitty猫基因突变", "background": "", "description": " ![](https://cdn.luogu.com.cn/upload/pic/1682.png) \n\n![](https://cdn.luogu.com.cn/upload/pic/1683.png)\n", "inputFormat": "![](https://cdn.luogu.com.cn/upload/pic/1684.png)\n", "outputFormat": "以一行的形式输出评价效果最好的突变方案的评价指标。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2561", "type": "P", "difficulty": 6, "samples": [["1", "2"], ["2", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "数学", "2002", "各省省选", "安徽", "置换"], "title": "[AHOI2002] 黑白瓷砖", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/pic/1685.png) \n\n![](https://cdn.luogu.com.cn/upload/pic/1686.png)\n", "inputFormat": "一行，一个正整数 $n$，$n \\leq 20$ 。\n", "outputFormat": "以一行的形式输出问题的解 $s$ (解的位数不超过 $200$ 位)。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2002] Black and White Tiles", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/pic/1685.png) \n\n![](https://cdn.luogu.com.cn/upload/pic/1686.png)", "inputFormat": "One line containing a positive integer $n$, where $n \\leq 20$.", "outputFormat": "Output, in one line, the solution $s$ (the number of digits of the answer does not exceed 200).", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2002] 黑白瓷砖", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/pic/1685.png) \n\n![](https://cdn.luogu.com.cn/upload/pic/1686.png)\n", "inputFormat": "一行，一个正整数 $n$，$n \\leq 20$ 。\n", "outputFormat": "以一行的形式输出问题的解 $s$ (解的位数不超过 $200$ 位)。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2562", "type": "P", "difficulty": 2, "samples": [["00", "A"], ["01001011", "CCCABACCBAB"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2002", "各省省选", "递归", "安徽"], "title": "[AHOI2002] Kitty猫基因编码", "background": null, "description": "小可可选修了基础生物基因学。教授告诉大家 Super Samuel 星球上 Kitty猫的基因的长度都是 $2$ 的正整数次幂，全是由两种不同的基因单元组成的。 这两种不同的基因单元分别记成 $0$ 和 $1$，于是 Kitty 猫基因可以写成一个 $01$ 串表达式 。\n\n为了便于分析和降低数据存储量，教授发明了 ABC 编码规则。该编码规则是不断地按照\n\n ![](https://cdn.luogu.com.cn/upload/pic/1679.png) \n\n对 Kitty 猫基因 $01$ 串表达式 进行改写， 直至最终被改写成只含有字符 “ A”、“ B”、“ C”的符号串。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1680.png) \n\n请你编写程序帮助小可可求出 Kitty 猫基因的 ABC 编码以协助教授开展科研工作。", "inputFormat": "文件中以一行的形式存放了一个 Kitty 猫基因的 $01$ 串表达式。", "outputFormat": "以一行的形式输出这个 Kitty 猫基因的 ABC 编码。", "hint": "给出的 $01$ 字符串长度 $Len\\leq 256$。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2002] Kitty Cat Gene Encoding", "background": "", "description": "Xiao Keke took an elective course in basic genetics. The professor told the class that on the planet Super Samuel, the lengths of Kitty cats’ genes are all positive integer powers of $2$, and they consist of two different gene units. These two different gene units are denoted as 0 and 1, so a Kitty cat’s gene can be written as a 01 string.\n\nTo facilitate analysis and reduce storage, the professor invented the ABC encoding rule. This encoding repeatedly rewrites the Kitty cat gene’s 01 string according to\n\n ![](https://cdn.luogu.com.cn/upload/pic/1679.png) \n\nuntil it is finally rewritten into a string containing only the characters \"A\", \"B\", and \"C\".\n\n ![](https://cdn.luogu.com.cn/upload/pic/1680.png) \n\nPlease write a program to help Xiao Keke compute the ABC encoding of a Kitty cat gene to assist the professor’s research.", "inputFormat": "The file contains one line, which is a 01 string representing a Kitty cat gene.", "outputFormat": "Output one line containing the ABC encoding of this Kitty cat gene.", "hint": "The given 01 string length satisfies $Len \\leq 256$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2002] Kitty猫基因编码", "background": null, "description": "小可可选修了基础生物基因学。教授告诉大家 Super Samuel 星球上 Kitty猫的基因的长度都是 $2$ 的正整数次幂，全是由两种不同的基因单元组成的。 这两种不同的基因单元分别记成 $0$ 和 $1$，于是 Kitty 猫基因可以写成一个 $01$ 串表达式 。\n\n为了便于分析和降低数据存储量，教授发明了 ABC 编码规则。该编码规则是不断地按照\n\n ![](https://cdn.luogu.com.cn/upload/pic/1679.png) \n\n对 Kitty 猫基因 $01$ 串表达式 进行改写， 直至最终被改写成只含有字符 “ A”、“ B”、“ C”的符号串。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1680.png) \n\n请你编写程序帮助小可可求出 Kitty 猫基因的 ABC 编码以协助教授开展科研工作。", "inputFormat": "文件中以一行的形式存放了一个 Kitty 猫基因的 $01$ 串表达式。", "outputFormat": "以一行的形式输出这个 Kitty 猫基因的 ABC 编码。", "hint": "给出的 $01$ 字符串长度 $Len\\leq 256$。", "locale": "zh-CN"}}}
{"pid": "P2563", "type": "P", "difficulty": 2, "samples": [["2\n200", "1\n9845164"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["2001", "各省省选", "安徽", "背包 DP", "素数判断,质数,筛法"], "title": "[AHOI2001] 质数和分解", "background": "", "description": "任何大于 $1$ 的自然数 $n$ 都可以写成若干个大于等于 $2$ 且小于等于 $n$ 的质数之和表达式(包括只有一个数构成的和表达式的情况)，并且可能有不止一种质数和的形式。例如，$9$ 的质数和表达式就有四种本质不同的形式：\n\n$9 = 2 + 5 + 2 = 2 + 3 + 2 + 2 = 3 + 3 + 3 = 2 + 7$ 。\n\n这里所谓两个本质相同的表达式是指可以通过交换其中一个表达式中参加和运算的各个数的位置而直接得到另一个表达式。\n\n试编程求解自然数 $n$ 可以写成多少种本质不同的质数和表达式。\n", "inputFormat": "文件中的每一行存放一个自然数 $n(2 \\leq n \\leq 200)$ 。\n", "outputFormat": "依次输出每一个自然数 $n$ 的本质不同的质数和表达式的数目。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2001] Prime Sum Decomposition", "background": "", "description": "Any natural number $n$ greater than $1$ can be written as a sum of primes each greater than or equal to $2$ and less than or equal to $n$ (including the case where the sum consists of only one number), and there may be more than one such prime-sum form. For example, the prime-sum expressions of $9$ have four essentially different forms:\n\n$9 = 2 + 5 + 2 = 2 + 3 + 2 + 2 = 3 + 3 + 3 = 2 + 7$。\n\nTwo expressions are considered essentially the same if one can be obtained from the other by permuting the addends.\n\nWrite a program to compute how many essentially different prime-sum expressions a natural number $n$ can have.", "inputFormat": "Each line of the file contains a natural number $n$ ($2 \\leq n \\leq 200$).", "outputFormat": "For each natural number $n$, output the number of essentially different prime-sum expressions.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2001] 质数和分解", "background": "", "description": "任何大于 $1$ 的自然数 $n$ 都可以写成若干个大于等于 $2$ 且小于等于 $n$ 的质数之和表达式(包括只有一个数构成的和表达式的情况)，并且可能有不止一种质数和的形式。例如，$9$ 的质数和表达式就有四种本质不同的形式：\n\n$9 = 2 + 5 + 2 = 2 + 3 + 2 + 2 = 3 + 3 + 3 = 2 + 7$ 。\n\n这里所谓两个本质相同的表达式是指可以通过交换其中一个表达式中参加和运算的各个数的位置而直接得到另一个表达式。\n\n试编程求解自然数 $n$ 可以写成多少种本质不同的质数和表达式。\n", "inputFormat": "文件中的每一行存放一个自然数 $n(2 \\leq n \\leq 200)$ 。\n", "outputFormat": "依次输出每一个自然数 $n$ 的本质不同的质数和表达式的数目。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2564", "type": "P", "difficulty": 4, "samples": [["6 3\n1 5\n2 1 7\n3 1 3 8\n", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "四川", "各省省选", "单调队列", "队列"], "title": "[SCOI2009] 生日礼物", "background": "四川2009NOI省选\n", "description": "\n小西有一条很长的彩带，彩带上挂着各式各样的彩珠。已知彩珠有 $N$ 个，分为 $K$ 种。简单的说，可以将彩带抽象为一个 x 轴，每一个彩珠有一个对应的坐标（即位置）。某些坐标上可以没有彩珠，但多个彩珠也可以出现在同一个位置上。\n\n小布的生日快到了，于是小西打算剪一段彩带送给小布。为了让礼物彩带足够漂亮，小西希望这一段彩带中能包含所有种类的彩珠。同时，为了方便，小西希望这段彩带尽可能短，你能帮助小西计算这个最短的长度么？\n\n彩带的长度即为彩带开始位置到结束位置的位置差。\n", "inputFormat": "第一行包含两个整数 $N, K$，分别表示彩珠的总数以及种类数。\n\n接下来 $K$ 行，每行第一个数为 $T_i$，表示第 $i$ 种彩珠的数目。\n\n接下来按升序给出 $T_i$ 个非负整数，为这 $T_i$ 个彩珠分别出现的位置。", "outputFormat": "输出应包含一行，为最短彩带长度。\n", "hint": "\n### 样例说明\n\n有多种方案可选，其中比较短的是 $1 \\sim 5$ 和 $5 \\sim 8$。后者长度为 $3$，更短，故答案为 $3$。\n\n### 数据范围\n\n对于 $50\\%$ 的数据，$N \\le 10^4$；\n\n对于 $80\\%$ 的数据，$N \\le 8 \\times 10^5$；\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10^6, 1 \\le K \\le 60$，$0 \\le$ 珠子位置 $< 2^{31}$，且 $\\sum T_i = N$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2009] Birthday Gift", "background": "Sichuan 2009 NOI Qualifier.", "description": "Xiaoxi has a very long ribbon with various colored beads hanging on it. There are $N$ beads in total, divided into $K$ types. Simply put, we can model the ribbon as the x-axis, and each bead corresponds to a coordinate (i.e., a position). Some coordinates may have no bead, and multiple beads may appear at the same position.\n\nXiaobu’s birthday is coming, so Xiaoxi plans to cut a segment of the ribbon as a gift. To make the gift look nice, she wants this segment to contain all types of beads. For convenience, she also wants the segment to be as short as possible. Can you help Xiaoxi find this minimum length?\n\nThe length of a ribbon segment is the difference between the end position and the start position.", "inputFormat": "The first line contains two integers $N, K$, the total number of beads and the number of types.\n\nFor each of the next $K$ lines, the first number is $T_i$, the count of beads of type $i$.\n\nOn the same line, $T_i$ non-negative integers are then given in ascending order, representing the positions where these $T_i$ beads appear.", "outputFormat": "Output a single line: the minimum possible ribbon length.", "hint": "Sample explanation:\nThere are multiple valid choices. Among the shorter ones are 1 ~ 5 and 5 ~ 8. The latter has length 3, which is shorter, so the answer is 3.\n\nConstraints:\n- For 50% of the testdata, $N \\le 10^4$.\n- For 80% of the testdata, $N \\le 8 \\times 10^5$.\n- For 100% of the testdata, $1 \\le N \\le 10^6, 1 \\le K \\le 60$, $0 \\le$ bead position $< 2^{31}$, and $\\sum T_i = N$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2009] 生日礼物", "background": "四川2009NOI省选\n", "description": "\n小西有一条很长的彩带，彩带上挂着各式各样的彩珠。已知彩珠有 $N$ 个，分为 $K$ 种。简单的说，可以将彩带抽象为一个 x 轴，每一个彩珠有一个对应的坐标（即位置）。某些坐标上可以没有彩珠，但多个彩珠也可以出现在同一个位置上。\n\n小布的生日快到了，于是小西打算剪一段彩带送给小布。为了让礼物彩带足够漂亮，小西希望这一段彩带中能包含所有种类的彩珠。同时，为了方便，小西希望这段彩带尽可能短，你能帮助小西计算这个最短的长度么？\n\n彩带的长度即为彩带开始位置到结束位置的位置差。\n", "inputFormat": "第一行包含两个整数 $N, K$，分别表示彩珠的总数以及种类数。\n\n接下来 $K$ 行，每行第一个数为 $T_i$，表示第 $i$ 种彩珠的数目。\n\n接下来按升序给出 $T_i$ 个非负整数，为这 $T_i$ 个彩珠分别出现的位置。", "outputFormat": "输出应包含一行，为最短彩带长度。\n", "hint": "\n### 样例说明\n\n有多种方案可选，其中比较短的是 $1 \\sim 5$ 和 $5 \\sim 8$。后者长度为 $3$，更短，故答案为 $3$。\n\n### 数据范围\n\n对于 $50\\%$ 的数据，$N \\le 10^4$；\n\n对于 $80\\%$ 的数据，$N \\le 8 \\times 10^5$；\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10^6, 1 \\le K \\le 60$，$0 \\le$ 珠子位置 $< 2^{31}$，且 $\\sum T_i = N$。", "locale": "zh-CN"}}}
{"pid": "P2565", "type": "P", "difficulty": 6, "samples": [["3 3\n2 3 1\n", "1 6 8\n3 5 7\n2 4 9\n"], ["3 4\n2 1 2\n", "0\n"], ["3 4\n2 3 1\n", "1 3 10 11\n2 7 8 9\n4 5 6 12\n"], ["4 4\n4 1 2 3\n", "1 11 8 14\n12 15 2 5\n3 6 16 9\n4 10 13 7\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "贪心", "2009", "四川", "各省省选", "Special Judge", "置换"], "title": "[SCOI2009] 骰子的学问", "background": "", "description": "小鱼儿是个数学天才。一天晚上他研究一个和字符串有关的 penney-ante 游戏。游戏的规则如下：\n\n1. 有两个玩家，开始时每人选择一个长度相同的字符串；\n\n2. 一个字符生成器不断的随机生成字母添加到字符串 $S$ 的末尾，$S$ 初始为空串；\n\n3. 如果 $S$ 包含了某个玩家选择的字符串则游戏结束，该玩家获胜。\n\n假设玩家 1 和玩家 2 分别选择了两个字符串 $A$ 和 $B$，如果玩家 1 可以以较大概率战胜玩家 2，我们记作 $A>B$。咋一看来，小鱼儿觉得如果 $A>B$ 且 $B>C$ 则 $A>C$。可事实恰好相反，存在字符串 $A, B, C$ 使得 $A>B, B>C, C>A$。\n\n\n小鱼儿被这种戏的一个反常现象所吸引，通过查阅资料，他了解到这种现象被称为“非传递性悖论”，在许多非完全信息游戏（比如军棋）中，经常会有这样的例子。可是它到底是如何产生的呢？小鱼儿决定设计一种游戏，从中可以容易的找到非传递的例子，以便更清楚的认识“非传递性”。当然，这样的游戏越简单道理越深刻，于是小鱼儿想起了最简单的掷骰子游戏……\n\n\n这个游戏是这样的，假设有 $n$ 个骰子 $D_1,\\dots,D_n$，每个骰子有 $m$ 个面。每个面上标有一个 $1,2,\\dots,n\\times m$ 的正整数，并且所有骰子的所有 $n\\times m$ 个面上的数字各不相同。满足这条编号要求，并且每个面被随到的概率相等的，这样的 $n$ 个骰子称为一组“好骰子”。游戏开始时，两个玩家分别选两个骰子 $D_i$ 和 $D_j$，各掷一次来比较掷出来那一面的数值，数大的获胜。\n\n\n小鱼儿请你帮忙设计一组“好骰子”，使得对任意一个骰子 $D_i$，它总能战胜 $D_{a_i}$。此处战胜是指选择前者的玩家获胜的概率超过 $1/2$；$a_1,a_2,\\dots,a_n$ 为输入的 $1\\sim n$ 的正整数。", "inputFormat": "第一行为两个整数 $n, m$。第二行有 $n$ 个整数，为 $a_1,a_2,\\dots,a_n$。", "outputFormat": "包含 $n$ 行，每行 $m$ 个 $1\\sim n\\times m$ 的正整数，各不相同，以空格分开。\n\n如果有多解，输出任意一组解；如果无解，输出一个整数 $0$。", "hint": "$30\\%$ 的数据满足 $n, m\\le 10$。\n\n$100\\%$的数据满足 $3\\le n, m\\le200$。\n\n感谢 @cn：苏卿念 提供 spj。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2009] The Knowledge of Dice", "background": "", "description": "Xiao Yu'er is a math genius. One night he studied a Penney-ante game related to strings. The rules are as follows:\n\n1. There are two players. At the beginning, each chooses a string of the same length.\n2. A character generator keeps randomly generating letters and appending them to the end of string $S$, which is initially empty.\n3. If $S$ contains the string chosen by a player, the game ends and that player wins.\n\nSuppose players 1 and 2 choose strings $A$ and $B$ respectively. If player 1 can defeat player 2 with higher probability, we write $A > B$. At first glance, Xiao Yu'er thought that if $A > B$ and $B > C$ then $A > C$. However, the opposite is true: there exist strings $A, B, C$ such that $A > B$, $B > C$, and $C > A$.\n\nXiao Yu'er was fascinated by this counterintuitive phenomenon. From the literature, he learned that this is called the \"non-transitivity paradox\", which often appears in many imperfect-information games (such as military chess). But how does it arise? Xiao Yu'er decided to design a game in which it is easy to find non-transitive examples, to better understand \"non-transitivity\". Of course, the simpler the game, the deeper the idea; thus Xiao Yu'er thought of the simplest dice-rolling game.\n\nThe game is as follows. Assume there are $n$ dice $D_1, \\dots, D_n$, each with $m$ faces. Each face is labeled with a positive integer from $1$ to $n \\times m$, and across all dice, the $n \\times m$ faces have pairwise distinct labels. If the above labeling requirement is satisfied and each face is equally likely to be rolled, such $n$ dice are called a set of \"good dice\". At the start of the game, the two players choose two dice $D_i$ and $D_j$; they each roll once and compare the numbers on the rolled faces, and the larger number wins.\n\nXiao Yu'er asks you to design a set of \"good dice\" such that for every die $D_i$, it always beats $D_{a_i}$. Here, \"beat\" means the probability that the player choosing the former wins exceeds $1/2$; $a_1, a_2, \\dots, a_n$ are the input integers in $1 \\sim n$.", "inputFormat": "The first line contains two integers $n, m$. The second line contains $n$ integers, namely $a_1, a_2, \\dots, a_n$.", "outputFormat": "Output $n$ lines, each containing $m$ distinct integers in $1 \\sim n \\times m$, separated by spaces.\n\nIf there are multiple solutions, output any one of them. If there is no solution, output a single integer $0$.", "hint": "- 30% of the testdata satisfies $n, m \\le 10$.\n- 100% of the testdata satisfies $3 \\le n, m \\le 200$.\n\nThanks to @cn: 苏卿念 for providing the SPJ.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2009] 骰子的学问", "background": "", "description": "小鱼儿是个数学天才。一天晚上他研究一个和字符串有关的 penney-ante 游戏。游戏的规则如下：\n\n1. 有两个玩家，开始时每人选择一个长度相同的字符串；\n\n2. 一个字符生成器不断的随机生成字母添加到字符串 $S$ 的末尾，$S$ 初始为空串；\n\n3. 如果 $S$ 包含了某个玩家选择的字符串则游戏结束，该玩家获胜。\n\n假设玩家 1 和玩家 2 分别选择了两个字符串 $A$ 和 $B$，如果玩家 1 可以以较大概率战胜玩家 2，我们记作 $A>B$。咋一看来，小鱼儿觉得如果 $A>B$ 且 $B>C$ 则 $A>C$。可事实恰好相反，存在字符串 $A, B, C$ 使得 $A>B, B>C, C>A$。\n\n\n小鱼儿被这种戏的一个反常现象所吸引，通过查阅资料，他了解到这种现象被称为“非传递性悖论”，在许多非完全信息游戏（比如军棋）中，经常会有这样的例子。可是它到底是如何产生的呢？小鱼儿决定设计一种游戏，从中可以容易的找到非传递的例子，以便更清楚的认识“非传递性”。当然，这样的游戏越简单道理越深刻，于是小鱼儿想起了最简单的掷骰子游戏……\n\n\n这个游戏是这样的，假设有 $n$ 个骰子 $D_1,\\dots,D_n$，每个骰子有 $m$ 个面。每个面上标有一个 $1,2,\\dots,n\\times m$ 的正整数，并且所有骰子的所有 $n\\times m$ 个面上的数字各不相同。满足这条编号要求，并且每个面被随到的概率相等的，这样的 $n$ 个骰子称为一组“好骰子”。游戏开始时，两个玩家分别选两个骰子 $D_i$ 和 $D_j$，各掷一次来比较掷出来那一面的数值，数大的获胜。\n\n\n小鱼儿请你帮忙设计一组“好骰子”，使得对任意一个骰子 $D_i$，它总能战胜 $D_{a_i}$。此处战胜是指选择前者的玩家获胜的概率超过 $1/2$；$a_1,a_2,\\dots,a_n$ 为输入的 $1\\sim n$ 的正整数。", "inputFormat": "第一行为两个整数 $n, m$。第二行有 $n$ 个整数，为 $a_1,a_2,\\dots,a_n$。", "outputFormat": "包含 $n$ 行，每行 $m$ 个 $1\\sim n\\times m$ 的正整数，各不相同，以空格分开。\n\n如果有多解，输出任意一组解；如果无解，输出一个整数 $0$。", "hint": "$30\\%$ 的数据满足 $n, m\\le 10$。\n\n$100\\%$的数据满足 $3\\le n, m\\le200$。\n\n感谢 @cn：苏卿念 提供 spj。", "locale": "zh-CN"}}}
{"pid": "P2566", "type": "P", "difficulty": 6, "samples": [["3 8\r\n3\r\n30 -100 30\r\n00000000\r\n010203#0\r\n00000000\r\n", "38"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "四川", "各省省选", "状压 DP"], "title": "[SCOI2009] 围豆豆", "background": "四川 NOI2009 省选", "description": "是不是平时在手机里玩吃豆豆游戏玩腻了呢？最近 MOKIA 手机上推出了一种新的围豆豆游戏，大家一起来试一试吧。\n\n\n游戏的规则非常简单，在一个 $N\\times M$ 的矩阵方格内分布着 $D$ 颗豆子，每颗豆有不同的分值 $V_i$。游戏者可以选择任意一个方格作为起始格，每次移动可以随意的走到相邻的四个格子，直到最终又回到起始格。最终游戏者的得分为所有被路径围住的豆豆的分值总和减去游戏者移动的步数。矩阵中某些格子内设有障碍物，任何时刻游戏者不能进入包含障碍物或豆子的格子。游戏者可能的最低得分为 $0$，即什么都不做。\n\n\n注意路径包围的概念，即某一颗豆在路径所形成的多边形（可能是含自交的复杂多边形）的内部。下面有两个例子：\n\n \n ![](https://cdn.luogu.com.cn/upload/pic/1690.png) \n\n第一个例子中，豆在路径围成的矩形内部，所以豆被围住了。第二个例子中，虽然路径经过了豆的周围的 $8$ 个格子，但是路径形成的多边形内部并不包含豆，所以没有围住豆子。\n\n布布最近迷上了这款游戏，但是怎么玩都拿不了高分。聪明的你决定写一个程序来帮助他顺利通关。", "inputFormat": "第一行两个整数 $N$ 和 $M$，为矩阵的边长。\n\n第二行一个整数 $D$，为豆子的总个数。\n\n第三行包含 $D$ 个整数 $V_1$ 到 $V_D$，分别为每颗豆子的分值。\n\n接着 $N$ 行有一个 $N\\times M$ 的字符矩阵来描述游戏矩阵状态，`0` 表示空格，`#` 表示障碍物。而数字 `1` 到 `9` 分别表示对应编号的豆子。", "outputFormat": "仅包含一个整数，为最高可能获得的分值。", "hint": "$50\\%$ 的数据满足 $1\\le D\\le 3$。\n\n$100\\%$ 的数据满足 $1\\le D\\le 9$，$1\\le N,M\\le 10$，$-10^4\\le V_i\\le 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2009] Enclosing Beans", "background": "Sichuan NOI2009 NOI Qualifier.", "description": "Are you tired of playing Pac-Man on your phone? Recently, the MOKIA phone launched a new game called “Enclosing Beans.” Give it a try.\n\nThe rules are simple. In an $N\\times M$ grid there are $D$ beans, and each bean has a value $V_i$. The player may choose any cell as the starting cell. Each move, the player may go to one of the four orthogonally adjacent cells, and eventually must return to the starting cell. The final score is the total value of all beans enclosed by the path minus the number of steps taken. Some cells contain obstacles; at no time may the player enter a cell that contains an obstacle or a bean. The player’s minimum possible score is $0$, i.e., they may choose to do nothing.\n\nNote the notion of being enclosed: a bean is considered enclosed if it lies inside the polygon formed by the path (which may be a complex polygon with self-intersections). See the two examples below:\n\n![](https://cdn.luogu.com.cn/upload/pic/1690.png)\n\nIn the first example, the bean lies inside the rectangle formed by the path, so it is enclosed. In the second example, even though the path visits the $8$ neighboring cells around the bean, the interior of the polygon formed by the path does not contain the bean, so it is not enclosed.\n\nBubu has become obsessed with this game but cannot get a high score. You decide to write a program to help him pass the game.", "inputFormat": "The first line contains two integers $N$ and $M$, the dimensions of the grid.\n\nThe second line contains an integer $D$, the total number of beans.\n\nThe third line contains $D$ integers $V_1$ to $V_D$, the values of the beans.\n\nThen follow $N$ lines, each with $M$ characters, forming an $N\\times M$ character matrix describing the game grid. Character `0` denotes an empty cell, `#` denotes an obstacle, and digits `1` to `9` denote beans with the corresponding indices.", "outputFormat": "Output a single integer, the maximum possible score.", "hint": "$50\\%$ of the testdata satisfies $1\\le D\\le 3$.\n\n$100\\%$ of the testdata satisfies $1\\le D\\le 9$, $1\\le N,M\\le 10$, $-10^4\\le V_i\\le 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2009] 围豆豆", "background": "四川 NOI2009 省选", "description": "是不是平时在手机里玩吃豆豆游戏玩腻了呢？最近 MOKIA 手机上推出了一种新的围豆豆游戏，大家一起来试一试吧。\n\n\n游戏的规则非常简单，在一个 $N\\times M$ 的矩阵方格内分布着 $D$ 颗豆子，每颗豆有不同的分值 $V_i$。游戏者可以选择任意一个方格作为起始格，每次移动可以随意的走到相邻的四个格子，直到最终又回到起始格。最终游戏者的得分为所有被路径围住的豆豆的分值总和减去游戏者移动的步数。矩阵中某些格子内设有障碍物，任何时刻游戏者不能进入包含障碍物或豆子的格子。游戏者可能的最低得分为 $0$，即什么都不做。\n\n\n注意路径包围的概念，即某一颗豆在路径所形成的多边形（可能是含自交的复杂多边形）的内部。下面有两个例子：\n\n \n ![](https://cdn.luogu.com.cn/upload/pic/1690.png) \n\n第一个例子中，豆在路径围成的矩形内部，所以豆被围住了。第二个例子中，虽然路径经过了豆的周围的 $8$ 个格子，但是路径形成的多边形内部并不包含豆，所以没有围住豆子。\n\n布布最近迷上了这款游戏，但是怎么玩都拿不了高分。聪明的你决定写一个程序来帮助他顺利通关。", "inputFormat": "第一行两个整数 $N$ 和 $M$，为矩阵的边长。\n\n第二行一个整数 $D$，为豆子的总个数。\n\n第三行包含 $D$ 个整数 $V_1$ 到 $V_D$，分别为每颗豆子的分值。\n\n接着 $N$ 行有一个 $N\\times M$ 的字符矩阵来描述游戏矩阵状态，`0` 表示空格，`#` 表示障碍物。而数字 `1` 到 `9` 分别表示对应编号的豆子。", "outputFormat": "仅包含一个整数，为最高可能获得的分值。", "hint": "$50\\%$ 的数据满足 $1\\le D\\le 3$。\n\n$100\\%$ 的数据满足 $1\\le D\\le 9$，$1\\le N,M\\le 10$，$-10^4\\le V_i\\le 10^4$。", "locale": "zh-CN"}}}
{"pid": "P2567", "type": "P", "difficulty": 5, "samples": [["1 10", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2010", "四川", "各省省选", "深度优先搜索 DFS", "剪枝", "容斥原理"], "title": "[SCOI2010] 幸运数字", "background": "四川 NOI 省选 2010。\n", "description": "在中国，很多人都把 $6$ 和 $8$ 视为是幸运数字！lxhgww 也这样认为，于是他定义自己的“幸运号码”是十进制表示中只包含数字 $6$ 和 $8$ 的那些号码，比如 $68$，$666$，$888$ 都是“幸运号码”！但是这种“幸运号码”总是太少了，比如在 $[1,100]$ 的区间内就只有 $6$ 个（$6$，$8$，$66$，$68$，$86$，$88$），于是他又定义了一种“近似幸运号码”。lxhgww 规定，凡是“幸运号码”的倍数都是“近似幸运号码”，当然，任何的“幸运号码”也都是“近似幸运号码”，比如 $12$，$16$，$666$ 都是“近似幸运号码”。\n\n现在 lxhgww 想知道在一段闭区间 $[a, b]$ 内，“近似幸运号码”的个数。", "inputFormat": "输入数据是一行，包括 $2$ 个数字 $a$ 和 $b$。", "outputFormat": "输出数据是一行，包括 $1$ 个数字，表示在闭区间 $[a, b]$ 内“近似幸运号码”的个数。", "hint": "对于 $30\\%$ 的数据，保证 $1\\le a\\le b\\le10^6$。\n\n对于 $100\\%$ 的数据，保证 $1\\le a\\le b\\le10^{10}$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2010] Lucky Numbers", "background": "Sichuan NOI Qualifier 2010.", "description": "In China, many people consider $6$ and $8$ to be lucky numbers. lxhgww thinks so too, so he defines his own \"lucky numbers\" as those whose decimal representation contains only the digits $6$ and $8$. For example, $68$, $666$, and $888$ are all \"lucky numbers\". However, there are too few such \"lucky numbers\"; for instance, in the interval $[1,100]$ there are only $6$ of them ($6$, $8$, $66$, $68$, $86$, $88$). Therefore, he further defines \"almost lucky numbers\": any multiple of a \"lucky number\" is an \"almost lucky number\". Of course, any \"lucky number\" is also an \"almost lucky number\". For example, $12$, $16$, and $666$ are all \"almost lucky numbers\".\n\nNow lxhgww wants to know how many \"almost lucky numbers\" there are in a closed interval $[a, b]$.", "inputFormat": "The input is a single line containing $2$ numbers $a$ and $b$.", "outputFormat": "Output a single line containing $1$ number, the count of \"almost lucky numbers\" in the closed interval $[a, b]$.", "hint": "For $30\\%$ of the testdata, it is guaranteed that $1 \\le a \\le b \\le 10^6$.\n\nFor $100\\%$ of the testdata, it is guaranteed that $1 \\le a \\le b \\le 10^{10}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2010] 幸运数字", "background": "四川 NOI 省选 2010。\n", "description": "在中国，很多人都把 $6$ 和 $8$ 视为是幸运数字！lxhgww 也这样认为，于是他定义自己的“幸运号码”是十进制表示中只包含数字 $6$ 和 $8$ 的那些号码，比如 $68$，$666$，$888$ 都是“幸运号码”！但是这种“幸运号码”总是太少了，比如在 $[1,100]$ 的区间内就只有 $6$ 个（$6$，$8$，$66$，$68$，$86$，$88$），于是他又定义了一种“近似幸运号码”。lxhgww 规定，凡是“幸运号码”的倍数都是“近似幸运号码”，当然，任何的“幸运号码”也都是“近似幸运号码”，比如 $12$，$16$，$666$ 都是“近似幸运号码”。\n\n现在 lxhgww 想知道在一段闭区间 $[a, b]$ 内，“近似幸运号码”的个数。", "inputFormat": "输入数据是一行，包括 $2$ 个数字 $a$ 和 $b$。", "outputFormat": "输出数据是一行，包括 $1$ 个数字，表示在闭区间 $[a, b]$ 内“近似幸运号码”的个数。", "hint": "对于 $30\\%$ 的数据，保证 $1\\le a\\le b\\le10^6$。\n\n对于 $100\\%$ 的数据，保证 $1\\le a\\le b\\le10^{10}$。\n", "locale": "zh-CN"}}}
{"pid": "P2568", "type": "P", "difficulty": 5, "samples": [["4", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["素数判断,质数,筛法", "前缀和", "欧拉函数"], "title": "GCD", "background": null, "description": "给定正整数 $n$，求 $1\\le x,y\\le n$ 且 $\\gcd(x,y)$ 为素数的数对 $(x,y)$ 有多少对。", "inputFormat": "只有一行一个整数，代表 $n$。", "outputFormat": "一行一个整数表示答案。", "hint": "#### 样例输入输出 1 解释\n\n对于样例，满足条件的 $(x,y)$ 为 $(2,2)$，$(2,4)$，$(3,3)$，$(4,2)$。\n\n---\n\n#### 数据规模与约定\n\n- 对于 $100\\%$ 的数据，保证 $1\\le n\\le10^7$。\n\n---\n\n来源：bzoj2818。\n\n本题数据为洛谷自造数据，使用 [CYaRon](https://github.com/luogu-dev/cyaron) 耗时 $5$ 分钟完成数据制作。", "locale": "zh-CN", "translations": {"en": {"title": "GCD", "background": "", "description": "Given a positive integer $n$, count the number of pairs $(x, y)$ such that $1\\le x, y\\le n$ and $\\gcd(x,y)$ is a prime number.", "inputFormat": "A single line containing one integer representing $n$.", "outputFormat": "Output a single integer in one line, representing the answer.", "hint": "#### Sample Input/Output 1 Explanation\n\nFor the sample, the pairs $(x, y)$ that satisfy the condition are $(2, 2)$, $(2, 4)$, $(3, 3)$, $(4, 2)$.\n\n---\n\n#### Constraints\n\n- For $100\\%$ of the testdata, it is guaranteed that $1\\le n\\le 10^7$.\n\n---\n\nSource: bzoj2818.\n\nThe testdata for this problem are self-made by Luogu, generated using [CYaRon](https://github.com/luogu-dev/cyaron), taking 5 minutes.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "GCD", "background": null, "description": "给定正整数 $n$，求 $1\\le x,y\\le n$ 且 $\\gcd(x,y)$ 为素数的数对 $(x,y)$ 有多少对。", "inputFormat": "只有一行一个整数，代表 $n$。", "outputFormat": "一行一个整数表示答案。", "hint": "#### 样例输入输出 1 解释\n\n对于样例，满足条件的 $(x,y)$ 为 $(2,2)$，$(2,4)$，$(3,3)$，$(4,2)$。\n\n---\n\n#### 数据规模与约定\n\n- 对于 $100\\%$ 的数据，保证 $1\\le n\\le10^7$。\n\n---\n\n来源：bzoj2818。\n\n本题数据为洛谷自造数据，使用 [CYaRon](https://github.com/luogu-dev/cyaron) 耗时 $5$ 分钟完成数据制作。", "locale": "zh-CN"}}}
{"pid": "P2569", "type": "P", "difficulty": 5, "samples": [["5 2 0\n2 1 1 1\n2 1 1 1\n3 2 1 1\n4 3 1 1\n5 4 1 1\n", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2010", "四川", "各省省选", "单调队列", "队列"], "title": "[SCOI2010] 股票交易", "background": "", "description": "最近 $\\text{lxhgww}$ 又迷上了投资股票，通过一段时间的观察和学习，他总结出了股票行情的一些规律。\n\n通过一段时间的观察，$\\text{lxhgww}$ 预测到了未来 $T$ 天内某只股票的走势，第 $i$ 天的股票买入价为每股 $AP_i$，第 $i$ 天的股票卖出价为每股 $BP_i$（数据保证对于每个 $i$，都有 $AP_i \\geq BP_i$），但是每天不能无限制地交易，于是股票交易所规定第 $i$ 天的一次买入至多只能购买 $AS_i$ 股，一次卖出至多只能卖出 $BS_i$ 股。\n\n另外，股票交易所还制定了两个规定。为了避免大家疯狂交易，股票交易所规定在两次交易（某一天的买入或者卖出均算是一次交易）之间，至少要间隔 $W$ 天，也就是说如果在第 $i$ 天发生了交易，那么从第 $i+1$ 天到第 $i+W$ 天，均不能发生交易。同时，为了避免垄断，股票交易所还规定在任何时间，一个人的手里的股票数不能超过 $\\text{MaxP}$。\n\n在第 $1$ 天之前，$\\text{lxhgww}$ 手里有一大笔钱（可以认为钱的数目无限），但是没有任何股票，当然，$T$ 天以后，$\\text{lxhgww}$ 想要赚到最多的钱，聪明的程序员们，你们能帮助他吗？\n\n", "inputFormat": "输入数据第一行包括 $3$ 个整数，分别是 $T$，$\\text{MaxP}$，$W$。\n\n接下来 $T$ 行，第 $i$ 行代表第 $i-1$ 天的股票走势，每行 $4$ 个整数，分别表示 $AP_i,\\ BP_i,\\ AS_i,\\ BS_i$。", "outputFormat": "输出数据为一行，包括 $1$ 个数字，表示 $\\text{lxhgww}$ 能赚到的最多的钱数。", "hint": "- 对于 $30\\%$ 的数据，$0\\leq W<T\\leq 50,1\\leq\\text{MaxP}\\leq50$；\n- 对于 $50\\%$ 的数据，$0\\leq W<T\\leq 2000,1\\leq\\text{MaxP}\\leq50$；\n- 对于 $100\\%$ 的数据，$0\\leq W<T\\leq 2000,1\\leq\\text{MaxP}\\leq2000$；\n- 对于所有的数据，$1\\leq BP_i\\leq AP_i\\leq 1000,1\\leq AS_i,BS_i\\leq\\text{MaxP}$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2010] Stock Trading", "background": "", "description": "Recently, $\\text{lxhgww}$ has gotten into stock investing again. After a period of observation and learning, he summarized some patterns in stock prices.\n\nOver time, $\\text{lxhgww}$ predicted the movement of a certain stock for the next $T$ days. On day $i$, the buy price per share is $AP_i$, and the sell price per share is $BP_i$ (the data guarantees that for every $i$, $AP_i \\geq BP_i$). However, trading cannot be unrestricted each day, so the exchange stipulates that in a single buy on day $i$, you can purchase at most $AS_i$ shares, and in a single sell on day $i$, you can sell at most $BS_i$ shares.\n\nIn addition, the exchange has two more rules. To avoid excessive trading, the exchange requires that between any two transactions (a buy or a sell on any day counts as one transaction), there must be at least $W$ days in between. That is, if a transaction occurs on day $i$, then from day $i+1$ to day $i+W$ (inclusive), no transactions are allowed. Also, to prevent monopolies, the exchange mandates that at any time, the number of shares a person holds cannot exceed $\\text{MaxP}$.\n\nBefore day $1$, $\\text{lxhgww}$ has a large amount of cash (consider it as unlimited cash), but no stock. Of course, after $T$ days, $\\text{lxhgww}$ wants to earn as much money as possible. Smart programmers, can you help him?", "inputFormat": "The first line of input contains $3$ integers: $T$, $\\text{MaxP}$, and $W$.\n\nThe next $T$ lines describe the stock data. The $i$-th line corresponds to day $i$ and contains $4$ integers, namely $AP_i,\\ BP_i,\\ AS_i,\\ BS_i$.", "outputFormat": "Output a single number: the maximum amount of money $\\text{lxhgww}$ can earn.", "hint": "- For 30% of the testdata, $0 \\leq W < T \\leq 50$, $1 \\leq \\text{MaxP} \\leq 50$.\n- For 50% of the testdata, $0 \\leq W < T \\leq 2000$, $1 \\leq \\text{MaxP} \\leq 50$.\n- For 100% of the testdata, $0 \\leq W < T \\leq 2000$, $1 \\leq \\text{MaxP} \\leq 2000$.\n- For all testdata, $1 \\leq BP_i \\leq AP_i \\leq 1000$, $1 \\leq AS_i,BS_i \\leq \\text{MaxP}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2010] 股票交易", "background": "", "description": "最近 $\\text{lxhgww}$ 又迷上了投资股票，通过一段时间的观察和学习，他总结出了股票行情的一些规律。\n\n通过一段时间的观察，$\\text{lxhgww}$ 预测到了未来 $T$ 天内某只股票的走势，第 $i$ 天的股票买入价为每股 $AP_i$，第 $i$ 天的股票卖出价为每股 $BP_i$（数据保证对于每个 $i$，都有 $AP_i \\geq BP_i$），但是每天不能无限制地交易，于是股票交易所规定第 $i$ 天的一次买入至多只能购买 $AS_i$ 股，一次卖出至多只能卖出 $BS_i$ 股。\n\n另外，股票交易所还制定了两个规定。为了避免大家疯狂交易，股票交易所规定在两次交易（某一天的买入或者卖出均算是一次交易）之间，至少要间隔 $W$ 天，也就是说如果在第 $i$ 天发生了交易，那么从第 $i+1$ 天到第 $i+W$ 天，均不能发生交易。同时，为了避免垄断，股票交易所还规定在任何时间，一个人的手里的股票数不能超过 $\\text{MaxP}$。\n\n在第 $1$ 天之前，$\\text{lxhgww}$ 手里有一大笔钱（可以认为钱的数目无限），但是没有任何股票，当然，$T$ 天以后，$\\text{lxhgww}$ 想要赚到最多的钱，聪明的程序员们，你们能帮助他吗？\n\n", "inputFormat": "输入数据第一行包括 $3$ 个整数，分别是 $T$，$\\text{MaxP}$，$W$。\n\n接下来 $T$ 行，第 $i$ 行代表第 $i-1$ 天的股票走势，每行 $4$ 个整数，分别表示 $AP_i,\\ BP_i,\\ AS_i,\\ BS_i$。", "outputFormat": "输出数据为一行，包括 $1$ 个数字，表示 $\\text{lxhgww}$ 能赚到的最多的钱数。", "hint": "- 对于 $30\\%$ 的数据，$0\\leq W<T\\leq 50,1\\leq\\text{MaxP}\\leq50$；\n- 对于 $50\\%$ 的数据，$0\\leq W<T\\leq 2000,1\\leq\\text{MaxP}\\leq50$；\n- 对于 $100\\%$ 的数据，$0\\leq W<T\\leq 2000,1\\leq\\text{MaxP}\\leq2000$；\n- 对于所有的数据，$1\\leq BP_i\\leq AP_i\\leq 1000,1\\leq AS_i,BS_i\\leq\\text{MaxP}$。", "locale": "zh-CN"}}}
{"pid": "P2570", "type": "P", "difficulty": 6, "samples": [["2\n2 2\n13 0 4\n10 1 3\n4\n2\n1 1\n1 0 2\n1\n", "0.5\n0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "二分", "各省省选", "网络流", "浙江", "Special Judge"], "title": "[ZJOI2010] 贪吃的老鼠", "background": "", "description": "奶酪店里最近出现了 $m$ 只老鼠！它们的目标就是把生产出来的所有奶酪都吃掉。奶酪店中一天会生产 $n$ 块奶酪，其中第 $i$ 块的大小为 $p_i$，会在第 $r_i$ 秒被生产出来，并且必须在第 $d_i$ 秒之前将它吃掉。第 $j$ 只老鼠吃奶酪的速度为 $s_j$，因此如果它单独吃完第 $i$ 块奶酪所需的时间为 $p_i/s_j$。老鼠们吃奶酪的习惯很独特，具体来说：\n\n1. 在任一时刻，一只老鼠最多可以吃一块奶酪；\n2. 在任一时刻，一块奶酪最多被一只老鼠吃。\n\n由于奶酪的保质期常常很短，为了将它们全部吃掉，老鼠们需要使用一种神奇的魔法来延长奶酪的保质期。将奶酪的保质期延长 $T$ 秒是指所有的奶酪的 $d_i$ 变成 $d_i+T$。同时，使用魔法的代价很高，因此老鼠们希望找到最小的 $T$ 使得可以吃掉所有的奶酪。", "inputFormat": "输入文件的第一行包含一个整数 $K$，表示输入文件中数据的组数。\n\n每组数据的第一行包含两个整数 $n$ 和 $m$，分别表示奶酪和老鼠的数量。接下来的 $n$ 行每行包含三个整数 $p_i,r_i,d_i$。最后 $m$ 行每行包含一个整数，表示 $s_j$。$p_i,r_i,d_i,s_j$ 的含义如上文所述。", "outputFormat": "包含 $K$ 行，每行包含一个实数，表示你找到的最小的 $T$。你的答案和标准答案的绝对误差不应超过 $10^{-4}$。", "hint": "### 样例说明\n\n第一组数据中：\n\n第 $0$ 到第 $1$ 秒：\n\n第一只老鼠吃第一块奶酪；\n\n第 $1$ 到第 $3.5$ 秒：\n\n- 第一只老鼠吃第二块奶酪；\n- 第二只老鼠吃第一块奶酪；\n\n第 $3.5$ 到第 $4.5$ 秒：第一只老鼠吃第一块奶酪。\n\n### 数据规模\n\n$30\\%$ 的数据中，$1 \\le n,m \\le 5$；\n\n$100\\%$ 的数据中，$1 \\le K \\le 5$，$1 \\le n,m \\le 30$，$1 \\le p_i \\le 10^5$，$0 \\le r_i<d_i \\le 10^7$，$1 \\le s_j \\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2010] The Gluttonous Mice", "background": "", "description": "Recently, $m$ mice have appeared in the cheese shop. Their goal is to eat all the cheese produced. The shop produces $n$ pieces of cheese per day. The $i$-th piece has size $p_i$, is produced at second $r_i$, and must be eaten before second $d_i$. Mouse $j$ eats at speed $s_j$, so if it eats the $i$-th piece alone, it takes time $p_i / s_j$. The mice have special eating rules:\n\n1. At any moment, a mouse can eat at most one piece of cheese.\n2. At any moment, a piece of cheese can be eaten by at most one mouse.\n\nBecause the shelf life of cheese is often short, to eat all pieces, the mice can use a magical spell to extend the shelf life. Extending the shelf life by $T$ seconds means every $d_i$ becomes $d_i + T$. Since the spell is costly, the mice want the minimum $T$ such that all cheese can be eaten.", "inputFormat": "The first line contains an integer $K$, the number of test cases.\n\nFor each test case, the first line contains two integers $n$ and $m$, the numbers of cheese pieces and mice, respectively. The next $n$ lines each contain three integers $p_i, r_i, d_i$. The final $m$ lines each contain one integer $s_j$. The meanings of $p_i, r_i, d_i, s_j$ are as described above.", "outputFormat": "Output $K$ lines. Each line contains a real number, the minimum $T$ you found. The absolute error between your answer and the standard answer must not exceed $10^{-4}$.", "hint": "Sample Explanation:\n\nFor the first test case:\n\nFrom second $0$ to second $1$:\nThe first mouse eats the first piece of cheese.\n\nFrom second $1$ to second $3.5$:\n- The first mouse eats the second piece of cheese.\n- The second mouse eats the first piece of cheese.\n\nFrom second $3.5$ to second $4.5$: the first mouse eats the first piece of cheese.\n\nConstraints:\n\n- For $30\\%$ of the testdata, $1 \\le n, m \\le 5$.\n- For $100\\%$ of the testdata, $1 \\le K \\le 5$, $1 \\le n, m \\le 30$, $1 \\le p_i \\le 10^5$, $0 \\le r_i < d_i \\le 10^7$, $1 \\le s_j \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2010] 贪吃的老鼠", "background": "", "description": "奶酪店里最近出现了 $m$ 只老鼠！它们的目标就是把生产出来的所有奶酪都吃掉。奶酪店中一天会生产 $n$ 块奶酪，其中第 $i$ 块的大小为 $p_i$，会在第 $r_i$ 秒被生产出来，并且必须在第 $d_i$ 秒之前将它吃掉。第 $j$ 只老鼠吃奶酪的速度为 $s_j$，因此如果它单独吃完第 $i$ 块奶酪所需的时间为 $p_i/s_j$。老鼠们吃奶酪的习惯很独特，具体来说：\n\n1. 在任一时刻，一只老鼠最多可以吃一块奶酪；\n2. 在任一时刻，一块奶酪最多被一只老鼠吃。\n\n由于奶酪的保质期常常很短，为了将它们全部吃掉，老鼠们需要使用一种神奇的魔法来延长奶酪的保质期。将奶酪的保质期延长 $T$ 秒是指所有的奶酪的 $d_i$ 变成 $d_i+T$。同时，使用魔法的代价很高，因此老鼠们希望找到最小的 $T$ 使得可以吃掉所有的奶酪。", "inputFormat": "输入文件的第一行包含一个整数 $K$，表示输入文件中数据的组数。\n\n每组数据的第一行包含两个整数 $n$ 和 $m$，分别表示奶酪和老鼠的数量。接下来的 $n$ 行每行包含三个整数 $p_i,r_i,d_i$。最后 $m$ 行每行包含一个整数，表示 $s_j$。$p_i,r_i,d_i,s_j$ 的含义如上文所述。", "outputFormat": "包含 $K$ 行，每行包含一个实数，表示你找到的最小的 $T$。你的答案和标准答案的绝对误差不应超过 $10^{-4}$。", "hint": "### 样例说明\n\n第一组数据中：\n\n第 $0$ 到第 $1$ 秒：\n\n第一只老鼠吃第一块奶酪；\n\n第 $1$ 到第 $3.5$ 秒：\n\n- 第一只老鼠吃第二块奶酪；\n- 第二只老鼠吃第一块奶酪；\n\n第 $3.5$ 到第 $4.5$ 秒：第一只老鼠吃第一块奶酪。\n\n### 数据规模\n\n$30\\%$ 的数据中，$1 \\le n,m \\le 5$；\n\n$100\\%$ 的数据中，$1 \\le K \\le 5$，$1 \\le n,m \\le 30$，$1 \\le p_i \\le 10^5$，$0 \\le r_i<d_i \\le 10^7$，$1 \\le s_j \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P2571", "type": "P", "difficulty": 5, "samples": [["0 0 0 100\r\n100 0 100 100\r\n2 2 1\r\n", "136.60"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "四川", "各省省选"], "title": "[SCOI2010] 传送带", "background": "", "description": "在一个 $2$ 维平面上有两条传送带，每一条传送带可以看成是一条线段。两条传送带分别为线段 $\\text{AB}$ 和线段 $\\text{CD}$。lxhgww 在 $\\text{AB}$ 上的移动速度为 $P$，在 $\\text{CD}$ 上的移动速度为 $Q$，在平面上的移动速度 $R$。现在 lxhgww 想从 $\\text A$ 点走到 $\\text D$ 点，他想知道最少需要走多长时间。\n", "inputFormat": "第一行 $4$ 个整数，表示 $\\text A$ 和 $\\text B$ 的坐标，分别为 $A_x$，$A_y$，$B_x$，$B_y$。\n\n第二行 $4$ 个整数，表示 $\\text C$ 和 $\\text D$ 的坐标，分别为 $C_x$，$C_y$，$D_x$，$D_y$。\n\n第三行 $3$ 个整数，分别是 $P$，$Q$，$R$。", "outputFormat": "输出数据为一行，表示 lxhgww 从 $\\text A$ 点走到 $\\text D$ 点的最短时间，保留到小数点后 $2$ 位。", "hint": "对于 $100\\%$ 的数据，$1\\le A_x,A_y,B_x,B_y,C_x,C_y,D_x,D_y\\le10^3$，$1\\le P,Q,R\\le10$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2010] Conveyor Belt", "background": "", "description": "In a $2$-dimensional plane, there are two conveyor belts, each of which can be regarded as a line segment. The two conveyor belts are line segment $\\text{AB}$ and line segment $\\text{CD}$. lxhgww moves at speed $P$ on $\\text{AB}$, at speed $Q$ on $\\text{CD}$, and at speed $R$ on the plane. Now lxhgww wants to go from point $\\text{A}$ to point $\\text{D}$, and he wants to know the minimum time required.", "inputFormat": "The first line contains $4$ integers, giving the coordinates of $\\text{A}$ and $\\text{B}$, namely $A_x$, $A_y$, $B_x$, $B_y$.\n\nThe second line contains $4$ integers, giving the coordinates of $\\text{C}$ and $\\text{D}$, namely $C_x$, $C_y$, $D_x$, $D_y$.\n\nThe third line contains $3$ integers, which are $P$, $Q$, and $R$.", "outputFormat": "Output one line, the minimum time for lxhgww to go from point $\\text{A}$ to point $\\text{D}$, rounded to $2$ decimal places.", "hint": "For $100\\%$ of the testdata, $1 \\le A_x, A_y, B_x, B_y, C_x, C_y, D_x, D_y \\le 10^3$, $1 \\le P, Q, R \\le 10$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2010] 传送带", "background": "", "description": "在一个 $2$ 维平面上有两条传送带，每一条传送带可以看成是一条线段。两条传送带分别为线段 $\\text{AB}$ 和线段 $\\text{CD}$。lxhgww 在 $\\text{AB}$ 上的移动速度为 $P$，在 $\\text{CD}$ 上的移动速度为 $Q$，在平面上的移动速度 $R$。现在 lxhgww 想从 $\\text A$ 点走到 $\\text D$ 点，他想知道最少需要走多长时间。\n", "inputFormat": "第一行 $4$ 个整数，表示 $\\text A$ 和 $\\text B$ 的坐标，分别为 $A_x$，$A_y$，$B_x$，$B_y$。\n\n第二行 $4$ 个整数，表示 $\\text C$ 和 $\\text D$ 的坐标，分别为 $C_x$，$C_y$，$D_x$，$D_y$。\n\n第三行 $3$ 个整数，分别是 $P$，$Q$，$R$。", "outputFormat": "输出数据为一行，表示 lxhgww 从 $\\text A$ 点走到 $\\text D$ 点的最短时间，保留到小数点后 $2$ 位。", "hint": "对于 $100\\%$ 的数据，$1\\le A_x,A_y,B_x,B_y,C_x,C_y,D_x,D_y\\le10^3$，$1\\le P,Q,R\\le10$。", "locale": "zh-CN"}}}
{"pid": "P2572", "type": "P", "difficulty": 5, "samples": [["10 10\n0 0 0 1 1 0 1 0 1 1\n1 0 2\n3 0 5\n2 2 2\n4 0 4\n0 3 6\n2 3 7\n4 2 8\n1 0 5\n0 5 6\n3 3 9\n", "5\n2\n6\n5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2010", "四川", "线段树", "各省省选"], "title": "[SCOI2010] 序列操作", "background": "", "description": "lxhgww 最近收到了一个 $01$ 序列，序列里面包含了 $n$ 个数，下标从 $0$ 开始。这些数要么是 $0$，要么是 $1$，现在对于这个序列有五种变换操作和询问操作：\n\n- `0 l r` 把 $[l, r]$ 区间内的所有数全变成 $0$；\n- `1 l r` 把 $[l, r]$ 区间内的所有数全变成 $1$；\n- `2 l r` 把 $[l,r]$ 区间内的所有数全部取反，也就是说把所有的 $0$ 变成 $1$，把所有的 $1$ 变成 $0$；\n- `3 l r` 询问 $[l, r]$ 区间内总共有多少个 $1$；\n- `4 l r` 询问 $[l, r]$ 区间内最多有多少个连续的 $1$。\n\n对于每一种询问操作，lxhgww 都需要给出回答，聪明的程序员们，你们能帮助他吗？\n", "inputFormat": "第一行两个正整数 $n,m$，表示序列长度与操作个数。  \n第二行包括 $n$ 个数，表示序列的初始状态。  \n接下来 $m$ 行，每行三个整数，表示一次操作。\n", "outputFormat": "对于每一个询问操作，输出一行一个数，表示其对应的答案。\n", "hint": "【数据范围】  \n对于 $30\\%$ 的数据，$1\\le n,m \\le 1000$；  \n对于$100\\%$ 的数据，$1\\le n,m \\le 10^5$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2010] Sequence Operations", "background": "", "description": "lxhgww recently received a $01$ sequence containing $n$ numbers, indexed from $0$. Each number is either $0$ or $1$. There are five types of update and query operations on this sequence:\n\n- `0 l r` Set all numbers in the interval $[l, r]$ to $0$.\n- `1 l r` Set all numbers in the interval $[l, r]$ to $1$.\n- `2 l r` Flip all numbers in the interval $[l, r]$, that is, change every $0$ to $1$ and every $1$ to $0$.\n- `3 l r` Query how many $1$s are in the interval $[l, r]$.\n- `4 l r` Query the maximum number of consecutive $1$s in the interval $[l, r]$.\n\nFor each query operation, lxhgww needs to provide an answer. Clever programmers, can you help him?", "inputFormat": "The first line contains two positive integers $n, m$, representing the length of the sequence and the number of operations.  \nThe second line contains $n$ numbers, representing the initial state of the sequence.  \nThen follow $m$ lines, each containing three integers, representing one operation.", "outputFormat": "For each query operation, output one line with a single integer representing the corresponding answer.", "hint": "Constraints  \nFor $30\\%$ of the testdata, $1 \\le n, m \\le 1000$.  \nFor $100\\%$ of the testdata, $1 \\le n, m \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2010] 序列操作", "background": "", "description": "lxhgww 最近收到了一个 $01$ 序列，序列里面包含了 $n$ 个数，下标从 $0$ 开始。这些数要么是 $0$，要么是 $1$，现在对于这个序列有五种变换操作和询问操作：\n\n- `0 l r` 把 $[l, r]$ 区间内的所有数全变成 $0$；\n- `1 l r` 把 $[l, r]$ 区间内的所有数全变成 $1$；\n- `2 l r` 把 $[l,r]$ 区间内的所有数全部取反，也就是说把所有的 $0$ 变成 $1$，把所有的 $1$ 变成 $0$；\n- `3 l r` 询问 $[l, r]$ 区间内总共有多少个 $1$；\n- `4 l r` 询问 $[l, r]$ 区间内最多有多少个连续的 $1$。\n\n对于每一种询问操作，lxhgww 都需要给出回答，聪明的程序员们，你们能帮助他吗？\n", "inputFormat": "第一行两个正整数 $n,m$，表示序列长度与操作个数。  \n第二行包括 $n$ 个数，表示序列的初始状态。  \n接下来 $m$ 行，每行三个整数，表示一次操作。\n", "outputFormat": "对于每一个询问操作，输出一行一个数，表示其对应的答案。\n", "hint": "【数据范围】  \n对于 $30\\%$ 的数据，$1\\le n,m \\le 1000$；  \n对于$100\\%$ 的数据，$1\\le n,m \\le 10^5$。\n", "locale": "zh-CN"}}}
{"pid": "P2573", "type": "P", "difficulty": 5, "samples": [["3 3 \n3 2 1 \n1 2 1 \n2 3 1 \n1 3 10 ", "3 2"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "2012", "四川", "各省省选", "排序", "生成树"], "title": "[SCOI2012] 滑雪", "background": null, "description": "a180285 非常喜欢滑雪。他来到一座雪山，这里分布着 $m$ 条供滑行的轨道和 $n$ 个轨道之间的交点（同时也是景点），而且每个景点都有一编号 $i\\space (1 \\le i \\le n)$ 和一高度 $h_i$。  \n\na180285 能从景点 $i$ 滑到景点 $j$ 当且仅当存在一条 $i$ 和 $j$ 之间的边，且 $i$ 的高度**不小于** $j$。与其他滑雪爱好者不同，a180285 喜欢用最短的滑行路径去访问尽量多的景点。如果仅仅访问一条路径上的景点，他会觉得数量太少。\n\n于是 a180285 拿出了他随身携带的时间胶囊。这是一种很神奇的药物，吃下之后可以立即回到上个经过的景点（不用移动也不被认为是 a180285 滑行的距离）。  \n\n请注意，这种神奇的药物是可以连续食用的，即能够回到较长时间之前到过的景点（比如上上个经过的景点和上上上个经过的景点）。 现在，a180285 站在 $1$ 号景点望着山下的目标，心潮澎湃。他十分想知道在不考虑时间胶囊消耗的情况下，以最短滑行距离滑到尽量多的景点的方案（即满足经过景点数最大的前提下使得滑行总距离最小）。你能帮他求出最短距离和景点数吗？", "inputFormat": "输入的第一行是两个整数 $n,m$。接下来一行有 $n$ 个整数 $h_i$，分别表示每个景点的高度。\n\n接下来 $m$ 行，表示各个景点之间轨道分布的情况。每行三个整数 $u,v,k$，表示编号为 $u$ 的景点和编号为 $v$ 的景点之间有一条长度为 $k$ 的轨道。", "outputFormat": "输出一行，表示 a180285 最多能到达多少个景点，以及此时最短的滑行距离总和。", "hint": "对于 $ 30\\% $ 的数据，$ 1 \\le n \\le 2000 $；\n\n对于 $ 100\\% $ 的数据，$ 1 \\le n \\le 10^5 , 1 \\le m \\le 10^6 , 1 \\le h_i \\le 10^9 , 1 \\le k_i \\le 10^9 $。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2012] Skiing", "background": "", "description": "a180285 is very fond of skiing. He comes to a snowy mountain with $m$ ski tracks and $n$ intersections between tracks (which are also scenic spots). Each scenic spot has an index $i\\space (1 \\le i \\le n)$ and a height $h_i$.\n\na180285 can ski from spot $i$ to spot $j$ if and only if there is an edge between $i$ and $j$, and the height at $i$ is **not less than** that at $j$. Unlike other ski enthusiasts, a180285 prefers to visit as many spots as possible using the shortest skiing route. If he only visits the spots along a single path, he feels the number is too small.\n\nSo a180285 takes out his portable time capsule. It is a magical medicine that, after being taken, can immediately return him to the last visited spot (this does not require movement and is not counted in a180285’s skiing distance).\n\nNote that this magical medicine can be taken consecutively, allowing him to return to spots visited a longer time ago (for example, the previous, the one before that, or the one even earlier). Now, a180285 stands at spot $1$, gazing at the goals downhill, full of excitement. He wants to know, ignoring the consumption of time capsules, the plan that uses the shortest skiing distance to reach as many scenic spots as possible (i.e., among all plans that maximize the number of visited spots, minimize the total skiing distance). Can you help him find the minimum distance and the number of spots?", "inputFormat": "The first line contains two integers $n, m$.  \nThe next line contains $n$ integers $h_i$, representing the height of each scenic spot.\n\nThen there are $m$ lines, each with three integers $u, v, k$, indicating there is a track of length $k$ between spots $u$ and $v$.", "outputFormat": "Output one line with two integers: the maximum number of scenic spots a180285 can reach, and the minimum total skiing distance in that case.", "hint": "For $30\\%$ of the testdata, $1 \\le n \\le 2000$.\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 10^5$, $1 \\le m \\le 10^6$, $1 \\le h_i \\le 10^9$, $1 \\le k_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2012] 滑雪", "background": null, "description": "a180285 非常喜欢滑雪。他来到一座雪山，这里分布着 $m$ 条供滑行的轨道和 $n$ 个轨道之间的交点（同时也是景点），而且每个景点都有一编号 $i\\space (1 \\le i \\le n)$ 和一高度 $h_i$。  \n\na180285 能从景点 $i$ 滑到景点 $j$ 当且仅当存在一条 $i$ 和 $j$ 之间的边，且 $i$ 的高度**不小于** $j$。与其他滑雪爱好者不同，a180285 喜欢用最短的滑行路径去访问尽量多的景点。如果仅仅访问一条路径上的景点，他会觉得数量太少。\n\n于是 a180285 拿出了他随身携带的时间胶囊。这是一种很神奇的药物，吃下之后可以立即回到上个经过的景点（不用移动也不被认为是 a180285 滑行的距离）。  \n\n请注意，这种神奇的药物是可以连续食用的，即能够回到较长时间之前到过的景点（比如上上个经过的景点和上上上个经过的景点）。 现在，a180285 站在 $1$ 号景点望着山下的目标，心潮澎湃。他十分想知道在不考虑时间胶囊消耗的情况下，以最短滑行距离滑到尽量多的景点的方案（即满足经过景点数最大的前提下使得滑行总距离最小）。你能帮他求出最短距离和景点数吗？", "inputFormat": "输入的第一行是两个整数 $n,m$。接下来一行有 $n$ 个整数 $h_i$，分别表示每个景点的高度。\n\n接下来 $m$ 行，表示各个景点之间轨道分布的情况。每行三个整数 $u,v,k$，表示编号为 $u$ 的景点和编号为 $v$ 的景点之间有一条长度为 $k$ 的轨道。", "outputFormat": "输出一行，表示 a180285 最多能到达多少个景点，以及此时最短的滑行距离总和。", "hint": "对于 $ 30\\% $ 的数据，$ 1 \\le n \\le 2000 $；\n\n对于 $ 100\\% $ 的数据，$ 1 \\le n \\le 10^5 , 1 \\le m \\le 10^6 , 1 \\le h_i \\le 10^9 , 1 \\le k_i \\le 10^9 $。", "locale": "zh-CN"}}}
{"pid": "P2574", "type": "P", "difficulty": 4, "samples": [["10 6\n1011101001\n0 2 4\n1 1 5\n0 3 7\n1 1 10\n0 1 4\n1 2 6\n", "3\n6\n1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["线段树", "洛谷原创"], "title": "XOR的艺术", "background": "", "description": "AKN 觉得第一题太水了，不屑于写第一题，所以他又玩起了新的游戏。在游戏中，他发现，这个游戏的伤害计算有一个规律，规律如下：\n\n1. 拥有一个伤害串，是一个长度为 $n$ 的只含字符 ``0`` 和字符 ``1`` 的字符串。规定这个字符串的首字符是第一个字符，即下标从 $1$ 开始。\n2. 给定一个范围 $[l,~r]$，伤害为伤害串的这个范围内中字符 ``1`` 的个数。\n3. 会修改伤害串中的数值，修改的方法是把 $[l,~r]$ 中所有原来的字符 ``0`` 变成 ``1``，将 ``1`` 变成 ``0``。\n\nAKN 想知道一些时刻的伤害，请你帮助他求出这个伤害。", "inputFormat": "输入的第一行有两个用空格隔开的整数，分别表示伤害串的长度 $n$，和操作的个数 $m$。\n\n输入第二行是一个长度为 $n$ 的字符串 $S$，代表伤害串。\n\n第 $3$ 到第 $(m + 2)$ 行，每行有三个用空格隔开的整数 $op, l, r$。代表第 $i$ 次操作的方式和区间，规则是：\n\n- 若 $op = 0$，则表示将伤害串的 $[l,~r]$ 区间内的 ``0`` 变成 ``1``，``1`` 变成 ``0``。\n- 若 $op = 1$，则表示询问伤害串的 $[l,~r]$ 区间内有多少个字符 ``1``。", "outputFormat": "对于每次询问，输出一行一个整数，代表区间内 ``1`` 的个数。\n", "hint": "#### 样例输入输出 $1$ 解释\n\n原伤害串为 ``1011101001``。\n\n对于第一次操作，改变 $[2,~4]$ 的字符，伤害串变为 ``1100101001``。\n\n对于第二次操作，查询 $[1,~5]$ 内 ``1`` 的个数，共有 $3$ 个。\n\n对于第三次操作，改变 $[3,~7]$ 的字符，伤害串变为 ``1111010001``。\n\n对于第四次操作，查询 $[1,~10]$ 内 ``1`` 的个数，共有 $6$ 个。\n\n对于第五次操作，改变 $[1,~4]$ 的字符，伤害串变为 ``0000010001``。\n\n对于第六次操作，查询 $[2,~6]$ 内 ``1`` 的个数，共有 $1$ 个。\n\n#### 数据范围与约定\n\n对于 $10\\%$ 的数据，保证 $n, m \\leq 10$。\n\n另有 $30\\%$ 的数据，保证 $n, m \\leq 2 \\times 10^3$。\n\n对于 $100\\%$ 的数据，保证 $2 \\leq n, m \\leq 2 \\times 10^5$，$0 \\leq op \\leq 1$，$1 \\leq l \\leq r \\leq n$，$S$ 中只含字符 ``0`` 和字符 ``1``。", "locale": "zh-CN", "translations": {"en": {"title": "The Art of XOR", "background": "", "description": "AKN thought the first problem was too easy and refused to write it, so he started a new game. In the game, he found a pattern in the damage calculation, as follows:\n\n1. There is a damage string, which is a string of length $n$ consisting only of the characters ``0`` and ``1``. The first character is considered the first position, i.e., indices start from $1$.\n2. Given a range $[l,~r]$, the damage is the number of characters ``1`` within that range of the damage string.\n3. The damage string can be modified by toggling all characters in $[l,~r]$: change every ``0`` to ``1`` and every ``1`` to ``0``.\n\nAKN wants to know the damage at certain times. Please help him compute it.", "inputFormat": "The first line contains two integers separated by a space, representing the length $n$ of the damage string and the number of operations $m$.\n\nThe second line is a string $S$ of length $n$, representing the damage string.\n\nFrom the $3$-rd to the $(m + 2)$-nd line, each line contains three integers $op, l, r$, representing the type and interval of the $i$-th operation. The rules are:\n\n- If $op = 0$, toggle the characters in the interval $[l,~r]$ of the damage string: change ``0`` to ``1`` and ``1`` to ``0``.\n- If $op = 1$, query how many characters ``1`` are in the interval $[l,~r]$ of the damage string.", "outputFormat": "For each query, output a single line with one integer, representing the number of ``1`` in the interval.", "hint": "Explanation for Sample Input/Output 1:\n\nThe original damage string is ``1011101001``.\n\nFor the first operation, toggle the characters in $[2,~4]$, and the damage string becomes ``1100101001``.\n\nFor the second operation, query the number of ``1`` in $[1,~5]$, which is $3$.\n\nFor the third operation, toggle the characters in $[3,~7]$, and the damage string becomes ``1111010001``.\n\nFor the fourth operation, query the number of ``1`` in $[1,~10]$, which is $6$.\n\nFor the fifth operation, toggle the characters in $[1,~4]$, and the damage string becomes ``0000010001``.\n\nFor the sixth operation, query the number of ``1`` in $[2,~6]$, which is $1$.\n\nConstraints:\n\n- For $10\\%$ of the testdata, it is guaranteed that $n, m \\leq 10$.\n- For an additional $30\\%$ of the testdata, it is guaranteed that $n, m \\leq 2 \\times 10^3$.\n- For $100\\%$ of the testdata, it is guaranteed that $2 \\leq n, m \\leq 2 \\times 10^5$, $0 \\leq op \\leq 1$, $1 \\leq l \\leq r \\leq n$, and $S$ contains only the characters ``0`` and ``1``.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "XOR的艺术", "background": "", "description": "AKN 觉得第一题太水了，不屑于写第一题，所以他又玩起了新的游戏。在游戏中，他发现，这个游戏的伤害计算有一个规律，规律如下：\n\n1. 拥有一个伤害串，是一个长度为 $n$ 的只含字符 ``0`` 和字符 ``1`` 的字符串。规定这个字符串的首字符是第一个字符，即下标从 $1$ 开始。\n2. 给定一个范围 $[l,~r]$，伤害为伤害串的这个范围内中字符 ``1`` 的个数。\n3. 会修改伤害串中的数值，修改的方法是把 $[l,~r]$ 中所有原来的字符 ``0`` 变成 ``1``，将 ``1`` 变成 ``0``。\n\nAKN 想知道一些时刻的伤害，请你帮助他求出这个伤害。", "inputFormat": "输入的第一行有两个用空格隔开的整数，分别表示伤害串的长度 $n$，和操作的个数 $m$。\n\n输入第二行是一个长度为 $n$ 的字符串 $S$，代表伤害串。\n\n第 $3$ 到第 $(m + 2)$ 行，每行有三个用空格隔开的整数 $op, l, r$。代表第 $i$ 次操作的方式和区间，规则是：\n\n- 若 $op = 0$，则表示将伤害串的 $[l,~r]$ 区间内的 ``0`` 变成 ``1``，``1`` 变成 ``0``。\n- 若 $op = 1$，则表示询问伤害串的 $[l,~r]$ 区间内有多少个字符 ``1``。", "outputFormat": "对于每次询问，输出一行一个整数，代表区间内 ``1`` 的个数。\n", "hint": "#### 样例输入输出 $1$ 解释\n\n原伤害串为 ``1011101001``。\n\n对于第一次操作，改变 $[2,~4]$ 的字符，伤害串变为 ``1100101001``。\n\n对于第二次操作，查询 $[1,~5]$ 内 ``1`` 的个数，共有 $3$ 个。\n\n对于第三次操作，改变 $[3,~7]$ 的字符，伤害串变为 ``1111010001``。\n\n对于第四次操作，查询 $[1,~10]$ 内 ``1`` 的个数，共有 $6$ 个。\n\n对于第五次操作，改变 $[1,~4]$ 的字符，伤害串变为 ``0000010001``。\n\n对于第六次操作，查询 $[2,~6]$ 内 ``1`` 的个数，共有 $1$ 个。\n\n#### 数据范围与约定\n\n对于 $10\\%$ 的数据，保证 $n, m \\leq 10$。\n\n另有 $30\\%$ 的数据，保证 $n, m \\leq 2 \\times 10^3$。\n\n对于 $100\\%$ 的数据，保证 $2 \\leq n, m \\leq 2 \\times 10^5$，$0 \\leq op \\leq 1$，$1 \\leq l \\leq r \\leq n$，$S$ 中只含字符 ``0`` 和字符 ``1``。", "locale": "zh-CN"}}}
{"pid": "P2575", "type": "P", "difficulty": 5, "samples": [["2\n1\n2 19 20\n2\n1 19\n1 18\n", "NO\nYES\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["博弈论", "SG 函数"], "title": "高手过招", "background": null, "description": "AKN 玩游戏玩累了，于是他开始和同伴下棋了，玩的是跳棋！对手是 wwx！这两位上古神遇在一起下棋，使得棋局变得玄幻莫测，高手过招，必有一赢，他们都将用最佳策略下棋，现在给你一个 $n \\times 20$ 的棋盘，以及棋盘上有若干个棋子，问谁赢？akn 先手！\n\n游戏规则是这样的：\n\n对于一个棋子，能将它向右移动一格，如果右边有空格，则向右跳到第一个空格，如果右边没有空格，则不能移动这个棋子，如果所有棋子都不能移动，那么将输掉这场比赛。", "inputFormat": "第一行一个 $T$，表示 $T$ 组数据。\n\n每组数据第一行 $n$，表示 $n \\times 20$ 的棋盘。\n\n接下来 $n$ 行每行第一个数 $m$ 表示第 $i$ 行有 $m$ 个棋子。\n\n随后跟着 $m$ 个数 $p_j$ 表示第 $i$ 行的棋子布局。", "outputFormat": "如果 AKN 能赢，则输出 `YES`，否则输出 `NO`。", "hint": "$10\\%$ 的数据 $T \\leq 1,n \\leq 1$。\n\n另外 $10\\%$ 的数据 $m \\leq 1$。\n\n$100\\%$ 的数据 $T \\leq 100$，$n \\leq  1000$，$m \\leq 20$，$1 \\leq p_j \\leq 20$。", "locale": "zh-CN", "translations": {"en": {"title": "Clash of Masters", "background": "", "description": "AKN got tired of playing video games, so he started a game of checkers with his teammate. The opponent is wwx. When these two ancient masters meet over the board, the game becomes unpredictable. When masters clash, there will be a winner. They both play optimally. You are given an $n \\times 20$ board with some pieces on it. Who wins? AKN moves first.\n\nThe rules of the game are as follows:\n- For any piece, you may move it one cell to the right. If there is a piece immediately to its right, then jump to the first empty cell to the right. If there is no empty cell to the right, you cannot move this piece. If none of the pieces can move, you lose the game.", "inputFormat": "The first line contains $T$, the number of test cases.\n\nFor each test case, the first line contains $n$, indicating an $n \\times 20$ board.\n\nThen follow $n$ lines; on each line, the first number $m$ indicates that row $i$ has $m$ pieces.\n\nIt is then followed by $m$ numbers $p_j$ describing the piece positions in row $i$.", "outputFormat": "If AKN can win, print `YES`; otherwise, print `NO`.", "hint": "$10\\%$ of the testdata has $T \\leq 1, n \\leq 1$.\n\nAdditionally, $10\\%$ of the testdata has $m \\leq 1$.\n\nFor $100\\%$ of the testdata, $T \\leq 100$, $n \\leq 1000$, $m \\leq 20$, $1 \\leq p_j \\leq 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "高手过招", "background": null, "description": "AKN 玩游戏玩累了，于是他开始和同伴下棋了，玩的是跳棋！对手是 wwx！这两位上古神遇在一起下棋，使得棋局变得玄幻莫测，高手过招，必有一赢，他们都将用最佳策略下棋，现在给你一个 $n \\times 20$ 的棋盘，以及棋盘上有若干个棋子，问谁赢？akn 先手！\n\n游戏规则是这样的：\n\n对于一个棋子，能将它向右移动一格，如果右边有空格，则向右跳到第一个空格，如果右边没有空格，则不能移动这个棋子，如果所有棋子都不能移动，那么将输掉这场比赛。", "inputFormat": "第一行一个 $T$，表示 $T$ 组数据。\n\n每组数据第一行 $n$，表示 $n \\times 20$ 的棋盘。\n\n接下来 $n$ 行每行第一个数 $m$ 表示第 $i$ 行有 $m$ 个棋子。\n\n随后跟着 $m$ 个数 $p_j$ 表示第 $i$ 行的棋子布局。", "outputFormat": "如果 AKN 能赢，则输出 `YES`，否则输出 `NO`。", "hint": "$10\\%$ 的数据 $T \\leq 1,n \\leq 1$。\n\n另外 $10\\%$ 的数据 $m \\leq 1$。\n\n$100\\%$ 的数据 $T \\leq 100$，$n \\leq  1000$，$m \\leq 20$，$1 \\leq p_j \\leq 20$。", "locale": "zh-CN"}}}
{"pid": "P2576", "type": "P", "difficulty": 6, "samples": [["4\r\n\r\n1 7\r\n3 1 7 6 5 4 2\r\n\r\n2 2\r\n1 2\r\n3 4\r\n\r\n2 3\r\n2 1 6\r\n3 4 5\r\n\r\n4 4\r\n11 12 15 14\r\n10 9 16 13\r\n5 8 1 2\r\n6 7 4 3\r\n", "AllRight\r\nCheat\r\nAllRight\r\nAllRight\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "各省省选", "浙江"], "title": "[ZJOI2005] 梦幻折纸", "background": "你是一个喜欢幻想的小女孩，特别喜欢追求一些完美的理想的东西——“理想的圆”，“理想的均等”，“理想的材料”，“理想的最优解”……\n\n最近，偶然的机会，你迷恋上了折纸。你把自己的作业本扯下来折成了各种各样的小把戏——小花，小草，小鸟，小兔子，小老鼠……一张又一张，直到作业本的封面都被你折成了纸鹤。但是你还是觉得不过瘾。\n\n终于……你克制不住自己心中压抑的想法，从可怜的同桌那儿拿了一张用过的草稿纸。正当你打算用同样的方法折掉它的时候，你十分惊奇的发现：这不是一张普通的草稿纸，而是一张非常特殊的草稿纸：它薄得厚度可以忽略不计，柔韧得怎么撕也撕不破，而且无论怎么折都行。\n\n你如获至宝，这不就是你梦寐以求的“理想的材料”吗？真所谓“踏破铁鞋无觅处，得来全不费功夫。梦里寻它千百度，蓦然回首，它却在灯火阑珊处 ！”你决心要把它折成一个有难度一点的东西，才对得住一张这么好的纸。", "description": "你仔细观察了一下纸的特点：\n\n纸的大小为 $n \\times m$，上面等距离的印好了格线，$n-1$ 条横线和 $m-1$ 条竖线（线的宽度忽略不计）。这些格线将纸分成了 $n \\times m$ 个大小完全相同的正方形小格。你的同桌已经在每一块小格 $(i,j)$ 上写下了一个互不相同的正整数 $P_{i,j}$，$1 \\le P_{i,j} \\le n \\times m$。\n\n“他干嘛在纸上写下这么些数字呢？”你看着这些数字，疑惑不解。\n\n这时，你的同桌突然出现了，他发现你正拿着他的纸，看着上面的数字发呆。于是傻乎乎地对你说：\n\n“我刚刚也想学你折纸，可是我很笨，只折出一个 $1 \\times 1$ 的正方形，也就是一个 $n \\times m$ 层纸的纸垛，每一层恰好是一个小格，所有的格线都恰好在正方形的边界上。”\n\n“哦，折得不错，挺好的。”你口里说不错，心里却暗笑：没见过你这么笨的。居然把这么好的纸折成一个如此简单的正方形，简直是暴殄天物，罪过啊，罪过！\n\n“是吗？你也觉得不错啊？我刚刚就在想，如果给这些小格编上号，最上面一层编为 $1$，从上往下数的第 $i$ 层编为 $i$，那么能不能从这些编号复原出刚刚我折的那个图形呢？于是我就在这些格子上写下了它们的编号”\n\n“这……”你一时语塞，确切的说，惊讶得说不出话来，原来一向傻乎乎的同桌脑子里也有这么深奥的想法。\n\n“这样吧，如果你能根据我把我刚刚折的正方形折出来，那我就把这张纸送给你！” 同桌接着说，“不管你折法是否和我一样，只要折出来也是个 $1 \\times 1$ 的正方形，从上往下数的第 $i$ 层的编号恰好也是 $i$，并且纸不能破，就算你折对了。”\n\n“好啊，不过我先要检查检查你有没有骗我，要是你故意骗我或者自己粗心在编号的时候写错了数字而害得我折不出来，我可饶不了你！”", "inputFormat": "第一行为整数 $t$，代表输入数据的总数。\n\n以下有 $t$ 组数据，每组数据的结构如下：\n\n第一行两个正整数 $n,m$。\n\n以下 $n$ 行，每行 $m$ 个正整数，相邻两个整数之间用一个空格隔开，描述矩阵 $P_{i,j}$。", "outputFormat": "输出 $t$ 行，对应 $t$ 个输入数据。\n\n对于第 $i$ 组数据，输出 `AllRight`——如果可以折出来；输出 `Cheat`——如果折不出来。", "hint": "- $1 \\le t \\le 10$\n\n- $1 \\le n, m \\le 100$", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2005] Fantasy Origami", "background": "You are a girl who loves to daydream, especially about perfect ideals—“ideal circles,” “ideal equality,” “ideal materials,” “ideal optimal solutions”…\n\nRecently, by chance, you fell in love with origami. You tore pages from your notebook and folded all kinds of little tricks—little flowers, little grasses, little birds, little rabbits, little mice… page after page, until even the cover was folded into a paper crane. But you still didn’t feel satisfied.\n\nFinally… you couldn’t hold back your urge. You took a used scratch paper from your poor deskmate. Just as you were about to fold it the same way, you were amazed to find: this was not an ordinary scratch paper, but a very special one. It was so thin that its thickness could be ignored, so tough that it wouldn’t tear no matter how you pulled, and it could be folded in any way you wanted.\n\nYou were thrilled—wasn’t this the “ideal material” you had dreamed of? As the saying goes, “after searching everywhere in iron shoes and finding nothing, it all comes without effort; seeking it a thousand times in dreams, suddenly turning back, there it is where the lights are dim!” You decided to fold something a bit more challenging to be worthy of such a good piece of paper.", "description": "You carefully observe the features of the paper:\n\nThe paper has size $n \\times m$, with equally spaced grid lines printed on it: $n - 1$ horizontal lines and $m - 1$ vertical lines (line width ignored). These grid lines divide the paper into $n \\times m$ small squares of exactly the same size. Your deskmate has already written on each small square $(i, j)$ a distinct positive integer $P_{i, j}$ with $1 \\le P_{i, j} \\le n \\times m$.\n\n“Why did he write so many numbers on the paper?” You look at these numbers, puzzled.\n\nAt this moment, your deskmate suddenly shows up. He finds you holding his paper, staring at the numbers in a daze. So he says, a bit silly:\n\n“I just tried to learn origami from you, but I’m clumsy. I only folded a $1 \\times 1$ square, that is, a stack of $n \\times m$ layers of paper, with each layer exactly one small square, and all grid lines exactly on the boundary of the square.”\n\n“Oh, that’s nice, pretty good.” You say it’s good, but secretly laugh: never seen anyone as clumsy as you. Folding such a great paper into such a simple square—what a waste!\n\n“Really? You also think it’s good? I was just thinking, if we number these small squares, label the top layer as $1$, and label the $i$-th layer counted from top to bottom as $i$, can we reconstruct the exact figure I folded from these numbers? So I wrote their labels on the squares.”\n\n“This…” You are at a loss for words—more precisely, so surprised you cannot speak. Turns out your usually silly deskmate has such a deep thought.\n\n“How about this: if you can fold the square I folded just now based on my labels, I’ll give you this paper!” he continues. “No matter whether your sequence of folds is the same as mine or not, as long as you also get a $1 \\times 1$ square, the $i$-th layer from top to bottom is exactly labeled $i$, and the paper is not torn, then you did it right.”\n\n“Alright, but I’ll first check whether you’re trying to fool me. If you deliberately cheat or made careless mistakes when writing the labels so that I cannot fold it, I won’t let you off!”", "inputFormat": "The first line contains an integer $t$, the total number of testcases.\n\nThen there are $t$ testcases, each with the following structure:\n\n- The first line contains two positive integers $n, m$.\n- The next $n$ lines each contain $m$ positive integers, separated by a single space, describing the matrix $P_{i, j}$.", "outputFormat": "Output $t$ lines, one for each testcase.\n\nFor the $i$-th testcase, output `AllRight` if it can be folded as required; otherwise output `Cheat` if it cannot.", "hint": "- $1 \\le t \\le 10$.\n- $1 \\le n, m \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2005] 梦幻折纸", "background": "你是一个喜欢幻想的小女孩，特别喜欢追求一些完美的理想的东西——“理想的圆”，“理想的均等”，“理想的材料”，“理想的最优解”……\n\n最近，偶然的机会，你迷恋上了折纸。你把自己的作业本扯下来折成了各种各样的小把戏——小花，小草，小鸟，小兔子，小老鼠……一张又一张，直到作业本的封面都被你折成了纸鹤。但是你还是觉得不过瘾。\n\n终于……你克制不住自己心中压抑的想法，从可怜的同桌那儿拿了一张用过的草稿纸。正当你打算用同样的方法折掉它的时候，你十分惊奇的发现：这不是一张普通的草稿纸，而是一张非常特殊的草稿纸：它薄得厚度可以忽略不计，柔韧得怎么撕也撕不破，而且无论怎么折都行。\n\n你如获至宝，这不就是你梦寐以求的“理想的材料”吗？真所谓“踏破铁鞋无觅处，得来全不费功夫。梦里寻它千百度，蓦然回首，它却在灯火阑珊处 ！”你决心要把它折成一个有难度一点的东西，才对得住一张这么好的纸。", "description": "你仔细观察了一下纸的特点：\n\n纸的大小为 $n \\times m$，上面等距离的印好了格线，$n-1$ 条横线和 $m-1$ 条竖线（线的宽度忽略不计）。这些格线将纸分成了 $n \\times m$ 个大小完全相同的正方形小格。你的同桌已经在每一块小格 $(i,j)$ 上写下了一个互不相同的正整数 $P_{i,j}$，$1 \\le P_{i,j} \\le n \\times m$。\n\n“他干嘛在纸上写下这么些数字呢？”你看着这些数字，疑惑不解。\n\n这时，你的同桌突然出现了，他发现你正拿着他的纸，看着上面的数字发呆。于是傻乎乎地对你说：\n\n“我刚刚也想学你折纸，可是我很笨，只折出一个 $1 \\times 1$ 的正方形，也就是一个 $n \\times m$ 层纸的纸垛，每一层恰好是一个小格，所有的格线都恰好在正方形的边界上。”\n\n“哦，折得不错，挺好的。”你口里说不错，心里却暗笑：没见过你这么笨的。居然把这么好的纸折成一个如此简单的正方形，简直是暴殄天物，罪过啊，罪过！\n\n“是吗？你也觉得不错啊？我刚刚就在想，如果给这些小格编上号，最上面一层编为 $1$，从上往下数的第 $i$ 层编为 $i$，那么能不能从这些编号复原出刚刚我折的那个图形呢？于是我就在这些格子上写下了它们的编号”\n\n“这……”你一时语塞，确切的说，惊讶得说不出话来，原来一向傻乎乎的同桌脑子里也有这么深奥的想法。\n\n“这样吧，如果你能根据我把我刚刚折的正方形折出来，那我就把这张纸送给你！” 同桌接着说，“不管你折法是否和我一样，只要折出来也是个 $1 \\times 1$ 的正方形，从上往下数的第 $i$ 层的编号恰好也是 $i$，并且纸不能破，就算你折对了。”\n\n“好啊，不过我先要检查检查你有没有骗我，要是你故意骗我或者自己粗心在编号的时候写错了数字而害得我折不出来，我可饶不了你！”", "inputFormat": "第一行为整数 $t$，代表输入数据的总数。\n\n以下有 $t$ 组数据，每组数据的结构如下：\n\n第一行两个正整数 $n,m$。\n\n以下 $n$ 行，每行 $m$ 个正整数，相邻两个整数之间用一个空格隔开，描述矩阵 $P_{i,j}$。", "outputFormat": "输出 $t$ 行，对应 $t$ 个输入数据。\n\n对于第 $i$ 组数据，输出 `AllRight`——如果可以折出来；输出 `Cheat`——如果折不出来。", "hint": "- $1 \\le t \\le 10$\n\n- $1 \\le n, m \\le 100$", "locale": "zh-CN"}}}
{"pid": "P2577", "type": "P", "difficulty": 4, "samples": [["5\r\n2 2\r\n7 7\r\n1 3\r\n6 4\r\n8 5\r\n", "17"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2004", "各省省选", "浙江", "排序"], "title": "[ZJOI2004] 午餐", "background": null, "description": "上午的训练结束了，THU ACM 小组集体去吃午餐，他们一行 $N$ 人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。\n\nTHU ACM 小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。\n\n现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。\n\n假设 THU ACM 小组在时刻 $0$ 到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。\n\n现在给定 $N$ 个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。", "inputFormat": "第一行一个整数 $N$，代表总共有 $N$ 个人。\n\n以下 $N$ 行，每行两个整数 $A_i,B_i$，依次代表第 $i$ 个人的打饭时间和吃饭时间。", "outputFormat": "一个整数 $T$，代表所有人吃完饭的最早时刻。", "hint": "所有输入数据均为不超过 $200$ 的正整数。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2004] Lunch", "background": "", "description": "After the morning training, the THU ACM team goes to have lunch. A group of $N$ people arrive at the famous Canteen No. 10. There are two serving windows, and each window can serve at most one person at a time. Because everyone has different tastes (and appetites), the time needed to be served varies by person. Everyone also eats at a different speed, so the eating time may also differ.\n\nTheir plan is: first split all people into two queues and decide the order within each queue. Then queue 1 lines up at window 1, and queue 2 at window 2. Each person starts eating immediately after being served. As soon as everyone finishes eating, they gather to go to the basement of Teaching Building No. 6 for the afternoon training.\n\nGiven the serving time and eating time of each person, arrange the teams and the order to make the time when everyone finishes eating as early as possible.\n\nAssume the THU ACM team arrives at time $0$, and there are no other diners in the canteen (only the servers). Each person must be assigned to exactly one queue. The two windows operate in parallel and do not affect each other, and a person’s serving time is independent of the window. After being served, each person starts eating immediately with no delay.\n\nGiven the serving and eating times of $N$ people, output the time when everyone finishes eating under the optimal plan.", "inputFormat": "The first line contains an integer $N$, the total number of people.\n\nEach of the next $N$ lines contains two integers $A_i, B_i$, representing the $i$-th person’s serving time and eating time.", "outputFormat": "A single integer $T$, the earliest time when everyone has finished eating.", "hint": "Constraints: All input numbers are positive integers not exceeding $200$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2004] 午餐", "background": null, "description": "上午的训练结束了，THU ACM 小组集体去吃午餐，他们一行 $N$ 人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。\n\nTHU ACM 小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。\n\n现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。\n\n假设 THU ACM 小组在时刻 $0$ 到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。\n\n现在给定 $N$ 个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。", "inputFormat": "第一行一个整数 $N$，代表总共有 $N$ 个人。\n\n以下 $N$ 行，每行两个整数 $A_i,B_i$，依次代表第 $i$ 个人的打饭时间和吃饭时间。", "outputFormat": "一个整数 $T$，代表所有人吃完饭的最早时刻。", "hint": "所有输入数据均为不超过 $200$ 的正整数。", "locale": "zh-CN"}}}
